head	1.35;
access;
symbols;
locks; strict;
comment	@# @;


1.35
date	2003.03.23.20.20.56;	author tg;	state dead;
branches;
next	1.34;

1.34
date	2003.03.22.22.33.31;	author tg;	state Exp;
branches;
next	1.33;

1.33
date	2003.03.22.16.14.25;	author tg;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.07.20.32.48;	author tg;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.07.18.06.52;	author tg;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.04.16.52.30;	author tg;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.02.01.08.35;	author tg;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.01.15.23.52;	author tg;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.01.13.16.09;	author tg;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.01.10.05.37;	author tg;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.28.18.22.12;	author tg;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.24.21.32.08;	author tg;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.23.17.59.46;	author tg;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.11.21.08.32;	author tg;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.11.20.02.19;	author tg;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.10.19.41.27;	author tg;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.27.21.17.22;	author tg;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.27.17.47.10;	author tg;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.27.15.38.19;	author tg;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.26.13.10.27;	author tg;	state Exp;
branches;
next	1.15;

1.15
date	2003.01.24.16.25.01;	author tg;	state Exp;
branches;
next	1.14;

1.14
date	2003.01.21.19.26.04;	author tg;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.19.18.45.40;	author tg;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.18.21.11.53;	author tg;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.17.18.26.40;	author tg;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.16.14.47.52;	author tg;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.10.21.37.46;	author tg;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.10.19.45.31;	author tg;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.06.16.23.43;	author tg;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.05.22.53.19;	author tg;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.31.01.38.59;	author tg;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.20.23.24.35;	author tg;	state Exp;
branches;
next	1.3;

1.3
date	2002.12.05.17.54.40;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.04.19.11.47;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2002.12.03.20.06.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.35
log
@sync everything over to MirBSD-new
@
text
@Index: src/gnu/usr.bin/Makefile
===================================================================
RCS file: /cvs/src/gnu/usr.bin/Makefile,v
retrieving revision 1.32
diff -u -r1.32 Makefile
--- src/gnu/usr.bin/Makefile	12 Jun 2002 04:17:02 -0000	1.32
+++ src/gnu/usr.bin/Makefile	22 Mar 2003 15:41:54 -0000
@@@@ -1,3 +1,4 @@@@
+#	$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
 #	$OpenBSD: Makefile,v 1.32 2002/06/12 04:17:24 art Exp $
 #	$NetBSD: Makefile,v 1.35 1996/04/03 21:20:52 chuck Exp $
 
@@@@ -13,6 +14,9 @@@@
 .if ${ELF_TOOLCHAIN} != "yes"
 SUBDIR+=	gas ld
 .endif
+
+# MirBSD (dict is under the NPL!)
+SUBDIR+=	dict tinyirc
 
 # Do these last; texinfo builds the info 'dir' file, perl must be after binutils
 SUBDIR+=	perl texinfo
Index: src/share/misc/Makefile
===================================================================
RCS file: /cvs/src/share/misc/Makefile,v
retrieving revision 1.8
diff -u -r1.8 Makefile
--- src/share/misc/Makefile	5 Oct 2001 17:30:29 -0000	1.8
+++ src/share/misc/Makefile	22 Mar 2003 15:41:54 -0000
@@@@ -1,12 +1,9 @@@@
 #	$OpenBSD: Makefile,v 1.8 2001/10/05 17:30:51 matthieu Exp $
 #	from: @@(#)Makefile	5.13 (Berkeley) 5/7/91
 
-FILES=	airport ascii birthtoken countrycodes eqnchar getopt \
+FILES=	acronyms airport ascii birthtoken countrycodes eqnchar getopt \
 	inter.phone man.template mdoc.template na.phone operator \
 	scsi_modes usb_hid_usages usb_hid_usages zipcodes
-.if ${MACHINE} == "i386"
-SUBDIR=	pcvtfonts
-.endif
 
 all clean cleandir depend lint obj tags: _SUBDIRUSE
 
Index: src/usr.bin/Makefile
===================================================================
RCS file: /cvs/src/usr.bin/Makefile,v
retrieving revision 1.79
diff -u -r1.79 Makefile
--- src/usr.bin/Makefile	24 Jul 2002 01:08:34 -0000	1.79
+++ src/usr.bin/Makefile	22 Mar 2003 15:41:55 -0000
@@@@ -35,4 +35,6 @@@@
 SUBDIR+= elf2ecoff elf2aout
 .endif
 
+SUBDIR+= brainfuck host ndat wtf
+
 .include <bsd.subdir.mk>
index: src/gnu/usr.bin/dict/Makefile
===================================================================
RCS file: /cvs/src/gnu/usr.bin/dict/Makefile,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/gnu/usr.bin/dict/Makefile	Sat Mar 22 15:41:55 2003
@@@@ -0,0 +1,25 @@@@
+# $MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+# Public domain.
+
+SRCS=	dict
+NOOBS=	noobj
+
+MANALL=	\
+	dict.cat1
+CLEANFILES+= \
+	dict.pm
+
+dict.cat1: ${SRCS}
+	cp ${.ALLSRC} dict.pm && \
+	    pod2man --section=1 --official --center='miranda.org' \
+		--release="OpenBSD `uname -r`" dict.pm | \
+	    nroff -Tascii -man >${.TARGET}
+
+realinstall:
+	cd ${.CURDIR}; install -c -o ${BINOWN} -g ${BINGRP} -m 555 \
+	    ${SRCS} ${DESTDIR}${BINDIR}
+
+clean:
+	rm -f ${CLEANFILES}
+
+.include <bsd.prog.mk>
index: src/gnu/usr.bin/dict/dict
===================================================================
RCS file: /cvs/src/gnu/usr.bin/dict/dict,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/gnu/usr.bin/dict/dict	Sat Mar 22 15:41:55 2003
@@@@ -0,0 +1,775 @@@@
+#!/usr/bin/perl
+#
+# dict -- Perl DICT system client
+#
+# Created: Thu Apr 17 19:49:15 1997 by bamartin@@miranda.org
+# Revised: Thu Mar 12 02:00:44 1998 by bamartin@@miranda.org
+# Revised: $Date: 2003/03/22 22:33:31 $ by x86@@ePost.de
+# Copyright 1997-1998 Bret A. Martin (bamartin@@miranda.org)
+# This program comes with ABSOLUTELY NO WARRANTY.
+#
+#   The contents of this file are subject to the Netscape Public License
+#   Version 1.0 (the "NPL"); you may not use this file except in compliance
+#   with the NPL. You may obtain a copy of the NPL at the end of this file.
+#
+#   Software distributed under the NPL is distributed on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, either express or implied. See the NPL.
+#
+#   The Initial Developer of this code under the NPL is Bret Martin.
+#
+# _Id: dict,v 1.5 1998/03/08 23:41:42 bamartin Exp $
+
+require 5.002;
+use File::Basename;
+use FileHandle;
+use Socket;
+
+$me = basename $0;
+chop($hostname = `hostname`);
+
+# Did not work for some time. Search for NOCLUE
+# $server = "dict.org";
+# This is miranda.org:
+$server = "209.58.150.153";
+$port   = 2628;
+
+sub usage {
+    print STDERR <<EOM;
+usage: $me [options] [word]
+  valid options: -d database            use database <database>
+                 -m strategy            use matching strategy <strategy>
+                 -i database            get information on <database>
+                 -D                     list available databases
+                 -M                     list matching methods
+                 -I                     show server information
+                 -s server[:port]       specify server (and optional port)
+                                        default is $server:$port
+                 -v                     verbose (for debugging)
+  get more help with "perldoc -F $me"
+EOM
+    exit(1);
+}
+
+if ($#ARGV < 0) { &usage; }
+
+push(@@cmdlist, "CLIENT perl-dict\@@$hostname");
+
+while ($arg = shift @@ARGV) {
+    if    ($arg eq "-d") { $opt_d = shift @@ARGV; }
+    elsif ($arg eq "-m") {
+        $opt_m = shift @@ARGV;
+        push(@@cmdlist, "SHOW DATABASES");  # need DB list for header
+    }
+    elsif ($arg eq "-D") { push(@@cmdlist, "SHOW DATABASES");   $opt_D = 1; }
+    elsif ($arg eq "-M") { push(@@cmdlist, "SHOW STRATEGIES");  $opt_M = 1; }
+    elsif ($arg eq "-I") { push(@@cmdlist, "SHOW SERVER");      $opt_I = 1; }
+    elsif ($arg eq "-h") { $opt_h = shift @@ARGV; }
+    elsif ($arg eq "-v") { $opt_v = 1; }
+    elsif ($arg eq "-i") {
+	$opt_i = shift @@ARGV;
+	push(@@cmdlist, "SHOW DATABASES");  # need DB list for header
+	push(@@cmdlist, "SHOW INFO $opt_i");
+    } else {
+	if ($opt_m ne "") {
+	    push(@@cmdlist, "MATCH " .
+		 ($opt_d eq "" ? '*' : $opt_d) .
+		 " $opt_m  \"$arg\"");
+	} else {
+	    push(@@cmdlist, "DEFINE " .
+		 ($opt_d eq "" ? '*' : $opt_d) .
+		 " \"$arg\"");
+	}
+    }
+}
+
+if ($opt_h ne "") {                        # handle -h command line option
+    if ($opt_h =~ /:/) { ($server,$port) = split(/:/, $opt_h); }
+    else { $server = $opt_h; }
+}
+
+push(@@cmdlist, "QUIT");
+
+# NOCLUE here, too... seems to be related to Socket6
+$iaddr  = inet_aton($server)               || die "server not found";
+$paddr  = sockaddr_in($port, $iaddr);
+#($name, $aliases, $type, $len, $iaddr) = gethostbyname($server);
+#($opt_v) && printf "Server %s => %s\n", $server, $name;
+#$sockaddr = 'S n a4 x8';
+#$paddr = pack( $sockaddr, AF_INET, $port, $iaddr );
+# End switch-commenting of NOCLUE
+
+$proto  = getprotobyname('tcp');
+
+socket(SOCK, PF_INET, SOCK_STREAM, $proto) || die "socket: $!";
+connect(SOCK, $paddr)                      || die "connect: $!";
+
+select(SOCK); $| = 1; select(STDOUT); $| = 1;
+
+foreach $i (@@cmdlist) {
+    print SOCK "$i\r\n";
+    $opt_v && print "client sends: $i\n";
+}
+
+$n = $#cmdlist; $data = $buf = "";
+
+while ($buf !~ /221 /) {                   # while connection is open
+    recv(SOCK, $buf, 4096, 0);             # receive data from socket
+    $data = $data . $buf;                  # and append it to stored data
+}
+
+$data =~ s/\r\n\r\n/\r\n \r\n/g;
+@@data = split(/\r\n/,$data);
+@@data = reverse @@data;
+
+while ($line = pop @@data) {
+    if ($line =~ /^(\d{3}) (.+)$/) {
+	$tail = $2;
+	for ($1) {
+	    /110/ and do {          # database list
+		while (($line = pop @@data) !~ /^\.$/) {
+		    $line =~ /^(\S+) \"(.+)\"/;
+		    $db = $1; $name = $2;
+		    $dbs{$db} = $name;
+		}
+
+		if ($opt_D) {
+		    $- = 0;
+		    STDOUT->format_name("DB");
+		    STDOUT->format_top_name("DB_TOP");
+		    foreach $db (keys %dbs) {
+			write;
+		    }
+		}
+
+		last;
+	    };
+
+	    /111/ and do {          # strategy list
+		while (($line = pop @@data) !~ /^\.$/) {
+		    $line =~ /^(\S+) \"(.+)\"/;
+		    $strat = $1; $name = $2;
+		    $strats{$strat} = $name;
+		}
+
+		if ($opt_M) {
+		    $- = 0;
+		    STDOUT->format_name("STRAT");
+		    STDOUT->format_top_name("STRAT_TOP");
+		    foreach $strat (keys %strats) {
+			write;
+		    }
+		}
+
+		last;
+	    };
+
+	    /112/ and do {          # database info
+		print "*** Database information on \"$dbs{$opt_i}\" ***\n";
+		last;
+	    };
+
+	    /113/ and do {          # help text
+		print "*** Server/protocol help text ***\n";
+		last;
+	    };
+
+            /114/ and do {          # server info
+		print "*** Server information for $server:$port ***\n";
+		last;
+	    };
+
+	    /130|210|220|221|230|250|330/ and do {
+		# 130 challenge follows
+		# 210 open connection
+		# 220 text msg-id
+		# 221 closing connection
+		# 230 authentication successful
+		# 250 command complete
+		# 330 challenge response
+
+		($opt_v) &&
+		  print STDERR "server sends: $line\n";
+		last;
+	    };
+
+	    /150/ and do {          # definitions found
+		($num,$trash) = split(/ /,$tail);
+		print "$num definition" .
+		    (($num==1) ? "" : "s") . " found\n\n";
+		last;
+	    };
+
+	    /151/ and do {          # definition follows
+		$tail =~ /"(.+)" (.+) "(.+)"/;
+		$db = $2;
+		print "*** Source: $3 ***\n";
+		last;
+	    };
+
+	    /152/ and do {          # matches found
+	        ($num,$trash) = split(/ /,$tail);
+		print "$num match" .
+		    (($num==1) ? "" : "es"). " found\n";
+		$matching = 1;
+		last;
+	    };
+
+	    /420|421/ and do {      # server transitional errors
+		# 420 Server temporarily unavailable
+		# 421 Server shutting down
+
+		print STDERR "DICT server: $line\n";
+		last;
+	    };
+
+	    /500|501|502|503|530|531|532|550|551|552|554|555/ and do {
+		# 500 bad command, 501 bad parameters,
+		# 502 command not implemented, 503 parameter not implemented,
+		# 530/531/532 authentication failed,
+		# 550 invalid database, 551 invalid strategy,
+		# 552 no matches found
+		# 554 no databases present, 555 no strategies available
+
+		print STDERR "DICT error: $line\n";
+		last;
+	    };
+	}
+
+    } elsif ($line =~ /^\.$/) {
+	print "\n";
+    } elsif ($matching == 1) {
+	$line =~ /^(\S+) \"(.+)\"$/;
+	if ($1 ne $curdb) {
+	    $curdb = $1;
+	    print "\n*** Source: $dbs{$curdb} ***\n";
+	}
+	$cow = $query = $2;
+	print "\t$cow\n";
+    } else {
+	print "$line\n";
+    }
+}
+
+close(SOCK)                                || die "close: $!";
+exit(0);
+
+
+format DB_TOP =
+short name      description
+----------      -----------
+.
+
+format DB =
+@@<<<<<<<<<<<<<< @@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
+$db, $dbs{$db}
+.
+
+format STRAT_TOP =
+method name     description
+-----------     -----------
+.
+
+format STRAT =
+@@<<<<<<<<<<<<<< @@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
+$strat, $strats{$strat}
+.
+
+
+__END__
+
+=head1 NAME
+
+dict - perl client for the DICT protocol described in RFC 2229
+
+=head1 SYNOPSIS
+
+dict [B<-d> I<database>] [B<-m> I<strategy>] [B<-i> I<database>]
+     [B<-D>] [B<-M>] [B<-I>] [B<-h> I<server>[:I<port>]] [B<-v>] [I<word> ...]
+
+=head1 DESCRIPTION
+
+B<dict> is a client for the DICT protocol described in RFC 2229.  DICT
+is a protocol that allows a client to access dictionary definitions
+from a set of natural language dictionary databases.  More informatin
+on the DICT project is available at http://www.dict.org/ .
+
+Every DICT server has a set of databases and a set of matching
+strategies.  Unless otherwise specified (with the B<-m> option and a
+matching I<strategy>), B<dict> will request definitions of I<word>s
+specified on the command line.
+
+=head2 OPTIONS
+
+=item B<-d> I<database>
+
+Use I<database> for this query.  (Obtain a list of I<database>s with
+B<dict -D>.)  Without this option, all I<databases> will be searched.
+
+=item B<-m> I<strategy>
+
+Use I<strategy> for this query.  (Obtain a list of I<strategies> with
+B<dict -M>.)  With this option, the default behavior (returning
+definitons) is overridden and a list of words matching the query
+I<word> using the specified I<strategy> is returned.
+
+=item B<-i> I<database>
+
+Ask the server for information on I<database>.
+
+=item B<-D>
+
+Get a list of available I<database>s and their full names.
+
+=item B<-M>
+
+Get a list of available matching I<strategies>.
+
+=item B<-h> I<server>[:I<port>]
+
+Override the default I<server> (and optionally I<port>).
+
+=item B<-v>
+
+Be verbose about the DICT transaction.  This is really only useful for
+debugging.
+
+=head1 AUTHOR
+
+Bret A. Martin (bamartin@@miranda.org).
+
+=head1 BUGS
+
+B<dict> does not implement the AUTH command and associated
+functionality for authentication as specified in RFC 2229.
+
+=head1 COPYRIGHT
+
+Copyright 1997-1998 Bret A. Martin (bamartin@@miranda.org).
+
+This program is subject to the Netscape Public License Version 1.0
+(the "NPL"); you may not use this file except in compliance with the
+NPL, Version 1.0, which is outlined below:
+
+=head1 LICENCE
+
+NETSCAPE PUBLIC LICENSE
+Version 1.0
+
+=head2 1. Definitions.
+
+1.1. "Contributor" means each entity that creates or contributes to
+the creation of Modifications.
+
+1.2. "Contributor Version" means the combination of the Original
+Code, prior Modifications used by a Contributor, and the Modifications
+made by that particular Contributor.
+
+1.3. "Covered Code" means the Original Code or Modifications or the
+combination of the Original Code and Modifications, in each case
+including portions thereof.
+
+1.4. "Electronic Distribution Mechanism" means a mechanism generally
+accepted in the software development community for the electronic
+transfer of data.
+
+1.5. "Executable" means Covered Code in any form other than Source
+Code.
+
+1.6. "Initial Developer" means the individual or entity identified as
+the Initial Developer in the Source Code notice required by Exhibit A.
+
+1.7. "Larger Work" means a work which combines Covered Code or
+portions thereof with code not governed by the terms of this License.
+
+1.8. "License" means this document.
+
+1.9. "Modifications" means any addition to or deletion from the
+substance or structure of either the Original Code or any previous
+Modifications. When Covered Code is released as a series of files, a
+Modification is:
+
+    A. Any addition to or deletion from the contents of a file
+    containing Original Code or previous Modifications.
+
+    B. Any new file that contains any part of the Original Code or
+    previous Modifications.
+
+1.10. "Original Code" means Source Code of computer software code
+which is described in the Source Code notice required by Exhibit A as
+Original Code, and which, at the time of its release under this License
+is not already Covered Code governed by this License.
+
+1.11. "Source Code" means the preferred form of the Covered Code for
+making modifications to it, including all modules it contains, plus any
+associated interface definition files, scripts used to control
+compilation and installation of an Executable, or a list of source code
+differential comparisons against either the Original Code or another
+well known, available Covered Code of the Contributor's choice. The
+Source Code can be in a compressed or archival form, provided the
+appropriate decompression or de-archiving software is widely available
+for no charge.
+
+1.12. "You" means an individual or a legal entity exercising rights
+under, and complying with all of the terms of, this License or a future
+version of this License issued under Section 6.1. For legal entities,
+"You" includes any entity which controls, is controlled by, or is
+under common control with You. For purposes of this definition,
+"control" means (a) the power, direct or indirect, to cause the
+direction or management of such entity, whether by contract or
+otherwise, or (b) ownership of fifty percent (50%) or more of the
+outstanding shares or beneficial ownership of such entity.
+
+=head2 2. Source Code License.
+
+2.1. The Initial Developer Grant.
+The Initial Developer hereby grants You a world-wide, royalty-free,
+non-exclusive license, subject to third party intellectual property
+claims:
+
+    (a) to use, reproduce, modify, display, perform, sublicense and
+    distribute the Original Code (or portions thereof) with or without
+    Modifications, or as part of a Larger Work; and
+
+    (b) under patents now or hereafter owned or controlled by Initial
+    Developer, to make, have made, use and sell ("Utilize") the
+    Original Code (or portions thereof), but solely to the extent that
+    any such patent is reasonably necessary to enable You to Utilize
+    the Original Code (or portions thereof) and not to any greater
+    extent that may be necessary to Utilize further Modifications or
+    combinations.
+
+2.2. Contributor Grant.
+Each Contributor hereby grants You a world-wide, royalty-free,
+non-exclusive license, subject to third party intellectual property
+claims:
+
+    (a) to use, reproduce, modify, display, perform, sublicense and
+    distribute the Modifications created by such Contributor (or
+    portions thereof) either on an unmodified basis, with other
+    Modifications, as Covered Code or as part of a Larger Work; and
+
+    (b) under patents now or hereafter owned or controlled by
+    Contributor, to Utilize the Contributor Version (or portions
+    thereof), but solely to the extent that any such patent is
+    reasonably necessary to enable You to Utilize the Contributor
+    Version (or portions thereof), and not to any greater extent that
+    may be necessary to Utilize further Modifications or combinations.
+
+=head2 3. Distribution Obligations.
+
+3.1. Application of License.
+The Modifications which You create or to which You contribute are
+governed by the terms of this License, including without limitation
+Section 2.2. The Source Code version of Covered Code may be distributed
+only under the terms of this License or a future version of this
+License released under Section 6.1, and You must include a copy of this
+License with every copy of the Source Code You distribute. You may not
+offer or impose any terms on any Source Code version that alters or
+restricts the applicable version of this License or the recipients'
+rights hereunder. However, You may include an additional document
+offering the additional rights described in Section 3.5.
+
+3.2. Availability of Source Code.
+Any Modification which You create or to which You contribute must be
+made available in Source Code form under the terms of this License
+either on the same media as an Executable version or via an accepted
+Electronic Distribution Mechanism to anyone to whom you made an
+Executable version available; and if made available via Electronic
+Distribution Mechanism, must remain available for at least twelve (12)
+months after the date it initially became available, or at least six
+(6) months after a subsequent version of that particular Modification
+has been made available to such recipients. You are responsible for
+ensuring that the Source Code version remains available even if the
+Electronic Distribution Mechanism is maintained by a third party.
+
+3.3. Description of Modifications.
+You must cause all Covered Code to which you contribute to contain a
+file documenting the changes You made to create that Covered Code and
+the date of any change. You must include a prominent statement that the
+Modification is derived, directly or indirectly, from Original Code
+provided by the Initial Developer and including the name of the Initial
+Developer in (a) the Source Code, and (b) in any notice in an
+Executable version or related documentation in which You describe the
+origin or ownership of the Covered Code.
+
+3.4. Intellectual Property Matters
+
+    (a) Third Party Claims.
+    If You have knowledge that a party claims an intellectual property
+    right in particular functionality or code (or its utilization
+    under this License), you must include a text file with the source
+    code distribution titled "LEGAL" which describes the claim and
+    the party making the claim in sufficient detail that a recipient
+    will know whom to contact. If you obtain such knowledge after You
+    make Your Modification available as described in Section 3.2, You
+    shall promptly modify the LEGAL file in all copies You make
+    available thereafter and shall take other steps (such as notifying
+    appropriate mailing lists or newsgroups) reasonably calculated to
+    inform those who received the Covered Code that new knowledge has
+    been obtained.
+
+    (b) Contributor APIs.
+    If Your Modification is an application programming interface and
+    You own or control patents which are reasonably necessary to
+    implement that API, you must also include this information in the
+    LEGAL file.
+
+3.5. Required Notices.
+You must duplicate the notice in Exhibit A in each file of the Source
+Code, and this License in any documentation for the Source Code, where
+You describe recipients' rights relating to Covered Code. If You
+created one or more Modification(s), You may add your name as a
+Contributor to the notice described in Exhibit A. If it is not possible
+to put such notice in a particular Source Code file due to its
+structure, then you must include such notice in a location (such as a
+relevant directory file) where a user would be likely to look for such
+a notice. You may choose to offer, and to charge a fee for, warranty,
+support, indemnity or liability obligations to one or more recipients
+of Covered Code. However, You may do so only on Your own behalf, and
+not on behalf of the Initial Developer or any Contributor. You must
+make it absolutely clear than any such warranty, support, indemnity or
+liability obligation is offered by You alone, and You hereby agree to
+indemnify the Initial Developer and every Contributor for any liability
+incurred by the Initial Developer or such Contributor as a result of
+warranty, support, indemnity or liability terms You offer.
+
+3.6. Distribution of Executable Versions.
+You may distribute Covered Code in Executable form only if the
+requirements of Section 3.1-3.5 have been met for that Covered Code,
+and if You include a notice stating that the Source Code version of the
+Covered Code is available under the terms of this License, including a
+description of how and where You have fulfilled the obligations of
+Section 3.2. The notice must be conspicuously included in any notice in
+an Executable version, related documentation or collateral in which You
+describe recipients' rights relating to the Covered Code. You may
+distribute the Executable version of Covered Code under a license of
+Your choice, which may contain terms different from this License,
+provided that You are in compliance with the terms of this License and
+that the license for the Executable version does not attempt to limit
+or alter the recipient's rights in the Source Code version from the
+rights set forth in this License. If You distribute the Executable
+version under a different license You must make it absolutely clear
+that any terms which differ from this License are offered by You alone,
+not by the Initial Developer or any Contributor. You hereby agree to
+indemnify the Initial Developer and every Contributor for any liability
+incurred by the Initial Developer or such Contributor as a result of
+any such terms You offer.
+
+3.7. Larger Works.
+You may create a Larger Work by combining Covered Code with other code
+not governed by the terms of this License and distribute the Larger
+Work as a single product. In such a case, You must make sure the
+requirements of this License are fulfilled for the Covered Code.
+
+=head2 4. Inability to Comply Due to Statute or Regulation.
+
+If it is impossible for You to comply with any of the terms of this
+License with respect to some or all of the Covered Code due to statute
+or regulation then You must: (a) comply with the terms of this License
+to the maximum extent possible; and (b) describe the limitations and
+the code they affect. Such description must be included in the LEGAL
+file described in Section 3.4 and must be included with all
+distributions of the Source Code. Except to the extent prohibited by
+statute or regulation, such description must be sufficiently detailed
+for a recipient of ordinary skill to be able to understand it.
+
+=head2 5. Application of this License.
+
+This License applies to code to which the Initial Developer has
+attached the notice in Exhibit A, and to related Covered Code.
+
+=head2 6. Versions of the License.
+
+6.1. New Versions.
+Netscape Communications Corporation ("Netscape") may publish revised
+and/or new versions of the License from time to time. Each version will
+be given a distinguishing version number.
+
+6.2. Effect of New Versions.
+Once Covered Code has been published under a particular version of the
+License, You may always continue to use it under the terms of that
+version. You may also choose to use such Covered Code under the terms
+of any subsequent version of the License published by Netscape. No one
+other than Netscape has the right to modify the terms applicable to
+Covered Code created under this License.
+
+6.3. Derivative Works.
+If you create or use a modified version of this License (which you may
+only do in order to apply it to code which is not already Covered Code
+governed by this License), you must (a) rename Your license so that the
+phrases "Mozilla", "MOZILLAPL", "MOZPL", "Netscape", "NPL" or
+any confusingly similar phrase do not appear anywhere in your license
+and (b) otherwise make it clear that your version of the license
+contains terms which differ from the Mozilla Public License and
+Netscape Public License. (Filling in the name of the Initial Developer,
+Original Code or Contributor in the notice described in Exhibit A shall
+not of themselves be deemed to be modifications of this License.)
+
+=head2 7. DISCLAIMER OF WARRANTY.
+
+COVERED CODE IS PROVIDED UNDER THIS LICENSE ON AN "AS IS" BASIS,
+WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+WITHOUT LIMITATION, WARRANTIES THAT THE COVERED CODE IS FREE OF
+DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR NON-INFRINGING.
+THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE COVERED CODE
+IS WITH YOU. SHOULD ANY COVERED CODE PROVE DEFECTIVE IN ANY RESPECT,
+YOU (NOT THE INITIAL DEVELOPER OR ANY OTHER CONTRIBUTOR) ASSUME THE
+COST OF ANY NECESSARY SERVICING, REPAIR OR CORRECTION. THIS DISCLAIMER
+OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS LICENSE. NO USE OF
+ANY COVERED CODE IS AUTHORIZED HEREUNDER EXCEPT UNDER THIS DISCLAIMER.
+
+=head2 8. TERMINATION.
+
+This License and the rights granted hereunder will terminate
+automatically if You fail to comply with terms herein and fail to cure
+such breach within 30 days of becoming aware of the breach. All
+sublicenses to the Covered Code which are properly granted shall
+survive any termination of this License. Provisions which, by their
+nature, must remain in effect beyond the termination of this License
+shall survive.
+
+=head2 9. LIMITATION OF LIABILITY.
+
+UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY, WHETHER TORT
+(INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE, SHALL THE INITIAL
+DEVELOPER, ANY OTHER CONTRIBUTOR, OR ANY DISTRIBUTOR OF COVERED CODE,
+OR ANY SUPPLIER OF ANY OF SUCH PARTIES, BE LIABLE TO YOU OR ANY OTHER
+PERSON FOR ANY INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+OF ANY CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF
+GOODWILL, WORK STOPPAGE, COMPUTER FAILURE OR MALFUNCTION, OR ANY AND
+ALL OTHER COMMERCIAL DAMAGES OR LOSSES, EVEN IF SUCH PARTY SHALL HAVE
+BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES. THIS LIMITATION OF
+LIABILITY SHALL NOT APPLY TO LIABILITY FOR DEATH OR PERSONAL INJURY
+RESULTING FROM SUCH PARTY'S NEGLIGENCE TO THE EXTENT APPLICABLE LAW
+PROHIBITS SUCH LIMITATION. SOME JURISDICTIONS DO NOT ALLOW THE
+EXCLUSION OR LIMITATION OF INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THAT
+EXCLUSION AND LIMITATION MAY NOT APPLY TO YOU.
+
+=head2 10. U.S. GOVERNMENT END USERS.
+
+The Covered Code is a "commercial item," as that term is defined in
+48 C.F.R. 2.101 (Oct. 1995), consisting of "commercial computer
+software" and "commercial computer software documentation," as such
+terms are used in 48 C.F.R. 12.212 (Sept. 1995). Consistent with 48
+C.F.R. 12.212 and 48 C.F.R. 227.7202-1 through 227.7202-4 (June 1995),
+all U.S. Government End Users acquire Covered Code with only those
+rights set forth herein.
+
+=head2 11. MISCELLANEOUS.
+
+This License represents the complete agreement concerning subject
+matter hereof. If any provision of this License is held to be
+unenforceable, such provision shall be reformed only to the extent
+necessary to make it enforceable. This License shall be governed by
+California law provisions (except to the extent applicable law, if any,
+provides otherwise), excluding its conflict-of-law provisions. With
+respect to disputes in which at least one party is a citizen of, or an
+entity chartered or registered to do business in, the United States of
+America: (a) unless otherwise agreed in writing, all disputes relating
+to this License (excepting any dispute relating to intellectual
+property rights) shall be subject to final and binding arbitration,
+with the losing party paying all costs of arbitration; (b) any
+arbitration relating to this Agreement shall be held in Santa Clara
+County, California, under the auspices of JAMS/EndDispute; and (c) any
+litigation relating to this Agreement shall be subject to the
+jurisdiction of the Federal Courts of the Northern District of
+California, with venue lying in Santa Clara County, California, with
+the losing party responsible for costs, including without limitation,
+court costs and reasonable attorneys fees and expenses. The application
+of the United Nations Convention on Contracts for the International
+Sale of Goods is expressly excluded. Any law or regulation which
+provides that the language of a contract shall be construed against the
+drafter shall not apply to this License.
+
+=head2 12. RESPONSIBILITY FOR CLAIMS.
+
+Except in cases where another Contributor has failed to comply with
+Section 3.4, You are responsible for damages arising, directly or
+indirectly, out of Your utilization of rights under this License, based
+on the number of copies of Covered Code you made available, the
+revenues you received from utilizing such rights, and other relevant
+factors. You agree to work with affected parties to distribute
+responsibility on an equitable basis.
+
+=head2 AMENDMENTS
+Additional Terms applicable to the Netscape Public License.
+
+I. Effect.
+These additional terms described in this Netscape Public License --
+Amendments shall apply to the Mozilla Communicator client code and to
+all Covered Code under this License.
+
+II. "Netscape's Branded Code" means Covered Code that Netscape
+distributes and/or permits others to distribute under one or more
+trademark(s) which are controlled by Netscape but which are not
+licensed for use under this License.
+
+III. Netscape and logo.
+This License does not grant any rights to use the trademark
+"Netscape", the "Netscape N and horizon" logo or the Netscape
+lighthouse logo, even if such marks are included in the Original Code.
+
+IV. Inability to Comply Due to Contractual Obligation.
+Prior to licensing the Original Code under this License, Netscape has
+licensed third party code for use in Netscape's Branded Code. To the
+extent that Netscape is limited contractually from making such third
+party code available under this License, Netscape may choose to
+reintegrate such code into Covered Code without being required to
+distribute such code in Source Code form, even if such code would
+otherwise be considered "Modifications" under this License.
+
+V. Use of Modifications and Covered Code by Initial Developer.
+
+    V.1. In General.
+    The obligations of Section 3 apply to Netscape, except to the
+    extent specified in this Amendment, Section V.2 and V.3.
+
+    V.2. Other Products.
+    Netscape may include Covered Code in products other than the
+    Netscape's Branded Code which are released by Netscape during the
+    two (2) years following the release date of the Original Code,
+    without such additional products becoming subject to the terms of
+    this License, and may license such additional products on
+    different terms from those contained in this License.
+
+    V.3. Alternative Licensing.
+    Netscape may license the Source Code of Netscape's Branded Code,
+    including Modifications incorporated therein, without such
+    additional products becoming subject to the terms of this License,
+    and may license such additional products on different terms from
+    those contained in this License.
+
+VI. Arbitration and Litigation.
+Notwithstanding the limitations of Section 11 above, the provisions
+regarding arbitration and litigation in Section 11(a), (b) and (c) of
+the License shall apply to all disputes relating to this License.
+
+=head2 EXHIBIT A.
+
+"The contents of this file are subject to the Netscape Public License
+Version 1.0 (the "License"); you may not use this file except in
+compliance with the License. You may obtain a copy of the License at
+http://www.mozilla.org/NPL/
+
+Software distributed under the License is distributed on an "AS IS"
+basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
+License for the specific language governing rights and limitations
+under the License.
+
+The Original Code is Mozilla Communicator client code, released March
+31, 1998.
+
+The Initial Developer of the Original Code is Netscape Communications
+Corporation. Portions created by Netscape are Copyright (C) 1998
+Netscape Communications Corporation. All Rights Reserved.
+
+Contributor(s): ______________________________________."
+
+[NOTE: The text of this Exhibit A may differ slightly from the text of
+the notices in the Source Code files of the Original Code. This is due
+to time constraints encountered in simultaneously finalizing the
+License and in preparing the Original Code for release. You should use
+the text of this Exhibit A rather than the text found in the Original
+Code Source Code for Your Modifications.]
+
+=cut
index: src/gnu/usr.bin/tinyirc/Makefile
===================================================================
RCS file: /cvs/src/gnu/usr.bin/tinyirc/Makefile,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Sat Mar 22 15:41:55 2003
@@@@ -0,0 +1,11 @@@@
+# $MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+# Public domain.
+
+PROG=	tinyirc
+CFLAGS+=-Wall -Werror -pedantic
+CFLAGS+=-DUSETERMIOS
+LDADD=	-ltermcap
+
+NOMAN=
+
+.include <bsd.prog.mk>
index: src/gnu/usr.bin/tinyirc/tinyirc.c
===================================================================
RCS file: /cvs/src/gnu/usr.bin/tinyirc/tinyirc.c,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Sat Mar 22 15:41:55 2003
@@@@ -0,0 +1,830 @@@@
+/* Configuration options */
+static char *DEFAULTSERVER = "134.102.206.163";
+/*			reads: irc.freenode.net      */
+/* please change the default server to one near you. */
+#define DEFAULTPORT	6667
+#define COMMANDCHAR	'/'
+/* each line of history adds 512 bytes to resident size */
+#define HISTLEN		8
+#define RELEASE_	"TinyIRC pre1.0-mirabile"
+#define RELEASE		"TinyIRC p1.0m"      /* shorter */
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+
+   TinyIRC Alpha Release
+   Copyright (C) 1994 Nathan I. Laredo
+   Copyright (c) 1999-2003 Thorsten "mirabile" Glaser
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License Version 1
+   as published by the Free Software Foundation.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   Send your comments and all your spare pocket change to
+   laredo@@gnu.ai.mit.edu (Nathan Laredo) or to 1604 Lilac Lane,
+   Plano, TX 75074, USA.  Any donations are welcome.
+
+
+   Please do not forget to donate to the OpenBSD project
+   at http://www.OpenBSD.org/ - the daemons will thank you.
+
+   While you're at it, visit the MirBSD project pages
+   at http://templeofhate.com/tglaser/MirBSD/
+
+   Missing features:
+    * KNF - man 9 style
+    * Security auditing
+   Added:
+    * /quote command (shortcut: Q)
+    * command re-ordering for shortcuts
+    * ^C command for instant exiting
+ */
+
+#include <stdio.h>
+#ifndef USETERMIOS
+#include <sgtty.h>
+#define	USE_OLD_TTY
+#include <sys/ioctl.h>
+#if !defined(sun) && !defined(sequent) && !defined(hpux) && \
+	!defined(_AIX_)
+#include <strings.h>
+#define strchr index
+#else
+#include <string.h>
+#endif
+#else
+#include <string.h>
+#include <termios.h>
+#endif
+#include <sys/types.h>
+#include <pwd.h>
+#include <sys/time.h>
+#include <sys/file.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <signal.h>
+#include <ctype.h>
+#include <curses.h>
+#include <stdlib.h>
+#include <sys/uio.h>
+#include <term.h>
+#include <unistd.h>
+
+struct dlist {
+    char name[64];
+    struct dlist *next;
+};
+struct dlist *object = NULL, *objlist = NULL, *newobj;
+u_short IRCPORT = DEFAULTPORT;
+int sockfd, sok = 1, stdinfd, stdoutfd, histline, dumb = 0, CO, LI, column;
+char *CM, *CS, *CE, *linein, lineout[512], *history[HISTLEN], localhost[64],
+*SO, *SE, *tok_in[256], *tok_out[256], *tmp, serverdata[512], termcap[1024],
+*DC, *ptr, *term, *fromhost, IRCNAME[10], inputbuf[512], beenden = 0;
+char bp[4096];
+int cursd = 0, curli = 0, curx = 0;
+fd_set readfs;
+struct timeval time_out;
+struct tm *timenow;
+static time_t idletimer, datenow, wasdate;
+struct passwd *userinfo;
+
+#ifdef	USETERMIOS
+struct termios _tty;
+tcflag_t _res_iflg, _res_lflg;
+#define raw() (_tty.c_lflag &= ~(ICANON | ECHO | ISIG), \
+	tcsetattr(stdinfd, TCSANOW, &_tty))
+#define savetty() ((void) tcgetattr(stdinfd, &_tty), \
+	_res_iflg = _tty.c_iflag, _res_lflg = _tty.c_lflag)
+#define resetty() (_tty.c_iflag = _res_iflg, _tty.c_lflag = _res_lflg,\
+	(void) tcsetattr(stdinfd, TCSADRAIN, &_tty))
+#else
+struct sgttyb _tty;
+int _res_flg;
+#define raw() (_tty.sg_flags |= RAW, _tty.sg_flags &= ~ECHO, \
+	ioctl(stdinfd, TIOCSETP, &_tty))
+#define savetty() ((void) ioctl(stdinfd, TIOCGETP, &_tty), \
+	_res_flg = _tty.sg_flags)
+#define resetty() (_tty.sg_flags = _res_flg, \
+	(void) ioctl(stdinfd, TIOCSETP, &_tty))
+#endif
+
+int putchar_x(c)
+int c;
+{
+    return putchar(c);
+}
+
+#define	tputs_x(s) (tputs(s,0,putchar_x))
+
+int my_stricmp(str1, str2)
+char *str1, *str2;
+{
+    int compare;
+
+    while (*str1 != 0 && str2 != 0) {
+	if (isalpha(*str1) && isalpha(*str2)) {
+	    compare = *str1 ^ *str2;
+	    if ((compare != 32) && (compare != 0))
+		return (*str1 - *str2);
+	} else {
+	    if (*str1 != *str2)
+		return (*str1 - *str2);
+	}
+	str1++;
+	str2++;
+    }
+    return (*str1 - *str2);
+}
+
+struct dlist *additem(item, ptr)
+char *item;
+struct dlist *ptr;
+{
+    newobj = (struct dlist *) malloc(sizeof(struct dlist));
+    strcpy(newobj->name, item);
+    newobj->next = ptr;
+    return newobj;
+}
+struct dlist *finditem(item, ptr)
+char *item;
+struct dlist *ptr;
+{
+    while (ptr != NULL)
+	if (my_stricmp(item, ptr->name) == 0)
+	    break;
+	else
+	    ptr = ptr->next;
+    return ptr;
+}
+struct dlist *removeitem(item, ptr)
+char *item;
+struct dlist *ptr;
+{
+    struct dlist *prev = NULL, *start = ptr;
+    while (ptr != NULL) 
+	if (my_stricmp(item, ptr->name) == 0) {
+	    newobj = ptr->next;
+	    if (object == ptr)
+		object = NULL;
+	    free (ptr);
+	    if (prev == NULL)
+		return newobj;
+	    else {
+		prev->next = newobj;
+		return start;
+	    }
+	} else {
+	    prev = ptr;
+	    ptr = ptr->next;
+	}
+    return start;
+}
+int makeconnect(hostname)
+char *hostname;
+{
+    struct sockaddr_in sa;
+    struct hostent *hp;
+    int s;
+
+    if ((hp = gethostbyname(hostname)) == NULL)
+	return -1;
+    bzero(&sa, sizeof(sa));
+    bcopy(hp->h_addr, (char *) &sa.sin_addr, hp->h_length);
+    sa.sin_family = hp->h_addrtype;
+    sa.sin_port = htons((u_short) IRCPORT);
+    if ((s = socket(hp->h_addrtype, SOCK_STREAM, 0)) < 0)
+	return -1;
+    if (connect(s, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
+	close(s);
+	return -1;
+    }
+    fcntl(s, F_SETFL, O_NDELAY);
+    return s;
+}
+
+int sendline()
+{
+    if (write(sockfd, lineout, strlen(lineout)) < 1)
+	return 0;
+    return 1;
+}
+
+void updatestatus()
+{
+    int n;
+    if (!dumb) {
+	if (60 < (datenow = time(NULL)) - wasdate) {
+	    wasdate = datenow;
+	    timenow = localtime(&datenow);
+	    tputs_x(tgoto(CM, 0, LI - 2));
+	    tputs_x(SO);
+	    n = printf("[%02d:%02d] %s on %s : %s", timenow->tm_hour,
+			timenow->tm_min, IRCNAME, (object->name == NULL ?
+			"*" : object->name), RELEASE);
+	    for (; n < CO; n++)
+		putchar(' ');
+	    tputs_x(SE);
+	}
+    }
+}
+
+static int nop()
+{
+    return 1;
+}
+static int doerror()
+{
+    column = printf("*** ERROR:");
+    return 2;
+}
+static int doinvite()
+{
+    printf("*** %s (%s) invites you to join %s.",
+	   tok_in[0], fromhost, &tok_in[2][1]);
+    return 0;
+}
+static int dojoin()
+{
+    if (strcmp(tok_in[0], IRCNAME) == 0) {
+	object = objlist = additem(tok_in[2], objlist);
+	wasdate = 0;
+	printf("*** Now talking in %s", object->name);
+    } else
+	printf("*** %s (%s) joined %s", tok_in[0], fromhost, tok_in[2]);
+    return 0;
+}
+static int dokick()
+{
+    printf("*** %s was kicked from %s by %s (%s)",
+	   tok_in[3], tok_in[2], tok_in[0], tok_in[4]);
+    if (strcmp(tok_in[3], IRCNAME) == 0) {
+	objlist = removeitem(tok_in[2], objlist);
+	if (object == NULL)
+	    object = objlist;
+	if (object != NULL)
+	    printf("\n\r*** Now talking in %s", object->name);
+	wasdate = 0;
+    }
+    return 0;
+}
+static int dokill()
+{
+    printf("*** %s killed by %s (%s)", tok_in[3], tok_in[0], tok_in[4]);
+    return 0;
+}
+static int domode()
+{
+    printf("*** %s changed %s to:", tok_in[0], tok_in[2]);
+    return 3;
+}
+static int donick()
+{
+    if (strcmp(tok_in[0], IRCNAME) == 0) {
+	wasdate = 0;
+	strcpy(IRCNAME, tok_in[2]);
+    }
+    printf("*** %s is now known as %s", tok_in[0], tok_in[2]);
+    return 0;
+}
+static int donotice()
+{
+    if (*tok_in[2] != '#')
+	column = printf("-%s-", tok_in[0]);
+    else 
+	column = printf("-%s:%s-", tok_in[0], tok_in[2]);
+    return 3;
+}
+static int dopart()
+{
+    printf("*** %s (%s) left %s", tok_in[0], fromhost,
+	   tok_in[2]);
+    if (strcmp(tok_in[0], IRCNAME) == 0) {
+	objlist = removeitem(tok_in[2], objlist);
+	if (object == NULL)
+	    object = objlist;
+	if (object != NULL)
+	    printf("\n\r*** Now talking in %s", object->name);
+	wasdate = 0;
+    }
+    return 0;
+}
+static int dopong()
+{
+    column = printf("*** Got PONG from %s:", tok_in[0]);
+    return 3;
+}
+static int doprivmsg()
+{
+    if (*tok_in[2] != '#')
+	column = printf("*%s*", tok_in[0]);
+    else if (object != NULL && my_stricmp(object->name, tok_in[2]))
+	column = printf("<%s:%s>", tok_in[0], tok_in[2]);
+    else
+	column = printf("<%s>", tok_in[0]);
+    return 3;
+}
+static int doquit()
+{
+    printf("*** %s (%s) Quit (%s)", tok_in[0], fromhost, tok_in[2]);
+    return 0;
+}
+static int dosquit()
+{
+    return 1;
+}
+static int dotime()
+{
+    return 1;
+}
+static int dotopic()
+{
+    printf("*** %s set %s topic to \"%s\"", tok_in[0], tok_in[2],
+	   tok_in[3]);
+    return 0;
+}
+
+int donumeric(num)
+int num;
+{
+    if (num == 352) {		/* rpl_whoreply */
+	column = printf("%-14s %-10s %-3s %s@@%s :", tok_in[3], tok_in[7],
+			tok_in[8], tok_in[4], tok_in[5]);
+	return 9;
+    } else if (num == 432 || num == 433) {
+	char ch;
+	printf("*** You've chosen an invalid nick.  Choose again.");
+	tputs_x(tgoto(CM, 0, LI - 1));
+	tputs_x(CE);
+	printf("New Nick? ");
+	fflush(stdout);
+	resetty();
+	tmp = IRCNAME;
+	while ((ch = getchar()) != '\n')
+	    if (strlen(IRCNAME) < 9)
+		*(tmp++) = ch;
+        *tmp = '\0';
+	wasdate = 0;
+	raw();
+	sprintf(lineout, "NICK :%s\n", IRCNAME);
+	sendline();
+	tputs_x(tgoto(CM, 0, LI - 1));
+	tputs_x(CE);
+    } else {			/* all remaining numerics */
+	column = printf("%s", tok_in[1]);
+	return 3;
+    }
+    return (0);
+}
+
+#define	LISTSIZE	51
+#define	DO_JOIN		12
+#define	DO_MSG		18
+#define	DO_PRIVMSG	30
+#define	DO_QUOTE	31
+#define	DO_W		46
+#define	DO_WHOIS	49
+static char *cmdlist[LISTSIZE] =
+{"AWAY", "ADMIN", "CONNECT", "CLOSE", "DIE", "DNS", "ERROR", "HELP",
+ "HASH", "INVITE", "INFO", "ISON", "JOIN", "KICK", "KILL", "LIST", "LINKS",
+ "LUSERS", "MSG", "MODE", "MOTD", "NOTICE", "NICK", "NAMES", "NOTE", "OPER",
+ "PART", "PASS", "PING", "PONG", "PRIVMSG", "QUOTE", "QUIT", "REHASH", "RESTART",
+ "SERVER", "SQUIT", "STATS", "SUMMON", "TIME", "TOPIC", "TRACE", "USER",
+ "USERHOST", "USERS", "VERSION", "W", "WALLOPS", "WHO", "WHOIS", "WHOWAS"};
+static int numargs[LISTSIZE] =
+{1, 1, 3, 1, 1, 1, 1, 1,
+ 1, 2, 1, 1, 1, 3, 2, 1, 1,
+ 2, 2, 2, 1, 2, 1, 1, 1, 2,
+ 1, 1, 1, 1, 2, 0, 1, 1, 1,
+ 3, 2, 1, 3, 1, 2, 2, 4,
+ 1, 1, 1, 1, 1, 1, 1, 1
+};
+static int (*docommand[LISTSIZE]) () =
+{nop, nop, nop, nop, nop, nop, doerror, nop,
+ nop, doinvite, nop, nop, dojoin, dokick, dokill, nop, nop,
+ nop, nop, domode, nop, donotice, donick, nop, nop, nop,
+ dopart, nop, nop, dopong, doprivmsg, nop, doquit, nop, nop,
+ nop, dosquit, nop, nop, dotime, dotopic, nop, nop,
+ nop, nop, nop, nop, nop, nop, nop, nop
+};
+
+int wordwrapout(ptr, count)
+char *ptr;
+int count;
+{
+    while(ptr != NULL) {
+	if ((tmp = strchr(ptr, ' ')) != NULL)
+	    *(tmp++) = '\0';
+	if (strlen(ptr) < CO - count)
+	    count += printf(" %s", ptr);
+	else
+	    count = printf("\n\r   %s", ptr);
+	ptr = tmp;
+    }
+    return count;
+}
+int parsedata()
+{
+    int i, found = 0;
+
+/* take care of ping silently */
+    if (serverdata[0] == 'P') {
+	sprintf(lineout, "PONG :%s\n", &serverdata[6]);
+	return sendline();
+    }
+    if (!dumb)
+	tputs_x(tgoto(CM, 0, LI - 3));
+
+    tok_in[i = 0] = serverdata;
+    tok_in[i]++;
+    while (tok_in[i] != NULL)
+	if (*tok_in[i] == ':')
+	    break;
+	else {
+	    if ((tmp = strchr(tok_in[i], ' ')) != NULL) {
+		tok_in[++i] = &tmp[1];
+		*tmp = '\0';
+	   } else
+		tok_in[++i] = NULL;
+	}
+    if (tok_in[i] != NULL)
+	tok_in[i]++;
+    tok_in[++i] = NULL;
+
+    if (!dumb)
+	putchar('\n');
+    if ((tmp = strchr(tok_in[0], '!')) != NULL) {
+	fromhost = &tmp[1];
+	*tmp = '\0';
+    } else
+	fromhost = NULL;
+
+    column = 0;
+    if ((i = atoi(tok_in[1])))
+	i = donumeric(i);
+    else {
+	for (i = 0; i < LISTSIZE && !found; i++)
+	    found = (strcmp(cmdlist[i], tok_in[1]) == 0);
+	if (found)
+	    i = (*docommand[i - 1]) ();
+	else
+	    i = nop();
+    }
+
+    if (i)
+	while (tok_in[i])	/* output remainder with word wrap */
+	    column = wordwrapout(tok_in[i++], column);
+    if (dumb)
+	putchar('\n');
+    if (strncmp(tok_in[1], "Closing", 7) == 0)
+	return 0;
+    return 1;
+}
+
+int serverinput()
+{   char ich;
+    while (read(sockfd, &ich, 1) > 0)
+	if (ich != '\n' && ich != '\r')
+	    serverdata[cursd++] = ich;
+	else {
+	    serverdata[cursd] = 0;
+	    if (cursd) {
+		cursd = 0;
+		return parsedata();
+	    }
+	}
+    return 1;
+}
+
+void parseinput()
+{
+    int i, j, outcol, found = 0;
+
+    if (*linein == '\0')
+	return;
+
+    strcpy(inputbuf, linein);
+    tok_out[i = 0] = strtok(inputbuf," ");
+    while((tok_out[++i] = strtok(NULL, " ")) != NULL);
+    if (!dumb) {
+	tputs_x(tgoto(CM, 0, LI - 3));
+	putchar('\n');
+    }
+    if (*tok_out[0] == COMMANDCHAR) {
+	tok_out[0]++;
+	for (i = 0; i < strlen(tok_out[0]) && isalpha(tok_out[0][i]); i++)
+	    tok_out[0][i] = toupper(tok_out[0][i]);
+	for (i = 0; i < LISTSIZE && !found; i++)
+	    found = (strncmp(cmdlist[i], tok_out[0], strlen(tok_out[0])) == 0);
+	i--;
+	if (!found) {
+	    printf("*** Invalid command");
+	    return;
+	}
+	if (i == DO_JOIN)
+	    if ((newobj = finditem(tok_out[1], objlist)) != NULL) {
+		object = newobj;
+		wasdate = 0;
+		printf("*** Now talking in %s", object->name);
+		return;
+	    }
+	if (i == DO_MSG)
+	    i = DO_PRIVMSG;
+	if (i == DO_W)
+	    i = DO_WHOIS;
+
+	strcpy(lineout, (i == DO_QUOTE) ? "" : cmdlist[i]);
+	j = 0;
+	outcol = printf("= %s", lineout);
+	while (tok_out[++j]) {
+	   sprintf(&lineout[strlen(lineout)], "%s%s", ((j == numargs[i] &&
+		   tok_out[j + 1] != NULL) ? " :" : " "), tok_out[j]);
+	   outcol = wordwrapout(tok_out[j], outcol);
+	}
+	strcat(lineout,"\n");
+    } else {
+	if (object == NULL) {
+	    printf ("*** Nowhere to send");
+	    return;
+	}
+	sprintf(lineout, "PRIVMSG %s :%s\n", object->name, linein);
+	outcol = printf("> %s", tok_out[j = 0]);
+	while(tok_out[++j])
+	   outcol = wordwrapout(tok_out[j], outcol);
+    }
+    sendline();
+    idletimer = time(NULL);
+}
+
+void histupdate()
+{
+    linein = history[histline];
+    curx = curli = strlen(linein);
+    tputs_x(tgoto(CM, 0, LI - 1));
+    printf("%s", &linein[(curli / CO) * CO]);
+    tputs_x(CE);
+}
+
+void printpartial(fromx)
+int fromx;
+{
+    int i;
+    tputs_x(tgoto(CM, 0, LI - 1));
+    for(i = fromx; i < fromx + CO && i < curli; i++)
+	putchar(linein[i]);
+    tputs_x(CE);
+    tputs_x(tgoto(CM, curx % CO, LI - 1));
+}
+void userinput()
+{
+    int i, z;
+    char ch;
+    if (dumb) {
+	fgets(linein, 500, stdin);
+	tmp = strchr(linein, '\n');
+	if (tmp != NULL)	/* get rid of newline */
+	    *tmp = '\0';
+	parseinput();
+	putchar('\n');
+    } else {
+	read(stdinfd, &ch, 1);
+	if (ch == '\177')
+	    ch = '\10';
+	switch (ch) {
+	case '\1':		/* C-a */
+	    if (curx >= CO)
+	        printpartial(curx = 0);
+	    else
+		tputs_x(tgoto(CM, curx = 0, LI - 1));
+	    break;
+	case '\4':		/* C-d */
+	case '\10':		/* C-h */
+	    if (curx) {
+		if (ch == '\4' && curx < curli)
+		    curx++;
+		if (curli == curx)
+		    linein[(--curx)] = '\0';
+		else		/* delete somewhere in the middle */
+		    for (i = (--curx); i < curli; i++)
+			linein[i] = linein[i + 1];
+		curli--;
+		if (DC != NULL && curx % CO != CO - 1) {
+		    tputs_x(tgoto(CM, curx % CO, LI - 1));
+		    tputs_x(DC);
+		} else
+		    printpartial((curx / CO) * CO);
+	    }
+	    break;
+	case '\2':		/* C-b */
+	    if (curx > 0)
+		curx--;
+	    if (curx % CO == CO - 1)
+		printpartial((curx / CO) * CO);
+	    else
+		tputs_x(tgoto(CM, curx % CO, LI - 1));
+	    break;
+	case '\3':		/* C-c */
+	    beenden = 1;
+	    break;
+	case '\5':		/* C-e */
+	    curx = curli;
+	case '\14':		/* C-l */
+	    printpartial((curx / CO) * CO);
+	    break;
+	case '\6':		/* C-f */
+	    if (curx < curli)
+		curx++;
+	    tputs_x(tgoto(CM, curx % CO, LI - 1));
+	    break;
+	case '\16':		/* C-n */
+	    if ((++histline) >= HISTLEN)
+		histline = 0;
+	    histupdate();
+	    break;
+	case '\20':		/* C-p */
+	    if ((--histline) < 0)
+		histline = HISTLEN - 1;
+	    histupdate();
+	    break;
+	case '\r':
+	case '\n':
+	    if (!curli)
+		return;
+	    tputs_x(tgoto(CM, 0, LI - 1));
+	    tputs_x(CE);
+	    parseinput();
+	    if ((++histline) >= HISTLEN)
+		histline = 0;
+	    curx = curli = 0;
+	    linein = history[histline];
+	    break;
+	case '\27':
+	    if (object == NULL)
+		break;
+	    object = object->next;
+	    if (object == NULL)
+		object = objlist;
+	    wasdate = 0;
+	    break;
+	default:
+	    if (curli < 499) {
+		if (curli == curx) {	/* append character */
+		    linein[++curli] = '\0';
+		    linein[curx++] = ch;
+		    putchar(ch);
+		    tputs_x(CE);
+		} else {	/* insert somewhere in the middle */
+		    for (i = (++curli); i >= curx; i--)
+			linein[i + 1] = linein[i];
+		    linein[curx] = ch;
+		    for (i = (curx % CO); i < CO &&
+			(z = (curx / CO) * CO + i) < curli; i++)
+			putchar(linein[z]);
+		    tputs_x(CE);
+		    curx++;
+		}
+	    }
+	    break;
+	}
+    }
+}
+
+void cleanup(sig)
+int sig;
+{
+    tputs_x(tgoto(CS, -1, -1));
+    tputs_x(tgoto(CM, 0, LI - 1));
+    resetty();
+    printf("\ngot signal %d\n", sig);
+    exit(128 + sig);
+}
+
+int
+main(argc, argv)
+int argc;
+char **argv;
+{
+    char hostname[64];
+    int i;
+
+    stdinfd = fileno(stdin);
+    stdoutfd = fileno(stdout);
+    userinfo = getpwuid(getuid());
+    strcpy(hostname, DEFAULTSERVER);
+    if (!getenv("IRCNICK"))
+	strncpy(IRCNAME, userinfo->pw_name, sizeof(IRCNAME));
+    else
+	strncpy(IRCNAME, (char *) getenv("IRCNICK"), sizeof(IRCNAME));
+    if (argc > 1) {
+	for (i = 1; i < argc; i++)
+	    if (argv[i][0] == '-') {
+		if (argv[i][1] == 'd')
+		    dumb = 1;
+		else {
+		    fprintf(stderr, "usage: %s %s\n", argv[0],
+			    "[nick] [server] [port] [-dumb]");
+		    exit(1);
+		}
+	    } else if (strchr(argv[i], '.')) {
+		strcpy(hostname, argv[i]);
+	    } else if (atoi(argv[i]) > 255) {
+		IRCPORT = atoi(argv[i]);
+	    } else
+		strncpy(IRCNAME, argv[i], sizeof(IRCNAME));
+    }
+    printf("*** trying port %d of %s\n\n", IRCPORT, hostname);
+    if ((sockfd = makeconnect(hostname)) < 0) {
+	fprintf(stderr, "*** %s connection refused, aborting\n", hostname);
+	exit(0);
+    }
+    gethostname(localhost, 64);
+    if (!getenv("IRCNAME"))
+	sprintf(lineout, "USER %s %s %s :%s\n", userinfo->pw_name,
+		localhost, hostname, userinfo->pw_gecos);
+    else
+	sprintf(lineout, "USER %s %s %s :%s\n", userinfo->pw_name, localhost,
+		hostname, (char *)getenv("IRCNAME"));
+    sendline();
+    sprintf(lineout, "NICK :%s\n", IRCNAME);
+    sendline();
+    idletimer = time(NULL);
+    if (!dumb) {
+	ptr = termcap;
+	if ((term = (char *) getenv("TERM")) == NULL) {
+	    fprintf(stderr, "tinyirc: TERM not set\n");
+	    exit(1);
+	}
+	if (tgetent(bp, term) < 1) {
+	    fprintf(stderr, "tinyirc: no termcap entry for %s\n", term);
+	    exit(1);
+	}
+	if ((CO = tgetnum("co") - 2) < 1)
+	    CO = 78;
+	if ((LI = tgetnum("li")) == -1)
+	    LI = 24;
+	if ((CM = (char *) tgetstr("cm", &ptr)) == NULL)
+	    CM = (char *) tgetstr("CM", &ptr);
+	if ((SO = (char *) tgetstr("so", &ptr)) == NULL)
+	    SO = "";
+	if ((SE = (char *) tgetstr("se", &ptr)) == NULL)
+	    SE = "";
+	if (!CM || !(CS = (char *) tgetstr("cs", &ptr)) ||
+	    !(CE = (char *) tgetstr("ce", &ptr))) {
+	    printf("tinyirc: sorry, no termcap cm,cs,ce: dumb mode set\n");
+	    dumb = 1;
+	}
+	if (!dumb) {
+	    DC = (char *) tgetstr("dc", &ptr);
+	    wasdate = 0;
+	    signal(SIGINT, cleanup);
+	    signal(SIGHUP, cleanup);
+	    signal(SIGKILL, cleanup);
+	    signal(SIGQUIT, cleanup);
+	    signal(SIGSTOP, cleanup);
+	    signal(SIGSEGV, cleanup);
+	    savetty();
+	    raw();
+	    tputs_x(tgoto(CS, LI - 3, 0));
+	    updatestatus();
+	}
+    }
+    for (i = 0; i < HISTLEN; i++)
+	history[i] = (char *) calloc(512, sizeof(char));
+    linein = history[histline = 0];
+    while (sok && !beenden) {
+	FD_ZERO(&readfs);
+	FD_SET(sockfd, &readfs);
+	FD_SET(stdinfd, &readfs);
+	if (!dumb) {
+	    time_out.tv_sec = 61;
+	    time_out.tv_usec = 0;
+	}
+	if (select(FD_SETSIZE, &readfs, NULL, NULL, (dumb ? NULL : &time_out))) {
+	    if (FD_ISSET(stdinfd, &readfs))
+		userinput();
+	    if (FD_ISSET(sockfd, &readfs))
+		sok = serverinput();
+	    if (!wasdate)
+		updatestatus();
+	} else
+	    updatestatus();
+	if (!dumb) {
+	    tputs_x(tgoto(CM, curx % CO, LI - 1));
+	    fflush(stdout);
+	}
+    }
+    if (!dumb) {
+	tputs_x(tgoto(CS, -1, -1));
+	tputs_x(tgoto(CM, 0, LI - 1));
+	resetty();
+    }
+    exit(0);
+}
index: src/share/misc/acronyms
===================================================================
RCS file: /cvs/src/share/misc/acronyms,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/share/misc/acronyms	Sat Mar 22 15:41:55 2003
@@@@ -0,0 +1,361 @@@@
+$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+$NetBSD: acronyms,v 1.113 2003/02/05 20:11:04 mason Exp $
+10X	tenx (thanks)
+ACK	achja, cnnt klappen
+ACK	acknowledged / [japanese] Hai!
+AFAICR	as far as I can recall
+AFAICT	as far as I can tell
+AFAIHH	as far as I have heard
+AFAIK	as far as I know
+AFAIR	as far as I recall
+AFAIU	as far as I understand
+AFD	away from desktop
+AFK	away from keyboard
+AFW	away from window
+AIU	as I understand
+AIUI	as I understand it
+AKA	also known as
+ASAP	as soon as possible
+ATM	asynchronous transfer mode
+ATM	at the moment
+AWOL	absent without official leave
+AYB	all your base are belong to us
+AYBABTU	all your base are belong to us
+B4	before
+BASIC	beginners' all-purpose symbolic instruction code (_the_ programming language per se)
+BBIAB	be back in a bit
+BBIAF	be back in a few
+BBL	[I'll] be back later
+BBS	be back soon
+BBT	be back tomorrow
+BFD	big fucking deal
+BFG	big fat grin
+BIAB	back in a bit
+BIAF	back in a few
+BIALW	back in a little while
+BIAS	back in a second
+BIAW	back in a while
+BOFH	bastard operator from hell
+BOGAHICA	bend over, grab ankles, here it comes again
+BOHICA	bend over here it comes again
+BRB	[I'll] be right back
+BSD	basically secure and dependable
+BSD	big scary daemons
+BTDB	been there, done both
+BTDT	been there, done that
+BTST	been there, seen that
+BTTH	boot to the head
+BTW	by the way
+CMIIW	correct me if I'm wrong
+CNP	continued [in my] next post
+COB	close of business [day]
+CYA	see you around
+C|N>K	coffee pipe nose to keyboard
+DEBILLIAN	ancient GNU/Linux distribution, nearly forgotten
+DJB	Dan J Bernstein -- http://cr.yp.to/
+DKDC	don't know, don't care
+DOCH	German for "yes" answering "you don't ..., do you?"
+DOS	Disc Operating System
+DSTM	don't shoot the messenger
+DTRT	do the right thing
+DTWT	do the wrong thing
+DWIM	do what I mean
+EG	evil grin
+ELDA	ecolupo lacht dich aus
+ELDINA	ecolupo lacht dich immer noch aus
+ELF	endless long to wait for
+ELF	extrem langsames Format
+EMSG	email message
+EOB	end of business [day]
+EOL	end of life
+ESR	Eric Steven Raymond -- http://www.catb.org/~esr/
+ETA	estimated time of arrival (usually infinite)
+ETLA	extended three letter acronym
+EWAG	experienced wild-ass guess
+FAQ	frequently asked question
+FDA	Federal Drug Administration
+FDA	Fr den Arsch
+FIIK	fuck[ed] if I know
+FIIR	fuck[ed] if I remember
+FM	fucking magic
+FOAD	fall over and die
+FSDO	for some definition of
+FSF	Free Software Foundation -- http://www.fsf.org/ http://www.fsf-europe.org/
+FSVO	for some value of
+FTFM	fuck the fuckin' manual!
+FU	fuck you
+FUBAR	fucked up beyond all recognition
+FUD	fear, uncertainty and doubt
+FUQ	frequently unanswered questions
+FWIW	for what it's worth
+FYI	for your information
+G	grin
+GC	garbage collect{,ion} [also: g/c]
+GIGO	garbage in, garbage out
+GL	"gl hf" - good luck, have fun [StarCraft]
+GMTA	great minds think alike
+GN8	goodneight
+GTFO	get the fuck out
+HAND	have a nice day
+HDA	Heil den Asen (=OMG)
+HDB	Heil Dir, Bruder
+HDW	Heil den Wansen (=OMG)
+HF	see GL
+HHIS	hanging head in shame
+HTH	hoffentlich tut's helfen
+HTH	hope this helps
+IANAL	I am not a lawyer
+IHAFC	I haven't a fucking clue
+IHNFC	I have no fucking clue
+IIANM	if I am not mistaken
+IINM	if I'm not mistaken
+IIRC	if I recall correctly
+IMAO   in my arrogant opinion
+IMCO	in my considered opinion
+IMHO	in my humble opinion
+IMNSHO	in my not so humble opinion
+IMO	in my opinion
+IOW	in other words
+IPV6	next generation Internet Protocol, triggers japanese simple-mind ideas
+IRC	internet relay chat
+IRL	in real life
+ISAGN	I see a great need
+ISTM	it seems to me
+ISTR	I seem to recall
+ITYM	I think you mean
+ITYM	It's this you mean
+IYSS	If you say so
+JAJAJAJA	yes yes yes yes (common German expression in OpenBSD development)
+JFTR	just falls Thema reinkarniert
+JFTR	just for the record
+JIC	just in case
+JK	just kidding
+JMO	just my opinion
+JTLYK	just to let you know
+KISS	keep it simple, stupid
+KITA	kick in the ass
+KNF	kernel normal form (man 9 style)
+KUNDE	kann ungestraft nerven, da Einnahmequelle
+L8ER	later
+L8R	later
+LART	luser attitude readjustment tool (ie, hammer)
+LINUX	life is not utterly exciting
+LJBF	let's just be friends
+LKML	linux-kernel mailing list (vger.rutgers.edu -> vger.kernel.org)
+LMAO	laughing my ass off
+LMSO	laughing my socks off
+LOL	lachend, oba laut
+LOL	laughing out loud
+LTNS	long time no see
+MARC	http://marc.theaimsgroup.com/
+MCSE	"Mayday", called some experts
+MCSE	Minesweeper Consultant and Solitaire Expert
+MCSE	mad consultants slurping ethanol
+MCSE	madly causing slashdot effect
+MCSE	mail consumed somewhere in exchange
+MCSE	mainframe computers seemed extinct
+MCSE	maintenance contracts seem expensive
+MCSE	maintenance costs significantly extra
+MCSE	making companies surrender everyday
+MCSE	making computers slow everyday
+MCSE	making computers spew errors
+MCSE	making computers susceptible to exploit
+MCSE	making cretins self-employed
+MCSE	maledictis confutatious sounds exquisite
+MCSE	management can't send e-mail
+MCSE	management conned by something expensive
+MCSE	management coronaries soon enough
+MCSE	management will catch you with a screenful of erotica
+MCSE	managers contain significant egos
+MCSE	managing computers by slapdash empiricism
+MCSE	managing crap systems everyday
+MCSE	manipulative closed-source economics
+MCSE	many collisions saturate ethernet
+MCSE	marginal computer software enthusiast
+MCSE	marketing cancels software efficiency
+MCSE	marksmanship can solve everything
+MCSE	mass c squared is energy
+MCSE	massive computational solar eclipse
+MCSE	massive cyberspace sheepshearing empire
+MCSE	maybe could suggest exorcism
+MCSE	me-too computer science education
+MCSE	meandering cosmicrays 'sodded explorer
+MCSE	megabytes can soon evaporate
+MCSE	meowing cats suggest evil
+MCSE	migrane-causing suckage extravaganza
+MCSE	millenium caused societal extinction
+MCSE	mindfscked computers swapping egregiously
+MCSE	minimally cheerful software experience
+MCSE	minimising competence is so exhausting
+MCSE	minion of the crappy software empire
+MCSE	mischief causing shipwrecked equipment
+MCSE	misconceived computer science experiment
+MCSE	misguided consultant slagging eunuchs
+MCSE	misunderstanding cryptically strange errors
+MCSE	moe and curly's software emporium
+MCSE	molasses comparitively seems expeditious
+MCSE	molotov cocktails shutdown electricity
+MCSE	monetary compensation sounds exciting
+MCSE	mongolian clusterfsck swallows everything
+MCSE	monkies composing shakespearian equivalents
+MCSE	moot crypto software is exportable
+MCSE	more co-opted standards everyday
+MCSE	morning comes so early
+MCSE	moron confused by sun equipment
+MCSE	morons crudely simulating expertise
+MCSE	mortifying crackle of static electricity
+MCSE	most computers suck eggs
+MCSE	most computers suck exasperatingly
+MCSE	motherboard chips simulate encephalopathy
+MCSE	mounteback causing significant expenses
+MCSE	mouse clickings of sophomoric experimentation
+MCSE	mouse clicks selected "erase"
+MCSE	mozilla couldn't stomach explorer
+MCSE	multiple corrective servicepack exorcist
+MCSE	must consult someone experienced
+MCSE	must...  contain...   STR.   Eaaaaaaaaaaaurgh!
+MCSE	mutant computer solutions evangelist
+MCSE	mutant computers seem eviscerated
+MCSE	mutated CP/M system emulator
+MCSE	mutated convoluted strokery everywhere
+MCSE	my cat studies ecclesiastes
+MCSE	my company screws everyone
+MCSE	my computer's software exploded
+MCSE	my cranium softened easily
+MCSE	my customers support extravagance
+MFG	with friendly greetings
+MIPS	meaningless indicator of processor speed
+MIPS	meaningless information provided by salesperson
+MIPS	{def.} die Zahl von Millionen Maschinenoperationen pro Sekunde, von der der Hersteller garantiert, da sie unter keinerlei Betriebsbedingungen berschritten wird
+MMU	memory management unit
+MOTAS	member of the appropriate sex
+MOTOS	member of the opposite sex
+MOTSS	member of the same sex
+MTF	more to follow
+MYOB	mind your own business
+N8	goodneight
+NBD	no big deal
+NFC	no fucking clue
+NFI	no fucking idea
+NFW	no fucking way
+NIH	not invented here
+NMP	not my problem
+NP	no problem
+NP	now playing
+NR	not really
+NRFPT	not ready for prime time
+NRN	no reply necessary
+OIC	oh, I see
+OMG	Oh my Goddess!
+OT	off topic
+OT	ohne Themenbezug
+OTL	out to lunch
+OTOH	on the other hand
+OTT	over the top
+OTTOMH	off the top of my head
+PEBCAK	reverse'ism for PEBKAC
+PEBKAC	problem exists between keyboard and chair
+PFO	please fuck off
+PFY	pimply faced youth
+PITA	pain in the ass
+PKSP	pound keys and spew profanity
+PLONK	Poster liest Originalposter nicht konsequent
+PNG	persona non grata
+PNP	{pay,plug} and pray
+POC	point of contact
+POLA	principle of least astonishment
+POS	piece of shit
+PPL	pretty please
+PTV	parental tunnel vision
+QED	quod erat demonstrandum
+RATIBIBUGLE	french-specific version of ROTOTILL
+RFC	request for comment
+RL	real life
+RLC	rod length check
+RMS	Richard M Stallman -- http://www.stallman.org/
+ROFL	Respekt, Originalposting fein lustig
+ROFL	rolling on floor laughing
+ROFLMAO	rolling on floor laughing my ass off
+ROTFL	Respekt, Originalposting tatschlich fein lustig
+ROTFL	rolling on the floor laughing
+ROTFLBTCDICAJTTWADBSIHPWTRHITSBKABAYB	rolling on the floor laughing, biting the carpet, dancing in circles and jumping through the window almost dieing by smashing into hp who's then running horrified into the street being killed accidentally by a yellow bulldozer
+ROTFLMAO	rolling on the floor laughing my ass off
+ROTOTILL	"nuke with a chain saw device", to die with extreme prejudice (see GC)
+RP	responsible person
+RSN	real soon now
+RTFB	read the fine/fucking book
+RTFJF	read the fine jargon file: http://www.catb.org/~esr/jargon/
+RTFM	read the fine/fucking manual
+RTFMF	read the fucking Makefile
+RTFMP	read the fine/fucking man page
+RTFRFC	read the boring RFC
+RTFRFC	read the {fine,fucking} RFC
+RTFS	read the fine/fucking source
+RTFWS	read the {fine,fucking} web site
+RTFWS	return to frankensteins wooly sheep
+SCNR	schulljung, connte nit rckhalten
+SCNR	sorry, could not resist
+SEP	someone else's problem
+SFA	sweet fuck all
+SHID	slaps head in disgust
+SHOK	smashing head on keyboard
+SIMCA	sitting in my chair amused
+SMLSFB	so many losers, so few bullets
+SMOP	simple matter of programming
+SNAFU	situation normal, all fucked up
+SNERT	snot-nosed egotistical rude teenager
+SO	significant other
+SOB	son of [a] bitch
+SOL	shit out [of] luck
+SOP	standard operating procedure
+SSIA	subject says it all
+STFA	search the fscking archives
+SUS	stupid user syndrome
+SWAG	silly, wild-assed guess
+SWAHBI	silly, wild-assed hare-brained idea
+SWMBO	she who must be obeyed
+TANSTAAFL	there ain't no such thing as a free lunch
+TBD	to be {decided,determined,done}
+TDR	Theo de Raadt -- http://theos.com/
+THGTTG	the hitchhiker's guide to the galaxy
+TIA	thanks in advance
+TLA	three letter acronym
+TLB	translation lookaside buffer
+TMA	too many abbreviations
+TMI	too much information
+TNX	thanks
+TOEFL	test of english as a foreign language
+TPTB	the powers that be (Theo de Raadt et. al with commit access)
+TTFN	ta ta for now
+TTY	teletype terminal
+TTYL	talk to you later
+TTYL8ER	tty (read) you later [usenet]
+TWIAVBP	the world is a very big place
+TYVM	thank you very much
+UTFG	use the fscking google
+UTFS	use the {fine,fucking} source
+UTSL	use the source, Luke
+VEG	very evil grin
+WAG	wild-ass guess
+WB	welcome back
+WDYM	what do you mean
+WHY	because.
+WIBNI	wouldn't it be nice if
+WINDOWS	Will ich nicht doch ohne WINDOWS sein?
+WINDOWS	will install needless data on whole system
+WINDOWS	work is never done on WINDOWS systems.
+WOFTAM	waste of fucking time and money
+WOMBAT	waste of money, brain, and time
+WRT	with respect to
+WTF	oh, it's me! *g*
+WTF	{what,where,who,why} the fuck
+WTH	{what,where,who,why} the hell
+WYSIWYG	what you see is what you get
+XD	;-) on espaol
+YGWYPF	you get what you {pay,prayed} for
+YHBT	you have been trolled
+YHL	you have lost
+YKWIM	you know what I mean
+YMA	yo momma's ass
+YMMD	you made my day!
+YMMV	your mileage may vary
index: src/usr.bin/brainfuck/Makefile
===================================================================
RCS file: /cvs/src/usr.bin/brainfuck/Makefile,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/usr.bin/brainfuck/Makefile	Sat Mar 22 15:41:55 2003
@@@@ -0,0 +1,12 @@@@
+# $MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+# Public domain.
+
+SCRIPTS=brainfuck
+NOOBS=	noobj
+MAN=	brainfuck.1
+
+realinstall:
+	cd ${.CURDIR}; install -c -o ${BINOWN} -g ${BINGRP} -m 555 \
+	    ${SCRIPTS} ${DESTDIR}${BINDIR}
+
+.include <bsd.prog.mk>
index: src/usr.bin/brainfuck/brainfuck
===================================================================
RCS file: /cvs/src/usr.bin/brainfuck/brainfuck,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/usr.bin/brainfuck/brainfuck	Sat Mar 22 15:41:55 2003
@@@@ -0,0 +1,7 @@@@
+#!/usr/bin/perl
+#
+# Public domain by Marko Nippula
+
+$/=$a;while(<>){s/./$&;/g;s/\+|-/P$&$&/g;s/</\$p--/g;s/>/\$p++/g;s/\./
+print chr P/g;s/,/P=ord getc/g;y/[]/{}/;s/{/while(P){/g;s/P/\$m[\$p]/g
+;eval$_;print$@@if$@@}
index: src/usr.bin/brainfuck/brainfuck.1
===================================================================
RCS file: /cvs/src/usr.bin/brainfuck/brainfuck.1,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Sat Mar 22 15:41:55 2003
@@@@ -0,0 +1,73 @@@@
+.\"	$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+.\"
+.\" Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
+.\"
+.\" Anyone who obtained a copy of this work is hereby permitted to freely use,
+.\" distribute, modify, merge, sublicence, give away or sell it as long as the
+.\" authors are given due credit and the following notice is retained:
+.\"
+.\" This work is provided "as is", with no explicit or implicit warranty what-
+.\" soever. Use it only at your own risk. In no event may an author or contri-
+.\" butor be held liable for any damage, directly or indirectly, that origina-
+.\" ted through or is caused by creation or modification of this work.
+.\"
+.Dd November 3, 2002
+.Dt BRAINFUCK 1
+.Os MirBSD 20021103
+.Sh NAME
+.Nm brainfuck
+.Nd perl brainfuck interpreter
+.Sh SYNOPSIS
+.Nm
+.Sh DESCRIPTION
+The
+.Nm
+utility interprets its standard input as a brainfuck script.
+Processing will start after EOF.
+If you started
+.Nm
+interactively, hit Ctrl-D on a new line to start.
+.Pp
+.Sh THE LANGUAGE
+brainfuck is a simple enough language to include the entire official language
+describtion in this man page.
+The following is from the original brainfuck distribution by Urban Mueller
+\f(CW<umueller@@amiga.physik.unizh.ch\fR>, who also invented the language:
+.Pp
+The language \fIbrainfuck\fR knows the following commands:
+.Pp
+.Bd -literal -offset indent
+\& Cmd  Effect                                    Equivalent in C
+\& ---  ------                                    ---------------
+\& +    Increases element under pointer           array[p]++;
+\& -    Decrases element under pointer            array[p]--;
+\& >    Increases pointer                         p++;
+\& <    Decreases pointer                         p--;
+\& [    Starts loop, counter under pointer        while(array[p]) {
+\& ]    Indicates end of loop                     }
+\& .    Outputs ASCII code under pointer          putchar(array[p]);
+\& ,    Reads char and stores ASCII under ptr     array[p]=getchar();
+.Ed
+
+All other characters are ignored.
+
+The array elements and p are being initialized to zero at the beginning.
+Now while this seems to be a pretty useless language, it can be proven
+that it can compute every solvable mathematical problem (if we ignore
+the array size limit and the executable size limit).
+.Sh HISTORY
+.Nm
+first appeared in
+.Ox
+3.2-mirabile.
+.Sh AUTHORS
+.Bl -inset
+.It Em Urban Mueller
+designed the language.
+.It Em Marko Nippula
+wrote this interpreter.
+.It Em Chaos Computer Club Cologne
+gave some hints for the man page.
+.It Em Thorsten Glaser
+wrote this man page and put the things together.
+.El
index: src/usr.bin/host/Makefile
===================================================================
RCS file: /cvs/src/usr.bin/host/Makefile,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/usr.bin/host/Makefile	Sat Mar 22 15:41:55 2003
@@@@ -0,0 +1,12 @@@@
+# $MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+# Public domain.
+
+PROG=	host
+CFLAGS+=-Wall -Werror -pedantic
+MLINKS+=host.1 nslookup.8
+
+afterinstall:
+	cd ${.CURDIR} && ${INSTALL} ${INSTALL_COPY} -o root -g bin \
+		-m 555 nslookup ${DESTDIR}${BINDIR}
+
+.include <bsd.prog.mk>
index: src/usr.bin/host/host.1
===================================================================
RCS file: /cvs/src/usr.bin/host/host.1,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/usr.bin/host/host.1	Sat Mar 22 15:41:55 2003
@@@@ -0,0 +1,879 @@@@
+.\"	$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+.\"	$OpenBSD: host.1,v 1.6 2000/08/02 15:58:09 provos Exp $
+.\"	@@(#)host.1              e07@@nikhef.nl (Eric Wassenaar) 961010
+.\"
+.TH host 1 "961010"
+.SH NAME
+host \- query nameserver about domain names and zones
+.SH SYNOPSIS
+.na
+.nf
+\fBhost\fP [\fB\-v\fP] [\fB\-a\fP] [\fB\-t\fP \fIquerytype\fP] [\fIoptions\fP]  \fIname\fP  [\fIserver\fP]
+.br
+\fBhost\fP [\fB\-v\fP] [\fB\-a\fP] [\fB\-t\fP \fIquerytype\fP] [\fIoptions\fP]  \fB\-l\fP \fIzone\fP  [\fIserver\fP]
+.br
+\fBhost\fP [\fB\-v\fP] [\fIoptions\fP] \fB\-H\fP [\fB\-D\fP] [\fB\-E\fP] [\fB\-G\fP] \fIzone\fP
+.br
+\fBhost\fP [\fB\-v\fP] [\fIoptions\fP] \fB\-C\fP \fIzone\fP
+.br
+\fBhost\fP [\fB\-v\fP] [\fIoptions\fP] \fB\-A\fP \fIhost\fP
+.sp
+\fBhost\fP [\fIoptions\fP] \fB\-x\fP [\fIname\fP ...]
+.br
+\fBhost\fP [\fIoptions\fP] \fB\-X\fP \fIserver\fP [\fIname\fP ...]
+.br
+\fBnslookup\fP
+.SH DESCRIPTION
+.I host
+looks for information about Internet hosts and domain names.
+It gets this information from a set of interconnected servers
+that are spread across the world. The information is stored
+in the form of "resource records" belonging to hierarchically
+organized "zones".
+.PP
+.I nslookup
+is only included for compatibility reasons.
+Do not use it, it may be removed in the future.
+.PP
+By default, the program simply converts between host names and Internet
+addresses. However, with the \fB\-t\fP, \fB\-a\fP and \fB\-v\fP
+options, it can be used to find all of the information about
+domain names that is maintained by the domain nameserver system.
+The information printed consists of various fields of the
+associated resource records that were retrieved.
+.PP
+The arguments can be either host names (domain names) or numeric
+Internet addresses.
+.PP
+A numeric Internet address consists of four decimal numbers
+separated by dots, e.g., \fB192.16.199.1\fP, representing the
+four bytes of the 32-bit address.
+.br
+The default action is to look up the associated host name.
+.PP
+A host name or domain name consists of component names (labels)
+separated by dots, e.g., \fBnikhefh.nikhef.nl\fP
+.br
+The default action is to look up all of its Internet addresses.
+.PP
+For single names without a trailing dot, the local domain is
+automatically tacked on the end.
+Thus a user in domain "nikhef.nl" can say "host nikhapo",
+and it will actually look up "nikhapo.nikhef.nl".
+In all other cases, the name is tried unchanged.
+Single names with trailing dot are considered top-level domain
+specifications, e.g., "nl."
+.PP
+Note that the usual lookup convention for any name that does not end
+with a trailing dot is to try first with the local domain appended,
+and possibly other search domains.
+This convention is not used by this program.
+.PP
+The actual suffix to tack on the end is usually the local domain
+as specified in the \fB/etc/resolv.conf\fP file, but this can be
+overridden.
+See below for a description of how to customize the host name lookup.
+.SH ARGUMENTS
+The first argument is normally the host name (domain name) for which
+you want to look up the requested information.
+If the first argument is an Internet address, a query is done on the
+special "reverse mapping" domain to look up its associated host name.
+.PP
+If the \fB\-l\fP option is given, the first argument is a domain zone
+name for which a complete listing is given. The program enters a
+special zone listing mode which has several variants (see below).
+.PP
+The second argument is optional. It allows you to specify a particular
+server to query.  If you don't specify this argument, default servers
+are used, as defined by the \fB/etc/resolv.conf\fP file.
+.SS "EXTENDED SYNTAX"
+If the \fB\-x\fP option is given, it extends the syntax in the sense
+that multiple arguments are allowed on the command line. An optional
+explicit server must now be specified using the \fB\-X\fP option as it
+cannot be given as an ordinary argument any more. The \fB\-X\fP
+option implies \fB\-x\fP.
+.sp
+The extended syntax allows no arguments at all, in which case the
+arguments will be read from standard input. This can be a pipe,
+redirection from a file, or an interactive terminal. Note that
+these arguments are the names to be queried, and not command options.
+Everything that appears after a '#' or ';' on an input line will be
+skipped. Multiple arguments per line are allowed.
+.SS OPTIONS
+There are a number of options that can be used before the specified
+arguments.  Some of these options are meaningful only to the people
+who maintain the domain database zones.
+The first options are the regularly used ones.
+.TP 4
+.B \-v
+causes printout to be in a "verbose" format.
+All resource record fields are printed.
+Without this option, the ttl and class fields are not shown.
+Also the contents of the "additional information" and "authoritative
+nameservers" sections in the answer from the nameserver are printed,
+if present.  Normally these sections are not shown.
+In addition, the verbose option prints extra information about the
+various actions that are taken by the program.
+Note that \fB\-vv\fP is "very verbose". This generates a lot of output.
+.TP
+.BI \-t " querytype"
+allows you to specify a particular type of resource record information
+to be looked up.  Supported types are listed below.
+The wildcard may be written as either \fBANY\fP or \fB*\fP.
+Types may be given in upper or lower case.
+The default is type \fBA\fP for regular lookups,
+and \fBA\fP, \fBNS\fP, and \fBPTR\fP for zone listings.
+.TP
+.B \-a
+is equivalent to \fB\-t ANY\fP.
+Note that this gives you "anything available" (currently cached) and
+not "all defined data" if a non-authoritative server is queried.
+.SS "SPECIAL MODES"
+The following options put the program in a special mode.
+.TP 4
+.BI \-l " zone"
+generates the listing of an entire zone.
+.sp
+E.g. the command
+.br
+	\fBhost \-l nikhef.nl\fP
+.br
+will give a listing of all hosts in the "nikhef.nl" zone.
+The \fB\-t\fP option is used to filter what information is
+extracted, as you would expect. The default is address
+information from A records, supplemented with data from PTR
+and NS records.
+.sp
+The command
+.br
+	\fBhost \-Z \-a \-l nikhef.nl\fP
+.br
+will give a complete download of the zone data for "nikhef.nl",
+in the official master file format.
+.TP 4
+.B \-H
+can be specified instead of the \fB\-l\fP option. It will print
+the count of the unique hostnames (names with an A record)
+encountered within the zone.
+It will not count pseudo names like "localhost", nor addresses
+associated with the zone name itself. Neither are counted the
+"glue records" that are necessary to define nameservers for
+the zone and its delegated zones.
+.sp
+By default, this option will not print any resource records.
+.sp
+Combined with the \fB\-S\fP option, it will give a complete
+statistics survey of the zone.
+.sp
+The host count may be affected by duplicate hosts (see below).
+To compute the most realistic value, subtract the duplicate
+host count from the total host count.
+.TP
+.B \-G
+implies \fB\-H\fP, but lists the names of gateway hosts.
+These are the hosts that have more than one address.
+Gateway hosts are not checked for duplicate addresses.
+.TP
+.B \-E
+implies \fB\-H\fP, but lists the names of extrazone hosts.
+An extrazone host in zone "foo.bar" is of the form
+"host.xxx.foo.bar" where "xxx.foo.bar" is not defined as
+a delegated zone with an NS record.
+This may be intentional, but also may be an error.
+.TP
+.B \-D
+implies \fB\-H\fP, but lists the names of duplicate hosts.
+These are hosts with only one address, which is known to
+have been defined also for another host with a different name,
+possibly even in a different zone.
+This may be intentional, but also may be an error.
+.TP
+.B \-C
+can be specified instead of the \fB\-l\fP option. It causes the SOA
+records for the specified zone to be compared as found at each of
+the authoritative nameservers for the zone (as listed in the NS records).
+Nameserver recursion is turned off, and it will be checked whether
+the answers are really authoritative. If a server cannot provide an
+authoritative SOA record, a lame delegation of the zone to that server
+is reported.
+Discrepancies between the records are reported. Various sanity checks
+are performed.
+.TP
+.B \-A
+enters a special address check mode.
+.sp
+If the first argument is a host name, its addresses will be retrieved,
+and for each of the addresses it will be checked whether they map back
+to the given host.
+.sp
+If the first argument is a dotted quad Internet address, its name will
+be retrieved, and it will be checked whether the given address is listed
+among the known addresses belonging to that host.
+.sp
+If the \fB\-A\fP flag is specified along with any zone listing option,
+a reverse lookup of the address in each encountered A record is performed,
+and it is checked whether it is registered and maps back to the name of
+the A record.
+.SS "SPECIAL OPTIONS"
+The following options apply only to the special zone listing modes.
+.TP 4
+.BI \-L " level"
+Recursively generate zone listings up to this level deep.
+Level 1 traverses the parent zone and all of its delegated zones.
+Each additional level descends into another layer of delegated zones.
+.TP
+.B \-S
+prints statistics about the various types of resource records found
+during zone listings, the number of various host classifications,
+the number of delegated zones, and some total statistics after
+recursive listings.
+.TP
+.B \-p
+causes only the primary nameserver of a zone to be contacted for zone
+transfers during zone listings. Normally, zone transfers are obtained
+from any one of the authoritative servers that responds.
+The primary nameserver is obtained from the SOA record of the zone.
+If a specific server is given on the command line, this option will
+query that server for the desired nameservers of the zone. This can be
+used for testing purposes in case the zone has not been registered yet.
+.TP
+.BI \-P " prefserver"
+gives priority for zone transfers to preferred servers residing in
+domains given by the comma-separated list \fIprefserver\fP. The more
+domain component labels match, the higher the priority.
+If this option is not present, priority is given to servers within
+your own domain or parent domains.
+The order in which NS records are issued may be unfavorable if they
+are subject to BIND 4.9 round-robin reshuffling.
+.TP
+.BI \-N " skipzone"
+prohibits zone transfers for the zones given by the comma-separated
+list \fIskipzone\fP. This may be used during recursive zone listings
+when certain zones are known to contain bogus information which
+should be excluded from further processing.
+.SS "COMMON OPTIONS"
+The following options can be used in both normal mode and domain
+listing mode.
+.TP 4
+.B \-d
+turns on debugging.  Nameserver transactions are shown in detail.
+Note that \fB\-dd\fP prints even more debugging output.
+.TP
+.BI \-f " filename"
+writes the resource record output to the given logfile as well as
+to standard output.
+.TP
+.BI \-F " filename"
+same as \fB\-f\fP, but exchange the role of stdout and logfile.
+All stdout output (including verbose and debug printout) goes to
+the logfile, and stdout gets only the extra resource record output
+(so that it can be used in pipes).
+.TP
+.BI \-I " chars"
+suppresses warning messages about illegal domain names containing
+invalid characters, by specifying such characters in the string
+\fIchars\fP. The underscore is a good candidate.
+.TP
+.B \-i
+constructs a query for the "reverse mapping" \fBin-addr.arpa\fP
+domain in case a numeric (dotted quad) address was specified.
+Useful primarily for zone listing mode, since for numeric regular
+lookups such query is done anyway (but with \-i you see the actual
+PTR resource record outcome).
+.TP
+.B \-n
+constructs a query for the "reverse mapping" \fBnsap.int\fP
+domain in case an nsap address was specified.
+This can be used to look up the names associated with nsap addresses,
+or to list reverse nsap zones.
+An nsap address consists of an even number of hexadecimal digits,
+with a maximum of 40, optionally separated by interspersed dots.
+An optional prefix "0x" is skipped.
+If this option is used, all reverse nsap.int names are by default
+printed in forward notation, only to improve readability.
+The \fB\-Z\fP option forces the output to be in the official zone
+file format.
+.TP
+.B \-q
+be quiet and suppress various warning messages (the ones preceded
+by " !!! ").
+Serious error messages (preceded by " *** ") are never suppressed.
+.TP
+.B \-T
+prints the time-to-live values during non-verbose output.
+By default the ttl is shown only in verbose mode.
+.TP
+.B \-Z
+prints the selected resource record output in full zone file format,
+including trailing dot in domain names, plus ttl value and class name.
+.SS "OTHER OPTIONS"
+The following options are used only in special circumstances.
+.TP 4
+.BI \-c " class"
+allows you to specify a particular resource record class.
+Supported are
+\fBIN\fP, \fBINTERNET\fP, \fBCS\fP, \fBCSNET\fP, \fBCH\fP, \fBCHAOS\fP,
+\fBHS\fP, \fBHESIOD\fP, and the wildcard \fBANY\fP or \fB*\fP.
+The default class is \fBIN\fP.
+.TP
+.B \-e
+excludes information about names that are not residing within
+the given zone during zone listings, such as some glue records.
+For regular queries, it suppresses the printing of the "additional
+information" and "authoritative nameserver" sections in the answer
+from the nameserver.
+.TP
+.B \-m
+is equivalent to \fB\-t MAILB\fP, which filters
+any of types \fBMB\fP, \fBMR\fP, \fBMG\fP, or \fBMINFO\fP.
+In addition, \fBMR\fP and \fBMG\fP records will be recursively
+expanded into \fBMB\fP records.
+.TP
+.B \-o
+suppresses the resource record output to stdout. Can be used in
+combination with the \fB\-f\fP option to separate the resource
+record output from verbose and debug comments and error messages.
+.TP
+.B \-r
+causes nameserver recursion to be turned off in the request.
+This means that the contacted nameserver will return only data
+it has currently cached in its own database.
+It will not ask other servers to retrieve the information.
+Note that nameserver recursion is always turned off when checking
+SOA records using the \fB\-C\fP option. Authoritative servers
+should have all relevant information available.
+.TP
+.B \-R
+Normally querynames are assumed to be fully qualified and are
+tried as such, unless it is a single name, which is always tried
+(and only once) in the default domain.
+This option simulates the default BIND behavior by qualifying
+any specified name by repeatedly adding search domains, with
+the exception that the search terminates immediately if the name
+exists but does not have the desired querytype.
+The default search domains are constructed from the default domain
+by repeatedly peeling off the first component, until a final domain
+with only one dot remains.
+.TP
+.BI \-s " seconds"
+specifies a new nameserver timeout value. The program will wait
+for a nameserver reply in two attempts of this number of seconds.
+Normally it does 2 attempts of 5 seconds per nameserver address tried.
+The actual timeout algorithm is slightly more complicated, extending
+the timeout value dynamically depending on the number of tries and
+the number of nameserver addresses.
+.TP
+.B \-u
+forces the use of virtual circuits (TCP) instead of datagrams (UDP) when
+issuing nameserver queries. This is slower, but potentially more reliable.
+Note that a virtual circuit is automatically chosen in case a query
+exceeds the maximum datagram packet size. Also if a datagram answer
+turns out to be truncated, the query is retried using virtual circuit.
+A zone transfer is always done via a virtual circuit.
+.TP
+.B \-w
+causes the program to retry forever if the response to a regular query
+times out. Normally it will time out after some 10 seconds per
+nameserver address tried.
+.TP
+.B \-V
+prints just the version number of the \fBhost\fP program, and exits.
+.SS "DEFAULT OPTIONS"
+Default options and parameters can be preset in an environment
+variable \fBHOST_DEFAULTS\fP using the same syntax as on the command
+line. They will be evaluated before the command line arguments.
+.SH QUERYTYPES
+The following querytypes (resource record types) are supported.
+Indicated within parentheses are the various kinds of data fields.
+.TP 10
+.B A
+Host address (dotted quad)
+.TP
+.B NS
+Authoritative nameserver (domain name)
+.TP
+.B MD
+Mail destination (domain name)
+.TP
+.B MF
+Mail forwarder (domain name)
+.TP
+.B CNAME
+Canonical name for an alias (domain name)
+.TP
+.B SOA
+Marks the start of a zone of authority
+(domain name of primary, domain name of hostmaster,
+serial, refresh, retry, expiration, default ttl)
+.TP
+.B MB
+Mailbox domain name (domain name)
+.TP
+.B MG
+Mail group member (domain name)
+.TP
+.B MR
+Mail rename domain name (domain name)
+.TP
+.B NULL
+Null resource record (no format or data)
+.TP
+.B WKS
+Well-known service description (dotted quad, protocol name, list of services)
+.TP
+.B PTR
+Domain name pointer (domain name)
+.TP
+.B HINFO
+Host information (CPU type string, OS type string)
+.TP
+.B MINFO
+Mailbox or mail list information (request domain name, error domain name)
+.TP
+.B MX
+Mail exchanger (preference value, domain name)
+.TP
+.B TXT
+Descriptive text (one or more strings)
+.TP
+.B UINFO
+User information (string)
+.TP
+.B UID
+User identification (number)
+.TP
+.B GID
+Group identification (number)
+.TP
+.B UNSPEC
+Unspecified binary data (data)
+.TP
+.B ANY
+Matches information of any type available.
+.TP
+.B MAILB
+Matches any of types \fBMB\fP, \fBMR\fP, \fBMG\fP, or \fBMINFO\fP.
+.TP
+.B MAILA
+Matches any of types \fBMD\fP, or \fBMF\fP.
+.PP
+The following types have been defined in RFC 1183, but
+are not yet in general use. They are recognized by this program.
+.TP 10
+.B RP
+Responsible person (domain name for MB, domain name for TXT)
+.TP
+.B AFSDB
+AFS database location (type, domain name)
+.TP
+.B X25
+X25 address (address string)
+.TP
+.B ISDN
+ISDN address (address string, optional subaddress string)
+.TP
+.B RT
+Route through host (preference value, domain name)
+.PP
+The following types have been defined in RFC 1348, but
+are not yet in general use. They are recognized by this program.
+RFC 1348 has already been obsoleted by RFC 1637 and RFC 1706,
+which defines a new experimental usage of NSAP records.
+This program has now hooks to manipulate them.
+.TP 10
+.B NSAP
+NSAP address (encoded address)
+.TP
+.B NSAP-PTR
+NSAP pointer (domain name)
+.PP
+The following are new types as per RFC 1664 and RFC 1712.
+Note that the GPOS type has been withdrawn already, and will be
+superseded by the LOC type.
+.TP 10
+.B PX
+X400 to RFC822 mapping (preference value, rfc822 domain, x400 domain)
+.TP
+.B GPOS
+Geographical position (longitude string, latitude string, altitude string)
+.PP
+The following types have already been reserved in RFC 1700, but are
+not yet implemented.
+.TP 10
+.B SIG
+Security signature
+.TP
+.B KEY
+Security key
+.PP
+The IP v6 address architecture and DNS extensions are defined in
+RFC 2373 and RFC 1886.
+.TP 10
+.B AAAA
+IP v6 address (address spec with colons)
+.PP
+The following type is documented in RFC 1876.
+.TP 10
+.B LOC
+Geographical location (latitude, longitude, altitude, precision)
+.PP
+The following types have been proposed, but are still in draft.
+.TP 10
+.B NXT
+Next valid record
+.TP
+.B EID
+Endpoint identifier
+.TP
+.B NIMLOC
+Nimrod locator
+.TP
+.B SRV
+Internet service information
+.TP
+.B ATMA
+ATM address
+.TP
+.B NAPTR
+Naming authority URN
+.SH EXAMPLES
+A very good summary and validation of an entire zone can be obtained
+with the following command:
+.sp
+	\fBhost \-G \-S \-C \-A \-L 1\fP \fIzone\fP
+.sp
+.SH DIAGNOSTICS
+.SS "FAILURE MESSAGES"
+The following messages are printed to show the reason
+of failure for a particular query. The name of an explicit
+server, if specified, may be included. If a special class
+was requested, it is also shown.
+.TP 4
+Nameserver [\fIserver\fP] not running
+The contacted server host does not have a nameserver running.
+.TP
+Nameserver [\fIserver\fP] not responding
+The nameserver at the contacted server host did not give a reply
+within the specified time frame.
+.TP
+Nameserver [\fIserver\fP] not reachable
+The network route to the intended server host is blocked.
+.TP
+\fIname\fP does not exist [at \fIserver\fP] (Authoritative answer)
+The queryname does definitely not exist at all.
+.TP
+\fIname\fP does not exist [at \fIserver\fP], try again
+The queryname does not exist, but the answer was not authoritative,
+so it is still undecided.
+.TP
+\fIname\fP has no \fItype\fP record [at \fIserver\fP] (Authoritative answer)
+The queryname is valid, but the specified type does not exist.
+This status is here returned only in case authoritative.
+.TP
+\fIname\fP \fItype\fP record currently not present [at \fIserver\fP]
+The specified type does not exist, but we don't know whether
+the queryname is valid or not. The answer was not authoritative.
+Perhaps recursion was off, and no data was cached locally.
+.TP
+\fIname\fP \fItype\fP record not found [at \fIserver\fP], try again
+Some intermediate failure, e.g., timeout reaching a nameserver.
+.TP
+\fIname\fP \fItype\fP record not found [at \fIserver\fP], server failure
+Some explicit nameserver failure to process the query, due to internal
+or forwarding errors. This may also be returned if the zone data has
+expired at a secondary server, of when the server is not authoritative
+for some class.
+.TP
+\fIname\fP \fItype\fP record not found [at \fIserver\fP], no recovery
+Some irrecoverable format error, or server refusal.
+.TP
+\fIname\fP \fItype\fP record query refused [by \fIserver\fP]
+The contacted nameserver explicitly refused to answer the query.
+Some nameservers are configured to refuse zone transfer requests
+that come from arbitrary clients.
+.TP
+\fIname\fP \fItype\fP record not found [at \fIserver\fP]
+The exact reason for failure could not be determined.
+(This should not happen).
+.TP
+\fIzone\fP has lame delegation to \fIserver\fP
+If we query a supposedly authoritative nameserver for the SOA record
+of a zone, the information should be available and the answer should
+be authoritative. If not, a lame delegation is flagged. This is also
+done if the server turns out not to exist at all. Ditto if we ask for
+a zone transfer and the server cannot provide it.
+.TP
+No nameservers for \fIzone\fP found
+It was not possible to retrieve the name of any nameserver
+for the desired zone, in order to do a zone transfer.
+.TP
+No addresses of nameservers for \fIzone\fP found
+We got some nameserver names, but it was not possible to retrieve
+addresses for any of them.
+.TP
+No nameservers for \fIzone\fP responded
+When trying all nameservers in succession to do a zone transfer,
+none of them were able or willing to provide it.
+.SS "WARNING AND ERROR MESSAGES"
+Miscellaneous warning messages may be generated.
+They are preceded by " !!! " and indicate some non-fatal condition,
+usually during the interpretation of the retrieved data.
+These messages can be suppressed with the \-q command line option.
+.sp
+Error messages are preceded by " *** " and indicate a serious problem,
+such as format errors in the answers to queries, but also major
+violations of the specifications.
+Those messages cannot be suppressed.
+.TP 4
+\fIzone\fP has only one nameserver \fIserver\fP
+When retrieving the nameservers for a zone, it appears that only one
+single nameserver exists.  This is against the recommendations.
+.TP
+\fIzone\fP nameserver \fIserver\fP is not canonical (\fIrealserver\fP)
+When retrieving the nameservers for a zone, the name of the specified
+server appears not to be canonical. This may cause serious operational
+problems. The canonical name is given between parentheses.
+.TP
+empty zone transfer for \fIzone\fP from \fIserver\fP
+The zone transfer from the specified server contained no data, perhaps
+only the SOA record. This could happen if we query the victim of a
+lame delegation which happens to have the SOA record in its cache.
+.TP
+extraneous NS record for \fIname\fP within \fIzone\fP from \fIserver\fP
+During a zone transfer, an NS record appears for a name which is not
+a delegated subzone of the current zone.
+.TP
+extraneous SOA record for \fIname\fP within \fIzone\fP from \fIserver\fP
+During a zone transfer, an SOA record appears for a name which is
+not the name of the current zone.
+.TP
+extraneous glue record for \fIname\fP within \fIzone\fP from \fIserver\fP
+During a zone transfer, a glue record is included for a name which
+is not part of the zone or its delegated subzones. This is done in some
+older versions of BIND. It is undesirable since unauthoritative, or even
+incorrect, information may be propagated.
+.TP
+incomplete \fItype\fP record for \fIname\fP
+When decoding the resource record data from the answer to a query,
+not all required data fields were present. This is frequently the case
+for HINFO records of which only one of the two data field is encoded.
+.TP
+\fIname\fP has both NS and A records within \fIzone\fP from \fIserver\fP
+An A record has been defined for the delegated zone \fIname\fP. This is
+signalled only during the transfer of the parent \fIzone\fP. It is not
+an error, but the overall hostcount may be wrong, since the A record
+is counted as a host in the parent zone. This A record is not included
+in the hostcount of the delegated zone.
+.TP
+\fIname\fP \fItype\fP records have different ttl within \fIzone\fP from \fIserver\fP
+Resource records of the same name/type/class should have the same ttl value
+in zone listings. This is sometimes not the case, due to the independent
+definition of glue records or other information in the parent zone, which
+is not kept in sync with the definition in the delegated zone.
+.TP
+\fIname\fP \fItype\fP record has illegal name
+The name of an A or MX record contains invalid characters.
+Only alphanumeric characters and hyphen '-' are valid in
+components (labels) between dots.
+.TP
+\fIname\fP \fItype\fP host \fIserver\fP has illegal name
+The name of an NS or MX target host contains invalid characters.
+Only alphanumeric characters and hyphen '-' are valid in
+components (labels) between dots.
+.TP
+\fIname\fP \fItype\fP host \fIserver\fP does not exist
+The NS or MX target host \fIserver\fP does not exist at all.
+In case of NS, a lame delegation of \fIname\fP to \fIserver\fP
+is flagged.
+.TP
+\fIname\fP \fItype\fP host \fIserver\fP has no A record
+The NS or MX target host \fIserver\fP has no address.
+In case of NS, a lame delegation of \fIname\fP to \fIserver\fP
+is flagged.
+.TP
+\fIname\fP \fItype\fP host \fIserver\fP is not canonical
+The NS or MX target host \fIserver\fP is not a canonical name.
+This may cause serious operational problems during domain data
+retrieval, or electronic mail delivery.
+.TP
+\fIname\fP address \fIA.B.C.D\fP is not registered
+The reverse lookup of the address of an A record failed in an
+authoritative fashion. It was not present in the corresponding
+in-addr.arpa zone.
+.TP
+\fIname\fP address \fIA.B.C.D\fP maps to \fIrealname\fP
+The reverse lookup of the address of an A record succeeded,
+but it did not map back to the name of the A record.
+There may be A records with different names for the same address.
+In the reverse in-addr.arpa zone there is usually only one PTR to
+the ``official'' host name.
+.TP
+\fIzone\fP SOA record at \fIserver\fP is not authoritative
+When checking the SOA for a zone at one of its supposedly
+authoritative nameservers, the SOA information turns out
+to be not authoritative.  This could be determined by making
+a query without nameserver recursion turned on.
+.TP
+\fIzone\fP SOA primary \fIserver\fP is not advertised via NS
+The primary nameserver is not among the list of nameservers
+retrieved via NS records for the zone.
+This is not an error per se, since only publicly accessible
+nameservers may be advertised, and others may be behind a
+firewall.
+.TP
+\fIzone\fP SOA primary \fIserver\fP has illegal name
+The name of the primary nameserver contains invalid characters.
+.TP
+\fIzone\fP SOA hostmaster \fImailbox\fP has illegal mailbox
+The name of the hostmaster mailbox contains invalid characters.
+A common mistake is to use an RFC822 email address with a ``@@'',
+whereas the at-sign should have been replaced with a dot.
+.TP
+\fIzone\fP SOA serial has high bit set
+Although the serial number is an unsigned 32-bit value, overflow
+into the high bit can inadvertently occur by making inappropriate
+use of the dotted decimal notation in the zone file. This may lead
+to synchronization failures between primary and secondary servers.
+.TP
+\fIzone\fP SOA retry exceeds refresh
+A failing refresh would be retried after it is time for the
+next refresh.
+.TP
+\fIzone\fP SOA refresh+retry exceeds expire
+The retry after a failing refresh would be done after the data
+has already expired.
+.TP
+\fIserver1\fP and \fIserver2\fP have different primary for \fIzone\fP
+If the SOA record is different, the zone data is probably different
+as well. What you get depends on which server you happen to query.
+.TP
+\fIserver1\fP and \fIserver2\fP have different hostmaster for \fIzone\fP
+If the SOA record is different, the zone data is probably different
+as well. What you get depends on which server you happen to query.
+.TP
+\fIserver1\fP and \fIserver2\fP have different serial for \fIzone\fP
+This is usually not an error, but happens during the period after the
+primary server has updated its zone data, but before a secondary
+performed a refresh. Nevertheless there could be an error if a mistake
+has been made in properly adapting the serial number.
+.TP
+\fIserver1\fP and \fIserver2\fP have different refresh for \fIzone\fP
+If the SOA record is different, the zone data is probably different
+as well. What you get depends on which server you happen to query.
+.TP
+\fIserver1\fP and \fIserver2\fP have different retry for \fIzone\fP
+If the SOA record is different, the zone data is probably different
+as well. What you get depends on which server you happen to query.
+.TP
+\fIserver1\fP and \fIserver2\fP have different expire for \fIzone\fP
+If the SOA record is different, the zone data is probably different
+as well. What you get depends on which server you happen to query.
+.TP
+\fIserver1\fP and \fIserver2\fP have different defttl for \fIzone\fP
+If the SOA record is different, the zone data is probably different
+as well. What you get depends on which server you happen to query.
+.SH "EXIT STATUS"
+The program returns a zero exit status if the requested information
+could be retrieved successfully, or in case zone listings or SOA
+checks were performed without any serious error.
+Otherwise it returns a non-zero exit status.
+.SH ENVIRONMENT
+.SS "CUSTOMIZING HOST NAME LOOKUP"
+In general, if the name supplied by the user does not have any dots
+in it, a default domain is appended to the end. This domain is usually
+defined in the \fB/etc/resolv.conf\fP file. If not, it is derived by
+taking the local hostname and taking everything after its first dot.
+.PP
+.fw LOCALDOMAIN
+The user can override this, and specify a different default domain,
+by defining it in the environment variable \fILOCALDOMAIN\fP.
+.PP
+.fw HOSTALIASES
+In addition, the user can supply his own single-word abbreviations
+for host names. They should be in a file consisting of one line per
+abbreviation. Each line contains an abbreviation, whitespace, and
+then the fully qualified host name. The name of this file must be
+specified in the environment variable \fIHOSTALIASES\fP.
+.SH "SPECIAL CONSIDERATIONS"
+The complete set of resource record information for a domain name
+is available from an authoritative nameserver only. Therefore,
+if you query another server with the "-a" option, only a subset
+of the data may be presented, since this option asks for any data
+that the latter server currently knows about, not all data that
+may possibly exist.  Note that the "-v" option shows whether an
+answer is authoritative or not.
+.PP
+When listing a zone with the "-l" option, information will be fetched
+from authoritative nameservers for that zone. This is implemented by
+doing a complete zone transfer and then filtering out the information
+that you have asked for.
+Note that direct contact with such nameservers must be possible for
+this option to work.
+This option should be used with caution. Servers may be configured
+to refuse zone transfers if they are flooded with requests.
+.SH "RELATED DOCUMENTATION"
+rfc883, Domain names - implementation and specification
+.br
+rfc920, Domain requirements
+.br
+rfc952, DOD Internet host table specification
+.br
+rfc974, Mail routing and the domain system
+.br
+rfc1032, Domain administrators guide
+.br
+rfc1033, Domain administrators operations guide
+.br
+rfc1034, Domain names - concepts and facilities
+.br
+rfc1035, Domain names - implementation and specification
+.br
+rfc1101, DNS encoding of network names and other types
+.br
+rfc1123, Requirements for Internet hosts - application
+.br
+rfc1183, New DNS RR definitions
+.br
+rfc1348, DNS NSAP RRs
+.br
+rfc1535, A security problem and proposed correction
+.br
+rfc1536, Common DNS implementation errors
+.br
+rfc1537, Common DNS data file configuration errors
+.br
+rfc1591, Domain Name System structure and delegation
+.br
+rfc1637, DNS NSAP resource records
+.br
+rfc1664, Using DNS to distribute X.400 address mappings
+.br
+rfc1700, Assigned numbers
+.br
+rfc1706, DNS NSAP resource records
+.br
+rfc1712, DNS encoding of geographical location
+.br
+rfc1713, Tools for DNS debugging
+.br
+rfc1794, DNS support for load balancing
+.br
+rfc1876, Expressing location information in the DNS
+.br
+rfc1884, IP v6 addressing architecture
+.br
+rfc1886, DNS extensions to support IP v6
+.br
+rfc1912, Common DNS operational and configuration errors
+.br
+rfc1982, Serial number arithmetic
+.br
+rfc1995, Incremental zone transfer in DNS
+.br
+rfc1996, Prompt notification of zone changes
+.SH AUTHOR
+This program is originally from Rutgers University.
+.br
+Rewritten by Eric Wassenaar, NIKHEF, <e07@@nikhef.nl>
+.SH "SEE ALSO"
+resolv.conf(5), resolver(3)
index: src/usr.bin/host/host.c
===================================================================
RCS file: /cvs/src/usr.bin/host/host.c,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/usr.bin/host/host.c	Sat Mar 22 15:42:19 2003
@@@@ -0,0 +1,8730 @@@@
+/*-	$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+ * from	$OpenBSD: host.c,v 1.4 2002/04/06 23:54:25 fgsch Exp $
+ *
+ * Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
+ * Copyright (c) by Eric Wassenaar, Nikhef-H, <e07@@nikhef.nl>
+ *
+ * Anyone who obtained a copy of this work is hereby permitted to freely use,
+ * distribute, modify, merge, sublicence, give away or sell it as long as the
+ * authors are given due credit and the following notice is retained:
+ *
+ * This work is provided "as is", with no explicit or implicit warranty what-
+ * soever. Use it only at your own risk. In no event may an author or contri-
+ * butor be held liable for any damage, directly or indirectly, that origina-
+ * ted through or is caused by creation or modification of this work.
+ */
+
+/*
+ *		Usage: host [options] name [server]
+ *		Usage: host [options] -x [name ...]
+ *		Usage: host [options] -X server [name ...]
+ *
+ * Regular command line options:
+ * ----------------------------
+ *
+ * -t type	specify query type; default is T_A for normal mode
+ * -a		specify query type T_ANY
+ * -v		print verbose messages (-vv is very verbose)
+ * -d		print debugging output (-dd prints even more)
+ *
+ * Special mode options.
+ * --------------------
+ *
+ * -l		special mode to generate zone listing for a zone
+ * -L level	do recursive zone listing/checking this level deep
+ * -p		use primary nameserver of zone for zone transfers
+ * -P server	give priority to preferred servers for zone transfers
+ * -N zone	do not perform zone transfer for these explicit zones
+ * -S		print zone resource record statistics
+ * -H		special mode to count hosts residing in a zone
+ * -G		same as -H but lists gateway hosts in addition
+ * -E		same as -H but lists extrazone hosts in addition
+ * -D		same as -H but lists duplicate hosts in addition
+ * -C		special mode to check SOA records for a zone
+ * -A		special mode to check reverse mappings of host addresses
+ *
+ * Miscellaneous options.
+ * ---------------------
+ *
+ * -f filename	log resource record output also in given file
+ * -F filename	same as -f, but exchange role of stdout and log file
+ * -I chars	chars are not considered illegal in domain names
+ * -i		generate reverse in-addr.arpa query for dotted quad
+ * -n		generate reverse nsap.int query for dotted nsap address
+ * -q		be quiet about some non-fatal errors
+ * -T		print ttl value during non-verbose output
+ * -Z		print selected RR output in full zone file format
+ *
+ * Seldom used options.
+ * -------------------
+ *
+ * -c class	specify query class; default is C_IN
+ * -e		exclude info from names that do not reside in the zone
+ * -m		specify query type T_MAILB and trace MB records
+ * -o		suppress resource record output to stdout
+ * -r		do not use recursion when querying nameserver
+ * -R		repeatedly add search domains to qualify queryname
+ * -s secs	specify timeout value in seconds; default is 2 * 5
+ * -u		use virtual circuit instead of datagram for queries
+ * -w		wait until nameserver becomes available
+ *
+ * Undocumented options. (Experimental, subject to change)
+ * --------------------
+ *
+ * -g length	only select names that are at least this long
+ * -B		enforce full BIND behavior during DNSRCH
+ * -M		special mode to list mailable delegated zones of zone
+ * -W		special mode to list wildcard records in a zone
+ * -z		special mode to list delegated zones in a zone
+ */
+
+static char Usage[] =
+"\
+Usage:	 host [-v] [-a] [-t querytype] [options] name [server]\n\
+Listing: host [-v] [-a] [-t querytype] [options] -l zone [server]\n\
+Hostcnt: host [-v] [opts] -H [-D] [-E] [-G] zone\n\
+Chk soa: host [-v] [opts] -C zone\n\
+Addrchk: host [-v] [opts] -A host\n\
+Listing opts: [-L level] [-S] [-A] [-p] [-P prefserver] [-N skipzone]\n\
+Common opts:  [-d] [-f|-F filename] [-I chars] [-i|-n] [-q] [-T] [-Z]\n\
+Other opts:   [-c class] [-e] [-m] [-o] [-r] [-R] [-s secs] [-u] [-w]\n\
+Ext. usage:   [-x [name ...]] [-X server [name ...]]\n\
+";
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
+char *version = "961113";
+
+#include <arpa/inet.h>
+#include <arpa/nameser.h>
+#include <ctype.h>
+#include <errno.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <resolv.h>
+#include <setjmp.h>
+#include <signal.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <time.h>
+#include <unistd.h>
+
+#ifndef NO_DATA
+#define NO_DATA	NO_ADDRESS	/* used here only in case authoritative */
+#endif
+#define NO_RREC	(NO_DATA + 1)	/* used for non-authoritative NO_DATA */
+#define NO_HOST	(NO_DATA + 2)	/* used for non-authoritative HOST_NOT_FOUND */
+#define QUERY_REFUSED  (NO_DATA + 3)	/* query was refused by server */
+#define SERVER_FAILURE (NO_DATA + 4)	/* instead of TRY_AGAIN upon SERVFAIL */
+#define HOST_NOT_CANON (NO_DATA + 5)	/* host name is not canonical */
+#define T_NONE	0		/* yet unspecified resource record type */
+#define T_FIRST	T_A		/* first possible type in resource record */
+#define T_LAST	(T_IXFR - 1)	/* last  possible type in resource record */
+#ifndef NOCHANGE
+#define NOCHANGE 0xf		/* compatibility with older BIND versions */
+#endif
+#define NOT_DOTTED_QUAD	((ipaddr_t)-1)
+#define BROADCAST_ADDR	((ipaddr_t)0xffffffff)
+#define LOCALHOST_ADDR	((ipaddr_t)0x7f000001)
+#if PACKETSZ > 8192
+#define MAXPACKET PACKETSZ	/* PACKETSZ should be the max udp size (512) */
+#else
+#define MAXPACKET 8192		/* but tcp packets can be considerably larger */
+#endif
+#ifndef HFIXEDSZ
+#define HFIXEDSZ 12		/* actually sizeof(HEADER) */
+#endif
+#define MAXDLEN (MAXPACKET - HFIXEDSZ)	/* upper bound for dlen */
+#define STDERR	2
+#define STDIN	0
+#define STDOUT	1
+#define assert(condition)
+#define bitset(a,b)	(((a) & (b)) != 0)
+#define fakeaddr(a)	(nulladdr(a) || ((a) == htonl(LOCALHOST_ADDR)))
+#define fakename(a)	(samehead(a,"localhost.") || samehead(a,"loopback."))
+#define hexdigit(n)	(((n) < 10) ? '0' + (n) : 'A' + (n) - 10);
+#define in_string(s,c)	(index(s,c) != NULL)
+#define incopy(a)	*((struct in_addr *)(a))
+#define input			/* read-only input parameter */
+#define is_alnum(c)	(isascii(c) && isalnum(c))
+#define is_quoted(a,b)	(((a) > (b)) && ((a)[-1] == '\\'))
+#define is_space(c)	(isascii(c) && isspace(c))
+#define is_upper(c)	(isascii(c) && isupper(c))
+#define is_xdigit(c)	(isascii(c) && isxdigit(c))
+#define lower(c)	(((c) >= 'A' && (c) <= 'Z') ? (c) + 'a' - 'A' : (c))
+#define lowercase(c)	(is_upper(c) ? tolower(c) : (c))
+#define newlist(a,n,t)	(t *)xalloc((ptr_t *)(a), (siz_t)((n)*sizeof(t)))
+#define newstr(s)	strcpy(newstring(s), s)
+#define newstring(s)	(char *)xalloc((ptr_t *)NULL, (siz_t)(strlen(s)+1))
+#define newstruct(t)	(t *)xalloc((ptr_t *)NULL, (siz_t)(sizeof(t)))
+#define nulladdr(a)	(((a) == 0) || ((a) == BROADCAST_ADDR))
+#define output			/* modified output parameter */
+#define plural(n)	(((n) == 1) ? "" : "s")
+#define plurale(n)	(((n) == 1) ? "" : "es")
+#define querysize(n)	(((n) > sizeof(querybuf)) ? sizeof(querybuf) : (n))
+#define samehead(a,b)	(strncasecmp(a,b,sizeof(b)-1) == 0)
+#define samepart(a,b)	(strncasecmp(a,b,strlen(b)) == 0)
+#define sameword(a,b)	(strcasecmp(a,b) == 0)
+#define setalarm(n)	(void) alarm((unsigned int)(n))
+#define strlength(s)	(int)strlen(s)
+#define xfree(a)	(void) free((ptr_t *)(a))
+#define ARPA_ROOT	"in-addr.arpa"
+#ifndef IPNG_ROOT
+#define IPNG_ROOT	"ip6.int"
+#endif
+#ifndef NSAP_ROOT
+#define NSAP_ROOT	"nsap.int"
+#endif
+#define MAXNSAP		20	/* maximum size of encoded NSAP address */
+#define T_LOC_VERSION	0	/* must be zero */
+#define	MAXMD5BITS	2552
+#define	MAXMD5SIZE	(2*((MAXMD5BITS+7)/8)+3)
+#define	MAXB64SIZE	(4*((MAXMD5SIZE+2)/3))
+#ifndef NAMESERVER_PORT
+#define NAMESERVER_PORT	53
+#endif
+#define MAXCHAIN	10	/* maximum count of recursive chain lookups */
+#define MAXALIAS	35	/* maximum aliases count from gethnamaddr.c */
+#define MAXADDRS	35	/* maximum address count from gethnamaddr.c */
+#define MAXNSNAME	16	/* maximum count of nameservers per zone */
+#define MAXIPADDR	10	/* maximum count of addresses per nameserver */
+#define DEF_RETRIES	2	/* number of datagram retries per nameserver */
+#define DEF_RETRANS	5	/* timeout (seconds) between datagram retries */
+#define CONNTIMEOUT	5	/* connect timeout (value _res.retrans used) */
+#define READTIMEOUT	60	/* read timeout (seconds) during stream I/O */
+#define DBPREFIX	";; "
+#undef  EX_OK			/* defined in <unistd.h> on SVR4 */
+#define EX_SUCCESS	0	/* successful termination */
+#define EX_USAGE	64	/* command line usage error */
+#define EX_DATAERR	65	/* data format error */
+#define EX_NOINPUT	66	/* cannot open input */
+#define EX_NOUSER	67	/* addressee unknown */
+#define EX_NOHOST	68	/* host name unknown */
+#define EX_UNAVAILABLE	69	/* service unavailable */
+#define EX_SOFTWARE	70	/* internal software error */
+#define EX_OSERR	71	/* system error (e.g., can't fork) */
+#define EX_OSFILE	72	/* critical OS file missing */
+#define EX_CANTCREAT	73	/* can't create (user) output file */
+#define EX_IOERR	74	/* input/output error */
+#define EX_TEMPFAIL	75	/* temp failure; user is invited to retry */
+#define EX_PROTOCOL	76	/* remote error in protocol */
+#define EX_NOPERM	77	/* permission denied */
+#define EX_CONFIG	78	/* local configuration error */
+#if defined(SYSV) || defined(SVR4)
+#define SYSV_MALLOC
+#define SYSV_MEMSET
+#define SYSV_STRCHR
+#define SYSV_SETVBUF
+#endif
+#define BIND_49
+#define BIND_493
+#ifndef INT16SZ
+#define	INT16SZ		2	/* for systems without 16-bit ints */
+#endif
+#ifndef INT32SZ
+#define	INT32SZ		4	/* for systems without 32-bit ints */
+#endif
+#ifndef INADDRSZ
+#define	INADDRSZ	4	/* for sizeof(struct inaddr) != 4 */
+#endif
+#define	IPNGSIZE	16	/* 128 bit ip v6 address size */
+#define linebufmode(a)	(void) setlinebuf(a);
+#define nslist(i)	_res.nsaddr_list[i]
+#ifdef fp_nquery
+#define pr_query(a,n,f)	fp_nquery(a,n,f)
+#else
+#define pr_query(a,n,f)	fp_query(a,f)
+#endif
+#define PROTO(TYPES)	()
+#define MAXSTRING 255		/* maximum size of single encoded string */
+#define MAXSTRLEN MAXDLEN	/* maximum size of multiple substrings */
+#define t_rr		data.data_rr
+#define t_a		data.data_a
+#define t_ns		data.data_ns
+#define t_md		data.data_md
+#define t_mf		data.data_mf
+#define t_cname		data.data_cname
+#define t_soa		data.data_soa
+#define t_mb		data.data_mb
+#define t_mg		data.data_mg
+#define t_mr		data.data_mr
+#define t_null		data.data_null
+#define t_wks		data.data_wks
+#define t_ptr		data.data_ptr
+#define t_hinfo		data.data_hinfo
+#define t_minfo		data.data_minfo
+#define t_mx		data.data_mx
+#define t_txt		data.data_txt
+#define t_rp		data.data_rp
+#define t_afsdb		data.data_afsdb
+#define t_x25		data.data_x25
+#define t_isdn		data.data_isdn
+#define t_rt		data.data_rt
+#define t_nsap		data.data_nsap
+#define t_nsapptr	data.data_nsapptr
+#define t_sig		data.data_sig
+#define t_key		data.data_key
+#define t_px		data.data_px
+#define t_gpos		data.data_gpos
+#define t_aaaa		data.data_aaaa
+#define t_loc		data.data_loc
+#define t_nxt		data.data_nxt
+#define t_srv		data.data_srv
+#define t_naptr		data.data_naptr
+#define t_uinfo		data.data_uinfo
+#define t_uid		data.data_uid
+#define t_gid		data.data_gid
+#define t_unspec	data.data_unspec
+#ifndef C_CSNET
+#define C_CSNET		2
+#endif
+#ifndef C_CHAOS
+#define C_CHAOS		3
+#endif
+#ifndef C_HS
+#define C_HS		4
+#endif
+#ifndef T_MD
+#define T_MD		3
+#endif
+#ifndef T_MF
+#define T_MF		4
+#endif
+#ifndef T_MB
+#define T_MB		7
+#endif
+#ifndef T_MG
+#define T_MG		8
+#endif
+#ifndef T_MR
+#define T_MR		9
+#endif
+#ifndef T_NULL
+#define T_NULL		10
+#endif
+#ifndef T_MINFO
+#define T_MINFO		14
+#endif
+#ifndef T_TXT
+#define T_TXT		16
+#endif
+#ifndef T_RP
+#define T_RP		17
+#endif
+#ifndef T_AFSDB
+#define T_AFSDB		18
+#endif
+#ifndef T_X25
+#define T_X25		19
+#endif
+#ifndef T_ISDN
+#define T_ISDN		20
+#endif
+#ifndef T_RT
+#define T_RT		21
+#endif
+#ifndef T_NSAP
+#define T_NSAP		22
+#endif
+#ifndef T_NSAPPTR
+#define T_NSAPPTR	23
+#endif
+#ifndef T_SIG
+#define T_SIG		24
+#endif
+#ifndef T_KEY
+#define T_KEY		25
+#endif
+#ifndef T_PX
+#define T_PX		26
+#endif
+#ifndef T_GPOS
+#define T_GPOS		27
+#endif
+#ifndef T_AAAA
+#define T_AAAA		28
+#endif
+#ifndef T_LOC
+#define T_LOC		29
+#endif
+#ifndef T_NXT
+#define T_NXT		30
+#endif
+#ifndef T_EID
+#define T_EID		31
+#endif
+#ifndef T_NIMLOC
+#define T_NIMLOC	32
+#endif
+#ifndef T_SRV
+#define T_SRV		33
+#endif
+#ifndef T_ATMA
+#define T_ATMA		34
+#endif
+#ifndef T_NAPTR
+#define T_NAPTR		35
+#endif
+#ifndef T_UINFO
+#define T_UINFO		100
+#endif
+#ifndef T_UID
+#define T_UID		101
+#endif
+#ifndef T_GID
+#define T_GID		102
+#endif
+#ifndef T_UNSPEC
+#define T_UNSPEC	103
+#endif
+#ifndef T_IXFR
+#define T_IXFR		251
+#endif
+#ifndef T_AXFR
+#define T_AXFR		252
+#endif
+#ifndef T_MAILB
+#define T_MAILB		253
+#endif
+#ifndef T_MAILA
+#define T_MAILA		254
+#endif
+#define dbprefix ""
+
+typedef struct __res_state	res_state_t;
+
+typedef u_char		rrec_t;
+
+typedef u_char	qbuf_t;
+
+typedef char	nbuf_t;
+
+typedef u_int	ipaddr_t;
+
+typedef struct rr_data {
+	u_char databuf[MAXDLEN];	/* generic data buffer */
+} rr_data_t;
+
+typedef struct a_data {
+	ipaddr_t address;		/* internet address of host */
+} a_data_t;
+
+typedef struct ns_data {
+	char nameserver[MAXDNAME+1];	/* name of domain nameserver */
+} ns_data_t;
+
+typedef struct md_data {
+	char destination[MAXDNAME+1];	/* name of mail destination */
+} md_data_t;
+
+typedef struct mf_data {
+	char forwarder[MAXDNAME+1];	/* name of mail forwarder */
+} mf_data_t;
+
+typedef struct cname_data {
+	char canonical[MAXDNAME+1];	/* canonical domain name */
+} cname_data_t;
+
+typedef struct soa_data {
+	char primary[MAXDNAME+1];	/* name of primary nameserver */
+	char hostmaster[MAXDNAME+1];	/* name of hostmaster mailbox */
+	int serial;			/* serial (version) number */
+	int refresh;			/* refresh time in seconds */
+	int retry;			/* refresh retry time in seconds */
+	int expire;			/* expiration time in seconds */
+	int defttl;			/* default time_to_live */
+} soa_data_t;
+
+typedef struct mb_data {
+	char mailhost[MAXDNAME+1];	/* name of mailbox host */
+} mb_data_t;
+
+typedef struct mg_data {
+	char memberbox[MAXDNAME+1];	/* mailbox of mail group member */
+} mg_data_t;
+
+typedef struct mr_data {
+	char aliasbox[MAXDNAME+1];	/* mailbox of mail alias */
+} mr_data_t;
+
+typedef struct null_data {
+	u_char nullbuf[MAXDLEN];	/* generic data buffer */
+} null_data_t;
+
+typedef struct wks_data {
+	ipaddr_t servaddress;		/* internet address of host */
+	int protocol;			/* protocol number */
+	u_char services[32];		/* ports 0-255 */
+} wks_data_t;
+
+typedef struct ptr_data {
+	char domain[MAXDNAME+1];	/* domain name of pointer */
+} ptr_data_t;
+
+typedef struct hinfo_data {
+	char cputype[MAXSTRING+1];	/* machine description */
+	char ostype[MAXSTRING+1];	/* operating system type */
+} hinfo_data_t;
+
+typedef struct minfo_data {
+	char ownerbox[MAXDNAME+1];	/* name of owner mailbox */
+	char errorbox[MAXDNAME+1];	/* name of error mailbox */
+} minfo_data_t;
+
+typedef struct mx_data {
+	int preference;			/* preference value */
+	char mxhost[MAXDNAME+1];	/* name of mx host */
+} mx_data_t;
+
+typedef struct txt_data {
+	char text[MAXSTRLEN+1];		/* multiple substrings */
+} txt_data_t;
+
+typedef struct rp_data {
+	char mailbox[MAXDNAME+1];	/* name of person mailbox */
+	char txtinfo[MAXDNAME+1];	/* name of description txt record */
+} rp_data_t;
+
+typedef struct afsdb_data {
+	int afstype;			/* type of afs server */
+	char afshost[MAXDNAME+1];	/* name of afs server */
+} afsdb_data_t;
+
+typedef struct x25_data {
+	char psdnaddress[MAXSTRING+1];	/* x25 psdn address */
+} x25_data_t;
+
+typedef struct isdn_data {
+	char isdnaddress[MAXSTRING+1];	/* isdn address */
+	char isdnsubaddr[MAXSTRING+1];	/* isdn subaddress */
+} isdn_data_t;
+
+typedef struct rt_data {
+	int routepref;			/* preference value */
+	char routehost[MAXDNAME+1];	/* name of route-through host */
+} rt_data_t;
+
+typedef struct nsap_data {
+	u_char nsapaddr[MAXNSAP];	/* binary nsap address */
+} nsap_data_t;
+
+typedef struct nsapptr_data {
+	char nsapdomain[MAXDNAME+1];	/* domain name of nsap pointer */
+} nsapptr_data_t;
+
+typedef struct sig_data {
+	int sigtype;			/* resource record type covered */
+	int algorithm;			/* signature encoding algorithm */
+	int nlabels;			/* number of labels in SIG name */
+	int sigttl;			/* original ttl of SIG record */
+	time_t expiretime;		/* signature expiration time */
+	time_t sigtime;			/* time signature was signed */
+	int footprint;			/* key identification */
+	char signer[MAXDNAME+1];	/* signer's domain name */
+	u_char sig[MAXMD5SIZE];		/* encoded signature */
+} sig_data_t;
+
+typedef struct key_data {
+	int keyflags;			/* key description flags */
+	int protocol;			/* protocol suite */
+	int algorithm;			/* key encoding algorithm */
+	u_char key[MAXMD5SIZE];		/* encoded key */
+} key_data_t;
+
+typedef struct px_data {
+	int mappref;			/* preference value */
+	char map822[MAXDNAME+1];	/* rfc822 domain name */
+	char mapx400[MAXDNAME+1];	/* x400 domain name */
+} px_data_t;
+
+typedef struct gpos_data {
+	char longpos[MAXSTRING+1];	/* geographical longitude */
+	char latpos[MAXSTRING+1];	/* geographical latitude */
+	char altpos[MAXSTRING+1];	/* geographical altitude */
+} gpos_data_t;
+
+typedef struct aaaa_data {
+	u_char ipngaddr[IPNGSIZE];	/* binary ip v6 address */
+} aaaa_data_t;
+
+typedef struct loc_data {
+	int locversion;			/* version number */
+	int objectsize;			/* size of object */
+	int hprecision;			/* horizontal precision */
+	int vprecision;			/* vertical precision */
+	int longitude;			/* geographical longitude */
+	int latitude;			/* geographical latitude */
+	int altitude;			/* geographical altitude */
+} loc_data_t;
+
+typedef struct nxt_data {
+	char nxtdomain[MAXDNAME+1];	/* name of next domain in order */
+	u_char typemap[32];		/* types 0-255 */
+} nxt_data_t;
+
+typedef struct srv_data {
+	int srvpref;			/* preference value */
+	int srvweight;			/* load balancing weight */
+	int srvport;			/* port of service */
+	char srvhost[MAXDNAME+1];	/* name of service host */
+} srv_data_t;
+
+typedef struct naptr_data {
+	int naorder;
+	int napref;			/* preference value */
+	char naflags[MAXSTRING+1];	/* flags */
+	char naservice[MAXSTRING+1];
+	char naregexp[MAXSTRING+1];
+	char nahost[MAXDNAME+1];	/* name of naming authority host */
+} naptr_data_t;
+
+typedef struct uinfo_data {
+	char userinfo[MAXSTRLEN+1];	/* user description */
+} uinfo_data_t;
+
+typedef struct uid_data {
+	int userid;			/* user uid */
+} uid_data_t;
+
+typedef struct gid_data {
+	int groupid;			/* user gid */
+} gid_data_t;
+
+typedef struct unspec_data {
+	u_char unspecbuf[MAXDLEN];	/* generic data buffer */
+} unspec_data_t;
+
+typedef struct rrecord {
+	char	name[MAXDNAME+1];	/* resource record name */
+	int	type;			/* resource record type */
+	int	class;			/* resource record class */
+	int	ttl;			/* time_to_live value */
+	union {
+		rr_data_t	data_rr;
+		a_data_t	data_a;
+		ns_data_t	data_ns;
+		md_data_t	data_md;
+		mf_data_t	data_mf;
+		cname_data_t	data_cname;
+		soa_data_t	data_soa;
+		mb_data_t	data_mb;
+		mg_data_t	data_mg;
+		mr_data_t	data_mr;
+		null_data_t	data_null;
+		wks_data_t	data_wks;
+		ptr_data_t	data_ptr;
+		hinfo_data_t	data_hinfo;
+		minfo_data_t	data_minfo;
+		mx_data_t	data_mx;
+		txt_data_t	data_txt;
+		rp_data_t	data_rp;
+		afsdb_data_t	data_afsdb;
+		x25_data_t	data_x25;
+		isdn_data_t	data_isdn;
+		rt_data_t	data_rt;
+		nsap_data_t	data_nsap;
+		nsapptr_data_t	data_nsapptr;
+		sig_data_t	data_sig;
+		key_data_t	data_key;
+		px_data_t	data_px;
+		gpos_data_t	data_gpos;
+		aaaa_data_t	data_aaaa;
+		loc_data_t	data_loc;
+		nxt_data_t	data_nxt;
+		srv_data_t	data_srv;
+		naptr_data_t	data_naptr;
+		uinfo_data_t	data_uinfo;
+		uid_data_t	data_uid;
+		gid_data_t	data_gid;
+		unspec_data_t	data_unspec;
+	} data;
+} rrecord_t;
+
+typedef union {
+        HEADER header;
+        u_char packet[MAXPACKET];
+} querybuf;
+
+#if defined(_BSD_SIGNALS)
+typedef int	sigtype_t;
+#else
+typedef void	sigtype_t;
+#endif
+
+#if defined(SYSV_MALLOC)
+typedef void	ptr_t;		/* generic pointer type */
+typedef u_int	siz_t;		/* general size type */
+typedef void	free_t;
+#else
+typedef char	ptr_t;		/* generic pointer type */
+typedef u_int	siz_t;		/* general size type */
+typedef int	free_t;
+#endif
+
+FILE *logfile = NULL;		/* default is stdout only */
+bool addrmode = false;		/* check reverse mappings of addresses */
+bool bindcompat = false;	/* enforce full BIND DNSRCH compatibility */
+bool checkmode = false;		/* check SOA records at each nameserver */
+bool classprint = false;	/* print class value in non-verbose mode */
+bool dotprint = false;		/* print trailing dot in non-listing mode */
+bool duplmode = false;		/* list duplicate hosts within zone */
+bool exclusive = false;		/* exclude records that are not in zone */
+bool extrmode = false;		/* list extrazone hosts within zone */
+bool gatemode = false;		/* list gateway hosts within zone */
+bool hostmode = false;		/* count real hosts residing within zone */
+bool listmode = false;		/* generate zone listing of a zone */
+bool listzones = false;		/* list only delegated zones in a zone */
+bool logexchange = false;	/* exchange role of log file and stdout */
+bool mailmode = false;		/* trace MG and MR into MB records */
+bool mxdomains = false;		/* list MX records for each delegated zone */
+bool primary = false;		/* use primary server for zone transfers */
+bool quiet = false;		/* suppress non-fatal warning messages */
+bool recurskip = false;		/* skip certain checks during recursion */
+bool reverse = false;		/* generate reverse in-addr.arpa queries */
+bool revnsap = false;		/* generate reverse nsap.int queries */
+bool statistics = false;	/* print resource record statistics */
+bool suppress = false;		/* suppress resource record output */
+bool ttlprint = false;		/* print ttl value in non-verbose mode */
+bool waitmode = false;		/* wait until server becomes available */
+bool wildcards = false;		/* list only wildcard records in a zone */
+char **optargv = NULL;		/* argument list including default options */
+char *adrname = NULL;		/* LHS domain name of A record */
+char *cname = NULL;		/* RHS name to which CNAME is aliased */
+char *illegal = NULL;		/* give warning about illegal domain names */
+char *listhost = NULL;		/* actual host queried during zone listing */
+char *mname = NULL;		/* RHS name to which MR or MG is aliased */
+char *prefserver = NULL;	/* preferred server(s) for zone listing */
+char *queryname = NULL;		/* the name about which to query */
+char *realname = NULL;		/* the actual name that was queried */
+char *server = NULL;		/* name of explicit server to query */
+char *skipzone = NULL;		/* zone(s) for which to skip zone transfer */
+char *soaname = NULL;		/* LHS domain name of SOA record */
+char *subname = NULL;		/* LHS domain name of NS record */
+char adrnamebuf[MAXDNAME+1];
+char cnamebuf[MAXDNAME+1];
+char mnamebuf[MAXDNAME+1];
+char realnamebuf[2*MAXDNAME+2];
+char serverbuf[MAXDNAME+1];
+char soanamebuf[MAXDNAME+1];
+char subnamebuf[MAXDNAME+1];
+extern int errno;
+extern int h_errno;		/* defined in the resolver library */
+extern res_state_t _res;	/* defined in res_init.c */
+int debug = 0;			/* print resolver debugging output */
+int errorcount = 0;		/* global error count */
+int namelen = 0;		/* select records exceeding this length */
+int optargc = 0;		/* number of arguments in new argument list */
+int print_level = 0;		/* level below which to skip verbose output */
+int queryclass = C_IN;		/* the class of the query */
+int querytype = T_NONE;		/* the type of the query */
+int record_stats[T_ANY+1];	/* count of resource records per type */
+int recursion_level = 0;	/* current recursion level */
+int recursive = 0;		/* recursive listmode maximum level */
+int skip_level = 0;		/* level beyond which to skip checks */
+int verbose = 0;		/* verbose mode for extra output */
+ipaddr_t address;		/* internet address of A record */
+ipaddr_t queryaddr;		/* set if name to query is dotted quad */
+static int timeout;		/* connection read timeout */
+static struct sockaddr_in from;	/* address of inbound packet */
+static struct sockaddr *from_sa = (struct sockaddr *)&from;
+
+bool check_addr		PROTO((char *));
+bool check_dupl		PROTO((ipaddr_t));
+bool check_name		PROTO((ipaddr_t));
+bool check_ttl		PROTO((char *, int, int, int));
+bool check_zone		PROTO((char *));
+bool do_transfer	PROTO((char *));
+bool execute		PROTO((char *, ipaddr_t));
+bool find_servers	PROTO((char *));
+bool get_domaininfo	PROTO((char *, char *));
+bool get_hostinfo	PROTO((char *, bool));
+bool get_mxrec		PROTO((char *));
+bool get_nsinfo		PROTO((querybuf *, int, char *));
+bool get_recursive	PROTO((char **));
+bool get_servers	PROTO((char *));
+bool get_soainfo	PROTO((querybuf *, int, char *));
+bool get_zone		PROTO((char *, struct in_addr, char *));
+bool gluerecord		PROTO((char *, char *, char **, int));
+bool host_query		PROTO((char *, ipaddr_t));
+bool indomain		PROTO((char *, char *, bool));
+bool list_zone		PROTO((char *));
+bool print_info		PROTO((querybuf *, int, char *, int, int, bool));
+bool samedomain		PROTO((char *, char *, bool));
+bool skip_transfer	PROTO((char *));
+bool transfer_zone	PROTO((char *, struct in_addr, char *));
+bool valid_name		PROTO((char *, bool, bool, bool));
+bool want_class		PROTO((int, int));
+bool want_type		PROTO((int, int));
+char *base_ntoa		PROTO((u_char *, int));
+char *decode_error	PROTO((int));
+char *get_primary	PROTO((char *));
+char *in_addr_arpa	PROTO((char *));
+char *inet_ntoa		PROTO((struct in_addr));
+char *ipng_ntoa		PROTO((u_char *));
+char *itoa		PROTO((int));
+char *mapreverse	PROTO((char *, struct in_addr));
+char *myhostname	PROTO((void));
+char *nsap_int		PROTO((char *));
+char *nsap_ntoa		PROTO((u_char *, int));
+char *pr_class		PROTO((int));
+char *pr_date		PROTO((int));
+char *pr_domain		PROTO((char *, bool));
+char *pr_dotname	PROTO((char *));
+char *pr_nsap		PROTO((char *));
+char *pr_precision	PROTO((int));
+char *pr_spherical	PROTO((int, char *, char *));
+char *pr_time		PROTO((int, bool));
+char *pr_type		PROTO((int));
+char *pr_vertical	PROTO((int, char *, char *));
+char *stoa		PROTO((u_char *, int, bool));
+char *utoa		PROTO((int));
+char *xtoa		PROTO((int));
+int _res_connect	PROTO((int, struct sockaddr_in *, int));
+int _res_read		PROTO((int, struct sockaddr_in *, char *, char *, int));
+int _res_write		PROTO((int, struct sockaddr_in *, char *, char *, int));
+int canonical		PROTO((char *));
+int check_canon		PROTO((char *));
+int check_size		PROTO((char *, int, u_char *, u_char *, u_char *, int));
+int compare_name	PROTO((const ptr_t *, const ptr_t *));
+int execute_name	PROTO((char *));
+int expand_name		PROTO((char *, int, u_char *, u_char *, u_char *, char *));
+int get_info		PROTO((querybuf *, char *, int, int));
+int host_index		PROTO((char *, bool));
+int main		PROTO((int, char **));
+int matchlabels		PROTO((char *, char *));
+int parse_class		PROTO((char *));
+int parse_type		PROTO((char *));
+int process_argv	PROTO((int, char **));
+int process_file	PROTO((FILE *));
+int process_name	PROTO((char *));
+int zone_index		PROTO((char *, bool));
+ptr_t *xalloc		PROTO((ptr_t *, siz_t));
+static int recv_sock	PROTO((int, char *, int));
+static sigtype_t timer	PROTO((int));
+struct hostent *geth_byaddr	PROTO((const char *, int, int));
+struct hostent *geth_byname	PROTO((const char *));
+u_char *print_rrec	PROTO((char *, int, int, u_char *, u_char *, u_char *, bool));
+u_char *skip_qrec	PROTO((char *, int, int, u_char *, u_char *, u_char *));
+unsigned int alarm	PROTO((unsigned int));
+void _res_perror	PROTO((struct sockaddr_in *, char *, char *));
+void check_soa		PROTO((querybuf *, char *));
+void clear_hosttab	PROTO((void));
+void clear_statistics	PROTO((void));
+void clear_ttltab	PROTO((void));
+void clear_zonetab	PROTO((void));
+void do_check		PROTO((char *));
+void errmsg		PROTO((char *, ...));
+void fatal		PROTO((char *, ...));
+void ns_error		PROTO((char *, int, int, char *));
+void pr_error		PROTO((char *, ...));
+void pr_warning		PROTO((char *, ...));
+void print_data		PROTO((char *, ...));
+void print_host		PROTO((char *, struct hostent *));
+void print_statistics	PROTO((char *, int, int));
+void print_status	PROTO((querybuf *, int));
+void set_defaults	PROTO((char *, int, char **));
+void set_logfile	PROTO((char *));
+void set_server		PROTO((char *));
+void show_res		PROTO((void));
+void show_types		PROTO((char *, int, int));
+void sort_servers	PROTO((void));
+void update_zone	PROTO((char *));
+
+/*
+** MAIN -- Start of program host
+** -----------------------------
+**
+**	Exits:
+**		EX_SUCCESS	Operation successfully completed
+**		EX_UNAVAILABLE	Could not obtain requested information
+**		EX_CANTCREAT	Could not create specified log file
+**		EX_NOINPUT	No input arguments were found
+**		EX_NOHOST	Could not lookup explicit server
+**		EX_OSERR	Could not obtain resources
+**		EX_USAGE	Improper parameter/option specified
+**		EX_SOFTWARE	Assertion botch in DEBUG mode
+*/
+
+int
+main(argc, argv)
+input int argc;
+input char *argv[];
+{
+	register char *option;
+	res_state_t new_res;		/* new resolver database */
+	int result;			/* result status of action taken */
+	char *program;			/* name that host was called with */
+	char *servername = NULL;	/* name of explicit server */
+	char *logfilename = NULL;	/* name of log file */
+	bool extended = false;		/* accept extended argument syntax */
+
+	assert(sizeof(int) >= 4);	/* probably paranoid */
+
+/*
+ * Synchronize stdout and stderr in case output is redirected.
+ */
+	linebufmode(stdout);
+
+/*
+ * Initialize resolver, set new defaults. See show_res() for details.
+ * The old defaults are (RES_RECURSE | RES_DEFNAMES | RES_DNSRCH)
+ */
+	(void) res_init();
+
+	_res.options |=  RES_DEFNAMES;	/* qualify single names */
+	_res.options &= ~RES_DNSRCH;	/* dotted names are qualified */
+
+	_res.options |=  RES_RECURSE;	/* request nameserver recursion */
+	_res.options &= ~RES_DEBUG;	/* turn off debug printout */
+	_res.options &= ~RES_USEVC;	/* do not use virtual circuit */
+
+	_res.retry = DEF_RETRIES;	/* number of datagram retries */
+	_res.retrans = DEF_RETRANS;	/* timeout in secs between retries */
+
+	/* initialize packet id */
+	_res.id = res_randomid();
+
+	/* save new defaults */
+	new_res = _res;
+
+/*
+ * Check whether host was called with a different name.
+ * Interpolate default options and parameters.
+ */
+	if (argc < 1 || argv[0] == NULL)
+		fatal(Usage);
+
+	option = getenv("HOST_DEFAULTS");
+	if (option != NULL)
+	{
+		set_defaults(option, argc, argv);
+		argc = optargc; argv = optargv;
+	}
+
+	program = rindex(argv[0], '/');
+	if (program++ == NULL)
+		program = argv[0];
+
+	/* check for resource record names */
+	querytype = parse_type(program);
+	if (querytype < 0)
+		querytype = T_NONE;
+
+	/* check for zone listing abbreviation */
+	if (sameword(program, "zone"))
+		listmode = true;
+
+/*
+ * Scan command line options and flags.
+ */
+	while (argc > 1 && argv[1] != NULL && argv[1][0] == '-')
+	{
+	    for (option = &argv[1][1]; *option != '\0'; option++)
+	    {
+		switch (*option)
+		{
+		    case 'w' :
+			waitmode = true;
+			new_res.retry = DEF_RETRIES;
+			new_res.retrans = DEF_RETRANS;
+			break;
+
+		    case 's' :
+			if (argv[2] == NULL || argv[2][0] == '-')
+				fatal("Missing timeout value");
+			new_res.retry = DEF_RETRIES;
+			new_res.retrans = atoi(argv[2]);
+			if (new_res.retrans <= 0)
+				fatal("Invalid timeout value %s", argv[2]);
+			argv++; argc--;
+			break;
+
+		    case 'r' :
+			new_res.options &= ~RES_RECURSE;
+			break;
+
+		    case 'B' :
+			bindcompat = true;
+			/*FALLTHROUGH*/
+
+		    case 'R' :
+			new_res.options |= RES_DNSRCH;
+			break;
+
+		    case 'u' :
+			new_res.options |= RES_USEVC;
+			break;
+
+		    case 'd' :
+			new_res.options |= RES_DEBUG;
+			debug++;		/* increment debugging level */
+			break;
+
+		    case 'v' :
+			verbose++;		/* increment verbosity level */
+			break;
+
+		    case 'q' :
+			quiet = true;
+			break;
+
+		    case 'i' :
+			reverse = true;
+			break;
+
+		    case 'n' :
+			revnsap = true;
+			break;
+
+		    case 'p' :
+			primary = true;
+			break;
+
+		    case 'o' :
+			suppress = true;
+			break;
+
+		    case 'e' :
+			exclusive = true;
+			break;
+
+		    case 'S' :
+			statistics = true;
+			break;
+
+		    case 'T' :
+			ttlprint = true;
+			break;
+
+		    case 'Z' :
+			dotprint = true;
+			ttlprint = true;
+			classprint = true;
+			break;
+
+		    case 'A' :
+			addrmode = true;
+			break;
+
+		    case 'D' :
+		    case 'E' :
+		    case 'G' :
+		    case 'H' :
+			if (*option == 'D')
+				duplmode = true;
+			if (*option == 'E')
+				extrmode = true;
+			if (*option == 'G')
+				gatemode = true;
+			hostmode = true;
+			listmode = true;
+			if (querytype == T_NONE)
+				querytype = -1;	/* suppress zone data output */
+			break;
+
+		    case 'C' :
+			checkmode = true;
+			listmode = true;
+			if (querytype == T_NONE)
+				querytype = -1;	/* suppress zone data output */
+			break;
+
+		    case 'z' :
+			listzones = true;
+			listmode = true;
+			if (querytype == T_NONE)
+				querytype = -1;	/* suppress zone data output */
+			break;
+
+		    case 'M' :
+			mxdomains = true;
+			listmode = true;
+			if (querytype == T_NONE)
+				querytype = -1;	/* suppress zone data output */
+			break;
+
+		    case 'W' :
+			wildcards = true;
+			listmode = true;
+			if (querytype == T_NONE)
+				querytype = T_MX;
+			break;
+
+		    case 'L' :
+			if (argv[2] == NULL || argv[2][0] == '-')
+				fatal("Missing recursion level");
+			recursive = atoi(argv[2]);
+			if (recursive <= 0)
+				fatal("Invalid recursion level %s", argv[2]);
+			argv++; argc--;
+			/*FALLTHROUGH*/
+
+		    case 'l' :
+			listmode = true;
+			break;
+
+		    case 'c' :
+			if (argv[2] == NULL || argv[2][0] == '-')
+				fatal("Missing query class");
+			queryclass = parse_class(argv[2]);
+			if (queryclass < 0)
+				fatal("Invalid query class %s", argv[2]);
+			argv++; argc--;
+			break;
+
+		    case 't' :
+			if (argv[2] == NULL || argv[2][0] == '-')
+				fatal("Missing query type");
+			querytype = parse_type(argv[2]);
+			if (querytype < 0)
+				fatal("Invalid query type %s", argv[2]);
+			argv++; argc--;
+			break;
+
+		    case 'a' :
+			querytype = T_ANY;	/* filter anything available */
+			break;
+
+		    case 'm' :
+			mailmode = true;
+			querytype = T_MAILB;	/* filter MINFO/MG/MR/MB data */
+			break;
+
+		    case 'I' :
+			if (argv[2] == NULL || argv[2][0] == '-')
+				fatal("Missing allowed chars");
+			illegal = argv[2];
+			argv++; argc--;
+			break;
+
+		    case 'P' :
+			if (argv[2] == NULL || argv[2][0] == '-')
+				fatal("Missing preferred server");
+			prefserver = argv[2];
+			argv++; argc--;
+			break;
+
+		    case 'N' :
+			if (argv[2] == NULL || argv[2][0] == '-')
+				fatal("Missing zone to be skipped");
+			skipzone = argv[2];
+			argv++; argc--;
+			break;
+
+		    case 'F' :
+			logexchange = true;
+			/*FALLTHROUGH*/
+
+		    case 'f' :
+			if (argv[2] == NULL || argv[2][0] == '-')
+				fatal("Missing log file name");
+			logfilename = argv[2];
+			argv++; argc--;
+			break;
+
+		    case 'X' :
+			if (argv[2] == NULL || argv[2][0] == '-')
+				fatal("Missing server name");
+			servername = argv[2];
+			argv++; argc--;
+			/*FALLTHROUGH*/
+
+		    case 'x' :
+			extended = true;
+			break;
+		    case 'g' :
+			if (argv[2] == NULL || argv[2][0] == '-')
+				fatal("Missing minimum length");
+			namelen = atoi(argv[2]);
+			if (namelen <= 0)
+				fatal("Invalid minimum length %s", argv[2]);
+			argv++; argc--;
+			break;
+		    case 'V' :
+			printf("Version %s\n", version);
+			exit(EX_SUCCESS);
+
+		    default:
+			fatal(Usage);
+		}
+	    }
+
+	    argv++; argc--;
+	}
+
+/*
+ * Check the remaining arguments.
+ */
+	/* old syntax must have at least one argument */
+	if (!extended && (argc < 2 || argv[1] == NULL || argc > 3))
+		fatal(Usage);
+
+	/* old syntax has explicit server as second argument */
+	if (!extended && (argc > 2 && argv[2] != NULL))
+		servername = argv[2];
+
+/*
+ * Open log file if requested.
+ */
+	if (logfilename != NULL)
+		set_logfile(logfilename);
+
+/*
+ * Set default preferred server for zone listings, if not specified.
+ */
+	if (listmode && (prefserver == NULL))
+		prefserver = myhostname();
+
+/*
+ * Check for possible alternative server. Use new resolver defaults.
+ */
+	if (servername != NULL)
+		set_server(servername);
+
+/*
+ * Do final resolver initialization.
+ * Show resolver parameters and special environment options.
+ */
+	/* set new resolver values changed by command options */
+	_res.retry = new_res.retry;
+	_res.retrans = new_res.retrans;
+	_res.options = new_res.options;
+
+	/* show the new resolver database */
+	if (verbose > 1 || debug > 1)
+		show_res();
+
+	/* show customized default domain */
+	option = getenv("LOCALDOMAIN");
+	if (option != NULL && verbose > 1)
+		printf("Explicit local domain %s\n\n", option);
+
+/*
+ * Process command line argument(s) depending on syntax.
+ */
+	if (!extended) /* only one argument */
+		result = process_name(argv[1]);
+
+	else if (argc < 2) /* no arguments */
+		result = process_file(stdin);
+
+	else /* multiple command line arguments */
+		result = process_argv(argc, argv);
+
+/*
+ * Report result status of action taken.
+ */
+	exit(result);
+	/*NOTREACHED*/
+}
+
+/*
+** SET_DEFAULTS -- Interpolate default options and parameters in argv
+** ------------------------------------------------------------------
+**
+**	The HOST_DEFAULTS environment variable gives customized options.
+**
+**	Returns:
+**		None.
+**
+**	Outputs:
+**		Creates ``optargv'' vector with ``optargc'' arguments.
+*/
+
+void
+set_defaults(option, argc, argv)
+input char *option;			/* option string */
+input int argc;				/* original command line arg count */
+input char *argv[];			/* original command line arguments */
+{
+	register char *p, *q;
+	register int i;
+
+/*
+ * Allocate new argument vector.
+ */
+	optargv = newlist(NULL, 2, char *);
+	optargv[0] = argv[0];
+	optargc = 1;
+
+/*
+ * Construct argument list from option string.
+ */
+	for (q = "", p = newstr(option); *p != '\0'; p = q)
+	{
+		while (is_space(*p))
+			p++;
+
+		if (*p == '\0')
+			break;
+
+		for (q = p; *q != '\0' && !is_space(*q); q++)
+			continue;
+
+		if (*q != '\0')
+			*q++ = '\0';
+
+		optargv = newlist(optargv, optargc+2, char *);
+		optargv[optargc] = p;
+		optargc++;
+	}
+
+/*
+ * Append command line arguments.
+ */
+	for (i = 1; i < argc && argv[i] != NULL; i++)
+	{
+		optargv = newlist(optargv, optargc+2, char *);
+		optargv[optargc] = argv[i];
+		optargc++;
+	}
+
+	/* and terminate */
+	optargv[optargc] = NULL;
+}
+
+/*
+** PROCESS_ARGV -- Process command line arguments
+** ----------------------------------------------
+**
+**	Returns:
+**		EX_SUCCESS if information was obtained successfully.
+**		Appropriate exit code otherwise.
+*/
+
+int
+process_argv(argc, argv)
+input int argc;
+input char *argv[];
+{
+	register int i;
+	int result;			/* result status of action taken */
+	int excode = EX_NOINPUT;	/* overall result status */
+
+	for (i = 1; i < argc && argv[i] != NULL; i++)
+	{
+		/* process a single argument */
+		result = process_name(argv[i]);
+
+		/* maintain overall result */
+		if (result != EX_SUCCESS || excode == EX_NOINPUT)
+			excode = result;
+	}
+
+	/* return overall result */
+	return(excode);
+}
+
+/*
+** PROCESS_FILE -- Process arguments from input file
+** -------------------------------------------------
+**
+**	Returns:
+**		EX_SUCCESS if information was obtained successfully.
+**		Appropriate exit code otherwise.
+*/
+
+int
+process_file(fp)
+input FILE *fp;				/* input file with query names */
+{
+	register char *p, *q;
+	char buf[BUFSIZ];
+	int result;			/* result status of action taken */
+	int excode = EX_NOINPUT;	/* overall result status */
+
+	while (fgets(buf, sizeof(buf), fp) != NULL)
+	{
+		p = index(buf, '\n');
+		if (p != NULL)
+			*p = '\0';
+
+		/* extract names separated by whitespace */
+		for (q = "", p = buf; *p != '\0'; p = q)
+		{
+			while (is_space(*p))
+				p++;
+
+			/* ignore comment lines */
+			if (*p == '\0' || *p == '#' || *p == ';')
+				break;
+
+			for (q = p; *q != '\0' && !is_space(*q); q++)
+				continue;
+
+			if (*q != '\0')
+				*q++ = '\0';
+
+			/* process a single argument */
+			result = process_name(p);
+
+			/* maintain overall result */
+			if (result != EX_SUCCESS || excode == EX_NOINPUT)
+				excode = result;
+		}
+	}
+
+	/* return overall result */
+	return(excode);
+}
+
+/*
+** PROCESS_NAME -- Process a single command line argument
+** ------------------------------------------------------
+**
+**	Returns:
+**		EX_SUCCESS if information was obtained successfully.
+**		Appropriate exit code otherwise.
+**
+**	Wrapper for execute_name() to hide administrative tasks.
+*/
+
+int
+process_name(name)
+input char *name;			/* command line argument */
+{
+	int result;			/* result status of action taken */
+	static int save_querytype;
+	static bool save_reverse;
+	static bool firstname = true;
+
+	/* separate subsequent pieces of output */
+	if (!firstname && (verbose || debug || checkmode))
+		printf("\n");
+
+/*
+ * Some global variables are redefined further on. Save their initial
+ * values in the first pass, and restore them during subsequent passes.
+ */
+	if (firstname)
+	{
+		save_querytype = querytype;
+		save_reverse = reverse;
+		firstname = false;
+	}
+	else
+	{
+		querytype = save_querytype;
+		reverse = save_reverse;
+	}
+
+/*
+ * Do the real work.
+ */
+	result = execute_name(name);
+	return(result);
+}
+
+/*
+** EXECUTE_NAME -- Process a single command line argument
+** ------------------------------------------------------
+**
+**	Returns:
+**		EX_SUCCESS if information was obtained successfully.
+**		Appropriate exit code otherwise.
+**
+**	Outputs:
+**		Defines ``queryname'' and ``queryaddr'' appropriately.
+**
+**	Side effects:
+**		May redefine ``querytype'' and ``reverse'' if necessary.
+*/
+
+int
+execute_name(name)
+input char *name;			/* command line argument */
+{
+	bool result;			/* result status of action taken */
+
+	/* check for nonsense input name */
+	if (strlength(name) > MAXDNAME)
+	{
+		errmsg("Query name %s too long", name);
+		return(EX_USAGE);
+	}
+
+/*
+ * Analyze the name and type to be queried about.
+ * The name can be an ordinary domain name, or an internet address
+ * in dotted quad notation. If the -n option is given, the name is
+ * supposed to be a dotted nsap address.
+ * Furthermore, an empty input name is treated as the root domain.
+ */
+	queryname = name;
+	if (queryname[0] == '\0')
+		queryname = ".";
+
+	if (sameword(queryname, "."))
+		queryaddr = NOT_DOTTED_QUAD;
+	else
+		queryaddr = inet_addr(queryname);
+
+/*
+ * Generate reverse in-addr.arpa query if so requested.
+ * The input name must be a dotted quad, and be convertible.
+ */
+	if (reverse)
+	{
+		if (queryaddr == NOT_DOTTED_QUAD)
+			name = NULL;
+		else
+			name = in_addr_arpa(queryname);
+
+		if (name == NULL)
+		{
+			errmsg("Invalid dotted quad %s", queryname);
+			return(EX_USAGE);
+		}
+
+		/* redefine appropriately */
+		queryname = name;
+		queryaddr = NOT_DOTTED_QUAD;
+	}
+
+/*
+ * Generate reverse nsap.int query if so requested.
+ * The input name must be a dotted nsap, and be convertible.
+ */
+	if (revnsap)
+	{
+		if (reverse)
+			name = NULL;
+		else
+			name = nsap_int(queryname);
+
+		if (name == NULL)
+		{
+			errmsg("Invalid nsap address %s", queryname);
+			return(EX_USAGE);
+		}
+
+		/* redefine appropriately */
+		queryname = name;
+		queryaddr = NOT_DOTTED_QUAD;
+
+		/* this is also a reversed mapping domain */
+		reverse = true;
+	}
+
+/*
+ * In regular mode, the querytype is used to formulate the nameserver
+ * query, and any response is filtered out when processing the answer.
+ * In listmode, the querytype is used to filter out the proper records.
+ */
+	/* set querytype for regular mode if unspecified */
+	if ((querytype == T_NONE) && !listmode)
+	{
+		if ((queryaddr != NOT_DOTTED_QUAD) || reverse)
+			querytype = T_PTR;
+		else
+			querytype = T_A;
+	}
+
+/*
+ * Check for incompatible options.
+ */
+	/* cannot have dotted quad in listmode */
+	if (listmode && (queryaddr != NOT_DOTTED_QUAD))
+	{
+		errmsg("Invalid query name %s", queryname);
+		return(EX_USAGE);
+	}
+
+	/* must have regular name or dotted quad in addrmode */
+	if (!listmode && addrmode && reverse)
+	{
+		errmsg("Invalid query name %s", queryname);
+		return(EX_USAGE);
+	}
+
+	/* show what we are going to query about */
+	if (verbose)
+		show_types(queryname, querytype, queryclass);
+
+/*
+ * All set. Perform requested function.
+ */
+	result = execute(queryname, queryaddr);
+	return(result ? EX_SUCCESS : EX_UNAVAILABLE);
+}
+
+/*
+** EXECUTE -- Perform the requested function
+** -----------------------------------------
+**
+**	Returns:
+**		true if information was obtained successfully.
+**		false otherwise.
+**
+**	The whole environment has been set up and checked.
+*/
+
+bool
+execute(name, addr)
+input char *name;			/* name to query about */
+input ipaddr_t addr;			/* explicit address of query */
+{
+	bool result;			/* result status of action taken */
+
+/*
+ * Special mode to list contents of specified zone.
+ */
+	if (listmode)
+	{
+		result = list_zone(name);
+		return(result);
+	}
+
+/*
+ * Special mode to check reverse mappings of host addresses.
+ */
+	if (addrmode)
+	{
+		if (addr == NOT_DOTTED_QUAD)
+			result = check_addr(name);
+		else
+			result = check_name(addr);
+		return(result);
+	}
+
+/*
+ * Regular mode to query about specified host.
+ */
+	result = host_query(name, addr);
+	return(result);
+}
+
+/*
+** HOST_QUERY -- Regular mode to query about specified host
+** --------------------------------------------------------
+**
+**	Returns:
+**		true if information was obtained successfully.
+**		false otherwise.
+*/
+
+bool
+host_query(name, addr)
+input char *name;			/* name to query about */
+input ipaddr_t addr;			/* explicit address of query */
+{
+	struct hostent *hp;
+	struct in_addr inaddr;
+	char newnamebuf[MAXDNAME+1];
+	char *newname = NULL;		/* name to which CNAME is aliased */
+	int ncnames = 0;		/* count of CNAMEs in chain */
+	bool result;			/* result status of action taken */
+
+	inaddr.s_addr = addr;
+
+	result = false;
+	h_errno = TRY_AGAIN;
+
+	/* retry until positive result or permanent failure */
+	while (result == false && h_errno == TRY_AGAIN)
+	{
+		/* reset before each query to avoid stale data */
+		errno = 0;
+		realname = NULL;
+
+		if (addr == NOT_DOTTED_QUAD)
+		{
+			/* reset CNAME indicator */
+			cname = NULL;
+
+			/* lookup the name in question */
+			if (newname == NULL)
+				result = get_hostinfo(name, false);
+			else
+				result = get_hostinfo(newname, true);
+
+			/* recurse on CNAMEs, but not too deep */
+			if (cname && (querytype != T_CNAME))
+			{
+				newname = strcpy(newnamebuf, cname);
+
+				if (ncnames++ > MAXCHAIN)
+				{
+					errmsg("Possible CNAME loop");
+					return(false);
+				}
+
+				result = false;
+				h_errno = TRY_AGAIN;
+				continue;
+			}
+		}
+		else
+		{
+			hp = geth_byaddr((char *)&inaddr, INADDRSZ, AF_INET);
+			if (hp != NULL)
+			{
+				print_host("Name", hp);
+				result = true;
+			}
+		}
+
+		/* only retry if so requested */
+		if (!waitmode)
+			break;
+	}
+
+	/* use actual name if available */
+	if (realname != NULL)
+		name = realname;
+
+	/* explain the reason of a failure */
+	if (result == false)
+		ns_error(name, querytype, queryclass, server);
+
+	return(result);
+}
+
+/*
+** MYHOSTNAME -- Determine our own fully qualified host name
+** ---------------------------------------------------------
+**
+**	Returns:
+**		Pointer to own host name.
+**		Aborts if host name could not be determined.
+*/
+
+char *
+myhostname()
+{
+	struct hostent *hp;
+	static char mynamebuf[MAXDNAME+1];
+	static char *myname = NULL;
+
+	if (myname == NULL)
+	{
+		if (gethostname(mynamebuf, MAXDNAME) < 0)
+		{
+			perror("gethostname");
+			exit(EX_OSERR);
+		}
+		mynamebuf[MAXDNAME] = '\0';
+
+		hp = gethostbyname(mynamebuf);
+		if (hp == NULL)
+		{
+			ns_error(mynamebuf, T_A, C_IN, server);
+			errmsg("Error in looking up own name");
+			exit(EX_NOHOST);
+		}
+
+		/* cache the result */
+		myname = strncpy(mynamebuf, hp->h_name, MAXDNAME);
+		myname[MAXDNAME] = '\0';
+	}
+
+	return(myname);
+}
+
+/*
+** SET_SERVER -- Override default nameserver with explicit server
+** --------------------------------------------------------------
+**
+**	Returns:
+**		None.
+**		Aborts the program if an unknown host was given.
+**
+**	Side effects:
+**		The global variable ``server'' is set to indicate
+**		that an explicit server is being used.
+**
+**	The default nameserver addresses in the resolver database
+**	which are initialized by res_init() from /etc/resolv.conf
+**	are replaced with the (possibly multiple) addresses of an
+**	explicitly named server host. If a dotted quad is given,
+**	only that single address will be used.
+**
+**	The answers from such server must be interpreted with some
+**	care if we don't know beforehand whether it can be trusted.
+*/
+
+void
+set_server(name)
+input char *name;			/* name of server to be queried */
+{
+	register int i;
+	struct hostent *hp;
+	struct in_addr inaddr;
+	ipaddr_t addr;			/* explicit address of server */
+
+	/* check for nonsense input name */
+	if (strlength(name) > MAXDNAME)
+	{
+		errmsg("Server name %s too long", name);
+		exit(EX_USAGE);
+	}
+
+/*
+ * Overrule the default nameserver addresses.
+ */
+	addr = inet_addr(name);
+	inaddr.s_addr = addr;
+
+	if (addr == NOT_DOTTED_QUAD)
+	{
+		/* lookup all of its addresses; this must not fail */
+		hp = gethostbyname(name);
+		if (hp == NULL)
+		{
+			ns_error(name, T_A, C_IN, server);
+			errmsg("Error in looking up server name");
+			exit(EX_NOHOST);
+		}
+
+		for (i = 0; i < MAXNS && hp->h_addr_list[i]; i++)
+		{
+			nslist(i).sin_family = AF_INET;
+			nslist(i).sin_port = htons(NAMESERVER_PORT);
+			nslist(i).sin_addr = incopy(hp->h_addr_list[i]);
+		}
+		_res.nscount = i;
+	}
+	else
+	{
+		/* lookup the name, but use only the given address */
+		hp = gethostbyaddr((char *)&inaddr, INADDRSZ, AF_INET);
+
+		nslist(0).sin_family = AF_INET;
+		nslist(0).sin_port = htons(NAMESERVER_PORT);
+		nslist(0).sin_addr = inaddr;
+		_res.nscount = 1;
+	}
+
+/*
+ * Indicate the use of an explicit server.
+ */
+	if (hp != NULL)
+	{
+		server = strncpy(serverbuf, hp->h_name, MAXDNAME);
+		server[MAXDNAME] = '\0';
+
+		if (verbose)
+			print_host("Server", hp);
+	}
+	else
+	{
+		server = strcpy(serverbuf, inet_ntoa(inaddr));
+
+		if (verbose)
+			printf("Server: %s\n\n", server);
+	}
+}
+
+/*
+** SET_LOGFILE -- Initialize optional log file
+** -------------------------------------------
+**
+**	Returns:
+**		None.
+**		Aborts the program if the file could not be created.
+**
+**	Side effects:
+**		The global variable ``logfile'' is set to indicate
+**		that resource record output is to be written to it.
+**
+**	Swap ordinary stdout and log file output if so requested.
+*/
+
+void
+set_logfile(filename)
+input char *filename;			/* name of log file */
+{
+	if (logexchange)
+	{
+		logfile = fdopen(dup(STDOUT), "w");
+		if (logfile == NULL)
+		{
+			perror("fdopen");
+			exit(EX_OSERR);
+		}
+
+		if (freopen(filename, "w", stdout) == NULL)
+		{
+			perror(filename);
+			exit(EX_CANTCREAT);
+		}
+	}
+	else
+	{
+		logfile = fopen(filename, "w");
+		if (logfile == NULL)
+		{
+			perror(filename);
+			exit(EX_CANTCREAT);
+		}
+	}
+}
+
+/*
+** FATAL -- Abort program when illegal option encountered
+** ------------------------------------------------------
+**
+**	Returns:
+**		Aborts after issuing error message.
+*/
+
+void /*VARARGS1*/
+fatal(fmt, a, b, c, d)
+input char *fmt;			/* format of message */
+input char *a, *b, *c, *d;		/* optional arguments */
+{
+	(void) fprintf(stderr, fmt, a, b, c, d);
+	(void) fprintf(stderr, "\n");
+	exit(EX_USAGE);
+}
+
+
+/*
+** ERRMSG -- Issue error message to error output
+** ---------------------------------------------
+**
+**	Returns:
+**		None.
+**
+**	Side effects:
+**		Increments the global error count.
+*/
+
+void /*VARARGS1*/
+errmsg(fmt, a, b, c, d)
+input char *fmt;			/* format of message */
+input char *a, *b, *c, *d;		/* optional arguments */
+{
+	(void) fprintf(stderr, fmt, a, b, c, d);
+	(void) fprintf(stderr, "\n");
+
+	/* flag an error */
+	errorcount++;
+}
+
+/*
+** GET_HOSTINFO -- Principal routine to query about given name
+** -----------------------------------------------------------
+**
+**	Returns:
+**		true if requested info was obtained successfully.
+**		false otherwise.
+**
+**	This is the equivalent of the resolver module res_search().
+**
+**	In this program RES_DEFNAMES is always on, and RES_DNSRCH
+**	is off by default. This means that single names without dot
+**	are always, and only, tried within the own default domain,
+**	and compound names are assumed to be already fully qualified.
+**
+**	The default BIND behavior can be simulated by turning on
+**	RES_DNSRCH with -R. The given name, whether or not compound,
+**	is then	first tried within the possible search domains.
+**
+**	Note. In the latter case, the search terminates in case the
+**	specified name exists but does not have the desired type.
+**	The BIND behavior is to continue the search. This can be
+**	simulated with the undocumented option -B.
+*/
+
+bool
+get_hostinfo(name, qualified)
+input char *name;			/* name to query about */
+input bool qualified;			/* assume fully qualified if set */
+{
+	register char **domain;
+	register char *cp;
+	const char *hp;
+	int dot;			/* number of dots in query name */
+	bool result;			/* result status of action taken */
+	char oldnamebuf[2*MAXDNAME+2];
+	char *oldname = NULL;		/* saved actual name when NO_DATA */
+	int nodata = 0;			/* NO_DATA status during DNSRCH */
+	int nquery = 0;			/* number of extra search queries */
+
+/*
+ * Single dot means root zone.
+ */
+	if (sameword(name, "."))
+		qualified = true;
+
+/*
+ * Names known to be fully qualified are just tried ``as is''.
+ */
+	if (qualified)
+	{
+		result = get_domaininfo(name, (char *)NULL);
+		return(result);
+	}
+
+/*
+ * Count number of dots. Move to the end of the name.
+ */
+	for (dot = 0, cp = name; *cp != '\0'; cp++)
+		if (*cp == '.')
+			dot++;
+
+/*
+ * Check for aliases of single name.
+ * Note that the alias is supposed to be fully qualified.
+ */
+	if (dot == 0 && (hp = hostalias(name)) != NULL)
+	{
+		if (verbose)
+			printf("Aliased %s to %s\n", name, hp);
+
+		result = get_domaininfo(hp, (char *)NULL);
+		return(result);
+	}
+
+/*
+ * Trailing dot means absolute (fully qualified) address.
+ */
+	if (dot != 0 && cp[-1] == '.')
+	{
+		cp[-1] = '\0';
+		result = get_domaininfo(name, (char *)NULL);
+		cp[-1] = '.';
+		return(result);
+	}
+
+/*
+ * Append own default domain and other search domains if appropriate.
+ */
+	if ((dot == 0 && bitset(RES_DEFNAMES, _res.options)) ||
+	    (dot != 0 && bitset(RES_DNSRCH, _res.options)))
+	{
+		for (domain = _res.dnsrch; *domain; domain++)
+		{
+			result = get_domaininfo(name, *domain);
+			if (result)
+				return(result);
+
+			/* keep count of extra search queries */
+			nquery++;
+
+			/* in case nameserver not present */
+			if (errno == ECONNREFUSED)
+				return(false);
+
+			/* if no further search desired (single name) */
+	    		if (!bitset(RES_DNSRCH, _res.options))
+				break;
+
+			/* if name exists but has not requested type */
+			if (h_errno == NO_DATA || h_errno == NO_RREC)
+			{
+				if (bindcompat)
+				{
+					/* remember status and search up */
+					oldname = strcpy(oldnamebuf, realname);
+					nodata = h_errno;
+					continue;
+				}
+
+				return(false);
+			}
+
+			/* retry only if name does not exist at all */
+			if (h_errno != HOST_NOT_FOUND && h_errno != NO_HOST)
+				break;
+		}
+	}
+
+/*
+ * Single name lookup failed.
+ */
+	if (dot == 0)
+	{
+		/* unclear what actual name should be */
+		if (nquery != 1)
+			realname = NULL;
+
+		/* restore nodata status from search */
+		if (bindcompat && nodata)
+		{
+			realname = strcpy(realnamebuf, oldname);
+			h_errno = nodata;
+		}
+
+		/* set status in case we never queried */
+		if (!bitset(RES_DEFNAMES, _res.options))
+			h_errno = HOST_NOT_FOUND;
+
+		return(false);
+	}
+
+/*
+ * Rest means fully qualified.
+ */
+	result = get_domaininfo(name, (char *)NULL);
+
+	/* restore nodata status from search */
+	if (!result && bindcompat && nodata)
+	{
+		realname = strcpy(realnamebuf, oldname);
+		h_errno = nodata;
+	}
+
+	return(result);
+}
+
+/*
+** GET_DOMAININFO -- Fetch and print desired info about name in domain
+** -------------------------------------------------------------------
+**
+**	Returns:
+**		true if requested info was obtained successfully.
+**		false otherwise.
+**
+**	Side effects:
+**		Sets global variable ``realname'' to actual name queried.
+**
+**	This is the equivalent of the resolver module res_querydomain().
+**
+**	Things get a little complicated in case RES_DNSRCH is on.
+**	If we get an answer but the data is corrupted, an error will be
+**	returned and NO_RECOVERY will be set. This will terminate the
+**	extra search loop, but a compound name will still be tried as-is.
+**	The same holds if the query times out or we have a server failure,
+**	in which case an error will be returned and TRY_AGAIN will be set.
+**	For now we take this for granted. Normally RES_DNSRCH is disabled.
+**	In this default case we do only one query and we have no problem.
+*/
+
+bool
+get_domaininfo(name, domain)
+input char *name;			/* name to query about */
+input char *domain;			/* domain to which name is relative */
+{
+	char namebuf[2*MAXDNAME+2];	/* buffer to store full domain name */
+	querybuf answer;
+	register int n;
+	bool result;			/* result status of action taken */
+
+/*
+ * Show what we are about to query.
+ */
+	if (verbose)
+	{
+		if (domain == NULL || domain[0] == '\0')
+			printf("Trying %s", name);
+		else
+			printf("Trying %s within %s", name, domain);
+
+		if (server && (verbose > 1))
+			printf(" at server %s", server);
+
+		printf(" ...\n");
+	}
+
+/*
+ * Construct the actual domain name.
+ * A null domain means the given name is already fully qualified.
+ * If the composite name is too long, res_mkquery() will fail.
+ */
+	if (domain == NULL || domain[0] == '\0')
+		(void) sprintf(namebuf, "%.*s", MAXDNAME, name);
+	else
+		(void) sprintf(namebuf, "%.*s.%.*s",
+				MAXDNAME, name, MAXDNAME, domain);
+	name = namebuf;
+
+/*
+ * Fetch the desired info.
+ */
+	n = get_info(&answer, name, querytype, queryclass);
+	result = (n < 0) ? false : true;
+
+/*
+ * Print the relevant data.
+ * If we got a positive answer, the data may still be corrupted.
+ */
+	if (result)
+	    result = print_info(&answer, n, name, querytype, queryclass, true);
+
+/*
+ * Remember the actual name that was queried.
+ * Must be at the end to avoid clobbering during recursive calls.
+ */
+	realname = strcpy(realnamebuf, name);
+
+	return(result);
+}
+
+/*
+** GET_INFO -- Basic routine to issue a nameserver query
+** -----------------------------------------------------
+**
+**	Returns:
+**		Length of nameserver answer buffer, if obtained.
+**		-1 if an error occurred (h_errno is set appropriately).
+**
+**	This is the equivalent of the resolver module res_query().
+*/
+
+int
+get_info(answerbuf, name, type, class)
+output querybuf *answerbuf;		/* location of buffer to store answer */
+input char *name;			/* full name to query about */
+input int type;				/* specific resource record type */
+input int class;			/* specific resource record class */
+{
+	querybuf query;
+	HEADER *bp;
+	int ancount;
+	register int n;
+
+/*
+ * Construct query, and send it to the nameserver.
+ * res_send() will fail if no nameserver responded. In the BIND version the
+ * possible values for errno are ECONNREFUSED and ETIMEDOUT. If we did get
+ * an answer, errno should be reset, since res_send() may have left an errno
+ * in case it has used datagrams. Our private version of res_send() will leave
+ * also other error statuses, and will clear errno if an answer was obtained.
+ */
+	errno = 0;	/* reset before querying nameserver */
+
+	n = res_mkquery(QUERY, name, class, type, (qbuf_t *)NULL, 0,
+			(rrec_t *)NULL, (qbuf_t *)&query, sizeof(querybuf));
+	if (n < 0)
+	{
+		if (debug)
+			printf("%sres_mkquery failed\n", dbprefix);
+		h_errno = NO_RECOVERY;
+		return(-1);
+	}
+
+	n = res_send((qbuf_t *)&query, n, (qbuf_t *)answerbuf, sizeof(querybuf));
+	if (n < 0)
+	{
+		if (debug)
+			printf("%sres_send failed\n", dbprefix);
+		h_errno = TRY_AGAIN;
+		return(-1);
+	}
+
+	errno = 0;	/* reset after we got an answer */
+
+	if (n < HFIXEDSZ)
+	{
+		pr_error("answer length %s too short after %s query for %s",
+			itoa(n), pr_type(type), name);
+		h_errno = NO_RECOVERY;
+		return(-1);
+	}
+
+/*
+ * Analyze the status of the answer from the nameserver.
+ */
+	if ((verbose > print_level) || debug)
+		print_status(answerbuf, n);
+
+	bp = (HEADER *)answerbuf;
+	ancount = ntohs(bp->ancount);
+
+	if (bp->rcode != NOERROR || ancount == 0)
+	{
+		switch (bp->rcode)
+		{
+		    case NXDOMAIN:
+			/* distinguish between authoritative or not */
+			h_errno = bp->aa ? HOST_NOT_FOUND : NO_HOST;
+			break;
+
+		    case NOERROR:
+			/* distinguish between authoritative or not */
+			h_errno = bp->aa ? NO_DATA : NO_RREC;
+			break;
+
+		    case SERVFAIL:
+			h_errno = SERVER_FAILURE; /* instead of TRY_AGAIN */
+			break;
+
+		    case REFUSED:
+			h_errno = QUERY_REFUSED; /* instead of NO_RECOVERY */
+			break;
+
+		    default:
+			h_errno = NO_RECOVERY; /* FORMERR NOTIMP NOCHANGE */
+			break;
+		}
+		return(-1);
+	}
+
+	/* valid answer received, avoid buffer overrun */
+	h_errno = 0;
+	return(querysize(n));
+}
+
+/*
+** PRINT_INFO -- Check resource records in answer and print relevant data
+** ----------------------------------------------------------------------
+**
+**	Returns:
+**		true if answer buffer was processed successfully.
+**		false otherwise.
+**
+**	Side effects:
+**		Will recurse on MAILB records if appropriate.
+**		See also side effects of the print_rrec() routine.
+*/
+
+bool
+print_info(answerbuf, answerlen, name, type, class, regular)
+input querybuf *answerbuf;		/* location of answer buffer */
+input int answerlen;			/* length of answer buffer */
+input char *name;			/* full name we are querying about */
+input int type;				/* record type we are querying about */
+input int class;			/* record class we are querying about */
+input bool regular;			/* set if this is a regular lookup */
+{
+	HEADER *bp;
+	int qdcount, ancount, nscount, arcount;
+	u_char *msg, *eom;
+	register u_char *cp;
+
+	bp = (HEADER *)answerbuf;
+	qdcount = ntohs(bp->qdcount);
+	ancount = ntohs(bp->ancount);
+	nscount = ntohs(bp->nscount);
+	arcount = ntohs(bp->arcount);
+
+	msg = (u_char *)answerbuf;
+	eom = (u_char *)answerbuf + answerlen;
+	cp  = (u_char *)answerbuf + HFIXEDSZ;
+
+/*
+ * Skip the query section in the response (present only in normal queries).
+ */
+	if (qdcount)
+	{
+		while (qdcount > 0 && cp < eom)	/* process all records */
+		{
+			cp = skip_qrec(name, type, class, cp, msg, eom);
+			if (cp == NULL)
+				return(false);
+			qdcount--;
+		}
+
+		if (qdcount)
+		{
+			pr_error("invalid qdcount after %s query for %s",
+				pr_type(type), name);
+			h_errno = NO_RECOVERY;
+			return(false);
+		}
+	}
+
+/*
+ * Process the actual answer section in the response.
+ * During zone transfers, this is the only section available.
+ */
+	if (ancount)
+	{
+		if ((type != T_AXFR) && verbose && !bp->aa)
+			printf("The following answer is not authoritative:\n");
+
+		while (ancount > 0 && cp < eom)
+		{
+			/* reset for each record during zone listings */
+			soaname = NULL, subname = NULL, adrname = NULL, address = 0;
+
+			print_level++;
+			cp = print_rrec(name, type, class, cp, msg, eom, regular);
+			print_level--;
+			if (cp == NULL)
+				return(false);
+			ancount--;
+
+			/* update zone information during zone listings */
+			if (type == T_AXFR)
+				update_zone(name);
+
+			/* we trace down CNAME chains ourselves */
+			if (regular && !verbose && cname)
+				return(true);
+
+			/* recursively expand MR/MG records into MB records */
+			if (regular && mailmode && mname)
+				(void) get_recursive(&mname);
+		}
+
+		if (ancount)
+		{
+			pr_error("invalid ancount after %s query for %s",
+				pr_type(type), name);
+			h_errno = NO_RECOVERY;
+			return(false);
+		}
+	}
+
+/*
+ * The nameserver and additional info section are normally not processed.
+ * Both sections shouldn't exist in zone transfers.
+ */
+	if (!verbose || exclusive)
+		return(true);
+
+	if (nscount)
+	{
+		printf("Authoritative nameservers:\n");
+
+		while (nscount > 0 && cp < eom)
+		{
+			print_level++;
+			cp = print_rrec(name, type, class, cp, msg, eom, false);
+			print_level--;
+			if (cp == NULL)
+				return(false);
+			nscount--;
+		}
+
+		if (nscount)
+		{
+			pr_error("invalid nscount after %s query for %s",
+				pr_type(type), name);
+			h_errno = NO_RECOVERY;
+			return(false);
+		}
+	}
+
+	if (arcount)
+	{
+		printf("Additional information:\n");
+
+		while (arcount > 0 && cp < eom)
+		{
+			print_level++;
+			cp = print_rrec(name, type, class, cp, msg, eom, false);
+			print_level--;
+			if (cp == NULL)
+				return(false);
+			arcount--;
+		}
+
+		if (arcount)
+		{
+			pr_error("invalid arcount after %s query for %s",
+				pr_type(type), name);
+			h_errno = NO_RECOVERY;
+			return(false);
+		}
+	}
+
+	/* all sections were processed successfully */
+	return(true);
+}
+
+/*
+** PRINT_DATA -- Output resource record data if this record is wanted
+** ------------------------------------------------------------------
+**
+**	Returns:
+**		None.
+**
+**	Inputs:
+**		The global variable ``doprint'' is set by print_rrec()
+**		if we need to print the data.
+*/
+
+static bool doprint;		/* indicates whether or not to print */
+
+void /*VARARGS1*/
+print_data(fmt, a, b, c, d)
+input char *fmt;			/* format of message */
+input char *a, *b, *c, *d;		/* optional arguments */
+{
+	/* if (doprint) */
+	{
+		if (!suppress)
+			printf(fmt, a, b, c, d);
+
+		if (logfile != NULL)
+			(void) fprintf(logfile, fmt, a, b, c, d);
+	}
+}
+
+#define doprintf(x)\
+{\
+	if (doprint)\
+	{\
+		print_data x ;\
+	}\
+}
+
+/*
+** PRINT_RREC -- Decode single resource record and output relevant data
+** --------------------------------------------------------------------
+**
+**	Returns:
+**		Pointer to position in answer buffer after current record.
+**		NULL if there was a format error in the current record.
+**
+**	Outputs:
+**		The global variable ``doprint'' is set appropriately
+**		for use by print_data().
+**
+**	Side effects:
+**		Updates resource record statistics in record_stats[].
+**		Sets ``soaname'' if this is an SOA record.
+**		Sets ``subname'' if this is an NS record.
+**		Sets ``adrname'' if this is an A record.
+**		Sets ``address'' if this is an A record.
+**		Sets ``cname'' if this is a valid CNAME record.
+**		Sets ``mname'' if this is a valid MAILB record.
+**		These variables must have been cleared before calling
+**		print_info() and may be checked afterwards.
+*/
+
+/* print domain names after certain conversions */
+#define pr_name(x)	pr_domain(x, listing)
+
+/* check the LHS record name of these records for invalid characters */
+#define test_valid(t)	(((t == T_A) && !reverse) || t == T_MX || t == T_AAAA)
+
+/* check the RHS domain name of these records for canonical host names */
+#define test_canon(t)	(t == T_NS || t == T_MX)
+
+u_char *
+print_rrec(name, qtype, qclass, cp, msg, eom, regular)
+input char *name;			/* full name we are querying about */
+input int qtype;			/* record type we are querying about */
+input int qclass;			/* record class we are querying about */
+register u_char *cp;			/* current position in answer buf */
+input u_char *msg, *eom;		/* begin and end of answer buf */
+input bool regular;			/* set if this is a regular lookup */
+{
+	char rname[MAXDNAME+1];		/* record name in LHS */
+	char dname[MAXDNAME+1];		/* domain name in RHS */
+	int type, class, ttl, dlen;	/* fixed values in every record */
+	u_char *eor;			/* predicted position of next record */
+	bool classmatch;		/* set if we want to see this class */
+	bool listing;			/* set if this is a zone listing */
+	char *host = listhost;		/* contacted host for zone listings */
+	register int n, c;
+	struct in_addr inaddr;
+	struct protoent *protocol;
+	struct servent *service;
+
+/*
+ * Pickup the standard values present in each resource record.
+ */
+	n = expand_name(name, T_NONE, cp, msg, eom, rname);
+	if (n < 0)
+		return(NULL);
+	cp += n;
+
+	n = 3*INT16SZ + INT32SZ;
+	if (check_size(rname, T_NONE, cp, msg, eom, n) < 0)
+		return(NULL);
+
+	type = _getshort(cp);
+	cp += INT16SZ;
+
+	class = _getshort(cp);
+	cp += INT16SZ;
+
+	ttl = _getlong(cp);
+	cp += INT32SZ;
+
+	dlen = _getshort(cp);
+	cp += INT16SZ;
+
+	eor = cp + dlen;
+
+/*
+ * Decide whether or not to print this resource record.
+ */
+	listing = (qtype == T_AXFR || qtype == T_IXFR) ? true : false;
+
+	if (listing)
+	{
+		classmatch = want_class(class, queryclass);
+		doprint = classmatch && want_type(type, querytype);
+	}
+	else
+	{
+		classmatch = want_class(class, C_ANY);
+		doprint = classmatch && want_type(type, T_ANY);
+	}
+
+	if (doprint && exclusive && !indomain(rname, name, true))
+		doprint = false;
+
+	if (doprint && exclusive && fakename(rname))
+		doprint = false;
+
+	if (doprint && wildcards && !in_string(rname, '*'))
+		doprint = false;
+	if (namelen && (strlength(rname) < namelen))
+		doprint = false;
+
+/*
+ * Print name and common values, if appropriate.
+ */
+	doprintf(("%-20s", pr_name(rname)))
+
+	if (verbose || ttlprint)
+		doprintf(("\t%s", itoa(ttl)))
+
+	if (verbose || classprint || (class != qclass))
+		doprintf(("\t%s", pr_class(class)))
+
+	doprintf(("\t%s", pr_type(type)))
+
+/*
+ * Update resource record statistics for zone listing.
+ */
+	if (listing && classmatch)
+	{
+		if (type >= T_FIRST && type <= T_LAST)
+			record_stats[type]++;
+	}
+
+/*
+ * Save the domain name of an SOA or NS or A record for zone listing.
+ */
+	if (listing && classmatch)
+	{
+		if (type == T_A)
+			adrname = strcpy(adrnamebuf, rname);
+
+		else if (type == T_NS)
+			subname = strcpy(subnamebuf, rname);
+
+		else if (type == T_SOA)
+			soaname = strcpy(soanamebuf, rname);
+	}
+
+/*
+ * Print type specific data, if appropriate.
+ */
+	switch (type)
+	{
+	    case T_A:
+		if (class == C_IN || class == C_HS)
+		{
+			if (dlen == INADDRSZ)
+			{
+				bcopy((char *)cp, (char *)&inaddr, INADDRSZ);
+				address = inaddr.s_addr;
+				doprintf(("\t%s", inet_ntoa(inaddr)))
+				cp += INADDRSZ;
+				break;
+			}
+			address = 0;
+			break;
+		}
+		address = 0;
+		cp += dlen;
+		break;
+
+	    case T_MX:
+		if (check_size(rname, type, cp, msg, eor, INT16SZ) < 0)
+			break;
+		n = _getshort(cp);
+		doprintf(("\t%s", itoa(n)))
+		cp += INT16SZ;
+
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf((" %s", pr_name(dname)))
+		cp += n;
+		break;
+
+	    case T_NS:
+	    case T_PTR:
+	    case T_CNAME:
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf(("\t%s", pr_name(dname)))
+		cp += n;
+		break;
+
+	    case T_HINFO:
+		if (check_size(rname, type, cp, msg, eor, 1) < 0)
+			break;
+		n = *cp++;
+		doprintf(("\t\"%s\"", stoa(cp, n, true)))
+		cp += n;
+
+		if (check_size(rname, type, cp, msg, eor, 1) < 0)
+			break;
+		n = *cp++;
+		doprintf(("\t\"%s\"", stoa(cp, n, true)))
+		cp += n;
+		break;
+
+	    case T_SOA:
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf(("\t%s", pr_name(dname)))
+		cp += n;
+
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf((" %s", pr_name(dname)))
+		cp += n;
+
+		n = 5*INT32SZ;
+		if (check_size(rname, type, cp, msg, eor, n) < 0)
+			break;
+		doprintf((" ("))
+
+		n = _getlong(cp);
+		doprintf(("\n\t\t\t%s", utoa(n)))
+		doprintf(("\t;serial (version)"))
+		cp += INT32SZ;
+
+		n = _getlong(cp);
+		doprintf(("\n\t\t\t%s", itoa(n)))
+		doprintf(("\t;refresh period (%s)", pr_time(n, false)))
+		cp += INT32SZ;
+
+		n = _getlong(cp);
+		doprintf(("\n\t\t\t%s", itoa(n)))
+		doprintf(("\t;retry interval (%s)", pr_time(n, false)))
+		cp += INT32SZ;
+
+		n = _getlong(cp);
+		doprintf(("\n\t\t\t%s", itoa(n)))
+		doprintf(("\t;expire time (%s)", pr_time(n, false)))
+		cp += INT32SZ;
+
+		n = _getlong(cp);
+		doprintf(("\n\t\t\t%s", itoa(n)))
+		doprintf(("\t;default ttl (%s)", pr_time(n, false)))
+		cp += INT32SZ;
+
+		doprintf(("\n\t\t\t)"))
+		break;
+
+	    case T_WKS:
+		if (check_size(rname, type, cp, msg, eor, INADDRSZ) < 0)
+			break;
+		bcopy((char *)cp, (char *)&inaddr, INADDRSZ);
+		doprintf(("\t%s", inet_ntoa(inaddr)))
+		cp += INADDRSZ;
+
+		if (check_size(rname, type, cp, msg, eor, 1) < 0)
+			break;
+		n = *cp++;
+
+		protocol = getprotobynumber(n);
+		if (protocol != NULL)
+			doprintf((" %s", protocol->p_name))
+		else
+			doprintf((" %s", itoa(n)))
+
+		doprintf((" ("))
+		n = 0;
+		while (cp < eor)
+		{
+		    c = *cp++;
+		    do
+		    {
+ 			if (c & 0200)
+			{
+			    int port;
+
+			    port = htons(n);
+			    if (protocol != NULL)
+				    service = getservbyport(port, protocol->p_name);
+			    else
+				    service = NULL;
+
+			    if (service != NULL)
+				    doprintf((" %s", service->s_name))
+			    else
+				    doprintf((" %s", itoa(n)))
+			}
+ 			c <<= 1;
+		    } while (++n & 07);
+		}
+		doprintf((" )"))
+		break;
+
+
+	    case T_TXT:
+		if (check_size(rname, type, cp, msg, eor, 1) < 0)
+			break;
+		n = *cp++;
+		doprintf(("\t\"%s\"", stoa(cp, n, true)))
+		cp += n;
+
+		while (cp < eor)
+		{
+			if (check_size(rname, type, cp, msg, eor, 1) < 0)
+				break;
+			n = *cp++;
+			doprintf((" \"%s\"", stoa(cp, n, true)))
+			cp += n;
+		}
+		break;
+
+	    case T_MINFO:
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf(("\t%s", pr_name(dname)))
+		cp += n;
+
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf((" %s", pr_name(dname)))
+		cp += n;
+		break;
+
+	    case T_MB:
+	    case T_MG:
+	    case T_MR:
+	    case T_MD:
+	    case T_MF:
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf(("\t%s", pr_name(dname)))
+		cp += n;
+		break;
+
+	    case T_UID:
+	    case T_GID:
+		if (dlen == INT32SZ)
+		{
+			n = _getlong(cp);
+			doprintf(("\t%s", itoa(n)))
+			cp += INT32SZ;
+		}
+		break;
+
+	    case T_UINFO:
+		doprintf(("\t\"%s\"", stoa(cp, dlen, true)))
+		cp += dlen;
+		break;
+
+	    case T_RP:
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf(("\t%s", pr_name(dname)))
+		cp += n;
+
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf((" %s", pr_name(dname)))
+		cp += n;
+		break;
+
+	    case T_RT:
+		if (check_size(rname, type, cp, msg, eor, INT16SZ) < 0)
+			break;
+		n = _getshort(cp);
+		doprintf(("\t%s", itoa(n)))
+		cp += INT16SZ;
+
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf((" %s", pr_name(dname)))
+		cp += n;
+		break;
+
+	    case T_AFSDB:
+		if (check_size(rname, type, cp, msg, eor, INT16SZ) < 0)
+			break;
+		n = _getshort(cp);
+		doprintf(("\t%s", itoa(n)))
+		cp += INT16SZ;
+
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf((" %s", pr_name(dname)))
+		cp += n;
+		break;
+
+	    case T_X25:
+		if (check_size(rname, type, cp, msg, eor, 1) < 0)
+			break;
+		n = *cp++;
+		doprintf(("\t%s", stoa(cp, n, false)))
+		cp += n;
+		break;
+
+	    case T_ISDN:
+		if (check_size(rname, type, cp, msg, eor, 1) < 0)
+			break;
+		n = *cp++;
+		doprintf(("\t%s", stoa(cp, n, false)))
+		cp += n;
+
+		if (cp < eor)
+		{
+			if (check_size(rname, type, cp, msg, eor, 1) < 0)
+				break;
+			n = *cp++;
+			doprintf((" %s", stoa(cp, n, false)))
+			cp += n;
+		}
+		break;
+
+	    case T_NSAP:
+		doprintf(("\t0x%s", nsap_ntoa(cp, dlen)))
+		cp += dlen;
+		break;
+
+	    case T_NSAPPTR:
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf(("\t%s", pr_name(dname)))
+		cp += n;
+		break;
+
+	    case T_PX:
+		if (check_size(rname, type, cp, msg, eor, INT16SZ) < 0)
+			break;
+		n = _getshort(cp);
+		doprintf(("\t%s", itoa(n)))
+		cp += INT16SZ;
+
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf((" %s", pr_name(dname)))
+		cp += n;
+
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf((" %s", pr_name(dname)))
+		cp += n;
+		break;
+
+	    case T_GPOS:
+		if (check_size(rname, type, cp, msg, eor, 1) < 0)
+			break;
+		n = *cp++;
+		doprintf(("\t%s", stoa(cp, n, false)))
+		cp += n;
+
+		if (check_size(rname, type, cp, msg, eor, 1) < 0)
+			break;
+		n = *cp++;
+		doprintf(("\t%s", stoa(cp, n, false)))
+		cp += n;
+
+		if (check_size(rname, type, cp, msg, eor, 1) < 0)
+			break;
+		n = *cp++;
+		doprintf(("\t%s", stoa(cp, n, false)))
+		cp += n;
+		break;
+
+	    case T_LOC:
+		if ((n = *cp) != T_LOC_VERSION)
+		{
+			pr_error("invalid version %s in %s record for %s",
+				itoa(n), pr_type(type), rname);
+			cp += dlen;
+			break;
+		}
+
+		n = INT32SZ + 3*INT32SZ;
+		if (check_size(rname, type, cp, msg, eor, n) < 0)
+			break;
+		c = _getlong(cp);
+		cp += INT32SZ;
+
+		n = _getlong(cp);
+		doprintf(("\t%s ", pr_spherical(n, "N", "S")))
+		cp += INT32SZ;
+
+		n = _getlong(cp);
+		doprintf((" %s ", pr_spherical(n, "E", "W")))
+		cp += INT32SZ;
+
+		n = _getlong(cp);
+		doprintf((" %sm ", pr_vertical(n, "", "-")))
+		cp += INT32SZ;
+
+		doprintf((" %sm", pr_precision((c >> 16) & 0xff)))
+		doprintf((" %sm", pr_precision((c >>  8) & 0xff)))
+		doprintf((" %sm", pr_precision((c >>  0) & 0xff)))
+		break;
+
+	    case T_UNSPEC:
+	    case T_NULL:
+		cp += dlen;
+		break;
+
+	    case T_AAAA:
+		if (dlen == IPNGSIZE)
+		{
+			doprintf(("\t%s", ipng_ntoa(cp)))
+			cp += IPNGSIZE;
+		}
+		break;
+
+	    case T_SIG:
+		if (check_size(rname, type, cp, msg, eor, INT16SZ) < 0)
+			break;
+		n = _getshort(cp);
+		doprintf(("\t%s", pr_type(n)))
+		cp += INT16SZ;
+
+		if (check_size(rname, type, cp, msg, eor, 1) < 0)
+			break;
+		n = *cp++;
+		doprintf((" %s", itoa(n)))
+
+		n = 1 + 3*INT32SZ + INT16SZ;
+		if (check_size(rname, type, cp, msg, eor, n) < 0)
+			break;
+		doprintf((" ("))
+
+		n = *cp++;
+		doprintf(("\n\t\t\t; %s", itoa(n)))
+		doprintf(("\t\t;labels"))
+
+		n = _getlong(cp);
+		doprintf(("\n\t\t\t%s", itoa(n)))
+		doprintf(("\t\t;original ttl"))
+		cp += INT32SZ;
+
+		n = _getlong(cp);
+		doprintf(("\n\t\t\t%s", pr_date(n)))
+		doprintf(("\t;signature expiration"))
+		cp += INT32SZ;
+
+		n = _getlong(cp);
+		doprintf(("\n\t\t\t%s", pr_date(n)))
+		doprintf(("\t;signature signed time"))
+		cp += INT32SZ;
+
+		n = _getshort(cp);
+		doprintf(("\n\t\t\t%s", itoa(n)))
+		doprintf(("\t\t;key footprint"))
+		cp += INT16SZ;
+
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf(("\n\t\t\t%s", pr_name(dname)))
+		cp += n;
+
+		if (cp < eor)
+		{
+			register char *buf;
+			register int size;
+
+			n = eor - cp;
+			buf = base_ntoa(cp, n);
+			size = strlength(buf);
+			cp += n;
+
+			while ((n = (size > 64) ? 64 : size) > 0)
+			{
+				doprintf(("\n\t%s", stoa((u_char *)buf, n, false)))
+				buf += n; size -= n;
+			}
+		}
+
+		doprintf(("\n\t\t\t)"))
+		break;
+
+	    case T_KEY:
+		if (check_size(rname, type, cp, msg, eor, INT16SZ) < 0)
+			break;
+		n = _getshort(cp);
+		doprintf(("\t0x%s", xtoa(n)))
+		cp += INT16SZ;
+
+		if (check_size(rname, type, cp, msg, eor, 1) < 0)
+			break;
+		n = *cp++;
+		doprintf((" %s", itoa(n)))
+
+		if (check_size(rname, type, cp, msg, eor, 1) < 0)
+			break;
+		n = *cp++;
+		doprintf((" %s", itoa(n)))
+
+		if (cp < eor)
+		{
+			register char *buf;
+			register int size;
+
+			n = eor - cp;
+			buf = base_ntoa(cp, n);
+			size = strlength(buf);
+			cp += n;
+
+			doprintf((" ("))
+			while ((n = (size > 64) ? 64 : size) > 0)
+			{
+				doprintf(("\n\t%s", stoa((u_char *)buf, n, false)))
+				buf += n; size -= n;
+			}
+			doprintf(("\n\t\t\t)"))
+		}
+		break;
+
+	    case T_NXT:
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf(("\t%s", pr_name(dname)))
+		cp += n;
+
+		n = 0;
+		while (cp < eor)
+		{
+		    c = *cp++;
+		    do
+		    {
+ 			if (c & 0200)
+			{
+			    doprintf((" %s", pr_type(n)))
+			}
+ 			c <<= 1;
+		    } while (++n & 07);
+		}
+		break;
+
+	    case T_SRV:
+		if (check_size(rname, type, cp, msg, eor, INT16SZ) < 0)
+			break;
+		n = _getshort(cp);
+		doprintf(("\t%s", itoa(n)))
+		cp += INT16SZ;
+
+		if (check_size(rname, type, cp, msg, eor, INT16SZ) < 0)
+			break;
+		n = _getshort(cp);
+		doprintf((" %s", itoa(n)))
+		cp += INT16SZ;
+
+		if (check_size(rname, type, cp, msg, eor, INT16SZ) < 0)
+			break;
+		n = _getshort(cp);
+		doprintf((" %s", itoa(n)))
+		cp += INT16SZ;
+
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf((" %s", pr_name(dname)))
+		cp += n;
+		break;
+
+	    case T_EID:
+	    case T_NIMLOC:
+	    case T_ATMA:
+		doprintf(("\t\"not yet implemented\""))
+		cp += dlen;
+		break;
+
+	    case T_NAPTR:
+		if (check_size(rname, type, cp, msg, eor, INT16SZ) < 0)
+			break;
+		n = _getshort(cp);
+		doprintf(("\t%s", itoa(n)))
+		cp += INT16SZ;
+
+		if (check_size(rname, type, cp, msg, eor, INT16SZ) < 0)
+			break;
+		n = _getshort(cp);
+		doprintf((" %s", itoa(n)))
+		cp += INT16SZ;
+
+		if (check_size(rname, type, cp, msg, eor, 1) < 0)
+			break;
+		n = *cp++;
+		doprintf((" \"%s\"", stoa(cp, n, true)))
+		cp += n;
+
+		if (check_size(rname, type, cp, msg, eor, 1) < 0)
+			break;
+		n = *cp++;
+		doprintf((" \"%s\"", stoa(cp, n, true)))
+		cp += n;
+
+		if (check_size(rname, type, cp, msg, eor, 1) < 0)
+			break;
+		n = *cp++;
+		doprintf((" \"%s\"", stoa(cp, n, true)))
+		cp += n;
+
+		n = expand_name(rname, type, cp, msg, eom, dname);
+		if (n < 0)
+			break;
+		doprintf((" %s", pr_name(dname)))
+		cp += n;
+		break;
+	    default:
+		doprintf(("\t\"???\""))
+		cp += dlen;
+		break;
+	}
+
+/*
+ * End of specific data type processing.
+ * Terminate resource record printout.
+ */
+	doprintf(("\n"))
+
+/*
+ * Check whether we have reached the exact end of this resource record.
+ * If not, we cannot be sure that the record has been decoded correctly,
+ * and therefore the subsequent tests will be skipped.
+ */
+	if (cp != eor)
+	{
+		pr_error("size error in %s record for %s, off by %s",
+			pr_type(type), rname, itoa(cp - eor));
+
+		/* we believe value of dlen; should perhaps return(NULL) */
+		return(eor);
+	}
+
+/*
+ * Save the CNAME alias for cname chain tracing.
+ * Save the MR or MG alias for MB chain tracing.
+ * These features can be enabled only in normal mode.
+ */
+	if (regular && classmatch)
+	{
+		if (type == T_CNAME)
+			cname = strcpy(cnamebuf, dname);
+
+		else if (type == T_MR || type == T_MG)
+			mname = strcpy(mnamebuf, dname);
+	}
+
+/*
+ * Suppress the subsequent checks in quiet mode.
+ * This can safely be done as there are no side effects.
+ * It may speedup things, and nothing would be printed anyway.
+ */
+	if (quiet)
+		return(cp);
+
+/*
+ * In zone listings, resource records with the same name/type/class
+ * must have the same ttl value. Maintain and check list of record info.
+ * This is done on a per-zone basis.
+ */
+	if (listing && !check_ttl(rname, type, class, ttl))
+	{
+		pr_warning("%s %s records have different ttl within %s from %s",
+			rname, pr_type(type), name, host);
+	}
+
+/*
+ * Check validity of 'host' related domain names in certain resource records.
+ * These include LHS record names and RHS domain names of selected records.
+ * Currently underscores are not reported during deep recursive listings.
+ */
+	if (test_valid(type) && !valid_name(rname, true, false, recurskip))
+	{
+		pr_warning("%s %s record has illegal name",
+			rname, pr_type(type));
+	}
+
+	if (test_canon(type) && !valid_name(dname, false, false, recurskip))
+	{
+		pr_warning("%s %s host %s has illegal name",
+			rname, pr_type(type), dname);
+	}
+
+/*
+ * The RHS of various resource records should refer to a canonical host name,
+ * i.e. it should exist and have an A record and not be a CNAME.
+ * Currently this test is suppressed during deep recursive zone listings.
+ */
+	if (!recurskip && test_canon(type) && ((n = check_canon(dname)) != 0))
+	{
+		/* only report definitive target host failures */
+		if (n == HOST_NOT_FOUND)
+			pr_warning("%s %s host %s does not exist",
+				rname, pr_type(type), dname);
+		else if (n == NO_DATA)
+			pr_warning("%s %s host %s has no A record",
+				rname, pr_type(type), dname);
+		else if (n == HOST_NOT_CANON)
+			pr_warning("%s %s host %s is not canonical",
+				rname, pr_type(type), dname);
+
+		/* authoritative failure to find nameserver target host */
+		if (type == T_NS && (n == NO_DATA || n == HOST_NOT_FOUND))
+		{
+			if (server == NULL)
+				errmsg("%s has lame delegation to %s",
+					rname, dname);
+		}
+	}
+
+/*
+ * On request, reverse map the address of an A record, and verify that
+ * it is registered and maps back to the name of the A record.
+ * Currently this option has effect here only during zone listings.
+ */
+	if (addrmode && ((type == T_A) && !reverse) && !fakeaddr(address))
+	{
+		host = mapreverse(rname, inaddr);
+		if (host == NULL)
+			pr_warning("%s address %s is not registered",
+				rname, inet_ntoa(inaddr));
+		else if (host != rname)
+			pr_warning("%s address %s maps to %s",
+				rname, inet_ntoa(inaddr), host);
+	}
+
+/*
+ * This record was processed successfully.
+ */
+	return(cp);
+}
+
+/*
+** SKIP_QREC -- Skip the query record in the nameserver answer buffer
+** ------------------------------------------------------------------
+**
+**	Returns:
+**		Pointer to position in answer buffer after current record.
+**		NULL if there was a format error in the current record.
+*/
+
+u_char *
+skip_qrec(name, qtype, qclass, cp, msg, eom)
+input char *name;			/* full name we are querying about */
+input int qtype;			/* record type we are querying about */
+input int qclass;			/* record class we are querying about */
+register u_char *cp;			/* current position in answer buf */
+input u_char *msg, *eom;		/* begin and end of answer buf */
+{
+	char rname[MAXDNAME+1];		/* record name in LHS */
+	int type, class;		/* fixed values in query record */
+	register int n;
+
+/*
+ * Pickup the standard values present in the query section.
+ */
+	n = expand_name(name, T_NONE, cp, msg, eom, rname);
+	if (n < 0)
+		return(NULL);
+	cp += n;
+
+	n = 2*INT16SZ;
+	if (check_size(rname, T_NONE, cp, msg, eom, n) < 0)
+		return(NULL);
+
+	type = _getshort(cp);
+	cp += INT16SZ;
+
+	class = _getshort(cp);
+	cp += INT16SZ;
+
+#ifdef lint
+	if (verbose)
+		printf("%-20s\t%s\t%s\n",
+			rname, pr_class(class), pr_type(type));
+#endif
+
+/*
+ * The values in the answer should match those in the query.
+ * If there is a mismatch, we just signal an error, but don't abort.
+ * For regular queries there is exactly one record in the query section.
+ */
+	if (!sameword(rname, name))
+		pr_error("invalid answer name %s after %s query for %s",
+			rname, pr_type(qtype), name);
+
+	if (type != qtype)
+		pr_error("invalid answer type %s after %s query for %s",
+			pr_type(type), pr_type(qtype), name);
+
+	if (class != qclass)
+		pr_error("invalid answer class %s after %s query for %s",
+			pr_class(class), pr_type(qtype), name);
+
+	return(cp);
+}
+
+/*
+** GET_RECURSIVE -- Wrapper for get_hostinfo() during recursion
+** ------------------------------------------------------------
+**
+**	Returns:
+**		true if requested info was obtained successfully.
+**		false otherwise.
+*/
+
+bool
+get_recursive(name)
+input char **name;			/* name to query about */
+{
+	static int level = 0;		/* recursion level */
+	char newnamebuf[MAXDNAME+1];
+	char *newname;			/* new name to look up */
+	bool result;			/* result status of action taken */
+	int save_errno;
+	int save_herrno;
+
+	if (level > MAXCHAIN)
+	{
+		errmsg("Recursion too deep");
+		return(false);
+	}
+
+	/* save local copy, and reset indicator */
+	newname = strcpy(newnamebuf, *name);
+	*name = NULL;
+
+	save_errno = errno;
+	save_herrno = h_errno;
+
+	level++;
+	result = get_hostinfo(newname, true);
+	level--;
+
+	errno = save_errno;
+	h_errno = save_herrno;
+
+	return(result);
+}
+
+
+/*
+ * Nameserver information.
+ * Stores names and addresses of all servers that are to be queried
+ * for a zone transfer of the desired zone. Normally these are the
+ * authoritative primary and/or secondary nameservers for the zone.
+ */
+
+char nsname[MAXNSNAME][MAXDNAME+1];		/* nameserver host name */
+struct in_addr ipaddr[MAXNSNAME][MAXIPADDR];	/* nameserver addresses */
+int naddrs[MAXNSNAME];				/* count of addresses */
+int nservers = 0;				/* count of nameservers */
+
+bool authserver;		/* server is supposed to be authoritative */
+bool lameserver;		/* server could not provide SOA service */
+
+/*
+ * Host information.
+ * Stores names and (single) addresses encountered during the zone listing
+ * of all A records that belong to the zone. Non-authoritative glue records
+ * that do not belong to the zone are not stored. Glue records that belong
+ * to a delegated zone will be filtered out later during the host count scan.
+ * The host names are allocated dynamically.
+ * The list itself is also allocated dynamically, to avoid static limits,
+ * and to keep the initial bss of the executable to a reasonable size.
+ * Allocation is done in chunks, to reduce considerable malloc overhead.
+ * Note that the list will not shrink during recursive processing.
+ */
+
+typedef struct host_data {
+	char *hd_hostname;	/* host name of host in zone */
+	ipaddr_t hd_hostaddr;	/* first host address */
+	bool hd_multaddr;	/* set if this is a multiple address host */
+} host_data_t;
+
+host_data_t *hostlist = NULL;	/* info on hosts in zone */
+int hostcount = 0;		/* count of hosts in zone */
+
+int maxhosts = 0;		/* number of allocated hostlist entries */
+
+#define MAXHOSTINCR	4096	/* chunk size to increment hostlist */
+
+#define hostname(i)	hostlist[i].hd_hostname
+#define hostaddr(i)	hostlist[i].hd_hostaddr
+#define multaddr(i)	hostlist[i].hd_multaddr
+
+/*
+ * Delegated zone information.
+ * Stores the names of the delegated zones encountered during the zone
+ * listing. The names and the list itself are allocated dynamically.
+ */
+
+char **zonename = NULL;		/* names of delegated zones within zone */
+int zonecount = 0;		/* count of delegated zones within zone */
+
+/*
+ * Address information.
+ * Stores the (single) addresses of hosts found in all zones traversed.
+ * Used to search for duplicate hosts (same address but different name).
+ * The list of addresses is allocated dynamically, and remains allocated.
+ * This has now been implemented as a hashed list, using the low-order
+ * address bits as the hash key.
+ */
+
+/*
+ * SOA record information.
+ */
+
+soa_data_t soa;			/* buffer to store soa data */
+
+int soacount = 0;		/* count of SOA records during listing */
+
+/*
+ * Nameserver preference.
+ * As per BIND 4.9.* resource records may be returned after round-robin
+ * reshuffling each time they are retrieved. For NS records, this may
+ * lead to an unfavorable order for doing zone transfers.
+ * We apply some heuristic to sort the NS records according to their
+ * preference with respect to a given list of preferred server domains.
+ */
+
+int nsrank[MAXNSNAME];		/* nameserver ranking after sorting */
+int nspref[MAXNSNAME];		/* nameserver preference value */
+
+/*
+** LIST_ZONE -- Basic routine to do complete zone listing and checking
+** -------------------------------------------------------------------
+**
+**	Returns:
+**		true if the requested info was processed successfully.
+**		false otherwise.
+*/
+
+int total_calls = 0;		/* number of calls for zone processing */
+int total_check = 0;		/* number of zones successfully processed */
+int total_tries = 0;		/* number of zone transfer attempts */
+int total_zones = 0;		/* number of successful zone transfers */
+int total_hosts = 0;		/* number of hosts in all traversed zones */
+int total_dupls = 0;		/* number of duplicates in all zones */
+
+char longname[MAXDNAME+1];	/* longest host name found */
+int longsize = 0;		/* size of longest host name */
+
+bool
+list_zone(name)
+input char *name;			/* name of zone to process */
+{
+	register int n;
+	register int i;
+	int nzones;			/* count of delegated zones */
+	int nhosts;			/* count of real host names */
+	int ndupls;			/* count of duplicate hosts */
+	int nextrs;			/* count of extrazone hosts */
+	int ngates;			/* count of gateway hosts */
+
+	total_calls += 1;		/* update zone processing calls */
+
+/*
+ * Normalize to not have trailing dot, unless it is the root zone.
+ */
+	n = strlength(name);
+	if (n > 1 && name[n-1] == '.')
+		name[n-1] = '\0';
+
+/*
+ * Indicate whether we are processing an in-addr.arpa reverse zone.
+ * In this case we will suppress accumulating host count statistics.
+ */
+	reverse = indomain(name, ARPA_ROOT, false);
+
+/*
+ * Suppress various checks if working beyond the recursion skip level.
+ * This affects processing in print_rrec(). It may need refinement.
+ */
+	recurskip = ((recursion_level > skip_level) && !addrmode) ? true : false;
+
+/*
+ * Find the nameservers for the given zone.
+ */
+	(void) find_servers(name);
+
+	if (nservers < 1)
+	{
+		errmsg("No nameservers for %s found", name);
+		return(false);
+	}
+
+/*
+ * Make sure we have an address for at least one nameserver.
+ */
+	for (n = 0; n < nservers; n++)
+		if (naddrs[n] > 0)
+			break;
+
+	if (n >= nservers)
+	{
+		errmsg("No addresses of nameservers for %s found", name);
+		return(false);
+	}
+
+/*
+ * Without an explicit server on the command line, the servers we
+ * have looked up are supposed to be authoritative for the zone.
+ */
+	authserver = (server && !primary) ? false : true;
+
+/*
+ * Check SOA records at each of the nameservers if so requested.
+ */
+	if (checkmode)
+	{
+		do_check(name);
+
+		total_check += 1;	/* update zones processed */
+
+		/* all done if maximum recursion level reached */
+		if (!recursive || (recursion_level >= recursive))
+			return((errorcount == 0) ? true : false);
+	}
+
+/*
+ * The zone transfer for certain zones can be skipped.
+ * Currently this must be indicated on the command line.
+ */
+	if (skip_transfer(name))
+	{
+		if (verbose || statistics || checkmode || hostmode)
+			printf("Skipping zone transfer for %s\n", name);
+		return(false);
+	}
+
+/*
+ * Ask zone transfer to the nameservers, until one responds.
+ */
+	total_tries += 1;		/* update zone transfer attempts */
+
+	if (!do_transfer(name))
+		return(false);
+
+	total_zones += 1;		/* update successful zone transfers */
+
+/*
+ * Print resource record statistics if so requested.
+ */
+	if (statistics)
+		print_statistics(name, querytype, queryclass);
+
+/*
+ * Accumulate host count statistics for this zone.
+ * Do this only in modes in which such output would be printed.
+ */
+	nzones = zonecount;
+
+	nhosts = 0, ndupls = 0, nextrs = 0, ngates = 0;
+
+	i = (verbose || statistics || hostmode) ? 0 : hostcount;
+
+	for (n = i; n < hostcount; n++)
+	{
+		/* skip fake hosts using a very rudimentary test */
+		if (fakename(hostname(n)) || fakeaddr(hostaddr(n)))
+			continue;
+		/* save longest host name encountered so far */
+		if (verbose && ((i = strlength(hostname(n))) > longsize))
+		{
+			longsize = i;
+			(void) strcpy(longname, hostname(n));
+		}
+		/* skip apparent glue records */
+		if (gluerecord(hostname(n), name, zonename, nzones))
+		{
+			if (verbose > 1)
+				printf("%s is glue record\n", hostname(n));
+			continue;
+		}
+
+		/* otherwise count as host */
+		nhosts++;
+
+	/*
+	 * Mark hosts not residing directly in the zone as extrazone host.
+	 */
+		if (!samedomain(hostname(n), name, true))
+		{
+			nextrs++;
+			if (extrmode || (verbose > 1))
+				printf("%s is extrazone host\n", hostname(n));
+		}
+
+	/*
+	 * Mark hosts with more than one address as gateway host.
+	 * These are not checked for duplicate addresses.
+	 */
+		if (multaddr(n))
+		{
+			ngates++;
+			if (gatemode || (verbose > 1))
+				printf("%s is gateway host\n", hostname(n));
+		}
+		
+	/*
+	 * Compare single address hosts against global list of addresses.
+	 * Multiple address hosts are too complicated to handle this way.
+	 */
+		else if (check_dupl(hostaddr(n)))
+		{
+			struct in_addr inaddr;
+			inaddr.s_addr = hostaddr(n);
+
+			ndupls++;
+			if (duplmode || (verbose > 1))
+				printf("%s is duplicate host with address %s\n",
+					hostname(n), inet_ntoa(inaddr));
+		}
+	}
+
+/*
+ * Print statistics for this zone.
+ */
+	if (verbose || statistics || hostmode)
+	{
+		printf("Found %d host%s within %s\n",
+			nhosts, plural(nhosts), name);
+
+	    if ((ndupls > 0) || duplmode || (verbose > 1))
+		printf("Found %d duplicate host%s within %s\n",
+			ndupls, plural(ndupls), name);
+
+	    if ((nextrs > 0) || extrmode || (verbose > 1))
+		printf("Found %d extrazone host%s within %s\n",
+			nextrs, plural(nextrs), name);
+
+	    if ((ngates > 0) || gatemode || (verbose > 1))
+		printf("Found %d gateway host%s within %s\n",
+			ngates, plural(ngates), name);
+	}
+
+	total_hosts += nhosts;		/* update total number of hosts */
+	total_dupls += ndupls;		/* update total number of duplicates */
+
+	if (!checkmode)
+		total_check += 1;	/* update zones processed */
+
+	if (verbose || statistics)
+		printf("Found %d delegated zone%s within %s\n",
+			nzones, plural(nzones), name);
+
+/*
+ * Sort the encountered delegated zones alphabetically.
+ * Note that this precludes further use of the zone_index() function.
+ */
+	if ((nzones > 1) && (recursive || listzones || mxdomains))
+		qsort((ptr_t *)zonename, nzones, sizeof(char *), compare_name);
+
+/*
+ * The names of the hosts were allocated dynamically.
+ */
+	for (n = 0; n < hostcount; n++)
+		xfree(hostname(n));
+
+/*
+ * Check for mailable delegated zones within this zone.
+ * This is based on ordinary MX lookup, and not on the MX info
+ * which may be present in the zone listing, to reduce zone transfers.
+ */
+	if (mxdomains)
+	{
+		if (recursion_level == 0)
+		{
+			if (verbose)
+				printf("\n");
+
+			if (!get_mxrec(name))
+				ns_error(name, T_MX, queryclass, server);
+		}
+
+		for (n = 0; n < nzones; n++)
+		{
+			if (verbose)
+				printf("\n");
+
+			if (!get_mxrec(zonename[n]))
+				ns_error(zonename[n], T_MX, queryclass, server);
+		}
+	}
+
+/*
+ * Do recursion on delegated zones if requested and any were found.
+ * Temporarily save zonename list, and force allocation of new list.
+ */
+	if (recursive && (recursion_level < recursive))
+	{
+		for (n = 0; n < nzones; n++)
+		{
+			char **newzone;		/* local copy of list */
+
+			newzone = zonename;
+			zonename = NULL;	/* allocate new list */
+
+			if (verbose || statistics || checkmode || hostmode)
+				printf("\n");
+
+			if (listzones)
+			{
+				for (i = 0; i <= recursion_level; i++)
+					printf("%s", (i == 0) ? "\t" : "  ");
+				printf("%s\n", newzone[n]);
+			}
+
+			if (verbose)
+				printf("Entering zone %s\n", newzone[n]);
+
+			recursion_level++;
+			(void) list_zone(newzone[n]);
+			recursion_level--;
+
+			zonename = newzone;	/* restore */
+		}
+	}
+	else if (listzones)
+	{
+		for (n = 0; n < nzones; n++)
+		{
+			for (i = 0; i <= recursion_level; i++)
+				printf("%s", (i == 0) ? "\t" : "  ");
+			printf("%s\n", zonename[n]);
+		}
+	}
+
+/*
+ * The names of the delegated zones were allocated dynamically.
+ * The list of delegated zone names was also allocated dynamically.
+ */
+	for (n = 0; n < nzones; n++)
+		xfree(zonename[n]);
+
+	if (zonename != NULL)
+		xfree(zonename);
+
+	zonename = NULL;
+
+/*
+ * Print final overall statistics.
+ */
+	if (recursive && (recursion_level == 0))
+	{
+		if (verbose || statistics || checkmode || hostmode)
+			printf("\n");
+
+		if (verbose || statistics || hostmode)
+			printf("Encountered %d host%s in %d zone%s within %s\n",
+				total_hosts, plural(total_hosts),
+				total_zones, plural(total_zones),
+				name);
+
+		if (verbose || statistics || hostmode)
+			printf("Encountered %d duplicate host%s in %d zone%s within %s\n",
+				total_dupls, plural(total_dupls),
+				total_zones, plural(total_zones),
+				name);
+
+		if (verbose || statistics || checkmode)
+			printf("Transferred %d zone%s out of %d attempt%s\n",
+				total_zones, plural(total_zones),
+				total_tries, plural(total_tries));
+
+		if (verbose || statistics || checkmode)
+			printf("Processed %d zone%s out of %d request%s\n",
+				total_check, plural(total_check),
+				total_calls, plural(total_calls));
+		if (verbose && (longsize > 0))
+			printf("Longest hostname %s\t%d\n",
+				longname, longsize);
+	}
+
+	/* indicate whether any errors were encountered */
+	return((errorcount == 0) ? true : false);
+}
+
+/*
+** FIND_SERVERS -- Fetch names and addresses of authoritative servers
+** ------------------------------------------------------------------
+**
+**	Returns:
+**		true if servers could be determined successfully.
+**		false otherwise.
+**
+**	Inputs:
+**		The global variable ``server'', if set, contains the
+**		name of the explicit server to be contacted.
+**		The global variable ``primary'', if set, indicates
+**		that we must use the primary nameserver for the zone.
+**		If both are set simultaneously, the explicit server
+**		is contacted to retrieve the desired servers.
+**
+**	Outputs:
+**		The count of nameservers is stored in ``nservers''.
+**		Names are stored in the nsname[] database.
+**		Addresses are stored in the ipaddr[] database.
+**		Address counts are stored in the naddrs[] database.
+*/
+
+bool
+find_servers(name)
+input char *name;			/* name of zone to find servers for */
+{
+	struct hostent *hp;
+	register int n, i;
+
+/*
+ * Use the explicit server if given on the command line.
+ * Its addresses are stored in the resolver state struct.
+ * This server may not be authoritative for the given zone.
+ */
+	if (server && !primary)
+	{
+		(void) strcpy(nsname[0], server);
+
+		for (i = 0; i < MAXIPADDR && i < _res.nscount; i++)
+			ipaddr[0][i] = nslist(i).sin_addr;
+		naddrs[0] = i;
+
+		nservers = 1;
+		return(true);
+	}
+
+/*
+ * Fetch primary nameserver info if so requested.
+ * Get its name from the SOA record for the zone, and do a regular
+ * host lookup to fetch its addresses. We are assuming here that the
+ * SOA record is a proper one. This is not necessarily true.
+ * Obviously this server should be authoritative.
+ */
+	if (primary && !server)
+	{
+		char *primaryname;
+
+		primaryname = get_primary(name);
+		if (primaryname == NULL)
+		{
+			ns_error(name, T_SOA, queryclass, server);
+			nservers = 0;
+			return(false);
+		}
+
+		hp = geth_byname(primaryname);
+		if (hp == NULL)
+		{
+			ns_error(primaryname, T_A, C_IN, server);
+			nservers = 0;
+			return(false);
+		}
+
+		primaryname = strncpy(nsname[0], hp->h_name, MAXDNAME);
+		primaryname[MAXDNAME] = '\0';
+
+		for (i = 0; i < MAXIPADDR && hp->h_addr_list[i]; i++)
+			ipaddr[0][i] = incopy(hp->h_addr_list[i]);
+		naddrs[0] = i;
+
+		if (verbose)
+			printf("Found %d address%s for %s\n",
+				naddrs[0], plurale(naddrs[0]), nsname[0]);
+		nservers = 1;
+		return(true);
+	}
+
+/*
+ * Otherwise we have to find the nameservers for the zone.
+ * These are supposed to be authoritative, but sometimes we
+ * encounter lame delegations, perhaps due to misconfiguration.
+ */
+	if (!get_servers(name))
+	{
+		ns_error(name, T_NS, queryclass, server);
+		nservers = 0;
+		return(false);
+	}
+
+/*
+ * Usually we'll get addresses for all the servers in the additional
+ * info section.  But in case we don't, look up their addresses.
+ * Addresses could be missing because there is no room in the answer.
+ * No address is present if the name of a server is not canonical.
+ * If we get no addresses by extra query, and this is authoritative,
+ * we flag a lame delegation to that server.
+ */
+	for (n = 0; n < nservers; n++)
+	{
+	    if (naddrs[n] == 0)
+	    {
+		hp = geth_byname(nsname[n]);
+		if (hp != NULL)
+		{
+			for (i = 0; i < MAXIPADDR && hp->h_addr_list[i]; i++)
+				ipaddr[n][i] = incopy(hp->h_addr_list[i]);
+			naddrs[n] = i;
+		}
+
+		if (verbose)
+			printf("Found %d address%s for %s by extra query\n",
+				naddrs[n], plurale(naddrs[n]), nsname[n]);
+
+		if (hp == NULL)
+		{
+			/* server name lookup failed */
+			ns_error(nsname[n], T_A, C_IN, server);
+
+			/* authoritative denial: probably misconfiguration */
+			if (h_errno == NO_DATA || h_errno == HOST_NOT_FOUND)
+			{
+				if (server == NULL)
+					errmsg("%s has lame delegation to %s",
+						name, nsname[n]);
+			}
+		}
+
+		if ((hp != NULL) && !sameword(hp->h_name, nsname[n]))
+			pr_warning("%s nameserver %s is not canonical (%s)",
+				name, nsname[n], hp->h_name);
+	    }
+	    else
+	    {
+		if (verbose)
+			printf("Found %d address%s for %s\n",
+				naddrs[n], plurale(naddrs[n]), nsname[n]);
+	    }
+	}
+
+/*
+ * Issue warning if only one server has been discovered.
+ * This is not an error per se, but not much redundancy in that case.
+ */
+	if (nservers == 1)
+		pr_warning("%s has only one nameserver %s",
+			name, nsname[0]);
+
+	return((nservers > 0) ? true : false);
+}
+
+/*
+** GET_SERVERS -- Fetch names and addresses of authoritative servers
+** -----------------------------------------------------------------
+**
+**	Returns:
+**		true if servers could be determined successfully.
+**		false otherwise.
+**
+**	Side effects:
+**		The count of nameservers is stored in ``nservers''.
+**		Names are stored in the nsname[] database.
+**		Addresses are stored in the ipaddr[] database.
+**		Address counts are stored in the naddrs[] database.
+*/
+
+bool
+get_servers(name)
+input char *name;			/* name of zone to find servers for */
+{
+	querybuf answer;
+	register int n;
+	bool result;			/* result status of action taken */
+
+	if (verbose)
+		printf("Finding nameservers for %s ...\n", name);
+
+	n = get_info(&answer, name, T_NS, queryclass);
+	if (n < 0)
+		return(false);
+
+	if (verbose > 1)
+		(void) print_info(&answer, n, name, T_NS, queryclass, false);
+
+	result = get_nsinfo(&answer, n, name);
+	return(result);
+}
+
+/*
+** GET_NSINFO -- Extract nameserver data from nameserver answer buffer
+** -------------------------------------------------------------------
+**
+**	Returns:
+**		true if the answer buffer was processed successfully.
+**		false otherwise.
+**
+**	Outputs:
+**		The count of nameservers is stored in ``nservers''.
+**		Names are stored in the nsname[] database.
+**		Addresses are stored in the ipaddr[] database.
+**		Address counts are stored in the naddrs[] database.
+*/
+
+bool
+get_nsinfo(answerbuf, answerlen, name)
+input querybuf *answerbuf;		/* location of answer buffer */
+input int answerlen;			/* length of answer buffer */
+input char *name;			/* name of zone to find servers for */
+{
+	HEADER *bp;
+	int qdcount, ancount, nscount, arcount, rrcount;
+	u_char *msg, *eom;
+	register u_char *cp;
+	register int i;
+
+	nservers = 0;			/* count of nameservers */
+
+	bp = (HEADER *)answerbuf;
+	qdcount = ntohs(bp->qdcount);
+	ancount = ntohs(bp->ancount);
+	nscount = ntohs(bp->nscount);
+	arcount = ntohs(bp->arcount);
+
+	msg = (u_char *)answerbuf;
+	eom = (u_char *)answerbuf + answerlen;
+	cp  = (u_char *)answerbuf + HFIXEDSZ;
+
+	if (qdcount > 0 && cp < eom)	/* should be exactly one record */
+	{
+		cp = skip_qrec(name, T_NS, queryclass, cp, msg, eom);
+		if (cp == NULL)
+			return(false);
+		qdcount--;
+	}
+
+	if (qdcount)
+	{
+		pr_error("invalid qdcount after %s query for %s",
+			pr_type(T_NS), name);
+		h_errno = NO_RECOVERY;
+		return(false);
+	}
+
+/*
+ * If the answer is authoritative, the names are found in the
+ * answer section, and the nameserver section is empty.
+ * If not, there may be duplicate names in both sections.
+ * Addresses are found in the additional info section both cases.
+ */
+	rrcount = ancount + nscount + arcount;
+	while (rrcount > 0 && cp < eom)
+	{
+		char rname[MAXDNAME+1];
+		char dname[MAXDNAME+1];
+		int type, class, ttl, dlen;
+		u_char *eor;
+		register int n;
+		struct in_addr inaddr;
+
+		n = expand_name(name, T_NONE, cp, msg, eom, rname);
+		if (n < 0)
+			return(false);
+		cp += n;
+
+		n = 3*INT16SZ + INT32SZ;
+		if (check_size(rname, T_NONE, cp, msg, eom, n) < 0)
+			return(false);
+
+		type = _getshort(cp);
+		cp += INT16SZ;
+
+		class = _getshort(cp);
+		cp += INT16SZ;
+
+		ttl = _getlong(cp);
+		cp += INT32SZ;
+
+		dlen = _getshort(cp);
+		cp += INT16SZ;
+
+		eor = cp + dlen;
+#ifdef lint
+		if (verbose)
+			printf("%-20s\t%d\t%s\t%s\n",
+				rname, ttl, pr_class(class), pr_type(type));
+#endif
+		if ((type == T_NS) && sameword(rname, name))
+		{
+			n = expand_name(rname, type, cp, msg, eom, dname);
+			if (n < 0)
+				return(false);
+			cp += n;
+
+			for (i = 0; i < nservers; i++)
+				if (sameword(nsname[i], dname))
+					break;	/* duplicate */
+
+			if (i >= nservers && nservers < MAXNSNAME)
+			{
+				(void) strcpy(nsname[nservers], dname);
+				naddrs[nservers] = 0;
+				nservers++;
+			}
+		}
+		else if ((type == T_A) && (dlen == INADDRSZ))
+		{
+			for (i = 0; i < nservers; i++)
+				if (sameword(nsname[i], rname))
+					break;	/* found */
+
+			if (i < nservers && naddrs[i] < MAXIPADDR)
+			{
+				bcopy((char *)cp, (char *)&inaddr, INADDRSZ);
+				ipaddr[i][naddrs[i]] = inaddr;
+				naddrs[i]++;
+			}
+
+			cp += dlen;
+		}
+		else
+		{
+			/* just ignore other records */
+			cp += dlen;
+		}
+
+		if (cp != eor)
+		{
+			pr_error("size error in %s record for %s, off by %s",
+				pr_type(type), rname, itoa(cp - eor));
+			h_errno = NO_RECOVERY;
+			return(false);
+		}
+
+		rrcount--;
+	}
+
+	if (rrcount)
+	{
+		pr_error("invalid rrcount after %s query for %s",
+			pr_type(T_NS), name);
+		h_errno = NO_RECOVERY;
+		return(false);
+	}
+
+	/* set proper status if no answers found */
+	h_errno = (nservers > 0) ? 0 : TRY_AGAIN;
+	return(true);
+}
+
+/*
+** SORT_SERVERS -- Sort set of nameservers according to preference
+** ---------------------------------------------------------------
+**
+**	Returns:
+**		None.
+**
+**	Inputs:
+**		Set of nameservers as determined by find_servers().
+**		The global variable ``prefserver'', if set, contains
+**		a list of preferred server domains to compare against.
+**
+**	Outputs:
+**		Stores the preferred nameserver order in nsrank[].
+*/
+
+void
+sort_servers()
+{
+	register int i, j;
+	register int n, pref;
+	register char *p, *q;
+
+/*
+ * Initialize the default ranking.
+ */
+	for (n = 0; n < nservers; n++)
+	{
+		nsrank[n] = n;
+		nspref[n] = 0;
+	}
+
+/*
+ * Determine the nameserver preference.
+ * Compare against a list of comma-separated preferred server domains.
+ * Use the maximum value of all comparisons.
+ */
+	for (q = NULL, p = prefserver; p != NULL; p = q)
+	{
+		q = index(p, ',');
+		if (q != NULL)
+			*q = '\0';
+
+		for (n = 0; n < nservers; n++)
+		{
+			pref = matchlabels(nsname[n], p);
+			if (pref > nspref[n])
+				nspref[n] = pref;
+		}
+
+		if (q != NULL)
+			*q++ = ',';
+	}
+
+/*
+ * Sort the set according to preference.
+ * Keep the rest as much as possible in original order.
+ */
+	for (i = 0; i < nservers; i++)
+	{
+		for (j = i + 1; j < nservers; j++)
+		{
+			if (nspref[j] > nspref[i])
+			{
+				pref = nspref[j];
+				/* nspref[j] = nspref[i]; */
+				for (n = j; n > i; n--)
+					nspref[n] = nspref[n-1];
+				nspref[i] = pref;
+
+				pref = nsrank[j];
+				/* nsrank[j] = nsrank[i]; */
+				for (n = j; n > i; n--)
+					nsrank[n] = nsrank[n-1];
+				nsrank[i] = pref;
+			}
+		}
+	}
+}
+
+/*
+** SKIP_TRANSFER -- Check whether a zone transfer should be skipped
+** ----------------------------------------------------------------
+**
+**	Returns:
+**		true if a transfer for this zone should be skipped.
+**		false if the zone transfer should proceed.
+**
+**	Inputs:
+**		The global variable ``skipzone'', if set, contains
+**		a list of zone names to be skipped.
+**
+**	Certain zones are known to contain bogus information, and
+**	can be requested to be excluded from further processing.
+**	The zone transfer for such zones and its delegated zones
+**	will be skipped.
+*/
+
+bool
+skip_transfer(name)
+input char *name;			/* name of zone to process */
+{
+	register char *p, *q;
+	bool skip = false;
+
+	for (q = NULL, p = skipzone; p != NULL; p = q)
+	{
+		q = index(p, ',');
+		if (q != NULL)
+			*q = '\0';
+
+		if (sameword(name, p))
+			skip = true;
+
+		if (q != NULL)
+			*q++ = ',';
+	}
+
+	return(skip);
+}
+
+/*
+** DO_CHECK -- Check SOA records at each of the nameservers
+** --------------------------------------------------------
+**
+**	Returns:
+**		None.
+**
+**	Inputs:
+**		The count of nameservers is stored in ``nservers''.
+**		Names are stored in the nsname[] database.
+**		Addresses are stored in the ipaddr[] database.
+**		Address counts are stored in the naddrs[] database.
+**
+**	The SOA record of the zone is checked at each nameserver.
+**	Nameserver recursion is turned off to make sure that the
+**	answer is authoritative.
+*/
+
+void
+do_check(name)
+input char *name;			/* name of zone to process */
+{
+	res_state_t save_res;		/* saved copy of resolver database */
+	char *save_server;		/* saved copy of server name */
+	register int n;
+	register int i;
+
+	/* save resolver database */
+	save_res = _res;
+	save_server = server;
+
+	/* turn off nameserver recursion */
+	_res.options &= ~RES_RECURSE;
+
+	for (n = 0; n < nservers; n++)
+	{
+		if (naddrs[n] < 1)
+			continue;	/* shortcut */
+
+		server = nsname[n];
+		for (i = 0; i < MAXNS && i < naddrs[n]; i++)
+		{
+			nslist(i).sin_family = AF_INET;
+			nslist(i).sin_port = htons(NAMESERVER_PORT);
+			nslist(i).sin_addr = ipaddr[n][i];
+		}
+		_res.nscount = i;
+
+		/* retrieve and check SOA */
+		if (check_zone(name))
+			continue;
+
+		/* SOA query failed */
+		ns_error(name, T_SOA, queryclass, server);
+
+		/* explicit server failure: possibly data expired */
+		lameserver = (h_errno == SERVER_FAILURE) ? true : false;
+
+		/* non-authoritative denial: assume lame delegation */
+		if (h_errno == NO_RREC || h_errno == NO_HOST)
+			lameserver = true;
+
+		/* authoritative denial: probably misconfiguration */
+		if (h_errno == NO_DATA || h_errno == HOST_NOT_FOUND)
+			lameserver = true;
+
+		/* flag an error if server should not have failed */
+		if (lameserver && authserver)
+			errmsg("%s has lame delegation to %s",
+				name, server);
+	}
+
+	/* restore resolver database */
+	_res = save_res;
+	server = save_server;
+}
+
+/*
+** DO_TRANSFER -- Perform a zone transfer from any of its nameservers
+** ------------------------------------------------------------------
+**
+**	Returns:
+**		true if the zone data have been retrieved successfully.
+**		false if none of the servers responded.
+**
+**	Inputs:
+**		The count of nameservers is stored in ``nservers''.
+**		Names are stored in the nsname[] database.
+**		Addresses are stored in the ipaddr[] database.
+**		Address counts are stored in the naddrs[] database.
+**
+**	Ask zone transfer to the nameservers, until one responds.
+**	The list of nameservers is sorted according to preference.
+**	An authoritative server should always respond positively.
+**	If it responds with an error, we may have a lame delegation.
+**	Always retry with the next server to avoid missing entire zones.
+*/
+
+bool
+do_transfer(name)
+input char *name;			/* name of zone to do zone xfer for */
+{
+	register int n, ns;
+	register int i;
+
+	for (sort_servers(), ns = 0; ns < nservers; ns++)
+	{
+	    for (n = nsrank[ns], i = 0; i < naddrs[n]; i++)
+	    {
+		if (verbose)
+			printf("Trying server %s (%s) ...\n",
+				inet_ntoa(ipaddr[n][i]), nsname[n]);
+
+		if (transfer_zone(name, ipaddr[n][i], nsname[n]))
+			goto done;	/* double break */
+
+		/* zone transfer failed */
+		if ((h_errno != TRY_AGAIN) || verbose)
+			ns_error(name, T_AXFR, queryclass, nsname[n]);
+
+		/* zone transfer request was explicitly refused */
+		if (h_errno == QUERY_REFUSED)
+			break;
+
+		/* explicit server failure: possibly data expired */
+		lameserver = (h_errno == SERVER_FAILURE) ? true : false;
+
+		/* non-authoritative denial: assume lame delegation */
+		if (h_errno == NO_RREC || h_errno == NO_HOST)
+			lameserver = true;
+
+		/* authoritative denial: probably misconfiguration */
+		if (h_errno == NO_DATA || h_errno == HOST_NOT_FOUND)
+			lameserver = true;
+
+		/* flag an error if server should not have failed */
+		if (lameserver && authserver)
+			errmsg("%s has lame delegation to %s",
+				name, nsname[n]);
+
+		/* try next server if this one is sick */
+		if (lameserver)
+			break;
+
+		/* terminate on irrecoverable errors */
+		if (h_errno != TRY_AGAIN)
+			return(false);
+
+		/* in case nameserver not present */
+		if (errno == ECONNREFUSED)
+			break;
+	    }
+	}
+done:
+	if (ns >= nservers)
+	{
+		if ((h_errno == TRY_AGAIN) && !verbose)
+			ns_error(name, T_AXFR, queryclass, (char *)NULL);
+		errmsg("No nameservers for %s responded", name);
+		return(false);
+	}
+
+	return(true);
+}
+
+/*
+** TRANSFER_ZONE -- Wrapper for get_zone() to hide administrative tasks
+** --------------------------------------------------------------------
+**
+**	Returns:
+**		See get_zone() for details.
+**
+**	Side effects:
+**		See get_zone() for details.
+**
+**	This routine may be called repeatedly with different server
+**	addresses, until one of the servers responds. Various items
+**	must be reset on every try to continue with a clean slate.
+*/
+
+bool
+transfer_zone(name, inaddr, host)
+input char *name;			/* name of zone to do zone xfer for */
+input struct in_addr inaddr;		/* address of server to be queried */
+input char *host;			/* name of server to be queried */
+{
+	register int n;
+
+/*
+ * Reset the resource record statistics before each try.
+ */
+	clear_statistics();
+
+/*
+ * Reset the hash tables of saved resource record information.
+ * These tables are used only during the zone transfer itself.
+ */
+	clear_ttltab();
+	clear_hosttab();
+	clear_zonetab();
+
+/*
+ * Perform the actual zone transfer.
+ * All error reporting is done by get_zone().
+ */
+	if (get_zone(name, inaddr, host))
+		return(true);
+
+/*
+ * Failure to get the zone. Free any memory that may have been allocated.
+ * On success it is the responsibility of the caller to free the memory.
+ * The information gathered is used by list_zone() after the zone transfer.
+ */
+	for (n = 0; n < hostcount; n++)
+		xfree(hostname(n));
+
+	for (n = 0; n < zonecount; n++)
+		xfree(zonename[n]);
+
+	if (zonename != NULL)
+		xfree(zonename);
+
+	zonename = NULL;
+
+	return(false);
+}
+
+/*
+** GET_ZONE -- Perform a zone transfer from server at specific address
+** -------------------------------------------------------------------
+**
+**	Returns:
+**		true if the zone data have been retrieved successfully.
+**		false if an error occurred (h_errno is set appropriately).
+**		Set TRY_AGAIN wherever possible to try the next server.
+**
+**	Side effects:
+**		Stores list of delegated zones found in zonename[],
+**		and the count of delegated zones in ``zonecount''.
+**		Stores list of host names found in hostname[],
+**		and the count of host names in ``hostcount''.
+**		Updates resource record statistics in record_stats[].
+**		This array must have been cleared before.
+*/
+
+bool
+get_zone(name, inaddr, host)
+input char *name;			/* name of zone to do zone xfer for */
+input struct in_addr inaddr;		/* address of server to be queried */
+input char *host;			/* name of server to be queried */
+{
+	querybuf query;
+	querybuf answer;
+	HEADER *bp;
+	int ancount;
+	int sock;
+	struct sockaddr_in sin;
+	register int n, i;
+	int nrecords = 0;		/* number of records processed */
+	int npackets = 0;		/* number of packets received */
+
+	/* clear global counts */
+	soacount = 0;			/* count of SOA records */
+	zonecount = 0;			/* count of delegated zones */
+	hostcount = 0;			/* count of host names */
+
+/*
+ * Construct query, and connect to the given server.
+ */
+	errno = 0;	/* reset before querying nameserver */
+
+	n = res_mkquery(QUERY, name, queryclass, T_AXFR, (qbuf_t *)NULL, 0,
+			(rrec_t *)NULL, (qbuf_t *)&query, sizeof(querybuf));
+	if (n < 0)
+	{
+		if (debug)
+			printf("%sres_mkquery failed\n", dbprefix);
+		h_errno = NO_RECOVERY;
+		return(false);
+	}
+
+	if (debug)
+	{
+		printf("%sget_zone()\n", dbprefix);
+		pr_query((qbuf_t *)&query, n, stdout);
+	}
+
+	/* setup destination address */
+	bzero((char *)&sin, sizeof(sin));
+
+	sin.sin_family = AF_INET;
+	sin.sin_port = htons(NAMESERVER_PORT);
+	sin.sin_addr = inaddr;
+
+	sock = socket(AF_INET, SOCK_STREAM, 0);
+	if (sock < 0)
+	{
+		_res_perror(&sin, host, "socket");
+		h_errno = TRY_AGAIN;
+		return(false);
+	}
+
+	if (_res_connect(sock, &sin, sizeof(sin)) < 0)
+	{
+		if (verbose || debug)
+			_res_perror(&sin, host, "connect");
+		(void) close(sock);
+		h_errno = TRY_AGAIN;
+		return(false);
+	}
+
+	if (verbose)
+		printf("Asking zone transfer for %s ...\n", name);
+
+/*
+ * Send the query buffer.
+ */
+	if (_res_write(sock, &sin, host, (char *)&query, n) < 0)
+	{
+		(void) close(sock);
+		h_errno = TRY_AGAIN;
+		return(false);
+	}
+
+/*
+ * Process all incoming packets, usually one record in a separate packet.
+ */
+	while ((n = _res_read(sock, &sin, host, (char *)&answer, sizeof(querybuf))) != 0)
+	{
+		if (n < 0)
+		{
+			(void) close(sock);
+			h_errno = TRY_AGAIN;
+			return(false);
+		}
+
+		errno = 0;	/* reset after we got an answer */
+
+		if (n < HFIXEDSZ)
+		{
+			pr_error("answer length %s too short during %s for %s from %s",
+				itoa(n), pr_type(T_AXFR), name, host);
+			(void) close(sock);
+			h_errno = TRY_AGAIN;
+			return(false);
+		}
+
+		if (debug > 1)
+		{
+			printf("%sgot answer, %d bytes:\n", dbprefix, n);
+			pr_query((qbuf_t *)&answer, querysize(n), stdout);
+		}
+
+	/*
+	 * Analyze the contents of the answer and check for errors.
+	 * An error can be expected only in the very first packet.
+	 * The query section should be empty except in the first packet.
+	 * Note the special error status codes for specific failures.
+	 */
+		bp = (HEADER *)&answer;
+		ancount = ntohs(bp->ancount);
+
+		if (bp->rcode != NOERROR || ancount == 0)
+		{
+			if (verbose || debug)
+				print_status(&answer, n);
+
+			switch (bp->rcode)
+			{
+			    case NXDOMAIN:
+				/* distinguish between authoritative or not */
+				h_errno = bp->aa ? HOST_NOT_FOUND : NO_HOST;
+				break;
+
+			    case NOERROR:
+				/* distinguish between authoritative or not */
+				h_errno = bp->aa ? NO_DATA : NO_RREC;
+				break;
+
+			    case REFUSED:
+				/* special status if zone transfer refused */
+				h_errno = QUERY_REFUSED;
+				break;
+
+			    case SERVFAIL:
+				/* special status upon explicit failure */
+				h_errno = SERVER_FAILURE;
+				break;
+
+			    default:
+				/* all other errors will cause a retry */
+				h_errno = TRY_AGAIN;
+				break;
+			}
+
+			if (npackets != 0)
+				pr_error("unexpected error during %s for %s from %s",
+					pr_type(T_AXFR), name, host);
+
+			(void) close(sock);
+			return(false);
+		}
+
+		/* valid answer received, avoid buffer overrun */
+		h_errno = 0;
+		n = querysize(n);
+
+	/*
+	 * The nameserver and additional info section should be empty.
+	 * There may be multiple answers in the answer section.
+	 */
+		if (ntohs(bp->nscount) != 0)
+			pr_error("nonzero nscount during %s for %s from %s",
+				pr_type(T_AXFR), name, host);
+
+		if (ntohs(bp->arcount) != 0)
+			pr_error("nonzero arcount during %s for %s from %s",
+				pr_type(T_AXFR), name, host);
+
+	/*
+	 * Valid packet received. Print contents if appropriate.
+	 * Specific zone information will be saved by update_zone().
+	 */
+		npackets += 1;
+		nrecords += ancount;
+
+		soaname = NULL, subname = NULL, adrname = NULL, address = 0;
+		listhost = host;
+
+		(void) print_info(&answer, n, name, T_AXFR, queryclass, false);
+
+	/*
+	 * Terminate upon the second SOA record for this zone.
+	 */
+		if (soacount > 1)
+			break;
+	}
+
+/*
+ * End of zone transfer at second SOA record or zero length read.
+ */
+	(void) close(sock);
+
+/*
+ * Check for the anomaly that the whole transfer consisted of the
+ * SOA records only. Could occur if we queried the victim of a lame
+ * delegation which happened to have the SOA record present.
+ */
+	if (nrecords <= soacount)
+	{
+		pr_error("empty zone transfer for %s from %s",
+			name, host);
+		h_errno = NO_RREC;
+		return(false);
+	}
+
+/*
+ * Do an extra check for delegated zones that also have an A record.
+ * Those may have been defined in the child zone, and crept in the
+ * parent zone, or may have been defined as glue records.
+ * This is not necessarily an error, but the host count may be wrong.
+ * Note that an A record for the current zone has been ignored above.
+ */
+	for (n = 0; n < zonecount; n++)
+	{
+		i = host_index(zonename[n], false);
+		if (i < hostcount)
+			pr_warning("%s has both NS and A records within %s from %s",
+				zonename[n], name, host);
+	}
+
+/*
+ * The zone transfer has been successful.
+ */
+	if (verbose)
+	{
+		printf("Transfer complete, %d record%s received for %s\n",
+			nrecords, plural(nrecords), name);
+		if (npackets != nrecords)
+			printf("Transfer consisted of %d packet%s from %s\n",
+				npackets, plural(npackets), host);
+	}
+
+	return(true);
+}
+
+/*
+** UPDATE_ZONE -- Save zone information during zone listings
+** ---------------------------------------------------------
+**
+**	Returns:
+**		None.
+**
+**	Side effects:
+**		Stores list of delegated zones found in zonename[],
+**		and the count of delegated zones in ``zonecount''.
+**		Stores list of host names found in hostname[],
+**		and the count of host names in ``hostcount''.
+**		Stores the count of SOA records in ``soacount''.
+**
+**	This routine is called by print_info() for each resource record.
+*/
+
+void
+update_zone(name)
+input char *name;			/* name of zone to do zone xfer for */
+{
+	char *host = listhost;		/* contacted host for zone listings */
+	register int i;
+
+/*
+ * Terminate upon the second SOA record for this zone.
+ */
+	if (soaname && sameword(soaname, name))
+		soacount++;
+
+	/* the nameserver balks on this one */
+	else if (soaname && !sameword(soaname, name))
+		pr_warning("extraneous SOA record for %s within %s from %s",
+			soaname, name, host);
+
+/*
+ * Save encountered delegated zone name for recursive listing.
+ */
+	if (subname && indomain(subname, name, false))
+	{
+		i = zone_index(subname, true);
+		if (i >= zonecount)
+		{
+			zonename = newlist(zonename, zonecount+1, char *);
+			zonename[zonecount] = newstr(subname);
+			zonecount++;
+		}
+	}
+
+	/* warn about strange delegated zones */
+	else if (subname && !indomain(subname, name, true))
+		pr_warning("extraneous NS record for %s within %s from %s",
+			subname, name, host);
+
+/*
+ * Save encountered name of A record for host name count.
+ */
+	if (adrname && indomain(adrname, name, false) && !reverse)
+	{
+		i = host_index(adrname, true);
+		if (i >= hostcount)
+		{
+			if (hostcount >= maxhosts)
+			{
+				maxhosts += MAXHOSTINCR;
+				hostlist = newlist(hostlist, maxhosts, host_data_t);
+			}
+			hostname(hostcount) = newstr(adrname);
+			hostaddr(hostcount) = address;
+			multaddr(hostcount) = false;
+			hostcount++;
+		}
+		else if (address != hostaddr(i))
+			multaddr(i) = true;
+	}
+
+	/* check for unauthoritative glue records */
+	else if (adrname && !indomain(adrname, name, true))
+		pr_warning("extraneous glue record for %s within %s from %s",
+			adrname, name, host);
+}
+
+/*
+** GET_MXREC -- Fetch MX records of a domain
+** -----------------------------------------
+**
+**	Returns:
+**		true if MX records were found.
+**		false otherwise.
+*/
+
+bool
+get_mxrec(name)
+input char *name;			/* domain name to get mx for */
+{
+	querybuf answer;
+	register int n;
+
+	if (verbose)
+		printf("Finding MX records for %s ...\n", name);
+
+	n = get_info(&answer, name, T_MX, queryclass);
+	if (n < 0)
+		return(false);
+
+	(void) print_info(&answer, n, name, T_MX, queryclass, false);
+
+	return(true);
+}
+
+/*
+** GET_PRIMARY -- Fetch name of primary nameserver for a zone
+** ----------------------------------------------------------
+**
+**	Returns:
+**		Pointer to the name of the primary server, if found.
+**		NULL if the server could not be determined.
+*/
+
+char *
+get_primary(name)
+input char *name;			/* name of zone to get soa for */
+{
+	querybuf answer;
+	register int n;
+
+	if (verbose)
+		printf("Finding primary nameserver for %s ...\n", name);
+
+	n = get_info(&answer, name, T_SOA, queryclass);
+	if (n < 0)
+		return(NULL);
+
+	if (verbose > 1)
+		(void) print_info(&answer, n, name, T_SOA, queryclass, false);
+
+	soaname = NULL;
+	(void) get_soainfo(&answer, n, name);
+	if (soaname == NULL)
+		return(NULL);
+
+	return(soa.primary);
+}
+
+/*
+** CHECK_ZONE -- Fetch and analyze SOA record of a zone
+** ----------------------------------------------------
+**
+**	Returns:
+**		true if the SOA record was found at the given server.
+**		false otherwise.
+**
+**	Inputs:
+**		The global variable ``server'' must contain the name
+**		of the server that was queried.
+*/
+
+bool
+check_zone(name)
+input char *name;			/* name of zone to get soa for */
+{
+	querybuf answer;
+	register int n;
+
+	if (verbose)
+		printf("Checking SOA for %s at server %s ...\n", name, server);
+	else if (authserver)
+		printf("%-20s\tNS\t%s\n", name, server);
+	else
+		printf("%s\t(%s)\n", name, server);
+
+	n = get_info(&answer, name, T_SOA, queryclass);
+	if (n < 0)
+		return(false);
+
+	if (verbose > 1)
+		(void) print_info(&answer, n, name, T_SOA, queryclass, false);
+
+	soaname = NULL;
+	(void) get_soainfo(&answer, n, name);
+	if (soaname == NULL)
+		return(false);
+
+	check_soa(&answer, name);
+
+	return(true);
+}
+
+/*
+** GET_SOAINFO -- Extract SOA data from nameserver answer buffer
+** -------------------------------------------------------------
+**
+**	Returns:
+**		true if the answer buffer was processed successfully.
+**		false otherwise.
+**
+**	Outputs:
+**		The global struct ``soa'' is filled with the soa data.
+**
+**	Side effects:
+**		Sets ``soaname'' if there is a valid SOA record.
+**		This variable must have been cleared before calling
+**		get_soainfo() and may be checked afterwards.
+*/
+
+bool
+get_soainfo(answerbuf, answerlen, name)
+input querybuf *answerbuf;		/* location of answer buffer */
+input int answerlen;			/* length of answer buffer */
+input char *name;			/* name of zone to get soa for */
+{
+	HEADER *bp;
+	int qdcount, ancount;
+	u_char *msg, *eom;
+	register u_char *cp;
+
+	bp = (HEADER *)answerbuf;
+	qdcount = ntohs(bp->qdcount);
+	ancount = ntohs(bp->ancount);
+
+	msg = (u_char *)answerbuf;
+	eom = (u_char *)answerbuf + answerlen;
+	cp  = (u_char *)answerbuf + HFIXEDSZ;
+
+	if (qdcount > 0 && cp < eom)	/* should be exactly one record */
+	{
+		cp = skip_qrec(name, T_SOA, queryclass, cp, msg, eom);
+		if (cp == NULL)
+			return(false);
+		qdcount--;
+	}
+
+	if (qdcount)
+	{
+		pr_error("invalid qdcount after %s query for %s",
+			pr_type(T_SOA), name);
+		h_errno = NO_RECOVERY;
+		return(false);
+	}
+
+/*
+ * Check answer section only.
+ * Check that answers match the requested zone. Ignore other entries.
+ * The nameserver section may contain the nameservers for the zone,
+ * and the additional section their addresses, but not guaranteed.
+ * Those sections are usually empty for authoritative answers.
+ */
+	while (ancount > 0 && cp < eom)
+	{
+		char rname[MAXDNAME+1];
+		int type, class, ttl, dlen;
+		u_char *eor;
+		register int n;
+
+		n = expand_name(name, T_NONE, cp, msg, eom, rname);
+		if (n < 0)
+			return(false);
+		cp += n;
+
+		n = 3*INT16SZ + INT32SZ;
+		if (check_size(rname, T_NONE, cp, msg, eom, n) < 0)
+			return(false);
+
+		type = _getshort(cp);
+		cp += INT16SZ;
+
+		class = _getshort(cp);
+		cp += INT16SZ;
+
+		ttl = _getlong(cp);
+		cp += INT32SZ;
+
+		dlen = _getshort(cp);
+		cp += INT16SZ;
+
+		eor = cp + dlen;
+#ifdef lint
+		if (verbose)
+			printf("%-20s\t%d\t%s\t%s\n",
+				rname, ttl, pr_class(class), pr_type(type));
+#endif
+		if ((type == T_SOA) && sameword(rname, name))
+		{
+			n = expand_name(rname, type, cp, msg, eom, soa.primary);
+			if (n < 0)
+				return(false);
+			cp += n;
+
+			n = expand_name(rname, type, cp, msg, eom, soa.hostmaster);
+			if (n < 0)
+				return(false);
+			cp += n;
+
+			n = 5*INT32SZ;
+			if (check_size(rname, type, cp, msg, eor, n) < 0)
+				return(false);
+			soa.serial = _getlong(cp);
+			cp += INT32SZ;
+			soa.refresh = _getlong(cp);
+			cp += INT32SZ;
+			soa.retry = _getlong(cp);
+			cp += INT32SZ;
+			soa.expire = _getlong(cp);
+			cp += INT32SZ;
+			soa.defttl = _getlong(cp);
+			cp += INT32SZ;
+
+			/* valid complete soa record found */
+			soaname = strcpy(soanamebuf, rname);
+		}
+		else
+		{
+			/* just ignore other records */
+			cp += dlen;
+		}
+
+		if (cp != eor)
+		{
+			pr_error("size error in %s record for %s, off by %s",
+				pr_type(type), rname, itoa(cp - eor));
+			h_errno = NO_RECOVERY;
+			return(false);
+		}
+
+		ancount--;
+	}
+
+	if (ancount)
+	{
+		pr_error("invalid ancount after %s query for %s",
+			pr_type(T_SOA), name);
+		h_errno = NO_RECOVERY;
+		return(false);
+	}
+
+	/* set proper status if no answers found */
+	h_errno = (soaname != NULL) ? 0 : TRY_AGAIN;
+	return(true);
+}
+
+/*
+** CHECK_SOA -- Analyze retrieved SOA records of a zone
+** ----------------------------------------------------
+**
+**	Returns:
+**		None.
+**
+**	Inputs:
+**		The global variable ``server'' must contain the
+**		name of the server that was queried.
+**		The global struct ``soa'' must contain the soa data.
+*/
+
+void
+check_soa(answerbuf, name)
+input querybuf *answerbuf;		/* location of answer buffer */
+input char *name;			/* name of zone to check soa for */
+{
+	static char oldnamebuf[MAXDNAME+1];
+	static char *oldname = NULL;	/* previous name of zone */
+	static char *oldserver = NULL;	/* previous name of server */
+	static soa_data_t oldsoa;	/* previous soa data */
+	register int n;
+	HEADER *bp;
+
+/*
+ * Print the various SOA fields in abbreviated form.
+ * Values are actually unsigned, but we print them as signed integers,
+ * apart from the serial which really becomes that big sometimes.
+ * In the latter case we print a warning below.
+ */
+	printf("%s\t%s\t(%u %d %d %d %d)\n",
+		soa.primary, soa.hostmaster, (unsigned)soa.serial,
+		soa.refresh, soa.retry, soa.expire, soa.defttl);
+
+/*
+ * We are supposed to have queried an authoritative nameserver, and since
+ * nameserver recursion has been turned off, answer must be authoritative.
+ */
+	bp = (HEADER *)answerbuf;
+	if (!bp->aa)
+	{
+		if (authserver)
+			pr_error("%s SOA record at %s is not authoritative",
+				name, server);
+		else
+			pr_warning("%s SOA record at %s is not authoritative",
+				name, server);
+
+		if (authserver)
+			errmsg("%s has lame delegation to %s",
+				name, server);
+	}
+
+/*
+ * Check whether we are switching to a new zone.
+ * The old name must have been saved in static storage.
+ */
+	if ((oldname != NULL) && !sameword(name, oldname))
+		oldname = NULL;
+
+/*
+ * Make few timer consistency checks only for the first one in a series.
+ * Compare the primary field against the list of authoritative servers.
+ * Explicitly check the hostmaster field for illegal characters ('@@').
+ * Yell if the serial has the high bit set (not always intentional).
+ */
+	if (oldname == NULL)
+	{
+		for (n = 0; n < nservers; n++)
+			if (sameword(soa.primary, nsname[n]))
+				break;	/* found */
+
+		if ((n >= nservers) && authserver)
+			pr_warning("%s SOA primary %s is not advertised via NS",
+				name, soa.primary);
+
+		if (!valid_name(soa.primary, false, false, false))
+			pr_warning("%s SOA primary %s has illegal name",
+				name, soa.primary);
+
+		if (!valid_name(soa.hostmaster, false, true, false))
+			pr_warning("%s SOA hostmaster %s has illegal mailbox",
+				name, soa.hostmaster);
+
+		if (bitset(0x80000000, soa.serial))
+			pr_warning("%s SOA serial has high bit set",
+				name);
+
+		if (soa.retry > soa.refresh)
+			pr_warning("%s SOA retry exceeds refresh",
+				name);
+
+		if (soa.refresh + soa.retry > soa.expire)
+			pr_warning("%s SOA refresh+retry exceeds expire",
+				name);
+	}
+
+/*
+ * Compare various fields with those of the previous query, if any.
+ * Different serial numbers may be present if secondaries have not yet
+ * refreshed the data from the primary. Issue only a warning in that case.
+ */
+	if (oldname != NULL)
+	{
+		if (!sameword(soa.primary, oldsoa.primary))
+			pr_error("%s and %s have different primary for %s",
+				server, oldserver, name);
+
+		if (!sameword(soa.hostmaster, oldsoa.hostmaster))
+			pr_error("%s and %s have different hostmaster for %s",
+				server, oldserver, name);
+
+		if (soa.serial != oldsoa.serial)
+			pr_warning("%s and %s have different serial for %s",
+				server, oldserver, name);
+
+		if (soa.refresh != oldsoa.refresh)
+			pr_error("%s and %s have different refresh for %s",
+				server, oldserver, name);
+
+		if (soa.retry != oldsoa.retry)
+			pr_error("%s and %s have different retry for %s",
+				server, oldserver, name);
+
+		if (soa.expire != oldsoa.expire)
+			pr_error("%s and %s have different expire for %s",
+				server, oldserver, name);
+
+		if (soa.defttl != oldsoa.defttl)
+			pr_error("%s and %s have different defttl for %s",
+				server, oldserver, name);
+	}
+
+/*
+ * Save the current information.
+ */
+	oldname = strcpy(oldnamebuf, name);
+	oldserver = server;
+	oldsoa = soa;
+}
+
+/*
+** CHECK_DUPL -- Check global address list for duplicates
+** ------------------------------------------------------
+**
+**	Returns:
+**		true if the given host address already exists.
+**		false otherwise.
+**
+**	Side effects:
+**		Adds the host address to the list if not present.
+**
+**	The information in this table is global, and is not cleared.
+*/
+
+#define AHASHSIZE	0x2000
+#define AHASHMASK	0x1fff
+
+typedef struct addr_tab {
+	ipaddr_t *addrlist;		/* global list of addresses */
+	int addrcount;			/* count of global addresses */
+} addr_tab_t;
+
+addr_tab_t addrtab[AHASHSIZE];		/* hash list of global addresses */
+
+bool
+check_dupl(addr)
+input ipaddr_t addr;			/* address of host to check */
+{
+ 	register int i;
+	register addr_tab_t *s;
+
+	s = &addrtab[ntohl(addr) & AHASHMASK];
+
+	for (i = 0; i < s->addrcount; i++)
+		if (s->addrlist[i] == addr)
+			return(true);	/* duplicate */
+
+	s->addrlist = newlist(s->addrlist, s->addrcount+1, ipaddr_t);
+	s->addrlist[s->addrcount] = addr;
+	s->addrcount++;
+	return(false);
+}
+
+/*
+** CHECK_TTL -- Check list of records for different ttl values
+** -----------------------------------------------------------
+**
+**	Returns:
+**		true if the ttl value matches the first record
+**		already listed with the same name/type/class.
+**		false only when the first discrepancy is found.
+**
+**	Side effects:
+**		Adds the record data to the list if not present.
+*/
+
+#define THASHSIZE	2003
+
+typedef struct ttl_tab {
+	struct ttl_tab *next;		/* next entry in chain */
+	char *name;			/* name of resource record */
+	int type;			/* resource record type */
+	int class;			/* resource record class */
+	int ttl;			/* time_to_live value */
+	int count;			/* count of different ttl values */
+} ttl_tab_t;
+
+ttl_tab_t *ttltab[THASHSIZE];		/* hash list of record info */
+
+bool
+check_ttl(name, type, class, ttl)
+input char *name;			/* resource record name */
+input int type, class, ttl;		/* resource record fixed values */
+{
+	register ttl_tab_t *s;
+	register ttl_tab_t **ps;
+	register unsigned int hfunc;
+	register char *p;
+	register char c;
+
+/*
+ * Compute the hash function for this resource record.
+ * Look it up in the appropriate hash chain.
+ */
+	for (hfunc = type, p = name; (c = *p) != '\0'; p++)
+	{
+		hfunc = ((hfunc << 1) ^ (lowercase(c) & 0377)) % THASHSIZE;
+	}
+
+	for (ps = &ttltab[hfunc]; (s = *ps) != NULL; ps = &s->next)
+	{
+		if (s->type != type || s->class != class)
+			continue;
+		if (sameword(s->name, name))
+			break;
+	}
+
+/*
+ * Allocate new entry if not found.
+ */
+	if (s == NULL)
+	{
+		/* ps = &ttltab[hfunc]; */
+		s = newstruct(ttl_tab_t);
+
+		/* initialize new entry */
+		s->name = newstr(name);
+		s->type = type;
+		s->class = class;
+		s->ttl = ttl;
+		s->count = 0;
+
+		/* link it in */
+		s->next = *ps;
+		*ps = s;
+	}
+
+/*
+ * Check whether the ttl value matches the first recorded one.
+ * If not, signal only the first discrepancy encountered, so
+ * only one warning message will be printed.
+ */
+	if (s->ttl == ttl)
+		return(true);
+
+	s->count += 1;
+	return((s->count == 1) ? false : true);
+}
+
+/*
+** CLEAR_TTLTAB -- Clear resource record list for ttl checking
+** -----------------------------------------------------------
+**
+**	Returns:
+**		None.
+**
+**	An entry on the hash list, and the host name in each
+**	entry, have been allocated in dynamic memory.
+**
+**	The information in this table is on a per-zone basis.
+**	It must be cleared before any subsequent zone transfers.
+*/
+
+void
+clear_ttltab()
+{
+	register int i;
+	register ttl_tab_t *s, *t;
+
+	for (i = 0; i < THASHSIZE; i++)
+	{
+		if (ttltab[i] != NULL)
+		{
+			/* free chain of entries */
+			for (t = NULL, s = ttltab[i]; s != NULL; s = t)
+			{
+				t = s->next;
+				xfree(s->name);
+				xfree(s);
+			}
+
+			/* reset hash chain */
+			ttltab[i] = NULL;
+		}
+	}
+}
+
+/*
+** HOST_INDEX -- Check list of host names for name being present
+** -------------------------------------------------------------
+**
+**	Returns:
+**		Index into hostname[] table, if found.
+**		Current ``hostcount'' value, if not found.
+**
+**	Side effects:
+**		May add an entry to the hash list if not present.
+**
+**	A linear search through the master table becomes very
+**	costly for zones with more than a few thousand hosts.
+**	Maintain a hash list with indexes into the master table.
+**	Caller should update the master table after this call.
+*/
+
+#define HHASHSIZE	2003
+
+typedef struct host_tab {
+	struct host_tab *next;		/* next entry in chain */
+	int slot;			/* slot in host name table */
+} host_tab_t;
+
+host_tab_t *hosttab[HHASHSIZE];		/* hash list of host name info */
+
+int
+host_index(name, enter)
+input char *name;			/* the host name to check */
+input bool enter;			/* add to table if not found */
+{
+	register host_tab_t *s;
+	register host_tab_t **ps;
+	register unsigned int hfunc;
+	register char *p;
+	register char c;
+
+/*
+ * Compute the hash function for this host name.
+ * Look it up in the appropriate hash chain.
+ */
+	for (hfunc = 0, p = name; (c = *p) != '\0'; p++)
+	{
+		hfunc = ((hfunc << 1) ^ (lowercase(c) & 0377)) % HHASHSIZE;
+	}
+
+	for (ps = &hosttab[hfunc]; (s = *ps) != NULL; ps = &s->next)
+	{
+		if (s->slot >= hostcount)
+			continue;
+		if (sameword(hostname(s->slot), name))
+			break;
+	}
+
+/*
+ * Allocate new entry if not found.
+ */
+	if ((s == NULL) && enter)
+	{
+		/* ps = &hosttab[hfunc]; */
+		s = newstruct(host_tab_t);
+
+		/* initialize new entry */
+		s->slot = hostcount;
+
+		/* link it in */
+		s->next = *ps;
+		*ps = s;
+	}
+
+	return((s != NULL) ? s->slot : hostcount);
+}
+
+/*
+** CLEAR_HOSTTAB -- Clear hash list for host name checking
+** -------------------------------------------------------
+**
+**	Returns:
+**		None.
+**
+**	A hash list entry has been allocated in dynamic memory.
+**
+**	The information in this table is on a per-zone basis.
+**	It must be cleared before any subsequent zone transfers.
+*/
+
+void
+clear_hosttab()
+{
+	register int i;
+	register host_tab_t *s, *t;
+
+	for (i = 0; i < HHASHSIZE; i++)
+	{
+		if (hosttab[i] != NULL)
+		{
+			/* free chain of entries */
+			for (t = NULL, s = hosttab[i]; s != NULL; s = t)
+			{
+				t = s->next;
+				xfree(s);
+			}
+
+			/* reset hash chain */
+			hosttab[i] = NULL;
+		}
+	}
+}
+
+/*
+** ZONE_INDEX -- Check list of zone names for name being present
+** -------------------------------------------------------------
+**
+**	Returns:
+**		Index into zonename[] table, if found.
+**		Current ``zonecount'' value, if not found.
+**
+**	Side effects:
+**		May add an entry to the hash list if not present.
+**
+**	A linear search through the master table becomes very
+**	costly for more than a few thousand delegated zones.
+**	Maintain a hash list with indexes into the master table.
+**	Caller should update the master table after this call.
+*/
+
+#define ZHASHSIZE	2003
+
+typedef struct zone_tab {
+	struct zone_tab *next;		/* next entry in chain */
+	int slot;			/* slot in zone name table */
+} zone_tab_t;
+
+zone_tab_t *zonetab[ZHASHSIZE];		/* hash list of zone name info */
+
+int
+zone_index(name, enter)
+input char *name;			/* the zone name to check */
+input bool enter;			/* add to table if not found */
+{
+	register zone_tab_t *s;
+	register zone_tab_t **ps;
+	register unsigned int hfunc;
+	register char *p;
+	register char c;
+
+/*
+ * Compute the hash function for this zone name.
+ * Look it up in the appropriate hash chain.
+ */
+	for (hfunc = 0, p = name; (c = *p) != '\0'; p++)
+	{
+		hfunc = ((hfunc << 1) ^ (lowercase(c) & 0377)) % ZHASHSIZE;
+	}
+
+	for (ps = &zonetab[hfunc]; (s = *ps) != NULL; ps = &s->next)
+	{
+		if (s->slot >= zonecount)
+			continue;
+		if (sameword(zonename[s->slot], name))
+			break;
+	}
+
+/*
+ * Allocate new entry if not found.
+ */
+	if ((s == NULL) && enter)
+	{
+		/* ps = &zonetab[hfunc]; */
+		s = newstruct(zone_tab_t);
+
+		/* initialize new entry */
+		s->slot = zonecount;
+
+		/* link it in */
+		s->next = *ps;
+		*ps = s;
+	}
+
+	return((s != NULL) ? s->slot : zonecount);
+}
+
+/*
+** CLEAR_ZONETAB -- Clear hash list for zone name checking
+** -------------------------------------------------------
+**
+**	Returns:
+**		None.
+**
+**	A hash list entry has been allocated in dynamic memory.
+**
+**	The information in this table is on a per-zone basis.
+**	It must be cleared before any subsequent zone transfers.
+*/
+
+void
+clear_zonetab()
+{
+	register int i;
+	register zone_tab_t *s, *t;
+
+	for (i = 0; i < ZHASHSIZE; i++)
+	{
+		if (zonetab[i] != NULL)
+		{
+			/* free chain of entries */
+			for (t = NULL, s = zonetab[i]; s != NULL; s = t)
+			{
+				t = s->next;
+				xfree(s);
+			}
+
+			/* reset hash chain */
+			zonetab[i] = NULL;
+		}
+	}
+}
+
+/*
+** CHECK_CANON -- Check list of domain names for name being canonical
+** ------------------------------------------------------------------
+**
+**	Returns:
+**		Nonzero if the name is definitely not canonical.
+**		0 if it is canonical, or if it remains undecided.
+**
+**	Side effects:
+**		Adds the domain name to the list if not present.
+**
+**	The information in this table is global, and is not cleared
+**	(which may be necessary if the checking algorithm changes).
+*/
+
+#define CHASHSIZE	2003
+
+typedef struct canon_tab {
+	struct canon_tab *next;		/* next entry in chain */
+	char *name;			/* domain name */
+	int status;			/* nonzero if not canonical */
+} canon_tab_t;
+
+canon_tab_t *canontab[CHASHSIZE];	/* hash list of domain name info */
+
+int
+check_canon(name)
+input char *name;			/* the domain name to check */
+{
+	register canon_tab_t *s;
+	register canon_tab_t **ps;
+	register unsigned int hfunc;
+	register char *p;
+	register char c;
+
+/*
+ * Compute the hash function for this domain name.
+ * Look it up in the appropriate hash chain.
+ */
+	for (hfunc = 0, p = name; (c = *p) != '\0'; p++)
+	{
+		hfunc = ((hfunc << 1) ^ (lowercase(c) & 0377)) % CHASHSIZE;
+	}
+
+	for (ps = &canontab[hfunc]; (s = *ps) != NULL; ps = &s->next)
+	{
+		if (sameword(s->name, name))
+			break;
+	}
+
+/*
+ * Allocate new entry if not found.
+ * Only then is the actual check carried out.
+ */
+	if (s == NULL)
+	{
+		/* ps = &canontab[hfunc]; */
+		s = newstruct(canon_tab_t);
+
+		/* initialize new entry */
+		s->name = newstr(name);
+		s->status = canonical(name);
+
+		/* link it in */
+		s->next = *ps;
+		*ps = s;
+	}
+
+	return(s->status);
+}
+
+/*
+** CHECK_ADDR -- Check whether reverse address mappings revert to host
+** -------------------------------------------------------------------
+**
+**	Returns:
+**		true if all addresses of host map back to host.
+**		false otherwise.
+*/
+
+bool
+check_addr(name)
+input char *name;			/* host name to check addresses for */
+{
+	struct hostent *hp;
+	register int i;
+	struct in_addr inaddr[MAXADDRS];
+	int naddress;
+	char hnamebuf[MAXDNAME+1];
+	char *hname;
+	char inamebuf[MAXDNAME+1];
+	char *iname;
+	int matched;
+
+/*
+ * Look up the specified host to fetch its addresses.
+ */
+	hp = gethostbyname(name);
+	if (hp == NULL)
+	{
+		ns_error(name, T_A, C_IN, server);
+		return(false);
+	}
+
+	hname = strncpy(hnamebuf, hp->h_name, MAXDNAME);
+	hname[MAXDNAME] = '\0';
+
+	for (i = 0; i < MAXADDRS && hp->h_addr_list[i]; i++)
+		inaddr[i] = incopy(hp->h_addr_list[i]);
+	naddress = i;
+
+	if (verbose)
+		printf("Found %d address%s for %s\n",
+			naddress, plurale(naddress), hname);
+
+/*
+ * Map back the addresses found, and check whether they revert to host.
+ */
+	for (matched = 0, i = 0; i < naddress; i++)
+	{
+		iname = strcpy(inamebuf, inet_ntoa(inaddr[i]));
+
+		if (verbose)
+			printf("Checking %s address %s\n", hname, iname);
+
+		hp = gethostbyaddr((char *)&inaddr[i], INADDRSZ, AF_INET);
+		if (hp == NULL)
+			ns_error(iname, T_PTR, C_IN, server);
+		else if (!sameword(hp->h_name, hname))
+			pr_warning("%s address %s maps to %s",
+				hname, iname, hp->h_name);
+		else
+			matched++;
+	}
+
+	return((matched == naddress) ? true : false);
+}
+
+/*
+** CHECK_NAME -- Check whether address belongs to host addresses
+** -------------------------------------------------------------
+**
+**	Returns:
+**		true if given address was found among host addresses.
+**		false otherwise.
+*/
+
+bool
+check_name(addr)
+input ipaddr_t addr;			/* address of host to check */
+{
+	struct hostent *hp;
+	register int i;
+	struct in_addr inaddr;
+	char hnamebuf[MAXDNAME+1];
+	char *hname;
+	char inamebuf[MAXDNAME+1];
+	char *iname;
+	int matched;
+
+/*
+ * Check whether the address is registered by fetching its host name.
+ */
+	inaddr.s_addr = addr;
+	iname = strcpy(inamebuf, inet_ntoa(inaddr));
+
+	hp = gethostbyaddr((char *)&inaddr, INADDRSZ, AF_INET);
+	if (hp == NULL)
+	{
+		ns_error(iname, T_PTR, C_IN, server);
+		return(false);
+	}
+
+	hname = strncpy(hnamebuf, hp->h_name, MAXDNAME);
+	hname[MAXDNAME] = '\0';
+
+	if (verbose)
+		printf("Address %s maps to %s\n", iname, hname);
+
+/*
+ * Lookup the host name found to fetch its addresses.
+ */
+	hp = gethostbyname(hname);
+	if (hp == NULL)
+	{
+		ns_error(hname, T_A, C_IN, server);
+		return(false);
+	}
+
+/*
+ * Verify whether the mapped host name is canonical.
+ */
+	if (!sameword(hp->h_name, hname))
+		pr_warning("%s host %s is not canonical (%s)",
+			iname, hname, hp->h_name);
+
+/*
+ * Check whether the given address is listed among the known addresses.
+ */
+	for (matched = 0, i = 0; hp->h_addr_list[i]; i++)
+	{
+		inaddr = incopy(hp->h_addr_list[i]);
+
+		if (verbose)
+			printf("Checking %s address %s\n",
+				hname, inet_ntoa(inaddr));
+
+		if (inaddr.s_addr == addr)
+			matched++;
+	}
+
+	if (!matched)
+		pr_error("address %s does not belong to %s",
+			iname, hname);
+
+	return(matched ? true : false);
+}
+
+/*
+** GETH_BYNAME -- Wrapper for gethostbyname
+** ----------------------------------------
+**
+**	Returns:
+**		Pointer to struct hostent if lookup was successful.
+**		NULL otherwise.
+**
+**	Note. This routine works for fully qualified names only.
+**	The entire special res_search() processing can be skipped.
+*/
+
+struct hostent *
+geth_byname(name)
+input const char *name;			/* name to do forward lookup for */
+{
+	querybuf answer;
+	struct hostent *hp;
+	register int n;
+
+	hp = gethostbyname(name);
+	if (hp != NULL)
+		return(hp);
+
+	if (verbose > print_level)
+		printf("Finding addresses for %s ...\n", name);
+
+	n = get_info(&answer, name, T_A, C_IN);
+	if (n < 0)
+		return(NULL);
+
+	if ((verbose > print_level + 1) && (print_level < 1))
+		(void) print_info(&answer, n, name, T_A, C_IN, false);
+
+	hp = gethostbyname(name);
+	return(hp);
+}
+
+/*
+** GETH_BYADDR -- Wrapper for gethostbyaddr
+** ----------------------------------------
+**
+**	Returns:
+**		Pointer to struct hostent if lookup was successful.
+**		NULL otherwise.
+*/
+
+struct hostent *
+geth_byaddr(addr, size, family)
+input const char *addr;			/* address to do reverse mapping for */
+input int size;				/* size of the address */
+input int family;			/* address family */
+{
+	char addrbuf[4*4 + sizeof(ARPA_ROOT) + 1];
+	char *name = addrbuf;
+	u_char *a = (u_char *)addr;
+	querybuf answer;
+	struct hostent *hp;
+	register int n;
+
+	if (size != INADDRSZ || family != AF_INET)
+	{
+		hp = gethostbyaddr(addr, size, family);
+		return(hp);
+	}
+
+	hp = gethostbyaddr(addr, size, family);
+	if (hp != NULL)
+		return(hp);
+
+	/* construct absolute reverse name *without* trailing dot */
+	(void) sprintf(addrbuf, "%u.%u.%u.%u.%s",
+		a[3]&0xff, a[2]&0xff, a[1]&0xff, a[0]&0xff, ARPA_ROOT);
+
+	if (verbose > print_level)
+		printf("Finding reverse mapping for %s ...\n",
+			inet_ntoa(incopy(addr)));
+
+	n = get_info(&answer, name, T_PTR, C_IN);
+	if (n < 0)
+		return(NULL);
+
+	if ((verbose > print_level + 1) && (print_level < 1))
+		(void) print_info(&answer, n, name, T_PTR, C_IN, false);
+
+	hp = gethostbyaddr(addr, size, family);
+	return(hp);
+}
+
+/*
+** PARSE_TYPE -- Decode rr type from input string
+** ----------------------------------------------
+**
+**	Returns:
+**		Value of resource record type.
+**		-1 if specified record name is invalid.
+**
+**	Note.	Several types are deprecated or obsolete, but recognized.
+**		T_AXFR/T_IXFR is not allowed to be specified as query type.
+*/
+
+int
+parse_type(str)
+input char *str;			/* input string with record type */
+{
+	register int type;
+
+		/* standard types */
+
+	if (sameword(str, "A"))		return(T_A);
+	if (sameword(str, "NS"))	return(T_NS);
+	if (sameword(str, "MD"))	return(T_MD);		/* obsolete */
+	if (sameword(str, "MF"))	return(T_MF);		/* obsolete */
+	if (sameword(str, "CNAME"))	return(T_CNAME);
+	if (sameword(str, "SOA"))	return(T_SOA);
+	if (sameword(str, "MB"))	return(T_MB);		/* deprecated */
+	if (sameword(str, "MG"))	return(T_MG);		/* deprecated */
+	if (sameword(str, "MR"))	return(T_MR);		/* deprecated */
+	if (sameword(str, "NULL"))	return(T_NULL);		/* obsolete */
+	if (sameword(str, "WKS"))	return(T_WKS);
+	if (sameword(str, "PTR"))	return(T_PTR);
+	if (sameword(str, "HINFO"))	return(T_HINFO);
+	if (sameword(str, "MINFO"))	return(T_MINFO);	/* deprecated */
+	if (sameword(str, "MX"))	return(T_MX);
+	if (sameword(str, "TXT"))	return(T_TXT);
+
+		/* new types */
+
+	if (sameword(str, "RP"))	return(T_RP);
+	if (sameword(str, "AFSDB"))	return(T_AFSDB);
+	if (sameword(str, "X25"))	return(T_X25);
+	if (sameword(str, "ISDN"))	return(T_ISDN);
+	if (sameword(str, "RT"))	return(T_RT);
+	if (sameword(str, "NSAP"))	return(T_NSAP);
+	if (sameword(str, "NSAP-PTR"))	return(T_NSAPPTR);
+	if (sameword(str, "SIG"))	return(T_SIG);
+	if (sameword(str, "KEY"))	return(T_KEY);
+	if (sameword(str, "PX"))	return(T_PX);
+	if (sameword(str, "GPOS"))	return(T_GPOS);		/* withdrawn */
+	if (sameword(str, "AAAA"))	return(T_AAAA);
+	if (sameword(str, "LOC"))	return(T_LOC);
+	if (sameword(str, "NXT"))	return(T_NXT);
+	if (sameword(str, "EID"))	return(T_EID);
+	if (sameword(str, "NIMLOC"))	return(T_NIMLOC);
+	if (sameword(str, "SRV"))	return(T_SRV);
+	if (sameword(str, "ATMA"))	return(T_ATMA);
+	if (sameword(str, "NAPTR"))	return(T_NAPTR);
+
+		/* nonstandard types */
+
+	if (sameword(str, "UINFO"))	return(T_UINFO);
+	if (sameword(str, "UID"))	return(T_UID);
+	if (sameword(str, "GID"))	return(T_GID);
+	if (sameword(str, "UNSPEC"))	return(T_UNSPEC);
+
+		/* filters */
+
+	if (sameword(str, "IXFR"))	return(-1);		/* illegal */
+	if (sameword(str, "AXFR"))	return(-1);		/* illegal */
+	if (sameword(str, "MAILB"))	return(T_MAILB);
+	if (sameword(str, "MAILA"))	return(T_MAILA);	/* obsolete */
+	if (sameword(str, "ANY"))	return(T_ANY);
+	if (sameword(str, "*"))		return(T_ANY);
+
+		/* unknown types */
+
+	type = atoi(str);
+	if (type >= T_FIRST && type <= T_LAST)
+		return(type);
+
+	return(-1);
+}
+
+/*
+** PARSE_CLASS -- Decode rr class from input string
+** ------------------------------------------------
+**
+**	Returns:
+**		Value of resource class.
+**		-1 if specified class name is invalid.
+**
+**	Note.	C_CSNET is obsolete, but recognized.
+*/
+
+int
+parse_class(str)
+input char *str;			/* input string with resource class */
+{
+	register int class;
+
+	if (sameword(str, "IN"))	return(C_IN);
+	if (sameword(str, "INTERNET"))	return(C_IN);
+	if (sameword(str, "CS"))	return(C_CSNET);	/* obsolete */
+	if (sameword(str, "CSNET"))	return(C_CSNET);	/* obsolete */
+	if (sameword(str, "CH"))	return(C_CHAOS);
+	if (sameword(str, "CHAOS"))	return(C_CHAOS);
+	if (sameword(str, "HS"))	return(C_HS);
+	if (sameword(str, "HESIOD"))	return(C_HS);
+
+	if (sameword(str, "ANY"))	return(C_ANY);
+	if (sameword(str, "*"))		return(C_ANY);
+
+	class = atoi(str);
+	if (class > 0)
+		return(class);
+
+	return(-1);
+}
+
+/*
+** IN_ADDR_ARPA -- Convert dotted quad string to reverse in-addr.arpa
+** ------------------------------------------------------------------
+**
+**	Returns:
+**		Pointer to appropriate reverse in-addr.arpa name
+**		with trailing dot to force absolute domain name.
+**		NULL in case of invalid dotted quad input string.
+*/
+
+char *
+in_addr_arpa(dottedquad)
+input char *dottedquad;			/* input string with dotted quad */
+{
+	static char addrbuf[4*4 + sizeof(ARPA_ROOT) + 2];
+	unsigned int a[4];
+	register int n;
+
+	n = sscanf(dottedquad, "%u.%u.%u.%u", &a[0], &a[1], &a[2], &a[3]);
+	switch (n)
+	{
+	    case 4:
+		(void) sprintf(addrbuf, "%u.%u.%u.%u.%s.",
+			a[3]&0xff, a[2]&0xff, a[1]&0xff, a[0]&0xff, ARPA_ROOT);
+		break;
+
+	    case 3:
+		(void) sprintf(addrbuf, "%u.%u.%u.%s.",
+			a[2]&0xff, a[1]&0xff, a[0]&0xff, ARPA_ROOT);
+		break;
+
+	    case 2:
+		(void) sprintf(addrbuf, "%u.%u.%s.",
+			a[1]&0xff, a[0]&0xff, ARPA_ROOT);
+		break;
+
+	    case 1:
+		(void) sprintf(addrbuf, "%u.%s.",
+			a[0]&0xff, ARPA_ROOT);
+		break;
+
+	    default:
+		return(NULL);
+	}
+
+	while (--n >= 0)
+		if (a[n] > 255)
+			return(NULL);
+
+	return(addrbuf);
+}
+
+/*
+** NSAP_INT -- Convert dotted nsap address string to reverse nsap.int
+** ------------------------------------------------------------------
+**
+**	Returns:
+**		Pointer to appropriate reverse nsap.int name
+**		with trailing dot to force absolute domain name.
+**		NULL in case of invalid nsap address input string.
+*/
+
+char *
+nsap_int(name)
+input char *name;			/* input string with dotted nsap */
+{
+	static char addrbuf[4*MAXNSAP + sizeof(NSAP_ROOT) + 2];
+	register int n;
+	register int i;
+
+	/* skip optional leading hex indicator */
+	if (samehead(name, "0x"))
+		name += 2;
+
+	for (n = 0, i = strlength(name)-1; i >= 0; --i)
+	{
+		/* skip optional interspersed separators */
+		if (name[i] == '.' || name[i] == '+' || name[i] == '/')
+			continue;
+
+		/* must consist of hex digits only */
+		if (!is_xdigit(name[i]))
+			return(NULL);
+
+		/* but not too many */
+		if (n >= 4*MAXNSAP)
+			return(NULL);
+
+		addrbuf[n++] = name[i];
+		addrbuf[n++] = '.';
+	}
+
+	/* must have an even number of hex digits */ 
+	if (n == 0 || (n % 4) != 0)
+		return(NULL);
+
+	(void) sprintf(&addrbuf[n], "%s.", NSAP_ROOT);
+	return(addrbuf);
+}
+
+/*
+** PRINT_HOST -- Print host name and address of hostent struct
+** -----------------------------------------------------------
+**
+**	Returns:
+**		None.
+*/
+
+void
+print_host(heading, hp)
+input char *heading;			/* header string */
+input struct hostent *hp;		/* location of hostent struct */
+{
+	register char **ap;
+
+	printf("%s: %s", heading, hp->h_name);
+
+	for (ap = hp->h_addr_list; ap && *ap; ap++)
+	{
+		if (ap == hp->h_addr_list)
+			printf("\nAddress:");
+
+		printf(" %s", inet_ntoa(incopy(*ap)));
+	}
+
+	for (ap = hp->h_aliases; ap && *ap && **ap; ap++)
+	{
+		if (ap == hp->h_aliases)
+			printf("\nAliases:");
+
+		printf(" %s", *ap);
+	}
+
+	printf("\n\n");
+}
+
+/*
+** SHOW_RES -- Show resolver database information
+** ----------------------------------------------
+**
+**	Returns:
+**		None.
+**
+**	Inputs:
+**		The resolver database _res is localized in the resolver.
+*/
+
+void
+show_res()
+{
+	register int i;
+	register char **domain;
+
+/*
+ * The default domain is defined by the "domain" entry in /etc/resolv.conf
+ * if not overridden by the environment variable "LOCALDOMAIN".
+ * If still not defined, gethostname() may yield a fully qualified host name.
+ */
+	printf("Default domain:");
+	if (_res.defdname[0] != '\0')
+		printf(" %s", _res.defdname);
+	printf("\n");
+
+/*
+ * The search domains are extracted from the default domain components,
+ * but may be overridden by "search" directives in /etc/resolv.conf
+ * since 4.8.3.
+ */
+	printf("Search domains:");
+	for (domain = _res.dnsrch; *domain; domain++)
+		printf(" %s", *domain);
+	printf("\n");
+
+/*
+ * The routine res_send() will do _res.retry tries to contact each of the
+ * _res.nscount nameserver addresses before giving up when using datagrams.
+ * The first try will timeout after _res.retrans seconds. Each following
+ * try will timeout after ((_res.retrans << try) / _res.nscount) seconds.
+ * Note. When we contact an explicit server the addresses will be replaced
+ * by the multiple addresses of the same server.
+ * When doing a zone transfer _res.retrans is used for the connect timeout.
+ */
+	printf("Timeout per retry: %d secs\n", _res.retrans);
+	printf("Number of retries: %d\n", _res.retry);
+
+	printf("Number of addresses: %d\n", _res.nscount);
+	for (i = 0; i < _res.nscount; i++)
+		printf("%s\n", inet_ntoa(nslist(i).sin_addr));
+
+/*
+ * The resolver options are initialized by res_init() to contain the
+ * defaults settings (RES_RECURSE | RES_DEFNAMES | RES_DNSRCH)
+ * The various options have the following meaning:
+ *
+ *	RES_INIT	set after res_init() has been called
+ *	RES_DEBUG	let the resolver modules print debugging info
+ *	RES_AAONLY	want authoritative answers only (not implemented)
+ *	RES_USEVC	use tcp virtual circuit instead of udp datagrams
+ *	RES_PRIMARY	use primary nameserver only (not implemented)
+ *	RES_IGNTC	ignore datagram truncation; don't switch to tcp
+ *	RES_RECURSE	forward query if answer not locally available
+ *	RES_DEFNAMES	add default domain to queryname without dot
+ *	RES_STAYOPEN	keep tcp socket open for subsequent queries
+ *	RES_DNSRCH	append search domains even to queryname with dot
+ */
+	printf("Options set:");
+	if (bitset(RES_INIT,      _res.options)) printf(" INIT");
+	if (bitset(RES_DEBUG,     _res.options)) printf(" DEBUG");
+	if (bitset(RES_AAONLY,    _res.options)) printf(" AAONLY");
+	if (bitset(RES_USEVC,     _res.options)) printf(" USEVC");
+	if (bitset(RES_PRIMARY,   _res.options)) printf(" PRIMARY");
+	if (bitset(RES_IGNTC,     _res.options)) printf(" IGNTC");
+	if (bitset(RES_RECURSE,   _res.options)) printf(" RECURSE");
+	if (bitset(RES_DEFNAMES,  _res.options)) printf(" DEFNAMES");
+	if (bitset(RES_STAYOPEN,  _res.options)) printf(" STAYOPEN");
+	if (bitset(RES_DNSRCH,    _res.options)) printf(" DNSRCH");
+	printf("\n");
+
+	printf("Options clr:");
+	if (!bitset(RES_INIT,     _res.options)) printf(" INIT");
+	if (!bitset(RES_DEBUG,    _res.options)) printf(" DEBUG");
+	if (!bitset(RES_AAONLY,   _res.options)) printf(" AAONLY");
+	if (!bitset(RES_USEVC,    _res.options)) printf(" USEVC");
+	if (!bitset(RES_PRIMARY,  _res.options)) printf(" PRIMARY");
+	if (!bitset(RES_IGNTC,    _res.options)) printf(" IGNTC");
+	if (!bitset(RES_RECURSE,  _res.options)) printf(" RECURSE");
+	if (!bitset(RES_DEFNAMES, _res.options)) printf(" DEFNAMES");
+	if (!bitset(RES_STAYOPEN, _res.options)) printf(" STAYOPEN");
+	if (!bitset(RES_DNSRCH,   _res.options)) printf(" DNSRCH");
+	printf("\n");
+
+/*
+ * The new BIND 4.9.3 has additional features which are not (yet) used.
+ */
+	printf("\n");
+}
+
+/*
+** PRINT_STATISTICS -- Print resource record statistics
+** ----------------------------------------------------
+**
+**	Returns:
+**		None.
+**
+**	Inputs:
+**		The record_stats[] counts have been updated by print_rrec().
+*/
+
+void
+print_statistics(name, filter, class)
+input char *name;			/* name of zone we are listing */
+input int filter;			/* type of records we want to see */
+input int class;			/* class of records we want to see */
+{
+	register int type;
+	int nrecords;
+
+	for (type = T_FIRST; type <= T_LAST; type++)
+	{
+		nrecords = record_stats[type];
+		if (nrecords > 0 || ((filter != T_ANY) && want_type(type, filter)))
+		{
+			printf("Found %4d %-5s record%-1s", nrecords,
+				pr_type(type), plural(nrecords));
+
+			if (class != C_IN)
+				printf(" in class %s", pr_class(class));
+
+			printf(" within %s\n", name);
+		}
+	}
+}
+
+
+/*
+** CLEAR_STATISTICS -- Clear resource record statistics
+** ----------------------------------------------------
+**
+**	Returns:
+**		None.
+*/
+
+void
+clear_statistics()
+{
+	bzero((char *)record_stats, sizeof(record_stats));
+}
+
+/*
+** SHOW_TYPES -- Show resource record types wanted
+** -----------------------------------------------
+**
+**	Returns:
+**		None.
+*/
+
+void
+show_types(name, filter, class)
+input char *name;			/* name we want to query about */
+input int filter;			/* type of records we want to see */
+input int class;			/* class of records we want to see */
+{
+	register int type;
+
+	if (filter >= T_NONE)
+	{
+		printf("Query about %s for record types", name);
+
+		if (filter == T_ANY)
+			printf(" %s", pr_type(T_ANY));
+		else
+			for (type = T_FIRST; type <= T_LAST; type++)
+				if (want_type(type, filter))
+					printf(" %s", pr_type(type));
+
+		if (class != C_IN)
+			printf(" in class %s", pr_class(class));
+
+		printf("\n");
+	}
+}
+
+/*
+** NS_ERROR -- Print error message from errno and h_errno
+** ------------------------------------------------------
+**
+**	Returns:
+**		None.
+**
+** If BIND res_send() fails, it will leave errno in either of the first
+** two following states when using datagrams. Note that this depends on
+** the proper handling of connected datagram sockets, which is usually
+** true if BSD >= 43 (see res_send.c for details; it may need a patch).
+** Note. If the 4.8 version succeeds, it may leave errno as EAFNOSUPPORT
+** if it has disconnected a previously connected datagram socket, since
+** the dummy address used to disconnect does not have a proper family set.
+** Always clear errno after getting a reply, or patch res_send().
+** Our private version of res_send() will leave also other error statuses.
+*/
+
+void
+ns_error(name, type, class, host) 
+input char *name;			/* full name we queried about */
+input int type;				/* record type we queried about */
+input int class;			/* record class we queried about */
+input char *host;			/* set if explicit server was used */
+{
+	static char *auth = "Authoritative answer";
+
+/*
+ * Print the message associated with the network related errno values.
+ */
+	switch (errno)
+	{
+	    case ECONNREFUSED:
+		/*
+		 * The contacted host does not have a nameserver running.
+		 * The standard res_send() also returns this if none of
+		 * the intended hosts could be reached via datagrams.
+		 */
+		if (host != NULL)
+			errmsg("Nameserver %s not running", host);
+		else
+			errmsg("Nameserver not running");
+		break;
+
+	    case ETIMEDOUT:
+		/*
+		 * The contacted server did not give any reply at all
+		 * within the specified time frame.
+		 */
+		if (host != NULL)
+			errmsg("Nameserver %s not responding", host);
+		else
+			errmsg("Nameserver not responding");
+		break;
+
+	    case ENETDOWN:
+	    case ENETUNREACH:
+	    case EHOSTDOWN:
+	    case EHOSTUNREACH:
+		/*
+		 * The host to be contacted or its network can not be reached.
+		 * Our private res_send() also returns this using datagrams.
+		 */
+		if (host != NULL)
+			errmsg("Nameserver %s not reachable", host);
+		else
+			errmsg("Nameserver not reachable");
+		break;
+	}
+
+/*
+ * Print the message associated with the particular nameserver error.
+ */
+	switch (h_errno)
+	{
+	    case HOST_NOT_FOUND:
+		/*
+		 * The specified name does definitely not exist at all.
+		 * In this case the answer is always authoritative.
+		 * Nameserver status: NXDOMAIN
+		 */
+		if (class != C_IN)
+			errmsg("%s does not exist in class %s (%s)",
+				name, pr_class(class), auth);
+		else if (host != NULL)
+			errmsg("%s does not exist at %s (%s)",
+				name, host, auth);
+		else
+			errmsg("%s does not exist (%s)",
+				name, auth);
+		break;
+
+	    case NO_HOST:
+		/*
+		 * The specified name does not exist, but the answer
+		 * was not authoritative, so it is still undecided.
+		 * Nameserver status: NXDOMAIN
+		 */
+		if (class != C_IN)
+			errmsg("%s does not exist in class %s, try again",
+				name, pr_class(class));
+		else if (host != NULL)
+			errmsg("%s does not exist at %s, try again",
+				name, host);
+		else
+			errmsg("%s does not exist, try again",
+				name);
+		break;
+
+	    case NO_DATA:
+		/*
+		 * The name is valid, but the specified type does not exist.
+		 * This status is here returned only in case authoritative.
+		 * Nameserver status: NOERROR
+		 */
+		if (class != C_IN)
+			errmsg("%s has no %s record in class %s (%s)",
+				name, pr_type(type), pr_class(class), auth);
+		else if (host != NULL)
+			errmsg("%s has no %s record at %s (%s)",
+				name, pr_type(type), host, auth);
+		else
+			errmsg("%s has no %s record (%s)",
+				name, pr_type(type), auth);
+		break;
+
+	    case NO_RREC:
+		/*
+		 * The specified type does not exist, but we don't know whether
+		 * the name is valid or not. The answer was not authoritative.
+		 * Perhaps recursion was off, and no data was cached locally.
+		 * Nameserver status: NOERROR
+		 */
+		if (class != C_IN)
+			errmsg("%s %s record in class %s currently not present",
+				name, pr_type(type), pr_class(class));
+		else if (host != NULL)
+			errmsg("%s %s record currently not present at %s",
+				name, pr_type(type), host);
+		else
+			errmsg("%s %s record currently not present",
+				name, pr_type(type));
+		break;
+
+	    case TRY_AGAIN:
+		/*
+		 * Some intermediate failure, e.g. connect timeout,
+		 * or some local operating system transient errors.
+		 * General failure to reach any appropriate servers.
+		 * The status SERVFAIL now yields a separate error code.
+		 * Nameserver status: (SERVFAIL)
+		 */
+		if (class != C_IN)
+			errmsg("%s %s record in class %s not found, try again",
+				name, pr_type(type), pr_class(class));
+		else if (host != NULL)
+			errmsg("%s %s record not found at %s, try again",
+				name, pr_type(type), host);
+		else
+			errmsg("%s %s record not found, try again",
+				name, pr_type(type));
+		break;
+
+	    case SERVER_FAILURE:
+		/*
+		 * Explicit server failure status. This will be returned upon
+		 * some internal server errors, forwarding failures, or when
+		 * the server is not authoritative for a specific class.
+		 * Also if the zone data has expired at a secondary server.
+		 * Nameserver status: SERVFAIL
+		 */
+		if (class != C_IN)
+			errmsg("%s %s record in class %s not found, server failure",
+				name, pr_type(type), pr_class(class));
+		else if (host != NULL)
+			errmsg("%s %s record not found at %s, server failure",
+				name, pr_type(type), host);
+		else
+			errmsg("%s %s record not found, server failure",
+				name, pr_type(type));
+		break;
+
+	    case NO_RECOVERY:
+		/*
+		 * Some irrecoverable format error, or server refusal.
+		 * The status REFUSED now yields a separate error code.
+		 * Nameserver status: (REFUSED) FORMERR NOTIMP NOCHANGE
+		 */
+		if (class != C_IN)
+			errmsg("%s %s record in class %s not found, no recovery",
+				name, pr_type(type), pr_class(class));
+		else if (host != NULL)
+			errmsg("%s %s record not found at %s, no recovery",
+				name, pr_type(type), host);
+		else
+			errmsg("%s %s record not found, no recovery",
+				name, pr_type(type));
+		break;
+
+	    case QUERY_REFUSED:
+		/*
+		 * The server explicitly refused to answer the query.
+		 * Servers can be configured to disallow zone transfers.
+		 * Nameserver status: REFUSED
+		 */
+		if (class != C_IN)
+			errmsg("%s %s record in class %s query refused",
+				name, pr_type(type), pr_class(class));
+		else if (host != NULL)
+			errmsg("%s %s record query refused by %s",
+				name, pr_type(type), host);
+		else
+			errmsg("%s %s record query refused",
+				name, pr_type(type));
+		break;
+
+	    default:
+		/*
+		 * Unknown cause for server failure.
+		 */
+		if (class != C_IN)
+			errmsg("%s %s record in class %s not found",
+				name, pr_type(type), pr_class(class));
+		else if (host != NULL)
+			errmsg("%s %s record not found at %s",
+				name, pr_type(type), host);
+		else
+			errmsg("%s %s record not found",
+				name, pr_type(type));
+		break;
+	}
+}
+
+/*
+** DECODE_ERROR -- Convert nameserver error code to error message
+** --------------------------------------------------------------
+**
+**	Returns:
+**		Pointer to appropriate error message.
+*/
+
+char *
+decode_error(rcode)
+input int rcode;			/* error code from bp->rcode */
+{
+	switch (rcode)
+	{
+	    case NOERROR: 	return("no error");
+	    case FORMERR:	return("format error");
+	    case SERVFAIL:	return("server failure");
+	    case NXDOMAIN:	return("non-existent domain");
+	    case NOTIMP:	return("not implemented");
+	    case REFUSED:	return("query refused");
+	    case NOCHANGE:	return("no change");
+	}
+
+	return("unknown error");
+}
+
+/*
+** PRINT_STATUS -- Print result status after nameserver query
+** ----------------------------------------------------------
+**
+**	Returns:
+**		None.
+**
+**	Conditions:
+**		The size of the answer buffer must have been
+**		checked before to be of sufficient length,
+**		i.e. to contain at least the buffer header.
+*/
+
+void
+print_status(answerbuf, answerlen)
+input querybuf *answerbuf;		/* location of answer buffer */
+input int answerlen;			/* length of answer buffer */
+{
+	HEADER *bp;
+	int ancount;
+	bool failed;
+
+	bp = (HEADER *)answerbuf;
+	ancount = ntohs(bp->ancount);
+	failed = (bp->rcode != NOERROR || ancount == 0);
+
+	printf("Query %s", failed ? "failed" : "done");
+
+	if (bp->tc || (answerlen > PACKETSZ))
+		printf(", %d byte%s", answerlen, plural(answerlen));
+
+	if (bp->tc)
+	{
+		if (answerlen > sizeof(querybuf))
+			printf(" (truncated to %d)", sizeof(querybuf));
+		else
+			printf(" (truncated)");
+	}
+
+	printf(", %d answer%s", ancount, plural(ancount));
+
+	printf(", %s", bp->aa ? "authoritative " : "");
+
+	printf("status: %s\n", decode_error((int)bp->rcode));
+}
+
+/*
+** PR_ERROR -- Print error message about encountered inconsistencies
+** -----------------------------------------------------------------
+**
+**	We are supposed to have an error condition which is fatal
+**	for normal continuation, and the message is always printed.
+**
+**	Returns:
+**		None.
+**
+**	Side effects:
+**		Increments the global error count.
+*/
+
+void /*VARARGS1*/
+pr_error(fmt, a, b, c, d)
+input char *fmt;			/* format of message */
+input char *a, *b, *c, *d;		/* optional arguments */
+{
+	(void) fprintf(stderr, " *** ");
+	(void) fprintf(stderr, fmt, a, b, c, d);
+	(void) fprintf(stderr, "\n");
+
+	/* flag an error */
+	errorcount++;
+}
+
+
+/*
+** PR_WARNING -- Print warning message about encountered inconsistencies
+** ---------------------------------------------------------------------
+**
+**	We are supposed to have an error condition which is non-fatal
+**	for normal continuation, and the message is suppressed in case
+**	quiet mode has been selected.
+**
+**	Returns:
+**		None.
+*/
+
+void /*VARARGS1*/
+pr_warning(fmt, a, b, c, d)
+input char *fmt;			/* format of message */
+input char *a, *b, *c, *d;		/* optional arguments */
+{
+	if (!quiet)
+	{
+		(void) fprintf(stderr, " !!! ");
+		(void) fprintf(stderr, fmt, a, b, c, d);
+		(void) fprintf(stderr, "\n");
+	}
+}
+
+/*
+** WANT_TYPE -- Indicate whether the rr type matches the desired filter
+** --------------------------------------------------------------------
+**
+**	Returns:
+**		true if the resource record type matches the filter.
+**		false otherwise.
+**
+**	In regular mode, the querytype is used to formulate the query,
+**	and the filter is set to T_ANY to filter out any response.
+**	In listmode, we get everything, so the filter is set to the
+**	querytype to filter out the proper responses.
+**	Note that T_NONE is the default querytype in listmode.
+*/
+
+bool
+want_type(type, filter)
+input int type;				/* resource record type */
+input int filter;			/* type of records we want to see */
+{
+	if (type == filter)
+		return(true);
+
+	if (filter == T_ANY)
+		return(true);
+
+	if (filter == T_NONE &&
+	   (type == T_A || type == T_NS || type == T_PTR))
+		return(true);
+
+	if (filter == T_MAILB &&
+	   (type == T_MB || type == T_MR || type == T_MG || type == T_MINFO))
+		return(true);
+
+	if (filter == T_MAILA &&
+	   (type == T_MD || type == T_MF))
+		return(true);
+
+	return(false);
+}
+
+/*
+** WANT_CLASS -- Indicate whether the rr class matches the desired filter
+** ----------------------------------------------------------------------
+**
+**	Returns:
+**		true if the resource record class matches the filter.
+**		false otherwise.
+**
+**	In regular mode, the queryclass is used to formulate the query,
+**	and the filter is set to C_ANY to filter out any response.
+**	In listmode, we get everything, so the filter is set to the
+**	queryclass to filter out the proper responses.
+**	Note that C_IN is the default queryclass in listmode.
+*/
+
+bool
+want_class(class, filter)
+input int class;			/* resource record class */
+input int filter;			/* class of records we want to see */
+{
+	if (class == filter)
+		return(true);
+
+	if (filter == C_ANY)
+		return(true);
+
+	return(false);
+}
+
+/*
+** INDOMAIN -- Check whether a name belongs to a zone
+** --------------------------------------------------
+**
+**	Returns:
+**		true if the given name lies anywhere in the zone, or
+**		if the given name is the same as the zone and may be so.
+**		false otherwise.
+*/
+
+bool
+indomain(name, domain, equal)
+input char *name;			/* the name under consideration */
+input char *domain;			/* the name of the zone */
+input bool equal;			/* set if name may be same as zone */
+{
+	register char *dot;
+
+	if (sameword(name, domain))
+		return(equal);
+
+	if (sameword(domain, "."))
+		return(true);
+
+	dot = index(name, '.');
+	while (dot != NULL)
+	{
+		if (!is_quoted(dot, name))
+		{
+			if (sameword(dot+1, domain))
+				return(true);
+		}
+
+		dot = index(dot+1, '.');
+	}
+
+	return(false);
+}
+
+/*
+** SAMEDOMAIN -- Check whether a name belongs to a zone
+** ----------------------------------------------------
+**
+**	Returns:
+**		true if the given name lies directly in the zone, or
+**		if the given name is the same as the zone and may be so.
+**		false otherwise.
+*/
+
+bool
+samedomain(name, domain, equal)
+input char *name;			/* the name under consideration */
+input char *domain;			/* the name of the zone */
+input bool equal;			/* set if name may be same as zone */
+{
+	register char *dot;
+
+	if (sameword(name, domain))
+		return(equal);
+
+	dot = index(name, '.');
+	while (dot != NULL)
+	{
+		if (!is_quoted(dot, name))
+		{
+			if (sameword(dot+1, domain))
+				return(true);
+
+			return(false);
+		}
+
+		dot = index(dot+1, '.');
+	}
+
+	if (sameword(domain, "."))
+		return(true);
+
+	return(false);
+}
+
+/*
+** GLUERECORD -- Check whether a name is a glue record
+** ---------------------------------------------------
+**
+**	Returns:
+**		true is this is a glue record.
+**		false otherwise.
+**
+**	The name is supposed to be the name of an address record.
+**	If it lies directly in the given zone, it is considered
+**	an ordinary host within that zone, and not a glue record.
+**	If it does not belong to the given zone at all, is it
+**	here considered to be a glue record.
+**	If it lies in the given zone, but not directly, it is
+**	considered a glue record if it belongs to any of the known
+**	delegated zones of the given zone.
+**	In the root zone itself are no hosts, only glue records.
+*/
+
+bool
+gluerecord(name, domain, zone, nzones)
+input char *name;			/* the name under consideration */
+input char *domain;			/* name of zone being processed */
+input char *zone[];			/* list of known delegated zones */
+input int nzones;			/* number of known delegated zones */
+{
+	register int n;
+
+	if (sameword(domain, "."))
+		return(true);
+
+	if (samedomain(name, domain, true))
+		return(false);
+
+	if (!indomain(name, domain, true))
+		return(true);
+
+	for (n = 0; n < nzones; n++)
+		if (indomain(name, zone[n], true))
+			return(true);
+
+	return(false);
+}
+
+/*
+** MATCHLABELS -- Determine number of matching domain name labels
+** --------------------------------------------------------------
+**
+**	Returns:
+**		Number of shared trailing components in both names.
+**
+**	Note. This routine is currently used only to compare nameserver
+**	names in the RHS of NS records, so there is no need to check
+**	for embedded quoted dots.
+*/
+
+int
+matchlabels(name, domain)
+input char *name;			/* domain name to check */
+input char *domain;			/* domain name to compare against */
+{
+	register int i, j;
+	int matched = 0;
+
+	i = strlength(name);
+	j = strlength(domain);
+
+	while (--i >= 0 && --j >= 0)
+	{
+		if (lowercase(name[i]) != lowercase(domain[j]))
+			break;
+		if (domain[j] == '.')
+			matched++;
+		else if (j == 0 && (i == 0 || name[i-1] == '.'))
+			matched++;
+	}
+
+	return(matched);
+}
+
+/*
+** PR_DOMAIN -- Convert domain name according to printing options
+** --------------------------------------------------------------
+**
+**	Returns:
+**		Pointer to new domain name, if conversion was done.
+**		Pointer to original name, if no conversion necessary.
+*/
+
+char *
+pr_domain(name, listing)
+input char *name;			/* domain name to be printed */
+input bool listing;			/* set if this is a zone listing */
+{
+	char *newname;			/* converted domain name */
+
+/*
+ * Print reverse nsap.int name in forward notation, unless prohibited.
+ */
+	if (revnsap && !dotprint)
+	{
+		newname = pr_nsap(name);
+		if (newname != name)
+			return(newname);
+	}
+
+/*
+ * Print domain names with trailing dot if necessary.
+ */
+	if (listing || dotprint)
+	{
+		newname = pr_dotname(name);
+		if (newname != name)
+			return(newname);
+	}
+
+/*
+ * No conversion was required, use original name.
+ */
+	return(name);
+}
+
+/*
+** PR_DOTNAME -- Return domain name with trailing dot
+** --------------------------------------------------
+**
+**	Returns:
+**		Pointer to new domain name, if dot was added.
+**		Pointer to original name, if dot was already present.
+*/
+
+char *
+pr_dotname(name)
+input char *name;			/* domain name to append to */
+{
+	static char buf[MAXDNAME+2];	/* buffer to store new domain name */
+	register int n;
+
+	n = strlength(name);
+	if (n > 0 && name[n-1] == '.')
+		return(name);
+
+	if (n > MAXDNAME)
+		n = MAXDNAME;
+
+	bcopy(name, buf, n);
+	buf[n] = '.';
+	buf[n+1] = '\0';
+	return(buf);
+}
+
+/*
+** PR_NSAP -- Convert reverse nsap.int to dotted forward notation
+** --------------------------------------------------------------
+**
+**	Returns:
+**		Pointer to new dotted nsap, if converted.
+**		Pointer to original name otherwise.
+*/
+
+char *
+pr_nsap(name)
+input char *name;			/* potential reverse nsap.int name */
+{
+	static char buf[3*MAXNSAP+1];
+	register char *p;
+	register int n;
+	register int i;
+
+	/* must begin with single hex digits separated by dots */
+	for (i = 0; is_xdigit(name[i]) && name[i+1] == '.'; i += 2)
+		continue;
+
+	/* must have an even number of hex digits */ 
+	if (i == 0 || (i % 4) != 0)
+		return(name);
+
+	/* but not too many */
+	if (i > 4*MAXNSAP)
+		return(name);
+
+	/* must end in the appropriate root domain */
+	if (!sameword(&name[i], NSAP_ROOT))
+		return(name);
+
+	for (p = buf, n = 0; i >= 4; i -= 4, n++)
+	{
+		*p++ = name[i-2];
+		*p++ = name[i-4];
+
+		/* add dots for readability */
+		if ((n % 2) == 0 && (i - 4) > 0)
+			*p++ = '.';
+	}
+	*p = '\0';
+
+	return(buf);
+}
+
+/*
+** PR_TYPE -- Return name of resource record type
+** ----------------------------------------------
+**
+**	Returns:
+**		Pointer to name of resource record type.
+**
+**	Note.	All possible (even obsolete) types are recognized.
+*/
+
+char *
+pr_type(type)
+input int type;				/* resource record type */
+{
+	static char buf[30];		/* sufficient for 64-bit values */
+
+	switch (type)
+	{
+		/* standard types */
+
+	    case T_A:       return("A");	/* internet address */
+	    case T_NS:      return("NS");	/* authoritative server */
+	    case T_MD:      return("MD");	/* mail destination */
+	    case T_MF:      return("MF");	/* mail forwarder */
+	    case T_CNAME:   return("CNAME");	/* canonical name */
+	    case T_SOA:     return("SOA");	/* start of auth zone */
+	    case T_MB:      return("MB");	/* mailbox domain name */
+	    case T_MG:      return("MG");	/* mail group member */
+	    case T_MR:      return("MR");	/* mail rename name */
+	    case T_NULL:    return("NULL");	/* null resource record */
+	    case T_WKS:     return("WKS");	/* well known service */
+	    case T_PTR:     return("PTR");	/* domain name pointer */
+	    case T_HINFO:   return("HINFO");	/* host information */
+	    case T_MINFO:   return("MINFO");	/* mailbox information */
+	    case T_MX:      return("MX");	/* mail routing info */
+	    case T_TXT:     return("TXT");	/* descriptive text */
+
+		/* new types */
+
+	    case T_RP:      return("RP");	/* responsible person */
+	    case T_AFSDB:   return("AFSDB");	/* afs database location */
+	    case T_X25:     return("X25");	/* x25 address */
+	    case T_ISDN:    return("ISDN");	/* isdn address */
+	    case T_RT:      return("RT");	/* route through host */
+	    case T_NSAP:    return("NSAP");	/* nsap address */
+	    case T_NSAPPTR: return("NSAP-PTR");	/* nsap pointer */
+	    case T_SIG:     return("SIG");	/* security signature */
+	    case T_KEY:     return("KEY");	/* security key */
+	    case T_PX:      return("PX");	/* rfc822 - x400 mapping */
+	    case T_GPOS:    return("GPOS");	/* geographical position */
+	    case T_AAAA:    return("AAAA");	/* ip v6 address */
+	    case T_LOC:     return("LOC");	/* geographical location */
+	    case T_NXT:     return("NXT");	/* next valid name */
+	    case T_EID:     return("EID");	/* endpoint identifier */
+	    case T_NIMLOC:  return("NIMLOC");	/* nimrod locator */
+	    case T_SRV:     return("SRV");	/* service info */
+	    case T_ATMA:    return("ATMA");	/* atm address */
+	    case T_NAPTR:   return("NAPTR");	/* naming authority urn */
+
+		/* nonstandard types */
+
+	    case T_UINFO:   return("UINFO");	/* user information */
+	    case T_UID:     return("UID");	/* user ident */
+	    case T_GID:     return("GID");	/* group ident */
+	    case T_UNSPEC:  return("UNSPEC");	/* unspecified binary data */
+
+		/* filters */
+
+	    case T_IXFR:    return("IXFR");	/* incremental zone transfer */
+	    case T_AXFR:    return("AXFR");	/* zone transfer */
+	    case T_MAILB:   return("MAILB");	/* matches MB/MR/MG/MINFO */
+	    case T_MAILA:   return("MAILA");	/* matches MD/MF */
+	    case T_ANY:     return("ANY");	/* matches any type */
+
+	    case T_NONE:    return("resource");	/* not yet determined */
+	}
+
+	/* unknown type */
+	(void) sprintf(buf, "%d", type);
+	return(buf);
+}
+
+/*
+** PR_CLASS -- Return name of resource record class
+** ------------------------------------------------
+**
+**	Returns:
+**		Pointer to name of resource record class.
+*/
+
+char *
+pr_class(class)
+input int class;			/* resource record class */
+{
+	static char buf[30];		/* sufficient for 64-bit values */
+
+	switch (class)
+	{
+	    case C_IN:      return("IN");	/* internet */
+	    case C_CSNET:   return("CS");	/* csnet */
+	    case C_CHAOS:   return("CH");	/* chaosnet */
+	    case C_HS:      return("HS");	/* hesiod */
+	    case C_ANY:     return("ANY");	/* any class */
+	}
+
+	/* unknown class */
+	(void) sprintf(buf, "%d", class);
+	return(buf);
+}
+
+/*
+** EXPAND_NAME -- Expand compressed domain name in a resource record
+** -----------------------------------------------------------------
+**
+**	Returns:
+**		Number of bytes advanced in answer buffer.
+**		-1 if there was a format error.
+**
+**	It is assumed that the specified buffer is of a fixed size
+**	MAXDNAME+1 that should be sufficient to store the data.
+*/
+
+int
+expand_name(name, type, cp, msg, eom, namebuf)
+input char *name;			/* name of resource record */
+input int type;				/* type of resource record */
+input u_char *cp;			/* current position in answer buf */
+input u_char *msg, *eom;		/* begin and end of answer buf */
+output char *namebuf;			/* location of buf to expand name in */
+{
+	register int n;
+
+	n = dn_expand(msg, eom, cp, (nbuf_t *)namebuf, MAXDNAME);
+	if (n < 0)
+	{
+		pr_error("expand error in %s record for %s, offset %s",
+			pr_type(type), name, itoa(cp - msg));
+		h_errno = NO_RECOVERY;
+		return(-1);
+	}
+
+	/* should not be necessary, but who knows */
+	namebuf[MAXDNAME] = '\0';
+
+	/* change root to single dot */
+	if (namebuf[0] == '\0')
+	{
+		namebuf[0] = '.';
+		namebuf[1] = '\0';
+	}
+
+	return(n);
+}
+
+/*
+** CHECK_SIZE -- Check whether resource record is of sufficient length
+** -------------------------------------------------------------------
+**
+**	Returns:
+**		Requested size if current record is long enough.
+**		-1 if current record does not have this many bytes.
+**
+**	Note that HINFO records are very often incomplete since only
+**	one of the two data fields has been filled in and the second
+**	field is missing. So we generate only a warning message.
+*/
+
+int
+check_size(name, type, cp, msg, eor, size)
+input char *name;			/* name of resource record */
+input int type;				/* type of resource record */
+input u_char *cp;			/* current position in answer buf */
+input u_char *msg;			/* begin of answer buf */
+input u_char *eor;			/* predicted position of next record */
+input int size;				/* required record size remaining */
+{
+	if (cp + size > eor)
+	{
+		if (type != T_HINFO)
+			pr_error("incomplete %s record for %s, offset %s",
+				pr_type(type), name, itoa(cp - msg));
+		else
+			pr_warning("incomplete %s record for %s",
+				pr_type(type), name);
+		h_errno = NO_RECOVERY;
+		return(-1);
+	}
+
+	return(size);
+}
+
+/*
+** VALID_NAME -- Check whether domain name contains invalid characters
+** -------------------------------------------------------------------
+**
+**	Returns:
+**		true if the name is valid.
+**		false otherwise.
+**
+**	The total size of a compound name should not exceed MAXDNAME.
+**	We assume that this is true. Its individual components between
+**	dots should not be longer than 64. This is not checked here.
+**
+**	Only alphanumeric characters and dash '-' may be used (dash
+**	only in the middle). We only check the individual characters.
+**	Strictly speaking, this restriction is only for ``host names''.
+**	The underscore is illegal, at least not recommended, but is
+**	so abundant that it requires special processing.
+**
+**	If the domain name represents a mailbox specification, the
+**	first label up to the first (unquoted) dot is the local part
+**	of a mail address, which should adhere to the RFC 822 specs.
+**	This first dot takes the place of the RFC 822 '@@' sign.
+**
+**	The label '*' can in principle be used anywhere to indicate
+**	wildcarding. It is valid only in the LHS resource record name,
+**	in definitions in zone files only as the first component.
+**	Used primarily in wildcard MX record definitions.
+**
+**	Note. This routine is much too liberal.
+*/
+
+char *specials = ".()<>@@,;:\\\"[]";	/* RFC 822 specials */
+
+bool
+valid_name(name, wildcard, localpart, underscore)
+input char *name;			/* domain name to check */
+input bool wildcard;			/* set if wildcard is allowed */
+input bool localpart;			/* set if this is a mailbox spec */
+input bool underscore;			/* set if underscores are allowed */
+{
+	bool backslash = false;
+	bool quoting = false;
+	register char *p;
+	register char c;
+
+	for (p = name; (c = *p) != '\0'; p++)
+	{
+		/* special check for local part in mailbox */
+		if (localpart)
+		{
+			if (backslash)
+				backslash = false;	/* escape this char */
+			else if (c == '\\')
+				backslash = true;	/* escape next char */
+			else if (c == '"')
+				quoting = !quoting;	/* start/stop quoting */
+			else if (quoting)
+				continue;		/* allow quoted chars */
+			else if (c == '.')
+				localpart = false;	/* instead of '@@' */
+			else if (c == '@@')
+				return(false);		/* should be '.' */
+			else if (in_string(specials, c))
+				return(false);		/* must be escaped */
+			else if (is_space(c))
+				return(false);		/* must be escaped */
+			continue;
+		}
+
+		/* basic character set */
+		if (is_alnum(c) || (c == '-'))
+			continue;
+
+		/* start of a new component */
+		if (c == '.')
+			continue;
+
+		/* allow '*' for use in wildcard names */
+		if ((c == '*') && (p == name && p[1] == '.') && wildcard)
+			continue;
+
+		/* ignore underscore in certain circumstances */
+		if ((c == '_') && underscore && !illegal)
+			continue;
+
+		/* silently allowed widespread exceptions */
+		if (illegal && in_string(illegal, c))
+			continue;
+
+		return(false);
+	}
+
+	/* must be beyond the local part in a mailbox */
+	if (localpart)
+		return(false);
+
+	return(true);
+}
+
+/* 
+** CANONICAL -- Check whether domain name is a canonical host name
+** ---------------------------------------------------------------
+**
+**	Returns:
+**		Nonzero if the name is definitely not canonical.
+**		0 if it is canonical, or if it remains undecided.
+*/
+
+int
+canonical(name)
+input char *name;			/* the domain name to check */
+{
+	struct hostent *hp;
+	int status;
+	int save_errno;
+	int save_herrno;
+	
+/*
+ * Preserve state when querying, to avoid clobbering current values.
+ */
+	save_errno = errno;
+	save_herrno = h_errno;
+
+	hp = geth_byname(name);
+	status = h_errno;
+
+	errno = save_errno;
+	h_errno = save_herrno;
+
+/*
+ * Indicate negative result only after definitive lookup failures.
+ */
+	if (hp == NULL)
+	{
+		/* authoritative denial -- not existing or no A record */
+		if (status == NO_DATA || status == HOST_NOT_FOUND)
+			return(status);
+
+		/* nameserver failure -- still undecided, assume ok */
+		return(0);
+	}
+
+/*
+ * The given name exists and there is an associated A record.
+ * The name of this A record should be the name we queried about.
+ * If this is not the case we probably supplied a CNAME.
+ */
+	status = sameword(hp->h_name, name) ? 0 : HOST_NOT_CANON;
+	return(status);
+}
+
+/* 
+** MAPREVERSE -- Check whether address maps back to given domain
+** -------------------------------------------------------------
+**
+**	Returns:
+**		NULL if address could definitively not be mapped.
+**		Given name if the address maps back properly, or
+**		in case of transient nameserver failures.
+**		Reverse name if it differs from the given name.
+*/
+
+char *
+mapreverse(name, inaddr)
+input char *name;			/* domain name of A record */
+input struct in_addr inaddr;		/* address of A record to check */
+{
+	struct hostent *hp;
+	int status;
+	int save_errno;
+	int save_herrno;
+	
+/*
+ * Preserve state when querying, to avoid clobbering current values.
+ */
+	save_errno = errno;
+	save_herrno = h_errno;
+
+	hp = geth_byaddr((char *)&inaddr, INADDRSZ, AF_INET);
+	status = h_errno;
+
+	errno = save_errno;
+	h_errno = save_herrno;
+
+/*
+ * Indicate negative result only after definitive lookup failures.
+ */
+	if (hp == NULL)
+	{
+		/* authoritative denial -- not existing or no PTR record */
+		if (status == NO_DATA || status == HOST_NOT_FOUND)
+			return(NULL);
+
+		/* nameserver failure -- still undecided, assume ok */
+		return(name);
+	}
+
+/*
+ * Indicate whether the reverse mapping yields the given name.
+ */
+	return(sameword(hp->h_name, name) ? name : hp->h_name);
+}
+
+/* 
+** COMPARE_NAME -- Compare two names wrt alphabetical order
+** --------------------------------------------------------
+**
+**	Returns:
+**		Value of case-insensitive comparison.
+*/
+
+int
+compare_name(a, b)
+input const ptr_t *a;			/* first name */
+input const ptr_t *b;			/* second name */
+{
+	return(strcasecmp(*(char **)a, *(char **)b));
+}
+
+/*
+** XALLOC -- Allocate or reallocate additional memory
+** --------------------------------------------------
+**
+**	Returns:
+**		Pointer to (re)allocated buffer space.
+**		Aborts if the requested memory could not be obtained.
+*/
+
+ptr_t *
+xalloc(buf, size)
+register ptr_t *buf;			/* current start of buffer space */
+input siz_t size;			/* number of bytes to allocate */
+{
+	if (buf == NULL)
+		buf = malloc(size);
+	else
+		buf = realloc(buf, size);
+
+	if (buf == NULL)
+	{
+		errmsg("Out of memory");
+		exit(EX_OSERR);
+	}
+
+	return(buf);
+}
+
+/*
+** ITOA -- Convert value to decimal integer ascii string
+** -----------------------------------------------------
+**
+**	Returns:
+**		Pointer to string.
+*/
+
+char *
+itoa(n)
+input int n;				/* value to convert */
+{
+	static char buf[30];		/* sufficient for 64-bit values */
+
+	(void) sprintf(buf, "%d", n);
+	return(buf);
+}
+
+/*
+** UTOA -- Convert value to unsigned decimal ascii string
+** ------------------------------------------------------
+**
+**	Returns:
+**		Pointer to string.
+*/
+
+char *
+utoa(n)
+input int n;				/* value to convert */
+{
+	static char buf[30];		/* sufficient for 64-bit values */
+
+	(void) sprintf(buf, "%u", (unsigned)n);
+	return(buf);
+}
+
+/*
+** XTOA -- Convert value to hexadecimal ascii string
+** -------------------------------------------------
+**
+**	Returns:
+**		Pointer to string.
+*/
+
+char *
+xtoa(n)
+input int n;				/* value to convert */
+{
+	static char buf[17];		/* sufficient for 64-bit values */
+
+	(void) sprintf(buf, "%X", (unsigned)n);
+	return(buf);
+}
+
+/*
+** STOA -- Extract partial ascii string, escape if necessary
+** ---------------------------------------------------------
+**
+**	Returns:
+**		Pointer to string.
+*/
+
+char *
+stoa(cp, size, escape)
+input u_char *cp;			/* current position in answer buf */
+input int size;				/* number of bytes to extract */
+input bool escape;			/* escape special characters if set */
+{
+	static char buf[2*MAXDLEN+1];
+	register char *p;
+	register char c;
+	register int i;
+
+	if (size > MAXDLEN)
+		size = MAXDLEN;
+
+	for (p = buf, i = 0; i < size; i++)
+	{
+		c = *cp++;
+		if (escape && (c == '\n' || c == '\\' || c == '"'))
+			*p++ = '\\';
+		*p++ = c;
+	}
+	*p = '\0';
+
+	return(buf);
+}
+
+/*
+** BASE_NTOA -- Convert binary data to base64 ascii
+** ------------------------------------------------
+**
+**	Returns:
+**		Pointer to string.
+**
+**	This routine is used to convert encoded keys and signatures
+**	in T_KEY and T_SIG resource records.
+*/
+
+char b64tab[] =
+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+
+char *
+base_ntoa(cp, size)
+input u_char *cp;			/* current position in answer buf */
+input int size;				/* number of bytes to extract */
+{
+	static char buf[MAXB64SIZE+1];
+	register char *p;
+	int c1, c2, c3, c4;
+
+	if (size > MAXMD5SIZE)
+		size = MAXMD5SIZE;
+
+	for (p = buf; size > 2; cp += 3, size -= 3)
+	{
+		c1 = (((int)cp[0] >> 2) & 0x3f);
+		c2 = (((int)cp[0] & 0x03) << 4) + (((int)cp[1] >> 4) & 0x0f);
+		c3 = (((int)cp[1] & 0x0f) << 2) + (((int)cp[2] >> 6) & 0x03);
+		c4 =  ((int)cp[2] & 0x3f);
+
+		*p++ = b64tab[c1];
+		*p++ = b64tab[c2];
+		*p++ = b64tab[c3];
+		*p++ = b64tab[c4];
+	}
+    
+	if (size == 2)
+	{
+		c1 = (((int)cp[0] >> 2) & 0x3f);
+		c2 = (((int)cp[0] & 0x03) << 4) + (((int)cp[1] >> 4) & 0x0f);
+		c3 = (((int)cp[1] & 0x0f) << 2);
+
+		*p++ = b64tab[c1];
+		*p++ = b64tab[c2];
+		*p++ = b64tab[c3];
+		*p++ = '=';
+	}
+	else if (size == 1)
+	{
+		c1 = (((int)cp[0] >> 2) & 0x3f);
+		c2 = (((int)cp[0] & 0x03) << 4);
+
+		*p++ = b64tab[c1];
+		*p++ = b64tab[c2];
+		*p++ = '=';
+		*p++ = '=';
+	}
+	*p = '\0';
+
+	return(buf);
+}
+
+/*
+** NSAP_NTOA -- Convert binary nsap address to ascii
+** -------------------------------------------------
+**
+**	Returns:
+**		Pointer to string.
+**
+**	As per RFC 1637 an nsap address is encoded in binary form
+**	in the resource record. It was unclear from RFC 1348 how
+**	the encoding should be. RFC 1629 defines an upper bound
+**	of 20 bytes to the size of a binary nsap address.
+*/
+
+char *
+nsap_ntoa(cp, size)
+input u_char *cp;			/* current position in answer buf */
+input int size;				/* number of bytes to extract */
+{
+	static char buf[3*MAXNSAP+1];
+	register char *p;
+	register int n;
+	register int i;
+
+	if (size > MAXNSAP)
+		size = MAXNSAP;
+
+	for (p = buf, i = 0; i < size; i++, cp++)
+	{
+		n = ((int)(*cp) >> 4) & 0x0f;
+		*p++ = hexdigit(n);
+		n = ((int)(*cp) >> 0) & 0x0f;
+		*p++ = hexdigit(n);
+
+		/* add dots for readability */
+		if ((i % 2) == 0 && (i + 1) < size)
+			*p++ = '.';
+	}
+	*p = '\0';
+
+	return(buf);
+}
+
+/*
+** IPNG_NTOA -- Convert binary ip v6 address to ascii
+** --------------------------------------------------
+**
+**	Returns:
+**		Pointer to string.
+**
+**	As per RFC 1886 an ip v6 address is encoded in binary form
+**	in the resource record. The size is fixed.
+*/
+
+char *
+ipng_ntoa(cp)
+input u_char *cp;			/* current position in answer buf */
+{
+	static char buf[5*(IPNGSIZE/2)+1];
+	register char *p;
+	register int n;
+	register int i;
+
+	for (p = buf, i = 0; i < IPNGSIZE/2; i++)
+	{
+		n = _getshort(cp);
+		cp += INT16SZ;
+
+		(void) sprintf(p, ":%X", n);
+		p += strlength(p);
+	}
+	*p = '\0';
+
+	return(buf + 1);
+}
+
+/*
+** PR_DATE -- Produce printable version of a clock value
+** -----------------------------------------------------
+**
+**	Returns:
+**		Pointer to string.
+**
+**	The value is a standard absolute clock value.
+*/
+
+char *
+pr_date(value)
+input int value;			/* the clock value to be converted */
+{
+	static char buf[sizeof("YYYYMMDDHHMMSS")+1];
+	time_t clocktime = value;
+	struct tm *t;
+	
+	t = gmtime(&clocktime);
+	t->tm_year += 1900;
+	t->tm_mon += 1;
+
+	(void) sprintf(buf, "%04d%02d%02d%02d%02d%02d",
+		t->tm_year, t->tm_mon, t->tm_mday,
+		t->tm_hour, t->tm_min, t->tm_sec);
+
+	return(buf);
+}
+
+/*
+** PR_TIME -- Produce printable version of a time interval
+** -------------------------------------------------------
+**
+**	Returns:
+**		Pointer to a string version of interval.
+**
+**	The value is a time interval expressed in seconds.
+*/
+
+char *
+pr_time(value, brief)
+input int value;			/* the interval to be converted */
+input bool brief;			/* use brief format if set */
+{
+	static char buf[256];
+	register char *p = buf;
+	int week, days, hour, mins, secs;
+
+	/* special cases */
+	if (value < 0)
+		return("negative");
+	if ((value == 0) && !brief)
+		return("zero seconds");
+
+/*
+ * Decode the components.
+ */
+	secs = value % 60; value /= 60;
+	mins = value % 60; value /= 60;
+	hour = value % 24; value /= 24;
+	days = value;
+
+	if (!brief)
+	{
+		days = value % 7; value /= 7;
+		week = value;
+	}
+
+/*
+ * Now turn it into a sexy form.
+ */
+	if (brief)
+	{
+		if (days > 0)
+		{
+			(void) sprintf(p, "%d+", days);
+			p += strlength(p);
+		}
+
+		(void) sprintf(p, "%02d:%02d:%02d", hour, mins, secs);
+		return(buf);
+	}
+
+	if (week > 0)
+	{
+		(void) sprintf(p, ", %d week%s", week, plural(week));
+		p += strlength(p);
+	}
+
+	if (days > 0)
+	{
+		(void) sprintf(p, ", %d day%s", days, plural(days));
+		p += strlength(p);
+	}
+
+	if (hour > 0)
+	{
+		(void) sprintf(p, ", %d hour%s", hour, plural(hour));
+		p += strlength(p);
+	}
+
+	if (mins > 0)
+	{
+		(void) sprintf(p, ", %d minute%s", mins, plural(mins));
+		p += strlength(p);
+	}
+
+	if (secs > 0)
+	{
+		(void) sprintf(p, ", %d second%s", secs, plural(secs));
+		/* p += strlength(p); */
+	}
+
+	return(buf + 2);
+}
+
+/*
+** PR_SPHERICAL -- Produce printable version of a spherical location
+** -----------------------------------------------------------------
+**
+**	Returns:
+**		Pointer to a string version of location.
+**
+**	The value is a spherical location (latitude or longitude)
+**	expressed in thousandths of a second of arc.
+**	The value 2^31 represents zero (equator or prime meridian).
+*/
+
+char *
+pr_spherical(value, pos, neg)
+input int value;			/* the location to be converted */
+input char *pos;			/* suffix if value positive */
+input char *neg;			/* suffix if value negative */
+{
+	static char buf[256];
+	register char *p = buf;
+	char *direction;
+	int degrees, minutes, seconds, fracsec;
+
+/*
+ * Normalize.
+ */
+	value -= (int)((unsigned)1 << 31);
+
+	direction = pos;
+	if (value < 0)
+	{
+		direction = neg;
+		value = -value;
+	}
+
+/*
+ * Decode the components.
+ */
+	fracsec = value % 1000; value /= 1000;
+	seconds = value % 60;   value /= 60;
+	minutes = value % 60;   value /= 60;
+	degrees = value;
+
+/*
+ * Construct output string.
+ */
+	(void) sprintf(p, "%d", degrees);
+	p += strlength(p);
+
+	if (minutes > 0 || seconds > 0 || fracsec > 0)
+	{
+		(void) sprintf(p, " %02d", minutes);
+		p += strlength(p);
+	}
+
+	if (seconds > 0 || fracsec > 0)
+	{
+		(void) sprintf(p, " %02d", seconds);
+		p += strlength(p);
+	}
+
+	if (fracsec > 0)
+	{
+		(void) sprintf(p, ".%03d", fracsec);
+		p += strlength(p);
+	}
+
+	(void) sprintf(p, " %s", direction);
+
+	return(buf);
+}
+
+/*
+** PR_VERTICAL -- Produce printable version of a vertical location
+** ---------------------------------------------------------------
+**
+**	Returns:
+**		Pointer to a string version of location.
+**
+**	The value is an altitude expressed in centimeters, starting
+**	from a base 100000 meters below the GPS reference spheroid.
+**	This allows for the actual range [-10000000 .. 4293967296].
+*/
+
+char *
+pr_vertical(value, pos, neg)
+input int value;			/* the location to be converted */
+input char *pos;			/* prefix if value positive */
+input char *neg;			/* prefix if value negative */
+{
+	static char buf[256];
+	register char *p = buf;
+	char *direction;
+	int meters, centimeters;
+	unsigned int altitude;
+	unsigned int reference;
+
+/*
+ * Normalize.
+ */
+	altitude = value;
+	reference = 100000*100;
+
+	if (altitude < reference)
+	{
+		direction = neg;
+		altitude = reference - altitude;
+	}
+	else
+	{
+		direction = pos;
+		altitude = altitude - reference;
+	}
+
+/*
+ * Decode the components.
+ */
+	centimeters = altitude % 100; altitude /= 100;
+	meters = altitude;
+
+/*
+ * Construct output string.
+ */
+	(void) sprintf(p, "%s%d", direction, meters);
+	p += strlength(p);
+
+	if (centimeters > 0)
+		(void) sprintf(p, ".%02d", centimeters);
+
+	return(buf);
+}
+
+/*
+** PR_PRECISION -- Produce printable version of a location precision
+** -----------------------------------------------------------------
+**
+**	Returns:
+**		Pointer to a string version of precision.
+**
+**	The value is a precision expressed in centimeters, encoded
+**	as 4-bit mantissa and 4-bit power of 10 (each ranging 0-9).
+*/
+
+unsigned int poweroften[10] =
+{1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};
+
+char *
+pr_precision(value)
+input int value;			/* the precision to be converted */
+{
+	static char buf[256];
+	register char *p = buf;
+	int meters, centimeters;
+	unsigned int precision;
+	register int mantissa;
+	register int exponent;
+
+/*
+ * Normalize.
+ */
+	mantissa = ((value >> 4) & 0x0f) % 10;
+	exponent = ((value >> 0) & 0x0f) % 10;
+	precision = mantissa * poweroften[exponent];
+
+/*
+ * Decode the components.
+ */
+	centimeters = precision % 100; precision /= 100;
+	meters = precision;
+
+/*
+ * Construct output string.
+ */
+	(void) sprintf(p, "%d", meters);
+	p += strlength(p);
+
+	if (centimeters > 0)
+		(void) sprintf(p, ".%02d", centimeters);
+
+	return(buf);
+}
+
+/*
+** _RES_CONNECT -- Connect to a stream (virtual circuit) socket
+** ------------------------------------------------------------
+**
+**	Returns:
+**		0 if successfully connected.
+**		-1 in case of failure or timeout.
+**
+**	Note that we use _res.retrans to override the default
+**	connect timeout value.
+*/
+
+static jmp_buf timer_buf;
+
+static sigtype_t
+/*ARGSUSED*/
+timer(sig)
+int sig;
+{
+	longjmp(timer_buf, 1);
+	/*NOTREACHED*/
+}
+
+
+int
+_res_connect(sock, addr, addrlen)
+input int sock;
+input struct sockaddr_in *addr;		/* the server address to connect to */
+input int addrlen;
+{
+	if (setjmp(timer_buf) != 0)
+	{
+		errno = ETIMEDOUT;
+		setalarm(0);
+		return(-1);
+	}
+
+	(void) signal(SIGALRM, timer);
+	setalarm(_res.retrans);
+
+	if (connect(sock, (struct sockaddr *)addr, addrlen) < 0)
+	{
+		if (errno == EINTR)
+			errno = ETIMEDOUT;
+		setalarm(0);
+		return(-1);
+	}
+
+	setalarm(0);
+	return(0);
+}
+
+/*
+** _RES_WRITE -- Write the query buffer via a stream socket
+** --------------------------------------------------------
+**
+**	Returns:
+**		Length of buffer if successfully transmitted.
+**		-1 in case of failure (error message is issued).
+**
+**	The query is sent in two steps: first a single word with
+**	the length of the buffer, followed by the buffer itself.
+*/
+
+int
+_res_write(sock, addr, host, buf, bufsize)
+input int sock;
+input struct sockaddr_in *addr;		/* the server address to connect to */
+input char *host;			/* name of server to connect to */
+input char *buf;			/* location of formatted query buffer */
+input int bufsize;			/* length of query buffer */
+{
+	u_short len;
+
+/*
+ * Write the length of the query buffer.
+ */
+	/* len = htons(bufsize); */
+	putshort((u_short)bufsize, (u_char *)&len);
+
+	if (write(sock, (char *)&len, INT16SZ) != INT16SZ)
+	{
+		_res_perror(addr, host, "write query length");
+		return(-1);
+	}
+
+/*
+ * Write the query buffer itself.
+ */
+	if (write(sock, buf, bufsize) != bufsize)
+	{
+		_res_perror(addr, host, "write query");
+		return(-1);
+	}
+
+	return(bufsize);
+}
+
+/*
+** _RES_READ -- Read the answer buffer via a stream socket
+** -------------------------------------------------------
+**
+**	Returns:
+**		Length of (untruncated) answer if successfully received.
+**		-1 in case of failure (error message is issued).
+**
+**	The answer is read in two steps: first a single word which
+**	gives the length of the buffer, followed by the buffer itself.
+**	If the answer is too long to fit into the supplied buffer,
+**	only the portion that fits will be stored, the residu will be
+**	flushed, and the truncation flag will be set.
+**
+**	Note. The returned length is that of the *un*truncated answer,
+**	however, and not the amount of data that is actually available.
+**	This may give the caller a hint about new buffer reallocation.
+*/
+
+int
+_res_read(sock, addr, host, buf, bufsize)
+input int sock;
+input struct sockaddr_in *addr;		/* the server address to connect to */
+input char *host;			/* name of server to connect to */
+output char *buf;			/* location of buffer to store answer */
+input int bufsize;			/* maximum size of answer buffer */
+{
+	u_short len;
+	char *buffer;
+	int buflen;
+	int reslen;
+	register int n;
+
+	/* set stream timeout for recv_sock() */
+	timeout = READTIMEOUT;
+
+/*
+ * Read the length of answer buffer.
+ */
+	buffer = (char *)&len;
+	buflen = INT16SZ;
+
+	while (buflen > 0 && (n = recv_sock(sock, buffer, buflen)) > 0)
+	{
+		buffer += n;
+		buflen -= n;
+	}
+
+	if (buflen != 0)
+	{
+		_res_perror(addr, host, "read answer length");
+		return(-1);
+	}
+
+/*
+ * Terminate if length is zero.
+ */
+	/* len = ntohs(len); */
+	len = _getshort((u_char *)&len);
+	if (len == 0)
+		return(0);
+
+/*
+ * Check for truncation.
+ * Do not chop the returned length in case of buffer overflow.
+ */
+	reslen = 0;
+	if ((int)len > bufsize)
+	{
+		reslen = len - bufsize;
+		/* len = bufsize; */
+	}
+
+/*
+ * Read the answer buffer itself.
+ * Truncate the answer is the supplied buffer is not big enough.
+ */
+	buffer = buf;
+	buflen = (reslen > 0) ? bufsize : len;
+
+	while (buflen > 0 && (n = recv_sock(sock, buffer, buflen)) > 0)
+	{
+		buffer += n;
+		buflen -= n;
+	}
+
+	if (buflen != 0)
+	{
+		_res_perror(addr, host, "read answer");
+		return(-1);
+	}
+
+/*
+ * Discard the residu to keep connection in sync.
+ */
+	if (reslen > 0)
+	{
+		HEADER *bp = (HEADER *)buf;
+		char resbuf[PACKETSZ];
+
+		buffer = resbuf;
+		buflen = (reslen < sizeof(resbuf)) ? reslen : sizeof(resbuf);
+
+		while (reslen > 0 && (n = recv_sock(sock, buffer, buflen)) > 0)
+		{
+			reslen -= n;
+			buflen = (reslen < sizeof(resbuf)) ? reslen : sizeof(resbuf);
+		}
+
+		if (reslen != 0)
+		{
+			_res_perror(addr, host, "read residu");
+			return(-1);
+		}
+
+		if (bitset(RES_DEBUG, _res.options))
+			printf("%sresponse truncated to %d bytes\n", dbprefix, bufsize);
+
+		/* set truncation flag */
+		bp->tc = 1;
+	}
+
+	return(len);
+}
+
+/*
+** RECV_SOCK -- Read from stream or datagram socket with timeout
+** -------------------------------------------------------------
+**
+**	Returns:
+**		Length of buffer if successfully received.
+**		-1 in case of failure or timeout.
+**	Inputs:
+**		The global variable ``timeout'' should have been
+**		set with the desired timeout value in seconds.
+**	Outputs:
+**		Sets ``from'' to the address of the packet sender.
+*/
+
+static int
+recv_sock(sock, buffer, buflen)
+input int sock;
+output char *buffer;			/* current buffer address */
+input int buflen;			/* remaining buffer size */
+{
+	fd_set fds;
+	struct timeval wait;
+	socklen_t fromlen;
+	register int n;
+
+	wait.tv_sec = timeout;
+	wait.tv_usec = 0;
+rewait:
+	/* FD_ZERO(&fds); */
+	bzero((char *)&fds, sizeof(fds));
+	FD_SET(sock, &fds);
+
+	/* wait for the arrival of data, or timeout */
+	n = select(FD_SETSIZE, &fds, (fd_set *)NULL, (fd_set *)NULL, &wait);
+	if (n <= 0)
+	{
+		if (n < 0 && errno == EINTR)
+			goto rewait;
+		if (n == 0)
+			errno = ETIMEDOUT;
+		return(-1);
+	}
+reread:
+	/* fake an error if nothing was actually read */
+	fromlen = sizeof(from);
+	n = recvfrom(sock, buffer, buflen, 0, from_sa, &fromlen);
+	if (n < 0 && errno == EINTR)
+		goto reread;
+	if (n == 0)
+		errno = ECONNRESET;
+	return(n);
+}
+
+/*
+ * Alternative version for systems with broken networking code.
+ *
+ * The select() system call may fail on the solaris 2.4 platform
+ * without appropriate patches. However, these patches are reported
+ * to break client NFS.
+ *
+ * This version uses an alarm() instead of select(). This introduces
+ * additional system call overhead.
+ */
+
+#ifdef BROKEN_SELECT
+
+static int
+recv_sock(sock, buffer, buflen)
+input int sock;
+output char *buffer;			/* current buffer address */
+input int buflen;			/* remaining buffer size */
+{
+	int fromlen;
+	register int n;
+
+	if (setjmp(timer_buf) != 0)
+	{
+		errno = ETIMEDOUT;
+		setalarm(0);
+		return(-1);
+	}
+
+	(void) signal(SIGALRM, timer);
+	setalarm(timeout);
+reread:
+	/* fake an error if nothing was actually read */
+	fromlen = sizeof(from);
+	n = recvfrom(sock, buffer, buflen, 0, from_sa, &fromlen);
+	if (n < 0 && errno == EINTR)
+		goto reread;
+	if (n == 0)
+		errno = ECONNRESET;
+	setalarm(0);
+	return(n);
+}
+
+#endif /*BROKEN_SELECT*/
+
+/*
+** _RES_PERROR -- Issue perror message including host info
+** -------------------------------------------------------
+**
+**	Returns:
+**		None.
+*/
+
+void
+_res_perror(addr, host, message)
+input struct sockaddr_in *addr;		/* the server address to connect to */
+input char *host;			/* name of server to connect to */
+input char *message;			/* perror message string */
+{
+	int save_errno = errno;		/* preserve state */
+
+	/* prepend server address and name */
+	if (addr != NULL)
+		(void) fprintf(stderr, "%s ", inet_ntoa(addr->sin_addr));
+	if (host != NULL)
+		(void) fprintf(stderr, "(%s) ", host);
+
+	/* issue actual message */
+	errno = save_errno;
+	perror(message);
+
+	/* restore state */
+	errno = save_errno;
+}
+/*-	$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+ * from	$OpenBSD: host.c,v 1.4 2002/04/06 23:54:25 fgsch Exp $
+ *
+ * Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
+ * Copyright (c) by Eric Wassenaar, Nikhef-H, <e07@@nikhef.nl>
+ *
+ * Anyone who obtained a copy of this work is hereby permitted to freely use,
+ * distribute, modify, merge, sublicence, give away or sell it as long as the
+ * authors are given due credit and the following notice is retained:
+ *
+ * This work is provided "as is", with no explicit or implicit warranty what-
+ * soever. Use it only at your own risk. In no event may an author or contri-
+ * butor be held liable for any damage, directly or indirectly, that origina-
+ * ted through or is caused by creation or modification of this work.
+ */
+
+/*
+ *		Usage: host [options] name [server]
+ *		Usage: host [options] -x [name ...]
+ *		Usage: host [options] -X server [name ...]
+ *
+ * Regular command line options:
+ * ----------------------------
+ *
+ * -t type	specify query type; default is T_A for normal mode
+ * -a		specify query type T_ANY
+ * -v		print verbose messages (-vv is very verbose)
+ * -d		print debugging output (-dd prints even more)
+ *
+ * Special mode options.
+ * --------------------
+ *
+ * -l		special mode to generate zone listing for a zone
+ * -L level	do recursive zone listing/checking this level deep
+ * -p		use primary nameserver of zone for zone transfers
+ * -P server	give priority to preferred servers for zone transfers
+ * -N zone	do not perform zone transfer for these explicit zones
+ * -S		print zone resource record statistics
+ * -H		special mode to count hosts residing in a zone
+ * -G		same as -H but lists gateway hosts in addition
+ * -E		same as -H but lists extrazone hosts in addition
+ * -D		same as -H but lists duplicate hosts in addition
+ * -C		special mode to check SOA records for a zone
+ * -A		special mode to check reverse mappings of host addresses
+ *
+ * Miscellaneous options.
+ * ---------------------
+ *
+ * -f filename	log resource record output also in given file
+ * -F filename	same as -f, but exchange role of stdout and log file
+ * -I chars	chars are not considered illegal in domain names
+ * -i		generate reverse in-addr.arpa query for dotted quad
+ * -n		generate reverse nsap.int query for dotted nsap address
+ * -q		be quiet about some non-fatal errors
+ * -T		print ttl value during non-verbose output
+ * -Z		print selected RR output in full zone file format
+ *
+ * Seldom used options.
+ * -------------------
+ *
+ * -c class	specify query class; default is C_IN
+ * -e		exclude info from names that do not reside in the zone
+ * -m		specify query type T_MAILB and trace MB records
+ * -o		suppress resource record output to stdout
+ * -r		do not use recursion when querying nameserver
+ * -R		repeatedly add search domains to qualify queryname
+ * -s secs	specify timeout value in seconds; default is 2 * 5
+ * -u		use virtual circuit instead of datagram for queries
+ * -w		wait until nameserver becomes available
+ *
+ * Undocumented options. (Experimental, subject to change)
+ * --------------------
+ *
+ * -g length	only select names that are at least this long
+ * -B		enforce full BIND behavior during DNSRCH
+ * -M		special mode to list mailable delegated zones of zone
+ * -W		special mode to list wildcard records in a zone
+ * -z		special mode to list delegated zones in a zone
+ */
+
+static char Usage[] =
+"\
+Usage:	 host [-v] [-a] [-t querytype] [options] name [server]\n\
+Listing: host [-v] [-a] [-t querytype] [options] -l zone [server]\n\
+Hostcnt: host [-v] [opts] -H [-D] [-E] [-G] zone\n\
+Chk soa: host [-v] [opts] -C zone\n\
+Addrchk: host [-v] [opts] -A host\n\
+Listing opts: [-L level] [-S] [-A] [-p] [-P prefserver] [-N skipzone]\n\
+Common opts:  [-d] [-f|-F filename] [-I chars] [-i|-n] [-q] [-T] [-Z]\n\
+Other opts:   [-c class] [-e] [-m] [-o] [-r] [-R] [-s secs] [-u] [-w]\n\
+Ext. usage:   [-x [name ...]] [-X server [name ...]]\n\
+";
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
+char *version = "961113";
+
+#include <arpa/inet.h>
+#include <arpa/nameser.h>
+#include <ctype.h>
+#include <errno.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <resolv.h>
+#include <setjmp.h>
+#include <signal.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <time.h>
+#include <unistd.h>
+
+#ifndef NO_DATA
+#define NO_DATA	NO_ADDRESS	/* used here only in case authoritative */
+#endif
+#define NO_RREC	(NO_DATA + 1)	/* used for non-authoritative NO_DATA */
+#define NO_HOST	(NO_DATA + 2)	/* used for non-authoritative HOST_NOT_FOUND */
+#define QUERY_REFUSED  (NO_DATA + 3)	/* query was refused by server */
+#define SERVER_FAILURE (NO_DATA + 4)	/* instead of TRY_AGAIN upon SERVFAIL */
+#define HOST_NOT_CANON (NO_DATA + 5)	/* host name is not canonical */
+#define T_NONE	0		/* yet unspecified resource record type */
+#define T_FIRST	T_A		/* first possible type in resource record */
+#define T_LAST	(T_IXFR - 1)	/* last  possible type in resource record */
+#ifndef NOCHANGE
+#define NOCHANGE 0xf		/* compatibility with older BIND versions */
+#endif
+#define NOT_DOTTED_QUAD	((ipaddr_t)-1)
+#define BROADCAST_ADDR	((ipaddr_t)0xffffffff)
+#define LOCALHOST_ADDR	((ipaddr_t)0x7f000001)
+#if PACKETSZ > 8192
+#define MAXPACKET PACKETSZ	/* PACKETSZ should be the max udp size (512) */
+#else
+#define MAXPACKET 8192		/* but tcp packets can be considerably larger */
+#endif
+#ifndef HFIXEDSZ
+#define HFIXEDSZ 12		/* actually sizeof(HEADER) */
+#endif
+#define MAXDLEN (MAXPACKET - HFIXEDSZ)	/* upper bound for dlen */
+#define STDERR	2
+#define STDIN	0
+#define STDOUT	1
+#define assert(condition)
+#define bitset(a,b)	(((a) & (b)) != 0)
+#define fakeaddr(a)	(nulladdr(a) || ((a) == htonl(LOCALHOST_ADDR)))
+#define fakename(a)	(samehead(a,"localhost.") || samehead(a,"loopback."))
+#define hexdigit(n)	(((n) < 10) ? '0' + (n) : 'A' + (n) - 10);
+#define in_string(s,c)	(index(s,c) != NULL)
+#define incopy(a)	*((struct in_addr *)(a))
+#define input			/* read-only input parameter */
+#define is_alnum(c)	(isascii(c) && isalnum(c))
+#define is_quoted(a,b)	(((a) > (b)) && ((a)[-1] == '\\'))
+#define is_space(c)	(isascii(c) && isspace(c))
+#define is_upper(c)	(isascii(c) && isupper(c))
+#define is_xdigit(c)	(isascii(c) && isxdigit(c))
+#define lower(c)	(((c) >= 'A' && (c) <= 'Z') ? (c) + 'a' - 'A' : (c))
+#define lowercase(c)	(is_upper(c) ? tolower(c) : (c))
+#define newlist(a,n,t)	(t *)xalloc((ptr_t *)(a), (siz_t)((n)*sizeof(t)))
+#define newstr(s)	strcpy(newstring(s), s)
+#define newstring(s)	(char *)xalloc((ptr_t *)NULL, (siz_t)(strlen(s)+1))
+#define newstruct(t)	(t *)xalloc((ptr_t *)NULL, (siz_t)(sizeof(t)))
+#define nulladdr(a)	(((a) == 0) || ((a) == BROADCAST_ADDR))
+#define output			/* modified output parameter */
+#define plural(n)	(((n) == 1) ? "" : "s")
+#define plurale(n)	(((n) == 1) ? "" : "es")
+#define querysize(n)	(((n) > sizeof(querybuf)) ? sizeof(querybuf) : (n))
+#define samehead(a,b)	(strncasecmp(a,b,sizeof(b)-1) == 0)
+#define samepart(a,b)	(strncasecmp(a,b,strlen(b)) == 0)
+#define sameword(a,b)	(strcasecmp(a,b) == 0)
+#define setalarm(n)	(void) alarm((unsigned int)(n))
+#define strlength(s)	(int)strlen(s)
+#define xfree(a)	(void) free((ptr_t *)(a))
+#define ARPA_ROOT	"in-addr.arpa"
+#ifndef IPNG_ROOT
+#define IPNG_ROOT	"ip6.int"
+#endif
+#ifndef NSAP_ROOT
+#define NSAP_ROOT	"nsap.int"
+#endif
+#define MAXNSAP		20	/* maximum size of encoded NSAP address */
+#define T_LOC_VERSION	0	/* must be zero */
+#define	MAXMD5BITS	2552
+#define	MAXMD5SIZE	(2*((MAXMD5BITS+7)/8)+3)
+#define	MAXB64SIZE	(4*((MAXMD5SIZE+2)/3))
+#ifndef NAMESERVER_PORT
+#define NAMESERVER_PORT	53
+#endif
+#define MAXCHAIN	10	/* maximum count of recursive chain lookups */
+#define MAXALIAS	35	/* maximum aliases count from gethnamaddr.c */
+#define MAXADDRS	35	/* maximum address count from gethnamaddr.c */
+#define MAXNSNAME	16	/* maximum count of nameservers per zone */
+#define MAXIPADDR	10	/* maximum count of addresses per nameserver */
+#define DEF_RETRIES	2	/* number of datagram retries per nameserver */
+#d.ds b1
+.ds rS
+.aY
+..
+.\" NS Hf macro - source include header files.
+.de Hf
+.Pp
+File:
+.Pa \\$1
+.Pp
+.nr cF \\n(.f
+.nr cZ \\n(.s
+.ie t \{\
+\&\\*(lI
+.br
+.ta +9n 18n 27n 36n 45n 54n 63n 72n
+.\}
+.el \{\
+.ta +8n 16n 24n 32n 40n 48n 56n 64n 72n
+.\}
+.nf
+.so  \\$1
+.fi
+.ft \\n(cF
+.fz \\n(cZ
+.Pp
+..
+.\" NS An macro - author name
+.\" NS aN register
+.nr aN 0
+.de An
+.if \\n(nY==1 \{\
+.	ie \\n(aN==1 \{\
+.		br
+.	\}
+.	el \{\
+.		nr aN 1
+.	\}
+.\}
+.if \\n(aC==0 \{\
+.       ie \\n(.$==0 .tm Usage: .An author_name ... \\*(Pu (#\\n(.c)
+.	el \{\
+.		ds mN An
+.		aV \\$1 \\$2 \\$3 \\$4 \\$5 \\$6 \\$7 \\$8 \\$9
+.	\}
+.\}
+.if \\n(aC>\\n(aP \{\
+.	nr aP \\n(aP+1
+.       nr cF \\n(.f
+.	nr cZ \\n(.s
+.       nR
+.\}
+..
+.\" NS Sf macro -defunct
+.de Sf
+.tm .Sf defunct, use prefix or Ns
+..
+.ds rV "function returns the value 0 if successful; otherwise the value -1 is returned and the global variable \\*(vAerrno\fP is set to indicate the error.
+.\" Ns Rv macro - return values
+.\" Ns rV string - standard return message
+.de Rv
+.ie \\n(.$==0 \{\
+.tm Usage: .Rv [-std] (#\\n(.c)
+.\}
+.el \{\
+.	ds mN Rv
+.\" .	nr aP 0
+.\" .	nr lR \\n(lR+1
+.\" .	ds A1 \\$2
+.\" .	ds A2 \\$3
+.\" .	ds A3 \\$4
+.\" .	ds A4 \\$5
+.\" .	ds A5 \\$6
+.\" .	ds A6 \\$7
+.\" .	ds A7 \\$8
+.\" .	ds A8 \\$9
+.\" .	nr fV \\n(.$-1
+.	if "\\$1"-std" \{\
+.	nr cH \\*(cH
+.	if (\\n(cH<2):(\\n(cH>3) .tm Usage: .Rv -std sections 2 and 3 only
+.		br
+\&The
+.Fn \\$2
+\&\\*(rV
+.	\}
+.\}
+..
index: src/usr.bin/host/nslookup
===================================================================
RCS file: /cvs/src/usr.bin/host/nslookup,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/usr.bin/host/nslookup	Sat Mar 22 15:41:56 2003
@@@@ -0,0 +1,584 @@@@
+#!/bin/sh -
+#	$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+#	$OpenBSD: nslookup,v 1.2 1997/03/12 10:41:55 downsj Exp $
+#	@@(#)nslookup            e07@@nikhef.nl (Eric Wassenaar) 940919
+#
+# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
+# Copyright (c) by Eric Wassenaar, Nikhef-H, <e07@@nikhef.nl>
+#
+# I hereby permit everyone who obtained a copy of this work to distri-
+# bute, sell, give away, modify, sublicense, merge and use it, freely.
+# I retain the right to be known as the author of the work.
+#
+# The work is provided "as is", with no explicit or implicit warranty.
+# Use it at your own risk. Neither the author, nor contributors may be
+# held liable for any damage, directly or indirectly, which originated
+# by the creation or modification of this work. Since modern computing
+# devices are error-prone, flawless behaviour cannot be expected.
+
+# This utility emulates nslookup as a wrapper to host.
+# It performs most, but not all, functions.
+
+exec=echo
+exec=
+
+echo "Warning! nslookup is deprecated. Use host(1) instead."
+
+# ----------------------------------------------------------------------
+# Setup environment.
+# ----------------------------------------------------------------------
+
+# This is where the "host" executable lives.
+BINDIR=/usr/sbin
+
+PATH=${BINDIR}:/bin:/usr/bin; export PATH
+
+cmd=$(basename $0)
+
+options="[-l]"
+usage="Usage: $cmd $options [server]"
+
+# ----------------------------------------------------------------------
+# Exit codes from <sysexits.h>
+# ----------------------------------------------------------------------
+
+EX_OK=0
+EX_USAGE=64
+EX_UNAVAILABLE=69
+
+# ----------------------------------------------------------------------
+# Setup defaults.
+# ----------------------------------------------------------------------
+
+name=""
+zone=""
+
+type=""
+class=""
+
+server=""
+
+debug=""
+verbose=""
+norecurse=""
+vc=""
+
+# ----------------------------------------------------------------------
+# Process arguments.
+# ----------------------------------------------------------------------
+
+for i
+do
+	if [ "X$server" != "X" ]
+	then
+		echo "$usage" 1>&2 ; exit $EX_USAGE
+	fi
+
+	case "$i" in
+	-d)	exec=echo		;;
+	-l)	server=$(hostname)	;;
+	-*)	echo "$cmd: Unknown option $i" 1>&2 ; exit $EX_USAGE ;;
+	*)	server="$i"		;;
+	esac
+done
+
+# ----------------------------------------------------------------------
+# Choose between BSD or SYSV echo command.
+# ----------------------------------------------------------------------
+
+n=$(echo -n)
+if [ "$n" = "-n" ]
+then
+	c='\c' ; n=''
+else
+	n='-n' ; c=''
+fi
+
+# ----------------------------------------------------------------------
+# Main loop.
+# ----------------------------------------------------------------------
+
+trap continue 2
+
+while echo $n "> $c" ; read line
+do
+	case "$line" in
+	"")	continue	;;
+	*\**)	continue	;;
+	*\!*)	continue	;;
+	*\?*)	line="help"	;;
+	esac
+
+	set - $line
+	command="$1"
+	case "$command" in
+
+	help)
+		cat <<!
+	exit | quit	- exit from the program
+	help | ?	- print this help message
+	set  | set all	- show all current settings
+	set [no]debug	- increase debug output level
+	set [no]verbose	- increase verbose output level
+	set [no]recurse	- request recursive nameserver queries
+	set [no]vc	- use virtual circuit for queries
+	set type=TYPE	- query about the given resource record TYPE
+	set class=CLASS	- query about the given resource record CLASS
+	server SERVER	- contact the explicit server with name SERVER
+	server		- show the name of the current explicit SERVER
+	NAME		- query for NAME using all current settings
+	NAME SERVER	- query for NAME at the given SERVER
+	ls ZONE		- generate listing of the given name ZONE
+	ls		- generate listing of the last given ZONE
+	ls ZONE [>]FILE	- copy resource record output also to FILE
+!
+		;;
+
+	exit|quit)
+		break
+		;;
+
+	set)
+		option="$2"
+		case "$option" in
+
+		""|all)
+			echo "name=$name"
+			echo "zone=$zone"
+			echo "server=$server"
+			echo "set type=$type"
+			echo "set class=$class"
+			echo "set debug=$debug"
+			echo "set verbose=$verbose"
+			echo "set norecurse=$norecurse"
+			echo "set vc=$vc"
+			;;
+
+		debug|debu|deb|de|d)
+			debug="-d $debug"
+			;;
+
+		nodebug|nodebu|nodeb|node|nod)
+			debug=""
+			;;
+
+		d2)
+			debug="-d -d"
+			verbose="-v -v"
+			;;
+
+		nod2)
+			debug=""
+			verbose=""
+			;;
+
+		verbose|verbos|verbo|verb|ver|ve|v)
+			verbose="-v $verbose"
+			;;
+
+		noverbose|noverbos|noverbo|noverb|nover|nove|nov)
+			verbose=""
+			;;
+
+		recurse|recurs|recur|recu|rec|re|r)
+			norecurse=""
+			;;
+
+		norecurse|norecurs|norecur|norecu|norec|nore|nor)
+			norecurse="-r"
+			;;
+
+		vc)
+			vc="-u"
+			;;
+
+		novc)
+			vc=""
+			;;
+
+		querytype=*|querytyp=*|queryty=*|queryt=*|\
+		query=*|quer=*|que=*|qu=*|q=*|\
+		type=*|typ=*|ty=*|t=*)
+			type=$(echo $option | sed 's/.*=//')
+			if [ "X$type" != "X" ]
+			then
+				type="-t $type"
+			fi
+			;;
+
+		querytype|querytyp|queryty|queryt|\
+		query|quer|que|qu|q|\
+		type|typ|ty|t)
+			type=""
+			;;
+
+		class=*|clas=*|cla=*|cl=*|c=*)
+			class=$(echo $option | sed 's/.*=//')
+			if [ "X$class" != "X" ]
+			then
+				class="-c $class"
+			fi
+			;;
+
+		class*|clas*|cla*|cl*|c*)
+			class=""
+			;;
+
+		*)
+			echo "Unknown option $option"
+			;;
+
+		esac
+		;;
+
+	server)
+		nserver="$2"
+		if [ "X$nserver" = "X" ]
+		then
+			if [ "X$server" = "X" ]
+			then
+				echo "No server defined"
+			else
+				echo "server=$server"
+			fi
+		else
+			server="$nserver"
+		fi
+		;;
+
+	ls)
+		nzone="$2"
+		if [ "X$nzone" = "X" ]
+		then
+			if [ "X$zone" = "X" ]
+			then
+				echo "No zone defined"
+				continue
+			fi
+		else
+			zone="$nzone"
+		fi
+
+		file=$(echo "$3$4" | sed 's/>*//')
+		if [ "X$file" != "X" ]
+		then
+			file="-f $file"
+		fi
+
+		options="$debug $verbose $norecurse $vc $file"
+		$exec host $options $type $class -l $zone $nserver
+		;;
+
+	[a-zA-Z0-9]*)
+		name="$1"
+
+		nserver="$2"
+		if [ "X$nserver" = "X" ]
+		then
+			nserver="$server"
+		fi
+
+		options="$debug $verbose $norecurse $vc"
+		$exec host $options $type $class $name $nserver
+		;;
+
+	*)
+		echo "Unknown command $command"
+		;;
+
+	esac
+done
+
+exit $EX_OK
+#!/bin/sh -
+#	$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+#	$OpenBSD: nslookup,v 1.2 1997/03/12 10:41:55 downsj Exp $
+#	@@(#)nslookup            e07@@nikhef.nl (Eric Wassenaar) 940919
+#
+# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
+# Copyright (c) by Eric Wassenaar, Nikhef-H, <e07@@nikhef.nl>
+#
+# I hereby permit everyone who obtained a copy of this work to distri-
+# bute, sell, give away, modify, sublicense, merge and use it, freely.
+# I retain the right to be known as the author of the work.
+#
+# The work is provided "as is", with no explicit or implicit warranty.
+# Use it at your own risk. Neither the author, nor contributors may be
+# held liable for any damage, directly or indirectly, which originated
+# by the creation or modification of this work. Since modern computing
+# devices are error-prone, flawless behaviour cannot be expected.
+
+# This utility emulates nslookup as a wrapper to host.
+# It performs most, but not all, functions.
+
+exec=echo
+exec=
+
+echo "Warning! nslookup is deprecated. Use host(1) instead."
+
+# ----------------------------------------------------------------------
+# Setup environment.
+# ----------------------------------------------------------------------
+
+# This is where the "host" executable lives.
+BINDIR=/usr/sbin
+
+PATH=${BINDIR}:/bin:/usr/bin; export PATH
+
+cmd=$(basename $0)
+
+options="[-l]"
+usage="Usage: $cmd $options [server]"
+
+# ----------------------------------------------------------------------
+# Exit codes from <sysexits.h>
+# ----------------------------------------------------------------------
+
+EX_OK=0
+EX_USAGE=64
+EX_UNAVAILABLE=69
+
+# ----------------------------------------------------------------------
+# Setup defaults.
+# ----------------------------------------------------------------------
+
+name=""
+zone=""
+
+type=""
+class=""
+
+server=""
+
+debug=""
+verbose=""
+norecurse=""
+vc=""
+
+# ----------------------------------------------------------------------
+# Process arguments.
+# ----------------------------------------------------------------------
+
+for i
+do
+	if [ "X$server" != "X" ]
+	then
+		echo "$usage" 1>&2 ; exit $EX_USAGE
+	fi
+
+	case "$i" in
+	-d)	exec=echo		;;
+	-l)	server=$(hostname)	;;
+	-*)	echo "$cmd: Unknown option $i" 1>&2 ; exit $EX_USAGE ;;
+	*)	server="$i"		;;
+	esac
+done
+
+# ----------------------------------------------------------------------
+# Choose between BSD or SYSV echo command.
+# ----------------------------------------------------------------------
+
+n=$(echo -n)
+if [ "$n" = "-n" ]
+then
+	c='\c' ; n=''
+else
+	n='-n' ; c=''
+fi
+
+# ----------------------------------------------------------------------
+# Main loop.
+# ----------------------------------------------------------------------
+
+trap continue 2
+
+while echo $n "> $c" ; read line
+do
+	case "$line" in
+	"")	continue	;;
+	*\**)	continue	;;
+	*\!*)	continue	;;
+	*\?*)	line="help"	;;
+	esac
+
+	set - $line
+	command="$1"
+	case "$command" in
+
+	help)
+		cat <<!
+	exit | quit	- exit from the program
+	help | ?	- print this help message
+	set  | set all	- show all current settings
+	set [no]debug	- increase debug output level
+	set [no]verbose	- increase verbose output level
+	set [no]recurse	- request recursive nameserver queries
+	set [no]vc	- use virtual circuit for queries
+	set type=TYPE	- query about the given resource record TYPE
+	set class=CLASS	- query about the given resource record CLASS
+	server SERVER	- contact the explicit server with name SERVER
+	server		- show the name of the current explicit SERVER
+	NAME		- query for NAME using all current settings
+	NAME SERVER	- query for NAME at the given SERVER
+	ls ZONE		- generate listing of the given name ZONE
+	ls		- generate listing of the last given ZONE
+	ls ZONE [>]FILE	- copy resource record output also to FILE
+!
+		;;
+
+	exit|quit)
+		break
+		;;
+
+	set)
+		option="$2"
+		case "$option" in
+
+		""|all)
+			echo "name=$name"
+			echo "zone=$zone"
+			echo "server=$server"
+			echo "set type=$type"
+			echo "set class=$class"
+			echo "set debug=$debug"
+			echo "set verbose=$verbose"
+			echo "set norecurse=$norecurse"
+			echo "set vc=$vc"
+			;;
+
+		debug|debu|deb|de|d)
+			debug="-d $debug"
+			;;
+
+		nodebug|nodebu|nodeb|node|nod)
+			debug=""
+			;;
+
+		d2)
+			debug="-d -d"
+			verbose="-v -v"
+			;;
+
+		nod2)
+			debug=""
+			verbose=""
+			;;
+
+		verbose|verbos|verbo|verb|ver|ve|v)
+			verbose="-v $verbose"
+			;;
+
+		noverbose|noverbos|noverbo|noverb|nover|nove|nov)
+			verbose=""
+			;;
+
+		recurse|recurs|recur|recu|rec|re|r)
+			norecurse=""
+			;;
+
+		norecurse|norecurs|norecur|norecu|norec|nore|nor)
+			norecurse="-r"
+			;;
+
+		vc)
+			vc="-u"
+			;;
+
+		novc)
+			vc=""
+			;;
+
+		querytype=*|querytyp=*|queryty=*|queryt=*|\
+		query=*|quer=*|que=*|qu=*|q=*|\
+		type=*|typ=*|ty=*|t=*)
+			type=$(echo $option | sed 's/.*=//')
+			if [ "X$type" != "X" ]
+			then
+				type="-t $type"
+			fi
+			;;
+
+		querytype|querytyp|queryty|queryt|\
+		query|quer|que|qu|q|\
+		type|typ|ty|t)
+			type=""
+			;;
+
+		class=*|clas=*|cla=*|cl=*|c=*)
+			class=$(echo $option | sed 's/.*=//')
+			if [ "X$class" != "X" ]
+			then
+				class="-c $class"
+			fi
+			;;
+
+		class*|clas*|cla*|cl*|c*)
+			class=""
+			;;
+
+		*)
+			echo "Unknown option $option"
+			;;
+
+		esac
+		;;
+
+	server)
+		nserver="$2"
+		if [ "X$nserver" = "X" ]
+		then
+			if [ "X$server" = "X" ]
+			then
+				echo "No server defined"
+			else
+				echo "server=$server"
+			fi
+		else
+			server="$nserver"
+		fi
+		;;
+
+	ls)
+		nzone="$2"
+		if [ "X$nzone" = "X" ]
+		then
+			if [ "X$zone" = "X" ]
+			then
+				echo "No zone defined"
+				continue
+			fi
+		else
+			zone="$nzone"
+		fi
+
+		file=$(echo "$3$4" | sed 's/>*//')
+		if [ "X$file" != "X" ]
+		then
+			file="-f $file"
+		fi
+
+		options="$debug $verbose $norecurse $vc $file"
+		$exec host $options $type $class -l $zone $nserver
+		;;
+
+	[a-zA-Z0-9]*)
+		name="$1"
+
+		nserver="$2"
+		if [ "X$nserver" = "X" ]
+		then
+			nserver="$server"
+		fi
+
+		options="$debug $verbose $norecurse $vc"
+		$exec host $options $type $class $name $nserver
+		;;
+
+	*)
+		echo "Unknown command $command"
+		;;
+
+	esac
+done
+
+exit $EX_OK
index: src/usr.bin/ndat/Makefile
===================================================================
RCS file: /cvs/src/usr.bin/ndat/Makefile,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/usr.bin/ndat/Makefile	Sat Mar 22 15:41:56 2003
@@@@ -0,0 +1,18 @@@@
+# $MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+# Public domain.
+
+PROG=	ndat
+CFLAGS+=-Wall -Werror -pedantic
+
+NOMAN=
+
+.include <bsd.prog.mk>
+# $MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+# Public domain.
+
+PROG=	ndat
+CFLAGS+=-Wall -Werror -pedantic
+
+NOMAN=
+
+.include <bsd.prog.mk>
index: src/usr.bin/ndat/ndat.c
===================================================================
RCS file: /cvs/src/usr.bin/ndat/ndat.c,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/usr.bin/ndat/ndat.c	Sat Mar 22 15:41:56 2003
@@@@ -0,0 +1,506 @@@@
+/* Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
+ *
+ * Anyone who obtained a copy of this work is hereby permitted to freely use,
+ * distribute, modify, merge, sublicence, give away or sell it as long as the
+ * authors are given due credit and the following notice is retained:
+ *
+ * This work is provided "as is", with no explicit or implicit warranty what-
+ * soever. Use it only at your own risk. In no event may an author or contri-
+ * butor be held liable for any damage, directly or indirectly, that origina-
+ * ted through or is caused by creation or modification of this work.
+ */
+
+/* Offizielles Programm der Republica Occultae Germanorum zur Umrechnung
+ * zwischen naturamistischen und neu-christlichen (VAW) Zeitangaben.
+ * Finale Version, funktional identisch und getestet. Bugs gefixt.
+ * manual page still missing... hexadecimal time-of-day too.
+ */
+
+static const char RCSId[]="$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $";
+
+#include <sys/types.h>
+
+#include <time.h>
+#include <stdio.h>
+
+int main(int argc, char *argv[]);
+int DatCN(char s, char *otm);
+int DatNC(char s, char *otm);
+int dpm(int m, int y);
+
+char buf[16];
+
+char *tag[]=	{ "Pd", "Sc", "Td", "Qa", "Qi", "Vd" };
+char *chrtag[]=	{ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" };
+
+#ifdef RESTRICT_ASCII
+char *langtag[]={ "Primdies", "Secundies", "Tertdies",
+		  "Quartdies", "Quintdies", "Veyrdag" };
+#else
+char *langtag[]={ "Prmdies", "Secndies", "Trtdies",
+		  "Qurtdies", "Quntdies", "Vyrdag" };
+#endif
+
+#define	bounds(v, min, max)	(((v<min) || (v>max)) ? -1 : 0)
+#define	februar(y)	((y&3) ? 28 : ((y%100) ? 29 : ((y%400) ? 28 : 29)))
+
+
+int main(int argc, char *argv[])
+{
+	time_t v;
+	struct tm *tts;
+
+	if (argc == 3) {
+		/*
+		 * +!	nat -> chr		inp: d.m.y
+		 * +	nat(short) -> chr	inp: day-of-year.y
+		 */
+		if (argv[1][0] == '+')
+			return DatNC(argv[1][1], argv[2]);
+
+		/*
+		 * -	chr -> nat			 xx ddd.yy
+		 * -!	chr -> nat(short)		 xx yyddd
+		 * -+	chr -> nat(absurdly verbose)	xxx dd.mm.yy
+		 */
+		if (argv[1][0] == '-')
+			return DatCN(argv[1][1], argv[2]);
+	}
+
+	if ((argc == 2) && (argv[1][0] == '-')) {
+		/*
+		 * -	convert today's date
+		 */
+		v = time(NULL);
+		tts = gmtime(&v);
+		strftime(buf, 16, "%d.%m.%Y", tts);
+		return DatCN(argv[1][1], buf);
+	}
+
+	fprintf(stderr, "Syntax:\n\n ndat +[!] naturamistic.date\n ndat"
+	    " -[!+] [christian.date]\n\n%s\n", RCSId);
+	return -1;
+}
+
+/* Days per month depending on year */
+int dpm(int m, int y)
+{
+	switch(m) {
+		case 1:
+		case 3:
+		case 5:
+		case 7:
+		case 8:
+		case 10:
+		case 12: return 31;
+
+		case 4:
+		case 6:
+		case 9:
+		case 11: return 30;
+	}
+	return februar(y);
+}
+
+/* convert Christian to Naturamistic date */
+int DatCN(char s, char *otm)
+{
+	int d, m, y, dp, a, b, c, t;
+	int64_t ofs;
+
+	if (sscanf(otm, "%d.%d.%d", &d, &m, &y) != 3)
+		return -1;
+	if (bounds(y, 1600, 9999))
+		return -1;
+
+	/* Trick bei Jahr < 1982 */
+	y += 400;
+
+	if (bounds(m, 1, 12)) return -1;
+	dp = dpm(m, y);
+	if (bounds(d, 1, dp)) return -1;
+
+	ofs = 10 + d;
+	for (a = 1; a < m; a++)
+		ofs += dpm(a, y);
+	for (a = 1982; a < y; a++)
+		if (februar(a) == 29)
+			ofs += 366;
+		else	ofs += 365;
+
+	t = (ofs - 4) % 6;
+
+	y = 0;
+	b = 1982;
+getny:	c = (februar(b) == 29) ? 366 : 365;
+	if (ofs > c) {
+		++y;
+		++b;
+		ofs -= c;
+		goto getny;
+	}
+
+	/*
+	 * y ist jetzt das naturamistische Jahr
+	 * ofs der Tag des Jahres
+	 */
+
+	/* Trick bei Jahr < 0 */
+	y -= 400;
+
+	m = ofs / 30 + 1;
+	d = ofs % 30;
+	if (!d) {
+		d = 30;
+		--m;
+	}
+
+	if (s == '!') {
+		printf("%s %01i%03d\n", tag[t], y, (int) ofs);
+	} else if ((m < 12) && (s == '+')) {
+		printf("%s %02d.%02d.%01i\n", langtag[t], d, m, y);
+	} else	printf("%s %03d.%01i\n", tag[t], (int) ofs, y);
+	return 0;
+}
+
+/* convert Naturamistic to Christian date */
+int DatNC(char s, char *otm)
+{
+	int d, m, y, ny, nd, w;
+	struct tm *tts;
+
+	if (s == '!') {
+		if (sscanf(otm, "%d.%d.%d", &d, &m, &ny) != 3)
+			return -1;
+		nd = (m-1)*30 + d;
+	} else	{
+		d = sscanf(otm, "%d.%d", &nd, &ny);
+		if (d == 1) {
+			if (nd < 0) {
+				ny = -1;
+				nd *= -1;
+			} else	ny = 1;
+			ny *= nd / 1000;
+			nd %= 1000;
+		} else if (d != 2)
+			return -1;
+	}
+	if (bounds(ny, -382, 8018))
+		return -1;
+	if (bounds(nd, 1, 366))
+		return -1;
+	if ((ny == -382) && (nd < 11))
+		return -1;
+	if ((ny == 8018) && (nd > 10))
+		return -1;
+	y = ny + 1982;
+	if ((februar(y)==28) && (nd==366))
+		return -1;
+
+	if (nd < 11) {
+		d = 21 + nd;
+		m = 12;
+		y--;
+		goto dny;
+	}
+	d = nd - 10;
+	m = 1;
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d <= februar(y)) goto dny;
+	++m; d -= februar(y);
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d < 31) goto dny;
+	++m; d -= 30;
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d < 31) goto dny;
+	++m; d -= 30;
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d < 31) goto dny;
+	++m; d -= 30;
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d < 31) goto dny;
+	++m; d -= 30;
+
+	if (d > 31) return -1;
+
+dny:	w = 7;
+
+	/* Unix time "struct tm" year starts at 1900 and ends at 32 bit */
+	if ((y < 1900) || (y > 2037))
+		goto dnyw;
+
+	/* Now calculate the day of week, using heavy kludges */
+	if ((tts = gmtime(&w)) == NULL)
+		goto dnyw;
+	snprintf(buf, 16, "%d %d %d", d, m, y);
+	if (strptime(buf, "%d %m %Y", tts) == NULL)
+		goto dnyw;
+	mktime(tts);
+	w = tts->tm_wday;
+
+dnyw:	if (bounds(w, 0, 7))
+		w = 7;
+	printf("%s%s%i.%02i.%04i\n", ((w==7) ? "" : chrtag[w]),
+	    ((w==7) ? "" : " "), d, m, y);
+	return 0;
+}
+/* Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
+ *
+ * Anyone who obtained a copy of this work is hereby permitted to freely use,
+ * distribute, modify, merge, sublicence, give away or sell it as long as the
+ * authors are given due credit and the following notice is retained:
+ *
+ * This work is provided "as is", with no explicit or implicit warranty what-
+ * soever. Use it only at your own risk. In no event may an author or contri-
+ * butor be held liable for any damage, directly or indirectly, that origina-
+ * ted through or is caused by creation or modification of this work.
+ */
+
+/* Offizielles Programm der Republica Occultae Germanorum zur Umrechnung
+ * zwischen naturamistischen und neu-christlichen (VAW) Zeitangaben.
+ * Finale Version, funktional identisch und getestet. Bugs gefixt.
+ * manual page still missing... hexadecimal time-of-day too.
+ */
+
+static const char RCSId[]="$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $";
+
+#include <sys/types.h>
+
+#include <time.h>
+#include <stdio.h>
+
+int main(int argc, char *argv[]);
+int DatCN(char s, char *otm);
+int DatNC(char s, char *otm);
+int dpm(int m, int y);
+
+char buf[16];
+
+char *tag[]=	{ "Pd", "Sc", "Td", "Qa", "Qi", "Vd" };
+char *chrtag[]=	{ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" };
+
+#ifdef RESTRICT_ASCII
+char *langtag[]={ "Primdies", "Secundies", "Tertdies",
+		  "Quartdies", "Quintdies", "Veyrdag" };
+#else
+char *langtag[]={ "Prmdies", "Secndies", "Trtdies",
+		  "Qurtdies", "Quntdies", "Vyrdag" };
+#endif
+
+#define	bounds(v, min, max)	(((v<min) || (v>max)) ? -1 : 0)
+#define	februar(y)	((y&3) ? 28 : ((y%100) ? 29 : ((y%400) ? 28 : 29)))
+
+
+int main(int argc, char *argv[])
+{
+	time_t v;
+	struct tm *tts;
+
+	if (argc == 3) {
+		/*
+		 * +!	nat -> chr		inp: d.m.y
+		 * +	nat(short) -> chr	inp: day-of-year.y
+		 */
+		if (argv[1][0] == '+')
+			return DatNC(argv[1][1], argv[2]);
+
+		/*
+		 * -	chr -> nat			 xx ddd.yy
+		 * -!	chr -> nat(short)		 xx yyddd
+		 * -+	chr -> nat(absurdly verbose)	xxx dd.mm.yy
+		 */
+		if (argv[1][0] == '-')
+			return DatCN(argv[1][1], argv[2]);
+	}
+
+	if ((argc == 2) && (argv[1][0] == '-')) {
+		/*
+		 * -	convert today's date
+		 */
+		v = time(NULL);
+		tts = gmtime(&v);
+		strftime(buf, 16, "%d.%m.%Y", tts);
+		return DatCN(argv[1][1], buf);
+	}
+
+	fprintf(stderr, "Syntax:\n\n ndat +[!] naturamistic.date\n ndat"
+	    " -[!+] [christian.date]\n\n%s\n", RCSId);
+	return -1;
+}
+
+/* Days per month depending on year */
+int dpm(int m, int y)
+{
+	switch(m) {
+		case 1:
+		case 3:
+		case 5:
+		case 7:
+		case 8:
+		case 10:
+		case 12: return 31;
+
+		case 4:
+		case 6:
+		case 9:
+		case 11: return 30;
+	}
+	return februar(y);
+}
+
+/* convert Christian to Naturamistic date */
+int DatCN(char s, char *otm)
+{
+	int d, m, y, dp, a, b, c, t;
+	int64_t ofs;
+
+	if (sscanf(otm, "%d.%d.%d", &d, &m, &y) != 3)
+		return -1;
+	if (bounds(y, 1600, 9999))
+		return -1;
+
+	/* Trick bei Jahr < 1982 */
+	y += 400;
+
+	if (bounds(m, 1, 12)) return -1;
+	dp = dpm(m, y);
+	if (bounds(d, 1, dp)) return -1;
+
+	ofs = 10 + d;
+	for (a = 1; a < m; a++)
+		ofs += dpm(a, y);
+	for (a = 1982; a < y; a++)
+		if (februar(a) == 29)
+			ofs += 366;
+		else	ofs += 365;
+
+	t = (ofs - 4) % 6;
+
+	y = 0;
+	b = 1982;
+getny:	c = (februar(b) == 29) ? 366 : 365;
+	if (ofs > c) {
+		++y;
+		++b;
+		ofs -= c;
+		goto getny;
+	}
+
+	/*
+	 * y ist jetzt das naturamistische Jahr
+	 * ofs der Tag des Jahres
+	 */
+
+	/* Trick bei Jahr < 0 */
+	y -= 400;
+
+	m = ofs / 30 + 1;
+	d = ofs % 30;
+	if (!d) {
+		d = 30;
+		--m;
+	}
+
+	if (s == '!') {
+		printf("%s %01i%03d\n", tag[t], y, (int) ofs);
+	} else if ((m < 12) && (s == '+')) {
+		printf("%s %02d.%02d.%01i\n", langtag[t], d, m, y);
+	} else	printf("%s %03d.%01i\n", tag[t], (int) ofs, y);
+	return 0;
+}
+
+/* convert Naturamistic to Christian date */
+int DatNC(char s, char *otm)
+{
+	int d, m, y, ny, nd, w;
+	struct tm *tts;
+
+	if (s == '!') {
+		if (sscanf(otm, "%d.%d.%d", &d, &m, &ny) != 3)
+			return -1;
+		nd = (m-1)*30 + d;
+	} else	{
+		d = sscanf(otm, "%d.%d", &nd, &ny);
+		if (d == 1) {
+			if (nd < 0) {
+				ny = -1;
+				nd *= -1;
+			} else	ny = 1;
+			ny *= nd / 1000;
+			nd %= 1000;
+		} else if (d != 2)
+			return -1;
+	}
+	if (bounds(ny, -382, 8018))
+		return -1;
+	if (bounds(nd, 1, 366))
+		return -1;
+	if ((ny == -382) && (nd < 11))
+		return -1;
+	if ((ny == 8018) && (nd > 10))
+		return -1;
+	y = ny + 1982;
+	if ((februar(y)==28) && (nd==366))
+		return -1;
+
+	if (nd < 11) {
+		d = 21 + nd;
+		m = 12;
+		y--;
+		goto dny;
+	}
+	d = nd - 10;
+	m = 1;
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d <= februar(y)) goto dny;
+	++m; d -= februar(y);
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d < 31) goto dny;
+	++m; d -= 30;
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d < 31) goto dny;
+	++m; d -= 30;
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d < 31) goto dny;
+	++m; d -= 30;
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d < 31) goto dny;
+	++m; d -= 30;
+
+	if (d > 31) return -1;
+
+dny:	w = 7;
+
+	/* Unix time "struct tm" year starts at 1900 and ends at 32 bit */
+	if ((y < 1900) || (y > 2037))
+		goto dnyw;
+
+	/* Now calculate the day of week, using heavy kludges */
+	if ((tts = gmtime(&w)) == NULL)
+		goto dnyw;
+	snprintf(buf, 16, "%d %d %d", d, m, y);
+	if (strptime(buf, "%d %m %Y", tts) == NULL)
+		goto dnyw;
+	mktime(tts);
+	w = tts->tm_wday;
+
+dnyw:	if (bounds(w, 0, 7))
+		w = 7;
+	printf("%s%s%i.%02i.%04i\n", ((w==7) ? "" : chrtag[w]),
+	    ((w==7) ? "" : " "), d, m, y);
+	return 0;
+}
index: src/usr.bin/wtf/Makefile
===================================================================
RCS file: /cvs/src/usr.bin/wtf/Makefile,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/usr.bin/wtf/Makefile	Sat Mar 22 15:41:56 2003
@@@@ -0,0 +1,24 @@@@
+# $MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+# Public domain.
+
+SCRIPTS=wtf
+NOOBS=	noobj
+MAN=	wtf.1
+
+realinstall:
+	cd ${.CURDIR}; install -c -o ${BINOWN} -g ${BINGRP} -m 555 \
+	    ${SCRIPTS} ${DESTDIR}${BINDIR}
+
+.include <bsd.prog.mk>
+# $MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+# Public domain.
+
+SCRIPTS=wtf
+NOOBS=	noobj
+MAN=	wtf.1
+
+realinstall:
+	cd ${.CURDIR}; install -c -o ${BINOWN} -g ${BINGRP} -m 555 \
+	    ${SCRIPTS} ${DESTDIR}${BINDIR}
+
+.include <bsd.prog.mk>
index: src/usr.bin/wtf/wtf
===================================================================
RCS file: /cvs/src/usr.bin/wtf/wtf,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/usr.bin/wtf/wtf	Sat Mar 22 15:41:56 2003
@@@@ -0,0 +1,72 @@@@
+#!/bin/sh -
+#	$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+#	$NetBSD: wtf,v 1.7 2000/11/21 00:18:52 soren Exp $
+#
+# Public domain
+
+acronyms=${ACRONYMDB:-/usr/share/misc/acronyms}
+
+[ x"$1" = x"is" -o x"$1" = x"ist" ] && shift
+
+[ $# -lt 1 ] && echo "Usage: $(basename $0) [is] <acronym>"
+
+rv=0
+while [ $# -gt 0 ] ; do
+	target=$(echo $1 | tr '[:lower:]' '[:upper:]')
+	ans=$(fgrep $target <${acronyms} 2>/dev/null \
+	    | sed -ne "/^$target[[:space:]]/s/^$target[[:space:]]*//p")
+	if [ -n "$ans" ] ; then
+		echo "   $target:\n$ans"
+	else
+		ans=$(whatis $1 2>/dev/null | egrep "^$1[, ]" 2>/dev/null)
+		if [ $? -eq 0 ] ; then
+			echo "   $1:\n$ans"
+		else
+			echo "Gee...  I don't know what $1 means..." 1>&2
+			rv=1
+			if [ -x /usr/bin/dict ]; then
+				echo "Let's try The Dictionary..." 1>&2
+				dict $1
+				rv=2
+			fi
+		fi
+	fi
+	shift
+done
+exit $rv
+#!/bin/sh -
+#	$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+#	$NetBSD: wtf,v 1.7 2000/11/21 00:18:52 soren Exp $
+#
+# Public domain
+
+acronyms=${ACRONYMDB:-/usr/share/misc/acronyms}
+
+[ x"$1" = x"is" -o x"$1" = x"ist" ] && shift
+
+[ $# -lt 1 ] && echo "Usage: $(basename $0) [is] <acronym>"
+
+rv=0
+while [ $# -gt 0 ] ; do
+	target=$(echo $1 | tr '[:lower:]' '[:upper:]')
+	ans=$(fgrep $target <${acronyms} 2>/dev/null \
+	    | sed -ne "/^$target[[:space:]]/s/^$target[[:space:]]*//p")
+	if [ -n "$ans" ] ; then
+		echo "   $target:\n$ans"
+	else
+		ans=$(whatis $1 2>/dev/null | egrep "^$1[, ]" 2>/dev/null)
+		if [ $? -eq 0 ] ; then
+			echo "   $1:\n$ans"
+		else
+			echo "Gee...  I don't know what $1 means..." 1>&2
+			rv=1
+			if [ -x /usr/bin/dict ]; then
+				echo "Let's try The Dictionary..." 1>&2
+				dict $1
+				rv=2
+			fi
+		fi
+	fi
+	shift
+done
+exit $rv
index: src/usr.bin/wtf/wtf.1
===================================================================
RCS file: /cvs/src/usr.bin/wtf/wtf.1,v
retrieving revision DEAD
--- /dev/null	Sat Mar 22 14:34:57 2003
+++ src/usr.bin/wtf/wtf.1	Sat Mar 22 15:41:56 2003
@@@@ -0,0 +1,114 @@@@
+.\"	$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+.\"	$NetBSD: wtf.6,v 1.4 2001/04/02 22:42:40 wiz Exp $
+.\"
+.\" Public Domain
+.\"
+.Dd July 21, 1999
+.Dt WTF 1
+.Os
+.Sh NAME
+.Nm wtf
+.Nd translates acronyms for you
+.Sh SYNOPSIS
+.Nm
+.Op Ar is
+.Ar acronym Ar ...
+.Sh DESCRIPTION
+The
+.Nm
+utility displays the expansion of the acronyms
+specified on the command line.
+If the acronym is unknown,
+.Nm
+will check to see if the acronym is known by the
+.Xr whatis 1
+command.
+.Pp
+If
+.Dq is
+is specified on the command line, it will be ignored,
+allowing the fairly natural
+.Sy wtf\ is\ WTF
+and, for German users,
+.Sy wtf\ ist\ Windows
+usage.
+.Pp
+If the acronym is not found,
+the "dict" (online dictionary client) is tried
+if it exists.
+.Sh ENVIRONMENT
+.Bl -tag -width ACRONYMDB
+.It Ev ACRONYMDB
+The default acronym database may be overridden by setting the
+environment variable
+.Ev ACRONYMDB
+to the name of a file in the proper format (acronym[tab]meaning).
+.El
+.Sh FILES
+.Bl -tag -width /usr/share/misc/acronyms -compact
+.It Pa /usr/share/misc/acronyms
+default acronym database.
+.El
+.Sh SEE ALSO
+.Xr whatis 1
+.Sh HISTORY
+.Nm
+first appeared in
+.Nx 1.5 .
+.\"	$MirBSD: obsd.util,v 1.34 2003/03/22 22:33:31 tg Exp $
+.\"	$NetBSD: wtf.6,v 1.4 2001/04/02 22:42:40 wiz Exp $
+.\"
+.\" Public Domain
+.\"
+.Dd July 21, 1999
+.Dt WTF 1
+.Os
+.Sh NAME
+.Nm wtf
+.Nd translates acronyms for you
+.Sh SYNOPSIS
+.Nm
+.Op Ar is
+.Ar acronym Ar ...
+.Sh DESCRIPTION
+The
+.Nm
+utility displays the expansion of the acronyms
+specified on the command line.
+If the acronym is unknown,
+.Nm
+will check to see if the acronym is known by the
+.Xr whatis 1
+command.
+.Pp
+If
+.Dq is
+is specified on the command line, it will be ignored,
+allowing the fairly natural
+.Sy wtf\ is\ WTF
+and, for German users,
+.Sy wtf\ ist\ Windows
+usage.
+.Pp
+If the acronym is not found,
+the "dict" (online dictionary client) is tried
+if it exists.
+.Sh ENVIRONMENT
+.Bl -tag -width ACRONYMDB
+.It Ev ACRONYMDB
+The default acronym database may be overridden by setting the
+environment variable
+.Ev ACRONYMDB
+to the name of a file in the proper format (acronym[tab]meaning).
+.El
+.Sh FILES
+.Bl -tag -width /usr/share/misc/acronyms -compact
+.It Pa /usr/share/misc/acronyms
+default acronym database.
+.El
+.Sh SEE ALSO
+.Xr whatis 1
+.Sh HISTORY
+.Nm
+first appeared in
+.Nx 1.5 .

@


1.34
log
@- sync with repo
- rm fixed stuff
- tmp""ly add file list (for reference)
@
text
@d9 1
a9 1
+#	$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d65 1
a65 1
+# $MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d103 1
a103 1
+# Revised: $Date: 2003/03/22 16:14:25 $ by x86@@ePost.de
d879 1
a879 1
+# $MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d907 1
a907 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d1734 1
a1734 1
+$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d2102 1
a2102 1
+# $MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d2135 1
a2135 1
+.\"	$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d2215 1
a2215 1
+# $MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d2234 1
a2234 1
+.\"	$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d3120 1
a3120 1
+/*-	$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d3212 1
a3212 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11569 1
a11569 1
+/*-	$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d11661 1
a11661 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11858 1
a11858 1
+#	$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d12150 1
a12150 1
+#	$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d12448 1
a12448 1
+# $MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d12457 1
a12457 1
+# $MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d12491 1
a12491 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $";
d12744 1
a12744 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $";
d12986 1
a12986 1
+# $MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d12998 1
a12998 1
+# $MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d13018 1
a13018 1
+#	$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d13054 1
a13054 1
+#	$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d13096 1
a13096 1
+.\"	$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
d13153 1
a13153 1
+.\"	$MirBSD: obsd.util,v 1.33 2003/03/22 16:14:25 tg Exp $
@


1.33
log
@intermediate, broken, does not even apply
cvs and jupp in combination can produce weird results
jupp should be audited, or rewritten even
@
text
@a0 23
>> http://templeofhate.com/tglaser/MirBSD/index.php
>> MirBSD is a modified version of OpenBSD (http://www.OpenBSD.org/)

Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
Copyright  1968-2003  The authors of And contributors to UNIX, the
    "C" Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.

Anyone who obtained a copy of this work is hereby permitted to freely use,
distribute, modify, merge, sublicence, give away or sell it as long as the
authors are given due credit and the following notice is retained:

This work is provided "as is", with no explicit or implicit warranty what-
soever. Use it only at your own risk. In no event may an author or contri-
butor be held liable for any damage, directly or indirectly, that origina-
ted through or is caused by creation or modification of this work.


This diff, ID $MirBSD: regen-obsdp.sh,v 1.15 2003/03/09 21:54:38 tg Exp $
(/usr/ports/mystuff/util-metafiles to obsd.util) is made
against CTM on Sat Mar 22 15:42:22 UTC 2003.

### GENERATOR: @@(#)_MirBSD: regen-obsdp.sh,v 1.15 2003/03/09 21:54:38 tg Exp $
### CTM OpenBSD-cvs 3132
d9 1
a9 1
+#	$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d65 1
a65 1
+# $MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d103 1
a103 1
+# Revised: $Date: 2003/03/07 20:32:48 $ by x86@@ePost.de
d879 1
a879 1
+# $MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d907 1
a907 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d1734 1
a1734 1
+$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d2102 1
a2102 1
+# $MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d2135 1
a2135 1
+.\"	$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d2215 1
a2215 1
+# $MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d2234 1
a2234 1
+.\"	$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d3120 1
a3120 1
+/*-	$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d3212 1
a3212 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11569 1
a11569 1
+/*-	$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d11661 1
a11661 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11858 1
a11858 1
+#	$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d12150 1
a12150 1
+#	$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d12448 1
a12448 1
+# $MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d12457 1
a12457 1
+# $MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d12491 1
a12491 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $";
d12744 1
a12744 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $";
d12986 1
a12986 1
+# $MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d12998 1
a12998 1
+# $MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d13018 1
a13018 1
+#	$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d13054 1
a13054 1
+#	$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d13096 1
a13096 1
+.\"	$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
d13153 1
a13153 1
+.\"	$MirBSD: obsd.util,v 1.32 2003/03/07 20:32:48 tg Exp $
a13210 39
Index: ports/mystuff/util-metafiles (meta file)
===================================================================
ports/mystuff/util-metafiles	.
ports/mystuff/util-patchfiles	.
ports/mystuff/util-addedfiles	.
ports/mystuff/util-notes	.
Index: ports/mystuff/util-patchfiles (meta file)
===================================================================
src/gnu/usr.bin/Makefile	+dict +tinyirc
src/share/misc/Makefile		+acronyms
src/usr.bin/Makefile		+wtf +host +ndat +brainfuck
Index: ports/mystuff/util-addedfiles (meta file)
===================================================================
src/gnu/usr.bin/dict/Makefile		me
src/gnu/usr.bin/dict/dict		LICENSE: NPL!
src/gnu/usr.bin/tinyirc/Makefile	me
src/gnu/usr.bin/tinyirc/tinyirc.c	simple IRC client
src/share/misc/acronyms			cared of by me, too
src/usr.bin/brainfuck/Makefile		me
src/usr.bin/brainfuck/brainfuck		three-liner in perl
src/usr.bin/brainfuck/brainfuck.1	me
src/usr.bin/host/Makefile		simpler Makefile for simpler code
src/usr.bin/host/host.1			old usr.sbin/named (bind 4) host(1)
src/usr.bin/host/host.c			all the audited bind4 code in one file
src/usr.bin/host/nslookup		compatibility script
src/usr.bin/ndat/Makefile		me
src/usr.bin/ndat/ndat.c			me
src/usr.bin/wtf/Makefile		me
src/usr.bin/wtf/wtf			much mods by me
src/usr.bin/wtf/wtf.1			from NetBSD
Index: ports/mystuff/util-notes (meta file)
===================================================================
. add brainfuck interpreter in perl
. add ndat
. add wtf plus acronym database
. add gnu/usr.bin/dict LICENSE:NPL
. add gnu/usr.bin/tinyirc
. fix errors in code of wtf, tinyirc, dict
. sync acronyme database against NetBSD
@


1.32
log
@blah blah 509 bytes per string blah blah ISO C99 blah
@
text
@d5 2
a6 5
Copyright  1968-2003 NOP by the authors of and contributors to AT&T
    UNIX; the "C" Language, xBSD/Berkeley Unix; 386BSD, NetBSD 1.1,
    OpenBSD and MirBSD. The licence conditions of specific files be-
    fore patching also applies to the patched unless the file is re-
    placed in its entirety.
d8 3
a10 3
I hereby permit everyone who obtained a copy of this work to distri-
bute, sell, give away, modify, sublicense, merge and use it, freely.
I retain the right to be known as an author of the work.
d12 4
a15 5
The work is provided "as is", with no explicit or implicit warranty.
Use at your own risk. Neither author nor any contributor may be held
liable for any damage, directly or indirectly, which originated thru
creation or modification of this work. Because computing devices are
error-prone, flawless behaviour cannot be expected.
d18 1
a18 1
This diff, ID $MirBSD: regen-obsdp.sh,v 1.14 2003/03/01 22:12:48 tg Exp $
d20 1
a20 1
against CTM on Fri Mar  7 20:30:53 UTC 2003.
d22 2
a23 2
### GENERATOR: @@(#)_MirBSD: regen-obsdp.sh,v 1.14 2003/03/01 22:12:48 tg Exp $
### CTM OpenBSD-cvs 3094
d30 1
a30 1
+++ src/gnu/usr.bin/Makefile	7 Mar 2003 18:07:50 -0000
d32 1
a32 1
+#	$MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
d52 1
a52 1
+++ src/share/misc/Makefile	7 Mar 2003 18:07:50 -0000
d73 1
a73 1
+++ src/usr.bin/Makefile	7 Mar 2003 18:07:50 -0000
d85 2
a86 2
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/gnu/usr.bin/dict/Makefile	Fri Mar  7 18:07:50 2003
d88 1
a88 1
+# $MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
d117 2
a118 2
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/gnu/usr.bin/dict/dict	Fri Mar  7 18:07:50 2003
d126 1
a126 1
+# Revised: $Date: 2003/03/07 18:06:52 $ by x86@@ePost.de
d899 4
a902 4
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Fri Mar  7 18:07:50 2003
@@@@ -0,0 +1,10 @@@@
+# $MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
d907 1
d917 3
a919 3
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Fri Mar  7 18:07:50 2003
@@@@ -0,0 +1,826 @@@@
d930 1
a930 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
d966 1
d1010 1
a1010 1
+*DC, *ptr, *term, *fromhost, IRCNAME[10], inputbuf[512];
d1553 3
d1721 1
a1721 1
+    while (sok) {
d1754 4
a1757 4
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/share/misc/acronyms	Fri Mar  7 18:07:50 2003
@@@@ -0,0 +1,360 @@@@
+$MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
d2084 1
d2122 2
a2123 2
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/usr.bin/brainfuck/Makefile	Fri Mar  7 18:07:50 2003
d2125 1
a2125 1
+# $MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
d2141 2
a2142 2
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/usr.bin/brainfuck/brainfuck	Fri Mar  7 18:07:50 2003
d2155 4
a2158 4
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Fri Mar  7 18:07:50 2003
@@@@ -0,0 +1,77 @@@@
+.\"	$MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
d2160 1
a2160 1
+.\" Copyright (c) 2000-2002 by Thorsten "mirabile" Glaser <x86@@ePost.de>
d2162 3
a2164 6
+.\" I hereby permit everyone who obtained a copy of this work to distri-
+.\" bute, sell, give away, modify, sublicense, merge and use it, freely.
+.\" I retain the right to be known as the author of the work. For no fee
+.\" and further restrainments, all patents hold by the author or contri-
+.\" butors, applying to this work, shall be licensed to any copy of this
+.\" work, whether modified, merged or not.
d2166 4
a2169 5
+.\" The work is provided "as is", with no explicit or implicit warranty.
+.\" Use it at your own risk. Neither the author, nor contributors may be
+.\" held liable for any damage, directly or indirectly, which originated
+.\" by the creation or modification of this work. Since modern computing
+.\" devices are error-prone, flawless behaviour cannot be expected.
d2235 2
a2236 2
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/usr.bin/host/Makefile	Fri Mar  7 18:07:54 2003
d2238 1
a2238 1
+# $MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
d2254 2
a2255 2
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/usr.bin/host/host.1	Fri Mar  7 18:07:54 2003
d2257 1
a2257 1
+.\"	$MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
d3140 4
a3143 4
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/usr.bin/host/host.c	Fri Mar  7 20:30:17 2003
@@@@ -0,0 +1,8450 @@@@
+/*-	$MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
d3149 3
a3151 3
+ * I hereby permit everyone who obtained a copy of this work to distri-
+ * bute, sell, give away, modify, sublicense, merge and use it, freely.
+ * I retain the right to be known as the author of the work.
d3153 4
a3156 5
+ * The work is provided "as is", with no explicit or implicit warranty.
+ * Use it at your own risk. Neither the author, nor contributors may be
+ * held liable for any damage, directly or indirectly, which originated
+ * by the creation or modification of this work. Since modern computing
+ * devices are error-prone, flawless behaviour cannot be expected.
d3235 1
a3235 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11592 281
d11877 3
a11879 3
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/usr.bin/host/nslookup	Fri Mar  7 18:07:54 2003
@@@@ -0,0 +1,292 @@@@
d11881 1
a11881 1
+#	$MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
d12172 17
a12188 9
index: src/usr.bin/ndat/Makefile
===================================================================
RCS file: /cvs/src/usr.bin/ndat/Makefile,v
retrieving revision DEAD
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/usr.bin/ndat/Makefile	Fri Mar  7 18:07:54 2003
@@@@ -0,0 +1,9 @@@@
+# $MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
+# Public domain.
d12190 2
a12191 2
+PROG=	ndat
+CFLAGS+=-Wall -Werror -pedantic
d12193 2
a12194 1
+NOMAN=
d12196 1
a12196 27
+.include <bsd.prog.mk>
index: src/usr.bin/ndat/ndat.c
===================================================================
RCS file: /cvs/src/usr.bin/ndat/ndat.c,v
retrieving revision DEAD
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/usr.bin/ndat/ndat.c	Fri Mar  7 18:07:54 2003
@@@@ -0,0 +1,256 @@@@
+/* $MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
+ * Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
+ *
+ * I hereby permit everyone who obtained a copy of this work to distri-
+ * bute, sell, give away, modify, sublicense, merge and use it, freely.
+ * I retain the right to be known as an author of the work.
+ *
+ * The work is provided "as is", with no explicit or implicit warranty.
+ * Use at your own risk. Neither author nor any contributor may be held
+ * liable for any damage, directly or indirectly, which originated thru
+ * creation or modification of this work. Because computing devices are
+ * error-prone, flawless behaviour cannot be expected.
+ *
+ *
+ * Offizielles Programm der Republica Occultae Germanorum zur Umrechnung
+ * zwischen naturamistischen und neu-christlichen (VAW) Zeitangaben.
+ * Finale Version, funktional identisch und getestet. Bugs gefixt.
+ * manual page still missing... hexadecimal time-of-day too.
+ */
d12198 3
a12200 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $";
d12202 2
d12205 1
a12205 1
+#include <sys/types.h>
d12207 1
a12207 2
+#include <time.h>
+#include <stdio.h>
d12209 2
a12210 4
+int main(int argc, char *argv[]);
+int DatCN(char s, char *otm);
+int DatNC(char s, char *otm);
+int dpm(int m, int y);
d12212 568
a12779 1
+char buf[16];
d12784 1
a12784 1
+#ifdef NO_LATIN1
d13006 16
a13021 4
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/usr.bin/wtf/Makefile	Fri Mar  7 18:07:54 2003
@@@@ -0,0 +1,12 @@@@
+# $MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
d13037 3
a13039 3
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/usr.bin/wtf/wtf	Fri Mar  7 18:07:54 2003
@@@@ -0,0 +1,35 @@@@
d13041 1
a13041 1
+#	$MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
d13048 1
a13048 1
+[ "$1" = "is" -o "$1" = "ist" ] && shift
d13065 1
d13069 1
d13071 30
d13102 5
d13116 61
a13176 4
--- /dev/null	Fri Mar  7 20:18:41 2003
+++ src/usr.bin/wtf/wtf.1	Fri Mar  7 18:07:54 2003
@@@@ -0,0 +1,57 @@@@
+.\"	$MirBSD: obsd.util,v 1.31 2003/03/07 18:06:52 tg Exp $
@


1.31
log
@intermediate; should work tho

sync ports
pull in new egcs-propolice 3.2.2-2 by etoh
www/lynx fallback to active ftp is pasv doesnt work & vice-versa
tinyirc update
stuff compiles with -Wall -Werror -pedantic
@
text
@d24 1
a24 1
against CTM on Fri Mar  7 18:03:54 UTC 2003.
d34 1
a34 1
+++ src/gnu/usr.bin/Makefile	4 Mar 2003 16:53:36 -0000
d36 1
a36 1
+#	$MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $
d56 1
a56 1
+++ src/share/misc/Makefile	4 Mar 2003 16:53:36 -0000
d77 1
a77 1
+++ src/usr.bin/Makefile	4 Mar 2003 16:53:36 -0000
d89 2
a90 2
--- /dev/null	Fri Mar  7 18:03:58 2003
+++ src/gnu/usr.bin/dict/Makefile	Tue Mar  4 16:53:36 2003
d92 1
a92 1
+# $MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $
d121 2
a122 2
--- /dev/null	Fri Mar  7 18:03:58 2003
+++ src/gnu/usr.bin/dict/dict	Tue Mar  4 16:53:36 2003
d130 1
a130 1
+# Revised: $Date: 2003/03/04 16:52:30 $ by x86@@ePost.de
d903 2
a904 2
--- /dev/null	Fri Mar  7 18:03:58 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Fri Mar  7 17:56:14 2003
d906 1
a906 1
+# $MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $
d920 2
a921 2
--- /dev/null	Fri Mar  7 18:03:58 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Fri Mar  7 17:58:17 2003
d933 1
a933 1
+/* tinyirc 1.0		$MirBSD$
d1753 2
a1754 2
--- /dev/null	Fri Mar  7 18:03:58 2003
+++ src/share/misc/acronyms	Thu Mar  6 15:18:43 2003
d1756 1
a1756 1
+$MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $
d2120 2
a2121 2
--- /dev/null	Fri Mar  7 18:03:58 2003
+++ src/usr.bin/brainfuck/Makefile	Tue Mar  4 16:53:37 2003
d2123 1
a2123 1
+# $MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $
d2139 2
a2140 2
--- /dev/null	Fri Mar  7 18:03:58 2003
+++ src/usr.bin/brainfuck/brainfuck	Tue Mar  4 16:53:37 2003
d2153 2
a2154 2
--- /dev/null	Fri Mar  7 18:03:58 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Tue Mar  4 16:53:37 2003
d2156 1
a2156 1
+.\"	$MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $
d2237 2
a2238 2
--- /dev/null	Fri Mar  7 18:03:58 2003
+++ src/usr.bin/host/Makefile	Fri Mar  7 17:55:39 2003
d2240 1
a2240 1
+# $MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $
d2256 2
a2257 2
--- /dev/null	Fri Mar  7 18:03:58 2003
+++ src/usr.bin/host/host.1	Tue Mar  4 16:53:37 2003
d2259 1
a2259 1
+.\"	$MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $
d3142 2
a3143 2
--- /dev/null	Fri Mar  7 18:03:58 2003
+++ src/usr.bin/host/host.c	Tue Mar  4 16:53:37 2003
d3145 1
a3145 1
+/*-	$MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $
d3228 9
a3236 9
+Usage:      host [-v] [-a] [-t querytype] [options]  name  [server]\n\
+Listing:    host [-v] [-a] [-t querytype] [options]  -l zone  [server]\n\
+Hostcount:  host [-v] [options] -H [-D] [-E] [-G] zone\n\
+Check soa:  host [-v] [options] -C zone\n\
+Addrcheck:  host [-v] [options] -A host\n\
+Listing options: [-L level] [-S] [-A] [-p] [-P prefserver] [-N skipzone]\n\
+Common options:  [-d] [-f|-F filename] [-I chars] [-i|-n] [-q] [-T] [-Z]\n\
+Other options:   [-c class] [-e] [-m] [-o] [-r] [-R] [-s secs] [-u] [-w]\n\
+Extended usage:  [-x [name ...]] [-X server [name ...]]\
d3238 1
a3238 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11599 2
a11600 2
--- /dev/null	Fri Mar  7 18:03:58 2003
+++ src/usr.bin/host/nslookup	Tue Mar  4 16:53:37 2003
d11603 1
a11603 1
+#	$MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $
d11898 2
a11899 2
--- /dev/null	Fri Mar  7 18:03:59 2003
+++ src/usr.bin/ndat/Makefile	Fri Mar  7 17:55:50 2003
d11901 1
a11901 1
+# $MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $
d11914 2
a11915 2
--- /dev/null	Fri Mar  7 18:03:59 2003
+++ src/usr.bin/ndat/ndat.c	Fri Mar  7 17:54:27 2003
d11917 1
a11917 1
+/* $MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $
d11937 1
a11937 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $";
d12177 2
a12178 2
--- /dev/null	Fri Mar  7 18:03:59 2003
+++ src/usr.bin/wtf/Makefile	Tue Mar  4 16:53:37 2003
d12180 1
a12180 1
+# $MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $
d12196 2
a12197 2
--- /dev/null	Fri Mar  7 18:03:59 2003
+++ src/usr.bin/wtf/wtf	Tue Mar  4 16:53:37 2003
d12200 1
a12200 1
+#	$MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $
d12238 2
a12239 2
--- /dev/null	Fri Mar  7 18:03:59 2003
+++ src/usr.bin/wtf/wtf.1	Tue Mar  4 16:53:37 2003
d12241 1
a12241 1
+.\"	$MirBSD: obsd.util,v 1.30 2003/03/04 16:52:30 tg Exp $
@


1.30
log
@the usual sync/update post-release
pre-build
@
text
@d24 1
a24 1
against CTM on Tue Mar  4 16:50:07 UTC 2003.
d27 1
a27 1
### CTM OpenBSD-cvs 3085
d34 1
a34 1
+++ src/gnu/usr.bin/Makefile	2 Mar 2003 01:09:34 -0000
d36 1
a36 1
+#	$MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
d56 1
a56 1
+++ src/share/misc/Makefile	2 Mar 2003 01:09:34 -0000
d77 1
a77 1
+++ src/usr.bin/Makefile	2 Mar 2003 01:09:34 -0000
d89 2
a90 2
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/gnu/usr.bin/dict/Makefile	Sun Mar  2 01:09:34 2003
d92 1
a92 1
+# $MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
d121 2
a122 2
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/gnu/usr.bin/dict/dict	Sun Mar  2 01:09:34 2003
d130 1
a130 1
+# Revised: $Date: 2003/03/02 01:08:35 $ by x86@@ePost.de
d903 4
a906 4
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Sun Mar  2 01:09:34 2003
@@@@ -0,0 +1,8 @@@@
+# $MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
d910 3
a913 1
+LDADD=	-lcurses
d920 3
a922 3
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Sun Mar  2 01:09:34 2003
@@@@ -0,0 +1,811 @@@@
d924 2
a925 1
+#define USETERMIOS	1
a926 1
+static char *DEFAULTSERVER = "irc.freenode.net";
d930 4
a933 4
+#define HISTLEN		32
+#define RELEASE		"TinyIRC pre1.0"
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
+   THIS VERSION OF TINYIRC WORKS ONLY WITH 2.8.x IRC SERVERS!!!!
d937 1
d960 2
a963 1
+    * command /QUOTE alias /Q
d966 3
a968 1
+
d1012 2
a1013 2
+*DC, *ptr, *fromhost, IRCNAME[10], inputbuf[512];
+char *term, bp[1024];
d1308 8
a1315 3
+/* list of all ircd 2.8.16 server commands - alpha order for searching */
+#define LISTSIZE 49
+/* Not sorted any more because of shortcut shortcomings -mirabile */
d1320 1
a1320 1
+ "PART", "PASS", "PING", "PONG", "PRIVMSG", "QUIT", "REHASH", "RESTART",
d1322 1
a1322 4
+ "USERHOST", "USERS", "VERSION", "WHOIS", "WALLOPS", "WHO", "WHOWAS"};
+#define DO_JOIN 12
+#define DO_MSG 18
+#define DO_PRIVMSG 30
d1324 7
a1330 3
+{1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 2, 1, 1, 3, 2, 1, 1, 2, 2, 1, 2, 1, 1, 1,
+ 2, 2, 1, 1, 1, 1, 2, 1, 1, 1, 3, 2, 1, 3, 1, 2, 2, 4, 1, 1, 1, 1, 1, 1,
+ 1};
d1332 6
a1337 5
+{ nop, nop, nop, nop, nop, nop, doerror, nop, nop, nop, doinvite, nop,
+  dojoin, dokick, dokill, nop, nop, nop, domode, nop, nop, nop, donick,
+  nop, donotice, nop, dopart, nop, nop, dopong, doprivmsg, doquit, nop,
+  nop, nop, dosquit, nop, nop, dotime, dotopic, nop, nop, nop, nop, nop,
+  nop, nop, nop, nop
d1462 4
a1465 1
+	strcpy(lineout, cmdlist[i]);
d1628 2
a1629 1
+int main(argc, argv)
d1753 2
a1754 2
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/share/misc/acronyms	Sun Mar  2 01:09:34 2003
d1756 1
a1756 1
+$MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
d1826 1
a1826 1
+ESR	Eric Steven Raymond -- http://www.tuxedo.org/~esr/
d2042 1
a2042 1
+RTFJF	read the fine jargon file: http://www.tuxedo.org/~esr/jargon/
d2120 2
a2121 2
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/usr.bin/brainfuck/Makefile	Sun Mar  2 01:09:34 2003
d2123 1
a2123 1
+# $MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
d2139 2
a2140 2
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/usr.bin/brainfuck/brainfuck	Sun Mar  2 01:09:34 2003
d2153 2
a2154 2
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Sun Mar  2 01:09:34 2003
d2156 1
a2156 1
+.\"	$MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
d2237 2
a2238 2
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/usr.bin/host/Makefile	Sun Mar  2 01:09:34 2003
d2240 1
a2240 1
+# $MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
d2244 1
a2244 1
+CFLAGS+=-Wall -Werror
d2256 2
a2257 2
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/usr.bin/host/host.1	Sun Mar  2 01:09:34 2003
d2259 1
a2259 1
+.\"	$MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
d3142 2
a3143 2
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/usr.bin/host/host.c	Sun Mar  2 01:09:34 2003
d3145 1
a3145 1
+/*-	$MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
d3238 1
a3238 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11599 2
a11600 2
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/usr.bin/host/nslookup	Sun Mar  2 01:09:34 2003
d11603 1
a11603 1
+#	$MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
d11898 4
a11901 4
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/usr.bin/ndat/Makefile	Sun Mar  2 01:09:34 2003
@@@@ -0,0 +1,7 @@@@
+# $MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
d11905 2
d11914 2
a11915 2
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/usr.bin/ndat/ndat.c	Sun Mar  2 01:09:34 2003
d11917 1
a11917 1
+/* $MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
d11922 1
a11922 1
+ * I retain the right to be known as the author of the work.
d11925 4
a11928 4
+ * Use it at your own risk. Neither the author, nor contributors may be
+ * held liable for any damage, directly or indirectly, which originated
+ * by the creation or modification of this work. Since modern computing
+ * devices are error-prone, flawless behaviour cannot be expected.
d11937 1
a11937 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $";
d12177 2
a12178 2
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/usr.bin/wtf/Makefile	Sun Mar  2 01:09:34 2003
d12180 1
a12180 1
+# $MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
d12196 2
a12197 2
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/usr.bin/wtf/wtf	Sun Mar  2 01:09:34 2003
d12200 1
a12200 1
+#	$MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
d12238 2
a12239 2
--- /dev/null	Tue Mar  4 16:46:20 2003
+++ src/usr.bin/wtf/wtf.1	Sun Mar  2 01:09:34 2003
d12241 1
a12241 1
+.\"	$MirBSD: obsd.util,v 1.29 2003/03/02 01:08:35 tg Exp $
@


1.29
log
@pre-build Sn#3-RC2

1914 KiB
@
text
@d24 1
a24 1
against anoncvs@@anoncvs.comstyle.com:/cvs on Sat Mar  1 20:45:58 UTC 2003.
d27 1
d33 2
a34 2
--- src/gnu/usr.bin/Makefile	2002/06/12 04:17:24	1.32
+++ src/gnu/usr.bin/Makefile	2003/03/02 01:07:46
d36 1
a36 1
+#	$MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
d55 2
a56 2
--- src/share/misc/Makefile	2001/10/05 17:30:51	1.8
+++ src/share/misc/Makefile	2003/03/02 01:07:46
d76 2
a77 2
--- src/usr.bin/Makefile	2002/07/24 01:08:56	1.79
+++ src/usr.bin/Makefile	2003/03/02 01:07:46
d89 2
a90 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/gnu/usr.bin/dict/Makefile	Sat Mar  1 15:23:59 2003
d92 1
a92 1
+# $MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
d121 2
a122 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/gnu/usr.bin/dict/dict	Sat Mar  1 15:23:59 2003
d130 1
a130 1
+# Revised: $Date: 2003/03/01 15:23:52 $ by x86@@ePost.de
d903 2
a904 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Sat Mar  1 15:23:59 2003
d906 1
a906 1
+# $MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
d918 2
a919 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Sat Mar  1 15:23:59 2003
d930 1
a930 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
d1736 2
a1737 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/share/misc/acronyms	Sat Mar  1 15:23:59 2003
d1739 1
a1739 1
+$MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
d2103 2
a2104 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/usr.bin/brainfuck/Makefile	Sat Mar  1 15:23:59 2003
d2106 1
a2106 1
+# $MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
d2122 2
a2123 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/usr.bin/brainfuck/brainfuck	Sat Mar  1 15:23:59 2003
d2136 2
a2137 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Sat Mar  1 15:23:59 2003
d2139 1
a2139 1
+.\"	$MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
d2220 2
a2221 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/usr.bin/host/Makefile	Sat Mar  1 15:23:59 2003
d2223 1
a2223 1
+# $MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
d2239 2
a2240 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/usr.bin/host/host.1	Sat Mar  1 15:23:59 2003
d2242 1
a2242 1
+.\"	$MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
d3125 2
a3126 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/usr.bin/host/host.c	Sat Mar  1 15:23:59 2003
d3128 1
a3128 1
+/*-	$MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
d3221 1
a3221 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11582 2
a11583 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/usr.bin/host/nslookup	Sat Mar  1 15:23:59 2003
d11586 1
a11586 1
+#	$MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
d11881 2
a11882 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/usr.bin/ndat/Makefile	Sat Mar  1 15:23:59 2003
d11884 1
a11884 1
+# $MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
d11895 2
a11896 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/usr.bin/ndat/ndat.c	Sat Mar  1 15:23:59 2003
d11898 1
a11898 1
+/* $MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
d11918 1
a11918 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $";
d12158 2
a12159 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/usr.bin/wtf/Makefile	Sat Mar  1 15:23:59 2003
d12161 1
a12161 1
+# $MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
d12177 2
a12178 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/usr.bin/wtf/wtf	Sat Mar  1 15:23:59 2003
d12181 1
a12181 1
+#	$MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
d12219 2
a12220 2
--- /dev/null	Sun Mar  2 00:56:39 2003
+++ src/usr.bin/wtf/wtf.1	Sat Mar  1 15:23:59 2003
d12222 1
a12222 1
+.\"	$MirBSD: obsd.util,v 1.28 2003/03/01 15:23:52 tg Exp $
@


1.28
log
@post-build

saad@@ gave us another acronyme
the stuff except XF4 builds fine. XF4 untested.
@
text
@d9 1
a9 1
    placed in its entirety (not easily distinguishable in the diff).
d22 1
a22 1
This diff, ID $MirBSD: regen-obsdp.sh,v 1.13 2003/02/28 22:52:54 tg Exp $
d24 1
a24 1
against CTM on Sat Mar  1 15:21:15 UTC 2003.
d26 1
a26 2
### GENERATOR: @@(#)_MirBSD: regen-obsdp.sh,v 1.13 2003/02/28 22:52:54 tg Exp $
### CTM OpenBSD-cvs 3075
d32 2
a33 2
--- src/gnu/usr.bin/Makefile	12 Jun 2002 04:17:02 -0000	1.32
+++ src/gnu/usr.bin/Makefile	1 Mar 2003 13:41:03 -0000
d35 1
a35 1
+#	$MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
d54 2
a55 2
--- src/share/misc/Makefile	5 Oct 2001 17:30:29 -0000	1.8
+++ src/share/misc/Makefile	1 Mar 2003 13:41:03 -0000
d75 2
a76 2
--- src/usr.bin/Makefile	24 Jul 2002 01:08:34 -0000	1.79
+++ src/usr.bin/Makefile	1 Mar 2003 13:41:03 -0000
d84 1
a84 1
Index: src/gnu/usr.bin/dict/Makefile
d88 2
a89 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/gnu/usr.bin/dict/Makefile	Sat Mar  1 13:41:03 2003
d91 1
a91 1
+# $MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
d116 1
a116 1
Index: src/gnu/usr.bin/dict/dict
d120 2
a121 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/gnu/usr.bin/dict/dict	Sat Mar  1 13:41:03 2003
d129 1
a129 1
+# Revised: $Date: 2003/03/01 13:16:09 $ by x86@@ePost.de
d898 1
a898 1
Index: src/gnu/usr.bin/tinyirc/Makefile
d902 2
a903 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Sat Mar  1 13:41:03 2003
d905 1
a905 1
+# $MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
d913 1
a913 1
Index: src/gnu/usr.bin/tinyirc/tinyirc.c
d917 2
a918 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Sat Mar  1 14:32:28 2003
d929 1
a929 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
d1731 1
a1731 1
Index: src/share/misc/acronyms
d1735 2
a1736 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/share/misc/acronyms	Sat Mar  1 15:18:45 2003
d1738 1
a1738 1
+$MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
d2098 1
a2098 1
Index: src/usr.bin/brainfuck/Makefile
d2102 2
a2103 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/usr.bin/brainfuck/Makefile	Sat Mar  1 13:41:03 2003
d2105 1
a2105 1
+# $MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
d2117 1
a2117 1
Index: src/usr.bin/brainfuck/brainfuck
d2121 2
a2122 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/usr.bin/brainfuck/brainfuck	Sat Mar  1 13:41:03 2003
d2131 1
a2131 1
Index: src/usr.bin/brainfuck/brainfuck.1
d2135 2
a2136 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Sat Mar  1 13:41:03 2003
d2138 1
a2138 1
+.\"	$MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
d2215 1
a2215 1
Index: src/usr.bin/host/Makefile
d2219 2
a2220 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/usr.bin/host/Makefile	Sat Mar  1 13:41:03 2003
d2222 1
a2222 1
+# $MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
d2234 1
a2234 1
Index: src/usr.bin/host/host.1
d2238 2
a2239 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/usr.bin/host/host.1	Sat Mar  1 13:41:03 2003
d2241 1
a2241 1
+.\"	$MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
d3120 1
a3120 1
Index: src/usr.bin/host/host.c
d3124 2
a3125 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/usr.bin/host/host.c	Sat Mar  1 13:41:03 2003
d3127 1
a3127 1
+/*-	$MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
d3220 1
a3220 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11577 1
a11577 1
Index: src/usr.bin/host/nslookup
d11581 2
a11582 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/usr.bin/host/nslookup	Sat Mar  1 13:41:03 2003
d11585 1
a11585 1
+#	$MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
d11876 1
a11876 1
Index: src/usr.bin/ndat/Makefile
d11880 2
a11881 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/usr.bin/ndat/Makefile	Sat Mar  1 13:41:03 2003
d11883 1
a11883 1
+# $MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
d11890 1
a11890 1
Index: src/usr.bin/ndat/ndat.c
d11894 2
a11895 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/usr.bin/ndat/ndat.c	Sat Mar  1 13:41:03 2003
d11897 1
a11897 1
+/* $MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
d11917 1
a11917 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $";
d12153 1
a12153 1
Index: src/usr.bin/wtf/Makefile
d12157 2
a12158 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/usr.bin/wtf/Makefile	Sat Mar  1 13:41:03 2003
d12160 1
a12160 1
+# $MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
d12172 1
a12172 1
Index: src/usr.bin/wtf/wtf
d12176 2
a12177 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/usr.bin/wtf/wtf	Sat Mar  1 13:41:03 2003
d12180 1
a12180 1
+#	$MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
d12214 1
a12214 1
Index: src/usr.bin/wtf/wtf.1
d12218 2
a12219 2
--- /dev/null	Sat Mar  1 15:16:56 2003
+++ src/usr.bin/wtf/wtf.1	Sat Mar  1 13:41:03 2003
d12221 1
a12221 1
+.\"	$MirBSD: obsd.util,v 1.27 2003/03/01 13:16:09 tg Exp $
@


1.27
log
@pre-build

fix ELF, file lists, domain, misc. stuff
@
text
@d24 1
a24 1
against CTM on Sat Mar  1 13:09:41 UTC 2003.
d34 1
a34 1
+++ src/gnu/usr.bin/Makefile	1 Mar 2003 10:26:32 -0000
d36 1
a36 1
+#	$MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
d56 1
a56 1
+++ src/share/misc/Makefile	1 Mar 2003 10:26:32 -0000
d77 1
a77 1
+++ src/usr.bin/Makefile	1 Mar 2003 10:26:32 -0000
d89 2
a90 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/gnu/usr.bin/dict/Makefile	Sat Mar  1 10:26:32 2003
d92 1
a92 1
+# $MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
d121 2
a122 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/gnu/usr.bin/dict/dict	Sat Mar  1 10:26:32 2003
d130 1
a130 1
+# Revised: $Date: 2003/03/01 10:05:37 $ by x86@@ePost.de
d903 2
a904 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Sat Mar  1 10:26:32 2003
d906 1
a906 1
+# $MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
d918 2
a919 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Sat Mar  1 10:26:32 2003
d930 1
a930 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
d1313 1
a1313 1
+#define DO_MSG 20
d1736 4
a1739 4
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/share/misc/acronyms	Sat Mar  1 10:26:32 2003
@@@@ -0,0 +1,359 @@@@
+$MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
d2078 1
d2103 2
a2104 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/usr.bin/brainfuck/Makefile	Sat Mar  1 10:26:32 2003
d2106 1
a2106 1
+# $MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
d2122 2
a2123 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/usr.bin/brainfuck/brainfuck	Sat Mar  1 10:26:32 2003
d2136 2
a2137 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Sat Mar  1 10:26:32 2003
d2139 1
a2139 1
+.\"	$MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
d2220 2
a2221 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/usr.bin/host/Makefile	Sat Mar  1 10:26:32 2003
d2223 1
a2223 1
+# $MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
d2239 2
a2240 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/usr.bin/host/host.1	Sat Mar  1 10:26:32 2003
d2242 1
a2242 1
+.\"	$MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
d3125 2
a3126 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/usr.bin/host/host.c	Sat Mar  1 10:26:32 2003
d3128 1
a3128 1
+/*-	$MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
d3221 1
a3221 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11582 2
a11583 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/usr.bin/host/nslookup	Sat Mar  1 10:26:32 2003
d11586 1
a11586 1
+#	$MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
d11881 2
a11882 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/usr.bin/ndat/Makefile	Sat Mar  1 10:26:35 2003
d11884 1
a11884 1
+# $MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
d11895 2
a11896 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/usr.bin/ndat/ndat.c	Sat Mar  1 10:26:35 2003
d11898 1
a11898 1
+/* $MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
d11918 1
a11918 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $";
d12158 2
a12159 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/usr.bin/wtf/Makefile	Sat Mar  1 10:26:35 2003
d12161 1
a12161 1
+# $MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
d12177 2
a12178 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/usr.bin/wtf/wtf	Sat Mar  1 10:26:35 2003
d12181 1
a12181 1
+#	$MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
d12219 2
a12220 2
--- /dev/null	Sat Mar  1 13:09:38 2003
+++ src/usr.bin/wtf/wtf.1	Sat Mar  1 10:26:35 2003
d12222 1
a12222 1
+.\"	$MirBSD: obsd.util,v 1.26 2003/03/01 10:05:37 tg Exp $
@


1.26
log
@post-build developer

I'm not sure if egcs builds now...
@
text
@d24 1
a24 1
against CTM on Sat Mar  1 10:05:01 UTC 2003.
d27 1
a27 1
### CTM OpenBSD-cvs 3073
d34 1
a34 1
+++ src/gnu/usr.bin/Makefile	28 Feb 2003 18:23:07 -0000
d36 1
a36 1
+#	$MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
d56 1
a56 1
+++ src/share/misc/Makefile	28 Feb 2003 18:23:07 -0000
d77 1
a77 1
+++ src/usr.bin/Makefile	28 Feb 2003 18:23:07 -0000
d89 2
a90 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/gnu/usr.bin/dict/Makefile	Fri Feb 28 18:23:07 2003
d92 1
a92 1
+# $MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
d121 2
a122 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/gnu/usr.bin/dict/dict	Fri Feb 28 18:23:07 2003
d130 1
a130 1
+# Revised: $Date: 2003/02/28 18:22:12 $ by x86@@ePost.de
d903 2
a904 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Fri Feb 28 18:23:07 2003
d906 1
a906 1
+# $MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
d918 2
a919 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Fri Feb 28 18:23:07 2003
d930 1
a930 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
d1736 2
a1737 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/share/misc/acronyms	Fri Feb 28 18:23:07 2003
d1739 1
a1739 1
+$MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
d2102 2
a2103 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/usr.bin/brainfuck/Makefile	Fri Feb 28 18:23:07 2003
d2105 1
a2105 1
+# $MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
d2121 2
a2122 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/usr.bin/brainfuck/brainfuck	Fri Feb 28 18:23:07 2003
d2135 2
a2136 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Fri Feb 28 18:23:07 2003
d2138 1
a2138 1
+.\"	$MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
d2219 2
a2220 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/usr.bin/host/Makefile	Fri Feb 28 18:23:07 2003
d2222 1
a2222 1
+# $MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
d2238 2
a2239 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/usr.bin/host/host.1	Fri Feb 28 18:23:07 2003
d2241 1
a2241 1
+.\"	$MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
d3124 2
a3125 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/usr.bin/host/host.c	Fri Feb 28 18:23:07 2003
d3127 1
a3127 1
+/*-	$MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
d3220 1
a3220 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11581 2
a11582 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/usr.bin/host/nslookup	Fri Feb 28 18:23:07 2003
d11585 1
a11585 1
+#	$MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
d11880 2
a11881 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/usr.bin/ndat/Makefile	Fri Feb 28 18:23:07 2003
d11883 1
a11883 1
+# $MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
d11894 2
a11895 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/usr.bin/ndat/ndat.c	Fri Feb 28 18:23:07 2003
d11897 1
a11897 1
+/* $MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
d11917 1
a11917 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $";
d12157 2
a12158 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/usr.bin/wtf/Makefile	Fri Feb 28 18:23:07 2003
d12160 1
a12160 1
+# $MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
d12176 2
a12177 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/usr.bin/wtf/wtf	Fri Feb 28 18:23:07 2003
d12180 1
a12180 1
+#	$MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
d12218 2
a12219 2
--- /dev/null	Sat Mar  1 10:00:31 2003
+++ src/usr.bin/wtf/wtf.1	Fri Feb 28 18:23:07 2003
d12221 1
a12221 1
+.\"	$MirBSD: obsd.util,v 1.25 2003/02/28 18:22:12 tg Exp $
@


1.25
log
@intermediate broken

to survive a make build, does not mean,
to be able to build a kernel (not even a.out)

gcc was broken prior, too. hope it is fixed now.
@
text
@a2 1
>> Thank you, Theo de Raadt and all other contributors to OpenBSD.
a4 1
Contributors:
d13 1
a13 1
I retain the right to be known as the author of the work.
d16 4
a19 4
Use it at your own risk. Neither the author, nor contributors may be
held liable for any damage, directly or indirectly, which originated
by the creation or modification of this work. Since modern computing
devices are error-prone, flawless behaviour cannot be expected.
d22 1
a22 1
This diff, ID $MirBSD: regen-obsdp.sh,v 1.11 2003/02/23 17:34:59 tg Exp $
d24 1
a24 1
against CTM on Fri Feb 28 18:19:00 UTC 2003.
d26 1
a26 1
### GENERATOR: @@(#)_MirBSD: regen-obsdp.sh,v 1.11 2003/02/23 17:34:59 tg Exp $
d34 1
a34 1
+++ src/gnu/usr.bin/Makefile	24 Feb 2003 21:33:13 -0000
d36 1
a36 1
+#	$MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
d56 1
a56 1
+++ src/share/misc/Makefile	24 Feb 2003 21:33:13 -0000
d77 1
a77 1
+++ src/usr.bin/Makefile	24 Feb 2003 21:33:13 -0000
d89 2
a90 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/gnu/usr.bin/dict/Makefile	Mon Feb 24 21:33:13 2003
d92 1
a92 1
+# $MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
d121 2
a122 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/gnu/usr.bin/dict/dict	Mon Feb 24 21:33:13 2003
d130 1
a130 1
+# Revised: $Date: 2003/02/24 21:32:08 $ by x86@@ePost.de
d903 2
a904 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Mon Feb 24 21:33:13 2003
d906 1
a906 1
+# $MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
d918 2
a919 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Mon Feb 24 21:33:13 2003
d930 1
a930 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
d1736 2
a1737 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/share/misc/acronyms	Mon Feb 24 21:33:13 2003
d1739 1
a1739 1
+$MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
d2102 2
a2103 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/usr.bin/brainfuck/Makefile	Mon Feb 24 21:33:13 2003
d2105 1
a2105 1
+# $MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
d2121 2
a2122 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/usr.bin/brainfuck/brainfuck	Mon Feb 24 21:33:13 2003
d2135 2
a2136 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Mon Feb 24 21:33:13 2003
d2138 1
a2138 1
+.\"	$MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
d2219 2
a2220 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/usr.bin/host/Makefile	Mon Feb 24 21:33:13 2003
d2222 1
a2222 1
+# $MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
d2238 2
a2239 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/usr.bin/host/host.1	Mon Feb 24 21:33:13 2003
d2241 1
a2241 1
+.\"	$MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
d3124 2
a3125 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/usr.bin/host/host.c	Mon Feb 24 21:33:13 2003
d3127 1
a3127 1
+/*-	$MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
d3220 1
a3220 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11581 2
a11582 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/usr.bin/host/nslookup	Mon Feb 24 21:33:13 2003
d11585 1
a11585 1
+#	$MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
d11880 2
a11881 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/usr.bin/ndat/Makefile	Mon Feb 24 21:33:15 2003
d11883 1
a11883 1
+# $MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
d11894 2
a11895 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/usr.bin/ndat/ndat.c	Mon Feb 24 21:33:15 2003
d11897 1
a11897 1
+/* $MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
d11917 1
a11917 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $";
d12157 2
a12158 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/usr.bin/wtf/Makefile	Mon Feb 24 21:33:17 2003
d12160 1
a12160 1
+# $MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
d12176 2
a12177 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/usr.bin/wtf/wtf	Mon Feb 24 21:33:17 2003
d12180 1
a12180 1
+#	$MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
d12218 2
a12219 2
--- /dev/null	Fri Feb 28 18:11:26 2003
+++ src/usr.bin/wtf/wtf.1	Mon Feb 24 21:33:17 2003
d12221 1
a12221 1
+.\"	$MirBSD: obsd.util,v 1.24 2003/02/24 21:32:08 tg Exp $
@


1.24
log
@post-release development

Made make build release succeed and synched plists to the amount needed.
OTOH I don't know if a _kernel_ build with this will succeed...
@
text
@d26 1
a26 1
against CTM on Mon Feb 24 21:29:57 UTC 2003.
d29 1
a29 1
### CTM OpenBSD-cvs 3060
d36 1
a36 1
+++ src/gnu/usr.bin/Makefile	23 Feb 2003 18:22:41 -0000
d38 1
a38 1
+#	$MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
d58 1
a58 1
+++ src/share/misc/Makefile	23 Feb 2003 18:22:41 -0000
d79 1
a79 1
+++ src/usr.bin/Makefile	23 Feb 2003 18:22:41 -0000
d91 2
a92 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/gnu/usr.bin/dict/Makefile	Sun Feb 23 18:22:41 2003
d94 1
a94 1
+# $MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
d123 2
a124 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/gnu/usr.bin/dict/dict	Sun Feb 23 18:22:41 2003
d132 1
a132 1
+# Revised: $Date: 2003/02/23 17:59:46 $ by x86@@ePost.de
d905 2
a906 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Sun Feb 23 18:22:41 2003
d908 1
a908 1
+# $MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
d920 2
a921 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Sun Feb 23 18:22:42 2003
d932 1
a932 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
d1738 2
a1739 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/share/misc/acronyms	Sun Feb 23 18:22:42 2003
d1741 1
a1741 1
+$MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
d2104 2
a2105 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/usr.bin/brainfuck/Makefile	Sun Feb 23 18:22:42 2003
d2107 1
a2107 1
+# $MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
d2123 2
a2124 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/usr.bin/brainfuck/brainfuck	Sun Feb 23 18:22:42 2003
d2137 2
a2138 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Sun Feb 23 18:22:42 2003
d2140 1
a2140 1
+.\"	$MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
d2221 2
a2222 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/usr.bin/host/Makefile	Sun Feb 23 18:22:42 2003
d2224 1
a2224 1
+# $MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
d2240 2
a2241 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/usr.bin/host/host.1	Sun Feb 23 18:22:42 2003
d2243 1
a2243 1
+.\"	$MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
d3126 2
a3127 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/usr.bin/host/host.c	Sun Feb 23 18:22:42 2003
d3129 1
a3129 1
+/*-	$MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
d3222 1
a3222 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11583 2
a11584 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/usr.bin/host/nslookup	Sun Feb 23 18:22:42 2003
d11587 1
a11587 1
+#	$MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
d11882 2
a11883 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/usr.bin/ndat/Makefile	Sun Feb 23 18:22:42 2003
d11885 1
a11885 1
+# $MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
d11896 2
a11897 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/usr.bin/ndat/ndat.c	Sun Feb 23 18:22:42 2003
d11899 1
a11899 1
+/* $MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
d11919 1
a11919 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $";
d12159 2
a12160 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/usr.bin/wtf/Makefile	Sun Feb 23 18:22:42 2003
d12162 1
a12162 1
+# $MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
d12178 2
a12179 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/usr.bin/wtf/wtf	Sun Feb 23 18:22:42 2003
d12182 1
a12182 1
+#	$MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
d12220 2
a12221 2
--- /dev/null	Mon Feb 24 21:18:01 2003
+++ src/usr.bin/wtf/wtf.1	Sun Feb 23 18:22:42 2003
d12223 1
a12223 1
+.\"	$MirBSD: obsd.util,v 1.23 2003/02/23 17:59:46 tg Exp $
@


1.23
log
@intermediate broken

first attempt to upgrade source tree and clean it up
additionally it makes libkern smaller by another like 20 bytes...
@
text
@d26 1
a26 1
against CTM on Sun Feb 23 17:42:45 UTC 2003.
d36 1
a36 1
+++ src/gnu/usr.bin/Makefile	23 Feb 2003 17:39:49 -0000
d38 1
a38 1
+#	$MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
d58 1
a58 1
+++ src/share/misc/Makefile	23 Feb 2003 17:39:49 -0000
d79 1
a79 1
+++ src/usr.bin/Makefile	23 Feb 2003 17:39:49 -0000
d91 2
a92 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/gnu/usr.bin/dict/Makefile	Sun Feb 23 17:39:49 2003
d94 1
a94 1
+# $MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
d123 2
a124 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/gnu/usr.bin/dict/dict	Sun Feb 23 17:39:49 2003
d132 1
a132 1
+# Revised: $Date: 2003/02/11 21:08:32 $ by x86@@ePost.de
d905 2
a906 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Sun Feb 23 17:39:49 2003
d908 1
a908 1
+# $MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
d920 2
a921 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Sun Feb 23 17:39:49 2003
d932 1
a932 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
d1738 2
a1739 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/share/misc/acronyms	Sun Feb 23 17:39:49 2003
d1741 1
a1741 1
+$MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
d2104 2
a2105 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/usr.bin/brainfuck/Makefile	Sun Feb 23 17:39:49 2003
d2107 1
a2107 1
+# $MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
d2123 2
a2124 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/usr.bin/brainfuck/brainfuck	Sun Feb 23 17:39:49 2003
d2137 2
a2138 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Sun Feb 23 17:39:49 2003
d2140 1
a2140 1
+.\"	$MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
d2221 2
a2222 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/usr.bin/host/Makefile	Sun Feb 23 17:39:49 2003
d2224 1
a2224 1
+# $MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
d2240 2
a2241 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/usr.bin/host/host.1	Sun Feb 23 17:39:49 2003
d2243 1
a2243 1
+.\"	$MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
d3126 2
a3127 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/usr.bin/host/host.c	Sun Feb 23 17:42:39 2003
d3129 1
a3129 1
+/*-	$MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
d3222 1
a3222 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11583 2
a11584 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/usr.bin/host/nslookup	Sun Feb 23 17:42:38 2003
d11587 1
a11587 1
+#	$MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
d11882 2
a11883 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/usr.bin/ndat/Makefile	Sun Feb 23 17:39:49 2003
d11885 1
a11885 1
+# $MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
d11896 2
a11897 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/usr.bin/ndat/ndat.c	Sun Feb 23 17:41:20 2003
d11899 1
a11899 1
+/* $MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
d11919 1
a11919 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $";
d12159 2
a12160 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/usr.bin/wtf/Makefile	Sun Feb 23 17:39:49 2003
d12162 1
a12162 1
+# $MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
d12178 2
a12179 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/usr.bin/wtf/wtf	Sun Feb 23 17:39:49 2003
d12182 1
a12182 1
+#	$MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
d12220 2
a12221 2
--- /dev/null	Sun Feb 23 17:38:10 2003
+++ src/usr.bin/wtf/wtf.1	Sun Feb 23 17:39:49 2003
d12223 1
a12223 1
+.\"	$MirBSD: obsd.util,v 1.22 2003/02/11 21:08:32 tg Exp $
@


1.22
log
@post-build

MirBSD goes ELF now
still needs a.out loader (and kernel?)

add more signatures; fix hostname
@
text
@d1 3
a3 1
>>> http://templeofhate.com/tglaser/MirBSD/index.php
d5 1
a5 1
Copyright (c) 2000-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
d7 5
a11 4
Copyright (c) 1968-2003 NOP by the authors of and contributors to C,
    UNIX, BSD/Berkeley Unix, 386BSD, NetBSD and OpenBSD. The licen-
    ce of the file before patching also applies to the patch, unless
    special provisions are made.
d15 1
a15 4
I retain the right to be known as the author of the work. The author
and every single contributor, unless marked with "NOP" above, hereby
waive their right to require additional patent licences for usage of
this work, even if the work could infringe patents hold by them.
d24 1
a24 1
This diff, ID $MirBSD: regen-obsdp.sh,v 1.7 2003/02/10 19:33:07 tg Exp $
d26 1
a26 1
against /cvs on Tue Jan 28 23:58:42 UTC 2003.
d28 2
a29 1
### GENERATOR: @@(#)_MirBSD: regen-obsdp.sh,v 1.7 2003/02/10 19:33:07 tg Exp $
d36 1
a36 1
+++ src/gnu/usr.bin/Makefile	11 Feb 2003 20:16:18 -0000
d38 1
a38 1
+#	$MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
d58 1
a58 1
+++ src/share/misc/Makefile	11 Feb 2003 20:16:18 -0000
d79 1
a79 1
+++ src/usr.bin/Makefile	11 Feb 2003 20:16:18 -0000
d91 2
a92 2
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/gnu/usr.bin/dict/Makefile	Tue Feb 11 20:16:18 2003
d94 1
a94 1
+# $MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
d123 2
a124 2
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/gnu/usr.bin/dict/dict	Tue Feb 11 20:16:18 2003
d132 1
a132 1
+# Revised: $Date: 2003/02/11 20:02:19 $ by x86@@ePost.de
d905 2
a906 2
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Tue Feb 11 20:16:18 2003
d908 1
a908 1
+# $MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
d920 2
a921 2
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Tue Feb 11 20:16:18 2003
d932 1
a932 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
d1738 5
a1742 6
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/share/misc/acronyms	Tue Feb 11 20:16:18 2003
@@@@ -0,0 +1,353 @@@@
+$MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
+$NetBSD: acronyms,v 1.112 2002/09/27 03:40:46 junyoung Exp $
+
d1840 3
d1853 1
d1984 2
d2080 1
d2104 2
a2105 2
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/usr.bin/brainfuck/Makefile	Tue Feb 11 20:16:18 2003
d2107 1
a2107 1
+# $MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
d2123 2
a2124 2
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/usr.bin/brainfuck/brainfuck	Tue Feb 11 20:16:18 2003
d2137 2
a2138 2
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Tue Feb 11 20:16:18 2003
d2140 1
a2140 1
+.\"	$MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
d2221 2
a2222 2
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/usr.bin/host/Makefile	Tue Feb 11 20:16:18 2003
d2224 1
a2224 1
+# $MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
d2240 2
a2241 2
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/usr.bin/host/host.1	Tue Feb 11 20:16:18 2003
d2243 1
a2243 1
+.\"	$MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
d3126 4
a3129 4
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/usr.bin/host/host.c	Tue Feb 11 20:16:18 2003
@@@@ -0,0 +1,8453 @@@@
+/*-	$MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
d3132 2
a3133 2
+ * Copyright (c) 2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
+ * Copyright (c) NOP by Eric Wassenaar, Nikhef-H, <e07@@nikhef.nl>
d3137 1
a3137 4
+ * I retain the right to be known as the author of the work. The author
+ * and every single contributor, unless marked with "NOP" above, hereby
+ * waive their right to require additional patent licences for usage of
+ * this work, even if the work could infringe patents hold by them.
d3222 1
a3222 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11583 3
a11585 3
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/usr.bin/host/nslookup	Tue Feb 11 20:16:18 2003
@@@@ -0,0 +1,295 @@@@
d11587 1
a11587 1
+#	$MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
d11591 2
a11592 2
+# Copyright (c) 2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
+# Copyright (c) NOP by Eric Wassenaar, Nikhef-H, <e07@@nikhef.nl>
d11596 1
a11596 4
+# I retain the right to be known as the author of the work. The author
+# and every single contributor, unless marked with "NOP" above, hereby
+# waive their right to require additional patent licences for usage of
+# this work, even if the work could infringe patents hold by them.
d11882 2
a11883 2
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/usr.bin/ndat/Makefile	Tue Feb 11 20:16:18 2003
d11885 1
a11885 1
+# $MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
d11896 5
a11900 5
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/usr.bin/ndat/ndat.c	Tue Feb 11 20:16:18 2003
@@@@ -0,0 +1,259 @@@@
+/* $MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
+ * Copyright (c) 2000-2002 by Thorsten "mirabile" Glaser <x86@@ePost.de>
d11904 1
a11904 4
+ * I retain the right to be known as the author of the work. The author
+ * and every single contributor, unless marked with "NOP" above, hereby
+ * waive their right to require additional patent licences for usage of
+ * this work, even if the work could infringe patents hold by them.
d11919 1
a11919 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $";
d12159 2
a12160 2
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/usr.bin/wtf/Makefile	Tue Feb 11 20:16:18 2003
d12162 1
a12162 1
+# $MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
d12178 2
a12179 2
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/usr.bin/wtf/wtf	Tue Feb 11 20:16:18 2003
d12182 1
a12182 1
+#	$MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
d12220 2
a12221 2
--- /dev/null	Tue Feb 11 20:26:13 2003
+++ src/usr.bin/wtf/wtf.1	Tue Feb 11 20:16:18 2003
d12223 1
a12223 1
+.\"	$MirBSD: obsd.util,v 1.21 2003/02/11 20:02:19 tg Exp $
d12253 1
a12253 1
+.Dq wtf is WTF
d12255 1
a12255 1
+.Dq wtf ist Windows
@


1.21
log
@Uhm. Prepare for MirBSD -> ELF and obsd/ -> mbsd/
Did not mean to checkin diffs yet. They are incomplete.
@
text
@d35 1
a35 1
+++ src/gnu/usr.bin/Makefile	10 Feb 2003 19:42:21 -0000
d37 1
a37 1
+#	$MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d57 1
a57 1
+++ src/share/misc/Makefile	10 Feb 2003 19:42:21 -0000
d78 1
a78 1
+++ src/usr.bin/Makefile	10 Feb 2003 19:42:21 -0000
d90 2
a91 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/gnu/usr.bin/dict/Makefile	Mon Feb 10 19:42:21 2003
d93 1
a93 1
+# $MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d122 2
a123 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/gnu/usr.bin/dict/dict	Mon Feb 10 19:42:21 2003
d131 1
a131 1
+# Revised: $Date: 2003/02/10 19:41:27 $ by x86@@ePost.de
d904 2
a905 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Mon Feb 10 19:42:21 2003
d907 1
a907 1
+# $MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d919 2
a920 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Mon Feb 10 19:42:21 2003
d931 1
a931 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d1737 2
a1738 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/share/misc/acronyms	Mon Feb 10 19:42:21 2003
d1740 1
a1740 1
+$MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d2097 2
a2098 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/usr.bin/brainfuck/Makefile	Mon Feb 10 19:42:21 2003
d2100 1
a2100 1
+# $MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d2116 2
a2117 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/usr.bin/brainfuck/brainfuck	Mon Feb 10 19:42:21 2003
d2130 2
a2131 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Mon Feb 10 19:42:21 2003
d2133 1
a2133 1
+.\"	$MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d2214 2
a2215 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/usr.bin/host/Makefile	Mon Feb 10 19:42:21 2003
d2217 1
a2217 1
+# $MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d2233 2
a2234 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/usr.bin/host/host.1	Mon Feb 10 19:42:21 2003
d2236 1
a2236 1
+.\"	$MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d3119 2
a3120 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/usr.bin/host/host.c	Mon Feb 10 19:42:21 2003
d3122 1
a3122 1
+/*-	$MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d3218 1
a3218 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11579 2
a11580 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/usr.bin/host/nslookup	Mon Feb 10 19:42:21 2003
d11583 1
a11583 1
+#	$MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d11881 2
a11882 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/usr.bin/ndat/Makefile	Mon Feb 10 19:42:24 2003
d11884 1
a11884 1
+# $MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d11895 2
a11896 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/usr.bin/ndat/ndat.c	Mon Feb 10 19:42:24 2003
d11898 1
a11898 1
+/* $MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d11921 1
a11921 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $";
d12161 2
a12162 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/usr.bin/wtf/Makefile	Mon Feb 10 19:42:24 2003
d12164 1
a12164 1
+# $MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d12180 2
a12181 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/usr.bin/wtf/wtf	Mon Feb 10 19:42:24 2003
d12184 1
a12184 1
+#	$MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d12222 2
a12223 2
--- /dev/null	Tue Feb 11 19:42:55 2003
+++ src/usr.bin/wtf/wtf.1	Mon Feb 10 19:42:24 2003
d12225 1
a12225 1
+.\"	$MirBSD: obsd.util,v 1.20 2003/02/10 19:41:27 tg Exp $
d12292 1
a12292 1
src/share/misc/Makefile		wtf(acronyms)
@


1.20
log
@pre-build (development!)

+---------------.,
| ELF is there! ||
+===============''

- ports did not update INDEX
  there are conflicts in it
- diff set lists are not synched
- distrib sets are not touched at all
- still statically linked :)
- needs ELF system and EGCC to build
- no kernel yet, sorry

not to be used. backup only.
@
text
@d26 1
a26 1
against /cvs on Tue Jan 28 22:02:42 UTC 2003.
d35 1
a35 1
+++ src/gnu/usr.bin/Makefile	27 Jan 2003 21:18:59 -0000
d37 1
a37 1
+#	$MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
d57 1
a57 1
+++ src/share/misc/Makefile	27 Jan 2003 21:18:59 -0000
d78 1
a78 1
+++ src/usr.bin/Makefile	27 Jan 2003 21:18:59 -0000
d90 2
a91 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/gnu/usr.bin/dict/Makefile	Mon Jan 27 21:18:59 2003
d93 1
a93 1
+# $MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
d122 2
a123 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/gnu/usr.bin/dict/dict	Mon Jan 27 21:18:59 2003
d131 1
a131 1
+# Revised: $Date: 2003/01/27 21:17:22 $ by x86@@ePost.de
d904 2
a905 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Mon Jan 27 21:18:59 2003
d907 1
a907 1
+# $MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
d919 2
a920 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Mon Jan 27 21:18:59 2003
d931 1
a931 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
d1737 2
a1738 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/share/misc/acronyms	Tue Jan 28 20:25:00 2003
d1740 1
a1740 1
+$MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
d2097 2
a2098 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/usr.bin/brainfuck/Makefile	Mon Jan 27 21:19:02 2003
d2100 1
a2100 1
+# $MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
d2116 2
a2117 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/usr.bin/brainfuck/brainfuck	Mon Jan 27 21:19:02 2003
d2130 2
a2131 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Mon Jan 27 21:19:02 2003
d2133 1
a2133 1
+.\"	$MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
d2214 2
a2215 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/usr.bin/host/Makefile	Mon Jan 27 21:19:02 2003
d2217 1
a2217 1
+# $MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
d2233 2
a2234 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/usr.bin/host/host.1	Mon Jan 27 21:19:02 2003
d2236 1
a2236 1
+.\"	$MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
d3119 2
a3120 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/usr.bin/host/host.c	Mon Jan 27 21:19:02 2003
d3122 1
a3122 1
+/*-	$MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
d3218 1
a3218 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11579 2
a11580 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/usr.bin/host/nslookup	Mon Jan 27 21:19:02 2003
d11583 1
a11583 1
+#	$MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
d11881 2
a11882 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/usr.bin/ndat/Makefile	Mon Jan 27 21:19:02 2003
d11884 1
a11884 1
+# $MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
d11895 2
a11896 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/usr.bin/ndat/ndat.c	Mon Jan 27 21:19:02 2003
d11898 1
a11898 1
+/* $MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
d11921 1
a11921 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $";
d12161 2
a12162 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/usr.bin/wtf/Makefile	Mon Jan 27 21:19:02 2003
d12164 1
a12164 1
+# $MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
d12180 2
a12181 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/usr.bin/wtf/wtf	Mon Jan 27 21:19:02 2003
d12184 1
a12184 1
+#	$MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
d12222 2
a12223 2
--- /dev/null	Mon Feb 10 19:17:46 2003
+++ src/usr.bin/wtf/wtf.1	Mon Jan 27 21:19:02 2003
d12225 1
a12225 1
+.\"	$MirBSD: obsd.util,v 1.19 2003/01/27 21:17:22 tg Exp $
@


1.19
log
@another
MirBSD Snapshot #2 RC3
@
text
@d24 1
a24 1
This diff, ID $MirBSD: regen-obsdp.sh,v 1.6 2003/01/21 19:56:49 tg Exp $
d26 1
a26 1
against anoncvs@@anoncvs.ca.openbsd.org:/cvs on Mon Jan 27 17:30:00 UTC 2003.
d28 1
a28 1
### GENERATOR: @@(#)_MirBSD: regen-obsdp.sh,v 1.6 2003/01/21 19:56:49 tg Exp $
d34 2
a35 2
--- src/gnu/usr.bin/Makefile	2002/06/12 04:17:24	1.32
+++ src/gnu/usr.bin/Makefile	2003/01/27 21:13:15
d37 1
a37 1
+#	$MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
d56 2
a57 2
--- src/share/misc/Makefile	2001/10/05 17:30:51	1.8
+++ src/share/misc/Makefile	2003/01/27 21:13:15
d77 2
a78 2
--- src/usr.bin/Makefile	2002/07/24 01:08:56	1.79
+++ src/usr.bin/Makefile	2003/01/27 21:13:15
d90 2
a91 2
--- /dev/null	Mon Jan 27 21:13:16 2003
+++ src/gnu/usr.bin/dict/Makefile	Mon Jan 27 17:48:06 2003
d93 1
a93 1
+# $MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
d122 2
a123 2
--- /dev/null	Mon Jan 27 21:13:16 2003
+++ src/gnu/usr.bin/dict/dict	Mon Jan 27 17:48:06 2003
d131 1
a131 1
+# Revised: $Date: 2003/01/27 17:47:10 $ by x86@@ePost.de
d904 2
a905 2
--- /dev/null	Mon Jan 27 21:13:16 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Mon Jan 27 17:48:06 2003
d907 1
a907 1
+# $MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
d919 2
a920 2
--- /dev/null	Mon Jan 27 21:13:16 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Mon Jan 27 17:48:06 2003
d931 1
a931 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
d1737 4
a1740 4
--- /dev/null	Mon Jan 27 21:13:16 2003
+++ src/share/misc/acronyms	Mon Jan 27 18:51:35 2003
@@@@ -0,0 +1,352 @@@@
+$MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
d1767 1
d2097 2
a2098 2
--- /dev/null	Mon Jan 27 21:13:16 2003
+++ src/usr.bin/brainfuck/Makefile	Mon Jan 27 17:48:06 2003
d2100 1
a2100 1
+# $MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
d2116 2
a2117 2
--- /dev/null	Mon Jan 27 21:13:16 2003
+++ src/usr.bin/brainfuck/brainfuck	Mon Jan 27 17:48:06 2003
d2130 2
a2131 2
--- /dev/null	Mon Jan 27 21:13:16 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Mon Jan 27 17:48:06 2003
d2133 1
a2133 1
+.\"	$MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
d2214 2
a2215 2
--- /dev/null	Mon Jan 27 21:13:16 2003
+++ src/usr.bin/host/Makefile	Mon Jan 27 17:48:06 2003
d2217 1
a2217 1
+# $MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
d2233 2
a2234 2
--- /dev/null	Mon Jan 27 21:13:16 2003
+++ src/usr.bin/host/host.1	Mon Jan 27 17:48:06 2003
d2236 1
a2236 1
+.\"	$MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
d3119 2
a3120 2
--- /dev/null	Mon Jan 27 21:13:16 2003
+++ src/usr.bin/host/host.c	Mon Jan 27 17:48:06 2003
d3122 1
a3122 1
+/*-	$MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
d3218 1
a3218 1
+static const char * const RCSId = "$MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11579 2
a11580 2
--- /dev/null	Mon Jan 27 21:13:16 2003
+++ src/usr.bin/host/nslookup	Mon Jan 27 17:48:06 2003
d11583 1
a11583 1
+#	$MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
d11881 2
a11882 2
--- /dev/null	Mon Jan 27 21:13:16 2003
+++ src/usr.bin/ndat/Makefile	Mon Jan 27 17:48:06 2003
d11884 1
a11884 1
+# $MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
d11895 2
a11896 2
--- /dev/null	Mon Jan 27 21:13:16 2003
+++ src/usr.bin/ndat/ndat.c	Mon Jan 27 17:48:06 2003
d11898 1
a11898 1
+/* $MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
d11921 1
a11921 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $";
d12161 2
a12162 2
--- /dev/null	Mon Jan 27 21:13:17 2003
+++ src/usr.bin/wtf/Makefile	Mon Jan 27 17:48:06 2003
d12164 1
a12164 1
+# $MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
d12180 2
a12181 2
--- /dev/null	Mon Jan 27 21:13:17 2003
+++ src/usr.bin/wtf/wtf	Mon Jan 27 17:48:06 2003
d12184 1
a12184 1
+#	$MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
d12222 2
a12223 2
--- /dev/null	Mon Jan 27 21:13:17 2003
+++ src/usr.bin/wtf/wtf.1	Mon Jan 27 17:48:06 2003
d12225 1
a12225 1
+.\"	$MirBSD: obsd.util,v 1.18 2003/01/27 17:47:10 tg Exp $
@


1.18
log
@Release Candidate #2
@
text
@d26 1
a26 1
against anoncvs@@anoncvs.ca.openbsd.org:/cvs on Mon Jan 27 12:20:00 UTC 2003.
d35 1
a35 1
+++ src/gnu/usr.bin/Makefile	2003/01/27 17:43:58
d37 1
a37 1
+#	$MirBSD: obsd.util,v 1.17 2003/01/27 15:38:19 tg Exp $
d57 1
a57 1
+++ src/share/misc/Makefile	2003/01/27 17:43:58
d78 1
a78 1
+++ src/usr.bin/Makefile	2003/01/27 17:43:58
d90 2
a91 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/gnu/usr.bin/dict/Makefile	Mon Jan 27 17:32:05 2003
d93 1
a93 1
+# $MirBSD: obsd.util,v 1.17 2003/01/27 15:38:19 tg Exp $
d122 2
a123 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/gnu/usr.bin/dict/dict	Mon Jan 27 17:32:05 2003
d131 1
a131 1
+# Revised: $Date: 2003/01/27 15:38:19 $ by x86@@ePost.de
d904 2
a905 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Mon Jan 27 17:32:05 2003
d907 1
a907 1
+# $MirBSD: obsd.util,v 1.17 2003/01/27 15:38:19 tg Exp $
d919 2
a920 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Mon Jan 27 17:32:05 2003
d931 1
a931 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.17 2003/01/27 15:38:19 tg Exp $
d1737 2
a1738 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/share/misc/acronyms	Mon Jan 27 17:32:05 2003
d2096 2
a2097 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/usr.bin/brainfuck/Makefile	Mon Jan 27 17:32:05 2003
d2099 1
a2099 1
+# $MirBSD: obsd.util,v 1.17 2003/01/27 15:38:19 tg Exp $
d2115 2
a2116 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/usr.bin/brainfuck/brainfuck	Mon Jan 27 17:32:05 2003
d2129 2
a2130 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Mon Jan 27 17:32:05 2003
d2132 1
a2132 1
+.\"	$MirBSD: obsd.util,v 1.17 2003/01/27 15:38:19 tg Exp $
d2213 2
a2214 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/usr.bin/host/Makefile	Mon Jan 27 17:36:01 2003
d2216 1
a2216 1
+# $MirBSD: obsd.tygs,v 1.19 2003/01/27 15:38:18 tg Exp $
d2232 2
a2233 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/usr.bin/host/host.1	Mon Jan 27 17:30:45 2003
d2235 1
a2235 1
+.\"	$MirBSD: obsd.tygs,v 1.19 2003/01/27 15:38:18 tg Exp $
d3118 2
a3119 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/usr.bin/host/host.c	Mon Jan 27 17:30:45 2003
d3121 1
a3121 1
+/*-	$MirBSD: obsd.tygs,v 1.19 2003/01/27 15:38:18 tg Exp $
d3217 1
a3217 1
+static const char * const RCSId = "$MirBSD: obsd.tygs,v 1.19 2003/01/27 15:38:18 tg Exp $ from @@(#)host.c	e07@@nikhef.nl (Eric Wassenaar) 961013";
d11578 2
a11579 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/usr.bin/host/nslookup	Mon Jan 27 17:30:45 2003
d11582 1
a11582 1
+#	$MirBSD: obsd.tygs,v 1.19 2003/01/27 15:38:18 tg Exp $
d11880 2
a11881 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/usr.bin/ndat/Makefile	Mon Jan 27 17:32:05 2003
d11883 1
a11883 1
+# $MirBSD: obsd.util,v 1.17 2003/01/27 15:38:19 tg Exp $
d11894 2
a11895 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/usr.bin/ndat/ndat.c	Mon Jan 27 17:32:05 2003
d11897 1
a11897 1
+/* $MirBSD: obsd.util,v 1.17 2003/01/27 15:38:19 tg Exp $
d11920 1
a11920 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.17 2003/01/27 15:38:19 tg Exp $";
d12160 2
a12161 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/usr.bin/wtf/Makefile	Mon Jan 27 17:32:05 2003
d12163 1
a12163 1
+# $MirBSD: obsd.util,v 1.17 2003/01/27 15:38:19 tg Exp $
d12179 2
a12180 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/usr.bin/wtf/wtf	Mon Jan 27 17:32:05 2003
d12183 1
a12183 1
+#	$MirBSD: obsd.util,v 1.17 2003/01/27 15:38:19 tg Exp $
d12221 2
a12222 2
--- /dev/null	Mon Jan 27 15:57:44 2003
+++ src/usr.bin/wtf/wtf.1	Mon Jan 27 17:32:05 2003
d12224 1
a12224 1
+.\"	$MirBSD: obsd.util,v 1.17 2003/01/27 15:38:19 tg Exp $
@


1.17
log
@snapshot release candidate
todo:
 + cvs repo (ports, src) check for diff
 + make build
 + make release
 + checkflist
 + if !correct: regen diffs, do again
 + upload
@
text
@d35 1
a35 1
+++ src/gnu/usr.bin/Makefile	2003/01/27 15:37:16
d37 1
a37 1
+#	$MirBSD: obsd.util,v 1.16 2003/01/26 13:10:27 tg Exp $
d57 1
a57 1
+++ src/share/misc/Makefile	2003/01/27 15:37:16
d78 1
a78 1
+++ src/usr.bin/Makefile	2003/01/27 15:37:16
d83 1
a83 1
+SUBDIR+= brainfuck ndat wtf
d90 2
a91 2
--- /dev/null	Mon Jan 27 14:30:41 2003
+++ src/gnu/usr.bin/dict/Makefile	Sun Jan 26 13:11:26 2003
d93 1
a93 1
+# $MirBSD: obsd.util,v 1.16 2003/01/26 13:10:27 tg Exp $
d122 2
a123 2
--- /dev/null	Mon Jan 27 14:30:41 2003
+++ src/gnu/usr.bin/dict/dict	Sun Jan 26 13:11:26 2003
d131 1
a131 1
+# Revised: $Date: 2003/01/26 13:10:27 $ by x86@@ePost.de
d904 2
a905 2
--- /dev/null	Mon Jan 27 14:30:41 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Sun Jan 26 13:11:26 2003
d907 1
a907 1
+# $MirBSD: obsd.util,v 1.16 2003/01/26 13:10:27 tg Exp $
d919 2
a920 2
--- /dev/null	Mon Jan 27 14:30:41 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Sun Jan 26 13:11:26 2003
d931 1
a931 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.16 2003/01/26 13:10:27 tg Exp $
d1737 2
a1738 2
--- /dev/null	Mon Jan 27 14:30:41 2003
+++ src/share/misc/acronyms	Sun Jan 26 13:11:26 2003
d1740 1
a1740 1
+$MirBSD: obsd.util,v 1.16 2003/01/26 13:10:27 tg Exp $
d2095 2
a2096 2
--- /dev/null	Mon Jan 27 14:30:41 2003
+++ src/usr.bin/brainfuck/Makefile	Mon Jan 27 14:16:17 2003
d2098 1
a2098 1
+# $MirBSD: obsd.util,v 1.16 2003/01/26 13:10:27 tg Exp $
d2114 2
a2115 2
--- /dev/null	Mon Jan 27 14:30:41 2003
+++ src/usr.bin/brainfuck/brainfuck	Sun Jan 26 13:11:26 2003
d2128 2
a2129 2
--- /dev/null	Mon Jan 27 14:30:41 2003
+++ src/usr.bin/brainfuck/brainfuck.1	Mon Jan 27 14:16:54 2003
d2131 1
a2131 1
+.\"	$MirBSD: obsd.util,v 1.16 2003/01/26 13:10:27 tg Exp $
d2208 9667
d11879 2
a11880 2
--- /dev/null	Mon Jan 27 14:30:41 2003
+++ src/usr.bin/ndat/Makefile	Sun Jan 26 13:11:26 2003
d11882 1
a11882 1
+# $MirBSD: obsd.util,v 1.16 2003/01/26 13:10:27 tg Exp $
d11893 2
a11894 2
--- /dev/null	Mon Jan 27 14:30:41 2003
+++ src/usr.bin/ndat/ndat.c	Sun Jan 26 13:11:26 2003
d11896 1
a11896 1
+/* $MirBSD: obsd.util,v 1.16 2003/01/26 13:10:27 tg Exp $
d11919 1
a11919 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.16 2003/01/26 13:10:27 tg Exp $";
d12159 2
a12160 2
--- /dev/null	Mon Jan 27 14:30:41 2003
+++ src/usr.bin/wtf/Makefile	Mon Jan 27 14:15:54 2003
d12162 1
a12162 1
+# $MirBSD: obsd.util,v 1.16 2003/01/26 13:10:27 tg Exp $
d12178 2
a12179 2
--- /dev/null	Mon Jan 27 14:30:41 2003
+++ src/usr.bin/wtf/wtf	Sun Jan 26 13:11:26 2003
d12182 1
a12182 1
+#	$MirBSD: obsd.util,v 1.16 2003/01/26 13:10:27 tg Exp $
d12220 2
a12221 2
--- /dev/null	Mon Jan 27 14:30:41 2003
+++ src/usr.bin/wtf/wtf.1	Mon Jan 27 14:17:16 2003
d12223 1
a12223 1
+.\"	$MirBSD: obsd.util,v 1.16 2003/01/26 13:10:27 tg Exp $
d12291 1
a12291 1
src/usr.bin/Makefile		+wtf +ndat +brainfuck
d12302 4
@


1.16
log
@sync
fix gcc-3.2 port (uses humantime-ulimit!)
switch system CXX to g++-3.2
bump mc
make build, fix
plug some compiler warnings (uninitialized, trigraph, ...)
make release, sync plists

merge obsd.gcc and obsd.mini to obsd.misc
@
text
@d26 1
a26 1
against CTM on Sun Jan 26 13:00:17 UTC 2003.
a28 21
### CTM OpenBSD-cvs 2976
Index: src/games/Makefile
===================================================================
RCS file: /cvs/src/games/Makefile,v
retrieving revision 1.9
diff -u -r1.9 Makefile
--- src/games/Makefile	23 May 2002 18:42:37 -0000	1.9
+++ src/games/Makefile	24 Jan 2003 16:25:56 -0000
@@@@ -1,3 +1,4 @@@@
+#	$MirBSD: obsd.util,v 1.15 2003/01/24 16:25:01 tg Exp $
 #	$OpenBSD: Makefile,v 1.9 2002/05/23 18:42:59 deraadt Exp $
 
 # Missing: ching dungeon warp
@@@@ -8,6 +9,6 @@@@
 	bs caesar canfield cribbage factor fish fortune gomoku grdc hack \
 	hangman hunt larn mille monop morse number phantasia pig pom ppt \
 	primes quiz rain random robots rogue sail snake tetris trek wargames \
-	worm worms wump
+	worm worms wump wtf ndat brainfuck
 
 .include <bsd.subdir.mk>
d34 2
a35 2
--- src/gnu/usr.bin/Makefile	12 Jun 2002 04:17:02 -0000	1.32
+++ src/gnu/usr.bin/Makefile	24 Jan 2003 16:25:56 -0000
d37 1
a37 1
+#	$MirBSD: obsd.util,v 1.15 2003/01/24 16:25:01 tg Exp $
d56 2
a57 2
--- src/share/misc/Makefile	5 Oct 2001 17:30:29 -0000	1.8
+++ src/share/misc/Makefile	24 Jan 2003 16:25:56 -0000
d72 15
a86 1
Index: src/games/brainfuck/Makefile
d88 1
a88 1
RCS file: /cvs/src/games/brainfuck/Makefile,v
d90 4
a93 4
--- /dev/null	Sun Jan 26 12:57:40 2003
+++ src/games/brainfuck/Makefile	Fri Jan 24 16:25:56 2003
@@@@ -0,0 +1,12 @@@@
+# $MirBSD: obsd.util,v 1.15 2003/01/24 16:25:01 tg Exp $
d96 1
a96 1
+SCRIPTS=brainfuck
d98 11
a108 1
+MAN=	brainfuck.6
d112 4
a115 1
+	    ${SCRIPTS} ${DESTDIR}${BINDIR}
d118 1
a118 1
Index: src/games/brainfuck/brainfuck
d120 1
a120 1
RCS file: /cvs/src/games/brainfuck/brainfuck,v
d122 3
a124 3
--- /dev/null	Sun Jan 26 12:57:40 2003
+++ src/games/brainfuck/brainfuck	Fri Jan 24 16:25:56 2003
@@@@ -0,0 +1,7 @@@@
d127 18
a144 1
+# Public domain by Marko Nippula
d146 4
a149 64
+$/=$a;while(<>){s/./$&;/g;s/\+|-/P$&$&/g;s/</\$p--/g;s/>/\$p++/g;s/\./
+print chr P/g;s/,/P=ord getc/g;y/[]/{}/;s/{/while(P){/g;s/P/\$m[\$p]/g
+;eval$_;print$@@if$@@}
Index: src/games/brainfuck/brainfuck.6
===================================================================
RCS file: /cvs/src/games/brainfuck/brainfuck.6,v
retrieving revision DEAD
--- /dev/null	Sun Jan 26 12:57:40 2003
+++ src/games/brainfuck/brainfuck.6	Fri Jan 24 16:25:56 2003
@@@@ -0,0 +1,77 @@@@
+.\"	$MirBSD: obsd.util,v 1.15 2003/01/24 16:25:01 tg Exp $
+.\"
+.\" Copyright (c) 2000-2002 by Thorsten "mirabile" Glaser <x86@@ePost.de>
+.\"
+.\" I hereby permit everyone who obtained a copy of this work to distri-
+.\" bute, sell, give away, modify, sublicense, merge and use it, freely.
+.\" I retain the right to be known as the author of the work. For no fee
+.\" and further restrainments, all patents hold by the author or contri-
+.\" butors, applying to this work, shall be licensed to any copy of this
+.\" work, whether modified, merged or not.
+.\"
+.\" The work is provided "as is", with no explicit or implicit warranty.
+.\" Use it at your own risk. Neither the author, nor contributors may be
+.\" held liable for any damage, directly or indirectly, which originated
+.\" by the creation or modification of this work. Since modern computing
+.\" devices are error-prone, flawless behaviour cannot be expected.
+.\"
+.Dd November 3, 2002
+.Dt BRAINFUCK 6
+.Os BSD-mirabile 20021103
+.Sh NAME
+.Nm brainfuck
+.Nd perl brainfuck interpreter
+.Sh SYNOPSIS
+.Nm
+.Sh DESCRIPTION
+The
+.Nm
+utility interprets its standard input as a brainfuck script.
+Processing will start after EOF.
+If you started
+.Nm
+interactively, hit Ctrl-D on a new line to start.
+.Pp
+.Sh THE LANGUAGE
+brainfuck is a simple enough language to include the entire official language
+describtion in this man page.
+The following is from the original brainfuck distribution by Urban Mueller
+\f(CW<umueller@@amiga.physik.unizh.ch\fR>, who also invented the language:
+.Pp
+The language \fIbrainfuck\fR knows the following commands:
+.Pp
+.Bd -literal -offset indent
+\& Cmd  Effect                                    Equivalent in C
+\& ---  ------                                    ---------------
+\& +    Increases element under pointer           array[p]++;
+\& -    Decrases element under pointer            array[p]--;
+\& >    Increases pointer                         p++;
+\& <    Decreases pointer                         p--;
+\& [    Starts loop, counter under pointer        while(array[p]) {
+\& ]    Indicates end of loop                     }
+\& .    Outputs ASCII code under pointer          putchar(array[p]);
+\& ,    Reads char and stores ASCII under ptr     array[p]=getchar();
+.Ed
d151 2
a152 1
+All other characters are ignored.
d154 5
a158 29
+The array elements and p are being initialized to zero at the beginning.
+Now while this seems to be a pretty useless language, it can be proven
+that it can compute every solvable mathematical problem (if we ignore
+the array size limit and the executable size limit).
+.Sh HISTORY
+.Nm
+first appeared in
+.Ox
+3.2-mirabile.
+.Sh AUTHORS
+.Bl -inset
+.It Em Urban Mueller
+designed the language.
+.It Em Marko Nippula
+wrote this interpreter.
+.It Em Chaos Computer Club Cologne
+gave some hints for the man page.
+.It Em Thorsten Glaser
+wrote this man page and put the things together.
+.El
Index: src/games/ndat/Makefile
===================================================================
RCS file: /cvs/src/games/ndat/Makefile,v
retrieving revision DEAD
--- /dev/null	Sun Jan 26 12:57:40 2003
+++ src/games/ndat/Makefile	Fri Jan 24 16:25:56 2003
@@@@ -0,0 +1,7 @@@@
+# $MirBSD: obsd.util,v 1.15 2003/01/24 16:25:01 tg Exp $
+# Public domain.
d160 16
a175 2
+PROG=	ndat
+NOMAN=
d177 1
a177 30
+.include <bsd.prog.mk>
Index: src/games/ndat/ndat.c
===================================================================
RCS file: /cvs/src/games/ndat/ndat.c,v
retrieving revision DEAD
--- /dev/null	Sun Jan 26 12:57:40 2003
+++ src/games/ndat/ndat.c	Fri Jan 24 16:25:56 2003
@@@@ -0,0 +1,259 @@@@
+/* $MirBSD: obsd.util,v 1.15 2003/01/24 16:25:01 tg Exp $
+ * Copyright (c) 2000-2002 by Thorsten "mirabile" Glaser <x86@@ePost.de>
+ *
+ * I hereby permit everyone who obtained a copy of this work to distri-
+ * bute, sell, give away, modify, sublicense, merge and use it, freely.
+ * I retain the right to be known as the author of the work. The author
+ * and every single contributor, unless marked with "NOP" above, hereby
+ * waive their right to require additional patent licences for usage of
+ * this work, even if the work could infringe patents hold by them.
+ *
+ * The work is provided "as is", with no explicit or implicit warranty.
+ * Use it at your own risk. Neither the author, nor contributors may be
+ * held liable for any damage, directly or indirectly, which originated
+ * by the creation or modification of this work. Since modern computing
+ * devices are error-prone, flawless behaviour cannot be expected.
+ *
+ *
+ * Offizielles Programm der Republica Occultae Germanorum zur Umrechnung
+ * zwischen naturamistischen und neu-christlichen (VAW) Zeitangaben.
+ * Finale Version, funktional identisch und getestet. Bugs gefixt.
+ * manual page still missing... hexadecimal time-of-day too.
+ */
d179 1
a179 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.15 2003/01/24 16:25:01 tg Exp $";
d181 27
d209 4
a212 1
+#include <sys/types.h>
d214 1
a214 2
+#include <time.h>
+#include <stdio.h>
d216 8
a223 4
+int main(int argc, char *argv[]);
+int DatCN(char s, char *otm);
+int DatNC(char s, char *otm);
+int dpm(int m, int y);
d225 1
a225 1
+char buf[16];
d227 2
a228 2
+char *tag[]=	{ "Pd", "Sc", "Td", "Qa", "Qi", "Vd" };
+char *chrtag[]=	{ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" };
d230 1
a230 7
+#ifdef NO_LATIN1
+char *langtag[]={ "Primdies", "Secundies", "Tertdies",
+		  "Quartdies", "Quintdies", "Veyrdag" };
+#else
+char *langtag[]={ "Prmdies", "Secndies", "Trtdies",
+		  "Qurtdies", "Quntdies", "Vyrdag" };
+#endif
d232 15
a246 2
+#define	bounds(v, min, max)	(((v<min) || (v>max)) ? -1 : 0)
+#define	februar(y)	((y&3) ? 28 : ((y%100) ? 29 : ((y%400) ? 28 : 29)))
d248 10
d259 8
a266 4
+int main(int argc, char *argv[])
+{
+	time_t v;
+	struct tm *tts;
d268 2
a269 7
+	if (argc == 3) {
+		/*
+		 * +!	nat -> chr		inp: d.m.y
+		 * +	nat(short) -> chr	inp: day-of-year.y
+		 */
+		if (argv[1][0] == '+')
+			return DatNC(argv[1][1], argv[2]);
d271 6
a276 8
+		/*
+		 * -	chr -> nat			 xx ddd.yy
+		 * -!	chr -> nat(short)		 xx yyddd
+		 * -+	chr -> nat(absurdly verbose)	xxx dd.mm.yy
+		 */
+		if (argv[1][0] == '-')
+			return DatCN(argv[1][1], argv[2]);
+	}
d278 8
a285 9
+	if ((argc == 2) && (argv[1][0] == '-')) {
+		/*
+		 * -	convert today's date
+		 */
+		v = time(NULL);
+		tts = gmtime(&v);
+		strftime(buf, 16, "%d.%m.%Y", tts);
+		return DatCN(argv[1][1], buf);
+	}
d287 2
a288 4
+	fprintf(stderr, "Syntax:\n\n ndat +[!] naturamistic.date\n ndat"
+	    " -[!+] [christian.date]\n\n%s\n", RCSId);
+	return -1;
+}
d290 4
a293 11
+/* Days per month depending on year */
+int dpm(int m, int y)
+{
+	switch(m) {
+		case 1:
+		case 3:
+		case 5:
+		case 7:
+		case 8:
+		case 10:
+		case 12: return 31;
d295 4
a298 7
+		case 4:
+		case 6:
+		case 9:
+		case 11: return 30;
+	}
+	return februar(y);
+}
d300 4
a303 5
+/* convert Christian to Naturamistic date */
+int DatCN(char s, char *otm)
+{
+	int d, m, y, dp, a, b, c, t;
+	int64_t ofs;
d305 8
a312 4
+	if (sscanf(otm, "%d.%d.%d", &d, &m, &y) != 3)
+		return -1;
+	if (bounds(y, 1600, 9999))
+		return -1;
d314 4
a317 2
+	/* Trick bei Jahr < 1982 */
+	y += 400;
d319 6
a324 3
+	if (bounds(m, 1, 12)) return -1;
+	dp = dpm(m, y);
+	if (bounds(d, 1, dp)) return -1;
d326 6
a331 7
+	ofs = 10 + d;
+	for (a = 1; a < m; a++)
+		ofs += dpm(a, y);
+	for (a = 1982; a < y; a++)
+		if (februar(a) == 29)
+			ofs += 366;
+		else	ofs += 365;
d333 7
a339 1
+	t = (ofs - 4) % 6;
d341 3
a343 9
+	y = 0;
+	b = 1982;
+getny:	c = (februar(b) == 29) ? 366 : 365;
+	if (ofs > c) {
+		++y;
+		++b;
+		ofs -= c;
+		goto getny;
+	}
d345 3
a347 4
+	/*
+	 * y ist jetzt das naturamistische Jahr
+	 * ofs der Tag des Jahres
+	 */
d349 7
a355 2
+	/* Trick bei Jahr < 0 */
+	y -= 400;
d357 3
a359 5
+	m = ofs / 30 + 1;
+	d = ofs % 30;
+	if (!d) {
+		d = 30;
+		--m;
d362 13
a374 6
+	if (s == '!') {
+		printf("%s %01i%03d\n", tag[t], y, (int) ofs);
+	} else if ((m < 12) && (s == '+')) {
+		printf("%s %02d.%02d.%01i\n", langtag[t], d, m, y);
+	} else	printf("%s %03d.%01i\n", tag[t], (int) ofs, y);
+	return 0;
d377 2
a378 5
+/* convert Naturamistic to Christian date */
+int DatNC(char s, char *otm)
+{
+	int d, m, y, ny, nd, w;
+	struct tm *tts;
a379 27
+	if (s == '!') {
+		if (sscanf(otm, "%d.%d.%d", &d, &m, &ny) != 3)
+			return -1;
+		nd = (m-1)*30 + d;
+	} else	{
+		d = sscanf(otm, "%d.%d", &nd, &ny);
+		if (d == 1) {
+			if (nd < 0) {
+				ny = -1;
+				nd *= -1;
+			} else	ny = 1;
+			ny *= nd / 1000;
+			nd %= 1000;
+		} else if (d != 2)
+			return -1;
+	}
+	if (bounds(ny, -382, 8018))
+		return -1;
+	if (bounds(nd, 1, 366))
+		return -1;
+	if ((ny == -382) && (nd < 11))
+		return -1;
+	if ((ny == 8018) && (nd > 10))
+		return -1;
+	y = ny + 1982;
+	if ((februar(y)==28) && (nd==366))
+		return -1;
d381 4
a384 30
+	if (nd < 11) {
+		d = 21 + nd;
+		m = 12;
+		y--;
+		goto dny;
+	}
+	d = nd - 10;
+	m = 1;
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d <= februar(y)) goto dny;
+	++m; d -= februar(y);
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d < 31) goto dny;
+	++m; d -= 30;
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d < 31) goto dny;
+	++m; d -= 30;
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d < 31) goto dny;
+	++m; d -= 30;
+	if (d < 32) goto dny;
+	++m; d -= 31;
+	if (d < 31) goto dny;
+	++m; d -= 30;
d386 4
a389 1
+	if (d > 31) return -1;
d391 4
a394 1
+dny:	w = 7;
d396 4
a399 3
+	/* Unix time "struct tm" year starts at 1900 and ends at 32 bit */
+	if ((y < 1900) || (y > 2037))
+		goto dnyw;
a400 8
+	/* Now calculate the day of week, using heavy kludges */
+	if ((tts = gmtime(&w)) == NULL)
+		goto dnyw;
+	snprintf(buf, 16, "%d %d %d", d, m, y);
+	if (strptime(buf, "%d %m %Y", tts) == NULL)
+		goto dnyw;
+	mktime(tts);
+	w = tts->tm_wday;
d402 1
a402 15
+dnyw:	if (bounds(w, 0, 7))
+		w = 7;
+	printf("%s%s%i.%02i.%04i\n", ((w==7) ? "" : chrtag[w]),
+	    ((w==7) ? "" : " "), d, m, y);
+	return 0;
+}
Index: src/games/wtf/Makefile
===================================================================
RCS file: /cvs/src/games/wtf/Makefile,v
retrieving revision DEAD
--- /dev/null	Sun Jan 26 12:57:40 2003
+++ src/games/wtf/Makefile	Fri Jan 24 16:25:56 2003
@@@@ -0,0 +1,12 @@@@
+# $MirBSD: obsd.util,v 1.15 2003/01/24 16:25:01 tg Exp $
+# Public domain.
d404 1
a404 3
+SCRIPTS=wtf
+NOOBS=	noobj
+MAN=	wtf.6
d406 1
a406 3
+realinstall:
+	cd ${.CURDIR}; install -c -o ${BINOWN} -g ${BINGRP} -m 555 \
+	    ${SCRIPTS} ${DESTDIR}${BINDIR}
d408 1
a408 13
+.include <bsd.prog.mk>
Index: src/games/wtf/wtf
===================================================================
RCS file: /cvs/src/games/wtf/wtf,v
retrieving revision DEAD
--- /dev/null	Sun Jan 26 12:57:40 2003
+++ src/games/wtf/wtf	Fri Jan 24 16:25:56 2003
@@@@ -0,0 +1,35 @@@@
+#!/bin/sh -
+#	$MirBSD: obsd.util,v 1.15 2003/01/24 16:25:01 tg Exp $
+#	$NetBSD: wtf,v 1.7 2000/11/21 00:18:52 soren Exp $
+#
+# Public domain
d410 2
a411 1
+acronyms=${ACRONYMDB:-/usr/share/misc/acronyms}
d413 1
a413 1
+[ "$1" = "is" -o "$1" = "ist" ] && shift
d415 4
a418 1
+[ $# -lt 1 ] && echo "Usage: $(basename $0) [is] <acronym>"
d420 3
a422 49
+rv=0
+while [ $# -gt 0 ] ; do
+	target=$(echo $1 | tr '[:lower:]' '[:upper:]')
+	ans=$(fgrep $target <${acronyms} 2>/dev/null \
+	    | sed -ne "/^$target[[:space:]]/s/^$target[[:space:]]*//p")
+	if [ -n "$ans" ] ; then
+		echo "   $target:\n$ans"
+	else
+		ans=$(whatis $1 2>/dev/null | egrep "^$1[, ]" 2>/dev/null)
+		if [ $? -eq 0 ] ; then
+			echo "   $1:\n$ans"
+		else
+			echo "Gee...  I don't know what $1 means..." 1>&2
+			if [ -x /usr/bin/dict ]; then
+				echo "Let's try The Dictionary..." 1>&2
+				dict $1
+			fi
+			rv=1
+		fi
+	fi
+	shift
+done
+exit $rv
Index: src/games/wtf/wtf.6
===================================================================
RCS file: /cvs/src/games/wtf/wtf.6,v
retrieving revision DEAD
--- /dev/null	Sun Jan 26 12:57:40 2003
+++ src/games/wtf/wtf.6	Fri Jan 24 16:25:56 2003
@@@@ -0,0 +1,57 @@@@
+.\"	$OpenBSD$ $MirBSD: obsd.util,v 1.15 2003/01/24 16:25:01 tg Exp $
+.\"	$NetBSD: wtf.6,v 1.4 2001/04/02 22:42:40 wiz Exp $
+.\"
+.\" Public Domain
+.\"
+.Dd July 21, 1999
+.Dt WTF 6
+.Os
+.Sh NAME
+.Nm wtf
+.Nd translates acronyms for you
+.Sh SYNOPSIS
+.Nm
+.Op Ar is
+.Ar acronym Ar ...
+.Sh DESCRIPTION
+The
+.Nm
+utility displays the expansion of the acronyms
a423 46
+If the acronym is unknown,
+.Nm
+will check to see if the acronym is known by the
+.Xr whatis 1
+command.
+.Pp
+If
+.Dq is
+is specified on the command line, it will be ignored,
+allowing the fairly natural
+.Dq wtf is WTF
+and, for German users,
+.Dq wtf ist Windows
+usage.
+.Pp
+If the acronym is not found,
+the "dict" (online dictionary client) is tried
+if it exists.
+.Sh ENVIRONMENT
+.Bl -tag -width ACRONYMDB
+.It Ev ACRONYMDB
+The default acronym database may be overridden by setting the
+environment variable
+.Ev ACRONYMDB
+to the name of a file in the proper format (acronym[tab]meaning).
+.El
+.Sh FILES
+.Bl -tag -width /usr/share/misc/acronyms -compact
+.It Pa /usr/share/misc/acronyms
+default acronym database.
+.El
+.Sh SEE ALSO
+.Xr whatis 1
+.Sh HISTORY
+.Nm
+first appeared in
+.Nx 1.5 .
Index: src/gnu/usr.bin/dict/Makefile
===================================================================
RCS file: /cvs/src/gnu/usr.bin/dict/Makefile,v
retrieving revision DEAD
--- /dev/null	Sun Jan 26 12:57:40 2003
+++ src/gnu/usr.bin/dict/Makefile	Fri Jan 24 16:25:56 2003
@@@@ -0,0 +1,25 @@@@
+# $MirBSD: obsd.util,v 1.15 2003/01/24 16:25:01 tg Exp $
+# Public domain.
d425 13
a437 2
+SRCS=	dict
+NOOBS=	noobj
d439 1
a439 4
+MANALL=	\
+	dict.cat1
+CLEANFILES+= \
+	dict.pm
d441 1
a441 5
+dict.cat1: ${SRCS}
+	cp ${.ALLSRC} dict.pm && \
+	    pod2man --section=1 --official --center='miranda.org' \
+		--release="OpenBSD `uname -r`" dict.pm | \
+	    nroff -Tascii -man >${.TARGET}
d443 1
a443 3
+realinstall:
+	cd ${.CURDIR}; install -c -o ${BINOWN} -g ${BINGRP} -m 555 \
+	    ${SRCS} ${DESTDIR}${BINDIR}
d445 1
a445 2
+clean:
+	rm -f ${CLEANFILES}
d447 1
a447 28
+.include <bsd.prog.mk>
Index: src/gnu/usr.bin/dict/dict
===================================================================
RCS file: /cvs/src/gnu/usr.bin/dict/dict,v
retrieving revision DEAD
--- /dev/null	Sun Jan 26 12:57:40 2003
+++ src/gnu/usr.bin/dict/dict	Fri Jan 24 16:25:56 2003
@@@@ -0,0 +1,775 @@@@
+#!/usr/bin/perl
+#
+# dict -- Perl DICT system client
+#
+# Created: Thu Apr 17 19:49:15 1997 by bamartin@@miranda.org
+# Revised: Thu Mar 12 02:00:44 1998 by bamartin@@miranda.org
+# Revised: $Date: 2003/01/24 16:25:01 $ by x86@@ePost.de
+# Copyright 1997-1998 Bret A. Martin (bamartin@@miranda.org)
+# This program comes with ABSOLUTELY NO WARRANTY.
+#
+#   The contents of this file are subject to the Netscape Public License
+#   Version 1.0 (the "NPL"); you may not use this file except in compliance
+#   with the NPL. You may obtain a copy of the NPL at the end of this file.
+#
+#   Software distributed under the NPL is distributed on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, either express or implied. See the NPL.
+#
+#   The Initial Developer of this code under the NPL is Bret Martin.
+#
+# _Id: dict,v 1.5 1998/03/08 23:41:42 bamartin Exp $
d449 1
a449 4
+require 5.002;
+use File::Basename;
+use FileHandle;
+use Socket;
d451 1
a451 2
+$me = basename $0;
+chop($hostname = `hostname`);
d453 1
a453 5
+# Did not work for some time. Search for NOCLUE
+# $server = "dict.org";
+# This is miranda.org:
+$server = "209.58.150.153";
+$port   = 2628;
d455 4
a458 16
+sub usage {
+    print STDERR <<EOM;
+usage: $me [options] [word]
+  valid options: -d database            use database <database>
+                 -m strategy            use matching strategy <strategy>
+                 -i database            get information on <database>
+                 -D                     list available databases
+                 -M                     list matching methods
+                 -I                     show server information
+                 -s server[:port]       specify server (and optional port)
+                                        default is $server:$port
+                 -v                     verbose (for debugging)
+  get more help with "perldoc -F $me"
+EOM
+    exit(1);
+}
d460 1
a460 1
+if ($#ARGV < 0) { &usage; }
d462 1
a462 1
+push(@@cmdlist, "CLIENT perl-dict\@@$hostname");
d464 1
a464 27
+while ($arg = shift @@ARGV) {
+    if    ($arg eq "-d") { $opt_d = shift @@ARGV; }
+    elsif ($arg eq "-m") {
+        $opt_m = shift @@ARGV;
+        push(@@cmdlist, "SHOW DATABASES");  # need DB list for header
+    }
+    elsif ($arg eq "-D") { push(@@cmdlist, "SHOW DATABASES");   $opt_D = 1; }
+    elsif ($arg eq "-M") { push(@@cmdlist, "SHOW STRATEGIES");  $opt_M = 1; }
+    elsif ($arg eq "-I") { push(@@cmdlist, "SHOW SERVER");      $opt_I = 1; }
+    elsif ($arg eq "-h") { $opt_h = shift @@ARGV; }
+    elsif ($arg eq "-v") { $opt_v = 1; }
+    elsif ($arg eq "-i") {
+	$opt_i = shift @@ARGV;
+	push(@@cmdlist, "SHOW DATABASES");  # need DB list for header
+	push(@@cmdlist, "SHOW INFO $opt_i");
+    } else {
+	if ($opt_m ne "") {
+	    push(@@cmdlist, "MATCH " .
+		 ($opt_d eq "" ? '*' : $opt_d) .
+		 " $opt_m  \"$arg\"");
+	} else {
+	    push(@@cmdlist, "DEFINE " .
+		 ($opt_d eq "" ? '*' : $opt_d) .
+		 " \"$arg\"");
+	}
+    }
+}
d466 2
a467 4
+if ($opt_h ne "") {                        # handle -h command line option
+    if ($opt_h =~ /:/) { ($server,$port) = split(/:/, $opt_h); }
+    else { $server = $opt_h; }
+}
d469 1
a469 1
+push(@@cmdlist, "QUIT");
d471 1
a471 8
+# NOCLUE here, too... seems to be related to Socket6
+$iaddr  = inet_aton($server)               || die "server not found";
+$paddr  = sockaddr_in($port, $iaddr);
+#($name, $aliases, $type, $len, $iaddr) = gethostbyname($server);
+#($opt_v) && printf "Server %s => %s\n", $server, $name;
+#$sockaddr = 'S n a4 x8';
+#$paddr = pack( $sockaddr, AF_INET, $port, $iaddr );
+# End switch-commenting of NOCLUE
d473 3
a475 1
+$proto  = getprotobyname('tcp');
d477 1
a477 2
+socket(SOCK, PF_INET, SOCK_STREAM, $proto) || die "socket: $!";
+connect(SOCK, $paddr)                      || die "connect: $!";
d479 2
a480 1
+select(SOCK); $| = 1; select(STDOUT); $| = 1;
d482 1
a482 4
+foreach $i (@@cmdlist) {
+    print SOCK "$i\r\n";
+    $opt_v && print "client sends: $i\n";
+}
d484 2
a485 1
+$n = $#cmdlist; $data = $buf = "";
d487 3
a489 4
+while ($buf !~ /221 /) {                   # while connection is open
+    recv(SOCK, $buf, 4096, 0);             # receive data from socket
+    $data = $data . $buf;                  # and append it to stored data
+}
d491 3
a493 3
+$data =~ s/\r\n\r\n/\r\n \r\n/g;
+@@data = split(/\r\n/,$data);
+@@data = reverse @@data;
d495 3
a497 10
+while ($line = pop @@data) {
+    if ($line =~ /^(\d{3}) (.+)$/) {
+	$tail = $2;
+	for ($1) {
+	    /110/ and do {          # database list
+		while (($line = pop @@data) !~ /^\.$/) {
+		    $line =~ /^(\S+) \"(.+)\"/;
+		    $db = $1; $name = $2;
+		    $dbs{$db} = $name;
+		}
d499 2
a500 8
+		if ($opt_D) {
+		    $- = 0;
+		    STDOUT->format_name("DB");
+		    STDOUT->format_top_name("DB_TOP");
+		    foreach $db (keys %dbs) {
+			write;
+		    }
+		}
d502 2
a503 2
+		last;
+	    };
d505 2
a506 6
+	    /111/ and do {          # strategy list
+		while (($line = pop @@data) !~ /^\.$/) {
+		    $line =~ /^(\S+) \"(.+)\"/;
+		    $strat = $1; $name = $2;
+		    $strats{$strat} = $name;
+		}
d508 1
a508 8
+		if ($opt_M) {
+		    $- = 0;
+		    STDOUT->format_name("STRAT");
+		    STDOUT->format_top_name("STRAT_TOP");
+		    foreach $strat (keys %strats) {
+			write;
+		    }
+		}
d510 4
a513 2
+		last;
+	    };
d515 2
a516 4
+	    /112/ and do {          # database info
+		print "*** Database information on \"$dbs{$opt_i}\" ***\n";
+		last;
+	    };
d518 2
a519 4
+	    /113/ and do {          # help text
+		print "*** Server/protocol help text ***\n";
+		last;
+	    };
d521 4
a524 4
+            /114/ and do {          # server info
+		print "*** Server information for $server:$port ***\n";
+		last;
+	    };
d526 9
a534 8
+	    /130|210|220|221|230|250|330/ and do {
+		# 130 challenge follows
+		# 210 open connection
+		# 220 text msg-id
+		# 221 closing connection
+		# 230 authentication successful
+		# 250 command complete
+		# 330 challenge response
d536 9
a544 4
+		($opt_v) &&
+		  print STDERR "server sends: $line\n";
+		last;
+	    };
d546 1
a546 6
+	    /150/ and do {          # definitions found
+		($num,$trash) = split(/ /,$tail);
+		print "$num definition" .
+		    (($num==1) ? "" : "s") . " found\n\n";
+		last;
+	    };
d548 4
a551 6
+	    /151/ and do {          # definition follows
+		$tail =~ /"(.+)" (.+) "(.+)"/;
+		$db = $2;
+		print "*** Source: $3 ***\n";
+		last;
+	    };
d553 3
a555 7
+	    /152/ and do {          # matches found
+	        ($num,$trash) = split(/ /,$tail);
+		print "$num match" .
+		    (($num==1) ? "" : "es"). " found\n";
+		$matching = 1;
+		last;
+	    };
d557 7
a563 3
+	    /420|421/ and do {      # server transitional errors
+		# 420 Server temporarily unavailable
+		# 421 Server shutting down
d565 4
a568 3
+		print STDERR "DICT server: $line\n";
+		last;
+	    };
d570 4
a573 7
+	    /500|501|502|503|530|531|532|550|551|552|554|555/ and do {
+		# 500 bad command, 501 bad parameters,
+		# 502 command not implemented, 503 parameter not implemented,
+		# 530/531/532 authentication failed,
+		# 550 invalid database, 551 invalid strategy,
+		# 552 no matches found
+		# 554 no databases present, 555 no strategies available
d575 1
a575 219
+		print STDERR "DICT error: $line\n";
+		last;
+	    };
+	}
+
+    } elsif ($line =~ /^\.$/) {
+	print "\n";
+    } elsif ($matching == 1) {
+	$line =~ /^(\S+) \"(.+)\"$/;
+	if ($1 ne $curdb) {
+	    $curdb = $1;
+	    print "\n*** Source: $dbs{$curdb} ***\n";
+	}
+	$cow = $query = $2;
+	print "\t$cow\n";
+    } else {
+	print "$line\n";
+    }
+}
+
+close(SOCK)                                || die "close: $!";
+exit(0);
+
+
+format DB_TOP =
+short name      description
+----------      -----------
+.
+
+format DB =
+@@<<<<<<<<<<<<<< @@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
+$db, $dbs{$db}
+.
+
+format STRAT_TOP =
+method name     description
+-----------     -----------
+.
+
+format STRAT =
+@@<<<<<<<<<<<<<< @@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
+$strat, $strats{$strat}
+.
+
+
+__END__
+
+=head1 NAME
+
+dict - perl client for the DICT protocol described in RFC 2229
+
+=head1 SYNOPSIS
+
+dict [B<-d> I<database>] [B<-m> I<strategy>] [B<-i> I<database>]
+     [B<-D>] [B<-M>] [B<-I>] [B<-h> I<server>[:I<port>]] [B<-v>] [I<word> ...]
+
+=head1 DESCRIPTION
+
+B<dict> is a client for the DICT protocol described in RFC 2229.  DICT
+is a protocol that allows a client to access dictionary definitions
+from a set of natural language dictionary databases.  More informatin
+on the DICT project is available at http://www.dict.org/ .
+
+Every DICT server has a set of databases and a set of matching
+strategies.  Unless otherwise specified (with the B<-m> option and a
+matching I<strategy>), B<dict> will request definitions of I<word>s
+specified on the command line.
+
+=head2 OPTIONS
+
+=item B<-d> I<database>
+
+Use I<database> for this query.  (Obtain a list of I<database>s with
+B<dict -D>.)  Without this option, all I<databases> will be searched.
+
+=item B<-m> I<strategy>
+
+Use I<strategy> for this query.  (Obtain a list of I<strategies> with
+B<dict -M>.)  With this option, the default behavior (returning
+definitons) is overridden and a list of words matching the query
+I<word> using the specified I<strategy> is returned.
+
+=item B<-i> I<database>
+
+Ask the server for information on I<database>.
+
+=item B<-D>
+
+Get a list of available I<database>s and their full names.
+
+=item B<-M>
+
+Get a list of available matching I<strategies>.
+
+=item B<-h> I<server>[:I<port>]
+
+Override the default I<server> (and optionally I<port>).
+
+=item B<-v>
+
+Be verbose about the DICT transaction.  This is really only useful for
+debugging.
+
+=head1 AUTHOR
+
+Bret A. Martin (bamartin@@miranda.org).
+
+=head1 BUGS
+
+B<dict> does not implement the AUTH command and associated
+functionality for authentication as specified in RFC 2229.
+
+=head1 COPYRIGHT
+
+Copyright 1997-1998 Bret A. Martin (bamartin@@miranda.org).
+
+This program is subject to the Netscape Public License Version 1.0
+(the "NPL"); you may not use this file except in compliance with the
+NPL, Version 1.0, which is outlined below:
+
+=head1 LICENCE
+
+NETSCAPE PUBLIC LICENSE
+Version 1.0
+
+=head2 1. Definitions.
+
+1.1. "Contributor" means each entity that creates or contributes to
+the creation of Modifications.
+
+1.2. "Contributor Version" means the combination of the Original
+Code, prior Modifications used by a Contributor, and the Modifications
+made by that particular Contributor.
+
+1.3. "Covered Code" means the Original Code or Modifications or the
+combination of the Original Code and Modifications, in each case
+including portions thereof.
+
+1.4. "Electronic Distribution Mechanism" means a mechanism generally
+accepted in the software development community for the electronic
+transfer of data.
+
+1.5. "Executable" means Covered Code in any form other than Source
+Code.
+
+1.6. "Initial Developer" means the individual or entity identified as
+the Initial Developer in the Source Code notice required by Exhibit A.
+
+1.7. "Larger Work" means a work which combines Covered Code or
+portions thereof with code not governed by the terms of this License.
+
+1.8. "License" means this document.
+
+1.9. "Modifications" means any addition to or deletion from the
+substance or structure of either the Original Code or any previous
+Modifications. When Covered Code is released as a series of files, a
+Modification is:
+
+    A. Any addition to or deletion from the contents of a file
+    containing Original Code or previous Modifications.
+
+    B. Any new file that contains any part of the Original Code or
+    previous Modifications.
+
+1.10. "Original Code" means Source Code of computer software code
+which is described in the Source Code notice required by Exhibit A as
+Original Code, and which, at the time of its release under this License
+is not already Covered Code governed by this License.
+
+1.11. "Source Code" means the preferred form of the Covered Code for
+making modifications to it, including all modules it contains, plus any
+associated interface definition files, scripts used to control
+compilation and installation of an Executable, or a list of source code
+differential comparisons against either the Original Code or another
+well known, available Covered Code of the Contributor's choice. The
+Source Code can be in a compressed or archival form, provided the
+appropriate decompression or de-archiving software is widely available
+for no charge.
+
+1.12. "You" means an individual or a legal entity exercising rights
+under, and complying with all of the terms of, this License or a future
+version of this License issued under Section 6.1. For legal entities,
+"You" includes any entity which controls, is controlled by, or is
+under common control with You. For purposes of this definition,
+"control" means (a) the power, direct or indirect, to cause the
+direction or management of such entity, whether by contract or
+otherwise, or (b) ownership of fifty percent (50%) or more of the
+outstanding shares or beneficial ownership of such entity.
+
+=head2 2. Source Code License.
+
+2.1. The Initial Developer Grant.
+The Initial Developer hereby grants You a world-wide, royalty-free,
+non-exclusive license, subject to third party intellectual property
+claims:
+
+    (a) to use, reproduce, modify, display, perform, sublicense and
+    distribute the Original Code (or portions thereof) with or without
+    Modifications, or as part of a Larger Work; and
+
+    (b) under patents now or hereafter owned or controlled by Initial
+    Developer, to make, have made, use and sell ("Utilize") the
+    Original Code (or portions thereof), but solely to the extent that
+    any such patent is reasonably necessary to enable You to Utilize
+    the Original Code (or portions thereof) and not to any greater
+    extent that may be necessary to Utilize further Modifications or
+    combinations.
+
+2.2. Contributor Grant.
+Each Contributor hereby grants You a world-wide, royalty-free,
+non-exclusive license, subject to third party intellectual property
+claims:
+
+    (a) to use, reproduce, modify, display, perform, sublicense and
+    distribute the Modifications created by such Contributor (or
+    portions thereof) either on an unmodified basis, with other
+    Modifications, as Covered Code or as part of a Larger Work; and
+
+    (b) under patents now or hereafter owned or controlled by
d904 2
a905 2
--- /dev/null	Sun Jan 26 12:57:40 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Fri Jan 24 16:25:56 2003
d907 1
a907 1
+# $MirBSD: obsd.util,v 1.15 2003/01/24 16:25:01 tg Exp $
d919 2
a920 2
--- /dev/null	Sun Jan 26 12:57:40 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Fri Jan 24 16:25:56 2003
d931 1
a931 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.15 2003/01/24 16:25:01 tg Exp $
d1737 2
a1738 2
--- /dev/null	Sun Jan 26 12:57:40 2003
+++ src/share/misc/acronyms	Fri Jan 24 16:25:56 2003
d1740 1
a1740 1
+$MirBSD: obsd.util,v 1.15 2003/01/24 16:25:01 tg Exp $
d2091 522
a2621 1
src/games/Makefile		+wtf +ndat +brainfuck
d2623 2
a2624 1
src/share/misc/Makefile		wtf
a2626 8
src/games/brainfuck/Makefile		me
src/games/brainfuck/brainfuck		three-liner in perl
src/games/brainfuck/brainfuck.6		me
src/games/ndat/Makefile			me
src/games/ndat/ndat.c			me
src/games/wtf/Makefile			me
src/games/wtf/wtf			much mods by me
src/games/wtf/wtf.6			wtf(6) from NetBSD
d2632 8
d2643 2
a2644 2
. add games/ndat
. add games/wtf plus acronym database
d2647 1
a2647 2
. fix errors in code of tinyirc and dict
. plus everything I've forgotten
@


1.15
log
@sync
css not yet complete
@
text
@d26 1
a26 1
against CTM on Fri Jan 24 16:24:01 UTC 2003.
d29 1
a29 1
### CTM OpenBSD-cvs 2971
d36 1
a36 1
+++ src/games/Makefile	21 Jan 2003 20:14:54 -0000
d38 1
a38 1
+#	$MirBSD: obsd.util,v 1.14 2003/01/21 19:26:04 tg Exp $
d56 1
a56 1
+++ src/gnu/usr.bin/Makefile	21 Jan 2003 20:14:54 -0000
d58 1
a58 1
+#	$MirBSD: obsd.util,v 1.14 2003/01/21 19:26:04 tg Exp $
d78 1
a78 1
+++ src/share/misc/Makefile	21 Jan 2003 20:14:55 -0000
d97 2
a98 2
--- /dev/null	Fri Jan 24 15:57:40 2003
+++ src/games/brainfuck/Makefile	Tue Jan 21 20:14:55 2003
d100 1
a100 1
+# $MirBSD: obsd.util,v 1.14 2003/01/21 19:26:04 tg Exp $
d116 2
a117 2
--- /dev/null	Fri Jan 24 15:57:40 2003
+++ src/games/brainfuck/brainfuck	Tue Jan 21 20:14:55 2003
d130 2
a131 2
--- /dev/null	Fri Jan 24 15:57:40 2003
+++ src/games/brainfuck/brainfuck.6	Tue Jan 21 20:14:55 2003
d133 1
a133 1
+.\"	$MirBSD: obsd.util,v 1.14 2003/01/21 19:26:04 tg Exp $
d214 2
a215 2
--- /dev/null	Fri Jan 24 15:57:40 2003
+++ src/games/ndat/Makefile	Tue Jan 21 20:14:55 2003
d217 1
a217 1
+# $MirBSD: obsd.util,v 1.14 2003/01/21 19:26:04 tg Exp $
d228 2
a229 2
--- /dev/null	Fri Jan 24 15:57:40 2003
+++ src/games/ndat/ndat.c	Tue Jan 21 20:14:55 2003
d231 1
a231 1
+/* $MirBSD: obsd.util,v 1.14 2003/01/21 19:26:04 tg Exp $
d254 1
a254 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.14 2003/01/21 19:26:04 tg Exp $";
d494 2
a495 2
--- /dev/null	Fri Jan 24 15:57:40 2003
+++ src/games/wtf/Makefile	Tue Jan 21 20:14:55 2003
d497 1
a497 1
+# $MirBSD: obsd.util,v 1.14 2003/01/21 19:26:04 tg Exp $
d513 2
a514 2
--- /dev/null	Fri Jan 24 15:57:40 2003
+++ src/games/wtf/wtf	Tue Jan 21 20:14:55 2003
d517 1
a517 1
+#	$MirBSD: obsd.util,v 1.14 2003/01/21 19:26:04 tg Exp $
d555 2
a556 2
--- /dev/null	Fri Jan 24 15:57:40 2003
+++ src/games/wtf/wtf.6	Tue Jan 21 20:14:55 2003
d558 1
a558 1
+.\"	$OpenBSD$ $MirBSD: obsd.util,v 1.14 2003/01/21 19:26:04 tg Exp $
d619 2
a620 2
--- /dev/null	Fri Jan 24 15:57:40 2003
+++ src/gnu/usr.bin/dict/Makefile	Tue Jan 21 20:14:55 2003
d622 1
a622 1
+# $MirBSD: obsd.util,v 1.14 2003/01/21 19:26:04 tg Exp $
d651 2
a652 2
--- /dev/null	Fri Jan 24 15:57:40 2003
+++ src/gnu/usr.bin/dict/dict	Tue Jan 21 20:14:55 2003
d660 1
a660 1
+# Revised: $Date: 2003/01/21 19:26:04 $ by x86@@ePost.de
d1433 2
a1434 2
--- /dev/null	Fri Jan 24 15:57:40 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Tue Jan 21 20:14:55 2003
d1436 1
a1436 1
+# $MirBSD: obsd.util,v 1.14 2003/01/21 19:26:04 tg Exp $
d1448 2
a1449 2
--- /dev/null	Fri Jan 24 15:57:40 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Tue Jan 21 20:14:55 2003
d1460 1
a1460 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.14 2003/01/21 19:26:04 tg Exp $
d2266 2
a2267 2
--- /dev/null	Fri Jan 24 15:57:40 2003
+++ src/share/misc/acronyms	Fri Jan 24 16:11:23 2003
d2269 1
a2269 1
+$MirBSD: obsd.util,v 1.14 2003/01/21 19:26:04 tg Exp $
@


1.14
log
@first part of system-wide sync
second part to come (check packaging list of diffs)
@
text
@d5 1
a5 1
Copyright (c) 1968-2002 NOP by the authors of and contributors to C,
d24 1
a24 1
This diff, ID $MirBSD: regen-obsdp.sh,v 1.5 2003/01/17 18:50:51 tg Exp $
d26 1
a26 1
against CTM on Tue Jan 21 19:20:16 UTC 2003.
d28 2
a29 2
### GENERATOR: @@(#)_MirBSD: regen-obsdp.sh,v 1.5 2003/01/17 18:50:51 tg Exp $
### CTM OpenBSD-cvs 2962
d36 1
a36 1
+++ src/games/Makefile	19 Jan 2003 18:46:04 -0000
d38 1
a38 1
+#	$MirBSD: obsd.util,v 1.13 2003/01/19 18:45:40 tg Exp $
d56 1
a56 1
+++ src/gnu/usr.bin/Makefile	19 Jan 2003 18:46:04 -0000
d58 1
a58 1
+#	$MirBSD: obsd.util,v 1.13 2003/01/19 18:45:40 tg Exp $
d78 1
a78 1
+++ src/share/misc/Makefile	19 Jan 2003 18:46:04 -0000
d97 2
a98 2
--- /dev/null	Tue Jan 21 18:57:41 2003
+++ src/games/brainfuck/Makefile	Sun Jan 19 18:46:04 2003
d100 1
a100 1
+# $MirBSD: obsd.util,v 1.13 2003/01/19 18:45:40 tg Exp $
d116 2
a117 2
--- /dev/null	Tue Jan 21 18:57:41 2003
+++ src/games/brainfuck/brainfuck	Sun Jan 19 18:46:04 2003
d130 2
a131 2
--- /dev/null	Tue Jan 21 18:57:41 2003
+++ src/games/brainfuck/brainfuck.6	Sun Jan 19 18:46:04 2003
d133 1
a133 1
+.\"	$MirBSD: obsd.util,v 1.13 2003/01/19 18:45:40 tg Exp $
d214 2
a215 2
--- /dev/null	Tue Jan 21 18:57:41 2003
+++ src/games/ndat/Makefile	Sun Jan 19 18:46:04 2003
d217 1
a217 1
+# $MirBSD: obsd.util,v 1.13 2003/01/19 18:45:40 tg Exp $
d228 2
a229 2
--- /dev/null	Tue Jan 21 18:57:41 2003
+++ src/games/ndat/ndat.c	Sun Jan 19 18:46:04 2003
d231 1
a231 1
+/* $MirBSD: obsd.util,v 1.13 2003/01/19 18:45:40 tg Exp $
d254 1
a254 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.13 2003/01/19 18:45:40 tg Exp $";
d494 2
a495 2
--- /dev/null	Tue Jan 21 18:57:41 2003
+++ src/games/wtf/Makefile	Sun Jan 19 18:46:04 2003
d497 1
a497 1
+# $MirBSD: obsd.util,v 1.13 2003/01/19 18:45:40 tg Exp $
d513 2
a514 2
--- /dev/null	Tue Jan 21 18:57:41 2003
+++ src/games/wtf/wtf	Sun Jan 19 18:46:04 2003
d517 1
a517 1
+#	$MirBSD: obsd.util,v 1.13 2003/01/19 18:45:40 tg Exp $
d555 2
a556 2
--- /dev/null	Tue Jan 21 18:57:41 2003
+++ src/games/wtf/wtf.6	Sun Jan 19 18:46:04 2003
d558 1
a558 1
+.\"	$OpenBSD$ $MirBSD: obsd.util,v 1.13 2003/01/19 18:45:40 tg Exp $
d619 2
a620 2
--- /dev/null	Tue Jan 21 18:57:41 2003
+++ src/gnu/usr.bin/dict/Makefile	Sun Jan 19 18:46:04 2003
d622 1
a622 1
+# $MirBSD: obsd.util,v 1.13 2003/01/19 18:45:40 tg Exp $
d651 2
a652 2
--- /dev/null	Tue Jan 21 18:57:41 2003
+++ src/gnu/usr.bin/dict/dict	Sun Jan 19 18:46:04 2003
d660 1
a660 1
+# Revised: $Date: 2003/01/19 18:45:40 $ by x86@@ePost.de
d1433 2
a1434 2
--- /dev/null	Tue Jan 21 18:57:41 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Sun Jan 19 18:46:05 2003
d1436 1
a1436 1
+# $MirBSD: obsd.util,v 1.13 2003/01/19 18:45:40 tg Exp $
d1448 2
a1449 2
--- /dev/null	Tue Jan 21 18:57:41 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Sun Jan 19 18:46:05 2003
d1460 1
a1460 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.13 2003/01/19 18:45:40 tg Exp $
d2266 4
a2269 4
--- /dev/null	Tue Jan 21 18:57:41 2003
+++ src/share/misc/acronyms	Sun Jan 19 18:46:05 2003
@@@@ -0,0 +1,347 @@@@
+$MirBSD: obsd.util,v 1.13 2003/01/19 18:45:40 tg Exp $
d2332 2
d2544 1
d2562 1
@


1.13
log
@fuck you cvs(1)
@
text
@d26 1
a26 1
against CTM on Sun Jan 19 18:42:46 UTC 2003.
d29 1
a29 1
### CTM OpenBSD-cvs 2956
d36 3
a38 3
+++ src/games/Makefile	18 Jan 2003 21:12:32 -0000
@@@@ -1,4 +1,5 @@@@
+#	$MirBSD: obsd.util,v 1.12 2003/01/18 21:11:53 tg Exp $
d42 1
a42 2
 # Moved: chess
@@@@ -8,6 +8,6 @@@@
d56 1
a56 1
+++ src/gnu/usr.bin/Makefile	18 Jan 2003 21:12:32 -0000
d58 1
a58 1
+#	$MirBSD: obsd.util,v 1.12 2003/01/18 21:11:53 tg Exp $
d78 1
a78 1
+++ src/share/misc/Makefile	18 Jan 2003 21:12:32 -0000
d97 2
a98 2
--- /dev/null	Sun Jan 19 18:20:15 2003
+++ src/games/brainfuck/Makefile	Sat Jan 18 21:12:32 2003
d100 1
a100 1
+# $MirBSD: obsd.util,v 1.12 2003/01/18 21:11:53 tg Exp $
d116 2
a117 2
--- /dev/null	Sun Jan 19 18:20:15 2003
+++ src/games/brainfuck/brainfuck	Sat Jan 18 21:12:32 2003
d130 2
a131 2
--- /dev/null	Sun Jan 19 18:20:15 2003
+++ src/games/brainfuck/brainfuck.6	Sat Jan 18 21:12:32 2003
d133 1
a133 1
+.\"	$MirBSD: obsd.util,v 1.12 2003/01/18 21:11:53 tg Exp $
d214 2
a215 2
--- /dev/null	Sun Jan 19 18:20:15 2003
+++ src/games/ndat/Makefile	Sat Jan 18 21:12:32 2003
d217 1
a217 1
+# $MirBSD: obsd.util,v 1.12 2003/01/18 21:11:53 tg Exp $
d228 2
a229 2
--- /dev/null	Sun Jan 19 18:20:15 2003
+++ src/games/ndat/ndat.c	Sat Jan 18 21:12:32 2003
d231 1
a231 1
+/* $MirBSD: obsd.util,v 1.12 2003/01/18 21:11:53 tg Exp $
d254 1
a254 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.12 2003/01/18 21:11:53 tg Exp $";
d494 2
a495 2
--- /dev/null	Sun Jan 19 18:20:15 2003
+++ src/games/wtf/Makefile	Sat Jan 18 21:12:32 2003
d497 1
a497 1
+# $MirBSD: obsd.util,v 1.12 2003/01/18 21:11:53 tg Exp $
d513 2
a514 2
--- /dev/null	Sun Jan 19 18:20:15 2003
+++ src/games/wtf/wtf	Sat Jan 18 21:12:32 2003
d517 1
a517 1
+#	$MirBSD: obsd.util,v 1.12 2003/01/18 21:11:53 tg Exp $
d555 2
a556 2
--- /dev/null	Sun Jan 19 18:20:15 2003
+++ src/games/wtf/wtf.6	Sat Jan 18 21:12:32 2003
d558 1
a558 1
+.\"	$OpenBSD$ $MirBSD: obsd.util,v 1.12 2003/01/18 21:11:53 tg Exp $
d619 2
a620 2
--- /dev/null	Sun Jan 19 18:20:15 2003
+++ src/gnu/usr.bin/dict/Makefile	Sat Jan 18 21:12:32 2003
d622 1
a622 1
+# $MirBSD: obsd.util,v 1.12 2003/01/18 21:11:53 tg Exp $
d651 2
a652 2
--- /dev/null	Sun Jan 19 18:20:15 2003
+++ src/gnu/usr.bin/dict/dict	Sat Jan 18 21:12:32 2003
d660 1
a660 1
+# Revised: $Date: 2003/01/18 21:11:53 $ by x86@@ePost.de
d1433 2
a1434 2
--- /dev/null	Sun Jan 19 18:20:15 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Sat Jan 18 21:12:32 2003
d1436 1
a1436 1
+# $MirBSD: obsd.util,v 1.12 2003/01/18 21:11:53 tg Exp $
d1448 2
a1449 2
--- /dev/null	Sun Jan 19 18:20:15 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Sat Jan 18 21:12:32 2003
d1460 1
a1460 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.12 2003/01/18 21:11:53 tg Exp $
d2266 2
a2267 2
--- /dev/null	Sun Jan 19 18:20:15 2003
+++ src/share/misc/acronyms	Sat Jan 18 21:12:32 2003
d2269 1
a2269 1
+$MirBSD: obsd.util,v 1.12 2003/01/18 21:11:53 tg Exp $
@


1.12
log
@new diff release
@
text
@d26 1
a26 1
against CTM on Sat Jan 18 21:11:22 UTC 2003.
d36 4
a39 4
+++ src/games/Makefile	17 Jan 2003 18:27:46 -0000
@@@@ -1,4 +1,4 @@@@
-#	$OpenBSD: Makefile,v 1.9 2002/05/23 18:42:59 deraadt Exp $
+#	$MirBSD: obsd.util,v 1.11 2003/01/17 18:26:40 tg Exp $
d57 1
a57 1
+++ src/gnu/usr.bin/Makefile	17 Jan 2003 18:27:46 -0000
d59 1
a59 1
+#	$MirBSD: obsd.util,v 1.11 2003/01/17 18:26:40 tg Exp $
d79 1
a79 1
+++ src/share/misc/Makefile	17 Jan 2003 18:27:46 -0000
d98 2
a99 2
--- /dev/null	Sat Jan 18 21:08:27 2003
+++ src/games/brainfuck/Makefile	Fri Jan 17 18:27:46 2003
d101 1
a101 1
+# $MirBSD: obsd.util,v 1.11 2003/01/17 18:26:40 tg Exp $
d117 2
a118 2
--- /dev/null	Sat Jan 18 21:08:27 2003
+++ src/games/brainfuck/brainfuck	Fri Jan 17 18:27:46 2003
d131 2
a132 2
--- /dev/null	Sat Jan 18 21:08:27 2003
+++ src/games/brainfuck/brainfuck.6	Fri Jan 17 18:27:46 2003
d134 1
a134 1
+.\"	$MirBSD: obsd.util,v 1.11 2003/01/17 18:26:40 tg Exp $
d215 2
a216 2
--- /dev/null	Sat Jan 18 21:08:27 2003
+++ src/games/ndat/Makefile	Fri Jan 17 18:27:46 2003
d218 1
a218 1
+# $MirBSD: obsd.util,v 1.11 2003/01/17 18:26:40 tg Exp $
d229 2
a230 2
--- /dev/null	Sat Jan 18 21:08:27 2003
+++ src/games/ndat/ndat.c	Fri Jan 17 18:27:46 2003
d232 1
a232 1
+/* $MirBSD: obsd.util,v 1.11 2003/01/17 18:26:40 tg Exp $
d255 1
a255 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.11 2003/01/17 18:26:40 tg Exp $";
d495 2
a496 2
--- /dev/null	Sat Jan 18 21:08:27 2003
+++ src/games/wtf/Makefile	Fri Jan 17 18:27:46 2003
d498 1
a498 1
+# $MirBSD: obsd.util,v 1.11 2003/01/17 18:26:40 tg Exp $
d514 2
a515 2
--- /dev/null	Sat Jan 18 21:08:27 2003
+++ src/games/wtf/wtf	Fri Jan 17 18:27:46 2003
d518 1
a518 1
+#	$MirBSD: obsd.util,v 1.11 2003/01/17 18:26:40 tg Exp $
d556 2
a557 2
--- /dev/null	Sat Jan 18 21:08:27 2003
+++ src/games/wtf/wtf.6	Fri Jan 17 18:27:46 2003
d559 1
a559 1
+.\"	$OpenBSD$ $MirBSD: obsd.util,v 1.11 2003/01/17 18:26:40 tg Exp $
d620 2
a621 2
--- /dev/null	Sat Jan 18 21:08:27 2003
+++ src/gnu/usr.bin/dict/Makefile	Fri Jan 17 18:27:46 2003
d623 1
a623 1
+# $MirBSD: obsd.util,v 1.11 2003/01/17 18:26:40 tg Exp $
d652 2
a653 2
--- /dev/null	Sat Jan 18 21:08:27 2003
+++ src/gnu/usr.bin/dict/dict	Fri Jan 17 18:27:46 2003
d661 1
a661 1
+# Revised: $Date: 2003/01/17 18:26:40 $ by x86@@ePost.de
d1434 2
a1435 2
--- /dev/null	Sat Jan 18 21:08:27 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Fri Jan 17 18:27:46 2003
d1437 1
a1437 1
+# $MirBSD: obsd.util,v 1.11 2003/01/17 18:26:40 tg Exp $
d1449 2
a1450 2
--- /dev/null	Sat Jan 18 21:08:27 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Fri Jan 17 18:27:46 2003
d1461 1
a1461 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.11 2003/01/17 18:26:40 tg Exp $
d2267 2
a2268 2
--- /dev/null	Sat Jan 18 21:08:27 2003
+++ src/share/misc/acronyms	Fri Jan 17 18:27:46 2003
d2270 1
a2270 1
+$MirBSD: obsd.util,v 1.11 2003/01/17 18:26:40 tg Exp $
@


1.11
log
@sync
compile
@
text
@d24 1
a24 1
This diff, ID : regen-obsdp.sh,v 1.4 2003/01/10 21:37:46 tg Exp $
d26 1
a26 1
against CTM on Fri Jan 17 18:25:52 UTC 2003.
d28 2
a29 2
### GENERATOR: @@(#)_MirBSD: regen-obsdp.sh,v 1.4 2003/01/10 21:37:46 tg Exp $
### CTM OpenBSD-cvs 2953
d36 1
a36 1
+++ src/games/Makefile	17 Jan 2003 17:50:20 -0000
d39 1
a39 1
+#	$MirBSD: obsd.util,v 1.10 2003/01/16 14:47:52 tg Exp $
d57 1
a57 1
+++ src/gnu/usr.bin/Makefile	17 Jan 2003 17:50:59 -0000
d59 1
a59 1
+#	$MirBSD$
d79 1
a79 1
+++ src/share/misc/Makefile	16 Jan 2003 14:48:48 -0000
d98 2
a99 2
--- /dev/null	Fri Jan 17 18:25:32 2003
+++ src/games/brainfuck/Makefile	Fri Jan 17 17:50:02 2003
d101 1
a101 1
+# $MirBSD: obsd.util,v 1.10 2003/01/16 14:47:52 tg Exp $
d117 2
a118 2
--- /dev/null	Fri Jan 17 18:25:32 2003
+++ src/games/brainfuck/brainfuck	Thu Jan 16 14:48:48 2003
d131 2
a132 2
--- /dev/null	Fri Jan 17 18:25:32 2003
+++ src/games/brainfuck/brainfuck.6	Thu Jan 16 14:48:48 2003
d134 1
a134 1
+.\"	$MirBSD: obsd.util,v 1.10 2003/01/16 14:47:52 tg Exp $
d215 2
a216 2
--- /dev/null	Fri Jan 17 18:25:32 2003
+++ src/games/ndat/Makefile	Fri Jan 17 17:50:35 2003
d218 1
a218 1
+# $MirBSD: obsd.util,v 1.10 2003/01/16 14:47:52 tg Exp $
d229 2
a230 2
--- /dev/null	Fri Jan 17 18:25:32 2003
+++ src/games/ndat/ndat.c	Thu Jan 16 14:48:48 2003
d232 1
a232 1
+/* $MirBSD: obsd.util,v 1.10 2003/01/16 14:47:52 tg Exp $
d255 1
a255 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.10 2003/01/16 14:47:52 tg Exp $";
d495 2
a496 2
--- /dev/null	Fri Jan 17 18:25:32 2003
+++ src/games/wtf/Makefile	Fri Jan 17 17:50:31 2003
d498 1
a498 1
+# $MirBSD: obsd.util,v 1.10 2003/01/16 14:47:52 tg Exp $
d514 2
a515 2
--- /dev/null	Fri Jan 17 18:25:32 2003
+++ src/games/wtf/wtf	Thu Jan 16 14:48:48 2003
d518 1
a518 1
+#	$MirBSD: obsd.util,v 1.10 2003/01/16 14:47:52 tg Exp $
d556 2
a557 2
--- /dev/null	Fri Jan 17 18:25:32 2003
+++ src/games/wtf/wtf.6	Thu Jan 16 14:48:48 2003
d559 1
a559 1
+.\"	$OpenBSD$ $MirBSD: obsd.util,v 1.10 2003/01/16 14:47:52 tg Exp $
d620 2
a621 2
--- /dev/null	Fri Jan 17 18:25:32 2003
+++ src/gnu/usr.bin/dict/Makefile	Fri Jan 17 17:49:37 2003
d623 1
a623 1
+# $MirBSD: obsd.util,v 1.10 2003/01/16 14:47:52 tg Exp $
d652 2
a653 2
--- /dev/null	Fri Jan 17 18:25:32 2003
+++ src/gnu/usr.bin/dict/dict	Thu Jan 16 14:48:48 2003
d661 1
a661 1
+# Revised: $Date: 2003/01/16 14:47:52 $ by x86@@ePost.de
d1434 2
a1435 2
--- /dev/null	Fri Jan 17 18:25:32 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Fri Jan 17 17:51:07 2003
d1437 1
a1437 1
+# $MirBSD: obsd.util,v 1.10 2003/01/16 14:47:52 tg Exp $
d1449 2
a1450 2
--- /dev/null	Fri Jan 17 18:25:32 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Thu Jan 16 14:48:48 2003
d1461 1
a1461 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.10 2003/01/16 14:47:52 tg Exp $
d2267 2
a2268 2
--- /dev/null	Fri Jan 17 18:25:32 2003
+++ src/share/misc/acronyms	Thu Jan 16 14:48:48 2003
d2270 1
a2270 1
+$MirBSD: obsd.util,v 1.10 2003/01/16 14:47:52 tg Exp $
@


1.10
log
@sync with -current
prepare for libpthread
convert ports to flavour style
dont use! untested
@
text
@d26 1
a26 1
against CTM on Thu Jan 16 14:46:49 UTC 2003.
d29 1
a29 1
### CTM OpenBSD-cvs 2950
d36 2
a37 2
+++ src/games/Makefile	10 Jan 2003 21:41:28 -0000
@@@@ -1,13 +1,13 @@@@
d39 1
d43 1
a43 4
+#	$MirBSD: obsd.util,v 1.9 2003/01/10 21:37:46 tg Exp $
 # Don't belong: xneko xroach
 
 SUBDIR=	adventure arithmetic atc backgammon banner battlestar bcd boggle \
d57 8
a64 2
+++ src/gnu/usr.bin/Makefile	10 Jan 2003 21:41:28 -0000
@@@@ -14,6 +14,9 @@@@
d67 3
a70 3
+# -mirabile (dict is under the NPL!)
+SUBDIR+=	dict tinyirc
+
a72 1
 
d79 1
a79 1
+++ src/share/misc/Makefile	10 Jan 2003 21:41:28 -0000
d98 5
a102 4
--- /dev/null	Thu Jan 16 14:11:16 2003
+++ src/games/brainfuck/Makefile	Fri Jan 10 21:41:28 2003
@@@@ -0,0 +1,11 @@@@
+# $MirBSD: obsd.util,v 1.9 2003/01/10 21:37:46 tg Exp $ Public domain.
d117 2
a118 2
--- /dev/null	Thu Jan 16 14:11:16 2003
+++ src/games/brainfuck/brainfuck	Fri Jan 10 21:41:28 2003
d131 2
a132 2
--- /dev/null	Thu Jan 16 14:11:16 2003
+++ src/games/brainfuck/brainfuck.6	Fri Jan 10 21:41:28 2003
d134 1
a134 1
+.\"	$MirBSD: obsd.util,v 1.9 2003/01/10 21:37:46 tg Exp $
d215 5
a219 4
--- /dev/null	Thu Jan 16 14:11:16 2003
+++ src/games/ndat/Makefile	Fri Jan 10 21:41:28 2003
@@@@ -0,0 +1,6 @@@@
+# $MirBSD: obsd.util,v 1.9 2003/01/10 21:37:46 tg Exp $ Public domain.
d229 2
a230 2
--- /dev/null	Thu Jan 16 14:11:16 2003
+++ src/games/ndat/ndat.c	Fri Jan 10 21:41:28 2003
d232 1
a232 1
+/* $MirBSD: obsd.util,v 1.9 2003/01/10 21:37:46 tg Exp $
d255 1
a255 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.9 2003/01/10 21:37:46 tg Exp $";
d495 5
a499 4
--- /dev/null	Thu Jan 16 14:11:16 2003
+++ src/games/wtf/Makefile	Fri Jan 10 21:41:28 2003
@@@@ -0,0 +1,11 @@@@
+# $MirBSD: obsd.util,v 1.9 2003/01/10 21:37:46 tg Exp $ Public domain.
d514 2
a515 2
--- /dev/null	Thu Jan 16 14:11:16 2003
+++ src/games/wtf/wtf	Fri Jan 10 21:41:28 2003
d518 1
a518 1
+#	$MirBSD: obsd.util,v 1.9 2003/01/10 21:37:46 tg Exp $
d556 2
a557 2
--- /dev/null	Thu Jan 16 14:11:16 2003
+++ src/games/wtf/wtf.6	Fri Jan 10 21:41:28 2003
d559 1
a559 1
+.\"	$OpenBSD$ $MirBSD: obsd.util,v 1.9 2003/01/10 21:37:46 tg Exp $
d620 5
a624 4
--- /dev/null	Thu Jan 16 14:11:16 2003
+++ src/gnu/usr.bin/dict/Makefile	Fri Jan 10 21:41:28 2003
@@@@ -0,0 +1,24 @@@@
+# $MirBSD: obsd.util,v 1.9 2003/01/10 21:37:46 tg Exp $ Public domain.
d637 1
a637 1
+		--release="OpenBSD $(uname -r)" dict.pm | \
d652 2
a653 2
--- /dev/null	Thu Jan 16 14:11:16 2003
+++ src/gnu/usr.bin/dict/dict	Fri Jan 10 21:41:28 2003
d661 1
a661 1
+# Revised: $Date: 2003/01/10 21:37:46 $ by x86@@ePost.de
d1434 5
a1438 4
--- /dev/null	Thu Jan 16 14:11:16 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Fri Jan 10 21:41:28 2003
@@@@ -0,0 +1,7 @@@@
+# $MirBSD: obsd.util,v 1.9 2003/01/10 21:37:46 tg Exp $ Public domain.
d1449 2
a1450 2
--- /dev/null	Thu Jan 16 14:11:16 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Fri Jan 10 21:41:28 2003
d1461 1
a1461 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.9 2003/01/10 21:37:46 tg Exp $
d2267 2
a2268 2
--- /dev/null	Thu Jan 16 14:11:16 2003
+++ src/share/misc/acronyms	Fri Jan 10 21:41:28 2003
d2270 1
a2270 1
+$MirBSD: obsd.util,v 1.9 2003/01/10 21:37:46 tg Exp $
@


1.9
log
@another acronyme
add RCSId to diffs
@
text
@d24 3
a26 2
This diff (/usr/ports/mystuff/util-metafiles to obsd.util) is made
against CTM on Fri Jan 10 21:35:56 UTC 2003.
d28 2
a29 2
### GENERATOR: @@(#)_MirBSD: regen-obsdp.sh,v 1.3 2003/01/06 01:52:24 tg Exp $
### CTM OpenBSD-cvs 2932
d36 1
a36 1
+++ src/games/Makefile	10 Jan 2003 19:46:42 -0000
d42 1
a42 1
+#	$MirBSD: obsd.util,v 1.8 2003/01/10 19:45:31 tg Exp $
d59 1
a59 1
+++ src/gnu/usr.bin/Makefile	10 Jan 2003 19:46:42 -0000
d76 1
a76 1
+++ src/share/misc/Makefile	10 Jan 2003 19:46:42 -0000
d95 2
a96 2
--- /dev/null	Fri Jan 10 21:04:54 2003
+++ src/games/brainfuck/Makefile	Fri Jan 10 19:46:42 2003
d98 1
a98 1
+# $MirBSD: obsd.util,v 1.8 2003/01/10 19:45:31 tg Exp $ Public domain.
d113 2
a114 2
--- /dev/null	Fri Jan 10 21:04:54 2003
+++ src/games/brainfuck/brainfuck	Fri Jan 10 19:46:42 2003
d127 2
a128 2
--- /dev/null	Fri Jan 10 21:04:54 2003
+++ src/games/brainfuck/brainfuck.6	Fri Jan 10 19:46:42 2003
d130 1
a130 1
+.\"	$MirBSD: obsd.util,v 1.8 2003/01/10 19:45:31 tg Exp $
d211 2
a212 2
--- /dev/null	Fri Jan 10 21:04:54 2003
+++ src/games/ndat/Makefile	Fri Jan 10 19:46:42 2003
d214 1
a214 1
+# $MirBSD: obsd.util,v 1.8 2003/01/10 19:45:31 tg Exp $ Public domain.
d224 2
a225 2
--- /dev/null	Fri Jan 10 21:04:54 2003
+++ src/games/ndat/ndat.c	Fri Jan 10 19:46:42 2003
d227 1
a227 1
+/* $MirBSD: obsd.util,v 1.8 2003/01/10 19:45:31 tg Exp $
d250 1
a250 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.8 2003/01/10 19:45:31 tg Exp $";
d490 2
a491 2
--- /dev/null	Fri Jan 10 21:04:54 2003
+++ src/games/wtf/Makefile	Fri Jan 10 19:46:42 2003
d493 1
a493 1
+# $MirBSD: obsd.util,v 1.8 2003/01/10 19:45:31 tg Exp $ Public domain.
d508 2
a509 2
--- /dev/null	Fri Jan 10 21:04:54 2003
+++ src/games/wtf/wtf	Fri Jan 10 19:46:42 2003
d512 1
a512 1
+#	$MirBSD: obsd.util,v 1.8 2003/01/10 19:45:31 tg Exp $
d550 2
a551 2
--- /dev/null	Fri Jan 10 21:04:54 2003
+++ src/games/wtf/wtf.6	Fri Jan 10 19:46:42 2003
d553 1
a553 1
+.\"	$OpenBSD$ $MirBSD: obsd.util,v 1.8 2003/01/10 19:45:31 tg Exp $
d614 2
a615 2
--- /dev/null	Fri Jan 10 21:04:54 2003
+++ src/gnu/usr.bin/dict/Makefile	Fri Jan 10 19:46:42 2003
d617 1
a617 1
+# $MirBSD: obsd.util,v 1.8 2003/01/10 19:45:31 tg Exp $ Public domain.
d645 2
a646 2
--- /dev/null	Fri Jan 10 21:04:54 2003
+++ src/gnu/usr.bin/dict/dict	Fri Jan 10 19:46:42 2003
d654 1
a654 1
+# Revised: $Date: 2003/01/10 19:45:31 $ by x86@@ePost.de
d1427 2
a1428 2
--- /dev/null	Fri Jan 10 21:04:54 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Fri Jan 10 19:46:42 2003
d1430 1
a1430 1
+# $MirBSD: obsd.util,v 1.8 2003/01/10 19:45:31 tg Exp $ Public domain.
d1441 2
a1442 2
--- /dev/null	Fri Jan 10 21:04:54 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Fri Jan 10 19:46:42 2003
d1453 1
a1453 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.8 2003/01/10 19:45:31 tg Exp $
d2259 2
a2260 2
--- /dev/null	Fri Jan 10 21:04:54 2003
+++ src/share/misc/acronyms	Fri Jan 10 21:35:54 2003
d2262 1
a2262 1
+$MirBSD: obsd.util,v 1.8 2003/01/10 19:45:31 tg Exp $
@


1.8
log
@make build release. all ok. sync
@
text
@d25 1
a25 1
against CTM on Fri Jan 10 19:41:59 UTC 2003.
d35 1
a35 1
+++ src/games/Makefile	6 Jan 2003 16:24:31 -0000
d41 1
a41 1
+#	$MirBSD: obsd.util,v 1.7 2003/01/06 16:23:43 tg Exp $
d58 1
a58 1
+++ src/gnu/usr.bin/Makefile	6 Jan 2003 16:24:31 -0000
d75 1
a75 1
+++ src/share/misc/Makefile	6 Jan 2003 16:24:31 -0000
d94 2
a95 2
--- /dev/null	Fri Jan 10 19:12:14 2003
+++ src/games/brainfuck/Makefile	Mon Jan  6 16:24:31 2003
d97 1
a97 1
+# $MirBSD: obsd.util,v 1.7 2003/01/06 16:23:43 tg Exp $ Public domain.
d112 2
a113 2
--- /dev/null	Fri Jan 10 19:12:14 2003
+++ src/games/brainfuck/brainfuck	Mon Jan  6 16:24:31 2003
d126 2
a127 2
--- /dev/null	Fri Jan 10 19:12:14 2003
+++ src/games/brainfuck/brainfuck.6	Mon Jan  6 16:24:31 2003
d129 1
a129 1
+.\"	$MirBSD: obsd.util,v 1.7 2003/01/06 16:23:43 tg Exp $
d210 2
a211 2
--- /dev/null	Fri Jan 10 19:12:14 2003
+++ src/games/ndat/Makefile	Mon Jan  6 16:24:31 2003
d213 1
a213 1
+# $MirBSD: obsd.util,v 1.7 2003/01/06 16:23:43 tg Exp $ Public domain.
d223 2
a224 2
--- /dev/null	Fri Jan 10 19:12:14 2003
+++ src/games/ndat/ndat.c	Mon Jan  6 16:24:31 2003
d226 1
a226 1
+/* $MirBSD: obsd.util,v 1.7 2003/01/06 16:23:43 tg Exp $
d249 1
a249 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.7 2003/01/06 16:23:43 tg Exp $";
d489 2
a490 2
--- /dev/null	Fri Jan 10 19:12:14 2003
+++ src/games/wtf/Makefile	Mon Jan  6 16:24:31 2003
d492 1
a492 1
+# $MirBSD: obsd.util,v 1.7 2003/01/06 16:23:43 tg Exp $ Public domain.
d507 2
a508 2
--- /dev/null	Fri Jan 10 19:12:14 2003
+++ src/games/wtf/wtf	Mon Jan  6 16:24:31 2003
d511 1
a511 1
+#	$MirBSD: obsd.util,v 1.7 2003/01/06 16:23:43 tg Exp $
d549 2
a550 2
--- /dev/null	Fri Jan 10 19:12:14 2003
+++ src/games/wtf/wtf.6	Mon Jan  6 16:24:31 2003
d552 1
a552 1
+.\"	$OpenBSD$ $MirBSD: obsd.util,v 1.7 2003/01/06 16:23:43 tg Exp $
d613 2
a614 2
--- /dev/null	Fri Jan 10 19:12:14 2003
+++ src/gnu/usr.bin/dict/Makefile	Mon Jan  6 16:24:31 2003
d616 1
a616 1
+# $MirBSD: obsd.util,v 1.7 2003/01/06 16:23:43 tg Exp $ Public domain.
d644 2
a645 2
--- /dev/null	Fri Jan 10 19:12:14 2003
+++ src/gnu/usr.bin/dict/dict	Mon Jan  6 16:24:31 2003
d653 1
a653 1
+# Revised: $Date: 2003/01/06 16:23:43 $ by x86@@ePost.de
d1426 2
a1427 2
--- /dev/null	Fri Jan 10 19:12:14 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Mon Jan  6 16:24:31 2003
d1429 1
a1429 1
+# $MirBSD: obsd.util,v 1.7 2003/01/06 16:23:43 tg Exp $ Public domain.
d1440 2
a1441 2
--- /dev/null	Fri Jan 10 19:12:14 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Mon Jan  6 16:24:31 2003
d1452 1
a1452 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.7 2003/01/06 16:23:43 tg Exp $
d2258 4
a2261 4
--- /dev/null	Fri Jan 10 19:12:14 2003
+++ src/share/misc/acronyms	Mon Jan  6 16:24:31 2003
@@@@ -0,0 +1,346 @@@@
+$MirBSD: obsd.util,v 1.7 2003/01/06 16:23:43 tg Exp $
d2287 1
@


1.7
log
@sync for xsa; make index; nothing new
@
text
@d25 1
a25 1
against CTM on Mon Jan  6 16:22:12 UTC 2003.
d28 1
a28 1
### CTM OpenBSD-cvs 2920
d35 1
a35 1
+++ src/games/Makefile	5 Jan 2003 22:56:27 -0000
d41 1
a41 1
+#	$MirBSD: obsd.util,v 1.6 2003/01/05 22:53:19 tg Exp $
d58 1
a58 1
+++ src/gnu/usr.bin/Makefile	5 Jan 2003 22:56:28 -0000
d75 1
a75 1
+++ src/share/misc/Makefile	5 Jan 2003 22:56:28 -0000
d94 2
a95 2
--- /dev/null	Mon Jan  6 16:10:50 2003
+++ src/games/brainfuck/Makefile	Sun Jan  5 22:56:28 2003
d97 1
a97 1
+# $MirBSD: obsd.util,v 1.6 2003/01/05 22:53:19 tg Exp $ Public domain.
d112 2
a113 2
--- /dev/null	Mon Jan  6 16:10:50 2003
+++ src/games/brainfuck/brainfuck	Sun Jan  5 22:56:28 2003
d126 2
a127 2
--- /dev/null	Mon Jan  6 16:10:50 2003
+++ src/games/brainfuck/brainfuck.6	Sun Jan  5 22:56:28 2003
d129 1
a129 1
+.\"	$MirBSD: obsd.util,v 1.6 2003/01/05 22:53:19 tg Exp $
d210 2
a211 2
--- /dev/null	Mon Jan  6 16:10:50 2003
+++ src/games/ndat/Makefile	Sun Jan  5 22:56:28 2003
d213 1
a213 1
+# $MirBSD: obsd.util,v 1.6 2003/01/05 22:53:19 tg Exp $ Public domain.
d223 2
a224 2
--- /dev/null	Mon Jan  6 16:10:50 2003
+++ src/games/ndat/ndat.c	Sun Jan  5 22:56:28 2003
d226 1
a226 1
+/* $MirBSD: obsd.util,v 1.6 2003/01/05 22:53:19 tg Exp $
d249 1
a249 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.6 2003/01/05 22:53:19 tg Exp $";
d489 2
a490 2
--- /dev/null	Mon Jan  6 16:10:50 2003
+++ src/games/wtf/Makefile	Sun Jan  5 22:56:28 2003
d492 1
a492 1
+# $MirBSD: obsd.util,v 1.6 2003/01/05 22:53:19 tg Exp $ Public domain.
d507 2
a508 2
--- /dev/null	Mon Jan  6 16:10:50 2003
+++ src/games/wtf/wtf	Sun Jan  5 22:56:28 2003
d511 1
a511 1
+#	$MirBSD: obsd.util,v 1.6 2003/01/05 22:53:19 tg Exp $
d549 2
a550 2
--- /dev/null	Mon Jan  6 16:10:50 2003
+++ src/games/wtf/wtf.6	Sun Jan  5 22:56:28 2003
d552 1
a552 1
+.\"	$OpenBSD$ $MirBSD: obsd.util,v 1.6 2003/01/05 22:53:19 tg Exp $
d613 2
a614 2
--- /dev/null	Mon Jan  6 16:10:50 2003
+++ src/gnu/usr.bin/dict/Makefile	Sun Jan  5 22:56:28 2003
d616 1
a616 1
+# $MirBSD: obsd.util,v 1.6 2003/01/05 22:53:19 tg Exp $ Public domain.
d644 2
a645 2
--- /dev/null	Mon Jan  6 16:10:50 2003
+++ src/gnu/usr.bin/dict/dict	Sun Jan  5 22:56:28 2003
d653 1
a653 1
+# Revised: $Date: 2003/01/05 22:53:19 $ by x86@@ePost.de
d1426 2
a1427 2
--- /dev/null	Mon Jan  6 16:10:50 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Sun Jan  5 22:56:28 2003
d1429 1
a1429 1
+# $MirBSD: obsd.util,v 1.6 2003/01/05 22:53:19 tg Exp $ Public domain.
d1440 2
a1441 2
--- /dev/null	Mon Jan  6 16:10:50 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Sun Jan  5 22:56:28 2003
d1452 1
a1452 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.6 2003/01/05 22:53:19 tg Exp $
d2258 2
a2259 2
--- /dev/null	Mon Jan  6 16:10:50 2003
+++ src/share/misc/acronyms	Sun Jan  5 22:56:28 2003
d2261 1
a2261 1
+$MirBSD: obsd.util,v 1.6 2003/01/05 22:53:19 tg Exp $
@


1.6
log
@tg@@n1:/home/tg $ uname -a
OpenBSD n1.BOFH.gott.cx 3.2-20021231 GENERIC#132 i386

That one did fairly well, but there's a lot more commits,
diffs, conflicts, new sendmail, byebye amiga, etc. pp
@
text
@d3 1
a3 1
Copyright (c) 2000-2002 by Thorsten "mirabile" Glaser <x86@@ePost.de>
d25 1
a25 1
against CTM on Sun Jan  5 22:50:39 UTC 2003.
d27 2
a28 2
### GENERATOR: @@(#)_MirBSD: regen-obsdp.sh,v 1.2 2002/12/20 19:11:26 tg Exp $
### CTM OpenBSD-cvs 2917
d35 3
a37 4
+++ src/games/Makefile	5 Jan 2003 22:44:52 -0000
@@@@ -1,3 +1,4 @@@@
+#	$MirBSD: obsd.util,v 1.5 2002/12/31 01:38:59 tg Exp $
 #	$OpenBSD: Makefile,v 1.9 2002/05/23 18:42:59 deraadt Exp $
d40 5
a44 1
@@@@ -8,6 +9,6 @@@@
d58 1
a58 1
+++ src/gnu/usr.bin/Makefile	5 Jan 2003 22:44:52 -0000
d75 1
a75 1
+++ src/share/misc/Makefile	5 Jan 2003 22:44:52 -0000
d94 2
a95 2
--- /dev/null	Sun Jan  5 22:48:56 2003
+++ src/games/brainfuck/Makefile	Sun Jan  5 22:44:52 2003
d97 1
a97 1
+# $MirBSD: obsd.util,v 1.5 2002/12/31 01:38:59 tg Exp $ Public domain.
d112 2
a113 2
--- /dev/null	Sun Jan  5 22:48:56 2003
+++ src/games/brainfuck/brainfuck	Sun Jan  5 22:44:52 2003
d126 2
a127 2
--- /dev/null	Sun Jan  5 22:48:56 2003
+++ src/games/brainfuck/brainfuck.6	Sun Jan  5 22:44:52 2003
d129 1
a129 1
+.\"	$MirBSD: obsd.util,v 1.5 2002/12/31 01:38:59 tg Exp $
d210 2
a211 2
--- /dev/null	Sun Jan  5 22:48:56 2003
+++ src/games/ndat/Makefile	Sun Jan  5 22:44:52 2003
d213 1
a213 1
+# $MirBSD: obsd.util,v 1.5 2002/12/31 01:38:59 tg Exp $ Public domain.
d223 2
a224 2
--- /dev/null	Sun Jan  5 22:48:56 2003
+++ src/games/ndat/ndat.c	Sun Jan  5 22:44:52 2003
d226 1
a226 1
+/* $MirBSD: obsd.util,v 1.5 2002/12/31 01:38:59 tg Exp $
d249 1
a249 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.5 2002/12/31 01:38:59 tg Exp $";
d489 2
a490 2
--- /dev/null	Sun Jan  5 22:48:56 2003
+++ src/games/wtf/Makefile	Sun Jan  5 22:44:52 2003
d492 1
a492 1
+# $MirBSD: obsd.util,v 1.5 2002/12/31 01:38:59 tg Exp $ Public domain.
d507 2
a508 2
--- /dev/null	Sun Jan  5 22:48:56 2003
+++ src/games/wtf/wtf	Sun Jan  5 22:44:52 2003
d511 1
a511 1
+#	$MirBSD: obsd.util,v 1.5 2002/12/31 01:38:59 tg Exp $
d549 2
a550 2
--- /dev/null	Sun Jan  5 22:48:56 2003
+++ src/games/wtf/wtf.6	Sun Jan  5 22:44:52 2003
d552 1
a552 1
+.\"	$OpenBSD$ $MirBSD: obsd.util,v 1.5 2002/12/31 01:38:59 tg Exp $
d613 2
a614 2
--- /dev/null	Sun Jan  5 22:48:56 2003
+++ src/gnu/usr.bin/dict/Makefile	Sun Jan  5 22:44:52 2003
d616 1
a616 1
+# $MirBSD: obsd.util,v 1.5 2002/12/31 01:38:59 tg Exp $ Public domain.
d644 2
a645 2
--- /dev/null	Sun Jan  5 22:48:56 2003
+++ src/gnu/usr.bin/dict/dict	Sun Jan  5 22:44:52 2003
d653 1
a653 1
+# Revised: $Date: 2002/12/31 01:38:59 $ by x86@@ePost.de
d1426 2
a1427 2
--- /dev/null	Sun Jan  5 22:48:56 2003
+++ src/gnu/usr.bin/tinyirc/Makefile	Sun Jan  5 22:44:52 2003
d1429 1
a1429 1
+# $MirBSD: obsd.util,v 1.5 2002/12/31 01:38:59 tg Exp $ Public domain.
d1440 2
a1441 2
--- /dev/null	Sun Jan  5 22:48:56 2003
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Sun Jan  5 22:44:52 2003
d1452 1
a1452 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.5 2002/12/31 01:38:59 tg Exp $
d2258 2
a2259 2
--- /dev/null	Sun Jan  5 22:48:56 2003
+++ src/share/misc/acronyms	Sun Jan  5 22:45:11 2003
d2261 1
a2261 1
+$MirBSD: obsd.util,v 1.5 2002/12/31 01:38:59 tg Exp $
@


1.5
log
@sync with -current, not more
@
text
@d25 1
a25 1
against CTM on Tue Dec 31 01:32:37 UTC 2002.
d28 1
a28 1
### CTM OpenBSD-cvs 2909
d35 1
a35 1
+++ src/games/Makefile	20 Dec 2002 23:25:05 -0000
d37 1
a37 1
+#	$MirBSD: obsd.util,v 1.4 2002/12/20 23:24:35 tg Exp $
d55 1
a55 1
+++ src/gnu/usr.bin/Makefile	20 Dec 2002 23:25:05 -0000
d72 1
a72 1
+++ src/share/misc/Makefile	20 Dec 2002 23:25:05 -0000
d91 2
a92 2
--- /dev/null	Tue Dec 31 01:30:54 2002
+++ src/games/brainfuck/Makefile	Fri Dec 20 23:25:05 2002
d94 1
a94 1
+# $MirBSD: obsd.util,v 1.4 2002/12/20 23:24:35 tg Exp $ Public domain.
d109 2
a110 2
--- /dev/null	Tue Dec 31 01:30:54 2002
+++ src/games/brainfuck/brainfuck	Fri Dec 20 23:25:05 2002
d123 2
a124 2
--- /dev/null	Tue Dec 31 01:30:54 2002
+++ src/games/brainfuck/brainfuck.6	Fri Dec 20 23:25:05 2002
d126 1
a126 1
+.\"	$MirBSD: obsd.util,v 1.4 2002/12/20 23:24:35 tg Exp $
d207 2
a208 2
--- /dev/null	Tue Dec 31 01:30:54 2002
+++ src/games/ndat/Makefile	Fri Dec 20 23:25:05 2002
d210 1
a210 1
+# $MirBSD: obsd.util,v 1.4 2002/12/20 23:24:35 tg Exp $ Public domain.
d220 2
a221 2
--- /dev/null	Tue Dec 31 01:30:54 2002
+++ src/games/ndat/ndat.c	Tue Dec 31 01:17:09 2002
d223 1
a223 1
+/* $MirBSD: obsd.util,v 1.4 2002/12/20 23:24:35 tg Exp $
d246 1
a246 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.4 2002/12/20 23:24:35 tg Exp $";
d486 2
a487 2
--- /dev/null	Tue Dec 31 01:30:54 2002
+++ src/games/wtf/Makefile	Fri Dec 20 23:25:05 2002
d489 1
a489 1
+# $MirBSD: obsd.util,v 1.4 2002/12/20 23:24:35 tg Exp $ Public domain.
d504 2
a505 2
--- /dev/null	Tue Dec 31 01:30:54 2002
+++ src/games/wtf/wtf	Fri Dec 20 23:25:05 2002
d508 1
a508 1
+#	$MirBSD: obsd.util,v 1.4 2002/12/20 23:24:35 tg Exp $
d546 2
a547 2
--- /dev/null	Tue Dec 31 01:30:54 2002
+++ src/games/wtf/wtf.6	Fri Dec 20 23:25:05 2002
d549 1
a549 1
+.\"	$OpenBSD$ $MirBSD: obsd.util,v 1.4 2002/12/20 23:24:35 tg Exp $
d610 2
a611 2
--- /dev/null	Tue Dec 31 01:30:54 2002
+++ src/gnu/usr.bin/dict/Makefile	Fri Dec 20 23:25:06 2002
d613 1
a613 1
+# $MirBSD: obsd.util,v 1.4 2002/12/20 23:24:35 tg Exp $ Public domain.
d641 2
a642 2
--- /dev/null	Tue Dec 31 01:30:54 2002
+++ src/gnu/usr.bin/dict/dict	Fri Dec 20 23:25:06 2002
d650 1
a650 1
+# Revised: $Date: 2002/12/20 23:24:35 $ by x86@@ePost.de
d1423 2
a1424 2
--- /dev/null	Tue Dec 31 01:30:54 2002
+++ src/gnu/usr.bin/tinyirc/Makefile	Fri Dec 20 23:25:06 2002
d1426 1
a1426 1
+# $MirBSD: obsd.util,v 1.4 2002/12/20 23:24:35 tg Exp $ Public domain.
d1437 2
a1438 2
--- /dev/null	Tue Dec 31 01:30:54 2002
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Fri Dec 20 23:25:06 2002
d1449 1
a1449 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.4 2002/12/20 23:24:35 tg Exp $
d2255 4
a2258 4
--- /dev/null	Tue Dec 31 01:30:54 2002
+++ src/share/misc/acronyms	Tue Dec 31 01:18:58 2002
@@@@ -0,0 +1,344 @@@@
+$MirBSD: obsd.util,v 1.4 2002/12/20 23:24:35 tg Exp $
d2280 1
d2504 1
@


1.4
log
@sync/update/merge here, too
@
text
@d25 1
a25 1
against CTM on Fri Dec 20 23:24:10 UTC 2002.
d28 1
a28 1
### CTM OpenBSD-cvs 2906
d35 1
a35 1
+++ src/games/Makefile	20 Dec 2002 19:52:54 -0000
d37 1
a37 1
+#	$MirBSD: obsd.util,v 1.3 2002/12/05 17:54:40 tg Exp $
d55 1
a55 1
+++ src/gnu/usr.bin/Makefile	20 Dec 2002 19:52:54 -0000
d72 1
a72 1
+++ src/share/misc/Makefile	20 Dec 2002 19:52:54 -0000
d91 2
a92 2
--- /dev/null	Fri Dec 20 23:07:58 2002
+++ src/games/brainfuck/Makefile	Fri Dec 20 19:52:54 2002
d94 1
a94 1
+# $MirBSD: obsd.util,v 1.3 2002/12/05 17:54:40 tg Exp $ Public domain.
d109 2
a110 2
--- /dev/null	Fri Dec 20 23:07:58 2002
+++ src/games/brainfuck/brainfuck	Fri Dec 20 19:52:54 2002
d123 2
a124 2
--- /dev/null	Fri Dec 20 23:07:58 2002
+++ src/games/brainfuck/brainfuck.6	Fri Dec 20 19:52:54 2002
d126 1
a126 1
+.\"	$MirBSD: obsd.util,v 1.3 2002/12/05 17:54:40 tg Exp $
d207 2
a208 2
--- /dev/null	Fri Dec 20 23:07:58 2002
+++ src/games/ndat/Makefile	Fri Dec 20 19:52:54 2002
d210 1
a210 1
+# $MirBSD: obsd.util,v 1.3 2002/12/05 17:54:40 tg Exp $ Public domain.
d220 4
a223 4
--- /dev/null	Fri Dec 20 23:07:58 2002
+++ src/games/ndat/ndat.c	Fri Dec 20 19:52:54 2002
@@@@ -0,0 +1,260 @@@@
+/* $MirBSD: obsd.util,v 1.3 2002/12/05 17:54:40 tg Exp $
d228 4
a231 4
+ * I retain the right to be known as the author of the work. For no fee
+ * and further restrainments, all patents hold by the author or contri-
+ * butors, applying to this work, shall be licensed to any copy of this
+ * work, whether modified, merged or not.
d238 2
a239 3
+ */
+
+/*
d243 1
a243 1
+ * man page still missing...
d246 1
a246 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.3 2002/12/05 17:54:40 tg Exp $";
d486 2
a487 2
--- /dev/null	Fri Dec 20 23:07:58 2002
+++ src/games/wtf/Makefile	Fri Dec 20 19:52:54 2002
d489 1
a489 1
+# $MirBSD: obsd.util,v 1.3 2002/12/05 17:54:40 tg Exp $ Public domain.
d504 2
a505 2
--- /dev/null	Fri Dec 20 23:07:58 2002
+++ src/games/wtf/wtf	Fri Dec 20 19:52:54 2002
d508 1
a508 1
+#	$MirBSD: obsd.util,v 1.3 2002/12/05 17:54:40 tg Exp $
d546 2
a547 2
--- /dev/null	Fri Dec 20 23:07:58 2002
+++ src/games/wtf/wtf.6	Fri Dec 20 19:52:54 2002
d549 1
a549 1
+.\"	$OpenBSD$ $MirBSD: obsd.util,v 1.3 2002/12/05 17:54:40 tg Exp $
d610 2
a611 2
--- /dev/null	Fri Dec 20 23:07:58 2002
+++ src/gnu/usr.bin/dict/Makefile	Fri Dec 20 19:52:54 2002
d613 1
a613 1
+# $MirBSD: obsd.util,v 1.3 2002/12/05 17:54:40 tg Exp $ Public domain.
d641 2
a642 2
--- /dev/null	Fri Dec 20 23:07:58 2002
+++ src/gnu/usr.bin/dict/dict	Fri Dec 20 19:52:54 2002
d650 1
a650 1
+# Revised: $Date: 2002/12/05 17:54:40 $ by x86@@ePost.de
d1423 2
a1424 2
--- /dev/null	Fri Dec 20 23:07:58 2002
+++ src/gnu/usr.bin/tinyirc/Makefile	Fri Dec 20 19:52:54 2002
d1426 1
a1426 1
+# $MirBSD: obsd.util,v 1.3 2002/12/05 17:54:40 tg Exp $ Public domain.
d1437 2
a1438 2
--- /dev/null	Fri Dec 20 23:07:58 2002
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Fri Dec 20 19:52:54 2002
d1449 1
a1449 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.3 2002/12/05 17:54:40 tg Exp $
d2255 4
a2258 4
--- /dev/null	Fri Dec 20 23:07:58 2002
+++ src/share/misc/acronyms	Fri Dec 20 23:21:32 2002
@@@@ -0,0 +1,343 @@@@
+$MirBSD: obsd.util,v 1.3 2002/12/05 17:54:40 tg Exp $
d2319 1
@


1.3
log
@LAST UPDATE EVER!
@
text
@d5 4
a8 3
Copyright (c) 1968-2002 NOP by the creators of UNIX, BSD / Berkeley
    Unix, NetBSD and OpenBSD. A patched file also shares the licence
    of the file before patching, unless special provisions are made.
d25 1
a25 1
against CTM on Thu Dec  5 17:00:29 UTC 2002.
d27 2
a28 2
### GENERATOR: @@(#)_MirBSD: regen-obsdp.sh,v 1.1 2002/12/03 20:04:25 tg Exp $
### CTM OpenBSD-cvs 2858
d35 1
a35 1
+++ src/games/Makefile	4 Dec 2002 19:12:49 -0000
d37 1
a37 1
+#	$MirBSD: obsd.util,v 1.2 2002/12/04 19:11:47 tg Exp $
d55 1
a55 1
+++ src/gnu/usr.bin/Makefile	4 Dec 2002 19:12:49 -0000
d72 1
a72 1
+++ src/share/misc/Makefile	4 Dec 2002 19:12:49 -0000
d91 2
a92 2
--- /dev/null	Thu Dec  5 16:15:28 2002
+++ src/games/brainfuck/Makefile	Wed Dec  4 19:12:49 2002
d94 1
a94 1
+# $MirBSD: obsd.util,v 1.2 2002/12/04 19:11:47 tg Exp $ Public domain.
d109 2
a110 2
--- /dev/null	Thu Dec  5 16:15:28 2002
+++ src/games/brainfuck/brainfuck	Wed Dec  4 19:12:49 2002
d123 2
a124 2
--- /dev/null	Thu Dec  5 16:15:28 2002
+++ src/games/brainfuck/brainfuck.6	Wed Dec  4 19:12:49 2002
d126 1
a126 1
+.\"	$MirBSD: obsd.util,v 1.2 2002/12/04 19:11:47 tg Exp $
d207 2
a208 2
--- /dev/null	Thu Dec  5 16:15:28 2002
+++ src/games/ndat/Makefile	Wed Dec  4 19:12:49 2002
d210 1
a210 1
+# $MirBSD: obsd.util,v 1.2 2002/12/04 19:11:47 tg Exp $ Public domain.
d220 2
a221 2
--- /dev/null	Thu Dec  5 16:15:28 2002
+++ src/games/ndat/ndat.c	Wed Dec  4 19:12:49 2002
d223 1
a223 1
+/* $MirBSD: obsd.util,v 1.2 2002/12/04 19:11:47 tg Exp $
d247 1
a247 1
+static const char RCSId[]="$MirBSD: obsd.util,v 1.2 2002/12/04 19:11:47 tg Exp $";
d487 2
a488 2
--- /dev/null	Thu Dec  5 16:15:28 2002
+++ src/games/wtf/Makefile	Wed Dec  4 19:12:49 2002
d490 1
a490 1
+# $MirBSD: obsd.util,v 1.2 2002/12/04 19:11:47 tg Exp $ Public domain.
d505 2
a506 2
--- /dev/null	Thu Dec  5 16:15:28 2002
+++ src/games/wtf/wtf	Wed Dec  4 19:12:49 2002
d509 1
a509 1
+#	$MirBSD: obsd.util,v 1.2 2002/12/04 19:11:47 tg Exp $
d547 2
a548 2
--- /dev/null	Thu Dec  5 16:15:28 2002
+++ src/games/wtf/wtf.6	Wed Dec  4 19:12:49 2002
d550 1
a550 1
+.\"	$OpenBSD$ $MirBSD: obsd.util,v 1.2 2002/12/04 19:11:47 tg Exp $
d611 2
a612 2
--- /dev/null	Thu Dec  5 16:15:28 2002
+++ src/gnu/usr.bin/dict/Makefile	Wed Dec  4 19:12:49 2002
d614 1
a614 1
+# $MirBSD: obsd.util,v 1.2 2002/12/04 19:11:47 tg Exp $ Public domain.
d642 2
a643 2
--- /dev/null	Thu Dec  5 16:15:28 2002
+++ src/gnu/usr.bin/dict/dict	Wed Dec  4 19:12:49 2002
d651 1
a651 1
+# Revised: $Date: 2002/12/04 19:11:47 $ by x86@@ePost.de
d1424 2
a1425 2
--- /dev/null	Thu Dec  5 16:15:28 2002
+++ src/gnu/usr.bin/tinyirc/Makefile	Wed Dec  4 19:12:49 2002
d1427 1
a1427 1
+# $MirBSD: obsd.util,v 1.2 2002/12/04 19:11:47 tg Exp $ Public domain.
d1438 2
a1439 2
--- /dev/null	Thu Dec  5 16:15:28 2002
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Wed Dec  4 19:12:49 2002
d1450 1
a1450 1
+/* tinyirc 1.0		$MirBSD: obsd.util,v 1.2 2002/12/04 19:11:47 tg Exp $
d2256 4
a2259 4
--- /dev/null	Thu Dec  5 16:15:28 2002
+++ src/share/misc/acronyms	Wed Dec  4 19:12:49 2002
@@@@ -0,0 +1,342 @@@@
+$MirBSD: obsd.util,v 1.2 2002/12/04 19:11:47 tg Exp $
d2532 1
@


1.2
log
@current progress
@
text
@d24 1
a24 1
against CTM on Wed Dec  4 19:05:23 UTC 2002.
d34 1
a34 1
+++ src/games/Makefile	4 Dec 2002 18:13:53 -0000
d36 1
a36 1
+#	$MirBSD$
d54 1
a54 1
+++ src/gnu/usr.bin/Makefile	4 Dec 2002 18:13:53 -0000
d71 1
a71 1
+++ src/share/misc/Makefile	4 Dec 2002 18:13:53 -0000
d90 2
a91 2
--- /dev/null	Wed Dec  4 18:57:40 2002
+++ src/games/brainfuck/Makefile	Wed Dec  4 18:13:53 2002
d93 1
a93 1
+# $MirBSD$ Public domain.
d108 2
a109 2
--- /dev/null	Wed Dec  4 18:57:40 2002
+++ src/games/brainfuck/brainfuck	Wed Dec  4 18:13:53 2002
d122 2
a123 2
--- /dev/null	Wed Dec  4 18:57:40 2002
+++ src/games/brainfuck/brainfuck.6	Wed Dec  4 18:13:53 2002
d125 1
a125 1
+.\"	$MirBSD$
d206 2
a207 2
--- /dev/null	Wed Dec  4 18:57:40 2002
+++ src/games/ndat/Makefile	Wed Dec  4 18:13:53 2002
d209 1
a209 1
+# $MirBSD$ Public domain.
d219 2
a220 2
--- /dev/null	Wed Dec  4 18:57:40 2002
+++ src/games/ndat/ndat.c	Wed Dec  4 18:13:53 2002
d222 1
a222 1
+/* $MirBSD$
d246 1
a246 1
+static const char RCSId[]="$MirBSD$";
d486 2
a487 2
--- /dev/null	Wed Dec  4 18:57:40 2002
+++ src/games/wtf/Makefile	Wed Dec  4 18:13:53 2002
d489 1
a489 1
+# $MirBSD$ Public domain.
d504 2
a505 2
--- /dev/null	Wed Dec  4 18:57:40 2002
+++ src/games/wtf/wtf	Wed Dec  4 18:13:53 2002
d508 1
a508 1
+#	$MirBSD$
d546 2
a547 2
--- /dev/null	Wed Dec  4 18:57:40 2002
+++ src/games/wtf/wtf.6	Wed Dec  4 18:13:53 2002
d549 1
a549 1
+.\"	$OpenBSD$ $MirBSD$
d610 2
a611 2
--- /dev/null	Wed Dec  4 18:57:40 2002
+++ src/gnu/usr.bin/dict/Makefile	Wed Dec  4 18:13:53 2002
d613 1
a613 1
+# $MirBSD$ Public domain.
d641 2
a642 2
--- /dev/null	Wed Dec  4 18:57:40 2002
+++ src/gnu/usr.bin/dict/dict	Wed Dec  4 18:13:53 2002
d650 1
a650 1
+# Revised: $Date: 2002/12/03 20:06:43 $ by x86@@ePost.de
d1423 2
a1424 2
--- /dev/null	Wed Dec  4 18:57:40 2002
+++ src/gnu/usr.bin/tinyirc/Makefile	Wed Dec  4 18:13:53 2002
d1426 1
a1426 1
+# $MirBSD$ Public domain.
d1437 2
a1438 2
--- /dev/null	Wed Dec  4 18:57:40 2002
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Wed Dec  4 18:13:53 2002
d1449 1
a1449 1
+/* tinyirc 1.0		$MirBSD$
d2255 2
a2256 2
--- /dev/null	Wed Dec  4 18:57:40 2002
+++ src/share/misc/acronyms	Wed Dec  4 18:13:53 2002
d2258 1
a2258 1
+$MirBSD$
@


1.1
log
@re-import the old BSD-mirabile patches

conversion to MirBSD will take place,
but first the compile problems regarding
the stack protector "propolice" have to
be resolved.
@
text
@d1 1
a1 1
>>> UTIL part of OBSD.DIFF - Instructions at the bottom
d4 4
d11 4
a14 4
I retain the right to be known as the author of the work. For no fee
and further restrainments, all patents hold by the author or contri-
butors, applying to this work, shall be licensed to any copy of this
work, whether modified, merged or not.
d22 1
a22 2
Patched files share the license of the original files. - Followed by
the release notes, the list of modified/added files is at the EOF.
d24 1
a24 1
against CTM on Tue Dec  3 15:46:24 UTC 2002.
d26 2
a27 2
### GENERATOR: @@(#)_tgId: regen-obsdp.sh,v 3.19 2002/11/30 22:40:15 tg Exp $
### CTM OpenBSD-cvs 2855
d34 1
a34 1
+++ src/games/Makefile	3 Dec 2002 15:31:08 -0000
d36 1
a36 1
+#	$tgId: obsd.util,v 3.32 2002/12/03 15:46:56 tg Exp $
d54 1
a54 1
+++ src/gnu/usr.bin/Makefile	3 Dec 2002 15:31:08 -0000
d71 1
a71 1
+++ src/share/misc/Makefile	3 Dec 2002 15:31:08 -0000
d90 2
a91 2
--- /dev/null	Tue Dec  3 15:15:33 2002
+++ src/games/brainfuck/Makefile	Tue Dec  3 15:31:08 2002
d93 1
a93 1
+# $tgId: obsd.util,v 3.32 2002/12/03 15:46:56 tg Exp $ Public domain.
d108 2
a109 2
--- /dev/null	Tue Dec  3 15:15:33 2002
+++ src/games/brainfuck/brainfuck	Tue Dec  3 15:31:08 2002
d122 2
a123 2
--- /dev/null	Tue Dec  3 15:15:33 2002
+++ src/games/brainfuck/brainfuck.6	Tue Dec  3 15:31:08 2002
d125 1
a125 1
+.\"	$tgId: obsd.util,v 3.32 2002/12/03 15:46:56 tg Exp $
d206 2
a207 2
--- /dev/null	Tue Dec  3 15:15:33 2002
+++ src/games/ndat/Makefile	Tue Dec  3 15:31:08 2002
d209 1
a209 1
+# $tgId: obsd.util,v 3.32 2002/12/03 15:46:56 tg Exp $ Public domain.
d219 2
a220 2
--- /dev/null	Tue Dec  3 15:15:33 2002
+++ src/games/ndat/ndat.c	Tue Dec  3 15:31:08 2002
d222 1
a222 1
+/* $tgId: obsd.util,v 3.32 2002/12/03 15:46:56 tg Exp $
d246 1
a246 1
+static const char RCSId[]="$tgId: obsd.util,v 3.32 2002/12/03 15:46:56 tg Exp $";
d486 2
a487 2
--- /dev/null	Tue Dec  3 15:15:33 2002
+++ src/games/wtf/Makefile	Tue Dec  3 15:31:08 2002
d489 1
a489 1
+# $tgId: obsd.util,v 3.32 2002/12/03 15:46:56 tg Exp $ Public domain.
d504 2
a505 2
--- /dev/null	Tue Dec  3 15:15:33 2002
+++ src/games/wtf/wtf	Tue Dec  3 15:31:08 2002
d508 1
a508 1
+#	$tgId: obsd.util,v 3.32 2002/12/03 15:46:56 tg Exp $
d546 2
a547 2
--- /dev/null	Tue Dec  3 15:15:33 2002
+++ src/games/wtf/wtf.6	Tue Dec  3 15:31:08 2002
d549 1
a549 1
+.\"	$OpenBSD$ $tgId: obsd.util,v 3.32 2002/12/03 15:46:56 tg Exp $
d610 2
a611 2
--- /dev/null	Tue Dec  3 15:15:33 2002
+++ src/gnu/usr.bin/dict/Makefile	Tue Dec  3 15:31:09 2002
d613 1
a613 1
+# $tgId: obsd.util,v 3.32 2002/12/03 15:46:56 tg Exp $ Public domain.
d641 2
a642 2
--- /dev/null	Tue Dec  3 15:15:33 2002
+++ src/gnu/usr.bin/dict/dict	Tue Dec  3 15:31:09 2002
d650 1
a650 1
+# Revised: $Date: 2002/12/03 15:46:56 $ by x86@@ePost.de
d1423 2
a1424 2
--- /dev/null	Tue Dec  3 15:15:33 2002
+++ src/gnu/usr.bin/tinyirc/Makefile	Tue Dec  3 15:31:09 2002
d1426 1
a1426 1
+# $tgId: obsd.util,v 3.32 2002/12/03 15:46:56 tg Exp $ Public domain.
d1437 2
a1438 2
--- /dev/null	Tue Dec  3 15:15:33 2002
+++ src/gnu/usr.bin/tinyirc/tinyirc.c	Tue Dec  3 15:31:09 2002
d1449 1
a1449 1
+/* tinyirc 1.0		$tgId: obsd.util,v 3.32 2002/12/03 15:46:56 tg Exp $
d2255 2
a2256 2
--- /dev/null	Tue Dec  3 15:15:33 2002
+++ src/share/misc/acronyms	Tue Dec  3 15:31:09 2002
d2258 1
a2258 1
+$tgId: obsd.util,v 3.32 2002/12/03 15:46:56 tg Exp $
@

