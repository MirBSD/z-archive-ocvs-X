head	1.3;
access;
symbols
	tg-mergetmp-2:1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.03.02.20.10.40;	author tg;	state Stab;
branches;
next	1.2;

1.2
date	2004.01.31.02.17.23;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.19.59.29;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.19.59.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.17.25;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.20.59;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.01.45;	author tg;	state Exp;
branches;
next	;


desc
@@


1.3
log
@semi-automatic merge and whitespace adjustment of OpenBSD XF4 subtree
@
text
@/***************************************************************************
 *                                                                         *
 *                                Porting Note                             *
 *                                                                         *
 * Add the value of BOOTSTRAPCFLAGS to the cpp_argv table so that it will  *
 * be passed to the template file.                                         *
 *                                                                         *
 ***************************************************************************/
/* $MirBSD: imake.c,v 1.2 2004/01/31 02:17:23 tg Exp $ */
/* $XFree86: xc/config/imake/imake.c,v 3.64 2003/03/26 20:43:47 tsi Exp $ */

/*
 *
Copyright (c) 1985, 1986, 1987, 1998 The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.
 *
 * Original Author:
 *	Todd Brunhoff
 *	Tektronix, inc.
 *	While a guest engineer at Project Athena, MIT
 *
 * imake: the include-make program.
 *
 * Usage: imake [-Idir] [-Ddefine] [-T template] [-f imakefile ] [-C Imakefile.c ] [-s] [-e] [-v] [make flags]
 *
 * Imake takes a template file (Imake.tmpl) and a prototype (Imakefile)
 * and runs cpp on them producing a Makefile.  It then optionally runs make
 * on the Makefile.
 * Options:
 *		-D	define.  Same as cpp -D argument.
 *		-U	undefine.  Same as cpp -U argument.
 *		-W	warning.  Same as cpp -W argument.
 *		-I	Include directory.  Same as cpp -I argument.
 *		-T	template.  Designate a template other
 *			than Imake.tmpl
 *		-f	specify the Imakefile file
 *		-C	specify the name to use instead of Imakefile.c
 *		-s[F]	show.  Show the produced makefile on the standard
 *			output.  Make is not run is this case.  If a file
 *			argument is provided, the output is placed there.
 *		-e[F]	execute instead of show; optionally name Makefile F
 *		-v	verbose.  Show the make command line executed.
 *
 * Environment variables:
 *
 *		IMAKEINCLUDE	Include directory to use in addition to "."
 *		IMAKECPP	Cpp to use instead of /lib/cpp
 *		IMAKEMAKE	make program to use other than what is
 *				found by searching the $PATH variable.
 * Other features:
 *	imake reads the entire cpp output into memory and then scans it
 *	for occurences of "@@@@".  If it encounters them, it replaces it with
 *	a newline.  It also trims any trailing white space on output lines
 *	(because make gets upset at them).  This helps when cpp expands
 *	multi-line macros but you want them to appear on multiple lines.
 *	It also changes occurences of "XCOMM" to "#", to avoid problems
 *	with treating commands as invalid preprocessor commands.
 *
 *	The macros MAKEFILE and MAKE are provided as macros
 *	to make.  MAKEFILE is set to imake's makefile (not the constructed,
 *	preprocessed one) and MAKE is set to argv[0], i.e. the name of
 *	the imake program.
 *
 * Theory of operation:
 *   1. Determine the name of the imakefile from the command line (-f)
 *	or from the content of the current directory (Imakefile or imakefile).
 *	Call this <imakefile>.  This gets added to the arguments for
 *	make as MAKEFILE=<imakefile>.
 *   2. Determine the name of the template from the command line (-T)
 *	or the default, Imake.tmpl.  Call this <template>
 *   3. Determine the name of the imakeCfile from the command line (-C)
 *	or the default, Imakefile.c.  Call this <imakeCfile>
 *   4. Store lines of input into <imakeCfile>:
 *	- A c-style comment header (see ImakefileCHeader below), used
 *	  to recognize temporary files generated by imake.
 *	- If DEFAULT_OS_NAME is defined, format the utsname struct and
 *	  call the result <defaultOsName>.  Add:
 *		#define DefaultOSName <defaultOsName>
 *	- If DEFAULT_OS_MAJOR_REV is defined, format the utsname struct
 *	  and call the result <defaultOsMajorVersion>.  Add:
 *		#define DefaultOSMajorVersion <defaultOsMajorVersion>
 *	- If DEFAULT_OS_MINOR_REV is defined, format the utsname struct
 *	  and call the result <defaultOsMinorVersion>.  Add:
 *		#define DefaultOSMinorVersion <defaultOsMinorVersion>
 *	- If DEFAULT_OS_TEENY_REV is defined, format the utsname struct
 *	  and call the result <defaultOsTeenyVersion>.  Add:
 *		#define DefaultOSTeenyVersion <defaultOsTeenyVersion>
 *	- If DEFAULT_MACHINE_ARCITECTURE is defined, format the utsname struct
 *	  and define the corresponding macro.  (For example on the amiga,
 *	  this will define amiga in addition to m68k).
 *	- If the file "localdefines" is readable in the current
 *	  directory, print a warning message to stderr and add:
 *		#define IMAKE_LOCAL_DEFINES	"localdefines"
 *		#include IMAKE_LOCAL_DEFINES
 *	- If the file "admindefines" is readable in the current
 *	  directory, print a warning message to stderr and add:
 *		#define IMAKE_ADMIN_DEFINES	"admindefines"
 *		#include IMAKE_ADMIN_DEFINES
 *	- The following lines:
 *		#define INCLUDE_IMAKEFILE	< <imakefile> >
 *		#define IMAKE_TEMPLATE		" <template> "
 *		#include IMAKE_TEMPLATE
 *	- If the file "adminmacros" is readable in the current
 *	  directory, print a warning message to stderr and add:
 *		#define IMAKE_ADMIN_MACROS	"adminmacros"
 *		#include IMAKE_ADMIN_MACROS
 *	- If the file "localmacros" is readable in the current
 *	  directory, print a warning message to stderr and add:
 *		#define IMAKE_LOCAL_MACROS	"localmacros"
 *		#include IMAKE_LOCAL_MACROS
 *   5. Start up cpp and provide it with this file.
 *	Note that the define for INCLUDE_IMAKEFILE is intended for
 *	use in the template file.  This implies that the imake is
 *	useless unless the template file contains at least the line
 *		#include INCLUDE_IMAKEFILE
 *   6. Gather the output from cpp, and clean it up, expanding @@@@ to
 *	newlines, stripping trailing white space, cpp control lines,
 *	and extra blank lines, and changing XCOMM to #.  This cleaned
 *	output is placed in a new file, default "Makefile", but can
 *	be specified with -s or -e options.
 *   7. Optionally start up make on the resulting file.
 *
 * The design of the template makefile should therefore be:
 *	<set global macros like CFLAGS, etc.>
 *	<include machine dependent additions>
 *	#include INCLUDE_IMAKEFILE
 *	<add any global targets like 'clean' and long dependencies>
 */
#if defined(__FreeBSD__) || defined(__NetBSD__)
/* This needs to be before _POSIX_SOURCE gets defined */
# include <sys/param.h>
# include <sys/types.h>
# include <sys/sysctl.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include "Xosdefs.h"
#include <string.h>
#include <ctype.h>
#ifdef WIN32
# include "Xw32defs.h"
#endif
#if 0
#ifndef X_NOT_POSIX
# ifndef _POSIX_SOURCE
#  define _POSIX_SOURCE
# endif
#endif
#endif
#include <sys/types.h>
#include <fcntl.h>
#ifdef X_NOT_POSIX
# ifndef WIN32
#  include <sys/file.h>
# endif
#else
# include <unistd.h>
#endif
#ifdef ISC
# include <unistd.h>
#endif
#if defined(X_NOT_POSIX) || defined(_POSIX_SOURCE)
# include <signal.h>
#else
# define _POSIX_SOURCE
# include <signal.h>
# undef _POSIX_SOURCE
#endif
#if !defined(SIGCHLD) && defined(SIGCLD)
# define SIGCHLD		SIGCLD
#endif
#include <sys/stat.h>
#ifndef X_NOT_POSIX
# ifdef _POSIX_SOURCE
#  ifdef SCO325
#   include <sys/procset.h>
#   include <sys/siginfo.h>
#  endif
#  include <sys/wait.h>
# else
#  define _POSIX_SOURCE
#  include <sys/wait.h>
#  undef _POSIX_SOURCE
# endif
# define waitCode(w)	WEXITSTATUS(w)
# define waitSig(w)	WTERMSIG(w)
typedef int		waitType;
#else /* X_NOT_POSIX */
# ifdef SYSV
#  define waitCode(w)	(((w) >> 8) & 0x7f)
#  define waitSig(w)	((w) & 0xff)
typedef int		waitType;
# else /* SYSV */
#  ifdef WIN32
#   include <process.h>
typedef int		waitType;
#  else
#   include <sys/wait.h>
#   define waitCode(w)	((w).w_T.w_Retcode)
#   define waitSig(w)	((w).w_T.w_Termsig)
typedef union wait	waitType;
#  endif
# endif
# ifndef WIFSIGNALED
#  define WIFSIGNALED(w) waitSig(w)
# endif
# ifndef WIFEXITED
#  define WIFEXITED(w) waitCode(w)
# endif
#endif /* X_NOT_POSIX */
# include <stdlib.h>
#if defined(macII) && !defined(__STDC__)  /* stdlib.h fails to define these */
char *malloc(), *realloc();
#endif /* macII */
#include <errno.h>
#ifdef __minix_vmd
#define USE_FREOPEN		1
#endif

#if !((defined(sun) && !defined(SVR4)) || defined(macII))
#define USE_STRERROR		1
#endif
#ifndef WIN32
#include <sys/utsname.h>
#else
#include <windows.h>
#endif
#ifndef SYS_NMLN
# ifdef _SYS_NMLN
#  define SYS_NMLN _SYS_NMLN
# else
#  define SYS_NMLN 257
# endif
#endif
#if defined(linux) || defined(__GNU__)
#include <limits.h>
#include <stdio.h>
#endif
#ifdef __QNX__
#include <unix.h>
#endif

/*
 * This define of strerror is copied from (and should be identical to)
 * Xos.h, which we don't want to include here for bootstrapping reasons.
 */
#ifndef USE_STRERROR
# ifndef strerror
extern char *sys_errlist[];
extern int sys_nerr;
#  define strerror(n) \
    (((n) >= 0 && (n) < sys_nerr) ? sys_errlist[n] : "unknown error")
# endif
#endif

#if defined(__NetBSD__)		/* see code clock in init() below */
#include <sys/utsname.h>
#endif

#if !(defined(Lynx) || defined(__Lynx__) || (defined(SVR4) && !defined(sun))) && !defined (__CYGWIN__)
#define HAS_MKSTEMP
#endif

typedef unsigned char boolean;
#define TRUE		1
#define FALSE		0

# include "imakemdep.h"
#ifdef CROSSCOMPILE
# include "imakemdep_cpp.h"
#endif

#if defined CROSSCOMPILE || defined FIXUP_CPP_WHITESPACE
int InRule = FALSE;
#endif
#if defined CROSSCOMPILE || defined INLINE_SYNTAX
int InInline = 0;
#endif
#if defined CROSSCOMPILE || defined MAGIC_MAKE_VARS
int xvariable = 0;
int xvariables[10];
#endif

#ifndef PATH_MAX
#define PATH_MAX 1024
#endif

/*
 * Some versions of cpp reduce all tabs in macro expansion to a single
 * space.  In addition, the escaped newline may be replaced with a
 * space instead of being deleted.  Blech.
 */
void KludgeOutputLine(char **), KludgeResetRule(void);

#ifndef CROSSCOMPILE
# ifdef USE_CC_E
#  ifndef DEFAULT_CC
#   define DEFAULT_CC "cc"
#  endif
# else
#  ifndef DEFAULT_CPP
#   ifdef CPP_PROGRAM
#    define DEFAULT_CPP CPP_PROGRAM
#   else
#    define DEFAULT_CPP "/lib/cpp"
#   endif
#  endif
# endif
#endif

char *cpp = NULL;

char	*tmpMakefile = "/tmp/Imf.XXXXXX";
char	*tmpImakefile = "/tmp/IIf.XXXXXX";
char	*make_argv[ ARGUMENTS ] = {
#ifdef WIN32
    "nmake"
#else
    "make"
#endif
};

int	make_argindex;
int	cpp_argindex;
char	*Imakefile = NULL;
char	*Makefile = "Makefile";
char	*Template = "Imake.tmpl";
char	*ImakefileC = "Imakefile.c";
boolean haveImakefileC = FALSE;
char	*cleanedImakefile = NULL;
char	*program;
char	*FindImakefile(char *Imakefile);
char	*ReadLine(FILE *tmpfd, char *tmpfname);
char	*CleanCppInput(char *imakefile);
char	*Strdup(char *cp);
char	*Emalloc(int size);
void	LogFatalI(char *s, int i), LogFatal(char *x0, char *x1),
	LogMsg(char *x0, char *x1);

void	showit(FILE *fd);
void	wrapup(void);
void	init(void);
void	AddMakeArg(char *arg);
void	AddCppArg(char *arg);
#ifdef CROSSCOMPILE
char	*CrossCompileCPP(void);
#endif
void	SetOpts(int argc, char **argv);
void	CheckImakefileC(char *masterc);
void	cppit(char *imakefile, char *template, char *masterc,
	      FILE *outfd, char *outfname);
void	makeit(void);
void	CleanCppOutput(FILE *tmpfd, char *tmpfname);
boolean isempty(char *line);
void	writetmpfile(FILE *fd, char *buf, int cnt, char *fname);
#ifdef SIGNALRETURNSINT
int	catch(int sig);
#else
void	catch(int sig);
#endif
void	showargs(char **argv);
boolean optional_include(FILE *inFile, char *defsym, char *fname);
void	  doit(FILE *outfd, char *cmd, char **argv);
boolean define_os_defaults(FILE *inFile);
#ifdef CROSSCOMPILE
static void get_cross_compile_dir(FILE *inFile);
#endif
#ifdef CROSSCOMPILEDIR
char *CrossCompileDir = CROSSCOMPILEDIR;
#else
char *CrossCompileDir = "";
#endif
boolean CrossCompiling = FALSE;



boolean verbose = FALSE;
boolean show = TRUE;

int
main(int argc, char *argv[])
{
	FILE	*tmpfd = NULL;
	char	makeMacro[ BUFSIZ ];
	char	makefileMacro[ BUFSIZ ];
	int	lenCrossCompileDir = 0;

	program = argv[0];
	init();

	lenCrossCompileDir = strlen(CrossCompileDir);
	if (lenCrossCompileDir) {
	    if (lenCrossCompileDir > (PATH_MAX - 20))
	      LogFatal("Cross compile directory path too long %s\n",
		       CrossCompileDir);
	    else
		CrossCompiling = TRUE;
	}

	SetOpts(argc, argv);
	Imakefile = FindImakefile(Imakefile);
	CheckImakefileC(ImakefileC);
	if (Makefile) {
		tmpMakefile = Makefile;
		if ((tmpfd = fopen(tmpMakefile, "w+")) == NULL)
		   LogFatal("Cannot create temporary file %s.", tmpMakefile);
	} else {
#ifdef HAS_MKSTEMP
		int fd;
#endif
		tmpMakefile = Strdup(tmpMakefile);
#ifndef HAS_MKSTEMP
		if (mktemp(tmpMakefile) == NULL ||
		    (tmpfd = fopen(tmpMakefile, "w+")) == NULL) {
		   LogFatal("Cannot create temporary file %s.", tmpMakefile);
		}
#else
		fd = mkstemp(tmpMakefile);
		if (fd == -1 || (tmpfd = fdopen(fd, "w+")) == NULL) {
		   if (fd != -1) {
		      unlink(tmpMakefile); close(fd);
		   }
		   LogFatal("Cannot create temporary file %s.", tmpMakefile);
		}
#endif
	}
	AddMakeArg("-f");
	AddMakeArg( tmpMakefile );
	sprintf(makeMacro, "MAKE=%s", program);
	AddMakeArg( makeMacro );
	sprintf(makefileMacro, "MAKEFILE=%s", Imakefile);
	AddMakeArg( makefileMacro );

	cleanedImakefile = CleanCppInput(Imakefile);
	cppit(cleanedImakefile, Template, ImakefileC, tmpfd, tmpMakefile);

	if (show) {
		if (Makefile == NULL)
			showit(tmpfd);
	} else
		makeit();
	wrapup();
	exit(0);
}

void
showit(FILE *fd)
{
	char	buf[ BUFSIZ ];
	int	red;

	fseek(fd, 0, 0);
	while ((red = fread(buf, 1, BUFSIZ, fd)) > 0)
		writetmpfile(stdout, buf, red, "stdout");
	if (red < 0)
	    LogFatal("Cannot read %s.", tmpMakefile);
}

void
wrapup(void)
{
	if (tmpMakefile != Makefile)
		unlink(tmpMakefile);
	if (cleanedImakefile && cleanedImakefile != Imakefile)
		unlink(cleanedImakefile);
	if (haveImakefileC)
		unlink(ImakefileC);
}

#ifdef SIGNALRETURNSINT
int
#else
void
#endif
catch(int sig)
{
	errno = 0;
	LogFatalI("Signal %d.", sig);
}

/*
 * Initialize some variables.
 */
void
init(void)
{
	register char	*p;

	make_argindex=0;
	while (make_argv[ make_argindex ] != NULL)
		make_argindex++;
	cpp_argindex = 0;
	while (cpp_argv[ cpp_argindex ] != NULL)
		cpp_argindex++;

#if defined CROSSCOMPILE
	if (sys == netBSD)
	  if (CrossCompiling) {
	    LogFatal("fix imake to do crosscompiling for NetBSD\n","");
	  } else
#endif
#if defined(__NetBSD__) || defined CROSSCOMPILE
	{
		struct utsname uts;
		static char argument[512];

		/*
		 * Sharable imake configurations require a
		 * machine identifier.
		 */
		if (uname(&uts) != 0)
			LogFatal("uname(3) failed; can't tell what %s",
			    "kind of machine you have.");

		memset(argument, 0, sizeof(argument));
		(void)snprintf(argument, sizeof(argument) - 1,
		    "-D__%s__", uts.machine);

		AddCppArg(argument);
	}
#endif /* __NetBSD__ */

	/*
	 * See if the standard include directory is different than
	 * the default.  Or if cpp is not the default.  Or if the make
	 * found by the PATH variable is not the default.
	 */
	if ((p = getenv("IMAKEINCLUDE"))) {
		if (*p != '-' || *(p+1) != 'I')
			LogFatal("Environment var IMAKEINCLUDE %s",
				"must begin with -I");
		AddCppArg(p);
		for (; *p; p++)
			if (*p == ' ') {
				*p++ = '\0';
				AddCppArg(p);
			}
	}
	if ((p = getenv("IMAKECPP")))
		cpp = p;
	if ((p = getenv("IMAKEMAKE")))
		make_argv[0] = p;

	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		signal(SIGINT, catch);
#ifdef SIGCHLD
	signal(SIGCHLD, SIG_DFL);
#endif
}

void
AddMakeArg(char *arg)
{
	errno = 0;
	if (make_argindex >= ARGUMENTS-1)
		LogFatal("Out of internal storage.", "");
	make_argv[ make_argindex++ ] = arg;
	make_argv[ make_argindex ] = NULL;
}

void
AddCppArg(char *arg)
{
	errno = 0;
	if (cpp_argindex >= ARGUMENTS-1)
		LogFatal("Out of internal storage.", "");
	cpp_argv[ cpp_argindex++ ] = arg;
	cpp_argv[ cpp_argindex ] = NULL;
}

void
SetOpts(int argc, char **argv)
{

	errno = 0;
	/*
	 * Now gather the arguments for make
	 */
	for(argc--, argv++; argc; argc--, argv++) {
	    /*
	     * We intercept these flags.
	     */
	    if (argv[0][0] == '-') {
		if (argv[0][1] == 'D') {
		    AddCppArg(argv[0]);
		} else if (argv[0][1] == 'I') {
		    AddCppArg(argv[0]);
		} else if (argv[0][1] == 'U') {
		    AddCppArg(argv[0]);
		} else if (argv[0][1] == 'W') {
		    AddCppArg(argv[0]);
		} else if (argv[0][1] == 'f') {
		    if (argv[0][2])
			Imakefile = argv[0]+2;
		    else {
			argc--, argv++;
			if (! argc)
			    LogFatal("No description arg after -f flag", "");
			Imakefile = argv[0];
		    }
		} else if (argv[0][1] == 's') {
		    if (argv[0][2])
			Makefile = ((argv[0][2] == '-') && !argv[0][3]) ?
			    NULL : argv[0]+2;
		    else {
			argc--, argv++;
			if (!argc)
			    LogFatal("No description arg after -s flag", "");
			Makefile = ((argv[0][0] == '-') && !argv[0][1]) ?
			    NULL : argv[0];
		    }
		    show = TRUE;
		} else if (argv[0][1] == 'e') {
		   Makefile = (argv[0][2] ? argv[0]+2 : NULL);
		   show = FALSE;
		} else if (argv[0][1] == 'T') {
		    if (argv[0][2])
			Template = argv[0]+2;
		    else {
			argc--, argv++;
			if (! argc)
			    LogFatal("No description arg after -T flag", "");
			Template = argv[0];
		    }
		} else if (argv[0][1] == 'C') {
		    if (argv[0][2])
			ImakefileC = argv[0]+2;
		    else {
			argc--, argv++;
			if (! argc)
			    LogFatal("No imakeCfile arg after -C flag", "");
			ImakefileC = argv[0];
		    }
		} else if (argv[0][1] == 'v') {
		    verbose = TRUE;
		} else
		    AddMakeArg(argv[0]);
	    } else
		AddMakeArg(argv[0]);
	}

#ifndef CROSSCOMPILE
# ifdef USE_CC_E
	    if (!cpp)
	    {
		AddCppArg("-E");
#ifdef __GNUC__
		if (verbose)
		    AddCppArg("-v");
#endif
		cpp = DEFAULT_CC;
	    }
# else
	    if (!cpp)
		cpp = DEFAULT_CPP;
# endif
#else
	    if (!cpp)
		cpp = CrossCompileCPP();
#endif

	cpp_argv[0] = cpp;
	AddCppArg(ImakefileC);
}

char *
FindImakefile(char *Imakefile)
{
	if (Imakefile) {
		if (access(Imakefile, R_OK) < 0)
			LogFatal("Cannot find %s.", Imakefile);
	} else {
		if (access("Imakefile", R_OK) < 0) {
			if (access("imakefile", R_OK) < 0)
				LogFatal("No description file.", "");
			else
				Imakefile = "imakefile";
		} else
			Imakefile = "Imakefile";
	}
	return(Imakefile);
}

void
LogFatalI(char *s, int i)
{
	/*NOSTRICT*/
	LogFatal(s, (char *)(long)i);
}

void
LogFatal(char *x0, char *x1)
{
	static boolean entered = FALSE;

	if (entered)
		return;
	entered = TRUE;

	LogMsg(x0, x1);
	fprintf(stderr, "  Stop.\n");
	wrapup();
	exit(1);
}

void
LogMsg(char *x0, char *x1)
{
	int error_number = errno;

	if (error_number) {
		fprintf(stderr, "%s: ", program);
		fprintf(stderr, "%s\n", strerror(error_number));
	}
	fprintf(stderr, "%s: ", program);
	fprintf(stderr, x0, x1);
	fprintf(stderr, "\n");
}

void
showargs(char **argv)
{
	for (; *argv; argv++)
		fprintf(stderr, "%s ", *argv);
	fprintf(stderr, "\n");
}

#define ImakefileCHeader "/* imake - temporary file */"

void
CheckImakefileC(char *masterc)
{
	char mkcbuf[1024];
	FILE *inFile;

	if (access(masterc, F_OK) == 0) {
		inFile = fopen(masterc, "r");
		if (inFile == NULL)
			LogFatal("Refuse to overwrite: %s", masterc);
		if ((fgets(mkcbuf, sizeof(mkcbuf), inFile) &&
		     strncmp(mkcbuf, ImakefileCHeader,
			     sizeof(ImakefileCHeader)-1)))
		{
			fclose(inFile);
			LogFatal("Refuse to overwrite: %s", masterc);
		}
		fclose(inFile);
	}
}

#define LocalDefineFmt	"#define %s \"%s\"\n"
#define IncludeFmt	"#include %s\n"
#define ImakeDefSym	"INCLUDE_IMAKEFILE"
#define ImakeTmplSym	"IMAKE_TEMPLATE"
#define OverrideWarning "Warning: local file \"%s\" overrides global macros."

boolean
optional_include(FILE *inFile, char *defsym, char *fname)
{
	errno = 0;
	if (access(fname, R_OK) == 0) {
		LogMsg(OverrideWarning, fname);
		return (fprintf(inFile, LocalDefineFmt, defsym, fname) < 0 ||
			fprintf(inFile, IncludeFmt, defsym) < 0);
	}
	return FALSE;
}

void
doit(FILE *outfd, char *cmd, char **argv)
{
	int		pid;
	waitType	status;

	/*
	 * Fork and exec the command.
	 */
#ifdef WIN32
	if (outfd)
		dup2(fileno(outfd), 1);
	status = _spawnvp(_P_WAIT, cmd, argv);
	if (status < 0)
		LogFatal("Cannot spawn %s.", cmd);
	if (status > 0)
		LogFatalI("Exit code %d.", status);
#else
	pid = fork();
	if (pid < 0)
		LogFatal("Cannot fork.", "");
	if (pid) {	/* parent... simply wait */
		while (wait(&status) > 0) {
			errno = 0;
			if (WIFSIGNALED(status))
				LogFatalI("Signal %d.", waitSig(status));
			if (WIFEXITED(status) && waitCode(status))
				LogFatalI("Exit code %d.", waitCode(status));
		}
	}
	else {	/* child... dup and exec cmd */
		if (verbose)
			showargs(argv);
		if (outfd)
			dup2(fileno(outfd), 1);
		execvp(cmd, argv);
		LogFatal("Cannot exec %s.", cmd);
	}
#endif
}

#if !defined WIN32
static void
parse_utsname(struct utsname *name, char *fmt, char *result, char *msg)
{
  char buf[SYS_NMLN * 5 + 1];
  char *ptr = buf;
  int arg;

  if (!name)
      LogFatal(msg,fmt);

  /* Assemble all the pieces into a buffer. */
  for (arg = 0; fmt[arg] != ' '; arg++)
    {
      /* Our buffer is only guaranteed to hold 5 arguments. */
      if (arg >= 5)
	LogFatal(msg, fmt);

      switch (fmt[arg])
	{
	case 's':
	  if (arg > 0)
	    *ptr++ = ' ';
	  strcpy(ptr, name->sysname);
	  ptr += strlen(ptr);
	  break;

	case 'n':
	  if (arg > 0)
	    *ptr++ = ' ';
	  strcpy(ptr, name->nodename);
	  ptr += strlen(ptr);
	  break;

	case 'r':
	  if (arg > 0)
	    *ptr++ = ' ';
	  strcpy(ptr, name->release);
	  ptr += strlen(ptr);
	  break;

	case 'v':
	  if (arg > 0)
	    *ptr++ = ' ';
	  strcpy(ptr, name->version);
	  ptr += strlen(ptr);
	  break;

	case 'm':
	  if (arg > 0)
	    *ptr++ = ' ';
	  strcpy(ptr, name->machine);
	  ptr += strlen(ptr);
	  break;

#ifdef	__MirBSD__
	case 'l':
	  if (arg > 0)
	    *ptr++ = ' ';
	  strcpy(ptr, name->patchlevel);
	  ptr += strlen(ptr);
	  break;
#endif

	default:
	  LogFatal(msg, fmt);
	}
    }

  /* Just in case... */
  if (strlen(buf) >= sizeof(buf))
    LogFatal("Buffer overflow parsing uname.", "");

  /* Parse the buffer.  The sscanf() return value is rarely correct. */
  *result = '\0';
  (void) sscanf(buf, fmt + arg + 1, result);
}

/* Trim leading 0's and periods from version names.  The 0's cause
   the number to be interpreted as octal numbers.  Some version strings
   have the potential for different numbers of .'s in them.
 */

static char *
trim_version(char *p)
{

	if (p != 0 && *p != '\0')
	{
		while ((*p == '0' || *p == '.') && *(p + 1) != '\0')
			++p;
	}
	return (p);
}
#endif

#if defined linux
const char *libc_c=
"#include <stdio.h>\n"
"#include <ctype.h>\n"
"\n"
"#if 1\n"
"#pragma weak gnu_get_libc_version\n"
"#pragma weak __libc_version\n"
"#pragma weak __linux_C_lib_version\n"
"#endif\n"
"\n"
"extern const char * gnu_get_libc_version (void);\n"
"extern const char * __linux_C_lib_version;\n"
"extern const char __libc_version [];\n"
"\n"
"int\n"
"main ()\n"
"{\n"
"  int libcmajor = 0, libcminor = 0, libcteeny = 0;\n"
"  const char * ptr = NULL;\n"
"  int glibcmajor = 0;\n"
"\n"
"  if (gnu_get_libc_version != 0)\n"
"  {\n"
"    ptr = gnu_get_libc_version ();\n"
"    glibcmajor = 4;\n"
"  }\n"
"  else if (&__libc_version != 0)\n"
"  {\n"
"    ptr = __libc_version;\n"
"    glibcmajor = 4;\n"
"  }\n"
"  else if (&__linux_C_lib_version != 0)\n"
"  {\n"
"    ptr = __linux_C_lib_version;\n"
"  }\n"
"  else\n"
"  {\n"
"    libcmajor = 0; libcminor = 0; libcteeny = 0;\n"
"  }\n"
"\n"
"  if (ptr)\n"
"  {\n"
"    while (!isdigit (*ptr))\n"
"      ptr++;\n"
"\n"
"    sscanf (ptr, \"%d.%d.%d\", &libcmajor, &libcminor, &libcteeny);\n"
"    libcmajor += glibcmajor;\n"
"  }\n"
"\n"
"  printf(\"#define DefaultLinuxCLibMajorVersion %d\\n\", libcmajor);\n"
"  printf(\"#define DefaultLinuxCLibMinorVersion %d\\n\", libcminor);\n"
"  printf(\"#define DefaultLinuxCLibTeenyVersion %d\\n\", libcteeny);\n"
"\n"
"  return 0;\n"
"}\n"
;

static void
get_libc_version(FILE *inFile)
{
  char aout[] = "/tmp/imakeXXXXXX";
  FILE *fp;
  const char *format = "%s -o %s -x c -";
  char *cc;
  int len;
  char *command;

  /* Pre-create temp file safely */
  {
    /* Linux + ELF has mkstemp() */
    int tmpfd;
    if ((tmpfd = mkstemp(aout)) == -1) {
      perror("mkstemp");
      abort();
    }
    close(tmpfd);
  }
  cc = getenv ("CC");
  if (cc == NULL)
    cc = "gcc";
  len = strlen (aout) + strlen (format) + strlen (cc);
  if (len < 128) len = 128;
  command = alloca (len);

  if (snprintf (command , len, format, cc, aout) == len)
    abort ();

  fp = popen (command, "w");
  if (fp == NULL || fprintf (fp, "%s\n", libc_c) < 0
      || pclose (fp) != 0)
    abort ();

  fp = popen (aout, "r");
  if (fp == NULL)
    abort ();

  while (fgets (command, len, fp))
    fprintf (inFile, command);

  len = pclose (fp);
  remove (aout);
  if (len)
    abort ();
}
#endif

#if defined(__OpenBSD__)
static void
get_stackprotector(FILE *inFile)
{
  FILE *fp;
  char *cc;
  char command[1024], buf[1024];

  cc = getenv("CC");
  if (cc == NULL) {
    cc = "cc";
  }
  snprintf(command, sizeof(command), "%s -v 2>&1", cc);
  fp = popen(command, "r");
  if (fp == NULL)
    abort();
  while (fgets(buf, sizeof(buf), fp)) {
    if (strstr(buf, "propolice") != NULL) {
      fprintf(inFile, "#define HasGccStackProtector YES\n");
      break;
    }
  }
  if (pclose(fp))
    abort();
}
#endif


#if defined CROSSCOMPILE || defined linux
static void
get_distrib(FILE *inFile)
{
  struct stat sb;

  static char* suse = "/etc/SuSE-release";
  static char* redhat = "/etc/redhat-release";
  static char* debian = "/etc/debian_version";

  fprintf (inFile, "%s\n", "#define LinuxUnknown    0");
  fprintf (inFile, "%s\n", "#define LinuxSuSE       1");
  fprintf (inFile, "%s\n", "#define LinuxCaldera    2");
  fprintf (inFile, "%s\n", "#define LinuxCraftworks 3");
  fprintf (inFile, "%s\n", "#define LinuxDebian     4");
  fprintf (inFile, "%s\n", "#define LinuxInfoMagic  5");
  fprintf (inFile, "%s\n", "#define LinuxKheops     6");
  fprintf (inFile, "%s\n", "#define LinuxPro        7");
  fprintf (inFile, "%s\n", "#define LinuxRedHat     8");
  fprintf (inFile, "%s\n", "#define LinuxSlackware  9");
  fprintf (inFile, "%s\n", "#define LinuxTurbo      10");
  fprintf (inFile, "%s\n", "#define LinuxWare       11");
  fprintf (inFile, "%s\n", "#define LinuxYggdrasil  12");

#ifdef CROSSCOMPILE
  if (CrossCompiling) {
      fprintf (inFile, "%s\n",
	       "#define DefaultLinuxDistribution LinuxUnknown");
      fprintf (inFile, "%s\n", "#define DefaultLinuxDistName Unknown");
      return;
  }
#endif
  if (lstat (suse, &sb) == 0) {
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxSuSE");
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistName SuSE");
    return;
  }
  if (lstat (redhat, &sb) == 0) {
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxRedHat");
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistName RedHat");
    return;
  }
  if (lstat (debian, &sb) == 0) {
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxDebian");
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistName Debian");
    /* You could also try to get the version of the Debian distrib by looking
     * at the content of /etc/debian_version */
    return;
  }
  /* what's the definitive way to tell what any particular distribution is? */

  fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxUnknown");
  fprintf (inFile, "%s\n", "#define DefaultLinuxDistName Unknown");
  /* would like to know what version of the distribution it is */
}

static void
get_ld_version(FILE *inFile)
{
  FILE* ldprog;
  signed char c;
  int ldmajor, ldminor;
  const char *ld = "ld -v";

#ifdef CROSSCOMPILE
  if (CrossCompiling) {
      char cmd[PATH_MAX];
      strcpy (cmd, CrossCompileDir);
      strcat (cmd,"/");
      strcat (cmd,ld);
      ldprog = popen (cmd, "r");
  } else
#endif
      ldprog = popen (ld, "r");

  if (ldprog) {
    do {
      c = fgetc (ldprog);
    } while (c != EOF && !isdigit (c));
    ungetc (c, ldprog);
    (void) fscanf (ldprog, "%d.%d", &ldmajor, &ldminor);
    /* Start conversion to a more rational number */
    if ((ldmajor > 2) || ((ldmajor == 2) && (ldminor > 9)))
	ldmajor *= 100;
    else
	ldmajor *= 10;

    fprintf(inFile, "#define DefaultLinuxBinUtilsMajorVersion %d\n",
	    ldmajor + ldminor);
    pclose (ldprog);
  }
}
#endif

#if defined __FreeBSD__
static void
get_binary_format(FILE *inFile)
{
  int mib[2];
  size_t len;
  int osrel = 0;
  FILE *objprog = NULL;
  int iself = 0;
  char buf[10];
  char cmd[PATH_MAX];

  mib[0] = CTL_KERN;
  mib[1] = KERN_OSRELDATE;
  len = sizeof(osrel);
  sysctl(mib, 2, &osrel, &len, NULL, 0);
  if (CrossCompiling) {
      strcpy (cmd, CrossCompileDir);
      strcat (cmd, "/");
      strcat (cmd,"objformat");
  } else
      strcpy (cmd, "objformat");

  if (osrel >= 300004 &&
      (objprog = popen(cmd, "r")) != NULL &&
      fgets(buf, sizeof(buf), objprog) != NULL &&
      strncmp(buf, "elf", 3) == 0)
    iself = 1;
  if (objprog)
    pclose(objprog);

  fprintf(inFile, "#define DefaultToElfFormat %s\n", iself ? "YES" : "NO");
}
#endif

#if defined(sun) && defined(__SVR4)
static void
get_sun_compiler_versions (FILE *inFile)
{
  char buf[PATH_MAX];
  char cmd[PATH_MAX];
  static char* sunpro_cc = "/opt/SUNWspro/bin/cc";
  static char* sunpro_CC = "/opt/SUNWspro/bin/CC";
  int cmajor, cminor;
  char* vptr;
  struct stat sb;
  FILE* ccproc;

#if defined CROSSCOMPILE
  if (CrossCompiling) {
      int len = strlen(CrossCompileDir);
      len += 3;
      sunpro_cc = (char *) malloc(len);
      sunpro_CC = (char *) malloc(len);
      strcpy(sunpro_cc,CrossCompileDir);
      strcpy(sunpro_CC,CrossCompileDir);
      strcat(sunpro_cc,"/cc");
      strcat(sunpro_CC,"/CC");
  }
#endif
  if (lstat (sunpro_cc, &sb) == 0) {
    strcpy (cmd, sunpro_cc);
    strcat (cmd, " -V 2>&1");
    if ((ccproc = popen (cmd, "r")) != NULL) {
      if (fgets (buf, PATH_MAX, ccproc) != NULL) {
	vptr = strrchr (buf, 'C');
	for (; !isdigit(*vptr); vptr++);
	(void) sscanf (vptr, "%d.%d", &cmajor, &cminor);
	fprintf (inFile,
		 "#define DefaultSunProCCompilerMajorVersion %d\n",
		 cmajor);
	fprintf (inFile,
		 "#define DefaultSunProCCompilerMinorVersion %d\n",
		 cminor);
      }
      while (fgets (buf, PATH_MAX, ccproc) != NULL) {};
      pclose (ccproc);
    }
  }
  if (lstat (sunpro_CC, &sb) == 0) {
    strcpy (cmd, sunpro_CC);
    strcat (cmd, " -V 2>&1");
    if ((ccproc = popen (cmd, "r")) != NULL) {
      if (fgets (buf, PATH_MAX, ccproc) != NULL) {
	vptr = strrchr (buf, 'C');
	for (; !isdigit(*vptr); vptr++);
	(void) sscanf (vptr, "%d.%d", &cmajor, &cminor);
	fprintf (inFile,
		 "#define DefaultSunProCplusplusCompilerMajorVersion %d\n",
		 cmajor);
	fprintf (inFile,
		 "#define DefaultSunProCplusplusCompilerMinorVersion %d\n",
		 cminor);
      }
      while (fgets (buf, PATH_MAX, ccproc) != NULL) {};
      pclose (ccproc);
    }
  }
}
#endif

#if defined CROSSCOMPILE || defined  __GNUC__
static void
get_gcc_version(FILE *inFile, char *name)
{
    fprintf (inFile, "#define HasGcc 1\n");
#ifdef CROSSCOMPILE
    if (CrossCompiling)
    {
	if (gnu_c > 1) {
	    fprintf (inFile, "#define HasGcc2 1\n");
	    if (gnu_c > 2)
		fprintf (inFile, "#define HasGcc3 1\n");
	}
	fprintf (inFile, "#define GccMajorVersion %d\n", gnu_c);
	fprintf (inFile, "#define GccMinorVersion %d\n", gnu_c_minor);
    } else
#endif
    {
#if __GNUC__ > 1
	fprintf (inFile, "#define HasGcc2 1\n");
# if __GNUC__ > 2
	fprintf (inFile, "#define HasGcc3 1\n");
# endif
#endif
	fprintf (inFile, "#define GccMajorVersion %d\n", __GNUC__);
	fprintf (inFile, "#define GccMinorVersion %d\n", __GNUC_MINOR__);
    }
#if defined(HAS_MERGE_CONSTANTS)
    fprintf (inFile, "#define HasGccMergeConstants %d\n", HAS_MERGE_CONSTANTS);
#endif
}
#endif

static boolean
get_gcc(char *cmd)
{
  struct stat sb;
    static char* gcc_path[] = {
# if defined(linux) || \
     defined(__NetBSD__) || \
     defined(__OpenBSD__) || \
     defined(__FreeBSD__) || \
     defined(__APPLE__) || \
     defined(__GNU__)
	"/usr/bin/cc",	/* for Linux PostIncDir */
# endif
	"/usr/local/bin/gcc",
	"/opt/gnu/bin/gcc",
	"/usr/pkg/bin/gcc"
    };

#ifdef CROSSCOMPILE
    static char* cross_cc_name[] = {
	"cc",
	"gcc"
    };

    if (CrossCompiling) {
	int i;
	for (i = 0; i < sizeof (cross_cc_name) / sizeof cross_cc_name[0]; i++){
	    strcpy (cmd, CrossCompileDir);
	    strcat (cmd, "/");
	    strcat (cmd, cross_cc_name[i]);
	    if (lstat (cmd, &sb) == 0) {
		return TRUE;
		break;
	    }
	}
    } else
#endif
      {
	int i;
	for (i = 0; i < sizeof (gcc_path) / sizeof gcc_path[0]; i++) {
	    if (lstat (gcc_path[i], &sb) == 0) {
		strcpy (cmd, gcc_path[i]);
		return TRUE;
	    }
	}
      }
    return FALSE;
}

#if defined CROSSCOMPILE || !defined __UNIXOS2__
static void
get_gcc_incdir(FILE *inFile, char* name)
{
  FILE* gccproc;
  char buf[PATH_MAX];
  char cmd[PATH_MAX];
  char* ptr;

  strcpy(cmd,name);

  buf[0] = '\0';
  strcat (cmd, " --print-libgcc-file-name");
  if ((gccproc = popen (cmd, "r")) != NULL) {
      if (fgets (buf, PATH_MAX, gccproc) != NULL) {
	  ptr = strstr (buf, "libgcc.a");
	  if (ptr) strcpy (ptr, "include");
      }
      (void) pclose (gccproc);
  }

  if (buf[0])
      fprintf (inFile, "#define DefaultGccIncludeDir \"%s\"\n", buf);
}
#endif

boolean
define_os_defaults(FILE *inFile)
{
#if defined CROSSCOMPILE || ( !defined(WIN32) && !defined(__UNIXOS2__) )
#ifdef CROSSCOMPILE
  if ((sys != win32) && (sys != emx))
#endif
    {
# if (defined(DEFAULT_OS_NAME) || defined(DEFAULT_OS_MAJOR_REV) || \
     defined(DEFAULT_OS_MINOR_REV) || defined(DEFAULT_OS_TEENY_REV))
	struct utsname *name = NULL;
	struct utsname uts_name;
	char buf[SYS_NMLN * 5 + 1];

	/* Obtain the system information. */
#ifdef CROSSCOMPILE
      if (!CrossCompiling)
#endif
      {
	  if (uname(&uts_name) < 0)
	      LogFatal("Cannot invoke uname", "");
	  else
	      name = &uts_name;
      }
#if defined CROSSCOMPILE && defined linux
      else {
	  strncpy(uts_name.sysname,cross_uts_sysname,SYS_NMLN);
	  strncpy(uts_name.release,cross_uts_release,SYS_NMLN);
	  strncpy(uts_name.version,cross_uts_version,SYS_NMLN);
	  strncpy(uts_name.machine,cross_uts_machine,SYS_NMLN);
	  name = &uts_name;
      }
#endif

#  if defined DEFAULT_OS_NAME
#   if defined CROSSCOMPILE
      if (!CrossCompiling)
#   endif
	{
	  parse_utsname(name, DEFAULT_OS_NAME, buf,
			"Bad DEFAULT_OS_NAME syntax %s");
#   ifdef DEFAULT_OS_NAME_FROB
	  DEFAULT_OS_NAME_FROB(buf, sizeof buf);
#   endif
	  if (buf[0] != '\0')
	    fprintf(inFile, "#define DefaultOSName %s\n", buf);
	}
#  endif

#  if defined CROSSCOMPILE
	if (CrossCompiling && defaultOsName) {
	  parse_utsname(name, defaultOsName, buf,
			"Bad DEFAULT_OS_NAME syntax %s");
	  if (defaultOsNameFrob)
	    defaultOsNameFrob(buf, sizeof buf);
	  if (buf[0] != '\0')
	    fprintf(inFile, "#define DefaultOSName %s\n", buf);
	}
#  endif

#  ifdef DEFAULT_OS_MAJOR_REV
#   if defined CROSSCOMPILE
	if (!CrossCompiling)
#   endif
	  {
	    parse_utsname(name, DEFAULT_OS_MAJOR_REV, buf,
			  "Bad DEFAULT_OS_MAJOR_REV syntax %s");
#   ifdef DEFAULT_OS_MAJOR_REV_FROB
	    DEFAULT_OS_MAJOR_REV_FROB(buf, sizeof buf);
#   endif
	    fprintf(inFile, "#define DefaultOSMajorVersion %s\n",
		    *buf ? trim_version(buf) : "0");
	  }
#  endif

#  if defined CROSSCOMPILE
	if (CrossCompiling && defaultOsMajorRev) {
	  parse_utsname(name, defaultOsMajorRev, buf,
			"Bad defaultOsMajorRev syntax %s");
	  if (defaultOsMajorRevFrob)
	    defaultOsMajorRevFrob(buf, sizeof buf);
	  fprintf(inFile, "#define DefaultOSMajorVersion %s\n",
		  *buf ? trim_version(buf) : "0");
	}
#  endif

#  ifdef DEFAULT_OS_MINOR_REV
#   if defined CROSSCOMPILE
	if (!CrossCompiling)
#   endif
	  {
	    parse_utsname(name, DEFAULT_OS_MINOR_REV, buf,
			  "Bad DEFAULT_OS_MINOR_REV syntax %s");
#   ifdef DEFAULT_OS_MINOR_REV_FROB
	    DEFAULT_OS_MINOR_REV_FROB(buf, sizeof buf);
#   endif
	    fprintf(inFile, "#define DefaultOSMinorVersion %s\n",
		    *buf ? trim_version(buf) : "0");
	  }
#  endif

#  if defined CROSSCOMPILE
	if (CrossCompiling && defaultOsMinorRev) {
	  parse_utsname(name, defaultOsMinorRev, buf,
			"Bad defaultOsMinorRev syntax %s");
	  if (defaultOsMinorRevFrob)
	    defaultOsMinorRevFrob(buf, sizeof buf);
	  fprintf(inFile, "#define DefaultOSMinorVersion %s\n",
		  *buf ? trim_version(buf) : "0");
	}
#  endif

#  ifdef DEFAULT_OS_TEENY_REV
#   if defined CROSSCOMPILE
	if (!CrossCompiling)
#   endif
	  {
	    parse_utsname(name, DEFAULT_OS_TEENY_REV, buf,
			  "Bad DEFAULT_OS_TEENY_REV syntax %s");
#   ifdef DEFAULT_OS_TEENY_REV_FROB
	    DEFAULT_OS_TEENY_REV_FROB(buf, sizeof buf);
#   endif
	    fprintf(inFile, "#define DefaultOSTeenyVersion %s\n",
		    *buf ? trim_version(buf) : "0");
	  }
#  endif

#  if defined CROSSCOMPILE
	if (CrossCompiling && defaultOsTeenyRev) {
	  parse_utsname(name, defaultOsTeenyRev, buf,
			"Bad defaultOsTeenyRev syntax %s");
	  if (defaultOsTeenyRevFrob)
	    defaultOsTeenyRevFrob(buf, sizeof buf);
	  fprintf(inFile, "#define DefaultOSTeenyVersion %s\n",
		  *buf ? trim_version(buf) : "0");
	}
#  endif

#  ifdef DEFAULT_MACHINE_ARCHITECTURE
#   if defined CROSSCOMPILE
	if (!CrossCompiling)
#   endif
	  {
	    parse_utsname(name, DEFAULT_MACHINE_ARCHITECTURE, buf,
			  "Bad DEFAULT_MACHINE_ARCHITECTURE %s");
	    fprintf(inFile, "#ifndef %s\n# define %s\n#endif\n", buf, buf);
	  }
#  endif

#  if defined CROSSCOMPILE
	if (CrossCompiling && defaultMachineArchitecture) {
	  parse_utsname(name, defaultMachineArchitecture, buf,
			"Bad defaultMachineArchitecture syntax %s");
	  fprintf(inFile, "#ifndef %s\n# define %s\n#endif\n", buf, buf);
	}
#  endif
# endif
# if defined CROSSCOMPILE
      if (CrossCompiling)
	get_cross_compile_dir(inFile);
      else
# endif
	  fprintf(inFile, "#define CrossCompiling NO\n");
# if defined CROSSCOMPILE
      if (CrossCompiling && sys == LinuX)
# endif
# if defined CROSSCOMPILE || defined linux
#  ifdef CROSSCOMPILE
	if (sys == LinuX)
#  endif
	  get_distrib (inFile);
# endif
# if defined linux
#  if defined CROSSCOMPILE
      if (!CrossCompiling)
#  endif
	  get_libc_version (inFile);
#  if defined CROSSCOMPILE
      else {
	  fprintf(inFile,"#define DefaultLinuxCLibMajorVersion %d\n",
		  glibc_major);
	  fprintf(inFile,"#define DefaultLinuxCLibMinorVersion %d\n",
		  glibc_minor);
	  fprintf(inFile,"#define DefaultLinuxCLibTeenyVersion 0\n");
      }
#  endif
# endif /* linux */
# if defined CROSSCOMPILE || defined linux
#  if defined CROSSCOMPILE
      if (sys == LinuX)
#  endif
	  get_ld_version(inFile);
# endif
# if defined (sun) && defined(SVR4)
      get_sun_compiler_versions (inFile);
# endif
# if defined CROSSCOMPILE || defined __GNUC__
#  if defined CROSSCOMPILE
      if (gnu_c)
#  endif
	{
	  char name[PATH_MAX];
	  if (get_gcc(name)) {
	      get_gcc_version (inFile,name);
#  if defined CROSSCOMPILE || !defined __UNIXOS2__
#   if defined CROSSCOMPILE
	      if (sys != emx)
#   endif
		  get_gcc_incdir(inFile,name);
#  endif
	  }
	}
# endif
# if defined __FreeBSD__
#  if defined CROSSCOMPILE
      if (sys == freeBSD)
#  endif
	  get_binary_format(inFile);
# endif
    }
#endif /* !WIN32 && !__UNIXOS2__*/
#if defined WIN32
# ifdef CROSSCOMPILE
  else if (sys == win32 && !CrossCompiling)
# endif
    {
      OSVERSIONINFO osvi;
      static char* os_names[] = { "Win32s", "Windows 95", "Windows NT" };

      memset(&osvi, 0, sizeof(OSVERSIONINFO));
      osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
      GetVersionEx (&osvi);

      fprintf (inFile, "#define DefaultOSName Microsoft %s\n",
	       os_names[osvi.dwPlatformId]);

      fprintf(inFile, "#define DefaultOSMajorVersion %d\n", osvi.dwMajorVersion);
      fprintf(inFile, "#define DefaultOSMinorVersion %d\n", osvi.dwMinorVersion);
      fprintf(inFile, "#define DefaultOSTeenyVersion %d\n",
	      osvi.dwBuildNumber & 0xFFFF);
    }
#endif /* WIN32 */
#ifdef CROSSCOMPILE
  else if (sys == emx)
#endif
#if defined CROSSCOMPILE || defined __UNIXOS2__
    {
      fprintf(inFile, "#define DefaultOSMajorVersion 4\n");
      fprintf(inFile, "#define DefaultOSMinorVersion 0\n");
      fprintf(inFile, "#define DefaultOSTeenyVersion 0\n");
    }
#endif /* EMX */
#if defined(__OpenBSD__)
  get_stackprotector(inFile);
#endif
  return FALSE;
}

void
cppit(char *imakefile, char *template, char *masterc,
      FILE *outfd, char *outfname)
{
	FILE	*inFile;

	haveImakefileC = TRUE;
	inFile = fopen(masterc, "w");
	if (inFile == NULL)
		LogFatal("Cannot open %s for output.", masterc);
	if (fprintf(inFile, "%s\n", ImakefileCHeader) < 0 ||
	    define_os_defaults(inFile) ||
	    optional_include(inFile, "IMAKE_LOCAL_DEFINES", "localdefines") ||
	    optional_include(inFile, "IMAKE_ADMIN_DEFINES", "admindefines") ||
	    fprintf(inFile, "#define %s <%s>\n", ImakeDefSym, imakefile) < 0 ||
	    fprintf(inFile, LocalDefineFmt, ImakeTmplSym, template) < 0 ||
	    fprintf(inFile, IncludeFmt, ImakeTmplSym) < 0 ||
	    optional_include(inFile, "IMAKE_ADMIN_MACROS", "adminmacros") ||
	    optional_include(inFile, "IMAKE_LOCAL_MACROS", "localmacros") ||
	    fflush(inFile) ||
	    fclose(inFile))
		LogFatal("Cannot write to %s.", masterc);
	/*
	 * Fork and exec cpp
	 */
	doit(outfd, cpp, cpp_argv);
	CleanCppOutput(outfd, outfname);
}

void
makeit(void)
{
	doit(NULL, make_argv[0], make_argv);
}

char *
CleanCppInput(char *imakefile)
{
	FILE	*outFile = NULL;
	FILE	*inFile;
	char	*buf,		/* buffer for file content */
		*pbuf,		/* walking pointer to buf */
		*punwritten,	/* pointer to unwritten portion of buf */
		*ptoken,	/* pointer to # token */
		*pend,		/* pointer to end of # token */
		savec;		/* temporary character holder */
	int	count;
	struct stat	st;

	/*
	 * grab the entire file.
	 */
	if (!(inFile = fopen(imakefile, "r")))
		LogFatal("Cannot open %s for input.", imakefile);
	if (fstat(fileno(inFile), &st) < 0)
		LogFatal("Cannot stat %s for size.", imakefile);
	buf = Emalloc((int)st.st_size+3);
	count = fread(buf + 2, 1, st.st_size, inFile);
	if (count == 0 && st.st_size != 0)
		LogFatal("Cannot read %s:", imakefile);
	fclose(inFile);
	buf[0] = '\n';
	buf[1] = '\n';
	buf[count + 2] = '\0';

	punwritten = pbuf = buf + 2;
	while (*pbuf) {
	    /* for compatibility, replace make comments for cpp */
	    if (*pbuf == '#' && pbuf[-1] == '\n' && pbuf[-2] != '\\') {
		ptoken = pbuf+1;
		while (*ptoken == ' ' || *ptoken == '\t')
			ptoken++;
		pend = ptoken;
		while (*pend && *pend != ' ' && *pend != '\t' && *pend != '\n' && *pend != '\r')
			pend++;
		savec = *pend;
		*pend = '\0';
		if (strcmp(ptoken, "define") &&
		    strcmp(ptoken, "if") &&
		    strcmp(ptoken, "ifdef") &&
		    strcmp(ptoken, "ifndef") &&
		    strcmp(ptoken, "include") &&
		    strcmp(ptoken, "line") &&
		    strcmp(ptoken, "else") &&
		    strcmp(ptoken, "elif") &&
		    strcmp(ptoken, "endif") &&
		    strcmp(ptoken, "error") &&
		    strcmp(ptoken, "pragma") &&
		    strcmp(ptoken, "undef")) {
		    if (outFile == NULL) {
#ifdef HAS_MKSTEMP
			int fd;
#endif
			tmpImakefile = Strdup(tmpImakefile);
#ifndef HAS_MKSTEMP
			if (mktemp(tmpImakefile) == NULL ||
			    (outFile = fopen(tmpImakefile, "w+")) == NULL) {
			    LogFatal("Cannot open %s for write.",
				tmpImakefile);
			}
#else
			fd=mkstemp(tmpImakefile);
			if (fd != -1)
			    outFile = fdopen(fd, "w");
			if (outFile == NULL) {
			    if (fd != -1) {
			       unlink(tmpImakefile); close(fd);
			    }
			    LogFatal("Cannot open %s for write.",
				tmpImakefile);
			}
#endif
		    }
		    writetmpfile(outFile, punwritten, pbuf-punwritten,
				 tmpImakefile);
		    if (ptoken > pbuf + 1)
			writetmpfile(outFile, "XCOMM", 5, tmpImakefile);
		    else
			writetmpfile(outFile, "XCOMM ", 6, tmpImakefile);
		    punwritten = pbuf + 1;
		}
		*pend = savec;
	    }
	    pbuf++;
	}
	if (outFile) {
	    writetmpfile(outFile, punwritten, pbuf-punwritten, tmpImakefile);
	    fclose(outFile);

	    return tmpImakefile;
	}

	return(imakefile);
}

void
CleanCppOutput(FILE *tmpfd, char *tmpfname)
{
	char	*input;
	int	blankline = 0;

	while((input = ReadLine(tmpfd, tmpfname))) {
		if (isempty(input)) {
			if (blankline++)
				continue;
#ifdef CROSSCOMPILE
			if (fixup_whitespace)
#endif
#if defined CROSSCOMPILE || defined FIXUP_CPP_WHITESPACE
			    KludgeResetRule();
#endif
		} else {
			blankline = 0;
#ifdef CROSSCOMPILE
			if (fixup_whitespace)
#endif
#if defined CROSSCOMPILE || defined FIXUP_CPP_WHITESPACE
			    KludgeOutputLine(&input);
#endif
			writetmpfile(tmpfd, input, strlen(input), tmpfname);
		}
		writetmpfile(tmpfd, "\n", 1, tmpfname);
	}
	fflush(tmpfd);
#ifdef NFS_STDOUT_BUG
	/*
	 * On some systems, NFS seems to leave a large number of nulls at
	 * the end of the file.  Ralph Swick says that this kludge makes the
	 * problem go away.
	 */
	ftruncate (fileno(tmpfd), (off_t)ftell(tmpfd));
#endif
}

/*
 * Determine if a line has nothing in it.  As a side effect, we trim white
 * space from the end of the line.  Cpp magic cookies are also thrown away.
 * "XCOMM" token is transformed to "#".
 */
boolean
isempty(char *line)
{
	char	*pend;

	/*
	 * Check for lines of the form
	 *	# n "...
	 * or
	 *	# line n "...
	 */
	if (*line == '#') {
		pend = line+1;
		if (*pend == ' ')
			pend++;
		if (*pend == 'l' && pend[1] == 'i' && pend[2] == 'n' &&
		    pend[3] == 'e' && pend[4] == ' ')
			pend += 5;
		if (isdigit(*pend)) {
			do {
			    pend++;
			} while (isdigit(*pend));
			if (*pend == '\n' || *pend == '\0')
				return(TRUE);
			if (*pend++ == ' ' && *pend == '"')
				return(TRUE);
		}
		while (*pend)
		    pend++;
	} else {
	    for (pend = line; *pend; pend++) {
		if (*pend == 'X' && pend[1] == 'C' && pend[2] == 'O' &&
		    pend[3] == 'M' && pend[4] == 'M' &&
		    (pend == line || pend[-1] == ' ' || pend[-1] == '\t' || pend[-1] == '\r') &&
		    (pend[5] == ' ' || pend[5] == '\t' || pend[5] == '\r' || pend[5] == '\0'))
		{
		    *pend = '#';
		    memmove(pend+1, pend+5, strlen(pend+5)+1);
		}
#ifdef CROSSCOMPILE
		if (magic_make_vars)
#endif
		  {
#if defined CROSSCOMPILE || defined MAGIC_MAKE_VARS
		    if (*pend == 'X' && pend[1] == 'V' && pend[2] == 'A' &&
			pend[3] == 'R')
		    {
			char varbuf[5];
			int i;

			if (pend[4] == 'd' && pend[5] == 'e' && pend[6] == 'f' &&
			    pend[7] >= '0' && pend[7] <= '9')
			{
			    i = pend[7] - '0';
			    sprintf(varbuf, "%0.4d", xvariable);
			    strncpy(pend+4, varbuf, 4);
			    xvariables[i] = xvariable;
			    xvariable = (xvariable + 1) % 10000;
			}
			else if (pend[4] == 'u' && pend[5] == 's' &&
				 pend[6] == 'e' && pend[7] >= '0' &&
				 pend[7] <= '9')
			{
			    i = pend[7] - '0';
			    sprintf(varbuf, "%0.4d", xvariables[i]);
			    strncpy(pend+4, varbuf, 4);
			}
		    }
#endif
		}
	    }
	}
	while (--pend >= line && (*pend == ' ' || *pend == '\t' || *pend == '\r')) ;
	pend[1] = '\0';
	return (*line == '\0');
}

/*ARGSUSED*/
char *
ReadLine(FILE *tmpfd, char *tmpfname)
{
	static boolean	initialized = FALSE;
	static char	*buf, *pline, *end;
	register char	*p1, *p2;

	if (! initialized) {
#ifdef WIN32
		FILE *fp = tmpfd;
#endif
		int total_red;
		struct stat st;

		/*
		 * Slurp it all up.
		 */
		fseek(tmpfd, 0, 0);
		if (fstat(fileno(tmpfd), &st) < 0)
			LogFatal("cannot stat %s for size", tmpMakefile);
		pline = buf = Emalloc((int)st.st_size+1);
		total_red = fread(buf, 1, st.st_size, tmpfd);
		if (total_red == 0 && st.st_size != 0)
			LogFatal("cannot read %s", tmpMakefile);
		end = buf + total_red;
		*end = '\0';
		fseek(tmpfd, 0, 0);
#if defined(SYSV) || defined(WIN32) || defined(USE_FREOPEN)
		tmpfd = freopen(tmpfname, "w+", tmpfd);
#ifdef WIN32
		if (! tmpfd) /* if failed try again */
			tmpfd = freopen(tmpfname, "w+", fp);
#endif
		if (! tmpfd)
			LogFatal("cannot reopen %s\n", tmpfname);
#else	/* !SYSV */
		ftruncate(fileno(tmpfd), (off_t) 0);
#endif	/* !SYSV */
		initialized = TRUE;
	    fprintf (tmpfd, "# Makefile generated by imake - do not edit!\n");
	    fprintf (tmpfd, "# %s\n",
		"$Xorg: imake.c,v 1.6 2001/02/09 02:03:15 xorgcvs Exp $");
	}

	for (p1 = pline; p1 < end; p1++) {
		if (*p1 == '@@' && *(p1+1) == '@@'
		    /* ignore ClearCase version-extended pathnames */
		    && !(p1 != pline && !isspace(*(p1-1)) && *(p1+2) == '/'))
		{ /* soft EOL */
			*p1++ = '\0';
			p1++; /* skip over second @@ */
			break;
		}
		else if (*p1 == '\n') { /* real EOL */
#if defined CROSSCOMPILE || defined WIN32
# if defined CROSSCOMPILE
		  if (sys == win32)
# endif
		    {
			if (p1 > pline && p1[-1] == '\r')
				p1[-1] = '\0';
		    }
#endif
			*p1++ = '\0';
			break;
		}
	}

	/*
	 * return NULL at the end of the file.
	 */
	p2 = (pline == p1 ? NULL : pline);
	pline = p1;
	return(p2);
}

void
writetmpfile(FILE *fd, char *buf, int cnt, char *fname)
{
	if (fwrite(buf, sizeof(char), cnt, fd) == -1)
		LogFatal("Cannot write to %s.", fname);
}

char *
Emalloc(int size)
{
	char	*p;

	if ((p = malloc(size)) == NULL)
		LogFatalI("Cannot allocate %d bytes", size);
	return(p);
}

#if defined CROSSCOMPILE || defined FIXUP_CPP_WHITESPACE
void
KludgeOutputLine(char **pline)
{
	char	*p = *pline;
	char	quotechar = '\0';

	switch (*p) {
	    case '#':	/*Comment - ignore*/
		break;
	    case '\t':	/*Already tabbed - ignore it*/
		break;
	    case ' ':	/*May need a tab*/
	    default:
#ifdef CROSSCOMPILE
		if (inline_syntax)
#endif
#if defined CROSSCOMPILE || defined INLINE_SYNTAX
		{
		    if (*p == '<' && p[1] == '<') { /* inline file close */
			InInline--;
			InRule = TRUE;
			break;
		    }
		}
#endif
		/*
		 * The following cases should not be treated as beginning of
		 * rules:
		 * variable := name (GNU make)
		 * variable = .*:.* (':' should be allowed as value)
		 * sed 's:/a:/b:'   (: used in quoted values)
		 */
		for (; *p; p++) {
		    if (quotechar) {
			if (quotechar == '\\' ||
			    (*p == quotechar &&
# if defined CROSSCOMPILE || defined WIN32
			     (
#  if defined CROSSCOMPILE
			      (sys == win32) &&
#  endif
			      quotechar != ')') &&
# endif
			     p[-1] != '\\'))
			    quotechar = '\0';
			continue;
		    }
		    switch (*p) {
		    case '\\':
		    case '"':
		    case '\'':
			quotechar = *p;
			break;
		    case '(':
			quotechar = ')';
			break;
		    case '{':
			quotechar = '}';
			break;
		    case '[':
			quotechar = ']';
			break;
		    case '=':
#ifdef CROSSCOMPILE
			if (remove_cpp_leadspace)
#endif
#if defined CROSSCOMPILE || defined REMOVE_CPP_LEADSPACE
			{
			    if (!InRule && **pline == ' ') {
				while (**pline == ' ')
				    (*pline)++;
			    }
			}
#endif
			goto breakfor;
#if defined CROSSCOMPILE || defined INLINE_SYNTAX
		    case '<':
			if (inline_syntax) {
			    if (p[1] == '<') /* inline file start */
				InInline++;
			}
			break;
#endif
		    case ':':
			if (p[1] == '=')
			    goto breakfor;
			while (**pline == ' ')
			    (*pline)++;
			InRule = TRUE;
			return;
		    }
		}
breakfor:
		if (InRule && **pline == ' ')
		    **pline = '\t';
		break;
	}
}

void
KludgeResetRule(void)
{
	InRule = FALSE;
}
#endif
char *
Strdup(char *cp)
{
	char *new = Emalloc(strlen(cp) + 1);

	strcpy(new, cp);
	return new;
}

#ifdef CROSSCOMPILE
char*
CrossCompileCPP(void)
{
    char *cpp, *c;
    int len ;
    if (crosscompile_use_cc_e)
	AddCppArg("-E");

    cpp = strrchr(crosscompile_cpp,'/');
    if (!cpp)
	cpp = crosscompile_cpp;
    else
	cpp++;

    len = strlen(cpp) + strlen(CrossCompileDir) + 2;
    c = Emalloc(len);

    (void)snprintf(c, len,"%s/%s",CrossCompileDir,cpp);

    return c;
}

#endif

#ifdef CROSSCOMPILE
static void
get_cross_compile_dir(FILE *inFile)
{
	fprintf(inFile, "#define CrossCompileDir %s\n",
		CrossCompileDir);
	fprintf(inFile, "#define CrossCompiling YES\n");
}
#endif
@


1.2
log
@* this time, make b-r for real
* including X-Window
* merge evilwm import
* install all .cf etc. files, especially the MirBSD.cf one
* cope in X for MirOS changes
* refine anoncvssh: all defines in Makefile, etc.
* cope for XFree86 1.1 licence
* merge nlist.c import
* nuke unused files
* remove warnings
* fix really bogus bug in rcdb again
* offer bsd.slim for installation
* fix the default route bug
* sync distrib stuff
(...)

thanks for alpha-testing to
 * Jannis "Kabelaffe" Konrad
 * Jos Antnio "T0ni" "jesus_" Matias de Jesus
@
text
@a0 1

d9 2
a10 2
/* $MirBSD$ */
/* $XFree86: xc/config/imake/imake.c,v 3.63 2002/12/16 22:48:27 herrb Exp $ */
d1837 1
a1837 1
		    strcpy(pend+1, pend+5);
@


1.1
log
@Initial revision
@
text
@d10 2
a11 1
/* $XFree86: xc/config/imake/imake.c,v 3.48 2001/12/14 19:53:18 dawes Exp $ */
d14 2
a15 2
 * 
Copyright (c) 1985, 1986, 1987, 1998 The Open Group  
d36 1
a36 1
 * 
d61 1
a61 1
 *              -e[F]   execute instead of show; optionally name Makefile F
d65 1
a65 1
 *		
d108 3
a110 3
 *      - If DEFAULT_MACHINE_ARCITECTURE is defined, format the utsname struct
 *        and define the corresponding macro. (For example on the amiga,
 *        this will define amiga in addition to m68k).    
d112 1
a112 1
 *	  directory, print a warning message to stderr and add: 
d116 1
a116 1
 *	  directory, print a warning message to stderr and add: 
d124 1
a124 1
 *	  directory, print a warning message to stderr and add: 
d128 1
a128 1
 *	  directory, print a warning message to stderr and add: 
d231 1
a231 1
#include <stdlib.h>
a242 3
#ifdef __EMX__
#define USE_STRERROR		1
#endif
a262 2
#include "imakemdep.h"

d280 1
a280 1
#if !(defined(Lynx) || defined(__Lynx__) || (defined(SVR4) && !defined(sun))) && !defined(__CYGWIN__)
d284 8
a291 2
#define	TRUE		1
#define	FALSE		0
d293 5
a297 5
#ifdef FIXUP_CPP_WHITESPACE
int	InRule = FALSE;
# ifdef INLINE_SYNTAX
int	InInline = 0;
# endif
d299 1
a299 1
#ifdef MAGIC_MAKE_VARS
d304 4
a312 1
#ifdef FIXUP_CPP_WHITESPACE
a313 4
#else
# define KludgeOutputLine(arg)
# define KludgeResetRule()
#endif
d315 12
a326 12
typedef	unsigned char	boolean;

#ifdef USE_CC_E
# ifndef DEFAULT_CC
#  define DEFAULT_CC "cc"
# endif
#else
# ifndef DEFAULT_CPP
#  ifdef CPP_PROGRAM
#   define DEFAULT_CPP CPP_PROGRAM
#  else
#   define DEFAULT_CPP "/lib/cpp"
d333 2
a334 2
char	*tmpMakefile    = "/tmp/Imf.XXXXXX";
char	*tmpImakefile    = "/tmp/IIf.XXXXXX";
d357 2
a358 2
void	LogFatalI(char *s, int i), LogFatal(char *x0, char *x1), 
        LogMsg(char *x0, char *x1);
d365 3
d370 1
a370 1
void	cppit(char *imakefile, char *template, char *masterc, 
d374 1
a374 1
boolean	isempty(char *line);
d377 1
a377 1
int     catch(int sig);
d379 1
a379 1
void    catch(int sig);
d381 1
a381 1
void    showargs(char **argv);
d383 1
a383 1
void    doit(FILE *outfd, char *cmd, char **argv);
d385 10
d397 2
a398 2
boolean	verbose = FALSE;
boolean	show = TRUE;
d406 1
d410 10
a420 1

d424 3
a426 3
                tmpMakefile = Makefile;
                if ((tmpfd = fopen(tmpMakefile, "w+")) == NULL)
                   LogFatal("Cannot create temporary file %s.", tmpMakefile);
d429 1
a429 1
	        int fd;
d438 2
a439 2
	        fd = mkstemp(tmpMakefile);
	        if (fd == -1 || (tmpfd = fdopen(fd, "w+")) == NULL) {
d516 7
a522 1
#if defined(__NetBSD__)
d594 1
d661 5
a665 3
#ifdef USE_CC_E
	if (!cpp)
	{
d667 4
d672 5
a676 1
	}
d678 2
a679 2
	if (!cpp)
		cpp = DEFAULT_CPP;
d681 1
d714 1
a714 1
	static boolean	entered = FALSE;
d761 1
a761 1
		     strncmp(mkcbuf, ImakefileCHeader, 
d775 1
a775 1
#define OverrideWarning	"Warning: local file \"%s\" overrides global macros."
d792 1
a792 1
	int	pid;
d830 1
a830 1
#ifndef WIN32
d838 3
d885 9
d912 1
a912 1
	
d926 1
a926 1
#ifdef linux
d931 1
a931 1
"#if 0\n"
a934 4
"#else\n"
"asm (\".weak gnu_get_libc_version\");\n"
"asm (\".weak __libc_version\");\n"
"asm (\".weak __linux_C_lib_version\");\n"
d945 2
d948 6
a953 4
"  if (((&__linux_C_lib_version != 0)\n"
"       && ((&__libc_version != 0) || (gnu_get_libc_version != 0)))\n"
"      || (!(&__linux_C_lib_version != 0) && !(&__libc_version != 0)\n"
"	  && !(gnu_get_libc_version != 0)))\n"
d955 6
a960 3
"    libcmajor = 0;\n"
"    libcminor = 0;\n"
"    libcteeny = 0;\n"
d964 2
a965 15
"    const char * ptr;\n"
"    int glibcmajor = 0;\n"
"\n"
"    if (gnu_get_libc_version != 0)\n"
"    {\n"
"      ptr = gnu_get_libc_version ();\n"
"      glibcmajor = 4;\n"
"    }\n"
"    else if (&__libc_version != 0)\n"
"    {\n"
"      ptr = __libc_version;\n"
"      glibcmajor = 4;\n"
"    }\n"
"    else\n"
"      ptr = __linux_C_lib_version;\n"
d967 2
a984 47
get_distrib(FILE *inFile)
{
  struct stat sb;

  static char* yast = "/sbin/YaST";
  static char* redhat = "/etc/redhat-release";
  static char* debian = "/etc/debian_version";

  fprintf (inFile, "%s\n", "#define LinuxUnknown    0");
  fprintf (inFile, "%s\n", "#define LinuxSuSE       1");
  fprintf (inFile, "%s\n", "#define LinuxCaldera    2");
  fprintf (inFile, "%s\n", "#define LinuxCraftworks 3");
  fprintf (inFile, "%s\n", "#define LinuxDebian     4");
  fprintf (inFile, "%s\n", "#define LinuxInfoMagic  5");
  fprintf (inFile, "%s\n", "#define LinuxKheops     6");
  fprintf (inFile, "%s\n", "#define LinuxPro        7");
  fprintf (inFile, "%s\n", "#define LinuxRedHat     8");
  fprintf (inFile, "%s\n", "#define LinuxSlackware  9");
  fprintf (inFile, "%s\n", "#define LinuxTurbo      10");
  fprintf (inFile, "%s\n", "#define LinuxWare       11");
  fprintf (inFile, "%s\n", "#define LinuxYggdrasil  12");

  if (lstat (yast, &sb) == 0) {
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxSuSE");
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistName SuSE");
    return;
  }
  if (lstat (redhat, &sb) == 0) {
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxRedHat");
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistName RedHat");
    return;
  }
  if (lstat (debian, &sb) == 0) {
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxDebian");
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistName Debian");
    /* You could also try to get the version of the Debian distrib by looking
     * at the content of /etc/debian_version */
    return;
  }
  /* what's the definitive way to tell what any particular distribution is? */

  fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxUnknown");
  fprintf (inFile, "%s\n", "#define DefaultLinuxDistName Unknown");
  /* would like to know what version of the distribution it is */
}

static void
d1025 1
a1025 1
  
d1031 85
d1120 1
a1120 1
  FILE* ldprog = popen ("ld -v", "r");
d1123 12
d1147 3
a1149 2
    fprintf(inFile, "#define DefaultLinuxBinUtilsMajorVersion %d\n", 
	    ldmajor + ldminor);    
d1155 1
a1155 1
#ifdef __FreeBSD__
d1165 1
d1171 7
d1179 1
a1179 1
      (objprog = popen("objformat", "r")) != NULL &&
a1189 4
#ifndef PATH_MAX
#define PATH_MAX 1024
#endif

d1203 12
d1223 1
a1223 1
	fprintf (inFile, 
d1226 1
a1226 1
	fprintf (inFile, 
d1242 1
a1242 1
	fprintf (inFile, 
d1245 1
a1245 1
	fprintf (inFile, 
d1256 1
a1256 1
#if defined(__OpenBSD__) 
d1258 1
a1258 1
get_stackprotector(FILE *inFile)
d1260 22
a1281 16
  FILE *fp;
  char *cc;
  char command[1024], buf[1024];
  
  cc = getenv("CC");
  if (cc == NULL) {
    cc = "cc";
  }
  snprintf(command, sizeof(command), "%s -v 2>&1", cc);
  fp = popen(command, "r");
  if (fp == NULL) 
    abort();
  while (fgets(buf, sizeof(buf), fp)) {
    if (strstr(buf, "propolice") != NULL) {
      fprintf(inFile, "#define HasGccStackProtector YES\n");
      break;
d1283 3
a1285 3
  }
  if (pclose(fp)) 
    abort();
a1287 1
	
d1289 2
a1290 3
#ifdef __GNUC__
static void
get_gcc_version(FILE *inFile)
d1292 33
a1324 8
   fprintf (inFile, "#define HasGcc 1\n");
#if __GNUC__ > 1
   fprintf (inFile, "#define HasGcc2 1\n");
#endif
   fprintf (inFile, "#define GccMajorVersion %d\n", __GNUC__);
   fprintf (inFile, "#define GccMinorVersion %d\n", __GNUC_MINOR__);
#if defined(HAS_MERGE_CONSTANTS)
   fprintf (inFile, "#define HasGccMergeConstants %d\n", HAS_MERGE_CONSTANTS);
d1326 10
a1336 1
#endif
d1338 1
a1338 1
#ifndef __EMX__
d1340 1
a1340 1
get_gcc_incdir(FILE *inFile)
a1341 9
  static char* gcc_path[] = {
#if defined(linux) || defined(__OpenBSD__) || defined (__GNU__)
    "/usr/bin/cc",	/* for Linux PostIncDir */
#endif
    "/usr/local/bin/gcc",
    "/opt/gnu/bin/gcc"
  };
  struct stat sb;
  int i;
d1347 2
d1350 3
a1352 6
  for (i = 0; i < sizeof gcc_path / sizeof gcc_path[0]; i++) {
    if (lstat (gcc_path[i], &sb) == 0) {
      strcpy (cmd, gcc_path[i]);
      strcat (cmd, " --print-libgcc-file-name");
      if ((gccproc = popen (cmd, "r")) != NULL) {
	if (fgets (buf, PATH_MAX, gccproc) != NULL) {
a1354 3
	}
	(void) pclose (gccproc);
	break;
d1356 1
a1356 1
    }
d1358 1
d1360 1
a1360 1
    fprintf (inFile, "#define DefaultGccIncludeDir \"%s\"\n", buf);
d1367 6
a1372 2
#if !defined(WIN32) && !defined(__EMX__)
#if (defined(DEFAULT_OS_NAME) || defined(DEFAULT_OS_MAJOR_REV) || \
d1374 2
a1375 1
	struct utsname name;
d1379 96
a1474 2
	if (uname(&name) < 0)
		LogFatal("Cannot invoke uname", "");
d1476 13
a1488 5
# ifdef DEFAULT_OS_NAME
	parse_utsname(&name, DEFAULT_OS_NAME, buf, 
		      "Bad DEFAULT_OS_NAME syntax %s");
#  ifdef DEFAULT_OS_NAME_FROB
	DEFAULT_OS_NAME_FROB(buf, sizeof buf);
d1490 45
a1534 2
	if (buf[0] != '\0')
		fprintf(inFile, "#define DefaultOSName %s\n", buf);
d1536 18
a1553 6

# ifdef DEFAULT_OS_MAJOR_REV
	parse_utsname(&name, DEFAULT_OS_MAJOR_REV, buf,
		      "Bad DEFAULT_OS_MAJOR_REV syntax %s");
#  ifdef DEFAULT_OS_MAJOR_REV_FROB
	DEFAULT_OS_MAJOR_REV_FROB(buf, sizeof buf);
d1555 4
a1558 2
	fprintf(inFile, "#define DefaultOSMajorVersion %s\n",
		*buf ? trim_version(buf) : "0");
d1560 13
a1572 6

# ifdef DEFAULT_OS_MINOR_REV
	parse_utsname(&name, DEFAULT_OS_MINOR_REV, buf,
		      "Bad DEFAULT_OS_MINOR_REV syntax %s");
#  ifdef DEFAULT_OS_MINOR_REV_FROB
	DEFAULT_OS_MINOR_REV_FROB(buf, sizeof buf);
d1574 2
a1575 2
	fprintf(inFile, "#define DefaultOSMinorVersion %s\n",
		*buf ? trim_version(buf) : "0");
d1577 3
a1579 6

# ifdef DEFAULT_OS_TEENY_REV
	parse_utsname(&name, DEFAULT_OS_TEENY_REV, buf,
		      "Bad DEFAULT_OS_TEENY_REV syntax %s");
#  ifdef DEFAULT_OS_TEENY_REV_FROB
	DEFAULT_OS_TEENY_REV_FROB(buf, sizeof buf);
d1581 1
a1581 2
	fprintf(inFile, "#define DefaultOSTeenyVersion %s\n",
		*buf ? trim_version(buf) : "0");
d1583 5
a1587 4
# ifdef DEFAULT_MACHINE_ARCHITECTURE
	parse_utsname(&name, DEFAULT_MACHINE_ARCHITECTURE, buf, 
		      "Bad DEFAULT_MACHINE_ARCHITECTURE %s");
	fprintf(inFile, "#ifndef %s\n# define %s\n#endif\n", buf, buf);
d1589 19
d1609 9
a1617 11
#ifdef linux
    get_distrib (inFile);
    get_libc_version (inFile);
    get_ld_version(inFile);
#endif
    get_gcc_incdir(inFile);
#if defined (sun) && defined(SVR4)
    get_sun_compiler_versions (inFile);
#endif
#ifdef __GNUC__
    get_gcc_version (inFile);
d1619 1
a1619 29
#ifdef __FreeBSD__
    get_binary_format(inFile);
#endif
#ifdef __OpenBSD__
    get_stackprotector(inFile);
#endif
#else /* WIN32 */
#ifndef __EMX__
   OSVERSIONINFO osvi;
   static char* os_names[] = { "Win32s", "Windows 95", "Windows NT" };

   memset(&osvi, 0, sizeof(OSVERSIONINFO));
   osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
   GetVersionEx (&osvi);

   fprintf (inFile, "#define DefaultOSName Microsoft %s\n", 
	    os_names[osvi.dwPlatformId]);

   fprintf(inFile, "#define DefaultOSMajorVersion %d\n", osvi.dwMajorVersion);
   fprintf(inFile, "#define DefaultOSMinorVersion %d\n", osvi.dwMinorVersion);
   fprintf(inFile, "#define DefaultOSTeenyVersion %d\n", 
	   osvi.dwBuildNumber & 0xFFFF);
#else /* EMX */
   fprintf(inFile, "#define DefaultOSMajorVersion 4\n");
   fprintf(inFile, "#define DefaultOSMinorVersion 0\n");
   fprintf(inFile, "#define DefaultOSTeenyVersion 0\n");
#endif /* EMX */
#endif /* WIN32 */
   return FALSE;
d1623 1
a1623 1
cppit(char *imakefile, char *template, char *masterc, 
d1641 1
a1641 1
	    fflush(inFile) || 
d1680 1
a1680 1
	if (count == 0  &&  st.st_size != 0)
d1695 1
a1695 1
		while (*pend && *pend != ' ' && *pend != '\t' && *pend != '\n')
d1713 1
a1713 1
		        int fd;
d1750 1
d1767 6
a1772 1
			KludgeResetRule();
d1775 6
a1780 1
			KludgeOutputLine(&input);
d1820 1
a1820 1
		    	do {
d1834 2
a1835 2
		    (pend == line || pend[-1] == ' ' || pend[-1] == '\t') &&
		    (pend[5] == ' ' || pend[5] == '\t' || pend[5] == '\0'))
d1840 10
a1849 6
#ifdef MAGIC_MAKE_VARS
		if (*pend == 'X' && pend[1] == 'V' && pend[2] == 'A' &&
		    pend[3] == 'R')
		{
		    char varbuf[5];
		    int i;
d1851 17
a1867 16
		    if (pend[4] == 'd' && pend[5] == 'e' && pend[6] == 'f' &&
			pend[7] >= '0' && pend[7] <= '9')
		    {
			i = pend[7] - '0';
			sprintf(varbuf, "%0.4d", xvariable);
			strncpy(pend+4, varbuf, 4);
			xvariables[i] = xvariable;
			xvariable = (xvariable + 1) % 10000;
		    }
		    else if (pend[4] == 'u' && pend[5] == 's' &&
			     pend[6] == 'e' && pend[7] >= '0' &&
			     pend[7] <= '9')
		    {
			i = pend[7] - '0';
			sprintf(varbuf, "%0.4d", xvariables[i]);
			strncpy(pend+4, varbuf, 4);
d1869 1
a1870 1
#endif
d1873 1
a1873 1
	while (--pend >= line && (*pend == ' ' || *pend == '\t')) ;
d1890 2
a1891 2
		int	total_red;
		struct stat	st;
d1901 1
a1901 1
		if (total_red == 0  &&  st.st_size != 0)
d1933 5
a1937 1
#ifdef WIN32
d1940 1
d1972 1
a1972 1
#ifdef FIXUP_CPP_WHITESPACE
d1983 1
a1983 1
	    	break;
d1986 10
a1995 5
# ifdef INLINE_SYNTAX
		if (*p == '<' && p[1] == '<') { /* inline file close */
		    InInline--;
		    InRule = TRUE;
		    break;
d1997 1
a1997 1
# endif
d1999 1
a1999 1
		 * The following cases should not be treated as beginning of 
d2001 3
a2003 3
		 * variable := name	(GNU make)
		 * variable = .*:.*	(':' should be allowed as value)
		 *	sed 's:/a:/b:'	(: used in quoted values)
d2009 6
a2014 2
# ifdef WIN32
			     quotechar != ')' &&
d2036 9
a2044 4
# ifdef REMOVE_CPP_LEADSPACE
			if (!InRule && **pline == ' ') {
			    while (**pline == ' ')
				(*pline)++;
d2046 1
a2046 1
# endif
d2048 1
a2048 1
# ifdef INLINE_SYNTAX
d2050 4
a2053 2
			if (p[1] == '<') /* inline file start */
			    InInline++;
d2055 1
a2055 1
# endif
d2077 1
a2077 2
#endif /* FIXUP_CPP_WHITESPACE */

d2086 35
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d10 1
a10 1
/* $XFree86: xc/config/imake/imake.c,v 3.64 2003/03/26 20:43:47 tsi Exp $ */
d13 2
a14 2
 *
Copyright (c) 1985, 1986, 1987, 1998 The Open Group
d35 1
a35 1
 *
d60 1
a60 1
 *		-e[F]	execute instead of show; optionally name Makefile F
d64 1
a64 1
 *
d107 3
a109 3
 *	- If DEFAULT_MACHINE_ARCITECTURE is defined, format the utsname struct
 *	  and define the corresponding macro.  (For example on the amiga,
 *	  this will define amiga in addition to m68k).
d111 1
a111 1
 *	  directory, print a warning message to stderr and add:
d115 1
a115 1
 *	  directory, print a warning message to stderr and add:
d123 1
a123 1
 *	  directory, print a warning message to stderr and add:
d127 1
a127 1
 *	  directory, print a warning message to stderr and add:
d230 1
a230 1
# include <stdlib.h>
d242 3
d265 2
d284 1
a284 1
#if !(defined(Lynx) || defined(__Lynx__) || (defined(SVR4) && !defined(sun))) && !defined (__CYGWIN__)
d288 2
a289 3
typedef unsigned char boolean;
#define TRUE		1
#define FALSE		0
d291 5
a295 10
# include "imakemdep.h"
#ifdef CROSSCOMPILE
# include "imakemdep_cpp.h"
#endif

#if defined CROSSCOMPILE || defined FIXUP_CPP_WHITESPACE
int InRule = FALSE;
#endif
#if defined CROSSCOMPILE || defined INLINE_SYNTAX
int InInline = 0;
d297 1
a297 1
#if defined CROSSCOMPILE || defined MAGIC_MAKE_VARS
a301 4
#ifndef PATH_MAX
#define PATH_MAX 1024
#endif

d307 1
d309 4
d314 12
a325 12
#ifndef CROSSCOMPILE
# ifdef USE_CC_E
#  ifndef DEFAULT_CC
#   define DEFAULT_CC "cc"
#  endif
# else
#  ifndef DEFAULT_CPP
#   ifdef CPP_PROGRAM
#    define DEFAULT_CPP CPP_PROGRAM
#   else
#    define DEFAULT_CPP "/lib/cpp"
#   endif
d332 2
a333 2
char	*tmpMakefile = "/tmp/Imf.XXXXXX";
char	*tmpImakefile = "/tmp/IIf.XXXXXX";
d356 2
a357 2
void	LogFatalI(char *s, int i), LogFatal(char *x0, char *x1),
	LogMsg(char *x0, char *x1);
a363 3
#ifdef CROSSCOMPILE
char	*CrossCompileCPP(void);
#endif
d366 1
a366 1
void	cppit(char *imakefile, char *template, char *masterc,
d370 1
a370 1
boolean isempty(char *line);
d373 1
a373 1
int	catch(int sig);
d375 1
a375 1
void	catch(int sig);
d377 1
a377 1
void	showargs(char **argv);
d379 1
a379 1
void	  doit(FILE *outfd, char *cmd, char **argv);
a380 10
#ifdef CROSSCOMPILE
static void get_cross_compile_dir(FILE *inFile);
#endif
#ifdef CROSSCOMPILEDIR
char *CrossCompileDir = CROSSCOMPILEDIR;
#else
char *CrossCompileDir = "";
#endif
boolean CrossCompiling = FALSE;

d383 2
a384 2
boolean verbose = FALSE;
boolean show = TRUE;
a391 1
	int	lenCrossCompileDir = 0;
d395 1
a396 10
	lenCrossCompileDir = strlen(CrossCompileDir);
	if (lenCrossCompileDir) {
	    if (lenCrossCompileDir > (PATH_MAX - 20))
	      LogFatal("Cross compile directory path too long %s\n",
		       CrossCompileDir);
	    else
		CrossCompiling = TRUE;
	}

	SetOpts(argc, argv);
d400 3
a402 3
		tmpMakefile = Makefile;
		if ((tmpfd = fopen(tmpMakefile, "w+")) == NULL)
		   LogFatal("Cannot create temporary file %s.", tmpMakefile);
d405 1
a405 1
		int fd;
d414 2
a415 2
		fd = mkstemp(tmpMakefile);
		if (fd == -1 || (tmpfd = fdopen(fd, "w+")) == NULL) {
d492 1
a492 7
#if defined CROSSCOMPILE
	if (sys == netBSD)
	  if (CrossCompiling) {
	    LogFatal("fix imake to do crosscompiling for NetBSD\n","");
	  } else
#endif
#if defined(__NetBSD__) || defined CROSSCOMPILE
a563 1

d630 3
a632 5

#ifndef CROSSCOMPILE
# ifdef USE_CC_E
	    if (!cpp)
	    {
a633 4
#ifdef __GNUC__
		if (verbose)
		    AddCppArg("-v");
#endif
d635 3
a637 3
	    }
# else
	    if (!cpp)
a638 4
# endif
#else
	    if (!cpp)
		cpp = CrossCompileCPP();
a639 1

d672 1
a672 1
	static boolean entered = FALSE;
d719 1
a719 1
		     strncmp(mkcbuf, ImakefileCHeader,
d733 1
a733 1
#define OverrideWarning "Warning: local file \"%s\" overrides global macros."
d750 1
a750 1
	int		pid;
d788 1
a788 1
#if !defined WIN32
a795 3
  if (!name)
      LogFatal(msg,fmt);

d858 1
a858 1

d872 1
a872 1
#if defined linux
d877 1
a877 1
"#if 1\n"
d881 4
a894 2
"  const char * ptr = NULL;\n"
"  int glibcmajor = 0;\n"
d896 4
a899 11
"  if (gnu_get_libc_version != 0)\n"
"  {\n"
"    ptr = gnu_get_libc_version ();\n"
"    glibcmajor = 4;\n"
"  }\n"
"  else if (&__libc_version != 0)\n"
"  {\n"
"    ptr = __libc_version;\n"
"    glibcmajor = 4;\n"
"  }\n"
"  else if (&__linux_C_lib_version != 0)\n"
d901 3
a903 1
"    ptr = __linux_C_lib_version;\n"
d907 15
a921 2
"    libcmajor = 0; libcminor = 0; libcteeny = 0;\n"
"  }\n"
a922 2
"  if (ptr)\n"
"  {\n"
d939 47
d1026 1
a1026 1

a1031 85
#endif

#if defined(__OpenBSD__) 
static void
get_stackprotector(FILE *inFile)
{
  FILE *fp;
  char *cc;
  char command[1024], buf[1024];
  
  cc = getenv("CC");
  if (cc == NULL) {
    cc = "cc";
  }
  snprintf(command, sizeof(command), "%s -v 2>&1", cc);
  fp = popen(command, "r");
  if (fp == NULL) 
    abort();
  while (fgets(buf, sizeof(buf), fp)) {
    if (strstr(buf, "propolice") != NULL) {
      fprintf(inFile, "#define HasGccStackProtector YES\n");
      break;
    }
  }
  if (pclose(fp)) 
    abort();
}
#endif
	

#if defined CROSSCOMPILE || defined linux
static void
get_distrib(FILE *inFile)
{
  struct stat sb;

  static char* suse = "/etc/SuSE-release";
  static char* redhat = "/etc/redhat-release";
  static char* debian = "/etc/debian_version";

  fprintf (inFile, "%s\n", "#define LinuxUnknown    0");
  fprintf (inFile, "%s\n", "#define LinuxSuSE       1");
  fprintf (inFile, "%s\n", "#define LinuxCaldera    2");
  fprintf (inFile, "%s\n", "#define LinuxCraftworks 3");
  fprintf (inFile, "%s\n", "#define LinuxDebian     4");
  fprintf (inFile, "%s\n", "#define LinuxInfoMagic  5");
  fprintf (inFile, "%s\n", "#define LinuxKheops     6");
  fprintf (inFile, "%s\n", "#define LinuxPro        7");
  fprintf (inFile, "%s\n", "#define LinuxRedHat     8");
  fprintf (inFile, "%s\n", "#define LinuxSlackware  9");
  fprintf (inFile, "%s\n", "#define LinuxTurbo      10");
  fprintf (inFile, "%s\n", "#define LinuxWare       11");
  fprintf (inFile, "%s\n", "#define LinuxYggdrasil  12");

#ifdef CROSSCOMPILE
  if (CrossCompiling) {
      fprintf (inFile, "%s\n",
	       "#define DefaultLinuxDistribution LinuxUnknown");
      fprintf (inFile, "%s\n", "#define DefaultLinuxDistName Unknown");
      return;
  }
#endif
  if (lstat (suse, &sb) == 0) {
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxSuSE");
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistName SuSE");
    return;
  }
  if (lstat (redhat, &sb) == 0) {
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxRedHat");
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistName RedHat");
    return;
  }
  if (lstat (debian, &sb) == 0) {
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxDebian");
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistName Debian");
    /* You could also try to get the version of the Debian distrib by looking
     * at the content of /etc/debian_version */
    return;
  }
  /* what's the definitive way to tell what any particular distribution is? */

  fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxUnknown");
  fprintf (inFile, "%s\n", "#define DefaultLinuxDistName Unknown");
  /* would like to know what version of the distribution it is */
}
d1036 1
a1036 1
  FILE* ldprog;
a1038 12
  const char *ld = "ld -v";

#ifdef CROSSCOMPILE
  if (CrossCompiling) {
      char cmd[PATH_MAX];
      strcpy (cmd, CrossCompileDir);
      strcat (cmd,"/");
      strcat (cmd,ld);
      ldprog = popen (cmd, "r");
  } else
#endif
      ldprog = popen (ld, "r");
d1051 2
a1052 3

    fprintf(inFile, "#define DefaultLinuxBinUtilsMajorVersion %d\n",
	    ldmajor + ldminor);
d1058 1
a1058 1
#if defined __FreeBSD__
a1067 1
  char cmd[PATH_MAX];
a1072 7
  if (CrossCompiling) {
      strcpy (cmd, CrossCompileDir);
      strcat (cmd, "/");
      strcat (cmd,"objformat");
  } else
      strcpy (cmd, "objformat");

d1074 1
a1074 1
      (objprog = popen(cmd, "r")) != NULL &&
d1085 4
a1101 12
#if defined CROSSCOMPILE
  if (CrossCompiling) {
      int len = strlen(CrossCompileDir);
      len += 3;
      sunpro_cc = (char *) malloc(len);
      sunpro_CC = (char *) malloc(len);
      strcpy(sunpro_cc,CrossCompileDir);
      strcpy(sunpro_CC,CrossCompileDir);
      strcat(sunpro_cc,"/cc");
      strcat(sunpro_CC,"/CC");
  }
#endif
d1110 1
a1110 1
	fprintf (inFile,
d1113 1
a1113 1
	fprintf (inFile,
d1129 1
a1129 1
	fprintf (inFile,
d1132 1
a1132 1
	fprintf (inFile,
d1143 1
a1143 1
#if defined CROSSCOMPILE || defined  __GNUC__
d1145 1
a1145 1
get_gcc_version(FILE *inFile, char *name)
d1147 21
a1167 12
    fprintf (inFile, "#define HasGcc 1\n");
#ifdef CROSSCOMPILE
    if (CrossCompiling)
    {
	if (gnu_c > 1) {
	    fprintf (inFile, "#define HasGcc2 1\n");
	    if (gnu_c > 2)
		fprintf (inFile, "#define HasGcc3 1\n");
	}
	fprintf (inFile, "#define GccMajorVersion %d\n", gnu_c);
	fprintf (inFile, "#define GccMinorVersion %d\n", gnu_c_minor);
    } else
d1169 7
a1175 1
    {
d1177 1
a1177 4
	fprintf (inFile, "#define HasGcc2 1\n");
# if __GNUC__ > 2
	fprintf (inFile, "#define HasGcc3 1\n");
# endif
d1179 2
a1180 3
	fprintf (inFile, "#define GccMajorVersion %d\n", __GNUC__);
	fprintf (inFile, "#define GccMinorVersion %d\n", __GNUC_MINOR__);
    }
d1182 1
a1182 1
    fprintf (inFile, "#define HasGccMergeConstants %d\n", HAS_MERGE_CONSTANTS);
d1187 3
a1189 2
static boolean
get_gcc(char *cmd)
d1191 7
d1199 1
a1199 49
    static char* gcc_path[] = {
# if defined(linux) || \
     defined(__NetBSD__) || \
     defined(__OpenBSD__) || \
     defined(__FreeBSD__) || \
     defined(__APPLE__) || \
     defined(__GNU__)
	"/usr/bin/cc",	/* for Linux PostIncDir */
# endif
	"/usr/local/bin/gcc",
	"/opt/gnu/bin/gcc",
	"/usr/pkg/bin/gcc"
    };

#ifdef CROSSCOMPILE
    static char* cross_cc_name[] = {
	"cc",
	"gcc"
    };

    if (CrossCompiling) {
	int i;
	for (i = 0; i < sizeof (cross_cc_name) / sizeof cross_cc_name[0]; i++){
	    strcpy (cmd, CrossCompileDir);
	    strcat (cmd, "/");
	    strcat (cmd, cross_cc_name[i]);
	    if (lstat (cmd, &sb) == 0) {
		return TRUE;
		break;
	    }
	}
    } else
#endif
      {
	int i;
	for (i = 0; i < sizeof (gcc_path) / sizeof gcc_path[0]; i++) {
	    if (lstat (gcc_path[i], &sb) == 0) {
		strcpy (cmd, gcc_path[i]);
		return TRUE;
	    }
	}
      }
    return FALSE;
}

#if defined CROSSCOMPILE || !defined __UNIXOS2__
static void
get_gcc_incdir(FILE *inFile, char* name)
{
a1204 2
  strcpy(cmd,name);

d1206 6
a1211 3
  strcat (cmd, " --print-libgcc-file-name");
  if ((gccproc = popen (cmd, "r")) != NULL) {
      if (fgets (buf, PATH_MAX, gccproc) != NULL) {
d1214 3
d1218 1
a1218 1
      (void) pclose (gccproc);
a1219 1

d1221 1
a1221 1
      fprintf (inFile, "#define DefaultGccIncludeDir \"%s\"\n", buf);
d1228 2
a1229 6
#if defined CROSSCOMPILE || ( !defined(WIN32) && !defined(__UNIXOS2__) )
#ifdef CROSSCOMPILE
  if ((sys != win32) && (sys != emx))
#endif
    {
# if (defined(DEFAULT_OS_NAME) || defined(DEFAULT_OS_MAJOR_REV) || \
d1231 1
a1231 2
	struct utsname *name = NULL;
	struct utsname uts_name;
d1235 2
a1236 18
#ifdef CROSSCOMPILE
      if (!CrossCompiling)
#endif
      {
	  if (uname(&uts_name) < 0)
	      LogFatal("Cannot invoke uname", "");
	  else
	      name = &uts_name;
      }
#if defined CROSSCOMPILE && defined linux
      else {
	  strncpy(uts_name.sysname,cross_uts_sysname,SYS_NMLN);
	  strncpy(uts_name.release,cross_uts_release,SYS_NMLN);
	  strncpy(uts_name.version,cross_uts_version,SYS_NMLN);
	  strncpy(uts_name.machine,cross_uts_machine,SYS_NMLN);
	  name = &uts_name;
      }
#endif
d1238 5
a1242 13
#  if defined DEFAULT_OS_NAME
#   if defined CROSSCOMPILE
      if (!CrossCompiling)
#   endif
	{
	  parse_utsname(name, DEFAULT_OS_NAME, buf,
			"Bad DEFAULT_OS_NAME syntax %s");
#   ifdef DEFAULT_OS_NAME_FROB
	  DEFAULT_OS_NAME_FROB(buf, sizeof buf);
#   endif
	  if (buf[0] != '\0')
	    fprintf(inFile, "#define DefaultOSName %s\n", buf);
	}
d1244 3
d1248 5
a1252 9
#  if defined CROSSCOMPILE
	if (CrossCompiling && defaultOsName) {
	  parse_utsname(name, defaultOsName, buf,
			"Bad DEFAULT_OS_NAME syntax %s");
	  if (defaultOsNameFrob)
	    defaultOsNameFrob(buf, sizeof buf);
	  if (buf[0] != '\0')
	    fprintf(inFile, "#define DefaultOSName %s\n", buf);
	}
d1254 3
d1258 5
a1262 13
#  ifdef DEFAULT_OS_MAJOR_REV
#   if defined CROSSCOMPILE
	if (!CrossCompiling)
#   endif
	  {
	    parse_utsname(name, DEFAULT_OS_MAJOR_REV, buf,
			  "Bad DEFAULT_OS_MAJOR_REV syntax %s");
#   ifdef DEFAULT_OS_MAJOR_REV_FROB
	    DEFAULT_OS_MAJOR_REV_FROB(buf, sizeof buf);
#   endif
	    fprintf(inFile, "#define DefaultOSMajorVersion %s\n",
		    *buf ? trim_version(buf) : "0");
	  }
d1264 3
d1268 5
a1272 80
#  if defined CROSSCOMPILE
	if (CrossCompiling && defaultOsMajorRev) {
	  parse_utsname(name, defaultOsMajorRev, buf,
			"Bad defaultOsMajorRev syntax %s");
	  if (defaultOsMajorRevFrob)
	    defaultOsMajorRevFrob(buf, sizeof buf);
	  fprintf(inFile, "#define DefaultOSMajorVersion %s\n",
		  *buf ? trim_version(buf) : "0");
	}
#  endif

#  ifdef DEFAULT_OS_MINOR_REV
#   if defined CROSSCOMPILE
	if (!CrossCompiling)
#   endif
	  {
	    parse_utsname(name, DEFAULT_OS_MINOR_REV, buf,
			  "Bad DEFAULT_OS_MINOR_REV syntax %s");
#   ifdef DEFAULT_OS_MINOR_REV_FROB
	    DEFAULT_OS_MINOR_REV_FROB(buf, sizeof buf);
#   endif
	    fprintf(inFile, "#define DefaultOSMinorVersion %s\n",
		    *buf ? trim_version(buf) : "0");
	  }
#  endif

#  if defined CROSSCOMPILE
	if (CrossCompiling && defaultOsMinorRev) {
	  parse_utsname(name, defaultOsMinorRev, buf,
			"Bad defaultOsMinorRev syntax %s");
	  if (defaultOsMinorRevFrob)
	    defaultOsMinorRevFrob(buf, sizeof buf);
	  fprintf(inFile, "#define DefaultOSMinorVersion %s\n",
		  *buf ? trim_version(buf) : "0");
	}
#  endif

#  ifdef DEFAULT_OS_TEENY_REV
#   if defined CROSSCOMPILE
	if (!CrossCompiling)
#   endif
	  {
	    parse_utsname(name, DEFAULT_OS_TEENY_REV, buf,
			  "Bad DEFAULT_OS_TEENY_REV syntax %s");
#   ifdef DEFAULT_OS_TEENY_REV_FROB
	    DEFAULT_OS_TEENY_REV_FROB(buf, sizeof buf);
#   endif
	    fprintf(inFile, "#define DefaultOSTeenyVersion %s\n",
		    *buf ? trim_version(buf) : "0");
	  }
#  endif

#  if defined CROSSCOMPILE
	if (CrossCompiling && defaultOsTeenyRev) {
	  parse_utsname(name, defaultOsTeenyRev, buf,
			"Bad defaultOsTeenyRev syntax %s");
	  if (defaultOsTeenyRevFrob)
	    defaultOsTeenyRevFrob(buf, sizeof buf);
	  fprintf(inFile, "#define DefaultOSTeenyVersion %s\n",
		  *buf ? trim_version(buf) : "0");
	}
#  endif

#  ifdef DEFAULT_MACHINE_ARCHITECTURE
#   if defined CROSSCOMPILE
	if (!CrossCompiling)
#   endif
	  {
	    parse_utsname(name, DEFAULT_MACHINE_ARCHITECTURE, buf,
			  "Bad DEFAULT_MACHINE_ARCHITECTURE %s");
	    fprintf(inFile, "#ifndef %s\n# define %s\n#endif\n", buf, buf);
	  }
#  endif

#  if defined CROSSCOMPILE
	if (CrossCompiling && defaultMachineArchitecture) {
	  parse_utsname(name, defaultMachineArchitecture, buf,
			"Bad defaultMachineArchitecture syntax %s");
	  fprintf(inFile, "#ifndef %s\n# define %s\n#endif\n", buf, buf);
	}
d1274 2
d1277 4
a1280 4
# if defined CROSSCOMPILE
      if (CrossCompiling)
	get_cross_compile_dir(inFile);
      else
a1281 82
	  fprintf(inFile, "#define CrossCompiling NO\n");
# if defined CROSSCOMPILE
      if (CrossCompiling && sys == LinuX)
# endif
# if defined CROSSCOMPILE || defined linux
#  ifdef CROSSCOMPILE
	if (sys == LinuX)
#  endif
	  get_distrib (inFile);
# endif
# if defined linux
#  if defined CROSSCOMPILE
      if (!CrossCompiling)
#  endif
	  get_libc_version (inFile);
#  if defined CROSSCOMPILE
      else {
	  fprintf(inFile,"#define DefaultLinuxCLibMajorVersion %d\n",
		  glibc_major);
	  fprintf(inFile,"#define DefaultLinuxCLibMinorVersion %d\n",
		  glibc_minor);
	  fprintf(inFile,"#define DefaultLinuxCLibTeenyVersion 0\n");
      }
#  endif
# endif /* linux */
# if defined CROSSCOMPILE || defined linux
#  if defined CROSSCOMPILE
      if (sys == LinuX)
#  endif
	  get_ld_version(inFile);
# endif
# if defined (sun) && defined(SVR4)
      get_sun_compiler_versions (inFile);
# endif
# if defined CROSSCOMPILE || defined __GNUC__
#  if defined CROSSCOMPILE
      if (gnu_c)
#  endif
	{
	  char name[PATH_MAX];
	  if (get_gcc(name)) {
	      get_gcc_version (inFile,name);
#  if defined CROSSCOMPILE || !defined __UNIXOS2__
#   if defined CROSSCOMPILE
	      if (sys != emx)
#   endif
		  get_gcc_incdir(inFile,name);
#  endif
	  }
	}
# endif
# if defined __FreeBSD__
#  if defined CROSSCOMPILE
      if (sys == freeBSD)
#  endif
	  get_binary_format(inFile);
# endif
    }
#endif /* !WIN32 && !__UNIXOS2__*/
#if defined WIN32
# ifdef CROSSCOMPILE
  else if (sys == win32 && !CrossCompiling)
# endif
    {
      OSVERSIONINFO osvi;
      static char* os_names[] = { "Win32s", "Windows 95", "Windows NT" };

      memset(&osvi, 0, sizeof(OSVERSIONINFO));
      osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
      GetVersionEx (&osvi);

      fprintf (inFile, "#define DefaultOSName Microsoft %s\n",
	       os_names[osvi.dwPlatformId]);

      fprintf(inFile, "#define DefaultOSMajorVersion %d\n", osvi.dwMajorVersion);
      fprintf(inFile, "#define DefaultOSMinorVersion %d\n", osvi.dwMinorVersion);
      fprintf(inFile, "#define DefaultOSTeenyVersion %d\n",
	      osvi.dwBuildNumber & 0xFFFF);
    }
#endif /* WIN32 */
#ifdef CROSSCOMPILE
  else if (sys == emx)
d1283 38
a1320 6
#if defined CROSSCOMPILE || defined __UNIXOS2__
    {
      fprintf(inFile, "#define DefaultOSMajorVersion 4\n");
      fprintf(inFile, "#define DefaultOSMinorVersion 0\n");
      fprintf(inFile, "#define DefaultOSTeenyVersion 0\n");
    }
d1322 2
a1323 4
#if defined(__OpenBSD__)
  get_stackprotector(inFile);
#endif
  return FALSE;
d1327 1
a1327 1
cppit(char *imakefile, char *template, char *masterc,
d1345 1
a1345 1
	    fflush(inFile) ||
d1384 1
a1384 1
	if (count == 0 && st.st_size != 0)
d1399 1
a1399 1
		while (*pend && *pend != ' ' && *pend != '\t' && *pend != '\n' && *pend != '\r')
d1417 1
a1417 1
			int fd;
a1453 1

d1470 1
a1470 6
#ifdef CROSSCOMPILE
			if (fixup_whitespace)
#endif
#if defined CROSSCOMPILE || defined FIXUP_CPP_WHITESPACE
			    KludgeResetRule();
#endif
d1473 1
a1473 6
#ifdef CROSSCOMPILE
			if (fixup_whitespace)
#endif
#if defined CROSSCOMPILE || defined FIXUP_CPP_WHITESPACE
			    KludgeOutputLine(&input);
#endif
d1513 1
a1513 1
			do {
d1527 2
a1528 2
		    (pend == line || pend[-1] == ' ' || pend[-1] == '\t' || pend[-1] == '\r') &&
		    (pend[5] == ' ' || pend[5] == '\t' || pend[5] == '\r' || pend[5] == '\0'))
d1531 1
a1531 1
		    memmove(pend+1, pend+5, strlen(pend+5)+1);
d1533 19
a1551 7
#ifdef CROSSCOMPILE
		if (magic_make_vars)
#endif
		  {
#if defined CROSSCOMPILE || defined MAGIC_MAKE_VARS
		    if (*pend == 'X' && pend[1] == 'V' && pend[2] == 'A' &&
			pend[3] == 'R')
d1553 3
a1555 20
			char varbuf[5];
			int i;

			if (pend[4] == 'd' && pend[5] == 'e' && pend[6] == 'f' &&
			    pend[7] >= '0' && pend[7] <= '9')
			{
			    i = pend[7] - '0';
			    sprintf(varbuf, "%0.4d", xvariable);
			    strncpy(pend+4, varbuf, 4);
			    xvariables[i] = xvariable;
			    xvariable = (xvariable + 1) % 10000;
			}
			else if (pend[4] == 'u' && pend[5] == 's' &&
				 pend[6] == 'e' && pend[7] >= '0' &&
				 pend[7] <= '9')
			{
			    i = pend[7] - '0';
			    sprintf(varbuf, "%0.4d", xvariables[i]);
			    strncpy(pend+4, varbuf, 4);
			}
d1557 1
a1558 1
		}
d1561 1
a1561 1
	while (--pend >= line && (*pend == ' ' || *pend == '\t' || *pend == '\r')) ;
d1578 2
a1579 2
		int total_red;
		struct stat st;
d1589 1
a1589 1
		if (total_red == 0 && st.st_size != 0)
d1621 1
a1621 5
#if defined CROSSCOMPILE || defined WIN32
# if defined CROSSCOMPILE
		  if (sys == win32)
# endif
		    {
a1623 1
		    }
d1655 1
a1655 1
#if defined CROSSCOMPILE || defined FIXUP_CPP_WHITESPACE
d1666 1
a1666 1
		break;
d1669 5
a1673 10
#ifdef CROSSCOMPILE
		if (inline_syntax)
#endif
#if defined CROSSCOMPILE || defined INLINE_SYNTAX
		{
		    if (*p == '<' && p[1] == '<') { /* inline file close */
			InInline--;
			InRule = TRUE;
			break;
		    }
d1675 1
a1675 1
#endif
d1677 1
a1677 1
		 * The following cases should not be treated as beginning of
d1679 3
a1681 3
		 * variable := name (GNU make)
		 * variable = .*:.* (':' should be allowed as value)
		 * sed 's:/a:/b:'   (: used in quoted values)
d1687 2
a1688 6
# if defined CROSSCOMPILE || defined WIN32
			     (
#  if defined CROSSCOMPILE
			      (sys == win32) &&
#  endif
			      quotechar != ')') &&
d1710 4
a1713 9
#ifdef CROSSCOMPILE
			if (remove_cpp_leadspace)
#endif
#if defined CROSSCOMPILE || defined REMOVE_CPP_LEADSPACE
			{
			    if (!InRule && **pline == ' ') {
				while (**pline == ' ')
				    (*pline)++;
			    }
d1715 1
a1715 1
#endif
d1717 1
a1717 1
#if defined CROSSCOMPILE || defined INLINE_SYNTAX
d1719 2
a1720 4
			if (inline_syntax) {
			    if (p[1] == '<') /* inline file start */
				InInline++;
			}
d1722 1
a1722 1
#endif
d1744 2
a1745 1
#endif
a1753 35

#ifdef CROSSCOMPILE
char*
CrossCompileCPP(void)
{
    char *cpp, *c;
    int len ;
    if (crosscompile_use_cc_e)
	AddCppArg("-E");

    cpp = strrchr(crosscompile_cpp,'/');
    if (!cpp)
	cpp = crosscompile_cpp;
    else
	cpp++;

    len = strlen(cpp) + strlen(CrossCompileDir) + 2;
    c = Emalloc(len);

    (void)snprintf(c, len,"%s/%s",CrossCompileDir,cpp);

    return c;
}

#endif

#ifdef CROSSCOMPILE
static void
get_cross_compile_dir(FILE *inFile)
{
	fprintf(inFile, "#define CrossCompileDir %s\n",
		CrossCompileDir);
	fprintf(inFile, "#define CrossCompiling YES\n");
}
#endif
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d10 1
a10 1
/* $XFree86: xc/config/imake/imake.c,v 3.63 2002/12/16 22:48:27 herrb Exp $ */
d13 2
a14 2
 *
Copyright (c) 1985, 1986, 1987, 1998 The Open Group
d35 1
a35 1
 *
d60 1
a60 1
 *		-e[F]	execute instead of show; optionally name Makefile F
d64 1
a64 1
 *
d107 3
a109 3
 *	- If DEFAULT_MACHINE_ARCITECTURE is defined, format the utsname struct
 *	  and define the corresponding macro.  (For example on the amiga,
 *	  this will define amiga in addition to m68k).
d111 1
a111 1
 *	  directory, print a warning message to stderr and add:
d115 1
a115 1
 *	  directory, print a warning message to stderr and add:
d123 1
a123 1
 *	  directory, print a warning message to stderr and add:
d127 1
a127 1
 *	  directory, print a warning message to stderr and add:
d230 1
a230 1
# include <stdlib.h>
d242 3
d265 2
d284 1
a284 1
#if !(defined(Lynx) || defined(__Lynx__) || (defined(SVR4) && !defined(sun))) && !defined (__CYGWIN__)
d288 2
a289 3
typedef unsigned char boolean;
#define TRUE		1
#define FALSE		0
d291 5
a295 10
# include "imakemdep.h"
#ifdef CROSSCOMPILE
# include "imakemdep_cpp.h"
#endif

#if defined CROSSCOMPILE || defined FIXUP_CPP_WHITESPACE
int InRule = FALSE;
#endif
#if defined CROSSCOMPILE || defined INLINE_SYNTAX
int InInline = 0;
d297 1
a297 1
#if defined CROSSCOMPILE || defined MAGIC_MAKE_VARS
a301 4
#ifndef PATH_MAX
#define PATH_MAX 1024
#endif

d307 1
d309 4
d314 12
a325 12
#ifndef CROSSCOMPILE
# ifdef USE_CC_E
#  ifndef DEFAULT_CC
#   define DEFAULT_CC "cc"
#  endif
# else
#  ifndef DEFAULT_CPP
#   ifdef CPP_PROGRAM
#    define DEFAULT_CPP CPP_PROGRAM
#   else
#    define DEFAULT_CPP "/lib/cpp"
#   endif
d332 2
a333 2
char	*tmpMakefile = "/tmp/Imf.XXXXXX";
char	*tmpImakefile = "/tmp/IIf.XXXXXX";
d356 2
a357 2
void	LogFatalI(char *s, int i), LogFatal(char *x0, char *x1),
	LogMsg(char *x0, char *x1);
a363 3
#ifdef CROSSCOMPILE
char	*CrossCompileCPP(void);
#endif
d366 1
a366 1
void	cppit(char *imakefile, char *template, char *masterc,
d370 1
a370 1
boolean isempty(char *line);
d373 1
a373 1
int	catch(int sig);
d375 1
a375 1
void	catch(int sig);
d377 1
a377 1
void	showargs(char **argv);
d379 1
a379 1
void	  doit(FILE *outfd, char *cmd, char **argv);
a380 10
#ifdef CROSSCOMPILE
static void get_cross_compile_dir(FILE *inFile);
#endif
#ifdef CROSSCOMPILEDIR
char *CrossCompileDir = CROSSCOMPILEDIR;
#else
char *CrossCompileDir = "";
#endif
boolean CrossCompiling = FALSE;

d383 2
a384 2
boolean verbose = FALSE;
boolean show = TRUE;
a391 1
	int	lenCrossCompileDir = 0;
d395 1
a396 10
	lenCrossCompileDir = strlen(CrossCompileDir);
	if (lenCrossCompileDir) {
	    if (lenCrossCompileDir > (PATH_MAX - 20))
	      LogFatal("Cross compile directory path too long %s\n",
		       CrossCompileDir);
	    else
		CrossCompiling = TRUE;
	}

	SetOpts(argc, argv);
d400 3
a402 3
		tmpMakefile = Makefile;
		if ((tmpfd = fopen(tmpMakefile, "w+")) == NULL)
		   LogFatal("Cannot create temporary file %s.", tmpMakefile);
d405 1
a405 1
		int fd;
d414 2
a415 2
		fd = mkstemp(tmpMakefile);
		if (fd == -1 || (tmpfd = fdopen(fd, "w+")) == NULL) {
d492 1
a492 7
#if defined CROSSCOMPILE
	if (sys == netBSD)
	  if (CrossCompiling) {
	    LogFatal("fix imake to do crosscompiling for NetBSD\n","");
	  } else
#endif
#if defined(__NetBSD__) || defined CROSSCOMPILE
a563 1

d630 3
a632 5

#ifndef CROSSCOMPILE
# ifdef USE_CC_E
	    if (!cpp)
	    {
a633 4
#ifdef __GNUC__
		if (verbose)
		    AddCppArg("-v");
#endif
d635 3
a637 3
	    }
# else
	    if (!cpp)
a638 4
# endif
#else
	    if (!cpp)
		cpp = CrossCompileCPP();
a639 1

d672 1
a672 1
	static boolean entered = FALSE;
d719 1
a719 1
		     strncmp(mkcbuf, ImakefileCHeader,
d733 1
a733 1
#define OverrideWarning "Warning: local file \"%s\" overrides global macros."
d750 1
a750 1
	int		pid;
d788 1
a788 1
#if !defined WIN32
a795 3
  if (!name)
      LogFatal(msg,fmt);

d858 1
a858 1

d872 1
a872 1
#if defined linux
d877 1
a877 1
"#if 1\n"
d881 4
a894 2
"  const char * ptr = NULL;\n"
"  int glibcmajor = 0;\n"
d896 4
a899 11
"  if (gnu_get_libc_version != 0)\n"
"  {\n"
"    ptr = gnu_get_libc_version ();\n"
"    glibcmajor = 4;\n"
"  }\n"
"  else if (&__libc_version != 0)\n"
"  {\n"
"    ptr = __libc_version;\n"
"    glibcmajor = 4;\n"
"  }\n"
"  else if (&__linux_C_lib_version != 0)\n"
d901 3
a903 1
"    ptr = __linux_C_lib_version;\n"
d907 15
a921 2
"    libcmajor = 0; libcminor = 0; libcteeny = 0;\n"
"  }\n"
a922 2
"  if (ptr)\n"
"  {\n"
d939 47
d1026 1
a1026 1

a1031 85
#endif

#if defined(__OpenBSD__) 
static void
get_stackprotector(FILE *inFile)
{
  FILE *fp;
  char *cc;
  char command[1024], buf[1024];
  
  cc = getenv("CC");
  if (cc == NULL) {
    cc = "cc";
  }
  snprintf(command, sizeof(command), "%s -v 2>&1", cc);
  fp = popen(command, "r");
  if (fp == NULL) 
    abort();
  while (fgets(buf, sizeof(buf), fp)) {
    if (strstr(buf, "propolice") != NULL) {
      fprintf(inFile, "#define HasGccStackProtector YES\n");
      break;
    }
  }
  if (pclose(fp)) 
    abort();
}
#endif
	

#if defined CROSSCOMPILE || defined linux
static void
get_distrib(FILE *inFile)
{
  struct stat sb;

  static char* suse = "/etc/SuSE-release";
  static char* redhat = "/etc/redhat-release";
  static char* debian = "/etc/debian_version";

  fprintf (inFile, "%s\n", "#define LinuxUnknown    0");
  fprintf (inFile, "%s\n", "#define LinuxSuSE       1");
  fprintf (inFile, "%s\n", "#define LinuxCaldera    2");
  fprintf (inFile, "%s\n", "#define LinuxCraftworks 3");
  fprintf (inFile, "%s\n", "#define LinuxDebian     4");
  fprintf (inFile, "%s\n", "#define LinuxInfoMagic  5");
  fprintf (inFile, "%s\n", "#define LinuxKheops     6");
  fprintf (inFile, "%s\n", "#define LinuxPro        7");
  fprintf (inFile, "%s\n", "#define LinuxRedHat     8");
  fprintf (inFile, "%s\n", "#define LinuxSlackware  9");
  fprintf (inFile, "%s\n", "#define LinuxTurbo      10");
  fprintf (inFile, "%s\n", "#define LinuxWare       11");
  fprintf (inFile, "%s\n", "#define LinuxYggdrasil  12");

#ifdef CROSSCOMPILE
  if (CrossCompiling) {
      fprintf (inFile, "%s\n",
	       "#define DefaultLinuxDistribution LinuxUnknown");
      fprintf (inFile, "%s\n", "#define DefaultLinuxDistName Unknown");
      return;
  }
#endif
  if (lstat (suse, &sb) == 0) {
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxSuSE");
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistName SuSE");
    return;
  }
  if (lstat (redhat, &sb) == 0) {
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxRedHat");
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistName RedHat");
    return;
  }
  if (lstat (debian, &sb) == 0) {
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxDebian");
    fprintf (inFile, "%s\n", "#define DefaultLinuxDistName Debian");
    /* You could also try to get the version of the Debian distrib by looking
     * at the content of /etc/debian_version */
    return;
  }
  /* what's the definitive way to tell what any particular distribution is? */

  fprintf (inFile, "%s\n", "#define DefaultLinuxDistribution LinuxUnknown");
  fprintf (inFile, "%s\n", "#define DefaultLinuxDistName Unknown");
  /* would like to know what version of the distribution it is */
}
d1036 1
a1036 1
  FILE* ldprog;
a1038 12
  const char *ld = "ld -v";

#ifdef CROSSCOMPILE
  if (CrossCompiling) {
      char cmd[PATH_MAX];
      strcpy (cmd, CrossCompileDir);
      strcat (cmd,"/");
      strcat (cmd,ld);
      ldprog = popen (cmd, "r");
  } else
#endif
      ldprog = popen (ld, "r");
d1051 2
a1052 3

    fprintf(inFile, "#define DefaultLinuxBinUtilsMajorVersion %d\n",
	    ldmajor + ldminor);
d1058 1
a1058 1
#if defined __FreeBSD__
a1067 1
  char cmd[PATH_MAX];
a1072 7
  if (CrossCompiling) {
      strcpy (cmd, CrossCompileDir);
      strcat (cmd, "/");
      strcat (cmd,"objformat");
  } else
      strcpy (cmd, "objformat");

d1074 1
a1074 1
      (objprog = popen(cmd, "r")) != NULL &&
d1085 4
a1101 12
#if defined CROSSCOMPILE
  if (CrossCompiling) {
      int len = strlen(CrossCompileDir);
      len += 3;
      sunpro_cc = (char *) malloc(len);
      sunpro_CC = (char *) malloc(len);
      strcpy(sunpro_cc,CrossCompileDir);
      strcpy(sunpro_CC,CrossCompileDir);
      strcat(sunpro_cc,"/cc");
      strcat(sunpro_CC,"/CC");
  }
#endif
d1110 1
a1110 1
	fprintf (inFile,
d1113 1
a1113 1
	fprintf (inFile,
d1129 1
a1129 1
	fprintf (inFile,
d1132 1
a1132 1
	fprintf (inFile,
d1143 1
a1143 1
#if defined CROSSCOMPILE || defined  __GNUC__
d1145 1
a1145 1
get_gcc_version(FILE *inFile, char *name)
d1147 21
a1167 12
    fprintf (inFile, "#define HasGcc 1\n");
#ifdef CROSSCOMPILE
    if (CrossCompiling)
    {
	if (gnu_c > 1) {
	    fprintf (inFile, "#define HasGcc2 1\n");
	    if (gnu_c > 2)
		fprintf (inFile, "#define HasGcc3 1\n");
	}
	fprintf (inFile, "#define GccMajorVersion %d\n", gnu_c);
	fprintf (inFile, "#define GccMinorVersion %d\n", gnu_c_minor);
    } else
d1169 7
a1175 1
    {
d1177 1
a1177 4
	fprintf (inFile, "#define HasGcc2 1\n");
# if __GNUC__ > 2
	fprintf (inFile, "#define HasGcc3 1\n");
# endif
d1179 2
a1180 3
	fprintf (inFile, "#define GccMajorVersion %d\n", __GNUC__);
	fprintf (inFile, "#define GccMinorVersion %d\n", __GNUC_MINOR__);
    }
d1182 1
a1182 1
    fprintf (inFile, "#define HasGccMergeConstants %d\n", HAS_MERGE_CONSTANTS);
d1187 3
a1189 2
static boolean
get_gcc(char *cmd)
d1191 7
d1199 1
a1199 49
    static char* gcc_path[] = {
# if defined(linux) || \
     defined(__NetBSD__) || \
     defined(__OpenBSD__) || \
     defined(__FreeBSD__) || \
     defined(__APPLE__) || \
     defined(__GNU__)
	"/usr/bin/cc",	/* for Linux PostIncDir */
# endif
	"/usr/local/bin/gcc",
	"/opt/gnu/bin/gcc",
	"/usr/pkg/bin/gcc"
    };

#ifdef CROSSCOMPILE
    static char* cross_cc_name[] = {
	"cc",
	"gcc"
    };

    if (CrossCompiling) {
	int i;
	for (i = 0; i < sizeof (cross_cc_name) / sizeof cross_cc_name[0]; i++){
	    strcpy (cmd, CrossCompileDir);
	    strcat (cmd, "/");
	    strcat (cmd, cross_cc_name[i]);
	    if (lstat (cmd, &sb) == 0) {
		return TRUE;
		break;
	    }
	}
    } else
#endif
      {
	int i;
	for (i = 0; i < sizeof (gcc_path) / sizeof gcc_path[0]; i++) {
	    if (lstat (gcc_path[i], &sb) == 0) {
		strcpy (cmd, gcc_path[i]);
		return TRUE;
	    }
	}
      }
    return FALSE;
}

#if defined CROSSCOMPILE || !defined __UNIXOS2__
static void
get_gcc_incdir(FILE *inFile, char* name)
{
a1204 2
  strcpy(cmd,name);

d1206 6
a1211 3
  strcat (cmd, " --print-libgcc-file-name");
  if ((gccproc = popen (cmd, "r")) != NULL) {
      if (fgets (buf, PATH_MAX, gccproc) != NULL) {
d1214 3
d1218 1
a1218 1
      (void) pclose (gccproc);
a1219 1

d1221 1
a1221 1
      fprintf (inFile, "#define DefaultGccIncludeDir \"%s\"\n", buf);
d1228 2
a1229 6
#if defined CROSSCOMPILE || ( !defined(WIN32) && !defined(__UNIXOS2__) )
#ifdef CROSSCOMPILE
  if ((sys != win32) && (sys != emx))
#endif
    {
# if (defined(DEFAULT_OS_NAME) || defined(DEFAULT_OS_MAJOR_REV) || \
d1231 1
a1231 2
	struct utsname *name = NULL;
	struct utsname uts_name;
d1235 2
a1236 18
#ifdef CROSSCOMPILE
      if (!CrossCompiling)
#endif
      {
	  if (uname(&uts_name) < 0)
	      LogFatal("Cannot invoke uname", "");
	  else
	      name = &uts_name;
      }
#if defined CROSSCOMPILE && defined linux
      else {
	  strncpy(uts_name.sysname,cross_uts_sysname,SYS_NMLN);
	  strncpy(uts_name.release,cross_uts_release,SYS_NMLN);
	  strncpy(uts_name.version,cross_uts_version,SYS_NMLN);
	  strncpy(uts_name.machine,cross_uts_machine,SYS_NMLN);
	  name = &uts_name;
      }
#endif
d1238 5
a1242 13
#  if defined DEFAULT_OS_NAME
#   if defined CROSSCOMPILE
      if (!CrossCompiling)
#   endif
	{
	  parse_utsname(name, DEFAULT_OS_NAME, buf,
			"Bad DEFAULT_OS_NAME syntax %s");
#   ifdef DEFAULT_OS_NAME_FROB
	  DEFAULT_OS_NAME_FROB(buf, sizeof buf);
#   endif
	  if (buf[0] != '\0')
	    fprintf(inFile, "#define DefaultOSName %s\n", buf);
	}
d1244 3
d1248 5
a1252 9
#  if defined CROSSCOMPILE
	if (CrossCompiling && defaultOsName) {
	  parse_utsname(name, defaultOsName, buf,
			"Bad DEFAULT_OS_NAME syntax %s");
	  if (defaultOsNameFrob)
	    defaultOsNameFrob(buf, sizeof buf);
	  if (buf[0] != '\0')
	    fprintf(inFile, "#define DefaultOSName %s\n", buf);
	}
d1254 3
d1258 5
a1262 13
#  ifdef DEFAULT_OS_MAJOR_REV
#   if defined CROSSCOMPILE
	if (!CrossCompiling)
#   endif
	  {
	    parse_utsname(name, DEFAULT_OS_MAJOR_REV, buf,
			  "Bad DEFAULT_OS_MAJOR_REV syntax %s");
#   ifdef DEFAULT_OS_MAJOR_REV_FROB
	    DEFAULT_OS_MAJOR_REV_FROB(buf, sizeof buf);
#   endif
	    fprintf(inFile, "#define DefaultOSMajorVersion %s\n",
		    *buf ? trim_version(buf) : "0");
	  }
d1264 3
d1268 5
a1272 80
#  if defined CROSSCOMPILE
	if (CrossCompiling && defaultOsMajorRev) {
	  parse_utsname(name, defaultOsMajorRev, buf,
			"Bad defaultOsMajorRev syntax %s");
	  if (defaultOsMajorRevFrob)
	    defaultOsMajorRevFrob(buf, sizeof buf);
	  fprintf(inFile, "#define DefaultOSMajorVersion %s\n",
		  *buf ? trim_version(buf) : "0");
	}
#  endif

#  ifdef DEFAULT_OS_MINOR_REV
#   if defined CROSSCOMPILE
	if (!CrossCompiling)
#   endif
	  {
	    parse_utsname(name, DEFAULT_OS_MINOR_REV, buf,
			  "Bad DEFAULT_OS_MINOR_REV syntax %s");
#   ifdef DEFAULT_OS_MINOR_REV_FROB
	    DEFAULT_OS_MINOR_REV_FROB(buf, sizeof buf);
#   endif
	    fprintf(inFile, "#define DefaultOSMinorVersion %s\n",
		    *buf ? trim_version(buf) : "0");
	  }
#  endif

#  if defined CROSSCOMPILE
	if (CrossCompiling && defaultOsMinorRev) {
	  parse_utsname(name, defaultOsMinorRev, buf,
			"Bad defaultOsMinorRev syntax %s");
	  if (defaultOsMinorRevFrob)
	    defaultOsMinorRevFrob(buf, sizeof buf);
	  fprintf(inFile, "#define DefaultOSMinorVersion %s\n",
		  *buf ? trim_version(buf) : "0");
	}
#  endif

#  ifdef DEFAULT_OS_TEENY_REV
#   if defined CROSSCOMPILE
	if (!CrossCompiling)
#   endif
	  {
	    parse_utsname(name, DEFAULT_OS_TEENY_REV, buf,
			  "Bad DEFAULT_OS_TEENY_REV syntax %s");
#   ifdef DEFAULT_OS_TEENY_REV_FROB
	    DEFAULT_OS_TEENY_REV_FROB(buf, sizeof buf);
#   endif
	    fprintf(inFile, "#define DefaultOSTeenyVersion %s\n",
		    *buf ? trim_version(buf) : "0");
	  }
#  endif

#  if defined CROSSCOMPILE
	if (CrossCompiling && defaultOsTeenyRev) {
	  parse_utsname(name, defaultOsTeenyRev, buf,
			"Bad defaultOsTeenyRev syntax %s");
	  if (defaultOsTeenyRevFrob)
	    defaultOsTeenyRevFrob(buf, sizeof buf);
	  fprintf(inFile, "#define DefaultOSTeenyVersion %s\n",
		  *buf ? trim_version(buf) : "0");
	}
#  endif

#  ifdef DEFAULT_MACHINE_ARCHITECTURE
#   if defined CROSSCOMPILE
	if (!CrossCompiling)
#   endif
	  {
	    parse_utsname(name, DEFAULT_MACHINE_ARCHITECTURE, buf,
			  "Bad DEFAULT_MACHINE_ARCHITECTURE %s");
	    fprintf(inFile, "#ifndef %s\n# define %s\n#endif\n", buf, buf);
	  }
#  endif

#  if defined CROSSCOMPILE
	if (CrossCompiling && defaultMachineArchitecture) {
	  parse_utsname(name, defaultMachineArchitecture, buf,
			"Bad defaultMachineArchitecture syntax %s");
	  fprintf(inFile, "#ifndef %s\n# define %s\n#endif\n", buf, buf);
	}
d1274 2
d1277 4
a1280 4
# if defined CROSSCOMPILE
      if (CrossCompiling)
	get_cross_compile_dir(inFile);
      else
a1281 82
	  fprintf(inFile, "#define CrossCompiling NO\n");
# if defined CROSSCOMPILE
      if (CrossCompiling && sys == LinuX)
# endif
# if defined CROSSCOMPILE || defined linux
#  ifdef CROSSCOMPILE
	if (sys == LinuX)
#  endif
	  get_distrib (inFile);
# endif
# if defined linux
#  if defined CROSSCOMPILE
      if (!CrossCompiling)
#  endif
	  get_libc_version (inFile);
#  if defined CROSSCOMPILE
      else {
	  fprintf(inFile,"#define DefaultLinuxCLibMajorVersion %d\n",
		  glibc_major);
	  fprintf(inFile,"#define DefaultLinuxCLibMinorVersion %d\n",
		  glibc_minor);
	  fprintf(inFile,"#define DefaultLinuxCLibTeenyVersion 0\n");
      }
#  endif
# endif /* linux */
# if defined CROSSCOMPILE || defined linux
#  if defined CROSSCOMPILE
      if (sys == LinuX)
#  endif
	  get_ld_version(inFile);
# endif
# if defined (sun) && defined(SVR4)
      get_sun_compiler_versions (inFile);
# endif
# if defined CROSSCOMPILE || defined __GNUC__
#  if defined CROSSCOMPILE
      if (gnu_c)
#  endif
	{
	  char name[PATH_MAX];
	  if (get_gcc(name)) {
	      get_gcc_version (inFile,name);
#  if defined CROSSCOMPILE || !defined __UNIXOS2__
#   if defined CROSSCOMPILE
	      if (sys != emx)
#   endif
		  get_gcc_incdir(inFile,name);
#  endif
	  }
	}
# endif
# if defined __FreeBSD__
#  if defined CROSSCOMPILE
      if (sys == freeBSD)
#  endif
	  get_binary_format(inFile);
# endif
    }
#endif /* !WIN32 && !__UNIXOS2__*/
#if defined WIN32
# ifdef CROSSCOMPILE
  else if (sys == win32 && !CrossCompiling)
# endif
    {
      OSVERSIONINFO osvi;
      static char* os_names[] = { "Win32s", "Windows 95", "Windows NT" };

      memset(&osvi, 0, sizeof(OSVERSIONINFO));
      osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
      GetVersionEx (&osvi);

      fprintf (inFile, "#define DefaultOSName Microsoft %s\n",
	       os_names[osvi.dwPlatformId]);

      fprintf(inFile, "#define DefaultOSMajorVersion %d\n", osvi.dwMajorVersion);
      fprintf(inFile, "#define DefaultOSMinorVersion %d\n", osvi.dwMinorVersion);
      fprintf(inFile, "#define DefaultOSTeenyVersion %d\n",
	      osvi.dwBuildNumber & 0xFFFF);
    }
#endif /* WIN32 */
#ifdef CROSSCOMPILE
  else if (sys == emx)
d1283 38
a1320 6
#if defined CROSSCOMPILE || defined __UNIXOS2__
    {
      fprintf(inFile, "#define DefaultOSMajorVersion 4\n");
      fprintf(inFile, "#define DefaultOSMinorVersion 0\n");
      fprintf(inFile, "#define DefaultOSTeenyVersion 0\n");
    }
d1322 2
a1323 4
#if defined(__OpenBSD__)
  get_stackprotector(inFile);
#endif
  return FALSE;
d1327 1
a1327 1
cppit(char *imakefile, char *template, char *masterc,
d1345 1
a1345 1
	    fflush(inFile) ||
d1384 1
a1384 1
	if (count == 0 && st.st_size != 0)
d1399 1
a1399 1
		while (*pend && *pend != ' ' && *pend != '\t' && *pend != '\n' && *pend != '\r')
d1417 1
a1417 1
			int fd;
a1453 1

d1470 1
a1470 6
#ifdef CROSSCOMPILE
			if (fixup_whitespace)
#endif
#if defined CROSSCOMPILE || defined FIXUP_CPP_WHITESPACE
			    KludgeResetRule();
#endif
d1473 1
a1473 6
#ifdef CROSSCOMPILE
			if (fixup_whitespace)
#endif
#if defined CROSSCOMPILE || defined FIXUP_CPP_WHITESPACE
			    KludgeOutputLine(&input);
#endif
d1513 1
a1513 1
			do {
d1527 2
a1528 2
		    (pend == line || pend[-1] == ' ' || pend[-1] == '\t' || pend[-1] == '\r') &&
		    (pend[5] == ' ' || pend[5] == '\t' || pend[5] == '\r' || pend[5] == '\0'))
d1533 19
a1551 7
#ifdef CROSSCOMPILE
		if (magic_make_vars)
#endif
		  {
#if defined CROSSCOMPILE || defined MAGIC_MAKE_VARS
		    if (*pend == 'X' && pend[1] == 'V' && pend[2] == 'A' &&
			pend[3] == 'R')
d1553 3
a1555 20
			char varbuf[5];
			int i;

			if (pend[4] == 'd' && pend[5] == 'e' && pend[6] == 'f' &&
			    pend[7] >= '0' && pend[7] <= '9')
			{
			    i = pend[7] - '0';
			    sprintf(varbuf, "%0.4d", xvariable);
			    strncpy(pend+4, varbuf, 4);
			    xvariables[i] = xvariable;
			    xvariable = (xvariable + 1) % 10000;
			}
			else if (pend[4] == 'u' && pend[5] == 's' &&
				 pend[6] == 'e' && pend[7] >= '0' &&
				 pend[7] <= '9')
			{
			    i = pend[7] - '0';
			    sprintf(varbuf, "%0.4d", xvariables[i]);
			    strncpy(pend+4, varbuf, 4);
			}
d1557 1
a1558 1
		}
d1561 1
a1561 1
	while (--pend >= line && (*pend == ' ' || *pend == '\t' || *pend == '\r')) ;
d1578 2
a1579 2
		int total_red;
		struct stat st;
d1589 1
a1589 1
		if (total_red == 0 && st.st_size != 0)
d1621 1
a1621 5
#if defined CROSSCOMPILE || defined WIN32
# if defined CROSSCOMPILE
		  if (sys == win32)
# endif
		    {
a1623 1
		    }
d1655 1
a1655 1
#if defined CROSSCOMPILE || defined FIXUP_CPP_WHITESPACE
d1666 1
a1666 1
		break;
d1669 5
a1673 10
#ifdef CROSSCOMPILE
		if (inline_syntax)
#endif
#if defined CROSSCOMPILE || defined INLINE_SYNTAX
		{
		    if (*p == '<' && p[1] == '<') { /* inline file close */
			InInline--;
			InRule = TRUE;
			break;
		    }
d1675 1
a1675 1
#endif
d1677 1
a1677 1
		 * The following cases should not be treated as beginning of
d1679 3
a1681 3
		 * variable := name (GNU make)
		 * variable = .*:.* (':' should be allowed as value)
		 * sed 's:/a:/b:'   (: used in quoted values)
d1687 2
a1688 6
# if defined CROSSCOMPILE || defined WIN32
			     (
#  if defined CROSSCOMPILE
			      (sys == win32) &&
#  endif
			      quotechar != ')') &&
d1710 4
a1713 9
#ifdef CROSSCOMPILE
			if (remove_cpp_leadspace)
#endif
#if defined CROSSCOMPILE || defined REMOVE_CPP_LEADSPACE
			{
			    if (!InRule && **pline == ' ') {
				while (**pline == ' ')
				    (*pline)++;
			    }
d1715 1
a1715 1
#endif
d1717 1
a1717 1
#if defined CROSSCOMPILE || defined INLINE_SYNTAX
d1719 2
a1720 4
			if (inline_syntax) {
			    if (p[1] == '<') /* inline file start */
				InInline++;
			}
d1722 1
a1722 1
#endif
d1744 2
a1745 1
#endif
a1753 35

#ifdef CROSSCOMPILE
char*
CrossCompileCPP(void)
{
    char *cpp, *c;
    int len ;
    if (crosscompile_use_cc_e)
	AddCppArg("-E");

    cpp = strrchr(crosscompile_cpp,'/');
    if (!cpp)
	cpp = crosscompile_cpp;
    else
	cpp++;

    len = strlen(cpp) + strlen(CrossCompileDir) + 2;
    c = Emalloc(len);

    (void)snprintf(c, len,"%s/%s",CrossCompileDir,cpp);

    return c;
}

#endif

#ifdef CROSSCOMPILE
static void
get_cross_compile_dir(FILE *inFile)
{
	fprintf(inFile, "#define CrossCompileDir %s\n",
		CrossCompileDir);
	fprintf(inFile, "#define CrossCompiling YES\n");
}
#endif
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d10 1
a10 1
/* $XFree86: xc/config/imake/imake.c,v 3.64 2003/03/26 20:43:47 tsi Exp $ */
d1828 1
a1828 1
		    memmove(pend+1, pend+5, strlen(pend+5)+1);
@


