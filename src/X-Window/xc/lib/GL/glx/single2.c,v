head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.04.11;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.04.11;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.31.18;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.57.32;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.17.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $XFree86: xc/lib/GL/glx/single2.c,v 1.3 2001/03/21 16:04:39 dawes Exp $ */
/*
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: The application programming interfaces
** established by SGI in conjunction with the Original Code are The
** OpenGL(R) Graphics System: A Specification (Version 1.2.1), released
** April 1, 1999; The OpenGL(R) Graphics System Utility Library (Version
** 1.3), released November 4, 1998; and OpenGL(R) Graphics with the X
** Window System(R) (Version 1.3), released October 19, 1998. This software
** was created using the OpenGL(R) version 1.2.1 Sample Implementation
** published by SGI, but has not been independently verified as being
** compliant with the OpenGL(R) version 1.2.1 Specification.
**
*/

#define NEED_GL_FUNCS_WRAPPED
#include "glxclient.h"
#include "packsingle.h"

GLenum glGetError(void)
{
    __GLX_SINGLE_DECLARE_VARIABLES();
    GLuint retval = GL_NO_ERROR;
    xGLXGetErrorReply reply;

    if (gc->error) {
	/* Use internal error first */
	retval = gc->error;
	gc->error = GL_NO_ERROR;
	return retval;
    }

    __GLX_SINGLE_LOAD_VARIABLES();
    __GLX_SINGLE_BEGIN(X_GLsop_GetError,0);
    __GLX_SINGLE_READ_XREPLY();
    retval = reply.error;
    __GLX_SINGLE_END();

    return retval;
}

void glGetClipPlane(GLenum plane, GLdouble *equation)
{
    __GLX_SINGLE_DECLARE_VARIABLES();
    xGLXSingleReply reply;
    __GLX_SINGLE_LOAD_VARIABLES();
    __GLX_SINGLE_BEGIN(X_GLsop_GetClipPlane,4);
    __GLX_SINGLE_PUT_LONG(0,plane);
    __GLX_SINGLE_READ_XREPLY();
    if (reply.length == 8) {
	__GLX_SINGLE_GET_DOUBLE_ARRAY(equation,4);
    }
    __GLX_SINGLE_END();
}

void glGetBooleanv(GLenum val, GLboolean *b)
{
    __GLX_SINGLE_DECLARE_VARIABLES();
    xGLXSingleReply reply;

    __GLX_SINGLE_LOAD_VARIABLES();
    __GLX_SINGLE_BEGIN(X_GLsop_GetBooleanv,4);
    __GLX_SINGLE_PUT_LONG(0,val);
    __GLX_SINGLE_READ_XREPLY();
    __GLX_SINGLE_GET_SIZE(compsize);

    if (compsize == 0) {
	/*
	** Error occured; don't modify user's buffer.
	*/
    } else {
	/*
	** For all the queries listed here, we use the locally stored
	** values rather than the one returned by the server.  Note that
	** we still needed to send the request to the server in order to
	** find out whether it was legal to make a query (it's illegal,
	** for example, to call a query between glBegin() and glEnd()).
	*/
	switch (val) {
	  case GL_PACK_ROW_LENGTH:
	    *b = (GLboolean)gc->state.storePack.rowLength;
	    break;
	  case GL_PACK_IMAGE_HEIGHT:
	    *b = (GLboolean)gc->state.storePack.imageHeight;
	    break;
	  case GL_PACK_SKIP_ROWS:
	    *b = (GLboolean)gc->state.storePack.skipRows;
	    break;
	  case GL_PACK_SKIP_PIXELS:
	    *b = (GLboolean)gc->state.storePack.skipPixels;
	    break;
	  case GL_PACK_SKIP_IMAGES:
	    *b = (GLboolean)gc->state.storePack.skipImages;
	    break;
	  case GL_PACK_ALIGNMENT:
	    *b = (GLboolean)gc->state.storePack.alignment;
	    break;
	  case GL_PACK_SWAP_BYTES:
	    *b = (GLboolean)gc->state.storePack.swapEndian;
	    break;
	  case GL_PACK_LSB_FIRST:
	    *b = (GLboolean)gc->state.storePack.lsbFirst;
	    break;
	  case GL_UNPACK_ROW_LENGTH:
	    *b = (GLboolean)gc->state.storeUnpack.rowLength;
	    break;
	  case GL_UNPACK_IMAGE_HEIGHT:
	    *b = (GLboolean)gc->state.storeUnpack.imageHeight;
	    break;
	  case GL_UNPACK_SKIP_ROWS:
	    *b = (GLboolean)gc->state.storeUnpack.skipRows;
	    break;
	  case GL_UNPACK_SKIP_PIXELS:
	    *b = (GLboolean)gc->state.storeUnpack.skipPixels;
	    break;
	  case GL_UNPACK_SKIP_IMAGES:
	    *b = (GLboolean)gc->state.storeUnpack.skipImages;
	    break;
	  case GL_UNPACK_ALIGNMENT:
	    *b = (GLboolean)gc->state.storeUnpack.alignment;
	    break;
	  case GL_UNPACK_SWAP_BYTES:
	    *b = (GLboolean)gc->state.storeUnpack.swapEndian;
	    break;
	  case GL_UNPACK_LSB_FIRST:
	    *b = (GLboolean)gc->state.storeUnpack.lsbFirst;
	    break;
	  case GL_VERTEX_ARRAY:
	    *b = (GLboolean)gc->state.vertArray.vertex.enable;
	    break;
	  case GL_VERTEX_ARRAY_SIZE:
	    *b = (GLboolean)gc->state.vertArray.vertex.size;
	    break;
	  case GL_VERTEX_ARRAY_TYPE:
	    *b = (GLboolean)gc->state.vertArray.vertex.type;
	    break;
	  case GL_VERTEX_ARRAY_STRIDE:
	    *b = (GLboolean)gc->state.vertArray.vertex.stride;
	    break;
	  case GL_NORMAL_ARRAY:
	    *b = (GLboolean)gc->state.vertArray.normal.enable;
	    break;
	  case GL_NORMAL_ARRAY_TYPE:
	    *b = (GLboolean)gc->state.vertArray.normal.type;
	    break;
	  case GL_NORMAL_ARRAY_STRIDE:
	    *b = (GLboolean)gc->state.vertArray.normal.stride;
	    break;
	  case GL_COLOR_ARRAY:
	    *b = (GLboolean)gc->state.vertArray.color.enable;
	    break;
	  case GL_COLOR_ARRAY_SIZE:
	    *b = (GLboolean)gc->state.vertArray.color.size;
	    break;
	  case GL_COLOR_ARRAY_TYPE:
	    *b = (GLboolean)gc->state.vertArray.color.type;
	    break;
	  case GL_COLOR_ARRAY_STRIDE:
	    *b = (GLboolean)gc->state.vertArray.color.stride;
	    break;
	  case GL_INDEX_ARRAY:
	    *b = (GLboolean)gc->state.vertArray.index.enable;
	    break;
	  case GL_INDEX_ARRAY_TYPE:
	    *b = (GLboolean)gc->state.vertArray.index.type;
	    break;
	  case GL_INDEX_ARRAY_STRIDE:
	    *b = (GLboolean)gc->state.vertArray.index.stride;
	    break;
	  case GL_TEXTURE_COORD_ARRAY:
	    *b = (GLboolean)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].enable;
	    break;
	  case GL_TEXTURE_COORD_ARRAY_SIZE:
	    *b = (GLboolean)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].size;
	    break;
	  case GL_TEXTURE_COORD_ARRAY_TYPE:
	    *b = (GLboolean)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].type;
	    break;
	  case GL_TEXTURE_COORD_ARRAY_STRIDE:
	    *b = (GLboolean)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].stride;
	    break;
	  case GL_EDGE_FLAG_ARRAY:
	    *b = (GLboolean)gc->state.vertArray.edgeFlag.enable;
	    break;
	  case GL_EDGE_FLAG_ARRAY_STRIDE:
	    *b = (GLboolean)gc->state.vertArray.edgeFlag.stride;
	    break;
	  case GL_MAX_ELEMENTS_VERTICES:
	    *b = (GLboolean)gc->state.vertArray.maxElementsVertices;
	    break;
	  case GL_MAX_ELEMENTS_INDICES:
	    *b = (GLboolean)gc->state.vertArray.maxElementsIndices;
	    break;
	  case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
	    *b = (GLboolean)__GL_CLIENT_ATTRIB_STACK_DEPTH;
	    break;
	  case GL_CLIENT_ACTIVE_TEXTURE_ARB:
	    *b = (GLboolean)(gc->state.vertArray.activeTexture + GL_TEXTURE0_ARB);
	    break;
	  default:
	    /*
	    ** Not a local value, so use what we got from the server.
	    */
	    if (compsize == 1) {
		__GLX_SINGLE_GET_CHAR(b);
	    } else {
		__GLX_SINGLE_GET_CHAR_ARRAY(b,compsize);
	    }
	}
    }
    __GLX_SINGLE_END();
}

void glGetDoublev(GLenum val, GLdouble *d)
{
    __GLX_SINGLE_DECLARE_VARIABLES();
    xGLXSingleReply reply;

    __GLX_SINGLE_LOAD_VARIABLES();
    __GLX_SINGLE_BEGIN(X_GLsop_GetDoublev,4);
    __GLX_SINGLE_PUT_LONG(0,val);
    __GLX_SINGLE_READ_XREPLY();
    __GLX_SINGLE_GET_SIZE(compsize);

    if (compsize == 0) {
	/*
	** Error occured; don't modify user's buffer.
	*/
    } else {
	/*
	** For all the queries listed here, we use the locally stored
	** values rather than the one returned by the server.  Note that
	** we still needed to send the request to the server in order to
	** find out whether it was legal to make a query (it's illegal,
	** for example, to call a query between glBegin() and glEnd()).
	*/
	switch (val) {
	  case GL_PACK_ROW_LENGTH:
	    *d = (GLdouble)gc->state.storePack.rowLength;
	    break;
	  case GL_PACK_IMAGE_HEIGHT:
	    *d = (GLdouble)gc->state.storePack.imageHeight;
	    break;
	  case GL_PACK_SKIP_ROWS:
	    *d = (GLdouble)gc->state.storePack.skipRows;
	    break;
	  case GL_PACK_SKIP_PIXELS:
	    *d = (GLdouble)gc->state.storePack.skipPixels;
	    break;
	  case GL_PACK_SKIP_IMAGES:
	    *d = (GLdouble)gc->state.storePack.skipImages;
	    break;
	  case GL_PACK_ALIGNMENT:
	    *d = (GLdouble)gc->state.storePack.alignment;
	    break;
	  case GL_PACK_SWAP_BYTES:
	    *d = (GLdouble)gc->state.storePack.swapEndian;
	    break;
	  case GL_PACK_LSB_FIRST:
	    *d = (GLdouble)gc->state.storePack.lsbFirst;
	    break;
	  case GL_UNPACK_ROW_LENGTH:
	    *d = (GLdouble)gc->state.storeUnpack.rowLength;
	    break;
	  case GL_UNPACK_IMAGE_HEIGHT:
	    *d = (GLdouble)gc->state.storeUnpack.imageHeight;
	    break;
	  case GL_UNPACK_SKIP_ROWS:
	    *d = (GLdouble)gc->state.storeUnpack.skipRows;
	    break;
	  case GL_UNPACK_SKIP_PIXELS:
	    *d = (GLdouble)gc->state.storeUnpack.skipPixels;
	    break;
	  case GL_UNPACK_SKIP_IMAGES:
	    *d = (GLdouble)gc->state.storeUnpack.skipImages;
	    break;
	  case GL_UNPACK_ALIGNMENT:
	    *d = (GLdouble)gc->state.storeUnpack.alignment;
	    break;
	  case GL_UNPACK_SWAP_BYTES:
	    *d = (GLdouble)gc->state.storeUnpack.swapEndian;
	    break;
	  case GL_UNPACK_LSB_FIRST:
	    *d = (GLdouble)gc->state.storeUnpack.lsbFirst;
	    break;
	  case GL_VERTEX_ARRAY:
	    *d = (GLdouble)gc->state.vertArray.vertex.enable;
	    break;
	  case GL_VERTEX_ARRAY_SIZE:
	    *d = (GLdouble)gc->state.vertArray.vertex.size;
	    break;
	  case GL_VERTEX_ARRAY_TYPE:
	    *d = (GLdouble)gc->state.vertArray.vertex.type;
	    break;
	  case GL_VERTEX_ARRAY_STRIDE:
	    *d = (GLdouble)gc->state.vertArray.vertex.stride;
	    break;
	  case GL_NORMAL_ARRAY:
	    *d = (GLdouble)gc->state.vertArray.normal.enable;
	    break;
	  case GL_NORMAL_ARRAY_TYPE:
	    *d = (GLdouble)gc->state.vertArray.normal.type;
	    break;
	  case GL_NORMAL_ARRAY_STRIDE:
	    *d = (GLdouble)gc->state.vertArray.normal.stride;
	    break;
	  case GL_COLOR_ARRAY:
	    *d = (GLdouble)gc->state.vertArray.color.enable;
	    break;
	  case GL_COLOR_ARRAY_SIZE:
	    *d = (GLdouble)gc->state.vertArray.color.size;
	    break;
	  case GL_COLOR_ARRAY_TYPE:
	    *d = (GLdouble)gc->state.vertArray.color.type;
	    break;
	  case GL_COLOR_ARRAY_STRIDE:
	    *d = (GLdouble)gc->state.vertArray.color.stride;
	    break;
	  case GL_INDEX_ARRAY:
	    *d = (GLdouble)gc->state.vertArray.index.enable;
	    break;
	  case GL_INDEX_ARRAY_TYPE:
	    *d = (GLdouble)gc->state.vertArray.index.type;
	    break;
	  case GL_INDEX_ARRAY_STRIDE:
	    *d = (GLdouble)gc->state.vertArray.index.stride;
	    break;
	  case GL_TEXTURE_COORD_ARRAY:
	    *d = (GLdouble)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].enable;
	    break;
	  case GL_TEXTURE_COORD_ARRAY_SIZE:
	    *d = (GLdouble)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].size;
	    break;
	  case GL_TEXTURE_COORD_ARRAY_TYPE:
	    *d = (GLdouble)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].type;
	    break;
	  case GL_TEXTURE_COORD_ARRAY_STRIDE:
	    *d = (GLdouble)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].stride;
	    break;
	  case GL_EDGE_FLAG_ARRAY:
	    *d = (GLdouble)gc->state.vertArray.edgeFlag.enable;
	    break;
	  case GL_EDGE_FLAG_ARRAY_STRIDE:
	    *d = (GLdouble)gc->state.vertArray.edgeFlag.stride;
	    break;
	  case GL_MAX_ELEMENTS_VERTICES:
	    *d = (GLdouble)gc->state.vertArray.maxElementsVertices;
	    break;
	  case GL_MAX_ELEMENTS_INDICES:
	    *d = (GLdouble)gc->state.vertArray.maxElementsIndices;
	    break;
	  case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
	    *d = (GLdouble)__GL_CLIENT_ATTRIB_STACK_DEPTH;
	    break;
	  case GL_CLIENT_ACTIVE_TEXTURE_ARB:
	    *d = (GLdouble)(gc->state.vertArray.activeTexture + GL_TEXTURE0_ARB);
	    break;
	  default:
	    /*
	     ** Not a local value, so use what we got from the server.
	     */
	    if (compsize == 1) {
		__GLX_SINGLE_GET_DOUBLE(d);
	    } else {
		__GLX_SINGLE_GET_DOUBLE_ARRAY(d,compsize);
	    }
	}
    }
    __GLX_SINGLE_END();
}

void glGetFloatv(GLenum val, GLfloat *f)
{
    __GLX_SINGLE_DECLARE_VARIABLES();
    xGLXSingleReply reply;

    __GLX_SINGLE_LOAD_VARIABLES();
    __GLX_SINGLE_BEGIN(X_GLsop_GetFloatv,4);
    __GLX_SINGLE_PUT_LONG(0,val);
    __GLX_SINGLE_READ_XREPLY();
    __GLX_SINGLE_GET_SIZE(compsize);

    if (compsize == 0) {
	/*
	** Error occured; don't modify user's buffer.
	*/
    } else {
	/*
	** For all the queries listed here, we use the locally stored
	** values rather than the one returned by the server.  Note that
	** we still needed to send the request to the server in order to
	** find out whether it was legal to make a query (it's illegal,
	** for example, to call a query between glBegin() and glEnd()).
	*/
	switch (val) {
	  case GL_PACK_ROW_LENGTH:
	    *f = (GLfloat)gc->state.storePack.rowLength;
	    break;
	  case GL_PACK_IMAGE_HEIGHT:
	    *f = (GLfloat)gc->state.storePack.imageHeight;
	    break;
	  case GL_PACK_SKIP_ROWS:
	    *f = (GLfloat)gc->state.storePack.skipRows;
	    break;
	  case GL_PACK_SKIP_PIXELS:
	    *f = (GLfloat)gc->state.storePack.skipPixels;
	    break;
	  case GL_PACK_SKIP_IMAGES:
	    *f = (GLfloat)gc->state.storePack.skipImages;
	    break;
	  case GL_PACK_ALIGNMENT:
	    *f = (GLfloat)gc->state.storePack.alignment;
	    break;
	  case GL_PACK_SWAP_BYTES:
	    *f = (GLfloat)gc->state.storePack.swapEndian;
	    break;
	  case GL_PACK_LSB_FIRST:
	    *f = (GLfloat)gc->state.storePack.lsbFirst;
	    break;
	  case GL_UNPACK_ROW_LENGTH:
	    *f = (GLfloat)gc->state.storeUnpack.rowLength;
	    break;
	  case GL_UNPACK_IMAGE_HEIGHT:
	    *f = (GLfloat)gc->state.storeUnpack.imageHeight;
	    break;
	  case GL_UNPACK_SKIP_ROWS:
	    *f = (GLfloat)gc->state.storeUnpack.skipRows;
	    break;
	  case GL_UNPACK_SKIP_PIXELS:
	    *f = (GLfloat)gc->state.storeUnpack.skipPixels;
	    break;
	  case GL_UNPACK_SKIP_IMAGES:
	    *f = (GLfloat)gc->state.storeUnpack.skipImages;
	    break;
	  case GL_UNPACK_ALIGNMENT:
	    *f = (GLfloat)gc->state.storeUnpack.alignment;
	    break;
	  case GL_UNPACK_SWAP_BYTES:
	    *f = (GLfloat)gc->state.storeUnpack.swapEndian;
	    break;
	  case GL_UNPACK_LSB_FIRST:
	    *f = (GLfloat)gc->state.storeUnpack.lsbFirst;
	    break;
	  case GL_VERTEX_ARRAY:
	    *f = (GLfloat)gc->state.vertArray.vertex.enable;
	    break;
	  case GL_VERTEX_ARRAY_SIZE:
	    *f = (GLfloat)gc->state.vertArray.vertex.size;
	    break;
	  case GL_VERTEX_ARRAY_TYPE:
	    *f = (GLfloat)gc->state.vertArray.vertex.type;
	    break;
	  case GL_VERTEX_ARRAY_STRIDE:
	    *f = (GLfloat)gc->state.vertArray.vertex.stride;
	    break;
	  case GL_NORMAL_ARRAY:
	    *f = (GLfloat)gc->state.vertArray.normal.enable;
	    break;
	  case GL_NORMAL_ARRAY_TYPE:
	    *f = (GLfloat)gc->state.vertArray.normal.type;
	    break;
	  case GL_NORMAL_ARRAY_STRIDE:
	    *f = (GLfloat)gc->state.vertArray.normal.stride;
	    break;
	  case GL_COLOR_ARRAY:
	    *f = (GLfloat)gc->state.vertArray.color.enable;
	    break;
	  case GL_COLOR_ARRAY_SIZE:
	    *f = (GLfloat)gc->state.vertArray.color.size;
	    break;
	  case GL_COLOR_ARRAY_TYPE:
	    *f = (GLfloat)gc->state.vertArray.color.type;
	    break;
	  case GL_COLOR_ARRAY_STRIDE:
	    *f = (GLfloat)gc->state.vertArray.color.stride;
	    break;
	  case GL_INDEX_ARRAY:
	    *f = (GLfloat)gc->state.vertArray.index.enable;
	    break;
	  case GL_INDEX_ARRAY_TYPE:
	    *f = (GLfloat)gc->state.vertArray.index.type;
	    break;
	  case GL_INDEX_ARRAY_STRIDE:
	    *f = (GLfloat)gc->state.vertArray.index.stride;
	    break;
	  case GL_TEXTURE_COORD_ARRAY:
	    *f = (GLfloat)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].enable;
	    break;
	  case GL_TEXTURE_COORD_ARRAY_SIZE:
	    *f = (GLfloat)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].size;
	    break;
	  case GL_TEXTURE_COORD_ARRAY_TYPE:
	    *f = (GLfloat)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].type;
	    break;
	  case GL_TEXTURE_COORD_ARRAY_STRIDE:
	    *f = (GLfloat)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].stride;
	    break;
	  case GL_EDGE_FLAG_ARRAY:
	    *f = (GLfloat)gc->state.vertArray.edgeFlag.enable;
	    break;
	  case GL_EDGE_FLAG_ARRAY_STRIDE:
	    *f = (GLfloat)gc->state.vertArray.edgeFlag.stride;
	    break;
	  case GL_MAX_ELEMENTS_VERTICES:
	    *f = (GLfloat)gc->state.vertArray.maxElementsVertices;
	    break;
	  case GL_MAX_ELEMENTS_INDICES:
	    *f = (GLfloat)gc->state.vertArray.maxElementsIndices;
	    break;
	  case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
	    *f = (GLfloat)__GL_CLIENT_ATTRIB_STACK_DEPTH;
	    break;
	  case GL_CLIENT_ACTIVE_TEXTURE_ARB:
	    *f = (GLfloat)(gc->state.vertArray.activeTexture + GL_TEXTURE0_ARB);
	    break;
	  default:
	    /*
	    ** Not a local value, so use what we got from the server.
	    */
	    if (compsize == 1) {
		__GLX_SINGLE_GET_FLOAT(f);
	    } else {
		__GLX_SINGLE_GET_FLOAT_ARRAY(f,compsize);
	    }
	}
    }
    __GLX_SINGLE_END();
}

void glGetIntegerv(GLenum val, GLint *i)
{
    __GLX_SINGLE_DECLARE_VARIABLES();
    xGLXSingleReply reply;

    __GLX_SINGLE_LOAD_VARIABLES();
    __GLX_SINGLE_BEGIN(X_GLsop_GetIntegerv,4);
    __GLX_SINGLE_PUT_LONG(0,val);
    __GLX_SINGLE_READ_XREPLY();
    __GLX_SINGLE_GET_SIZE(compsize);

    if (compsize == 0) {
	/*
	** Error occured; don't modify user's buffer.
	*/
    } else {
	/*
	** For all the queries listed here, we use the locally stored
	** values rather than the one returned by the server.  Note that
	** we still needed to send the request to the server in order to
	** find out whether it was legal to make a query (it's illegal,
	** for example, to call a query between glBegin() and glEnd()).
	*/
	switch (val) {
	  case GL_PACK_ROW_LENGTH:
	    *i = (GLint)gc->state.storePack.rowLength;
	    break;
	  case GL_PACK_IMAGE_HEIGHT:
	    *i = (GLint)gc->state.storePack.imageHeight;
	    break;
	  case GL_PACK_SKIP_ROWS:
	    *i = (GLint)gc->state.storePack.skipRows;
	    break;
	  case GL_PACK_SKIP_PIXELS:
	    *i = (GLint)gc->state.storePack.skipPixels;
	    break;
	  case GL_PACK_SKIP_IMAGES:
	    *i = (GLint)gc->state.storePack.skipImages;
	    break;
	  case GL_PACK_ALIGNMENT:
	    *i = (GLint)gc->state.storePack.alignment;
	    break;
	  case GL_PACK_SWAP_BYTES:
	    *i = (GLint)gc->state.storePack.swapEndian;
	    break;
	  case GL_PACK_LSB_FIRST:
	    *i = (GLint)gc->state.storePack.lsbFirst;
	    break;
	  case GL_UNPACK_ROW_LENGTH:
	    *i = (GLint)gc->state.storeUnpack.rowLength;
	    break;
	  case GL_UNPACK_IMAGE_HEIGHT:
	    *i = (GLint)gc->state.storeUnpack.imageHeight;
	    break;
	  case GL_UNPACK_SKIP_ROWS:
	    *i = (GLint)gc->state.storeUnpack.skipRows;
	    break;
	  case GL_UNPACK_SKIP_PIXELS:
	    *i = (GLint)gc->state.storeUnpack.skipPixels;
	    break;
	  case GL_UNPACK_SKIP_IMAGES:
	    *i = (GLint)gc->state.storeUnpack.skipImages;
	    break;
	  case GL_UNPACK_ALIGNMENT:
	    *i = (GLint)gc->state.storeUnpack.alignment;
	    break;
	  case GL_UNPACK_SWAP_BYTES:
	    *i = (GLint)gc->state.storeUnpack.swapEndian;
	    break;
	  case GL_UNPACK_LSB_FIRST:
	    *i = (GLint)gc->state.storeUnpack.lsbFirst;
	    break;
	  case GL_VERTEX_ARRAY:
	    *i = (GLint)gc->state.vertArray.vertex.enable;
	    break;
	  case GL_VERTEX_ARRAY_SIZE:
	    *i = (GLint)gc->state.vertArray.vertex.size;
	    break;
	  case GL_VERTEX_ARRAY_TYPE:
	    *i = (GLint)gc->state.vertArray.vertex.type;
	    break;
	  case GL_VERTEX_ARRAY_STRIDE:
	    *i = (GLint)gc->state.vertArray.vertex.stride;
	    break;
	  case GL_NORMAL_ARRAY:
	    *i = (GLint)gc->state.vertArray.normal.enable;
	    break;
	  case GL_NORMAL_ARRAY_TYPE:
	    *i = (GLint)gc->state.vertArray.normal.type;
	    break;
	  case GL_NORMAL_ARRAY_STRIDE:
	    *i = (GLint)gc->state.vertArray.normal.stride;
	    break;
	  case GL_COLOR_ARRAY:
	    *i = (GLint)gc->state.vertArray.color.enable;
	    break;
	  case GL_COLOR_ARRAY_SIZE:
	    *i = (GLint)gc->state.vertArray.color.size;
	    break;
	  case GL_COLOR_ARRAY_TYPE:
	    *i = (GLint)gc->state.vertArray.color.type;
	    break;
	  case GL_COLOR_ARRAY_STRIDE:
	    *i = (GLint)gc->state.vertArray.color.stride;
	    break;
	  case GL_INDEX_ARRAY:
	    *i = (GLint)gc->state.vertArray.index.enable;
	    break;
	  case GL_INDEX_ARRAY_TYPE:
	    *i = (GLint)gc->state.vertArray.index.type;
	    break;
	  case GL_INDEX_ARRAY_STRIDE:
	    *i = (GLint)gc->state.vertArray.index.stride;
	    break;
	  case GL_TEXTURE_COORD_ARRAY:
	    *i = (GLint)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].enable;
	    break;
	  case GL_TEXTURE_COORD_ARRAY_SIZE:
	    *i = (GLint)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].size;
	    break;
	  case GL_TEXTURE_COORD_ARRAY_TYPE:
	    *i = (GLint)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].type;
	    break;
	  case GL_TEXTURE_COORD_ARRAY_STRIDE:
	    *i = (GLint)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].stride;
	    break;
	  case GL_EDGE_FLAG_ARRAY:
	    *i = (GLint)gc->state.vertArray.edgeFlag.enable;
	    break;
	  case GL_EDGE_FLAG_ARRAY_STRIDE:
	    *i = (GLint)gc->state.vertArray.edgeFlag.stride;
	    break;
	  case GL_MAX_ELEMENTS_VERTICES:
	    *i = (GLint)gc->state.vertArray.maxElementsVertices;
	    break;
	  case GL_MAX_ELEMENTS_INDICES:
	    *i = (GLint)gc->state.vertArray.maxElementsIndices;
	    break;
	  case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
	    *i = (GLint)__GL_CLIENT_ATTRIB_STACK_DEPTH;
	    break;
	  case GL_CLIENT_ACTIVE_TEXTURE_ARB:
	    *i = (GLint)(gc->state.vertArray.activeTexture + GL_TEXTURE0_ARB);
	    break;
	  default:
	    /*
	    ** Not a local value, so use what we got from the server.
	    */
	    if (compsize == 1) {
		__GLX_SINGLE_GET_LONG(i);
	    } else {
		__GLX_SINGLE_GET_LONG_ARRAY(i,compsize);
	    }
	}
    }
    __GLX_SINGLE_END();
}

/*
** Send all pending commands to server.
*/
void glFlush(void)
{
    __GLX_SINGLE_DECLARE_VARIABLES();

    if (!dpy) return;

    __GLX_SINGLE_LOAD_VARIABLES();
    __GLX_SINGLE_BEGIN(X_GLsop_Flush,0);
    __GLX_SINGLE_END();

    /* And finally flush the X protocol data */
    XFlush(dpy);
}

void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
{
    __GLX_SINGLE_DECLARE_VARIABLES();

    if (!dpy) return;

    __GLX_SINGLE_LOAD_VARIABLES();
    __GLX_SINGLE_BEGIN(X_GLsop_FeedbackBuffer,8);
    __GLX_SINGLE_PUT_LONG(0,size);
    __GLX_SINGLE_PUT_LONG(4,type);
    __GLX_SINGLE_END();

    gc->feedbackBuf = buffer;
}

void glSelectBuffer(GLsizei numnames, GLuint *buffer)
{
    __GLX_SINGLE_DECLARE_VARIABLES();

    if (!dpy) return;

    __GLX_SINGLE_LOAD_VARIABLES();
    __GLX_SINGLE_BEGIN(X_GLsop_SelectBuffer,4);
    __GLX_SINGLE_PUT_LONG(0,numnames);
    __GLX_SINGLE_END();

    gc->selectBuf = buffer;
}

GLint glRenderMode(GLenum mode)
{
    __GLX_SINGLE_DECLARE_VARIABLES();
    GLint retval;
    xGLXRenderModeReply reply;

    if (!dpy) return -1;

    __GLX_SINGLE_LOAD_VARIABLES();
    __GLX_SINGLE_BEGIN(X_GLsop_RenderMode,4);
    __GLX_SINGLE_PUT_LONG(0,mode);
    __GLX_SINGLE_READ_XREPLY();
    __GLX_SINGLE_GET_RETVAL(retval,GLint);

    if (reply.newMode != mode) {
	/*
	** Switch to new mode did not take effect, therefore an error
	** occured.  When an error happens the server won't send us any
	** other data.
	*/
    } else {
	/* Read the feedback or selection data */
	if (gc->renderMode == GL_FEEDBACK) {
	    __GLX_SINGLE_GET_SIZE(compsize);
	    __GLX_SINGLE_GET_FLOAT_ARRAY(gc->feedbackBuf, compsize);
	} else
	if (gc->renderMode == GL_SELECT) {
	    __GLX_SINGLE_GET_SIZE(compsize);
	    __GLX_SINGLE_GET_LONG_ARRAY(gc->selectBuf, compsize);
	}
	gc->renderMode = mode;
    }
    __GLX_SINGLE_END();

    return retval;
}

void glFinish(void)
{
    __GLX_SINGLE_DECLARE_VARIABLES();
    xGLXSingleReply reply;

    __GLX_SINGLE_LOAD_VARIABLES();
    __GLX_SINGLE_BEGIN(X_GLsop_Finish,0);
    __GLX_SINGLE_READ_XREPLY();
    __GLX_SINGLE_END();
}

const GLubyte *glGetString(GLenum name)
{
    __GLX_SINGLE_DECLARE_VARIABLES();
    xGLXSingleReply reply;
    GLubyte *s = NULL;

    if (!dpy) return 0;

    /*
    ** Return the cached copy if the string has already been fetched
    */
    switch(name) {
      case GL_VENDOR:
	if (gc->vendor) return gc->vendor;
	break;
      case GL_RENDERER:
	if (gc->renderer) return gc->renderer;
	break;
      case GL_VERSION:
	if (gc->version) return gc->version;
	break;
      case GL_EXTENSIONS:
	if (gc->extensions) return gc->extensions;
	break;
      default:
	__glXSetError(gc, GL_INVALID_ENUM);
	return 0;
    }

    /*
    ** Get requested string from server
    */
    __GLX_SINGLE_LOAD_VARIABLES();
    __GLX_SINGLE_BEGIN(X_GLsop_GetString,4);
    __GLX_SINGLE_PUT_LONG(0,name);
    __GLX_SINGLE_READ_XREPLY();
    __GLX_SINGLE_GET_SIZE(compsize);
    s = (GLubyte*) Xmalloc(compsize);
    if (!s) {
	/* Throw data on the floor */
	_XEatData(dpy, compsize);
	__glXSetError(gc, GL_OUT_OF_MEMORY);
    } else {
	__GLX_SINGLE_GET_CHAR_ARRAY(s,compsize);

	/*
	** Update local cache
	*/
	switch(name) {
	  case GL_VENDOR:
	    gc->vendor = s;
	    break;
	  case GL_RENDERER:
	    gc->renderer = s;
	    break;
	  case GL_VERSION:
	    gc->version = s;
	    break;
	  case GL_EXTENSIONS:
	    gc->extensions = s;
	    break;
	}
    }
    __GLX_SINGLE_END();
    return s;
}

GLboolean glIsEnabled(GLenum cap)
{
    __GLX_SINGLE_DECLARE_VARIABLES();
    xGLXSingleReply reply;
    GLboolean retval = 0;

    if (!dpy) return 0;

    switch(cap) {
      case GL_VERTEX_ARRAY:
	  return gc->state.vertArray.vertex.enable;
      case GL_NORMAL_ARRAY:
	  return gc->state.vertArray.normal.enable;
      case GL_COLOR_ARRAY:
	  return gc->state.vertArray.color.enable;
      case GL_INDEX_ARRAY:
	  return gc->state.vertArray.index.enable;
      case GL_TEXTURE_COORD_ARRAY:
	  return gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].enable;
      case GL_EDGE_FLAG_ARRAY:
	  return gc->state.vertArray.edgeFlag.enable;
    }

    __GLX_SINGLE_LOAD_VARIABLES();
    __GLX_SINGLE_BEGIN(X_GLsop_IsEnabled,4);
    __GLX_SINGLE_PUT_LONG(0,cap);
    __GLX_SINGLE_READ_XREPLY();
    __GLX_SINGLE_GET_RETVAL(retval, GLboolean);
    __GLX_SINGLE_END();
    return retval;
}

void glGetPointerv(GLenum pname, void **params)
{
    __GLXcontext *gc = __glXGetCurrentContext();
    Display *dpy = gc->currentDpy;

    if (!dpy) return;

    switch(pname) {
      case GL_VERTEX_ARRAY_POINTER:
	  *params = (void *)gc->state.vertArray.vertex.ptr;
	  return;
      case GL_NORMAL_ARRAY_POINTER:
	  *params = (void *)gc->state.vertArray.normal.ptr;
	  return;
      case GL_COLOR_ARRAY_POINTER:
	  *params = (void *)gc->state.vertArray.color.ptr;
	  return;
      case GL_INDEX_ARRAY_POINTER:
	  *params = (void *)gc->state.vertArray.index.ptr;
	  return;
      case GL_TEXTURE_COORD_ARRAY_POINTER:
	  *params = (void *)gc->state.vertArray.texCoord[gc->state.vertArray.activeTexture].ptr;
	  return;
      case GL_EDGE_FLAG_ARRAY_POINTER:
	  *params = (void *)gc->state.vertArray.edgeFlag.ptr;
	return;
      case GL_FEEDBACK_BUFFER_POINTER:
	*params = (void *)gc->feedbackBuf;
	return;
      case GL_SELECTION_BUFFER_POINTER:
	*params = (void *)gc->selectBuf;
	return;
      default:
	__glXSetError(gc, GL_INVALID_ENUM);
	return;
    }
}

@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/lib/GL/glx/single2.c,v 1.11 2004/02/11 20:01:21 dawes Exp $ */
a40 52
/* Used for GL_ARB_transpose_matrix */
static void TransposeMatrixf(GLfloat m[16])
{
    int i, j;
    for (i = 0; i < 4; i++) {
        for (j = 0; j < i; j++) {
            GLfloat tmp = m[i*4+j];
            m[i*4+j] = m[j*4+i];
            m[j*4+i] = tmp;
        }
    }
}

/* Used for GL_ARB_transpose_matrix */
static void TransposeMatrixb(GLboolean m[16])
{
    int i, j;
    for (i = 0; i < 4; i++) {
        for (j = 0; j < i; j++) {
            GLboolean tmp = m[i*4+j];
            m[i*4+j] = m[j*4+i];
            m[j*4+i] = tmp;
        }
    }
}

/* Used for GL_ARB_transpose_matrix */
static void TransposeMatrixd(GLdouble m[16])
{
    int i, j;
    for (i = 0; i < 4; i++) {
        for (j = 0; j < i; j++) {
            GLdouble tmp = m[i*4+j];
            m[i*4+j] = m[j*4+i];
            m[j*4+i] = tmp;
        }
    }
}

/* Used for GL_ARB_transpose_matrix */
static void TransposeMatrixi(GLint m[16])
{
    int i, j;
    for (i = 0; i < 4; i++) {
        for (j = 0; j < i; j++) {
            GLint tmp = m[i*4+j];
            m[i*4+j] = m[j*4+i];
            m[j*4+i] = tmp;
        }
    }
}

a76 19
#define CASE_ARRAY_ENABLE(enum_name,array,dest,gl_type) \
    case GL_ ## enum_name ## _ARRAY: \
      *dest = (gl_type) state->vertArray. array .enable ; break
#define CASE_ARRAY_SIZE(enum_name,array,dest,gl_type) \
    case GL_ ## enum_name ## _ARRAY_SIZE: \
      *dest = (gl_type) state->vertArray. array .size ; break
#define CASE_ARRAY_TYPE(enum_name,array,dest,gl_type) \
    case GL_ ## enum_name ## _ARRAY_TYPE: \
      *dest = (gl_type) state->vertArray. array .type ; break
#define CASE_ARRAY_STRIDE(enum_name,array,dest,gl_type) \
    case GL_ ## enum_name ## _ARRAY_STRIDE: \
      *dest = (gl_type) state->vertArray. array .stride ; break

#define CASE_ARRAY_ALL(enum_name,array,dest,gl_type) \
	CASE_ARRAY_ENABLE(enum_name,array,dest,gl_type); \
	CASE_ARRAY_STRIDE(enum_name,array,dest,gl_type); \
	CASE_ARRAY_TYPE(enum_name,array,dest,gl_type); \
	CASE_ARRAY_SIZE(enum_name,array,dest,gl_type)

a78 1
    const GLenum origVal = val;
a79 1
    __GLXattribute * state = (__GLXattribute *)(gc->client_state_private);
a81 13
    if (val == GL_TRANSPOSE_MODELVIEW_MATRIX_ARB) {
       val = GL_MODELVIEW_MATRIX;
    }
    else if (val == GL_TRANSPOSE_PROJECTION_MATRIX_ARB) {
       val = GL_PROJECTION_MATRIX;
    }
    else if (val == GL_TRANSPOSE_TEXTURE_MATRIX_ARB) {
       val = GL_TEXTURE_MATRIX;
    }
    else if (val == GL_TRANSPOSE_COLOR_MATRIX_ARB) {
       val = GL_COLOR_MATRIX;
    }

d102 1
a102 1
	    *b = (GLboolean)state->storePack.rowLength;
d105 1
a105 1
	    *b = (GLboolean)state->storePack.imageHeight;
d108 1
a108 1
	    *b = (GLboolean)state->storePack.skipRows;
d111 1
a111 1
	    *b = (GLboolean)state->storePack.skipPixels;
d114 1
a114 1
	    *b = (GLboolean)state->storePack.skipImages;
d117 1
a117 1
	    *b = (GLboolean)state->storePack.alignment;
d120 1
a120 1
	    *b = (GLboolean)state->storePack.swapEndian;
d123 1
a123 1
	    *b = (GLboolean)state->storePack.lsbFirst;
d126 1
a126 1
	    *b = (GLboolean)state->storeUnpack.rowLength;
d129 1
a129 1
	    *b = (GLboolean)state->storeUnpack.imageHeight;
d132 1
a132 1
	    *b = (GLboolean)state->storeUnpack.skipRows;
d135 1
a135 1
	    *b = (GLboolean)state->storeUnpack.skipPixels;
d138 1
a138 1
	    *b = (GLboolean)state->storeUnpack.skipImages;
d141 1
a141 1
	    *b = (GLboolean)state->storeUnpack.alignment;
d144 1
a144 1
	    *b = (GLboolean)state->storeUnpack.swapEndian;
d147 1
a147 1
	    *b = (GLboolean)state->storeUnpack.lsbFirst;
d150 1
a150 1
	    *b = (GLboolean)state->vertArray.vertex.enable;
d153 1
a153 1
	    *b = (GLboolean)state->vertArray.vertex.size;
d156 1
a156 1
	    *b = (GLboolean)state->vertArray.vertex.type;
d159 1
a159 1
	    *b = (GLboolean)state->vertArray.vertex.stride;
d162 1
a162 1
	    *b = (GLboolean)state->vertArray.normal.enable;
d165 1
a165 1
	    *b = (GLboolean)state->vertArray.normal.type;
d168 1
a168 1
	    *b = (GLboolean)state->vertArray.normal.stride;
d171 1
a171 1
	    *b = (GLboolean)state->vertArray.color.enable;
d174 1
a174 1
	    *b = (GLboolean)state->vertArray.color.size;
d177 1
a177 1
	    *b = (GLboolean)state->vertArray.color.type;
d180 1
a180 1
	    *b = (GLboolean)state->vertArray.color.stride;
d183 1
a183 1
	    *b = (GLboolean)state->vertArray.index.enable;
d186 1
a186 1
	    *b = (GLboolean)state->vertArray.index.type;
d189 1
a189 1
	    *b = (GLboolean)state->vertArray.index.stride;
d192 1
a192 1
	    *b = (GLboolean)state->vertArray.texCoord[state->vertArray.activeTexture].enable;
d195 1
a195 1
	    *b = (GLboolean)state->vertArray.texCoord[state->vertArray.activeTexture].size;
d198 1
a198 1
	    *b = (GLboolean)state->vertArray.texCoord[state->vertArray.activeTexture].type;
d201 1
a201 1
	    *b = (GLboolean)state->vertArray.texCoord[state->vertArray.activeTexture].stride;
d204 1
a204 1
	    *b = (GLboolean)state->vertArray.edgeFlag.enable;
d207 1
a207 1
	    *b = (GLboolean)state->vertArray.edgeFlag.stride;
a208 7

	  CASE_ARRAY_ALL(SECONDARY_COLOR, secondaryColor, b, GLboolean);

	  CASE_ARRAY_ENABLE(FOG_COORDINATE, fogCoord, b, GLboolean);
	  CASE_ARRAY_TYPE(FOG_COORDINATE, fogCoord, b, GLboolean);
	  CASE_ARRAY_STRIDE(FOG_COORDINATE, fogCoord, b, GLboolean);

d210 1
a210 1
	    *b = (GLboolean)state->vertArray.maxElementsVertices;
d213 1
a213 1
	    *b = (GLboolean)state->vertArray.maxElementsIndices;
d219 1
a219 1
	    *b = (GLboolean)(state->vertArray.activeTexture + GL_TEXTURE0_ARB);
a228 4
                if (val != origVal) {
                   /* matrix transpose */
                   TransposeMatrixb(b);
                }
a236 1
    const GLenum origVal = val;
a237 1
    __GLXattribute * state = (__GLXattribute *)(gc->client_state_private);
a239 13
    if (val == GL_TRANSPOSE_MODELVIEW_MATRIX_ARB) {
       val = GL_MODELVIEW_MATRIX;
    }
    else if (val == GL_TRANSPOSE_PROJECTION_MATRIX_ARB) {
       val = GL_PROJECTION_MATRIX;
    }
    else if (val == GL_TRANSPOSE_TEXTURE_MATRIX_ARB) {
       val = GL_TEXTURE_MATRIX;
    }
    else if (val == GL_TRANSPOSE_COLOR_MATRIX_ARB) {
       val = GL_COLOR_MATRIX;
    }

d260 1
a260 1
	    *d = (GLdouble)state->storePack.rowLength;
d263 1
a263 1
	    *d = (GLdouble)state->storePack.imageHeight;
d266 1
a266 1
	    *d = (GLdouble)state->storePack.skipRows;
d269 1
a269 1
	    *d = (GLdouble)state->storePack.skipPixels;
d272 1
a272 1
	    *d = (GLdouble)state->storePack.skipImages;
d275 1
a275 1
	    *d = (GLdouble)state->storePack.alignment;
d278 1
a278 1
	    *d = (GLdouble)state->storePack.swapEndian;
d281 1
a281 1
	    *d = (GLdouble)state->storePack.lsbFirst;
d284 1
a284 1
	    *d = (GLdouble)state->storeUnpack.rowLength;
d287 1
a287 1
	    *d = (GLdouble)state->storeUnpack.imageHeight;
d290 1
a290 1
	    *d = (GLdouble)state->storeUnpack.skipRows;
d293 1
a293 1
	    *d = (GLdouble)state->storeUnpack.skipPixels;
d296 1
a296 1
	    *d = (GLdouble)state->storeUnpack.skipImages;
d299 1
a299 1
	    *d = (GLdouble)state->storeUnpack.alignment;
d302 1
a302 1
	    *d = (GLdouble)state->storeUnpack.swapEndian;
d305 1
a305 1
	    *d = (GLdouble)state->storeUnpack.lsbFirst;
d308 1
a308 1
	    *d = (GLdouble)state->vertArray.vertex.enable;
d311 1
a311 1
	    *d = (GLdouble)state->vertArray.vertex.size;
d314 1
a314 1
	    *d = (GLdouble)state->vertArray.vertex.type;
d317 1
a317 1
	    *d = (GLdouble)state->vertArray.vertex.stride;
d320 1
a320 1
	    *d = (GLdouble)state->vertArray.normal.enable;
d323 1
a323 1
	    *d = (GLdouble)state->vertArray.normal.type;
d326 1
a326 1
	    *d = (GLdouble)state->vertArray.normal.stride;
d329 1
a329 1
	    *d = (GLdouble)state->vertArray.color.enable;
d332 1
a332 1
	    *d = (GLdouble)state->vertArray.color.size;
d335 1
a335 1
	    *d = (GLdouble)state->vertArray.color.type;
d338 1
a338 1
	    *d = (GLdouble)state->vertArray.color.stride;
d341 1
a341 1
	    *d = (GLdouble)state->vertArray.index.enable;
d344 1
a344 1
	    *d = (GLdouble)state->vertArray.index.type;
d347 1
a347 1
	    *d = (GLdouble)state->vertArray.index.stride;
d350 1
a350 1
	    *d = (GLdouble)state->vertArray.texCoord[state->vertArray.activeTexture].enable;
d353 1
a353 1
	    *d = (GLdouble)state->vertArray.texCoord[state->vertArray.activeTexture].size;
d356 1
a356 1
	    *d = (GLdouble)state->vertArray.texCoord[state->vertArray.activeTexture].type;
d359 1
a359 1
	    *d = (GLdouble)state->vertArray.texCoord[state->vertArray.activeTexture].stride;
d362 1
a362 1
	    *d = (GLdouble)state->vertArray.edgeFlag.enable;
d365 1
a365 1
	    *d = (GLdouble)state->vertArray.edgeFlag.stride;
a366 7

	  CASE_ARRAY_ALL(SECONDARY_COLOR, secondaryColor, d, GLdouble);

	  CASE_ARRAY_ENABLE(FOG_COORDINATE, fogCoord, d, GLdouble);
	  CASE_ARRAY_TYPE(FOG_COORDINATE, fogCoord, d, GLdouble);
	  CASE_ARRAY_STRIDE(FOG_COORDINATE, fogCoord, d, GLdouble);

d368 1
a368 1
	    *d = (GLdouble)state->vertArray.maxElementsVertices;
d371 1
a371 1
	    *d = (GLdouble)state->vertArray.maxElementsIndices;
d377 1
a377 1
	    *d = (GLdouble)(state->vertArray.activeTexture + GL_TEXTURE0_ARB);
a386 4
                if (val != origVal) {
                   /* matrix transpose */
                   TransposeMatrixd(d);
                }
a394 1
    const GLenum origVal = val;
a395 1
    __GLXattribute * state = (__GLXattribute *)(gc->client_state_private);
a397 13
    if (val == GL_TRANSPOSE_MODELVIEW_MATRIX_ARB) {
       val = GL_MODELVIEW_MATRIX;
    }
    else if (val == GL_TRANSPOSE_PROJECTION_MATRIX_ARB) {
       val = GL_PROJECTION_MATRIX;
    }
    else if (val == GL_TRANSPOSE_TEXTURE_MATRIX_ARB) {
       val = GL_TEXTURE_MATRIX;
    }
    else if (val == GL_TRANSPOSE_COLOR_MATRIX_ARB) {
       val = GL_COLOR_MATRIX;
    }

d418 1
a418 1
	    *f = (GLfloat)state->storePack.rowLength;
d421 1
a421 1
	    *f = (GLfloat)state->storePack.imageHeight;
d424 1
a424 1
	    *f = (GLfloat)state->storePack.skipRows;
d427 1
a427 1
	    *f = (GLfloat)state->storePack.skipPixels;
d430 1
a430 1
	    *f = (GLfloat)state->storePack.skipImages;
d433 1
a433 1
	    *f = (GLfloat)state->storePack.alignment;
d436 1
a436 1
	    *f = (GLfloat)state->storePack.swapEndian;
d439 1
a439 1
	    *f = (GLfloat)state->storePack.lsbFirst;
d442 1
a442 1
	    *f = (GLfloat)state->storeUnpack.rowLength;
d445 1
a445 1
	    *f = (GLfloat)state->storeUnpack.imageHeight;
d448 1
a448 1
	    *f = (GLfloat)state->storeUnpack.skipRows;
d451 1
a451 1
	    *f = (GLfloat)state->storeUnpack.skipPixels;
d454 1
a454 1
	    *f = (GLfloat)state->storeUnpack.skipImages;
d457 1
a457 1
	    *f = (GLfloat)state->storeUnpack.alignment;
d460 1
a460 1
	    *f = (GLfloat)state->storeUnpack.swapEndian;
d463 1
a463 1
	    *f = (GLfloat)state->storeUnpack.lsbFirst;
d466 1
a466 1
	    *f = (GLfloat)state->vertArray.vertex.enable;
d469 1
a469 1
	    *f = (GLfloat)state->vertArray.vertex.size;
d472 1
a472 1
	    *f = (GLfloat)state->vertArray.vertex.type;
d475 1
a475 1
	    *f = (GLfloat)state->vertArray.vertex.stride;
d478 1
a478 1
	    *f = (GLfloat)state->vertArray.normal.enable;
d481 1
a481 1
	    *f = (GLfloat)state->vertArray.normal.type;
d484 1
a484 1
	    *f = (GLfloat)state->vertArray.normal.stride;
d487 1
a487 1
	    *f = (GLfloat)state->vertArray.color.enable;
d490 1
a490 1
	    *f = (GLfloat)state->vertArray.color.size;
d493 1
a493 1
	    *f = (GLfloat)state->vertArray.color.type;
d496 1
a496 1
	    *f = (GLfloat)state->vertArray.color.stride;
d499 1
a499 1
	    *f = (GLfloat)state->vertArray.index.enable;
d502 1
a502 1
	    *f = (GLfloat)state->vertArray.index.type;
d505 1
a505 1
	    *f = (GLfloat)state->vertArray.index.stride;
d508 1
a508 1
	    *f = (GLfloat)state->vertArray.texCoord[state->vertArray.activeTexture].enable;
d511 1
a511 1
	    *f = (GLfloat)state->vertArray.texCoord[state->vertArray.activeTexture].size;
d514 1
a514 1
	    *f = (GLfloat)state->vertArray.texCoord[state->vertArray.activeTexture].type;
d517 1
a517 1
	    *f = (GLfloat)state->vertArray.texCoord[state->vertArray.activeTexture].stride;
d520 1
a520 1
	    *f = (GLfloat)state->vertArray.edgeFlag.enable;
d523 1
a523 1
	    *f = (GLfloat)state->vertArray.edgeFlag.stride;
a524 7

	  CASE_ARRAY_ALL(SECONDARY_COLOR, secondaryColor, f, GLfloat);

	  CASE_ARRAY_ENABLE(FOG_COORDINATE, fogCoord, f, GLfloat);
	  CASE_ARRAY_TYPE(FOG_COORDINATE, fogCoord, f, GLfloat);
	  CASE_ARRAY_STRIDE(FOG_COORDINATE, fogCoord, f, GLfloat);

d526 1
a526 1
	    *f = (GLfloat)state->vertArray.maxElementsVertices;
d529 1
a529 1
	    *f = (GLfloat)state->vertArray.maxElementsIndices;
d535 1
a535 1
	    *f = (GLfloat)(state->vertArray.activeTexture + GL_TEXTURE0_ARB);
a544 4
                if (val != origVal) {
                   /* matrix transpose */
                   TransposeMatrixf(f);
                }
a552 1
    const GLenum origVal = val;
a553 1
    __GLXattribute * state = (__GLXattribute *)(gc->client_state_private);
a555 13
    if (val == GL_TRANSPOSE_MODELVIEW_MATRIX_ARB) {
       val = GL_MODELVIEW_MATRIX;
    }
    else if (val == GL_TRANSPOSE_PROJECTION_MATRIX_ARB) {
       val = GL_PROJECTION_MATRIX;
    }
    else if (val == GL_TRANSPOSE_TEXTURE_MATRIX_ARB) {
       val = GL_TEXTURE_MATRIX;
    }
    else if (val == GL_TRANSPOSE_COLOR_MATRIX_ARB) {
       val = GL_COLOR_MATRIX;
    }

d576 1
a576 1
	    *i = (GLint)state->storePack.rowLength;
d579 1
a579 1
	    *i = (GLint)state->storePack.imageHeight;
d582 1
a582 1
	    *i = (GLint)state->storePack.skipRows;
d585 1
a585 1
	    *i = (GLint)state->storePack.skipPixels;
d588 1
a588 1
	    *i = (GLint)state->storePack.skipImages;
d591 1
a591 1
	    *i = (GLint)state->storePack.alignment;
d594 1
a594 1
	    *i = (GLint)state->storePack.swapEndian;
d597 1
a597 1
	    *i = (GLint)state->storePack.lsbFirst;
d600 1
a600 1
	    *i = (GLint)state->storeUnpack.rowLength;
d603 1
a603 1
	    *i = (GLint)state->storeUnpack.imageHeight;
d606 1
a606 1
	    *i = (GLint)state->storeUnpack.skipRows;
d609 1
a609 1
	    *i = (GLint)state->storeUnpack.skipPixels;
d612 1
a612 1
	    *i = (GLint)state->storeUnpack.skipImages;
d615 1
a615 1
	    *i = (GLint)state->storeUnpack.alignment;
d618 1
a618 1
	    *i = (GLint)state->storeUnpack.swapEndian;
d621 1
a621 1
	    *i = (GLint)state->storeUnpack.lsbFirst;
d624 1
a624 1
	    *i = (GLint)state->vertArray.vertex.enable;
d627 1
a627 1
	    *i = (GLint)state->vertArray.vertex.size;
d630 1
a630 1
	    *i = (GLint)state->vertArray.vertex.type;
d633 1
a633 1
	    *i = (GLint)state->vertArray.vertex.stride;
d636 1
a636 1
	    *i = (GLint)state->vertArray.normal.enable;
d639 1
a639 1
	    *i = (GLint)state->vertArray.normal.type;
d642 1
a642 1
	    *i = (GLint)state->vertArray.normal.stride;
d645 1
a645 1
	    *i = (GLint)state->vertArray.color.enable;
d648 1
a648 1
	    *i = (GLint)state->vertArray.color.size;
d651 1
a651 1
	    *i = (GLint)state->vertArray.color.type;
d654 1
a654 1
	    *i = (GLint)state->vertArray.color.stride;
d657 1
a657 1
	    *i = (GLint)state->vertArray.index.enable;
d660 1
a660 1
	    *i = (GLint)state->vertArray.index.type;
d663 1
a663 1
	    *i = (GLint)state->vertArray.index.stride;
d666 1
a666 1
	    *i = (GLint)state->vertArray.texCoord[state->vertArray.activeTexture].enable;
d669 1
a669 1
	    *i = (GLint)state->vertArray.texCoord[state->vertArray.activeTexture].size;
d672 1
a672 1
	    *i = (GLint)state->vertArray.texCoord[state->vertArray.activeTexture].type;
d675 1
a675 1
	    *i = (GLint)state->vertArray.texCoord[state->vertArray.activeTexture].stride;
d678 1
a678 1
	    *i = (GLint)state->vertArray.edgeFlag.enable;
d681 1
a681 1
	    *i = (GLint)state->vertArray.edgeFlag.stride;
a682 7

	  CASE_ARRAY_ALL(SECONDARY_COLOR, secondaryColor, i, GLint);

	  CASE_ARRAY_ENABLE(FOG_COORDINATE, fogCoord, i, GLint);
	  CASE_ARRAY_TYPE(FOG_COORDINATE, fogCoord, i, GLint);
	  CASE_ARRAY_STRIDE(FOG_COORDINATE, fogCoord, i, GLint);

d684 1
a684 1
	    *i = (GLint)state->vertArray.maxElementsVertices;
d687 1
a687 1
	    *i = (GLint)state->vertArray.maxElementsIndices;
d693 1
a693 1
	    *i = (GLint)(state->vertArray.activeTexture + GL_TEXTURE0_ARB);
a702 4
                if (val != origVal) {
                   /* matrix transpose */
                   TransposeMatrixi(i);
                }
d858 3
a860 29
	  case GL_VERSION: {
	     double server_version = strtod((char *)s, NULL);
	     double client_version = strtod(__glXGLClientVersion, NULL);

	     if ( server_version <= client_version ) {
		gc->version = s;
	     }
	     else {
		gc->version = Xmalloc( strlen(__glXGLClientVersion)
				       + strlen((char *)s) + 4 );
		if ( gc->version == NULL ) {
		   /* If we couldn't allocate memory for the new string,
		    * make a best-effort and just copy the client-side version
		    * to the string and use that.  It probably doesn't
		    * matter what is done here.  If there not memory available
		    * for a short string, the system is probably going to die
		    * soon anyway.
		    */
		   strcpy((char *)s, __glXGLClientVersion);
		}
		else {
		   sprintf( (char *)gc->version, "%s (%s)",
			    __glXGLClientVersion, s );
		   Xfree( s );
		   s = gc->version;
		}
	     }
	     break;
	  }
d862 1
a862 3
	    gc->extensions = (GLubyte *)__glXCombineExtensionStrings( (const char *)s, __glXGLClientExtensions );
	    XFree( s );
	    s = gc->extensions;
a872 1
    __GLXattribute * state = (__GLXattribute *)(gc->client_state_private);
d880 1
a880 1
	  return state->vertArray.vertex.enable;
d882 1
a882 1
	  return state->vertArray.normal.enable;
d884 1
a884 1
	  return state->vertArray.color.enable;
d886 1
a886 1
	  return state->vertArray.index.enable;
d888 1
a888 1
	  return state->vertArray.texCoord[state->vertArray.activeTexture].enable;
d890 1
a890 5
	  return state->vertArray.edgeFlag.enable;
      case GL_SECONDARY_COLOR_ARRAY:
	  return state->vertArray.secondaryColor.enable;
      case GL_FOG_COORDINATE_ARRAY:
	  return state->vertArray.fogCoord.enable;
a904 1
    __GLXattribute * state = (__GLXattribute *)(gc->client_state_private);
d911 1
a911 1
	  *params = (void *)state->vertArray.vertex.ptr;
d914 1
a914 1
	  *params = (void *)state->vertArray.normal.ptr;
d917 1
a917 1
	  *params = (void *)state->vertArray.color.ptr;
d920 1
a920 1
	  *params = (void *)state->vertArray.index.ptr;
d923 1
a923 1
	  *params = (void *)state->vertArray.texCoord[state->vertArray.activeTexture].ptr;
d926 1
a926 7
	  *params = (void *)state->vertArray.edgeFlag.ptr;
	return;
      case GL_SECONDARY_COLOR_ARRAY_POINTER:
	  *params = (void *)state->vertArray.secondaryColor.ptr;
	return;
      case GL_FOG_COORDINATE_ARRAY_POINTER:
	  *params = (void *)state->vertArray.fogCoord.ptr;
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/lib/GL/glx/single2.c,v 1.4 2002/02/22 21:32:54 dawes Exp $ */
a40 52
/* Used for GL_ARB_transpose_matrix */
static void TransposeMatrixf(GLfloat m[16])
{
    int i, j;
    for (i = 0; i < 4; i++) {
        for (j = 0; j < i; j++) {
            GLfloat tmp = m[i*4+j];
            m[i*4+j] = m[j*4+i];
            m[j*4+i] = tmp;
        }
    }
}

/* Used for GL_ARB_transpose_matrix */
static void TransposeMatrixb(GLboolean m[16])
{
    int i, j;
    for (i = 0; i < 4; i++) {
        for (j = 0; j < i; j++) {
            GLboolean tmp = m[i*4+j];
            m[i*4+j] = m[j*4+i];
            m[j*4+i] = tmp;
        }
    }
}

/* Used for GL_ARB_transpose_matrix */
static void TransposeMatrixd(GLdouble m[16])
{
    int i, j;
    for (i = 0; i < 4; i++) {
        for (j = 0; j < i; j++) {
            GLdouble tmp = m[i*4+j];
            m[i*4+j] = m[j*4+i];
            m[j*4+i] = tmp;
        }
    }
}

/* Used for GL_ARB_transpose_matrix */
static void TransposeMatrixi(GLint m[16])
{
    int i, j;
    for (i = 0; i < 4; i++) {
        for (j = 0; j < i; j++) {
            GLint tmp = m[i*4+j];
            m[i*4+j] = m[j*4+i];
            m[j*4+i] = tmp;
        }
    }
}

a78 1
    const GLenum origVal = val;
a81 13
    if (val == GL_TRANSPOSE_MODELVIEW_MATRIX_ARB) {
       val = GL_MODELVIEW_MATRIX;
    }
    else if (val == GL_TRANSPOSE_PROJECTION_MATRIX_ARB) {
       val = GL_PROJECTION_MATRIX;
    }
    else if (val == GL_TRANSPOSE_TEXTURE_MATRIX_ARB) {
       val = GL_TEXTURE_MATRIX;
    }
    else if (val == GL_TRANSPOSE_COLOR_MATRIX_ARB) {
       val = GL_COLOR_MATRIX;
    }

a228 4
                if (val != origVal) {
                   /* matrix transpose */
                   TransposeMatrixb(b);
                }
a236 1
    const GLenum origVal = val;
a239 13
    if (val == GL_TRANSPOSE_MODELVIEW_MATRIX_ARB) {
       val = GL_MODELVIEW_MATRIX;
    }
    else if (val == GL_TRANSPOSE_PROJECTION_MATRIX_ARB) {
       val = GL_PROJECTION_MATRIX;
    }
    else if (val == GL_TRANSPOSE_TEXTURE_MATRIX_ARB) {
       val = GL_TEXTURE_MATRIX;
    }
    else if (val == GL_TRANSPOSE_COLOR_MATRIX_ARB) {
       val = GL_COLOR_MATRIX;
    }

a386 4
                if (val != origVal) {
                   /* matrix transpose */
                   TransposeMatrixd(d);
                }
a394 1
    const GLenum origVal = val;
a397 13
    if (val == GL_TRANSPOSE_MODELVIEW_MATRIX_ARB) {
       val = GL_MODELVIEW_MATRIX;
    }
    else if (val == GL_TRANSPOSE_PROJECTION_MATRIX_ARB) {
       val = GL_PROJECTION_MATRIX;
    }
    else if (val == GL_TRANSPOSE_TEXTURE_MATRIX_ARB) {
       val = GL_TEXTURE_MATRIX;
    }
    else if (val == GL_TRANSPOSE_COLOR_MATRIX_ARB) {
       val = GL_COLOR_MATRIX;
    }

a544 4
                if (val != origVal) {
                   /* matrix transpose */
                   TransposeMatrixf(f);
                }
a552 1
    const GLenum origVal = val;
a555 13
    if (val == GL_TRANSPOSE_MODELVIEW_MATRIX_ARB) {
       val = GL_MODELVIEW_MATRIX;
    }
    else if (val == GL_TRANSPOSE_PROJECTION_MATRIX_ARB) {
       val = GL_PROJECTION_MATRIX;
    }
    else if (val == GL_TRANSPOSE_TEXTURE_MATRIX_ARB) {
       val = GL_TEXTURE_MATRIX;
    }
    else if (val == GL_TRANSPOSE_COLOR_MATRIX_ARB) {
       val = GL_COLOR_MATRIX;
    }

a702 4
                if (val != origVal) {
                   /* matrix transpose */
                   TransposeMatrixi(i);
                }
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/lib/GL/glx/single2.c,v 1.11 2004/02/11 20:01:21 dawes Exp $ */
a128 19
#define CASE_ARRAY_ENABLE(enum_name,array,dest,gl_type) \
    case GL_ ## enum_name ## _ARRAY: \
      *dest = (gl_type) state->vertArray. array .enable ; break
#define CASE_ARRAY_SIZE(enum_name,array,dest,gl_type) \
    case GL_ ## enum_name ## _ARRAY_SIZE: \
      *dest = (gl_type) state->vertArray. array .size ; break
#define CASE_ARRAY_TYPE(enum_name,array,dest,gl_type) \
    case GL_ ## enum_name ## _ARRAY_TYPE: \
      *dest = (gl_type) state->vertArray. array .type ; break
#define CASE_ARRAY_STRIDE(enum_name,array,dest,gl_type) \
    case GL_ ## enum_name ## _ARRAY_STRIDE: \
      *dest = (gl_type) state->vertArray. array .stride ; break

#define CASE_ARRAY_ALL(enum_name,array,dest,gl_type) \
	CASE_ARRAY_ENABLE(enum_name,array,dest,gl_type); \
	CASE_ARRAY_STRIDE(enum_name,array,dest,gl_type); \
	CASE_ARRAY_TYPE(enum_name,array,dest,gl_type); \
	CASE_ARRAY_SIZE(enum_name,array,dest,gl_type)

a132 1
    __GLXattribute * state = (__GLXattribute *)(gc->client_state_private);
d168 1
a168 1
	    *b = (GLboolean)state->storePack.rowLength;
d171 1
a171 1
	    *b = (GLboolean)state->storePack.imageHeight;
d174 1
a174 1
	    *b = (GLboolean)state->storePack.skipRows;
d177 1
a177 1
	    *b = (GLboolean)state->storePack.skipPixels;
d180 1
a180 1
	    *b = (GLboolean)state->storePack.skipImages;
d183 1
a183 1
	    *b = (GLboolean)state->storePack.alignment;
d186 1
a186 1
	    *b = (GLboolean)state->storePack.swapEndian;
d189 1
a189 1
	    *b = (GLboolean)state->storePack.lsbFirst;
d192 1
a192 1
	    *b = (GLboolean)state->storeUnpack.rowLength;
d195 1
a195 1
	    *b = (GLboolean)state->storeUnpack.imageHeight;
d198 1
a198 1
	    *b = (GLboolean)state->storeUnpack.skipRows;
d201 1
a201 1
	    *b = (GLboolean)state->storeUnpack.skipPixels;
d204 1
a204 1
	    *b = (GLboolean)state->storeUnpack.skipImages;
d207 1
a207 1
	    *b = (GLboolean)state->storeUnpack.alignment;
d210 1
a210 1
	    *b = (GLboolean)state->storeUnpack.swapEndian;
d213 1
a213 1
	    *b = (GLboolean)state->storeUnpack.lsbFirst;
d216 1
a216 1
	    *b = (GLboolean)state->vertArray.vertex.enable;
d219 1
a219 1
	    *b = (GLboolean)state->vertArray.vertex.size;
d222 1
a222 1
	    *b = (GLboolean)state->vertArray.vertex.type;
d225 1
a225 1
	    *b = (GLboolean)state->vertArray.vertex.stride;
d228 1
a228 1
	    *b = (GLboolean)state->vertArray.normal.enable;
d231 1
a231 1
	    *b = (GLboolean)state->vertArray.normal.type;
d234 1
a234 1
	    *b = (GLboolean)state->vertArray.normal.stride;
d237 1
a237 1
	    *b = (GLboolean)state->vertArray.color.enable;
d240 1
a240 1
	    *b = (GLboolean)state->vertArray.color.size;
d243 1
a243 1
	    *b = (GLboolean)state->vertArray.color.type;
d246 1
a246 1
	    *b = (GLboolean)state->vertArray.color.stride;
d249 1
a249 1
	    *b = (GLboolean)state->vertArray.index.enable;
d252 1
a252 1
	    *b = (GLboolean)state->vertArray.index.type;
d255 1
a255 1
	    *b = (GLboolean)state->vertArray.index.stride;
d258 1
a258 1
	    *b = (GLboolean)state->vertArray.texCoord[state->vertArray.activeTexture].enable;
d261 1
a261 1
	    *b = (GLboolean)state->vertArray.texCoord[state->vertArray.activeTexture].size;
d264 1
a264 1
	    *b = (GLboolean)state->vertArray.texCoord[state->vertArray.activeTexture].type;
d267 1
a267 1
	    *b = (GLboolean)state->vertArray.texCoord[state->vertArray.activeTexture].stride;
d270 1
a270 1
	    *b = (GLboolean)state->vertArray.edgeFlag.enable;
d273 1
a273 1
	    *b = (GLboolean)state->vertArray.edgeFlag.stride;
a274 7

	  CASE_ARRAY_ALL(SECONDARY_COLOR, secondaryColor, b, GLboolean);

	  CASE_ARRAY_ENABLE(FOG_COORDINATE, fogCoord, b, GLboolean);
	  CASE_ARRAY_TYPE(FOG_COORDINATE, fogCoord, b, GLboolean);
	  CASE_ARRAY_STRIDE(FOG_COORDINATE, fogCoord, b, GLboolean);

d276 1
a276 1
	    *b = (GLboolean)state->vertArray.maxElementsVertices;
d279 1
a279 1
	    *b = (GLboolean)state->vertArray.maxElementsIndices;
d285 1
a285 1
	    *b = (GLboolean)(state->vertArray.activeTexture + GL_TEXTURE0_ARB);
a308 1
    __GLXattribute * state = (__GLXattribute *)(gc->client_state_private);
d344 1
a344 1
	    *d = (GLdouble)state->storePack.rowLength;
d347 1
a347 1
	    *d = (GLdouble)state->storePack.imageHeight;
d350 1
a350 1
	    *d = (GLdouble)state->storePack.skipRows;
d353 1
a353 1
	    *d = (GLdouble)state->storePack.skipPixels;
d356 1
a356 1
	    *d = (GLdouble)state->storePack.skipImages;
d359 1
a359 1
	    *d = (GLdouble)state->storePack.alignment;
d362 1
a362 1
	    *d = (GLdouble)state->storePack.swapEndian;
d365 1
a365 1
	    *d = (GLdouble)state->storePack.lsbFirst;
d368 1
a368 1
	    *d = (GLdouble)state->storeUnpack.rowLength;
d371 1
a371 1
	    *d = (GLdouble)state->storeUnpack.imageHeight;
d374 1
a374 1
	    *d = (GLdouble)state->storeUnpack.skipRows;
d377 1
a377 1
	    *d = (GLdouble)state->storeUnpack.skipPixels;
d380 1
a380 1
	    *d = (GLdouble)state->storeUnpack.skipImages;
d383 1
a383 1
	    *d = (GLdouble)state->storeUnpack.alignment;
d386 1
a386 1
	    *d = (GLdouble)state->storeUnpack.swapEndian;
d389 1
a389 1
	    *d = (GLdouble)state->storeUnpack.lsbFirst;
d392 1
a392 1
	    *d = (GLdouble)state->vertArray.vertex.enable;
d395 1
a395 1
	    *d = (GLdouble)state->vertArray.vertex.size;
d398 1
a398 1
	    *d = (GLdouble)state->vertArray.vertex.type;
d401 1
a401 1
	    *d = (GLdouble)state->vertArray.vertex.stride;
d404 1
a404 1
	    *d = (GLdouble)state->vertArray.normal.enable;
d407 1
a407 1
	    *d = (GLdouble)state->vertArray.normal.type;
d410 1
a410 1
	    *d = (GLdouble)state->vertArray.normal.stride;
d413 1
a413 1
	    *d = (GLdouble)state->vertArray.color.enable;
d416 1
a416 1
	    *d = (GLdouble)state->vertArray.color.size;
d419 1
a419 1
	    *d = (GLdouble)state->vertArray.color.type;
d422 1
a422 1
	    *d = (GLdouble)state->vertArray.color.stride;
d425 1
a425 1
	    *d = (GLdouble)state->vertArray.index.enable;
d428 1
a428 1
	    *d = (GLdouble)state->vertArray.index.type;
d431 1
a431 1
	    *d = (GLdouble)state->vertArray.index.stride;
d434 1
a434 1
	    *d = (GLdouble)state->vertArray.texCoord[state->vertArray.activeTexture].enable;
d437 1
a437 1
	    *d = (GLdouble)state->vertArray.texCoord[state->vertArray.activeTexture].size;
d440 1
a440 1
	    *d = (GLdouble)state->vertArray.texCoord[state->vertArray.activeTexture].type;
d443 1
a443 1
	    *d = (GLdouble)state->vertArray.texCoord[state->vertArray.activeTexture].stride;
d446 1
a446 1
	    *d = (GLdouble)state->vertArray.edgeFlag.enable;
d449 1
a449 1
	    *d = (GLdouble)state->vertArray.edgeFlag.stride;
a450 7

	  CASE_ARRAY_ALL(SECONDARY_COLOR, secondaryColor, d, GLdouble);

	  CASE_ARRAY_ENABLE(FOG_COORDINATE, fogCoord, d, GLdouble);
	  CASE_ARRAY_TYPE(FOG_COORDINATE, fogCoord, d, GLdouble);
	  CASE_ARRAY_STRIDE(FOG_COORDINATE, fogCoord, d, GLdouble);

d452 1
a452 1
	    *d = (GLdouble)state->vertArray.maxElementsVertices;
d455 1
a455 1
	    *d = (GLdouble)state->vertArray.maxElementsIndices;
d461 1
a461 1
	    *d = (GLdouble)(state->vertArray.activeTexture + GL_TEXTURE0_ARB);
a484 1
    __GLXattribute * state = (__GLXattribute *)(gc->client_state_private);
d520 1
a520 1
	    *f = (GLfloat)state->storePack.rowLength;
d523 1
a523 1
	    *f = (GLfloat)state->storePack.imageHeight;
d526 1
a526 1
	    *f = (GLfloat)state->storePack.skipRows;
d529 1
a529 1
	    *f = (GLfloat)state->storePack.skipPixels;
d532 1
a532 1
	    *f = (GLfloat)state->storePack.skipImages;
d535 1
a535 1
	    *f = (GLfloat)state->storePack.alignment;
d538 1
a538 1
	    *f = (GLfloat)state->storePack.swapEndian;
d541 1
a541 1
	    *f = (GLfloat)state->storePack.lsbFirst;
d544 1
a544 1
	    *f = (GLfloat)state->storeUnpack.rowLength;
d547 1
a547 1
	    *f = (GLfloat)state->storeUnpack.imageHeight;
d550 1
a550 1
	    *f = (GLfloat)state->storeUnpack.skipRows;
d553 1
a553 1
	    *f = (GLfloat)state->storeUnpack.skipPixels;
d556 1
a556 1
	    *f = (GLfloat)state->storeUnpack.skipImages;
d559 1
a559 1
	    *f = (GLfloat)state->storeUnpack.alignment;
d562 1
a562 1
	    *f = (GLfloat)state->storeUnpack.swapEndian;
d565 1
a565 1
	    *f = (GLfloat)state->storeUnpack.lsbFirst;
d568 1
a568 1
	    *f = (GLfloat)state->vertArray.vertex.enable;
d571 1
a571 1
	    *f = (GLfloat)state->vertArray.vertex.size;
d574 1
a574 1
	    *f = (GLfloat)state->vertArray.vertex.type;
d577 1
a577 1
	    *f = (GLfloat)state->vertArray.vertex.stride;
d580 1
a580 1
	    *f = (GLfloat)state->vertArray.normal.enable;
d583 1
a583 1
	    *f = (GLfloat)state->vertArray.normal.type;
d586 1
a586 1
	    *f = (GLfloat)state->vertArray.normal.stride;
d589 1
a589 1
	    *f = (GLfloat)state->vertArray.color.enable;
d592 1
a592 1
	    *f = (GLfloat)state->vertArray.color.size;
d595 1
a595 1
	    *f = (GLfloat)state->vertArray.color.type;
d598 1
a598 1
	    *f = (GLfloat)state->vertArray.color.stride;
d601 1
a601 1
	    *f = (GLfloat)state->vertArray.index.enable;
d604 1
a604 1
	    *f = (GLfloat)state->vertArray.index.type;
d607 1
a607 1
	    *f = (GLfloat)state->vertArray.index.stride;
d610 1
a610 1
	    *f = (GLfloat)state->vertArray.texCoord[state->vertArray.activeTexture].enable;
d613 1
a613 1
	    *f = (GLfloat)state->vertArray.texCoord[state->vertArray.activeTexture].size;
d616 1
a616 1
	    *f = (GLfloat)state->vertArray.texCoord[state->vertArray.activeTexture].type;
d619 1
a619 1
	    *f = (GLfloat)state->vertArray.texCoord[state->vertArray.activeTexture].stride;
d622 1
a622 1
	    *f = (GLfloat)state->vertArray.edgeFlag.enable;
d625 1
a625 1
	    *f = (GLfloat)state->vertArray.edgeFlag.stride;
a626 7

	  CASE_ARRAY_ALL(SECONDARY_COLOR, secondaryColor, f, GLfloat);

	  CASE_ARRAY_ENABLE(FOG_COORDINATE, fogCoord, f, GLfloat);
	  CASE_ARRAY_TYPE(FOG_COORDINATE, fogCoord, f, GLfloat);
	  CASE_ARRAY_STRIDE(FOG_COORDINATE, fogCoord, f, GLfloat);

d628 1
a628 1
	    *f = (GLfloat)state->vertArray.maxElementsVertices;
d631 1
a631 1
	    *f = (GLfloat)state->vertArray.maxElementsIndices;
d637 1
a637 1
	    *f = (GLfloat)(state->vertArray.activeTexture + GL_TEXTURE0_ARB);
a660 1
    __GLXattribute * state = (__GLXattribute *)(gc->client_state_private);
d696 1
a696 1
	    *i = (GLint)state->storePack.rowLength;
d699 1
a699 1
	    *i = (GLint)state->storePack.imageHeight;
d702 1
a702 1
	    *i = (GLint)state->storePack.skipRows;
d705 1
a705 1
	    *i = (GLint)state->storePack.skipPixels;
d708 1
a708 1
	    *i = (GLint)state->storePack.skipImages;
d711 1
a711 1
	    *i = (GLint)state->storePack.alignment;
d714 1
a714 1
	    *i = (GLint)state->storePack.swapEndian;
d717 1
a717 1
	    *i = (GLint)state->storePack.lsbFirst;
d720 1
a720 1
	    *i = (GLint)state->storeUnpack.rowLength;
d723 1
a723 1
	    *i = (GLint)state->storeUnpack.imageHeight;
d726 1
a726 1
	    *i = (GLint)state->storeUnpack.skipRows;
d729 1
a729 1
	    *i = (GLint)state->storeUnpack.skipPixels;
d732 1
a732 1
	    *i = (GLint)state->storeUnpack.skipImages;
d735 1
a735 1
	    *i = (GLint)state->storeUnpack.alignment;
d738 1
a738 1
	    *i = (GLint)state->storeUnpack.swapEndian;
d741 1
a741 1
	    *i = (GLint)state->storeUnpack.lsbFirst;
d744 1
a744 1
	    *i = (GLint)state->vertArray.vertex.enable;
d747 1
a747 1
	    *i = (GLint)state->vertArray.vertex.size;
d750 1
a750 1
	    *i = (GLint)state->vertArray.vertex.type;
d753 1
a753 1
	    *i = (GLint)state->vertArray.vertex.stride;
d756 1
a756 1
	    *i = (GLint)state->vertArray.normal.enable;
d759 1
a759 1
	    *i = (GLint)state->vertArray.normal.type;
d762 1
a762 1
	    *i = (GLint)state->vertArray.normal.stride;
d765 1
a765 1
	    *i = (GLint)state->vertArray.color.enable;
d768 1
a768 1
	    *i = (GLint)state->vertArray.color.size;
d771 1
a771 1
	    *i = (GLint)state->vertArray.color.type;
d774 1
a774 1
	    *i = (GLint)state->vertArray.color.stride;
d777 1
a777 1
	    *i = (GLint)state->vertArray.index.enable;
d780 1
a780 1
	    *i = (GLint)state->vertArray.index.type;
d783 1
a783 1
	    *i = (GLint)state->vertArray.index.stride;
d786 1
a786 1
	    *i = (GLint)state->vertArray.texCoord[state->vertArray.activeTexture].enable;
d789 1
a789 1
	    *i = (GLint)state->vertArray.texCoord[state->vertArray.activeTexture].size;
d792 1
a792 1
	    *i = (GLint)state->vertArray.texCoord[state->vertArray.activeTexture].type;
d795 1
a795 1
	    *i = (GLint)state->vertArray.texCoord[state->vertArray.activeTexture].stride;
d798 1
a798 1
	    *i = (GLint)state->vertArray.edgeFlag.enable;
d801 1
a801 1
	    *i = (GLint)state->vertArray.edgeFlag.stride;
a802 7

	  CASE_ARRAY_ALL(SECONDARY_COLOR, secondaryColor, i, GLint);

	  CASE_ARRAY_ENABLE(FOG_COORDINATE, fogCoord, i, GLint);
	  CASE_ARRAY_TYPE(FOG_COORDINATE, fogCoord, i, GLint);
	  CASE_ARRAY_STRIDE(FOG_COORDINATE, fogCoord, i, GLint);

d804 1
a804 1
	    *i = (GLint)state->vertArray.maxElementsVertices;
d807 1
a807 1
	    *i = (GLint)state->vertArray.maxElementsIndices;
d813 1
a813 1
	    *i = (GLint)(state->vertArray.activeTexture + GL_TEXTURE0_ARB);
d982 3
a984 29
	  case GL_VERSION: {
	     double server_version = strtod((char *)s, NULL);
	     double client_version = strtod(__glXGLClientVersion, NULL);

	     if ( server_version <= client_version ) {
		gc->version = s;
	     }
	     else {
		gc->version = Xmalloc( strlen(__glXGLClientVersion)
				       + strlen((char *)s) + 4 );
		if ( gc->version == NULL ) {
		   /* If we couldn't allocate memory for the new string,
		    * make a best-effort and just copy the client-side version
		    * to the string and use that.  It probably doesn't
		    * matter what is done here.  If there not memory available
		    * for a short string, the system is probably going to die
		    * soon anyway.
		    */
		   strcpy((char *)s, __glXGLClientVersion);
		}
		else {
		   sprintf( (char *)gc->version, "%s (%s)",
			    __glXGLClientVersion, s );
		   Xfree( s );
		   s = gc->version;
		}
	     }
	     break;
	  }
d986 1
a986 3
	    gc->extensions = (GLubyte *)__glXCombineExtensionStrings( (const char *)s, __glXGLClientExtensions );
	    XFree( s );
	    s = gc->extensions;
a996 1
    __GLXattribute * state = (__GLXattribute *)(gc->client_state_private);
d1004 1
a1004 1
	  return state->vertArray.vertex.enable;
d1006 1
a1006 1
	  return state->vertArray.normal.enable;
d1008 1
a1008 1
	  return state->vertArray.color.enable;
d1010 1
a1010 1
	  return state->vertArray.index.enable;
d1012 1
a1012 1
	  return state->vertArray.texCoord[state->vertArray.activeTexture].enable;
d1014 1
a1014 5
	  return state->vertArray.edgeFlag.enable;
      case GL_SECONDARY_COLOR_ARRAY:
	  return state->vertArray.secondaryColor.enable;
      case GL_FOG_COORDINATE_ARRAY:
	  return state->vertArray.fogCoord.enable;
a1028 1
    __GLXattribute * state = (__GLXattribute *)(gc->client_state_private);
d1035 1
a1035 1
	  *params = (void *)state->vertArray.vertex.ptr;
d1038 1
a1038 1
	  *params = (void *)state->vertArray.normal.ptr;
d1041 1
a1041 1
	  *params = (void *)state->vertArray.color.ptr;
d1044 1
a1044 1
	  *params = (void *)state->vertArray.index.ptr;
d1047 1
a1047 1
	  *params = (void *)state->vertArray.texCoord[state->vertArray.activeTexture].ptr;
d1050 1
a1050 7
	  *params = (void *)state->vertArray.edgeFlag.ptr;
	return;
      case GL_SECONDARY_COLOR_ARRAY_POINTER:
	  *params = (void *)state->vertArray.secondaryColor.ptr;
	return;
      case GL_FOG_COORDINATE_ARRAY_POINTER:
	  *params = (void *)state->vertArray.fogCoord.ptr;
@


