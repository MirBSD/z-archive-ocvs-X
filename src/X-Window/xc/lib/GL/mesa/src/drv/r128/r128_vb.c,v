head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.04.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.04.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.31.32;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.58.50;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.18.02;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $XFree86: xc/lib/GL/mesa/src/drv/r128/r128_vb.c,v 1.11 2001/01/08 01:07:24 martin Exp $ */
/**************************************************************************

Copyright 1999, 2000 ATI Technologies Inc. and Precision Insight, Inc.,
                                               Cedar Park, Texas.
All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
on the rights to use, copy, modify, merge, publish, distribute, sub
license, and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
ATI, PRECISION INSIGHT AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Gareth Hughes <gareth@@valinux.com>
 *   Kevin E. Martin <martin@@valinux.com>
 *
 */

#include "r128_context.h"
#include "r128_ioctl.h"
#include "r128_state.h"
#include "r128_vb.h"

#include "mem.h"
#include "stages.h"

#define TEX0								\
do {									\
   v->v.tu0 = tc0[i][0];						\
   v->v.tv0 = tc0[i][1];						\
} while (0)

#define TEX1								\
do {									\
   v->v.tu1 = tc1[i][0];						\
   v->v.tv1 = tc1[i][1];						\
} while (0)

#define SPC								\
do {									\
   GLubyte *spec = &(VB->Spec[0][i][0]);				\
   v->v.specular.blue  = spec[2];					\
   v->v.specular.green = spec[1];					\
   v->v.specular.red   = spec[0];					\
} while (0)

#define FOG								\
do {									\
   GLubyte *spec = &(VB->Spec[0][i][0]);				\
   v->v.specular.alpha = spec[3];					\
} while (0)

#define COL								\
do {									\
   GLubyte *col = &(VB->Color[0]->data[i][0]);				\
   v->v.color.blue  = col[2];						\
   v->v.color.green = col[1];						\
   v->v.color.red   = col[0];						\
   v->v.color.alpha = col[3];						\
} while (0)

#define TEX0_4								\
do {									\
   if ( VB->TexCoordPtr[0]->size == 4 ) {				\
      GLfloat (*tc)[4] = VB->TexCoordPtr[0]->data;			\
      v = &(R128_DRIVER_DATA(VB)->verts[start]);			\
      for ( i = start ; i < end ; i++, v++ ) {				\
	 float oow = 1.0 / tc[i][3];					\
	 v->v.rhw *= tc[i][3];						\
	 v->v.tu0 *= oow;						\
	 v->v.tv0 *= oow;						\
      }									\
   }									\
} while (0)

#ifdef USE_RHW2

#define TEX1_4								\
do {									\
   if ( VB->TexCoordPtr[1]->size == 4 ) {				\
      GLfloat (*tc)[4] = VB->TexCoordPtr[1]->data;			\
      v = &(R128_DRIVER_DATA(VB)->verts[start]);			\
      for ( i = start ; i < end ; i++, v++ ) {				\
	 float oow = 1.0 / tc[i][3];					\
	 v->v.rhw2 *= tc[i][3];						\
	 v->v.tu1 *= oow;						\
	 v->v.tv1 *= oow;						\
      }									\
   }									\
} while (0)

#define COORD								\
do {									\
   GLfloat *win = VB->Win.data[i];					\
   v->v.x =               win[0] + xoffset;				\
   v->v.y =             - win[1] + yoffset;				\
   v->v.z = depth_scale * win[2];					\
   v->v.rhw = v->v.rhw2 = win[3];					\
} while (0)

#else /* USE_RHW2 */

#define TEX1_4

#define COORD								\
do {									\
   GLfloat *win = VB->Win.data[i];					\
   v->v.x =               win[0] + xoffset;				\
   v->v.y =             - win[1] + yoffset;				\
   v->v.z = depth_scale * win[2];					\
   v->v.rhw =             win[3];					\
} while (0)

#endif /* USE_RHW2 */

#define NOP


#define SETUPFUNC(name,win,col,tex0,tex1,tex0_4,tex1_4,spec,fog)	\
static void name( struct vertex_buffer *VB, GLuint start, GLuint end )	\
{									\
   r128ContextPtr rmesa = R128_CONTEXT(VB->ctx);			\
   __DRIdrawablePrivate *dPriv = rmesa->driDrawable;			\
   r128VertexPtr v;							\
   GLfloat (*tc0)[4];							\
   GLfloat (*tc1)[4];							\
   const GLfloat depth_scale = rmesa->depth_scale;			\
   const GLfloat xoffset = SUBPIXEL_X;					\
   const GLfloat yoffset = dPriv->h + SUBPIXEL_Y;			\
   GLint i;								\
									\
   (void) xoffset; (void) yoffset; (void) depth_scale;			\
									\
   gl_import_client_data( VB, VB->ctx->RenderFlags,			\
			  (VB->ClipOrMask				\
			   ? VEC_WRITABLE | VEC_GOOD_STRIDE		\
			   : VEC_GOOD_STRIDE) );			\
									\
   tc0 = VB->TexCoordPtr[rmesa->tmu_source[0]]->data;			\
   tc1 = VB->TexCoordPtr[rmesa->tmu_source[1]]->data;			\
									\
   v = &(R128_DRIVER_DATA(VB)->verts[start]);				\
									\
   if ( VB->ClipOrMask == 0 ) {						\
      for ( i = start ; i < end ; i++, v++ ) {				\
	 win;								\
	 col;								\
	 spec;								\
	 fog;								\
	 tex0;								\
	 tex1;								\
      }									\
   } else {								\
      for ( i = start ; i < end ; i++, v++ ) {				\
	 if ( VB->ClipMask[i] == 0 ) {					\
	    win;							\
	    spec;							\
	    fog;							\
	    tex0;							\
	    tex1;							\
	 }								\
	 col;								\
      }									\
   }									\
   tex0_4;								\
   tex1_4;								\
}


SETUPFUNC(rs_wt0,	COORD, NOP, TEX0, NOP,  TEX0_4, NOP,    NOP, NOP)
SETUPFUNC(rs_wt0t1,	COORD, NOP, TEX0, TEX1, TEX0_4, TEX1_4, NOP, NOP)
SETUPFUNC(rs_wft0,	COORD, NOP, TEX0, NOP,  TEX0_4, NOP,    NOP, FOG)
SETUPFUNC(rs_wft0t1,	COORD, NOP, TEX0, TEX1, TEX0_4, TEX1_4, NOP, FOG)
SETUPFUNC(rs_wg,	COORD, COL, NOP,  NOP,  NOP,    NOP,    NOP, NOP)
SETUPFUNC(rs_wgs,	COORD, COL, NOP,  NOP,  NOP,    NOP,    SPC, NOP)
SETUPFUNC(rs_wgt0,	COORD, COL, TEX0, NOP,  TEX0_4, NOP,    NOP, NOP)
SETUPFUNC(rs_wgt0t1,	COORD, COL, TEX0, TEX1, TEX0_4, TEX1_4, NOP, NOP)
SETUPFUNC(rs_wgst0,	COORD, COL, TEX0, NOP,  TEX0_4, NOP,    SPC, NOP)
SETUPFUNC(rs_wgst0t1,	COORD, COL, TEX0, TEX1, TEX0_4, TEX1_4, SPC, NOP)
SETUPFUNC(rs_wgf,	COORD, COL, NOP,  NOP,  NOP,    NOP,    NOP, FOG)
SETUPFUNC(rs_wgfs,	COORD, COL, NOP,  NOP,  NOP,    NOP,    SPC, FOG)
SETUPFUNC(rs_wgft0,	COORD, COL, TEX0, NOP,  TEX0_4, NOP,    NOP, FOG)
SETUPFUNC(rs_wgft0t1,	COORD, COL, TEX0, TEX1, TEX0_4, TEX1_4, NOP, FOG)
SETUPFUNC(rs_wgfst0,	COORD, COL, TEX0, NOP,  TEX0_4, NOP,    SPC, FOG)
SETUPFUNC(rs_wgfst0t1,	COORD, COL, TEX0, TEX1, TEX0_4, TEX1_4, SPC, FOG)

SETUPFUNC(rs_t0,	NOP,   NOP, TEX0, NOP,  TEX0_4, NOP,    NOP, NOP)
SETUPFUNC(rs_t0t1,	NOP,   NOP, TEX0, TEX1, TEX0_4, TEX1_4, NOP, NOP)
SETUPFUNC(rs_f,		NOP,   NOP, NOP,  NOP,  NOP,    NOP,    NOP, FOG)
SETUPFUNC(rs_ft0,	NOP,   NOP, TEX0, NOP,  TEX0_4, NOP,    NOP, FOG)
SETUPFUNC(rs_ft0t1,	NOP,   NOP, TEX0, TEX1, TEX0_4, TEX1_4, NOP, FOG)
SETUPFUNC(rs_g,		NOP,   COL, NOP,  NOP,  NOP,    NOP,    NOP, NOP)
SETUPFUNC(rs_gs,	NOP,   COL, NOP,  NOP,  NOP,    NOP,    SPC, NOP)
SETUPFUNC(rs_gt0,	NOP,   COL, TEX0, NOP,  TEX0_4, NOP,    NOP, NOP)
SETUPFUNC(rs_gt0t1,	NOP,   COL, TEX0, TEX1, TEX0_4, TEX1_4, NOP, NOP)
SETUPFUNC(rs_gst0,	NOP,   COL, TEX0, NOP,  TEX0_4, NOP,    SPC, NOP)
SETUPFUNC(rs_gst0t1,	NOP,   COL, TEX0, TEX1, TEX0_4, TEX1_4, SPC, NOP)
SETUPFUNC(rs_gf,	NOP,   COL, NOP,  NOP,  NOP,    NOP,    NOP, FOG)
SETUPFUNC(rs_gfs,	NOP,   COL, NOP,  NOP,  NOP,    NOP,    SPC, FOG)
SETUPFUNC(rs_gft0,	NOP,   COL, TEX0, NOP,  TEX0_4, NOP,    NOP, FOG)
SETUPFUNC(rs_gft0t1,	NOP,   COL, TEX0, TEX1, TEX0_4, TEX1_4, NOP, FOG)
SETUPFUNC(rs_gfst0,	NOP,   COL, TEX0, NOP,  TEX0_4, NOP,    SPC, FOG)
SETUPFUNC(rs_gfst0t1,	NOP,   COL, TEX0, TEX1, TEX0_4, TEX1_4, SPC, FOG)


static void rs_invalid( struct vertex_buffer *VB, GLuint start, GLuint end )
{
   fprintf( stderr, "r128RasterSetup(): invalid setup function\n" );
}

typedef void (*setupFunc)( struct vertex_buffer *, GLuint, GLuint );
static setupFunc setup_func[R128_MAX_SETUPFUNC];


void r128DDSetupInit( void )
{
   GLint i;

   for ( i = 0 ; i < R128_MAX_SETUPFUNC ; i++ ) {
      setup_func[i] = rs_invalid;
   }

   /* Functions to build vertices from scratch
    */
   setup_func[R128_WIN_BIT|R128_TEX0_BIT] = rs_wt0;
   setup_func[R128_WIN_BIT|R128_TEX0_BIT|R128_TEX1_BIT] = rs_wt0t1;
   setup_func[R128_WIN_BIT|R128_FOG_BIT|R128_TEX0_BIT] = rs_wft0;
   setup_func[R128_WIN_BIT|R128_FOG_BIT|R128_TEX0_BIT|R128_TEX1_BIT] = rs_wft0t1;
   setup_func[R128_WIN_BIT|R128_RGBA_BIT] = rs_wg;
   setup_func[R128_WIN_BIT|R128_RGBA_BIT|R128_SPEC_BIT] = rs_wgs;
   setup_func[R128_WIN_BIT|R128_RGBA_BIT|R128_TEX0_BIT] = rs_wgt0;
   setup_func[R128_WIN_BIT|R128_RGBA_BIT|R128_TEX0_BIT|R128_TEX1_BIT] = rs_wgt0t1;
   setup_func[R128_WIN_BIT|R128_RGBA_BIT|R128_SPEC_BIT|R128_TEX0_BIT] = rs_wgst0;
   setup_func[R128_WIN_BIT|R128_RGBA_BIT|R128_SPEC_BIT|R128_TEX0_BIT|R128_TEX1_BIT] = rs_wgst0t1;
   setup_func[R128_WIN_BIT|R128_RGBA_BIT|R128_FOG_BIT] = rs_wgf;
   setup_func[R128_WIN_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT] = rs_wgfs;
   setup_func[R128_WIN_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_TEX0_BIT] = rs_wgft0;
   setup_func[R128_WIN_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_TEX0_BIT|R128_TEX1_BIT] = rs_wgft0t1;
   setup_func[R128_WIN_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT|R128_TEX0_BIT] = rs_wgfst0;
   setup_func[R128_WIN_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT|R128_TEX0_BIT|R128_TEX1_BIT] = rs_wgfst0t1;

   /* Repair functions
    */
   setup_func[R128_TEX0_BIT] = rs_t0;
   setup_func[R128_TEX0_BIT|R128_TEX1_BIT] = rs_t0t1;
   setup_func[R128_FOG_BIT] = rs_f;
   setup_func[R128_FOG_BIT|R128_TEX0_BIT] = rs_ft0;
   setup_func[R128_FOG_BIT|R128_TEX0_BIT|R128_TEX1_BIT] = rs_ft0t1;
   setup_func[R128_RGBA_BIT] = rs_g;
   setup_func[R128_RGBA_BIT|R128_SPEC_BIT] = rs_gs;
   setup_func[R128_RGBA_BIT|R128_TEX0_BIT] = rs_gt0;
   setup_func[R128_RGBA_BIT|R128_TEX0_BIT|R128_TEX1_BIT] = rs_gt0t1;
   setup_func[R128_RGBA_BIT|R128_SPEC_BIT|R128_TEX0_BIT] = rs_gst0;
   setup_func[R128_RGBA_BIT|R128_SPEC_BIT|R128_TEX0_BIT|R128_TEX1_BIT] = rs_gst0t1;
   setup_func[R128_RGBA_BIT|R128_FOG_BIT] = rs_gf;
   setup_func[R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT] = rs_gfs;
   setup_func[R128_RGBA_BIT|R128_FOG_BIT|R128_TEX0_BIT] = rs_gft0;
   setup_func[R128_RGBA_BIT|R128_FOG_BIT|R128_TEX0_BIT|R128_TEX1_BIT] = rs_gft0t1;
   setup_func[R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT|R128_TEX0_BIT] = rs_gfst0;
   setup_func[R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT|R128_TEX0_BIT|R128_TEX1_BIT] = rs_gfst0t1;
}


void r128PrintSetupFlags( char *msg, GLuint flags )
{
   fprintf( stderr, "%s: %d %s%s%s%s%s%s\n",
	    msg,
	    (int)flags,
	    (flags & R128_WIN_BIT)	? " xyzw," : "",
	    (flags & R128_RGBA_BIT)	? " rgba," : "",
	    (flags & R128_SPEC_BIT)	? " spec," : "",
	    (flags & R128_FOG_BIT)	? " fog," : "",
	    (flags & R128_TEX0_BIT)	? " tex-0," : "",
	    (flags & R128_TEX1_BIT)	? " tex-1," : "" );
}


/* Initialize the vertex buffer setup functions based on the current
 * rendering state.
 */
void r128DDChooseRasterSetupFunc( GLcontext *ctx )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLint index = R128_WIN_BIT | R128_RGBA_BIT;

   rmesa->multitex = 0;
   rmesa->vertsize = 8;
   rmesa->vc_format = R128_TEX0_VERTEX_FORMAT;
   rmesa->tmu_source[0] = 0;
   rmesa->tmu_source[1] = 1;
   rmesa->tex_dest[0] = R128_TEX0_BIT;
   rmesa->tex_dest[1] = R128_TEX1_BIT;
   rmesa->blend_flags &= ~R128_BLEND_MULTITEX;

   if ( ctx->Texture.ReallyEnabled & ENABLE_TEX0 ) {
      if ( R128_IS_PLAIN( rmesa ) &&		/* Pro/M3 support GL_BLEND */
	   ctx->Texture.Unit[0].EnvMode == GL_BLEND && rmesa->env_color ) {
	 rmesa->multitex = 1;
	 rmesa->vertsize = 10;
	 rmesa->vc_format = R128_TEX1_VERTEX_FORMAT;
	 rmesa->tmu_source[1] = 0;
	 index |= R128_TEX1_BIT;
      }

      index |= R128_TEX0_BIT;
   }

   if ( ctx->Texture.ReallyEnabled & ENABLE_TEX1 ) {
      if ( ctx->Texture.ReallyEnabled & ENABLE_TEX0 ) {
	 rmesa->multitex = 1;
	 rmesa->vertsize = 10;
	 rmesa->vc_format = R128_TEX1_VERTEX_FORMAT;
	 if ( R128_IS_PLAIN( rmesa ) )		/* Pro/M3 support GL_BLEND */
	    rmesa->blend_flags |= R128_BLEND_MULTITEX;
	 index |= R128_TEX1_BIT;
      } else {
	 /* Just a funny way of doing single texturing.
	  */
	 rmesa->tmu_source[0] = 1;
	 rmesa->tex_dest[1] = R128_TEX0_BIT;

	 if ( R128_IS_PLAIN( rmesa ) &&		/* Pro/M3 support GL_BLEND */
	      ctx->Texture.Unit[1].EnvMode == GL_BLEND && rmesa->env_color ) {
	    rmesa->multitex = 1;
	    rmesa->vertsize = 10;
	    rmesa->vc_format = R128_TEX1_VERTEX_FORMAT;
	    rmesa->tmu_source[1] = 1;
	    index |= R128_TEX1_BIT;
	 }

	 index |= R128_TEX0_BIT;
      }
   }

   if ( ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR )
      index |= R128_SPEC_BIT;

   if ( ctx->Fog.Enabled )
      index |= R128_FOG_BIT;

   if ( R128_DEBUG & DEBUG_VERBOSE_MSG ) {
      fprintf( stderr, "\n" );
      r128PrintSetupFlags( "full setup function", index );
   }

   rmesa->new_state |= R128_NEW_TEXTURE;
   rmesa->SetupIndex = index;

   ctx->Driver.RasterSetup = setup_func[index];
}

/* Check to see if any updates of the vertex buffer entries are needed.
 */
void r128DDCheckPartialRasterSetup( GLcontext *ctx,
				    struct gl_pipeline_stage *s )
{
   r128ContextPtr rmesa = R128_CONTEXT( ctx );
   GLint tmp = rmesa->SetupDone;

   s->type = 0;
   rmesa->SetupDone = 0;

   if ( (ctx->Array.Summary & VERT_OBJ_ANY) == 0 )
      return;

   if ( ctx->IndirectTriangles )
      return;

   rmesa->SetupDone = tmp;
}

/* Repair existing precalculated vertices with new data.
 */
void r128DDPartialRasterSetup( struct vertex_buffer *VB )
{
   r128ContextPtr rmesa = R128_CONTEXT(VB->ctx);
   GLuint new = VB->pipeline->new_outputs;
   GLuint available = VB->pipeline->outputs;
   GLuint index = 0;

   if ( new & VERT_WIN ) {
      new = available;
      index |= R128_WIN_BIT | R128_FOG_BIT;
   }

   if ( new & VERT_RGBA )
      index |= R128_RGBA_BIT | R128_SPEC_BIT;

   if ( new & VERT_TEX0_ANY )
      index |= R128_TEX0_BIT;

   if ( new & VERT_TEX1_ANY )
      index |= rmesa->tex_dest[1];

   if ( new & VERT_FOG_COORD )
      index |= R128_FOG_BIT;

   rmesa->SetupDone &= ~index;
   index &= rmesa->SetupIndex;
   rmesa->SetupDone |= index;

   if ( R128_DEBUG & DEBUG_VERBOSE_MSG )
      r128PrintSetupFlags( "partial setup function", index );

   if ( index )
      setup_func[index]( VB, VB->Start, VB->Count );
}

void r128DDDoRasterSetup( struct vertex_buffer *VB )
{
   GLcontext *ctx = VB->ctx;

   if ( VB->Type == VB_CVA_PRECALC ) {
      r128DDPartialRasterSetup( VB );
   } else if ( ctx->Driver.RasterSetup ) {
      ctx->Driver.RasterSetup( VB, VB->CopyStart, VB->Count );
   }
}


/* ================================================================
 * Hardware-format vertex buffers
 */

void r128DDResizeVB( struct vertex_buffer *VB, GLuint size )
{
   r128VertexBufferPtr rvb = R128_DRIVER_DATA(VB);

   while ( rvb->size < size )
      rvb->size *= 2;

   ALIGN_FREE( rvb->vert_store );
   rvb->vert_store = ALIGN_MALLOC( sizeof(r128Vertex) * rvb->size, 32 );
   if ( !rvb->vert_store ) {
      fprintf( stderr, "Cannot allocate vertex store!  Exiting...\n" );
      exit( 1 );
   }

   rvb->verts = (r128VertexPtr)rvb->vert_store;

   gl_vector1ui_free( &rvb->clipped_elements );
   gl_vector1ui_alloc( &rvb->clipped_elements, VEC_WRITABLE, rvb->size, 32 );
   if ( !rvb->clipped_elements.start ) {
      fprintf( stderr, "Cannot allocate clipped elements!  Exiting...\n" );
      exit( 1 );
   }

   ALIGN_FREE( VB->ClipMask );
   VB->ClipMask = (GLubyte *)ALIGN_MALLOC( sizeof(GLubyte) * rvb->size, 32 );
   if ( !VB->ClipMask ) {
      fprintf( stderr, "Cannot allocate clipmask!  Exiting...\n" );
      exit( 1 );
   }
}

void r128DDRegisterVB( struct vertex_buffer *VB )
{
   r128VertexBufferPtr rvb;

   rvb = (r128VertexBufferPtr)CALLOC( sizeof(*rvb) );

   rvb->size = VB->Size * 2;
   rvb->vert_store = ALIGN_MALLOC( sizeof(r128Vertex) * rvb->size, 32 );
   if ( !rvb->vert_store ) {
      fprintf( stderr, "Cannot allocate vertex store!  Exiting...\n" );
      exit( 1 );
   }

   rvb->verts = (r128VertexPtr)rvb->vert_store;

   gl_vector1ui_alloc( &rvb->clipped_elements, VEC_WRITABLE, rvb->size, 32 );
   if ( !rvb->clipped_elements.start ) {
      fprintf( stderr, "Cannot allocate clipped elements!  Exiting...\n" );
      exit( 1 );
   }

   ALIGN_FREE( VB->ClipMask );
   VB->ClipMask = (GLubyte *)ALIGN_MALLOC( sizeof(GLubyte) * rvb->size, 32 );
   if ( !VB->ClipMask ) {
      fprintf( stderr, "Cannot allocate clipmask!  Exiting...\n" );
      exit( 1 );
   }

   VB->driver_data = rvb;
}

void r128DDUnregisterVB( struct vertex_buffer *VB )
{
   r128VertexBufferPtr rvb = R128_DRIVER_DATA(VB);

   if ( rvb ) {
      if ( rvb->vert_store ) ALIGN_FREE( rvb->vert_store );
      gl_vector1ui_free( &rvb->clipped_elements );
      FREE( rvb );
      VB->driver_data = 0;
   }
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/lib/GL/mesa/src/drv/r128/r128_vb.c,v 1.17 2003/09/28 20:15:22 alanh Exp $ */
d4 2
a5 3
Copyright 2000, 2001 ATI Technologies Inc., Ontario, Canada, and
                     VA Linux Systems Inc., Fremont, California.

d22 1
a22 1
ATI, VA LINUX SYSTEMS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
d31 2
a32 1
 *   Keith Whitwell <keith@@tungstengraphics.com>
a35 9
#include "glheader.h"
#include "mtypes.h"
#include "imports.h"
#include "macros.h"
#include "colormac.h"

#include "swrast_setup/swrast_setup.h"
#include "tnl/t_context.h"

a36 1
#include "r128_vb.h"
a37 1
#include "r128_tris.h"
d39 146
d187 34
a220 239
#define R128_TEX1_BIT       0x1
#define R128_TEX0_BIT       0x2
#define R128_RGBA_BIT       0x4
#define R128_SPEC_BIT       0x8
#define R128_FOG_BIT	    0x10
#define R128_XYZW_BIT       0x20
#define R128_PTEX_BIT       0x40
#define R128_MAX_SETUP      0x80

static struct {
   void                (*emit)( GLcontext *, GLuint, GLuint, void *, GLuint );
   interp_func		interp;
   copy_pv_func	        copy_pv;
   GLboolean           (*check_tex_sizes)( GLcontext *ctx );
   GLuint               vertex_size;
   GLuint               vertex_stride_shift;
   GLuint               vertex_format;
} setup_tab[R128_MAX_SETUP];

#define TINY_VERTEX_FORMAT		(R128_CCE_VC_FRMT_DIFFUSE_ARGB)

#define NOTEX_VERTEX_FORMAT		(R128_CCE_VC_FRMT_RHW |		\
					 R128_CCE_VC_FRMT_DIFFUSE_ARGB |\
					 R128_CCE_VC_FRMT_SPEC_FRGB)

#define TEX0_VERTEX_FORMAT		(R128_CCE_VC_FRMT_RHW |		\
					 R128_CCE_VC_FRMT_DIFFUSE_ARGB |\
					 R128_CCE_VC_FRMT_SPEC_FRGB |	\
					 R128_CCE_VC_FRMT_S_T)

#define TEX1_VERTEX_FORMAT		(R128_CCE_VC_FRMT_RHW |		\
					 R128_CCE_VC_FRMT_DIFFUSE_ARGB |\
					 R128_CCE_VC_FRMT_SPEC_FRGB |	\
					 R128_CCE_VC_FRMT_S_T |		\
					 R128_CCE_VC_FRMT_S2_T2)


#define PROJ_TEX1_VERTEX_FORMAT 0
#define TEX2_VERTEX_FORMAT      0
#define TEX3_VERTEX_FORMAT      0
#define PROJ_TEX3_VERTEX_FORMAT 0

#define DO_XYZW (IND & R128_XYZW_BIT)
#define DO_RGBA (IND & R128_RGBA_BIT)
#define DO_SPEC (IND & R128_SPEC_BIT)
#define DO_FOG  (IND & R128_FOG_BIT)
#define DO_TEX0 (IND & R128_TEX0_BIT)
#define DO_TEX1 (IND & R128_TEX1_BIT)
#define DO_TEX2 0
#define DO_TEX3 0
#define DO_PTEX (IND & R128_PTEX_BIT)

#define VERTEX r128Vertex
#define VERTEX_COLOR r128_color_t
#define LOCALVARS r128ContextPtr rmesa = R128_CONTEXT(ctx);
#define GET_VIEWPORT_MAT() rmesa->hw_viewport
#define GET_TEXSOURCE(n)  rmesa->tmu_source[n]
#define GET_VERTEX_FORMAT() rmesa->vertex_format
#define GET_VERTEX_STORE() rmesa->verts
#define GET_VERTEX_STRIDE_SHIFT() rmesa->vertex_stride_shift
#define INVALIDATE_STORED_VERTICES()
#define GET_UBYTE_COLOR_STORE() &rmesa->UbyteColor
#define GET_UBYTE_SPEC_COLOR_STORE() &rmesa->UbyteSecondaryColor

#define HAVE_HW_VIEWPORT    0
#define HAVE_HW_DIVIDE      0
#define HAVE_RGBA_COLOR     0
#define HAVE_TINY_VERTICES  1
#define HAVE_NOTEX_VERTICES 1
#define HAVE_TEX0_VERTICES  1
#define HAVE_TEX1_VERTICES  1
#define HAVE_TEX2_VERTICES  0
#define HAVE_TEX3_VERTICES  0
#define HAVE_PTEX_VERTICES  0	/* r128 rhw2 not supported by template */

#define UNVIEWPORT_VARS  GLfloat h = R128_CONTEXT(ctx)->driDrawable->h
#define UNVIEWPORT_X(x)  x - SUBPIXEL_X
#define UNVIEWPORT_Y(y)  - y + h + SUBPIXEL_Y
#define UNVIEWPORT_Z(z)  z / rmesa->depth_scale

#define PTEX_FALLBACK() FALLBACK(R128_CONTEXT(ctx), R128_FALLBACK_TEXTURE, 1)

#define IMPORT_FLOAT_COLORS r128_import_float_colors
#define IMPORT_FLOAT_SPEC_COLORS r128_import_float_spec_colors

#define INTERP_VERTEX setup_tab[rmesa->SetupIndex].interp
#define COPY_PV_VERTEX setup_tab[rmesa->SetupIndex].copy_pv

/***********************************************************************
 *         Generate  pv-copying and translation functions              *
 ***********************************************************************/

#define TAG(x) r128_##x
#include "tnl_dd/t_dd_vb.c"

/***********************************************************************
 *             Generate vertex emit and interp functions               *
 ***********************************************************************/


#define IND (R128_XYZW_BIT|R128_RGBA_BIT)
#define TAG(x) x##_wg
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_SPEC_BIT)
#define TAG(x) x##_wgs
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_TEX0_BIT)
#define TAG(x) x##_wgt0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_TEX0_BIT|R128_TEX1_BIT)
#define TAG(x) x##_wgt0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_TEX0_BIT|R128_PTEX_BIT)
#define TAG(x) x##_wgpt0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_SPEC_BIT|R128_TEX0_BIT)
#define TAG(x) x##_wgst0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_SPEC_BIT|R128_TEX0_BIT|\
             R128_TEX1_BIT)
#define TAG(x) x##_wgst0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_SPEC_BIT|R128_TEX0_BIT|\
             R128_PTEX_BIT)
#define TAG(x) x##_wgspt0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT)
#define TAG(x) x##_wgf
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT)
#define TAG(x) x##_wgfs
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_TEX0_BIT)
#define TAG(x) x##_wgft0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_TEX0_BIT|\
             R128_TEX1_BIT)
#define TAG(x) x##_wgft0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_TEX0_BIT|\
             R128_PTEX_BIT)
#define TAG(x) x##_wgfpt0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT|\
             R128_TEX0_BIT)
#define TAG(x) x##_wgfst0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT|\
             R128_TEX0_BIT|R128_TEX1_BIT)
#define TAG(x) x##_wgfst0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT|\
             R128_TEX0_BIT|R128_PTEX_BIT)
#define TAG(x) x##_wgfspt0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_TEX0_BIT)
#define TAG(x) x##_t0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_TEX0_BIT|R128_TEX1_BIT)
#define TAG(x) x##_t0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_FOG_BIT)
#define TAG(x) x##_f
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_FOG_BIT|R128_TEX0_BIT)
#define TAG(x) x##_ft0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_FOG_BIT|R128_TEX0_BIT|R128_TEX1_BIT)
#define TAG(x) x##_ft0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT)
#define TAG(x) x##_g
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_SPEC_BIT)
#define TAG(x) x##_gs
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_TEX0_BIT)
#define TAG(x) x##_gt0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_TEX0_BIT|R128_TEX1_BIT)
#define TAG(x) x##_gt0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_SPEC_BIT|R128_TEX0_BIT)
#define TAG(x) x##_gst0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_SPEC_BIT|R128_TEX0_BIT|R128_TEX1_BIT)
#define TAG(x) x##_gst0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_FOG_BIT)
#define TAG(x) x##_gf
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT)
#define TAG(x) x##_gfs
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_FOG_BIT|R128_TEX0_BIT)
#define TAG(x) x##_gft0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_FOG_BIT|R128_TEX0_BIT|R128_TEX1_BIT)
#define TAG(x) x##_gft0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT|R128_TEX0_BIT)
#define TAG(x) x##_gfst0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT|R128_TEX0_BIT|\
             R128_TEX1_BIT)
#define TAG(x) x##_gfst0t1
#include "tnl_dd/t_dd_vbtmp.h"
d223 1
a223 1
static void init_setup_tab( void )
d225 1
a225 33
   init_wg();
   init_wgs();
   init_wgt0();
   init_wgt0t1();
   init_wgpt0();
   init_wgst0();
   init_wgst0t1();
   init_wgspt0();
   init_wgf();
   init_wgfs();
   init_wgft0();
   init_wgft0t1();
   init_wgfpt0();
   init_wgfst0();
   init_wgfst0t1();
   init_wgfspt0();
   init_t0();
   init_t0t1();
   init_f();
   init_ft0();
   init_ft0t1();
   init_g();
   init_gs();
   init_gt0();
   init_gt0t1();
   init_gst0();
   init_gst0t1();
   init_gf();
   init_gfs();
   init_gft0();
   init_gft0t1();
   init_gfst0();
   init_gfst0t1();
d228 2
d232 1
a232 1
void r128PrintSetupFlags(char *msg, GLuint flags )
d234 44
a277 9
   fprintf(stderr, "%s(%x): %s%s%s%s%s%s\n",
	   msg,
	   (int)flags,
	   (flags & R128_XYZW_BIT)     ? " xyzw," : "",
	   (flags & R128_RGBA_BIT)     ? " rgba," : "",
	   (flags & R128_SPEC_BIT)     ? " spec," : "",
	   (flags & R128_FOG_BIT)      ? " fog," : "",
	   (flags & R128_TEX0_BIT)     ? " tex-0," : "",
	   (flags & R128_TEX1_BIT)     ? " tex-1," : "");
d281 13
d295 4
a298 1
void r128CheckTexSizes( GLcontext *ctx )
d300 24
a323 1
   r128ContextPtr rmesa = R128_CONTEXT( ctx );
d325 22
a346 2
   if (!setup_tab[rmesa->SetupIndex].check_tex_sizes(ctx)) {
      TNLcontext *tnl = TNL_CONTEXT(ctx);
d348 1
a348 12
      /* Invalidate stored verts
       */
      rmesa->SetupNewInputs = ~0;
      rmesa->SetupIndex |= R128_PTEX_BIT;

      if (!rmesa->Fallback &&
	  !(ctx->_TriangleCaps & (DD_TRI_LIGHT_TWOSIDE|DD_TRI_UNFILLED))) {
	 tnl->Driver.Render.Interp = setup_tab[rmesa->SetupIndex].interp;
	 tnl->Driver.Render.CopyPV = setup_tab[rmesa->SetupIndex].copy_pv;
      }
      if (rmesa->Fallback) {
         tnl->Driver.Render.Start(ctx);
d351 16
d369 4
a372 4
void r128BuildVertices( GLcontext *ctx,
			GLuint start,
			GLuint count,
			GLuint newinputs )
d375 4
a378 2
   GLubyte *v = ((GLubyte *)rmesa->verts + (start<<rmesa->vertex_stride_shift));
   GLuint stride = 1<<rmesa->vertex_stride_shift;
d380 2
a381 2
   newinputs |= rmesa->SetupNewInputs;
   rmesa->SetupNewInputs = 0;
d383 1
a383 1
   if (!newinputs)
d386 2
a387 4
   if (newinputs & VERT_BIT_CLIP) {
      setup_tab[rmesa->SetupIndex].emit( ctx, start, count, v, stride );
   } else {
      GLuint ind = 0;
d389 13
a401 2
      if (newinputs & VERT_BIT_COLOR0)
	 ind |= R128_RGBA_BIT;
d403 2
a404 2
      if (newinputs & VERT_BIT_COLOR1)
	 ind |= R128_SPEC_BIT;
d406 2
a407 2
      if (newinputs & VERT_BIT_TEX0)
	 ind |= R128_TEX0_BIT;
d409 2
a410 2
      if (newinputs & VERT_BIT_TEX1)
	 ind |= R128_TEX1_BIT;
d412 2
a413 2
      if (newinputs & VERT_BIT_FOG)
	 ind |= R128_FOG_BIT;
d415 3
a417 2
      if (rmesa->SetupIndex & R128_PTEX_BIT)
	 ind = ~0;
d419 2
a420 1
      ind &= rmesa->SetupIndex;
d422 2
a423 4
      if (ind) {
	 setup_tab[ind].emit( ctx, start, count, v, stride );
      }
   }
d426 1
a426 1
void r128ChooseVertexState( GLcontext *ctx )
d428 1
a428 3
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   r128ContextPtr rmesa = R128_CONTEXT( ctx );
   GLuint ind = R128_XYZW_BIT|R128_RGBA_BIT;
d430 6
a435 2
   if (ctx->_TriangleCaps & DD_SEPARATE_SPECULAR)
      ind |= R128_SPEC_BIT;
a436 2
   if (ctx->Fog.Enabled)
      ind |= R128_FOG_BIT;
d438 3
a440 6
   if (ctx->Texture._EnabledUnits) {
      ind |= R128_TEX0_BIT;
      if (ctx->Texture.Unit[0]._ReallyEnabled &&
	  ctx->Texture.Unit[1]._ReallyEnabled)
	 ind |= R128_TEX1_BIT;
   }
d442 3
a444 1
   rmesa->SetupIndex = ind;
d446 2
a447 7
   if (ctx->_TriangleCaps & (DD_TRI_LIGHT_TWOSIDE|DD_TRI_UNFILLED)) {
      tnl->Driver.Render.Interp = r128_interp_extras;
      tnl->Driver.Render.CopyPV = r128_copy_pv_extras;
   } else {
      tnl->Driver.Render.Interp = setup_tab[ind].interp;
      tnl->Driver.Render.CopyPV = setup_tab[ind].copy_pv;
   }
d449 5
a453 5
   if (setup_tab[ind].vertex_format != rmesa->vertex_format) {
      FLUSH_BATCH(rmesa);
      rmesa->vertex_format = setup_tab[ind].vertex_format;
      rmesa->vertex_size = setup_tab[ind].vertex_size;
      rmesa->vertex_stride_shift = setup_tab[ind].vertex_stride_shift;
a454 1
}
d456 1
d458 6
d465 6
a470 8
void r128_emit_contiguous_verts( GLcontext *ctx,
				 GLuint start,
				 GLuint count )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint vertex_size = rmesa->vertex_size * 4;
   GLuint *dest = r128AllocDmaLow( rmesa, (count-start) * vertex_size);
   setup_tab[rmesa->SetupIndex].emit( ctx, start, count, dest, vertex_size );
d473 1
a473 3

#if 0
void r128_emit_indexed_verts( GLcontext *ctx, GLuint start, GLuint count )
d475 1
a475 14
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint vertex_size = rmesa->vertex_size * 4;
   GLuint bufsz = (count-start) * vertex_size;
   CARD32 *dest;

   rmesa->vertex_low = (rmesa->vertex_low + 63) & ~63; /* alignment */
   rmesa->vertex_last_prim = rmesa->vertex_low;

   dest = r128AllocDmaLow( rmesa, bufsz, __FUNCTION__);
   setup_tab[rmesa->SetupIndex].emit( ctx, start, count, dest, vertex_size );

   rmesa->retained_buffer = rmesa->vertex_buffer;
   rmesa->vb_offset = (rmesa->vertex_buffer->idx * R128_BUFFER_SIZE +
		       rmesa->vertex_low - bufsz);
d477 1
a477 4
   rmesa->vertex_low = (rmesa->vertex_low + 0x7) & ~0x7;  /* alignment */
   rmesa->vertex_last_prim = rmesa->vertex_low;
}
#endif
d479 6
d486 1
a486 4
void r128InitVB( GLcontext *ctx )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint size = TNL_CONTEXT(ctx)->vb.Size;
d488 5
a492 1
   rmesa->verts = (GLubyte *)ALIGN_MALLOC(size * 4 * 16, 32);
d494 5
a498 6
   {
      static int firsttime = 1;
      if (firsttime) {
	 init_setup_tab();
	 firsttime = 0;
      }
d500 2
d504 1
a504 2

void r128FreeVB( GLcontext *ctx )
d506 1
a506 11
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   if (rmesa->verts) {
      ALIGN_FREE(rmesa->verts);
      rmesa->verts = 0;
   }


   if (rmesa->UbyteSecondaryColor.Ptr) {
      ALIGN_FREE(rmesa->UbyteSecondaryColor.Ptr);
      rmesa->UbyteSecondaryColor.Ptr = 0;
   }
d508 5
a512 3
   if (rmesa->UbyteColor.Ptr) {
      ALIGN_FREE(rmesa->UbyteColor.Ptr);
      rmesa->UbyteColor.Ptr = 0;
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/lib/GL/mesa/src/drv/r128/r128_vb.c,v 1.15 2002/10/30 12:51:43 alanh Exp $ */
d4 2
a5 3
Copyright 2000, 2001 ATI Technologies Inc., Ontario, Canada, and
                     VA Linux Systems Inc., Fremont, California.

d22 1
a22 1
ATI, VA LINUX SYSTEMS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
d31 2
a32 1
 *   Keith Whitwell <keith@@tungstengraphics.com>
a35 10
#include "glheader.h"
#include "mtypes.h"
#include "mem.h"
#include "macros.h"
#include "colormac.h"
#include "mmath.h"

#include "swrast_setup/swrast_setup.h"
#include "tnl/t_context.h"

a36 1
#include "r128_vb.h"
a37 1
#include "r128_tris.h"
d39 4
d44 141
a185 239
#define R128_TEX1_BIT       0x1
#define R128_TEX0_BIT       0x2
#define R128_RGBA_BIT       0x4
#define R128_SPEC_BIT       0x8
#define R128_FOG_BIT	    0x10
#define R128_XYZW_BIT       0x20
#define R128_PTEX_BIT       0x40
#define R128_MAX_SETUP      0x80

static struct {
   void                (*emit)( GLcontext *, GLuint, GLuint, void *, GLuint );
   interp_func		interp;
   copy_pv_func	        copy_pv;
   GLboolean           (*check_tex_sizes)( GLcontext *ctx );
   GLuint               vertex_size;
   GLuint               vertex_stride_shift;
   GLuint               vertex_format;
} setup_tab[R128_MAX_SETUP];

#define TINY_VERTEX_FORMAT		(R128_CCE_VC_FRMT_DIFFUSE_ARGB)

#define NOTEX_VERTEX_FORMAT		(R128_CCE_VC_FRMT_RHW |		\
					 R128_CCE_VC_FRMT_DIFFUSE_ARGB |\
					 R128_CCE_VC_FRMT_SPEC_FRGB)

#define TEX0_VERTEX_FORMAT		(R128_CCE_VC_FRMT_RHW |		\
					 R128_CCE_VC_FRMT_DIFFUSE_ARGB |\
					 R128_CCE_VC_FRMT_SPEC_FRGB |	\
					 R128_CCE_VC_FRMT_S_T)

#define TEX1_VERTEX_FORMAT		(R128_CCE_VC_FRMT_RHW |		\
					 R128_CCE_VC_FRMT_DIFFUSE_ARGB |\
					 R128_CCE_VC_FRMT_SPEC_FRGB |	\
					 R128_CCE_VC_FRMT_S_T |		\
					 R128_CCE_VC_FRMT_S2_T2)


#define PROJ_TEX1_VERTEX_FORMAT 0
#define TEX2_VERTEX_FORMAT      0
#define TEX3_VERTEX_FORMAT      0
#define PROJ_TEX3_VERTEX_FORMAT 0

#define DO_XYZW (IND & R128_XYZW_BIT)
#define DO_RGBA (IND & R128_RGBA_BIT)
#define DO_SPEC (IND & R128_SPEC_BIT)
#define DO_FOG  (IND & R128_FOG_BIT)
#define DO_TEX0 (IND & R128_TEX0_BIT)
#define DO_TEX1 (IND & R128_TEX1_BIT)
#define DO_TEX2 0
#define DO_TEX3 0
#define DO_PTEX (IND & R128_PTEX_BIT)

#define VERTEX r128Vertex
#define VERTEX_COLOR r128_color_t
#define LOCALVARS r128ContextPtr rmesa = R128_CONTEXT(ctx);
#define GET_VIEWPORT_MAT() rmesa->hw_viewport
#define GET_TEXSOURCE(n)  rmesa->tmu_source[n]
#define GET_VERTEX_FORMAT() rmesa->vertex_format
#define GET_VERTEX_STORE() rmesa->verts
#define GET_VERTEX_STRIDE_SHIFT() rmesa->vertex_stride_shift
#define INVALIDATE_STORED_VERTICES()
#define GET_UBYTE_COLOR_STORE() &rmesa->UbyteColor
#define GET_UBYTE_SPEC_COLOR_STORE() &rmesa->UbyteSecondaryColor

#define HAVE_HW_VIEWPORT    0
#define HAVE_HW_DIVIDE      0
#define HAVE_RGBA_COLOR     0
#define HAVE_TINY_VERTICES  1
#define HAVE_NOTEX_VERTICES 1
#define HAVE_TEX0_VERTICES  1
#define HAVE_TEX1_VERTICES  1
#define HAVE_TEX2_VERTICES  0
#define HAVE_TEX3_VERTICES  0
#define HAVE_PTEX_VERTICES  0	/* r128 rhw2 not supported by template */

#define UNVIEWPORT_VARS  GLfloat h = R128_CONTEXT(ctx)->driDrawable->h
#define UNVIEWPORT_X(x)  x - SUBPIXEL_X
#define UNVIEWPORT_Y(y)  - y + h + SUBPIXEL_Y
#define UNVIEWPORT_Z(z)  z / rmesa->depth_scale

#define PTEX_FALLBACK() FALLBACK(R128_CONTEXT(ctx), R128_FALLBACK_TEXTURE, 1)

#define IMPORT_FLOAT_COLORS r128_import_float_colors
#define IMPORT_FLOAT_SPEC_COLORS r128_import_float_spec_colors

#define INTERP_VERTEX setup_tab[rmesa->SetupIndex].interp
#define COPY_PV_VERTEX setup_tab[rmesa->SetupIndex].copy_pv

/***********************************************************************
 *         Generate  pv-copying and translation functions              *
 ***********************************************************************/

#define TAG(x) r128_##x
#include "tnl_dd/t_dd_vb.c"

/***********************************************************************
 *             Generate vertex emit and interp functions               *
 ***********************************************************************/


#define IND (R128_XYZW_BIT|R128_RGBA_BIT)
#define TAG(x) x##_wg
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_SPEC_BIT)
#define TAG(x) x##_wgs
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_TEX0_BIT)
#define TAG(x) x##_wgt0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_TEX0_BIT|R128_TEX1_BIT)
#define TAG(x) x##_wgt0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_TEX0_BIT|R128_PTEX_BIT)
#define TAG(x) x##_wgpt0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_SPEC_BIT|R128_TEX0_BIT)
#define TAG(x) x##_wgst0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_SPEC_BIT|R128_TEX0_BIT|\
             R128_TEX1_BIT)
#define TAG(x) x##_wgst0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_SPEC_BIT|R128_TEX0_BIT|\
             R128_PTEX_BIT)
#define TAG(x) x##_wgspt0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT)
#define TAG(x) x##_wgf
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT)
#define TAG(x) x##_wgfs
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_TEX0_BIT)
#define TAG(x) x##_wgft0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_TEX0_BIT|\
             R128_TEX1_BIT)
#define TAG(x) x##_wgft0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_TEX0_BIT|\
             R128_PTEX_BIT)
#define TAG(x) x##_wgfpt0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT|\
             R128_TEX0_BIT)
#define TAG(x) x##_wgfst0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT|\
             R128_TEX0_BIT|R128_TEX1_BIT)
#define TAG(x) x##_wgfst0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_XYZW_BIT|R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT|\
             R128_TEX0_BIT|R128_PTEX_BIT)
#define TAG(x) x##_wgfspt0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_TEX0_BIT)
#define TAG(x) x##_t0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_TEX0_BIT|R128_TEX1_BIT)
#define TAG(x) x##_t0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_FOG_BIT)
#define TAG(x) x##_f
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_FOG_BIT|R128_TEX0_BIT)
#define TAG(x) x##_ft0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_FOG_BIT|R128_TEX0_BIT|R128_TEX1_BIT)
#define TAG(x) x##_ft0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT)
#define TAG(x) x##_g
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_SPEC_BIT)
#define TAG(x) x##_gs
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_TEX0_BIT)
#define TAG(x) x##_gt0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_TEX0_BIT|R128_TEX1_BIT)
#define TAG(x) x##_gt0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_SPEC_BIT|R128_TEX0_BIT)
#define TAG(x) x##_gst0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_SPEC_BIT|R128_TEX0_BIT|R128_TEX1_BIT)
#define TAG(x) x##_gst0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_FOG_BIT)
#define TAG(x) x##_gf
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT)
#define TAG(x) x##_gfs
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_FOG_BIT|R128_TEX0_BIT)
#define TAG(x) x##_gft0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_FOG_BIT|R128_TEX0_BIT|R128_TEX1_BIT)
#define TAG(x) x##_gft0t1
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT|R128_TEX0_BIT)
#define TAG(x) x##_gfst0
#include "tnl_dd/t_dd_vbtmp.h"

#define IND (R128_RGBA_BIT|R128_FOG_BIT|R128_SPEC_BIT|R128_TEX0_BIT|\
             R128_TEX1_BIT)
#define TAG(x) x##_gfst0t1
#include "tnl_dd/t_dd_vbtmp.h"
d187 34
d222 2
a223 1
static void init_setup_tab( void )
d225 1
a225 33
   init_wg();
   init_wgs();
   init_wgt0();
   init_wgt0t1();
   init_wgpt0();
   init_wgst0();
   init_wgst0t1();
   init_wgspt0();
   init_wgf();
   init_wgfs();
   init_wgft0();
   init_wgft0t1();
   init_wgfpt0();
   init_wgfst0();
   init_wgfst0t1();
   init_wgfspt0();
   init_t0();
   init_t0t1();
   init_f();
   init_ft0();
   init_ft0t1();
   init_g();
   init_gs();
   init_gt0();
   init_gt0t1();
   init_gst0();
   init_gst0t1();
   init_gf();
   init_gfs();
   init_gft0();
   init_gft0t1();
   init_gfst0();
   init_gfst0t1();
d228 2
d232 1
a232 1
void r128PrintSetupFlags(char *msg, GLuint flags )
d234 44
a277 9
   fprintf(stderr, "%s(%x): %s%s%s%s%s%s\n",
	   msg,
	   (int)flags,
	   (flags & R128_XYZW_BIT)     ? " xyzw," : "",
	   (flags & R128_RGBA_BIT)     ? " rgba," : "",
	   (flags & R128_SPEC_BIT)     ? " spec," : "",
	   (flags & R128_FOG_BIT)      ? " fog," : "",
	   (flags & R128_TEX0_BIT)     ? " tex-0," : "",
	   (flags & R128_TEX1_BIT)     ? " tex-1," : "");
d281 12
d294 5
a298 1
void r128CheckTexSizes( GLcontext *ctx )
d300 24
a323 1
   r128ContextPtr rmesa = R128_CONTEXT( ctx );
d325 22
a346 2
   if (!setup_tab[rmesa->SetupIndex].check_tex_sizes(ctx)) {
      TNLcontext *tnl = TNL_CONTEXT(ctx);
d348 1
a348 9
      /* Invalidate stored verts
       */
      rmesa->SetupNewInputs = ~0;
      rmesa->SetupIndex |= R128_PTEX_BIT;

      if (!rmesa->Fallback &&
	  !(ctx->_TriangleCaps & (DD_TRI_LIGHT_TWOSIDE|DD_TRI_UNFILLED))) {
	 tnl->Driver.Render.Interp = setup_tab[rmesa->SetupIndex].interp;
	 tnl->Driver.Render.CopyPV = setup_tab[rmesa->SetupIndex].copy_pv;
d351 16
d369 4
a372 4
void r128BuildVertices( GLcontext *ctx,
			GLuint start,
			GLuint count,
			GLuint newinputs )
d375 1
a375 2
   GLubyte *v = ((GLubyte *)rmesa->verts + (start<<rmesa->vertex_stride_shift));
   GLuint stride = 1<<rmesa->vertex_stride_shift;
d377 2
a378 2
   newinputs |= rmesa->SetupNewInputs;
   rmesa->SetupNewInputs = 0;
d380 1
a380 1
   if (!newinputs)
d383 2
a384 4
   if (newinputs & VERT_CLIP) {
      setup_tab[rmesa->SetupIndex].emit( ctx, start, count, v, stride );
   } else {
      GLuint ind = 0;
d386 2
a387 2
      if (newinputs & VERT_RGBA)
	 ind |= R128_RGBA_BIT;
d389 13
a401 2
      if (newinputs & VERT_SPEC_RGB)
	 ind |= R128_SPEC_BIT;
d403 2
a404 2
      if (newinputs & VERT_TEX0)
	 ind |= R128_TEX0_BIT;
d406 2
a407 2
      if (newinputs & VERT_TEX1)
	 ind |= R128_TEX1_BIT;
d409 2
a410 2
      if (newinputs & VERT_FOG_COORD)
	 ind |= R128_FOG_BIT;
d412 2
a413 2
      if (rmesa->SetupIndex & R128_PTEX_BIT)
	 ind = ~0;
d415 3
a417 1
      ind &= rmesa->SetupIndex;
d419 5
a423 4
      if (ind) {
	 setup_tab[ind].emit( ctx, start, count, v, stride );
      }
   }
d426 1
a426 1
void r128ChooseVertexState( GLcontext *ctx )
d428 1
a428 3
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   r128ContextPtr rmesa = R128_CONTEXT( ctx );
   GLuint ind = R128_XYZW_BIT|R128_RGBA_BIT;
d430 6
a435 2
   if (ctx->_TriangleCaps & DD_SEPARATE_SPECULAR)
      ind |= R128_SPEC_BIT;
a436 2
   if (ctx->Fog.Enabled)
      ind |= R128_FOG_BIT;
d438 3
a440 6
   if (ctx->Texture._ReallyEnabled) {
      ind |= R128_TEX0_BIT;
      if (ctx->Texture.Unit[0]._ReallyEnabled &&
	  ctx->Texture.Unit[1]._ReallyEnabled)
	 ind |= R128_TEX1_BIT;
   }
d442 3
a444 1
   rmesa->SetupIndex = ind;
d446 2
a447 7
   if (ctx->_TriangleCaps & (DD_TRI_LIGHT_TWOSIDE|DD_TRI_UNFILLED)) {
      tnl->Driver.Render.Interp = r128_interp_extras;
      tnl->Driver.Render.CopyPV = r128_copy_pv_extras;
   } else {
      tnl->Driver.Render.Interp = setup_tab[ind].interp;
      tnl->Driver.Render.CopyPV = setup_tab[ind].copy_pv;
   }
d449 5
a453 5
   if (setup_tab[ind].vertex_format != rmesa->vertex_format) {
      FLUSH_BATCH(rmesa);
      rmesa->vertex_format = setup_tab[ind].vertex_format;
      rmesa->vertex_size = setup_tab[ind].vertex_size;
      rmesa->vertex_stride_shift = setup_tab[ind].vertex_stride_shift;
a454 1
}
d456 1
d458 6
d465 6
a470 8
void r128_emit_contiguous_verts( GLcontext *ctx,
				 GLuint start,
				 GLuint count )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint vertex_size = rmesa->vertex_size * 4;
   GLuint *dest = r128AllocDmaLow( rmesa, (count-start) * vertex_size);
   setup_tab[rmesa->SetupIndex].emit( ctx, start, count, dest, vertex_size );
d473 1
a473 3

#if 0
void r128_emit_indexed_verts( GLcontext *ctx, GLuint start, GLuint count )
d475 1
a475 14
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint vertex_size = rmesa->vertex_size * 4;
   GLuint bufsz = (count-start) * vertex_size;
   CARD32 *dest;

   rmesa->vertex_low = (rmesa->vertex_low + 63) & ~63; /* alignment */
   rmesa->vertex_last_prim = rmesa->vertex_low;

   dest = r128AllocDmaLow( rmesa, bufsz, __FUNCTION__);
   setup_tab[rmesa->SetupIndex].emit( ctx, start, count, dest, vertex_size );

   rmesa->retained_buffer = rmesa->vertex_buffer;
   rmesa->vb_offset = (rmesa->vertex_buffer->idx * R128_BUFFER_SIZE +
		       rmesa->vertex_low - bufsz);
d477 1
a477 4
   rmesa->vertex_low = (rmesa->vertex_low + 0x7) & ~0x7;  /* alignment */
   rmesa->vertex_last_prim = rmesa->vertex_low;
}
#endif
d479 6
d486 1
a486 4
void r128InitVB( GLcontext *ctx )
{
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   GLuint size = TNL_CONTEXT(ctx)->vb.Size;
d488 5
a492 1
   rmesa->verts = (char *)ALIGN_MALLOC(size * 4 * 16, 32);
d494 5
a498 6
   {
      static int firsttime = 1;
      if (firsttime) {
	 init_setup_tab();
	 firsttime = 0;
      }
d500 2
d504 1
a504 2

void r128FreeVB( GLcontext *ctx )
d506 1
a506 11
   r128ContextPtr rmesa = R128_CONTEXT(ctx);
   if (rmesa->verts) {
      ALIGN_FREE(rmesa->verts);
      rmesa->verts = 0;
   }


   if (rmesa->UbyteSecondaryColor.Ptr) {
      ALIGN_FREE(rmesa->UbyteSecondaryColor.Ptr);
      rmesa->UbyteSecondaryColor.Ptr = 0;
   }
d508 5
a512 3
   if (rmesa->UbyteColor.Ptr) {
      ALIGN_FREE(rmesa->UbyteColor.Ptr);
      rmesa->UbyteColor.Ptr = 0;
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/lib/GL/mesa/src/drv/r128/r128_vb.c,v 1.17 2003/09/28 20:15:22 alanh Exp $ */
d38 1
a38 1
#include "imports.h"
d41 1
a364 3
      if (rmesa->Fallback) {
         tnl->Driver.Render.Start(ctx);
      }
d383 1
a383 1
   if (newinputs & VERT_BIT_CLIP) {
d388 1
a388 1
      if (newinputs & VERT_BIT_COLOR0)
d391 1
a391 1
      if (newinputs & VERT_BIT_COLOR1)
d394 1
a394 1
      if (newinputs & VERT_BIT_TEX0)
d397 1
a397 1
      if (newinputs & VERT_BIT_TEX1)
d400 1
a400 1
      if (newinputs & VERT_BIT_FOG)
d426 1
a426 1
   if (ctx->Texture._EnabledUnits) {
d493 1
a493 1
   rmesa->verts = (GLubyte *)ALIGN_MALLOC(size * 4 * 16, 32);
@


