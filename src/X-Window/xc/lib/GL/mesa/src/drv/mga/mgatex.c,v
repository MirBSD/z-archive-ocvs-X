head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.04.16;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.04.16;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.31.31;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.58.38;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.17.59;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright 2000-2001 VA Linux Systems, Inc.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Whitwell <keithw@@valinux.com>
 */
/* $XFree86: xc/lib/GL/mesa/src/drv/mga/mgatex.c,v 1.12 2001/08/18 02:51:05 dawes Exp $ */

#include <stdlib.h>
#include <stdio.h>
#include <GL/gl.h>

#include "mm.h"
#include "mgacontext.h"
#include "mgatex.h"
#include "mgaregs.h"
#include "mgaioctl.h"

#include "context.h"
#include "enums.h"
#include "simple_list.h"
#include "mem.h"
#include "texutil.h"

#define TEX_0 1
#define TEX_1 2

/*
 * mgaDestroyTexObj
 * Free all memory associated with a texture and NULL any pointers
 * to it.
 */
void
mgaDestroyTexObj( mgaContextPtr mmesa, mgaTextureObjectPtr t )
{
   if ( !t ) return;

   /* free the texture memory */
   if (t->MemBlock) {
      mmFreeMem( t->MemBlock );
      t->MemBlock = 0;

      if (t->age > mmesa->dirtyAge)
	 mmesa->dirtyAge = t->age;
   }

   /* free mesa's link */
   if (t->tObj)
      t->tObj->DriverData = NULL;

   /* see if it was the driver's current object */
   if (t->bound & TEX_0) mmesa->CurrentTexObj[0] = 0;
   if (t->bound & TEX_1) mmesa->CurrentTexObj[1] = 0;

   remove_from_list(t);
   FREE( t );
}


/*
 * mgaSetTexWrappings
 */
static void mgaSetTexWrapping( mgaTextureObjectPtr t,
			       GLenum sWrap,
			       GLenum tWrap )
{
   GLuint val = 0;

   if (sWrap != GL_REPEAT)
      val |= TMC_clampu_enable;

   if (tWrap != GL_REPEAT)
      val |= TMC_clampv_enable;

   t->setup.texctl &= ~(TMC_clampu_enable|TMC_clampv_enable);
   t->setup.texctl |= val;
}


/*
 * mgaSetTexFilter
 */
static void mgaSetTexFilter(mgaTextureObjectPtr t, GLenum minf, GLenum magf)
{
   GLuint val = 0;

   switch (minf) {
   case GL_NEAREST: val = TF_minfilter_nrst; break;
   case GL_LINEAR: val = TF_minfilter_bilin; break;
   case GL_NEAREST_MIPMAP_NEAREST: val = TF_minfilter_mm1s; break;
   case GL_LINEAR_MIPMAP_NEAREST: val = TF_minfilter_mm4s; break;
   case GL_NEAREST_MIPMAP_LINEAR: val = TF_minfilter_mm2s; break;
   case GL_LINEAR_MIPMAP_LINEAR: val = TF_minfilter_mm8s; break;
   default: val = TF_minfilter_nrst; break;
   }

   switch (magf) {
   case GL_NEAREST: val |= TF_magfilter_nrst; break;
   case GL_LINEAR: val |= TF_magfilter_bilin; break;
   default: val |= TF_magfilter_nrst; break;
   }

   /* See OpenGL 1.2 specification */
   if (magf == GL_LINEAR && (minf == GL_NEAREST_MIPMAP_NEAREST ||
			     minf == GL_NEAREST_MIPMAP_LINEAR)) {
      val |= (0x20 << TF_fthres_SHIFT); /* c = 0.5 */
   } else {
      val |= (0x10 << TF_fthres_SHIFT); /* c = 0 */
   }


   t->setup.texfilter &= (TF_minfilter_MASK |
			  TF_magfilter_MASK |
			  TF_fthres_MASK);
   t->setup.texfilter |= val;
}

/*
 * mgaSetTexBorderColor
 */
static void mgaSetTexBorderColor(mgaTextureObjectPtr t, GLubyte color[4])
{
   t->setup.texbordercol = MGAPACKCOLOR8888(color[0],color[1],
					    color[2],color[3]);
}


static GLint mgaChooseTexFormat( mgaContextPtr mmesa,
				 struct gl_texture_image *texImage,
				 GLenum format, GLenum type )
{
   const GLboolean do32bpt = mmesa->default32BitTextures;
   const struct gl_texture_format *texFormat;
   GLint ret;

   if ( 0 )
      fprintf( stderr, "internal=%s format=%s type=%s\n",
	       texImage->IntFormat == 3 ? "GL_RGB (3)" :
	       texImage->IntFormat == 4 ? "GL_RGBA (4)" :
	       gl_lookup_enum_by_nr( texImage->IntFormat ),
	       gl_lookup_enum_by_nr( format ),
	       gl_lookup_enum_by_nr( type ) );

#define SET_FORMAT( r, gl )						\
   do {									\
      ret = (r);							\
      texFormat = &(gl);						\
   } while (0)

#define SET_FORMAT_32BPT( r32, gl32, r16, gl16 )			\
   do {									\
      if ( do32bpt ) {							\
	 ret = (r32);							\
	 texFormat = &(gl32);						\
      } else {								\
	 ret = (r16);							\
	 texFormat = &(gl16);						\
      }									\
   } while (0)

   switch ( texImage->IntFormat ) {
   case GL_RGBA:
   case 4:
      if ( format == GL_BGRA ) {
	 if ( type == GL_UNSIGNED_INT_8_8_8_8_REV ) {
	    SET_FORMAT( TMC_tformat_tw32, _mesa_texformat_argb8888 );
	    break;
	 } else if ( type == GL_UNSIGNED_SHORT_4_4_4_4_REV ) {
	    SET_FORMAT( TMC_tformat_tw12, _mesa_texformat_argb4444 );
	    break;
	 } else if ( type == GL_UNSIGNED_SHORT_1_5_5_5_REV ) {
	    SET_FORMAT( TMC_tformat_tw15, _mesa_texformat_argb1555 );
	    break;
	 }
      }
      SET_FORMAT_32BPT( TMC_tformat_tw32, _mesa_texformat_argb8888,
			TMC_tformat_tw12, _mesa_texformat_argb4444 );
      break;

   case GL_RGB:
   case 3:
      if ( format == GL_RGB && type == GL_UNSIGNED_SHORT_5_6_5 ) {
	 SET_FORMAT( TMC_tformat_tw16, _mesa_texformat_rgb565 );
	 break;
      }
      SET_FORMAT_32BPT( TMC_tformat_tw32, _mesa_texformat_argb8888,
			TMC_tformat_tw16, _mesa_texformat_rgb565 );
      break;

   case GL_RGBA8:
   case GL_RGB10_A2:
   case GL_RGBA12:
   case GL_RGBA16:
      SET_FORMAT_32BPT( TMC_tformat_tw32, _mesa_texformat_argb8888,
			TMC_tformat_tw12, _mesa_texformat_argb4444 );
      break;

   case GL_RGBA4:
   case GL_RGBA2:
   case GL_RGB5_A1:
      SET_FORMAT( TMC_tformat_tw12, _mesa_texformat_argb4444 );
      break;

#if 0
   case GL_RGB5_A1:
      /* GH: Leave this until we use the new texture conversion code.
       */
      SET_FORMAT( TMC_tformat_tw15, _mesa_texformat_argb1555 );
      break;
#endif

   case GL_RGB8:
   case GL_RGB10:
   case GL_RGB12:
   case GL_RGB16:
      SET_FORMAT_32BPT( TMC_tformat_tw32, _mesa_texformat_argb8888,
			TMC_tformat_tw16, _mesa_texformat_rgb565 );
      break;

   case GL_RGB5:
   case GL_RGB4:
   case GL_R3_G3_B2:
      SET_FORMAT( TMC_tformat_tw16, _mesa_texformat_rgb565 );
      break;

   case GL_ALPHA:
   case GL_ALPHA4:
   case GL_ALPHA8:
   case GL_ALPHA12:
   case GL_ALPHA16:
      /* FIXME: This will report incorrect component sizes... */
      SET_FORMAT( TMC_tformat_tw12, _mesa_texformat_argb4444 );
      break;

   case 1:
   case GL_LUMINANCE:
   case GL_LUMINANCE4:
   case GL_LUMINANCE8:
   case GL_LUMINANCE12:
   case GL_LUMINANCE16:
      /* FIXME: This will report incorrect component sizes... */
      SET_FORMAT( TMC_tformat_tw16, _mesa_texformat_rgb565 );
      break;

   case 2:
   case GL_LUMINANCE_ALPHA:
   case GL_LUMINANCE4_ALPHA4:
   case GL_LUMINANCE6_ALPHA2:
   case GL_LUMINANCE8_ALPHA8:
   case GL_LUMINANCE12_ALPHA4:
   case GL_LUMINANCE12_ALPHA12:
   case GL_LUMINANCE16_ALPHA16:
      /* FIXME: This will report incorrect component sizes... */
      SET_FORMAT( TMC_tformat_tw12, _mesa_texformat_argb4444 );
      break;

   case GL_INTENSITY:
   case GL_INTENSITY4:
   case GL_INTENSITY8:
   case GL_INTENSITY12:
   case GL_INTENSITY16:
      /* FIXME: This will report incorrect component sizes... */
      SET_FORMAT( TMC_tformat_tw12, _mesa_texformat_argb4444 );
      break;

   case GL_COLOR_INDEX:
   case GL_COLOR_INDEX1_EXT:
   case GL_COLOR_INDEX2_EXT:
   case GL_COLOR_INDEX4_EXT:
   case GL_COLOR_INDEX8_EXT:
   case GL_COLOR_INDEX12_EXT:
   case GL_COLOR_INDEX16_EXT:
      SET_FORMAT( TMC_tformat_tw8, _mesa_texformat_ci8 );
      break;

   default:
      fprintf( stderr, "bad texture format in mgaChooseTexFormat() %d",
	       texImage->IntFormat );
      return -1;
   }

   texImage->TexFormat = texFormat;

   return ret;
}


/*
 * mgaCreateTexObj
 * Allocate space for and load the mesa images into the texture memory block.
 * This will happen before drawing with a new texture, or drawing with a
 * texture after it was swapped out or teximaged again.
 */
static void mgaCreateTexObj(mgaContextPtr mmesa,
			    struct gl_texture_object *tObj)
{
   const GLint baseLevel = tObj->BaseLevel;
   struct gl_texture_image *image = tObj->Image[baseLevel];
   mgaTextureObjectPtr t;
   int i, ofs;
   int LastLevel;
   int s, s2;
   int tformat;

   if (!image) return;

   tObj->DriverData = t = CALLOC( sizeof( *t ) );
   if (!t) {
      fprintf(stderr, "mgaCreateTexObj: Failed to malloc mgaTextureObject\n" );
      return;
   }

   /* FIXME: Use the real DD interface...
    */
   tformat = mgaChooseTexFormat( mmesa, image, image->Format,
				 GL_UNSIGNED_BYTE );
   t->texelBytes = image->TexFormat->TexelBytes;

   /* We are going to upload all levels that are present, even if
    * later levels wouldn't be used by the current filtering mode.  This
    * allows the filtering mode to change without forcing another upload
    * of the images.
    */
   LastLevel = MGA_TEX_MAXLEVELS-1;

   ofs = 0;
   for ( i = 0 ; i <= LastLevel ; i++ ) {
      if ( !tObj->Image[i] ) {
	 LastLevel = i - 1;
	 break;
      }

      t->offsets[i] = ofs;
      t->dirty_images |= (1<<i);

      ofs += ((MAX2( tObj->Image[i]->Width, 8 ) *
	       MAX2( tObj->Image[i]->Height, 8 ) *
	       t->texelBytes) + 31) & ~31;
   }
   t->totalSize = ofs;
   t->lastLevel = LastLevel;
   t->tObj = tObj;
   t->ctx = mmesa;
   t->age = 0;
   t->bound = 0;
   t->MemBlock = 0;

   insert_at_tail(&(mmesa->SwappedOut), t);


   /* setup hardware register values */
   t->setup.texctl = TMC_takey_1 | TMC_tamask_0 | tformat;

   if (image->WidthLog2 >= 3)
      t->setup.texctl |= ((image->WidthLog2 - 3) << TMC_tpitch_SHIFT);
   else
      t->setup.texctl |= (TMC_tpitchlin_enable |
			  (image->Width << TMC_tpitchext_SHIFT));


   t->setup.texctl2 = TMC_ckstransdis_enable;

   if ( mmesa->glCtx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR )
      t->setup.texctl2 |= TMC_specen_enable;


   t->setup.texfilter = (TF_minfilter_nrst |
			 TF_magfilter_nrst |
			 TF_filteralpha_enable |
			 (0x10 << TF_fthres_SHIFT) |
			 (LastLevel << TF_mapnb_SHIFT));

   /* warp texture registers */
   ofs = MGA_IS_G200(mmesa) ? 28 : 11;
   s = image->Width;
   s2 = image->WidthLog2;
   t->setup.texwidth = (MGA_FIELD(TW_twmask, s - 1) |
			MGA_FIELD(TW_rfw, (10 - s2 - 8) & 63 ) |
			MGA_FIELD(TW_tw, (s2 + ofs ) | 0x40 ));


   s = image->Height;
   s2 = image->HeightLog2;
   t->setup.texheight = (MGA_FIELD(TH_thmask, s - 1) |
			 MGA_FIELD(TH_rfh, (10 - s2 - 8) & 63 ) |
			 MGA_FIELD(TH_th, (s2 + ofs ) | 0x40 ));


   /* set all the register values for filtering, border, etc */
   mgaSetTexWrapping( t, tObj->WrapS, tObj->WrapT );
   mgaSetTexFilter( t, tObj->MinFilter, tObj->MagFilter );
   mgaSetTexBorderColor( t, tObj->BorderColor );
}




static void mgaUpdateTextureEnvG200( GLcontext *ctx )
{
   struct gl_texture_object *tObj = ctx->Texture.Unit[0].Current;
   mgaTextureObjectPtr t;

   if (!tObj || !tObj->DriverData)
      return;

   t = (mgaTextureObjectPtr)tObj->DriverData;

   t->setup.texctl2 &= ~TMC_decalblend_enable;

   switch (ctx->Texture.Unit[0].EnvMode) {
   case GL_REPLACE:
      t->setup.texctl &= ~TMC_tmodulate_enable;
      break;
   case GL_MODULATE:
      t->setup.texctl |= TMC_tmodulate_enable;
      break;
   case GL_DECAL:
      t->setup.texctl &= ~TMC_tmodulate_enable;
      t->setup.texctl2 |= TMC_decalblend_enable;
      break;
   case GL_BLEND:
      t->ctx->Fallback |= MGA_FALLBACK_TEXTURE;
      break;
   default:
      break;
   }
}

static void mgaUpdateTextureEnvG400( GLcontext *ctx, int unit )
{
   mgaContextPtr mmesa = MGA_CONTEXT( ctx );
   GLuint *reg = ((GLuint *)&mmesa->setup.tdualstage0 + unit);
   GLuint source = mmesa->tmu_source[unit];
   struct gl_texture_object *tObj = ctx->Texture.Unit[source].Current;
   GLenum format;

   if ( tObj != ctx->Texture.Unit[source].CurrentD[2] ||
	!tObj ||
	!tObj->Complete ||
	((ctx->Enabled>>(source*4))&TEXTURE0_ANY) != TEXTURE0_2D )
      return;

   format = tObj->Image[tObj->BaseLevel]->Format;

   switch (ctx->Texture.Unit[source].EnvMode) {
   case GL_REPLACE:
      if (format == GL_RGB || format == GL_LUMINANCE) {
	 *reg = (TD0_color_sel_arg1 |
                 TD0_alpha_arg2_diffuse |
		 TD0_alpha_sel_arg2 );
      }
      else if (format == GL_ALPHA) {
         *reg = (TD0_color_sel_arg2 |
                 TD0_color_arg2_diffuse |
                 TD0_alpha_sel_arg1 );
      }
      else {
         *reg = (TD0_color_sel_arg1 |
                 TD0_alpha_sel_arg1 );
      }
      break;

   case GL_MODULATE:
      if (unit == 0) {
	 *reg = ( TD0_color_arg2_diffuse |
		  TD0_color_sel_mulout |
		  TD0_alpha_arg2_diffuse |
		  TD0_alpha_sel_mulout);
      }
      else {
	 *reg = ( TD0_color_arg2_prevstage |
		  TD0_color_alpha_prevstage |
		  TD0_color_sel_mulout |
		  TD0_alpha_arg2_prevstage |
		  TD0_alpha_sel_mulout);
      }
      break;
   case GL_DECAL:
      if (format == GL_RGB) {
         if (unit == 0) {
            *reg = (TD0_color_sel_arg1 |
                    TD0_alpha_arg2_diffuse |
                    TD0_alpha_sel_arg2 );
         }
         else {
            *reg = (TD0_color_sel_arg1 |
                    TD0_alpha_arg2_prevstage |
                    TD0_alpha_sel_arg2 );
         }
      }
      else if ( format == GL_RGBA ) {
#if 0
         if (unit == 0) {
            /* this doesn't work */
            *reg = (TD0_color_arg2_diffuse |
                    TD0_color_alpha_currtex |
                    TD0_color_alpha2inv_enable |
                    TD0_color_arg2mul_alpha2 |
                    TD0_color_arg1mul_alpha1 |
                    TD0_color_blend_enable |
                    TD0_color_arg1add_mulout |
                    TD0_color_arg2add_mulout |
                    TD0_color_add_add |
                    TD0_color_sel_mul |
                    TD0_alpha_arg2_diffuse |
                    TD0_alpha_sel_arg2 );
         }
         else {
            *reg = (TD0_color_arg2_prevstage |
                    TD0_color_alpha_currtex |
                    TD0_color_alpha2inv_enable |
                    TD0_color_arg2mul_alpha2 |
                    TD0_color_arg1mul_alpha1 |
                    TD0_color_add_add |
                    TD0_color_sel_add |
                    TD0_alpha_arg2_prevstage |
                    TD0_alpha_sel_arg2 );
         }
#else
         /* s/w fallback, pretty sure we can't do in h/w */
	 mmesa->Fallback |= MGA_FALLBACK_TEXTURE;
	 if ( MGA_DEBUG & DEBUG_VERBOSE_FALLBACK )
	    fprintf( stderr, "FALLBACK: GL_DECAL RGBA texture, unit=%d\n",
		     unit );
#endif
      }
      else {
	 if (unit == 0) {
	    *reg = ( TD0_color_arg2_diffuse |
		     TD0_color_sel_arg2 |
		     TD0_alpha_arg2_diffuse |
		     TD0_alpha_sel_arg2);
	 }
	 else {
	    *reg = ( TD0_color_arg2_prevstage |
		     TD0_color_sel_arg2 |
		     TD0_alpha_arg2_prevstage |
		     TD0_alpha_sel_arg2);
	 }
      }
      break;

   case GL_ADD:
      if (unit == 0) {
         if (format == GL_INTENSITY)
            *reg = ( TD0_color_arg2_diffuse |
                     TD0_color_add_add |
                     TD0_color_sel_addout |
                     TD0_alpha_arg2_diffuse |
                     TD0_alpha_add_enable |
                     TD0_alpha_sel_addout);
         else if (format == GL_ALPHA)
            *reg = ( TD0_color_arg2_diffuse |
                     TD0_color_sel_mulout |
                     TD0_alpha_arg2_diffuse |
                     TD0_alpha_sel_mulout);
         else
            *reg = ( TD0_color_arg2_diffuse |
                     TD0_color_add_add |
                     TD0_color_sel_addout |
                     TD0_alpha_arg2_diffuse |
                     TD0_alpha_sel_mulout);
      }
      else {
         if (format == GL_INTENSITY) {
            *reg = ( TD0_color_arg2_prevstage |
                     TD0_color_add_add |
                     TD0_color_sel_addout |
                     TD0_alpha_arg2_prevstage |
                     TD0_alpha_add_enable |
                     TD0_alpha_sel_addout);
         }
         else if (format == GL_ALPHA) {
            *reg = ( TD0_color_arg2_prevstage |
                     TD0_color_sel_mulout |
                     TD0_alpha_arg2_prevstage |
                     TD0_alpha_sel_mulout);
         }
         else {
            *reg = ( TD0_color_arg2_prevstage |
                     TD0_color_alpha_prevstage |
                     TD0_color_add_add |
                     TD0_color_sel_addout |
                     TD0_alpha_arg2_prevstage |
                     TD0_alpha_sel_mulout);
         }
      }
      break;

   case GL_BLEND:
      if (format == GL_ALPHA) {
	 *reg = ( TD0_color_arg2_diffuse |
		  TD0_color_sel_mulout |
		  TD0_alpha_arg2_diffuse |
		  TD0_alpha_sel_mulout);
      }
      else {
	 mmesa->Fallback |= MGA_FALLBACK_TEXTURE;
	 if ( MGA_DEBUG & DEBUG_VERBOSE_FALLBACK )
	    fprintf( stderr, "FALLBACK: GL_BLEND envcolor=0x%08x\n",
		     mmesa->envcolor );

         /* Do singletexture GL_BLEND with 'all ones' env-color
          * by using both texture units.  Multitexture gl_blend
          * is a fallback.
          */
         if (unit == 0) {
            /* Part 1: R1 = Rf ( 1 - Rt )
             *         A1 = Af At
             */
            *reg = ( TD0_color_arg2_diffuse |
                     TD0_color_arg1_inv_enable |
                     TD0_color_sel_mulout |
                     TD0_alpha_arg2_diffuse |
                     TD0_alpha_sel_arg1);
         } else {
            /* Part 2: R2 = R1 + Rt
             *         A2 = A1
             */
            *reg = ( TD0_color_arg2_prevstage |
                     TD0_color_add_add |
                     TD0_color_sel_addout |
                     TD0_alpha_arg2_prevstage |
                     TD0_alpha_sel_arg2);
         }
      }
      break;
   default:
      break;
   }
}



static void mgaUpdateTextureObject( GLcontext *ctx, int unit )
{
   mgaTextureObjectPtr t;
   struct gl_texture_object	*tObj;
   GLuint enabled;
   mgaContextPtr mmesa = MGA_CONTEXT( ctx );
   GLuint source = mmesa->tmu_source[unit];


   enabled = (ctx->Texture.ReallyEnabled>>(source*4))&TEXTURE0_ANY;
   tObj = ctx->Texture.Unit[source].Current;

   if (enabled != TEXTURE0_2D) {
      if (enabled) {
	 mmesa->Fallback |= MGA_FALLBACK_TEXTURE;
	 if ( MGA_DEBUG & DEBUG_VERBOSE_FALLBACK )
	    fprintf( stderr, "FALLBACK: tex enable != 2D\n" );
      }
      return;
   }

   if ( !tObj || tObj != ctx->Texture.Unit[source].CurrentD[2] ) {
      mmesa->Fallback |= MGA_FALLBACK_TEXTURE;
      if ( MGA_DEBUG & DEBUG_VERBOSE_FALLBACK )
	 fprintf( stderr, "FALLBACK: tObj != 2D texture\n" );
      return;
   }

   if (tObj->Image[tObj->BaseLevel]->Border > 0) {
      mmesa->Fallback |= MGA_FALLBACK_TEXTURE;
      if ( MGA_DEBUG & DEBUG_VERBOSE_FALLBACK )
	 fprintf( stderr, "FALLBACK: texture border\n" );
      return;
   }

/*     if (!tObj) tObj = ctx->Texture.Unit[0].Current; */
/*     if (!tObj) return; */

   if ( !tObj->DriverData ) {
      mgaCreateTexObj( mmesa, tObj );
      if ( !tObj->DriverData ) {
	 mmesa->Fallback |= MGA_FALLBACK_TEXTURE;
	 if ( MGA_DEBUG & DEBUG_VERBOSE_FALLBACK )
	    fprintf( stderr, "FALLBACK: could not create texture object\n" );
	 return;
      }
   }

   t = (mgaTextureObjectPtr)tObj->DriverData;

   if (t->dirty_images)
      mmesa->dirty |= (MGA_UPLOAD_TEX0IMAGE << unit);

   mmesa->CurrentTexObj[unit] = t;
   t->bound |= unit+1;

/*     if (t->MemBlock) */
/*        mgaUpdateTexLRU( mmesa, t ); */

   t->setup.texctl2 &= ~TMC_dualtex_enable;
   if (mmesa->multitex)
      t->setup.texctl2 |= TMC_dualtex_enable;

   t->setup.texctl2 &= ~TMC_specen_enable;
   if (ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR)
      t->setup.texctl2 |= TMC_specen_enable;
}






/* The G400 is now programmed quite differently wrt texture environment.
 */
void mgaUpdateTextureState( GLcontext *ctx )
{
   mgaContextPtr mmesa = MGA_CONTEXT( ctx );
   mmesa->Fallback &= ~MGA_FALLBACK_TEXTURE;

   if (mmesa->CurrentTexObj[0]) {
      mmesa->CurrentTexObj[0]->bound = 0;
      mmesa->CurrentTexObj[0] = 0;
   }

   if (mmesa->CurrentTexObj[1]) {
      mmesa->CurrentTexObj[1]->bound = 0;
      mmesa->CurrentTexObj[1] = 0;
   }

   if (MGA_IS_G400(mmesa)) {
      mgaUpdateTextureObject( ctx, 0 );
      mgaUpdateTextureEnvG400( ctx, 0 );

      mmesa->setup.tdualstage1 = mmesa->setup.tdualstage0;

      if (mmesa->multitex || 1) {
	 mgaUpdateTextureObject( ctx, 1 );
	 mgaUpdateTextureEnvG400( ctx, 1 );
      }
/*  else  */
/*  	 mmesa->Setup[MGA_CTXREG_TDUAL1] = ( TD0_color_arg2_prevstage | */
/*  					     TD0_color_sel_arg2 |  */
/*  					     TD0_alpha_arg2_prevstage | */
/*  					     TD0_alpha_sel_arg2); */


      mmesa->dirty |= MGA_UPLOAD_TEX1;
   } else {
      mgaUpdateTextureObject( ctx, 0 );
      mgaUpdateTextureEnvG200( ctx );
   }

   mmesa->dirty |= MGA_UPLOAD_CONTEXT | MGA_UPLOAD_TEX0;

   mmesa->setup.dwgctl &= DC_opcod_MASK;
   mmesa->setup.dwgctl |= (ctx->Texture.ReallyEnabled
			   ? DC_opcod_texture_trap
			   : DC_opcod_trap);
}




static void mgaDDTexEnv( GLcontext *ctx, GLenum target,
			 GLenum pname, const GLfloat *param )
{
   mgaContextPtr mmesa = MGA_CONTEXT(ctx);


   if (pname == GL_TEXTURE_ENV_MODE) {
      /* force the texture state to be updated */
      FLUSH_BATCH( MGA_CONTEXT(ctx) );
      MGA_CONTEXT(ctx)->new_state |= (MGA_NEW_TEXTURE |
				      MGA_NEW_ALPHA);
   }
   else if (pname == GL_TEXTURE_ENV_COLOR)
   {
      struct gl_texture_unit *texUnit =
	 &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      GLfloat *fc = texUnit->EnvColor;
      GLubyte c[4];
      GLuint col;

      COPY_4V(c, fc);
      col = mgaPackColor( mmesa->mgaScreen->cpp, c[0], c[1], c[2], c[3] );
      mmesa->envcolor = (c[3]<<24) | (c[0]<<16) | (c[1]<<8) | (c[2]);

      if (mmesa->setup.fcol != col) {
	 FLUSH_BATCH(mmesa);
	 mmesa->setup.fcol = col;
	 mmesa->dirty |= MGA_UPLOAD_CONTEXT;

	 mmesa->blend_flags &= ~MGA_BLEND_ENV_COLOR;

	 /* Actually just require all four components to be
	  * equal.  This permits a single-pass GL_BLEND.
	  *
	  * More complex multitexture/multipass fallbacks
	  * for blend can be done later.
	  */
	 if (mmesa->envcolor != 0x0 && mmesa->envcolor != 0xffffffff)
	    mmesa->blend_flags |= MGA_BLEND_ENV_COLOR;
      }
   }
}


static void mgaDDTexImage( GLcontext *ctx, GLenum target,
			   struct gl_texture_object *tObj, GLint level,
			   GLint internalFormat,
			   const struct gl_texture_image *image )
{
   mgaContextPtr mmesa = MGA_CONTEXT( ctx );
   mgaTextureObjectPtr t;
   GLint tformat;
   /* hack: cast-away const */
   struct gl_texture_image *img = (struct gl_texture_image *) image;

   /* just free the mga texture if it exists, it will be recreated at
      mgaUpdateTextureState time. */
   t = (mgaTextureObjectPtr) tObj->DriverData;
   if ( t ) {
      if (t->bound) FLUSH_BATCH(mmesa);
      /* if this is the current object, it will force an update */
      mgaDestroyTexObj( mmesa, t );
      mmesa->new_state |= MGA_NEW_TEXTURE;
   }

   tformat = mgaChooseTexFormat( mmesa, img, img->Format,
				 GL_UNSIGNED_BYTE );

   if (0)
      fprintf(stderr, "mgaDDTexImage tObj %p, level %d, image %p\n",
	      tObj, level, image);

}

static void mgaDDTexSubImage( GLcontext *ctx, GLenum target,
			      struct gl_texture_object *tObj, GLint level,
			      GLint xoffset, GLint yoffset,
			      GLsizei width, GLsizei height,
			      GLint internalFormat,
			      const struct gl_texture_image *image )
{
   mgaContextPtr mmesa = MGA_CONTEXT( ctx );
   mgaTextureObjectPtr t;

   t = (mgaTextureObjectPtr) tObj->DriverData;


   /* just free the mga texture if it exists, it will be recreated at
      mgaUpdateTextureState time. */
   t = (mgaTextureObjectPtr) tObj->DriverData;
   if ( t ) {
      if (t->bound) FLUSH_BATCH(mmesa);
      /* if this is the current object, it will force an update */
      mgaDestroyTexObj( mmesa, t );
      mmesa->new_state |= MGA_NEW_TEXTURE;
   }



#if 0
   /* the texture currently exists, so directly update it */
   mgaUploadSubImage( t, level, xoffset, yoffset, width, height );
#endif
}



/*
 * mgaTexParameter
 * This just changes variables and flags for a state update, which
 * will happen at the next mgaUpdateTextureState
 */
static void
mgaDDTexParameter( GLcontext *ctx, GLenum target,
		   struct gl_texture_object *tObj,
		   GLenum pname, const GLfloat *params )
{
   mgaContextPtr mmesa = MGA_CONTEXT( ctx );
   mgaTextureObjectPtr t;

   t = (mgaTextureObjectPtr) tObj->DriverData;

   /* if we don't have a hardware texture, it will be automatically
      created with current state before it is used, so we don't have
      to do anything now */
   if ( !t || !t->bound || target != GL_TEXTURE_2D ) {
      return;
   }

   switch (pname) {
   case GL_TEXTURE_MIN_FILTER:
   case GL_TEXTURE_MAG_FILTER:
      FLUSH_BATCH(mmesa);
      mgaSetTexFilter( t, tObj->MinFilter, tObj->MagFilter );
      break;

   case GL_TEXTURE_WRAP_S:
   case GL_TEXTURE_WRAP_T:
      FLUSH_BATCH(mmesa);
      mgaSetTexWrapping(t,tObj->WrapS,tObj->WrapT);
      break;

   case GL_TEXTURE_BORDER_COLOR:
      FLUSH_BATCH(mmesa);
      mgaSetTexBorderColor(t,tObj->BorderColor);
      break;

   default:
      return;
   }

   mmesa->new_state |= MGA_NEW_TEXTURE;
}


static void
mgaDDBindTexture( GLcontext *ctx, GLenum target,
		  struct gl_texture_object *tObj )
{
   mgaContextPtr mmesa = MGA_CONTEXT( ctx );
   int unit = ctx->Texture.CurrentUnit;

   FLUSH_BATCH(mmesa);

   if (mmesa->CurrentTexObj[unit]) {
      mmesa->CurrentTexObj[unit]->bound &= ~(unit+1);
      mmesa->CurrentTexObj[unit] = 0;
   }

   /* force the texture state to be updated
    */
   MGA_CONTEXT(ctx)->new_state |= MGA_NEW_TEXTURE;
}


static void
mgaDDDeleteTexture( GLcontext *ctx, struct gl_texture_object *tObj )
{
   mgaContextPtr mmesa = MGA_CONTEXT( ctx );
   mgaTextureObjectPtr t = (mgaTextureObjectPtr)tObj->DriverData;

   if ( t ) {
      if (t->bound) {
	 FLUSH_BATCH(mmesa);
	 if (t->bound & TEX_0) mmesa->CurrentTexObj[0] = 0;
	 if (t->bound & TEX_1) mmesa->CurrentTexObj[1] = 0;
	 mmesa->new_state |= MGA_NEW_TEXTURE;
      }

      mgaDestroyTexObj( mmesa, t );
      mmesa->new_state |= MGA_NEW_TEXTURE;
   }
}


static GLboolean
mgaDDIsTextureResident( GLcontext *ctx, struct gl_texture_object *t )
{
   mgaTextureObjectPtr mt = (mgaTextureObjectPtr)t->DriverData;
   return mt && mt->MemBlock;
}


void
mgaDDInitTextureFuncs( GLcontext *ctx )
{
   ctx->Driver.TexEnv = mgaDDTexEnv;
   ctx->Driver.TexImage = mgaDDTexImage;
   ctx->Driver.TexSubImage = mgaDDTexSubImage;
   ctx->Driver.BindTexture = mgaDDBindTexture;
   ctx->Driver.DeleteTexture = mgaDDDeleteTexture;
   ctx->Driver.TexParameter = mgaDDTexParameter;
   ctx->Driver.UpdateTexturePalette = 0;
   ctx->Driver.IsTextureResident = mgaDDIsTextureResident;
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d25 1
a25 1
 *    Keith Whitwell <keith@@tungstengraphics.com>
d27 5
a31 1
/* $XFree86: xc/lib/GL/mesa/src/drv/mga/mgatex.c,v 1.16 2003/12/02 13:02:38 alanh Exp $ */
a32 1
#include "glheader.h"
a36 1
#include "mgatris.h"
a38 1
#include "colormac.h"
d42 10
a51 14
#include "imports.h"
#include "macros.h"
#include "texformat.h"
#include "texstore.h"

#include "swrast/swrast.h"

/**
 * Set the texture wrap modes.
 * Currently \c GL_REPEAT, \c GL_CLAMP and \c GL_CLAMP_TO_EDGE are supported.
 * 
 * \param t Texture object whose wrap modes are to be set
 * \param swrap Wrap mode for the \a s texture coordinate
 * \param twrap Wrap mode for the \a t texture coordinate
d53 2
a54 3

static void 
mgaSetTexWrapping( mgaTextureObjectPtr t, GLenum swrap, GLenum twrap )
d56 1
a56 2
   GLboolean  is_clamp = GL_FALSE;
   GLboolean  is_clamp_to_edge = GL_FALSE;
d58 4
a61 2
   t->setup.texctl &= (TMC_clampu_MASK & TMC_clampv_MASK);
   t->setup.texctl2 &= (TMC_borderen_MASK);
d63 2
a64 13
   switch( swrap ) {
   case GL_REPEAT:
      break;
   case GL_CLAMP:
      t->setup.texctl |= TMC_clampu_enable;
      is_clamp = GL_TRUE;
      break;
   case GL_CLAMP_TO_EDGE:
      t->setup.texctl |= TMC_clampu_enable;
      is_clamp_to_edge = GL_TRUE;
      break;
   default:
      _mesa_problem(NULL, "bad S wrap mode in %s", __FUNCTION__);
d67 3
a69 14
   switch( twrap ) {
   case GL_REPEAT:
      break;
   case GL_CLAMP:
      t->setup.texctl |= TMC_clampv_enable;
      is_clamp = GL_TRUE;
      break;
   case GL_CLAMP_TO_EDGE:
      t->setup.texctl |= TMC_clampv_enable;
      is_clamp_to_edge = GL_TRUE;
      break;
   default:
      _mesa_problem(NULL, "bad T wrap mode in %s", __FUNCTION__);
   }
d71 3
a73 3
   if ( is_clamp ) {
      t->setup.texctl2 |= TMC_borderen_enable;
   }
d75 2
a76 1
   t->border_fallback = (is_clamp && is_clamp_to_edge);
d80 2
a81 6
/**
 * Set the texture magnification and minification modes.
 * 
 * \param t Texture whose filter modes are to be set
 * \param minf Texture minification mode
 * \param magf Texture magnification mode
d83 16
d100 4
a103 2
static void
mgaSetTexFilter( mgaTextureObjectPtr t, GLenum minf, GLenum magf )
d126 1
a126 1
      val |= MGA_FIELD( TF_fthres, 0x20 ); /* c = 0.5 */
d128 1
a128 1
      val |= MGA_FIELD( TF_fthres, 0x10 ); /* c = 0 */
d132 2
a133 7
   /* Mask off the bits for the fields we are setting.  Remember, the MGA mask
    * defines have 0s for the bits in the named fields.  This is the opposite
    * of most of the other drivers.
    */

   t->setup.texfilter &= (TF_minfilter_MASK &
			  TF_magfilter_MASK &
d138 3
d143 2
a144 2
   t->setup.texbordercol = PACK_COLOR_8888(color[3], color[0], 
					   color[1], color[2] );
d148 3
a150 3
static const struct gl_texture_format *
mgaChooseTextureFormat( GLcontext *ctx, GLint internalFormat,
		        GLenum format, GLenum type )
a151 1
   mgaContextPtr mmesa = MGA_CONTEXT(ctx);
d153 27
d181 2
a182 1
   switch ( internalFormat ) {
a183 2
   case GL_RGBA:
   case GL_COMPRESSED_RGBA:
d186 8
a193 7
	    return &_mesa_texformat_argb8888;
	 }
         else if ( type == GL_UNSIGNED_SHORT_4_4_4_4_REV ) {
            return &_mesa_texformat_argb4444;
	 }
         else if ( type == GL_UNSIGNED_SHORT_1_5_5_5_REV ) {
	    return &_mesa_texformat_argb1555;
d196 3
a198 1
      return do32bpt ? &_mesa_texformat_argb8888 : &_mesa_texformat_argb4444;
d200 1
a201 2
   case GL_RGB:
   case GL_COMPRESSED_RGB:
d203 2
a204 1
	 return &_mesa_texformat_rgb565;
d206 3
a208 1
      return do32bpt ? &_mesa_texformat_argb8888 : &_mesa_texformat_rgb565;
d214 3
a216 1
      return do32bpt ? &_mesa_texformat_argb8888 : &_mesa_texformat_argb4444;
d220 3
a222 1
      return &_mesa_texformat_argb4444;
d224 1
d226 5
a230 1
      return &_mesa_texformat_argb1555;
d236 3
a238 1
      return do32bpt ? &_mesa_texformat_argb8888 : &_mesa_texformat_rgb565;
d243 2
a244 1
      return &_mesa_texformat_rgb565;
a250 1
   case GL_COMPRESSED_ALPHA:
d252 2
a253 1
      return MGA_IS_G400(mmesa) ? &_mesa_texformat_al88 : &_mesa_texformat_argb4444;
a260 1
   case GL_COMPRESSED_LUMINANCE:
d262 2
a263 1
      return MGA_IS_G400(mmesa) ? &_mesa_texformat_al88 : &_mesa_texformat_rgb565;
a272 1
   case GL_COMPRESSED_LUMINANCE_ALPHA:
d274 2
a275 1
      return MGA_IS_G400(mmesa) ? &_mesa_texformat_al88 : &_mesa_texformat_argb4444;
a281 1
   case GL_COMPRESSED_INTENSITY:
d283 2
a284 9
      return MGA_IS_G400(mmesa) ? &_mesa_texformat_i8 : &_mesa_texformat_argb4444;

   case GL_YCBCR_MESA:
      if (MGA_IS_G400(mmesa) &&
          (type == GL_UNSIGNED_SHORT_8_8_APPLE ||
           type == GL_UNSIGNED_BYTE))
         return &_mesa_texformat_ycbcr;
      else
         return &_mesa_texformat_ycbcr_rev;
d293 2
a294 1
      return &_mesa_texformat_ci8;
d297 3
a299 2
      _mesa_problem( ctx, "unexpected texture format in %s", __FUNCTION__ );
      return NULL;
d302 3
a304 1
   return NULL; /* never get here */
d308 2
a309 3


/**
d314 2
a315 3

static mgaTextureObjectPtr
mgaAllocTexObj( struct gl_texture_object *tObj )
d317 2
d320 65
d387 5
a391 6
   t = CALLOC( sizeof( *t ) );
   tObj->DriverData = t;
   if ( t != NULL ) {
      /* Initialize non-image-dependent parts of the state:
       */
      t->base.tObj = tObj;
d393 7
a399 3
      t->setup.texctl = TMC_takey_1 | TMC_tamask_0;
      t->setup.texctl2 = TMC_ckstransdis_enable;
      t->setup.texfilter = TF_filteralpha_enable | TF_uvoffset_OGL;
a400 2
      t->border_fallback = GL_FALSE;
      t->texenv_fallback = GL_FALSE;
d402 5
a406 1
      make_empty_list( & t->base );
a407 4
      mgaSetTexWrapping( t, tObj->WrapS, tObj->WrapT );
      mgaSetTexFilter( t, tObj->MinFilter, tObj->MagFilter );
      mgaSetTexBorderColor( t, tObj->_BorderChan );
   }
d409 4
a412 1
   return( t );
d416 3
a418 2
static void mgaDDTexEnv( GLcontext *ctx, GLenum target,
			 GLenum pname, const GLfloat *param )
d420 7
a426 3
   GLuint unit = ctx->Texture.CurrentUnit;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
   mgaContextPtr mmesa = MGA_CONTEXT(ctx);
d428 1
a428 3
   switch( pname ) {
   case GL_TEXTURE_ENV_COLOR: {
      GLubyte c[4];
d430 15
a444 2
      UNCLAMPED_FLOAT_TO_RGBA_CHAN( c, texUnit->EnvColor );
      mmesa->envcolor[unit] = PACK_COLOR_8888( c[3], c[0], c[1], c[2] );
d447 203
d654 2
a655 7
static void mgaTexImage2D( GLcontext *ctx, GLenum target, GLint level,
			    GLint internalFormat,
			    GLint width, GLint height, GLint border,
			    GLenum format, GLenum type, const GLvoid *pixels,
			    const struct gl_pixelstore_attrib *packing,
			    struct gl_texture_object *texObj,
			    struct gl_texture_image *texImage )
d657 6
a662 1
   driTextureObject * t = (driTextureObject *) texObj->DriverData;
d664 2
d667 5
a671 8
   if ( t != NULL ) {
      driSwapOutTextureObject( t );
   } 
   else {
      t = (driTextureObject *) mgaAllocTexObj( texObj );
      if ( t == NULL ) {
	 _mesa_error( ctx, GL_OUT_OF_MEMORY, "glTexImage2D" );
	 return;
d673 8
d683 16
a698 30
   _mesa_store_teximage2d( ctx, target, level, internalFormat,
			   width, height, border, format, type,
			   pixels, packing, texObj, texImage );
   level -= t->firstLevel;
   if (level >= 0)
      t->dirty_images[0] |= (1UL << level);
}

static void mgaTexSubImage2D( GLcontext *ctx, 
			       GLenum target,
			       GLint level,	
			       GLint xoffset, GLint yoffset,
			       GLsizei width, GLsizei height,
			       GLenum format, GLenum type,
			       const GLvoid *pixels,
			       const struct gl_pixelstore_attrib *packing,
			       struct gl_texture_object *texObj,
			       struct gl_texture_image *texImage )
{
   driTextureObject * t = (driTextureObject *) texObj->DriverData;


   assert( t != NULL ); /* this _should_ be true */
   if ( t != NULL ) {
      driSwapOutTextureObject( t );
   } 
   else {
      t = (driTextureObject *) mgaAllocTexObj( texObj );
      if ( t == NULL ) {
	 _mesa_error( ctx, GL_OUT_OF_MEMORY, "glTexImage2D" );
d703 18
a720 6
   _mesa_store_texsubimage2d(ctx, target, level, xoffset, yoffset, width, 
			     height, format, type, pixels, packing, texObj,
			     texImage);
   level -= t->firstLevel;
   if (level >= 0)
      t->dirty_images[0] |= (1UL << level);
d724 5
a728 3
/**
 * Changes variables and flags for a state update, which will happen at the
 * next UpdateTextureState
d730 155
d886 5
d896 1
a896 1
   mgaContextPtr       mmesa = MGA_CONTEXT( ctx );
d901 4
a904 8
   /* If we don't have a hardware texture, it will be automatically
    * created with current state before it is used, so we don't have
    * to do anything now 
    */

   if ( (t == NULL) ||
        (target != GL_TEXTURE_2D &&
         target != GL_TEXTURE_RECTANGLE_NV) ) {
a909 2
      driSwapOutTextureObject( (driTextureObject *) t );
      /* FALLTHROUGH */
d923 1
a923 13
      mgaSetTexBorderColor(t, tObj->_BorderChan);
      break;

   case GL_TEXTURE_BASE_LEVEL:
   case GL_TEXTURE_MAX_LEVEL:
   case GL_TEXTURE_MIN_LOD:
   case GL_TEXTURE_MAX_LOD:
      /* This isn't the most efficient solution but there doesn't appear to
       * be a nice alternative.  Since there's no LOD clamping,
       * we just have to rely on loading the right subset of mipmap levels
       * to simulate a clamped LOD.
       */
      driSwapOutTextureObject( (driTextureObject *) t );
d929 2
d938 8
a945 5
   if ( target == GL_TEXTURE_2D ||
        target == GL_TEXTURE_RECTANGLE_NV ) {
      if ( tObj->DriverData == NULL ) {
	 mgaAllocTexObj( tObj );
      }
d947 4
d958 1
a958 1
   driTextureObject * t = (driTextureObject *) tObj->DriverData;
d961 5
a965 2
      if ( mmesa ) {
	 FLUSH_BATCH( mmesa );
d968 2
a969 1
      driDestroyTextureObject( t );
d974 8
d985 8
a992 31
   mgaContextPtr mmesa = MGA_CONTEXT(ctx);


   ctx->Driver.ChooseTextureFormat	= mgaChooseTextureFormat;
   ctx->Driver.TexImage1D		= _mesa_store_teximage1d;
   ctx->Driver.TexImage2D		= mgaTexImage2D;
   ctx->Driver.TexImage3D		= _mesa_store_teximage3d;
   ctx->Driver.TexSubImage1D		= _mesa_store_texsubimage1d;
   ctx->Driver.TexSubImage2D		= mgaTexSubImage2D;
   ctx->Driver.TexSubImage3D		= _mesa_store_texsubimage3d;
   ctx->Driver.CopyTexImage1D		= _swrast_copy_teximage1d;
   ctx->Driver.CopyTexImage2D		= _swrast_copy_teximage2d;
   ctx->Driver.CopyTexSubImage1D	= _swrast_copy_texsubimage1d;
   ctx->Driver.CopyTexSubImage2D	= _swrast_copy_texsubimage2d;
   ctx->Driver.CopyTexSubImage3D	= _swrast_copy_texsubimage3d;
   ctx->Driver.TestProxyTexImage	= _mesa_test_proxy_teximage;

   ctx->Driver.BindTexture		= mgaDDBindTexture;
   ctx->Driver.CreateTexture		= NULL; /* FIXME: Is this used??? */
   ctx->Driver.DeleteTexture		= mgaDDDeleteTexture;
   ctx->Driver.IsTextureResident	= driIsTextureResident;
   ctx->Driver.PrioritizeTexture	= NULL;
   ctx->Driver.ActiveTexture		= NULL;
   ctx->Driver.UpdateTexturePalette	= NULL;

   ctx->Driver.TexEnv			= mgaDDTexEnv;
   ctx->Driver.TexParameter		= mgaDDTexParameter;

   driInitTextureObjects( ctx, & mmesa->swapped,
                          (DRI_TEXMGR_DO_TEXTURE_2D |
                           DRI_TEXMGR_DO_TEXTURE_RECT) );
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d25 1
a25 1
 *    Keith Whitwell <keith@@tungstengraphics.com>
d27 1
a27 1
/* $XFree86: xc/lib/GL/mesa/src/drv/mga/mgatex.c,v 1.14 2002/10/30 12:51:36 alanh Exp $ */
a36 1
#include "mgatris.h"
d39 1
d43 1
a43 5
#include "macros.h"
#include "texformat.h"
#include "texstore.h"

#include "swrast/swrast.h"
d63 1
a63 1
      if (mmesa && t->age > mmesa->dirtyAge)
d72 3
a74 5
   if (mmesa) {
      if (t->bound & TEX_0) mmesa->CurrentTexObj[0] = 0;
      if (t->bound & TEX_1) mmesa->CurrentTexObj[1] = 0;
   }
	
d160 3
a162 3
	       _mesa_lookup_enum_by_nr( texImage->IntFormat ),
	       _mesa_lookup_enum_by_nr( format ),
	       _mesa_lookup_enum_by_nr( type ) );
d182 1
a182 4
      /* GH: Bias towards GL_RGB, GL_RGBA texture formats.  This has
       * got to be better than sticking them way down the end of this
       * huge list.
       */
a183 2
   case GL_RGBA:
   case GL_COMPRESSED_RGBA:
d200 1
a201 2
   case GL_RGB:
   case GL_COMPRESSED_RGB:
a209 3
      /* GH: Okay, keep checking as normal.  Still test for GL_RGB,
       * GL_RGBA formats first.
       */
d220 1
d224 1
d226 2
d230 1
a250 1
   case GL_COMPRESSED_ALPHA:
a260 1
   case GL_COMPRESSED_LUMINANCE:
a272 1
   case GL_COMPRESSED_LUMINANCE_ALPHA:
a281 1
   case GL_COMPRESSED_INTENSITY:
d420 1
a420 1
   struct gl_texture_object *tObj = ctx->Texture.Unit[0]._Current;
d442 1
a442 1
      FALLBACK( ctx, MGA_FALLBACK_TEXTURE, GL_TRUE );
d454 1
a454 1
   struct gl_texture_object *tObj = ctx->Texture.Unit[source]._Current;
d457 4
a460 1
   if ( tObj != ctx->Texture.Unit[source].Current2D || !tObj ) 
d486 1
a486 1
		  TD0_color_sel_mul |
d488 1
a488 1
		  TD0_alpha_sel_mul);
d493 1
a493 1
		  TD0_color_sel_mul |
d495 1
a495 1
		  TD0_alpha_sel_mul);
d541 1
a541 1
	 FALLBACK( ctx, MGA_FALLBACK_TEXTURE, GL_TRUE );
d568 1
a568 1
                     TD0_color_sel_add |
d571 1
a571 1
                     TD0_alpha_sel_add);
d574 1
a574 1
                     TD0_color_sel_mul |
d576 1
a576 1
                     TD0_alpha_sel_mul);
d580 1
a580 1
                     TD0_color_sel_add |
d582 1
a582 1
                     TD0_alpha_sel_mul);
d588 1
a588 1
                     TD0_color_sel_add |
d591 1
a591 1
                     TD0_alpha_sel_add);
d595 1
a595 1
                     TD0_color_sel_mul |
d597 1
a597 1
                     TD0_alpha_sel_mul);
d603 1
a603 1
                     TD0_color_sel_add |
d605 1
a605 1
                     TD0_alpha_sel_mul);
d613 1
a613 1
		  TD0_color_sel_mul |
d615 1
a615 1
		  TD0_alpha_sel_mul);
d618 1
a618 1
	 FALLBACK( ctx, MGA_FALLBACK_TEXTURE, GL_TRUE );
d633 1
a633 1
                     TD0_color_sel_mul |
d642 1
a642 1
                     TD0_color_sel_add |
d655 1
a655 1
static void mgaUpdateTextureObject( GLcontext *ctx, int hw_unit )
d661 1
a661 1
   GLuint gl_unit = mmesa->tmu_source[hw_unit];
d664 2
a665 2
   enabled = ctx->Texture.Unit[gl_unit]._ReallyEnabled;
   tObj = ctx->Texture.Unit[gl_unit]._Current;
d668 12
a679 2
      if (enabled)
	 FALLBACK( ctx, MGA_FALLBACK_TEXTURE, GL_TRUE );
d684 1
a684 1
      FALLBACK( ctx, MGA_FALLBACK_TEXTURE, GL_TRUE );
d690 3
d696 4
a699 2
	 FALLBACK( ctx, MGA_FALLBACK_TEXTURE, GL_TRUE );
	 return;		
d706 1
a706 1
      mmesa->dirty |= (MGA_UPLOAD_TEX0IMAGE << hw_unit);
d708 2
a709 2
   mmesa->CurrentTexObj[hw_unit] = t;
   t->bound |= hw_unit+1;
d715 1
a715 1
   if (ctx->Texture._ReallyEnabled == (TEXTURE0_2D|TEXTURE1_2D)) 
d733 1
a733 1
   FALLBACK( ctx, MGA_FALLBACK_TEXTURE, GL_FALSE );
a744 6
   if (ctx->Texture._ReallyEnabled == TEXTURE1_2D) {
      mmesa->tmu_source[0] = 1;
   } else {
      mmesa->tmu_source[0] = 0;
   }

d750 3
a752 3
      
      if (ctx->Texture._ReallyEnabled == (TEXTURE0_2D|TEXTURE1_2D)) {
	 mgaUpdateTextureObject( ctx, 1 );	
a753 1
	 mmesa->dirty |= MGA_UPLOAD_TEX1;
d755 8
d771 1
a771 1
   mmesa->setup.dwgctl |= (ctx->Texture._ReallyEnabled
d823 27
a849 37
static void mgaTexImage2D( GLcontext *ctx, GLenum target, GLint level,
			    GLint internalFormat,
			    GLint width, GLint height, GLint border,
			    GLenum format, GLenum type, const GLvoid *pixels,
			    const struct gl_pixelstore_attrib *packing,
			    struct gl_texture_object *texObj,
			    struct gl_texture_image *texImage )
{
   mgaTextureObjectPtr t = (mgaTextureObjectPtr) texObj->DriverData;
   if (t) {
      mgaDestroyTexObj( MGA_CONTEXT(ctx), t );
      texObj->DriverData = 0;
   }
   _mesa_store_teximage2d( ctx, target, level, internalFormat,
			   width, height, border, format, type,
			   pixels, packing, texObj, texImage );
}

static void mgaTexSubImage2D( GLcontext *ctx, 
			       GLenum target,
			       GLint level,	
			       GLint xoffset, GLint yoffset,
			       GLsizei width, GLsizei height,
			       GLenum format, GLenum type,
			       const GLvoid *pixels,
			       const struct gl_pixelstore_attrib *packing,
			       struct gl_texture_object *texObj,
			       struct gl_texture_image *texImage )
{
   mgaTextureObjectPtr t = (mgaTextureObjectPtr) texObj->DriverData;
   if (t) {
      mgaDestroyTexObj( MGA_CONTEXT(ctx), t );
      texObj->DriverData = 0;
   }
   _mesa_store_texsubimage2d(ctx, target, level, xoffset, yoffset, width, 
			     height, format, type, pixels, packing, texObj,
			     texImage);
d853 30
d961 5
a965 7
      if (mmesa) {
         if (t->bound) {
            FLUSH_BATCH(mmesa);
            if (t->bound & TEX_0) mmesa->CurrentTexObj[0] = 0;
            if (t->bound & TEX_1) mmesa->CurrentTexObj[1] = 0;
         }
         mmesa->new_state |= MGA_NEW_TEXTURE;
d969 1
d986 2
a987 15

   ctx->Driver.ChooseTextureFormat = _mesa_choose_tex_format;
   ctx->Driver.TexImage1D = _mesa_store_teximage1d;
   ctx->Driver.TexImage2D = mgaTexImage2D;
   ctx->Driver.TexImage3D = _mesa_store_teximage3d;
   ctx->Driver.TexSubImage1D = _mesa_store_texsubimage1d;
   ctx->Driver.TexSubImage2D = mgaTexSubImage2D;
   ctx->Driver.TexSubImage3D = _mesa_store_texsubimage3d;
   ctx->Driver.CopyTexImage1D = _swrast_copy_teximage1d;
   ctx->Driver.CopyTexImage2D = _swrast_copy_teximage2d;
   ctx->Driver.CopyTexSubImage1D = _swrast_copy_texsubimage1d;
   ctx->Driver.CopyTexSubImage2D = _swrast_copy_texsubimage2d;
   ctx->Driver.CopyTexSubImage3D = _swrast_copy_texsubimage3d;
   ctx->Driver.TestProxyTexImage = _mesa_test_proxy_teximage;

@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d27 5
a31 1
/* $XFree86: xc/lib/GL/mesa/src/drv/mga/mgatex.c,v 1.16 2003/12/02 13:02:38 alanh Exp $ */
a32 1
#include "glheader.h"
a39 2
#include "colormac.h"
#include "context.h"
d42 1
a42 1
#include "imports.h"
d49 7
a55 7
/**
 * Set the texture wrap modes.
 * Currently \c GL_REPEAT, \c GL_CLAMP and \c GL_CLAMP_TO_EDGE are supported.
 * 
 * \param t Texture object whose wrap modes are to be set
 * \param swrap Wrap mode for the \a s texture coordinate
 * \param twrap Wrap mode for the \a t texture coordinate
d57 2
a58 3

static void 
mgaSetTexWrapping( mgaTextureObjectPtr t, GLenum swrap, GLenum twrap )
d60 1
a60 2
   GLboolean  is_clamp = GL_FALSE;
   GLboolean  is_clamp_to_edge = GL_FALSE;
d62 4
a65 2
   t->setup.texctl &= (TMC_clampu_MASK & TMC_clampv_MASK);
   t->setup.texctl2 &= (TMC_borderen_MASK);
d67 2
a68 13
   switch( swrap ) {
   case GL_REPEAT:
      break;
   case GL_CLAMP:
      t->setup.texctl |= TMC_clampu_enable;
      is_clamp = GL_TRUE;
      break;
   case GL_CLAMP_TO_EDGE:
      t->setup.texctl |= TMC_clampu_enable;
      is_clamp_to_edge = GL_TRUE;
      break;
   default:
      _mesa_problem(NULL, "bad S wrap mode in %s", __FUNCTION__);
d71 8
a78 13
   switch( twrap ) {
   case GL_REPEAT:
      break;
   case GL_CLAMP:
      t->setup.texctl |= TMC_clampv_enable;
      is_clamp = GL_TRUE;
      break;
   case GL_CLAMP_TO_EDGE:
      t->setup.texctl |= TMC_clampv_enable;
      is_clamp_to_edge = GL_TRUE;
      break;
   default:
      _mesa_problem(NULL, "bad T wrap mode in %s", __FUNCTION__);
d80 14
d95 5
a99 3
   if ( is_clamp ) {
      t->setup.texctl2 |= TMC_borderen_enable;
   }
d101 2
a102 1
   t->border_fallback = (is_clamp && is_clamp_to_edge);
d106 2
a107 6
/**
 * Set the texture magnification and minification modes.
 * 
 * \param t Texture whose filter modes are to be set
 * \param minf Texture minification mode
 * \param magf Texture magnification mode
d109 1
a109 3

static void
mgaSetTexFilter( mgaTextureObjectPtr t, GLenum minf, GLenum magf )
d132 1
a132 1
      val |= MGA_FIELD( TF_fthres, 0x20 ); /* c = 0.5 */
d134 1
a134 1
      val |= MGA_FIELD( TF_fthres, 0x10 ); /* c = 0 */
d138 2
a139 7
   /* Mask off the bits for the fields we are setting.  Remember, the MGA mask
    * defines have 0s for the bits in the named fields.  This is the opposite
    * of most of the other drivers.
    */

   t->setup.texfilter &= (TF_minfilter_MASK &
			  TF_magfilter_MASK &
d144 3
d149 2
a150 2
   t->setup.texbordercol = PACK_COLOR_8888(color[3], color[0], 
					   color[1], color[2] );
d154 3
a156 3
static const struct gl_texture_format *
mgaChooseTextureFormat( GLcontext *ctx, GLint internalFormat,
		        GLenum format, GLenum type )
a157 1
   mgaContextPtr mmesa = MGA_CONTEXT(ctx);
d159 2
d162 30
a191 1
   switch ( internalFormat ) {
d197 8
a204 7
	    return &_mesa_texformat_argb8888;
	 }
         else if ( type == GL_UNSIGNED_SHORT_4_4_4_4_REV ) {
            return &_mesa_texformat_argb4444;
	 }
         else if ( type == GL_UNSIGNED_SHORT_1_5_5_5_REV ) {
	    return &_mesa_texformat_argb1555;
d207 3
a209 1
      return do32bpt ? &_mesa_texformat_argb8888 : &_mesa_texformat_argb4444;
d215 2
a216 1
	 return &_mesa_texformat_rgb565;
d218 3
a220 1
      return do32bpt ? &_mesa_texformat_argb8888 : &_mesa_texformat_rgb565;
d222 3
d229 3
a231 1
      return do32bpt ? &_mesa_texformat_argb8888 : &_mesa_texformat_argb4444;
d235 2
a236 1
      return &_mesa_texformat_argb4444;
d239 2
a240 1
      return &_mesa_texformat_argb1555;
d246 3
a248 1
      return do32bpt ? &_mesa_texformat_argb8888 : &_mesa_texformat_rgb565;
d253 2
a254 1
      return &_mesa_texformat_rgb565;
d263 2
a264 1
      return MGA_IS_G400(mmesa) ? &_mesa_texformat_al88 : &_mesa_texformat_argb4444;
d274 2
a275 1
      return MGA_IS_G400(mmesa) ? &_mesa_texformat_al88 : &_mesa_texformat_rgb565;
d287 2
a288 1
      return MGA_IS_G400(mmesa) ? &_mesa_texformat_al88 : &_mesa_texformat_argb4444;
d297 2
a298 9
      return MGA_IS_G400(mmesa) ? &_mesa_texformat_i8 : &_mesa_texformat_argb4444;

   case GL_YCBCR_MESA:
      if (MGA_IS_G400(mmesa) &&
          (type == GL_UNSIGNED_SHORT_8_8_APPLE ||
           type == GL_UNSIGNED_BYTE))
         return &_mesa_texformat_ycbcr;
      else
         return &_mesa_texformat_ycbcr_rev;
d307 2
a308 1
      return &_mesa_texformat_ci8;
d311 3
a313 2
      _mesa_problem( ctx, "unexpected texture format in %s", __FUNCTION__ );
      return NULL;
d316 3
a318 1
   return NULL; /* never get here */
d322 2
a323 3


/**
d328 336
d665 2
a666 2
static mgaTextureObjectPtr
mgaAllocTexObj( struct gl_texture_object *tObj )
d669 52
a722 6
   t = CALLOC( sizeof( *t ) );
   tObj->DriverData = t;
   if ( t != NULL ) {
      /* Initialize non-image-dependent parts of the state:
       */
      t->base.tObj = tObj;
d724 6
a729 3
      t->setup.texctl = TMC_takey_1 | TMC_tamask_0;
      t->setup.texctl2 = TMC_ckstransdis_enable;
      t->setup.texfilter = TF_filteralpha_enable | TF_uvoffset_OGL;
d731 4
a734 2
      t->border_fallback = GL_FALSE;
      t->texenv_fallback = GL_FALSE;
d736 4
a739 1
      make_empty_list( & t->base );
d741 20
a760 3
      mgaSetTexWrapping( t, tObj->WrapS, tObj->WrapT );
      mgaSetTexFilter( t, tObj->MinFilter, tObj->MagFilter );
      mgaSetTexBorderColor( t, tObj->_BorderChan );
d763 6
a768 1
   return( t );
d772 2
a776 2
   GLuint unit = ctx->Texture.CurrentUnit;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
d779 12
a790 2
   switch( pname ) {
   case GL_TEXTURE_ENV_COLOR: {
d792 1
d794 20
a813 4
      UNCLAMPED_FLOAT_TO_RGBA_CHAN( c, texUnit->EnvColor );
      mmesa->envcolor[unit] = PACK_COLOR_8888( c[3], c[0], c[1], c[2] );
      break;
   }
d826 4
a829 12
   driTextureObject * t = (driTextureObject *) texObj->DriverData;


   if ( t != NULL ) {
      driSwapOutTextureObject( t );
   } 
   else {
      t = (driTextureObject *) mgaAllocTexObj( texObj );
      if ( t == NULL ) {
	 _mesa_error( ctx, GL_OUT_OF_MEMORY, "glTexImage2D" );
	 return;
      }
a830 1

a833 3
   level -= t->firstLevel;
   if (level >= 0)
      t->dirty_images[0] |= (1UL << level);
d847 4
a850 13
   driTextureObject * t = (driTextureObject *) texObj->DriverData;


   assert( t != NULL ); /* this _should_ be true */
   if ( t != NULL ) {
      driSwapOutTextureObject( t );
   } 
   else {
      t = (driTextureObject *) mgaAllocTexObj( texObj );
      if ( t == NULL ) {
	 _mesa_error( ctx, GL_OUT_OF_MEMORY, "glTexImage2D" );
	 return;
      }
a851 1

d855 1
a855 3
   level -= t->firstLevel;
   if (level >= 0)
      t->dirty_images[0] |= (1UL << level);
d859 6
a864 3
/**
 * Changes variables and flags for a state update, which will happen at the
 * next UpdateTextureState
a865 1

d871 1
a871 1
   mgaContextPtr       mmesa = MGA_CONTEXT( ctx );
d876 4
a879 8
   /* If we don't have a hardware texture, it will be automatically
    * created with current state before it is used, so we don't have
    * to do anything now 
    */

   if ( (t == NULL) ||
        (target != GL_TEXTURE_2D &&
         target != GL_TEXTURE_RECTANGLE_NV) ) {
a884 2
      driSwapOutTextureObject( (driTextureObject *) t );
      /* FALLTHROUGH */
d898 1
a898 13
      mgaSetTexBorderColor(t, tObj->_BorderChan);
      break;

   case GL_TEXTURE_BASE_LEVEL:
   case GL_TEXTURE_MAX_LEVEL:
   case GL_TEXTURE_MIN_LOD:
   case GL_TEXTURE_MAX_LOD:
      /* This isn't the most efficient solution but there doesn't appear to
       * be a nice alternative.  Since there's no LOD clamping,
       * we just have to rely on loading the right subset of mipmap levels
       * to simulate a clamped LOD.
       */
      driSwapOutTextureObject( (driTextureObject *) t );
d904 2
d913 8
a920 5
   if ( target == GL_TEXTURE_2D ||
        target == GL_TEXTURE_RECTANGLE_NV ) {
      if ( tObj->DriverData == NULL ) {
	 mgaAllocTexObj( tObj );
      }
d922 4
d933 1
a933 1
   driTextureObject * t = (driTextureObject *) tObj->DriverData;
d936 7
a942 2
      if ( mmesa ) {
	 FLUSH_BATCH( mmesa );
d945 1
a945 1
      driDestroyTextureObject( t );
d950 8
d961 1
a961 2
   mgaContextPtr mmesa = MGA_CONTEXT(ctx);

d963 19
a981 28
   ctx->Driver.ChooseTextureFormat	= mgaChooseTextureFormat;
   ctx->Driver.TexImage1D		= _mesa_store_teximage1d;
   ctx->Driver.TexImage2D		= mgaTexImage2D;
   ctx->Driver.TexImage3D		= _mesa_store_teximage3d;
   ctx->Driver.TexSubImage1D		= _mesa_store_texsubimage1d;
   ctx->Driver.TexSubImage2D		= mgaTexSubImage2D;
   ctx->Driver.TexSubImage3D		= _mesa_store_texsubimage3d;
   ctx->Driver.CopyTexImage1D		= _swrast_copy_teximage1d;
   ctx->Driver.CopyTexImage2D		= _swrast_copy_teximage2d;
   ctx->Driver.CopyTexSubImage1D	= _swrast_copy_texsubimage1d;
   ctx->Driver.CopyTexSubImage2D	= _swrast_copy_texsubimage2d;
   ctx->Driver.CopyTexSubImage3D	= _swrast_copy_texsubimage3d;
   ctx->Driver.TestProxyTexImage	= _mesa_test_proxy_teximage;

   ctx->Driver.BindTexture		= mgaDDBindTexture;
   ctx->Driver.CreateTexture		= NULL; /* FIXME: Is this used??? */
   ctx->Driver.DeleteTexture		= mgaDDDeleteTexture;
   ctx->Driver.IsTextureResident	= driIsTextureResident;
   ctx->Driver.PrioritizeTexture	= NULL;
   ctx->Driver.ActiveTexture		= NULL;
   ctx->Driver.UpdateTexturePalette	= NULL;

   ctx->Driver.TexEnv			= mgaDDTexEnv;
   ctx->Driver.TexParameter		= mgaDDTexParameter;

   driInitTextureObjects( ctx, & mmesa->swapped,
                          (DRI_TEXMGR_DO_TEXTURE_2D |
                           DRI_TEXMGR_DO_TEXTURE_RECT) );
@


