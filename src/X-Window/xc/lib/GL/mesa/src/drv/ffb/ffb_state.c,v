head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.04.11;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.04.11;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.31.20;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.57.54;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.17.48;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $XFree86: xc/lib/GL/mesa/src/drv/ffb/ffb_state.c,v 1.2 2001/05/24 16:34:49 dawes Exp $
 *
 * GLX Hardware Device Driver for Sun Creator/Creator3D
 * Copyright (C) 2000 David S. Miller
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * DAVID MILLER, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM, 
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *
 *    David S. Miller <davem@@redhat.com>
 */

#include "types.h"
#include "vbrender.h"

#include <stdio.h>
#include <stdlib.h>

#include "mm.h"
#include "ffb_dd.h"
#include "ffb_span.h"
#include "ffb_depth.h"
#include "ffb_context.h"
#include "ffb_vb.h"
#include "ffb_tris.h"
#include "ffb_lines.h"
#include "ffb_points.h"
#include "ffb_state.h"
#include "ffb_lock.h"
#include "extensions.h"
#include "vb.h"
#include "dd.h"
#include "enums.h"
#include "pipeline.h"
#include "pb.h"

#undef STATE_TRACE

static unsigned int ffbComputeAlphaFunc(GLcontext *ctx)
{
	unsigned int xclip;

#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDAlphaFunc: func(%s) ref(%02x)\n",
		gl_lookup_enum_by_nr(ctx->Color.AlphaFunc),
		ctx->Color.AlphaRef & 0xff);
#endif

	switch (ctx->Color.AlphaFunc) {
	case GL_NEVER: xclip = FFB_XCLIP_TEST_NEVER; break;
	case GL_LESS: xclip = FFB_XCLIP_TEST_LT; break;
	case GL_EQUAL: xclip = FFB_XCLIP_TEST_EQ; break;
	case GL_LEQUAL: xclip = FFB_XCLIP_TEST_LE; break;
	case GL_GREATER: xclip = FFB_XCLIP_TEST_GT; break;
	case GL_NOTEQUAL: xclip = FFB_XCLIP_TEST_NE; break;
	case GL_GEQUAL: xclip = FFB_XCLIP_TEST_GE; break;
	case GL_ALWAYS: xclip = FFB_XCLIP_TEST_ALWAYS; break;

	default:
		return FFB_XCLIP_TEST_ALWAYS | 0x00;
	}

	xclip |= (ctx->Color.AlphaRef & 0xff);

	return xclip;
}

static void ffbDDAlphaFunc(GLcontext *ctx, GLenum func, GLclampf ref)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);

	if (ctx->Color.AlphaEnabled) {
		unsigned int xclip = ffbComputeAlphaFunc(ctx);

		if (fmesa->xclip != xclip) {
			fmesa->xclip = xclip;
			fmesa->state_dirty |= FFB_STATE_XCLIP;
			fmesa->state_fifo_ents += 1;
		}
	}
}

static void ffbDDBlendEquation(GLcontext *ctx, GLenum mode)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);

#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDBlendEquation: mode(%s)\n", gl_lookup_enum_by_nr(mode));
#endif
	if (mode != GL_FUNC_ADD_EXT)
		fmesa->bad_fragment_attrs |= FFB_BADATTR_BLENDEQN;
	else
		fmesa->bad_fragment_attrs &= ~FFB_BADATTR_BLENDEQN;
}

static void ffbDDBlendFunc(GLcontext *ctx, GLenum sfactor, GLenum dfactor)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	unsigned int blendc = 1 << 4;

#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDBlendFunc: sfactor(%s) dfactor(%s)\n",
		gl_lookup_enum_by_nr(sfactor), gl_lookup_enum_by_nr(dfactor));
#endif
	switch (ctx->Color.BlendSrcRGB) {
	case GL_ZERO:
		blendc |= (0 << 0);
		break;

	case GL_ONE:
		blendc |= (1 << 0);
		break;

	case GL_ONE_MINUS_SRC_ALPHA:
		blendc |= (2 << 0);
		break;

	case GL_SRC_ALPHA:
		blendc |= (3 << 0);
		break;

	default:
		if (ctx->Color.BlendEnabled)
			fmesa->bad_fragment_attrs |= FFB_BADATTR_BLENDFUNC;
		return;
	};

	switch (ctx->Color.BlendDstRGB) {
	case GL_ZERO:
		blendc |= (0 << 2);
		break;

	case GL_ONE:
		blendc |= (1 << 2);
		break;

	case GL_ONE_MINUS_SRC_ALPHA:
		blendc |= (2 << 2);
		break;

	case GL_SRC_ALPHA:
		blendc |= (3 << 2);
		break;

	default:
		if (ctx->Color.BlendEnabled)
			fmesa->bad_fragment_attrs |= FFB_BADATTR_BLENDFUNC;
		return;
	};

	if (ctx->Color.BlendEnabled &&
	    ctx->Color.ColorLogicOpEnabled &&
	    ctx->Color.LogicOp != GL_COPY) {
		/* We could avoid this if sfactor is GL_ONE and
		 * dfactor is GL_ZERO.  I do not think that is even
		 * worthwhile to check because if someone is using
		 * blending they use more interesting settings and
		 * also it would add more state tracking to a lot
		 * of the code in this file.
		 */
		fmesa->bad_fragment_attrs |= FFB_BADATTR_BLENDROP;
		return;
	}

	fmesa->bad_fragment_attrs &= ~(FFB_BADATTR_BLENDFUNC |
				       FFB_BADATTR_BLENDROP);

	if (blendc != fmesa->blendc) {
		fmesa->blendc = blendc;
		fmesa->state_dirty |= FFB_STATE_BLEND;
		fmesa->state_fifo_ents += 1;
	}
}

static void ffbDDBlendFuncSeparate(GLcontext *ctx, GLenum sfactorRGB,
				   GLenum dfactorRGB, GLenum sfactorA,
				   GLenum dfactorA)
{
#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDBlendFuncSeparate: sRGB(%s) dRGB(%s) sA(%s) dA(%s)\n",
		gl_lookup_enum_by_nr(sfactorRGB),
		gl_lookup_enum_by_nr(dfactorRGB),
		gl_lookup_enum_by_nr(sfactorA),
		gl_lookup_enum_by_nr(dfactorA));
#endif

	ffbDDBlendFunc(ctx, sfactorRGB, dfactorRGB);
}

static void ffbDDDepthFunc(GLcontext *ctx, GLenum func)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	GLuint cmp;

#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDDepthFunc: func(%s)\n",
		gl_lookup_enum_by_nr(func));
#endif

	switch (func) {
	case GL_NEVER:
		cmp = FFB_CMP_MAGN_NEVER;
		break;
	case GL_ALWAYS:
		cmp = FFB_CMP_MAGN_ALWAYS;
		break;
	case GL_LESS:
		cmp = FFB_CMP_MAGN_LT;
		break;
	case GL_LEQUAL:
		cmp = FFB_CMP_MAGN_LE;
		break;
	case GL_EQUAL:
		cmp = FFB_CMP_MAGN_EQ;
		break;
	case GL_GREATER:
		cmp = FFB_CMP_MAGN_GT;
		break;
	case GL_GEQUAL:
		cmp = FFB_CMP_MAGN_GE;
		break;
	case GL_NOTEQUAL:
		cmp = FFB_CMP_MAGN_NE;
		break;
	default:
		return;
	};

	if (! ctx->Depth.Test)
		cmp = FFB_CMP_MAGN_ALWAYS;

	cmp <<= 16;
	cmp = (fmesa->cmp & ~(0xff<<16)) | cmp;
	if (cmp != fmesa->cmp) {
		fmesa->cmp = cmp;
		fmesa->state_dirty |= FFB_STATE_CMP;
		fmesa->state_fifo_ents += 1;
	}
}

static void ffbDDDepthMask(GLcontext *ctx, GLboolean flag)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	GLuint fbc = fmesa->fbc;
	GLboolean enabled_now;

#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDDepthMask: flag(%d)\n", flag);
#endif

	if ((fbc & FFB_FBC_ZE_MASK) == FFB_FBC_ZE_OFF)
		enabled_now = GL_FALSE;
	else
		enabled_now = GL_TRUE;

	if (flag != enabled_now) {
		fbc &= ~FFB_FBC_ZE_MASK;
		if (flag) {
			fbc |= FFB_FBC_WB_C | FFB_FBC_ZE_ON;
		} else {
			fbc |= FFB_FBC_ZE_OFF;
			fbc &= ~FFB_FBC_WB_C;
		}
		fmesa->fbc = fbc;
		fmesa->state_dirty |= FFB_STATE_FBC;
		fmesa->state_fifo_ents += 1;
	}
}

static void ffbDDStencilFunc(GLcontext *ctx, GLenum func, GLint ref, GLuint mask)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	unsigned int stencil, stencilctl, consty;

	/* We will properly update sw/hw state when stenciling is
	 * enabled.
	 */
	if (! ctx->Stencil.Enabled)
		return;

	stencilctl = fmesa->stencilctl;
	stencilctl &= ~(7 << 16);

	switch (func) {
	case GL_ALWAYS:		stencilctl |= (0 << 16); break;
	case GL_GREATER:	stencilctl |= (1 << 16); break;
	case GL_EQUAL:		stencilctl |= (2 << 16); break;
	case GL_GEQUAL:		stencilctl |= (3 << 16); break;
	case GL_NEVER:		stencilctl |= (4 << 16); break;
	case GL_LEQUAL:		stencilctl |= (5 << 16); break;
	case GL_NOTEQUAL:	stencilctl |= (6 << 16); break;
	case GL_LESS:		stencilctl |= (7 << 16); break;

	default:
		return;
	};

	consty = ref & 0xf;

	stencil = fmesa->stencil;
	stencil &= ~(0xf << 20);
	stencil |= (mask & 0xf) << 20;

	if (fmesa->stencil != stencil ||
	    fmesa->stencilctl != stencilctl ||
	    fmesa->consty != consty) {
		fmesa->stencil = stencil;
		fmesa->stencilctl = stencilctl;
		fmesa->consty = consty;
		fmesa->state_dirty |= FFB_STATE_STENCIL;
		fmesa->state_fifo_ents += 6;
	}
}

static void ffbDDStencilMask(GLcontext *ctx, GLuint mask)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);

	mask &= 0xf;
	if (fmesa->ypmask != mask) {
		fmesa->ypmask = mask;
		fmesa->state_dirty |= FFB_STATE_YPMASK;
		fmesa->state_fifo_ents += 1;
	}
}

static void ffbDDStencilOp(GLcontext *ctx, GLenum fail, GLenum zfail, GLenum zpass)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	unsigned int stencilctl;

	/* We will properly update sw/hw state when stenciling is
	 * enabled.
	 */
	if (! ctx->Stencil.Enabled)
		return;

	stencilctl = fmesa->stencilctl;
	stencilctl &= ~(0xfff00000);

	switch (fail) {
	case GL_ZERO:		stencilctl |= (0 << 28); break;
	case GL_KEEP:		stencilctl |= (1 << 28); break;
	case GL_INVERT:		stencilctl |= (2 << 28); break;
	case GL_REPLACE:	stencilctl |= (3 << 28); break;
	case GL_INCR:		stencilctl |= (4 << 28); break;
	case GL_DECR:		stencilctl |= (5 << 28); break;

	default:
		return;
	};

	switch (zfail) {
	case GL_ZERO:		stencilctl |= (0 << 24); break;
	case GL_KEEP:		stencilctl |= (1 << 24); break;
	case GL_INVERT:		stencilctl |= (2 << 24); break;
	case GL_REPLACE:	stencilctl |= (3 << 24); break;
	case GL_INCR:		stencilctl |= (4 << 24); break;
	case GL_DECR:		stencilctl |= (5 << 24); break;

	default:
		return;
	};

	switch (zpass) {
	case GL_ZERO:		stencilctl |= (0 << 20); break;
	case GL_KEEP:		stencilctl |= (1 << 20); break;
	case GL_INVERT:		stencilctl |= (2 << 20); break;
	case GL_REPLACE:	stencilctl |= (3 << 20); break;
	case GL_INCR:		stencilctl |= (4 << 20); break;
	case GL_DECR:		stencilctl |= (5 << 20); break;

	default:
		return;
	};

	if (fmesa->stencilctl != stencilctl) {
		fmesa->stencilctl = stencilctl;
		fmesa->state_dirty |= FFB_STATE_STENCIL;
		fmesa->state_fifo_ents += 6;
	}
}

void ffbDDScissor(GLcontext *ctx, GLint cx, GLint cy,
		  GLsizei cw, GLsizei ch)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	__DRIdrawablePrivate *dPriv = fmesa->driDrawable;
	GLint x, y;
	unsigned int vcmin, vcmax;

#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDScissor: x(%x) y(%x) w(%x) h(%x)\n",
		cx, cy, cw, ch);
#endif
	x = cx + dPriv->x;
	y = dPriv->y + (cy - ch);
	vcmin = ((y & 0xffff) << 16) | (x & 0xffff);
	vcmax = ((((y + ch) & 0xffff) << 16) |
		 (((x + cw) & 0xffff)));
	if (fmesa->vclipmin != vcmin ||
	    fmesa->vclipmax != vcmax) {
		fmesa->vclipmin = vcmin;
		fmesa->vclipmax = vcmax;
		fmesa->state_dirty |= FFB_STATE_CLIP;
		fmesa->state_fifo_ents += 4 + (4 * 2);
	}
}

static GLboolean ffbDDSetDrawBuffer(GLcontext *ctx, GLenum buffer)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	unsigned int fbc = fmesa->fbc;

#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDSetDrawBuffer: mode(%s)\n",
		gl_lookup_enum_by_nr(buffer));
#endif
	fbc &= ~(FFB_FBC_WB_AB);
	switch (buffer) {
	case GL_FRONT_LEFT:
		if (fmesa->back_buffer == 0)
			fbc |= FFB_FBC_WB_B;
		else
			fbc |= FFB_FBC_WB_A;
		break;

	case GL_BACK_LEFT:
		if (fmesa->back_buffer == 0)
			fbc |= FFB_FBC_WB_A;
		else
			fbc |= FFB_FBC_WB_B;
		break;

	case GL_FRONT_AND_BACK:
		fbc |= FFB_FBC_WB_AB;
		break;

	default:
		return GL_FALSE;
	};

	if (fbc != fmesa->fbc) {
		fmesa->fbc = fbc;
		fmesa->state_dirty |= FFB_STATE_FBC;
		fmesa->state_fifo_ents += 1;
	}

	return GL_TRUE;
}

static void ffbDDSetReadBuffer(GLcontext *ctx, GLframebuffer *colorBuffer,
			       GLenum buffer)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	unsigned int fbc = fmesa->fbc;

#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDSetReadBuffer: mode(%s)\n",
		gl_lookup_enum_by_nr(buffer));
#endif
	fbc &= ~(FFB_FBC_RB_MASK);
	switch (buffer) {
	case GL_FRONT_LEFT:
		if (fmesa->back_buffer == 0)
			fbc |= FFB_FBC_RB_B;
		else
			fbc |= FFB_FBC_RB_A;
		break;

	case GL_BACK_LEFT:
		if (fmesa->back_buffer == 0)
			fbc |= FFB_FBC_RB_A;
		else
			fbc |= FFB_FBC_RB_B;
		break;

	default:
		return;
	};

	if (fbc != fmesa->fbc) {
		fmesa->fbc = fbc;
		fmesa->state_dirty |= FFB_STATE_FBC;
		fmesa->state_fifo_ents += 1;
	}
}

static void ffbDDSetColor(GLcontext *ctx, GLubyte r, GLubyte g, GLubyte b, GLubyte a)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);

	fmesa->MonoColor = ((r <<  0) |
			    (g << 8) |
			    (b << 16));
}

static void ffbDDClearColor(GLcontext *ctx, GLubyte r, GLubyte g, GLubyte b, GLubyte a)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);

	fmesa->clear_pixel = ((r << 0) |
			      (g << 8) |
			      (b << 16));
}

static void ffbDDClearDepth(GLcontext *ctx, GLclampd depth)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);

	fmesa->clear_depth = Z_FROM_MESA(depth * 4294967295.0f);
}

static void ffbDDClearStencil(GLcontext *ctx, GLint stencil)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);

	fmesa->clear_stencil = stencil & 0xf;
}

static void ffbDDReducedPrimitiveChange(GLcontext *ctx, GLenum prim)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	GLuint drawop, fbc, ppc;
	int do_sw = 0;

	drawop = fmesa->drawop;
	fbc = fmesa->fbc;
	ppc = fmesa->ppc & ~(FFB_PPC_ZS_MASK | FFB_PPC_CS_MASK);

#ifdef STATE_TRACE
	fprintf(stderr,
		"ffbDDReducedPrimitiveChange: prim(%d) ", prim);
#endif
	switch(prim) {
	case GL_POINT:
	case GL_POINTS:
#ifdef STATE_TRACE
		fprintf(stderr, "GL_POINTS ");
#endif
		if (ctx->IndirectTriangles & DD_POINT_SW_RASTERIZE) {
			do_sw = 1;
			break;
		}

		if (ctx->TriangleCaps & DD_POINT_SIZE) {
			ppc |= FFB_PPC_ZS_CONST | FFB_PPC_CS_CONST;
			drawop = FFB_DRAWOP_TRIANGLE;
		} else {
			if (ctx->Point.SmoothFlag) {
				ppc |= (FFB_PPC_ZS_VAR | FFB_PPC_CS_CONST);
				drawop = FFB_DRAWOP_AADOT;
			} else {
				ppc |= (FFB_PPC_ZS_CONST | FFB_PPC_CS_CONST);
				drawop = FFB_DRAWOP_DOT;
			}
		}
		break;

	case GL_LINE:
	case GL_LINES:
#ifdef STATE_TRACE
		fprintf(stderr, "GL_LINES ");
#endif
		if (ctx->IndirectTriangles & DD_LINE_SW_RASTERIZE) {
			do_sw = 1;
			break;
		}

		if (ctx->TriangleCaps & DD_FLATSHADE) {
			ppc |= FFB_PPC_ZS_VAR | FFB_PPC_CS_CONST;
		} else {
			ppc |= FFB_PPC_ZS_VAR | FFB_PPC_CS_VAR;
		}
		if (ctx->TriangleCaps & DD_LINE_WIDTH) {
			drawop = FFB_DRAWOP_TRIANGLE;
		} else {
			if (ctx->Line.SmoothFlag)
				drawop = FFB_DRAWOP_AALINE;
			else
				drawop = FFB_DRAWOP_DDLINE;
		}
		break;

	case GL_POLYGON:
#ifdef STATE_TRACE
		fprintf(stderr, "GL_POLYGON ");
#endif
		if (ctx->IndirectTriangles & DD_TRI_SW_RASTERIZE) {
			do_sw = 1;
			break;
		}

		ppc &= ~FFB_PPC_APE_MASK;
		if (ctx->Polygon.StippleFlag)
			ppc |= FFB_PPC_APE_ENABLE;
		else
			ppc |= FFB_PPC_APE_DISABLE;

		if (ctx->TriangleCaps & DD_FLATSHADE) {
			ppc |= FFB_PPC_ZS_VAR | FFB_PPC_CS_CONST;
		} else {
			ppc |= FFB_PPC_ZS_VAR | FFB_PPC_CS_VAR;
		}
		drawop = FFB_DRAWOP_TRIANGLE;
		break;

	default:
#ifdef STATE_TRACE
		fprintf(stderr, "unknown %d!\n", prim);
#endif
		return;
	};

#ifdef STATE_TRACE
	fprintf(stderr, "do_sw(%d) ", do_sw);
#endif
	if (do_sw != 0) {
		fbc &= ~(FFB_FBC_WB_C);
		fbc &= ~(FFB_FBC_ZE_MASK | FFB_FBC_RGBE_MASK);
		fbc |=   FFB_FBC_ZE_OFF  | FFB_FBC_RGBE_MASK;
		ppc &= ~(FFB_PPC_XS_MASK | FFB_PPC_ABE_MASK |
			 FFB_PPC_DCE_MASK | FFB_PPC_APE_MASK);
		ppc |=  (FFB_PPC_ZS_VAR | FFB_PPC_CS_VAR | FFB_PPC_XS_WID |
			 FFB_PPC_ABE_DISABLE | FFB_PPC_DCE_DISABLE |
			 FFB_PPC_APE_DISABLE);
	} else {
		fbc |= FFB_FBC_WB_C;
		fbc &= ~(FFB_FBC_RGBE_MASK);
		fbc |=   FFB_FBC_RGBE_MASK;
		ppc &= ~(FFB_PPC_ABE_MASK | FFB_PPC_XS_MASK);
		if (ctx->Color.BlendEnabled) {
			ppc |= FFB_PPC_ABE_ENABLE | FFB_PPC_XS_VAR;
		} else {
			ppc |= FFB_PPC_ABE_DISABLE | FFB_PPC_XS_WID;
		}
	}
#ifdef STATE_TRACE
	fprintf(stderr, "fbc(%08x) ppc(%08x)\n", fbc, ppc);
#endif

	FFBFifo(fmesa, 4);
	if (fmesa->drawop != drawop)
		fmesa->regs->drawop = fmesa->drawop = drawop;
	if (fmesa->fbc != fbc)
		fmesa->regs->fbc = fmesa->fbc = fbc;
	if (fmesa->ppc != ppc)
		fmesa->regs->ppc = fmesa->ppc = ppc;
	if (do_sw != 0) {
		fmesa->regs->cmp =
			(fmesa->cmp & ~(0xff<<16)) | (0x80 << 16);
	} else
		fmesa->regs->cmp = fmesa->cmp;

	/* Flush the vertex cache. */
	fmesa->vtx_cache[0] = fmesa->vtx_cache[1] =
		fmesa->vtx_cache[2] = fmesa->vtx_cache[3] = NULL;
}

/* XXX Actually, should I be using FBC controls for this? -DaveM */
static GLboolean ffbDDColorMask(GLcontext *ctx,
				GLboolean r, GLboolean g,
				GLboolean b, GLboolean a)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	unsigned int new_pmask = 0x0;

#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDColorMask: r(%d) g(%d) b(%d) a(%d)\n",
		r, g, b, a);
#endif
	if (r)
		new_pmask |= 0x000000ff;
	if (g)
		new_pmask |= 0x0000ff00;
	if (b)
		new_pmask |= 0x00ff0000;

	if (fmesa->pmask != new_pmask) {
		fmesa->pmask = new_pmask;
		fmesa->state_dirty |= FFB_STATE_PMASK;
		fmesa->state_fifo_ents += 1;
	}

	return GL_TRUE;
}

static GLboolean ffbDDLogicOp(GLcontext *ctx, GLenum op)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	unsigned int rop;

#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDLogicOp: op(%s)\n",
		gl_lookup_enum_by_nr(op));
#endif
	switch (op) {
	case GL_CLEAR: rop = FFB_ROP_ZERO; break;
	case GL_SET: rop = FFB_ROP_ONES; break;
	case GL_COPY: rop = FFB_ROP_NEW; break;
	case GL_AND: rop = FFB_ROP_NEW_AND_OLD; break;
	case GL_NAND: rop = FFB_ROP_NEW_AND_NOLD; break;
	case GL_OR: rop = FFB_ROP_NEW_OR_OLD; break;
	case GL_NOR: rop = FFB_ROP_NEW_OR_NOLD; break;
	case GL_XOR: rop = FFB_ROP_NEW_XOR_OLD; break;
	case GL_NOOP: rop = FFB_ROP_OLD; break;
	case GL_COPY_INVERTED: rop = FFB_ROP_NNEW; break;
	case GL_INVERT: rop = FFB_ROP_NOLD; break;
	case GL_EQUIV: rop = FFB_ROP_NNEW_XOR_NOLD; break;
	case GL_AND_REVERSE: rop = FFB_ROP_NEW_AND_NOLD; break;
	case GL_AND_INVERTED: rop = FFB_ROP_NNEW_AND_OLD; break;
	case GL_OR_REVERSE: rop = FFB_ROP_NEW_OR_NOLD; break;
	case GL_OR_INVERTED: rop = FFB_ROP_NNEW_OR_OLD; break;

	default:
		return GL_FALSE;
	};

	rop |= fmesa->rop & ~0xff;
	if (rop != fmesa->rop) {
		fmesa->rop = rop;
		fmesa->state_dirty |= FFB_STATE_ROP;
		fmesa->state_fifo_ents += 1;

		if (op == GL_COPY)
			fmesa->bad_fragment_attrs &= ~FFB_BADATTR_BLENDROP;
	}

	return GL_TRUE;
}

#if 0
/* XXX Also need to track near/far just like 3dfx driver.
 * XXX
 * XXX Actually, that won't work, because the 3dfx chip works by
 * XXX having 1/w coordinates fed to it for each primitive, and
 * XXX it uses this to index it's 64 entry fog table.
 */
static void ffb_fog_linear(GLcontext *ctx, ffbContextPtr fmesa)
{
	GLfloat c = ctx->ProjectionMatrix.m[10];
	GLfloat d = ctx->ProjectionMatrix.m[14];
	GLfloat tz = ctx->Viewport.WindowMap.m[MAT_TZ];
	GLfloat szInv = 1.0F / ctx->Viewport.WindowMap.m[MAT_SZ];
	GLfloat fogEnd = ctx->Fog.End;
	GLfloat fogScale = 1.0F / (ctx->Fog.End - ctx->Fog.Start);
	GLfloat ndcz;
	GLfloat eyez;
	GLfloat Zzero, Zone;
	unsigned int zb, zf;

	/* Compute the Z at which f reaches 0.0, this is the full
	 * saturation point.
	 *
	 * Thus compute Z (as seen by the chip during rendering),
	 * such that:
	 *
	 *	0.0 = (fogEnd - eyez) * fogScale
	 *
	 * fogScale is usually not zero, thus we are looking for:
	 *
	 *	fogEnd = eyez
	 *
	 *	fogEnd = -d / (c + ((Z - tz) * szInv))
	 *	fogEnd * (c + ((Z - tz) * szInv)) = -d
	 *	(c + ((Z - tz) * szInv)) = -d / fogEnd
	 *	(Z - tz) * szInv = (-d / fogEnd) - c
	 *	(Z - tz) = ((-d / fogEnd) - c) / szInv
	 *	Z = (((-d / fogEnd) - c) / szInv) + tz
	 */
	Zzero = (((-d / fogEnd) - c) / szInv) + tz;

	/* Compute the Z at which f reaches 1.0, this is where
	 * the incoming frag's full intensity is shown.  This
	 * equation is:
	 *
	 *	1.0 = (fogEnd - eyez)
	 *
	 * We are looking for:
	 *
	 *	1.0 + eyez = fogEnd
	 *
	 *	1.0 + (-d / (c + ((Z - tz) * szInv))) = fogEnd
	 *	-d / (c + ((Z - tz) * szInv)) = fogEnd - 1.0
	 *	-d / (FogEnd - 1.0) = (c + ((Z - tz) * szInv))
	 *	(-d / (fogEnd - 1.0)) - c = ((Z - tz) * szInv)
	 *	((-d / (fogEnd - 1.0)) - c) / szInv = (Z - tz)
	 *	(((-d / (fogEnd - 1.0)) - c) / szInv) + tz = Z
	 */
	Zone = (((-d / (fogEnd - 1.0)) - c) / szInv) + tz;

	/* FFB's Zfront must be less than Zback, thus we may have
	 * to invert Sf/Sb to satisfy this constraint.
	 */
	if (Zzero < Zone) {
		sf = 0.0;
		sb = 1.0;
		zf = Z_FROM_MESA(Zzero);
		zb = Z_FROM_MESA(Zone);
	} else {
		sf = 1.0;
		sb = 0.0;
		zf = Z_FROM_MESA(Zone);
		zb = Z_FROM_MESA(Zzero);
	}
}
#endif

static void ffbDDFogfv(GLcontext *ctx, GLenum pname, const GLfloat *param)
{
#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDFogfv: pname(%s)\n", gl_lookup_enum_by_nr(pname));
#endif
}

static void ffbDDLineStipple(GLcontext *ctx, GLint factor, GLushort pattern)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);

#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDLineStipple: factor(%d) pattern(%04x)\n",
		factor, pattern);
#endif
	if (ctx->Line.StippleFlag) {
		factor = ctx->Line.StippleFactor;
		pattern = ctx->Line.StipplePattern;
		if ((GLuint) factor > 15) {
			ctx->Driver.TriangleCaps &= ~DD_LINE_STIPPLE;
			fmesa->lpat = FFB_LPAT_BAD;
		} else {
			ctx->Driver.TriangleCaps |= DD_LINE_STIPPLE;
			fmesa->lpat = ((factor << FFB_LPAT_SCALEVAL_SHIFT) |
				       (0 << FFB_LPAT_PATLEN_SHIFT) |
				       ((pattern & 0xffff) << FFB_LPAT_PATTERN_SHIFT));
		}
	} else {
		fmesa->lpat = 0;
	}
}

void ffbXformAreaPattern(ffbContextPtr fmesa, const GLubyte *mask)
{
	__DRIdrawablePrivate *dPriv = fmesa->driDrawable;
	int i, lines, xoff;

	lines = 0;
	i = (dPriv->y + dPriv->h) & (32 - 1);
	xoff = dPriv->x & (32 - 1);
	while (lines++ < 32) {
		GLuint raw =
			(((GLuint)mask[0] << 24) |
			 ((GLuint)mask[1] << 16) |
			 ((GLuint)mask[2] <<  8) |
			 ((GLuint)mask[3] <<  0));

		fmesa->pattern[i] =
			(raw << xoff) | (raw >> (32 - xoff));
		i = (i - 1) & (32 - 1);
		mask += 4;
	}

	fmesa->state_dirty |= FFB_STATE_APAT;
	fmesa->state_fifo_ents += 32;
}

static void ffbDDPolygonStipple(GLcontext *ctx, const GLubyte *mask)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);

#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDPolygonStipple: state(%d)\n",
		ctx->Polygon.StippleFlag);
#endif
	if (ctx->Polygon.StippleFlag) {
		ctx->Driver.TriangleCaps |= DD_TRI_STIPPLE;
	} else {
		ctx->Driver.TriangleCaps &= ~DD_TRI_STIPPLE;
	}
	ffbXformAreaPattern(fmesa, mask);
}

static void ffbDDEnable(GLcontext *ctx, GLenum cap, GLboolean state)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	unsigned int tmp;

#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDEnable: %s state(%d)\n",
		gl_lookup_enum_by_nr(cap), state);
#endif
	switch (cap) {
	case GL_ALPHA_TEST:
		if (state)
			tmp = ffbComputeAlphaFunc(ctx);
		else
			tmp = FFB_XCLIP_TEST_ALWAYS;

		if (tmp != fmesa->xclip) {
			fmesa->xclip = tmp;
			fmesa->state_dirty |= FFB_STATE_XCLIP;
			fmesa->state_fifo_ents += 1;
		}
		break;

	case GL_BLEND:
		tmp = (fmesa->ppc & ~FFB_PPC_ABE_MASK);
		if (state) {
			tmp |= FFB_PPC_ABE_ENABLE;
		} else {
			tmp |= FFB_PPC_ABE_DISABLE;
		}
		if (fmesa->ppc != tmp) {
			fmesa->ppc = tmp;
			fmesa->state_dirty |= FFB_STATE_PPC;
			fmesa->state_fifo_ents += 1;
			ffbDDBlendFunc(ctx, 0, 0);
		}
		break;

	case GL_DEPTH_TEST:
		if (state)
			tmp = 0x0fffffff;
		else
			tmp = 0x00000000;
		if (tmp != fmesa->magnc) {
			unsigned int fbc = fmesa->fbc;
			fbc &= ~FFB_FBC_ZE_MASK;
			if (state)
				fbc |= FFB_FBC_ZE_ON;
			else
				fbc |= FFB_FBC_ZE_OFF;
			fmesa->fbc = fbc;
			ffbDDDepthFunc(ctx, ctx->Depth.Func);
			fmesa->magnc = tmp;
			fmesa->state_dirty |= FFB_STATE_MAGNC | FFB_STATE_FBC;
			fmesa->state_fifo_ents += 2;
		}
		break;

	case GL_SCISSOR_TEST:
		tmp = fmesa->ppc & ~FFB_PPC_VCE_MASK;
		if (state) {
			ffbDDScissor(ctx, ctx->Scissor.X, ctx->Scissor.Y,
				     ctx->Scissor.Width, ctx->Scissor.Height);
			tmp |= FFB_PPC_VCE_2D;
	        } else {
			tmp |= FFB_PPC_VCE_DISABLE;
		}
		break;

	case GL_STENCIL_TEST:
		if (!(fmesa->ffb_sarea->flags & FFB_DRI_FFB2PLUS)) {
			if (state)
				fmesa->bad_fragment_attrs |= FFB_BADATTR_STENCIL;
			else
				fmesa->bad_fragment_attrs &= ~FFB_BADATTR_STENCIL;
			break;
		}

		tmp = fmesa->fbc & ~FFB_FBC_YE_MASK;
		if (state) {
			ffbDDStencilFunc(ctx,
					 ctx->Stencil.Function,
					 ctx->Stencil.Ref,
					 ctx->Stencil.ValueMask);
			ffbDDStencilMask(ctx, ctx->Stencil.WriteMask);
			ffbDDStencilOp(ctx,
				       ctx->Stencil.FailFunc,
				       ctx->Stencil.ZFailFunc,
				       ctx->Stencil.ZPassFunc);
			tmp |= FFB_FBC_YE_MASK;
		} else {
			fmesa->stencil		= 0xf0000000;
			fmesa->stencilctl	= 0x33300000;
			fmesa->state_dirty |= FFB_STATE_STENCIL;
			fmesa->state_fifo_ents += 6;
			tmp |= FFB_FBC_YE_OFF;
		}
		if (tmp != fmesa->fbc) {
			fmesa->fbc = tmp;
			fmesa->state_dirty |= FFB_STATE_FBC;
			fmesa->state_fifo_ents += 1;
		}
		break;

	case GL_FOG:
		/* Until I implement the fog support... */
		if (state)
			fmesa->bad_fragment_attrs |= FFB_BADATTR_FOG;
		else
			fmesa->bad_fragment_attrs &= ~FFB_BADATTR_FOG;
		break;

	case GL_LINE_STIPPLE:
		if (! state)
			fmesa->lpat = 0;
		else
			ffbDDLineStipple(ctx,
					 ctx->Line.StippleFactor,
					 ctx->Line.StipplePattern);
		break;

	case GL_POLYGON_STIPPLE:
		/* Do nothing, we interrogate the state during
		 * reduced primitive changes.  Since our caller
		 * will set NEW_POLYGON in the ctx NewState this
		 * will cause the driver rasterization functions
		 * to be reevaluated, which will cause us to force
		 * a reduced primitive change next rendering pass
		 * and it all works out.
		 */
		break;

	default:
		break;
	};
}

void ffbSyncHardware(ffbContextPtr fmesa)
{
	ffb_fbcPtr ffb = fmesa->regs;
	unsigned int dirty;
	int i;

	FFBFifo(fmesa, fmesa->state_fifo_ents);

	dirty = fmesa->state_dirty;
	if (dirty & (FFB_STATE_FBC | FFB_STATE_PPC | FFB_STATE_DRAWOP |
		     FFB_STATE_ROP | FFB_STATE_LPAT | FFB_STATE_WID)) {
		if (dirty & FFB_STATE_FBC)
			ffb->fbc = fmesa->fbc;
		if (dirty & FFB_STATE_PPC)
			ffb->ppc = fmesa->ppc;
		if (dirty & FFB_STATE_DRAWOP)
			ffb->drawop = fmesa->drawop;
		if (dirty & FFB_STATE_ROP)
			ffb->rop = fmesa->rop;
		if (dirty & FFB_STATE_LPAT)
			ffb->rop = fmesa->lpat;
		if (dirty & FFB_STATE_WID)
			ffb->wid = fmesa->wid;
	}
	if (dirty & (FFB_STATE_PMASK | FFB_STATE_XPMASK | FFB_STATE_YPMASK |
		     FFB_STATE_ZPMASK | FFB_STATE_XCLIP | FFB_STATE_CMP |
		     FFB_STATE_MATCHAB | FFB_STATE_MAGNAB | FFB_STATE_MATCHC |
		     FFB_STATE_MAGNC)) {
		if (dirty & FFB_STATE_PMASK)
			ffb->pmask = fmesa->pmask;
		if (dirty & FFB_STATE_XPMASK)
			ffb->xpmask = fmesa->xpmask;
		if (dirty & FFB_STATE_YPMASK)
			ffb->ypmask = fmesa->ypmask;
		if (dirty & FFB_STATE_ZPMASK)
			ffb->zpmask = fmesa->zpmask;
		if (dirty & FFB_STATE_XCLIP)
			ffb->xclip = fmesa->xclip;
		if (dirty & FFB_STATE_CMP)
			ffb->cmp = fmesa->cmp;
		if (dirty & FFB_STATE_MATCHAB)
			ffb->matchab = fmesa->matchab;
		if (dirty & FFB_STATE_MAGNAB)
			ffb->magnab = fmesa->magnab;
		if (dirty & FFB_STATE_MATCHC)
			ffb->matchc = fmesa->matchc;
		if (dirty & FFB_STATE_MAGNC)
			ffb->magnc = fmesa->magnc;
	}

	if (dirty & FFB_STATE_DCUE) {
		ffb->dcss = fmesa->dcss;
		ffb->dcsf = fmesa->dcsf;
		ffb->dcsb = fmesa->dcsb;
		ffb->dczf = fmesa->dczf;
		ffb->dczb = fmesa->dczb;
		if (fmesa->ffb_sarea->flags & (FFB_DRI_FFB2 | FFB_DRI_FFB2PLUS)) {
			ffb->dcss1 = fmesa->dcss1;
			ffb->dcss2 = fmesa->dcss2;
			ffb->dcss3 = fmesa->dcss3;
			ffb->dcs2  = fmesa->dcs2;
			ffb->dcs3  = fmesa->dcs3;
			ffb->dcs4  = fmesa->dcs4;
			ffb->dcd2  = fmesa->dcd2;
			ffb->dcd3  = fmesa->dcd3;
			ffb->dcd4  = fmesa->dcd4;
		}
	}

	if (dirty & FFB_STATE_BLEND) {
		ffb->blendc  = fmesa->blendc;
		ffb->blendc1 = fmesa->blendc1;
		ffb->blendc2 = fmesa->blendc2;
	}

	if (dirty & FFB_STATE_CLIP) {
		ffb->vclipmin  = fmesa->vclipmin;
		ffb->vclipmax  = fmesa->vclipmax;
		ffb->vclipzmin = fmesa->vclipzmin;
		ffb->vclipzmax = fmesa->vclipzmax;
		for (i = 0; i < 4; i++) {
			ffb->auxclip[i].min = fmesa->aux_clips[i].min;
			ffb->auxclip[i].max = fmesa->aux_clips[i].max;
		}
	}

	if ((dirty & FFB_STATE_STENCIL) &&
	    (fmesa->ffb_sarea->flags & FFB_DRI_FFB2PLUS)) {
		ffb->stencil    = fmesa->stencil;
		ffb->stencilctl = fmesa->stencilctl;
		ffb->fbc = FFB_FBC_WB_C;
		ffb->rawstencilctl = (fmesa->stencilctl | (1 << 19));
		ffb->fbc = fmesa->fbc;
		ffb->consty = fmesa->consty;
	}

	if (dirty & FFB_STATE_APAT) {
		for (i = 0; i < 32; i++)
			ffb->pattern[i] = fmesa->pattern[i];
	}

	fmesa->state_dirty = 0;
	fmesa->state_fifo_ents = 0;
	fmesa->ffbScreen->rp_active = 1;
}

static void ffbDDRenderStart(GLcontext *ctx)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);

	LOCK_HARDWARE(fmesa);
	fmesa->hw_locked = 1;

	if (fmesa->state_dirty != 0)
		ffbSyncHardware(fmesa);
}

static void ffbDDRenderFinish(GLcontext *ctx)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);

	UNLOCK_HARDWARE(fmesa);
	fmesa->hw_locked = 0;
}

#define INTERESTED (~(NEW_MODELVIEW|NEW_PROJECTION|\
                      NEW_TEXTURE_MATRIX|\
                      NEW_USER_CLIP|NEW_CLIENT_STATE|\
                      NEW_TEXTURE_ENABLE))

static void ffbDDUpdateState(GLcontext *ctx)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	unsigned int flags;

	if (ctx->NewState & INTERESTED) {
		if (fmesa->SWrender ||
		    fmesa->bad_fragment_attrs != 0) {
			/* Force SW rendering. */
			fmesa->PointsFunc = NULL;
			fmesa->LineFunc = NULL;
			fmesa->TriangleFunc = NULL;
			fmesa->QuadFunc = NULL;
		} else {
			ffbDDChooseTriRenderState(ctx);
			ffbDDChooseLineRenderState(ctx);
			ffbDDChoosePointRenderState(ctx);
		}

		if (0)
			gl_print_tri_caps("tricaps", ctx->TriangleCaps);

		ffbChooseRasterSetupFunc(ctx);

		/* Force a reduced primitive change next rendering
		 * pass.
		 */
		ctx->PB->primitive = GL_POLYGON + 1;
	}

#if 0
	/* When the modelview matrix changes, this changes what
	 * the eye coordinates will be so we have to recompute
	 * the depth cueing parameters.
	 *
	 * XXX DD_HAVE_HARDWARE_FOG.
	 */
	if (ctx->Fog.Enabled && (ctx->NewState & NEW_MODELVIEW))
		ffb_update_fog();
#endif

	/* XXX It may be possible to eliminate all of Mesa's sw clip
	 * XXX processing using the hw clip registers we have.  If
	 * XXX this is correct, it is just a matter of verifying the
	 * XXX FFB coordinate overflow rules in ffb_vb.c and if they
	 * XXX are not violated we clear CLIP_MASK_ACTIVE in
	 * XXX VB->CullMode.
	 * XXX
	 * XXX We would specify the xyz min/max values in the primary
	 * XXX viewport clip registers, and the user specified
	 * XXX scissor clip can go into one of the auxilliary viewport
	 * XXX clips.
	 */
	flags = ctx->IndirectTriangles;
	if (fmesa->PointsFunc != NULL) {
		ctx->Driver.PointsFunc = fmesa->PointsFunc;
		flags &= ~DD_POINT_SW_RASTERIZE;
	}
	if (fmesa->LineFunc != NULL) {
		ctx->Driver.LineFunc = fmesa->LineFunc;
		flags &= ~DD_LINE_SW_RASTERIZE;
	}
	if (fmesa->TriangleFunc != NULL) {
		ctx->Driver.TriangleFunc = fmesa->TriangleFunc;
		ctx->Driver.QuadFunc = fmesa->QuadFunc;
		flags &= ~(DD_TRI_SW_RASTERIZE |
			   DD_QUAD_SW_RASTERIZE);
	}
	ctx->IndirectTriangles = flags;
}

void ffbDDInitStateFuncs(GLcontext *ctx)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);

	ctx->Driver.UpdateState = ffbDDUpdateState;
	ctx->Driver.Enable = ffbDDEnable;
	ctx->Driver.LightModelfv = NULL;
	ctx->Driver.AlphaFunc = ffbDDAlphaFunc;
	ctx->Driver.BlendEquation = ffbDDBlendEquation;
	ctx->Driver.BlendFunc = ffbDDBlendFunc;
	ctx->Driver.BlendFuncSeparate = ffbDDBlendFuncSeparate;
	ctx->Driver.DepthFunc = ffbDDDepthFunc;
	ctx->Driver.DepthMask = ffbDDDepthMask;
	ctx->Driver.Fogfv = ffbDDFogfv;
	ctx->Driver.LineStipple = ffbDDLineStipple;
	ctx->Driver.PolygonStipple = ffbDDPolygonStipple;
	ctx->Driver.Scissor = ffbDDScissor;
	ctx->Driver.CullFace = NULL;
	ctx->Driver.FrontFace = NULL;
	ctx->Driver.ColorMask = ffbDDColorMask;
	ctx->Driver.LogicOp = ffbDDLogicOp;
	ctx->Driver.ReducedPrimitiveChange = ffbDDReducedPrimitiveChange;
	ctx->Driver.RenderStart = ffbDDRenderStart; 
	ctx->Driver.RenderFinish = ffbDDRenderFinish; 

	if (fmesa->ffb_sarea->flags & FFB_DRI_FFB2PLUS) {
		ctx->Driver.StencilFunc = ffbDDStencilFunc;
		ctx->Driver.StencilMask = ffbDDStencilMask;
		ctx->Driver.StencilOp = ffbDDStencilOp;
	} else {
		ctx->Driver.StencilFunc = NULL;
		ctx->Driver.StencilMask = NULL;
		ctx->Driver.StencilOp = NULL;
	}

	ctx->Driver.SetDrawBuffer = ffbDDSetDrawBuffer;
	ctx->Driver.SetReadBuffer = ffbDDSetReadBuffer;
	ctx->Driver.Color = ffbDDSetColor;
	ctx->Driver.ClearColor = ffbDDClearColor;
	ctx->Driver.ClearDepth = ffbDDClearDepth;
	ctx->Driver.ClearStencil = ffbDDClearStencil;
	ctx->Driver.Dither = NULL;

	/* We will support color index modes later... -DaveM */
	ctx->Driver.Index = 0;
	ctx->Driver.ClearIndex = 0;
	ctx->Driver.IndexMask = 0;
}

void ffbDDInitContextHwState(GLcontext *ctx)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	int fifo_count = 0;
	int i;

	fmesa->hw_locked = 0;

	fmesa->bad_fragment_attrs = 0;
	fmesa->state_dirty = FFB_STATE_ALL;

	fifo_count = 1;
	fmesa->fbc = (FFB_FBC_WE_FORCEON | FFB_FBC_WM_COMBINED |
		      FFB_FBC_SB_BOTH | FFB_FBC_ZE_MASK |
		      FFB_FBC_YE_OFF | FFB_FBC_XE_OFF |
		      FFB_FBC_RGBE_MASK);
	if (ctx->Visual->DBflag) {
		/* Buffer B is the initial back buffer. */
		fmesa->back_buffer = 1;
		fmesa->fbc |= FFB_FBC_WB_BC | FFB_FBC_RB_B;
	} else {
		fmesa->back_buffer = 0;
		fmesa->fbc |= FFB_FBC_WB_A | FFB_FBC_RB_A;
	}

	fifo_count += 1;
	fmesa->ppc = (FFB_PPC_ACE_DISABLE | FFB_PPC_DCE_DISABLE |
		      FFB_PPC_ABE_DISABLE | FFB_PPC_VCE_DISABLE |
		      FFB_PPC_APE_DISABLE | FFB_PPC_TBE_OPAQUE |
		      FFB_PPC_ZS_CONST | FFB_PPC_YS_CONST |
		      FFB_PPC_XS_WID | FFB_PPC_CS_VAR);

	fifo_count += 3;
	fmesa->drawop = FFB_DRAWOP_RECTANGLE;

	/* GL_COPY is the default LogicOp. */
	fmesa->rop = (FFB_ROP_NEW << 16) | (FFB_ROP_NEW << 8) | FFB_ROP_NEW;

	/* No line patterning enabled. */
	fmesa->lpat = 0x00000000;

	/* We do not know the WID value until the first context switch. */
	fifo_count += 1;
	fmesa->wid = ~0;

	fifo_count += 5;

	/* ColorMask, all enabled. */
	fmesa->pmask  = 0xffffffff;

	fmesa->xpmask = 0x000000ff;
	fmesa->ypmask = 0x0000000f;
	fmesa->zpmask = 0x0fffffff;

	/* AlphaFunc GL_ALWAYS, AlphaRef 0 */
	fmesa->xclip  = FFB_XCLIP_TEST_ALWAYS | 0x00;

	/* This sets us up to use WID clipping (so the DRI clipping
	 * rectangle is unneeded by us).  All other match and magnitude
	 * tests are set to pass.
	 */
	fifo_count += 5;
	fmesa->cmp = ((FFB_CMP_MATCH_ALWAYS << 24) |	/* MATCH C  */
		      (FFB_CMP_MAGN_ALWAYS  << 16) |	/* MAGN  C  */
		      (FFB_CMP_MATCH_EQ     <<  8) |	/* MATCH AB */
		      (FFB_CMP_MAGN_ALWAYS  <<  0));	/* MAGN  AB */
	fmesa->matchab = 0xff000000;
	fmesa->magnab  = 0x00000000;
	fmesa->matchc  = 0x00000000;
	fmesa->magnc   = 0x00000000;

	/* Depth cue parameters, all zeros to start. */
	fifo_count += 14;
	fmesa->dcss  = 0x00000000;
	fmesa->dcsf  = 0x00000000;
	fmesa->dcsb  = 0x00000000;
	fmesa->dczf  = 0x00000000;
	fmesa->dczb  = 0x00000000;
	fmesa->dcss1 = 0x00000000;
	fmesa->dcss2 = 0x00000000;
	fmesa->dcss3 = 0x00000000;
	fmesa->dcs2  = 0x00000000;
	fmesa->dcs3  = 0x00000000;
	fmesa->dcs4  = 0x00000000;
	fmesa->dcd2  = 0x00000000;
	fmesa->dcd3  = 0x00000000;
	fmesa->dcd4  = 0x00000000;

	/* Alpha blending unit state. */
	fifo_count += 3;
	fmesa->blendc  = (1 << 0) | (0 << 2);  /* src(GL_ONE) | dst(GL_ZERO) */
	fmesa->blendc1 = 0x00000000;
	fmesa->blendc2 = 0x00000000;

	/* ViewPort clip state. */
	fifo_count += 4 + (4 * 2);
	fmesa->vclipmin  = 0x00000000;
	fmesa->vclipmax  = 0x00000000;
	fmesa->vclipzmin = 0x00000000;
	fmesa->vclipzmax = 0x00000000;
	for (i = 0; i < 4; i++) {
		fmesa->aux_clips[0].min = 0x00000000;
		fmesa->aux_clips[0].max = 0x00000000;
	}

	/* Stenciling state. */
	fifo_count += 6;
	fmesa->stencil    = 0xf0000000; /* Stencil MASK, Y plane */
	fmesa->stencilctl = 0x33300000; /* All stencil tests disabled */
	fmesa->consty	  = 0x0;

	/* Area pattern, used for polygon stipples. */
	fifo_count += 32;
	for (i = 0; i < 32; i++)
		fmesa->pattern[i] = 0x00000000;

	fmesa->state_fifo_ents = fifo_count;
	fmesa->state_all_fifo_ents = fifo_count;
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/lib/GL/mesa/src/drv/ffb/ffb_state.c,v 1.6 2003/09/28 20:15:08 alanh Exp $
d4 1
a4 1
 * Copyright (C) 2000, 2001 David S. Miller
d28 6
a33 2
#include "mtypes.h"
#include "colormac.h"
d41 2
d46 2
d49 2
a50 7

#include "swrast/swrast.h"
#include "array_cache/acache.h"
#include "tnl/tnl.h"
#include "swrast_setup/swrast_setup.h"

#include "tnl/t_pipeline.h"
a56 1
	GLubyte alphaRef;
d60 1
a60 1
		_mesa_lookup_enum_by_nr(ctx->Color.AlphaFunc),
d78 1
a78 2
	CLAMPED_FLOAT_TO_UBYTE(alphaRef, ctx->Color.AlphaRef);
	xclip |= (alphaRef & 0xff);
d83 1
a83 1
static void ffbDDAlphaFunc(GLcontext *ctx, GLenum func, GLfloat ref)
d92 2
a93 1
			FFB_MAKE_DIRTY(fmesa, FFB_STATE_XCLIP, 1);
d100 1
d103 1
a103 1
	fprintf(stderr, "ffbDDBlendEquation: mode(%s)\n", _mesa_lookup_enum_by_nr(mode));
d105 4
a108 1
	FALLBACK( ctx, (mode != GL_FUNC_ADD_EXT), FFB_BADATTR_BLENDEQN);
d118 1
a118 1
		_mesa_lookup_enum_by_nr(sfactor), _mesa_lookup_enum_by_nr(dfactor));
d139 1
a139 1
			FALLBACK( ctx, FFB_BADATTR_BLENDFUNC, GL_TRUE );
d162 1
a162 1
			FALLBACK( ctx, FFB_BADATTR_BLENDFUNC, GL_TRUE );
d176 1
a176 1
		FALLBACK(ctx, FFB_BADATTR_BLENDROP, GL_TRUE);
d180 2
a181 1
	FALLBACK( ctx, (FFB_BADATTR_BLENDFUNC|FFB_BADATTR_BLENDROP), GL_FALSE );
d185 2
a186 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_BLEND, 1);
d196 4
a199 4
		_mesa_lookup_enum_by_nr(sfactorRGB),
		_mesa_lookup_enum_by_nr(dfactorRGB),
		_mesa_lookup_enum_by_nr(sfactorA),
		_mesa_lookup_enum_by_nr(dfactorA));
d212 1
a212 1
		_mesa_lookup_enum_by_nr(func));
d251 2
a252 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_CMP, 1);
d280 2
a281 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_FBC, 1);
d325 2
a326 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_STENCIL, 6);
d337 2
a338 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_YPMASK, 1);
d394 2
a395 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_STENCIL, 6);
d399 2
a400 1
static void ffbCalcViewportRegs(GLcontext *ctx)
d404 1
a404 1
	GLuint xmin, xmax, ymin, ymax, zmin, zmax;
d407 9
a415 25
	xmin = ctx->Viewport.X + dPriv->x;
	xmax = xmin + ctx->Viewport.Width;
	ymax = dPriv->y + dPriv->h - ctx->Viewport.Y;
	ymin = ymax - ctx->Viewport.Height;
	if (ctx->Scissor.Enabled) {
		GLuint sc_xmin, sc_xmax, sc_ymin, sc_ymax;

		sc_xmin = ctx->Viewport.X + dPriv->x;
		sc_xmax = sc_xmin + ctx->Viewport.Width;
		sc_ymax = dPriv->y + dPriv->h - ctx->Viewport.Y;
		sc_ymin = sc_ymax - ctx->Viewport.Height;
		if (sc_xmin > xmin)
			xmin = sc_xmin;
		if (sc_xmax < xmax)
			xmax = sc_xmax;
		if (sc_ymin > ymin)
			ymin = sc_ymin;
		if (sc_ymax < ymax)
			ymax = sc_ymax;
	}
	zmin = ((GLdouble)ctx->Viewport.Near * 0x0fffffff);
	zmax = ((GLdouble)ctx->Viewport.Far  * 0x0fffffff);

	vcmin = ((ymin & 0xffff) << 16) | (xmin & 0xffff);
	vcmax = ((ymax & 0xffff) << 16) | (xmax & 0xffff);
d417 1
a417 3
	    fmesa->vclipmax != vcmax ||
	    fmesa->vclipzmin != zmin ||
	    fmesa->vclipzmax != zmax) {
d420 2
a421 3
		fmesa->vclipzmin = zmin;
		fmesa->vclipzmax = zmax;
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_CLIP, (4 + (4 * 2)));
d425 1
a425 39
void ffbCalcViewport(GLcontext *ctx)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	const GLfloat *v = ctx->Viewport._WindowMap.m;
	GLfloat *m = fmesa->hw_viewport;
	__DRIdrawablePrivate *dPriv = fmesa->driDrawable;

	m[MAT_SX] =   v[MAT_SX];
	m[MAT_TX] =   v[MAT_TX] + dPriv->x + SUBPIXEL_X;
	m[MAT_SY] = - v[MAT_SY];
	m[MAT_TY] = - v[MAT_TY] + dPriv->h + dPriv->y + SUBPIXEL_Y;
	m[MAT_SZ] =   v[MAT_SZ] * ((GLdouble)1.0 / (GLdouble)0x0fffffff);
	m[MAT_TZ] =   v[MAT_TZ] * ((GLdouble)1.0 / (GLdouble)0x0fffffff);

	fmesa->depth_scale = ((GLdouble)1.0 / (GLdouble)0x0fffffff);

	ffbCalcViewportRegs(ctx);

	fmesa->setupnewinputs |= VERT_BIT_CLIP;
}

static void ffbDDViewport(GLcontext *ctx, GLint x, GLint y,
			  GLsizei width, GLsizei height)
{
	ffbCalcViewport(ctx);
}

static void ffbDDDepthRange(GLcontext *ctx, GLclampd nearval, GLclampd farval)
{
	ffbCalcViewport(ctx);
}

static void ffbDDScissor(GLcontext *ctx, GLint cx, GLint cy,
		  GLsizei cw, GLsizei ch)
{
	ffbCalcViewport(ctx);
}

static void ffbDDDrawBuffer(GLcontext *ctx, GLenum buffer)
d431 2
a432 2
	fprintf(stderr, "ffbDDDrawBuffer: mode(%s)\n",
		_mesa_lookup_enum_by_nr(buffer));
d434 1
a434 1
	fbc &= ~(FFB_FBC_WB_AB | FFB_FBC_RB_MASK);
d436 1
a436 1
	case FRONT_LEFT_BIT:
d438 1
a438 1
			fbc |= FFB_FBC_WB_B | FFB_FBC_RB_B;
d440 1
a440 1
			fbc |= FFB_FBC_WB_A | FFB_FBC_RB_A;
d443 1
a443 1
	case BACK_LEFT_BIT:
d445 1
a445 1
			fbc |= FFB_FBC_WB_A | FFB_FBC_RB_A;
d447 1
a447 1
			fbc |= FFB_FBC_WB_B | FFB_FBC_RB_B;
d450 1
a450 1
	case BACK_LEFT_BIT | FRONT_LEFT_BIT:
d455 1
a455 1
		return;
d460 2
a461 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_FBC, 1);
a462 1
}
d464 1
a464 4

static void ffbDDReadBuffer(GLcontext *ctx, GLenum buffer)
{
   /* no-op, unless you implement h/w glRead/CopyPixels */
d467 2
a468 6

/*
 * Specifies buffer for sw fallbacks (spans)
 */
static void ffbDDSetBuffer(GLcontext *ctx, GLframebuffer *colorBuffer,
			   GLuint bufferBit)
d475 1
a475 1
		_mesa_lookup_enum_by_nr(buffer));
d478 2
a479 2
	switch (bufferBit) {
	case FRONT_LEFT_BIT:
d486 1
a486 1
	case BACK_LEFT_BIT:
d499 2
a500 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_FBC, 1);
d504 1
a504 1
static void ffbDDClearColor(GLcontext *ctx, const GLfloat color[4])
a506 4
	GLubyte c[4];
	CLAMPED_FLOAT_TO_UBYTE(c[0], color[0]);
	CLAMPED_FLOAT_TO_UBYTE(c[1], color[1]);
	CLAMPED_FLOAT_TO_UBYTE(c[2], color[2]);
d508 12
a519 3
	fmesa->clear_pixel = ((c[0] << 0) |
			      (c[1] << 8) |
			      (c[2] << 16));
d536 139
d676 3
a678 3
static void ffbDDColorMask(GLcontext *ctx,
			   GLboolean r, GLboolean g,
			   GLboolean b, GLboolean a)
d696 2
a697 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_PMASK, 1);
d699 2
d703 1
a703 1
static void ffbDDLogicOp(GLcontext *ctx, GLenum op)
d710 1
a710 1
		_mesa_lookup_enum_by_nr(op));
d731 1
a731 1
		return;
d737 2
a738 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_ROP, 1);
d741 1
a741 1
			FALLBACK( ctx, FFB_BADATTR_BLENDROP, GL_FALSE );
d743 2
d827 1
a827 1
	fprintf(stderr, "ffbDDFogfv: pname(%s)\n", _mesa_lookup_enum_by_nr(pname));
d842 2
a843 1
		if ((GLuint) factor > 15) {			
d846 1
d877 2
a878 1
	FFB_MAKE_DIRTY(fmesa, FFB_STATE_APAT, 32);
d889 5
d904 1
a904 1
		_mesa_lookup_enum_by_nr(cap), state);
d915 2
a916 1
			FFB_MAKE_DIRTY(fmesa, FFB_STATE_XCLIP, 1);
d929 2
a930 1
			FFB_MAKE_DIRTY(fmesa, FFB_STATE_PPC, 1);
d950 2
a951 1
			FFB_MAKE_DIRTY(fmesa, (FFB_STATE_MAGNC | FFB_STATE_FBC), 2);
d956 8
a963 2
		ffbDDScissor(ctx, ctx->Scissor.X, ctx->Scissor.Y,
			     ctx->Scissor.Width, ctx->Scissor.Height);
d968 5
a972 1
			FALLBACK( ctx, FFB_BADATTR_STENCIL, state );
d978 4
a981 4
					 ctx->Stencil.Function[0],
					 ctx->Stencil.Ref[0],
					 ctx->Stencil.ValueMask[0]);
			ffbDDStencilMask(ctx, ctx->Stencil.WriteMask[0]);
d983 3
a985 3
				       ctx->Stencil.FailFunc[0],
				       ctx->Stencil.ZFailFunc[0],
				       ctx->Stencil.ZPassFunc[0]);
d990 2
a991 1
			FFB_MAKE_DIRTY(fmesa, FFB_STATE_STENCIL, 6);
d996 2
a997 1
			FFB_MAKE_DIRTY(fmesa, FFB_STATE_FBC, 1);
d1003 4
a1006 1
		FALLBACK( ctx, FFB_BADATTR_FOG, state );
d1140 1
a1140 1
static void ffbDDUpdateState(GLcontext *ctx, GLuint newstate)
d1144 10
a1153 6
	/* When we are hw rendering, changing certain kinds of
	 * state does not require flushing all of our context.
	 */
	if (fmesa->bad_fragment_attrs == 0 &&
	    (newstate & ~_NEW_COLOR) == 0)
		return;
d1155 3
a1157 4
	_swrast_InvalidateState( ctx, newstate );
	_swsetup_InvalidateState( ctx, newstate );
	_ac_InvalidateState( ctx, newstate );
	_tnl_InvalidateState( ctx, newstate );
d1159 23
a1181 3
	if (newstate & _NEW_TEXTURE)
	   FALLBACK( ctx, FFB_BADATTR_TEXTURE, 
		     (ctx->Texture._EnabledUnits != 0));
d1183 2
a1184 3
#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDUpdateState: newstate(%08x)\n", newstate);
#endif
d1186 1
a1186 1
	fmesa->new_gl_state |= newstate;
d1188 5
a1192 4
	/* Force a reduced primitive change next rendering
	 * pass.
	 */
	fmesa->raster_primitive = GL_POLYGON + 1;
d1201 1
a1201 1
	if (ctx->Fog.Enabled && (newstate & _NEW_MODELVIEW))
d1204 29
a1234 1

a1239 1

d1255 4
a1258 3
	ctx->Driver.LogicOpcode = ffbDDLogicOp;
	ctx->Driver.Viewport = ffbDDViewport;
	ctx->Driver.DepthRange = ffbDDDepthRange;
d1270 3
a1272 2
	ctx->Driver.DrawBuffer = ffbDDDrawBuffer;
	ctx->Driver.ReadBuffer = ffbDDReadBuffer;
d1276 1
d1279 1
a1281 25



	/* Pixel path fallbacks.
	 */
	ctx->Driver.Accum = _swrast_Accum;
	ctx->Driver.CopyPixels = _swrast_CopyPixels;
	ctx->Driver.DrawPixels = _swrast_DrawPixels;
	ctx->Driver.ReadPixels = _swrast_ReadPixels;
	ctx->Driver.ResizeBuffers = _swrast_alloc_buffers;

	/* Swrast hooks for imaging extensions:
	 */
	ctx->Driver.CopyColorTable = _swrast_CopyColorTable;
	ctx->Driver.CopyColorSubTable = _swrast_CopyColorSubTable;
	ctx->Driver.CopyConvolutionFilter1D = _swrast_CopyConvolutionFilter1D;
	ctx->Driver.CopyConvolutionFilter2D = _swrast_CopyConvolutionFilter2D;

	{
		struct swrast_device_driver *swdd = 
			_swrast_GetDeviceDriverReference(ctx);
		swdd->SetBuffer = ffbDDSetBuffer;
	}
   

a1293 1
	fmesa->new_gl_state = ~0;
d1300 1
a1300 1
	if (ctx->Visual.doubleBufferMode) {
d1311 1
a1311 1
		      FFB_PPC_ABE_DISABLE | FFB_PPC_VCE_3D |
d1381 1
a1381 1
	fmesa->vclipmax  = 0xffffffff;
d1383 1
a1383 1
	fmesa->vclipzmax = 0x0fffffff;
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/lib/GL/mesa/src/drv/ffb/ffb_state.c,v 1.5 2002/10/30 12:51:27 alanh Exp $
d4 1
a4 1
 * Copyright (C) 2000, 2001 David S. Miller
d28 2
a29 1
#include "mtypes.h"
d46 2
d49 2
a50 7

#include "swrast/swrast.h"
#include "array_cache/acache.h"
#include "tnl/tnl.h"
#include "swrast_setup/swrast_setup.h"

#include "tnl/t_pipeline.h"
d60 1
a60 1
		_mesa_lookup_enum_by_nr(ctx->Color.AlphaFunc),
d83 1
a83 1
static void ffbDDAlphaFunc(GLcontext *ctx, GLenum func, GLchan ref)
d92 2
a93 1
			FFB_MAKE_DIRTY(fmesa, FFB_STATE_XCLIP, 1);
d100 1
d103 1
a103 1
	fprintf(stderr, "ffbDDBlendEquation: mode(%s)\n", _mesa_lookup_enum_by_nr(mode));
d105 4
a108 1
	FALLBACK( ctx, (mode != GL_FUNC_ADD_EXT), FFB_BADATTR_BLENDEQN);
d118 1
a118 1
		_mesa_lookup_enum_by_nr(sfactor), _mesa_lookup_enum_by_nr(dfactor));
d139 1
a139 1
			FALLBACK( ctx, FFB_BADATTR_BLENDFUNC, GL_TRUE );
d162 1
a162 1
			FALLBACK( ctx, FFB_BADATTR_BLENDFUNC, GL_TRUE );
d176 1
a176 1
		FALLBACK(ctx, FFB_BADATTR_BLENDROP, GL_TRUE);
d180 2
a181 1
	FALLBACK( ctx, (FFB_BADATTR_BLENDFUNC|FFB_BADATTR_BLENDROP), GL_FALSE );
d185 2
a186 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_BLEND, 1);
d196 4
a199 4
		_mesa_lookup_enum_by_nr(sfactorRGB),
		_mesa_lookup_enum_by_nr(dfactorRGB),
		_mesa_lookup_enum_by_nr(sfactorA),
		_mesa_lookup_enum_by_nr(dfactorA));
d212 1
a212 1
		_mesa_lookup_enum_by_nr(func));
d251 2
a252 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_CMP, 1);
d280 2
a281 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_FBC, 1);
d325 2
a326 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_STENCIL, 6);
d337 2
a338 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_YPMASK, 1);
d394 2
a395 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_STENCIL, 6);
d399 2
a400 1
static void ffbCalcViewportRegs(GLcontext *ctx)
d404 1
a404 1
	GLuint xmin, xmax, ymin, ymax, zmin, zmax;
d407 9
a415 25
	xmin = ctx->Viewport.X + dPriv->x;
	xmax = xmin + ctx->Viewport.Width;
	ymax = dPriv->y + dPriv->h - ctx->Viewport.Y;
	ymin = ymax - ctx->Viewport.Height;
	if (ctx->Scissor.Enabled) {
		GLuint sc_xmin, sc_xmax, sc_ymin, sc_ymax;

		sc_xmin = ctx->Viewport.X + dPriv->x;
		sc_xmax = sc_xmin + ctx->Viewport.Width;
		sc_ymax = dPriv->y + dPriv->h - ctx->Viewport.Y;
		sc_ymin = sc_ymax - ctx->Viewport.Height;
		if (sc_xmin > xmin)
			xmin = sc_xmin;
		if (sc_xmax < xmax)
			xmax = sc_xmax;
		if (sc_ymin > ymin)
			ymin = sc_ymin;
		if (sc_ymax < ymax)
			ymax = sc_ymax;
	}
	zmin = ((GLdouble)ctx->Viewport.Near * 0x0fffffff);
	zmax = ((GLdouble)ctx->Viewport.Far  * 0x0fffffff);

	vcmin = ((ymin & 0xffff) << 16) | (xmin & 0xffff);
	vcmax = ((ymax & 0xffff) << 16) | (xmax & 0xffff);
d417 1
a417 3
	    fmesa->vclipmax != vcmax ||
	    fmesa->vclipzmin != zmin ||
	    fmesa->vclipzmax != zmax) {
d420 2
a421 3
		fmesa->vclipzmin = zmin;
		fmesa->vclipzmax = zmax;
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_CLIP, (4 + (4 * 2)));
d425 1
a425 39
void ffbCalcViewport(GLcontext *ctx)
{
	ffbContextPtr fmesa = FFB_CONTEXT(ctx);
	const GLfloat *v = ctx->Viewport._WindowMap.m;
	GLfloat *m = fmesa->hw_viewport;
	__DRIdrawablePrivate *dPriv = fmesa->driDrawable;

	m[MAT_SX] =   v[MAT_SX];
	m[MAT_TX] =   v[MAT_TX] + dPriv->x + SUBPIXEL_X;
	m[MAT_SY] = - v[MAT_SY];
	m[MAT_TY] = - v[MAT_TY] + dPriv->h + dPriv->y + SUBPIXEL_Y;
	m[MAT_SZ] =   v[MAT_SZ] * ((GLdouble)1.0 / (GLdouble)0x0fffffff);
	m[MAT_TZ] =   v[MAT_TZ] * ((GLdouble)1.0 / (GLdouble)0x0fffffff);

	fmesa->depth_scale = ((GLdouble)1.0 / (GLdouble)0x0fffffff);

	ffbCalcViewportRegs(ctx);

	fmesa->setupnewinputs |= VERT_CLIP;
}

static void ffbDDViewport(GLcontext *ctx, GLint x, GLint y,
			  GLsizei width, GLsizei height)
{
	ffbCalcViewport(ctx);
}

static void ffbDDDepthRange(GLcontext *ctx, GLclampd nearval, GLclampd farval)
{
	ffbCalcViewport(ctx);
}

static void ffbDDScissor(GLcontext *ctx, GLint cx, GLint cy,
		  GLsizei cw, GLsizei ch)
{
	ffbCalcViewport(ctx);
}

static void ffbDDSetDrawBuffer(GLcontext *ctx, GLenum buffer)
d432 1
a432 1
		_mesa_lookup_enum_by_nr(buffer));
d434 1
a434 1
	fbc &= ~(FFB_FBC_WB_AB | FFB_FBC_RB_MASK);
d438 1
a438 1
			fbc |= FFB_FBC_WB_B | FFB_FBC_RB_B;
d440 1
a440 1
			fbc |= FFB_FBC_WB_A | FFB_FBC_RB_A;
d445 1
a445 1
			fbc |= FFB_FBC_WB_A | FFB_FBC_RB_A;
d447 1
a447 1
			fbc |= FFB_FBC_WB_B | FFB_FBC_RB_B;
d455 1
a455 1
		return;
d460 2
a461 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_FBC, 1);
d463 2
d475 1
a475 1
		_mesa_lookup_enum_by_nr(buffer));
d499 2
a500 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_FBC, 1);
d504 10
a513 1
static void ffbDDClearColor(GLcontext *ctx, const GLchan color[4])
d517 3
a519 3
	fmesa->clear_pixel = ((color[0] << 0) |
			      (color[1] << 8) |
			      (color[2] << 16));
d536 139
d676 3
a678 3
static void ffbDDColorMask(GLcontext *ctx,
			   GLboolean r, GLboolean g,
			   GLboolean b, GLboolean a)
d696 2
a697 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_PMASK, 1);
d699 2
d703 1
a703 1
static void ffbDDLogicOp(GLcontext *ctx, GLenum op)
d710 1
a710 1
		_mesa_lookup_enum_by_nr(op));
d731 1
a731 1
		return;
d737 2
a738 1
		FFB_MAKE_DIRTY(fmesa, FFB_STATE_ROP, 1);
d741 1
a741 1
			FALLBACK( ctx, FFB_BADATTR_BLENDROP, GL_FALSE );
d743 2
d827 1
a827 1
	fprintf(stderr, "ffbDDFogfv: pname(%s)\n", _mesa_lookup_enum_by_nr(pname));
d842 2
a843 1
		if ((GLuint) factor > 15) {			
d846 1
d877 2
a878 1
	FFB_MAKE_DIRTY(fmesa, FFB_STATE_APAT, 32);
d889 5
d904 1
a904 1
		_mesa_lookup_enum_by_nr(cap), state);
d915 2
a916 1
			FFB_MAKE_DIRTY(fmesa, FFB_STATE_XCLIP, 1);
d929 2
a930 1
			FFB_MAKE_DIRTY(fmesa, FFB_STATE_PPC, 1);
d950 2
a951 1
			FFB_MAKE_DIRTY(fmesa, (FFB_STATE_MAGNC | FFB_STATE_FBC), 2);
d956 8
a963 2
		ffbDDScissor(ctx, ctx->Scissor.X, ctx->Scissor.Y,
			     ctx->Scissor.Width, ctx->Scissor.Height);
d968 5
a972 1
			FALLBACK( ctx, FFB_BADATTR_STENCIL, state );
d990 2
a991 1
			FFB_MAKE_DIRTY(fmesa, FFB_STATE_STENCIL, 6);
d996 2
a997 1
			FFB_MAKE_DIRTY(fmesa, FFB_STATE_FBC, 1);
d1003 4
a1006 1
		FALLBACK( ctx, FFB_BADATTR_FOG, state );
d1140 1
a1140 1
static void ffbDDUpdateState(GLcontext *ctx, GLuint newstate)
d1144 10
a1153 6
	/* When we are hw rendering, changing certain kinds of
	 * state does not require flushing all of our context.
	 */
	if (fmesa->bad_fragment_attrs == 0 &&
	    (newstate & ~_NEW_COLOR) == 0)
		return;
d1155 3
a1157 4
	_swrast_InvalidateState( ctx, newstate );
	_swsetup_InvalidateState( ctx, newstate );
	_ac_InvalidateState( ctx, newstate );
	_tnl_InvalidateState( ctx, newstate );
d1159 23
a1181 3
	if (newstate & _NEW_TEXTURE)
	   FALLBACK( ctx, FFB_BADATTR_TEXTURE, 
		     (ctx->Texture._ReallyEnabled != 0));
d1183 2
a1184 3
#ifdef STATE_TRACE
	fprintf(stderr, "ffbDDUpdateState: newstate(%08x)\n", newstate);
#endif
d1186 1
a1186 1
	fmesa->new_gl_state |= newstate;
d1188 5
a1192 4
	/* Force a reduced primitive change next rendering
	 * pass.
	 */
	fmesa->raster_primitive = GL_POLYGON + 1;
d1201 1
a1201 1
	if (ctx->Fog.Enabled && (newstate & _NEW_MODELVIEW))
d1204 29
a1234 1

a1239 1

d1255 4
a1258 3
	ctx->Driver.LogicOpcode = ffbDDLogicOp;
	ctx->Driver.Viewport = ffbDDViewport;
	ctx->Driver.DepthRange = ffbDDDepthRange;
d1271 2
d1276 1
d1279 1
a1281 25



	/* Pixel path fallbacks.
	 */
	ctx->Driver.Accum = _swrast_Accum;
	ctx->Driver.CopyPixels = _swrast_CopyPixels;
	ctx->Driver.DrawPixels = _swrast_DrawPixels;
	ctx->Driver.ReadPixels = _swrast_ReadPixels;
	ctx->Driver.ResizeBuffers = _swrast_alloc_buffers;

	/* Swrast hooks for imaging extensions:
	 */
	ctx->Driver.CopyColorTable = _swrast_CopyColorTable;
	ctx->Driver.CopyColorSubTable = _swrast_CopyColorSubTable;
	ctx->Driver.CopyConvolutionFilter1D = _swrast_CopyConvolutionFilter1D;
	ctx->Driver.CopyConvolutionFilter2D = _swrast_CopyConvolutionFilter2D;

	{
		struct swrast_device_driver *swdd = 
			_swrast_GetDeviceDriverReference(ctx);
		swdd->SetReadBuffer = ffbDDSetReadBuffer;
	}
   

a1293 1
	fmesa->new_gl_state = ~0;
d1300 1
a1300 1
	if (ctx->Visual.doubleBufferMode) {
d1311 1
a1311 1
		      FFB_PPC_ABE_DISABLE | FFB_PPC_VCE_3D |
d1381 1
a1381 1
	fmesa->vclipmax  = 0xffffffff;
d1383 1
a1383 1
	fmesa->vclipzmax = 0x0fffffff;
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/lib/GL/mesa/src/drv/ffb/ffb_state.c,v 1.6 2003/09/28 20:15:08 alanh Exp $
d29 4
a32 1
#include "colormac.h"
d40 2
a58 1
	GLubyte alphaRef;
d80 1
a80 2
	CLAMPED_FLOAT_TO_UBYTE(alphaRef, ctx->Color.AlphaRef);
	xclip |= (alphaRef & 0xff);
d85 1
a85 1
static void ffbDDAlphaFunc(GLcontext *ctx, GLenum func, GLfloat ref)
d451 1
a451 1
	fmesa->setupnewinputs |= VERT_BIT_CLIP;
d471 1
a471 1
static void ffbDDDrawBuffer(GLcontext *ctx, GLenum buffer)
d477 1
a477 1
	fprintf(stderr, "ffbDDDrawBuffer: mode(%s)\n",
d482 1
a482 1
	case FRONT_LEFT_BIT:
d489 1
a489 1
	case BACK_LEFT_BIT:
d496 1
a496 1
	case BACK_LEFT_BIT | FRONT_LEFT_BIT:
d510 2
a511 12

static void ffbDDReadBuffer(GLcontext *ctx, GLenum buffer)
{
   /* no-op, unless you implement h/w glRead/CopyPixels */
}


/*
 * Specifies buffer for sw fallbacks (spans)
 */
static void ffbDDSetBuffer(GLcontext *ctx, GLframebuffer *colorBuffer,
			   GLuint bufferBit)
d521 2
a522 2
	switch (bufferBit) {
	case FRONT_LEFT_BIT:
d529 1
a529 1
	case BACK_LEFT_BIT:
d546 1
a546 1
static void ffbDDClearColor(GLcontext *ctx, const GLfloat color[4])
a548 4
	GLubyte c[4];
	CLAMPED_FLOAT_TO_UBYTE(c[0], color[0]);
	CLAMPED_FLOAT_TO_UBYTE(c[1], color[1]);
	CLAMPED_FLOAT_TO_UBYTE(c[2], color[2]);
d550 3
a552 3
	fmesa->clear_pixel = ((c[0] << 0) |
			      (c[1] << 8) |
			      (c[2] << 16));
d845 4
a848 4
					 ctx->Stencil.Function[0],
					 ctx->Stencil.Ref[0],
					 ctx->Stencil.ValueMask[0]);
			ffbDDStencilMask(ctx, ctx->Stencil.WriteMask[0]);
d850 3
a852 3
				       ctx->Stencil.FailFunc[0],
				       ctx->Stencil.ZFailFunc[0],
				       ctx->Stencil.ZPassFunc[0]);
d1020 1
a1020 1
		     (ctx->Texture._EnabledUnits != 0));
d1081 1
a1081 2
	ctx->Driver.DrawBuffer = ffbDDDrawBuffer;
	ctx->Driver.ReadBuffer = ffbDDReadBuffer;
d1110 1
a1110 1
		swdd->SetBuffer = ffbDDSetBuffer;
@


