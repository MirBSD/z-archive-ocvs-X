head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.04.16;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.04.16;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.31.25;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.58.15;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.17.54;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * GLX Hardware Device Driver for Intel i810
 * Copyright (C) 1999 Keith Whitwell
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * KEITH WHITWELL, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM, 
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */
/* $XFree86: xc/lib/GL/mesa/src/drv/i810/i810tex.c,v 1.7 2001/10/31 22:50:24 tsi Exp $ */

#include <stdlib.h>
#include <stdio.h>

#include <GL/gl.h>

#include "mm.h"
#include "i810context.h"
#include "i810tex.h"
#include "i810log.h"
#include "i810ioctl.h"
#include "simple_list.h"
#include "enums.h"

static void i810SetTexWrapping(i810TextureObjectPtr tex, GLenum s, GLenum t)
{
   unsigned int val = tex->Setup[I810_TEXREG_MCS];

   val &= ~(MCS_U_STATE_MASK|MCS_V_STATE_MASK);
   val |= (MCS_U_WRAP|MCS_V_WRAP);
   
   if (s != GL_REPEAT) 
      val ^= (MCS_U_WRAP^MCS_U_CLAMP);

   if (t != GL_REPEAT) 
      val ^= (MCS_V_WRAP^MCS_V_CLAMP);

   tex->Setup[I810_TEXREG_MCS] = val;
}

static void i810SetTexFilter(i810ContextPtr imesa, 
			     i810TextureObjectPtr t, 
			     GLenum minf, GLenum magf)
{
   GLuint LastLevel;

   switch (minf) {
   case GL_NEAREST:
      I810_SET_FIELD(t->Setup[I810_TEXREG_MF],
		     MF_MIN_MASK | MF_MIP_MASK,
		     MF_MIN_NEAREST | MF_MIP_NONE);
      break;
   case GL_LINEAR:
      I810_SET_FIELD(t->Setup[I810_TEXREG_MF],
		     MF_MIN_MASK | MF_MIP_MASK,
		     MF_MIN_LINEAR | MF_MIP_NONE);
      break;
   case GL_NEAREST_MIPMAP_NEAREST:
      I810_SET_FIELD(t->Setup[I810_TEXREG_MF],
		     MF_MIN_MASK | MF_MIP_MASK,
		     MF_MIN_NEAREST | MF_MIP_NEAREST);
      break;
   case GL_LINEAR_MIPMAP_NEAREST:
      I810_SET_FIELD(t->Setup[I810_TEXREG_MF],
		     MF_MIN_MASK | MF_MIP_MASK,
		     MF_MIN_LINEAR | MF_MIP_NEAREST);
      break;
   case GL_NEAREST_MIPMAP_LINEAR:
      /* This is quite a performance hit - may want to make this
       * choice user-configurable, otherwise the 815 may look slower
       * than the 810 (despite having much better image quality).
       */
      if (IS_I815(imesa)) {
	 I810_SET_FIELD(t->Setup[I810_TEXREG_MF],
			MF_MIN_MASK | MF_MIP_MASK,
			MF_MIN_NEAREST | MF_MIP_LINEAR );
      } else {
	 I810_SET_FIELD(t->Setup[I810_TEXREG_MF],
			MF_MIN_MASK | MF_MIP_MASK,
			MF_MIN_NEAREST | MF_MIP_DITHER );
      }
      break;
   case GL_LINEAR_MIPMAP_LINEAR:
      if (IS_I815(imesa)) {
	 I810_SET_FIELD(t->Setup[I810_TEXREG_MF],
			MF_MIN_MASK | MF_MIP_MASK,
			MF_MIN_LINEAR  | MF_MIP_LINEAR );
      } else {
	 I810_SET_FIELD(t->Setup[I810_TEXREG_MF],
			MF_MIN_MASK | MF_MIP_MASK,
			MF_MIN_LINEAR  | MF_MIP_DITHER );
      }
      break;
   default:
      i810Error("i810SetTexFilter(): not supported min. filter %d\n",(int)minf);
      break;
   }

   switch (magf) {
   case GL_NEAREST:
      I810_SET_FIELD(t->Setup[I810_TEXREG_MF],
		     MF_MAG_MASK,MF_MAG_NEAREST);
      break;
   case GL_LINEAR:
      I810_SET_FIELD(t->Setup[I810_TEXREG_MF],
		     MF_MAG_MASK,MF_MAG_LINEAR);
      break;
   default:
      i810Error("i810SetTexFilter(): not supported mag. filter %d\n",(int)magf);
      break;
   }  

   if (t->globj->MinFilter != GL_NEAREST && 
       t->globj->MinFilter != GL_LINEAR) {
      LastLevel = t->max_level;
   } else {
      LastLevel = t->min_level;
   }

   I810_SET_FIELD(t->Setup[I810_TEXREG_MLL],
		  MLL_MAX_MIP_MASK,
		  (t->min_level << (MLL_MAX_MIP_SHIFT+4)));

   I810_SET_FIELD(t->Setup[I810_TEXREG_MLL],
		  MLL_MIN_MIP_MASK,
		  (LastLevel << MLL_MIN_MIP_SHIFT));

   /* See OpenGL 1.2 specification */
   if (magf == GL_LINEAR && (minf == GL_NEAREST_MIPMAP_NEAREST || 
			     minf == GL_NEAREST_MIPMAP_LINEAR))
   {
      /* c = 0.5 */
      I810_SET_FIELD(t->Setup[I810_TEXREG_MLC],
		     MLC_LOD_BIAS_MASK,
		     0x10);
   } else {
      /* c = 0 */
      I810_SET_FIELD(t->Setup[I810_TEXREG_MLC],
		     MLC_LOD_BIAS_MASK,
		     0x0);
   }
}


/* Need a fallback ?
 */
static void i810SetTexBorderColor(i810TextureObjectPtr t, GLubyte color[4])
{
/*    t->Setup[I810_TEXREG_TEXBORDERCOL] =  */
/*      I810PACKCOLOR8888(color[0],color[1],color[2],color[3]); */
}



static void ReplicateMesaTexState(i810ContextPtr imesa,
				  i810TextureObjectPtr t,
                                  struct gl_texture_object *mesatex)
{
   i810SetTexWrapping(t,mesatex->WrapS,mesatex->WrapT);
   i810SetTexFilter(imesa, t,mesatex->MinFilter,mesatex->MagFilter);
   i810SetTexBorderColor(t,mesatex->BorderColor);
}

static i810TextureObjectPtr i810CreateTexObj(i810ContextPtr imesa,
					     struct gl_texture_object *tObj)
{
   i810TextureObjectPtr t;
   GLuint height, width, pitch, i, textureFormat, log_pitch;
   struct gl_texture_image *image;

   image = tObj->Image[ 0 ];
   if ( !image ) {
      fprintf(stderr, "no image at level zero - not creating texobj\n");
      return 0;
   }
   
   t = (i810TextureObjectPtr) calloc(1,sizeof(*t));
   if (!t)
      return 0;

   switch( image->Format ) {
   case GL_RGB:
   case GL_LUMINANCE:
      t->texelBytes = 2;
      textureFormat = MI1_FMT_16BPP | MI1_PF_16BPP_RGB565;
      break;
   case GL_ALPHA:
   case GL_LUMINANCE_ALPHA:
   case GL_INTENSITY:
   case GL_RGBA:
      t->texelBytes = 2;
      textureFormat = MI1_FMT_16BPP | MI1_PF_16BPP_ARGB4444;
      break;
   case GL_COLOR_INDEX:
      textureFormat = MI1_FMT_8CI | MI1_PF_8CI_ARGB4444;
      t->texelBytes = 1;
      break;
   default:
      i810Error( "i810CreateTexObj: bad image->Format\n" );
      free( t );      
      return 0;	
   }


   /* Figure out the size now (and count the levels).  Upload won't be done
    * until later.
    */ 
   width = image->Width * t->texelBytes;
   for (pitch = 32, log_pitch=2 ; pitch < width ; pitch *= 2 )
      log_pitch++;
   
   t->dirty_images = 0;
   t->bound = 0;
   
   for ( height = i = 0 ; i < I810_TEX_MAXLEVELS && tObj->Image[i] ; i++ ) {
      t->image[i].image = tObj->Image[i];
      t->image[i].offset = height * pitch;
      t->image[i].internalFormat = image->Format;
      t->dirty_images |= (1<<i);
      height += t->image[i].image->Height;
   }

   t->Pitch = pitch;
   t->totalSize = height*pitch;
   t->max_level = i-1;
   t->min_level = 0;
   t->globj = tObj;
   t->age = 0;

   t->Setup[I810_TEXREG_MI0] = GFX_OP_MAP_INFO;

   t->Setup[I810_TEXREG_MI1] = (MI1_MAP_0 |
				textureFormat |
				log_pitch);			 

   t->Setup[I810_TEXREG_MI2] = (MI2_DIMENSIONS_ARE_LOG2 |
				(image->HeightLog2 << 16) |
				(image->WidthLog2));

   t->Setup[I810_TEXREG_MI3] = 0;
  
   t->Setup[I810_TEXREG_MLC] = (GFX_OP_MAP_LOD_CTL | 
				MLC_MAP_0 |
				MLC_DITHER_WEIGHT_FULL |
				MLC_UPDATE_LOD_BIAS |
				0x0);

   t->Setup[I810_TEXREG_MLL] = (GFX_OP_MAP_LOD_LIMITS |
				MLL_MAP_0  |
				MLL_UPDATE_MAX_MIP | 
				(t->min_level << MLL_MAX_MIP_SHIFT) |
				MLL_UPDATE_MIN_MIP |
				t->max_level);

   /* I think this is context state, really.
    */
   t->Setup[I810_TEXREG_MCS] = (GFX_OP_MAP_COORD_SETS |
				MCS_COORD_0 |
				MCS_UPDATE_NORMALIZED |
				MCS_NORMALIZED_COORDS |
				MCS_UPDATE_V_STATE |
				MCS_V_WRAP |
				MCS_UPDATE_U_STATE |
				MCS_U_WRAP);

   t->Setup[I810_TEXREG_MF] = (GFX_OP_MAP_FILTER |
			       MF_MAP_0 |
			       MF_UPDATE_ANISOTROPIC |
			       0 |
			       MF_UPDATE_MIP_FILTER |
			       MF_MIP_NEAREST |
			       MF_UPDATE_MAG_FILTER |
			       MF_MAG_NEAREST |
			       MF_UPDATE_MIN_FILTER |
			       MF_MIN_NEAREST);

   t->current_unit = 0;

   ReplicateMesaTexState(imesa, t,tObj);
   tObj->DriverData = t;
   imesa->dirty |= I810_UPLOAD_CTX;
   make_empty_list( t );
   return t;
}

void i810DestroyTexObj(i810ContextPtr imesa, i810TextureObjectPtr t)
{
   if (!t) return;

   /* This is sad - need to sync *in case* we upload a texture
    * to this newly free memory...
    */
   if (t->MemBlock) {
      mmFreeMem(t->MemBlock);
      t->MemBlock = 0;

      if (t->age > imesa->dirtyAge)
	 imesa->dirtyAge = t->age;
   }

   if (t->globj)
      t->globj->DriverData = 0;

   if (t->bound)
      imesa->CurrentTexObj[t->bound - 1] = 0; 

   remove_from_list(t);
   free(t);
}


static void i810SwapOutTexObj(i810ContextPtr imesa, i810TextureObjectPtr t)
{
   if (t->MemBlock) {
      mmFreeMem(t->MemBlock);
      t->MemBlock = 0;      

      if (t->age > imesa->dirtyAge)
	 imesa->dirtyAge = t->age;
   }

   t->dirty_images = ~0;
   move_to_tail(&(imesa->SwappedOut), t);
}



/* Upload an image from mesa's internal copy.
 */
static void i810UploadTexLevel( i810TextureObjectPtr t, int level )
{
   const struct gl_texture_image *image = t->image[level].image;
   int i,j;

   if (I810_DEBUG & DEBUG_VERBOSE_LRU)
      fprintf(stderr, "i810UploadTexLevel %d, BufAddr %p offset %x\n",
	      level, t->BufAddr, t->image[level].offset);

   /* Need triangle (rather than pixel) fallbacks to simulate this using
    * normal textured triangles.
    *
    * DO THIS IN DRIVER STATE MANAGMENT, not hardware state.
    *
   if (image->Border != 0) 
      i810Error("Not supported texture border %d.\n", (int) image->Border);
    */

   switch (t->image[level].internalFormat) {
   case GL_RGB:
   {
      GLushort *dst = (GLushort *)(t->BufAddr + t->image[level].offset);
      GLubyte  *src = (GLubyte *)image->Data;

      for (j = 0 ; j < image->Height ; j++, dst += (t->Pitch/2)) {
	 for (i = 0 ; i < image->Width ; i++) {
	    dst[i] = I810PACKCOLOR565(src[0],src[1],src[2]);
	    src += 3;
	 }
      }
   }
   break;
      
   case GL_RGBA:
   {
      GLushort *dst = (GLushort *)(t->BufAddr + t->image[level].offset);
      GLubyte  *src = (GLubyte *)image->Data;

      for (j = 0 ; j < image->Height ; j++, dst += (t->Pitch/2)) {
	 for (i = 0 ; i < image->Width ; i++) {
	    dst[i] = I810PACKCOLOR4444(src[0],src[1],src[2],src[3]);
	    src += 4;
	 }
      }
   }
   break;
      
   case GL_LUMINANCE:
   {
      GLushort *dst = (GLushort *)(t->BufAddr + t->image[level].offset);
      GLubyte  *src = (GLubyte *)image->Data;

      for (j = 0 ; j < image->Height ; j++, dst += (t->Pitch/2)) {
	 for (i = 0 ; i < image->Width ; i++) {
	    dst[i] = I810PACKCOLOR565(src[0],src[0],src[0]);
	    src ++;
	 }
      }
   }
   break;

   case GL_INTENSITY:
   {
      GLushort *dst = (GLushort *)(t->BufAddr + t->image[level].offset);
      GLubyte  *src = (GLubyte *)image->Data;
      int i;

      for (j = 0 ; j < image->Height ; j++, dst += (t->Pitch/2)) {
	 for (i = 0 ; i < image->Width ; i++) {
	    dst[i] = I810PACKCOLOR4444(src[0],src[0],src[0],src[0]);
	    src ++;
	 }
      }
   }
   break;
      
   case GL_LUMINANCE_ALPHA:
   {
      GLushort *dst = (GLushort *)(t->BufAddr + t->image[level].offset);
      GLubyte  *src = (GLubyte *)image->Data;

      for (j = 0 ; j < image->Height ; j++, dst += (t->Pitch/2)) {
	 for (i = 0 ; i < image->Width ; i++) {
	    dst[i] = I810PACKCOLOR4444(src[0],src[0],src[0],src[1]);
	    src += 2;
	 }
      }
   }
   break;

   case GL_ALPHA:
   {
      GLushort *dst = (GLushort *)(t->BufAddr + t->image[level].offset);
      GLubyte  *src = (GLubyte *)image->Data;

      for (j = 0 ; j < image->Height ; j++, dst += (t->Pitch/2)) {
	 for (i = 0 ; i < image->Width ; i++) {
	    dst[i] = I810PACKCOLOR4444(255,255,255,src[0]);
	    src += 1;
	 }
      }
   }
   break;

   /* TODO: Translate color indices *now*:
    */
   case GL_COLOR_INDEX:
      {
	 GLubyte *dst = (GLubyte *)(t->BufAddr + t->image[level].offset);
	 GLubyte *src = (GLubyte *)image->Data;

	 for (j = 0 ; j < image->Height ; j++, dst += t->Pitch) {
	    for (i = 0 ; i < image->Width ; i++) {
	       dst[i] = src[0];
	       src += 1;
	    }
	 }
      }
   break;
      
   default:
      i810Error("Not supported texture format %s\n",
		gl_lookup_enum_by_nr(image->Format));
   }
}



void i810PrintLocalLRU( i810ContextPtr imesa ) 
{
   i810TextureObjectPtr t;
   int sz = 1 << (imesa->i810Screen->logTextureGranularity);

   foreach( t, &imesa->TexObjList ) {
      if (!t->globj)
	 fprintf(stderr, "Placeholder %d at %x sz %x\n", 
		 t->MemBlock->ofs / sz,
		 t->MemBlock->ofs,
		 t->MemBlock->size);      
      else
	 fprintf(stderr, "Texture (bound %d) at %x sz %x\n", 
		 t->bound,
		 t->MemBlock->ofs,
		 t->MemBlock->size);      

   }
}

void i810PrintGlobalLRU( i810ContextPtr imesa )
{
   int i, j;
   drm_i810_tex_region_t *list = imesa->sarea->texList;

   for (i = 0, j = I810_NR_TEX_REGIONS ; i < I810_NR_TEX_REGIONS ; i++) {
      fprintf(stderr, "list[%d] age %d next %d prev %d\n",
	      j, list[j].age, list[j].next, list[j].prev);
      j = list[j].next;
      if (j == I810_NR_TEX_REGIONS) break;
   }
   
   if (j != I810_NR_TEX_REGIONS)
      fprintf(stderr, "Loop detected in global LRU\n");
}


void i810ResetGlobalLRU( i810ContextPtr imesa )
{
   drm_i810_tex_region_t *list = imesa->sarea->texList;
   int sz = 1 << imesa->i810Screen->logTextureGranularity;
   int i;

   /* (Re)initialize the global circular LRU list.  The last element
    * in the array (I810_NR_TEX_REGIONS) is the sentinal.  Keeping it
    * at the end of the array allows it to be addressed rationally
    * when looking up objects at a particular location in texture
    * memory.  
    */
   for (i = 0 ; (i+1) * sz <= imesa->i810Screen->textureSize ; i++) {
      list[i].prev = i-1;
      list[i].next = i+1;
      list[i].age = 0;
   }

   i--;
   list[0].prev = I810_NR_TEX_REGIONS;
   list[i].prev = i-1;
   list[i].next = I810_NR_TEX_REGIONS;
   list[I810_NR_TEX_REGIONS].prev = i;
   list[I810_NR_TEX_REGIONS].next = 0;
   imesa->sarea->texAge = 0;
}


static void i810UpdateTexLRU( i810ContextPtr imesa, i810TextureObjectPtr t ) 
{
   int i;
   int logsz = imesa->i810Screen->logTextureGranularity;
   int start = t->MemBlock->ofs >> logsz;
   int end = (t->MemBlock->ofs + t->MemBlock->size - 1) >> logsz;
   drm_i810_tex_region_t *list = imesa->sarea->texList;
   
   imesa->texAge = ++imesa->sarea->texAge;

   /* Update our local LRU
    */
   move_to_head( &(imesa->TexObjList), t );

   /* Update the global LRU
    */
   for (i = start ; i <= end ; i++) {

      list[i].in_use = 1;
      list[i].age = imesa->texAge;

      /* remove_from_list(i)
       */
      list[(unsigned)list[i].next].prev = list[i].prev;
      list[(unsigned)list[i].prev].next = list[i].next;
      
      /* insert_at_head(list, i)
       */
      list[i].prev = I810_NR_TEX_REGIONS;
      list[i].next = list[I810_NR_TEX_REGIONS].next;
      list[(unsigned)list[I810_NR_TEX_REGIONS].next].prev = i;
      list[I810_NR_TEX_REGIONS].next = i;
   }
}


/* Called for every shared texture region which has increased in age
 * since we last held the lock.
 *
 * Figures out which of our textures have been ejected by other clients,
 * and pushes a placeholder texture onto the LRU list to represent 
 * the other client's textures.  
 */
void i810TexturesGone( i810ContextPtr imesa,
		       GLuint offset, 
		       GLuint size,
		       GLuint in_use ) 
{
   i810TextureObjectPtr t, tmp;
   
   foreach_s ( t, tmp, &imesa->TexObjList ) {

      if (t->MemBlock->ofs >= offset + size ||
	  t->MemBlock->ofs + t->MemBlock->size <= offset)
	 continue;

      /* It overlaps - kick it off.  Need to hold onto the currently bound
       * objects, however.
       */
      if (t->bound)
	 i810SwapOutTexObj( imesa, t );
      else
	 i810DestroyTexObj( imesa, t );
   }

   
   if (in_use) {
      t = (i810TextureObjectPtr) calloc(1,sizeof(*t));
      if (!t) return;

      t->MemBlock = mmAllocMem( imesa->texHeap, size, 0, offset);      
      insert_at_head( &imesa->TexObjList, t );
   }
}





/* This is called with the lock held.  May have to eject our own and/or
 * other client's texture objects to make room for the upload.
 */
int i810UploadTexImages( i810ContextPtr imesa, i810TextureObjectPtr t )
{
   int i;
   int ofs;

   /* Do we need to eject LRU texture objects?
    */
   if (!t->MemBlock) {
      while (1)
      {
	 t->MemBlock = mmAllocMem( imesa->texHeap, t->totalSize, 12, 0 ); 
	 if (t->MemBlock)
	    break;

	 if (imesa->TexObjList.prev->bound) {
  	    fprintf(stderr, "Hit bound texture in upload\n"); 
	    i810PrintLocalLRU( imesa );
	    return -1;
	 }

	 if (imesa->TexObjList.prev == &(imesa->TexObjList)) {
 	    fprintf(stderr, "Failed to upload texture, sz %d\n", t->totalSize);
	    mmDumpMemInfo( imesa->texHeap );
	    return -1;
	 }
	 
	 i810DestroyTexObj( imesa, imesa->TexObjList.prev );
      }
 
      ofs = t->MemBlock->ofs;
      t->Setup[I810_TEXREG_MI3] = imesa->i810Screen->textureOffset + ofs;
      t->BufAddr = imesa->i810Screen->tex.map + ofs;
      imesa->dirty |= I810_UPLOAD_CTX;
   }

   /* Let the world know we've used this memory recently.
    */
   i810UpdateTexLRU( imesa, t );

   if (I810_DEBUG & DEBUG_VERBOSE_LRU)
      fprintf(stderr, "dispatch age: %d age freed memory: %d\n",
	      GET_DISPATCH_AGE(imesa), imesa->dirtyAge);

   if (imesa->dirtyAge >= GET_DISPATCH_AGE(imesa)) 
      i810WaitAgeLocked( imesa, imesa->dirtyAge );
   

   if (t->dirty_images) {
      if (I810_DEBUG & DEBUG_VERBOSE_LRU)
	 fprintf(stderr, "*");

      for (i = t->min_level ; i <= t->max_level ; i++)
	 if (t->dirty_images & (1<<i)) 
	    i810UploadTexLevel( t, i );
   }


   t->dirty_images = 0;
   return 0;
}

static void i810TexSetUnit( i810TextureObjectPtr t, GLuint unit )
{
   if (t->current_unit == unit) return;

   t->Setup[I810_TEXREG_MI1] ^= (MI1_MAP_0 ^ MI1_MAP_1);
   t->Setup[I810_TEXREG_MLC] ^= (MLC_MAP_0 ^ MLC_MAP_1);
   t->Setup[I810_TEXREG_MLL] ^= (MLL_MAP_0 ^ MLL_MAP_1);
   t->Setup[I810_TEXREG_MCS] ^= (MCS_COORD_0 ^ MCS_COORD_1);
   t->Setup[I810_TEXREG_MF]  ^= (MF_MAP_0 ^ MF_MAP_1);

   t->current_unit = unit;
}




static void i810UpdateTex0State( GLcontext *ctx )
{
   i810ContextPtr imesa = I810_CONTEXT(ctx);
   struct gl_texture_object	*tObj;
   i810TextureObjectPtr t;
   int ma_modulate_op;
   int format;

   /* disable */
   imesa->Setup[I810_CTXREG_MT] &= ~MT_TEXEL0_ENABLE;
   imesa->Setup[I810_CTXREG_MC0] = ( GFX_OP_MAP_COLOR_STAGES |
                                     MC_STAGE_0 |
                                     MC_UPDATE_DEST |
                                     MC_DEST_CURRENT |
                                     MC_UPDATE_ARG1 |
                                     MC_ARG1_ITERATED_COLOR | 
                                     MC_UPDATE_ARG2 |
                                     MC_ARG2_ONE |
                                     MC_UPDATE_OP |
                                     MC_OP_ARG1 );
   imesa->Setup[I810_CTXREG_MA0] = ( GFX_OP_MAP_ALPHA_STAGES |
                                     MA_STAGE_0 |
                                     MA_UPDATE_ARG1 |
                                     MA_ARG1_ITERATED_ALPHA |
                                     MA_UPDATE_ARG2 |
                                     MA_ARG2_TEX0_ALPHA |
                                     MA_UPDATE_OP |
                                     MA_OP_ARG1 );

   if (ctx->Texture.Unit[0].ReallyEnabled == 0) {
      return;
   }

   tObj = ctx->Texture.Unit[0].Current;
   if (ctx->Texture.Unit[0].ReallyEnabled != TEXTURE0_2D ||
       tObj->Image[tObj->BaseLevel]->Border > 0) {
      /* 1D or 3D texturing enabled, or texture border - fallback */
      imesa->Fallback |= I810_FALLBACK_TEXTURE;
      return;
   }

   /* Do 2D texture setup */

   imesa->Setup[I810_CTXREG_MT] |= MT_TEXEL0_ENABLE;

   t = tObj->DriverData;
   if (!t) {
      t = i810CreateTexObj( imesa, tObj );
      if (!t)
         return;
   }

   if (t->current_unit != 0)
      i810TexSetUnit( t, 0 );
    
   if (t->dirty_images) 
      imesa->dirty |= I810_UPLOAD_TEX0IMAGE;
   
   imesa->CurrentTexObj[0] = t;
   t->bound = 1;

   if (t->MemBlock)
      i810UpdateTexLRU( imesa, t );
  
   format = t->image[0].internalFormat;

   switch (ctx->Texture.Unit[0].EnvMode) {
   case GL_REPLACE:
      if (format == GL_ALPHA) 
	 imesa->Setup[I810_CTXREG_MC0] = ( GFX_OP_MAP_COLOR_STAGES |
					   MC_STAGE_0 |
					   MC_UPDATE_DEST |
					   MC_DEST_CURRENT |
					   MC_UPDATE_ARG1 |
					   MC_ARG1_TEX0_COLOR | 
					   MC_UPDATE_ARG2 |
					   MC_ARG2_ITERATED_COLOR |
					   MC_UPDATE_OP |
					   MC_OP_ARG2 );
      else 
	 imesa->Setup[I810_CTXREG_MC0] = ( GFX_OP_MAP_COLOR_STAGES |
					   MC_STAGE_0 |
					   MC_UPDATE_DEST |
					   MC_DEST_CURRENT |
					   MC_UPDATE_ARG1 |
					   MC_ARG1_TEX0_COLOR | 
					   MC_UPDATE_ARG2 |
					   MC_ARG2_ONE |
					   MC_UPDATE_OP |
					   MC_OP_ARG1 );

      if (format == GL_RGB) {
	 ma_modulate_op = MA_OP_ARG1;
      } else {
	 ma_modulate_op = MA_OP_ARG2;
      }

      imesa->Setup[I810_CTXREG_MA0] = ( GFX_OP_MAP_ALPHA_STAGES |
					MA_STAGE_0 |
					MA_UPDATE_ARG1 |
					MA_ARG1_ITERATED_ALPHA |
					MA_UPDATE_ARG2 |
					MA_ARG2_TEX0_ALPHA |
					MA_UPDATE_OP |
					ma_modulate_op );
      break;
   case GL_MODULATE:
      imesa->Setup[I810_CTXREG_MC0] = ( GFX_OP_MAP_COLOR_STAGES |
					MC_STAGE_0 |
					MC_UPDATE_DEST |
					MC_DEST_CURRENT |
					MC_UPDATE_ARG1 |
					MC_ARG1_TEX0_COLOR | 
					MC_UPDATE_ARG2 |
					MC_ARG2_ITERATED_COLOR |
					MC_UPDATE_OP |
					MC_OP_MODULATE );

      if (format == GL_RGB) {
	 ma_modulate_op = MA_OP_ARG1;
      } else {
	 ma_modulate_op = MA_OP_MODULATE;
      }
	
      imesa->Setup[I810_CTXREG_MA0] = ( GFX_OP_MAP_ALPHA_STAGES |
					MA_STAGE_0 |
					MA_UPDATE_ARG1 |
					MA_ARG1_ITERATED_ALPHA |
					MA_UPDATE_ARG2 |
					MA_ARG2_TEX0_ALPHA |
					MA_UPDATE_OP |
					MA_OP_MODULATE );
      break;

   case GL_ADD:
      if (format == GL_ALPHA) {
         /* Cv = Cf */
	 imesa->Setup[I810_CTXREG_MC0] = ( GFX_OP_MAP_COLOR_STAGES |
					   MC_STAGE_0 |
					   MC_UPDATE_DEST |
					   MC_DEST_CURRENT |
					   MC_UPDATE_ARG1 |
					   MC_ARG1_TEX0_COLOR | 
					   MC_UPDATE_ARG2 |
					   MC_ARG2_ITERATED_COLOR |
					   MC_UPDATE_OP |
					   MC_OP_ARG2 );
      }
      else {
         /* Cv = Cf + Ct */
         imesa->Setup[I810_CTXREG_MC0] = ( GFX_OP_MAP_COLOR_STAGES |
                                           MC_STAGE_0 |
                                           MC_UPDATE_DEST |
                                           MC_DEST_CURRENT |
                                           MC_UPDATE_ARG1 |
                                           MC_ARG1_TEX0_COLOR | 
                                           MC_UPDATE_ARG2 |
                                           MC_ARG2_ITERATED_COLOR |
                                           MC_UPDATE_OP |
                                           MC_OP_ADD );
      }

      /* alpha */
      if (format == GL_ALPHA ||
          format == GL_LUMINANCE_ALPHA ||
          format == GL_RGBA) {
         /* Av = Af * At */
         imesa->Setup[I810_CTXREG_MA0] = ( GFX_OP_MAP_ALPHA_STAGES |
                                           MA_STAGE_0 |
                                           MA_UPDATE_ARG1 |
                                           MA_ARG1_ITERATED_ALPHA |
                                           MA_UPDATE_ARG2 |
                                           MA_ARG2_TEX0_ALPHA |
                                           MA_UPDATE_OP |
                                           MA_OP_MODULATE );
      }
      else if (format == GL_LUMINANCE || format == GL_RGB) {
         /* Av = Af */
         imesa->Setup[I810_CTXREG_MA0] = ( GFX_OP_MAP_ALPHA_STAGES |
                                           MA_STAGE_0 |
                                           MA_UPDATE_ARG1 |
                                           MA_ARG1_ITERATED_ALPHA |
                                           MA_UPDATE_ARG2 |
                                           MA_ARG2_ITERATED_ALPHA |
                                           MA_UPDATE_OP |
                                           MA_OP_ARG1 );
      }
      else {
         /* Av = Af + At */
         imesa->Setup[I810_CTXREG_MA0] = ( GFX_OP_MAP_ALPHA_STAGES |
                                           MA_STAGE_0 |
                                           MA_UPDATE_ARG1 |
                                           MA_ARG1_ITERATED_ALPHA |
                                           MA_UPDATE_ARG2 |
                                           MA_ARG2_TEX0_ALPHA |
                                           MA_UPDATE_OP |
                                           MA_OP_ADD );
      }
      break;

   case GL_DECAL:
      if (format == GL_RGB) {
         /* C = Ct */
	 imesa->Setup[I810_CTXREG_MC0] = ( GFX_OP_MAP_COLOR_STAGES |
					   MC_STAGE_0 |
					   MC_UPDATE_DEST |
					   MC_DEST_CURRENT |
					   MC_UPDATE_ARG1 |
					   MC_ARG1_COLOR_FACTOR | 
					   MC_UPDATE_ARG2 |
					   MC_ARG2_TEX0_COLOR |
					   MC_UPDATE_OP |
					   MC_OP_ARG2 );

      } else {
         /* RGBA or undefined result */
         /* C = Cf*(1-At)+Ct*At */
	 imesa->Setup[I810_CTXREG_MC0] = ( GFX_OP_MAP_COLOR_STAGES |
					   MC_STAGE_0 |
					   MC_UPDATE_DEST |
					   MC_DEST_CURRENT |
					   MC_UPDATE_ARG1 |
					   MC_ARG1_TEX0_COLOR |
					   MC_UPDATE_ARG2 |
					   MC_ARG2_ITERATED_COLOR | 
					   MC_UPDATE_OP |
					   MC_OP_LIN_BLEND_TEX0_ALPHA );
      }

      /* Av = Af */
      imesa->Setup[I810_CTXREG_MA0] = ( GFX_OP_MAP_ALPHA_STAGES |
					MA_STAGE_0 |
					MA_UPDATE_ARG1 |
					MA_ARG1_ITERATED_ALPHA |
					MA_UPDATE_ARG2 |
					MA_ARG2_ITERATED_ALPHA |
					MA_UPDATE_OP |
					MA_OP_ARG1 );
      break;
   case GL_BLEND:
      if (format == GL_ALPHA) 
	 imesa->Setup[I810_CTXREG_MC0] = ( GFX_OP_MAP_COLOR_STAGES |
					   MC_STAGE_0 |
					   MC_UPDATE_DEST |
					   MC_DEST_CURRENT |
					   MC_UPDATE_ARG1 |
					   MC_ARG1_TEX0_COLOR | 
					   MC_UPDATE_ARG2 |
					   MC_ARG2_ITERATED_COLOR |
					   MC_UPDATE_OP |
					   MC_OP_ARG2 );
      else 
	 imesa->Setup[I810_CTXREG_MC0] = ( GFX_OP_MAP_COLOR_STAGES |
					   MC_STAGE_0 |
					   MC_UPDATE_DEST |
					   MC_DEST_CURRENT |
					   MC_UPDATE_ARG1 |
					   MC_ARG1_COLOR_FACTOR | 
					   MC_UPDATE_ARG2 |
					   MC_ARG2_ITERATED_COLOR |
					   MC_UPDATE_OP |
					   MC_OP_LIN_BLEND_TEX0_COLOR );

      /* alpha */
      if (format == GL_LUMINANCE || format == GL_RGB) {
         /* Av = Af */
         imesa->Setup[I810_CTXREG_MA0] = ( GFX_OP_MAP_ALPHA_STAGES |
                                           MA_STAGE_0 |
                                           MA_UPDATE_ARG1 |
                                           MA_ARG1_ITERATED_ALPHA |
                                           MA_UPDATE_ARG2 |
                                           MA_ARG2_ITERATED_ALPHA |
                                           MA_UPDATE_OP |
                                           MA_OP_ARG1 );
      }
      else if (format == GL_INTENSITY) {
         /* Av = Af(1-It)+AcIt */
	 imesa->Setup[I810_CTXREG_MA0] = ( GFX_OP_MAP_ALPHA_STAGES |
					   MA_STAGE_0 |
					   MA_UPDATE_ARG1 |
					   MA_ARG1_ALPHA_FACTOR |
					   MA_UPDATE_ARG2 |
					   MA_ARG2_ITERATED_ALPHA |
					   MA_UPDATE_OP |
					   MA_OP_LIN_BLEND_TEX0_ALPHA );
      } else {
         /* Av = AfAt */
	 imesa->Setup[I810_CTXREG_MA0] = ( GFX_OP_MAP_ALPHA_STAGES |
					   MA_STAGE_0 |
					   MA_UPDATE_ARG1 |
					   MA_ARG1_TEX0_ALPHA |
					   MA_UPDATE_ARG2 |
					   MA_ARG2_ITERATED_ALPHA |
					   MA_UPDATE_OP |
					   MA_OP_MODULATE );
      }
      break;

   default:
      fprintf(stderr, "unknown tex env mode");
      exit(1);
      break;			
   }
}



static void i810UpdateTex1State( GLcontext *ctx )
{
   i810ContextPtr imesa = I810_CONTEXT(ctx);
   struct gl_texture_object	*tObj;
   i810TextureObjectPtr t;
   int ma_modulate_op, format;

   /* disable */
   imesa->Setup[I810_CTXREG_MT] &= ~MT_TEXEL1_ENABLE;
   imesa->Setup[I810_CTXREG_MC1] = ( GFX_OP_MAP_COLOR_STAGES |
                                     MC_STAGE_1 |
                                     MC_UPDATE_DEST |
                                     MC_DEST_CURRENT |
                                     MC_UPDATE_ARG1 |
                                     MC_ARG1_ONE | 
                                     MC_ARG1_DONT_REPLICATE_ALPHA |
                                     MC_ARG1_DONT_INVERT |
                                     MC_UPDATE_ARG2 |
                                     MC_ARG2_ONE |
                                     MC_ARG2_DONT_REPLICATE_ALPHA |
                                     MC_ARG2_DONT_INVERT |
                                     MC_UPDATE_OP |
                                     MC_OP_DISABLE );
   imesa->Setup[I810_CTXREG_MA1] = ( GFX_OP_MAP_ALPHA_STAGES |
                                     MA_STAGE_1 |
                                     MA_UPDATE_ARG1 |
                                     MA_ARG1_CURRENT_ALPHA |
                                     MA_ARG1_DONT_INVERT |
                                     MA_UPDATE_ARG2 |
                                     MA_ARG2_CURRENT_ALPHA |
                                     MA_ARG2_DONT_INVERT |
                                     MA_UPDATE_OP |
                                     MA_OP_ARG1 );

   if (ctx->Texture.Unit[1].ReallyEnabled == 0) {
      return;
   }

   tObj = ctx->Texture.Unit[1].Current;
   if (ctx->Texture.Unit[1].ReallyEnabled != TEXTURE0_2D ||
       tObj->Image[tObj->BaseLevel]->Border > 0) {
      /* 1D or 3D texturing enabled, or texture border - fallback */
      imesa->Fallback |= I810_FALLBACK_TEXTURE;
      return;
   }

   /* Do 2D texture setup */

   imesa->Setup[I810_CTXREG_MT] |= MT_TEXEL1_ENABLE;

   t = tObj->DriverData;
   if (!t) {
      t = i810CreateTexObj( imesa, tObj );
      if (!t)
         return;
   }
    
   if (t->current_unit != 1)
      i810TexSetUnit( t, 1 );

   if (t->dirty_images) 
      imesa->dirty |= I810_UPLOAD_TEX1IMAGE;

   imesa->CurrentTexObj[1] = t;
   t->bound = 2;

   if (t->MemBlock)
      i810UpdateTexLRU( imesa, t );

   format = t->image[0].internalFormat;

   switch (ctx->Texture.Unit[1].EnvMode) {
   case GL_REPLACE:
      imesa->Setup[I810_CTXREG_MC1] = ( GFX_OP_MAP_COLOR_STAGES |
					MC_STAGE_1 |
					MC_UPDATE_DEST |
					MC_DEST_CURRENT |
					MC_UPDATE_ARG1 |
					MC_ARG1_TEX1_COLOR | 
					MC_UPDATE_ARG2 |
					MC_ARG2_ONE |
					MC_UPDATE_OP |
					MC_OP_ARG1 );

      if (format == GL_RGB) {
	 ma_modulate_op = MA_OP_ARG1;
      } else {
	 ma_modulate_op = MA_OP_ARG2;
      }

      imesa->Setup[I810_CTXREG_MA1] = ( GFX_OP_MAP_ALPHA_STAGES |
					MA_STAGE_1 |
					MA_UPDATE_ARG1 |
					MA_ARG1_CURRENT_ALPHA |
					MA_UPDATE_ARG2 |
					MA_ARG2_TEX1_ALPHA |
					MA_UPDATE_OP |
					ma_modulate_op );
      break;
   case GL_MODULATE:
      imesa->Setup[I810_CTXREG_MC1] = ( GFX_OP_MAP_COLOR_STAGES |
					MC_STAGE_1 |
					MC_UPDATE_DEST |
					MC_DEST_CURRENT |
					MC_UPDATE_ARG1 |
					MC_ARG1_TEX1_COLOR | 
					MC_UPDATE_ARG2 |
					MC_ARG2_CURRENT_COLOR |
					MC_UPDATE_OP |
					MC_OP_MODULATE );

      if (format == GL_RGB) {
	 ma_modulate_op = MA_OP_ARG1;
      } else {
	 ma_modulate_op = MA_OP_MODULATE;
      }
	
      imesa->Setup[I810_CTXREG_MA1] = ( GFX_OP_MAP_ALPHA_STAGES |
					MA_STAGE_1 |
					MA_UPDATE_ARG1 |
					MA_ARG1_CURRENT_ALPHA |
					MA_UPDATE_ARG2 |
					MA_ARG2_TEX1_ALPHA |
					MA_UPDATE_OP |
					ma_modulate_op );
      break;

   case GL_ADD:
      imesa->Setup[I810_CTXREG_MC1] = ( GFX_OP_MAP_COLOR_STAGES |
					MC_STAGE_1 |
					MC_UPDATE_DEST |
					MC_DEST_CURRENT |
					MC_UPDATE_ARG1 |
					MC_ARG1_TEX1_COLOR | 
					MC_UPDATE_ARG2 |
					MC_ARG2_CURRENT_COLOR |
					MC_UPDATE_OP |
					MC_OP_ADD );

      if (format == GL_RGB) {
	 ma_modulate_op = MA_OP_ARG1;
      } else {
	 ma_modulate_op = MA_OP_ADD;
      }
	
      imesa->Setup[I810_CTXREG_MA1] = ( GFX_OP_MAP_ALPHA_STAGES |
					MA_STAGE_1 |
					MA_UPDATE_ARG1 |
					MA_ARG1_CURRENT_ALPHA |
					MA_UPDATE_ARG2 |
					MA_ARG2_TEX1_ALPHA |
					MA_UPDATE_OP |
					ma_modulate_op );
      break;


   case GL_DECAL:
      if (format == GL_RGB) {
	 imesa->Setup[I810_CTXREG_MC1] = ( GFX_OP_MAP_COLOR_STAGES |
					   MC_STAGE_1 |
					   MC_UPDATE_DEST |
					   MC_DEST_CURRENT |
					   MC_UPDATE_ARG1 |
					   MC_ARG1_COLOR_FACTOR | 
					   MC_UPDATE_ARG2 |
					   MC_ARG2_TEX1_COLOR |
					   MC_UPDATE_OP |
					   MC_OP_ARG2 );

      } else {
	 imesa->Setup[I810_CTXREG_MC1] = ( GFX_OP_MAP_COLOR_STAGES |
					   MC_STAGE_1 |
					   MC_UPDATE_DEST |
					   MC_DEST_CURRENT |
					   MC_UPDATE_ARG1 |
					   MC_ARG1_COLOR_FACTOR | 
					   MC_UPDATE_ARG2 |
					   MC_ARG2_TEX1_COLOR |
					   MC_UPDATE_OP |
					   MC_OP_LIN_BLEND_TEX1_ALPHA );
      }

      imesa->Setup[I810_CTXREG_MA1] = ( GFX_OP_MAP_ALPHA_STAGES |
					MA_STAGE_1 |
					MA_UPDATE_ARG1 |
					MA_ARG1_ALPHA_FACTOR |
					MA_UPDATE_ARG2 |
					MA_ARG2_ALPHA_FACTOR |
					MA_UPDATE_OP |
					MA_OP_ARG1 );
      break;

   case GL_BLEND:
      imesa->Setup[I810_CTXREG_MC1] = ( GFX_OP_MAP_COLOR_STAGES |
					MC_STAGE_1 |
					MC_UPDATE_DEST |
					MC_DEST_CURRENT |
					MC_UPDATE_ARG1 |
					MC_ARG1_COLOR_FACTOR | 
					MC_UPDATE_ARG2 |
					MC_ARG2_CURRENT_COLOR |
					MC_UPDATE_OP |
					MC_OP_LIN_BLEND_TEX1_COLOR );

      if (format == GL_RGB) {
	 imesa->Setup[I810_CTXREG_MA1] = ( GFX_OP_MAP_ALPHA_STAGES |
					   MA_STAGE_1 |
					   MA_UPDATE_ARG1 |
					   MA_ARG1_ALPHA_FACTOR |
					   MA_UPDATE_ARG2 |
					   MA_ARG2_CURRENT_ALPHA |
					   MA_UPDATE_OP |
					   MA_OP_ARG1 );
      } else {
	 imesa->Setup[I810_CTXREG_MA1] = ( GFX_OP_MAP_ALPHA_STAGES |
					   MA_STAGE_1 |
					   MA_UPDATE_ARG1 |
					   MA_ARG1_ALPHA_FACTOR |
					   MA_UPDATE_ARG2 |
					   MA_ARG2_ITERATED_ALPHA |
					   MA_UPDATE_OP |
					   MA_OP_LIN_BLEND_TEX1_ALPHA );
      }
      break;

   default:
      fprintf(stderr, "unkown tex 1 env mode\n");
      exit(1);
      break;			
   }
}


void i810UpdateTextureState( GLcontext *ctx )
{
   i810ContextPtr imesa = I810_CONTEXT(ctx);
   if (imesa->CurrentTexObj[0]) imesa->CurrentTexObj[0]->bound = 0;
   if (imesa->CurrentTexObj[1]) imesa->CurrentTexObj[1]->bound = 0;
   imesa->CurrentTexObj[0] = 0;
   imesa->CurrentTexObj[1] = 0;   
   imesa->Fallback &= ~I810_FALLBACK_TEXTURE;
   i810UpdateTex0State( ctx );
   i810UpdateTex1State( ctx );
   I810_CONTEXT( ctx )->dirty |= (I810_UPLOAD_CTX |
                                  I810_UPLOAD_TEX0 | 
                                  I810_UPLOAD_TEX1);
}



/*****************************************
 * DRIVER functions
 *****************************************/

static void i810TexEnv( GLcontext *ctx, GLenum target, 
			GLenum pname, const GLfloat *param )
{
   i810ContextPtr imesa = I810_CONTEXT( ctx );

   if (pname == GL_TEXTURE_ENV_MODE) {

      FLUSH_BATCH(imesa);	
      imesa->new_state |= I810_NEW_TEXTURE;

   } else if (pname == GL_TEXTURE_ENV_COLOR) {

      struct gl_texture_unit *texUnit = 
	 &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
      const GLfloat *fc = texUnit->EnvColor;
      GLuint r, g, b, a, col;
      FLOAT_COLOR_TO_UBYTE_COLOR(r, fc[0]);
      FLOAT_COLOR_TO_UBYTE_COLOR(g, fc[1]);
      FLOAT_COLOR_TO_UBYTE_COLOR(b, fc[2]);
      FLOAT_COLOR_TO_UBYTE_COLOR(a, fc[3]);

      col = ((a << 24) | 
	     (r << 16) | 
	     (g <<  8) | 
	     (b <<  0));
    
      if (imesa->Setup[I810_CTXREG_CF1] != col) {
	 FLUSH_BATCH(imesa);	
	 imesa->Setup[I810_CTXREG_CF1] = col;      
	 imesa->dirty |= I810_UPLOAD_CTX;
      }
   } 
}

static void i810TexImage( GLcontext *ctx, 
			  GLenum target,
			  struct gl_texture_object *tObj, 
			  GLint level,
			  GLint internalFormat,
			  const struct gl_texture_image *image )
{
   i810ContextPtr imesa = I810_CONTEXT( ctx );
   i810TextureObjectPtr t;

   if (target != GL_TEXTURE_2D)
      return;

   if (level >= I810_TEX_MAXLEVELS)
      return;

   t = (i810TextureObjectPtr) tObj->DriverData;
   if (t) {
      if (t->bound) FLUSH_BATCH(imesa);
      /* if this is the current object, it will force an update */
      i810DestroyTexObj( imesa, t );
      tObj->DriverData = 0;
      imesa->new_state |= I810_NEW_TEXTURE;
   }
}

static void i810TexSubImage( GLcontext *ctx, GLenum target,
			     struct gl_texture_object *tObj, GLint level,
			     GLint xoffset, GLint yoffset,
			     GLsizei width, GLsizei height,
			     GLint internalFormat,
			     const struct gl_texture_image *image ) 
{
   i810ContextPtr imesa = I810_CONTEXT( ctx );
   i810TextureObjectPtr t;

   if ( target != GL_TEXTURE_2D ) 
      return;
   
   t = (i810TextureObjectPtr) tObj->DriverData;
   if (t) {
      if (t->bound) FLUSH_BATCH( imesa );
      i810DestroyTexObj( imesa, t );
      tObj->DriverData = 0;
      imesa->new_state |= I810_NEW_TEXTURE;
   }
}

static void i810TexParameter( GLcontext *ctx, GLenum target,
			      struct gl_texture_object *tObj,
			      GLenum pname, const GLfloat *params )
{
   i810TextureObjectPtr t = (i810TextureObjectPtr) tObj->DriverData;
   i810ContextPtr imesa = I810_CONTEXT( ctx );

   if (!t || target != GL_TEXTURE_2D)
      return;

   switch (pname) {
   case GL_TEXTURE_MIN_FILTER:
   case GL_TEXTURE_MAG_FILTER:
      if (t->bound) FLUSH_BATCH( imesa );
      i810SetTexFilter(imesa, t,tObj->MinFilter,tObj->MagFilter);
      break;

   case GL_TEXTURE_WRAP_S:
   case GL_TEXTURE_WRAP_T:
      if (t->bound) FLUSH_BATCH( imesa );
      i810SetTexWrapping(t,tObj->WrapS,tObj->WrapT);
      break;
  
   case GL_TEXTURE_BORDER_COLOR:
      if (t->bound) FLUSH_BATCH( imesa );
      i810SetTexBorderColor(t,tObj->BorderColor);
      break;

   default:
      return;
   }

   imesa->new_state |= I810_NEW_TEXTURE;
}

static void i810BindTexture( GLcontext *ctx, GLenum target,
			     struct gl_texture_object *tObj )
{
   i810ContextPtr imesa = I810_CONTEXT( ctx );
   
   FLUSH_BATCH(imesa);

   if (imesa->CurrentTexObj[ctx->Texture.CurrentUnit]) {
      imesa->CurrentTexObj[ctx->Texture.CurrentUnit]->bound = 0;
      imesa->CurrentTexObj[ctx->Texture.CurrentUnit] = 0;  
   }

   imesa->new_state |= I810_NEW_TEXTURE;
}

static void i810DeleteTexture( GLcontext *ctx, struct gl_texture_object *tObj )
{
   i810TextureObjectPtr t = (i810TextureObjectPtr)tObj->DriverData;
   i810ContextPtr imesa = I810_CONTEXT( ctx );

   if (t) {

      if (t->bound) {
	 FLUSH_BATCH(imesa);
	 imesa->CurrentTexObj[t->bound-1] = 0;
	 imesa->new_state |= I810_NEW_TEXTURE;
      }

      i810DestroyTexObj(imesa,t);
      tObj->DriverData=0;
   }
}


static GLboolean i810IsTextureResident( GLcontext *ctx, 
					struct gl_texture_object *t )
{
   i810TextureObjectPtr mt;

/*     LOCK_HARDWARE; */
   mt = (i810TextureObjectPtr)t->DriverData;
/*     UNLOCK_HARDWARE; */

   return mt && mt->MemBlock;
}

void i810DDInitTextureFuncs( GLcontext *ctx )
{
   ctx->Driver.TexEnv = i810TexEnv;
   ctx->Driver.TexImage = i810TexImage;
   ctx->Driver.TexSubImage = i810TexSubImage;
   ctx->Driver.BindTexture = i810BindTexture;
   ctx->Driver.DeleteTexture = i810DeleteTexture;
   ctx->Driver.TexParameter = i810TexParameter;
   ctx->Driver.UpdateTexturePalette = 0;
   ctx->Driver.IsTextureResident = i810IsTextureResident;
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d24 1
a24 1
/* $XFree86: xc/lib/GL/mesa/src/drv/i810/i810tex.c,v 1.10 2003/09/28 20:15:12 alanh Exp $ */
d26 4
a29 10
#include "glheader.h"
#include "mtypes.h"
#include "imports.h"
#include "simple_list.h"
#include "enums.h"
#include "texstore.h"
#include "texformat.h"
#include "texmem.h"
#include "swrast/swrast.h"
#include "colormac.h"
a31 4

#include "i810screen.h"
#include "i810_dri.h"

d34 1
a34 1
#include "i810state.h"
d36 2
d39 1
a39 5

/*
 * Compute the 'S2.4' lod bias factor from the floating point OpenGL bias.
 */
static GLuint i810ComputeLodBias(GLfloat bias)
d41 1
a41 7
   int b = (int) (bias * 16.0) + 12;
   if (b > 63)
      b = 63;
   else if (b < -64)
      b = -64;
   return (GLuint) (b & MLC_LOD_BIAS_MASK);
}
d43 5
d49 2
a50 4
static void i810SetTexWrapping(i810TextureObjectPtr tex,
			       GLenum swrap, GLenum twrap)
{
   tex->Setup[I810_TEXREG_MCS] &= ~(MCS_U_STATE_MASK| MCS_V_STATE_MASK);
d52 1
a52 29
   switch( swrap ) {
   case GL_REPEAT:
      tex->Setup[I810_TEXREG_MCS] |= MCS_U_WRAP;
      break;
   case GL_CLAMP:
   case GL_CLAMP_TO_EDGE:
      tex->Setup[I810_TEXREG_MCS] |= MCS_U_CLAMP;
      break;
   case GL_MIRRORED_REPEAT:
      tex->Setup[I810_TEXREG_MCS] |= MCS_U_MIRROR;
      break;
   default:
      _mesa_problem(NULL, "bad S wrap mode in %s", __FUNCTION__);
   }

   switch( twrap ) {
   case GL_REPEAT:
      tex->Setup[I810_TEXREG_MCS] |= MCS_V_WRAP;
      break;
   case GL_CLAMP:
   case GL_CLAMP_TO_EDGE:
      tex->Setup[I810_TEXREG_MCS] |= MCS_V_CLAMP;
      break;
   case GL_MIRRORED_REPEAT:
      tex->Setup[I810_TEXREG_MCS] |= MCS_V_MIRROR;
      break;
   default:
      _mesa_problem(NULL, "bad T wrap mode in %s", __FUNCTION__);
   }
a54 1

d57 1
a57 2
			     GLenum minf, GLenum magf,
                             GLfloat bias)
d59 1
a59 4
   t->Setup[I810_TEXREG_MF] &= ~(MF_MIN_MASK|
				 MF_MAG_MASK|
				 MF_MIP_MASK);
   t->Setup[I810_TEXREG_MLC] &= ~(MLC_LOD_BIAS_MASK);
d63 3
a65 1
      t->Setup[I810_TEXREG_MF] |= MF_MIN_NEAREST | MF_MIP_NONE;
d68 3
a70 1
      t->Setup[I810_TEXREG_MF] |= MF_MIN_LINEAR | MF_MIP_NONE;
d73 3
a75 4
      t->Setup[I810_TEXREG_MF] |= MF_MIN_NEAREST | MF_MIP_NEAREST;
      if (magf == GL_LINEAR) {
         /*bias -= 0.5;*/  /* this doesn't work too good */
      }
d78 3
a80 1
      t->Setup[I810_TEXREG_MF] |= MF_MIN_LINEAR | MF_MIP_NEAREST;
d83 12
a94 7
      if (IS_I815(imesa)) 
	 t->Setup[I810_TEXREG_MF] |= MF_MIN_NEAREST | MF_MIP_LINEAR;
      else 
	 t->Setup[I810_TEXREG_MF] |= MF_MIN_NEAREST | MF_MIP_DITHER;
      /*
      if (magf == GL_LINEAR) {
         bias -= 0.5;
a95 2
      */
      bias -= 0.5; /* always biasing here looks better */
d98 9
a106 4
      if (IS_I815(imesa))
	 t->Setup[I810_TEXREG_MF] |= MF_MIN_LINEAR | MF_MIP_LINEAR;
      else 
	 t->Setup[I810_TEXREG_MF] |= MF_MIN_LINEAR | MF_MIP_DITHER;
d109 2
a110 1
      return;
d114 86
a199 2
   case GL_NEAREST: 
      t->Setup[I810_TEXREG_MF] |= MF_MAG_NEAREST; 
d201 6
a206 2
   case GL_LINEAR: 
      t->Setup[I810_TEXREG_MF] |= MF_MAG_LINEAR; 
d208 126
a333 2
   default: 
      return;
d336 2
a337 1
   t->Setup[I810_TEXREG_MLC] |= i810ComputeLodBias(bias);
d341 4
a344 2
static void i810SetTexBorderColor(i810TextureObjectPtr t, 
				  GLubyte color[4])
d346 103
a448 1
   /* Need a fallback.
d450 18
d469 4
a472 1
static i810TextureObjectPtr i810AllocTexObj( GLcontext *ctx, struct gl_texture_object *texObj )
d475 82
a556 1
   i810ContextPtr imesa = I810_CONTEXT(ctx);
d558 1
a558 5
   t = CALLOC_STRUCT( i810_texture_object_t );
   texObj->DriverData = t;
   if ( t != NULL ) {
      GLfloat bias = ctx->Texture.Unit[ctx->Texture.CurrentUnit].LodBias;
      /* Initialize non-image-dependent parts of the state:
d560 2
a561 24
      t->base.tObj = texObj;
      t->Setup[I810_TEXREG_MI0] = GFX_OP_MAP_INFO;
      t->Setup[I810_TEXREG_MI1] = MI1_MAP_0; 
      t->Setup[I810_TEXREG_MI2] = MI2_DIMENSIONS_ARE_LOG2;
      t->Setup[I810_TEXREG_MLC] = (GFX_OP_MAP_LOD_CTL | 
				   MLC_MAP_0 |
				   /*MLC_DITHER_WEIGHT_FULL |*/
				   MLC_DITHER_WEIGHT_12 |
				   MLC_UPDATE_LOD_BIAS |
				   0x0);
      t->Setup[I810_TEXREG_MCS] = (GFX_OP_MAP_COORD_SETS |
				   MCS_COORD_0 |
				   MCS_UPDATE_NORMALIZED |
				   MCS_NORMALIZED_COORDS |
				   MCS_UPDATE_V_STATE |
				   MCS_V_WRAP |
				   MCS_UPDATE_U_STATE |
				   MCS_U_WRAP);
      t->Setup[I810_TEXREG_MF] = (GFX_OP_MAP_FILTER |
				  MF_MAP_0 |
				  MF_UPDATE_ANISOTROPIC |
				  MF_UPDATE_MIP_FILTER |
				  MF_UPDATE_MAG_FILTER |
				  MF_UPDATE_MIN_FILTER);
d563 94
a656 1
      make_empty_list( & t->base );
d658 15
a672 4
      i810SetTexWrapping( t, texObj->WrapS, texObj->WrapT );
      /*i830SetTexMaxAnisotropy( t, texObj->MaxAnisotropy );*/
      i810SetTexFilter( imesa, t, texObj->MinFilter, texObj->MagFilter, bias );
      i810SetTexBorderColor( t, texObj->_BorderChan );
d675 16
a690 1
   return t;
d694 3
a696 3
static void i810TexParameter( GLcontext *ctx, GLenum target,
			      struct gl_texture_object *tObj,
			      GLenum pname, const GLfloat *params )
d699 27
a725 2
   i810TextureObjectPtr t = (i810TextureObjectPtr) tObj->DriverData;
   if (!t)
d727 1
d729 5
a733 1
   if ( target != GL_TEXTURE_2D )
d735 122
d858 35
a892 12
   /* Can't do the update now as we don't know whether to flush
    * vertices or not.  Setting imesa->new_state means that
    * i810UpdateTextureState() will be called before any triangles are
    * rendered.  If a statechange has occurred, it will be detected at
    * that point, and buffered vertices flushed.  
    */
   switch (pname) {
   case GL_TEXTURE_MIN_FILTER:
   case GL_TEXTURE_MAG_FILTER:
      {
         GLfloat bias = ctx->Texture.Unit[ctx->Texture.CurrentUnit].LodBias;
         i810SetTexFilter( imesa, t, tObj->MinFilter, tObj->MagFilter, bias );
d896 28
a923 8
   case GL_TEXTURE_WRAP_S:
   case GL_TEXTURE_WRAP_T:
      i810SetTexWrapping( t, tObj->WrapS, tObj->WrapT );
      break;
  
   case GL_TEXTURE_BORDER_COLOR:
      i810SetTexBorderColor( t, tObj->_BorderChan );
      break;
d925 67
a991 11
   case GL_TEXTURE_BASE_LEVEL:
   case GL_TEXTURE_MAX_LEVEL:
   case GL_TEXTURE_MIN_LOD:
   case GL_TEXTURE_MAX_LOD:
      /* This isn't the most efficient solution but there doesn't appear to
       * be a nice alternative for Radeon.  Since there's no LOD clamping,
       * we just have to rely on loading the right subset of mipmap levels
       * to simulate a clamped LOD.
       */
      I810_FIREVERTICES( I810_CONTEXT(ctx) );
      driSwapOutTextureObject( (driTextureObject *) t );
d995 51
d1049 9
a1057 2
   if (t == imesa->CurrentTexObj[0]) {
      I810_STATECHANGE( imesa, I810_UPLOAD_TEX0 );
d1059 33
d1093 139
a1231 2
   if (t == imesa->CurrentTexObj[1]) {
      I810_STATECHANGE( imesa, I810_UPLOAD_TEX1 );
d1236 21
a1260 1
   GLuint unit = ctx->Texture.CurrentUnit;
d1262 10
a1271 7
   /* Only one env color.  Need a fallback if env colors are different
    * and texture setup references env color in both units.  
    */
   switch (pname) {
   case GL_TEXTURE_ENV_COLOR: {
      struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
      GLfloat *fc = texUnit->EnvColor;
d1273 4
a1276 4
      CLAMPED_FLOAT_TO_UBYTE(r, fc[0]);
      CLAMPED_FLOAT_TO_UBYTE(g, fc[1]);
      CLAMPED_FLOAT_TO_UBYTE(b, fc[2]);
      CLAMPED_FLOAT_TO_UBYTE(a, fc[3]);
d1282 1
a1282 1
 
d1284 1
a1284 1
	 I810_STATECHANGE(imesa, I810_UPLOAD_CTX);	
d1286 1
d1288 2
a1289 5
      break;
   }
   case GL_TEXTURE_ENV_MODE:
      imesa->TexEnvImageFmt[unit] = 0; /* force recalc of env state */
      break;
d1291 9
a1299 13
   case GL_TEXTURE_LOD_BIAS_EXT:
      {
         struct gl_texture_object *tObj = ctx->Texture.Unit[unit]._Current;
         i810TextureObjectPtr t = (i810TextureObjectPtr) tObj->DriverData;
         t->Setup[I810_TEXREG_MLC] &= ~(MLC_LOD_BIAS_MASK);
         t->Setup[I810_TEXREG_MLC] |= i810ComputeLodBias(*param);
      }
      break;

   default:
      break;
   }
} 
d1301 2
d1304 2
d1307 1
a1307 11
#if 0
static void i810TexImage1D( GLcontext *ctx, GLenum target, GLint level,
			    GLint internalFormat,
			    GLint width, GLint border,
			    GLenum format, GLenum type, 
			    const GLvoid *pixels,
			    const struct gl_pixelstore_attrib *pack,
			    struct gl_texture_object *texObj,
			    struct gl_texture_image *texImage )
{
   i810TextureObjectPtr t = (i810TextureObjectPtr) texObj->DriverData;
d1309 5
a1313 1
      i810SwapOutTexObj( imesa, t );
d1317 6
a1322 10
static void i810TexSubImage1D( GLcontext *ctx, 
			       GLenum target,
			       GLint level,	
			       GLint xoffset,
			       GLsizei width,
			       GLenum format, GLenum type,
			       const GLvoid *pixels,
			       const struct gl_pixelstore_attrib *pack,
			       struct gl_texture_object *texObj,
			       struct gl_texture_image *texImage )
d1324 2
a1325 2
}
#endif
d1327 4
a1330 10

static void i810TexImage2D( GLcontext *ctx, GLenum target, GLint level,
			    GLint internalFormat,
			    GLint width, GLint height, GLint border,
			    GLenum format, GLenum type, const GLvoid *pixels,
			    const struct gl_pixelstore_attrib *packing,
			    struct gl_texture_object *texObj,
			    struct gl_texture_image *texImage )
{
   driTextureObject *t = (driTextureObject *) texObj->DriverData;
d1332 4
a1335 9
      I810_FIREVERTICES( I810_CONTEXT(ctx) );
      driSwapOutTextureObject( t );
   }
   else {
      t = (driTextureObject *) i810AllocTexObj( ctx, texObj );
      if (!t) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage2D");
         return;
      }
a1336 4
   _mesa_store_teximage2d( ctx, target, level, internalFormat,
			   width, height, border, format, type,
			   pixels, packing, texObj, texImage );

d1339 3
a1341 10
static void i810TexSubImage2D( GLcontext *ctx, 
			       GLenum target,
			       GLint level,	
			       GLint xoffset, GLint yoffset,
			       GLsizei width, GLsizei height,
			       GLenum format, GLenum type,
			       const GLvoid *pixels,
			       const struct gl_pixelstore_attrib *packing,
			       struct gl_texture_object *texObj,
			       struct gl_texture_image *texImage )
d1343 12
a1354 1
   driTextureObject *t = (driTextureObject *)texObj->DriverData;
d1356 13
a1368 3
   if (t) {
     I810_FIREVERTICES( I810_CONTEXT(ctx) );
     driSwapOutTextureObject( t );
a1369 3
   _mesa_store_texsubimage2d(ctx, target, level, xoffset, yoffset, width, 
			     height, format, type, pixels, packing, texObj,
			     texImage);
d1371 1
a1373 1

d1377 10
a1386 3
  if (!tObj->DriverData) {
      i810AllocTexObj( ctx, tObj );
  }
a1388 1

d1391 3
a1393 1
  driTextureObject * t = (driTextureObject *) tObj->DriverData;
a1394 6
      i810ContextPtr imesa = I810_CONTEXT( ctx );
      if (imesa)
         I810_FIREVERTICES( imesa );
      driDestroyTextureObject( t );
   }
}
d1396 4
a1399 12
static const struct gl_texture_format *
i810ChooseTextureFormat( GLcontext *ctx, GLint internalFormat,
			 GLenum format, GLenum type )
{
   switch ( internalFormat ) {
   case 4:
   case GL_RGBA:
   case GL_COMPRESSED_RGBA:
      if ( format == GL_BGRA ) {
         if ( type == GL_UNSIGNED_SHORT_1_5_5_5_REV ) {
	    return &_mesa_texformat_argb1555;
	 }
a1400 1
      return &_mesa_texformat_argb4444;
d1402 4
a1405 19
   case 3:
   case GL_RGB:
   case GL_COMPRESSED_RGB:
   case GL_R3_G3_B2:
   case GL_RGB4:
   case GL_RGB5:
   case GL_RGB8:
   case GL_RGB10:
   case GL_RGB12:
   case GL_RGB16:
     return &_mesa_texformat_rgb565;

   case GL_RGBA2:
   case GL_RGBA4:
   case GL_RGBA8:
   case GL_RGB10_A2:
   case GL_RGBA12:
   case GL_RGBA16:
      return &_mesa_texformat_argb4444;
a1406 2
   case GL_RGB5_A1:
      return &_mesa_texformat_argb1555;
d1408 4
a1411 7
   case GL_ALPHA:
   case GL_ALPHA4:
   case GL_ALPHA8:
   case GL_ALPHA12:
   case GL_ALPHA16:
   case GL_COMPRESSED_ALPHA:
      return &_mesa_texformat_al88;
d1413 3
a1415 8
   case 1:
   case GL_LUMINANCE:
   case GL_LUMINANCE4:
   case GL_LUMINANCE8:
   case GL_LUMINANCE12:
   case GL_LUMINANCE16:
   case GL_COMPRESSED_LUMINANCE:
      return &_mesa_texformat_rgb565;
d1417 1
a1417 30
   case 2:
   case GL_LUMINANCE_ALPHA:
   case GL_LUMINANCE4_ALPHA4:
   case GL_LUMINANCE6_ALPHA2:
   case GL_LUMINANCE8_ALPHA8:
   case GL_LUMINANCE12_ALPHA4:
   case GL_LUMINANCE12_ALPHA12:
   case GL_LUMINANCE16_ALPHA16:
   case GL_COMPRESSED_LUMINANCE_ALPHA:
   case GL_INTENSITY:
   case GL_INTENSITY4:
   case GL_INTENSITY8:
   case GL_INTENSITY12:
   case GL_INTENSITY16:
   case GL_COMPRESSED_INTENSITY:
      return &_mesa_texformat_argb4444;

   case GL_YCBCR_MESA:
      if (type == GL_UNSIGNED_SHORT_8_8_MESA ||
	  type == GL_UNSIGNED_BYTE)
         return &_mesa_texformat_ycbcr;
      else
         return &_mesa_texformat_ycbcr_rev;

   default:
      fprintf(stderr, "unexpected texture format in %s\n", __FUNCTION__);
      return NULL;
   }

   return NULL; /* never get here */
d1420 1
a1420 1
void i810InitTextureFuncs( GLcontext *ctx )
a1421 2
   i810ContextPtr imesa = I810_CONTEXT(ctx);

d1423 2
a1424 12
   ctx->Driver.ChooseTextureFormat = i810ChooseTextureFormat;
   ctx->Driver.TexImage1D = _mesa_store_teximage1d;
   ctx->Driver.TexImage2D = i810TexImage2D;
   ctx->Driver.TexImage3D = _mesa_store_teximage3d;
   ctx->Driver.TexSubImage1D = _mesa_store_texsubimage1d;
   ctx->Driver.TexSubImage2D = i810TexSubImage2D;
   ctx->Driver.TexSubImage3D = _mesa_store_texsubimage3d;
   ctx->Driver.CopyTexImage1D = _swrast_copy_teximage1d;
   ctx->Driver.CopyTexImage2D = _swrast_copy_teximage2d;
   ctx->Driver.CopyTexSubImage1D = _swrast_copy_texsubimage1d;
   ctx->Driver.CopyTexSubImage2D = _swrast_copy_texsubimage2d;
   ctx->Driver.CopyTexSubImage3D = _swrast_copy_texsubimage3d;
d1429 1
a1429 5
   ctx->Driver.IsTextureResident = driIsTextureResident;
   ctx->Driver.TestProxyTexImage = _mesa_test_proxy_teximage;

   driInitTextureObjects( ctx, &imesa->swapped, DRI_TEXMGR_DO_TEXTURE_2D);

@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d24 1
a24 1
/* $XFree86: xc/lib/GL/mesa/src/drv/i810/i810tex.c,v 1.9 2002/10/30 12:51:33 alanh Exp $ */
d29 1
a29 8
#include "glheader.h"
#include "mtypes.h"
#include "mem.h"
#include "simple_list.h"
#include "enums.h"
#include "texstore.h"
#include "texformat.h"
#include "swrast/swrast.h"
a31 4

#include "i810screen.h"
#include "i810_dri.h"

d34 1
a34 1
#include "i810state.h"
d36 2
d39 1
a39 5

/*
 * Compute the 'S2.4' lod bias factor from the floating point OpenGL bias.
 */
static GLuint i810ComputeLodBias(GLfloat bias)
d41 1
a41 7
   int b = (int) (bias * 16.0) + 12;
   if (b > 63)
      b = 63;
   else if (b < -64)
      b = -64;
   return (GLuint) (b & MLC_LOD_BIAS_MASK);
}
d43 5
d49 2
a50 11
static void i810SetTexWrapping(i810TextureObjectPtr t, 
			       GLenum wraps, GLenum wrapt)
{
   t->Setup[I810_TEXREG_MCS] &= ~(MCS_U_STATE_MASK| MCS_V_STATE_MASK);
   t->Setup[I810_TEXREG_MCS] |= (MCS_U_WRAP|MCS_V_WRAP);

   if (wraps != GL_REPEAT) 
      t->Setup[I810_TEXREG_MCS] ^= (MCS_U_WRAP^MCS_U_CLAMP);

   if (wrapt != GL_REPEAT) 
      t->Setup[I810_TEXREG_MCS] ^= (MCS_V_WRAP^MCS_V_CLAMP);
d52 1
a54 1

d57 1
a57 2
			     GLenum minf, GLenum magf,
                             GLfloat bias)
d59 1
a59 4
   t->Setup[I810_TEXREG_MF] &= ~(MF_MIN_MASK|
				 MF_MAG_MASK|
				 MF_MIP_MASK);
   t->Setup[I810_TEXREG_MLC] &= ~(MLC_LOD_BIAS_MASK);
d63 3
a65 1
      t->Setup[I810_TEXREG_MF] |= MF_MIN_NEAREST | MF_MIP_NONE;
d68 3
a70 1
      t->Setup[I810_TEXREG_MF] |= MF_MIN_LINEAR | MF_MIP_NONE;
d73 3
a75 4
      t->Setup[I810_TEXREG_MF] |= MF_MIN_NEAREST | MF_MIP_NEAREST;
      if (magf == GL_LINEAR) {
         /*bias -= 0.5;*/  /* this doesn't work too good */
      }
d78 3
a80 1
      t->Setup[I810_TEXREG_MF] |= MF_MIN_LINEAR | MF_MIP_NEAREST;
d83 12
a94 7
      if (IS_I815(imesa)) 
	 t->Setup[I810_TEXREG_MF] |= MF_MIN_NEAREST | MF_MIP_LINEAR;
      else 
	 t->Setup[I810_TEXREG_MF] |= MF_MIN_NEAREST | MF_MIP_DITHER;
      /*
      if (magf == GL_LINEAR) {
         bias -= 0.5;
a95 2
      */
      bias -= 0.5; /* always biasing here looks better */
d98 9
a106 4
      if (IS_I815(imesa))
	 t->Setup[I810_TEXREG_MF] |= MF_MIN_LINEAR | MF_MIP_LINEAR;
      else 
	 t->Setup[I810_TEXREG_MF] |= MF_MIN_LINEAR | MF_MIP_DITHER;
d109 2
a110 1
      return;
d114 93
a206 2
   case GL_NEAREST: 
      t->Setup[I810_TEXREG_MF] |= MF_MAG_NEAREST; 
d208 3
a210 2
   case GL_LINEAR: 
      t->Setup[I810_TEXREG_MF] |= MF_MAG_LINEAR; 
d212 313
a524 2
   default: 
      return;
d527 7
a533 1
   t->Setup[I810_TEXREG_MLC] |= i810ComputeLodBias(bias);
d537 1
a537 2
static void i810SetTexBorderColor(i810TextureObjectPtr t, 
				  GLubyte color[4])
d539 9
a547 1
   /* Need a fallback.
d549 61
d613 84
a696 3
static void i810TexParameter( GLcontext *ctx, GLenum target,
			      struct gl_texture_object *tObj,
			      GLenum pname, const GLfloat *params )
d699 27
a725 2
   i810TextureObjectPtr t = (i810TextureObjectPtr) tObj->DriverData;
   if (!t)
d727 1
d729 5
a733 1
   if ( target != GL_TEXTURE_2D )
d735 1
d737 81
a817 12
   /* Can't do the update now as we don't know whether to flush
    * vertices or not.  Setting imesa->new_state means that
    * i810UpdateTextureState() will be called before any triangles are
    * rendered.  If a statechange has occurred, it will be detected at
    * that point, and buffered vertices flushed.  
    */
   switch (pname) {
   case GL_TEXTURE_MIN_FILTER:
   case GL_TEXTURE_MAG_FILTER:
      {
         GLfloat bias = ctx->Texture.Unit[ctx->Texture.CurrentUnit].LodBias;
         i810SetTexFilter( imesa, t, tObj->MinFilter, tObj->MagFilter, bias );
d819 9
d830 64
a893 3
   case GL_TEXTURE_WRAP_S:
   case GL_TEXTURE_WRAP_T:
      i810SetTexWrapping( t, tObj->WrapS, tObj->WrapT );
d895 39
a933 3
  
   case GL_TEXTURE_BORDER_COLOR:
      i810SetTexBorderColor( t, tObj->BorderColor );
d935 57
a991 11

   case GL_TEXTURE_BASE_LEVEL:
   case GL_TEXTURE_MAX_LEVEL:
   case GL_TEXTURE_MIN_LOD:
   case GL_TEXTURE_MAX_LOD:
      /* This isn't the most efficient solution but there doesn't appear to
       * be a nice alternative for Radeon.  Since there's no LOD clamping,
       * we just have to rely on loading the right subset of mipmap levels
       * to simulate a clamped LOD.
       */
      i810SwapOutTexObj( imesa, t );
d995 43
d1041 6
a1046 2
   if (t == imesa->CurrentTexObj[0]) {
      I810_STATECHANGE( imesa, I810_UPLOAD_TEX0 );
d1049 9
a1057 2
   if (t == imesa->CurrentTexObj[1]) {
      I810_STATECHANGE( imesa, I810_UPLOAD_TEX1 );
d1059 190
d1252 5
a1260 1
   GLuint unit = ctx->Texture.CurrentUnit;
d1262 10
a1271 7
   /* Only one env color.  Need a fallback if env colors are different
    * and texture setup references env color in both units.  
    */
   switch (pname) {
   case GL_TEXTURE_ENV_COLOR: {
      struct gl_texture_unit *texUnit = &ctx->Texture.Unit[unit];
      GLfloat *fc = texUnit->EnvColor;
d1273 4
a1276 4
      CLAMPED_FLOAT_TO_UBYTE(r, fc[0]);
      CLAMPED_FLOAT_TO_UBYTE(g, fc[1]);
      CLAMPED_FLOAT_TO_UBYTE(b, fc[2]);
      CLAMPED_FLOAT_TO_UBYTE(a, fc[3]);
d1282 1
a1282 1
 
d1284 1
a1284 1
	 I810_STATECHANGE(imesa, I810_UPLOAD_CTX);	
d1286 1
d1288 15
a1302 5
      break;
   }
   case GL_TEXTURE_ENV_MODE:
      imesa->TexEnvImageFmt[unit] = 0; /* force recalc of env state */
      break;
d1304 2
a1305 8
   case GL_TEXTURE_LOD_BIAS_EXT:
      {
         struct gl_texture_object *tObj = ctx->Texture.Unit[unit]._Current;
         i810TextureObjectPtr t = (i810TextureObjectPtr) tObj->DriverData;
         t->Setup[I810_TEXREG_MLC] &= ~(MLC_LOD_BIAS_MASK);
         t->Setup[I810_TEXREG_MLC] |= i810ComputeLodBias(*param);
      }
      break;
d1307 7
a1313 2
   default:
      break;
d1315 1
a1315 1
} 
d1317 6
a1322 9
#if 0
static void i810TexImage1D( GLcontext *ctx, GLenum target, GLint level,
			    GLint internalFormat,
			    GLint width, GLint border,
			    GLenum format, GLenum type, 
			    const GLvoid *pixels,
			    const struct gl_pixelstore_attrib *pack,
			    struct gl_texture_object *texObj,
			    struct gl_texture_image *texImage )
d1324 7
a1330 1
   i810TextureObjectPtr t = (i810TextureObjectPtr) texObj->DriverData;
d1332 4
a1335 1
      i810SwapOutTexObj( imesa, t );
d1339 3
a1341 10
static void i810TexSubImage1D( GLcontext *ctx, 
			       GLenum target,
			       GLint level,	
			       GLint xoffset,
			       GLsizei width,
			       GLenum format, GLenum type,
			       const GLvoid *pixels,
			       const struct gl_pixelstore_attrib *pack,
			       struct gl_texture_object *texObj,
			       struct gl_texture_image *texImage )
d1343 2
a1344 2
}
#endif
d1346 2
d1349 20
a1368 11
static void i810TexImage2D( GLcontext *ctx, GLenum target, GLint level,
			    GLint internalFormat,
			    GLint width, GLint height, GLint border,
			    GLenum format, GLenum type, const GLvoid *pixels,
			    const struct gl_pixelstore_attrib *packing,
			    struct gl_texture_object *texObj,
			    struct gl_texture_image *texImage )
{
   i810TextureObjectPtr t = (i810TextureObjectPtr) texObj->DriverData;
   if (t) {
      i810SwapOutTexObj( I810_CONTEXT(ctx), t );
a1369 23
   _mesa_store_teximage2d( ctx, target, level, internalFormat,
			   width, height, border, format, type,
			   pixels, packing, texObj, texImage );
}

static void i810TexSubImage2D( GLcontext *ctx, 
			       GLenum target,
			       GLint level,	
			       GLint xoffset, GLint yoffset,
			       GLsizei width, GLsizei height,
			       GLenum format, GLenum type,
			       const GLvoid *pixels,
			       const struct gl_pixelstore_attrib *packing,
			       struct gl_texture_object *texObj,
			       struct gl_texture_image *texImage )
{
   i810TextureObjectPtr t = (i810TextureObjectPtr) texObj->DriverData;
   if (t) {
      i810SwapOutTexObj( I810_CONTEXT(ctx), t );
   }
   _mesa_store_texsubimage2d(ctx, target, level, xoffset, yoffset, width, 
			     height, format, type, pixels, packing, texObj,
			     texImage);
d1371 1
a1373 1

d1377 7
a1383 44
   if (target == GL_TEXTURE_2D) {
      i810ContextPtr imesa = I810_CONTEXT( ctx );
      i810TextureObjectPtr t = (i810TextureObjectPtr) tObj->DriverData;

      if (!t) {
         GLfloat bias = ctx->Texture.Unit[ctx->Texture.CurrentUnit].LodBias;
	 t = CALLOC_STRUCT(i810_texture_object_t);

	 /* Initialize non-image-dependent parts of the state:
	  */
	 t->globj = tObj;
	 t->Setup[I810_TEXREG_MI0] = GFX_OP_MAP_INFO;
	 t->Setup[I810_TEXREG_MI1] = MI1_MAP_0; 
	 t->Setup[I810_TEXREG_MI2] = MI2_DIMENSIONS_ARE_LOG2;
	 t->Setup[I810_TEXREG_MLC] = (GFX_OP_MAP_LOD_CTL | 
				      MLC_MAP_0 |
				      /*MLC_DITHER_WEIGHT_FULL |*/
				      MLC_DITHER_WEIGHT_12 |
				      MLC_UPDATE_LOD_BIAS |
				      0x0);
	 t->Setup[I810_TEXREG_MCS] = (GFX_OP_MAP_COORD_SETS |
				      MCS_COORD_0 |
				      MCS_UPDATE_NORMALIZED |
				      MCS_NORMALIZED_COORDS |
				      MCS_UPDATE_V_STATE |
				      MCS_V_WRAP |
				      MCS_UPDATE_U_STATE |
				      MCS_U_WRAP);
	 t->Setup[I810_TEXREG_MF] = (GFX_OP_MAP_FILTER |
				     MF_MAP_0 |
				     MF_UPDATE_ANISOTROPIC |
				     MF_UPDATE_MIP_FILTER |
				     MF_UPDATE_MAG_FILTER |
				     MF_UPDATE_MIN_FILTER);

	 t->dirty_images = ~0;

	 tObj->DriverData = t;
	 make_empty_list( t );

	 i810SetTexWrapping( t, tObj->WrapS, tObj->WrapT );
	 i810SetTexFilter( imesa, t, tObj->MinFilter, tObj->MagFilter, bias );
	 i810SetTexBorderColor( t, tObj->BorderColor );
      }
d1385 2
a1388 1

d1392 1
d1395 9
a1403 5
      i810ContextPtr imesa = I810_CONTEXT( ctx );
      if (imesa)
         I810_FIREVERTICES( imesa );
      i810DestroyTexObj( imesa, t );
      tObj->DriverData = 0;
d1407 1
d1409 1
a1409 1
					struct gl_texture_object *tObj )
d1411 7
a1417 2
   i810TextureObjectPtr t = (i810TextureObjectPtr)tObj->DriverData;
   return t && t->MemBlock;
d1420 1
a1420 1
void i810InitTextureFuncs( GLcontext *ctx )
d1423 2
a1424 12
   ctx->Driver.ChooseTextureFormat = _mesa_choose_tex_format;
   ctx->Driver.TexImage1D = _mesa_store_teximage1d;
   ctx->Driver.TexImage2D = i810TexImage2D;
   ctx->Driver.TexImage3D = _mesa_store_teximage3d;
   ctx->Driver.TexSubImage1D = _mesa_store_texsubimage1d;
   ctx->Driver.TexSubImage2D = i810TexSubImage2D;
   ctx->Driver.TexSubImage3D = _mesa_store_texsubimage3d;
   ctx->Driver.CopyTexImage1D = _swrast_copy_teximage1d;
   ctx->Driver.CopyTexImage2D = _swrast_copy_teximage2d;
   ctx->Driver.CopyTexSubImage1D = _swrast_copy_texsubimage1d;
   ctx->Driver.CopyTexSubImage2D = _swrast_copy_texsubimage2d;
   ctx->Driver.CopyTexSubImage3D = _swrast_copy_texsubimage3d;
a1429 10
   ctx->Driver.TestProxyTexImage = _mesa_test_proxy_teximage;

   {
      GLuint tmp = ctx->Texture.CurrentUnit;
      ctx->Texture.CurrentUnit = 0;
      i810BindTexture( ctx, GL_TEXTURE_2D, ctx->Texture.Unit[0].Current2D);
      ctx->Texture.CurrentUnit = 1;
      i810BindTexture( ctx, GL_TEXTURE_2D, ctx->Texture.Unit[1].Current2D);
      ctx->Texture.CurrentUnit = tmp;
   }
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d24 4
a27 1
/* $XFree86: xc/lib/GL/mesa/src/drv/i810/i810tex.c,v 1.10 2003/09/28 20:15:12 alanh Exp $ */
d31 1
a31 1
#include "imports.h"
a35 1
#include "texmem.h"
a36 1
#include "colormac.h"
d63 2
a64 2
static void i810SetTexWrapping(i810TextureObjectPtr tex,
			       GLenum swrap, GLenum twrap)
d66 5
a70 1
   tex->Setup[I810_TEXREG_MCS] &= ~(MCS_U_STATE_MASK| MCS_V_STATE_MASK);
d72 2
a73 14
   switch( swrap ) {
   case GL_REPEAT:
      tex->Setup[I810_TEXREG_MCS] |= MCS_U_WRAP;
      break;
   case GL_CLAMP:
   case GL_CLAMP_TO_EDGE:
      tex->Setup[I810_TEXREG_MCS] |= MCS_U_CLAMP;
      break;
   case GL_MIRRORED_REPEAT:
      tex->Setup[I810_TEXREG_MCS] |= MCS_U_MIRROR;
      break;
   default:
      _mesa_problem(NULL, "bad S wrap mode in %s", __FUNCTION__);
   }
a74 14
   switch( twrap ) {
   case GL_REPEAT:
      tex->Setup[I810_TEXREG_MCS] |= MCS_V_WRAP;
      break;
   case GL_CLAMP:
   case GL_CLAMP_TO_EDGE:
      tex->Setup[I810_TEXREG_MCS] |= MCS_V_CLAMP;
      break;
   case GL_MIRRORED_REPEAT:
      tex->Setup[I810_TEXREG_MCS] |= MCS_V_MIRROR;
      break;
   default:
      _mesa_problem(NULL, "bad T wrap mode in %s", __FUNCTION__);
   }
a146 46
static i810TextureObjectPtr i810AllocTexObj( GLcontext *ctx, struct gl_texture_object *texObj )
{
   i810TextureObjectPtr t;
   i810ContextPtr imesa = I810_CONTEXT(ctx);

   t = CALLOC_STRUCT( i810_texture_object_t );
   texObj->DriverData = t;
   if ( t != NULL ) {
      GLfloat bias = ctx->Texture.Unit[ctx->Texture.CurrentUnit].LodBias;
      /* Initialize non-image-dependent parts of the state:
       */
      t->base.tObj = texObj;
      t->Setup[I810_TEXREG_MI0] = GFX_OP_MAP_INFO;
      t->Setup[I810_TEXREG_MI1] = MI1_MAP_0; 
      t->Setup[I810_TEXREG_MI2] = MI2_DIMENSIONS_ARE_LOG2;
      t->Setup[I810_TEXREG_MLC] = (GFX_OP_MAP_LOD_CTL | 
				   MLC_MAP_0 |
				   /*MLC_DITHER_WEIGHT_FULL |*/
				   MLC_DITHER_WEIGHT_12 |
				   MLC_UPDATE_LOD_BIAS |
				   0x0);
      t->Setup[I810_TEXREG_MCS] = (GFX_OP_MAP_COORD_SETS |
				   MCS_COORD_0 |
				   MCS_UPDATE_NORMALIZED |
				   MCS_NORMALIZED_COORDS |
				   MCS_UPDATE_V_STATE |
				   MCS_V_WRAP |
				   MCS_UPDATE_U_STATE |
				   MCS_U_WRAP);
      t->Setup[I810_TEXREG_MF] = (GFX_OP_MAP_FILTER |
				  MF_MAP_0 |
				  MF_UPDATE_ANISOTROPIC |
				  MF_UPDATE_MIP_FILTER |
				  MF_UPDATE_MAG_FILTER |
				  MF_UPDATE_MIN_FILTER);
      
      make_empty_list( & t->base );

      i810SetTexWrapping( t, texObj->WrapS, texObj->WrapT );
      /*i830SetTexMaxAnisotropy( t, texObj->MaxAnisotropy );*/
      i810SetTexFilter( imesa, t, texObj->MinFilter, texObj->MagFilter, bias );
      i810SetTexBorderColor( t, texObj->_BorderChan );
   }

   return t;
}
d182 1
a182 1
      i810SetTexBorderColor( t, tObj->_BorderChan );
d194 1
a194 2
      I810_FIREVERTICES( I810_CONTEXT(ctx) );
      driSwapOutTextureObject( (driTextureObject *) t );
a258 2


d298 1
a298 1
   driTextureObject *t = (driTextureObject *) texObj->DriverData;
d300 1
a300 9
      I810_FIREVERTICES( I810_CONTEXT(ctx) );
      driSwapOutTextureObject( t );
   }
   else {
      t = (driTextureObject *) i810AllocTexObj( ctx, texObj );
      if (!t) {
         _mesa_error(ctx, GL_OUT_OF_MEMORY, "glTexImage2D");
         return;
      }
a304 1

d318 1
a318 2
   driTextureObject *t = (driTextureObject *)texObj->DriverData;

d320 1
a320 2
     I810_FIREVERTICES( I810_CONTEXT(ctx) );
     driSwapOutTextureObject( t );
d332 45
a376 3
  if (!tObj->DriverData) {
      i810AllocTexObj( ctx, tObj );
  }
d382 2
a383 1
  driTextureObject * t = (driTextureObject *) tObj->DriverData;
d388 2
a389 1
      driDestroyTextureObject( t );
d393 5
a397 85
static const struct gl_texture_format *
i810ChooseTextureFormat( GLcontext *ctx, GLint internalFormat,
			 GLenum format, GLenum type )
{
   switch ( internalFormat ) {
   case 4:
   case GL_RGBA:
   case GL_COMPRESSED_RGBA:
      if ( format == GL_BGRA ) {
         if ( type == GL_UNSIGNED_SHORT_1_5_5_5_REV ) {
	    return &_mesa_texformat_argb1555;
	 }
      }
      return &_mesa_texformat_argb4444;

   case 3:
   case GL_RGB:
   case GL_COMPRESSED_RGB:
   case GL_R3_G3_B2:
   case GL_RGB4:
   case GL_RGB5:
   case GL_RGB8:
   case GL_RGB10:
   case GL_RGB12:
   case GL_RGB16:
     return &_mesa_texformat_rgb565;

   case GL_RGBA2:
   case GL_RGBA4:
   case GL_RGBA8:
   case GL_RGB10_A2:
   case GL_RGBA12:
   case GL_RGBA16:
      return &_mesa_texformat_argb4444;

   case GL_RGB5_A1:
      return &_mesa_texformat_argb1555;

   case GL_ALPHA:
   case GL_ALPHA4:
   case GL_ALPHA8:
   case GL_ALPHA12:
   case GL_ALPHA16:
   case GL_COMPRESSED_ALPHA:
      return &_mesa_texformat_al88;

   case 1:
   case GL_LUMINANCE:
   case GL_LUMINANCE4:
   case GL_LUMINANCE8:
   case GL_LUMINANCE12:
   case GL_LUMINANCE16:
   case GL_COMPRESSED_LUMINANCE:
      return &_mesa_texformat_rgb565;

   case 2:
   case GL_LUMINANCE_ALPHA:
   case GL_LUMINANCE4_ALPHA4:
   case GL_LUMINANCE6_ALPHA2:
   case GL_LUMINANCE8_ALPHA8:
   case GL_LUMINANCE12_ALPHA4:
   case GL_LUMINANCE12_ALPHA12:
   case GL_LUMINANCE16_ALPHA16:
   case GL_COMPRESSED_LUMINANCE_ALPHA:
   case GL_INTENSITY:
   case GL_INTENSITY4:
   case GL_INTENSITY8:
   case GL_INTENSITY12:
   case GL_INTENSITY16:
   case GL_COMPRESSED_INTENSITY:
      return &_mesa_texformat_argb4444;

   case GL_YCBCR_MESA:
      if (type == GL_UNSIGNED_SHORT_8_8_MESA ||
	  type == GL_UNSIGNED_BYTE)
         return &_mesa_texformat_ycbcr;
      else
         return &_mesa_texformat_ycbcr_rev;

   default:
      fprintf(stderr, "unexpected texture format in %s\n", __FUNCTION__);
      return NULL;
   }

   return NULL; /* never get here */
a401 2
   i810ContextPtr imesa = I810_CONTEXT(ctx);

d403 1
a403 1
   ctx->Driver.ChooseTextureFormat = i810ChooseTextureFormat;
d419 1
a419 1
   ctx->Driver.IsTextureResident = driIsTextureResident;
d422 8
a429 2
   driInitTextureObjects( ctx, &imesa->swapped, DRI_TEXMGR_DO_TEXTURE_2D);

@


