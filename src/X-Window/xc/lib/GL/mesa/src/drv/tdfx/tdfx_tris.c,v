head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.04.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.04.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.31.41;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.59.48;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.18.16;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* -*- mode: c; c-basic-offset: 3 -*-
 *
 * Copyright 2000 VA Linux Systems Inc., Fremont, California.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEMS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/* $XFree86: xc/lib/GL/mesa/src/drv/tdfx/tdfx_tris.c,v 1.2 2001/08/18 02:51:07 dawes Exp $ */

/*
 * Original rewrite:
 *	Gareth Hughes <gareth@@valinux.com>, 29 Sep - 1 Oct 2000
 *
 * Authors:
 *	Gareth Hughes <gareth@@valinux.com>
 *	Brian Paul <brianp@@valinux.com>
 *	Keith Whitwell <keithw@@valinux.com>
 *
 */

#include "tdfx_context.h"
#include "tdfx_tris.h"

#include "pipeline.h"
#include "vbindirect.h"

static struct {
   points_func		points;
   line_func    	line;
   triangle_func	triangle;
   quad_func		quad;
   render_func          *render_tab;
} rast_tab[TDFX_MAX_TRIFUNC];

#define TDFX_COLOR( to, from )						\
   do {									\
      (to)[0] = (from)[2];						\
      (to)[1] = (from)[1];						\
      (to)[2] = (from)[0];						\
      (to)[3] = (from)[3];						\
   } while (0)


static void tdfxPrintRenderState( const char *msg, GLuint state )
{
   fprintf( stderr, "%s: (0x%x) %s%s%s%s\n",
	    msg, state,
	    (state & TDFX_FLAT_BIT)       ? "flat, "       : "",
	    (state & TDFX_OFFSET_BIT)     ? "offset, "     : "",
	    (state & TDFX_TWOSIDE_BIT)    ? "twoside, "    : "",
	    (state & TDFX_CLIPRECT_BIT)   ? "cliprects, "  : "");
}


#define IND (0)
#define TAG(x) x
#include "tdfx_tritmp.h"

#define IND (TDFX_FLAT_BIT)
#define TAG(x) x##_flat
#include "tdfx_tritmp.h"

#define IND (TDFX_OFFSET_BIT)
#define TAG(x) x##_offset
#include "tdfx_tritmp.h"

#define IND (TDFX_OFFSET_BIT | TDFX_FLAT_BIT)
#define TAG(x) x##_offset_flat
#include "tdfx_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT)
#define TAG(x) x##_twoside
#include "tdfx_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT | TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_flat
#include "tdfx_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT | TDFX_OFFSET_BIT)
#define TAG(x) x##_twoside_offset
#include "tdfx_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT | TDFX_OFFSET_BIT | TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_offset_flat
#include "tdfx_tritmp.h"

#define IND (TDFX_CLIPRECT_BIT)
#define TAG(x) x##_cliprect
#include "tdfx_tritmp.h"

#define IND (TDFX_FLAT_BIT | TDFX_CLIPRECT_BIT)
#define TAG(x) x##_flat_cliprect
#include "tdfx_tritmp.h"

#define IND (TDFX_OFFSET_BIT | TDFX_CLIPRECT_BIT)
#define TAG(x) x##_offset_cliprect
#include "tdfx_tritmp.h"

#define IND (TDFX_OFFSET_BIT | TDFX_FLAT_BIT | TDFX_CLIPRECT_BIT)
#define TAG(x) x##_offset_flat_cliprect
#include "tdfx_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT | TDFX_CLIPRECT_BIT)
#define TAG(x) x##_twoside_cliprect
#include "tdfx_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT | TDFX_FLAT_BIT | TDFX_CLIPRECT_BIT)
#define TAG(x) x##_twoside_flat_cliprect
#include "tdfx_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT | TDFX_OFFSET_BIT | TDFX_CLIPRECT_BIT)
#define TAG(x) x##_twoside_offset_cliprect
#include "tdfx_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT | TDFX_OFFSET_BIT | TDFX_FLAT_BIT | TDFX_CLIPRECT_BIT)
#define TAG(x) x##_twoside_offset_flat_cliprect
#include "tdfx_tritmp.h"

static void tdfx_render_vb_points( struct vertex_buffer *VB,
				      GLuint start,
				      GLuint count,
				      GLuint parity )
{
   GLcontext *ctx = VB->ctx;
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   tdfxVertexPtr fxVB = TDFX_DRIVER_DATA(VB)->verts;
   GLint i;
   (void) parity;
   /* Adjust point coords */
   for (i = start; i < count; i++) {
      fxVB[i].v.x += PNT_X_OFFSET - TRI_X_OFFSET;
      fxVB[i].v.y += PNT_Y_OFFSET - TRI_Y_OFFSET;
   }
   fxMesa->Glide.grDrawVertexArrayContiguous( GR_POINTS, count-start,
                                              fxVB+start, sizeof(*fxVB));
   /* restore point coords */
   for (i = start; i < count; i++) {
      fxVB[i].v.x -= PNT_X_OFFSET - TRI_X_OFFSET;
      fxVB[i].v.y -= PNT_Y_OFFSET - TRI_Y_OFFSET;
   }
}

static void tdfx_render_vb_line_strip( struct vertex_buffer *VB,
				      GLuint start,
				      GLuint count,
				      GLuint parity )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(VB->ctx);
   tdfxVertexPtr fxVB = TDFX_DRIVER_DATA(VB)->verts;
   GLint i;
   (void) parity;
   /* adjust line coords */
   for (i = start; i < count; i++) {
      fxVB[i].v.x += LINE_X_OFFSET - TRI_X_OFFSET;
      fxVB[i].v.y += LINE_Y_OFFSET - TRI_Y_OFFSET;
   }
   fxMesa->Glide.grDrawVertexArrayContiguous( GR_LINE_STRIP, count-start,
                                              fxVB+start, sizeof(*fxVB));
   /* restore line coords */
   for (i = start; i < count; i++) {
      fxVB[i].v.x -= LINE_X_OFFSET - TRI_X_OFFSET;
      fxVB[i].v.y -= LINE_Y_OFFSET - TRI_Y_OFFSET;
   }
}

static void tdfx_render_vb_lines( struct vertex_buffer *VB,
				      GLuint start,
				      GLuint count,
				      GLuint parity )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(VB->ctx);
   tdfxVertexPtr fxVB = TDFX_DRIVER_DATA(VB)->verts;
   GLint i;
   (void) parity;
   /* adjust line coords */
   for (i = start; i < count; i++) {
      fxVB[i].v.x += LINE_X_OFFSET - TRI_X_OFFSET;
      fxVB[i].v.y += LINE_Y_OFFSET - TRI_Y_OFFSET;
   }
   fxMesa->Glide.grDrawVertexArrayContiguous( GR_LINES, count-start,
                                              fxVB+start, sizeof(*fxVB));
   /* restore line coords */
   for (i = start; i < count; i++) {
      fxVB[i].v.x -= LINE_X_OFFSET - TRI_X_OFFSET;
      fxVB[i].v.y -= LINE_Y_OFFSET - TRI_Y_OFFSET;
   }
}

static void tdfx_render_vb_triangles( struct vertex_buffer *VB,
				      GLuint start,
				      GLuint count,
				      GLuint parity )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(VB->ctx);
   tdfxVertexPtr fxVB = TDFX_DRIVER_DATA(VB)->verts;
   fxMesa->Glide.grDrawVertexArrayContiguous( GR_TRIANGLES, count-start,
                                              fxVB+start, sizeof(*fxVB));
   (void) parity;
}


static void tdfx_render_vb_tri_strip( struct vertex_buffer *VB,
				      GLuint start,
				      GLuint count,
				      GLuint parity )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(VB->ctx);
   tdfxVertexPtr fxVB = TDFX_DRIVER_DATA(VB)->verts;
   fxMesa->Glide.grDrawVertexArrayContiguous( GR_TRIANGLE_STRIP, count-start,
                                              fxVB+start, sizeof(*fxVB));
   (void) parity;
}


static void tdfx_render_vb_tri_fan( struct vertex_buffer *VB,
				    GLuint start,
				    GLuint count,
				    GLuint parity )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(VB->ctx);
   tdfxVertexPtr fxVB = TDFX_DRIVER_DATA(VB)->verts;
   fxMesa->Glide.grDrawVertexArrayContiguous( GR_TRIANGLE_FAN, count-start,
                                              fxVB+start, sizeof(*fxVB) );
   (void) parity;
}


static void tdfx_render_vb_poly( struct vertex_buffer *VB,
				 GLuint start,
				 GLuint count,
				 GLuint parity )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(VB->ctx);
   tdfxVertexPtr fxVB = TDFX_DRIVER_DATA(VB)->verts;
   fxMesa->Glide.grDrawVertexArrayContiguous( GR_POLYGON, count-start,
                                              fxVB+start, sizeof(*fxVB));
   (void) parity;
}


#define RENDER_POINTS( start, count ) 			\
do {							\
   int i;						\
   for (i = start ; i < count ; i++) {			\
      v[elt[i]].v.x += PNT_X_OFFSET - TRI_X_OFFSET;	\
      v[elt[i]].v.y += PNT_Y_OFFSET - TRI_Y_OFFSET;	\
      fxMesa->Glide.grDrawPoint(&v[elt[i]]);		\
      v[elt[i]].v.x -= PNT_X_OFFSET - TRI_X_OFFSET;	\
      v[elt[i]].v.y -= PNT_Y_OFFSET - TRI_Y_OFFSET;	\
   }							\
} while (0)

#define RENDER_LINE( i0, i1 )				\
do {							\
   v[elt[i0]].v.x += LINE_X_OFFSET - TRI_X_OFFSET;	\
   v[elt[i0]].v.y += LINE_Y_OFFSET - TRI_Y_OFFSET;	\
   v[elt[i1]].v.x += LINE_X_OFFSET - TRI_X_OFFSET;	\
   v[elt[i1]].v.y += LINE_Y_OFFSET - TRI_Y_OFFSET;	\
   fxMesa->Glide.grDrawLine( &v[elt[i0]], &v[elt[i1]] );\
   v[elt[i0]].v.x -= LINE_X_OFFSET - TRI_X_OFFSET;	\
   v[elt[i0]].v.y -= LINE_Y_OFFSET - TRI_Y_OFFSET;	\
   v[elt[i1]].v.x -= LINE_X_OFFSET - TRI_X_OFFSET;	\
   v[elt[i1]].v.y -= LINE_Y_OFFSET - TRI_Y_OFFSET;	\
} while (0)

#define RENDER_TRI( i2, i1, i, pv, parity )				\
do {									\
   if (parity) fxMesa->Glide.grDrawTriangle( &v[elt[i1]], &v[elt[i2]], &v[elt[i]] );	\
   else        fxMesa->Glide.grDrawTriangle( &v[elt[i2]], &v[elt[i1]], &v[elt[i]] );	\
} while (0)

#define RENDER_QUAD( i3, i2, i1, i, pv )			\
do {								\
   fxMesa->Glide.grDrawTriangle( &v[elt[i3]], &v[elt[i2]], &v[elt[i]] );	\
   fxMesa->Glide.grDrawTriangle( &v[elt[i2]], &v[elt[i1]], &v[elt[i]] );	\
} while (0)


#define LOCAL_VARS				\
   GLcontext *ctx = VB->ctx;			\
   tdfxContextPtr fxMesa = TDFX_CONTEXT( ctx ); \
   const GLuint *elt = VB->EltPtr->data;        \
   tdfxVertexPtr v = TDFX_DRIVER_DATA(VB)->verts; \
   (void) v; (void) ctx;

#define TAG(x) tdfx_##x##_elts
#include "render_tmp.h"


static void tdfxDDRenderEltsRaw( struct vertex_buffer *VB )
{
   GLcontext *ctx = VB->ctx;
   tdfxContextPtr fxMesa = TDFX_CONTEXT( ctx );
   struct vertex_buffer *OldVB = ctx->VB;
   GLenum prim = ctx->CVA.elt_mode;
   GLuint nr = VB->EltPtr->count;
   render_func func = tdfx_render_tab_elts[prim];
   GLuint p = 0;

   ctx->VB = VB;
   ctx->Driver.RenderStart( ctx );

   BEGIN_CLIP_LOOP_LOCKED( fxMesa );
   do {
      func( VB, 0, nr, 0 );
   } while ( ctx->Driver.MultipassFunc &&
	     ctx->Driver.MultipassFunc( VB, ++p ) );
   END_CLIP_LOOP_LOCKED( fxMesa );

   ctx->Driver.RenderFinish( ctx );
   ctx->VB = OldVB;
}


void tdfxDDTriangleFuncsInit( void )
{
   init();
   init_flat();
   init_offset();
   init_offset_flat();
   init_twoside();
   init_twoside_flat();
   init_twoside_offset();
   init_twoside_offset_flat();

   init_cliprect();
   init_flat_cliprect();
   init_offset_cliprect();
   init_offset_flat_cliprect();
   init_twoside_cliprect();
   init_twoside_flat_cliprect();
   init_twoside_offset_cliprect();
   init_twoside_offset_flat_cliprect();

   rast_tab[0].render_tab[GL_POINTS] = tdfx_render_vb_points;
   rast_tab[0].render_tab[GL_LINE_STRIP] = tdfx_render_vb_line_strip;
   rast_tab[0].render_tab[GL_LINES] = tdfx_render_vb_lines;
   rast_tab[0].render_tab[GL_TRIANGLES] = tdfx_render_vb_triangles;
   rast_tab[0].render_tab[GL_TRIANGLE_STRIP] = tdfx_render_vb_tri_strip;
   rast_tab[0].render_tab[GL_TRIANGLE_FAN] = tdfx_render_vb_tri_fan;
   rast_tab[0].render_tab[GL_POLYGON] = tdfx_render_vb_poly;

   tdfx_render_init_elts();
}


#define ALL_FALLBACK	(DD_SELECT | DD_FEEDBACK)
#define POINT_FALLBACK	(ALL_FALLBACK | DD_POINT_SMOOTH | DD_POINT_ATTEN)
#define LINE_FALLBACK	(ALL_FALLBACK | DD_LINE_STIPPLE)
#define TRI_FALLBACK	(ALL_FALLBACK | DD_TRI_SMOOTH | DD_TRI_UNFILLED)
#define ANY_FALLBACK	(POINT_FALLBACK | LINE_FALLBACK | TRI_FALLBACK | DD_TRI_STIPPLE | DD_LINE_SMOOTH | DD_LINE_WIDTH | DD_POINT_SIZE )
#define ANY_RENDER_FLAGS (DD_FLATSHADE | DD_TRI_LIGHT_TWOSIDE | DD_TRI_OFFSET)

/* Setup the Point, Line, Triangle and Quad functions based on the
 * current rendering state.  Wherever possible, use the hardware to
 * render the primitive.  Otherwise, fallback to software rendering.
 */
void tdfxDDChooseRenderState( GLcontext *ctx )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT( ctx );
   GLuint flags = ctx->TriangleCaps;
   CARD32 index = 0;
   fxMesa->RenderElementsRaw = tdfxDDRenderEltsRaw;

   if ( fxMesa->Fallback ) {
      fxMesa->RenderElementsRaw = gl_render_elts;
      fxMesa->RenderIndex = TDFX_FALLBACK_BIT;
      return;
   }

   if ( flags & ANY_RENDER_FLAGS ) {
      if ( flags & DD_FLATSHADE )		index |= TDFX_FLAT_BIT;
      if ( flags & DD_TRI_LIGHT_TWOSIDE )	index |= TDFX_TWOSIDE_BIT;
      if ( flags & DD_TRI_OFFSET )		index |= TDFX_OFFSET_BIT;
      fxMesa->RenderElementsRaw = gl_render_elts;
   }

   if ( fxMesa->numClipRects > 1 )
      index |= TDFX_CLIPRECT_BIT;

   fxMesa->PointsFunc	= rast_tab[index].points;
   fxMesa->LineFunc	= rast_tab[index].line;
   fxMesa->TriangleFunc	= rast_tab[index].triangle;
   fxMesa->QuadFunc	= rast_tab[index].quad;
   fxMesa->RenderVBRawTab = rast_tab[index].render_tab;
   fxMesa->RenderIndex = index;
   fxMesa->IndirectTriangles = 0;

   if ( flags & ANY_FALLBACK ) {
      if ( flags & POINT_FALLBACK ) {
	 fxMesa->PointsFunc = 0;
	 fxMesa->RenderVBRawTab = 0;
	 fxMesa->IndirectTriangles |= DD_POINT_SW_RASTERIZE;
	 fxMesa->RenderIndex |= TDFX_FALLBACK_BIT;
      }

      if ( flags & LINE_FALLBACK ) {
	 fxMesa->LineFunc = 0;
	 fxMesa->RenderVBRawTab = 0;
	 fxMesa->IndirectTriangles |= DD_LINE_SW_RASTERIZE;
	 fxMesa->RenderIndex |= TDFX_FALLBACK_BIT;
      }

      if ( flags & TRI_FALLBACK ) {
	 fxMesa->TriangleFunc = 0;
	 fxMesa->QuadFunc = 0;
	 fxMesa->RenderVBRawTab = 0;
	 fxMesa->IndirectTriangles |= (DD_TRI_SW_RASTERIZE |
				       DD_QUAD_SW_RASTERIZE);
	 fxMesa->RenderIndex |= TDFX_FALLBACK_BIT;
      }

      /* Special case:  wide, AA lines must be done in software */
      if (flags & DD_LINE_SMOOTH) {
         if (ctx->Line.Width != 1.0) {
	    fxMesa->RenderVBRawTab = 0;
            fxMesa->LineFunc = 0;
            fxMesa->IndirectTriangles |= DD_LINE_SW_RASTERIZE;
            fxMesa->RenderIndex |= TDFX_FALLBACK_BIT;
         }
      }

      /* Special case:  we can do polygon stipples, but otherwise */
      if ((flags & DD_TRI_STIPPLE) &&
	 (ctx->IndirectTriangles & DD_TRI_STIPPLE)) {
	 fxMesa->TriangleFunc = 0;
	 fxMesa->QuadFunc = 0;
	 fxMesa->RenderVBRawTab = 0;
	 fxMesa->IndirectTriangles |= (DD_TRI_SW_RASTERIZE |
				       DD_QUAD_SW_RASTERIZE);
	 fxMesa->RenderIndex |= TDFX_FALLBACK_BIT;
      }

      if (flags & (DD_LINE_WIDTH | DD_POINT_SIZE))
	 fxMesa->RenderVBRawTab = 0;

      fxMesa->RenderElementsRaw = gl_render_elts;
   }


   if ( 0 ) {
      gl_print_tri_caps( "tricaps", ctx->TriangleCaps );
      tdfxPrintRenderState( "tdfx render state", fxMesa->RenderIndex );
   }
}


void tdfxDDToggleTriCliprects( GLcontext *ctx )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT( ctx );
   int oldidx = fxMesa->RenderIndex;
   int newidx;

   if (fxMesa->Fallback)
      return;

   if (fxMesa->numClipRects > 1)
      newidx = (fxMesa->RenderIndex |= TDFX_CLIPRECT_BIT);
   else
      newidx = (fxMesa->RenderIndex &= ~TDFX_CLIPRECT_BIT);

   if (ctx->Driver.TriangleFunc == rast_tab[oldidx].triangle)
      ctx->Driver.TriangleFunc = rast_tab[newidx].triangle;

   if (ctx->Driver.QuadFunc == rast_tab[oldidx].quad)
      ctx->Driver.QuadFunc = rast_tab[newidx].quad;

   if (ctx->Driver.LineFunc == rast_tab[oldidx].line)
      ctx->Driver.LineFunc = rast_tab[newidx].line;

   if (ctx->Driver.PointsFunc == rast_tab[oldidx].points)
      ctx->Driver.PointsFunc = rast_tab[newidx].points;

   if (ctx->Driver.RenderVBRawTab == rast_tab[oldidx].render_tab)
      ctx->Driver.RenderVBRawTab = rast_tab[newidx].render_tab;

   if (ctx->TriangleFunc == rast_tab[oldidx].triangle)
      ctx->TriangleFunc = rast_tab[newidx].triangle;

   if (ctx->QuadFunc == rast_tab[oldidx].quad)
      ctx->QuadFunc = rast_tab[newidx].quad;

   fxMesa->PointsFunc	= rast_tab[newidx].points;
   fxMesa->LineFunc	= rast_tab[newidx].line;
   fxMesa->TriangleFunc	= rast_tab[newidx].triangle;
   fxMesa->QuadFunc	= rast_tab[newidx].quad;
   fxMesa->RenderVBRawTab = rast_tab[newidx].render_tab;

   if (newidx == 0 &&
       (ctx->IndirectTriangles & (DD_LINE_WIDTH|DD_POINT_SIZE)) == 0)
      fxMesa->RenderElementsRaw = tdfxDDRenderEltsRaw;
   else
      fxMesa->RenderElementsRaw = gl_render_elts;

   if (0)
      tdfxPrintRenderState( "toggle tdfx render state", fxMesa->RenderIndex );
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d26 1
a26 1
/* $XFree86: xc/lib/GL/mesa/src/drv/tdfx/tdfx_tris.c,v 1.6 2004/01/23 03:57:07 dawes Exp $ */
d28 9
a36 2
/* Authors:
 *    Keith Whitwell <keith@@tungstengraphics.com>
d39 1
a39 11
#include "glheader.h"
#include "mtypes.h"
#include "macros.h"
#include "colormac.h"

#include "swrast/swrast.h"
#include "swrast_setup/swrast_setup.h"
#include "swrast_setup/ss_context.h"
#include "tnl/t_context.h"
#include "tnl/t_pipeline.h"

a40 174
#include "tdfx_state.h"
#include "tdfx_vb.h"
#include "tdfx_lock.h"
#include "tdfx_render.h"


static void tdfxRasterPrimitive( GLcontext *ctx, GLenum prim );
static void tdfxRenderPrimitive( GLcontext *ctx, GLenum prim );

/***********************************************************************
 *          Macros for t_dd_tritmp.h to draw basic primitives          *
 ***********************************************************************/

#define TRI( a, b, c )				\
do {						\
   if (DO_FALLBACK)				\
      fxMesa->draw_triangle( fxMesa, a, b, c );	\
   else						\
      fxMesa->Glide.grDrawTriangle( a, b, c );	\
} while (0)					\

#define QUAD( a, b, c, d )			\
do {						\
   if (DO_FALLBACK) {				\
      fxMesa->draw_triangle( fxMesa, a, b, d );	\
      fxMesa->draw_triangle( fxMesa, b, c, d );	\
   } else {					\
      fxMesa->Glide.grDrawTriangle( a, b, d );	\
      fxMesa->Glide.grDrawTriangle( b, c, d );	\
   }						\
} while (0)

#define LINE( v0, v1 )				\
do {						\
   if (DO_FALLBACK)				\
      fxMesa->draw_line( fxMesa, v0, v1 );	\
   else {					\
      v0->v.x += LINE_X_OFFSET - TRI_X_OFFSET;	\
      v0->v.y += LINE_Y_OFFSET - TRI_Y_OFFSET;	\
      v1->v.x += LINE_X_OFFSET - TRI_X_OFFSET;	\
      v1->v.y += LINE_Y_OFFSET - TRI_Y_OFFSET;	\
      fxMesa->Glide.grDrawLine( v0, v1 );	\
      v0->v.x -= LINE_X_OFFSET - TRI_X_OFFSET;	\
      v0->v.y -= LINE_Y_OFFSET - TRI_Y_OFFSET;	\
      v1->v.x -= LINE_X_OFFSET - TRI_X_OFFSET;	\
      v1->v.y -= LINE_Y_OFFSET - TRI_Y_OFFSET;	\
   }						\
} while (0)

#define POINT( v0 )				\
do {						\
   if (DO_FALLBACK)				\
      fxMesa->draw_point( fxMesa, v0 );		\
   else {					\
      v0->v.x += PNT_X_OFFSET - TRI_X_OFFSET;	\
      v0->v.y += PNT_Y_OFFSET - TRI_Y_OFFSET;	\
      fxMesa->Glide.grDrawPoint( v0 );		\
      v0->v.x -= PNT_X_OFFSET - TRI_X_OFFSET;	\
      v0->v.y -= PNT_Y_OFFSET - TRI_Y_OFFSET;	\
   }						\
} while (0)


/***********************************************************************
 *              Fallback to swrast for basic primitives                *
 ***********************************************************************/

/* Build an SWvertex from a hardware vertex. 
 *
 * This code is hit only when a mix of accelerated and unaccelerated
 * primitives are being drawn, and only for the unaccelerated
 * primitives.  
 */
static void 
tdfx_translate_vertex( GLcontext *ctx, const tdfxVertex *src, SWvertex *dst)
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);

   if (fxMesa->vertexFormat == TDFX_LAYOUT_TINY) {
      dst->win[0] = src->tv.x - fxMesa->x_offset;
      dst->win[1] = src->tv.y - (fxMesa->screen_height - fxMesa->height - fxMesa->y_offset);
      dst->win[2] = src->tv.z;
      dst->win[3] = 1.0;

      dst->color[0] = src->tv.color.red;
      dst->color[1] = src->tv.color.green;
      dst->color[2] = src->tv.color.blue;
      dst->color[3] = src->tv.color.alpha;
   } 
   else {
      GLfloat w = 1.0 / src->v.rhw;

      dst->win[0] = src->v.x - fxMesa->x_offset;
      dst->win[1] = fxMesa->screen_height - fxMesa->y_offset - src->v.y;
      dst->win[2] = src->v.z;
      dst->win[3] = src->v.rhw;

      dst->color[0] = src->v.color.red;
      dst->color[1] = src->v.color.green;
      dst->color[2] = src->v.color.blue;
      dst->color[3] = src->v.color.alpha;

      if (fxMesa->vertexFormat == TDFX_LAYOUT_PROJECT) {
	 dst->texcoord[0][0] = fxMesa->sScale0 * w * src->pv.tu0;
	 dst->texcoord[0][1] = fxMesa->tScale0 * w * src->pv.tv0;
	 dst->texcoord[0][3] = w * src->pv.tq0;

	 if (fxMesa->SetupIndex & TDFX_TEX1_BIT) {
	    dst->texcoord[1][0] = fxMesa->sScale1 * w * src->pv.tu1;
	    dst->texcoord[1][1] = fxMesa->tScale1 * w * src->pv.tv1;
	    dst->texcoord[1][3] = w * src->pv.tq1;
	 }
      } else if (fxMesa->SetupIndex & TDFX_TEX0_BIT) {
	 dst->texcoord[0][0] = fxMesa->sScale0 * w * src->v.tu0;
	 dst->texcoord[0][1] = fxMesa->tScale0 * w * src->v.tv0;
	 dst->texcoord[0][3] = 1.0;

	 if (fxMesa->SetupIndex & TDFX_TEX1_BIT) {
	    dst->texcoord[1][0] = fxMesa->sScale1 * w * src->v.tu1;
	    dst->texcoord[1][1] = fxMesa->tScale1 * w * src->v.tv1;
	    dst->texcoord[1][3] = 1.0;
	 }
      }
   }

   dst->pointSize = ctx->Point._Size;
}


static void 
tdfx_fallback_tri( tdfxContextPtr fxMesa, 
		   tdfxVertex *v0, 
		   tdfxVertex *v1, 
		   tdfxVertex *v2 )
{
   GLcontext *ctx = fxMesa->glCtx;
   SWvertex v[3];
   tdfx_translate_vertex( ctx, v0, &v[0] );
   tdfx_translate_vertex( ctx, v1, &v[1] );
   tdfx_translate_vertex( ctx, v2, &v[2] );
   _swrast_Triangle( ctx, &v[0], &v[1], &v[2] );
}


static void 
tdfx_fallback_line( tdfxContextPtr fxMesa,
		    tdfxVertex *v0,
		    tdfxVertex *v1 )
{
   GLcontext *ctx = fxMesa->glCtx;
   SWvertex v[2];
   tdfx_translate_vertex( ctx, v0, &v[0] );
   tdfx_translate_vertex( ctx, v1, &v[1] );
   _swrast_Line( ctx, &v[0], &v[1] );
}


static void 
tdfx_fallback_point( tdfxContextPtr fxMesa, 
		     tdfxVertex *v0 )
{
   GLcontext *ctx = fxMesa->glCtx;
   SWvertex v[1];
   tdfx_translate_vertex( ctx, v0, &v[0] );
   _swrast_Point( ctx, &v[0] );
}

/***********************************************************************
 *                 Functions to draw basic primitives                  *
 ***********************************************************************/

static void tdfx_print_vertex( GLcontext *ctx, const tdfxVertex *v )
{
   tdfxContextPtr imesa = TDFX_CONTEXT( ctx );
d42 2
a43 85
   fprintf(stderr, "vertex at %p\n", (void *)v);

   if (imesa->vertexFormat == TDFX_LAYOUT_TINY) {
      fprintf(stderr, "x %f y %f z %f\n", v->v.x, v->v.y, v->v.z);
      fprintf(stderr, "r %d g %d b %d a %d\n", 
	      v->tv.color.red,
	      v->tv.color.green,
	      v->tv.color.blue,
	      v->tv.color.alpha);
   } 
   else {
      fprintf(stderr, "x %f y %f z %f oow %f\n", 
	      v->v.x, v->v.y, v->v.z, v->v.rhw);
      fprintf(stderr, "r %d g %d b %d a %d\n", 
	      v->v.color.red,
	      v->v.color.green,
	      v->v.color.blue,
	      v->v.color.alpha);
   }
   
   fprintf(stderr, "\n");
}

#define DO_FALLBACK 0

/* Need to do clip loop at each triangle when mixing swrast and hw
 * rendering.  These functions are only used when mixed-mode rendering
 * is occurring.
 */
static void tdfx_draw_quad( tdfxContextPtr fxMesa,
			    tdfxVertexPtr v0,
			    tdfxVertexPtr v1,
			    tdfxVertexPtr v2,
			    tdfxVertexPtr v3 )
{
/*     fprintf(stderr, "%s\n", __FUNCTION__); */
   BEGIN_CLIP_LOOP_LOCKED(fxMesa) {
      QUAD( v0, v1, v2, v3 );
   } END_CLIP_LOOP_LOCKED(fxMesa);
}

static void tdfx_draw_triangle( tdfxContextPtr fxMesa,
				tdfxVertexPtr v0,
				tdfxVertexPtr v1,
				tdfxVertexPtr v2 )
{
/*     fprintf(stderr, "%s\n", __FUNCTION__); */
/*     tdfx_print_vertex( fxMesa->glCtx, v0 ); */
/*     tdfx_print_vertex( fxMesa->glCtx, v1 ); */
/*     tdfx_print_vertex( fxMesa->glCtx, v2 ); */
   BEGIN_CLIP_LOOP_LOCKED(fxMesa) {
      TRI( v0, v1, v2 );
   } END_CLIP_LOOP_LOCKED(fxMesa);
}

static void tdfx_draw_line( tdfxContextPtr fxMesa,
			    tdfxVertexPtr v0,
			    tdfxVertexPtr v1 )
{
   /* No support for wide lines (avoid wide/aa line fallback).
    */
   BEGIN_CLIP_LOOP_LOCKED(fxMesa) {
      LINE(v0, v1);
   } END_CLIP_LOOP_LOCKED(fxMesa);
}

static void tdfx_draw_point( tdfxContextPtr fxMesa,
			     tdfxVertexPtr v0 )
{
   /* No support for wide points.
    */
   BEGIN_CLIP_LOOP_LOCKED(fxMesa) {
      POINT( v0 );
   } END_CLIP_LOOP_LOCKED(fxMesa);
}

#undef DO_FALLBACK


#define TDFX_UNFILLED_BIT    0x1
#define TDFX_OFFSET_BIT	     0x2
#define TDFX_TWOSIDE_BIT     0x4
#define TDFX_FLAT_BIT        0x8
#define TDFX_FALLBACK_BIT    0x10
#define TDFX_MAX_TRIFUNC     0x20
d46 2
a47 2
   points_func	        points;
   line_func		line;
d50 1
d53 18
a70 25
#define DO_FALLBACK (IND & TDFX_FALLBACK_BIT)
#define DO_OFFSET   (IND & TDFX_OFFSET_BIT)
#define DO_UNFILLED (IND & TDFX_UNFILLED_BIT)
#define DO_TWOSIDE  (IND & TDFX_TWOSIDE_BIT)
#define DO_FLAT     (IND & TDFX_FLAT_BIT)
#define DO_TRI       1
#define DO_QUAD      1
#define DO_LINE      1
#define DO_POINTS    1
#define DO_FULL_QUAD 1

#define HAVE_RGBA   1
#define HAVE_SPEC   0
#define HAVE_HW_FLATSHADE 0
#define HAVE_BACK_COLORS  0
#define VERTEX tdfxVertex
#define TAB rast_tab

#define TDFX_COLOR( dst, src )			\
do {						\
   dst[0] = src[2];				\
   dst[1] = src[1];				\
   dst[2] = src[0];				\
   dst[3] = src[3];				\
} while (0)
a71 20
#define DEPTH_SCALE 1.0
#define UNFILLED_TRI unfilled_tri
#define UNFILLED_QUAD unfilled_quad
#define VERT_X(_v) _v->v.x
#define VERT_Y(_v) _v->v.y
#define VERT_Z(_v) _v->v.z
#define AREA_IS_CCW( a ) (a < 0)
#define GET_VERTEX(e) (fxMesa->verts + (e<<fxMesa->vertex_stride_shift))

#define VERT_SET_RGBA( v, c )    TDFX_COLOR( v->ub4[coloroffset], c )
#define VERT_COPY_RGBA( v0, v1 ) v0->ui[coloroffset] = v1->ui[coloroffset]
#define VERT_SAVE_RGBA( idx )    color[idx] = v[idx]->ui[coloroffset]
#define VERT_RESTORE_RGBA( idx ) v[idx]->ui[coloroffset] = color[idx]   

#define LOCAL_VARS(n)					\
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);		\
   GLuint coloroffset = (fxMesa->vertexFormat ==	\
			 TDFX_LAYOUT_TINY) ? 3 : 4;	\
   GLuint color[n];					\
   (void) color; (void)coloroffset
d73 1
a73 10


/***********************************************************************
 *            Functions to draw basic unfilled primitives              *
 ***********************************************************************/

#define RASTERIZE(x) if (fxMesa->raster_primitive != x) \
                        tdfxRasterPrimitive( ctx, x )
#define RENDER_PRIMITIVE fxMesa->render_primitive
#define IND TDFX_FALLBACK_BIT
d75 1
a75 2
#include "tnl_dd/t_dd_unfilled.h"
#undef IND
d77 3
a79 7
/***********************************************************************
 *                 Functions to draw GL primitives                     *
 ***********************************************************************/

#define IND (0)
#define TAG(x) x
#include "tnl_dd/t_dd_tritmp.h"
d83 5
a87 1
#include "tnl_dd/t_dd_tritmp.h"
d91 5
a95 1
#include "tnl_dd/t_dd_tritmp.h"
d97 1
a97 1
#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT)
d99 1
a99 1
#include "tnl_dd/t_dd_tritmp.h"
d101 1
a101 65
#define IND (TDFX_UNFILLED_BIT)
#define TAG(x) x##_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT)
#define TAG(x) x##_offset_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_UNFILLED_BIT)
#define TAG(x) x##_twoside_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT)
#define TAG(x) x##_twoside_offset_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_FALLBACK_BIT)
#define TAG(x) x##_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_OFFSET_BIT|TDFX_FALLBACK_BIT)
#define TAG(x) x##_offset_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_FALLBACK_BIT)
#define TAG(x) x##_twoside_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT|TDFX_FALLBACK_BIT)
#define TAG(x) x##_twoside_offset_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_UNFILLED_BIT|TDFX_FALLBACK_BIT)
#define TAG(x) x##_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT|TDFX_FALLBACK_BIT)
#define TAG(x) x##_offset_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_UNFILLED_BIT|TDFX_FALLBACK_BIT)
#define TAG(x) x##_twoside_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT| \
	     TDFX_FALLBACK_BIT)
#define TAG(x) x##_twoside_offset_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"


/* Tdfx doesn't support provoking-vertex flat-shading?
 */
#define IND (TDFX_FLAT_BIT)
#define TAG(x) x##_flat
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_OFFSET_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_offset_flat
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_flat
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT|TDFX_FLAT_BIT)
d103 1
a103 9
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_UNFILLED_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_unfilled_flat
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_offset_unfilled_flat
#include "tnl_dd/t_dd_tritmp.h"
d105 3
a107 3
#define IND (TDFX_TWOSIDE_BIT|TDFX_UNFILLED_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_unfilled_flat
#include "tnl_dd/t_dd_tritmp.h"
d109 3
a111 3
#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_offset_unfilled_flat
#include "tnl_dd/t_dd_tritmp.h"
d113 3
a115 3
#define IND (TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"
d117 3
a119 3
#define IND (TDFX_OFFSET_BIT|TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_offset_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"
d121 3
a123 3
#define IND (TDFX_TWOSIDE_BIT|TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"
d125 3
a127 3
#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT|TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_offset_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"
d129 3
a131 3
#define IND (TDFX_UNFILLED_BIT|TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_unfilled_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"
d133 3
a135 3
#define IND (TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT|TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_offset_unfilled_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"
d137 1
a137 58
#define IND (TDFX_TWOSIDE_BIT|TDFX_UNFILLED_BIT|TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_unfilled_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT| \
	     TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_offset_unfilled_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"


static void init_rast_tab( void )
{
   init();
   init_offset();
   init_twoside();
   init_twoside_offset();
   init_unfilled();
   init_offset_unfilled();
   init_twoside_unfilled();
   init_twoside_offset_unfilled();
   init_fallback();
   init_offset_fallback();
   init_twoside_fallback();
   init_twoside_offset_fallback();
   init_unfilled_fallback();
   init_offset_unfilled_fallback();
   init_twoside_unfilled_fallback();
   init_twoside_offset_unfilled_fallback();

   init_flat();
   init_offset_flat();
   init_twoside_flat();
   init_twoside_offset_flat();
   init_unfilled_flat();
   init_offset_unfilled_flat();
   init_twoside_unfilled_flat();
   init_twoside_offset_unfilled_flat();
   init_fallback_flat();
   init_offset_fallback_flat();
   init_twoside_fallback_flat();
   init_twoside_offset_fallback_flat();
   init_unfilled_fallback_flat();
   init_offset_unfilled_fallback_flat();
   init_twoside_unfilled_fallback_flat();
   init_twoside_offset_unfilled_fallback_flat();
}


/**********************************************************************/
/*                 Render whole begin/end objects                     */
/**********************************************************************/


/* Accelerate vertex buffer rendering when renderindex == 0 and
 * there is no clipping.
 */

static void tdfx_render_vb_points( GLcontext *ctx,
d140 1
a140 1
				      GLuint flags )
d142 1
d144 1
a144 4
   GLuint shift = fxMesa->vertex_stride_shift;
   GLubyte *fxVB = fxMesa->verts + (start << shift);
   int stride = 1<<shift;
   GLubyte *tmp;
d146 1
a146 2
   (void) flags;

d148 3
a150 3
   for (i = start, tmp = fxVB; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x += PNT_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y += PNT_Y_OFFSET - TRI_Y_OFFSET;
a151 1

d153 1
a153 1
                                              fxVB, stride);
d155 3
a157 3
   for (i = start, tmp = fxVB; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x -= PNT_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y -= PNT_Y_OFFSET - TRI_Y_OFFSET;
d161 1
a161 1
static void tdfx_render_vb_line_strip( GLcontext *ctx,
d164 1
a164 1
				      GLuint flags )
d166 2
a167 5
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   GLubyte *fxVB = fxMesa->verts + (start << shift);
   int stride = 1<<shift;
   GLubyte *tmp;
d169 1
a169 2
   (void) flags;

d171 3
a173 3
   for (i = start, tmp = fxVB; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x += LINE_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y += LINE_Y_OFFSET - TRI_Y_OFFSET;
a174 1

d176 1
a176 41
                                              fxVB, 1<<shift);

   /* restore line coords */
   for (i = start, tmp = fxVB; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x -= LINE_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y -= LINE_Y_OFFSET - TRI_Y_OFFSET;
   }
}

static void tdfx_render_vb_line_loop( GLcontext *ctx,
				      GLuint start,
				      GLuint count,
				      GLuint flags )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   GLubyte *fxVB = fxMesa->verts + (start << shift);
   int stride = 1<<shift;
   GLubyte *tmp, *tmp2 = fxVB;
   GLint i;
   GLint j = start;
   (void) flags;

   if (!(flags & PRIM_BEGIN)) {
      fxVB += (1 << shift);
      j++;
   }

   /* adjust line coords */
   for (i = start, tmp = tmp2; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x += LINE_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y += LINE_Y_OFFSET - TRI_Y_OFFSET;
   }

   fxMesa->Glide.grDrawVertexArrayContiguous( GR_LINE_STRIP, count-j,
                                              fxVB, 1<<shift);

   if (flags & PRIM_END) 
      fxMesa->Glide.grDrawLine( fxMesa->verts + ((count - 1)<<shift), 
                                fxMesa->verts + (start<<shift) );

d178 3
a180 3
   for (i = start, tmp = tmp2; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x -= LINE_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y -= LINE_Y_OFFSET - TRI_Y_OFFSET;
d184 1
a184 1
static void tdfx_render_vb_lines( GLcontext *ctx,
d187 1
a187 1
				      GLuint flags )
d189 2
a190 5
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   GLubyte *fxVB = fxMesa->verts + (start << shift);
   int stride = 1<<shift;
   GLubyte *tmp;
d192 1
a192 2
   (void) flags;

d194 3
a196 3
   for (i = start, tmp = fxVB; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x += LINE_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y += LINE_Y_OFFSET - TRI_Y_OFFSET;
a197 1

d199 1
a199 2
                                              fxVB, 1<<shift);

d201 3
a203 3
   for (i = start, tmp = fxVB; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x -= LINE_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y -= LINE_Y_OFFSET - TRI_Y_OFFSET;
d207 1
a207 1
static void tdfx_render_vb_triangles( GLcontext *ctx,
d210 1
a210 1
				      GLuint flags )
d212 2
a213 5
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   GLubyte *fxVB = fxMesa->verts + (start << shift);
   (void) flags;

d215 2
a216 1
                                              fxVB, 1<<shift);
d220 1
a220 1
static void tdfx_render_vb_tri_strip( GLcontext *ctx,
d223 1
a223 1
				      GLuint flags )
d225 5
a229 16
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   GLubyte *fxVB = fxMesa->verts + (start << shift);
   int mode;
   (void) flags;

/*     fprintf(stderr, "%s/%d\n", __FUNCTION__, 1<<shift); */
/*     if(!prevLockLine) abort(); */

   if (flags & PRIM_PARITY) 
      mode = GR_TRIANGLE_STRIP_CONTINUE;
   else
      mode = GR_TRIANGLE_STRIP;

   fxMesa->Glide.grDrawVertexArrayContiguous( mode, count-start,
                                              fxVB, 1<<shift);
d233 1
a233 1
static void tdfx_render_vb_tri_fan( GLcontext *ctx,
d236 1
a236 1
				    GLuint flags )
d238 2
a239 5
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   GLubyte *fxVB = fxMesa->verts + (start << shift);
   (void) flags;

d241 2
a242 1
                                              fxVB, 1<<shift );
a244 30
static void tdfx_render_vb_quads( GLcontext *ctx,
				       GLuint start,
				       GLuint count,
				       GLuint flags )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   GLubyte *fxVB = fxMesa->verts;
   GLuint i;
   (void) flags;
   
   for (i = start ; i < count-3 ; i += 4 ) {
#define VERT(x) (fxVB + ((x)<<shift))
      fxMesa->Glide.grDrawTriangle( VERT(i),   VERT(i+1), VERT(i+3) );
      fxMesa->Glide.grDrawTriangle( VERT(i+1), VERT(i+2), VERT(i+3) );
#undef VERT
   }
}

static void tdfx_render_vb_quad_strip( GLcontext *ctx,
				       GLuint start,
				       GLuint count,
				       GLuint flags )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   GLubyte *fxVB = fxMesa->verts + (start << shift);
   (void) flags;

   count -= (count-start)&1;
d246 1
a246 5
   fxMesa->Glide.grDrawVertexArrayContiguous( GR_TRIANGLE_STRIP,
                                              count-start, fxVB, 1<<shift);
}

static void tdfx_render_vb_poly( GLcontext *ctx,
d249 1
a249 1
				 GLuint flags )
d251 2
a252 5
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   GLubyte *fxVB = fxMesa->verts + (start << shift);
   (void) flags;
   
d254 2
a255 1
                                              fxVB, 1<<shift);
a257 7
static void tdfx_render_vb_noop( GLcontext *ctx,
				 GLuint start,
				 GLuint count,
				 GLuint flags )
{
   (void) (ctx && start && count && flags);
}
d259 24
a282 52
static void (*tdfx_render_tab_verts[GL_POLYGON+2])(GLcontext *,
						   GLuint,
						   GLuint,
						   GLuint) = 
{
   tdfx_render_vb_points,
   tdfx_render_vb_lines,
   tdfx_render_vb_line_loop,
   tdfx_render_vb_line_strip,
   tdfx_render_vb_triangles,
   tdfx_render_vb_tri_strip,
   tdfx_render_vb_tri_fan,
   tdfx_render_vb_quads,
   tdfx_render_vb_quad_strip,
   tdfx_render_vb_poly,
   tdfx_render_vb_noop,
};


/**********************************************************************/
/*            Render whole (indexed) begin/end objects                */
/**********************************************************************/


#define VERT(x) (tdfxVertex *)(vertptr + ((x)<<vertshift))

#define RENDER_POINTS( start, count )		\
   for ( ; start < count ; start++)		\
      fxMesa->Glide.grDrawPoint( VERT(ELT(start)) );

#define RENDER_LINE( v0, v1 ) \
   fxMesa->Glide.grDrawLine( VERT(v0), VERT(v1) )

#define RENDER_TRI( v0, v1, v2 )  \
   fxMesa->Glide.grDrawTriangle( VERT(v0), VERT(v1), VERT(v2) )

#define RENDER_QUAD( v0, v1, v2, v3 ) \
   tdfx_draw_quad( fxMesa, VERT(v0), VERT(v1), VERT(v2), VERT(v3) )

#define INIT(x) tdfxRenderPrimitive( ctx, x )

#undef LOCAL_VARS
#define LOCAL_VARS						\
    tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);			\
    GLubyte *vertptr = (GLubyte *)fxMesa->verts;		\
    const GLuint vertshift = fxMesa->vertex_stride_shift;	\
    const GLuint * const elt = TNL_CONTEXT(ctx)->vb.Elts;	\
    (void) elt;

#define RESET_STIPPLE 
#define RESET_OCCLUSION 
#define PRESERVE_VB_DEFS
d284 5
a288 7
/* Elts, no clipping.
 */
#undef ELT
#undef TAG
#define TAG(x) tdfx_##x##_elts
#define ELT(x) elt[x]
#include "tnl_dd/t_dd_rendertmp.h"
d290 5
d297 6
a302 3
/**********************************************************************/
/*                   Render clipped primitives                        */
/**********************************************************************/
d304 2
d308 1
a308 2
static void tdfxRenderClippedPoly( GLcontext *ctx, const GLuint *elts, 
				   GLuint n )
d310 17
a326 13
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct vertex_buffer *VB = &tnl->vb;
   GLuint prim = fxMesa->render_primitive;

   /* Render the new vertices as an unclipped polygon. 
    */
   {
      GLuint *tmp = VB->Elts;
      VB->Elts = (GLuint *)elts;
      tnl->Driver.Render.PrimTabElts[GL_POLYGON]( ctx, 0, n, PRIM_BEGIN|PRIM_END );
      VB->Elts = tmp;
   }
d328 2
a329 4
   /* Restore the render primitive
    */
   if (prim != GL_POLYGON)
      tnl->Driver.Render.PrimitiveNotify( ctx, prim );
a331 5
static void tdfxRenderClippedLine( GLcontext *ctx, GLuint ii, GLuint jj )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   tnl->Driver.Render.Line( ctx, ii, jj );
}
d333 1
a333 2
static void tdfxFastRenderClippedPoly( GLcontext *ctx, const GLuint *elts, 
				       GLuint n )
d335 8
a342 5
   tdfxContextPtr fxMesa = TDFX_CONTEXT( ctx );
   GLubyte *vertptr = (GLubyte *)fxMesa->verts;			
   const GLuint vertshift = fxMesa->vertex_stride_shift;       	
   const GLuint *start = (const GLuint *)VERT(elts[0]);
   int i;
d344 18
a361 3
   for (i = 2 ; i < n ; i++) {
      fxMesa->Glide.grDrawTriangle( VERT(elts[i-1]), VERT(elts[i]), start );
   }
a363 4
/**********************************************************************/
/*                    Choose render functions                         */
/**********************************************************************/

d365 10
a374 9
#define POINT_FALLBACK (DD_POINT_SMOOTH)
#define LINE_FALLBACK (DD_LINE_STIPPLE)
#define TRI_FALLBACK (DD_TRI_SMOOTH)
#define ANY_FALLBACK_FLAGS (POINT_FALLBACK|LINE_FALLBACK|TRI_FALLBACK|DD_TRI_STIPPLE)
#define ANY_RASTER_FLAGS (DD_FLATSHADE|DD_TRI_LIGHT_TWOSIDE|DD_TRI_OFFSET| \
			  DD_TRI_UNFILLED)


/* All state referenced below:
d376 1
a376 12
#define _TDFX_NEW_RENDERSTATE (_DD_NEW_POINT_SMOOTH |		\
                               _DD_NEW_LINE_STIPPLE |		\
                               _DD_NEW_TRI_SMOOTH |		\
			       _DD_NEW_FLATSHADE |		\
			       _DD_NEW_TRI_UNFILLED |		\
			       _DD_NEW_TRI_LIGHT_TWOSIDE |	\
			       _DD_NEW_TRI_OFFSET |		\
			       _DD_NEW_TRI_STIPPLE |		\
			       _NEW_POLYGONSTIPPLE)


static void tdfxChooseRenderState(GLcontext *ctx)
d378 9
a386 10
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint flags = ctx->_TriangleCaps;
   GLuint index = 0;

   if (0) {
      fxMesa->draw_point = tdfx_draw_point;
      fxMesa->draw_line = tdfx_draw_line;
      fxMesa->draw_triangle = tdfx_draw_triangle;
      index |= TDFX_FALLBACK_BIT;
d389 24
a412 6
   if (flags & (ANY_FALLBACK_FLAGS|ANY_RASTER_FLAGS)) {
      if (flags & ANY_RASTER_FLAGS) {
	 if (flags & DD_TRI_LIGHT_TWOSIDE)    index |= TDFX_TWOSIDE_BIT;
	 if (flags & DD_TRI_OFFSET)	      index |= TDFX_OFFSET_BIT;
	 if (flags & DD_TRI_UNFILLED)	      index |= TDFX_UNFILLED_BIT;
	 if (flags & DD_FLATSHADE)	      index |= TDFX_FLAT_BIT;
d415 6
a420 22
      fxMesa->draw_point = tdfx_draw_point;
      fxMesa->draw_line = tdfx_draw_line;
      fxMesa->draw_triangle = tdfx_draw_triangle;

      /* Hook in fallbacks for specific primitives.
       *
       * DD_TRI_UNFILLED is here because the unfilled_tri functions use
       * fxMesa->draw_tri *always*, and thus can't use the multipass
       * approach to cliprects.
       *
       */
      if (flags & (POINT_FALLBACK|
		   LINE_FALLBACK|
		   TRI_FALLBACK|
		   DD_TRI_STIPPLE|
		   DD_TRI_UNFILLED))
      {
	 if (flags & POINT_FALLBACK)
	    fxMesa->draw_point = tdfx_fallback_point;

	 if (flags & LINE_FALLBACK)
	    fxMesa->draw_line = tdfx_fallback_line;
d422 8
a429 2
	 if (flags & TRI_FALLBACK)
	    fxMesa->draw_triangle = tdfx_fallback_tri;
d431 8
a438 4
	 if ((flags & DD_TRI_STIPPLE) && !fxMesa->haveHwStipple)
	    fxMesa->draw_triangle = tdfx_fallback_tri;

	 index |= TDFX_FALLBACK_BIT;
a439 1
   }
d441 9
a449 18
   if (fxMesa->RenderIndex != index) {
      fxMesa->RenderIndex = index;

      tnl->Driver.Render.Points = rast_tab[index].points;
      tnl->Driver.Render.Line = rast_tab[index].line;
      tnl->Driver.Render.Triangle = rast_tab[index].triangle;
      tnl->Driver.Render.Quad = rast_tab[index].quad;

      if (index == 0) {
	 tnl->Driver.Render.PrimTabVerts = tdfx_render_tab_verts;
	 tnl->Driver.Render.PrimTabElts = tdfx_render_tab_elts;
	 tnl->Driver.Render.ClippedLine = line; /* from tritmp.h */
	 tnl->Driver.Render.ClippedPolygon = tdfxFastRenderClippedPoly;
      } else {
	 tnl->Driver.Render.PrimTabVerts = _tnl_render_tab_verts;
	 tnl->Driver.Render.PrimTabElts = _tnl_render_tab_elts;
	 tnl->Driver.Render.ClippedLine = tdfxRenderClippedLine;
	 tnl->Driver.Render.ClippedPolygon = tdfxRenderClippedPoly;
a450 6
   }
}

/**********************************************************************/
/*                Use multipass rendering for cliprects               */
/**********************************************************************/
d452 2
d455 1
a455 17

/* TODO: Benchmark this.
 * TODO: Use single back-buffer cliprect where possible.  
 * NOTE: <pass> starts at 1, not zero!
 */
static GLboolean multipass_cliprect( GLcontext *ctx, GLuint pass )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   if (pass >= fxMesa->numClipRects)
      return GL_FALSE;
   else {   
      fxMesa->Glide.grClipWindow(fxMesa->pClipRects[pass].x1,
		   fxMesa->screen_height - fxMesa->pClipRects[pass].y2,
		   fxMesa->pClipRects[pass].x2,
		   fxMesa->screen_height - fxMesa->pClipRects[pass].y1);
      
      return GL_TRUE;
a456 10
}


/**********************************************************************/
/*                Runtime render state and callbacks                  */
/**********************************************************************/

static void tdfxRunPipeline( GLcontext *ctx )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
a457 3
   if (fxMesa->new_state) {
      tdfxDDUpdateHwState( ctx );
   }
d459 3
a461 8
   if (!fxMesa->Fallback && fxMesa->new_gl_state) {
      if (fxMesa->new_gl_state & _TDFX_NEW_RASTERSETUP)
	 tdfxChooseVertexState( ctx );
      
      if (fxMesa->new_gl_state & _TDFX_NEW_RENDERSTATE)
	 tdfxChooseRenderState( ctx );
      
      fxMesa->new_gl_state = 0;
a462 2

   _tnl_run_pipeline( ctx );
d466 1
a466 50
static void tdfxRenderStart( GLcontext *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);

   tdfxCheckTexSizes( ctx );

   LOCK_HARDWARE(fxMesa);

   /* Make sure vertex format changes get uploaded before we start
    * sending triangles.  
    */
   if (fxMesa->dirty) {
      tdfxEmitHwStateLocked( fxMesa );
   }

   if (fxMesa->numClipRects && !(fxMesa->RenderIndex & TDFX_FALLBACK_BIT)) {
      fxMesa->Glide.grClipWindow(fxMesa->pClipRects[0].x1,
		   fxMesa->screen_height - fxMesa->pClipRects[0].y2,
		   fxMesa->pClipRects[0].x2,
		   fxMesa->screen_height - fxMesa->pClipRects[0].y1);
      if (fxMesa->numClipRects > 1)
         tnl->Driver.Render.Multipass = multipass_cliprect;
      else
         tnl->Driver.Render.Multipass = NULL;
   }
   else
      tnl->Driver.Render.Multipass = NULL;
}


static GLenum reduced_prim[GL_POLYGON+1] = {
   GL_POINTS,
   GL_LINES,
   GL_LINES,
   GL_LINES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES
};



/* Always called between RenderStart and RenderFinish --> We already
 * hold the lock.
 */
static void tdfxRasterPrimitive( GLcontext *ctx, GLenum prim )
d469 2
d472 1
a472 36
   FLUSH_BATCH( fxMesa );

   fxMesa->raster_primitive = prim;

   tdfxUpdateCull(ctx);
   if ( fxMesa->dirty & TDFX_UPLOAD_CULL ) {
      fxMesa->Glide.grCullMode( fxMesa->CullMode );
      fxMesa->dirty &= ~TDFX_UPLOAD_CULL;
   }

   tdfxUpdateStipple(ctx);
   if ( fxMesa->dirty & TDFX_UPLOAD_STIPPLE ) {
      fxMesa->Glide.grStipplePattern ( fxMesa->Stipple.Pattern );
      fxMesa->Glide.grStippleMode ( fxMesa->Stipple.Mode );
      fxMesa->dirty &= ~TDFX_UPLOAD_STIPPLE;
   }
}



/* Determine the rasterized primitive when not drawing unfilled 
 * polygons.
 *
 * Used only for the default render stage which always decomposes
 * primitives to trianges/lines/points.  For the accelerated stage,
 * which renders strips as strips, the equivalent calculations are
 * performed in tdfx_render.c.
 */
static void tdfxRenderPrimitive( GLcontext *ctx, GLenum prim )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint rprim = reduced_prim[prim];

   fxMesa->render_primitive = prim;

   if (rprim == GL_TRIANGLES && (ctx->_TriangleCaps & DD_TRI_UNFILLED))
a473 15
       
   if (fxMesa->raster_primitive != rprim) {
      tdfxRasterPrimitive( ctx, rprim );
   }
}

static void tdfxRenderFinish( GLcontext *ctx )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);

   if (fxMesa->RenderIndex & TDFX_FALLBACK_BIT)
      _swrast_flush( ctx );

   UNLOCK_HARDWARE(fxMesa);
}
d475 4
d480 2
a481 17
/**********************************************************************/
/*               Manage total rasterization fallbacks                 */
/**********************************************************************/

static char *fallbackStrings[] = {
   "1D/3D Texture map",
   "glDrawBuffer(GL_FRONT_AND_BACK)",
   "Separate specular color",
   "glEnable/Disable(GL_STENCIL_TEST)",
   "glRenderMode(selection or feedback)",
   "glLogicOp()",
   "Texture env mode",
   "Texture border",
   "glColorMask",
   "blend mode",
   "line stipple"
};
d483 2
d486 2
a487 9
static char *getFallbackString(GLuint bit)
{
   int i = 0;
   while (bit > 1) {
      i++;
      bit >>= 1;
   }
   return fallbackStrings[i];
}
d489 2
d492 2
a493 37
void tdfxFallback( GLcontext *ctx, GLuint bit, GLboolean mode )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint oldfallback = fxMesa->Fallback;

   if (mode) {
      fxMesa->Fallback |= bit;
      if (oldfallback == 0) {
         /*printf("Go to software rendering, bit = 0x%x\n", bit);*/
	 FLUSH_BATCH(fxMesa);
	 _swsetup_Wakeup( ctx );
	 fxMesa->RenderIndex = ~0;
         if (fxMesa->debugFallbacks) {
            fprintf(stderr, "Tdfx begin software fallback: 0x%x %s\n",
                    bit, getFallbackString(bit));
         }
      }
   }
   else {
      fxMesa->Fallback &= ~bit;
      if (oldfallback == bit) {
         /*printf("Go to hardware rendering, bit = 0x%x\n", bit);*/
	 _swrast_flush( ctx );
	 tnl->Driver.Render.Start = tdfxRenderStart;
	 tnl->Driver.Render.PrimitiveNotify = tdfxRenderPrimitive;
	 tnl->Driver.Render.Finish = tdfxRenderFinish;
	 tnl->Driver.Render.BuildVertices = tdfxBuildVertices;
	 fxMesa->new_gl_state |= (_TDFX_NEW_RENDERSTATE|
				  _TDFX_NEW_RASTERSETUP);
         if (fxMesa->debugFallbacks) {
            fprintf(stderr, "Tdfx end software fallback: 0x%x %s\n",
                    bit, getFallbackString(bit));
         }
      }
   }
}
d495 2
d498 2
a499 5
void tdfxDDInitTriFuncs( GLcontext *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   static int firsttime = 1;
d501 5
a505 4
   if (firsttime) {
      init_rast_tab();
      firsttime = 0;
   }
d507 5
a511 9
   fxMesa->RenderIndex = ~0;
	
   tnl->Driver.RunPipeline              = tdfxRunPipeline;
   tnl->Driver.Render.Start             = tdfxRenderStart;
   tnl->Driver.Render.Finish            = tdfxRenderFinish; 
   tnl->Driver.Render.PrimitiveNotify   = tdfxRenderPrimitive;
   tnl->Driver.Render.ResetLineStipple  = _swrast_ResetLineStipple;
   tnl->Driver.Render.BuildVertices     = tdfxBuildVertices;
   tnl->Driver.Render.Multipass		= NULL;
d513 2
a514 1
   (void) tdfx_print_vertex;
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d26 1
a26 1
/* $XFree86: xc/lib/GL/mesa/src/drv/tdfx/tdfx_tris.c,v 1.4 2002/10/30 12:52:01 alanh Exp $ */
d28 9
a36 2
/* Authors:
 *    Keith Whitwell <keith@@tungstengraphics.com>
d39 1
a39 14
#include <stdio.h>
#include <math.h>

#include "glheader.h"
#include "mtypes.h"
#include "macros.h"
#include "colormac.h"

#include "swrast/swrast.h"
#include "swrast_setup/swrast_setup.h"
#include "swrast_setup/ss_context.h"
#include "tnl/t_context.h"
#include "tnl/t_pipeline.h"

a40 215
#include "tdfx_state.h"
#include "tdfx_vb.h"
#include "tdfx_lock.h"
#include "tdfx_render.h"


static void tdfxRasterPrimitive( GLcontext *ctx, GLenum prim );
static void tdfxRenderPrimitive( GLcontext *ctx, GLenum prim );

/***********************************************************************
 *          Macros for t_dd_tritmp.h to draw basic primitives          *
 ***********************************************************************/

#define TRI( a, b, c )				\
do {						\
   if (DO_FALLBACK)				\
      fxMesa->draw_triangle( fxMesa, a, b, c );	\
   else						\
      fxMesa->Glide.grDrawTriangle( a, b, c );	\
} while (0)					\

#define QUAD( a, b, c, d )			\
do {						\
   if (DO_FALLBACK) {				\
      fxMesa->draw_triangle( fxMesa, a, b, d );	\
      fxMesa->draw_triangle( fxMesa, b, c, d );	\
   } else {					\
      fxMesa->Glide.grDrawTriangle( a, b, d );	\
      fxMesa->Glide.grDrawTriangle( b, c, d );	\
   }						\
} while (0)

#define LINE( v0, v1 )				\
do {						\
   if (DO_FALLBACK)				\
      fxMesa->draw_line( fxMesa, v0, v1 );	\
   else {					\
      v0->v.x += LINE_X_OFFSET - TRI_X_OFFSET;	\
      v0->v.y += LINE_Y_OFFSET - TRI_Y_OFFSET;	\
      v1->v.x += LINE_X_OFFSET - TRI_X_OFFSET;	\
      v1->v.y += LINE_Y_OFFSET - TRI_Y_OFFSET;	\
      fxMesa->Glide.grDrawLine( v0, v1 );	\
      v0->v.x -= LINE_X_OFFSET - TRI_X_OFFSET;	\
      v0->v.y -= LINE_Y_OFFSET - TRI_Y_OFFSET;	\
      v1->v.x -= LINE_X_OFFSET - TRI_X_OFFSET;	\
      v1->v.y -= LINE_Y_OFFSET - TRI_Y_OFFSET;	\
   }						\
} while (0)

#define POINT( v0 )				\
do {						\
   if (DO_FALLBACK)				\
      fxMesa->draw_point( fxMesa, v0 );		\
   else {					\
      v0->v.x += PNT_X_OFFSET - TRI_X_OFFSET;	\
      v0->v.y += PNT_Y_OFFSET - TRI_Y_OFFSET;	\
      fxMesa->Glide.grDrawPoint( v0 );		\
      v0->v.x -= PNT_X_OFFSET - TRI_X_OFFSET;	\
      v0->v.y -= PNT_Y_OFFSET - TRI_Y_OFFSET;	\
   }						\
} while (0)


/***********************************************************************
 *              Fallback to swrast for basic primitives                *
 ***********************************************************************/

/* Build an SWvertex from a hardware vertex. 
 *
 * This code is hit only when a mix of accelerated and unaccelerated
 * primitives are being drawn, and only for the unaccelerated
 * primitives.  
 */
static void 
tdfx_translate_vertex( GLcontext *ctx, const tdfxVertex *src, SWvertex *dst)
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);

   if (fxMesa->vertexFormat == TDFX_LAYOUT_TINY) {
      dst->win[0] = src->tv.x - fxMesa->x_offset;
      dst->win[1] = src->tv.y - (fxMesa->screen_height - fxMesa->height - fxMesa->y_offset);
      dst->win[2] = src->tv.z;
      dst->win[3] = 1.0;

      dst->color[0] = src->tv.color.red;
      dst->color[1] = src->tv.color.green;
      dst->color[2] = src->tv.color.blue;
      dst->color[3] = src->tv.color.alpha;
   } 
   else {
      GLfloat w = 1.0 / src->v.rhw;

      dst->win[0] = src->v.x - fxMesa->x_offset;
      dst->win[1] = fxMesa->screen_height - fxMesa->y_offset - src->v.y;
      dst->win[2] = src->v.z;
      dst->win[3] = src->v.rhw;

      dst->color[0] = src->v.color.red;
      dst->color[1] = src->v.color.green;
      dst->color[2] = src->v.color.blue;
      dst->color[3] = src->v.color.alpha;

      if (fxMesa->vertexFormat == TDFX_LAYOUT_PROJECT) {
	 dst->texcoord[0][0] = fxMesa->sScale0 * w * src->pv.tu0;
	 dst->texcoord[0][1] = fxMesa->tScale0 * w * src->pv.tv0;
	 dst->texcoord[0][3] = w * src->pv.tq0;

	 if (fxMesa->SetupIndex & TDFX_TEX1_BIT) {
	    dst->texcoord[1][0] = fxMesa->sScale1 * w * src->pv.tu1;
	    dst->texcoord[1][1] = fxMesa->tScale1 * w * src->pv.tv1;
	    dst->texcoord[1][3] = w * src->pv.tq1;
	 }
      } else if (fxMesa->SetupIndex & TDFX_TEX0_BIT) {
	 dst->texcoord[0][0] = fxMesa->sScale0 * w * src->v.tu0;
	 dst->texcoord[0][1] = fxMesa->tScale0 * w * src->v.tv0;
	 dst->texcoord[0][3] = 1.0;

	 if (fxMesa->SetupIndex & TDFX_TEX1_BIT) {
	    dst->texcoord[1][0] = fxMesa->sScale1 * w * src->v.tu1;
	    dst->texcoord[1][1] = fxMesa->tScale1 * w * src->v.tv1;
	    dst->texcoord[1][3] = 1.0;
	 }
      }
   }

   dst->pointSize = ctx->Point._Size;
}


static void 
tdfx_fallback_tri( tdfxContextPtr fxMesa, 
		   tdfxVertex *v0, 
		   tdfxVertex *v1, 
		   tdfxVertex *v2 )
{
   GLcontext *ctx = fxMesa->glCtx;
   SWvertex v[3];
   tdfx_translate_vertex( ctx, v0, &v[0] );
   tdfx_translate_vertex( ctx, v1, &v[1] );
   tdfx_translate_vertex( ctx, v2, &v[2] );
   _swrast_Triangle( ctx, &v[0], &v[1], &v[2] );
}


static void 
tdfx_fallback_line( tdfxContextPtr fxMesa,
		    tdfxVertex *v0,
		    tdfxVertex *v1 )
{
   GLcontext *ctx = fxMesa->glCtx;
   SWvertex v[2];
   tdfx_translate_vertex( ctx, v0, &v[0] );
   tdfx_translate_vertex( ctx, v1, &v[1] );
   _swrast_Line( ctx, &v[0], &v[1] );
}


static void 
tdfx_fallback_point( tdfxContextPtr fxMesa, 
		     tdfxVertex *v0 )
{
   GLcontext *ctx = fxMesa->glCtx;
   SWvertex v[1];
   tdfx_translate_vertex( ctx, v0, &v[0] );
   _swrast_Point( ctx, &v[0] );
}

/***********************************************************************
 *                 Functions to draw basic primitives                  *
 ***********************************************************************/

static void tdfx_print_vertex( GLcontext *ctx, const tdfxVertex *v )
{
   tdfxContextPtr imesa = TDFX_CONTEXT( ctx );

   fprintf(stderr, "vertex at %p\n", v);

   if (imesa->vertexFormat == TDFX_LAYOUT_TINY) {
      fprintf(stderr, "x %f y %f z %f\n", v->v.x, v->v.y, v->v.z);
      fprintf(stderr, "r %d g %d b %d a %d\n", 
	      v->tv.color.red,
	      v->tv.color.green,
	      v->tv.color.blue,
	      v->tv.color.alpha);
   } 
   else {
      fprintf(stderr, "x %f y %f z %f oow %f\n", 
	      v->v.x, v->v.y, v->v.z, v->v.rhw);
      fprintf(stderr, "r %d g %d b %d a %d\n", 
	      v->v.color.red,
	      v->v.color.green,
	      v->v.color.blue,
	      v->v.color.alpha);
   }
   
   fprintf(stderr, "\n");
}

#define DO_FALLBACK 0

/* Need to do clip loop at each triangle when mixing swrast and hw
 * rendering.  These functions are only used when mixed-mode rendering
 * is occurring.
 */
static void tdfx_draw_quad( tdfxContextPtr fxMesa,
			    tdfxVertexPtr v0,
			    tdfxVertexPtr v1,
			    tdfxVertexPtr v2,
			    tdfxVertexPtr v3 )
{
/*     fprintf(stderr, "%s\n", __FUNCTION__); */
   BEGIN_CLIP_LOOP_LOCKED(fxMesa) {
      QUAD( v0, v1, v2, v3 );
   } END_CLIP_LOOP_LOCKED(fxMesa);
}
d42 2
a43 44
static void tdfx_draw_triangle( tdfxContextPtr fxMesa,
				tdfxVertexPtr v0,
				tdfxVertexPtr v1,
				tdfxVertexPtr v2 )
{
/*     fprintf(stderr, "%s\n", __FUNCTION__); */
/*     tdfx_print_vertex( fxMesa->glCtx, v0 ); */
/*     tdfx_print_vertex( fxMesa->glCtx, v1 ); */
/*     tdfx_print_vertex( fxMesa->glCtx, v2 ); */
   BEGIN_CLIP_LOOP_LOCKED(fxMesa) {
      TRI( v0, v1, v2 );
   } END_CLIP_LOOP_LOCKED(fxMesa);
}

static void tdfx_draw_line( tdfxContextPtr fxMesa,
			    tdfxVertexPtr v0,
			    tdfxVertexPtr v1 )
{
   /* No support for wide lines (avoid wide/aa line fallback).
    */
   BEGIN_CLIP_LOOP_LOCKED(fxMesa) {
      LINE(v0, v1);
   } END_CLIP_LOOP_LOCKED(fxMesa);
}

static void tdfx_draw_point( tdfxContextPtr fxMesa,
			     tdfxVertexPtr v0 )
{
   /* No support for wide points.
    */
   BEGIN_CLIP_LOOP_LOCKED(fxMesa) {
      POINT( v0 );
   } END_CLIP_LOOP_LOCKED(fxMesa);
}

#undef DO_FALLBACK


#define TDFX_UNFILLED_BIT    0x1
#define TDFX_OFFSET_BIT	     0x2
#define TDFX_TWOSIDE_BIT     0x4
#define TDFX_FLAT_BIT        0x8
#define TDFX_FALLBACK_BIT    0x10
#define TDFX_MAX_TRIFUNC     0x20
d46 2
a47 2
   points_func	        points;
   line_func		line;
d50 1
d53 18
a70 25
#define DO_FALLBACK (IND & TDFX_FALLBACK_BIT)
#define DO_OFFSET   (IND & TDFX_OFFSET_BIT)
#define DO_UNFILLED (IND & TDFX_UNFILLED_BIT)
#define DO_TWOSIDE  (IND & TDFX_TWOSIDE_BIT)
#define DO_FLAT     (IND & TDFX_FLAT_BIT)
#define DO_TRI       1
#define DO_QUAD      1
#define DO_LINE      1
#define DO_POINTS    1
#define DO_FULL_QUAD 1

#define HAVE_RGBA   1
#define HAVE_SPEC   0
#define HAVE_HW_FLATSHADE 0
#define HAVE_BACK_COLORS  0
#define VERTEX tdfxVertex
#define TAB rast_tab

#define TDFX_COLOR( dst, src )			\
do {						\
   dst[0] = src[2];				\
   dst[1] = src[1];				\
   dst[2] = src[0];				\
   dst[3] = src[3];				\
} while (0)
a71 20
#define DEPTH_SCALE 1.0
#define UNFILLED_TRI unfilled_tri
#define UNFILLED_QUAD unfilled_quad
#define VERT_X(_v) _v->v.x
#define VERT_Y(_v) _v->v.y
#define VERT_Z(_v) _v->v.z
#define AREA_IS_CCW( a ) (a < 0)
#define GET_VERTEX(e) (fxMesa->verts + (e<<fxMesa->vertex_stride_shift))

#define VERT_SET_RGBA( v, c )    TDFX_COLOR( v->ub4[coloroffset], c )
#define VERT_COPY_RGBA( v0, v1 ) v0->ui[coloroffset] = v1->ui[coloroffset]
#define VERT_SAVE_RGBA( idx )    color[idx] = v[idx]->ui[coloroffset]
#define VERT_RESTORE_RGBA( idx ) v[idx]->ui[coloroffset] = color[idx]   

#define LOCAL_VARS(n)					\
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);		\
   GLuint coloroffset = (fxMesa->vertexFormat ==	\
			 TDFX_LAYOUT_TINY) ? 3 : 4;	\
   GLuint color[n];					\
   (void) color; (void)coloroffset
d73 1
a73 10


/***********************************************************************
 *            Functions to draw basic unfilled primitives              *
 ***********************************************************************/

#define RASTERIZE(x) if (fxMesa->raster_primitive != x) \
                        tdfxRasterPrimitive( ctx, x )
#define RENDER_PRIMITIVE fxMesa->render_primitive
#define IND TDFX_FALLBACK_BIT
d75 1
a75 2
#include "tnl_dd/t_dd_unfilled.h"
#undef IND
d77 3
a79 7
/***********************************************************************
 *                 Functions to draw GL primitives                     *
 ***********************************************************************/

#define IND (0)
#define TAG(x) x
#include "tnl_dd/t_dd_tritmp.h"
d83 5
a87 1
#include "tnl_dd/t_dd_tritmp.h"
d91 5
a95 1
#include "tnl_dd/t_dd_tritmp.h"
d97 1
a97 1
#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT)
d99 1
a99 1
#include "tnl_dd/t_dd_tritmp.h"
d101 1
a101 65
#define IND (TDFX_UNFILLED_BIT)
#define TAG(x) x##_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT)
#define TAG(x) x##_offset_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_UNFILLED_BIT)
#define TAG(x) x##_twoside_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT)
#define TAG(x) x##_twoside_offset_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_FALLBACK_BIT)
#define TAG(x) x##_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_OFFSET_BIT|TDFX_FALLBACK_BIT)
#define TAG(x) x##_offset_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_FALLBACK_BIT)
#define TAG(x) x##_twoside_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT|TDFX_FALLBACK_BIT)
#define TAG(x) x##_twoside_offset_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_UNFILLED_BIT|TDFX_FALLBACK_BIT)
#define TAG(x) x##_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT|TDFX_FALLBACK_BIT)
#define TAG(x) x##_offset_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_UNFILLED_BIT|TDFX_FALLBACK_BIT)
#define TAG(x) x##_twoside_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT| \
	     TDFX_FALLBACK_BIT)
#define TAG(x) x##_twoside_offset_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"


/* Tdfx doesn't support provoking-vertex flat-shading?
 */
#define IND (TDFX_FLAT_BIT)
#define TAG(x) x##_flat
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_OFFSET_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_offset_flat
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_flat
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT|TDFX_FLAT_BIT)
d103 1
a103 9
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_UNFILLED_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_unfilled_flat
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_offset_unfilled_flat
#include "tnl_dd/t_dd_tritmp.h"
d105 3
a107 3
#define IND (TDFX_TWOSIDE_BIT|TDFX_UNFILLED_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_unfilled_flat
#include "tnl_dd/t_dd_tritmp.h"
d109 3
a111 3
#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_offset_unfilled_flat
#include "tnl_dd/t_dd_tritmp.h"
d113 3
a115 3
#define IND (TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"
d117 3
a119 3
#define IND (TDFX_OFFSET_BIT|TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_offset_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"
d121 3
a123 3
#define IND (TDFX_TWOSIDE_BIT|TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"
d125 3
a127 3
#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT|TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_offset_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"
d129 3
a131 3
#define IND (TDFX_UNFILLED_BIT|TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_unfilled_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"
d133 3
a135 3
#define IND (TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT|TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_offset_unfilled_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"
d137 1
a137 58
#define IND (TDFX_TWOSIDE_BIT|TDFX_UNFILLED_BIT|TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_unfilled_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"

#define IND (TDFX_TWOSIDE_BIT|TDFX_OFFSET_BIT|TDFX_UNFILLED_BIT| \
	     TDFX_FALLBACK_BIT|TDFX_FLAT_BIT)
#define TAG(x) x##_twoside_offset_unfilled_fallback_flat
#include "tnl_dd/t_dd_tritmp.h"


static void init_rast_tab( void )
{
   init();
   init_offset();
   init_twoside();
   init_twoside_offset();
   init_unfilled();
   init_offset_unfilled();
   init_twoside_unfilled();
   init_twoside_offset_unfilled();
   init_fallback();
   init_offset_fallback();
   init_twoside_fallback();
   init_twoside_offset_fallback();
   init_unfilled_fallback();
   init_offset_unfilled_fallback();
   init_twoside_unfilled_fallback();
   init_twoside_offset_unfilled_fallback();

   init_flat();
   init_offset_flat();
   init_twoside_flat();
   init_twoside_offset_flat();
   init_unfilled_flat();
   init_offset_unfilled_flat();
   init_twoside_unfilled_flat();
   init_twoside_offset_unfilled_flat();
   init_fallback_flat();
   init_offset_fallback_flat();
   init_twoside_fallback_flat();
   init_twoside_offset_fallback_flat();
   init_unfilled_fallback_flat();
   init_offset_unfilled_fallback_flat();
   init_twoside_unfilled_fallback_flat();
   init_twoside_offset_unfilled_fallback_flat();
}


/**********************************************************************/
/*                 Render whole begin/end objects                     */
/**********************************************************************/


/* Accelerate vertex buffer rendering when renderindex == 0 and
 * there is no clipping.
 */

static void tdfx_render_vb_points( GLcontext *ctx,
d140 1
a140 1
				      GLuint flags )
d142 1
d144 1
a144 4
   GLuint shift = fxMesa->vertex_stride_shift;
   char *fxVB = fxMesa->verts + (start << shift);
   int stride = 1<<shift;
   char *tmp;
d146 1
a146 2
   (void) flags;

d148 3
a150 3
   for (i = start, tmp = fxVB; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x += PNT_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y += PNT_Y_OFFSET - TRI_Y_OFFSET;
a151 1

d153 1
a153 1
                                              fxVB, stride);
d155 3
a157 3
   for (i = start, tmp = fxVB; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x -= PNT_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y -= PNT_Y_OFFSET - TRI_Y_OFFSET;
d161 1
a161 1
static void tdfx_render_vb_line_strip( GLcontext *ctx,
d164 1
a164 1
				      GLuint flags )
d166 2
a167 5
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   char *fxVB = fxMesa->verts + (start << shift);
   int stride = 1<<shift;
   char *tmp;
d169 1
a169 2
   (void) flags;

d171 3
a173 3
   for (i = start, tmp = fxVB; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x += LINE_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y += LINE_Y_OFFSET - TRI_Y_OFFSET;
a174 1

d176 1
a176 41
                                              fxVB, 1<<shift);

   /* restore line coords */
   for (i = start, tmp = fxVB; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x -= LINE_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y -= LINE_Y_OFFSET - TRI_Y_OFFSET;
   }
}

static void tdfx_render_vb_line_loop( GLcontext *ctx,
				      GLuint start,
				      GLuint count,
				      GLuint flags )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   char *fxVB = fxMesa->verts + (start << shift);
   int stride = 1<<shift;
   char *tmp, *tmp2 = fxVB;
   GLint i;
   GLint j = start;
   (void) flags;

   if (!(flags & PRIM_BEGIN)) {
      fxVB += (1 << shift);
      j++;
   }

   /* adjust line coords */
   for (i = start, tmp = tmp2; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x += LINE_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y += LINE_Y_OFFSET - TRI_Y_OFFSET;
   }

   fxMesa->Glide.grDrawVertexArrayContiguous( GR_LINE_STRIP, count-j,
                                              fxVB, 1<<shift);

   if (flags & PRIM_END) 
      fxMesa->Glide.grDrawLine( fxMesa->verts + ((count - 1)<<shift), 
                                fxMesa->verts + (start<<shift) );

d178 3
a180 3
   for (i = start, tmp = tmp2; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x -= LINE_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y -= LINE_Y_OFFSET - TRI_Y_OFFSET;
d184 1
a184 1
static void tdfx_render_vb_lines( GLcontext *ctx,
d187 1
a187 1
				      GLuint flags )
d189 2
a190 5
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   char *fxVB = fxMesa->verts + (start << shift);
   int stride = 1<<shift;
   char *tmp;
d192 1
a192 2
   (void) flags;

d194 3
a196 3
   for (i = start, tmp = fxVB; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x += LINE_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y += LINE_Y_OFFSET - TRI_Y_OFFSET;
a197 1

d199 1
a199 2
                                              fxVB, 1<<shift);

d201 3
a203 3
   for (i = start, tmp = fxVB; i < count; i++, tmp += stride) {
      ((tdfxVertexPtr)tmp)->v.x -= LINE_X_OFFSET - TRI_X_OFFSET;
      ((tdfxVertexPtr)tmp)->v.y -= LINE_Y_OFFSET - TRI_Y_OFFSET;
d207 1
a207 1
static void tdfx_render_vb_triangles( GLcontext *ctx,
d210 1
a210 1
				      GLuint flags )
d212 2
a213 5
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   char *fxVB = fxMesa->verts + (start << shift);
   (void) flags;

d215 2
a216 1
                                              fxVB, 1<<shift);
d220 1
a220 1
static void tdfx_render_vb_tri_strip( GLcontext *ctx,
d223 1
a223 1
				      GLuint flags )
d225 5
a229 16
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   char *fxVB = fxMesa->verts + (start << shift);
   int mode;
   (void) flags;

/*     fprintf(stderr, "%s/%d\n", __FUNCTION__, 1<<shift); */
/*     if(!prevLockLine) abort(); */

   if (flags & PRIM_PARITY) 
      mode = GR_TRIANGLE_STRIP_CONTINUE;
   else
      mode = GR_TRIANGLE_STRIP;

   fxMesa->Glide.grDrawVertexArrayContiguous( mode, count-start,
                                              fxVB, 1<<shift);
d233 1
a233 1
static void tdfx_render_vb_tri_fan( GLcontext *ctx,
d236 1
a236 1
				    GLuint flags )
d238 2
a239 5
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   char *fxVB = fxMesa->verts + (start << shift);
   (void) flags;

d241 2
a242 1
                                              fxVB, 1<<shift );
a244 30
static void tdfx_render_vb_quads( GLcontext *ctx,
				       GLuint start,
				       GLuint count,
				       GLuint flags )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   char *fxVB = fxMesa->verts;
   GLuint i;
   (void) flags;
   
   for (i = start ; i < count-3 ; i += 4 ) {
#define VERT(x) (fxVB + ((x)<<shift))
      fxMesa->Glide.grDrawTriangle( VERT(i),   VERT(i+1), VERT(i+3) );
      fxMesa->Glide.grDrawTriangle( VERT(i+1), VERT(i+2), VERT(i+3) );
#undef VERT
   }
}

static void tdfx_render_vb_quad_strip( GLcontext *ctx,
				       GLuint start,
				       GLuint count,
				       GLuint flags )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   char *fxVB = fxMesa->verts + (start << shift);
   (void) flags;

   count -= (count-start)&1;
d246 1
a246 5
   fxMesa->Glide.grDrawVertexArrayContiguous( GR_TRIANGLE_STRIP,
                                              count-start, fxVB, 1<<shift);
}

static void tdfx_render_vb_poly( GLcontext *ctx,
d249 1
a249 1
				 GLuint flags )
d251 2
a252 5
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint shift = fxMesa->vertex_stride_shift;
   char *fxVB = fxMesa->verts + (start << shift);
   (void) flags;
   
d254 2
a255 1
                                              fxVB, 1<<shift);
a257 7
static void tdfx_render_vb_noop( GLcontext *ctx,
				 GLuint start,
				 GLuint count,
				 GLuint flags )
{
   (void) (ctx && start && count && flags);
}
d259 24
a282 52
static void (*tdfx_render_tab_verts[GL_POLYGON+2])(GLcontext *,
						   GLuint,
						   GLuint,
						   GLuint) = 
{
   tdfx_render_vb_points,
   tdfx_render_vb_lines,
   tdfx_render_vb_line_loop,
   tdfx_render_vb_line_strip,
   tdfx_render_vb_triangles,
   tdfx_render_vb_tri_strip,
   tdfx_render_vb_tri_fan,
   tdfx_render_vb_quads,
   tdfx_render_vb_quad_strip,
   tdfx_render_vb_poly,
   tdfx_render_vb_noop,
};


/**********************************************************************/
/*            Render whole (indexed) begin/end objects                */
/**********************************************************************/


#define VERT(x) (tdfxVertex *)(vertptr + ((x)<<vertshift))

#define RENDER_POINTS( start, count )		\
   for ( ; start < count ; start++)		\
      fxMesa->Glide.grDrawPoint( VERT(ELT(start)) );

#define RENDER_LINE( v0, v1 ) \
   fxMesa->Glide.grDrawLine( VERT(v0), VERT(v1) )

#define RENDER_TRI( v0, v1, v2 )  \
   fxMesa->Glide.grDrawTriangle( VERT(v0), VERT(v1), VERT(v2) )

#define RENDER_QUAD( v0, v1, v2, v3 ) \
   tdfx_draw_quad( fxMesa, VERT(v0), VERT(v1), VERT(v2), VERT(v3) )

#define INIT(x) tdfxRenderPrimitive( ctx, x )

#undef LOCAL_VARS
#define LOCAL_VARS						\
    tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);			\
    GLubyte *vertptr = (GLubyte *)fxMesa->verts;		\
    const GLuint vertshift = fxMesa->vertex_stride_shift;	\
    const GLuint * const elt = TNL_CONTEXT(ctx)->vb.Elts;	\
    (void) elt;

#define RESET_STIPPLE 
#define RESET_OCCLUSION 
#define PRESERVE_VB_DEFS
d284 5
a288 7
/* Elts, no clipping.
 */
#undef ELT
#undef TAG
#define TAG(x) tdfx_##x##_elts
#define ELT(x) elt[x]
#include "tnl_dd/t_dd_rendertmp.h"
d290 5
d297 6
a302 3
/**********************************************************************/
/*                   Render clipped primitives                        */
/**********************************************************************/
d304 2
d308 1
a308 2
static void tdfxRenderClippedPoly( GLcontext *ctx, const GLuint *elts, 
				   GLuint n )
d310 17
a326 13
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct vertex_buffer *VB = &tnl->vb;
   GLuint prim = fxMesa->render_primitive;

   /* Render the new vertices as an unclipped polygon. 
    */
   {
      GLuint *tmp = VB->Elts;
      VB->Elts = (GLuint *)elts;
      tnl->Driver.Render.PrimTabElts[GL_POLYGON]( ctx, 0, n, PRIM_BEGIN|PRIM_END );
      VB->Elts = tmp;
   }
d328 2
a329 4
   /* Restore the render primitive
    */
   if (prim != GL_POLYGON)
      tnl->Driver.Render.PrimitiveNotify( ctx, prim );
a331 5
static void tdfxRenderClippedLine( GLcontext *ctx, GLuint ii, GLuint jj )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   tnl->Driver.Render.Line( ctx, ii, jj );
}
d333 1
a333 2
static void tdfxFastRenderClippedPoly( GLcontext *ctx, const GLuint *elts, 
				       GLuint n )
d335 8
a342 5
   tdfxContextPtr fxMesa = TDFX_CONTEXT( ctx );
   GLubyte *vertptr = (GLubyte *)fxMesa->verts;			
   const GLuint vertshift = fxMesa->vertex_stride_shift;       	
   const GLuint *start = (const GLuint *)VERT(elts[0]);
   int i;
d344 18
a361 3
   for (i = 2 ; i < n ; i++) {
      fxMesa->Glide.grDrawTriangle( VERT(elts[i-1]), VERT(elts[i]), start );
   }
a363 4
/**********************************************************************/
/*                    Choose render functions                         */
/**********************************************************************/

d365 10
a374 9
#define POINT_FALLBACK (DD_POINT_SMOOTH)
#define LINE_FALLBACK (DD_LINE_STIPPLE)
#define TRI_FALLBACK (DD_TRI_SMOOTH)
#define ANY_FALLBACK_FLAGS (POINT_FALLBACK|LINE_FALLBACK|TRI_FALLBACK|DD_TRI_STIPPLE)
#define ANY_RASTER_FLAGS (DD_FLATSHADE|DD_TRI_LIGHT_TWOSIDE|DD_TRI_OFFSET| \
			  DD_TRI_UNFILLED)


/* All state referenced below:
d376 1
a376 12
#define _TDFX_NEW_RENDERSTATE (_DD_NEW_POINT_SMOOTH |		\
                               _DD_NEW_LINE_STIPPLE |		\
                               _DD_NEW_TRI_SMOOTH |		\
			       _DD_NEW_FLATSHADE |		\
			       _DD_NEW_TRI_UNFILLED |		\
			       _DD_NEW_TRI_LIGHT_TWOSIDE |	\
			       _DD_NEW_TRI_OFFSET |		\
			       _DD_NEW_TRI_STIPPLE |		\
			       _NEW_POLYGONSTIPPLE)


static void tdfxChooseRenderState(GLcontext *ctx)
d378 9
a386 10
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint flags = ctx->_TriangleCaps;
   GLuint index = 0;

   if (0) {
      fxMesa->draw_point = tdfx_draw_point;
      fxMesa->draw_line = tdfx_draw_line;
      fxMesa->draw_triangle = tdfx_draw_triangle;
      index |= TDFX_FALLBACK_BIT;
d389 24
a412 6
   if (flags & (ANY_FALLBACK_FLAGS|ANY_RASTER_FLAGS)) {
      if (flags & ANY_RASTER_FLAGS) {
	 if (flags & DD_TRI_LIGHT_TWOSIDE)    index |= TDFX_TWOSIDE_BIT;
	 if (flags & DD_TRI_OFFSET)	      index |= TDFX_OFFSET_BIT;
	 if (flags & DD_TRI_UNFILLED)	      index |= TDFX_UNFILLED_BIT;
	 if (flags & DD_FLATSHADE)	      index |= TDFX_FLAT_BIT;
d415 6
a420 22
      fxMesa->draw_point = tdfx_draw_point;
      fxMesa->draw_line = tdfx_draw_line;
      fxMesa->draw_triangle = tdfx_draw_triangle;

      /* Hook in fallbacks for specific primitives.
       *
       * DD_TRI_UNFILLED is here because the unfilled_tri functions use
       * fxMesa->draw_tri *always*, and thus can't use the multipass
       * approach to cliprects.
       *
       */
      if (flags & (POINT_FALLBACK|
		   LINE_FALLBACK|
		   TRI_FALLBACK|
		   DD_TRI_STIPPLE|
		   DD_TRI_UNFILLED))
      {
	 if (flags & POINT_FALLBACK)
	    fxMesa->draw_point = tdfx_fallback_point;

	 if (flags & LINE_FALLBACK)
	    fxMesa->draw_line = tdfx_fallback_line;
d422 8
a429 2
	 if (flags & TRI_FALLBACK)
	    fxMesa->draw_triangle = tdfx_fallback_tri;
d431 8
a438 4
	 if ((flags & DD_TRI_STIPPLE) && !fxMesa->haveHwStipple)
	    fxMesa->draw_triangle = tdfx_fallback_tri;

	 index |= TDFX_FALLBACK_BIT;
a439 1
   }
d441 9
a449 18
   if (fxMesa->RenderIndex != index) {
      fxMesa->RenderIndex = index;

      tnl->Driver.Render.Points = rast_tab[index].points;
      tnl->Driver.Render.Line = rast_tab[index].line;
      tnl->Driver.Render.Triangle = rast_tab[index].triangle;
      tnl->Driver.Render.Quad = rast_tab[index].quad;

      if (index == 0) {
	 tnl->Driver.Render.PrimTabVerts = tdfx_render_tab_verts;
	 tnl->Driver.Render.PrimTabElts = tdfx_render_tab_elts;
	 tnl->Driver.Render.ClippedLine = line; /* from tritmp.h */
	 tnl->Driver.Render.ClippedPolygon = tdfxFastRenderClippedPoly;
      } else {
	 tnl->Driver.Render.PrimTabVerts = _tnl_render_tab_verts;
	 tnl->Driver.Render.PrimTabElts = _tnl_render_tab_elts;
	 tnl->Driver.Render.ClippedLine = tdfxRenderClippedLine;
	 tnl->Driver.Render.ClippedPolygon = tdfxRenderClippedPoly;
a450 6
   }
}

/**********************************************************************/
/*                Use multipass rendering for cliprects               */
/**********************************************************************/
d452 2
d455 1
a455 17

/* TODO: Benchmark this.
 * TODO: Use single back-buffer cliprect where possible.  
 * NOTE: <pass> starts at 1, not zero!
 */
static GLboolean multipass_cliprect( GLcontext *ctx, GLuint pass )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   if (pass >= fxMesa->numClipRects)
      return GL_FALSE;
   else {   
      fxMesa->Glide.grClipWindow(fxMesa->pClipRects[pass].x1,
		   fxMesa->screen_height - fxMesa->pClipRects[pass].y2,
		   fxMesa->pClipRects[pass].x2,
		   fxMesa->screen_height - fxMesa->pClipRects[pass].y1);
      
      return GL_TRUE;
a456 10
}


/**********************************************************************/
/*                Runtime render state and callbacks                  */
/**********************************************************************/

static void tdfxRunPipeline( GLcontext *ctx )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
a457 3
   if (fxMesa->new_state) {
      tdfxDDUpdateHwState( ctx );
   }
d459 3
a461 8
   if (!fxMesa->Fallback && fxMesa->new_gl_state) {
      if (fxMesa->new_gl_state & _TDFX_NEW_RASTERSETUP)
	 tdfxChooseVertexState( ctx );
      
      if (fxMesa->new_gl_state & _TDFX_NEW_RENDERSTATE)
	 tdfxChooseRenderState( ctx );
      
      fxMesa->new_gl_state = 0;
a462 2

   _tnl_run_pipeline( ctx );
d466 1
a466 50
static void tdfxRenderStart( GLcontext *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);

   tdfxCheckTexSizes( ctx );

   LOCK_HARDWARE(fxMesa);

   /* Make sure vertex format changes get uploaded before we start
    * sending triangles.  
    */
   if (fxMesa->dirty) {
      tdfxEmitHwStateLocked( fxMesa );
   }

   if (fxMesa->numClipRects && !(fxMesa->RenderIndex & TDFX_FALLBACK_BIT)) {
      fxMesa->Glide.grClipWindow(fxMesa->pClipRects[0].x1,
		   fxMesa->screen_height - fxMesa->pClipRects[0].y2,
		   fxMesa->pClipRects[0].x2,
		   fxMesa->screen_height - fxMesa->pClipRects[0].y1);
      if (fxMesa->numClipRects > 1)
         tnl->Driver.Render.Multipass = multipass_cliprect;
      else
         tnl->Driver.Render.Multipass = NULL;
   }
   else
      tnl->Driver.Render.Multipass = NULL;
}


static GLenum reduced_prim[GL_POLYGON+1] = {
   GL_POINTS,
   GL_LINES,
   GL_LINES,
   GL_LINES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES
};



/* Always called between RenderStart and RenderFinish --> We already
 * hold the lock.
 */
static void tdfxRasterPrimitive( GLcontext *ctx, GLenum prim )
d469 2
d472 1
a472 36
   FLUSH_BATCH( fxMesa );

   fxMesa->raster_primitive = prim;

   tdfxUpdateCull(ctx);
   if ( fxMesa->dirty & TDFX_UPLOAD_CULL ) {
      fxMesa->Glide.grCullMode( fxMesa->CullMode );
      fxMesa->dirty &= ~TDFX_UPLOAD_CULL;
   }

   tdfxUpdateStipple(ctx);
   if ( fxMesa->dirty & TDFX_UPLOAD_STIPPLE ) {
      fxMesa->Glide.grStipplePattern ( fxMesa->Stipple.Pattern );
      fxMesa->Glide.grStippleMode ( fxMesa->Stipple.Mode );
      fxMesa->dirty &= ~TDFX_UPLOAD_STIPPLE;
   }
}



/* Determine the rasterized primitive when not drawing unfilled 
 * polygons.
 *
 * Used only for the default render stage which always decomposes
 * primitives to trianges/lines/points.  For the accelerated stage,
 * which renders strips as strips, the equivalent calculations are
 * performed in tdfx_render.c.
 */
static void tdfxRenderPrimitive( GLcontext *ctx, GLenum prim )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint rprim = reduced_prim[prim];

   fxMesa->render_primitive = prim;

   if (rprim == GL_TRIANGLES && (ctx->_TriangleCaps & DD_TRI_UNFILLED))
a473 15
       
   if (fxMesa->raster_primitive != rprim) {
      tdfxRasterPrimitive( ctx, rprim );
   }
}

static void tdfxRenderFinish( GLcontext *ctx )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);

   if (fxMesa->RenderIndex & TDFX_FALLBACK_BIT)
      _swrast_flush( ctx );

   UNLOCK_HARDWARE(fxMesa);
}
d475 4
d480 2
a481 17
/**********************************************************************/
/*               Manage total rasterization fallbacks                 */
/**********************************************************************/

static char *fallbackStrings[] = {
   "1D/3D Texture map",
   "glDrawBuffer(GL_FRONT_AND_BACK)",
   "Separate specular color",
   "glEnable/Disable(GL_STENCIL_TEST)",
   "glRenderMode(selection or feedback)",
   "glLogicOp()",
   "Texture env mode",
   "Texture border",
   "glColorMask",
   "blend mode",
   "line stipple"
};
d483 2
d486 2
a487 9
static char *getFallbackString(GLuint bit)
{
   int i = 0;
   while (bit > 1) {
      i++;
      bit >>= 1;
   }
   return fallbackStrings[i];
}
d489 2
d492 2
a493 37
void tdfxFallback( GLcontext *ctx, GLuint bit, GLboolean mode )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   GLuint oldfallback = fxMesa->Fallback;

   if (mode) {
      fxMesa->Fallback |= bit;
      if (oldfallback == 0) {
         /*printf("Go to software rendering, bit = 0x%x\n", bit);*/
	 FLUSH_BATCH(fxMesa);
	 _swsetup_Wakeup( ctx );
	 fxMesa->RenderIndex = ~0;
         if (fxMesa->debugFallbacks) {
            fprintf(stderr, "Tdfx begin software fallback: 0x%x %s\n",
                    bit, getFallbackString(bit));
         }
      }
   }
   else {
      fxMesa->Fallback &= ~bit;
      if (oldfallback == bit) {
         /*printf("Go to hardware rendering, bit = 0x%x\n", bit);*/
	 _swrast_flush( ctx );
	 tnl->Driver.Render.Start = tdfxRenderStart;
	 tnl->Driver.Render.PrimitiveNotify = tdfxRenderPrimitive;
	 tnl->Driver.Render.Finish = tdfxRenderFinish;
	 tnl->Driver.Render.BuildVertices = tdfxBuildVertices;
	 fxMesa->new_gl_state |= (_TDFX_NEW_RENDERSTATE|
				  _TDFX_NEW_RASTERSETUP);
         if (fxMesa->debugFallbacks) {
            fprintf(stderr, "Tdfx end software fallback: 0x%x %s\n",
                    bit, getFallbackString(bit));
         }
      }
   }
}
d495 2
d498 2
a499 5
void tdfxDDInitTriFuncs( GLcontext *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   static int firsttime = 1;
d501 5
a505 4
   if (firsttime) {
      init_rast_tab();
      firsttime = 0;
   }
d507 5
a511 9
   fxMesa->RenderIndex = ~0;
	
   tnl->Driver.RunPipeline              = tdfxRunPipeline;
   tnl->Driver.Render.Start             = tdfxRenderStart;
   tnl->Driver.Render.Finish            = tdfxRenderFinish; 
   tnl->Driver.Render.PrimitiveNotify   = tdfxRenderPrimitive;
   tnl->Driver.Render.ResetLineStipple  = _swrast_ResetLineStipple;
   tnl->Driver.Render.BuildVertices     = tdfxBuildVertices;
   tnl->Driver.Render.Multipass		= NULL;
d513 2
a514 1
   (void) tdfx_print_vertex;
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d26 1
a26 1
/* $XFree86: xc/lib/GL/mesa/src/drv/tdfx/tdfx_tris.c,v 1.6 2004/01/23 03:57:07 dawes Exp $ */
d32 3
d222 1
a222 1
   fprintf(stderr, "vertex at %p\n", (void *)v);
d568 1
a568 1
   GLubyte *fxVB = fxMesa->verts + (start << shift);
d570 1
a570 1
   GLubyte *tmp;
d596 1
a596 1
   GLubyte *fxVB = fxMesa->verts + (start << shift);
d598 1
a598 1
   GLubyte *tmp;
d625 1
a625 1
   GLubyte *fxVB = fxMesa->verts + (start << shift);
d627 1
a627 1
   GLubyte *tmp, *tmp2 = fxVB;
d664 1
a664 1
   GLubyte *fxVB = fxMesa->verts + (start << shift);
d666 1
a666 1
   GLubyte *tmp;
d693 1
a693 1
   GLubyte *fxVB = fxMesa->verts + (start << shift);
d708 1
a708 1
   GLubyte *fxVB = fxMesa->verts + (start << shift);
d732 1
a732 1
   GLubyte *fxVB = fxMesa->verts + (start << shift);
d746 1
a746 1
   GLubyte *fxVB = fxMesa->verts;
d765 1
a765 1
   GLubyte *fxVB = fxMesa->verts + (start << shift);
d781 1
a781 1
   GLubyte *fxVB = fxMesa->verts + (start << shift);
@


