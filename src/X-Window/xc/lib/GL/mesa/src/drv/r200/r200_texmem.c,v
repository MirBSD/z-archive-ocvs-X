head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.2
	cvs-200410241530:1.1.1.2
	cvs-200410012000:1.1.1.2
	cvs-200407141120:1.1.1.2
	cvs-200406231010:1.1.1.2
	MIRBSD_7quater:1.1.1.1
	cvs-200405271510:1.1.1.2
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.2
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.4
	MIRBSD_7:1.1.1.1.0.2
	MIRBSD_7ter:1.1.1.1
	cvs-20011091815:1.1.1.1
	cvs-200309162130:1.1.1.1
	cvs-200308302005:1.1.1.1
	ctmx-0387:1.1.1.1
	ctmx-0384:1.1.1.1
	MIRBSD_5:1.1.1.1
	ctmx-0375:1.1.1.1
	ctmx-0373:1.1.1.1
	ctm-0371:1.1.1.1
	ctm-0370:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-0363:1.1.1.1
	ctm-0359:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.04.08.18.31.32;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.04.08.18.31.32;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.03.02.17.59.07;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.18.06;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $XFree86: xc/lib/GL/mesa/src/drv/r200/r200_texmem.c,v 1.5 2002/12/17 00:32:56 dawes Exp $ */
/**************************************************************************

Copyright (C) Tungsten Graphics 2002.  All Rights Reserved.  
The Weather Channel, Inc. funded Tungsten Graphics to develop the
initial release of the Radeon 8500 driver under the XFree86
license. This notice must be preserved.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation on the rights to use, copy, modify, merge, publish,
distribute, sub license, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial
portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NON-INFRINGEMENT. IN NO EVENT SHALL ATI, VA LINUX SYSTEMS AND/OR THEIR
SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Kevin E. Martin <martin@@valinux.com>
 *   Gareth Hughes <gareth@@valinux.com>
 *
 */

#include "radeon_reg.h"
#include "r200_context.h"
#include "r200_state.h"
#include "r200_ioctl.h"
#include "r200_swtcl.h"
#include "r200_tex.h"

#include "context.h"
#include "colormac.h"
#include "mmath.h"
#include "macros.h"
#include "simple_list.h"
#include "enums.h"
#include "mem.h"

#include <unistd.h>	/* for usleep */

/* Destroy hardware state associated with texture `t'.
 */
void r200DestroyTexObj( r200ContextPtr rmesa, r200TexObjPtr t )
{
   if ( !t )
      return;

   if ( R200_DEBUG & DEBUG_TEXTURE ) {
      fprintf( stderr, "%s( %p, %p )\n", __FUNCTION__, t, t->tObj );
   }

   if ( t->memBlock ) {
      mmFreeMem( t->memBlock );
      t->memBlock = NULL;
   }

   if ( t->tObj )
      t->tObj->DriverData = NULL;

   if ( rmesa ) {
      if ( t == rmesa->state.texture.unit[0].texobj ) {
         rmesa->state.texture.unit[0].texobj = NULL;
	 remove_from_list( &rmesa->hw.tex[0] );
	 make_empty_list( &rmesa->hw.tex[0] );
      }

      if ( t == rmesa->state.texture.unit[1].texobj ) {
         rmesa->state.texture.unit[1].texobj = NULL;
	 remove_from_list( &rmesa->hw.tex[1] );
	 make_empty_list( &rmesa->hw.tex[1] );
      }
   }

   remove_from_list( t );
   FREE( t );
}


/* Keep track of swapped out texture objects.
 */
void r200SwapOutTexObj( r200ContextPtr rmesa, r200TexObjPtr t )
{
   if ( R200_DEBUG & DEBUG_TEXTURE ) {
      fprintf( stderr, "%s( %p, %p )\n", __FUNCTION__, t, t->tObj );
   }

   if ( t->memBlock ) {
      mmFreeMem( t->memBlock );
      t->memBlock = NULL;
   }

   t->dirty_images = ~0;
   move_to_tail( &rmesa->texture.swapped, t );
}

/* Print out debugging information about texture LRU.
 */
void r200PrintLocalLRU( r200ContextPtr rmesa, int heap )
{
   r200TexObjPtr t;
   int sz = 1 << (rmesa->r200Screen->logTexGranularity[heap]);

   fprintf( stderr, "\nLocal LRU, heap %d:\n", heap );

   foreach ( t, &rmesa->texture.objects[heap] ) {
      if (!t->memBlock)
	 continue;
      if (!t->tObj) {
	 fprintf( stderr, "Placeholder %d at 0x%x sz 0x%x\n",
		  t->memBlock->ofs / sz,
		  t->memBlock->ofs,
		  t->memBlock->size );
      } else {
	 fprintf( stderr, "Texture at 0x%x sz 0x%x\n",
		  t->memBlock->ofs,
		  t->memBlock->size );
      }
   }

   fprintf( stderr, "\n" );
}

void r200PrintGlobalLRU( r200ContextPtr rmesa, int heap )
{
   radeon_tex_region_t *list = rmesa->sarea->texList[heap];
   int i, j;

   fprintf( stderr, "\nGlobal LRU, heap %d list %p:\n", heap, list );

   for ( i = 0, j = RADEON_NR_TEX_REGIONS ; i < RADEON_NR_TEX_REGIONS ; i++ ) {
      fprintf( stderr, "list[%d] age %d next %d prev %d\n",
	       j, list[j].age, list[j].next, list[j].prev );
      j = list[j].next;
      if ( j == RADEON_NR_TEX_REGIONS ) break;
   }

   if ( j != RADEON_NR_TEX_REGIONS ) {
      fprintf( stderr, "Loop detected in global LRU\n" );
      for ( i = 0 ; i < RADEON_NR_TEX_REGIONS ; i++ ) {
	 fprintf( stderr, "list[%d] age %d next %d prev %d\n",
		  i, list[i].age, list[i].next, list[i].prev );
      }
   }

   fprintf( stderr, "\n" );
}

/* Reset the global texture LRU.
 */
static void r200ResetGlobalLRU( r200ContextPtr rmesa, int heap )
{
   radeon_tex_region_t *list = rmesa->sarea->texList[heap];
   int sz = 1 << rmesa->r200Screen->logTexGranularity[heap];
   int i;

   /*
    * (Re)initialize the global circular LRU list.  The last element in
    * the array (RADEON_NR_TEX_REGIONS) is the sentinal.  Keeping it at
    * the end of the array allows it to be addressed rationally when
    * looking up objects at a particular location in texture memory.
    */
   for ( i = 0 ; (i+1) * sz <= rmesa->r200Screen->texSize[heap] ; i++ ) {
      list[i].prev = i-1;
      list[i].next = i+1;
      list[i].age = 0;
   }

   i--;
   list[0].prev = RADEON_NR_TEX_REGIONS;
   list[i].prev = i-1;
   list[i].next = RADEON_NR_TEX_REGIONS;
   list[RADEON_NR_TEX_REGIONS].prev = i;
   list[RADEON_NR_TEX_REGIONS].next = 0;
   rmesa->sarea->texAge[heap] = 0;
}

/* Update the local and glock texture LRUs.
 */
void r200UpdateTexLRU(r200ContextPtr rmesa, r200TexObjPtr t )
{
   int heap = t->heap;
   radeon_tex_region_t *list = rmesa->sarea->texList[heap];
   int sz = rmesa->r200Screen->logTexGranularity[heap];
   int i, start, end;

   rmesa->texture.age[heap] = ++rmesa->sarea->texAge[heap];

   if ( !t->memBlock ) 
      return;

   start = t->memBlock->ofs >> sz;
   end = (t->memBlock->ofs + t->memBlock->size-1) >> sz;

   /* Update our local LRU */
   move_to_head( &rmesa->texture.objects[heap], t );

   /* Update the global LRU */
   for ( i = start ; i <= end ; i++ ) {
      list[i].in_use = 1;
      list[i].age = rmesa->texture.age[heap];

      /* remove_from_list(i) */
      list[(CARD32)list[i].next].prev = list[i].prev;
      list[(CARD32)list[i].prev].next = list[i].next;

      /* insert_at_head(list, i) */
      list[i].prev = RADEON_NR_TEX_REGIONS;
      list[i].next = list[RADEON_NR_TEX_REGIONS].next;
      list[(CARD32)list[RADEON_NR_TEX_REGIONS].next].prev = i;
      list[RADEON_NR_TEX_REGIONS].next = i;
   }

   if ( 0 ) {
      r200PrintGlobalLRU( rmesa, t->heap );
      r200PrintLocalLRU( rmesa, t->heap );
   }
}

/* Update our notion of what textures have been changed since we last
 * held the lock.  This pertains to both our local textures and the
 * textures belonging to other clients.  Keep track of other client's
 * textures by pushing a placeholder texture onto the LRU list -- these
 * are denoted by (tObj == NULL).
 */
static void r200TexturesGone( r200ContextPtr rmesa, int heap,
				int offset, int size, int in_use )
{
   r200TexObjPtr t, tmp;

   foreach_s ( t, tmp, &rmesa->texture.objects[heap] ) {
      if ( !t->memBlock ||
	   t->memBlock->ofs >= offset + size ||
	   t->memBlock->ofs + t->memBlock->size <= offset )
	 continue;

      /* It overlaps - kick it out.  Need to hold onto the currently
       * bound objects, however.
       */
      r200SwapOutTexObj( rmesa, t );
   }

   if ( in_use ) {
      t = (r200TexObjPtr) CALLOC( sizeof(*t) );
      if ( !t ) return;

      t->memBlock = mmAllocMem( rmesa->texture.heap[heap], size, 0, offset );
      if ( !t->memBlock ) {
	 fprintf( stderr, "Couldn't alloc placeholder sz %x ofs %x\n",
		  (int)size, (int)offset );
	 mmDumpMemInfo( rmesa->texture.heap[heap] );
	 return;
      }
      insert_at_head( &rmesa->texture.objects[heap], t );
   }
}

/* Update our client's shared texture state.  If another client has
 * modified a region in which we have textures, then we need to figure
 * out which of our textures has been removed, and update our global
 * LRU.
 */
void r200AgeTextures( r200ContextPtr rmesa, int heap )
{
   RADEONSAREAPrivPtr sarea = rmesa->sarea;

   if ( sarea->texAge[heap] != rmesa->texture.age[heap] ) {
      int sz = 1 << rmesa->r200Screen->logTexGranularity[heap];
      int nr = 0;
      int idx;

      for ( idx = sarea->texList[heap][RADEON_NR_TEX_REGIONS].prev ;
	    idx != RADEON_NR_TEX_REGIONS && nr < RADEON_NR_TEX_REGIONS ;
	    idx = sarea->texList[heap][idx].prev, nr++ )
      {
	 /* If switching texturing schemes, then the SAREA might not
	  * have been properly cleared, so we need to reset the
	  * global texture LRU.
	  */
	 if ( idx * sz > rmesa->r200Screen->texSize[heap] ) {
	    nr = RADEON_NR_TEX_REGIONS;
	    break;
	 }

	 if ( sarea->texList[heap][idx].age > rmesa->texture.age[heap] ) {
	    r200TexturesGone( rmesa, heap, idx * sz, sz,
				sarea->texList[heap][idx].in_use );
	 }
      }

      if ( nr == RADEON_NR_TEX_REGIONS ) {
	 r200TexturesGone( rmesa, heap, 0,
			     rmesa->r200Screen->texSize[heap], 0 );
	 r200ResetGlobalLRU( rmesa, heap );
      }

      rmesa->texture.age[heap] = sarea->texAge[heap];
   }
}


/* ------------------------------------------------------------
 * Texture image conversions
 */


static void r200UploadAGPClientSubImage( r200ContextPtr rmesa,
					 r200TexObjPtr t, 
					 struct gl_texture_image *texImage,
					 GLint hwlevel,
					 GLint x, GLint y, 
					 GLint width, GLint height )
{
   const struct gl_texture_format *texFormat = texImage->TexFormat;
   GLuint pitch = t->image[0].width * texFormat->TexelBytes;
   int blit_format;
   int srcOffset;


   switch ( texFormat->TexelBytes ) {
   case 1:
      blit_format = R200_CP_COLOR_FORMAT_CI8;
      break;
   case 2:
      blit_format = R200_CP_COLOR_FORMAT_RGB565;
      break;
   case 4:
      blit_format = R200_CP_COLOR_FORMAT_ARGB8888;
      break;
   default:
      return;
   }

   t->image[hwlevel].data = texImage->Data;
   srcOffset = r200AgpOffsetFromVirtual( rmesa, texImage->Data );

   assert( srcOffset != ~0 );

   /* Don't currently need to cope with small pitches?
    */
   width = texImage->Width;
   height = texImage->Height;

   r200EmitWait( rmesa, RADEON_WAIT_3D );

   r200EmitBlit( rmesa, blit_format, 
		 pitch,  
		 srcOffset,   
		 t->image[0].width * texFormat->TexelBytes, /* dst pitch! */
		 t->bufAddr,
		 x, 
		 y, 
		 t->image[hwlevel].x + x,
		 t->image[hwlevel].y + y, 
		 width,
		 height );

   r200EmitWait( rmesa, RADEON_WAIT_2D );
}

static void r200UploadRectSubImage( r200ContextPtr rmesa,
				    r200TexObjPtr t, 
				    struct gl_texture_image *texImage,
				    GLint x, GLint y, 
				    GLint width, GLint height )
{
   const struct gl_texture_format *texFormat = texImage->TexFormat;
   int blit_format, blit_pitch, done;

   switch ( texFormat->TexelBytes ) {
   case 1:
      blit_format = R200_CP_COLOR_FORMAT_CI8;
      break;
   case 2:
      blit_format = R200_CP_COLOR_FORMAT_RGB565;
      break;
   case 4:
      blit_format = R200_CP_COLOR_FORMAT_ARGB8888;
      break;
   default:
      return;
   }

   t->image[0].data = texImage->Data;

   /* Currently don't need to cope with small pitches.
    */
   width = texImage->Width;
   height = texImage->Height;
   blit_pitch = t->pp_txpitch + 32;

   if (rmesa->prefer_agp_client_texturing && texImage->IsClientData) {
      /* In this case, could also use agp texturing.  This is
       * currently disabled, but has been tested & works.
       */
      t->pp_txoffset = r200AgpOffsetFromVirtual( rmesa, texImage->Data );
      t->pp_txpitch = texImage->RowStride * texFormat->TexelBytes - 32;

      if (R200_DEBUG & DEBUG_TEXTURE)
	 fprintf(stderr, 
		 "Using agp texturing for rectangular client texture\n");

      /* Release FB memory allocated for this image:
       */
      if ( t->memBlock ) {
	 mmFreeMem( t->memBlock );
	 t->memBlock = NULL;
      }

   }
   else if (texImage->IsClientData) {
      /* Data already in agp memory, with usable pitch.
       */
      r200EmitBlit( rmesa, 
		    blit_format, 
		    texImage->RowStride * texFormat->TexelBytes, 
		    r200AgpOffsetFromVirtual( rmesa, texImage->Data ),   
		    blit_pitch, t->bufAddr,
		    0, 0, 
		    0, 0, 
		    width, height );
   }
   else {
      /* Data not in agp memory, or bad pitch.
       */
      for (done = 0; done < height ; ) {
	 struct r200_dma_region region;
	 int lines = MIN2( height - done, RADEON_BUFFER_SIZE / blit_pitch );
	 int src_pitch = texImage->RowStride * texFormat->TexelBytes;
	 char *tex = (char *)texImage->Data + done * src_pitch;

	 memset(&region, 0, sizeof(region));
	 r200AllocDmaRegion( rmesa, &region, lines * blit_pitch, 64 );

	 /* Copy texdata to dma:
	  */
	 if (0)
	    fprintf(stderr, "%s: src_pitch %d blit_pitch %d\n",
		    __FUNCTION__, src_pitch, blit_pitch);

	 if (src_pitch == blit_pitch) {
	    memcpy( region.address, tex, lines * src_pitch );
	 } 
	 else {
	    char *buf = region.address;
	    int i;
	    for (i = 0 ; i < lines ; i++) {
	       memcpy( buf, tex, src_pitch );
	       buf += blit_pitch;
	       tex += src_pitch;
	    }
	 }

	 r200EmitWait( rmesa, RADEON_WAIT_3D );

	 /* Blit to framebuffer
	  */
	 r200EmitBlit( rmesa, 
		       blit_format, 
		       blit_pitch, GET_START( &region ),   
		       blit_pitch, t->bufAddr,
		       0, 0, 
		       0, done, 
		       width, lines );
	 
	 r200EmitWait( rmesa, RADEON_WAIT_2D );

	 r200ReleaseDmaRegion( rmesa, &region, __FUNCTION__ );
	 done += lines;
      }
   }
}


/* Upload the texture image associated with texture `t' at level `level'
 * at the address relative to `start'.
 */
static void r200UploadSubImage( r200ContextPtr rmesa,
				r200TexObjPtr t, 
				GLint hwlevel,
				GLint x, GLint y, GLint width, GLint height )
{
   struct gl_texture_image *texImage;
   const struct gl_texture_format *texFormat;
   GLint texelsPerDword = 0;
   GLuint format, pitch, offset;
   GLint imageWidth, imageHeight;
   GLint ret;
   drmRadeonTexture tex;
   drmRadeonTexImage tmp;
   int level = hwlevel + t->firstLevel;

   if ( R200_DEBUG & DEBUG_TEXTURE ) {
      fprintf( stderr, "%s level %d %dx%d\n", __FUNCTION__,
	       level, width, height);
   }

   /* Ensure we have a valid texture to upload */
   if ( ( hwlevel < 0 ) || ( hwlevel >= RADEON_MAX_TEXTURE_LEVELS ) ) {
      _mesa_problem(NULL, "bad texture level in r200UploadSubimage");
      return;
   }

   texImage = t->tObj->Image[level];
   if ( !texImage ) {
      if ( R200_DEBUG & DEBUG_TEXTURE )
	 fprintf( stderr, "%s: texImage %d is NULL!\n", __FUNCTION__, level );
      return;
   }
   if ( !texImage->Data ) {
      if ( R200_DEBUG & DEBUG_TEXTURE )
	 fprintf( stderr, "%s: image data is NULL!\n", __FUNCTION__ );
      return;
   }


   if (t->tObj->Target == GL_TEXTURE_RECTANGLE_NV) {
      assert(level == 0);
      assert(hwlevel == 0);
      if ( R200_DEBUG & DEBUG_TEXTURE )
	 fprintf( stderr, "%s: image data is rectangular\n", __FUNCTION__);
      r200UploadRectSubImage( rmesa, t, texImage, x, y, width, height );
      return;
   }
   else if (texImage->IsClientData) {
      if ( R200_DEBUG & DEBUG_TEXTURE )
	 fprintf( stderr, "%s: image data is in agp client storage\n",
		  __FUNCTION__);
      r200UploadAGPClientSubImage( rmesa, t, texImage, hwlevel,
				   x, y, width, height );
      return;
   }
   else if ( R200_DEBUG & DEBUG_TEXTURE )
      fprintf( stderr, "%s: image data is in normal memory\n",
	       __FUNCTION__);
      

   texFormat = texImage->TexFormat;

   switch ( texFormat->TexelBytes ) {
   case 1:
      texelsPerDword = 4;
      break;
   case 2:
      texelsPerDword = 2;
      break;
   case 4:
      texelsPerDword = 1;
      break;
   }

   format = t->pp_txformat & R200_TXFORMAT_FORMAT_MASK;

   imageWidth = texImage->Width;
   imageHeight = texImage->Height;

   offset = t->bufAddr;
   pitch = (t->image[0].width * texFormat->TexelBytes) / 64;


   if ( R200_DEBUG & (DEBUG_TEXTURE|DEBUG_IOCTL) )
   {
      GLint imageX = 0;
      GLint imageY = 0;
      GLint blitX = t->image[hwlevel].x;
      GLint blitY = t->image[hwlevel].y;
      GLint blitWidth = t->image[hwlevel].width;
      GLint blitHeight = t->image[hwlevel].height;
      fprintf( stderr, "   upload image: %d,%d at %d,%d\n",
	       imageWidth, imageHeight, imageX, imageY );
      fprintf( stderr, "   upload  blit: %d,%d at %d,%d\n",
	       blitWidth, blitHeight, blitX, blitY );
      fprintf( stderr, "       blit ofs: 0x%07x pitch: 0x%x "
	       "level: %d/%d format: %x\n",
	       (GLuint)offset, (GLuint)pitch, hwlevel, level, format );
   }

   t->image[hwlevel].data = texImage->Data;

   tex.offset = offset;
   tex.pitch = pitch;
   tex.format = format;
   tex.width = imageWidth;
   tex.height = imageHeight;
   tex.image = &tmp;

   memcpy( &tmp, &t->image[hwlevel], sizeof(drmRadeonTexImage) );

   LOCK_HARDWARE( rmesa );
   do {
      ret = drmCommandWriteRead( rmesa->dri.fd, DRM_RADEON_TEXTURE,
                                 &tex, sizeof(drmRadeonTexture) );
      if (ret) {
	 if (R200_DEBUG & DEBUG_IOCTL)
	    fprintf(stderr, "DRM_RADEON_TEXTURE:  again!\n");
	 usleep(1);
      }
   } while ( ret && errno == EAGAIN );

   UNLOCK_HARDWARE( rmesa );

   if ( ret ) {
      fprintf( stderr, "DRM_R200_TEXTURE: return = %d\n", ret );
      fprintf( stderr, "   offset=0x%08x pitch=0x%x format=%d\n",
	       offset, pitch, format );
      fprintf( stderr, "   image width=%d height=%d\n",
	       imageWidth, imageHeight );
      fprintf( stderr, "    blit width=%d height=%d data=%p\n",
	       t->image[hwlevel].width, t->image[hwlevel].height,
	       t->image[hwlevel].data );
      exit( 1 );
   }
}



/* Upload the texture images associated with texture `t'.  This might
 * require removing our own and/or other client's texture objects to
 * make room for these images.
 */
int r200UploadTexImages( r200ContextPtr rmesa, r200TexObjPtr t )
{
   const int numLevels = t->lastLevel - t->firstLevel + 1;
   int heap;
   r200TexObjPtr t0 = rmesa->state.texture.unit[0].texobj;
   r200TexObjPtr t1 = rmesa->state.texture.unit[1].texobj;

   if ( R200_DEBUG & (DEBUG_TEXTURE|DEBUG_IOCTL) ) {
      fprintf( stderr, "%s( %p, %p ) sz=%d lvls=%d-%d\n", __FUNCTION__,
	       rmesa->glCtx, t->tObj, t->totalSize,
	       t->firstLevel, t->lastLevel );
   }

   if ( !t || t->totalSize == 0 )
      return 0;

   if (R200_DEBUG & DEBUG_SYNC) {
      fprintf(stderr, "\nSyncing\n\n");
      R200_FIREVERTICES( rmesa );
      r200Finish( rmesa->glCtx );
   }

   LOCK_HARDWARE( rmesa );

   /* Choose the heap appropriately */
   heap = t->heap = RADEON_CARD_HEAP;

   /* Do we need to eject LRU texture objects? */
   if ( !t->memBlock ) {
      /* Allocate a memory block on a 1k boundary (1<<10 == 1024) */
      t->memBlock = mmAllocMem( rmesa->texture.heap[heap],
				t->totalSize, 10, 0 );


      /* Kick out textures until the requested texture fits */
      while ( !t->memBlock ) {
	 if ( rmesa->texture.objects[heap].prev == t0 ||
	      rmesa->texture.objects[heap].prev == t1 ) {
	    fprintf( stderr,
		     "r200UploadTexImages: ran into bound texture\n" );
	    UNLOCK_HARDWARE( rmesa );
	    return -1;
	 }
	 if ( rmesa->texture.objects[heap].prev ==
	      &rmesa->texture.objects[heap] ) {
	    if ( rmesa->r200Screen->IsPCI ) {
	       fprintf( stderr, "r200UploadTexImages: upload texture "
			"failure on local texture heaps, sz=%d\n",
			t->totalSize );
	       UNLOCK_HARDWARE( rmesa );
	       return -1;
	    } else {
	       fprintf( stderr, "r200UploadTexImages: upload texture "
			"failure on both local and AGP texture heaps, "
			"sz=%d\n",
			t->totalSize );
	       UNLOCK_HARDWARE( rmesa );
	       return -1;
	    }
	 }

	 r200SwapOutTexObj( rmesa, rmesa->texture.objects[heap].prev );

	 t->memBlock = mmAllocMem( rmesa->texture.heap[heap],
				   t->totalSize, 12, 0 );
      }

      /* Set the base offset of the texture image */
      t->bufAddr = rmesa->r200Screen->texOffset[heap] + t->memBlock->ofs;
      t->pp_txoffset = t->bufAddr;

      /* Mark this texobj as dirty on all units:
       */
      t->dirty_state = TEX_ALL;
   }

   /* Let the world know we've used this memory recently */
   r200UpdateTexLRU( rmesa, t );
   UNLOCK_HARDWARE( rmesa );

   /* Upload any images that are new */
   if (t->dirty_images) {
      int hwlevel;
      for ( hwlevel = 0 ; hwlevel < numLevels ; hwlevel++ ) {
         if ( t->dirty_images & (1 << (hwlevel+t->firstLevel)) ) {
            r200UploadSubImage( rmesa, t, hwlevel, 
				0, 0,
				t->image[hwlevel].width, 
				t->image[hwlevel].height );
         }
      }
      t->dirty_images = 0;
   }



   if (R200_DEBUG & DEBUG_SYNC) {
      fprintf(stderr, "\nSyncing\n\n");
      r200Finish( rmesa->glCtx );
   }

   return 0;
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/lib/GL/mesa/src/drv/r200/r200_texmem.c,v 1.7 2004/01/23 03:57:05 dawes Exp $ */
d39 1
a39 7
#include "glheader.h"
#include "imports.h"
#include "context.h"
#include "colormac.h"
#include "macros.h"
#include "simple_list.h"
#include "radeon_reg.h" /* gets definition for usleep */
d46 7
a52 1
#include <unistd.h>  /* for usleep() */
d54 1
d56 1
a56 3
/**
 * Destroy any device-dependent state associated with the texture.  This may
 * include NULLing out hardware state that points to the texture.
d58 1
a58 2
void
r200DestroyTexObj( r200ContextPtr rmesa, r200TexObjPtr t )
d60 3
d64 167
a230 1
      fprintf( stderr, "%s( %p, %p )\n", __FUNCTION__, (void *)t, (void *)t->base.tObj );
d232 1
d234 10
a243 2
   if ( rmesa != NULL ) {
      unsigned   i;
d245 5
d251 51
a301 7
      for ( i = 0 ; i < rmesa->glCtx->Const.MaxTextureUnits ; i++ ) {
	 if ( t == rmesa->state.texture.unit[i].texobj ) {
	    rmesa->state.texture.unit[i].texobj = NULL;
	    remove_from_list( &rmesa->hw.tex[i] );
	    make_empty_list( &rmesa->hw.tex[i] );
	    remove_from_list( &rmesa->hw.cube[i] );
	    make_empty_list( &rmesa->hw.cube[i] );
d304 8
d321 6
a326 6
static void r200UploadGARTClientSubImage( r200ContextPtr rmesa,
					  r200TexObjPtr t, 
					  struct gl_texture_image *texImage,
					  GLint hwlevel,
					  GLint x, GLint y, 
					  GLint width, GLint height )
d329 1
a329 1
   GLuint srcPitch, dstPitch;
d333 1
a333 5
   /*
    * XXX it appears that we always upload the full image, not a subimage.
    * I.e. x==0, y==0, width=texWidth, height=texWidth.  If this is ever
    * changed, the src pitch will have to change.
    */
a336 2
      srcPitch = t->image[0][0].width * texFormat->TexelBytes;
      dstPitch = t->image[0][0].width * texFormat->TexelBytes;
a339 2
      srcPitch = t->image[0][0].width * texFormat->TexelBytes;
      dstPitch = t->image[0][0].width * texFormat->TexelBytes;
a342 2
      srcPitch = t->image[0][0].width * texFormat->TexelBytes;
      dstPitch = t->image[0][0].width * texFormat->TexelBytes;
d348 2
a349 2
   t->image[0][hwlevel].data = texImage->Data;
   srcOffset = r200GartOffsetFromVirtual( rmesa, texImage->Data );
d361 1
a361 1
		 srcPitch,  
d363 1
a363 1
		 dstPitch,
d367 2
a368 2
		 t->image[0][hwlevel].x + x,
		 t->image[0][hwlevel].y + y, 
d382 1
a382 1
   int blit_format, dstPitch, done;
d398 1
a398 1
   t->image[0][0].data = texImage->Data;
d404 1
a404 1
   dstPitch = t->pp_txpitch + 32;
d406 2
a407 2
   if (rmesa->prefer_gart_client_texturing && texImage->IsClientData) {
      /* In this case, could also use GART texturing.  This is
d410 1
a410 1
      t->pp_txoffset = r200GartOffsetFromVirtual( rmesa, texImage->Data );
d415 1
a415 1
		 "Using GART texturing for rectangular client texture\n");
d419 3
a421 5
      /* FIXME This may not be correct as driSwapOutTextureObject sets
       * FIXME dirty_images.  It may be fine, though.
       */
      if ( t->base.memBlock ) {
	 driSwapOutTextureObject( (driTextureObject *) t );
d423 1
d426 1
a426 1
      /* Data already in GART memory, with usable pitch.
a427 2
      GLuint srcPitch;
      srcPitch = texImage->RowStride * texFormat->TexelBytes;
d430 3
a432 3
		    srcPitch,
		    r200GartOffsetFromVirtual( rmesa, texImage->Data ),   
		    dstPitch, t->bufAddr,
d438 1
a438 1
      /* Data not in GART memory, or bad pitch.
d442 3
a444 7
	 int lines = MIN2( height - done, RADEON_BUFFER_SIZE / dstPitch );
	 int src_pitch;
	 char *tex;

         src_pitch = texImage->RowStride * texFormat->TexelBytes;

	 tex = (char *)texImage->Data + done * src_pitch;
d447 1
a447 1
	 r200AllocDmaRegion( rmesa, &region, lines * dstPitch, 64 );
d452 2
a453 2
	    fprintf(stderr, "%s: src_pitch %d dst_pitch %d\n",
		    __FUNCTION__, src_pitch, dstPitch);
d455 1
a455 1
	 if (src_pitch == dstPitch) {
d463 1
a463 1
	       buf += dstPitch;
d474 2
a475 2
		       dstPitch, GET_START( &region ),   
		       dstPitch, t->bufAddr,
d489 7
a495 8
/**
 * Upload the texture image associated with texture \a t at the specified
 * level at the address relative to \a start.
 */
static void uploadSubImage( r200ContextPtr rmesa, r200TexObjPtr t, 
			    GLint hwlevel,
			    GLint x, GLint y, GLint width, GLint height,
			    GLuint face )
d497 4
a500 2
   struct gl_texture_image *texImage = NULL;
   GLuint offset;
d505 1
a505 1
   const int level = hwlevel + t->base.firstLevel;
d508 2
a509 2
      fprintf( stderr, "%s( %p, %p ) level/width/height/face = %d/%d/%d/%u\n", 
	       __FUNCTION__, (void *)t, (void *)t->base.tObj, level, width, height, face );
a511 2
   ASSERT(face < 6);

d514 1
a514 1
      _mesa_problem(NULL, "bad texture level in %s", __FUNCTION__);
d518 1
a518 21
   switch (face) {
   case 0:
      texImage = t->base.tObj->Image[level];
      break;
   case 1:
      texImage = t->base.tObj->NegX[level];
      break;
   case 2:
      texImage = t->base.tObj->PosY[level];
      break;
   case 3:
      texImage = t->base.tObj->NegY[level];
      break;
   case 4:
      texImage = t->base.tObj->PosZ[level];
      break;
   case 5:
      texImage = t->base.tObj->NegZ[level];
      break;
   }

d531 1
a531 1
   if (t->base.tObj->Target == GL_TEXTURE_RECTANGLE_NV) {
d541 1
a541 1
	 fprintf( stderr, "%s: image data is in GART client storage\n",
d543 1
a543 1
      r200UploadGARTClientSubImage( rmesa, t, texImage, hwlevel,
d552 16
d572 1
d574 3
a576 1
   if ( R200_DEBUG & (DEBUG_TEXTURE|DEBUG_IOCTL) ) {
d579 4
a582 4
      GLint blitX = t->image[face][hwlevel].x;
      GLint blitY = t->image[face][hwlevel].y;
      GLint blitWidth = t->image[face][hwlevel].width;
      GLint blitHeight = t->image[face][hwlevel].height;
d587 3
a589 2
      fprintf( stderr, "       blit ofs: 0x%07x level: %d/%d\n",
	       (GLuint)offset, hwlevel, level );
d592 1
a592 1
   t->image[face][hwlevel].data = texImage->Data;
a593 6
   /* Init the DRM_RADEON_TEXTURE command / drmRadeonTexture struct.
    * NOTE: we're always use a 1KB-wide blit and I8 texture format.
    * We used to use 1, 2 and 4-byte texels and used to use the texture
    * width to dictate the blit width - but that won't work for compressed
    * textures. (Brian)
    */
d595 4
a598 12
   tex.pitch = BLIT_WIDTH_BYTES / 64;
   tex.format = R200_TXFORMAT_I8; /* any 1-byte texel format */
   if (texImage->TexFormat->TexelBytes) {
      tex.width = imageWidth * texImage->TexFormat->TexelBytes; /* in bytes */
      tex.height = imageHeight;
   }
   else {
      tex.width = imageWidth; /* compressed */
      tex.height = imageHeight;
      if (tex.height < 4)
         tex.height = 4;
   }
d601 1
a601 2
   /* copy (x,y,width,height,data) */
   memcpy( &tmp, &t->image[face][hwlevel], sizeof(drmRadeonTexImage) );
d617 3
a619 3
      fprintf( stderr, "DRM_RADEON_TEXTURE: return = %d\n", ret );
      fprintf( stderr, "   offset=0x%08x\n",
	       offset );
d623 2
a624 2
	       t->image[face][hwlevel].width, t->image[face][hwlevel].height,
	       t->image[face][hwlevel].data );
d630 4
a633 7
/**
 * Upload the texture images associated with texture \a t.  This might
 * require the allocation of texture memory.
 * 
 * \param rmesa Context pointer
 * \param t Texture to be uploaded
 * \param face Cube map face to be uploaded.  Zero for non-cube maps.
d635 1
a635 2

int r200UploadTexImages( r200ContextPtr rmesa, r200TexObjPtr t, GLuint face )
d637 4
a640 1
   const int numLevels = t->base.lastLevel - t->base.firstLevel + 1;
d644 2
a645 2
	       (void *)rmesa->glCtx, (void *)t->base.tObj, t->base.totalSize,
	       t->base.firstLevel, t->base.lastLevel );
d648 1
a648 1
   if ( !t || t->base.totalSize == 0 )
d652 2
a653 1
      fprintf(stderr, "%s: Syncing\n", __FUNCTION__ );
d659 2
a660 2
   if ( t->base.memBlock == NULL ) {
      int heap;
d662 38
a699 5
      heap = driAllocateTexture( rmesa->texture_heaps, rmesa->nr_heaps,
				 (driTextureObject *) t );
      if ( heap == -1 ) {
	 UNLOCK_HARDWARE( rmesa );
	 return -1;
d703 1
a703 2
      t->bufAddr = rmesa->r200Screen->texOffset[heap] 
	   + t->base.memBlock->ofs;
a705 1

d711 2
a712 3
   /* Let the world know we've used this memory recently.
    */
   driUpdateTextureLRU( (driTextureObject *) t );
d716 8
a723 6
   if (t->base.dirty_images[face]) {
      int i;
      for ( i = 0 ; i < numLevels ; i++ ) {
         if ( (t->base.dirty_images[face] & (1 << (i+t->base.firstLevel))) != 0 ) {
            uploadSubImage( rmesa, t, i, 0, 0, t->image[face][i].width,
			    t->image[face][i].height, face );
d726 1
a726 1
      t->base.dirty_images[face] = 0;
d730 1
d732 1
a732 1
      fprintf(stderr, "%s: Syncing\n", __FUNCTION__ );
@


1.1.1.1
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@@


1.1.1.2
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/lib/GL/mesa/src/drv/r200/r200_texmem.c,v 1.7 2004/01/23 03:57:05 dawes Exp $ */
d39 1
a39 7
#include "glheader.h"
#include "imports.h"
#include "context.h"
#include "colormac.h"
#include "macros.h"
#include "simple_list.h"
#include "radeon_reg.h" /* gets definition for usleep */
d46 7
a52 1
#include <unistd.h>  /* for usleep() */
d54 1
d56 1
a56 3
/**
 * Destroy any device-dependent state associated with the texture.  This may
 * include NULLing out hardware state that points to the texture.
d58 1
a58 2
void
r200DestroyTexObj( r200ContextPtr rmesa, r200TexObjPtr t )
d60 3
d64 167
a230 1
      fprintf( stderr, "%s( %p, %p )\n", __FUNCTION__, (void *)t, (void *)t->base.tObj );
d232 1
d234 10
a243 2
   if ( rmesa != NULL ) {
      unsigned   i;
d245 5
d251 51
a301 7
      for ( i = 0 ; i < rmesa->glCtx->Const.MaxTextureUnits ; i++ ) {
	 if ( t == rmesa->state.texture.unit[i].texobj ) {
	    rmesa->state.texture.unit[i].texobj = NULL;
	    remove_from_list( &rmesa->hw.tex[i] );
	    make_empty_list( &rmesa->hw.tex[i] );
	    remove_from_list( &rmesa->hw.cube[i] );
	    make_empty_list( &rmesa->hw.cube[i] );
d304 8
d321 6
a326 6
static void r200UploadGARTClientSubImage( r200ContextPtr rmesa,
					  r200TexObjPtr t, 
					  struct gl_texture_image *texImage,
					  GLint hwlevel,
					  GLint x, GLint y, 
					  GLint width, GLint height )
d329 1
a329 1
   GLuint srcPitch, dstPitch;
d333 1
a333 5
   /*
    * XXX it appears that we always upload the full image, not a subimage.
    * I.e. x==0, y==0, width=texWidth, height=texWidth.  If this is ever
    * changed, the src pitch will have to change.
    */
a336 2
      srcPitch = t->image[0][0].width * texFormat->TexelBytes;
      dstPitch = t->image[0][0].width * texFormat->TexelBytes;
a339 2
      srcPitch = t->image[0][0].width * texFormat->TexelBytes;
      dstPitch = t->image[0][0].width * texFormat->TexelBytes;
a342 2
      srcPitch = t->image[0][0].width * texFormat->TexelBytes;
      dstPitch = t->image[0][0].width * texFormat->TexelBytes;
d348 2
a349 2
   t->image[0][hwlevel].data = texImage->Data;
   srcOffset = r200GartOffsetFromVirtual( rmesa, texImage->Data );
d361 1
a361 1
		 srcPitch,  
d363 1
a363 1
		 dstPitch,
d367 2
a368 2
		 t->image[0][hwlevel].x + x,
		 t->image[0][hwlevel].y + y, 
d382 1
a382 1
   int blit_format, dstPitch, done;
d398 1
a398 1
   t->image[0][0].data = texImage->Data;
d404 1
a404 1
   dstPitch = t->pp_txpitch + 32;
d406 2
a407 2
   if (rmesa->prefer_gart_client_texturing && texImage->IsClientData) {
      /* In this case, could also use GART texturing.  This is
d410 1
a410 1
      t->pp_txoffset = r200GartOffsetFromVirtual( rmesa, texImage->Data );
d415 1
a415 1
		 "Using GART texturing for rectangular client texture\n");
d419 3
a421 5
      /* FIXME This may not be correct as driSwapOutTextureObject sets
       * FIXME dirty_images.  It may be fine, though.
       */
      if ( t->base.memBlock ) {
	 driSwapOutTextureObject( (driTextureObject *) t );
d423 1
d426 1
a426 1
      /* Data already in GART memory, with usable pitch.
a427 2
      GLuint srcPitch;
      srcPitch = texImage->RowStride * texFormat->TexelBytes;
d430 3
a432 3
		    srcPitch,
		    r200GartOffsetFromVirtual( rmesa, texImage->Data ),   
		    dstPitch, t->bufAddr,
d438 1
a438 1
      /* Data not in GART memory, or bad pitch.
d442 3
a444 7
	 int lines = MIN2( height - done, RADEON_BUFFER_SIZE / dstPitch );
	 int src_pitch;
	 char *tex;

         src_pitch = texImage->RowStride * texFormat->TexelBytes;

	 tex = (char *)texImage->Data + done * src_pitch;
d447 1
a447 1
	 r200AllocDmaRegion( rmesa, &region, lines * dstPitch, 64 );
d452 2
a453 2
	    fprintf(stderr, "%s: src_pitch %d dst_pitch %d\n",
		    __FUNCTION__, src_pitch, dstPitch);
d455 1
a455 1
	 if (src_pitch == dstPitch) {
d463 1
a463 1
	       buf += dstPitch;
d474 2
a475 2
		       dstPitch, GET_START( &region ),   
		       dstPitch, t->bufAddr,
d489 7
a495 8
/**
 * Upload the texture image associated with texture \a t at the specified
 * level at the address relative to \a start.
 */
static void uploadSubImage( r200ContextPtr rmesa, r200TexObjPtr t, 
			    GLint hwlevel,
			    GLint x, GLint y, GLint width, GLint height,
			    GLuint face )
d497 4
a500 2
   struct gl_texture_image *texImage = NULL;
   GLuint offset;
d505 1
a505 1
   const int level = hwlevel + t->base.firstLevel;
d508 2
a509 2
      fprintf( stderr, "%s( %p, %p ) level/width/height/face = %d/%d/%d/%u\n", 
	       __FUNCTION__, (void *)t, (void *)t->base.tObj, level, width, height, face );
a511 2
   ASSERT(face < 6);

d514 1
a514 1
      _mesa_problem(NULL, "bad texture level in %s", __FUNCTION__);
d518 1
a518 21
   switch (face) {
   case 0:
      texImage = t->base.tObj->Image[level];
      break;
   case 1:
      texImage = t->base.tObj->NegX[level];
      break;
   case 2:
      texImage = t->base.tObj->PosY[level];
      break;
   case 3:
      texImage = t->base.tObj->NegY[level];
      break;
   case 4:
      texImage = t->base.tObj->PosZ[level];
      break;
   case 5:
      texImage = t->base.tObj->NegZ[level];
      break;
   }

d531 1
a531 1
   if (t->base.tObj->Target == GL_TEXTURE_RECTANGLE_NV) {
d541 1
a541 1
	 fprintf( stderr, "%s: image data is in GART client storage\n",
d543 1
a543 1
      r200UploadGARTClientSubImage( rmesa, t, texImage, hwlevel,
d552 16
d572 1
d574 3
a576 1
   if ( R200_DEBUG & (DEBUG_TEXTURE|DEBUG_IOCTL) ) {
d579 4
a582 4
      GLint blitX = t->image[face][hwlevel].x;
      GLint blitY = t->image[face][hwlevel].y;
      GLint blitWidth = t->image[face][hwlevel].width;
      GLint blitHeight = t->image[face][hwlevel].height;
d587 3
a589 2
      fprintf( stderr, "       blit ofs: 0x%07x level: %d/%d\n",
	       (GLuint)offset, hwlevel, level );
d592 1
a592 1
   t->image[face][hwlevel].data = texImage->Data;
a593 6
   /* Init the DRM_RADEON_TEXTURE command / drmRadeonTexture struct.
    * NOTE: we're always use a 1KB-wide blit and I8 texture format.
    * We used to use 1, 2 and 4-byte texels and used to use the texture
    * width to dictate the blit width - but that won't work for compressed
    * textures. (Brian)
    */
d595 4
a598 12
   tex.pitch = BLIT_WIDTH_BYTES / 64;
   tex.format = R200_TXFORMAT_I8; /* any 1-byte texel format */
   if (texImage->TexFormat->TexelBytes) {
      tex.width = imageWidth * texImage->TexFormat->TexelBytes; /* in bytes */
      tex.height = imageHeight;
   }
   else {
      tex.width = imageWidth; /* compressed */
      tex.height = imageHeight;
      if (tex.height < 4)
         tex.height = 4;
   }
d601 1
a601 2
   /* copy (x,y,width,height,data) */
   memcpy( &tmp, &t->image[face][hwlevel], sizeof(drmRadeonTexImage) );
d617 3
a619 3
      fprintf( stderr, "DRM_RADEON_TEXTURE: return = %d\n", ret );
      fprintf( stderr, "   offset=0x%08x\n",
	       offset );
d623 2
a624 2
	       t->image[face][hwlevel].width, t->image[face][hwlevel].height,
	       t->image[face][hwlevel].data );
d630 4
a633 7
/**
 * Upload the texture images associated with texture \a t.  This might
 * require the allocation of texture memory.
 * 
 * \param rmesa Context pointer
 * \param t Texture to be uploaded
 * \param face Cube map face to be uploaded.  Zero for non-cube maps.
d635 1
a635 2

int r200UploadTexImages( r200ContextPtr rmesa, r200TexObjPtr t, GLuint face )
d637 4
a640 1
   const int numLevels = t->base.lastLevel - t->base.firstLevel + 1;
d644 2
a645 2
	       (void *)rmesa->glCtx, (void *)t->base.tObj, t->base.totalSize,
	       t->base.firstLevel, t->base.lastLevel );
d648 1
a648 1
   if ( !t || t->base.totalSize == 0 )
d652 2
a653 1
      fprintf(stderr, "%s: Syncing\n", __FUNCTION__ );
d659 2
a660 2
   if ( t->base.memBlock == NULL ) {
      int heap;
d662 38
a699 5
      heap = driAllocateTexture( rmesa->texture_heaps, rmesa->nr_heaps,
				 (driTextureObject *) t );
      if ( heap == -1 ) {
	 UNLOCK_HARDWARE( rmesa );
	 return -1;
d703 1
a703 2
      t->bufAddr = rmesa->r200Screen->texOffset[heap] 
	   + t->base.memBlock->ofs;
a705 1

d711 2
a712 3
   /* Let the world know we've used this memory recently.
    */
   driUpdateTextureLRU( (driTextureObject *) t );
d716 8
a723 6
   if (t->base.dirty_images[face]) {
      int i;
      for ( i = 0 ; i < numLevels ; i++ ) {
         if ( (t->base.dirty_images[face] & (1 << (i+t->base.firstLevel))) != 0 ) {
            uploadSubImage( rmesa, t, i, 0, 0, t->image[face][i].width,
			    t->image[face][i].height, face );
d726 1
a726 1
      t->base.dirty_images[face] = 0;
d730 1
d732 1
a732 1
      fprintf(stderr, "%s: Syncing\n", __FUNCTION__ );
@

