head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.04.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.04.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.31.41;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.59.47;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.18.16;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* -*- mode: c; c-basic-offset: 3 -*-
 *
 * Copyright 2000 VA Linux Systems Inc., Fremont, California.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEMS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/* $XFree86: xc/lib/GL/mesa/src/drv/tdfx/tdfx_texman.c,v 1.4 2001/08/18 02:51:07 dawes Exp $ */

/*
 * Original rewrite:
 *	Gareth Hughes <gareth@@valinux.com>, 29 Sep - 1 Oct 2000
 *
 * Authors:
 *	Gareth Hughes <gareth@@valinux.com>
 *	Brian Paul <brianp@@valinux.com>
 *
 */

#include "tdfx_context.h"
#include "tdfx_tex.h"
#include "tdfx_texman.h"

#define BAD_ADDRESS	((FxU32) -1)

/* Verify the consistancy of the texture memory manager.
 * This involves:
 *    Traversing all texture objects and computing total memory used.
 *    Traverse the free block list and computing total memory free.
 *    Compare the total free and total used amounts to the total memory size.
 *    Make various assertions about the results.
 */
static void tdfxTMVerifyFreeList( tdfxContextPtr fxMesa, FxU32 unit )
{
   struct gl_shared_state *ss = fxMesa->glCtx->Shared;
   struct gl_texture_object *texObj;
   tdfxSharedStatePtr tss = (tdfxSharedStatePtr)ss->DriverData;
   tdfxMemRange *block;
   int prevStart = -1, prevEnd = -1;
   int totalFree = 0;
   int numObj = 0, numRes = 0;
   int totalUsed = 0;

   for ( block = tss->freeRanges[unit] ; block ; block = block->next ) {
      assert( block->endAddr > 0 );
      assert( block->startAddr <= tss->totalTexMem[unit] );
      assert( block->endAddr <= tss->totalTexMem[unit] );
      assert( (int) block->startAddr > prevStart );
      assert( (int) block->startAddr >= prevEnd );
      prevStart = (int) block->startAddr;
      prevEnd = (int) block->endAddr;
      totalFree += (block->endAddr - block->startAddr);
   }
   assert( totalFree == tss->freeTexMem[unit] );

   for ( texObj = ss->TexObjectList ; texObj ; texObj = texObj->Next ) {
      tdfxTexObjPtr t = TDFX_TEXTURE_DATA(texObj);
      numObj++;
      if ( t ) {
	 if ( t->isInTM ) {
	    numRes++;
	    assert( t->range[0] );
	    if ( t->range[unit] )
	       totalUsed += (t->range[unit]->endAddr - t->range[unit]->startAddr);
	 } else {
	    assert(!t->range[0]);
	 }
      }
   }

   fprintf( stderr,
	    "totalFree: %d  totalUsed: %d  totalMem: %d #objs=%d  #res=%d\n",
	    tss->freeTexMem[unit], totalUsed, tss->totalTexMem[unit],
	    numObj, numRes );

   assert( totalUsed + totalFree == tss->totalTexMem[unit] );
}

static void tdfxTMDumpTexMem( tdfxContextPtr fxMesa )
{
   struct gl_shared_state *ss = fxMesa->glCtx->Shared;
   tdfxSharedStatePtr tss = (tdfxSharedStatePtr)ss->DriverData;
   struct gl_texture_object *texObj;
   tdfxMemRange *r;
   FxU32 prev;

   printf( "DUMP Objects:\n" );
   for ( texObj = ss->TexObjectList ; texObj ; texObj = texObj->Next ) {
      tdfxTexObjPtr t = TDFX_TEXTURE_DATA(texObj);

      if ( t && t->isInTM ) {
	 printf( "Obj %8p: %4d  info = %p\n", texObj, texObj->Name, t );

	 printf( "  isInTM=%d  whichTMU=%ld  lastTimeUsed=%d\n",
		 t->isInTM, t->whichTMU, t->lastTimeUsed );
	 printf( "    tm[0] = %p", t->range[0] );
	 assert( t->range[0] );
	 if ( t->range[0] ) {
	    printf( "  tm startAddr = %ld  endAddr = %ld",
		    t->range[0]->startAddr,
		    t->range[0]->endAddr );
	 }
	 printf( "\n" );
	 printf( "    tm[1] = %p", t->range[1] );
	 if ( t->range[1] ) {
	    printf( "  tm startAddr = %ld  endAddr = %ld",
		    t->range[1]->startAddr,
		    t->range[1]->endAddr );
	 }
	 printf( "\n" );
      }
   }

   tdfxTMVerifyFreeList( fxMesa, 0 );
   tdfxTMVerifyFreeList( fxMesa, 1 );

   printf( "Free memory unit 0:  %d bytes\n", tss->freeTexMem[0] );
   prev = 0;
   for ( r = tss->freeRanges[0] ; r ; r = r->next ) {
      printf( "%8p:  start %8ld  end %8ld  size %8ld  gap %8ld\n",
	      r, r->startAddr, r->endAddr, r->endAddr - r->startAddr,
	      r->startAddr - prev );
      prev = r->endAddr;
   }

   printf( "Free memory unit 1:  %d bytes\n", tss->freeTexMem[1] );
   prev = 0;
   for ( r = tss->freeRanges[1] ; r ; r = r->next ) {
      printf( "%8p:  start %8ld  end %8ld  size %8ld  gap %8ld\n",
	      r, r->startAddr, r->endAddr, r->endAddr - r->startAddr,
	      r->startAddr - prev );
      prev = r->endAddr;
   }
}


#ifdef TEXSANITY
static void fubar( void )
{
   /* GH: What am I meant to do??? */
}

/* Sanity Check
 */
static void sanity( tdfxContextPtr fxMesa )
{
   tdfxMemRange *tmp, *prev, *pos;

   prev = 0;
   tmp = fxMesa->freeRanges[0];
   while ( tmp ) {
      if ( !tmp->startAddr && !tmp->endAddr ) {
	 fprintf( stderr, "Textures fubar\n" );
	 fubar();
      }
      if ( tmp->startAddr >= tmp->endAddr ) {
	 fprintf( stderr, "Node fubar\n" );
	 fubar();
      }
      if ( prev && ( prev->startAddr >= tmp->startAddr ||
		     prev->endAddr > tmp->startAddr ) ) {
	 fprintf( stderr, "Sorting fubar\n" );
	 fubar();
      }
      prev = tmp;
      tmp = tmp->next;
   }

   prev = 0;
   tmp = fxMesa->freeRanges[1];
   while ( tmp ) {
      if ( !tmp->startAddr && !tmp->endAddr ) {
	 fprintf( stderr, "Textures fubar\n" );
	 fubar();
      }
      if ( tmp->startAddr >= tmp->endAddr ) {
	 fprintf( stderr, "Node fubar\n" );
	 fubar();
      }
      if ( prev && ( prev->startAddr >= tmp->startAddr ||
		     prev->endAddr > tmp->startAddr ) ) {
	 fprintf( stderr, "Sorting fubar\n" );
	 fubar();
      }
      prev = tmp;
      tmp = tmp->next;
   }
}
#endif


/* Allocate and initialize a new MemRange struct.  Try to allocate it
 * from the pool of free MemRange nodes rather than malloc.
 */
static tdfxMemRange *
tdfxTMNewRangeNode( tdfxContextPtr fxMesa, FxU32 start, FxU32 end )
{
   struct gl_shared_state *ss = fxMesa->glCtx->Shared;
   tdfxSharedStatePtr tss = (tdfxSharedStatePtr)ss->DriverData;
   tdfxMemRange *range;

   _glthread_LOCK_MUTEX( ss->Mutex );
   if ( tss && tss->rangePool ) {
      range = tss->rangePool;
      tss->rangePool = tss->rangePool->next;
   } else {
      range = MALLOC( sizeof(tdfxMemRange) );
   }
   _glthread_UNLOCK_MUTEX( ss->Mutex );

   if ( !range ) {
      if ( TDFX_DEBUG & DEBUG_VERBOSE_TEXTURE )
	 fprintf( stderr, __FUNCTION__ ": out of memory!\n" );
      return NULL;
   }

   range->startAddr = start;
   range->endAddr = end;
   range->next = NULL;

   return range;
}


/* Initialize texture memory.  We take care of one or both TMU's here.
 */
void tdfxTMInit( tdfxContextPtr fxMesa )
{
   GLcontext *ctx = fxMesa->glCtx;

   if ( TDFX_DEBUG & DEBUG_VERBOSE_TEXTURE )
      fprintf( stderr, __FUNCTION__ "\n" );

   if ( !ctx->Shared->DriverData ) {
      const char *extensions;
      tdfxSharedStatePtr tss = CALLOC_STRUCT( tdfx_shared_state );

      if ( !tss )
	 return;

      LOCK_HARDWARE( fxMesa );

      extensions = fxMesa->Glide.grGetString( GR_EXTENSION );

      if ( strstr( extensions, " TEXUMA " ) ) {
	 FxU32 start, end;

	 tss->umaTexMemory = GL_TRUE;

	 fxMesa->Glide.grEnable( GR_TEXTURE_UMA_EXT );

	 start = fxMesa->Glide.grTexMinAddress( 0 );
	 end = fxMesa->Glide.grTexMaxAddress( 0 );

	 if ( TDFX_DEBUG & DEBUG_VERBOSE_TEXTURE )
	    fprintf( stderr, "   UMA tex memory: %d\n", (int)(end - start) );

	 tss->totalTexMem[0] = end - start;
	 tss->totalTexMem[1] = 0;
	 tss->freeTexMem[0] = end - start;
	 tss->freeTexMem[1] = 0;
	 tss->freeRanges[0] = tdfxTMNewRangeNode( fxMesa, start, end );
	 tss->freeRanges[1] = NULL;
      } else {
	 int unit;

	 tss->umaTexMemory = GL_FALSE;

	 for ( unit = 0 ; unit < fxMesa->numTMUs ; unit++ ) {
	    FxU32 start, end;

	    start = fxMesa->Glide.grTexMinAddress( unit );
	    end = fxMesa->Glide.grTexMaxAddress( unit );

	    tss->totalTexMem[unit] = end - start;
	    tss->freeTexMem[unit] = end - start;
	    tss->freeRanges[unit] = tdfxTMNewRangeNode( fxMesa, start, end );

	    if ( TDFX_DEBUG & DEBUG_VERBOSE_TEXTURE )
	       fprintf( stderr, "   Split tex memory: %d\n",
			(int)(end - start) );
	 }
      }

      UNLOCK_HARDWARE( fxMesa );

      tss->rangePool = NULL;
      ctx->Shared->DriverData = tss;

      if ( TDFX_DEBUG & DEBUG_VERBOSE_TEXTURE )
	 fprintf( stderr, "  init UMA: %d\n", tss->umaTexMemory );
   }
}


/* Clean-up texture memory before destroying context.
 */
void tdfxTMClose( tdfxContextPtr fxMesa )
{
   GLcontext *ctx = fxMesa->glCtx;

   if ( ctx->Shared->RefCount == 1 && fxMesa->driDrawable ) {
      /* RefCount will soon go to zero, free our 3dfx stuff */
      tdfxSharedStatePtr tss = (tdfxSharedStatePtr)ctx->Shared->DriverData;
      int unit;
      tdfxMemRange *tmp, *next;

      /* Deallocate the pool of free tdfxMemRange nodes */
      tmp = tss->rangePool;
      while ( tmp ) {
	 next = tmp->next;
	 FREE( tmp );
	 tmp = next;
      }

      /* Delete the texture memory block tdfxMemRange nodes */
      for ( unit = 0 ; unit < fxMesa->numTMUs ; unit++ ) {
	 tmp = tss->freeRanges[unit];
	 while ( tmp ) {
	    next = tmp->next;
	    FREE( tmp );
	    tmp = next;
	 }
      }

      FREE( tss );
      ctx->Shared->DriverData = NULL;
   }
}



/* Delete a tdfxMemRange struct.
 * We keep a linked list of free/available tdfxMemRange structs to
 * avoid extra malloc/free calls.
 */
#define DELETE_RANGE_NODE( tss, range )					\
do {									\
   (range)->next = (tss)->rangePool;					\
   (tss)->rangePool = (range);						\
} while (0)

/* When we've run out of texture memory we have to throw out an
 * existing texture to make room for the new one.  This function
 * determins the texture to throw out.
 */
static struct gl_texture_object *
tdfxTMFindOldestObject( tdfxContextPtr fxMesa, FxU32 unit )
{
   struct gl_shared_state *ss = fxMesa->glCtx->Shared;
   const GLuint bindNumber = fxMesa->texBindNumber;
   struct gl_texture_object *oldestObj, *texObj, *lowestPriorityObj;
   GLfloat lowestPriority;
   GLuint oldestAge;

   if ( TDFX_DEBUG & DEBUG_VERBOSE_TEXTURE )
      fprintf( stderr, __FUNCTION__ "\n" );

   oldestObj = NULL;
   oldestAge = 0;

   lowestPriority = 1.0F;
   lowestPriorityObj = NULL;

   for ( texObj = ss->TexObjectList ; texObj ; texObj = texObj->Next ) {
      tdfxTexObjPtr t = TDFX_TEXTURE_DATA(texObj);

      if ( t && t->isInTM &&
	   ( ( t->whichTMU == unit ) ||
	     ( t->whichTMU == TDFX_TMU_BOTH ) ||
	     ( t->whichTMU == TDFX_TMU_SPLIT ) ) ) {
	 GLuint age, lastTime;

	 assert( t->range[0] );
	 lastTime = t->lastTimeUsed;

	 if ( lastTime > bindNumber ) {
	    /* TODO: check wrap around */
	    age = bindNumber + (UINT_MAX - lastTime + 1);
	 } else {
	    age = bindNumber - lastTime;
	 }
	 if ( age >= oldestAge ) {
	    oldestAge = age;
	    oldestObj = texObj;
	 }

	 /* examine priority */
	 if ( texObj->Priority < lowestPriority ) {
	    lowestPriority = texObj->Priority;
	    lowestPriorityObj = texObj;
	 }
      }
   }

   if ( lowestPriority < 1.0 ) {
      ASSERT( lowestPriorityObj );
      if ( TDFX_DEBUG & DEBUG_VERBOSE_TEXTURE )
	 fprintf( stderr, "discard %d pri=%f\n",
		  lowestPriorityObj->Name, lowestPriority );
      return lowestPriorityObj;
   } else {
      if ( TDFX_DEBUG & DEBUG_VERBOSE_TEXTURE )
	 fprintf( stderr, "discard %d age=%d\n",
		  oldestObj->Name, oldestAge );
      return oldestObj;
   }
}


/* Find the address (offset?) at which we can store a new texture.
 * <unit> is the texture unit.
 * <size> is the texture size in bytes.
 */
static FxU32 tdfxTMFindStartAddr( tdfxContextPtr fxMesa,
				  FxU32 unit, FxU32 size )
{
   struct gl_shared_state *ss = fxMesa->glCtx->Shared;
   tdfxSharedStatePtr tss = (tdfxSharedStatePtr)ss->DriverData;
   struct gl_texture_object *texObj;
   tdfxMemRange *prev, *block;
   FxU32 result;

   if ( tss->umaTexMemory ) {
      assert( unit == TDFX_TMU0 );
   }

   _glthread_LOCK_MUTEX( ss->Mutex );
   while ( 1 ) {
      prev = NULL;
      block = tss->freeRanges[unit];

      while ( block ) {
	 if ( block->endAddr - block->startAddr >= size ) {
	    /* The texture will fit here */
	    result = block->startAddr;
	    block->startAddr += size;
	    if ( block->startAddr == block->endAddr ) {
	       /* Remove this node since it's empty */
	       if ( prev ) {
		  prev->next = block->next;
	       } else {
		  tss->freeRanges[unit] = block->next;
	       }
	       DELETE_RANGE_NODE( tss, block );
	    }
	    tss->freeTexMem[unit] -= size;
	    _glthread_UNLOCK_MUTEX( ss->Mutex );
	    return result;
	 }
	 prev = block;
	 block = block->next;
      }

      /* We failed to find a block large enough to accomodate <size> bytes.
       * Find the oldest texObject and free it.
       */
      texObj = tdfxTMFindOldestObject( fxMesa, unit );
      if ( texObj ) {
	 tdfxTMMoveOutTMLocked( fxMesa, texObj );
	 fxMesa->stats.texSwaps++;
      } else {
	 gl_problem( NULL, "tdfx driver: extreme texmem fragmentation" );
	 _glthread_UNLOCK_MUTEX( ss->Mutex );
	 return BAD_ADDRESS;
      }
   }

   /* never get here, but play it safe */
   _glthread_UNLOCK_MUTEX( ss->Mutex );
   return BAD_ADDRESS;
}


/* Remove the given tdfxMemRange node from hardware texture memory.
 */
static void tdfxTMRemoveRangeLocked( tdfxContextPtr fxMesa,
				     FxU32 unit, tdfxMemRange *range )
{
   struct gl_shared_state *ss = fxMesa->glCtx->Shared;
   tdfxSharedStatePtr tss = (tdfxSharedStatePtr)ss->DriverData;
   tdfxMemRange *block, *prev;

   if ( tss->umaTexMemory ) {
      assert( unit == TDFX_TMU0 );
   }

   if ( !range )
      return;

   if ( range->startAddr == range->endAddr ) {
      DELETE_RANGE_NODE( tss, range );
      return;
   }
   tss->freeTexMem[unit] += range->endAddr - range->startAddr;

   /* find position in linked list to insert this tdfxMemRange node */
   prev = NULL;
   block = tss->freeRanges[unit];
   while ( block ) {
      assert( range->startAddr != block->startAddr );
      if ( range->startAddr > block->startAddr ) {
	 prev = block;
	 block = block->next;
      } else {
	 break;
      }
   }

   /* Insert the free block, combine with adjacent blocks when possible */
   range->next = block;
   if ( block ) {
      if ( range->endAddr == block->startAddr ) {
	 /* Combine */
	 block->startAddr = range->startAddr;
	 DELETE_RANGE_NODE( tss, range );
	 range = block;
      }
   }
   if ( prev ) {
      if ( prev->endAddr == range->startAddr ) {
	 /* Combine */
	 prev->endAddr = range->endAddr;
	 prev->next = range->next;
	 DELETE_RANGE_NODE( tss, range );
      } else {
	 prev->next = range;
      }
   } else {
      tss->freeRanges[unit] = range;
   }
}


/* Allocate space for a texture image.
 * <tmu> is the texture unit
 * <texmemsize> is the number of bytes to allocate
 */
static tdfxMemRange *
tdfxTMAllocTexMem( tdfxContextPtr fxMesa, FxU32 unit, FxU32 size )
{
   tdfxMemRange *range = NULL;
   FxU32 start;

   start = tdfxTMFindStartAddr( fxMesa, unit, size );

   if ( start != BAD_ADDRESS ) {
      range = tdfxTMNewRangeNode( fxMesa, start, start + size );
   } else {
      fprintf( stderr,
	       "tdfxTMAllocTexMem returned NULL!  unit=%ld size=%ld\n",
	       unit, size );
   }
   return range;
}


/* Download (copy) the given texture data (all mipmap levels) into the
 * Voodoo's texture memory.  The texture memory must have already been
 * allocated.
 */
void tdfxTMDownloadTextureLocked( tdfxContextPtr fxMesa,
				  struct gl_texture_object *tObj )
{
   tdfxTexObjPtr t = TDFX_TEXTURE_DATA(tObj);
   FxU32 targetTMU;
   GLint l;

   assert( tObj );
   assert( t );

   targetTMU = t->whichTMU;

   switch ( targetTMU ) {
   case TDFX_TMU0:
   case TDFX_TMU1:
      if ( t->range[targetTMU] ) {
	 for ( l = t->minLevel ; l <= t->maxLevel && t->image[l].data ; l++ ) {
	    GrLOD_t glideLod = t->info.largeLodLog2 - l + tObj->BaseLevel;

	    fxMesa->Glide.grTexDownloadMipMapLevel( targetTMU,
				      t->range[targetTMU]->startAddr,
				      glideLod,
				      t->info.largeLodLog2,
				      t->info.aspectRatioLog2,
				      t->info.format,
				      GR_MIPMAPLEVELMASK_BOTH,
				      t->image[l].data );
	 }
      }
      break;

   case TDFX_TMU_SPLIT:
      if ( t->range[TDFX_TMU0] && t->range[TDFX_TMU1] ) {
	 for ( l = t->minLevel ; l <= t->maxLevel && t->image[l].data ; l++ ) {
	    GrLOD_t glideLod = t->info.largeLodLog2 - l + tObj->BaseLevel;

	    fxMesa->Glide.grTexDownloadMipMapLevel( GR_TMU0,
				      t->range[TDFX_TMU0]->startAddr,
				      glideLod,
				      t->info.largeLodLog2,
				      t->info.aspectRatioLog2,
				      t->info.format,
				      GR_MIPMAPLEVELMASK_ODD,
				      t->image[l].data );

	    fxMesa->Glide.grTexDownloadMipMapLevel( GR_TMU1,
				      t->range[TDFX_TMU1]->startAddr,
				      glideLod,
				      t->info.largeLodLog2,
				      t->info.aspectRatioLog2,
				      t->info.format,
				      GR_MIPMAPLEVELMASK_EVEN,
				      t->image[l].data );
	 }
      }
      break;

   case TDFX_TMU_BOTH:
      if ( t->range[TDFX_TMU0] && t->range[TDFX_TMU1] ) {
	 for ( l = t->minLevel ; l <= t->maxLevel && t->image[l].data ; l++ ) {
	    GrLOD_t glideLod = t->info.largeLodLog2 - l + tObj->BaseLevel;

	    fxMesa->Glide.grTexDownloadMipMapLevel( GR_TMU0,
				      t->range[TDFX_TMU0]->startAddr,
				      glideLod,
				      t->info.largeLodLog2,
				      t->info.aspectRatioLog2,
				      t->info.format,
				      GR_MIPMAPLEVELMASK_BOTH,
				      t->image[l].data );

	    fxMesa->Glide.grTexDownloadMipMapLevel( GR_TMU1,
				      t->range[TDFX_TMU1]->startAddr,
				      glideLod,
				      t->info.largeLodLog2,
				      t->info.aspectRatioLog2,
				      t->info.format,
				      GR_MIPMAPLEVELMASK_BOTH,
				      t->image[l].data );
	 }
      }
      break;

   default:
      gl_problem( NULL, "error in tdfxTMDownloadTexture: bad unit" );
      return;
   }
}


void tdfxTMReloadMipMapLevelLocked( GLcontext *ctx,
				    struct gl_texture_object *tObj,
				    GLint level )
{
   tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
   tdfxTexObjPtr t = TDFX_TEXTURE_DATA(tObj);
   GrLOD_t glideLod;
   FxU32 unit;

   ASSERT( t->isInTM );

   unit = t->whichTMU;
   glideLod =  t->info.largeLodLog2 - level + tObj->BaseLevel;

   switch ( unit ) {
   case TDFX_TMU0:
   case TDFX_TMU1:
      fxMesa->Glide.grTexDownloadMipMapLevel( unit,
				t->range[unit]->startAddr,
				glideLod,
				t->info.largeLodLog2,
				t->info.aspectRatioLog2,
				t->info.format,
				GR_MIPMAPLEVELMASK_BOTH,
				t->image[level].data );
      break;

   case TDFX_TMU_SPLIT:
      fxMesa->Glide.grTexDownloadMipMapLevel( GR_TMU0,
				t->range[GR_TMU0]->startAddr,
				glideLod,
				t->info.largeLodLog2,
				t->info.aspectRatioLog2,
				t->info.format,
				GR_MIPMAPLEVELMASK_ODD,
				t->image[level].data );

      fxMesa->Glide.grTexDownloadMipMapLevel( GR_TMU1,
				t->range[GR_TMU1]->startAddr,
				glideLod,
				t->info.largeLodLog2,
				t->info.aspectRatioLog2,
				t->info.format,
				GR_MIPMAPLEVELMASK_EVEN,
				t->image[level].data );
      break;

   case TDFX_TMU_BOTH:
      fxMesa->Glide.grTexDownloadMipMapLevel( GR_TMU0,
				t->range[GR_TMU0]->startAddr,
				glideLod,
				t->info.largeLodLog2,
				t->info.aspectRatioLog2,
				t->info.format,
				GR_MIPMAPLEVELMASK_BOTH,
				t->image[level].data );

      fxMesa->Glide.grTexDownloadMipMapLevel( GR_TMU1,
				t->range[GR_TMU1]->startAddr,
				glideLod,
				t->info.largeLodLog2,
				t->info.aspectRatioLog2,
				t->info.format,
				GR_MIPMAPLEVELMASK_BOTH,
				t->image[level].data );
      break;

   default:
      gl_problem( ctx, "error in tdfxTMReloadMipMapLevel(): wrong unit" );
      break;
   }
}


/* Allocate space for the given texture in texture memory then
 * download (copy) it into that space.
 */
void tdfxTMMoveInTMLocked( tdfxContextPtr fxMesa,
			    struct gl_texture_object *tObj, FxU32 targetTMU )
{
   tdfxTexObjPtr t = TDFX_TEXTURE_DATA(tObj);
   FxU32 size;

   fxMesa->stats.reqTexUpload++;

   if ( t->isInTM ) {
      if ( t->whichTMU == targetTMU )
	 return;

      if ( targetTMU == TDFX_TMU_SPLIT || t->whichTMU == TDFX_TMU_SPLIT ) {
	 tdfxTMMoveOutTMLocked( fxMesa, tObj );
      } else {
	 if ( t->whichTMU == TDFX_TMU_BOTH )
	    return;
	 targetTMU = TDFX_TMU_BOTH;
      }
   }

   t->whichTMU = targetTMU;

   switch ( targetTMU ) {
   case TDFX_TMU0:
   case TDFX_TMU1:
      size = fxMesa->Glide.grTexTextureMemRequired( GR_MIPMAPLEVELMASK_BOTH, &t->info );
      t->range[targetTMU] = tdfxTMAllocTexMem(fxMesa, targetTMU, size);
      break;

   case TDFX_TMU_SPLIT:
      size = fxMesa->Glide.grTexTextureMemRequired( GR_MIPMAPLEVELMASK_ODD, &t->info );
      t->range[TDFX_TMU0] = tdfxTMAllocTexMem( fxMesa, TDFX_TMU0, size );
      if ( t->range[TDFX_TMU0] )
	 fxMesa->stats.memTexUpload += size;

      size = fxMesa->Glide.grTexTextureMemRequired( GR_MIPMAPLEVELMASK_EVEN, &t->info );
      t->range[TDFX_TMU1] = tdfxTMAllocTexMem( fxMesa, TDFX_TMU1, size );
      break;

   case TDFX_TMU_BOTH:
      size = fxMesa->Glide.grTexTextureMemRequired( GR_MIPMAPLEVELMASK_BOTH, &t->info );
      t->range[TDFX_TMU0] = tdfxTMAllocTexMem( fxMesa, TDFX_TMU0, size );
      if ( t->range[TDFX_TMU0] )
	 fxMesa->stats.memTexUpload += size;

      size = fxMesa->Glide.grTexTextureMemRequired( GR_MIPMAPLEVELMASK_BOTH, &t->info );
      t->range[TDFX_TMU1] = tdfxTMAllocTexMem( fxMesa, TDFX_TMU1, size );
      break;

   default:
      gl_problem( NULL, "error in tdfxTMMoveInTM() -> bad unit (%d)" );
      return;
   }

   t->reloadImages = GL_TRUE;
   t->isInTM = GL_TRUE;

   fxMesa->stats.texUpload++;
}


/* Move the given texture out of hardware texture memory.
 * This deallocates the texture's memory space.
 */
void tdfxTMMoveOutTMLocked( tdfxContextPtr fxMesa,
			    struct gl_texture_object *tObj )
{
   struct gl_shared_state *ss = fxMesa->glCtx->Shared;
   tdfxSharedStatePtr tss = (tdfxSharedStatePtr)ss->DriverData;
   tdfxTexObjPtr t = TDFX_TEXTURE_DATA(tObj);

   if ( TDFX_DEBUG & DEBUG_VERBOSE_TEXTURE ) {
      fprintf( stderr, __FUNCTION__ "( %p (%d) )\n", tObj, tObj->Name );
      tdfxTMVerifyFreeList( fxMesa, 0 );
      tdfxTMVerifyFreeList( fxMesa, 1 );
   }

   if ( !t || !t->isInTM )
      return;

   switch ( t->whichTMU ) {
   case TDFX_TMU0:
   case TDFX_TMU1:
      tdfxTMRemoveRangeLocked( fxMesa, t->whichTMU, t->range[t->whichTMU] );
      break;

   case TDFX_TMU_SPLIT:
   case TDFX_TMU_BOTH:
      assert( !tss->umaTexMemory );
      tdfxTMRemoveRangeLocked( fxMesa, TDFX_TMU0, t->range[TDFX_TMU0] );
      tdfxTMRemoveRangeLocked( fxMesa, TDFX_TMU1, t->range[TDFX_TMU1] );
      break;

   default:
      gl_problem( NULL, "tdfx driver: bad unit in tdfxTMMOveOutTM()" );
      return;
   }

   t->isInTM = GL_FALSE;
   t->range[0] = NULL;
   t->range[1] = NULL;
   t->whichTMU = TDFX_TMU_NONE;

   if ( TDFX_DEBUG & DEBUG_VERBOSE_TEXTURE ) {
      tdfxTMVerifyFreeList( fxMesa, 0 );
      tdfxTMVerifyFreeList( fxMesa, 1 );
   }
}


void tdfxTMFreeTextureLocked( tdfxContextPtr fxMesa,
			      struct gl_texture_object *tObj )
{
   tdfxTexObjPtr t = TDFX_TEXTURE_DATA(tObj);

   if ( t ) {
      int i;
      tdfxTMMoveOutTMLocked( fxMesa, tObj );
      for ( i = 0 ; i < MAX_TEXTURE_LEVELS ; i++ ) {
	 if ( t->image[i].original.data ) FREE( t->image[i].original.data );
	 if ( t->image[i].rescaled.data ) FREE( t->image[i].rescaled.data );
      }
      FREE( t );
      tObj->DriverData = NULL;
   }

   if ( TDFX_DEBUG & DEBUG_VERBOSE_TEXTURE ) {
      tdfxTMVerifyFreeList( fxMesa, 0 );
      tdfxTMVerifyFreeList( fxMesa, 1 );
   }
}


/* After a context switch this function will be called to restore
 * texture memory for the new context.
 */
void tdfxTMRestoreTexturesLocked( tdfxContextPtr fxMesa )
{
   GLcontext *ctx = fxMesa->glCtx;
   struct gl_texture_object *tObj;
   int i;

   for ( tObj = ctx->Shared->TexObjectList ; tObj ; tObj = tObj->Next ) {
      tdfxTexObjPtr t = TDFX_TEXTURE_DATA( tObj );
      if ( t && t->isInTM ) {
	 for ( i = 0 ; i < MAX_TEXTURE_UNITS ; i++ ) {
	    if ( ctx->Texture.Unit[i].Current == tObj ) {
	       tdfxTMDownloadTextureLocked( fxMesa, tObj );
	       break;
	    }
	 }
	 if ( i == MAX_TEXTURE_UNITS ) {
	    tdfxTMMoveOutTMLocked( fxMesa, tObj );
	 }
      }
   }

   if ( TDFX_DEBUG & DEBUG_VERBOSE_TEXTURE ) {
      tdfxTMVerifyFreeList( fxMesa, 0 );
      tdfxTMVerifyFreeList( fxMesa, 1 );
   }
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d26 1
a26 1
/* $XFree86: xc/lib/GL/mesa/src/drv/tdfx/tdfx_texman.c,v 1.7 2004/01/23 03:57:07 dawes Exp $ */
d42 1
d44 1
a44 6
#define BAD_ADDRESS ((FxU32) -1)


#if 0 /* DEBUG use */
/*
 * Verify the consistancy of the texture memory manager.
d51 1
a51 2
static void
VerifyFreeList(tdfxContextPtr fxMesa, FxU32 tmu)
d53 20
a72 99
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    struct tdfxSharedState *shared = (struct tdfxSharedState *) mesaShared->DriverData;
    tdfxMemRange *block;
    int prevStart = -1, prevEnd = -1;
    int totalFree = 0;
    int numObj = 0, numRes = 0;
    int totalUsed = 0;

    for (block = shared->tmFree[tmu]; block; block = block->next) {
       assert( block->endAddr > 0 );
       assert( block->startAddr <= shared->totalTexMem[tmu] );
       assert( block->endAddr <= shared->totalTexMem[tmu] );
       assert( (int) block->startAddr > prevStart );
       assert( (int) block->startAddr >= prevEnd );
       prevStart = (int) block->startAddr;
       prevEnd = (int) block->endAddr;
       totalFree += (block->endAddr - block->startAddr);
    }
    assert(totalFree == shared->freeTexMem[tmu]);

    {
       struct gl_texture_object *obj;
       for (obj = mesaShared->TexObjectList; obj; obj = obj->Next) {
          tdfxTexInfo *ti = TDFX_TEXTURE_DATA(obj);
          numObj++;
          if (ti) {
             if (ti->isInTM) {
                numRes++;
                assert(ti->tm[0]);
                if (ti->tm[tmu])
                   totalUsed += (ti->tm[tmu]->endAddr - ti->tm[tmu]->startAddr);
             }
             else {
                assert(!ti->tm[0]);
             }
          }
       }
    }

    printf("totalFree: %d  totalUsed: %d  totalMem: %d #objs=%d  #res=%d\n",
           shared->freeTexMem[tmu], totalUsed, shared->totalTexMem[tmu],
           numObj, numRes);

    assert(totalUsed + totalFree == shared->totalTexMem[tmu]);
}


static void
dump_texmem(tdfxContextPtr fxMesa)
{
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    struct tdfxSharedState *shared = (struct tdfxSharedState *) mesaShared->DriverData;
    struct gl_texture_object *oldestObj, *obj, *lowestPriorityObj;
    tdfxMemRange *r;
    FxU32 prev;

    printf("DUMP Objects:\n");
    for (obj = mesaShared->TexObjectList; obj; obj = obj->Next) {
        tdfxTexInfo *info = TDFX_TEXTURE_DATA(obj);

        if (info && info->isInTM) {
        printf("Obj %8p: %4d  info = %p\n", obj, obj->Name, info);

           printf("  isInTM=%d  whichTMU=%d  lastTimeUsed=%d\n",
                  info->isInTM, info->whichTMU, info->lastTimeUsed);
           printf("    tm[0] = %p", info->tm[0]);
           assert(info->tm[0]);
           if (info->tm[0]) {
              printf("  tm startAddr = %d  endAddr = %d",
                     info->tm[0]->startAddr,
                     info->tm[0]->endAddr);
           }
           printf("\n");
           printf("    tm[1] = %p", info->tm[1]);
           if (info->tm[1]) {
              printf("  tm startAddr = %d  endAddr = %d",
                     info->tm[1]->startAddr,
                     info->tm[1]->endAddr);
           }
           printf("\n");
        }
    }

    VerifyFreeList(fxMesa, 0);
    VerifyFreeList(fxMesa, 1);

    printf("Free memory unit 0:  %d bytes\n", shared->freeTexMem[0]);
    prev = 0;
    for (r = shared->tmFree[0]; r; r = r->next) {
       printf("%8p:  start %8d  end %8d  size %8d  gap %8d\n", r, r->startAddr, r->endAddr, r->endAddr - r->startAddr, r->startAddr - prev);
       prev = r->endAddr;
    }

    printf("Free memory unit 1:  %d bytes\n", shared->freeTexMem[1]);
    prev = 0;
    for (r = shared->tmFree[1]; r; r = r->next) {
       printf("%8p:  start %8d  end %8d  size %8d  gap %8d\n", r, r->startAddr, r->endAddr, r->endAddr - r->startAddr, r->startAddr - prev);
       prev = r->endAddr;
    }
d74 78
a152 2
#endif

d156 1
a156 2
static void
fubar(void)
d158 1
d161 1
a161 2
/*
 * Sanity Check
d163 1
a163 2
static void
sanity(tdfxContextPtr fxMesa)
d165 21
a185 1
    tdfxMemRange *tmp, *prev, *pos;
d187 19
a205 38
    prev = 0;
    tmp = fxMesa->tmFree[0];
    while (tmp) {
        if (!tmp->startAddr && !tmp->endAddr) {
            fprintf(stderr, "Textures fubar\n");
            fubar();
        }
        if (tmp->startAddr >= tmp->endAddr) {
            fprintf(stderr, "Node fubar\n");
            fubar();
        }
        if (prev && (prev->startAddr >= tmp->startAddr ||
                     prev->endAddr > tmp->startAddr)) {
            fprintf(stderr, "Sorting fubar\n");
            fubar();
        }
        prev = tmp;
        tmp = tmp->next;
    }
    prev = 0;
    tmp = fxMesa->tmFree[1];
    while (tmp) {
        if (!tmp->startAddr && !tmp->endAddr) {
            fprintf(stderr, "Textures fubar\n");
            fubar();
        }
        if (tmp->startAddr >= tmp->endAddr) {
            fprintf(stderr, "Node fubar\n");
            fubar();
        }
        if (prev && (prev->startAddr >= tmp->startAddr ||
                     prev->endAddr > tmp->startAddr)) {
            fprintf(stderr, "Sorting fubar\n");
            fubar();
        }
        prev = tmp;
        tmp = tmp->next;
    }
d210 2
a211 6



/*
 * Allocate and initialize a new MemRange struct.
 * Try to allocate it from the pool of free MemRange nodes rather than malloc.
d214 1
a214 1
NewRangeNode(tdfxContextPtr fxMesa, FxU32 start, FxU32 end)
d216 22
a237 23
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    struct tdfxSharedState *shared = (struct tdfxSharedState *) mesaShared->DriverData;
    tdfxMemRange *result;

    _glthread_LOCK_MUTEX(mesaShared->Mutex);
    if (shared && shared->tmPool) {
        result = shared->tmPool;
        shared->tmPool = shared->tmPool->next;
    }
    else {
        result = MALLOC(sizeof(tdfxMemRange));

    }
    _glthread_UNLOCK_MUTEX(mesaShared->Mutex);

    if (!result) {
        /*fprintf(stderr, "fxDriver: out of memory!\n");*/
        return NULL;
    }

    result->startAddr = start;
    result->endAddr = end;
    result->next = NULL;
d239 1
a239 1
    return result;
d243 1
a243 3
/*
 * Initialize texture memory.
 * We take care of one or both TMU's here.
d245 1
a245 2
void
tdfxTMInit(tdfxContextPtr fxMesa)
d247 64
a310 45
    if (!fxMesa->glCtx->Shared->DriverData) {
        const char *extensions;
        struct tdfxSharedState *shared = CALLOC_STRUCT(tdfxSharedState);
        if (!shared)
           return;

        LOCK_HARDWARE(fxMesa);
        extensions = fxMesa->Glide.grGetString(GR_EXTENSION);
        UNLOCK_HARDWARE(fxMesa);
        if (strstr(extensions, "TEXUMA")) {
            FxU32 start, end;
            shared->umaTexMemory = GL_TRUE;
            LOCK_HARDWARE(fxMesa);
            fxMesa->Glide.grEnable(GR_TEXTURE_UMA_EXT);
            start = fxMesa->Glide.grTexMinAddress(0);
            end = fxMesa->Glide.grTexMaxAddress(0);
            UNLOCK_HARDWARE(fxMesa);
            shared->totalTexMem[0] = end - start;
            shared->totalTexMem[1] = 0;
            shared->freeTexMem[0] = end - start;
            shared->freeTexMem[1] = 0;
            shared->tmFree[0] = NewRangeNode(fxMesa, start, end);
            shared->tmFree[1] = NULL;
            /*printf("UMA tex memory: %d\n", (int) (end - start));*/
        }
        else {
            const int numTMUs = fxMesa->haveTwoTMUs ? 2 : 1;
            int tmu;
            shared->umaTexMemory = GL_FALSE;
            LOCK_HARDWARE(fxMesa);
            for (tmu = 0; tmu < numTMUs; tmu++) {
                FxU32 start = fxMesa->Glide.grTexMinAddress(tmu);
                FxU32 end = fxMesa->Glide.grTexMaxAddress(tmu);
                shared->totalTexMem[tmu] = end - start;
                shared->freeTexMem[tmu] = end - start;
                shared->tmFree[tmu] = NewRangeNode(fxMesa, start, end);
                /*printf("Split tex memory: %d\n", (int) (end - start));*/
            }
            UNLOCK_HARDWARE(fxMesa);
        }

        shared->tmPool = NULL;
        fxMesa->glCtx->Shared->DriverData = shared;
        /*printf("Texture memory init UMA: %d\n", shared->umaTexMemory);*/
    }
d314 1
a314 2
/*
 * Clean-up texture memory before destroying context.
d316 1
a316 2
void
tdfxTMClose(tdfxContextPtr fxMesa)
d318 29
a346 29
    if (fxMesa->glCtx->Shared->RefCount == 1 && fxMesa->driDrawable) {
        /* refcount will soon go to zero, free our 3dfx stuff */
        struct tdfxSharedState *shared = (struct tdfxSharedState *) fxMesa->glCtx->Shared->DriverData;

        const int numTMUs = fxMesa->haveTwoTMUs ? 2 : 1;
        int tmu;
        tdfxMemRange *tmp, *next;

        /* Deallocate the pool of free tdfxMemRange nodes */
        tmp = shared->tmPool;
        while (tmp) {
            next = tmp->next;
            FREE(tmp);
            tmp = next;
        }

        /* Delete the texture memory block tdfxMemRange nodes */
        for (tmu = 0; tmu < numTMUs; tmu++) {
            tmp = shared->tmFree[tmu];
            while (tmp) {
                next = tmp->next;
                FREE(tmp);
                tmp = next;
            }
        }

        FREE(shared);
        fxMesa->glCtx->Shared->DriverData = NULL;
    }
d351 1
a351 2
/*
 * Delete a tdfxMemRange struct.
d355 5
a359 9
#if 0
static void
DeleteRangeNode_NoLock(struct TdfxSharedState *shared, tdfxMemRange *range)
{
    /* insert at head of list */
    range->next = shared->tmPool;
    shared->tmPool = range;
}
#endif
d361 1
a361 8
#define DELETE_RANGE_NODE(shared, range) \
    (range)->next = (shared)->tmPool;    \
    (shared)->tmPool = (range)



/*
 * When we've run out of texture memory we have to throw out an
d366 1
a366 1
FindOldestObject(tdfxContextPtr fxMesa, FxU32 tmu)
d368 58
a425 70
    const GLuint bindnumber = fxMesa->texBindNumber;
    struct gl_texture_object *oldestObj, *obj, *lowestPriorityObj;
    GLfloat lowestPriority;
    GLuint oldestAge;

    oldestObj = NULL;
    oldestAge = 0;

    lowestPriority = 1.0F;
    lowestPriorityObj = NULL;

    for (obj = fxMesa->glCtx->Shared->TexObjectList; obj; obj = obj->Next) {
        tdfxTexInfo *info = TDFX_TEXTURE_DATA(obj);

        if (info && info->isInTM &&
            ((info->whichTMU == tmu) || (info->whichTMU == TDFX_TMU_BOTH) ||
             (info->whichTMU == TDFX_TMU_SPLIT))) {
            GLuint age, lasttime;

            assert(info->tm[0]);
            lasttime = info->lastTimeUsed;

            if (lasttime > bindnumber)
                age = bindnumber + (UINT_MAX - lasttime + 1); /* TO DO: check wrap around */
            else
                age = bindnumber - lasttime;

            if (age >= oldestAge) {
                oldestAge = age;
                oldestObj = obj;
            }

            /* examine priority */
            if (obj->Priority < lowestPriority) {
                lowestPriority = obj->Priority;
                lowestPriorityObj = obj;
            }
        }
    }

    if (lowestPriority < 1.0) {
        ASSERT(lowestPriorityObj);
        /*
        printf("discard %d pri=%f\n", lowestPriorityObj->Name, lowestPriority);
        */
        return lowestPriorityObj;
    }
    else {
        /*
        printf("discard %d age=%d\n", oldestObj->Name, oldestAge);
        */
        return oldestObj;
    }
}


#if 0
static void
FlushTexMemory(tdfxContextPtr fxMesa)
{
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    struct tdfxSharedState *shared = (struct tdfxSharedState *) mesaShared->DriverData;
    struct gl_texture_object *obj;

    for (obj = mesaShared->TexObjectList; obj; obj = obj->Next) {
       if (obj->RefCount < 2) {
          /* don't flush currently bound textures */
          tdfxTMMoveOutTM_NoLock(fxMesa, obj);
       }
    }
a426 1
#endif
d429 2
a430 3
/*
 * Find the address (offset?) at which we can store a new texture.
 * <tmu> is the texture unit.
d433 2
a434 2
static FxU32
FindStartAddr(tdfxContextPtr fxMesa, FxU32 tmu, FxU32 size)
d436 50
a485 8
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    struct tdfxSharedState *shared = (struct tdfxSharedState *) mesaShared->DriverData;
    tdfxMemRange *prev, *block;
    FxU32 result;
#if 0
    int discardedCount = 0;
#define MAX_DISCARDS 10
#endif
d487 3
a489 63
    if (shared->umaTexMemory) {
        assert(tmu == TDFX_TMU0);
    }

    _glthread_LOCK_MUTEX(mesaShared->Mutex);
    while (1) {
        prev = NULL;
        block = shared->tmFree[tmu];
        while (block) {
            if (block->endAddr - block->startAddr >= size) {
                /* The texture will fit here */
                result = block->startAddr;
                block->startAddr += size;
                if (block->startAddr == block->endAddr) {
                    /* Remove this node since it's empty */
                    if (prev) {
                        prev->next = block->next;
                    }
                    else {
                        shared->tmFree[tmu] = block->next;
                    }
                    DELETE_RANGE_NODE(shared, block);
                }
                shared->freeTexMem[tmu] -= size;
                _glthread_UNLOCK_MUTEX(mesaShared->Mutex);
                return result;
            }
            prev = block;
            block = block->next;
        }
        /* We failed to find a block large enough to accomodate <size> bytes.
         * Find the oldest texObject and free it.
         */
#if 0
        discardedCount++;
        if (discardedCount > MAX_DISCARDS + 1) {
            _mesa_problem(NULL, "%s: extreme texmem fragmentation", __FUNCTION__);
            _glthread_UNLOCK_MUTEX(mesaShared->Mutex);
            return BAD_ADDRESS;
        }
        else if (discardedCount > MAX_DISCARDS) {
            /* texture memory is probably really fragmented, flush it */
            FlushTexMemory(fxMesa);
        }
        else
#endif
        {
            struct gl_texture_object *obj = FindOldestObject(fxMesa, tmu);
            if (obj) {
                tdfxTMMoveOutTM_NoLock(fxMesa, obj);
                fxMesa->stats.texSwaps++;
            }
            else {
                _mesa_problem(NULL, "%s: extreme texmem fragmentation", __FUNCTION__);
                _glthread_UNLOCK_MUTEX(mesaShared->Mutex);
                return BAD_ADDRESS;
            }
        }
    }

    /* never get here, but play it safe */
    _glthread_UNLOCK_MUTEX(mesaShared->Mutex);
    return BAD_ADDRESS;
d493 1
a493 2
/*
 * Remove the given tdfxMemRange node from hardware texture memory.
d495 2
a496 2
static void
RemoveRange_NoLock(tdfxContextPtr fxMesa, FxU32 tmu, tdfxMemRange *range)
d498 52
a549 66
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    struct tdfxSharedState *shared = (struct tdfxSharedState *) mesaShared->DriverData;
    tdfxMemRange *block, *prev;

    if (shared->umaTexMemory) {
       assert(tmu == TDFX_TMU0);
    }

    if (!range)
        return;

    if (range->startAddr == range->endAddr) {
        DELETE_RANGE_NODE(shared, range);
        return;
    }
    shared->freeTexMem[tmu] += range->endAddr - range->startAddr;

    /* find position in linked list to insert this tdfxMemRange node */
    prev = NULL;
    block = shared->tmFree[tmu];
    while (block) {
        assert(range->startAddr != block->startAddr);
        if (range->startAddr > block->startAddr) {
            prev = block;
            block = block->next;
        }
        else {
            break;
        }
    }

    /* Insert the free block, combine with adjacent blocks when possible */
    range->next = block;
    if (block) {
        if (range->endAddr == block->startAddr) {
            /* Combine */
            block->startAddr = range->startAddr;
            DELETE_RANGE_NODE(shared, range);
            range = block;
        }
    }
    if (prev) {
        if (prev->endAddr == range->startAddr) {
            /* Combine */
            prev->endAddr = range->endAddr;
            prev->next = range->next;
            DELETE_RANGE_NODE(shared, range);
        }
        else {
            prev->next = range;
        }
    }
    else {
        shared->tmFree[tmu] = range;
    }
}


#if 0 /* NOT USED */
static void
RemoveRange(tdfxContextPtr fxMesa, FxU32 tmu, tdfxMemRange *range)
{
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    _glthread_LOCK_MUTEX(mesaShared->Mutex);
    RemoveRange_NoLock(fxMesa, tmu, range);
    _glthread_UNLOCK_MUTEX(mesaShared->Mutex);
a550 1
#endif
d553 1
a553 2
/*
 * Allocate space for a texture image.
d558 1
a558 1
AllocTexMem(tdfxContextPtr fxMesa, FxU32 tmu, FxU32 texmemsize)
d560 107
a666 12
    FxU32 startAddr;
    startAddr = FindStartAddr(fxMesa, tmu, texmemsize);
    if (startAddr == BAD_ADDRESS) {
        _mesa_problem(fxMesa->glCtx, "%s returned NULL!  tmu=%d texmemsize=%d",
               __FUNCTION__, (int) tmu, (int) texmemsize);
        return NULL;
    }
    else {
        tdfxMemRange *range;
        range = NewRangeNode(fxMesa, startAddr, startAddr + texmemsize);
        return range;
    }
d670 71
a740 163
/*
 * Download (copy) the given texture data (all mipmap levels) into the
 * Voodoo's texture memory.
 * The texture memory must have already been allocated.
 */
void
tdfxTMDownloadTexture(tdfxContextPtr fxMesa, struct gl_texture_object *tObj)
{
    tdfxTexInfo *ti;
    GLint l;
    FxU32 targetTMU;

    assert(tObj);
    ti = TDFX_TEXTURE_DATA(tObj);
    assert(ti);
    targetTMU = ti->whichTMU;

    switch (targetTMU) {
    case TDFX_TMU0:
    case TDFX_TMU1:
        if (ti->tm[targetTMU]) {
            for (l = ti->minLevel; l <= ti->maxLevel
                    && tObj->Image[l]->Data; l++) {
                GrLOD_t glideLod = ti->info.largeLodLog2 - l + tObj->BaseLevel;
                fxMesa->Glide.grTexDownloadMipMapLevel(targetTMU,
                                                  ti->tm[targetTMU]->startAddr,
                                                  glideLod,
                                                  ti->info.largeLodLog2,
                                                  ti->info.aspectRatioLog2,
                                                  ti->info.format,
                                                  GR_MIPMAPLEVELMASK_BOTH,
                                                  tObj->Image[l]->Data);
            }
        }
        break;
    case TDFX_TMU_SPLIT:
        if (ti->tm[TDFX_TMU0] && ti->tm[TDFX_TMU1]) {
            for (l = ti->minLevel; l <= ti->maxLevel
                    && tObj->Image[l]->Data; l++) {
                GrLOD_t glideLod = ti->info.largeLodLog2 - l + tObj->BaseLevel;
                fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU0,
                                                  ti->tm[TDFX_TMU0]->startAddr,
                                                  glideLod,
                                                  ti->info.largeLodLog2,
                                                  ti->info.aspectRatioLog2,
                                                  ti->info.format,
                                                  GR_MIPMAPLEVELMASK_ODD,
                                                  tObj->Image[l]->Data);

                fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU1,
                                                  ti->tm[TDFX_TMU1]->startAddr,
                                                  glideLod,
                                                  ti->info.largeLodLog2,
                                                  ti->info.aspectRatioLog2,
                                                  ti->info.format,
                                                  GR_MIPMAPLEVELMASK_EVEN,
                                                  tObj->Image[l]->Data);
            }
        }
        break;
    case TDFX_TMU_BOTH:
        if (ti->tm[TDFX_TMU0] && ti->tm[TDFX_TMU1]) {
            for (l = ti->minLevel; l <= ti->maxLevel
                    && tObj->Image[l]->Data; l++) {
                GrLOD_t glideLod = ti->info.largeLodLog2 - l + tObj->BaseLevel;
                fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU0,
                                                  ti->tm[TDFX_TMU0]->startAddr,
                                                  glideLod,
                                                  ti->info.largeLodLog2,
                                                  ti->info.aspectRatioLog2,
                                                  ti->info.format,
                                                  GR_MIPMAPLEVELMASK_BOTH,
                                                  tObj->Image[l]->Data);

                fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU1,
                                                  ti->tm[TDFX_TMU1]->startAddr,
                                                  glideLod,
                                                  ti->info.largeLodLog2,
                                                  ti->info.aspectRatioLog2,
                                                  ti->info.format,
                                                  GR_MIPMAPLEVELMASK_BOTH,
                                                  tObj->Image[l]->Data);
            }
        }
        break;
    default:
        _mesa_problem(NULL, "%s: bad tmu (%d)", __FUNCTION__, (int)targetTMU);
        return;
    }
}


void
tdfxTMReloadMipMapLevel(GLcontext *ctx, struct gl_texture_object *tObj,
                        GLint level)
{
    tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
    tdfxTexInfo *ti = TDFX_TEXTURE_DATA(tObj);
    GrLOD_t glideLod;
    FxU32 tmu;

    tmu = ti->whichTMU;
    glideLod =  ti->info.largeLodLog2 - level + tObj->BaseLevel;
    ASSERT(ti->isInTM);

    LOCK_HARDWARE(fxMesa);

    switch (tmu) {
    case TDFX_TMU0:
    case TDFX_TMU1:
        fxMesa->Glide.grTexDownloadMipMapLevel(tmu,
                                    ti->tm[tmu]->startAddr,
                                    glideLod,
                                    ti->info.largeLodLog2,
                                    ti->info.aspectRatioLog2,
                                    ti->info.format,
                                    GR_MIPMAPLEVELMASK_BOTH,
                                    tObj->Image[level]->Data);
        break;
    case TDFX_TMU_SPLIT:
        fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU0,
                                    ti->tm[GR_TMU0]->startAddr,
                                    glideLod,
                                    ti->info.largeLodLog2,
                                    ti->info.aspectRatioLog2,
                                    ti->info.format,
                                    GR_MIPMAPLEVELMASK_ODD,
                                    tObj->Image[level]->Data);

        fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU1,
                                    ti->tm[GR_TMU1]->startAddr,
                                    glideLod,
                                    ti->info.largeLodLog2,
                                    ti->info.aspectRatioLog2,
                                    ti->info.format,
                                    GR_MIPMAPLEVELMASK_EVEN,
                                    tObj->Image[level]->Data);
        break;
    case TDFX_TMU_BOTH:
        fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU0,
                                    ti->tm[GR_TMU0]->startAddr,
                                    glideLod,
                                    ti->info.largeLodLog2,
                                    ti->info.aspectRatioLog2,
                                    ti->info.format,
                                    GR_MIPMAPLEVELMASK_BOTH,
                                    tObj->Image[level]->Data);

        fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU1,
                                    ti->tm[GR_TMU1]->startAddr,
                                    glideLod,
                                    ti->info.largeLodLog2,
                                    ti->info.aspectRatioLog2,
                                    ti->info.format,
                                    GR_MIPMAPLEVELMASK_BOTH,
                                    tObj->Image[level]->Data);
        break;

    default:
        _mesa_problem(ctx, "%s: bad tmu (%d)", __FUNCTION__, (int)tmu);
        break;
    }
    UNLOCK_HARDWARE(fxMesa);
d744 1
a744 2
/*
 * Allocate space for the given texture in texture memory then
d747 5
a751 57
void
tdfxTMMoveInTM_NoLock( tdfxContextPtr fxMesa, struct gl_texture_object *tObj,
                       FxU32 targetTMU )
{
    tdfxTexInfo *ti = TDFX_TEXTURE_DATA(tObj);
    FxU32 texmemsize;

    fxMesa->stats.reqTexUpload++;

    if (ti->isInTM) {
        if (ti->whichTMU == targetTMU)
            return;
        if (targetTMU == TDFX_TMU_SPLIT || ti->whichTMU == TDFX_TMU_SPLIT) {
            tdfxTMMoveOutTM_NoLock(fxMesa, tObj);
        }
        else {
            if (ti->whichTMU == TDFX_TMU_BOTH)
                return;
            targetTMU = TDFX_TMU_BOTH;
        }
    }

    ti->whichTMU = targetTMU;

    switch (targetTMU) {
    case TDFX_TMU0:
    case TDFX_TMU1:
        texmemsize = fxMesa->Glide.grTexTextureMemRequired(GR_MIPMAPLEVELMASK_BOTH,
                                                       &(ti->info));
        ti->tm[targetTMU] = AllocTexMem(fxMesa, targetTMU, texmemsize);
        break;
    case TDFX_TMU_SPLIT:
        texmemsize = fxMesa->Glide.grTexTextureMemRequired(GR_MIPMAPLEVELMASK_ODD,
                                                       &(ti->info));
        ti->tm[TDFX_TMU0] = AllocTexMem(fxMesa, TDFX_TMU0, texmemsize);
        if (ti->tm[TDFX_TMU0])
           fxMesa->stats.memTexUpload += texmemsize;

        texmemsize = fxMesa->Glide.grTexTextureMemRequired(GR_MIPMAPLEVELMASK_EVEN,
                                                       &(ti->info));
        ti->tm[TDFX_TMU1] = AllocTexMem(fxMesa, TDFX_TMU1, texmemsize);
        break;
    case TDFX_TMU_BOTH:
        texmemsize = fxMesa->Glide.grTexTextureMemRequired(GR_MIPMAPLEVELMASK_BOTH,
                                                       &(ti->info));
        ti->tm[TDFX_TMU0] = AllocTexMem(fxMesa, TDFX_TMU0, texmemsize);
        if (ti->tm[TDFX_TMU0])
           fxMesa->stats.memTexUpload += texmemsize;

        texmemsize = fxMesa->Glide.grTexTextureMemRequired(GR_MIPMAPLEVELMASK_BOTH,
                                                       &(ti->info));
        ti->tm[TDFX_TMU1] = AllocTexMem(fxMesa, TDFX_TMU1, texmemsize);
        break;
    default:
        _mesa_problem(NULL, "%s: bad tmu (%d)", __FUNCTION__, (int)targetTMU);
        return;
    }
d753 1
a753 2
    ti->reloadImages = GL_TRUE;
    ti->isInTM = GL_TRUE;
d755 51
a805 1
    fxMesa->stats.texUpload++;
d809 1
a809 2
/*
 * Move the given texture out of hardware texture memory.
d812 2
a813 2
void
tdfxTMMoveOutTM_NoLock( tdfxContextPtr fxMesa, struct gl_texture_object *tObj )
d815 40
a854 41
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    struct tdfxSharedState *shared = (struct tdfxSharedState *) mesaShared->DriverData;
    tdfxTexInfo *ti = TDFX_TEXTURE_DATA(tObj);

    if (MESA_VERBOSE & VERBOSE_DRIVER) {
        fprintf(stderr, "fxmesa: %s(%p (%d))\n", __FUNCTION__, (void *)tObj, tObj->Name);
    }

    /*
    VerifyFreeList(fxMesa, 0);
    VerifyFreeList(fxMesa, 1);
    */

    if (!ti || !ti->isInTM)
        return;

    switch (ti->whichTMU) {
    case TDFX_TMU0:
    case TDFX_TMU1:
        RemoveRange_NoLock(fxMesa, ti->whichTMU, ti->tm[ti->whichTMU]);
        break;
    case TDFX_TMU_SPLIT:
    case TDFX_TMU_BOTH:
        assert(!shared->umaTexMemory);
        RemoveRange_NoLock(fxMesa, TDFX_TMU0, ti->tm[TDFX_TMU0]);
        RemoveRange_NoLock(fxMesa, TDFX_TMU1, ti->tm[TDFX_TMU1]);
        break;
    default:
        _mesa_problem(NULL, "%s: bad tmu (%d)", __FUNCTION__, (int)ti->whichTMU);
        return;
    }

    ti->isInTM = GL_FALSE;
    ti->tm[0] = NULL;
    ti->tm[1] = NULL;
    ti->whichTMU = TDFX_TMU_NONE;

    /*
    VerifyFreeList(fxMesa, 0);
    VerifyFreeList(fxMesa, 1);
    */
d858 2
a859 5
/*
 * Called via glDeleteTexture to delete a texture object.
 */
void
tdfxTMFreeTexture(tdfxContextPtr fxMesa, struct gl_texture_object *tObj)
d861 17
a877 10
    tdfxTexInfo *ti = TDFX_TEXTURE_DATA(tObj);
    if (ti) {
        tdfxTMMoveOutTM(fxMesa, tObj);
        FREE(ti);
        tObj->DriverData = NULL;
    }
    /*
    VerifyFreeList(fxMesa, 0);
    VerifyFreeList(fxMesa, 1);
    */
d881 1
a881 3

/*
 * After a context switch this function will be called to restore
d884 1
a884 1
void tdfxTMRestoreTextures_NoLock( tdfxContextPtr fxMesa )
d891 2
a892 2
      tdfxTexInfo *ti = TDFX_TEXTURE_DATA( tObj );
      if ( ti && ti->isInTM ) {
d894 2
a895 2
	    if ( ctx->Texture.Unit[i]._Current == tObj ) {
	       tdfxTMDownloadTexture( fxMesa, tObj );
d900 1
a900 1
	    tdfxTMMoveOutTM_NoLock( fxMesa, tObj );
d904 5
a908 4
   /*
   VerifyFreeList(fxMesa, 0);
   VerifyFreeList(fxMesa, 1);
   */
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d26 1
a26 1
/* $XFree86: xc/lib/GL/mesa/src/drv/tdfx/tdfx_texman.c,v 1.5 2002/02/22 21:45:04 dawes Exp $ */
d42 1
d44 1
a44 6
#define BAD_ADDRESS ((FxU32) -1)


#if 0 /* DEBUG use */
/*
 * Verify the consistancy of the texture memory manager.
d51 1
a51 2
static void
VerifyFreeList(tdfxContextPtr fxMesa, FxU32 tmu)
d53 20
a72 99
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    struct tdfxSharedState *shared = (struct tdfxSharedState *) mesaShared->DriverData;
    tdfxMemRange *block;
    int prevStart = -1, prevEnd = -1;
    int totalFree = 0;
    int numObj = 0, numRes = 0;
    int totalUsed = 0;

    for (block = shared->tmFree[tmu]; block; block = block->next) {
       assert( block->endAddr > 0 );
       assert( block->startAddr <= shared->totalTexMem[tmu] );
       assert( block->endAddr <= shared->totalTexMem[tmu] );
       assert( (int) block->startAddr > prevStart );
       assert( (int) block->startAddr >= prevEnd );
       prevStart = (int) block->startAddr;
       prevEnd = (int) block->endAddr;
       totalFree += (block->endAddr - block->startAddr);
    }
    assert(totalFree == shared->freeTexMem[tmu]);

    {
       struct gl_texture_object *obj;
       for (obj = mesaShared->TexObjectList; obj; obj = obj->Next) {
          tdfxTexInfo *ti = TDFX_TEXTURE_DATA(obj);
          numObj++;
          if (ti) {
             if (ti->isInTM) {
                numRes++;
                assert(ti->tm[0]);
                if (ti->tm[tmu])
                   totalUsed += (ti->tm[tmu]->endAddr - ti->tm[tmu]->startAddr);
             }
             else {
                assert(!ti->tm[0]);
             }
          }
       }
    }

    printf("totalFree: %d  totalUsed: %d  totalMem: %d #objs=%d  #res=%d\n",
           shared->freeTexMem[tmu], totalUsed, shared->totalTexMem[tmu],
           numObj, numRes);

    assert(totalUsed + totalFree == shared->totalTexMem[tmu]);
}


static void
dump_texmem(tdfxContextPtr fxMesa)
{
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    struct tdfxSharedState *shared = (struct tdfxSharedState *) mesaShared->DriverData;
    struct gl_texture_object *oldestObj, *obj, *lowestPriorityObj;
    tdfxMemRange *r;
    FxU32 prev;

    printf("DUMP Objects:\n");
    for (obj = mesaShared->TexObjectList; obj; obj = obj->Next) {
        tdfxTexInfo *info = TDFX_TEXTURE_DATA(obj);

        if (info && info->isInTM) {
        printf("Obj %8p: %4d  info = %p\n", obj, obj->Name, info);

           printf("  isInTM=%d  whichTMU=%d  lastTimeUsed=%d\n",
                  info->isInTM, info->whichTMU, info->lastTimeUsed);
           printf("    tm[0] = %p", info->tm[0]);
           assert(info->tm[0]);
           if (info->tm[0]) {
              printf("  tm startAddr = %d  endAddr = %d",
                     info->tm[0]->startAddr,
                     info->tm[0]->endAddr);
           }
           printf("\n");
           printf("    tm[1] = %p", info->tm[1]);
           if (info->tm[1]) {
              printf("  tm startAddr = %d  endAddr = %d",
                     info->tm[1]->startAddr,
                     info->tm[1]->endAddr);
           }
           printf("\n");
        }
    }

    VerifyFreeList(fxMesa, 0);
    VerifyFreeList(fxMesa, 1);

    printf("Free memory unit 0:  %d bytes\n", shared->freeTexMem[0]);
    prev = 0;
    for (r = shared->tmFree[0]; r; r = r->next) {
       printf("%8p:  start %8d  end %8d  size %8d  gap %8d\n", r, r->startAddr, r->endAddr, r->endAddr - r->startAddr, r->startAddr - prev);
       prev = r->endAddr;
    }

    printf("Free memory unit 1:  %d bytes\n", shared->freeTexMem[1]);
    prev = 0;
    for (r = shared->tmFree[1]; r; r = r->next) {
       printf("%8p:  start %8d  end %8d  size %8d  gap %8d\n", r, r->startAddr, r->endAddr, r->endAddr - r->startAddr, r->startAddr - prev);
       prev = r->endAddr;
    }
d74 78
a152 2
#endif

d156 1
a156 2
static void
fubar(void)
d158 1
d161 1
a161 2
/*
 * Sanity Check
d163 1
a163 2
static void
sanity(tdfxContextPtr fxMesa)
d165 21
a185 1
    tdfxMemRange *tmp, *prev, *pos;
d187 19
a205 38
    prev = 0;
    tmp = fxMesa->tmFree[0];
    while (tmp) {
        if (!tmp->startAddr && !tmp->endAddr) {
            fprintf(stderr, "Textures fubar\n");
            fubar();
        }
        if (tmp->startAddr >= tmp->endAddr) {
            fprintf(stderr, "Node fubar\n");
            fubar();
        }
        if (prev && (prev->startAddr >= tmp->startAddr ||
                     prev->endAddr > tmp->startAddr)) {
            fprintf(stderr, "Sorting fubar\n");
            fubar();
        }
        prev = tmp;
        tmp = tmp->next;
    }
    prev = 0;
    tmp = fxMesa->tmFree[1];
    while (tmp) {
        if (!tmp->startAddr && !tmp->endAddr) {
            fprintf(stderr, "Textures fubar\n");
            fubar();
        }
        if (tmp->startAddr >= tmp->endAddr) {
            fprintf(stderr, "Node fubar\n");
            fubar();
        }
        if (prev && (prev->startAddr >= tmp->startAddr ||
                     prev->endAddr > tmp->startAddr)) {
            fprintf(stderr, "Sorting fubar\n");
            fubar();
        }
        prev = tmp;
        tmp = tmp->next;
    }
d210 2
a211 6



/*
 * Allocate and initialize a new MemRange struct.
 * Try to allocate it from the pool of free MemRange nodes rather than malloc.
d214 1
a214 1
NewRangeNode(tdfxContextPtr fxMesa, FxU32 start, FxU32 end)
d216 22
a237 23
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    struct tdfxSharedState *shared = (struct tdfxSharedState *) mesaShared->DriverData;
    tdfxMemRange *result;

    _glthread_LOCK_MUTEX(mesaShared->Mutex);
    if (shared && shared->tmPool) {
        result = shared->tmPool;
        shared->tmPool = shared->tmPool->next;
    }
    else {
        result = MALLOC(sizeof(tdfxMemRange));

    }
    _glthread_UNLOCK_MUTEX(mesaShared->Mutex);

    if (!result) {
        /*fprintf(stderr, "fxDriver: out of memory!\n");*/
        return NULL;
    }

    result->startAddr = start;
    result->endAddr = end;
    result->next = NULL;
d239 1
a239 1
    return result;
d243 1
a243 3
/*
 * Initialize texture memory.
 * We take care of one or both TMU's here.
d245 1
a245 2
void
tdfxTMInit(tdfxContextPtr fxMesa)
d247 64
a310 45
    if (!fxMesa->glCtx->Shared->DriverData) {
        const char *extensions;
        struct tdfxSharedState *shared = CALLOC_STRUCT(tdfxSharedState);
        if (!shared)
           return;

        LOCK_HARDWARE(fxMesa);
        extensions = fxMesa->Glide.grGetString(GR_EXTENSION);
        UNLOCK_HARDWARE(fxMesa);
        if (strstr(extensions, "TEXUMA")) {
            FxU32 start, end;
            shared->umaTexMemory = GL_TRUE;
            LOCK_HARDWARE(fxMesa);
            fxMesa->Glide.grEnable(GR_TEXTURE_UMA_EXT);
            start = fxMesa->Glide.grTexMinAddress(0);
            end = fxMesa->Glide.grTexMaxAddress(0);
            UNLOCK_HARDWARE(fxMesa);
            shared->totalTexMem[0] = end - start;
            shared->totalTexMem[1] = 0;
            shared->freeTexMem[0] = end - start;
            shared->freeTexMem[1] = 0;
            shared->tmFree[0] = NewRangeNode(fxMesa, start, end);
            shared->tmFree[1] = NULL;
            /*printf("UMA tex memory: %d\n", (int) (end - start));*/
        }
        else {
            const int numTMUs = fxMesa->haveTwoTMUs ? 2 : 1;
            int tmu;
            shared->umaTexMemory = GL_FALSE;
            LOCK_HARDWARE(fxMesa);
            for (tmu = 0; tmu < numTMUs; tmu++) {
                FxU32 start = fxMesa->Glide.grTexMinAddress(tmu);
                FxU32 end = fxMesa->Glide.grTexMaxAddress(tmu);
                shared->totalTexMem[tmu] = end - start;
                shared->freeTexMem[tmu] = end - start;
                shared->tmFree[tmu] = NewRangeNode(fxMesa, start, end);
                /*printf("Split tex memory: %d\n", (int) (end - start));*/
            }
            UNLOCK_HARDWARE(fxMesa);
        }

        shared->tmPool = NULL;
        fxMesa->glCtx->Shared->DriverData = shared;
        /*printf("Texture memory init UMA: %d\n", shared->umaTexMemory);*/
    }
d314 1
a314 2
/*
 * Clean-up texture memory before destroying context.
d316 1
a316 2
void
tdfxTMClose(tdfxContextPtr fxMesa)
d318 29
a346 29
    if (fxMesa->glCtx->Shared->RefCount == 1 && fxMesa->driDrawable) {
        /* refcount will soon go to zero, free our 3dfx stuff */
        struct tdfxSharedState *shared = (struct tdfxSharedState *) fxMesa->glCtx->Shared->DriverData;

        const int numTMUs = fxMesa->haveTwoTMUs ? 2 : 1;
        int tmu;
        tdfxMemRange *tmp, *next;

        /* Deallocate the pool of free tdfxMemRange nodes */
        tmp = shared->tmPool;
        while (tmp) {
            next = tmp->next;
            FREE(tmp);
            tmp = next;
        }

        /* Delete the texture memory block tdfxMemRange nodes */
        for (tmu = 0; tmu < numTMUs; tmu++) {
            tmp = shared->tmFree[tmu];
            while (tmp) {
                next = tmp->next;
                FREE(tmp);
                tmp = next;
            }
        }

        FREE(shared);
        fxMesa->glCtx->Shared->DriverData = NULL;
    }
d351 1
a351 2
/*
 * Delete a tdfxMemRange struct.
d355 5
a359 9
#if 0
static void
DeleteRangeNode_NoLock(struct TdfxSharedState *shared, tdfxMemRange *range)
{
    /* insert at head of list */
    range->next = shared->tmPool;
    shared->tmPool = range;
}
#endif
d361 1
a361 8
#define DELETE_RANGE_NODE(shared, range) \
    (range)->next = (shared)->tmPool;    \
    (shared)->tmPool = (range)



/*
 * When we've run out of texture memory we have to throw out an
d366 1
a366 1
FindOldestObject(tdfxContextPtr fxMesa, FxU32 tmu)
d368 58
a425 70
    const GLuint bindnumber = fxMesa->texBindNumber;
    struct gl_texture_object *oldestObj, *obj, *lowestPriorityObj;
    GLfloat lowestPriority;
    GLuint oldestAge;

    oldestObj = NULL;
    oldestAge = 0;

    lowestPriority = 1.0F;
    lowestPriorityObj = NULL;

    for (obj = fxMesa->glCtx->Shared->TexObjectList; obj; obj = obj->Next) {
        tdfxTexInfo *info = TDFX_TEXTURE_DATA(obj);

        if (info && info->isInTM &&
            ((info->whichTMU == tmu) || (info->whichTMU == TDFX_TMU_BOTH) ||
             (info->whichTMU == TDFX_TMU_SPLIT))) {
            GLuint age, lasttime;

            assert(info->tm[0]);
            lasttime = info->lastTimeUsed;

            if (lasttime > bindnumber)
                age = bindnumber + (UINT_MAX - lasttime + 1); /* TO DO: check wrap around */
            else
                age = bindnumber - lasttime;

            if (age >= oldestAge) {
                oldestAge = age;
                oldestObj = obj;
            }

            /* examine priority */
            if (obj->Priority < lowestPriority) {
                lowestPriority = obj->Priority;
                lowestPriorityObj = obj;
            }
        }
    }

    if (lowestPriority < 1.0) {
        ASSERT(lowestPriorityObj);
        /*
        printf("discard %d pri=%f\n", lowestPriorityObj->Name, lowestPriority);
        */
        return lowestPriorityObj;
    }
    else {
        /*
        printf("discard %d age=%d\n", oldestObj->Name, oldestAge);
        */
        return oldestObj;
    }
}


#if 0
static void
FlushTexMemory(tdfxContextPtr fxMesa)
{
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    struct tdfxSharedState *shared = (struct tdfxSharedState *) mesaShared->DriverData;
    struct gl_texture_object *obj;

    for (obj = mesaShared->TexObjectList; obj; obj = obj->Next) {
       if (obj->RefCount < 2) {
          /* don't flush currently bound textures */
          tdfxTMMoveOutTM_NoLock(fxMesa, obj);
       }
    }
a426 1
#endif
d429 2
a430 3
/*
 * Find the address (offset?) at which we can store a new texture.
 * <tmu> is the texture unit.
d433 2
a434 2
static FxU32
FindStartAddr(tdfxContextPtr fxMesa, FxU32 tmu, FxU32 size)
d436 50
a485 8
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    struct tdfxSharedState *shared = (struct tdfxSharedState *) mesaShared->DriverData;
    tdfxMemRange *prev, *block;
    FxU32 result;
#if 0
    int discardedCount = 0;
#define MAX_DISCARDS 10
#endif
d487 3
a489 63
    if (shared->umaTexMemory) {
        assert(tmu == TDFX_TMU0);
    }

    _glthread_LOCK_MUTEX(mesaShared->Mutex);
    while (1) {
        prev = NULL;
        block = shared->tmFree[tmu];
        while (block) {
            if (block->endAddr - block->startAddr >= size) {
                /* The texture will fit here */
                result = block->startAddr;
                block->startAddr += size;
                if (block->startAddr == block->endAddr) {
                    /* Remove this node since it's empty */
                    if (prev) {
                        prev->next = block->next;
                    }
                    else {
                        shared->tmFree[tmu] = block->next;
                    }
                    DELETE_RANGE_NODE(shared, block);
                }
                shared->freeTexMem[tmu] -= size;
                _glthread_UNLOCK_MUTEX(mesaShared->Mutex);
                return result;
            }
            prev = block;
            block = block->next;
        }
        /* We failed to find a block large enough to accomodate <size> bytes.
         * Find the oldest texObject and free it.
         */
#if 0
        discardedCount++;
        if (discardedCount > MAX_DISCARDS + 1) {
            _mesa_problem(NULL, "tdfx driver: extreme texmem fragmentation");
            _glthread_UNLOCK_MUTEX(mesaShared->Mutex);
            return BAD_ADDRESS;
        }
        else if (discardedCount > MAX_DISCARDS) {
            /* texture memory is probably really fragmented, flush it */
            FlushTexMemory(fxMesa);
        }
        else
#endif
        {
            struct gl_texture_object *obj = FindOldestObject(fxMesa, tmu);
            if (obj) {
                tdfxTMMoveOutTM_NoLock(fxMesa, obj);
                fxMesa->stats.texSwaps++;
            }
            else {
                _mesa_problem(NULL, "tdfx driver: extreme texmem fragmentation");
                _glthread_UNLOCK_MUTEX(mesaShared->Mutex);
                return BAD_ADDRESS;
            }
        }
    }

    /* never get here, but play it safe */
    _glthread_UNLOCK_MUTEX(mesaShared->Mutex);
    return BAD_ADDRESS;
d493 1
a493 2
/*
 * Remove the given tdfxMemRange node from hardware texture memory.
d495 2
a496 2
static void
RemoveRange_NoLock(tdfxContextPtr fxMesa, FxU32 tmu, tdfxMemRange *range)
d498 52
a549 66
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    struct tdfxSharedState *shared = (struct tdfxSharedState *) mesaShared->DriverData;
    tdfxMemRange *block, *prev;

    if (shared->umaTexMemory) {
       assert(tmu == TDFX_TMU0);
    }

    if (!range)
        return;

    if (range->startAddr == range->endAddr) {
        DELETE_RANGE_NODE(shared, range);
        return;
    }
    shared->freeTexMem[tmu] += range->endAddr - range->startAddr;

    /* find position in linked list to insert this tdfxMemRange node */
    prev = NULL;
    block = shared->tmFree[tmu];
    while (block) {
        assert(range->startAddr != block->startAddr);
        if (range->startAddr > block->startAddr) {
            prev = block;
            block = block->next;
        }
        else {
            break;
        }
    }

    /* Insert the free block, combine with adjacent blocks when possible */
    range->next = block;
    if (block) {
        if (range->endAddr == block->startAddr) {
            /* Combine */
            block->startAddr = range->startAddr;
            DELETE_RANGE_NODE(shared, range);
            range = block;
        }
    }
    if (prev) {
        if (prev->endAddr == range->startAddr) {
            /* Combine */
            prev->endAddr = range->endAddr;
            prev->next = range->next;
            DELETE_RANGE_NODE(shared, range);
        }
        else {
            prev->next = range;
        }
    }
    else {
        shared->tmFree[tmu] = range;
    }
}


#if 0 /* NOT USED */
static void
RemoveRange(tdfxContextPtr fxMesa, FxU32 tmu, tdfxMemRange *range)
{
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    _glthread_LOCK_MUTEX(mesaShared->Mutex);
    RemoveRange_NoLock(fxMesa, tmu, range);
    _glthread_UNLOCK_MUTEX(mesaShared->Mutex);
a550 1
#endif
d553 1
a553 2
/*
 * Allocate space for a texture image.
d558 1
a558 1
AllocTexMem(tdfxContextPtr fxMesa, FxU32 tmu, FxU32 texmemsize)
d560 107
a666 14
    FxU32 startAddr;
    startAddr = FindStartAddr(fxMesa, tmu, texmemsize);
    if (startAddr == BAD_ADDRESS) {
        char err[100];
        sprintf(err, "AllocTexMem returned NULL!  tmu=%d texmemsize=%d\n",
               (int) tmu, (int) texmemsize);
        _mesa_problem(fxMesa->glCtx, err);
        return NULL;
    }
    else {
        tdfxMemRange *range;
        range = NewRangeNode(fxMesa, startAddr, startAddr + texmemsize);
        return range;
    }
d670 71
a740 163
/*
 * Download (copy) the given texture data (all mipmap levels) into the
 * Voodoo's texture memory.
 * The texture memory must have already been allocated.
 */
void
tdfxTMDownloadTexture(tdfxContextPtr fxMesa, struct gl_texture_object *tObj)
{
    tdfxTexInfo *ti;
    GLint l;
    FxU32 targetTMU;

    assert(tObj);
    ti = TDFX_TEXTURE_DATA(tObj);
    assert(ti);
    targetTMU = ti->whichTMU;

    switch (targetTMU) {
    case TDFX_TMU0:
    case TDFX_TMU1:
        if (ti->tm[targetTMU]) {
            for (l = ti->minLevel; l <= ti->maxLevel
                    && tObj->Image[l]->Data; l++) {
                GrLOD_t glideLod = ti->info.largeLodLog2 - l + tObj->BaseLevel;
                fxMesa->Glide.grTexDownloadMipMapLevel(targetTMU,
                                                  ti->tm[targetTMU]->startAddr,
                                                  glideLod,
                                                  ti->info.largeLodLog2,
                                                  ti->info.aspectRatioLog2,
                                                  ti->info.format,
                                                  GR_MIPMAPLEVELMASK_BOTH,
                                                  tObj->Image[l]->Data);
            }
        }
        break;
    case TDFX_TMU_SPLIT:
        if (ti->tm[TDFX_TMU0] && ti->tm[TDFX_TMU1]) {
            for (l = ti->minLevel; l <= ti->maxLevel
                    && tObj->Image[l]->Data; l++) {
                GrLOD_t glideLod = ti->info.largeLodLog2 - l + tObj->BaseLevel;
                fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU0,
                                                  ti->tm[TDFX_TMU0]->startAddr,
                                                  glideLod,
                                                  ti->info.largeLodLog2,
                                                  ti->info.aspectRatioLog2,
                                                  ti->info.format,
                                                  GR_MIPMAPLEVELMASK_ODD,
                                                  tObj->Image[l]->Data);

                fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU1,
                                                  ti->tm[TDFX_TMU1]->startAddr,
                                                  glideLod,
                                                  ti->info.largeLodLog2,
                                                  ti->info.aspectRatioLog2,
                                                  ti->info.format,
                                                  GR_MIPMAPLEVELMASK_EVEN,
                                                  tObj->Image[l]->Data);
            }
        }
        break;
    case TDFX_TMU_BOTH:
        if (ti->tm[TDFX_TMU0] && ti->tm[TDFX_TMU1]) {
            for (l = ti->minLevel; l <= ti->maxLevel
                    && tObj->Image[l]->Data; l++) {
                GrLOD_t glideLod = ti->info.largeLodLog2 - l + tObj->BaseLevel;
                fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU0,
                                                  ti->tm[TDFX_TMU0]->startAddr,
                                                  glideLod,
                                                  ti->info.largeLodLog2,
                                                  ti->info.aspectRatioLog2,
                                                  ti->info.format,
                                                  GR_MIPMAPLEVELMASK_BOTH,
                                                  tObj->Image[l]->Data);

                fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU1,
                                                  ti->tm[TDFX_TMU1]->startAddr,
                                                  glideLod,
                                                  ti->info.largeLodLog2,
                                                  ti->info.aspectRatioLog2,
                                                  ti->info.format,
                                                  GR_MIPMAPLEVELMASK_BOTH,
                                                  tObj->Image[l]->Data);
            }
        }
        break;
    default:
        _mesa_problem(NULL, "error in tdfxTMDownloadTexture: bad tmu");
        return;
    }
}


void
tdfxTMReloadMipMapLevel(GLcontext *ctx, struct gl_texture_object *tObj,
                        GLint level)
{
    tdfxContextPtr fxMesa = TDFX_CONTEXT(ctx);
    tdfxTexInfo *ti = TDFX_TEXTURE_DATA(tObj);
    GrLOD_t glideLod;
    FxU32 tmu;

    tmu = ti->whichTMU;
    glideLod =  ti->info.largeLodLog2 - level + tObj->BaseLevel;
    ASSERT(ti->isInTM);

    LOCK_HARDWARE(fxMesa);

    switch (tmu) {
    case TDFX_TMU0:
    case TDFX_TMU1:
        fxMesa->Glide.grTexDownloadMipMapLevel(tmu,
                                    ti->tm[tmu]->startAddr,
                                    glideLod,
                                    ti->info.largeLodLog2,
                                    ti->info.aspectRatioLog2,
                                    ti->info.format,
                                    GR_MIPMAPLEVELMASK_BOTH,
                                    tObj->Image[level]->Data);
        break;
    case TDFX_TMU_SPLIT:
        fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU0,
                                    ti->tm[GR_TMU0]->startAddr,
                                    glideLod,
                                    ti->info.largeLodLog2,
                                    ti->info.aspectRatioLog2,
                                    ti->info.format,
                                    GR_MIPMAPLEVELMASK_ODD,
                                    tObj->Image[level]->Data);

        fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU1,
                                    ti->tm[GR_TMU1]->startAddr,
                                    glideLod,
                                    ti->info.largeLodLog2,
                                    ti->info.aspectRatioLog2,
                                    ti->info.format,
                                    GR_MIPMAPLEVELMASK_EVEN,
                                    tObj->Image[level]->Data);
        break;
    case TDFX_TMU_BOTH:
        fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU0,
                                    ti->tm[GR_TMU0]->startAddr,
                                    glideLod,
                                    ti->info.largeLodLog2,
                                    ti->info.aspectRatioLog2,
                                    ti->info.format,
                                    GR_MIPMAPLEVELMASK_BOTH,
                                    tObj->Image[level]->Data);

        fxMesa->Glide.grTexDownloadMipMapLevel(GR_TMU1,
                                    ti->tm[GR_TMU1]->startAddr,
                                    glideLod,
                                    ti->info.largeLodLog2,
                                    ti->info.aspectRatioLog2,
                                    ti->info.format,
                                    GR_MIPMAPLEVELMASK_BOTH,
                                    tObj->Image[level]->Data);
        break;

    default:
        _mesa_problem(ctx, "error in tdfxTMReloadMipMapLevel(): wrong tmu");
        break;
    }
    UNLOCK_HARDWARE(fxMesa);
d744 1
a744 2
/*
 * Allocate space for the given texture in texture memory then
d747 5
a751 57
void
tdfxTMMoveInTM_NoLock( tdfxContextPtr fxMesa, struct gl_texture_object *tObj,
                       FxU32 targetTMU )
{
    tdfxTexInfo *ti = TDFX_TEXTURE_DATA(tObj);
    FxU32 texmemsize;

    fxMesa->stats.reqTexUpload++;

    if (ti->isInTM) {
        if (ti->whichTMU == targetTMU)
            return;
        if (targetTMU == TDFX_TMU_SPLIT || ti->whichTMU == TDFX_TMU_SPLIT) {
            tdfxTMMoveOutTM_NoLock(fxMesa, tObj);
        }
        else {
            if (ti->whichTMU == TDFX_TMU_BOTH)
                return;
            targetTMU = TDFX_TMU_BOTH;
        }
    }

    ti->whichTMU = targetTMU;

    switch (targetTMU) {
    case TDFX_TMU0:
    case TDFX_TMU1:
        texmemsize = fxMesa->Glide.grTexTextureMemRequired(GR_MIPMAPLEVELMASK_BOTH,
                                                       &(ti->info));
        ti->tm[targetTMU] = AllocTexMem(fxMesa, targetTMU, texmemsize);
        break;
    case TDFX_TMU_SPLIT:
        texmemsize = fxMesa->Glide.grTexTextureMemRequired(GR_MIPMAPLEVELMASK_ODD,
                                                       &(ti->info));
        ti->tm[TDFX_TMU0] = AllocTexMem(fxMesa, TDFX_TMU0, texmemsize);
        if (ti->tm[TDFX_TMU0])
           fxMesa->stats.memTexUpload += texmemsize;

        texmemsize = fxMesa->Glide.grTexTextureMemRequired(GR_MIPMAPLEVELMASK_EVEN,
                                                       &(ti->info));
        ti->tm[TDFX_TMU1] = AllocTexMem(fxMesa, TDFX_TMU1, texmemsize);
        break;
    case TDFX_TMU_BOTH:
        texmemsize = fxMesa->Glide.grTexTextureMemRequired(GR_MIPMAPLEVELMASK_BOTH,
                                                       &(ti->info));
        ti->tm[TDFX_TMU0] = AllocTexMem(fxMesa, TDFX_TMU0, texmemsize);
        if (ti->tm[TDFX_TMU0])
           fxMesa->stats.memTexUpload += texmemsize;

        texmemsize = fxMesa->Glide.grTexTextureMemRequired(GR_MIPMAPLEVELMASK_BOTH,
                                                       &(ti->info));
        ti->tm[TDFX_TMU1] = AllocTexMem(fxMesa, TDFX_TMU1, texmemsize);
        break;
    default:
        _mesa_problem(NULL, "error in tdfxTMMoveInTM() -> bad tmu (%d)");
        return;
    }
d753 1
a753 2
    ti->reloadImages = GL_TRUE;
    ti->isInTM = GL_TRUE;
d755 51
a805 1
    fxMesa->stats.texUpload++;
d809 1
a809 2
/*
 * Move the given texture out of hardware texture memory.
d812 2
a813 2
void
tdfxTMMoveOutTM_NoLock( tdfxContextPtr fxMesa, struct gl_texture_object *tObj )
d815 40
a854 41
    struct gl_shared_state *mesaShared = fxMesa->glCtx->Shared;
    struct tdfxSharedState *shared = (struct tdfxSharedState *) mesaShared->DriverData;
    tdfxTexInfo *ti = TDFX_TEXTURE_DATA(tObj);

    if (MESA_VERBOSE & VERBOSE_DRIVER) {
        fprintf(stderr, "fxmesa: fxTMMoveOutTM(%p (%d))\n", tObj, tObj->Name);
    }

    /*
    VerifyFreeList(fxMesa, 0);
    VerifyFreeList(fxMesa, 1);
    */

    if (!ti || !ti->isInTM)
        return;

    switch (ti->whichTMU) {
    case TDFX_TMU0:
    case TDFX_TMU1:
        RemoveRange_NoLock(fxMesa, ti->whichTMU, ti->tm[ti->whichTMU]);
        break;
    case TDFX_TMU_SPLIT:
    case TDFX_TMU_BOTH:
        assert(!shared->umaTexMemory);
        RemoveRange_NoLock(fxMesa, TDFX_TMU0, ti->tm[TDFX_TMU0]);
        RemoveRange_NoLock(fxMesa, TDFX_TMU1, ti->tm[TDFX_TMU1]);
        break;
    default:
        _mesa_problem(NULL, "tdfx driver: bad tmu in tdfxTMMOveOutTM()");
        return;
    }

    ti->isInTM = GL_FALSE;
    ti->tm[0] = NULL;
    ti->tm[1] = NULL;
    ti->whichTMU = TDFX_TMU_NONE;

    /*
    VerifyFreeList(fxMesa, 0);
    VerifyFreeList(fxMesa, 1);
    */
d858 2
a859 5
/*
 * Called via glDeleteTexture to delete a texture object.
 */
void
tdfxTMFreeTexture(tdfxContextPtr fxMesa, struct gl_texture_object *tObj)
d861 17
a877 10
    tdfxTexInfo *ti = TDFX_TEXTURE_DATA(tObj);
    if (ti) {
        tdfxTMMoveOutTM(fxMesa, tObj);
        FREE(ti);
        tObj->DriverData = NULL;
    }
    /*
    VerifyFreeList(fxMesa, 0);
    VerifyFreeList(fxMesa, 1);
    */
d881 1
a881 3

/*
 * After a context switch this function will be called to restore
d884 1
a884 1
void tdfxTMRestoreTextures_NoLock( tdfxContextPtr fxMesa )
d891 2
a892 2
      tdfxTexInfo *ti = TDFX_TEXTURE_DATA( tObj );
      if ( ti && ti->isInTM ) {
d894 2
a895 2
	    if ( ctx->Texture.Unit[i]._Current == tObj ) {
	       tdfxTMDownloadTexture( fxMesa, tObj );
d900 1
a900 1
	    tdfxTMMoveOutTM_NoLock( fxMesa, tObj );
d904 5
a908 4
   /*
   VerifyFreeList(fxMesa, 0);
   VerifyFreeList(fxMesa, 1);
   */
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d26 1
a26 1
/* $XFree86: xc/lib/GL/mesa/src/drv/tdfx/tdfx_texman.c,v 1.7 2004/01/23 03:57:07 dawes Exp $ */
d507 1
a507 1
            _mesa_problem(NULL, "%s: extreme texmem fragmentation", __FUNCTION__);
d524 1
a524 1
                _mesa_problem(NULL, "%s: extreme texmem fragmentation", __FUNCTION__);
d624 4
a627 2
        _mesa_problem(fxMesa->glCtx, "%s returned NULL!  tmu=%d texmemsize=%d",
               __FUNCTION__, (int) tmu, (int) texmemsize);
d724 1
a724 1
        _mesa_problem(NULL, "%s: bad tmu (%d)", __FUNCTION__, (int)targetTMU);
d797 1
a797 1
        _mesa_problem(ctx, "%s: bad tmu (%d)", __FUNCTION__, (int)tmu);
d862 1
a862 1
        _mesa_problem(NULL, "%s: bad tmu (%d)", __FUNCTION__, (int)targetTMU);
d885 1
a885 1
        fprintf(stderr, "fxmesa: %s(%p (%d))\n", __FUNCTION__, (void *)tObj, tObj->Name);
d908 1
a908 1
        _mesa_problem(NULL, "%s: bad tmu (%d)", __FUNCTION__, (int)ti->whichTMU);
@


