head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.04.16;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.04.16;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.31.25;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.58.18;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.17.54;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * GLX Hardware Device Driver for Intel i810
 * Copyright (C) 1999 Keith Whitwell
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * KEITH WHITWELL, OR ANY OTHER CONTRIBUTORS BE LIABLE FOR ANY CLAIM, 
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *
 */
/* $XFree86: xc/lib/GL/mesa/src/drv/i810/i810tris.c,v 1.5 2000/09/24 13:51:04 alanh Exp $ */

#include <stdio.h>
#include <math.h>

#include "types.h"
#include "vb.h"
#include "pipeline.h"

#include "mm.h"
#include "i810tris.h"
#include "i810vb.h"
#include "i810log.h"

/* Used in i810tritmp.h
 */
#define I810_COLOR(to, from) {			\
  (to)[0] = (from)[2];				\
  (to)[1] = (from)[1];				\
  (to)[2] = (from)[0];				\
  (to)[3] = (from)[3];				\
}

static triangle_func tri_tab[0x10];   
static quad_func     quad_tab[0x10];  
static line_func     line_tab[0x10];  
static points_func   points_tab[0x10];

#define IND (0)
#define TAG(x) x
#include "i810tritmp.h"

#define IND (I810_FLAT_BIT)
#define TAG(x) x##_flat
#include "i810tritmp.h"

#define IND (I810_OFFSET_BIT)	
#define TAG(x) x##_offset
#include "i810tritmp.h"

#define IND (I810_OFFSET_BIT|I810_FLAT_BIT) 
#define TAG(x) x##_offset_flat
#include "i810tritmp.h"

#define IND (I810_TWOSIDE_BIT)	
#define TAG(x) x##_twoside
#include "i810tritmp.h"

#define IND (I810_TWOSIDE_BIT|I810_FLAT_BIT) 
#define TAG(x) x##_twoside_flat
#include "i810tritmp.h"

#define IND (I810_TWOSIDE_BIT|I810_OFFSET_BIT) 
#define TAG(x) x##_twoside_offset
#include "i810tritmp.h"

#define IND (I810_TWOSIDE_BIT|I810_OFFSET_BIT|I810_FLAT_BIT) 
#define TAG(x) x##_twoside_offset_flat
#include "i810tritmp.h"



void i810DDTrifuncInit()
{
   init();
   init_flat();
   init_offset();
   init_offset_flat();
   init_twoside();
   init_twoside_flat();
   init_twoside_offset();
   init_twoside_offset_flat();
}



#define ALL_FALLBACK (DD_MULTIDRAW | DD_SELECT | DD_FEEDBACK | DD_STENCIL)
#define POINT_FALLBACK (ALL_FALLBACK)
#define LINE_FALLBACK (ALL_FALLBACK | DD_LINE_STIPPLE)
#define TRI_FALLBACK (ALL_FALLBACK | DD_TRI_UNFILLED)
#define ANY_FALLBACK (POINT_FALLBACK|LINE_FALLBACK|TRI_FALLBACK|DD_TRI_STIPPLE)
#define ANY_RASTER_FLAGS (DD_FLATSHADE|DD_TRI_LIGHT_TWOSIDE|DD_TRI_OFFSET)

void i810DDChooseRenderState(GLcontext *ctx)
{
    i810ContextPtr imesa = I810_CONTEXT(ctx);
    GLuint         flags   = ctx->TriangleCaps;
    CARD32 index    = 0;

    if (imesa->Fallback) {
	imesa->renderindex = I810_FALLBACK_BIT;
	return;
    }
    
    if (flags & ANY_RASTER_FLAGS) {
	if (flags & DD_FLATSHADE)               index |= I810_FLAT_BIT;
	if (flags & DD_TRI_LIGHT_TWOSIDE)       index |= I810_TWOSIDE_BIT;
	if (flags & DD_TRI_OFFSET)              index |= I810_OFFSET_BIT; 
    }
	
    imesa->PointsFunc = points_tab[index];
    imesa->LineFunc = line_tab[index];
    imesa->TriangleFunc = tri_tab[index];
    imesa->QuadFunc = quad_tab[index];
    imesa->renderindex = index;
    imesa->IndirectTriangles = 0;

    if (flags & ANY_FALLBACK) {
	if (flags & POINT_FALLBACK) {
	    imesa->renderindex |= I810_FALLBACK_BIT;
	    imesa->PointsFunc = 0;
	    imesa->IndirectTriangles |= DD_POINT_SW_RASTERIZE;
	}
	    
	if (flags & LINE_FALLBACK) {
	    imesa->renderindex |= I810_FALLBACK_BIT;
	    imesa->LineFunc = 0;
	    imesa->IndirectTriangles |= DD_LINE_SW_RASTERIZE;
	}

	if (flags & TRI_FALLBACK) {
	    imesa->renderindex |= I810_FALLBACK_BIT;
	    imesa->TriangleFunc = 0;
	    imesa->QuadFunc = 0;
	    imesa->IndirectTriangles |= (DD_TRI_SW_RASTERIZE |
					 DD_QUAD_SW_RASTERIZE);
	}
	/* Special cases:
	 */
	if ((flags & DD_TRI_STIPPLE) &&
	    (ctx->IndirectTriangles & DD_TRI_STIPPLE)) {
	    imesa->renderindex |= I810_FALLBACK_BIT;
	    imesa->TriangleFunc = 0;
	    imesa->QuadFunc = 0;
	    imesa->IndirectTriangles |= (DD_TRI_SW_RASTERIZE |
					 DD_QUAD_SW_RASTERIZE);
	}
    }
}



@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@a0 28
/* $XFree86: xc/lib/GL/mesa/src/drv/i810/i810tris.c,v 1.8 2003/09/28 20:15:12 alanh Exp $ */
/**************************************************************************

Copyright 2001 VA Linux Systems Inc., Fremont, California.

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
on the rights to use, copy, modify, merge, publish, distribute, sub
license, and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
ATI, VA LINUX SYSTEMS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

d2 22
a23 2
 * Authors:
 *   Keith Whitwell <keith@@tungstengraphics.com>
d25 1
d27 2
a28 10
#include "glheader.h"
#include "mtypes.h"
#include "macros.h"
#include "enums.h"
#include "colormac.h"

#include "swrast/swrast.h"
#include "swrast_setup/swrast_setup.h"
#include "tnl/t_context.h"
#include "tnl/t_pipeline.h"
d30 3
a32 2
#include "i810screen.h"
#include "i810_dri.h"
d34 1
a35 1
#include "i810state.h"
d37 1
a37 1
#include "i810ioctl.h"
d39 7
a45 37
static void i810RenderPrimitive( GLcontext *ctx, GLenum prim );

/***********************************************************************
 *                    Emit primitives as inline vertices               *
 ***********************************************************************/

#if defined(USE_X86_ASM)
#define COPY_DWORDS( j, vb, vertsize, v )				\
do {									\
	int __tmp;							\
	__asm__ __volatile__( "rep ; movsl"				\
			      : "=%c" (j), "=D" (vb), "=S" (__tmp)	\
			      : "0" (vertsize),				\
			        "D" ((long)vb),				\
			        "S" ((long)v) );			\
} while (0)
#else
#define COPY_DWORDS( j, vb, vertsize, v )				\
do {									\
   for ( j = 0 ; j < vertsize ; j++ )					\
      vb[j] = ((GLuint *)v)[j];						\
   vb += vertsize;							\
} while (0)
#endif

static void __inline__ i810_draw_triangle( i810ContextPtr imesa,
					   i810VertexPtr v0,
					   i810VertexPtr v1,
					   i810VertexPtr v2 )
{
   GLuint vertsize = imesa->vertex_size;
   GLuint *vb = i810AllocDmaLow( imesa, 3 * 4 * vertsize );
   int j;

   COPY_DWORDS( j, vb, vertsize, v0 );
   COPY_DWORDS( j, vb, vertsize, v1 );
   COPY_DWORDS( j, vb, vertsize, v2 );
d48 4
d53 1
a53 200
static void __inline__ i810_draw_quad( i810ContextPtr imesa,
				       i810VertexPtr v0,
				       i810VertexPtr v1,
				       i810VertexPtr v2,
				       i810VertexPtr v3 )
{
   GLuint vertsize = imesa->vertex_size;
   GLuint *vb = i810AllocDmaLow( imesa, 6 * 4 * vertsize );
   int j;

   COPY_DWORDS( j, vb, vertsize, v0 );
   COPY_DWORDS( j, vb, vertsize, v1 );
   COPY_DWORDS( j, vb, vertsize, v3 );
   COPY_DWORDS( j, vb, vertsize, v1 );
   COPY_DWORDS( j, vb, vertsize, v2 );
   COPY_DWORDS( j, vb, vertsize, v3 );
}


static __inline__ void i810_draw_point( i810ContextPtr imesa,
					i810VertexPtr tmp )
{
   GLfloat sz = imesa->glCtx->Point._Size * .5;
   int vertsize = imesa->vertex_size;
   GLuint *vb = i810AllocDmaLow( imesa, 2 * 4 * vertsize );
   int j;

   /* Draw a point as a horizontal line.
    */
   *(float *)&vb[0] = tmp->v.x - sz + 0.125;
   for (j = 1 ; j < vertsize ; j++)
      vb[j] = tmp->ui[j];
   vb += vertsize;

   *(float *)&vb[0] = tmp->v.x + sz + 0.125;
   for (j = 1 ; j < vertsize ; j++)
      vb[j] = tmp->ui[j];
   vb += vertsize;
}


static __inline__ void i810_draw_line( i810ContextPtr imesa,
				       i810VertexPtr v0,
				       i810VertexPtr v1 )
{
   GLuint vertsize = imesa->vertex_size;
   GLuint *vb = i810AllocDmaLow( imesa, 2 * 4 * vertsize );
   int j;

   COPY_DWORDS( j, vb, vertsize, v0 );
   COPY_DWORDS( j, vb, vertsize, v1 );
}



/***********************************************************************
 *          Macros for t_dd_tritmp.h to draw basic primitives          *
 ***********************************************************************/

#define TRI( a, b, c )				\
do { 						\
   if (0) fprintf(stderr, "hw TRI\n");		\
   if (DO_FALLBACK)				\
      imesa->draw_tri( imesa, a, b, c );	\
   else						\
      i810_draw_triangle( imesa, a, b, c );	\
} while (0)

#define QUAD( a, b, c, d )			\
do { 						\
   if (0) fprintf(stderr, "hw QUAD\n");		\
   if (DO_FALLBACK) {				\
      imesa->draw_tri( imesa, a, b, d );	\
      imesa->draw_tri( imesa, b, c, d );	\
   } else					\
      i810_draw_quad( imesa, a, b, c, d );	\
} while (0)

#define LINE( v0, v1 )				\
do { 						\
   if (0) fprintf(stderr, "hw LINE\n");		\
   if (DO_FALLBACK)				\
      imesa->draw_line( imesa, v0, v1 );	\
   else						\
      i810_draw_line( imesa, v0, v1 );		\
} while (0)

#define POINT( v0 )				\
do { 						\
   if (0) fprintf(stderr, "hw POINT\n");	\
   if (DO_FALLBACK)				\
      imesa->draw_point( imesa, v0 );		\
   else						\
      i810_draw_point( imesa, v0 );		\
} while (0)


/***********************************************************************
 *              Build render functions from dd templates               *
 ***********************************************************************/

#define I810_OFFSET_BIT 	0x01
#define I810_TWOSIDE_BIT	0x02
#define I810_UNFILLED_BIT	0x04
#define I810_FALLBACK_BIT	0x08
#define I810_MAX_TRIFUNC	0x10


static struct {
   points_func	        points;
   line_func		line;
   triangle_func	triangle;
   quad_func		quad;
} rast_tab[I810_MAX_TRIFUNC];


#define DO_FALLBACK (IND & I810_FALLBACK_BIT)
#define DO_OFFSET   (IND & I810_OFFSET_BIT)
#define DO_UNFILLED (IND & I810_UNFILLED_BIT)
#define DO_TWOSIDE  (IND & I810_TWOSIDE_BIT)
#define DO_FLAT      0
#define DO_TRI       1
#define DO_QUAD      1
#define DO_LINE      1
#define DO_POINTS    1
#define DO_FULL_QUAD 1

#define HAVE_RGBA         1
#define HAVE_SPEC         1
#define HAVE_BACK_COLORS  0
#define HAVE_HW_FLATSHADE 1
#define VERTEX            i810Vertex
#define TAB               rast_tab

/* Only used to pull back colors into vertices (ie, we know color is
 * floating point).
 */
#define I810_COLOR( dst, src )			\
do {						\
   dst[0] = src[2];				\
   dst[1] = src[1];				\
   dst[2] = src[0];				\
   dst[3] = src[3];				\
} while (0)

#define I810_SPEC( dst, src )			\
do {						\
   dst[0] = src[2];				\
   dst[1] = src[1];				\
   dst[2] = src[0];				\
} while (0)


#define DEPTH_SCALE (1.0/0xffff)
#define UNFILLED_TRI unfilled_tri
#define UNFILLED_QUAD unfilled_quad
#define VERT_X(_v) _v->v.x
#define VERT_Y(_v) _v->v.y
#define VERT_Z(_v) _v->v.z
#define AREA_IS_CCW( a ) (a > 0)
#define GET_VERTEX(e) (imesa->verts + (e<<imesa->vertex_stride_shift))

#define VERT_SET_RGBA( v, c )    I810_COLOR( v->ub4[coloroffset], c )
#define VERT_COPY_RGBA( v0, v1 ) v0->ui[coloroffset] = v1->ui[coloroffset]
#define VERT_SAVE_RGBA( idx )    color[idx] = v[idx]->ui[coloroffset]
#define VERT_RESTORE_RGBA( idx ) v[idx]->ui[coloroffset] = color[idx]

#define VERT_SET_SPEC( v, c )    if (havespec) I810_SPEC( v->ub4[5], c )
#define VERT_COPY_SPEC( v0, v1 ) if (havespec) COPY_3V(v0->ub4[5], v1->ub4[5])
#define VERT_SAVE_SPEC( idx )    if (havespec) spec[idx] = v[idx]->ui[5]
#define VERT_RESTORE_SPEC( idx ) if (havespec) v[idx]->ui[5] = spec[idx]

#define LOCAL_VARS(n)							\
   i810ContextPtr imesa = I810_CONTEXT(ctx);				\
   GLuint color[n], spec[n];						\
   GLuint coloroffset = (imesa->vertex_size == 4 ? 3 : 4);		\
   GLboolean havespec = (imesa->vertex_size > 4);			\
   (void) color; (void) spec; (void) coloroffset; (void) havespec;


/***********************************************************************
 *                Helpers for rendering unfilled primitives            *
 ***********************************************************************/

static const GLuint hw_prim[GL_POLYGON+1] = {
   PR_LINES,
   PR_LINES,
   PR_LINES,
   PR_LINES,
   PR_TRIANGLES,
   PR_TRIANGLES,
   PR_TRIANGLES,
   PR_TRIANGLES,
   PR_TRIANGLES,
   PR_TRIANGLES
};

#define RASTERIZE(x) if (imesa->hw_primitive != hw_prim[x]) \
                        i810RasterPrimitive( ctx, x, hw_prim[x] )
#define RENDER_PRIMITIVE imesa->render_primitive
d55 1
a55 7
#define IND I810_FALLBACK_BIT
#include "tnl_dd/t_dd_unfilled.h"
#undef IND

/***********************************************************************
 *                      Generate GL render functions                   *
 ***********************************************************************/
d57 3
a59 3
#define IND (0)
#define TAG(x) x
#include "tnl_dd/t_dd_tritmp.h"
d61 1
a61 1
#define IND (I810_OFFSET_BIT)
d63 1
a63 1
#include "tnl_dd/t_dd_tritmp.h"
d65 5
a69 1
#define IND (I810_TWOSIDE_BIT)
d71 5
a75 1
#include "tnl_dd/t_dd_tritmp.h"
d77 1
a77 1
#define IND (I810_TWOSIDE_BIT|I810_OFFSET_BIT)
d79 1
a79 17
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_UNFILLED_BIT)
#define TAG(x) x##_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_OFFSET_BIT|I810_UNFILLED_BIT)
#define TAG(x) x##_offset_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_TWOSIDE_BIT|I810_UNFILLED_BIT)
#define TAG(x) x##_twoside_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_TWOSIDE_BIT|I810_OFFSET_BIT|I810_UNFILLED_BIT)
#define TAG(x) x##_twoside_offset_unfilled
#include "tnl_dd/t_dd_tritmp.h"
d81 3
a83 3
#define IND (I810_FALLBACK_BIT)
#define TAG(x) x##_fallback
#include "tnl_dd/t_dd_tritmp.h"
a84 3
#define IND (I810_OFFSET_BIT|I810_FALLBACK_BIT)
#define TAG(x) x##_offset_fallback
#include "tnl_dd/t_dd_tritmp.h"
a85 3
#define IND (I810_TWOSIDE_BIT|I810_FALLBACK_BIT)
#define TAG(x) x##_twoside_fallback
#include "tnl_dd/t_dd_tritmp.h"
d87 1
a87 23
#define IND (I810_TWOSIDE_BIT|I810_OFFSET_BIT|I810_FALLBACK_BIT)
#define TAG(x) x##_twoside_offset_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_UNFILLED_BIT|I810_FALLBACK_BIT)
#define TAG(x) x##_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_OFFSET_BIT|I810_UNFILLED_BIT|I810_FALLBACK_BIT)
#define TAG(x) x##_offset_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_TWOSIDE_BIT|I810_UNFILLED_BIT|I810_FALLBACK_BIT)
#define TAG(x) x##_twoside_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_TWOSIDE_BIT|I810_OFFSET_BIT|I810_UNFILLED_BIT| \
	     I810_FALLBACK_BIT)
#define TAG(x) x##_twoside_offset_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"


static void init_rast_tab( void )
d90 1
d92 1
d94 1
d96 1
a96 314
   init_unfilled();
   init_offset_unfilled();
   init_twoside_unfilled();
   init_twoside_offset_unfilled();
   init_fallback();
   init_offset_fallback();
   init_twoside_fallback();
   init_twoside_offset_fallback();
   init_unfilled_fallback();
   init_offset_unfilled_fallback();
   init_twoside_unfilled_fallback();
   init_twoside_offset_unfilled_fallback();
}


/***********************************************************************
 *                    Rasterization fallback helpers                   *
 ***********************************************************************/


/* This code is hit only when a mix of accelerated and unaccelerated
 * primitives are being drawn, and only for the unaccelerated
 * primitives.
 */
static void
i810_fallback_tri( i810ContextPtr imesa,
		   i810Vertex *v0,
		   i810Vertex *v1,
		   i810Vertex *v2 )
{
   GLcontext *ctx = imesa->glCtx;
   SWvertex v[3];
   i810_translate_vertex( ctx, v0, &v[0] );
   i810_translate_vertex( ctx, v1, &v[1] );
   i810_translate_vertex( ctx, v2, &v[2] );
   _swrast_Triangle( ctx, &v[0], &v[1], &v[2] );
}


static void
i810_fallback_line( i810ContextPtr imesa,
		    i810Vertex *v0,
		    i810Vertex *v1 )
{
   GLcontext *ctx = imesa->glCtx;
   SWvertex v[2];
   i810_translate_vertex( ctx, v0, &v[0] );
   i810_translate_vertex( ctx, v1, &v[1] );
   _swrast_Line( ctx, &v[0], &v[1] );
}


static void
i810_fallback_point( i810ContextPtr imesa,
		     i810Vertex *v0 )
{
   GLcontext *ctx = imesa->glCtx;
   SWvertex v[1];
   i810_translate_vertex( ctx, v0, &v[0] );
   _swrast_Point( ctx, &v[0] );
}



/**********************************************************************/
/*               Render unclipped begin/end objects                   */
/**********************************************************************/

#define IND 0
#define V(x) (i810Vertex *)(vertptr + ((x)<<vertshift))
#define RENDER_POINTS( start, count )	\
   for ( ; start < count ; start++) POINT( V(ELT(start)) );
#define RENDER_LINE( v0, v1 )         LINE( V(v0), V(v1) )
#define RENDER_TRI(  v0, v1, v2 )     TRI(  V(v0), V(v1), V(v2) )
#define RENDER_QUAD( v0, v1, v2, v3 ) QUAD( V(v0), V(v1), V(v2), V(v3) )
#define INIT(x) i810RenderPrimitive( ctx, x )
#undef LOCAL_VARS
#define LOCAL_VARS						\
    i810ContextPtr imesa = I810_CONTEXT(ctx);			\
    GLubyte *vertptr = (GLubyte *)imesa->verts;			\
    const GLuint vertshift = imesa->vertex_stride_shift;       	\
    const GLuint * const elt = TNL_CONTEXT(ctx)->vb.Elts;	\
    (void) elt;
#define RESET_STIPPLE
#define RESET_OCCLUSION
#define PRESERVE_VB_DEFS
#define ELT(x) x
#define TAG(x) i810_##x##_verts
#include "tnl/t_vb_rendertmp.h"
#undef ELT
#undef TAG
#define TAG(x) i810_##x##_elts
#define ELT(x) elt[x]
#include "tnl/t_vb_rendertmp.h"

/**********************************************************************/
/*                   Render clipped primitives                        */
/**********************************************************************/



static void i810RenderClippedPoly( GLcontext *ctx, const GLuint *elts,
				   GLuint n )
{
   i810ContextPtr imesa = I810_CONTEXT(ctx);
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct vertex_buffer *VB = &TNL_CONTEXT(ctx)->vb;
   GLuint prim = imesa->render_primitive;

   /* Render the new vertices as an unclipped polygon.
    */
   {
      GLuint *tmp = VB->Elts;
      VB->Elts = (GLuint *)elts;
      tnl->Driver.Render.PrimTabElts[GL_POLYGON]( ctx, 0, n, 
						  PRIM_BEGIN|PRIM_END );
      VB->Elts = tmp;
   }

   /* Restore the render primitive
    */
   if (prim != GL_POLYGON)
      tnl->Driver.Render.PrimitiveNotify( ctx, prim );
}

static void i810RenderClippedLine( GLcontext *ctx, GLuint ii, GLuint jj )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   tnl->Driver.Render.Line( ctx, ii, jj );
}

static void i810FastRenderClippedPoly( GLcontext *ctx, const GLuint *elts,
				       GLuint n )
{
   i810ContextPtr imesa = I810_CONTEXT( ctx );
   GLuint vertsize = imesa->vertex_size;
   GLuint *vb = i810AllocDmaLow( imesa, (n-2) * 3 * 4 * vertsize );
   GLubyte *vertptr = (GLubyte *)imesa->verts;
   const GLuint vertshift = imesa->vertex_stride_shift;
   const GLuint *start = (const GLuint *)V(elts[0]);
   int i,j;

   for (i = 2 ; i < n ; i++) {
      COPY_DWORDS( j, vb, vertsize, V(elts[i-1]) );
      COPY_DWORDS( j, vb, vertsize, V(elts[i]) );
      COPY_DWORDS( j, vb, vertsize, start );
   }
}

/**********************************************************************/
/*                    Choose render functions                         */
/**********************************************************************/

/***********************************************************************
 *                    Rasterization fallback helpers                   *
 ***********************************************************************/



#define _I810_NEW_RENDERSTATE (_DD_NEW_LINE_STIPPLE |		\
			       _DD_NEW_TRI_UNFILLED |		\
			       _DD_NEW_TRI_LIGHT_TWOSIDE |	\
			       _DD_NEW_TRI_OFFSET |		\
			       _DD_NEW_TRI_STIPPLE |		\
			       _NEW_POLYGONSTIPPLE)

#define POINT_FALLBACK (0)
#define LINE_FALLBACK (DD_LINE_STIPPLE)
#define TRI_FALLBACK (0)
#define ANY_FALLBACK_FLAGS (POINT_FALLBACK|LINE_FALLBACK|TRI_FALLBACK|\
                            DD_TRI_STIPPLE)
#define ANY_RASTER_FLAGS (DD_TRI_LIGHT_TWOSIDE|DD_TRI_OFFSET|DD_TRI_UNFILLED)

static void i810ChooseRenderState(GLcontext *ctx)
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   i810ContextPtr imesa = I810_CONTEXT(ctx);
   GLuint flags = ctx->_TriangleCaps;
   GLuint index = 0;

   if (I810_DEBUG & DEBUG_STATE)
     fprintf(stderr,"\n%s\n",__FUNCTION__);

   if (flags & (ANY_FALLBACK_FLAGS|ANY_RASTER_FLAGS)) {
      if (flags & ANY_RASTER_FLAGS) {
	 if (flags & DD_TRI_LIGHT_TWOSIDE)    index |= I810_TWOSIDE_BIT;
	 if (flags & DD_TRI_OFFSET)	      index |= I810_OFFSET_BIT;
	 if (flags & DD_TRI_UNFILLED)	      index |= I810_UNFILLED_BIT;
      }

      imesa->draw_point = i810_draw_point;
      imesa->draw_line = i810_draw_line;
      imesa->draw_tri = i810_draw_triangle;

      /* Hook in fallbacks for specific primitives.
       */
      if (flags & ANY_FALLBACK_FLAGS)
      {
	 if (flags & POINT_FALLBACK)
	    imesa->draw_point = i810_fallback_point;

	 if (flags & LINE_FALLBACK)
	    imesa->draw_line = i810_fallback_line;

	 if (flags & TRI_FALLBACK)
	    imesa->draw_tri = i810_fallback_tri;

	 if ((flags & DD_TRI_STIPPLE) && !imesa->stipple_in_hw)
	    imesa->draw_tri = i810_fallback_tri;

	 index |= I810_FALLBACK_BIT;
      }
   }

   if (imesa->RenderIndex != index) {
      imesa->RenderIndex = index;

      tnl->Driver.Render.Points = rast_tab[index].points;
      tnl->Driver.Render.Line = rast_tab[index].line;
      tnl->Driver.Render.Triangle = rast_tab[index].triangle;
      tnl->Driver.Render.Quad = rast_tab[index].quad;

      if (index == 0) {
	 tnl->Driver.Render.PrimTabVerts = i810_render_tab_verts;
	 tnl->Driver.Render.PrimTabElts = i810_render_tab_elts;
	 tnl->Driver.Render.ClippedLine = line; /* from tritmp.h */
	 tnl->Driver.Render.ClippedPolygon = i810FastRenderClippedPoly;
      } else {
	 tnl->Driver.Render.PrimTabVerts = _tnl_render_tab_verts;
	 tnl->Driver.Render.PrimTabElts = _tnl_render_tab_elts;
	 tnl->Driver.Render.ClippedLine = i810RenderClippedLine;
	 tnl->Driver.Render.ClippedPolygon = i810RenderClippedPoly;
      }
   }
}

static const GLenum reduced_prim[GL_POLYGON+1] = {
   GL_POINTS,
   GL_LINES,
   GL_LINES,
   GL_LINES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES
};


/**********************************************************************/
/*                 High level hooks for t_vb_render.c                 */
/**********************************************************************/



/* Determine the rasterized primitive when not drawing unfilled
 * polygons.
 *
 * Used only for the default render stage which always decomposes
 * primitives to trianges/lines/points.  For the accelerated stage,
 * which renders strips as strips, the equivalent calculations are
 * performed in i810render.c.
 */
static void i810RenderPrimitive( GLcontext *ctx, GLenum prim )
{
   i810ContextPtr imesa = I810_CONTEXT(ctx);
   GLuint rprim = reduced_prim[prim];

   imesa->render_primitive = prim;

   if (rprim == GL_TRIANGLES && (ctx->_TriangleCaps & DD_TRI_UNFILLED))
      return;

   if (imesa->reduced_primitive != rprim ||
       hw_prim[prim] != imesa->hw_primitive) {
      i810RasterPrimitive( ctx, rprim, hw_prim[prim] );
   }
}

static void i810RunPipeline( GLcontext *ctx )
{
   i810ContextPtr imesa = I810_CONTEXT(ctx);

   if (imesa->new_state) {
      if (imesa->new_state & _NEW_TEXTURE)
	 i810UpdateTextureState( ctx );	/* may modify imesa->new_state */

      if (!imesa->Fallback) {
	 if (imesa->new_state & _I810_NEW_VERTEX)
	    i810ChooseVertexState( ctx );

	 if (imesa->new_state & _I810_NEW_RENDERSTATE)
	    i810ChooseRenderState( ctx );
      }

      imesa->new_state = 0;
   }

   _tnl_run_pipeline( ctx );
}

static void i810RenderStart( GLcontext *ctx )
{
   /* Check for projective textureing.  Make sure all texcoord
    * pointers point to something.  (fix in mesa?)
    */
   i810CheckTexSizes( ctx );
}

static void i810RenderFinish( GLcontext *ctx )
{
   if (I810_CONTEXT(ctx)->RenderIndex & I810_FALLBACK_BIT)
      _swrast_flush( ctx );
d101 62
a162 92

/* System to flush dma and emit state changes based on the rasterized
 * primitive.
 */
void i810RasterPrimitive( GLcontext *ctx,
			  GLenum rprim,
			  GLuint hwprim )
{
   i810ContextPtr imesa = I810_CONTEXT(ctx);
   GLuint st1 = imesa->Setup[I810_CTXREG_ST1];
   GLuint aa = imesa->Setup[I810_CTXREG_AA];
   GLuint lcs = imesa->Setup[I810_CTXREG_LCS];

   st1 &= ~ST1_ENABLE;
   aa &= ~AA_ENABLE;

   if (I810_DEBUG & DEBUG_PRIMS) {
      /* Prints reduced prim, and hw prim */
      char *prim_name = "Unknown";
      
      switch(hwprim) {
      case PR_LINES:
	 prim_name = "Lines";
	 break;
      case PR_LINESTRIP:
	 prim_name = "LineStrip";
	 break;	 
      case PR_TRIANGLES:
	 prim_name = "Triangles";
	 break;	 
      case PR_TRISTRIP_0:
	 prim_name = "TriStrip_0";
	 break;	 
      case PR_TRIFAN:
	 prim_name = "TriFan";
	 break;	 
      case PR_POLYGON:
	 prim_name = "Polygons";
	 break;
      default:
	 break;
      }

      fprintf(stderr, "%s : rprim(%s), hwprim(%s)\n",
	      __FUNCTION__,
	      _mesa_lookup_enum_by_nr(rprim),
	      prim_name);
   }

   switch (rprim) {
   case GL_TRIANGLES:
      if (ctx->Polygon.StippleFlag)
	 st1 |= ST1_ENABLE;
      if (ctx->Polygon.SmoothFlag)
	 aa |= AA_ENABLE;
      break;
   case GL_LINES:
      lcs &= ~(LCS_LINEWIDTH_3_0|LCS_LINEWIDTH_0_5);
      lcs |= imesa->LcsLineWidth;
      if (ctx->Line.SmoothFlag) {
	 aa |= AA_ENABLE;
	 lcs |= LCS_LINEWIDTH_0_5;
      }
      break;
   case GL_POINTS:
      lcs &= ~(LCS_LINEWIDTH_3_0|LCS_LINEWIDTH_0_5);
      lcs |= imesa->LcsPointSize;
      if (ctx->Point.SmoothFlag) {
	 aa |= AA_ENABLE;
	 lcs |= LCS_LINEWIDTH_0_5;
      }
      break;
   default:
      return;
   }

   imesa->reduced_primitive = rprim;

   if (st1 != imesa->Setup[I810_CTXREG_ST1] ||
       aa != imesa->Setup[I810_CTXREG_AA] ||
       lcs != imesa->Setup[I810_CTXREG_LCS])
   {
      I810_STATECHANGE(imesa, I810_UPLOAD_CTX);
      imesa->hw_primitive = hwprim;
      imesa->Setup[I810_CTXREG_LCS] = lcs;
      imesa->Setup[I810_CTXREG_ST1] = st1;
      imesa->Setup[I810_CTXREG_AA] = aa;
   }
   else if (hwprim != imesa->hw_primitive) {
      I810_STATECHANGE(imesa, 0);
      imesa->hw_primitive = hwprim;
   }
a164 14
/**********************************************************************/
/*           Transition to/from hardware rasterization.               */
/**********************************************************************/
static char *fallbackStrings[] = {
   "Texture",
   "Draw buffer",
   "Read buffer",
   "Color mask",
   "Render mode",
   "Stencil",
   "Stipple",
   "User disable"
};

a165 9
static char *getFallbackString(GLuint bit)
{
   int i = 0;
   while (bit > 1) {
      i++;
      bit >>= 1;
   }
   return fallbackStrings[i];
}
a166 57
void i810Fallback( i810ContextPtr imesa, GLuint bit, GLboolean mode )
{
   GLcontext *ctx = imesa->glCtx;
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   GLuint oldfallback = imesa->Fallback;

   if (0) fprintf(stderr, "%s old %x bit %x mode %d\n", __FUNCTION__,
		  imesa->Fallback, bit, mode );

   if (mode) {
      imesa->Fallback |= bit;
      if (oldfallback == 0) {
	 I810_FIREVERTICES(imesa);
	 if (I810_DEBUG & DEBUG_FALLBACKS) 
	    fprintf(stderr, "ENTER FALLBACK %s\n", getFallbackString( bit ));
	 _swsetup_Wakeup( ctx );
	 imesa->RenderIndex = ~0;
      }
   }
   else {
      imesa->Fallback &= ~bit;
      if (oldfallback == bit) {
	 _swrast_flush( ctx );
	 if (I810_DEBUG & DEBUG_FALLBACKS) 
	    fprintf(stderr, "LEAVE FALLBACK %s\n", getFallbackString( bit ));
	 tnl->Driver.Render.Start = i810RenderStart;
	 tnl->Driver.Render.PrimitiveNotify = i810RenderPrimitive;
	 tnl->Driver.Render.Finish = i810RenderFinish;
	 tnl->Driver.Render.BuildVertices = i810BuildVertices;
	 imesa->new_state |= (_I810_NEW_RENDERSTATE|_I810_NEW_VERTEX);
      }
   }
}


/**********************************************************************/
/*                            Initialization.                         */
/**********************************************************************/


void i810InitTriFuncs( GLcontext *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   static int firsttime = 1;

   if (firsttime) {
      init_rast_tab();
      firsttime = 0;
   }

   tnl->Driver.RunPipeline = i810RunPipeline;
   tnl->Driver.Render.Start = i810RenderStart;
   tnl->Driver.Render.Finish = i810RenderFinish;
   tnl->Driver.Render.PrimitiveNotify = i810RenderPrimitive;
   tnl->Driver.Render.ResetLineStipple = _swrast_ResetLineStipple;
   tnl->Driver.Render.BuildVertices = i810BuildVertices;
}
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@a0 28
/* $XFree86: xc/lib/GL/mesa/src/drv/i810/i810tris.c,v 1.7 2002/10/30 12:51:33 alanh Exp $ */
/**************************************************************************

Copyright 2001 VA Linux Systems Inc., Fremont, California.

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
on the rights to use, copy, modify, merge, publish, distribute, sub
license, and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
ATI, VA LINUX SYSTEMS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

d2 22
a23 2
 * Authors:
 *   Keith Whitwell <keith@@tungstengraphics.com>
d25 1
d30 3
a32 12
#include "glheader.h"
#include "mtypes.h"
#include "macros.h"
#include "colormac.h"

#include "swrast/swrast.h"
#include "swrast_setup/swrast_setup.h"
#include "tnl/t_context.h"
#include "tnl/t_pipeline.h"

#include "i810screen.h"
#include "i810_dri.h"
d34 1
a35 1
#include "i810state.h"
d37 1
a37 1
#include "i810ioctl.h"
d39 7
a45 37
static void i810RenderPrimitive( GLcontext *ctx, GLenum prim );

/***********************************************************************
 *                    Emit primitives as inline vertices               *
 ***********************************************************************/

#if defined(USE_X86_ASM)
#define COPY_DWORDS( j, vb, vertsize, v )				\
do {									\
	int __tmp;							\
	__asm__ __volatile__( "rep ; movsl"				\
			      : "=%c" (j), "=D" (vb), "=S" (__tmp)	\
			      : "0" (vertsize),				\
			        "D" ((long)vb),				\
			        "S" ((long)v) );			\
} while (0)
#else
#define COPY_DWORDS( j, vb, vertsize, v )				\
do {									\
   for ( j = 0 ; j < vertsize ; j++ )					\
      vb[j] = ((GLuint *)v)[j];						\
   vb += vertsize;							\
} while (0)
#endif

static void __inline__ i810_draw_triangle( i810ContextPtr imesa,
					   i810VertexPtr v0,
					   i810VertexPtr v1,
					   i810VertexPtr v2 )
{
   GLuint vertsize = imesa->vertex_size;
   GLuint *vb = i810AllocDmaLow( imesa, 3 * 4 * vertsize );
   int j;

   COPY_DWORDS( j, vb, vertsize, v0 );
   COPY_DWORDS( j, vb, vertsize, v1 );
   COPY_DWORDS( j, vb, vertsize, v2 );
d48 4
d53 1
a53 200
static void __inline__ i810_draw_quad( i810ContextPtr imesa,
				       i810VertexPtr v0,
				       i810VertexPtr v1,
				       i810VertexPtr v2,
				       i810VertexPtr v3 )
{
   GLuint vertsize = imesa->vertex_size;
   GLuint *vb = i810AllocDmaLow( imesa, 6 * 4 * vertsize );
   int j;

   COPY_DWORDS( j, vb, vertsize, v0 );
   COPY_DWORDS( j, vb, vertsize, v1 );
   COPY_DWORDS( j, vb, vertsize, v3 );
   COPY_DWORDS( j, vb, vertsize, v1 );
   COPY_DWORDS( j, vb, vertsize, v2 );
   COPY_DWORDS( j, vb, vertsize, v3 );
}


static __inline__ void i810_draw_point( i810ContextPtr imesa,
					i810VertexPtr tmp )
{
   GLfloat sz = imesa->glCtx->Point._Size * .5;
   int vertsize = imesa->vertex_size;
   GLuint *vb = i810AllocDmaLow( imesa, 2 * 4 * vertsize );
   int j;

   /* Draw a point as a horizontal line.
    */
   *(float *)&vb[0] = tmp->v.x - sz + 0.125;
   for (j = 1 ; j < vertsize ; j++)
      vb[j] = tmp->ui[j];
   vb += vertsize;

   *(float *)&vb[0] = tmp->v.x + sz + 0.125;
   for (j = 1 ; j < vertsize ; j++)
      vb[j] = tmp->ui[j];
   vb += vertsize;
}


static __inline__ void i810_draw_line( i810ContextPtr imesa,
				       i810VertexPtr v0,
				       i810VertexPtr v1 )
{
   GLuint vertsize = imesa->vertex_size;
   GLuint *vb = i810AllocDmaLow( imesa, 2 * 4 * vertsize );
   int j;

   COPY_DWORDS( j, vb, vertsize, v0 );
   COPY_DWORDS( j, vb, vertsize, v1 );
}



/***********************************************************************
 *          Macros for t_dd_tritmp.h to draw basic primitives          *
 ***********************************************************************/

#define TRI( a, b, c )				\
do { 						\
   if (0) fprintf(stderr, "hw TRI\n");		\
   if (DO_FALLBACK)				\
      imesa->draw_tri( imesa, a, b, c );	\
   else						\
      i810_draw_triangle( imesa, a, b, c );	\
} while (0)

#define QUAD( a, b, c, d )			\
do { 						\
   if (0) fprintf(stderr, "hw QUAD\n");		\
   if (DO_FALLBACK) {				\
      imesa->draw_tri( imesa, a, b, d );	\
      imesa->draw_tri( imesa, b, c, d );	\
   } else					\
      i810_draw_quad( imesa, a, b, c, d );	\
} while (0)

#define LINE( v0, v1 )				\
do { 						\
   if (0) fprintf(stderr, "hw LINE\n");		\
   if (DO_FALLBACK)				\
      imesa->draw_line( imesa, v0, v1 );	\
   else						\
      i810_draw_line( imesa, v0, v1 );		\
} while (0)

#define POINT( v0 )				\
do { 						\
   if (0) fprintf(stderr, "hw POINT\n");	\
   if (DO_FALLBACK)				\
      imesa->draw_point( imesa, v0 );		\
   else						\
      i810_draw_point( imesa, v0 );		\
} while (0)


/***********************************************************************
 *              Build render functions from dd templates               *
 ***********************************************************************/

#define I810_OFFSET_BIT 	0x01
#define I810_TWOSIDE_BIT	0x02
#define I810_UNFILLED_BIT	0x04
#define I810_FALLBACK_BIT	0x08
#define I810_MAX_TRIFUNC	0x10


static struct {
   points_func	        points;
   line_func		line;
   triangle_func	triangle;
   quad_func		quad;
} rast_tab[I810_MAX_TRIFUNC];


#define DO_FALLBACK (IND & I810_FALLBACK_BIT)
#define DO_OFFSET   (IND & I810_OFFSET_BIT)
#define DO_UNFILLED (IND & I810_UNFILLED_BIT)
#define DO_TWOSIDE  (IND & I810_TWOSIDE_BIT)
#define DO_FLAT      0
#define DO_TRI       1
#define DO_QUAD      1
#define DO_LINE      1
#define DO_POINTS    1
#define DO_FULL_QUAD 1

#define HAVE_RGBA         1
#define HAVE_SPEC         1
#define HAVE_BACK_COLORS  0
#define HAVE_HW_FLATSHADE 1
#define VERTEX            i810Vertex
#define TAB               rast_tab

/* Only used to pull back colors into vertices (ie, we know color is
 * floating point).
 */
#define I810_COLOR( dst, src )			\
do {						\
   dst[0] = src[2];				\
   dst[1] = src[1];				\
   dst[2] = src[0];				\
   dst[3] = src[3];				\
} while (0)

#define I810_SPEC( dst, src )			\
do {						\
   dst[0] = src[2];				\
   dst[1] = src[1];				\
   dst[2] = src[0];				\
} while (0)


#define DEPTH_SCALE (1.0/0xffff)
#define UNFILLED_TRI unfilled_tri
#define UNFILLED_QUAD unfilled_quad
#define VERT_X(_v) _v->v.x
#define VERT_Y(_v) _v->v.y
#define VERT_Z(_v) _v->v.z
#define AREA_IS_CCW( a ) (a > 0)
#define GET_VERTEX(e) (imesa->verts + (e<<imesa->vertex_stride_shift))

#define VERT_SET_RGBA( v, c )    I810_COLOR( v->ub4[coloroffset], c )
#define VERT_COPY_RGBA( v0, v1 ) v0->ui[coloroffset] = v1->ui[coloroffset]
#define VERT_SAVE_RGBA( idx )    color[idx] = v[idx]->ui[coloroffset]
#define VERT_RESTORE_RGBA( idx ) v[idx]->ui[coloroffset] = color[idx]

#define VERT_SET_SPEC( v, c )    if (havespec) I810_SPEC( v->ub4[5], c )
#define VERT_COPY_SPEC( v0, v1 ) if (havespec) COPY_3V(v0->ub4[5], v1->ub4[5])
#define VERT_SAVE_SPEC( idx )    if (havespec) spec[idx] = v[idx]->ui[5]
#define VERT_RESTORE_SPEC( idx ) if (havespec) v[idx]->ui[5] = spec[idx]

#define LOCAL_VARS(n)							\
   i810ContextPtr imesa = I810_CONTEXT(ctx);				\
   GLuint color[n], spec[n];						\
   GLuint coloroffset = (imesa->vertex_size == 4 ? 3 : 4);		\
   GLboolean havespec = (imesa->vertex_size > 4);			\
   (void) color; (void) spec; (void) coloroffset; (void) havespec;


/***********************************************************************
 *                Helpers for rendering unfilled primitives            *
 ***********************************************************************/

static const GLuint hw_prim[GL_POLYGON+1] = {
   PR_LINES,
   PR_LINES,
   PR_LINES,
   PR_LINES,
   PR_TRIANGLES,
   PR_TRIANGLES,
   PR_TRIANGLES,
   PR_TRIANGLES,
   PR_TRIANGLES,
   PR_TRIANGLES
};

#define RASTERIZE(x) if (imesa->hw_primitive != hw_prim[x]) \
                        i810RasterPrimitive( ctx, x, hw_prim[x] )
#define RENDER_PRIMITIVE imesa->render_primitive
d55 1
a55 7
#define IND I810_FALLBACK_BIT
#include "tnl_dd/t_dd_unfilled.h"
#undef IND

/***********************************************************************
 *                      Generate GL render functions                   *
 ***********************************************************************/
d57 3
a59 3
#define IND (0)
#define TAG(x) x
#include "tnl_dd/t_dd_tritmp.h"
d61 1
a61 1
#define IND (I810_OFFSET_BIT)
d63 5
a67 1
#include "tnl_dd/t_dd_tritmp.h"
d69 1
a69 1
#define IND (I810_TWOSIDE_BIT)
d71 1
a71 1
#include "tnl_dd/t_dd_tritmp.h"
d73 5
a77 1
#define IND (I810_TWOSIDE_BIT|I810_OFFSET_BIT)
d79 1
a79 41
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_UNFILLED_BIT)
#define TAG(x) x##_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_OFFSET_BIT|I810_UNFILLED_BIT)
#define TAG(x) x##_offset_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_TWOSIDE_BIT|I810_UNFILLED_BIT)
#define TAG(x) x##_twoside_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_TWOSIDE_BIT|I810_OFFSET_BIT|I810_UNFILLED_BIT)
#define TAG(x) x##_twoside_offset_unfilled
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_FALLBACK_BIT)
#define TAG(x) x##_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_OFFSET_BIT|I810_FALLBACK_BIT)
#define TAG(x) x##_offset_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_TWOSIDE_BIT|I810_FALLBACK_BIT)
#define TAG(x) x##_twoside_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_TWOSIDE_BIT|I810_OFFSET_BIT|I810_FALLBACK_BIT)
#define TAG(x) x##_twoside_offset_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_UNFILLED_BIT|I810_FALLBACK_BIT)
#define TAG(x) x##_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"

#define IND (I810_OFFSET_BIT|I810_UNFILLED_BIT|I810_FALLBACK_BIT)
#define TAG(x) x##_offset_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"
d81 3
a83 3
#define IND (I810_TWOSIDE_BIT|I810_UNFILLED_BIT|I810_FALLBACK_BIT)
#define TAG(x) x##_twoside_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"
a84 4
#define IND (I810_TWOSIDE_BIT|I810_OFFSET_BIT|I810_UNFILLED_BIT| \
	     I810_FALLBACK_BIT)
#define TAG(x) x##_twoside_offset_unfilled_fallback
#include "tnl_dd/t_dd_tritmp.h"
d87 1
a87 1
static void init_rast_tab( void )
d90 1
d92 1
d94 1
d96 1
a96 147
   init_unfilled();
   init_offset_unfilled();
   init_twoside_unfilled();
   init_twoside_offset_unfilled();
   init_fallback();
   init_offset_fallback();
   init_twoside_fallback();
   init_twoside_offset_fallback();
   init_unfilled_fallback();
   init_offset_unfilled_fallback();
   init_twoside_unfilled_fallback();
   init_twoside_offset_unfilled_fallback();
}


/***********************************************************************
 *                    Rasterization fallback helpers                   *
 ***********************************************************************/


/* This code is hit only when a mix of accelerated and unaccelerated
 * primitives are being drawn, and only for the unaccelerated
 * primitives.
 */
static void
i810_fallback_tri( i810ContextPtr imesa,
		   i810Vertex *v0,
		   i810Vertex *v1,
		   i810Vertex *v2 )
{
   GLcontext *ctx = imesa->glCtx;
   SWvertex v[3];
   i810_translate_vertex( ctx, v0, &v[0] );
   i810_translate_vertex( ctx, v1, &v[1] );
   i810_translate_vertex( ctx, v2, &v[2] );
   _swrast_Triangle( ctx, &v[0], &v[1], &v[2] );
}


static void
i810_fallback_line( i810ContextPtr imesa,
		    i810Vertex *v0,
		    i810Vertex *v1 )
{
   GLcontext *ctx = imesa->glCtx;
   SWvertex v[2];
   i810_translate_vertex( ctx, v0, &v[0] );
   i810_translate_vertex( ctx, v1, &v[1] );
   _swrast_Line( ctx, &v[0], &v[1] );
}


static void
i810_fallback_point( i810ContextPtr imesa,
		     i810Vertex *v0 )
{
   GLcontext *ctx = imesa->glCtx;
   SWvertex v[1];
   i810_translate_vertex( ctx, v0, &v[0] );
   _swrast_Point( ctx, &v[0] );
}



/**********************************************************************/
/*               Render unclipped begin/end objects                   */
/**********************************************************************/

#define IND 0
#define V(x) (i810Vertex *)(vertptr + ((x)<<vertshift))
#define RENDER_POINTS( start, count )	\
   for ( ; start < count ; start++) POINT( V(ELT(start)) );
#define RENDER_LINE( v0, v1 )         LINE( V(v0), V(v1) )
#define RENDER_TRI(  v0, v1, v2 )     TRI(  V(v0), V(v1), V(v2) )
#define RENDER_QUAD( v0, v1, v2, v3 ) QUAD( V(v0), V(v1), V(v2), V(v3) )
#define INIT(x) i810RenderPrimitive( ctx, x )
#undef LOCAL_VARS
#define LOCAL_VARS						\
    i810ContextPtr imesa = I810_CONTEXT(ctx);			\
    GLubyte *vertptr = (GLubyte *)imesa->verts;			\
    const GLuint vertshift = imesa->vertex_stride_shift;       	\
    const GLuint * const elt = TNL_CONTEXT(ctx)->vb.Elts;	\
    (void) elt;
#define RESET_STIPPLE
#define RESET_OCCLUSION
#define PRESERVE_VB_DEFS
#define ELT(x) x
#define TAG(x) i810_##x##_verts
#include "tnl/t_vb_rendertmp.h"
#undef ELT
#undef TAG
#define TAG(x) i810_##x##_elts
#define ELT(x) elt[x]
#include "tnl/t_vb_rendertmp.h"

/**********************************************************************/
/*                   Render clipped primitives                        */
/**********************************************************************/



static void i810RenderClippedPoly( GLcontext *ctx, const GLuint *elts,
				   GLuint n )
{
   i810ContextPtr imesa = I810_CONTEXT(ctx);
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   struct vertex_buffer *VB = &TNL_CONTEXT(ctx)->vb;
   GLuint prim = imesa->render_primitive;

   /* Render the new vertices as an unclipped polygon.
    */
   {
      GLuint *tmp = VB->Elts;
      VB->Elts = (GLuint *)elts;
      tnl->Driver.Render.PrimTabElts[GL_POLYGON]( ctx, 0, n, 
						  PRIM_BEGIN|PRIM_END );
      VB->Elts = tmp;
   }

   /* Restore the render primitive
    */
   if (prim != GL_POLYGON)
      tnl->Driver.Render.PrimitiveNotify( ctx, prim );
}

static void i810RenderClippedLine( GLcontext *ctx, GLuint ii, GLuint jj )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   tnl->Driver.Render.Line( ctx, ii, jj );
}

static void i810FastRenderClippedPoly( GLcontext *ctx, const GLuint *elts,
				       GLuint n )
{
   i810ContextPtr imesa = I810_CONTEXT( ctx );
   GLuint vertsize = imesa->vertex_size;
   GLuint *vb = i810AllocDmaLow( imesa, (n-2) * 3 * 4 * vertsize );
   GLubyte *vertptr = (GLubyte *)imesa->verts;
   const GLuint vertshift = imesa->vertex_stride_shift;
   const GLuint *start = (const GLuint *)V(elts[0]);
   int i,j;

   for (i = 2 ; i < n ; i++) {
      COPY_DWORDS( j, vb, vertsize, V(elts[i-1]) );
      COPY_DWORDS( j, vb, vertsize, V(elts[i]) );
      COPY_DWORDS( j, vb, vertsize, start );
   }
a98 7
/**********************************************************************/
/*                    Choose render functions                         */
/**********************************************************************/

/***********************************************************************
 *                    Rasterization fallback helpers                   *
 ***********************************************************************/
d101 62
a162 73

#define _I810_NEW_RENDERSTATE (_DD_NEW_LINE_STIPPLE |		\
			       _DD_NEW_TRI_UNFILLED |		\
			       _DD_NEW_TRI_LIGHT_TWOSIDE |	\
			       _DD_NEW_TRI_OFFSET |		\
			       _DD_NEW_TRI_STIPPLE |		\
			       _NEW_POLYGONSTIPPLE)

#define POINT_FALLBACK (0)
#define LINE_FALLBACK (DD_LINE_STIPPLE)
#define TRI_FALLBACK (0)
#define ANY_FALLBACK_FLAGS (POINT_FALLBACK|LINE_FALLBACK|TRI_FALLBACK|\
                            DD_TRI_STIPPLE)
#define ANY_RASTER_FLAGS (DD_TRI_LIGHT_TWOSIDE|DD_TRI_OFFSET|DD_TRI_UNFILLED)

static void i810ChooseRenderState(GLcontext *ctx)
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   i810ContextPtr imesa = I810_CONTEXT(ctx);
   GLuint flags = ctx->_TriangleCaps;
   GLuint index = 0;

   if (flags & (ANY_FALLBACK_FLAGS|ANY_RASTER_FLAGS)) {
      if (flags & ANY_RASTER_FLAGS) {
	 if (flags & DD_TRI_LIGHT_TWOSIDE)    index |= I810_TWOSIDE_BIT;
	 if (flags & DD_TRI_OFFSET)	      index |= I810_OFFSET_BIT;
	 if (flags & DD_TRI_UNFILLED)	      index |= I810_UNFILLED_BIT;
      }

      imesa->draw_point = i810_draw_point;
      imesa->draw_line = i810_draw_line;
      imesa->draw_tri = i810_draw_triangle;

      /* Hook in fallbacks for specific primitives.
       */
      if (flags & ANY_FALLBACK_FLAGS)
      {
	 if (flags & POINT_FALLBACK)
	    imesa->draw_point = i810_fallback_point;

	 if (flags & LINE_FALLBACK)
	    imesa->draw_line = i810_fallback_line;

	 if (flags & TRI_FALLBACK)
	    imesa->draw_tri = i810_fallback_tri;

	 if ((flags & DD_TRI_STIPPLE) && !imesa->stipple_in_hw)
	    imesa->draw_tri = i810_fallback_tri;

	 index |= I810_FALLBACK_BIT;
      }
   }

   if (imesa->RenderIndex != index) {
      imesa->RenderIndex = index;

      tnl->Driver.Render.Points = rast_tab[index].points;
      tnl->Driver.Render.Line = rast_tab[index].line;
      tnl->Driver.Render.Triangle = rast_tab[index].triangle;
      tnl->Driver.Render.Quad = rast_tab[index].quad;

      if (index == 0) {
	 tnl->Driver.Render.PrimTabVerts = i810_render_tab_verts;
	 tnl->Driver.Render.PrimTabElts = i810_render_tab_elts;
	 tnl->Driver.Render.ClippedLine = line; /* from tritmp.h */
	 tnl->Driver.Render.ClippedPolygon = i810FastRenderClippedPoly;
      } else {
	 tnl->Driver.Render.PrimTabVerts = _tnl_render_tab_verts;
	 tnl->Driver.Render.PrimTabElts = _tnl_render_tab_elts;
	 tnl->Driver.Render.ClippedLine = i810RenderClippedLine;
	 tnl->Driver.Render.ClippedPolygon = i810RenderClippedPoly;
      }
   }
a164 47
static const GLenum reduced_prim[GL_POLYGON+1] = {
   GL_POINTS,
   GL_LINES,
   GL_LINES,
   GL_LINES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES,
   GL_TRIANGLES
};


/**********************************************************************/
/*                 High level hooks for t_vb_render.c                 */
/**********************************************************************/



/* Determine the rasterized primitive when not drawing unfilled
 * polygons.
 *
 * Used only for the default render stage which always decomposes
 * primitives to trianges/lines/points.  For the accelerated stage,
 * which renders strips as strips, the equivalent calculations are
 * performed in i810render.c.
 */
static void i810RenderPrimitive( GLcontext *ctx, GLenum prim )
{
   i810ContextPtr imesa = I810_CONTEXT(ctx);
   GLuint rprim = reduced_prim[prim];

   imesa->render_primitive = prim;

   if (rprim == GL_TRIANGLES && (ctx->_TriangleCaps & DD_TRI_UNFILLED))
      return;

   if (imesa->reduced_primitive != rprim ||
       hw_prim[prim] != imesa->hw_primitive) {
      i810RasterPrimitive( ctx, rprim, hw_prim[prim] );
   }
}

static void i810RunPipeline( GLcontext *ctx )
{
   i810ContextPtr imesa = I810_CONTEXT(ctx);
a165 3
   if (imesa->new_state) {
      if (imesa->new_state & _NEW_TEXTURE)
	 i810UpdateTextureState( ctx );	/* may modify imesa->new_state */
a166 151
      if (!imesa->Fallback) {
	 if (imesa->new_state & _I810_NEW_VERTEX)
	    i810ChooseVertexState( ctx );

	 if (imesa->new_state & _I810_NEW_RENDERSTATE)
	    i810ChooseRenderState( ctx );
      }

      imesa->new_state = 0;
   }

   _tnl_run_pipeline( ctx );
}

static void i810RenderStart( GLcontext *ctx )
{
   /* Check for projective textureing.  Make sure all texcoord
    * pointers point to something.  (fix in mesa?)
    */
   i810CheckTexSizes( ctx );
}

static void i810RenderFinish( GLcontext *ctx )
{
   if (I810_CONTEXT(ctx)->RenderIndex & I810_FALLBACK_BIT)
      _swrast_flush( ctx );
}




/* System to flush dma and emit state changes based on the rasterized
 * primitive.
 */
void i810RasterPrimitive( GLcontext *ctx,
			  GLenum rprim,
			  GLuint hwprim )
{
   i810ContextPtr imesa = I810_CONTEXT(ctx);
   GLuint st1 = imesa->Setup[I810_CTXREG_ST1];
   GLuint aa = imesa->Setup[I810_CTXREG_AA];
   GLuint lcs = imesa->Setup[I810_CTXREG_LCS];

   st1 &= ~ST1_ENABLE;
   aa &= ~AA_ENABLE;

   switch (rprim) {
   case GL_TRIANGLES:
      if (ctx->Polygon.StippleFlag)
	 st1 |= ST1_ENABLE;
      if (ctx->Polygon.SmoothFlag)
	 aa |= AA_ENABLE;
      break;
   case GL_LINES:
      lcs &= ~(LCS_LINEWIDTH_3_0|LCS_LINEWIDTH_0_5);
      lcs |= imesa->LcsLineWidth;
      if (ctx->Line.SmoothFlag) {
	 aa |= AA_ENABLE;
	 lcs |= LCS_LINEWIDTH_0_5;
      }
      break;
   case GL_POINTS:
      lcs &= ~(LCS_LINEWIDTH_3_0|LCS_LINEWIDTH_0_5);
      lcs |= imesa->LcsPointSize;
      if (ctx->Point.SmoothFlag) {
	 aa |= AA_ENABLE;
	 lcs |= LCS_LINEWIDTH_0_5;
      }
      break;
   default:
      return;
   }

   imesa->reduced_primitive = rprim;

   if (st1 != imesa->Setup[I810_CTXREG_ST1] ||
       aa != imesa->Setup[I810_CTXREG_AA] ||
       lcs != imesa->Setup[I810_CTXREG_LCS])
   {
      I810_STATECHANGE(imesa, I810_UPLOAD_CTX);
      imesa->hw_primitive = hwprim;
      imesa->Setup[I810_CTXREG_LCS] = lcs;
      imesa->Setup[I810_CTXREG_ST1] = st1;
      imesa->Setup[I810_CTXREG_AA] = aa;
   }
   else if (hwprim != imesa->hw_primitive) {
      I810_STATECHANGE(imesa, 0);
      imesa->hw_primitive = hwprim;
   }
}

/**********************************************************************/
/*           Transition to/from hardware rasterization.               */
/**********************************************************************/


void i810Fallback( i810ContextPtr imesa, GLuint bit, GLboolean mode )
{
   GLcontext *ctx = imesa->glCtx;
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   GLuint oldfallback = imesa->Fallback;

   if (0) fprintf(stderr, "%s old %x bit %x mode %d\n", __FUNCTION__,
		  imesa->Fallback, bit, mode );

   if (mode) {
      imesa->Fallback |= bit;
      if (oldfallback == 0) {
	 if (0) fprintf(stderr, "ENTER FALLBACK\n");
	 I810_FIREVERTICES(imesa);
	 _swsetup_Wakeup( ctx );
	 imesa->RenderIndex = ~0;
      }
   }
   else {
      imesa->Fallback &= ~bit;
      if (oldfallback == bit) {
	 if (0) fprintf(stderr, "LEAVE FALLBACK\n");
	 _swrast_flush( ctx );
	 tnl->Driver.Render.Start = i810RenderStart;
	 tnl->Driver.Render.PrimitiveNotify = i810RenderPrimitive;
	 tnl->Driver.Render.Finish = i810RenderFinish;
	 tnl->Driver.Render.BuildVertices = i810BuildVertices;
	 imesa->new_state |= (_I810_NEW_RENDERSTATE|_I810_NEW_VERTEX);
      }
   }
}


/**********************************************************************/
/*                            Initialization.                         */
/**********************************************************************/


void i810InitTriFuncs( GLcontext *ctx )
{
   TNLcontext *tnl = TNL_CONTEXT(ctx);
   static int firsttime = 1;

   if (firsttime) {
      init_rast_tab();
      firsttime = 0;
   }

   tnl->Driver.RunPipeline = i810RunPipeline;
   tnl->Driver.Render.Start = i810RenderStart;
   tnl->Driver.Render.Finish = i810RenderFinish;
   tnl->Driver.Render.PrimitiveNotify = i810RenderPrimitive;
   tnl->Driver.Render.ResetLineStipple = _swrast_ResetLineStipple;
   tnl->Driver.Render.BuildVertices = i810BuildVertices;
}
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/lib/GL/mesa/src/drv/i810/i810tris.c,v 1.8 2003/09/28 20:15:12 alanh Exp $ */
d34 3
a39 1
#include "enums.h"
a555 3
   if (I810_DEBUG & DEBUG_STATE)
     fprintf(stderr,"\n%s\n",__FUNCTION__);

a706 33
   if (I810_DEBUG & DEBUG_PRIMS) {
      /* Prints reduced prim, and hw prim */
      char *prim_name = "Unknown";
      
      switch(hwprim) {
      case PR_LINES:
	 prim_name = "Lines";
	 break;
      case PR_LINESTRIP:
	 prim_name = "LineStrip";
	 break;	 
      case PR_TRIANGLES:
	 prim_name = "Triangles";
	 break;	 
      case PR_TRISTRIP_0:
	 prim_name = "TriStrip_0";
	 break;	 
      case PR_TRIFAN:
	 prim_name = "TriFan";
	 break;	 
      case PR_POLYGON:
	 prim_name = "Polygons";
	 break;
      default:
	 break;
      }

      fprintf(stderr, "%s : rprim(%s), hwprim(%s)\n",
	      __FUNCTION__,
	      _mesa_lookup_enum_by_nr(rprim),
	      prim_name);
   }

a754 11
static char *fallbackStrings[] = {
   "Texture",
   "Draw buffer",
   "Read buffer",
   "Color mask",
   "Render mode",
   "Stencil",
   "Stipple",
   "User disable"
};

a755 9
static char *getFallbackString(GLuint bit)
{
   int i = 0;
   while (bit > 1) {
      i++;
      bit >>= 1;
   }
   return fallbackStrings[i];
}
d769 1
a770 2
	 if (I810_DEBUG & DEBUG_FALLBACKS) 
	    fprintf(stderr, "ENTER FALLBACK %s\n", getFallbackString( bit ));
d778 1
a779 2
	 if (I810_DEBUG & DEBUG_FALLBACKS) 
	    fprintf(stderr, "LEAVE FALLBACK %s\n", getFallbackString( bit ));
@


