head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.2
	cvs-200410241530:1.1.1.2
	cvs-200410012000:1.1.1.2
	cvs-200407141120:1.1.1.2
	cvs-200406231010:1.1.1.2
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.2
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.2
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.04.53;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.04.53;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.32.35;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.19.22;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * $XFree86: xc/lib/Xft/xftrender.c,v 1.8 2001/07/13 18:16:10 keithp Exp $
 *
 * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdlib.h>
#include "xftint.h"

void
XftRenderString8 (Display *dpy, Picture src, 
		  XftFontStruct *font, Picture dst,
		  int srcx, int srcy,
		  int x, int y,
		  XftChar8 *string, int len)
{
    XftChar32	    missing[XFT_NMISSING];
    int		    nmissing;
    XftChar8	    *s;
    int		    l;

    s = string;
    l = len;
    nmissing = 0;
    while (l--)
	XftGlyphCheck (dpy, font, (XftChar32) *s++, missing, &nmissing);
    if (nmissing)
	XftGlyphLoad (dpy, font, missing, nmissing);
    XRenderCompositeString8 (dpy, PictOpOver, src, dst,
			     font->format, font->glyphset,
			     srcx, srcy, x, y, (char *) string, len);
}

void
XftRenderString16 (Display *dpy, Picture src, 
		   XftFontStruct *font, Picture dst,
		   int srcx, int srcy,
		   int x, int y,
		   XftChar16 *string, int len)
{
    XftChar32	    missing[XFT_NMISSING];
    int		    nmissing;
    XftChar16	    *s;
    int		    l;

    s = string;
    l = len;
    nmissing = 0;
    while (l--)
	XftGlyphCheck (dpy, font, (XftChar32) *s++, missing, &nmissing);
    if (nmissing)
	XftGlyphLoad (dpy, font, missing, nmissing);
    XRenderCompositeString16 (dpy, PictOpOver, src, dst,
			      font->format, font->glyphset,
			      srcx, srcy, x, y, string, len);
}

void
XftRenderString32 (Display *dpy, Picture src, 
		   XftFontStruct *font, Picture dst,
		   int srcx, int srcy,
		   int x, int y,
		   XftChar32 *string, int len)
{
    XftChar32	    missing[XFT_NMISSING];
    int		    nmissing;
    XftChar32	    *s;
    int		    l;

    s = string;
    l = len;
    nmissing = 0;
    while (l--)
	XftGlyphCheck (dpy, font, (XftChar32) *s++, missing, &nmissing);
    if (nmissing)
	XftGlyphLoad (dpy, font, missing, nmissing);
    XRenderCompositeString32 (dpy, PictOpOver, src, dst,
			      font->format, font->glyphset,
			      srcx, srcy, x, y, string, len);
}

void
XftRenderStringUtf8 (Display *dpy, Picture src, 
		     XftFontStruct *font, Picture dst,
		     int srcx, int srcy,
		     int x, int y,
		     XftChar8 *string, int len)
{
    XftChar8	*s;
    XftChar32	c;
    XftChar32	lbuf[4096];
    XftChar32	*d;
    XftChar8	*dst8;
    XftChar16	*dst16;
    XftChar32	*dst32;
    int		rlen, clen;
    int		width = 1;
    int		n;

    /* compute needed width */
    if (!XftUtf8Len (string, len, &n, &width))
	return;
    
    d = lbuf;
    if (n * width > sizeof (lbuf))
    {
	d = (XftChar32 *) malloc (n * width);
	if (!d)
	    return;
    }
    
    switch (width) {
    case 4:
	s = string;
	rlen = len;
	dst32 = d;
	while (rlen)
	{
	    clen = XftUtf8ToUcs4 (s, &c, rlen);
	    if (clen <= 0)	/* malformed UTF8 string */
		return;
	    *dst32++ = c;
	    s += clen;
	    rlen -= clen;
	}
	dst32 = d;
	XftRenderString32 (dpy, src, font, dst, srcx, srcy, x, y,
			 dst32, n);
	break;
    case 2:
	s = string;
	rlen = len;
	dst16 = (XftChar16 *) d;
	while (rlen)
	{
	    clen = XftUtf8ToUcs4 (s, &c, rlen);
	    if (clen <= 0)	/* malformed UTF8 string */
		return;
	    *dst16++ = c;
	    s += clen;
	    rlen -= clen;
	}
	dst16 = (XftChar16 *) d;
	XftRenderString16 (dpy, src, font, dst, srcx, srcy, x, y,
			   dst16, n);
	break;
    case 1:
	s = string;
	rlen = len;
	dst8 = (XftChar8 *) d;
	while (rlen)
	{
	    clen = XftUtf8ToUcs4 (s, &c, rlen);
	    if (clen <= 0)	/* malformed UTF8 string */
		return;
	    *dst8++ = c;
	    s += clen;
	    rlen -= clen;
	}
	dst8 = (XftChar8 *) d;
	XftRenderString8 (dpy, src, font, dst, srcx, srcy, x, y,
			  dst8, n);
	break;
    }
    if (d != lbuf)
	free (d);
}
   
void
XftRenderExtents8 (Display	    *dpy,
		   XftFontStruct    *font,
		   XftChar8    *string, 
		   int		    len,
		   XGlyphInfo	    *extents)
{
    XftChar32	    missing[XFT_NMISSING];
    int		    nmissing;
    XftChar8	    *s, c;
    int		    l;
    XGlyphInfo	    *gi;
    int		    x, y;
    int		    left, right, top, bottom;
    int		    overall_left, overall_right;
    int		    overall_top, overall_bottom;

    s = string;
    l = len;
    nmissing = 0;
    while (l--)
	XftGlyphCheck (dpy, font, (XftChar32) *s++, missing, &nmissing);
    if (nmissing)
	XftGlyphLoad (dpy, font, missing, nmissing);
    
    gi = 0;
    while (len)
    {
	c = *string++;
	len--;
	gi = c < font->nrealized ? font->realized[c] : 0;
	if (gi)
	    break;
    }
    if (len == 0 && !gi)
    {
	extents->width = 0;
	extents->height = 0;
	extents->x = 0;
	extents->y = 0;
	extents->yOff = 0;
	extents->xOff = 0;
	return;
    }
    x = 0;
    y = 0;
    overall_left = x - gi->x;
    overall_top = y - gi->y;
    overall_right = overall_left + (int) gi->width;
    overall_bottom = overall_top + (int) gi->height;
    x += gi->xOff;
    y += gi->yOff;
    while (len--)
    {
	c = *string++;
	gi = c < font->nrealized ? font->realized[c] : 0;
	if (!gi)
	    continue;
	left = x - gi->x;
	top = y - gi->y;
	right = left + (int) gi->width;
	bottom = top + (int) gi->height;
	if (left < overall_left)
	    overall_left = left;
	if (top < overall_top)
	    overall_top = top;
	if (right > overall_right)
	    overall_right = right;
	if (bottom > overall_bottom)
	    overall_bottom = bottom;
	x += gi->xOff;
	y += gi->yOff;
    }
    extents->x = -overall_left;
    extents->y = -overall_top;
    extents->width = overall_right - overall_left;
    extents->height = overall_bottom - overall_top;
    extents->xOff = x;
    extents->yOff = y;
}

void
XftRenderExtents16 (Display	    *dpy,
		    XftFontStruct   *font,
		    XftChar16	    *string,
		    int		    len,
		    XGlyphInfo	    *extents)
{
    XftChar32	    missing[XFT_NMISSING];
    int		    nmissing;
    XftChar16	    *s, c;
    int		    l;
    XGlyphInfo	    *gi;
    int		    x, y;
    int		    left, right, top, bottom;
    int		    overall_left, overall_right;
    int		    overall_top, overall_bottom;

    s = string;
    l = len;
    nmissing = 0;
    while (l--)
	XftGlyphCheck (dpy, font, (XftChar32) *s++, missing, &nmissing);
    if (nmissing)
	XftGlyphLoad (dpy, font, missing, nmissing);
    
    gi = 0;
    while (len)
    {
	c = *string++;
	len--;
	gi = c < font->nrealized ? font->realized[c] : 0;
	if (gi)
	    break;
    }
    if (len == 0 && !gi)
    {
	extents->width = 0;
	extents->height = 0;
	extents->x = 0;
	extents->y = 0;
	extents->yOff = 0;
	extents->xOff = 0;
	return;
    }
    x = 0;
    y = 0;
    overall_left = x - gi->x;
    overall_top = y - gi->y;
    overall_right = overall_left + (int) gi->width;
    overall_bottom = overall_top + (int) gi->height;
    x += gi->xOff;
    y += gi->yOff;
    while (len--)
    {
	c = *string++;
	gi = c < font->nrealized ? font->realized[c] : 0;
	if (!gi)
	    continue;
	left = x - gi->x;
	top = y - gi->y;
	right = left + (int) gi->width;
	bottom = top + (int) gi->height;
	if (left < overall_left)
	    overall_left = left;
	if (top < overall_top)
	    overall_top = top;
	if (right > overall_right)
	    overall_right = right;
	if (bottom > overall_bottom)
	    overall_bottom = bottom;
	x += gi->xOff;
	y += gi->yOff;
    }
    extents->x = -overall_left;
    extents->y = -overall_top;
    extents->width = overall_right - overall_left;
    extents->height = overall_bottom - overall_top;
    extents->xOff = x;
    extents->yOff = y;
}

void
XftRenderExtents32 (Display	    *dpy,
		    XftFontStruct   *font,
		    XftChar32	    *string,
		    int		    len,
		    XGlyphInfo	    *extents)
{
    XftChar32	    missing[XFT_NMISSING];
    int		    nmissing;
    XftChar32	    *s, c;
    int		    l;
    XGlyphInfo	    *gi;
    int		    x, y;
    int		    left, right, top, bottom;
    int		    overall_left, overall_right;
    int		    overall_top, overall_bottom;

    s = string;
    l = len;
    nmissing = 0;
    while (l--)
	XftGlyphCheck (dpy, font, (XftChar32) *s++, missing, &nmissing);
    if (nmissing)
	XftGlyphLoad (dpy, font, missing, nmissing);
    
    gi = 0;
    while (len)
    {
	c = *string++;
	len--;
	gi = c < font->nrealized ? font->realized[c] : 0;
	if (gi)
	    break;
    }
    if (len == 0 && !gi)
    {
	extents->width = 0;
	extents->height = 0;
	extents->x = 0;
	extents->y = 0;
	extents->yOff = 0;
	extents->xOff = 0;
	return;
    }
    x = 0;
    y = 0;
    overall_left = x - gi->x;
    overall_top = y - gi->y;
    overall_right = overall_left + (int) gi->width;
    overall_bottom = overall_top + (int) gi->height;
    x += gi->xOff;
    y += gi->yOff;
    while (len--)
    {
	c = *string++;
	gi = c < font->nrealized ? font->realized[c] : 0;
	if (!gi)
	    continue;
	left = x - gi->x;
	top = y - gi->y;
	right = left + (int) gi->width;
	bottom = top + (int) gi->height;
	if (left < overall_left)
	    overall_left = left;
	if (top < overall_top)
	    overall_top = top;
	if (right > overall_right)
	    overall_right = right;
	if (bottom > overall_bottom)
	    overall_bottom = bottom;
	x += gi->xOff;
	y += gi->yOff;
    }
    extents->x = -overall_left;
    extents->y = -overall_top;
    extents->width = overall_right - overall_left;
    extents->height = overall_bottom - overall_top;
    extents->xOff = x;
    extents->yOff = y;
}

void
XftRenderExtentsUtf8 (Display	    *dpy,
		      XftFontStruct *font,
		      XftChar8	    *string, 
		      int	    len,
		      XGlyphInfo    *extents)
{
    XftChar32	    missing[XFT_NMISSING];
    int		    nmissing;
    XftChar8	    *s;
    XftChar32	    c;
    int		    l, clen;
    XGlyphInfo	    *gi;
    int		    x, y;
    int		    left, right, top, bottom;
    int		    overall_left, overall_right;
    int		    overall_top, overall_bottom;

    s = string;
    l = len;
    nmissing = 0;
    while (l)
    {
	clen = XftUtf8ToUcs4 (s, &c, l);
	if (clen < 0)
	    break;
	XftGlyphCheck (dpy, font, (XftChar32) c, missing, &nmissing);
	s += clen;
	l -= clen;
    }
    if (nmissing)
	XftGlyphLoad (dpy, font, missing, nmissing);
    
    gi = 0;
    while (len)
    {
	clen = XftUtf8ToUcs4 (string, &c, len);
	if (clen < 0)
	{
	    len = 0;
	    break;
	}
	len -= clen;
	string += clen;
	gi = c < font->nrealized ? font->realized[c] : 0;
	if (gi)
	    break;
    }
    if (len == 0 && !gi)
    {
	extents->width = 0;
	extents->height = 0;
	extents->x = 0;
	extents->y = 0;
	extents->yOff = 0;
	extents->xOff = 0;
	return;
    }
    x = 0;
    y = 0;
    overall_left = x - gi->x;
    overall_top = y - gi->y;
    overall_right = overall_left + (int) gi->width;
    overall_bottom = overall_top + (int) gi->height;
    x += gi->xOff;
    y += gi->yOff;
    while (len)
    {
	clen = XftUtf8ToUcs4 (string, &c, len);
	if (clen < 0)
	    break;
	len -= clen;
	string += clen;
	gi = c < font->nrealized ? font->realized[c] : 0;
	if (!gi)
	    continue;
	left = x - gi->x;
	top = y - gi->y;
	right = left + (int) gi->width;
	bottom = top + (int) gi->height;
	if (left < overall_left)
	    overall_left = left;
	if (top < overall_top)
	    overall_top = top;
	if (right > overall_right)
	    overall_right = right;
	if (bottom > overall_bottom)
	    overall_bottom = bottom;
	x += gi->xOff;
	y += gi->yOff;
    }
    extents->x = -overall_left;
    extents->y = -overall_top;
    extents->width = overall_right - overall_left;
    extents->height = overall_bottom - overall_top;
    extents->xOff = x;
    extents->yOff = y;
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d2 1
a2 1
 * $XFree86: xc/lib/Xft/xftrender.c,v 1.15 2002/12/14 01:59:38 dawes Exp $
a27 7
#define NUM_LOCAL	1024
#define NUM_ELT_LOCAL	128

/*
 * Use the Render extension to draw the glyphs
 */

d29 5
a33 11
XftGlyphRender (Display		*dpy,
		int		op,
		Picture		src,
		XftFont		*pub,
		Picture		dst,
		int		srcx,
		int		srcy,
		int		x,
		int		y,
		_Xconst FT_UInt	*glyphs,
		int		nglyphs)
d35 1
a35 3
    XftFontInt	    *font = (XftFontInt *) pub;
    int		    i;
    FT_UInt	    missing[XFT_NMISSING];
d37 5
a41 16
    FT_UInt	    g, max;
    int		    size, width;
    Glyph	    wire;
    char	    *char8;
    unsigned short  *char16;
    unsigned int    *char32;
    unsigned int    char_local[NUM_LOCAL];
    unsigned int    *chars;
    FcBool	    glyphs_loaded;
    
    if (!font->format)
	return;
    
    /*
     * Load missing glyphs
     */
d43 2
a44 10
    max = 0;
    glyphs_loaded = FcFalse;
    for (i = 0; i < nglyphs; i++)
    {
	g = glyphs[i];
	if (g > max)
	    max = g;
	if (XftFontCheckGlyph (dpy, pub, FcTrue, g, missing, &nmissing))
	    glyphs_loaded = FcTrue;
    }
d46 4
a49 63
	XftFontLoadGlyphs (dpy, pub, FcTrue, missing, nmissing);
    
    if (!font->glyphset)
	goto bail1;
    if (max < 0x100)
    {
	width = 1;
	size = sizeof (char);
    }
    else if (max < 0x10000)
    {
	width = 2;
	size = sizeof (unsigned short);
    }
    else
    {
	width = 4;
	size = sizeof (unsigned int);
    }
    chars = char_local;
    if (nglyphs * size > sizeof (char_local))
    {
	chars = malloc (nglyphs * size);
	if (!chars)
	    goto bail1;
    }
    char8 = (char *) chars;
    char16 = (unsigned short *) chars;
    char32 = (unsigned int *) chars;
    for (i = 0; i < nglyphs; i++)
    {
	wire = (Glyph) glyphs[i];
	if (wire >= font->num_glyphs || !font->glyphs[wire])
	    wire = 0;
	switch (width) {
	case 1: char8[i] = (char) wire; break;
	case 2: char16[i] = (unsigned short) wire; break;
	case 4: char32[i] = (unsigned long) wire; break;
	}
    }
    switch (width) {
    case 1:
    default:
	XRenderCompositeString8 (dpy, op,
				 src, dst, font->format, font->glyphset,
				 srcx, srcy, x, y, char8, nglyphs);
	break;
    case 2:
	XRenderCompositeString16(dpy, op,
				 src, dst, font->format, font->glyphset,
				 srcx, srcy, x, y, char16, nglyphs);
	break;
    case 4:
	XRenderCompositeString32(dpy, op,
				 src, dst, font->format, font->glyphset,
				 srcx, srcy, x, y, char32, nglyphs);
	break;
    }
    if (chars != char_local)
	free (chars);
bail1:
    if (glyphs_loaded)
	_XftFontManageMemory (dpy, pub);
d53 5
a57 9
XftGlyphSpecRender (Display		    *dpy,
		    int			    op,
		    Picture		    src,
		    XftFont		    *pub,
		    Picture		    dst,
		    int			    srcx,
		    int			    srcy,
		    _Xconst XftGlyphSpec    *glyphs,
		    int			    nglyphs)
d59 1
a59 3
    XftFontInt	    *font = (XftFontInt *) pub;
    int		    i, j;
    FT_UInt	    missing[XFT_NMISSING];
d61 5
a65 25
    int		    n;
    FT_UInt	    g;
    XftGlyph	    *glyph;
    FT_UInt	    max;
    int		    size, width;
    char	    *char8;
    unsigned short  *char16;
    unsigned int    *char32;
    unsigned int    char_local[NUM_LOCAL];
    unsigned int    *chars;
    XGlyphElt8	    *elts;
    XGlyphElt8	    elts_local[NUM_ELT_LOCAL];
    FcBool	    glyphs_loaded;
    int		    nelt;
    int		    x, y;
    
    if (!font->format)
	return;
    if (!nglyphs)
	return;
    
    /*
     * Load missing glyphs
     */
    max = 0;
d67 2
a68 10
    glyphs_loaded = FcFalse;
    g = glyphs[0].glyph;
    for (i = 0; i < nglyphs; i++)
    {
	g = glyphs[i].glyph;
	if (g > max)
	    max = g;
	if (XftFontCheckGlyph (dpy, pub, FcTrue, g, missing, &nmissing))
	    glyphs_loaded = FcTrue;
    }
d70 4
a73 155
	XftFontLoadGlyphs (dpy, pub, FcTrue, missing, nmissing);
    
    if (!font->glyphset)
	goto bail1;

    /*
     * See what encoding size is needed
     */
    if (max < 0x100)
    {
	size = sizeof (char);
	width = 1;
    }
    else if (max < 0x10000)
    {
	size = sizeof (unsigned short);
	width = 2;
    }
    else
    {
	size = sizeof (unsigned int);
	width = 4;
    }
    chars = char_local;
    if (nglyphs * size > NUM_LOCAL)
    {
	chars = malloc (nglyphs * size);
	if (!chars)
	    goto bail1;
    }
    char8 = (char *) chars;
    char16 = (unsigned short *) chars;
    char32 = (unsigned int *) chars;
    
    /*
     * Compute the number of glyph elts needed
     */
    nelt = 1;
    for (i = 0; i < nglyphs; i++)
    {
	g = glyphs[i].glyph;
	/* Substitute default for non-existant glyphs */
	if (g >= font->num_glyphs || !font->glyphs[g])
	    g = 0;
	if (font->glyphs[g])
	     break;
    }
    if (i == nglyphs)
	goto bail2;
    glyph = font->glyphs[g];
    x = glyphs[i].x + glyph->metrics.xOff;
    y = glyphs[i].y + glyph->metrics.yOff;
    while (++i < nglyphs)
    {
	g = glyphs[i].glyph;
	/* Substitute default for non-existant glyphs */
	if (g >= font->num_glyphs || !font->glyphs[g])
	    g = 0;
	/* 
	 * check to see if the glyph is placed where it would
	 * fall using the normal spacing
	 */
	if ((glyph = font->glyphs[g]))
	{
	    if (x != glyphs[i].x || y != glyphs[i].y)
	    {
		x = glyphs[i].x;
		y = glyphs[i].y;
		++nelt;
	    }
	    x += glyph->metrics.xOff;
	    y += glyph->metrics.yOff;
	}
    }

    elts = elts_local;
    if (nelt > NUM_ELT_LOCAL)
    {
	elts = malloc (nelt * sizeof (XGlyphElt8));
	if (!elts)
	    goto bail2;
    }

    /*
     * Generate the list of glyph elts
     */
    nelt = 0;
    x = y = 0;
    n = 0;
    j = 0;
    for (i = 0; i < nglyphs; i++)
    {
	g = glyphs[i].glyph;
	/* Substitute default for non-existant glyphs */
	if (g >= font->num_glyphs || !font->glyphs[g])
	    g = 0;
	if ((glyph = font->glyphs[g]))
	{
	    if (!i || x != glyphs[i].x || y != glyphs[i].y)
	    {
		if (n)
		{
		    elts[nelt].nchars = n;
		    nelt++;
		}
		elts[nelt].glyphset = font->glyphset;
		elts[nelt].chars = char8 + size * j;
		elts[nelt].xOff = glyphs[i].x - x;
		elts[nelt].yOff = glyphs[i].y - y;
		x = glyphs[i].x;
		y = glyphs[i].y;
		n = 0;
	    }
	    switch (width) {
	    case 1: char8[j] = (char) g; break;
	    case 2: char16[j] = (unsigned short) g; break;
	    case 4: char32[j] = (unsigned int) g; break;
	    }
	    x += glyph->metrics.xOff;
	    y += glyph->metrics.yOff;
	    j++;
	    n++;
	}
    }
    if (n)
    {
	elts[nelt].nchars = n;
	nelt++;
    }
    switch (width) {
    case 1:
	XRenderCompositeText8 (dpy, op, src, dst, font->format,
			       srcx, srcy, glyphs[0].x, glyphs[0].y,
			       elts, nelt);
	break;
    case 2:
	XRenderCompositeText16 (dpy, op, src, dst, font->format,
				srcx, srcy, glyphs[0].x, glyphs[0].y,
				(XGlyphElt16 *) elts, nelt);
	break;
    case 4:
	XRenderCompositeText32 (dpy, op, src, dst, font->format,
				srcx, srcy, glyphs[0].x, glyphs[0].y,
				(XGlyphElt32 *) elts, nelt);
	break;
    }

    if (elts != elts_local)
	free (elts);
bail2:
    if (chars != char_local)
	free (chars);
bail1:
    if (glyphs_loaded)
	_XftFontManageMemory (dpy, pub);
d77 5
a81 9
XftCharSpecRender (Display		*dpy,
		   int			op,
		   Picture		src,
		   XftFont		*pub,
		   Picture		dst,
		   int			srcx, 
		   int			srcy,
		   _Xconst XftCharSpec	*chars,
		   int			len)
d83 4
a86 2
    XftGlyphSpec    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;
d88 10
a97 19
    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
    {
	glyphs = malloc (len * sizeof (XftGlyphSpec));
	if (!glyphs)
	    return;
    }
    for (i = 0; i < len; i++)
    {
	glyphs[i].glyph = XftCharIndex(dpy, pub, chars[i].ucs4);
	glyphs[i].x = chars[i].x;
	glyphs[i].y = chars[i].y;
    }

    XftGlyphSpecRender (dpy, op, src, pub, dst, srcx, srcy, glyphs, len);

    if (glyphs != glyphs_local)
	free (glyphs);
d101 19
a119 31
XftGlyphFontSpecRender (Display			    *dpy,
			int			    op,
			Picture			    src,
			Picture			    dst,
			int			    srcx,
			int			    srcy,
			_Xconst XftGlyphFontSpec    *glyphs,
			int			    nglyphs)
{
    int		    i, j;
    XftFont	    *prevPublic;
    XftFontInt	    *firstFont;
    FT_UInt	    missing[XFT_NMISSING];
    int		    nmissing;
    int		    n;
    FT_UInt	    g;
    XftGlyph	    *glyph;
    FT_UInt	    max;
    int		    size, width;
    char	    *char8;
    unsigned short  *char16;
    unsigned int    *char32;
    unsigned int    char_local[NUM_LOCAL];
    unsigned int    *chars;
    XGlyphElt8	    *elts;
    XGlyphElt8	    elts_local[NUM_ELT_LOCAL];
    FcBool	    glyphs_loaded;
    int		    nelt;
    int		    x, y;
    
    if (!nglyphs)
d122 2
a123 29
    /*
     * Load missing glyphs.  Have to load them
     * one at a time in case the font changes
     */
    max = 0;
    glyphs_loaded = FcFalse;
    g = glyphs[0].glyph;
    for (i = 0; i < nglyphs; i++)
    {
	XftFont	    *pub = glyphs[i].font;
	XftFontInt  *font = (XftFontInt *) pub;
	g = glyphs[i].glyph;
	if (g > max)
	    max = g;
	nmissing = 0;
	if (XftFontCheckGlyph (dpy, pub, FcTrue, g, missing, &nmissing))
	    glyphs_loaded = FcTrue;
	if (nmissing)
	    XftFontLoadGlyphs (dpy, pub, FcTrue, missing, nmissing);
	if (!font->format)
	    goto bail1;
	if (!font->glyphset)
	    goto bail1;
    }
    
    /*
     * See what encoding size is needed
     */
    if (max < 0x100)
d125 3
a127 12
	size = sizeof (char);
	width = 1;
    }
    else if (max < 0x10000)
    {
	size = sizeof (unsigned short);
	width = 2;
    }
    else
    {
	size = sizeof (unsigned int);
	width = 4;
a128 10
    chars = char_local;
    if (nglyphs * size > NUM_LOCAL)
    {
	chars = malloc (nglyphs * size);
	if (!chars)
	    goto bail1;
    }
    char8 = (char *) chars;
    char16 = (unsigned short *) chars;
    char32 = (unsigned int *) chars;
d130 6
a135 14
    /*
     * Compute the number of glyph elts needed
     */
    nelt = 1;
    firstFont = 0;
    for (i = 0; i < nglyphs; i++)
    {
	XftFont	    *pub = glyphs[i].font;
	XftFontInt  *font = (XftFontInt *) pub;
	g = glyphs[i].glyph;
	/* Substitute default for non-existant glyphs */
	if (g >= font->num_glyphs || !font->glyphs[g])
	    g = 0;
	if (font->glyphs[g])
d137 6
a142 2
	    firstFont = font;
	    break;
d144 9
a152 20
    }
    if (i == nglyphs)
	goto bail2;
    glyph = firstFont->glyphs[g];
    x = glyphs[i].x + glyph->metrics.xOff;
    y = glyphs[i].y + glyph->metrics.yOff;
    prevPublic = 0;
    while (++i < nglyphs)
    {
	XftFont	    *pub = glyphs[i].font;
	XftFontInt  *font = (XftFontInt *) pub;
	g = glyphs[i].glyph;
	/* Substitute default for non-existant glyphs */
	if (g >= font->num_glyphs || !font->glyphs[g])
	    g = 0;
	/* 
	 * check to see if the glyph is placed where it would
	 * fall using the normal spacing
	 */
	if ((glyph = font->glyphs[g]))
d154 6
a159 9
	    if (pub != prevPublic || x != glyphs[i].x || y != glyphs[i].y)
	    {
		prevPublic = pub;
		x = glyphs[i].x;
		y = glyphs[i].y;
		++nelt;
	    }
	    x += glyph->metrics.xOff;
	    y += glyph->metrics.yOff;
d161 9
a169 28
    }

    elts = elts_local;
    if (nelt > NUM_ELT_LOCAL)
    {
	elts = malloc (nelt * sizeof (XGlyphElt8));
	if (!elts)
	    goto bail2;
    }

    /*
     * Generate the list of glyph elts
     */
    nelt = 0;
    x = y = 0;
    n = 0;
    j = 0;
    prevPublic = 0;
    for (i = 0; i < nglyphs; i++)
    {
	XftFont	    *pub = glyphs[i].font;
	XftFontInt  *font = (XftFontInt *) pub;
	
	g = glyphs[i].glyph;
	/* Substitute default for non-existant glyphs */
	if (g >= font->num_glyphs || !font->glyphs[g])
	    g = 0;
	if ((glyph = font->glyphs[g]))
d171 6
a176 25
	    if (!i || pub != prevPublic || x != glyphs[i].x || y != glyphs[i].y)
	    {
		if (n)
		{
		    elts[nelt].nchars = n;
		    nelt++;
		}
		elts[nelt].glyphset = font->glyphset;
		elts[nelt].chars = char8 + size * j;
		elts[nelt].xOff = glyphs[i].x - x;
		elts[nelt].yOff = glyphs[i].y - y;
		prevPublic = pub;
		x = glyphs[i].x;
		y = glyphs[i].y;
		n = 0;
	    }
	    switch (width) {
	    case 1: char8[j] = (char) g; break;
	    case 2: char16[j] = (unsigned short) g; break;
	    case 4: char32[j] = (unsigned int) g; break;
	    }
	    x += glyph->metrics.xOff;
	    y += glyph->metrics.yOff;
	    j++;
	    n++;
d178 3
a180 21
    }
    if (n)
    {
	elts[nelt].nchars = n;
	nelt++;
    }
    switch (width) {
    case 1:
	XRenderCompositeText8 (dpy, op, src, dst, firstFont->format,
			       srcx, srcy, glyphs[0].x, glyphs[0].y,
			       elts, nelt);
	break;
    case 2:
	XRenderCompositeText16 (dpy, op, src, dst, firstFont->format,
				srcx, srcy, glyphs[0].x, glyphs[0].y,
				(XGlyphElt16 *) elts, nelt);
	break;
    case 4:
	XRenderCompositeText32 (dpy, op, src, dst, firstFont->format,
				srcx, srcy, glyphs[0].x, glyphs[0].y,
				(XGlyphElt32 *) elts, nelt);
d183 2
a184 10

    if (elts != elts_local)
	free (elts);
bail2:
    if (chars != char_local)
	free (chars);
bail1:
    if (glyphs_loaded)
	for (i = 0; i < nglyphs; i++)
	    _XftFontManageMemory (dpy, glyphs[i].font);
d186 1
a186 1

d188 5
a192 8
XftCharFontSpecRender (Display			*dpy,
		       int			op,
		       Picture			src,
		       Picture			dst,
		       int			srcx,
		       int			srcy,
		       _Xconst XftCharFontSpec	*chars,
		       int			len)
d194 9
a202 2
    XftGlyphFontSpec	*glyphs, glyphs_local[NUM_LOCAL];
    int			i;
d204 10
a213 3
    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d215 5
a219 3
	glyphs = malloc (len * sizeof (XftGlyphFontSpec));
	if (!glyphs)
	    return;
d221 1
a221 1
    for (i = 0; i < len; i++)
d223 7
a229 4
	glyphs[i].font = chars[i].font;
	glyphs[i].glyph = XftCharIndex(dpy, glyphs[i].font, chars[i].ucs4);
	glyphs[i].x = chars[i].x;
	glyphs[i].y = chars[i].y;
d231 35
a265 4

    XftGlyphFontSpecRender (dpy, op, src, dst, srcx, srcy, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
d269 5
a273 11
XftTextRender8 (Display		*dpy,
		int		op,
		Picture		src,
		XftFont		*pub,
		Picture		dst,
		int		srcx,
		int		srcy,
		int		x,
		int		y,
		_Xconst FcChar8	*string,
		int		len)
d275 9
a283 2
    FT_UInt	    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;
d285 10
a294 3
    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d296 5
a300 3
	glyphs = malloc (len * sizeof (FT_UInt));
	if (!glyphs)
	    return;
d302 1
a302 27
    for (i = 0; i < len; i++)
	glyphs[i] = XftCharIndex (dpy, pub, string[i]);
    XftGlyphRender (dpy, op, src, pub, dst, 
		     srcx, srcy, x, y, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
}

void
XftTextRender16 (Display	    *dpy,
		 int		    op,
		 Picture	    src,
		 XftFont	    *pub,
		 Picture	    dst,
		 int		    srcx,
		 int		    srcy,
		 int		    x,
		 int		    y,
		 _Xconst FcChar16   *string,
		 int		    len)
{
    FT_UInt	    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;

    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d304 7
a310 3
	glyphs = malloc (len * sizeof (FT_UInt));
	if (!glyphs)
	    return;
d312 35
a346 6
    for (i = 0; i < len; i++)
	glyphs[i] = XftCharIndex (dpy, pub, string[i]);
    XftGlyphRender (dpy, op, src, pub, dst, 
		     srcx, srcy, x, y, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
d350 5
a354 11
XftTextRender16BE (Display	    *dpy,
		   int		    op,
		   Picture	    src,
		   XftFont	    *pub,
		   Picture	    dst,
		   int		    srcx,
		   int		    srcy,
		   int		    x,
		   int		    y,
		   _Xconst FcChar8  *string,
		   int		    len)
d356 9
a364 2
    FT_UInt	    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;
d366 10
a375 3
    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d377 5
a381 3
	glyphs = malloc (len * sizeof (FT_UInt));
	if (!glyphs)
	    return;
d383 1
a383 28
    for (i = 0; i < len; i++)
	glyphs[i] = XftCharIndex (dpy, pub, 
				  (string[i*2]<<8) | string[i*2+1]);
    XftGlyphRender (dpy, op, src, pub, dst, 
		     srcx, srcy, x, y, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
}

void
XftTextRender16LE (Display	    *dpy,
		   int		    op,
		   Picture	    src,
		   XftFont	    *pub,
		   Picture	    dst,
		   int		    srcx,
		   int		    srcy,
		   int		    x,
		   int		    y,
		   _Xconst FcChar8  *string,
		   int		    len)
{
    FT_UInt	    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;

    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d385 7
a391 3
	glyphs = malloc (len * sizeof (FT_UInt));
	if (!glyphs)
	    return;
d393 35
a427 7
    for (i = 0; i < len; i++)
	glyphs[i] = XftCharIndex (dpy, pub, 
				  string[i*2] | (string[i*2+1]<<8));
    XftGlyphRender (dpy, op, src, pub, dst, 
		     srcx, srcy, x, y, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
d431 5
a435 11
XftTextRender32 (Display	    *dpy,
		 int		    op,
		 Picture	    src,
		 XftFont	    *pub,
		 Picture	    dst,
		 int		    srcx,
		 int		    srcy,
		 int		    x,
		 int		    y,
		 _Xconst FcChar32   *string,
		 int		    len)
d437 10
a446 2
    FT_UInt	    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;
d448 4
a451 3
    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d453 6
a458 3
	glyphs = malloc (len * sizeof (FT_UInt));
	if (!glyphs)
	    return;
d460 5
a464 27
    for (i = 0; i < len; i++)
	glyphs[i] = XftCharIndex (dpy, pub, string[i]);
    XftGlyphRender (dpy, op, src, pub, dst, 
		     srcx, srcy, x, y, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
}

void
XftTextRender32BE (Display	    *dpy,
		   int		    op,
		   Picture	    src,
		   XftFont	    *pub,
		   Picture	    dst,
		   int		    srcx,
		   int		    srcy,
		   int		    x,
		   int		    y,
		   _Xconst FcChar8  *string,
		   int		    len)
{
    FT_UInt	    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;

    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d466 11
a476 3
	glyphs = malloc (len * sizeof (FT_UInt));
	if (!glyphs)
	    return;
d478 1
a478 31
    for (i = 0; i < len; i++)
	glyphs[i] = XftCharIndex (dpy, pub, 
				  (string[i*4] << 24) |
				  (string[i*4+1] << 16) |
				  (string[i*4+2] << 8) |
				  (string[i*4+3]));
    XftGlyphRender (dpy, op, src, pub, dst, 
		     srcx, srcy, x, y, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
}

void
XftTextRender32LE (Display	    *dpy,
		   int		    op,
		   Picture	    src,
		   XftFont	    *pub,
		   Picture	    dst,
		   int		    srcx,
		   int		    srcy,
		   int		    x,
		   int		    y,
		   _Xconst FcChar8  *string,
		   int		    len)
{
    FT_UInt	    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;

    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d480 7
a486 3
	glyphs = malloc (len * sizeof (FT_UInt));
	if (!glyphs)
	    return;
d488 9
a496 35
    for (i = 0; i < len; i++)
	glyphs[i] = XftCharIndex (dpy, pub, 
				  (string[i*4]) |
				  (string[i*4+1] << 8) |
				  (string[i*4+2] << 16) |
				  (string[i*4+3] << 24));
    XftGlyphRender (dpy, op, src, pub, dst, 
		     srcx, srcy, x, y, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
}

void
XftTextRenderUtf8 (Display	    *dpy,
		   int		    op,
		   Picture	    src,
		   XftFont	    *pub,
		   Picture	    dst,
		   int		    srcx,
		   int		    srcy,
		   int		    x,
		   int		    y,
		   _Xconst FcChar8  *string,
		   int		    len)
{
    FT_UInt	    *glyphs, *glyphs_new, glyphs_local[NUM_LOCAL];
    FcChar32	    ucs4;
    int		    i;
    int		    l;
    int		    size;

    i = 0;
    glyphs = glyphs_local;
    size = NUM_LOCAL;
    while (len && (l = FcUtf8ToUcs4 (string, &ucs4, len)) > 0)
d498 29
a526 73
	if (i == size)
	{
	    glyphs_new = malloc (size * 2 * sizeof (FT_UInt));
	    if (!glyphs_new)
	    {
		if (glyphs != glyphs_local)
		    free (glyphs);
		return;
	    }
	    memcpy (glyphs_new, glyphs, size * sizeof (FT_UInt));
	    size *= 2;
	    if (glyphs != glyphs_local)
		free (glyphs);
	    glyphs = glyphs_new;
	}
	glyphs[i++] = XftCharIndex (dpy, pub, ucs4);
	string += l;
	len -= l;
    }
    XftGlyphRender (dpy, op, src, pub, dst,
		     srcx, srcy, x, y, glyphs, i);
    if (glyphs != glyphs_local)
	free (glyphs);
}

void
XftTextRenderUtf16 (Display	    *dpy,
		    int		    op,
		    Picture	    src,
		    XftFont	    *pub,
		    Picture	    dst,
		    int		    srcx,
		    int		    srcy,
		    int		    x,
		    int		    y,
		    _Xconst FcChar8 *string,
		    FcEndian	    endian,
		    int		    len)
{
    FT_UInt	    *glyphs, *glyphs_new, glyphs_local[NUM_LOCAL];
    FcChar32	    ucs4;
    int		    i;
    int		    l;
    int		    size;

    i = 0;
    glyphs = glyphs_local;
    size = NUM_LOCAL;
    while (len && (l = FcUtf16ToUcs4 (string, endian, &ucs4, len)) > 0)
    {
	if (i == size)
	{
	    glyphs_new = malloc (size * 2 * sizeof (FT_UInt));
	    if (!glyphs_new)
	    {
		if (glyphs != glyphs_local)
		    free (glyphs);
		return;
	    }
	    memcpy (glyphs_new, glyphs, size * sizeof (FT_UInt));
	    size *= 2;
	    if (glyphs != glyphs_local)
		free (glyphs);
	    glyphs = glyphs_new;
	}
	glyphs[i++] = XftCharIndex (dpy, pub, ucs4);
	string += l;
	len -= l;
    }
    XftGlyphRender (dpy, PictOpOver, src, pub, dst,
		     srcx, srcy, x, y, glyphs, i);
    if (glyphs != glyphs_local)
	free (glyphs);
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d2 1
a2 1
 * $XFree86: xc/lib/Xft/xftrender.c,v 1.15 2002/12/14 01:59:38 dawes Exp $
a27 7
#define NUM_LOCAL	1024
#define NUM_ELT_LOCAL	128

/*
 * Use the Render extension to draw the glyphs
 */

d29 5
a33 11
XftGlyphRender (Display		*dpy,
		int		op,
		Picture		src,
		XftFont		*pub,
		Picture		dst,
		int		srcx,
		int		srcy,
		int		x,
		int		y,
		_Xconst FT_UInt	*glyphs,
		int		nglyphs)
d35 1
a35 3
    XftFontInt	    *font = (XftFontInt *) pub;
    int		    i;
    FT_UInt	    missing[XFT_NMISSING];
d37 5
a41 16
    FT_UInt	    g, max;
    int		    size, width;
    Glyph	    wire;
    char	    *char8;
    unsigned short  *char16;
    unsigned int    *char32;
    unsigned int    char_local[NUM_LOCAL];
    unsigned int    *chars;
    FcBool	    glyphs_loaded;
    
    if (!font->format)
	return;
    
    /*
     * Load missing glyphs
     */
d43 2
a44 10
    max = 0;
    glyphs_loaded = FcFalse;
    for (i = 0; i < nglyphs; i++)
    {
	g = glyphs[i];
	if (g > max)
	    max = g;
	if (XftFontCheckGlyph (dpy, pub, FcTrue, g, missing, &nmissing))
	    glyphs_loaded = FcTrue;
    }
d46 4
a49 63
	XftFontLoadGlyphs (dpy, pub, FcTrue, missing, nmissing);
    
    if (!font->glyphset)
	goto bail1;
    if (max < 0x100)
    {
	width = 1;
	size = sizeof (char);
    }
    else if (max < 0x10000)
    {
	width = 2;
	size = sizeof (unsigned short);
    }
    else
    {
	width = 4;
	size = sizeof (unsigned int);
    }
    chars = char_local;
    if (nglyphs * size > sizeof (char_local))
    {
	chars = malloc (nglyphs * size);
	if (!chars)
	    goto bail1;
    }
    char8 = (char *) chars;
    char16 = (unsigned short *) chars;
    char32 = (unsigned int *) chars;
    for (i = 0; i < nglyphs; i++)
    {
	wire = (Glyph) glyphs[i];
	if (wire >= font->num_glyphs || !font->glyphs[wire])
	    wire = 0;
	switch (width) {
	case 1: char8[i] = (char) wire; break;
	case 2: char16[i] = (unsigned short) wire; break;
	case 4: char32[i] = (unsigned long) wire; break;
	}
    }
    switch (width) {
    case 1:
    default:
	XRenderCompositeString8 (dpy, op,
				 src, dst, font->format, font->glyphset,
				 srcx, srcy, x, y, char8, nglyphs);
	break;
    case 2:
	XRenderCompositeString16(dpy, op,
				 src, dst, font->format, font->glyphset,
				 srcx, srcy, x, y, char16, nglyphs);
	break;
    case 4:
	XRenderCompositeString32(dpy, op,
				 src, dst, font->format, font->glyphset,
				 srcx, srcy, x, y, char32, nglyphs);
	break;
    }
    if (chars != char_local)
	free (chars);
bail1:
    if (glyphs_loaded)
	_XftFontManageMemory (dpy, pub);
d53 5
a57 9
XftGlyphSpecRender (Display		    *dpy,
		    int			    op,
		    Picture		    src,
		    XftFont		    *pub,
		    Picture		    dst,
		    int			    srcx,
		    int			    srcy,
		    _Xconst XftGlyphSpec    *glyphs,
		    int			    nglyphs)
d59 1
a59 3
    XftFontInt	    *font = (XftFontInt *) pub;
    int		    i, j;
    FT_UInt	    missing[XFT_NMISSING];
d61 5
a65 25
    int		    n;
    FT_UInt	    g;
    XftGlyph	    *glyph;
    FT_UInt	    max;
    int		    size, width;
    char	    *char8;
    unsigned short  *char16;
    unsigned int    *char32;
    unsigned int    char_local[NUM_LOCAL];
    unsigned int    *chars;
    XGlyphElt8	    *elts;
    XGlyphElt8	    elts_local[NUM_ELT_LOCAL];
    FcBool	    glyphs_loaded;
    int		    nelt;
    int		    x, y;
    
    if (!font->format)
	return;
    if (!nglyphs)
	return;
    
    /*
     * Load missing glyphs
     */
    max = 0;
d67 2
a68 10
    glyphs_loaded = FcFalse;
    g = glyphs[0].glyph;
    for (i = 0; i < nglyphs; i++)
    {
	g = glyphs[i].glyph;
	if (g > max)
	    max = g;
	if (XftFontCheckGlyph (dpy, pub, FcTrue, g, missing, &nmissing))
	    glyphs_loaded = FcTrue;
    }
d70 4
a73 155
	XftFontLoadGlyphs (dpy, pub, FcTrue, missing, nmissing);
    
    if (!font->glyphset)
	goto bail1;

    /*
     * See what encoding size is needed
     */
    if (max < 0x100)
    {
	size = sizeof (char);
	width = 1;
    }
    else if (max < 0x10000)
    {
	size = sizeof (unsigned short);
	width = 2;
    }
    else
    {
	size = sizeof (unsigned int);
	width = 4;
    }
    chars = char_local;
    if (nglyphs * size > NUM_LOCAL)
    {
	chars = malloc (nglyphs * size);
	if (!chars)
	    goto bail1;
    }
    char8 = (char *) chars;
    char16 = (unsigned short *) chars;
    char32 = (unsigned int *) chars;
    
    /*
     * Compute the number of glyph elts needed
     */
    nelt = 1;
    for (i = 0; i < nglyphs; i++)
    {
	g = glyphs[i].glyph;
	/* Substitute default for non-existant glyphs */
	if (g >= font->num_glyphs || !font->glyphs[g])
	    g = 0;
	if (font->glyphs[g])
	     break;
    }
    if (i == nglyphs)
	goto bail2;
    glyph = font->glyphs[g];
    x = glyphs[i].x + glyph->metrics.xOff;
    y = glyphs[i].y + glyph->metrics.yOff;
    while (++i < nglyphs)
    {
	g = glyphs[i].glyph;
	/* Substitute default for non-existant glyphs */
	if (g >= font->num_glyphs || !font->glyphs[g])
	    g = 0;
	/* 
	 * check to see if the glyph is placed where it would
	 * fall using the normal spacing
	 */
	if ((glyph = font->glyphs[g]))
	{
	    if (x != glyphs[i].x || y != glyphs[i].y)
	    {
		x = glyphs[i].x;
		y = glyphs[i].y;
		++nelt;
	    }
	    x += glyph->metrics.xOff;
	    y += glyph->metrics.yOff;
	}
    }

    elts = elts_local;
    if (nelt > NUM_ELT_LOCAL)
    {
	elts = malloc (nelt * sizeof (XGlyphElt8));
	if (!elts)
	    goto bail2;
    }

    /*
     * Generate the list of glyph elts
     */
    nelt = 0;
    x = y = 0;
    n = 0;
    j = 0;
    for (i = 0; i < nglyphs; i++)
    {
	g = glyphs[i].glyph;
	/* Substitute default for non-existant glyphs */
	if (g >= font->num_glyphs || !font->glyphs[g])
	    g = 0;
	if ((glyph = font->glyphs[g]))
	{
	    if (!i || x != glyphs[i].x || y != glyphs[i].y)
	    {
		if (n)
		{
		    elts[nelt].nchars = n;
		    nelt++;
		}
		elts[nelt].glyphset = font->glyphset;
		elts[nelt].chars = char8 + size * j;
		elts[nelt].xOff = glyphs[i].x - x;
		elts[nelt].yOff = glyphs[i].y - y;
		x = glyphs[i].x;
		y = glyphs[i].y;
		n = 0;
	    }
	    switch (width) {
	    case 1: char8[j] = (char) g; break;
	    case 2: char16[j] = (unsigned short) g; break;
	    case 4: char32[j] = (unsigned int) g; break;
	    }
	    x += glyph->metrics.xOff;
	    y += glyph->metrics.yOff;
	    j++;
	    n++;
	}
    }
    if (n)
    {
	elts[nelt].nchars = n;
	nelt++;
    }
    switch (width) {
    case 1:
	XRenderCompositeText8 (dpy, op, src, dst, font->format,
			       srcx, srcy, glyphs[0].x, glyphs[0].y,
			       elts, nelt);
	break;
    case 2:
	XRenderCompositeText16 (dpy, op, src, dst, font->format,
				srcx, srcy, glyphs[0].x, glyphs[0].y,
				(XGlyphElt16 *) elts, nelt);
	break;
    case 4:
	XRenderCompositeText32 (dpy, op, src, dst, font->format,
				srcx, srcy, glyphs[0].x, glyphs[0].y,
				(XGlyphElt32 *) elts, nelt);
	break;
    }

    if (elts != elts_local)
	free (elts);
bail2:
    if (chars != char_local)
	free (chars);
bail1:
    if (glyphs_loaded)
	_XftFontManageMemory (dpy, pub);
d77 5
a81 9
XftCharSpecRender (Display		*dpy,
		   int			op,
		   Picture		src,
		   XftFont		*pub,
		   Picture		dst,
		   int			srcx, 
		   int			srcy,
		   _Xconst XftCharSpec	*chars,
		   int			len)
d83 4
a86 2
    XftGlyphSpec    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;
d88 10
a97 19
    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
    {
	glyphs = malloc (len * sizeof (XftGlyphSpec));
	if (!glyphs)
	    return;
    }
    for (i = 0; i < len; i++)
    {
	glyphs[i].glyph = XftCharIndex(dpy, pub, chars[i].ucs4);
	glyphs[i].x = chars[i].x;
	glyphs[i].y = chars[i].y;
    }

    XftGlyphSpecRender (dpy, op, src, pub, dst, srcx, srcy, glyphs, len);

    if (glyphs != glyphs_local)
	free (glyphs);
d101 19
a119 31
XftGlyphFontSpecRender (Display			    *dpy,
			int			    op,
			Picture			    src,
			Picture			    dst,
			int			    srcx,
			int			    srcy,
			_Xconst XftGlyphFontSpec    *glyphs,
			int			    nglyphs)
{
    int		    i, j;
    XftFont	    *prevPublic;
    XftFontInt	    *firstFont;
    FT_UInt	    missing[XFT_NMISSING];
    int		    nmissing;
    int		    n;
    FT_UInt	    g;
    XftGlyph	    *glyph;
    FT_UInt	    max;
    int		    size, width;
    char	    *char8;
    unsigned short  *char16;
    unsigned int    *char32;
    unsigned int    char_local[NUM_LOCAL];
    unsigned int    *chars;
    XGlyphElt8	    *elts;
    XGlyphElt8	    elts_local[NUM_ELT_LOCAL];
    FcBool	    glyphs_loaded;
    int		    nelt;
    int		    x, y;
    
    if (!nglyphs)
d122 2
a123 29
    /*
     * Load missing glyphs.  Have to load them
     * one at a time in case the font changes
     */
    max = 0;
    glyphs_loaded = FcFalse;
    g = glyphs[0].glyph;
    for (i = 0; i < nglyphs; i++)
    {
	XftFont	    *pub = glyphs[i].font;
	XftFontInt  *font = (XftFontInt *) pub;
	g = glyphs[i].glyph;
	if (g > max)
	    max = g;
	nmissing = 0;
	if (XftFontCheckGlyph (dpy, pub, FcTrue, g, missing, &nmissing))
	    glyphs_loaded = FcTrue;
	if (nmissing)
	    XftFontLoadGlyphs (dpy, pub, FcTrue, missing, nmissing);
	if (!font->format)
	    goto bail1;
	if (!font->glyphset)
	    goto bail1;
    }
    
    /*
     * See what encoding size is needed
     */
    if (max < 0x100)
d125 3
a127 12
	size = sizeof (char);
	width = 1;
    }
    else if (max < 0x10000)
    {
	size = sizeof (unsigned short);
	width = 2;
    }
    else
    {
	size = sizeof (unsigned int);
	width = 4;
a128 10
    chars = char_local;
    if (nglyphs * size > NUM_LOCAL)
    {
	chars = malloc (nglyphs * size);
	if (!chars)
	    goto bail1;
    }
    char8 = (char *) chars;
    char16 = (unsigned short *) chars;
    char32 = (unsigned int *) chars;
d130 6
a135 14
    /*
     * Compute the number of glyph elts needed
     */
    nelt = 1;
    firstFont = 0;
    for (i = 0; i < nglyphs; i++)
    {
	XftFont	    *pub = glyphs[i].font;
	XftFontInt  *font = (XftFontInt *) pub;
	g = glyphs[i].glyph;
	/* Substitute default for non-existant glyphs */
	if (g >= font->num_glyphs || !font->glyphs[g])
	    g = 0;
	if (font->glyphs[g])
d137 6
a142 2
	    firstFont = font;
	    break;
d144 9
a152 20
    }
    if (i == nglyphs)
	goto bail2;
    glyph = firstFont->glyphs[g];
    x = glyphs[i].x + glyph->metrics.xOff;
    y = glyphs[i].y + glyph->metrics.yOff;
    prevPublic = 0;
    while (++i < nglyphs)
    {
	XftFont	    *pub = glyphs[i].font;
	XftFontInt  *font = (XftFontInt *) pub;
	g = glyphs[i].glyph;
	/* Substitute default for non-existant glyphs */
	if (g >= font->num_glyphs || !font->glyphs[g])
	    g = 0;
	/* 
	 * check to see if the glyph is placed where it would
	 * fall using the normal spacing
	 */
	if ((glyph = font->glyphs[g]))
d154 6
a159 9
	    if (pub != prevPublic || x != glyphs[i].x || y != glyphs[i].y)
	    {
		prevPublic = pub;
		x = glyphs[i].x;
		y = glyphs[i].y;
		++nelt;
	    }
	    x += glyph->metrics.xOff;
	    y += glyph->metrics.yOff;
d161 9
a169 28
    }

    elts = elts_local;
    if (nelt > NUM_ELT_LOCAL)
    {
	elts = malloc (nelt * sizeof (XGlyphElt8));
	if (!elts)
	    goto bail2;
    }

    /*
     * Generate the list of glyph elts
     */
    nelt = 0;
    x = y = 0;
    n = 0;
    j = 0;
    prevPublic = 0;
    for (i = 0; i < nglyphs; i++)
    {
	XftFont	    *pub = glyphs[i].font;
	XftFontInt  *font = (XftFontInt *) pub;
	
	g = glyphs[i].glyph;
	/* Substitute default for non-existant glyphs */
	if (g >= font->num_glyphs || !font->glyphs[g])
	    g = 0;
	if ((glyph = font->glyphs[g]))
d171 6
a176 25
	    if (!i || pub != prevPublic || x != glyphs[i].x || y != glyphs[i].y)
	    {
		if (n)
		{
		    elts[nelt].nchars = n;
		    nelt++;
		}
		elts[nelt].glyphset = font->glyphset;
		elts[nelt].chars = char8 + size * j;
		elts[nelt].xOff = glyphs[i].x - x;
		elts[nelt].yOff = glyphs[i].y - y;
		prevPublic = pub;
		x = glyphs[i].x;
		y = glyphs[i].y;
		n = 0;
	    }
	    switch (width) {
	    case 1: char8[j] = (char) g; break;
	    case 2: char16[j] = (unsigned short) g; break;
	    case 4: char32[j] = (unsigned int) g; break;
	    }
	    x += glyph->metrics.xOff;
	    y += glyph->metrics.yOff;
	    j++;
	    n++;
d178 3
a180 21
    }
    if (n)
    {
	elts[nelt].nchars = n;
	nelt++;
    }
    switch (width) {
    case 1:
	XRenderCompositeText8 (dpy, op, src, dst, firstFont->format,
			       srcx, srcy, glyphs[0].x, glyphs[0].y,
			       elts, nelt);
	break;
    case 2:
	XRenderCompositeText16 (dpy, op, src, dst, firstFont->format,
				srcx, srcy, glyphs[0].x, glyphs[0].y,
				(XGlyphElt16 *) elts, nelt);
	break;
    case 4:
	XRenderCompositeText32 (dpy, op, src, dst, firstFont->format,
				srcx, srcy, glyphs[0].x, glyphs[0].y,
				(XGlyphElt32 *) elts, nelt);
d183 2
a184 10

    if (elts != elts_local)
	free (elts);
bail2:
    if (chars != char_local)
	free (chars);
bail1:
    if (glyphs_loaded)
	for (i = 0; i < nglyphs; i++)
	    _XftFontManageMemory (dpy, glyphs[i].font);
d186 1
a186 1

d188 5
a192 8
XftCharFontSpecRender (Display			*dpy,
		       int			op,
		       Picture			src,
		       Picture			dst,
		       int			srcx,
		       int			srcy,
		       _Xconst XftCharFontSpec	*chars,
		       int			len)
d194 9
a202 2
    XftGlyphFontSpec	*glyphs, glyphs_local[NUM_LOCAL];
    int			i;
d204 10
a213 3
    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d215 5
a219 3
	glyphs = malloc (len * sizeof (XftGlyphFontSpec));
	if (!glyphs)
	    return;
d221 1
a221 1
    for (i = 0; i < len; i++)
d223 7
a229 4
	glyphs[i].font = chars[i].font;
	glyphs[i].glyph = XftCharIndex(dpy, glyphs[i].font, chars[i].ucs4);
	glyphs[i].x = chars[i].x;
	glyphs[i].y = chars[i].y;
d231 35
a265 4

    XftGlyphFontSpecRender (dpy, op, src, dst, srcx, srcy, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
d269 5
a273 11
XftTextRender8 (Display		*dpy,
		int		op,
		Picture		src,
		XftFont		*pub,
		Picture		dst,
		int		srcx,
		int		srcy,
		int		x,
		int		y,
		_Xconst FcChar8	*string,
		int		len)
d275 9
a283 2
    FT_UInt	    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;
d285 10
a294 3
    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d296 5
a300 3
	glyphs = malloc (len * sizeof (FT_UInt));
	if (!glyphs)
	    return;
d302 1
a302 27
    for (i = 0; i < len; i++)
	glyphs[i] = XftCharIndex (dpy, pub, string[i]);
    XftGlyphRender (dpy, op, src, pub, dst, 
		     srcx, srcy, x, y, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
}

void
XftTextRender16 (Display	    *dpy,
		 int		    op,
		 Picture	    src,
		 XftFont	    *pub,
		 Picture	    dst,
		 int		    srcx,
		 int		    srcy,
		 int		    x,
		 int		    y,
		 _Xconst FcChar16   *string,
		 int		    len)
{
    FT_UInt	    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;

    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d304 7
a310 3
	glyphs = malloc (len * sizeof (FT_UInt));
	if (!glyphs)
	    return;
d312 35
a346 6
    for (i = 0; i < len; i++)
	glyphs[i] = XftCharIndex (dpy, pub, string[i]);
    XftGlyphRender (dpy, op, src, pub, dst, 
		     srcx, srcy, x, y, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
d350 5
a354 11
XftTextRender16BE (Display	    *dpy,
		   int		    op,
		   Picture	    src,
		   XftFont	    *pub,
		   Picture	    dst,
		   int		    srcx,
		   int		    srcy,
		   int		    x,
		   int		    y,
		   _Xconst FcChar8  *string,
		   int		    len)
d356 9
a364 2
    FT_UInt	    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;
d366 10
a375 3
    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d377 5
a381 3
	glyphs = malloc (len * sizeof (FT_UInt));
	if (!glyphs)
	    return;
d383 1
a383 28
    for (i = 0; i < len; i++)
	glyphs[i] = XftCharIndex (dpy, pub, 
				  (string[i*2]<<8) | string[i*2+1]);
    XftGlyphRender (dpy, op, src, pub, dst, 
		     srcx, srcy, x, y, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
}

void
XftTextRender16LE (Display	    *dpy,
		   int		    op,
		   Picture	    src,
		   XftFont	    *pub,
		   Picture	    dst,
		   int		    srcx,
		   int		    srcy,
		   int		    x,
		   int		    y,
		   _Xconst FcChar8  *string,
		   int		    len)
{
    FT_UInt	    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;

    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d385 7
a391 3
	glyphs = malloc (len * sizeof (FT_UInt));
	if (!glyphs)
	    return;
d393 35
a427 7
    for (i = 0; i < len; i++)
	glyphs[i] = XftCharIndex (dpy, pub, 
				  string[i*2] | (string[i*2+1]<<8));
    XftGlyphRender (dpy, op, src, pub, dst, 
		     srcx, srcy, x, y, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
d431 5
a435 11
XftTextRender32 (Display	    *dpy,
		 int		    op,
		 Picture	    src,
		 XftFont	    *pub,
		 Picture	    dst,
		 int		    srcx,
		 int		    srcy,
		 int		    x,
		 int		    y,
		 _Xconst FcChar32   *string,
		 int		    len)
d437 10
a446 2
    FT_UInt	    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;
d448 4
a451 3
    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d453 6
a458 3
	glyphs = malloc (len * sizeof (FT_UInt));
	if (!glyphs)
	    return;
d460 5
a464 27
    for (i = 0; i < len; i++)
	glyphs[i] = XftCharIndex (dpy, pub, string[i]);
    XftGlyphRender (dpy, op, src, pub, dst, 
		     srcx, srcy, x, y, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
}

void
XftTextRender32BE (Display	    *dpy,
		   int		    op,
		   Picture	    src,
		   XftFont	    *pub,
		   Picture	    dst,
		   int		    srcx,
		   int		    srcy,
		   int		    x,
		   int		    y,
		   _Xconst FcChar8  *string,
		   int		    len)
{
    FT_UInt	    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;

    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d466 11
a476 3
	glyphs = malloc (len * sizeof (FT_UInt));
	if (!glyphs)
	    return;
d478 1
a478 31
    for (i = 0; i < len; i++)
	glyphs[i] = XftCharIndex (dpy, pub, 
				  (string[i*4] << 24) |
				  (string[i*4+1] << 16) |
				  (string[i*4+2] << 8) |
				  (string[i*4+3]));
    XftGlyphRender (dpy, op, src, pub, dst, 
		     srcx, srcy, x, y, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
}

void
XftTextRender32LE (Display	    *dpy,
		   int		    op,
		   Picture	    src,
		   XftFont	    *pub,
		   Picture	    dst,
		   int		    srcx,
		   int		    srcy,
		   int		    x,
		   int		    y,
		   _Xconst FcChar8  *string,
		   int		    len)
{
    FT_UInt	    *glyphs, glyphs_local[NUM_LOCAL];
    int		    i;

    if (len <= NUM_LOCAL)
	glyphs = glyphs_local;
    else
d480 7
a486 3
	glyphs = malloc (len * sizeof (FT_UInt));
	if (!glyphs)
	    return;
d488 9
a496 35
    for (i = 0; i < len; i++)
	glyphs[i] = XftCharIndex (dpy, pub, 
				  (string[i*4]) |
				  (string[i*4+1] << 8) |
				  (string[i*4+2] << 16) |
				  (string[i*4+3] << 24));
    XftGlyphRender (dpy, op, src, pub, dst, 
		     srcx, srcy, x, y, glyphs, len);
    if (glyphs != glyphs_local)
	free (glyphs);
}

void
XftTextRenderUtf8 (Display	    *dpy,
		   int		    op,
		   Picture	    src,
		   XftFont	    *pub,
		   Picture	    dst,
		   int		    srcx,
		   int		    srcy,
		   int		    x,
		   int		    y,
		   _Xconst FcChar8  *string,
		   int		    len)
{
    FT_UInt	    *glyphs, *glyphs_new, glyphs_local[NUM_LOCAL];
    FcChar32	    ucs4;
    int		    i;
    int		    l;
    int		    size;

    i = 0;
    glyphs = glyphs_local;
    size = NUM_LOCAL;
    while (len && (l = FcUtf8ToUcs4 (string, &ucs4, len)) > 0)
d498 29
a526 73
	if (i == size)
	{
	    glyphs_new = malloc (size * 2 * sizeof (FT_UInt));
	    if (!glyphs_new)
	    {
		if (glyphs != glyphs_local)
		    free (glyphs);
		return;
	    }
	    memcpy (glyphs_new, glyphs, size * sizeof (FT_UInt));
	    size *= 2;
	    if (glyphs != glyphs_local)
		free (glyphs);
	    glyphs = glyphs_new;
	}
	glyphs[i++] = XftCharIndex (dpy, pub, ucs4);
	string += l;
	len -= l;
    }
    XftGlyphRender (dpy, op, src, pub, dst,
		     srcx, srcy, x, y, glyphs, i);
    if (glyphs != glyphs_local)
	free (glyphs);
}

void
XftTextRenderUtf16 (Display	    *dpy,
		    int		    op,
		    Picture	    src,
		    XftFont	    *pub,
		    Picture	    dst,
		    int		    srcx,
		    int		    srcy,
		    int		    x,
		    int		    y,
		    _Xconst FcChar8 *string,
		    FcEndian	    endian,
		    int		    len)
{
    FT_UInt	    *glyphs, *glyphs_new, glyphs_local[NUM_LOCAL];
    FcChar32	    ucs4;
    int		    i;
    int		    l;
    int		    size;

    i = 0;
    glyphs = glyphs_local;
    size = NUM_LOCAL;
    while (len && (l = FcUtf16ToUcs4 (string, endian, &ucs4, len)) > 0)
    {
	if (i == size)
	{
	    glyphs_new = malloc (size * 2 * sizeof (FT_UInt));
	    if (!glyphs_new)
	    {
		if (glyphs != glyphs_local)
		    free (glyphs);
		return;
	    }
	    memcpy (glyphs_new, glyphs, size * sizeof (FT_UInt));
	    size *= 2;
	    if (glyphs != glyphs_local)
		free (glyphs);
	    glyphs = glyphs_new;
	}
	glyphs[i++] = XftCharIndex (dpy, pub, ucs4);
	string += l;
	len -= l;
    }
    XftGlyphRender (dpy, PictOpOver, src, pub, dst,
		     srcx, srcy, x, y, glyphs, i);
    if (glyphs != glyphs_local)
	free (glyphs);
@

