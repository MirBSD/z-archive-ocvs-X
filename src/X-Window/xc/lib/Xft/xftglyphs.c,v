head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.04.53;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.04.53;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.32.34;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.04.07;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.19.20;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * $XFree86: xc/lib/Xft/xftglyphs.c,v 1.14 2001/11/17 08:22:45 keithp Exp $
 *
 * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "xftint.h"
#include <freetype/ftoutln.h>

static const int    filters[3][3] = {
    /* red */
#if 0
{    65538*4/7,65538*2/7,65538*1/7 },
    /* green */
{    65536*1/4, 65536*2/4, 65537*1/4 },
    /* blue */
{    65538*1/7,65538*2/7,65538*4/7 },
#endif
{    65538*9/13,65538*3/13,65538*1/13 },
    /* green */
{    65538*1/6, 65538*4/6, 65538*1/6 },
    /* blue */
{    65538*1/13,65538*3/13,65538*9/13 },
};

#define _UntestedGlyph	((XGlyphInfo *) 1)

void
XftGlyphLoad (Display		*dpy,
	      XftFontStruct	*font,
	      XftChar32		*glyphs,
	      int		nglyph)
{
    FT_Error	    error;
    FT_ULong	    charcode;
    FT_UInt	    glyphindex;
    FT_GlyphSlot    glyph;
    XGlyphInfo	    *gi;
    Glyph	    g;
    unsigned char   bufLocal[4096];
    unsigned char   *bufBitmap = bufLocal;
    unsigned char   *b;
    int		    bufSize = sizeof (bufLocal);
    int		    size, pitch;
    unsigned char   bufLocalRgba[4096];
    unsigned char   *bufBitmapRgba = bufLocalRgba;
    int		    bufSizeRgba = sizeof (bufLocalRgba);
    int		    sizergba, pitchrgba, widthrgba;
    int		    width;
    int		    height;
    int		    i;
    int		    left, right, top, bottom;
    int		    hmul = 1;
    int		    vmul = 1;
    FT_Bitmap	    ftbit;
    FT_Matrix	    matrix;
    FT_Vector	    vector;
    Bool	    subpixel = False;

    if (!XftFreeTypeSetFace (font->face, font->size, font->charmap, &font->matrix))
	return ;

    matrix.xx = matrix.yy = 0x10000L;
    matrix.xy = matrix.yx = 0;

    if (font->antialias)
    {
	switch (font->rgba) {
	case XFT_RGBA_RGB:
	case XFT_RGBA_BGR:
	    matrix.xx *= 3;
	    subpixel = True;
	    hmul = 3;
	    break;
	case XFT_RGBA_VRGB:
	case XFT_RGBA_VBGR:
	    matrix.yy *= 3;
	    vmul = 3;
	    subpixel = True;
	    break;
	}
    }

    while (nglyph--)
    {
	charcode = (FT_ULong) *glyphs++;
	gi = font->realized[charcode];
	if (!gi)
	    continue;
	
	if (font->charmap != -1)
	{
	    glyphindex = FT_Get_Char_Index (font->face, charcode);
#if 0	    
	    if (!glyphindex)
	    {
		if (_XftFontDebug() & XFT_DBG_GLYPH)
		    printf ("glyph (%c) %d missing\n",
			    (int) charcode, (int) charcode);
		continue;
	    }
#endif
	}
	else
	    glyphindex = (FT_UInt) charcode;
	error = FT_Load_Glyph (font->face, glyphindex, FT_LOAD_NO_BITMAP);
	if (error)
	    continue;

#define FLOOR(x)    ((x) & -64)
#define CEIL(x)	    (((x)+63) & -64)
#define TRUNC(x)    ((x) >> 6)
#define ROUND(x)    (((x)+32) & -64)
		
	glyph = font->face->glyph;

	if(font->transform) 
	{
	    /*
	     * calculate the true width by transforming all four corners.
	     */
	    int xc, yc;
	    left = right = top = bottom = 0;
	    for(xc = 0; xc <= 1; xc ++) {
		for(yc = 0; yc <= 1; yc++) {
		    vector.x = glyph->metrics.horiBearingX + xc * glyph->metrics.width;
		    vector.y = glyph->metrics.horiBearingY - yc * glyph->metrics.height;
		    FT_Vector_Transform(&vector, &font->matrix);   
		    if (_XftFontDebug() & XFT_DBG_GLYPH)
			printf("Trans %d %d: %d %d\n", (int) xc, (int) yc, 
			       (int) vector.x, (int) vector.y);
		    if(xc == 0 && yc == 0) {
			left = right = vector.x;
			top = bottom = vector.y;
		    } else {
			if(left > vector.x) left = vector.x;
			if(right < vector.x) right = vector.x;
			if(bottom > vector.y) bottom = vector.y;
			if(top < vector.y) top = vector.y;
		    }

		}
	    }
	    left = FLOOR(left);
	    right = CEIL(right);
	    bottom = FLOOR(bottom);
	    top = CEIL(top);

	} else {
	    left  = FLOOR( glyph->metrics.horiBearingX );
	    right = CEIL( glyph->metrics.horiBearingX + glyph->metrics.width );

	    top    = CEIL( glyph->metrics.horiBearingY );
	    bottom = FLOOR( glyph->metrics.horiBearingY - glyph->metrics.height );
	}

	width = TRUNC(right - left);
	height = TRUNC( top - bottom );


	/*
	 * Try to keep monospace fonts ink-inside
	 * XXX transformed?
	 */
	if (font->spacing != XFT_PROPORTIONAL && !font->transform)
	{
	    if (TRUNC(right) > font->max_advance_width)
	    {
		int adjust;

		adjust = right - (font->max_advance_width << 6);
		if (adjust > left)
		    adjust = left;
		left -= adjust;
		right -= adjust;
		width = font->max_advance_width;
	    }
	}

	if ( glyph->format == ft_glyph_format_outline )
	{
	    if (font->antialias)
		pitch = (width * hmul + 3) & ~3;
	    else
		pitch = ((width + 31) & ~31) >> 3;
	    
	    size = pitch * height * vmul;
	    
	    if (size > bufSize)
	    {
		if (bufBitmap != bufLocal)
		    free (bufBitmap);
		bufBitmap = (unsigned char *) malloc (size);
		if (!bufBitmap)
		    continue;
		bufSize = size;
	    }
	    memset (bufBitmap, 0, size);

	    ftbit.width      = width * hmul;
	    ftbit.rows       = height * vmul;
	    ftbit.pitch      = pitch;
	    if (font->antialias)
		ftbit.pixel_mode = ft_pixel_mode_grays;
	    else
		ftbit.pixel_mode = ft_pixel_mode_mono;
	    
	    ftbit.buffer     = bufBitmap;
	    
	    if (subpixel)
		FT_Outline_Transform (&glyph->outline, &matrix);

	    FT_Outline_Translate ( &glyph->outline, -left*hmul, -bottom*vmul );

	    FT_Outline_Get_Bitmap( _XftFTlibrary, &glyph->outline, &ftbit );
	    i = size;
	    b = (unsigned char *) bufBitmap;
	    /*
	     * swap bit order around
	     */
	    if (!font->antialias)
	    {
		if (BitmapBitOrder (dpy) != MSBFirst)
		{
		    unsigned char   *line;
		    unsigned char   c;
		    int		    i;

		    line = (unsigned char *) bufBitmap;
		    i = size;
		    while (i--)
		    {
			c = *line;
			c = ((c << 1) & 0xaa) | ((c >> 1) & 0x55);
			c = ((c << 2) & 0xcc) | ((c >> 2) & 0x33);
			c = ((c << 4) & 0xf0) | ((c >> 4) & 0x0f);
			*line++ = c;
		    }
		}
	    }
	    if (_XftFontDebug() & XFT_DBG_GLYPH)
	    {
		printf ("char 0x%x (%c):\n", (int) charcode, (char) charcode);
		printf (" xywh (%d %d %d %d), trans (%d %d %d %d) wh (%d %d)\n",
			    (int) glyph->metrics.horiBearingX,
			    (int) glyph->metrics.horiBearingY,
			    (int) glyph->metrics.width,
			    (int) glyph->metrics.height,
			    left, right, top, bottom,
			    width, height);
		if (_XftFontDebug() & XFT_DBG_GLYPHV)
		{
		    int		x, y;
		    unsigned char	*line;

		    line = bufBitmap;
		    for (y = 0; y < height * vmul; y++)
		    {
			if (font->antialias) 
			{
			    static char    den[] = { " .:;=+*#" };
			    for (x = 0; x < pitch; x++)
				printf ("%c", den[line[x] >> 5]);
			}
			else
			{
			    for (x = 0; x < pitch * 8; x++)
			    {
				printf ("%c", line[x>>3] & (1 << (x & 7)) ? '#' : ' ');
			    }
			}
			printf ("|\n");
			line += pitch;
		    }
		    printf ("\n");
		}
	    }
	}
	else
	{
	    if (_XftFontDebug() & XFT_DBG_GLYPH)
		printf ("glyph (%c) %d no outline\n",
			(int) charcode, (int) charcode);
	    continue;
	}
	
	gi->width = width;
	gi->height = height;
	gi->x = -TRUNC(left);
	gi->y = TRUNC(top);
	if (font->spacing != XFT_PROPORTIONAL)
	{
	    if (font->transform)
	    {
		vector.x = font->max_advance_width;
		vector.y = 0;
		FT_Vector_Transform (&vector, &font->matrix);
		gi->xOff = vector.x;
		gi->yOff = -vector.y;
	    }
	    else
	    {
		gi->xOff = font->max_advance_width;
		gi->yOff = 0;
	    }
	}
	else
	{
	    gi->xOff = TRUNC(ROUND(glyph->advance.x));
	    gi->yOff = -TRUNC(ROUND(glyph->advance.y));
	}
	g = charcode;

	if (subpixel)
	{
	    int		    x, y;
	    unsigned char   *in_line, *out_line, *in;
	    unsigned int    *out;
	    unsigned int    red, green, blue;
	    int		    rf, gf, bf;
	    int		    s;
	    int		    o, os;
	    
	    widthrgba = width;
	    pitchrgba = (widthrgba * 4 + 3) & ~3;
	    sizergba = pitchrgba * height;

	    os = 1;
	    switch (font->rgba) {
	    case XFT_RGBA_VRGB:
		os = pitch;
	    case XFT_RGBA_RGB:
	    default:
		rf = 0;
		gf = 1;
		bf = 2;
		break;
	    case XFT_RGBA_VBGR:
		os = pitch;
	    case XFT_RGBA_BGR:
		bf = 0;
		gf = 1;
		rf = 2;
		break;
	    }
	    if (sizergba > bufSizeRgba)
	    {
		if (bufBitmapRgba != bufLocalRgba)
		    free (bufBitmapRgba);
		bufBitmapRgba = (unsigned char *) malloc (sizergba);
		if (!bufBitmapRgba)
		    continue;
		bufSizeRgba = sizergba;
	    }
	    memset (bufBitmapRgba, 0, sizergba);
	    in_line = bufBitmap;
	    out_line = bufBitmapRgba;
	    for (y = 0; y < height; y++)
	    {
		in = in_line;
		out = (unsigned int *) out_line;
		in_line += pitch * vmul;
		out_line += pitchrgba;
		for (x = 0; x < width * hmul; x += hmul)
		{
		    red = green = blue = 0;
		    o = 0;
		    for (s = 0; s < 3; s++)
		    {
			red += filters[rf][s]*in[x+o];
			green += filters[gf][s]*in[x+o];
			blue += filters[bf][s]*in[x+o];
			o += os;
		    }
		    red = red / 65536;
		    green = green / 65536;
		    blue = blue / 65536;
		    *out++ = (green << 24) | (red << 16) | (green << 8) | blue;
		}
	    }
	    
	    XRenderAddGlyphs (dpy, font->glyphset, &g, gi, 1, 
			      (char *) bufBitmapRgba, sizergba);
	}
	else
	{
	    XRenderAddGlyphs (dpy, font->glyphset, &g, gi, 1, 
			      (char *) bufBitmap, size);
	}
    }
    if (bufBitmap != bufLocal)
	free (bufBitmap);
    if (bufBitmapRgba != bufLocalRgba)
	free (bufBitmapRgba);
}

#define STEP	    256

/*
 * Return whether the given glyph generates any image on the screen,
 * this means it exists or a default glyph exists
 */
static Bool
XftGlyphDrawable (Display	*dpy,
		  XftFontStruct	*font,
		  XftChar32	glyph)
{
    if (font->charmap != -1)
    {
	FT_Set_Charmap (font->face, font->face->charmaps[font->charmap]);
	glyph = (XftChar32) FT_Get_Char_Index (font->face, (FT_ULong) glyph);
    }
    return glyph <= font->face->num_glyphs;
}
	    
void
XftGlyphCheck (Display		*dpy,
	       XftFontStruct	*font,
	       XftChar32	glyph,
	       XftChar32	*missing,
	       int		*nmissing)
{
    XGlyphInfo	    **realized;
    int		    nrealized;
    int		    n;
    
    if (glyph >= font->nrealized)
    {
	nrealized = glyph + STEP;
	
	if (font->realized)
	    realized = (XGlyphInfo **) realloc ((void *) font->realized,
						nrealized * sizeof (XGlyphInfo *));
	else
	    realized = (XGlyphInfo **) malloc (nrealized * sizeof (XGlyphInfo *));
	if (!realized)
	    return;
	for (n = font->nrealized; n < nrealized; n++)
	    realized[n] = _UntestedGlyph;
	
	font->realized = realized;
	font->nrealized = nrealized;
    }
    if (font->realized[glyph] == _UntestedGlyph)
    {
	if (XftGlyphDrawable (dpy, font, glyph))
	{
	    font->realized[glyph] = (XGlyphInfo *) malloc (sizeof (XGlyphInfo));
	    n = *nmissing;
	    missing[n++] = glyph;
	    if (n == XFT_NMISSING)
	    {
		XftGlyphLoad (dpy, font, missing, n);
		n = 0;
	    }
	    *nmissing = n;
	}
	else
	    font->realized[glyph] = 0;
    }
}

Bool
XftFreeTypeGlyphExists (Display		*dpy,
			XftFontStruct	*font,
			XftChar32	glyph)
{
    if (font->charmap != -1)
    {
	FT_Set_Charmap (font->face, font->face->charmaps[font->charmap]);
	glyph = (XftChar32) FT_Get_Char_Index (font->face, (FT_ULong) glyph);
    }
    return glyph && glyph <= font->face->num_glyphs;
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d2 1
a2 1
 * $XFree86: xc/lib/Xft/xftglyphs.c,v 1.24 2003/11/20 22:36:33 dawes Exp $
d29 1
a29 3
#include <ft2build.h>
#include FT_OUTLINE_H
#include <fontconfig/fcfreetype.h>
d47 1
a47 25
/*
 * Validate the memory info for a font
 */

static void
_XftFontValidateMemory (Display *dpy, XftFont *public)
{
    XftFontInt	    *font = (XftFontInt *) public;
    unsigned long   glyph_memory;
    FT_UInt	    glyphindex;
    XftGlyph	    *xftg;

    glyph_memory = 0;
    for (glyphindex = 0; glyphindex < font->num_glyphs; glyphindex++)
    {
	xftg = font->glyphs[glyphindex];
	if (xftg)
	{
	    glyph_memory += xftg->glyph_memory;
	}
    }
    if (glyph_memory != font->glyph_memory)
	printf ("Font glyph cache incorrect has %ld bytes, should have %ld\n",
		font->glyph_memory, glyph_memory);
}
d50 4
a53 5
XftFontLoadGlyphs (Display	    *dpy,
		   XftFont	    *pub,
		   FcBool	    need_bitmaps,
		   _Xconst FT_UInt  *glyphs,
		   int		    nglyph)
a54 2
    XftDisplayInfo  *info = _XftDisplayInfoGet (dpy, True);
    XftFontInt	    *font = (XftFontInt *) pub;
d56 1
d58 3
a60 3
    FT_GlyphSlot    glyphslot;
    XftGlyph	    *xftg;
    Glyph	    glyph;
d63 1
d72 1
a79 4
    FT_Face	    face;

    if (!info)
	return;
d81 2
a82 4
    face = XftLockFace (&font->public);
    
    if (!face)
	return;
d87 1
a87 1
    if (font->info.antialias)
d89 3
a91 3
	switch (font->info.rgba) {
	case FC_RGBA_RGB:
	case FC_RGBA_BGR:
d96 2
a97 2
	case FC_RGBA_VRGB:
	case FC_RGBA_VBGR:
d107 3
a109 13
	glyphindex = *glyphs++;
	xftg = font->glyphs[glyphindex];
	if (!xftg)
	    continue;
	
	if (XftDebug() & XFT_DBG_CACHE)
	    _XftFontValidateMemory (dpy, pub);
	/*
	 * Check to see if this glyph has just been loaded,
	 * this happens when drawing the same glyph twice
	 * in a single string
	 */
	if (xftg->glyph_memory)
d112 1
a112 2
	error = FT_Load_Glyph (face, glyphindex, font->info.load_flags);
	if (error)
d114 7
a120 10
	    /*
	     * If anti-aliasing or transforming glyphs and
	     * no outline version exists, fallback to the
	     * bitmap and let things look bad instead of
	     * missing the glyph
	     */
	    if (font->info.load_flags & FT_LOAD_NO_BITMAP)
		error = FT_Load_Glyph (face, glyphindex,
				       font->info.load_flags & ~FT_LOAD_NO_BITMAP);
	    if (error)
d122 2
d125 5
d136 1
a136 1
	glyphslot = face->glyph;
d138 1
a138 4
	/*
	 * Compute glyph metrics from FreeType information
	 */
	if(font->info.transform && glyphslot->format != ft_glyph_format_bitmap) 
d147 4
a150 4
		    vector.x = glyphslot->metrics.horiBearingX + xc * glyphslot->metrics.width;
		    vector.y = glyphslot->metrics.horiBearingY - yc * glyphslot->metrics.height;
		    FT_Vector_Transform(&vector, &font->info.matrix);   
		    if (XftDebug() & XFT_DBG_GLYPH)
d171 2
a172 2
	    left  = FLOOR( glyphslot->metrics.horiBearingX );
	    right = CEIL( glyphslot->metrics.horiBearingX + glyphslot->metrics.width );
d174 2
a175 2
	    top    = CEIL( glyphslot->metrics.horiBearingY );
	    bottom = FLOOR( glyphslot->metrics.horiBearingY - glyphslot->metrics.height );
d181 1
d186 1
a186 1
	if (font->info.spacing != FC_PROPORTIONAL && !font->info.transform)
d188 1
a188 1
	    if (font->info.load_flags & FT_LOAD_VERTICAL_LAYOUT)
d190 8
a197 25
		if (TRUNC(bottom) > font->public.max_advance_width)
		{
		    int adjust;
    
		    adjust = bottom - (font->public.max_advance_width << 6);
		    if (adjust > top)
			adjust = top;
		    top -= adjust;
		    bottom -= adjust;
		    height = font->public.max_advance_width;
		}
	    }
	    else
	    {
		if (TRUNC(right) > font->public.max_advance_width)
		{
		    int adjust;
    
		    adjust = right - (font->public.max_advance_width << 6);
		    if (adjust > left)
			adjust = left;
		    left -= adjust;
		    right -= adjust;
		    width = font->public.max_advance_width;
		}
d201 1
a201 13
	if (font->info.antialias)
	    pitch = (width * hmul + 3) & ~3;
	else
	    pitch = ((width + 31) & ~31) >> 3;

	size = pitch * height * vmul;

	xftg->metrics.width = width;
	xftg->metrics.height = height;
	xftg->metrics.x = -TRUNC(left);
	xftg->metrics.y = TRUNC(top);

	if (font->info.spacing != FC_PROPORTIONAL)
d203 2
a204 16
	    if (font->info.transform)
	    {
		if (font->info.load_flags & FT_LOAD_VERTICAL_LAYOUT)
		{
		    vector.x = 0;
		    vector.y = -face->size->metrics.max_advance;
		}
		else
		{
		    vector.x = face->size->metrics.max_advance;
		    vector.y = 0;
		}
		FT_Vector_Transform (&vector, &font->info.matrix);
		xftg->metrics.xOff = vector.x >> 6;
		xftg->metrics.yOff = -(vector.y >> 6);
	    }
d206 5
d212 6
a217 10
		if (font->info.load_flags & FT_LOAD_VERTICAL_LAYOUT)
		{
		    xftg->metrics.xOff = 0;
		    xftg->metrics.yOff = -font->public.max_advance_width;
		}
		else
		{
		    xftg->metrics.xOff = font->public.max_advance_width;
		    xftg->metrics.yOff = 0;
		}
d219 1
a219 27
	}
	else
	{
	    xftg->metrics.xOff = TRUNC(ROUND(glyphslot->advance.x));
	    xftg->metrics.yOff = -TRUNC(ROUND(glyphslot->advance.y));
	}
	
	/*
	 * If the glyph is relatively large (> 1% of server memory),
	 * don't send it until necessary
	 */
	if (!need_bitmaps && size > info->max_glyph_memory / 100)
	    continue;
	
	/*
	 * Make sure there's enough buffer space for the glyph
	 */
	if (size > bufSize)
	{
	    if (bufBitmap != bufLocal)
		free (bufBitmap);
	    bufBitmap = (unsigned char *) malloc (size);
	    if (!bufBitmap)
		continue;
	    bufSize = size;
	}
	memset (bufBitmap, 0, size);
a220 5
	/*
	 * Rasterize into the local buffer
	 */
	switch (glyphslot->format) {
	case ft_glyph_format_outline:
d224 1
a224 1
	    if (font->info.antialias)
d232 1
a232 1
		FT_Outline_Transform (&glyphslot->outline, &matrix);
d234 1
a234 1
	    FT_Outline_Translate ( &glyphslot->outline, -left*hmul, -bottom*vmul );
d236 7
a242 4
	    FT_Outline_Get_Bitmap( _XftFTlibrary, &glyphslot->outline, &ftbit );
	    break;
	case ft_glyph_format_bitmap:
	    if (font->info.antialias)
d244 1
a244 9
		unsigned char	*srcLine, *dstLine;
		int		height;
		int		x;
		int	    h, v;

		srcLine = glyphslot->bitmap.buffer;
		dstLine = bufBitmap;
		height = glyphslot->bitmap.rows;
		while (height--)
d246 7
a252 1
		    for (x = 0; x < glyphslot->bitmap.width; x++)
d254 5
a258 11
			/* always MSB bitmaps */
			unsigned char	a = ((srcLine[x >> 3] & (0x80 >> (x & 7))) ?
					     0xff : 0x00);
			if (subpixel)
			{
			    for (v = 0; v < vmul; v++)
				for (h = 0; h < hmul; h++)
				    dstLine[v * pitch + x*hmul + h] = a;
			}
			else
			    dstLine[x] = a;
a259 2
		    dstLine += pitch * vmul;
		    srcLine += glyphslot->bitmap.pitch;
d262 1
a262 1
	    else
d264 12
a275 2
		unsigned char	*srcLine, *dstLine;
		int		h, bytes;
d277 20
a296 9
		srcLine = glyphslot->bitmap.buffer;
		dstLine = bufBitmap;
		h = glyphslot->bitmap.rows;
		bytes = (glyphslot->bitmap.width + 7) >> 3;
		while (h--)
		{
		    memcpy (dstLine, srcLine, bytes);
		    dstLine += pitch;
		    srcLine += glyphslot->bitmap.pitch;
d299 6
a304 5
	    break;
	default:
	    if (XftDebug() & XFT_DBG_GLYPH)
		printf ("glyph %d is not in a usable format\n",
			(int) glyphindex);
d308 15
a322 11
	if (XftDebug() & XFT_DBG_GLYPH)
	{
	    printf ("glyph %d:\n", (int) glyphindex);
	    printf (" xywh (%d %d %d %d), trans (%d %d %d %d) wh (%d %d)\n",
		    (int) glyphslot->metrics.horiBearingX,
		    (int) glyphslot->metrics.horiBearingY,
		    (int) glyphslot->metrics.width,
		    (int) glyphslot->metrics.height,
		    left, right, top, bottom,
		    width, height);
	    if (XftDebug() & XFT_DBG_GLYPHV)
d324 2
a325 23
		int		x, y;
		unsigned char	*line;

		line = bufBitmap;
		for (y = 0; y < height * vmul; y++)
		{
		    if (font->info.antialias) 
		    {
			static char    den[] = { " .:;=+*#" };
			for (x = 0; x < pitch; x++)
			    printf ("%c", den[line[x] >> 5]);
		    }
		    else
		    {
			for (x = 0; x < pitch * 8; x++)
			{
			    printf ("%c", line[x>>3] & (1 << (x & 7)) ? '#' : ' ');
			}
		    }
		    printf ("|\n");
		    line += pitch;
		}
		printf ("\n");
d328 6
a333 9

	/*
	 * Use the glyph index as the wire encoding; it
	 * might be more efficient for some locales to map
	 * these by first usage to smaller values, but that
	 * would require persistently storing the map when
	 * glyphs were freed.
	 */
	glyph = (Glyph) glyphindex;
a344 3
	    /*
	     * Filter the glyph to soften the color fringes
	     */
d350 2
a351 2
	    switch (font->info.rgba) {
	    case FC_RGBA_VRGB:
d353 1
a353 1
	    case FC_RGBA_RGB:
d359 1
a359 1
	    case FC_RGBA_VBGR:
d361 1
a361 1
	    case FC_RGBA_BGR:
d403 2
a404 17
	    xftg->glyph_memory = sizergba + sizeof (XftGlyph);
	    if (font->format)
	    {
		if (!font->glyphset)
		    font->glyphset = XRenderCreateGlyphSet (dpy, font->format);
		if (ImageByteOrder (dpy) != XftNativeByteOrder ())
		    XftSwapCARD32 ((CARD32 *) bufBitmapRgba, sizergba >> 2);
		XRenderAddGlyphs (dpy, font->glyphset, &glyph,
				  &xftg->metrics, 1, 
				  (char *) bufBitmapRgba, sizergba);
	    }
	    else
	    {
		xftg->bitmap = malloc (sizergba);
		if (xftg->bitmap)
		    memcpy (xftg->bitmap, bufBitmapRgba, sizergba);
	    }
d408 2
a409 38
	    xftg->glyph_memory = size + sizeof (XftGlyph);
	    if (font->format)
	    {
		/*
		 * swap bit order around; FreeType is always MSBFirst
		 */
		if (!font->info.antialias)
		{
		    if (BitmapBitOrder (dpy) != MSBFirst)
		    {
			unsigned char   *line;
			unsigned char   c;
			int		    i;

			line = (unsigned char *) bufBitmap;
			i = size;
			while (i--)
			{
			    c = *line;
			    c = ((c << 1) & 0xaa) | ((c >> 1) & 0x55);
			    c = ((c << 2) & 0xcc) | ((c >> 2) & 0x33);
			    c = ((c << 4) & 0xf0) | ((c >> 4) & 0x0f);
			    *line++ = c;
			}
		    }
		}
		if (!font->glyphset)
		    font->glyphset = XRenderCreateGlyphSet (dpy, font->format);
		XRenderAddGlyphs (dpy, font->glyphset, &glyph,
				  &xftg->metrics, 1, 
				  (char *) bufBitmap, size);
	    }
	    else
	    {
		xftg->bitmap = malloc (size);
		if (xftg->bitmap)
		    memcpy (xftg->bitmap, bufBitmap, size);
	    }
a410 7
	font->glyph_memory += xftg->glyph_memory;
	info->glyph_memory += xftg->glyph_memory;
	if (XftDebug() & XFT_DBG_CACHE)
	    _XftFontValidateMemory (dpy, pub);
	if (XftDebug() & XFT_DBG_CACHEV)
	    printf ("Caching glyph 0x%x size %ld\n", glyphindex,
		    xftg->glyph_memory);
a415 93
    XftUnlockFace (&font->public);
}

void
XftFontUnloadGlyphs (Display		*dpy,
		     XftFont		*pub,
		     _Xconst FT_UInt	*glyphs,
		     int		nglyph)
{
    XftDisplayInfo  *info = _XftDisplayInfoGet (dpy, False);
    XftFontInt	    *font = (XftFontInt *) pub;
    XftGlyph	    *xftg;
    FT_UInt	    glyphindex;
    Glyph	    glyphBuf[1024];
    int		    nused;
    
    nused = 0;
    while (nglyph--)
    {
	glyphindex = *glyphs++;
	xftg = font->glyphs[glyphindex];
	if (!xftg)
	    continue;
	if (xftg->glyph_memory)
	{
	    if (font->format)
	    {
		if (font->glyphset)
		{
		    glyphBuf[nused++] = (Glyph) glyphindex;
		    if (nused == sizeof (glyphBuf) / sizeof (glyphBuf[0]))
		    {
			XRenderFreeGlyphs (dpy, font->glyphset, glyphBuf, nused);
			nused = 0;
		    }
		}
	    }
	    else
	    {
		if (xftg->bitmap)
		    free (xftg->bitmap);
	    }
	    font->glyph_memory -= xftg->glyph_memory;
	    if (info)
		info->glyph_memory -= xftg->glyph_memory;
	}
	free (xftg);
	XftMemFree (XFT_MEM_GLYPH, sizeof (XftGlyph));
	font->glyphs[glyphindex] = 0;
    }    
    if (font->glyphset && nused)
	XRenderFreeGlyphs (dpy, font->glyphset, glyphBuf, nused);
}

FcBool
XftFontCheckGlyph (Display	*dpy,
		   XftFont	*pub,
		   FcBool	need_bitmaps,
		   FT_UInt	glyph,
		   FT_UInt	*missing,
		   int		*nmissing)
{
    XftFontInt	    *font = (XftFontInt *) pub;
    XftGlyph	    *xftg;
    int		    n;
    
    if (glyph >= font->num_glyphs)
	return FcFalse;
    xftg = font->glyphs[glyph];
    if (!xftg || (need_bitmaps && !xftg->glyph_memory))
    {
	if (!xftg)
	{
	    xftg = (XftGlyph *) malloc (sizeof (XftGlyph));
	    if (!xftg)
		return FcFalse;
	    XftMemAlloc (XFT_MEM_GLYPH, sizeof (XftGlyph));
	    xftg->bitmap = 0;
	    xftg->glyph_memory = 0;
	    font->glyphs[glyph] = xftg;
	}
	n = *nmissing;
	missing[n++] = glyph;
	if (n == XFT_NMISSING)
	{
	    XftFontLoadGlyphs (dpy, pub, need_bitmaps, missing, n);
	    n = 0;
	}
	*nmissing = n;
	return FcTrue;
    }
    else
	return FcFalse;
d418 1
a418 9
FcBool
XftCharExists (Display	    *dpy,
	       XftFont	    *pub,
	       FcChar32    ucs4)
{
    if (pub->charset)
	return FcCharSetHasChar (pub->charset, ucs4);
    return FcFalse;
}
d420 8
a427 6
#define Missing	    ((FT_UInt) ~0)

FT_UInt
XftCharIndex (Display	    *dpy, 
	      XftFont	    *pub,
	      FcChar32	    ucs4)
d429 1
a429 10
    XftFontInt	*font = (XftFontInt *) pub;
    FcChar32	ent, offset;
    FT_Face	face;
    
    if (!font->hash_value)
	return 0;

    ent = ucs4 % font->hash_value;
    offset = 0;
    while (font->hash_table[ent].ucs4 != ucs4)
d431 2
a432 21
	if (font->hash_table[ent].ucs4 == (FcChar32) ~0)
	{
	    if (!XftCharExists (dpy, pub, ucs4))
		return 0;
	    face  = XftLockFace (pub);
	    if (!face)
		return 0;
	    font->hash_table[ent].ucs4 = ucs4;
	    font->hash_table[ent].glyph = FcFreeTypeCharIndex (face, ucs4);
	    XftUnlockFace (pub);
	    break;
	}
	if (!offset)
	{
	    offset = ucs4 % font->rehash_value;
	    if (!offset)
		offset = 1;
	}
	ent = ent + offset;
	if (ent > font->hash_value)
	    ent -= font->hash_value;
d434 1
a434 1
    return font->hash_table[ent].glyph;
d436 1
a436 4

/*
 * Pick a random glyph from the font and remove it from the cache
 */
d438 5
a442 1
_XftFontUncacheGlyph (Display *dpy, XftFont *pub)
d444 3
a446 4
    XftFontInt	    *font = (XftFontInt *) pub;
    unsigned long   glyph_memory;
    FT_UInt	    glyphindex;
    XftGlyph	    *xftg;
d448 1
a448 3
    if (!font->glyph_memory)
	return;
    if (font->use_free_glyphs)
d450 14
a463 1
	glyph_memory = rand() % font->glyph_memory;
d465 1
a465 1
    else
d467 1
a467 1
	if (font->glyphset)
d469 4
a472 14
	    XRenderFreeGlyphSet (dpy, font->glyphset);
	    font->glyphset = 0;
	}
	glyph_memory = 0;
    }
	
    if (XftDebug() & XFT_DBG_CACHE)
	_XftFontValidateMemory (dpy, pub);
    for (glyphindex = 0; glyphindex < font->num_glyphs; glyphindex++)
    {
	xftg = font->glyphs[glyphindex];
	if (xftg)
	{
	    if (xftg->glyph_memory > glyph_memory)
d474 2
a475 7
		if (XftDebug() & XFT_DBG_CACHEV)
		    printf ("Uncaching glyph 0x%x size %ld\n",
			    glyphindex, xftg->glyph_memory);
		XftFontUnloadGlyphs (dpy, pub, &glyphindex, 1);
		if (!font->use_free_glyphs)
		    continue;
		break;
d477 1
a477 1
	    glyph_memory -= xftg->glyph_memory;
d479 2
a481 2
    if (XftDebug() & XFT_DBG_CACHE)
	_XftFontValidateMemory (dpy, pub);
d484 4
a487 2
void
_XftFontManageMemory (Display *dpy, XftFont *pub)
d489 1
a489 3
    XftFontInt	*font = (XftFontInt *) pub;

    if (font->max_glyph_memory)
d491 2
a492 9
	if (XftDebug() & XFT_DBG_CACHE)
	{
	    if (font->glyph_memory > font->max_glyph_memory)
		printf ("Reduce memory for font 0x%lx from %ld to %ld\n",
			font->glyphset ? font->glyphset : (unsigned long) font,
			font->glyph_memory, font->max_glyph_memory);
	}
	while (font->glyph_memory > font->max_glyph_memory)
	    _XftFontUncacheGlyph (dpy, pub);
d494 1
a494 1
    _XftDisplayManageMemory (dpy);
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d2 1
a2 1
 * $XFree86: xc/lib/Xft/xftglyphs.c,v 1.23 2002/10/11 17:53:02 keithp Exp $
a29 1
#include <fontconfig/fcfreetype.h>
d47 1
a47 25
/*
 * Validate the memory info for a font
 */

static void
_XftFontValidateMemory (Display *dpy, XftFont *public)
{
    XftFontInt	    *font = (XftFontInt *) public;
    unsigned long   glyph_memory;
    FT_UInt	    glyphindex;
    XftGlyph	    *xftg;

    glyph_memory = 0;
    for (glyphindex = 0; glyphindex < font->num_glyphs; glyphindex++)
    {
	xftg = font->glyphs[glyphindex];
	if (xftg)
	{
	    glyph_memory += xftg->glyph_memory;
	}
    }
    if (glyph_memory != font->glyph_memory)
	printf ("Font glyph cache incorrect has %ld bytes, should have %ld\n",
		font->glyph_memory, glyph_memory);
}
d50 4
a53 5
XftFontLoadGlyphs (Display	    *dpy,
		   XftFont	    *pub,
		   FcBool	    need_bitmaps,
		   _Xconst FT_UInt  *glyphs,
		   int		    nglyph)
a54 2
    XftDisplayInfo  *info = _XftDisplayInfoGet (dpy, True);
    XftFontInt	    *font = (XftFontInt *) pub;
d56 1
d58 3
a60 3
    FT_GlyphSlot    glyphslot;
    XftGlyph	    *xftg;
    Glyph	    glyph;
d63 1
d72 1
a79 4
    FT_Face	    face;

    if (!info)
	return;
d81 2
a82 4
    face = XftLockFace (&font->public);
    
    if (!face)
	return;
d87 1
a87 1
    if (font->info.antialias)
d89 3
a91 3
	switch (font->info.rgba) {
	case FC_RGBA_RGB:
	case FC_RGBA_BGR:
d96 2
a97 2
	case FC_RGBA_VRGB:
	case FC_RGBA_VBGR:
d107 3
a109 13
	glyphindex = *glyphs++;
	xftg = font->glyphs[glyphindex];
	if (!xftg)
	    continue;
	
	if (XftDebug() & XFT_DBG_CACHE)
	    _XftFontValidateMemory (dpy, pub);
	/*
	 * Check to see if this glyph has just been loaded,
	 * this happens when drawing the same glyph twice
	 * in a single string
	 */
	if (xftg->glyph_memory)
d112 1
a112 2
	error = FT_Load_Glyph (face, glyphindex, font->info.load_flags);
	if (error)
d114 7
a120 10
	    /*
	     * If anti-aliasing or transforming glyphs and
	     * no outline version exists, fallback to the
	     * bitmap and let things look bad instead of
	     * missing the glyph
	     */
	    if (font->info.load_flags & FT_LOAD_NO_BITMAP)
		error = FT_Load_Glyph (face, glyphindex,
				       font->info.load_flags & ~FT_LOAD_NO_BITMAP);
	    if (error)
d122 2
d125 5
d136 1
a136 1
	glyphslot = face->glyph;
d138 1
a138 4
	/*
	 * Compute glyph metrics from FreeType information
	 */
	if(font->info.transform && glyphslot->format != ft_glyph_format_bitmap) 
d147 4
a150 4
		    vector.x = glyphslot->metrics.horiBearingX + xc * glyphslot->metrics.width;
		    vector.y = glyphslot->metrics.horiBearingY - yc * glyphslot->metrics.height;
		    FT_Vector_Transform(&vector, &font->info.matrix);   
		    if (XftDebug() & XFT_DBG_GLYPH)
d171 2
a172 2
	    left  = FLOOR( glyphslot->metrics.horiBearingX );
	    right = CEIL( glyphslot->metrics.horiBearingX + glyphslot->metrics.width );
d174 2
a175 2
	    top    = CEIL( glyphslot->metrics.horiBearingY );
	    bottom = FLOOR( glyphslot->metrics.horiBearingY - glyphslot->metrics.height );
d181 1
d186 1
a186 1
	if (font->info.spacing != FC_PROPORTIONAL && !font->info.transform)
d188 1
a188 1
	    if (font->info.load_flags & FT_LOAD_VERTICAL_LAYOUT)
d190 8
a197 25
		if (TRUNC(bottom) > font->public.max_advance_width)
		{
		    int adjust;
    
		    adjust = bottom - (font->public.max_advance_width << 6);
		    if (adjust > top)
			adjust = top;
		    top -= adjust;
		    bottom -= adjust;
		    height = font->public.max_advance_width;
		}
	    }
	    else
	    {
		if (TRUNC(right) > font->public.max_advance_width)
		{
		    int adjust;
    
		    adjust = right - (font->public.max_advance_width << 6);
		    if (adjust > left)
			adjust = left;
		    left -= adjust;
		    right -= adjust;
		    width = font->public.max_advance_width;
		}
d201 1
a201 13
	if (font->info.antialias)
	    pitch = (width * hmul + 3) & ~3;
	else
	    pitch = ((width + 31) & ~31) >> 3;

	size = pitch * height * vmul;

	xftg->metrics.width = width;
	xftg->metrics.height = height;
	xftg->metrics.x = -TRUNC(left);
	xftg->metrics.y = TRUNC(top);

	if (font->info.spacing != FC_PROPORTIONAL)
d203 2
a204 16
	    if (font->info.transform)
	    {
		if (font->info.load_flags & FT_LOAD_VERTICAL_LAYOUT)
		{
		    vector.x = 0;
		    vector.y = -face->size->metrics.max_advance;
		}
		else
		{
		    vector.x = face->size->metrics.max_advance;
		    vector.y = 0;
		}
		FT_Vector_Transform (&vector, &font->info.matrix);
		xftg->metrics.xOff = vector.x >> 6;
		xftg->metrics.yOff = -(vector.y >> 6);
	    }
d206 5
d212 6
a217 10
		if (font->info.load_flags & FT_LOAD_VERTICAL_LAYOUT)
		{
		    xftg->metrics.xOff = 0;
		    xftg->metrics.yOff = -font->public.max_advance_width;
		}
		else
		{
		    xftg->metrics.xOff = font->public.max_advance_width;
		    xftg->metrics.yOff = 0;
		}
d219 1
a219 27
	}
	else
	{
	    xftg->metrics.xOff = TRUNC(ROUND(glyphslot->advance.x));
	    xftg->metrics.yOff = -TRUNC(ROUND(glyphslot->advance.y));
	}
	
	/*
	 * If the glyph is relatively large (> 1% of server memory),
	 * don't send it until necessary
	 */
	if (!need_bitmaps && size > info->max_glyph_memory / 100)
	    continue;
	
	/*
	 * Make sure there's enough buffer space for the glyph
	 */
	if (size > bufSize)
	{
	    if (bufBitmap != bufLocal)
		free (bufBitmap);
	    bufBitmap = (unsigned char *) malloc (size);
	    if (!bufBitmap)
		continue;
	    bufSize = size;
	}
	memset (bufBitmap, 0, size);
a220 5
	/*
	 * Rasterize into the local buffer
	 */
	switch (glyphslot->format) {
	case ft_glyph_format_outline:
d224 1
a224 1
	    if (font->info.antialias)
d232 1
a232 1
		FT_Outline_Transform (&glyphslot->outline, &matrix);
d234 1
a234 1
	    FT_Outline_Translate ( &glyphslot->outline, -left*hmul, -bottom*vmul );
d236 7
a242 4
	    FT_Outline_Get_Bitmap( _XftFTlibrary, &glyphslot->outline, &ftbit );
	    break;
	case ft_glyph_format_bitmap:
	    if (font->info.antialias)
d244 1
a244 9
		unsigned char	*srcLine, *dstLine;
		int		height;
		int		x;
		int	    h, v;

		srcLine = glyphslot->bitmap.buffer;
		dstLine = bufBitmap;
		height = glyphslot->bitmap.rows;
		while (height--)
d246 7
a252 1
		    for (x = 0; x < glyphslot->bitmap.width; x++)
d254 5
a258 11
			/* always MSB bitmaps */
			unsigned char	a = ((srcLine[x >> 3] & (0x80 >> (x & 7))) ?
					     0xff : 0x00);
			if (subpixel)
			{
			    for (v = 0; v < vmul; v++)
				for (h = 0; h < hmul; h++)
				    dstLine[v * pitch + x*hmul + h] = a;
			}
			else
			    dstLine[x] = a;
a259 2
		    dstLine += pitch * vmul;
		    srcLine += glyphslot->bitmap.pitch;
d262 1
a262 1
	    else
d264 12
a275 2
		unsigned char	*srcLine, *dstLine;
		int		h, bytes;
d277 20
a296 9
		srcLine = glyphslot->bitmap.buffer;
		dstLine = bufBitmap;
		h = glyphslot->bitmap.rows;
		bytes = (glyphslot->bitmap.width + 7) >> 3;
		while (h--)
		{
		    memcpy (dstLine, srcLine, bytes);
		    dstLine += pitch;
		    srcLine += glyphslot->bitmap.pitch;
d299 6
a304 5
	    break;
	default:
	    if (XftDebug() & XFT_DBG_GLYPH)
		printf ("glyph %d is not in a usable format\n",
			(int) glyphindex);
d308 15
a322 11
	if (XftDebug() & XFT_DBG_GLYPH)
	{
	    printf ("glyph %d:\n", (int) glyphindex);
	    printf (" xywh (%d %d %d %d), trans (%d %d %d %d) wh (%d %d)\n",
		    (int) glyphslot->metrics.horiBearingX,
		    (int) glyphslot->metrics.horiBearingY,
		    (int) glyphslot->metrics.width,
		    (int) glyphslot->metrics.height,
		    left, right, top, bottom,
		    width, height);
	    if (XftDebug() & XFT_DBG_GLYPHV)
d324 2
a325 23
		int		x, y;
		unsigned char	*line;

		line = bufBitmap;
		for (y = 0; y < height * vmul; y++)
		{
		    if (font->info.antialias) 
		    {
			static char    den[] = { " .:;=+*#" };
			for (x = 0; x < pitch; x++)
			    printf ("%c", den[line[x] >> 5]);
		    }
		    else
		    {
			for (x = 0; x < pitch * 8; x++)
			{
			    printf ("%c", line[x>>3] & (1 << (x & 7)) ? '#' : ' ');
			}
		    }
		    printf ("|\n");
		    line += pitch;
		}
		printf ("\n");
d328 6
a333 9

	/*
	 * Use the glyph index as the wire encoding; it
	 * might be more efficient for some locales to map
	 * these by first usage to smaller values, but that
	 * would require persistently storing the map when
	 * glyphs were freed.
	 */
	glyph = (Glyph) glyphindex;
a344 3
	    /*
	     * Filter the glyph to soften the color fringes
	     */
d350 2
a351 2
	    switch (font->info.rgba) {
	    case FC_RGBA_VRGB:
d353 1
a353 1
	    case FC_RGBA_RGB:
d359 1
a359 1
	    case FC_RGBA_VBGR:
d361 1
a361 1
	    case FC_RGBA_BGR:
d403 2
a404 17
	    xftg->glyph_memory = sizergba + sizeof (XftGlyph);
	    if (font->format)
	    {
		if (!font->glyphset)
		    font->glyphset = XRenderCreateGlyphSet (dpy, font->format);
		if (ImageByteOrder (dpy) != XftNativeByteOrder ())
		    XftSwapCARD32 ((CARD32 *) bufBitmapRgba, sizergba >> 2);
		XRenderAddGlyphs (dpy, font->glyphset, &glyph,
				  &xftg->metrics, 1, 
				  (char *) bufBitmapRgba, sizergba);
	    }
	    else
	    {
		xftg->bitmap = malloc (sizergba);
		if (xftg->bitmap)
		    memcpy (xftg->bitmap, bufBitmapRgba, sizergba);
	    }
d408 2
a409 38
	    xftg->glyph_memory = size + sizeof (XftGlyph);
	    if (font->format)
	    {
		/*
		 * swap bit order around; FreeType is always MSBFirst
		 */
		if (!font->info.antialias)
		{
		    if (BitmapBitOrder (dpy) != MSBFirst)
		    {
			unsigned char   *line;
			unsigned char   c;
			int		    i;

			line = (unsigned char *) bufBitmap;
			i = size;
			while (i--)
			{
			    c = *line;
			    c = ((c << 1) & 0xaa) | ((c >> 1) & 0x55);
			    c = ((c << 2) & 0xcc) | ((c >> 2) & 0x33);
			    c = ((c << 4) & 0xf0) | ((c >> 4) & 0x0f);
			    *line++ = c;
			}
		    }
		}
		if (!font->glyphset)
		    font->glyphset = XRenderCreateGlyphSet (dpy, font->format);
		XRenderAddGlyphs (dpy, font->glyphset, &glyph,
				  &xftg->metrics, 1, 
				  (char *) bufBitmap, size);
	    }
	    else
	    {
		xftg->bitmap = malloc (size);
		if (xftg->bitmap)
		    memcpy (xftg->bitmap, bufBitmap, size);
	    }
a410 7
	font->glyph_memory += xftg->glyph_memory;
	info->glyph_memory += xftg->glyph_memory;
	if (XftDebug() & XFT_DBG_CACHE)
	    _XftFontValidateMemory (dpy, pub);
	if (XftDebug() & XFT_DBG_CACHEV)
	    printf ("Caching glyph 0x%x size %ld\n", glyphindex,
		    xftg->glyph_memory);
a415 93
    XftUnlockFace (&font->public);
}

void
XftFontUnloadGlyphs (Display		*dpy,
		     XftFont		*pub,
		     _Xconst FT_UInt	*glyphs,
		     int		nglyph)
{
    XftDisplayInfo  *info = _XftDisplayInfoGet (dpy, False);
    XftFontInt	    *font = (XftFontInt *) pub;
    XftGlyph	    *xftg;
    FT_UInt	    glyphindex;
    Glyph	    glyphBuf[1024];
    int		    nused;
    
    nused = 0;
    while (nglyph--)
    {
	glyphindex = *glyphs++;
	xftg = font->glyphs[glyphindex];
	if (!xftg)
	    continue;
	if (xftg->glyph_memory)
	{
	    if (font->format)
	    {
		if (font->glyphset)
		{
		    glyphBuf[nused++] = (Glyph) glyphindex;
		    if (nused == sizeof (glyphBuf) / sizeof (glyphBuf[0]))
		    {
			XRenderFreeGlyphs (dpy, font->glyphset, glyphBuf, nused);
			nused = 0;
		    }
		}
	    }
	    else
	    {
		if (xftg->bitmap)
		    free (xftg->bitmap);
	    }
	    font->glyph_memory -= xftg->glyph_memory;
	    if (info)
		info->glyph_memory -= xftg->glyph_memory;
	}
	free (xftg);
	XftMemFree (XFT_MEM_GLYPH, sizeof (XftGlyph));
	font->glyphs[glyphindex] = 0;
    }    
    if (font->glyphset && nused)
	XRenderFreeGlyphs (dpy, font->glyphset, glyphBuf, nused);
}

FcBool
XftFontCheckGlyph (Display	*dpy,
		   XftFont	*pub,
		   FcBool	need_bitmaps,
		   FT_UInt	glyph,
		   FT_UInt	*missing,
		   int		*nmissing)
{
    XftFontInt	    *font = (XftFontInt *) pub;
    XftGlyph	    *xftg;
    int		    n;
    
    if (glyph >= font->num_glyphs)
	return FcFalse;
    xftg = font->glyphs[glyph];
    if (!xftg || (need_bitmaps && !xftg->glyph_memory))
    {
	if (!xftg)
	{
	    xftg = (XftGlyph *) malloc (sizeof (XftGlyph));
	    if (!xftg)
		return FcFalse;
	    XftMemAlloc (XFT_MEM_GLYPH, sizeof (XftGlyph));
	    xftg->bitmap = 0;
	    xftg->glyph_memory = 0;
	    font->glyphs[glyph] = xftg;
	}
	n = *nmissing;
	missing[n++] = glyph;
	if (n == XFT_NMISSING)
	{
	    XftFontLoadGlyphs (dpy, pub, need_bitmaps, missing, n);
	    n = 0;
	}
	*nmissing = n;
	return FcTrue;
    }
    else
	return FcFalse;
d418 1
a418 9
FcBool
XftCharExists (Display	    *dpy,
	       XftFont	    *pub,
	       FcChar32    ucs4)
{
    if (pub->charset)
	return FcCharSetHasChar (pub->charset, ucs4);
    return FcFalse;
}
d420 8
a427 6
#define Missing	    ((FT_UInt) ~0)

FT_UInt
XftCharIndex (Display	    *dpy, 
	      XftFont	    *pub,
	      FcChar32	    ucs4)
d429 1
a429 10
    XftFontInt	*font = (XftFontInt *) pub;
    FcChar32	ent, offset;
    FT_Face	face;
    
    if (!font->hash_value)
	return 0;

    ent = ucs4 % font->hash_value;
    offset = 0;
    while (font->hash_table[ent].ucs4 != ucs4)
d431 2
a432 21
	if (font->hash_table[ent].ucs4 == (FcChar32) ~0)
	{
	    if (!XftCharExists (dpy, pub, ucs4))
		return 0;
	    face  = XftLockFace (pub);
	    if (!face)
		return 0;
	    font->hash_table[ent].ucs4 = ucs4;
	    font->hash_table[ent].glyph = FcFreeTypeCharIndex (face, ucs4);
	    XftUnlockFace (pub);
	    break;
	}
	if (!offset)
	{
	    offset = ucs4 % font->rehash_value;
	    if (!offset)
		offset = 1;
	}
	ent = ent + offset;
	if (ent > font->hash_value)
	    ent -= font->hash_value;
d434 1
a434 1
    return font->hash_table[ent].glyph;
d436 1
a436 4

/*
 * Pick a random glyph from the font and remove it from the cache
 */
d438 5
a442 1
_XftFontUncacheGlyph (Display *dpy, XftFont *pub)
d444 3
a446 4
    XftFontInt	    *font = (XftFontInt *) pub;
    unsigned long   glyph_memory;
    FT_UInt	    glyphindex;
    XftGlyph	    *xftg;
d448 1
a448 3
    if (!font->glyph_memory)
	return;
    if (font->use_free_glyphs)
d450 14
a463 1
	glyph_memory = rand() % font->glyph_memory;
d465 1
a465 1
    else
d467 1
a467 1
	if (font->glyphset)
d469 4
a472 14
	    XRenderFreeGlyphSet (dpy, font->glyphset);
	    font->glyphset = 0;
	}
	glyph_memory = 0;
    }
	
    if (XftDebug() & XFT_DBG_CACHE)
	_XftFontValidateMemory (dpy, pub);
    for (glyphindex = 0; glyphindex < font->num_glyphs; glyphindex++)
    {
	xftg = font->glyphs[glyphindex];
	if (xftg)
	{
	    if (xftg->glyph_memory > glyph_memory)
d474 2
a475 7
		if (XftDebug() & XFT_DBG_CACHEV)
		    printf ("Uncaching glyph 0x%x size %ld\n",
			    glyphindex, xftg->glyph_memory);
		XftFontUnloadGlyphs (dpy, pub, &glyphindex, 1);
		if (!font->use_free_glyphs)
		    continue;
		break;
d477 1
a477 1
	    glyph_memory -= xftg->glyph_memory;
d479 2
a481 2
    if (XftDebug() & XFT_DBG_CACHE)
	_XftFontValidateMemory (dpy, pub);
d484 4
a487 2
void
_XftFontManageMemory (Display *dpy, XftFont *pub)
d489 1
a489 3
    XftFontInt	*font = (XftFontInt *) pub;

    if (font->max_glyph_memory)
d491 2
a492 9
	if (XftDebug() & XFT_DBG_CACHE)
	{
	    if (font->glyph_memory > font->max_glyph_memory)
		printf ("Reduce memory for font 0x%lx from %ld to %ld\n",
			font->glyphset ? font->glyphset : (unsigned long) font,
			font->glyph_memory, font->max_glyph_memory);
	}
	while (font->glyph_memory > font->max_glyph_memory)
	    _XftFontUncacheGlyph (dpy, pub);
d494 1
a494 1
    _XftDisplayManageMemory (dpy);
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d2 1
a2 1
 * $XFree86: xc/lib/Xft/xftglyphs.c,v 1.24 2003/11/20 22:36:33 dawes Exp $
d29 1
a29 2
#include <ft2build.h>
#include FT_OUTLINE_H
@


