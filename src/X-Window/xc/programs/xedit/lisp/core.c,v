head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.10.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.10.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.39.50;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.39.02;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.28.28;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (c) 2001 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *  
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of the XFree86 Project shall
 * not be used in advertising or otherwise to promote the sale, use or other
 * dealings in this Software without prior written authorization from the
 * XFree86 Project.
 *
 * Author: Paulo César Pereira de Andrade
 */

/* $XFree86: xc/programs/xedit/lisp/core.c,v 1.17 2001/10/28 14:18:49 tsi Exp $ */

#include "core.h"
#include "format.h"
#include "helper.h"
#include "private.h"

/*
 * Prototypes
 */
extern LispObj *LispRunSetf(LispMac*, LispObj*, LispObj*, LispObj*);

/*
 * Implementation
 */
LispObj *
Lisp_Mul(LispMac *mac, LispObj *list, char *fname)
{
    double result = 1.0;

    for (; list != NIL; list = CDR(list)) {
	if (!NUMBER_P(CAR(list)))
	    LispDestroy(mac, ExpectingNumberAt, fname);
	result *= NUMBER_VALUE(CAR(list));
    }
    return (REAL(result));
}

LispObj *
Lisp_Plus(LispMac *mac, LispObj *list, char *fname)
{
    double result = 0.0;

    for (; list != NIL; list = CDR(list)) {
	if (!NUMBER_P(CAR(list)))
	    LispDestroy(mac, ExpectingNumberAt, fname);
	result += NUMBER_VALUE(CAR(list));
    }
    return (REAL(result));
}

LispObj *
Lisp_Minus(LispMac *mac, LispObj *list, char *fname)
{
    double result;

    if (!NUMBER_P(CAR(list)))
	LispDestroy(mac, ExpectingNumberAt, fname);
    result = NUMBER_VALUE(CAR(list));
    list = CDR(list);
    if (list == NIL)
	return (REAL(-result));
    for (; list != NIL; list = CDR(list)) {
	if (!NUMBER_P(CAR(list)))
	    LispDestroy(mac, ExpectingNumberAt, fname);
	result -= NUMBER_VALUE(CAR(list));
    }
    return (REAL(result));
}

LispObj *
Lisp_Div(LispMac *mac, LispObj *list, char *fname)
{
    double result;

    if (!NUMBER_P(CAR(list)))
	LispDestroy(mac, ExpectingNumberAt, fname);
    result = NUMBER_VALUE(CAR(list));
    list = CDR(list);
    if (list == NIL) {
	if (result == 0.0)
	    LispDestroy(mac, "divide by 0, at %s", fname);
	return (REAL(1.0 / result));
    }
    for (; list != NIL; list = CDR(list)) {
	if (!NUMBER_P(CAR(list)))
	    LispDestroy(mac, ExpectingNumberAt, fname);
	if (NUMBER_VALUE(CAR(list)))
	    LispDestroy(mac, "divide by 0, at %s", fname);
	result /= NUMBER_VALUE(CAR(list));
    }
    return (REAL(result));
}

LispObj *
Lisp_OnePlus(LispMac *mac, LispObj *list, char *fname)
{
    if (!NUMBER_P(CAR(list)))
	LispDestroy(mac, ExpectingNumberAt, fname);
    return (REAL(NUMBER_VALUE(CAR(list)) + 1.0));
}

LispObj *
Lisp_OneMinus(LispMac *mac, LispObj *list, char *fname)
{
    if (!NUMBER_P(CAR(list)))
	LispDestroy(mac, ExpectingNumberAt, fname);
    return (REAL(NUMBER_VALUE(CAR(list)) - 1.0));
}

LispObj *
Lisp_Less(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispBoolCond(mac, list, fname, LESS));
}

LispObj *
Lisp_LessEqual(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispBoolCond(mac, list, fname, LESS_EQUAL));
}

LispObj *
Lisp_Equal_(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispBoolCond(mac, list, fname, EQUAL));
}

LispObj *
Lisp_Greater(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispBoolCond(mac, list, fname, GREATER));
}

LispObj *
Lisp_GreaterEqual(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispBoolCond(mac, list, fname, GREATER_EQUAL));
}

LispObj *
Lisp_NotEqual(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispBoolCond(mac, list, fname, NOT_EQUAL));
}

LispObj *
Lisp_Aref(LispMac *mac, LispObj *list, char *fname)
{
    long c, count, idx, seq;
    LispObj *ary = CAR(list), *dim = CDR(list), *obj;

    if (ary->type != LispArray_t)
	LispDestroy(mac, "%s is not an array, at %s",
		    LispStrObj(mac, ary), fname);

    for (count = 0, list = dim, obj = ary->data.array.dim; list != NIL;
	 count++, list = CDR(list), obj = CDR(obj)) {
	if (count >= ary->data.array.rank)
	    LispDestroy(mac, "too many subscripts %s, at %s",
			LispStrObj(mac, dim), fname);
	if (!INDEX_P(CAR(list)) ||
	    NUMBER_VALUE(CAR(list)) >= NUMBER_VALUE(CAR(obj)))
	    LispDestroy(mac, "%s is out of range or a bad index, at %s",
			LispStrObj(mac, CAR(list)), fname);
    }
    if (count < ary->data.array.rank)
	LispDestroy(mac, "too few subscripts %s, at %s",
		    LispStrObj(mac, dim), fname);

    for (count = seq = 0, list = dim; list != NIL; list = CDR(list), seq++) {
	for (idx = 0, obj = ary->data.array.dim; idx < seq; obj = CDR(obj), ++idx)
	    ;
	for (c = 1, obj = CDR(obj); obj != NIL; obj = CDR(obj))
	    c *= NUMBER_VALUE(CAR(obj));
	count += c * NUMBER_VALUE(CAR(list));
    }

    for (ary = ary->data.array.list; count > 0; ary = CDR(ary), count--)
	;

    return (CAR(ary));
}

LispObj *
Lisp_Assoc(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *cmp, *obj, *res = NIL;

    cmp = CAR(list);
    list = CDR(list);
    if (list == NIL)
	return (NIL);

    for (list = CAR(list); list != NIL; list = CDR(list)) {
	if (list->type != LispCons_t || (obj = CAR(list))->type != LispCons_t)
	    LispDestroy(mac, ExpectingListAt, fname);
	else if (_LispEqual(mac, cmp, CAR(obj)) == T) {
	    res = obj;
	    break;
	}
    }

    return (res);
}

LispObj *
Lisp_And(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *res = T;

    for (; list != NIL; list = CDR(list)) {
	if ((res = EVAL(CAR(list))) == NIL)
	    break;
    }
    return (res);
}

LispObj *
Lisp_Append(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *res, *obj, *cdr, *cons, *frm;

    if (list == NIL)
	return (NIL);
    else if (CDR(list) == NIL)
	return (EVAL(CAR(list)));

    frm = FRM;
    res = cdr = NIL;

    for (; list != NIL; list = CDR(list)) {
	if ((obj = EVAL(CAR(list))) == NIL)
	    continue;
	if (obj->type != LispCons_t) {
	    if (CDR(list) != NIL)
		LispDestroy(mac, ExpectingListAt, fname);
	}
	GCProtect();
	if (res == NIL) {
	    if (obj->type != LispCons_t) {
		/* is last argument, as previous check didn't fail */
		res = obj;
		GCUProtect();
		break;
	    }
	    res = cdr = CONS(CAR(obj), CDR(obj));
	    FRM = CONS(res, FRM);
	}
	else {
	    if (CDR(cdr)->type == LispCons_t) {
		cons = CDR(cdr);
		while (CDR(cons)->type == LispCons_t) {
		    CDR(cdr) = CONS(CAR(cons), CDR(cons));
		    cons = CDR(cons);
		    cdr = CDR(cdr);
		}
		CDR(cdr) = CONS(CAR(CDR(cdr)), obj);
	    }
	    else
		CDR(cdr) = obj;
	    cdr = CDR(cdr);
	}
	GCUProtect();
    }
    FRM = frm;

    return (res);
}

LispObj *
Lisp_Apply(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *obj, *eval, *cdr, *frm = FRM;

    eval = EVAL(CAR(list));
    if (!SYMBOL_P(eval) && eval->type != LispLambda_t)
	LispDestroy(mac, "%s is not a valid function name, at %s",
		LispStrObj(mac, eval), fname);
    obj = NIL;
    /* link eval to FRM to protect from GC */
    GCProtect();
    eval = cdr = CONS(eval, NIL);
    FRM = CONS(eval, FRM);
    GCUProtect();
    for (list = CDR(list); list != NIL; list = CDR(list)) {
	obj = EVAL(CAR(list));
	if (CDR(list) != NIL) {
	    CDR(cdr) = CONS(obj, NIL);
	    cdr = CDR(cdr);
	}
	else
	    CDR(cdr) = obj;
    }
    if (obj != NIL && (obj->type != LispCons_t || CDR(obj)->type != LispCons_t))
	LispDestroy(mac, "last apply argument must be a list");
    /* Need to quote back to avoid double evaluation */
    while (obj != NIL) {
	CAR(obj) = QUOTE(CAR(obj));
	obj = CDR(obj);
    }

    frm = FRM;

    return (EVAL(eval));
}

LispObj *
Lisp_Atom(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *res;

    if (list == NIL)
	res = T;
    else
	switch (CAR(list)->type) {
	    case LispCons_t:
		res = NIL;
		break;
	    default:
		res = T;
		break;
	}
    return (res);
}

LispObj *
Lisp_Block(LispMac *mac, LispObj *list, char *fname)
{
    int did_jump, *pdid_jump = &did_jump;
    LispObj *res, **pres = &res;
    LispBlock *block;

    if (CAR(list) != NIL && CAR(list) != T && !SYMBOL_P(CAR(list)))
	LispDestroy(mac, "%s is not a symbol, at %s",
		    LispStrObj(mac, CAR(list)), fname);

    *pres = NIL;
    *pdid_jump = 1;
    block = LispBeginBlock(mac, CAR(list), LispBlockTag);
    if (setjmp(block->jmp) == 0) {
	*pres = Lisp_Progn(mac, CDR(list), fname);
	*pdid_jump = 0;
    }
    LispEndBlock(mac, block);
    if (*pdid_jump)
	*pres = mac->block.block_ret;

    return (*pres);
}

LispObj *
Lisp_Butlast(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *res, *obj, *cdr;
    int nlist;

    if ((obj = CAR(list))->type != LispCons_t)
	LispDestroy(mac, "%s is not a list, at %s",
		LispStrObj(mac, obj), fname);
    cdr = NIL;
    nlist = 0;
    while (obj->type == LispCons_t) {
	++nlist;
	obj = CDR(obj);
    }
    --nlist;
    obj = CDR(list);
    if (obj != NIL) {
	obj = CAR(obj);
	if (INDEX_P(obj)) {
	    int pos = NUMBER_VALUE(obj);

	    if (pos == 0) {
		res = CAR(list);
		if (CDR(res)->type != LispCons_t)
		    /* CL compatible return value */
		    return (CONS(CAR(res), NIL));
		return (res);
	    }
	    else {
		if (pos > nlist)
		    return (NIL);
		nlist -= pos - 1;
	    }
	}
	else
	    LispDestroy(mac, "%s is a invalid index, at %s",
			LispStrObj(mac, obj), fname);
    }

    GCProtect();	/* just disable GC, no EVAL's below */
    res = NIL;
    list = CAR(list);
    for (; nlist > 0; list = CDR(list), nlist--) {
	obj = CAR(list);
	if (res == NIL)
	    res = cdr = CONS(obj, NIL);
	else {
	    CDR(cdr) = CONS(obj, NIL);
	    cdr = CDR(cdr);
	}
    }
    GCUProtect();

    return (res);
}

LispObj *
Lisp_Car(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *res = NIL;

    switch (CAR(list)->type) {
	case LispNil_t:
	    return (NIL);
	    break;
	case LispCons_t:
	    res = CAR(CAR(list));
	    break;
	default:
	    LispDestroy(mac, ExpectingListAt, fname);
	    /*NOTREACHED*/
    }

    return (res);
}

LispObj *
Lisp_Case(LispMac *mac, LispObj *list, char *fname)
{
    static char *other = "OTHERWISE";
    LispObj *key, *res;

    res = NIL;
    key = EVAL(CAR(list));

    for (list = CDR(list); list != NIL; list = CDR(list)) {
	if (CAR(list)->type != LispCons_t)
	    LispDestroy(mac, "expecting list, at %s", fname);
	else if (CAR(CAR(list)) == T) {
	    if (CDR(list) != NIL)
		LispDestroy(mac, "T must be the last clause, at %s", fname);
	    res = CDR(CAR(list));
	    break;
	}
	else if (SYMBOL_P(CAR(CAR(list))) &&
		 strcmp(other, STRPTR(CAR(CAR(list)))) == 0) {
	    if (CDR(list) != NIL)
		LispDestroy(mac, "%s must be the last clause, at %s",
			    other, fname);
	    res = CDR(CAR(list));
	    break;
	}
	else if (CAR(CAR(list))->type == LispCons_t) {
	    LispObj *keylist = CAR(CAR(list));

	    for (; keylist->type == LispCons_t; keylist = CDR(keylist))
		if (_LispEqual(mac, key, CAR(keylist)) == T) {
		    res = CDR(CAR(list));
		    break;
		}
	    if (keylist->type == LispCons_t)	/* if found match */
		break;
	}
	else if (_LispEqual(mac, key, CAR(CAR(list))) == T) {
	    res = CDR(CAR(list));
	    break;
	}
    }

    return (res->type == LispCons_t ? Lisp_Progn(mac, res, fname) : NIL);
}

LispObj *
Lisp_Catch(LispMac *mac, LispObj *list, char *fname)
{
    int did_jump, *pdid_jump = &did_jump;
    LispObj *res, **pres = &res;
    LispBlock *block;

    *pres = NIL;
    *pdid_jump = 1;
    block = LispBeginBlock(mac, CAR(list), LispBlockCatch);
    if (setjmp(block->jmp) == 0) {
	*pres = Lisp_Progn(mac, CDR(list), fname);
	*pdid_jump = 0;
    }
    LispEndBlock(mac, block);
    if (*pdid_jump)
	*pres = mac->block.block_ret;

    return (*pres);
}

LispObj *
Lisp_Coerce(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *from, *to, *res = NIL;
    LispType type = LispNil_t;

    from = CAR(list);
    to = CAR(CDR(list));
    if (to == NIL)
	LispDestroy(mac, "cannot convert %s to nil, at %s",
		    LispStrObj(mac, from), fname);
    else if (to == T)
	return (from);
    else if (!SYMBOL_P(to))
	LispDestroy(mac, "bad argument %s, at %s", LispStrObj(mac, to), fname);
    else {
	if (strcmp(STRPTR(to), "ATOM") == 0 || strcmp(STRPTR(to), "SYMBOL") == 0)
	    type = LispAtom_t;
	else if (strcmp(STRPTR(to), "REAL") == 0)
	    type = LispReal_t;
	else if (strcmp(STRPTR(to), "CONS") == 0)
	    type = LispCons_t;
	else if (strcmp(STRPTR(to), "STRING") == 0)
	    type = LispString_t;
	else if (strcmp(STRPTR(to), "CHARACTER") == 0)
	    type = LispCharacter_t;
	else if (strcmp(STRPTR(to), "OPAQUE") == 0)
	    type = LispOpaque_t;
	else
	    LispDestroy(mac, "invalid type specification %s, at %s",
			STRPTR(to), fname);
    }

    if (from->type == LispOpaque_t) {
	switch (type) {
	    case LispAtom_t:
		res = ATOM(from->data.opaque.data);
		break;
	    case LispString_t:
		res = STRING(from->data.opaque.data);
		break;
	    case LispCharacter_t:
		res = CHAR((int)from->data.opaque.data);
		break;
	    case LispReal_t:
		res = REAL((double)((int)from->data.opaque.data));
		break;
	    case LispOpaque_t:
		res = OPAQUE(from->data.opaque.data, 0);
		break;
	    default:
		LispDestroy(mac, "cannot convert %s to %s, at %s",
			    LispStrObj(mac, from), STRPTR(to), fname);
	}
    }
    else if (from->type != type) {
	if (type == LispString_t)
	    res = Lisp_String(mac, CONS(from, NIL), fname);
	else if (type == LispCharacter_t)
	    res = Lisp_Character(mac, CONS(from, NIL), fname);
	else
	    LispDestroy(mac, "cannot convert %s to %s, at %s",
			LispStrObj(mac, from), STRPTR(to), fname);
    }
    else
	res = from;

    return (res);
}

LispObj *
Lisp_Cdr(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *res = NIL;

    switch (CAR(list)->type) {
	case LispNil_t:
	    return (NIL);
	    break;
	case LispCons_t:
	    res = CDR(CAR(list));
	    break;
	default:
	    LispDestroy(mac, ExpectingListAt, fname);
	    /*NOTREACHED*/
    }

    return (res);
}

LispObj *
Lisp_Cond(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *eval, *res = NIL;

    for (; list != NIL; list = CDR(list)) {
	eval = CAR(list);
	if (eval->type != LispCons_t)
	    LispDestroy(mac, "%s is a illegal clause for %s",
			LispStrObj(mac, eval), fname);
	res = EVAL(CAR(eval));
	if (res->type == LispNil_t)
	    continue;
	for (eval = CDR(eval); eval != NIL; eval = CDR(eval))
	    res = EVAL(CAR(eval));
	break;
    }

    return (res);
}

LispObj *
Lisp_Cons(LispMac *mac, LispObj *list, char *fname)
{
    return (CONS(CAR(list), CAR(CDR(list))));
}

LispObj *
Lisp_Decf(LispMac *mac, LispObj *list, char *fname)
{
    double dval;
    LispObj *sym = CAR(list), *num = EVAL(sym),
	    *obj = CDR(list) == NIL ? NIL : CAR(CDR(list)), *val;

    if (!NUMBER_P(num))
	LispDestroy(mac, "expecting number, at %s", fname);
    if (obj != NIL) {
	obj = EVAL(obj);
	if (!NUMBER_P(obj))
	    LispDestroy(mac, "expecting number, at %s", fname);
    }

    dval = NUMBER_VALUE(num) - (obj != NIL ? NUMBER_VALUE(obj) : 1.0);
    val = REAL(dval);

    if (!SYMBOL_P(sym)) {
	/* a bit more complicated, but still faster than
	 *	(setf place (- place 1))
	 * in most cases, could directly change num, but that would cause
	 * side effects, like:
	 *	(setq n '(1))		=> 1
	 *	(setq m (car n))	=> 1
	 *	(decf (car n))		=> 0
	 *	m			=> 0
	 * this should not happen.
	 *
	 *	incf uses the same logic
	 */
	LispObj *frm = FRM;

	obj = CONS(sym, CONS(val, NIL));
	FRM = CONS(obj, FRM);	/* protect setf arguments */
	num = Lisp_Setf(mac, obj, fname);
	frm = FRM;
    }
    else {
	if (obj != NIL)
	    num = _LispSet(mac, sym, val, fname, 0);
	else
	    num = _LispSet(mac, sym, val, fname, 0);
    }

    return (num);
}

LispObj *
Lisp_Defmacro(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispDefLambda(mac, list, LispMacro));
}

LispObj *
Lisp_Defun(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispDefLambda(mac, list, LispFunction));
}

LispObj *
Lisp_Defsetf(LispMac *mac, LispObj *list, char *fname)
{
    if (CDR(CDR(list)) == NIL) {
	LispObj *nam, *val;

	nam = CAR(list);
	list = CDR(list);
	val = CAR(list);
	if (!SYMBOL_P(nam) || !SYMBOL_P(val))
	    LispDestroy(mac, "syntax error at %s %s", fname,
			LispStrObj(mac, nam));

	LispSetAtomSetfProperty(mac, nam->data.atom, val);

	return (nam);
     }

    return (_LispDefLambda(mac, list, LispSetf));
}

LispObj *
Lisp_Do(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispDo(mac, list, fname, 0));
}

LispObj *
Lisp_DoP(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispDo(mac, list, fname, 1));
}

LispObj *
Lisp_DoList(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispDoListTimes(mac, list, fname, 0));
}

LispObj *
Lisp_DoTimes(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispDoListTimes(mac, list, fname, 1));
}

LispObj *
Lisp_Elt(LispMac *mac, LispObj *list, char *fname)
{
    int len, pos;
    LispObj *seq = CAR(list), *opos = CAR(CDR(list)), *res;

    /* if not a sequence, Lisp_Length will see it */
    len = Lisp_Length(mac, list, fname)->data.real;

    if (!INDEX_P(opos) || NUMBER_VALUE(opos) >= len)
	LispDestroy(mac, "bad index %s, at %s", LispStrObj(mac, opos), fname);
    pos = NUMBER_VALUE(opos);

    if (STRING_P(seq))
	res = CHAR(*(unsigned char*)(STRPTR(seq) + pos));
    else {
	if (seq->type == LispArray_t)
	    seq = seq->data.array.list;

	for (; pos > 0; pos--, seq = CDR(seq))
	    ;
	res = CAR(seq);
    }

    return (res);
}

LispObj *
Lisp_Equal(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispEqual(mac, CAR(list), CAR(CDR(list))));
}

LispObj *
Lisp_Error(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *str;

    str = Lisp_Format(mac, CONS(NIL, list), fname);
    LispDestroy(mac, "%s", STRPTR(str));
    /*NOTREACHED*/

    return (NIL);
}

LispObj *
Lisp_Eval(LispMac *mac, LispObj *list, char *fname)
{
    return (EVAL(CAR(list)));
}

LispObj *
Lisp_Evenp(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *obj = CAR(list);

    if (!INTEGER_P(obj))
	LispDestroy(mac, "expecting integer, at %s", fname);

    return ((int)NUMBER_VALUE(obj) % 2 ? NIL : T);
}

LispObj *
Lisp_FMakunbound(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *atom;

    if (!SYMBOL_P(CAR(list)))
	LispDestroy(mac, "%s is not a symbol, at %s",
		    LispStrObj(mac, CAR(list)), fname);
    atom = CAR(list);

    if (atom->data.atom->property) {
	if (atom->data.atom->property->function)
	    LispRemAtomFunctionProperty(mac, atom->data.atom);
	else if (atom->data.atom->property->builtin)
	    /* not a smart move, just looses a fast function,
	     * and gains no extra memory... */
	    LispRemAtomBuiltinProperty(mac, atom->data.atom);
    }

    return (atom);
}

LispObj *
Lisp_Funcall(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *fun = EVAL(CAR(list));

    return (EVAL(CONS(fun, CDR(list))));
}

LispObj *
Lisp_Get(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *sym, *key, *res;

    if ((sym = CAR(list))->type != LispAtom_t)
	LispDestroy(mac, "expecting symbol, at %s", fname);
    list = CDR(list);
    key = CAR(list);

    res = LispGetAtomProperty(mac, sym->data.atom, key);

    if (res != NIL)
	res = CAR(res);
    else {
	list = CDR(list);
	if (list == NIL)
	    res = NIL;
	else
	    res = CAR(list);
    }

    return (res);
}

LispObj *
Lisp_Gc(LispMac *mac, LispObj *list, char *fname)
{
    LispGC(mac, NIL, NIL);

    return (list == NIL || CAR(list)->type == LispNil_t ? NIL : T);
}

LispObj *
Lisp_Go(LispMac *mac, LispObj *list, char *fname)
{
    unsigned blevel = mac->block.block_level;
    LispObj *tag = CAR(list);

    if (tag != NIL && tag != T && !SYMBOL_P(tag) && !NUMBER_P(tag))
	goto cannot_go;

    while (blevel) {
	LispBlock *block = mac->block.block[--blevel];

	if (block->type == LispBlockClosure)
	    /* if reached a function call */
	    break;
	if (block->type == LispBlockBody) {
	    mac->block.block_ret = tag;
	    LispBlockUnwind(mac);
	    longjmp(block->jmp, 1);
	}
     }

cannot_go:
    LispDestroy(mac, "cannot go to %s, at %s", LispStrObj(mac, tag), fname);

    /*NOTREACHED*/
    return (NIL);
}

LispObj *
Lisp_Incf(LispMac *mac, LispObj *list, char *fname)
{
    double dval;
    LispObj *sym = CAR(list), *num = EVAL(sym),
	    *obj = CDR(list) == NIL ? NIL : CAR(CDR(list)), *val;

    if (!NUMBER_P(num))
	LispDestroy(mac, "expecting number, at %s", fname);
    if (obj != NIL) {
	obj = EVAL(obj);
	if (!NUMBER_P(obj))
	    LispDestroy(mac, "expecting number, at %s", fname);
    }

    dval = NUMBER_VALUE(num) + (obj != NIL ? NUMBER_VALUE(obj) : 1.0);
    val = REAL(dval);

    if (!SYMBOL_P(sym)) {
	LispObj *frm = FRM;

	obj = CONS(sym, CONS(val, NIL));
	FRM = CONS(obj, FRM);	/* protect setf arguments */
	num = Lisp_Setf(mac, obj, fname);
	frm = FRM;
    }
    else {
	if (obj != NIL)
	    num = _LispSet(mac, sym, val, fname, 0);
	else
	    num = _LispSet(mac, sym, val, fname, 0);
    }

    return (num);
}

LispObj *
Lisp_If(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *cond, *res;

    cond = EVAL(CAR(list));
    list = CDR(list);
    if (cond != NIL)
	res = EVAL(CAR(list));
    else {
	if (CDR(list) == NIL)
	    res = NIL;
	else
	    res = EVAL(CAR(CDR(list)));
    }

    return (res);
}

LispObj *
Lisp_Integerp(LispMac *mac, LispObj *list, char *fname)
{
    return (INTEGER_P(CAR(list)) ? T : NIL);
}

LispObj *
Lisp_Lambda(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispDefLambda(mac, list, LispLambda));
}

LispObj *
Lisp_Last(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *seq, *obj;
    int nseq, count;

    if ((seq = CAR(list)) == NIL)
	return (seq);
    else if (seq->type != LispCons_t)
	LispDestroy(mac, ExpectingListAt, fname);

    if (CDR(list) != NIL) {
	obj = CAR(CDR(list));
	if (!INDEX_P(obj))
	    LispDestroy(mac, "bad index %s, at %s", LispStrObj(mac, obj), fname);
	count = NUMBER_VALUE(obj);
    }
    else
	count = 1;

    for (nseq = 0, obj = seq; obj->type == LispCons_t; nseq++, obj = CDR(obj))
	;

    count = nseq - count;

    if (count > nseq)
	return (NIL);
    else if (count <= 0)
	return (seq);

    for (; count > 0; count--, seq = CDR(seq))
	;

    return (seq);
}

LispObj *
Lisp_Length(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *obj;
    int length = 0;

    obj = CAR(list);
    switch (obj->type) {
	case LispNil_t:
	    break;
	case LispString_t:
	    length = strlen(STRPTR(obj));
	    break;
	case LispArray_t:
	    if (obj->data.array.rank != 1)
		goto notseq;
	    obj = obj->data.array.list;
	    /*FALLTROUGH*/
	case LispCons_t:
	    while (obj->type == LispCons_t) {
		++length;
		obj = CDR(obj);
	    }
	    break;
	default:
notseq:
	    LispDestroy(mac, "%s is not a sequence, at %s",
		    LispStrObj(mac, obj), fname);
	    /*NOTREACHED*/
    }

    return (REAL(length));
}

LispObj *
Lisp_Let(LispMac *mac, LispObj *list, char *fname)
{
    return (LispEnvRun(mac, list, Lisp_Progn, fname, 0));
}

LispObj *
Lisp_LetP(LispMac *mac, LispObj *list, char *fname)
{
    return (LispEnvRun(mac, list, Lisp_Progn, fname, 1));
}

LispObj *
Lisp_List(LispMac *mac, LispObj *list, char *fname)
{
    return (list);
}

LispObj *
Lisp_ListP(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *res, *cdr, *obj;

    obj = EVAL(CAR(list));
    if (CDR(list) == NIL)
	return (obj);

    GCProtect();	/* just disable GC, no EVAL's below */
    res = NIL;
    cdr = obj;
    for (list = CDR(list); list != NIL; list = CDR(list)) {
	obj = EVAL(CAR(list));
	if (res == NIL)
	    res = cdr = CONS(cdr, obj);
	else {
	    CDR(cdr) = CONS(CDR(cdr), obj);
	    cdr = CDR(cdr);
	}
    }
    GCUProtect();

    return (res);
}

LispObj *
Lisp_Listp(LispMac *mac, LispObj *list, char *fname)
{
    switch (CAR(list)->type) {
	case LispNil_t:
	case LispCons_t:
	    return (T);
	default:
	    return (NIL);
    }
    /*NOTREACHED*/
}

LispObj *
Lisp_Loop(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *obj, *res;
    LispBlock *block;

    res = NIL;
    block = LispBeginBlock(mac, NIL, LispBlockTag);
    if (setjmp(block->jmp) == 0) {
	for (;;)
	    for (obj = list; obj != NIL; obj = CDR(obj))
		(void)EVAL(CAR(obj));
    }
    LispEndBlock(mac, block);
    res = mac->block.block_ret;

    return (res);
}

LispObj *
Lisp_Makearray(LispMac *mac, LispObj *list, char *fname)
{
    LispType type = LispNil_t;
    long rank = 0, count = 1, zero, offset, c;
    LispObj *ary = NIL, *dim = NIL, *init, *typ, *cont, *disp, *off, *obj;

    if (NUMBER_P(CAR(list))) {
	if (!INDEX_P(CAR(list)))
	    LispDestroy(mac, "%s is a bad array dimension, at %s",
			LispStrObj(mac, CAR(list)), fname);
	else
	    dim = CONS(CAR(list), NIL);
	rank = 1;
	count = NUMBER_VALUE(CAR(list));
    }
    else if (CAR(list)->type == LispCons_t) {
	dim = CAR(list);

	for (obj = dim, rank = 0; obj != NIL; obj = CDR(obj), ++rank) {
	    if (obj->type != LispCons_t || !INDEX_P(CAR(obj)))
		LispDestroy(mac, "%s is a bad array dimension, at %s",
			    LispStrObj(mac, dim), fname);
		count *= NUMBER_VALUE(CAR(obj));
	}
    }

    offset = -1;
    LispGetKeys(mac, fname,
		"INITIAL-ELEMENT:ELEMENT-TYPE:INITIAL-CONTENTS"
		":DISPLACED-TO:DISPLACED-INDEX-OFFSET",
		CDR(list), &init, &typ, &cont, &disp, &off);

    /* check element-type */
    if (typ != NIL) {
	if (typ == T)
	    type = LispTrue_t;
	else if (!SYMBOL_P(typ))
	    LispDestroy(mac, "unsupported element type %s, at %s",
			LispStrObj(mac, typ), fname);
	else {
	    if (strcmp(STRPTR(typ), "ATOM") == 0)
		type = LispAtom_t;
	    else if (strcmp(STRPTR(typ), "REAL") == 0)
		type = LispReal_t;
	    else if (strcmp(STRPTR(typ), "STRING") == 0)
		type = LispString_t;
	    else if (strcmp(STRPTR(typ), "LIST") == 0)
		type = LispCons_t;
	    else if (strcmp(STRPTR(typ), "OPAQUE") == 0)
		type = LispOpaque_t;
	    else
		LispDestroy(mac, "unsupported element type %s, at %s",
			    STRPTR(typ), fname);
	}
    }

    /* check initial-contents */
    if (cont != NIL && cont->type != LispCons_t)
	LispDestroy(mac, "%s is not a list, at %s",
		    LispStrObj(mac, cont), fname);

    /* check displaced-to */
    if (disp != NIL && disp->type != LispArray_t)
	LispDestroy(mac, "%s is not an array, at %s",
		    LispStrObj(mac, disp), fname);

    /* check displaced-index-offset */
    if (off != NIL) {
	if (!INDEX_P(off))
	    LispDestroy(mac, "%s is a bad :DISPLACED-INDEX-OFFSET, at %s",
			LispStrObj(mac, off), fname);
	offset = (int)NUMBER_VALUE(off);
    }

    c = 0;
    if (init != NIL)
	++c;
    if (cont != NIL)
	++c;
    if (disp != NIL || offset >= 0)
	++c;
    if (c > 1)
	LispDestroy(mac, "more than one initialization specified, at %s",
		    fname);

    zero = count == 0;
    if (disp != NIL) {
	if (offset < 0)
	    offset = 0;
	for (c = 1, obj = disp->data.array.dim; obj != NIL; obj = CDR(obj))
	    c *= (int)NUMBER_VALUE(CAR(obj));
	if (c < count + offset)
	    LispDestroy(mac, "array-total-size + displaced-index-offset "
			"exceeds total size, at %s", fname);
	for (c = 0, ary = disp->data.array.list; c < offset; c++)
	    ary = CDR(ary);
    }
    else if (cont != NIL) {
	if (rank == 1) {
	    for (ary = cont, c = 0; c < count; ary = CDR(ary), ++c)
		if (ary->type != LispCons_t)
		    LispDestroy(mac, "bad argument or size %s, at %s",
				LispStrObj(mac, ary), fname);
	    if (ary != NIL)
		LispDestroy(mac, "bad argument or size %s, at %s",
			    LispStrObj(mac, ary), fname);
	    ary = cont;
	}
	else {
	    LispObj *err = NIL;
	    /* check if list matches */
	    int i, j, k, *dims, *loop;

	    /* create iteration variables */
	    dims = LispMalloc(mac, sizeof(int) * rank);
	    loop = LispCalloc(mac, 1, sizeof(int) * (rank - 1));
	    for (i = 0, obj = dim; obj != NIL; i++, obj = CDR(obj))
		dims[i] = (int)NUMBER_VALUE(CAR(obj));

	    /* check if list matches specified dimensions */
	    while (loop[0] < dims[0]) {
		for (obj = cont, i = 0; i < rank - 1; i++) {
		    for (j = 0; j < loop[i]; j++)
			obj = CDR(obj);
		    err = obj;
		    if ((obj = CAR(obj))->type != LispCons_t)
			goto make_array_error;
		    err = obj;
		}
		--i;
		for (;;) {
		    ++loop[i];
		    if (i && loop[i] >= dims[i])
			loop[i] = 0;
		    else
			break;
		    --i;
		}
		for (k = 0; k < dims[rank - 1]; obj = CDR(obj), k++) {
		    if (obj->type != LispCons_t)
			goto make_array_error;
		}
		if (obj == NIL)
		    continue;
make_array_error:
		LispFree(mac, dims);
		LispFree(mac, loop);
		LispDestroy(mac, "bad argument or size %s, at %s",
			    LispStrObj(mac, err), fname);
	    }

	    /* list is correct, use it to fill initial values */

	    /* reset loop */
	    memset(loop, 0, sizeof(int) * (rank - 1));

	    GCProtect();
	    /* fill array with supplied values */
	    while (loop[0] < dims[0]) {
		for (obj = cont, i = 0; i < rank - 1; i++) {
		    for (j = 0; j < loop[i]; j++)
			obj = CDR(obj);
		    obj = CAR(obj);
		}
		--i;
		for (;;) {
		    ++loop[i];
		    if (i && loop[i] >= dims[i])
			loop[i] = 0;
		    else
			break;
		    --i;
		}
		for (k = 0; k < dims[rank - 1]; obj = CDR(obj), k++) {
		    if (ary == NIL)
			ary = CONS(CAR(obj), NIL);
		    else {
			CDR(ary) = CONS(CAR(ary), CDR(ary));
			CAR(ary) = CAR(obj);
		    }
		}
	    }
	    LispFree(mac, dims);
	    LispFree(mac, loop);
	    ary = LispReverse(ary);
	    GCUProtect();
	}
    }
    else {
	GCProtect();
	/* allocate array */
	if (count) {
	    --count;
	    ary = CONS(init, NIL);
	    while (count) {
		CDR(ary) = CONS(CAR(ary), CDR(ary));
		CAR(ary) = init;
		count--;
	    }
	}
	GCUProtect();
    }

    if (type == LispNil_t)
	type = LispTrue_t;
    obj = LispNew(mac, ary, dim);
    obj->type = LispArray_t;
    obj->data.array.list = ary;
    obj->data.array.dim = dim;
    obj->data.array.rank = rank;
    obj->data.array.type = type;	/* XXX ignored */
    obj->data.array.zero = zero;

    return (obj);
}

LispObj *
Lisp_Makelist(LispMac *mac, LispObj *list, char *fname)
{
    int count;
    LispObj *res, *data, *tail;

    if (!INDEX_P(CAR(list)))
	LispDestroy(mac, "%s is not a positive integer, at %s",
		    LispStrObj(mac, CAR(list)), fname);

    count = NUMBER_VALUE(CAR(list));
    LispGetKeys(mac, fname, "INITIAL-ELEMENT", CDR(list), &data);

    GCProtect();
    res = tail = CONS(data, data);
    for (; count > 1; count--)
	res = CONS(data, res);
    CDR(tail) = NIL;
    GCUProtect();

    return (res);
}

LispObj *
Lisp_Makunbound(LispMac *mac, LispObj *list, char *fname)
{
    if (!SYMBOL_P(CAR(list)))
	LispDestroy(mac, "%s is not a symbol, at %s",
		    LispStrObj(mac, CAR(list)), fname);

    LispUnsetVar(mac, CAR(list));

    return (CAR(list));
}

LispObj *
Lisp_Mapcar(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *obj, *eval, *res, *cdres, *car, *cdr, *ptr, *fun, *frm = FRM;
    int i, level;

    fun = EVAL(CAR(list));
    if (!SYMBOL_P(fun) && fun->type != LispLambda_t)
	LispDestroy(mac, "%s is not a valid function name, at %s",
		    LispStrObj(mac, fun), fname);
    cdres = NIL;
    for (level = 0, res = NIL; ; level++) {
	LispObj *tfrm = FRM;

	eval = cdr = CONS(fun, NIL);
	FRM = CONS(eval, FRM);	/* protect eval, as there is n EVAL's below */
	for (ptr = CDR(list); ptr != NIL; ptr = CDR(ptr)) {
	    car = EVAL(CAR(ptr));
	    if (car->type != LispCons_t)
		goto mapcar_done;
	    for (i = 0, obj = car; i < level; i++) {
		if ((obj = CDR(obj)) == NIL)
		    goto mapcar_done;
	    }
	    /* quote back to avoid double eval */
	    GCProtect();
	    car = QUOTE(CAR(obj));
	    CDR(cdr) = CONS(car, NIL);
	    cdr = CDR(cdr);
	    GCUProtect();
	}
	obj = EVAL(eval);
	FRM = tfrm;
	if (res == NIL) {
	    GCProtect();
	    res = cdres = CONS(obj, NIL);
	    FRM = CONS(res, FRM);	/* protect res linking to FRM */
	    GCUProtect();
	}
	else {
	    CDR(cdres) = CONS(obj, NIL);
	    cdres = CDR(cdres);
	}
    }

    FRM = frm;				/* no need for GC protection now */

    /* to be CL compatible */
mapcar_done:
    return (res);
}

LispObj *
Lisp_Max(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispMinMax(mac, list, fname, 1));
}

LispObj *
Lisp_Member(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *obj = CAR(list), *res = NIL;

    list = CAR(CDR(list));
    if (list->type == LispNil_t)
	return (NIL);
    else if (list->type != LispCons_t)
	LispDestroy(mac, ExpectingListAt, fname);

    for (; list != NIL; list = CDR(list))
	if (_LispEqual(mac, obj, CAR(list)) == T) {
	    res = list;
	    break;
	}

    return (res);
}

LispObj *
Lisp_Min(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispMinMax(mac, list, fname, 0));
}

LispObj *
Lisp_Minusp(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *obj = CAR(list);

    if (!NUMBER_P(obj))
	LispDestroy(mac, "expecting number, at %s", fname);

    return (NUMBER_VALUE(obj) < 0.0 ? T : NIL);
}

LispObj *
Lisp_Nth(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispNth(mac, list, fname, 0));
}

LispObj *
Lisp_Nthcdr(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispNth(mac, list, fname, 1));
}

LispObj *
Lisp_Null(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *res = NIL;

    if (list != NIL && CAR(list)->type == LispNil_t)
	res = T;
    return (res);
}

LispObj *
Lisp_Numberp(LispMac *mac, LispObj *list, char *fname)
{
    return (NUMBER_P(CAR(list)) ? T : NIL);
}

LispObj *
Lisp_Oddp(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *obj = CAR(list);

    if (!INTEGER_P(obj))
	LispDestroy(mac, "expecting integer, at %s", fname);

    return ((int)NUMBER_VALUE(obj) % 2 ? T : NIL);
}

LispObj *
Lisp_Or(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *res = NIL;

    for (; list != NIL; list = CDR(list)) {
	if ((res = EVAL(CAR(list))) != NIL)
	    break;
    }
    return (res);
}

LispObj *
Lisp_Plusp(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *obj = CAR(list);

    if (!NUMBER_P(obj))
	LispDestroy(mac, "expecting number, at %s", fname);

    return (NUMBER_VALUE(obj) > 0.0 ? T : NIL);
}

LispObj *
Lisp_Prin1(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *obj = CAR(list), *stream;

    list = CDR(list);
    if (list == NIL || CAR(list) == NIL)
	stream = NIL;
    else
	stream = CAR(list);

    LispPrint(mac, obj, stream, 0);

    return (obj);
}

LispObj *
Lisp_Princ(LispMac *mac, LispObj *list, char *fname)
{
    int princ = mac->princ;
    LispObj *obj = CAR(list), *stream;

    list = CDR(list);
    if (list == NIL || CAR(list) == NIL)
	stream = NIL;
    else
	stream = CAR(list);

    mac->princ = 1;
    LispPrint(mac, obj, stream, 0);
    mac->princ = princ;

    return (obj);
}

LispObj *
Lisp_Print(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *obj = CAR(list), *stream;

    list = CDR(list);
    if (list == NIL || CAR(list) == NIL)
	stream = NIL;
    else
	stream = CAR(list);

    LispPrint(mac, obj, stream, 1);

    return (obj);
}

LispObj *
Lisp_Prog1(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *frm, *res = EVAL(CAR(list));

    frm = FRM;
    FRM = CONS(res, FRM);
    for (list = CDR(list); list != NIL; list = CDR(list))
	(void)EVAL(CAR(list));
    FRM = frm;

    return (res);
}

LispObj *
Lisp_Prog2(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *frm, *res;

    (void)EVAL(CAR(list));
    list = CDR(list);
    res = EVAL(CAR(list));
    frm = FRM;
    FRM = CONS(res, FRM);
    for (list = CDR(list); list != NIL; list = CDR(list))
	(void)EVAL(CAR(list));
    FRM = frm;

    return (res);
}

LispObj *
Lisp_Progn(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *res = NIL;

    for (; list != NIL; list = CDR(list))
	res = EVAL(CAR(list));

    return (res);
}

LispObj *
Lisp_Progv(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *old_frm, *old_env, *res, *cons = NIL, *valist = NIL;
    LispObj *syms, *values, *body;

    old_frm = FRM;

    /* get symbol names */
    syms = EVAL(CAR(list));
    GCProtect();
    FRM = CONS(syms, FRM);
    GCUProtect();

    /* get symbol values */
    list = CDR(list);
    values = EVAL(CAR(list));
    GCProtect();
    FRM = CONS(values, FRM);
    GCUProtect();
    list = CDR(list);

    /* the body to be executed */
    body = list;

    /* fill variable list */
    for (; syms->type == LispCons_t; syms = CDR(syms)) {
	if (values->type != LispCons_t)
	    break;
	if (!SYMBOL_P(CAR(syms)))
	    LispDestroy(mac, "%s is not a symbol, at %s",
			LispStrObj(mac, CAR(syms)), fname);
	if (valist == NIL) {
	    GCProtect();
	    valist = cons = CONS(CONS(CAR(syms), CAR(values)), NIL);
	    FRM = CONS(valist, FRM);
	    GCUProtect();
	}
	else {
	    CDR(cons) = CONS(CONS(CAR(syms), CAR(values)), NIL);
	    cons = CDR(cons);
	}
	values = CDR(values);
    }

    /* add variables */
    old_env = ENV;
    for (; valist != NIL; valist = CDR(valist)) {
	cons = CAR(valist);
	LispAddVar(mac, CAR(cons), CDR(cons));
    }

    res = Lisp_Progn(mac, body, fname);

    ENV = old_env;
    FRM = old_frm;

    return (res);
}

LispObj *
Lisp_Provide(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *feat = CAR(list), *obj;

    if (!STRING_P(feat) && !SYMBOL_P(feat))
	LispDestroy(mac, "cannot provide %s", LispStrObj(mac, feat));

    for (obj = MOD; obj != NIL; obj = CDR(obj)) {
	if (STRPTR(CAR(obj)) == STRPTR(feat))
	    return (feat);
    }

    if (MOD == NIL)
	MOD = CONS(feat, NIL);
    else {
	CDR(MOD) = CONS(CAR(MOD), CDR(MOD));
	CAR(MOD) = feat;
    }

    return (feat);
}

LispObj *
Lisp_Quit(LispMac *mac, LispObj *list, char *fname)
{
    int status = 0;

    if (list != NIL) {
	if (!INTEGER_P(CAR(list)))
	    LispDestroy(mac, "bad exit status argument %s, at %s",
			LispStrObj(mac, CAR(list)), fname);
	status = (int)NUMBER_VALUE(CAR(list));
    }

    exit(status);
}

LispObj *
Lisp_Quote(LispMac *mac, LispObj *list, char *fname)
{
    return (CAR(list));
}

/* XXX needs to be extended to accept parameters */
LispObj *
Lisp_Read(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *obj;

    obj = LispRun(mac);
    if (obj == EOLIST)
	LispDestroy(mac, "object cannot start with #\\)");

    return (obj);
}

/* Destructively replaces seq1 elements with seq2 elements
 *	(replace sequence1 sequence2 &key :start1 :end1 :start2 :end2)
 */
LispObj *
Lisp_Replace(LispMac *mac, LispObj *list, char *fname)
{
    int len, len1, len2, start1, end1, start2, end2;
    LispObj *seq1, *seq2, *ostart1, *oend1, *ostart2, *oend2;

    seq1 = CAR(list);
    len1 = Lisp_Length(mac, list, fname)->data.real;

    list = CDR(list);
    seq2 = CAR(list);
    len2 = Lisp_Length(mac, list, fname)->data.real;

    list = CDR(list);
    LispGetKeys(mac, fname, "START1:END1:START2:END2", list,
		&ostart1, &oend1, &ostart2, &oend2);

    if (ostart1 == NIL)
	start1 = 0;
    else if (INDEX_P(ostart1))
	goto replace_not_integer;
    else
	start1 = NUMBER_VALUE(ostart1);
    if (oend1 == NIL)
	end1 = len1;
    else if (INDEX_P(oend1))
	goto replace_not_integer;
    else
	end1 = NUMBER_VALUE(oend1);

    if (ostart2 == NIL)
	start2 = 0;
    else if (INDEX_P(ostart2))
	goto replace_not_integer;
    else
	start2 = NUMBER_VALUE(ostart2);
    if (oend2 == NIL)
	end2 = len2;
    else if (INDEX_P(oend2))
	goto replace_not_integer;
    else
	end2 = NUMBER_VALUE(oend2);

    if (start1 == end1 || start2 == end2)
	goto replace_done;

    if (start1 > end1 || end1 > len1 || start2 > end2 || end2 > len2)
	goto replace_out_of_range;

    len = end1 - start1;
    if (len > end2 - start2)
	len = end2 - start2;

    if (STRING_P(seq1)) {
	char *string;

	if (!STRING_P(seq2))
	    goto replace_type_mismatch;

	string = LispStrdup(mac, STRPTR(seq1));
	strncpy(string + start1, STRPTR(seq2) + start2, len);
	seq1->data.atom = LispDoGetAtom(mac, string, 0, 0);
	LispFree(mac, string);
    }
    else {
	int i;
	LispObj *from, *to;

	if (seq1->type == LispArray_t)
	    seq1 = seq1->data.array.list;
	if (seq2->type == LispArray_t)
	    seq2 = seq2->data.array.list;

	/* adjust pointers */
	for (i = 0, from = seq2; i < start2; i++, from = CDR(from))
	    ;
	for (i = 0, to = seq1; i < start1; i++, to = CDR(to))
	    ;

	/* copy data */
	for (i = 0; i < len; i++, from = CDR(from), to = CDR(to))
	    CAR(to) = CAR(from);
    }

    goto replace_done;

replace_not_integer:
    LispDestroy(mac, "expecting a positive integer, at %s", fname);

replace_out_of_range:
    LispDestroy(mac, "index out of range, at %s", fname);

replace_type_mismatch:
    LispDestroy(mac, "sequences type don't match, at %s", fname);

replace_done:
    return (seq1);
}

LispObj *
Lisp_Return(LispMac *mac, LispObj *list, char *fname)
{
    unsigned blevel = mac->block.block_level;

    while (blevel) {
	LispBlock *block = mac->block.block[--blevel];

	if (block->type == LispBlockClosure)
	    /* if reached a function call */
	    break;
	if (block->type == LispBlockTag && block->tag.type == LispNil_t) {
	    mac->block.block_ret = list == NIL ? NIL : EVAL(CAR(list));
	    LispBlockUnwind(mac);
	    longjmp(block->jmp, 1);
	}
    }
    LispDestroy(mac, "no visible NIL block, at %s", fname);
    /*NOTREACHED*/

    return (NIL);
}

LispObj *
Lisp_ReturnFrom(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *tag = CAR(list);
    unsigned blevel = mac->block.block_level;

    if (tag != NIL && tag != T && !SYMBOL_P(tag))
	LispDestroy(mac, "%s is not a symbol, at %s",
		    LispStrObj(mac, tag), fname);

    list = CDR(list);
    while (blevel) {
	int jmp = 1;
	LispBlock *block = mac->block.block[--blevel];

	if (tag->type == block->tag.type) {
	    switch (tag->type) {
		case LispNil_t:
		case LispTrue_t:
		    break;
		case LispAtom_t:
		    jmp = tag->data.atom == block->tag.data.atom;
		    break;
		default:
		    /* only atom, nil or t can be used */
		    jmp = 0;
		    break;
	    }
	}
	if (block->type != LispBlockTag && block->type != LispBlockClosure)
	    break;
	if (jmp) {
	    mac->block.block_ret = list == NIL ? NIL : EVAL(CAR(list));
	    LispBlockUnwind(mac);
	    longjmp(block->jmp, 1);
	}
	if (block->type != LispBlockTag)
	    /* can use return-from only in the current function */
	    break;
    }
    LispDestroy(mac, "no visible block named %s, at %s",
		LispStrObj(mac, tag), fname);
    /*NOTREACHED*/

    return (NIL);
}

LispObj *
Lisp_Reverse(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *res;

    switch (CAR(list)->type) {
	case LispNil_t:
	    return (NIL);
	    break;
	case LispCons_t:
	    break;
	default:
	    LispDestroy(mac, ExpectingListAt, fname);
	    /*NOTREACHED*/
    }

    GCProtect();
    res = NIL;
    list = CAR(list);
    while (list->type == LispCons_t && list != NIL) {
	res = CONS(CAR(list), res);
	list = CDR(list);
    }
    GCUProtect();

    return (res);
}

LispObj *
Lisp_Rplaca(LispMac *mac, LispObj *list, char *fname)
{
    if (CAR(list)->type != LispCons_t)
	LispDestroy(mac, "%s is not of type cons, at %s",
		    LispStrObj(mac, CAR(list)), fname);

    CAR(CAR(list)) = CAR(CDR(list));

    return (CAR(list));
}

LispObj *
Lisp_Rplacd(LispMac *mac, LispObj *list, char *fname)
{
    if (CAR(list)->type != LispCons_t)
	LispDestroy(mac, "%s is not of type cons, at %s",
		    LispStrObj(mac, CAR(list)), fname);

    CDR(CAR(list)) = CAR(CDR(list));

    return (CAR(list));
}

LispObj *
Lisp_Set(LispMac *mac, LispObj *list, char *fname)
{
    int count;
    LispObj *var, *val, *res = NIL;
			/* res always set, is minimum args is 2 */

    for (count = 0, var = list; var != NIL; count++, var = CDR(var))
	;
    if (count & 1)
	LispDestroy(mac, "odd number of arguments, at %s", fname);

    for (var = CAR(list), val = CAR(CDR(list)); list != NIL;
	 list = CDR(CDR(list)))
	res = _LispSet(mac, CAR(list), CAR(CDR(list)), fname, 0);

    return (res);
}

LispObj *
Lisp_SetQ(LispMac *mac, LispObj *list, char *fname)
{
    int count;
    LispObj *var, *val, *res = NIL;
			/* res always set, is minimum args is 2 */

    for (count = 0, var = list; var != NIL; count++, var = CDR(var))
	;
    if (count & 1)
	LispDestroy(mac, "odd number of arguments, at %s", fname);

    for (var = CAR(list), val = CAR(CDR(list)); list != NIL;
	 list = CDR(CDR(list)))
	res = _LispSet(mac, CAR(list), CAR(CDR(list)), fname, 1);

    return (res);
}

LispObj *
Lisp_Setf(LispMac *mac, LispObj *list, char *fname)
{
    int count;
    LispAtom *atom;
    LispObj *place, *setf, *res = NIL;

    for (count = 0, place = list; place != NIL; count++, place = CDR(place))
	;
    if (count & 1)
	LispDestroy(mac, "odd number of arguments, at %s", fname);

    for (place = CAR(list), list = CDR(list);
	 ; place = CAR(list), list = CDR(list)) {
	/* if a variable, just work like setq */
	if (SYMBOL_P(place))
	    res = _LispSet(mac, place, CAR(list), fname, 1);
	else if (place->type == LispCons_t) {
	    int struc_access = 0;

	    /* the default setf method for structures is generated here
	     * (cannot be done in EVAL as SETF is a macro), and the
	     * code executed is as if this definition were supplied:
	     *	(defsetf THE-STRUCT-FIELD (struct) (value)
	     *		`(xedit::struct-store 'THE-STRUCT-FIELD ,struct ,value))
	     */

	    setf = CAR(place);
	    if (!SYMBOL_P(setf) || setf->data.atom->property == NULL)
		LispDestroy(mac, "%s is a invalid %s place",
			    LispStrObj(mac, place), fname);

	    atom = setf->data.atom;

	    if (atom->property->defsetf == 0) {
		if (atom->property->defstruct &&
		    atom->property->structure.function >= 0) {
		    /* user didn't provide any special defsetf */
		    setf = ATOM("XEDIT::STRUCT-STORE");
		    struc_access = 1;
		}
		else
		    LispDestroy(mac, "%s is a invalid %s place",
				LispStrObj(mac, place), fname);
	    }
	    else
		setf = setf->data.atom->property->setf;

	    if (SYMBOL_P(setf)) {
		/* just change function call, and append value to arguments */
		LispObj *cod, *cdr, *obj, *frm = FRM;

		GCProtect();
		cod = cdr = CONS(setf, NIL);
		FRM = CONS(cod, FRM);
		GCUProtect();

		if (struc_access) {
		    /* using builtin setf method for structure field */
		    CDR(cdr) = CONS(QUOTE(CAR(place)), NIL);
		    cdr = CDR(cdr);
		}

		for (obj = CDR(place); obj != NIL; obj = CDR(obj)) {
		    CDR(cdr) = CONS(CAR(obj), NIL);
		    cdr = CDR(cdr);
		}
		CDR(cdr) = CONS(CAR(list), NIL);
		res = EVAL(cod);
		frm = FRM;
	    }
	    else
		res = LispRunSetf(mac, setf, place, CAR(list));

	}
	else
	    LispDestroy(mac, "%s is not a %s place",
			LispStrObj(mac, place), fname);

	if ((list = CDR(list)) == NIL)
	    break;
    }

    return (res);
}

LispObj *
Lisp_Stringp(LispMac *mac, LispObj *list, char *fname)
{
    return (STRING_P(CAR(list)) ? T : NIL);
}

LispObj *
Lisp_Subseq(LispMac *mac, LispObj *list, char *fname)
{
    int start, end, length, sublen;
    LispObj *seq, *ostart, *oend, *res;

    seq = CAR(list);
    if (seq != NIL && seq->type != LispCons_t &&
	!STRING_P(seq) && seq->type != LispArray_t)
	LispDestroy(mac, "%s is not a sequence, at %s",
		    LispStrObj(mac, seq), fname);
    length = Lisp_Length(mac, list, fname)->data.real;

    list = CDR(list);
    ostart = CAR(list);
    list = CDR(list);
    oend = list == NIL ? NIL : CAR(list);
    if (!INDEX_P(ostart) || (oend != NIL && !INDEX_P(oend)))
	LispDestroy(mac, "expecting positive integer, at %s", fname);

    start = NUMBER_VALUE(ostart);

    if (oend != NIL)
	end = NUMBER_VALUE(oend);
    else
	end = length;

    if (start > end || end > length)
	LispDestroy(mac, "bad index, at %s", fname);

    sublen = end - start;

    if (seq == NIL)
	res = NIL;
    else if (STRING_P(seq)) {
	char *str = LispMalloc(mac, sublen + 1);

	strncpy(str, STRPTR(seq) + start, sublen);
	str[sublen] = '\0';
	res = STRING(str);
	LispFree(mac, str);
    }
    else {
	LispObj *obj;

	GCProtect();
	if (end > start) {
	    /* list or array */
	    int count;
	    LispObj *cdr;

	    if (seq->type == LispArray_t)
		obj = seq->data.array.list;
	    else
		obj = seq;
	    /* goto first element to copy */
	    for (count = 0; count < start; count++, obj = CDR(obj))
		;
	    res = cdr = CONS(CAR(obj), NIL);
	    for (++count, obj = CDR(obj); count < end; count++, obj = CDR(obj)) {
		CDR(cdr) = CONS(CAR(obj), NIL);
		cdr = CDR(cdr);
	    }
	}
	else
	    res = NIL;

	if (seq->type == LispArray_t) {
	    obj = LispNew(mac, res, NIL);
	    obj->type = LispArray_t;
	    obj->data.array.list = res;
	    obj->data.array.dim = CONS(REAL(sublen), NIL);
	    obj->data.array.rank = 1;
	    obj->data.array.type = seq->data.array.type;
	    obj->data.array.zero = length == 0;
	    res = obj;
	}
	GCUProtect();
    }

    return (res);
}

LispObj *
Lisp_Symbolp(LispMac *mac, LispObj *list, char *fname)
{
    switch (CAR(list)->type) {
	case LispNil_t:
	case LispTrue_t:
	case LispAtom_t:
	case LispLambda_t:
	    return (T);
	default:
	    return (NIL);
    }
    /*NOTREACHED*/
}

LispObj *
Lisp_SymbolPlist(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *sym = CAR(list);

    if (sym == NIL || sym == T)
	return (sym);
    else if (!SYMBOL_P(sym))
	LispDestroy(mac, "%s is not a symbol, at %s",
		    LispStrObj(mac, sym), fname);

    return (sym->data.atom->property && sym->data.atom->property->property ?
	    sym->data.atom->property->properties : NIL);
}

LispObj *
Lisp_Tagbody(LispMac *mac, LispObj *list, char *fname)
{
    int did_jump, *pdid_jump = &did_jump, body_jump, *pbody_jump = &body_jump;
    LispObj * volatile body;
    LispObj *res, **pres = &res;
    LispBlock *block, *body_block;

    for (body = list; body != NIL; body = CDR(body))
	if (body->type == LispCons_t)
	    break;

    if (body == NIL)
	return (NIL);

    *pdid_jump = 1;
    *pres = NIL;
    block = LispBeginBlock(mac, NIL, LispBlockTag);
    if (setjmp(block->jmp) == 0) {
	body = list;
	while (1) {
	    *pbody_jump = 1;
	    body_block = LispBeginBlock(mac, NIL, LispBlockBody);
	    if (setjmp(body_block->jmp) == 0) {
		for (; body != NIL; body = CDR(body)) {
		    if (CAR(body)->type == LispCons_t)
			*pres = EVAL(CAR(body));
		}
		*pbody_jump = 0;
	    }
	    LispEndBlock(mac, body_block);
	    if (*pbody_jump) {
		int found = 0;
		LispObj *ptr, *tag;

		tag = mac->block.block_ret;
		for (ptr = body; ptr != NIL; ptr = CDR(ptr)) {
		    if (CAR(ptr)->type == tag->type &&
			((CAR(ptr) == NIL && tag->type == LispNil_t) ||
			 (CAR(ptr) == T && tag->type == LispTrue_t) ||
			 (NUMBER_P(ptr) && NUMBER_P(tag) &&
			  NUMBER_VALUE(ptr) == NUMBER_VALUE(tag)) ||
			 (SYMBOL_P(CAR(ptr)) && SYMBOL_P(tag) &&
			  CAR(ptr)->data.atom == tag->data.atom))) {
			found = 1;
			break;
		    }
		}
		if (ptr == NIL) {
		    for (ptr = list; ptr != body; ptr = CDR(ptr)) {
			if (CAR(ptr)->type == tag->type &&
			    ((CAR(ptr) == NIL && tag->type == LispNil_t) ||
			     (CAR(ptr) == T && tag->type == LispTrue_t) ||
			     (NUMBER_P(ptr) && NUMBER_P(tag) &&
			      NUMBER_VALUE(ptr) == NUMBER_VALUE(tag)) ||
			     (SYMBOL_P(CAR(ptr)) && SYMBOL_P(tag) &&
			      CAR(ptr)->data.atom == tag->data.atom))) {
			    found = 1;
			    break;
			}
		    }
		}
		/* XXX no search for duplicated tags, if there are
		 * duplicated tags, will just search the body for the tag,
		 * if the end of the list is reached, search again from
		 * beginning. This is (I believe) allowable for an interpreter,
		 * but if (byte) compiled code is to be generated, duplicated
		 * tags must not be allowed. */
		if ((body = ptr) == NIL)
		    LispDestroy(mac, "no such tag %s, at %s",
				LispStrObj(mac, tag), fname);

		/* search for start of code */
		for (body = CDR(body); body != NIL; body = CDR(body)) {
		    if (CAR(body)->type == LispCons_t)
			break;
		}

		/* just jumped to the bottom of the code body */
		if (body == NIL)
		    break;
	    }
	    else
		/* 'go' not called */
		break;
	    *pdid_jump = 1;
	}
	*pdid_jump = 0;
    }
    LispEndBlock(mac, block);
    if (*pdid_jump)
	*pres = mac->block.block_ret;

    return (*pres);
}

LispObj *
Lisp_Terpri(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *stream = NIL;

    if (list == NIL || CAR(list) == NIL)
	stream = NIL;
    else if (CAR(list)->type != LispStream_t)
	LispDestroy(mac, "%s is not a stream, at %s",
		    LispStrObj(mac, CAR(list)), fname);
    else
	stream = CAR(list);
    LispPrintf(mac, stream, "\n");
    mac->newline = 1;
    mac->column = 0;
    fflush(lisp_stdout);

    return (NIL);
}

LispObj *
Lisp_Throw(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *tag = EVAL(CAR(list));
    unsigned blevel = mac->block.block_level;

    if (blevel == 0)
	LispDestroy(mac, "%s called not within a block", fname);

    while (blevel) {
	int jmp = 1;
	LispBlock *block = mac->block.block[--blevel];

	if (block->type == LispBlockCatch && tag->type == block->tag.type) {
	    switch(tag->type) {
		case LispNil_t:
		case LispTrue_t:
		    break;
		case LispAtom_t:
		case LispString_t:
		    jmp = tag->data.atom == block->tag.data.atom;
		    break;
		case LispCharacter_t:
		case LispInteger_t:
		    jmp = tag->data.integer == block->tag.data.integer;
		    break;
		case LispReal_t:
		    jmp = tag->data.real == block->tag.data.real;
		    break;
		default:
		    jmp = memcmp(tag, &(block->tag), sizeof(LispObj)) == 0;
		    break;
	    }
	    if (jmp) {
		mac->block.block_ret = EVAL(CAR(CDR(list)));
		LispBlockUnwind(mac);
		longjmp(block->jmp, 1);
	    }
	}
    }
    LispDestroy(mac, "%s is not a tag to %s", LispStrObj(mac, tag), fname);
    /*NOTREACHED*/

    return (NIL);
}

LispObj *
Lisp_Typep(LispMac *mac, LispObj *list, char *fname)
{
    LispType type = LispStruct_t;
    LispObj *obj;
    char *atom = NULL;

    obj = CAR(CDR(list));
    if (obj == NIL || obj == T)
	return (obj);
    else if (!SYMBOL_P(obj))
	LispDestroy(mac, "%s is a bad type specification, at %s",
		    LispStrObj(mac, obj), fname);
    else {
	atom = STRPTR(obj);
	if (strcmp(atom, "ATOM") == 0)
	    type = LispAtom_t;
	else if (strcmp(atom, "REAL") == 0)
	    type = LispReal_t;
	else if (strcmp(atom, "LIST") == 0)
	    type = LispCons_t;
	else if (strcmp(atom, "STRING") == 0)
	    type = LispString_t;
	else if (strcmp(atom, "OPAQUE") == 0)
	    type = LispOpaque_t;
    }

    obj = CAR(list);
    if (type != LispStruct_t && obj->type == type)
	return (T);
    else if (obj->type == LispStruct_t)
	return (STRPTR(CAR(obj->data.struc.def)) == atom ? T : NIL);

    return (NIL);
}

LispObj *
Lisp_Unless(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispWhenUnless(mac, list, 0));
}

LispObj *
Lisp_UnwindProtect(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *prot = CAR(list), *res, **pres = &res;
    int did_jump, *pdid_jump = &did_jump;
    LispBlock *block;

    /* run protected code */
    *pres = NIL;
    *pdid_jump = 1;
    block = LispBeginBlock(mac, NIL, LispBlockProtect);
    if (setjmp(block->jmp) == 0) {
	*pres = EVAL(prot);
	*pdid_jump = 0;
    }
    LispEndBlock(mac, block);
    if (!mac->destroyed && *pdid_jump)
	*pres = mac->block.block_ret;

    /* run cleanup, unprotected code */
    if (CDR(list) != NIL)
	res = Lisp_Progn(mac, CDR(list), fname);
    else if (mac->destroyed)
	/* no cleanup code */
	LispDestroy(mac, NULL);	/* special handling if mac->destroyed */

    return (res);
}

LispObj *
Lisp_Vector(LispMac *mac, LispObj *list, char *fname)
{
    int count;
    LispObj *dim, *ary = list, *obj;

    for (count = 0; list != NIL; count++, list = CDR(list))
	;
    dim = CONS(REAL((double)count), NIL);

    obj = LispNew(mac, ary, dim); /* no need to gc protect, as dim is argument*/
    obj->type = LispArray_t;
    obj->data.array.list = ary;
    obj->data.array.dim = dim;
    obj->data.array.rank = 1;
    obj->data.array.type = LispTrue_t;
    obj->data.array.zero = count == 0;

    return (obj);
}

LispObj *
Lisp_When(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispWhenUnless(mac, list, 1));
}

LispObj *
Lisp_Until(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispWhileUntil(mac, list, 0));
}

LispObj *
Lisp_While(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispWhileUntil(mac, list, 1));
}

/* helper functions for setf
 *	DONT explicitly call these functions. Non standard functions
 */
LispObj *
Lisp_XeditEltStore(LispMac *mac, LispObj *list, char *fname)
{
    int len, pos;
    LispObj *seq, *opos, *value;

    seq = CAR(list);
    /* if not a sequence, Lisp_Length will see it */
    len = Lisp_Length(mac, list, fname)->data.real;

    list = CDR(list);
    opos = CAR(list);
    if (!INDEX_P(opos) || NUMBER_VALUE(opos) >= len)
	LispDestroy(mac, "bad index %s, at %s", LispStrObj(mac, opos), fname);
    pos = NUMBER_VALUE(opos);

    list = CDR(list);
    value = CAR(list);
    if (STRING_P(seq)) {
	int c;
	char *string;

	if (value->type != LispCharacter_t)
	    LispDestroy(mac, "%s is not a character, at %s",
			LispStrObj(mac, value), fname);

	c = value->data.integer;
	if (c < 0 || c > 255)
	    LispDestroy(mac, "cannot represent character %d, at %s", c, fname);

	string = LispStrdup(mac, STRPTR(seq));
	string[pos] = c;

	seq->data.atom = LispDoGetAtom(mac, string, 0, 0);
	LispFree(mac, string);
    }
    else {
	if (seq->type == LispArray_t)
	    seq = seq->data.array.list;

	for (; pos > 0; pos--, seq = CDR(seq))
	    ;
	CAR(seq) = value;
    }

    return (value);
}

LispObj *
Lisp_XeditPut(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *sym, *key, *val;

    if ((sym = CAR(list))->type != LispAtom_t)
	LispDestroy(mac, "expecting symbol, at %s", fname);
    list = CDR(list);
    key = CAR(list);
    list = CDR(list);
    val = CAR(list);

    return (CAR(LispPutAtomProperty(mac, sym->data.atom, key, val)));
}

LispObj *
Lisp_XeditVectorStore(LispMac *mac, LispObj *list, char *fname)
{
    long c, count, idx, seq;
    LispObj *ary = CAR(list), *dim = CDR(list), *obj;

    if (ary->type != LispArray_t)
	LispDestroy(mac, "%s is not an array, at %s",
		    LispStrObj(mac, ary), fname);

    for (count = 0, list = dim, obj = ary->data.array.dim; CDR(list) != NIL;
	 count++, list = CDR(list), obj = CDR(obj)) {
	if (count >= ary->data.array.rank)
	    LispDestroy(mac, "too many subscripts %s, at %s",
			LispStrObj(mac, dim), fname);
	if (!INDEX_P(CAR(list)) ||
	    NUMBER_VALUE(CAR(list)) >= NUMBER_VALUE(CAR(obj)))
	    LispDestroy(mac, "%s is out of range or a bad index, at %s",
			LispStrObj(mac, CAR(list)), fname);
    }
    if (count < ary->data.array.rank)
	LispDestroy(mac, "too few subscripts %s, at %s",
		    LispStrObj(mac, dim), fname);

    for (count = seq = 0, list = dim; CDR(list) != NIL;
	 list = CDR(list), seq++) {
	for (idx = 0, obj = ary->data.array.dim; idx < seq; obj = CDR(obj), ++idx)
	    ;
	for (c = 1, obj = CDR(obj); obj != NIL; obj = CDR(obj))
	    c *= NUMBER_VALUE(CAR(obj));
	count += c * NUMBER_VALUE(CAR(list));
    }

    for (ary = ary->data.array.list; count > 0; ary = CDR(ary), count--)
	;

    CAR(ary) = CAR(list);

    return (CAR(list));
}

LispObj *
Lisp_Zerop(LispMac *mac, LispObj *list, char *fname)
{
    LispObj *obj = CAR(list);

    if (!NUMBER_P(obj))
	LispDestroy(mac, "expecting number, at %s", fname);

    return (NUMBER_VALUE(obj) == 0 ? T : NIL);
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d30 1
a30 1
/* $XFree86: xc/programs/xedit/lisp/core.c,v 1.72 2003/05/27 22:27:01 tsi Exp $ */
d32 4
a35 41
#include "lisp/io.h"
#include "lisp/core.h"
#include "lisp/format.h"
#include "lisp/helper.h"
#include "lisp/package.h"
#include "lisp/private.h"
#include "lisp/write.h"

/*
 * Types
 */
typedef struct _SeqInfo {
    LispType type;
    union {
	LispObj *list;
	LispObj **vector;
	unsigned char *string;
    } data;
} SeqInfo;

#define SETSEQ(seq, object)						\
    switch (seq.type = XOBJECT_TYPE(object)) {				\
	case LispString_t:						\
	    seq.data.string = (unsigned char*)THESTR(object);		\
	    break;							\
	case LispCons_t:						\
	    seq.data.list = object;					\
	    break;							\
	default:							\
	    seq.data.list = object->data.array.list;			\
	    break;							\
    }

#ifdef __UNIXOS2__
# define finite(x) isfinite(x)
#endif

#ifdef NEED_SETENV
extern int setenv(const char *name, const char *value, int overwrite);
extern void unsetenv(const char *name);
#endif
d40 1
a40 102
#define NONE		0

#define	REMOVE		1
#define	SUBSTITUTE	2
#define DELETE		3
#define	NSUBSTITUTE	4

#define ASSOC		1
#define MEMBER		2

#define FIND		1
#define POSITION	2

#define	IF		1
#define	IFNOT		2

#define UNION		1
#define INTERSECTION	2
#define SETDIFFERENCE	3
#define SETEXCLUSIVEOR	4
#define SUBSETP		5
#define NSETDIFFERENCE	6
#define NINTERSECTION	7
#define NUNION		8
#define NSETEXCLUSIVEOR	9

#define COPY_LIST	1
#define COPY_ALIST	2
#define COPY_TREE	3

#define EVERY		1
#define SOME		2
#define NOTEVERY	3
#define NOTANY		4

/* Call directly LispObjectCompare() if possible */
#define FCODE(predicate)					\
    predicate == Oeql ? FEQL :					\
	predicate == Oequal ? FEQUAL :				\
	    predicate == Oeq ? FEQ :				\
		predicate == Oequalp ? FEQUALP : 0
#define FCOMPARE(predicate, left, right, code)			\
    code == FEQ ? left == right :				\
	code ? LispObjectCompare(left, right, code) != NIL :	\
	       APPLY2(predicate, left, right) != NIL

#define FUNCTION_CHECK(predicate)				\
    if (FUNCTIONP(predicate))					\
	predicate = (predicate)->data.atom->object

#define CHECK_TEST_0()						\
    if (test != UNSPEC && test_not != UNSPEC)			\
	LispDestroy("%s: specify either :TEST or :TEST-NOT",	\
		    STRFUN(builtin))

#define CHECK_TEST()						\
    CHECK_TEST_0();						\
    if (test_not == UNSPEC) {					\
	if (test == UNSPEC)					\
	    lambda = Oeql;					\
	else							\
	    lambda = test;					\
	expect = 1;						\
    }								\
    else {							\
	lambda = test_not;					\
	expect = 0;						\
    }								\
    FUNCTION_CHECK(lambda);					\
    code = FCODE(lambda)


static LispObj *LispAdjoin(LispBuiltin*,
			   LispObj*, LispObj*, LispObj*, LispObj*, LispObj*);
static LispObj *LispAssocOrMember(LispBuiltin*, int, int);
static LispObj *LispEverySomeAnyNot(LispBuiltin*, int);
static LispObj *LispFindOrPosition(LispBuiltin*, int, int);
static LispObj *LispDeleteOrRemoveDuplicates(LispBuiltin*, int);
static LispObj *LispDeleteRemoveXSubstitute(LispBuiltin*, int, int);
static LispObj *LispListSet(LispBuiltin*, int);
static LispObj *LispMapc(LispBuiltin*, int);
static LispObj *LispMapl(LispBuiltin*, int);
static LispObj *LispMapnconc(LispObj*);
extern LispObj *LispRunSetf(LispArgList*, LispObj*, LispObj*, LispObj*);
extern LispObj *LispRunSetfMacro(LispAtom*, LispObj*, LispObj*);
static LispObj *LispMergeSort(LispObj*, LispObj*, LispObj*, int);
static LispObj *LispXReverse(LispBuiltin*, int);
static LispObj *LispCopyList(LispBuiltin*, LispObj*, int);
static LispObj *LispValuesList(LispBuiltin*, int);
static LispObj *LispTreeEqual(LispObj*, LispObj*, LispObj*, int);
static LispDocType_t LispDocumentationType(LispBuiltin*, LispObj*);

extern void LispSetAtomObjectProperty(LispAtom*, LispObj*);

/*
 * Initialization
 */
LispObj *Oeq, *Oeql, *Oequal, *Oequalp, *Omake_array,
	*Kinitial_contents, *Osetf, *Ootherwise, *Oquote;
LispObj *Ogensym_counter;

Atom_id Svariable, Sstructure, Stype, Ssetf;
d45 2
a46 2
void
LispCoreInit(void)
d48 1
a48 20
    Oeq			= STATIC_ATOM("EQ");
    Oeql		= STATIC_ATOM("EQL");
    Oequal		= STATIC_ATOM("EQUAL");
    Oequalp		= STATIC_ATOM("EQUALP");
    Omake_array		= STATIC_ATOM("MAKE-ARRAY");
    Kinitial_contents	= KEYWORD("INITIAL-CONTENTS");
    Osetf		= STATIC_ATOM("SETF");
    Ootherwise		= STATIC_ATOM("OTHERWISE");
    LispExportSymbol(Ootherwise);
    Oquote		= STATIC_ATOM("QUOTE");
    LispExportSymbol(Oquote);

    Svariable		= GETATOMID("VARIABLE");
    Sstructure		= GETATOMID("STRUCTURE");
    Stype		= GETATOMID("TYPE");

    /* Create as a constant so that only the C code should change the value */
    Ogensym_counter	= STATIC_ATOM("*GENSYM-COUNTER*");
    LispDefconstant(Ogensym_counter, FIXNUM(0), NIL);
    LispExportSymbol(Ogensym_counter);
d50 6
a55 1
    Ssetf	= ATOMID(Osetf);
d59 1
a59 4
Lisp_Acons(LispBuiltin *builtin)
/*
 acons key datum alist
 */
d61 1
a61 1
    LispObj *key, *datum, *alist;
d63 6
a68 5
    alist = ARGUMENT(2);
    datum = ARGUMENT(1);
    key = ARGUMENT(0);

    return (CONS(CONS(key, datum), alist));
d71 2
a72 3
static LispObj *
LispAdjoin(LispBuiltin*builtin, LispObj *item, LispObj *list,
	   LispObj *key, LispObj *test, LispObj *test_not)
d74 1
a74 3
    GC_ENTER();
    int code, expect, value;
    LispObj *lambda, *compare, *object;
d76 10
a85 7
    CHECK_LIST(list);
    CHECK_TEST();

    if (key != UNSPEC) {
	item = APPLY1(key, item);
	/* Result is not guaranteed to be gc protected */
	GC_PROTECT(item);
d87 2
d90 4
a93 12
    /* Check if item is not already in place */
    for (object = list; CONSP(object); object = CDR(object)) {
	compare = CAR(object);
	if (key != UNSPEC) {
	    compare = APPLY1(key, compare);
	    GC_PROTECT(compare);
	    value = FCOMPARE(lambda, item, compare, code);
	    /* Unprotect compare... */
	    --lisp__data.protect.length;
	}
	else
	    value = FCOMPARE(lambda, item, compare, code);
d95 15
a109 6
	if (value == expect) {
	    /* Item is already in list */
	    GC_LEAVE();

	    return (list);
	}
d111 2
a112 1
    GC_LEAVE();
d114 6
a119 1
    return (CONS(item, list));
d123 1
a123 4
Lisp_Adjoin(LispBuiltin *builtin)
/*
 adjoin item list &key key test test-not
 */
d125 4
a128 1
    LispObj *item, *list, *key, *test, *test_not;
d130 5
a134 5
    test_not = ARGUMENT(4);
    test = ARGUMENT(3);
    key = ARGUMENT(2);
    list = ARGUMENT(1);
    item = ARGUMENT(0);
d136 4
a139 1
    return (LispAdjoin(builtin, item, list, key, test, test_not));
d143 1
a143 4
Lisp_Append(LispBuiltin *builtin)
/*
 append &rest lists
 */
d145 2
a146 2
    GC_ENTER();
    LispObj *result, *cons, *list;
d148 5
a152 1
    LispObj *lists;
d154 5
a158 1
    lists = ARGUMENT(0);
d160 4
a163 42
    /* no arguments */
    if (!CONSP(lists))
	return (NIL);

    /* skip initial nil lists */
    for (; CONSP(CDR(lists)) && CAR(lists) == NIL; lists = CDR(lists))
	;

    /* last argument is not copied (even if it is the single argument) */
    if (!CONSP(CDR(lists)))
	return (CAR(lists));

    /* make sure result is a list */
    list = CAR(lists);
    CHECK_CONS(list);
    result = cons = CONS(CAR(list), NIL);
    GC_PROTECT(result);
    for (list = CDR(list); CONSP(list); list = CDR(list)) {
	RPLACD(cons, CONS(CAR(list), NIL));
	cons = CDR(cons);
    }
    lists = CDR(lists);

    /* copy intermediate lists */
    for (; CONSP(CDR(lists)); lists = CDR(lists)) {
	list = CAR(lists);
	if (list == NIL)
	    continue;
	/* intermediate elements must be lists */
	CHECK_CONS(list);
	for (; CONSP(list); list = CDR(list)) {
	    RPLACD(cons, CONS(CAR(list), NIL));
	    cons = CDR(cons);
	}
    }

    /* add last element */
    RPLACD(cons, CAR(lists));

    GC_LEAVE();

    return (result);
d167 1
a167 4
Lisp_Aref(LispBuiltin *builtin)
/*
 aref array &rest subscripts
 */
d170 1
a170 6
    LispObj *obj, *dim;

    LispObj *array, *subscripts;

    subscripts = ARGUMENT(1);
    array = ARGUMENT(0);
d172 17
a188 3
    /* accept strings also */
    if (STRINGP(array) && CONSP(subscripts) && CDR(subscripts) == NIL) {
	long offset, length = STRLEN(array);
d190 2
a191 29
	CHECK_INDEX(CAR(subscripts));
	offset = FIXNUM_VALUE(CAR(subscripts));

	if (offset >= length)
	    LispDestroy("%s: index %ld too large for sequence length %ld",
			STRFUN(builtin), offset, length);

	return (SCHAR(THESTR(array)[offset]));
    }

    CHECK_ARRAY(array);

    for (count = 0, dim = subscripts, obj = array->data.array.dim; CONSP(dim);
	 count++, dim = CDR(dim), obj = CDR(obj)) {
	if (count >= array->data.array.rank)
	    LispDestroy("%s: too many subscripts %s",
			STRFUN(builtin), STROBJ(subscripts));
	if (!INDEXP(CAR(dim)) ||
	    FIXNUM_VALUE(CAR(dim)) >= FIXNUM_VALUE(CAR(obj)))
	    LispDestroy("%s: %s is out of range or a bad index",
			STRFUN(builtin), STROBJ(CAR(dim)));
    }
    if (count < array->data.array.rank)
	LispDestroy("%s: too few subscripts %s",
		    STRFUN(builtin), STROBJ(subscripts));

    for (count = seq = 0, dim = subscripts; CONSP(dim); dim = CDR(dim), seq++) {
	for (idx = 0, obj = array->data.array.dim; idx < seq;
	     obj = CDR(obj), ++idx)
d194 2
a195 2
	    c *= FIXNUM_VALUE(CAR(obj));
	count += c * FIXNUM_VALUE(CAR(dim));
d198 1
a198 1
    for (array = array->data.array.list; count > 0; array = CDR(array), count--)
d201 1
a201 1
    return (CAR(array));
d204 2
a205 10
static LispObj *
LispAssocOrMember(LispBuiltin *builtin, int function, int comparison)
/*
 assoc item list &key test test-not key
 assoc-if predicate list &key key
 assoc-if-not predicate list &key key
 member item list &key test test-not key
 member-if predicate list &key key
 member-if-not predicate list &key key
 */
d207 1
a207 20
    int code = 0, expect, value;
    LispObj *lambda, *result, *compare;

    LispObj *item, *list, *test, *test_not, *key;

    if (comparison == NONE) {
	key = ARGUMENT(4);
	test_not = ARGUMENT(3);
	test = ARGUMENT(2);
	list = ARGUMENT(1);
	item = ARGUMENT(0);
	lambda = NIL;
    }
    else {
	key = ARGUMENT(2);
	list = ARGUMENT(1);
	lambda = ARGUMENT(0);
	test = test_not = UNSPEC;
	item = NIL;
    }
d209 2
a212 19
    CHECK_CONS(list);

    /* Resolve compare function, and expected result of comparison */
    if (comparison == NONE) {
	CHECK_TEST();
    }
    else
	expect = comparison == IFNOT ? 0 : 1;

    result = NIL;
    for (; CONSP(list); list = CDR(list)) {
	compare = CAR(list);
	if (function == ASSOC) {
	    if (!CONSP(compare))
		continue;
	    compare = CAR(compare);
	}
	if (key != UNSPEC)
	    compare = APPLY1(key, compare);
d214 5
a218 8
	if (comparison == NONE)
	    value = FCOMPARE(lambda, item, compare, code);
	else
	    value = APPLY1(lambda, compare) != NIL;
	if (value == expect) {
	    result = list;
	    if (function == ASSOC)
		result = CAR(result);
a221 3
    if (function == MEMBER) {
	CHECK_LIST(list);
    }
d223 1
a223 1
    return (result);
d227 1
a227 4
Lisp_Assoc(LispBuiltin *builtin)
/*
 assoc item list &key test test-not key
 */
d229 1
a229 2
    return (LispAssocOrMember(builtin, ASSOC, NONE));
}
d231 5
a235 7
LispObj *
Lisp_AssocIf(LispBuiltin *builtin)
/*
 assoc-if predicate list &key key
 */
{
    return (LispAssocOrMember(builtin, ASSOC, IF));
d239 1
a239 4
Lisp_AssocIfNot(LispBuiltin *builtin)
/*
 assoc-if-not predicate list &key key
 */
d241 1
a241 2
    return (LispAssocOrMember(builtin, ASSOC, IFNOT));
}
d243 4
a246 7
LispObj *
Lisp_And(LispBuiltin *builtin)
/*
 and &rest args
 */
{
    LispObj *result = T, *args;
d248 2
a249 1
    args = ARGUMENT(0);
d251 33
a283 4
    for (; CONSP(args); args = CDR(args)) {
	result = EVAL(CAR(args));
	if (result == NIL)
	    break;
d285 1
d287 1
a287 1
    return (result);
d291 1
a291 4
Lisp_Apply(LispBuiltin *builtin)
/*
 apply function arg &rest more-args
 */
d293 1
a293 2
    GC_ENTER();
    LispObj *result, *arguments;
d295 18
a312 12
    LispObj *function, *arg, *more_args;

    more_args = ARGUMENT(2);
    arg = ARGUMENT(1);
    function = ARGUMENT(0);

    if (more_args == NIL) {
	CHECK_LIST(arg);
	arguments = arg;
	for (; CONSP(arg); arg = CDR(arg))
	    ;
	CHECK_LIST(arg);
d314 6
a319 19
    else {
	LispObj *cons;

	CHECK_CONS(more_args);
	arguments = cons = CONS(arg, NIL);
	GC_PROTECT(arguments);
	for (arg = CDR(more_args);
	     CONSP(arg);
	     more_args = arg, arg = CDR(arg)) {
	    RPLACD(cons, CONS(CAR(more_args), NIL));
	    cons = CDR(cons);
	}
	more_args = CAR(more_args);
	if (more_args != NIL) {
	    for (arg = more_args; CONSP(arg); arg = CDR(arg))
		;
	    CHECK_LIST(arg);
	    RPLACD(cons, more_args);
	}
d322 1
a322 2
    result = APPLY(function, arguments);
    GC_LEAVE();
d324 1
a324 1
    return (result);
d328 1
a328 4
Lisp_Atom(LispBuiltin *builtin)
/*
 atom object
 */
d330 1
a330 1
    LispObj *object;
d332 12
a343 3
    object = ARGUMENT(0);

    return (CONSP(object) ? NIL : T);
d347 1
a347 4
Lisp_Block(LispBuiltin *builtin)
/*
 block name &rest body
 */
d353 3
a355 8
    LispObj *name, *body;

    body = ARGUMENT(1);
    name = ARGUMENT(0);

    if (!SYMBOLP(name) && name != NIL && name != T)
	LispDestroy("%s: %s cannot name a block",
		    STRFUN(builtin), STROBJ(name));
d359 1
a359 1
    block = LispBeginBlock(name, LispBlockTag);
d361 1
a361 2
	for (; CONSP(body); body = CDR(body))
	    res = EVAL(CAR(body));
d364 1
a364 1
    LispEndBlock(block);
d366 1
a366 1
	*pres = lisp__data.block.block_ret;
d368 1
a368 1
    return (res);
d372 1
a372 4
Lisp_Boundp(LispBuiltin *builtin)
/*
 boundp symbol
 */
d374 35
a408 33
    LispAtom *atom;

    LispObj *symbol = ARGUMENT(0);

    CHECK_SYMBOL(symbol);

    atom = symbol->data.atom;
    if (atom->package == lisp__data.keyword ||
	(atom->a_object && atom->property->value != UNBOUND))
	return (T);

    return (NIL);
}

LispObj *
Lisp_Butlast(LispBuiltin *builtin)
/*
 butlast list &optional count
 */
{
    GC_ENTER();
    long length, count;
    LispObj *result, *cons, *list, *ocount;

    ocount = ARGUMENT(1);
    list = ARGUMENT(0);

    CHECK_LIST(list);
    if (ocount == UNSPEC)
	count = 1;
    else {
	CHECK_INDEX(ocount);
	count = FIXNUM_VALUE(ocount);
a409 1
    length = LispLength(list);
d411 11
a421 11
    if (count == 0)
	return (list);
    else if (count >= length)
	return (NIL);

    length -= count + 1;
    result = cons = CONS(CAR(list), NIL);
    GC_PROTECT(result);
    for (list = CDR(list); length > 0; list = CDR(list), length--) {
	RPLACD(cons, CONS(CAR(list), NIL));
	cons = CDR(cons);
d423 1
a423 1
    GC_LEAVE();
d425 1
a425 1
    return (result);
d429 1
a429 4
Lisp_Nbutlast(LispBuiltin *builtin)
/*
 nbutlast list &optional count
 */
d431 1
a431 2
    long length, count;
    LispObj *result, *list, *ocount;
d433 10
a442 9
    ocount = ARGUMENT(1);
    list = ARGUMENT(0);

    CHECK_LIST(list);
    if (ocount == UNSPEC)
	count = 1;
    else {
	CHECK_INDEX(ocount);
	count = FIXNUM_VALUE(ocount);
a443 1
    length = LispLength(list);
d445 1
a445 12
    if (count == 0)
	return (list);
    else if (count >= length)
	return (NIL);

    length -= count + 1;
    result = list;
    for (; length > 0; list = CDR(list), length--)
	;
    RPLACD(list, NIL);

    return (result);
d449 1
a449 4
Lisp_Car(LispBuiltin *builtin)
/*
 car list
 */
d451 2
a452 1
    LispObj *list, *result = NULL;
d454 2
a455 1
    list = ARGUMENT(0);
d457 15
a471 34
    if (list == NIL)
	result = NIL;
    else {
	CHECK_CONS(list);
	result = CAR(list);
    }

    return (result);
}

LispObj *
Lisp_Case(LispBuiltin *builtin)
/*
 case keyform &rest body
 */
{
    LispObj *result, *code, *keyform, *body, *form;

    body = ARGUMENT(1);
    keyform = ARGUMENT(0);

    result = NIL;
    keyform = EVAL(keyform);

    for (; CONSP(body); body = CDR(body)) {
	code = CAR(body);
	CHECK_CONS(code);

	form = CAR(code);
	if (form == T || form == Ootherwise) {
	    if (CONSP(CDR(body)))
		LispDestroy("%s: %s must be the last clause",
			    STRFUN(builtin), STROBJ(CAR(code)));
	    result = CDR(code);
d474 6
a479 4
	else if (CONSP(form)) {
	    for (; CONSP(form); form = CDR(form))
		if (XEQL(keyform, CAR(form)) == T) {
		    result = CDR(code);
d482 1
a482 1
	    if (CONSP(form))	/* if found match */
d485 2
a486 2
	else if (XEQL(keyform, form) == T) {
	    result = CDR(code);
d491 1
a491 4
    for (body = result; CONSP(body); body = CDR(body))
	result = EVAL(CAR(body));

    return (result);
d495 1
a495 4
Lisp_Catch(LispBuiltin *builtin)
/*
 catch tag &rest body
 */
a500 5
    LispObj *tag, *body;

    body = ARGUMENT(1);
    tag = ARGUMENT(0);

d503 1
a503 1
    block = LispBeginBlock(tag, LispBlockCatch);
d505 1
a505 2
	for (; CONSP(body); body = CDR(body))
	    res = EVAL(CAR(body));
d508 1
a508 1
    LispEndBlock(block);
d510 1
a510 1
	*pres = lisp__data.block.block_ret;
d512 1
a512 1
    return (res);
d516 1
a516 4
Lisp_Coerce(LispBuiltin *builtin)
/*
 coerce object result-type
 */
d518 29
a546 1
    LispObj *object, *result_type;
d548 33
a580 2
    result_type = ARGUMENT(1);
    object = ARGUMENT(0);
d582 1
a582 1
    return (LispCoerce(builtin, object, result_type));
d586 1
a586 4
Lisp_Cdr(LispBuiltin *builtin)
/*
 cdr list
 */
d588 1
a588 1
    LispObj *list, *result = NULL;
d590 10
a599 7
    list = ARGUMENT(0);

    if (list == NIL)
	result = NIL;
    else {
	CHECK_CONS(list);
	result = CDR(list);
d602 1
a602 1
    return (result);
d606 1
a606 4
Lisp_C_r(LispBuiltin *builtin)
/*
 c[ad]{2,4}r list
 */
d608 1
a608 1
    char *desc;
d610 11
a620 14
    LispObj *list, *result = NULL;

    list = ARGUMENT(0);

    result = list;
    desc = STRFUN(builtin);
    while (desc[1] != 'R')
	++desc;
    while (*desc != 'C') {
	if (result == NIL)
	    break;
	CHECK_CONS(result);
	result = *desc == 'A' ? CAR(result) : CDR(result);
	--desc;
d623 1
a623 1
    return (result);
d627 1
a627 4
Lisp_Cond(LispBuiltin *builtin)
/*
 cond &rest body
 */
d629 2
a630 1
    LispObj *result, *code, *body;
d632 6
a637 5
    body = ARGUMENT(0);

    result = NIL;
    for (; CONSP(body); body = CDR(body)) {
	code = CAR(body);
d639 6
a644 7
	CHECK_CONS(code);
	result = EVAL(CAR(code));
	if (result == NIL)
	    continue;
	for (code = CDR(code); CONSP(code); code = CDR(code))
	    result = EVAL(CAR(code));
	break;
d647 2
a648 8
    return (result);
}

static LispObj *
LispCopyList(LispBuiltin *builtin, LispObj *list, int function)
{
    GC_ENTER();
    LispObj *result, *cons;
d650 14
a663 3
    if (list == NIL)
	return (list);
    CHECK_CONS(list);
d665 4
a668 14
    result = cons = CONS(NIL, NIL);
    GC_PROTECT(result);
    if (CONSP(CAR(list))) {
	switch (function) {
	    case COPY_LIST:
		RPLACA(result, CAR(list));
		break;
	    case COPY_ALIST:
		RPLACA(result, CONS(CAR(CAR(list)), CDR(CAR(list))));
		break;
	    case COPY_TREE:
		RPLACA(result, LispCopyList(builtin, CAR(list), COPY_TREE));
		break;
	}
d670 3
a672 19
    else
	RPLACA(result, CAR(list));

    for (list = CDR(list); CONSP(list); list = CDR(list)) {
	CDR(cons) = CONS(NIL, NIL);
	cons = CDR(cons);
	if (CONSP(CAR(list))) {
	    switch (function) {
		case COPY_LIST:
		    RPLACA(cons, CAR(list));
		    break;
		case COPY_ALIST:
		    RPLACA(cons, CONS(CAR(CAR(list)), CDR(CAR(list))));
		    break;
		case COPY_TREE:
		    RPLACA(cons, LispCopyList(builtin, CAR(list), COPY_TREE));
		    break;
	    }
	}
d674 1
a674 1
	    RPLACA(cons, CAR(list));
a675 3
    /* in case list is dotted */
    RPLACD(cons, list);
    GC_LEAVE();
d677 1
a677 1
    return (result);
d681 1
a681 4
Lisp_CopyAlist(LispBuiltin *builtin)
/*
 copy-alist list
 */
d683 1
a683 5
    LispObj *list;

    list = ARGUMENT(0);

    return (LispCopyList(builtin, list, COPY_ALIST));
d687 1
a687 4
Lisp_CopyList(LispBuiltin *builtin)
/*
 copy-list list
 */
d689 1
a689 5
    LispObj *list;

    list = ARGUMENT(0);

    return (LispCopyList(builtin, list, COPY_LIST));
d693 1
a693 4
Lisp_CopyTree(LispBuiltin *builtin)
/*
 copy-tree list
 */
d695 9
a703 1
    LispObj *list;
d705 1
a705 1
    list = ARGUMENT(0);
d707 4
a710 1
    return (LispCopyList(builtin, list, COPY_TREE));
d714 1
a714 4
Lisp_Cons(LispBuiltin *builtin)
/*
 cons car cdr
 */
d716 1
a716 6
    LispObj *car, *cdr;

    cdr = ARGUMENT(1);
    car = ARGUMENT(0);

    return (CONS(car, cdr));
d720 1
a720 4
Lisp_Consp(LispBuiltin *builtin)
/*
 consp object
 */
d722 1
a722 5
    LispObj *object;

    object = ARGUMENT(0);

    return (CONSP(object) ? T : NIL);
d726 1
a726 4
Lisp_Constantp(LispBuiltin *builtin)
/*
 constantp form &optional environment
 */
d728 1
a728 15
    LispObj *form;

    form = ARGUMENT(0);

    /* not all self-evaluating objects are considered constants */
    if (!POINTERP(form) ||
	NUMBERP(form) ||
	XQUOTEP(form) ||
	(XCONSP(form) && CAR(form) == Oquote) ||
	(XSYMBOLP(form) && form->data.atom->constant) ||
	XSTRINGP(form) ||
	XARRAYP(form))
	return (T);

    return (NIL);
d732 1
a732 4
Lisp_Defconstant(LispBuiltin *builtin)
/*
 defconstant name initial-value &optional documentation
 */
d734 1
a734 15
    LispObj *name, *initial_value, *documentation;

    documentation = ARGUMENT(2);
    initial_value = ARGUMENT(1);
    name = ARGUMENT(0);

    CHECK_SYMBOL(name);
    if (documentation != UNSPEC) {
	CHECK_STRING(documentation);
    }
    else
	documentation = NIL;
    LispDefconstant(name, EVAL(initial_value), documentation);

    return (name);
d738 1
a738 4
Lisp_Defmacro(LispBuiltin *builtin)
/*
 defmacro name lambda-list &rest body
 */
d740 2
a741 1
    LispArgList *alist;
d743 2
a744 1
    LispObj *lambda, *name, *lambda_list, *body;
d746 3
a748 3
    body = ARGUMENT(2);
    lambda_list = ARGUMENT(1);
    name = ARGUMENT(0);
d750 5
a754 2
    CHECK_SYMBOL(name);
    alist = LispCheckArguments(LispMacro, lambda_list, ATOMID(name), 0);
d756 3
a758 3
    if (CONSP(body) && STRINGP(CAR(body))) {
	LispAddDocumentation(name, CAR(body), LispDocFunction);
	body = CDR(body);
d761 2
a762 2
    lambda_list = LispListProtectedArguments(alist);
    lambda = LispNewLambda(name, body, lambda_list, LispMacro);
d764 5
a768 7
    if (name->data.atom->a_builtin || name->data.atom->a_compiled) {
	if (name->data.atom->a_builtin) {
	    ERROR_CHECK_SPECIAL_FORM(name->data.atom);
	}
	/* redefining these may cause surprises if bytecode
	 * compiled functions references them */
	LispWarning("%s: %s is being redefined", STRFUN(builtin), ATOMID(name));
d770 4
a773 2
	LispRemAtomBuiltinProperty(name->data.atom);
    }
d775 3
a777 2
    LispSetAtomFunctionProperty(name->data.atom, lambda, alist);
    LispUseArgList(alist);
d779 1
a779 1
    return (name);
d783 1
a783 4
Lisp_Defun(LispBuiltin *builtin)
/*
 defun name lambda-list &rest body
 */
d785 2
a786 1
    LispArgList *alist;
d788 4
a791 1
    LispObj *lambda, *name, *lambda_list, *body;
d793 2
a794 3
    body = ARGUMENT(2);
    lambda_list = ARGUMENT(1);
    name = ARGUMENT(0);
d796 2
a797 2
    CHECK_SYMBOL(name);
    alist = LispCheckArguments(LispFunction, lambda_list, ATOMID(name), 0);
d799 4
a802 7
    if (CONSP(body) && STRINGP(CAR(body))) {
	LispAddDocumentation(name, CAR(body), LispDocFunction);
	body = CDR(body);
    }

    lambda_list = LispListProtectedArguments(alist);
    lambda = LispNewLambda(name, body, lambda_list, LispFunction);
d804 4
a807 7
    if (name->data.atom->a_builtin || name->data.atom->a_compiled) {
	if (name->data.atom->a_builtin) {
	    ERROR_CHECK_SPECIAL_FORM(name->data.atom);
	}
	/* redefining these may cause surprises if bytecode
	 * compiled functions references them */
	LispWarning("%s: %s is being redefined", STRFUN(builtin), ATOMID(name));
d809 7
a815 1
	LispRemAtomBuiltinProperty(name->data.atom);
a816 2
    LispSetAtomFunctionProperty(name->data.atom, lambda, alist);
    LispUseArgList(alist);
d818 1
a818 1
    return (name);
d822 1
a822 4
Lisp_Defsetf(LispBuiltin *builtin)
/*
 defsetf function lambda-list &rest body
 */
d824 1
a824 3
    LispArgList *alist;
    LispObj *obj;
    LispObj *lambda, *function, *lambda_list, *store, *body;
d826 2
a827 3
    body = ARGUMENT(2);
    lambda_list = ARGUMENT(1);
    function = ARGUMENT(0);
d829 4
a832 1
    CHECK_SYMBOL(function);
d834 4
a837 6
    if (body == NIL || (CONSP(body) && STRINGP(CAR(body)))) {
	if (!SYMBOLP(lambda_list))
	    LispDestroy("%s: syntax error %s %s",
			STRFUN(builtin), STROBJ(function), STROBJ(lambda_list));
	if (body != NIL)
	    LispAddDocumentation(function, CAR(body), LispDocSetf);
d839 1
a839 1
	LispSetAtomSetfProperty(function->data.atom, lambda_list, NULL);
d841 8
a848 1
	return (function);
d851 1
a851 21
    alist = LispCheckArguments(LispSetf, lambda_list, ATOMID(function), 0);

    store = CAR(body);
    if (!CONSP(store))
	LispDestroy("%s: %s is a bad store value",
		    STRFUN(builtin), STROBJ(store));
    for (obj = store; CONSP(obj); obj = CDR(obj)) {
	CHECK_SYMBOL(CAR(obj));
    }

    body = CDR(body);
    if (CONSP(body) && STRINGP(CAR(body))) {
	LispAddDocumentation(function, CAR(body), LispDocSetf);
	body = CDR(body);
    }

    lambda = LispNewLambda(function, body, store, LispSetf);
    LispSetAtomSetfProperty(function->data.atom, lambda, alist);
    LispUseArgList(alist);

    return (function);
d855 1
a855 4
Lisp_Defparameter(LispBuiltin *builtin)
/*
 defparameter name initial-value &optional documentation
 */
d857 1
a857 14
    LispObj *name, *initial_value, *documentation;

    documentation = ARGUMENT(2);
    initial_value = ARGUMENT(1);
    name = ARGUMENT(0);

    CHECK_SYMBOL(name);
    if (documentation != UNSPEC) {
	CHECK_STRING(documentation);
    }
    else
	documentation = NIL;

    LispProclaimSpecial(name, EVAL(initial_value), documentation);
d859 1
a859 1
    return (name);
d863 1
a863 4
Lisp_Defvar(LispBuiltin *builtin)
/*
 defvar name &optional initial-value documentation
 */
d865 2
a866 1
    LispObj *name, *initial_value, *documentation;
d868 2
a869 10
    documentation = ARGUMENT(2);
    initial_value = ARGUMENT(1);
    name = ARGUMENT(0);

    CHECK_SYMBOL(name);
    if (documentation != UNSPEC) {
	CHECK_STRING(documentation);
    }
    else
	documentation = NIL;
d871 2
a872 3
    LispProclaimSpecial(name,
			initial_value != UNSPEC ? EVAL(initial_value) : NULL,
			documentation);
d874 9
a882 2
    return (name);
}
d884 2
a885 8
LispObj *
Lisp_Delete(LispBuiltin *builtin)
/*
 delete item sequence &key from-end test test-not start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, DELETE, NONE));
}
d887 2
a888 16
LispObj *
Lisp_DeleteIf(LispBuiltin *builtin)
/*
 delete-if predicate sequence &key from-end start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, DELETE, IF));
}

LispObj *
Lisp_DeleteIfNot(LispBuiltin *builtin)
/*
 delete-if-not predicate sequence &key from-end start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, DELETE, IFNOT));
d892 1
a892 4
Lisp_DeleteDuplicates(LispBuiltin *builtin)
/*
 delete-duplicates sequence &key from-end test test-not start end key
 */
d894 3
a896 2
    return (LispDeleteOrRemoveDuplicates(builtin, DELETE));
}
d898 7
a904 8
LispObj *
Lisp_Do(LispBuiltin *builtin)
/*
 do init test &rest body
 */
{
    return (LispDo(builtin, 0));
}
d906 2
a907 8
LispObj *
Lisp_DoP(LispBuiltin *builtin)
/*
 do* init test &rest body
 */
{
    return (LispDo(builtin, 1));
}
d909 2
a910 5
static LispDocType_t
LispDocumentationType(LispBuiltin *builtin, LispObj *type)
{
    Atom_id atom;
    LispDocType_t doc_type = LispDocVariable;
d912 5
a916 13
    CHECK_SYMBOL(type);
    atom = ATOMID(type);

    if (atom == Svariable)
	doc_type = LispDocVariable;
    else if (atom == Sfunction)
	doc_type = LispDocFunction;
    else if (atom == Sstructure)
	doc_type = LispDocStructure;
    else if (atom == Stype)
	doc_type = LispDocType;
    else if (atom == Ssetf)
	doc_type = LispDocSetf;
d918 4
a921 3
	LispDestroy("%s: unknown documentation type %s",
		    STRFUN(builtin), STROBJ(type));
	/*NOTREACHED*/
d924 1
a924 1
    return (doc_type);
d928 1
a928 4
Lisp_Documentation(LispBuiltin *builtin)
/*
 documentation symbol type
 */
d930 1
a930 1
    LispObj *symbol, *type;
d932 10
a941 2
    type = ARGUMENT(1);
    symbol = ARGUMENT(0);
d943 1
a943 4
    CHECK_SYMBOL(symbol);
    /* type is checked in LispDocumentationType() */

    return (LispGetDocumentation(symbol, LispDocumentationType(builtin, type)));
d947 1
a947 1
Lisp_DoList(LispBuiltin *builtin)
d949 1
a949 1
    return (LispDoListTimes(builtin, 0));
d953 1
a953 1
Lisp_DoTimes(LispBuiltin *builtin)
d955 1
a955 1
    return (LispDoListTimes(builtin, 1));
d959 1
a959 5
Lisp_Elt(LispBuiltin *builtin)
/*
 elt sequence index
 svref sequence index
 */
d961 2
a962 2
    long offset, length;
    LispObj *result, *sequence, *oindex;
d964 4
a967 2
    oindex = ARGUMENT(1);
    sequence = ARGUMENT(0);
d969 8
a976 1
    length = LispLength(sequence);
d978 2
a979 2
    CHECK_INDEX(oindex);
    offset = FIXNUM_VALUE(oindex);
d981 1
a981 3
    if (offset >= length)
	LispDestroy("%s: index %ld too large for sequence length %ld",
		    STRFUN(builtin), offset, length);
d983 4
a986 5
    if (STRINGP(sequence))
	result = SCHAR(THESTR(sequence)[offset]);
    else {
	if (ARRAYP(sequence))
	    sequence = sequence->data.array.list;
d988 2
a989 4
	for (; offset > 0; offset--, sequence = CDR(sequence))
	    ;
	result = CAR(sequence);
    }
d991 1
a991 1
    return (result);
d995 1
a995 4
Lisp_Endp(LispBuiltin *builtin)
/*
 endp object
 */
d997 2
a998 1
    LispObj *object;
d1000 24
a1023 5
    object = ARGUMENT(0);

    if (object == NIL)
	return (T);
    CHECK_CONS(object);
d1025 1
a1025 1
    return (NIL);
d1029 1
a1029 4
Lisp_Eq(LispBuiltin *builtin)
/*
 eq left right
 */
d1031 1
a1031 6
    LispObj *left, *right;

    right = ARGUMENT(1);
    left = ARGUMENT(0);

    return (XEQ(left, right));
d1035 1
a1035 4
Lisp_Eql(LispBuiltin *builtin)
/*
 eql left right
 */
d1037 1
a1037 6
    LispObj *left, *right;

    right = ARGUMENT(1);
    left = ARGUMENT(0);

    return (XEQL(left, right));
d1041 1
a1041 4
Lisp_Equal(LispBuiltin *builtin)
/*
 equal left right
 */
d1043 1
a1043 6
    LispObj *left, *right;

    right = ARGUMENT(1);
    left = ARGUMENT(0);

    return (XEQUAL(left, right));
d1047 1
a1047 4
Lisp_Equalp(LispBuiltin *builtin)
/*
 equalp left right
 */
d1049 1
a1049 1
    LispObj *left, *right;
d1051 17
a1067 2
    right = ARGUMENT(1);
    left = ARGUMENT(0);
d1069 1
a1069 1
    return (XEQUALP(left, right));
d1073 1
a1073 4
Lisp_Error(LispBuiltin *builtin)
/*
 error control-string &rest arguments
 */
d1075 7
a1081 11
    LispObj *string, *arglist;

    LispObj *control_string, *arguments;

    arguments = ARGUMENT(1);
    control_string = ARGUMENT(0);

    arglist = CONS(NIL, CONS(control_string, arguments));
    GC_PROTECT(arglist);
    string = APPLY(Oformat, arglist);
    LispDestroy("%s", THESTR(string));
a1082 3

    /* No need to call GC_ENTER() and GC_LEAVE() macros */
    return (NIL);
d1086 1
a1086 4
Lisp_Eval(LispBuiltin *builtin)
/*
 eval form
 */
d1088 2
a1089 2
    int lex;
    LispObj *form, *result;
d1091 9
a1099 1
    form = ARGUMENT(0);
d1101 1
a1101 7
    /* make sure eval form will not access local variables */
    lex = lisp__data.env.lex;
    lisp__data.env.lex = lisp__data.env.length;
    result = EVAL(form);
    lisp__data.env.lex = lex;

    return (result);
d1104 2
a1105 8
static LispObj *
LispEverySomeAnyNot(LispBuiltin *builtin, int function)
/*
 every predicate sequence &rest more-sequences
 some predicate sequence &rest more-sequences
 notevery predicate sequence &rest more-sequences
 notany predicate sequence &rest more-sequences
 */
d1107 12
a1118 17
    GC_ENTER();
    long i, j, length, count;
    LispObj *result, *list, *item, *arguments, *acons, *value;
    SeqInfo stk[8], *seqs;

    LispObj *predicate, *sequence, *more_sequences;

    more_sequences = ARGUMENT(2);
    sequence = ARGUMENT(1);
    predicate = ARGUMENT(0);

    count = 1;
    length = LispLength(sequence);
    for (list = more_sequences; CONSP(list); list = CDR(list), count++) {
	i = LispLength(CAR(list));
	if (i < length)
	    length = i;
d1120 2
d1123 5
a1127 38
    result = function == EVERY || function == NOTANY ? T : NIL;

    /* if at least one sequence has length zero */
    if (length == 0)
	return (result);

    if (count > sizeof(stk) / sizeof(stk[0]))
	seqs = LispMalloc(count * sizeof(SeqInfo));
    else
	seqs = &stk[0];

    /* build information about sequences */
    SETSEQ(seqs[0], sequence);
    for (i = 1, list = more_sequences; CONSP(list); list = CDR(list), i++) {
	item = CAR(list);
	SETSEQ(seqs[i], item);
    }

    /* prepare argument list */
    arguments = acons = CONS(NIL, NIL);
    GC_PROTECT(arguments);
    for (i = 1; i < count; i++) {
	RPLACD(acons, CONS(NIL, NIL));
	acons = CDR(acons);
    }

    /* loop applying predicate in sequence elements */
    for (i = 0; i < length; i++) {

	/* build argument list */
	for (acons = arguments, j = 0; j < count; acons = CDR(acons), j++) {
	    if (seqs[j].type == LispString_t)
		item = SCHAR(*seqs[j].data.string++);
	    else {
		item = CAR(seqs[j].data.list);
		seqs[j].data.list = CDR(seqs[j].data.list);
	    }
	    RPLACA(acons, item);
d1129 1
d1131 5
a1135 2
	/* apply predicate */
	value = APPLY(predicate, arguments);
d1137 7
a1143 11
	/* check if needs to terminate loop */
	if (value == NIL) {
	    if (function == EVERY) {
		result = NIL;
		break;
	    }
	    if (function == NOTEVERY) {
		result = T;
		break;
	    }
	}
d1145 13
a1157 8
	    if (function == SOME) {
		result = value;
		break;
	    }
	    if (function == NOTANY) {
		result = NIL;
		break;
	    }
d1161 4
a1164 3
    GC_LEAVE();
    if (seqs != &stk[0])
	LispFree(seqs);
d1166 154
a1319 2
    return (result);
}
d1322 1
a1322 4
Lisp_Every(LispBuiltin *builtin)
/*
 every predicate sequence &rest more-sequences
 */
d1324 18
a1341 1
    return (LispEverySomeAnyNot(builtin, EVERY));
d1345 1
a1345 4
Lisp_Some(LispBuiltin *builtin)
/*
 some predicate sequence &rest more-sequences
 */
d1347 7
a1353 1
    return (LispEverySomeAnyNot(builtin, SOME));
d1357 49
a1405 6
Lisp_Notevery(LispBuiltin *builtin)
/*
 notevery predicate sequence &rest more-sequences
 */
{
    return (LispEverySomeAnyNot(builtin, NOTEVERY));
d1409 1
a1409 4
Lisp_Notany(LispBuiltin *builtin)
/*
 notany predicate sequence &rest more-sequences
 */
d1411 1
a1411 1
    return (LispEverySomeAnyNot(builtin, NOTANY));
d1415 1
a1415 4
Lisp_Fboundp(LispBuiltin *builtin)
/*
 fboundp symbol
 */
d1417 1
a1417 1
    LispAtom *atom;
d1419 5
a1423 1
    LispObj *symbol = ARGUMENT(0);
d1425 5
a1429 1
    CHECK_SYMBOL(symbol);
d1431 2
a1432 3
    atom = symbol->data.atom;
    if (atom->a_function || atom->a_builtin || atom->a_compiled)
	return (T);
d1434 4
a1437 1
    return (NIL);
d1441 1
a1441 4
Lisp_Find(LispBuiltin *builtin)
/*
 find item sequence &key from-end test test-not start end key
 */
d1443 6
a1448 1
    return (LispFindOrPosition(builtin, FIND, NONE));
d1452 1
a1452 4
Lisp_FindIf(LispBuiltin *builtin)
/*
 find-if predicate sequence &key from-end start end key
 */
d1454 1
a1454 1
    return (LispFindOrPosition(builtin, FIND, IF));
d1458 1
a1458 4
Lisp_FindIfNot(LispBuiltin *builtin)
/*
 find-if-not predicate sequence &key from-end start end key
 */
d1460 1
a1460 1
    return (LispFindOrPosition(builtin, FIND, IFNOT));
d1464 1
a1464 4
Lisp_Fill(LispBuiltin *builtin)
/*
 fill sequence item &key start end
 */
d1466 1
a1466 1
    long i, start, end, length;
d1468 4
a1471 1
    LispObj *sequence, *item, *ostart, *oend;
d1473 5
a1477 20
    oend = ARGUMENT(3);
    ostart = ARGUMENT(2);
    item = ARGUMENT(1);
    sequence = ARGUMENT(0);

    LispCheckSequenceStartEnd(builtin, sequence, ostart, oend,
			      &start, &end, &length);

    if (STRINGP(sequence)) {
	int ch;
	char *string = THESTR(sequence);

	CHECK_STRING_WRITABLE(sequence);
	CHECK_SCHAR(item);
	ch = SCHAR_VALUE(item);
	for (i = start; i < end; i++)
	    string[i] = ch;
    }
    else {
	LispObj *list;
d1479 4
a1482 4
	if (CONSP(sequence))
	    list = sequence;
	else
	    list = sequence->data.array.list;
d1484 2
a1485 5
	for (i = 0; i < start; i++, list = CDR(list))
	    ;
	for (; i < end; i++, list = CDR(list))
	    RPLACA(list, item);
    }
d1487 1
a1487 1
    return (sequence);
d1491 1
a1491 4
Lisp_Fmakunbound(LispBuiltin *builtin)
/*
 fmkaunbound symbol
 */
d1493 1
a1493 1
    LispObj *symbol;
d1495 5
a1499 11
    symbol = ARGUMENT(0);

    CHECK_SYMBOL(symbol);
    if (symbol->data.atom->a_function)
	LispRemAtomFunctionProperty(symbol->data.atom);
    else if (symbol->data.atom->a_builtin)
	LispRemAtomBuiltinProperty(symbol->data.atom);
    else if (symbol->data.atom->a_compiled)
	LispRemAtomCompiledProperty(symbol->data.atom);

    return (symbol);
d1503 1
a1503 4
Lisp_Funcall(LispBuiltin *builtin)
/*
 funcall function &rest arguments
 */
d1505 1
a1505 3
    LispObj *result;

    LispObj *function, *arguments;
d1507 2
a1508 2
    arguments = ARGUMENT(1);
    function = ARGUMENT(0);
d1510 1
a1510 3
    result = APPLY(function, arguments);

    return (result);
d1514 1
a1514 4
Lisp_Functionp(LispBuiltin *builtin)
/*
 functionp object
 */
d1516 7
a1522 1
    LispObj *object;
d1524 1
a1524 1
    object = ARGUMENT(0);
d1526 1
a1526 1
    return (FUNCTIONP(object) || LAMBDAP(object) ? T : NIL);
d1530 1
a1530 4
Lisp_Get(LispBuiltin *builtin)
/*
 get symbol indicator &optional default
 */
d1532 2
a1533 1
    LispObj *result;
d1535 5
a1539 1
    LispObj *symbol, *indicator, *defalt;
d1541 3
a1543 3
    defalt = ARGUMENT(2);
    indicator = ARGUMENT(1);
    symbol = ARGUMENT(0);
d1545 2
a1546 1
    CHECK_SYMBOL(symbol);
d1548 4
a1551 1
    result = LispGetAtomProperty(symbol->data.atom, indicator);
d1553 3
a1555 2
    if (result != NIL)
	result = CAR(result);
d1557 3
a1559 1
	result = defalt == UNSPEC ? NIL : defalt;
d1561 1
a1561 1
    return (result);
a1563 3
/*
 * ext::getenv
 */
d1565 1
a1565 4
Lisp_Getenv(LispBuiltin *builtin)
/*
 getenv name
 */
d1567 1
a1567 1
    char *value;
d1569 5
a1573 1
    LispObj *name;
d1575 1
a1575 6
    name = ARGUMENT(0);

    CHECK_STRING(name);
    value = getenv(THESTR(name));

    return (value ? STRING(value) : NIL);
d1579 1
a1579 4
Lisp_Gc(LispBuiltin *builtin)
/*
 gc &optional car cdr
 */
d1581 1
a1581 1
    LispObj *car, *cdr;
d1583 8
a1590 2
    cdr = ARGUMENT(1);
    car = ARGUMENT(0);
d1592 1
a1592 3
    LispGC(car, cdr);

    return (NIL);
d1596 1
a1596 4
Lisp_Gensym(LispBuiltin *builtin)
/*
 gensym &optional arg
 */
d1598 1
a1598 19
    char *preffix = "G", name[132];
    long counter = LONGINT_VALUE(Ogensym_counter->data.atom->property->value);
    LispObj *symbol;

    LispObj *arg;

    arg = ARGUMENT(0);
    if (arg != UNSPEC) {
	if (STRINGP(arg))
	    preffix = THESTR(arg);
	else {
	    CHECK_INDEX(arg);
	    counter = FIXNUM_VALUE(arg);
	}
    }
    snprintf(name, sizeof(name), "%s%ld", preffix, counter);
    if (strlen(name) >= 128)
	LispDestroy("%s: name %s too long", STRFUN(builtin), name);
    Ogensym_counter->data.atom->property->value = INTEGER(counter + 1);
d1600 2
a1601 2
    symbol = UNINTERNED_ATOM(name);
    symbol->data.atom->unreadable = !LispCheckAtomString(name);
d1603 1
a1603 1
    return (symbol);
d1607 1
a1607 4
Lisp_Go(LispBuiltin *builtin)
/*
 go tag
 */
d1609 2
a1610 1
    unsigned blevel = lisp__data.block.block_level;
d1612 1
a1612 1
    LispObj *tag;
d1614 5
a1618 1
    tag = ARGUMENT(0);
d1620 27
a1646 10
    while (blevel) {
	LispBlock *block = lisp__data.block.block[--blevel];

	if (block->type == LispBlockClosure)
	    /* if reached a function call */
	    break;
	if (block->type == LispBlockBody) {
	    lisp__data.block.block_ret = tag;
	    LispBlockUnwind(block);
	    BLOCKJUMP(block);
d1648 2
a1649 1
     }
d1651 6
a1656 5
    LispDestroy("%s: no visible tagbody for %s",
		STRFUN(builtin), STROBJ(tag));
    /*NOTREACHED*/
    return (NIL);
}
d1658 1
a1658 7
LispObj *
Lisp_If(LispBuiltin *builtin)
/*
 if test then &optional else
 */
{
    LispObj *result, *test, *then, *oelse;
d1660 2
a1661 11
    oelse = ARGUMENT(2);
    then = ARGUMENT(1);
    test = ARGUMENT(0);

    test = EVAL(test);
    if (test != NIL)
	result = EVAL(then);
    else if (oelse != UNSPEC)
	result = EVAL(oelse);
    else
	result = NIL;
d1663 1
a1663 1
    return (result);
d1667 1
a1667 4
Lisp_IgnoreErrors(LispBuiltin *builtin)
/*
 ignore-erros &rest body
 */
d1669 4
a1672 3
    LispObj *result;
    int i, jumped;
    LispBlock *block;
d1674 4
a1677 51
    /* interpreter state */
    GC_ENTER();
    int stack, lex, length;

    /* memory allocation */
    int mem_level;
    void **mem;

    LispObj *body;

    body = ARGUMENT(0);

    /* Save environment information */
    stack = lisp__data.stack.length;
    lex = lisp__data.env.lex;
    length = lisp__data.env.length;

    /* Save memory allocation information */
    mem_level = lisp__data.mem.level;
    mem = LispMalloc(mem_level * sizeof(void*));
    memcpy(mem, lisp__data.mem.mem, mem_level * sizeof(void*));

    ++lisp__data.ignore_errors;
    result = NIL;
    jumped = 1;
    block = LispBeginBlock(NIL, LispBlockProtect);
    if (setjmp(block->jmp) == 0) {
	for (; CONSP(body); body = CDR(body))
	    result = EVAL(CAR(body));
	jumped = 0;
    }
    LispEndBlock(block);
    if (!lisp__data.destroyed && jumped)
	result = lisp__data.block.block_ret;

    if (lisp__data.destroyed) {
	/* Restore environment */
	lisp__data.stack.length = stack;
	lisp__data.env.lex = lex;
	lisp__data.env.head = lisp__data.env.length = length;
	GC_LEAVE();

	/* Check for possible leaks due to ignoring errors */
	for (i = 0; i < mem_level; i++) {
	    if (lisp__data.mem.mem[i] && mem[i] != lisp__data.mem.mem[i])
		LispFree(lisp__data.mem.mem[i]);
	}
	for (; i < lisp__data.mem.level; i++) {
	    if (lisp__data.mem.mem[i])
		LispFree(lisp__data.mem.mem[i]);
	}
d1679 5
a1683 4
	lisp__data.destroyed = 0;
	result = NIL;
	RETURN_COUNT = 1;
	RETURN(0) = lisp__data.error_condition;
a1684 2
    LispFree(mem);
    --lisp__data.ignore_errors;
d1686 1
a1686 1
    return (result);
d1690 1
a1690 4
Lisp_Intersection(LispBuiltin *builtin)
/*
 intersection list1 list2 &key test test-not key
 */
d1692 10
a1701 1
    return (LispListSet(builtin, INTERSECTION));
d1705 1
a1705 4
Lisp_Nintersection(LispBuiltin *builtin)
/*
 nintersection list1 list2 &key test test-not key
 */
d1707 1
a1707 1
    return (LispListSet(builtin, NINTERSECTION));
d1710 1
d1712 1
a1712 4
Lisp_Keywordp(LispBuiltin *builtin)
/*
 keywordp object
 */
d1714 1
a1714 1
    LispObj *object;
d1716 3
a1718 1
    object = ARGUMENT(0);
d1720 1
a1720 1
    return (KEYWORDP(object) ? T : NIL);
d1723 3
d1727 1
a1727 4
Lisp_Lambda(LispBuiltin *builtin)
/*
 lambda lambda-list &rest body
 */
d1729 5
a1733 3
    GC_ENTER();
    LispObj *name;
    LispArgList *alist;
d1735 3
a1737 1
    LispObj *lambda, *lambda_list, *body;
d1739 3
a1741 2
    body = ARGUMENT(1);
    lambda_list = ARGUMENT(0);
d1743 12
a1754 1
    alist = LispCheckArguments(LispLambda, lambda_list, Snil, 0);
d1756 12
a1767 7
    name = OPAQUE(alist, LispArgList_t);
    lambda_list = LispListProtectedArguments(alist);
    GC_PROTECT(name);
    GC_PROTECT(lambda_list);
    lambda = LispNewLambda(name, body, lambda_list, LispLambda);
    LispUseArgList(alist);
    GC_LEAVE();
d1769 2
a1770 2
    return (lambda);
}
d1772 2
a1773 8
LispObj *
Lisp_Last(LispBuiltin *builtin)
/*
 last list &optional count
 */
{
    long count, length;
    LispObj *list, *ocount;
d1775 3
a1777 2
    ocount = ARGUMENT(1);
    list = ARGUMENT(0);
d1779 2
a1780 2
    if (!CONSP(list))
	return (list);
d1782 2
a1783 1
    length = LispLength(list);
d1785 5
a1789 2
    if (ocount == UNSPEC)
	count = 1;
d1791 2
a1792 3
	CHECK_INDEX(ocount);
	count = FIXNUM_VALUE(ocount);
    }
d1794 4
a1797 2
    if (count >= length)
	return (list);
d1799 5
a1803 3572
    length -= count;
    for (; length > 0; length--)
	list = CDR(list);

    return (list);
}

LispObj *
Lisp_Length(LispBuiltin *builtin)
/*
 length sequence
 */
{
    LispObj *sequence;

    sequence = ARGUMENT(0);

    return (FIXNUM(LispLength(sequence)));
}

LispObj *
Lisp_Let(LispBuiltin *builtin)
/*
 let init &rest body
 */
{
    GC_ENTER();
    int head = lisp__data.env.length;
    LispObj *init, *body, *pair, *result, *list, *cons = NIL;

    body = ARGUMENT(1);
    init = ARGUMENT(0);

    CHECK_LIST(init);
    for (list = NIL; CONSP(init); init = CDR(init)) {
	LispObj *symbol, *value;

	pair = CAR(init);
	if (SYMBOLP(pair)) {
	    symbol = pair;
	    value = NIL;
	}
	else {
	    CHECK_CONS(pair);
	    symbol = CAR(pair);
	    CHECK_SYMBOL(symbol);
	    pair = CDR(pair);
	    if (CONSP(pair)) {
		value = CAR(pair);
		if (CDR(pair) != NIL)
		    LispDestroy("%s: too much arguments to initialize %s",
				STRFUN(builtin), STROBJ(symbol));
		value = EVAL(value);
	    }
	    else
		value = NIL;
	}
	pair = CONS(symbol, value);
	if (list == NIL) {
	    list = cons = CONS(pair, NIL);
	    GC_PROTECT(list);
	}
	else {
	    RPLACD(cons, CONS(pair, NIL));
	    cons = CDR(cons);
	}
    }
    /* Add variables */
    for (; CONSP(list); list = CDR(list)) {
	pair = CAR(list);
	CHECK_CONSTANT(CAR(pair));
	LispAddVar(CAR(pair), CDR(pair));
	++lisp__data.env.head;
    }
    /* Values of symbols are now protected */
    GC_LEAVE();

    /* execute body */
    for (result = NIL; CONSP(body); body = CDR(body))
	result = EVAL(CAR(body));

    lisp__data.env.head = lisp__data.env.length = head;

    return (result);
}

LispObj *
Lisp_LetP(LispBuiltin *builtin)
/*
 let* init &rest body
 */
{
    int head = lisp__data.env.length;
    LispObj *init, *body, *pair, *result;

    body = ARGUMENT(1);
    init = ARGUMENT(0);

    CHECK_LIST(init);
    for (; CONSP(init); init = CDR(init)) {
	LispObj *symbol, *value;

	pair = CAR(init);
	if (SYMBOLP(pair)) {
	    symbol = pair;
	    value = NIL;
	}
	else {
	    CHECK_CONS(pair);
	    symbol = CAR(pair);
	    CHECK_SYMBOL(symbol);
	    pair = CDR(pair);
	    if (CONSP(pair)) {
		value = CAR(pair);
		if (CDR(pair) != NIL)
		    LispDestroy("%s: too much arguments to initialize %s",
				STRFUN(builtin), STROBJ(symbol));
		value = EVAL(value);
	    }
	    else
		value = NIL;
	}

	CHECK_CONSTANT(symbol);
	LispAddVar(symbol, value);
	++lisp__data.env.head;
    }

    /* execute body */
    for (result = NIL; CONSP(body); body = CDR(body))
	result = EVAL(CAR(body));

    lisp__data.env.head = lisp__data.env.length = head;

    return (result);
}

LispObj *
Lisp_List(LispBuiltin *builtin)
/*
 list &rest args
 */
{
    LispObj *args;

    args = ARGUMENT(0);

    return (args);
}

LispObj *
Lisp_ListP(LispBuiltin *builtin)
/*
 list* object &rest more-objects
 */
{
    GC_ENTER();
    LispObj *result, *cons;

    LispObj *object, *more_objects;

    more_objects = ARGUMENT(1);
    object = ARGUMENT(0);

    if (!CONSP(more_objects))
	return (object);

    result = cons = CONS(object, CAR(more_objects));
    GC_PROTECT(result);
    for (more_objects = CDR(more_objects); CONSP(more_objects);
	 more_objects = CDR(more_objects)) {
	object = CAR(more_objects);
	RPLACD(cons, CONS(CDR(cons), object));
	cons = CDR(cons);
    }
    GC_LEAVE();

    return (result);
}

/* "classic" list-length */
LispObj *
Lisp_ListLength(LispBuiltin *builtin)
/*
 list-length list
 */
{
    long length;
    LispObj *fast, *slow;

    LispObj *list;

    list = ARGUMENT(0);

    CHECK_LIST(list);
    for (fast = slow = list, length = 0;
	 CONSP(slow);
	 slow = CDR(slow), length += 2) {
	if (fast == NIL)
	    break;
	CHECK_CONS(fast);
	fast = CDR(fast);
	if (fast == NIL) {
	    ++length;
	    break;
	}
	CHECK_CONS(fast);
	fast = CDR(fast);
	if (slow == fast)
	    /* circular list */
	    return (NIL);
    }

    return (FIXNUM(length));
}

LispObj *
Lisp_Listp(LispBuiltin *builtin)
/*
 listp object
 */
{
    LispObj *object;

    object = ARGUMENT(0);

    return (object == NIL || CONSP(object) ? T : NIL);
}

static LispObj *
LispListSet(LispBuiltin *builtin, int function)
/*
 intersection list1 list2 &key test test-not key
 nintersection list1 list2 &key test test-not key
 set-difference list1 list2 &key test test-not key
 nset-difference list1 list2 &key test test-not key
 set-exclusive-or list1 list2 &key test test-not key
 nset-exclusive-or list1 list2 &key test test-not key
 subsetp list1 list2 &key test test-not key
 union list1 list2 &key test test-not key
 nunion list1 list2 &key test test-not key
 */
{
    GC_ENTER();
    int code, expect, value, inplace, check_list2,
	intersection, setdifference, xunion, setexclusiveor;
    LispObj *lambda, *result, *cmp, *cmp1, *cmp2,
	    *item, *clist1, *clist2, *cons, *cdr;

    LispObj *list1, *list2, *test, *test_not, *key;

    key = ARGUMENT(4);
    test_not = ARGUMENT(3);
    test = ARGUMENT(2);
    list2 = ARGUMENT(1);
    list1 = ARGUMENT(0);

    /* Check if arguments are valid lists */
    CHECK_LIST(list1);
    CHECK_LIST(list2);

    setdifference = intersection = xunion = setexclusiveor = inplace = 0;
    switch (function) {
	case NSETDIFFERENCE:
	    inplace = 1;
	case SETDIFFERENCE:
	    setdifference = 1;
	    break;
	case NINTERSECTION:
	    inplace = 1;
	case INTERSECTION:
	    intersection = 1;
	    break;
	case NUNION:
	    inplace = 1;
	case UNION:
	    xunion = 1;
	    break;
	case NSETEXCLUSIVEOR:
	    inplace = 1;
	case SETEXCLUSIVEOR:
	    setexclusiveor = 1;
	    break;
    }

    /* Check for fast return */
    if (list1 == NIL)
	return (setdifference || intersection ?
		NIL : function == SUBSETP ? T : list2);
    if (list2 == NIL)
	return (intersection || xunion || function == SUBSETP ? NIL : list1);

    CHECK_TEST();
    clist1 = cdr = NIL;

    /* Make a copy of list2 with the key predicate applied */
    if (key != UNSPEC) {
	result = cons = CONS(APPLY1(key, CAR(list2)), NIL);
	GC_PROTECT(result);
	for (cmp2 = CDR(list2); CONSP(cmp2); cmp2 = CDR(cmp2)) {
	    item = APPLY1(key, CAR(cmp2));
	    RPLACD(cons, CONS(APPLY1(key, CAR(cmp2)), NIL));
	    cons = CDR(cons);
	}
	/* check if list2 is a proper list */
	CHECK_LIST(cmp2);
	clist2 = result;
	check_list2 = 0;
    }
    else {
	clist2 = list2;
	check_list2 = 1;
    }
    result = cons = NIL;

    /* Compare elements of lists
     * Logic:
     *	   UNION
     *		1) Walk list1 and if CAR(list1) not in list2, add it to result
     *		2) Add list2 to result
     *	   INTERSECTION
     *		1) Walk list1 and if CAR(list1) in list2, add it to result
     *	   SET-DIFFERENCE
     *		1) Walk list1 and if CAR(list1) not in list2, add it to result
     *	   SET-EXCLUSIVE-OR
     *		1) Walk list1 and if CAR(list1) not in list2, add it to result
     *		2) Walk list2 and if CAR(list2) not in list1, add it to result
     *	   SUBSETP
     *		1) Walk list1 and if CAR(list1) not in list2, return NIL
     *		2) Return T
     */
    value = 0;
    for (cmp1 = list1; CONSP(cmp1); cmp1 = CDR(cmp1)) {
	item = CAR(cmp1);

	/* Apply key predicate if required */
	if (key != UNSPEC) {
	    cmp = APPLY1(key, item);
	    if (setexclusiveor) {
		if (clist1 == NIL) {
		    clist1 = cdr = CONS(cmp, NIL);
		    GC_PROTECT(clist1);
		}
		else {
		    RPLACD(cdr, CONS(cmp, NIL));
		    cdr = CDR(cdr);
		}
	    }
	}
	else
	    cmp = item;

	/* Compare against list2 */
	for (cmp2 = clist2; CONSP(cmp2); cmp2 = CDR(cmp2)) {
	    value = FCOMPARE(lambda, cmp, CAR(cmp2), code);
	    if (value == expect)
		break;
	}
	if (check_list2 && value != expect) {
	    /* check if list2 is a proper list */
	    CHECK_LIST(cmp2);
	    check_list2 = 0;
	}

	if (function == SUBSETP) {
	    /* Element of list1 not in list2? */
	    if (value != expect) {
		GC_LEAVE();

		return (NIL);
	    }
	}
	/* If need to add item to result */
	else if (((setdifference || xunion || setexclusiveor) &&
		  value != expect) ||
		 (intersection && value == expect)) {
	    if (inplace) {
		if (result == NIL)
		    result = cons = cmp1;
		else {
		    if (setexclusiveor) {
			/* don't remove elements yet, will need
			 * to check agains't list2 later */
			for (cmp2 = cons; CDR(cmp2) != cmp1; cmp2 = CDR(cmp2))
			    ;
			if (cmp2 != cons) {
			    RPLACD(cmp2, list1);
			    list1 = cmp2;
			}
		    }
		    RPLACD(cons, cmp1);
		    cons = cmp1;
		}
	    }
	    else {
		if (result == NIL) {
		    result = cons = CONS(item, NIL);
		    GC_PROTECT(result);
		}
		else {
		    RPLACD(cons, CONS(item, NIL));
		    cons = CDR(cons);
		}
	    }
	}
    }
    /* check if list1 is a proper list */
    CHECK_LIST(cmp1);

    if (function == SUBSETP) {
	GC_LEAVE();

	return (T);
    }
    else if (xunion) {
	/* Add list2 to tail of result */
	if (result == NIL)
	    result = list2;
	else
	    RPLACD(cons, list2);
    }
    else if (setexclusiveor) {
	LispObj *result2, *cons2;

	result2 = cons2 = NIL;
	for (cmp2 = list2; CONSP(cmp2); cmp2 = CDR(cmp2)) {
	    item = CAR(cmp2);

	    if (key != UNSPEC) {
		cmp = CAR(clist2);
		/* XXX changing clist2 */
		clist2 = CDR(clist2);
		cmp1 = clist1;
	    }
	    else {
		cmp = item;
		cmp1 = list1;
	    }

	    /* Compare against list1 */
	    for (; CONSP(cmp1); cmp1 = CDR(cmp1)) {
		value = FCOMPARE(lambda, cmp, CAR(cmp1), code);
		if (value == expect)
		    break;
	    }

	    if (value != expect) {
		if (inplace) {
		    if (result2 == NIL)
			result2 = cons2 = cmp2;
		    else {
			RPLACD(cons2, cmp2);
			cons2 = cmp2;
		    }
		}
		else {
		    if (result == NIL) {
			result = cons = CONS(item, NIL);
			GC_PROTECT(result);
		    }
		    else {
			RPLACD(cons, CONS(item, NIL));
			cons = CDR(cons);
		    }
		}
	    }
	}
	if (inplace) {
	    if (CONSP(cons2))
		RPLACD(cons2, NIL);
	    if (result == NIL)
		result = result2;
	    else
		RPLACD(cons, result2);
	}
    }
    else if ((function == NSETDIFFERENCE || function == NINTERSECTION) &&
	     CONSP(cons))
	RPLACD(cons, NIL);

    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_Loop(LispBuiltin *builtin)
/*
 loop &rest body
 */
{
    LispObj *code, *result;
    LispBlock *block;

    LispObj *body;

    body = ARGUMENT(0);

    result = NIL;
    block = LispBeginBlock(NIL, LispBlockTag);
    if (setjmp(block->jmp) == 0) {
	for (;;)
	    for (code = body; CONSP(code); code = CDR(code))
		(void)EVAL(CAR(code));
    }
    LispEndBlock(block);
    result = lisp__data.block.block_ret;

    return (result);
}

/* XXX This function is broken, needs a review
 (being delayed until true array/vectors be implemented) */
LispObj *
Lisp_MakeArray(LispBuiltin *builtin)
/*
 make-array dimensions &key element-type initial-element initial-contents
			    adjustable fill-pointer displaced-to
			    displaced-index-offset
 */
{
    long rank = 0, count = 1, offset, zero, c;
    LispObj *obj, *dim, *array;
    LispType type;

    LispObj *dimensions, *element_type, *initial_element, *initial_contents,
	    *displaced_to, *displaced_index_offset;

    dim = array = NIL;
    type = LispNil_t;

    displaced_index_offset = ARGUMENT(7);
    displaced_to = ARGUMENT(6);
    initial_contents = ARGUMENT(3);
    initial_element = ARGUMENT(2);
    element_type = ARGUMENT(1);
    dimensions = ARGUMENT(0);

    if (INDEXP(dimensions)) {
	dim = CONS(dimensions, NIL);
	rank = 1;
	count = FIXNUM_VALUE(dimensions);
    }
    else if (CONSP(dimensions)) {
	dim = dimensions;

	for (rank = 0; CONSP(dim); rank++, dim = CDR(dim)) {
	    obj = CAR(dim);
	    CHECK_INDEX(obj);
	    count *= FIXNUM_VALUE(obj);
	}
	dim = dimensions;
    }
    else if (dimensions == NIL) {
	dim = NIL;
	rank = count = 0;
    }
    else
	LispDestroy("%s: %s is a bad array dimension",
		    STRFUN(builtin), STROBJ(dimensions));

    /* check element-type */
    if (element_type != UNSPEC) {
	if (element_type == T)
	    type = LispNil_t;
	else if (!SYMBOLP(element_type))
	    LispDestroy("%s: unsupported element type %s",
			STRFUN(builtin), STROBJ(element_type));
	else {
	    Atom_id atom = ATOMID(element_type);

	    if (atom == Satom)
		type = LispAtom_t;
	    else if (atom == Sinteger)
		type = LispInteger_t;
	    else if (atom == Scharacter)
		type = LispSChar_t;
	    else if (atom == Sstring)
		type = LispString_t;
	    else if (atom == Slist)
		type = LispCons_t;
	    else if (atom == Sopaque)
		type = LispOpaque_t;
	    else
		LispDestroy("%s: unsupported element type %s",
			    STRFUN(builtin), ATOMID(element_type));
	}
    }

    /* check initial-contents */
    if (rank) {
	CHECK_LIST(initial_contents);
    }

    /* check displaced-to */
    if (displaced_to != UNSPEC) {
	CHECK_ARRAY(displaced_to);
    }

    /* check displaced-index-offset */
    offset = -1;
    if (displaced_index_offset != UNSPEC) {
	CHECK_INDEX(displaced_index_offset);
	offset = FIXNUM_VALUE(displaced_index_offset);
    }

    c = 0;
    if (initial_element != UNSPEC)
	++c;
    if (initial_contents != UNSPEC)
	++c;
    if (displaced_to != UNSPEC || offset >= 0)
	++c;
    if (c > 1)
	LispDestroy("%s: more than one initialization specified",
		    STRFUN(builtin));
    if (initial_element == UNSPEC)
	initial_element = NIL;

    zero = count == 0;
    if (displaced_to != UNSPEC) {
	CHECK_ARRAY(displaced_to);
	if (offset < 0)
	    offset = 0;
	for (c = 1, obj = displaced_to->data.array.dim; obj != NIL;
	     obj = CDR(obj))
	    c *= FIXNUM_VALUE(CAR(obj));
	if (c < count + offset)
	    LispDestroy("%s: array-total-size + displaced-index-offset "
			"exceeds total size", STRFUN(builtin));
	for (c = 0, array = displaced_to->data.array.list; c < offset; c++)
	    array = CDR(array);
    }
    else if (initial_contents != UNSPEC) {
	CHECK_CONS(initial_contents);
	if (rank == 0)
	    array = initial_contents;
	else if (rank == 1) {
	    for (array = initial_contents, c = 0; c < count;
		 array = CDR(array), c++)
		if (!CONSP(array))
		    LispDestroy("%s: bad argument or size %s",
				STRFUN(builtin), STROBJ(array));
	    if (array != NIL)
		LispDestroy("%s: bad argument or size %s",
			    STRFUN(builtin), STROBJ(array));
	    array = initial_contents;
	}
	else {
	    LispObj *err = NIL;
	    /* check if list matches */
	    int i, j, k, *dims, *loop;

	    /* create iteration variables */
	    dims = LispMalloc(sizeof(int) * rank);
	    loop = LispCalloc(1, sizeof(int) * (rank - 1));
	    for (i = 0, obj = dim; CONSP(obj); i++, obj = CDR(obj))
		dims[i] = FIXNUM_VALUE(CAR(obj));

	    /* check if list matches specified dimensions */
	    while (loop[0] < dims[0]) {
		for (obj = initial_contents, i = 0; i < rank - 1; i++) {
		    for (j = 0; j < loop[i]; j++)
			obj = CDR(obj);
		    err = obj;
		    if (!CONSP(obj = CAR(obj)))
			goto make_array_error;
		    err = obj;
		}
		--i;
		for (;;) {
		    ++loop[i];
		    if (i && loop[i] >= dims[i])
			loop[i] = 0;
		    else
			break;
		    --i;
		}
		for (k = 0; k < dims[rank - 1]; obj = CDR(obj), k++) {
		    if (!CONSP(obj))
			goto make_array_error;
		}
		if (obj == NIL)
		    continue;
make_array_error:
		LispFree(dims);
		LispFree(loop);
		LispDestroy("%s: bad argument or size %s",
			    STRFUN(builtin), STROBJ(err));
	    }

	    /* list is correct, use it to fill initial values */

	    /* reset loop */
	    memset(loop, 0, sizeof(int) * (rank - 1));

	    GCDisable();
	    /* fill array with supplied values */
	    array = NIL;
	    while (loop[0] < dims[0]) {
		for (obj = initial_contents, i = 0; i < rank - 1; i++) {
		    for (j = 0; j < loop[i]; j++)
			obj = CDR(obj);
		    obj = CAR(obj);
		}
		--i;
		for (;;) {
		    ++loop[i];
		    if (i && loop[i] >= dims[i])
			loop[i] = 0;
		    else
			break;
		    --i;
		}
		for (k = 0; k < dims[rank - 1]; obj = CDR(obj), k++) {
		    if (array == NIL)
			array = CONS(CAR(obj), NIL);
		    else {
			RPLACD(array, CONS(CAR(array), CDR(array)));
			RPLACA(array, CAR(obj));
		    }
		}
	    }
	    LispFree(dims);
	    LispFree(loop);
	    array = LispReverse(array);
	    GCEnable();
	}
    }
    else {
	GCDisable();
	/* allocate array */
	if (count) {
	    --count;
	    array = CONS(initial_element, NIL);
	    while (count) {
		RPLACD(array, CONS(CAR(array), CDR(array)));
		RPLACA(array, initial_element);
		count--;
	    }
	}
	GCEnable();
    }

    obj = LispNew(array, dim);
    obj->type = LispArray_t;
    obj->data.array.list = array;
    obj->data.array.dim = dim;
    obj->data.array.rank = rank;
    obj->data.array.type = type;
    obj->data.array.zero = zero;

    return (obj);
}

LispObj *
Lisp_MakeList(LispBuiltin *builtin)
/*
 make-list size &key initial-element
 */
{
    GC_ENTER();
    long count;
    LispObj *result, *cons;

    LispObj *size, *initial_element;

    initial_element = ARGUMENT(1);
    size = ARGUMENT(0);

    CHECK_INDEX(size);
    count = FIXNUM_VALUE(size);

    if (count == 0)
	return (NIL);
    if (initial_element == UNSPEC)
	initial_element = NIL;

    result = cons = CONS(initial_element, NIL);
    GC_PROTECT(result);
    for (; count > 1; count--) {
	RPLACD(cons, CONS(initial_element, NIL));
	cons = CDR(cons);
    }
    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_MakeSymbol(LispBuiltin *builtin)
/*
 make-symbol name
 */
{
    LispObj *name, *symbol;

    name = ARGUMENT(0);
    CHECK_STRING(name);

    symbol = UNINTERNED_ATOM(THESTR(name));
    symbol->data.atom->unreadable = !LispCheckAtomString(THESTR(name));

    return (symbol);
}

LispObj *
Lisp_Makunbound(LispBuiltin *builtin)
/*
 makunbound symbol
 */
{
    LispObj *symbol;

    symbol = ARGUMENT(0);

    CHECK_SYMBOL(symbol);
    LispUnsetVar(symbol);

    return (symbol);
}

LispObj *
Lisp_Mapc(LispBuiltin *builtin)
/*
 mapc function list &rest more-lists
 */
{
    return (LispMapc(builtin, 0));
}

LispObj *
Lisp_Mapcar(LispBuiltin *builtin)
/*
 mapcar function list &rest more-lists
 */
{
    return (LispMapc(builtin, 1));
}

/* Like nconc but ignore non list arguments */
LispObj *
LispMapnconc(LispObj *list)
{
    LispObj *result = NIL;

    if (CONSP(list)) {
	LispObj *cons, *head, *tail;

	cons = NIL;
	for (; CONSP(CDR(list)); list = CDR(list)) {
	    head = CAR(list);
	    if (CONSP(head)) {
		for (tail = head; CONSP(CDR(tail)); tail = CDR(tail))
		    ;
		if (cons != NIL)
		    RPLACD(cons, head);
		else
		    result = head;
		cons = tail;
	    }
	}
	head = CAR(list);
	if (CONSP(head)) {
	    if (cons != NIL)
		RPLACD(cons, head);
	    else
		result = head;
	}
    }

    return (result);
}

LispObj *
Lisp_Mapcan(LispBuiltin *builtin)
/*
 mapcan function list &rest more-lists
 */
{
    return (LispMapnconc(LispMapc(builtin, 1)));
}

static LispObj *
LispMapc(LispBuiltin *builtin, int mapcar)
{
    GC_ENTER();
    long i, offset, count, length;
    LispObj *result = NIL, *cons, *arguments, *acons, *rest, *alist, *value;
    LispObj *stk[8], **cdrs;

    LispObj *function, *list, *more_lists;

    more_lists = ARGUMENT(2);
    list = ARGUMENT(1);
    function = ARGUMENT(0);

    /* Result will be no longer than this */
    for (length = 0, alist = list; CONSP(alist); length++, alist = CDR(alist))
	;

    /* If first argument is not a list... */
    if (length == 0)
	return (NIL);

    /* At least one argument will be passed to function, count how many
     * extra arguments will be used, and calculate result length. */
    count = 0;
    for (rest = more_lists; CONSP(rest); rest = CDR(rest), count++) {

	/* Check if extra list is really a list, and if it is smaller
	 * than the first list */
	for (i = 0, alist = CAR(rest);
	     i < length && CONSP(alist);
	     i++, alist = CDR(alist))
	    ;

	/* If it is not a true list */
	if (i == 0)
	    return (NIL);

	/* If it is smaller than the currently calculated result length */
	if (i < length)
	    length = i;
    }

    if (mapcar) {
	/* Initialize gc protected object cells for resulting list */
	result = cons = CONS(NIL, NIL);
	GC_PROTECT(result);
    }
    else
	result = cons = list;

    if (count >= sizeof(stk) / sizeof(stk[0]))
	cdrs = LispMalloc(count * sizeof(LispObj*));
    else
	cdrs = &stk[0];
    for (i = 0, rest = more_lists; i < count; i++, rest = CDR(rest))
	cdrs[i] = CAR(rest);

    /* Initialize gc protected object cells for argument list */
    arguments = acons = CONS(NIL, NIL);
    GC_PROTECT(arguments);

    /* Allocate space for extra arguments */
    for (i = 0; i < count; i++) {
	RPLACD(acons, CONS(NIL, NIL));
	acons = CDR(acons);
    }

    /* For every element of the list that will be used */
    for (offset = 0;; list = CDR(list)) {
	acons = arguments;

	/* Add first argument */
	RPLACA(acons, CAR(list));
	acons = CDR(acons);

	/* For every extra list argument */
	for (i = 0; i < count; i++) {
	    alist = cdrs[i];
	    cdrs[i] = CDR(cdrs[i]);

	    /* Add element to argument list */
	    RPLACA(acons, CAR(alist));
	    acons = CDR(acons);
	}

	value = APPLY(function, arguments);

	if (mapcar) {
	    /* Store result */
	    RPLACA(cons, value);

	    /* Allocate new result cell */
	    if (++offset < length) {
		RPLACD(cons, CONS(NIL, NIL));
		cons = CDR(cons);
	    }
	    else
		break;
	}
	else if (++offset >= length)
	    break;
    }

    /* Unprotect argument and result list */
    GC_LEAVE();
    if (cdrs != &stk[0])
	LispFree(cdrs);

    return (result);
}

static LispObj *
LispMapl(LispBuiltin *builtin, int maplist)
{
    GC_ENTER();
    long i, offset, count, length;
    LispObj *result = NIL, *cons, *arguments, *acons, *rest, *alist, *value;
    LispObj *stk[8], **cdrs;

    LispObj *function, *list, *more_lists;

    more_lists = ARGUMENT(2);
    list = ARGUMENT(1);
    function = ARGUMENT(0);

    /* count is the number of lists, length is the length of the result */
    for (length = 0, alist = list; CONSP(alist); length++, alist = CDR(alist))
	;

    /* first argument is not a list */
    if (length == 0)
	return (NIL);

    /* check remaining arguments */
    for (count = 0, rest = more_lists; CONSP(rest); rest = CDR(rest), count++) {
	for (i = 0, alist = CAR(rest);
	     i < length && CONSP(alist);
	     i++, alist = CDR(alist))
	    ;
	/* argument is not a list */
	if (i == 0)
	    return (NIL);
	/* result will have the length of the smallest list */
	if (i < length)
	    length = i;
    }

    /* result will be a list */
    if (maplist) {
	result = cons = CONS(NIL, NIL);
	GC_PROTECT(result);
    }
    else
	result = cons = list;

    if (count >= sizeof(stk) / sizeof(stk[0]))
	cdrs = LispMalloc(count * sizeof(LispObj*));
    else
	cdrs = &stk[0];
    for (i = 0, rest = more_lists; i < count; i++, rest = CDR(rest))
	cdrs[i] = CAR(rest);

    /* initialize argument list */
    arguments = acons = CONS(NIL, NIL);
    GC_PROTECT(arguments);
    for (i = 0; i < count; i++) {
	RPLACD(acons, CONS(NIL, NIL));
	acons = CDR(acons);
    }

    /* for every used list element */
    for (offset = 0;; list = CDR(list)) {
	acons = arguments;

	/* first argument */
	RPLACA(acons, list);
	acons = CDR(acons);

	/* for every extra list */
	for (i = 0; i < count; i++) {
	    RPLACA(acons, cdrs[i]);
	    cdrs[i] = CDR(cdrs[i]);
	    acons = CDR(acons);
	}

	value = APPLY(function, arguments);

	if (maplist) {
	    /* store result */
	    RPLACA(cons, value);

	    /* allocate new cell */
	    if (++offset < length) {
		RPLACD(cons, CONS(NIL, NIL));
		cons = CDR(cons);
	    }
	    else
		break;
	}
	else if (++offset >= length)
	    break;
    }

    GC_LEAVE();
    if (cdrs != &stk[0])
	LispFree(cdrs);

    return (result);
}

LispObj *
Lisp_Mapl(LispBuiltin *builtin)
/*
 mapl function list &rest more-lists
 */
{
    return (LispMapl(builtin, 0));
}

LispObj *
Lisp_Maplist(LispBuiltin *builtin)
/*
 maplist function list &rest more-lists
 */
{
    return (LispMapl(builtin, 1));
}

LispObj *
Lisp_Mapcon(LispBuiltin *builtin)
/*
 mapcon function list &rest more-lists
 */
{
    return (LispMapnconc(LispMapl(builtin, 1)));
}

LispObj *
Lisp_Member(LispBuiltin *builtin)
/*
 member item list &key test test-not key
 */
{
    int code, expect;
    LispObj *compare, *lambda;
    LispObj *item, *list, *test, *test_not, *key;

    key = ARGUMENT(4);
    test_not = ARGUMENT(3);
    test = ARGUMENT(2);
    list = ARGUMENT(1);
    item = ARGUMENT(0);

    if (list == NIL)
	return (NIL);
    CHECK_CONS(list);

    CHECK_TEST();
    if (key == UNSPEC) {
	if (code == FEQ) {
	    for (; CONSP(list); list = CDR(list))
		if (item == CAR(list))
		    return (list);
	}
	else {
	    for (; CONSP(list); list = CDR(list))
		if (FCOMPARE(lambda, item, CAR(list), code) == expect)
		    return (list);
	}
    }
    else {
	if (code == FEQ) {
	    for (; CONSP(list); list = CDR(list))
		if (item == APPLY1(key, CAR(list)))
		    return (list);
	}
	else {
	    for (; CONSP(list); list = CDR(list)) {
		compare = APPLY1(key, CAR(list));
		if (FCOMPARE(lambda, item, compare, code) == expect)
		    return (list);
	    }
	}
    }
    /* check if is a proper list */
    CHECK_LIST(list);

    return (NIL);
}

LispObj *
Lisp_MemberIf(LispBuiltin *builtin)
/*
 member-if predicate list &key key
 */
{
    return (LispAssocOrMember(builtin, MEMBER, IF));
}

LispObj *
Lisp_MemberIfNot(LispBuiltin *builtin)
/*
 member-if-not predicate list &key key
 */
{
    return (LispAssocOrMember(builtin, MEMBER, IFNOT));
}

LispObj *
Lisp_MultipleValueBind(LispBuiltin *builtin)
/*
 multiple-value-bind symbols values &rest body
 */
{
    int i, head = lisp__data.env.length;
    LispObj *result, *symbol, *value;

    LispObj *symbols, *values, *body;

    body = ARGUMENT(2);
    values = ARGUMENT(1);
    symbols = ARGUMENT(0);

    result = EVAL(values);
    for (i = -1; CONSP(symbols); symbols = CDR(symbols), i++) {
	symbol = CAR(symbols);
	CHECK_SYMBOL(symbol);
	CHECK_CONSTANT(symbol);
	if (i >= 0 && i < RETURN_COUNT)
	    value = RETURN(i);
	else if (i < 0)
	    value = result;
	else
	    value = NIL;
	LispAddVar(symbol, value);
	++lisp__data.env.head;
    }

    /* Execute code with binded variables (if any) */
    for (result = NIL; CONSP(body); body = CDR(body))
	result = EVAL(CAR(body));

    lisp__data.env.head = lisp__data.env.length = head;

    return (result);
}

LispObj *
Lisp_MultipleValueCall(LispBuiltin *builtin)
/*
 multiple-value-call function &rest form
 */
{
    GC_ENTER();
    int i;
    LispObj *arguments, *cons, *result;

    LispObj *function, *form;

    form = ARGUMENT(1);
    function = ARGUMENT(0);

    /* build argument list */
    arguments = cons = NIL;
    for (; CONSP(form); form = CDR(form)) {
	RETURN_COUNT = 0;
	result = EVAL(CAR(form));
	if (RETURN_COUNT >= 0) {
	    if (arguments == NIL) {
		arguments = cons = CONS(result, NIL);
		GC_PROTECT(arguments);
	    }
	    else {
		RPLACD(cons, CONS(result, NIL));
		cons = CDR(cons);
	    }
	    for (i = 0; i < RETURN_COUNT; i++) {
		RPLACD(cons, CONS(RETURN(i), NIL));
		cons = CDR(cons);
	    }
	}
    }

    /* apply function */
    if (POINTERP(function) && !XSYMBOLP(function) && !XFUNCTIONP(function)) {
	function = EVAL(function);
	GC_PROTECT(function);
    }
    result = APPLY(function, arguments);
    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_MultipleValueProg1(LispBuiltin *builtin)
/*
 multiple-value-prog1 first-form &rest form
 */
{
    GC_ENTER();
    int i, count;
    LispObj *values, *cons;

    LispObj *first_form, *form;

    form = ARGUMENT(1);
    first_form = ARGUMENT(0);

    values = EVAL(first_form);
    if (!CONSP(form))
	return (values);

    cons = NIL;
    count = RETURN_COUNT;
    if (count < 0)
	values = NIL;
    else if (count == 0) {
	GC_PROTECT(values);
    }
    else {
	values = cons = CONS(values, NIL);
	GC_PROTECT(values);
	for (i = 0; i < count; i++) {
	    RPLACD(cons, CONS(RETURN(i), NIL));
	    cons = CDR(cons);
	}
    }

    for (; CONSP(form); form = CDR(form))
	EVAL(CAR(form));

    RETURN_COUNT = count;
    if (count > 0) {
	for (i = 0, cons = CDR(values); CONSP(cons); cons = CDR(cons), i++)
	    RETURN(i) = CAR(cons);
	values = CAR(values);
    }
    GC_LEAVE();

    return (values);
}

LispObj *
Lisp_MultipleValueList(LispBuiltin *builtin)
/*
 multiple-value-list form
 */
{
    int i;
    GC_ENTER();
    LispObj *form, *result, *cons;

    form = ARGUMENT(0);

    result = EVAL(form);

    if (RETURN_COUNT < 0)
	return (NIL);

    result = cons = CONS(result, NIL);
    GC_PROTECT(result);
    for (i = 0; i < RETURN_COUNT; i++) {
	RPLACD(cons, CONS(RETURN(i), NIL));
	cons = CDR(cons);
    }
    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_MultipleValueSetq(LispBuiltin *builtin)
/*
 multiple-value-setq symbols form
 */
{
    int i;
    LispObj *result, *symbol, *value;

    LispObj *symbols, *form;

    form = ARGUMENT(1);
    symbols = ARGUMENT(0);

    CHECK_LIST(symbols);
    result = EVAL(form);
    if (CONSP(symbols)) {
	symbol = CAR(symbols);
	CHECK_SYMBOL(symbol);
	CHECK_CONSTANT(symbol);
	LispSetVar(symbol, result);
	symbols = CDR(symbols);
    }
    for (i = 0; CONSP(symbols); symbols = CDR(symbols), i++) {
	symbol = CAR(symbols);
	CHECK_SYMBOL(symbol);
	CHECK_CONSTANT(symbol);
	if (i < RETURN_COUNT && RETURN_COUNT > 0)
	    value = RETURN(i);
	else
	    value = NIL;
	LispSetVar(symbol, value);
    }

    return (result);
}

LispObj *
Lisp_Nconc(LispBuiltin *builtin)
/*
 nconc &rest lists
 */
{
    LispObj *list, *lists, *cons, *head, *tail;

    lists = ARGUMENT(0);

    /* skip any initial empty lists */
    for (; CONSP(lists); lists = CDR(lists))
	if (CAR(lists) != NIL)
	    break;

    /* don't check if a proper list */
    if (!CONSP(lists))
	return (lists);

    /* setup to concatenate lists */
    list = CAR(lists);
    CHECK_CONS(list);
    for (cons = list; CONSP(CDR(cons)); cons = CDR(cons))
	;

    /* if only two lists */
    lists = CDR(lists);
    if (!CONSP(lists)) {
	RPLACD(cons, lists);

	return (list);
    }

    /* concatenate */
    for (; CONSP(CDR(lists)); lists = CDR(lists)) {
	head = CAR(lists);
	if (head == NIL)
	    continue;
	CHECK_CONS(head);
	for (tail = head; CONSP(CDR(tail)); tail = CDR(tail))
	    ;
	RPLACD(cons, head);
	cons = tail;
    }
    /* add last list */
    RPLACD(cons, CAR(lists));

    return (list);
}

LispObj *
Lisp_Nreverse(LispBuiltin *builtin)
/*
 nreverse sequence
 */
{
    return (LispXReverse(builtin, 1));
}

LispObj *
Lisp_NsetDifference(LispBuiltin *builtin)
/*
 nset-difference list1 list2 &key test test-not key
 */
{
    return (LispListSet(builtin, NSETDIFFERENCE));
}

LispObj *
Lisp_Nsubstitute(LispBuiltin *builtin)
/*
 nsubstitute newitem olditem sequence &key from-end test test-not start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, NSUBSTITUTE, NONE));
}

LispObj *
Lisp_NsubstituteIf(LispBuiltin *builtin)
/*
 nsubstitute-if newitem test sequence &key from-end start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, NSUBSTITUTE, IF));
}

LispObj *
Lisp_NsubstituteIfNot(LispBuiltin *builtin)
/*
 nsubstitute-if-not newitem test sequence &key from-end start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, NSUBSTITUTE, IFNOT));
}

LispObj *
Lisp_Nth(LispBuiltin *builtin)
/*
 nth index list
 */
{
    long position;
    LispObj *oindex, *list;

    list = ARGUMENT(1);
    oindex = ARGUMENT(0);

    CHECK_INDEX(oindex);
    position = FIXNUM_VALUE(oindex);

    if (list == NIL)
	return (NIL);

    CHECK_CONS(list);
    for (; position > 0; position--) {
	if (!CONSP(list))
	    return (NIL);
	list = CDR(list);
    }

    return (CONSP(list) ? CAR(list) : NIL);
}

LispObj *
Lisp_Nthcdr(LispBuiltin *builtin)
/*
 nthcdr index list
 */
{
    long position;
    LispObj *oindex, *list;

    list = ARGUMENT(1);
    oindex = ARGUMENT(0);

    CHECK_INDEX(oindex);
    position = FIXNUM_VALUE(oindex);

    if (list == NIL)
	return (NIL);
    CHECK_CONS(list);

    for (; position > 0; position--) {
	if (!CONSP(list))
	    return (NIL);
	list = CDR(list);
    }

    return (list);
}

LispObj *
Lisp_NthValue(LispBuiltin *builtin)
/*
 nth-value index form
 */
{
    long i;
    LispObj *oindex, *form, *result;

    form = ARGUMENT(1);
    oindex = ARGUMENT(0);

    oindex = EVAL(oindex);
    CHECK_INDEX(oindex);
    i = FIXNUM_VALUE(oindex) - 1;

    result = EVAL(form);
    if (RETURN_COUNT < 0 || i >= RETURN_COUNT)
	result = NIL;
    else if (i >= 0)
	result = RETURN(i);

    return (result);
}

LispObj *
Lisp_Null(LispBuiltin *builtin)
/*
 null list
 */
{
    LispObj *list;

    list = ARGUMENT(0);

    return (list == NIL ? T : NIL);
}

LispObj *
Lisp_Or(LispBuiltin *builtin)
/*
 or &rest args
 */
{
    LispObj *result = NIL, *args;

    args = ARGUMENT(0);

    for (; CONSP(args); args = CDR(args)) {
	result = EVAL(CAR(args));
	if (result != NIL)
	    break;
    }

    return (result);
}

LispObj *
Lisp_Pairlis(LispBuiltin *builtin)
/*
 pairlis key data &optional alist
 */
{
    LispObj *result, *cons;

    LispObj *key, *data, *alist;

    alist = ARGUMENT(2);
    data = ARGUMENT(1);
    key = ARGUMENT(0);

    if (CONSP(key) && CONSP(data)) {
	GC_ENTER();

	result = cons = CONS(CONS(CAR(key), CAR(data)), NIL);
	GC_PROTECT(result);
	key = CDR(key);
	data = CDR(data);
	for (; CONSP(key) && CONSP(data); key = CDR(key), data = CDR(data)) {
	    RPLACD(cons, CONS(CONS(CAR(key), CAR(data)), NIL));
	    cons = CDR(cons);
	}
	if (CONSP(key) || CONSP(data))
	    LispDestroy("%s: different length lists", STRFUN(builtin));
	GC_LEAVE();
	if (alist != UNSPEC)
	    RPLACD(cons, alist);
    }
    else
	result = alist == UNSPEC ? NIL : alist;

    return (result);
}

static LispObj *
LispFindOrPosition(LispBuiltin *builtin,
		   int function, int comparison)
/*
 find item sequence &key from-end test test-not start end key
 find-if predicate sequence &key from-end start end key
 find-if-not predicate sequence &key from-end start end key
 position item sequence &key from-end test test-not start end key
 position-if predicate sequence &key from-end start end key
 position-if-not predicate sequence &key from-end start end key
 */
{
    int code = 0, istring, expect, value;
    char *string = NULL;
    long offset = -1, start, end, length, i = comparison == NONE ? 7 : 5;
    LispObj *cmp, *element, **objects = NULL;

    LispObj *item, *predicate, *sequence, *from_end,
	    *test, *test_not, *ostart, *oend, *key;

    key = ARGUMENT(i);		--i;
    oend = ARGUMENT(i);		--i;
    ostart = ARGUMENT(i);	--i;
    if (comparison == NONE) {
	test_not = ARGUMENT(i);	--i;
	test = ARGUMENT(i);	--i;
    }
    else
	test_not = test = UNSPEC;
    from_end = ARGUMENT(i);	--i;
    if (from_end == UNSPEC)
	from_end = NIL;
    sequence = ARGUMENT(i);	--i;
    if (comparison == NONE) {
	item = ARGUMENT(i);
	predicate = Oeql;
    }
    else {
	predicate = ARGUMENT(i);
	item = NIL;
    }

    LispCheckSequenceStartEnd(builtin, sequence, ostart, oend,
			      &start, &end, &length);

    if (sequence == NIL)
	return (NIL);

    /* Cannot specify both :test and :test-not */
    if (test != UNSPEC && test_not != UNSPEC)
	LispDestroy("%s: specify either :TEST or :TEST-NOT", STRFUN(builtin));

    expect = 1;
    if (comparison == NONE) {
	if (test != UNSPEC)
	    predicate = test;
	else if (test_not != UNSPEC) {
	    predicate = test_not;
	    expect = 0;
	}
	FUNCTION_CHECK(predicate);
	code = FCODE(predicate);
    }

    cmp = element = NIL;
    istring = STRINGP(sequence);
    if (istring)
	string = THESTR(sequence);
    else {
	if (!CONSP(sequence))
	    sequence = sequence->data.array.list;
	for (i = 0; i < start; i++)
	    sequence = CDR(sequence);
    }

    if ((length = end - start) == 0)
	return (NIL);

    if (from_end != NIL && !istring) {
	objects = LispMalloc(sizeof(LispObj*) * length);
	for (i = length - 1; i >= 0; i--, sequence = CDR(sequence))
	    objects[i] = CAR(sequence);
    }

    for (i = 0; i < length; i++) {
	if (istring)
	    element = SCHAR(string[from_end == NIL ? i + start : end - i - 1]);
	else
	    element = from_end == NIL ? CAR(sequence) : objects[i];

	if (key != UNSPEC)
	    cmp = APPLY1(key, element);
	else
	    cmp = element;

	/* Update list */
	if (!istring && from_end == NIL)
	    sequence = CDR(sequence);

	if (comparison == NONE)
	    value = FCOMPARE(predicate, item, cmp, code);
	else
	    value = APPLY1(predicate, cmp) != NIL;

	if ((!value &&
	     (comparison == IFNOT ||
	      (comparison == NONE && !expect))) ||
	    (value &&
	     (comparison == IF ||
	      (comparison == NONE && expect)))) {
	    offset = from_end == NIL ? i + start : end - i - 1;
	    break;
	}
    }

    if (from_end != NIL && !istring)
	LispFree(objects);

    return (offset == -1 ? NIL : function == FIND ? element : FIXNUM(offset));
}

LispObj *
Lisp_Pop(LispBuiltin *builtin)
/*
 pop place
 */
{
    LispObj *result, *value;

    LispObj *place;

    place = ARGUMENT(0);

    if (SYMBOLP(place)) {
	result = LispGetVar(place);
	if (result == NULL)
	    LispDestroy("EVAL: the variable %s is unbound", STROBJ(place));
	CHECK_CONSTANT(place);
	if (result != NIL) {
	    CHECK_CONS(result);
	    value = CDR(result);
	    result = CAR(result);
	}
	else
	    value = NIL;
	LispSetVar(place, value);
    }
    else {
	GC_ENTER();
	LispObj quote;

	result = EVAL(place);
	if (result != NIL) {
	    CHECK_CONS(result);
	    value = CDR(result);
	    GC_PROTECT(value);
	    result = CAR(result);
	}
	else
	    value = NIL;
	quote.type = LispQuote_t;
	quote.data.quote = value;
	APPLY2(Osetf, place, &quote);
	GC_LEAVE();
    }

    return (result);
}

LispObj *
Lisp_Position(LispBuiltin *builtin)
/*
 position item sequence &key from-end test test-not start end key
 */
{
    return (LispFindOrPosition(builtin, POSITION, NONE));
}

LispObj *
Lisp_PositionIf(LispBuiltin *builtin)
/*
 position-if predicate sequence &key from-end start end key
 */
{
    return (LispFindOrPosition(builtin, POSITION, IF));
}

LispObj *
Lisp_PositionIfNot(LispBuiltin *builtin)
/*
 position-if-not predicate sequence &key from-end start end key
 */
{
    return (LispFindOrPosition(builtin, POSITION, IFNOT));
}

LispObj *
Lisp_Proclaim(LispBuiltin *builtin)
/*
 proclaim declaration
 */
{
    LispObj *arguments, *object;
    char *operation;

    LispObj *declaration;

    declaration = ARGUMENT(0);

    CHECK_CONS(declaration);

    arguments = declaration;
    object = CAR(arguments);
    CHECK_SYMBOL(object);

    operation = ATOMID(object);
    if (strcmp(operation, "SPECIAL") == 0) {
	for (arguments = CDR(arguments); CONSP(arguments);
	     arguments = CDR(arguments)) {
	    object = CAR(arguments);
	    CHECK_SYMBOL(object);
	    LispProclaimSpecial(object, NULL, NIL);
	}
    }
    else if (strcmp(operation, "TYPE") == 0) {
	/* XXX no type checking yet, but should be added */
    }
    /* else do nothing */

    return (NIL);
}

LispObj *
Lisp_Prog1(LispBuiltin *builtin)
/*
 prog1 first &rest body
 */
{
    GC_ENTER();
    LispObj *result;

    LispObj *first, *body;

    body = ARGUMENT(1);
    first = ARGUMENT(0);

    result = EVAL(first);

    GC_PROTECT(result);
    for (; CONSP(body); body = CDR(body))
	(void)EVAL(CAR(body));
    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_Prog2(LispBuiltin *builtin)
/*
 prog2 first second &rest body
 */
{
    GC_ENTER();
    LispObj *result;

    LispObj *first, *second, *body;

    body = ARGUMENT(2);
    second = ARGUMENT(1);
    first = ARGUMENT(0);

    (void)EVAL(first);
    result = EVAL(second);
    GC_PROTECT(result);
    for (; CONSP(body); body = CDR(body))
	(void)EVAL(CAR(body));
    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_Progn(LispBuiltin *builtin)
/*
 progn &rest body
 */
{
    LispObj *result = NIL;

    LispObj *body;

    body = ARGUMENT(0);

    for (; CONSP(body); body = CDR(body))
	result = EVAL(CAR(body));

    return (result);
}

/*
 *  This does what I believe is the expected behaviour (or at least
 * acceptable for the the interpreter), if the code being executed
 * ever tries to change/bind a progv symbol, the symbol state will
 * be restored when exiting the progv block, so, code like:
 *	(progv '(*x*) '(1) (defvar *x* 10))
 * when exiting the block, will have *x* unbound, and not a dynamic
 * symbol; if it was already bound, will have the old value.
 *  Symbols already dynamic can be freely changed, even unbounded in
 * the progv block.
 */
LispObj *
Lisp_Progv(LispBuiltin *builtin)
/*
 progv symbols values &rest body
 */
{
    GC_ENTER();
    int head = lisp__data.env.length, i, count, ostk[32], *offsets;
    LispObj *result, *list, *symbol, *value;
    int jumped;
    char fstk[32], *flags;
    LispBlock *block;
    LispAtom *atom;

    LispObj *symbols, *values, *body;

    /* Possible states */
#define DYNAMIC_SYMBOL		1
#define GLOBAL_SYMBOL		2
#define UNBOUND_SYMBOL		3

    body = ARGUMENT(2);
    values = ARGUMENT(1);
    symbols = ARGUMENT(0);

    /* get symbol names */
    symbols = EVAL(symbols);
    GC_PROTECT(symbols);

    /* get symbol values */
    values = EVAL(values);
    GC_PROTECT(values);

    /* count/check symbols and allocate space to remember symbol state */
    for (count = 0, list = symbols; CONSP(list); count++, list = CDR(list)) {
	symbol = CAR(list);
	CHECK_SYMBOL(symbol);
	CHECK_CONSTANT(symbol);
    }
    if (count > sizeof(fstk)) {
	flags = LispMalloc(count);
	offsets = LispMalloc(count * sizeof(int));
    }
    else {
	flags = &fstk[0];
	offsets = &ostk[0];
    }

    /* store flags and save old value if required */
    for (i = 0, list = symbols; i < count; i++, list = CDR(list)) {
	atom = CAR(list)->data.atom;
	if (atom->dyn)
	    flags[i] = DYNAMIC_SYMBOL;
	else if (atom->a_object) {
	    flags[i] = GLOBAL_SYMBOL;
	    offsets[i] = lisp__data.protect.length;
	    GC_PROTECT(atom->property->value);
	}
	else
	    flags[i] = UNBOUND_SYMBOL;
    }

    /* bind the symbols */
    for (i = 0, list = symbols; i < count; i++, list = CDR(list)) {
	symbol = CAR(list);
	atom = symbol->data.atom;
	if (CONSP(values)) {
	    value = CAR(values);
	    values = CDR(values);
	}
	else
	    value = NIL;
	if (flags[i] != DYNAMIC_SYMBOL) {
	    if (!atom->a_object)
		LispSetAtomObjectProperty(atom, value);
	    else
		SETVALUE(atom, value);
	}
	else
	    LispAddVar(symbol, value);
    }
    /* bind dynamic symbols */
    lisp__data.env.head = lisp__data.env.length;

    jumped = 0;
    result = NIL;
    block = LispBeginBlock(NIL, LispBlockProtect);
    if (setjmp(block->jmp) == 0) {
	for (; CONSP(body); body = CDR(body))
	    result = EVAL(CAR(body));
    }

    /* restore symbols */
    for (i = 0, list = symbols; i < count; i++, list = CDR(list)) {
	symbol = CAR(list);
	atom = symbol->data.atom;
	if (flags[i] != DYNAMIC_SYMBOL) {
	    if (flags[i] == UNBOUND_SYMBOL)
		LispUnsetVar(symbol);
	    else {
		/* restore global symbol value */
		LispSetAtomObjectProperty(atom, lisp__data.protect.objects
					  [offsets[i]]);
		atom->dyn = 0;
	    }
	}
    }
    /* unbind dynamic symbols */
    lisp__data.env.head = lisp__data.env.length = head;
    GC_LEAVE();

    if (count > sizeof(fstk)) {
	LispFree(flags);
	LispFree(offsets);
    }

    LispEndBlock(block);
    if (!lisp__data.destroyed) {
	if (jumped)
	    result = lisp__data.block.block_ret;
    }
    else {
	/* check if there is an unwind-protect block */
	LispBlockUnwind(NULL);

	/* no unwind-protect block, return to the toplevel */
	LispDestroy(".");
    }

    return (result);
}

LispObj *
Lisp_Provide(LispBuiltin *builtin)
/*
 provide module
 */
{
    LispObj *module, *obj;

    module = ARGUMENT(0);

    CHECK_STRING(module);
    for (obj = MOD; obj != NIL; obj = CDR(obj)) {
	if (STRLEN(CAR(obj)) == STRLEN(module) &&
	    memcmp(THESTR(CAR(obj)), THESTR(module), STRLEN(module)) == 0)
	    return (module);
    }

    if (MOD == NIL)
	MOD = CONS(module, NIL);
    else {
	RPLACD(MOD, CONS(CAR(MOD), CDR(MOD)));
	RPLACA(MOD, module);
    }

    LispSetVar(lisp__data.modules, MOD);

    return (MOD);
}

LispObj *
Lisp_Push(LispBuiltin *builtin)
/*
 push item place
 */
{
    LispObj *result, *list;

    LispObj *item, *place;

    place = ARGUMENT(1);
    item = ARGUMENT(0);

    item = EVAL(item);

    if (SYMBOLP(place)) {
	list = LispGetVar(place);
	if (list == NULL)
	    LispDestroy("EVAL: the variable %s is unbound", STROBJ(place));
	CHECK_CONSTANT(place);
	LispSetVar(place, result = CONS(item, list));
    }
    else {
	GC_ENTER();
	LispObj quote;

	list = EVAL(place);
	result = CONS(item, list);
	GC_PROTECT(result);
	quote.type = LispQuote_t;
	quote.data.quote = result;
	APPLY2(Osetf, place, &quote);
	GC_LEAVE();
    }

    return (result);
}

LispObj *
Lisp_Pushnew(LispBuiltin *builtin)
/*
 pushnew item place &key key test test-not
 */
{
    GC_ENTER();
    LispObj *result, *list;

    LispObj *item, *place, *key, *test, *test_not;

    test_not = ARGUMENT(4);
    test = ARGUMENT(3);
    key = ARGUMENT(2);
    place = ARGUMENT(1);
    item = ARGUMENT(0);

    /* Evaluate place */
    if (SYMBOLP(place)) {
	list = LispGetVar(place);
	if (list == NULL)
	    LispDestroy("EVAL: the variable %s is unbound", STROBJ(place));
	/* Do error checking now. */
	CHECK_CONSTANT(place);
    }
    else
	/* It is possible that list is not gc protected? */
	list = EVAL(place);

    item = EVAL(item);
    GC_PROTECT(item);
    if (key != UNSPEC) {
	key = EVAL(key);
	GC_PROTECT(key);
    }
    if (test != UNSPEC) {
	test = EVAL(test);
	GC_PROTECT(test);
    }
    else if (test_not != UNSPEC) {
	test_not = EVAL(test_not);
	GC_PROTECT(test_not);
    }

    result = LispAdjoin(builtin, item, list, key, test, test_not);

    /* Item already in list */
    if (result == list) {
	GC_LEAVE();

	return (result);
    }

    if (SYMBOLP(place)) {
	CHECK_CONSTANT(place);
	LispSetVar(place, result);
    }
    else {
	LispObj quote;

	GC_PROTECT(result);
	quote.type = LispQuote_t;
	quote.data.quote = result;
	APPLY2(Osetf, place, &quote);
    }
    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_Quit(LispBuiltin *builtin)
/*
 quit &optional status
 */
{
    int status = 0;
    LispObj *ostatus;

    ostatus = ARGUMENT(0);

    if (FIXNUMP(ostatus))
	status = (int)FIXNUM_VALUE(ostatus);
    else if (ostatus != UNSPEC)
	LispDestroy("%s: bad exit status argument %s",
		    STRFUN(builtin), STROBJ(ostatus));

    exit(status);
}

LispObj *
Lisp_Quote(LispBuiltin *builtin)
/*
 quote object
 */
{
    LispObj *object;

    object = ARGUMENT(0);

    return (object);
}

LispObj *
Lisp_Replace(LispBuiltin *builtin)
/*
 replace sequence1 sequence2 &key start1 end1 start2 end2
 */
{
    long length, length1, length2, start1, end1, start2, end2;
    LispObj *sequence1, *sequence2, *ostart1, *oend1, *ostart2, *oend2;

    oend2 = ARGUMENT(5);
    ostart2 = ARGUMENT(4);
    oend1 = ARGUMENT(3);
    ostart1 = ARGUMENT(2);
    sequence2 = ARGUMENT(1);
    sequence1 = ARGUMENT(0);

    LispCheckSequenceStartEnd(builtin, sequence1, ostart1, oend1,
			      &start1, &end1, &length1);
    LispCheckSequenceStartEnd(builtin, sequence2, ostart2, oend2,
			      &start2, &end2, &length2);

    if (start1 == end1 || start2 == end2)
	return (sequence1);

    length = end1 - start1;
    if (length > end2 - start2)
	length = end2 - start2;

    if (STRINGP(sequence1)) {
	CHECK_STRING_WRITABLE(sequence1);
	if (!STRINGP(sequence2))
	    LispDestroy("%s: cannot store %s in %s",
			STRFUN(builtin), STROBJ(sequence2), THESTR(sequence1));

	memmove(THESTR(sequence1) + start1, THESTR(sequence2) + start2, length);
    }
    else {
	int i;
	LispObj *from, *to;

	if (ARRAYP(sequence1))
	    sequence1 = sequence1->data.array.list;
	if (ARRAYP(sequence2))
	    sequence2 = sequence2->data.array.list;

	/* adjust pointers */
	for (i = 0, from = sequence2; i < start2; i++, from = CDR(from))
	    ;
	for (i = 0, to = sequence1; i < start1; i++, to = CDR(to))
	    ;

	/* copy data */
	for (i = 0; i < length; i++, from = CDR(from), to = CDR(to))
	    RPLACA(to, CAR(from));
    }

    return (sequence1);
}

static LispObj *
LispDeleteOrRemoveDuplicates(LispBuiltin *builtin, int function)
/*
 delete-duplicates sequence &key from-end test test-not start end key
 remove-duplicates sequence &key from-end test test-not start end key
 */
{
    GC_ENTER();
    int code, expect, value = 0;
    long i, j, start, end, length, count;
    LispObj *lambda, *result, *cons, *compare;

    LispObj *sequence, *from_end, *test, *test_not, *ostart, *oend, *key;

    key = ARGUMENT(6);
    oend = ARGUMENT(5);
    ostart = ARGUMENT(4);
    test_not = ARGUMENT(3);
    test = ARGUMENT(2);
    from_end = ARGUMENT(1);
    if (from_end == UNSPEC)
	from_end = NIL;
    sequence = ARGUMENT(0);

    LispCheckSequenceStartEnd(builtin, sequence, ostart, oend,
			      &start, &end, &length);

    /* Check if need to do something */
    if (start == end)
	return (sequence);

    CHECK_TEST();

    /* Initialize */
    count = 0;

    result = cons = NIL;
    if (STRINGP(sequence)) {
	char *ptr, *string, *buffer = LispMalloc(length + 1);

	/* Use same code, update start/end offsets */
	if (from_end != NIL) {
	    i = length - start;
	    start = length - end;
	    end = i;
	}

	if (from_end == NIL)
	    string = THESTR(sequence);
	else {
	    /* Make a reversed copy of the sequence */
	    string = LispMalloc(length + 1);
	    for (ptr = THESTR(sequence) + length - 1, i = 0; i < length; i++)
		string[i] = *ptr--;
	    string[i] = '\0';
	}

	ptr = buffer;
	/* Copy leading bytes */
	for (i = 0; i < start; i++)
	    *ptr++ = string[i];

	compare = SCHAR(string[i]);
	if (key != UNSPEC)
	    compare = APPLY1(key, compare);
	result = cons = CONS(compare, NIL);
	GC_PROTECT(result);
	for (++i; i < end; i++) {
	    compare = SCHAR(string[i]);
	    if (key != UNSPEC)
		compare = APPLY1(key, compare);
	    RPLACD(cons, CONS(compare, NIL));
	    cons = CDR(cons);
	}

	for (i = start; i < end; i++, result = CDR(result)) {
	    compare = CAR(result);
	    for (j = i + 1, cons = CDR(result); j < end; j++, cons = CDR(cons)) {
		value = FCOMPARE(lambda, compare, CAR(cons), code);
		if (value == expect)
		    break;
	    }
	    if (value != expect)
		*ptr++ = string[i];
	    else
		++count;
	}

	if (count) {
	    /* Copy ending bytes */
	    for (; i <= length; i++)   /* Also copy the ending nul */
		*ptr++ = string[i];

	    if (from_end == NIL)
		ptr = buffer;
	    else {
		for (i = 0, ptr = buffer + strlen(buffer);
		     ptr > buffer;
		     i++)
		    string[i] = *--ptr;
		string[i] = '\0';
		ptr = string;
		LispFree(buffer);
	    }
	    if (function == REMOVE)
		result = STRING2(ptr);
	    else {
		CHECK_STRING_WRITABLE(sequence);
		result = sequence;
		free(THESTR(result));
		THESTR(result) = ptr;
		LispMused(ptr);
	    }
	}
	else {
	    result = sequence;
	    if (from_end != NIL)
		LispFree(string);
	}
    }
    else {
	long xlength = end - start;
	LispObj *list, *object, **kobjects = NULL, **xobjects;
	LispObj **objects = LispMalloc(sizeof(LispObj*) * xlength);

	if (!CONSP(sequence))
	    object = sequence->data.array.list;
	else
	    object = sequence;
	list = object;

	for (i = 0; i < start; i++)
	    object = CDR(object);

	/* Put data in a vector */
	if (from_end == NIL) {
	    for (i = 0; i < xlength; i++, object = CDR(object))
		objects[i] = CAR(object);
	}
	else {
	    for (i = xlength - 1; i >= 0; i--, object = CDR(object))
		objects[i] = CAR(object);
	}

	/* Apply key predicate if required */
	if (key != UNSPEC) {
	    kobjects = LispMalloc(sizeof(LispObj*) * xlength);
	    for (i = 0; i < xlength; i++) {
		kobjects[i] = APPLY1(key, objects[i]);
		GC_PROTECT(kobjects[i]);
	    }
	    xobjects = kobjects;
	}
	else
	    xobjects = objects;

	/* Check if needs to remove something */
	for (i = 0; i < xlength; i++) {
	    compare = xobjects[i];
	    for (j = i + 1; j < xlength; j++) {
		value = FCOMPARE(lambda, compare, xobjects[j], code);
		if (value == expect) {
		    objects[i] = NULL;
		    ++count;
		    break;
		}
	    }
	}

	if (count) {
	    /* Create/set result list */
	    object = list;

	    if (start) {
		/* Skip first elements of resulting list */
		if (function == REMOVE) {
		    result = cons = CONS(CAR(object), NIL);
		    GC_PROTECT(result);
		    for (i = 1, object = CDR(object);
			 i < start;
			 i++, object = CDR(object)) {
			RPLACD(cons, CONS(CAR(object), NIL));
			cons = CDR(cons);
		    }
		}
		else {
		    result = cons = object;
		    for (i = 1; i < start; i++, cons = CDR(cons))
			;
		}
	    }
	    else if (function == DELETE)
		result = list;

	    /* Skip initial removed elements */
	    if (function == REMOVE) {
		for (i = 0; objects[i] == NULL && i < xlength; i++)
		    ;
	    }
	    else
		i = 0;

	    if (i < xlength) {
		int xstart, xlimit, xinc;

		if (from_end == NIL) {
		    xstart = i;
		    xlimit = xlength;
		    xinc = 1;
		}
		else {
		    xstart = xlength - 1;
		    xlimit = i - 1;
		    xinc = -1;
		}

		if (function == REMOVE) {
		    for (i = xstart; i != xlimit; i += xinc) {
			if (objects[i] != NULL) {
			    if (result == NIL) {
				result = cons = CONS(objects[i], NIL);
				GC_PROTECT(result);
			    }
			    else {
				RPLACD(cons, CONS(objects[i], NIL));
				cons = CDR(cons);
			    }
			}
		    }
		}
		else {
		    /* Delete duplicates */
		    for (i = xstart; i != xlimit; i += xinc) {
			if (objects[i] == NULL) {
			    if (cons == NIL) {
				if (CONSP(CDR(result))) {
				    RPLACA(result, CADR(result));
				    RPLACD(result, CDDR(result));
				}
				else {
				    RPLACA(result, CDR(result));
				    RPLACD(result, NIL);
				}
			    }
			    else {
				if (CONSP(CDR(cons)))
				    RPLACD(cons, CDDR(cons));
				else
				    RPLACD(cons, NIL);
			    }
			}
			else {
			    if (cons == NIL)
				cons = result;
			    else
				cons = CDR(cons);
			}
		    }
		}
	    }
	    if (end < length && function == REMOVE) {
		for (i = start; i < end; i++, object = CDR(object))
		    ;
		if (result == NIL) {
		    result = cons = CONS(CAR(object), NIL);
		    GC_PROTECT(result);
		    ++i;
		    object = CDR(object);
		}
		for (; i < length; i++, object = CDR(object)) {
		    RPLACD(cons, CONS(CAR(object), NIL));
		    cons = CDR(cons);
		}
	    }
	}
	else
	    result = sequence;
	LispFree(objects);
	if (key != UNSPEC)
	    LispFree(kobjects);

	if (count && !CONSP(sequence)) {
	    if (function == REMOVE)
		result = VECTOR(result);
	    else {
		length = FIXNUM_VALUE(CAR(sequence->data.array.dim)) - count;
		CAR(sequence->data.array.dim) = FIXNUM(length);
		result = sequence;
	    }
	}
    }
    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_RemoveDuplicates(LispBuiltin *builtin)
/*
 remove-duplicates sequence &key from-end test test-not start end key
 */
{
    return (LispDeleteOrRemoveDuplicates(builtin, REMOVE));
}

static LispObj *
LispDeleteRemoveXSubstitute(LispBuiltin *builtin,
			    int function, int comparison)
/*
 delete item sequence &key from-end test test-not start end count key
 delete-if predicate sequence &key from-end start end count key
 delete-if-not predicate sequence &key from-end start end count key
 remove item sequence &key from-end test test-not start end count key
 remove-if predicate sequence &key from-end start end count key
 remove-if-not predicate sequence &key from-end start end count key
 substitute newitem olditem sequence &key from-end test test-not start end count key
 substitute-if newitem test sequence &key from-end start end count key
 substitute-if-not newitem test sequence &key from-end start end count key
 nsubstitute newitem olditem sequence &key from-end test test-not start end count key
 nsubstitute-if newitem test sequence &key from-end start end count key
 nsubstitute-if-not newitem test sequence &key from-end start end count key
 */
{
    GC_ENTER();
    int code, expect, value, inplace, substitute;
    long i, j, start, end, length, copy, count, xstart, xend, xinc, xlength;

    LispObj *result, *compare;

    LispObj *item, *newitem, *lambda, *sequence, *from_end,
	    *test, *test_not, *ostart, *oend, *ocount, *key;

    substitute = function == SUBSTITUTE || function == NSUBSTITUTE;
    if (!substitute)
	i = comparison == NONE ? 8 : 6;
    else /* substitute */
	i = comparison == NONE ? 9 : 7;

    /* Get function arguments */
    key = ARGUMENT(i);			--i;
    ocount = ARGUMENT(i);		--i;
    oend = ARGUMENT(i);			--i;
    ostart = ARGUMENT(i);		--i;
    if (comparison == NONE) {
	test_not = ARGUMENT(i);		--i;
	test = ARGUMENT(i);		--i;
    }
    else
	test_not = test = UNSPEC;
    from_end = ARGUMENT(i);		--i;
    if (from_end == UNSPEC)
	from_end = NIL;
    sequence = ARGUMENT(i);		--i;
    if (comparison != NONE) {
	lambda = ARGUMENT(i);	--i;
	if (substitute)
	    newitem = ARGUMENT(0);
	else
	    newitem = NIL;
	item = NIL;
    }
    else {
	lambda = NIL;
	if (substitute) {
	    item = ARGUMENT(1);
	    newitem = ARGUMENT(0);
	}
	else {
	    item = ARGUMENT(0);
	    newitem = NIL;
	}
    }

    /* Check if argument is a valid sequence, and if start/end
     * are correctly specified. */
    LispCheckSequenceStartEnd(builtin, sequence, ostart, oend,
			      &start, &end, &length);

    /* Check count argument */
    if (ocount == UNSPEC) {
	count = length;
	/* Doesn't matter, but left to right should be slightly faster */
	from_end = NIL;
    }
    else {
	CHECK_INDEX(ocount);
	count = FIXNUM_VALUE(ocount);
    }

    /* Check if need to do something */
    if (start == end || count == 0)
	return (sequence);

    CHECK_TEST_0();

    /* Resolve comparison function, and expected result of comparison */
    if (comparison == NONE) {
	if (test_not == UNSPEC) {
	    if (test == UNSPEC)
		lambda = Oeql;
	    else
		lambda = test;
	    expect = 1;
	}
	else {
	    lambda = test_not;
	    expect = 0;
	}
	FUNCTION_CHECK(lambda);
    }
    else
	expect = comparison == IFNOT ? 0 : 1;

    /* Check for fast path to comparison function */
    code = FCODE(lambda);

    /* Initialize for loop */
    copy = count;
    result = sequence;
    inplace = function == DELETE || function == NSUBSTITUTE;
    xlength = end - start;

    /* String is easier */
    if (STRINGP(sequence)) {
	char *buffer, *string;

	if (comparison == NONE) {
	    CHECK_SCHAR(item);
	}
	if (substitute) {
	    CHECK_SCHAR(newitem);
	}

	if (from_end == NIL) {
	    xstart = start;
	    xend = end;
	    xinc = 1;
	}
	else {
	    xstart = end - 1;
	    xend = start - 1;
	    xinc = -1;
	}

	string = THESTR(sequence);
	buffer = LispMalloc(length + 1);

	/* Copy leading bytes, if any */
	for (i = 0; i < start; i++)
	    buffer[i] = string[i];

	for (j = xstart; i != xend && count > 0; i += xinc) {
	    compare = SCHAR(string[i]);
	    if (key != UNSPEC) {
		compare = APPLY1(key, compare);
		/* Value returned by the key predicate may not be protected */
		GC_PROTECT(compare);
		if (comparison == NONE)
		    value = FCOMPARE(lambda, item, compare, code);
		else
		    value = APPLY1(lambda, compare) != NIL;
		/* Unprotect value returned by the key predicate */
		GC_LEAVE();
	    }
	    else {
		if (comparison == NONE)
		    value = FCOMPARE(lambda, item, compare, code);
		else
		    value = APPLY1(lambda, compare) != NIL;
	    }

	    if (value != expect) {
		buffer[j] = string[i];
		j += xinc;
	    }
	    else {
		if (substitute) {
		    buffer[j] = SCHAR_VALUE(newitem);
		    j += xinc;
		}
		else
		    --count;
	    }
	}

	if (count != copy && from_end != NIL)
	    memmove(buffer + start, buffer + copy - count, count);

	/* Copy remaining bytes, if any */
	for (; i < length; i++, j++)
	    buffer[j] = string[i];
	buffer[j] = '\0';

	xlength = length - (copy - count);
	if (inplace) {
	    CHECK_STRING_WRITABLE(sequence);
	    /* result is a pointer to sequence */
	    LispFree(THESTR(sequence));
	    LispMused(buffer);
	    THESTR(sequence) = buffer;
	    STRLEN(sequence) = xlength;
	}
	else
	    result = LSTRING2(buffer, xlength);
    }

    /* If inplace, need to update CAR and CDR of sequence */
    else {
	LispObj *list, *object;
	LispObj **objects = LispMalloc(sizeof(LispObj*) * xlength);

	if (!CONSP(sequence))
	    list = sequence->data.array.list;
	else
	    list = sequence;

	/* Put data in a vector */
	for (i = 0, object = list; i < start; i++)
	    object = CDR(object);

	for (i = 0; i < xlength; i++, object = CDR(object))
	    objects[i] = CAR(object);

	if (from_end == NIL) {
	    xstart = 0;
	    xend = xlength;
	    xinc = 1;
	}
	else {
	    xstart = xlength - 1;
	    xend = -1;
	    xinc = -1;
	}

	/* Check if needs to remove something */
	for (i = xstart; i != xend && count > 0; i += xinc) {
	    compare = objects[i];
	    if (key != UNSPEC) {
		compare = APPLY1(key, compare);
		GC_PROTECT(compare);
		if (comparison == NONE)
		    value = FCOMPARE(lambda, item, compare, code);
		else
		    value = APPLY1(lambda, compare) != NIL;
		GC_LEAVE();
	    }
	    else {
		if (comparison == NONE)
		    value = FCOMPARE(lambda, item, compare, code);
		else
		    value = APPLY1(lambda, compare) != NIL;
	    }
	    if (value == expect) {
		if (substitute)
		    objects[i] = newitem;
		else
		    objects[i] = NULL;
		--count;
	    }
	}

	if (copy != count) {
	    LispObj *cons = NIL;

	    i = 0;
	    object = list;
	    if (inplace) {
		/* While result is NIL, skip initial elements of sequence */
		result = start ? list : NIL;

		/* Skip initial elements, if any */
		for (; i < start; i++, cons = object, object = CDR(object))
		    ;
	    }
	    /* Copy initial elements, if any */
	    else {
		result = NIL;
		if (start) {
		    result = cons = CONS(CAR(list), NIL);
		    GC_PROTECT(result);
		    for (++i, object = CDR(list);
			 i < start;
			 i++, object = CDR(object)) {
			RPLACD(cons, CONS(CAR(object), NIL));
		 	cons = CDR(cons);
		    }
		}
	    }

	    /* Skip initial removed elements, if any */
	    for (i = 0; objects[i] == NULL && i < xlength; i++)
		;

	    for (i = 0; i < xlength; i++, object = CDR(object)) {
		if (objects[i]) {
		    if (inplace) {
			if (result == NIL)
			    result = cons = object;
			else {
			    RPLACD(cons, object);
			    cons = CDR(cons);
			}
			if (function == NSUBSTITUTE)
			    RPLACA(cons, objects[i]);
		    }
		    else {
			if (result == NIL) {
			    result = cons = CONS(objects[i], NIL);
			    GC_PROTECT(result);
			}
			else {
			    RPLACD(cons, CONS(objects[i], NIL));
			    cons = CDR(cons);
			}
		    }
		}
	    }

	    if (inplace) {
		if (result == NIL)
		    result = object;
		else
		    RPLACD(cons, object);

		if (!CONSP(sequence)) {
		    result = sequence;
		    CAR(result)->data.array.dim =
			FIXNUM(length - (copy - count));
		}
	    }
	    else if (end < length) {
		i = end;
		/* Copy ending elements, if any */
		if (result == NIL) {
		    result = cons = CONS(CAR(object), NIL);
		    GC_PROTECT(result);
		    object = CDR(object);
		    i++;
		}
		for (; i < length; i++, object = CDR(object)) {
		    RPLACD(cons, CONS(CAR(object), NIL));
		    cons = CDR(cons);
		}
	    }
	}

	/* Release comparison vector */
	LispFree(objects);
    }

    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_Remove(LispBuiltin *builtin)
/*
 remove item sequence &key from-end test test-not start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, REMOVE, NONE));
}

LispObj *
Lisp_RemoveIf(LispBuiltin *builtin)
/*
 remove-if predicate sequence &key from-end start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, REMOVE, IF));
}

LispObj *
Lisp_RemoveIfNot(LispBuiltin *builtin)
/*
 remove-if-not predicate sequence &key from-end start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, REMOVE, IFNOT));
}

LispObj *
Lisp_Remprop(LispBuiltin *builtin)
/*
 remprop symbol indicator
 */
{
    LispObj *symbol, *indicator;

    indicator = ARGUMENT(1);
    symbol = ARGUMENT(0);

    CHECK_SYMBOL(symbol);

    return (LispRemAtomProperty(symbol->data.atom, indicator));
}

LispObj *
Lisp_Return(LispBuiltin *builtin)
/*
 return &optional result
 */
{
    unsigned blevel = lisp__data.block.block_level;

    LispObj *result;

    result = ARGUMENT(0);

    while (blevel) {
	LispBlock *block = lisp__data.block.block[--blevel];

	if (block->type == LispBlockClosure)
	    /* if reached a function call */
	    break;
	if (block->type == LispBlockTag && block->tag == NIL) {
	    lisp__data.block.block_ret = result == UNSPEC ? NIL : EVAL(result);
	    LispBlockUnwind(block);
	    BLOCKJUMP(block);
	}
    }
    LispDestroy("%s: no visible NIL block", STRFUN(builtin));

    /*NOTREACHED*/
    return (NIL);
}

LispObj *
Lisp_ReturnFrom(LispBuiltin *builtin)
/*
 return-from name &optional result
 */
{
    unsigned blevel = lisp__data.block.block_level;

    LispObj *name, *result;

    result = ARGUMENT(1);
    name = ARGUMENT(0);

    if (name != NIL && name != T && !SYMBOLP(name))
	LispDestroy("%s: %s is not a valid block name",
		    STRFUN(builtin), STROBJ(name));

    while (blevel) {
	LispBlock *block = lisp__data.block.block[--blevel];

	if (name == block->tag &&
	    (block->type == LispBlockTag || block->type == LispBlockClosure)) {
	    lisp__data.block.block_ret = result == UNSPEC ? NIL : EVAL(result);
	    LispBlockUnwind(block);
	    BLOCKJUMP(block);
	}
	if (block->type == LispBlockClosure)
	    /* can use return-from only in the current function */
	    break;
    }
    LispDestroy("%s: no visible block named %s",
		STRFUN(builtin), STROBJ(name));

    /*NOTREACHED*/
    return (NIL);
}

static LispObj *
LispXReverse(LispBuiltin *builtin, int inplace)
/*
 nreverse sequence
 reverse sequence
 */
{
    long length;
    LispObj *list, *result = NIL;

    LispObj *sequence;

    sequence = ARGUMENT(0);

    /* Do error checking for arrays and object type. */
    length = LispLength(sequence);
    if (length <= 1)
	return (sequence);

    switch (XOBJECT_TYPE(sequence)) {
	case LispString_t: {
	    long i;
	    char *from, *to;

	    from = THESTR(sequence) + length - 1;
	    if (inplace) {
		char temp;

		CHECK_STRING_WRITABLE(sequence);
		to = THESTR(sequence);
		for (i = 0; i < length / 2; i++) {
		    temp = to[i];
		    to[i] = from[-i];
		    from[-i] = temp;
		}
		result = sequence;
	    }
	    else {
		to = LispMalloc(length + 1);
		to[length] = '\0';
		for (i = 0; i < length; i++)
		    to[i] = from[-i];
		result = STRING2(to);
	    }
	}   return (result);
	case LispCons_t:
	    if (inplace) {
		long i, j;
		LispObj *temp;

		/* For large lists this can be very slow, but for small
		 * amounts of data, this avoid allocating a buffer to
		 * to store the CAR of the sequence. This is only done
		 * to not destroy the contents of a variable.
		 */
		for (i = 0, list = sequence;
		     i < (length + 1) / 2;
		     i++, list = CDR(list))
		    ;
		length /= 2;
		for (i = 0; i < length; i++, list = CDR(list)) {
		    for (j = length - i - 1, result = sequence;
			 j > 0;
			 j--, result = CDR(result))
			;
		    temp = CAR(list);
		    RPLACA(list, CAR(result));
		    RPLACA(result, temp);
		}
		return (sequence);
	    }
	    list = sequence;
	    break;
	case LispArray_t:
	    if (inplace) {
		sequence->data.array.list =
		    LispReverse(sequence->data.array.list);
		return (sequence);
	    }
	    list = sequence->data.array.list;
	    break;
	default:	/* LispNil_t */
	    return (result);
    }

    {
	GC_ENTER();
	LispObj *cons;

	result = cons = CONS(CAR(list), NIL);
	GC_PROTECT(result);
	for (list = CDR(list); CONSP(list); list = CDR(list)) {
	    RPLACD(cons, CONS(CAR(list), NIL));
	    cons = CDR(cons);
	}
	result = LispReverse(result);

	GC_LEAVE();
    }

    if (ARRAYP(sequence)) {
	list = result;

	result = LispNew(list, NIL);
	result->type = LispArray_t;
	result->data.array.list = list;
	result->data.array.dim = sequence->data.array.dim;
	result->data.array.rank = sequence->data.array.rank;
	result->data.array.type = sequence->data.array.type;
	result->data.array.zero = sequence->data.array.zero;
    }

    return (result);
}

LispObj *
Lisp_Reverse(LispBuiltin *builtin)
/*
 reverse sequence
 */
{
    return (LispXReverse(builtin, 0));
}

LispObj *
Lisp_Rplaca(LispBuiltin *builtin)
/*
 rplaca place value
 */
{
    LispObj *place, *value;

    value = ARGUMENT(1);
    place = ARGUMENT(0);

    CHECK_CONS(place);
    RPLACA(place, value);

    return (place);
}

LispObj *
Lisp_Rplacd(LispBuiltin *builtin)
/*
 rplacd place value
 */
{
    LispObj *place, *value;

    value = ARGUMENT(1);
    place = ARGUMENT(0);

    CHECK_CONS(place);
    RPLACD(place, value);

    return (place);
}

LispObj *
Lisp_Search(LispBuiltin *builtin)
/*
 search sequence1 sequence2 &key from-end test test-not key start1 start2 end1 end2
 */
{
    int code = 0, expect, value;
    long start1, start2, end1, end2, length1, length2, off1, off2, offset = -1;
    LispObj *cmp1, *cmp2, *list1 = NIL, *lambda;
    SeqInfo seq1, seq2;

    LispObj *sequence1, *sequence2, *from_end, *test, *test_not,
	    *key, *ostart1, *ostart2, *oend1, *oend2;

    oend2 = ARGUMENT(9);
    oend1 = ARGUMENT(8);
    ostart2 = ARGUMENT(7);
    ostart1 = ARGUMENT(6);
    key = ARGUMENT(5);
    test_not = ARGUMENT(4);
    test = ARGUMENT(3);
    from_end = ARGUMENT(2);
    sequence2 = ARGUMENT(1);
    sequence1 = ARGUMENT(0);

    LispCheckSequenceStartEnd(builtin, sequence1, ostart1, oend1,
			      &start1, &end1, &length1);
    LispCheckSequenceStartEnd(builtin, sequence2, ostart2, oend2,
			      &start2, &end2, &length2);

    /* Check for special conditions */
    if (start1 == end1)
	return (FIXNUM(end2));
    else if (start2 == end2)
	return (start1 == end1 ? FIXNUM(start2) : NIL);

    CHECK_TEST();

    if (from_end == UNSPEC)
	from_end = NIL;

    SETSEQ(seq1, sequence1);
    SETSEQ(seq2, sequence2);

    length1 = end1 - start1;
    length2 = end2 - start2;

    /* update start of sequences */
    if (start1) {
	if (seq1.type == LispString_t)
	    seq1.data.string += start1;
	else {
	    for (cmp1 = seq1.data.list; start1; cmp1 = CDR(cmp1), --start1)
		;
	    seq1.data.list = cmp1;
	}
	end1 = length1;
    }
    if (start2) {
	if (seq2.type == LispString_t)
	    seq2.data.string += start2;
	else {
	    for (cmp2 = seq2.data.list; start2; cmp2 = CDR(cmp2), --start2)
		;
	    seq2.data.list = cmp2;
	}
	end2 = length2;
    }

    /* easier case */
    if (from_end == NIL) {
	LispObj *list2 = NIL;

	/* while a match is possible */
	while (end2 - start2 >= length1) {

	    /* prepare to search */
	    off1 = 0;
	    off2 = start2;
	    if (seq1.type != LispString_t)
		list1 = seq1.data.list;
	    if (seq2.type != LispString_t)
		list2 = seq2.data.list;

	    /* for every element that must match in sequence1 */
	    while (off1 < length1) {
		if (seq1.type == LispString_t)
		    cmp1 = SCHAR(seq1.data.string[off1]);
		else
		    cmp1 = CAR(list1);
		if (seq2.type == LispString_t)
		    cmp2 = SCHAR(seq2.data.string[off2]);
		else
		    cmp2 = CAR(list2);
		if (key != UNSPEC) {
		    cmp1 = APPLY1(key, cmp1);
		    cmp2 = APPLY1(key, cmp2);
		}

		/* compare elements */
		value = FCOMPARE(lambda, cmp1, cmp2, code);
		if (value != expect)
		    break;

		/* update offsets/sequence pointers */
		++off1;
		++off2;
		if (seq1.type != LispString_t)
		    list1 = CDR(list1);
		if (seq2.type != LispString_t)
		    list2 = CDR(list2);
	    }

	    /* if everything matched */
	    if (off1 == end1) {
		offset = off2 - length1;
		break;
	    }

	    /* update offset/sequence2 pointer */
	    ++start2;
	    if (seq2.type != LispString_t)
		seq2.data.list = CDR(seq2.data.list);
	}
    }
    else {
	/* allocate vector if required, only list2 requires it.
	 * list1 can be traversed forward */
	if (seq2.type != LispString_t) {
	    cmp2 = seq2.data.list;
	    seq2.data.vector = LispMalloc(sizeof(LispObj*) * length2);
	    for (off2 = 0; off2 < end2; off2++, cmp2 = CDR(cmp2))
		seq2.data.vector[off2] = CAR(cmp2);
	}

	/* while a match is possible */
	while (end2 >= length1) {

	    /* prepare to search */
	    off1 = 0;
	    off2 = end2 - length1;
	    if (seq1.type != LispString_t)
		list1 = seq1.data.list;

	    /* for every element that must match in sequence1 */
	    while (off1 < end1) {
		if (seq1.type == LispString_t)
		    cmp1 = SCHAR(seq1.data.string[off1]);
		else
		    cmp1 = CAR(list1);
		if (seq2.type == LispString_t)
		    cmp2 = SCHAR(seq2.data.string[off2]);
		else
		    cmp2 = seq2.data.vector[off2];
		if (key != UNSPEC) {
		    cmp1 = APPLY1(key, cmp1);
		    cmp2 = APPLY1(key, cmp2);
		}

		/* Compare elements */
		value = FCOMPARE(lambda, cmp1, cmp2, code);
		if (value != expect)
		    break;

		/* Update offsets */
		++off1;
		++off2;
		if (seq1.type != LispString_t)
		    list1 = CDR(list1);
	    }

	    /* If all elements matched */
	    if (off1 == end1) {
		offset = off2 - length1;
		break;
	    }

	    /* Update offset */
	    --end2;
	}

	if (seq2.type != LispString_t)
	    LispFree(seq2.data.vector);
    }

    return (offset == -1 ? NIL : FIXNUM(offset));
}

/*
 * ext::getenv
 */
LispObj *
Lisp_Setenv(LispBuiltin *builtin)
/*
 setenv name value &optional overwrite
 */
{
    char *name, *value;

    LispObj *oname, *ovalue, *overwrite;

    overwrite = ARGUMENT(2);
    ovalue = ARGUMENT(1);
    oname = ARGUMENT(0);

    CHECK_STRING(oname);
    name = THESTR(oname);

    CHECK_STRING(ovalue);
    value = THESTR(ovalue);

    setenv(name, value, overwrite != UNSPEC && overwrite != NIL);
    value = getenv(name);

    return (value ? STRING(value) : NIL);
}

LispObj *
Lisp_Set(LispBuiltin *builtin)
/*
 set symbol value
 */
{
    LispAtom *atom;
    LispObj *symbol, *value;

    value = ARGUMENT(1);
    symbol = ARGUMENT(0);

    CHECK_SYMBOL(symbol);
    atom = symbol->data.atom;
    if (atom->dyn)
	LispSetVar(symbol, value);
    else if (atom->watch || !atom->a_object)
	LispSetAtomObjectProperty(atom, value);
    else {
	CHECK_CONSTANT(symbol);
	SETVALUE(atom, value);
    }

    return (value);
}

LispObj *
Lisp_SetDifference(LispBuiltin *builtin)
/*
 set-difference list1 list2 &key test test-not key
 */
{
    return (LispListSet(builtin, SETDIFFERENCE));
}

LispObj *
Lisp_SetExclusiveOr(LispBuiltin *builtin)
/*
 set-exclusive-or list1 list2 &key test test-not key
 */
{
    return (LispListSet(builtin, SETEXCLUSIVEOR));
}

LispObj *
Lisp_NsetExclusiveOr(LispBuiltin *builtin)
/*
 nset-exclusive-or list1 list2 &key test test-not key
 */
{
    return (LispListSet(builtin, NSETEXCLUSIVEOR));
}

LispObj *
Lisp_SetQ(LispBuiltin *builtin)
/*
 setq &rest form
 */
{
    LispObj *result, *variable, *form;

    form = ARGUMENT(0);

    result = NIL;
    for (; CONSP(form); form = CDR(form)) {
	variable = CAR(form);
	CHECK_SYMBOL(variable);
	CHECK_CONSTANT(variable);
	form = CDR(form);
	if (!CONSP(form))
	    LispDestroy("%s: odd number of arguments", STRFUN(builtin));
	result = EVAL(CAR(form));
	LispSetVar(variable, result);
    }

    return (result);
}

LispObj *
Lisp_Psetq(LispBuiltin *builtin)
/*
 psetq &rest form
 */
{
    GC_ENTER();
    int base = gc__protect;
    LispObj *value, *symbol, *list, *form;

    form = ARGUMENT(0);

    /* parallel setq, first pass evaluate values and basic error checking */
    for (list = form; CONSP(list); list = CDR(list)) {
	symbol = CAR(list);
	CHECK_SYMBOL(symbol);
	list = CDR(list);
	if (!CONSP(list))
	    LispDestroy("%s: odd number of arguments", STRFUN(builtin));
	value = EVAL(CAR(list));
	GC_PROTECT(value);
    }

    /* second pass, assign values */
    for (; CONSP(form); form = CDDR(form)) {
	symbol = CAR(form);
	CHECK_CONSTANT(symbol);
	LispSetVar(symbol, lisp__data.protect.objects[base++]);
    }
    GC_LEAVE();

    return (NIL);
}

LispObj *
Lisp_Setf(LispBuiltin *builtin)
/*
 setf &rest form
 */
{
    LispAtom *atom;
    LispObj *setf, *place, *value, *result = NIL, *data;

    LispObj *form;

    form = ARGUMENT(0);
d1805 3
a1807 93
    for (; CONSP(form); form = CDR(form)) {
	place = CAR(form);
	form = CDR(form);
	if (!CONSP(form))
	    LispDestroy("%s: odd number of arguments", STRFUN(builtin));
	value = CAR(form);

	if (!POINTERP(place))
	    goto invalid_place;
	if (XSYMBOLP(place)) {
	    CHECK_CONSTANT(place);
	    result = EVAL(value);
	    (void)LispSetVar(place, result);
	}
	else if (XCONSP(place)) {
	    /* it really should not be required to protect any object
	     * evaluated here, but is done for safety in case one of
	     * the evaluated forms returns data not gc protected, what
	     * could cause surprises if the object is garbage collected
	     * before finishing setf. */
	    GC_ENTER();

	    setf = CAR(place);
	    if (!SYMBOLP(setf))
		goto invalid_place;
	    if (!CONSP(CDR(place)))
		goto invalid_place;

	    value = EVAL(value);
	    GC_PROTECT(value);

	    atom = setf->data.atom;
	    if (atom->a_defsetf == 0) {
		if (atom->a_defstruct &&
		    atom->property->structure.function >= 0) {
		    /* Use a default setf method for the structure field, as
		     * if this definition have been done
		     *	(defsetf THE-STRUCT-FIELD (struct) (value)
		     *	 `(lisp::struct-store 'THE-STRUCT-FIELD ,struct ,value))
		     */
		    place = CDR(place);
		    data = CAR(place);
		    if (CONSP(CDR(place)))
			goto invalid_place;
		    data = EVAL(data);
		    GC_PROTECT(data);
		    result = APPLY3(Ostruct_store, setf, data, value);
		    GC_LEAVE();
		    continue;
		}
		/* Must also expand macros */
		else if (atom->a_function &&
			 atom->property->fun.function->funtype == LispMacro) {
		    result = LispRunSetfMacro(atom, CDR(place), value);
		    continue;
		}
		goto invalid_place;
	    }

	    place = CDR(place);
	    setf = setf->data.atom->property->setf;
	    if (SYMBOLP(setf)) {
		LispObj *arguments, *cons;

		if (!CONSP(CDR(place))) {
		    arguments = EVAL(CAR(place));
		    GC_PROTECT(arguments);
		    result = APPLY2(setf, arguments, value);
		}
		else if (!CONSP(CDDR(place))) {
		    arguments = EVAL(CAR(place));
		    GC_PROTECT(arguments);
		    cons = EVAL(CADR(place));
		    GC_PROTECT(cons);
		    result = APPLY3(setf, arguments, cons, value);
		}
		else {
		    arguments = cons = CONS(EVAL(CAR(place)), NIL);
		    GC_PROTECT(arguments);
		    for (place = CDR(place); CONSP(place); place = CDR(place)) {
			RPLACD(cons, CONS(EVAL(CAR(place)), NIL));
			cons = CDR(cons);
		    }
		    RPLACD(cons, CONS(value, NIL));
		    result = APPLY(setf, arguments);
		}
	    }
	    else
		result = LispRunSetf(atom->property->salist, setf, place, value);
	    GC_LEAVE();
	}
	else
	    goto invalid_place;
d1810 1
a1810 19
    return (result);
invalid_place:
    LispDestroy("%s: %s is an invalid place", STRFUN(builtin), STROBJ(place));
    /*NOTREACHED*/
    return (NIL);
}

LispObj *
Lisp_Psetf(LispBuiltin *builtin)
/*
 psetf &rest form
 */
{
    int base;
    GC_ENTER();
    LispAtom *atom;
    LispObj *setf, *place = NIL, *value, *data;

    LispObj *form;
d1812 2
a1813 1
    form = ARGUMENT(0);
d1815 2
a1816 53
    /* parallel setf, first pass evaluate values and basic error checking */
    base = gc__protect;
    for (setf = form; CONSP(setf); setf = CDR(setf)) {
	if (!POINTERP(CAR(setf)))
	    goto invalid_place;
	setf = CDR(setf);
	if (!CONSP(setf))
	    LispDestroy("%s: odd number of arguments", STRFUN(builtin));
	value = EVAL(CAR(setf));
	GC_PROTECT(value);
    }

    /* second pass, assign values */
    for (; CONSP(form); form = CDDR(form)) {
	place = CAR(form);
	value = lisp__data.protect.objects[base++];

	if (XSYMBOLP(place)) {
	    CHECK_CONSTANT(place);
	    (void)LispSetVar(place, value);
	}
	else if (XCONSP(place)) {
	    LispObj *arguments, *cons;
	    int xbase = lisp__data.protect.length;

	    setf = CAR(place);
	    if (!SYMBOLP(setf))
		goto invalid_place;
	    if (!CONSP(CDR(place)))
		goto invalid_place;

	    atom = setf->data.atom;
	    if (atom->a_defsetf == 0) {
		if (atom->a_defstruct &&
		    atom->property->structure.function >= 0) {
		    place = CDR(place);
		    data = CAR(place);
		    if (CONSP(CDR(place)))
			goto invalid_place;
		    data = EVAL(data);
		    GC_PROTECT(data);
		    (void)APPLY3(Ostruct_store, setf, data, value);
		    lisp__data.protect.length = xbase;
		    continue;
		}
		else if (atom->a_function &&
			 atom->property->fun.function->funtype == LispMacro) {
		    (void)LispRunSetfMacro(atom, CDR(place), value);
		    lisp__data.protect.length = xbase;
		    continue;
		}
		goto invalid_place;
	    }
d1818 2
a1819 34
	    place = CDR(place);
	    setf = setf->data.atom->property->setf;
	    if (SYMBOLP(setf)) {
		if (!CONSP(CDR(place))) {
		    arguments = EVAL(CAR(place));
		    GC_PROTECT(arguments);
		    (void)APPLY2(setf, arguments, value);
		}
		else if (!CONSP(CDDR(place))) {
		    arguments = EVAL(CAR(place));
		    GC_PROTECT(arguments);
		    cons = EVAL(CADR(place));
		    GC_PROTECT(cons);
		    (void)APPLY3(setf, arguments, cons, value);
		}
		else {
		    arguments = cons = CONS(EVAL(CAR(place)), NIL);
		    GC_PROTECT(arguments);
		    for (place = CDR(place); CONSP(place); place = CDR(place)) {
			RPLACD(cons, CONS(EVAL(CAR(place)), NIL));
			cons = CDR(cons);
		    }
		    RPLACD(cons, CONS(value, NIL));
		    (void)APPLY(setf, arguments);
		}
		lisp__data.protect.length = xbase;
	    }
	    else
		(void)LispRunSetf(atom->property->salist, setf, place, value);
	}
	else
	    goto invalid_place;
    }
    GC_LEAVE();
d1821 2
a1822 5
    return (NIL);
invalid_place:
    LispDestroy("%s: %s is an invalid place", STRFUN(builtin), STROBJ(place));
    /*NOTREACHED*/
    return (NIL);
d1826 1
a1826 4
Lisp_Sleep(LispBuiltin *builtin)
/*
 sleep seconds
 */
d1828 1
a1828 2
    long sec, msec;
    double value, dsec;
d1830 2
a1831 1
    LispObj *seconds;
d1833 2
a1834 11
    seconds = ARGUMENT(0);

    value = -1.0;
    switch (OBJECT_TYPE(seconds)) {
	case LispFixnum_t:
	    value = FIXNUM_VALUE(seconds);
	    break;
	case LispDFloat_t:
	    value = DFLOAT_VALUE(seconds);
	    break;
	default:
d1836 4
a1839 102
    }

    if (value < 0.0 || value > MOST_POSITIVE_FIXNUM)
	LispDestroy("%s: %s is not a positive fixnum",
		    STRFUN(builtin), STROBJ(seconds));

    msec = modf(value, &dsec) * 1e6;
    sec = dsec;

    if (sec)
	sleep(sec);
    if (msec)
	usleep(msec);

    return (NIL);
}

/*
 *   This function is called recursively, but the contents of "list2" are
 * kept gc protected until it returns to LispSort. This is required partly
 * because the "gc protection logic" protects an object, not the contents
 * of the c pointer.
 */
static LispObj *
LispMergeSort(LispObj *list, LispObj *predicate, LispObj *key, int code)
{
    int protect;
    LispObj *list1, *list2, *left, *right, *result, *cons;

    /* Check if list length is larger than 1 */
    if (!CONSP(list) || !CONSP(CDR(list)))
	return (list);

    list1 = list2 = list;
    for (;;) {
	list = CDR(list);
	if (!CONSP(list))
	    break;
	list = CDR(list);
	if (!CONSP(list))
	    break;
	list2 = CDR(list2);
    }
    cons = list2;
    list2 = CDR(list2);
    RPLACD(cons, NIL);

    protect = 0;
    if (lisp__data.protect.length + 2 >= lisp__data.protect.space)
	LispMoreProtects();
    lisp__data.protect.objects[lisp__data.protect.length++] = list2;
    list1 = LispMergeSort(list1, predicate, key, code);
    list2 = LispMergeSort(list2, predicate, key, code);

    left = CAR(list1);
    right = CAR(list2);
    if (key != UNSPEC) {
	protect = lisp__data.protect.length;
	left = APPLY1(key, left);
	lisp__data.protect.objects[protect] = left;
	right = APPLY1(key, right);
	lisp__data.protect.objects[protect + 1] = right;
    }

    result = NIL;
    for (;;) {
	if ((FCOMPARE(predicate, left, right, code)) == 0 &&
	    (FCOMPARE(predicate, right, left, code)) == 1) {
	    /* right is "smaller" */
	    if (result == NIL)
		result = list2;
	    else
		RPLACD(cons, list2);
	    cons = list2;
	    list2 = CDR(list2);
	    if (!CONSP(list2)) {
		RPLACD(cons, list1);
		break;
	    }
	    right = CAR(list2);
	    if (key != UNSPEC) {
		right = APPLY1(key, right);
		lisp__data.protect.objects[protect + 1] = right;
	    }
	}
	else {
	    /* left is "smaller" */
	    if (result == NIL)
		result = list1;
	    else
		RPLACD(cons, list1);
	    cons = list1;
	    list1 = CDR(list1);
	    if (!CONSP(list1)) {
		RPLACD(cons, list2);
		break;
	    }
	    left = CAR(list1);
	    if (key != UNSPEC) {
		left = APPLY1(key, left);
		lisp__data.protect.objects[protect] = left;
	    }
d1842 2
a1843 391
    if (key != UNSPEC)
	lisp__data.protect.length = protect;

    return (result);
}

/* XXX The first version made a copy of the list and then adjusted
 *     the CARs of the list. To minimize GC time now it is now doing
 *     the sort inplace. So, instead of writing just (sort variable)
 *     now it is required to write (setq variable (sort variable))
 *     if the variable should always keep all elements.
 */
LispObj *
Lisp_Sort(LispBuiltin *builtin)
/*
 sort sequence predicate &key key
 */
{
    GC_ENTER();
    int istring, code;
    long length;
    char *string;

    LispObj *list, *work, *cons = NULL;

    LispObj *sequence, *predicate, *key;

    key = ARGUMENT(2);
    predicate = ARGUMENT(1);
    sequence = ARGUMENT(0);

    length = LispLength(sequence);
    if (length < 2)
	return (sequence);

    list = sequence;
    istring = XSTRINGP(sequence);
    if (istring) {
	CHECK_STRING_WRITABLE(sequence);
	/* Convert string to list */
	string = THESTR(sequence);
	work = cons = CONS(SCHAR(string[0]), NIL);
	GC_PROTECT(work);
	for (++string; *string; ++string) {
	    RPLACD(cons, CONS(SCHAR(*string), NIL));
	    cons = CDR(cons);
	}
    }
    else if (ARRAYP(list))
	work = list->data.array.list;
    else
	work = list;

    FUNCTION_CHECK(predicate);
    code = FCODE(predicate);
    work = LispMergeSort(work, predicate, key, code);

    if (istring) {
	/* Convert list to string */
	string = THESTR(sequence);
	for (; CONSP(work); ++string, work = CDR(work))
	    *string = SCHAR_VALUE(CAR(work));
    }
    else if (ARRAYP(list))
	list->data.array.list = work;
    else
	sequence = work;
    GC_LEAVE();

    return (sequence);
}

LispObj *
Lisp_Subseq(LispBuiltin *builtin)
/*
 subseq sequence start &optional end
 */
{
    long start, end, length, seqlength;

    LispObj *sequence, *ostart, *oend, *result;

    oend = ARGUMENT(2);
    ostart = ARGUMENT(1);
    sequence = ARGUMENT(0);

    LispCheckSequenceStartEnd(builtin, sequence, ostart, oend,
			      &start, &end, &length);

    seqlength = end - start;

    if (sequence == NIL)
	result = NIL;
    else if (XSTRINGP(sequence)) {
	char *string = LispMalloc(seqlength + 1);

	memcpy(string, THESTR(sequence) + start, seqlength);
	string[seqlength] = '\0';
	result = STRING2(string);
    }
    else {
	GC_ENTER();
	LispObj *object;

	if (end > start) {
	    /* list or array */
	    int count;
	    LispObj *cons;

	    if (ARRAYP(sequence))
		object = sequence->data.array.list;
	    else
		object = sequence;
	    /* goto first element to copy */
	    for (count = 0; count < start; count++, object = CDR(object))
		;
	    result = cons = CONS(CAR(object), NIL);
	    GC_PROTECT(result);
	    for (++count, object = CDR(object); count < end; count++,
		 object = CDR(object)) {
		RPLACD(cons, CONS(CAR(object), NIL));
		cons = CDR(cons);
	    }
	}
	else
	    result = NIL;

	if (ARRAYP(sequence)) {
	    object = LispNew(NIL, NIL);
	    GC_PROTECT(object);
	    object->type = LispArray_t;
	    object->data.array.list = result;
	    object->data.array.dim = CONS(FIXNUM(seqlength), NIL);
	    object->data.array.rank = 1;
	    object->data.array.type = sequence->data.array.type;
	    object->data.array.zero = length == 0;
	    result = object;
	}
	GC_LEAVE();
    }

    return (result);
}

LispObj *
Lisp_Subsetp(LispBuiltin *builtin)
/*
 subsetp list1 list2 &key test test-not key
 */
{
    return (LispListSet(builtin, SUBSETP));
}


LispObj *
Lisp_Substitute(LispBuiltin *builtin)
/*
 substitute newitem olditem sequence &key from-end test test-not start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, SUBSTITUTE, NONE));
}

LispObj *
Lisp_SubstituteIf(LispBuiltin *builtin)
/*
 substitute-if newitem test sequence &key from-end start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, SUBSTITUTE, IF));
}

LispObj *
Lisp_SubstituteIfNot(LispBuiltin *builtin)
/*
 substitute-if-not newitem test sequence &key from-end start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, SUBSTITUTE, IFNOT));
}

LispObj *
Lisp_Symbolp(LispBuiltin *builtin)
/*
 symbolp object
 */
{
    LispObj *object;

    object = ARGUMENT(0);

    return (SYMBOLP(object) ? T : NIL);
}

LispObj *
Lisp_SymbolFunction(LispBuiltin *builtin)
/*
 symbol-function symbol
 */
{
    LispObj *symbol;

    symbol = ARGUMENT(0);
    CHECK_SYMBOL(symbol);

    return (LispSymbolFunction(symbol));
}

LispObj *
Lisp_SymbolName(LispBuiltin *builtin)
/*
 symbol-name symbol
 */
{
    LispObj *symbol;

    symbol = ARGUMENT(0);
    CHECK_SYMBOL(symbol);

    return (LispSymbolName(symbol));
}

LispObj *
Lisp_SymbolPackage(LispBuiltin *builtin)
/*
 symbol-package symbol
 */
{
    LispObj *symbol;

    symbol = ARGUMENT(0);
    CHECK_SYMBOL(symbol);

    symbol = symbol->data.atom->package;

    return (symbol ? symbol : NIL);
}

LispObj *
Lisp_SymbolPlist(LispBuiltin *builtin)
/*
 symbol-plist symbol
 */
{
    LispObj *symbol;

    symbol = ARGUMENT(0);

    CHECK_SYMBOL(symbol);

    return (symbol->data.atom->a_property ?
	    symbol->data.atom->property->properties : NIL);
}

LispObj *
Lisp_SymbolValue(LispBuiltin *builtin)
/*
 symbol-value symbol
 */
{
    LispAtom *atom;
    LispObj *symbol;

    symbol = ARGUMENT(0);

    CHECK_SYMBOL(symbol);
    atom = symbol->data.atom;
    if (!atom->a_object || atom->property->value == UNBOUND) {
	if (atom->package == lisp__data.keyword)
	    return (symbol);
	LispDestroy("%s: the symbol %s has no value",
		    STRFUN(builtin), STROBJ(symbol));
    }

    return (atom->dyn ? LispGetVar(symbol) : atom->property->value);
}

LispObj *
Lisp_Tagbody(LispBuiltin *builtin)
/*
 tagbody &rest body
 */
{
    GC_ENTER();
    int stack, lex, length;
    LispObj *list, *body, *ptr, *tag, *labels, *map, **p_body;
    LispBlock *block;

    body = ARGUMENT(0);

    /* Save environment information */
    stack = lisp__data.stack.length;
    lex = lisp__data.env.lex;
    length = lisp__data.env.length;

    /* Since the body may be large, and the code may iterate several
     * thousand times, it is not a bad idea to avoid checking all
     * elements of the body to verify if it is a tag. */
    for (labels = map = NIL, ptr = body; CONSP(ptr); ptr = CDR(ptr)) {
	tag = CAR(ptr);
	switch (OBJECT_TYPE(tag)) {
	    case LispNil_t:
	    case LispAtom_t:
	    case LispFixnum_t:
		/* Don't allow duplicated labels */
		for (list = labels; CONSP(list); list = CDDR(list)) {
		    if (CAR(list) == tag)
			LispDestroy("%s: tag %s specified more than once",
				    STRFUN(builtin), STROBJ(tag));
		}
		if (labels == NIL) {
		    labels = CONS(tag, CONS(NIL, NIL));
		    map = CDR(labels);
		    GC_PROTECT(labels);
		}
		else {
		    RPLACD(map, CONS(tag, CONS(NIL, NIL)));
		    map = CDDR(map);
		}
		break;
	    case LispCons_t:
		/* Restart point for tag */
		if (map != NIL && CAR(map) == NIL)
		    RPLACA(map, ptr);
		break;
	    default:
		break;
	}
    }
    /* Check for consecutive labels without code between them */
    for (ptr = labels; CONSP(ptr); ptr = CDDR(ptr)) {
	if (CADR(ptr) == NIL) {
	    for (map = CDDR(ptr); CONSP(map); map = CDDR(map)) {
		if (CADR(map) != NIL) {
		    RPLACA(CDR(ptr), CADR(map));
		    break;
		}
	    }
	}
    }

    /* Initialize */
    list = body;
    p_body = &body;
    block = LispBeginBlock(NIL, LispBlockBody);

    /* Loop */
    if (setjmp(block->jmp) != 0) {
	/* Restore environment */
	lisp__data.stack.length = stack;
	lisp__data.env.lex = lex;
	lisp__data.env.head = lisp__data.env.length = length;

	tag = lisp__data.block.block_ret;
	for (ptr = labels; CONSP(ptr); ptr = CDDR(ptr)) {
	    map = CAR(ptr);
	    if (map == tag)
		break;
	}

	if (!CONSP(ptr))
	    LispDestroy("%s: no such tag %s", STRFUN(builtin), STROBJ(tag));

	*p_body = CADR(ptr);
    }

    /* Execute code */
    for (; CONSP(body); body = CDR(body)) {
	LispObj *form = CAR(body);

	if (CONSP(form))
	    EVAL(form);
    }
    /* If got here, (go) not called, else, labels will be candidate to gc
     * when GC_LEAVE() be called by the code in the bottom of the stack. */
    GC_LEAVE();

    /* Finished */
    LispEndBlock(block);

    /* Always return NIL */
    return (NIL);
}

LispObj *
Lisp_The(LispBuiltin *builtin)
/*
 the value-type form
 */
{
    LispObj *value_type, *form;
d1845 1
a1845 6
    form = ARGUMENT(1);
    value_type = ARGUMENT(0);

    form = EVAL(form);

    return (LispCoerce(builtin, form, value_type));
d1849 1
a1849 4
Lisp_Throw(LispBuiltin *builtin)
/*
 throw tag result
 */
d1851 2
a1852 6
    unsigned blevel = lisp__data.block.block_level;

    LispObj *tag, *result;

    result = ARGUMENT(1);
    tag = ARGUMENT(0);
d1854 3
a1856 4
    tag = EVAL(tag);

    if (blevel == 0)
	LispDestroy("%s: not within a block", STRFUN(builtin));
d1858 1
d1860 2
a1861 1
	LispBlock *block = lisp__data.block.block[--blevel];
d1863 20
a1882 4
	if (block->type == LispBlockCatch && tag == block->tag) {
	    lisp__data.block.block_ret = EVAL(result);
	    LispBlockUnwind(block);
	    BLOCKJUMP(block);
d1884 3
d1888 3
a1890 1
    LispDestroy("%s: %s is not a valid tag", STRFUN(builtin), STROBJ(tag));
a1891 1
    /*NOTREACHED*/
d1895 2
a1896 2
static LispObj *
LispTreeEqual(LispObj *left, LispObj *right, LispObj *test, int expect)
d1898 1
a1898 1
    LispObj *cmp_left, *cmp_right;
d1900 2
a1901 28
    if ((OBJECT_TYPE(left)) ^ (OBJECT_TYPE(right)))
	return (NIL);
    if (CONSP(left)) {
	for (; CONSP(left) && CONSP(right);
	     left = CDR(left), right = CDR(right)) {
	    cmp_left = CAR(left);
	    cmp_right = CAR(right);
	    if ((OBJECT_TYPE(cmp_left)) ^ (OBJECT_TYPE(cmp_right)))
		return (NIL);
	    if (CONSP(cmp_left)) {
		if (LispTreeEqual(cmp_left, cmp_right, test, expect) == NIL)
		    return (NIL);
	    }
	    else {
		if (POINTERP(cmp_left) &&
		    (XQUOTEP(cmp_left) || XBACKQUOTEP(cmp_left))) {
		    cmp_left = cmp_left->data.quote;
		    cmp_right = cmp_right->data.quote;
		}
		else if (COMMAP(cmp_left)) {
		    cmp_left = cmp_left->data.comma.eval;
		    cmp_right = cmp_right->data.comma.eval;
		}
		if ((APPLY2(test, cmp_left, cmp_right) != NIL) != expect)
		    return (NIL);
	    }
	}
	if ((OBJECT_TYPE(left)) ^ (OBJECT_TYPE(right)))
d1903 6
d1911 6
a1916 7
    if (POINTERP(left) && (XQUOTEP(left) || XBACKQUOTEP(left))) {
	left = left->data.quote;
	right = right->data.quote;
    }
    else if (COMMAP(left)) {
	left = left->data.comma.eval;
	right = right->data.comma.eval;
d1918 1
d1920 1
a1920 1
    return ((APPLY2(test, left, right) != NIL) == expect ? T : NIL);
d1924 1
a1924 4
Lisp_TreeEqual(LispBuiltin *builtin)
/*
 tree-equal tree-1 tree-2 &key test test-not
 */
d1926 3
a1928 4
    int expect;
    LispObj *compare;

    LispObj *tree_1, *tree_2, *test, *test_not;
d1930 1
a1930 16
    test_not = ARGUMENT(3);
    test = ARGUMENT(2);
    tree_2 = ARGUMENT(1);
    tree_1 = ARGUMENT(0);

    CHECK_TEST_0();
    if (test_not != UNSPEC) {
	expect = 0;
	compare = test_not;
    }
    else {
	if (test == UNSPEC)
	    test = Oeql;
	expect = 1;
	compare = test;
    }
d1932 1
a1932 1
    return (LispTreeEqual(tree_1, tree_2, compare, expect));
d1936 1
a1936 4
Lisp_Typep(LispBuiltin *builtin)
/*
 typep object type
 */
d1938 3
a1940 3
    LispObj *result = NULL;

    LispObj *object, *type;
d1942 1
a1942 57
    type = ARGUMENT(1);
    object = ARGUMENT(0);

    if (SYMBOLP(type)) {
	Atom_id atom = ATOMID(type);

	if (OBJECT_TYPE(object) == LispStruct_t)
	    result = ATOMID(CAR(object->data.struc.def)) == atom ? T : NIL;
	else if (type->data.atom->a_defstruct &&
		 type->data.atom->property->structure.function == STRUCT_NAME)
	    result = NIL;
	else if (atom == Snil)
	    result = object == NIL ? T : NIL;
	else if (atom == St)
	    result = object == T ? T : NIL;
	else if (atom == Satom)
	    result = !CONSP(object) ? T : NIL;
	else if (atom == Ssymbol)
	    result = SYMBOLP(object) || object == NIL || object == T ? T : NIL;
	else if (atom == Sinteger)
	    result = INTEGERP(object) ? T : NIL;
	else if (atom == Srational)
	    result = RATIONALP(object) ? T : NIL;
	else if (atom == Scons || atom == Slist)
	    result = CONSP(object) ? T : NIL;
	else if (atom == Sstring)
	    result = STRINGP(object) ? T : NIL;
	else if (atom == Scharacter)
	    result = SCHARP(object) ? T : NIL;
	else if (atom == Scomplex)
	    result = COMPLEXP(object) ? T : NIL;
	else if (atom == Svector || atom == Sarray)
	    result = ARRAYP(object) ? T : NIL;
	else if (atom == Skeyword)
	    result = KEYWORDP(object) ? T : NIL;
	else if (atom == Sfunction)
	    result = LAMBDAP(object) ? T : NIL;
	else if (atom == Spathname)
	    result = PATHNAMEP(object) ? T : NIL;
	else if (atom == Sopaque)
	    result = OPAQUEP(object) ? T : NIL;
    }
    else if (CONSP(type)) {
	if (OBJECT_TYPE(object) == LispStruct_t &&
	    SYMBOLP(CAR(type)) && ATOMID(CAR(type)) == Sstruct &&
	    SYMBOLP(CAR(CDR(type))) && CDR(CDR(type)) == NIL) {
	    result = ATOMID(CAR(object->data.struc.def)) ==
		     ATOMID(CAR(CDR(type))) ? T : NIL;
	}
    }
    else if (type == NIL)
	result = object == NIL ? T : NIL;
    else if (type == T)
	result = object == T ? T : NIL;
    if (result == NULL)
	LispDestroy("%s: bad type specification %s",
		    STRFUN(builtin), STROBJ(type));
d1944 1
a1944 1
    return (result);
d1948 1
a1948 4
Lisp_Union(LispBuiltin *builtin)
/*
 union list1 list2 &key test test-not key
 */
d1950 14
a1963 1
    return (LispListSet(builtin, UNION));
d1967 1
a1967 4
Lisp_Nunion(LispBuiltin *builtin)
/*
 nunion list1 list2 &key test test-not key
 */
d1969 14
a1982 1
    return (LispListSet(builtin, NUNION));
d1986 1
a1986 4
Lisp_Unless(LispBuiltin *builtin)
/*
 unless test &rest body
 */
d1988 8
a1995 1
    LispObj *result, *test, *body;
d1997 14
a2010 2
    body = ARGUMENT(1);
    test = ARGUMENT(0);
d2012 6
a2017 7
    result = NIL;
    test = EVAL(test);
    RETURN_COUNT = 0;
    if (test == NIL) {
	for (; CONSP(body); body = CDR(body))
	    result = EVAL(CAR(body));
    }
d2019 13
a2031 2
    return (result);
}
d2033 14
a2046 10
/*
 * ext::until
 */
LispObj *
Lisp_Until(LispBuiltin *builtin)
/*
 until test &rest body
 */
{
    LispObj *result, *test, *body, *prog;
d2048 10
a2057 2
    body = ARGUMENT(1);
    test = ARGUMENT(0);
a2058 5
    result = NIL;
    for (;;) {
	if ((result = EVAL(test)) == NIL) {
	    for (prog = body; CONSP(prog); prog = CDR(prog))
		(void)EVAL(CAR(prog));
d2061 4
d2068 1
a2068 1
    return (result);
d2072 1
a2072 4
Lisp_UnwindProtect(LispBuiltin *builtin)
/*
 unwind-protect protect &rest cleanup
 */
d2074 2
a2075 3
    LispObj *result, **presult = &result;
    int did_jump, *pdid_jump = &did_jump, destroyed;
    LispBlock *block;
d2077 5
a2081 1
    LispObj *protect, *cleanup, **pcleanup = &cleanup;
d2083 6
a2088 2
    cleanup = ARGUMENT(1);
    protect = ARGUMENT(0);
d2090 6
a2095 11
    /* run protected code */
    *presult = NIL;
    *pdid_jump = 1;
    block = LispBeginBlock(NIL, LispBlockProtect);
    if (setjmp(block->jmp) == 0) {
	*presult = EVAL(protect);
	*pdid_jump = 0;
    }
    LispEndBlock(block);
    if (!lisp__data.destroyed && *pdid_jump)
	*presult = lisp__data.block.block_ret;
d2097 1
a2097 2
    destroyed = lisp__data.destroyed;
    lisp__data.destroyed = 0;
d2099 4
a2102 4
    /* run cleanup, unprotected code */
    if (CONSP(*pcleanup))
	for (; CONSP(cleanup); cleanup = CDR(cleanup))
	    (void)EVAL(CAR(cleanup));
d2104 2
a2105 7
    if (destroyed) {
	/* in case there is another unwind-protect */
	LispBlockUnwind(NULL);
	/* if not, just return to the toplevel */
	lisp__data.destroyed = 1;
	LispDestroy(".");
    }
d2107 1
a2107 2
    return (result);
}
d2109 4
a2112 5
static LispObj *
LispValuesList(LispBuiltin *builtin, int check_list)
{
    long i, count;
    LispObj *result;
d2114 7
a2120 1
    LispObj *list;
d2122 5
a2126 1
    list = ARGUMENT(0);
d2128 25
a2152 12
    count = LispLength(list) - 1;

    if (count >= 0) {
	result = CAR(list);
	if ((RETURN_CHECK(count)) != count)
	    LispDestroy("%s: too many values", STRFUN(builtin));
	RETURN_COUNT = count;
	for (i = 0, list = CDR(list); count && CONSP(list);
	     count--, i++, list = CDR(list))
	    RETURN(i) = CAR(list);
	if (check_list) {
	    CHECK_LIST(list);
d2154 1
a2154 4
    }
    else {
	RETURN_COUNT = -1;
	result = NIL;
d2157 1
a2157 1
    return (result);
d2161 1
a2161 4
Lisp_Values(LispBuiltin *builtin)
/*
 values &rest objects
 */
d2163 10
a2172 1
    return (LispValuesList(builtin, 0));
d2176 1
a2176 4
Lisp_ValuesList(LispBuiltin *builtin)
/*
 values-list list
 */
d2178 10
a2187 1
    return (LispValuesList(builtin, 1));
d2191 1
a2191 4
Lisp_Vector(LispBuiltin *builtin)
/*
 vector &rest objects
 */
d2193 74
a2266 1
    LispObj *objects;
d2268 14
a2281 1
    objects = ARGUMENT(0);
d2283 1
a2283 1
    return (VECTOR(objects));
d2287 1
a2287 4
Lisp_When(LispBuiltin *builtin)
/*
 when test &rest body
 */
d2289 1
a2289 1
    LispObj *result, *test, *body;
d2291 11
a2301 2
    body = ARGUMENT(1);
    test = ARGUMENT(0);
d2303 1
a2303 9
    result = NIL;
    test = EVAL(test);
    RETURN_COUNT = 0;
    if (test != NIL) {
	for (; CONSP(body); body = CDR(body))
	    result = EVAL(CAR(body));
    }

    return (result);
a2305 3
/*
 * ext::while
 */
d2307 1
a2307 4
Lisp_While(LispBuiltin *builtin)
/*
 while test &rest body
 */
d2309 5
a2313 1
    LispObj *test, *body, *prog;
d2315 3
a2317 2
    body = ARGUMENT(1);
    test = ARGUMENT(0);
d2319 25
a2343 4
    for (;;) {
	if (EVAL(test) != NIL) {
	    for (prog = body; CONSP(prog); prog = CDR(prog))
		(void)EVAL(CAR(prog));
a2344 2
	else
	    break;
d2346 2
a2351 3
/*
 * ext::unsetenv
 */
d2353 1
a2353 4
Lisp_Unsetenv(LispBuiltin *builtin)
/*
 unsetenv name
 */
d2355 3
a2357 1
    char *name;
d2359 19
a2377 1
    LispObj *oname;
d2379 5
a2383 6
    oname = ARGUMENT(0);

    CHECK_STRING(oname);
    name = THESTR(oname);

    unsetenv(name);
d2389 1
a2389 4
Lisp_XeditEltStore(LispBuiltin *builtin)
/*
 lisp::elt-store sequence index value
 */
d2391 2
a2392 1
    int length, offset;
d2394 6
a2399 1
    LispObj *sequence, *oindex, *value;
d2401 7
a2407 22
    value = ARGUMENT(2);
    oindex = ARGUMENT(1);
    sequence = ARGUMENT(0);

    CHECK_INDEX(oindex);
    offset = FIXNUM_VALUE(oindex);
    length = LispLength(sequence);

    if (offset >= length)
	LispDestroy("%s: index %d too large for sequence length %d",
		    STRFUN(builtin), offset, length);

    if (STRINGP(sequence)) {
	int ch;

	CHECK_STRING_WRITABLE(sequence);
	CHECK_SCHAR(value);
	ch = SCHAR_VALUE(value);
	if (ch < 0 || ch > 255)
	    LispDestroy("%s: cannot represent character %d",
			STRFUN(builtin), ch);
	THESTR(sequence)[offset] = ch;
d2409 3
a2411 3
    else {
	if (ARRAYP(sequence))
	    sequence = sequence->data.array.list;
d2413 6
a2418 4
	for (; offset > 0; offset--, sequence = CDR(sequence))
	    ;
	RPLACA(sequence, value);
    }
d2420 1
a2420 1
    return (value);
d2424 1
a2424 4
Lisp_XeditPut(LispBuiltin *builtin)
/*
 lisp::put symbol indicator value
 */
d2426 2
a2427 1
    LispObj *symbol, *indicator, *value;
d2429 3
a2431 3
    value = ARGUMENT(2);
    indicator = ARGUMENT(1);
    symbol = ARGUMENT(0);
d2433 7
a2439 1
    CHECK_SYMBOL(symbol);
d2441 1
a2441 1
    return (CAR(LispPutAtomProperty(symbol->data.atom, indicator, value)));
d2445 1
a2445 4
Lisp_XeditSetSymbolPlist(LispBuiltin *builtin)
/*
 lisp::set-symbol-plist symbol list
 */
d2447 2
a2448 1
    LispObj *symbol, *list;
d2450 5
a2454 2
    list = ARGUMENT(1);
    symbol = ARGUMENT(0);
d2456 4
a2459 3
    CHECK_SYMBOL(symbol);

    return (LispReplaceAtomPropertyList(symbol->data.atom, list));
d2462 3
d2466 1
a2466 4
Lisp_XeditVectorStore(LispBuiltin *builtin)
/*
 lisp::vector-store array &rest values
 */
d2468 18
a2485 2
    LispObj *value, *list, *object;
    long rank, count, sequence, offset, accum;
d2487 3
a2489 1
    LispObj *array, *values;
d2491 3
a2493 2
    values = ARGUMENT(1);
    array = ARGUMENT(0);
d2495 5
a2499 5
    /* check for errors */
    for (rank = 0, list = values;
	 CONSP(list) && CONSP(CDR(list));
	 list = CDR(list), rank++) {
	CHECK_INDEX(CAR(values));
d2501 3
d2505 1
a2505 44
    if (rank == 0)
	LispDestroy("%s: too few subscripts", STRFUN(builtin));
    value = CAR(list);

    if (STRINGP(array) && rank == 1) {
	long ch;
	long length = STRLEN(array);
	long offset = FIXNUM_VALUE(CAR(values));

	CHECK_SCHAR(value);
	CHECK_STRING_WRITABLE(array);
	ch = SCHAR_VALUE(value);
	if (offset >= length)
	    LispDestroy("%s: index %ld too large for sequence length %ld",
			STRFUN(builtin), offset, length);

	if (ch < 0 || ch > 255)
	    LispDestroy("%s: cannot represent character %ld",
			STRFUN(builtin), ch);
	THESTR(array)[offset] = ch;

	return (value);
    }

    CHECK_ARRAY(array);
    if (rank != array->data.array.rank)
	LispDestroy("%s: too %s subscripts", STRFUN(builtin),
		    rank < array->data.array.rank ? "few" : "many");

    for (list = values, object = array->data.array.dim;
	 CONSP(CDR(list));
	 list = CDR(list), object = CDR(object)) {
	if (FIXNUM_VALUE(CAR(list)) >= FIXNUM_VALUE(CAR(object)))
	    LispDestroy("%s: %ld is out of range, index %ld",
			STRFUN(builtin),
			FIXNUM_VALUE(CAR(list)),
			FIXNUM_VALUE(CAR(object)));
    }

    for (count = sequence = 0, list = values;
	 CONSP(CDR(list));
	 list = CDR(list), sequence++) {
	for (offset = 0, object = array->data.array.dim;
	     offset < sequence; object = CDR(object), offset++)
d2507 1
a2507 4
	for (accum = 1, object = CDR(object); CONSP(object);
	     object = CDR(object))
	    accum *= FIXNUM_VALUE(CAR(object));
	count += accum * FIXNUM_VALUE(CAR(list));
d2510 7
a2516 2
    for (array = array->data.array.list; count > 0; array = CDR(array), count--)
	;
d2518 6
a2523 1
    RPLACA(array, value);
d2525 1
a2525 1
    return (value);
d2529 1
a2529 4
Lisp_XeditDocumentationStore(LispBuiltin *builtin)
/*
 lisp::documentation-store symbol type string
 */
d2531 29
a2559 1
    LispDocType_t doc_type;
d2561 2
a2562 1
    LispObj *symbol, *type, *string;
d2564 1
a2564 3
    string = ARGUMENT(2);
    type = ARGUMENT(1);
    symbol = ARGUMENT(0);
d2566 2
a2567 1
    CHECK_SYMBOL(symbol);
d2569 4
a2572 2
    /* type is checked in LispDocumentationType() */
    doc_type = LispDocumentationType(builtin, type);
d2574 2
a2575 7
    if (string == NIL)
	/* allow explicitly releasing memory used for documentation */
	LispRemDocumentation(symbol, doc_type);
    else {
	CHECK_STRING(string);
	LispAddDocumentation(symbol, string, doc_type);
    }
d2577 1
a2577 1
    return (string);
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d30 1
a30 1
/* $XFree86: xc/programs/xedit/lisp/core.c,v 1.69 2002/12/20 04:32:45 paulo Exp $ */
a31 1
#include "io.h"
a34 1
#include "package.h"
a35 31
#include "write.h"

/*
 * Types
 */
typedef struct _SeqInfo {
    LispType type;
    union {
	LispObj *list;
	LispObj **vector;
	unsigned char *string;
    } data;
} SeqInfo;

#define SETSEQ(seq, object)						\
    switch (seq.type = XOBJECT_TYPE(object)) {				\
	case LispString_t:						\
	    seq.data.string = (unsigned char*)THESTR(object);		\
	    break;							\
	case LispCons_t:						\
	    seq.data.list = object;					\
	    break;							\
	default:							\
	    seq.data.list = object->data.array.list;			\
	    break;							\
    }

#ifdef NEED_SETENV
extern int setenv(const char *name, const char *value, int overwrite);
extern void unsetenv(const char *name);
#endif
d40 1
a40 102
#define NONE		0

#define	REMOVE		1
#define	SUBSTITUTE	2
#define DELETE		3
#define	NSUBSTITUTE	4

#define ASSOC		1
#define MEMBER		2

#define FIND		1
#define POSITION	2

#define	IF		1
#define	IFNOT		2

#define UNION		1
#define INTERSECTION	2
#define SETDIFFERENCE	3
#define SETEXCLUSIVEOR	4
#define SUBSETP		5
#define NSETDIFFERENCE	6
#define NINTERSECTION	7
#define NUNION		8
#define NSETEXCLUSIVEOR	9

#define COPY_LIST	1
#define COPY_ALIST	2
#define COPY_TREE	3

#define EVERY		1
#define SOME		2
#define NOTEVERY	3
#define NOTANY		4

/* Call directly LispObjectCompare() if possible */
#define FCODE(predicate)					\
    predicate == Oeql ? FEQL :					\
	predicate == Oequal ? FEQUAL :				\
	    predicate == Oeq ? FEQ :				\
		predicate == Oequalp ? FEQUALP : 0
#define FCOMPARE(predicate, left, right, code)			\
    code == FEQ ? left == right :				\
	code ? LispObjectCompare(left, right, code) != NIL :	\
	       APPLY2(predicate, left, right) != NIL

#define FUNCTION_CHECK(predicate)				\
    if (FUNCTIONP(predicate))					\
	predicate = (predicate)->data.atom->object

#define CHECK_TEST_0()						\
    if (test != UNSPEC && test_not != UNSPEC)			\
	LispDestroy("%s: specify either :TEST or :TEST-NOT",	\
		    STRFUN(builtin))

#define CHECK_TEST()						\
    CHECK_TEST_0();						\
    if (test_not == UNSPEC) {					\
	if (test == UNSPEC)					\
	    lambda = Oeql;					\
	else							\
	    lambda = test;					\
	expect = 1;						\
    }								\
    else {							\
	lambda = test_not;					\
	expect = 0;						\
    }								\
    FUNCTION_CHECK(lambda);					\
    code = FCODE(lambda)


static LispObj *LispAdjoin(LispBuiltin*,
			   LispObj*, LispObj*, LispObj*, LispObj*, LispObj*);
static LispObj *LispAssocOrMember(LispBuiltin*, int, int);
static LispObj *LispEverySomeAnyNot(LispBuiltin*, int);
static LispObj *LispFindOrPosition(LispBuiltin*, int, int);
static LispObj *LispDeleteOrRemoveDuplicates(LispBuiltin*, int);
static LispObj *LispDeleteRemoveXSubstitute(LispBuiltin*, int, int);
static LispObj *LispListSet(LispBuiltin*, int);
static LispObj *LispMapc(LispBuiltin*, int);
static LispObj *LispMapl(LispBuiltin*, int);
static LispObj *LispMapnconc(LispObj*);
extern LispObj *LispRunSetf(LispArgList*, LispObj*, LispObj*, LispObj*);
extern LispObj *LispRunSetfMacro(LispAtom*, LispObj*, LispObj*);
static LispObj *LispMergeSort(LispObj*, LispObj*, LispObj*, int);
static LispObj *LispXReverse(LispBuiltin*, int);
static LispObj *LispCopyList(LispBuiltin*, LispObj*, int);
static LispObj *LispValuesList(LispBuiltin*, int);
static LispObj *LispTreeEqual(LispObj*, LispObj*, LispObj*, int);
static LispDocType_t LispDocumentationType(LispBuiltin*, LispObj*);

extern void LispSetAtomObjectProperty(LispAtom*, LispObj*);

/*
 * Initialization
 */
LispObj *Oeq, *Oeql, *Oequal, *Oequalp, *Omake_array,
	*Kinitial_contents, *Osetf, *Ootherwise, *Oquote;
LispObj *Ogensym_counter;

Atom_id Svariable, Sstructure, Stype, Ssetf;
d45 2
a46 2
void
LispCoreInit(void)
d48 1
a48 20
    Oeq			= STATIC_ATOM("EQ");
    Oeql		= STATIC_ATOM("EQL");
    Oequal		= STATIC_ATOM("EQUAL");
    Oequalp		= STATIC_ATOM("EQUALP");
    Omake_array		= STATIC_ATOM("MAKE-ARRAY");
    Kinitial_contents	= KEYWORD("INITIAL-CONTENTS");
    Osetf		= STATIC_ATOM("SETF");
    Ootherwise		= STATIC_ATOM("OTHERWISE");
    LispExportSymbol(Ootherwise);
    Oquote		= STATIC_ATOM("QUOTE");
    LispExportSymbol(Oquote);

    Svariable		= GETATOMID("VARIABLE");
    Sstructure		= GETATOMID("STRUCTURE");
    Stype		= GETATOMID("TYPE");

    /* Create as a constant so that only the C code should change the value */
    Ogensym_counter	= STATIC_ATOM("*GENSYM-COUNTER*");
    LispDefconstant(Ogensym_counter, FIXNUM(0), NIL);
    LispExportSymbol(Ogensym_counter);
d50 6
a55 1
    Ssetf	= ATOMID(Osetf);
d59 1
a59 4
Lisp_Acons(LispBuiltin *builtin)
/*
 acons key datum alist
 */
d61 1
a61 1
    LispObj *key, *datum, *alist;
d63 6
a68 5
    alist = ARGUMENT(2);
    datum = ARGUMENT(1);
    key = ARGUMENT(0);

    return (CONS(CONS(key, datum), alist));
d71 2
a72 3
static LispObj *
LispAdjoin(LispBuiltin*builtin, LispObj *item, LispObj *list,
	   LispObj *key, LispObj *test, LispObj *test_not)
d74 1
a74 3
    GC_ENTER();
    int code, expect, value;
    LispObj *lambda, *compare, *object;
d76 10
a85 7
    CHECK_LIST(list);
    CHECK_TEST();

    if (key != UNSPEC) {
	item = APPLY1(key, item);
	/* Result is not guaranteed to be gc protected */
	GC_PROTECT(item);
d87 2
d90 4
a93 12
    /* Check if item is not already in place */
    for (object = list; CONSP(object); object = CDR(object)) {
	compare = CAR(object);
	if (key != UNSPEC) {
	    compare = APPLY1(key, compare);
	    GC_PROTECT(compare);
	    value = FCOMPARE(lambda, item, compare, code);
	    /* Unprotect compare... */
	    --lisp__data.protect.length;
	}
	else
	    value = FCOMPARE(lambda, item, compare, code);
d95 15
a109 6
	if (value == expect) {
	    /* Item is already in list */
	    GC_LEAVE();

	    return (list);
	}
d111 2
a112 1
    GC_LEAVE();
d114 6
a119 1
    return (CONS(item, list));
d123 1
a123 4
Lisp_Adjoin(LispBuiltin *builtin)
/*
 adjoin item list &key key test test-not
 */
d125 4
a128 1
    LispObj *item, *list, *key, *test, *test_not;
d130 5
a134 5
    test_not = ARGUMENT(4);
    test = ARGUMENT(3);
    key = ARGUMENT(2);
    list = ARGUMENT(1);
    item = ARGUMENT(0);
d136 4
a139 1
    return (LispAdjoin(builtin, item, list, key, test, test_not));
d143 1
a143 4
Lisp_Append(LispBuiltin *builtin)
/*
 append &rest lists
 */
d145 2
a146 2
    GC_ENTER();
    LispObj *result, *cons, *list;
d148 5
a152 1
    LispObj *lists;
d154 5
a158 1
    lists = ARGUMENT(0);
d160 4
a163 42
    /* no arguments */
    if (!CONSP(lists))
	return (NIL);

    /* skip initial nil lists */
    for (; CONSP(CDR(lists)) && CAR(lists) == NIL; lists = CDR(lists))
	;

    /* last argument is not copied (even if it is the single argument) */
    if (!CONSP(CDR(lists)))
	return (CAR(lists));

    /* make sure result is a list */
    list = CAR(lists);
    CHECK_CONS(list);
    result = cons = CONS(CAR(list), NIL);
    GC_PROTECT(result);
    for (list = CDR(list); CONSP(list); list = CDR(list)) {
	RPLACD(cons, CONS(CAR(list), NIL));
	cons = CDR(cons);
    }
    lists = CDR(lists);

    /* copy intermediate lists */
    for (; CONSP(CDR(lists)); lists = CDR(lists)) {
	list = CAR(lists);
	if (list == NIL)
	    continue;
	/* intermediate elements must be lists */
	CHECK_CONS(list);
	for (; CONSP(list); list = CDR(list)) {
	    RPLACD(cons, CONS(CAR(list), NIL));
	    cons = CDR(cons);
	}
    }

    /* add last element */
    RPLACD(cons, CAR(lists));

    GC_LEAVE();

    return (result);
d167 1
a167 4
Lisp_Aref(LispBuiltin *builtin)
/*
 aref array &rest subscripts
 */
d170 1
a170 6
    LispObj *obj, *dim;

    LispObj *array, *subscripts;

    subscripts = ARGUMENT(1);
    array = ARGUMENT(0);
d172 17
a188 3
    /* accept strings also */
    if (STRINGP(array) && CONSP(subscripts) && CDR(subscripts) == NIL) {
	long offset, length = STRLEN(array);
d190 2
a191 29
	CHECK_INDEX(CAR(subscripts));
	offset = FIXNUM_VALUE(CAR(subscripts));

	if (offset >= length)
	    LispDestroy("%s: index %ld too large for sequence length %ld",
			STRFUN(builtin), offset, length);

	return (SCHAR(THESTR(array)[offset]));
    }

    CHECK_ARRAY(array);

    for (count = 0, dim = subscripts, obj = array->data.array.dim; CONSP(dim);
	 count++, dim = CDR(dim), obj = CDR(obj)) {
	if (count >= array->data.array.rank)
	    LispDestroy("%s: too many subscripts %s",
			STRFUN(builtin), STROBJ(subscripts));
	if (!INDEXP(CAR(dim)) ||
	    FIXNUM_VALUE(CAR(dim)) >= FIXNUM_VALUE(CAR(obj)))
	    LispDestroy("%s: %s is out of range or a bad index",
			STRFUN(builtin), STROBJ(CAR(dim)));
    }
    if (count < array->data.array.rank)
	LispDestroy("%s: too few subscripts %s",
		    STRFUN(builtin), STROBJ(subscripts));

    for (count = seq = 0, dim = subscripts; CONSP(dim); dim = CDR(dim), seq++) {
	for (idx = 0, obj = array->data.array.dim; idx < seq;
	     obj = CDR(obj), ++idx)
d194 2
a195 2
	    c *= FIXNUM_VALUE(CAR(obj));
	count += c * FIXNUM_VALUE(CAR(dim));
d198 1
a198 1
    for (array = array->data.array.list; count > 0; array = CDR(array), count--)
d201 1
a201 1
    return (CAR(array));
d204 2
a205 10
static LispObj *
LispAssocOrMember(LispBuiltin *builtin, int function, int comparison)
/*
 assoc item list &key test test-not key
 assoc-if predicate list &key key
 assoc-if-not predicate list &key key
 member item list &key test test-not key
 member-if predicate list &key key
 member-if-not predicate list &key key
 */
d207 1
a207 20
    int code = 0, expect, value;
    LispObj *lambda, *result, *compare;

    LispObj *item, *list, *test, *test_not, *key;

    if (comparison == NONE) {
	key = ARGUMENT(4);
	test_not = ARGUMENT(3);
	test = ARGUMENT(2);
	list = ARGUMENT(1);
	item = ARGUMENT(0);
	lambda = NIL;
    }
    else {
	key = ARGUMENT(2);
	list = ARGUMENT(1);
	lambda = ARGUMENT(0);
	test = test_not = UNSPEC;
	item = NIL;
    }
d209 2
a212 19
    CHECK_CONS(list);

    /* Resolve compare function, and expected result of comparison */
    if (comparison == NONE) {
	CHECK_TEST();
    }
    else
	expect = comparison == IFNOT ? 0 : 1;

    result = NIL;
    for (; CONSP(list); list = CDR(list)) {
	compare = CAR(list);
	if (function == ASSOC) {
	    if (!CONSP(compare))
		continue;
	    compare = CAR(compare);
	}
	if (key != UNSPEC)
	    compare = APPLY1(key, compare);
d214 5
a218 8
	if (comparison == NONE)
	    value = FCOMPARE(lambda, item, compare, code);
	else
	    value = APPLY1(lambda, compare) != NIL;
	if (value == expect) {
	    result = list;
	    if (function == ASSOC)
		result = CAR(result);
a221 3
    if (function == MEMBER) {
	CHECK_LIST(list);
    }
d223 1
a223 1
    return (result);
d227 1
a227 4
Lisp_Assoc(LispBuiltin *builtin)
/*
 assoc item list &key test test-not key
 */
d229 1
a229 2
    return (LispAssocOrMember(builtin, ASSOC, NONE));
}
d231 5
a235 7
LispObj *
Lisp_AssocIf(LispBuiltin *builtin)
/*
 assoc-if predicate list &key key
 */
{
    return (LispAssocOrMember(builtin, ASSOC, IF));
d239 1
a239 4
Lisp_AssocIfNot(LispBuiltin *builtin)
/*
 assoc-if-not predicate list &key key
 */
d241 1
a241 2
    return (LispAssocOrMember(builtin, ASSOC, IFNOT));
}
d243 4
a246 7
LispObj *
Lisp_And(LispBuiltin *builtin)
/*
 and &rest args
 */
{
    LispObj *result = T, *args;
d248 2
a249 1
    args = ARGUMENT(0);
d251 33
a283 4
    for (; CONSP(args); args = CDR(args)) {
	result = EVAL(CAR(args));
	if (result == NIL)
	    break;
d285 1
d287 1
a287 1
    return (result);
d291 1
a291 4
Lisp_Apply(LispBuiltin *builtin)
/*
 apply function arg &rest more-args
 */
d293 1
a293 2
    GC_ENTER();
    LispObj *result, *arguments;
d295 18
a312 12
    LispObj *function, *arg, *more_args;

    more_args = ARGUMENT(2);
    arg = ARGUMENT(1);
    function = ARGUMENT(0);

    if (more_args == NIL) {
	CHECK_LIST(arg);
	arguments = arg;
	for (; CONSP(arg); arg = CDR(arg))
	    ;
	CHECK_LIST(arg);
d314 6
a319 19
    else {
	LispObj *cons;

	CHECK_CONS(more_args);
	arguments = cons = CONS(arg, NIL);
	GC_PROTECT(arguments);
	for (arg = CDR(more_args);
	     CONSP(arg);
	     more_args = arg, arg = CDR(arg)) {
	    RPLACD(cons, CONS(CAR(more_args), NIL));
	    cons = CDR(cons);
	}
	more_args = CAR(more_args);
	if (more_args != NIL) {
	    for (arg = more_args; CONSP(arg); arg = CDR(arg))
		;
	    CHECK_LIST(arg);
	    RPLACD(cons, more_args);
	}
d322 1
a322 2
    result = APPLY(function, arguments);
    GC_LEAVE();
d324 1
a324 1
    return (result);
d328 1
a328 4
Lisp_Atom(LispBuiltin *builtin)
/*
 atom object
 */
d330 1
a330 1
    LispObj *object;
d332 12
a343 3
    object = ARGUMENT(0);

    return (CONSP(object) ? NIL : T);
d347 1
a347 4
Lisp_Block(LispBuiltin *builtin)
/*
 block name &rest body
 */
d350 1
a350 1
    LispObj *res, **pres = &res, **pbody;
d353 3
a355 4
    LispObj *name, *body;

    body = ARGUMENT(1);
    name = ARGUMENT(0);
a356 5
    if (!SYMBOLP(name) && name != NIL && name != T)
	LispDestroy("%s: %s cannot name a block",
		    STRFUN(builtin), STROBJ(name));

    pbody = &body;
d359 1
a359 1
    block = LispBeginBlock(name, LispBlockTag);
d361 1
a361 2
	for (; CONSP(body); body = CDR(body))
	    res = EVAL(CAR(body));
d364 1
a364 1
    LispEndBlock(block);
d366 1
a366 1
	*pres = lisp__data.block.block_ret;
d368 1
a368 1
    return (res);
d372 1
a372 4
Lisp_Boundp(LispBuiltin *builtin)
/*
 boundp symbol
 */
d374 35
a408 33
    LispAtom *atom;

    LispObj *symbol = ARGUMENT(0);

    CHECK_SYMBOL(symbol);

    atom = symbol->data.atom;
    if (atom->package == lisp__data.keyword ||
	(atom->a_object && atom->property->value != UNBOUND))
	return (T);

    return (NIL);
}

LispObj *
Lisp_Butlast(LispBuiltin *builtin)
/*
 butlast list &optional count
 */
{
    GC_ENTER();
    long length, count;
    LispObj *result, *cons, *list, *ocount;

    ocount = ARGUMENT(1);
    list = ARGUMENT(0);

    CHECK_LIST(list);
    if (ocount == UNSPEC)
	count = 1;
    else {
	CHECK_INDEX(ocount);
	count = FIXNUM_VALUE(ocount);
a409 1
    length = LispLength(list);
d411 11
a421 11
    if (count == 0)
	return (list);
    else if (count >= length)
	return (NIL);

    length -= count + 1;
    result = cons = CONS(CAR(list), NIL);
    GC_PROTECT(result);
    for (list = CDR(list); length > 0; list = CDR(list), length--) {
	RPLACD(cons, CONS(CAR(list), NIL));
	cons = CDR(cons);
d423 1
a423 1
    GC_LEAVE();
d425 1
a425 1
    return (result);
d429 1
a429 4
Lisp_Nbutlast(LispBuiltin *builtin)
/*
 nbutlast list &optional count
 */
d431 1
a431 2
    long length, count;
    LispObj *result, *list, *ocount;
d433 10
a442 9
    ocount = ARGUMENT(1);
    list = ARGUMENT(0);

    CHECK_LIST(list);
    if (ocount == UNSPEC)
	count = 1;
    else {
	CHECK_INDEX(ocount);
	count = FIXNUM_VALUE(ocount);
a443 1
    length = LispLength(list);
d445 1
a445 12
    if (count == 0)
	return (list);
    else if (count >= length)
	return (NIL);

    length -= count + 1;
    result = list;
    for (; length > 0; list = CDR(list), length--)
	;
    RPLACD(list, NIL);

    return (result);
d449 1
a449 4
Lisp_Car(LispBuiltin *builtin)
/*
 car list
 */
d451 2
a452 1
    LispObj *list, *result = NULL;
d454 2
a455 1
    list = ARGUMENT(0);
d457 15
a471 34
    if (list == NIL)
	result = NIL;
    else {
	CHECK_CONS(list);
	result = CAR(list);
    }

    return (result);
}

LispObj *
Lisp_Case(LispBuiltin *builtin)
/*
 case keyform &rest body
 */
{
    LispObj *result, *code, *keyform, *body, *form;

    body = ARGUMENT(1);
    keyform = ARGUMENT(0);

    result = NIL;
    keyform = EVAL(keyform);

    for (; CONSP(body); body = CDR(body)) {
	code = CAR(body);
	CHECK_CONS(code);

	form = CAR(code);
	if (form == T || form == Ootherwise) {
	    if (CONSP(CDR(body)))
		LispDestroy("%s: %s must be the last clause",
			    STRFUN(builtin), STROBJ(CAR(code)));
	    result = CDR(code);
d474 6
a479 4
	else if (CONSP(form)) {
	    for (; CONSP(form); form = CDR(form))
		if (XEQL(keyform, CAR(form)) == T) {
		    result = CDR(code);
d482 1
a482 1
	    if (CONSP(form))	/* if found match */
d485 2
a486 2
	else if (XEQL(keyform, form) == T) {
	    result = CDR(code);
d491 1
a491 4
    for (body = result; CONSP(body); body = CDR(body))
	result = EVAL(CAR(body));

    return (result);
d495 1
a495 4
Lisp_Catch(LispBuiltin *builtin)
/*
 catch tag &rest body
 */
a500 6
    LispObj *tag, *body, **pbody;

    body = ARGUMENT(1);
    tag = ARGUMENT(0);

    pbody = &body;
d503 1
a503 1
    block = LispBeginBlock(tag, LispBlockCatch);
d505 1
a505 2
	for (; CONSP(body); body = CDR(body))
	    res = EVAL(CAR(body));
d508 1
a508 1
    LispEndBlock(block);
d510 1
a510 1
	*pres = lisp__data.block.block_ret;
d512 1
a512 1
    return (res);
d516 1
a516 4
Lisp_Coerce(LispBuiltin *builtin)
/*
 coerce object result-type
 */
d518 29
a546 1
    LispObj *object, *result_type;
d548 33
a580 2
    result_type = ARGUMENT(1);
    object = ARGUMENT(0);
d582 1
a582 1
    return (LispCoerce(builtin, object, result_type));
d586 1
a586 4
Lisp_Cdr(LispBuiltin *builtin)
/*
 cdr list
 */
d588 1
a588 1
    LispObj *list, *result = NULL;
d590 10
a599 7
    list = ARGUMENT(0);

    if (list == NIL)
	result = NIL;
    else {
	CHECK_CONS(list);
	result = CDR(list);
d602 1
a602 1
    return (result);
d606 1
a606 4
Lisp_C_r(LispBuiltin *builtin)
/*
 c[ad]{2,4}r list
 */
d608 1
a608 1
    char *desc;
d610 11
a620 14
    LispObj *list, *result = NULL;

    list = ARGUMENT(0);

    result = list;
    desc = STRFUN(builtin);
    while (desc[1] != 'R')
	++desc;
    while (*desc != 'C') {
	if (result == NIL)
	    break;
	CHECK_CONS(result);
	result = *desc == 'A' ? CAR(result) : CDR(result);
	--desc;
d623 1
a623 1
    return (result);
d627 1
a627 4
Lisp_Cond(LispBuiltin *builtin)
/*
 cond &rest body
 */
d629 2
a630 1
    LispObj *result, *code, *body;
d632 6
a637 1
    body = ARGUMENT(0);
d639 6
a644 11
    result = NIL;
    for (; CONSP(body); body = CDR(body)) {
	code = CAR(body);

	CHECK_CONS(code);
	result = EVAL(CAR(code));
	if (result == NIL)
	    continue;
	for (code = CDR(code); CONSP(code); code = CDR(code))
	    result = EVAL(CAR(code));
	break;
d647 2
a648 8
    return (result);
}

static LispObj *
LispCopyList(LispBuiltin *builtin, LispObj *list, int function)
{
    GC_ENTER();
    LispObj *result, *cons;
d650 14
a663 3
    if (list == NIL)
	return (list);
    CHECK_CONS(list);
d665 4
a668 14
    result = cons = CONS(NIL, NIL);
    GC_PROTECT(result);
    if (CONSP(CAR(list))) {
	switch (function) {
	    case COPY_LIST:
		RPLACA(result, CAR(list));
		break;
	    case COPY_ALIST:
		RPLACA(result, CONS(CAR(CAR(list)), CDR(CAR(list))));
		break;
	    case COPY_TREE:
		RPLACA(result, LispCopyList(builtin, CAR(list), COPY_TREE));
		break;
	}
d670 3
a672 19
    else
	RPLACA(result, CAR(list));

    for (list = CDR(list); CONSP(list); list = CDR(list)) {
	CDR(cons) = CONS(NIL, NIL);
	cons = CDR(cons);
	if (CONSP(CAR(list))) {
	    switch (function) {
		case COPY_LIST:
		    RPLACA(cons, CAR(list));
		    break;
		case COPY_ALIST:
		    RPLACA(cons, CONS(CAR(CAR(list)), CDR(CAR(list))));
		    break;
		case COPY_TREE:
		    RPLACA(cons, LispCopyList(builtin, CAR(list), COPY_TREE));
		    break;
	    }
	}
d674 1
a674 1
	    RPLACA(cons, CAR(list));
a675 3
    /* in case list is dotted */
    RPLACD(cons, list);
    GC_LEAVE();
d677 1
a677 1
    return (result);
d681 1
a681 4
Lisp_CopyAlist(LispBuiltin *builtin)
/*
 copy-alist list
 */
d683 1
a683 5
    LispObj *list;

    list = ARGUMENT(0);

    return (LispCopyList(builtin, list, COPY_ALIST));
d687 1
a687 4
Lisp_CopyList(LispBuiltin *builtin)
/*
 copy-list list
 */
d689 1
a689 5
    LispObj *list;

    list = ARGUMENT(0);

    return (LispCopyList(builtin, list, COPY_LIST));
d693 1
a693 4
Lisp_CopyTree(LispBuiltin *builtin)
/*
 copy-tree list
 */
d695 11
a705 1
    LispObj *list;
d707 2
a708 1
    list = ARGUMENT(0);
d710 1
a710 1
    return (LispCopyList(builtin, list, COPY_TREE));
d714 1
a714 4
Lisp_Cons(LispBuiltin *builtin)
/*
 cons car cdr
 */
d716 1
a716 6
    LispObj *car, *cdr;

    cdr = ARGUMENT(1);
    car = ARGUMENT(0);

    return (CONS(car, cdr));
d720 1
a720 4
Lisp_Consp(LispBuiltin *builtin)
/*
 consp object
 */
d722 1
a722 5
    LispObj *object;

    object = ARGUMENT(0);

    return (CONSP(object) ? T : NIL);
d726 1
a726 4
Lisp_Constantp(LispBuiltin *builtin)
/*
 constantp form &optional environment
 */
d728 1
a728 16
    LispObj *form, *environment;

    environment = ARGUMENT(1);
    form = ARGUMENT(0);

    /* not all self-evaluating objects are considered constants */
    if (!POINTERP(form) ||
	NUMBERP(form) ||
	XQUOTEP(form) ||
	(XCONSP(form) && CAR(form) == Oquote) ||
	(XSYMBOLP(form) && form->data.atom->constant) ||
	XSTRINGP(form) ||
	XARRAYP(form))
	return (T);

    return (NIL);
d732 1
a732 4
Lisp_Defconstant(LispBuiltin *builtin)
/*
 defconstant name initial-value &optional documentation
 */
d734 1
a734 15
    LispObj *name, *initial_value, *documentation;

    documentation = ARGUMENT(2);
    initial_value = ARGUMENT(1);
    name = ARGUMENT(0);

    CHECK_SYMBOL(name);
    if (documentation != UNSPEC) {
	CHECK_STRING(documentation);
    }
    else
	documentation = NIL;
    LispDefconstant(name, EVAL(initial_value), documentation);

    return (name);
d738 1
a738 4
Lisp_Defmacro(LispBuiltin *builtin)
/*
 defmacro name lambda-list &rest body
 */
d740 2
a741 1
    LispArgList *alist;
d743 2
a744 1
    LispObj *lambda, *name, *lambda_list, *body;
d746 3
a748 3
    body = ARGUMENT(2);
    lambda_list = ARGUMENT(1);
    name = ARGUMENT(0);
d750 5
a754 2
    CHECK_SYMBOL(name);
    alist = LispCheckArguments(LispMacro, lambda_list, ATOMID(name), 0);
d756 3
a758 3
    if (CONSP(body) && STRINGP(CAR(body))) {
	LispAddDocumentation(name, CAR(body), LispDocFunction);
	body = CDR(body);
d761 2
a762 2
    lambda_list = LispListProtectedArguments(alist);
    lambda = LispNewLambda(name, body, lambda_list, LispMacro);
d764 5
a768 7
    if (name->data.atom->a_builtin || name->data.atom->a_compiled) {
	if (name->data.atom->a_builtin) {
	    ERROR_CHECK_SPECIAL_FORM(name->data.atom);
	}
	/* redefining these may cause surprises if bytecode
	 * compiled functions references them */
	LispWarning("%s: %s is being redefined", STRFUN(builtin), ATOMID(name));
d770 4
a773 2
	LispRemAtomBuiltinProperty(name->data.atom);
    }
d775 3
a777 2
    LispSetAtomFunctionProperty(name->data.atom, lambda, alist);
    LispUseArgList(alist);
d779 1
a779 1
    return (name);
d783 1
a783 4
Lisp_Defun(LispBuiltin *builtin)
/*
 defun name lambda-list &rest body
 */
d785 2
a786 1
    LispArgList *alist;
d788 4
a791 1
    LispObj *lambda, *name, *lambda_list, *body;
d793 2
a794 3
    body = ARGUMENT(2);
    lambda_list = ARGUMENT(1);
    name = ARGUMENT(0);
d796 2
a797 2
    CHECK_SYMBOL(name);
    alist = LispCheckArguments(LispFunction, lambda_list, ATOMID(name), 0);
d799 4
a802 4
    if (CONSP(body) && STRINGP(CAR(body))) {
	LispAddDocumentation(name, CAR(body), LispDocFunction);
	body = CDR(body);
    }
d804 4
a807 2
    lambda_list = LispListProtectedArguments(alist);
    lambda = LispNewLambda(name, body, lambda_list, LispFunction);
d809 7
a815 9
    if (name->data.atom->a_builtin || name->data.atom->a_compiled) {
	if (name->data.atom->a_builtin) {
	    ERROR_CHECK_SPECIAL_FORM(name->data.atom);
	}
	/* redefining these may cause surprises if bytecode
	 * compiled functions references them */
	LispWarning("%s: %s is being redefined", STRFUN(builtin), ATOMID(name));

	LispRemAtomBuiltinProperty(name->data.atom);
a816 2
    LispSetAtomFunctionProperty(name->data.atom, lambda, alist);
    LispUseArgList(alist);
d818 1
a818 1
    return (name);
d822 1
a822 4
Lisp_Defsetf(LispBuiltin *builtin)
/*
 defsetf function lambda-list &rest body
 */
d824 1
a824 3
    LispArgList *alist;
    LispObj *obj;
    LispObj *lambda, *function, *lambda_list, *store, *body;
d826 2
a827 3
    body = ARGUMENT(2);
    lambda_list = ARGUMENT(1);
    function = ARGUMENT(0);
d829 4
a832 1
    CHECK_SYMBOL(function);
d834 4
a837 6
    if (body == NIL || (CONSP(body) && STRINGP(CAR(body)))) {
	if (!SYMBOLP(lambda_list))
	    LispDestroy("%s: syntax error %s %s",
			STRFUN(builtin), STROBJ(function), STROBJ(lambda_list));
	if (body != NIL)
	    LispAddDocumentation(function, CAR(body), LispDocSetf);
d839 1
a839 1
	LispSetAtomSetfProperty(function->data.atom, lambda_list, NULL);
d841 8
a848 1
	return (function);
d851 1
a851 21
    alist = LispCheckArguments(LispSetf, lambda_list, ATOMID(function), 0);

    store = CAR(body);
    if (!CONSP(store))
	LispDestroy("%s: %s is a bad store value",
		    STRFUN(builtin), STROBJ(store));
    for (obj = store; CONSP(obj); obj = CDR(obj)) {
	CHECK_SYMBOL(CAR(obj));
    }

    body = CDR(body);
    if (CONSP(body) && STRINGP(CAR(body))) {
	LispAddDocumentation(function, CAR(body), LispDocSetf);
	body = CDR(body);
    }

    lambda = LispNewLambda(function, body, store, LispSetf);
    LispSetAtomSetfProperty(function->data.atom, lambda, alist);
    LispUseArgList(alist);

    return (function);
d855 1
a855 4
Lisp_Defparameter(LispBuiltin *builtin)
/*
 defparameter name initial-value &optional documentation
 */
d857 1
a857 12
    LispObj *name, *initial_value, *documentation;

    documentation = ARGUMENT(2);
    initial_value = ARGUMENT(1);
    name = ARGUMENT(0);

    CHECK_SYMBOL(name);
    if (documentation != UNSPEC) {
	CHECK_STRING(documentation);
    }
    else
	documentation = NIL;
d859 1
a859 3
    LispProclaimSpecial(name, EVAL(initial_value), documentation);

    return (name);
d863 1
a863 4
Lisp_Defvar(LispBuiltin *builtin)
/*
 defvar name &optional initial-value documentation
 */
d865 2
a866 1
    LispObj *name, *initial_value, *documentation;
d868 2
a869 10
    documentation = ARGUMENT(2);
    initial_value = ARGUMENT(1);
    name = ARGUMENT(0);

    CHECK_SYMBOL(name);
    if (documentation != UNSPEC) {
	CHECK_STRING(documentation);
    }
    else
	documentation = NIL;
d871 2
a872 3
    LispProclaimSpecial(name,
			initial_value != UNSPEC ? EVAL(initial_value) : NULL,
			documentation);
d874 9
a882 2
    return (name);
}
d884 2
a885 8
LispObj *
Lisp_Delete(LispBuiltin *builtin)
/*
 delete item sequence &key from-end test test-not start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, DELETE, NONE));
}
d887 2
a888 7
LispObj *
Lisp_DeleteIf(LispBuiltin *builtin)
/*
 delete-if predicate sequence &key from-end start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, DELETE, IF));
d892 1
a892 4
Lisp_DeleteIfNot(LispBuiltin *builtin)
/*
 delete-if-not predicate sequence &key from-end start end count key
 */
d894 3
a896 2
    return (LispDeleteRemoveXSubstitute(builtin, DELETE, IFNOT));
}
d898 7
a904 17
LispObj *
Lisp_DeleteDuplicates(LispBuiltin *builtin)
/*
 delete-duplicates sequence &key from-end test test-not start end key
 */
{
    return (LispDeleteOrRemoveDuplicates(builtin, DELETE));
}

LispObj *
Lisp_Do(LispBuiltin *builtin)
/*
 do init test &rest body
 */
{
    return (LispDo(builtin, 0));
}
d906 2
a907 8
LispObj *
Lisp_DoP(LispBuiltin *builtin)
/*
 do* init test &rest body
 */
{
    return (LispDo(builtin, 1));
}
d909 2
a910 5
static LispDocType_t
LispDocumentationType(LispBuiltin *builtin, LispObj *type)
{
    Atom_id atom;
    LispDocType_t doc_type = LispDocVariable;
d912 5
a916 13
    CHECK_SYMBOL(type);
    atom = ATOMID(type);

    if (atom == Svariable)
	doc_type = LispDocVariable;
    else if (atom == Sfunction)
	doc_type = LispDocFunction;
    else if (atom == Sstructure)
	doc_type = LispDocStructure;
    else if (atom == Stype)
	doc_type = LispDocType;
    else if (atom == Ssetf)
	doc_type = LispDocSetf;
d918 4
a921 3
	LispDestroy("%s: unknown documentation type %s",
		    STRFUN(builtin), STROBJ(type));
	/*NOTREACHED*/
d924 1
a924 1
    return (doc_type);
d928 1
a928 4
Lisp_Documentation(LispBuiltin *builtin)
/*
 documentation symbol type
 */
d930 1
a930 1
    LispObj *symbol, *type;
d932 10
a941 2
    type = ARGUMENT(1);
    symbol = ARGUMENT(0);
d943 1
a943 4
    CHECK_SYMBOL(symbol);
    /* type is checked in LispDocumentationType() */

    return (LispGetDocumentation(symbol, LispDocumentationType(builtin, type)));
d947 1
a947 1
Lisp_DoList(LispBuiltin *builtin)
d949 1
a949 1
    return (LispDoListTimes(builtin, 0));
d953 1
a953 1
Lisp_DoTimes(LispBuiltin *builtin)
d955 1
a955 1
    return (LispDoListTimes(builtin, 1));
d959 1
a959 5
Lisp_Elt(LispBuiltin *builtin)
/*
 elt sequence index
 svref sequence index
 */
d961 2
a962 2
    long offset, length;
    LispObj *result, *sequence, *oindex;
d964 4
a967 2
    oindex = ARGUMENT(1);
    sequence = ARGUMENT(0);
d969 8
a976 1
    length = LispLength(sequence);
d978 2
a979 2
    CHECK_INDEX(oindex);
    offset = FIXNUM_VALUE(oindex);
d981 1
a981 3
    if (offset >= length)
	LispDestroy("%s: index %ld too large for sequence length %ld",
		    STRFUN(builtin), offset, length);
d983 4
a986 5
    if (STRINGP(sequence))
	result = SCHAR(THESTR(sequence)[offset]);
    else {
	if (ARRAYP(sequence))
	    sequence = sequence->data.array.list;
d988 2
a989 4
	for (; offset > 0; offset--, sequence = CDR(sequence))
	    ;
	result = CAR(sequence);
    }
d991 1
a991 1
    return (result);
d995 1
a995 4
Lisp_Endp(LispBuiltin *builtin)
/*
 endp object
 */
d997 2
a998 1
    LispObj *object;
d1000 24
a1023 1
    object = ARGUMENT(0);
d1025 1
a1025 5
    if (object == NIL)
	return (T);
    CHECK_CONS(object);

    return (NIL);
d1029 1
a1029 4
Lisp_Eq(LispBuiltin *builtin)
/*
 eq left right
 */
d1031 1
a1031 6
    LispObj *left, *right;

    right = ARGUMENT(1);
    left = ARGUMENT(0);

    return (XEQ(left, right));
d1035 1
a1035 4
Lisp_Eql(LispBuiltin *builtin)
/*
 eql left right
 */
d1037 1
a1037 6
    LispObj *left, *right;

    right = ARGUMENT(1);
    left = ARGUMENT(0);

    return (XEQL(left, right));
d1041 1
a1041 4
Lisp_Equal(LispBuiltin *builtin)
/*
 equal left right
 */
d1043 1
a1043 6
    LispObj *left, *right;

    right = ARGUMENT(1);
    left = ARGUMENT(0);

    return (XEQUAL(left, right));
d1047 1
a1047 4
Lisp_Equalp(LispBuiltin *builtin)
/*
 equalp left right
 */
d1049 1
a1049 1
    LispObj *left, *right;
d1051 17
a1067 2
    right = ARGUMENT(1);
    left = ARGUMENT(0);
d1069 1
a1069 1
    return (XEQUALP(left, right));
d1073 1
a1073 4
Lisp_Error(LispBuiltin *builtin)
/*
 error control-string &rest arguments
 */
d1075 7
a1081 11
    LispObj *string, *arglist;

    LispObj *control_string, *arguments;

    arguments = ARGUMENT(1);
    control_string = ARGUMENT(0);

    arglist = CONS(NIL, CONS(control_string, arguments));
    GC_PROTECT(arglist);
    string = APPLY(Oformat, arglist);
    LispDestroy("%s", THESTR(string));
a1082 3

    /* No need to call GC_ENTER() and GC_LEAVE() macros */
    return (NIL);
d1086 1
a1086 4
Lisp_Eval(LispBuiltin *builtin)
/*
 eval form
 */
d1088 2
a1089 2
    int lex;
    LispObj *form, *result;
d1091 9
a1099 1
    form = ARGUMENT(0);
d1101 1
a1101 7
    /* make sure eval form will not access local variables */
    lex = lisp__data.env.lex;
    lisp__data.env.lex = lisp__data.env.length;
    result = EVAL(form);
    lisp__data.env.lex = lex;

    return (result);
d1104 2
a1105 8
static LispObj *
LispEverySomeAnyNot(LispBuiltin *builtin, int function)
/*
 every predicate sequence &rest more-sequences
 some predicate sequence &rest more-sequences
 notevery predicate sequence &rest more-sequences
 notany predicate sequence &rest more-sequences
 */
d1107 12
a1118 17
    GC_ENTER();
    long i, j, length, count;
    LispObj *result, *list, *item, *arguments, *acons, *value;
    SeqInfo stk[8], *seqs;

    LispObj *predicate, *sequence, *more_sequences;

    more_sequences = ARGUMENT(2);
    sequence = ARGUMENT(1);
    predicate = ARGUMENT(0);

    count = 1;
    length = LispLength(sequence);
    for (list = more_sequences; CONSP(list); list = CDR(list), count++) {
	i = LispLength(CAR(list));
	if (i < length)
	    length = i;
d1120 2
d1123 5
a1127 38
    result = function == EVERY || function == NOTANY ? T : NIL;

    /* if at least one sequence has length zero */
    if (length == 0)
	return (result);

    if (count > sizeof(stk) / sizeof(stk[0]))
	seqs = LispMalloc(count * sizeof(SeqInfo));
    else
	seqs = &stk[0];

    /* build information about sequences */
    SETSEQ(seqs[0], sequence);
    for (i = 1, list = more_sequences; CONSP(list); list = CDR(list), i++) {
	item = CAR(list);
	SETSEQ(seqs[i], item);
    }

    /* prepare argument list */
    arguments = acons = CONS(NIL, NIL);
    GC_PROTECT(arguments);
    for (i = 1; i < count; i++) {
	RPLACD(acons, CONS(NIL, NIL));
	acons = CDR(acons);
    }

    /* loop applying predicate in sequence elements */
    for (i = 0; i < length; i++) {

	/* build argument list */
	for (acons = arguments, j = 0; j < count; acons = CDR(acons), j++) {
	    if (seqs[j].type == LispString_t)
		item = SCHAR(*seqs[j].data.string++);
	    else {
		item = CAR(seqs[j].data.list);
		seqs[j].data.list = CDR(seqs[j].data.list);
	    }
	    RPLACA(acons, item);
d1129 1
d1131 5
a1135 2
	/* apply predicate */
	value = APPLY(predicate, arguments);
d1137 7
a1143 11
	/* check if needs to terminate loop */
	if (value == NIL) {
	    if (function == EVERY) {
		result = NIL;
		break;
	    }
	    if (function == NOTEVERY) {
		result = T;
		break;
	    }
	}
d1145 13
a1157 8
	    if (function == SOME) {
		result = value;
		break;
	    }
	    if (function == NOTANY) {
		result = NIL;
		break;
	    }
d1161 4
a1164 3
    GC_LEAVE();
    if (seqs != &stk[0])
	LispFree(seqs);
d1166 154
a1319 2
    return (result);
}
d1322 1
a1322 4
Lisp_Every(LispBuiltin *builtin)
/*
 every predicate sequence &rest more-sequences
 */
d1324 18
a1341 1
    return (LispEverySomeAnyNot(builtin, EVERY));
d1345 1
a1345 4
Lisp_Some(LispBuiltin *builtin)
/*
 some predicate sequence &rest more-sequences
 */
d1347 7
a1353 1
    return (LispEverySomeAnyNot(builtin, SOME));
d1357 49
a1405 6
Lisp_Notevery(LispBuiltin *builtin)
/*
 notevery predicate sequence &rest more-sequences
 */
{
    return (LispEverySomeAnyNot(builtin, NOTEVERY));
d1409 1
a1409 4
Lisp_Notany(LispBuiltin *builtin)
/*
 notany predicate sequence &rest more-sequences
 */
d1411 1
a1411 1
    return (LispEverySomeAnyNot(builtin, NOTANY));
d1415 1
a1415 4
Lisp_Fboundp(LispBuiltin *builtin)
/*
 fboundp symbol
 */
d1417 1
a1417 1
    LispAtom *atom;
d1419 5
a1423 1
    LispObj *symbol = ARGUMENT(0);
d1425 5
a1429 1
    CHECK_SYMBOL(symbol);
d1431 2
a1432 3
    atom = symbol->data.atom;
    if (atom->a_function || atom->a_builtin || atom->a_compiled)
	return (T);
d1434 4
a1437 1
    return (NIL);
d1441 1
a1441 4
Lisp_Find(LispBuiltin *builtin)
/*
 find item sequence &key from-end test test-not start end key
 */
d1443 6
a1448 1
    return (LispFindOrPosition(builtin, FIND, NONE));
d1452 1
a1452 4
Lisp_FindIf(LispBuiltin *builtin)
/*
 find-if predicate sequence &key from-end start end key
 */
d1454 1
a1454 1
    return (LispFindOrPosition(builtin, FIND, IF));
d1458 1
a1458 4
Lisp_FindIfNot(LispBuiltin *builtin)
/*
 find-if-not predicate sequence &key from-end start end key
 */
d1460 1
a1460 1
    return (LispFindOrPosition(builtin, FIND, IFNOT));
d1464 1
a1464 4
Lisp_Fill(LispBuiltin *builtin)
/*
 fill sequence item &key start end
 */
d1466 1
a1466 1
    long i, start, end, length;
d1468 4
a1471 1
    LispObj *sequence, *item, *ostart, *oend;
d1473 5
a1477 20
    oend = ARGUMENT(3);
    ostart = ARGUMENT(2);
    item = ARGUMENT(1);
    sequence = ARGUMENT(0);

    LispCheckSequenceStartEnd(builtin, sequence, ostart, oend,
			      &start, &end, &length);

    if (STRINGP(sequence)) {
	int ch;
	char *string = THESTR(sequence);

	CHECK_STRING_WRITABLE(sequence);
	CHECK_SCHAR(item);
	ch = SCHAR_VALUE(item);
	for (i = start; i < end; i++)
	    string[i] = ch;
    }
    else {
	LispObj *list;
d1479 4
a1482 4
	if (CONSP(sequence))
	    list = sequence;
	else
	    list = sequence->data.array.list;
d1484 2
a1485 5
	for (i = 0; i < start; i++, list = CDR(list))
	    ;
	for (; i < end; i++, list = CDR(list))
	    RPLACA(list, item);
    }
d1487 1
a1487 1
    return (sequence);
d1491 1
a1491 4
Lisp_Fmakunbound(LispBuiltin *builtin)
/*
 fmkaunbound symbol
 */
d1493 1
a1493 1
    LispObj *symbol;
d1495 5
a1499 11
    symbol = ARGUMENT(0);

    CHECK_SYMBOL(symbol);
    if (symbol->data.atom->a_function)
	LispRemAtomFunctionProperty(symbol->data.atom);
    else if (symbol->data.atom->a_builtin)
	LispRemAtomBuiltinProperty(symbol->data.atom);
    else if (symbol->data.atom->a_compiled)
	LispRemAtomCompiledProperty(symbol->data.atom);

    return (symbol);
d1503 1
a1503 4
Lisp_Funcall(LispBuiltin *builtin)
/*
 funcall function &rest arguments
 */
d1505 1
a1505 1
    LispObj *result;
d1507 2
a1508 1
    LispObj *function, *arguments;
d1510 1
a1510 6
    arguments = ARGUMENT(1);
    function = ARGUMENT(0);

    result = APPLY(function, arguments);

    return (result);
d1514 1
a1514 4
Lisp_Functionp(LispBuiltin *builtin)
/*
 functionp object
 */
d1516 1
a1516 1
    LispObj *object;
d1518 7
a1524 1
    object = ARGUMENT(0);
d1526 1
a1526 1
    return (FUNCTIONP(object) || LAMBDAP(object) ? T : NIL);
d1530 1
a1530 4
Lisp_Get(LispBuiltin *builtin)
/*
 get symbol indicator &optional default
 */
d1532 2
a1533 1
    LispObj *result;
d1535 5
a1539 1
    LispObj *symbol, *indicator, *defalt;
d1541 3
a1543 3
    defalt = ARGUMENT(2);
    indicator = ARGUMENT(1);
    symbol = ARGUMENT(0);
d1545 2
a1546 1
    CHECK_SYMBOL(symbol);
d1548 4
a1551 1
    result = LispGetAtomProperty(symbol->data.atom, indicator);
d1553 3
a1555 2
    if (result != NIL)
	result = CAR(result);
d1557 1
a1557 1
	result = defalt == UNSPEC ? NIL : defalt;
d1559 3
a1561 1
    return (result);
a1563 3
/*
 * ext::getenv
 */
d1565 1
a1565 4
Lisp_Getenv(LispBuiltin *builtin)
/*
 getenv name
 */
d1567 1
a1567 1
    char *value;
d1569 5
a1573 1
    LispObj *name;
d1575 1
a1575 6
    name = ARGUMENT(0);

    CHECK_STRING(name);
    value = getenv(THESTR(name));

    return (value ? STRING(value) : NIL);
d1579 1
a1579 4
Lisp_Gc(LispBuiltin *builtin)
/*
 gc &optional car cdr
 */
d1581 1
a1581 1
    LispObj *car, *cdr;
d1583 8
a1590 2
    cdr = ARGUMENT(1);
    car = ARGUMENT(0);
d1592 1
a1592 3
    LispGC(car, cdr);

    return (NIL);
d1596 1
a1596 4
Lisp_Gensym(LispBuiltin *builtin)
/*
 gensym &optional arg
 */
d1598 1
a1598 19
    char *preffix = "G", name[132];
    long counter = LONGINT_VALUE(Ogensym_counter->data.atom->property->value);
    LispObj *symbol;

    LispObj *arg;

    arg = ARGUMENT(0);
    if (arg != UNSPEC) {
	if (STRINGP(arg))
	    preffix = THESTR(arg);
	else {
	    CHECK_INDEX(arg);
	    counter = FIXNUM_VALUE(arg);
	}
    }
    snprintf(name, sizeof(name), "%s%ld", preffix, counter);
    if (strlen(name) >= 128)
	LispDestroy("%s: name %s too long", STRFUN(builtin), name);
    Ogensym_counter->data.atom->property->value = INTEGER(counter + 1);
d1600 2
a1601 2
    symbol = UNINTERNED_ATOM(name);
    symbol->data.atom->unreadable = !LispCheckAtomString(name);
d1603 1
a1603 1
    return (symbol);
d1607 1
a1607 4
Lisp_Go(LispBuiltin *builtin)
/*
 go tag
 */
d1609 2
a1610 1
    unsigned blevel = lisp__data.block.block_level;
d1612 1
a1612 1
    LispObj *tag;
d1614 5
a1618 1
    tag = ARGUMENT(0);
d1620 27
a1646 10
    while (blevel) {
	LispBlock *block = lisp__data.block.block[--blevel];

	if (block->type == LispBlockClosure)
	    /* if reached a function call */
	    break;
	if (block->type == LispBlockBody) {
	    lisp__data.block.block_ret = tag;
	    LispBlockUnwind(block);
	    BLOCKJUMP(block);
d1648 2
a1649 1
     }
d1651 6
a1656 5
    LispDestroy("%s: no visible tagbody for %s",
		STRFUN(builtin), STROBJ(tag));
    /*NOTREACHED*/
    return (NIL);
}
d1658 1
a1658 7
LispObj *
Lisp_If(LispBuiltin *builtin)
/*
 if test then &optional else
 */
{
    LispObj *result, *test, *then, *oelse;
d1660 2
a1661 11
    oelse = ARGUMENT(2);
    then = ARGUMENT(1);
    test = ARGUMENT(0);

    test = EVAL(test);
    if (test != NIL)
	result = EVAL(then);
    else if (oelse != UNSPEC)
	result = EVAL(oelse);
    else
	result = NIL;
d1663 1
a1663 1
    return (result);
d1667 1
a1667 4
Lisp_IgnoreErrors(LispBuiltin *builtin)
/*
 ignore-erros &rest body
 */
d1669 4
a1672 3
    LispObj *result, **presult, **pbody;
    int i, jumped, *pjumped;
    LispBlock *block;
d1674 4
a1677 54
    /* interpreter state */
    GC_ENTER();
    int stack, lex, length;

    /* memory allocation */
    int mem_level;
    void **mem;

    LispObj *body;

    body = ARGUMENT(0);

    /* Save environment information */
    stack = lisp__data.stack.length;
    lex = lisp__data.env.lex;
    length = lisp__data.env.length;

    /* Save memory allocation information */
    mem_level = lisp__data.mem.level;
    mem = LispMalloc(mem_level * sizeof(void*));
    memcpy(mem, lisp__data.mem.mem, mem_level * sizeof(void*));

    ++lisp__data.ignore_errors;
    presult = &result;
    pjumped = &jumped;
    pbody = &body;
    result = NIL;
    jumped = 1;
    block = LispBeginBlock(NIL, LispBlockProtect);
    if (setjmp(block->jmp) == 0) {
	for (; CONSP(body); body = CDR(body))
	    result = EVAL(CAR(body));
	jumped = 0;
    }
    LispEndBlock(block);
    if (!lisp__data.destroyed && jumped)
	result = lisp__data.block.block_ret;

    if (lisp__data.destroyed) {
	/* Restore environment */
	lisp__data.stack.length = stack;
	lisp__data.env.lex = lex;
	lisp__data.env.head = lisp__data.env.length = length;
	GC_LEAVE();

	/* Check for possible leaks due to ignoring errors */
	for (i = 0; i < mem_level; i++) {
	    if (lisp__data.mem.mem[i] && mem[i] != lisp__data.mem.mem[i])
		LispFree(lisp__data.mem.mem[i]);
	}
	for (; i < lisp__data.mem.level; i++) {
	    if (lisp__data.mem.mem[i])
		LispFree(lisp__data.mem.mem[i]);
	}
d1679 5
a1683 4
	lisp__data.destroyed = 0;
	result = NIL;
	RETURN_COUNT = 1;
	RETURN(0) = lisp__data.error_condition;
a1684 2
    LispFree(mem);
    --lisp__data.ignore_errors;
d1686 1
a1686 1
    return (result);
d1690 1
a1690 4
Lisp_Intersection(LispBuiltin *builtin)
/*
 intersection list1 list2 &key test test-not key
 */
d1692 10
a1701 1
    return (LispListSet(builtin, INTERSECTION));
d1705 1
a1705 4
Lisp_Nintersection(LispBuiltin *builtin)
/*
 nintersection list1 list2 &key test test-not key
 */
d1707 1
a1707 1
    return (LispListSet(builtin, NINTERSECTION));
d1710 1
d1712 1
a1712 4
Lisp_Keywordp(LispBuiltin *builtin)
/*
 keywordp object
 */
d1714 1
a1714 1
    LispObj *object;
d1716 3
a1718 1
    object = ARGUMENT(0);
d1720 1
a1720 1
    return (KEYWORDP(object) ? T : NIL);
d1723 3
d1727 1
a1727 4
Lisp_Lambda(LispBuiltin *builtin)
/*
 lambda lambda-list &rest body
 */
d1729 2
a1730 3
    GC_ENTER();
    LispObj *name;
    LispArgList *alist;
d1732 2
a1733 1
    LispObj *lambda, *lambda_list, *body;
d1735 3
a1737 2
    body = ARGUMENT(1);
    lambda_list = ARGUMENT(0);
d1739 16
a1754 1
    alist = LispCheckArguments(LispLambda, lambda_list, Snil, 0);
d1756 12
a1767 7
    name = OPAQUE(alist, LispArgList_t);
    lambda_list = LispListProtectedArguments(alist);
    GC_PROTECT(name);
    GC_PROTECT(lambda_list);
    lambda = LispNewLambda(name, body, lambda_list, LispLambda);
    LispUseArgList(alist);
    GC_LEAVE();
d1769 2
a1770 2
    return (lambda);
}
d1772 2
a1773 8
LispObj *
Lisp_Last(LispBuiltin *builtin)
/*
 last list &optional count
 */
{
    long count, length;
    LispObj *list, *ocount;
d1775 3
a1777 2
    ocount = ARGUMENT(1);
    list = ARGUMENT(0);
d1779 2
a1780 2
    if (!CONSP(list))
	return (list);
d1782 2
a1783 1
    length = LispLength(list);
d1785 5
a1789 2
    if (ocount == UNSPEC)
	count = 1;
d1791 2
a1792 3
	CHECK_INDEX(ocount);
	count = FIXNUM_VALUE(ocount);
    }
d1794 4
a1797 2
    if (count >= length)
	return (list);
d1799 4
a1802 2308
    length -= count;
    for (; length > 0; length--)
	list = CDR(list);

    return (list);
}

LispObj *
Lisp_Length(LispBuiltin *builtin)
/*
 length sequence
 */
{
    LispObj *sequence;

    sequence = ARGUMENT(0);

    return (FIXNUM(LispLength(sequence)));
}

LispObj *
Lisp_Let(LispBuiltin *builtin)
/*
 let init &rest body
 */
{
    GC_ENTER();
    int head = lisp__data.env.length;
    LispObj *init, *body, *pair, *result, *list, *cons = NIL;

    body = ARGUMENT(1);
    init = ARGUMENT(0);

    CHECK_LIST(init);
    for (list = NIL; CONSP(init); init = CDR(init)) {
	LispObj *symbol, *value;

	pair = CAR(init);
	if (SYMBOLP(pair)) {
	    symbol = pair;
	    value = NIL;
	}
	else {
	    CHECK_CONS(pair);
	    symbol = CAR(pair);
	    CHECK_SYMBOL(symbol);
	    pair = CDR(pair);
	    if (CONSP(pair)) {
		value = CAR(pair);
		if (CDR(pair) != NIL)
		    LispDestroy("%s: too much arguments to initialize %s",
				STRFUN(builtin), STROBJ(symbol));
		value = EVAL(value);
	    }
	    else
		value = NIL;
	}
	pair = CONS(symbol, value);
	if (list == NIL) {
	    list = cons = CONS(pair, NIL);
	    GC_PROTECT(list);
	}
	else {
	    RPLACD(cons, CONS(pair, NIL));
	    cons = CDR(cons);
	}
    }
    /* Add variables */
    for (; CONSP(list); list = CDR(list)) {
	pair = CAR(list);
	CHECK_CONSTANT(CAR(pair));
	LispAddVar(CAR(pair), CDR(pair));
	++lisp__data.env.head;
    }
    /* Values of symbols are now protected */
    GC_LEAVE();

    /* execute body */
    for (result = NIL; CONSP(body); body = CDR(body))
	result = EVAL(CAR(body));

    lisp__data.env.head = lisp__data.env.length = head;

    return (result);
}

LispObj *
Lisp_LetP(LispBuiltin *builtin)
/*
 let* init &rest body
 */
{
    int head = lisp__data.env.length;
    LispObj *init, *body, *pair, *result;

    body = ARGUMENT(1);
    init = ARGUMENT(0);

    CHECK_LIST(init);
    for (; CONSP(init); init = CDR(init)) {
	LispObj *symbol, *value;

	pair = CAR(init);
	if (SYMBOLP(pair)) {
	    symbol = pair;
	    value = NIL;
	}
	else {
	    CHECK_CONS(pair);
	    symbol = CAR(pair);
	    CHECK_SYMBOL(symbol);
	    pair = CDR(pair);
	    if (CONSP(pair)) {
		value = CAR(pair);
		if (CDR(pair) != NIL)
		    LispDestroy("%s: too much arguments to initialize %s",
				STRFUN(builtin), STROBJ(symbol));
		value = EVAL(value);
	    }
	    else
		value = NIL;
	}

	CHECK_CONSTANT(symbol);
	LispAddVar(symbol, value);
	++lisp__data.env.head;
    }

    /* execute body */
    for (result = NIL; CONSP(body); body = CDR(body))
	result = EVAL(CAR(body));

    lisp__data.env.head = lisp__data.env.length = head;

    return (result);
}

LispObj *
Lisp_List(LispBuiltin *builtin)
/*
 list &rest args
 */
{
    LispObj *args;

    args = ARGUMENT(0);

    return (args);
}

LispObj *
Lisp_ListP(LispBuiltin *builtin)
/*
 list* object &rest more-objects
 */
{
    GC_ENTER();
    LispObj *result, *cons;

    LispObj *object, *more_objects;

    more_objects = ARGUMENT(1);
    object = ARGUMENT(0);

    if (!CONSP(more_objects))
	return (object);

    result = cons = CONS(object, CAR(more_objects));
    GC_PROTECT(result);
    for (more_objects = CDR(more_objects); CONSP(more_objects);
	 more_objects = CDR(more_objects)) {
	object = CAR(more_objects);
	RPLACD(cons, CONS(CDR(cons), object));
	cons = CDR(cons);
    }
    GC_LEAVE();

    return (result);
}

/* "classic" list-length */
LispObj *
Lisp_ListLength(LispBuiltin *builtin)
/*
 list-length list
 */
{
    long length;
    LispObj *fast, *slow;

    LispObj *list;

    list = ARGUMENT(0);

    CHECK_LIST(list);
    for (fast = slow = list, length = 0;
	 CONSP(slow);
	 slow = CDR(slow), length += 2) {
	if (fast == NIL)
	    break;
	CHECK_CONS(fast);
	fast = CDR(fast);
	if (fast == NIL) {
	    ++length;
	    break;
	}
	CHECK_CONS(fast);
	fast = CDR(fast);
	if (slow == fast)
	    /* circular list */
	    return (NIL);
    }

    return (FIXNUM(length));
}

LispObj *
Lisp_Listp(LispBuiltin *builtin)
/*
 listp object
 */
{
    LispObj *object;

    object = ARGUMENT(0);

    return (object == NIL || CONSP(object) ? T : NIL);
}

static LispObj *
LispListSet(LispBuiltin *builtin, int function)
/*
 intersection list1 list2 &key test test-not key
 nintersection list1 list2 &key test test-not key
 set-difference list1 list2 &key test test-not key
 nset-difference list1 list2 &key test test-not key
 set-exclusive-or list1 list2 &key test test-not key
 nset-exclusive-or list1 list2 &key test test-not key
 subsetp list1 list2 &key test test-not key
 union list1 list2 &key test test-not key
 nunion list1 list2 &key test test-not key
 */
{
    GC_ENTER();
    int code, expect, value, inplace, check_list2,
	intersection, setdifference, xunion, setexclusiveor;
    LispObj *lambda, *result, *cmp, *cmp1, *cmp2,
	    *item, *clist1, *clist2, *cons, *cdr;

    LispObj *list1, *list2, *test, *test_not, *key;

    key = ARGUMENT(4);
    test_not = ARGUMENT(3);
    test = ARGUMENT(2);
    list2 = ARGUMENT(1);
    list1 = ARGUMENT(0);

    /* Check if arguments are valid lists */
    CHECK_LIST(list1);
    CHECK_LIST(list2);

    setdifference = intersection = xunion = setexclusiveor = inplace = 0;
    switch (function) {
	case NSETDIFFERENCE:
	    inplace = 1;
	case SETDIFFERENCE:
	    setdifference = 1;
	    break;
	case NINTERSECTION:
	    inplace = 1;
	case INTERSECTION:
	    intersection = 1;
	    break;
	case NUNION:
	    inplace = 1;
	case UNION:
	    xunion = 1;
	    break;
	case NSETEXCLUSIVEOR:
	    inplace = 1;
	case SETEXCLUSIVEOR:
	    setexclusiveor = 1;
	    break;
    }

    /* Check for fast return */
    if (list1 == NIL)
	return (setdifference || intersection ?
		NIL : function == SUBSETP ? T : list2);
    if (list2 == NIL)
	return (intersection || xunion || function == SUBSETP ? NIL : list1);

    CHECK_TEST();
    clist1 = cdr = NIL;

    /* Make a copy of list2 with the key predicate applied */
    if (key != UNSPEC) {
	result = cons = CONS(APPLY1(key, CAR(list2)), NIL);
	GC_PROTECT(result);
	for (cmp2 = CDR(list2); CONSP(cmp2); cmp2 = CDR(cmp2)) {
	    item = APPLY1(key, CAR(cmp2));
	    RPLACD(cons, CONS(APPLY1(key, CAR(cmp2)), NIL));
	    cons = CDR(cons);
	}
	/* check if list2 is a proper list */
	CHECK_LIST(cmp2);
	clist2 = result;
	check_list2 = 0;
    }
    else {
	clist2 = list2;
	check_list2 = 1;
    }
    result = cons = NIL;

    /* Compare elements of lists
     * Logic:
     *	   UNION
     *		1) Walk list1 and if CAR(list1) not in list2, add it to result
     *		2) Add list2 to result
     *	   INTERSECTION
     *		1) Walk list1 and if CAR(list1) in list2, add it to result
     *	   SET-DIFFERENCE
     *		1) Walk list1 and if CAR(list1) not in list2, add it to result
     *	   SET-EXCLUSIVE-OR
     *		1) Walk list1 and if CAR(list1) not in list2, add it to result
     *		2) Walk list2 and if CAR(list2) not in list1, add it to result
     *	   SUBSETP
     *		1) Walk list1 and if CAR(list1) not in list2, return NIL
     *		2) Return T
     */
    value = 0;
    for (cmp1 = list1; CONSP(cmp1); cmp1 = CDR(cmp1)) {
	item = CAR(cmp1);

	/* Apply key predicate if required */
	if (key != UNSPEC) {
	    cmp = APPLY1(key, item);
	    if (setexclusiveor) {
		if (clist1 == NIL) {
		    clist1 = cdr = CONS(cmp, NIL);
		    GC_PROTECT(clist1);
		}
		else {
		    RPLACD(cdr, CONS(cmp, NIL));
		    cdr = CDR(cdr);
		}
	    }
	}
	else
	    cmp = item;

	/* Compare against list2 */
	for (cmp2 = clist2; CONSP(cmp2); cmp2 = CDR(cmp2)) {
	    value = FCOMPARE(lambda, cmp, CAR(cmp2), code);
	    if (value == expect)
		break;
	}
	if (check_list2 && value != expect) {
	    /* check if list2 is a proper list */
	    CHECK_LIST(cmp2);
	    check_list2 = 0;
	}

	if (function == SUBSETP) {
	    /* Element of list1 not in list2? */
	    if (value != expect) {
		GC_LEAVE();

		return (NIL);
	    }
	}
	/* If need to add item to result */
	else if (((setdifference || xunion || setexclusiveor) &&
		  value != expect) ||
		 (intersection && value == expect)) {
	    if (inplace) {
		if (result == NIL)
		    result = cons = cmp1;
		else {
		    if (setexclusiveor) {
			/* don't remove elements yet, will need
			 * to check agains't list2 later */
			for (cmp2 = cons; CDR(cmp2) != cmp1; cmp2 = CDR(cmp2))
			    ;
			if (cmp2 != cons) {
			    RPLACD(cmp2, list1);
			    list1 = cmp2;
			}
		    }
		    RPLACD(cons, cmp1);
		    cons = cmp1;
		}
	    }
	    else {
		if (result == NIL) {
		    result = cons = CONS(item, NIL);
		    GC_PROTECT(result);
		}
		else {
		    RPLACD(cons, CONS(item, NIL));
		    cons = CDR(cons);
		}
	    }
	}
    }
    /* check if list1 is a proper list */
    CHECK_LIST(cmp1);

    if (function == SUBSETP) {
	GC_LEAVE();

	return (T);
    }
    else if (xunion) {
	/* Add list2 to tail of result */
	if (result == NIL)
	    result = list2;
	else
	    RPLACD(cons, list2);
    }
    else if (setexclusiveor) {
	LispObj *result2, *cons2;

	result2 = cons2 = NIL;
	for (cmp2 = list2; CONSP(cmp2); cmp2 = CDR(cmp2)) {
	    item = CAR(cmp2);

	    if (key != UNSPEC) {
		cmp = CAR(clist2);
		/* XXX changing clist2 */
		clist2 = CDR(clist2);
		cmp1 = clist1;
	    }
	    else {
		cmp = item;
		cmp1 = list1;
	    }

	    /* Compare against list1 */
	    for (; CONSP(cmp1); cmp1 = CDR(cmp1)) {
		value = FCOMPARE(lambda, cmp, CAR(cmp1), code);
		if (value == expect)
		    break;
	    }

	    if (value != expect) {
		if (inplace) {
		    if (result2 == NIL)
			result2 = cons2 = cmp2;
		    else {
			RPLACD(cons2, cmp2);
			cons2 = cmp2;
		    }
		}
		else {
		    if (result == NIL) {
			result = cons = CONS(item, NIL);
			GC_PROTECT(result);
		    }
		    else {
			RPLACD(cons, CONS(item, NIL));
			cons = CDR(cons);
		    }
		}
	    }
	}
	if (inplace) {
	    if (CONSP(cons2))
		RPLACD(cons2, NIL);
	    if (result == NIL)
		result = result2;
	    else
		RPLACD(cons, result2);
	}
    }
    else if ((function == NSETDIFFERENCE || function == NINTERSECTION) &&
	     CONSP(cons))
	RPLACD(cons, NIL);

    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_Loop(LispBuiltin *builtin)
/*
 loop &rest body
 */
{
    LispObj *code, *result;
    LispBlock *block;

    LispObj *body;

    body = ARGUMENT(0);

    result = NIL;
    block = LispBeginBlock(NIL, LispBlockTag);
    if (setjmp(block->jmp) == 0) {
	for (;;)
	    for (code = body; CONSP(code); code = CDR(code))
		(void)EVAL(CAR(code));
    }
    LispEndBlock(block);
    result = lisp__data.block.block_ret;

    return (result);
}

/* XXX This function is broken, needs a review
 (being delayed until true array/vectors be implemented) */
LispObj *
Lisp_MakeArray(LispBuiltin *builtin)
/*
 make-array dimensions &key element-type initial-element initial-contents
			    adjustable fill-pointer displaced-to
			    displaced-index-offset
 */
{
    long rank = 0, count = 1, offset, zero, c;
    LispObj *obj, *dim, *array;
    LispType type;

    LispObj *dimensions, *element_type, *initial_element, *initial_contents,
	    *adjustable, *fill_pointer, *displaced_to,
	    *displaced_index_offset;

    dim = array = NIL;
    type = LispNil_t;

    displaced_index_offset = ARGUMENT(7);
    displaced_to = ARGUMENT(6);
    fill_pointer = ARGUMENT(5);
    adjustable = ARGUMENT(4);
    initial_contents = ARGUMENT(3);
    initial_element = ARGUMENT(2);
    element_type = ARGUMENT(1);
    dimensions = ARGUMENT(0);

    if (INDEXP(dimensions)) {
	dim = CONS(dimensions, NIL);
	rank = 1;
	count = FIXNUM_VALUE(dimensions);
    }
    else if (CONSP(dimensions)) {
	dim = dimensions;

	for (rank = 0; CONSP(dim); rank++, dim = CDR(dim)) {
	    obj = CAR(dim);
	    CHECK_INDEX(obj);
	    count *= FIXNUM_VALUE(obj);
	}
	dim = dimensions;
    }
    else if (dimensions == NIL) {
	dim = NIL;
	rank = count = 0;
    }
    else
	LispDestroy("%s: %s is a bad array dimension",
		    STRFUN(builtin), STROBJ(dimensions));

    /* check element-type */
    if (element_type != UNSPEC) {
	if (element_type == T)
	    type = LispNil_t;
	else if (!SYMBOLP(element_type))
	    LispDestroy("%s: unsupported element type %s",
			STRFUN(builtin), STROBJ(element_type));
	else {
	    Atom_id atom = ATOMID(element_type);

	    if (atom == Satom)
		type = LispAtom_t;
	    else if (atom == Sinteger)
		type = LispInteger_t;
	    else if (atom == Scharacter)
		type = LispSChar_t;
	    else if (atom == Sstring)
		type = LispString_t;
	    else if (atom == Slist)
		type = LispCons_t;
	    else if (atom == Sopaque)
		type = LispOpaque_t;
	    else
		LispDestroy("%s: unsupported element type %s",
			    STRFUN(builtin), ATOMID(element_type));
	}
    }

    /* check initial-contents */
    if (rank) {
	CHECK_LIST(initial_contents);
    }

    /* check displaced-to */
    if (displaced_to != UNSPEC) {
	CHECK_ARRAY(displaced_to);
    }

    /* check displaced-index-offset */
    offset = -1;
    if (displaced_index_offset != UNSPEC) {
	CHECK_INDEX(displaced_index_offset);
	offset = FIXNUM_VALUE(displaced_index_offset);
    }

    c = 0;
    if (initial_element != UNSPEC)
	++c;
    if (initial_contents != UNSPEC)
	++c;
    if (displaced_to != UNSPEC || offset >= 0)
	++c;
    if (c > 1)
	LispDestroy("%s: more than one initialization specified",
		    STRFUN(builtin));
    if (initial_element == UNSPEC)
	initial_element = NIL;

    zero = count == 0;
    if (displaced_to != UNSPEC) {
	CHECK_ARRAY(displaced_to);
	if (offset < 0)
	    offset = 0;
	for (c = 1, obj = displaced_to->data.array.dim; obj != NIL;
	     obj = CDR(obj))
	    c *= FIXNUM_VALUE(CAR(obj));
	if (c < count + offset)
	    LispDestroy("%s: array-total-size + displaced-index-offset "
			"exceeds total size", STRFUN(builtin));
	for (c = 0, array = displaced_to->data.array.list; c < offset; c++)
	    array = CDR(array);
    }
    else if (initial_contents != UNSPEC) {
	CHECK_CONS(initial_contents);
	if (rank == 0)
	    array = initial_contents;
	else if (rank == 1) {
	    for (array = initial_contents, c = 0; c < count;
		 array = CDR(array), c++)
		if (!CONSP(array))
		    LispDestroy("%s: bad argument or size %s",
				STRFUN(builtin), STROBJ(array));
	    if (array != NIL)
		LispDestroy("%s: bad argument or size %s",
			    STRFUN(builtin), STROBJ(array));
	    array = initial_contents;
	}
	else {
	    LispObj *err = NIL;
	    /* check if list matches */
	    int i, j, k, *dims, *loop;

	    /* create iteration variables */
	    dims = LispMalloc(sizeof(int) * rank);
	    loop = LispCalloc(1, sizeof(int) * (rank - 1));
	    for (i = 0, obj = dim; CONSP(obj); i++, obj = CDR(obj))
		dims[i] = FIXNUM_VALUE(CAR(obj));

	    /* check if list matches specified dimensions */
	    while (loop[0] < dims[0]) {
		for (obj = initial_contents, i = 0; i < rank - 1; i++) {
		    for (j = 0; j < loop[i]; j++)
			obj = CDR(obj);
		    err = obj;
		    if (!CONSP(obj = CAR(obj)))
			goto make_array_error;
		    err = obj;
		}
		--i;
		for (;;) {
		    ++loop[i];
		    if (i && loop[i] >= dims[i])
			loop[i] = 0;
		    else
			break;
		    --i;
		}
		for (k = 0; k < dims[rank - 1]; obj = CDR(obj), k++) {
		    if (!CONSP(obj))
			goto make_array_error;
		}
		if (obj == NIL)
		    continue;
make_array_error:
		LispFree(dims);
		LispFree(loop);
		LispDestroy("%s: bad argument or size %s",
			    STRFUN(builtin), STROBJ(err));
	    }

	    /* list is correct, use it to fill initial values */

	    /* reset loop */
	    memset(loop, 0, sizeof(int) * (rank - 1));

	    GCDisable();
	    /* fill array with supplied values */
	    array = NIL;
	    while (loop[0] < dims[0]) {
		for (obj = initial_contents, i = 0; i < rank - 1; i++) {
		    for (j = 0; j < loop[i]; j++)
			obj = CDR(obj);
		    obj = CAR(obj);
		}
		--i;
		for (;;) {
		    ++loop[i];
		    if (i && loop[i] >= dims[i])
			loop[i] = 0;
		    else
			break;
		    --i;
		}
		for (k = 0; k < dims[rank - 1]; obj = CDR(obj), k++) {
		    if (array == NIL)
			array = CONS(CAR(obj), NIL);
		    else {
			RPLACD(array, CONS(CAR(array), CDR(array)));
			RPLACA(array, CAR(obj));
		    }
		}
	    }
	    LispFree(dims);
	    LispFree(loop);
	    array = LispReverse(array);
	    GCEnable();
	}
    }
    else {
	GCDisable();
	/* allocate array */
	if (count) {
	    --count;
	    array = CONS(initial_element, NIL);
	    while (count) {
		RPLACD(array, CONS(CAR(array), CDR(array)));
		RPLACA(array, initial_element);
		count--;
	    }
	}
	GCEnable();
    }

    obj = LispNew(array, dim);
    obj->type = LispArray_t;
    obj->data.array.list = array;
    obj->data.array.dim = dim;
    obj->data.array.rank = rank;
    obj->data.array.type = type;
    obj->data.array.zero = zero;

    return (obj);
}

LispObj *
Lisp_MakeList(LispBuiltin *builtin)
/*
 make-list size &key initial-element
 */
{
    GC_ENTER();
    long count;
    LispObj *result, *cons;

    LispObj *size, *initial_element;

    initial_element = ARGUMENT(1);
    size = ARGUMENT(0);

    CHECK_INDEX(size);
    count = FIXNUM_VALUE(size);

    if (count == 0)
	return (NIL);
    if (initial_element == UNSPEC)
	initial_element = NIL;

    result = cons = CONS(initial_element, NIL);
    GC_PROTECT(result);
    for (; count > 1; count--) {
	RPLACD(cons, CONS(initial_element, NIL));
	cons = CDR(cons);
    }
    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_MakeSymbol(LispBuiltin *builtin)
/*
 make-symbol name
 */
{
    LispObj *name, *symbol;

    name = ARGUMENT(0);
    CHECK_STRING(name);

    symbol = UNINTERNED_ATOM(THESTR(name));
    symbol->data.atom->unreadable = !LispCheckAtomString(THESTR(name));

    return (symbol);
}

LispObj *
Lisp_Makunbound(LispBuiltin *builtin)
/*
 makunbound symbol
 */
{
    LispObj *symbol;

    symbol = ARGUMENT(0);

    CHECK_SYMBOL(symbol);
    LispUnsetVar(symbol);

    return (symbol);
}

LispObj *
Lisp_Mapc(LispBuiltin *builtin)
/*
 mapc function list &rest more-lists
 */
{
    return (LispMapc(builtin, 0));
}

LispObj *
Lisp_Mapcar(LispBuiltin *builtin)
/*
 mapcar function list &rest more-lists
 */
{
    return (LispMapc(builtin, 1));
}

/* Like nconc but ignore non list arguments */
LispObj *
LispMapnconc(LispObj *list)
{
    LispObj *result = NIL;

    if (CONSP(list)) {
	LispObj *cons, *head, *tail;

	cons = NIL;
	for (; CONSP(CDR(list)); list = CDR(list)) {
	    head = CAR(list);
	    if (CONSP(head)) {
		for (tail = head; CONSP(CDR(tail)); tail = CDR(tail))
		    ;
		if (cons != NIL)
		    RPLACD(cons, head);
		else
		    result = head;
		cons = tail;
	    }
	}
	head = CAR(list);
	if (CONSP(head)) {
	    if (cons != NIL)
		RPLACD(cons, head);
	    else
		result = head;
	}
    }

    return (result);
}

LispObj *
Lisp_Mapcan(LispBuiltin *builtin)
/*
 mapcan function list &rest more-lists
 */
{
    return (LispMapnconc(LispMapc(builtin, 1)));
}

static LispObj *
LispMapc(LispBuiltin *builtin, int mapcar)
{
    GC_ENTER();
    long i, offset, count, length;
    LispObj *result = NIL, *cons, *arguments, *acons, *rest, *alist, *value;
    LispObj *stk[8], **cdrs;

    LispObj *function, *list, *more_lists;

    more_lists = ARGUMENT(2);
    list = ARGUMENT(1);
    function = ARGUMENT(0);

    /* Result will be no longer than this */
    for (length = 0, alist = list; CONSP(alist); length++, alist = CDR(alist))
	;

    /* If first argument is not a list... */
    if (length == 0)
	return (NIL);

    /* At least one argument will be passed to function, count how many
     * extra arguments will be used, and calculate result length. */
    count = 0;
    for (rest = more_lists; CONSP(rest); rest = CDR(rest), count++) {

	/* Check if extra list is really a list, and if it is smaller
	 * than the first list */
	for (i = 0, alist = CAR(rest);
	     i < length && CONSP(alist);
	     i++, alist = CDR(alist))
	    ;

	/* If it is not a true list */
	if (i == 0)
	    return (NIL);

	/* If it is smaller than the currently calculated result length */
	if (i < length)
	    length = i;
    }

    if (mapcar) {
	/* Initialize gc protected object cells for resulting list */
	result = cons = CONS(NIL, NIL);
	GC_PROTECT(result);
    }
    else
	result = cons = list;

    if (count >= sizeof(stk) / sizeof(stk[0]))
	cdrs = LispMalloc(count * sizeof(LispObj*));
    else
	cdrs = &stk[0];
    for (i = 0, rest = more_lists; i < count; i++, rest = CDR(rest))
	cdrs[i] = CAR(rest);

    /* Initialize gc protected object cells for argument list */
    arguments = acons = CONS(NIL, NIL);
    GC_PROTECT(arguments);

    /* Allocate space for extra arguments */
    for (i = 0; i < count; i++) {
	RPLACD(acons, CONS(NIL, NIL));
	acons = CDR(acons);
    }

    /* For every element of the list that will be used */
    for (offset = 0;; list = CDR(list)) {
	acons = arguments;

	/* Add first argument */
	RPLACA(acons, CAR(list));
	acons = CDR(acons);

	/* For every extra list argument */
	for (i = 0; i < count; i++) {
	    alist = cdrs[i];
	    cdrs[i] = CDR(cdrs[i]);

	    /* Add element to argument list */
	    RPLACA(acons, CAR(alist));
	    acons = CDR(acons);
	}

	value = APPLY(function, arguments);

	if (mapcar) {
	    /* Store result */
	    RPLACA(cons, value);

	    /* Allocate new result cell */
	    if (++offset < length) {
		RPLACD(cons, CONS(NIL, NIL));
		cons = CDR(cons);
	    }
	    else
		break;
	}
	else if (++offset >= length)
	    break;
    }

    /* Unprotect argument and result list */
    GC_LEAVE();
    if (cdrs != &stk[0])
	LispFree(cdrs);

    return (result);
}

static LispObj *
LispMapl(LispBuiltin *builtin, int maplist)
{
    GC_ENTER();
    long i, offset, count, length;
    LispObj *result = NIL, *cons, *arguments, *acons, *rest, *alist, *value;
    LispObj *stk[8], **cdrs;

    LispObj *function, *list, *more_lists;

    more_lists = ARGUMENT(2);
    list = ARGUMENT(1);
    function = ARGUMENT(0);

    /* count is the number of lists, length is the length of the result */
    for (length = 0, alist = list; CONSP(alist); length++, alist = CDR(alist))
	;

    /* first argument is not a list */
    if (length == 0)
	return (NIL);

    /* check remaining arguments */
    for (count = 0, rest = more_lists; CONSP(rest); rest = CDR(rest), count++) {
	for (i = 0, alist = CAR(rest);
	     i < length && CONSP(alist);
	     i++, alist = CDR(alist))
	    ;
	/* argument is not a list */
	if (i == 0)
	    return (NIL);
	/* result will have the length of the smallest list */
	if (i < length)
	    length = i;
    }

    /* result will be a list */
    if (maplist) {
	result = cons = CONS(NIL, NIL);
	GC_PROTECT(result);
    }
    else
	result = cons = list;

    if (count >= sizeof(stk) / sizeof(stk[0]))
	cdrs = LispMalloc(count * sizeof(LispObj*));
    else
	cdrs = &stk[0];
    for (i = 0, rest = more_lists; i < count; i++, rest = CDR(rest))
	cdrs[i] = CAR(rest);

    /* initialize argument list */
    arguments = acons = CONS(NIL, NIL);
    GC_PROTECT(arguments);
    for (i = 0; i < count; i++) {
	RPLACD(acons, CONS(NIL, NIL));
	acons = CDR(acons);
    }

    /* for every used list element */
    for (offset = 0;; list = CDR(list)) {
	acons = arguments;

	/* first argument */
	RPLACA(acons, list);
	acons = CDR(acons);

	/* for every extra list */
	for (i = 0; i < count; i++) {
	    RPLACA(acons, cdrs[i]);
	    cdrs[i] = CDR(cdrs[i]);
	    acons = CDR(acons);
	}

	value = APPLY(function, arguments);

	if (maplist) {
	    /* store result */
	    RPLACA(cons, value);

	    /* allocate new cell */
	    if (++offset < length) {
		RPLACD(cons, CONS(NIL, NIL));
		cons = CDR(cons);
	    }
	    else
		break;
	}
	else if (++offset >= length)
	    break;
    }

    GC_LEAVE();
    if (cdrs != &stk[0])
	LispFree(cdrs);

    return (result);
}

LispObj *
Lisp_Mapl(LispBuiltin *builtin)
/*
 mapl function list &rest more-lists
 */
{
    return (LispMapl(builtin, 0));
}

LispObj *
Lisp_Maplist(LispBuiltin *builtin)
/*
 maplist function list &rest more-lists
 */
{
    return (LispMapl(builtin, 1));
}

LispObj *
Lisp_Mapcon(LispBuiltin *builtin)
/*
 mapcon function list &rest more-lists
 */
{
    return (LispMapnconc(LispMapl(builtin, 1)));
}

LispObj *
Lisp_Member(LispBuiltin *builtin)
/*
 member item list &key test test-not key
 */
{
    int code, expect;
    LispObj *compare, *lambda;
    LispObj *item, *list, *test, *test_not, *key;

    key = ARGUMENT(4);
    test_not = ARGUMENT(3);
    test = ARGUMENT(2);
    list = ARGUMENT(1);
    item = ARGUMENT(0);

    if (list == NIL)
	return (NIL);
    CHECK_CONS(list);

    CHECK_TEST();
    if (key == UNSPEC) {
	if (code == FEQ) {
	    for (; CONSP(list); list = CDR(list))
		if (item == CAR(list))
		    return (list);
	}
	else {
	    for (; CONSP(list); list = CDR(list))
		if (FCOMPARE(lambda, item, CAR(list), code) == expect)
		    return (list);
	}
    }
    else {
	if (code == FEQ) {
	    for (; CONSP(list); list = CDR(list))
		if (item == APPLY1(key, CAR(list)))
		    return (list);
	}
	else {
	    for (; CONSP(list); list = CDR(list)) {
		compare = APPLY1(key, CAR(list));
		if (FCOMPARE(lambda, item, compare, code) == expect)
		    return (list);
	    }
	}
    }
    /* check if is a proper list */
    CHECK_LIST(list);

    return (NIL);
}

LispObj *
Lisp_MemberIf(LispBuiltin *builtin)
/*
 member-if predicate list &key key
 */
{
    return (LispAssocOrMember(builtin, MEMBER, IF));
}

LispObj *
Lisp_MemberIfNot(LispBuiltin *builtin)
/*
 member-if-not predicate list &key key
 */
{
    return (LispAssocOrMember(builtin, MEMBER, IFNOT));
}

LispObj *
Lisp_MultipleValueBind(LispBuiltin *builtin)
/*
 multiple-value-bind symbols values &rest body
 */
{
    int i, head = lisp__data.env.length;
    LispObj *result, *symbol, *value;

    LispObj *symbols, *values, *body;

    body = ARGUMENT(2);
    values = ARGUMENT(1);
    symbols = ARGUMENT(0);

    result = EVAL(values);
    for (i = -1; CONSP(symbols); symbols = CDR(symbols), i++) {
	symbol = CAR(symbols);
	CHECK_SYMBOL(symbol);
	CHECK_CONSTANT(symbol);
	if (i >= 0 && i < RETURN_COUNT)
	    value = RETURN(i);
	else if (i < 0)
	    value = result;
	else
	    value = NIL;
	LispAddVar(symbol, value);
	++lisp__data.env.head;
    }

    /* Execute code with binded variables (if any) */
    for (result = NIL; CONSP(body); body = CDR(body))
	result = EVAL(CAR(body));

    lisp__data.env.head = lisp__data.env.length = head;

    return (result);
}

LispObj *
Lisp_MultipleValueCall(LispBuiltin *builtin)
/*
 multiple-value-call function &rest form
 */
{
    GC_ENTER();
    int i;
    LispObj *arguments, *cons, *result;

    LispObj *function, *form;

    form = ARGUMENT(1);
    function = ARGUMENT(0);

    /* build argument list */
    arguments = cons = NIL;
    for (; CONSP(form); form = CDR(form)) {
	RETURN_COUNT = 0;
	result = EVAL(CAR(form));
	if (RETURN_COUNT >= 0) {
	    if (arguments == NIL) {
		arguments = cons = CONS(result, NIL);
		GC_PROTECT(arguments);
	    }
	    else {
		RPLACD(cons, CONS(result, NIL));
		cons = CDR(cons);
	    }
	    for (i = 0; i < RETURN_COUNT; i++) {
		RPLACD(cons, CONS(RETURN(i), NIL));
		cons = CDR(cons);
	    }
	}
    }

    /* apply function */
    if (POINTERP(function) && !XSYMBOLP(function) && !XFUNCTIONP(function)) {
	function = EVAL(function);
	GC_PROTECT(function);
    }
    result = APPLY(function, arguments);
    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_MultipleValueProg1(LispBuiltin *builtin)
/*
 multiple-value-prog1 first-form &rest form
 */
{
    GC_ENTER();
    int i, count;
    LispObj *values, *cons;

    LispObj *first_form, *form;

    form = ARGUMENT(1);
    first_form = ARGUMENT(0);

    values = EVAL(first_form);
    if (!CONSP(form))
	return (values);

    cons = NIL;
    count = RETURN_COUNT;
    if (count < 0)
	values = NIL;
    else if (count == 0) {
	GC_PROTECT(values);
    }
    else {
	values = cons = CONS(values, NIL);
	GC_PROTECT(values);
	for (i = 0; i < count; i++) {
	    RPLACD(cons, CONS(RETURN(i), NIL));
	    cons = CDR(cons);
	}
    }

    for (; CONSP(form); form = CDR(form))
	EVAL(CAR(form));

    RETURN_COUNT = count;
    if (count > 0) {
	for (i = 0, cons = CDR(values); CONSP(cons); cons = CDR(cons), i++)
	    RETURN(i) = CAR(cons);
	values = CAR(values);
    }
    GC_LEAVE();

    return (values);
}

LispObj *
Lisp_MultipleValueList(LispBuiltin *builtin)
/*
 multiple-value-list form
 */
{
    int i;
    GC_ENTER();
    LispObj *form, *result, *cons;

    form = ARGUMENT(0);

    result = EVAL(form);

    if (RETURN_COUNT < 0)
	return (NIL);

    result = cons = CONS(result, NIL);
    GC_PROTECT(result);
    for (i = 0; i < RETURN_COUNT; i++) {
	RPLACD(cons, CONS(RETURN(i), NIL));
	cons = CDR(cons);
    }
    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_MultipleValueSetq(LispBuiltin *builtin)
/*
 multiple-value-setq symbols form
 */
{
    int i;
    LispObj *result, *symbol, *value;

    LispObj *symbols, *form;

    form = ARGUMENT(1);
    symbols = ARGUMENT(0);

    CHECK_LIST(symbols);
    result = EVAL(form);
    if (CONSP(symbols)) {
	symbol = CAR(symbols);
	CHECK_SYMBOL(symbol);
	CHECK_CONSTANT(symbol);
	LispSetVar(symbol, result);
	symbols = CDR(symbols);
    }
    for (i = 0; CONSP(symbols); symbols = CDR(symbols), i++) {
	symbol = CAR(symbols);
	CHECK_SYMBOL(symbol);
	CHECK_CONSTANT(symbol);
	if (i < RETURN_COUNT && RETURN_COUNT > 0)
	    value = RETURN(i);
	else
	    value = NIL;
	LispSetVar(symbol, value);
    }

    return (result);
}

LispObj *
Lisp_Nconc(LispBuiltin *builtin)
/*
 nconc &rest lists
 */
{
    LispObj *list, *lists, *cons, *head, *tail;

    lists = ARGUMENT(0);

    /* skip any initial empty lists */
    for (; CONSP(lists); lists = CDR(lists))
	if (CAR(lists) != NIL)
	    break;

    /* don't check if a proper list */
    if (!CONSP(lists))
	return (lists);

    /* setup to concatenate lists */
    list = CAR(lists);
    CHECK_CONS(list);
    for (cons = list; CONSP(CDR(cons)); cons = CDR(cons))
	;

    /* if only two lists */
    lists = CDR(lists);
    if (!CONSP(lists)) {
	RPLACD(cons, lists);

	return (list);
    }

    /* concatenate */
    for (; CONSP(CDR(lists)); lists = CDR(lists)) {
	head = CAR(lists);
	if (head == NIL)
	    continue;
	CHECK_CONS(head);
	for (tail = head; CONSP(CDR(tail)); tail = CDR(tail))
	    ;
	RPLACD(cons, head);
	cons = tail;
    }
    /* add last list */
    RPLACD(cons, CAR(lists));

    return (list);
}

LispObj *
Lisp_Nreverse(LispBuiltin *builtin)
/*
 nreverse sequence
 */
{
    return (LispXReverse(builtin, 1));
}

LispObj *
Lisp_NsetDifference(LispBuiltin *builtin)
/*
 nset-difference list1 list2 &key test test-not key
 */
{
    return (LispListSet(builtin, NSETDIFFERENCE));
}

LispObj *
Lisp_Nsubstitute(LispBuiltin *builtin)
/*
 nsubstitute newitem olditem sequence &key from-end test test-not start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, NSUBSTITUTE, NONE));
}

LispObj *
Lisp_NsubstituteIf(LispBuiltin *builtin)
/*
 nsubstitute-if newitem test sequence &key from-end start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, NSUBSTITUTE, IF));
}

LispObj *
Lisp_NsubstituteIfNot(LispBuiltin *builtin)
/*
 nsubstitute-if-not newitem test sequence &key from-end start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, NSUBSTITUTE, IFNOT));
}

LispObj *
Lisp_Nth(LispBuiltin *builtin)
/*
 nth index list
 */
{
    long position;
    LispObj *oindex, *list;

    list = ARGUMENT(1);
    oindex = ARGUMENT(0);

    CHECK_INDEX(oindex);
    position = FIXNUM_VALUE(oindex);

    if (list == NIL)
	return (NIL);

    CHECK_CONS(list);
    for (; position > 0; position--) {
	if (!CONSP(list))
	    return (NIL);
	list = CDR(list);
    }

    return (CONSP(list) ? CAR(list) : NIL);
}

LispObj *
Lisp_Nthcdr(LispBuiltin *builtin)
/*
 nthcdr index list
 */
{
    long position;
    LispObj *oindex, *list;

    list = ARGUMENT(1);
    oindex = ARGUMENT(0);

    CHECK_INDEX(oindex);
    position = FIXNUM_VALUE(oindex);

    if (list == NIL)
	return (NIL);
    CHECK_CONS(list);

    for (; position > 0; position--) {
	if (!CONSP(list))
	    return (NIL);
	list = CDR(list);
    }

    return (list);
}

LispObj *
Lisp_NthValue(LispBuiltin *builtin)
/*
 nth-value index form
 */
{
    long i;
    LispObj *oindex, *form, *result;

    form = ARGUMENT(1);
    oindex = ARGUMENT(0);

    oindex = EVAL(oindex);
    CHECK_INDEX(oindex);
    i = FIXNUM_VALUE(oindex) - 1;

    result = EVAL(form);
    if (RETURN_COUNT < 0 || i >= RETURN_COUNT)
	result = NIL;
    else if (i >= 0)
	result = RETURN(i);

    return (result);
}

LispObj *
Lisp_Null(LispBuiltin *builtin)
/*
 null list
 */
{
    LispObj *list;

    list = ARGUMENT(0);

    return (list == NIL ? T : NIL);
}

LispObj *
Lisp_Or(LispBuiltin *builtin)
/*
 or &rest args
 */
{
    LispObj *result = NIL, *args;

    args = ARGUMENT(0);

    for (; CONSP(args); args = CDR(args)) {
	result = EVAL(CAR(args));
	if (result != NIL)
	    break;
    }

    return (result);
}

LispObj *
Lisp_Pairlis(LispBuiltin *builtin)
/*
 pairlis key data &optional alist
 */
{
    LispObj *result, *cons;

    LispObj *key, *data, *alist;

    alist = ARGUMENT(2);
    data = ARGUMENT(1);
    key = ARGUMENT(0);

    if (CONSP(key) && CONSP(data)) {
	GC_ENTER();

	result = cons = CONS(CONS(CAR(key), CAR(data)), NIL);
	GC_PROTECT(result);
	key = CDR(key);
	data = CDR(data);
	for (; CONSP(key) && CONSP(data); key = CDR(key), data = CDR(data)) {
	    RPLACD(cons, CONS(CONS(CAR(key), CAR(data)), NIL));
	    cons = CDR(cons);
	}
	if (CONSP(key) || CONSP(data))
	    LispDestroy("%s: different length lists", STRFUN(builtin));
	GC_LEAVE();
	if (alist != UNSPEC)
	    RPLACD(cons, alist);
    }
    else
	result = alist == UNSPEC ? NIL : alist;

    return (result);
}

static LispObj *
LispFindOrPosition(LispBuiltin *builtin,
		   int function, int comparison)
/*
 find item sequence &key from-end test test-not start end key
 find-if predicate sequence &key from-end start end key
 find-if-not predicate sequence &key from-end start end key
 position item sequence &key from-end test test-not start end key
 position-if predicate sequence &key from-end start end key
 position-if-not predicate sequence &key from-end start end key
 */
{
    int code = 0, istring, expect, value;
    char *string = NULL;
    long offset = -1, start, end, length, i = comparison == NONE ? 7 : 5;
    LispObj *cmp, *element, **objects = NULL;

    LispObj *item, *predicate, *sequence, *from_end,
	    *test, *test_not, *ostart, *oend, *key;

    key = ARGUMENT(i);		--i;
    oend = ARGUMENT(i);		--i;
    ostart = ARGUMENT(i);	--i;
    if (comparison == NONE) {
	test_not = ARGUMENT(i);	--i;
	test = ARGUMENT(i);	--i;
    }
    else
	test_not = test = UNSPEC;
    from_end = ARGUMENT(i);	--i;
    if (from_end == UNSPEC)
	from_end = NIL;
    sequence = ARGUMENT(i);	--i;
    if (comparison == NONE) {
	item = ARGUMENT(i);
	predicate = Oeql;
    }
    else {
	predicate = ARGUMENT(i);
	item = NIL;
    }

    LispCheckSequenceStartEnd(builtin, sequence, ostart, oend,
			      &start, &end, &length);

    if (sequence == NIL)
	return (NIL);

    /* Cannot specify both :test and :test-not */
    if (test != UNSPEC && test_not != UNSPEC)
	LispDestroy("%s: specify either :TEST or :TEST-NOT", STRFUN(builtin));

    expect = 1;
    if (comparison == NONE) {
	if (test != UNSPEC)
	    predicate = test;
	else if (test_not != UNSPEC) {
	    predicate = test_not;
	    expect = 0;
	}
	FUNCTION_CHECK(predicate);
	code = FCODE(predicate);
    }

    cmp = element = NIL;
    istring = STRINGP(sequence);
    if (istring)
	string = THESTR(sequence);
    else {
	if (!CONSP(sequence))
	    sequence = sequence->data.array.list;
	for (i = 0; i < start; i++)
	    sequence = CDR(sequence);
    }

    if ((length = end - start) == 0)
	return (NIL);

    if (from_end != NIL && !istring) {
	objects = LispMalloc(sizeof(LispObj*) * length);
	for (i = length - 1; i >= 0; i--, sequence = CDR(sequence))
	    objects[i] = CAR(sequence);
    }

    for (i = 0; i < length; i++) {
	if (istring)
	    element = SCHAR(string[from_end == NIL ? i + start : end - i - 1]);
	else
	    element = from_end == NIL ? CAR(sequence) : objects[i];

	if (key != UNSPEC)
	    cmp = APPLY1(key, element);
	else
	    cmp = element;

	/* Update list */
	if (!istring && from_end == NIL)
	    sequence = CDR(sequence);

	if (comparison == NONE)
	    value = FCOMPARE(predicate, item, cmp, code);
	else
	    value = APPLY1(predicate, cmp) != NIL;

	if ((!value &&
	     (comparison == IFNOT ||
	      (comparison == NONE && !expect))) ||
	    (value &&
	     (comparison == IF ||
	      (comparison == NONE && expect)))) {
	    offset = from_end == NIL ? i + start : end - i - 1;
	    break;
	}
    }

    if (from_end != NIL && !istring)
	LispFree(objects);

    return (offset == -1 ? NIL : function == FIND ? element : FIXNUM(offset));
}

LispObj *
Lisp_Pop(LispBuiltin *builtin)
/*
 pop place
 */
{
    LispObj *result, *value;

    LispObj *place;

    place = ARGUMENT(0);

    if (SYMBOLP(place)) {
	result = LispGetVar(place);
	if (result == NULL)
	    LispDestroy("EVAL: the variable %s is unbound", STROBJ(place));
	CHECK_CONSTANT(place);
	if (result != NIL) {
	    CHECK_CONS(result);
	    value = CDR(result);
	    result = CAR(result);
	}
	else
	    value = NIL;
	LispSetVar(place, value);
    }
    else {
	GC_ENTER();
	LispObj quote;

	result = EVAL(place);
	if (result != NIL) {
	    CHECK_CONS(result);
	    value = CDR(result);
	    GC_PROTECT(value);
	    result = CAR(result);
	}
	else
	    value = NIL;
	quote.type = LispQuote_t;
	quote.data.quote = value;
	APPLY2(Osetf, place, &quote);
	GC_LEAVE();
    }

    return (result);
}

LispObj *
Lisp_Position(LispBuiltin *builtin)
/*
 position item sequence &key from-end test test-not start end key
 */
{
    return (LispFindOrPosition(builtin, POSITION, NONE));
}

LispObj *
Lisp_PositionIf(LispBuiltin *builtin)
/*
 position-if predicate sequence &key from-end start end key
 */
{
    return (LispFindOrPosition(builtin, POSITION, IF));
}

LispObj *
Lisp_PositionIfNot(LispBuiltin *builtin)
/*
 position-if-not predicate sequence &key from-end start end key
 */
{
    return (LispFindOrPosition(builtin, POSITION, IFNOT));
}

LispObj *
Lisp_Proclaim(LispBuiltin *builtin)
/*
 proclaim declaration
 */
{
    LispObj *arguments, *object;
    char *operation;

    LispObj *declaration;

    declaration = ARGUMENT(0);

    CHECK_CONS(declaration);

    arguments = declaration;
    object = CAR(arguments);
    CHECK_SYMBOL(object);

    operation = ATOMID(object);
    if (strcmp(operation, "SPECIAL") == 0) {
	for (arguments = CDR(arguments); CONSP(arguments);
	     arguments = CDR(arguments)) {
	    object = CAR(arguments);
	    CHECK_SYMBOL(object);
	    LispProclaimSpecial(object, NULL, NIL);
	}
    }
    else if (strcmp(operation, "TYPE") == 0) {
	/* XXX no type checking yet, but should be added */
    }
    /* else do nothing */

    return (NIL);
}

LispObj *
Lisp_Prog1(LispBuiltin *builtin)
/*
 prog1 first &rest body
 */
{
    GC_ENTER();
    LispObj *result;

    LispObj *first, *body;

    body = ARGUMENT(1);
    first = ARGUMENT(0);

    result = EVAL(first);

    GC_PROTECT(result);
    for (; CONSP(body); body = CDR(body))
	(void)EVAL(CAR(body));
    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_Prog2(LispBuiltin *builtin)
/*
 prog2 first second &rest body
 */
{
    GC_ENTER();
    LispObj *result;

    LispObj *first, *second, *body;

    body = ARGUMENT(2);
    second = ARGUMENT(1);
    first = ARGUMENT(0);

    (void)EVAL(first);
    result = EVAL(second);
    GC_PROTECT(result);
    for (; CONSP(body); body = CDR(body))
	(void)EVAL(CAR(body));
    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_Progn(LispBuiltin *builtin)
/*
 progn &rest body
 */
{
    LispObj *result = NIL;

    LispObj *body;

    body = ARGUMENT(0);

    for (; CONSP(body); body = CDR(body))
	result = EVAL(CAR(body));

    return (result);
}

/*
 *  This does what I believe is the expected behaviour (or at least
 * acceptable for the the interpreter), if the code being executed
 * ever tries to change/bind a progv symbol, the symbol state will
 * be restored when exiting the progv block, so, code like:
 *	(progv '(*x*) '(1) (defvar *x* 10))
 * when exiting the block, will have *x* unbound, and not a dynamic
 * symbol; if it was already bound, will have the old value.
 *  Symbols already dynamic can be freely changed, even unbounded in
 * the progv block.
 */
LispObj *
Lisp_Progv(LispBuiltin *builtin)
/*
 progv symbols values &rest body
 */
{
    GC_ENTER();
    int head = lisp__data.env.length, i, count, ostk[32], *offsets;
    LispObj *result, *list, *symbol, *value, **presult, **psymbols, **pbody;
    int jumped, *pjumped, *pcount, **poffsets;
    char fstk[32], *flags, **pflags;
    LispBlock *block;
    LispAtom *atom;

    LispObj *symbols, *values, *body;

    /* Possible states */
#define DYNAMIC_SYMBOL		1
#define GLOBAL_SYMBOL		2
#define UNBOUND_SYMBOL		3

    body = ARGUMENT(2);
    values = ARGUMENT(1);
    symbols = ARGUMENT(0);

    /* get symbol names */
    symbols = EVAL(symbols);
    GC_PROTECT(symbols);

    /* get symbol values */
    values = EVAL(values);
    GC_PROTECT(values);

    /* use variables */
    pbody = &body;
    psymbols = &symbols;
    presult = &result;
    pjumped = &jumped;
    poffsets = &offsets;
    pcount = &count;
    pflags = &flags;

    /* count/check symbols and allocate space to remember symbol state */
    for (count = 0, list = symbols; CONSP(list); count++, list = CDR(list)) {
	symbol = CAR(list);
	CHECK_SYMBOL(symbol);
	CHECK_CONSTANT(symbol);
    }
    if (count > sizeof(fstk)) {
	flags = LispMalloc(count);
	offsets = LispMalloc(count * sizeof(int));
    }
    else {
	flags = &fstk[0];
	offsets = &ostk[0];
    }

    /* store flags and save old value if required */
    for (i = 0, list = symbols; i < count; i++, list = CDR(list)) {
	atom = CAR(list)->data.atom;
	if (atom->dyn)
	    flags[i] = DYNAMIC_SYMBOL;
	else if (atom->a_object) {
	    flags[i] = GLOBAL_SYMBOL;
	    offsets[i] = lisp__data.protect.length;
	    GC_PROTECT(atom->property->value);
	}
	else
	    flags[i] = UNBOUND_SYMBOL;
    }

    /* bind the symbols */
    for (i = 0, list = symbols; i < count; i++, list = CDR(list)) {
	symbol = CAR(list);
	atom = symbol->data.atom;
	if (CONSP(values)) {
	    value = CAR(values);
	    values = CDR(values);
	}
	else
	    value = NIL;
	if (flags[i] != DYNAMIC_SYMBOL) {
	    if (!atom->a_object)
		LispSetAtomObjectProperty(atom, value);
	    else
		SETVALUE(atom, value);
	}
	else
	    LispAddVar(symbol, value);
    }
    /* bind dynamic symbols */
    lisp__data.env.head = lisp__data.env.length;

    jumped = 0;
    result = NIL;
    block = LispBeginBlock(NIL, LispBlockProtect);
    if (setjmp(block->jmp) == 0) {
	for (; CONSP(body); body = CDR(body))
	    result = EVAL(CAR(body));
    }

    /* restore symbols */
    for (i = 0, list = symbols; i < count; i++, list = CDR(list)) {
	symbol = CAR(list);
	atom = symbol->data.atom;
	if (flags[i] != DYNAMIC_SYMBOL) {
	    if (flags[i] == UNBOUND_SYMBOL)
		LispUnsetVar(symbol);
	    else {
		/* restore global symbol value */
		LispSetAtomObjectProperty(atom, lisp__data.protect.objects
					  [offsets[i]]);
		atom->dyn = 0;
	    }
	}
    }
    /* unbind dynamic symbols */
    lisp__data.env.head = lisp__data.env.length = head;
    GC_LEAVE();

    if (count > sizeof(fstk)) {
	LispFree(flags);
	LispFree(offsets);
    }

    LispEndBlock(block);
    if (!lisp__data.destroyed) {
	if (jumped)
	    result = lisp__data.block.block_ret;
    }
    else {
	/* check if there is an unwind-protect block */
	LispBlockUnwind(NULL);

	/* no unwind-protect block, return to the toplevel */
	LispDestroy(".");
    }

    return (result);
}

LispObj *
Lisp_Provide(LispBuiltin *builtin)
/*
 provide module
 */
{
    LispObj *module, *obj;

    module = ARGUMENT(0);

    CHECK_STRING(module);
    for (obj = MOD; obj != NIL; obj = CDR(obj)) {
	if (STRLEN(CAR(obj)) == STRLEN(module) &&
	    memcmp(THESTR(CAR(obj)), THESTR(module), STRLEN(module)) == 0)
	    return (module);
    }

    if (MOD == NIL)
	MOD = CONS(module, NIL);
    else {
	RPLACD(MOD, CONS(CAR(MOD), CDR(MOD)));
	RPLACA(MOD, module);
    }

    LispSetVar(lisp__data.modules, MOD);

    return (MOD);
}

LispObj *
Lisp_Push(LispBuiltin *builtin)
/*
 push item place
 */
{
    LispObj *result, *list;

    LispObj *item, *place;

    place = ARGUMENT(1);
    item = ARGUMENT(0);

    item = EVAL(item);

    if (SYMBOLP(place)) {
	list = LispGetVar(place);
	if (list == NULL)
	    LispDestroy("EVAL: the variable %s is unbound", STROBJ(place));
	CHECK_CONSTANT(place);
	LispSetVar(place, result = CONS(item, list));
    }
    else {
	GC_ENTER();
	LispObj quote;

	list = EVAL(place);
	result = CONS(item, list);
	GC_PROTECT(result);
	quote.type = LispQuote_t;
	quote.data.quote = result;
	APPLY2(Osetf, place, &quote);
	GC_LEAVE();
    }

    return (result);
}

LispObj *
Lisp_Pushnew(LispBuiltin *builtin)
/*
 pushnew item place &key key test test-not
 */
{
    GC_ENTER();
    LispObj *result, *list;

    LispObj *item, *place, *key, *test, *test_not;

    test_not = ARGUMENT(4);
    test = ARGUMENT(3);
    key = ARGUMENT(2);
    place = ARGUMENT(1);
    item = ARGUMENT(0);

    /* Evaluate place */
    if (SYMBOLP(place)) {
	list = LispGetVar(place);
	if (list == NULL)
	    LispDestroy("EVAL: the variable %s is unbound", STROBJ(place));
	/* Do error checking now. */
	CHECK_CONSTANT(place);
    }
    else
	/* It is possible that list is not gc protected? */
	list = EVAL(place);

    item = EVAL(item);
    GC_PROTECT(item);
    if (key != UNSPEC) {
	key = EVAL(key);
	GC_PROTECT(key);
    }
    if (test != UNSPEC) {
	test = EVAL(test);
	GC_PROTECT(test);
    }
    else if (test_not != UNSPEC) {
	test_not = EVAL(test_not);
	GC_PROTECT(test_not);
    }

    result = LispAdjoin(builtin, item, list, key, test, test_not);

    /* Item already in list */
    if (result == list) {
	GC_LEAVE();

	return (result);
    }

    if (SYMBOLP(place)) {
	CHECK_CONSTANT(place);
	LispSetVar(place, result);
    }
    else {
	LispObj quote;

	GC_PROTECT(result);
	quote.type = LispQuote_t;
	quote.data.quote = result;
	APPLY2(Osetf, place, &quote);
    }
    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_Quit(LispBuiltin *builtin)
/*
 quit &optional status
 */
{
    int status = 0;
    LispObj *ostatus;

    ostatus = ARGUMENT(0);

    if (FIXNUMP(ostatus))
	status = (int)FIXNUM_VALUE(ostatus);
    else if (ostatus != UNSPEC)
	LispDestroy("%s: bad exit status argument %s",
		    STRFUN(builtin), STROBJ(ostatus));

    exit(status);
}

LispObj *
Lisp_Quote(LispBuiltin *builtin)
/*
 quote object
 */
{
    LispObj *object;

    object = ARGUMENT(0);

    return (object);
}

LispObj *
Lisp_Replace(LispBuiltin *builtin)
/*
 replace sequence1 sequence2 &key start1 end1 start2 end2
 */
{
    long length, length1, length2, start1, end1, start2, end2;
    LispObj *sequence1, *sequence2, *ostart1, *oend1, *ostart2, *oend2;

    oend2 = ARGUMENT(5);
    ostart2 = ARGUMENT(4);
    oend1 = ARGUMENT(3);
    ostart1 = ARGUMENT(2);
    sequence2 = ARGUMENT(1);
    sequence1 = ARGUMENT(0);

    LispCheckSequenceStartEnd(builtin, sequence1, ostart1, oend1,
			      &start1, &end1, &length1);
    LispCheckSequenceStartEnd(builtin, sequence2, ostart2, oend2,
			      &start2, &end2, &length2);

    if (start1 == end1 || start2 == end2)
	return (sequence1);

    length = end1 - start1;
    if (length > end2 - start2)
	length = end2 - start2;

    if (STRINGP(sequence1)) {
	CHECK_STRING_WRITABLE(sequence1);
	if (!STRINGP(sequence2))
	    LispDestroy("%s: cannot store %s in %s",
			STRFUN(builtin), STROBJ(sequence2), THESTR(sequence1));

	memmove(THESTR(sequence1) + start1, THESTR(sequence2) + start2, length);
    }
    else {
	int i;
	LispObj *from, *to;

	if (ARRAYP(sequence1))
	    sequence1 = sequence1->data.array.list;
	if (ARRAYP(sequence2))
	    sequence2 = sequence2->data.array.list;

	/* adjust pointers */
	for (i = 0, from = sequence2; i < start2; i++, from = CDR(from))
a1803 1275
	for (i = 0, to = sequence1; i < start1; i++, to = CDR(to))
	    ;

	/* copy data */
	for (i = 0; i < length; i++, from = CDR(from), to = CDR(to))
	    RPLACA(to, CAR(from));
    }

    return (sequence1);
}

static LispObj *
LispDeleteOrRemoveDuplicates(LispBuiltin *builtin, int function)
/*
 delete-duplicates sequence &key from-end test test-not start end key
 remove-duplicates sequence &key from-end test test-not start end key
 */
{
    GC_ENTER();
    int code, expect, value = 0;
    long i, j, start, end, length, count;
    LispObj *lambda, *result, *cons, *compare;

    LispObj *sequence, *from_end, *test, *test_not, *ostart, *oend, *key;

    key = ARGUMENT(6);
    oend = ARGUMENT(5);
    ostart = ARGUMENT(4);
    test_not = ARGUMENT(3);
    test = ARGUMENT(2);
    from_end = ARGUMENT(1);
    if (from_end == UNSPEC)
	from_end = NIL;
    sequence = ARGUMENT(0);

    LispCheckSequenceStartEnd(builtin, sequence, ostart, oend,
			      &start, &end, &length);

    /* Check if need to do something */
    if (start == end)
	return (sequence);

    CHECK_TEST();

    /* Initialize */
    count = 0;

    result = cons = NIL;
    if (STRINGP(sequence)) {
	char *ptr, *string, *buffer = LispMalloc(length + 1);

	/* Use same code, update start/end offsets */
	if (from_end != NIL) {
	    i = length - start;
	    start = length - end;
	    end = i;
	}

	if (from_end == NIL)
	    string = THESTR(sequence);
	else {
	    /* Make a reversed copy of the sequence */
	    string = LispMalloc(length + 1);
	    for (ptr = THESTR(sequence) + length - 1, i = 0; i < length; i++)
		string[i] = *ptr--;
	    string[i] = '\0';
	}

	ptr = buffer;
	/* Copy leading bytes */
	for (i = 0; i < start; i++)
	    *ptr++ = string[i];

	compare = SCHAR(string[i]);
	if (key != UNSPEC)
	    compare = APPLY1(key, compare);
	result = cons = CONS(compare, NIL);
	GC_PROTECT(result);
	for (++i; i < end; i++) {
	    compare = SCHAR(string[i]);
	    if (key != UNSPEC)
		compare = APPLY1(key, compare);
	    RPLACD(cons, CONS(compare, NIL));
	    cons = CDR(cons);
	}

	for (i = start; i < end; i++, result = CDR(result)) {
	    compare = CAR(result);
	    for (j = i + 1, cons = CDR(result); j < end; j++, cons = CDR(cons)) {
		value = FCOMPARE(lambda, compare, CAR(cons), code);
		if (value == expect)
		    break;
	    }
	    if (value != expect)
		*ptr++ = string[i];
	    else
		++count;
	}

	if (count) {
	    /* Copy ending bytes */
	    for (; i <= length; i++)   /* Also copy the ending nul */
		*ptr++ = string[i];

	    if (from_end == NIL)
		ptr = buffer;
	    else {
		for (i = 0, ptr = buffer + strlen(buffer);
		     ptr > buffer;
		     i++)
		    string[i] = *--ptr;
		string[i] = '\0';
		ptr = string;
		LispFree(buffer);
	    }
	    if (function == REMOVE)
		result = STRING2(ptr);
	    else {
		CHECK_STRING_WRITABLE(sequence);
		result = sequence;
		free(THESTR(result));
		THESTR(result) = ptr;
		LispMused(ptr);
	    }
	}
	else {
	    result = sequence;
	    if (from_end != NIL)
		LispFree(string);
	}
    }
    else {
	long xlength = end - start;
	LispObj *list, *object, **kobjects = NULL, **xobjects;
	LispObj **objects = LispMalloc(sizeof(LispObj*) * xlength);

	if (!CONSP(sequence))
	    object = sequence->data.array.list;
	else
	    object = sequence;
	list = object;

	for (i = 0; i < start; i++)
	    object = CDR(object);

	/* Put data in a vector */
	if (from_end == NIL) {
	    for (i = 0; i < xlength; i++, object = CDR(object))
		objects[i] = CAR(object);
	}
	else {
	    for (i = xlength - 1; i >= 0; i--, object = CDR(object))
		objects[i] = CAR(object);
	}

	/* Apply key predicate if required */
	if (key != UNSPEC) {
	    kobjects = LispMalloc(sizeof(LispObj*) * xlength);
	    for (i = 0; i < xlength; i++) {
		kobjects[i] = APPLY1(key, objects[i]);
		GC_PROTECT(kobjects[i]);
	    }
	    xobjects = kobjects;
	}
	else
	    xobjects = objects;

	/* Check if needs to remove something */
	for (i = 0; i < xlength; i++) {
	    compare = xobjects[i];
	    for (j = i + 1; j < xlength; j++) {
		value = FCOMPARE(lambda, compare, xobjects[j], code);
		if (value == expect) {
		    objects[i] = NULL;
		    ++count;
		    break;
		}
	    }
	}

	if (count) {
	    /* Create/set result list */
	    object = list;

	    if (start) {
		/* Skip first elements of resulting list */
		if (function == REMOVE) {
		    result = cons = CONS(CAR(object), NIL);
		    GC_PROTECT(result);
		    for (i = 1, object = CDR(object);
			 i < start;
			 i++, object = CDR(object)) {
			RPLACD(cons, CONS(CAR(object), NIL));
			cons = CDR(cons);
		    }
		}
		else {
		    result = cons = object;
		    for (i = 1; i < start; i++, cons = CDR(cons))
			;
		}
	    }
	    else if (function == DELETE)
		result = list;

	    /* Skip initial removed elements */
	    if (function == REMOVE) {
		for (i = 0; objects[i] == NULL && i < xlength; i++)
		    ;
	    }
	    else
		i = 0;

	    if (i < xlength) {
		int xstart, xlimit, xinc;

		if (from_end == NIL) {
		    xstart = i;
		    xlimit = xlength;
		    xinc = 1;
		}
		else {
		    xstart = xlength - 1;
		    xlimit = i - 1;
		    xinc = -1;
		}

		if (function == REMOVE) {
		    for (i = xstart; i != xlimit; i += xinc) {
			if (objects[i] != NULL) {
			    if (result == NIL) {
				result = cons = CONS(objects[i], NIL);
				GC_PROTECT(result);
			    }
			    else {
				RPLACD(cons, CONS(objects[i], NIL));
				cons = CDR(cons);
			    }
			}
		    }
		}
		else {
		    /* Delete duplicates */
		    for (i = xstart; i != xlimit; i += xinc) {
			if (objects[i] == NULL) {
			    if (cons == NIL) {
				if (CONSP(CDR(result))) {
				    RPLACA(result, CADR(result));
				    RPLACD(result, CDDR(result));
				}
				else {
				    RPLACA(result, CDR(result));
				    RPLACD(result, NIL);
				}
			    }
			    else {
				if (CONSP(CDR(cons)))
				    RPLACD(cons, CDDR(cons));
				else
				    RPLACD(cons, NIL);
			    }
			}
			else {
			    if (cons == NIL)
				cons = result;
			    else
				cons = CDR(cons);
			}
		    }
		}
	    }
	    if (end < length && function == REMOVE) {
		for (i = start; i < end; i++, object = CDR(object))
		    ;
		if (result == NIL) {
		    result = cons = CONS(CAR(object), NIL);
		    GC_PROTECT(result);
		    ++i;
		    object = CDR(object);
		}
		for (; i < length; i++, object = CDR(object)) {
		    RPLACD(cons, CONS(CAR(object), NIL));
		    cons = CDR(cons);
		}
	    }
	}
	else
	    result = sequence;
	LispFree(objects);
	if (key != UNSPEC)
	    LispFree(kobjects);

	if (count && !CONSP(sequence)) {
	    if (function == REMOVE)
		result = VECTOR(result);
	    else {
		length = FIXNUM_VALUE(CAR(sequence->data.array.dim)) - count;
		CAR(sequence->data.array.dim) = FIXNUM(length);
		result = sequence;
	    }
	}
    }
    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_RemoveDuplicates(LispBuiltin *builtin)
/*
 remove-duplicates sequence &key from-end test test-not start end key
 */
{
    return (LispDeleteOrRemoveDuplicates(builtin, REMOVE));
}

static LispObj *
LispDeleteRemoveXSubstitute(LispBuiltin *builtin,
			    int function, int comparison)
/*
 delete item sequence &key from-end test test-not start end count key
 delete-if predicate sequence &key from-end start end count key
 delete-if-not predicate sequence &key from-end start end count key
 remove item sequence &key from-end test test-not start end count key
 remove-if predicate sequence &key from-end start end count key
 remove-if-not predicate sequence &key from-end start end count key
 substitute newitem olditem sequence &key from-end test test-not start end count key
 substitute-if newitem test sequence &key from-end start end count key
 substitute-if-not newitem test sequence &key from-end start end count key
 nsubstitute newitem olditem sequence &key from-end test test-not start end count key
 nsubstitute-if newitem test sequence &key from-end start end count key
 nsubstitute-if-not newitem test sequence &key from-end start end count key
 */
{
    GC_ENTER();
    int code, expect, value, inplace, substitute;
    long i, j, start, end, length, copy, count, xstart, xend, xinc, xlength;

    LispObj *result, *compare;

    LispObj *item, *newitem, *lambda, *sequence, *from_end,
	    *test, *test_not, *ostart, *oend, *ocount, *key;

    substitute = function == SUBSTITUTE || function == NSUBSTITUTE;
    if (!substitute)
	i = comparison == NONE ? 8 : 6;
    else /* substitute */
	i = comparison == NONE ? 9 : 7;

    /* Get function arguments */
    key = ARGUMENT(i);			--i;
    ocount = ARGUMENT(i);		--i;
    oend = ARGUMENT(i);			--i;
    ostart = ARGUMENT(i);		--i;
    if (comparison == NONE) {
	test_not = ARGUMENT(i);		--i;
	test = ARGUMENT(i);		--i;
    }
    else
	test_not = test = UNSPEC;
    from_end = ARGUMENT(i);		--i;
    if (from_end == UNSPEC)
	from_end = NIL;
    sequence = ARGUMENT(i);		--i;
    if (comparison != NONE) {
	lambda = ARGUMENT(i);	--i;
	if (substitute)
	    newitem = ARGUMENT(0);
	else
	    newitem = NIL;
	item = NIL;
    }
    else {
	lambda = NIL;
	if (substitute) {
	    item = ARGUMENT(1);
	    newitem = ARGUMENT(0);
	}
	else {
	    item = ARGUMENT(0);
	    newitem = NIL;
	}
    }

    /* Check if argument is a valid sequence, and if start/end
     * are correctly specified. */
    LispCheckSequenceStartEnd(builtin, sequence, ostart, oend,
			      &start, &end, &length);

    /* Check count argument */
    if (ocount == UNSPEC) {
	count = length;
	/* Doesn't matter, but left to right should be slightly faster */
	from_end = NIL;
    }
    else {
	CHECK_INDEX(ocount);
	count = FIXNUM_VALUE(ocount);
    }

    /* Check if need to do something */
    if (start == end || count == 0)
	return (sequence);

    CHECK_TEST_0();

    /* Resolve comparison function, and expected result of comparison */
    if (comparison == NONE) {
	if (test_not == UNSPEC) {
	    if (test == UNSPEC)
		lambda = Oeql;
	    else
		lambda = test;
	    expect = 1;
	}
	else {
	    lambda = test_not;
	    expect = 0;
	}
	FUNCTION_CHECK(lambda);
    }
    else
	expect = comparison == IFNOT ? 0 : 1;

    /* Check for fast path to comparison function */
    code = FCODE(lambda);

    /* Initialize for loop */
    copy = count;
    result = sequence;
    inplace = function == DELETE || function == NSUBSTITUTE;
    xlength = end - start;

    /* String is easier */
    if (STRINGP(sequence)) {
	char *buffer, *string;

	if (comparison == NONE) {
	    CHECK_SCHAR(item);
	}
	if (substitute) {
	    CHECK_SCHAR(newitem);
	}

	if (from_end == NIL) {
	    xstart = start;
	    xend = end;
	    xinc = 1;
	}
	else {
	    xstart = end - 1;
	    xend = start - 1;
	    xinc = -1;
	}

	string = THESTR(sequence);
	buffer = LispMalloc(length + 1);

	/* Copy leading bytes, if any */
	for (i = 0; i < start; i++)
	    buffer[i] = string[i];

	for (j = xstart; i != xend && count > 0; i += xinc) {
	    compare = SCHAR(string[i]);
	    if (key != UNSPEC) {
		compare = APPLY1(key, compare);
		/* Value returned by the key predicate may not be protected */
		GC_PROTECT(compare);
		if (comparison == NONE)
		    value = FCOMPARE(lambda, item, compare, code);
		else
		    value = APPLY1(lambda, compare) != NIL;
		/* Unprotect value returned by the key predicate */
		GC_LEAVE();
	    }
	    else {
		if (comparison == NONE)
		    value = FCOMPARE(lambda, item, compare, code);
		else
		    value = APPLY1(lambda, compare) != NIL;
	    }

	    if (value != expect) {
		buffer[j] = string[i];
		j += xinc;
	    }
	    else {
		if (substitute) {
		    buffer[j] = SCHAR_VALUE(newitem);
		    j += xinc;
		}
		else
		    --count;
	    }
	}

	if (count != copy && from_end != NIL)
	    memmove(buffer + start, buffer + copy - count, count);

	/* Copy remaining bytes, if any */
	for (; i < length; i++, j++)
	    buffer[j] = string[i];
	buffer[j] = '\0';

	xlength = length - (copy - count);
	if (inplace) {
	    CHECK_STRING_WRITABLE(sequence);
	    /* result is a pointer to sequence */
	    LispFree(THESTR(sequence));
	    LispMused(buffer);
	    THESTR(sequence) = buffer;
	    STRLEN(sequence) = xlength;
	}
	else
	    result = LSTRING2(buffer, xlength);
    }

    /* If inplace, need to update CAR and CDR of sequence */
    else {
	LispObj *list, *object;
	LispObj **objects = LispMalloc(sizeof(LispObj*) * xlength);

	if (!CONSP(sequence))
	    list = sequence->data.array.list;
	else
	    list = sequence;

	/* Put data in a vector */
	for (i = 0, object = list; i < start; i++)
	    object = CDR(object);

	for (i = 0; i < xlength; i++, object = CDR(object))
	    objects[i] = CAR(object);

	if (from_end == NIL) {
	    xstart = 0;
	    xend = xlength;
	    xinc = 1;
	}
	else {
	    xstart = xlength - 1;
	    xend = -1;
	    xinc = -1;
	}

	/* Check if needs to remove something */
	for (i = xstart; i != xend && count > 0; i += xinc) {
	    compare = objects[i];
	    if (key != UNSPEC) {
		compare = APPLY1(key, compare);
		GC_PROTECT(compare);
		if (comparison == NONE)
		    value = FCOMPARE(lambda, item, compare, code);
		else
		    value = APPLY1(lambda, compare) != NIL;
		GC_LEAVE();
	    }
	    else {
		if (comparison == NONE)
		    value = FCOMPARE(lambda, item, compare, code);
		else
		    value = APPLY1(lambda, compare) != NIL;
	    }
	    if (value == expect) {
		if (substitute)
		    objects[i] = newitem;
		else
		    objects[i] = NULL;
		--count;
	    }
	}

	if (copy != count) {
	    LispObj *cons = NIL;

	    i = 0;
	    object = list;
	    if (inplace) {
		/* While result is NIL, skip initial elements of sequence */
		result = start ? list : NIL;

		/* Skip initial elements, if any */
		for (; i < start; i++, cons = object, object = CDR(object))
		    ;
	    }
	    /* Copy initial elements, if any */
	    else {
		result = NIL;
		if (start) {
		    result = cons = CONS(CAR(list), NIL);
		    GC_PROTECT(result);
		    for (++i, object = CDR(list);
			 i < start;
			 i++, object = CDR(object)) {
			RPLACD(cons, CONS(CAR(object), NIL));
		 	cons = CDR(cons);
		    }
		}
	    }

	    /* Skip initial removed elements, if any */
	    for (i = 0; objects[i] == NULL && i < xlength; i++)
		;

	    for (i = 0; i < xlength; i++, object = CDR(object)) {
		if (objects[i]) {
		    if (inplace) {
			if (result == NIL)
			    result = cons = object;
			else {
			    RPLACD(cons, object);
			    cons = CDR(cons);
			}
			if (function == NSUBSTITUTE)
			    RPLACA(cons, objects[i]);
		    }
		    else {
			if (result == NIL) {
			    result = cons = CONS(objects[i], NIL);
			    GC_PROTECT(result);
			}
			else {
			    RPLACD(cons, CONS(objects[i], NIL));
			    cons = CDR(cons);
			}
		    }
		}
	    }

	    if (inplace) {
		if (result == NIL)
		    result = object;
		else
		    RPLACD(cons, object);

		if (!CONSP(sequence)) {
		    result = sequence;
		    CAR(result)->data.array.dim =
			FIXNUM(length - (copy - count));
		}
	    }
	    else if (end < length) {
		i = end;
		/* Copy ending elements, if any */
		if (result == NIL) {
		    result = cons = CONS(CAR(object), NIL);
		    GC_PROTECT(result);
		    object = CDR(object);
		    i++;
		}
		for (; i < length; i++, object = CDR(object)) {
		    RPLACD(cons, CONS(CAR(object), NIL));
		    cons = CDR(cons);
		}
	    }
	}

	/* Release comparison vector */
	LispFree(objects);
    }

    GC_LEAVE();

    return (result);
}

LispObj *
Lisp_Remove(LispBuiltin *builtin)
/*
 remove item sequence &key from-end test test-not start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, REMOVE, NONE));
}

LispObj *
Lisp_RemoveIf(LispBuiltin *builtin)
/*
 remove-if predicate sequence &key from-end start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, REMOVE, IF));
}

LispObj *
Lisp_RemoveIfNot(LispBuiltin *builtin)
/*
 remove-if-not predicate sequence &key from-end start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, REMOVE, IFNOT));
}

LispObj *
Lisp_Remprop(LispBuiltin *builtin)
/*
 remprop symbol indicator
 */
{
    LispObj *symbol, *indicator;

    indicator = ARGUMENT(1);
    symbol = ARGUMENT(0);

    CHECK_SYMBOL(symbol);

    return (LispRemAtomProperty(symbol->data.atom, indicator));
}

LispObj *
Lisp_Return(LispBuiltin *builtin)
/*
 return &optional result
 */
{
    unsigned blevel = lisp__data.block.block_level;

    LispObj *result;

    result = ARGUMENT(0);

    while (blevel) {
	LispBlock *block = lisp__data.block.block[--blevel];

	if (block->type == LispBlockClosure)
	    /* if reached a function call */
	    break;
	if (block->type == LispBlockTag && block->tag == NIL) {
	    lisp__data.block.block_ret = result == UNSPEC ? NIL : EVAL(result);
	    LispBlockUnwind(block);
	    BLOCKJUMP(block);
	}
    }
    LispDestroy("%s: no visible NIL block", STRFUN(builtin));

    /*NOTREACHED*/
    return (NIL);
}

LispObj *
Lisp_ReturnFrom(LispBuiltin *builtin)
/*
 return-from name &optional result
 */
{
    unsigned blevel = lisp__data.block.block_level;

    LispObj *name, *result;

    result = ARGUMENT(1);
    name = ARGUMENT(0);

    if (name != NIL && name != T && !SYMBOLP(name))
	LispDestroy("%s: %s is not a valid block name",
		    STRFUN(builtin), STROBJ(name));

    while (blevel) {
	LispBlock *block = lisp__data.block.block[--blevel];

	if (name == block->tag &&
	    (block->type == LispBlockTag || block->type == LispBlockClosure)) {
	    lisp__data.block.block_ret = result == UNSPEC ? NIL : EVAL(result);
	    LispBlockUnwind(block);
	    BLOCKJUMP(block);
	}
	if (block->type == LispBlockClosure)
	    /* can use return-from only in the current function */
	    break;
    }
    LispDestroy("%s: no visible block named %s",
		STRFUN(builtin), STROBJ(name));

    /*NOTREACHED*/
    return (NIL);
}

static LispObj *
LispXReverse(LispBuiltin *builtin, int inplace)
/*
 nreverse sequence
 reverse sequence
 */
{
    long length;
    LispObj *list, *result = NIL;

    LispObj *sequence;

    sequence = ARGUMENT(0);

    /* Do error checking for arrays and object type. */
    length = LispLength(sequence);
    if (length <= 1)
	return (sequence);

    switch (XOBJECT_TYPE(sequence)) {
	case LispString_t: {
	    long i;
	    char *from, *to;

	    from = THESTR(sequence) + length - 1;
	    if (inplace) {
		char temp;

		CHECK_STRING_WRITABLE(sequence);
		to = THESTR(sequence);
		for (i = 0; i < length / 2; i++) {
		    temp = to[i];
		    to[i] = from[-i];
		    from[-i] = temp;
		}
		result = sequence;
	    }
	    else {
		to = LispMalloc(length + 1);
		to[length] = '\0';
		for (i = 0; i < length; i++)
		    to[i] = from[-i];
		result = STRING2(to);
	    }
	}   return (result);
	case LispCons_t:
	    if (inplace) {
		long i, j;
		LispObj *temp;

		/* For large lists this can be very slow, but for small
		 * amounts of data, this avoid allocating a buffer to
		 * to store the CAR of the sequence. This is only done
		 * to not destroy the contents of a variable.
		 */
		for (i = 0, list = sequence;
		     i < (length + 1) / 2;
		     i++, list = CDR(list))
		    ;
		length /= 2;
		for (i = 0; i < length; i++, list = CDR(list)) {
		    for (j = length - i - 1, result = sequence;
			 j > 0;
			 j--, result = CDR(result))
			;
		    temp = CAR(list);
		    RPLACA(list, CAR(result));
		    RPLACA(result, temp);
		}
		return (sequence);
	    }
	    list = sequence;
	    break;
	case LispArray_t:
	    if (inplace) {
		sequence->data.array.list =
		    LispReverse(sequence->data.array.list);
		return (sequence);
	    }
	    list = sequence->data.array.list;
	    break;
	default:	/* LispNil_t */
	    return (result);
    }

    {
	GC_ENTER();
	LispObj *cons;

	result = cons = CONS(CAR(list), NIL);
	GC_PROTECT(result);
	for (list = CDR(list); CONSP(list); list = CDR(list)) {
	    RPLACD(cons, CONS(CAR(list), NIL));
	    cons = CDR(cons);
	}
	result = LispReverse(result);

	GC_LEAVE();
    }

    if (ARRAYP(sequence)) {
	list = result;

	result = LispNew(list, NIL);
	result->type = LispArray_t;
	result->data.array.list = list;
	result->data.array.dim = sequence->data.array.dim;
	result->data.array.rank = sequence->data.array.rank;
	result->data.array.type = sequence->data.array.type;
	result->data.array.zero = sequence->data.array.zero;
    }

    return (result);
}

LispObj *
Lisp_Reverse(LispBuiltin *builtin)
/*
 reverse sequence
 */
{
    return (LispXReverse(builtin, 0));
}

LispObj *
Lisp_Rplaca(LispBuiltin *builtin)
/*
 rplaca place value
 */
{
    LispObj *place, *value;

    value = ARGUMENT(1);
    place = ARGUMENT(0);

    CHECK_CONS(place);
    RPLACA(place, value);

    return (place);
}

LispObj *
Lisp_Rplacd(LispBuiltin *builtin)
/*
 rplacd place value
 */
{
    LispObj *place, *value;

    value = ARGUMENT(1);
    place = ARGUMENT(0);

    CHECK_CONS(place);
    RPLACD(place, value);

    return (place);
}

LispObj *
Lisp_Search(LispBuiltin *builtin)
/*
 search sequence1 sequence2 &key from-end test test-not key start1 start2 end1 end2
 */
{
    int code = 0, expect, value;
    long start1, start2, end1, end2, length1, length2, off1, off2, offset = -1;
    LispObj *cmp1, *cmp2, *list1 = NIL, *lambda;
    SeqInfo seq1, seq2;

    LispObj *sequence1, *sequence2, *from_end, *test, *test_not,
	    *key, *ostart1, *ostart2, *oend1, *oend2;

    oend2 = ARGUMENT(9);
    oend1 = ARGUMENT(8);
    ostart2 = ARGUMENT(7);
    ostart1 = ARGUMENT(6);
    key = ARGUMENT(5);
    test_not = ARGUMENT(4);
    test = ARGUMENT(3);
    from_end = ARGUMENT(2);
    sequence2 = ARGUMENT(1);
    sequence1 = ARGUMENT(0);

    LispCheckSequenceStartEnd(builtin, sequence1, ostart1, oend1,
			      &start1, &end1, &length1);
    LispCheckSequenceStartEnd(builtin, sequence2, ostart2, oend2,
			      &start2, &end2, &length2);

    /* Check for special conditions */
    if (start1 == end1)
	return (FIXNUM(end2));
    else if (start2 == end2)
	return (start1 == end1 ? FIXNUM(start2) : NIL);

    CHECK_TEST();

    if (from_end == UNSPEC)
	from_end = NIL;

    SETSEQ(seq1, sequence1);
    SETSEQ(seq2, sequence2);

    length1 = end1 - start1;
    length2 = end2 - start2;

    /* update start of sequences */
    if (start1) {
	if (seq1.type == LispString_t)
	    seq1.data.string += start1;
	else {
	    for (cmp1 = seq1.data.list; start1; cmp1 = CDR(cmp1), --start1)
		;
	    seq1.data.list = cmp1;
	}
	end1 = length1;
    }
    if (start2) {
	if (seq2.type == LispString_t)
	    seq2.data.string += start2;
	else {
	    for (cmp2 = seq2.data.list; start2; cmp2 = CDR(cmp2), --start2)
		;
	    seq2.data.list = cmp2;
	}
	end2 = length2;
    }

    /* easier case */
    if (from_end == NIL) {
	LispObj *list2 = NIL;

	/* while a match is possible */
	while (end2 - start2 >= length1) {

	    /* prepare to search */
	    off1 = 0;
	    off2 = start2;
	    if (seq1.type != LispString_t)
		list1 = seq1.data.list;
	    if (seq2.type != LispString_t)
		list2 = seq2.data.list;

	    /* for every element that must match in sequence1 */
	    while (off1 < length1) {
		if (seq1.type == LispString_t)
		    cmp1 = SCHAR(seq1.data.string[off1]);
		else
		    cmp1 = CAR(list1);
		if (seq2.type == LispString_t)
		    cmp2 = SCHAR(seq2.data.string[off2]);
		else
		    cmp2 = CAR(list2);
		if (key != UNSPEC) {
		    cmp1 = APPLY1(key, cmp1);
		    cmp2 = APPLY1(key, cmp2);
		}

		/* compare elements */
		value = FCOMPARE(lambda, cmp1, cmp2, code);
		if (value != expect)
		    break;

		/* update offsets/sequence pointers */
		++off1;
		++off2;
		if (seq1.type != LispString_t)
		    list1 = CDR(list1);
		if (seq2.type != LispString_t)
		    list2 = CDR(list2);
	    }

	    /* if everything matched */
	    if (off1 == end1) {
		offset = off2 - length1;
		break;
	    }

	    /* update offset/sequence2 pointer */
	    ++start2;
	    if (seq2.type != LispString_t)
		seq2.data.list = CDR(seq2.data.list);
	}
    }
    else {
	/* allocate vector if required, only list2 requires it.
	 * list1 can be traversed forward */
	if (seq2.type != LispString_t) {
	    cmp2 = seq2.data.list;
	    seq2.data.vector = LispMalloc(sizeof(LispObj*) * length2);
	    for (off2 = 0; off2 < end2; off2++, cmp2 = CDR(cmp2))
		seq2.data.vector[off2] = CAR(cmp2);
	}

	/* while a match is possible */
	while (end2 >= length1) {

	    /* prepare to search */
	    off1 = 0;
	    off2 = end2 - length1;
	    if (seq1.type != LispString_t)
		list1 = seq1.data.list;

	    /* for every element that must match in sequence1 */
	    while (off1 < end1) {
		if (seq1.type == LispString_t)
		    cmp1 = SCHAR(seq1.data.string[off1]);
		else
		    cmp1 = CAR(list1);
		if (seq2.type == LispString_t)
		    cmp2 = SCHAR(seq2.data.string[off2]);
		else
		    cmp2 = seq2.data.vector[off2];
		if (key != UNSPEC) {
		    cmp1 = APPLY1(key, cmp1);
		    cmp2 = APPLY1(key, cmp2);
		}

		/* Compare elements */
		value = FCOMPARE(lambda, cmp1, cmp2, code);
		if (value != expect)
		    break;

		/* Update offsets */
		++off1;
		++off2;
		if (seq1.type != LispString_t)
		    list1 = CDR(list1);
	    }

	    /* If all elements matched */
	    if (off1 == end1) {
		offset = off2 - length1;
		break;
	    }

	    /* Update offset */
	    --end2;
	}

	if (seq2.type != LispString_t)
	    LispFree(seq2.data.vector);
    }

    return (offset == -1 ? NIL : FIXNUM(offset));
}

/*
 * ext::getenv
 */
LispObj *
Lisp_Setenv(LispBuiltin *builtin)
/*
 setenv name value &optional overwrite
 */
{
    char *name, *value;

    LispObj *oname, *ovalue, *overwrite;

    overwrite = ARGUMENT(2);
    ovalue = ARGUMENT(1);
    oname = ARGUMENT(0);

    CHECK_STRING(oname);
    name = THESTR(oname);

    CHECK_STRING(ovalue);
    value = THESTR(ovalue);

    setenv(name, value, overwrite != UNSPEC && overwrite != NIL);
    value = getenv(name);

    return (value ? STRING(value) : NIL);
}

LispObj *
Lisp_Set(LispBuiltin *builtin)
/*
 set symbol value
 */
{
    LispAtom *atom;
    LispObj *symbol, *value;

    value = ARGUMENT(1);
    symbol = ARGUMENT(0);

    CHECK_SYMBOL(symbol);
    atom = symbol->data.atom;
    if (atom->dyn)
	LispSetVar(symbol, value);
    else if (atom->watch || !atom->a_object)
	LispSetAtomObjectProperty(atom, value);
    else {
	CHECK_CONSTANT(symbol);
	SETVALUE(atom, value);
    }

    return (value);
}

LispObj *
Lisp_SetDifference(LispBuiltin *builtin)
/*
 set-difference list1 list2 &key test test-not key
 */
{
    return (LispListSet(builtin, SETDIFFERENCE));
}

LispObj *
Lisp_SetExclusiveOr(LispBuiltin *builtin)
/*
 set-exclusive-or list1 list2 &key test test-not key
 */
{
    return (LispListSet(builtin, SETEXCLUSIVEOR));
}

LispObj *
Lisp_NsetExclusiveOr(LispBuiltin *builtin)
/*
 nset-exclusive-or list1 list2 &key test test-not key
 */
{
    return (LispListSet(builtin, NSETEXCLUSIVEOR));
}

LispObj *
Lisp_SetQ(LispBuiltin *builtin)
/*
 setq &rest form
 */
{
    LispObj *result, *variable, *form;

    form = ARGUMENT(0);

    result = NIL;
    for (; CONSP(form); form = CDR(form)) {
	variable = CAR(form);
	CHECK_SYMBOL(variable);
	CHECK_CONSTANT(variable);
	form = CDR(form);
	if (!CONSP(form))
	    LispDestroy("%s: odd number of arguments", STRFUN(builtin));
	result = EVAL(CAR(form));
	LispSetVar(variable, result);
    }

    return (result);
}

LispObj *
Lisp_Psetq(LispBuiltin *builtin)
/*
 psetq &rest form
 */
{
    GC_ENTER();
    int base = gc__protect;
    LispObj *value, *symbol, *list, *form;

    form = ARGUMENT(0);

    /* parallel setq, first pass evaluate values and basic error checking */
    for (list = form; CONSP(list); list = CDR(list)) {
	symbol = CAR(list);
	CHECK_SYMBOL(symbol);
	list = CDR(list);
	if (!CONSP(list))
	    LispDestroy("%s: odd number of arguments", STRFUN(builtin));
	value = EVAL(CAR(list));
	GC_PROTECT(value);
    }

    /* second pass, assign values */
    for (; CONSP(form); form = CDDR(form)) {
	symbol = CAR(form);
	CHECK_CONSTANT(symbol);
	LispSetVar(symbol, lisp__data.protect.objects[base++]);
    }
    GC_LEAVE();

    return (NIL);
}

LispObj *
Lisp_Setf(LispBuiltin *builtin)
/*
 setf &rest form
 */
{
    LispAtom *atom;
    LispObj *setf, *place, *value, *result = NIL, *data;

    LispObj *form;

    form = ARGUMENT(0);
d1805 3
a1807 93
    for (; CONSP(form); form = CDR(form)) {
	place = CAR(form);
	form = CDR(form);
	if (!CONSP(form))
	    LispDestroy("%s: odd number of arguments", STRFUN(builtin));
	value = CAR(form);

	if (!POINTERP(place))
	    goto invalid_place;
	if (XSYMBOLP(place)) {
	    CHECK_CONSTANT(place);
	    result = EVAL(value);
	    (void)LispSetVar(place, result);
	}
	else if (XCONSP(place)) {
	    /* it really should not be required to protect any object
	     * evaluated here, but is done for safety in case one of
	     * the evaluated forms returns data not gc protected, what
	     * could cause surprises if the object is garbage collected
	     * before finishing setf. */
	    GC_ENTER();

	    setf = CAR(place);
	    if (!SYMBOLP(setf))
		goto invalid_place;
	    if (!CONSP(CDR(place)))
		goto invalid_place;

	    value = EVAL(value);
	    GC_PROTECT(value);

	    atom = setf->data.atom;
	    if (atom->a_defsetf == 0) {
		if (atom->a_defstruct &&
		    atom->property->structure.function >= 0) {
		    /* Use a default setf method for the structure field, as
		     * if this definition have been done
		     *	(defsetf THE-STRUCT-FIELD (struct) (value)
		     *	 `(lisp::struct-store 'THE-STRUCT-FIELD ,struct ,value))
		     */
		    place = CDR(place);
		    data = CAR(place);
		    if (CONSP(CDR(place)))
			goto invalid_place;
		    data = EVAL(data);
		    GC_PROTECT(data);
		    result = APPLY3(Ostruct_store, setf, data, value);
		    GC_LEAVE();
		    continue;
		}
		/* Must also expand macros */
		else if (atom->a_function &&
			 atom->property->fun.function->funtype == LispMacro) {
		    result = LispRunSetfMacro(atom, CDR(place), value);
		    continue;
		}
		goto invalid_place;
	    }

	    place = CDR(place);
	    setf = setf->data.atom->property->setf;
	    if (SYMBOLP(setf)) {
		LispObj *arguments, *cons;

		if (!CONSP(CDR(place))) {
		    arguments = EVAL(CAR(place));
		    GC_PROTECT(arguments);
		    result = APPLY2(setf, arguments, value);
		}
		else if (!CONSP(CDDR(place))) {
		    arguments = EVAL(CAR(place));
		    GC_PROTECT(arguments);
		    cons = EVAL(CADR(place));
		    GC_PROTECT(cons);
		    result = APPLY3(setf, arguments, cons, value);
		}
		else {
		    arguments = cons = CONS(EVAL(CAR(place)), NIL);
		    GC_PROTECT(arguments);
		    for (place = CDR(place); CONSP(place); place = CDR(place)) {
			RPLACD(cons, CONS(EVAL(CAR(place)), NIL));
			cons = CDR(cons);
		    }
		    RPLACD(cons, CONS(value, NIL));
		    result = APPLY(setf, arguments);
		}
	    }
	    else
		result = LispRunSetf(atom->property->salist, setf, place, value);
	    GC_LEAVE();
	}
	else
	    goto invalid_place;
d1810 1
a1810 19
    return (result);
invalid_place:
    LispDestroy("%s: %s is an invalid place", STRFUN(builtin), STROBJ(place));
    /*NOTREACHED*/
    return (NIL);
}

LispObj *
Lisp_Psetf(LispBuiltin *builtin)
/*
 psetf &rest form
 */
{
    int base;
    GC_ENTER();
    LispAtom *atom;
    LispObj *setf, *place = NIL, *value, *data;

    LispObj *form;
d1812 2
a1813 1
    form = ARGUMENT(0);
d1815 2
a1816 53
    /* parallel setf, first pass evaluate values and basic error checking */
    base = gc__protect;
    for (setf = form; CONSP(setf); setf = CDR(setf)) {
	if (!POINTERP(CAR(setf)))
	    goto invalid_place;
	setf = CDR(setf);
	if (!CONSP(setf))
	    LispDestroy("%s: odd number of arguments", STRFUN(builtin));
	value = EVAL(CAR(setf));
	GC_PROTECT(value);
    }

    /* second pass, assign values */
    for (; CONSP(form); form = CDDR(form)) {
	place = CAR(form);
	value = lisp__data.protect.objects[base++];

	if (XSYMBOLP(place)) {
	    CHECK_CONSTANT(place);
	    (void)LispSetVar(place, value);
	}
	else if (XCONSP(place)) {
	    LispObj *arguments, *cons;
	    int xbase = lisp__data.protect.length;

	    setf = CAR(place);
	    if (!SYMBOLP(setf))
		goto invalid_place;
	    if (!CONSP(CDR(place)))
		goto invalid_place;

	    atom = setf->data.atom;
	    if (atom->a_defsetf == 0) {
		if (atom->a_defstruct &&
		    atom->property->structure.function >= 0) {
		    place = CDR(place);
		    data = CAR(place);
		    if (CONSP(CDR(place)))
			goto invalid_place;
		    data = EVAL(data);
		    GC_PROTECT(data);
		    (void)APPLY3(Ostruct_store, setf, data, value);
		    lisp__data.protect.length = xbase;
		    continue;
		}
		else if (atom->a_function &&
			 atom->property->fun.function->funtype == LispMacro) {
		    (void)LispRunSetfMacro(atom, CDR(place), value);
		    lisp__data.protect.length = xbase;
		    continue;
		}
		goto invalid_place;
	    }
d1818 2
a1819 34
	    place = CDR(place);
	    setf = setf->data.atom->property->setf;
	    if (SYMBOLP(setf)) {
		if (!CONSP(CDR(place))) {
		    arguments = EVAL(CAR(place));
		    GC_PROTECT(arguments);
		    (void)APPLY2(setf, arguments, value);
		}
		else if (!CONSP(CDDR(place))) {
		    arguments = EVAL(CAR(place));
		    GC_PROTECT(arguments);
		    cons = EVAL(CADR(place));
		    GC_PROTECT(cons);
		    (void)APPLY3(setf, arguments, cons, value);
		}
		else {
		    arguments = cons = CONS(EVAL(CAR(place)), NIL);
		    GC_PROTECT(arguments);
		    for (place = CDR(place); CONSP(place); place = CDR(place)) {
			RPLACD(cons, CONS(EVAL(CAR(place)), NIL));
			cons = CDR(cons);
		    }
		    RPLACD(cons, CONS(value, NIL));
		    (void)APPLY(setf, arguments);
		}
		lisp__data.protect.length = xbase;
	    }
	    else
		(void)LispRunSetf(atom->property->salist, setf, place, value);
	}
	else
	    goto invalid_place;
    }
    GC_LEAVE();
d1821 2
a1822 5
    return (NIL);
invalid_place:
    LispDestroy("%s: %s is an invalid place", STRFUN(builtin), STROBJ(place));
    /*NOTREACHED*/
    return (NIL);
d1826 1
a1826 4
Lisp_Sleep(LispBuiltin *builtin)
/*
 sleep seconds
 */
d1828 1
a1828 2
    long sec, msec;
    double value, dsec;
d1830 2
a1831 1
    LispObj *seconds;
d1833 2
a1834 11
    seconds = ARGUMENT(0);

    value = -1.0;
    switch (OBJECT_TYPE(seconds)) {
	case LispFixnum_t:
	    value = FIXNUM_VALUE(seconds);
	    break;
	case LispDFloat_t:
	    value = DFLOAT_VALUE(seconds);
	    break;
	default:
d1836 4
a1839 102
    }

    if (value < 0.0 || value > MOST_POSITIVE_FIXNUM)
	LispDestroy("%s: %s is not a positive fixnum",
		    STRFUN(builtin), STROBJ(seconds));

    msec = modf(value, &dsec) * 1e6;
    sec = dsec;

    if (sec)
	sleep(sec);
    if (msec)
	usleep(msec);

    return (NIL);
}

/*
 *   This function is called recursively, but the contents of "list2" are
 * kept gc protected until it returns to LispSort. This is required partly
 * because the "gc protection logic" protects an object, not the contents
 * of the c pointer.
 */
static LispObj *
LispMergeSort(LispObj *list, LispObj *predicate, LispObj *key, int code)
{
    int protect;
    LispObj *list1, *list2, *left, *right, *result, *cons;

    /* Check if list length is larger than 1 */
    if (!CONSP(list) || !CONSP(CDR(list)))
	return (list);

    list1 = list2 = list;
    for (;;) {
	list = CDR(list);
	if (!CONSP(list))
	    break;
	list = CDR(list);
	if (!CONSP(list))
	    break;
	list2 = CDR(list2);
    }
    cons = list2;
    list2 = CDR(list2);
    RPLACD(cons, NIL);

    protect = 0;
    if (lisp__data.protect.length + 2 >= lisp__data.protect.space)
	LispMoreProtects();
    lisp__data.protect.objects[lisp__data.protect.length++] = list2;
    list1 = LispMergeSort(list1, predicate, key, code);
    list2 = LispMergeSort(list2, predicate, key, code);

    left = CAR(list1);
    right = CAR(list2);
    if (key != UNSPEC) {
	protect = lisp__data.protect.length;
	left = APPLY1(key, left);
	lisp__data.protect.objects[protect] = left;
	right = APPLY1(key, right);
	lisp__data.protect.objects[protect + 1] = right;
    }

    result = NIL;
    for (;;) {
	if ((FCOMPARE(predicate, left, right, code)) == 0 &&
	    (FCOMPARE(predicate, right, left, code)) == 1) {
	    /* right is "smaller" */
	    if (result == NIL)
		result = list2;
	    else
		RPLACD(cons, list2);
	    cons = list2;
	    list2 = CDR(list2);
	    if (!CONSP(list2)) {
		RPLACD(cons, list1);
		break;
	    }
	    right = CAR(list2);
	    if (key != UNSPEC) {
		right = APPLY1(key, right);
		lisp__data.protect.objects[protect + 1] = right;
	    }
	}
	else {
	    /* left is "smaller" */
	    if (result == NIL)
		result = list1;
	    else
		RPLACD(cons, list1);
	    cons = list1;
	    list1 = CDR(list1);
	    if (!CONSP(list1)) {
		RPLACD(cons, list2);
		break;
	    }
	    left = CAR(list1);
	    if (key != UNSPEC) {
		left = APPLY1(key, left);
		lisp__data.protect.objects[protect] = left;
	    }
d1842 2
a1843 394
    if (key != UNSPEC)
	lisp__data.protect.length = protect;

    return (result);
}

/* XXX The first version made a copy of the list and then adjusted
 *     the CARs of the list. To minimize GC time now it is now doing
 *     the sort inplace. So, instead of writing just (sort variable)
 *     now it is required to write (setq variable (sort variable))
 *     if the variable should always keep all elements.
 */
LispObj *
Lisp_Sort(LispBuiltin *builtin)
/*
 sort sequence predicate &key key
 */
{
    GC_ENTER();
    int istring, code;
    long length;
    char *string;

    LispObj *list, *work, *cons = NULL;

    LispObj *sequence, *predicate, *key;

    key = ARGUMENT(2);
    predicate = ARGUMENT(1);
    sequence = ARGUMENT(0);

    length = LispLength(sequence);
    if (length < 2)
	return (sequence);

    list = sequence;
    istring = XSTRINGP(sequence);
    if (istring) {
	CHECK_STRING_WRITABLE(sequence);
	/* Convert string to list */
	string = THESTR(sequence);
	work = cons = CONS(SCHAR(string[0]), NIL);
	GC_PROTECT(work);
	for (++string; *string; ++string) {
	    RPLACD(cons, CONS(SCHAR(*string), NIL));
	    cons = CDR(cons);
	}
    }
    else if (ARRAYP(list))
	work = list->data.array.list;
    else
	work = list;

    FUNCTION_CHECK(predicate);
    code = FCODE(predicate);
    work = LispMergeSort(work, predicate, key, code);

    if (istring) {
	/* Convert list to string */
	string = THESTR(sequence);
	for (; CONSP(work); ++string, work = CDR(work))
	    *string = SCHAR_VALUE(CAR(work));
    }
    else if (ARRAYP(list))
	list->data.array.list = work;
    else
	sequence = work;
    GC_LEAVE();

    return (sequence);
}

LispObj *
Lisp_Subseq(LispBuiltin *builtin)
/*
 subseq sequence start &optional end
 */
{
    long start, end, length, seqlength;

    LispObj *sequence, *ostart, *oend, *result;

    oend = ARGUMENT(2);
    ostart = ARGUMENT(1);
    sequence = ARGUMENT(0);

    LispCheckSequenceStartEnd(builtin, sequence, ostart, oend,
			      &start, &end, &length);

    seqlength = end - start;

    if (sequence == NIL)
	result = NIL;
    else if (XSTRINGP(sequence)) {
	char *string = LispMalloc(seqlength + 1);

	memcpy(string, THESTR(sequence) + start, seqlength);
	string[seqlength] = '\0';
	result = STRING2(string);
    }
    else {
	GC_ENTER();
	LispObj *object;

	if (end > start) {
	    /* list or array */
	    int count;
	    LispObj *cons;

	    if (ARRAYP(sequence))
		object = sequence->data.array.list;
	    else
		object = sequence;
	    /* goto first element to copy */
	    for (count = 0; count < start; count++, object = CDR(object))
		;
	    result = cons = CONS(CAR(object), NIL);
	    GC_PROTECT(result);
	    for (++count, object = CDR(object); count < end; count++,
		 object = CDR(object)) {
		RPLACD(cons, CONS(CAR(object), NIL));
		cons = CDR(cons);
	    }
	}
	else
	    result = NIL;

	if (ARRAYP(sequence)) {
	    object = LispNew(NIL, NIL);
	    GC_PROTECT(object);
	    object->type = LispArray_t;
	    object->data.array.list = result;
	    object->data.array.dim = CONS(FIXNUM(seqlength), NIL);
	    object->data.array.rank = 1;
	    object->data.array.type = sequence->data.array.type;
	    object->data.array.zero = length == 0;
	    result = object;
	}
	GC_LEAVE();
    }

    return (result);
}

LispObj *
Lisp_Subsetp(LispBuiltin *builtin)
/*
 subsetp list1 list2 &key test test-not key
 */
{
    return (LispListSet(builtin, SUBSETP));
}


LispObj *
Lisp_Substitute(LispBuiltin *builtin)
/*
 substitute newitem olditem sequence &key from-end test test-not start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, SUBSTITUTE, NONE));
}

LispObj *
Lisp_SubstituteIf(LispBuiltin *builtin)
/*
 substitute-if newitem test sequence &key from-end start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, SUBSTITUTE, IF));
}

LispObj *
Lisp_SubstituteIfNot(LispBuiltin *builtin)
/*
 substitute-if-not newitem test sequence &key from-end start end count key
 */
{
    return (LispDeleteRemoveXSubstitute(builtin, SUBSTITUTE, IFNOT));
}

LispObj *
Lisp_Symbolp(LispBuiltin *builtin)
/*
 symbolp object
 */
{
    LispObj *object;

    object = ARGUMENT(0);

    return (SYMBOLP(object) ? T : NIL);
}

LispObj *
Lisp_SymbolFunction(LispBuiltin *builtin)
/*
 symbol-function symbol
 */
{
    LispObj *symbol;

    symbol = ARGUMENT(0);
    CHECK_SYMBOL(symbol);

    return (LispSymbolFunction(symbol));
}

LispObj *
Lisp_SymbolName(LispBuiltin *builtin)
/*
 symbol-name symbol
 */
{
    LispObj *symbol;

    symbol = ARGUMENT(0);
    CHECK_SYMBOL(symbol);

    return (LispSymbolName(symbol));
}

LispObj *
Lisp_SymbolPackage(LispBuiltin *builtin)
/*
 symbol-package symbol
 */
{
    LispObj *symbol;

    symbol = ARGUMENT(0);
    CHECK_SYMBOL(symbol);

    symbol = symbol->data.atom->package;

    return (symbol ? symbol : NIL);
}

LispObj *
Lisp_SymbolPlist(LispBuiltin *builtin)
/*
 symbol-plist symbol
 */
{
    LispObj *symbol;

    symbol = ARGUMENT(0);

    CHECK_SYMBOL(symbol);

    return (symbol->data.atom->a_property ?
	    symbol->data.atom->property->properties : NIL);
}

LispObj *
Lisp_SymbolValue(LispBuiltin *builtin)
/*
 symbol-value symbol
 */
{
    LispAtom *atom;
    LispObj *symbol;

    symbol = ARGUMENT(0);

    CHECK_SYMBOL(symbol);
    atom = symbol->data.atom;
    if (!atom->a_object || atom->property->value == UNBOUND) {
	if (atom->package == lisp__data.keyword)
	    return (symbol);
	LispDestroy("%s: the symbol %s has no value",
		    STRFUN(builtin), STROBJ(symbol));
    }

    return (atom->dyn ? LispGetVar(symbol) : atom->property->value);
}

LispObj *
Lisp_Tagbody(LispBuiltin *builtin)
/*
 tagbody &rest body
 */
{
    GC_ENTER();
    int stack, lex, length;
    LispObj *list, *body, *ptr, *tag, *labels, *map,
	    **p_list, **p_body, **p_labels;
    LispBlock *block;

    body = ARGUMENT(0);

    /* Save environment information */
    stack = lisp__data.stack.length;
    lex = lisp__data.env.lex;
    length = lisp__data.env.length;

    /* Since the body may be large, and the code may iterate several
     * thousand times, it is not a bad idea to avoid checking all
     * elements of the body to verify if it is a tag. */
    for (labels = map = NIL, ptr = body; CONSP(ptr); ptr = CDR(ptr)) {
	tag = CAR(ptr);
	switch (OBJECT_TYPE(tag)) {
	    case LispNil_t:
	    case LispAtom_t:
	    case LispFixnum_t:
		/* Don't allow duplicated labels */
		for (list = labels; CONSP(list); list = CDDR(list)) {
		    if (CAR(list) == tag)
			LispDestroy("%s: tag %s specified more than once",
				    STRFUN(builtin), STROBJ(tag));
		}
		if (labels == NIL) {
		    labels = CONS(tag, CONS(NIL, NIL));
		    map = CDR(labels);
		    GC_PROTECT(labels);
		}
		else {
		    RPLACD(map, CONS(tag, CONS(NIL, NIL)));
		    map = CDDR(map);
		}
		break;
	    case LispCons_t:
		/* Restart point for tag */
		if (map != NIL && CAR(map) == NIL)
		    RPLACA(map, ptr);
		break;
	    default:
		break;
	}
    }
    /* Check for consecutive labels without code between them */
    for (ptr = labels; CONSP(ptr); ptr = CDDR(ptr)) {
	if (CADR(ptr) == NIL) {
	    for (map = CDDR(ptr); CONSP(map); map = CDDR(map)) {
		if (CADR(map) != NIL) {
		    RPLACA(CDR(ptr), CADR(map));
		    break;
		}
	    }
	}
    }

    /* Initialize */
    list = body;
    p_list = &list;
    p_body = &body;
    p_labels = &labels;
    block = LispBeginBlock(NIL, LispBlockBody);

    /* Loop */
    if (setjmp(block->jmp) != 0) {
	/* Restore environment */
	lisp__data.stack.length = stack;
	lisp__data.env.lex = lex;
	lisp__data.env.head = lisp__data.env.length = length;

	tag = lisp__data.block.block_ret;
	for (ptr = labels; CONSP(ptr); ptr = CDDR(ptr)) {
	    map = CAR(ptr);
	    if (map == tag)
		break;
	}

	if (!CONSP(ptr))
	    LispDestroy("%s: no such tag %s", STRFUN(builtin), STROBJ(tag));

	*p_body = CADR(ptr);
    }

    /* Execute code */
    for (; CONSP(body); body = CDR(body)) {
	LispObj *form = CAR(body);

	if (CONSP(form))
	    EVAL(form);
    }
    /* If got here, (go) not called, else, labels will be candidate to gc
     * when GC_LEAVE() be called by the code in the bottom of the stack. */
    GC_LEAVE();

    /* Finished */
    LispEndBlock(block);

    /* Always return NIL */
    return (NIL);
}

LispObj *
Lisp_The(LispBuiltin *builtin)
/*
 the value-type form
 */
{
    LispObj *value_type, *form;
d1845 1
a1845 6
    form = ARGUMENT(1);
    value_type = ARGUMENT(0);

    form = EVAL(form);

    return (LispCoerce(builtin, form, value_type));
d1849 1
a1849 4
Lisp_Throw(LispBuiltin *builtin)
/*
 throw tag result
 */
d1851 2
a1852 6
    unsigned blevel = lisp__data.block.block_level;

    LispObj *tag, *result;

    result = ARGUMENT(1);
    tag = ARGUMENT(0);
d1854 3
a1856 4
    tag = EVAL(tag);

    if (blevel == 0)
	LispDestroy("%s: not within a block", STRFUN(builtin));
d1858 1
d1860 2
a1861 1
	LispBlock *block = lisp__data.block.block[--blevel];
d1863 20
a1882 4
	if (block->type == LispBlockCatch && tag == block->tag) {
	    lisp__data.block.block_ret = EVAL(result);
	    LispBlockUnwind(block);
	    BLOCKJUMP(block);
d1884 3
d1888 3
a1890 1
    LispDestroy("%s: %s is not a valid tag", STRFUN(builtin), STROBJ(tag));
a1891 1
    /*NOTREACHED*/
d1895 2
a1896 2
static LispObj *
LispTreeEqual(LispObj *left, LispObj *right, LispObj *test, int expect)
d1898 1
a1898 1
    LispObj *cmp_left, *cmp_right;
d1900 2
a1901 28
    if ((OBJECT_TYPE(left)) ^ (OBJECT_TYPE(right)))
	return (NIL);
    if (CONSP(left)) {
	for (; CONSP(left) && CONSP(right);
	     left = CDR(left), right = CDR(right)) {
	    cmp_left = CAR(left);
	    cmp_right = CAR(right);
	    if ((OBJECT_TYPE(cmp_left)) ^ (OBJECT_TYPE(cmp_right)))
		return (NIL);
	    if (CONSP(cmp_left)) {
		if (LispTreeEqual(cmp_left, cmp_right, test, expect) == NIL)
		    return (NIL);
	    }
	    else {
		if (POINTERP(cmp_left) &&
		    (XQUOTEP(cmp_left) || XBACKQUOTEP(cmp_left))) {
		    cmp_left = cmp_left->data.quote;
		    cmp_right = cmp_right->data.quote;
		}
		else if (COMMAP(cmp_left)) {
		    cmp_left = cmp_left->data.comma.eval;
		    cmp_right = cmp_right->data.comma.eval;
		}
		if ((APPLY2(test, cmp_left, cmp_right) != NIL) != expect)
		    return (NIL);
	    }
	}
	if ((OBJECT_TYPE(left)) ^ (OBJECT_TYPE(right)))
d1903 6
d1911 6
a1916 7
    if (POINTERP(left) && (XQUOTEP(left) || XBACKQUOTEP(left))) {
	left = left->data.quote;
	right = right->data.quote;
    }
    else if (COMMAP(left)) {
	left = left->data.comma.eval;
	right = right->data.comma.eval;
d1918 1
d1920 1
a1920 1
    return ((APPLY2(test, left, right) != NIL) == expect ? T : NIL);
d1924 1
a1924 4
Lisp_TreeEqual(LispBuiltin *builtin)
/*
 tree-equal tree-1 tree-2 &key test test-not
 */
d1926 3
a1928 4
    int expect;
    LispObj *compare;

    LispObj *tree_1, *tree_2, *test, *test_not;
d1930 1
a1930 16
    test_not = ARGUMENT(3);
    test = ARGUMENT(2);
    tree_2 = ARGUMENT(1);
    tree_1 = ARGUMENT(0);

    CHECK_TEST_0();
    if (test_not != UNSPEC) {
	expect = 0;
	compare = test_not;
    }
    else {
	if (test == UNSPEC)
	    test = Oeql;
	expect = 1;
	compare = test;
    }
d1932 1
a1932 1
    return (LispTreeEqual(tree_1, tree_2, compare, expect));
d1936 1
a1936 4
Lisp_Typep(LispBuiltin *builtin)
/*
 typep object type
 */
d1938 3
a1940 3
    LispObj *result = NULL;

    LispObj *object, *type;
d1942 1
a1942 57
    type = ARGUMENT(1);
    object = ARGUMENT(0);

    if (SYMBOLP(type)) {
	Atom_id atom = ATOMID(type);

	if (OBJECT_TYPE(object) == LispStruct_t)
	    result = ATOMID(CAR(object->data.struc.def)) == atom ? T : NIL;
	else if (type->data.atom->a_defstruct &&
		 type->data.atom->property->structure.function == STRUCT_NAME)
	    result = NIL;
	else if (atom == Snil)
	    result = object == NIL ? T : NIL;
	else if (atom == St)
	    result = object == T ? T : NIL;
	else if (atom == Satom)
	    result = !CONSP(object) ? T : NIL;
	else if (atom == Ssymbol)
	    result = SYMBOLP(object) || object == NIL || object == T ? T : NIL;
	else if (atom == Sinteger)
	    result = INTEGERP(object) ? T : NIL;
	else if (atom == Srational)
	    result = RATIONALP(object) ? T : NIL;
	else if (atom == Scons || atom == Slist)
	    result = CONSP(object) ? T : NIL;
	else if (atom == Sstring)
	    result = STRINGP(object) ? T : NIL;
	else if (atom == Scharacter)
	    result = SCHARP(object) ? T : NIL;
	else if (atom == Scomplex)
	    result = COMPLEXP(object) ? T : NIL;
	else if (atom == Svector || atom == Sarray)
	    result = ARRAYP(object) ? T : NIL;
	else if (atom == Skeyword)
	    result = KEYWORDP(object) ? T : NIL;
	else if (atom == Sfunction)
	    result = LAMBDAP(object) ? T : NIL;
	else if (atom == Spathname)
	    result = PATHNAMEP(object) ? T : NIL;
	else if (atom == Sopaque)
	    result = OPAQUEP(object) ? T : NIL;
    }
    else if (CONSP(type)) {
	if (OBJECT_TYPE(object) == LispStruct_t &&
	    SYMBOLP(CAR(type)) && ATOMID(CAR(type)) == Sstruct &&
	    SYMBOLP(CAR(CDR(type))) && CDR(CDR(type)) == NIL) {
	    result = ATOMID(CAR(object->data.struc.def)) ==
		     ATOMID(CAR(CDR(type))) ? T : NIL;
	}
    }
    else if (type == NIL)
	result = object == NIL ? T : NIL;
    else if (type == T)
	result = object == T ? T : NIL;
    if (result == NULL)
	LispDestroy("%s: bad type specification %s",
		    STRFUN(builtin), STROBJ(type));
d1944 1
a1944 1
    return (result);
d1948 1
a1948 4
Lisp_Union(LispBuiltin *builtin)
/*
 union list1 list2 &key test test-not key
 */
d1950 14
a1963 1
    return (LispListSet(builtin, UNION));
d1967 1
a1967 4
Lisp_Nunion(LispBuiltin *builtin)
/*
 nunion list1 list2 &key test test-not key
 */
d1969 14
a1982 1
    return (LispListSet(builtin, NUNION));
d1986 1
a1986 4
Lisp_Unless(LispBuiltin *builtin)
/*
 unless test &rest body
 */
d1988 8
a1995 1
    LispObj *result, *test, *body;
d1997 14
a2010 2
    body = ARGUMENT(1);
    test = ARGUMENT(0);
d2012 6
a2017 7
    result = NIL;
    test = EVAL(test);
    RETURN_COUNT = 0;
    if (test == NIL) {
	for (; CONSP(body); body = CDR(body))
	    result = EVAL(CAR(body));
    }
d2019 13
a2031 2
    return (result);
}
d2033 14
a2046 10
/*
 * ext::until
 */
LispObj *
Lisp_Until(LispBuiltin *builtin)
/*
 until test &rest body
 */
{
    LispObj *result, *test, *body, *prog;
d2048 10
a2057 2
    body = ARGUMENT(1);
    test = ARGUMENT(0);
a2058 5
    result = NIL;
    for (;;) {
	if ((result = EVAL(test)) == NIL) {
	    for (prog = body; CONSP(prog); prog = CDR(prog))
		(void)EVAL(CAR(prog));
d2061 4
d2068 1
a2068 1
    return (result);
d2072 1
a2072 4
Lisp_UnwindProtect(LispBuiltin *builtin)
/*
 unwind-protect protect &rest cleanup
 */
d2074 2
a2075 3
    LispObj *result, **presult = &result;
    int did_jump, *pdid_jump = &did_jump, destroyed;
    LispBlock *block;
d2077 5
a2081 1
    LispObj *protect, *cleanup, **pcleanup = &cleanup;
d2083 6
a2088 2
    cleanup = ARGUMENT(1);
    protect = ARGUMENT(0);
d2090 6
a2095 11
    /* run protected code */
    *presult = NIL;
    *pdid_jump = 1;
    block = LispBeginBlock(NIL, LispBlockProtect);
    if (setjmp(block->jmp) == 0) {
	*presult = EVAL(protect);
	*pdid_jump = 0;
    }
    LispEndBlock(block);
    if (!lisp__data.destroyed && *pdid_jump)
	*presult = lisp__data.block.block_ret;
d2097 1
a2097 2
    destroyed = lisp__data.destroyed;
    lisp__data.destroyed = 0;
d2099 4
a2102 4
    /* run cleanup, unprotected code */
    if (CONSP(*pcleanup))
	for (; CONSP(cleanup); cleanup = CDR(cleanup))
	    (void)EVAL(CAR(cleanup));
d2104 2
a2105 7
    if (destroyed) {
	/* in case there is another unwind-protect */
	LispBlockUnwind(NULL);
	/* if not, just return to the toplevel */
	lisp__data.destroyed = 1;
	LispDestroy(".");
    }
d2107 1
a2107 2
    return (result);
}
d2109 4
a2112 5
static LispObj *
LispValuesList(LispBuiltin *builtin, int check_list)
{
    long i, count;
    LispObj *result;
d2114 7
a2120 1
    LispObj *list;
d2122 5
a2126 1
    list = ARGUMENT(0);
d2128 25
a2152 12
    count = LispLength(list) - 1;

    if (count >= 0) {
	result = CAR(list);
	if ((RETURN_CHECK(count)) != count)
	    LispDestroy("%s: too many values", STRFUN(builtin));
	RETURN_COUNT = count;
	for (i = 0, list = CDR(list); count && CONSP(list);
	     count--, i++, list = CDR(list))
	    RETURN(i) = CAR(list);
	if (check_list) {
	    CHECK_LIST(list);
d2154 1
a2154 4
    }
    else {
	RETURN_COUNT = -1;
	result = NIL;
d2157 1
a2157 1
    return (result);
d2161 1
a2161 4
Lisp_Values(LispBuiltin *builtin)
/*
 values &rest objects
 */
d2163 10
a2172 1
    return (LispValuesList(builtin, 0));
d2176 1
a2176 4
Lisp_ValuesList(LispBuiltin *builtin)
/*
 values-list list
 */
d2178 10
a2187 1
    return (LispValuesList(builtin, 1));
d2191 1
a2191 4
Lisp_Vector(LispBuiltin *builtin)
/*
 vector &rest objects
 */
d2193 74
a2266 1
    LispObj *objects;
d2268 14
a2281 1
    objects = ARGUMENT(0);
d2283 1
a2283 1
    return (VECTOR(objects));
d2287 1
a2287 4
Lisp_When(LispBuiltin *builtin)
/*
 when test &rest body
 */
d2289 1
a2289 1
    LispObj *result, *test, *body;
d2291 11
a2301 2
    body = ARGUMENT(1);
    test = ARGUMENT(0);
d2303 1
a2303 9
    result = NIL;
    test = EVAL(test);
    RETURN_COUNT = 0;
    if (test != NIL) {
	for (; CONSP(body); body = CDR(body))
	    result = EVAL(CAR(body));
    }

    return (result);
a2305 3
/*
 * ext::while
 */
d2307 1
a2307 4
Lisp_While(LispBuiltin *builtin)
/*
 while test &rest body
 */
d2309 5
a2313 1
    LispObj *result, *test, *body, *prog;
d2315 3
a2317 2
    body = ARGUMENT(1);
    test = ARGUMENT(0);
d2319 25
a2343 5
    result = NIL;
    for (;;) {
	if (EVAL(test) != NIL) {
	    for (prog = body; CONSP(prog); prog = CDR(prog))
		(void)EVAL(CAR(prog));
a2344 2
	else
	    break;
d2346 2
a2351 3
/*
 * ext::unsetenv
 */
d2353 1
a2353 4
Lisp_Unsetenv(LispBuiltin *builtin)
/*
 unsetenv name
 */
d2355 3
a2357 1
    char *name;
d2359 19
a2377 1
    LispObj *oname;
d2379 5
a2383 6
    oname = ARGUMENT(0);

    CHECK_STRING(oname);
    name = THESTR(oname);

    unsetenv(name);
d2389 1
a2389 4
Lisp_XeditEltStore(LispBuiltin *builtin)
/*
 lisp::elt-store sequence index value
 */
d2391 2
a2392 1
    int length, offset;
d2394 6
a2399 1
    LispObj *sequence, *oindex, *value;
d2401 7
a2407 22
    value = ARGUMENT(2);
    oindex = ARGUMENT(1);
    sequence = ARGUMENT(0);

    CHECK_INDEX(oindex);
    offset = FIXNUM_VALUE(oindex);
    length = LispLength(sequence);

    if (offset >= length)
	LispDestroy("%s: index %d too large for sequence length %d",
		    STRFUN(builtin), offset, length);

    if (STRINGP(sequence)) {
	int ch;

	CHECK_STRING_WRITABLE(sequence);
	CHECK_SCHAR(value);
	ch = SCHAR_VALUE(value);
	if (ch < 0 || ch > 255)
	    LispDestroy("%s: cannot represent character %d",
			STRFUN(builtin), ch);
	THESTR(sequence)[offset] = ch;
d2409 3
a2411 3
    else {
	if (ARRAYP(sequence))
	    sequence = sequence->data.array.list;
d2413 6
a2418 4
	for (; offset > 0; offset--, sequence = CDR(sequence))
	    ;
	RPLACA(sequence, value);
    }
d2420 1
a2420 1
    return (value);
d2424 1
a2424 4
Lisp_XeditPut(LispBuiltin *builtin)
/*
 lisp::put symbol indicator value
 */
d2426 2
a2427 1
    LispObj *symbol, *indicator, *value;
d2429 3
a2431 3
    value = ARGUMENT(2);
    indicator = ARGUMENT(1);
    symbol = ARGUMENT(0);
d2433 7
a2439 1
    CHECK_SYMBOL(symbol);
d2441 1
a2441 1
    return (CAR(LispPutAtomProperty(symbol->data.atom, indicator, value)));
d2445 1
a2445 4
Lisp_XeditSetSymbolPlist(LispBuiltin *builtin)
/*
 lisp::set-symbol-plist symbol list
 */
d2447 2
a2448 1
    LispObj *symbol, *list;
d2450 5
a2454 2
    list = ARGUMENT(1);
    symbol = ARGUMENT(0);
d2456 4
a2459 3
    CHECK_SYMBOL(symbol);

    return (LispReplaceAtomPropertyList(symbol->data.atom, list));
d2462 3
d2466 1
a2466 4
Lisp_XeditVectorStore(LispBuiltin *builtin)
/*
 lisp::vector-store array &rest values
 */
d2468 18
a2485 2
    LispObj *value, *list, *object;
    long rank, count, sequence, offset, accum;
d2487 3
a2489 1
    LispObj *array, *values;
d2491 3
a2493 2
    values = ARGUMENT(1);
    array = ARGUMENT(0);
d2495 5
a2499 5
    /* check for errors */
    for (rank = 0, list = values;
	 CONSP(list) && CONSP(CDR(list));
	 list = CDR(list), rank++) {
	CHECK_INDEX(CAR(values));
d2501 3
d2505 1
a2505 44
    if (rank == 0)
	LispDestroy("%s: too few subscripts", STRFUN(builtin));
    value = CAR(list);

    if (STRINGP(array) && rank == 1) {
	long ch;
	long length = STRLEN(array);
	long offset = FIXNUM_VALUE(CAR(values));

	CHECK_SCHAR(value);
	CHECK_STRING_WRITABLE(array);
	ch = SCHAR_VALUE(value);
	if (offset >= length)
	    LispDestroy("%s: index %ld too large for sequence length %ld",
			STRFUN(builtin), offset, length);

	if (ch < 0 || ch > 255)
	    LispDestroy("%s: cannot represent character %ld",
			STRFUN(builtin), ch);
	THESTR(array)[offset] = ch;

	return (value);
    }

    CHECK_ARRAY(array);
    if (rank != array->data.array.rank)
	LispDestroy("%s: too %s subscripts", STRFUN(builtin),
		    rank < array->data.array.rank ? "few" : "many");

    for (list = values, object = array->data.array.dim;
	 CONSP(CDR(list));
	 list = CDR(list), object = CDR(object)) {
	if (FIXNUM_VALUE(CAR(list)) >= FIXNUM_VALUE(CAR(object)))
	    LispDestroy("%s: %ld is out of range, index %ld",
			STRFUN(builtin),
			FIXNUM_VALUE(CAR(list)),
			FIXNUM_VALUE(CAR(object)));
    }

    for (count = sequence = 0, list = values;
	 CONSP(CDR(list));
	 list = CDR(list), sequence++) {
	for (offset = 0, object = array->data.array.dim;
	     offset < sequence; object = CDR(object), offset++)
d2507 1
a2507 4
	for (accum = 1, object = CDR(object); CONSP(object);
	     object = CDR(object))
	    accum *= FIXNUM_VALUE(CAR(object));
	count += accum * FIXNUM_VALUE(CAR(list));
d2510 7
a2516 2
    for (array = array->data.array.list; count > 0; array = CDR(array), count--)
	;
d2518 6
a2523 1
    RPLACA(array, value);
d2525 1
a2525 1
    return (value);
d2529 1
a2529 4
Lisp_XeditDocumentationStore(LispBuiltin *builtin)
/*
 lisp::documentation-store symbol type string
 */
d2531 29
a2559 1
    LispDocType_t doc_type;
d2561 2
a2562 1
    LispObj *symbol, *type, *string;
d2564 1
a2564 3
    string = ARGUMENT(2);
    type = ARGUMENT(1);
    symbol = ARGUMENT(0);
d2566 2
a2567 1
    CHECK_SYMBOL(symbol);
d2569 4
a2572 2
    /* type is checked in LispDocumentationType() */
    doc_type = LispDocumentationType(builtin, type);
d2574 2
a2575 7
    if (string == NIL)
	/* allow explicitly releasing memory used for documentation */
	LispRemDocumentation(symbol, doc_type);
    else {
	CHECK_STRING(string);
	LispAddDocumentation(symbol, string, doc_type);
    }
d2577 1
a2577 1
    return (string);
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d30 1
a30 1
/* $XFree86: xc/programs/xedit/lisp/core.c,v 1.72 2003/05/27 22:27:01 tsi Exp $ */
d32 7
a38 7
#include "lisp/io.h"
#include "lisp/core.h"
#include "lisp/format.h"
#include "lisp/helper.h"
#include "lisp/package.h"
#include "lisp/private.h"
#include "lisp/write.h"
a64 4
#ifdef __UNIXOS2__
# define finite(x) isfinite(x)
#endif

d583 1
a583 1
    LispObj *res, **pres = &res;
d595 1
d782 1
a782 1
    LispObj *tag, *body;
d787 1
d1016 1
a1016 1
    LispObj *form;
d1018 1
d1939 2
a1940 2
    LispObj *result;
    int i, jumped;
d1966 3
d2621 2
a2622 1
	    *displaced_to, *displaced_index_offset;
d2629 2
d4053 3
a4055 3
    LispObj *result, *list, *symbol, *value;
    int jumped;
    char fstk[32], *flags;
d4078 9
d6305 2
a6306 1
    LispObj *list, *body, *ptr, *tag, *labels, *map, **p_body;
d6364 1
d6366 1
d6813 1
a6813 1
    LispObj *test, *body, *prog;
d6818 1
@


