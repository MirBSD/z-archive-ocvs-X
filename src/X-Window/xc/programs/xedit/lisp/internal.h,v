head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.10.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.10.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.39.50;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.39.11;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.28.30;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (c) 2001 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *  
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of the XFree86 Project shall
 * not be used in advertising or otherwise to promote the sale, use or other
 * dealings in this Software without prior written authorization from the
 * XFree86 Project.
 *
 * Author: Paulo César Pereira de Andrade
 */

/* $XFree86: xc/programs/xedit/lisp/internal.h,v 1.11 2001/10/20 00:19:34 paulo Exp $ */

#ifndef Lisp_internal_h
#define Lisp_internal_h

#include <stdio.h>
#include "lisp.h"

/*
 * Defines
 */
#define	CAR(list)		((list)->data.cons.car)
#define	CAAR(list)		((list)->data.cons.car->data.cons.car)
#define	CADR(list)		((list)->data.cons.cdr->data.cons.car)
#define CDR(list)		((list)->data.cons.cdr)
#define CDAR(list)		((list)->data.cons.car->data.cons.cdr)
#define CONS(car, cdr)		LispNewCons(mac, car, cdr)
#define EVAL(list)		LispEval(mac, list)
#define ATOM(atom)		LispNewAtom(mac, atom)
#define ATOM2(atom)		LispNewAtom(mac, LispGetString(mac, atom))
#define QUOTE(quote)		LispNewQuote(mac, quote)
#define BACKQUOTE(bquote)	LispNewBackquote(mac, bquote)
#define COMMA(comma, at)	LispNewComma(mac, comma, at)
#define REAL(num)		LispNewReal(mac, num)
#define STRING(str)		LispNewString(mac, str)
#define CHAR(c)			LispNewCharacter(mac, c)
#define INTEGER(i)		LispNewInteger(mac, i)
#define OPAQUE(data, type)	LispNewOpaque(mac, (void*)((long)data), type)
#define CHECKO(obj, typ)						\
	(obj)->type == LispOpaque_t && 					\
	 ((obj)->data.opaque.type == typ || (obj)->data.opaque.type == 0)
#define PROTECT(key, list)	LispProtect(mac, key, list)
#define UPROTECT(key, list)	LispUProtect(mac, key, list)

#define	GCProtect()		++gcpro
#define	GCUProtect()		--gcpro

#define	STRPTR(obj)		(obj)->data.atom->string

#define NUMBER_P(obj)			\
	((obj)->type == LispReal_t || (obj)->type == LispInteger_t)

/* assumes NUMBER_P is true */
#define NUMBER_VALUE(obj)		\
	(obj->type == LispReal_t ? obj->data.real : obj->data.integer)

#define INTEGER_P(obj)			\
	((obj)->type == LispInteger_t ||	\
	 ((obj)->type == LispReal_t && (long)(obj)->data.real == (obj)->data.real))

/* positive integer */
#define INDEX_P(obj)		(INTEGER_P(obj) && NUMBER_VALUE(obj) >= 0)

#define SYMBOL_P(obj)		((obj)->type == LispAtom_t)
#define STRING_P(obj)		((obj)->type == LispString_t)

/*
 * Types
 */
typedef struct _LispObj LispObj;
typedef struct _LispAtom LispAtom;
typedef struct _LispBuiltin LispBuiltin;
typedef struct _LispModuleData LispModuleData;

typedef enum _LispType {
    LispNil_t,
    LispTrue_t,
    LispAtom_t,
    LispInteger_t,
    LispReal_t,
    LispCons_t,
    LispQuote_t,
    LispCharacter_t,
    LispString_t,
    LispLambda_t,
    LispArray_t,
    LispStruct_t,
    LispStream_t,
    LispOpaque_t,
    LispBackquote_t,
    LispComma_t
} LispType;

typedef enum _LispFunType {
    LispLambda,
    LispFunction,
    LispMacro,
    LispSetf
} LispFunType;

struct _LispObj {
    LispType type : 6;
    unsigned int mark : 1;	/* gc protected */
    unsigned int dirty : 1;
    unsigned int prot: 1;	/* protection for constant/unamed variables */
    union {
	LispAtom *atom;
	long integer;
	double real;
	LispObj *quote;
	struct {
	    LispObj *car;
	    LispObj *cdr;
	} cons;
	struct {
	    LispObj *name;
	    LispObj *code;
	    unsigned int num_args : 12;
	    LispFunType type : 4;
	    unsigned int key : 1;
	    unsigned int optional : 1;
	    unsigned int rest : 1;
	} lambda;
	struct {
	    LispObj *list;		/* stored as a linear list */
	    LispObj *dim;		/* dimensions of array */
	    unsigned int rank : 8;	/* i.e. array-rank-limit => 256 */
	    unsigned int type : 7;	/* converted to LispType, if not
					 * Lisp{Nil,True}_t only accepts given
					 * type in array fields */
	    unsigned int zero : 1;	/* at least one of the dimensions
					 * is zero */
	} array;
	struct {
	    LispObj *fields;	/* structure fields */
	    LispObj *def;	/* structure definition */
	} struc;
	struct {
	    union {
		FILE *fp;
		unsigned char *str;
	    } source;
	    int size;		/* if smaller than zero, use source.fp */
	    int idx;		/* index in string */
	} stream;
	struct {
	    void *data;
	    int type;
	} opaque;
	struct {
	    LispObj *eval;
	    int atlist;
	} comma;
    } data;
};

struct _LispBuiltin {
    char *name;
    LispObj *(*fn)(LispMac*, LispObj*, char*);
    int eval : 1;
    int min_args : 15;
    int max_args : 15;
};

typedef	LispObj *(*LispFunPtr)(LispMac*, LispObj*, char*);
typedef int (*LispLoadModule)(LispMac*);
typedef int (*LispUnloadModule)(LispMac*);

#define LISP_MODULE_VERSION		1
struct _LispModuleData {
    int version;
    LispLoadModule load;
    LispUnloadModule unload;
};

/*
 * Prototypes
 */
LispObj *LispEval(LispMac*, LispObj*);

LispObj *LispNew(LispMac*, LispObj*, LispObj*);
LispObj *LispNewAtom(LispMac*, char*);
LispObj *LispNewReal(LispMac*, double);
LispObj *LispNewString(LispMac*, char*);
LispObj *LispNewCharacter(LispMac*, long);
LispObj *LispNewInteger(LispMac*, long);
LispObj *LispNewQuote(LispMac*, LispObj*);
LispObj *LispNewBackquote(LispMac*, LispObj*);
LispObj *LispNewComma(LispMac*, LispObj*, int);
LispObj *LispNewCons(LispMac*, LispObj*, LispObj*);
LispObj *LispNewSymbol(LispMac*, char*, LispObj*);
LispObj *LispNewLambda(LispMac*, LispObj*, LispObj*, LispObj*,
		       int, LispFunType, int, int, int);
LispObj *LispNewStruct(LispMac*, LispObj*, LispObj*);
LispObj *LispNewOpaque(LispMac*, void*, int);

char *LispGetString(LispMac*, char*);

/* This function does not allocate a copy of it's argument, but the argument
 * itself. The argument string should never change. */
char *LispGetPermString(LispMac*, char*);

void *LispMalloc(LispMac*, unsigned);
void *LispCalloc(LispMac*, unsigned, unsigned);
void *LispRealloc(LispMac*, void*, unsigned);
char *LispStrdup(LispMac*, char*);
void LispFree(LispMac*, void*);
/* LispMused means memory is now safe from LispDestroy, and should not be
 * freed in case of an error */
void LispMused(LispMac*, void*);

void LispGC(LispMac*, LispObj*, LispObj*);

char *LispStrObj(LispMac*, LispObj*);

void LispDestroy(LispMac *mac, char *fmt, ...);

LispObj *LispSetVariable(LispMac*, LispObj*, LispObj*, char*, int);

int LispRegisterOpaqueType(LispMac*, char*);

int LispPrintf(LispMac*, LispObj*, char*, ...);
int LispPrintString(LispMac*, LispObj*, char*);
int LispPrintObj(LispMac*, LispObj*, LispObj*, int);

void LispProtect(LispMac*, LispObj*, LispObj*);
void LispUProtect(LispMac*, LispObj*, LispObj*);

/* search argument list for the specified keys.
 * example: LispGetKeys(mac, fname, "START:END", list, &start, &end);
 * note that the separator for key names is the ':' character.
 * values not present in the argument list get the default value of NIL,
 * values specified more than once get only the first specification,
 * and if an unknown is on the argument list, a fatal error happens. */
void LispGetKeys(LispMac*, char*, char*, LispObj*, ...);

/* this function should be called when a module is loaded, and is called
 * when loading the interpreter */
void LispAddBuiltinFunction(LispMac*, LispBuiltin*);

/*
 * Initialization
 */
extern LispObj *NIL, *T;
extern int gcpro;
extern FILE *lisp_stdin, *lisp_stdout, *lisp_stderr;

#endif /* Lisp_internal_h */
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d30 1
a30 1
/* $XFree86: xc/programs/xedit/lisp/internal.h,v 1.51 2003/05/27 22:27:03 tsi Exp $ */
d36 1
a36 4
#include "lisp/lisp.h"

#include "mp.h"
#include "re.h"
a40 9
typedef struct _LispMac LispMac;

#define STREAM_READ		0x01
#define STREAM_WRITE		0x02
#define STREAM_BINARY		0x20

#define RPLACA(cons, object)	(CAR(cons) = object)
#define RPLACD(cons, object)	(CDR(cons) = object)

d46 12
a57 47
#define CDDR(list)		((list)->data.cons.cdr->data.cons.cdr)
#define CONS(car, cdr)		LispNewCons(car, cdr)
#define EVAL(list)		LispEval(list)
#define APPLY(fun, args)	LispFuncall(fun, args, 0)
#define APPLY1(fun, arg)	LispApply1(fun, arg)
#define APPLY2(fun, arg1, arg2)	LispApply2(fun, arg1, arg2)
#define APPLY3(f, a1, a2, a3)	LispApply3(f, a1, a2, a3)
#define EXECUTE(string)		LispExecute(string)
#define SYMBOL(atom)		LispNewSymbol(atom)
#define ATOM(string)		LispNewAtom(string, 1)
#define UNINTERNED_ATOM(string)	LispNewAtom(string, 0)
#define FUNCTION(symbol)	LispNewFunction(symbol)
#define FUNCTION_QUOTE(symbol)	LispNewFunctionQuote(symbol)

	/* atom string is a static variable */
#define ATOM2(string)		LispNewSymbol(LispGetPermAtom(string))

	/* make a gc never released variable with a static string argument */
#define STATIC_ATOM(string)	LispNewStaticAtom(string)

#define STRING(str)		LispNewString(str, strlen(str), 0)
#define LSTRING(str, size)	LispNewString(str, size, 0)

	/* string must be from the LispXXX allocation functions,
	 * and LispMused not yet called on it */
#define STRING2(str)		LispNewString(str, strlen(str), 1)
#define LSTRING2(str, size)	LispNewString(str, size, 1)

#define VECTOR(objects)		LispNewVector(objects)

	/* STRINGSTREAM2 and LSTRINGSTREAM2 require that the
	 * string be allocated from the LispXXX allocation functions,
	 * and LispMused not yet called on it */
#define STRINGSTREAM(str, flag)			\
	LispNewStringStream(str, flag, strlen(str), 0)
#define STRINGSTREAM2(str, flag)		\
	LispNewStringStream(str, flag, strlen(str), 1)
#define LSTRINGSTREAM(str, flag, length)	\
	LispNewStringStream(str, flag, length, 0)
#define LSTRINGSTREAM2(str, flag, length)	\
	LispNewStringStream(str, flag, length, 1)

#define FILESTREAM(file, path, flag)	\
	LispNewFileStream(file, path, flag)
#define PIPESTREAM(file, path, flag)	\
	LispNewPipeStream(file, path, flag)

d59 4
a62 348
	((obj)->type == LispOpaque_t && 				\
	 ((obj)->data.opaque.type == typ || (obj)->data.opaque.type == 0))
#define PROTECT(key, list)	LispProtect(key, list)
#define UPROTECT(key, list)	LispUProtect(key, list)

/* create a new unique static atom string */
#define GETATOMID(string)	LispGetAtomString(string, 1)

#define	GCDisable()		++gcpro
#define	GCEnable()		--gcpro


/* pointer to something unique to all atoms with the same print representation */
#define ATOMID(object)		(object)->data.atom->string



#define NIL_BIT			0x01
#define FIXNUM_BIT		0x02
#define FIXNUM_MASK		0x03
#define SCHAR_BIT		0x04
#define SCHAR_MASK		0x05
#define BIT_COUNT		4
#define BIT_MASK		0x0f
#define POINTERP(object)						\
    (((unsigned long)(object) & NIL_BIT) == 0)

#define MOST_POSITIVE_FIXNUM	((1L << (sizeof(long) * 8 - 5)) - 1)
#define MOST_NEGATIVE_FIXNUM	(-1L << (sizeof(long) * 8 - 5))

#define SCHAR(value)							\
    ((LispObj*)(((long)(value) << BIT_COUNT) | SCHAR_MASK))
#define SCHAR_VALUE(object)	FIXNUM_VALUE(object)
#define SCHARP(object)							\
    (((unsigned long)(object) & BIT_MASK) == SCHAR_MASK)
#define CHECK_SCHAR(object)						\
    if (!SCHARP(object))						\
	LispDestroy("%s: %s is not a character",			\
		    STRFUN(builtin), STROBJ(object))

#define XOBJECT_TYPE(object)	((object)->type)
#define OBJECT_TYPE(object)	(POINTERP(object) ?			\
				XOBJECT_TYPE(object) :			\
				(LispType)((long)(object) & BIT_MASK))


#define NIL			(LispObj*)0x00000001
#define T			(LispObj*)0x00000011
#define DOT			(LispObj*)0x00000021
/* unmatched ')' */
#define	EOLIST			(LispObj*)0x00000031
#define READLABEL_MASK		0x00000041
/* unspecified argument */
#define UNSPEC			(LispObj*)0x00000051
#define INVALIDP(object)						\
    ((object) == NULL || (object) == EOLIST || (object) == DOT)


/* cons */
#define XCONSP(object)		((object)->type == LispCons_t)
#define CONSP(object)		(POINTERP(object) && XCONSP(object))
#define CHECK_CONS(object)						\
    if (!CONSP(object))							\
	LispDestroy("%s: %s is not of type cons",			\
		    STRFUN(builtin), STROBJ(object))
#define LISTP(object)		(object == NIL || CONSP(object))
#define CHECK_LIST(object)						\
    if (!LISTP(object))							\
	LispDestroy("%s: %s is not a list",				\
		    STRFUN(builtin), STROBJ(object))

/* fixnum */
#define FIXNUM(value)							\
    ((LispObj*)(((long)(value) << BIT_COUNT) | FIXNUM_MASK))
#define FIXNUM_VALUE(object)	((long)(object) >> BIT_COUNT)
#define FIXNUMP(object)							\
    (((unsigned long)(object) & BIT_MASK) == FIXNUM_MASK)
#define CHECK_FIXNUM(object)						\
    if (!FIXNUMP(object))						\
	LispDestroy("%s: %s is not a fixnum",				\
		    STRFUN(builtin), STROBJ(object))
#define INDEXP(object)							\
    (FIXNUMP(object) && FIXNUM_VALUE(object) >= 0)
#define CHECK_INDEX(object)						\
    if (!INDEXP(object))						\
	LispDestroy("%s: %s is not a positive fixnum",			\
		    STRFUN(builtin), STROBJ(object))


/* long int integer */
#define XINTP(object)		((object)->type == LispInteger_t)
#define INTP(objet)		(POINTERP(object) && XINTP(object))
#define INT_VALUE(object)	(object)->data.integer


/* values that fit in a machine long int but not in a fixnum */
#define LONGINTP(object)						\
    (POINTERP(object) ? XINTP(object) : FIXNUMP(object))
#define LONGINT_VALUE(object)						\
    (POINTERP(object) ? INT_VALUE(object) : FIXNUM_VALUE(object))
#define CHECK_LONGINT(object)						\
    if (!LONGINTP(object))						\
	LispDestroy("%s: %s is not an integer",				\
		    STRFUN(builtin), STROBJ(object))


/* bignum */
#define XBIGNUMP(object)	((object)->type == LispBignum_t)
#define BIGNUMP(object)		(POINTERP(object) && XBIGNUMP(object))
#define BIGNUM(object)		LispNewBignum(object)


/* generic integer */
#define INTEGER(integer)	LispNewInteger(integer)
#define INTEGERP(object)						\
    (POINTERP(object) ? XINTP(object) || XBIGNUMP(object) : FIXNUMP(object))
#define CHECK_INTEGER(object)						\
    if (!INTEGERP(object))						\
	LispDestroy("%s: %s is not an integer",				\
		    STRFUN(builtin), STROBJ(object))


/* ratio */
#define XRATIOP(object)		((object)->type == LispRatio_t)
#define RATIOP(object)		(POINTERP(object) && XRATIOP(object))
#define RATIO(num, den)		LispNewRatio(num, den)


/* bigratio */
#define XBIGRATIOP(object)	((object)->type == LispBigratio_t)
#define BIGRATIOP(object)	(POINTERP(object) && XBIGRATIOP(object))
#define BIGRATIO(ratio)		LispNewBigratio(ratio)


/* generic rational */
#define RATIONALP(object)						\
    (POINTERP(object) ? XINTP(object) || XRATIOP(object) ||		\
			XBIGNUMP(object) || XBIGRATIOP(object) :	\
			FIXNUMP(object))


/* double float */
#define XDFLOATP(object)	((object)->type == LispDFloat_t)
#define DFLOATP(object)		(POINTERP(object) && XDFLOATP(object))
#define DFLOAT_VALUE(object)	(object)->data.dfloat
#define CHECK_DFLOAT(object)						\
    if (!DFLOATP(object))						\
	LispDestroy("%s: %s is not a float number",			\
		    STRFUN(builtin), STROBJ(object))
#define DFLOAT(value)		LispNewDFloat(value)


/* generic float - currently only double float supported */
#define FLOATP(object)		DFLOATP(object)


/* real number */
#define REALP(object)							\
    (POINTERP(object) ? XINTP(object) || XDFLOATP(object) ||		\
			XRATIOP(object) || XBIGNUMP(object) ||		\
			XBIGRATIOP(object) :				\
			FIXNUMP(object))
#define CHECK_REAL(object)						\
    if (!REALP(object))							\
	LispDestroy("%s: %s is not a real number",			\
		    STRFUN(builtin), STROBJ(object))


/* complex */
#define XCOMPLEXP(object)	((object)->type == LispComplex_t)
#define COMPLEXP(object)	(POINTERP(object) && XCOMPLEXP(object))
#define COMPLEX(real, imag)	LispNewComplex(real, imag)


/* generic number */
#define NUMBERP(object)							\
    (POINTERP(object) ? XINTP(object) || XDFLOATP(object) ||		\
			XRATIOP(object) || XBIGNUMP(object) ||		\
			XBIGRATIOP(object) || XCOMPLEXP(object) :	\
			FIXNUMP(object))
#define CHECK_NUMBER(object)						\
    if (!NUMBERP(object))						\
	LispDestroy("%s: %s is not a number",				\
		    STRFUN(builtin), STROBJ(object))


/* symbol */
#define XSYMBOLP(object)	((object)->type == LispAtom_t)
#define SYMBOLP(object)		(POINTERP(object) && XSYMBOLP(object))
#define CHECK_SYMBOL(object)						\
    if (!SYMBOLP(object))						\
	LispDestroy("%s: %s is not a symbol",				\
		    STRFUN(builtin), STROBJ(object))


/* keyword */
#define XKEYWORDP(object)						\
    ((object)->data.atom->package == lisp__data.keyword)
#define KEYWORDP(object)						\
    (POINTERP(object) && XSYMBOLP(object) && XKEYWORDP(object))
#define KEYWORD(string)		LispNewKeyword(string)
#define CHECK_KEYWORD(object)						\
    if (!KEYWORDP(object))						\
	LispDestroy("%s: %s is not a keyword",				\
		    STRFUN(builtin), STROBJ(object))
#define CHECK_CONSTANT(object)						\
    if ((object)->data.atom->constant)					\
	LispDestroy("%s: %s is a constant",				\
		    STRFUN(builtin), STROBJ(object))

#define SETVALUE(atom, object)	((atom)->property->value = object)


/* function */
#define XFUNCTIONP(object)	((object)->type == LispFunction_t)
#define FUNCTIONP(object)	(POINTERP(object) && XFUNCTIONP(object))


/* lambda */
#define XLAMBDAP(object)	((object)->type == LispLambda_t)
#define LAMBDAP(object)		(POINTERP(object) && XLAMBDAP(object))


/* string - currently only simple 8 bit characters */
#define XSTRINGP(object)	((object)->type == LispString_t)
#define STRINGP(object)		(POINTERP(object) && XSTRINGP(object))
#define THESTR(object)		(object)->data.string.string
#define STRLEN(object)		(object)->data.string.length
#define CHECK_STRING(object)						\
    if (!STRINGP(object))						\
	LispDestroy("%s: %s is not a string",				\
		    STRFUN(builtin), STROBJ(object))
#define CHECK_STRING_WRITABLE(object)					\
    if (!object->data.string.writable)					\
	LispDestroy("%s: %s is readonly",				\
		    STRFUN(builtin), STROBJ(object))


/* array/vector */
#define XARRAYP(object)		((object)->type == LispArray_t)
#define ARRAYP(object)		(POINTERP(object) && XARRAYP(object))
#define CHECK_ARRAY(object)						\
    if (!ARRAYP(object))						\
	LispDestroy("%s: %s is not an array",				\
		    STRFUN(builtin), STROBJ(object))


/* quote */
#define XQUOTEP(object)		((object)->type == LispQuote_t)
#define QUOTEP(object)		(POINTERP(object) && XQUOTEP(object))
#define QUOTE(object)		LispNewQuote(object)

#define XBACKQUOTEP(object)	((object)->type == LispBackquote_t)
#define BACKQUOTEP(object)	(POINTERP(object) && XBACKQUOTEP(object))
#define BACKQUOTE(object)	LispNewBackquote(object)

#define XCOMMAP(object)		((object)->type == LispComma_t)
#define COMMAP(object)		(POINTERP(object) && XCOMMAP(object))
#define COMMA(object, at)	LispNewComma(object, at)


/* package */
#define XPACKAGEP(object)	((object)->type == LispPackage_t)
#define PACKAGEP(object)	(POINTERP(object) && XPACKAGEP(object))


/* pathname */
#define XPATHNAMEP(object)	((object)->type == LispPathname_t)
#define PATHNAMEP(object)	(POINTERP(object) && XPATHNAMEP(object))
#define PATHNAME(object)	LispNewPathname(object)
#define CHECK_PATHNAME(object)						\
    if (!PATHNAMEP(object))						\
	LispDestroy("%s: %s is not a pathname",				\
		    STRFUN(builtin), STROBJ(object))


/* stream */
#define XSTREAMP(object)	((object)->type == LispStream_t)
#define STREAMP(object)		(POINTERP(object) && XSTREAMP(object))
#define CHECK_STREAM(object)						\
    if (!STREAMP(object))						\
	LispDestroy("%s: %s is not a stream",				\
		    STRFUN(builtin), STROBJ(object))


/* hastable */
#define XHASHTABLEP(object)	((object)->type == LispHashTable_t)
#define HASHTABLEP(object)	(POINTERP(object) && XHASHTABLEP(object))
#define CHECK_HASHTABLE(object)						\
    if (!HASHTABLEP(object))						\
	LispDestroy("%s: %s is not a hash-table",			\
		    STRFUN(builtin), STROBJ(object))


/* regex */
#define XREGEXP(object)		((object)->type == LispRegex_t)
#define REGEXP(object)		(POINTERP(object) && XREGEXP(object))
#define CHECK_REGEX(object)						\
    if (!REGEXP(object))						\
	LispDestroy("%s: %s is not a regexp",				\
		    STRFUN(builtin), STROBJ(object))


/* bytecode */
#define XBYTECODEP(object)	((object)->type == LispBytecode_t)
#define BYTECODEP(object)	(POINTERP(object) && XBYTECODEP(object))


/* opaque */
#define XOPAQUEP(object)	((object)->type == LispOpaque_t)
#define OPAQUEP(object)		(POINTERP(object) && XOPAQUEP(object))
#define OPAQUE(data, type)	LispNewOpaque((void*)((long)data), type)



#define SSTREAMP(str)		((str)->data.stream.source.string)

#define FSTREAMP(str)		((str)->data.stream.source.file)

#define PSTREAMP(str)		((str)->data.stream.source.program)
#define PIDPSTREAMP(str)	((str)->data.stream.source.program->pid)
#define IPSTREAMP(str)		((str)->data.stream.source.program->input)
#define OPSTREAMP(str)		((str)->data.stream.source.program->output)
#define EPSTREAMP(str)		\
	FSTREAMP((str)->data.stream.source.program->errorp)

#define LispFileno(file)	((file)->descriptor)

#define STRFUN(builtin)		ATOMID(builtin->symbol)
#define STROBJ(obj)		LispStrObj(obj)

/* fetch builtin function/macro argument value
 */
#define ARGUMENT(index)							\
	lisp__data.stack.values[lisp__data.stack.base + (index)]

#define RETURN(index)	lisp__data.returns.values[(index)]
#define RETURN_COUNT	lisp__data.returns.count
#define RETURN_CHECK(value)						\
    value < MULTIPLE_VALUES_LIMIT ?					\
	value : MULTIPLE_VALUES_LIMIT

#define GC_ENTER()		int gc__protect = lisp__data.protect.length

#define GC_PROTECT(object)						\
    if (lisp__data.protect.length >= lisp__data.protect.space)		\
	LispMoreProtects();						\
    lisp__data.protect.objects[lisp__data.protect.length++] = object
d64 2
a65 1
#define GC_LEAVE()		lisp__data.protect.length = gc__protect
d67 1
d69 2
a70 4
#define ERROR_CHECK_SPECIAL_FORM(atom)					\
    if (atom->property->fun.builtin->compile)				\
	LispDestroy("%s: the special form %s cannot be redefined",	\
		    STRFUN(builtin), atom->string)
d72 3
d76 3
d80 2
a81 8
#define CONSTANTP(object)						\
    (!POINTERP(object) ||						\
     XOBJECT_TYPE(object) < LispAtom_t ||				\
     (XSYMBOLP(object) && XKEYWORDP(object)))

/* slightly faster test, since keywords are very uncommon as eval arguments */
#define NCONSTANTP(object)						\
    (OBJECT_TYPE(object) >= LispAtom_t)
d83 2
a92 10
typedef struct _LispFile LispFile;
typedef struct _LispString LispString;
typedef struct _LispPackage LispPackage;
typedef struct _LispBytecode LispBytecode;
typedef struct _LispHashTable LispHashTable;

/* Bytecode compiler data */
typedef struct _LispCom LispCom;

typedef char *Atom_id;
d95 2
a96 16
    /* objects encoded in the LispObj pointer */
    LispNil_t = 1,
    LispFixnum_t = 3,
    LispSChar_t = 5,

    /* objects that have a structure */
    LispInteger_t = 16,
    LispDFloat_t,
    LispString_t,
    LispRatio_t,
    LispOpaque_t,

    /* simple access for marking */
    LispBignum_t,
    LispBigratio_t,

d98 2
a99 6
    LispFunction_t,
    LispFunctionQuote_t,

    LispLambda_t,

    LispComplex_t,
d102 3
d108 1
d110 1
a110 6
    LispComma_t,
    LispPathname_t,
    LispPackage_t,
    LispRegex_t,
    LispBytecode_t,
    LispHashTable_t
a119 14
typedef enum _LispStreamType {
    LispStreamString,
    LispStreamFile,
    LispStreamStandard,
    LispStreamPipe
} LispStreamType;

typedef struct {
    int pid;			/* process id of program */
    LispFile *input;		/* if READABLE: stdout of program */
    LispFile *output;		/* if WRITABLE: stdin of program */
    LispObj *errorp;		/* ALWAYS (ONLY) READABLE: stderr of program */
} LispPipe;

d123 1
a124 1
    LispFunType funtype : 4;	/* this is subject to change in the future */
a126 5
	struct {
	    char *string;
	    long length;
	    unsigned int writable : 1;
	} string;
d128 1
a128 1
	double dfloat;
a129 14
	LispObj *pathname;	/* don't use quote generic name,
				 * to avoid confusing code */
	struct {
	    long numerator;
	    long denominator;
	} ratio;
	union {
	    mpi *integer;
	    mpr *ratio;
	} mp;
	struct {
	    LispObj *real;
	    LispObj *imag;
	} complex;
d137 5
a141 1
	    LispObj *data;		/* extra data to protect */
d148 1
a148 1
					 * Lisp_Nil_t only accepts given
d159 2
a160 3
		LispFile *file;
		LispPipe *program;
		LispString *string;
d162 2
a163 4
	    LispObj *pathname;
	    LispStreamType type : 6;
	    unsigned int readable : 1;
	    unsigned int writable : 1;
a172 19
	struct {
	    LispObj *name;
	    LispObj *nicknames;
	    LispPackage *package;
	} package;
	struct {
	    re_cod *regex;
	    LispObj *pattern;		/* regex string */
	    int options;		/* regex compile flags */
	} regex;
	struct {
	    LispBytecode *bytecode;
	    LispObj *code;		/* object used to generate bytecode */
	    LispObj *name;		/* name of function, or NIL */
	} bytecode;
	struct {
	    LispHashTable *table;
	    LispObj *test;
	} hash;
a175 3
typedef	LispObj *(*LispFunPtr)(LispBuiltin*);
typedef void (*LispComPtr)(LispCom*, LispBuiltin*);

d177 5
a181 16
    /* these fields must be set */
    LispFunType type;
    LispFunPtr function;
    char *declaration;

    /* this field is optional, set if the function returns multiple values */
    int multiple_values;

    /* this field is also optional, set if the function should not be exported */
    int internal;

    /* this optional field points to a function of the bytecode compiler */
    LispComPtr compile;

    /* this field is set at runtime */
    LispObj *symbol;
d184 3
a186 2
typedef int (*LispLoadModule)(void);
typedef int (*LispUnloadModule)(void);
d198 17
a214 32
LispObj *LispEval(LispObj*);
LispObj *LispFuncall(LispObj*, LispObj*, int);
LispObj *LispApply1(LispObj*, LispObj*);
LispObj *LispApply2(LispObj*, LispObj*, LispObj*);
LispObj *LispApply3(LispObj*, LispObj*, LispObj*, LispObj*);

LispObj *LispNew(LispObj*, LispObj*);
LispObj *LispNewSymbol(LispAtom*);
LispObj *LispNewAtom(char*, int);
LispObj *LispNewFunction(LispObj*);
LispObj *LispNewFunctionQuote(LispObj*);
LispObj *LispNewStaticAtom(char*);
LispObj *LispNewDFloat(double);
LispObj *LispNewString(char*, long, int);
LispObj *LispNewInteger(long);
LispObj *LispNewRatio(long, long);
LispObj *LispNewVector(LispObj*);
LispObj *LispNewQuote(LispObj*);
LispObj *LispNewBackquote(LispObj*);
LispObj *LispNewComma(LispObj*, int);
LispObj *LispNewCons(LispObj*, LispObj*);
LispObj *LispNewLambda(LispObj*, LispObj*, LispObj*, LispFunType);
LispObj *LispNewStruct(LispObj*, LispObj*);
LispObj *LispNewComplex(LispObj*, LispObj*);
LispObj *LispNewOpaque(void*, int);
LispObj *LispNewKeyword(char*);
LispObj *LispNewPathname(LispObj*);
LispObj *LispNewStringStream(char*, int, long, int);
LispObj *LispNewFileStream(LispFile*, LispObj*, int);
LispObj *LispNewPipeStream(LispPipe*, LispObj*, int);
LispObj *LispNewBignum(mpi*);
LispObj *LispNewBigratio(mpr*);
d216 1
a216 1
LispAtom *LispGetAtom(char*);
d220 1
a220 1
LispAtom *LispGetPermAtom(char*);
d222 5
a226 5
void *LispMalloc(size_t);
void *LispCalloc(size_t, size_t);
void *LispRealloc(void*, size_t);
char *LispStrdup(char*);
void LispFree(void*);
d229 1
a229 1
void LispMused(void*);
d231 1
a231 1
void LispGC(LispObj*, LispObj*);
d233 1
a233 1
char *LispStrObj(LispObj*);
d235 1
a235 11
#ifdef __GNUC__
#define PRINTF_FORMAT	__attribute__ ((format (printf, 1, 2)))
#else
#define PRINTF_FORMAT	/**/
#endif
void LispDestroy(char *fmt, ...) PRINTF_FORMAT;
	/* continuable error */
void LispContinuable(char *fmt, ...) PRINTF_FORMAT;
void LispMessage(char *fmt, ...) PRINTF_FORMAT;
void LispWarning(char *fmt, ...) PRINTF_FORMAT;
#undef PRINTF_FORMAT
d237 1
a237 1
LispObj *LispSetVariable(LispObj*, LispObj*, char*, int);
d239 1
a239 1
int LispRegisterOpaqueType(char*);
d241 3
a243 1
int LispPrintString(LispObj*, char*);
d245 10
a254 2
void LispProtect(LispObj*, LispObj*);
void LispUProtect(LispObj*, LispObj*);
d258 1
a258 1
void LispAddBuiltinFunction(LispBuiltin*);
d263 1
a263 1
extern LispObj *UNBOUND;
d265 1
a265 22

extern LispObj *Okey, *Orest, *Ooptional, *Oaux, *Olambda;
extern Atom_id Snil, St, Skey, Srest, Soptional, Saux;
extern Atom_id Sand, Sor, Snot;
extern Atom_id Satom, Ssymbol, Sinteger, Scharacter, Sstring, Slist,
	       Scons, Svector, Sarray, Sstruct, Skeyword, Sfunction, Spathname,
	       Srational, Sfloat, Scomplex, Sopaque, Sdefault;

extern LispObj *Ocomplex, *Oformat, *Kunspecific;

extern LispObj *Omake_array, *Kinitial_contents, *Osetf;
extern Atom_id Svariable, Sstructure, Stype, Ssetf;

extern Atom_id Smake_struct, Sstruct_access, Sstruct_store, Sstruct_type;
extern LispObj *Omake_struct, *Ostruct_access, *Ostruct_store, *Ostruct_type;

extern LispObj *Oparse_namestring, *Kerror, *Kabsolute, *Krelative, *Oopen,
	       *Oclose, *Kif_does_not_exist;

extern LispObj *Oequal_;

extern LispFile *Stdout, *Stdin, *Stderr;
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d30 1
a30 1
/* $XFree86: xc/programs/xedit/lisp/internal.h,v 1.49 2002/12/11 04:44:27 paulo Exp $ */
a37 3
#include "mp.h"
#include "re.h"

a40 9
typedef struct _LispMac LispMac;

#define STREAM_READ		0x01
#define STREAM_WRITE		0x02
#define STREAM_BINARY		0x20

#define RPLACA(cons, object)	(CAR(cons) = object)
#define RPLACD(cons, object)	(CDR(cons) = object)

d46 12
a57 47
#define CDDR(list)		((list)->data.cons.cdr->data.cons.cdr)
#define CONS(car, cdr)		LispNewCons(car, cdr)
#define EVAL(list)		LispEval(list)
#define APPLY(fun, args)	LispFuncall(fun, args, 0)
#define APPLY1(fun, arg)	LispApply1(fun, arg)
#define APPLY2(fun, arg1, arg2)	LispApply2(fun, arg1, arg2)
#define APPLY3(f, a1, a2, a3)	LispApply3(f, a1, a2, a3)
#define EXECUTE(string)		LispExecute(string)
#define SYMBOL(atom)		LispNewSymbol(atom)
#define ATOM(string)		LispNewAtom(string, 1)
#define UNINTERNED_ATOM(string)	LispNewAtom(string, 0)
#define FUNCTION(symbol)	LispNewFunction(symbol)
#define FUNCTION_QUOTE(symbol)	LispNewFunctionQuote(symbol)

	/* atom string is a static variable */
#define ATOM2(string)		LispNewSymbol(LispGetPermAtom(string))

	/* make a gc never released variable with a static string argument */
#define STATIC_ATOM(string)	LispNewStaticAtom(string)

#define STRING(str)		LispNewString(str, strlen(str), 0)
#define LSTRING(str, size)	LispNewString(str, size, 0)

	/* string must be from the LispXXX allocation functions,
	 * and LispMused not yet called on it */
#define STRING2(str)		LispNewString(str, strlen(str), 1)
#define LSTRING2(str, size)	LispNewString(str, size, 1)

#define VECTOR(objects)		LispNewVector(objects)

	/* STRINGSTREAM2 and LSTRINGSTREAM2 require that the
	 * string be allocated from the LispXXX allocation functions,
	 * and LispMused not yet called on it */
#define STRINGSTREAM(str, flag)			\
	LispNewStringStream(str, flag, strlen(str), 0)
#define STRINGSTREAM2(str, flag)		\
	LispNewStringStream(str, flag, strlen(str), 1)
#define LSTRINGSTREAM(str, flag, length)	\
	LispNewStringStream(str, flag, length, 0)
#define LSTRINGSTREAM2(str, flag, length)	\
	LispNewStringStream(str, flag, length, 1)

#define FILESTREAM(file, path, flag)	\
	LispNewFileStream(file, path, flag)
#define PIPESTREAM(file, path, flag)	\
	LispNewPipeStream(file, path, flag)

d59 4
a62 347
	((obj)->type == LispOpaque_t && 				\
	 ((obj)->data.opaque.type == typ || (obj)->data.opaque.type == 0))
#define PROTECT(key, list)	LispProtect(key, list)
#define UPROTECT(key, list)	LispUProtect(key, list)

/* create a new unique static atom string */
#define GETATOMID(string)	LispGetAtomString(string, 1)

#define	GCDisable()		++gcpro
#define	GCEnable()		--gcpro


/* pointer to something unique to all atoms with the same print representation */
#define ATOMID(object)		(object)->data.atom->string



#define NIL_BIT			0x01
#define FIXNUM_BIT		0x02
#define FIXNUM_MASK		0x03
#define SCHAR_BIT		0x04
#define SCHAR_MASK		0x05
#define BIT_COUNT		4
#define BIT_MASK		0x0f
#define POINTERP(object)						\
    (((unsigned long)(object) & NIL_BIT) == 0)

#define MOST_POSITIVE_FIXNUM	((1L << (sizeof(long) * 8 - 5)) - 1)
#define MOST_NEGATIVE_FIXNUM	(-1L << (sizeof(long) * 8 - 5))

#define SCHAR(value)							\
    ((LispObj*)(((long)(value) << BIT_COUNT) | SCHAR_MASK))
#define SCHAR_VALUE(object)	FIXNUM_VALUE(object)
#define SCHARP(object)							\
    (((unsigned long)(object) & BIT_MASK) == SCHAR_MASK)
#define CHECK_SCHAR(object)						\
    if (!SCHARP(object))						\
	LispDestroy("%s: %s is not a character",			\
		    STRFUN(builtin), STROBJ(object))

#define XOBJECT_TYPE(object)	((object)->type)
#define OBJECT_TYPE(object)						\
    (POINTERP(object) ? XOBJECT_TYPE(object) : (long)(object) & BIT_MASK)


#define NIL			(LispObj*)0x00000001
#define T			(LispObj*)0x00000011
#define DOT			(LispObj*)0x00000021
/* unmatched ')' */
#define	EOLIST			(LispObj*)0x00000031
#define READLABEL_MASK		0x00000041
/* unspecified argument */
#define UNSPEC			(LispObj*)0x00000051
#define INVALIDP(object)						\
    ((object) == NULL || (object) == EOLIST || (object) == DOT)


/* cons */
#define XCONSP(object)		((object)->type == LispCons_t)
#define CONSP(object)		(POINTERP(object) && XCONSP(object))
#define CHECK_CONS(object)						\
    if (!CONSP(object))							\
	LispDestroy("%s: %s is not of type cons",			\
		    STRFUN(builtin), STROBJ(object))
#define LISTP(object)		(object == NIL || CONSP(object))
#define CHECK_LIST(object)						\
    if (!LISTP(object))							\
	LispDestroy("%s: %s is not a list",				\
		    STRFUN(builtin), STROBJ(object))

/* fixnum */
#define FIXNUM(value)							\
    ((LispObj*)(((long)(value) << BIT_COUNT) | FIXNUM_MASK))
#define FIXNUM_VALUE(object)	((long)(object) >> BIT_COUNT)
#define FIXNUMP(object)							\
    (((unsigned long)(object) & BIT_MASK) == FIXNUM_MASK)
#define CHECK_FIXNUM(object)						\
    if (!FIXNUMP(object))						\
	LispDestroy("%s: %s is not a fixnum",				\
		    STRFUN(builtin), STROBJ(object))
#define INDEXP(object)							\
    (FIXNUMP(object) && FIXNUM_VALUE(object) >= 0)
#define CHECK_INDEX(object)						\
    if (!INDEXP(object))						\
	LispDestroy("%s: %s is not a positive fixnum",			\
		    STRFUN(builtin), STROBJ(object))


/* long int integer */
#define XINTP(object)		((object)->type == LispInteger_t)
#define INTP(objet)		(POINTERP(object) && XINTP(object))
#define INT_VALUE(object)	(object)->data.integer


/* values that fit in a machine long int but not in a fixnum */
#define LONGINTP(object)						\
    (POINTERP(object) ? XINTP(object) : FIXNUMP(object))
#define LONGINT_VALUE(object)						\
    (POINTERP(object) ? INT_VALUE(object) : FIXNUM_VALUE(object))
#define CHECK_LONGINT(object)						\
    if (!LONGINTP(object))						\
	LispDestroy("%s: %s is not an integer",				\
		    STRFUN(builtin), STROBJ(object))


/* bignum */
#define XBIGNUMP(object)	((object)->type == LispBignum_t)
#define BIGNUMP(object)		(POINTERP(object) && XBIGNUMP(object))
#define BIGNUM(object)		LispNewBignum(object)


/* generic integer */
#define INTEGER(integer)	LispNewInteger(integer)
#define INTEGERP(object)						\
    (POINTERP(object) ? XINTP(object) || XBIGNUMP(object) : FIXNUMP(object))
#define CHECK_INTEGER(object)						\
    if (!INTEGERP(object))						\
	LispDestroy("%s: %s is not an integer",				\
		    STRFUN(builtin), STROBJ(object))


/* ratio */
#define XRATIOP(object)		((object)->type == LispRatio_t)
#define RATIOP(object)		(POINTERP(object) && XRATIOP(object))
#define RATIO(num, den)		LispNewRatio(num, den)


/* bigratio */
#define XBIGRATIOP(object)	((object)->type == LispBigratio_t)
#define BIGRATIOP(object)	(POINTERP(object) && XBIGRATIOP(object))
#define BIGRATIO(ratio)		LispNewBigratio(ratio)


/* generic rational */
#define RATIONALP(object)						\
    (POINTERP(object) ? XINTP(object) || XRATIOP(object) ||		\
			XBIGNUMP(object) || XBIGRATIOP(object) :	\
			FIXNUMP(object))


/* double float */
#define XDFLOATP(object)	((object)->type == LispDFloat_t)
#define DFLOATP(object)		(POINTERP(object) && XDFLOATP(object))
#define DFLOAT_VALUE(object)	(object)->data.dfloat
#define CHECK_DFLOAT(object)						\
    if (!DFLOATP(object))						\
	LispDestroy("%s: %s is not a float number",			\
		    STRFUN(builtin), STROBJ(object))
#define DFLOAT(value)		LispNewDFloat(value)


/* generic float - currently only double float supported */
#define FLOATP(object)		DFLOATP(object)


/* real number */
#define REALP(object)							\
    (POINTERP(object) ? XINTP(object) || XDFLOATP(object) ||		\
			XRATIOP(object) || XBIGNUMP(object) ||		\
			XBIGRATIOP(object) :				\
			FIXNUMP(object))
#define CHECK_REAL(object)						\
    if (!REALP(object))							\
	LispDestroy("%s: %s is not a real number",			\
		    STRFUN(builtin), STROBJ(object))


/* complex */
#define XCOMPLEXP(object)	((object)->type == LispComplex_t)
#define COMPLEXP(object)	(POINTERP(object) && XCOMPLEXP(object))
#define COMPLEX(real, imag)	LispNewComplex(real, imag)


/* generic number */
#define NUMBERP(object)							\
    (POINTERP(object) ? XINTP(object) || XDFLOATP(object) ||		\
			XRATIOP(object) || XBIGNUMP(object) ||		\
			XBIGRATIOP(object) || XCOMPLEXP(object) :	\
			FIXNUMP(object))
#define CHECK_NUMBER(object)						\
    if (!NUMBERP(object))						\
	LispDestroy("%s: %s is not a number",				\
		    STRFUN(builtin), STROBJ(object))


/* symbol */
#define XSYMBOLP(object)	((object)->type == LispAtom_t)
#define SYMBOLP(object)		(POINTERP(object) && XSYMBOLP(object))
#define CHECK_SYMBOL(object)						\
    if (!SYMBOLP(object))						\
	LispDestroy("%s: %s is not a symbol",				\
		    STRFUN(builtin), STROBJ(object))


/* keyword */
#define XKEYWORDP(object)						\
    ((object)->data.atom->package == lisp__data.keyword)
#define KEYWORDP(object)						\
    (POINTERP(object) && XSYMBOLP(object) && XKEYWORDP(object))
#define KEYWORD(string)		LispNewKeyword(string)
#define CHECK_KEYWORD(object)						\
    if (!KEYWORDP(object))						\
	LispDestroy("%s: %s is not a keyword",				\
		    STRFUN(builtin), STROBJ(object))
#define CHECK_CONSTANT(object)						\
    if ((object)->data.atom->constant)					\
	LispDestroy("%s: %s is a constant",				\
		    STRFUN(builtin), STROBJ(object))

#define SETVALUE(atom, object)	((atom)->property->value = object)


/* function */
#define XFUNCTIONP(object)	((object)->type == LispFunction_t)
#define FUNCTIONP(object)	(POINTERP(object) && XFUNCTIONP(object))


/* lambda */
#define XLAMBDAP(object)	((object)->type == LispLambda_t)
#define LAMBDAP(object)		(POINTERP(object) && XLAMBDAP(object))


/* string - currently only simple 8 bit characters */
#define XSTRINGP(object)	((object)->type == LispString_t)
#define STRINGP(object)		(POINTERP(object) && XSTRINGP(object))
#define THESTR(object)		(object)->data.string.string
#define STRLEN(object)		(object)->data.string.length
#define CHECK_STRING(object)						\
    if (!STRINGP(object))						\
	LispDestroy("%s: %s is not a string",				\
		    STRFUN(builtin), STROBJ(object))
#define CHECK_STRING_WRITABLE(object)					\
    if (!object->data.string.writable)					\
	LispDestroy("%s: %s is readonly",				\
		    STRFUN(builtin), STROBJ(object))


/* array/vector */
#define XARRAYP(object)		((object)->type == LispArray_t)
#define ARRAYP(object)		(POINTERP(object) && XARRAYP(object))
#define CHECK_ARRAY(object)						\
    if (!ARRAYP(object))						\
	LispDestroy("%s: %s is not an array",				\
		    STRFUN(builtin), STROBJ(object))


/* quote */
#define XQUOTEP(object)		((object)->type == LispQuote_t)
#define QUOTEP(object)		(POINTERP(object) && XQUOTEP(object))
#define QUOTE(object)		LispNewQuote(object)

#define XBACKQUOTEP(object)	((object)->type == LispBackquote_t)
#define BACKQUOTEP(object)	(POINTERP(object) && XBACKQUOTEP(object))
#define BACKQUOTE(object)	LispNewBackquote(object)

#define XCOMMAP(object)		((object)->type == LispComma_t)
#define COMMAP(object)		(POINTERP(object) && XCOMMAP(object))
#define COMMA(object, at)	LispNewComma(object, at)


/* package */
#define XPACKAGEP(object)	((object)->type == LispPackage_t)
#define PACKAGEP(object)	(POINTERP(object) && XPACKAGEP(object))


/* pathname */
#define XPATHNAMEP(object)	((object)->type == LispPathname_t)
#define PATHNAMEP(object)	(POINTERP(object) && XPATHNAMEP(object))
#define PATHNAME(object)	LispNewPathname(object)
#define CHECK_PATHNAME(object)						\
    if (!PATHNAMEP(object))						\
	LispDestroy("%s: %s is not a pathname",				\
		    STRFUN(builtin), STROBJ(object))


/* stream */
#define XSTREAMP(object)	((object)->type == LispStream_t)
#define STREAMP(object)		(POINTERP(object) && XSTREAMP(object))
#define CHECK_STREAM(object)						\
    if (!STREAMP(object))						\
	LispDestroy("%s: %s is not a stream",				\
		    STRFUN(builtin), STROBJ(object))


/* hastable */
#define XHASHTABLEP(object)	((object)->type == LispHashTable_t)
#define HASHTABLEP(object)	(POINTERP(object) && XHASHTABLEP(object))
#define CHECK_HASHTABLE(object)						\
    if (!HASHTABLEP(object))						\
	LispDestroy("%s: %s is not a hash-table",			\
		    STRFUN(builtin), STROBJ(object))


/* regex */
#define XREGEXP(object)		((object)->type == LispRegex_t)
#define REGEXP(object)		(POINTERP(object) && XREGEXP(object))
#define CHECK_REGEX(object)						\
    if (!REGEXP(object))						\
	LispDestroy("%s: %s is not a regexp",				\
		    STRFUN(builtin), STROBJ(object))


/* bytecode */
#define XBYTECODEP(object)	((object)->type == LispBytecode_t)
#define BYTECODEP(object)	(POINTERP(object) && XBYTECODEP(object))


/* opaque */
#define XOPAQUEP(object)	((object)->type == LispOpaque_t)
#define OPAQUEP(object)		(POINTERP(object) && XOPAQUEP(object))
#define OPAQUE(data, type)	LispNewOpaque((void*)((long)data), type)



#define SSTREAMP(str)		((str)->data.stream.source.string)

#define FSTREAMP(str)		((str)->data.stream.source.file)

#define PSTREAMP(str)		((str)->data.stream.source.program)
#define PIDPSTREAMP(str)	((str)->data.stream.source.program->pid)
#define IPSTREAMP(str)		((str)->data.stream.source.program->input)
#define OPSTREAMP(str)		((str)->data.stream.source.program->output)
#define EPSTREAMP(str)		\
	FSTREAMP((str)->data.stream.source.program->errorp)

#define LispFileno(file)	((file)->descriptor)

#define STRFUN(builtin)		ATOMID(builtin->symbol)
#define STROBJ(obj)		LispStrObj(obj)

/* fetch builtin function/macro argument value
 */
#define ARGUMENT(index)							\
	lisp__data.stack.values[lisp__data.stack.base + (index)]

#define RETURN(index)	lisp__data.returns.values[(index)]
#define RETURN_COUNT	lisp__data.returns.count
#define RETURN_CHECK(value)						\
    value < MULTIPLE_VALUES_LIMIT ?					\
	value : MULTIPLE_VALUES_LIMIT

#define GC_ENTER()		int gc__protect = lisp__data.protect.length

#define GC_PROTECT(object)						\
    if (lisp__data.protect.length >= lisp__data.protect.space)		\
	LispMoreProtects();						\
    lisp__data.protect.objects[lisp__data.protect.length++] = object
d64 2
a65 1
#define GC_LEAVE()		lisp__data.protect.length = gc__protect
d67 1
d69 2
a70 4
#define ERROR_CHECK_SPECIAL_FORM(atom)					\
    if (atom->property->fun.builtin->compile)				\
	LispDestroy("%s: the special form %s cannot be redefined",	\
		    STRFUN(builtin), atom->string)
d72 3
d76 3
d80 2
a81 8
#define CONSTANTP(object)						\
    (!POINTERP(object) ||						\
     XOBJECT_TYPE(object) < LispAtom_t ||				\
     (XSYMBOLP(object) && XKEYWORDP(object)))

/* slightly faster test, since keywords are very uncommon as eval arguments */
#define NCONSTANTP(object)						\
    (OBJECT_TYPE(object) >= LispAtom_t)
d83 2
a92 10
typedef struct _LispFile LispFile;
typedef struct _LispString LispString;
typedef struct _LispPackage LispPackage;
typedef struct _LispBytecode LispBytecode;
typedef struct _LispHashTable LispHashTable;

/* Bytecode compiler data */
typedef struct _LispCom LispCom;

typedef char *Atom_id;
d95 2
a96 16
    /* objects encoded in the LispObj pointer */
    LispNil_t = 1,
    LispFixnum_t = 3,
    LispSChar_t = 5,

    /* objects that have a structure */
    LispInteger_t = 16,
    LispDFloat_t,
    LispString_t,
    LispRatio_t,
    LispOpaque_t,

    /* simple access for marking */
    LispBignum_t,
    LispBigratio_t,

d98 2
a99 6
    LispFunction_t,
    LispFunctionQuote_t,

    LispLambda_t,

    LispComplex_t,
d102 3
d108 1
d110 1
a110 6
    LispComma_t,
    LispPathname_t,
    LispPackage_t,
    LispRegex_t,
    LispBytecode_t,
    LispHashTable_t
a119 14
typedef enum _LispStreamType {
    LispStreamString,
    LispStreamFile,
    LispStreamStandard,
    LispStreamPipe
} LispStreamType;

typedef struct {
    int pid;			/* process id of program */
    LispFile *input;		/* if READABLE: stdout of program */
    LispFile *output;		/* if WRITABLE: stdin of program */
    LispObj *errorp;		/* ALWAYS (ONLY) READABLE: stderr of program */
} LispPipe;

d123 1
a124 1
    LispFunType funtype : 4;	/* this is subject to change in the future */
a126 5
	struct {
	    char *string;
	    long length;
	    int writable : 1;
	} string;
d128 1
a128 1
	double dfloat;
a129 14
	LispObj *pathname;	/* don't use quote generic name,
				 * to avoid confusing code */
	struct {
	    long numerator;
	    long denominator;
	} ratio;
	union {
	    mpi *integer;
	    mpr *ratio;
	} mp;
	struct {
	    LispObj *real;
	    LispObj *imag;
	} complex;
d137 5
a141 1
	    LispObj *data;		/* extra data to protect */
d148 1
a148 1
					 * Lisp_Nil_t only accepts given
d159 2
a160 3
		LispFile *file;
		LispPipe *program;
		LispString *string;
d162 2
a163 4
	    LispObj *pathname;
	    LispStreamType type : 6;
	    int readable : 1;
	    int writable : 1;
a172 19
	struct {
	    LispObj *name;
	    LispObj *nicknames;
	    LispPackage *package;
	} package;
	struct {
	    re_cod *regex;
	    LispObj *pattern;		/* regex string */
	    int options;		/* regex compile flags */
	} regex;
	struct {
	    LispBytecode *bytecode;
	    LispObj *code;		/* object used to generate bytecode */
	    LispObj *name;		/* name of function, or NIL */
	} bytecode;
	struct {
	    LispHashTable *table;
	    LispObj *test;
	} hash;
a175 3
typedef	LispObj *(*LispFunPtr)(LispBuiltin*);
typedef void (*LispComPtr)(LispCom*, LispBuiltin*);

d177 5
a181 16
    /* these fields must be set */
    LispFunType type;
    LispFunPtr function;
    char *declaration;

    /* this field is optional, set if the function returns multiple values */
    int multiple_values;

    /* this field is also optional, set if the function should not be exported */
    int internal;

    /* this optional field points to a function of the bytecode compiler */
    LispComPtr compile;

    /* this field is set at runtime */
    LispObj *symbol;
d184 3
a186 2
typedef int (*LispLoadModule)(void);
typedef int (*LispUnloadModule)(void);
d198 17
a214 32
LispObj *LispEval(LispObj*);
LispObj *LispFuncall(LispObj*, LispObj*, int);
LispObj *LispApply1(LispObj*, LispObj*);
LispObj *LispApply2(LispObj*, LispObj*, LispObj*);
LispObj *LispApply3(LispObj*, LispObj*, LispObj*, LispObj*);

LispObj *LispNew(LispObj*, LispObj*);
LispObj *LispNewSymbol(LispAtom*);
LispObj *LispNewAtom(char*, int);
LispObj *LispNewFunction(LispObj*);
LispObj *LispNewFunctionQuote(LispObj*);
LispObj *LispNewStaticAtom(char*);
LispObj *LispNewDFloat(double);
LispObj *LispNewString(char*, long, int);
LispObj *LispNewInteger(long);
LispObj *LispNewRatio(long, long);
LispObj *LispNewVector(LispObj*);
LispObj *LispNewQuote(LispObj*);
LispObj *LispNewBackquote(LispObj*);
LispObj *LispNewComma(LispObj*, int);
LispObj *LispNewCons(LispObj*, LispObj*);
LispObj *LispNewLambda(LispObj*, LispObj*, LispObj*, LispFunType);
LispObj *LispNewStruct(LispObj*, LispObj*);
LispObj *LispNewComplex(LispObj*, LispObj*);
LispObj *LispNewOpaque(void*, int);
LispObj *LispNewKeyword(char*);
LispObj *LispNewPathname(LispObj*);
LispObj *LispNewStringStream(char*, int, long, int);
LispObj *LispNewFileStream(LispFile*, LispObj*, int);
LispObj *LispNewPipeStream(LispPipe*, LispObj*, int);
LispObj *LispNewBignum(mpi*);
LispObj *LispNewBigratio(mpr*);
d216 1
a216 1
LispAtom *LispGetAtom(char*);
d220 1
a220 1
LispAtom *LispGetPermAtom(char*);
d222 5
a226 5
void *LispMalloc(size_t);
void *LispCalloc(size_t, size_t);
void *LispRealloc(void*, size_t);
char *LispStrdup(char*);
void LispFree(void*);
d229 1
a229 1
void LispMused(void*);
d231 1
a231 1
void LispGC(LispObj*, LispObj*);
d233 1
a233 1
char *LispStrObj(LispObj*);
d235 1
a235 11
#ifdef __GNUC__
#define PRINTF_FORMAT	__attribute__ ((format (printf, 1, 2)))
#else
#define PRINTF_FORMAT	/**/
#endif
void LispDestroy(char *fmt, ...) PRINTF_FORMAT;
	/* continuable error */
void LispContinuable(char *fmt, ...) PRINTF_FORMAT;
void LispMessage(char *fmt, ...) PRINTF_FORMAT;
void LispWarning(char *fmt, ...) PRINTF_FORMAT;
#undef PRINTF_FORMAT
d237 1
a237 1
LispObj *LispSetVariable(LispObj*, LispObj*, char*, int);
d239 1
a239 1
int LispRegisterOpaqueType(char*);
d241 3
a243 1
int LispPrintString(LispObj*, char*);
d245 10
a254 2
void LispProtect(LispObj*, LispObj*);
void LispUProtect(LispObj*, LispObj*);
d258 1
a258 1
void LispAddBuiltinFunction(LispBuiltin*);
d263 1
a263 1
extern LispObj *UNBOUND;
d265 1
a265 22

extern LispObj *Okey, *Orest, *Ooptional, *Oaux, *Olambda;
extern Atom_id Snil, St, Skey, Srest, Soptional, Saux;
extern Atom_id Sand, Sor, Snot;
extern Atom_id Satom, Ssymbol, Sinteger, Scharacter, Sstring, Slist,
	       Scons, Svector, Sarray, Sstruct, Skeyword, Sfunction, Spathname,
	       Srational, Sfloat, Scomplex, Sopaque, Sdefault;

extern LispObj *Ocomplex, *Oformat, *Kunspecific;

extern LispObj *Omake_array, *Kinitial_contents, *Osetf;
extern Atom_id Svariable, Sstructure, Stype, Ssetf;

extern Atom_id Smake_struct, Sstruct_access, Sstruct_store, Sstruct_type;
extern LispObj *Omake_struct, *Ostruct_access, *Ostruct_store, *Ostruct_type;

extern LispObj *Oparse_namestring, *Kerror, *Kabsolute, *Krelative, *Oopen,
	       *Oclose, *Kif_does_not_exist;

extern LispObj *Oequal_;

extern LispFile *Stdout, *Stdin, *Stderr;
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d30 1
a30 1
/* $XFree86: xc/programs/xedit/lisp/internal.h,v 1.51 2003/05/27 22:27:03 tsi Exp $ */
d36 1
a36 1
#include "lisp/lisp.h"
d147 2
a148 3
#define OBJECT_TYPE(object)	(POINTERP(object) ?			\
				XOBJECT_TYPE(object) :			\
				(LispType)((long)(object) & BIT_MASK))
d561 1
a561 1
	    unsigned int writable : 1;
d611 2
a612 2
	    unsigned int readable : 1;
	    unsigned int writable : 1;
@


