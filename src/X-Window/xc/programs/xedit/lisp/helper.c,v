head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.10.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.10.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.39.50;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.39.10;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.28.29;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (c) 2001 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *  
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of the XFree86 Project shall
 * not be used in advertising or otherwise to promote the sale, use or other
 * dealings in this Software without prior written authorization from the
 * XFree86 Project.
 *
 * Author: Paulo César Pereira de Andrade
 */

/* $XFree86: xc/programs/xedit/lisp/helper.c,v 1.15 2001/10/28 03:34:29 tsi Exp $ */

#include "helper.h"
#include <ctype.h>

/*
 * Prototypes
 */
static LispObj *_LispReallyDo(LispMac*, LispObj*, char*, int);
static LispObj *_LispReallyDoListTimes(LispMac*, LispObj*, char*, int);
extern int LispGet(LispMac*);
extern int LispUnget(LispMac*);

/*
 * Implementation
 */
LispObj *
_LispEqual(LispMac *mac, LispObj *left, LispObj *right)
{
    LispObj *res = NIL;

    if (left->type == right->type) {
	switch (left->type) {
	    case LispNil_t:
	    case LispTrue_t:
		res = T;
		break;
	    case LispReal_t:
		if (left->data.real == right->data.real)
		    res = T;
		break;
	    case LispCharacter_t:
	    case LispInteger_t:
		if (left->data.integer == right->data.integer)
		    res = T;
		break;
	    case LispAtom_t:
	    case LispString_t:
		if (STRPTR(left) == STRPTR(right))
		    res = T;
		break;
	    case LispCons_t:
		if (_LispEqual(mac, CAR(left), CAR(right)) == T &&
		    _LispEqual(mac, CDR(left), CDR(right)) == T)
		    res = T;
		break;
	    case LispQuote_t:
		res = _LispEqual(mac, left->data.quote, right->data.quote);
		break;
	    case LispLambda_t:
		res = _LispEqual(mac, left->data.lambda.name,
				 right->data.lambda.name);
		break;
	    case LispOpaque_t:
		if (left->data.opaque.data == right->data.opaque.data)
		    res = T;
		break;
	    default:
		if (left == right)
		    res = T;
		break;
	}
    }

    return (res);
}

LispObj *
_LispNth(LispMac *mac, LispObj *list, char *name, int cdr)
{
    int count, maxpos;
    LispObj *nth = CAR(list), *seq = CDR(list), *setf = list;

    if (!INDEX_P(nth))
	LispDestroy(mac, "bad index %s, at %s", LispStrObj(mac, nth), name);
    if (seq->type != LispCons_t)
	LispDestroy(mac, "%s is not of type list, at %s",
		    LispStrObj(mac, seq), name);
    maxpos = NUMBER_VALUE(nth);
    for (count = 0, seq = CAR(seq);
	 count < maxpos && seq->type == LispCons_t;
	 ++count, setf = seq, seq = CDR(seq))
	;

    if (count == maxpos)
	return (cdr || seq == NIL ? seq : CAR(seq));

    return (NIL);
}

LispObj *
_LispFindPlace(LispMac *mac, LispObj *list, LispObj *ref)
{
    LispObj *place;

    for (; list->type == LispCons_t; list = CDR(list)) {
	if (CAR(list) == ref)
	    return (list);
	else if (CDR(list) == ref)
	    return (list);
	else if ((place = _LispFindPlace(mac, CAR(list), ref)) != NULL)
	    return (place);
    }

    return (NULL);
}

LispObj *
_LispMinMax(LispMac *mac, LispObj *list, char *name, int max)
{
    double real, val;
    LispObj *obj;

    obj = EVAL(CAR(list));
    if (!NUMBER_P(obj))
	LispDestroy(mac, ExpectingNumberAt, name);
    real = NUMBER_VALUE(obj);
    for (list = CDR(list); list != NIL; list = CDR(list)) {
	obj = EVAL(CAR(list));
	if (!NUMBER_P(obj))
	    LispDestroy(mac, ExpectingNumberAt, name);
	val = NUMBER_VALUE(obj); 
	if ((max && val > real) || (!max && val < real))
	    real = val;
    }

    return (REAL(real));
}

LispObj *
_LispBoolCond(LispMac *mac, LispObj *list, char *name, int op)
{
    LispObj *obj;
    double value, val;
    int cond;

    cond = 1;
    obj = op == NOT_EQUAL ? CAR(list) : EVAL(CAR(list));
    if (!NUMBER_P(obj))
	LispDestroy(mac, ExpectingNumberAt, name);
    value = NUMBER_VALUE(obj);

    /* special handling, as (/= 3 6 5 2) => T, but (/= 3 3 5 3) => NIL
     * all elements must be different to be True
     * Also, for NOT_EQUAL, arguments must be evaluated before calling
     * this function.
     */
    if (op == NOT_EQUAL) {
	LispObj *cmp;

	list = CDR(list);
	if (list == NIL)
	    return (T);

	/* check if numbers first */
	for (obj = list; obj != NIL; obj = CDR(obj))
	    if (CAR(obj)->type != LispReal_t)
		LispDestroy(mac, ExpectingNumberAt, name);

	do {
	    for (cmp = list; cmp != NIL; cmp = CDR(cmp)) {
		obj = CAR(cmp);
		if (value == NUMBER_VALUE(obj))
		    return (NIL);
	    }
	    value = NUMBER_VALUE(CAR(list));
	    list = CDR(list);
	} while (list != NIL);
	return (T);
    }

    for (list = CDR(list); list != NIL; list = CDR(list)) {
	obj = EVAL(CAR(list));
	if (!NUMBER_P(obj))
	    LispDestroy(mac, ExpectingNumberAt, name);
	val = NUMBER_VALUE(obj); 
	switch (op) {
	    case LESS:
		if (value >= val)
		    cond = 0;
		break;
	    case LESS_EQUAL:
		if (value > val)
		    cond = 0;
		break;
	    case EQUAL:
		if (value != val)
		    cond = 0;
		break;
	    case GREATER:
		if (value <= val)
		    cond = 0;
		break;
	    case GREATER_EQUAL:
		if (value < val)
		    cond = 0;
		break;
	}
	if (!cond)
	    break;
	value = val;
    }
    return (cond ? T : NIL);
}

LispObj *
_LispCharBoolCond(LispMac *mac, LispObj *list, char *name, int op, int cas)
{
    LispObj *obj;
    long value, comp;
    int cond;

    cond = 1;
    obj = op == NOT_EQUAL ? CAR(list) : EVAL(CAR(list));
    if (obj->type != LispCharacter_t)
	LispDestroy(mac, "expecting character, at %s", name);
    value = obj->data.integer;
    if (cas)
	value = toupper(value);

    if (op == NOT_EQUAL) {
	LispObj *cmp;

	list = CDR(list);
	if (list == NIL)
	    return (T);

	for (obj = list; obj != NIL; obj = CDR(obj))
	    if (CAR(obj)->type != LispCharacter_t)
		LispDestroy(mac, "expecting character, at %s", name);

	do {
	    for (cmp = list; cmp != NIL; cmp = CDR(cmp)) {
		obj = CAR(cmp);
		comp = obj->data.integer;
		if (cas)
		    comp = toupper(comp);
		if (value == comp)
		    return (NIL);
	    }
	    value = CAR(list)->data.integer;
	    if (cas)
		value = toupper(value);
	    list = CDR(list);
	} while (list != NIL);
	return (T);
    }

    for (list = CDR(list); list != NIL; list = CDR(list)) {
	obj = EVAL(CAR(list));
	if (obj->type != LispCharacter_t)
	    LispDestroy(mac, "expecting character, at %s", name);
	comp = obj->data.integer;
	if (cas)
	    comp = toupper(comp);
	switch (op) {
	    case LESS:
		if (value >= comp)
		    cond = 0;
		break;
	    case LESS_EQUAL:
		if (value > comp)
		    cond = 0;
		break;
	    case EQUAL:
		if (value != comp)
		    cond = 0;
		break;
	    case GREATER:
		if (value <= comp)
		    cond = 0;
		break;
	    case GREATER_EQUAL:
		if (value < comp)
		    cond = 0;
		break;
	}
	if (!cond)
	    break;
	value = obj->data.integer;
	if (cas)
	    value = toupper(value);
    }
    return (cond ? T : NIL);
}

LispObj *
_LispDefLambda(LispMac *mac, LispObj *list, LispFunType type)
{
    LispObj *name = NIL, *args, *code, *obj = NIL, *fun, *sto;
    static char *types[4] = {"LAMBDA", "FUNCTION", "MACRO", "SETF-METHOD"};
    static char *fnames[4] = {"LAMBDA", "DEFUN", "DEFMACRO", "DEFSETF"};
    int num_args, rest, optional, key;

    /* name */
    if (type != LispLambda) {
	if ((name = CAR(list))->type != LispAtom_t)
	    LispDestroy(mac, "%s cannot be a %s name, at %s",
			LispStrObj(mac, name), types[type], fnames[type]);
	list = CDR(list);
    }

    /* args */
    args = CAR(list);
    num_args = rest = optional = key = 0;

    if (args->type == LispCons_t) {
	for (obj = args; obj != NIL; obj = CDR(obj), ++num_args)
	    if (CAR(obj)->type == LispCons_t && (key || optional)) {
		/* is this a default value? */
		if (!SYMBOL_P(CAR(CAR(obj))))
		    LispDestroy(mac, "%s cannot be a %s argument name, at %s %s",
				LispStrObj(mac, CAR(CAR(obj))), types[type],
				fnames[type],
				type == LispLambda ? "..." : STRPTR(name));
		else if (CDR(CAR(obj)) != NIL &&
			 (CDR(CAR(obj))->type != LispCons_t ||
			  CDR(CDR(CAR(obj))) != NIL))
		    LispDestroy(mac, "bad argument specification %s, at %s %s",
				LispStrObj(mac, CAR(obj)), types[type],
				fnames[type],
				type == LispLambda ? "..." : STRPTR(name));
	    }
	    else if (!SYMBOL_P(CAR(obj)) ||
		STRPTR(CAR(obj))[0] == ':')
		LispDestroy(mac, "%s cannot be a %s argument name, at %s %s",
			    LispStrObj(mac, CAR(obj)), types[type], fnames[type],
			    type == LispLambda ? "..." : STRPTR(name));
	    else if (STRPTR(CAR(obj))[0] == '&') {
		if (strcmp(STRPTR(CAR(obj)) + 1, "REST") == 0) {
		    if (rest || CDR(obj) == NIL || CDR(CDR(obj)) != NIL)
			LispDestroy(mac, "syntax error parsing &REST,"
				    " at %s %s", fnames[type],
				    type == LispLambda ?
				    "..." : STRPTR(name));
		    rest = 1;
		}
		else if (strcmp(STRPTR(CAR(obj)) + 1, "KEY") == 0) {
		    if (rest)
			LispDestroy(mac, "&KEY not allowed after &REST,"
				    " at %s %s", fnames[type],
				    type == LispLambda ?
				    "..." : STRPTR(name));
		    if (key || optional || CDR(obj) == NIL)
			LispDestroy(mac, "syntax error parsing &KEY,"
				    " at %s %s", fnames[type],
				    type == LispLambda ?
				    "..." : STRPTR(name));
		    key = 1;
		}
		else if (strcmp(STRPTR(CAR(obj)) + 1, "OPTIONAL") == 0) {
		    if (rest)
			LispDestroy(mac, "&OPTIONAL not allowed after &REST,"
				    " at %s %s", fnames[type],
				    type == LispLambda ?
				    "..." : STRPTR(name));
		    if (key || optional || CDR(obj) == NIL)
			LispDestroy(mac, "syntax error parsing &OPTIONAL,"
				    " at %s %s", fnames[type],
				    type == LispLambda ?
				    "..." : STRPTR(name));
		    optional = 1;
		}
		else
		    LispDestroy(mac, "%s not allowed %at %s %s",
				STRPTR(CAR(obj)), fnames[type],
				type == LispLambda ? "..." : STRPTR(name));
	    }
    }
    else if (args != NIL)
	LispDestroy(mac, "%s cannot be a %s argument list, at %s %s",
		    LispStrObj(mac, args), types[type], fnames[type],
		    type == LispLambda ? "..." : STRPTR(name));

    if (type == LispSetf) {
	list = CDR(list);
	sto = CAR(list);
	if (sto->type != LispCons_t)
	    LispDestroy(mac, "%s is a bad store value, at %s",
			LispStrObj(mac, sto), fnames[type]);
	for (obj = CAR(sto); obj->type == LispCons_t; obj = CDR(obj))
	    if (!SYMBOL_P(CAR(obj)) || STRPTR(CAR(obj))[0] == ':')
		LispDestroy(mac, "%s cannot be a variable name, at %s",
			    LispStrObj(mac, CAR(obj)), fnames[type]);
	args = CONS(args, sto);
    }

    /* code */
    code = CDR(list);

    GCProtect();
    fun = LispNewLambda(mac, name, args, code, num_args, type,
			key, optional, rest);
    GCUProtect();

    if (type == LispSetf)
	LispSetAtomSetfProperty(mac, name->data.atom, fun);
    else if (type != LispLambda) {
	if (name->data.atom->property) {
	    if ((name->data.atom->property->function ||
		name->data.atom->property->builtin))
		fprintf(lisp_stderr, "*** Warning: %s is being redefined\n",
			STRPTR(name));

	    if (name->data.atom->property->builtin)
		LispRemAtomBuiltinProperty(mac, name->data.atom);
	}
	LispSetAtomFunctionProperty(mac, name->data.atom, fun);
    }

    return (type != LispLambda ? name : fun);
}

static LispObj *
_LispReallyDo(LispMac *mac, LispObj *list, char *fname, int refs)
{
    LispObj *old_frm, *old_env, *env, *res, *args, *test, *body, *obj;

    env = res = NIL;
    old_frm = FRM;
    old_env = ENV;
    args = CAR(list);
    test = CAR(CDR(list));
    body = CDR(CDR(list));

    if (test->type != LispCons_t)
	LispDestroy(mac, "end test condition must be a list, at %s",
		    LispStrObj(mac, args), fname);

    /* Add variables */
    if (args != NIL && args->type != LispCons_t)
	LispDestroy(mac, "%s is not of type list, at %s",
		    LispStrObj(mac, args), fname);

    for (obj = args; obj != NIL; obj = CDR(obj)) {
	LispObj *var, *val, *step;

	var = val = NIL;
	step = NULL;
	list = CAR(obj);
	if (SYMBOL_P(list))
	    var = list;
	else if (list->type != LispCons_t)
		LispDestroy(mac, "%s is not of type list, at %s",
			    LispStrObj(mac, list), fname);
	else {
	    if ((var = CAR(list))->type != LispAtom_t)
		LispDestroy(mac, "%s is invalid as a variable name, at %s",
			    LispStrObj(mac, var), fname);
	    if ((list = CDR(list)) != NIL) {
		val = EVAL(CAR(list));
		if ((list = CDR(list)) != NIL)
		    step = CAR(list);
	    }
	}
	GCProtect();
	if (step)
	    list = CONS(var, CONS(val, CONS(step, NIL)));
	else
	    list = CONS(var, CONS(val, NIL));
	if (env == NIL) {
	    env = CONS(list, NIL);
	    FRM = CONS(env, FRM);
	}
	else {
	    CDR(env) = CONS(CAR(env), CDR(env));
	    CAR(env) = list;
	}
	GCUProtect();
	if (refs)
	    LispAddVar(mac, var, val);
    }

    /* Need to update CAR(FRM) or will run loop without gc protection! */
    env = CAR(FRM) = LispReverse(env);
    if (!refs) {
	for (obj = env; obj != NIL; obj = CDR(obj)) {
	    list = CAR(obj);
	    LispAddVar(mac, CAR(list), CAR(CDR(list)));
	}
    }

    /* Execute iterations */
    for (;;) {
	if (EVAL(CAR(test)) != NIL) {
	    if (CDR(test) != NIL)
		res = EVAL(CAR(CDR(test)));
	    break;
	}
	(void)Lisp_Progn(mac, body, fname);
	/* Update variables */
	for (obj = env; obj != NIL; obj = CDR(obj)) {
	    list = CAR(obj);
	    if (CDR(CDR(list)) != NIL)
		LispSetVar(mac, CAR(list),
			   EVAL(CAR(CDR(CDR(list)))));
	}
    }

    ENV = old_env;
    FRM = old_frm;

    return (res);
}

LispObj *
_LispDo(LispMac *mac, LispObj *list, char *fname, int refs)
{
    int did_jump, *pdid_jump = &did_jump;
    LispObj *res, **pres = &res;
    LispBlock *block;

    *pres = NIL;
    *pdid_jump = 1;
    block = LispBeginBlock(mac, NIL, LispBlockTag);
    if (setjmp(block->jmp) == 0) {
	*pres = _LispReallyDo(mac, list, fname, refs);
	*pdid_jump = 0;
    }
    LispEndBlock(mac, block);
    if (*pdid_jump)
	*pres = mac->block.block_ret;

    return (*pres);
}

static LispObj *
_LispReallyDoListTimes(LispMac *mac, LispObj *list, char *fname, int times)
{
    double count = 0.0;
    LispObj *var, *val = NIL, *res = NIL, *body, *old_frm, *old_env;

    /* Parse arguments */
    if (CAR(list)->type != LispCons_t)
	LispDestroy(mac, "expecting list, at %s", fname);
    body = CDR(list);
    list = CAR(list);
    if ((var = CAR(list))->type != LispAtom_t)
	LispDestroy(mac, "%s is invalid as a variable name, at %s",
		    LispStrObj(mac, var), fname);
    list = CDR(list);

    /* Save environment */
    old_frm = FRM;
    old_env = ENV;

    if (list == NIL) {
	if (!times)
	    val = res = NIL;
	else
	    LispDestroy(mac, "NIL is not a number, at %s", fname);
    }
    else {
	if (list->type == LispCons_t) {
	    val = CAR(list);
	    list = CDR(list);
	    if (list == NIL)
		res = NIL;
	    else if (list->type == LispCons_t)
		res = CAR(list);
	    else
		LispDestroy(mac, "expecting list, at %s", fname);
	}
	else
	    LispDestroy(mac, "%s is not a list, at %s",
			LispStrObj(mac, val), fname);

	val = EVAL(val);

	if (times && (!INTEGER_P(val)))
	    LispDestroy(mac, "%s is not an integer, at %s",
			LispStrObj(mac, val), fname);
	else if (!times && (val != NIL && val->type != LispCons_t))
	    LispDestroy(mac, "%s is not a list, at %s",
			LispStrObj(mac, val), fname);
    }

    /* Protect iteration control from gc */
    FRM = CONS(val, FRM);

    /* Initialize counter */
    if (times)
	LispAddVar(mac, var, REAL(count));
    else
	LispAddVar(mac, var, CAR(val));

    /* Execute iterations */
    for (;;) {
	/* Check loop */
	if (times) {
	    if ((count += 1.0) > NUMBER_VALUE(val))
		break;
	}
	else if (val == NIL)
	    break;

	(void)Lisp_Progn(mac, body, fname);

	/* Update variables */
	if (times)
	    LispSetVar(mac, var, REAL(count));
	else {
	    val = CDR(val);
	    if (val == NIL)
		break;
	    else if (val->type != LispCons_t)
		LispDestroy(mac, "true list required, at %s", fname);
	    LispSetVar(mac, var, CAR(val));
	}
    }

    ENV = old_env;
    FRM = old_frm;

    return (res == NIL ? NIL : EVAL(res));
}

LispObj *
_LispDoListTimes(LispMac *mac, LispObj *list, char *fname, int times)
{
    int did_jump, *pdid_jump = &did_jump;
    LispObj *res, **pres = &res;
    LispBlock *block;

    *pres = NIL;
    *pdid_jump = 1;
    block = LispBeginBlock(mac, NIL, LispBlockTag);
    if (setjmp(block->jmp) == 0) {
	*pres = _LispReallyDoListTimes(mac, list, fname, times);
	*pdid_jump = 0;
    }
    LispEndBlock(mac, block);
    if (*pdid_jump)
	*pres = mac->block.block_ret;

    return (*pres);
}

LispObj *
_LispSet(LispMac *mac, LispObj *var, LispObj *val, char *fname, int eval)
{
    char *name;

    if (!SYMBOL_P(var))
	LispDestroy(mac, "%s is not a symbol, at %s",
		    LispStrObj(mac, var), fname);

    name = STRPTR(var);
    if (isdigit(name[0]) || name[0] == '(' || name[0] == ')'
	|| name[0] == ';' || name[0] == '\'' || name[0] == '#')
	LispDestroy(mac, "bad name %s, at %s", name, fname);
    if (eval)
	val = EVAL(val);

    return (LispSetVar(mac, var, val));
}

LispObj *
_LispWhenUnless(LispMac *mac, LispObj *list, int op)
{
    LispObj *obj, *res = NIL;

    obj = EVAL(CAR(list));
    if ((obj->type == LispNil_t) ^ op) {
	for (obj = CDR(list); obj != NIL; obj = CDR(obj))
	    res = EVAL(CAR(obj));
    }
    return (res);
}

LispObj *
_LispWhileUntil(LispMac *mac, LispObj *list, int op)
{
    LispObj *obj, *res = NIL;

    /*CONSTCOND*/
    while (1) {
	obj = EVAL(CAR(list));
	if ((obj->type == LispNil_t) ^ op) {
	    for (obj = CDR(list); obj != NIL; obj = CDR(obj))
		res = EVAL(CAR(obj));
	}
	else
	    break;
    }
    return (res);
}

LispObj *
_LispLoadFile(LispMac *mac, char *filename, char *fname,
	      int verbose, int print, int ifdoesnotexist)
{
    LispObj *obj, *res = NIL;
    FILE *fp;
    int ch, level;

    if ((fp = fopen(filename, "r")) == NULL) {
	if (ifdoesnotexist)
	    LispDestroy(mac, "cannot open %s, at %s", filename, fname);
	return (NIL);
    }

    if (verbose)
	fprintf(lisp_stderr, "; Loading %s\n", filename);

    if (mac->stream.stream_level + 1 >= mac->stream.stream_size) {
	LispStream *stream = (LispStream*)
	    realloc(mac->stream.stream, sizeof(LispStream) *
		    (mac->stream.stream_size + 1));

	if (stream == NULL) {
	    fclose(fp);
	    LispDestroy(mac, "out of memory");
	}

	mac->stream.stream = stream;
	++mac->stream.stream_size;
    }
    mac->stream.stream[mac->stream.stream_level].fp = mac->fp;
    mac->stream.stream[mac->stream.stream_level].st = mac->st;
    mac->stream.stream[mac->stream.stream_level].cp = mac->cp;
    mac->stream.stream[mac->stream.stream_level].tok = mac->tok;
    ++mac->stream.stream_level;
    memset(mac->stream.stream + mac->stream.stream_level, 0, sizeof(LispStream));
    mac->stream.stream[mac->stream.stream_level].fp = fp;
    mac->fp = fp;
    mac->st = mac->cp = NULL;
    mac->tok = 0;

    level = mac->level;
    mac->level = 0;

    ch = LispGet(mac);
    if (ch != '#')
	LispUnget(mac);
    else if (LispGet(mac) == '!') {
	for (;;) {
	    ch = LispGet(mac);
	    if (ch == '\n' || ch == EOF)
		break;
	}
    }
    else {
	LispUnget(mac);
	LispUnget(mac);
    }

    /*CONSTCOND*/
    while (1) {
	if ((obj = LispRun(mac)) != NULL) {
	    if (obj == EOLIST)
		LispDestroy(mac, "object cannot start with #\\)");
	    res = EVAL(obj);
	    if (print)
		LispPrint(mac, res, NIL, 1);
	}
	if (mac->tok == EOF)
	    break;
    }
    mac->level = level;
    free(mac->st);
    --mac->stream.stream_level;

    mac->fp = mac->stream.stream[mac->stream.stream_level].fp;
    mac->st = mac->stream.stream[mac->stream.stream_level].st;
    mac->cp = mac->stream.stream[mac->stream.stream_level].cp;
    mac->tok = mac->stream.stream[mac->stream.stream_level].tok;

    return (res);
}

void
_LispGetStringArgs(LispMac *mac, LispObj *list, char *fname,
		   char **string1, char **string2,
		   int *start1, int *end1, int *start2, int *end2)
{
    int len1, len2;
    LispObj *lstring1, *lstring2, *lstart1, *lend1, *lstart2, *lend2;

    lstring1 = CAR(list);
    list = CDR(list);
    lstring2 = CAR(list);
    if ((!STRING_P(lstring1) && !SYMBOL_P(lstring1)) ||
	(!STRING_P(lstring2) && !SYMBOL_P(lstring2)))
	LispDestroy(mac, "expecting string, at %s", fname);

    *string1 = STRPTR(lstring1);
    *string2 = STRPTR(lstring2);

    LispGetKeys(mac, fname, "START1:END1:START2:END2", CDR(list),
		&lstart1, &lend1, &lstart2, &lend2);

    if ((lstart1 != NIL && !INDEX_P(lstart1)) ||
	(lend1 != NIL && !INDEX_P(lend1)) ||
	(lstart2 != NIL && !INDEX_P(lstart2)) ||
	(lend2 != NIL && !INDEX_P(lend2)))
	LispDestroy(mac, "expecting positive integer, at %s", fname);

    len1 = strlen(*string1);
    *start1 = lstart1 == NIL ? 0 : NUMBER_VALUE(lstart1);
    *end1 = lend1 == NIL ? len1 : NUMBER_VALUE(lend1);
    len2 = strlen(*string2);
    *start2 = lstart2 == NIL ? 0 : NUMBER_VALUE(lstart2);
    *end2 = lend2 == NIL ? len2 : NUMBER_VALUE(lend2);

    if (*start1 > *end1 || *end1 > len1 || *start2 > *end2 || *end2 > len2)
	LispDestroy(mac, "bad string index, at %s", fname);
}

void
_LispGetStringCaseArgs(LispMac *mac, LispObj *list, char *fname,
		       char **string, int *start, int *end)
{
    int len;
    LispObj *lstring, *lstart, *lend;

    lstring = CAR(list);
    if (!STRING_P(lstring) && !SYMBOL_P(lstring))
	LispDestroy(mac, "expecting string, at %s", fname);

    *string = STRPTR(lstring);

    LispGetKeys(mac, fname, "START:END", CDR(list), &lstart, &lend);

    if ((lstart != NIL && !INDEX_P(lstart)) ||
	(lend != NIL && !INDEX_P(lend)))
	LispDestroy(mac, "expecting positive integer, at %s", fname);

    len = strlen(*string);
    *start = lstart == NIL ? 0 : NUMBER_VALUE(lstart);
    *end = lend == NIL ? len : NUMBER_VALUE(lend);

    if (*start > *end || *end > len)
	LispDestroy(mac, "bad string index, at %s", fname);
}

LispObj *
_LispStringDoTrim(LispMac *mac, LispObj *list, char *fname, int left, int right)
{
    char *str;
    int start, end, sstart, send, len;
    LispObj *chars, *string;

    chars = CAR(list);
    if (!STRING_P(chars) && chars->type != LispCons_t)
	LispDestroy(mac, "%s is not a sequence, at %s",
		    LispStrObj(mac, chars), fname);
    string = CAR(CDR(list));
    if (!STRING_P(string) && !SYMBOL_P(string))
	LispDestroy(mac, "expecting string, at %s", fname);

    sstart = start = 0;
    send = end = strlen(STRPTR(string));

    if (STRING_P(chars)) {
	char *cmp;

	if (left) {
	    for (str = STRPTR(string); *str; str++) {
		for (cmp = STRPTR(chars); *cmp; cmp++)
		    if (*str == *cmp)
			break;
		if (*cmp == '\0')
		    break;
		++start;
	    }
	}
	if (right) {
	    for (str = STRPTR(string) + end - 1; end > 0; str--) {
		for (cmp = STRPTR(chars); *cmp; cmp++)
		    if (*str == *cmp)
			break;
		if (*cmp == '\0')
		    break;
		--end;
	    }
	}
    }
    else {
	LispObj *obj;

	if (left) {
	    for (str = STRPTR(string); *str; str++) {
		for (obj = chars; obj != NIL; obj = CDR(obj))
		    /* Should really ignore non character input ? */
		    if (CAR(obj)->type == LispCharacter_t &&
			*str == CAR(obj)->data.integer)
			break;
		if (obj == NIL)
		    break;
		++start;
	    }
	}
	if (right) {
	    for (str = STRPTR(string) + end - 1; end > 0; str--) {
		for (obj = chars; obj != NIL; obj = CDR(obj))
		    /* Should really ignore non character input ? */
		    if (CAR(obj)->type == LispCharacter_t &&
			*str == CAR(obj)->data.integer)
			break;
		if (obj == NIL)
		    break;
		--end;
	    }
	}
    }

    if (sstart == start && send == end)
	return (string);

    len = end - start;
    str = LispMalloc(mac, len + 1);
    strncpy(str, STRPTR(string) + start, len);
    str[len] = '\0';

    string = STRING(str);
    LispFree(mac, str);

    return (string);
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d30 1
a30 1
/* $XFree86: xc/programs/xedit/lisp/helper.c,v 1.51 2003/09/17 22:28:08 paulo Exp $ */
d32 1
a32 7
#include "lisp/helper.h"
#include "lisp/pathname.h"
#include "lisp/package.h"
#include "lisp/read.h"
#include "lisp/stream.h"
#include "lisp/write.h"
#include "lisp/hash.h"
a33 4
#include <fcntl.h>
#include <errno.h>
#include <math.h>
#include <sys/stat.h>
d38 4
a41 5
static LispObj *LispReallyDo(LispBuiltin*, int);
static LispObj *LispReallyDoListTimes(LispBuiltin*, int);

/* in math.c */
extern LispObj *LispFloatCoerce(LispBuiltin*, LispObj*);
d47 1
a47 1
LispObjectCompare(LispObj *left, LispObj *right, int function)
d49 1
a49 2
    LispType ltype, rtype;
    LispObj *result = left == right ? T : NIL;
d51 5
a55 115
    /* If left and right are the same object, or if function is EQ */
    if (result == T || function == FEQ)
	return (result);

    ltype = OBJECT_TYPE(left);
    rtype = OBJECT_TYPE(right);

    /* Equalp requires that numeric objects be compared by value, and
     * strings or characters comparison be case insenstive */
    if (function == FEQUALP) {
	switch (ltype) {
	    case LispFixnum_t:
	    case LispInteger_t:
	    case LispBignum_t:
	    case LispDFloat_t:
	    case LispRatio_t:
	    case LispBigratio_t:
	    case LispComplex_t:
		switch (rtype) {
		    case LispFixnum_t:
		    case LispInteger_t:
		    case LispBignum_t:
		    case LispDFloat_t:
		    case LispRatio_t:
		    case LispBigratio_t:
		    case LispComplex_t:
			result = APPLY2(Oequal_, left, right);
			break;
		    default:
			break;
		}
		goto compare_done;
	    case LispSChar_t:
		if (rtype == LispSChar_t &&
		    toupper(SCHAR_VALUE(left)) == toupper(SCHAR_VALUE(right)))
		    result = T;
		goto compare_done;
	    case LispString_t:
		if (rtype == LispString_t && STRLEN(left) == STRLEN(right)) {
		    long i = STRLEN(left);
		    char *sl = THESTR(left), *sr = THESTR(right);

		    for (--i; i >= 0; i--)
			if (toupper(sl[i]) != toupper(sr[i]))
			    break;
		    if (i < 0)
			result = T;
		}
		goto compare_done;
	    case LispArray_t:
		if (rtype == LispArray_t &&
		    left->data.array.type == right->data.array.type &&
		    left->data.array.rank == right->data.array.rank &&
		    LispObjectCompare(left->data.array.dim,
				      right->data.array.dim,
				      FEQUAL) != NIL) {
		    LispObj *llist = left->data.array.list,
		    	    *rlist = right->data.array.list;

		    for (; CONSP(llist); llist = CDR(llist), rlist = CDR(rlist))
			if (LispObjectCompare(CAR(llist), CAR(rlist),
					      FEQUALP) == NIL)
			    break;
		    if (!CONSP(llist))
			result = T;
		}
		goto compare_done;
	    case LispStruct_t:
		if (rtype == LispStruct_t &&
		    left->data.struc.def == right->data.struc.def) {
		    LispObj *lfield = left->data.struc.fields,
		    	    *rfield = right->data.struc.fields;

		    for (; CONSP(lfield);
			 lfield = CDR(lfield), rfield = CDR(rfield)) {
			if (LispObjectCompare(CAR(lfield), CAR(rfield),
					      FEQUALP) != T)
			    break;
		    }
		    if (!CONSP(lfield))
			result = T;
		}
		goto compare_done;
	    case LispHashTable_t:
		if (rtype == LispHashTable_t &&
		    left->data.hash.table->count ==
		    right->data.hash.table->count &&
		    left->data.hash.test == right->data.hash.test) {
		    unsigned long i;
		    LispObj *test = left->data.hash.test;
		    LispHashEntry *lentry = left->data.hash.table->entries,
				  *llast = lentry +
					   left->data.hash.table->num_entries,
				  *rentry = right->data.hash.table->entries;

		    for (; lentry < llast; lentry++, rentry++) {
			if (lentry->count != rentry->count)
			    break;
			for (i = 0; i < lentry->count; i++) {
			    if (APPLY2(test,
				       lentry->keys[i],
				       rentry->keys[i]) == NIL ||
				LispObjectCompare(lentry->values[i],
						  rentry->values[i],
						  FEQUALP) == NIL)
				break;
			}
			if (i < lentry->count)
			    break;
		    }
		    if (lentry == llast)
			result = T;
		}
		goto compare_done;
	    default:
d57 3
a59 10
	}
    }

    /* Function is EQL or EQUAL, or EQUALP on arguments with the same rules */
    if (ltype == rtype) {
	switch (ltype) {
	    case LispFixnum_t:
	    case LispSChar_t:
		if (FIXNUM_VALUE(left) == FIXNUM_VALUE(right))
		    result = T;
d61 1
d63 2
a64 2
		if (INT_VALUE(left) == INT_VALUE(right))
		    result = T;
d66 1
a66 37
	    case LispDFloat_t:
		if (DFLOAT_VALUE(left) == DFLOAT_VALUE(right))
		    result = T;
		break;
	    case LispRatio_t:
		if (left->data.ratio.numerator ==
		    right->data.ratio.numerator &&
		    left->data.ratio.denominator ==
		    right->data.ratio.denominator)
		    result = T;
		break;
	    case LispComplex_t:
		if (LispObjectCompare(left->data.complex.real,
				      right->data.complex.real,
				      function) == T &&
		    LispObjectCompare(left->data.complex.imag,
				      right->data.complex.imag,
				      function) == T)
		    result = T;
		break;
	    case LispBignum_t:
		if (mpi_cmp(left->data.mp.integer, right->data.mp.integer) == 0)
		    result = T;
		break;
	    case LispBigratio_t:
		if (mpr_cmp(left->data.mp.ratio, right->data.mp.ratio) == 0)
		    result = T;
		break;
	    default:
		break;
	}

	/* Next types must be the same object for EQL */
	if (function == FEQL)
	    goto compare_done;

	switch (ltype) {
d68 2
a69 3
		if (STRLEN(left) == STRLEN(right) &&
		    memcmp(THESTR(left), THESTR(right), STRLEN(left)) == 0)
		    result = T;
d72 3
a74 3
		if (LispObjectCompare(CAR(left), CAR(right), function) == T &&
		    LispObjectCompare(CDR(left), CDR(right), function) == T)
		    result = T;
d77 1
a77 4
	    case LispBackquote_t:
	    case LispPathname_t:
		result = LispObjectCompare(left->data.pathname,
					   right->data.pathname, function);
d80 2
a81 3
		result = LispObjectCompare(left->data.lambda.name,
					   right->data.lambda.name,
					   function);
d85 1
a85 8
		    result = T;
		break;
	    case LispRegex_t:
		/* If the regexs are guaranteed to generate the same matches */
		if (left->data.regex.options == right->data.regex.options)
		    result = LispObjectCompare(left->data.regex.pattern,
					       right->data.regex.pattern,
					       function);
d88 2
d94 1
a94 2
compare_done:
    return (result);
d97 2
a98 4
void
LispCheckSequenceStartEnd(LispBuiltin *builtin,
			  LispObj *sequence, LispObj *start, LispObj *end,
			  long *pstart, long *pend, long *plength)
d100 2
a101 2
    /* Calculate length of sequence and check it's type */
    *plength = LispLength(sequence);
d103 10
a112 7
    /* Check start argument */
    if (start == UNSPEC || start == NIL)
	*pstart = 0;
    else {
	CHECK_INDEX(start);
	*pstart = FIXNUM_VALUE(start);
    }
d114 2
a115 7
    /* Check end argument */
    if (end == UNSPEC || end == NIL)
	*pend = *plength;
    else {
	CHECK_INDEX(end);
	*pend = FIXNUM_VALUE(end);
    }
d117 1
a117 9
    /* Check start argument */
    if (*pstart > *pend)
	LispDestroy("%s: :START %ld is larger than :END %ld",
		    STRFUN(builtin), *pstart, *pend);

    /* Check end argument */
    if (*pend > *plength)
	LispDestroy("%s: :END %ld is larger then sequence length %ld",
		    STRFUN(builtin), *pend, *plength);
d120 2
a121 2
long
LispLength(LispObj *sequence)
d123 1
a123 1
    long length;
d125 7
a131 22
    if (sequence == NIL)
	return (0);
    switch (OBJECT_TYPE(sequence)) {
	case LispString_t:
	    length = STRLEN(sequence);
	    break;
	case LispArray_t:
	    if (sequence->data.array.rank != 1)
		goto not_a_sequence;
	    sequence = sequence->data.array.list;
	    /*FALLTROUGH*/
	case LispCons_t:
	    for (length = 0;
		 CONSP(sequence);
		 length++, sequence = CDR(sequence))
		;
	    break;
	default:
not_a_sequence:
	    LispDestroy("LENGTH: %s is not a sequence", STROBJ(sequence));
	    /*NOTREACHED*/
	    length = 0;
d134 1
a134 1
    return (length);
d138 1
a138 1
LispCharacterCoerce(LispBuiltin *builtin, LispObj *object)
d140 17
a156 19
    if (SCHARP(object))
	return (object);
    else if (STRINGP(object) && STRLEN(object) == 1)
	return (SCHAR(THESTR(object)[0]));
    else if (SYMBOLP(object) && ATOMID(object)[1] == '\0')
	return (SCHAR(ATOMID(object)[0]));
    else if (INDEXP(object)) {
	int c = FIXNUM_VALUE(object);

	if (c <= 0xff)
	    return (SCHAR(c));
    }
    else if (object == T)
	return (SCHAR('T'));

    LispDestroy("%s: cannot convert %s to character",
		STRFUN(builtin), STROBJ(object));
    /*NOTREACHED*/
    return (NIL);
d160 1
a160 1
LispStringCoerce(LispBuiltin *builtin, LispObj *object)
d162 71
a232 19
    if (STRINGP(object))
	return (object);
    else if (SYMBOLP(object))
	return (LispSymbolName(object));
    else if (SCHARP(object)) {
	char string[1];

	string[0] = SCHAR_VALUE(object);
	return (LSTRING(string, 1));
    }
    else if (object == NIL)
	return (LSTRING(Snil, 3));
    else if (object == T)
	return (LSTRING(St, 1));
    else
	LispDestroy("%s: cannot convert %s to string",
		    STRFUN(builtin), STROBJ(object));
    /*NOTREACHED*/
    return (NIL);
d236 1
a236 2
LispCoerce(LispBuiltin *builtin,
	   LispObj *object, LispObj *result_type)
d238 67
a304 79
    LispObj *result = NIL;
    LispType type = LispNil_t;

    if (result_type == NIL)
	/* not even NIL can be converted to NIL? */
	LispDestroy("%s: cannot convert %s to NIL",
		    STRFUN(builtin), STROBJ(object));

    else if (result_type == T)
	/* no conversion */
	return (object);

    else if (!SYMBOLP(result_type))
	/* only know about simple types */
	LispDestroy("%s: bad argument %s",
		    STRFUN(builtin), STROBJ(result_type));

    else {
	/* check all known types */

	Atom_id atom = ATOMID(result_type);

	if (atom == Satom) {
	    if (CONSP(object))
		goto coerce_fail;
	    return (object);
	}
	/* only convert ATOM to SYMBOL */

	if (atom == Sfloat)
	    type = LispDFloat_t;
	else if (atom == Sinteger)
	    type = LispInteger_t;
	else if (atom == Scons || atom == Slist) {
	    if (object == NIL)
		return (object);
	    type = LispCons_t;
	}
	else if (atom == Sstring)
	    type = LispString_t;
	else if (atom == Scharacter)
	    type = LispSChar_t;
	else if (atom == Scomplex)
	    type = LispComplex_t;
	else if (atom == Svector || atom == Sarray)
	    type = LispArray_t;
	else if (atom == Sopaque)
	    type = LispOpaque_t;
	else if (atom == Srational)
	    type = LispRatio_t;
	else if (atom == Spathname)
	    type = LispPathname_t;
	else
	    LispDestroy("%s: invalid type specification %s",
			STRFUN(builtin), ATOMID(result_type));
    }

    if (OBJECT_TYPE(object) == LispOpaque_t) {
	switch (type) {
	    case LispAtom_t:
		result = ATOM(object->data.opaque.data);
		break;
	    case LispString_t:
		result = STRING(object->data.opaque.data);
		break;
	    case LispSChar_t:
		result = SCHAR((unsigned long)object->data.opaque.data);
		break;
	    case LispDFloat_t:
		result = DFLOAT((double)((long)object->data.opaque.data));
		break;
	    case LispInteger_t:
		result = INTEGER(((long)object->data.opaque.data));
		break;
	    case LispOpaque_t:
		result = OPAQUE(object->data.opaque.data, 0);
		break;
	    default:
		goto coerce_fail;
d307 5
d313 2
d316 63
a378 20
    else if (OBJECT_TYPE(object) != type) {
	switch (type) {
	    case LispInteger_t:
		if (INTEGERP(object))
		    result = object;
		else if (DFLOATP(object)) {
		    if ((long)DFLOAT_VALUE(object) == DFLOAT_VALUE(object))
			result = INTEGER((long)DFLOAT_VALUE(object));
		    else {
			mpi *integer = LispMalloc(sizeof(mpi));

			mpi_init(integer);
			mpi_setd(integer, DFLOAT_VALUE(object));
			if (mpi_getd(integer) != DFLOAT_VALUE(object)) {
			    mpi_clear(integer);
			    LispFree(integer);
			    goto coerce_fail;
			}
			result = BIGNUM(integer);
		    }
d380 12
a391 17
		else
		    goto coerce_fail;
		break;
	    case LispRatio_t:
		if (DFLOATP(object)) {
		    mpr *ratio = LispMalloc(sizeof(mpr));

		    mpr_init(ratio);
		    mpr_setd(ratio, DFLOAT_VALUE(object));
		    if (mpr_fiti(ratio)) {
			result = RATIO(mpi_geti(mpr_num(ratio)),
				       mpi_geti(mpr_den(ratio)));
			mpr_clear(ratio);
			LispFree(ratio);
		    }
		    else
			result = BIGRATIO(ratio);
a392 2
		else if (RATIONALP(object))
		    result = object;
d394 42
a435 37
		    goto coerce_fail;
		break;
	    case LispDFloat_t:
		result = LispFloatCoerce(builtin, object);
	    	break;
	    case LispComplex_t:
		if (NUMBERP(object))
		    result = object;
		else
		    goto coerce_fail;
		break;
	    case LispString_t:
		if (object == NIL)
		    result = STRING("");
		else
		    result = LispStringCoerce(builtin, object);
		break;
	    case LispSChar_t:
		result = LispCharacterCoerce(builtin, object);
		break;
	    case LispArray_t:
		if (LISTP(object))
		    result = VECTOR(object);
		else
		    goto coerce_fail;
		break;
	    case LispCons_t:
		if (ARRAYP(object) && object->data.array.rank == 1)
		    result = object->data.array.list;
		else
		    goto coerce_fail;
		break;
	    case LispPathname_t:
		result = APPLY1(Oparse_namestring, object);
		break;
	    default:
		goto coerce_fail;
d437 1
a438 2
    else
	result = object;
d440 1
a440 7
    return (result);

coerce_fail:
    LispDestroy("%s: cannot convert %s to %s",
		STRFUN(builtin), STROBJ(object), ATOMID(result_type));
    /* NOTREACHED */
    return (NIL);
d444 1
a444 5
LispReallyDo(LispBuiltin *builtin, int refs)
/*
 do init test &rest body
 do* init test &rest body
 */
d446 38
a483 31
    GC_ENTER();
    int stack, lex, head;
    LispObj *list, *symbol, *value, *values, *cons;

    LispObj *init, *test, *body;

    body = ARGUMENT(2);
    test = ARGUMENT(1);
    init = ARGUMENT(0);

    if (!CONSP(test))
	LispDestroy("%s: end test condition must be a list, not %s",
		    STRFUN(builtin), STROBJ(init));

    CHECK_LIST(init);

    /* Save state */
    stack = lisp__data.stack.length;
    lex = lisp__data.env.lex;
    head = lisp__data.env.length;

    values = cons = NIL;
    for (list = init; CONSP(list); list = CDR(list)) {
	symbol = CAR(list);
	if (!SYMBOLP(symbol)) {
	    CHECK_CONS(symbol);
	    value = CDR(symbol);
	    symbol = CAR(symbol);
	    CHECK_SYMBOL(symbol);
	    CHECK_CONS(value);
	    value = EVAL(CAR(value));
d485 3
d489 4
a492 9
	    value = NIL;

	CHECK_CONSTANT(symbol);

	LispAddVar(symbol, value);

	/* Bind variable now */
	if (refs) {
	    ++lisp__data.env.head;
d495 14
a508 8
	    if (values == NIL) {
		values = cons = CONS(NIL, NIL);
		GC_PROTECT(values);
	    }
	    else {
		RPLACD(cons, CONS(NIL, NIL));
		cons = CDR(cons);
	    }
a510 2
    if (!refs)
	lisp__data.env.head = lisp__data.env.length;
d512 1
d514 3
a516 1
	if (EVAL(CAR(test)) != NIL)
a517 25

	/* TODO Run this code in an implicit tagbody */
	for (list = body; CONSP(list); list = CDR(list))
	    (void)EVAL(CAR(list));

	/* Error checking already done in the initialization */
	for (list = init, cons = values; CONSP(list); list = CDR(list)) {
	    symbol = CAR(list);
	    if (CONSP(symbol)) {
		value = CDDR(symbol);
		symbol = CAR(symbol);
		if (CONSP(value))
		    value = EVAL(CAR(value));
		else
		    value = NIL;
	    }
	    else
		value = NIL;

	    if (refs)
		LispSetVar(symbol, value);
	    else {
		RPLACA(cons, value);
		cons = CDR(cons);
	    }
d519 7
a525 10
	if (!refs) {
	    for (list = init, cons = values;
		 CONSP(list);
		 list = CDR(list), cons = CDR(cons)) {
		symbol = CAR(list);
		if (CONSP(symbol)) {
		    if (CONSP(CDR(symbol)))
			LispSetVar(CAR(symbol), CAR(cons));
		}
	    }
d529 2
a530 10
    if (CONSP(CDR(test)))
	value = EVAL(CADR(test));
    else
	value = NIL;

    /* Restore state */
    lisp__data.stack.length = stack;
    lisp__data.env.lex = lex;
    lisp__data.env.head = lisp__data.env.length = head;
    GC_LEAVE();
d532 1
a532 1
    return (value);
d536 1
a536 5
LispDo(LispBuiltin *builtin, int refs)
/*
 do init test &rest body
 do* init test &rest body
 */
d538 2
a539 2
    int jumped;
    LispObj *result;
d542 3
a544 3
    jumped = 1;
    result = NIL;
    block = LispBeginBlock(NIL, LispBlockTag);
d546 2
a547 2
	result = LispReallyDo(builtin, refs);
	jumped = 0;
d549 3
a551 3
    LispEndBlock(block);
    if (jumped)
	result = lisp__data.block.block_ret;
d553 1
a553 1
    return (result);
d557 1
a557 5
LispReallyDoListTimes(LispBuiltin *builtin, int times)
/*
 dolist init &rest body
 dotimes init &rest body
 */
d559 2
a560 7
    GC_ENTER();
    int head = lisp__data.env.length;
    long count = 0, end = 0;
    LispObj *symbol, *value = NIL, *result = NIL, *init, *body, *object;

    body = ARGUMENT(1);
    init = ARGUMENT(0);
d563 18
a580 8
    CHECK_CONS(init);
    symbol = CAR(init);
    CHECK_SYMBOL(symbol);
    init = CDR(init);

    if (init == NIL) {
	if (times)
	    LispDestroy("%s: NIL is not a number", STRFUN(builtin));
d583 9
a591 6
	CHECK_CONS(init);
	value = CAR(init);
	init = CDR(init);
	if (init != NIL) {
	    CHECK_CONS(init);
	    result = CAR(init);
d593 3
d597 1
a597 1
	value = EVAL(value);
d599 6
a604 9
	if (times) {
	    CHECK_INDEX(value);
	    end = FIXNUM_VALUE(value);
	}
	else {
	    CHECK_LIST(value);
	    /* Protect iteration control from gc */
	    GC_PROTECT(value);
	}
d607 2
a608 9
    /* The variable is only bound inside the loop, so it is safe to optimize
     * it out if there is no code to execute. But the result form may reference
     * the bound variable. */
    if (!CONSP(body)) {
	if (times)
	    count = end;
	else
	    value = NIL;
    }
a610 1
    CHECK_CONSTANT(symbol);
d612 1
a612 1
	LispAddVar(symbol, FIXNUM(count));
d614 1
a614 5
	LispAddVar(symbol, CONSP(value) ? CAR(value) : value);
    ++lisp__data.env.head;

    if (!CONSP(body) || (times && count >= end) || (!times && !CONSP(value)))
	goto loop_done;
d618 1
a618 4
	for (object = body; CONSP(object); object = CDR(object))
	    (void)EVAL(CAR(object));

	/* Update symbols and check exit condition */
d620 1
a620 3
	    ++count;
	    LispSetVar(symbol, FIXNUM(count));
	    if (count >= end)
d623 8
d632 2
a633 3
	    value = CDR(value);
	    if (!CONSP(value)) {
		LispSetVar(symbol, NIL);
d635 3
a637 2
	    }
	    LispSetVar(symbol, CAR(value));
d641 2
a642 4
loop_done:
    result = EVAL(result);
    lisp__data.env.head = lisp__data.env.length = head;
    GC_LEAVE();
d644 1
a644 1
    return (result);
d648 1
a648 5
LispDoListTimes(LispBuiltin *builtin, int times)
/*
 dolist init &rest body
 dotimes init &rest body
 */
d651 1
a651 1
    LispObj *result, **presult = &result;
d654 1
a654 1
    *presult = NIL;
d656 1
a656 1
    block = LispBeginBlock(NIL, LispBlockTag);
d658 2
a659 2
	result = LispReallyDoListTimes(builtin, times);
	did_jump = 0;
d661 11
a671 3
    LispEndBlock(block);
    if (did_jump)
	result = lisp__data.block.block_ret;
d673 12
a684 1
    return (result);
d688 1
a688 1
LispLoadFile(LispObj *filename, int verbose, int print, int ifdoesnotexist)
d690 1
a690 2
    LispObj *stream, *cod, *obj, *result;
    int ch;
d692 7
a698 2
    LispObj *savepackage;
    LispPackage *savepack;
d700 4
a703 2
    if (verbose)
	LispMessage("; Loading %s", THESTR(filename));
d705 9
a713 6
    if (ifdoesnotexist) {
	GC_ENTER();
	result = CONS(filename, CONS(Kif_does_not_exist, CONS(Kerror, NIL)));
	GC_PROTECT(result);
	stream = APPLY(Oopen, result);
	GC_LEAVE();
d715 2
a716 2
    else
	stream = APPLY1(Oopen, filename);
d718 11
a728 1
    if (stream == NIL)
d730 1
d732 31
a762 3
    result = NIL;
    LispPushInput(stream);
    ch = LispGet();
d764 2
a765 2
	LispUnget(ch);
    else if ((ch = LispGet()) == '!') {
d767 1
a767 1
	    ch = LispGet();
d773 2
a774 2
	LispUnget(ch);
	LispUnget('#');
a776 6
    /* Save package environment */
    savepackage = PACKAGE;
    savepack = lisp__data.pack;

    cod = COD;

d779 6
a784 11
	if ((obj = LispRead()) != NULL) {
	    result = EVAL(obj);
	    COD = cod;
	    if (print) {
		int i;

		if (RETURN_COUNT >= 0)
		    LispPrint(result, NIL, 1);
		for (i = 0; i < RETURN_COUNT; i++)
		    LispPrint(RETURN(i), NIL, 1);
	    }
d786 1
a786 1
	if (lisp__data.eof)
d789 8
a796 1
    LispPopInput(stream);
d798 2
a799 3
    /* Restore package environment */
    PACKAGE = savepackage;
    lisp__data.pack = savepack;
d801 33
a833 1
    APPLY1(Oclose, stream);
d835 2
a836 1
    return (T);
d840 2
a841 3
LispGetStringArgs(LispBuiltin *builtin,
		  char **string1, char **string2,
		  long *start1, long *end1, long *start2, long *end2)
d843 2
a844 2
    long length1, length2;
    LispObj *ostring1, *ostring2, *ostart1, *oend1, *ostart2, *oend2;
d846 3
a848 14
    oend2 = ARGUMENT(5);
    ostart2 = ARGUMENT(4);
    oend1 = ARGUMENT(3);
    ostart1 = ARGUMENT(2);
    ostring2 = ARGUMENT(1);
    ostring1 = ARGUMENT(0);

    CHECK_STRING(ostring1);
    *string1 = THESTR(ostring1);
    length1 = STRLEN(ostring1);

    CHECK_STRING(ostring2);
    *string2 = THESTR(ostring2);
    length2 = STRLEN(ostring2);
d850 3
a852 12
    if (ostart1 == UNSPEC)
	*start1 = 0;
    else {
	CHECK_INDEX(ostart1);
	*start1 = FIXNUM_VALUE(ostart1);
    }
    if (oend1 == UNSPEC)
	*end1 = length1;
    else {
	CHECK_INDEX(oend1);
	*end1 = FIXNUM_VALUE(oend1);
    }
d854 3
a856 6
    if (ostart2 == UNSPEC)
	*start2 = 0;
    else {
	CHECK_INDEX(ostart2);
	*start2 = FIXNUM_VALUE(ostart2);
    }
d858 3
a860 6
    if (oend2 == UNSPEC)
	*end2 = length2;
    else {
	CHECK_INDEX(oend2);
	*end2 = FIXNUM_VALUE(oend2);
    }
d862 2
a863 12
    if (*start1 > *end1)
	LispDestroy("%s: :START1 %ld larger than :END1 %ld",
		    STRFUN(builtin), *start1, *end1);
    if (*start2 > *end2)
	LispDestroy("%s: :START2 %ld larger than :END2 %ld",
		    STRFUN(builtin), *start2, *end2);
    if (*end1 > length1)
	LispDestroy("%s: :END1 %ld larger than string length %ld",
		    STRFUN(builtin), *end1, length1);
    if (*end2 > length2)
	LispDestroy("%s: :END2 %ld larger than string length %ld",
		    STRFUN(builtin), *end2, length2);
d867 1
a867 1
LispPathnameField(int field, int string)
d869 26
a894 36
    int offset = field;
    LispObj *pathname, *result, *object;

    pathname = ARGUMENT(0);

    if (!PATHNAMEP(pathname))
	pathname = APPLY1(Oparse_namestring, pathname);

    result = pathname->data.pathname;
    while (offset) {
	result = CDR(result);
	--offset;
    }
    object = result;
    result = CAR(result);

    if (string) {
	if (!STRINGP(result)) {
	    if (result == NIL)
		result = STRING("");
	    else if (field == PATH_DIRECTORY) {
		char *name = THESTR(CAR(pathname->data.pathname)), *ptr;

		ptr = strrchr(name, PATH_SEP);
		if (ptr) {
		    int length = ptr - name + 1;
		    char data[PATH_MAX];

		    if (length > PATH_MAX - 1)
			length = PATH_MAX - 1;
		    strncpy(data, name, length);
		    data[length] = '\0';
		    result = STRING(data);
		}
		else
		    result = STRING("");
a895 2
	    else
		result = Kunspecific;
d897 8
a904 16
	else if (field == PATH_NAME) {
	    object = CAR(CDR(object));
	    if (STRINGP(object)) {
		int length;
		char name[PATH_MAX + 1];

		strcpy(name, THESTR(result));
		length = STRLEN(result);
		if (length + 1 < sizeof(name)) {
		    name[length++] = PATH_TYPESEP;
		    name[length] = '\0';
		}
		if (STRLEN(object) + length < sizeof(name))
		    strcpy(name + length, THESTR(object));
		/* else LispDestroy ... */
		result = STRING(name);
d908 2
d911 23
a933 43
    return (result);
}

LispObj *
LispProbeFile(LispBuiltin *builtin, int probe)
{
    GC_ENTER();
    LispObj *result;
    char *name = NULL, resolved[PATH_MAX + 1];
    struct stat st;

    LispObj *pathname;

    pathname = ARGUMENT(0);

    if (!POINTERP(pathname))
	goto bad_pathname;

    if (XSTRINGP(pathname))
	name = THESTR(pathname);
    else if (XPATHNAMEP(pathname))
	name = THESTR(CAR(pathname->data.pathname));
    else if (STREAMP(pathname) && pathname->data.stream.type == LispStreamFile)
	name = THESTR(CAR(pathname->data.stream.pathname->data.pathname));

#ifndef __UNIXOS2__
    if (realpath(name, &resolved[0]) == NULL ||
	stat(resolved, &st)) {
#else
    if ((name == NULL) || stat(resolved, &st)) {
#endif
	if (probe)
	    return (NIL);
	LispDestroy("%s: realpath(\"%s\"): %s",
		    STRFUN(builtin), name, strerror(errno));
    }

    if (S_ISDIR(st.st_mode)) {
	int length = strlen(resolved);

	if (!length || resolved[length - 1] != PATH_SEP) {
	    resolved[length++] = PATH_SEP;
	    resolved[length] = '\0';
d937 2
a938 22
    result = STRING(resolved);
    GC_PROTECT(result);
    result = APPLY1(Oparse_namestring, result);
    GC_LEAVE();

    return (result);

bad_pathname:
    LispDestroy("%s: bad pathname %s", STRFUN(builtin), STROBJ(pathname));
    /*NOTREACHED*/
    return (NIL);
}

LispObj *
LispWriteString_(LispBuiltin *builtin, int newline)
/*
 write-line string &optional output-stream &key start end
 write-string string &optional output-stream &key start end
 */
{
    char *text;
    long start, end, length;
d940 4
a943 1
    LispObj *string, *output_stream, *ostart, *oend;
d945 2
a946 15
    oend = ARGUMENT(3);
    ostart = ARGUMENT(2);
    output_stream = ARGUMENT(1);
    string = ARGUMENT(0);

    CHECK_STRING(string);
    LispCheckSequenceStartEnd(builtin, string, ostart, oend,
			      &start, &end, &length);
    if (output_stream == UNSPEC)
	output_stream = NIL;
    text = THESTR(string);
    if (end > start)
	LispWriteStr(output_stream, text + start, end - start);
    if (newline)
	LispWriteChar(output_stream, '\n');
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d30 1
a30 1
/* $XFree86: xc/programs/xedit/lisp/helper.c,v 1.47 2002/11/26 04:06:28 paulo Exp $ */
a32 6
#include "pathname.h"
#include "package.h"
#include "read.h"
#include "stream.h"
#include "write.h"
#include "hash.h"
a33 4
#include <fcntl.h>
#include <errno.h>
#include <math.h>
#include <sys/stat.h>
d38 4
a41 5
static LispObj *LispReallyDo(LispBuiltin*, int);
static LispObj *LispReallyDoListTimes(LispBuiltin*, int);

/* in math.c */
extern LispObj *LispFloatCoerce(LispBuiltin*, LispObj*);
d47 1
a47 1
LispObjectCompare(LispObj *left, LispObj *right, int function)
d49 1
a49 2
    LispType ltype, rtype;
    LispObj *result = left == right ? T : NIL;
d51 5
a55 115
    /* If left and right are the same object, or if function is EQ */
    if (result == T || function == FEQ)
	return (result);

    ltype = OBJECT_TYPE(left);
    rtype = OBJECT_TYPE(right);

    /* Equalp requires that numeric objects be compared by value, and
     * strings or characters comparison be case insenstive */
    if (function == FEQUALP) {
	switch (ltype) {
	    case LispFixnum_t:
	    case LispInteger_t:
	    case LispBignum_t:
	    case LispDFloat_t:
	    case LispRatio_t:
	    case LispBigratio_t:
	    case LispComplex_t:
		switch (rtype) {
		    case LispFixnum_t:
		    case LispInteger_t:
		    case LispBignum_t:
		    case LispDFloat_t:
		    case LispRatio_t:
		    case LispBigratio_t:
		    case LispComplex_t:
			result = APPLY2(Oequal_, left, right);
			break;
		    default:
			break;
		}
		goto compare_done;
	    case LispSChar_t:
		if (rtype == LispSChar_t &&
		    toupper(SCHAR_VALUE(left)) == toupper(SCHAR_VALUE(right)))
		    result = T;
		goto compare_done;
	    case LispString_t:
		if (rtype == LispString_t && STRLEN(left) == STRLEN(right)) {
		    long i = STRLEN(left);
		    char *sl = THESTR(left), *sr = THESTR(right);

		    for (--i; i >= 0; i--)
			if (toupper(sl[i]) != toupper(sr[i]))
			    break;
		    if (i < 0)
			result = T;
		}
		goto compare_done;
	    case LispArray_t:
		if (rtype == LispArray_t &&
		    left->data.array.type == right->data.array.type &&
		    left->data.array.rank == right->data.array.rank &&
		    LispObjectCompare(left->data.array.dim,
				      right->data.array.dim,
				      FEQUAL) != NIL) {
		    LispObj *llist = left->data.array.list,
		    	    *rlist = right->data.array.list;

		    for (; CONSP(llist); llist = CDR(llist), rlist = CDR(rlist))
			if (LispObjectCompare(CAR(llist), CAR(rlist),
					      FEQUALP) == NIL)
			    break;
		    if (!CONSP(llist))
			result = T;
		}
		goto compare_done;
	    case LispStruct_t:
		if (rtype == LispStruct_t &&
		    left->data.struc.def == right->data.struc.def) {
		    LispObj *lfield = left->data.struc.fields,
		    	    *rfield = right->data.struc.fields;

		    for (; CONSP(lfield);
			 lfield = CDR(lfield), rfield = CDR(rfield)) {
			if (LispObjectCompare(CAR(lfield), CAR(rfield),
					      FEQUALP) != T)
			    break;
		    }
		    if (!CONSP(lfield))
			result = T;
		}
		goto compare_done;
	    case LispHashTable_t:
		if (rtype == LispHashTable_t &&
		    left->data.hash.table->count ==
		    right->data.hash.table->count &&
		    left->data.hash.test == right->data.hash.test) {
		    unsigned long i;
		    LispObj *test = left->data.hash.test;
		    LispHashEntry *lentry = left->data.hash.table->entries,
				  *llast = lentry +
					   left->data.hash.table->num_entries,
				  *rentry = right->data.hash.table->entries;

		    for (; lentry < llast; lentry++, rentry++) {
			if (lentry->count != rentry->count)
			    break;
			for (i = 0; i < lentry->count; i++) {
			    if (APPLY2(test,
				       lentry->keys[i],
				       rentry->keys[i]) == NIL ||
				LispObjectCompare(lentry->values[i],
						  rentry->values[i],
						  FEQUALP) == NIL)
				break;
			}
			if (i < lentry->count)
			    break;
		    }
		    if (lentry == llast)
			result = T;
		}
		goto compare_done;
	    default:
d57 3
a59 10
	}
    }

    /* Function is EQL or EQUAL, or EQUALP on arguments with the same rules */
    if (ltype == rtype) {
	switch (ltype) {
	    case LispFixnum_t:
	    case LispSChar_t:
		if (FIXNUM_VALUE(left) == FIXNUM_VALUE(right))
		    result = T;
d61 1
d63 2
a64 2
		if (INT_VALUE(left) == INT_VALUE(right))
		    result = T;
d66 1
a66 37
	    case LispDFloat_t:
		if (DFLOAT_VALUE(left) == DFLOAT_VALUE(right))
		    result = T;
		break;
	    case LispRatio_t:
		if (left->data.ratio.numerator ==
		    right->data.ratio.numerator &&
		    left->data.ratio.denominator ==
		    right->data.ratio.denominator)
		    result = T;
		break;
	    case LispComplex_t:
		if (LispObjectCompare(left->data.complex.real,
				      right->data.complex.real,
				      function) == T &&
		    LispObjectCompare(left->data.complex.imag,
				      right->data.complex.imag,
				      function) == T)
		    result = T;
		break;
	    case LispBignum_t:
		if (mpi_cmp(left->data.mp.integer, right->data.mp.integer) == 0)
		    result = T;
		break;
	    case LispBigratio_t:
		if (mpr_cmp(left->data.mp.ratio, right->data.mp.ratio) == 0)
		    result = T;
		break;
	    default:
		break;
	}

	/* Next types must be the same object for EQL */
	if (function == FEQL)
	    goto compare_done;

	switch (ltype) {
d68 2
a69 3
		if (STRLEN(left) == STRLEN(right) &&
		    memcmp(THESTR(left), THESTR(right), STRLEN(left)) == 0)
		    result = T;
d72 3
a74 3
		if (LispObjectCompare(CAR(left), CAR(right), function) == T &&
		    LispObjectCompare(CDR(left), CDR(right), function) == T)
		    result = T;
d77 1
a77 4
	    case LispBackquote_t:
	    case LispPathname_t:
		result = LispObjectCompare(left->data.pathname,
					   right->data.pathname, function);
d80 2
a81 3
		result = LispObjectCompare(left->data.lambda.name,
					   right->data.lambda.name,
					   function);
d85 1
a85 8
		    result = T;
		break;
	    case LispRegex_t:
		/* If the regexs are guaranteed to generate the same matches */
		if (left->data.regex.options == right->data.regex.options)
		    result = LispObjectCompare(left->data.regex.pattern,
					       right->data.regex.pattern,
					       function);
d88 2
d94 1
a94 2
compare_done:
    return (result);
d97 2
a98 4
void
LispCheckSequenceStartEnd(LispBuiltin *builtin,
			  LispObj *sequence, LispObj *start, LispObj *end,
			  long *pstart, long *pend, long *plength)
d100 2
a101 2
    /* Calculate length of sequence and check it's type */
    *plength = LispLength(sequence);
d103 10
a112 7
    /* Check start argument */
    if (start == UNSPEC || start == NIL)
	*pstart = 0;
    else {
	CHECK_INDEX(start);
	*pstart = FIXNUM_VALUE(start);
    }
d114 2
a115 7
    /* Check end argument */
    if (end == UNSPEC || end == NIL)
	*pend = *plength;
    else {
	CHECK_INDEX(end);
	*pend = FIXNUM_VALUE(end);
    }
d117 1
a117 9
    /* Check start argument */
    if (*pstart > *pend)
	LispDestroy("%s: :START %ld is larger than :END %ld",
		    STRFUN(builtin), *pstart, *pend);

    /* Check end argument */
    if (*pend > *plength)
	LispDestroy("%s: :END %ld is larger then sequence length %ld",
		    STRFUN(builtin), *pend, *plength);
d120 2
a121 2
long
LispLength(LispObj *sequence)
d123 1
a123 1
    long length;
d125 7
a131 22
    if (sequence == NIL)
	return (0);
    switch (OBJECT_TYPE(sequence)) {
	case LispString_t:
	    length = STRLEN(sequence);
	    break;
	case LispArray_t:
	    if (sequence->data.array.rank != 1)
		goto not_a_sequence;
	    sequence = sequence->data.array.list;
	    /*FALLTROUGH*/
	case LispCons_t:
	    for (length = 0;
		 CONSP(sequence);
		 length++, sequence = CDR(sequence))
		;
	    break;
	default:
not_a_sequence:
	    LispDestroy("LENGTH: %s is not a sequence", STROBJ(sequence));
	    /*NOTREACHED*/
	    length = 0;
d134 1
a134 1
    return (length);
d138 1
a138 1
LispCharacterCoerce(LispBuiltin *builtin, LispObj *object)
d140 17
a156 19
    if (SCHARP(object))
	return (object);
    else if (STRINGP(object) && STRLEN(object) == 1)
	return (SCHAR(THESTR(object)[0]));
    else if (SYMBOLP(object) && ATOMID(object)[1] == '\0')
	return (SCHAR(ATOMID(object)[0]));
    else if (INDEXP(object)) {
	int c = FIXNUM_VALUE(object);

	if (c <= 0xff)
	    return (SCHAR(c));
    }
    else if (object == T)
	return (SCHAR('T'));

    LispDestroy("%s: cannot convert %s to character",
		STRFUN(builtin), STROBJ(object));
    /*NOTREACHED*/
    return (NIL);
d160 1
a160 1
LispStringCoerce(LispBuiltin *builtin, LispObj *object)
d162 71
a232 19
    if (STRINGP(object))
	return (object);
    else if (SYMBOLP(object))
	return (LispSymbolName(object));
    else if (SCHARP(object)) {
	char string[1];

	string[0] = SCHAR_VALUE(object);
	return (LSTRING(string, 1));
    }
    else if (object == NIL)
	return (LSTRING(Snil, 3));
    else if (object == T)
	return (LSTRING(St, 1));
    else
	LispDestroy("%s: cannot convert %s to string",
		    STRFUN(builtin), STROBJ(object));
    /*NOTREACHED*/
    return (NIL);
d236 1
a236 2
LispCoerce(LispBuiltin *builtin,
	   LispObj *object, LispObj *result_type)
d238 67
a304 79
    LispObj *result = NIL;
    LispType type = LispNil_t;

    if (result_type == NIL)
	/* not even NIL can be converted to NIL? */
	LispDestroy("%s: cannot convert %s to NIL",
		    STRFUN(builtin), STROBJ(object));

    else if (result_type == T)
	/* no conversion */
	return (object);

    else if (!SYMBOLP(result_type))
	/* only know about simple types */
	LispDestroy("%s: bad argument %s",
		    STRFUN(builtin), STROBJ(result_type));

    else {
	/* check all known types */

	Atom_id atom = ATOMID(result_type);

	if (atom == Satom) {
	    if (CONSP(object))
		goto coerce_fail;
	    return (object);
	}
	/* only convert ATOM to SYMBOL */

	if (atom == Sfloat)
	    type = LispDFloat_t;
	else if (atom == Sinteger)
	    type = LispInteger_t;
	else if (atom == Scons || atom == Slist) {
	    if (object == NIL)
		return (object);
	    type = LispCons_t;
	}
	else if (atom == Sstring)
	    type = LispString_t;
	else if (atom == Scharacter)
	    type = LispSChar_t;
	else if (atom == Scomplex)
	    type = LispComplex_t;
	else if (atom == Svector || atom == Sarray)
	    type = LispArray_t;
	else if (atom == Sopaque)
	    type = LispOpaque_t;
	else if (atom == Srational)
	    type = LispRatio_t;
	else if (atom == Spathname)
	    type = LispPathname_t;
	else
	    LispDestroy("%s: invalid type specification %s",
			STRFUN(builtin), ATOMID(result_type));
    }

    if (OBJECT_TYPE(object) == LispOpaque_t) {
	switch (type) {
	    case LispAtom_t:
		result = ATOM(object->data.opaque.data);
		break;
	    case LispString_t:
		result = STRING(object->data.opaque.data);
		break;
	    case LispSChar_t:
		result = SCHAR((unsigned long)object->data.opaque.data);
		break;
	    case LispDFloat_t:
		result = DFLOAT((double)((long)object->data.opaque.data));
		break;
	    case LispInteger_t:
		result = INTEGER(((long)object->data.opaque.data));
		break;
	    case LispOpaque_t:
		result = OPAQUE(object->data.opaque.data, 0);
		break;
	    default:
		goto coerce_fail;
d307 5
d313 2
d316 63
a378 20
    else if (OBJECT_TYPE(object) != type) {
	switch (type) {
	    case LispInteger_t:
		if (INTEGERP(object))
		    result = object;
		else if (DFLOATP(object)) {
		    if ((long)DFLOAT_VALUE(object) == DFLOAT_VALUE(object))
			result = INTEGER((long)DFLOAT_VALUE(object));
		    else {
			mpi *integer = LispMalloc(sizeof(mpi));

			mpi_init(integer);
			mpi_setd(integer, DFLOAT_VALUE(object));
			if (mpi_getd(integer) != DFLOAT_VALUE(object)) {
			    mpi_clear(integer);
			    LispFree(integer);
			    goto coerce_fail;
			}
			result = BIGNUM(integer);
		    }
d380 12
a391 17
		else
		    goto coerce_fail;
		break;
	    case LispRatio_t:
		if (DFLOATP(object)) {
		    mpr *ratio = LispMalloc(sizeof(mpr));

		    mpr_init(ratio);
		    mpr_setd(ratio, DFLOAT_VALUE(object));
		    if (mpr_fiti(ratio)) {
			result = RATIO(mpi_geti(mpr_num(ratio)),
				       mpi_geti(mpr_den(ratio)));
			mpr_clear(ratio);
			LispFree(ratio);
		    }
		    else
			result = BIGRATIO(ratio);
a392 2
		else if (RATIONALP(object))
		    result = object;
d394 42
a435 37
		    goto coerce_fail;
		break;
	    case LispDFloat_t:
		result = LispFloatCoerce(builtin, object);
	    	break;
	    case LispComplex_t:
		if (NUMBERP(object))
		    result = object;
		else
		    goto coerce_fail;
		break;
	    case LispString_t:
		if (object == NIL)
		    result = STRING("");
		else
		    result = LispStringCoerce(builtin, object);
		break;
	    case LispSChar_t:
		result = LispCharacterCoerce(builtin, object);
		break;
	    case LispArray_t:
		if (LISTP(object))
		    result = VECTOR(object);
		else
		    goto coerce_fail;
		break;
	    case LispCons_t:
		if (ARRAYP(object) && object->data.array.rank == 1)
		    result = object->data.array.list;
		else
		    goto coerce_fail;
		break;
	    case LispPathname_t:
		result = APPLY1(Oparse_namestring, object);
		break;
	    default:
		goto coerce_fail;
d437 1
a438 2
    else
	result = object;
d440 1
a440 7
    return (result);

coerce_fail:
    LispDestroy("%s: cannot convert %s to %s",
		STRFUN(builtin), STROBJ(object), ATOMID(result_type));
    /* NOTREACHED */
    return (NIL);
d444 1
a444 5
LispReallyDo(LispBuiltin *builtin, int refs)
/*
 do init test &rest body
 do* init test &rest body
 */
d446 38
a483 31
    GC_ENTER();
    int stack, lex, head;
    LispObj *list, *symbol, *value, *values, *cons;

    LispObj *init, *test, *body;

    body = ARGUMENT(2);
    test = ARGUMENT(1);
    init = ARGUMENT(0);

    if (!CONSP(test))
	LispDestroy("%s: end test condition must be a list, not %s",
		    STRFUN(builtin), STROBJ(init));

    CHECK_LIST(init);

    /* Save state */
    stack = lisp__data.stack.length;
    lex = lisp__data.env.lex;
    head = lisp__data.env.length;

    values = cons = NIL;
    for (list = init; CONSP(list); list = CDR(list)) {
	symbol = CAR(list);
	if (!SYMBOLP(symbol)) {
	    CHECK_CONS(symbol);
	    value = CDR(symbol);
	    symbol = CAR(symbol);
	    CHECK_SYMBOL(symbol);
	    CHECK_CONS(value);
	    value = EVAL(CAR(value));
d485 3
d489 4
a492 9
	    value = NIL;

	CHECK_CONSTANT(symbol);

	LispAddVar(symbol, value);

	/* Bind variable now */
	if (refs) {
	    ++lisp__data.env.head;
d495 14
a508 8
	    if (values == NIL) {
		values = cons = CONS(NIL, NIL);
		GC_PROTECT(values);
	    }
	    else {
		RPLACD(cons, CONS(NIL, NIL));
		cons = CDR(cons);
	    }
a510 2
    if (!refs)
	lisp__data.env.head = lisp__data.env.length;
d512 1
d514 3
a516 1
	if (EVAL(CAR(test)) != NIL)
a517 25

	/* TODO Run this code in an implicit tagbody */
	for (list = body; CONSP(list); list = CDR(list))
	    (void)EVAL(CAR(list));

	/* Error checking already done in the initialization */
	for (list = init, cons = values; CONSP(list); list = CDR(list)) {
	    symbol = CAR(list);
	    if (CONSP(symbol)) {
		value = CDDR(symbol);
		symbol = CAR(symbol);
		if (CONSP(value))
		    value = EVAL(CAR(value));
		else
		    value = NIL;
	    }
	    else
		value = NIL;

	    if (refs)
		LispSetVar(symbol, value);
	    else {
		RPLACA(cons, value);
		cons = CDR(cons);
	    }
d519 7
a525 10
	if (!refs) {
	    for (list = init, cons = values;
		 CONSP(list);
		 list = CDR(list), cons = CDR(cons)) {
		symbol = CAR(list);
		if (CONSP(symbol)) {
		    if (CONSP(CDR(symbol)))
			LispSetVar(CAR(symbol), CAR(cons));
		}
	    }
d529 2
a530 10
    if (CONSP(CDR(test)))
	value = EVAL(CADR(test));
    else
	value = NIL;

    /* Restore state */
    lisp__data.stack.length = stack;
    lisp__data.env.lex = lex;
    lisp__data.env.head = lisp__data.env.length = head;
    GC_LEAVE();
d532 1
a532 1
    return (value);
d536 1
a536 5
LispDo(LispBuiltin *builtin, int refs)
/*
 do init test &rest body
 do* init test &rest body
 */
d538 2
a539 2
    int jumped, *pjumped;
    LispObj *result, **presult;
d542 3
a544 5
    jumped = 1;
    result = NIL;
    presult = &result;
    pjumped = &jumped;
    block = LispBeginBlock(NIL, LispBlockTag);
d546 2
a547 2
	result = LispReallyDo(builtin, refs);
	jumped = 0;
d549 3
a551 3
    LispEndBlock(block);
    if (jumped)
	result = lisp__data.block.block_ret;
d553 1
a553 1
    return (result);
d557 1
a557 5
LispReallyDoListTimes(LispBuiltin *builtin, int times)
/*
 dolist init &rest body
 dotimes init &rest body
 */
d559 2
a560 7
    GC_ENTER();
    int head = lisp__data.env.length;
    long count = 0, end = 0;
    LispObj *symbol, *value = NIL, *result = NIL, *init, *body, *object;

    body = ARGUMENT(1);
    init = ARGUMENT(0);
d563 18
a580 8
    CHECK_CONS(init);
    symbol = CAR(init);
    CHECK_SYMBOL(symbol);
    init = CDR(init);

    if (init == NIL) {
	if (times)
	    LispDestroy("%s: NIL is not a number", STRFUN(builtin));
d583 9
a591 6
	CHECK_CONS(init);
	value = CAR(init);
	init = CDR(init);
	if (init != NIL) {
	    CHECK_CONS(init);
	    result = CAR(init);
d593 3
d597 1
a597 1
	value = EVAL(value);
d599 6
a604 9
	if (times) {
	    CHECK_INDEX(value);
	    end = FIXNUM_VALUE(value);
	}
	else {
	    CHECK_LIST(value);
	    /* Protect iteration control from gc */
	    GC_PROTECT(value);
	}
d607 2
a608 9
    /* The variable is only bound inside the loop, so it is safe to optimize
     * it out if there is no code to execute. But the result form may reference
     * the bound variable. */
    if (!CONSP(body)) {
	if (times)
	    count = end;
	else
	    value = NIL;
    }
a610 1
    CHECK_CONSTANT(symbol);
d612 1
a612 1
	LispAddVar(symbol, FIXNUM(count));
d614 1
a614 5
	LispAddVar(symbol, CONSP(value) ? CAR(value) : value);
    ++lisp__data.env.head;

    if (!CONSP(body) || (times && count >= end) || (!times && !CONSP(value)))
	goto loop_done;
d618 1
a618 4
	for (object = body; CONSP(object); object = CDR(object))
	    (void)EVAL(CAR(object));

	/* Update symbols and check exit condition */
d620 1
a620 3
	    ++count;
	    LispSetVar(symbol, FIXNUM(count));
	    if (count >= end)
d623 8
d632 2
a633 3
	    value = CDR(value);
	    if (!CONSP(value)) {
		LispSetVar(symbol, NIL);
d635 3
a637 2
	    }
	    LispSetVar(symbol, CAR(value));
d641 2
a642 4
loop_done:
    result = EVAL(result);
    lisp__data.env.head = lisp__data.env.length = head;
    GC_LEAVE();
d644 1
a644 1
    return (result);
d648 1
a648 5
LispDoListTimes(LispBuiltin *builtin, int times)
/*
 dolist init &rest body
 dotimes init &rest body
 */
d651 1
a651 1
    LispObj *result, **presult = &result;
d654 1
a654 1
    *presult = NIL;
d656 1
a656 1
    block = LispBeginBlock(NIL, LispBlockTag);
d658 2
a659 2
	result = LispReallyDoListTimes(builtin, times);
	did_jump = 0;
d661 11
a671 3
    LispEndBlock(block);
    if (did_jump)
	result = lisp__data.block.block_ret;
d673 12
a684 1
    return (result);
d688 1
a688 1
LispLoadFile(LispObj *filename, int verbose, int print, int ifdoesnotexist)
d690 1
a690 2
    LispObj *stream, *cod, *obj, *result;
    int ch;
d692 7
a698 2
    LispObj *savepackage;
    LispPackage *savepack;
d700 4
a703 2
    if (verbose)
	LispMessage("; Loading %s", THESTR(filename));
d705 9
a713 6
    if (ifdoesnotexist) {
	GC_ENTER();
	result = CONS(filename, CONS(Kif_does_not_exist, CONS(Kerror, NIL)));
	GC_PROTECT(result);
	stream = APPLY(Oopen, result);
	GC_LEAVE();
d715 2
a716 2
    else
	stream = APPLY1(Oopen, filename);
d718 11
a728 1
    if (stream == NIL)
d730 1
d732 31
a762 3
    result = NIL;
    LispPushInput(stream);
    ch = LispGet();
d764 2
a765 2
	LispUnget(ch);
    else if ((ch = LispGet()) == '!') {
d767 1
a767 1
	    ch = LispGet();
d773 2
a774 2
	LispUnget(ch);
	LispUnget('#');
a776 6
    /* Save package environment */
    savepackage = PACKAGE;
    savepack = lisp__data.pack;

    cod = COD;

d779 6
a784 11
	if ((obj = LispRead()) != NULL) {
	    result = EVAL(obj);
	    COD = cod;
	    if (print) {
		int i;

		if (RETURN_COUNT >= 0)
		    LispPrint(result, NIL, 1);
		for (i = 0; i < RETURN_COUNT; i++)
		    LispPrint(RETURN(i), NIL, 1);
	    }
d786 1
a786 1
	if (lisp__data.eof)
d789 8
a796 1
    LispPopInput(stream);
d798 2
a799 3
    /* Restore package environment */
    PACKAGE = savepackage;
    lisp__data.pack = savepack;
d801 33
a833 1
    APPLY1(Oclose, stream);
d835 2
a836 1
    return (T);
d840 2
a841 3
LispGetStringArgs(LispBuiltin *builtin,
		  char **string1, char **string2,
		  long *start1, long *end1, long *start2, long *end2)
d843 2
a844 2
    long length1, length2;
    LispObj *ostring1, *ostring2, *ostart1, *oend1, *ostart2, *oend2;
d846 3
a848 14
    oend2 = ARGUMENT(5);
    ostart2 = ARGUMENT(4);
    oend1 = ARGUMENT(3);
    ostart1 = ARGUMENT(2);
    ostring2 = ARGUMENT(1);
    ostring1 = ARGUMENT(0);

    CHECK_STRING(ostring1);
    *string1 = THESTR(ostring1);
    length1 = STRLEN(ostring1);

    CHECK_STRING(ostring2);
    *string2 = THESTR(ostring2);
    length2 = STRLEN(ostring2);
d850 3
a852 12
    if (ostart1 == UNSPEC)
	*start1 = 0;
    else {
	CHECK_INDEX(ostart1);
	*start1 = FIXNUM_VALUE(ostart1);
    }
    if (oend1 == UNSPEC)
	*end1 = length1;
    else {
	CHECK_INDEX(oend1);
	*end1 = FIXNUM_VALUE(oend1);
    }
d854 3
a856 6
    if (ostart2 == UNSPEC)
	*start2 = 0;
    else {
	CHECK_INDEX(ostart2);
	*start2 = FIXNUM_VALUE(ostart2);
    }
d858 3
a860 6
    if (oend2 == UNSPEC)
	*end2 = length2;
    else {
	CHECK_INDEX(oend2);
	*end2 = FIXNUM_VALUE(oend2);
    }
d862 2
a863 12
    if (*start1 > *end1)
	LispDestroy("%s: :START1 %ld larger than :END1 %ld",
		    STRFUN(builtin), *start1, *end1);
    if (*start2 > *end2)
	LispDestroy("%s: :START2 %ld larger than :END2 %ld",
		    STRFUN(builtin), *start2, *end2);
    if (*end1 > length1)
	LispDestroy("%s: :END1 %ld larger than string length %ld",
		    STRFUN(builtin), *end1, length1);
    if (*end2 > length2)
	LispDestroy("%s: :END2 %ld larger than string length %ld",
		    STRFUN(builtin), *end2, length2);
d867 1
a867 1
LispPathnameField(int field, int string)
d869 26
a894 36
    int offset = field;
    LispObj *pathname, *result, *object;

    pathname = ARGUMENT(0);

    if (PATHNAMEP(pathname))
	pathname = APPLY1(Oparse_namestring, pathname);

    result = pathname->data.pathname;
    while (offset) {
	result = CDR(result);
	--offset;
    }
    object = result;
    result = CAR(result);

    if (string) {
	if (!STRINGP(result)) {
	    if (result == NIL)
		result = STRING("");
	    else if (field == PATH_DIRECTORY) {
		char *name = THESTR(CAR(pathname->data.pathname)), *ptr;

		ptr = strrchr(name, PATH_SEP);
		if (ptr) {
		    int length = ptr - name + 1;
		    char data[PATH_MAX];

		    if (length > PATH_MAX - 1)
			length = PATH_MAX - 1;
		    strncpy(data, name, length);
		    data[length] = '\0';
		    result = STRING(data);
		}
		else
		    result = STRING("");
a895 2
	    else
		result = Kunspecific;
d897 8
a904 16
	else if (field == PATH_NAME) {
	    object = CAR(CDR(object));
	    if (STRINGP(object)) {
		int length;
		char name[PATH_MAX + 1];

		strcpy(name, THESTR(result));
		length = STRLEN(result);
		if (length + 1 < sizeof(name)) {
		    name[length++] = PATH_TYPESEP;
		    name[length] = '\0';
		}
		if (STRLEN(object) + length < sizeof(name))
		    strcpy(name + length, THESTR(object));
		/* else LispDestroy ... */
		result = STRING(name);
d908 2
d911 23
a933 39
    return (result);
}

LispObj *
LispProbeFile(LispBuiltin *builtin, int probe)
{
    GC_ENTER();
    LispObj *result;
    char *name = NULL, resolved[PATH_MAX + 1];
    struct stat st;

    LispObj *pathname;

    pathname = ARGUMENT(0);

    if (!POINTERP(pathname))
	goto bad_pathname;

    if (XSTRINGP(pathname))
	name = THESTR(pathname);
    else if (XPATHNAMEP(pathname))
	name = THESTR(CAR(pathname->data.pathname));
    else if (STREAMP(pathname) && pathname->data.stream.type == LispStreamFile)
	name = THESTR(CAR(pathname->data.stream.pathname->data.pathname));

    if (realpath(name, &resolved[0]) == NULL ||
	stat(resolved, &st)) {
	if (probe)
	    return (NIL);
	LispDestroy("%s: realpath(\"%s\"): %s",
		    STRFUN(builtin), name, strerror(errno));
    }

    if (S_ISDIR(st.st_mode)) {
	int length = strlen(resolved);

	if (!length || resolved[length - 1] != PATH_SEP) {
	    resolved[length++] = PATH_SEP;
	    resolved[length] = '\0';
d937 2
a938 22
    result = STRING(resolved);
    GC_PROTECT(result);
    result = APPLY1(Oparse_namestring, result);
    GC_LEAVE();

    return (result);

bad_pathname:
    LispDestroy("%s: bad pathname %s", STRFUN(builtin), STROBJ(pathname));
    /*NOTREACHED*/
    return (NIL);
}

LispObj *
LispWriteString_(LispBuiltin *builtin, int newline)
/*
 write-line string &optional output-stream &key start end
 write-string string &optional output-stream &key start end
 */
{
    char *text;
    long start, end, length;
d940 4
a943 1
    LispObj *string, *output_stream, *ostart, *oend;
d945 2
a946 15
    oend = ARGUMENT(3);
    ostart = ARGUMENT(2);
    output_stream = ARGUMENT(1);
    string = ARGUMENT(0);

    CHECK_STRING(string);
    LispCheckSequenceStartEnd(builtin, string, ostart, oend,
			      &start, &end, &length);
    if (output_stream == UNSPEC)
	output_stream = NIL;
    text = THESTR(string);
    if (end > start)
	LispWriteStr(output_stream, text + start, end - start);
    if (newline)
	LispWriteChar(output_stream, '\n');
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d30 1
a30 1
/* $XFree86: xc/programs/xedit/lisp/helper.c,v 1.51 2003/09/17 22:28:08 paulo Exp $ */
d32 7
a38 7
#include "lisp/helper.h"
#include "lisp/pathname.h"
#include "lisp/package.h"
#include "lisp/read.h"
#include "lisp/stream.h"
#include "lisp/write.h"
#include "lisp/hash.h"
d694 2
a695 2
    int jumped;
    LispObj *result;
d700 2
d985 1
a985 1
    if (!PATHNAMEP(pathname))
a1064 1
#ifndef __UNIXOS2__
a1066 3
#else
    if ((name == NULL) || stat(resolved, &st)) {
#endif
@


