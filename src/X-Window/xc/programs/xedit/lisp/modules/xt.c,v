head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.10.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.10.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.39.52;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.39.37;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.28.35;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (c) 2001 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *  
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of the XFree86 Project shall
 * not be used in advertising or otherwise to promote the sale, use or other
 * dealings in this Software without prior written authorization from the
 * XFree86 Project.
 *
 * Author: Paulo César Pereira de Andrade
 */

/* $XFree86: xc/programs/xedit/lisp/modules/xt.c,v 1.10 2001/10/20 00:19:36 paulo Exp $ */

#include <stdlib.h>
#include <stdio.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Shell.h>
#include "internal.h"

/*
 * Types
 */
typedef struct {
    XrmQuark qname;
    XrmQuark qtype;
    Cardinal size;
} ResourceInfo;

typedef struct {
    WidgetClass widget_class;
    ResourceInfo **resources;
    Cardinal num_resources;
    Cardinal num_cons_resources;
} ResourceList;

typedef struct {
    Arg *args;
    Cardinal num_args;
} Resources;

typedef struct {
    LispMac *mac;
    LispObj *data;
    /* data is => (list* widget callback argument) */
} CallbackArgs;

/*
 * Prototypes
 */
int xtLoadModule(LispMac*);
void _LispXtCleanupCallback(Widget, XtPointer, XtPointer);

void _LispXtCallback(Widget, XtPointer, XtPointer);

LispObj *Lisp_XtCoerceToWidgetList(LispMac*, LispObj*, char*);
LispObj *Lisp_XtAddCallback(LispMac*, LispObj*, char*);
LispObj *Lisp_XtAppInitialize(LispMac*, LispObj*, char*);
LispObj *Lisp_XtAppMainLoop(LispMac*, LispObj*, char*);
LispObj *Lisp_XtAppPending(LispMac*, LispObj*, char*);
LispObj *Lisp_XtAppProcessEvent(LispMac*, LispObj*, char*);
LispObj *Lisp_XtCreateWidget(LispMac*, LispObj*, char*);
LispObj *Lisp_XtCreateManagedWidget(LispMac*, LispObj*, char*);
LispObj *Lisp_XtCreatePopupShell(LispMac*, LispObj*, char*);
LispObj *Lisp_XtDestroyWidget(LispMac*, LispObj*, char*);
LispObj *Lisp_XtGetValues(LispMac*, LispObj*, char*);
LispObj *Lisp_XtManageChild(LispMac*, LispObj*, char*);
LispObj *Lisp_XtPopup(LispMac*, LispObj*, char*);
LispObj *Lisp_XtPopdown(LispMac*, LispObj*, char*);
LispObj *Lisp_XtRealizeWidget(LispMac*, LispObj*, char*);
LispObj *Lisp_XtSetSensitive(LispMac*, LispObj*, char*);
LispObj *Lisp_XtSetValues(LispMac*, LispObj*, char*);
LispObj *Lisp_XtWidgetToApplicationContext(LispMac*, LispObj*, char*);

LispObj *_LispXtCreateWidget(LispMac*, LispObj*, char*, int);

static Resources *LispConvertResources(LispMac*, LispObj*, Widget,
				       ResourceList*, ResourceList*);
static void LispFreeResources(Resources*);

static int bcmp_action_resource(_Xconst void*, _Xconst void*);
static ResourceInfo *GetResourceInfo(char*, ResourceList*, ResourceList*);
static ResourceList *GetResourceList(WidgetClass);
static int bcmp_action_resource_list(_Xconst void*, _Xconst void*);
static ResourceList *FindResourceList(WidgetClass);
static int qcmp_action_resource_list(_Xconst void*, _Xconst void*);
static ResourceList *CreateResourceList(WidgetClass);
static int qcmp_action_resource(_Xconst void*, _Xconst void*);
static void BindResourceList(ResourceList*);

static void PopdownAction(Widget, XEvent*, String*, Cardinal*);
static void QuitAction(Widget, XEvent*, String*, Cardinal*);


/*
 * Initialization
 */
static LispBuiltin lispbuiltins[] = {
    {"XT-COERCE-TO-WIDGET-LIST",	Lisp_XtCoerceToWidgetList,	1,2,2,},
    {"XT-ADD-CALLBACK",			Lisp_XtAddCallback,		1,3,4,},
    {"XT-APP-INITIALIZE",		Lisp_XtAppInitialize,		1,2,4,},
    {"XT-APP-PENDING",			Lisp_XtAppPending,		1,1,1,},
    {"XT-APP-MAIN-LOOP",		Lisp_XtAppMainLoop,		1,1,1,},
    {"XT-APP-PROCESS-EVENT",		Lisp_XtAppProcessEvent,		1,1,2,},
    {"XT-CREATE-MANAGED-WIDGET",	Lisp_XtCreateManagedWidget,	1,3,4,},
    {"XT-CREATE-WIDGET",		Lisp_XtCreateWidget,		1,3,4,},
    {"XT-CREATE-POPUP-SHELL",		Lisp_XtCreatePopupShell,	1,3,4,},
    {"XT-DESTROY-WIDGET",		Lisp_XtDestroyWidget,		1,1,1,},
    {"XT-GET-VALUES",			Lisp_XtGetValues,		1,2,2,},
    {"XT-MANAGE-CHILD",			Lisp_XtManageChild,		1,1,1,},
    {"XT-POPUP",			Lisp_XtPopup,			1,2,2,},
    {"XT-POPDOWN",			Lisp_XtPopdown,			1,1,1,},
    {"XT-REALIZE-WIDGET",		Lisp_XtRealizeWidget,		1,1,1,},
    {"XT-SET-SENSITIVE",		Lisp_XtSetSensitive,		1,2,2,},
    {"XT-SET-VALUES",			Lisp_XtSetValues,		1,2,2,},
    {"XT-WIDGET-TO-APPLICATION-CONTEXT",Lisp_XtWidgetToApplicationContext,1,1,1,},
};

LispModuleData xtLispModuleData = {
    LISP_MODULE_VERSION,
    xtLoadModule,
};

static ResourceList **resource_list;
static Cardinal num_resource_list;

static Atom delete_window;
static int xtAppContext_t, xtWidget_t, xtWidgetClass_t, xtWidgetList_t;

static XtActionsRec actions[] = {
    {"xt-popdown",	PopdownAction},
    {"xt-quit",		QuitAction},
};

static XrmQuark qCardinal, qInt, qString, qWidget;

/*
 * Implementation
 */
int
xtLoadModule(LispMac *mac)
{
    int i;
    char *fname = "INTERNAL:XT-LOAD-MODULE";

    xtAppContext_t = LispRegisterOpaqueType(mac, "XtAppContext");
    xtWidget_t = LispRegisterOpaqueType(mac, "Widget");
    xtWidgetClass_t = LispRegisterOpaqueType(mac, "WidgetClass");
    xtWidgetList_t = LispRegisterOpaqueType(mac, "WidgetList");

    LispExecute(mac, "(DEFSTRUCT XT-WIDGET-LIST NUM-CHILDREN CHILDREN)\n");

    GCProtect();
    (void)LispSetVariable(mac, ATOM2("CORE-WIDGET-CLASS"),
			  OPAQUE(coreWidgetClass, xtWidgetClass_t),
			  fname, 0);
    (void)LispSetVariable(mac, ATOM2("TRANSIENT-SHELL-WIDGET-CLASS"),
			  OPAQUE(transientShellWidgetClass, xtWidgetClass_t),
			  fname, 0);

    /* parameters for XtPopup */
    (void)LispSetVariable(mac, ATOM2("XT-GRAB-EXCLUSIVE"),
			  REAL(XtGrabExclusive), fname, 0);
    (void)LispSetVariable(mac, ATOM2("XT-GRAB-NONE"),
			  REAL(XtGrabNone), fname, 0);
    (void)LispSetVariable(mac, ATOM2("XT-GRAB-NONE-EXCLUSIVE"),
			  REAL(XtGrabNonexclusive), fname, 0);

    /* parameters for XtAppProcessEvent */
    (void)LispSetVariable(mac, ATOM2("XT-IM-XEVENT"),
			  REAL(XtIMXEvent), fname, 0);
    (void)LispSetVariable(mac, ATOM2("XT-IM-TIMER"),
			  REAL(XtIMTimer), fname, 0);
    (void)LispSetVariable(mac, ATOM2("XT-IM-ALTERNATE-INPUT"),
			  REAL(XtIMAlternateInput), fname, 0);
    (void)LispSetVariable(mac, ATOM2("XT-IM-SIGNAL"),
			  REAL(XtIMSignal), fname, 0);
    (void)LispSetVariable(mac, ATOM2("XT-IM-ALL"),
			  REAL(XtIMSignal), fname, 0);
    GCUProtect();

    qCardinal = XrmPermStringToQuark(XtRCardinal);
    qInt = XrmPermStringToQuark(XtRInt);
    qString = XrmPermStringToQuark(XtRString);
    qWidget = XrmPermStringToQuark(XtRWidget);

    for (i = 0; i < sizeof(lispbuiltins) / sizeof(lispbuiltins[0]); i++)
	LispAddBuiltinFunction(mac, &lispbuiltins[i]);

    return (1);
}

void
_LispXtCallback(Widget w, XtPointer user_data, XtPointer call_data)
{
    CallbackArgs *args = (CallbackArgs*)user_data;
    LispMac *mac = args->mac;
    LispObj *code, *frm = FRM;

    GCProtect();
		/* callback name */               /* reall caller */
    code = CONS(QUOTE(CDR(CDR(args->data))), CONS(OPAQUE(w, xtWidget_t),
		CONS(CAR(CDR(args->data)), CONS(OPAQUE(call_data, 0), NIL))));
		     /* user arguments */
    FRM = CONS(code, FRM);
    GCUProtect();

    (void)Lisp_Funcall(mac, code, "FUNCALL");
    FRM = frm;
}

void
_LispXtCleanupCallback(Widget w, XtPointer user_data, XtPointer call_data)
{
    CallbackArgs *args = (CallbackArgs*)user_data;
    LispMac *mac = args->mac;

    UPROTECT(CAR(args->data), args->data);
}

LispObj *
Lisp_XtCoerceToWidgetList(LispMac *mac, LispObj *list, char *fname)
{
    int i;
    WidgetList children;
    Cardinal num_children;
    LispObj *obj, *cdr, *wid;

    if (CAR(list)->type != LispReal_t)
	LispDestroy(mac, "expecting number, at %s", fname);
    if (!CHECKO(CAR(CDR(list)), xtWidgetList_t))
	LispDestroy(mac, "cannot convert %s to XawListReturnStruct, at %s",
		    LispStrObj(mac, CAR(list)), fname);

    num_children = CAR(list)->data.real;
    children = (WidgetList)(CAR(CDR(list))->data.opaque.data);

    GCProtect();
    wid = cdr = NIL;
    for (i = 0; i < num_children; i++) {
	obj = CONS(OPAQUE(children[i], xtWidget_t), NIL);
	if (wid == NIL)
	    wid = cdr = CONS(OPAQUE(children[i], xtWidget_t), NIL);
	else {
	    CDR(cdr) = CONS(OPAQUE(children[i], xtWidget_t), NIL);
	    cdr = CDR(cdr);
	}
    }

    obj = EVAL(CONS(ATOM("MAKE-XT-WIDGET-LIST"),
		    CONS(ATOM(":NUM-CHILDREN"),
			 CONS(REAL(num_children),
			      CONS(ATOM(":CHILDREN"),
				   CONS(QUOTE(wid), NIL))))));
    GCUProtect();

    return (obj);
}

LispObj *
Lisp_XtAddCallback(LispMac *mac, LispObj *list, char *fname)
{
    CallbackArgs *arguments;
    LispObj *widget, *name, *callback, *args, *data;

    widget = CAR(list);
    if (!CHECKO(widget, xtWidget_t))
	LispDestroy(mac,
		    "cannot convert %s to Widget, at %s",
		    LispStrObj(mac, CAR(list)), fname);
    list = CDR(list);

    name = CAR(list);
    if (name->type != LispString_t)
	LispDestroy(mac, "expecting string, at %s", fname);
    list = CDR(list);

    callback = CAR(list);
    if (callback->type != LispAtom_t)
	LispDestroy(mac, "expecting atom, at %s", fname);
    list = CDR(list);

    GCProtect();
    if (list == NIL)
	args = list;
    else
	args = QUOTE(CAR(list));

    data = CONS(widget, CONS(args, callback));
    PROTECT(widget, data);
    GCUProtect();

    arguments = XtNew(CallbackArgs);
    arguments->mac = mac;
    arguments->data = data;

    XtAddCallback((Widget)(widget->data.opaque.data), STRPTR(name),
		  _LispXtCallback, (XtPointer)arguments);
    XtAddCallback((Widget)(widget->data.opaque.data), XtNdestroyCallback,
		  _LispXtCleanupCallback, (XtPointer)arguments);

    return (NIL);
}

LispObj *
Lisp_XtAppInitialize(LispMac *mac, LispObj *list, char *fname)
{
    XtAppContext appcon;
    char *app, *cname;
    Widget shell;
    int zero = 0;
    Resources *resources = NULL;
    String *fallback = NULL;

    if (CAR(list)->type != LispAtom_t)
	LispDestroy(mac, "expecting atom, at %s", fname);
    app = STRPTR(CAR(list));
    list = CDR(list);

    if (CAR(list)->type != LispString_t) {
	LispDestroy(mac, "cannot convert %s to string, at %s",
		    LispStrObj(mac, CAR(list)), fname);
    }
    cname = STRPTR(CAR(list));

    /* check if fallback resources given */
    if (list != NIL && CDR(list)->type == LispCons_t &&
	CDR(CDR(list))->type == LispCons_t) {
	int count;
	LispObj *ptr, *obj = CAR(CDR(CDR(list)));

	if (obj->type != LispCons_t)
	    LispDestroy(mac, "expecting string list, at %s", fname);

	for (ptr = obj, count = 0; ptr->type == LispCons_t;
	     ptr = CDR(ptr), count++)
	    if (CAR(ptr)->type != LispString_t)
		LispDestroy(mac, "%s is not a string, at %s",
			    LispStrObj(mac, CAR(ptr)), fname);

	/* fallback resources was correctly specified */
	fallback = LispMalloc(mac, sizeof(String) * (count + 1));
	for (ptr = obj, count = 0; ptr->type == LispCons_t;
	     ptr = CDR(ptr), count++)
	    fallback[count] = STRPTR(CAR(ptr));
	fallback[count] = NULL;
    }

    GCProtect();
    shell = XtAppInitialize(&appcon, cname, NULL, 0, &zero, NULL,
			    fallback, NULL, 0);
    if (fallback)
	LispFree(mac, fallback);
    (void)LispSetVariable(mac, ATOM(app), OPAQUE(appcon, xtAppContext_t),
			  fname, 0);
    GCUProtect();

    XtAppAddActions(appcon, actions, XtNumber(actions));

    list = CDR(list);
    if (list == NIL || CAR(list) == NIL)
	resources = NULL;
    else if (CAR(list)->type != LispCons_t)
	LispDestroy(mac, "expecting argument list, at %s", fname);
    else {
	resources = LispConvertResources(mac, CAR(list), shell,
					 GetResourceList(XtClass(shell)),
					 NULL);
	if (resources) {
	    XtSetValues(shell, resources->args, resources->num_args);
	    LispFreeResources(resources);
	}
    }

    return (OPAQUE(shell, xtWidget_t));
}

LispObj *
Lisp_XtAppMainLoop(LispMac *mac, LispObj *list, char *fname)
{
    if (!CHECKO(CAR(list), xtAppContext_t))
	LispDestroy(mac,
		    "cannot convert %s to XtAppContext, at %s",
		    LispStrObj(mac, CAR(list)), fname);

    XtAppMainLoop((XtAppContext)(CAR(list)->data.opaque.data));

    return (NIL);
}

LispObj *
Lisp_XtAppPending(LispMac *mac, LispObj *list, char *fname)
{
    if (!CHECKO(CAR(list), xtAppContext_t))
	LispDestroy(mac,
		    "cannot convert %s to XtAppContext, at %s",
		    LispStrObj(mac, CAR(list)), fname);

    return (REAL(XtAppPending((XtAppContext)(CAR(list)->data.opaque.data))));
}

LispObj *
Lisp_XtAppProcessEvent(LispMac *mac, LispObj *list, char *fname)
{
    XtInputMask mask;
    XtAppContext appcon;

    if (!CHECKO(CAR(list), xtAppContext_t))
	LispDestroy(mac,
		    "cannot convert %s to XtAppContext, at %s",
		    LispStrObj(mac, CAR(list)), fname);

    appcon = (XtAppContext)(CAR(list)->data.opaque.data);
    list = CDR(list);
    if (list == NIL)
	mask = XtIMAll;
    else if (!INTEGER_P(CAR(list)))
	LispDestroy(mac, "expecting XtInputMask, at %s", fname);
    mask = NUMBER_VALUE(CAR(list));
    switch (mask) {
	case 0:
	    break;
	case XtIMXEvent:
	case XtIMTimer:
	case XtIMAlternateInput:
	case XtIMSignal:
	case XtIMAll:
	    XtAppProcessEvent(appcon, mask);
	    break;
	default:
	    LispDestroy(mac, "bad XtInputMask, at %s", mask, fname);
	    break;
    }

    return (NIL);
}

LispObj *
Lisp_XtRealizeWidget(LispMac *mac, LispObj *list, char *fname)
{
    Widget widget;

    if (!CHECKO(CAR(list), xtWidget_t))
	LispDestroy(mac,
		    "cannot convert %s to Widget, at %s",
		    LispStrObj(mac, CAR(list)), fname);

    widget = (Widget)(CAR(list)->data.opaque.data);
    XtRealizeWidget(widget);

    if (XtIsSubclass(widget, shellWidgetClass)) {
	if (!delete_window)
	    delete_window = XInternAtom(XtDisplay(widget),
					"WM_DELETE_WINDOW", False);
	(void)XSetWMProtocols(XtDisplay(widget), XtWindow(widget),
			      &delete_window, 1);
    }

    return (NIL);
}

LispObj *
Lisp_XtDestroyWidget(LispMac *mac, LispObj *list, char *fname)
{
    Widget widget;

    if (!CHECKO(CAR(list), xtWidget_t))
	LispDestroy(mac,
		    "cannot convert %s to Widget, at %s",
		    LispStrObj(mac, CAR(list)), fname);

    widget = (Widget)(CAR(list)->data.opaque.data);
    XtDestroyWidget(widget);

    return (NIL);
}

#define UNMANAGED	0
#define MANAGED		1
#define SHELL		2
LispObj *
Lisp_XtCreateWidget(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispXtCreateWidget(mac, list, fname, UNMANAGED));
}

LispObj *
Lisp_XtCreateManagedWidget(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispXtCreateWidget(mac, list, fname, MANAGED));
}

LispObj *
Lisp_XtCreatePopupShell(LispMac *mac, LispObj *list, char *fname)
{
    return (_LispXtCreateWidget(mac, list, fname, SHELL));
}

LispObj *
_LispXtCreateWidget(LispMac *mac, LispObj *list, char *fname, int options)
{
    char *name;
    WidgetClass widget_class;
    Widget widget, parent;
    Resources *resources = NULL;

    if (CAR(list)->type != LispString_t)
	LispDestroy(mac, "cannot convert %s to char*, at %s",
		    LispStrObj(mac, CAR(list)), fname);
    name = STRPTR(CAR(list));
    list = CDR(list);

    if (!CHECKO(CAR(list), xtWidgetClass_t))
	LispDestroy(mac, "cannot convert %s to WidgetClass, at %s",
		    LispStrObj(mac, CAR(list)), fname);
    widget_class = (WidgetClass)(CAR(list)->data.opaque.data);
    list = CDR(list);

    if (!CHECKO(CAR(list), xtWidget_t))
	LispDestroy(mac, "cannot convert %s to Widget, at %s",
		    LispStrObj(mac, CAR(list)), fname);
    parent = (Widget)(CAR(list)->data.opaque.data);
    list = CDR(list);

    if (options != SHELL)
	widget = XtCreateWidget(name, widget_class, parent, NULL, 0);
    else
	widget = XtCreatePopupShell(name, widget_class, parent, NULL, 0);

    if (list == NIL || CAR(list) == NIL)
	resources = NULL;
    else if (CAR(list)->type != LispCons_t)
	LispDestroy(mac, "expecting argument list, at %s", fname);
    else {
	resources = LispConvertResources(mac, CAR(list), widget,
					 GetResourceList(widget_class),
					 GetResourceList(XtClass(parent)));
	XtSetValues(widget, resources->args, resources->num_args);
    }
    if (options == MANAGED)
	XtManageChild(widget);
    if (resources)
	LispFreeResources(resources);

    return (OPAQUE(widget, xtWidget_t));
}

LispObj *
Lisp_XtGetValues(LispMac *mac, LispObj *list, char *fname)
{
    Arg args[1];
    Widget widget;
    ResourceList *rlist, *plist;
    ResourceInfo *resource;
    LispObj *obj, *res, *ptr;
    char c1;
    short c2;
    int c4;
#ifdef LONG64
    long c8;
#endif

    if (!CHECKO(CAR(list), xtWidget_t))
	LispDestroy(mac, "cannot convert %s to Widget, at %s",
		    LispStrObj(mac, CAR(list)), fname);
    widget = (Widget)(CAR(list)->data.opaque.data);
    list = CDR(list);
    if (CAR(list)->type != LispCons_t)
	LispDestroy(mac, "expecting string list, at %s", fname);

    rlist = GetResourceList(XtClass(widget));
    plist =  XtParent(widget) ? GetResourceList(XtClass(XtParent(widget))) : NULL;

    GCProtect();
    res = NIL;
    for (list = CAR(list); list != NIL; list = CDR(list)) {
	if (CAR(list)->type != LispString_t)
	    LispDestroy(mac, "%s is not a string, at %s",
			LispStrObj(mac, CAR(list)), fname);
	if ((resource = GetResourceInfo(STRPTR(CAR(list)), rlist, plist))
	     == NULL) {
	    int i;
	    Widget child;

	    for (i = 0; i < rlist->num_resources; i++) {
		if (rlist->resources[i]->qtype == qWidget) {
		    XtSetArg(args[0],
			     XrmQuarkToString(rlist->resources[i]->qname),
			     &child);
		    XtGetValues(widget, args, 1);
		    if (child && XtParent(child) == widget) {
			resource =
			    GetResourceInfo(STRPTR(CAR(list)),
					    GetResourceList(XtClass(child)),
					    NULL);
			if (resource)
			    break;
		    }
		}
	    }
	    if (resource == NULL) {
		fprintf(stderr, "resource %s not available.\n",
			STRPTR(CAR(list)));
		continue;
	    }
	}
	switch (resource->size) {
	    case 1:
		XtSetArg(args[0], STRPTR(CAR(list)), &c1);
		break;
	    case 2:
		XtSetArg(args[0], STRPTR(CAR(list)), &c2);
		break;
	    case 4:
		XtSetArg(args[0], STRPTR(CAR(list)), &c4);
		break;
#ifdef LONG64
	    case 1:
		XtSetArg(args[0], STRPTR(CAR(list)), &c8);
		break;
#endif
	}
	XtGetValues(widget, args, 1);

	/* special resources */
	if (resource->qtype == qString) {
#ifdef LONG64
	    obj = CONS(CAR(list), STRING((char*)c8));
#else
	    obj = CONS(CAR(list), STRING((char*)c4));
#endif
	}
	else if (resource->qtype == qCardinal || resource->qtype == qInt) {
#ifdef LONG64
	    if (sizeof(int) == 8)
		obj = CONS(CAR(list), REAL(c8));
	    else
#endif
	    obj = CONS(CAR(list), REAL(c4));
	}
	else {
	    switch (resource->size) {
		case 1:
		    obj = CONS(CAR(list), OPAQUE(c1, 0));
		    break;
		case 2:
		    obj = CONS(CAR(list), OPAQUE(c2, 0));
		    break;
		case 4:
		    obj = CONS(CAR(list), OPAQUE(c4, 0));
		    break;
#ifdef LONG64
		case 8:
		    obj = CONS(CAR(list), OPAQUE(c8, 0));
		    break;
#endif
	    }
	}

	if (res == NIL)
	    res = ptr = CONS(obj, NIL);
	else {
	    CDR(ptr) = CONS(obj, NIL);
	    ptr = CDR(ptr);
	}
    }
    GCUProtect();

    return (res);
}

LispObj *
Lisp_XtManageChild(LispMac *mac, LispObj *list, char *fname)
{
    if (!CHECKO(CAR(list), xtWidget_t))
	LispDestroy(mac, "cannot convert %s to Widget, at %s",
		    LispStrObj(mac, CAR(list)), fname);
    XtManageChild((Widget)(CAR(list)->data.opaque.data));

    return (NIL);
}

LispObj *
Lisp_XtPopup(LispMac *mac, LispObj *list, char *fname)
{
    XtGrabKind kind;

    if (!CHECKO(CAR(list), xtWidget_t))
	LispDestroy(mac, "cannot convert %s to Widget, at %s",
		    LispStrObj(mac, CAR(list)), fname);
    if (CAR(CDR(list))->type != LispReal_t)
	LispDestroy(mac, "cannot convert %s to XtGrabKind, at %s",
		    LispStrObj(mac, CAR(CDR(list))), fname);
    kind = (XtGrabKind)(CAR(CDR(list))->data.real);
    if (kind != XtGrabExclusive && kind != XtGrabNone &&
	kind != XtGrabNonexclusive)
	LispDestroy(mac, "cannot convert %d to XtGrabKind, at %s",
		    kind, fname);
    XtPopup((Widget)(CAR(list)->data.opaque.data), kind);

    return (NIL);
}

LispObj *
Lisp_XtPopdown(LispMac *mac, LispObj *list, char *fname)
{
    if (!CHECKO(CAR(list), xtWidget_t))
	LispDestroy(mac, "cannot convert %s to Widget, at %s",
		    LispStrObj(mac, CAR(list)), fname);
    XtPopdown((Widget)(CAR(list)->data.opaque.data));

    return (NIL);
}

LispObj *
Lisp_XtSetSensitive(LispMac *mac, LispObj *list, char *fname)
{
    if (!CHECKO(CAR(list), xtWidget_t))
	LispDestroy(mac, "cannot convert %s to Widget, at %s",
		    LispStrObj(mac, CAR(list)), fname);
    XtSetSensitive((Widget)(CAR(list)->data.opaque.data),
		   CAR(CDR(list)) != NIL);

    return (CAR(CDR(list)) == NIL ? NIL : T);
}

LispObj *
Lisp_XtSetValues(LispMac *mac, LispObj *list, char *fname)
{
    Widget widget;
    Resources *resources;

    if (!CHECKO(CAR(list), xtWidget_t))
	LispDestroy(mac, "cannot convert %s to Widget, at %s",
		    LispStrObj(mac, CAR(list)), fname);
    widget = (Widget)(CAR(list)->data.opaque.data);
    list = CDR(list);
    if (CAR(list)->type != LispCons_t)
	LispDestroy(mac, "expecting string list, at %s", fname);

    resources = LispConvertResources(mac, CAR(list), widget,
				     GetResourceList(XtClass(widget)),
				     XtParent(widget) ?
					GetResourceList(XtClass(XtParent(widget))) :
					NULL);
    XtSetValues(widget, resources->args, resources->num_args);
    LispFreeResources(resources);

    return (NIL);
}

LispObj *
Lisp_XtWidgetToApplicationContext(LispMac *mac, LispObj *list, char *fname)
{
    Widget widget;
    XtAppContext appcon;

    if (!CHECKO(CAR(list), xtWidget_t))
	LispDestroy(mac, "cannot convert %s to Widget, at %s",
		    LispStrObj(mac, CAR(list)), fname);
    widget = (Widget)(CAR(list)->data.opaque.data);
    appcon = XtWidgetToApplicationContext(widget);

    return (OPAQUE(appcon, xtAppContext_t));
}

static Resources *
LispConvertResources(LispMac *mac, LispObj *list, Widget widget,
		     ResourceList *rlist, ResourceList *plist)
{
    char c1;
    short c2;
    int c4;   
#ifdef LONG64
    long c8;
#endif
    XrmValue from, to;
    LispObj *arg, *val;
    ResourceInfo *resource;
    char *fname = "XT-INTERNAL:CONVERT-RESOURCES";
    Resources *resources = (Resources*)XtCalloc(1, sizeof(Resources));

    for (; list != NIL; list = CDR(list)) {
	if (list->type != LispCons_t || CAR(list)->type != LispCons_t) {
	    XtFree((XtPointer)resources);
	    LispDestroy(mac, "expecting cons, at %s", fname);
	}
	arg = CAR(CAR(list));
	val = CDR(CAR(list));

	if (arg->type != LispString_t) {
	    XtFree((XtPointer)resources);
	    LispDestroy(mac, "resource name must be a string, at %s", fname);
	}

	if ((resource = GetResourceInfo(STRPTR(arg), rlist, plist)) == NULL) {
	    int i;
	    Arg args[1];
	    Widget child;

	    for (i = 0; i < rlist->num_resources; i++) {
		if (rlist->resources[i]->qtype == qWidget) {
		    XtSetArg(args[0],
			     XrmQuarkToString(rlist->resources[i]->qname),
			     &child);
		    XtGetValues(widget, args, 1);
		    if (child && XtParent(child) == widget) {
			resource =
			    GetResourceInfo(STRPTR(arg),
					    GetResourceList(XtClass(child)),
					    NULL);
			if (resource)
			    break;
		    }
		}
	    }
	    if (resource == NULL) {
		fprintf(stderr, "resource %s not available.\n", STRPTR(arg));
		continue;
	    }
	}

	if (val->type == LispReal_t || val->type == LispOpaque_t) {
	    resources->args = (Arg*)
		XtRealloc((XtPointer)resources->args,
			  sizeof(Arg) * (resources->num_args + 1));
	    if (val->type == LispReal_t)
		XtSetArg(resources->args[resources->num_args],
			 XrmQuarkToString(resource->qname), (int)val->data.real);
	    else
		XtSetArg(resources->args[resources->num_args],
			 XrmQuarkToString(resource->qname), val->data.opaque.data);
	    ++resources->num_args;
	    continue;
	}
	else if (val->type != LispString_t) {
	    XtFree((XtPointer)resources);
	    LispDestroy(mac,
			"resource value must be string, number or opaque, not %s at %s",
			LispStrObj(mac, val), fname);
	}

	from.size = val == NIL ? 1 : strlen(STRPTR(val)) + 1;
	from.addr = val == NIL ? "" : STRPTR(val);
	switch (to.size = resource->size) {
	    case 1:
		to.addr = (XtPointer)&c1;
		break;
	    case 2:
		to.addr = (XtPointer)&c2;
		break;
	    case 4:
		to.addr = (XtPointer)&c4;
		break;
#ifdef LONG64
	    case 8:
		to.addr = (XtPointer)&c8;
		break;
#endif
	    default:
		fprintf(stderr, "bad resource size %d, for %s.\n",
			to.size, STRPTR(arg));
		continue;
	}

	if (qString == resource->qtype)
#ifdef LONG64
	    c8 = (long)from.addr;
#else
	    c4 = (long)from.addr;
#endif
	else if (!XtConvertAndStore(widget, XtRString, &from,
				    XrmQuarkToString(resource->qtype), &to))
	    /* The type converter already have printed an error message */
	    continue;

	resources->args = (Arg*)
	    XtRealloc((XtPointer)resources->args,
		      sizeof(Arg) * (resources->num_args + 1));
	switch (to.size) {
	    case 1:
		XtSetArg(resources->args[resources->num_args],
			 XrmQuarkToString(resource->qname), c1);
		break;
	    case 2:
		XtSetArg(resources->args[resources->num_args],
			 XrmQuarkToString(resource->qname), c2);
		break;
	    case 4:
		XtSetArg(resources->args[resources->num_args],
			 XrmQuarkToString(resource->qname), c4);
		break;
#ifdef LONG64
	    case 8:
		XtSetArg(resources->args[resources->num_args],
			 XrmQuarkToString(resource->qname), c8);
		break;
#endif
	}
	++resources->num_args;
    }

    return (resources);
}

static void
LispFreeResources(Resources *resources)
{
    if (resources) {
	XtFree((XtPointer)resources->args);
	XtFree((XtPointer)resources);
    }
}

static int
bcmp_action_resource(_Xconst void *string, _Xconst void *resource)
{
    return (strcmp((String)string,
		   XrmQuarkToString((*(ResourceInfo**)resource)->qname)));
}   

static ResourceInfo *
GetResourceInfo(char *name, ResourceList *rlist, ResourceList *plist)
{
    ResourceInfo **resource = NULL;

    if (rlist->resources)
	resource = (ResourceInfo**)
	    bsearch(name, rlist->resources, rlist->num_resources,
		    sizeof(ResourceInfo*), bcmp_action_resource);

    if (resource == NULL && plist) {
	resource = (ResourceInfo**)
	  bsearch(name, &plist->resources[plist->num_resources],
		  plist->num_cons_resources, sizeof(ResourceInfo*),
		  bcmp_action_resource);
    }

    return (resource ? *resource : NULL);
}

static ResourceList *
GetResourceList(WidgetClass wc)
{
    ResourceList *list;

    if ((list = FindResourceList(wc)) == NULL)
	list = CreateResourceList(wc);

    return (list);
}

static int
bcmp_action_resource_list(_Xconst void *wc, _Xconst void *list)
{
    return ((char*)wc - (char*)((*(ResourceList**)list)->widget_class));
}

static ResourceList *
FindResourceList(WidgetClass wc)
{  
    ResourceList **list;

    if (!resource_list)
	return (NULL);

    list = (ResourceList**)
	bsearch(wc, resource_list, num_resource_list,
		sizeof(ResourceList*),  bcmp_action_resource_list);

    return (list ? *list : NULL);
}

static int
qcmp_action_resource_list(_Xconst void *left, _Xconst void *right)
{
    return ((char*)((*(ResourceList**)left)->widget_class) -
	    (char*)((*(ResourceList**)right)->widget_class));
}

static ResourceList *
CreateResourceList(WidgetClass wc)
{
    ResourceList *list;

    list = (ResourceList*)XtMalloc(sizeof(ResourceList));
    list->widget_class = wc;
    list->num_resources = list->num_cons_resources = 0;
    list->resources = NULL;

    resource_list = (ResourceList**)
	XtRealloc((XtPointer)resource_list, sizeof(ResourceList*) *
		  (num_resource_list + 1));
    resource_list[num_resource_list++] = list;
    qsort(resource_list, num_resource_list, sizeof(ResourceList*),
	  qcmp_action_resource_list);
    BindResourceList(list);

    return (list);
}

static int
qcmp_action_resource(_Xconst void *left, _Xconst void *right)
{
    return (strcmp(XrmQuarkToString((*(ResourceInfo**)left)->qname),
		   XrmQuarkToString((*(ResourceInfo**)right)->qname)));
}

static void
BindResourceList(ResourceList *list)
{
    XtResourceList xt_list, cons_list;
    Cardinal i, num_xt, num_cons;

    XtGetResourceList(list->widget_class, &xt_list, &num_xt);
    XtGetConstraintResourceList(list->widget_class, &cons_list, &num_cons);
    list->num_resources = num_xt;
    list->num_cons_resources = num_cons;

    list->resources = (ResourceInfo**)
	XtMalloc(sizeof(ResourceInfo*) * (num_xt + num_cons));

    for (i = 0; i < num_xt; i++) {
	list->resources[i] = (ResourceInfo*)XtMalloc(sizeof(ResourceInfo));
	list->resources[i]->qname =
	    XrmPermStringToQuark(xt_list[i].resource_name);
	list->resources[i]->qtype =
	    XrmPermStringToQuark(xt_list[i].resource_type);
	list->resources[i]->size = xt_list[i].resource_size;
    }

    for (; i < num_xt + num_cons; i++) {
	list->resources[i] = (ResourceInfo*)XtMalloc(sizeof(ResourceInfo));
	list->resources[i]->qname =
	    XrmPermStringToQuark(cons_list[i - num_xt].resource_name);
	list->resources[i]->qtype =
	    XrmPermStringToQuark(cons_list[i - num_xt].resource_type);
	list->resources[i]->size = cons_list[i - num_xt].resource_size;
    }

    XtFree((XtPointer)xt_list);
    if (cons_list)
	XtFree((XtPointer)cons_list);

    qsort(list->resources, list->num_resources, sizeof(ResourceInfo*),
	  qcmp_action_resource);
    if (num_cons)
	qsort(&list->resources[num_xt], list->num_cons_resources,
	      sizeof(ResourceInfo*), qcmp_action_resource);
}

/*ARGSUSED*/
static void
PopdownAction(Widget w, XEvent *event, String *params, Cardinal *num_params)
{
    XtPopdown(w);
}

/*ARGSUSED*/
static void
QuitAction(Widget w, XEvent *event, String *params, Cardinal *num_params)
{
    exit(0);
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d30 1
a30 1
/* $XFree86: xc/programs/xedit/lisp/modules/xt.c,v 1.21 2003/04/27 18:17:38 tsi Exp $ */
a33 1
#include <string.h>
d37 1
a37 2
#include "lisp/internal.h"
#include "lisp/private.h"
d61 1
d69 2
a70 2
int xtLoadModule(void);
void LispXtCleanupCallback(Widget, XtPointer, XtPointer);
d72 1
a72 2
void LispXtCallback(Widget, XtPointer, XtPointer);
void LispXtInputCallback(XtPointer, int*, XtInputId*);
d74 18
a91 2
/* a hack... */
LispObj *Lisp_XtCoerceToWidgetList(LispBuiltin*);
d93 1
a93 39
LispObj *Lisp_XtAddCallback(LispBuiltin*);
LispObj *Lisp_XtAppInitialize(LispBuiltin*);
LispObj *Lisp_XtAppMainLoop(LispBuiltin*);
LispObj *Lisp_XtAppAddInput(LispBuiltin*);
LispObj *Lisp_XtAppPending(LispBuiltin*);
LispObj *Lisp_XtAppProcessEvent(LispBuiltin*);
LispObj *Lisp_XtCreateWidget(LispBuiltin*);
LispObj *Lisp_XtCreateManagedWidget(LispBuiltin*);
LispObj *Lisp_XtCreatePopupShell(LispBuiltin*);
LispObj *Lisp_XtDestroyWidget(LispBuiltin*);
LispObj *Lisp_XtGetKeyboardFocusWidget(LispBuiltin*);
LispObj *Lisp_XtGetValues(LispBuiltin*);
LispObj *Lisp_XtManageChild(LispBuiltin*);
LispObj *Lisp_XtUnmanageChild(LispBuiltin*);
LispObj *Lisp_XtSetMappedWhenManaged(LispBuiltin*);
LispObj *Lisp_XtMapWidget(LispBuiltin*);
LispObj *Lisp_XtName(LispBuiltin*);
LispObj *Lisp_XtParent(LispBuiltin*);
LispObj *Lisp_XtUnmapWidget(LispBuiltin*);
LispObj *Lisp_XtPopup(LispBuiltin*);
LispObj *Lisp_XtPopdown(LispBuiltin*);
LispObj *Lisp_XtIsRealized(LispBuiltin*);
LispObj *Lisp_XtRealizeWidget(LispBuiltin*);
LispObj *Lisp_XtUnrealizeWidget(LispBuiltin*);
LispObj *Lisp_XtRemoveInput(LispBuiltin*);
LispObj *Lisp_XtSetSensitive(LispBuiltin*);
LispObj *Lisp_XtSetValues(LispBuiltin*);
LispObj *Lisp_XtWidgetToApplicationContext(LispBuiltin*);
LispObj *Lisp_XtDisplay(LispBuiltin*);
LispObj *Lisp_XtDisplayOfObject(LispBuiltin*);
LispObj *Lisp_XtScreen(LispBuiltin*);
LispObj *Lisp_XtScreenOfObject(LispBuiltin*);
LispObj *Lisp_XtSetKeyboardFocus(LispBuiltin*);
LispObj *Lisp_XtWindow(LispBuiltin*);
LispObj *Lisp_XtWindowOfObject(LispBuiltin*);
LispObj *Lisp_XtAddGrab(LispBuiltin*);
LispObj *Lisp_XtRemoveGrab(LispBuiltin*);
LispObj *Lisp_XtAppGetExitFlag(LispBuiltin*);
LispObj *Lisp_XtAppSetExitFlag(LispBuiltin*);
d95 1
a95 3
LispObj *LispXtCreateWidget(LispBuiltin*, int);

static Resources *LispConvertResources(LispObj*, Widget,
d112 1
d117 18
a134 41
    {LispFunction, Lisp_XtCoerceToWidgetList, "xt-coerce-to-widget-list number opaque"},

    {LispFunction, Lisp_XtAddGrab, "xt-add-grab widget exclusive spring-loaded"},
    {LispFunction, Lisp_XtAddCallback, "xt-add-callback widget callback-name callback &optional client-data"},
    {LispFunction, Lisp_XtAppAddInput, "xt-app-add-input app-context fileno condition function &optional client-data"},
    {LispFunction, Lisp_XtAppInitialize, "xt-app-initialize app-context-return application-class &optional options fallback-resources"},
    {LispFunction, Lisp_XtAppPending, "xt-app-pending app-context"},
    {LispFunction, Lisp_XtAppMainLoop, "xt-app-main-loop app-context"},
    {LispFunction, Lisp_XtAppProcessEvent, "xt-app-process-event app-context &optional mask"},
    {LispFunction, Lisp_XtAppGetExitFlag, "xt-app-get-exit-flag app-context"},
    {LispFunction, Lisp_XtAppSetExitFlag, "xt-app-set-exit-flag app-context"},
    {LispFunction, Lisp_XtCreateManagedWidget, "xt-create-managed-widget name widget-class parent &optional arguments"},
    {LispFunction, Lisp_XtCreateWidget, "xt-create-widget name widget-class parent &optional arguments"},
    {LispFunction, Lisp_XtCreatePopupShell, "xt-create-popup-shell name widget-class parent &optional arguments"},
    {LispFunction, Lisp_XtDestroyWidget, "xt-destroy-widget widget"},
    {LispFunction, Lisp_XtGetKeyboardFocusWidget, "xt-get-keyboard-focus-widget widget"},
    {LispFunction, Lisp_XtGetValues, "xt-get-values widget arguments"},
    {LispFunction, Lisp_XtManageChild, "xt-manage-child widget"},
    {LispFunction, Lisp_XtName, "xt-name widget"},
    {LispFunction, Lisp_XtUnmanageChild, "xt-unmanage-child widget"},
    {LispFunction, Lisp_XtMapWidget, "xt-map-widget widget"},
    {LispFunction, Lisp_XtUnmapWidget, "xt-unmap-widget widget"},
    {LispFunction, Lisp_XtSetMappedWhenManaged, "xt-set-mapped-when-managed widget map-when-managed"},
    {LispFunction, Lisp_XtParent, "xt-parent widget"},
    {LispFunction, Lisp_XtPopup, "xt-popup widget grab-kind"},
    {LispFunction, Lisp_XtPopdown, "xt-popdown widget"},
    {LispFunction, Lisp_XtIsRealized, "xt-is-realized widget"},
    {LispFunction, Lisp_XtRealizeWidget, "xt-realize-widget widget"},
    {LispFunction, Lisp_XtUnrealizeWidget, "xt-unrealize-widget widget"},
    {LispFunction, Lisp_XtRemoveInput, "xt-remove-input input"},
    {LispFunction, Lisp_XtRemoveGrab, "xt-remove-grab widget"},
    {LispFunction, Lisp_XtSetKeyboardFocus, "xt-set-keyboard-focus widget descendant"},
    {LispFunction, Lisp_XtSetSensitive, "xt-set-sensitive widget sensitive"},
    {LispFunction, Lisp_XtSetValues, "xt-set-values widget arguments"},
    {LispFunction, Lisp_XtWidgetToApplicationContext, "xt-widget-to-application-context widget"},
    {LispFunction, Lisp_XtDisplay, "xt-display widget"},
    {LispFunction, Lisp_XtDisplayOfObject, "xt-display-of-object object"},
    {LispFunction, Lisp_XtScreen, "xt-screen widget"},
    {LispFunction, Lisp_XtScreenOfObject, "xt-screen-of-object object"},
    {LispFunction, Lisp_XtWindow, "xt-window widget"},
    {LispFunction, Lisp_XtWindowOfObject, "xt-window-of-object object"},
d146 1
a146 2
static int xtAppContext_t, xtWidget_t, xtWidgetClass_t, xtWidgetList_t,
	   xtInputId_t, xtDisplay_t, xtScreen_t, xtWindow_t;
d153 1
a153 4
static XrmQuark qCardinal, qInt, qString, qWidget, qFloat;

static CallbackArgs **input_list;
static Cardinal num_input_list, size_input_list;
d159 1
a159 1
xtLoadModule(void)
d162 1
a162 1
    char *fname = "XT-LOAD-MODULE";
d164 4
a167 8
    xtAppContext_t = LispRegisterOpaqueType("XtAppContext");
    xtWidget_t = LispRegisterOpaqueType("Widget");
    xtWidgetClass_t = LispRegisterOpaqueType("WidgetClass");
    xtWidgetList_t = LispRegisterOpaqueType("WidgetList");
    xtInputId_t = LispRegisterOpaqueType("XtInputId");
    xtDisplay_t = LispRegisterOpaqueType("Display*");
    xtScreen_t = LispRegisterOpaqueType("Screen*");
    xtWindow_t = LispRegisterOpaqueType("Window");
d169 1
a169 1
    LispExecute("(DEFSTRUCT XT-WIDGET-LIST NUM-CHILDREN CHILDREN)\n");
d171 2
a172 2
    GCDisable();
    (void)LispSetVariable(ATOM2("CORE-WIDGET-CLASS"),
d175 1
a175 7
    (void)LispSetVariable(ATOM2("COMPOSITE-WIDGET-CLASS"),
			  OPAQUE(compositeWidgetClass, xtWidgetClass_t),
			  fname, 0);
    (void)LispSetVariable(ATOM2("CONSTRAINT-WIDGET-CLASS"),
			  OPAQUE(constraintWidgetClass, xtWidgetClass_t),
			  fname, 0);
    (void)LispSetVariable(ATOM2("TRANSIENT-SHELL-WIDGET-CLASS"),
d180 6
a185 6
    (void)LispSetVariable(ATOM2("XT-GRAB-EXCLUSIVE"),
			  INTEGER(XtGrabExclusive), fname, 0);
    (void)LispSetVariable(ATOM2("XT-GRAB-NONE"),
			  INTEGER(XtGrabNone), fname, 0);
    (void)LispSetVariable(ATOM2("XT-GRAB-NONE-EXCLUSIVE"),
			  INTEGER(XtGrabNonexclusive), fname, 0);
d188 11
a198 19
    (void)LispSetVariable(ATOM2("XT-IM-XEVENT"),
			  INTEGER(XtIMXEvent), fname, 0);
    (void)LispSetVariable(ATOM2("XT-IM-TIMER"),
			  INTEGER(XtIMTimer), fname, 0);
    (void)LispSetVariable(ATOM2("XT-IM-ALTERNATE-INPUT"),
			  INTEGER(XtIMAlternateInput), fname, 0);
    (void)LispSetVariable(ATOM2("XT-IM-SIGNAL"),
			  INTEGER(XtIMSignal), fname, 0);
    (void)LispSetVariable(ATOM2("XT-IM-ALL"),
			  INTEGER(XtIMAll), fname, 0);

    /* parameters for XtAppAddInput */
    (void)LispSetVariable(ATOM2("XT-INPUT-READ-MASK"),
			  INTEGER(XtInputReadMask), fname, 0);
    (void)LispSetVariable(ATOM2("XT-INPUT-WRITE-MASK"),
			  INTEGER(XtInputWriteMask), fname, 0);
    (void)LispSetVariable(ATOM2("XT-INPUT-EXCEPT-MASK"),
			  INTEGER(XtInputExceptMask), fname, 0);
    GCEnable();
a203 1
    qFloat = XrmPermStringToQuark(XtRFloat);
d206 1
a206 1
	LispAddBuiltinFunction(&lispbuiltins[i]);
d212 1
a212 1
LispXtCallback(Widget w, XtPointer user_data, XtPointer call_data)
d215 2
a216 1
    LispObj *code, *ocod = COD;
d218 3
a220 3
    GCDisable();
		/* callback name */	   /* reall caller */
    code = CONS(CDR(CDR(args->data)), CONS(OPAQUE(w, xtWidget_t),
d223 2
a224 2
    COD = CONS(code, COD);
    GCEnable();
d226 2
a227 2
    (void)EVAL(code);
    COD = ocod;
a229 1

d231 1
a231 1
LispXtCleanupCallback(Widget w, XtPointer user_data, XtPointer call_data)
d234 1
a236 19
    XtFree((XtPointer)args);
}

void
LispXtInputCallback(XtPointer closure, int *source, XtInputId *id)
{
    CallbackArgs *args = (CallbackArgs*)closure;
    LispObj *code, *ocod = COD;

    GCDisable();
		/* callback name */	  /* user arguments */
    code = CONS(CDR(CDR(args->data)), CONS(CAR(CDR(args->data)),
		CONS(INTEGER(*source), CONS(CAR(args->data), NIL))));
		     /* input source */	   /* input id */
    COD = CONS(code, COD);
    GCEnable();

    (void)EVAL(code);
    COD = ocod;
d240 1
a240 4
Lisp_XtCoerceToWidgetList(LispBuiltin *builtin)
/*
 xt-coerce-to-widget-list number opaque
 */
d245 1
a245 1
    LispObj *cons, *widget_list, *result;
d247 5
a251 1
    LispObj *onumber, *opaque;
d253 2
a254 2
    opaque = ARGUMENT(1);
    onumber = ARGUMENT(0);
d256 2
a257 10
    CHECK_INDEX(onumber);
    num_children = FIXNUM_VALUE(onumber);

    if (!CHECKO(opaque, xtWidgetList_t))
	LispDestroy("%s: cannot convert %s to WidgetList",
		    STRFUN(builtin), STROBJ(opaque));
    children = (WidgetList)(opaque->data.opaque.data);

    GCDisable();
    widget_list = cons = NIL;
d259 3
a261 3
	result = CONS(OPAQUE(children[i], xtWidget_t), NIL);
	if (widget_list == NIL)
	    widget_list = cons = result;
d263 2
a264 2
	    RPLACD(cons, result);
	    cons = CDR(cons);
d268 6
a273 6
    result = APPLY(ATOM("MAKE-XT-WIDGET-LIST"),
		   CONS(KEYWORD("NUM-CHILDREN"),
			CONS(INTEGER(num_children),
			     CONS(KEYWORD("CHILDREN"),
				  CONS(widget_list, NIL)))));
    GCEnable();
d275 1
a275 1
    return (result);
d279 1
a279 4
Lisp_XtAddCallback(LispBuiltin *builtin)
/*
 xt-add-callback widget callback-name callback &optional client-data
 */
d282 1
a282 8
    LispObj *data;

    LispObj *widget, *callback_name, *callback, *client_data;

    client_data = ARGUMENT(3);
    callback = ARGUMENT(2);
    callback_name = ARGUMENT(1);
    widget = ARGUMENT(0);
d284 1
d286 20
a305 7
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));

    CHECK_STRING(callback_name);
    if (!SYMBOLP(callback) && callback->type != LispLambda_t)
	LispDestroy("%s: %s cannot be used as a callback",
		    STRFUN(builtin), STROBJ(callback));
d307 1
a307 4
    if (client_data == UNSPEC)
	client_data = NIL;

    data = CONS(widget, CONS(client_data, callback));
d309 1
d312 1
d315 2
a316 2
    XtAddCallback((Widget)(widget->data.opaque.data), THESTR(callback_name),
		  LispXtCallback, (XtPointer)arguments);
d318 1
a318 103
		  LispXtCleanupCallback, (XtPointer)arguments);

    return (client_data);
}

LispObj *
Lisp_XtAppAddInput(LispBuiltin *builtin)
/*
  xt-app-add-input app-context fileno condition function &optional client-data
 */
{
    LispObj *data, *input;
    XtAppContext appcon;
    int source, condition;
    CallbackArgs *arguments;
    XtInputId id;

    LispObj *app_context, *fileno, *ocondition, *function, *client_data;

    client_data = ARGUMENT(4);
    function = ARGUMENT(3);
    ocondition = ARGUMENT(2);
    fileno = ARGUMENT(1);
    app_context = ARGUMENT(0);

    if (!CHECKO(app_context, xtAppContext_t))
	LispDestroy("%s: cannot convert %s to XtAppContext",
		    STRFUN(builtin), STROBJ(app_context));
    appcon = (XtAppContext)(app_context->data.opaque.data);

    CHECK_LONGINT(fileno);
    source = LONGINT_VALUE(fileno);

    CHECK_FIXNUM(ocondition);
    condition = FIXNUM_VALUE(ocondition);

    if (!SYMBOLP(function) && function->type != LispLambda_t)
	LispDestroy("%s: %s cannot be used as a callback",
		    STRFUN(builtin), STROBJ(function));

    /* client data optional */
    if (client_data == UNSPEC)
	client_data = NIL;

    data = CONS(NIL, CONS(client_data, function));

    arguments = XtNew(CallbackArgs);
    arguments->data = data;

    id = XtAppAddInput(appcon, source, (XtPointer)condition,
		       LispXtInputCallback, (XtPointer)arguments);
    GCDisable();
    input = OPAQUE(id, xtInputId_t);
    GCEnable();
    RPLACA(data, input);
    PROTECT(input, data);

    if (num_input_list + 1 >= size_input_list) {
	++size_input_list;
	input_list = (CallbackArgs**)
	    XtRealloc((XtPointer)input_list,
		      sizeof(CallbackArgs*) * size_input_list);
    }
    input_list[num_input_list++] = arguments;

    return (input);
}

LispObj *
Lisp_XtRemoveInput(LispBuiltin *builtin)
/*
 xt-remove-input input
 */
{
    int i;
    XtInputId id;
    CallbackArgs *args;

    LispObj *input;

    input = ARGUMENT(0);

    if (!CHECKO(input, xtInputId_t))
	LispDestroy("%s: cannot convert %s to XtInputId",
		    STRFUN(builtin), STROBJ(input));

    id = (XtInputId)(input->data.opaque.data);
    for (i = 0; i < num_input_list; i++) {
	args = input_list[i];
	if (id == (XtInputId)(CAR(args->data)->data.opaque.data)) {
	    UPROTECT(CAR(args->data), args->data);
	    XtFree((XtPointer)args);

	    if (i + 1 < num_input_list)
		memmove(input_list + i, input_list + i + 1,
			sizeof(CallbackArgs*) * (num_input_list - i - 1));
	    --num_input_list;

	    XtRemoveInput(id);

	    return (T);
	}
    }
d324 1
a324 4
Lisp_XtAppInitialize(LispBuiltin *builtin)
/*
 xt-app-initialize app-context-return application-class &optional options fallback-resources
 */
d327 1
d333 10
a342 2
    LispObj *app_context_return, *application_class,
	    *options, *fallback_resources;
d344 3
a346 12
    fallback_resources = ARGUMENT(3);
    options = ARGUMENT(2);
    application_class = ARGUMENT(1);
    app_context_return = ARGUMENT(0);

    CHECK_SYMBOL(app_context_return);
    CHECK_STRING(application_class);
    CHECK_LIST(options);

    /* check fallback resources, if given */
    if (fallback_resources != UNSPEC) {
	LispObj *string;
d348 4
d353 5
a357 4
	CHECK_CONS(fallback_resources);
	for (string = fallback_resources, count = 0; CONSP(string);
	     string = CDR(string), count++)
	    CHECK_STRING(CAR(string));
d360 4
a363 4
	fallback = LispMalloc(sizeof(String) * (count + 1));
	for (string = fallback_resources, count = 0; CONSP(string);
	     string = CDR(string), count++)
	    fallback[count] = THESTR(CAR(string));
d367 3
a369 2
    shell = XtAppInitialize(&appcon, THESTR(application_class), NULL,
			    0, &zero, NULL, fallback, NULL, 0);
d371 4
a374 4
	LispFree(fallback);
    (void)LispSetVariable(app_context_return,
			  OPAQUE(appcon, xtAppContext_t),
			  STRFUN(builtin), 0);
d378 7
a384 2
    if (options != UNSPEC) {
	resources = LispConvertResources(options, shell,
d397 1
a397 4
Lisp_XtAppMainLoop(LispBuiltin *builtin)
/*
 xt-app-main-loop app-context
 */
d399 4
a402 3
    LispObj *app_context;

    app_context = ARGUMENT(0);
d404 1
a404 5
    if (!CHECKO(app_context, xtAppContext_t))
	LispDestroy("%s: cannot convert %s to XtAppContext",
		    STRFUN(builtin), STROBJ(app_context));

    XtAppMainLoop((XtAppContext)(app_context->data.opaque.data));
d410 1
a410 4
Lisp_XtAppPending(LispBuiltin *builtin)
/*
 xt-app-pending app-context
 */
d412 4
a415 1
    LispObj *app_context;
d417 1
a417 8
    app_context = ARGUMENT(0);

    if (!CHECKO(app_context, xtAppContext_t))
	LispDestroy("%s: cannot convert %s to XtAppContext",
		    STRFUN(builtin), STROBJ(app_context));

    return (INTEGER(
	    XtAppPending((XtAppContext)(app_context->data.opaque.data))));
d421 1
a421 4
Lisp_XtAppProcessEvent(LispBuiltin *builtin)
/*
 xt-app-process-event app-context &optional mask
 */
d426 8
a433 11
    LispObj *app_context, *omask;

    omask = ARGUMENT(1);
    app_context = ARGUMENT(0);

    if (!CHECKO(app_context, xtAppContext_t))
	LispDestroy("%s: cannot convert %s to XtAppContext",
		    STRFUN(builtin), STROBJ(app_context));

    appcon = (XtAppContext)(app_context->data.opaque.data);
    if (omask == UNSPEC)
d435 16
a450 3
    else {
	CHECK_FIXNUM(omask);
	mask = FIXNUM_VALUE(omask);
d453 1
a453 8
    if (mask != (mask & XtIMAll))
	LispDestroy("%s: %ld does not fit in XtInputMask %ld",
		    STRFUN(builtin), (long)mask, (long)XtIMAll);

    if (mask)
	XtAppProcessEvent(appcon, mask);

    return (omask == NIL ? FIXNUM(mask) : omask);
d457 1
a457 4
Lisp_XtRealizeWidget(LispBuiltin *builtin)
/*
 xt-realize-widget widget
 */
d461 4
a464 3
    LispObj *owidget;

    owidget = ARGUMENT(0);
d466 1
a466 4
    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
d477 1
a477 20
    return (owidget);
}

LispObj *
Lisp_XtUnrealizeWidget(LispBuiltin *builtin)
/*
 xt-unrealize-widget widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));

    XtUnrealizeWidget((Widget)(widget->data.opaque.data));

    return (widget);
d481 1
a481 4
Lisp_XtIsRealized(LispBuiltin *builtin)
/*
 xt-is-realized widget
 */
d483 1
a483 1
    LispObj *widget;
d485 4
a488 22
    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));

    return (XtIsRealized((Widget)(widget->data.opaque.data)) ? T : NIL);
}

LispObj *
Lisp_XtDestroyWidget(LispBuiltin *builtin)
/*
 xt-destroy-widget widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
d490 2
a491 1
    XtDestroyWidget((Widget)(widget->data.opaque.data));
d500 1
a500 4
Lisp_XtCreateWidget(LispBuiltin *builtin)
/*
 xt-create-widget name widget-class parent &optional arguments
 */
d502 1
a502 1
    return (LispXtCreateWidget(builtin, UNMANAGED));
d506 1
a506 4
Lisp_XtCreateManagedWidget(LispBuiltin *builtin)
/*
 xt-create-managed-widget name widget-class parent &optional arguments
 */
d508 1
a508 1
    return (LispXtCreateWidget(builtin, MANAGED));
d512 1
a512 4
Lisp_XtCreatePopupShell(LispBuiltin *builtin)
/*
 xt-create-popup-shell name widget-class parent &optional arguments
 */
d514 1
a514 1
    return (LispXtCreateWidget(builtin, SHELL));
d518 1
a518 6
LispXtCreateWidget(LispBuiltin *builtin, int options)
/*
 xt-create-widget name widget-class parent &optional arguments
 xt-create-managed-widget name widget-class parent &optional arguments
 xt-create-popup-shell name widget-class parent &optional arguments
 */
d525 17
a541 1
    LispObj *oname, *owidget_class, *oparent, *arguments;
d543 3
a545 23
    arguments = ARGUMENT(3);
    oparent = ARGUMENT(2);
    owidget_class = ARGUMENT(1);
    oname = ARGUMENT(0);

    CHECK_STRING(oname);
    name = THESTR(oname);

    if (!CHECKO(owidget_class, xtWidgetClass_t))
	LispDestroy("%s: cannot convert %s to WidgetClass",
		    STRFUN(builtin), STROBJ(owidget_class));
    widget_class = (WidgetClass)(owidget_class->data.opaque.data);

    if (!CHECKO(oparent, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(oparent));
    parent = (Widget)(oparent->data.opaque.data);

    if (arguments == UNSPEC)
	arguments = NIL;
    CHECK_LIST(arguments);

    if (options == SHELL)
a546 2
    else
	widget = XtCreateWidget(name, widget_class, parent, NULL, 0);
d548 1
a548 1
    if (arguments == NIL)
d550 2
d553 1
a553 1
	resources = LispConvertResources(arguments, widget,
d567 1
a567 21
Lisp_XtGetKeyboardFocusWidget(LispBuiltin *builtin)
/*
 xt-get-keyboard-focus-widget widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    return (OPAQUE(XtGetKeyboardFocusWidget((Widget)(widget->data.opaque.data)),
		   xtWidget_t));
}

LispObj *
Lisp_XtGetValues(LispBuiltin *builtin)
/*
 xt-get-values widget arguments
 */
d573 1
a573 1
    LispObj *list, *object = NIL, *result, *cons = NIL;
d581 7
a587 13
    LispObj *owidget, *arguments;

    arguments = ARGUMENT(1);
    owidget = ARGUMENT(0);

    if (arguments == NIL)
	return (NIL);

    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
    CHECK_CONS(arguments);
d590 1
a590 2
    plist =  XtParent(widget) ?
	     GetResourceList(XtClass(XtParent(widget))) : NULL;
d592 7
a598 5
    GCDisable();
    result = NIL;
    for (list = arguments; CONSP(list); list = CDR(list)) {
	CHECK_STRING(CAR(list));
	if ((resource = GetResourceInfo(THESTR(CAR(list)), rlist, plist))
d611 1
a611 1
			    GetResourceInfo(THESTR(CAR(list)),
d620 2
a621 2
		LispMessage("%s: resource %s not available",
			    STRFUN(builtin), THESTR(CAR(list)));
d627 1
a627 1
		XtSetArg(args[0], THESTR(CAR(list)), &c1);
d630 1
a630 1
		XtSetArg(args[0], THESTR(CAR(list)), &c2);
d633 1
a633 1
		XtSetArg(args[0], THESTR(CAR(list)), &c4);
d637 1
a637 1
		XtSetArg(args[0], THESTR(CAR(list)), &c8);
d646 1
a646 1
	    object = CONS(CAR(list), STRING((char*)c8));
d648 1
a648 1
	    object = CONS(CAR(list), STRING((char*)c4));
d654 1
a654 1
		object = CONS(CAR(list), INTEGER(c8));
d657 1
a657 1
	    object = CONS(CAR(list), INTEGER(c4));
d662 1
a662 1
		    object = CONS(CAR(list), OPAQUE(c1, 0));
d665 1
a665 1
		    object = CONS(CAR(list), OPAQUE(c2, 0));
d668 1
a668 1
		    object = CONS(CAR(list), OPAQUE(c4, 0));
d672 1
a672 1
		    object = CONS(CAR(list), OPAQUE(c8, 0));
d678 2
a679 2
	if (result == NIL)
	    result = cons = CONS(object, NIL);
d681 2
a682 2
	    RPLACD(cons, CONS(object, NIL));
	    cons = CDR(cons);
d685 1
a685 1
    GCEnable();
d687 1
a687 1
    return (result);
d691 1
a691 4
Lisp_XtManageChild(LispBuiltin *builtin)
/*
 xt-manage-child widget
 */
d693 4
a696 1
    LispObj *widget;
d698 1
a698 26
    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    XtManageChild((Widget)(widget->data.opaque.data));

    return (widget);
}

LispObj *
Lisp_XtUnmanageChild(LispBuiltin *builtin)
/*
 xt-unmanage-child widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    XtUnmanageChild((Widget)(widget->data.opaque.data));

    return (widget);
d702 1
a702 61
Lisp_XtMapWidget(LispBuiltin *builtin)
/*
 xt-map-widget widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    XtMapWidget((Widget)(widget->data.opaque.data));

    return (widget);
}

LispObj *
Lisp_XtUnmapWidget(LispBuiltin *builtin)
/*
 xt-unmap-widget widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    XtUnmapWidget((Widget)(widget->data.opaque.data));

    return (widget);
}

LispObj *
Lisp_XtSetMappedWhenManaged(LispBuiltin *builtin)
/*
 xt-set-mapped-when-managed widget map-when-managed
 */
{
    LispObj *widget, *map_when_managed;

    map_when_managed = ARGUMENT(1);
    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));

    XtSetMappedWhenManaged((Widget)(widget->data.opaque.data),
			   map_when_managed != NIL);

    return (map_when_managed);
}

LispObj *
Lisp_XtPopup(LispBuiltin *builtin)
/*
 xt-popup widget grab-kind
 */
d706 7
a712 10
    LispObj *widget, *grab_kind;

    grab_kind = ARGUMENT(1);
    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    CHECK_INDEX(grab_kind);
    kind = (XtGrabKind)FIXNUM_VALUE(grab_kind);
d715 3
a717 3
	LispDestroy("%s: %d does not fit in XtGrabKind",
		    STRFUN(builtin), kind);
    XtPopup((Widget)(widget->data.opaque.data), kind);
d719 1
a719 1
    return (grab_kind);
d723 1
a723 4
Lisp_XtPopdown(LispBuiltin *builtin)
/*
 xt-popdown widget
 */
d725 4
a728 1
    LispObj *widget;
d730 1
a730 8
    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    XtPopdown((Widget)(widget->data.opaque.data));

    return (widget);
d734 1
a734 4
Lisp_XtSetKeyboardFocus(LispBuiltin *builtin)
/*
 xt-set-keyboard-focus widget descendant
 */
d736 5
a740 1
    LispObj *widget, *descendant;
d742 1
a742 13
    descendant = ARGUMENT(1);
    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    if (!CHECKO(descendant, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(descendant));
    XtSetKeyboardFocus((Widget)(widget->data.opaque.data),
		       (Widget)(descendant->data.opaque.data));

    return (widget);
d746 1
a746 23
Lisp_XtSetSensitive(LispBuiltin *builtin)
/*
 xt-set-sensitive widget sensitive
 */
{
    LispObj *widget, *sensitive;

    sensitive = ARGUMENT(1);
    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    XtSetSensitive((Widget)(widget->data.opaque.data), sensitive != NIL);

    return (sensitive);
}

LispObj *
Lisp_XtSetValues(LispBuiltin *builtin)
/*
 xt-set-values widget arguments
 */
d751 7
a757 1
    LispObj *owidget, *arguments;
d759 1
a759 12
    arguments = ARGUMENT(1);
    owidget = ARGUMENT(0);

    if (arguments == NIL)
	return (owidget);

    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
    CHECK_CONS(arguments);
    resources = LispConvertResources(arguments, widget,
d767 1
a767 1
    return (owidget);
d771 1
a771 4
Lisp_XtWidgetToApplicationContext(LispBuiltin *builtin)
/*
 xt-widget-to-application-context widget
 */
d776 4
a779 8
    LispObj *owidget;

    owidget = ARGUMENT(0);

    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
a784 249
LispObj *
Lisp_XtDisplay(LispBuiltin *builtin)
/*
 xt-display widget
 */
{
    Widget widget;
    Display *display;

    LispObj *owidget;

    owidget = ARGUMENT(0);

    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
    display = XtDisplay(widget);

    return (OPAQUE(display, xtDisplay_t));
}

LispObj *
Lisp_XtDisplayOfObject(LispBuiltin *builtin)
/*
 xt-display-of-object object
 */
{
    Widget widget;
    Display *display;

    LispObj *object;

    object = ARGUMENT(0);

    if (!CHECKO(object, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(object));
    widget = (Widget)(object->data.opaque.data);
    display = XtDisplayOfObject(widget);

    return (OPAQUE(display, xtDisplay_t));
}

LispObj *
Lisp_XtScreen(LispBuiltin *builtin)
/*
 xt-screen widget
 */
{
    Widget widget;
    Screen *screen;

    LispObj *owidget;

    owidget = ARGUMENT(0);

    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
    screen = XtScreen(widget);

    return (OPAQUE(screen, xtScreen_t));
}

LispObj *
Lisp_XtScreenOfObject(LispBuiltin *builtin)
/*
 xt-screen-of-object object
 */
{
    Widget widget;
    Screen *screen;

    LispObj *object;

    object = ARGUMENT(0);

    if (!CHECKO(object, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(object));
    widget = (Widget)(object->data.opaque.data);
    screen = XtScreenOfObject(widget);

    return (OPAQUE(screen, xtScreen_t));
}

LispObj *
Lisp_XtWindow(LispBuiltin *builtin)
/*
 xt-window widget
 */
{
    Widget widget;
    Window window;

    LispObj *owidget;

    owidget = ARGUMENT(0);

    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
    window = XtWindow(widget);

    return (OPAQUE(window, xtWindow_t));
}

LispObj *
Lisp_XtWindowOfObject(LispBuiltin *builtin)
/*
 xt-window-of-object widget
 */
{
    Widget widget;
    Window window;

    LispObj *object;

    object = ARGUMENT(0);

    if (!CHECKO(object, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(object));
    widget = (Widget)(object->data.opaque.data);
    window = XtWindowOfObject(widget);

    return (OPAQUE(window, xtWindow_t));
}

LispObj *
Lisp_XtAddGrab(LispBuiltin *builtin)
/*
 xt-add-grab widget exclusive spring-loaded
 */
{
    Widget widget;
    Bool exclusive, spring_loaded;

    LispObj *owidget, *oexclusive, *ospring_loaded;

    ospring_loaded = ARGUMENT(2);
    oexclusive = ARGUMENT(1);
    owidget = ARGUMENT(0);

    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
    exclusive = oexclusive != NIL;
    spring_loaded = ospring_loaded != NIL;

    XtAddGrab(widget, exclusive, spring_loaded);

    return (T);
}

LispObj *
Lisp_XtRemoveGrab(LispBuiltin *builtin)
/*
 xt-remove-grab widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));

    XtRemoveGrab((Widget)(widget->data.opaque.data));

    return (NIL);
}

LispObj *
Lisp_XtName(LispBuiltin *builtin)
/*
 xt-name widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));

    return (STRING(XtName((Widget)(widget->data.opaque.data))));
}

LispObj *
Lisp_XtParent(LispBuiltin *builtin)
/*
 xt-parent widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));

    return (OPAQUE(XtParent((Widget)widget->data.opaque.data), xtWidget_t));
}

LispObj *
Lisp_XtAppGetExitFlag(LispBuiltin *builtin)
/*
 xt-app-get-exit-flag app-context
 */
{
    LispObj *app_context;

    app_context = ARGUMENT(0);

    if (!CHECKO(app_context, xtAppContext_t))
	LispDestroy("%s: cannot convert %s to XtAppContext",
		    STRFUN(builtin), STROBJ(app_context));

    return (XtAppGetExitFlag((XtAppContext)(app_context->data.opaque.data)) ?
	    T : NIL);
}

LispObj *
Lisp_XtAppSetExitFlag(LispBuiltin *builtin)
/*
 xt-app-get-exit-flag app-context
 */
{
    LispObj *app_context;

    app_context = ARGUMENT(0);

    if (!CHECKO(app_context, xtAppContext_t))
	LispDestroy("%s: cannot convert %s to XtAppContext",
		    STRFUN(builtin), STROBJ(app_context));

    XtAppSetExitFlag((XtAppContext)(app_context->data.opaque.data));

    return (T);
}

d786 1
a786 1
LispConvertResources(LispObj *list, Widget widget,
d798 1
a798 1
    char *fname = "XT-CONVERT-RESOURCES";
d801 2
a802 2
    for (; CONSP(list); list = CDR(list)) {
	if (!CONSP(CAR(list))) {
d804 1
a804 1
	    LispDestroy("%s: %s is not a cons", fname, STROBJ(CAR(list)));
d809 1
a809 1
	if (!STRINGP(arg)) {
d811 1
a811 1
	    LispDestroy("%s: %s is not a string", fname, STROBJ(arg));
d814 1
a814 1
	if ((resource = GetResourceInfo(THESTR(arg), rlist, plist)) == NULL) {
d827 1
a827 1
			    GetResourceInfo(THESTR(arg),
d836 1
a836 2
		LispMessage("%s: resource %s not available",
			    fname, THESTR(arg));
d841 1
a841 1
	if (LONGINTP(val) || DFLOATP(val) || OPAQUEP(val)) {
d845 3
a847 16
	    if (!OPAQUEP(val)) {
		float fvalue;

		if (DFLOATP(val))
		    fvalue = DFLOAT_VALUE(val);
		else
		    fvalue = LONGINT_VALUE(val);
		if (resource->qtype == qFloat) {
		    XtSetArg(resources->args[resources->num_args],
			     XrmQuarkToString(resource->qname), fvalue);
		}
		else
		    XtSetArg(resources->args[resources->num_args],
			     XrmQuarkToString(resource->qname),
			     (int)fvalue);
	    }
d854 1
a854 29
	else if (val == NIL) {
	    /* XXX assume it is a pointer or a boolean */
#ifdef DEBUG
	    LispWarning("%s: assuming %s is a pointer or boolean",
			fname, XrmQuarkToString(resource->qname));
#endif
	    resources->args = (Arg*)
		XtRealloc((XtPointer)resources->args,
			  sizeof(Arg) * (resources->num_args + 1));
	    XtSetArg(resources->args[resources->num_args],
		     XrmQuarkToString(resource->qname), NULL);
	    ++resources->num_args;
	    continue;
	}
	else if (val == T) {
	    /* XXX assume it is a boolean */
#ifdef DEBUG
	    LispWarning("%s: assuming %s is a boolean",
			fname, XrmQuarkToString(resource->qname));
#endif
	    resources->args = (Arg*)
		XtRealloc((XtPointer)resources->args,
			  sizeof(Arg) * (resources->num_args + 1));
	    XtSetArg(resources->args[resources->num_args],
		     XrmQuarkToString(resource->qname), True);
	    ++resources->num_args;
	    continue;
	}
	else if (!STRINGP(val)) {
d856 3
a858 2
	    LispDestroy("%s: resource value must be string, number or opaque, not %s",
			fname, STROBJ(val));
d861 2
a862 2
	from.size = val == NIL ? 1 : strlen(THESTR(val)) + 1;
	from.addr = val == NIL ? "" : THESTR(val);
d879 2
a880 2
		LispWarning("%s: bad resource size %d for %s",
			    fname, to.size, THESTR(arg));
d1081 1
a1081 1
    XtAppSetExitFlag(XtWidgetToApplicationContext(w));
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d30 1
a30 1
/* $XFree86: xc/programs/xedit/lisp/modules/xt.c,v 1.19 2002/11/23 08:26:52 paulo Exp $ */
a33 1
#include <string.h>
a37 1
#include "private.h"
d61 1
d70 1
a70 1
void LispXtCleanupCallback(Widget, XtPointer, XtPointer);
d72 1
a72 2
void LispXtCallback(Widget, XtPointer, XtPointer);
void LispXtInputCallback(XtPointer, int*, XtInputId*);
d74 18
a91 2
/* a hack... */
LispObj *Lisp_XtCoerceToWidgetList(LispBuiltin*);
d93 1
a93 39
LispObj *Lisp_XtAddCallback(LispBuiltin*);
LispObj *Lisp_XtAppInitialize(LispBuiltin*);
LispObj *Lisp_XtAppMainLoop(LispBuiltin*);
LispObj *Lisp_XtAppAddInput(LispBuiltin*);
LispObj *Lisp_XtAppPending(LispBuiltin*);
LispObj *Lisp_XtAppProcessEvent(LispBuiltin*);
LispObj *Lisp_XtCreateWidget(LispBuiltin*);
LispObj *Lisp_XtCreateManagedWidget(LispBuiltin*);
LispObj *Lisp_XtCreatePopupShell(LispBuiltin*);
LispObj *Lisp_XtDestroyWidget(LispBuiltin*);
LispObj *Lisp_XtGetKeyboardFocusWidget(LispBuiltin*);
LispObj *Lisp_XtGetValues(LispBuiltin*);
LispObj *Lisp_XtManageChild(LispBuiltin*);
LispObj *Lisp_XtUnmanageChild(LispBuiltin*);
LispObj *Lisp_XtSetMappedWhenManaged(LispBuiltin*);
LispObj *Lisp_XtMapWidget(LispBuiltin*);
LispObj *Lisp_XtName(LispBuiltin*);
LispObj *Lisp_XtParent(LispBuiltin*);
LispObj *Lisp_XtUnmapWidget(LispBuiltin*);
LispObj *Lisp_XtPopup(LispBuiltin*);
LispObj *Lisp_XtPopdown(LispBuiltin*);
LispObj *Lisp_XtIsRealized(LispBuiltin*);
LispObj *Lisp_XtRealizeWidget(LispBuiltin*);
LispObj *Lisp_XtUnrealizeWidget(LispBuiltin*);
LispObj *Lisp_XtRemoveInput(LispBuiltin*);
LispObj *Lisp_XtSetSensitive(LispBuiltin*);
LispObj *Lisp_XtSetValues(LispBuiltin*);
LispObj *Lisp_XtWidgetToApplicationContext(LispBuiltin*);
LispObj *Lisp_XtDisplay(LispBuiltin*);
LispObj *Lisp_XtDisplayOfObject(LispBuiltin*);
LispObj *Lisp_XtScreen(LispBuiltin*);
LispObj *Lisp_XtScreenOfObject(LispBuiltin*);
LispObj *Lisp_XtSetKeyboardFocus(LispBuiltin*);
LispObj *Lisp_XtWindow(LispBuiltin*);
LispObj *Lisp_XtWindowOfObject(LispBuiltin*);
LispObj *Lisp_XtAddGrab(LispBuiltin*);
LispObj *Lisp_XtRemoveGrab(LispBuiltin*);
LispObj *Lisp_XtAppGetExitFlag(LispBuiltin*);
LispObj *Lisp_XtAppSetExitFlag(LispBuiltin*);
d95 1
a95 3
LispObj *LispXtCreateWidget(LispBuiltin*, int);

static Resources *LispConvertResources(LispObj*, Widget,
d112 1
d117 18
a134 41
    {LispFunction, Lisp_XtCoerceToWidgetList, "xt-coerce-to-widget-list number opaque"},

    {LispFunction, Lisp_XtAddGrab, "xt-add-grab widget exclusive spring-loaded"},
    {LispFunction, Lisp_XtAddCallback, "xt-add-callback widget callback-name callback &optional client-data"},
    {LispFunction, Lisp_XtAppAddInput, "xt-app-add-input app-context fileno condition function &optional client-data"},
    {LispFunction, Lisp_XtAppInitialize, "xt-app-initialize app-context-return application-class &optional options fallback-resources"},
    {LispFunction, Lisp_XtAppPending, "xt-app-pending app-context"},
    {LispFunction, Lisp_XtAppMainLoop, "xt-app-main-loop app-context"},
    {LispFunction, Lisp_XtAppProcessEvent, "xt-app-process-event app-context &optional mask"},
    {LispFunction, Lisp_XtAppGetExitFlag, "xt-app-get-exit-flag app-context"},
    {LispFunction, Lisp_XtAppSetExitFlag, "xt-app-set-exit-flag app-context"},
    {LispFunction, Lisp_XtCreateManagedWidget, "xt-create-managed-widget name widget-class parent &optional arguments"},
    {LispFunction, Lisp_XtCreateWidget, "xt-create-widget name widget-class parent &optional arguments"},
    {LispFunction, Lisp_XtCreatePopupShell, "xt-create-popup-shell name widget-class parent &optional arguments"},
    {LispFunction, Lisp_XtDestroyWidget, "xt-destroy-widget widget"},
    {LispFunction, Lisp_XtGetKeyboardFocusWidget, "xt-get-keyboard-focus-widget widget"},
    {LispFunction, Lisp_XtGetValues, "xt-get-values widget arguments"},
    {LispFunction, Lisp_XtManageChild, "xt-manage-child widget"},
    {LispFunction, Lisp_XtName, "xt-name widget"},
    {LispFunction, Lisp_XtUnmanageChild, "xt-unmanage-child widget"},
    {LispFunction, Lisp_XtMapWidget, "xt-map-widget widget"},
    {LispFunction, Lisp_XtUnmapWidget, "xt-unmap-widget widget"},
    {LispFunction, Lisp_XtSetMappedWhenManaged, "xt-set-mapped-when-managed widget map-when-managed"},
    {LispFunction, Lisp_XtParent, "xt-parent widget"},
    {LispFunction, Lisp_XtPopup, "xt-popup widget grab-kind"},
    {LispFunction, Lisp_XtPopdown, "xt-popdown widget"},
    {LispFunction, Lisp_XtIsRealized, "xt-is-realized widget"},
    {LispFunction, Lisp_XtRealizeWidget, "xt-realize-widget widget"},
    {LispFunction, Lisp_XtUnrealizeWidget, "xt-unrealize-widget widget"},
    {LispFunction, Lisp_XtRemoveInput, "xt-remove-input input"},
    {LispFunction, Lisp_XtRemoveGrab, "xt-remove-grab widget"},
    {LispFunction, Lisp_XtSetKeyboardFocus, "xt-set-keyboard-focus widget descendant"},
    {LispFunction, Lisp_XtSetSensitive, "xt-set-sensitive widget sensitive"},
    {LispFunction, Lisp_XtSetValues, "xt-set-values widget arguments"},
    {LispFunction, Lisp_XtWidgetToApplicationContext, "xt-widget-to-application-context widget"},
    {LispFunction, Lisp_XtDisplay, "xt-display widget"},
    {LispFunction, Lisp_XtDisplayOfObject, "xt-display-of-object object"},
    {LispFunction, Lisp_XtScreen, "xt-screen widget"},
    {LispFunction, Lisp_XtScreenOfObject, "xt-screen-of-object object"},
    {LispFunction, Lisp_XtWindow, "xt-window widget"},
    {LispFunction, Lisp_XtWindowOfObject, "xt-window-of-object object"},
d146 1
a146 2
static int xtAppContext_t, xtWidget_t, xtWidgetClass_t, xtWidgetList_t,
	   xtInputId_t, xtDisplay_t, xtScreen_t, xtWindow_t;
d153 1
a153 4
static XrmQuark qCardinal, qInt, qString, qWidget, qFloat;

static CallbackArgs **input_list;
static Cardinal num_input_list, size_input_list;
d159 1
a159 1
xtLoadModule(void)
d162 1
a162 1
    char *fname = "XT-LOAD-MODULE";
d164 4
a167 8
    xtAppContext_t = LispRegisterOpaqueType("XtAppContext");
    xtWidget_t = LispRegisterOpaqueType("Widget");
    xtWidgetClass_t = LispRegisterOpaqueType("WidgetClass");
    xtWidgetList_t = LispRegisterOpaqueType("WidgetList");
    xtInputId_t = LispRegisterOpaqueType("XtInputId");
    xtDisplay_t = LispRegisterOpaqueType("Display*");
    xtScreen_t = LispRegisterOpaqueType("Screen*");
    xtWindow_t = LispRegisterOpaqueType("Window");
d169 1
a169 1
    LispExecute("(DEFSTRUCT XT-WIDGET-LIST NUM-CHILDREN CHILDREN)\n");
d171 2
a172 2
    GCDisable();
    (void)LispSetVariable(ATOM2("CORE-WIDGET-CLASS"),
d175 1
a175 7
    (void)LispSetVariable(ATOM2("COMPOSITE-WIDGET-CLASS"),
			  OPAQUE(compositeWidgetClass, xtWidgetClass_t),
			  fname, 0);
    (void)LispSetVariable(ATOM2("CONSTRAINT-WIDGET-CLASS"),
			  OPAQUE(constraintWidgetClass, xtWidgetClass_t),
			  fname, 0);
    (void)LispSetVariable(ATOM2("TRANSIENT-SHELL-WIDGET-CLASS"),
d180 6
a185 6
    (void)LispSetVariable(ATOM2("XT-GRAB-EXCLUSIVE"),
			  INTEGER(XtGrabExclusive), fname, 0);
    (void)LispSetVariable(ATOM2("XT-GRAB-NONE"),
			  INTEGER(XtGrabNone), fname, 0);
    (void)LispSetVariable(ATOM2("XT-GRAB-NONE-EXCLUSIVE"),
			  INTEGER(XtGrabNonexclusive), fname, 0);
d188 11
a198 19
    (void)LispSetVariable(ATOM2("XT-IM-XEVENT"),
			  INTEGER(XtIMXEvent), fname, 0);
    (void)LispSetVariable(ATOM2("XT-IM-TIMER"),
			  INTEGER(XtIMTimer), fname, 0);
    (void)LispSetVariable(ATOM2("XT-IM-ALTERNATE-INPUT"),
			  INTEGER(XtIMAlternateInput), fname, 0);
    (void)LispSetVariable(ATOM2("XT-IM-SIGNAL"),
			  INTEGER(XtIMSignal), fname, 0);
    (void)LispSetVariable(ATOM2("XT-IM-ALL"),
			  INTEGER(XtIMAll), fname, 0);

    /* parameters for XtAppAddInput */
    (void)LispSetVariable(ATOM2("XT-INPUT-READ-MASK"),
			  INTEGER(XtInputReadMask), fname, 0);
    (void)LispSetVariable(ATOM2("XT-INPUT-WRITE-MASK"),
			  INTEGER(XtInputWriteMask), fname, 0);
    (void)LispSetVariable(ATOM2("XT-INPUT-EXCEPT-MASK"),
			  INTEGER(XtInputExceptMask), fname, 0);
    GCEnable();
a203 1
    qFloat = XrmPermStringToQuark(XtRFloat);
d206 1
a206 1
	LispAddBuiltinFunction(&lispbuiltins[i]);
d212 1
a212 1
LispXtCallback(Widget w, XtPointer user_data, XtPointer call_data)
d215 2
a216 1
    LispObj *code, *ocod = COD;
d218 3
a220 3
    GCDisable();
		/* callback name */	   /* reall caller */
    code = CONS(CDR(CDR(args->data)), CONS(OPAQUE(w, xtWidget_t),
d223 2
a224 2
    COD = CONS(code, COD);
    GCEnable();
d226 2
a227 2
    (void)EVAL(code);
    COD = ocod;
a229 1

d231 1
a231 1
LispXtCleanupCallback(Widget w, XtPointer user_data, XtPointer call_data)
d234 1
a236 19
    XtFree((XtPointer)args);
}

void
LispXtInputCallback(XtPointer closure, int *source, XtInputId *id)
{
    CallbackArgs *args = (CallbackArgs*)closure;
    LispObj *code, *ocod = COD;

    GCDisable();
		/* callback name */	  /* user arguments */
    code = CONS(CDR(CDR(args->data)), CONS(CAR(CDR(args->data)),
		CONS(INTEGER(*source), CONS(CAR(args->data), NIL))));
		     /* input source */	   /* input id */
    COD = CONS(code, COD);
    GCEnable();

    (void)EVAL(code);
    COD = ocod;
d240 1
a240 4
Lisp_XtCoerceToWidgetList(LispBuiltin *builtin)
/*
 xt-coerce-to-widget-list number opaque
 */
d245 1
a245 1
    LispObj *cons, *widget_list, *result;
d247 5
a251 1
    LispObj *onumber, *opaque;
d253 2
a254 2
    opaque = ARGUMENT(1);
    onumber = ARGUMENT(0);
d256 2
a257 10
    CHECK_INDEX(onumber);
    num_children = FIXNUM_VALUE(onumber);

    if (!CHECKO(opaque, xtWidgetList_t))
	LispDestroy("%s: cannot convert %s to WidgetList",
		    STRFUN(builtin), STROBJ(opaque));
    children = (WidgetList)(opaque->data.opaque.data);

    GCDisable();
    widget_list = cons = NIL;
d259 3
a261 3
	result = CONS(OPAQUE(children[i], xtWidget_t), NIL);
	if (widget_list == NIL)
	    widget_list = cons = result;
d263 2
a264 2
	    RPLACD(cons, result);
	    cons = CDR(cons);
d268 6
a273 6
    result = APPLY(ATOM("MAKE-XT-WIDGET-LIST"),
		   CONS(KEYWORD("NUM-CHILDREN"),
			CONS(INTEGER(num_children),
			     CONS(KEYWORD("CHILDREN"),
				  CONS(widget_list, NIL)))));
    GCEnable();
d275 1
a275 1
    return (result);
d279 1
a279 4
Lisp_XtAddCallback(LispBuiltin *builtin)
/*
 xt-add-callback widget callback-name callback &optional client-data
 */
d282 1
a282 8
    LispObj *data;

    LispObj *widget, *callback_name, *callback, *client_data;

    client_data = ARGUMENT(3);
    callback = ARGUMENT(2);
    callback_name = ARGUMENT(1);
    widget = ARGUMENT(0);
d284 1
d286 20
a305 7
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));

    CHECK_STRING(callback_name);
    if (!SYMBOLP(callback) && callback->type != LispLambda_t)
	LispDestroy("%s: %s cannot be used as a callback",
		    STRFUN(builtin), STROBJ(callback));
d307 1
a307 4
    if (client_data == UNSPEC)
	client_data = NIL;

    data = CONS(widget, CONS(client_data, callback));
d309 1
d312 1
d315 2
a316 2
    XtAddCallback((Widget)(widget->data.opaque.data), THESTR(callback_name),
		  LispXtCallback, (XtPointer)arguments);
d318 1
a318 103
		  LispXtCleanupCallback, (XtPointer)arguments);

    return (client_data);
}

LispObj *
Lisp_XtAppAddInput(LispBuiltin *builtin)
/*
  xt-app-add-input app-context fileno condition function &optional client-data
 */
{
    LispObj *data, *input;
    XtAppContext appcon;
    int source, condition;
    CallbackArgs *arguments;
    XtInputId id;

    LispObj *app_context, *fileno, *ocondition, *function, *client_data;

    client_data = ARGUMENT(4);
    function = ARGUMENT(3);
    ocondition = ARGUMENT(2);
    fileno = ARGUMENT(1);
    app_context = ARGUMENT(0);

    if (!CHECKO(app_context, xtAppContext_t))
	LispDestroy("%s: cannot convert %s to XtAppContext",
		    STRFUN(builtin), STROBJ(app_context));
    appcon = (XtAppContext)(app_context->data.opaque.data);

    CHECK_LONGINT(fileno);
    source = LONGINT_VALUE(fileno);

    CHECK_FIXNUM(ocondition);
    condition = FIXNUM_VALUE(ocondition);

    if (!SYMBOLP(function) && function->type != LispLambda_t)
	LispDestroy("%s: %s cannot be used as a callback",
		    STRFUN(builtin), STROBJ(function));

    /* client data optional */
    if (client_data == UNSPEC)
	client_data = NIL;

    data = CONS(NIL, CONS(client_data, function));

    arguments = XtNew(CallbackArgs);
    arguments->data = data;

    id = XtAppAddInput(appcon, source, (XtPointer)condition,
		       LispXtInputCallback, (XtPointer)arguments);
    GCDisable();
    input = OPAQUE(id, xtInputId_t);
    GCEnable();
    RPLACA(data, input);
    PROTECT(input, data);

    if (num_input_list + 1 >= size_input_list) {
	++size_input_list;
	input_list = (CallbackArgs**)
	    XtRealloc((XtPointer)input_list,
		      sizeof(CallbackArgs*) * size_input_list);
    }
    input_list[num_input_list++] = arguments;

    return (input);
}

LispObj *
Lisp_XtRemoveInput(LispBuiltin *builtin)
/*
 xt-remove-input input
 */
{
    int i;
    XtInputId id;
    CallbackArgs *args;

    LispObj *input;

    input = ARGUMENT(0);

    if (!CHECKO(input, xtInputId_t))
	LispDestroy("%s: cannot convert %s to XtInputId",
		    STRFUN(builtin), STROBJ(input));

    id = (XtInputId)(input->data.opaque.data);
    for (i = 0; i < num_input_list; i++) {
	args = input_list[i];
	if (id == (XtInputId)(CAR(args->data)->data.opaque.data)) {
	    UPROTECT(CAR(args->data), args->data);
	    XtFree((XtPointer)args);

	    if (i + 1 < num_input_list)
		memmove(input_list + i, input_list + i + 1,
			sizeof(CallbackArgs*) * (num_input_list - i - 1));
	    --num_input_list;

	    XtRemoveInput(id);

	    return (T);
	}
    }
d324 1
a324 4
Lisp_XtAppInitialize(LispBuiltin *builtin)
/*
 xt-app-initialize app-context-return application-class &optional options fallback-resources
 */
d327 1
d333 10
a342 2
    LispObj *app_context_return, *application_class,
	    *options, *fallback_resources;
d344 3
a346 12
    fallback_resources = ARGUMENT(3);
    options = ARGUMENT(2);
    application_class = ARGUMENT(1);
    app_context_return = ARGUMENT(0);

    CHECK_SYMBOL(app_context_return);
    CHECK_STRING(application_class);
    CHECK_LIST(options);

    /* check fallback resources, if given */
    if (fallback_resources != UNSPEC) {
	LispObj *string;
d348 4
d353 5
a357 4
	CHECK_CONS(fallback_resources);
	for (string = fallback_resources, count = 0; CONS_P(string);
	     string = CDR(string), count++)
	    CHECK_STRING(CAR(string));
d360 4
a363 4
	fallback = LispMalloc(sizeof(String) * (count + 1));
	for (string = fallback_resources, count = 0; CONS_P(string);
	     string = CDR(string), count++)
	    fallback[count] = THESTR(CAR(string));
d367 3
a369 2
    shell = XtAppInitialize(&appcon, THESTR(application_class), NULL,
			    0, &zero, NULL, fallback, NULL, 0);
d371 4
a374 4
	LispFree(fallback);
    (void)LispSetVariable(app_context_return,
			  OPAQUE(appcon, xtAppContext_t),
			  STRFUN(builtin), 0);
d378 7
a384 2
    if (options != UNSPEC) {
	resources = LispConvertResources(options, shell,
d397 1
a397 4
Lisp_XtAppMainLoop(LispBuiltin *builtin)
/*
 xt-app-main-loop app-context
 */
d399 4
a402 7
    LispObj *app_context;

    app_context = ARGUMENT(0);

    if (!CHECKO(app_context, xtAppContext_t))
	LispDestroy("%s: cannot convert %s to XtAppContext",
		    STRFUN(builtin), STROBJ(app_context));
d404 1
a404 1
    XtAppMainLoop((XtAppContext)(app_context->data.opaque.data));
d410 1
a410 4
Lisp_XtAppPending(LispBuiltin *builtin)
/*
 xt-app-pending app-context
 */
d412 4
a415 3
    LispObj *app_context;

    app_context = ARGUMENT(0);
d417 1
a417 6
    if (!CHECKO(app_context, xtAppContext_t))
	LispDestroy("%s: cannot convert %s to XtAppContext",
		    STRFUN(builtin), STROBJ(app_context));

    return (INTEGER(
	    XtAppPending((XtAppContext)(app_context->data.opaque.data))));
d421 1
a421 4
Lisp_XtAppProcessEvent(LispBuiltin *builtin)
/*
 xt-app-process-event app-context &optional mask
 */
d426 8
a433 11
    LispObj *app_context, *omask;

    omask = ARGUMENT(1);
    app_context = ARGUMENT(0);

    if (!CHECKO(app_context, xtAppContext_t))
	LispDestroy("%s: cannot convert %s to XtAppContext",
		    STRFUN(builtin), STROBJ(app_context));

    appcon = (XtAppContext)(app_context->data.opaque.data);
    if (omask == UNSPEC)
d435 16
a450 3
    else {
	CHECK_FIXNUM(omask);
	mask = FIXNUM_VALUE(omask);
d453 1
a453 8
    if (mask != (mask & XtIMAll))
	LispDestroy("%s: %d does not fit in XtInputMask %d",
		    STRFUN(builtin), mask);

    if (mask)
	XtAppProcessEvent(appcon, mask);

    return (omask == NIL ? FIXNUM(mask) : omask);
d457 1
a457 4
Lisp_XtRealizeWidget(LispBuiltin *builtin)
/*
 xt-realize-widget widget
 */
d461 4
a464 1
    LispObj *owidget;
d466 1
a466 6
    owidget = ARGUMENT(0);

    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
d477 1
a477 1
    return (owidget);
d481 1
a481 4
Lisp_XtUnrealizeWidget(LispBuiltin *builtin)
/*
 xt-unrealize-widget widget
 */
d483 1
a483 1
    LispObj *widget;
d485 4
a488 1
    widget = ARGUMENT(0);
d490 2
a491 41
    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));

    XtUnrealizeWidget((Widget)(widget->data.opaque.data));

    return (widget);
}

LispObj *
Lisp_XtIsRealized(LispBuiltin *builtin)
/*
 xt-is-realized widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));

    return (XtIsRealized((Widget)(widget->data.opaque.data)) ? T : NIL);
}

LispObj *
Lisp_XtDestroyWidget(LispBuiltin *builtin)
/*
 xt-destroy-widget widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));

    XtDestroyWidget((Widget)(widget->data.opaque.data));
d500 1
a500 4
Lisp_XtCreateWidget(LispBuiltin *builtin)
/*
 xt-create-widget name widget-class parent &optional arguments
 */
d502 1
a502 1
    return (LispXtCreateWidget(builtin, UNMANAGED));
d506 1
a506 4
Lisp_XtCreateManagedWidget(LispBuiltin *builtin)
/*
 xt-create-managed-widget name widget-class parent &optional arguments
 */
d508 1
a508 1
    return (LispXtCreateWidget(builtin, MANAGED));
d512 1
a512 4
Lisp_XtCreatePopupShell(LispBuiltin *builtin)
/*
 xt-create-popup-shell name widget-class parent &optional arguments
 */
d514 1
a514 1
    return (LispXtCreateWidget(builtin, SHELL));
d518 1
a518 6
LispXtCreateWidget(LispBuiltin *builtin, int options)
/*
 xt-create-widget name widget-class parent &optional arguments
 xt-create-managed-widget name widget-class parent &optional arguments
 xt-create-popup-shell name widget-class parent &optional arguments
 */
d525 17
a541 1
    LispObj *oname, *owidget_class, *oparent, *arguments;
d543 3
a545 21
    arguments = ARGUMENT(3);
    oparent = ARGUMENT(2);
    owidget_class = ARGUMENT(1);
    oname = ARGUMENT(0);

    CHECK_STRING(oname);
    name = THESTR(oname);

    if (!CHECKO(owidget_class, xtWidgetClass_t))
	LispDestroy("%s: cannot convert %s to WidgetClass",
		    STRFUN(builtin), STROBJ(owidget_class));
    widget_class = (WidgetClass)(owidget_class->data.opaque.data);

    if (!CHECKO(oparent, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(oparent));
    parent = (Widget)(oparent->data.opaque.data);

    CHECK_LIST(arguments);

    if (options == SHELL)
a546 2
    else
	widget = XtCreateWidget(name, widget_class, parent, NULL, 0);
d548 1
a548 1
    if (arguments == UNSPEC || arguments == NIL)
d550 2
d553 1
a553 1
	resources = LispConvertResources(arguments, widget,
d567 1
a567 21
Lisp_XtGetKeyboardFocusWidget(LispBuiltin *builtin)
/*
 xt-get-keyboard-focus-widget widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    return (OPAQUE(XtGetKeyboardFocusWidget((Widget)(widget->data.opaque.data)),
		   xtWidget_t));
}

LispObj *
Lisp_XtGetValues(LispBuiltin *builtin)
/*
 xt-get-values widget arguments
 */
d573 1
a573 1
    LispObj *list, *object = NIL, *result, *cons = NIL;
d581 7
a587 13
    LispObj *owidget, *arguments;

    arguments = ARGUMENT(1);
    owidget = ARGUMENT(0);

    if (arguments == NIL)
	return (NIL);

    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
    CHECK_CONS(arguments);
d590 1
a590 2
    plist =  XtParent(widget) ?
	     GetResourceList(XtClass(XtParent(widget))) : NULL;
d592 7
a598 5
    GCDisable();
    result = NIL;
    for (list = arguments; CONS_P(list); list = CDR(list)) {
	CHECK_STRING(CAR(list));
	if ((resource = GetResourceInfo(THESTR(CAR(list)), rlist, plist))
d611 1
a611 1
			    GetResourceInfo(THESTR(CAR(list)),
d620 2
a621 2
		LispMessage("%s: resource %s not available",
			    STRFUN(builtin), THESTR(CAR(list)));
d627 1
a627 1
		XtSetArg(args[0], THESTR(CAR(list)), &c1);
d630 1
a630 1
		XtSetArg(args[0], THESTR(CAR(list)), &c2);
d633 1
a633 1
		XtSetArg(args[0], THESTR(CAR(list)), &c4);
d637 1
a637 1
		XtSetArg(args[0], THESTR(CAR(list)), &c8);
d646 1
a646 1
	    object = CONS(CAR(list), STRING(c8));
d648 1
a648 1
	    object = CONS(CAR(list), STRING(c4));
d654 1
a654 1
		object = CONS(CAR(list), INTEGER(c8));
d657 1
a657 1
	    object = CONS(CAR(list), INTEGER(c4));
d662 1
a662 1
		    object = CONS(CAR(list), OPAQUE(c1, 0));
d665 1
a665 1
		    object = CONS(CAR(list), OPAQUE(c2, 0));
d668 1
a668 1
		    object = CONS(CAR(list), OPAQUE(c4, 0));
d672 1
a672 1
		    object = CONS(CAR(list), OPAQUE(c8, 0));
d678 2
a679 2
	if (result == NIL)
	    result = cons = CONS(object, NIL);
d681 2
a682 2
	    RPLACD(cons, CONS(object, NIL));
	    cons = CDR(cons);
d685 1
a685 1
    GCEnable();
d687 1
a687 1
    return (result);
d691 1
a691 4
Lisp_XtManageChild(LispBuiltin *builtin)
/*
 xt-manage-child widget
 */
d693 4
a696 1
    LispObj *widget;
d698 1
a698 8
    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    XtManageChild((Widget)(widget->data.opaque.data));

    return (widget);
d702 1
a702 79
Lisp_XtUnmanageChild(LispBuiltin *builtin)
/*
 xt-unmanage-child widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    XtUnmanageChild((Widget)(widget->data.opaque.data));

    return (widget);
}

LispObj *
Lisp_XtMapWidget(LispBuiltin *builtin)
/*
 xt-map-widget widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    XtMapWidget((Widget)(widget->data.opaque.data));

    return (widget);
}

LispObj *
Lisp_XtUnmapWidget(LispBuiltin *builtin)
/*
 xt-unmap-widget widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    XtUnmapWidget((Widget)(widget->data.opaque.data));

    return (widget);
}

LispObj *
Lisp_XtSetMappedWhenManaged(LispBuiltin *builtin)
/*
 xt-set-mapped-when-managed widget map-when-managed
 */
{
    LispObj *widget, *map_when_managed;

    map_when_managed = ARGUMENT(1);
    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));

    XtSetMappedWhenManaged((Widget)(widget->data.opaque.data),
			   map_when_managed != NIL);

    return (map_when_managed);
}

LispObj *
Lisp_XtPopup(LispBuiltin *builtin)
/*
 xt-popup widget grab-kind
 */
d706 7
a712 10
    LispObj *widget, *grab_kind;

    grab_kind = ARGUMENT(1);
    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    CHECK_INDEX(grab_kind);
    kind = (XtGrabKind)FIXNUM_VALUE(grab_kind);
d715 3
a717 3
	LispDestroy("%s: %d does not fit in XtGrabKind",
		    STRFUN(builtin), kind);
    XtPopup((Widget)(widget->data.opaque.data), kind);
d719 1
a719 1
    return (grab_kind);
d723 1
a723 4
Lisp_XtPopdown(LispBuiltin *builtin)
/*
 xt-popdown widget
 */
d725 4
a728 1
    LispObj *widget;
d730 1
a730 31
    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    XtPopdown((Widget)(widget->data.opaque.data));

    return (widget);
}

LispObj *
Lisp_XtSetKeyboardFocus(LispBuiltin *builtin)
/*
 xt-set-keyboard-focus widget descendant
 */
{
    LispObj *widget, *descendant;

    descendant = ARGUMENT(1);
    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    if (!CHECKO(descendant, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(descendant));
    XtSetKeyboardFocus((Widget)(widget->data.opaque.data),
		       (Widget)(descendant->data.opaque.data));

    return (widget);
d734 1
a734 4
Lisp_XtSetSensitive(LispBuiltin *builtin)
/*
 xt-set-sensitive widget sensitive
 */
d736 5
a740 1
    LispObj *widget, *sensitive;
d742 1
a742 9
    sensitive = ARGUMENT(1);
    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));
    XtSetSensitive((Widget)(widget->data.opaque.data), sensitive != NIL);

    return (sensitive);
d746 1
a746 4
Lisp_XtSetValues(LispBuiltin *builtin)
/*
 xt-set-values widget arguments
 */
d751 7
a757 4
    LispObj *owidget, *arguments;

    arguments = ARGUMENT(1);
    owidget = ARGUMENT(0);
d759 1
a759 9
    if (arguments == NIL)
	return (owidget);

    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
    CHECK_CONS(arguments);
    resources = LispConvertResources(arguments, widget,
d767 1
a767 1
    return (owidget);
d771 1
a771 4
Lisp_XtWidgetToApplicationContext(LispBuiltin *builtin)
/*
 xt-widget-to-application-context widget
 */
d776 4
a779 8
    LispObj *owidget;

    owidget = ARGUMENT(0);

    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
a784 249
LispObj *
Lisp_XtDisplay(LispBuiltin *builtin)
/*
 xt-display widget
 */
{
    Widget widget;
    Display *display;

    LispObj *owidget;

    owidget = ARGUMENT(0);

    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
    display = XtDisplay(widget);

    return (OPAQUE(display, xtDisplay_t));
}

LispObj *
Lisp_XtDisplayOfObject(LispBuiltin *builtin)
/*
 xt-display-of-object object
 */
{
    Widget widget;
    Display *display;

    LispObj *object;

    object = ARGUMENT(0);

    if (!CHECKO(object, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(object));
    widget = (Widget)(object->data.opaque.data);
    display = XtDisplayOfObject(widget);

    return (OPAQUE(display, xtDisplay_t));
}

LispObj *
Lisp_XtScreen(LispBuiltin *builtin)
/*
 xt-screen widget
 */
{
    Widget widget;
    Screen *screen;

    LispObj *owidget;

    owidget = ARGUMENT(0);

    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
    screen = XtScreen(widget);

    return (OPAQUE(screen, xtScreen_t));
}

LispObj *
Lisp_XtScreenOfObject(LispBuiltin *builtin)
/*
 xt-screen-of-object object
 */
{
    Widget widget;
    Screen *screen;

    LispObj *object;

    object = ARGUMENT(0);

    if (!CHECKO(object, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(object));
    widget = (Widget)(object->data.opaque.data);
    screen = XtScreenOfObject(widget);

    return (OPAQUE(screen, xtScreen_t));
}

LispObj *
Lisp_XtWindow(LispBuiltin *builtin)
/*
 xt-window widget
 */
{
    Widget widget;
    Window window;

    LispObj *owidget;

    owidget = ARGUMENT(0);

    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
    window = XtWindow(widget);

    return (OPAQUE(window, xtWindow_t));
}

LispObj *
Lisp_XtWindowOfObject(LispBuiltin *builtin)
/*
 xt-window-of-object widget
 */
{
    Widget widget;
    Window window;

    LispObj *object;

    object = ARGUMENT(0);

    if (!CHECKO(object, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(object));
    widget = (Widget)(object->data.opaque.data);
    window = XtWindowOfObject(widget);

    return (OPAQUE(window, xtWindow_t));
}

LispObj *
Lisp_XtAddGrab(LispBuiltin *builtin)
/*
 xt-add-grab widget exclusive spring-loaded
 */
{
    Widget widget;
    Bool exclusive, spring_loaded;

    LispObj *owidget, *oexclusive, *ospring_loaded;

    ospring_loaded = ARGUMENT(2);
    oexclusive = ARGUMENT(1);
    owidget = ARGUMENT(0);

    if (!CHECKO(owidget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(owidget));
    widget = (Widget)(owidget->data.opaque.data);
    exclusive = oexclusive != NIL;
    spring_loaded = ospring_loaded != NIL;

    XtAddGrab(widget, exclusive, spring_loaded);

    return (T);
}

LispObj *
Lisp_XtRemoveGrab(LispBuiltin *builtin)
/*
 xt-remove-grab widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));

    XtRemoveGrab((Widget)(widget->data.opaque.data));

    return (NIL);
}

LispObj *
Lisp_XtName(LispBuiltin *builtin)
/*
 xt-name widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));

    return (STRING(XtName((Widget)(widget->data.opaque.data))));
}

LispObj *
Lisp_XtParent(LispBuiltin *builtin)
/*
 xt-parent widget
 */
{
    LispObj *widget;

    widget = ARGUMENT(0);

    if (!CHECKO(widget, xtWidget_t))
	LispDestroy("%s: cannot convert %s to Widget",
		    STRFUN(builtin), STROBJ(widget));

    return (OPAQUE(XtParent((Widget)widget->data.opaque.data), xtWidget_t));
}

LispObj *
Lisp_XtAppGetExitFlag(LispBuiltin *builtin)
/*
 xt-app-get-exit-flag app-context
 */
{
    LispObj *app_context;

    app_context = ARGUMENT(0);

    if (!CHECKO(app_context, xtAppContext_t))
	LispDestroy("%s: cannot convert %s to XtAppContext",
		    STRFUN(builtin), STROBJ(app_context));

    return (XtAppGetExitFlag((XtAppContext)(app_context->data.opaque.data)) ?
	    T : NIL);
}

LispObj *
Lisp_XtAppSetExitFlag(LispBuiltin *builtin)
/*
 xt-app-get-exit-flag app-context
 */
{
    LispObj *app_context;

    app_context = ARGUMENT(0);

    if (!CHECKO(app_context, xtAppContext_t))
	LispDestroy("%s: cannot convert %s to XtAppContext",
		    STRFUN(builtin), STROBJ(app_context));

    XtAppSetExitFlag((XtAppContext)(app_context->data.opaque.data));

    return (T);
}

d786 1
a786 1
LispConvertResources(LispObj *list, Widget widget,
d798 1
a798 1
    char *fname = "XT-CONVERT-RESOURCES";
d801 2
a802 2
    for (; CONSP(list); list = CDR(list)) {
	if (!CONSP(CAR(list))) {
d804 1
a804 1
	    LispDestroy("%s: %s is not a cons", fname, STROBJ(CAR(list)));
d809 1
a809 1
	if (!STRINGP(arg)) {
d811 1
a811 1
	    LispDestroy("%s: %s is not a string", fname, STROBJ(arg));
d814 1
a814 1
	if ((resource = GetResourceInfo(THESTR(arg), rlist, plist)) == NULL) {
d827 1
a827 1
			    GetResourceInfo(THESTR(arg),
d836 1
a836 2
		LispMessage("%s: resource %s not available",
			    fname, THESTR(arg));
d841 1
a841 1
	if (LONGINTP(val) || DFLOATP(val) || OPAQUEP(val)) {
d845 3
a847 16
	    if (!OPAQUEP(val)) {
		float fvalue;

		if (DFLOATP(val))
		    fvalue = DFLOAT_VALUE(val);
		else
		    fvalue = LONGINT_VALUE(val);
		if (resource->qtype == qFloat) {
		    XtSetArg(resources->args[resources->num_args],
			     XrmQuarkToString(resource->qname), fvalue);
		}
		else
		    XtSetArg(resources->args[resources->num_args],
			     XrmQuarkToString(resource->qname),
			     (int)fvalue);
	    }
d854 1
a854 29
	else if (val == NIL) {
	    /* XXX assume it is a pointer or a boolean */
#ifdef DEBUG
	    LispWarning("%s: assuming %s is a pointer or boolean",
			fname, XrmQuarkToString(resource->qname));
#endif
	    resources->args = (Arg*)
		XtRealloc((XtPointer)resources->args,
			  sizeof(Arg) * (resources->num_args + 1));
	    XtSetArg(resources->args[resources->num_args],
		     XrmQuarkToString(resource->qname), NULL);
	    ++resources->num_args;
	    continue;
	}
	else if (val == T) {
	    /* XXX assume it is a boolean */
#ifdef DEBUG
	    LispWarning("%s: assuming %s is a boolean",
			fname, XrmQuarkToString(resource->qname));
#endif
	    resources->args = (Arg*)
		XtRealloc((XtPointer)resources->args,
			  sizeof(Arg) * (resources->num_args + 1));
	    XtSetArg(resources->args[resources->num_args],
		     XrmQuarkToString(resource->qname), True);
	    ++resources->num_args;
	    continue;
	}
	else if (!STRINGP(val)) {
d856 3
a858 2
	    LispDestroy("%s: resource value must be string, number or opaque, not %s",
			fname, STROBJ(val));
d861 2
a862 2
	from.size = val == NIL ? 1 : strlen(THESTR(val)) + 1;
	from.addr = val == NIL ? "" : THESTR(val);
d879 2
a880 2
		LispWarning("%s: bad resource size %d for %s",
			    fname, to.size, THESTR(arg));
d1081 1
a1081 1
    XtAppSetExitFlag(XtWidgetToApplicationContext(w));
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d30 1
a30 1
/* $XFree86: xc/programs/xedit/lisp/modules/xt.c,v 1.21 2003/04/27 18:17:38 tsi Exp $ */
d38 2
a39 2
#include "lisp/internal.h"
#include "lisp/private.h"
d70 1
a70 1
int xtLoadModule(void);
d548 1
a548 1
	for (string = fallback_resources, count = 0; CONSP(string);
d554 1
a554 1
	for (string = fallback_resources, count = 0; CONSP(string);
d647 2
a648 2
	LispDestroy("%s: %ld does not fit in XtInputMask %ld",
		    STRFUN(builtin), (long)mask, (long)XtIMAll);
a802 2
    if (arguments == UNSPEC)
	arguments = NIL;
d810 1
a810 1
    if (arguments == NIL)
d881 1
a881 1
    for (list = arguments; CONSP(list); list = CDR(list)) {
d931 1
a931 1
	    object = CONS(CAR(list), STRING((char*)c8));
d933 1
a933 1
	    object = CONS(CAR(list), STRING((char*)c4));
@


