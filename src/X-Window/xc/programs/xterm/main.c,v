head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.5
	cvs-200410241530:1.1.1.5
	cvs-200410012000:1.1.1.5
	cvs-200407190955:1.1.1.5
	cvs-200407141120:1.1.1.5
	cvs-200406231010:1.1.1.4
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.11.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.11.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.41.12;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.46.22;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.06.23.11.44.54;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.07.14.12.19.21;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.29.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#ifndef lint
static char *rid="$Xorg: main.c,v 1.7 2001/02/09 02:06:02 xorgcvs Exp $";
#endif /* lint */

/*
 *				 W A R N I N G
 *
 * If you think you know what all of this code is doing, you are
 * probably very mistaken.  There be serious and nasty dragons here.
 *
 * This client is *not* to be taken as an example of how to write X
 * Toolkit applications.  It is in need of a substantial rewrite,
 * ideally to create a generic tty widget with several different parsing
 * widgets so that you can plug 'em together any way you want.  Don't
 * hold your breath, though....
 */

/***********************************************************

Copyright 2002 by Thomas E. Dickey

                        All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name(s) of the above copyright
holders shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without prior written
authorization.


Copyright 1987, 1988  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.


Copyright 1987, 1988 by Digital Equipment Corporation, Maynard.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be used in
advertising or publicity pertaining to distribution of the software
without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/* $XFree86: xc/programs/xterm/main.c,v 3.145 2002/01/07 18:35:41 dawes Exp $ */


/* main.c */

#include <version.h>
#include <xterm.h>

#include <X11/StringDefs.h>
#include <X11/Shell.h>
#include <X11/cursorfont.h>
#include <X11/Xlocale.h>

#if OPT_TOOLBAR
#include <X11/Xaw/Form.h>
#endif

#include <pwd.h>
#include <ctype.h>

#include <data.h>
#include <error.h>
#include <menu.h>
#include <main.h>
#include <xstrings.h>
#include <xterm_io.h>

#if OPT_WIDE_CHARS
#include <charclass.h>
#endif

#ifdef AMOEBA
#include <amoeba.h>
#include <cmdreg.h>
#include <stderr.h>
#include <thread.h>
#include <limits.h>
#include <module/proc.h>
#include <module/name.h>

#define NILCAP ((capability *)NULL)
#endif

#ifdef MINIX
#include <sys/nbio.h>

#define setpgrp(pid, pgid) setpgid(pid, pgid)
#define MNX_LASTLOG
#define WTMP
/* Remap or define non-existing termios flags */
#define OCRNL	0
#define ONLRET	0
#define NLDLY	0
#define CRDLY	0
#define TABDLY	0
#define BSDLY	0
#define VTDLY	0
#define FFDLY	0
#endif /* MINIX */

#ifdef __osf__
#define USE_SYSV_SIGNALS
#define WTMP
#endif

#ifdef USE_ISPTS_FLAG
static Bool IsPts = False;
#endif

#if defined(SCO) || defined(SVR4) || defined(_POSIX_SOURCE)
#define USE_POSIX_SIGNALS
#endif

#if defined(SYSV) && !defined(SVR4) && !defined(ISC22) && !defined(ISC30)
/* older SYSV systems cannot ignore SIGHUP.
   Shell hangs, or you get extra shells, or something like that */
#define USE_SYSV_SIGHUP
#endif

#if defined(sony) && defined(bsd43) && !defined(KANJI)
#define KANJI
#endif

#ifdef linux
#define USE_SYSV_PGRP
#define USE_SYSV_SIGNALS
#define WTMP
#ifdef __GLIBC__
#if (__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 1))
#include <pty.h>
#endif
#endif
#endif

#ifdef __MVS__
#define USE_SYSV_PGRP
#define USE_SYSV_SIGNALS
#endif

#ifdef __CYGWIN__
#define LASTLOG
#define WTMP
#endif

#ifdef SCO325
#define _SVID3
#endif

#ifdef __GNU__
#define USE_SYSV_PGRP
#define WTMP
#define HAS_BSD_GROUPS
#endif

#ifdef USE_TTY_GROUP
#include <grp.h>
#endif

#ifndef TTY_GROUP_NAME
#define TTY_GROUP_NAME "tty"
#endif

#include <sys/stat.h>

#ifdef Lynx
#ifndef BSDLY
#define BSDLY	0
#endif
#ifndef VTDLY
#define VTDLY	0
#endif
#ifndef FFDLY
#define FFDLY	0
#endif
#endif

#ifdef SYSV /* { */

#ifdef USE_USG_PTYS			/* AT&T SYSV has no ptyio.h */
#include <sys/stropts.h>		/* for I_PUSH */
#include <poll.h>			/* for POLLIN */
#endif /* USE_USG_PTYS */

#define USE_SYSV_SIGNALS
#define	USE_SYSV_PGRP

#if !defined(TIOCSWINSZ)
#define USE_SYSV_ENVVARS		/* COLUMNS/LINES vs. TERMCAP */
#endif

/*
 * now get system-specific includes
 */
#ifdef CRAY
#define HAS_BSD_GROUPS
#endif

#ifdef macII
#define HAS_BSD_GROUPS
#include <sys/ttychars.h>
#undef USE_SYSV_ENVVARS
#undef FIOCLEX
#undef FIONCLEX
#define setpgrp2 setpgrp
#include <sgtty.h>
#include <sys/resource.h>
#endif

#ifdef __hpux
#define HAS_BSD_GROUPS
#include <sys/ptyio.h>
#endif /* __hpux */

#ifdef __osf__
#define HAS_BSD_GROUPS
#undef  USE_SYSV_PGRP
#define setpgrp setpgid
#endif

#ifdef __sgi
#define HAS_BSD_GROUPS
#include <sys/sysmacros.h>
#endif /* __sgi */

#ifdef sun
#include <sys/strredir.h>
#endif

#else /* } !SYSV { */			/* BSD systems */

#ifndef MINIX /* { */

#ifdef __QNX__

#ifndef __QNXNTO__
#define ttyslot() 1
#else
#define USE_SYSV_PGRP
extern __inline__ ttyslot() {return 1;} /* yuk */
#endif

#else

#ifndef linux
#ifndef VMS
#ifndef USE_POSIX_TERMIOS
#ifndef USE_ANY_SYSV_TERMIO
#include <sgtty.h>
#endif
#endif /* USE_POSIX_TERMIOS */
#ifdef Lynx
#include <resource.h>
#else
#include <sys/resource.h>
#endif
#define HAS_BSD_GROUPS
#endif /* !VMS */
#endif /* !linux */

#endif /* __QNX__ */

#endif /* } MINIX */

#endif	/* } !SYSV */

#if defined(SVR4) && !defined(__CYGWIN__)
#define HAS_SAVED_IDS_AND_SETEUID
#endif

#ifdef linux
#define HAS_SAVED_IDS_AND_SETEUID
#endif

/* Xpoll.h and <sys/param.h> on glibc 2.1 systems have colliding NBBY's */
#if defined(__GLIBC__) && ((__GLIBC__ > 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ >= 1)))
#ifndef NOFILE
#define NOFILE OPEN_MAX
#endif
#elif !(defined(VMS) || defined(MINIX) || defined(WIN32) || defined(Lynx) || defined(__GNU__) || defined(__MVS__))
#include <sys/param.h>	/* for NOFILE */
#endif

#if defined(BSD) && (BSD >= 199103)
#define WTMP
#define HAS_SAVED_IDS_AND_SETEUID
#endif

#include <stdio.h>

#ifdef __hpux
#include <sys/utsname.h>
#endif /* __hpux */

#if defined(apollo) && (OSMAJORVERSION == 10) && (OSMINORVERSION < 4)
#define ttyslot() 1
#endif /* apollo */

#if defined(USE_UTEMPTER)

#include <utempter.h>

#elif defined(UTMPX_FOR_UTMP)

#include <utmpx.h>
#define setutent setutxent
#define getutid getutxid
#define endutent endutxent
#define pututline pututxline

#elif defined(HAVE_UTMP)

#include <utmp.h>
#if defined(_CRAY) && (OSMAJORVERSION < 8)
extern struct utmp *getutid __((struct utmp *_Id));
#endif

#endif

#if defined(USE_LASTLOG) && defined(HAVE_LASTLOG_H)
#include <lastlog.h>
#endif

#ifdef  PUCC_PTYD
#include <local/openpty.h>
#endif /* PUCC_PTYD */

#ifdef __OpenBSD__
#include <util.h>
#endif

#if !defined(UTMP_FILENAME)
#if defined(UTMP_FILE)
#define UTMP_FILENAME UTMP_FILE
#elif defined(_PATH_UTMP)
#define UTMP_FILENAME _PATH_UTMP
#else
#define UTMP_FILENAME "/etc/utmp"
#endif
#endif

#ifndef LASTLOG_FILENAME
#ifdef _PATH_LASTLOG
#define LASTLOG_FILENAME _PATH_LASTLOG
#else
#define LASTLOG_FILENAME "/usr/adm/lastlog"  /* only on BSD systems */
#endif
#endif

#if !defined(WTMP_FILENAME)
#if defined(WTMP_FILE)
#define WTMP_FILENAME WTMP_FILE
#elif defined(_PATH_WTMP)
#define WTMP_FILENAME _PATH_WTMP
#elif defined(SYSV)
#define WTMP_FILENAME "/etc/wtmp"
#else
#define WTMP_FILENAME "/usr/adm/wtmp"
#endif
#endif

#include <signal.h>

#if defined(sco) || (defined(ISC) && !defined(_POSIX_SOURCE))
#undef SIGTSTP			/* defined, but not the BSD way */
#endif

#ifdef SIGTSTP
#include <sys/wait.h>
#endif

#ifdef X_NOT_POSIX
extern long lseek();
#if defined(USG) || defined(SVR4)
extern unsigned sleep();
#else
extern void sleep();
#endif
extern char *ttyname();
#endif

#ifdef SYSV
extern char *ptsname(int);
#endif

#ifdef	__cplusplus
extern "C" {
#endif

extern int tgetent (char *ptr, char *name);
extern char *tgetstr (char *name, char **ptr);

#ifdef	__cplusplus
	}
#endif

#ifndef VMS
static SIGNAL_T reapchild (int n);
static int spawn (void);
static void remove_termcap_entry (char *buf, char *str);
#ifdef USE_PTY_SEARCH
static int pty_search (int *pty);
#endif
#endif /* ! VMS */

static void get_terminal (void);
static void resize (TScreen *s, char *oldtc, char *newtc);
static int get_pty (int *pty);
static void set_owner(char *device, int uid, int gid, int mode);

static Bool added_utmp_entry = False;

#ifdef __OpenBSD__
static gid_t utmpGid = -1;
#endif

#ifdef USE_SYSV_UTMP
static Bool xterm_exiting = False;
#endif

/*
** Ordinarily it should be okay to omit the assignment in the following
** statement. Apparently the c89 compiler on AIX 4.1.3 has a bug, or does
** it? Without the assignment though the compiler will init command_to_exec
** to 0xffffffff instead of NULL; and subsequent usage, e.g. in spawn() to
** SEGV.
*/
static char **command_to_exec = NULL;

#define TERMCAP_ERASE "kb"
#define VAL_INITIAL_ERASE A2E(8)

/* choose a nice default value for speed - if we make it too low, users who
 * mistakenly use $TERM set to vt100 will get padding delays
 */
#ifdef B38400	/* everyone should define this */
#define VAL_LINE_SPEED B38400
#else		/* ...but xterm's used this for a long time */
#define VAL_LINE_SPEED B9600
#endif

/* allow use of system default characters if defined and reasonable */
#ifndef CBRK
#define CBRK 0
#endif
#ifndef CDSUSP
#define CDSUSP CONTROL('Y')
#endif
#ifndef CEOF
#define CEOF CONTROL('D')
#endif
#ifndef CEOL
#define CEOL 0
#endif
#ifndef CFLUSH
#define CFLUSH CONTROL('O')
#endif
#ifndef CINTR
#define CINTR 0177
#endif
#ifndef CKILL
#define CKILL '@@'
#endif
#ifndef CLNEXT
#define CLNEXT CONTROL('V')
#endif
#ifndef CNUL
#define CNUL 0
#endif
#ifndef CQUIT
#define CQUIT CONTROL('\\')
#endif
#ifndef CRPRNT
#define CRPRNT CONTROL('R')
#endif
#ifndef CSTART
#define CSTART CONTROL('Q')
#endif
#ifndef CSTOP
#define CSTOP CONTROL('S')
#endif
#ifndef CSUSP
#define CSUSP CONTROL('Z')
#endif
#ifndef CSWTCH
#define CSWTCH 0
#endif
#ifndef CWERASE
#define CWERASE CONTROL('W')
#endif

#ifndef VMS
#ifdef USE_ANY_SYSV_TERMIO
/* The following structures are initialized in main() in order
** to eliminate any assumptions about the internal order of their
** contents.
*/
static struct termio d_tio;
#ifdef HAS_LTCHARS
static struct ltchars d_ltc;
#endif	/* HAS_LTCHARS */

#ifdef TIOCLSET
static unsigned int d_lmode;
#endif	/* TIOCLSET */

#elif defined(USE_POSIX_TERMIOS)
static struct termios d_tio;
#else /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
static struct  sgttyb d_sg = {
	0, 0, 0177, CKILL, EVENP|ODDP|ECHO|XTABS|CRMOD
};
static struct  tchars d_tc = {
	CINTR, CQUIT, CSTART,
	CSTOP, CEOF, CBRK
};
static struct  ltchars d_ltc = {
	CSUSP, CDSUSP, CRPRNT,
	CFLUSH, CWERASE, CLNEXT
};
static int d_disipline = NTTYDISC;
static long int d_lmode = LCRTBS|LCRTERA|LCRTKIL|LCTLECH;
#ifdef sony
static long int d_jmode = KM_SYSSJIS|KM_ASCII;
static struct jtchars d_jtc = {
	'J', 'B'
};
#endif /* sony */
#endif /* USE_ANY_SYSV_TERMIO */
#endif /* ! VMS */

/*
 * SYSV has the termio.c_cc[V] and ltchars; BSD has tchars and ltchars;
 * SVR4 has only termio.c_cc, but it includes everything from ltchars.
 * POSIX termios has termios.c_cc, which is similar to SVR4.
 */
static int override_tty_modes = 0;
struct _xttymodes {
    char *name;
    size_t len;
    int set;
    char value;
} ttymodelist[] = {
{ "intr", 4, 0, '\0' },			/* tchars.t_intrc ; VINTR */
#define XTTYMODE_intr 0
{ "quit", 4, 0, '\0' },			/* tchars.t_quitc ; VQUIT */
#define XTTYMODE_quit 1
{ "erase", 5, 0, '\0' },		/* sgttyb.sg_erase ; VERASE */
#define XTTYMODE_erase 2
{ "kill", 4, 0, '\0' },			/* sgttyb.sg_kill ; VKILL */
#define XTTYMODE_kill 3
{ "eof", 3, 0, '\0' },			/* tchars.t_eofc ; VEOF */
#define XTTYMODE_eof 4
{ "eol", 3, 0, '\0' },			/* VEOL */
#define XTTYMODE_eol 5
{ "swtch", 5, 0, '\0' },		/* VSWTCH */
#define XTTYMODE_swtch 6
{ "start", 5, 0, '\0' },		/* tchars.t_startc */
#define XTTYMODE_start 7
{ "stop", 4, 0, '\0' },			/* tchars.t_stopc */
#define XTTYMODE_stop 8
{ "brk", 3, 0, '\0' },			/* tchars.t_brkc */
#define XTTYMODE_brk 9
{ "susp", 4, 0, '\0' },			/* ltchars.t_suspc ; VSUSP */
#define XTTYMODE_susp 10
{ "dsusp", 5, 0, '\0' },		/* ltchars.t_dsuspc ; VDSUSP */
#define XTTYMODE_dsusp 11
{ "rprnt", 5, 0, '\0' },		/* ltchars.t_rprntc ; VREPRINT */
#define XTTYMODE_rprnt 12
{ "flush", 5, 0, '\0' },		/* ltchars.t_flushc ; VDISCARD */
#define XTTYMODE_flush 13
{ "weras", 5, 0, '\0' },		/* ltchars.t_werasc ; VWERASE */
#define XTTYMODE_weras 14
{ "lnext", 5, 0, '\0' },		/* ltchars.t_lnextc ; VLNEXT */
#define XTTYMODE_lnext 15
{ "status", 6, 0, '\0' },		/* VSTATUS */
#define XTTYMODE_status 16
{ NULL, 0, 0, '\0' },			/* end of data */
};

#define TMODE(ind,var) if (ttymodelist[ind].set) var = ttymodelist[ind].value

static int parse_tty_modes (char *s, struct _xttymodes *modelist);

#ifdef USE_SYSV_UTMP
#if (defined(AIXV3) && (OSMAJORVERSION < 4)) && !(defined(getutid))
extern struct utmp *getutid();
#endif /* AIXV3 */

#else	/* not USE_SYSV_UTMP */
static char etc_utmp[] = UTMP_FILENAME;
#endif	/* USE_SYSV_UTMP */

#ifdef USE_LASTLOG
static char etc_lastlog[] = LASTLOG_FILENAME;
#endif

#ifdef WTMP
static char etc_wtmp[] = WTMP_FILENAME;
#endif

/*
 * Some people with 4.3bsd /bin/login seem to like to use login -p -f user
 * to implement xterm -ls.  They can turn on USE_LOGIN_DASH_P and turn off
 * WTMP and USE_LASTLOG.
 */
#ifdef USE_LOGIN_DASH_P
#ifndef LOGIN_FILENAME
#define LOGIN_FILENAME "/bin/login"
#endif
static char bin_login[] = LOGIN_FILENAME;
#endif

static int inhibit;
static char passedPty[PTYCHARLEN + 1];	/* name if pty if slave */

#if defined(TIOCCONS) || defined(SRIOCSREDIR)
static int Console;
#include <X11/Xmu/SysUtil.h>	/* XmuGetHostname */
#define MIT_CONSOLE_LEN	12
#define MIT_CONSOLE "MIT_CONSOLE_"
static char mit_console_name[255 + MIT_CONSOLE_LEN + 1] = MIT_CONSOLE;
static Atom mit_console;
#endif	/* TIOCCONS */

#ifndef USE_SYSV_UTMP
static int tslot;
#endif	/* USE_SYSV_UTMP */
static sigjmp_buf env;

char *ProgramName;

static struct _resource {
    char *xterm_name;
    char *icon_geometry;
    char *title;
    char *icon_name;
    char *term_name;
    char *tty_modes;
    Boolean hold_screen;	/* true if we keep window open	*/
    Boolean utmpInhibit;
    Boolean messages;
    Boolean sunFunctionKeys;	/* %%% should be widget resource? */
#if OPT_SUNPC_KBD
    Boolean sunKeyboard;
#endif
#if OPT_HP_FUNC_KEYS
    Boolean hpFunctionKeys;
#endif
#if OPT_INITIAL_ERASE
    Boolean ptyInitialErase;	/* if true, use pty's sense of erase char */
    Boolean backarrow_is_erase;	/* override backspace/delete */
#endif
    Boolean wait_for_map;
    Boolean useInsertMode;
#if OPT_ZICONBEEP
    int zIconBeep;		/* beep level when output while iconified */
#endif
#if OPT_SAME_NAME
    Boolean sameName;		/* Don't change the title or icon name if it is
				 * the same.  This prevents flicker on the
				 * screen at the cost of an extra request to
				 * the server.
				 */
#endif
} resource;

/* used by VT (charproc.c) */

#define offset(field)	XtOffsetOf(struct _resource, field)

static XtResource application_resources[] = {
    {"name", "Name", XtRString, sizeof(char *),
	offset(xterm_name), XtRString, DFT_TERMTYPE},
    {"iconGeometry", "IconGeometry", XtRString, sizeof(char *),
	offset(icon_geometry), XtRString, (caddr_t) NULL},
    {XtNtitle, XtCTitle, XtRString, sizeof(char *),
	offset(title), XtRString, (caddr_t) NULL},
    {XtNiconName, XtCIconName, XtRString, sizeof(char *),
	offset(icon_name), XtRString, (caddr_t) NULL},
    {"termName", "TermName", XtRString, sizeof(char *),
	offset(term_name), XtRString, (caddr_t) NULL},
    {"ttyModes", "TtyModes", XtRString, sizeof(char *),
	offset(tty_modes), XtRString, (caddr_t) NULL},
    {"hold", "Hold", XtRBoolean, sizeof (Boolean),
	offset(hold_screen), XtRString, "false"},
    {"utmpInhibit", "UtmpInhibit", XtRBoolean, sizeof (Boolean),
	offset(utmpInhibit), XtRString, "false"},
    {"messages", "Messages", XtRBoolean, sizeof (Boolean),
	offset(messages), XtRString, "true"},
    {"sunFunctionKeys", "SunFunctionKeys", XtRBoolean, sizeof (Boolean),
	offset(sunFunctionKeys), XtRString, "false"},
#if OPT_SUNPC_KBD
    {"sunKeyboard", "SunKeyboard", XtRBoolean, sizeof (Boolean),
	offset(sunKeyboard), XtRString, "false"},
#endif
#if OPT_HP_FUNC_KEYS
    {"hpFunctionKeys", "HpFunctionKeys", XtRBoolean, sizeof (Boolean),
	offset(hpFunctionKeys), XtRString, "false"},
#endif
#if OPT_INITIAL_ERASE
    {"ptyInitialErase", "PtyInitialErase", XtRBoolean, sizeof (Boolean),
	offset(ptyInitialErase), XtRString, "false"},
    {"backarrowKeyIsErase", "BackarrowKeyIsErase", XtRBoolean, sizeof(Boolean),
	offset(backarrow_is_erase), XtRString, "false"},
#endif
    {"waitForMap", "WaitForMap", XtRBoolean, sizeof (Boolean),
	offset(wait_for_map), XtRString, "false"},
    {"useInsertMode", "UseInsertMode", XtRBoolean, sizeof (Boolean),
	offset(useInsertMode), XtRString, "false"},
#if OPT_ZICONBEEP
    {"zIconBeep", "ZIconBeep", XtRInt, sizeof (int),
	offset(zIconBeep), XtRImmediate, 0},
#endif
#if OPT_SAME_NAME
    {"sameName", "SameName", XtRBoolean, sizeof (Boolean),
	offset(sameName), XtRString, "true"},
#endif
};
#undef offset

static char *fallback_resources[] = {
    "*SimpleMenu*menuLabel.vertSpace: 100",
    "*SimpleMenu*HorizontalMargins: 16",
    "*SimpleMenu*Sme.height: 16",
    "*SimpleMenu*Cursor: left_ptr",
    "*mainMenu.Label:  Main Options (no app-defaults)",
    "*vtMenu.Label:  VT Options (no app-defaults)",
    "*fontMenu.Label:  VT Fonts (no app-defaults)",
#if OPT_TEK4014
    "*tekMenu.Label:  Tek Options (no app-defaults)",
#endif
    NULL
};

/* Command line options table.  Only resources are entered here...there is a
   pass over the remaining options after XrmParseCommand is let loose. */

static XrmOptionDescRec optionDescList[] = {
{"-geometry",	"*vt100.geometry",XrmoptionSepArg,	(caddr_t) NULL},
{"-132",	"*c132",	XrmoptionNoArg,		(caddr_t) "on"},
{"+132",	"*c132",	XrmoptionNoArg,		(caddr_t) "off"},
{"-ah",		"*alwaysHighlight", XrmoptionNoArg,	(caddr_t) "on"},
{"+ah",		"*alwaysHighlight", XrmoptionNoArg,	(caddr_t) "off"},
{"-aw",		"*autoWrap",	XrmoptionNoArg,		(caddr_t) "on"},
{"+aw",		"*autoWrap",	XrmoptionNoArg,		(caddr_t) "off"},
#ifndef NO_ACTIVE_ICON
{"-ai",		"*activeIcon",	XrmoptionNoArg,		(caddr_t) "off"},
{"+ai",		"*activeIcon",	XrmoptionNoArg,		(caddr_t) "on"},
#endif /* NO_ACTIVE_ICON */
{"-b",		"*internalBorder",XrmoptionSepArg,	(caddr_t) NULL},
{"-bc",		"*cursorBlink",	XrmoptionNoArg,		(caddr_t) "on"},
{"+bc",		"*cursorBlink",	XrmoptionNoArg,		(caddr_t) "off"},
{"-bcf",	"*cursorOffTime",XrmoptionSepArg,	(caddr_t) NULL},
{"-bcn",	"*cursorOnTime",XrmoptionSepArg,	(caddr_t) NULL},
{"-bdc",	"*colorBDMode",	XrmoptionNoArg,		(caddr_t) "off"},
{"+bdc",	"*colorBDMode",	XrmoptionNoArg,		(caddr_t) "on"},
{"-cb",		"*cutToBeginningOfLine", XrmoptionNoArg, (caddr_t) "off"},
{"+cb",		"*cutToBeginningOfLine", XrmoptionNoArg, (caddr_t) "on"},
{"-cc",		"*charClass",	XrmoptionSepArg,	(caddr_t) NULL},
{"-cm",		"*colorMode",	XrmoptionNoArg,		(caddr_t) "off"},
{"+cm",		"*colorMode",	XrmoptionNoArg,		(caddr_t) "on"},
{"-cn",		"*cutNewline",	XrmoptionNoArg,		(caddr_t) "off"},
{"+cn",		"*cutNewline",	XrmoptionNoArg,		(caddr_t) "on"},
{"-cr",		"*cursorColor",	XrmoptionSepArg,	(caddr_t) NULL},
{"-cu",		"*curses",	XrmoptionNoArg,		(caddr_t) "on"},
{"+cu",		"*curses",	XrmoptionNoArg,		(caddr_t) "off"},
{"-dc",		"*dynamicColors",XrmoptionNoArg,	(caddr_t) "off"},
{"+dc",		"*dynamicColors",XrmoptionNoArg,	(caddr_t) "on"},
{"-fb",		"*boldFont",	XrmoptionSepArg,	(caddr_t) NULL},
{"-fbb",	"*freeBoldBox", XrmoptionNoArg,		(caddr_t)"off"},
{"+fbb",	"*freeBoldBox", XrmoptionNoArg,		(caddr_t)"on"},
{"-fbx",	"*forceBoxChars", XrmoptionNoArg,	(caddr_t)"off"},
{"+fbx",	"*forceBoxChars", XrmoptionNoArg,	(caddr_t)"on"},
#ifndef NO_ACTIVE_ICON
{"-fi",		"*iconFont",	XrmoptionSepArg,	(caddr_t) NULL},
#endif /* NO_ACTIVE_ICON */
#ifdef XRENDERFONT
{"-fa",		"*faceName",	XrmoptionSepArg,	(caddr_t) NULL},
{"-fs",		"*faceSize",	XrmoptionSepArg,	(caddr_t) NULL},
#endif
#if OPT_WIDE_CHARS
{"-fw",		"*wideFont",	XrmoptionSepArg,	(caddr_t) NULL},
{"-fwb",	"*wideBoldFont", XrmoptionSepArg,	(caddr_t) NULL},
#endif
#if OPT_INPUT_METHOD
{"-fx",		"*ximFont",	XrmoptionSepArg,	(caddr_t) NULL},
#endif
#if OPT_HIGHLIGHT_COLOR
{"-hc",		"*highlightColor", XrmoptionSepArg,	(caddr_t) NULL},
#endif
#if OPT_HP_FUNC_KEYS
{"-hf",		"*hpFunctionKeys",XrmoptionNoArg,	(caddr_t) "on"},
{"+hf",		"*hpFunctionKeys",XrmoptionNoArg,	(caddr_t) "off"},
#endif
{"-hold",	"*hold",	XrmoptionNoArg,		(caddr_t) "on"},
{"+hold",	"*hold",	XrmoptionNoArg,		(caddr_t) "off"},
#if OPT_INITIAL_ERASE
{"-ie",		"*ptyInitialErase", XrmoptionNoArg,	(caddr_t) "on"},
{"+ie",		"*ptyInitialErase", XrmoptionNoArg,	(caddr_t) "off"},
#endif
{"-j",		"*jumpScroll",	XrmoptionNoArg,		(caddr_t) "on"},
{"+j",		"*jumpScroll",	XrmoptionNoArg,		(caddr_t) "off"},
/* parse logging options anyway for compatibility */
{"-l",		"*logging",	XrmoptionNoArg,		(caddr_t) "on"},
{"+l",		"*logging",	XrmoptionNoArg,		(caddr_t) "off"},
{"-lf",		"*logFile",	XrmoptionSepArg,	(caddr_t) NULL},
{"-ls",		"*loginShell",	XrmoptionNoArg,		(caddr_t) "on"},
{"+ls",		"*loginShell",	XrmoptionNoArg,		(caddr_t) "off"},
{"-mb",		"*marginBell",	XrmoptionNoArg,		(caddr_t) "on"},
{"+mb",		"*marginBell",	XrmoptionNoArg,		(caddr_t) "off"},
{"-mc",		"*multiClickTime", XrmoptionSepArg,	(caddr_t) NULL},
{"-mesg",	"*messages",	XrmoptionNoArg,		(caddr_t) "off"},
{"+mesg",	"*messages",	XrmoptionNoArg,		(caddr_t) "on"},
{"-ms",		"*pointerColor",XrmoptionSepArg,	(caddr_t) NULL},
{"-nb",		"*nMarginBell",	XrmoptionSepArg,	(caddr_t) NULL},
{"-nul",	"*underLine",	XrmoptionNoArg,		(caddr_t) "off"},
{"+nul",	"*underLine",	XrmoptionNoArg,		(caddr_t) "on"},
{"-pc",		"*boldColors",	XrmoptionNoArg,		(caddr_t) "on"},
{"+pc",		"*boldColors",	XrmoptionNoArg,		(caddr_t) "off"},
{"-rw",		"*reverseWrap",	XrmoptionNoArg,		(caddr_t) "on"},
{"+rw",		"*reverseWrap",	XrmoptionNoArg,		(caddr_t) "off"},
{"-s",		"*multiScroll",	XrmoptionNoArg,		(caddr_t) "on"},
{"+s",		"*multiScroll",	XrmoptionNoArg,		(caddr_t) "off"},
{"-sb",		"*scrollBar",	XrmoptionNoArg,		(caddr_t) "on"},
{"+sb",		"*scrollBar",	XrmoptionNoArg,		(caddr_t) "off"},
#ifdef SCROLLBAR_RIGHT
{"-leftbar",	"*rightScrollBar", XrmoptionNoArg,	(caddr_t) "off"},
{"-rightbar",	"*rightScrollBar", XrmoptionNoArg,	(caddr_t) "on"},
#endif
{"-rvc",	"*colorRVMode",	XrmoptionNoArg,		(caddr_t) "off"},
{"+rvc",	"*colorRVMode",	XrmoptionNoArg,		(caddr_t) "on"},
{"-sf",		"*sunFunctionKeys", XrmoptionNoArg,	(caddr_t) "on"},
{"+sf",		"*sunFunctionKeys", XrmoptionNoArg,	(caddr_t) "off"},
{"-si",		"*scrollTtyOutput", XrmoptionNoArg,	(caddr_t) "off"},
{"+si",		"*scrollTtyOutput", XrmoptionNoArg,	(caddr_t) "on"},
{"-sk",		"*scrollKey",	XrmoptionNoArg,		(caddr_t) "on"},
{"+sk",		"*scrollKey",	XrmoptionNoArg,		(caddr_t) "off"},
{"-sl",		"*saveLines",	XrmoptionSepArg,	(caddr_t) NULL},
#if OPT_SUNPC_KBD
{"-sp",		"*sunKeyboard", XrmoptionNoArg,		(caddr_t) "on"},
{"+sp",		"*sunKeyboard", XrmoptionNoArg,		(caddr_t) "off"},
#endif
{"-t",		"*tekStartup",	XrmoptionNoArg,		(caddr_t) "on"},
{"+t",		"*tekStartup",	XrmoptionNoArg,		(caddr_t) "off"},
{"-ti",		"*decTerminalID",XrmoptionSepArg,	(caddr_t) NULL},
{"-tm",		"*ttyModes",	XrmoptionSepArg,	(caddr_t) NULL},
{"-tn",		"*termName",	XrmoptionSepArg,	(caddr_t) NULL},
#if OPT_WIDE_CHARS
{"-u8",		"*utf8",	XrmoptionNoArg,		(caddr_t) "2"},
{"+u8",		"*utf8",	XrmoptionNoArg,		(caddr_t) "0"},
#endif
{"-ulc",	"*colorULMode",	XrmoptionNoArg,		(caddr_t) "off"},
{"+ulc",	"*colorULMode",	XrmoptionNoArg,		(caddr_t) "on"},
{"-ut",		"*utmpInhibit",	XrmoptionNoArg,		(caddr_t) "on"},
{"+ut",		"*utmpInhibit",	XrmoptionNoArg,		(caddr_t) "off"},
{"-im",		"*useInsertMode", XrmoptionNoArg,	(caddr_t) "on"},
{"+im",		"*useInsertMode", XrmoptionNoArg,	(caddr_t) "off"},
{"-vb",		"*visualBell",	XrmoptionNoArg,		(caddr_t) "on"},
{"+vb",		"*visualBell",	XrmoptionNoArg,		(caddr_t) "off"},
{"-pob",	"*popOnBell",	XrmoptionNoArg,		(caddr_t) "on"},
{"+pob",	"*popOnBell",	XrmoptionNoArg,		(caddr_t) "off"},
#if OPT_WIDE_CHARS
{"-wc",		"*wideChars",	XrmoptionNoArg,		(caddr_t) "on"},
{"+wc",		"*wideChars",	XrmoptionNoArg,		(caddr_t) "off"},
#endif
{"-wf",		"*waitForMap",	XrmoptionNoArg,		(caddr_t) "on"},
{"+wf",		"*waitForMap",	XrmoptionNoArg,		(caddr_t) "off"},
#if OPT_ZICONBEEP
{"-ziconbeep",  "*zIconBeep",   XrmoptionSepArg,        (caddr_t) NULL},
#endif
#if OPT_SAME_NAME
{"-samename",	"*sameName",	XrmoptionNoArg,		(caddr_t) "on"},
{"+samename",	"*sameName",	XrmoptionNoArg,		(caddr_t) "off"},
#endif
/* options that we process ourselves */
{"-help",	NULL,		XrmoptionSkipNArgs,	(caddr_t) NULL},
{"-version",	NULL,		XrmoptionSkipNArgs,	(caddr_t) NULL},
{"-class",	NULL,		XrmoptionSkipArg,	(caddr_t) NULL},
{"-e",		NULL,		XrmoptionSkipLine,	(caddr_t) NULL},
/* bogus old compatibility stuff for which there are
   standard XtAppInitialize options now */
{"%",		"*tekGeometry",	XrmoptionStickyArg,	(caddr_t) NULL},
{"#",		".iconGeometry",XrmoptionStickyArg,	(caddr_t) NULL},
{"-T",		".title",	XrmoptionSepArg,	(caddr_t) NULL},
{"-n",		"*iconName",	XrmoptionSepArg,	(caddr_t) NULL},
{"-r",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "on"},
{"+r",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "off"},
{"-rv",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "on"},
{"+rv",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "off"},
{"-w",		".borderWidth", XrmoptionSepArg,	(caddr_t) NULL},
};

static OptionHelp options[] = {
{ "-version",              "print the version number" },
{ "-help",                 "print out this message" },
{ "-display displayname",  "X server to contact" },
{ "-geometry geom",        "size (in characters) and position" },
{ "-/+rv",                 "turn on/off reverse video" },
{ "-bg color",             "background color" },
{ "-fg color",             "foreground color" },
{ "-bd color",             "border color" },
{ "-bw number",            "border width in pixels" },
{ "-fn fontname",          "normal text font" },
{ "-fb fontname",          "bold text font" },
{ "-/+fbb",                "turn on/off bold font's box checking"},
{ "-/+fbx",                "turn off/on linedrawing characters"},
#ifdef XRENDERFONT
{ "-fa pattern",           "FreeType font-selection pattern" },
{ "-fs size",              "FreeType font-size" },
#endif
#if OPT_WIDE_CHARS
{ "-fw fontname",          "doublewidth text font" },
{ "-fwb fontname",         "doublewidth bold text font" },
#endif
#if OPT_INPUT_METHOD
{ "-fx fontname",          "XIM fontset" },
#endif
{ "-iconic",               "start iconic" },
{ "-name string",          "client instance, icon, and title strings" },
{ "-class string",         "class string (XTerm)" },
{ "-title string",         "title string" },
{ "-xrm resourcestring",   "additional resource specifications" },
{ "-/+132",                "turn on/off column switch inhibiting" },
{ "-/+ah",                 "turn on/off always highlight" },
#ifndef NO_ACTIVE_ICON
{ "-/+ai",                 "turn on/off active icon" },
{ "-fi fontname",          "icon font for active icon" },
#endif /* NO_ACTIVE_ICON */
{ "-b number",             "internal border in pixels" },
{ "-/+bc",		   "turn on/off text cursor blinking" },
{ "-bcf milliseconds",     "time text cursor is off when blinking"},
{ "-bcn milliseconds",     "time text cursor is on when blinking"},
{ "-/+bdc",                "turn off/on display of bold as color"},
{ "-/+cb",                 "turn on/off cut-to-beginning-of-line inhibit" },
{ "-cc classrange",        "specify additional character classes" },
{ "-/+cm",                 "turn off/on ANSI color mode" },
{ "-/+cn",                 "turn on/off cut newline inhibit" },
{ "-cr color",             "text cursor color" },
{ "-/+cu",                 "turn on/off curses emulation" },
{ "-/+dc",		   "turn off/on dynamic color selection" },
#if OPT_HIGHLIGHT_COLOR
{ "-hc",                   "selection background color" },
#endif
#if OPT_HP_FUNC_KEYS
{ "-/+hf",                 "turn on/off HP Function Key escape codes" },
#endif
{ "-/+hold",		   "turn on/off logic that retains window after exit" },
#if OPT_INITIAL_ERASE
{ "-/+ie",		   "turn on/off initialization of 'erase' from pty" },
#endif
{ "-/+im",		   "use insert mode for TERMCAP" },
{ "-/+j",                  "turn on/off jump scroll" },
#ifdef ALLOWLOGGING
{ "-/+l",                  "turn on/off logging" },
{ "-lf filename",          "logging filename" },
#else
{ "-/+l",                  "turn on/off logging (not supported)" },
{ "-lf filename",          "logging filename (not supported)" },
#endif
{ "-/+ls",                 "turn on/off login shell" },
{ "-/+mb",                 "turn on/off margin bell" },
{ "-mc milliseconds",      "multiclick time in milliseconds" },
{ "-/+mesg",		   "forbid/allow messages" },
{ "-ms color",             "pointer color" },
{ "-nb number",            "margin bell in characters from right end" },
{ "-/+nul",                "turn on/off display of underlining" },
{ "-/+aw",                 "turn on/off auto wraparound" },
{ "-/+pc",                 "turn on/off PC-style bold colors" },
{ "-/+rw",                 "turn on/off reverse wraparound" },
{ "-/+s",                  "turn on/off multiscroll" },
{ "-/+sb",                 "turn on/off scrollbar" },
#ifdef SCROLLBAR_RIGHT
{ "-rightbar",             "force scrollbar right (default left)" },
{ "-leftbar",              "force scrollbar left" },
#endif
{ "-/+rvc",		   "turn off/on display of reverse as color" },
{ "-/+sf",                 "turn on/off Sun Function Key escape codes" },
{ "-/+si",                 "turn on/off scroll-on-tty-output inhibit" },
{ "-/+sk",                 "turn on/off scroll-on-keypress" },
{ "-sl number",            "number of scrolled lines to save" },
#if OPT_SUNPC_KBD
{ "-/+sp",                 "turn on/off Sun/PC Function/Keypad mapping" },
#endif
#if OPT_TEK4014
{ "-/+t",                  "turn on/off Tek emulation window" },
#endif
{ "-ti termid",            "terminal identifier" },
{ "-tm string",            "terminal mode keywords and characters" },
{ "-tn name",              "TERM environment variable name" },
#if OPT_WIDE_CHARS
{ "-/+u8",                 "turn on/off UTF-8 mode (implies wide-characters)" },
#endif
{ "-/+ulc",                "turn off/on display of underline as color" },
#ifdef HAVE_UTMP
{ "-/+ut",                 "turn on/off utmp inhibit" },
#else
{ "-/+ut",                 "turn on/off utmp inhibit (not supported)" },
#endif
{ "-/+vb",                 "turn on/off visual bell" },
{ "-/+pob",                "turn on/off pop on bell" },
#if OPT_WIDE_CHARS
{ "-/+wc",                 "turn on/off wide-character mode" },
#endif
{ "-/+wf",                 "turn on/off wait for map before command exec" },
{ "-e command args ...",   "command to execute" },
#if OPT_TEK4014
{ "%geom",                 "Tek window geometry" },
#endif
{ "#geom",                 "icon window geometry" },
{ "-T string",             "title name for window" },
{ "-n string",             "icon name for window" },
#if defined(TIOCCONS) || defined(SRIOCSREDIR)
{ "-C",                    "intercept console messages" },
#else
{ "-C",                    "intercept console messages (not supported)" },
#endif
{ "-Sccn",                 "slave mode on \"ttycc\", file descriptor \"n\"" },
#if OPT_ZICONBEEP
{ "-ziconbeep percent",    "beep and flag icon of window having hidden output" },
#endif
#if OPT_SAME_NAME
{ "-/+samename",           "turn on/off the no-flicker option for title and icon name" },
#endif
{ NULL, NULL }};

static char *message[] = {
"Fonts should be fixed width and, if both normal and bold are specified, should",
"have the same size.  If only a normal font is specified, it will be used for",
"both normal and bold text (by doing overstriking).  The -e option, if given,",
"must appear at the end of the command line, otherwise the user's default shell",
"will be started.  Options that start with a plus sign (+) restore the default.",
NULL};

/*
 * Decode a key-definition.  This combines the termcap and ttyModes, for
 * comparison.  Note that octal escapes in ttyModes are done by the normal
 * resource translation.  Also, ttyModes allows '^-' as a synonym for disabled.
 */
static int decode_keyvalue(char *string, int termcap)
{
    int value = -1;

    TRACE(("...decode '%s'\n", string));
    if (*string == '^') {
	switch (*++string) {
	case '?':
	    value = A2E(127);
	    break;
	case '-':
	    if (!termcap) {
		errno = 0;
#if defined(_POSIX_VDISABLE) && defined(HAVE_UNISTD_H)
		value = _POSIX_VDISABLE;
#endif
#if defined(_PC_VDISABLE)
		if (value == -1) {
		    value = fpathconf(0, _PC_VDISABLE);
		    if (value == -1) {
			if (errno != 0)
			    break;	/* skip this (error) */
			value = 0377;
		    }
		}
#elif defined(VDISABLE)
		if (value == -1)
		    value = VDISABLE;
#endif
		break;
	    }
	    /* FALLTHRU */
	default:
	    value = CONTROL(*string);
	    break;
	}
    } else if (termcap && (*string == '\\')) {
	char *d;
	int temp = strtol(string, &d, 8);
	if (temp > 0 && d != string)
	    value = temp;
    } else {
	value = CharOf(*string);
    }
    return value;
}

/*
 * If we're linked to terminfo, tgetent() will return an empty buffer.  We
 * cannot use that to adjust the $TERMCAP variable.
 */
static Boolean get_termcap(char *name, char *buffer, char *resized)
{
    register TScreen *screen = &term->screen;

    *buffer = 0;	/* initialize, in case we're using terminfo's tgetent */

    if (name != 0) {
	if (tgetent (buffer, name) == 1) {
	    TRACE(("get_termcap(%s) succeeded (%s)\n", name,
	    	*buffer
		? "ok:termcap, we can update $TERMCAP"
		: "assuming this is terminfo"));
	    if (*buffer) {
		if (!TEK4014_ACTIVE(screen)) {
		    resize (screen, buffer, resized);
		}
	    }
	    return True;
	} else {
	    *buffer = 0;	/* just in case */
	}
    }
    return False;
}

static int abbrev (char *tst, char *cmp, size_t need)
{
	size_t len = strlen(tst);
	return ((len >= need) && (!strncmp(tst, cmp, len)));
}

static void Syntax (char *badOption)
{
    OptionHelp *opt;
    int col;

    fprintf (stderr, "%s:  bad command line option \"%s\"\r\n\n",
	     ProgramName, badOption);

    fprintf (stderr, "usage:  %s", ProgramName);
    col = 8 + strlen(ProgramName);
    for (opt = options; opt->opt; opt++) {
	int len = 3 + strlen(opt->opt);	 /* space [ string ] */
	if (col + len > 79) {
	    fprintf (stderr, "\r\n   ");  /* 3 spaces */
	    col = 3;
	}
	fprintf (stderr, " [%s]", opt->opt);
	col += len;
    }

    fprintf (stderr, "\r\n\nType %s -help for a full description.\r\n\n",
	     ProgramName);
    exit (1);
}

static void Version (void)
{
    printf("%s(%d)\n", XFREE86_VERSION, XTERM_PATCH);
    fflush(stdout);
}

static void Help (void)
{
    OptionHelp *opt;
    char **cpp;

    fprintf (stderr, "%s(%d) usage:\n    %s [-options ...] [-e command args]\n\n",
	     XFREE86_VERSION, XTERM_PATCH, ProgramName);
    fprintf (stderr, "where options include:\n");
    for (opt = options; opt->opt; opt++) {
	fprintf (stderr, "    %-28s %s\n", opt->opt, opt->desc);
    }

    putc ('\n', stderr);
    for (cpp = message; *cpp; cpp++) {
	fputs (*cpp, stderr);
	putc ('\n', stderr);
    }
    putc ('\n', stderr);
    fflush(stderr);
}

#if defined(TIOCCONS) || defined(SRIOCSREDIR)
/* ARGSUSED */
static Boolean
ConvertConsoleSelection(
	Widget w GCC_UNUSED,
	Atom *selection GCC_UNUSED,
	Atom *target GCC_UNUSED,
	Atom *type GCC_UNUSED,
	XtPointer *value GCC_UNUSED,
	unsigned long *length GCC_UNUSED,
	int *format GCC_UNUSED)
{
    /* we don't save console output, so can't offer it */
    return False;
}
#endif /* TIOCCONS */

Arg ourTopLevelShellArgs[] = {
	{ XtNallowShellResize, (XtArgVal) TRUE },
	{ XtNinput, (XtArgVal) TRUE },
};
int number_ourTopLevelShellArgs = 2;

Bool waiting_for_initial_map;

/*
 * DeleteWindow(): Action proc to implement ICCCM delete_window.
 */
/* ARGSUSED */
static void
DeleteWindow(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params GCC_UNUSED,
	Cardinal *num_params GCC_UNUSED)
{
#if OPT_TEK4014
  if (w == toplevel) {
    if (term->screen.Tshow)
      hide_vt_window();
    else
      do_hangup(w, (XtPointer)0, (XtPointer)0);
  } else
    if (term->screen.Vshow)
      hide_tek_window();
    else
#endif
      do_hangup(w, (XtPointer)0, (XtPointer)0);
}

/* ARGSUSED */
static void
KeyboardMapping(
	Widget w GCC_UNUSED,
	XEvent *event,
	String *params GCC_UNUSED,
	Cardinal *num_params GCC_UNUSED)
{
    switch (event->type) {
       case MappingNotify:
	  XRefreshKeyboardMapping(&event->xmapping);
	  break;
    }
}

XtActionsRec actionProcs[] = {
    { "DeleteWindow", DeleteWindow },
    { "KeyboardMapping", KeyboardMapping },
};

Atom wm_delete_window;

/*
 * Some platforms use names such as /dev/tty01, others /dev/pts/1.  Parse off
 * the "tty01" or "pts/1" portion, and return that for use as an identifier for
 * utmp.
 */
static char *
my_pty_name(char *device)
{
	size_t len = strlen(device);
	Boolean name = False;

	while (len != 0) {
		int ch = device[len-1];
		if (isdigit(ch)) {
			len--;
		} else if (ch == '/') {
			if (name)
				break;
			len--;
		} else if (isalpha(ch)) {
			name = True;
			len--;
		} else {
			break;
		}
	}
	TRACE(("my_pty_name(%s) -> '%s'\n", device, device + len));
	return device + len;
}

/*
 * If the name contains a '/', it is a "pts/1" case.  Otherwise, return the
 * last few characters for a utmp identifier.
 */
static char *
my_pty_id(char *device)
{
	char *name = my_pty_name(device);
	char *leaf = x_basename(name);

	if (name == leaf) {	/* no '/' in the name */
		int len = strlen(leaf);
		if (PTYCHARLEN < len)
			leaf = leaf + (len - PTYCHARLEN);
	}
	TRACE(("my_pty_id  (%s) -> '%s'\n", device, leaf));
	return leaf;
}

/*
 * Set the tty/pty identifier
 */
static void
set_pty_id(char *device, char *id)
{
	char *name = my_pty_name(device);
	char *leaf = x_basename(name);

	if (name == leaf) {
		strcpy(my_pty_id(device), id);
	} else {
		strcpy(leaf, id);
	}
	TRACE(("set_pty_id(%s) -> '%s'\n", id, device));
}

/*
 * The original -S option accepts two characters to identify the pty, and a
 * file-descriptor (assumed to be nonzero).  That is not general enough, so we
 * check first if the option contains a '/' to delimit the two fields, and if
 * not, fall-thru to the original logic.
 */
static Boolean
ParseSccn(char *option)
{
	char *leaf = x_basename(option);
	Boolean code = False;

	if (leaf != option) {
		if (leaf - option > 1
		 && leaf - option <= PTYCHARLEN
		 && sscanf(leaf, "%d", &am_slave) == 1) {
			size_t len = leaf - option - 1;
			/*
			 * If the given length is less than PTYCHARLEN, that is
			 * all right because the calling application may be
			 * giving us a path for /dev/pts, which would be
			 * followed by one or more decimal digits.
			 *
			 * For fixed-width fields, it is up to the calling
			 * application to provide leading 0's, if needed.
			 */
			strncpy(passedPty, option, len);
			passedPty[len] = 0;
			code = True;
		}
	} else {
		code = (sscanf(option, "%c%c%d",
			passedPty, passedPty+1, &am_slave) == 3);
	}
	TRACE(("ParseSccn(%s) = '%s' %d (%s)\n", option,
		passedPty, am_slave, code ? "OK" : "ERR"));
	return code;
}

#ifdef USE_SYSV_UTMP
/*
 * From "man utmp":
 * xterm and other terminal emulators directly create a USER_PROCESS record
 * and generate the ut_id by using the last two letters of /dev/ttyp%c or by
 * using p%d for /dev/pts/%d.  If they find a DEAD_PROCESS for this id, they
 * recycle it, otherwise they create a new entry.  If they can, they will mark
 * it as DEAD_PROCESS on exiting and it is advised that they null ut_line,
 * ut_time, ut_user and ut_host as well.
 *
 * Generally ut_id allows no more than 3 characters (plus null), even if the
 * pty implementation allows more than 3 digits.   
 */
static char *
my_utmp_id(char *device)
{
	static char result[PTYCHARLEN + 4];
	char *name = my_pty_name(device);
	char *leaf = x_basename(name);

	if (name == leaf) {	/* no '/' in the name */
		int len = strlen(leaf);
		if (PTYCHARLEN < len)
			leaf = leaf + (len - PTYCHARLEN);
		strcpy(result, leaf);
	} else {
		sprintf(result, "p%s", leaf);
	}
	TRACE(("my_utmp_id  (%s) -> '%s'\n", device, result));
	return result;
}
#endif

#ifdef USE_POSIX_SIGNALS

typedef void (*sigfunc)(int);

/* make sure we sure we ignore SIGCHLD for the cases parent 
   has just been stopped and not actually killed */

static sigfunc
posix_signal(int signo, sigfunc func)
{
	struct sigaction act, oact;

	act.sa_handler = func;
	sigemptyset(&act.sa_mask);
#ifdef SA_RESTART
	act.sa_flags = SA_NOCLDSTOP|SA_RESTART;
#else
	act.sa_flags = SA_NOCLDSTOP;
#endif
	if (sigaction(signo, &act, &oact) < 0)
		return(SIG_ERR);
	return (oact.sa_handler);
}

#endif /* linux && _POSIX_SOURCE */

int
main (int argc, char *argv[])
{
	Widget form_top, menu_top;
	register TScreen *screen;
	int mode;
	char *my_class = DEFCLASS;

	ProgramName = argv[0];

#ifndef AMOEBA
	/* extra length in case longer tty name like /dev/ttyq255 */
	ttydev = (char *) malloc (sizeof(TTYDEV) + 80);
#ifdef USE_PTY_DEVICE
	ptydev = (char *) malloc (sizeof(PTYDEV) + 80);
	if (!ttydev || !ptydev)
#else
	if (!ttydev)
#endif
	{
	    fprintf (stderr,
		     "%s: unable to allocate memory for ttydev or ptydev\n",
		     ProgramName);
	    exit (1);
	}
	strcpy (ttydev, TTYDEV);
#ifdef USE_PTY_DEVICE
	strcpy (ptydev, PTYDEV);
#endif

#ifdef __OpenBSD__
	get_pty(NULL);
	seteuid(getuid());
	setuid(getuid());
#endif /* __OpenBSD__ */

	/* Do these first, since we may not be able to open the display */
	TRACE_OPTS(options, optionDescList, XtNumber(optionDescList));
	TRACE_ARGV("Before XtAppInitialize", argv);
	if (argc > 1) {
		int n;
		int unique = 2;
		Boolean quit = True;

		for (n = 1; n < argc; n++) {
			TRACE(("parsing %s\n", argv[n]));
			if (abbrev(argv[n], "-version", unique)) {
				Version();
			} else if (abbrev(argv[n], "-help", unique)) {
				Help();
			} else if (abbrev(argv[n], "-class", 3)) {
				if ((my_class = argv[++n]) == 0) {
					Help();
				} else {
					quit = False;
				}
				unique = 3;
			} else {
				quit = False;
				unique = 3;
			}
		}
		if (quit)
			exit(0);
	}

	/* This dumps core on HP-UX 9.05 with X11R5 */
#if OPT_I18N_SUPPORT
	XtSetLanguageProc (NULL, NULL, NULL);
#endif

#ifdef MINIX
	d_tio.c_iflag= TINPUT_DEF;
	d_tio.c_oflag= TOUTPUT_DEF;
	d_tio.c_cflag= TCTRL_DEF;
	d_tio.c_lflag= TLOCAL_DEF;
	cfsetispeed(&d_tio, TSPEED_DEF);
	cfsetispeed(&d_tio, TSPEED_DEF);
	d_tio.c_cc[VEOF]= TEOF_DEF;
	d_tio.c_cc[VEOL]= TEOL_DEF;
	d_tio.c_cc[VERASE]= TERASE_DEF;
	d_tio.c_cc[VINTR]= TINTR_DEF;
	d_tio.c_cc[VKILL]= TKILL_DEF;
	d_tio.c_cc[VMIN]= TMIN_DEF;
	d_tio.c_cc[VQUIT]= TQUIT_DEF;
	d_tio.c_cc[VTIME]= TTIME_DEF;
	d_tio.c_cc[VSUSP]= TSUSP_DEF;
	d_tio.c_cc[VSTART]= TSTART_DEF;
	d_tio.c_cc[VSTOP]= TSTOP_DEF;
	d_tio.c_cc[VREPRINT]= TREPRINT_DEF;
	d_tio.c_cc[VLNEXT]= TLNEXT_DEF;
	d_tio.c_cc[VDISCARD]= TDISCARD_DEF;
#elif defined(USE_ANY_SYSV_TERMIO) || defined(USE_POSIX_TERMIOS) /* { */
	/* Initialization is done here rather than above in order
	** to prevent any assumptions about the order of the contents
	** of the various terminal structures (which may change from
	** implementation to implementation).
	*/
	d_tio.c_iflag = ICRNL|IXON;
#ifdef TAB3
	d_tio.c_oflag = OPOST|ONLCR|TAB3;
#else
#ifdef ONLCR
	d_tio.c_oflag = OPOST|ONLCR;
#else
	d_tio.c_oflag = OPOST;
#endif
#endif
#if defined(macII) || defined(ATT) || defined(CRAY) /* { */
	d_tio.c_cflag = VAL_LINE_SPEED|CS8|CREAD|PARENB|HUPCL;
	d_tio.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK;
#ifdef ECHOKE
	d_tio.c_lflag |= ECHOKE|IEXTEN;
#endif
#ifdef ECHOCTL
	d_tio.c_lflag |= ECHOCTL|IEXTEN;
#endif

#ifndef USE_TERMIOS /* { */
	d_tio.c_line = 0;
#endif /* } */

	d_tio.c_cc[VINTR] = CINTR;
	d_tio.c_cc[VQUIT] = CQUIT;
	d_tio.c_cc[VERASE] = CERASE;
	d_tio.c_cc[VKILL] = CKILL;
	d_tio.c_cc[VEOF] = CEOF;
	d_tio.c_cc[VEOL] = CNUL;
	d_tio.c_cc[VEOL2] = CNUL;
#ifdef VSWTCH
	d_tio.c_cc[VSWTCH] = CNUL;
#endif

#if defined(USE_TERMIOS) || defined(USE_POSIX_TERMIOS) /* { */
	d_tio.c_cc[VSUSP] = CSUSP;
#ifdef VDSUSP
	d_tio.c_cc[VDSUSP] = CDSUSP;
#endif
	d_tio.c_cc[VREPRINT] = CRPRNT;
	d_tio.c_cc[VDISCARD] = CFLUSH;
	d_tio.c_cc[VWERASE] = CWERASE;
	d_tio.c_cc[VLNEXT] = CLNEXT;
	d_tio.c_cc[VMIN] = 1;
	d_tio.c_cc[VTIME] = 0;
#endif /* } */
#ifdef HAS_LTCHARS /* { */
	d_ltc.t_suspc = CSUSP;		/* t_suspc */
	d_ltc.t_dsuspc = CDSUSP;	/* t_dsuspc */
	d_ltc.t_rprntc = CRPRNT;
	d_ltc.t_flushc = CFLUSH;
	d_ltc.t_werasc = CWERASE;
	d_ltc.t_lnextc = CLNEXT;
#endif /* } HAS_LTCHARS */
#ifdef TIOCLSET /* { */
	d_lmode = 0;
#endif /* } TIOCLSET */
#else  /* }{ else !macII, ATT, CRAY */
#ifndef USE_POSIX_TERMIOS
#ifdef BAUD_0 /* { */
	d_tio.c_cflag = CS8|CREAD|PARENB|HUPCL;
#else	/* }{ !BAUD_0 */
	d_tio.c_cflag = VAL_LINE_SPEED|CS8|CREAD|PARENB|HUPCL;
#endif	/* } !BAUD_0 */
#else /* USE_POSIX_TERMIOS */
	d_tio.c_cflag = CS8|CREAD|PARENB|HUPCL;
	cfsetispeed(&d_tio, VAL_LINE_SPEED);
	cfsetospeed(&d_tio, VAL_LINE_SPEED);
#endif
	d_tio.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK;
#ifdef ECHOKE
	d_tio.c_lflag |= ECHOKE|IEXTEN;
#endif
#ifdef ECHOCTL
	d_tio.c_lflag |= ECHOCTL|IEXTEN;
#endif
#ifndef USE_POSIX_TERMIOS
#ifdef NTTYDISC
	d_tio.c_line = NTTYDISC;
#else
	d_tio.c_line = 0;
#endif
#endif /* USE_POSIX_TERMIOS */
#ifdef __sgi
	d_tio.c_cflag &= ~(HUPCL|PARENB);
	d_tio.c_iflag |= BRKINT|ISTRIP|IGNPAR;
#endif
	d_tio.c_cc[VINTR] = CONTROL('C');	/* '^C'	*/
	d_tio.c_cc[VERASE] = 0x7f;		/* DEL	*/
	d_tio.c_cc[VKILL] = CONTROL('U');	/* '^U'	*/
	d_tio.c_cc[VQUIT] = CQUIT;		/* '^\'	*/
	d_tio.c_cc[VEOF] = CEOF;		/* '^D' */
	d_tio.c_cc[VEOL] = CEOL;		/* '^@@'	*/
	d_tio.c_cc[VMIN] = 1;
	d_tio.c_cc[VTIME] = 0;
#ifdef VSWTCH
	d_tio.c_cc[VSWTCH] = CSWTCH;            /* usually '^Z' */
#endif
#ifdef VLNEXT
	d_tio.c_cc[VLNEXT] = CLNEXT;
#endif
#ifdef VWERASE
	d_tio.c_cc[VWERASE] = CWERASE;
#endif
#ifdef VREPRINT
	d_tio.c_cc[VREPRINT] = CRPRNT;
#endif
#ifdef VRPRNT
	d_tio.c_cc[VRPRNT] = CRPRNT;
#endif
#ifdef VDISCARD
	d_tio.c_cc[VDISCARD] = CFLUSH;
#endif
#ifdef VFLUSHO
	d_tio.c_cc[VFLUSHO] = CFLUSH;
#endif
#ifdef VSTOP
	d_tio.c_cc[VSTOP] = CSTOP;
#endif
#ifdef VSTART
	d_tio.c_cc[VSTART] = CSTART;
#endif
#ifdef VSUSP
	d_tio.c_cc[VSUSP] = CSUSP;
#endif
#ifdef VDSUSP
	d_tio.c_cc[VDSUSP] = CDSUSP;
#endif
#ifdef VSTATUS
	d_tio.c_cc[VSTATUS] = CSTATUS;
#endif
	/* now, try to inherit tty settings */
	{
	    int i;

	    for (i = 0; i <= 2; i++) {
#ifndef USE_POSIX_TERMIOS
		struct termio deftio;
		if (ioctl (i, TCGETA, &deftio) == 0)
#else
		struct termios deftio;
		if (tcgetattr(i, &deftio) == 0)
#endif
		{
		    d_tio.c_cc[VINTR] = deftio.c_cc[VINTR];
		    d_tio.c_cc[VQUIT] = deftio.c_cc[VQUIT];
		    d_tio.c_cc[VERASE] = deftio.c_cc[VERASE];
		    d_tio.c_cc[VKILL] = deftio.c_cc[VKILL];
		    d_tio.c_cc[VEOF] = deftio.c_cc[VEOF];
		    d_tio.c_cc[VEOL] = deftio.c_cc[VEOL];
#ifdef VSWTCH
		    d_tio.c_cc[VSWTCH] = deftio.c_cc[VSWTCH];
#endif
#ifdef VEOL2
		    d_tio.c_cc[VEOL2] = deftio.c_cc[VEOL2];
#endif
#ifdef VLNEXT
		    d_tio.c_cc[VLNEXT] = deftio.c_cc[VLNEXT];
#endif
#ifdef VWERASE
		    d_tio.c_cc[VWERASE] = deftio.c_cc[VWERASE];
#endif
#ifdef VREPRINT
		    d_tio.c_cc[VREPRINT] = deftio.c_cc[VREPRINT];
#endif
#ifdef VRPRNT
		    d_tio.c_cc[VRPRNT] = deftio.c_cc[VRPRNT];
#endif
#ifdef VDISCARD
		    d_tio.c_cc[VDISCARD] = deftio.c_cc[VDISCARD];
#endif
#ifdef VFLUSHO
		    d_tio.c_cc[VFLUSHO] = deftio.c_cc[VFLUSHO];
#endif
#ifdef VSTOP
		    d_tio.c_cc[VSTOP] = deftio.c_cc[VSTOP];
#endif
#ifdef VSTART
		    d_tio.c_cc[VSTART] = deftio.c_cc[VSTART];
#endif
#ifdef VSUSP
		    d_tio.c_cc[VSUSP] = deftio.c_cc[VSUSP];
#endif
#ifdef VDSUSP
		    d_tio.c_cc[VDSUSP] = deftio.c_cc[VDSUSP];
#endif
#ifdef VSTATUS
		    d_tio.c_cc[VSTATUS] = deftio.c_cc[VSTATUS];
#endif
		    break;
		}
	    }
	}
#ifdef HAS_LTCHARS /* { */
	d_ltc.t_suspc = '\000';		/* t_suspc */
	d_ltc.t_dsuspc = '\000';	/* t_dsuspc */
	d_ltc.t_rprntc = '\377';	/* reserved...*/
	d_ltc.t_flushc = '\377';
	d_ltc.t_werasc = '\377';
	d_ltc.t_lnextc = '\377';
#endif	/* } HAS_LTCHARS */
#if defined(USE_TERMIOS) || defined(USE_POSIX_TERMIOS) /* { */
	d_tio.c_cc[VSUSP] = CSUSP;
#ifdef VDSUSP
	d_tio.c_cc[VDSUSP] = '\000';
#endif
#ifdef VSTATUS
	d_tio.c_cc[VSTATUS] = '\377';
#endif
#ifdef VREPRINT
	d_tio.c_cc[VREPRINT] = '\377';
#endif
#ifdef VDISCARD
	d_tio.c_cc[VDISCARD] = '\377';
#endif
#ifdef VWERASE
	d_tio.c_cc[VWERASE] = '\377';
#endif
#ifdef VLNEXT
	d_tio.c_cc[VLNEXT] = '\377';
#endif
#endif /* } USE_TERMIOS */
#ifdef TIOCLSET /* { */
	d_lmode = 0;
#endif	/* } TIOCLSET */
#endif  /* } macII, ATT, CRAY */
#endif	/* } MINIX, etc */
#endif  /* AMOEBA */

	/* Init the Toolkit. */
	{
#ifdef HAS_SAVED_IDS_AND_SETEUID
	    uid_t euid = geteuid();
	    gid_t egid = getegid();
	    uid_t ruid = getuid();
	    gid_t rgid = getgid();

	    if (setegid(rgid) == -1)
#ifdef __MVS__
	       if (!(errno == EMVSERR)) /* could happen if _BPX_SHAREAS=REUSE */
#endif
		(void) fprintf(stderr, "setegid(%d): %s\n",
			       (int) rgid, strerror(errno));

	    if (seteuid(ruid) == -1)
#ifdef __MVS__
	       if (!(errno == EMVSERR))
#endif
		(void) fprintf(stderr, "seteuid(%d): %s\n",
			       (int) ruid, strerror(errno));
#endif

	    XtSetErrorHandler(xt_error);
	    toplevel = XtAppInitialize (&app_con, my_class,
					optionDescList,
					XtNumber(optionDescList),
					&argc, argv, fallback_resources,
					NULL, 0);
	    XtSetErrorHandler((XtErrorHandler)0);

	    XtGetApplicationResources(toplevel, (XtPointer) &resource,
				      application_resources,
				      XtNumber(application_resources), NULL, 0);

#ifdef HAS_SAVED_IDS_AND_SETEUID
	    if (seteuid(euid) == -1)
#ifdef __MVS__
	       if (!(errno == EMVSERR))
#endif
		(void) fprintf(stderr, "seteuid(%d): %s\n",
			       (int) euid, strerror(errno));
	    if (setegid(egid) == -1)
#ifdef __MVS__
	       if (!(errno == EMVSERR))
#endif
		(void) fprintf(stderr, "setegid(%d): %s\n",
			       (int) egid, strerror(errno));
#endif
#ifdef __OpenBSD__
	    if (resource.utmpInhibit) {
		/* Can totally revoke group privs */
		setegid(getgid());
		setgid(getgid());
	    }
#endif
	}

	waiting_for_initial_map = resource.wait_for_map;

	/*
	 * ICCCM delete_window.
	 */
	XtAppAddActions(app_con, actionProcs, XtNumber(actionProcs));

	/*
	 * fill in terminal modes
	 */
	if (resource.tty_modes) {
	    int n = parse_tty_modes (resource.tty_modes, ttymodelist);
	    if (n < 0) {
		fprintf (stderr, "%s:  bad tty modes \"%s\"\n",
			 ProgramName, resource.tty_modes);
	    } else if (n > 0) {
		override_tty_modes = 1;
	    }
	}

#if OPT_ZICONBEEP
	zIconBeep = resource.zIconBeep;
	zIconBeep_flagged = False;
	if ( zIconBeep > 100 || zIconBeep < -100 ) {
	    zIconBeep = 0;	/* was 100, but I prefer to defaulting off. */
	    fprintf( stderr, "a number between -100 and 100 is required for zIconBeep.  0 used by default\n");
	}
#endif /* OPT_ZICONBEEP */
#if OPT_SAME_NAME
	sameName = resource.sameName;
#endif
	hold_screen = resource.hold_screen ? 1 : 0;
	xterm_name = resource.xterm_name;
	if (strcmp(xterm_name, "-") == 0) xterm_name = DFT_TERMTYPE;
	if (resource.icon_geometry != NULL) {
	    int scr, junk;
	    int ix, iy;
	    Arg args[2];

	    for(scr = 0;	/* yyuucchh */
		XtScreen(toplevel) != ScreenOfDisplay(XtDisplay(toplevel),scr);
		scr++);

	    args[0].name = XtNiconX;
	    args[1].name = XtNiconY;
	    XGeometry(XtDisplay(toplevel), scr, resource.icon_geometry, "",
		      0, 0, 0, 0, 0, &ix, &iy, &junk, &junk);
	    args[0].value = (XtArgVal) ix;
	    args[1].value = (XtArgVal) iy;
	    XtSetValues( toplevel, args, 2);
	}

	XtSetValues (toplevel, ourTopLevelShellArgs,
		     number_ourTopLevelShellArgs);

#if OPT_WIDE_CHARS
	/* seems as good a place as any */
	init_classtab();
#endif

	/* Parse the rest of the command line */
	TRACE_ARGV("After XtAppInitialize", argv);
	for (argc--, argv++ ; argc > 0 ; argc--, argv++) {
	    if(**argv != '-') Syntax (*argv);

	    TRACE(("parsing %s\n", argv[0]));
	    switch(argv[0][1]) {
	     case 'h':	/* -help */
		Help();
		continue;
	     case 'v':	/* -version */
		Version();
		continue;
	     case 'C':
#if defined(TIOCCONS) || defined(SRIOCSREDIR)
#ifndef __sgi
		{
		    struct stat sbuf;

		    /* Must be owner and have read/write permission.
		       xdm cooperates to give the console the right user. */
		    if ( !stat("/dev/console", &sbuf) &&
			 (sbuf.st_uid == getuid()) &&
			 !access("/dev/console", R_OK|W_OK))
		    {
			Console = TRUE;
		    } else
			Console = FALSE;
		}
#else /* __sgi */
		Console = TRUE;
#endif /* __sgi */
#endif	/* TIOCCONS */
		continue;
	     case 'S':
		if (!ParseSccn(*argv + 2))
		    Syntax(*argv);
		continue;
#ifdef DEBUG
	     case 'D':
		debug = TRUE;
		continue;
#endif	/* DEBUG */
	     case 'c':	/* -class param */
		argc--, argv++;
		continue;
	     case 'e':
		if (argc <= 1) Syntax (*argv);
		command_to_exec = ++argv;
		break;
	     default:
		Syntax (*argv);
	    }
	    break;
	}

#if OPT_WIDE_CHARS
	/* Test whether UTF-8 mode should be active by default */
	{
	    char *s;

	    if (((s = getenv("LC_ALL")) != 0 && *s != '\0') ||
		((s = getenv("LC_CTYPE")) != 0 && *s != '\0') ||
		((s = getenv("LANG")) != 0 && *s != '\0')) {
		if (strstr(s, "UTF-8"))
		    defaultUTF8[0] = '2';
	    }
	}
#endif

	SetupMenus(toplevel, &form_top, &menu_top);

	term = (XtermWidget) XtVaCreateManagedWidget(
		"vt100", xtermWidgetClass, form_top,
#if OPT_TOOLBAR
		XtNmenuBar,	menu_top,
		XtNresizable,	True,
		XtNfromVert,	menu_top,
		XtNleft,	XawChainLeft,
		XtNright,	XawChainRight,
		XtNbottom,	XawChainBottom,
#endif
		0);
	    /* this causes the initialize method to be called */

#if OPT_HP_FUNC_KEYS
	init_keyboard_type(keyboardIsHP, resource.hpFunctionKeys);
#endif
	init_keyboard_type(keyboardIsSun, resource.sunFunctionKeys);
#if OPT_SUNPC_KBD
	init_keyboard_type(keyboardIsVT220, resource.sunKeyboard);
#endif

	screen = &term->screen;

	inhibit = 0;
#ifdef ALLOWLOGGING
	if (term->misc.logInhibit)		inhibit |= I_LOG;
#endif
	if (term->misc.signalInhibit)		inhibit |= I_SIGNAL;
#if OPT_TEK4014
	if (term->misc.tekInhibit)		inhibit |= I_TEK;
#endif

/*
 * Set title and icon name if not specified
 */

	if (command_to_exec) {
	    Arg args[2];

	    if (!resource.title) {
		if (command_to_exec) {
		    resource.title = x_basename (command_to_exec[0]);
		} /* else not reached */
	    }

	    if (!resource.icon_name)
	      resource.icon_name = resource.title;
	    XtSetArg (args[0], XtNtitle, resource.title);
	    XtSetArg (args[1], XtNiconName, resource.icon_name);

	    TRACE(("setting:\n\ttitle \"%s\"\n\ticon \"%s\"\n\tbased on command \"%s\"\n",
		    resource.title,
		    resource.icon_name,
		    *command_to_exec));

	    XtSetValues (toplevel, args, 2);
	}

#if OPT_TEK4014
	if(inhibit & I_TEK)
		screen->TekEmu = FALSE;

	if(screen->TekEmu && !TekInit())
		exit(ERROR_INIT);
#endif

#ifndef MINIX
#ifdef DEBUG
    {
	/* Set up stderr properly.  Opening this log file cannot be
	 done securely by a privileged xterm process (although we try),
	 so the debug feature is disabled by default. */
	char dbglogfile[45];
	int i = -1;
	if(debug) {
		timestamp_filename(dbglogfile, "xterm.debug.log.");
		if(creat_as (getuid(), getgid(), False, dbglogfile, 0666)) {
			i = open (dbglogfile, O_WRONLY | O_TRUNC, 0666);
		}
	}
	if(i >= 0) {
#if defined(USE_ANY_SYSV_TERMIO) && !defined(SVR4) && !defined(linux)
		/* SYSV has another pointer which should be part of the
		** FILE structure but is actually a separate array.
		*/
		unsigned char *old_bufend;

		old_bufend = (unsigned char *) _bufend(stderr);
#ifdef __hpux
		stderr->__fileH = (i >> 8);
		stderr->__fileL = i;
#else
		stderr->_file = i;
#endif
		_bufend(stderr) = old_bufend;
#else	/* USE_ANY_SYSV_TERMIO */
		freopen(dbglogfile, "w", stderr);
#endif	/* USE_ANY_SYSV_TERMIO */

		/* mark this file as close on exec */
		(void) fcntl(i, F_SETFD, 1);
	}
    }
#endif	/* DEBUG */
#endif /* MINIX */

	/* open a terminal for client */
	get_terminal ();

	spawn ();

#ifndef VMS
	/* Child process is out there, let's catch its termination */

#ifdef USE_POSIX_SIGNALS
	(void) posix_signal(SIGCHLD, reapchild);
#else
	(void) signal (SIGCHLD, reapchild);
#endif
	/* Realize procs have now been executed */

#ifndef AMOEBA
	if (am_slave >= 0) { /* Write window id so master end can read and use */
	    char buf[80];

	    buf[0] = '\0';
	    sprintf (buf, "%lx\n", XtWindow (XtParent (CURRENT_EMU(screen))));
	    write (screen->respond, buf, strlen (buf));
	}
#endif /* !AMOEBA */

	screen->inhibit = inhibit;

#ifdef AIXV3
#if (OSMAJORVERSION < 4)
	/* In AIXV3, xterms started from /dev/console have CLOCAL set.
	 * This means we need to clear CLOCAL so that SIGHUP gets sent
	 * to the slave-pty process when xterm exits.
	 */

	{
	    struct termio tio;

	    if(ioctl(screen->respond, TCGETA, &tio) == -1)
		SysError(ERROR_TIOCGETP);

	    tio.c_cflag &= ~(CLOCAL);

	    if (ioctl (screen->respond, TCSETA, &tio) == -1)
		SysError(ERROR_TIOCSETP);
	}
#endif
#endif
#ifndef AMOEBA
#ifdef MINIX
	if ((mode = fcntl(screen->respond, F_GETFD, 0)) == -1)
		Error(1);
	mode |= FD_ASYNCHIO;
	if (fcntl(screen->respond, F_SETFD, mode) == -1)
		Error(1);
	nbio_register(screen->respond);
#elif defined(USE_ANY_SYSV_TERMIO) || defined(__MVS__)
	if (0 > (mode = fcntl(screen->respond, F_GETFL, 0)))
		Error(1);
#ifdef O_NDELAY
	mode |= O_NDELAY;
#else
	mode |= O_NONBLOCK;
#endif /* O_NDELAY */
	if (fcntl(screen->respond, F_SETFL, mode))
		Error(1);
#else	/* !MINIX && !USE_ANY_SYSV_TERMIO */
	mode = 1;
	if (ioctl (screen->respond, FIONBIO, (char *)&mode) == -1) SysError (ERROR_FIONBIO);
#endif	/* MINIX, etc */
#endif  /* AMOEBA */

	FD_ZERO (&pty_mask);
	FD_ZERO (&X_mask);
	FD_ZERO (&Select_mask);
	FD_SET (screen->respond, &pty_mask);
	FD_SET (ConnectionNumber(screen->display), &X_mask);
	FD_SET (screen->respond, &Select_mask);
	FD_SET (ConnectionNumber(screen->display), &Select_mask);
	max_plus1 = (screen->respond < ConnectionNumber(screen->display)) ?
		(1 + ConnectionNumber(screen->display)) :
		(1 + screen->respond);

#endif /* !VMS */
#ifdef DEBUG
	if (debug) printf ("debugging on\n");
#endif	/* DEBUG */
	XSetErrorHandler(xerror);
	XSetIOErrorHandler(xioerror);

#ifdef ALLOWLOGGING
	if (term->misc.log_on) {
		StartLog(screen);
	}
#endif
	for( ; ; ) {
#if OPT_TEK4014
		if(screen->TekEmu)
			TekRun();
		else
#endif
			VTRun();
	}
}

#ifndef AMOEBA
/*
 * This function opens up a pty master and stuffs its value into pty.
 *
 * If it finds one, it returns a value of 0.  If it does not find one,
 * it returns a value of !0.  This routine is designed to be re-entrant,
 * so that if a pty master is found and later, we find that the slave
 * has problems, we can re-enter this function and get another one.
 */
static int
get_pty (int *pty)
{
	int result = 1;

#ifdef __OpenBSD__
	static int m_tty = -1;
	static int m_pty = -1;
	struct group *ttygrp;

	if (pty == NULL) {
		result = openpty(&m_pty, &m_tty, ttydev, NULL, NULL);

		seteuid(0);
		if ((ttygrp = getgrnam(TTY_GROUP_NAME)) != 0) {
			set_owner(ttydev, getuid(), ttygrp->gr_gid,
			    0600);
		} else {
			set_owner(ttydev, getuid(), getgid(),
			    0600);
		}
		seteuid(getuid());
		return result;
	} else if (m_pty != -1) {
		*pty = m_pty;
		return (0);
	} else {
		return (-1);
	}
#endif /* __OpenBSD__ */


#ifdef PUCC_PTYD

	result = ((*pty = openrpty(ttydev, ptydev,
				(resource.utmpInhibit ? OPTY_NOP : OPTY_LOGIN),
				getuid(), from)) < 0);

#elif defined(__osf__) || (defined(__GLIBC__) && !defined(USE_USG_PTYS))

	int tty;
	result = openpty(pty, &tty, ttydev, NULL, NULL);

#elif defined(__QNXNTO__)

	result = pty_search(pty);

#else
#if defined(USE_ISPTS_FLAG)

	/*
	  The order of this code is *important*.  On SYSV/386 we want to open
	  a /dev/ttyp? first if at all possible.  If none are available, then
	  we'll try to open a /dev/pts??? device.

	  The reason for this is because /dev/ttyp? works correctly, where
	  as /dev/pts??? devices have a number of bugs, (won't update
	  screen correcly, will hang -- it more or less works, but you
	  really don't want to use it).

	  Most importantly, for boxes of this nature, one of the major
	  "features" is that you can emulate a 8086 by spawning off a UNIX
	  program on 80386/80486 in v86 mode.  In other words, you can spawn
	  off multiple MS-DOS environments.  On ISC the program that does
	  this is named "vpix."  The catcher is that "vpix" will *not* work
	  with a /dev/pts??? device, will only work with a /dev/ttyp? device.

	  Since we can open either a /dev/ttyp? or a /dev/pts??? device,
	  the flag "IsPts" is set here so that we know which type of
	  device we're dealing with in routine spawn().  That's the reason
	  for the "if (IsPts)" statement in spawn(); we have two different
	  device types which need to be handled differently.
	  */
	result = pty_search(pty);

#endif
#if defined(USE_USG_PTYS) || defined(__CYGWIN__)

#ifdef __GLIBC__ /* if __GLIBC__ and USE_USG_PTYS, we know glibc >= 2.1 */
	/* GNU libc 2 allows us to abstract away from having to know the
	   master pty device name. */
	if ((*pty = getpt()) >= 0) {
	    strcpy(ttydev, ptsname(*pty));
	    result = 0;
	}
#elif defined(__MVS__)
	result = pty_search(pty);
#else
	result = ((*pty = open ("/dev/ptmx", O_RDWR)) < 0);
#endif
#if defined(SVR4) || defined(SCO325) || defined(USE_ISPTS_FLAG)
	if (!result)
	    strcpy(ttydev, ptsname(*pty));
#ifdef USE_ISPTS_FLAG
	IsPts = !result;	/* true if we're successful */
#endif
#endif

#elif defined(AIXV3)

	if ((*pty = open ("/dev/ptc", O_RDWR)) >= 0) {
	    strcpy(ttydev, ttyname(*pty));
	    result = 0;
	}

#elif defined(__convex__)

	char *pty_name;
	extern char *getpty(void);

	while ((pty_name = getpty()) != NULL) {
	    if ((*pty = open (pty_name, O_RDWR)) >= 0) {
		strcpy(ptydev, pty_name);
		strcpy(ttydev, pty_name);
		*x_basename(ttydev) = 't';
		result = 0;
		break;
	    }
	}

#elif defined(sequent)

	result = ((*pty = getpseudotty (&ttydev, &ptydev)) < 0);

#elif defined(__sgi) && (OSMAJORVERSION >= 4)

	char    *tty_name;

	tty_name = _getpty (pty, O_RDWR, 0622, 0);
	if (tty_name != 0) {
	    strcpy (ttydev, tty_name);
	    result = 0;
	}

#elif (defined(__sgi) && (OSMAJORVERSION < 4)) || (defined(umips) && defined (SYSTYPE_SYSV))

	struct stat fstat_buf;

	*pty = open ("/dev/ptc", O_RDWR);
	if (*pty >= 0 && (fstat (*pty, &fstat_buf)) >= 0) {
	    result = 0;
	    sprintf (ttydev, "/dev/ttyq%d", minor(fstat_buf.st_rdev));
	}

#elif defined(__hpux)

	/*
	 * Use the clone device if it works, otherwise use pty_search logic.
	 */
	if ((*pty = open("/dev/ptym/clone", O_RDWR)) >= 0) {
	    strcpy(ttydev, ptsname(*pty));
	    result = 0;
	} else {
	    result = pty_search(pty);
	}

#else

	result = pty_search(pty);

#endif
#endif

	TRACE(("get_pty(ttydev=%s, ptydev=%s) %s fd=%d\n",
		ttydev != 0 ? ttydev : "?",
		ptydev != 0 ? ptydev : "?",
		result ? "FAIL" : "OK", *pty));
	return result;
}

/*
 * Called from get_pty to iterate over likely pseudo terminals
 * we might allocate.  Used on those systems that do not have
 * a functional interface for allocating a pty.
 * Returns 0 if found a pty, 1 if fails.
 */
#ifdef USE_PTY_SEARCH
static int
pty_search(int *pty)
{
    static int devindex = 0, letter = 0;

#if defined(CRAY) || defined(__MVS__)
    while (devindex < MAXPTTYS) {
	sprintf (ttydev, TTYFORMAT, devindex);
	sprintf (ptydev, PTYFORMAT, devindex);
	devindex++;

	TRACE(("pty_search(ttydev=%s, ptydev=%s)\n", ttydev, ptydev));
	if ((*pty = open (ptydev, O_RDWR)) >= 0) {
	    return 0;
	}
    }
#else /* CRAY || __MVS__ */
    while (PTYCHAR1[letter]) {
	ttydev [strlen(ttydev) - 2] =
	ptydev [strlen(ptydev) - 2] = PTYCHAR1 [letter];

	while (PTYCHAR2[devindex]) {
	    ttydev [strlen(ttydev) - 1] =
	    ptydev [strlen(ptydev) - 1] = PTYCHAR2 [devindex];
	    devindex++;

	    TRACE(("pty_search(ttydev=%s, ptydev=%s)\n", ttydev, ptydev));
	    if ((*pty = open (ptydev, O_RDWR)) >= 0) {
#ifdef sun
		/* Need to check the process group of the pty.
		 * If it exists, then the slave pty is in use,
		 * and we need to get another one.
		 */
		int pgrp_rtn;
		if (ioctl(*pty, TIOCGPGRP, &pgrp_rtn) == 0 || errno != EIO) {
		    close(*pty);
		    continue;
		}
#endif /* sun */
		return 0;
	    }
	}
	devindex = 0;
	letter++;
    }
#endif /* CRAY else */
    /*
     * We were unable to allocate a pty master!  Return an error
     * condition and let our caller terminate cleanly.
     */
    return 1;
}
#endif /* USE_PTY_SEARCH */
#endif /* AMOEBA */

static void
get_terminal (void)
/*
 * sets up X and initializes the terminal structure except for term.buf.fildes.
 */
{
	register TScreen *screen = &term->screen;

	screen->arrow = make_colored_cursor (XC_left_ptr,
					     screen->mousecolor,
					     screen->mousecolorback);
}

/*
 * The only difference in /etc/termcap between 4014 and 4015 is that
 * the latter has support for switching character sets.  We support the
 * 4015 protocol, but ignore the character switches.  Therefore, we
 * choose 4014 over 4015.
 *
 * Features of the 4014 over the 4012: larger (19") screen, 12-bit
 * graphics addressing (compatible with 4012 10-bit addressing),
 * special point plot mode, incremental plot mode (not implemented in
 * later Tektronix terminals), and 4 character sizes.
 * All of these are supported by xterm.
 */

#if OPT_TEK4014
static char *tekterm[] = {
	"tek4014",
	"tek4015",		/* 4014 with APL character set support */
	"tek4012",		/* 4010 with lower case */
	"tek4013",		/* 4012 with APL character set support */
	"tek4010",		/* small screen, upper-case only */
	"dumb",
	0
};
#endif

/* The VT102 is a VT100 with the Advanced Video Option included standard.
 * It also adds Escape sequences for insert/delete character/line.
 * The VT220 adds 8-bit character sets, selective erase.
 * The VT320 adds a 25th status line, terminal state interrogation.
 * The VT420 has up to 48 lines on the screen.
 */

static char *vtterm[] = {
#ifdef USE_X11TERM
	"x11term",		/* for people who want special term name */
#endif
	DFT_TERMTYPE,		/* for people who want special term name */
	"xterm",		/* the prefered name, should be fastest */
	"vt102",
	"vt100",
	"ansi",
	"dumb",
	0
};

/* ARGSUSED */
static SIGNAL_T hungtty(int i GCC_UNUSED)
{
       siglongjmp(env, 1);
	SIGNAL_RETURN;
}

/*
 * declared outside USE_HANDSHAKE so HsSysError() callers can use
 */
static int pc_pipe[2];	/* this pipe is used for parent to child transfer */
static int cp_pipe[2];	/* this pipe is used for child to parent transfer */

#ifdef USE_HANDSHAKE
typedef enum {		/* c == child, p == parent                        */
	PTY_BAD,	/* c->p: can't open pty slave for some reason     */
	PTY_FATALERROR,	/* c->p: we had a fatal error with the pty        */
	PTY_GOOD,	/* c->p: we have a good pty, let's go on          */
	PTY_NEW,	/* p->c: here is a new pty slave, try this        */
	PTY_NOMORE,	/* p->c; no more pty's, terminate                 */
	UTMP_ADDED,	/* c->p: utmp entry has been added                */
	UTMP_TTYSLOT,	/* c->p: here is my ttyslot                       */
	PTY_EXEC	/* p->c: window has been mapped the first time    */
} status_t;

typedef struct {
	status_t status;
	int error;
	int fatal_error;
	int tty_slot;
	int rows;
	int cols;
	char buffer[1024];
} handshake_t;

/* HsSysError()
 *
 * This routine does the equivalent of a SysError but it handshakes
 * over the errno and error exit to the master process so that it can
 * display our error message and exit with our exit code so that the
 * user can see it.
 */

static void
HsSysError(int pf, int error)
{
	handshake_t handshake;

	handshake.status = PTY_FATALERROR;
	handshake.error = errno;
	handshake.fatal_error = error;
	strcpy(handshake.buffer, ttydev);
	write(pf, (char *) &handshake, sizeof(handshake));
	exit(error);
}

void first_map_occurred (void)
{
    handshake_t handshake;
    register TScreen *screen = &term->screen;

    handshake.status = PTY_EXEC;
    handshake.rows = screen->max_row;
    handshake.cols = screen->max_col;
    write (pc_pipe[1], (char *) &handshake, sizeof(handshake));
    close (cp_pipe[0]);
    close (pc_pipe[1]);
    waiting_for_initial_map = False;
}
#else
/*
 * temporary hack to get xterm working on att ptys
 */
static void
HsSysError(int pf GCC_UNUSED, int error)
{
    fprintf(stderr, "%s: fatal pty error %d (errno=%d) on tty %s\n",
	    xterm_name, error, errno, ttydev);
    exit(error);
}

void first_map_occurred (void)
{
    return;
}
#endif /* USE_HANDSHAKE else !USE_HANDSHAKE */


#ifndef VMS
#ifndef AMOEBA
extern char **environ;

static void
set_owner(char *device, int uid, int gid, int mode)
{
	if (chown (device, uid, gid) < 0) {
		if (errno != ENOENT
		 && getuid() == 0) {
			fprintf(stderr, "Cannot chown %s to %d,%d: %s\n",
				device, uid, gid, strerror(errno));
		}
	}
	chmod (device, mode);
}

static int
spawn (void)
/*
 *  Inits pty and tty and forks a login process.
 *  Does not close fd Xsocket.
 *  If slave, the pty named in passedPty is already open for use
 */
{
	register TScreen *screen = &term->screen;
#ifdef USE_HANDSHAKE
	handshake_t handshake;
	int done;
#endif
#if OPT_INITIAL_ERASE
	int initial_erase = VAL_INITIAL_ERASE;
#endif
	int rc;
	int tty = -1;
#ifdef USE_ANY_SYSV_TERMIO
	struct termio tio;
#ifdef TIOCLSET
	unsigned lmode;
#endif	/* TIOCLSET */
#ifdef HAS_LTCHARS
	struct ltchars ltc;
#endif	/* HAS_LTCHARS */
#elif defined(USE_POSIX_TERMIOS)
	struct termios tio;
#else /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
	int ldisc = 0;
	int discipline;
	unsigned lmode;
	struct tchars tc;
	struct ltchars ltc;
	struct sgttyb sg;
#ifdef sony
	int jmode;
	struct jtchars jtc;
#endif /* sony */
#endif	/* USE_ANY_SYSV_TERMIO */

	char termcap [TERMCAP_SIZE];
	char newtc [TERMCAP_SIZE];
	char *ptr, *shname, *shname_minus;
	int i, no_dev_tty = FALSE;
	char **envnew;		/* new environment */
	int envsize;		/* elements in new environment */
	char buf[64];
	char *TermName = NULL;
#if defined(TIOCSSIZE) && (defined(sun) && !defined(SVR4))
	struct ttysize ts;
#elif defined(TIOCSWINSZ)
	struct winsize ws;
#endif	/* sun vs TIOCSWINSZ */
	struct passwd *pw = NULL;
	char *login_name = NULL;
#ifdef HAVE_UTMP
#if defined(UTMPX_FOR_UTMP)
	struct utmpx utmp,
		    *utret;
#else
	struct utmp utmp;
#ifdef USE_SYSV_UTMP
	struct utmp *utret;
#endif
#endif
#ifdef USE_LASTLOG
	struct lastlog lastlog;
#endif	/* USE_LASTLOG */
#endif	/* HAVE_UTMP */

	screen->uid = getuid();
	screen->gid = getgid();

	termcap[0] = '\0';
	newtc[0] = '\0';

#ifdef SIGTTOU
	/* so that TIOCSWINSZ || TIOCSIZE doesn't block */
	signal(SIGTTOU,SIG_IGN);
#endif

	if (am_slave >= 0) {
		screen->respond = am_slave;
		set_pty_id(ttydev, passedPty);
#ifdef USE_PTY_DEVICE
		set_pty_id(ptydev, passedPty);
#endif
		setgid (screen->gid);
		setuid (screen->uid);
	} else {
		Bool tty_got_hung;

		/*
		 * Sometimes /dev/tty hangs on open (as in the case of a pty
		 * that has gone away).  Simply make up some reasonable
		 * defaults.
		 */

		signal(SIGALRM, hungtty);
		alarm(2);		/* alarm(1) might return too soon */
		if (! sigsetjmp(env, 1)) {
			tty = open ("/dev/tty", O_RDWR, 0);
			alarm(0);
			tty_got_hung = False;
		} else {
			tty_got_hung = True;
			tty = -1;
			errno = ENXIO;
		}
#if OPT_INITIAL_ERASE
		initial_erase = VAL_INITIAL_ERASE;
#endif
		signal(SIGALRM, SIG_DFL);

		/*
		 * Check results and ignore current control terminal if
		 * necessary.  ENXIO is what is normally returned if there is
		 * no controlling terminal, but some systems (e.g. SunOS 4.0)
		 * seem to return EIO.  Solaris 2.3 is said to return EINVAL.
		 * Cygwin returns ENOENT.
		 */
		no_dev_tty = FALSE;
		if (tty < 0) {
			if (tty_got_hung || errno == ENXIO || errno == EIO ||
#ifdef ENODEV
			    errno == ENODEV ||
#endif
#ifdef __CYGWIN__
			    errno == ENOENT ||
#endif
			    errno == EINVAL || errno == ENOTTY || errno == EACCES) {
				no_dev_tty = TRUE;
#ifdef HAS_LTCHARS
				ltc = d_ltc;
#endif	/* HAS_LTCHARS */
#ifdef TIOCLSET
				lmode = d_lmode;
#endif	/* TIOCLSET */
#if defined(USE_ANY_SYSV_TERMIO) || defined(USE_POSIX_TERMIOS)
				tio = d_tio;
#else	/* not USE_ANY_SYSV_TERMIO and not USE_POSIX_TERMIOS */
				sg = d_sg;
				tc = d_tc;
				discipline = d_disipline;
#ifdef sony
				jmode = d_jmode;
				jtc = d_jtc;
#endif /* sony */
#endif	/* USE_ANY_SYSV_TERMIO or USE_POSIX_TERMIOS */
			} else {
			    SysError(ERROR_OPDEVTTY);
			}
		} else {

			/* Get a copy of the current terminal's state,
			 * if we can.  Some systems (e.g., SVR4 and MacII)
			 * may not have a controlling terminal at this point
			 * if started directly from xdm or xinit,
			 * in which case we just use the defaults as above.
			 */
#ifdef HAS_LTCHARS
			if(ioctl(tty, TIOCGLTC, &ltc) == -1)
				ltc = d_ltc;
#endif	/* HAS_LTCHARS */
#ifdef TIOCLSET
			if(ioctl(tty, TIOCLGET, &lmode) == -1)
				lmode = d_lmode;
#endif	/* TIOCLSET */
#ifdef USE_ANY_SYSV_TERMIO
			if ((rc = ioctl(tty, TCGETA, &tio)) == -1)
				tio = d_tio;
#elif defined(USE_POSIX_TERMIOS)
			if ((rc = tcgetattr(tty, &tio)) == -1)
				tio = d_tio;
#else   /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
			if ((rc = ioctl(tty, TIOCGETP, (char *)&sg)) == -1)
				sg = d_sg;
			if (ioctl(tty, TIOCGETC, (char *)&tc) == -1)
				tc = d_tc;
			if (ioctl(tty, TIOCGETD, (char *)&discipline) == -1)
				discipline = d_disipline;
#ifdef sony
			if (ioctl(tty, TIOCKGET, (char *)&jmode) == -1)
				jmode = d_jmode;
			if (ioctl(tty, TIOCKGETC, (char *)&jtc) == -1)
				jtc = d_jtc;
#endif /* sony */
#endif	/* USE_ANY_SYSV_TERMIO */

			/*
			 * If ptyInitialErase is set, we want to get the pty's
			 * erase value.  Just in case that will fail, first get
			 * the value from /dev/tty, so we will have something
			 * at least.
			 */
#if OPT_INITIAL_ERASE
			if (resource.ptyInitialErase) {
#ifdef USE_ANY_SYSV_TERMIO
				initial_erase = tio.c_cc[VERASE];
#elif defined(USE_POSIX_TERMIOS)
				initial_erase = tio.c_cc[VERASE];
#else   /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
				initial_erase = sg.sg_erase;
#endif	/* USE_ANY_SYSV_TERMIO */
				TRACE(("%s initial_erase:%d (from /dev/tty)\n",
					rc == 0 ? "OK" : "FAIL",
					initial_erase));
			}
#endif

#ifdef MINIX
			/* Editing shells interfere with xterms started in
			 * the background.
			 */
			tio = d_tio;
#endif
			close (tty);
			/* tty is no longer an open fd! */
			tty = -1;
		}

		if (get_pty (&screen->respond))
		{
			/*  no ptys! */
			(void) fprintf(stderr, "%s: no available ptys: %s\n",
				       xterm_name, strerror(errno));
			exit (ERROR_PTYS);
		}

#if OPT_INITIAL_ERASE
		if (resource.ptyInitialErase) {
#ifdef USE_ANY_SYSV_TERMIO
			struct termio my_tio;
			if ((rc = ioctl(screen->respond, TCGETA, &my_tio)) == 0)
				initial_erase = my_tio.c_cc[VERASE];
#elif defined(USE_POSIX_TERMIOS)
			struct termios my_tio;
			if ((rc = tcgetattr(screen->respond, &my_tio)) == 0)
				initial_erase = my_tio.c_cc[VERASE];
#else   /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
			struct sgttyb my_sg;
			if ((rc = ioctl(screen->respond, TIOCGETP, (char *)&my_sg)) == 0)
				initial_erase = my_sg.sg_erase;
#endif	/* USE_ANY_SYSV_TERMIO */
			TRACE(("%s initial_erase:%d (from pty)\n",
				(rc == 0) ? "OK" : "FAIL",
				initial_erase));
		}
#endif	/* OPT_INITIAL_ERASE */
	}

	/* avoid double MapWindow requests */
	XtSetMappedWhenManaged(XtParent(CURRENT_EMU(screen)), False );

	wm_delete_window = XInternAtom(XtDisplay(toplevel), "WM_DELETE_WINDOW",
				       False);

	if (!TEK4014_ACTIVE(screen))
	    VTInit();		/* realize now so know window size for tty driver */
#if defined(TIOCCONS) || defined(SRIOCSREDIR)
	if (Console) {
	    /*
	     * Inform any running xconsole program
	     * that we are going to steal the console.
	     */
	    XmuGetHostname (mit_console_name + MIT_CONSOLE_LEN, 255);
	    mit_console = XInternAtom(screen->display, mit_console_name, False);
	    /* the user told us to be the console, so we can use CurrentTime */
	    XtOwnSelection(XtParent(CURRENT_EMU(screen)),
			   mit_console, CurrentTime,
			   ConvertConsoleSelection, NULL, NULL);
	}
#endif
#if OPT_TEK4014
	if(screen->TekEmu) {
		envnew = tekterm;
		ptr = newtc;
	}
	else
#endif
	{
		envnew = vtterm;
		ptr = termcap;
	}

	/*
	 * This used to exit if no termcap entry was found for the specified
	 * terminal name.  That's a little unfriendly, so instead we'll allow
	 * the program to proceed (but not to set $TERMCAP) if the termcap
	 * entry is not found.
	 */
	get_termcap(TermName = resource.term_name, ptr, newtc);

	/*
	 * This block is invoked only if there was no terminal name specified
	 * by the command-line option "-tn".
	 */
	if (!TermName) {
	    TermName = *envnew;
	    while (*envnew != NULL) {
		if (get_termcap(*envnew, ptr, newtc)) {
		    TermName = *envnew;
		    break;
		}
		envnew++;
	    }
	}

	/*
	 * Check if ptyInitialErase is not set.  If so, we rely on the termcap
	 * (or terminfo) to tell us what the erase mode should be set to.
	 */
#if OPT_INITIAL_ERASE
	TRACE(("resource ptyInitialErase is %sset\n",
		resource.ptyInitialErase ? "" : "not "));
	if (!resource.ptyInitialErase) {
		char temp[1024], *p = temp;
		char *s = tgetstr(TERMCAP_ERASE, &p);
		TRACE(("...extracting initial_erase value from termcap\n"));
		if (s != 0) {
			initial_erase = decode_keyvalue(s, True);
		}
	}
	TRACE(("...initial_erase:%d\n", initial_erase));

	TRACE(("resource backarrowKeyIsErase is %sset\n",
		resource.backarrow_is_erase ? "" : "not "));
	if (resource.backarrow_is_erase) { /* see input.c */
		if (initial_erase == 127) {
		    term->keyboard.flags &= ~MODE_DECBKM;
		} else {
		    term->keyboard.flags |= MODE_DECBKM;
		    term->keyboard.reset_DECBKM = 1;
		}
		TRACE(("...sets DECBKM %s\n", 
		    (term->keyboard.flags & MODE_DECBKM) ? "on" : "off"));
	} else {
		term->keyboard.reset_DECBKM = 2;
	}
#endif	/* OPT_INITIAL_ERASE */

#if defined(TIOCSSIZE) && (defined(sun) && !defined(SVR4))
	/* tell tty how big window is */
	if(TEK4014_ACTIVE(screen)) {
		ts.ts_lines = 38;
		ts.ts_cols = 81;
	} else {
		ts.ts_lines = screen->max_row + 1;
		ts.ts_cols = screen->max_col + 1;
	}
	i = ioctl (screen->respond, TIOCSSIZE, &ts);
	TRACE(("spawn TIOCSSIZE %dx%d return %d\n", ts.ts_lines, ts.ts_cols, i));
#elif defined(TIOCSWINSZ)
	/* tell tty how big window is */
#if OPT_TEK4014
	if(TEK4014_ACTIVE(screen)) {
		ws.ws_row = 38;
		ws.ws_col = 81;
		ws.ws_xpixel = TFullWidth(screen);
		ws.ws_ypixel = TFullHeight(screen);
	} else
#endif
	{
		ws.ws_row = screen->max_row + 1;
		ws.ws_col = screen->max_col + 1;
		ws.ws_xpixel = FullWidth(screen);
		ws.ws_ypixel = FullHeight(screen);
	}
	i = ioctl (screen->respond, TIOCSWINSZ, (char *)&ws);
	TRACE(("spawn TIOCSWINSZ %dx%d return %d\n", ws.ws_row, ws.ws_col, i));
#endif	/* sun vs TIOCSWINSZ */

#if defined(USE_UTEMPTER)
#undef UTMP
	if (!resource.utmpInhibit) {
	    addToUtmp(ttydev, NULL, screen->respond);
	    added_utmp_entry = True;
	}
#endif

	if (am_slave < 0) {
#ifdef USE_HANDSHAKE
	    if (pipe(pc_pipe) || pipe(cp_pipe))
		SysError (ERROR_FORK);
#endif
	    TRACE(("Forking...\n"));
	    if ((screen->pid = fork ()) == -1)
		SysError (ERROR_FORK);

	    if (screen->pid == 0) {
		/*
		 * now in child process
		 */
		TRACE_CHILD
#if defined(_POSIX_SOURCE) || defined(SVR4) || defined(__convex__) || defined(SCO325) || defined(__QNX__)
		int pgrp = setsid();	/* variable may not be used... */
#else
		int pgrp = getpid();
#endif

#ifdef USE_USG_PTYS
#ifdef USE_ISPTS_FLAG
		if (IsPts) {	/* SYSV386 supports both, which did we open? */
#endif
		int ptyfd;

		setpgrp();
		grantpt (screen->respond);
		unlockpt (screen->respond);
		if ((ptyfd = open (ptsname(screen->respond), O_RDWR)) < 0) {
		    SysError (1);
		}
#ifdef I_PUSH
		if (ioctl (ptyfd, I_PUSH, "ptem") < 0) {
		    SysError (2);
		}
#if !defined(SVR4) && !(defined(SYSV) && defined(i386))
		if (!getenv("CONSEM") && ioctl (ptyfd, I_PUSH, "consem") < 0) {
		    SysError (3);
		}
#endif /* !SVR4 */
		if (ioctl (ptyfd, I_PUSH, "ldterm") < 0) {
		    SysError (4);
		}
#ifdef SVR4			/* from Sony */
		if (ioctl (ptyfd, I_PUSH, "ttcompat") < 0) {
		    SysError (5);
		}
#endif /* SVR4 */
#endif /* I_PUSH */
		tty = ptyfd;
		close (screen->respond);
#ifdef TIOCSWINSZ
		/* tell tty how big window is */
#if OPT_TEK4014
		if(TEK4014_ACTIVE(screen)) {
			ws.ws_row = 24;
			ws.ws_col = 80;
			ws.ws_xpixel = TFullWidth(screen);
			ws.ws_ypixel = TFullHeight(screen);
		} else
#endif
		{
			ws.ws_row = screen->max_row + 1;
			ws.ws_col = screen->max_col + 1;
			ws.ws_xpixel = FullWidth(screen);
			ws.ws_ypixel = FullHeight(screen);
		}
#endif
#ifdef USE_ISPTS_FLAG
		} else {	/* else pty, not pts */
#endif
#endif /* USE_USG_PTYS */

#ifdef USE_HANDSHAKE		/* warning, goes for a long ways */
		/* close parent's sides of the pipes */
		close (cp_pipe[0]);
		close (pc_pipe[1]);

		/* Make sure that our sides of the pipes are not in the
		 * 0, 1, 2 range so that we don't fight with stdin, out
		 * or err.
		 */
		if (cp_pipe[1] <= 2) {
			if ((i = fcntl(cp_pipe[1], F_DUPFD, 3)) >= 0) {
				(void) close(cp_pipe[1]);
				cp_pipe[1] = i;
			}
		}
		if (pc_pipe[0] <= 2) {
			if ((i = fcntl(pc_pipe[0], F_DUPFD, 3)) >= 0) {
				(void) close(pc_pipe[0]);
				pc_pipe[0] = i;
			}
		}

		/* we don't need the socket, or the pty master anymore */
		close (ConnectionNumber(screen->display));
		close (screen->respond);

		/* Now is the time to set up our process group and
		 * open up the pty slave.
		 */
#ifdef	USE_SYSV_PGRP
#if defined(CRAY) && (OSMAJORVERSION > 5)
		(void) setsid();
#else
		(void) setpgrp();
#endif
#endif /* USE_SYSV_PGRP */

#if defined(__QNX__) && !defined(__QNXNTO__)
		qsetlogin( getlogin(), ttydev );
#endif
		while (1) {
#if defined(TIOCNOTTY) && (!defined(__GLIBC__) || (__GLIBC__ < 2) || ((__GLIBC__ == 2) && (__GLIBC_MINOR__ < 1)))
			if (!no_dev_tty && (tty = open ("/dev/tty", O_RDWR)) >= 0) {
				ioctl (tty, TIOCNOTTY, (char *) NULL);
				close (tty);
			}
#endif /* TIOCNOTTY && !glibc >= 2.1 */
#ifdef CSRG_BASED
			(void)revoke(ttydev);
#endif
			if ((tty = open(ttydev, O_RDWR, 0)) >= 0) {
#if defined(CRAY) && defined(TCSETCTTY)
			    /* make /dev/tty work */
			    ioctl(tty, TCSETCTTY, 0);
#endif
#ifdef	USE_SYSV_PGRP
				/* We need to make sure that we are acutally
				 * the process group leader for the pty.  If
				 * we are, then we should now be able to open
				 * /dev/tty.
				 */
				if ((i = open("/dev/tty", O_RDWR, 0)) >= 0) {
					/* success! */
					close(i);
					break;
				}
#else	/* USE_SYSV_PGRP */
				break;
#endif	/* USE_SYSV_PGRP */
			}
			perror("open ttydev");
#ifdef TIOCSCTTY
			ioctl(tty, TIOCSCTTY, 0);
#endif
			/* let our master know that the open failed */
			handshake.status = PTY_BAD;
			handshake.error = errno;
			strcpy(handshake.buffer, ttydev);
			write(cp_pipe[1], (char *) &handshake,
			    sizeof(handshake));

			/* get reply from parent */
			i = read(pc_pipe[0], (char *) &handshake,
			    sizeof(handshake));
			if (i <= 0) {
				/* parent terminated */
				exit(1);
			}

			if (handshake.status == PTY_NOMORE) {
				/* No more ptys, let's shutdown. */
				exit(1);
			}

			/* We have a new pty to try */
			free(ttydev);
			ttydev = (char *)malloc((unsigned)
			    (strlen(handshake.buffer) + 1));
			if (ttydev == NULL) {
			    SysError(ERROR_SPREALLOC);
			}
			strcpy(ttydev, handshake.buffer);
		}

		/* use the same tty name that everyone else will use
		 * (from ttyname)
		 */
		if ((ptr = ttyname(tty)) != 0)
		{
			/* it may be bigger */
			ttydev = (char *)realloc (ttydev,
				(unsigned) (strlen(ptr) + 1));
			if (ttydev == NULL) {
			    SysError(ERROR_SPREALLOC);
			}
			(void) strcpy(ttydev, ptr);
		}
#ifdef USE_ISPTS_FLAG
		} /* end of IsPts else clause */
#endif

#endif /* USE_HANDSHAKE -- from near fork */

#ifdef USE_TTY_GROUP
	{
		struct group *ttygrp;
		if ((ttygrp = getgrnam(TTY_GROUP_NAME)) != 0) {
			/* change ownership of tty to real uid, "tty" gid */
			set_owner (ttydev, screen->uid, ttygrp->gr_gid,
				   (resource.messages? 0620 : 0600));
		}
		else {
			/* change ownership of tty to real group and user id */
			set_owner (ttydev, screen->uid, screen->gid,
				   (resource.messages? 0622 : 0600));
		}
		endgrent();
	}
#else /* else !USE_TTY_GROUP */
		/* change ownership of tty to real group and user id */
		set_owner (ttydev, screen->uid, screen->gid,
			   (resource.messages? 0622 : 0600));
#endif /* USE_TTY_GROUP */

		/*
		 * set up the tty modes
		 */
		{
#if defined(USE_ANY_SYSV_TERMIO) || defined(USE_POSIX_TERMIOS)
#if defined(umips) || defined(CRAY) || defined(linux)
		    /* If the control tty had its modes screwed around with,
		       eg. by lineedit in the shell, or emacs, etc. then tio
		       will have bad values.  Let's just get termio from the
		       new tty and tailor it.  */
		    if (ioctl (tty, TCGETA, &tio) == -1)
		      SysError (ERROR_TIOCGETP);
		    tio.c_lflag |= ECHOE;
#endif /* umips */
		    /* Now is also the time to change the modes of the
		     * child pty.
		     */
		    /* input: nl->nl, don't ignore cr, cr->nl */
		    tio.c_iflag &= ~(INLCR|IGNCR);
		    tio.c_iflag |= ICRNL;
		    /* ouput: cr->cr, nl is not return, no delays, ln->cr/nl */
#ifndef USE_POSIX_TERMIOS
		    tio.c_oflag &=
		     ~(OCRNL|ONLRET|NLDLY|CRDLY|TABDLY|BSDLY|VTDLY|FFDLY);
#endif /* USE_POSIX_TERMIOS */
#ifdef ONLCR
		    tio.c_oflag |= ONLCR;
#endif /* ONLCR */
#ifdef OPOST
		    tio.c_oflag |= OPOST;
#endif /* OPOST */
#ifdef MINIX	/* should be ifdef _POSIX_SOURCE */
		    cfsetispeed(&tio, VAL_LINE_SPEED);
		    cfsetospeed(&tio, VAL_LINE_SPEED);
#else /* !MINIX */
#ifndef USE_POSIX_TERMIOS
# if defined(Lynx) && !defined(CBAUD)
#  define CBAUD V_CBAUD
# endif
		    tio.c_cflag &= ~(CBAUD);
#ifdef BAUD_0
		    /* baud rate is 0 (don't care) */
#elif defined(HAVE_TERMIO_C_ISPEED)
		    tio.c_ispeed = tio.c_ospeed = VAL_LINE_SPEED;
#else	/* !BAUD_0 */
		    tio.c_cflag |= VAL_LINE_SPEED;
#endif	/* !BAUD_0 */
#else /* USE_POSIX_TERMIOS */
		    cfsetispeed(&tio, VAL_LINE_SPEED);
		    cfsetospeed(&tio, VAL_LINE_SPEED);
#ifdef __MVS__
		    /* turn off bits that can't be set from the slave side */
		    tio.c_cflag &= ~(PACKET|PKT3270|PTU3270|PKTXTND);
#endif /* __MVS__ */
		    /* Clear CLOCAL so that SIGHUP is sent to us
		       when the xterm ends */
		    tio.c_cflag &= ~CLOCAL;
#endif /* USE_POSIX_TERMIOS */
#endif /* MINIX */
		    tio.c_cflag &= ~CSIZE;
		    if (screen->input_eight_bits)
			tio.c_cflag |= CS8;
		    else
			tio.c_cflag |= CS7;
		    /* enable signals, canonical processing (erase, kill, etc),
		    ** echo
		    */
		    tio.c_lflag |= ISIG|ICANON|ECHO|ECHOE|ECHOK;
#ifdef ECHOKE
		    tio.c_lflag |= ECHOKE|IEXTEN;
#endif
#ifdef ECHOCTL
		    tio.c_lflag |= ECHOCTL|IEXTEN;
#endif
#ifndef __MVS__
		    /* reset EOL to default value */
		    tio.c_cc[VEOL] = CEOL;			/* '^@@' */
		    /* certain shells (ksh & csh) change EOF as well */
		    tio.c_cc[VEOF] = CEOF;			/* '^D' */
#else
		    if(tio.c_cc[VEOL]==0) tio.c_cc[VEOL] = CEOL;			/* '^@@' */
		    if(tio.c_cc[VEOF]==0) tio.c_cc[VEOF] = CEOF;			/* '^D' */
#endif
#ifdef VLNEXT
		    tio.c_cc[VLNEXT] = CLNEXT;
#endif
#ifdef VWERASE
		    tio.c_cc[VWERASE] = CWERASE;
#endif
#ifdef VREPRINT
		    tio.c_cc[VREPRINT] = CRPRNT;
#endif
#ifdef VRPRNT
		    tio.c_cc[VRPRNT] = CRPRNT;
#endif
#ifdef VDISCARD
		    tio.c_cc[VDISCARD] = CFLUSH;
#endif
#ifdef VFLUSHO
		    tio.c_cc[VFLUSHO] = CFLUSH;
#endif
#ifdef VSTOP
		    tio.c_cc[VSTOP] = CSTOP;
#endif
#ifdef VSTART
		    tio.c_cc[VSTART] = CSTART;
#endif
#ifdef VSUSP
		    tio.c_cc[VSUSP] = CSUSP;
#endif
#ifdef VDSUSP
		    tio.c_cc[VDSUSP] = CDSUSP;
#endif
		    if (override_tty_modes) {
			/* sysv-specific */
			TMODE (XTTYMODE_intr, tio.c_cc[VINTR]);
			TMODE (XTTYMODE_quit, tio.c_cc[VQUIT]);
			TMODE (XTTYMODE_erase, tio.c_cc[VERASE]);
			TMODE (XTTYMODE_kill, tio.c_cc[VKILL]);
			TMODE (XTTYMODE_eof, tio.c_cc[VEOF]);
			TMODE (XTTYMODE_eol, tio.c_cc[VEOL]);
#ifdef VSWTCH
			TMODE (XTTYMODE_swtch, tio.c_cc[VSWTCH]);
#endif
#ifdef VSUSP
			TMODE (XTTYMODE_susp, tio.c_cc[VSUSP]);
#endif
#ifdef VDSUSP
			TMODE (XTTYMODE_dsusp, tio.c_cc[VDSUSP]);
#endif
#ifdef VREPRINT
			TMODE (XTTYMODE_rprnt, tio.c_cc[VREPRINT]);
#endif
#ifdef VRPRNT
			TMODE (XTTYMODE_rprnt, tio.c_cc[VRPRNT]);
#endif
#ifdef VDISCARD
			TMODE (XTTYMODE_flush, tio.c_cc[VDISCARD]);
#endif
#ifdef VFLUSHO
			TMODE (XTTYMODE_flush, tio.c_cc[VFLUSHO]);
#endif
#ifdef VWERASE
			TMODE (XTTYMODE_weras, tio.c_cc[VWERASE]);
#endif
#ifdef VLNEXT
			TMODE (XTTYMODE_lnext, tio.c_cc[VLNEXT]);
#endif
#ifdef VSTART
			TMODE (XTTYMODE_start, tio.c_cc[VSTART]);
#endif
#ifdef VSTOP
			TMODE (XTTYMODE_stop, tio.c_cc[VSTOP]);
#endif
#ifdef VSTATUS
			TMODE (XTTYMODE_status, tio.c_cc[VSTATUS]);
#endif
#ifdef HAS_LTCHARS
			/* both SYSV and BSD have ltchars */
			TMODE (XTTYMODE_susp, ltc.t_suspc);
			TMODE (XTTYMODE_dsusp, ltc.t_dsuspc);
			TMODE (XTTYMODE_rprnt, ltc.t_rprntc);
			TMODE (XTTYMODE_flush, ltc.t_flushc);
			TMODE (XTTYMODE_weras, ltc.t_werasc);
			TMODE (XTTYMODE_lnext, ltc.t_lnextc);
#endif
		    }

#ifdef HAS_LTCHARS
#ifdef __hpux
		    /* ioctl chokes when the "reserved" process group controls
		     * are not set to _POSIX_VDISABLE */
		    ltc.t_rprntc = ltc.t_rprntc = ltc.t_flushc =
		    ltc.t_werasc = ltc.t_lnextc = _POSIX_VDISABLE;
#endif /* __hpux */
		    if (ioctl (tty, TIOCSLTC, &ltc) == -1)
			    HsSysError(cp_pipe[1], ERROR_TIOCSETC);
#endif	/* HAS_LTCHARS */
#ifdef TIOCLSET
		    if (ioctl (tty, TIOCLSET, (char *)&lmode) == -1)
			    HsSysError(cp_pipe[1], ERROR_TIOCLSET);
#endif	/* TIOCLSET */
#ifndef USE_POSIX_TERMIOS
		    if (ioctl (tty, TCSETA, &tio) == -1)
			    HsSysError(cp_pipe[1], ERROR_TIOCSETP);
#else   /* USE_POSIX_TERMIOS */
		    if (tcsetattr (tty, TCSANOW, &tio) == -1)
			    HsSysError(cp_pipe[1], ERROR_TIOCSETP);
#endif  /* USE_POSIX_TERMIOS */
#else	/* USE_ANY_SYSV_TERMIO or USE_POSIX_TERMIOS */
		    sg.sg_flags &= ~(ALLDELAY | XTABS | CBREAK | RAW);
		    sg.sg_flags |= ECHO | CRMOD;
		    /* make sure speed is set on pty so that editors work right*/
		    sg.sg_ispeed = VAL_LINE_SPEED;
		    sg.sg_ospeed = VAL_LINE_SPEED;
		    /* reset t_brkc to default value */
		    tc.t_brkc = -1;
#ifdef LPASS8
		    if (screen->input_eight_bits)
			lmode |= LPASS8;
		    else
			lmode &= ~(LPASS8);
#endif
#ifdef sony
		    jmode &= ~KM_KANJI;
#endif /* sony */

		    ltc = d_ltc;

		    if (override_tty_modes) {
			TMODE (XTTYMODE_intr, tc.t_intrc);
			TMODE (XTTYMODE_quit, tc.t_quitc);
			TMODE (XTTYMODE_erase, sg.sg_erase);
			TMODE (XTTYMODE_kill, sg.sg_kill);
			TMODE (XTTYMODE_eof, tc.t_eofc);
			TMODE (XTTYMODE_start, tc.t_startc);
			TMODE (XTTYMODE_stop, tc.t_stopc);
			TMODE (XTTYMODE_brk, tc.t_brkc);
			/* both SYSV and BSD have ltchars */
			TMODE (XTTYMODE_susp, ltc.t_suspc);
			TMODE (XTTYMODE_dsusp, ltc.t_dsuspc);
			TMODE (XTTYMODE_rprnt, ltc.t_rprntc);
			TMODE (XTTYMODE_flush, ltc.t_flushc);
			TMODE (XTTYMODE_weras, ltc.t_werasc);
			TMODE (XTTYMODE_lnext, ltc.t_lnextc);
		    }

		    if (ioctl (tty, TIOCSETP, (char *)&sg) == -1)
			    HsSysError (cp_pipe[1], ERROR_TIOCSETP);
		    if (ioctl (tty, TIOCSETC, (char *)&tc) == -1)
			    HsSysError (cp_pipe[1], ERROR_TIOCSETC);
		    if (ioctl (tty, TIOCSETD, (char *)&discipline) == -1)
			    HsSysError (cp_pipe[1], ERROR_TIOCSETD);
		    if (ioctl (tty, TIOCSLTC, (char *)&ltc) == -1)
			    HsSysError (cp_pipe[1], ERROR_TIOCSLTC);
		    if (ioctl (tty, TIOCLSET, (char *)&lmode) == -1)
			    HsSysError (cp_pipe[1], ERROR_TIOCLSET);
#ifdef sony
		    if (ioctl (tty, TIOCKSET, (char *)&jmode) == -1)
			    HsSysError (cp_pipe[1], ERROR_TIOCKSET);
		    if (ioctl (tty, TIOCKSETC, (char *)&jtc) == -1)
			    HsSysError (cp_pipe[1], ERROR_TIOCKSETC);
#endif /* sony */
#endif	/* !USE_ANY_SYSV_TERMIO */
#if defined(TIOCCONS) || defined(SRIOCSREDIR)
		    if (Console) {
#ifdef TIOCCONS
			int on = 1;
			if (ioctl (tty, TIOCCONS, (char *)&on) == -1)
			    fprintf(stderr, "%s: cannot open console: %s\n",
				    xterm_name, strerror(errno));
#endif
#ifdef SRIOCSREDIR
			int fd = open("/dev/console",O_RDWR);
			if (fd == -1 || ioctl (fd, SRIOCSREDIR, tty) == -1)
			    fprintf(stderr, "%s: cannot open console: %s\n",
				    xterm_name, strerror(errno));
			(void) close (fd);
#endif
		    }
#endif	/* TIOCCONS */
		}
		signal (SIGCHLD, SIG_DFL);
#ifdef USE_SYSV_SIGHUP
		/* watch out for extra shells (I don't understand either) */
		signal (SIGHUP, SIG_DFL);
#else
		signal (SIGHUP, SIG_IGN);
#endif
		/* restore various signals to their defaults */
		signal (SIGINT, SIG_DFL);
		signal (SIGQUIT, SIG_DFL);
		signal (SIGTERM, SIG_DFL);

		/*
		 * If we're not asked to make the parent process set the
		 * terminal's erase mode, and if we had no ttyModes resource,
		 * then set the terminal's erase mode from our best guess.
		 */
#if OPT_INITIAL_ERASE
		TRACE(("check if we should set erase to %d:%s\n\tptyInitialErase:%d,\n\toveride_tty_modes:%d,\n\tXTTYMODE_erase:%d\n",
			initial_erase,
			(! resource.ptyInitialErase
			 && !override_tty_modes
			 && !ttymodelist[XTTYMODE_erase].set)
				? "YES" : "NO",
			resource.ptyInitialErase,
			override_tty_modes,
			ttymodelist[XTTYMODE_erase].set));
		if (! resource.ptyInitialErase
		 && !override_tty_modes
		 && !ttymodelist[XTTYMODE_erase].set) {
			int old_erase;
#ifdef USE_ANY_SYSV_TERMIO
			if (ioctl(tty, TCGETA, &tio) == -1)
				tio = d_tio;
			old_erase = tio.c_cc[VERASE];
			tio.c_cc[VERASE] = initial_erase;
			rc = ioctl(tty, TCSETA, &tio);
#elif defined(USE_POSIX_TERMIOS)
			if (tcgetattr(tty, &tio) == -1)
				tio = d_tio;
			old_erase = tio.c_cc[VERASE];
			tio.c_cc[VERASE] = initial_erase;
			rc = tcsetattr(tty, TCSANOW, &tio);
#else   /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
			if (ioctl(tty, TIOCGETP, (char *)&sg) == -1)
				sg = d_sg;
			old_erase = sg.sg_erase;
			sg.sg_erase = initial_erase;
			rc = ioctl(tty, TIOCSETP, (char *)&sg);
#endif	/* USE_ANY_SYSV_TERMIO */
			TRACE(("%s setting erase to %d (was %d)\n",
				rc ? "FAIL" : "OK", initial_erase, old_erase));
		}
#endif

		/* copy the environment before Setenving */
		for (i = 0 ; environ [i] != NULL ; i++)
		    ;
		/* compute number of xtermSetenv() calls below */
		envsize = 1;	/* (NULL terminating entry) */
		envsize += 3;	/* TERM, WINDOWID, DISPLAY */
#ifdef HAVE_UTMP
		envsize += 1;   /* LOGNAME */
#endif /* HAVE_UTMP */
#ifdef USE_SYSV_ENVVARS
		envsize += 2;	/* COLUMNS, LINES */
#ifdef HAVE_UTMP
		envsize += 2;   /* HOME, SHELL */
#endif /* HAVE_UTMP */
#ifdef OWN_TERMINFO_DIR
		envsize += 1;	/* TERMINFO */
#endif
#else /* USE_SYSV_ENVVARS */
		envsize += 1;	/* TERMCAP */
#endif /* USE_SYSV_ENVVARS */
		envnew = (char **) calloc ((unsigned) i + envsize, sizeof(char *));
		memmove( (char *)envnew, (char *)environ, i * sizeof(char *));
		environ = envnew;
		xtermSetenv ("TERM=", TermName);
		if(!TermName)
			*newtc = 0;

		sprintf (buf, "%lu",
			 ((unsigned long) XtWindow (XtParent(CURRENT_EMU(screen)))));
		xtermSetenv ("WINDOWID=", buf);

		/* put the display into the environment of the shell*/
		xtermSetenv ("DISPLAY=", XDisplayString (screen->display));

		signal(SIGTERM, SIG_DFL);

#ifndef AMOEBA
		/* this is the time to go and set up stdin, out, and err
		 */
		{
#if defined(CRAY) && (OSMAJORVERSION >= 6)
		    (void) close(tty);
		    (void) close(0);

		    if (open ("/dev/tty", O_RDWR)) {
			fprintf(stderr, "cannot open /dev/tty: %s\n", strerror(errno));
			exit(1);
		    }
		    (void) close(1);
		    (void) close(2);
		    dup(0);
		    dup(0);
#else
		    /* dup the tty */
		    for (i = 0; i <= 2; i++)
			if (i != tty) {
			    (void) close(i);
			    (void) dup(tty);
			}

#ifndef ATT
		    /* and close the tty */
		    if (tty > 2)
			(void) close(tty);
#endif
#endif /* CRAY */
		}

#if !defined(USE_SYSV_PGRP)
#ifdef TIOCSCTTY
		setsid();
		ioctl(0, TIOCSCTTY, 0);
#endif
		ioctl(0, TIOCSPGRP, (char *)&pgrp);
		setpgrp(0,0);
		close(open(ttydev, O_WRONLY, 0));
		setpgrp (0, pgrp);
#if defined(__QNX__)
		tcsetpgrp( 0, pgrp /*setsid()*/ );
#endif
#endif /* !USE_SYSV_PGRP */

#endif /* AMOEBA */

#ifdef Lynx
		{
		struct termio	t;
		if (ioctl(0, TCGETA, &t) >= 0)
		{
			/* this gets lost somewhere on our way... */
			t.c_oflag |= OPOST;
			ioctl(0, TCSETA, &t);
		}
		}
#endif

#ifdef HAVE_UTMP
		pw = getpwuid(screen->uid);
		login_name = NULL;
		if (pw && pw->pw_name) {
#ifdef HAVE_GETLOGIN
		    /*
		     * If the value from getlogin() differs from the value we
		     * get by looking in the password file, check if it does
		     * correspond to the same uid.  If so, allow that as an
		     * alias for the uid.
		     *
		     * Of course getlogin() will fail if we're started from
		     * a window-manager, since there's no controlling terminal
		     * to fuss with.  In that case, try to get something useful
		     * from the user's $LOGNAME or $USER environment variables.
		     */
		    if (((login_name = getlogin()) != NULL
		      || (login_name = getenv("LOGNAME")) != NULL
		      || (login_name = getenv("USER")) != NULL)
		     && strcmp(login_name, pw->pw_name)) {
			struct passwd *pw2 = getpwnam(login_name);
			if (pw2 != 0
			 && pw->pw_uid != pw2->pw_uid) {
			    login_name = NULL;
			}
		    }
#endif
		    if (login_name == NULL)
			login_name = pw->pw_name;
		    if (login_name != NULL)
			login_name = x_strdup(login_name);
		}
		if (login_name != NULL) {
		    xtermSetenv ("LOGNAME=", login_name); /* for POSIX */
		}
#ifdef USE_SYSV_UTMP
		/* Set up our utmp entry now.  We need to do it here
		** for the following reasons:
		**   - It needs to have our correct process id (for
		**     login).
		**   - If our parent was to set it after the fork(),
		**     it might make it out before we need it.
		**   - We need to do it before we go and change our
		**     user and group id's.
		*/
		(void) setutent ();
		/* set up entry to search for */
		bzero((char *)&utmp, sizeof(utmp));
		(void) strncpy(utmp.ut_id, my_utmp_id(ttydev), sizeof (utmp.ut_id));

		utmp.ut_type = DEAD_PROCESS;

		/* position to entry in utmp file */
		/* Test return value: beware of entries left behind: PSz 9 Mar 00 */
		if (! ( utret = getutid(&utmp) ) ) {
		    (void) setutent();
		    utmp.ut_type = USER_PROCESS;
		    if (! ( utret = getutid(&utmp) ) ) {
			(void) setutent();
		    }
		}
#if OPT_TRACE
		if ( ! utret )
		    TRACE(("getutid: NULL\n"));
		else
		    TRACE(("getutid: pid=%d type=%d user=%s line=%s id=%s\n",
			utret->ut_pid, utret->ut_type, utret->ut_user,
			utret->ut_line, utret->ut_id));
#endif

		/* set up the new entry */
		utmp.ut_type = USER_PROCESS;
#ifdef HAVE_UTMP_UT_XSTATUS
		utmp.ut_xstatus = 2;
#endif
		(void) strncpy(utmp.ut_user,
			       (login_name != NULL) ? login_name : "????",
			       sizeof(utmp.ut_user));

		/* why are we copying this string again?  (see above) */
		(void) strncpy(utmp.ut_id, my_utmp_id(ttydev), sizeof(utmp.ut_id));
		(void) strncpy (utmp.ut_line,
			my_pty_name(ttydev), sizeof (utmp.ut_line));

#ifdef HAVE_UTMP_UT_HOST
		(void) strncpy(buf, DisplayString(screen->display),
			       sizeof(buf));
#ifndef linux
		{
		    char *disfin = strrchr(buf, ':');
		    if (disfin)
			*disfin = '\0';
		}
#endif
		(void) strncpy(utmp.ut_host, buf, sizeof(utmp.ut_host));
#endif
		(void) strncpy(utmp.ut_name, login_name, sizeof(utmp.ut_name));

		utmp.ut_pid = getpid();
#if defined(HAVE_UTMP_UT_XTIME)
#if defined(HAVE_UTMP_UT_SESSION)
		utmp.ut_session = getsid(0);
#endif
		utmp.ut_xtime = time ((time_t *) 0);
		utmp.ut_tv.tv_usec = 0;
#else
		utmp.ut_time = time ((time_t *) 0);
#endif

		/* write out the entry */
		if (!resource.utmpInhibit) {
		    errno = 0;
		    pututline(&utmp);
		    TRACE(("pututline: %d %d %s\n",
			resource.utmpInhibit,
			errno, strerror(errno)));
		}
#ifdef WTMP
#if defined(SVR4) || defined(SCO325)
		if (term->misc.login_shell)
		    updwtmpx(WTMPX_FILE, &utmp);
#elif defined(linux) && defined(__GLIBC__) && (__GLIBC__ >= 2) && !(defined(__powerpc__) && (__GLIBC__ == 2) && (__GLIBC_MINOR__ == 0))
		if (term->misc.login_shell)
		    updwtmp(etc_wtmp, &utmp);
#else
		if (term->misc.login_shell &&
		     (i = open(etc_wtmp, O_WRONLY|O_APPEND)) >= 0) {
		    write(i, (char *)&utmp, sizeof(utmp));
		    close(i);
		}
#endif
#endif
		/* close the file */
		(void) endutent();

#else	/* USE_SYSV_UTMP */
		/* We can now get our ttyslot!  We can also set the initial
		 * utmp entry.
		 */
		tslot = ttyslot();
		added_utmp_entry = False;
		{
			if (pw && !resource.utmpInhibit &&
			    (i = open(etc_utmp, O_WRONLY)) >= 0) {
				bzero((char *)&utmp, sizeof(utmp));
				(void) strncpy(utmp.ut_line,
					       my_pty_name(ttydev),
					       sizeof(utmp.ut_line));
				(void) strncpy(utmp.ut_name, login_name,
					       sizeof(utmp.ut_name));
#ifdef MINIX
				utmp.ut_pid = getpid();
				utmp.ut_type = USER_PROCESS;
#endif /* MINIX */
#ifdef HAVE_UTMP_UT_HOST
				(void) strncpy(utmp.ut_host,
					       XDisplayString (screen->display),
					       sizeof(utmp.ut_host));
#endif
				/* cast needed on Ultrix 4.4 */
				time((time_t*)&utmp.ut_time);
				lseek(i, (long)(tslot * sizeof(utmp)), 0);
				write(i, (char *)&utmp, sizeof(utmp));
				close(i);
				added_utmp_entry = True;
#if defined(WTMP)
				if (term->misc.login_shell &&
				(i = open(etc_wtmp, O_WRONLY|O_APPEND)) >= 0) {
				    int status;
				    status = write(i, (char *)&utmp,
						   sizeof(utmp));
				    status = close(i);
				}
#elif defined(MNX_LASTLOG)
				if (term->misc.login_shell &&
				(i = open(_U_LASTLOG, O_WRONLY)) >= 0) {
				    lseek(i, (long)(screen->uid *
					sizeof (utmp)), 0);
				    write(i, (char *)&utmp, sizeof (utmp));
				    close(i);
				}
#endif /* WTMP or MNX_LASTLOG */
			} else
				tslot = -tslot;
		}

		/* Let's pass our ttyslot to our parent so that it can
		 * clean up after us.
		 */
#ifdef USE_HANDSHAKE
		handshake.tty_slot = tslot;
#endif /* USE_HANDSHAKE */
#endif /* USE_SYSV_UTMP */

#ifdef USE_LASTLOG
		if (term->misc.login_shell &&
		(i = open(etc_lastlog, O_WRONLY)) >= 0) {
		    bzero((char *)&lastlog, sizeof (struct lastlog));
		    (void) strncpy(lastlog.ll_line,
		        my_pty_name(ttydev),
			sizeof (lastlog.ll_line));
		    (void) strncpy(lastlog.ll_host,
			  XDisplayString (screen->display),
			  sizeof (lastlog.ll_host));
		    time(&lastlog.ll_time);
		    lseek(i, (long)(screen->uid *
			sizeof (struct lastlog)), 0);
		    write(i, (char *)&lastlog,
			sizeof (struct lastlog));
		    close(i);
		}
#endif /* USE_LASTLOG */

#ifdef __OpenBSD__
		/* Switch to real gid after writing utmp entry */
		utmpGid = getegid();
		if (getgid() != getegid()) {
			utmpGid = getegid();
			setegid(getgid());
		}
#endif
			

#ifdef USE_HANDSHAKE
		/* Let our parent know that we set up our utmp entry
		 * so that it can clean up after us.
		 */
		handshake.status = UTMP_ADDED;
		handshake.error = 0;
		strcpy(handshake.buffer, ttydev);
		(void)write(cp_pipe[1], (char *)&handshake, sizeof(handshake));
#endif /* USE_HANDSHAKE */
#endif/* HAVE_UTMP */

		(void) setgid (screen->gid);
#ifdef HAS_BSD_GROUPS
		if (geteuid() == 0 && pw) {
		    if (initgroups (login_name, pw->pw_gid)) {
			perror( "initgroups failed" );
			exit (errno);
		    }
		}
#endif
		if (setuid (screen->uid)) {
			perror( "setuid failed" );
			exit (errno);
		}

#ifdef USE_HANDSHAKE
		/* mark the pipes as close on exec */
		fcntl(cp_pipe[1], F_SETFD, 1);
		fcntl(pc_pipe[0], F_SETFD, 1);

		/* We are at the point where we are going to
		 * exec our shell (or whatever).  Let our parent
		 * know we arrived safely.
		 */
		handshake.status = PTY_GOOD;
		handshake.error = 0;
		(void)strcpy(handshake.buffer, ttydev);
		(void)write(cp_pipe[1], (char *)&handshake, sizeof(handshake));

		if (waiting_for_initial_map) {
		    i = read (pc_pipe[0], (char *) &handshake,
			      sizeof(handshake));
		    if (i != sizeof(handshake) ||
			handshake.status != PTY_EXEC) {
			/* some very bad problem occurred */
			exit (ERROR_PTY_EXEC);
		    }
		    if(handshake.rows > 0 && handshake.cols > 0) {
			screen->max_row = handshake.rows;
			screen->max_col = handshake.cols;
#if defined(TIOCSSIZE) && (defined(sun) && !defined(SVR4))
			ts.ts_lines = screen->max_row + 1;
			ts.ts_cols = screen->max_col + 1;
#elif defined(TIOCSWINSZ)
			ws.ws_row = screen->max_row + 1;
			ws.ws_col = screen->max_col + 1;
			ws.ws_xpixel = FullWidth(screen);
			ws.ws_ypixel = FullHeight(screen);
#endif /* sun vs TIOCSWINSZ */
		    }
		}
#endif /* USE_HANDSHAKE */

#ifdef USE_SYSV_ENVVARS
		{
		char numbuf[12];
		sprintf (numbuf, "%d", screen->max_col + 1);
		xtermSetenv("COLUMNS=", numbuf);
		sprintf (numbuf, "%d", screen->max_row + 1);
		xtermSetenv("LINES=", numbuf);
		}
#ifdef HAVE_UTMP
		if (pw) {	/* SVR4 doesn't provide these */
		    if (!getenv("HOME"))
			xtermSetenv("HOME=", pw->pw_dir);
		    if (!getenv("SHELL"))
			xtermSetenv("SHELL=", pw->pw_shell);
		}
#endif /* HAVE_UTMP */
#ifdef OWN_TERMINFO_DIR
		xtermSetenv("TERMINFO=", OWN_TERMINFO_DIR);
#endif
#else /* USE_SYSV_ENVVARS */
		if(!TEK4014_ACTIVE(screen) && *newtc) {
		    strcpy (termcap, newtc);
		    resize (screen, termcap, newtc);
		}
		if (term->misc.titeInhibit && !term->misc.tiXtraScroll) {
		    remove_termcap_entry (newtc, "ti=");
		    remove_termcap_entry (newtc, "te=");
		}
		/*
		 * work around broken termcap entries */
		if (resource.useInsertMode)	{
		    remove_termcap_entry (newtc, "ic=");
		    /* don't get duplicates */
		    remove_termcap_entry (newtc, "im=");
		    remove_termcap_entry (newtc, "ei=");
		    remove_termcap_entry (newtc, "mi");
		    if(*newtc)
			strcat (newtc, ":im=\\E[4h:ei=\\E[4l:mi:");
		}
		if (*newtc) {
#if OPT_INITIAL_ERASE
		    unsigned len;
		    remove_termcap_entry (newtc, TERMCAP_ERASE "=");
		    len = strlen(newtc);
		    if (len != 0 && newtc[len-1] == ':')
			len--;
		    sprintf(newtc + len, ":%s=\\%03o:", TERMCAP_ERASE, initial_erase & 0377);
#endif
		    xtermSetenv ("TERMCAP=", newtc);
		}
#endif /* USE_SYSV_ENVVARS */


		/* need to reset after all the ioctl bashing we did above */
#if defined(TIOCSSIZE) && (defined(sun) && !defined(SVR4))
		i = ioctl (0, TIOCSSIZE, &ts);
		TRACE(("spawn TIOCSSIZE %dx%d return %d\n", ts.ts_lines, ts.ts_cols, i));
#elif defined(TIOCSWINSZ)
		i = ioctl (0, TIOCSWINSZ, (char *)&ws);
		TRACE(("spawn TIOCSWINSZ %dx%d return %d\n", ws.ws_row, ws.ws_col, i));
#else
		TRACE(("spawn cannot tell pty its size\n"));
#endif	/* sun vs TIOCSWINSZ */
		signal(SIGHUP, SIG_DFL);
		if (command_to_exec) {
			TRACE(("spawning command \"%s\"\n", *command_to_exec));
			execvp(*command_to_exec, command_to_exec);
			/* print error message on screen */
			fprintf(stderr, "%s: Can't execvp %s: %s\n",
				xterm_name, *command_to_exec, strerror(errno));
		}

#ifdef USE_SYSV_SIGHUP
		/* fix pts sh hanging around */
		signal (SIGHUP, SIG_DFL);
#endif

#ifdef HAVE_UTMP
		if(((ptr = getenv("SHELL")) == NULL || *ptr == 0) &&
		 ((pw == NULL && (pw = getpwuid(screen->uid)) == NULL) ||
		 *(ptr = pw->pw_shell) == 0))
#else	/* HAVE_UTMP */
		if(((ptr = getenv("SHELL")) == NULL || *ptr == 0) &&
		 ((pw = getpwuid(screen->uid)) == NULL ||
		 *(ptr = pw->pw_shell) == 0))
#endif	/* HAVE_UTMP */
			ptr = "/bin/sh";
		shname = x_basename(ptr);
		shname_minus = (char *)malloc(strlen(shname) + 2);
		(void) strcpy(shname_minus, "-");
		(void) strcat(shname_minus, shname);
#if !defined(USE_ANY_SYSV_TERMIO) && !defined(USE_POSIX_TERMIOS)
		ldisc = XStrCmp("csh", shname + strlen(shname) - 3) == 0 ?
		 NTTYDISC : 0;
		ioctl(0, TIOCSETD, (char *)&ldisc);
#endif	/* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */

#ifdef USE_LOGIN_DASH_P
		if (term->misc.login_shell && pw && added_utmp_entry)
		  execl (bin_login, "login", "-p", "-f", login_name, 0);
#endif
		execlp (ptr, (term->misc.login_shell ? shname_minus : shname),
			(void *)0);

		/* Exec failed. */
		fprintf (stderr, "%s: Could not exec %s: %s\n", xterm_name,
			ptr, strerror(errno));
		(void) sleep(5);
		exit(ERROR_EXEC);
	    }				/* end if in child after fork */

#ifdef USE_HANDSHAKE
	    /* Parent process.  Let's handle handshaked requests to our
	     * child process.
	     */

	    /* close childs's sides of the pipes */
	    close (cp_pipe[1]);
	    close (pc_pipe[0]);

	    for (done = 0; !done; ) {
		if (read(cp_pipe[0], (char *) &handshake, sizeof(handshake)) <= 0) {
			/* Our child is done talking to us.  If it terminated
			 * due to an error, we will catch the death of child
			 * and clean up.
			 */
			break;
		}

		switch(handshake.status) {
		case PTY_GOOD:
			/* Success!  Let's free up resources and
			 * continue.
			 */
			done = 1;
			break;

		case PTY_BAD:
			/* The open of the pty failed!  Let's get
			 * another one.
			 */
			(void) close(screen->respond);
			if (get_pty(&screen->respond)) {
			    /* no more ptys! */
			    fprintf(stderr,
				    "%s: child process can find no available ptys: %s\n",
				    xterm_name, strerror(errno));
			    handshake.status = PTY_NOMORE;
			    write(pc_pipe[1], (char *) &handshake, sizeof(handshake));
			    exit (ERROR_PTYS);
			}
			handshake.status = PTY_NEW;
			(void) strcpy(handshake.buffer, ttydev);
			write(pc_pipe[1], (char *) &handshake, sizeof(handshake));
			break;

		case PTY_FATALERROR:
			errno = handshake.error;
			close(cp_pipe[0]);
			close(pc_pipe[1]);
			SysError(handshake.fatal_error);

		case UTMP_ADDED:
			/* The utmp entry was set by our slave.  Remember
			 * this so that we can reset it later.
			 */
			added_utmp_entry = True;
#ifndef	USE_SYSV_UTMP
			tslot = handshake.tty_slot;
#endif	/* USE_SYSV_UTMP */
			free(ttydev);
			ttydev = x_strdup(handshake.buffer);
			break;
		default:
			fprintf(stderr, "%s: unexpected handshake status %d\n",
				xterm_name, handshake.status);
		}
	    }
	    /* close our sides of the pipes */
	    if (!waiting_for_initial_map) {
		close (cp_pipe[0]);
		close (pc_pipe[1]);
	    }
#endif /* USE_HANDSHAKE */
	}				/* end if no slave */

	/*
	 * still in parent (xterm process)
	 */

#ifdef USE_SYSV_SIGHUP
	/* hung sh problem? */
	signal (SIGHUP, SIG_DFL);
#else
	signal (SIGHUP, SIG_IGN);
#endif

/*
 * Unfortunately, System V seems to have trouble divorcing the child process
 * from the process group of xterm.  This is a problem because hitting the
 * INTR or QUIT characters on the keyboard will cause xterm to go away if we
 * don't ignore the signals.  This is annoying.
 */

#if defined(USE_SYSV_SIGNALS) && !defined(SIGTSTP)
	signal (SIGINT, SIG_IGN);

#ifndef SYSV
	/* hung shell problem */
	signal (SIGQUIT, SIG_IGN);
#endif
	signal (SIGTERM, SIG_IGN);
#elif defined(SYSV) || defined(__osf__)
	/* if we were spawned by a jobcontrol smart shell (like ksh or csh),
	 * then our pgrp and pid will be the same.  If we were spawned by
	 * a jobcontrol dumb shell (like /bin/sh), then we will be in our
	 * parent's pgrp, and we must ignore keyboard signals, or we will
	 * tank on everything.
	 */
	if (getpid() == getpgrp()) {
	    (void) signal(SIGINT, Exit);
	    (void) signal(SIGQUIT, Exit);
	    (void) signal(SIGTERM, Exit);
	} else {
	    (void) signal(SIGINT, SIG_IGN);
	    (void) signal(SIGQUIT, SIG_IGN);
	    (void) signal(SIGTERM, SIG_IGN);
	}
	(void) signal(SIGPIPE, Exit);
#else	/* SYSV */
	signal (SIGINT, Exit);
	signal (SIGQUIT, Exit);
	signal (SIGTERM, Exit);
	signal (SIGPIPE, Exit);
#endif /* USE_SYSV_SIGNALS and not SIGTSTP */

	return 0;
}							/* end spawn */
#else  /* AMOEBA */
/* manifest constants */
#define	TTY_NTHREADS		2
#define	TTY_INQSIZE		2000
#define	TTY_OUTQSIZE		1000
#define	TTY_THREAD_STACKSIZE	4096

#define	XWATCHDOG_THREAD_SIZE	4096

/* acceptable defaults */
#define	DEF_HOME		"/home"
#define	DEF_SHELL		"/bin/sh"
#define	DEF_PATH		"/bin:/usr/bin:/profile/util"

extern capability ttycap;
extern char **environ;
extern struct caplist *capv;

/*
 * Set capability.
 * I made this a function since it cannot be a macro.
 */
void
setcap(struct caplist *capvec, int n, char *name, capability *cap)
{
    capvec[n].cl_name = name;
    capvec[n].cl_cap = cap;
}

/*
 * Find process descriptor for specified program,
 * necessarily running down the user's PATH.
 */
errstat
find_program(char *program, capability *programcap)
{
    errstat err;

    if ((err = name_lookup(program, programcap)) != STD_OK) {
	char *path, *name;
	char programpath[1024];

	if ((path = getenv("PATH")) == NULL)
	    path = DEF_PATH;
	name = x_basename(program);

	do {
	    register char *p = programpath;
	    register char *n = name;
	    char *c1 = path;

	    while (*path && *path != ':')
		*p++ = *path++;
	    if (path != c1) *p++ = '/';
	    if (*path) path++;
	    while (*n) *p++ = *n++;
	    *p = '\0';
	    if ((err = name_lookup(programpath, programcap)) == STD_OK)
		break;
	} while (*path);
    }
    return err;
}

/* Semaphore on which the main thread blocks until it can do something
 * useful (which is made known by a call to WakeupMainThread()).
 */
static semaphore main_sema;

void
InitMainThread(void)
{
    sema_init(&main_sema, 0);
}

void
WakeupMainThread(void)
{
    sema_up(&main_sema);
}

/*
 * Spawn off tty threads and fork the login process.
 */
static int spawn(void)
{
    register TScreen *screen = &term->screen;
    char *TermName = NULL;
    char termcap[TERMCAP_SIZE];
    char newtc[TERMCAP_SIZE];
    char **envnew;		/* new environment */
    int envsize;		/* elements in new environment */
    char *ptr;
    int i, n, ncap;
    errstat err;
    struct caplist *cl;
    char buf[64];
    struct caplist *capvnew;
    int ttythread();
    int xwatchdogthread();

    screen->pid = 2;		/* at least > 1 */
    screen->uid = getuid();
    screen->gid = getgid();
    screen->respond = OPEN_MAX + 1;
    screen->tty_inq = cb_alloc(TTY_INQSIZE);
    screen->tty_outq = cb_alloc(TTY_OUTQSIZE);

    InitMainThread();
    if (!thread_newthread(xwatchdogthread, XWATCHDOG_THREAD_SIZE, 0, 0)) {
	fprintf(stderr, "%s:  unable to start tty thread.\n", ProgramName);
	Exit(1);
    }

    /*
     * Start tty threads. Ordinarily two should suffice, one for standard
     * input and one for standard (error) output.
     */
    ttyinit((char *) NULL);
    for (i = 0; i < TTY_NTHREADS; i++) {
	if (!thread_newthread(ttythread, TTY_THREAD_STACKSIZE, 0, 0)) {
	    fprintf(stderr, "%s:  unable to start tty thread.\n", ProgramName);
	    Exit(1);
	}
    }

    /* avoid double MapWindow requests */
    XtSetMappedWhenManaged( XtParent(CURRENT_EMU(screen)), False );
    wm_delete_window = XInternAtom(XtDisplay(toplevel), "WM_DELETE_WINDOW",
					False);

    /* realize now so know window size for tty driver */
    if (!TEK4014_ACTIVE(screen)) VTInit();

#if OPT_TEK4014
    if (screen->TekEmu) {
	envnew = tekterm;
	ptr = newtc;
    } else
#endif
    {
	envnew = vtterm;
	ptr = termcap;
    }

    get_termcap(TermName = resource.term_name, ptr, newtc);

    if (!TermName) {
	TermName = *envnew;
	while (*envnew != NULL) {
	    if (get_termcap(*envnew, ptr, newtc)) {
		TermName = *envnew;
		break;
	    }
	    envnew++;
	}
    }

    /*
     * Setup new capability environment. The whole point of the game is
     * to redirect the shell's stdin/stdout/stderr and tty to our own
     * tty server instead of the initial one.
     */
    for (ncap = 4, cl = capv; cl->cl_name != (char *)NULL; cl++)
	if (strcmp("STDIN", cl->cl_name) && strcmp("STDOUT", cl->cl_name)
	  && strcmp("STDERR", cl->cl_name) && strcmp("TTY", cl->cl_name))
	    ncap++;

    capvnew = (struct caplist *)
	calloc((unsigned) ncap + 1, sizeof(struct caplist));
    setcap(capvnew, 0, "STDIN", &ttycap);
    setcap(capvnew, 1, "STDOUT", &ttycap);
    setcap(capvnew, 2, "STDERR", &ttycap);
    setcap(capvnew, 3, "TTY", &ttycap);
    for (n = 4, cl = capv; cl->cl_name != (char *) NULL; cl++) {
	if (strcmp("STDIN", cl->cl_name)
	  && strcmp("STDOUT", cl->cl_name)
	  && strcmp("STDERR", cl->cl_name)
	  && strcmp("TTY", cl->cl_name))
	    setcap(capvnew, n++, cl->cl_name, cl->cl_cap);
    }
    setcap(capvnew, ncap, (char *)NULL, (capability *)NULL);
    if (n != ncap) {
	fprintf(stderr, "%s: bad capability set.\n", ProgramName);
	Exit(1);
    }

    /*
     * Setup environment variables. We add some extra ones to denote
     * window id, terminal type, display name, termcap entry, and some
     * standard one (which are required by every shell) HOME and SHELL.
     * Note that the two shell variables COLUMNS and LINES are not needed
     * under Amoeba since the tty server provides an RPC to query the
     * window sizes.
     */
    /* copy the environment before Setenving */
    for (i = 0 ; environ[i] != NULL ; i++)
	;

    /* compute number of xtermSetenv() calls below */
    envsize = 1;	/* (NULL terminating entry) */
    envsize += 3;	/* TERM, WINDOWID, DISPLAY */
    envsize += 2;	/* HOME, SHELL */
    envsize += 1;	/* TERMCAP */
    envnew = (char **) calloc ((unsigned) i + envsize, sizeof(char *));
    bcopy((char *)environ, (char *)envnew, i * sizeof(char *));
    environ = envnew;
    xtermSetenv ("TERM=", TermName);
    if(!TermName) *newtc = 0;

    sprintf (buf, "%lu",
	((unsigned long) XtWindow (XtParent(CURRENT_EMU(screen)))));
    xtermSetenv ("WINDOWID=", buf);

    /* put the display into the environment of the shell*/
    xtermSetenv ("DISPLAY=", XDisplayString (screen->display));

    /* always provide a HOME and SHELL definition */
    if (!getenv("HOME")) xtermSetenv("HOME=", DEF_HOME);
    if (!getenv("SHELL")) xtermSetenv("SHELL=", DEF_SHELL);

    if(!TEK4014_ACTIVE(screen) && *newtc) {
	strcpy (termcap, newtc);
	resize (screen, termcap, newtc);
    }
    if (term->misc.titeInhibit && !term->misc.tiXtraScroll) {
	remove_termcap_entry (newtc, "ti=");
	remove_termcap_entry (newtc, "te=");
    }
    /* work around broken termcap entries */
    if (resource.useInsertMode) {
	remove_termcap_entry (newtc, "ic=");
	/* don't get duplicates */
	remove_termcap_entry (newtc, "im=");
	remove_termcap_entry (newtc, "ei=");
	remove_termcap_entry (newtc, "mi");
	if (*newtc)
	    strcat (newtc, ":im=\\E[4h:ei=\\E[4l:mi:");
    }
    if (*newtc)
	xtermSetenv ("TERMCAP=", newtc);

    /*
     * Execute specified program or shell. Use find_program to
     * simulate the same behaviour as the original execvp.
     */
    if (command_to_exec) {
	capability programcap;

	if (find_program(*command_to_exec, &programcap) != STD_OK) {
	    fprintf(stderr, "%s: Could not find %s!\n",
		xterm_name, *command_to_exec);
	    exit(ERROR_EXEC);
	}

	err = exec_file(&programcap, NILCAP, &ttycap, 0,
	    command_to_exec, envnew, capvnew, &screen->proccap);
	if (err != STD_OK) {
	    fprintf(stderr, "%s: Could not exec %s!\n",
		xterm_name, *command_to_exec);
	    exit(ERROR_EXEC);
	}
    } else {
	char *shell, *shname, *shname_minus;
	capability shellcap;
	char *argvec[2];

	if ((shell = getenv("SHELL")) == NULL)
	    shell = DEF_SHELL; /* "cannot happen" */
	shname = x_basename(shell);
	shname_minus = malloc(strlen(shname) + 2);
	(void) strcpy(shname_minus, "-");
	(void) strcat(shname_minus, shname);

	argvec[0] = term->misc.login_shell ? shname_minus : shname;
	argvec[1] = NULL;

	if (find_program(shell, &shellcap) != STD_OK) {
	    fprintf(stderr, "%s: Could not find %s!\n", xterm_name, shell);
	    exit(ERROR_EXEC);
	}

	err = exec_file(&shellcap, NILCAP, &ttycap, 0, argvec,
	    envnew, capvnew, &screen->proccap);
	if (err != STD_OK) {
	    fprintf(stderr, "%s: Could not exec %s!\n", xterm_name, shell);
	    exit(ERROR_EXEC);
	}

	free(shname_minus);
    }
    free(capvnew);

    signal(SIGINT, SIG_IGN);
    signal(SIGQUIT, SIG_IGN);
    signal(SIGTERM, SIG_IGN);
    signal(SIGPIPE, Exit);
    return 0;
}

/*
 * X watch-dog thread. This thread unblocks the main
 * thread when there's an X event.
 */
xwatchdogthread(void)
{
    register TScreen *screen = &term->screen;

    for (;;) {
	int n = _X11TransAmSelect(ConnectionNumber(screen->display), 10);
	if (n < 0 && errno != EINTR) {
	    fprintf(stderr, "%s: X watch dog: Xselect failed: %s\n",
		ProgramName, SysErrorMsg(errno));
	    Cleanup(1);
	} else if (n > 0)
	    WakeupMainThread();
	threadswitch();
    }
}

void
SleepMainThread(void)
{
    int remaining;

    /* Wait for at least one event */
    sema_down(&main_sema);

    /* Since the main thread will continue handling all outstanding events
     * shortly, we can ignore the remaining wakeups that were done.
     */
    if ((remaining = sema_level(&main_sema)) > 1) {
	sema_mdown(&main_sema, remaining);
    }
}
#endif /* AMOEBA */

SIGNAL_T
Exit(int n)
{
	register TScreen *screen = &term->screen;

#ifdef USE_UTEMPTER
	if (!resource.utmpInhibit && added_utmp_entry)
	    removeFromUtmp();
#elif defined(HAVE_UTMP)
#ifdef USE_SYSV_UTMP
#if defined(UTMPX_FOR_UTMP)
	struct utmpx utmp;
	struct utmpx *utptr;
#else
	struct utmp utmp;
	struct utmp *utptr;
#endif
#if defined(WTMP) && !defined(SVR4) && !(defined(linux) && defined(__GLIBC__) && (__GLIBC__ >= 2) && !(defined(__powerpc__) && (__GLIBC__ == 2) && (__GLIBC_MINOR__ == 0)))
	int fd;			/* for /etc/wtmp */
#endif

	/* don't do this more than once */
	if (xterm_exiting)
	    SIGNAL_RETURN;
	xterm_exiting = True;

#ifdef PUCC_PTYD
	closepty(ttydev, ptydev, (resource.utmpInhibit ?  OPTY_NOP : OPTY_LOGIN), screen->respond);
#endif /* PUCC_PTYD */

	/* cleanup the utmp entry we forged earlier */
	if (!resource.utmpInhibit
#ifdef USE_HANDSHAKE		/* without handshake, no way to know */
	    && added_utmp_entry
#endif /* USE_HANDSHAKE */
	    ) {
#ifdef __OpenBSD__
	    if (utmpGid != -1) {
		/* Switch back to group utmp */
		setegid(utmpGid);
	    }
#endif
	    utmp.ut_type = USER_PROCESS;
	    (void) strncpy(utmp.ut_id, my_utmp_id(ttydev), sizeof(utmp.ut_id));
	    (void) setutent();
	    utptr = getutid(&utmp);
	    /* write it out only if it exists, and the pid's match */
	    if (utptr && (utptr->ut_pid == screen->pid)) {
		    utptr->ut_type = DEAD_PROCESS;
#if defined(HAVE_UTMP_UT_XTIME)
#if defined(HAVE_UTMP_UT_SESSION)
		    utptr->ut_session = getsid(0);
#endif
		    utptr->ut_xtime = time ((time_t *) 0);
		    utptr->ut_tv.tv_usec = 0;
#else
		    *utptr->ut_user = 0;
		    utptr->ut_time = time((time_t *) 0);
#endif
		    (void) pututline(utptr);
#ifdef WTMP
#if defined(SVR4) || defined(SCO325)
		    if (term->misc.login_shell)
			updwtmpx(WTMPX_FILE, utptr);
#elif defined(linux) && defined(__GLIBC__) && (__GLIBC__ >= 2) && !(defined(__powerpc__) && (__GLIBC__ == 2) && (__GLIBC_MINOR__ == 0))
		    strncpy (utmp.ut_line, utptr->ut_line, sizeof (utmp.ut_line));
		    if (term->misc.login_shell)
			updwtmp(etc_wtmp, utptr);
#else
		    /* set wtmp entry if wtmp file exists */
		    if (term->misc.login_shell &&
			(fd = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
			write(fd, utptr, sizeof(*utptr));
			close(fd);
		    }
#endif
#endif

	    }
	    (void) endutent();
	}
#else	/* not USE_SYSV_UTMP */
	register int wfd;
	struct utmp utmp;

	if (!resource.utmpInhibit && added_utmp_entry &&
	    (am_slave < 0 && tslot > 0 && (wfd = open(etc_utmp, O_WRONLY)) >= 0)){
		bzero((char *)&utmp, sizeof(utmp));
		lseek(wfd, (long)(tslot * sizeof(utmp)), 0);
		write(wfd, (char *)&utmp, sizeof(utmp));
		close(wfd);
#ifdef WTMP
		if (term->misc.login_shell &&
		    (wfd = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
			(void) strncpy(utmp.ut_line,
			    my_pty_name(ttydev),
			    sizeof (utmp.ut_line));
			time(&utmp.ut_time);
			write(wfd, (char *)&utmp, sizeof(utmp));
			close(wfd);
		}
#endif /* WTMP */
	}
#endif	/* USE_SYSV_UTMP */
#endif	/* HAVE_UTMP */
#ifndef AMOEBA
	close(screen->respond); /* close explicitly to avoid race with slave side */
#endif
#ifdef ALLOWLOGGING
	if(screen->logging)
		CloseLog(screen);
#endif

#ifndef AMOEBA
	if (am_slave < 0) {
		/* restore ownership of tty and pty */
		set_owner (ttydev, 0, 0, 0666);
#if (defined(USE_PTY_DEVICE) && !defined(__sgi) && !defined(__hpux))
		set_owner (ptydev, 0, 0, 0666);
#endif
	}
#endif /* AMOEBA */
	exit(n);
	SIGNAL_RETURN;
}

/* ARGSUSED */
static void
resize(TScreen *screen, register char *oldtc, char *newtc)
{
#ifndef USE_SYSV_ENVVARS
	register char *ptr1, *ptr2;
	register size_t i;
	register int li_first = 0;
	register char *temp;

	TRACE(("resize %s\n", oldtc));
	if ((ptr1 = x_strindex (oldtc, "co#")) == NULL){
		strcat (oldtc, "co#80:");
		ptr1 = x_strindex (oldtc, "co#");
	}
	if ((ptr2 = x_strindex (oldtc, "li#")) == NULL){
		strcat (oldtc, "li#24:");
		ptr2 = x_strindex (oldtc, "li#");
	}
	if(ptr1 > ptr2) {
		li_first++;
		temp = ptr1;
		ptr1 = ptr2;
		ptr2 = temp;
	}
	ptr1 += 3;
	ptr2 += 3;
	strncpy (newtc, oldtc, i = ptr1 - oldtc);
	temp = newtc + i;
	sprintf (temp, "%d", li_first
			? screen->max_row + 1
			: screen->max_col + 1);
	temp += strlen(temp);
	ptr1 = strchr(ptr1, ':');
	strncpy (temp, ptr1, i = ptr2 - ptr1);
	temp += i;
	sprintf (temp, "%d", li_first
			? screen->max_col + 1
			: screen->max_row + 1);
	ptr2 = strchr(ptr2, ':');
	strcat (temp, ptr2);
	TRACE(("   ==> %s\n", newtc));
#endif /* USE_SYSV_ENVVARS */
}

#endif /* ! VMS */

/*
 * Does a non-blocking wait for a child process.  If the system
 * doesn't support non-blocking wait, do nothing.
 * Returns the pid of the child, or 0 or -1 if none or error.
 */
int
nonblocking_wait(void)
{
#ifdef USE_POSIX_WAIT
	pid_t pid;

	pid = waitpid(-1, NULL, WNOHANG);
#elif defined(USE_SYSV_SIGNALS) && (defined(CRAY) || !defined(SIGTSTP))
	/* cannot do non-blocking wait */
	int pid = 0;
#else	/* defined(USE_SYSV_SIGNALS) && (defined(CRAY) || !defined(SIGTSTP)) */
#if defined(Lynx)
	int status;
#else
	union wait status;
#endif
	register int pid;

	pid = wait3 (&status, WNOHANG, (struct rusage *)NULL);
#endif /* USE_POSIX_WAIT else */
	return pid;
}

#ifndef VMS

/* ARGSUSED */
static SIGNAL_T reapchild (int n GCC_UNUSED)
{
    int olderrno = errno;
    int pid;

    pid = wait(NULL);

#ifdef USE_SYSV_SIGNALS
    /* cannot re-enable signal before waiting for child
     * because then SVR4 loops.  Sigh.  HP-UX 9.01 too.
     */
    (void) signal(SIGCHLD, reapchild);
#endif

    do {
	if (pid == term->screen.pid) {
#ifdef DEBUG
	    if (debug) fputs ("Exiting\n", stderr);
#endif
	    if (!hold_screen)
		Cleanup (0);
	}
    } while ( (pid=nonblocking_wait()) > 0);

    errno = olderrno;
    SIGNAL_RETURN;
}
#endif /* !VMS */

static void
remove_termcap_entry (char *buf, char *str)
{
    char *base = buf;
    char *first = base;
    int count = 0;
    size_t len = strlen(str);

    TRACE(("*** remove_termcap_entry('%s', '%s')\n", str, buf));

    while (*buf != 0) {
	if (!count && !strncmp(buf, str, len)) {
	    while (*buf != 0) {
		if (*buf == '\\')
		    buf++;
		else if (*buf == ':')
		    break;
		if (*buf != 0)
		    buf++;
	    }
	    while ((*first++ = *buf++) != 0)
		;
	    TRACE(("...removed_termcap_entry('%s', '%s')\n", str, base));
	    return;
	} else if (*buf == '\\') {
	    buf++;
	} else if (*buf == ':') {
	    first = buf;
	    count = 0;
	} else if (!isspace(CharOf(*buf))) {
	    count++;
	}
	if (*buf != 0)
	    buf++;
    }
    TRACE(("...cannot remove\n"));
}

/*
 * parse_tty_modes accepts lines of the following form:
 *
 *         [SETTING] ...
 *
 * where setting consists of the words in the modelist followed by a character
 * or ^char.
 */
static int parse_tty_modes (char *s, struct _xttymodes *modelist)
{
    struct _xttymodes *mp;
    int c;
    int count = 0;

    TRACE(("parse_tty_modes\n"));
    while (1) {
	while (*s && isascii(CharOf(*s)) && isspace(CharOf(*s))) s++;
	if (!*s) return count;

	for (mp = modelist; mp->name; mp++) {
	    if (strncmp (s, mp->name, mp->len) == 0) break;
	}
	if (!mp->name) return -1;

	s += mp->len;
	while (*s && isascii(CharOf(*s)) && isspace(CharOf(*s))) s++;
	if (!*s) return -1;

	if ((c = decode_keyvalue(s++, False)) != -1) {
	    mp->value = c;
	    mp->set = 1;
	    count++;
	    TRACE(("...parsed #%d: %s=%#x\n", count, mp->name, c));
	}
	while (*s && isascii(CharOf(*s)) && isgraph(CharOf(*s))) s++;
    }
}

#ifndef VMS /* don't use pipes on OpenVMS */
int GetBytesAvailable (int fd)
{
#ifdef AMOEBA
    /*
     * Since this routine is only used to poll X connections
     * we can use an internal Xlib routine (oh what ugly).
     */
    register TScreen *screen = &term->screen;
    int count;

    if (ConnectionNumber(screen->display) != fd) {
	Panic("Cannot get bytes available");
	return -1;
    }
    return _X11TransAmFdBytesReadable(fd, &count) < 0 ? -1 : count;
#elif defined(FIONREAD)
    long arg;
    ioctl (fd, FIONREAD, (char *) &arg);
    return (int) arg;
#elif defined(__CYGWIN__)
    fd_set set;
    struct timeval timeout = {0, 0};

    FD_ZERO (&set);
    FD_SET (fd, &set);
    if (select (fd+1, &set, NULL, NULL, &timeout) > 0)
      return 1;
    else
      return 0;
#elif defined(MINIX)
    /* The answer doesn't have to be correct.  Calling nbio_isinprogress() is
     * much cheaper than nbio_select().
     */
    if (nbio_isinprogress(fd, ASIO_READ))
	return 0;
    else
	return 1;
#elif defined(FIORDCK)
    return (ioctl (fd, FIORDCHK, NULL));
#else /* !FIORDCK */
    struct pollfd pollfds[1];

    pollfds[0].fd = fd;
    pollfds[0].events = POLLIN;
    return poll (pollfds, 1, 0);
#endif
}
#endif /* !VMS */

/* Utility function to try to hide system differences from
   everybody who used to call killpg() */

int
kill_process_group(int pid, int sig)
{
    TRACE(("kill_process_group(pid=%d, sig=%d)\n", pid, sig));
#ifdef AMOEBA
    if (pid != 2) {
	fprintf(stderr, "%s:  unexpected process id %d.\n", ProgramName, pid);
	abort();
    }
    ttysendsig(sig);
#elif defined(SVR4) || defined(SYSV) || !defined(X_NOT_POSIX)
    return kill (-pid, sig);
#else
    return killpg (pid, sig);
#endif /* AMOEBA */
}

#if OPT_EBCDIC
int A2E(int x)
{
    char c;
    c = x;
    __atoe_l(&c,1);
    return c;
}

int E2A(int x)
{
    char c;
    c = x;
    __etoa_l(&c,1);
    return c;
}
#endif

#if defined(__QNX__) && !defined(__QNXNTO__)
#include <sys/types.h>
#include <sys/proc_msg.h>
#include <sys/kernel.h>
#include <string.h>
#include <errno.h>

struct _proc_session ps;
struct _proc_session_reply rps;

int qsetlogin( char *login, char *ttyname )
{
	int v = getsid( getpid() );

	memset( &ps, 0, sizeof(ps) );
	memset( &rps, 0, sizeof(rps) );

	ps.type = _PROC_SESSION;
	ps.subtype = _PROC_SUB_ACTION1;
	ps.sid = v;
	strcpy( ps.name, login );

	Send( 1, &ps, &rps, sizeof(ps), sizeof(rps) );

	if ( rps.status < 0 )
		return( rps.status );

	ps.type = _PROC_SESSION;
	ps.subtype = _PROC_SUB_ACTION2;
	ps.sid = v;
	sprintf( ps.name, "//%d%s", getnid(), ttyname );
	Send( 1, &ps, &rps, sizeof(ps), sizeof(rps) );

	return( rps.status );
}
#endif
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 2
a2 2
#if !defined(lint) && 0
static char *rid = "$Xorg: main.c,v 1.7 2001/02/09 02:06:02 xorgcvs Exp $";
d20 1
a20 1
Copyright 2002,2003 by Thomas E. Dickey
d48 1
d71 1
d94 2
a95 1
/* $XFree86: xc/programs/xterm/main.c,v 3.174 2003/12/25 22:04:04 dickey Exp $ */
a98 2
#define RES_OFFSET(field)	XtOffsetOf(XTERM_RESOURCE, field)

d102 2
a107 2

#if defined(HAVE_LIB_XAW)
a108 6
#elif defined(HAVE_LIB_XAW3D)
#include <X11/Xaw3d/Form.h>
#elif defined(HAVE_LIB_NEXTAW)
#include <X11/neXtaw/Form.h>
#elif defined(HAVE_LIB_XAWPLUS)
#include <X11/XawPlus/Form.h>
a110 2
#endif /* OPT_TOOLBAR */

a122 1
#include <wcwidth.h>
d125 29
a156 5
#include <pty.h>		/* openpty() */
#endif

#ifdef __sgi
#include <grp.h>		/* initgroups() */
a198 1
#ifndef _SVID3
a200 1
#endif
d202 1
a202 1
#if defined(__GLIBC__) && !defined(linux)
d230 1
a230 1
#ifdef SYSV			/* { */
d232 3
a234 3
#ifdef USE_USG_PTYS		/* AT&T SYSV has no ptyio.h */
#include <sys/stropts.h>	/* for I_PUSH */
#include <poll.h>		/* for POLLIN */
d241 1
a241 1
#define USE_SYSV_ENVVARS	/* COLUMNS/LINES vs. TERMCAP */
d282 3
a284 1
#else	/* } !SYSV { */	/* BSD systems */
d292 1
a292 5
extern __inline__
ttyslot()
{
    return 1;			/* yuk */
}
d315 3
a317 1
#endif /* } !SYSV */
d332 2
a333 2
#elif !(defined(VMS) || defined(WIN32) || defined(Lynx) || defined(__GNU__) || defined(__MVS__))
#include <sys/param.h>		/* for NOFILE */
a350 6
#if defined(UTMPX_FOR_UTMP)
#define UTMP_STR utmpx
#else
#define UTMP_STR utmp
#endif

d367 1
a367 1
extern struct utmp *getutid __((struct utmp * _Id));
d398 1
a398 1
#define LASTLOG_FILENAME "/usr/adm/lastlog"	/* only on BSD systems */
d438 1
a438 1
#ifdef __cplusplus
d442 2
a443 2
    extern int tgetent(char *ptr, char *name);
    extern char *tgetstr(char *name, char **ptr);
d445 2
a446 2
#ifdef __cplusplus
}
d448 1
d450 3
a452 3
static SIGNAL_T reapchild(int n);
static int spawn(void);
static void remove_termcap_entry(char *buf, char *str);
d454 1
a454 1
static int pty_search(int *pty);
d458 3
a460 3
static int get_pty(int *pty, char *from);
static void get_terminal(void);
static void resize(TScreen * s, char *oldtc, char *newtc);
a481 4
#if OPT_LUIT_PROG
static char **command_to_exec_with_luit = NULL;
#endif

d488 1
a488 1
#ifdef B38400			/* everyone should define this */
d490 1
a490 1
#else /* ...but xterm's used this for a long time */
d553 1
a553 1
#endif /* HAS_LTCHARS */
d557 1
a557 1
#endif /* TIOCLSET */
d562 2
a563 3
static struct sgttyb d_sg =
{
    0, 0, 0177, CKILL, (EVENP | ODDP | ECHO | XTABS | CRMOD)
d565 3
a567 4
static struct tchars d_tc =
{
    CINTR, CQUIT, CSTART,
    CSTOP, CEOF, CBRK
d569 3
a571 4
static struct ltchars d_ltc =
{
    CSUSP, CDSUSP, CRPRNT,
    CFLUSH, CWERASE, CLNEXT
d574 1
a574 1
static long int d_lmode = LCRTBS | LCRTERA | LCRTKIL | LCTLECH;
d576 3
a578 4
static long int d_jmode = KM_SYSSJIS | KM_ASCII;
static struct jtchars d_jtc =
{
    'J', 'B'
a589 1
/* *INDENT-OFF* */
d596 1
a596 1
    { "intr",	4, 0, '\0' },	/* tchars.t_intrc ; VINTR */
d598 1
a598 1
    { "quit",	4, 0, '\0' },	/* tchars.t_quitc ; VQUIT */
d600 1
a600 1
    { "erase",	5, 0, '\0' },	/* sgttyb.sg_erase ; VERASE */
d602 1
a602 1
    { "kill",	4, 0, '\0' },	/* sgttyb.sg_kill ; VKILL */
d604 1
a604 1
    { "eof",	3, 0, '\0' },	/* tchars.t_eofc ; VEOF */
d606 1
a606 1
    { "eol",	3, 0, '\0' },	/* VEOL */
d608 1
a608 1
    { "swtch",	5, 0, '\0' },	/* VSWTCH */
d610 1
a610 1
    { "start",	5, 0, '\0' },	/* tchars.t_startc */
d612 1
a612 1
    { "stop",	4, 0, '\0' },	/* tchars.t_stopc */
d614 1
a614 1
    { "brk",	3, 0, '\0' },	/* tchars.t_brkc */
d616 1
a616 1
    { "susp",	4, 0, '\0' },	/* ltchars.t_suspc ; VSUSP */
d618 1
a618 1
    { "dsusp",	5, 0, '\0' },	/* ltchars.t_dsuspc ; VDSUSP */
d620 1
a620 1
    { "rprnt",	5, 0, '\0' },	/* ltchars.t_rprntc ; VREPRINT */
d622 1
a622 1
    { "flush",	5, 0, '\0' },	/* ltchars.t_flushc ; VDISCARD */
d624 1
a624 1
    { "weras",	5, 0, '\0' },	/* ltchars.t_werasc ; VWERASE */
d626 1
a626 1
    { "lnext",	5, 0, '\0' },	/* ltchars.t_lnextc ; VLNEXT */
d628 1
a628 1
    { "status", 6, 0, '\0' },	/* VSTATUS */
d630 1
a630 1
    { NULL,	0, 0, '\0' },	/* end of data */
a631 1
/* *INDENT-ON* */
d635 1
a635 1
static int parse_tty_modes(char *s, struct _xttymodes *modelist);
d642 1
a642 1
#else /* not USE_SYSV_UTMP */
d644 1
a644 1
#endif /* USE_SYSV_UTMP */
d676 1
a676 1
#endif /* TIOCCONS */
d680 1
a680 1
#endif /* USE_SYSV_UTMP */
d683 1
a683 1
/* used by VT (charproc.c) */
d685 11
a695 12
static XtResource application_resources[] =
{
    Sres("name", "Name", xterm_name, DFT_TERMTYPE),
    Sres("iconGeometry", "IconGeometry", icon_geometry, NULL),
    Sres(XtNtitle, XtCTitle, title, NULL),
    Sres(XtNiconName, XtCIconName, icon_name, NULL),
    Sres("termName", "TermName", term_name, NULL),
    Sres("ttyModes", "TtyModes", tty_modes, NULL),
    Bres("hold", "Hold", hold_screen, FALSE),
    Bres("utmpInhibit", "UtmpInhibit", utmpInhibit, FALSE),
    Bres("messages", "Messages", messages, TRUE),
    Bres("sunFunctionKeys", "SunFunctionKeys", sunFunctionKeys, FALSE),
d697 1
a697 1
    Bres("sunKeyboard", "SunKeyboard", sunKeyboard, FALSE),
d700 1
a700 1
    Bres("hpFunctionKeys", "HpFunctionKeys", hpFunctionKeys, FALSE),
d703 2
a704 2
    Bres("ptyInitialErase", "PtyInitialErase", ptyInitialErase, FALSE),
    Bres("backarrowKeyIsErase", "BackarrowKeyIsErase", backarrow_is_erase, FALSE),
d706 2
a707 2
    Bres("waitForMap", "WaitForMap", wait_for_map, FALSE),
    Bres("useInsertMode", "UseInsertMode", useInsertMode, FALSE),
d709 43
a751 1
    Ires("zIconBeep", "ZIconBeep", zIconBeep, 0),
d753 13
a765 2
#if OPT_PTY_HANDSHAKE
    Bres("ptyHandshake", "PtyHandshake", ptyHandshake, TRUE),
d768 2
a769 4
    Bres("sameName", "SameName", sameName, TRUE),
#endif
#if OPT_SESSION_MGT
    Bres("sessionMgt", "SessionMgt", sessionMgt, TRUE),
d772 1
d774 1
a774 2
static char *fallback_resources[] =
{
d790 1
a790 1
/* *INDENT-OFF* */
a855 4
#if OPT_C1_PRINT
{"-k8",		"*allowC1Printable", XrmoptionNoArg,	(caddr_t) "on"},
{"+k8",		"*allowC1Printable", XrmoptionNoArg,	(caddr_t) "off"},
#endif
a904 6
#if OPT_LUIT_PROG
{"-lc",		"*locale",	XrmoptionNoArg,		(caddr_t) "True"},
{"+lc",		"*locale",	XrmoptionNoArg,		(caddr_t) "False"},
{"-lcc",	"*localeFilter",XrmoptionSepArg,	(caddr_t) NULL},
{"-en",		"*locale",	XrmoptionSepArg,	(caddr_t) NULL},
#endif
a917 2
{"-cjk_width",	"*cjkWidth",	XrmoptionNoArg,		(caddr_t) "on"},
{"+cjk_width",	"*cjkWidth",	XrmoptionNoArg,		(caddr_t) "off"},
d922 1
a922 1
{"-ziconbeep", "*zIconBeep", XrmoptionSepArg, (caddr_t) NULL},
a927 4
#if OPT_SESSION_MGT
{"-sm",		"*sessionMgt",	XrmoptionNoArg,		(caddr_t) "on"},
{"+sm",		"*sessionMgt",	XrmoptionNoArg,		(caddr_t) "off"},
#endif
a932 1
{"-into",	NULL,		XrmoptionSkipArg,	(caddr_t) NULL},
d934 1
a934 1
   standard XtOpenApplication options now */
d946 1
a946 1
static OptionHelp xtermOptions[] = {
d958 1
a958 1
{ "-/+fbb",                "turn on/off normal/bold font comparison inhibit"},
d976 1
a976 1
{ "-/+132",                "turn on/off 80/132 column switching" },
d979 1
a979 1
{ "-/+ai",                 "turn off/on active icon" },
d983 1
a983 1
{ "-/+bc",                 "turn on/off text cursor blinking" },
d993 1
a993 1
{ "-/+dc",                 "turn off/on dynamic color selection" },
d995 1
a995 1
{ "-hc color",             "selection background color" },
d1000 1
a1000 1
{ "-/+hold",               "turn on/off logic that retains window after exit" },
d1002 1
a1002 1
{ "-/+ie",                 "turn on/off initialization of 'erase' from pty" },
d1004 1
a1004 1
{ "-/+im",                 "use insert mode for TERMCAP" },
a1005 3
#if OPT_C1_PRINT
{ "-/+k8",                 "turn on/off C1-printable classification"},
#endif
d1016 1
a1016 1
{ "-/+mesg",               "forbid/allow messages" },
d1019 1
a1019 1
{ "-/+nul",                "turn off/on display of underlining" },
d1029 1
a1029 1
{ "-/+rvc",                "turn off/on display of reverse as color" },
a1045 4
#if OPT_LUIT_PROG
{ "-/+lc",                 "turn on/off locale mode using luit" },
{ "-lcc path",             "filename of locale converter (" DEFLOCALEFILTER ")" },
#endif
d1048 1
a1048 1
{ "-/+ut",                 "turn on/off utmp support" },
d1050 1
a1050 1
{ "-/+ut",                 "turn on/off utmp support (not available)" },
a1055 1
{ "-/+cjk_width",          "turn on/off legacy CJK width convention" },
a1070 1
{ "-into windowId",        "use the window id given to -into as the parent window rather than the default root window" },
a1076 3
#if OPT_SESSION_MGT
{ "-/+sm",                 "turn on/off the session-management support" },
#endif
a1077 1
/* *INDENT-ON* */
d1079 7
a1085 8
static char *message[] =
{
    "Fonts should be fixed width and, if both normal and bold are specified, should",
    "have the same size.  If only a normal font is specified, it will be used for",
    "both normal and bold text (by doing overstriking).  The -e option, if given,",
    "must appear at the end of the command line, otherwise the user's default shell",
    "will be started.  Options that start with a plus sign (+) restore the default.",
    NULL};
d1092 1
a1092 2
static int
decode_keyvalue(char **ptr, int termcap)
a1093 1
    char *string = *ptr;
a1127 1
	++string;
d1130 2
a1131 2
	int temp = strtol(string + 1, &d, 8);
	if (temp > 0 && d != string) {
a1132 2
	    string = d;
	}
a1134 1
	++string;
a1135 1
    *ptr = string;
d1143 1
a1143 2
static Boolean
get_termcap(char *name, char *buffer, char *resized)
d1147 1
a1147 1
    *buffer = 0;		/* initialize, in case we're using terminfo's tgetent */
d1150 1
a1150 1
	if (tgetent(buffer, name) == 1) {
d1152 3
a1154 3
		   (*buffer
		    ? "ok:termcap, we can update $TERMCAP"
		    : "assuming this is terminfo")));
d1157 1
a1157 1
		    resize(screen, buffer, resized);
d1168 1
a1168 2
static int
abbrev(char *tst, char *cmp, size_t need)
d1170 2
a1171 2
    size_t len = strlen(tst);
    return ((len >= need) && (!strncmp(tst, cmp, len)));
d1174 1
a1174 2
static void
Syntax(char *badOption)
a1176 1
    OptionHelp *list = sortedOpts(xtermOptions, optionDescList, XtNumber(optionDescList));
d1179 2
a1180 2
    fprintf(stderr, "%s:  bad command line option \"%s\"\r\n\n",
	    ProgramName, badOption);
d1182 1
a1182 1
    fprintf(stderr, "usage:  %s", ProgramName);
d1184 2
a1185 2
    for (opt = list; opt->opt; opt++) {
	int len = 3 + strlen(opt->opt);		/* space [ string ] */
d1187 1
a1187 1
	    fprintf(stderr, "\r\n   ");		/* 3 spaces */
d1190 1
a1190 1
	fprintf(stderr, " [%s]", opt->opt);
d1194 3
a1196 3
    fprintf(stderr, "\r\n\nType %s -help for a full description.\r\n\n",
	    ProgramName);
    exit(1);
d1199 1
a1199 2
static void
Version(void)
d1205 1
a1205 2
static void
Help(void)
a1207 1
    OptionHelp *list = sortedOpts(xtermOptions, optionDescList, XtNumber(optionDescList));
d1210 5
a1214 6
    fprintf(stderr,
	    "%s(%d) usage:\n    %s [-options ...] [-e command args]\n\n",
	    XFREE86_VERSION, XTERM_PATCH, ProgramName);
    fprintf(stderr, "where options include:\n");
    for (opt = list; opt->opt; opt++) {
	fprintf(stderr, "    %-28s %s\n", opt->opt, opt->desc);
d1217 1
a1217 1
    putc('\n', stderr);
d1219 2
a1220 2
	fputs(*cpp, stderr);
	putc('\n', stderr);
d1222 1
a1222 1
    putc('\n', stderr);
d1229 8
a1236 7
ConvertConsoleSelection(Widget w GCC_UNUSED,
			Atom * selection GCC_UNUSED,
			Atom * target GCC_UNUSED,
			Atom * type GCC_UNUSED,
			XtPointer * value GCC_UNUSED,
			unsigned long *length GCC_UNUSED,
			int *format GCC_UNUSED)
d1243 5
a1247 19
#if OPT_SESSION_MGT
static void
die_callback(Widget w GCC_UNUSED,
	     XtPointer client_data GCC_UNUSED,
	     XtPointer call_data GCC_UNUSED)
{
    Cleanup(0);
}

static void
save_callback(Widget w GCC_UNUSED,
	      XtPointer client_data GCC_UNUSED,
	      XtPointer call_data)
{
    XtCheckpointToken token = (XtCheckpointToken) call_data;
    /* we have nothing to save */
    token->save_success = True;
}
#endif /* OPT_SESSION_MGT */
d1249 1
a1249 3
#if OPT_WIDE_CHARS
int (*my_wcwidth) (wchar_t);
#endif
d1256 5
a1260 4
DeleteWindow(Widget w,
	     XEvent * event GCC_UNUSED,
	     String * params GCC_UNUSED,
	     Cardinal * num_params GCC_UNUSED)
d1263 8
a1270 7
    if (w == toplevel) {
	if (term->screen.Tshow)
	    hide_vt_window();
	else
	    do_hangup(w, (XtPointer) 0, (XtPointer) 0);
    } else if (term->screen.Vshow)
	hide_tek_window();
d1273 1
a1273 1
	do_hangup(w, (XtPointer) 0, (XtPointer) 0);
d1278 5
a1282 4
KeyboardMapping(Widget w GCC_UNUSED,
		XEvent * event,
		String * params GCC_UNUSED,
		Cardinal * num_params GCC_UNUSED)
d1285 3
a1287 3
    case MappingNotify:
	XRefreshKeyboardMapping(&event->xmapping);
	break;
d1291 3
a1293 4
XtActionsRec actionProcs[] =
{
    {"DeleteWindow", DeleteWindow},
    {"KeyboardMapping", KeyboardMapping},
d1296 2
d1306 2
a1307 2
    size_t len = strlen(device);
    Boolean name = False;
d1309 14
a1322 13
    while (len != 0) {
	int ch = device[len - 1];
	if (isdigit(ch)) {
	    len--;
	} else if (ch == '/') {
	    if (name)
		break;
	    len--;
	} else if (isalpha(ch)) {
	    name = True;
	    len--;
	} else {
	    break;
d1324 2
a1325 3
    }
    TRACE(("my_pty_name(%s) -> '%s'\n", device, device + len));
    return device + len;
d1335 2
a1336 2
    char *name = my_pty_name(device);
    char *leaf = x_basename(name);
d1338 7
a1344 7
    if (name == leaf) {		/* no '/' in the name */
	int len = strlen(leaf);
	if (PTYCHARLEN < len)
	    leaf = leaf + (len - PTYCHARLEN);
    }
    TRACE(("my_pty_id  (%s) -> '%s'\n", device, leaf));
    return leaf;
d1353 2
a1354 2
    char *name = my_pty_name(device);
    char *leaf = x_basename(name);
d1356 6
a1361 6
    if (name == leaf) {
	strcpy(my_pty_id(device), id);
    } else {
	strcpy(leaf, id);
    }
    TRACE(("set_pty_id(%s) -> '%s'\n", id, device));
d1373 2
a1374 2
    char *leaf = x_basename(option);
    Boolean code = False;
d1376 21
a1396 17
    if (leaf != option) {
	if (leaf - option > 1
	    && leaf - option <= PTYCHARLEN
	    && sscanf(leaf, "%d", &am_slave) == 1) {
	    size_t len = leaf - option - 1;
	    /*
	     * If the given length is less than PTYCHARLEN, that is
	     * all right because the calling application may be
	     * giving us a path for /dev/pts, which would be
	     * followed by one or more decimal digits.
	     *
	     * For fixed-width fields, it is up to the calling
	     * application to provide leading 0's, if needed.
	     */
	    strncpy(passedPty, option, len);
	    passedPty[len] = 0;
	    code = True;
d1398 3
a1400 7
    } else {
	code = (sscanf(option, "%c%c%d",
		       passedPty, passedPty + 1, &am_slave) == 3);
    }
    TRACE(("ParseSccn(%s) = '%s' %d (%s)\n", option,
	   passedPty, am_slave, code ? "OK" : "ERR"));
    return code;
d1414 1
a1414 1
 * pty implementation allows more than 3 digits.
d1419 14
a1432 14
    static char result[PTYCHARLEN + 4];
    char *name = my_pty_name(device);
    char *leaf = x_basename(name);

    if (name == leaf) {		/* no '/' in the name */
	int len = strlen(leaf);
	if (PTYCHARLEN < len)
	    leaf = leaf + (len - PTYCHARLEN);
	strcpy(result, leaf);
    } else {
	sprintf(result, "p%s", leaf);
    }
    TRACE(("my_utmp_id (%s) -> '%s'\n", device, result));
    return result;
d1438 1
a1438 1
typedef void (*sigfunc) (int);
d1440 1
a1440 1
/* make sure we sure we ignore SIGCHLD for the cases parent
d1446 1
a1446 1
    struct sigaction act, oact;
d1448 2
a1449 2
    act.sa_handler = func;
    sigemptyset(&act.sa_mask);
d1451 1
a1451 1
    act.sa_flags = SA_NOCLDSTOP | SA_RESTART;
d1453 1
a1453 1
    act.sa_flags = SA_NOCLDSTOP;
d1455 3
a1457 3
    if (sigaction(signo, &act, &oact) < 0)
	return (SIG_ERR);
    return (oact.sa_handler);
d1463 1
a1463 1
main(int argc, char *argv[]ENVP_ARG)
d1465 10
a1474 10
    Widget form_top, menu_top;
    register TScreen *screen;
    int mode;
    char *my_class = DEFCLASS;
    Window winToEmbedInto = None;

    ProgramName = argv[0];

    /* extra length in case longer tty name like /dev/ttyq255 */
    ttydev = (char *) malloc(sizeof(TTYDEV) + 80);
d1476 2
a1477 2
    ptydev = (char *) malloc(sizeof(PTYDEV) + 80);
    if (!ttydev || !ptydev)
d1479 1
a1479 1
    if (!ttydev)
d1481 7
a1487 7
    {
	fprintf(stderr,
		"%s: unable to allocate memory for ttydev or ptydev\n",
		ProgramName);
	exit(1);
    }
    strcpy(ttydev, TTYDEV);
d1489 1
a1489 1
    strcpy(ptydev, PTYDEV);
d1493 3
a1495 3
    get_pty(NULL, NULL);
    seteuid(getuid());
    setuid(getuid());
d1498 25
a1522 19
    /* Do these first, since we may not be able to open the display */
    TRACE_OPTS(xtermOptions, optionDescList, XtNumber(optionDescList));
    TRACE_ARGV("Before XtOpenApplication", argv);
    if (argc > 1) {
	int n;
	int unique = 2;
	Boolean quit = True;

	for (n = 1; n < argc; n++) {
	    TRACE(("parsing %s\n", argv[n]));
	    if (abbrev(argv[n], "-version", unique)) {
		Version();
	    } else if (abbrev(argv[n], "-help", unique)) {
		Help();
	    } else if (abbrev(argv[n], "-class", 3)) {
		if ((my_class = argv[++n]) == 0) {
		    Help();
		} else {
		    quit = False;
d1524 2
a1525 5
		unique = 3;
	    } else {
		quit = False;
		unique = 3;
	    }
a1526 3
	if (quit)
	    exit(0);
    }
d1528 1
a1528 1
    /* This dumps core on HP-UX 9.05 with X11R5 */
d1530 1
a1530 1
    XtSetLanguageProc(NULL, NULL, NULL);
d1533 28
a1560 7
#if defined(USE_ANY_SYSV_TERMIO) || defined(USE_POSIX_TERMIOS)	/* { */
    /* Initialization is done here rather than above in order
     * to prevent any assumptions about the order of the contents
     * of the various terminal structures (which may change from
     * implementation to implementation).
     */
    d_tio.c_iflag = ICRNL | IXON;
d1562 1
a1562 1
    d_tio.c_oflag = OPOST | ONLCR | TAB3;
d1565 1
a1565 1
    d_tio.c_oflag = OPOST | ONLCR;
d1567 1
a1567 1
    d_tio.c_oflag = OPOST;
d1570 3
a1572 3
#if defined(macII) || defined(ATT) || defined(CRAY)	/* { */
    d_tio.c_cflag = VAL_LINE_SPEED | CS8 | CREAD | PARENB | HUPCL;
    d_tio.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK;
d1574 1
a1574 1
    d_tio.c_lflag |= ECHOKE | IEXTEN;
d1577 1
a1577 1
    d_tio.c_lflag |= ECHOCTL | IEXTEN;
d1580 2
a1581 2
#ifndef USE_TERMIOS		/* { */
    d_tio.c_line = 0;
d1584 7
a1590 7
    d_tio.c_cc[VINTR] = CINTR;
    d_tio.c_cc[VQUIT] = CQUIT;
    d_tio.c_cc[VERASE] = CERASE;
    d_tio.c_cc[VKILL] = CKILL;
    d_tio.c_cc[VEOF] = CEOF;
    d_tio.c_cc[VEOL] = CNUL;
    d_tio.c_cc[VEOL2] = CNUL;
d1592 1
a1592 1
    d_tio.c_cc[VSWTCH] = CNUL;
d1595 2
a1596 2
#if defined(USE_TERMIOS) || defined(USE_POSIX_TERMIOS)	/* { */
    d_tio.c_cc[VSUSP] = CSUSP;
d1598 1
a1598 1
    d_tio.c_cc[VDSUSP] = CDSUSP;
d1600 6
a1605 6
    d_tio.c_cc[VREPRINT] = CRPRNT;
    d_tio.c_cc[VDISCARD] = CFLUSH;
    d_tio.c_cc[VWERASE] = CWERASE;
    d_tio.c_cc[VLNEXT] = CLNEXT;
    d_tio.c_cc[VMIN] = 1;
    d_tio.c_cc[VTIME] = 0;
d1607 7
a1613 7
#ifdef HAS_LTCHARS		/* { */
    d_ltc.t_suspc = CSUSP;	/* t_suspc */
    d_ltc.t_dsuspc = CDSUSP;	/* t_dsuspc */
    d_ltc.t_rprntc = CRPRNT;
    d_ltc.t_flushc = CFLUSH;
    d_ltc.t_werasc = CWERASE;
    d_ltc.t_lnextc = CLNEXT;
d1615 2
a1616 2
#ifdef TIOCLSET			/* { */
    d_lmode = 0;
d1618 1
a1618 1
#else /* }{ else !macII, ATT, CRAY */
d1620 5
a1624 5
#ifdef BAUD_0			/* { */
    d_tio.c_cflag = CS8 | CREAD | PARENB | HUPCL;
#else /* }{ !BAUD_0 */
    d_tio.c_cflag = VAL_LINE_SPEED | CS8 | CREAD | PARENB | HUPCL;
#endif /* } !BAUD_0 */
d1626 3
a1628 3
    d_tio.c_cflag = CS8 | CREAD | PARENB | HUPCL;
    cfsetispeed(&d_tio, VAL_LINE_SPEED);
    cfsetospeed(&d_tio, VAL_LINE_SPEED);
d1630 1
a1630 1
    d_tio.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK;
d1632 1
a1632 1
    d_tio.c_lflag |= ECHOKE | IEXTEN;
d1635 1
a1635 1
    d_tio.c_lflag |= ECHOCTL | IEXTEN;
d1639 1
a1639 1
    d_tio.c_line = NTTYDISC;
d1641 1
a1641 1
    d_tio.c_line = 0;
d1645 2
a1646 2
    d_tio.c_cflag &= ~(HUPCL | PARENB);
    d_tio.c_iflag |= BRKINT | ISTRIP | IGNPAR;
d1648 8
a1655 8
    d_tio.c_cc[VINTR] = CONTROL('C');	/* '^C' */
    d_tio.c_cc[VERASE] = 0x7f;	/* DEL  */
    d_tio.c_cc[VKILL] = CONTROL('U');	/* '^U' */
    d_tio.c_cc[VQUIT] = CQUIT;	/* '^\' */
    d_tio.c_cc[VEOF] = CEOF;	/* '^D' */
    d_tio.c_cc[VEOL] = CEOL;	/* '^@@' */
    d_tio.c_cc[VMIN] = 1;
    d_tio.c_cc[VTIME] = 0;
d1657 1
a1657 1
    d_tio.c_cc[VSWTCH] = CSWTCH;	/* usually '^Z' */
d1660 1
a1660 1
    d_tio.c_cc[VLNEXT] = CLNEXT;
d1663 1
a1663 1
    d_tio.c_cc[VWERASE] = CWERASE;
d1666 1
a1666 1
    d_tio.c_cc[VREPRINT] = CRPRNT;
d1669 1
a1669 1
    d_tio.c_cc[VRPRNT] = CRPRNT;
d1672 1
a1672 1
    d_tio.c_cc[VDISCARD] = CFLUSH;
d1675 1
a1675 1
    d_tio.c_cc[VFLUSHO] = CFLUSH;
d1678 1
a1678 1
    d_tio.c_cc[VSTOP] = CSTOP;
d1681 1
a1681 1
    d_tio.c_cc[VSTART] = CSTART;
d1684 1
a1684 1
    d_tio.c_cc[VSUSP] = CSUSP;
d1687 1
a1687 1
    d_tio.c_cc[VDSUSP] = CDSUSP;
d1690 1
a1690 1
    d_tio.c_cc[VSTATUS] = CSTATUS;
d1692 3
a1694 3
    /* now, try to inherit tty settings */
    {
	int i;
d1696 1
a1696 1
	for (i = 0; i <= 2; i++) {
d1698 2
a1699 2
	    struct termio deftio;
	    if (ioctl(i, TCGETA, &deftio) == 0)
d1701 2
a1702 2
	    struct termios deftio;
	    if (tcgetattr(i, &deftio) == 0)
d1704 7
a1710 7
	    {
		d_tio.c_cc[VINTR] = deftio.c_cc[VINTR];
		d_tio.c_cc[VQUIT] = deftio.c_cc[VQUIT];
		d_tio.c_cc[VERASE] = deftio.c_cc[VERASE];
		d_tio.c_cc[VKILL] = deftio.c_cc[VKILL];
		d_tio.c_cc[VEOF] = deftio.c_cc[VEOF];
		d_tio.c_cc[VEOL] = deftio.c_cc[VEOL];
d1712 1
a1712 1
		d_tio.c_cc[VSWTCH] = deftio.c_cc[VSWTCH];
d1715 1
a1715 1
		d_tio.c_cc[VEOL2] = deftio.c_cc[VEOL2];
d1718 1
a1718 1
		d_tio.c_cc[VLNEXT] = deftio.c_cc[VLNEXT];
d1721 1
a1721 1
		d_tio.c_cc[VWERASE] = deftio.c_cc[VWERASE];
d1724 1
a1724 1
		d_tio.c_cc[VREPRINT] = deftio.c_cc[VREPRINT];
d1727 1
a1727 1
		d_tio.c_cc[VRPRNT] = deftio.c_cc[VRPRNT];
d1730 1
a1730 1
		d_tio.c_cc[VDISCARD] = deftio.c_cc[VDISCARD];
d1733 1
a1733 1
		d_tio.c_cc[VFLUSHO] = deftio.c_cc[VFLUSHO];
d1736 1
a1736 1
		d_tio.c_cc[VSTOP] = deftio.c_cc[VSTOP];
d1739 1
a1739 1
		d_tio.c_cc[VSTART] = deftio.c_cc[VSTART];
d1742 1
a1742 1
		d_tio.c_cc[VSUSP] = deftio.c_cc[VSUSP];
d1745 1
a1745 1
		d_tio.c_cc[VDSUSP] = deftio.c_cc[VDSUSP];
d1748 1
a1748 1
		d_tio.c_cc[VSTATUS] = deftio.c_cc[VSTATUS];
d1750 2
a1751 1
		break;
d1754 10
a1763 11
    }
#ifdef HAS_LTCHARS		/* { */
    d_ltc.t_suspc = '\000';	/* t_suspc */
    d_ltc.t_dsuspc = '\000';	/* t_dsuspc */
    d_ltc.t_rprntc = '\377';	/* reserved... */
    d_ltc.t_flushc = '\377';
    d_ltc.t_werasc = '\377';
    d_ltc.t_lnextc = '\377';
#endif /* } HAS_LTCHARS */
#if defined(USE_TERMIOS) || defined(USE_POSIX_TERMIOS)	/* { */
    d_tio.c_cc[VSUSP] = CSUSP;
d1765 1
a1765 1
    d_tio.c_cc[VDSUSP] = '\000';
d1768 1
a1768 1
    d_tio.c_cc[VSTATUS] = '\377';
d1771 1
a1771 1
    d_tio.c_cc[VREPRINT] = '\377';
d1774 1
a1774 1
    d_tio.c_cc[VDISCARD] = '\377';
d1777 1
a1777 1
    d_tio.c_cc[VWERASE] = '\377';
d1780 1
a1780 1
    d_tio.c_cc[VLNEXT] = '\377';
d1783 6
a1788 5
#ifdef TIOCLSET			/* { */
    d_lmode = 0;
#endif /* } TIOCLSET */
#endif /* } macII, ATT, CRAY */
#endif /* } USE_ANY_SYSV_TERMIO || USE_POSIX_TERMIOS */
d1790 2
a1791 2
    /* Init the Toolkit. */
    {
d1793 4
a1796 4
	uid_t euid = geteuid();
	gid_t egid = getegid();
	uid_t ruid = getuid();
	gid_t rgid = getgid();
d1798 1
a1798 1
	if (setegid(rgid) == -1) {
d1800 1
a1800 1
	    if (!(errno == EMVSERR))	/* could happen if _BPX_SHAREAS=REUSE */
a1803 1
	}
d1805 1
a1805 1
	if (seteuid(ruid) == -1) {
d1807 1
a1807 1
	    if (!(errno == EMVSERR))
a1810 1
	}
d1813 11
a1823 20
	XtSetErrorHandler(xt_error);
#if OPT_SESSION_MGT
	toplevel = XtOpenApplication(&app_con, my_class,
				     optionDescList,
				     XtNumber(optionDescList),
				     &argc, argv, fallback_resources,
				     sessionShellWidgetClass,
				     NULL, 0);
#else
	toplevel = XtAppInitialize(&app_con, my_class,
				   optionDescList,
				   XtNumber(optionDescList),
				   &argc, argv, fallback_resources,
				   NULL, 0);
#endif /* OPT_SESSION_MGT */
	XtSetErrorHandler((XtErrorHandler) 0);

	XtGetApplicationResources(toplevel, (XtPointer) & resource,
				  application_resources,
				  XtNumber(application_resources), NULL, 0);
d1826 1
a1826 1
	if (seteuid(euid) == -1) {
d1828 1
a1828 1
	    if (!(errno == EMVSERR))
d1832 1
a1832 3
	}

	if (setegid(egid) == -1) {
d1834 1
a1834 1
	    if (!(errno == EMVSERR))
a1837 1
	}
a1838 1

d1840 6
a1845 4
	if (resource.utmpInhibit) {
	    /* Can totally revoke group privs */
	    setegid(getgid());
	    setgid(getgid());
a1846 2
#endif
    }
d1848 1
a1848 1
    waiting_for_initial_map = resource.wait_for_map;
d1850 4
a1853 4
    /*
     * ICCCM delete_window.
     */
    XtAppAddActions(app_con, actionProcs, XtNumber(actionProcs));
d1855 11
a1865 10
    /*
     * fill in terminal modes
     */
    if (resource.tty_modes) {
	int n = parse_tty_modes(resource.tty_modes, ttymodelist);
	if (n < 0) {
	    fprintf(stderr, "%s:  bad tty modes \"%s\"\n",
		    ProgramName, resource.tty_modes);
	} else if (n > 0) {
	    override_tty_modes = 1;
d1867 1
a1867 1
    }
d1869 6
a1874 7
    zIconBeep = resource.zIconBeep;
    zIconBeep_flagged = False;
    if (zIconBeep > 100 || zIconBeep < -100) {
	zIconBeep = 0;		/* was 100, but I prefer to defaulting off. */
	fprintf(stderr,
		"a number between -100 and 100 is required for zIconBeep.  0 used by default\n");
    }
d1877 1
a1877 1
    sameName = resource.sameName;
d1879 20
a1898 21
    hold_screen = resource.hold_screen ? 1 : 0;
    xterm_name = resource.xterm_name;
    if (strcmp(xterm_name, "-") == 0)
	xterm_name = DFT_TERMTYPE;
    if (resource.icon_geometry != NULL) {
	int scr, junk;
	int ix, iy;
	Arg args[2];

	for (scr = 0;		/* yyuucchh */
	     XtScreen(toplevel) != ScreenOfDisplay(XtDisplay(toplevel), scr);
	     scr++) ;

	args[0].name = XtNiconX;
	args[1].name = XtNiconY;
	XGeometry(XtDisplay(toplevel), scr, resource.icon_geometry, "",
		  0, 0, 0, 0, 0, &ix, &iy, &junk, &junk);
	args[0].value = (XtArgVal) ix;
	args[1].value = (XtArgVal) iy;
	XtSetValues(toplevel, args, 2);
    }
d1900 2
a1901 2
    XtSetValues(toplevel, ourTopLevelShellArgs,
		number_ourTopLevelShellArgs);
d1904 2
a1905 2
    /* seems as good a place as any */
    init_classtab();
d1908 14
a1921 15
    /* Parse the rest of the command line */
    TRACE_ARGV("After XtOpenApplication", argv);
    for (argc--, argv++; argc > 0; argc--, argv++) {
	if (**argv != '-')
	    Syntax(*argv);

	TRACE(("parsing %s\n", argv[0]));
	switch (argv[0][1]) {
	case 'h':		/* -help */
	    Help();
	    continue;
	case 'v':		/* -version */
	    Version();
	    continue;
	case 'C':
d1924 2
a1925 2
	    {
		struct stat sbuf;
d1927 10
a1936 9
		/* Must be owner and have read/write permission.
		   xdm cooperates to give the console the right user. */
		if (!stat("/dev/console", &sbuf) &&
		    (sbuf.st_uid == getuid()) &&
		    !access("/dev/console", R_OK | W_OK)) {
		    Console = TRUE;
		} else
		    Console = FALSE;
	    }
d1938 1
a1938 1
	    Console = TRUE;
d1940 6
a1945 6
#endif /* TIOCCONS */
	    continue;
	case 'S':
	    if (!ParseSccn(*argv + 2))
		Syntax(*argv);
	    continue;
d1947 5
a1951 6
	case 'D':
	    debug = TRUE;
	    continue;
#endif /* DEBUG */
	case 'c':		/* -class param */
	    if (strcmp(argv[0] + 1, "class") == 0)
d1953 7
a1959 16
	    else
		Syntax(*argv);
	    continue;
	case 'e':
	    if (argc <= 1)
		Syntax(*argv);
	    command_to_exec = ++argv;
	    break;
	case 'i':
	    if (argc <= 1) {
		Syntax(*argv);
	    } else {
		char *endPtr;
		--argc;
		++argv;
		winToEmbedInto = (Window) strtol(argv[0], &endPtr, 10);
d1962 6
d1969 6
a1974 2
	default:
	    Syntax(*argv);
d1976 1
a1976 2
	break;
    }
d1978 1
a1978 1
    SetupMenus(toplevel, &form_top, &menu_top);
d1980 2
a1981 2
    term = (XtermWidget) XtVaCreateManagedWidget("vt100", xtermWidgetClass,
						 form_top,
d1983 6
a1988 6
						 XtNmenuBar, menu_top,
						 XtNresizable, True,
						 XtNfromVert, menu_top,
						 XtNleft, XawChainLeft,
						 XtNright, XawChainRight,
						 XtNbottom, XawChainBottom,
d1990 2
a1991 2
						 (XtPointer) 0);
    /* this causes the initialize method to be called */
d1994 1
a1994 1
    init_keyboard_type(keyboardIsHP, resource.hpFunctionKeys);
d1996 1
a1996 1
    init_keyboard_type(keyboardIsSun, resource.sunFunctionKeys);
d1998 1
a1998 1
    init_keyboard_type(keyboardIsVT220, resource.sunKeyboard);
d2001 1
a2001 1
    screen = &term->screen;
d2003 1
a2003 1
    inhibit = 0;
d2005 1
a2005 2
    if (term->misc.logInhibit)
	inhibit |= I_LOG;
d2007 1
a2007 2
    if (term->misc.signalInhibit)
	inhibit |= I_SIGNAL;
d2009 1
a2009 2
    if (term->misc.tekInhibit)
	inhibit |= I_TEK;
d2012 3
a2014 5
#if OPT_WIDE_CHARS
    my_wcwidth = &mk_wcwidth;
    if (term->misc.cjk_width)
	my_wcwidth = &mk_wcwidth_cjk;
#endif
d2016 2
a2017 7
#if OPT_SESSION_MGT
    if (resource.sessionMgt) {
	TRACE(("Enabling session-management callbacks\n"));
	XtAddCallback(toplevel, XtNdieCallback, die_callback, NULL);
	XtAddCallback(toplevel, XtNsaveCallback, save_callback, NULL);
    }
#endif
d2019 5
a2023 5
    /*
     * Set title and icon name if not specified
     */
    if (command_to_exec) {
	Arg args[2];
d2025 4
a2028 5
	if (!resource.title) {
	    if (command_to_exec) {
		resource.title = x_basename(command_to_exec[0]);
	    }			/* else not reached */
	}
d2030 4
a2033 4
	if (!resource.icon_name)
	    resource.icon_name = resource.title;
	XtSetArg(args[0], XtNtitle, resource.title);
	XtSetArg(args[1], XtNiconName, resource.icon_name);
d2035 2
a2036 4
	TRACE(("setting:\n\ttitle \"%s\"\n\ticon \"%s\"\n\tbased on command \"%s\"\n",
	       resource.title,
	       resource.icon_name,
	       *command_to_exec));
a2037 33
	XtSetValues(toplevel, args, 2);
    }
#if OPT_LUIT_PROG
    if (term->misc.callfilter) {
	int u = (term->misc.use_encoding ? 2 : 0);
	if (command_to_exec) {
	    int n;
	    char **c;
	    for (n = 0, c = command_to_exec; *c; n++, c++) ;
	    c = malloc((n + 3 + u) * sizeof(char *));
	    if (c == NULL)
		SysError(ERROR_LUMALLOC);
	    memcpy(c + 2 + u, command_to_exec, (n + 1) * sizeof(char *));
	    c[0] = term->misc.localefilter;
	    if (u) {
		c[1] = "-encoding";
		c[2] = term->misc.locale_str;
	    }
	    c[1 + u] = "--";
	    command_to_exec_with_luit = c;
	} else {
	    static char *luit[4];
	    luit[0] = term->misc.localefilter;
	    if (u) {
		luit[1] = "-encoding";
		luit[2] = term->misc.locale_str;
		luit[3] = NULL;
	    } else
		luit[1] = NULL;
	    command_to_exec_with_luit = luit;
	}
    }
#endif
d2039 2
a2040 2
    if (inhibit & I_TEK)
	screen->TekEmu = FALSE;
d2042 2
a2043 2
    if (screen->TekEmu && !TekInit())
	SysError(ERROR_INIT);
d2046 1
d2050 2
a2051 2
	   done securely by a privileged xterm process (although we try),
	   so the debug feature is disabled by default. */
d2054 5
a2058 5
	if (debug) {
	    timestamp_filename(dbglogfile, "xterm.debug.log.");
	    if (creat_as(getuid(), getgid(), False, dbglogfile, 0666)) {
		i = open(dbglogfile, O_WRONLY | O_TRUNC);
	    }
d2060 18
a2077 2
	if (i >= 0) {
	    dup2(i, 2);
d2079 2
a2080 2
	    /* mark this file as close on exec */
	    (void) fcntl(i, F_SETFD, 1);
d2083 2
a2084 1
#endif /* DEBUG */
d2086 2
a2087 2
    /* open a terminal for client */
    get_terminal();
d2089 1
a2089 1
    spawn();
d2092 1
a2092 1
    /* Child process is out there, let's catch its termination */
d2095 1
a2095 1
    (void) posix_signal(SIGCHLD, reapchild);
d2097 1
a2097 1
    (void) signal(SIGCHLD, reapchild);
d2099 1
a2099 1
    /* Realize procs have now been executed */
d2101 3
a2103 2
    if (am_slave >= 0) {	/* Write window id so master end can read and use */
	char buf[80];
d2105 5
a2109 4
	buf[0] = '\0';
	sprintf(buf, "%lx\n", XtWindow(XtParent(CURRENT_EMU(screen))));
	write(screen->respond, buf, strlen(buf));
    }
d2111 1
a2111 1
    screen->inhibit = inhibit;
d2115 4
a2118 4
    /* In AIXV3, xterms started from /dev/console have CLOCAL set.
     * This means we need to clear CLOCAL so that SIGHUP gets sent
     * to the slave-pty process when xterm exits.
     */
d2120 2
a2121 2
    {
	struct termio tio;
d2123 2
a2124 2
	if (ioctl(screen->respond, TCGETA, &tio) == -1)
	    SysError(ERROR_TIOCGETP);
d2126 1
a2126 1
	tio.c_cflag &= ~(CLOCAL);
d2128 3
a2130 3
	if (ioctl(screen->respond, TCSETA, &tio) == -1)
	    SysError(ERROR_TIOCSETP);
    }
d2133 11
a2143 3
#if defined(USE_ANY_SYSV_TERMIO) || defined(__MVS__)
    if (0 > (mode = fcntl(screen->respond, F_GETFL, 0)))
	SysError(ERROR_F_GETFL);
d2145 1
a2145 1
    mode |= O_NDELAY;
d2147 1
a2147 1
    mode |= O_NONBLOCK;
d2149 18
a2166 18
    if (fcntl(screen->respond, F_SETFL, mode))
	SysError(ERROR_F_SETFL);
#else /* !USE_ANY_SYSV_TERMIO */
    mode = 1;
    if (ioctl(screen->respond, FIONBIO, (char *) &mode) == -1)
	SysError(ERROR_FIONBIO);
#endif /* USE_ANY_SYSV_TERMIO, etc */

    FD_ZERO(&pty_mask);
    FD_ZERO(&X_mask);
    FD_ZERO(&Select_mask);
    FD_SET(screen->respond, &pty_mask);
    FD_SET(ConnectionNumber(screen->display), &X_mask);
    FD_SET(screen->respond, &Select_mask);
    FD_SET(ConnectionNumber(screen->display), &Select_mask);
    max_plus1 = ((screen->respond < ConnectionNumber(screen->display))
		 ? (1 + ConnectionNumber(screen->display))
		 : (1 + screen->respond));
d2170 4
a2173 5
    if (debug)
	printf("debugging on\n");
#endif /* DEBUG */
    XSetErrorHandler(xerror);
    XSetIOErrorHandler(xioerror);
d2176 3
a2178 3
    if (term->misc.log_on) {
	StartLog(screen);
    }
d2180 1
a2180 14

    if (winToEmbedInto != None) {
	XtRealizeWidget(toplevel);
	/*
	 * This should probably query the tree or check the attributes of
	 * winToEmbedInto in order to verify that it exists, but I'm still not
	 * certain what is the best way to do it -GPS
	 */
	XReparentWindow(XtDisplay(toplevel),
			XtWindow(toplevel),
			winToEmbedInto, 0, 0);
    }

    for (;;) {
d2182 3
a2184 3
	if (screen->TekEmu)
	    TekRun();
	else
d2186 2
a2187 2
	    VTRun();
    }
d2190 1
d2200 1
a2200 1
get_pty(int *pty, char *from GCC_UNUSED)
d2202 1
a2202 1
    int result = 1;
d2205 20
a2224 10
    static int m_tty = -1;
    static int m_pty = -1;
    struct group *ttygrp;

    if (pty == NULL) {
	result = openpty(&m_pty, &m_tty, ttydev, NULL, NULL);

	seteuid(0);
	if ((ttygrp = getgrnam(TTY_GROUP_NAME)) != 0) {
	    set_owner(ttydev, getuid(), ttygrp->gr_gid, 0600);
d2226 1
a2226 1
	    set_owner(ttydev, getuid(), getgid(), 0600);
d2228 4
a2231 8
	seteuid(getuid());
    } else if (m_pty != -1) {
	*pty = m_pty;
	result = 0;
    } else {
	result = -1;
    }
#elif defined(PUCC_PTYD)
d2233 3
a2235 3
    result = ((*pty = openrpty(ttydev, ptydev,
			       (resource.utmpInhibit ? OPTY_NOP : OPTY_LOGIN),
			       getuid(), from)) < 0);
d2237 1
a2237 1
#elif defined(__osf__) || (defined(__GLIBC__) && !defined(USE_USG_PTYS)) || defined(__NetBSD__)
d2239 2
a2240 2
    int tty;
    result = openpty(pty, &tty, ttydev, NULL, NULL);
d2244 1
a2244 1
    result = pty_search(pty);
d2249 24
a2272 26
    /*
       The order of this code is *important*.  On SYSV/386 we want to open
       a /dev/ttyp? first if at all possible.  If none are available, then
       we'll try to open a /dev/pts??? device.

       The reason for this is because /dev/ttyp? works correctly, where
       as /dev/pts??? devices have a number of bugs, (won't update
       screen correcly, will hang -- it more or less works, but you
       really don't want to use it).

       Most importantly, for boxes of this nature, one of the major
       "features" is that you can emulate a 8086 by spawning off a UNIX
       program on 80386/80486 in v86 mode.  In other words, you can spawn
       off multiple MS-DOS environments.  On ISC the program that does
       this is named "vpix."  The catcher is that "vpix" will *not* work
       with a /dev/pts??? device, will only work with a /dev/ttyp? device.

       Since we can open either a /dev/ttyp? or a /dev/pts??? device,
       the flag "IsPts" is set here so that we know which type of
       device we're dealing with in routine spawn().  That's the reason
       for the "if (IsPts)" statement in spawn(); we have two different
       device types which need to be handled differently.
     */
    result = pty_search(pty);
    if (!result)
	IsPts = 0;
d2276 6
a2281 7
#ifdef __GLIBC__		/* if __GLIBC__ and USE_USG_PTYS, we know glibc >= 2.1 */
    /* GNU libc 2 allows us to abstract away from having to know the
       master pty device name. */
    if ((*pty = getpt()) >= 0) {
	char *name = ptsname(*pty);
	if (name != 0) {	/* if filesystem is trashed, this may be null */
	    strcpy(ttydev, name);
a2283 1
    }
d2285 1
a2285 1
    result = pty_search(pty);
d2287 1
a2287 4
#if defined(USE_ISPTS_FLAG)
    if (result) {
#endif
	result = ((*pty = open("/dev/ptmx", O_RDWR)) < 0);
a2293 1
    }
d2299 5
a2303 4
    if ((*pty = open("/dev/ptc", O_RDWR)) >= 0) {
	strcpy(ttydev, ttyname(*pty));
	result = 0;
    }
d2306 2
a2307 2
    char *pty_name;
    extern char *getpty(void);
d2309 8
a2316 7
    while ((pty_name = getpty()) != NULL) {
	if ((*pty = open(pty_name, O_RDWR)) >= 0) {
	    strcpy(ptydev, pty_name);
	    strcpy(ttydev, pty_name);
	    *x_basename(ttydev) = 't';
	    result = 0;
	    break;
a2317 1
    }
d2321 1
a2321 1
    result = ((*pty = getpseudotty(&ttydev, &ptydev)) < 0);
d2325 7
a2331 1
    char *tty_name;
a2332 5
    tty_name = _getpty(pty, O_RDWR, 0622, 0);
    if (tty_name != 0) {
	strcpy(ttydev, tty_name);
	result = 0;
    }
d2335 7
a2341 1
    struct stat fstat_buf;
a2342 5
    *pty = open("/dev/ptc", O_RDWR);
    if (*pty >= 0 && (fstat(*pty, &fstat_buf)) >= 0) {
	result = 0;
	sprintf(ttydev, "/dev/ttyq%d", minor(fstat_buf.st_rdev));
    }
d2345 5
a2349 7
    /*
     * Use the clone device if it works, otherwise use pty_search logic.
     */
    if ((*pty = open("/dev/ptym/clone", O_RDWR)) >= 0) {
	char *name = ptsname(*pty);
	if (name != 0) {
	    strcpy(ttydev, name);
d2351 1
a2351 3
	} else {		/* permissions, or other unexpected problem */
	    close(*pty);
	    *pty = -1;
a2353 3
    } else {
	result = pty_search(pty);
    }
d2357 1
a2357 1
    result = pty_search(pty);
d2362 5
a2366 6
    TRACE(("get_pty(ttydev=%s, ptydev=%s) %s fd=%d\n",
	   ttydev != 0 ? ttydev : "?",
	   ptydev != 0 ? ptydev : "?",
	   result ? "FAIL" : "OK",
	   pty != 0 ? *pty : -1));
    return result;
d2383 2
a2384 2
	sprintf(ttydev, TTYFORMAT, devindex);
	sprintf(ptydev, PTYFORMAT, devindex);
d2388 1
a2388 1
	if ((*pty = open(ptydev, O_RDWR)) >= 0) {
d2394 2
a2395 2
	ttydev[strlen(ttydev) - 2] =
	    ptydev[strlen(ptydev) - 2] = PTYCHAR1[letter];
d2398 2
a2399 2
	    ttydev[strlen(ttydev) - 1] =
		ptydev[strlen(ptydev) - 1] = PTYCHAR2[devindex];
d2403 1
a2403 1
	    if ((*pty = open(ptydev, O_RDWR)) >= 0) {
d2429 1
d2432 1
a2432 1
get_terminal(void)
d2437 1
a2437 1
    register TScreen *screen = &term->screen;
d2439 3
a2441 3
    screen->arrow = make_colored_cursor(XC_left_ptr,
					screen->mousecolor,
					screen->mousecolorback);
d2458 8
a2465 9
static char *tekterm[] =
{
    "tek4014",
    "tek4015",			/* 4014 with APL character set support */
    "tek4012",			/* 4010 with lower case */
    "tek4013",			/* 4012 with APL character set support */
    "tek4010",			/* small screen, upper-case only */
    "dumb",
    0
d2476 1
a2476 2
static char *vtterm[] =
{
d2478 1
a2478 1
    "x11term",			/* for people who want special term name */
d2480 7
a2486 7
    DFT_TERMTYPE,		/* for people who want special term name */
    "xterm",			/* the prefered name, should be fastest */
    "vt102",
    "vt100",
    "ansi",
    "dumb",
    0
d2490 1
a2490 2
static SIGNAL_T
hungtty(int i GCC_UNUSED)
d2492 2
a2493 2
    siglongjmp(env, 1);
    SIGNAL_RETURN;
d2497 1
a2497 1
 * declared outside OPT_PTY_HANDSHAKE so HsSysError() callers can use
d2499 2
a2500 1
static int cp_pipe[2];		/* this pipe is used for child to parent transfer */
d2502 10
a2511 11
#if OPT_PTY_HANDSHAKE
static int pc_pipe[2];		/* this pipe is used for parent to child transfer */
typedef enum {			/* c == child, p == parent                        */
    PTY_BAD,			/* c->p: can't open pty slave for some reason     */
    PTY_FATALERROR,		/* c->p: we had a fatal error with the pty        */
    PTY_GOOD,			/* c->p: we have a good pty, let's go on          */
    PTY_NEW,			/* p->c: here is a new pty slave, try this        */
    PTY_NOMORE,			/* p->c; no more pty's, terminate                 */
    UTMP_ADDED,			/* c->p: utmp entry has been added                */
    UTMP_TTYSLOT,		/* c->p: here is my ttyslot                       */
    PTY_EXEC			/* p->c: window has been mapped the first time    */
d2515 7
a2521 7
    status_t status;
    int error;
    int fatal_error;
    int tty_slot;
    int rows;
    int cols;
    char buffer[1024];
d2535 1
a2535 1
    handshake_t handshake;
d2537 6
a2542 6
    handshake.status = PTY_FATALERROR;
    handshake.error = errno;
    handshake.fatal_error = error;
    strcpy(handshake.buffer, ttydev);
    write(pf, (char *) &handshake, sizeof(handshake));
    exit(error);
d2545 1
a2545 2
void
first_map_occurred(void)
d2553 3
a2555 3
    write(pc_pipe[1], (char *) &handshake, sizeof(handshake));
    close(cp_pipe[0]);
    close(pc_pipe[1]);
d2570 1
a2570 2
void
first_map_occurred(void)
d2574 2
a2575 1
#endif /* OPT_PTY_HANDSHAKE else !OPT_PTY_HANDSHAKE */
d2578 1
d2584 6
a2589 5
    if (chown(device, uid, gid) < 0) {
	if (errno != ENOENT
	    && getuid() == 0) {
	    fprintf(stderr, "Cannot chown %s to %d,%d: %s\n",
		    device, uid, gid, strerror(errno));
d2591 1
a2591 2
    }
    chmod(device, mode);
d2595 1
a2595 1
spawn(void)
d2602 4
a2605 4
    register TScreen *screen = &term->screen;
#if OPT_PTY_HANDSHAKE
    handshake_t handshake;
    int done;
d2608 1
a2608 1
    int initial_erase = VAL_INITIAL_ERASE;
d2610 2
a2611 2
    int rc = 0;
    int tty = -1;
d2613 1
a2613 1
    struct termio tio;
d2615 2
a2616 2
    unsigned lmode;
#endif /* TIOCLSET */
d2618 2
a2619 2
    struct ltchars ltc;
#endif /* HAS_LTCHARS */
d2621 1
a2621 1
    struct termios tio;
d2623 6
a2628 6
    int ldisc = 0;
    int discipline;
    unsigned lmode;
    struct tchars tc;
    struct ltchars ltc;
    struct sgttyb sg;
d2630 2
a2631 2
    int jmode;
    struct jtchars jtc;
d2633 1
a2633 1
#endif /* USE_ANY_SYSV_TERMIO */
d2635 15
a2649 13
    char termcap[TERMCAP_SIZE];
    char newtc[TERMCAP_SIZE];
    char *ptr, *shname, *shname_minus;
    int i, no_dev_tty = FALSE;
    char **envnew;		/* new environment */
    int envsize;		/* elements in new environment */
    char buf[64];
    char *TermName = NULL;
#ifdef TTYSIZE_STRUCT
    TTYSIZE_STRUCT ts;
#endif
    struct passwd *pw = NULL;
    char *login_name = NULL;
d2651 5
a2655 1
    struct UTMP_STR utmp;
d2657 2
a2658 1
    struct UTMP_STR *utret = NULL;
d2661 3
a2663 9
    struct lastlog lastlog;
#endif /* USE_LASTLOG */
#endif /* HAVE_UTMP */

    /* Noisy compilers */
    (void) rc;
#if defined(HAVE_UTMP) && defined(USE_SYSV_UTMP)
    (void) utret;
#endif
d2665 2
a2666 2
    screen->uid = getuid();
    screen->gid = getgid();
d2668 2
a2669 2
    termcap[0] = '\0';
    newtc[0] = '\0';
d2672 2
a2673 2
    /* so that TIOCSWINSZ || TIOCSIZE doesn't block */
    signal(SIGTTOU, SIG_IGN);
d2676 3
a2678 3
    if (am_slave >= 0) {
	screen->respond = am_slave;
	set_pty_id(ttydev, passedPty);
d2680 1
a2680 1
	set_pty_id(ptydev, passedPty);
d2682 4
a2685 4
	setgid(screen->gid);
	setuid(screen->uid);
    } else {
	Bool tty_got_hung;
d2687 5
a2691 5
	/*
	 * Sometimes /dev/tty hangs on open (as in the case of a pty
	 * that has gone away).  Simply make up some reasonable
	 * defaults.
	 */
d2693 11
a2703 11
	signal(SIGALRM, hungtty);
	alarm(2);		/* alarm(1) might return too soon */
	if (!sigsetjmp(env, 1)) {
	    tty = open("/dev/tty", O_RDWR);
	    alarm(0);
	    tty_got_hung = False;
	} else {
	    tty_got_hung = True;
	    tty = -1;
	    errno = ENXIO;
	}
d2705 1
a2705 1
	initial_erase = VAL_INITIAL_ERASE;
d2707 1
a2707 1
	signal(SIGALRM, SIG_DFL);
d2709 10
a2718 10
	/*
	 * Check results and ignore current control terminal if
	 * necessary.  ENXIO is what is normally returned if there is
	 * no controlling terminal, but some systems (e.g. SunOS 4.0)
	 * seem to return EIO.  Solaris 2.3 is said to return EINVAL.
	 * Cygwin returns ENOENT.
	 */
	no_dev_tty = FALSE;
	if (tty < 0) {
	    if (tty_got_hung || errno == ENXIO || errno == EIO ||
d2720 1
a2720 1
		errno == ENODEV ||
d2723 1
a2723 1
		errno == ENOENT ||
d2725 2
a2726 2
		errno == EINVAL || errno == ENOTTY || errno == EACCES) {
		no_dev_tty = TRUE;
d2728 2
a2729 2
		ltc = d_ltc;
#endif /* HAS_LTCHARS */
d2731 2
a2732 2
		lmode = d_lmode;
#endif /* TIOCLSET */
d2734 5
a2738 5
		tio = d_tio;
#else /* not USE_ANY_SYSV_TERMIO and not USE_POSIX_TERMIOS */
		sg = d_sg;
		tc = d_tc;
		discipline = d_disipline;
d2740 2
a2741 2
		jmode = d_jmode;
		jtc = d_jtc;
d2743 5
a2747 5
#endif /* USE_ANY_SYSV_TERMIO or USE_POSIX_TERMIOS */
	    } else {
		SysError(ERROR_OPDEVTTY);
	    }
	} else {
d2749 6
a2754 6
	    /* Get a copy of the current terminal's state,
	     * if we can.  Some systems (e.g., SVR4 and MacII)
	     * may not have a controlling terminal at this point
	     * if started directly from xdm or xinit,
	     * in which case we just use the defaults as above.
	     */
d2756 3
a2758 3
	    if (ioctl(tty, TIOCGLTC, &ltc) == -1)
		ltc = d_ltc;
#endif /* HAS_LTCHARS */
d2760 3
a2762 3
	    if (ioctl(tty, TIOCLGET, &lmode) == -1)
		lmode = d_lmode;
#endif /* TIOCLSET */
d2764 2
a2765 2
	    if ((rc = ioctl(tty, TCGETA, &tio)) == -1)
		tio = d_tio;
d2767 9
a2775 9
	    if ((rc = tcgetattr(tty, &tio)) == -1)
		tio = d_tio;
#else /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
	    if ((rc = ioctl(tty, TIOCGETP, (char *) &sg)) == -1)
		sg = d_sg;
	    if (ioctl(tty, TIOCGETC, (char *) &tc) == -1)
		tc = d_tc;
	    if (ioctl(tty, TIOCGETD, (char *) &discipline) == -1)
		discipline = d_disipline;
d2777 4
a2780 4
	    if (ioctl(tty, TIOCKGET, (char *) &jmode) == -1)
		jmode = d_jmode;
	    if (ioctl(tty, TIOCKGETC, (char *) &jtc) == -1)
		jtc = d_jtc;
d2782 1
a2782 1
#endif /* USE_ANY_SYSV_TERMIO */
d2784 6
a2789 6
	    /*
	     * If ptyInitialErase is set, we want to get the pty's
	     * erase value.  Just in case that will fail, first get
	     * the value from /dev/tty, so we will have something
	     * at least.
	     */
d2791 1
a2791 1
	    if (resource.ptyInitialErase) {
d2793 1
a2793 1
		initial_erase = tio.c_cc[VERASE];
d2795 8
a2802 8
		initial_erase = tio.c_cc[VERASE];
#else /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
		initial_erase = sg.sg_erase;
#endif /* USE_ANY_SYSV_TERMIO */
		TRACE(("%s initial_erase:%d (from /dev/tty)\n",
		       rc == 0 ? "OK" : "FAIL",
		       initial_erase));
	    }
d2805 18
a2822 4
	    close(tty);
	    /* tty is no longer an open fd! */
	    tty = -1;
	}
a2823 3
	if (get_pty(&screen->respond, XDisplayString(screen->display))) {
	    SysError(ERROR_PTYS);
	}
d2825 1
a2825 1
	if (resource.ptyInitialErase) {
d2827 3
a2829 3
	    struct termio my_tio;
	    if ((rc = ioctl(screen->respond, TCGETA, &my_tio)) == 0)
		initial_erase = my_tio.c_cc[VERASE];
d2831 13
a2843 11
	    struct termios my_tio;
	    if ((rc = tcgetattr(screen->respond, &my_tio)) == 0)
		initial_erase = my_tio.c_cc[VERASE];
#else /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
	    struct sgttyb my_sg;
	    if ((rc = ioctl(screen->respond, TIOCGETP, (char *) &my_sg)) == 0)
		initial_erase = my_sg.sg_erase;
#endif /* USE_ANY_SYSV_TERMIO */
	    TRACE(("%s initial_erase:%d (from pty)\n",
		   (rc == 0) ? "OK" : "FAIL",
		   initial_erase));
a2844 2
#endif /* OPT_INITIAL_ERASE */
    }
d2846 2
a2847 2
    /* avoid double MapWindow requests */
    XtSetMappedWhenManaged(XtParent(CURRENT_EMU(screen)), False);
d2849 2
a2850 2
    wm_delete_window = XInternAtom(XtDisplay(toplevel), "WM_DELETE_WINDOW",
				   False);
d2852 2
a2853 2
    if (!TEK4014_ACTIVE(screen))
	VTInit();		/* realize now so know window size for tty driver */
d2855 12
a2866 12
    if (Console) {
	/*
	 * Inform any running xconsole program
	 * that we are going to steal the console.
	 */
	XmuGetHostname(mit_console_name + MIT_CONSOLE_LEN, 255);
	mit_console = XInternAtom(screen->display, mit_console_name, False);
	/* the user told us to be the console, so we can use CurrentTime */
	XtOwnSelection(XtParent(CURRENT_EMU(screen)),
		       mit_console, CurrentTime,
		       ConvertConsoleSelection, NULL, NULL);
    }
d2869 5
a2873 4
    if (screen->TekEmu) {
	envnew = tekterm;
	ptr = newtc;
    } else
d2875 12
a2886 4
    {
	envnew = vtterm;
	ptr = termcap;
    }
d2888 12
a2899 14
    /*
     * This used to exit if no termcap entry was found for the specified
     * terminal name.  That's a little unfriendly, so instead we'll allow
     * the program to proceed (but not to set $TERMCAP) if the termcap
     * entry is not found.
     */
    if (!get_termcap(TermName = resource.term_name, ptr, newtc)) {
	char *last = NULL;
	TermName = *envnew;
	while (*envnew != NULL) {
	    if ((last == NULL || strcmp(last, *envnew))
		&& get_termcap(*envnew, ptr, newtc)) {
		TermName = *envnew;
		break;
a2900 2
	    last = *envnew;
	    envnew++;
a2901 1
    }
d2903 4
a2906 4
    /*
     * Check if ptyInitialErase is not set.  If so, we rely on the termcap
     * (or terminfo) to tell us what the erase mode should be set to.
     */
d2908 9
a2916 8
    TRACE(("resource ptyInitialErase is %sset\n",
	   resource.ptyInitialErase ? "" : "not "));
    if (!resource.ptyInitialErase) {
	char temp[1024], *p = temp;
	char *s = tgetstr(TERMCAP_ERASE, &p);
	TRACE(("...extracting initial_erase value from termcap\n"));
	if (s != 0) {
	    initial_erase = decode_keyvalue(&s, True);
d2918 1
a2918 2
    }
    TRACE(("...initial_erase:%d\n", initial_erase));
d2920 11
a2930 5
    TRACE(("resource backarrowKeyIsErase is %sset\n",
	   resource.backarrow_is_erase ? "" : "not "));
    if (resource.backarrow_is_erase) {	/* see input.c */
	if (initial_erase == 127) {
	    term->keyboard.flags &= ~MODE_DECBKM;
d2932 1
a2932 2
	    term->keyboard.flags |= MODE_DECBKM;
	    term->keyboard.reset_DECBKM = 1;
d2934 1
a2934 6
	TRACE(("...sets DECBKM %s\n",
	       (term->keyboard.flags & MODE_DECBKM) ? "on" : "off"));
    } else {
	term->keyboard.reset_DECBKM = 2;
    }
#endif /* OPT_INITIAL_ERASE */
d2936 13
a2948 2
#ifdef TTYSIZE_STRUCT
    /* tell tty how big window is */
d2950 16
a2965 22
    if (TEK4014_ACTIVE(screen)) {
	TTYSIZE_ROWS(ts) = 38;
	TTYSIZE_COLS(ts) = 81;
#if defined(USE_STRUCT_WINSIZE)
	ts.ws_xpixel = TFullWidth(screen);
	ts.ws_ypixel = TFullHeight(screen);
#endif
    } else
#endif
    {
	TTYSIZE_ROWS(ts) = screen->max_row + 1;
	TTYSIZE_COLS(ts) = screen->max_col + 1;
#if defined(USE_STRUCT_WINSIZE)
	ts.ws_xpixel = FullWidth(screen);
	ts.ws_ypixel = FullHeight(screen);
#endif
    }
    i = SET_TTYSIZE(screen->respond, ts);
    TRACE(("spawn SET_TTYSIZE %dx%d return %d\n",
	   TTYSIZE_ROWS(ts),
	   TTYSIZE_COLS(ts), i));
#endif /* TTYSIZE_STRUCT */
a2966 1
    added_utmp_entry = False;
d2969 4
a2972 4
    if (!resource.utmpInhibit) {
	addToUtmp(ttydev, NULL, screen->respond);
	added_utmp_entry = True;
    }
d2975 8
a2982 8
    if (am_slave < 0) {
#if OPT_PTY_HANDSHAKE
	if (resource.ptyHandshake && (pipe(pc_pipe) || pipe(cp_pipe)))
	    SysError(ERROR_FORK);
#endif
	TRACE(("Forking...\n"));
	if ((screen->pid = fork()) == -1)
	    SysError(ERROR_FORK);
d2984 5
a2988 5
	if (screen->pid == 0) {
	    /*
	     * now in child process
	     */
	    TRACE_CHILD
d2997 1
a2997 1
	    if (IsPts) {	/* SYSV386 supports both, which did we open? */
d2999 1
a2999 2
		int ptyfd = 0;
		char *pty_name = 0;
d3002 4
a3005 7
		grantpt(screen->respond);
		unlockpt(screen->respond);
		if ((pty_name = ptsname(screen->respond)) == 0) {
		    SysError(ERROR_PTSNAME);
		}
		if ((ptyfd = open(pty_name, O_RDWR)) < 0) {
		    SysError(ERROR_OPPTSNAME);
d3008 2
a3009 2
		if (ioctl(ptyfd, I_PUSH, "ptem") < 0) {
		    SysError(ERROR_PTEM);
d3012 2
a3013 2
		if (!getenv("CONSEM") && ioctl(ptyfd, I_PUSH, "consem") < 0) {
		    SysError(ERROR_CONSEM);
d3016 2
a3017 2
		if (ioctl(ptyfd, I_PUSH, "ldterm") < 0) {
		    SysError(ERROR_LDTERM);
d3020 2
a3021 2
		if (ioctl(ptyfd, I_PUSH, "ttcompat") < 0) {
		    SysError(ERROR_TTCOMPAT);
d3026 2
a3027 3
		close(screen->respond);

#ifdef TTYSIZE_STRUCT
d3030 6
a3035 6
		if (TEK4014_ACTIVE(screen)) {
		    TTYSIZE_ROWS(ts) = 24;
		    TTYSIZE_COLS(ts) = 80;
#ifdef USE_STRUCT_WINSIZE
		    ts.ws_xpixel = TFullWidth(screen);
		    ts.ws_ypixel = TFullHeight(screen);
a3036 2
		} else
#endif /* OPT_TEK4014 */
d3038 5
a3042 5
		    TTYSIZE_ROWS(ts) = screen->max_row + 1;
		    TTYSIZE_COLS(ts) = screen->max_col + 1;
#ifdef USE_STRUCT_WINSIZE
		    ts.ws_xpixel = FullWidth(screen);
		    ts.ws_ypixel = FullHeight(screen);
a3043 3
		}
#endif /* TTYSIZE_STRUCT */

d3045 1
a3045 1
	    } else {		/* else pty, not pts */
d3049 10
a3058 13
		(void) pgrp;	/* not all branches use this variable */

#if OPT_PTY_HANDSHAKE		/* warning, goes for a long ways */
		if (resource.ptyHandshake) {
		    /* close parent's sides of the pipes */
		    close(cp_pipe[0]);
		    close(pc_pipe[1]);

		    /* Make sure that our sides of the pipes are not in the
		     * 0, 1, 2 range so that we don't fight with stdin, out
		     * or err.
		     */
		    if (cp_pipe[1] <= 2) {
d3060 2
a3061 2
			    (void) close(cp_pipe[1]);
			    cp_pipe[1] = i;
d3063 2
a3064 2
		    }
		    if (pc_pipe[0] <= 2) {
d3066 2
a3067 2
			    (void) close(pc_pipe[0]);
			    pc_pipe[0] = i;
d3069 1
a3069 1
		    }
d3071 3
a3073 3
		    /* we don't need the socket, or the pty master anymore */
		    close(ConnectionNumber(screen->display));
		    close(screen->respond);
d3075 4
a3078 4
		    /* Now is the time to set up our process group and
		     * open up the pty slave.
		     */
#ifdef USE_SYSV_PGRP
d3080 1
a3080 1
		    (void) setsid();
d3082 1
a3082 1
		    (void) setpgrp();
d3087 1
a3087 1
		    qsetlogin(getlogin(), ttydev);
d3089 1
a3089 1
		    while (1) {
d3091 3
a3093 4
			if (!no_dev_tty
			    && (tty = open("/dev/tty", O_RDWR)) >= 0) {
			    ioctl(tty, TIOCNOTTY, (char *) NULL);
			    close(tty);
d3097 1
a3097 1
			(void) revoke(ttydev);
d3099 1
a3099 1
			if ((tty = open(ttydev, O_RDWR)) >= 0) {
d3104 12
a3115 9
#ifdef USE_SYSV_PGRP
			    /* We need to make sure that we are actually
			     * the process group leader for the pty.  If
			     * we are, then we should now be able to open
			     * /dev/tty.
			     */
			    if ((i = open("/dev/tty", O_RDWR)) >= 0) {
				/* success! */
				close(i);
d3117 1
a3117 4
			    }
#else /* USE_SYSV_PGRP */
			    break;
#endif /* USE_SYSV_PGRP */
d3128 1
a3128 1
			      sizeof(handshake));
d3132 1
a3132 1
				 sizeof(handshake));
d3134 2
a3135 2
			    /* parent terminated */
			    exit(1);
d3139 2
a3140 2
			    /* No more ptys, let's shutdown. */
			    exit(1);
d3145 2
a3146 2
			ttydev = (char *) malloc((unsigned)
						 (strlen(handshake.buffer) + 1));
d3151 1
a3151 1
		    }
d3153 5
a3157 4
		    /* use the same tty name that everyone else will use
		     * (from ttyname)
		     */
		    if ((ptr = ttyname(tty)) != 0) {
d3159 2
a3160 2
			ttydev = (char *) realloc(ttydev,
						  (unsigned) (strlen(ptr) + 1));
a3164 1
		    }
a3165 2
#endif /* OPT_PTY_HANDSHAKE -- from near fork */

d3167 1
a3167 1
	    }			/* end of IsPts else clause */
d3170 2
d3173 1
a3173 1
	    {
d3176 8
a3183 7
		    /* change ownership of tty to real uid, "tty" gid */
		    set_owner(ttydev, screen->uid, ttygrp->gr_gid,
			      (resource.messages ? 0620 : 0600));
		} else {
		    /* change ownership of tty to real group and user id */
		    set_owner(ttydev, screen->uid, screen->gid,
			      (resource.messages ? 0622 : 0600));
d3186 1
a3186 1
	    }
d3188 3
a3190 3
	    /* change ownership of tty to real group and user id */
	    set_owner(ttydev, screen->uid, screen->gid,
		      (resource.messages ? 0622 : 0600));
d3193 4
a3196 4
	    /*
	     * set up the tty modes
	     */
	    {
d3199 7
a3205 7
		/* If the control tty had its modes screwed around with,
		   eg. by lineedit in the shell, or emacs, etc. then tio
		   will have bad values.  Let's just get termio from the
		   new tty and tailor it.  */
		if (ioctl(tty, TCGETA, &tio) == -1)
		    SysError(ERROR_TIOCGETP);
		tio.c_lflag |= ECHOE;
d3207 7
a3213 7
		/* Now is also the time to change the modes of the
		 * child pty.
		 */
		/* input: nl->nl, don't ignore cr, cr->nl */
		tio.c_iflag &= ~(INLCR | IGNCR);
		tio.c_iflag |= ICRNL;
		/* ouput: cr->cr, nl is not return, no delays, ln->cr/nl */
d3215 2
a3216 9
		tio.c_oflag &=
		    ~(OCRNL
		      | ONLRET
		      | NLDLY
		      | CRDLY
		      | TABDLY
		      | BSDLY
		      | VTDLY
		      | FFDLY);
d3219 1
a3219 1
		tio.c_oflag |= ONLCR;
d3222 1
a3222 1
		tio.c_oflag |= OPOST;
d3224 4
d3232 1
a3232 1
		tio.c_cflag &= ~(CBAUD);
d3234 1
a3234 1
		/* baud rate is 0 (don't care) */
d3236 4
a3239 4
		tio.c_ispeed = tio.c_ospeed = VAL_LINE_SPEED;
#else /* !BAUD_0 */
		tio.c_cflag |= VAL_LINE_SPEED;
#endif /* !BAUD_0 */
d3241 2
a3242 2
		cfsetispeed(&tio, VAL_LINE_SPEED);
		cfsetospeed(&tio, VAL_LINE_SPEED);
d3244 2
a3245 2
		/* turn off bits that can't be set from the slave side */
		tio.c_cflag &= ~(PACKET | PKT3270 | PTU3270 | PKTXTND);
d3247 3
a3249 3
		/* Clear CLOCAL so that SIGHUP is sent to us
		   when the xterm ends */
		tio.c_cflag &= ~CLOCAL;
d3251 10
a3260 9
		tio.c_cflag &= ~CSIZE;
		if (screen->input_eight_bits)
		    tio.c_cflag |= CS8;
		else
		    tio.c_cflag |= CS7;
		/* enable signals, canonical processing (erase, kill, etc),
		 * echo
		 */
		tio.c_lflag |= ISIG | ICANON | ECHO | ECHOE | ECHOK;
d3262 1
a3262 1
		tio.c_lflag |= ECHOKE | IEXTEN;
d3265 1
a3265 1
		tio.c_lflag |= ECHOCTL | IEXTEN;
d3268 4
a3271 4
		/* reset EOL to default value */
		tio.c_cc[VEOL] = CEOL;	/* '^@@' */
		/* certain shells (ksh & csh) change EOF as well */
		tio.c_cc[VEOF] = CEOF;	/* '^D' */
d3273 2
a3274 4
		if (tio.c_cc[VEOL] == 0)
		    tio.c_cc[VEOL] = CEOL;	/* '^@@' */
		if (tio.c_cc[VEOF] == 0)
		    tio.c_cc[VEOF] = CEOF;	/* '^D' */
d3277 1
a3277 1
		tio.c_cc[VLNEXT] = CLNEXT;
d3280 1
a3280 1
		tio.c_cc[VWERASE] = CWERASE;
d3283 1
a3283 1
		tio.c_cc[VREPRINT] = CRPRNT;
d3286 1
a3286 1
		tio.c_cc[VRPRNT] = CRPRNT;
d3289 1
a3289 1
		tio.c_cc[VDISCARD] = CFLUSH;
d3292 1
a3292 1
		tio.c_cc[VFLUSHO] = CFLUSH;
d3295 1
a3295 1
		tio.c_cc[VSTOP] = CSTOP;
d3298 1
a3298 1
		tio.c_cc[VSTART] = CSTART;
d3301 1
a3301 1
		tio.c_cc[VSUSP] = CSUSP;
d3304 1
a3304 1
		tio.c_cc[VDSUSP] = CDSUSP;
d3306 8
a3313 8
		if (override_tty_modes) {
		    /* sysv-specific */
		    TMODE(XTTYMODE_intr, tio.c_cc[VINTR]);
		    TMODE(XTTYMODE_quit, tio.c_cc[VQUIT]);
		    TMODE(XTTYMODE_erase, tio.c_cc[VERASE]);
		    TMODE(XTTYMODE_kill, tio.c_cc[VKILL]);
		    TMODE(XTTYMODE_eof, tio.c_cc[VEOF]);
		    TMODE(XTTYMODE_eol, tio.c_cc[VEOL]);
d3315 1
a3315 1
		    TMODE(XTTYMODE_swtch, tio.c_cc[VSWTCH]);
d3318 1
a3318 1
		    TMODE(XTTYMODE_susp, tio.c_cc[VSUSP]);
d3321 1
a3321 1
		    TMODE(XTTYMODE_dsusp, tio.c_cc[VDSUSP]);
d3324 1
a3324 1
		    TMODE(XTTYMODE_rprnt, tio.c_cc[VREPRINT]);
d3327 1
a3327 1
		    TMODE(XTTYMODE_rprnt, tio.c_cc[VRPRNT]);
d3330 1
a3330 1
		    TMODE(XTTYMODE_flush, tio.c_cc[VDISCARD]);
d3333 1
a3333 1
		    TMODE(XTTYMODE_flush, tio.c_cc[VFLUSHO]);
d3336 1
a3336 1
		    TMODE(XTTYMODE_weras, tio.c_cc[VWERASE]);
d3339 1
a3339 1
		    TMODE(XTTYMODE_lnext, tio.c_cc[VLNEXT]);
d3342 1
a3342 1
		    TMODE(XTTYMODE_start, tio.c_cc[VSTART]);
d3345 1
a3345 1
		    TMODE(XTTYMODE_stop, tio.c_cc[VSTOP]);
d3348 1
a3348 1
		    TMODE(XTTYMODE_status, tio.c_cc[VSTATUS]);
d3351 7
a3357 7
		    /* both SYSV and BSD have ltchars */
		    TMODE(XTTYMODE_susp, ltc.t_suspc);
		    TMODE(XTTYMODE_dsusp, ltc.t_dsuspc);
		    TMODE(XTTYMODE_rprnt, ltc.t_rprntc);
		    TMODE(XTTYMODE_flush, ltc.t_flushc);
		    TMODE(XTTYMODE_weras, ltc.t_werasc);
		    TMODE(XTTYMODE_lnext, ltc.t_lnextc);
d3359 2
a3360 1
		}
d3363 3
a3365 3
		/* ioctl chokes when the "reserved" process group controls
		 * are not set to _POSIX_VDISABLE */
		ltc.t_rprntc = ltc.t_rprntc = ltc.t_flushc =
d3368 3
a3370 3
		if (ioctl(tty, TIOCSLTC, &ltc) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCSETC);
#endif /* HAS_LTCHARS */
d3372 3
a3374 3
		if (ioctl(tty, TIOCLSET, (char *) &lmode) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCLSET);
#endif /* TIOCLSET */
d3376 14
a3389 14
		if (ioctl(tty, TCSETA, &tio) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCSETP);
#else /* USE_POSIX_TERMIOS */
		if (tcsetattr(tty, TCSANOW, &tio) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCSETP);
#endif /* USE_POSIX_TERMIOS */
#else /* USE_ANY_SYSV_TERMIO or USE_POSIX_TERMIOS */
		sg.sg_flags &= ~(ALLDELAY | XTABS | CBREAK | RAW);
		sg.sg_flags |= ECHO | CRMOD;
		/* make sure speed is set on pty so that editors work right */
		sg.sg_ispeed = VAL_LINE_SPEED;
		sg.sg_ospeed = VAL_LINE_SPEED;
		/* reset t_brkc to default value */
		tc.t_brkc = -1;
d3391 4
a3394 4
		if (screen->input_eight_bits)
		    lmode |= LPASS8;
		else
		    lmode &= ~(LPASS8);
d3397 1
a3397 1
		jmode &= ~KM_KANJI;
d3400 19
a3418 1
		ltc = d_ltc;
d3420 10
a3429 28
		if (override_tty_modes) {
		    TMODE(XTTYMODE_intr, tc.t_intrc);
		    TMODE(XTTYMODE_quit, tc.t_quitc);
		    TMODE(XTTYMODE_erase, sg.sg_erase);
		    TMODE(XTTYMODE_kill, sg.sg_kill);
		    TMODE(XTTYMODE_eof, tc.t_eofc);
		    TMODE(XTTYMODE_start, tc.t_startc);
		    TMODE(XTTYMODE_stop, tc.t_stopc);
		    TMODE(XTTYMODE_brk, tc.t_brkc);
		    /* both SYSV and BSD have ltchars */
		    TMODE(XTTYMODE_susp, ltc.t_suspc);
		    TMODE(XTTYMODE_dsusp, ltc.t_dsuspc);
		    TMODE(XTTYMODE_rprnt, ltc.t_rprntc);
		    TMODE(XTTYMODE_flush, ltc.t_flushc);
		    TMODE(XTTYMODE_weras, ltc.t_werasc);
		    TMODE(XTTYMODE_lnext, ltc.t_lnextc);
		}

		if (ioctl(tty, TIOCSETP, (char *) &sg) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCSETP);
		if (ioctl(tty, TIOCSETC, (char *) &tc) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCSETC);
		if (ioctl(tty, TIOCSETD, (char *) &discipline) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCSETD);
		if (ioctl(tty, TIOCSLTC, (char *) &ltc) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCSLTC);
		if (ioctl(tty, TIOCLSET, (char *) &lmode) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCLSET);
d3431 4
a3434 4
		if (ioctl(tty, TIOCKSET, (char *) &jmode) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCKSET);
		if (ioctl(tty, TIOCKSETC, (char *) &jtc) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCKSETC);
d3436 1
a3436 1
#endif /* !USE_ANY_SYSV_TERMIO */
d3438 1
a3438 1
		if (Console) {
d3440 4
a3443 4
		    int on = 1;
		    if (ioctl(tty, TIOCCONS, (char *) &on) == -1)
			fprintf(stderr, "%s: cannot open console: %s\n",
				xterm_name, strerror(errno));
d3446 5
a3450 5
		    int fd = open("/dev/console", O_RDWR);
		    if (fd == -1 || ioctl(fd, SRIOCSREDIR, tty) == -1)
			fprintf(stderr, "%s: cannot open console: %s\n",
				xterm_name, strerror(errno));
		    (void) close(fd);
d3452 2
d3455 1
a3455 4
#endif /* TIOCCONS */
	    }

	    signal(SIGCHLD, SIG_DFL);
d3457 2
a3458 2
	    /* watch out for extra shells (I don't understand either) */
	    signal(SIGHUP, SIG_DFL);
d3460 1
a3460 1
	    signal(SIGHUP, SIG_IGN);
d3462 4
a3465 4
	    /* restore various signals to their defaults */
	    signal(SIGINT, SIG_DFL);
	    signal(SIGQUIT, SIG_DFL);
	    signal(SIGTERM, SIG_DFL);
d3467 5
a3471 5
	    /*
	     * If we're not asked to make the parent process set the
	     * terminal's erase mode, and if we had no ttyModes resource,
	     * then set the terminal's erase mode from our best guess.
	     */
d3473 13
a3485 15
	    TRACE(("check if we should set erase to %d:%s\n\tptyInitialErase:%d,\n\toveride_tty_modes:%d,\n\tXTTYMODE_erase:%d\n",
		   initial_erase,
		   (!resource.ptyInitialErase
		    && !override_tty_modes
		    && !ttymodelist[XTTYMODE_erase].set)
		   ? "YES" : "NO",
		   resource.ptyInitialErase,
		   override_tty_modes,
		   ttymodelist[XTTYMODE_erase].set));
	    if (!resource.ptyInitialErase
		&& !override_tty_modes
		&& !ttymodelist[XTTYMODE_erase].set) {
#if OPT_TRACE
		int old_erase;
#endif
d3487 5
a3491 7
		if (ioctl(tty, TCGETA, &tio) == -1)
		    tio = d_tio;
#if OPT_TRACE
		old_erase = tio.c_cc[VERASE];
#endif
		tio.c_cc[VERASE] = initial_erase;
		rc = ioctl(tty, TCSETA, &tio);
d3493 15
a3507 19
		if (tcgetattr(tty, &tio) == -1)
		    tio = d_tio;
#if OPT_TRACE
		old_erase = tio.c_cc[VERASE];
#endif
		tio.c_cc[VERASE] = initial_erase;
		rc = tcsetattr(tty, TCSANOW, &tio);
#else /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
		if (ioctl(tty, TIOCGETP, (char *) &sg) == -1)
		    sg = d_sg;
#if OPT_TRACE
		old_erase = sg.sg_erase;
#endif
		sg.sg_erase = initial_erase;
		rc = ioctl(tty, TIOCSETP, (char *) &sg);
#endif /* USE_ANY_SYSV_TERMIO */
		TRACE(("%s setting erase to %d (was %d)\n",
		       rc ? "FAIL" : "OK", initial_erase, old_erase));
	    }
d3510 6
a3515 5
	    /* copy the environment before Setenving */
	    for (i = 0; environ[i] != NULL; i++) ;
	    /* compute number of xtermSetenv() calls below */
	    envsize = 1;	/* (NULL terminating entry) */
	    envsize += 3;	/* TERM, WINDOWID, DISPLAY */
d3517 1
a3517 1
	    envsize += 1;	/* LOGNAME */
d3520 1
a3520 1
	    envsize += 2;	/* COLUMNS, LINES */
d3522 1
a3522 1
	    envsize += 2;	/* HOME, SHELL */
d3525 1
a3525 1
	    envsize += 1;	/* TERMINFO */
d3528 1
a3528 1
	    envsize += 1;	/* TERMCAP */
d3530 10
a3539 10
	    envnew = (char **) calloc((unsigned) i + envsize, sizeof(char *));
	    memmove((char *) envnew, (char *) environ, i * sizeof(char *));
	    environ = envnew;
	    xtermSetenv("TERM=", TermName);
	    if (!TermName)
		*newtc = 0;

	    sprintf(buf, "%lu",
		    ((unsigned long) XtWindow(XtParent(CURRENT_EMU(screen)))));
	    xtermSetenv("WINDOWID=", buf);
d3541 2
a3542 2
	    /* put the display into the environment of the shell */
	    xtermSetenv("DISPLAY=", XDisplayString(screen->display));
d3544 1
a3544 1
	    signal(SIGTERM, SIG_DFL);
d3546 4
a3549 3
	    /* this is the time to go and set up stdin, out, and err
	     */
	    {
d3551 2
a3552 2
		(void) close(tty);
		(void) close(0);
d3554 8
a3561 7
		if (open("/dev/tty", O_RDWR)) {
		    SysError(ERROR_OPDEVTTY);
		}
		(void) close(1);
		(void) close(2);
		dup(0);
		dup(0);
d3563 7
a3569 6
		/* dup the tty */
		for (i = 0; i <= 2; i++)
		    if (i != tty) {
			(void) close(i);
			(void) dup(tty);
		    }
d3571 3
a3573 3
		/* and close the tty */
		if (tty > 2)
		    (void) close(tty);
d3576 1
a3576 1
	    }
d3580 2
a3581 2
	    setsid();
	    ioctl(0, TIOCSCTTY, 0);
d3583 4
a3586 4
	    ioctl(0, TIOCSPGRP, (char *) &pgrp);
	    setpgrp(0, 0);
	    close(open(ttydev, O_WRONLY));
	    setpgrp(0, pgrp);
d3588 1
a3588 1
	    tcsetpgrp(0, pgrp /*setsid() */ );
d3592 2
d3595 8
a3602 6
	    {
		struct termio t;
		if (ioctl(0, TCGETA, &t) >= 0) {
		    /* this gets lost somewhere on our way... */
		    t.c_oflag |= OPOST;
		    ioctl(0, TCSETA, &t);
a3603 1
	    }
d3607 3
a3609 3
	    pw = getpwuid(screen->uid);
	    login_name = NULL;
	    if (pw && pw->pw_name) {
d3611 20
a3630 19
		/*
		 * If the value from getlogin() differs from the value we
		 * get by looking in the password file, check if it does
		 * correspond to the same uid.  If so, allow that as an
		 * alias for the uid.
		 *
		 * Of course getlogin() will fail if we're started from
		 * a window-manager, since there's no controlling terminal
		 * to fuss with.  In that case, try to get something useful
		 * from the user's $LOGNAME or $USER environment variables.
		 */
		if (((login_name = getlogin()) != NULL
		     || (login_name = getenv("LOGNAME")) != NULL
		     || (login_name = getenv("USER")) != NULL)
		    && strcmp(login_name, pw->pw_name)) {
		    struct passwd *pw2 = getpwnam(login_name);
		    if (pw2 != 0
			&& pw->pw_uid != pw2->pw_uid) {
			login_name = NULL;
d3632 8
a3640 9
#endif
		if (login_name == NULL)
		    login_name = pw->pw_name;
		if (login_name != NULL)
		    login_name = x_strdup(login_name);
	    }
	    if (login_name != NULL) {
		xtermSetenv("LOGNAME=", login_name);	/* for POSIX */
	    }
d3642 19
a3660 22
	    /* Set up our utmp entry now.  We need to do it here
	     * for the following reasons:
	     *   - It needs to have our correct process id (for
	     *     login).
	     *   - If our parent was to set it after the fork(),
	     *     it might make it out before we need it.
	     *   - We need to do it before we go and change our
	     *     user and group id's.
	     */
	    (void) setutent();
	    /* set up entry to search for */
	    bzero((char *) &utmp, sizeof(utmp));
	    (void) strncpy(utmp.ut_id, my_utmp_id(ttydev), sizeof(utmp.ut_id));

	    utmp.ut_type = DEAD_PROCESS;

	    /* position to entry in utmp file */
	    /* Test return value: beware of entries left behind: PSz 9 Mar 00 */
	    if (!(utret = getutid(&utmp))) {
		(void) setutent();
		utmp.ut_type = USER_PROCESS;
		if (!(utret = getutid(&utmp))) {
d3662 4
a3666 1
	    }
d3668 6
a3673 6
	    if (!utret)
		TRACE(("getutid: NULL\n"));
	    else
		TRACE(("getutid: pid=%d type=%d user=%s line=%s id=%s\n",
		       utret->ut_pid, utret->ut_type, utret->ut_user,
		       utret->ut_line, utret->ut_id));
d3676 2
a3677 2
	    /* set up the new entry */
	    utmp.ut_type = USER_PROCESS;
d3679 1
a3679 1
	    utmp.ut_xstatus = 2;
d3681 8
a3688 7
	    (void) strncpy(utmp.ut_user,
			   (login_name != NULL) ? login_name : "????",
			   sizeof(utmp.ut_user));
	    /* why are we copying this string again?  (see above) */
	    (void) strncpy(utmp.ut_id, my_utmp_id(ttydev), sizeof(utmp.ut_id));
	    (void) strncpy(utmp.ut_line,
			   my_pty_name(ttydev), sizeof(utmp.ut_line));
d3691 2
a3692 1
	    (void) strncpy(buf, DisplayString(screen->display), sizeof(buf));
d3694 5
a3698 5
	    {
		char *disfin = strrchr(buf, ':');
		if (disfin)
		    *disfin = '\0';
	    }
d3700 1
a3700 1
	    (void) strncpy(utmp.ut_host, buf, sizeof(utmp.ut_host));
d3702 1
a3702 3
	    (void) strncpy(utmp.ut_name,
			   (login_name) ? login_name : "????",
			   sizeof(utmp.ut_name));
d3704 1
a3704 1
	    utmp.ut_pid = getpid();
d3707 1
a3707 1
	    utmp.ut_session = getsid(0);
d3709 2
a3710 2
	    utmp.ut_xtime = time((time_t *) 0);
	    utmp.ut_tv.tv_usec = 0;
d3712 1
a3712 1
	    utmp.ut_time = time((time_t *) 0);
d3715 8
a3722 8
	    /* write out the entry */
	    if (!resource.utmpInhibit) {
		errno = 0;
		pututline(&utmp);
		TRACE(("pututline: %d %d %s\n",
		       resource.utmpInhibit,
		       errno, (errno != 0) ? strerror(errno) : ""));
	    }
d3724 3
a3726 3
#if defined(WTMPX_FILE) && (defined(SVR4) || defined(SCO325))
	    if (term->misc.login_shell)
		updwtmpx(WTMPX_FILE, &utmp);
d3728 2
a3729 2
	    if (term->misc.login_shell)
		updwtmp(etc_wtmp, &utmp);
d3731 5
a3735 5
	    if (term->misc.login_shell &&
		(i = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
		write(i, (char *) &utmp, sizeof(utmp));
		close(i);
	    }
d3738 2
a3739 2
	    /* close the file */
	    (void) endutent();
d3741 19
a3759 15
#else /* USE_SYSV_UTMP */
	    /* We can now get our ttyslot!  We can also set the initial
	     * utmp entry.
	     */
	    tslot = ttyslot();
	    added_utmp_entry = False;
	    {
		if (tslot > 0 && pw && !resource.utmpInhibit &&
		    (i = open(etc_utmp, O_WRONLY)) >= 0) {
		    bzero((char *) &utmp, sizeof(utmp));
		    (void) strncpy(utmp.ut_line,
				   my_pty_name(ttydev),
				   sizeof(utmp.ut_line));
		    (void) strncpy(utmp.ut_name, login_name,
				   sizeof(utmp.ut_name));
d3761 10
a3770 10
		    (void) strncpy(utmp.ut_host,
				   XDisplayString(screen->display),
				   sizeof(utmp.ut_host));
#endif
		    /* cast needed on Ultrix 4.4 */
		    time((time_t *) & utmp.ut_time);
		    lseek(i, (long) (tslot * sizeof(utmp)), 0);
		    write(i, (char *) &utmp, sizeof(utmp));
		    close(i);
		    added_utmp_entry = True;
d3772 7
a3778 6
		    if (term->misc.login_shell &&
			(i = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
			int status;
			status = write(i, (char *) &utmp, sizeof(utmp));
			status = close(i);
		    }
d3780 7
a3786 7
		    if (term->misc.login_shell &&
			(i = open(_U_LASTLOG, O_WRONLY)) >= 0) {
			lseek(i, (long) (screen->uid *
					 sizeof(utmp)), 0);
			write(i, (char *) &utmp, sizeof(utmp));
			close(i);
		    }
d3788 3
a3790 3
		} else
		    tslot = -tslot;
	    }
d3792 4
a3795 5
	    /* Let's pass our ttyslot to our parent so that it can
	     * clean up after us.
	     */
#if OPT_PTY_HANDSHAKE
	    if (resource.ptyHandshake) {
d3797 1
a3797 2
	    }
#endif /* OPT_PTY_HANDSHAKE */
d3801 1
a3801 1
	    if (term->misc.login_shell &&
d3803 14
a3816 12
		bzero((char *) &lastlog, sizeof(struct lastlog));
		(void) strncpy(lastlog.ll_line,
			       my_pty_name(ttydev),
			       sizeof(lastlog.ll_line));
		(void) strncpy(lastlog.ll_host,
			       XDisplayString(screen->display),
			       sizeof(lastlog.ll_host));
		time(&lastlog.ll_time);
		lseek(i, (long) (screen->uid * sizeof(struct lastlog)), 0);
		write(i, (char *) &lastlog, sizeof(struct lastlog));
		close(i);
	    }
d3820 1
a3820 3
	    /* Switch to real gid after writing utmp entry */
	    utmpGid = getegid();
	    if (getgid() != getegid()) {
d3822 4
a3825 2
		setegid(getgid());
	    }
d3827 1
d3829 4
a3832 5
#if OPT_PTY_HANDSHAKE
	    /* Let our parent know that we set up our utmp entry
	     * so that it can clean up after us.
	     */
	    if (resource.ptyHandshake) {
d3836 3
a3838 4
		(void) write(cp_pipe[1], (char *) &handshake, sizeof(handshake));
	    }
#endif /* OPT_PTY_HANDSHAKE */
#endif /* HAVE_UTMP */
d3840 1
a3840 1
	    (void) setgid(screen->gid);
d3842 5
a3846 4
	    if (geteuid() == 0 && pw) {
		if (initgroups(login_name, pw->pw_gid)) {
		    perror("initgroups failed");
		    SysError(ERROR_INIGROUPS);
a3847 1
	    }
d3849 6
a3854 5
	    if (setuid(screen->uid)) {
		SysError(ERROR_SETUID);
	    }
#if OPT_PTY_HANDSHAKE
	    if (resource.ptyHandshake) {
d3865 2
a3866 2
		(void) strcpy(handshake.buffer, ttydev);
		(void) write(cp_pipe[1], (char *) &handshake, sizeof(handshake));
d3869 2
a3870 2
		    i = read(pc_pipe[0], (char *) &handshake,
			     sizeof(handshake));
d3874 1
a3874 1
			exit(ERROR_PTY_EXEC);
d3876 1
a3876 1
		    if (handshake.rows > 0 && handshake.cols > 0) {
d3879 9
a3887 8
#ifdef TTYSIZE_STRUCT
			TTYSIZE_ROWS(ts) = screen->max_row + 1;
			TTYSIZE_COLS(ts) = screen->max_col + 1;
#if defined(USE_STRUCT_WINSIZE)
			ts.ws_xpixel = FullWidth(screen);
			ts.ws_ypixel = FullHeight(screen);
#endif
#endif /* TTYSIZE_STRUCT */
d3890 1
a3890 2
	    }
#endif /* OPT_PTY_HANDSHAKE */
d3893 1
a3893 1
	    {
d3895 1
a3895 1
		sprintf(numbuf, "%d", screen->max_col + 1);
d3897 1
a3897 1
		sprintf(numbuf, "%d", screen->max_row + 1);
d3899 1
a3899 1
	    }
d3901 6
a3906 6
	    if (pw) {		/* SVR4 doesn't provide these */
		if (!getenv("HOME"))
		    xtermSetenv("HOME=", pw->pw_dir);
		if (!getenv("SHELL"))
		    xtermSetenv("SHELL=", pw->pw_shell);
	    }
d3909 1
a3909 1
	    xtermSetenv("TERMINFO=", OWN_TERMINFO_DIR);
d3912 20
a3931 20
	    if (!TEK4014_ACTIVE(screen) && *newtc) {
		strcpy(termcap, newtc);
		resize(screen, termcap, newtc);
	    }
	    if (term->misc.titeInhibit && !term->misc.tiXtraScroll) {
		remove_termcap_entry(newtc, "ti=");
		remove_termcap_entry(newtc, "te=");
	    }
	    /*
	     * work around broken termcap entries */
	    if (resource.useInsertMode) {
		remove_termcap_entry(newtc, "ic=");
		/* don't get duplicates */
		remove_termcap_entry(newtc, "im=");
		remove_termcap_entry(newtc, "ei=");
		remove_termcap_entry(newtc, "mi");
		if (*newtc)
		    strcat(newtc, ":im=\\E[4h:ei=\\E[4l:mi:");
	    }
	    if (*newtc) {
d3933 6
a3938 8
		unsigned len;
		remove_termcap_entry(newtc, TERMCAP_ERASE "=");
		len = strlen(newtc);
		if (len != 0 && newtc[len - 1] == ':')
		    len--;
		sprintf(newtc + len, ":%s=\\%03o:",
			TERMCAP_ERASE,
			initial_erase & 0377);
d3940 2
a3941 2
		xtermSetenv("TERMCAP=", newtc);
	    }
a3943 12
	    /* need to reset after all the ioctl bashing we did above */
#if OPT_PTY_HANDSHAKE
	    if (resource.ptyHandshake) {
#ifdef TTYSIZE_STRUCT
		i = SET_TTYSIZE(0, ts);
		TRACE(("spawn SET_TTYSIZE %dx%d return %d\n",
		       TTYSIZE_ROWS(ts),
		       TTYSIZE_COLS(ts), i));
#endif /* TTYSIZE_STRUCT */
	    }
#endif /* OPT_PTY_HANDSHAKE */
	    signal(SIGHUP, SIG_DFL);
d3945 18
a3962 11
#ifdef HAVE_UTMP
	    if (((ptr = getenv("SHELL")) == NULL || *ptr == 0) &&
		((pw == NULL && (pw = getpwuid(screen->uid)) == NULL) ||
		 *(ptr = pw->pw_shell) == 0))
#else /* HAVE_UTMP */
	    if (((ptr = getenv("SHELL")) == NULL || *ptr == 0) &&
		((pw = getpwuid(screen->uid)) == NULL ||
		 *(ptr = pw->pw_shell) == 0))
#endif /* HAVE_UTMP */
		ptr = "/bin/sh";
	    shname = x_basename(ptr);
a3963 25
#if OPT_LUIT_PROG
	    /*
	     * Use two copies of command_to_exec, in case luit is not actually
	     * there, or refuses to run.  In that case we will fall-through to
	     * to command that the user gave anyway.
	     */
	    if (command_to_exec_with_luit) {
		TRACE(("spawning command \"%s\"\n", *command_to_exec_with_luit));
		execvp(*command_to_exec_with_luit, command_to_exec_with_luit);
		/* print error message on screen */
		fprintf(stderr, "%s: Can't execvp %s: %s\n",
			xterm_name, *command_to_exec_with_luit, strerror(errno));
		fprintf(stderr, "%s: cannot support your locale.\n",
			xterm_name);
	    }
#endif
	    if (command_to_exec) {
		TRACE(("spawning command \"%s\"\n", *command_to_exec));
		execvp(*command_to_exec, command_to_exec);
		if (command_to_exec[1] == 0)
		    execlp(ptr, shname, "-c", command_to_exec[0], (void *) 0);
		/* print error message on screen */
		fprintf(stderr, "%s: Can't execvp %s: %s\n",
			xterm_name, *command_to_exec, strerror(errno));
	    }
d3965 2
a3966 2
	    /* fix pts sh hanging around */
	    signal(SIGHUP, SIG_DFL);
d3969 14
a3982 3
	    shname_minus = (char *) malloc(strlen(shname) + 2);
	    (void) strcpy(shname_minus, "-");
	    (void) strcat(shname_minus, shname);
d3984 4
a3987 4
	    ldisc = XStrCmp("csh", shname + strlen(shname) - 3) == 0 ?
		NTTYDISC : 0;
	    ioctl(0, TIOCSETD, (char *) &ldisc);
#endif /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
d3990 2
a3991 2
	    if (term->misc.login_shell && pw && added_utmp_entry)
		execl(bin_login, "login", "-p", "-f", login_name, (void *) 0);
d3993 11
a4003 13
	    execlp(ptr,
		   (term->misc.login_shell ? shname_minus : shname),
		   (void *) 0);

	    /* Exec failed. */
	    fprintf(stderr, "%s: Could not exec %s: %s\n", xterm_name,
		    ptr, strerror(errno));
	    (void) sleep(5);
	    exit(ERROR_EXEC);
	}
	/* end if in child after fork */
#if OPT_PTY_HANDSHAKE
	if (resource.ptyHandshake) {
d4009 2
a4010 2
	    close(cp_pipe[1]);
	    close(pc_pipe[0]);
d4012 7
a4018 9
	    for (done = 0; !done;) {
		if (read(cp_pipe[0],
			 (char *) &handshake,
			 sizeof(handshake)) <= 0) {
		    /* Our child is done talking to us.  If it terminated
		     * due to an error, we will catch the death of child
		     * and clean up.
		     */
		    break;
d4021 1
a4021 1
		switch (handshake.status) {
d4023 5
a4027 5
		    /* Success!  Let's free up resources and
		     * continue.
		     */
		    done = 1;
		    break;
d4030 15
a4044 10
		    /* The open of the pty failed!  Let's get
		     * another one.
		     */
		    (void) close(screen->respond);
		    if (get_pty(&screen->respond, XDisplayString(screen->display))) {
			/* no more ptys! */
			fprintf(stderr,
				"%s: child process can find no available ptys: %s\n",
				xterm_name, strerror(errno));
			handshake.status = PTY_NOMORE;
d4046 1
a4046 6
			exit(ERROR_PTYS);
		    }
		    handshake.status = PTY_NEW;
		    (void) strcpy(handshake.buffer, ttydev);
		    write(pc_pipe[1], (char *) &handshake, sizeof(handshake));
		    break;
d4049 4
a4052 5
		    errno = handshake.error;
		    close(cp_pipe[0]);
		    close(pc_pipe[1]);
		    SysError(handshake.fatal_error);
		    /*NOTREACHED */
d4055 4
a4058 4
		    /* The utmp entry was set by our slave.  Remember
		     * this so that we can reset it later.
		     */
		    added_utmp_entry = True;
d4060 5
a4064 5
		    tslot = handshake.tty_slot;
#endif /* USE_SYSV_UTMP */
		    free(ttydev);
		    ttydev = x_strdup(handshake.buffer);
		    break;
d4066 2
a4067 2
		    fprintf(stderr, "%s: unexpected handshake status %d\n",
			    xterm_name, handshake.status);
d4072 2
a4073 2
		close(cp_pipe[0]);
		close(pc_pipe[1]);
d4075 6
a4080 3
	}
#endif /* OPT_PTY_HANDSHAKE */
    }
a4081 4
    /* end if no slave */
    /*
     * still in parent (xterm process)
     */
d4083 2
a4084 2
    /* hung sh problem? */
    signal(SIGHUP, SIG_DFL);
d4086 1
a4086 1
    signal(SIGHUP, SIG_IGN);
d4097 1
a4097 1
    signal(SIGINT, SIG_IGN);
d4100 2
a4101 2
    /* hung shell problem */
    signal(SIGQUIT, SIG_IGN);
d4103 1
a4103 1
    signal(SIGTERM, SIG_IGN);
d4105 187
a4291 5
    /* if we were spawned by a jobcontrol smart shell (like ksh or csh),
     * then our pgrp and pid will be the same.  If we were spawned by
     * a jobcontrol dumb shell (like /bin/sh), then we will be in our
     * parent's pgrp, and we must ignore keyboard signals, or we will
     * tank on everything.
d4293 99
a4391 4
    if (getpid() == getpgrp()) {
	(void) signal(SIGINT, Exit);
	(void) signal(SIGQUIT, Exit);
	(void) signal(SIGTERM, Exit);
d4393 27
a4419 3
	(void) signal(SIGINT, SIG_IGN);
	(void) signal(SIGQUIT, SIG_IGN);
	(void) signal(SIGTERM, SIG_IGN);
d4421 5
a4425 5
    (void) signal(SIGPIPE, Exit);
#else /* SYSV */
    signal(SIGINT, Exit);
    signal(SIGQUIT, Exit);
    signal(SIGTERM, Exit);
d4427 30
a4456 1
#endif /* USE_SYSV_SIGNALS and not SIGTSTP */
d4458 8
a4465 2
    return 0;
}				/* end spawn */
d4470 1
a4470 1
    register TScreen *screen = &term->screen;
d4473 2
a4474 2
    if (!resource.utmpInhibit && added_utmp_entry)
	removeFromUtmp();
d4477 10
a4486 2
    struct UTMP_STR utmp;
    struct UTMP_STR *utptr;
d4488 4
a4491 4
    /* don't do this more than once */
    if (xterm_exiting)
	SIGNAL_RETURN;
    xterm_exiting = True;
d4494 1
a4494 1
    closepty(ttydev, ptydev, (resource.utmpInhibit ? OPTY_NOP : OPTY_LOGIN), screen->respond);
d4497 6
a4502 6
    /* cleanup the utmp entry we forged earlier */
    if (!resource.utmpInhibit
#if OPT_PTY_HANDSHAKE		/* without handshake, no way to know */
	&& (resource.ptyHandshake && added_utmp_entry)
#endif /* OPT_PTY_HANDSHAKE */
	) {
d4504 4
a4507 4
	if (utmpGid != -1) {
	    /* Switch back to group utmp */
	    setegid(utmpGid);
	}
d4509 7
a4515 7
	utmp.ut_type = USER_PROCESS;
	(void) strncpy(utmp.ut_id, my_utmp_id(ttydev), sizeof(utmp.ut_id));
	(void) setutent();
	utptr = getutid(&utmp);
	/* write it out only if it exists, and the pid's match */
	if (utptr && (utptr->ut_pid == screen->pid)) {
	    utptr->ut_type = DEAD_PROCESS;
d4518 1
a4518 1
	    utptr->ut_session = getsid(0);
d4520 2
a4521 2
	    utptr->ut_xtime = time((time_t *) 0);
	    utptr->ut_tv.tv_usec = 0;
d4523 2
a4524 2
	    *utptr->ut_user = 0;
	    utptr->ut_time = time((time_t *) 0);
d4526 1
a4526 1
	    (void) pututline(utptr);
d4528 3
a4530 3
#if defined(WTMPX_FILE) && (defined(SVR4) || defined(SCO325))
	    if (term->misc.login_shell)
		updwtmpx(WTMPX_FILE, utptr);
d4532 3
a4534 3
	    strncpy(utmp.ut_line, utptr->ut_line, sizeof(utmp.ut_line));
	    if (term->misc.login_shell)
		updwtmp(etc_wtmp, utptr);
d4536 6
a4541 8
	    /* set wtmp entry if wtmp file exists */
	    if (term->misc.login_shell) {
		int fd;
		if ((fd = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
		    write(fd, utptr, sizeof(*utptr));
		    close(fd);
		}
	    }
d4545 2
d4548 10
a4557 12
	(void) endutent();
    }
#else /* not USE_SYSV_UTMP */
    register int wfd;
    struct utmp utmp;

    if (!resource.utmpInhibit && added_utmp_entry &&
	(am_slave < 0 && tslot > 0 && (wfd = open(etc_utmp, O_WRONLY)) >= 0)) {
	bzero((char *) &utmp, sizeof(utmp));
	lseek(wfd, (long) (tslot * sizeof(utmp)), 0);
	write(wfd, (char *) &utmp, sizeof(utmp));
	close(wfd);
d4559 10
a4568 8
	if (term->misc.login_shell &&
	    (wfd = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
	    (void) strncpy(utmp.ut_line,
			   my_pty_name(ttydev),
			   sizeof(utmp.ut_line));
	    time(&utmp.ut_time);
	    write(wfd, (char *) &utmp, sizeof(utmp));
	    close(wfd);
d4570 5
a4574 5
#endif /* WTMP */
    }
#endif /* USE_SYSV_UTMP */
#endif /* HAVE_UTMP */
    close(screen->respond);	/* close explicitly to avoid race with slave side */
d4576 2
a4577 2
    if (screen->logging)
	CloseLog(screen);
d4580 4
a4583 3
    if (am_slave < 0) {
	/* restore ownership of tty and pty */
	set_owner(ttydev, 0, 0, 0666);
d4585 1
a4585 1
	set_owner(ptydev, 0, 0, 0666);
d4587 4
a4590 3
    }
    exit(n);
    SIGNAL_RETURN;
d4595 1
a4595 1
resize(TScreen * screen, register char *oldtc, char *newtc)
d4598 37
a4634 37
    register char *ptr1, *ptr2;
    register size_t i;
    register int li_first = 0;
    register char *temp;

    TRACE(("resize %s\n", oldtc));
    if ((ptr1 = x_strindex(oldtc, "co#")) == NULL) {
	strcat(oldtc, "co#80:");
	ptr1 = x_strindex(oldtc, "co#");
    }
    if ((ptr2 = x_strindex(oldtc, "li#")) == NULL) {
	strcat(oldtc, "li#24:");
	ptr2 = x_strindex(oldtc, "li#");
    }
    if (ptr1 > ptr2) {
	li_first++;
	temp = ptr1;
	ptr1 = ptr2;
	ptr2 = temp;
    }
    ptr1 += 3;
    ptr2 += 3;
    strncpy(newtc, oldtc, i = ptr1 - oldtc);
    temp = newtc + i;
    sprintf(temp, "%d", (li_first
			 ? screen->max_row + 1
			 : screen->max_col + 1));
    temp += strlen(temp);
    ptr1 = strchr(ptr1, ':');
    strncpy(temp, ptr1, i = ptr2 - ptr1);
    temp += i;
    sprintf(temp, "%d", (li_first
			 ? screen->max_col + 1
			 : screen->max_row + 1));
    ptr2 = strchr(ptr2, ':');
    strcat(temp, ptr2);
    TRACE(("   ==> %s\n", newtc));
d4649 1
a4649 1
    pid_t pid;
d4651 1
a4651 1
    pid = waitpid(-1, NULL, WNOHANG);
d4653 3
a4655 3
    /* cannot do non-blocking wait */
    int pid = 0;
#else /* defined(USE_SYSV_SIGNALS) && (defined(CRAY) || !defined(SIGTSTP)) */
d4657 1
a4657 1
    int status;
d4659 1
a4659 1
    union wait status;
d4661 1
a4661 1
    register int pid;
d4663 1
a4663 1
    pid = wait3(&status, WNOHANG, (struct rusage *) NULL);
d4665 1
a4665 1
    return pid;
d4671 1
a4671 2
static SIGNAL_T
reapchild(int n GCC_UNUSED)
d4688 1
a4688 2
	    if (debug)
		fputs("Exiting\n", stderr);
d4691 1
a4691 1
		Cleanup(0);
d4693 1
a4693 1
    } while ((pid = nonblocking_wait()) > 0);
d4701 1
a4701 1
remove_termcap_entry(char *buf, char *str)
d4720 2
a4721 1
	    while ((*first++ = *buf++) != 0) ;
d4746 1
a4746 2
static int
parse_tty_modes(char *s, struct _xttymodes *modelist)
d4754 2
a4755 4
	while (*s && isascii(CharOf(*s)) && isspace(CharOf(*s)))
	    s++;
	if (!*s)
	    return count;
d4758 1
a4758 2
	    if (strncmp(s, mp->name, mp->len) == 0)
		break;
d4760 1
a4760 2
	if (!mp->name)
	    return -1;
d4763 2
a4764 4
	while (*s && isascii(CharOf(*s)) && isspace(CharOf(*s)))
	    s++;
	if (!*s)
	    return -1;
d4766 1
a4766 1
	if ((c = decode_keyvalue(&s, False)) != -1) {
d4772 1
d4776 2
a4777 3
#ifndef VMS			/* don't use pipes on OpenVMS */
int
GetBytesAvailable(int fd)
d4779 14
a4792 1
#if defined(FIONREAD)
d4794 1
a4794 1
    ioctl(fd, FIONREAD, (char *) &arg);
d4798 1
a4798 2
    struct timeval timeout =
    {0, 0};
d4800 4
a4803 4
    FD_ZERO(&set);
    FD_SET(fd, &set);
    if (select(fd + 1, &set, NULL, NULL, &timeout) > 0)
	return 1;
d4805 6
d4812 2
d4815 1
a4815 1
    return (ioctl(fd, FIORDCHK, NULL));
d4821 1
a4821 1
    return poll(pollfds, 1, 0);
d4833 8
a4840 2
#if defined(SVR4) || defined(SYSV) || !defined(X_NOT_POSIX)
    return kill(-pid, sig);
d4842 2
a4843 2
    return killpg(pid, sig);
#endif
d4847 1
a4847 2
int
A2E(int x)
d4851 1
a4851 1
    __atoe_l(&c, 1);
d4855 1
a4855 2
int
E2A(int x)
d4859 1
a4859 1
    __etoa_l(&c, 1);
d4874 1
a4874 2
int
qsetlogin(char *login, char *ttyname)
d4876 1
a4876 1
    int v = getsid(getpid());
d4878 2
a4879 2
    memset(&ps, 0, sizeof(ps));
    memset(&rps, 0, sizeof(rps));
d4881 4
a4884 4
    ps.type = _PROC_SESSION;
    ps.subtype = _PROC_SUB_ACTION1;
    ps.sid = v;
    strcpy(ps.name, login);
d4886 1
a4886 1
    Send(1, &ps, &rps, sizeof(ps), sizeof(rps));
d4888 2
a4889 2
    if (rps.status < 0)
	return (rps.status);
d4891 5
a4895 5
    ps.type = _PROC_SESSION;
    ps.subtype = _PROC_SUB_ACTION2;
    ps.sid = v;
    sprintf(ps.name, "//%d%s", getnid(), ttyname);
    Send(1, &ps, &rps, sizeof(ps), sizeof(rps));
d4897 1
a4897 1
    return (rps.status);
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 2
a2 2
#if !defined(lint) && 0
static char *rid = "$Xorg: main.c,v 1.7 2001/02/09 02:06:02 xorgcvs Exp $";
d48 1
d71 1
d94 2
a95 1
/* $XFree86: xc/programs/xterm/main.c,v 3.162 2002/12/27 21:05:22 dickey Exp $ */
d102 2
a107 2

#if defined(HAVE_LIB_XAW)
a108 4
#elif defined(HAVE_LIB_XAW3D)
#include <X11/Xaw3d/Form.h>
#elif defined(HAVE_LIB_NEXTAW)
#include <X11/neXtaw/Form.h>
a110 2
#endif /* OPT_TOOLBAR */

a122 1
#include <wcwidth.h>
d125 29
d230 1
a230 1
#ifdef SYSV			/* { */
d232 3
a234 3
#ifdef USE_USG_PTYS		/* AT&T SYSV has no ptyio.h */
#include <sys/stropts.h>	/* for I_PUSH */
#include <poll.h>		/* for POLLIN */
d241 1
a241 1
#define USE_SYSV_ENVVARS	/* COLUMNS/LINES vs. TERMCAP */
d282 3
a284 1
#else	/* } !SYSV { */	/* BSD systems */
d292 1
a292 5
extern __inline__
ttyslot()
{
    return 1;			/* yuk */
}
d315 3
a317 1
#endif /* } !SYSV */
d332 2
a333 2
#elif !(defined(VMS) || defined(WIN32) || defined(Lynx) || defined(__GNU__) || defined(__MVS__))
#include <sys/param.h>		/* for NOFILE */
a350 6
#if defined(UTMPX_FOR_UTMP)
#define UTMP_STR utmpx
#else
#define UTMP_STR utmp
#endif

d367 1
a367 1
extern struct utmp *getutid __((struct utmp * _Id));
d398 1
a398 1
#define LASTLOG_FILENAME "/usr/adm/lastlog"	/* only on BSD systems */
d438 1
a438 1
#ifdef __cplusplus
d442 2
a443 2
    extern int tgetent(char *ptr, char *name);
    extern char *tgetstr(char *name, char **ptr);
d445 2
a446 2
#ifdef __cplusplus
}
d448 1
d450 3
a452 3
static SIGNAL_T reapchild(int n);
static int spawn(void);
static void remove_termcap_entry(char *buf, char *str);
d454 1
a454 1
static int pty_search(int *pty);
d458 3
a460 3
static int get_pty(int *pty, char *from);
static void get_terminal(void);
static void resize(TScreen * s, char *oldtc, char *newtc);
a481 4
#if OPT_LUIT_PROG
static char **command_to_exec_with_luit = NULL;
#endif

d488 1
a488 1
#ifdef B38400			/* everyone should define this */
d490 1
a490 1
#else /* ...but xterm's used this for a long time */
d553 1
a553 1
#endif /* HAS_LTCHARS */
d557 1
a557 1
#endif /* TIOCLSET */
d562 2
a563 3
static struct sgttyb d_sg =
{
    0, 0, 0177, CKILL, (EVENP | ODDP | ECHO | XTABS | CRMOD)
d565 3
a567 4
static struct tchars d_tc =
{
    CINTR, CQUIT, CSTART,
    CSTOP, CEOF, CBRK
d569 3
a571 4
static struct ltchars d_ltc =
{
    CSUSP, CDSUSP, CRPRNT,
    CFLUSH, CWERASE, CLNEXT
d574 1
a574 1
static long int d_lmode = LCRTBS | LCRTERA | LCRTKIL | LCTLECH;
d576 3
a578 4
static long int d_jmode = KM_SYSSJIS | KM_ASCII;
static struct jtchars d_jtc =
{
    'J', 'B'
a589 1
/* *INDENT-OFF* */
d596 1
a596 1
    { "intr",	4, 0, '\0' },	/* tchars.t_intrc ; VINTR */
d598 1
a598 1
    { "quit",	4, 0, '\0' },	/* tchars.t_quitc ; VQUIT */
d600 1
a600 1
    { "erase",	5, 0, '\0' },	/* sgttyb.sg_erase ; VERASE */
d602 1
a602 1
    { "kill",	4, 0, '\0' },	/* sgttyb.sg_kill ; VKILL */
d604 1
a604 1
    { "eof",	3, 0, '\0' },	/* tchars.t_eofc ; VEOF */
d606 1
a606 1
    { "eol",	3, 0, '\0' },	/* VEOL */
d608 1
a608 1
    { "swtch",	5, 0, '\0' },	/* VSWTCH */
d610 1
a610 1
    { "start",	5, 0, '\0' },	/* tchars.t_startc */
d612 1
a612 1
    { "stop",	4, 0, '\0' },	/* tchars.t_stopc */
d614 1
a614 1
    { "brk",	3, 0, '\0' },	/* tchars.t_brkc */
d616 1
a616 1
    { "susp",	4, 0, '\0' },	/* ltchars.t_suspc ; VSUSP */
d618 1
a618 1
    { "dsusp",	5, 0, '\0' },	/* ltchars.t_dsuspc ; VDSUSP */
d620 1
a620 1
    { "rprnt",	5, 0, '\0' },	/* ltchars.t_rprntc ; VREPRINT */
d622 1
a622 1
    { "flush",	5, 0, '\0' },	/* ltchars.t_flushc ; VDISCARD */
d624 1
a624 1
    { "weras",	5, 0, '\0' },	/* ltchars.t_werasc ; VWERASE */
d626 1
a626 1
    { "lnext",	5, 0, '\0' },	/* ltchars.t_lnextc ; VLNEXT */
d628 1
a628 1
    { "status", 6, 0, '\0' },	/* VSTATUS */
d630 1
a630 1
    { NULL,	0, 0, '\0' },	/* end of data */
a631 1
/* *INDENT-ON* */
d635 1
a635 1
static int parse_tty_modes(char *s, struct _xttymodes *modelist);
d642 1
a642 1
#else /* not USE_SYSV_UTMP */
d644 1
a644 1
#endif /* USE_SYSV_UTMP */
d676 1
a676 1
#endif /* TIOCCONS */
d680 1
a680 1
#endif /* USE_SYSV_UTMP */
d683 37
d722 1
a722 1
#define offset(field)	XtOffsetOf(XTERM_RESOURCE, field)
d724 1
a724 2
static XtResource application_resources[] =
{
d726 1
a726 1
     offset(xterm_name), XtRString, DFT_TERMTYPE},
d728 1
a728 1
     offset(icon_geometry), XtRString, (caddr_t) NULL},
d730 1
a730 1
     offset(title), XtRString, (caddr_t) NULL},
d732 1
a732 1
     offset(icon_name), XtRString, (caddr_t) NULL},
d734 1
a734 1
     offset(term_name), XtRString, (caddr_t) NULL},
d736 9
a744 9
     offset(tty_modes), XtRString, (caddr_t) NULL},
    {"hold", "Hold", XtRBoolean, sizeof(Boolean),
     offset(hold_screen), XtRString, "false"},
    {"utmpInhibit", "UtmpInhibit", XtRBoolean, sizeof(Boolean),
     offset(utmpInhibit), XtRString, "false"},
    {"messages", "Messages", XtRBoolean, sizeof(Boolean),
     offset(messages), XtRString, "true"},
    {"sunFunctionKeys", "SunFunctionKeys", XtRBoolean, sizeof(Boolean),
     offset(sunFunctionKeys), XtRString, "false"},
d746 2
a747 2
    {"sunKeyboard", "SunKeyboard", XtRBoolean, sizeof(Boolean),
     offset(sunKeyboard), XtRString, "false"},
d750 2
a751 2
    {"hpFunctionKeys", "HpFunctionKeys", XtRBoolean, sizeof(Boolean),
     offset(hpFunctionKeys), XtRString, "false"},
d754 2
a755 2
    {"ptyInitialErase", "PtyInitialErase", XtRBoolean, sizeof(Boolean),
     offset(ptyInitialErase), XtRString, "false"},
d757 1
a757 1
     offset(backarrow_is_erase), XtRString, "false"},
d759 4
a762 4
    {"waitForMap", "WaitForMap", XtRBoolean, sizeof(Boolean),
     offset(wait_for_map), XtRString, "false"},
    {"useInsertMode", "UseInsertMode", XtRBoolean, sizeof(Boolean),
     offset(useInsertMode), XtRString, "false"},
d764 2
a765 2
    {"zIconBeep", "ZIconBeep", XtRInt, sizeof(int),
     offset(zIconBeep), XtRImmediate, 0},
d768 2
a769 6
    {"sameName", "SameName", XtRBoolean, sizeof(Boolean),
     offset(sameName), XtRString, "true"},
#endif
#if OPT_SESSION_MGT
    {"sessionMgt", "SessionMgt", XtRBoolean, sizeof(Boolean),
     offset(sessionMgt), XtRString, "true"},
d774 1
a774 2
static char *fallback_resources[] =
{
d790 1
a790 1
/* *INDENT-OFF* */
a904 6
#if OPT_LUIT_PROG
{"-lc",		"*locale",	XrmoptionNoArg,		(caddr_t) "True"},
{"+lc",		"*locale",	XrmoptionNoArg,		(caddr_t) "False"},
{"-lcc",	"*localeFilter",XrmoptionSepArg,	(caddr_t) NULL},
{"-en",		"*locale",	XrmoptionSepArg,	(caddr_t) NULL},
#endif
a917 2
{"-cjk_width",	"*cjkWidth",	XrmoptionNoArg,		(caddr_t) "on"},
{"+cjk_width",	"*cjkWidth",	XrmoptionNoArg,		(caddr_t) "off"},
a927 4
#if OPT_SESSION_MGT
{"-sm",		"*sessionMgt",	XrmoptionNoArg,		(caddr_t) "on"},
{"+sm",		"*sessionMgt",	XrmoptionNoArg,		(caddr_t) "off"},
#endif
a932 1
{"-into",	NULL,		XrmoptionSkipArg,	(caddr_t) NULL},
d934 1
a934 1
   standard XtOpenApplication options now */
d946 1
a946 1
static OptionHelp xtermOptions[] = {
d958 1
a958 1
{ "-/+fbb",                "turn on/off normal/bold font comparison inhibit"},
d976 1
a976 1
{ "-/+132",                "turn on/off 80/132 column switching" },
d979 1
a979 1
{ "-/+ai",                 "turn off/on active icon" },
d995 1
a995 1
{ "-hc color",             "selection background color" },
d1019 1
a1019 1
{ "-/+nul",                "turn off/on display of underlining" },
a1045 4
#if OPT_LUIT_PROG
{ "-/+lc",                 "turn on/off locale mode using luit" },
{ "-lcc path",             "filename of locale converter (" DEFLOCALEFILTER ")" },
#endif
d1048 1
a1048 1
{ "-/+ut",                 "turn on/off utmp support" },
d1050 1
a1050 1
{ "-/+ut",                 "turn on/off utmp support (not available)" },
a1055 1
{ "-/+cjk_width",          "turn on/off legacy CJK width convention" },
a1070 1
{ "-into windowId",        "use the window id given to -into as the parent window rather than the default root window" },
a1076 3
#if OPT_SESSION_MGT
{ "-/+sm",                 "turn on/off the session-management support" },
#endif
a1077 1
/* *INDENT-ON* */
d1079 7
a1085 8
static char *message[] =
{
    "Fonts should be fixed width and, if both normal and bold are specified, should",
    "have the same size.  If only a normal font is specified, it will be used for",
    "both normal and bold text (by doing overstriking).  The -e option, if given,",
    "must appear at the end of the command line, otherwise the user's default shell",
    "will be started.  Options that start with a plus sign (+) restore the default.",
    NULL};
d1092 1
a1092 2
static int
decode_keyvalue(char **ptr, int termcap)
a1093 1
    char *string = *ptr;
a1127 1
	++string;
d1130 2
a1131 2
	int temp = strtol(string + 1, &d, 8);
	if (temp > 0 && d != string) {
a1132 2
	    string = d;
	}
a1134 1
	++string;
a1135 1
    *ptr = string;
d1143 1
a1143 2
static Boolean
get_termcap(char *name, char *buffer, char *resized)
d1147 1
a1147 1
    *buffer = 0;		/* initialize, in case we're using terminfo's tgetent */
d1150 1
a1150 1
	if (tgetent(buffer, name) == 1) {
d1152 3
a1154 3
		   (*buffer
		    ? "ok:termcap, we can update $TERMCAP"
		    : "assuming this is terminfo")));
d1157 1
a1157 1
		    resize(screen, buffer, resized);
d1168 1
a1168 2
static int
abbrev(char *tst, char *cmp, size_t need)
d1170 2
a1171 2
    size_t len = strlen(tst);
    return ((len >= need) && (!strncmp(tst, cmp, len)));
d1174 1
a1174 2
static void
Syntax(char *badOption)
a1176 1
    OptionHelp *list = sortedOpts(xtermOptions, optionDescList, XtNumber(optionDescList));
d1179 2
a1180 2
    fprintf(stderr, "%s:  bad command line option \"%s\"\r\n\n",
	    ProgramName, badOption);
d1182 1
a1182 1
    fprintf(stderr, "usage:  %s", ProgramName);
d1184 2
a1185 2
    for (opt = list; opt->opt; opt++) {
	int len = 3 + strlen(opt->opt);		/* space [ string ] */
d1187 1
a1187 1
	    fprintf(stderr, "\r\n   ");		/* 3 spaces */
d1190 1
a1190 1
	fprintf(stderr, " [%s]", opt->opt);
d1194 3
a1196 3
    fprintf(stderr, "\r\n\nType %s -help for a full description.\r\n\n",
	    ProgramName);
    exit(1);
d1199 1
a1199 2
static void
Version(void)
d1205 1
a1205 2
static void
Help(void)
a1207 1
    OptionHelp *list = sortedOpts(xtermOptions, optionDescList, XtNumber(optionDescList));
d1210 5
a1214 6
    fprintf(stderr,
	    "%s(%d) usage:\n    %s [-options ...] [-e command args]\n\n",
	    XFREE86_VERSION, XTERM_PATCH, ProgramName);
    fprintf(stderr, "where options include:\n");
    for (opt = list; opt->opt; opt++) {
	fprintf(stderr, "    %-28s %s\n", opt->opt, opt->desc);
d1217 1
a1217 1
    putc('\n', stderr);
d1219 2
a1220 2
	fputs(*cpp, stderr);
	putc('\n', stderr);
d1222 1
a1222 1
    putc('\n', stderr);
d1229 8
a1236 7
ConvertConsoleSelection(Widget w GCC_UNUSED,
			Atom * selection GCC_UNUSED,
			Atom * target GCC_UNUSED,
			Atom * type GCC_UNUSED,
			XtPointer * value GCC_UNUSED,
			unsigned long *length GCC_UNUSED,
			int *format GCC_UNUSED)
d1243 5
a1247 19
#if OPT_SESSION_MGT
static void
die_callback(Widget w GCC_UNUSED,
	     XtPointer client_data GCC_UNUSED,
	     XtPointer call_data GCC_UNUSED)
{
    Cleanup(0);
}

static void
save_callback(Widget w GCC_UNUSED,
	      XtPointer client_data GCC_UNUSED,
	      XtPointer call_data)
{
    XtCheckpointToken token = (XtCheckpointToken) call_data;
    /* we have nothing to save */
    token->save_success = True;
}
#endif /* OPT_SESSION_MGT */
d1249 1
a1249 3
#if OPT_WIDE_CHARS
int (*my_wcwidth) (wchar_t);
#endif
d1256 5
a1260 4
DeleteWindow(Widget w,
	     XEvent * event GCC_UNUSED,
	     String * params GCC_UNUSED,
	     Cardinal * num_params GCC_UNUSED)
d1263 8
a1270 7
    if (w == toplevel) {
	if (term->screen.Tshow)
	    hide_vt_window();
	else
	    do_hangup(w, (XtPointer) 0, (XtPointer) 0);
    } else if (term->screen.Vshow)
	hide_tek_window();
d1273 1
a1273 1
	do_hangup(w, (XtPointer) 0, (XtPointer) 0);
d1278 5
a1282 4
KeyboardMapping(Widget w GCC_UNUSED,
		XEvent * event,
		String * params GCC_UNUSED,
		Cardinal * num_params GCC_UNUSED)
d1285 3
a1287 3
    case MappingNotify:
	XRefreshKeyboardMapping(&event->xmapping);
	break;
d1291 3
a1293 4
XtActionsRec actionProcs[] =
{
    {"DeleteWindow", DeleteWindow},
    {"KeyboardMapping", KeyboardMapping},
d1296 2
d1306 2
a1307 2
    size_t len = strlen(device);
    Boolean name = False;
d1309 14
a1322 13
    while (len != 0) {
	int ch = device[len - 1];
	if (isdigit(ch)) {
	    len--;
	} else if (ch == '/') {
	    if (name)
		break;
	    len--;
	} else if (isalpha(ch)) {
	    name = True;
	    len--;
	} else {
	    break;
d1324 2
a1325 3
    }
    TRACE(("my_pty_name(%s) -> '%s'\n", device, device + len));
    return device + len;
d1335 2
a1336 2
    char *name = my_pty_name(device);
    char *leaf = x_basename(name);
d1338 7
a1344 7
    if (name == leaf) {		/* no '/' in the name */
	int len = strlen(leaf);
	if (PTYCHARLEN < len)
	    leaf = leaf + (len - PTYCHARLEN);
    }
    TRACE(("my_pty_id  (%s) -> '%s'\n", device, leaf));
    return leaf;
d1353 2
a1354 2
    char *name = my_pty_name(device);
    char *leaf = x_basename(name);
d1356 6
a1361 6
    if (name == leaf) {
	strcpy(my_pty_id(device), id);
    } else {
	strcpy(leaf, id);
    }
    TRACE(("set_pty_id(%s) -> '%s'\n", id, device));
d1373 2
a1374 2
    char *leaf = x_basename(option);
    Boolean code = False;
d1376 21
a1396 17
    if (leaf != option) {
	if (leaf - option > 1
	    && leaf - option <= PTYCHARLEN
	    && sscanf(leaf, "%d", &am_slave) == 1) {
	    size_t len = leaf - option - 1;
	    /*
	     * If the given length is less than PTYCHARLEN, that is
	     * all right because the calling application may be
	     * giving us a path for /dev/pts, which would be
	     * followed by one or more decimal digits.
	     *
	     * For fixed-width fields, it is up to the calling
	     * application to provide leading 0's, if needed.
	     */
	    strncpy(passedPty, option, len);
	    passedPty[len] = 0;
	    code = True;
d1398 3
a1400 7
    } else {
	code = (sscanf(option, "%c%c%d",
		       passedPty, passedPty + 1, &am_slave) == 3);
    }
    TRACE(("ParseSccn(%s) = '%s' %d (%s)\n", option,
	   passedPty, am_slave, code ? "OK" : "ERR"));
    return code;
d1414 1
a1414 1
 * pty implementation allows more than 3 digits.
d1419 14
a1432 14
    static char result[PTYCHARLEN + 4];
    char *name = my_pty_name(device);
    char *leaf = x_basename(name);

    if (name == leaf) {		/* no '/' in the name */
	int len = strlen(leaf);
	if (PTYCHARLEN < len)
	    leaf = leaf + (len - PTYCHARLEN);
	strcpy(result, leaf);
    } else {
	sprintf(result, "p%s", leaf);
    }
    TRACE(("my_utmp_id  (%s) -> '%s'\n", device, result));
    return result;
d1438 1
a1438 1
typedef void (*sigfunc) (int);
d1440 1
a1440 1
/* make sure we sure we ignore SIGCHLD for the cases parent
d1446 1
a1446 1
    struct sigaction act, oact;
d1448 2
a1449 2
    act.sa_handler = func;
    sigemptyset(&act.sa_mask);
d1451 1
a1451 1
    act.sa_flags = SA_NOCLDSTOP | SA_RESTART;
d1453 1
a1453 1
    act.sa_flags = SA_NOCLDSTOP;
d1455 3
a1457 3
    if (sigaction(signo, &act, &oact) < 0)
	return (SIG_ERR);
    return (oact.sa_handler);
d1463 1
a1463 1
main(int argc, char *argv[]ENVP_ARG)
d1465 10
a1474 10
    Widget form_top, menu_top;
    register TScreen *screen;
    int mode;
    char *my_class = DEFCLASS;
    Window winToEmbedInto = None;

    ProgramName = argv[0];

    /* extra length in case longer tty name like /dev/ttyq255 */
    ttydev = (char *) malloc(sizeof(TTYDEV) + 80);
d1476 2
a1477 2
    ptydev = (char *) malloc(sizeof(PTYDEV) + 80);
    if (!ttydev || !ptydev)
d1479 1
a1479 1
    if (!ttydev)
d1481 7
a1487 7
    {
	fprintf(stderr,
		"%s: unable to allocate memory for ttydev or ptydev\n",
		ProgramName);
	exit(1);
    }
    strcpy(ttydev, TTYDEV);
d1489 1
a1489 1
    strcpy(ptydev, PTYDEV);
d1493 3
a1495 3
    get_pty(NULL, NULL);
    seteuid(getuid());
    setuid(getuid());
d1498 25
a1522 19
    /* Do these first, since we may not be able to open the display */
    TRACE_OPTS(xtermOptions, optionDescList, XtNumber(optionDescList));
    TRACE_ARGV("Before XtOpenApplication", argv);
    if (argc > 1) {
	int n;
	int unique = 2;
	Boolean quit = True;

	for (n = 1; n < argc; n++) {
	    TRACE(("parsing %s\n", argv[n]));
	    if (abbrev(argv[n], "-version", unique)) {
		Version();
	    } else if (abbrev(argv[n], "-help", unique)) {
		Help();
	    } else if (abbrev(argv[n], "-class", 3)) {
		if ((my_class = argv[++n]) == 0) {
		    Help();
		} else {
		    quit = False;
d1524 2
a1525 5
		unique = 3;
	    } else {
		quit = False;
		unique = 3;
	    }
a1526 3
	if (quit)
	    exit(0);
    }
d1528 1
a1528 1
    /* This dumps core on HP-UX 9.05 with X11R5 */
d1530 1
a1530 1
    XtSetLanguageProc(NULL, NULL, NULL);
d1533 28
a1560 7
#if defined(USE_ANY_SYSV_TERMIO) || defined(USE_POSIX_TERMIOS)	/* { */
    /* Initialization is done here rather than above in order
     * to prevent any assumptions about the order of the contents
     * of the various terminal structures (which may change from
     * implementation to implementation).
     */
    d_tio.c_iflag = ICRNL | IXON;
d1562 1
a1562 1
    d_tio.c_oflag = OPOST | ONLCR | TAB3;
d1565 1
a1565 1
    d_tio.c_oflag = OPOST | ONLCR;
d1567 1
a1567 1
    d_tio.c_oflag = OPOST;
d1570 3
a1572 3
#if defined(macII) || defined(ATT) || defined(CRAY)	/* { */
    d_tio.c_cflag = VAL_LINE_SPEED | CS8 | CREAD | PARENB | HUPCL;
    d_tio.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK;
d1574 1
a1574 1
    d_tio.c_lflag |= ECHOKE | IEXTEN;
d1577 1
a1577 1
    d_tio.c_lflag |= ECHOCTL | IEXTEN;
d1580 2
a1581 2
#ifndef USE_TERMIOS		/* { */
    d_tio.c_line = 0;
d1584 7
a1590 7
    d_tio.c_cc[VINTR] = CINTR;
    d_tio.c_cc[VQUIT] = CQUIT;
    d_tio.c_cc[VERASE] = CERASE;
    d_tio.c_cc[VKILL] = CKILL;
    d_tio.c_cc[VEOF] = CEOF;
    d_tio.c_cc[VEOL] = CNUL;
    d_tio.c_cc[VEOL2] = CNUL;
d1592 1
a1592 1
    d_tio.c_cc[VSWTCH] = CNUL;
d1595 2
a1596 2
#if defined(USE_TERMIOS) || defined(USE_POSIX_TERMIOS)	/* { */
    d_tio.c_cc[VSUSP] = CSUSP;
d1598 1
a1598 1
    d_tio.c_cc[VDSUSP] = CDSUSP;
d1600 6
a1605 6
    d_tio.c_cc[VREPRINT] = CRPRNT;
    d_tio.c_cc[VDISCARD] = CFLUSH;
    d_tio.c_cc[VWERASE] = CWERASE;
    d_tio.c_cc[VLNEXT] = CLNEXT;
    d_tio.c_cc[VMIN] = 1;
    d_tio.c_cc[VTIME] = 0;
d1607 7
a1613 7
#ifdef HAS_LTCHARS		/* { */
    d_ltc.t_suspc = CSUSP;	/* t_suspc */
    d_ltc.t_dsuspc = CDSUSP;	/* t_dsuspc */
    d_ltc.t_rprntc = CRPRNT;
    d_ltc.t_flushc = CFLUSH;
    d_ltc.t_werasc = CWERASE;
    d_ltc.t_lnextc = CLNEXT;
d1615 2
a1616 2
#ifdef TIOCLSET			/* { */
    d_lmode = 0;
d1618 1
a1618 1
#else /* }{ else !macII, ATT, CRAY */
d1620 5
a1624 5
#ifdef BAUD_0			/* { */
    d_tio.c_cflag = CS8 | CREAD | PARENB | HUPCL;
#else /* }{ !BAUD_0 */
    d_tio.c_cflag = VAL_LINE_SPEED | CS8 | CREAD | PARENB | HUPCL;
#endif /* } !BAUD_0 */
d1626 3
a1628 3
    d_tio.c_cflag = CS8 | CREAD | PARENB | HUPCL;
    cfsetispeed(&d_tio, VAL_LINE_SPEED);
    cfsetospeed(&d_tio, VAL_LINE_SPEED);
d1630 1
a1630 1
    d_tio.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK;
d1632 1
a1632 1
    d_tio.c_lflag |= ECHOKE | IEXTEN;
d1635 1
a1635 1
    d_tio.c_lflag |= ECHOCTL | IEXTEN;
d1639 1
a1639 1
    d_tio.c_line = NTTYDISC;
d1641 1
a1641 1
    d_tio.c_line = 0;
d1645 2
a1646 2
    d_tio.c_cflag &= ~(HUPCL | PARENB);
    d_tio.c_iflag |= BRKINT | ISTRIP | IGNPAR;
d1648 8
a1655 8
    d_tio.c_cc[VINTR] = CONTROL('C');	/* '^C' */
    d_tio.c_cc[VERASE] = 0x7f;	/* DEL  */
    d_tio.c_cc[VKILL] = CONTROL('U');	/* '^U' */
    d_tio.c_cc[VQUIT] = CQUIT;	/* '^\' */
    d_tio.c_cc[VEOF] = CEOF;	/* '^D' */
    d_tio.c_cc[VEOL] = CEOL;	/* '^@@' */
    d_tio.c_cc[VMIN] = 1;
    d_tio.c_cc[VTIME] = 0;
d1657 1
a1657 1
    d_tio.c_cc[VSWTCH] = CSWTCH;	/* usually '^Z' */
d1660 1
a1660 1
    d_tio.c_cc[VLNEXT] = CLNEXT;
d1663 1
a1663 1
    d_tio.c_cc[VWERASE] = CWERASE;
d1666 1
a1666 1
    d_tio.c_cc[VREPRINT] = CRPRNT;
d1669 1
a1669 1
    d_tio.c_cc[VRPRNT] = CRPRNT;
d1672 1
a1672 1
    d_tio.c_cc[VDISCARD] = CFLUSH;
d1675 1
a1675 1
    d_tio.c_cc[VFLUSHO] = CFLUSH;
d1678 1
a1678 1
    d_tio.c_cc[VSTOP] = CSTOP;
d1681 1
a1681 1
    d_tio.c_cc[VSTART] = CSTART;
d1684 1
a1684 1
    d_tio.c_cc[VSUSP] = CSUSP;
d1687 1
a1687 1
    d_tio.c_cc[VDSUSP] = CDSUSP;
d1690 1
a1690 1
    d_tio.c_cc[VSTATUS] = CSTATUS;
d1692 3
a1694 3
    /* now, try to inherit tty settings */
    {
	int i;
d1696 1
a1696 1
	for (i = 0; i <= 2; i++) {
d1698 2
a1699 2
	    struct termio deftio;
	    if (ioctl(i, TCGETA, &deftio) == 0)
d1701 2
a1702 2
	    struct termios deftio;
	    if (tcgetattr(i, &deftio) == 0)
d1704 7
a1710 7
	    {
		d_tio.c_cc[VINTR] = deftio.c_cc[VINTR];
		d_tio.c_cc[VQUIT] = deftio.c_cc[VQUIT];
		d_tio.c_cc[VERASE] = deftio.c_cc[VERASE];
		d_tio.c_cc[VKILL] = deftio.c_cc[VKILL];
		d_tio.c_cc[VEOF] = deftio.c_cc[VEOF];
		d_tio.c_cc[VEOL] = deftio.c_cc[VEOL];
d1712 1
a1712 1
		d_tio.c_cc[VSWTCH] = deftio.c_cc[VSWTCH];
d1715 1
a1715 1
		d_tio.c_cc[VEOL2] = deftio.c_cc[VEOL2];
d1718 1
a1718 1
		d_tio.c_cc[VLNEXT] = deftio.c_cc[VLNEXT];
d1721 1
a1721 1
		d_tio.c_cc[VWERASE] = deftio.c_cc[VWERASE];
d1724 1
a1724 1
		d_tio.c_cc[VREPRINT] = deftio.c_cc[VREPRINT];
d1727 1
a1727 1
		d_tio.c_cc[VRPRNT] = deftio.c_cc[VRPRNT];
d1730 1
a1730 1
		d_tio.c_cc[VDISCARD] = deftio.c_cc[VDISCARD];
d1733 1
a1733 1
		d_tio.c_cc[VFLUSHO] = deftio.c_cc[VFLUSHO];
d1736 1
a1736 1
		d_tio.c_cc[VSTOP] = deftio.c_cc[VSTOP];
d1739 1
a1739 1
		d_tio.c_cc[VSTART] = deftio.c_cc[VSTART];
d1742 1
a1742 1
		d_tio.c_cc[VSUSP] = deftio.c_cc[VSUSP];
d1745 1
a1745 1
		d_tio.c_cc[VDSUSP] = deftio.c_cc[VDSUSP];
d1748 1
a1748 1
		d_tio.c_cc[VSTATUS] = deftio.c_cc[VSTATUS];
d1750 2
a1751 1
		break;
d1754 10
a1763 11
    }
#ifdef HAS_LTCHARS		/* { */
    d_ltc.t_suspc = '\000';	/* t_suspc */
    d_ltc.t_dsuspc = '\000';	/* t_dsuspc */
    d_ltc.t_rprntc = '\377';	/* reserved... */
    d_ltc.t_flushc = '\377';
    d_ltc.t_werasc = '\377';
    d_ltc.t_lnextc = '\377';
#endif /* } HAS_LTCHARS */
#if defined(USE_TERMIOS) || defined(USE_POSIX_TERMIOS)	/* { */
    d_tio.c_cc[VSUSP] = CSUSP;
d1765 1
a1765 1
    d_tio.c_cc[VDSUSP] = '\000';
d1768 1
a1768 1
    d_tio.c_cc[VSTATUS] = '\377';
d1771 1
a1771 1
    d_tio.c_cc[VREPRINT] = '\377';
d1774 1
a1774 1
    d_tio.c_cc[VDISCARD] = '\377';
d1777 1
a1777 1
    d_tio.c_cc[VWERASE] = '\377';
d1780 1
a1780 1
    d_tio.c_cc[VLNEXT] = '\377';
d1783 6
a1788 5
#ifdef TIOCLSET			/* { */
    d_lmode = 0;
#endif /* } TIOCLSET */
#endif /* } macII, ATT, CRAY */
#endif /* } USE_ANY_SYSV_TERMIO || USE_POSIX_TERMIOS */
d1790 2
a1791 2
    /* Init the Toolkit. */
    {
d1793 4
a1796 4
	uid_t euid = geteuid();
	gid_t egid = getegid();
	uid_t ruid = getuid();
	gid_t rgid = getgid();
d1798 1
a1798 1
	if (setegid(rgid) == -1) {
d1800 1
a1800 1
	    if (!(errno == EMVSERR))	/* could happen if _BPX_SHAREAS=REUSE */
a1803 1
	}
d1805 1
a1805 1
	if (seteuid(ruid) == -1) {
d1807 1
a1807 1
	    if (!(errno == EMVSERR))
a1810 1
	}
d1813 11
a1823 20
	XtSetErrorHandler(xt_error);
#if OPT_SESSION_MGT
	toplevel = XtOpenApplication(&app_con, my_class,
				     optionDescList,
				     XtNumber(optionDescList),
				     &argc, argv, fallback_resources,
				     sessionShellWidgetClass,
				     NULL, 0);
#else
	toplevel = XtAppInitialize(&app_con, my_class,
				   optionDescList,
				   XtNumber(optionDescList),
				   &argc, argv, fallback_resources,
				   NULL, 0);
#endif /* OPT_SESSION_MGT */
	XtSetErrorHandler((XtErrorHandler) 0);

	XtGetApplicationResources(toplevel, (XtPointer) & resource,
				  application_resources,
				  XtNumber(application_resources), NULL, 0);
d1826 1
a1826 1
	if (seteuid(euid) == -1) {
d1828 1
a1828 1
	    if (!(errno == EMVSERR))
d1832 1
a1832 3
	}

	if (setegid(egid) == -1) {
d1834 1
a1834 1
	    if (!(errno == EMVSERR))
a1837 1
	}
a1838 1

d1840 6
a1845 4
	if (resource.utmpInhibit) {
	    /* Can totally revoke group privs */
	    setegid(getgid());
	    setgid(getgid());
a1846 2
#endif
    }
d1848 1
a1848 1
    waiting_for_initial_map = resource.wait_for_map;
d1850 4
a1853 4
    /*
     * ICCCM delete_window.
     */
    XtAppAddActions(app_con, actionProcs, XtNumber(actionProcs));
d1855 11
a1865 10
    /*
     * fill in terminal modes
     */
    if (resource.tty_modes) {
	int n = parse_tty_modes(resource.tty_modes, ttymodelist);
	if (n < 0) {
	    fprintf(stderr, "%s:  bad tty modes \"%s\"\n",
		    ProgramName, resource.tty_modes);
	} else if (n > 0) {
	    override_tty_modes = 1;
d1867 1
a1867 1
    }
d1869 6
a1874 7
    zIconBeep = resource.zIconBeep;
    zIconBeep_flagged = False;
    if (zIconBeep > 100 || zIconBeep < -100) {
	zIconBeep = 0;		/* was 100, but I prefer to defaulting off. */
	fprintf(stderr,
		"a number between -100 and 100 is required for zIconBeep.  0 used by default\n");
    }
d1877 1
a1877 1
    sameName = resource.sameName;
d1879 20
a1898 21
    hold_screen = resource.hold_screen ? 1 : 0;
    xterm_name = resource.xterm_name;
    if (strcmp(xterm_name, "-") == 0)
	xterm_name = DFT_TERMTYPE;
    if (resource.icon_geometry != NULL) {
	int scr, junk;
	int ix, iy;
	Arg args[2];

	for (scr = 0;		/* yyuucchh */
	     XtScreen(toplevel) != ScreenOfDisplay(XtDisplay(toplevel), scr);
	     scr++) ;

	args[0].name = XtNiconX;
	args[1].name = XtNiconY;
	XGeometry(XtDisplay(toplevel), scr, resource.icon_geometry, "",
		  0, 0, 0, 0, 0, &ix, &iy, &junk, &junk);
	args[0].value = (XtArgVal) ix;
	args[1].value = (XtArgVal) iy;
	XtSetValues(toplevel, args, 2);
    }
d1900 2
a1901 2
    XtSetValues(toplevel, ourTopLevelShellArgs,
		number_ourTopLevelShellArgs);
d1904 2
a1905 2
    /* seems as good a place as any */
    init_classtab();
d1908 14
a1921 15
    /* Parse the rest of the command line */
    TRACE_ARGV("After XtOpenApplication", argv);
    for (argc--, argv++; argc > 0; argc--, argv++) {
	if (**argv != '-')
	    Syntax(*argv);

	TRACE(("parsing %s\n", argv[0]));
	switch (argv[0][1]) {
	case 'h':		/* -help */
	    Help();
	    continue;
	case 'v':		/* -version */
	    Version();
	    continue;
	case 'C':
d1924 2
a1925 2
	    {
		struct stat sbuf;
d1927 10
a1936 9
		/* Must be owner and have read/write permission.
		   xdm cooperates to give the console the right user. */
		if (!stat("/dev/console", &sbuf) &&
		    (sbuf.st_uid == getuid()) &&
		    !access("/dev/console", R_OK | W_OK)) {
		    Console = TRUE;
		} else
		    Console = FALSE;
	    }
d1938 1
a1938 1
	    Console = TRUE;
d1940 6
a1945 6
#endif /* TIOCCONS */
	    continue;
	case 'S':
	    if (!ParseSccn(*argv + 2))
		Syntax(*argv);
	    continue;
d1947 5
a1951 6
	case 'D':
	    debug = TRUE;
	    continue;
#endif /* DEBUG */
	case 'c':		/* -class param */
	    if (strcmp(argv[0] + 1, "class") == 0)
d1953 7
a1959 16
	    else
		Syntax(*argv);
	    continue;
	case 'e':
	    if (argc <= 1)
		Syntax(*argv);
	    command_to_exec = ++argv;
	    break;
	case 'i':
	    if (argc <= 1) {
		Syntax(*argv);
	    } else {
		char *endPtr;
		--argc;
		++argv;
		winToEmbedInto = (Window) strtol(argv[0], &endPtr, 10);
d1962 6
d1969 6
a1974 2
	default:
	    Syntax(*argv);
d1976 1
a1976 2
	break;
    }
d1978 1
a1978 1
    SetupMenus(toplevel, &form_top, &menu_top);
d1980 2
a1981 2
    term = (XtermWidget) XtVaCreateManagedWidget("vt100", xtermWidgetClass,
						 form_top,
d1983 6
a1988 6
						 XtNmenuBar, menu_top,
						 XtNresizable, True,
						 XtNfromVert, menu_top,
						 XtNleft, XawChainLeft,
						 XtNright, XawChainRight,
						 XtNbottom, XawChainBottom,
d1990 2
a1991 2
						 (XtPointer) 0);
    /* this causes the initialize method to be called */
d1994 1
a1994 1
    init_keyboard_type(keyboardIsHP, resource.hpFunctionKeys);
d1996 1
a1996 1
    init_keyboard_type(keyboardIsSun, resource.sunFunctionKeys);
d1998 1
a1998 1
    init_keyboard_type(keyboardIsVT220, resource.sunKeyboard);
d2001 1
a2001 1
    screen = &term->screen;
d2003 1
a2003 1
    inhibit = 0;
d2005 1
a2005 2
    if (term->misc.logInhibit)
	inhibit |= I_LOG;
d2007 1
a2007 2
    if (term->misc.signalInhibit)
	inhibit |= I_SIGNAL;
d2009 1
a2009 2
    if (term->misc.tekInhibit)
	inhibit |= I_TEK;
d2012 3
a2014 5
#if OPT_WIDE_CHARS
    my_wcwidth = &mk_wcwidth;
    if (term->misc.cjk_width)
	my_wcwidth = &mk_wcwidth_cjk;
#endif
d2016 2
a2017 7
#if OPT_SESSION_MGT
    if (resource.sessionMgt) {
	TRACE(("Enabling session-management callbacks\n"));
	XtAddCallback(toplevel, XtNdieCallback, die_callback, NULL);
	XtAddCallback(toplevel, XtNsaveCallback, save_callback, NULL);
    }
#endif
d2019 5
a2023 11
    /*
     * Set title and icon name if not specified
     */
    if (command_to_exec) {
	Arg args[2];

	if (!resource.title) {
	    if (command_to_exec) {
		resource.title = x_basename(command_to_exec[0]);
	    }			/* else not reached */
	}
d2025 4
a2028 4
	if (!resource.icon_name)
	    resource.icon_name = resource.title;
	XtSetArg(args[0], XtNtitle, resource.title);
	XtSetArg(args[1], XtNiconName, resource.icon_name);
d2030 4
a2033 4
	TRACE(("setting:\n\ttitle \"%s\"\n\ticon \"%s\"\n\tbased on command \"%s\"\n",
	       resource.title,
	       resource.icon_name,
	       *command_to_exec));
d2035 1
a2035 30
	XtSetValues(toplevel, args, 2);
    }
#if OPT_LUIT_PROG
    if (term->misc.callfilter) {
	int u = (term->misc.use_encoding ? 2 : 0);
	if (command_to_exec) {
	    int n;
	    char **c;
	    for (n = 0, c = command_to_exec; *c; n++, c++) ;
	    c = malloc((n + 3 + u) * sizeof(char *));
	    if (c == NULL)
		SysError(ERROR_LUMALLOC);
	    memcpy(c + 2 + u, command_to_exec, (n + 1) * sizeof(char *));
	    c[0] = term->misc.localefilter;
	    if (u) {
		c[1] = "-encoding";
		c[2] = term->misc.locale_str;
	    }
	    c[1 + u] = "--";
	    command_to_exec_with_luit = c;
	} else {
	    static char *luit[4];
	    luit[0] = term->misc.localefilter;
	    if (u) {
		luit[1] = "-encoding";
		luit[2] = term->misc.locale_str;
		luit[3] = NULL;
	    } else
		luit[1] = NULL;
	    command_to_exec_with_luit = luit;
d2037 1
a2037 2
    }
#endif
d2039 2
a2040 2
    if (inhibit & I_TEK)
	screen->TekEmu = FALSE;
d2042 2
a2043 2
    if (screen->TekEmu && !TekInit())
	SysError(ERROR_INIT);
d2046 1
d2050 2
a2051 2
	   done securely by a privileged xterm process (although we try),
	   so the debug feature is disabled by default. */
d2054 5
a2058 5
	if (debug) {
	    timestamp_filename(dbglogfile, "xterm.debug.log.");
	    if (creat_as(getuid(), getgid(), False, dbglogfile, 0666)) {
		i = open(dbglogfile, O_WRONLY | O_TRUNC);
	    }
d2060 18
a2077 2
	if (i >= 0) {
	    dup2(i, 2);
d2079 2
a2080 2
	    /* mark this file as close on exec */
	    (void) fcntl(i, F_SETFD, 1);
d2083 2
a2084 1
#endif /* DEBUG */
d2086 2
a2087 2
    /* open a terminal for client */
    get_terminal();
d2089 1
a2089 1
    spawn();
d2092 1
a2092 1
    /* Child process is out there, let's catch its termination */
d2095 1
a2095 1
    (void) posix_signal(SIGCHLD, reapchild);
d2097 1
a2097 1
    (void) signal(SIGCHLD, reapchild);
d2099 1
a2099 1
    /* Realize procs have now been executed */
d2101 3
a2103 2
    if (am_slave >= 0) {	/* Write window id so master end can read and use */
	char buf[80];
d2105 5
a2109 4
	buf[0] = '\0';
	sprintf(buf, "%lx\n", XtWindow(XtParent(CURRENT_EMU(screen))));
	write(screen->respond, buf, strlen(buf));
    }
d2111 1
a2111 1
    screen->inhibit = inhibit;
d2115 4
a2118 4
    /* In AIXV3, xterms started from /dev/console have CLOCAL set.
     * This means we need to clear CLOCAL so that SIGHUP gets sent
     * to the slave-pty process when xterm exits.
     */
d2120 2
a2121 2
    {
	struct termio tio;
d2123 2
a2124 2
	if (ioctl(screen->respond, TCGETA, &tio) == -1)
	    SysError(ERROR_TIOCGETP);
d2126 1
a2126 1
	tio.c_cflag &= ~(CLOCAL);
d2128 3
a2130 3
	if (ioctl(screen->respond, TCSETA, &tio) == -1)
	    SysError(ERROR_TIOCSETP);
    }
d2133 11
a2143 3
#if defined(USE_ANY_SYSV_TERMIO) || defined(__MVS__)
    if (0 > (mode = fcntl(screen->respond, F_GETFL, 0)))
	SysError(ERROR_F_GETFL);
d2145 1
a2145 1
    mode |= O_NDELAY;
d2147 1
a2147 1
    mode |= O_NONBLOCK;
d2149 18
a2166 18
    if (fcntl(screen->respond, F_SETFL, mode))
	SysError(ERROR_F_SETFL);
#else /* !USE_ANY_SYSV_TERMIO */
    mode = 1;
    if (ioctl(screen->respond, FIONBIO, (char *) &mode) == -1)
	SysError(ERROR_FIONBIO);
#endif /* USE_ANY_SYSV_TERMIO, etc */

    FD_ZERO(&pty_mask);
    FD_ZERO(&X_mask);
    FD_ZERO(&Select_mask);
    FD_SET(screen->respond, &pty_mask);
    FD_SET(ConnectionNumber(screen->display), &X_mask);
    FD_SET(screen->respond, &Select_mask);
    FD_SET(ConnectionNumber(screen->display), &Select_mask);
    max_plus1 = ((screen->respond < ConnectionNumber(screen->display))
		 ? (1 + ConnectionNumber(screen->display))
		 : (1 + screen->respond));
d2170 4
a2173 5
    if (debug)
	printf("debugging on\n");
#endif /* DEBUG */
    XSetErrorHandler(xerror);
    XSetIOErrorHandler(xioerror);
d2176 3
a2178 3
    if (term->misc.log_on) {
	StartLog(screen);
    }
d2180 1
a2180 14

    if (winToEmbedInto != None) {
	XtRealizeWidget(toplevel);
	/*
	 * This should probably query the tree or check the attributes of
	 * winToEmbedInto in order to verify that it exists, but I'm still not
	 * certain what is the best way to do it -GPS
	 */
	XReparentWindow(XtDisplay(toplevel),
			XtWindow(toplevel),
			winToEmbedInto, 0, 0);
    }

    for (;;) {
d2182 3
a2184 3
	if (screen->TekEmu)
	    TekRun();
	else
d2186 2
a2187 2
	    VTRun();
    }
d2190 1
d2200 1
a2200 1
get_pty(int *pty, char *from GCC_UNUSED)
d2202 1
a2202 1
    int result = 1;
d2205 20
a2224 10
    static int m_tty = -1;
    static int m_pty = -1;
    struct group *ttygrp;

    if (pty == NULL) {
	result = openpty(&m_pty, &m_tty, ttydev, NULL, NULL);

	seteuid(0);
	if ((ttygrp = getgrnam(TTY_GROUP_NAME)) != 0) {
	    set_owner(ttydev, getuid(), ttygrp->gr_gid, 0600);
d2226 1
a2226 1
	    set_owner(ttydev, getuid(), getgid(), 0600);
d2228 4
a2231 8
	seteuid(getuid());
    } else if (m_pty != -1) {
	*pty = m_pty;
	result = 0;
    } else {
	result = -1;
    }
#elif defined(PUCC_PTYD)
d2233 3
a2235 3
    result = ((*pty = openrpty(ttydev, ptydev,
			       (resource.utmpInhibit ? OPTY_NOP : OPTY_LOGIN),
			       getuid(), from)) < 0);
d2237 1
a2237 1
#elif defined(__osf__) || (defined(__GLIBC__) && !defined(USE_USG_PTYS)) || defined(__NetBSD__)
d2239 2
a2240 2
    int tty;
    result = openpty(pty, &tty, ttydev, NULL, NULL);
d2244 1
a2244 1
    result = pty_search(pty);
d2249 24
a2272 24
    /*
       The order of this code is *important*.  On SYSV/386 we want to open
       a /dev/ttyp? first if at all possible.  If none are available, then
       we'll try to open a /dev/pts??? device.

       The reason for this is because /dev/ttyp? works correctly, where
       as /dev/pts??? devices have a number of bugs, (won't update
       screen correcly, will hang -- it more or less works, but you
       really don't want to use it).

       Most importantly, for boxes of this nature, one of the major
       "features" is that you can emulate a 8086 by spawning off a UNIX
       program on 80386/80486 in v86 mode.  In other words, you can spawn
       off multiple MS-DOS environments.  On ISC the program that does
       this is named "vpix."  The catcher is that "vpix" will *not* work
       with a /dev/pts??? device, will only work with a /dev/ttyp? device.

       Since we can open either a /dev/ttyp? or a /dev/pts??? device,
       the flag "IsPts" is set here so that we know which type of
       device we're dealing with in routine spawn().  That's the reason
       for the "if (IsPts)" statement in spawn(); we have two different
       device types which need to be handled differently.
     */
    result = pty_search(pty);
d2277 5
a2281 7
#ifdef __GLIBC__		/* if __GLIBC__ and USE_USG_PTYS, we know glibc >= 2.1 */
    /* GNU libc 2 allows us to abstract away from having to know the
       master pty device name. */
    if ((*pty = getpt()) >= 0) {
	char *name = ptsname(*pty);
	if (name != 0) {	/* if filesystem is trashed, this may be null */
	    strcpy(ttydev, name);
a2283 1
    }
d2285 1
a2285 1
    result = pty_search(pty);
d2287 1
a2287 1
    result = ((*pty = open("/dev/ptmx", O_RDWR)) < 0);
d2290 2
a2291 2
    if (!result)
	strcpy(ttydev, ptsname(*pty));
d2293 1
a2293 1
    IsPts = !result;		/* true if we're successful */
d2299 5
a2303 4
    if ((*pty = open("/dev/ptc", O_RDWR)) >= 0) {
	strcpy(ttydev, ttyname(*pty));
	result = 0;
    }
d2306 2
a2307 2
    char *pty_name;
    extern char *getpty(void);
d2309 8
a2316 7
    while ((pty_name = getpty()) != NULL) {
	if ((*pty = open(pty_name, O_RDWR)) >= 0) {
	    strcpy(ptydev, pty_name);
	    strcpy(ttydev, pty_name);
	    *x_basename(ttydev) = 't';
	    result = 0;
	    break;
a2317 1
    }
d2321 1
a2321 1
    result = ((*pty = getpseudotty(&ttydev, &ptydev)) < 0);
d2325 7
a2331 1
    char *tty_name;
a2332 5
    tty_name = _getpty(pty, O_RDWR, 0622, 0);
    if (tty_name != 0) {
	strcpy(ttydev, tty_name);
	result = 0;
    }
d2335 7
a2341 1
    struct stat fstat_buf;
a2342 5
    *pty = open("/dev/ptc", O_RDWR);
    if (*pty >= 0 && (fstat(*pty, &fstat_buf)) >= 0) {
	result = 0;
	sprintf(ttydev, "/dev/ttyq%d", minor(fstat_buf.st_rdev));
    }
d2345 13
a2357 13
    /*
     * Use the clone device if it works, otherwise use pty_search logic.
     */
    if ((*pty = open("/dev/ptym/clone", O_RDWR)) >= 0) {
	strcpy(ttydev, ptsname(*pty));
	result = 0;
    } else {
	result = pty_search(pty);
    }

#else

    result = pty_search(pty);
d2362 5
a2366 6
    TRACE(("get_pty(ttydev=%s, ptydev=%s) %s fd=%d\n",
	   ttydev != 0 ? ttydev : "?",
	   ptydev != 0 ? ptydev : "?",
	   result ? "FAIL" : "OK",
	   pty != 0 ? *pty : -1));
    return result;
d2383 2
a2384 2
	sprintf(ttydev, TTYFORMAT, devindex);
	sprintf(ptydev, PTYFORMAT, devindex);
d2388 1
a2388 1
	if ((*pty = open(ptydev, O_RDWR)) >= 0) {
d2394 2
a2395 2
	ttydev[strlen(ttydev) - 2] =
	    ptydev[strlen(ptydev) - 2] = PTYCHAR1[letter];
d2398 2
a2399 2
	    ttydev[strlen(ttydev) - 1] =
		ptydev[strlen(ptydev) - 1] = PTYCHAR2[devindex];
d2403 1
a2403 1
	    if ((*pty = open(ptydev, O_RDWR)) >= 0) {
d2429 1
d2432 1
a2432 1
get_terminal(void)
d2437 1
a2437 1
    register TScreen *screen = &term->screen;
d2439 3
a2441 3
    screen->arrow = make_colored_cursor(XC_left_ptr,
					screen->mousecolor,
					screen->mousecolorback);
d2458 8
a2465 9
static char *tekterm[] =
{
    "tek4014",
    "tek4015",			/* 4014 with APL character set support */
    "tek4012",			/* 4010 with lower case */
    "tek4013",			/* 4012 with APL character set support */
    "tek4010",			/* small screen, upper-case only */
    "dumb",
    0
d2476 1
a2476 2
static char *vtterm[] =
{
d2478 1
a2478 1
    "x11term",			/* for people who want special term name */
d2480 7
a2486 7
    DFT_TERMTYPE,		/* for people who want special term name */
    "xterm",			/* the prefered name, should be fastest */
    "vt102",
    "vt100",
    "ansi",
    "dumb",
    0
d2490 1
a2490 2
static SIGNAL_T
hungtty(int i GCC_UNUSED)
d2492 2
a2493 2
    siglongjmp(env, 1);
    SIGNAL_RETURN;
d2499 2
a2500 2
static int pc_pipe[2];		/* this pipe is used for parent to child transfer */
static int cp_pipe[2];		/* this pipe is used for child to parent transfer */
d2503 9
a2511 9
typedef enum {			/* c == child, p == parent                        */
    PTY_BAD,			/* c->p: can't open pty slave for some reason     */
    PTY_FATALERROR,		/* c->p: we had a fatal error with the pty        */
    PTY_GOOD,			/* c->p: we have a good pty, let's go on          */
    PTY_NEW,			/* p->c: here is a new pty slave, try this        */
    PTY_NOMORE,			/* p->c; no more pty's, terminate                 */
    UTMP_ADDED,			/* c->p: utmp entry has been added                */
    UTMP_TTYSLOT,		/* c->p: here is my ttyslot                       */
    PTY_EXEC			/* p->c: window has been mapped the first time    */
d2515 7
a2521 7
    status_t status;
    int error;
    int fatal_error;
    int tty_slot;
    int rows;
    int cols;
    char buffer[1024];
d2535 1
a2535 1
    handshake_t handshake;
d2537 6
a2542 6
    handshake.status = PTY_FATALERROR;
    handshake.error = errno;
    handshake.fatal_error = error;
    strcpy(handshake.buffer, ttydev);
    write(pf, (char *) &handshake, sizeof(handshake));
    exit(error);
d2545 1
a2545 2
void
first_map_occurred(void)
d2553 3
a2555 3
    write(pc_pipe[1], (char *) &handshake, sizeof(handshake));
    close(cp_pipe[0]);
    close(pc_pipe[1]);
d2570 1
a2570 2
void
first_map_occurred(void)
d2576 1
d2578 1
d2584 6
a2589 5
    if (chown(device, uid, gid) < 0) {
	if (errno != ENOENT
	    && getuid() == 0) {
	    fprintf(stderr, "Cannot chown %s to %d,%d: %s\n",
		    device, uid, gid, strerror(errno));
d2591 1
a2591 2
    }
    chmod(device, mode);
d2595 1
a2595 1
spawn(void)
d2602 1
a2602 1
    register TScreen *screen = &term->screen;
d2604 2
a2605 2
    handshake_t handshake;
    int done;
d2608 1
a2608 1
    int initial_erase = VAL_INITIAL_ERASE;
d2610 2
a2611 2
    int rc;
    int tty = -1;
d2613 1
a2613 1
    struct termio tio;
d2615 2
a2616 2
    unsigned lmode;
#endif /* TIOCLSET */
d2618 2
a2619 2
    struct ltchars ltc;
#endif /* HAS_LTCHARS */
d2621 1
a2621 1
    struct termios tio;
d2623 6
a2628 6
    int ldisc = 0;
    int discipline;
    unsigned lmode;
    struct tchars tc;
    struct ltchars ltc;
    struct sgttyb sg;
d2630 2
a2631 2
    int jmode;
    struct jtchars jtc;
d2633 1
a2633 1
#endif /* USE_ANY_SYSV_TERMIO */
d2635 8
a2642 8
    char termcap[TERMCAP_SIZE];
    char newtc[TERMCAP_SIZE];
    char *ptr, *shname, *shname_minus;
    int i, no_dev_tty = FALSE;
    char **envnew;		/* new environment */
    int envsize;		/* elements in new environment */
    char buf[64];
    char *TermName = NULL;
d2644 1
a2644 1
    struct ttysize ts;
d2646 4
a2649 4
    struct winsize ws;
#endif /* sun vs TIOCSWINSZ */
    struct passwd *pw = NULL;
    char *login_name = NULL;
d2651 5
a2655 1
    struct UTMP_STR utmp;
d2657 2
a2658 1
    struct UTMP_STR *utret;
d2661 3
a2663 3
    struct lastlog lastlog;
#endif /* USE_LASTLOG */
#endif /* HAVE_UTMP */
d2665 2
a2666 2
    screen->uid = getuid();
    screen->gid = getgid();
d2668 2
a2669 2
    termcap[0] = '\0';
    newtc[0] = '\0';
d2672 2
a2673 2
    /* so that TIOCSWINSZ || TIOCSIZE doesn't block */
    signal(SIGTTOU, SIG_IGN);
d2676 3
a2678 3
    if (am_slave >= 0) {
	screen->respond = am_slave;
	set_pty_id(ttydev, passedPty);
d2680 1
a2680 1
	set_pty_id(ptydev, passedPty);
d2682 4
a2685 4
	setgid(screen->gid);
	setuid(screen->uid);
    } else {
	Bool tty_got_hung;
d2687 5
a2691 5
	/*
	 * Sometimes /dev/tty hangs on open (as in the case of a pty
	 * that has gone away).  Simply make up some reasonable
	 * defaults.
	 */
d2693 11
a2703 11
	signal(SIGALRM, hungtty);
	alarm(2);		/* alarm(1) might return too soon */
	if (!sigsetjmp(env, 1)) {
	    tty = open("/dev/tty", O_RDWR);
	    alarm(0);
	    tty_got_hung = False;
	} else {
	    tty_got_hung = True;
	    tty = -1;
	    errno = ENXIO;
	}
d2705 1
a2705 1
	initial_erase = VAL_INITIAL_ERASE;
d2707 1
a2707 1
	signal(SIGALRM, SIG_DFL);
d2709 10
a2718 10
	/*
	 * Check results and ignore current control terminal if
	 * necessary.  ENXIO is what is normally returned if there is
	 * no controlling terminal, but some systems (e.g. SunOS 4.0)
	 * seem to return EIO.  Solaris 2.3 is said to return EINVAL.
	 * Cygwin returns ENOENT.
	 */
	no_dev_tty = FALSE;
	if (tty < 0) {
	    if (tty_got_hung || errno == ENXIO || errno == EIO ||
d2720 1
a2720 1
		errno == ENODEV ||
d2723 1
a2723 1
		errno == ENOENT ||
d2725 2
a2726 2
		errno == EINVAL || errno == ENOTTY || errno == EACCES) {
		no_dev_tty = TRUE;
d2728 2
a2729 2
		ltc = d_ltc;
#endif /* HAS_LTCHARS */
d2731 2
a2732 2
		lmode = d_lmode;
#endif /* TIOCLSET */
d2734 5
a2738 5
		tio = d_tio;
#else /* not USE_ANY_SYSV_TERMIO and not USE_POSIX_TERMIOS */
		sg = d_sg;
		tc = d_tc;
		discipline = d_disipline;
d2740 2
a2741 2
		jmode = d_jmode;
		jtc = d_jtc;
d2743 5
a2747 5
#endif /* USE_ANY_SYSV_TERMIO or USE_POSIX_TERMIOS */
	    } else {
		SysError(ERROR_OPDEVTTY);
	    }
	} else {
d2749 6
a2754 6
	    /* Get a copy of the current terminal's state,
	     * if we can.  Some systems (e.g., SVR4 and MacII)
	     * may not have a controlling terminal at this point
	     * if started directly from xdm or xinit,
	     * in which case we just use the defaults as above.
	     */
d2756 3
a2758 3
	    if (ioctl(tty, TIOCGLTC, &ltc) == -1)
		ltc = d_ltc;
#endif /* HAS_LTCHARS */
d2760 3
a2762 3
	    if (ioctl(tty, TIOCLGET, &lmode) == -1)
		lmode = d_lmode;
#endif /* TIOCLSET */
d2764 2
a2765 2
	    if ((rc = ioctl(tty, TCGETA, &tio)) == -1)
		tio = d_tio;
d2767 9
a2775 9
	    if ((rc = tcgetattr(tty, &tio)) == -1)
		tio = d_tio;
#else /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
	    if ((rc = ioctl(tty, TIOCGETP, (char *) &sg)) == -1)
		sg = d_sg;
	    if (ioctl(tty, TIOCGETC, (char *) &tc) == -1)
		tc = d_tc;
	    if (ioctl(tty, TIOCGETD, (char *) &discipline) == -1)
		discipline = d_disipline;
d2777 4
a2780 4
	    if (ioctl(tty, TIOCKGET, (char *) &jmode) == -1)
		jmode = d_jmode;
	    if (ioctl(tty, TIOCKGETC, (char *) &jtc) == -1)
		jtc = d_jtc;
d2782 1
a2782 1
#endif /* USE_ANY_SYSV_TERMIO */
d2784 6
a2789 6
	    /*
	     * If ptyInitialErase is set, we want to get the pty's
	     * erase value.  Just in case that will fail, first get
	     * the value from /dev/tty, so we will have something
	     * at least.
	     */
d2791 1
a2791 1
	    if (resource.ptyInitialErase) {
d2793 1
a2793 1
		initial_erase = tio.c_cc[VERASE];
d2795 15
a2809 8
		initial_erase = tio.c_cc[VERASE];
#else /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
		initial_erase = sg.sg_erase;
#endif /* USE_ANY_SYSV_TERMIO */
		TRACE(("%s initial_erase:%d (from /dev/tty)\n",
		       rc == 0 ? "OK" : "FAIL",
		       initial_erase));
	    }
d2811 4
d2816 7
a2822 4
	    close(tty);
	    /* tty is no longer an open fd! */
	    tty = -1;
	}
a2823 3
	if (get_pty(&screen->respond, XDisplayString(screen->display))) {
	    SysError(ERROR_PTYS);
	}
d2825 1
a2825 1
	if (resource.ptyInitialErase) {
d2827 3
a2829 3
	    struct termio my_tio;
	    if ((rc = ioctl(screen->respond, TCGETA, &my_tio)) == 0)
		initial_erase = my_tio.c_cc[VERASE];
d2831 13
a2843 11
	    struct termios my_tio;
	    if ((rc = tcgetattr(screen->respond, &my_tio)) == 0)
		initial_erase = my_tio.c_cc[VERASE];
#else /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
	    struct sgttyb my_sg;
	    if ((rc = ioctl(screen->respond, TIOCGETP, (char *) &my_sg)) == 0)
		initial_erase = my_sg.sg_erase;
#endif /* USE_ANY_SYSV_TERMIO */
	    TRACE(("%s initial_erase:%d (from pty)\n",
		   (rc == 0) ? "OK" : "FAIL",
		   initial_erase));
a2844 2
#endif /* OPT_INITIAL_ERASE */
    }
d2846 2
a2847 2
    /* avoid double MapWindow requests */
    XtSetMappedWhenManaged(XtParent(CURRENT_EMU(screen)), False);
d2849 2
a2850 2
    wm_delete_window = XInternAtom(XtDisplay(toplevel), "WM_DELETE_WINDOW",
				   False);
d2852 2
a2853 2
    if (!TEK4014_ACTIVE(screen))
	VTInit();		/* realize now so know window size for tty driver */
d2855 12
a2866 12
    if (Console) {
	/*
	 * Inform any running xconsole program
	 * that we are going to steal the console.
	 */
	XmuGetHostname(mit_console_name + MIT_CONSOLE_LEN, 255);
	mit_console = XInternAtom(screen->display, mit_console_name, False);
	/* the user told us to be the console, so we can use CurrentTime */
	XtOwnSelection(XtParent(CURRENT_EMU(screen)),
		       mit_console, CurrentTime,
		       ConvertConsoleSelection, NULL, NULL);
    }
d2869 5
a2873 4
    if (screen->TekEmu) {
	envnew = tekterm;
	ptr = newtc;
    } else
d2875 4
a2878 4
    {
	envnew = vtterm;
	ptr = termcap;
    }
d2880 7
a2886 7
    /*
     * This used to exit if no termcap entry was found for the specified
     * terminal name.  That's a little unfriendly, so instead we'll allow
     * the program to proceed (but not to set $TERMCAP) if the termcap
     * entry is not found.
     */
    get_termcap(TermName = resource.term_name, ptr, newtc);
d2888 12
a2899 10
    /*
     * This block is invoked only if there was no terminal name specified
     * by the command-line option "-tn".
     */
    if (!TermName) {
	TermName = *envnew;
	while (*envnew != NULL) {
	    if (get_termcap(*envnew, ptr, newtc)) {
		TermName = *envnew;
		break;
a2900 1
	    envnew++;
a2901 1
    }
d2903 4
a2906 4
    /*
     * Check if ptyInitialErase is not set.  If so, we rely on the termcap
     * (or terminfo) to tell us what the erase mode should be set to.
     */
d2908 9
a2916 8
    TRACE(("resource ptyInitialErase is %sset\n",
	   resource.ptyInitialErase ? "" : "not "));
    if (!resource.ptyInitialErase) {
	char temp[1024], *p = temp;
	char *s = tgetstr(TERMCAP_ERASE, &p);
	TRACE(("...extracting initial_erase value from termcap\n"));
	if (s != 0) {
	    initial_erase = decode_keyvalue(&s, True);
d2918 1
a2918 2
    }
    TRACE(("...initial_erase:%d\n", initial_erase));
d2920 11
a2930 5
    TRACE(("resource backarrowKeyIsErase is %sset\n",
	   resource.backarrow_is_erase ? "" : "not "));
    if (resource.backarrow_is_erase) {	/* see input.c */
	if (initial_erase == 127) {
	    term->keyboard.flags &= ~MODE_DECBKM;
d2932 1
a2932 2
	    term->keyboard.flags |= MODE_DECBKM;
	    term->keyboard.reset_DECBKM = 1;
d2934 1
a2934 6
	TRACE(("...sets DECBKM %s\n",
	       (term->keyboard.flags & MODE_DECBKM) ? "on" : "off"));
    } else {
	term->keyboard.reset_DECBKM = 2;
    }
#endif /* OPT_INITIAL_ERASE */
d2937 10
a2946 10
    /* tell tty how big window is */
    if (TEK4014_ACTIVE(screen)) {
	ts.ts_lines = 38;
	ts.ts_cols = 81;
    } else {
	ts.ts_lines = screen->max_row + 1;
	ts.ts_cols = screen->max_col + 1;
    }
    i = ioctl(screen->respond, TIOCSSIZE, &ts);
    TRACE(("spawn TIOCSSIZE %dx%d return %d\n", ts.ts_lines, ts.ts_cols, i));
d2948 1
a2948 1
    /* tell tty how big window is */
d2950 16
a2965 16
    if (TEK4014_ACTIVE(screen)) {
	ws.ws_row = 38;
	ws.ws_col = 81;
	ws.ws_xpixel = TFullWidth(screen);
	ws.ws_ypixel = TFullHeight(screen);
    } else
#endif
    {
	ws.ws_row = screen->max_row + 1;
	ws.ws_col = screen->max_col + 1;
	ws.ws_xpixel = FullWidth(screen);
	ws.ws_ypixel = FullHeight(screen);
    }
    i = ioctl(screen->respond, TIOCSWINSZ, (char *) &ws);
    TRACE(("spawn TIOCSWINSZ %dx%d return %d\n", ws.ws_row, ws.ws_col, i));
#endif /* sun vs TIOCSWINSZ */
d2969 4
a2972 4
    if (!resource.utmpInhibit) {
	addToUtmp(ttydev, NULL, screen->respond);
	added_utmp_entry = True;
    }
d2975 1
a2975 1
    if (am_slave < 0) {
d2977 2
a2978 2
	if (pipe(pc_pipe) || pipe(cp_pipe))
	    SysError(ERROR_FORK);
d2980 3
a2982 3
	TRACE(("Forking...\n"));
	if ((screen->pid = fork()) == -1)
	    SysError(ERROR_FORK);
d2984 5
a2988 5
	if (screen->pid == 0) {
	    /*
	     * now in child process
	     */
	    TRACE_CHILD
d2997 1
a2997 1
	    if (IsPts) {	/* SYSV386 supports both, which did we open? */
d2999 1
a2999 2
		int ptyfd = 0;
		char *pty_name = 0;
d3002 4
a3005 7
		grantpt(screen->respond);
		unlockpt(screen->respond);
		if ((pty_name = ptsname(screen->respond)) == 0) {
		    SysError(ERROR_PTSNAME);
		}
		if ((ptyfd = open(pty_name, O_RDWR)) < 0) {
		    SysError(ERROR_OPPTSNAME);
d3008 2
a3009 2
		if (ioctl(ptyfd, I_PUSH, "ptem") < 0) {
		    SysError(ERROR_PTEM);
d3012 2
a3013 2
		if (!getenv("CONSEM") && ioctl(ptyfd, I_PUSH, "consem") < 0) {
		    SysError(ERROR_CONSEM);
d3016 2
a3017 2
		if (ioctl(ptyfd, I_PUSH, "ldterm") < 0) {
		    SysError(ERROR_LDTERM);
d3020 2
a3021 2
		if (ioctl(ptyfd, I_PUSH, "ttcompat") < 0) {
		    SysError(ERROR_TTCOMPAT);
d3026 1
a3026 1
		close(screen->respond);
d3030 5
a3034 5
		if (TEK4014_ACTIVE(screen)) {
		    ws.ws_row = 24;
		    ws.ws_col = 80;
		    ws.ws_xpixel = TFullWidth(screen);
		    ws.ws_ypixel = TFullHeight(screen);
d3038 4
a3041 4
		    ws.ws_row = screen->max_row + 1;
		    ws.ws_col = screen->max_col + 1;
		    ws.ws_xpixel = FullWidth(screen);
		    ws.ws_ypixel = FullHeight(screen);
d3045 1
a3045 1
	    } else {		/* else pty, not pts */
d3051 2
a3052 2
		close(cp_pipe[0]);
		close(pc_pipe[1]);
d3059 4
a3062 4
		    if ((i = fcntl(cp_pipe[1], F_DUPFD, 3)) >= 0) {
			(void) close(cp_pipe[1]);
			cp_pipe[1] = i;
		    }
d3065 4
a3068 4
		    if ((i = fcntl(pc_pipe[0], F_DUPFD, 3)) >= 0) {
			(void) close(pc_pipe[0]);
			pc_pipe[0] = i;
		    }
d3072 2
a3073 2
		close(ConnectionNumber(screen->display));
		close(screen->respond);
d3078 1
a3078 1
#ifdef USE_SYSV_PGRP
d3087 1
a3087 1
		qsetlogin(getlogin(), ttydev);
d3091 4
a3094 4
		    if (!no_dev_tty && (tty = open("/dev/tty", O_RDWR)) >= 0) {
			ioctl(tty, TIOCNOTTY, (char *) NULL);
			close(tty);
		    }
d3097 1
a3097 1
		    (void) revoke(ttydev);
d3099 1
a3099 1
		    if ((tty = open(ttydev, O_RDWR)) >= 0) {
d3101 2
a3102 2
			/* make /dev/tty work */
			ioctl(tty, TCSETCTTY, 0);
d3104 14
a3117 10
#ifdef USE_SYSV_PGRP
			/* We need to make sure that we are actually
			 * the process group leader for the pty.  If
			 * we are, then we should now be able to open
			 * /dev/tty.
			 */
			if ((i = open("/dev/tty", O_RDWR)) >= 0) {
			    /* success! */
			    close(i);
			    break;
d3119 1
a3119 5
#else /* USE_SYSV_PGRP */
			break;
#endif /* USE_SYSV_PGRP */
		    }
		    perror("open ttydev");
d3121 1
a3121 1
		    ioctl(tty, TIOCSCTTY, 0);
d3123 14
a3136 14
		    /* let our master know that the open failed */
		    handshake.status = PTY_BAD;
		    handshake.error = errno;
		    strcpy(handshake.buffer, ttydev);
		    write(cp_pipe[1], (char *) &handshake,
			  sizeof(handshake));

		    /* get reply from parent */
		    i = read(pc_pipe[0], (char *) &handshake,
			     sizeof(handshake));
		    if (i <= 0) {
			/* parent terminated */
			exit(1);
		    }
d3138 4
a3141 4
		    if (handshake.status == PTY_NOMORE) {
			/* No more ptys, let's shutdown. */
			exit(1);
		    }
d3143 8
a3150 8
		    /* We have a new pty to try */
		    free(ttydev);
		    ttydev = (char *) malloc((unsigned)
					     (strlen(handshake.buffer) + 1));
		    if (ttydev == NULL) {
			SysError(ERROR_SPREALLOC);
		    }
		    strcpy(ttydev, handshake.buffer);
d3156 9
a3164 8
		if ((ptr = ttyname(tty)) != 0) {
		    /* it may be bigger */
		    ttydev = (char *) realloc(ttydev,
					      (unsigned) (strlen(ptr) + 1));
		    if (ttydev == NULL) {
			SysError(ERROR_SPREALLOC);
		    }
		    (void) strcpy(ttydev, ptr);
d3167 1
a3167 1
	    }			/* end of IsPts else clause */
d3173 1
a3173 1
	    {
d3176 8
a3183 7
		    /* change ownership of tty to real uid, "tty" gid */
		    set_owner(ttydev, screen->uid, ttygrp->gr_gid,
			      (resource.messages ? 0620 : 0600));
		} else {
		    /* change ownership of tty to real group and user id */
		    set_owner(ttydev, screen->uid, screen->gid,
			      (resource.messages ? 0622 : 0600));
d3186 1
a3186 1
	    }
d3188 3
a3190 3
	    /* change ownership of tty to real group and user id */
	    set_owner(ttydev, screen->uid, screen->gid,
		      (resource.messages ? 0622 : 0600));
d3193 4
a3196 4
	    /*
	     * set up the tty modes
	     */
	    {
d3199 7
a3205 7
		/* If the control tty had its modes screwed around with,
		   eg. by lineedit in the shell, or emacs, etc. then tio
		   will have bad values.  Let's just get termio from the
		   new tty and tailor it.  */
		if (ioctl(tty, TCGETA, &tio) == -1)
		    SysError(ERROR_TIOCGETP);
		tio.c_lflag |= ECHOE;
d3207 7
a3213 7
		/* Now is also the time to change the modes of the
		 * child pty.
		 */
		/* input: nl->nl, don't ignore cr, cr->nl */
		tio.c_iflag &= ~(INLCR | IGNCR);
		tio.c_iflag |= ICRNL;
		/* ouput: cr->cr, nl is not return, no delays, ln->cr/nl */
d3215 2
a3216 9
		tio.c_oflag &=
		    ~(OCRNL
		      | ONLRET
		      | NLDLY
		      | CRDLY
		      | TABDLY
		      | BSDLY
		      | VTDLY
		      | FFDLY);
d3219 1
a3219 1
		tio.c_oflag |= ONLCR;
d3222 1
a3222 1
		tio.c_oflag |= OPOST;
d3224 4
d3232 1
a3232 1
		tio.c_cflag &= ~(CBAUD);
d3234 1
a3234 1
		/* baud rate is 0 (don't care) */
d3236 4
a3239 4
		tio.c_ispeed = tio.c_ospeed = VAL_LINE_SPEED;
#else /* !BAUD_0 */
		tio.c_cflag |= VAL_LINE_SPEED;
#endif /* !BAUD_0 */
d3241 2
a3242 2
		cfsetispeed(&tio, VAL_LINE_SPEED);
		cfsetospeed(&tio, VAL_LINE_SPEED);
d3244 2
a3245 2
		/* turn off bits that can't be set from the slave side */
		tio.c_cflag &= ~(PACKET | PKT3270 | PTU3270 | PKTXTND);
d3247 3
a3249 3
		/* Clear CLOCAL so that SIGHUP is sent to us
		   when the xterm ends */
		tio.c_cflag &= ~CLOCAL;
d3251 10
a3260 9
		tio.c_cflag &= ~CSIZE;
		if (screen->input_eight_bits)
		    tio.c_cflag |= CS8;
		else
		    tio.c_cflag |= CS7;
		/* enable signals, canonical processing (erase, kill, etc),
		 * echo
		 */
		tio.c_lflag |= ISIG | ICANON | ECHO | ECHOE | ECHOK;
d3262 1
a3262 1
		tio.c_lflag |= ECHOKE | IEXTEN;
d3265 1
a3265 1
		tio.c_lflag |= ECHOCTL | IEXTEN;
d3268 4
a3271 4
		/* reset EOL to default value */
		tio.c_cc[VEOL] = CEOL;	/* '^@@' */
		/* certain shells (ksh & csh) change EOF as well */
		tio.c_cc[VEOF] = CEOF;	/* '^D' */
d3273 2
a3274 4
		if (tio.c_cc[VEOL] == 0)
		    tio.c_cc[VEOL] = CEOL;	/* '^@@' */
		if (tio.c_cc[VEOF] == 0)
		    tio.c_cc[VEOF] = CEOF;	/* '^D' */
d3277 1
a3277 1
		tio.c_cc[VLNEXT] = CLNEXT;
d3280 1
a3280 1
		tio.c_cc[VWERASE] = CWERASE;
d3283 1
a3283 1
		tio.c_cc[VREPRINT] = CRPRNT;
d3286 1
a3286 1
		tio.c_cc[VRPRNT] = CRPRNT;
d3289 1
a3289 1
		tio.c_cc[VDISCARD] = CFLUSH;
d3292 1
a3292 1
		tio.c_cc[VFLUSHO] = CFLUSH;
d3295 1
a3295 1
		tio.c_cc[VSTOP] = CSTOP;
d3298 1
a3298 1
		tio.c_cc[VSTART] = CSTART;
d3301 1
a3301 1
		tio.c_cc[VSUSP] = CSUSP;
d3304 1
a3304 1
		tio.c_cc[VDSUSP] = CDSUSP;
d3306 8
a3313 8
		if (override_tty_modes) {
		    /* sysv-specific */
		    TMODE(XTTYMODE_intr, tio.c_cc[VINTR]);
		    TMODE(XTTYMODE_quit, tio.c_cc[VQUIT]);
		    TMODE(XTTYMODE_erase, tio.c_cc[VERASE]);
		    TMODE(XTTYMODE_kill, tio.c_cc[VKILL]);
		    TMODE(XTTYMODE_eof, tio.c_cc[VEOF]);
		    TMODE(XTTYMODE_eol, tio.c_cc[VEOL]);
d3315 1
a3315 1
		    TMODE(XTTYMODE_swtch, tio.c_cc[VSWTCH]);
d3318 1
a3318 1
		    TMODE(XTTYMODE_susp, tio.c_cc[VSUSP]);
d3321 1
a3321 1
		    TMODE(XTTYMODE_dsusp, tio.c_cc[VDSUSP]);
d3324 1
a3324 1
		    TMODE(XTTYMODE_rprnt, tio.c_cc[VREPRINT]);
d3327 1
a3327 1
		    TMODE(XTTYMODE_rprnt, tio.c_cc[VRPRNT]);
d3330 1
a3330 1
		    TMODE(XTTYMODE_flush, tio.c_cc[VDISCARD]);
d3333 1
a3333 1
		    TMODE(XTTYMODE_flush, tio.c_cc[VFLUSHO]);
d3336 1
a3336 1
		    TMODE(XTTYMODE_weras, tio.c_cc[VWERASE]);
d3339 1
a3339 1
		    TMODE(XTTYMODE_lnext, tio.c_cc[VLNEXT]);
d3342 1
a3342 1
		    TMODE(XTTYMODE_start, tio.c_cc[VSTART]);
d3345 1
a3345 1
		    TMODE(XTTYMODE_stop, tio.c_cc[VSTOP]);
d3348 1
a3348 1
		    TMODE(XTTYMODE_status, tio.c_cc[VSTATUS]);
d3351 7
a3357 7
		    /* both SYSV and BSD have ltchars */
		    TMODE(XTTYMODE_susp, ltc.t_suspc);
		    TMODE(XTTYMODE_dsusp, ltc.t_dsuspc);
		    TMODE(XTTYMODE_rprnt, ltc.t_rprntc);
		    TMODE(XTTYMODE_flush, ltc.t_flushc);
		    TMODE(XTTYMODE_weras, ltc.t_werasc);
		    TMODE(XTTYMODE_lnext, ltc.t_lnextc);
d3359 2
a3360 1
		}
d3363 3
a3365 3
		/* ioctl chokes when the "reserved" process group controls
		 * are not set to _POSIX_VDISABLE */
		ltc.t_rprntc = ltc.t_rprntc = ltc.t_flushc =
d3368 3
a3370 3
		if (ioctl(tty, TIOCSLTC, &ltc) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCSETC);
#endif /* HAS_LTCHARS */
d3372 3
a3374 3
		if (ioctl(tty, TIOCLSET, (char *) &lmode) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCLSET);
#endif /* TIOCLSET */
d3376 14
a3389 14
		if (ioctl(tty, TCSETA, &tio) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCSETP);
#else /* USE_POSIX_TERMIOS */
		if (tcsetattr(tty, TCSANOW, &tio) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCSETP);
#endif /* USE_POSIX_TERMIOS */
#else /* USE_ANY_SYSV_TERMIO or USE_POSIX_TERMIOS */
		sg.sg_flags &= ~(ALLDELAY | XTABS | CBREAK | RAW);
		sg.sg_flags |= ECHO | CRMOD;
		/* make sure speed is set on pty so that editors work right */
		sg.sg_ispeed = VAL_LINE_SPEED;
		sg.sg_ospeed = VAL_LINE_SPEED;
		/* reset t_brkc to default value */
		tc.t_brkc = -1;
d3391 4
a3394 4
		if (screen->input_eight_bits)
		    lmode |= LPASS8;
		else
		    lmode &= ~(LPASS8);
d3397 1
a3397 1
		jmode &= ~KM_KANJI;
d3400 19
a3418 1
		ltc = d_ltc;
d3420 10
a3429 28
		if (override_tty_modes) {
		    TMODE(XTTYMODE_intr, tc.t_intrc);
		    TMODE(XTTYMODE_quit, tc.t_quitc);
		    TMODE(XTTYMODE_erase, sg.sg_erase);
		    TMODE(XTTYMODE_kill, sg.sg_kill);
		    TMODE(XTTYMODE_eof, tc.t_eofc);
		    TMODE(XTTYMODE_start, tc.t_startc);
		    TMODE(XTTYMODE_stop, tc.t_stopc);
		    TMODE(XTTYMODE_brk, tc.t_brkc);
		    /* both SYSV and BSD have ltchars */
		    TMODE(XTTYMODE_susp, ltc.t_suspc);
		    TMODE(XTTYMODE_dsusp, ltc.t_dsuspc);
		    TMODE(XTTYMODE_rprnt, ltc.t_rprntc);
		    TMODE(XTTYMODE_flush, ltc.t_flushc);
		    TMODE(XTTYMODE_weras, ltc.t_werasc);
		    TMODE(XTTYMODE_lnext, ltc.t_lnextc);
		}

		if (ioctl(tty, TIOCSETP, (char *) &sg) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCSETP);
		if (ioctl(tty, TIOCSETC, (char *) &tc) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCSETC);
		if (ioctl(tty, TIOCSETD, (char *) &discipline) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCSETD);
		if (ioctl(tty, TIOCSLTC, (char *) &ltc) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCSLTC);
		if (ioctl(tty, TIOCLSET, (char *) &lmode) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCLSET);
d3431 4
a3434 4
		if (ioctl(tty, TIOCKSET, (char *) &jmode) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCKSET);
		if (ioctl(tty, TIOCKSETC, (char *) &jtc) == -1)
		    HsSysError(cp_pipe[1], ERROR_TIOCKSETC);
d3436 1
a3436 1
#endif /* !USE_ANY_SYSV_TERMIO */
d3438 1
a3438 1
		if (Console) {
d3440 4
a3443 4
		    int on = 1;
		    if (ioctl(tty, TIOCCONS, (char *) &on) == -1)
			fprintf(stderr, "%s: cannot open console: %s\n",
				xterm_name, strerror(errno));
d3446 5
a3450 5
		    int fd = open("/dev/console", O_RDWR);
		    if (fd == -1 || ioctl(fd, SRIOCSREDIR, tty) == -1)
			fprintf(stderr, "%s: cannot open console: %s\n",
				xterm_name, strerror(errno));
		    (void) close(fd);
d3452 2
d3455 1
a3455 4
#endif /* TIOCCONS */
	    }

	    signal(SIGCHLD, SIG_DFL);
d3457 2
a3458 2
	    /* watch out for extra shells (I don't understand either) */
	    signal(SIGHUP, SIG_DFL);
d3460 1
a3460 1
	    signal(SIGHUP, SIG_IGN);
d3462 4
a3465 4
	    /* restore various signals to their defaults */
	    signal(SIGINT, SIG_DFL);
	    signal(SIGQUIT, SIG_DFL);
	    signal(SIGTERM, SIG_DFL);
d3467 5
a3471 5
	    /*
	     * If we're not asked to make the parent process set the
	     * terminal's erase mode, and if we had no ttyModes resource,
	     * then set the terminal's erase mode from our best guess.
	     */
d3473 13
a3485 13
	    TRACE(("check if we should set erase to %d:%s\n\tptyInitialErase:%d,\n\toveride_tty_modes:%d,\n\tXTTYMODE_erase:%d\n",
		   initial_erase,
		   (!resource.ptyInitialErase
		    && !override_tty_modes
		    && !ttymodelist[XTTYMODE_erase].set)
		   ? "YES" : "NO",
		   resource.ptyInitialErase,
		   override_tty_modes,
		   ttymodelist[XTTYMODE_erase].set));
	    if (!resource.ptyInitialErase
		&& !override_tty_modes
		&& !ttymodelist[XTTYMODE_erase].set) {
		int old_erase;
d3487 5
a3491 5
		if (ioctl(tty, TCGETA, &tio) == -1)
		    tio = d_tio;
		old_erase = tio.c_cc[VERASE];
		tio.c_cc[VERASE] = initial_erase;
		rc = ioctl(tty, TCSETA, &tio);
d3493 15
a3507 15
		if (tcgetattr(tty, &tio) == -1)
		    tio = d_tio;
		old_erase = tio.c_cc[VERASE];
		tio.c_cc[VERASE] = initial_erase;
		rc = tcsetattr(tty, TCSANOW, &tio);
#else /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
		if (ioctl(tty, TIOCGETP, (char *) &sg) == -1)
		    sg = d_sg;
		old_erase = sg.sg_erase;
		sg.sg_erase = initial_erase;
		rc = ioctl(tty, TIOCSETP, (char *) &sg);
#endif /* USE_ANY_SYSV_TERMIO */
		TRACE(("%s setting erase to %d (was %d)\n",
		       rc ? "FAIL" : "OK", initial_erase, old_erase));
	    }
d3510 6
a3515 5
	    /* copy the environment before Setenving */
	    for (i = 0; environ[i] != NULL; i++) ;
	    /* compute number of xtermSetenv() calls below */
	    envsize = 1;	/* (NULL terminating entry) */
	    envsize += 3;	/* TERM, WINDOWID, DISPLAY */
d3517 1
a3517 1
	    envsize += 1;	/* LOGNAME */
d3520 1
a3520 1
	    envsize += 2;	/* COLUMNS, LINES */
d3522 1
a3522 1
	    envsize += 2;	/* HOME, SHELL */
d3525 1
a3525 1
	    envsize += 1;	/* TERMINFO */
d3528 1
a3528 1
	    envsize += 1;	/* TERMCAP */
d3530 10
a3539 10
	    envnew = (char **) calloc((unsigned) i + envsize, sizeof(char *));
	    memmove((char *) envnew, (char *) environ, i * sizeof(char *));
	    environ = envnew;
	    xtermSetenv("TERM=", TermName);
	    if (!TermName)
		*newtc = 0;

	    sprintf(buf, "%lu",
		    ((unsigned long) XtWindow(XtParent(CURRENT_EMU(screen)))));
	    xtermSetenv("WINDOWID=", buf);
d3541 2
a3542 2
	    /* put the display into the environment of the shell */
	    xtermSetenv("DISPLAY=", XDisplayString(screen->display));
d3544 1
a3544 1
	    signal(SIGTERM, SIG_DFL);
d3546 4
a3549 3
	    /* this is the time to go and set up stdin, out, and err
	     */
	    {
d3551 2
a3552 2
		(void) close(tty);
		(void) close(0);
d3554 8
a3561 7
		if (open("/dev/tty", O_RDWR)) {
		    SysError(ERROR_OPDEVTTY);
		}
		(void) close(1);
		(void) close(2);
		dup(0);
		dup(0);
d3563 7
a3569 6
		/* dup the tty */
		for (i = 0; i <= 2; i++)
		    if (i != tty) {
			(void) close(i);
			(void) dup(tty);
		    }
d3571 3
a3573 3
		/* and close the tty */
		if (tty > 2)
		    (void) close(tty);
d3576 1
a3576 1
	    }
d3580 2
a3581 2
	    setsid();
	    ioctl(0, TIOCSCTTY, 0);
d3583 4
a3586 4
	    ioctl(0, TIOCSPGRP, (char *) &pgrp);
	    setpgrp(0, 0);
	    close(open(ttydev, O_WRONLY));
	    setpgrp(0, pgrp);
d3588 1
a3588 1
	    tcsetpgrp(0, pgrp /*setsid() */ );
d3592 2
d3595 8
a3602 6
	    {
		struct termio t;
		if (ioctl(0, TCGETA, &t) >= 0) {
		    /* this gets lost somewhere on our way... */
		    t.c_oflag |= OPOST;
		    ioctl(0, TCSETA, &t);
a3603 1
	    }
d3607 3
a3609 3
	    pw = getpwuid(screen->uid);
	    login_name = NULL;
	    if (pw && pw->pw_name) {
d3611 20
a3630 19
		/*
		 * If the value from getlogin() differs from the value we
		 * get by looking in the password file, check if it does
		 * correspond to the same uid.  If so, allow that as an
		 * alias for the uid.
		 *
		 * Of course getlogin() will fail if we're started from
		 * a window-manager, since there's no controlling terminal
		 * to fuss with.  In that case, try to get something useful
		 * from the user's $LOGNAME or $USER environment variables.
		 */
		if (((login_name = getlogin()) != NULL
		     || (login_name = getenv("LOGNAME")) != NULL
		     || (login_name = getenv("USER")) != NULL)
		    && strcmp(login_name, pw->pw_name)) {
		    struct passwd *pw2 = getpwnam(login_name);
		    if (pw2 != 0
			&& pw->pw_uid != pw2->pw_uid) {
			login_name = NULL;
d3632 8
a3640 9
#endif
		if (login_name == NULL)
		    login_name = pw->pw_name;
		if (login_name != NULL)
		    login_name = x_strdup(login_name);
	    }
	    if (login_name != NULL) {
		xtermSetenv("LOGNAME=", login_name);	/* for POSIX */
	    }
d3642 19
a3660 22
	    /* Set up our utmp entry now.  We need to do it here
	     * for the following reasons:
	     *   - It needs to have our correct process id (for
	     *     login).
	     *   - If our parent was to set it after the fork(),
	     *     it might make it out before we need it.
	     *   - We need to do it before we go and change our
	     *     user and group id's.
	     */
	    (void) setutent();
	    /* set up entry to search for */
	    bzero((char *) &utmp, sizeof(utmp));
	    (void) strncpy(utmp.ut_id, my_utmp_id(ttydev), sizeof(utmp.ut_id));

	    utmp.ut_type = DEAD_PROCESS;

	    /* position to entry in utmp file */
	    /* Test return value: beware of entries left behind: PSz 9 Mar 00 */
	    if (!(utret = getutid(&utmp))) {
		(void) setutent();
		utmp.ut_type = USER_PROCESS;
		if (!(utret = getutid(&utmp))) {
d3662 4
a3666 1
	    }
d3668 6
a3673 6
	    if (!utret)
		TRACE(("getutid: NULL\n"));
	    else
		TRACE(("getutid: pid=%d type=%d user=%s line=%s id=%s\n",
		       utret->ut_pid, utret->ut_type, utret->ut_user,
		       utret->ut_line, utret->ut_id));
d3676 2
a3677 2
	    /* set up the new entry */
	    utmp.ut_type = USER_PROCESS;
d3679 1
a3679 1
	    utmp.ut_xstatus = 2;
d3681 8
a3688 7
	    (void) strncpy(utmp.ut_user,
			   (login_name != NULL) ? login_name : "????",
			   sizeof(utmp.ut_user));
	    /* why are we copying this string again?  (see above) */
	    (void) strncpy(utmp.ut_id, my_utmp_id(ttydev), sizeof(utmp.ut_id));
	    (void) strncpy(utmp.ut_line,
			   my_pty_name(ttydev), sizeof(utmp.ut_line));
d3691 2
a3692 1
	    (void) strncpy(buf, DisplayString(screen->display), sizeof(buf));
d3694 5
a3698 5
	    {
		char *disfin = strrchr(buf, ':');
		if (disfin)
		    *disfin = '\0';
	    }
d3700 1
a3700 1
	    (void) strncpy(utmp.ut_host, buf, sizeof(utmp.ut_host));
d3702 1
a3702 3
	    (void) strncpy(utmp.ut_name,
			   (login_name) ? login_name : "????",
			   sizeof(utmp.ut_name));
d3704 1
a3704 1
	    utmp.ut_pid = getpid();
d3707 1
a3707 1
	    utmp.ut_session = getsid(0);
d3709 2
a3710 2
	    utmp.ut_xtime = time((time_t *) 0);
	    utmp.ut_tv.tv_usec = 0;
d3712 1
a3712 1
	    utmp.ut_time = time((time_t *) 0);
d3715 8
a3722 8
	    /* write out the entry */
	    if (!resource.utmpInhibit) {
		errno = 0;
		pututline(&utmp);
		TRACE(("pututline: %d %d %s\n",
		       resource.utmpInhibit,
		       errno, strerror(errno)));
	    }
d3725 2
a3726 2
	    if (term->misc.login_shell)
		updwtmpx(WTMPX_FILE, &utmp);
d3728 2
a3729 2
	    if (term->misc.login_shell)
		updwtmp(etc_wtmp, &utmp);
d3731 5
a3735 5
	    if (term->misc.login_shell &&
		(i = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
		write(i, (char *) &utmp, sizeof(utmp));
		close(i);
	    }
d3738 2
a3739 2
	    /* close the file */
	    (void) endutent();
d3741 19
a3759 15
#else /* USE_SYSV_UTMP */
	    /* We can now get our ttyslot!  We can also set the initial
	     * utmp entry.
	     */
	    tslot = ttyslot();
	    added_utmp_entry = False;
	    {
		if (tslot > 0 && pw && !resource.utmpInhibit &&
		    (i = open(etc_utmp, O_WRONLY)) >= 0) {
		    bzero((char *) &utmp, sizeof(utmp));
		    (void) strncpy(utmp.ut_line,
				   my_pty_name(ttydev),
				   sizeof(utmp.ut_line));
		    (void) strncpy(utmp.ut_name, login_name,
				   sizeof(utmp.ut_name));
d3761 10
a3770 10
		    (void) strncpy(utmp.ut_host,
				   XDisplayString(screen->display),
				   sizeof(utmp.ut_host));
#endif
		    /* cast needed on Ultrix 4.4 */
		    time((time_t *) & utmp.ut_time);
		    lseek(i, (long) (tslot * sizeof(utmp)), 0);
		    write(i, (char *) &utmp, sizeof(utmp));
		    close(i);
		    added_utmp_entry = True;
d3772 7
a3778 6
		    if (term->misc.login_shell &&
			(i = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
			int status;
			status = write(i, (char *) &utmp, sizeof(utmp));
			status = close(i);
		    }
d3780 7
a3786 7
		    if (term->misc.login_shell &&
			(i = open(_U_LASTLOG, O_WRONLY)) >= 0) {
			lseek(i, (long) (screen->uid *
					 sizeof(utmp)), 0);
			write(i, (char *) &utmp, sizeof(utmp));
			close(i);
		    }
d3788 3
a3790 3
		} else
		    tslot = -tslot;
	    }
d3792 3
a3794 3
	    /* Let's pass our ttyslot to our parent so that it can
	     * clean up after us.
	     */
d3796 1
a3796 1
	    handshake.tty_slot = tslot;
d3801 1
a3801 1
	    if (term->misc.login_shell &&
d3803 14
a3816 12
		bzero((char *) &lastlog, sizeof(struct lastlog));
		(void) strncpy(lastlog.ll_line,
			       my_pty_name(ttydev),
			       sizeof(lastlog.ll_line));
		(void) strncpy(lastlog.ll_host,
			       XDisplayString(screen->display),
			       sizeof(lastlog.ll_host));
		time(&lastlog.ll_time);
		lseek(i, (long) (screen->uid * sizeof(struct lastlog)), 0);
		write(i, (char *) &lastlog, sizeof(struct lastlog));
		close(i);
	    }
d3820 1
a3820 3
	    /* Switch to real gid after writing utmp entry */
	    utmpGid = getegid();
	    if (getgid() != getegid()) {
d3822 4
a3825 2
		setegid(getgid());
	    }
d3827 1
d3830 7
a3836 7
	    /* Let our parent know that we set up our utmp entry
	     * so that it can clean up after us.
	     */
	    handshake.status = UTMP_ADDED;
	    handshake.error = 0;
	    strcpy(handshake.buffer, ttydev);
	    (void) write(cp_pipe[1], (char *) &handshake, sizeof(handshake));
d3838 1
a3838 1
#endif /* HAVE_UTMP */
d3840 1
a3840 1
	    (void) setgid(screen->gid);
d3842 5
a3846 4
	    if (geteuid() == 0 && pw) {
		if (initgroups(login_name, pw->pw_gid)) {
		    perror("initgroups failed");
		    SysError(ERROR_INIGROUPS);
a3847 1
	    }
d3849 5
a3853 3
	    if (setuid(screen->uid)) {
		SysError(ERROR_SETUID);
	    }
d3855 24
a3878 24
	    /* mark the pipes as close on exec */
	    fcntl(cp_pipe[1], F_SETFD, 1);
	    fcntl(pc_pipe[0], F_SETFD, 1);

	    /* We are at the point where we are going to
	     * exec our shell (or whatever).  Let our parent
	     * know we arrived safely.
	     */
	    handshake.status = PTY_GOOD;
	    handshake.error = 0;
	    (void) strcpy(handshake.buffer, ttydev);
	    (void) write(cp_pipe[1], (char *) &handshake, sizeof(handshake));

	    if (waiting_for_initial_map) {
		i = read(pc_pipe[0], (char *) &handshake,
			 sizeof(handshake));
		if (i != sizeof(handshake) ||
		    handshake.status != PTY_EXEC) {
		    /* some very bad problem occurred */
		    exit(ERROR_PTY_EXEC);
		}
		if (handshake.rows > 0 && handshake.cols > 0) {
		    screen->max_row = handshake.rows;
		    screen->max_col = handshake.cols;
d3880 2
a3881 2
		    ts.ts_lines = screen->max_row + 1;
		    ts.ts_cols = screen->max_col + 1;
d3883 4
a3886 4
		    ws.ws_row = screen->max_row + 1;
		    ws.ws_col = screen->max_col + 1;
		    ws.ws_xpixel = FullWidth(screen);
		    ws.ws_ypixel = FullHeight(screen);
d3888 1
a3889 1
	    }
d3893 1
a3893 1
	    {
d3895 1
a3895 1
		sprintf(numbuf, "%d", screen->max_col + 1);
d3897 1
a3897 1
		sprintf(numbuf, "%d", screen->max_row + 1);
d3899 1
a3899 1
	    }
d3901 6
a3906 6
	    if (pw) {		/* SVR4 doesn't provide these */
		if (!getenv("HOME"))
		    xtermSetenv("HOME=", pw->pw_dir);
		if (!getenv("SHELL"))
		    xtermSetenv("SHELL=", pw->pw_shell);
	    }
d3909 1
a3909 1
	    xtermSetenv("TERMINFO=", OWN_TERMINFO_DIR);
d3912 20
a3931 20
	    if (!TEK4014_ACTIVE(screen) && *newtc) {
		strcpy(termcap, newtc);
		resize(screen, termcap, newtc);
	    }
	    if (term->misc.titeInhibit && !term->misc.tiXtraScroll) {
		remove_termcap_entry(newtc, "ti=");
		remove_termcap_entry(newtc, "te=");
	    }
	    /*
	     * work around broken termcap entries */
	    if (resource.useInsertMode) {
		remove_termcap_entry(newtc, "ic=");
		/* don't get duplicates */
		remove_termcap_entry(newtc, "im=");
		remove_termcap_entry(newtc, "ei=");
		remove_termcap_entry(newtc, "mi");
		if (*newtc)
		    strcat(newtc, ":im=\\E[4h:ei=\\E[4l:mi:");
	    }
	    if (*newtc) {
d3933 6
a3938 8
		unsigned len;
		remove_termcap_entry(newtc, TERMCAP_ERASE "=");
		len = strlen(newtc);
		if (len != 0 && newtc[len - 1] == ':')
		    len--;
		sprintf(newtc + len, ":%s=\\%03o:",
			TERMCAP_ERASE,
			initial_erase & 0377);
d3940 2
a3941 2
		xtermSetenv("TERMCAP=", newtc);
	    }
d3944 2
a3945 1
	    /* need to reset after all the ioctl bashing we did above */
d3947 2
a3948 3
	    i = ioctl(0, TIOCSSIZE, &ts);
	    TRACE(("spawn TIOCSSIZE %dx%d return %d\n",
		   ts.ts_lines, ts.ts_cols, i));
d3950 2
a3951 3
	    i = ioctl(0, TIOCSWINSZ, (char *) &ws);
	    TRACE(("spawn TIOCSWINSZ %dx%d return %d\n",
		   ws.ws_row, ws.ws_col, i));
d3953 15
a3967 3
	    TRACE(("spawn cannot tell pty its size\n"));
#endif /* sun vs TIOCSWINSZ */
	    signal(SIGHUP, SIG_DFL);
d3970 2
a3971 2
	    if (((ptr = getenv("SHELL")) == NULL || *ptr == 0) &&
		((pw == NULL && (pw = getpwuid(screen->uid)) == NULL) ||
d3973 3
a3975 3
#else /* HAVE_UTMP */
	    if (((ptr = getenv("SHELL")) == NULL || *ptr == 0) &&
		((pw = getpwuid(screen->uid)) == NULL ||
d3977 11
a3987 3
#endif /* HAVE_UTMP */
		ptr = "/bin/sh";
	    shname = x_basename(ptr);
d3989 3
a3991 28
#if OPT_LUIT_PROG
	    /*
	     * Use two copies of command_to_exec, in case luit is not actually
	     * there, or refuses to run.  In that case we will fall-through to
	     * to command that the user gave anyway.
	     */
	    if (command_to_exec_with_luit) {
		TRACE(("spawning command \"%s\"\n", *command_to_exec_with_luit));
		execvp(*command_to_exec_with_luit, command_to_exec_with_luit);
		/* print error message on screen */
		fprintf(stderr, "%s: Can't execvp %s: %s\n",
			xterm_name, *command_to_exec_with_luit, strerror(errno));
		fprintf(stderr, "%s: cannot support your locale.\n",
			xterm_name);
	    }
#endif
	    if (command_to_exec) {
		TRACE(("spawning command \"%s\"\n", *command_to_exec));
		execvp(*command_to_exec, command_to_exec);
		if (command_to_exec[1] == 0)
		    execlp(ptr, shname, "-c", command_to_exec[0], (char *)0);
		/* print error message on screen */
		fprintf(stderr, "%s: Can't execvp %s: %s\n",
			xterm_name, *command_to_exec, strerror(errno));
	    }
#ifdef USE_SYSV_SIGHUP
	    /* fix pts sh hanging around */
	    signal(SIGHUP, SIG_DFL);
d3993 2
d3996 6
a4001 8
	    shname_minus = (char *) malloc(strlen(shname) + 2);
	    (void) strcpy(shname_minus, "-");
	    (void) strcat(shname_minus, shname);
#if !defined(USE_ANY_SYSV_TERMIO) && !defined(USE_POSIX_TERMIOS)
	    ldisc = XStrCmp("csh", shname + strlen(shname) - 3) == 0 ?
		NTTYDISC : 0;
	    ioctl(0, TIOCSETD, (char *) &ldisc);
#endif /* !USE_ANY_SYSV_TERMIO && !USE_POSIX_TERMIOS */
a4002 15
#ifdef USE_LOGIN_DASH_P
	    if (term->misc.login_shell && pw && added_utmp_entry)
		execl(bin_login, "login", "-p", "-f", login_name, (void *) 0);
#endif
	    execlp(ptr,
		   (term->misc.login_shell ? shname_minus : shname),
		   (void *) 0);

	    /* Exec failed. */
	    fprintf(stderr, "%s: Could not exec %s: %s\n", xterm_name,
		    ptr, strerror(errno));
	    (void) sleep(5);
	    exit(ERROR_EXEC);
	}
	/* end if in child after fork */
d4004 3
a4006 3
	/* Parent process.  Let's handle handshaked requests to our
	 * child process.
	 */
d4008 12
a4019 12
	/* close childs's sides of the pipes */
	close(cp_pipe[1]);
	close(pc_pipe[0]);

	for (done = 0; !done;) {
	    if (read(cp_pipe[0], (char *) &handshake, sizeof(handshake)) <= 0) {
		/* Our child is done talking to us.  If it terminated
		 * due to an error, we will catch the death of child
		 * and clean up.
		 */
		break;
	    }
d4021 7
a4027 7
	    switch (handshake.status) {
	    case PTY_GOOD:
		/* Success!  Let's free up resources and
		 * continue.
		 */
		done = 1;
		break;
d4029 18
a4046 18
	    case PTY_BAD:
		/* The open of the pty failed!  Let's get
		 * another one.
		 */
		(void) close(screen->respond);
		if (get_pty(&screen->respond, XDisplayString(screen->display))) {
		    /* no more ptys! */
		    fprintf(stderr,
			    "%s: child process can find no available ptys: %s\n",
			    xterm_name, strerror(errno));
		    handshake.status = PTY_NOMORE;
		    write(pc_pipe[1], (char *) &handshake, sizeof(handshake));
		    exit(ERROR_PTYS);
		}
		handshake.status = PTY_NEW;
		(void) strcpy(handshake.buffer, ttydev);
		write(pc_pipe[1], (char *) &handshake, sizeof(handshake));
		break;
d4048 11
a4058 12
	    case PTY_FATALERROR:
		errno = handshake.error;
		close(cp_pipe[0]);
		close(pc_pipe[1]);
		SysError(handshake.fatal_error);
		/*NOTREACHED */

	    case UTMP_ADDED:
		/* The utmp entry was set by our slave.  Remember
		 * this so that we can reset it later.
		 */
		added_utmp_entry = True;
d4060 14
a4073 8
		tslot = handshake.tty_slot;
#endif /* USE_SYSV_UTMP */
		free(ttydev);
		ttydev = x_strdup(handshake.buffer);
		break;
	    default:
		fprintf(stderr, "%s: unexpected handshake status %d\n",
			xterm_name, handshake.status);
a4074 6
	}
	/* close our sides of the pipes */
	if (!waiting_for_initial_map) {
	    close(cp_pipe[0]);
	    close(pc_pipe[1]);
	}
d4076 5
a4080 1
    }
a4081 4
    /* end if no slave */
    /*
     * still in parent (xterm process)
     */
d4083 2
a4084 2
    /* hung sh problem? */
    signal(SIGHUP, SIG_DFL);
d4086 1
a4086 1
    signal(SIGHUP, SIG_IGN);
d4097 1
a4097 1
    signal(SIGINT, SIG_IGN);
d4100 2
a4101 2
    /* hung shell problem */
    signal(SIGQUIT, SIG_IGN);
d4103 1
a4103 1
    signal(SIGTERM, SIG_IGN);
d4105 187
a4291 5
    /* if we were spawned by a jobcontrol smart shell (like ksh or csh),
     * then our pgrp and pid will be the same.  If we were spawned by
     * a jobcontrol dumb shell (like /bin/sh), then we will be in our
     * parent's pgrp, and we must ignore keyboard signals, or we will
     * tank on everything.
d4293 99
a4391 4
    if (getpid() == getpgrp()) {
	(void) signal(SIGINT, Exit);
	(void) signal(SIGQUIT, Exit);
	(void) signal(SIGTERM, Exit);
d4393 27
a4419 3
	(void) signal(SIGINT, SIG_IGN);
	(void) signal(SIGQUIT, SIG_IGN);
	(void) signal(SIGTERM, SIG_IGN);
d4421 5
a4425 5
    (void) signal(SIGPIPE, Exit);
#else /* SYSV */
    signal(SIGINT, Exit);
    signal(SIGQUIT, Exit);
    signal(SIGTERM, Exit);
d4427 30
a4456 1
#endif /* USE_SYSV_SIGNALS and not SIGTSTP */
d4458 8
a4465 2
    return 0;
}				/* end spawn */
d4470 1
a4470 1
    register TScreen *screen = &term->screen;
d4473 2
a4474 2
    if (!resource.utmpInhibit && added_utmp_entry)
	removeFromUtmp();
d4477 7
a4483 2
    struct UTMP_STR utmp;
    struct UTMP_STR *utptr;
d4485 1
a4485 1
    int fd;			/* for /etc/wtmp */
d4488 4
a4491 4
    /* don't do this more than once */
    if (xterm_exiting)
	SIGNAL_RETURN;
    xterm_exiting = True;
d4494 1
a4494 1
    closepty(ttydev, ptydev, (resource.utmpInhibit ? OPTY_NOP : OPTY_LOGIN), screen->respond);
d4497 2
a4498 2
    /* cleanup the utmp entry we forged earlier */
    if (!resource.utmpInhibit
d4500 1
a4500 1
	&& added_utmp_entry
d4502 1
a4502 1
	) {
d4504 4
a4507 4
	if (utmpGid != -1) {
	    /* Switch back to group utmp */
	    setegid(utmpGid);
	}
d4509 7
a4515 7
	utmp.ut_type = USER_PROCESS;
	(void) strncpy(utmp.ut_id, my_utmp_id(ttydev), sizeof(utmp.ut_id));
	(void) setutent();
	utptr = getutid(&utmp);
	/* write it out only if it exists, and the pid's match */
	if (utptr && (utptr->ut_pid == screen->pid)) {
	    utptr->ut_type = DEAD_PROCESS;
d4518 1
a4518 1
	    utptr->ut_session = getsid(0);
d4520 2
a4521 2
	    utptr->ut_xtime = time((time_t *) 0);
	    utptr->ut_tv.tv_usec = 0;
d4523 2
a4524 2
	    *utptr->ut_user = 0;
	    utptr->ut_time = time((time_t *) 0);
d4526 1
a4526 1
	    (void) pututline(utptr);
d4529 2
a4530 2
	    if (term->misc.login_shell)
		updwtmpx(WTMPX_FILE, utptr);
d4532 3
a4534 3
	    strncpy(utmp.ut_line, utptr->ut_line, sizeof(utmp.ut_line));
	    if (term->misc.login_shell)
		updwtmp(etc_wtmp, utptr);
d4536 6
a4541 6
	    /* set wtmp entry if wtmp file exists */
	    if (term->misc.login_shell &&
		(fd = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
		write(fd, utptr, sizeof(*utptr));
		close(fd);
	    }
d4545 2
d4548 10
a4557 12
	(void) endutent();
    }
#else /* not USE_SYSV_UTMP */
    register int wfd;
    struct utmp utmp;

    if (!resource.utmpInhibit && added_utmp_entry &&
	(am_slave < 0 && tslot > 0 && (wfd = open(etc_utmp, O_WRONLY)) >= 0)) {
	bzero((char *) &utmp, sizeof(utmp));
	lseek(wfd, (long) (tslot * sizeof(utmp)), 0);
	write(wfd, (char *) &utmp, sizeof(utmp));
	close(wfd);
d4559 10
a4568 8
	if (term->misc.login_shell &&
	    (wfd = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
	    (void) strncpy(utmp.ut_line,
			   my_pty_name(ttydev),
			   sizeof(utmp.ut_line));
	    time(&utmp.ut_time);
	    write(wfd, (char *) &utmp, sizeof(utmp));
	    close(wfd);
d4570 5
a4574 5
#endif /* WTMP */
    }
#endif /* USE_SYSV_UTMP */
#endif /* HAVE_UTMP */
    close(screen->respond);	/* close explicitly to avoid race with slave side */
d4576 2
a4577 2
    if (screen->logging)
	CloseLog(screen);
d4580 4
a4583 3
    if (am_slave < 0) {
	/* restore ownership of tty and pty */
	set_owner(ttydev, 0, 0, 0666);
d4585 1
a4585 1
	set_owner(ptydev, 0, 0, 0666);
d4587 4
a4590 3
    }
    exit(n);
    SIGNAL_RETURN;
d4595 1
a4595 1
resize(TScreen * screen, register char *oldtc, char *newtc)
d4598 37
a4634 37
    register char *ptr1, *ptr2;
    register size_t i;
    register int li_first = 0;
    register char *temp;

    TRACE(("resize %s\n", oldtc));
    if ((ptr1 = x_strindex(oldtc, "co#")) == NULL) {
	strcat(oldtc, "co#80:");
	ptr1 = x_strindex(oldtc, "co#");
    }
    if ((ptr2 = x_strindex(oldtc, "li#")) == NULL) {
	strcat(oldtc, "li#24:");
	ptr2 = x_strindex(oldtc, "li#");
    }
    if (ptr1 > ptr2) {
	li_first++;
	temp = ptr1;
	ptr1 = ptr2;
	ptr2 = temp;
    }
    ptr1 += 3;
    ptr2 += 3;
    strncpy(newtc, oldtc, i = ptr1 - oldtc);
    temp = newtc + i;
    sprintf(temp, "%d", (li_first
			 ? screen->max_row + 1
			 : screen->max_col + 1));
    temp += strlen(temp);
    ptr1 = strchr(ptr1, ':');
    strncpy(temp, ptr1, i = ptr2 - ptr1);
    temp += i;
    sprintf(temp, "%d", (li_first
			 ? screen->max_col + 1
			 : screen->max_row + 1));
    ptr2 = strchr(ptr2, ':');
    strcat(temp, ptr2);
    TRACE(("   ==> %s\n", newtc));
d4649 1
a4649 1
    pid_t pid;
d4651 1
a4651 1
    pid = waitpid(-1, NULL, WNOHANG);
d4653 3
a4655 3
    /* cannot do non-blocking wait */
    int pid = 0;
#else /* defined(USE_SYSV_SIGNALS) && (defined(CRAY) || !defined(SIGTSTP)) */
d4657 1
a4657 1
    int status;
d4659 1
a4659 1
    union wait status;
d4661 1
a4661 1
    register int pid;
d4663 1
a4663 1
    pid = wait3(&status, WNOHANG, (struct rusage *) NULL);
d4665 1
a4665 1
    return pid;
d4671 1
a4671 2
static SIGNAL_T
reapchild(int n GCC_UNUSED)
d4688 1
a4688 2
	    if (debug)
		fputs("Exiting\n", stderr);
d4691 1
a4691 1
		Cleanup(0);
d4693 1
a4693 1
    } while ((pid = nonblocking_wait()) > 0);
d4701 1
a4701 1
remove_termcap_entry(char *buf, char *str)
d4720 2
a4721 1
	    while ((*first++ = *buf++) != 0) ;
d4746 1
a4746 2
static int
parse_tty_modes(char *s, struct _xttymodes *modelist)
d4754 2
a4755 4
	while (*s && isascii(CharOf(*s)) && isspace(CharOf(*s)))
	    s++;
	if (!*s)
	    return count;
d4758 1
a4758 2
	    if (strncmp(s, mp->name, mp->len) == 0)
		break;
d4760 1
a4760 2
	if (!mp->name)
	    return -1;
d4763 2
a4764 4
	while (*s && isascii(CharOf(*s)) && isspace(CharOf(*s)))
	    s++;
	if (!*s)
	    return -1;
d4766 1
a4766 1
	if ((c = decode_keyvalue(&s, False)) != -1) {
d4772 1
d4776 2
a4777 3
#ifndef VMS			/* don't use pipes on OpenVMS */
int
GetBytesAvailable(int fd)
d4779 14
a4792 1
#if defined(FIONREAD)
d4794 1
a4794 1
    ioctl(fd, FIONREAD, (char *) &arg);
d4798 1
a4798 2
    struct timeval timeout =
    {0, 0};
d4800 4
a4803 4
    FD_ZERO(&set);
    FD_SET(fd, &set);
    if (select(fd + 1, &set, NULL, NULL, &timeout) > 0)
	return 1;
d4805 6
d4812 2
d4815 1
a4815 1
    return (ioctl(fd, FIORDCHK, NULL));
d4821 1
a4821 1
    return poll(pollfds, 1, 0);
d4833 8
a4840 2
#if defined(SVR4) || defined(SYSV) || !defined(X_NOT_POSIX)
    return kill(-pid, sig);
d4842 2
a4843 2
    return killpg(pid, sig);
#endif
d4847 1
a4847 2
int
A2E(int x)
d4851 1
a4851 1
    __atoe_l(&c, 1);
d4855 1
a4855 2
int
E2A(int x)
d4859 1
a4859 1
    __etoa_l(&c, 1);
d4874 1
a4874 2
int
qsetlogin(char *login, char *ttyname)
d4876 1
a4876 1
    int v = getsid(getpid());
d4878 2
a4879 2
    memset(&ps, 0, sizeof(ps));
    memset(&rps, 0, sizeof(rps));
d4881 4
a4884 4
    ps.type = _PROC_SESSION;
    ps.subtype = _PROC_SUB_ACTION1;
    ps.sid = v;
    strcpy(ps.name, login);
d4886 1
a4886 1
    Send(1, &ps, &rps, sizeof(ps), sizeof(rps));
d4888 2
a4889 2
    if (rps.status < 0)
	return (rps.status);
d4891 5
a4895 5
    ps.type = _PROC_SESSION;
    ps.subtype = _PROC_SUB_ACTION2;
    ps.sid = v;
    sprintf(ps.name, "//%d%s", getnid(), ttyname);
    Send(1, &ps, &rps, sizeof(ps), sizeof(rps));
d4897 1
a4897 1
    return (rps.status);
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d20 1
a20 1
Copyright 2002,2003 by Thomas E. Dickey
d92 1
a92 1
/* $XFree86: xc/programs/xterm/main.c,v 3.174 2003/12/25 22:04:04 dickey Exp $ */
a95 2
#define RES_OFFSET(field)	XtOffsetOf(XTERM_RESOURCE, field)

a109 2
#elif defined(HAVE_LIB_XAWPLUS)
#include <X11/XawPlus/Form.h>
a131 5
#include <pty.h>		/* openpty() */
#endif

#ifdef __sgi
#include <grp.h>		/* initgroups() */
a173 1
#ifndef _SVID3
a175 1
#endif
d177 1
a177 1
#if defined(__GLIBC__) && !defined(linux)
d675 2
d679 20
a698 10
    Sres("name", "Name", xterm_name, DFT_TERMTYPE),
    Sres("iconGeometry", "IconGeometry", icon_geometry, NULL),
    Sres(XtNtitle, XtCTitle, title, NULL),
    Sres(XtNiconName, XtCIconName, icon_name, NULL),
    Sres("termName", "TermName", term_name, NULL),
    Sres("ttyModes", "TtyModes", tty_modes, NULL),
    Bres("hold", "Hold", hold_screen, FALSE),
    Bres("utmpInhibit", "UtmpInhibit", utmpInhibit, FALSE),
    Bres("messages", "Messages", messages, TRUE),
    Bres("sunFunctionKeys", "SunFunctionKeys", sunFunctionKeys, FALSE),
d700 2
a701 1
    Bres("sunKeyboard", "SunKeyboard", sunKeyboard, FALSE),
d704 2
a705 1
    Bres("hpFunctionKeys", "HpFunctionKeys", hpFunctionKeys, FALSE),
d708 9
a716 5
    Bres("ptyInitialErase", "PtyInitialErase", ptyInitialErase, FALSE),
    Bres("backarrowKeyIsErase", "BackarrowKeyIsErase", backarrow_is_erase, FALSE),
#endif
    Bres("waitForMap", "WaitForMap", wait_for_map, FALSE),
    Bres("useInsertMode", "UseInsertMode", useInsertMode, FALSE),
d718 2
a719 4
    Ires("zIconBeep", "ZIconBeep", zIconBeep, 0),
#endif
#if OPT_PTY_HANDSHAKE
    Bres("ptyHandshake", "PtyHandshake", ptyHandshake, TRUE),
d722 2
a723 1
    Bres("sameName", "SameName", sameName, TRUE),
d726 2
a727 1
    Bres("sessionMgt", "SessionMgt", sessionMgt, TRUE),
d730 1
a814 4
#if OPT_C1_PRINT
{"-k8",		"*allowC1Printable", XrmoptionNoArg,	(caddr_t) "on"},
{"+k8",		"*allowC1Printable", XrmoptionNoArg,	(caddr_t) "off"},
#endif
d889 1
a889 1
{"-ziconbeep", "*zIconBeep", XrmoptionSepArg, (caddr_t) NULL},
d955 1
a955 1
{ "-/+bc",                 "turn on/off text cursor blinking" },
d965 1
a965 1
{ "-/+dc",                 "turn off/on dynamic color selection" },
d972 1
a972 1
{ "-/+hold",               "turn on/off logic that retains window after exit" },
d974 1
a974 1
{ "-/+ie",                 "turn on/off initialization of 'erase' from pty" },
d976 1
a976 1
{ "-/+im",                 "use insert mode for TERMCAP" },
a977 3
#if OPT_C1_PRINT
{ "-/+k8",                 "turn on/off C1-printable classification"},
#endif
d988 1
a988 1
{ "-/+mesg",               "forbid/allow messages" },
d1001 1
a1001 1
{ "-/+rvc",                "turn off/on display of reverse as color" },
d1440 1
a1440 1
    TRACE(("my_utmp_id (%s) -> '%s'\n", device, result));
a2301 2
    if (!result)
	IsPts = 0;
d2305 1
d2319 1
a2319 4
#if defined(USE_ISPTS_FLAG)
    if (result) {
#endif
	result = ((*pty = open("/dev/ptmx", O_RDWR)) < 0);
d2322 2
a2323 2
	if (!result)
	    strcpy(ttydev, ptsname(*pty));
d2325 1
a2325 2
	IsPts = !result;	/* true if we're successful */
    }
d2378 2
a2379 9
	char *name = ptsname(*pty);
	if (name != 0) {
	    strcpy(ttydev, name);
	    result = 0;
	} else {		/* permissions, or other unexpected problem */
	    close(*pty);
	    *pty = -1;
	    result = pty_search(pty);
	}
d2529 1
a2529 1
 * declared outside OPT_PTY_HANDSHAKE so HsSysError() callers can use
d2531 1
d2534 1
a2534 2
#if OPT_PTY_HANDSHAKE
static int pc_pipe[2];		/* this pipe is used for parent to child transfer */
d2608 1
a2608 1
#endif /* OPT_PTY_HANDSHAKE else !OPT_PTY_HANDSHAKE */
d2635 1
a2635 1
#if OPT_PTY_HANDSHAKE
d2642 1
a2642 1
    int rc = 0;
d2675 5
a2679 3
#ifdef TTYSIZE_STRUCT
    TTYSIZE_STRUCT ts;
#endif
d2685 1
a2685 1
    struct UTMP_STR *utret = NULL;
a2691 6
    /* Noisy compilers */
    (void) rc;
#if defined(HAVE_UTMP) && defined(USE_SYSV_UTMP)
    (void) utret;
#endif

d2901 7
a2907 2
    if (!get_termcap(TermName = resource.term_name, ptr, newtc)) {
	char *last = NULL;
d2910 1
a2910 2
	    if ((last == NULL || strcmp(last, *envnew))
		&& get_termcap(*envnew, ptr, newtc)) {
a2913 1
	    last = *envnew;
d2951 12
a2962 1
#ifdef TTYSIZE_STRUCT
d2966 4
a2969 6
	TTYSIZE_ROWS(ts) = 38;
	TTYSIZE_COLS(ts) = 81;
#if defined(USE_STRUCT_WINSIZE)
	ts.ws_xpixel = TFullWidth(screen);
	ts.ws_ypixel = TFullHeight(screen);
#endif
d2973 8
a2980 12
	TTYSIZE_ROWS(ts) = screen->max_row + 1;
	TTYSIZE_COLS(ts) = screen->max_col + 1;
#if defined(USE_STRUCT_WINSIZE)
	ts.ws_xpixel = FullWidth(screen);
	ts.ws_ypixel = FullHeight(screen);
#endif
    }
    i = SET_TTYSIZE(screen->respond, ts);
    TRACE(("spawn SET_TTYSIZE %dx%d return %d\n",
	   TTYSIZE_ROWS(ts),
	   TTYSIZE_COLS(ts), i));
#endif /* TTYSIZE_STRUCT */
a2981 1
    added_utmp_entry = False;
d2991 2
a2992 2
#if OPT_PTY_HANDSHAKE
	if (resource.ptyHandshake && (pipe(pc_pipe) || pipe(cp_pipe)))
d3046 1
a3046 2

#ifdef TTYSIZE_STRUCT
d3050 5
a3054 5
		    TTYSIZE_ROWS(ts) = 24;
		    TTYSIZE_COLS(ts) = 80;
#ifdef USE_STRUCT_WINSIZE
		    ts.ws_xpixel = TFullWidth(screen);
		    ts.ws_ypixel = TFullHeight(screen);
a3055 2
		} else
#endif /* OPT_TEK4014 */
d3057 5
a3061 5
		    TTYSIZE_ROWS(ts) = screen->max_row + 1;
		    TTYSIZE_COLS(ts) = screen->max_col + 1;
#ifdef USE_STRUCT_WINSIZE
		    ts.ws_xpixel = FullWidth(screen);
		    ts.ws_ypixel = FullHeight(screen);
a3062 3
		}
#endif /* TTYSIZE_STRUCT */

d3068 4
a3071 1
		(void) pgrp;	/* not all branches use this variable */
d3073 8
a3080 15
#if OPT_PTY_HANDSHAKE		/* warning, goes for a long ways */
		if (resource.ptyHandshake) {
		    /* close parent's sides of the pipes */
		    close(cp_pipe[0]);
		    close(pc_pipe[1]);

		    /* Make sure that our sides of the pipes are not in the
		     * 0, 1, 2 range so that we don't fight with stdin, out
		     * or err.
		     */
		    if (cp_pipe[1] <= 2) {
			if ((i = fcntl(cp_pipe[1], F_DUPFD, 3)) >= 0) {
			    (void) close(cp_pipe[1]);
			    cp_pipe[1] = i;
			}
d3082 5
a3086 5
		    if (pc_pipe[0] <= 2) {
			if ((i = fcntl(pc_pipe[0], F_DUPFD, 3)) >= 0) {
			    (void) close(pc_pipe[0]);
			    pc_pipe[0] = i;
			}
d3088 5
d3094 3
a3096 7
		    /* we don't need the socket, or the pty master anymore */
		    close(ConnectionNumber(screen->display));
		    close(screen->respond);

		    /* Now is the time to set up our process group and
		     * open up the pty slave.
		     */
d3099 1
a3099 1
		    (void) setsid();
d3101 1
a3101 1
		    (void) setpgrp();
d3106 1
a3106 1
		    qsetlogin(getlogin(), ttydev);
d3108 1
a3108 1
		    while (1) {
d3110 4
a3113 5
			if (!no_dev_tty
			    && (tty = open("/dev/tty", O_RDWR)) >= 0) {
			    ioctl(tty, TIOCNOTTY, (char *) NULL);
			    close(tty);
			}
d3116 1
a3116 1
			(void) revoke(ttydev);
d3118 1
a3118 1
			if ((tty = open(ttydev, O_RDWR)) >= 0) {
d3120 2
a3121 2
			    /* make /dev/tty work */
			    ioctl(tty, TCSETCTTY, 0);
d3124 10
a3133 10
			    /* We need to make sure that we are actually
			     * the process group leader for the pty.  If
			     * we are, then we should now be able to open
			     * /dev/tty.
			     */
			    if ((i = open("/dev/tty", O_RDWR)) >= 0) {
				/* success! */
				close(i);
				break;
			    }
d3135 1
a3135 1
			    break;
d3137 2
a3138 2
			}
			perror("open ttydev");
d3140 1
a3140 1
			ioctl(tty, TIOCSCTTY, 0);
d3142 6
a3147 14
			/* let our master know that the open failed */
			handshake.status = PTY_BAD;
			handshake.error = errno;
			strcpy(handshake.buffer, ttydev);
			write(cp_pipe[1], (char *) &handshake,
			      sizeof(handshake));

			/* get reply from parent */
			i = read(pc_pipe[0], (char *) &handshake,
				 sizeof(handshake));
			if (i <= 0) {
			    /* parent terminated */
			    exit(1);
			}
d3149 7
a3155 4
			if (handshake.status == PTY_NOMORE) {
			    /* No more ptys, let's shutdown. */
			    exit(1);
			}
d3157 3
a3159 8
			/* We have a new pty to try */
			free(ttydev);
			ttydev = (char *) malloc((unsigned)
						 (strlen(handshake.buffer) + 1));
			if (ttydev == NULL) {
			    SysError(ERROR_SPREALLOC);
			}
			strcpy(ttydev, handshake.buffer);
d3162 6
a3167 11
		    /* use the same tty name that everyone else will use
		     * (from ttyname)
		     */
		    if ((ptr = ttyname(tty)) != 0) {
			/* it may be bigger */
			ttydev = (char *) realloc(ttydev,
						  (unsigned) (strlen(ptr) + 1));
			if (ttydev == NULL) {
			    SysError(ERROR_SPREALLOC);
			}
			(void) strcpy(ttydev, ptr);
d3169 1
a3170 1
#endif /* OPT_PTY_HANDSHAKE -- from near fork */
d3172 12
d3188 2
a3505 1
#if OPT_TRACE
a3506 1
#endif
a3509 1
#if OPT_TRACE
a3510 1
#endif
a3515 1
#if OPT_TRACE
a3516 1
#endif
a3521 1
#if OPT_TRACE
a3522 1
#endif
d3735 1
a3735 1
		       errno, (errno != 0) ? strerror(errno) : ""));
d3738 1
a3738 1
#if defined(WTMPX_FILE) && (defined(SVR4) || defined(SCO325))
d3804 3
a3806 5
#if OPT_PTY_HANDSHAKE
	    if (resource.ptyHandshake) {
		handshake.tty_slot = tslot;
	    }
#endif /* OPT_PTY_HANDSHAKE */
d3835 1
a3835 1
#if OPT_PTY_HANDSHAKE
d3839 5
a3843 7
	    if (resource.ptyHandshake) {
		handshake.status = UTMP_ADDED;
		handshake.error = 0;
		strcpy(handshake.buffer, ttydev);
		(void) write(cp_pipe[1], (char *) &handshake, sizeof(handshake));
	    }
#endif /* OPT_PTY_HANDSHAKE */
d3858 34
a3891 35
#if OPT_PTY_HANDSHAKE
	    if (resource.ptyHandshake) {
		/* mark the pipes as close on exec */
		fcntl(cp_pipe[1], F_SETFD, 1);
		fcntl(pc_pipe[0], F_SETFD, 1);

		/* We are at the point where we are going to
		 * exec our shell (or whatever).  Let our parent
		 * know we arrived safely.
		 */
		handshake.status = PTY_GOOD;
		handshake.error = 0;
		(void) strcpy(handshake.buffer, ttydev);
		(void) write(cp_pipe[1], (char *) &handshake, sizeof(handshake));

		if (waiting_for_initial_map) {
		    i = read(pc_pipe[0], (char *) &handshake,
			     sizeof(handshake));
		    if (i != sizeof(handshake) ||
			handshake.status != PTY_EXEC) {
			/* some very bad problem occurred */
			exit(ERROR_PTY_EXEC);
		    }
		    if (handshake.rows > 0 && handshake.cols > 0) {
			screen->max_row = handshake.rows;
			screen->max_col = handshake.cols;
#ifdef TTYSIZE_STRUCT
			TTYSIZE_ROWS(ts) = screen->max_row + 1;
			TTYSIZE_COLS(ts) = screen->max_col + 1;
#if defined(USE_STRUCT_WINSIZE)
			ts.ws_xpixel = FullWidth(screen);
			ts.ws_ypixel = FullHeight(screen);
#endif
#endif /* TTYSIZE_STRUCT */
		    }
d3894 1
a3894 1
#endif /* OPT_PTY_HANDSHAKE */
d3951 11
a3961 10
#if OPT_PTY_HANDSHAKE
	    if (resource.ptyHandshake) {
#ifdef TTYSIZE_STRUCT
		i = SET_TTYSIZE(0, ts);
		TRACE(("spawn SET_TTYSIZE %dx%d return %d\n",
		       TTYSIZE_ROWS(ts),
		       TTYSIZE_COLS(ts), i));
#endif /* TTYSIZE_STRUCT */
	    }
#endif /* OPT_PTY_HANDSHAKE */
d3996 1
a3996 1
		    execlp(ptr, shname, "-c", command_to_exec[0], (void *) 0);
d4030 25
a4054 5
#if OPT_PTY_HANDSHAKE
	if (resource.ptyHandshake) {
	    /* Parent process.  Let's handle handshaked requests to our
	     * child process.
	     */
d4056 13
a4068 13
	    /* close childs's sides of the pipes */
	    close(cp_pipe[1]);
	    close(pc_pipe[0]);

	    for (done = 0; !done;) {
		if (read(cp_pipe[0],
			 (char *) &handshake,
			 sizeof(handshake)) <= 0) {
		    /* Our child is done talking to us.  If it terminated
		     * due to an error, we will catch the death of child
		     * and clean up.
		     */
		    break;
d4070 4
d4075 6
a4080 26
		switch (handshake.status) {
		case PTY_GOOD:
		    /* Success!  Let's free up resources and
		     * continue.
		     */
		    done = 1;
		    break;

		case PTY_BAD:
		    /* The open of the pty failed!  Let's get
		     * another one.
		     */
		    (void) close(screen->respond);
		    if (get_pty(&screen->respond, XDisplayString(screen->display))) {
			/* no more ptys! */
			fprintf(stderr,
				"%s: child process can find no available ptys: %s\n",
				xterm_name, strerror(errno));
			handshake.status = PTY_NOMORE;
			write(pc_pipe[1], (char *) &handshake, sizeof(handshake));
			exit(ERROR_PTYS);
		    }
		    handshake.status = PTY_NEW;
		    (void) strcpy(handshake.buffer, ttydev);
		    write(pc_pipe[1], (char *) &handshake, sizeof(handshake));
		    break;
d4082 5
a4086 12
		case PTY_FATALERROR:
		    errno = handshake.error;
		    close(cp_pipe[0]);
		    close(pc_pipe[1]);
		    SysError(handshake.fatal_error);
		    /*NOTREACHED */

		case UTMP_ADDED:
		    /* The utmp entry was set by our slave.  Remember
		     * this so that we can reset it later.
		     */
		    added_utmp_entry = True;
d4088 1
a4088 1
		    tslot = handshake.tty_slot;
d4090 6
a4095 12
		    free(ttydev);
		    ttydev = x_strdup(handshake.buffer);
		    break;
		default:
		    fprintf(stderr, "%s: unexpected handshake status %d\n",
			    xterm_name, handshake.status);
		}
	    }
	    /* close our sides of the pipes */
	    if (!waiting_for_initial_map) {
		close(cp_pipe[0]);
		close(pc_pipe[1]);
d4098 6
a4103 1
#endif /* OPT_PTY_HANDSHAKE */
d4171 3
d4186 3
a4188 3
#if OPT_PTY_HANDSHAKE		/* without handshake, no way to know */
	&& (resource.ptyHandshake && added_utmp_entry)
#endif /* OPT_PTY_HANDSHAKE */
d4215 1
a4215 1
#if defined(WTMPX_FILE) && (defined(SVR4) || defined(SCO325))
d4224 4
a4227 6
	    if (term->misc.login_shell) {
		int fd;
		if ((fd = open(etc_wtmp, O_WRONLY | O_APPEND)) >= 0) {
		    write(fd, utptr, sizeof(*utptr));
		    close(fd);
		}
@


1.1.1.4
log
@OpenBSD updated X-Window plus fontconfig 2.2.2.
@
text
@d4505 3
a4507 3
    int arg;    
    ioctl(fd, FIONREAD, &arg);
    return arg;
@


1.1.1.5
log
@OpenBSD XF4 tree (minus old and mit) as of today
-> lib and fvwm fixes
@
text
@a704 1
#ifndef __OpenBSD__
a706 4
#else
    Bres("ptyInitialErase", "PtyInitialErase", ptyInitialErase, TRUE),
    Bres("backarrowKeyIsErase", "BackarrowKeyIsErase", backarrow_is_erase, TRUE),
#endif
@


