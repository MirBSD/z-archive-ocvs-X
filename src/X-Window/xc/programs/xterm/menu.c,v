head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407190955:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.11.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.11.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.41.13;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.46.25;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.29.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $Xorg: menu.c,v 1.4 2001/02/09 02:06:03 xorgcvs Exp $ */
/*

Copyright 1999, 2001 by Thomas E. Dickey

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of the above listed
copyright holder(s) not be used in advertising or publicity pertaining
to distribution of the software without specific, written prior
permission.

THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


Copyright 1989  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.

*/
/* $XFree86: xc/programs/xterm/menu.c,v 3.44 2002/01/05 22:05:03 dickey Exp $ */

#include <xterm.h>
#include <data.h>
#include <menu.h>
#include <fontutils.h>

#include <X11/StringDefs.h>
#include <X11/Shell.h>
#include <X11/Xmu/CharSet.h>

#include <X11/Xaw/SimpleMenu.h>
#include <X11/Xaw/Box.h>
#include <X11/Xaw/SmeBSB.h>
#include <X11/Xaw/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/Xaw/MenuButton.h>
#include <X11/Xaw/Form.h>
#endif

#include <stdio.h>
#include <signal.h>

static void do_8bit_control    PROTO_XT_CALLBACK_ARGS;
static void do_allow132        PROTO_XT_CALLBACK_ARGS;
static void do_allowsends      PROTO_XT_CALLBACK_ARGS;
static void do_altscreen       PROTO_XT_CALLBACK_ARGS;
static void do_appcursor       PROTO_XT_CALLBACK_ARGS;
static void do_appkeypad       PROTO_XT_CALLBACK_ARGS;
static void do_autolinefeed    PROTO_XT_CALLBACK_ARGS;
static void do_autowrap        PROTO_XT_CALLBACK_ARGS;
static void do_backarrow       PROTO_XT_CALLBACK_ARGS;
static void do_clearsavedlines PROTO_XT_CALLBACK_ARGS;
static void do_continue        PROTO_XT_CALLBACK_ARGS;
static void do_cursesemul      PROTO_XT_CALLBACK_ARGS;
static void do_delete_del      PROTO_XT_CALLBACK_ARGS;
static void do_hardreset       PROTO_XT_CALLBACK_ARGS;
static void do_interrupt       PROTO_XT_CALLBACK_ARGS;
static void do_jumpscroll      PROTO_XT_CALLBACK_ARGS;
static void do_kill            PROTO_XT_CALLBACK_ARGS;
static void do_marginbell      PROTO_XT_CALLBACK_ARGS;
static void do_old_fkeys       PROTO_XT_CALLBACK_ARGS;
static void do_print           PROTO_XT_CALLBACK_ARGS;
static void do_quit            PROTO_XT_CALLBACK_ARGS;
static void do_redraw          PROTO_XT_CALLBACK_ARGS;
static void do_reversevideo    PROTO_XT_CALLBACK_ARGS;
static void do_reversewrap     PROTO_XT_CALLBACK_ARGS;
static void do_scrollbar       PROTO_XT_CALLBACK_ARGS;
static void do_scrollkey       PROTO_XT_CALLBACK_ARGS;
static void do_scrollttyoutput PROTO_XT_CALLBACK_ARGS;
static void do_securekbd       PROTO_XT_CALLBACK_ARGS;
static void do_softreset       PROTO_XT_CALLBACK_ARGS;
static void do_sun_fkeys       PROTO_XT_CALLBACK_ARGS;
static void do_suspend         PROTO_XT_CALLBACK_ARGS;
static void do_terminate       PROTO_XT_CALLBACK_ARGS;
static void do_titeInhibit     PROTO_XT_CALLBACK_ARGS;
static void do_visualbell      PROTO_XT_CALLBACK_ARGS;
static void do_poponbell       PROTO_XT_CALLBACK_ARGS;
static void do_vtfont          PROTO_XT_CALLBACK_ARGS;

#ifdef ALLOWLOGGING
static void do_logging         PROTO_XT_CALLBACK_ARGS;
#endif

#ifndef NO_ACTIVE_ICON
static void do_activeicon      PROTO_XT_CALLBACK_ARGS;
#endif /* NO_ACTIVE_ICON */

#if OPT_BLINK_CURS
static void do_cursorblink     PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_BOX_CHARS
static void do_font_boxchars   PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_DEC_CHRSET
static void do_font_doublesize PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_DEC_SOFTFONT
static void do_font_loadable   PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_HP_FUNC_KEYS
static void do_hp_fkeys        PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_NUM_LOCK
static void do_num_lock        PROTO_XT_CALLBACK_ARGS;
static void do_meta_esc        PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_SCO_FUNC_KEYS
static void do_sco_fkeys       PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_SUNPC_KBD
static void do_sun_kbd         PROTO_XT_CALLBACK_ARGS;
#endif

#if OPT_TEK4014
static void do_tekcopy         PROTO_XT_CALLBACK_ARGS;
static void do_tekhide         PROTO_XT_CALLBACK_ARGS;
static void do_tekmode         PROTO_XT_CALLBACK_ARGS;
static void do_tekonoff        PROTO_XT_CALLBACK_ARGS;
static void do_tekpage         PROTO_XT_CALLBACK_ARGS;
static void do_tekreset        PROTO_XT_CALLBACK_ARGS;
static void do_tekshow         PROTO_XT_CALLBACK_ARGS;
static void do_tektext2        PROTO_XT_CALLBACK_ARGS;
static void do_tektext3        PROTO_XT_CALLBACK_ARGS;
static void do_tektextlarge    PROTO_XT_CALLBACK_ARGS;
static void do_tektextsmall    PROTO_XT_CALLBACK_ARGS;
static void do_vthide          PROTO_XT_CALLBACK_ARGS;
static void do_vtmode          PROTO_XT_CALLBACK_ARGS;
static void do_vtonoff         PROTO_XT_CALLBACK_ARGS;
static void do_vtshow          PROTO_XT_CALLBACK_ARGS;
static void handle_tekshow     (Widget gw, Bool allowswitch);
static void handle_vtshow      (Widget gw, Bool allowswitch);
#endif

/*
 * The order of entries MUST match the values given in menu.h
 */
MenuEntry mainMenuEntries[] = {
    { "securekbd",	do_securekbd,	NULL },
    { "allowsends",	do_allowsends,	NULL },
#ifdef ALLOWLOGGING
    { "logging",	do_logging,	NULL },
#endif
    { "print",		do_print,	NULL },
    { "redraw",		do_redraw,	NULL },
    { "line1",		NULL,		NULL },
    { "8-bit control",	do_8bit_control, NULL },
    { "backarrow key",	do_backarrow,	NULL },
#if OPT_NUM_LOCK
    { "num-lock",	do_num_lock,	NULL },
    { "meta-esc",	do_meta_esc,	NULL },
#endif
    { "delete-is-del",	do_delete_del,	NULL },
    { "oldFunctionKeys",do_old_fkeys,	NULL },
#if OPT_HP_FUNC_KEYS
    { "hpFunctionKeys",	do_hp_fkeys,	NULL },
#endif
#if OPT_SCO_FUNC_KEYS
    { "scoFunctionKeys",do_sco_fkeys,	NULL },
#endif
    { "sunFunctionKeys",do_sun_fkeys,	NULL },
#if OPT_SUNPC_KBD
    { "sunKeyboard",	do_sun_kbd,	NULL },
#endif
    { "line2",		NULL,		NULL },
    { "suspend",	do_suspend,	NULL },
    { "continue",	do_continue,	NULL },
    { "interrupt",	do_interrupt,	NULL },
    { "hangup",		do_hangup,	NULL },
    { "terminate",	do_terminate,	NULL },
    { "kill",		do_kill,	NULL },
    { "line3",		NULL,		NULL },
    { "quit",		do_quit,	NULL }};

MenuEntry vtMenuEntries[] = {
    { "scrollbar",	do_scrollbar,	NULL },
    { "jumpscroll",	do_jumpscroll,	NULL },
    { "reversevideo",	do_reversevideo, NULL },
    { "autowrap",	do_autowrap,	NULL },
    { "reversewrap",	do_reversewrap, NULL },
    { "autolinefeed",	do_autolinefeed, NULL },
    { "appcursor",	do_appcursor,	NULL },
    { "appkeypad",	do_appkeypad,	NULL },
    { "scrollkey",	do_scrollkey,	NULL },
    { "scrollttyoutput",do_scrollttyoutput, NULL },
    { "allow132",	do_allow132,	NULL },
    { "cursesemul",	do_cursesemul,	NULL },
    { "visualbell",	do_visualbell,	NULL },
    { "poponbell",	do_poponbell,	NULL },
    { "marginbell",	do_marginbell,	NULL },
#if OPT_BLINK_CURS
    { "cursorblink",	do_cursorblink,	NULL },
#endif
    { "titeInhibit",	do_titeInhibit,	NULL },
#ifndef NO_ACTIVE_ICON
    { "activeicon",	do_activeicon,	NULL },
#endif /* NO_ACTIVE_ICON */
    { "line1",		NULL,		NULL },
    { "softreset",	do_softreset,	NULL },
    { "hardreset",	do_hardreset,	NULL },
    { "clearsavedlines",do_clearsavedlines, NULL },
    { "line2",		NULL,		NULL },
#if OPT_TEK4014
    { "tekshow",	do_tekshow,	NULL },
    { "tekmode",	do_tekmode,	NULL },
    { "vthide",		do_vthide,	NULL },
#endif
    { "altscreen",	do_altscreen,	NULL },
    };

MenuEntry fontMenuEntries[] = {
    { "fontdefault",	do_vtfont,	NULL },
    { "font1",		do_vtfont,	NULL },
    { "font2",		do_vtfont,	NULL },
    { "font3",		do_vtfont,	NULL },
    { "font4",		do_vtfont,	NULL },
    { "font5",		do_vtfont,	NULL },
    { "font6",		do_vtfont,	NULL },
    /* this is after the last builtin font; the other entries are special */
    { "fontescape",	do_vtfont,	NULL },
    { "fontsel",	do_vtfont,	NULL },
    /* down to here should match NMENUFONTS in ptyx.h */
#if OPT_DEC_CHRSET || OPT_BOX_CHARS || OPT_DEC_SOFTFONT
    { "line1",		NULL,		NULL },
#if OPT_BOX_CHARS
    { "font-linedrawing",do_font_boxchars,NULL },
#endif
#if OPT_DEC_CHRSET
    { "font-doublesize",do_font_doublesize,NULL },
#endif
#if OPT_DEC_SOFTFONT
    { "font-loadable",	do_font_loadable,NULL },
#endif
#endif /* toggles for font extensions */
    };

#if OPT_TEK4014
MenuEntry tekMenuEntries[] = {
    { "tektextlarge",	do_tektextlarge, NULL },
    { "tektext2",	do_tektext2,	NULL },
    { "tektext3",	do_tektext3,	NULL },
    { "tektextsmall",	do_tektextsmall, NULL },
    { "line1",		NULL,		NULL },
    { "tekpage",	do_tekpage,	NULL },
    { "tekreset",	do_tekreset,	NULL },
    { "tekcopy",	do_tekcopy,	NULL },
    { "line2",		NULL,		NULL },
    { "vtshow",		do_vtshow,	NULL },
    { "vtmode",		do_vtmode,	NULL },
    { "tekhide",	do_tekhide,	NULL }};
#endif

typedef struct {
    char *internal_name;
    MenuEntry *entry_list;
    Cardinal entry_len;
} MenuHeader;

    /* This table is ordered to correspond with MenuIndex */
static MenuHeader menu_names[] = {
    { "mainMenu", mainMenuEntries, XtNumber(mainMenuEntries) },
    { "vtMenu",   vtMenuEntries,   XtNumber(vtMenuEntries)   },
    { "fontMenu", fontMenuEntries, XtNumber(fontMenuEntries) },
#if OPT_TEK4014
    { "tekMenu",  tekMenuEntries,  XtNumber(tekMenuEntries)  },
#endif
    { 0,          0,               0 },
};

/*
 * FIXME:  These are global data rather than in the xterm widget because they
 * are initialized before the widget is created.
 */
typedef struct {
    Widget w;
    Cardinal entries;
} MenuList;

static MenuList vt_shell[NUM_POPUP_MENUS];

#if OPT_TEK4014 && OPT_TOOLBAR
static MenuList tek_shell[NUM_POPUP_MENUS];
#endif

/*
 * Returns a pointer to the MenuList entry that matches the popup menu.
 */
static MenuList *
select_menu (Widget w GCC_UNUSED, MenuIndex num)
{
#if OPT_TEK4014 && OPT_TOOLBAR
    while (w != 0) {
	if (w == tekshellwidget) {
	    return &tek_shell[num];
	}
	w = XtParent(w);
    }
#endif
    return &vt_shell[num];
}

/*
 * Returns a pointer to the given popup menu shell
 */
static Widget
obtain_menu (Widget w, MenuIndex num)
{
    return select_menu(w, num)->w;
}

/*
 * Returns the number of entries in the given popup menu shell
 */
static Cardinal
sizeof_menu (Widget w, MenuIndex num)
{
    return select_menu(w, num)->entries;
}

/*
 * create_menu - create a popup shell and stuff the menu into it.
 */

static Widget
create_menu (Widget w, XtermWidget xtw, MenuIndex num)
{
    static XtCallbackRec cb[2] = { { NULL, NULL }, { NULL, NULL }};
    static Arg arg = { XtNcallback, (XtArgVal) cb };

    Widget m;
    TScreen *screen = &xtw->screen;
    MenuHeader *data = &menu_names[num];
    MenuList *list = select_menu(w, num);
    struct _MenuEntry *entries = data->entry_list;
    int nentries = data->entry_len;

    if (screen->menu_item_bitmap == None) {
	/*
	 * we really want to do these dynamically
	 */
#define check_width 9
#define check_height 8
	static unsigned char check_bits[] = {
	   0x00, 0x01, 0x80, 0x01, 0xc0, 0x00, 0x60, 0x00,
	   0x31, 0x00, 0x1b, 0x00, 0x0e, 0x00, 0x04, 0x00
	};

	screen->menu_item_bitmap =
	XCreateBitmapFromData (XtDisplay(xtw),
				RootWindowOfScreen(XtScreen(xtw)),
				(char *)check_bits, check_width, check_height);
    }

#if OPT_TOOLBAR
    m = list->w;
    if (m == 0) {
	return m;
    }
#else
    m = XtCreatePopupShell (data->internal_name, simpleMenuWidgetClass, toplevel, NULL, 0);
    list->w = m;
#endif
    list->entries = nentries;

    for (; nentries > 0; nentries--, entries++) {
	cb[0].callback = (XtCallbackProc) entries->function;
	cb[0].closure = (caddr_t) entries->name;
	entries->widget = XtCreateManagedWidget (entries->name,
						 (entries->function ?
						  smeBSBObjectClass :
						  smeLineObjectClass), m,
						 &arg, (Cardinal) 1);
    }

    /* do not realize at this point */
    return m;
}

static int indexOfMenu(String menuName)
{
    int me;
    switch (*menuName) {
    case 'm':
	me = mainMenu;
	break;
    case 'v':
	me = vtMenu;
	break;
    case 'f':
	me = fontMenu;
	break;
#if OPT_TEK4014
    case 't':
	me = tekMenu;
	break;
#endif
    default:
	me = -1;
    }
    return (me);
}

/*
 * public interfaces
 */

/* ARGSUSED */
static Bool domenu (
	Widget w GCC_UNUSED,
	XEvent *event GCC_UNUSED,
	String *params,             /* mainMenu, vtMenu, or tekMenu */
	Cardinal *param_count)      /* 0 or 1 */
{
    TScreen *screen = &term->screen;
    int me;
    Boolean created = False;
    Widget mw;

    if (*param_count != 1) {
	Bell(XkbBI_MinorError,0);
	return False;
    }

    if ((me = indexOfMenu(params[0])) < 0) {
	Bell(XkbBI_MinorError,0);
	return False;
    }

    if ((mw = obtain_menu(w, (MenuIndex) me)) == 0
     || sizeof_menu(w, me) == 0) {
	mw = create_menu (w, term, (MenuIndex) me);
	created = (mw != 0);
    }
    if (mw == 0)
	return False;

    switch (me) {
      case mainMenu:
	if (created) {
	    update_securekbd();
	    update_allowsends();
	    update_logging();
	    update_8bit_control();
	    update_decbkm();
	    update_num_lock();
	    update_meta_esc();
	    update_delete_del();
	    update_keyboard_type();
	    if (screen->terminal_id < 200) {
		set_sensitivity (mw,
				 mainMenuEntries[mainMenu_8bit_ctrl].widget,
				 FALSE);
	    }
#if !defined(SIGTSTP) || defined(AMOEBA)
	    set_sensitivity (mw,
			     mainMenuEntries[mainMenu_suspend].widget, FALSE);
#endif
#if !defined(SIGCONT) || defined(AMOEBA)
	    set_sensitivity (mw,
			     mainMenuEntries[mainMenu_continue].widget, FALSE);
#endif
	}
	break;

      case vtMenu:
	if (created) {
	    update_scrollbar();
	    update_jumpscroll();
	    update_reversevideo();
	    update_autowrap();
	    update_reversewrap();
	    update_autolinefeed();
	    update_appcursor();
	    update_appkeypad();
	    update_scrollkey();
	    update_scrollttyoutput();
	    update_allow132();
	    update_cursesemul();
	    update_visualbell();
	    update_poponbell();
	    update_marginbell();
	    update_cursorblink();
	    update_altscreen();
	    update_titeInhibit();
#ifndef NO_ACTIVE_ICON
	    if (!screen->fnt_icon || !screen->iconVwin.window) {
		set_sensitivity (mw,
				 vtMenuEntries[vtMenu_activeicon].widget,
				 FALSE);
	    }
	    else
		update_activeicon();
#endif /* NO_ACTIVE_ICON */
	}
	break;

      case fontMenu:
	if (created) {
	    set_menu_font (True);
	    set_sensitivity (mw,
			     fontMenuEntries[fontMenu_fontescape].widget,
			     (screen->menu_font_names[fontMenu_fontescape]
			      ? TRUE : FALSE));
#if OPT_BOX_CHARS
	    update_font_boxchars();
	    set_sensitivity (mw,
			     fontMenuEntries[fontMenu_font_boxchars].widget,
			     True);
#endif
#if OPT_DEC_SOFTFONT	/* FIXME: not implemented */
	    update_font_loadable();
	    set_sensitivity (mw,
			     fontMenuEntries[fontMenu_font_loadable].widget,
			     FALSE);
#endif
#if OPT_DEC_CHRSET
	    update_font_doublesize();
	    if (term->screen.cache_doublesize == 0)
		set_sensitivity (mw,
				fontMenuEntries[fontMenu_font_doublesize].widget,
				False);
#endif
	}
	FindFontSelection (NULL, True);
	set_sensitivity (mw,
			 fontMenuEntries[fontMenu_fontsel].widget,
			 (screen->menu_font_names[fontMenu_fontsel]
			  ? TRUE : FALSE));
	break;

#if OPT_TEK4014
      case tekMenu:
	if (created) {
	    set_tekfont_menu_item (screen->cur.fontsize, TRUE);
	    update_vtshow();
	}
	break;
#endif
    }

    return True;
}

void HandleCreateMenu (
	Widget w,
	XEvent *event,              /* unused */
	String *params,             /* mainMenu, vtMenu, or tekMenu */
	Cardinal *param_count)      /* 0 or 1 */
{
    (void) domenu (w, event, params, param_count);
}

void HandlePopupMenu (
	Widget w,
	XEvent *event,              /* unused */
	String *params,             /* mainMenu, vtMenu, or tekMenu */
	Cardinal *param_count)      /* 0 or 1 */
{
    if (domenu (w, event, params, param_count)) {
#if OPT_TOOLBAR
	w = select_menu(w, mainMenu)->w;
#endif
	XtCallActionProc (w, "XawPositionSimpleMenu", event, params, 1);
	XtCallActionProc (w, "MenuPopup", event, params, 1);
    }
}


/*
 * private interfaces - keep out!
 */

/* ARGSUSED */
static void handle_send_signal (Widget gw GCC_UNUSED, int sig)
{
#ifndef VMS
    register TScreen *screen = &term->screen;

    if (hold_screen > 1) hold_screen = 0;
    if (screen->pid > 1) kill_process_group (screen->pid, sig);
#endif
}


/*
 * action routines
 */

/* ARGSUSED */
void DoSecureKeyboard (Time tp GCC_UNUSED)
{
    do_securekbd (vt_shell[mainMenu].w, (XtPointer)0, (XtPointer)0);
}

static void do_securekbd (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    register TScreen *screen = &term->screen;
    Time now = CurrentTime;		/* XXX - wrong */

    if (screen->grabbedKbd) {
	XUngrabKeyboard (screen->display, now);
	ReverseVideo (term);
	screen->grabbedKbd = FALSE;
    } else {
	if (XGrabKeyboard (screen->display, XtWindow(term),
			   True, GrabModeAsync, GrabModeAsync, now)
	    != GrabSuccess) {
	    Bell(XkbBI_MinorError, 100);
	} else {
	    ReverseVideo (term);
	    screen->grabbedKbd = TRUE;
	}
    }
    update_securekbd();
}


static void do_allowsends (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    register TScreen *screen = &term->screen;

    screen->allowSendEvents = !screen->allowSendEvents;
    update_allowsends ();
}

static void do_visualbell (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    register TScreen *screen = &term->screen;

    screen->visualbell = !screen->visualbell;
    update_visualbell();
}

static void do_poponbell (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    register TScreen *screen = &term->screen;

    screen->poponbell = !screen->poponbell;
    update_poponbell();
}

#ifdef ALLOWLOGGING
static void do_logging (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    register TScreen *screen = &term->screen;

    if (screen->logging) {
	CloseLog (screen);
    } else {
	StartLog (screen);
    }
    /* update_logging done by CloseLog and StartLog */
}
#endif

static void do_print (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    xtermPrintScreen (TRUE);
}


static void do_redraw (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    Redraw ();
}


void show_8bit_control (Bool value)
{
    if (term->screen.control_eight_bits != value) {
	term->screen.control_eight_bits = value;
	update_8bit_control();
    }
}

static void do_8bit_control (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    show_8bit_control(! term->screen.control_eight_bits);
}

static void do_backarrow (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    term->keyboard.flags ^= MODE_DECBKM;
    update_decbkm();
}

#if OPT_NUM_LOCK
static void do_num_lock (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    term->misc.real_NumLock = ! term->misc.real_NumLock;
    update_num_lock();
}

static void do_meta_esc (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    term->screen.meta_sends_esc = ! term->screen.meta_sends_esc;
    update_meta_esc();
}
#endif

static void do_delete_del (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    if (xtermDeleteIsDEL())
	term->screen.delete_is_del = False;
    else
	term->screen.delete_is_del = True;
    update_delete_del();
}

static void do_old_fkeys (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(keyboardIsLegacy);
}

#if OPT_HP_FUNC_KEYS
static void do_hp_fkeys (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(keyboardIsHP);
}
#endif

#if OPT_SCO_FUNC_KEYS
static void do_sco_fkeys (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(keyboardIsSCO);
}
#endif

static void do_sun_fkeys (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(keyboardIsSun);
}

#if OPT_SUNPC_KBD
/*
 * This really means "Sun/PC keyboard emulating VT220".
 */
static void do_sun_kbd (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    toggle_keyboard_type(keyboardIsVT220);
}
#endif

/*
 * The following cases use the pid instead of the process group so that we
 * don't get hosed by programs that change their process group
 */


/* ARGSUSED */
static void do_suspend (
	Widget gw,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
#if defined(SIGTSTP) && !defined(AMOEBA)
    handle_send_signal (gw, SIGTSTP);
#endif
}

/* ARGSUSED */
static void do_continue (
	Widget gw,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
#if defined(SIGCONT) && !defined(AMOEBA)
    handle_send_signal (gw, SIGCONT);
#endif
}

/* ARGSUSED */
static void do_interrupt (
	Widget gw,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    handle_send_signal (gw, SIGINT);
}

/* ARGSUSED */
void do_hangup (
	Widget gw,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    handle_send_signal (gw, SIGHUP);
}

/* ARGSUSED */
static void do_terminate (
	Widget gw,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    handle_send_signal (gw, SIGTERM);
}

/* ARGSUSED */
static void do_kill (
	Widget gw,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    handle_send_signal (gw, SIGKILL);
}

static void do_quit (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    Cleanup (0);
}



/*
 * vt menu callbacks
 */

static void do_scrollbar (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    ToggleScrollBar(term);
}


static void do_jumpscroll (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    register TScreen *screen = &term->screen;

    term->flags ^= SMOOTHSCROLL;
    if (term->flags & SMOOTHSCROLL) {
	screen->jumpscroll = FALSE;
	if (screen->scroll_amt) FlushScroll(screen);
    } else {
	screen->jumpscroll = TRUE;
    }
    update_jumpscroll();
}


static void do_reversevideo (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    ReverseVideo (term);
}


static void do_autowrap (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    term->flags ^= WRAPAROUND;
    update_autowrap();
}


static void do_reversewrap (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    term->flags ^= REVERSEWRAP;
    update_reversewrap();
}


static void do_autolinefeed (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    term->flags ^= LINEFEED;
    update_autolinefeed();
}


static void do_appcursor (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    term->keyboard.flags ^= MODE_DECCKM;
    update_appcursor();
}


static void do_appkeypad (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    term->keyboard.flags ^= MODE_DECKPAM;
    update_appkeypad();
}


static void do_scrollkey (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    register TScreen *screen = &term->screen;

    screen->scrollkey = !screen->scrollkey;
    update_scrollkey();
}


static void do_scrollttyoutput (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    register TScreen *screen = &term->screen;

    screen->scrollttyoutput = !screen->scrollttyoutput;
    update_scrollttyoutput();
}


static void do_allow132 (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    register TScreen *screen = &term->screen;

    screen->c132 = !screen->c132;
    update_allow132();
}


static void do_cursesemul (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    register TScreen *screen = &term->screen;

    screen->curses = !screen->curses;
    update_cursesemul();
}


static void do_marginbell (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    register TScreen *screen = &term->screen;

    if (!(screen->marginbell = !screen->marginbell)) screen->bellarmed = -1;
    update_marginbell();
}


#if OPT_TEK4014
static void handle_tekshow (Widget gw GCC_UNUSED, Bool allowswitch)
{
    register TScreen *screen = &term->screen;

    if (!screen->Tshow) {		/* not showing, turn on */
	set_tek_visibility (TRUE);
    } else if (screen->Vshow || allowswitch) {  /* is showing, turn off */
	set_tek_visibility (FALSE);
	end_tek_mode ();		/* WARNING: this does a longjmp */
    } else
      Bell(XkbBI_MinorError, 0);
}

/* ARGSUSED */
static void do_tekshow (
	Widget gw,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    handle_tekshow (gw, True);
}

/* ARGSUSED */
static void do_tekonoff (
	Widget gw,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    handle_tekshow (gw, False);
}
#endif /* OPT_TEK4014 */

#if OPT_BLINK_CURS
/* ARGSUSED */
static void do_cursorblink (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;
    ToggleCursorBlink(screen);
}
#endif

/* ARGSUSED */
static void do_altscreen (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;
    ToggleAlternate(screen);
}

/* ARGSUSED */
static void do_titeInhibit (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    term->misc.titeInhibit = !term->misc.titeInhibit;
    update_titeInhibit();
}

#ifndef NO_ACTIVE_ICON
/* ARGSUSED */
static void do_activeicon (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    TScreen *screen = &term->screen;

    if (screen->iconVwin.window) {
	Widget shell = XtParent(term);
	term->misc.active_icon = !term->misc.active_icon;
	XtVaSetValues(shell, XtNiconWindow,
		      term->misc.active_icon ? screen->iconVwin.window : None,
		      NULL);
	update_activeicon();
    }
}
#endif /* NO_ACTIVE_ICON */

static void do_softreset (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    VTReset (FALSE, FALSE);
}


static void do_hardreset (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    VTReset (TRUE, FALSE);
}


static void do_clearsavedlines (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    VTReset (TRUE, TRUE);
}


#if OPT_TEK4014
static void do_tekmode (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    register TScreen *screen = &term->screen;

    switch_modes (screen->TekEmu);	/* switch to tek mode */
}

/* ARGSUSED */
static void do_vthide (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    hide_vt_window();
}
#endif /* OPT_TEK4014 */


/*
 * vtfont menu
 */

static void do_vtfont (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    char *entryname = (char *) closure;
    int i;

    for (i = 0; i < NMENUFONTS; i++) {
	if (strcmp (entryname, fontMenuEntries[i].name) == 0) {
	    SetVTFont (i, True, VT_FONTSET(NULL, NULL, NULL, NULL));
	    return;
	}
    }
    Bell(XkbBI_MinorError, 0);
}

#if OPT_DEC_CHRSET
static void do_font_doublesize (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    if (term->screen.cache_doublesize != 0)
        term->screen.font_doublesize = ! term->screen.font_doublesize;
    update_font_doublesize();
    Redraw ();
}
#endif

#if OPT_BOX_CHARS
static void do_font_boxchars (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    term->screen.force_box_chars = ! term->screen.force_box_chars;
    update_font_boxchars();
    Redraw ();
}
#endif

#if OPT_DEC_SOFTFONT
static void do_font_loadable (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    term->misc.font_loadable = ! term->misc.font_loadable;
    update_font_loadable();
}
#endif


/*
 * tek menu
 */

#if OPT_TEK4014
static void do_tektextlarge (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    TekSetFontSize (tekMenu_tektextlarge);
}


static void do_tektext2 (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    TekSetFontSize (tekMenu_tektext2);
}


static void do_tektext3 (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    TekSetFontSize (tekMenu_tektext3);
}


static void do_tektextsmall (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{

    TekSetFontSize (tekMenu_tektextsmall);
}


static void do_tekpage (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    TekSimulatePageButton (False);
}


static void do_tekreset (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    TekSimulatePageButton (True);
}


static void do_tekcopy (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    TekCopy ();
}


static void handle_vtshow (Widget gw GCC_UNUSED, Bool allowswitch)
{
    register TScreen *screen = &term->screen;

    if (!screen->Vshow) {		/* not showing, turn on */
	set_vt_visibility (TRUE);
    } else if (screen->Tshow || allowswitch) {  /* is showing, turn off */
	set_vt_visibility (FALSE);
	if (!screen->TekEmu && TekRefresh) dorefresh ();
	end_vt_mode ();			/* WARNING: this does a longjmp... */
    } else
      Bell(XkbBI_MinorError, 0);
}

static void do_vtshow (
	Widget gw,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    handle_vtshow (gw, True);
}

static void do_vtonoff (
	Widget gw,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    handle_vtshow (gw, False);
}

static void do_vtmode (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    register TScreen *screen = &term->screen;

    switch_modes (screen->TekEmu);	/* switch to vt, or from */
}


/* ARGSUSED */
static void do_tekhide (
	Widget gw GCC_UNUSED,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
    hide_tek_window();
}
#endif /* OPT_TEK4014 */



/*
 * public handler routines
 */

static void handle_toggle (
	void (*proc)PROTO_XT_CALLBACK_ARGS,
	int var,
	String *params,
	Cardinal nparams,
	Widget w,
	XtPointer closure,
	XtPointer data)
{
    int dir = -2;

    switch (nparams) {
      case 0:
	dir = -1;
	break;
      case 1:
	if (XmuCompareISOLatin1 (params[0], "on") == 0) dir = 1;
	else if (XmuCompareISOLatin1 (params[0], "off") == 0) dir = 0;
	else if (XmuCompareISOLatin1 (params[0], "toggle") == 0) dir = -1;
	break;
    }

    switch (dir) {
      case -2:
	Bell(XkbBI_MinorError, 0);
	break;

      case -1:
	(*proc) (w, closure, data);
	break;

      case 0:
	if (var) (*proc) (w, closure, data);
	else Bell(XkbBI_MinorError, 0);
	break;

      case 1:
	if (!var) (*proc) (w, closure, data);
	else Bell(XkbBI_MinorError, 0);
	break;
    }
    return;
}

void HandleAllowSends(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_allowsends, (int) term->screen.allowSendEvents,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleSetVisualBell(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_visualbell, (int) term->screen.visualbell,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleSetPopOnBell(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_poponbell, (int) term->screen.poponbell,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

#ifdef ALLOWLOGGING
void HandleLogging(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_logging, (int) term->screen.logging,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}
#endif

/* ARGSUSED */
void HandlePrint(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params GCC_UNUSED,
	Cardinal *param_count GCC_UNUSED)
{
    do_print(w, (XtPointer)0, (XtPointer)0);
}

/* ARGSUSED */
void HandleRedraw(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params GCC_UNUSED,
	Cardinal *param_count GCC_UNUSED)
{
    do_redraw(w, (XtPointer)0, (XtPointer)0);
}

/* ARGSUSED */
void HandleSendSignal(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    static struct sigtab {
	char *name;
	int sig;
    } signals[] = {
#ifdef SIGTSTP
	{ "suspend",	SIGTSTP },
	{ "tstp",	SIGTSTP },
#endif
#ifdef SIGCONT
	{ "cont",	SIGCONT },
#endif
	{ "int",	SIGINT },
	{ "hup",	SIGHUP },
	{ "quit",	SIGQUIT },
	{ "alrm",	SIGALRM },
	{ "alarm",	SIGALRM },
	{ "term",	SIGTERM },
	{ "kill",	SIGKILL },
	{ NULL, 0 },
    };

    if (*param_count == 1) {
	struct sigtab *st;

	for (st = signals; st->name; st++) {
	    if (XmuCompareISOLatin1 (st->name, params[0]) == 0) {
		handle_send_signal (w, st->sig);
		return;
	    }
	}
	/* one could allow numeric values, but that would be a security hole */
    }

    Bell(XkbBI_MinorError, 0);
}

/* ARGSUSED */
void HandleQuit(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params GCC_UNUSED,
	Cardinal *param_count GCC_UNUSED)
{
    do_quit(w, (XtPointer)0, (XtPointer)0);
}

void Handle8BitControl(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_8bit_control, (int) term->screen.control_eight_bits,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleBackarrow(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_backarrow, (int) term->keyboard.flags & MODE_DECBKM,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleSunFunctionKeys(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_sun_fkeys, term->keyboard.type == keyboardIsSun,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

#if OPT_NUM_LOCK
void HandleNumLock(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_num_lock, (int) term->misc.real_NumLock,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleMetaEsc(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_meta_esc, (int) term->screen.meta_sends_esc,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}
#endif

void HandleDeleteIsDEL(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_delete_del, term->screen.delete_is_del,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleOldFunctionKeys(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_old_fkeys, term->keyboard.type == keyboardIsLegacy,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

#if OPT_SUNPC_KBD
void HandleSunKeyboard(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_sun_kbd, term->keyboard.type == keyboardIsVT220,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}
#endif

#if OPT_HP_FUNC_KEYS
void HandleHpFunctionKeys(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_hp_fkeys, term->keyboard.type == keyboardIsHP,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}
#endif

#if OPT_SCO_FUNC_KEYS
void HandleScoFunctionKeys(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_sco_fkeys, term->keyboard.type == keyboardIsSCO,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}
#endif

void HandleScrollbar(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_scrollbar, (int) term->screen.fullVwin.sb_info.width,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleJumpscroll(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_jumpscroll, (int) term->screen.jumpscroll,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleReverseVideo(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_reversevideo, (int) (term->misc.re_verse0),
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleAutoWrap(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_autowrap, (int) (term->flags & WRAPAROUND),
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleReverseWrap(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_reversewrap, (int) (term->flags & REVERSEWRAP),
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleAutoLineFeed(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_autolinefeed, (int) (term->flags & LINEFEED),
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleAppCursor(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_appcursor, (int) (term->keyboard.flags & MODE_DECCKM),
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleAppKeypad(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_appkeypad, (int) (term->keyboard.flags & MODE_DECKPAM),
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleScrollKey(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_scrollkey, (int) term->screen.scrollkey,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleScrollTtyOutput(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_scrollttyoutput, (int) term->screen.scrollttyoutput,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleAllow132(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_allow132, (int) term->screen.c132,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleCursesEmul(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_cursesemul, (int) term->screen.curses,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleMarginBell(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_marginbell, (int) term->screen.marginbell,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

#if OPT_BLINK_CURS
void HandleCursorBlink(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    /* eventually want to see if sensitive or not */
    handle_toggle (do_cursorblink, (int) term->screen.cursor_blink,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}
#endif

void HandleAltScreen(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    /* eventually want to see if sensitive or not */
    handle_toggle (do_altscreen, (int) term->screen.alternate,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

void HandleTiteInhibit(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    /* eventually want to see if sensitive or not */
    handle_toggle (do_titeInhibit, ! ((int) term->misc.titeInhibit),
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}

/* ARGSUSED */
void HandleSoftReset(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params GCC_UNUSED,
	Cardinal *param_count GCC_UNUSED)
{
    do_softreset(w, (XtPointer)0, (XtPointer)0);
}

/* ARGSUSED */
void HandleHardReset(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params GCC_UNUSED,
	Cardinal *param_count GCC_UNUSED)
{
    do_hardreset(w, (XtPointer)0, (XtPointer)0);
}

/* ARGSUSED */
void HandleClearSavedLines(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params GCC_UNUSED,
	Cardinal *param_count GCC_UNUSED)
{
    do_clearsavedlines(w, (XtPointer)0, (XtPointer)0);
}

#if OPT_DEC_CHRSET
void HandleFontDoublesize(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_font_doublesize, (int) term->screen.font_doublesize,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}
#endif

#if OPT_BOX_CHARS
void HandleFontBoxChars(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_font_boxchars, (int) term->screen.force_box_chars,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}
#endif

#if OPT_DEC_SOFTFONT
void HandleFontLoading(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    handle_toggle (do_font_loadable, (int) term->misc.font_loadable,
		   params, *param_count, w, (XtPointer)0, (XtPointer)0);
}
#endif

#if OPT_TEK4014
void HandleSetTerminalType(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    if (*param_count == 1) {
	switch (params[0][0]) {
	  case 'v': case 'V':
	    if (term->screen.TekEmu) do_vtmode (w, (XtPointer)0, (XtPointer)0);
	    break;
	  case 't': case 'T':
	    if (!term->screen.TekEmu) do_tekmode (w, (XtPointer)0, (XtPointer)0);
	    break;
	  default:
	    Bell(XkbBI_MinorError, 0);
	}
    } else {
	Bell(XkbBI_MinorError, 0);
    }
}

void HandleVisibility(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    if (*param_count == 2) {
	switch (params[0][0]) {
	  case 'v': case 'V':
	    handle_toggle (do_vtonoff, (int) term->screen.Vshow,
			   params+1, (*param_count) - 1, w, (XtPointer)0, (XtPointer)0);
	    break;
	  case 't': case 'T':
	    handle_toggle (do_tekonoff, (int) term->screen.Tshow,
			   params+1, (*param_count) - 1, w, (XtPointer)0, (XtPointer)0);
	    break;
	  default:
	    Bell(XkbBI_MinorError, 0);
	}
    } else {
	Bell(XkbBI_MinorError, 0);
    }
}

/* ARGSUSED */
void HandleSetTekText(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params,
	Cardinal *param_count)
{
    void (*proc)PROTO_XT_CALLBACK_ARGS = 0;

    switch (*param_count) {
      case 0:
	proc = do_tektextlarge;
	break;
      case 1:
	switch (params[0][0]) {
	  case 'l': case 'L': proc = do_tektextlarge; break;
	  case '2': proc = do_tektext2; break;
	  case '3': proc = do_tektext3; break;
	  case 's': case 'S': proc = do_tektextsmall; break;
	}
	break;
    }
    if (proc) (*proc) (w, (XtPointer)0, (XtPointer)0);
    else Bell(XkbBI_MinorError, 0);
}

/* ARGSUSED */
void HandleTekPage(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params GCC_UNUSED,
	Cardinal *param_count GCC_UNUSED)
{
    do_tekpage(w, (XtPointer)0, (XtPointer)0);
}

/* ARGSUSED */
void HandleTekReset(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params GCC_UNUSED,
	Cardinal *param_count GCC_UNUSED)
{
    do_tekreset(w, (XtPointer)0, (XtPointer)0);
}

/* ARGSUSED */
void HandleTekCopy(
	Widget w,
	XEvent *event GCC_UNUSED,
	String *params GCC_UNUSED,
	Cardinal *param_count GCC_UNUSED)
{
    do_tekcopy(w, (XtPointer)0, (XtPointer)0);
}
#endif /* OPT_TEK4014 */

void
UpdateMenuItem(Widget mi, XtArgVal val)
{
	static Arg menuArgs = { XtNleftBitmap, (XtArgVal) 0 };

	if (mi) {
		menuArgs.value = (XtArgVal) ((val)
				? term->screen.menu_item_bitmap
				: None);
		XtSetValues (mi, &menuArgs, (Cardinal) 1);
	}
}

void
SetItemSensitivity(Widget mi, XtArgVal val)
{
	static Arg menuArgs = { XtNsensitive, (XtArgVal) 0 };

	if (mi) {
		menuArgs.value = (XtArgVal) (val);
		XtSetValues (mi, &menuArgs, (Cardinal) 1);
	}
}

#if OPT_TOOLBAR
/*
 * The normal style of xterm popup menu delays initialization until the menu is
 * first requested.  When using a toolbar, we can use the same initialization,
 * though on the first popup there will be a little geometry layout jitter,
 * since the menu is already managed when this callback is invoked.
 */
static void InitPopup (
	Widget gw,
	XtPointer closure GCC_UNUSED,
	XtPointer data GCC_UNUSED)
{
	String params[2];
	Cardinal count = 1;

	params[0] = closure;
	params[1] = 0;
	TRACE(("InitPopup(%s)\n", params[0]));

	domenu(gw, (XEvent *)0, params, &count);

	XtRemoveCallback(gw, XtNpopupCallback, InitPopup, closure);
}

static void SetupShell(Widget *menus, MenuList *shell, Widget *menu_tops, int n, int m)
{
	char temp[80];
	char *external_name = 0;

	shell[n].w = XtVaCreatePopupShell (menu_names[n].internal_name,
			simpleMenuWidgetClass,
			*menus,
			XtNgeometry,		NULL,
			NULL);

	XtAddCallback(shell[n].w, XtNpopupCallback, InitPopup, menu_names[n].internal_name);
	XtVaGetValues(shell[n].w,
			XtNlabel,	&external_name,
			NULL);

	TRACE(("...SetupShell(%s) -> %s -> %#lx\n",
		menu_names[n].internal_name,
		external_name,
		(long)shell[n].w));

	sprintf(temp, "%sButton", menu_names[n].internal_name);
	menu_tops[n] = XtVaCreateManagedWidget (temp,
			menuButtonWidgetClass,
			*menus,
			XtNfromHoriz,	(m >= 0) ? menu_tops[m] : 0,
			XtNmenuName,	menu_names[n].internal_name,
			XtNlabel,	external_name,
			NULL);
}

#endif

void
SetupMenus(Widget shell, Widget *forms, Widget *menus)
{
#if OPT_TOOLBAR
	int n;
	Widget menu_tops[NUM_POPUP_MENUS];
#endif

	TRACE(("SetupMenus(%s)\n", shell == toplevel ? "vt100" : "tek4014"));

	if (shell == toplevel) {
	    XawSimpleMenuAddGlobalActions (app_con);
	    XtRegisterGrabAction (HandlePopupMenu, True,
				  (ButtonPressMask|ButtonReleaseMask),
				  GrabModeAsync, GrabModeAsync);
	}
#if OPT_TOOLBAR
	*forms = XtVaCreateManagedWidget(
				"form",
				formWidgetClass,	shell,
				NULL);
	xtermAddInput(*forms);

	/*
	 * Set a nominal value for the preferred pane size, which lets the
	 * buttons determine the actual height of the menu bar.  We don't show
	 * the grip, because it's too easy to make the toolbar look bad that
	 * way.
	 */
	*menus = XtVaCreateManagedWidget(
				"menubar",
				boxWidgetClass,		*forms,
				XtNorientation,		XtorientHorizontal,
				XtNtop,			XawChainTop,
				XtNbottom,		XawChainTop,
				XtNleft,		XawChainLeft,
				XtNright,		XawChainLeft,
				NULL);

	if (shell == toplevel) {	/* vt100 */
	    for (n = mainMenu; n <= fontMenu; n++) {
		SetupShell(menus, vt_shell, menu_tops, n, n-1);
	    }
	}
#if OPT_TEK4014
	else {			/* tek4014 */
	    SetupShell(menus, tek_shell, menu_tops, mainMenu, -1);
	    SetupShell(menus, tek_shell, menu_tops, tekMenu, mainMenu);
	}
#endif

#else
	*forms = shell;
	*menus = shell;
#endif

	TRACE(("...shell=%#lx\n", (long) shell));
	TRACE(("...forms=%#lx\n", (long) *forms));
	TRACE(("...menus=%#lx\n", (long) *menus));
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d4 1
a4 1
Copyright 1999-2002,2003 by Thomas E. Dickey
d25 1
d49 1
a49 1
/* $XFree86: xc/programs/xterm/menu.c,v 3.53 2003/10/27 01:07:57 dickey Exp $ */
d56 2
a59 4
#define app_con Xaw_app_con	/* quiet a warning from SimpleMenu.h */

#if defined(HAVE_LIB_XAW)

a69 40
#elif defined(HAVE_LIB_XAW3D)

#include <X11/Xaw3d/SimpleMenu.h>
#include <X11/Xaw3d/Box.h>
#include <X11/Xaw3d/SmeBSB.h>
#include <X11/Xaw3d/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/Xaw3d/MenuButton.h>
#include <X11/Xaw3d/Form.h>
#endif

#elif defined(HAVE_LIB_NEXTAW)

#include <X11/neXtaw/SimpleMenu.h>
#include <X11/neXtaw/Box.h>
#include <X11/neXtaw/SmeBSB.h>
#include <X11/neXtaw/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/neXtaw/MenuButton.h>
#include <X11/neXtaw/Form.h>
#endif

#elif defined(HAVE_LIB_XAWPLUS)

#include <X11/XawPlus/SimpleMenu.h>
#include <X11/XawPlus/Box.h>
#include <X11/XawPlus/SmeBSB.h>
#include <X11/XawPlus/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/XawPlus/MenuButton.h>
#include <X11/XawPlus/Form.h>
#endif

#endif

#undef app_con

d72 1
a72 1
/* *INDENT-OFF* */
a92 1
static void do_print_redir     PROTO_XT_CALLBACK_ARGS;
a176 2
    { "redraw",		do_redraw,	NULL },
    { "line1",		NULL,		NULL },
d181 3
a183 3
    { "print-redirect",	do_print_redir,	NULL },
    { "line2",		NULL,		NULL },
    { "8-bit control",	do_8bit_control,NULL },
d201 1
a201 1
    { "line3",		NULL,		NULL },
d208 1
a208 1
    { "line4",		NULL,		NULL },
a304 1
/* *INDENT-ON* */
d325 1
a325 1
select_menu(Widget w GCC_UNUSED, MenuIndex num)
d342 1
a342 1
obtain_menu(Widget w, MenuIndex num)
d351 1
a351 1
sizeof_menu(Widget w, MenuIndex num)
d361 1
a361 1
create_menu(Widget w, XtermWidget xtw, MenuIndex num)
d363 2
a364 6
    static XtCallbackRec cb[2] =
    {
	{NULL, NULL},
	{NULL, NULL}};
    static Arg arg =
    {XtNcallback, (XtArgVal) cb};
d379 3
a381 4
	static unsigned char check_bits[] =
	{
	    0x00, 0x01, 0x80, 0x01, 0xc0, 0x00, 0x60, 0x00,
	    0x31, 0x00, 0x1b, 0x00, 0x0e, 0x00, 0x04, 0x00
d385 3
a387 3
	    XCreateBitmapFromData(XtDisplay(xtw),
				  RootWindowOfScreen(XtScreen(xtw)),
				  (char *) check_bits, check_width, check_height);
d389 1
d396 1
a396 4
    m = XtCreatePopupShell(data->internal_name,
			   simpleMenuWidgetClass,
			   toplevel,
			   NULL, 0);
d404 5
a408 5
	entries->widget = XtCreateManagedWidget(entries->name,
						(entries->function ?
						 smeBSBObjectClass :
						 smeLineObjectClass), m,
						&arg, (Cardinal) 1);
d415 1
a415 2
static MenuIndex
indexOfMenu(String menuName)
d417 1
a417 1
    MenuIndex me;
d434 1
a434 1
	me = noMenu;
d444 5
a448 5
static Bool
domenu(Widget w GCC_UNUSED,
       XEvent * event GCC_UNUSED,
       String * params,		/* mainMenu, vtMenu, or tekMenu */
       Cardinal * param_count)	/* 0 or 1 */
d451 1
a451 1
    MenuIndex me;
d456 1
a456 1
	Bell(XkbBI_MinorError, 0);
d460 2
a461 2
    if ((me = indexOfMenu(params[0])) == noMenu) {
	Bell(XkbBI_MinorError, 0);
d465 3
a467 3
    if ((mw = obtain_menu(w, me)) == 0
	|| sizeof_menu(w, me) == 0) {
	mw = create_menu(w, term, me);
d474 1
a474 1
    case mainMenu:
a478 1
	    update_print_redir();
d486 3
a488 16
		set_sensitivity(mw,
				mainMenuEntries[mainMenu_8bit_ctrl].widget,
				FALSE);
	    }
#if !defined(SIGTSTP)
	    set_sensitivity(mw,
			    mainMenuEntries[mainMenu_suspend].widget, FALSE);
#endif
#if !defined(SIGCONT)
	    set_sensitivity(mw,
			    mainMenuEntries[mainMenu_continue].widget, FALSE);
#endif
#ifdef ALLOWLOGGING
	    if (screen->inhibit & I_LOG) {
		set_sensitivity(mw,
				mainMenuEntries[mainMenu_logging].widget, FALSE);
d490 7
a497 6
	    if (screen->inhibit & I_SIGNAL) {
		int n;
		for (n = (int) mainMenu_suspend; n <= (int) mainMenu_quit; ++n) {
		    set_sensitivity(mw, mainMenuEntries[n].widget, FALSE);
		}
	    }
d501 1
a501 1
    case vtMenu:
d523 5
a527 4
		set_sensitivity(mw,
				vtMenuEntries[vtMenu_activeicon].widget,
				FALSE);
	    } else
a529 8
#if OPT_TEK4014
	    if (screen->inhibit & I_TEK) {
		int n;
		for (n = (int) vtMenu_tekshow; n <= (int) vtMenu_vthide; ++n) {
		    set_sensitivity(mw, vtMenuEntries[n].widget, FALSE);
		}
	    }
#endif
d533 1
a533 1
    case fontMenu:
d535 5
a539 5
	    set_menu_font(True);
	    set_sensitivity(mw,
			    fontMenuEntries[fontMenu_fontescape].widget,
			    (screen->menu_font_names[fontMenu_fontescape]
			     ? TRUE : FALSE));
d542 3
a544 3
	    set_sensitivity(mw,
			    fontMenuEntries[fontMenu_font_boxchars].widget,
			    True);
d546 1
a546 1
#if OPT_DEC_SOFTFONT		/* FIXME: not implemented */
d548 3
a550 3
	    set_sensitivity(mw,
			    fontMenuEntries[fontMenu_font_loadable].widget,
			    FALSE);
d555 1
a555 1
		set_sensitivity(mw,
d560 5
a564 5
	FindFontSelection(NULL, True);
	set_sensitivity(mw,
			fontMenuEntries[fontMenu_fontsel].widget,
			(screen->menu_font_names[fontMenu_fontsel]
			 ? TRUE : FALSE));
d568 1
a568 1
    case tekMenu:
d570 1
a570 1
	    set_tekfont_menu_item(screen->cur.fontsize, TRUE);
a574 2
    default:
	break;
d580 14
a593 5
void
HandleCreateMenu(Widget w,
		 XEvent * event,	/* unused */
		 String * params,	/* mainMenu, vtMenu, or tekMenu */
		 Cardinal * param_count)	/* 0 or 1 */
d595 1
a595 10
    (void) domenu(w, event, params, param_count);
}

void
HandlePopupMenu(Widget w,
		XEvent * event,	/* unused */
		String * params,	/* mainMenu, vtMenu, or tekMenu */
		Cardinal * param_count)		/* 0 or 1 */
{
    if (domenu(w, event, params, param_count)) {
d599 2
a600 2
	XtCallActionProc(w, "XawPositionSimpleMenu", event, params, 1);
	XtCallActionProc(w, "MenuPopup", event, params, 1);
d604 1
d610 1
a610 2
static void
handle_send_signal(Widget gw GCC_UNUSED, int sig)
d615 2
a616 4
    if (hold_screen > 1)
	hold_screen = 0;
    if (screen->pid > 1)
	kill_process_group(screen->pid, sig);
d620 1
d626 1
a626 2
void
DoSecureKeyboard(Time tp GCC_UNUSED)
d628 1
a628 1
    do_securekbd(vt_shell[mainMenu].w, (XtPointer) 0, (XtPointer) 0);
d631 4
a634 4
static void
do_securekbd(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d637 1
a637 1
    Time now = CurrentTime;	/* XXX - wrong */
d640 2
a641 2
	XUngrabKeyboard(screen->display, now);
	ReverseVideo(term);
d644 2
a645 2
	if (XGrabKeyboard(screen->display, XtWindow(term),
			  True, GrabModeAsync, GrabModeAsync, now)
d649 1
a649 1
	    ReverseVideo(term);
d656 5
a660 4
static void
do_allowsends(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
d665 1
a665 1
    update_allowsends();
d668 4
a671 4
static void
do_visualbell(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
d679 4
a682 4
static void
do_poponbell(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d691 4
a694 4
static void
do_logging(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d699 1
a699 1
	CloseLog(screen);
d701 1
a701 1
	StartLog(screen);
d707 4
a710 4
static void
do_print(Widget gw GCC_UNUSED,
	 XtPointer closure GCC_UNUSED,
	 XtPointer data GCC_UNUSED)
d712 1
a712 1
    xtermPrintScreen(TRUE);
d715 5
a719 4
static void
do_print_redir(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
d721 1
a721 1
    setPrinterControlMode(term->screen.printer_controlmode ? 0 : 2);
a723 7
static void
do_redraw(Widget gw GCC_UNUSED,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
{
    Redraw();
}
d725 1
a725 2
void
show_8bit_control(Bool value)
d733 6
a738 6
static void
do_8bit_control(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    show_8bit_control(!term->screen.control_eight_bits);
d741 4
a744 4
static void
do_backarrow(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d751 4
a754 4
static void
do_num_lock(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d756 1
a756 1
    term->misc.real_NumLock = !term->misc.real_NumLock;
d760 4
a763 4
static void
do_meta_esc(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d765 1
a765 1
    term->screen.meta_sends_esc = !term->screen.meta_sends_esc;
d770 4
a773 4
static void
do_delete_del(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
d782 4
a785 4
static void
do_old_fkeys(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d791 4
a794 4
static void
do_hp_fkeys(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d801 4
a804 4
static void
do_sco_fkeys(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d810 4
a813 4
static void
do_sun_fkeys(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d822 4
a825 4
static void
do_sun_kbd(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d836 1
d838 4
a841 4
static void
do_suspend(Widget gw,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d843 2
a844 2
#if defined(SIGTSTP)
    handle_send_signal(gw, SIGTSTP);
d849 4
a852 4
static void
do_continue(Widget gw,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d854 2
a855 2
#if defined(SIGCONT)
    handle_send_signal(gw, SIGCONT);
d860 4
a863 4
static void
do_interrupt(Widget gw,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d865 1
a865 1
    handle_send_signal(gw, SIGINT);
d869 4
a872 4
void
do_hangup(Widget gw,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
d874 1
a874 1
    handle_send_signal(gw, SIGHUP);
d878 4
a881 4
static void
do_terminate(Widget gw,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d883 1
a883 1
    handle_send_signal(gw, SIGTERM);
d887 2
a888 2
static void
do_kill(Widget gw,
d892 1
a892 1
    handle_send_signal(gw, SIGKILL);
d895 2
a896 2
static void
do_quit(Widget gw GCC_UNUSED,
d900 1
a900 1
    Cleanup(0);
d903 2
d909 4
a912 4
static void
do_scrollbar(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d917 5
a921 4
static void
do_jumpscroll(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
d928 1
a928 2
	if (screen->scroll_amt)
	    FlushScroll(screen);
d935 7
a941 6
static void
do_reversevideo(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    ReverseVideo(term);
d944 5
a948 4
static void
do_autowrap(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d954 5
a958 4
static void
do_reversewrap(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
d964 5
a968 4
static void
do_autolinefeed(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
d974 5
a978 4
static void
do_appcursor(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d984 5
a988 4
static void
do_appkeypad(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d994 5
a998 4
static void
do_scrollkey(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d1006 5
a1010 4
static void
do_scrollttyoutput(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
d1018 5
a1022 4
static void
do_allow132(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d1030 5
a1034 4
static void
do_cursesemul(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
d1042 5
a1046 4
static void
do_marginbell(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
d1050 1
a1050 2
    if (!(screen->marginbell = !screen->marginbell))
	screen->bellarmed = -1;
d1054 1
d1056 1
a1056 2
static void
handle_tekshow(Widget gw GCC_UNUSED, Bool allowswitch)
d1060 5
a1064 5
    if (!screen->Tshow) {	/* not showing, turn on */
	set_tek_visibility(TRUE);
    } else if (screen->Vshow || allowswitch) {	/* is showing, turn off */
	set_tek_visibility(FALSE);
	end_tek_mode();		/* WARNING: this does a longjmp */
d1066 1
a1066 1
	Bell(XkbBI_MinorError, 0);
d1070 4
a1073 4
static void
do_tekshow(Widget gw,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d1075 1
a1075 1
    handle_tekshow(gw, True);
d1079 4
a1082 4
static void
do_tekonoff(Widget gw,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d1084 1
a1084 1
    handle_tekshow(gw, False);
d1090 4
a1093 4
static void
do_cursorblink(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
d1101 4
a1104 4
static void
do_altscreen(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d1111 4
a1114 4
static void
do_titeInhibit(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
d1122 4
a1125 4
static void
do_activeicon(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
d1134 1
a1134 1
		      (XtPointer) 0);
d1140 4
a1143 4
static void
do_softreset(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d1145 1
a1145 1
    VTReset(FALSE, FALSE);
d1148 5
a1152 4
static void
do_hardreset(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d1154 1
a1154 1
    VTReset(TRUE, FALSE);
d1157 5
a1161 4
static void
do_clearsavedlines(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
d1163 1
a1163 1
    VTReset(TRUE, TRUE);
d1166 1
d1168 4
a1171 4
static void
do_tekmode(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d1175 1
a1175 1
    switch_modes(screen->TekEmu);	/* switch to tek mode */
d1179 4
a1182 4
static void
do_vthide(Widget gw GCC_UNUSED,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
d1188 1
d1193 4
a1196 4
static void
do_vtfont(Widget gw GCC_UNUSED,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
d1202 2
a1203 2
	if (strcmp(entryname, fontMenuEntries[i].name) == 0) {
	    SetVTFont(i, True, NULL);
d1211 4
a1214 4
static void
do_font_doublesize(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
d1217 1
a1217 1
	term->screen.font_doublesize = !term->screen.font_doublesize;
d1219 1
a1219 1
    Redraw();
d1224 4
a1227 4
static void
do_font_boxchars(Widget gw GCC_UNUSED,
		 XtPointer closure GCC_UNUSED,
		 XtPointer data GCC_UNUSED)
d1229 1
a1229 1
    term->screen.force_box_chars = !term->screen.force_box_chars;
d1231 1
a1231 1
    Redraw();
d1236 4
a1239 4
static void
do_font_loadable(Widget gw GCC_UNUSED,
		 XtPointer closure GCC_UNUSED,
		 XtPointer data GCC_UNUSED)
d1241 1
a1241 1
    term->misc.font_loadable = !term->misc.font_loadable;
d1246 1
d1252 4
a1255 4
static void
do_tektextlarge(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
d1257 1
a1257 1
    TekSetFontSize(tekMenu_tektextlarge);
d1260 5
a1264 4
static void
do_tektext2(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d1266 1
a1266 1
    TekSetFontSize(tekMenu_tektext2);
d1269 5
a1273 4
static void
do_tektext3(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d1275 1
a1275 1
    TekSetFontSize(tekMenu_tektext3);
d1278 5
a1282 4
static void
do_tektextsmall(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
d1285 1
a1285 1
    TekSetFontSize(tekMenu_tektextsmall);
d1288 5
a1292 4
static void
do_tekpage(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d1294 1
a1294 1
    TekSimulatePageButton(False);
d1297 5
a1301 4
static void
do_tekreset(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d1303 1
a1303 1
    TekSimulatePageButton(True);
d1306 5
a1310 4
static void
do_tekcopy(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d1312 1
a1312 1
    TekCopy();
d1315 2
a1316 2
static void
handle_vtshow(Widget gw GCC_UNUSED, Bool allowswitch)
d1320 6
a1325 7
    if (!screen->Vshow) {	/* not showing, turn on */
	set_vt_visibility(TRUE);
    } else if (screen->Tshow || allowswitch) {	/* is showing, turn off */
	set_vt_visibility(FALSE);
	if (!screen->TekEmu && TekRefresh)
	    dorefresh();
	end_vt_mode();		/* WARNING: this does a longjmp... */
d1327 1
a1327 1
	Bell(XkbBI_MinorError, 0);
d1330 4
a1333 4
static void
do_vtshow(Widget gw,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
d1335 1
a1335 1
    handle_vtshow(gw, True);
d1338 4
a1341 4
static void
do_vtonoff(Widget gw,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d1343 1
a1343 1
    handle_vtshow(gw, False);
d1346 4
a1349 4
static void
do_vtmode(Widget gw GCC_UNUSED,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
d1353 1
a1353 1
    switch_modes(screen->TekEmu);	/* switch to vt, or from */
d1356 1
d1358 4
a1361 4
static void
do_tekhide(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d1367 2
d1373 8
a1380 8
static void
handle_toggle(void (*proc) PROTO_XT_CALLBACK_ARGS,
	      int var,
	      String * params,
	      Cardinal nparams,
	      Widget w,
	      XtPointer closure,
	      XtPointer data)
d1385 1
a1385 1
    case 0:
d1388 4
a1391 7
    case 1:
	if (XmuCompareISOLatin1(params[0], "on") == 0)
	    dir = 1;
	else if (XmuCompareISOLatin1(params[0], "off") == 0)
	    dir = 0;
	else if (XmuCompareISOLatin1(params[0], "toggle") == 0)
	    dir = -1;
d1396 1
a1396 1
    case -2:
d1400 1
a1400 1
    case -1:
d1404 3
a1406 5
    case 0:
	if (var)
	    (*proc) (w, closure, data);
	else
	    Bell(XkbBI_MinorError, 0);
d1409 3
a1411 5
    case 1:
	if (!var)
	    (*proc) (w, closure, data);
	else
	    Bell(XkbBI_MinorError, 0);
d1417 25
a1441 15
void
HandleAllowSends(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal * param_count)
{
    handle_toggle(do_allowsends, (int) term->screen.allowSendEvents,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleSetVisualBell(Widget w,
		    XEvent * event GCC_UNUSED,
		    String * params,
		    Cardinal * param_count)
d1443 2
a1444 12
    handle_toggle(do_visualbell, (int) term->screen.visualbell,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleSetPopOnBell(Widget w,
		   XEvent * event GCC_UNUSED,
		   String * params,
		   Cardinal * param_count)
{
    handle_toggle(do_poponbell, (int) term->screen.poponbell,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1448 5
a1452 5
void
HandleLogging(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params,
	      Cardinal * param_count)
d1454 2
a1455 2
    handle_toggle(do_logging, (int) term->screen.logging,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1460 5
a1464 15
void
HandlePrintScreen(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params GCC_UNUSED,
		  Cardinal * param_count GCC_UNUSED)
{
    do_print(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandlePrintControlMode(Widget w,
		       XEvent * event GCC_UNUSED,
		       String * params GCC_UNUSED,
		       Cardinal * param_count GCC_UNUSED)
d1466 1
a1466 1
    do_print_redir(w, (XtPointer) 0, (XtPointer) 0);
d1470 5
a1474 5
void
HandleRedraw(Widget w,
	     XEvent * event GCC_UNUSED,
	     String * params GCC_UNUSED,
	     Cardinal * param_count GCC_UNUSED)
d1476 1
a1476 1
    do_redraw(w, (XtPointer) 0, (XtPointer) 0);
d1480 5
a1484 5
void
HandleSendSignal(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal * param_count)
a1485 1
    /* *INDENT-OFF* */
a1505 1
    /* *INDENT-ON* */
d1511 2
a1512 2
	    if (XmuCompareISOLatin1(st->name, params[0]) == 0) {
		handle_send_signal(w, st->sig);
d1523 5
a1527 5
void
HandleQuit(Widget w,
	   XEvent * event GCC_UNUSED,
	   String * params GCC_UNUSED,
	   Cardinal * param_count GCC_UNUSED)
d1529 1
a1529 1
    do_quit(w, (XtPointer) 0, (XtPointer) 0);
d1532 5
a1536 5
void
Handle8BitControl(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal * param_count)
d1538 2
a1539 2
    handle_toggle(do_8bit_control, (int) term->screen.control_eight_bits,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1542 5
a1546 5
void
HandleBackarrow(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal * param_count)
d1548 2
a1549 2
    handle_toggle(do_backarrow, (int) term->keyboard.flags & MODE_DECBKM,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1552 5
a1556 5
void
HandleSunFunctionKeys(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params,
		      Cardinal * param_count)
d1558 2
a1559 2
    handle_toggle(do_sun_fkeys, term->keyboard.type == keyboardIsSun,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1563 5
a1567 5
void
HandleNumLock(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params,
	      Cardinal * param_count)
d1569 2
a1570 2
    handle_toggle(do_num_lock, (int) term->misc.real_NumLock,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1573 5
a1577 5
void
HandleMetaEsc(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params,
	      Cardinal * param_count)
d1579 2
a1580 2
    handle_toggle(do_meta_esc, (int) term->screen.meta_sends_esc,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1584 5
a1588 5
void
HandleDeleteIsDEL(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal * param_count)
d1590 2
a1591 2
    handle_toggle(do_delete_del, term->screen.delete_is_del,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1594 5
a1598 5
void
HandleOldFunctionKeys(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params,
		      Cardinal * param_count)
d1600 2
a1601 2
    handle_toggle(do_old_fkeys, term->keyboard.type == keyboardIsLegacy,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1605 5
a1609 5
void
HandleSunKeyboard(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal * param_count)
d1611 2
a1612 2
    handle_toggle(do_sun_kbd, term->keyboard.type == keyboardIsVT220,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1617 5
a1621 5
void
HandleHpFunctionKeys(Widget w,
		     XEvent * event GCC_UNUSED,
		     String * params,
		     Cardinal * param_count)
d1623 2
a1624 2
    handle_toggle(do_hp_fkeys, term->keyboard.type == keyboardIsHP,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1629 5
a1633 5
void
HandleScoFunctionKeys(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params,
		      Cardinal * param_count)
d1635 2
a1636 2
    handle_toggle(do_sco_fkeys, term->keyboard.type == keyboardIsSCO,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1640 5
a1644 5
void
HandleScrollbar(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal * param_count)
d1646 2
a1647 2
    handle_toggle(do_scrollbar, (int) term->screen.fullVwin.sb_info.width,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1650 5
a1654 5
void
HandleJumpscroll(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal * param_count)
d1656 2
a1657 2
    handle_toggle(do_jumpscroll, (int) term->screen.jumpscroll,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1660 5
a1664 5
void
HandleReverseVideo(Widget w,
		   XEvent * event GCC_UNUSED,
		   String * params,
		   Cardinal * param_count)
d1666 2
a1667 2
    handle_toggle(do_reversevideo, (int) (term->misc.re_verse0),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1670 5
a1674 5
void
HandleAutoWrap(Widget w,
	       XEvent * event GCC_UNUSED,
	       String * params,
	       Cardinal * param_count)
d1676 2
a1677 2
    handle_toggle(do_autowrap, (int) (term->flags & WRAPAROUND),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1680 5
a1684 5
void
HandleReverseWrap(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal * param_count)
d1686 2
a1687 2
    handle_toggle(do_reversewrap, (int) (term->flags & REVERSEWRAP),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1690 5
a1694 5
void
HandleAutoLineFeed(Widget w,
		   XEvent * event GCC_UNUSED,
		   String * params,
		   Cardinal * param_count)
d1696 2
a1697 2
    handle_toggle(do_autolinefeed, (int) (term->flags & LINEFEED),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1700 5
a1704 5
void
HandleAppCursor(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal * param_count)
d1706 2
a1707 2
    handle_toggle(do_appcursor, (int) (term->keyboard.flags & MODE_DECCKM),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1710 5
a1714 5
void
HandleAppKeypad(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal * param_count)
d1716 2
a1717 2
    handle_toggle(do_appkeypad, (int) (term->keyboard.flags & MODE_DECKPAM),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1720 5
a1724 5
void
HandleScrollKey(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal * param_count)
d1726 2
a1727 2
    handle_toggle(do_scrollkey, (int) term->screen.scrollkey,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1730 5
a1734 5
void
HandleScrollTtyOutput(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params,
		      Cardinal * param_count)
d1736 2
a1737 2
    handle_toggle(do_scrollttyoutput, (int) term->screen.scrollttyoutput,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1740 5
a1744 5
void
HandleAllow132(Widget w,
	       XEvent * event GCC_UNUSED,
	       String * params,
	       Cardinal * param_count)
d1746 2
a1747 2
    handle_toggle(do_allow132, (int) term->screen.c132,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1750 5
a1754 5
void
HandleCursesEmul(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal * param_count)
d1756 2
a1757 2
    handle_toggle(do_cursesemul, (int) term->screen.curses,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1760 5
a1764 5
void
HandleMarginBell(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal * param_count)
d1766 2
a1767 2
    handle_toggle(do_marginbell, (int) term->screen.marginbell,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1771 5
a1775 5
void
HandleCursorBlink(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal * param_count)
d1778 2
a1779 2
    handle_toggle(do_cursorblink, (int) term->screen.cursor_blink,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1783 5
a1787 5
void
HandleAltScreen(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal * param_count)
d1790 2
a1791 2
    handle_toggle(do_altscreen, (int) term->screen.alternate,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1794 5
a1798 5
void
HandleTiteInhibit(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal * param_count)
d1801 2
a1802 2
    handle_toggle(do_titeInhibit, !((int) term->misc.titeInhibit),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1806 5
a1810 5
void
HandleSoftReset(Widget w,
		XEvent * event GCC_UNUSED,
		String * params GCC_UNUSED,
		Cardinal * param_count GCC_UNUSED)
d1812 1
a1812 1
    do_softreset(w, (XtPointer) 0, (XtPointer) 0);
d1816 5
a1820 5
void
HandleHardReset(Widget w,
		XEvent * event GCC_UNUSED,
		String * params GCC_UNUSED,
		Cardinal * param_count GCC_UNUSED)
d1822 1
a1822 1
    do_hardreset(w, (XtPointer) 0, (XtPointer) 0);
d1826 5
a1830 5
void
HandleClearSavedLines(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params GCC_UNUSED,
		      Cardinal * param_count GCC_UNUSED)
d1832 1
a1832 1
    do_clearsavedlines(w, (XtPointer) 0, (XtPointer) 0);
d1836 5
a1840 5
void
HandleFontDoublesize(Widget w,
		     XEvent * event GCC_UNUSED,
		     String * params,
		     Cardinal * param_count)
d1842 2
a1843 2
    handle_toggle(do_font_doublesize, (int) term->screen.font_doublesize,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1848 5
a1852 5
void
HandleFontBoxChars(Widget w,
		   XEvent * event GCC_UNUSED,
		   String * params,
		   Cardinal * param_count)
d1854 2
a1855 2
    handle_toggle(do_font_boxchars, (int) term->screen.force_box_chars,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1860 5
a1864 5
void
HandleFontLoading(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal * param_count)
d1866 2
a1867 2
    handle_toggle(do_font_loadable, (int) term->misc.font_loadable,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1872 5
a1876 5
void
HandleSetTerminalType(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params,
		      Cardinal * param_count)
d1880 2
a1881 4
	case 'v':
	case 'V':
	    if (term->screen.TekEmu)
		do_vtmode(w, (XtPointer) 0, (XtPointer) 0);
d1883 2
a1884 4
	case 't':
	case 'T':
	    if (!term->screen.TekEmu)
		do_tekmode(w, (XtPointer) 0, (XtPointer) 0);
d1886 1
a1886 1
	default:
d1894 5
a1898 5
void
HandleVisibility(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal * param_count)
d1902 3
a1904 5
	case 'v':
	case 'V':
	    handle_toggle(do_vtonoff, (int) term->screen.Vshow,
			  params + 1, (*param_count) - 1,
			  w, (XtPointer) 0, (XtPointer) 0);
d1906 3
a1908 5
	case 't':
	case 'T':
	    handle_toggle(do_tekonoff, (int) term->screen.Tshow,
			  params + 1, (*param_count) - 1,
			  w, (XtPointer) 0, (XtPointer) 0);
d1910 1
a1910 1
	default:
d1919 5
a1923 5
void
HandleSetTekText(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal * param_count)
d1925 1
a1925 1
    void (*proc) PROTO_XT_CALLBACK_ARGS = 0;
d1928 1
a1928 1
    case 0:
d1931 1
a1931 1
    case 1:
d1933 4
a1936 14
	case 'l':
	case 'L':
	    proc = do_tektextlarge;
	    break;
	case '2':
	    proc = do_tektext2;
	    break;
	case '3':
	    proc = do_tektext3;
	    break;
	case 's':
	case 'S':
	    proc = do_tektextsmall;
	    break;
d1940 2
a1941 4
    if (proc)
	(*proc) (w, (XtPointer) 0, (XtPointer) 0);
    else
	Bell(XkbBI_MinorError, 0);
d1945 5
a1949 5
void
HandleTekPage(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params GCC_UNUSED,
	      Cardinal * param_count GCC_UNUSED)
d1951 1
a1951 1
    do_tekpage(w, (XtPointer) 0, (XtPointer) 0);
d1955 5
a1959 5
void
HandleTekReset(Widget w,
	       XEvent * event GCC_UNUSED,
	       String * params GCC_UNUSED,
	       Cardinal * param_count GCC_UNUSED)
d1961 1
a1961 1
    do_tekreset(w, (XtPointer) 0, (XtPointer) 0);
d1965 5
a1969 5
void
HandleTekCopy(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params GCC_UNUSED,
	      Cardinal * param_count GCC_UNUSED)
d1971 1
a1971 1
    do_tekcopy(w, (XtPointer) 0, (XtPointer) 0);
d1978 1
a1978 2
    static Arg menuArgs =
    {XtNleftBitmap, (XtArgVal) 0};
d1980 6
a1985 6
    if (mi) {
	menuArgs.value = (XtArgVal) ((val)
				     ? term->screen.menu_item_bitmap
				     : None);
	XtSetValues(mi, &menuArgs, (Cardinal) 1);
    }
d1991 1
a1991 2
    static Arg menuArgs =
    {XtNsensitive, (XtArgVal) 0};
d1993 4
a1996 4
    if (mi) {
	menuArgs.value = (XtArgVal) (val);
	XtSetValues(mi, &menuArgs, (Cardinal) 1);
    }
d2006 4
a2009 55
static void
InitPopup(Widget gw,
	  XtPointer closure,
	  XtPointer data GCC_UNUSED)
{
    String params[2];
    Cardinal count = 1;

    params[0] = closure;
    params[1] = 0;
    TRACE(("InitPopup(%s)\n", params[0]));

    domenu(gw, (XEvent *) 0, params, &count);

    XtRemoveCallback(gw, XtNpopupCallback, InitPopup, closure);
}

static void
SetupShell(Widget * menus, MenuList * shell, Widget * menu_tops, int n, int m)
{
    char temp[80];
    char *external_name = 0;

    shell[n].w = XtVaCreatePopupShell(menu_names[n].internal_name,
				      simpleMenuWidgetClass,
				      *menus,
				      XtNgeometry, NULL,
				      (XtPointer) 0);

    XtAddCallback(shell[n].w, XtNpopupCallback, InitPopup, menu_names[n].internal_name);
    XtVaGetValues(shell[n].w,
		  XtNlabel, &external_name,
		  (XtPointer) 0);

    TRACE(("...SetupShell(%s) -> %s -> %#lx\n",
	   menu_names[n].internal_name,
	   external_name,
	   (long) shell[n].w));

    sprintf(temp, "%sButton", menu_names[n].internal_name);
    menu_tops[n] = XtVaCreateManagedWidget(temp,
					   menuButtonWidgetClass,
					   *menus,
					   XtNfromHoriz, ((m >= 0)
							  ? menu_tops[m]
							  : 0),
					   XtNmenuName, menu_names[n].internal_name,
					   XtNlabel, external_name,
					   (XtPointer) 0);
}

#endif

void
SetupMenus(Widget shell, Widget * forms, Widget * menus)
d2011 2
a2012 4
#if OPT_TOOLBAR
    int n;
    Widget menu_tops[NUM_POPUP_MENUS];
#endif
d2014 3
a2016 1
    TRACE(("SetupMenus(%s)\n", shell == toplevel ? "vt100" : "tek4014"));
d2018 1
a2018 38
    if (shell == toplevel) {
	XawSimpleMenuAddGlobalActions(app_con);
	XtRegisterGrabAction(HandlePopupMenu, True,
			     (ButtonPressMask | ButtonReleaseMask),
			     GrabModeAsync, GrabModeAsync);
    }
#if OPT_TOOLBAR
    *forms = XtVaCreateManagedWidget("form",
				     formWidgetClass, shell,
				     (XtPointer) 0);
    xtermAddInput(*forms);

    /*
     * Set a nominal value for the preferred pane size, which lets the
     * buttons determine the actual height of the menu bar.  We don't show
     * the grip, because it's too easy to make the toolbar look bad that
     * way.
     */
    *menus = XtVaCreateManagedWidget("menubar",
				     boxWidgetClass, *forms,
				     XtNorientation, XtorientHorizontal,
				     XtNtop, XawChainTop,
				     XtNbottom, XawChainTop,
				     XtNleft, XawChainLeft,
				     XtNright, XawChainLeft,
				     (XtPointer) 0);

    if (shell == toplevel) {	/* vt100 */
	for (n = mainMenu; n <= fontMenu; n++) {
	    SetupShell(menus, vt_shell, menu_tops, n, n - 1);
	}
    }
#if OPT_TEK4014
    else {			/* tek4014 */
	SetupShell(menus, tek_shell, menu_tops, mainMenu, -1);
	SetupShell(menus, tek_shell, menu_tops, tekMenu, mainMenu);
    }
#endif
d2020 1
a2020 8
#else
    *forms = shell;
    *menus = shell;
#endif

    TRACE(("...shell=%#lx\n", (long) shell));
    TRACE(("...forms=%#lx\n", (long) *forms));
    TRACE(("...menus=%#lx\n", (long) *menus));
d2023 1
a2023 2
void
update_securekbd(void)
d2025 2
a2026 4
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_securekbd].widget,
		     term->screen.grabbedKbd);
}
d2028 5
a2032 7
void
update_allowsends(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_allowsends].widget,
		     term->screen.allowSendEvents);
}
d2034 4
a2037 17
#ifdef ALLOWLOGGING
void
update_logging(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_logging].widget,
		     term->screen.logging);
}
#endif

void
update_print_redir(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_print_redir].widget,
		     term->screen.printer_controlmode);
}
d2039 4
a2042 7
void
update_8bit_control(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_8bit_ctrl].widget,
		     term->screen.control_eight_bits);
}
d2044 8
a2051 6
void
update_decbkm(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_backarrow].widget,
		     term->keyboard.flags & MODE_DECBKM);
a2053 16
#if OPT_NUM_LOCK
void
update_num_lock(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_num_lock].widget,
		     term->misc.real_NumLock);
}

void
update_meta_esc(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_meta_esc].widget,
		     term->screen.meta_sends_esc);
}
d2057 1
a2057 1
update_sun_fkeys(void)
d2059 3
a2061 29
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_sun_fkeys].widget,
		     term->keyboard.type == keyboardIsSun);
}

void
update_old_fkeys(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_old_fkeys].widget,
		     term->keyboard.type == keyboardIsLegacy);
}

void
update_delete_del(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_delete_del].widget,
		     xtermDeleteIsDEL());
}

#if OPT_SUNPC_KBD
void
update_sun_kbd(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_sun_kbd].widget,
		     term->keyboard.type == keyboardIsVT220);
}
d2064 1
a2064 9
#if OPT_HP_FUNC_KEYS
void
update_hp_fkeys(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_hp_fkeys].widget,
		     term->keyboard.type == keyboardIsHP);
}
#endif
d2066 12
a2077 9
#if OPT_SCO_FUNC_KEYS
void
update_sco_fkeys(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_sco_fkeys].widget,
		     term->keyboard.type == keyboardIsSCO);
}
#endif
d2079 26
a2104 128
void
update_scrollbar(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_scrollbar].widget,
		     ScrollbarWidth(&term->screen));
}

void
update_jumpscroll(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_jumpscroll].widget,
		     term->screen.jumpscroll);
}

void
update_reversevideo(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_reversevideo].widget,
		     (term->misc.re_verse));
}

void
update_autowrap(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_autowrap].widget,
		     (term->flags & WRAPAROUND));
}

void
update_reversewrap(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_reversewrap].widget,
		     (term->flags & REVERSEWRAP));
}

void
update_autolinefeed(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_autolinefeed].widget,
		     (term->flags & LINEFEED));
}

void
update_appcursor(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_appcursor].widget,
		     (term->keyboard.flags & MODE_DECCKM));
}

void
update_appkeypad(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_appkeypad].widget,
		     (term->keyboard.flags & MODE_DECKPAM));
}

void
update_scrollkey(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_scrollkey].widget,
		     term->screen.scrollkey);
}

void
update_scrollttyoutput(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_scrollttyoutput].widget,
		     term->screen.scrollttyoutput);
}

void
update_allow132(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_allow132].widget,
		     term->screen.c132);
}

void
update_cursesemul(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_cursesemul].widget,
		     term->screen.curses);
}

void
update_visualbell(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_visualbell].widget,
		     term->screen.visualbell);
}

void
update_poponbell(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_poponbell].widget,
		     term->screen.poponbell);
}

void
update_marginbell(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_marginbell].widget,
		     term->screen.marginbell);
}

#if OPT_BLINK_CURS
void
update_cursorblink(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_cursorblink].widget,
		     term->screen.cursor_blink);
}
d2107 3
a2109 34
void
update_altscreen(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_altscreen].widget,
		     term->screen.alternate);
}

void
update_titeInhibit(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_titeInhibit].widget,
		     !(term->misc.titeInhibit));
}

#ifndef NO_ACTIVE_ICON
void
update_activeicon(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_activeicon].widget,
		     term->misc.active_icon);
}
#endif /* NO_ACTIVE_ICON */

#if OPT_DEC_CHRSET
void
update_font_doublesize(void)
{
    update_menu_item(term->screen.fontMenu,
		     fontMenuEntries[fontMenu_font_doublesize].widget,
		     term->screen.font_doublesize);
}
d2112 3
a2114 91
#if OPT_BOX_CHARS
void
update_font_boxchars(void)
{
    update_menu_item(term->screen.fontMenu,
		     fontMenuEntries[fontMenu_font_boxchars].widget,
		     term->screen.force_box_chars);
}
#endif

#if OPT_DEC_SOFTFONT
void
update_font_loadable(void)
{
    update_menu_item(term->screen.fontMenu,
		     fontMenuEntries[fontMenu_font_loadable].widget,
		     term->misc.font_loadable);
}
#endif

#if OPT_TEK4014
void
update_tekshow(void)
{
    if (!(term->screen.inhibit & I_TEK)) {
	update_menu_item(term->screen.vtMenu,
			 vtMenuEntries[vtMenu_tekshow].widget,
			 term->screen.Tshow);
    }
}

void
update_vttekmode(void)
{
    if (!(term->screen.inhibit & I_TEK)) {
	update_menu_item(term->screen.vtMenu,
			 vtMenuEntries[vtMenu_tekmode].widget,
			 term->screen.TekEmu);
	update_menu_item(term->screen.tekMenu,
			 tekMenuEntries[tekMenu_vtmode].widget,
			 !term->screen.TekEmu);
    }
}

void
update_vtshow(void)
{
    if (!(term->screen.inhibit & I_TEK)) {
	update_menu_item(term->screen.tekMenu,
			 tekMenuEntries[tekMenu_vtshow].widget,
			 term->screen.Vshow);
    }
}

void
set_vthide_sensitivity(void)
{
    if (!(term->screen.inhibit & I_TEK)) {
	set_sensitivity(term->screen.vtMenu,
			vtMenuEntries[vtMenu_vthide].widget,
			term->screen.Tshow);
    }
}

void
set_tekhide_sensitivity(void)
{
    if (!(term->screen.inhibit & I_TEK)) {
	set_sensitivity(term->screen.tekMenu,
			tekMenuEntries[tekMenu_tekhide].widget,
			term->screen.Vshow);
    }
}

void
set_tekfont_menu_item(int n, int val)
{
    if (!(term->screen.inhibit & I_TEK)) {
	update_menu_item(term->screen.tekMenu,
			 tekMenuEntries[FS2MI(n)].widget,
			 (val));
    }
}
#endif /* OPT_TEK4014 */

void
set_menu_font(int val)
{
    update_menu_item(term->screen.fontMenu,
		     fontMenuEntries[term->screen.menu_font_number].widget,
		     (val));
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d4 1
a4 1
Copyright 1999-2001,2002 by Thomas E. Dickey
d25 1
d49 1
a49 1
/* $XFree86: xc/programs/xterm/menu.c,v 3.49 2002/10/05 17:57:12 dickey Exp $ */
d56 2
a59 2
#if defined(HAVE_LIB_XAW)

a69 26
#elif defined(HAVE_LIB_XAW3D)

#include <X11/Xaw3d/SimpleMenu.h>
#include <X11/Xaw3d/Box.h>
#include <X11/Xaw3d/SmeBSB.h>
#include <X11/Xaw3d/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/Xaw3d/MenuButton.h>
#include <X11/Xaw3d/Form.h>
#endif

#elif defined(HAVE_LIB_NEXTAW)

#include <X11/neXtaw/SimpleMenu.h>
#include <X11/neXtaw/Box.h>
#include <X11/neXtaw/SmeBSB.h>
#include <X11/neXtaw/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/neXtaw/MenuButton.h>
#include <X11/neXtaw/Form.h>
#endif

#endif

d72 1
a72 1
/* *INDENT-OFF* */
a92 1
static void do_print_redir     PROTO_XT_CALLBACK_ARGS;
a176 2
    { "redraw",		do_redraw,	NULL },
    { "line1",		NULL,		NULL },
d181 3
a183 3
    { "print-redirect",	do_print_redir,	NULL },
    { "line2",		NULL,		NULL },
    { "8-bit control",	do_8bit_control,NULL },
d201 1
a201 1
    { "line3",		NULL,		NULL },
d208 1
a208 1
    { "line4",		NULL,		NULL },
a304 1
/* *INDENT-ON* */
d325 1
a325 1
select_menu(Widget w GCC_UNUSED, MenuIndex num)
d342 1
a342 1
obtain_menu(Widget w, MenuIndex num)
d351 1
a351 1
sizeof_menu(Widget w, MenuIndex num)
d361 1
a361 1
create_menu(Widget w, XtermWidget xtw, MenuIndex num)
d363 2
a364 6
    static XtCallbackRec cb[2] =
    {
	{NULL, NULL},
	{NULL, NULL}};
    static Arg arg =
    {XtNcallback, (XtArgVal) cb};
d379 3
a381 4
	static unsigned char check_bits[] =
	{
	    0x00, 0x01, 0x80, 0x01, 0xc0, 0x00, 0x60, 0x00,
	    0x31, 0x00, 0x1b, 0x00, 0x0e, 0x00, 0x04, 0x00
d385 3
a387 3
	    XCreateBitmapFromData(XtDisplay(xtw),
				  RootWindowOfScreen(XtScreen(xtw)),
				  (char *) check_bits, check_width, check_height);
d389 1
d396 1
a396 4
    m = XtCreatePopupShell(data->internal_name,
			   simpleMenuWidgetClass,
			   toplevel,
			   NULL, 0);
d404 5
a408 5
	entries->widget = XtCreateManagedWidget(entries->name,
						(entries->function ?
						 smeBSBObjectClass :
						 smeLineObjectClass), m,
						&arg, (Cardinal) 1);
d415 1
a415 2
static int
indexOfMenu(String menuName)
d444 5
a448 5
static Bool
domenu(Widget w GCC_UNUSED,
       XEvent * event GCC_UNUSED,
       String * params,		/* mainMenu, vtMenu, or tekMenu */
       Cardinal * param_count)	/* 0 or 1 */
d456 1
a456 1
	Bell(XkbBI_MinorError, 0);
d461 1
a461 1
	Bell(XkbBI_MinorError, 0);
d466 2
a467 2
	|| sizeof_menu(w, me) == 0) {
	mw = create_menu(w, term, (MenuIndex) me);
d474 1
a474 1
    case mainMenu:
a478 1
	    update_print_redir();
d486 3
a488 3
		set_sensitivity(mw,
				mainMenuEntries[mainMenu_8bit_ctrl].widget,
				FALSE);
d490 7
a496 7
#if !defined(SIGTSTP)
	    set_sensitivity(mw,
			    mainMenuEntries[mainMenu_suspend].widget, FALSE);
#endif
#if !defined(SIGCONT)
	    set_sensitivity(mw,
			    mainMenuEntries[mainMenu_continue].widget, FALSE);
d501 1
a501 1
    case vtMenu:
d523 5
a527 4
		set_sensitivity(mw,
				vtMenuEntries[vtMenu_activeicon].widget,
				FALSE);
	    } else
d533 1
a533 1
    case fontMenu:
d535 5
a539 5
	    set_menu_font(True);
	    set_sensitivity(mw,
			    fontMenuEntries[fontMenu_fontescape].widget,
			    (screen->menu_font_names[fontMenu_fontescape]
			     ? TRUE : FALSE));
d542 3
a544 3
	    set_sensitivity(mw,
			    fontMenuEntries[fontMenu_font_boxchars].widget,
			    True);
d546 1
a546 1
#if OPT_DEC_SOFTFONT		/* FIXME: not implemented */
d548 3
a550 3
	    set_sensitivity(mw,
			    fontMenuEntries[fontMenu_font_loadable].widget,
			    FALSE);
d555 1
a555 1
		set_sensitivity(mw,
d560 5
a564 5
	FindFontSelection(NULL, True);
	set_sensitivity(mw,
			fontMenuEntries[fontMenu_fontsel].widget,
			(screen->menu_font_names[fontMenu_fontsel]
			 ? TRUE : FALSE));
d568 1
a568 1
    case tekMenu:
d570 1
a570 1
	    set_tekfont_menu_item(screen->cur.fontsize, TRUE);
d580 14
a593 14
void
HandleCreateMenu(Widget w,
		 XEvent * event,	/* unused */
		 String * params,	/* mainMenu, vtMenu, or tekMenu */
		 Cardinal * param_count)	/* 0 or 1 */
{
    (void) domenu(w, event, params, param_count);
}

void
HandlePopupMenu(Widget w,
		XEvent * event,	/* unused */
		String * params,	/* mainMenu, vtMenu, or tekMenu */
		Cardinal * param_count)		/* 0 or 1 */
d595 1
a595 1
    if (domenu(w, event, params, param_count)) {
d599 2
a600 2
	XtCallActionProc(w, "XawPositionSimpleMenu", event, params, 1);
	XtCallActionProc(w, "MenuPopup", event, params, 1);
d604 1
d610 1
a610 2
static void
handle_send_signal(Widget gw GCC_UNUSED, int sig)
d615 2
a616 4
    if (hold_screen > 1)
	hold_screen = 0;
    if (screen->pid > 1)
	kill_process_group(screen->pid, sig);
d620 1
d626 1
a626 2
void
DoSecureKeyboard(Time tp GCC_UNUSED)
d628 1
a628 1
    do_securekbd(vt_shell[mainMenu].w, (XtPointer) 0, (XtPointer) 0);
d631 4
a634 4
static void
do_securekbd(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d637 1
a637 1
    Time now = CurrentTime;	/* XXX - wrong */
d640 2
a641 2
	XUngrabKeyboard(screen->display, now);
	ReverseVideo(term);
d644 2
a645 2
	if (XGrabKeyboard(screen->display, XtWindow(term),
			  True, GrabModeAsync, GrabModeAsync, now)
d649 1
a649 1
	    ReverseVideo(term);
d656 5
a660 4
static void
do_allowsends(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
d665 1
a665 1
    update_allowsends();
d668 4
a671 4
static void
do_visualbell(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
d679 4
a682 4
static void
do_poponbell(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d691 4
a694 4
static void
do_logging(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d699 1
a699 1
	CloseLog(screen);
d701 1
a701 1
	StartLog(screen);
d707 4
a710 4
static void
do_print(Widget gw GCC_UNUSED,
	 XtPointer closure GCC_UNUSED,
	 XtPointer data GCC_UNUSED)
d712 1
a712 1
    xtermPrintScreen(TRUE);
d715 5
a719 4
static void
do_print_redir(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
d721 1
a721 1
    setPrinterControlMode(term->screen.printer_controlmode ? 0 : 2);
a723 7
static void
do_redraw(Widget gw GCC_UNUSED,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
{
    Redraw();
}
d725 1
a725 2
void
show_8bit_control(Bool value)
d733 6
a738 6
static void
do_8bit_control(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    show_8bit_control(!term->screen.control_eight_bits);
d741 4
a744 4
static void
do_backarrow(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d751 4
a754 4
static void
do_num_lock(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d756 1
a756 1
    term->misc.real_NumLock = !term->misc.real_NumLock;
d760 4
a763 4
static void
do_meta_esc(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d765 1
a765 1
    term->screen.meta_sends_esc = !term->screen.meta_sends_esc;
d770 4
a773 4
static void
do_delete_del(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
d782 4
a785 4
static void
do_old_fkeys(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d791 4
a794 4
static void
do_hp_fkeys(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d801 4
a804 4
static void
do_sco_fkeys(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d810 4
a813 4
static void
do_sun_fkeys(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d822 4
a825 4
static void
do_sun_kbd(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d836 1
d838 4
a841 4
static void
do_suspend(Widget gw,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d843 2
a844 2
#if defined(SIGTSTP)
    handle_send_signal(gw, SIGTSTP);
d849 4
a852 4
static void
do_continue(Widget gw,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d854 2
a855 2
#if defined(SIGCONT)
    handle_send_signal(gw, SIGCONT);
d860 4
a863 4
static void
do_interrupt(Widget gw,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d865 1
a865 1
    handle_send_signal(gw, SIGINT);
d869 4
a872 4
void
do_hangup(Widget gw,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
d874 1
a874 1
    handle_send_signal(gw, SIGHUP);
d878 4
a881 4
static void
do_terminate(Widget gw,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d883 1
a883 1
    handle_send_signal(gw, SIGTERM);
d887 2
a888 2
static void
do_kill(Widget gw,
d892 1
a892 1
    handle_send_signal(gw, SIGKILL);
d895 2
a896 2
static void
do_quit(Widget gw GCC_UNUSED,
d900 1
a900 1
    Cleanup(0);
d903 2
d909 4
a912 4
static void
do_scrollbar(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d917 5
a921 4
static void
do_jumpscroll(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
d928 1
a928 2
	if (screen->scroll_amt)
	    FlushScroll(screen);
d935 7
a941 6
static void
do_reversevideo(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
{
    ReverseVideo(term);
d944 5
a948 4
static void
do_autowrap(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d954 5
a958 4
static void
do_reversewrap(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
d964 5
a968 4
static void
do_autolinefeed(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
d974 5
a978 4
static void
do_appcursor(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d984 5
a988 4
static void
do_appkeypad(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d994 5
a998 4
static void
do_scrollkey(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d1006 5
a1010 4
static void
do_scrollttyoutput(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
d1018 5
a1022 4
static void
do_allow132(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d1030 5
a1034 4
static void
do_cursesemul(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
d1042 5
a1046 4
static void
do_marginbell(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
d1050 1
a1050 2
    if (!(screen->marginbell = !screen->marginbell))
	screen->bellarmed = -1;
d1054 1
d1056 1
a1056 2
static void
handle_tekshow(Widget gw GCC_UNUSED, Bool allowswitch)
d1060 5
a1064 5
    if (!screen->Tshow) {	/* not showing, turn on */
	set_tek_visibility(TRUE);
    } else if (screen->Vshow || allowswitch) {	/* is showing, turn off */
	set_tek_visibility(FALSE);
	end_tek_mode();		/* WARNING: this does a longjmp */
d1066 1
a1066 1
	Bell(XkbBI_MinorError, 0);
d1070 4
a1073 4
static void
do_tekshow(Widget gw,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d1075 1
a1075 1
    handle_tekshow(gw, True);
d1079 4
a1082 4
static void
do_tekonoff(Widget gw,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d1084 1
a1084 1
    handle_tekshow(gw, False);
d1090 4
a1093 4
static void
do_cursorblink(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
d1101 4
a1104 4
static void
do_altscreen(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d1111 4
a1114 4
static void
do_titeInhibit(Widget gw GCC_UNUSED,
	       XtPointer closure GCC_UNUSED,
	       XtPointer data GCC_UNUSED)
d1122 4
a1125 4
static void
do_activeicon(Widget gw GCC_UNUSED,
	      XtPointer closure GCC_UNUSED,
	      XtPointer data GCC_UNUSED)
d1134 1
a1134 1
		      (XtPointer) 0);
d1140 4
a1143 4
static void
do_softreset(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d1145 1
a1145 1
    VTReset(FALSE, FALSE);
d1148 5
a1152 4
static void
do_hardreset(Widget gw GCC_UNUSED,
	     XtPointer closure GCC_UNUSED,
	     XtPointer data GCC_UNUSED)
d1154 1
a1154 1
    VTReset(TRUE, FALSE);
d1157 5
a1161 4
static void
do_clearsavedlines(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
d1163 1
a1163 1
    VTReset(TRUE, TRUE);
d1166 1
d1168 4
a1171 4
static void
do_tekmode(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d1175 1
a1175 1
    switch_modes(screen->TekEmu);	/* switch to tek mode */
d1179 4
a1182 4
static void
do_vthide(Widget gw GCC_UNUSED,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
d1188 1
d1193 4
a1196 4
static void
do_vtfont(Widget gw GCC_UNUSED,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
d1202 2
a1203 2
	if (strcmp(entryname, fontMenuEntries[i].name) == 0) {
	    SetVTFont(i, True, VT_FONTSET(NULL, NULL, NULL, NULL));
d1211 4
a1214 4
static void
do_font_doublesize(Widget gw GCC_UNUSED,
		   XtPointer closure GCC_UNUSED,
		   XtPointer data GCC_UNUSED)
d1217 1
a1217 1
	term->screen.font_doublesize = !term->screen.font_doublesize;
d1219 1
a1219 1
    Redraw();
d1224 4
a1227 4
static void
do_font_boxchars(Widget gw GCC_UNUSED,
		 XtPointer closure GCC_UNUSED,
		 XtPointer data GCC_UNUSED)
d1229 1
a1229 1
    term->screen.force_box_chars = !term->screen.force_box_chars;
d1231 1
a1231 1
    Redraw();
d1236 4
a1239 4
static void
do_font_loadable(Widget gw GCC_UNUSED,
		 XtPointer closure GCC_UNUSED,
		 XtPointer data GCC_UNUSED)
d1241 1
a1241 1
    term->misc.font_loadable = !term->misc.font_loadable;
d1246 1
d1252 4
a1255 4
static void
do_tektextlarge(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
d1257 1
a1257 1
    TekSetFontSize(tekMenu_tektextlarge);
d1260 5
a1264 4
static void
do_tektext2(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d1266 1
a1266 1
    TekSetFontSize(tekMenu_tektext2);
d1269 5
a1273 4
static void
do_tektext3(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d1275 1
a1275 1
    TekSetFontSize(tekMenu_tektext3);
d1278 5
a1282 4
static void
do_tektextsmall(Widget gw GCC_UNUSED,
		XtPointer closure GCC_UNUSED,
		XtPointer data GCC_UNUSED)
d1285 1
a1285 1
    TekSetFontSize(tekMenu_tektextsmall);
d1288 5
a1292 4
static void
do_tekpage(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d1294 1
a1294 1
    TekSimulatePageButton(False);
d1297 5
a1301 4
static void
do_tekreset(Widget gw GCC_UNUSED,
	    XtPointer closure GCC_UNUSED,
	    XtPointer data GCC_UNUSED)
d1303 1
a1303 1
    TekSimulatePageButton(True);
d1306 5
a1310 4
static void
do_tekcopy(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d1312 1
a1312 1
    TekCopy();
d1315 2
a1316 2
static void
handle_vtshow(Widget gw GCC_UNUSED, Bool allowswitch)
d1320 6
a1325 7
    if (!screen->Vshow) {	/* not showing, turn on */
	set_vt_visibility(TRUE);
    } else if (screen->Tshow || allowswitch) {	/* is showing, turn off */
	set_vt_visibility(FALSE);
	if (!screen->TekEmu && TekRefresh)
	    dorefresh();
	end_vt_mode();		/* WARNING: this does a longjmp... */
d1327 1
a1327 1
	Bell(XkbBI_MinorError, 0);
d1330 4
a1333 4
static void
do_vtshow(Widget gw,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
d1335 1
a1335 1
    handle_vtshow(gw, True);
d1338 4
a1341 4
static void
do_vtonoff(Widget gw,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d1343 1
a1343 1
    handle_vtshow(gw, False);
d1346 4
a1349 4
static void
do_vtmode(Widget gw GCC_UNUSED,
	  XtPointer closure GCC_UNUSED,
	  XtPointer data GCC_UNUSED)
d1353 1
a1353 1
    switch_modes(screen->TekEmu);	/* switch to vt, or from */
d1356 1
d1358 4
a1361 4
static void
do_tekhide(Widget gw GCC_UNUSED,
	   XtPointer closure GCC_UNUSED,
	   XtPointer data GCC_UNUSED)
d1367 2
d1373 8
a1380 8
static void
handle_toggle(void (*proc) PROTO_XT_CALLBACK_ARGS,
	      int var,
	      String * params,
	      Cardinal nparams,
	      Widget w,
	      XtPointer closure,
	      XtPointer data)
d1385 1
a1385 1
    case 0:
d1388 4
a1391 7
    case 1:
	if (XmuCompareISOLatin1(params[0], "on") == 0)
	    dir = 1;
	else if (XmuCompareISOLatin1(params[0], "off") == 0)
	    dir = 0;
	else if (XmuCompareISOLatin1(params[0], "toggle") == 0)
	    dir = -1;
d1396 1
a1396 1
    case -2:
d1400 1
a1400 1
    case -1:
d1404 3
a1406 5
    case 0:
	if (var)
	    (*proc) (w, closure, data);
	else
	    Bell(XkbBI_MinorError, 0);
d1409 3
a1411 5
    case 1:
	if (!var)
	    (*proc) (w, closure, data);
	else
	    Bell(XkbBI_MinorError, 0);
d1417 25
a1441 25
void
HandleAllowSends(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal * param_count)
{
    handle_toggle(do_allowsends, (int) term->screen.allowSendEvents,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleSetVisualBell(Widget w,
		    XEvent * event GCC_UNUSED,
		    String * params,
		    Cardinal * param_count)
{
    handle_toggle(do_visualbell, (int) term->screen.visualbell,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
}

void
HandleSetPopOnBell(Widget w,
		   XEvent * event GCC_UNUSED,
		   String * params,
		   Cardinal * param_count)
d1443 2
a1444 2
    handle_toggle(do_poponbell, (int) term->screen.poponbell,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1448 5
a1452 5
void
HandleLogging(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params,
	      Cardinal * param_count)
d1454 2
a1455 2
    handle_toggle(do_logging, (int) term->screen.logging,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1460 5
a1464 5
void
HandlePrintScreen(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params GCC_UNUSED,
		  Cardinal * param_count GCC_UNUSED)
d1466 1
a1466 1
    do_print(w, (XtPointer) 0, (XtPointer) 0);
d1470 5
a1474 15
void
HandlePrintControlMode(Widget w,
		       XEvent * event GCC_UNUSED,
		       String * params GCC_UNUSED,
		       Cardinal * param_count GCC_UNUSED)
{
    do_print_redir(w, (XtPointer) 0, (XtPointer) 0);
}

/* ARGSUSED */
void
HandleRedraw(Widget w,
	     XEvent * event GCC_UNUSED,
	     String * params GCC_UNUSED,
	     Cardinal * param_count GCC_UNUSED)
d1476 1
a1476 1
    do_redraw(w, (XtPointer) 0, (XtPointer) 0);
d1480 5
a1484 5
void
HandleSendSignal(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal * param_count)
a1485 1
    /* *INDENT-OFF* */
a1505 1
    /* *INDENT-ON* */
d1511 2
a1512 2
	    if (XmuCompareISOLatin1(st->name, params[0]) == 0) {
		handle_send_signal(w, st->sig);
d1523 5
a1527 5
void
HandleQuit(Widget w,
	   XEvent * event GCC_UNUSED,
	   String * params GCC_UNUSED,
	   Cardinal * param_count GCC_UNUSED)
d1529 1
a1529 1
    do_quit(w, (XtPointer) 0, (XtPointer) 0);
d1532 5
a1536 5
void
Handle8BitControl(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal * param_count)
d1538 2
a1539 2
    handle_toggle(do_8bit_control, (int) term->screen.control_eight_bits,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1542 5
a1546 5
void
HandleBackarrow(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal * param_count)
d1548 2
a1549 2
    handle_toggle(do_backarrow, (int) term->keyboard.flags & MODE_DECBKM,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1552 5
a1556 5
void
HandleSunFunctionKeys(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params,
		      Cardinal * param_count)
d1558 2
a1559 2
    handle_toggle(do_sun_fkeys, term->keyboard.type == keyboardIsSun,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1563 5
a1567 5
void
HandleNumLock(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params,
	      Cardinal * param_count)
d1569 2
a1570 2
    handle_toggle(do_num_lock, (int) term->misc.real_NumLock,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1573 5
a1577 5
void
HandleMetaEsc(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params,
	      Cardinal * param_count)
d1579 2
a1580 2
    handle_toggle(do_meta_esc, (int) term->screen.meta_sends_esc,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1584 5
a1588 5
void
HandleDeleteIsDEL(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal * param_count)
d1590 2
a1591 2
    handle_toggle(do_delete_del, term->screen.delete_is_del,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1594 5
a1598 5
void
HandleOldFunctionKeys(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params,
		      Cardinal * param_count)
d1600 2
a1601 2
    handle_toggle(do_old_fkeys, term->keyboard.type == keyboardIsLegacy,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1605 5
a1609 5
void
HandleSunKeyboard(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal * param_count)
d1611 2
a1612 2
    handle_toggle(do_sun_kbd, term->keyboard.type == keyboardIsVT220,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1617 5
a1621 5
void
HandleHpFunctionKeys(Widget w,
		     XEvent * event GCC_UNUSED,
		     String * params,
		     Cardinal * param_count)
d1623 2
a1624 2
    handle_toggle(do_hp_fkeys, term->keyboard.type == keyboardIsHP,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1629 5
a1633 5
void
HandleScoFunctionKeys(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params,
		      Cardinal * param_count)
d1635 2
a1636 2
    handle_toggle(do_sco_fkeys, term->keyboard.type == keyboardIsSCO,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1640 5
a1644 5
void
HandleScrollbar(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal * param_count)
d1646 2
a1647 2
    handle_toggle(do_scrollbar, (int) term->screen.fullVwin.sb_info.width,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1650 5
a1654 5
void
HandleJumpscroll(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal * param_count)
d1656 2
a1657 2
    handle_toggle(do_jumpscroll, (int) term->screen.jumpscroll,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1660 5
a1664 5
void
HandleReverseVideo(Widget w,
		   XEvent * event GCC_UNUSED,
		   String * params,
		   Cardinal * param_count)
d1666 2
a1667 2
    handle_toggle(do_reversevideo, (int) (term->misc.re_verse0),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1670 5
a1674 5
void
HandleAutoWrap(Widget w,
	       XEvent * event GCC_UNUSED,
	       String * params,
	       Cardinal * param_count)
d1676 2
a1677 2
    handle_toggle(do_autowrap, (int) (term->flags & WRAPAROUND),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1680 5
a1684 5
void
HandleReverseWrap(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal * param_count)
d1686 2
a1687 2
    handle_toggle(do_reversewrap, (int) (term->flags & REVERSEWRAP),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1690 5
a1694 5
void
HandleAutoLineFeed(Widget w,
		   XEvent * event GCC_UNUSED,
		   String * params,
		   Cardinal * param_count)
d1696 2
a1697 2
    handle_toggle(do_autolinefeed, (int) (term->flags & LINEFEED),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1700 5
a1704 5
void
HandleAppCursor(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal * param_count)
d1706 2
a1707 2
    handle_toggle(do_appcursor, (int) (term->keyboard.flags & MODE_DECCKM),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1710 5
a1714 5
void
HandleAppKeypad(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal * param_count)
d1716 2
a1717 2
    handle_toggle(do_appkeypad, (int) (term->keyboard.flags & MODE_DECKPAM),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1720 5
a1724 5
void
HandleScrollKey(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal * param_count)
d1726 2
a1727 2
    handle_toggle(do_scrollkey, (int) term->screen.scrollkey,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1730 5
a1734 5
void
HandleScrollTtyOutput(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params,
		      Cardinal * param_count)
d1736 2
a1737 2
    handle_toggle(do_scrollttyoutput, (int) term->screen.scrollttyoutput,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1740 5
a1744 5
void
HandleAllow132(Widget w,
	       XEvent * event GCC_UNUSED,
	       String * params,
	       Cardinal * param_count)
d1746 2
a1747 2
    handle_toggle(do_allow132, (int) term->screen.c132,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1750 5
a1754 5
void
HandleCursesEmul(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal * param_count)
d1756 2
a1757 2
    handle_toggle(do_cursesemul, (int) term->screen.curses,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1760 5
a1764 5
void
HandleMarginBell(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal * param_count)
d1766 2
a1767 2
    handle_toggle(do_marginbell, (int) term->screen.marginbell,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1771 5
a1775 5
void
HandleCursorBlink(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal * param_count)
d1778 2
a1779 2
    handle_toggle(do_cursorblink, (int) term->screen.cursor_blink,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1783 5
a1787 5
void
HandleAltScreen(Widget w,
		XEvent * event GCC_UNUSED,
		String * params,
		Cardinal * param_count)
d1790 2
a1791 2
    handle_toggle(do_altscreen, (int) term->screen.alternate,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1794 5
a1798 5
void
HandleTiteInhibit(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal * param_count)
d1801 2
a1802 2
    handle_toggle(do_titeInhibit, !((int) term->misc.titeInhibit),
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1806 5
a1810 5
void
HandleSoftReset(Widget w,
		XEvent * event GCC_UNUSED,
		String * params GCC_UNUSED,
		Cardinal * param_count GCC_UNUSED)
d1812 1
a1812 1
    do_softreset(w, (XtPointer) 0, (XtPointer) 0);
d1816 5
a1820 5
void
HandleHardReset(Widget w,
		XEvent * event GCC_UNUSED,
		String * params GCC_UNUSED,
		Cardinal * param_count GCC_UNUSED)
d1822 1
a1822 1
    do_hardreset(w, (XtPointer) 0, (XtPointer) 0);
d1826 5
a1830 5
void
HandleClearSavedLines(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params GCC_UNUSED,
		      Cardinal * param_count GCC_UNUSED)
d1832 1
a1832 1
    do_clearsavedlines(w, (XtPointer) 0, (XtPointer) 0);
d1836 5
a1840 5
void
HandleFontDoublesize(Widget w,
		     XEvent * event GCC_UNUSED,
		     String * params,
		     Cardinal * param_count)
d1842 2
a1843 2
    handle_toggle(do_font_doublesize, (int) term->screen.font_doublesize,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1848 5
a1852 5
void
HandleFontBoxChars(Widget w,
		   XEvent * event GCC_UNUSED,
		   String * params,
		   Cardinal * param_count)
d1854 2
a1855 2
    handle_toggle(do_font_boxchars, (int) term->screen.force_box_chars,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1860 5
a1864 5
void
HandleFontLoading(Widget w,
		  XEvent * event GCC_UNUSED,
		  String * params,
		  Cardinal * param_count)
d1866 2
a1867 2
    handle_toggle(do_font_loadable, (int) term->misc.font_loadable,
		  params, *param_count, w, (XtPointer) 0, (XtPointer) 0);
d1872 5
a1876 5
void
HandleSetTerminalType(Widget w,
		      XEvent * event GCC_UNUSED,
		      String * params,
		      Cardinal * param_count)
d1880 2
a1881 4
	case 'v':
	case 'V':
	    if (term->screen.TekEmu)
		do_vtmode(w, (XtPointer) 0, (XtPointer) 0);
d1883 2
a1884 4
	case 't':
	case 'T':
	    if (!term->screen.TekEmu)
		do_tekmode(w, (XtPointer) 0, (XtPointer) 0);
d1886 1
a1886 1
	default:
d1894 5
a1898 5
void
HandleVisibility(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal * param_count)
d1902 3
a1904 5
	case 'v':
	case 'V':
	    handle_toggle(do_vtonoff, (int) term->screen.Vshow,
			  params + 1, (*param_count) - 1,
			  w, (XtPointer) 0, (XtPointer) 0);
d1906 3
a1908 5
	case 't':
	case 'T':
	    handle_toggle(do_tekonoff, (int) term->screen.Tshow,
			  params + 1, (*param_count) - 1,
			  w, (XtPointer) 0, (XtPointer) 0);
d1910 1
a1910 1
	default:
d1919 5
a1923 5
void
HandleSetTekText(Widget w,
		 XEvent * event GCC_UNUSED,
		 String * params,
		 Cardinal * param_count)
d1925 1
a1925 1
    void (*proc) PROTO_XT_CALLBACK_ARGS = 0;
d1928 1
a1928 1
    case 0:
d1931 1
a1931 1
    case 1:
d1933 4
a1936 14
	case 'l':
	case 'L':
	    proc = do_tektextlarge;
	    break;
	case '2':
	    proc = do_tektext2;
	    break;
	case '3':
	    proc = do_tektext3;
	    break;
	case 's':
	case 'S':
	    proc = do_tektextsmall;
	    break;
d1940 2
a1941 4
    if (proc)
	(*proc) (w, (XtPointer) 0, (XtPointer) 0);
    else
	Bell(XkbBI_MinorError, 0);
d1945 5
a1949 5
void
HandleTekPage(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params GCC_UNUSED,
	      Cardinal * param_count GCC_UNUSED)
d1951 1
a1951 1
    do_tekpage(w, (XtPointer) 0, (XtPointer) 0);
d1955 5
a1959 5
void
HandleTekReset(Widget w,
	       XEvent * event GCC_UNUSED,
	       String * params GCC_UNUSED,
	       Cardinal * param_count GCC_UNUSED)
d1961 1
a1961 1
    do_tekreset(w, (XtPointer) 0, (XtPointer) 0);
d1965 5
a1969 5
void
HandleTekCopy(Widget w,
	      XEvent * event GCC_UNUSED,
	      String * params GCC_UNUSED,
	      Cardinal * param_count GCC_UNUSED)
d1971 1
a1971 1
    do_tekcopy(w, (XtPointer) 0, (XtPointer) 0);
d1978 1
a1978 2
    static Arg menuArgs =
    {XtNleftBitmap, (XtArgVal) 0};
d1980 6
a1985 6
    if (mi) {
	menuArgs.value = (XtArgVal) ((val)
				     ? term->screen.menu_item_bitmap
				     : None);
	XtSetValues(mi, &menuArgs, (Cardinal) 1);
    }
d1991 1
a1991 2
    static Arg menuArgs =
    {XtNsensitive, (XtArgVal) 0};
d1993 4
a1996 4
    if (mi) {
	menuArgs.value = (XtArgVal) (val);
	XtSetValues(mi, &menuArgs, (Cardinal) 1);
    }
d2006 46
a2051 49
static void
InitPopup(Widget gw,
	  XtPointer closure,
	  XtPointer data GCC_UNUSED)
{
    String params[2];
    Cardinal count = 1;

    params[0] = closure;
    params[1] = 0;
    TRACE(("InitPopup(%s)\n", params[0]));

    domenu(gw, (XEvent *) 0, params, &count);

    XtRemoveCallback(gw, XtNpopupCallback, InitPopup, closure);
}

static void
SetupShell(Widget * menus, MenuList * shell, Widget * menu_tops, int n, int m)
{
    char temp[80];
    char *external_name = 0;

    shell[n].w = XtVaCreatePopupShell(menu_names[n].internal_name,
				      simpleMenuWidgetClass,
				      *menus,
				      XtNgeometry, NULL,
				      (XtPointer) 0);

    XtAddCallback(shell[n].w, XtNpopupCallback, InitPopup, menu_names[n].internal_name);
    XtVaGetValues(shell[n].w,
		  XtNlabel, &external_name,
		  (XtPointer) 0);

    TRACE(("...SetupShell(%s) -> %s -> %#lx\n",
	   menu_names[n].internal_name,
	   external_name,
	   (long) shell[n].w));

    sprintf(temp, "%sButton", menu_names[n].internal_name);
    menu_tops[n] = XtVaCreateManagedWidget(temp,
					   menuButtonWidgetClass,
					   *menus,
					   XtNfromHoriz, ((m >= 0)
							  ? menu_tops[m]
							  : 0),
					   XtNmenuName, menu_names[n].internal_name,
					   XtNlabel, external_name,
					   (XtPointer) 0);
d2057 1
a2057 1
SetupMenus(Widget shell, Widget * forms, Widget * menus)
d2060 2
a2061 2
    int n;
    Widget menu_tops[NUM_POPUP_MENUS];
d2064 1
a2064 1
    TRACE(("SetupMenus(%s)\n", shell == toplevel ? "vt100" : "tek4014"));
d2066 6
a2071 6
    if (shell == toplevel) {
	XawSimpleMenuAddGlobalActions(app_con);
	XtRegisterGrabAction(HandlePopupMenu, True,
			     (ButtonPressMask | ButtonReleaseMask),
			     GrabModeAsync, GrabModeAsync);
    }
d2073 26
a2098 23
    *forms = XtVaCreateManagedWidget("form",
				     formWidgetClass, shell,
				     (XtPointer) 0);
    xtermAddInput(*forms);

    /*
     * Set a nominal value for the preferred pane size, which lets the
     * buttons determine the actual height of the menu bar.  We don't show
     * the grip, because it's too easy to make the toolbar look bad that
     * way.
     */
    *menus = XtVaCreateManagedWidget("menubar",
				     boxWidgetClass, *forms,
				     XtNorientation, XtorientHorizontal,
				     XtNtop, XawChainTop,
				     XtNbottom, XawChainTop,
				     XtNleft, XawChainLeft,
				     XtNright, XawChainLeft,
				     (XtPointer) 0);

    if (shell == toplevel) {	/* vt100 */
	for (n = mainMenu; n <= fontMenu; n++) {
	    SetupShell(menus, vt_shell, menu_tops, n, n - 1);
a2099 1
    }
d2101 4
a2104 4
    else {			/* tek4014 */
	SetupShell(menus, tek_shell, menu_tops, mainMenu, -1);
	SetupShell(menus, tek_shell, menu_tops, tekMenu, mainMenu);
    }
d2108 2
a2109 2
    *forms = shell;
    *menus = shell;
d2112 3
a2114 3
    TRACE(("...shell=%#lx\n", (long) shell));
    TRACE(("...forms=%#lx\n", (long) *forms));
    TRACE(("...menus=%#lx\n", (long) *menus));
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d4 1
a4 1
Copyright 1999-2002,2003 by Thomas E. Dickey
d48 1
a48 1
/* $XFree86: xc/programs/xterm/menu.c,v 3.53 2003/10/27 01:07:57 dickey Exp $ */
a56 2
#define app_con Xaw_app_con	/* quiet a warning from SimpleMenu.h */

a92 10
#elif defined(HAVE_LIB_XAWPLUS)

#include <X11/XawPlus/SimpleMenu.h>
#include <X11/XawPlus/Box.h>
#include <X11/XawPlus/SmeBSB.h>
#include <X11/XawPlus/SmeLine.h>

#if OPT_TOOLBAR
#include <X11/XawPlus/MenuButton.h>
#include <X11/XawPlus/Form.h>
a94 4
#endif

#undef app_con

d451 1
a451 1
static MenuIndex
d454 1
a454 1
    MenuIndex me;
d471 1
a471 1
	me = noMenu;
d488 1
a488 1
    MenuIndex me;
d497 1
a497 1
    if ((me = indexOfMenu(params[0])) == noMenu) {
d502 1
a502 1
    if ((mw = obtain_menu(w, me)) == 0
d504 1
a504 1
	mw = create_menu(w, term, me);
a535 12
#ifdef ALLOWLOGGING
	    if (screen->inhibit & I_LOG) {
		set_sensitivity(mw,
				mainMenuEntries[mainMenu_logging].widget, FALSE);
	    }
#endif
	    if (screen->inhibit & I_SIGNAL) {
		int n;
		for (n = (int) mainMenu_suspend; n <= (int) mainMenu_quit; ++n) {
		    set_sensitivity(mw, mainMenuEntries[n].widget, FALSE);
		}
	    }
a566 8
#if OPT_TEK4014
	    if (screen->inhibit & I_TEK) {
		int n;
		for (n = (int) vtMenu_tekshow; n <= (int) vtMenu_vthide; ++n) {
		    set_sensitivity(mw, vtMenuEntries[n].widget, FALSE);
		}
	    }
#endif
a611 2
    default:
	break;
d1231 1
a1231 1
	    SetVTFont(i, True, NULL);
a2175 381
}

void
update_securekbd(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_securekbd].widget,
		     term->screen.grabbedKbd);
}

void
update_allowsends(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_allowsends].widget,
		     term->screen.allowSendEvents);
}

#ifdef ALLOWLOGGING
void
update_logging(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_logging].widget,
		     term->screen.logging);
}
#endif

void
update_print_redir(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_print_redir].widget,
		     term->screen.printer_controlmode);
}

void
update_8bit_control(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_8bit_ctrl].widget,
		     term->screen.control_eight_bits);
}

void
update_decbkm(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_backarrow].widget,
		     term->keyboard.flags & MODE_DECBKM);
}

#if OPT_NUM_LOCK
void
update_num_lock(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_num_lock].widget,
		     term->misc.real_NumLock);
}

void
update_meta_esc(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_meta_esc].widget,
		     term->screen.meta_sends_esc);
}
#endif

void
update_sun_fkeys(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_sun_fkeys].widget,
		     term->keyboard.type == keyboardIsSun);
}

void
update_old_fkeys(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_old_fkeys].widget,
		     term->keyboard.type == keyboardIsLegacy);
}

void
update_delete_del(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_delete_del].widget,
		     xtermDeleteIsDEL());
}

#if OPT_SUNPC_KBD
void
update_sun_kbd(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_sun_kbd].widget,
		     term->keyboard.type == keyboardIsVT220);
}
#endif

#if OPT_HP_FUNC_KEYS
void
update_hp_fkeys(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_hp_fkeys].widget,
		     term->keyboard.type == keyboardIsHP);
}
#endif

#if OPT_SCO_FUNC_KEYS
void
update_sco_fkeys(void)
{
    update_menu_item(term->screen.mainMenu,
		     mainMenuEntries[mainMenu_sco_fkeys].widget,
		     term->keyboard.type == keyboardIsSCO);
}
#endif

void
update_scrollbar(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_scrollbar].widget,
		     ScrollbarWidth(&term->screen));
}

void
update_jumpscroll(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_jumpscroll].widget,
		     term->screen.jumpscroll);
}

void
update_reversevideo(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_reversevideo].widget,
		     (term->misc.re_verse));
}

void
update_autowrap(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_autowrap].widget,
		     (term->flags & WRAPAROUND));
}

void
update_reversewrap(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_reversewrap].widget,
		     (term->flags & REVERSEWRAP));
}

void
update_autolinefeed(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_autolinefeed].widget,
		     (term->flags & LINEFEED));
}

void
update_appcursor(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_appcursor].widget,
		     (term->keyboard.flags & MODE_DECCKM));
}

void
update_appkeypad(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_appkeypad].widget,
		     (term->keyboard.flags & MODE_DECKPAM));
}

void
update_scrollkey(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_scrollkey].widget,
		     term->screen.scrollkey);
}

void
update_scrollttyoutput(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_scrollttyoutput].widget,
		     term->screen.scrollttyoutput);
}

void
update_allow132(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_allow132].widget,
		     term->screen.c132);
}

void
update_cursesemul(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_cursesemul].widget,
		     term->screen.curses);
}

void
update_visualbell(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_visualbell].widget,
		     term->screen.visualbell);
}

void
update_poponbell(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_poponbell].widget,
		     term->screen.poponbell);
}

void
update_marginbell(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_marginbell].widget,
		     term->screen.marginbell);
}

#if OPT_BLINK_CURS
void
update_cursorblink(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_cursorblink].widget,
		     term->screen.cursor_blink);
}
#endif

void
update_altscreen(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_altscreen].widget,
		     term->screen.alternate);
}

void
update_titeInhibit(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_titeInhibit].widget,
		     !(term->misc.titeInhibit));
}

#ifndef NO_ACTIVE_ICON
void
update_activeicon(void)
{
    update_menu_item(term->screen.vtMenu,
		     vtMenuEntries[vtMenu_activeicon].widget,
		     term->misc.active_icon);
}
#endif /* NO_ACTIVE_ICON */

#if OPT_DEC_CHRSET
void
update_font_doublesize(void)
{
    update_menu_item(term->screen.fontMenu,
		     fontMenuEntries[fontMenu_font_doublesize].widget,
		     term->screen.font_doublesize);
}
#endif

#if OPT_BOX_CHARS
void
update_font_boxchars(void)
{
    update_menu_item(term->screen.fontMenu,
		     fontMenuEntries[fontMenu_font_boxchars].widget,
		     term->screen.force_box_chars);
}
#endif

#if OPT_DEC_SOFTFONT
void
update_font_loadable(void)
{
    update_menu_item(term->screen.fontMenu,
		     fontMenuEntries[fontMenu_font_loadable].widget,
		     term->misc.font_loadable);
}
#endif

#if OPT_TEK4014
void
update_tekshow(void)
{
    if (!(term->screen.inhibit & I_TEK)) {
	update_menu_item(term->screen.vtMenu,
			 vtMenuEntries[vtMenu_tekshow].widget,
			 term->screen.Tshow);
    }
}

void
update_vttekmode(void)
{
    if (!(term->screen.inhibit & I_TEK)) {
	update_menu_item(term->screen.vtMenu,
			 vtMenuEntries[vtMenu_tekmode].widget,
			 term->screen.TekEmu);
	update_menu_item(term->screen.tekMenu,
			 tekMenuEntries[tekMenu_vtmode].widget,
			 !term->screen.TekEmu);
    }
}

void
update_vtshow(void)
{
    if (!(term->screen.inhibit & I_TEK)) {
	update_menu_item(term->screen.tekMenu,
			 tekMenuEntries[tekMenu_vtshow].widget,
			 term->screen.Vshow);
    }
}

void
set_vthide_sensitivity(void)
{
    if (!(term->screen.inhibit & I_TEK)) {
	set_sensitivity(term->screen.vtMenu,
			vtMenuEntries[vtMenu_vthide].widget,
			term->screen.Tshow);
    }
}

void
set_tekhide_sensitivity(void)
{
    if (!(term->screen.inhibit & I_TEK)) {
	set_sensitivity(term->screen.tekMenu,
			tekMenuEntries[tekMenu_tekhide].widget,
			term->screen.Vshow);
    }
}

void
set_tekfont_menu_item(int n, int val)
{
    if (!(term->screen.inhibit & I_TEK)) {
	update_menu_item(term->screen.tekMenu,
			 tekMenuEntries[FS2MI(n)].widget,
			 (val));
    }
}
#endif /* OPT_TEK4014 */

void
set_menu_font(int val)
{
    update_menu_item(term->screen.fontMenu,
		     fontMenuEntries[term->screen.menu_font_number].widget,
		     (val));
@


