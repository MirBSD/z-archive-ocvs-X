head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407190955:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.11.10;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.11.10;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.41.13;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.46.31;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.29.45;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* removed all foreign stuff to get the code more clear (hv)
 * and did some rewrite for the obscure OS/2 environment
 */

#ifndef lint
static char *rid="$XConsortium: main.c,v 1.227.1.2 95/06/29 18:13:15 kaleb Exp $";
#endif /* lint */
/* $XFree86: xc/programs/xterm/os2main.c,v 3.49 2002/01/05 22:05:03 dickey Exp $ */

/***********************************************************


Copyright (c) 1987, 1988  X Consortium

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of the X Consortium shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from the X Consortium.


Copyright 1987, 1988 by Digital Equipment Corporation, Maynard.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be used in
advertising or publicity pertaining to distribution of the software
without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/


/* main.c */

#ifdef __EMX__
#define INCL_DOSFILEMGR
#define INCL_DOSDEVIOCTL
#define INCL_DOSSEMAPHORES
#include <os2.h>
#endif

#include <version.h>
#include <xterm.h>

#include <X11/StringDefs.h>
#include <X11/Shell.h>
#include <X11/cursorfont.h>
#ifdef I18N
#include <X11/Xlocale.h>
#endif

#if OPT_TOOLBAR
#include <X11/Xaw/Form.h>
#endif

#include <pwd.h>
#include <ctype.h>

#include <data.h>
#include <error.h>
#include <menu.h>
#include <main.h>
#include <xstrings.h>
#include <xterm_io.h>

int setpgrp(pid_t pid ,gid_t pgid) {}
int chown(const char* fn, pid_t pid, gid_t gid) {}
char *ttyname(int fd) { return "/dev/tty"; }

#include <sys/stat.h>
#include <sys/param.h>	/* for NOFILE */
#include <stdio.h>
#include <signal.h>

static SIGNAL_T reapchild (int n);
static int spawn (void);
static void get_terminal (void);
static void resize (TScreen *s, char *oldtc, char *newtc);

static Bool added_utmp_entry = False;

static char **command_to_exec;

/* The following structures are initialized in main() in order
** to eliminate any assumptions about the internal order of their
** contents.
*/
static struct termio d_tio;

/* allow use of system default characters if defined and reasonable */
#ifndef CEOF
#define CEOF     CONTROL('D')
#endif
#ifndef CSUSP
#define CSUSP    CONTROL('Z')
#endif
#ifndef CQUIT
#define CQUIT    CONTROL('\\')
#endif
#ifndef CEOL
#define CEOL 0
#endif
#ifndef CNUL
#define CNUL 0
#endif
#ifndef CSWTCH
#define CSWTCH 0
#endif
#ifndef CLNEXT
#define CLNEXT   CONTROL('V')
#endif
#ifndef CWERASE
#define CWERASE  CONTROL('W')
#endif
#ifndef CRPRNT
#define CRPRNT   CONTROL('R')
#endif
#ifndef CFLUSH
#define CFLUSH   CONTROL('O')
#endif
#ifndef CSTOP
#define CSTOP    CONTROL('S')
#endif
#ifndef CSTART
#define CSTART   CONTROL('Q')
#endif

/*
 * SYSV has the termio.c_cc[V] and ltchars; BSD has tchars and ltchars;
 * SVR4 has only termio.c_cc, but it includes everything from ltchars.
 */
static int override_tty_modes = 0;
struct _xttymodes {
    char *name;
    size_t len;
    int set;
    char value;
} ttymodelist[] = {
{ "intr", 4, 0, '\0' },			/* tchars.t_intrc ; VINTR */
#define XTTYMODE_intr 0
{ "quit", 4, 0, '\0' },			/* tchars.t_quitc ; VQUIT */
#define XTTYMODE_quit 1
{ "erase", 5, 0, '\0' },		/* sgttyb.sg_erase ; VERASE */
#define XTTYMODE_erase 2
{ "kill", 4, 0, '\0' },			/* sgttyb.sg_kill ; VKILL */
#define XTTYMODE_kill 3
{ "eof", 3, 0, '\0' },			/* tchars.t_eofc ; VEOF */
#define XTTYMODE_eof 4
{ "eol", 3, 0, '\0' },			/* VEOL */
#define XTTYMODE_eol 5
{ "swtch", 5, 0, '\0' },		/* VSWTCH */
#define XTTYMODE_swtch 6
{ "start", 5, 0, '\0' },		/* tchars.t_startc */
#define XTTYMODE_start 7
{ "stop", 4, 0, '\0' },			/* tchars.t_stopc */
#define XTTYMODE_stop 8
{ "brk", 3, 0, '\0' },			/* tchars.t_brkc */
#define XTTYMODE_brk 9
{ "susp", 4, 0, '\0' },			/* ltchars.t_suspc ; VSUSP */
#define XTTYMODE_susp 10
{ "dsusp", 5, 0, '\0' },		/* ltchars.t_dsuspc ; VDSUSP */
#define XTTYMODE_dsusp 11
{ "rprnt", 5, 0, '\0' },		/* ltchars.t_rprntc ; VREPRINT */
#define XTTYMODE_rprnt 12
{ "flush", 5, 0, '\0' },		/* ltchars.t_flushc ; VDISCARD */
#define XTTYMODE_flush 13
{ "weras", 5, 0, '\0' },		/* ltchars.t_werasc ; VWERASE */
#define XTTYMODE_weras 14
{ "lnext", 5, 0, '\0' },		/* ltchars.t_lnextc ; VLNEXT */
#define XTTYMODE_lnext 15
{ NULL, 0, 0, '\0' },			/* end of data */
};

static int parse_tty_modes (char *s, struct _xttymodes *modelist);

static int inhibit;
static char passedPty[2];	/* name if pty if slave */


#ifdef __EMX__
#define TIOCCONS	108
#endif

static int Console;
#include <X11/Xmu/SysUtil.h>	/* XmuGetHostname */
#define MIT_CONSOLE_LEN	12
#define MIT_CONSOLE "MIT_CONSOLE_"
static char mit_console_name[255 + MIT_CONSOLE_LEN + 1] = MIT_CONSOLE;
static Atom mit_console;

static int tslot;
static jmp_buf env;

char *ProgramName;

static struct _resource {
    char *xterm_name;
    char *icon_geometry;
    char *title;
    char *icon_name;
    char *term_name;
    char *tty_modes;
    Boolean hold_screen;	/* true if we keep window open	*/
    Boolean utmpInhibit;
    Boolean messages;
    Boolean sunFunctionKeys;	/* %%% should be widget resource? */
#if OPT_SUNPC_KBD
    Boolean sunKeyboard;
#endif
#if OPT_HP_FUNC_KEYS
    Boolean hpFunctionKeys;
#endif
    Boolean wait_for_map;
    Boolean useInsertMode;
#if OPT_ZICONBEEP
    int zIconBeep;		/* beep level when output while iconified */
#endif
#if OPT_SAME_NAME
    Boolean sameName;		/* Don't change the title or icon name if it is
				 * the same.  This prevents flicker on the
				 * screen at the cost of an extra request to
				 * the server.
				 */
#endif
} resource;

/* used by VT (charproc.c) */

#define offset(field)	XtOffsetOf(struct _resource, field)

static XtResource application_resources[] = {
    {"name", "Name", XtRString, sizeof(char *),
	offset(xterm_name), XtRString, DFT_TERMTYPE},
    {"iconGeometry", "IconGeometry", XtRString, sizeof(char *),
	offset(icon_geometry), XtRString, (caddr_t) NULL},
    {XtNtitle, XtCTitle, XtRString, sizeof(char *),
	offset(title), XtRString, (caddr_t) NULL},
    {XtNiconName, XtCIconName, XtRString, sizeof(char *),
	offset(icon_name), XtRString, (caddr_t) NULL},
    {"termName", "TermName", XtRString, sizeof(char *),
	offset(term_name), XtRString, (caddr_t) NULL},
    {"ttyModes", "TtyModes", XtRString, sizeof(char *),
	offset(tty_modes), XtRString, (caddr_t) NULL},
    {"hold", "Hold", XtRBoolean, sizeof (Boolean),
	offset(hold_screen), XtRString, "false"},
    {"utmpInhibit", "UtmpInhibit", XtRBoolean, sizeof (Boolean),
	offset(utmpInhibit), XtRString, "false"},
    {"messages", "Messages", XtRBoolean, sizeof (Boolean),
	offset(messages), XtRString, "true"},
    {"sunFunctionKeys", "SunFunctionKeys", XtRBoolean, sizeof (Boolean),
	offset(sunFunctionKeys), XtRString, "false"},
#if OPT_SUNPC_KBD
    {"sunKeyboard", "SunKeyboard", XtRBoolean, sizeof (Boolean),
	offset(sunKeyboard), XtRString, "false"},
#endif
#if OPT_HP_FUNC_KEYS
    {"hpFunctionKeys", "HpFunctionKeys", XtRBoolean, sizeof (Boolean),
	offset(hpFunctionKeys), XtRString, "false"},
#endif
    {"waitForMap", "WaitForMap", XtRBoolean, sizeof (Boolean),
        offset(wait_for_map), XtRString, "false"},
    {"useInsertMode", "UseInsertMode", XtRBoolean, sizeof (Boolean),
        offset(useInsertMode), XtRString, "false"},
#if OPT_ZICONBEEP
    {"zIconBeep", "ZIconBeep", XtRInt, sizeof (int),
	offset(zIconBeep), XtRImmediate, 0},
#endif
#if OPT_SAME_NAME
    {"sameName", "SameName", XtRBoolean, sizeof (Boolean),
	offset(sameName), XtRString, "true"},
#endif
};
#undef offset

static char *fallback_resources[] = {
    "*SimpleMenu*menuLabel.vertSpace: 100",
    "*SimpleMenu*HorizontalMargins: 16",
    "*SimpleMenu*Sme.height: 16",
    "*SimpleMenu*Cursor: left_ptr",
    "*mainMenu.Label:  Main Options (no app-defaults)",
    "*vtMenu.Label:  VT Options (no app-defaults)",
    "*fontMenu.Label:  VT Fonts (no app-defaults)",
#if OPT_TEK4014
    "*tekMenu.Label:  Tek Options (no app-defaults)",
#endif
    NULL
};

/* Command line options table.  Only resources are entered here...there is a
   pass over the remaining options after XrmParseCommand is let loose. */

static XrmOptionDescRec optionDescList[] = {
{"-geometry",	"*vt100.geometry",XrmoptionSepArg,	(caddr_t) NULL},
{"-132",	"*c132",	XrmoptionNoArg,		(caddr_t) "on"},
{"+132",	"*c132",	XrmoptionNoArg,		(caddr_t) "off"},
{"-ah",		"*alwaysHighlight", XrmoptionNoArg,	(caddr_t) "on"},
{"+ah",		"*alwaysHighlight", XrmoptionNoArg,	(caddr_t) "off"},
{"-aw",		"*autoWrap",	XrmoptionNoArg,		(caddr_t) "on"},
{"+aw",		"*autoWrap",	XrmoptionNoArg,		(caddr_t) "off"},
#ifndef NO_ACTIVE_ICON
{"-ai",		"*activeIcon",	XrmoptionNoArg,		(caddr_t) "off"},
{"+ai",		"*activeIcon",	XrmoptionNoArg,		(caddr_t) "on"},
#endif /* NO_ACTIVE_ICON */
{"-b",		"*internalBorder",XrmoptionSepArg,	(caddr_t) NULL},
{"-bc",		"*cursorBlink",	XrmoptionNoArg,		(caddr_t) "on"},
{"+bc",		"*cursorBlink",	XrmoptionNoArg,		(caddr_t) "off"},
{"-bcf",	"*cursorOffTime",XrmoptionSepArg,	(caddr_t) NULL},
{"-bcn",	"*cursorOnTime",XrmoptionSepArg,	(caddr_t) NULL},
{"-bdc",	"*colorBDMode",	XrmoptionNoArg,		(caddr_t) "off"},
{"+bdc",	"*colorBDMode",	XrmoptionNoArg,		(caddr_t) "on"},
{"-cb",		"*cutToBeginningOfLine", XrmoptionNoArg, (caddr_t) "off"},
{"+cb",		"*cutToBeginningOfLine", XrmoptionNoArg, (caddr_t) "on"},
{"-cc",		"*charClass",	XrmoptionSepArg,	(caddr_t) NULL},
{"-cm",		"*colorMode",	XrmoptionNoArg,		(caddr_t) "off"},
{"+cm",		"*colorMode",	XrmoptionNoArg,		(caddr_t) "on"},
{"-cn",		"*cutNewline",	XrmoptionNoArg,		(caddr_t) "off"},
{"+cn",		"*cutNewline",	XrmoptionNoArg,		(caddr_t) "on"},
{"-cr",		"*cursorColor",	XrmoptionSepArg,	(caddr_t) NULL},
{"-cu",		"*curses",	XrmoptionNoArg,		(caddr_t) "on"},
{"+cu",		"*curses",	XrmoptionNoArg,		(caddr_t) "off"},
{"-dc",		"*dynamicColors",XrmoptionNoArg,	(caddr_t) "off"},
{"+dc",		"*dynamicColors",XrmoptionNoArg,	(caddr_t) "on"},
{"-fb",		"*boldFont",	XrmoptionSepArg,	(caddr_t) NULL},
{"-fbb",	"*freeBoldBox", XrmoptionNoArg,		(caddr_t)"off"},
{"+fbb",	"*freeBoldBox", XrmoptionNoArg,		(caddr_t)"on"},
{"-fbx",	"*forceBoxChars", XrmoptionNoArg,	(caddr_t)"off"},
{"+fbx",	"*forceBoxChars", XrmoptionNoArg,	(caddr_t)"on"},
#ifndef NO_ACTIVE_ICON
{"-fi",		"*iconFont",	XrmoptionSepArg,	(caddr_t) NULL},
#endif /* NO_ACTIVE_ICON */
#ifdef XRENDERFONT
{"-fa",		"*faceName",	XrmoptionSepArg,	(caddr_t) NULL},
{"-fs",		"*faceSize",	XrmoptionSepArg,	(caddr_t) NULL},
#endif
#if OPT_WIDE_CHARS
{"-fw",		"*wideFont",	XrmoptionSepArg,	(caddr_t) NULL},
{"-fwb",	"*wideBoldFont", XrmoptionSepArg,	(caddr_t) NULL},
#endif
#if OPT_HIGHLIGHT_COLOR
{"-hc",		"*highlightColor", XrmoptionSepArg,	(caddr_t) NULL},
#endif
#if OPT_HP_FUNC_KEYS
{"-hf",		"*hpFunctionKeys",XrmoptionNoArg,	(caddr_t) "on"},
{"+hf",		"*hpFunctionKeys",XrmoptionNoArg,	(caddr_t) "off"},
#endif
{"-hold",	"*hold",	XrmoptionNoArg,		(caddr_t) "on"},
{"+hold",	"*hold",	XrmoptionNoArg,		(caddr_t) "off"},
{"-j",		"*jumpScroll",	XrmoptionNoArg,		(caddr_t) "on"},
{"+j",		"*jumpScroll",	XrmoptionNoArg,		(caddr_t) "off"},
/* parse logging options anyway for compatibility */
{"-l",		"*logging",	XrmoptionNoArg,		(caddr_t) "on"},
{"+l",		"*logging",	XrmoptionNoArg,		(caddr_t) "off"},
{"-lf",		"*logFile",	XrmoptionSepArg,	(caddr_t) NULL},
{"-ls",		"*loginShell",	XrmoptionNoArg,		(caddr_t) "on"},
{"+ls",		"*loginShell",	XrmoptionNoArg,		(caddr_t) "off"},
{"-mb",		"*marginBell",	XrmoptionNoArg,		(caddr_t) "on"},
{"+mb",		"*marginBell",	XrmoptionNoArg,		(caddr_t) "off"},
{"-mc",		"*multiClickTime", XrmoptionSepArg,	(caddr_t) NULL},
{"-mesg",	"*messages",	XrmoptionNoArg,		(caddr_t) "off"},
{"+mesg",	"*messages",	XrmoptionNoArg,		(caddr_t) "on"},
{"-ms",		"*pointerColor",XrmoptionSepArg,	(caddr_t) NULL},
{"-nb",		"*nMarginBell",	XrmoptionSepArg,	(caddr_t) NULL},
{"-nul",	"*underLine",	XrmoptionNoArg,		(caddr_t) "off"},
{"+nul",	"*underLine",	XrmoptionNoArg,		(caddr_t) "on"},
{"-pc",		"*boldColors",	XrmoptionNoArg,		(caddr_t) "on"},
{"+pc",		"*boldColors",	XrmoptionNoArg,		(caddr_t) "off"},
{"-rw",		"*reverseWrap",	XrmoptionNoArg,		(caddr_t) "on"},
{"+rw",		"*reverseWrap",	XrmoptionNoArg,		(caddr_t) "off"},
{"-s",		"*multiScroll",	XrmoptionNoArg,		(caddr_t) "on"},
{"+s",		"*multiScroll",	XrmoptionNoArg,		(caddr_t) "off"},
{"-sb",		"*scrollBar",	XrmoptionNoArg,		(caddr_t) "on"},
{"+sb",		"*scrollBar",	XrmoptionNoArg,		(caddr_t) "off"},
#ifdef SCROLLBAR_RIGHT
{"-leftbar",	"*rightScrollBar", XrmoptionNoArg,	(caddr_t) "off"},
{"-rightbar",	"*rightScrollBar", XrmoptionNoArg,	(caddr_t) "on"},
#endif
{"-rvc",	"*colorRVMode",	XrmoptionNoArg,		(caddr_t) "off"},
{"+rvc",	"*colorRVMode",	XrmoptionNoArg,		(caddr_t) "on"},
{"-sf",		"*sunFunctionKeys", XrmoptionNoArg,	(caddr_t) "on"},
{"+sf",		"*sunFunctionKeys", XrmoptionNoArg,	(caddr_t) "off"},
{"-si",		"*scrollTtyOutput", XrmoptionNoArg,	(caddr_t) "off"},
{"+si",		"*scrollTtyOutput", XrmoptionNoArg,	(caddr_t) "on"},
{"-sk",		"*scrollKey",	XrmoptionNoArg,		(caddr_t) "on"},
{"+sk",		"*scrollKey",	XrmoptionNoArg,		(caddr_t) "off"},
{"-sl",		"*saveLines",	XrmoptionSepArg,	(caddr_t) NULL},
#if OPT_SUNPC_KBD
{"-sp",		"*sunKeyboard", XrmoptionNoArg,		(caddr_t) "on"},
{"+sp",		"*sunKeyboard", XrmoptionNoArg,		(caddr_t) "off"},
#endif
{"-t",		"*tekStartup",	XrmoptionNoArg,		(caddr_t) "on"},
{"+t",		"*tekStartup",	XrmoptionNoArg,		(caddr_t) "off"},
{"-ti",		"*decTerminalID",XrmoptionSepArg,	(caddr_t) NULL},
{"-tm",		"*ttyModes",	XrmoptionSepArg,	(caddr_t) NULL},
{"-tn",		"*termName",	XrmoptionSepArg,	(caddr_t) NULL},
#if OPT_WIDE_CHARS
{"-u8",		"*utf8",	XrmoptionNoArg,		(caddr_t) "2"},
{"+u8",		"*utf8",	XrmoptionNoArg,		(caddr_t) "0"},
#endif
{"-ulc",	"*colorULMode",	XrmoptionNoArg,		(caddr_t) "off"},
{"+ulc",	"*colorULMode",	XrmoptionNoArg,		(caddr_t) "on"},
{"-ut",		"*utmpInhibit",	XrmoptionNoArg,		(caddr_t) "on"},
{"+ut",		"*utmpInhibit",	XrmoptionNoArg,		(caddr_t) "off"},
{"-im",		"*useInsertMode", XrmoptionNoArg,	(caddr_t) "on"},
{"+im",		"*useInsertMode", XrmoptionNoArg,	(caddr_t) "off"},
{"-vb",		"*visualBell",	XrmoptionNoArg,		(caddr_t) "on"},
{"+vb",		"*visualBell",	XrmoptionNoArg,		(caddr_t) "off"},
{"-pob",	"*popOnBell",	XrmoptionNoArg,		(caddr_t) "on"},
{"+pob",	"*popOnBell",	XrmoptionNoArg,		(caddr_t) "off"},
#if OPT_WIDE_CHARS
{"-wc",		"*wideChars",	XrmoptionNoArg,		(caddr_t) "on"},
{"+wc",		"*wideChars",	XrmoptionNoArg,		(caddr_t) "off"},
#endif
{"-wf",		"*waitForMap",	XrmoptionNoArg,		(caddr_t) "on"},
{"+wf",		"*waitForMap",	XrmoptionNoArg,		(caddr_t) "off"},
#if OPT_ZICONBEEP
{"-ziconbeep",  "*zIconBeep",   XrmoptionSepArg,        (caddr_t) NULL},
#endif
#if OPT_SAME_NAME
{"-samename",	"*sameName",	XrmoptionNoArg,		(caddr_t) "on"},
{"+samename",	"*sameName",	XrmoptionNoArg,		(caddr_t) "off"},
#endif
/* options that we process ourselves */
{"-help",	NULL,		XrmoptionSkipNArgs,	(caddr_t) NULL},
{"-version",	NULL,		XrmoptionSkipNArgs,	(caddr_t) NULL},
{"-class",	NULL,		XrmoptionSkipArg,	(caddr_t) NULL},
{"-e",		NULL,		XrmoptionSkipLine,	(caddr_t) NULL},
/* bogus old compatibility stuff for which there are
   standard XtAppInitialize options now */
{"%",		"*tekGeometry",	XrmoptionStickyArg,	(caddr_t) NULL},
{"#",		".iconGeometry",XrmoptionStickyArg,	(caddr_t) NULL},
{"-T",		".title",	XrmoptionSepArg,	(caddr_t) NULL},
{"-n",		"*iconName",	XrmoptionSepArg,	(caddr_t) NULL},
{"-r",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "on"},
{"+r",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "off"},
{"-rv",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "on"},
{"+rv",		"*reverseVideo",XrmoptionNoArg,		(caddr_t) "off"},
{"-w",		".borderWidth", XrmoptionSepArg,	(caddr_t) NULL},
};

static OptionHelp options[] = {
{ "-version",              "print the version number" },
{ "-help",                 "print out this message" },
{ "-display displayname",  "X server to contact" },
{ "-geometry geom",        "size (in characters) and position" },
{ "-/+rv",                 "turn on/off reverse video" },
{ "-bg color",             "background color" },
{ "-fg color",             "foreground color" },
{ "-bd color",             "border color" },
{ "-bw number",            "border width in pixels" },
{ "-fn fontname",          "normal text font" },
{ "-fb fontname",          "bold text font" },
{ "-/+fbb",                "turn on/off bold font's box checking"},
{ "-/+fbx",                "turn off/on linedrawing characters"},
#ifdef XRENDERFONT
{ "-fa pattern",           "FreeType font-selection pattern" },
{ "-fs size",              "FreeType font-size" },
#endif
#if OPT_WIDE_CHARS
{ "-fw fontname",          "doublewidth text font" },
{ "-fwb fontname",         "doublewidth bold text font" },
#endif
{ "-iconic",               "start iconic" },
{ "-name string",          "client instance, icon, and title strings" },
{ "-class string",         "class string (XTerm)" },
{ "-title string",         "title string" },
{ "-xrm resourcestring",   "additional resource specifications" },
{ "-/+132",                "turn on/off column switch inhibiting" },
{ "-/+ah",                 "turn on/off always highlight" },
#ifndef NO_ACTIVE_ICON
{ "-/+ai",		   "turn on/off active icon" },
{ "-fi fontname",	   "icon font for active icon" },
#endif /* NO_ACTIVE_ICON */
{ "-b number",             "internal border in pixels" },
{ "-/+bc",		   "turn on/off text cursor blinking" },
{ "-bcf milliseconds",	   "time text cursor is off when blinking"},
{ "-bcn milliseconds",	   "time text cursor is on when blinking"},
{ "-/+bdc",                "turn off/on display of bold as color"},
{ "-/+cb",                 "turn on/off cut-to-beginning-of-line inhibit" },
{ "-cc classrange",        "specify additional character classes" },
{ "-/+cm",                 "turn off/on ANSI color mode" },
{ "-/+cn",                 "turn on/off cut newline inhibit" },
{ "-cr color",             "text cursor color" },
{ "-/+cu",                 "turn on/off curses emulation" },
{ "-/+dc",		   "turn off/on dynamic color selection" },
#if OPT_HIGHLIGHT_COLOR
{ "-hc",		   "selection background color" },
#endif
#if OPT_HP_FUNC_KEYS
{ "-/+hf",                 "turn on/off HP Function Key escape codes" },
#endif
{ "-/+hold",		   "turn on/off logic that retains window after exit" },
{ "-/+im",		   "use insert mode for TERMCAP" },
{ "-/+j",                  "turn on/off jump scroll" },
#ifdef ALLOWLOGGING
{ "-/+l",                  "turn on/off logging" },
{ "-lf filename",          "logging filename" },
#else
{ "-/+l",                  "turn on/off logging (not supported)" },
{ "-lf filename",          "logging filename (not supported)" },
#endif
{ "-/+ls",                 "turn on/off login shell" },
{ "-/+mb",                 "turn on/off margin bell" },
{ "-mc milliseconds",      "multiclick time in milliseconds" },
{ "-/+mesg",		   "forbid/allow messages" },
{ "-ms color",             "pointer color" },
{ "-nb number",            "margin bell in characters from right end" },
{ "-/+nul",                "turn on/off display of underlining" },
{ "-/+aw",                 "turn on/off auto wraparound" },
{ "-/+pc",                 "turn on/off PC-style bold colors" },
{ "-/+rw",                 "turn on/off reverse wraparound" },
{ "-/+s",                  "turn on/off multiscroll" },
{ "-/+sb",                 "turn on/off scrollbar" },
#ifdef SCROLLBAR_RIGHT
{ "-rightbar",             "force scrollbar right (default left)" },
{ "-leftbar",              "force scrollbar left" },
#endif
{ "-/+rvc",		   "turn off/on display of reverse as color" },
{ "-/+sf",                 "turn on/off Sun Function Key escape codes" },
{ "-/+si",                 "turn on/off scroll-on-tty-output inhibit" },
{ "-/+sk",                 "turn on/off scroll-on-keypress" },
{ "-sl number",            "number of scrolled lines to save" },
#if OPT_SUNPC_KBD
{ "-/+sp",                 "turn on/off Sun/PC Function/Keypad mapping" },
#endif
#if OPT_TEK4014
{ "-/+t",                  "turn on/off Tek emulation window" },
#endif
{ "-ti termid",            "terminal identifier" },
{ "-tm string",            "terminal mode keywords and characters" },
{ "-tn name",              "TERM environment variable name" },
#if OPT_WIDE_CHARS
{ "-/+u8",                 "turn on/off UTF-8 mode (implies wide-characters)" },
#endif
{ "-/+ulc",                "turn off/on display of underline as color" },
{ "-/+ut",                 "turn on/off utmp inhibit (not supported)" },
{ "-/+vb",                 "turn on/off visual bell" },
{ "-/+pob",                "turn on/off pop on bell" },
#if OPT_WIDE_CHARS
{ "-/+wc",                 "turn on/off wide-character mode" },
#endif
{ "-/+wf",                 "turn on/off wait for map before command exec" },
{ "-e command args ...",   "command to execute" },
#if OPT_TEK4014
{ "%geom",                 "Tek window geometry" },
#endif
{ "#geom",                 "icon window geometry" },
{ "-T string",             "title name for window" },
{ "-n string",             "icon name for window" },
{ "-C",                    "intercept console messages" },
{ "-Sccn",                 "slave mode on \"ttycc\", file descriptor \"n\"" },
#if OPT_ZICONBEEP
{ "-ziconbeep percent",    "beep and flag icon of window having hidden output" },
#endif
#if OPT_SAME_NAME
{ "-/+samename",           "turn on/off the no-flicker option for title and icon name" },
#endif
{ NULL, NULL }};

/*debug FILE *confd;*/
/*static void opencons()
{
        if ((confd=fopen("/dev/console$","w")) < 0) {
                fputs("!!! Cannot open console device.\n",
                        stderr);
                exit(1);
        }
}

static void closecons(void)
{
	fclose(confd);
}
*/
static char *message[] = {
"Fonts should be fixed width and, if both normal and bold are specified, should",
"have the same size.  If only a normal font is specified, it will be used for",
"both normal and bold text (by doing overstriking).  The -e option, if given,",
"must appear at the end of the command line, otherwise the user's default shell",
"will be started.  Options that start with a plus sign (+) restore the default.",
NULL};

static Boolean get_termcap(char *name, char *buffer, char *resized)
{
    register TScreen *screen = &term->screen;

    *buffer = 0;	/* initialize, in case we're using terminfo's tgetent */

    if (name != 0) {
	if (tgetent (buffer, name) == 1) {
	    TRACE(("get_termcap(%s) succeeded (%s)\n", name,
	    	*buffer
		? "ok:termcap, we can update $TERMCAP"
		: "assuming this is terminfo"));
	    if (*buffer) {
		if (!TEK4014_ACTIVE(screen)) {
		    resize (screen, buffer, resized);
		}
	    }
	    return True;
	} else {
	    *buffer = 0;	/* just in case */
	}
    }
    return False;
}

static int abbrev (char *tst, char *cmp, size_t need)
{
	size_t len = strlen(tst);
	return ((len >= need) && (!strncmp(tst, cmp, len)));
}

static void Syntax (char *badOption)
{
    OptionHelp *opt;
    int col;

    fprintf (stderr, "%s:  bad command line option \"%s\"\r\n\n",
	     ProgramName, badOption);

    fprintf (stderr, "usage:  %s", ProgramName);
    col = 8 + strlen(ProgramName);
    for (opt = options; opt->opt; opt++) {
	int len = 3 + strlen(opt->opt);	 /* space [ string ] */
	if (col + len > 79) {
	    fprintf (stderr, "\r\n   ");  /* 3 spaces */
	    col = 3;
	}
	fprintf (stderr, " [%s]", opt->opt);
	col += len;
    }

    fprintf (stderr, "\r\n\nType %s -help for a full description.\r\n\n",
	     ProgramName);
    exit (1);
}

static void Version (void)
{
    printf("%s(%d)\n", XFREE86_VERSION, XTERM_PATCH);
    fflush(stdout);
}

static void Help (void)
{
    OptionHelp *opt;
    char **cpp;

    fprintf (stderr, "%s(%d) usage:\n    %s [-options ...] [-e command args]\n\n",
	     XFREE86_VERSION, XTERM_PATCH, ProgramName);
    fprintf (stderr, "where options include:\n");
    for (opt = options; opt->opt; opt++) {
	fprintf (stderr, "    %-28s %s\n", opt->opt, opt->desc);
    }

    putc ('\n', stderr);
    for (cpp = message; *cpp; cpp++) {
	fputs (*cpp, stderr);
	putc ('\n', stderr);
    }
    putc ('\n', stderr);
    fflush(stderr);
}

/* ARGSUSED */
static Boolean
ConvertConsoleSelection(
    Widget w GCC_UNUSED,
    Atom *selection GCC_UNUSED,
    Atom *target GCC_UNUSED,
    Atom *type GCC_UNUSED,
    XtPointer *value GCC_UNUSED,
    unsigned long *length GCC_UNUSED,
    int *format GCC_UNUSED)
{
    /* we don't save console output, so can't offer it */
    return False;
}

Arg ourTopLevelShellArgs[] = {
	{ XtNallowShellResize, (XtArgVal) TRUE },
	{ XtNinput, (XtArgVal) TRUE },
};
int number_ourTopLevelShellArgs = 2;

Bool waiting_for_initial_map;

/*
 * DeleteWindow(): Action proc to implement ICCCM delete_window.
 */
/* ARGSUSED */
static void
DeleteWindow(
    Widget w,
    XEvent *event GCC_UNUSED,
    String *params GCC_UNUSED,
    Cardinal *num_params GCC_UNUSED)
{
#if OPT_TEK4014
  if (w == toplevel) {
    if (term->screen.Tshow)
      hide_vt_window();
    else
      do_hangup(w, (XtPointer)0, (XtPointer)0);
  } else
    if (term->screen.Vshow)
      hide_tek_window();
    else
#endif
      do_hangup(w, (XtPointer)0, (XtPointer)0);
}

/* ARGSUSED */
static void
KeyboardMapping(
    Widget w GCC_UNUSED,
    XEvent *event,
    String *params GCC_UNUSED,
    Cardinal *num_params GCC_UNUSED)
{
    switch (event->type) {
       case MappingNotify:
	  XRefreshKeyboardMapping(&event->xmapping);
	  break;
    }
}

XtActionsRec actionProcs[] = {
    { "DeleteWindow", DeleteWindow },
    { "KeyboardMapping", KeyboardMapping },
};

Atom wm_delete_window;

#ifdef __EMX__

int ptioctl(int fd, int func, void* data)
{
	APIRET rc;
	ULONG  len;
	struct pt_termios pt;
	struct termio *t;
	int i;

	switch (func) {
	case TCGETA:
		rc = DosDevIOCtl(fd,XFREE86_PTY, func,
		NULL, 0, NULL,
		(ULONG*)&pt, sizeof(struct pt_termios), &len);
		if (rc) return -1;
		t = (struct termio*)data;
		t->c_iflag = pt.c_iflag;
		t->c_oflag = pt.c_oflag;
		t->c_cflag = pt.c_cflag;
		t->c_lflag = pt.c_lflag;
		for (i=0; i<NCC; i++)
			t->c_cc[i] = pt.c_cc[i];
		return 0;
	case TCSETA:
	case TCSETAW:
	case TCSETAF:
		t = (struct termio*)data;
		pt.c_iflag = t->c_iflag;
		pt.c_oflag = t->c_oflag;
		pt.c_cflag = t->c_cflag;
		pt.c_lflag = t->c_lflag;

		for (i=0; i<NCC; i++)
			pt.c_cc[i] = t->c_cc[i];
		if (func==TCSETA)
			i = XTY_TIOCSETA;
		else if (func==TCSETAW)
			i = XTY_TIOCSETAW;
		else
			i = XTY_TIOCSETAF;
		rc = DosDevIOCtl(fd,XFREE86_PTY, i,
			(ULONG*)&pt, sizeof(struct pt_termios), &len,
			NULL, 0, NULL);
		return (rc) ? -1 : 0;
	case TIOCCONS:
		return DosDevIOCtl(fd,XFREE86_PTY, XTY_TIOCCONS,
			(ULONG*)data, sizeof(ULONG), &len,
			NULL, 0, NULL);
	case TIOCSWINSZ:
		return DosDevIOCtl(fd,XFREE86_PTY, XTY_TIOCSWINSZ,
			(ULONG*)data, sizeof(struct winsize), &len,
			NULL, 0, NULL);
	case TIOCGWINSZ:
		return DosDevIOCtl(fd,XFREE86_PTY, XTY_TIOCGWINSZ,
			NULL, 0, NULL,
			(ULONG*)data, sizeof(struct winsize), &len);
	case XTY_ENADUP:
		i = 1;
		return DosDevIOCtl(fd,XFREE86_PTY, XTY_ENADUP,
			(ULONG*)&i, sizeof(ULONG), &len,
			NULL, 0, NULL);
	case XTY_TRACE:
		i = 2;
		return DosDevIOCtl(fd,XFREE86_PTY, XTY_TRACE,
			(ULONG*)&i, sizeof(ULONG), &len,
			NULL, 0, NULL);
	case PTMS_GETPTY:
		i = 1;
		return DosDevIOCtl(fd,XFREE86_PTY, PTMS_GETPTY,
			(ULONG*)&i, sizeof(ULONG), &len,
			(UCHAR*)data, 14, &len);
	default:
		return -1;
	}
}
#endif /* __EMX__ */

char **gblenvp;
extern char **environ;

int
main (int argc, char **argv, char **envp)
{
	Widget form_top, menu_top;
	register TScreen *screen;
	int mode;
	char *my_class = DEFCLASS;

	/* Do these first, since we may not be able to open the display */
	ProgramName = argv[0];
	TRACE_OPTS(options, optionDescList, XtNumber(optionDescList));
	TRACE_ARGV("Before XtAppInitialize", argv);
	if (argc > 1) {
		int n;
		int unique = 2;
		Boolean quit = True;

		for (n = 1; n < argc; n++) {
			TRACE(("parsing %s\n", argv[n]));
			if (abbrev(argv[n], "-version", unique)) {
				Version();
			} else if (abbrev(argv[n], "-help", unique)) {
				Help();
			} else if (abbrev(argv[n], "-class", 3)) {
				if ((my_class = argv[++n]) == 0) {
					Help();
				} else {
					quit = False;
				}
				unique = 3;
			} else {
				quit = False;
				unique = 3;
			}
		}
		if (quit)
			exit(0);
	}

	/* XXX: for some obscure reason EMX seems to lose the value of
	 * the environ variable, don't understand why, so save it recently
	 */
	gblenvp = envp;

#ifdef I18N
	setlocale(LC_ALL, NULL);
#endif

/*debug	opencons();*/

	ttydev = (char *) malloc (PTMS_BUFSZ);
	ptydev = (char *) malloc (PTMS_BUFSZ);
	if (!ttydev || !ptydev) {
	    fprintf (stderr,
		     "%s:  unable to allocate memory for ttydev or ptydev\n",
		     ProgramName);
	    exit (1);
	}
	strcpy (ttydev, TTYDEV);
	strcpy (ptydev, PTYDEV);


	/* Initialization is done here rather than above in order
	** to prevent any assumptions about the order of the contents
	** of the various terminal structures (which may change from
	** implementation to implementation).
	*/
	d_tio.c_iflag = ICRNL|IXON;
	d_tio.c_oflag = OPOST|ONLCR|TAB3;
	d_tio.c_cflag = B38400|CS8|CREAD|PARENB|HUPCL;
	d_tio.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK;
	d_tio.c_line = 0;
	d_tio.c_cc[VINTR] = CONTROL('C');	/* '^C'	*/
	d_tio.c_cc[VERASE] = 0x7f;		/* DEL	*/
	d_tio.c_cc[VKILL] = CONTROL('U');	/* '^U'	*/
	d_tio.c_cc[VQUIT] = CQUIT;		/* '^\'	*/
	d_tio.c_cc[VEOF] = CEOF;		/* '^D' */
	d_tio.c_cc[VEOL] = CEOL;		/* '^@@'	*/

	/* Init the Toolkit. */
	{
	    XtSetErrorHandler(xt_error);
	    toplevel = XtAppInitialize (&app_con, my_class,
					optionDescList,
					XtNumber(optionDescList),
					&argc, argv, fallback_resources,
					NULL, 0);
	    XtSetErrorHandler((XtErrorHandler)0);

	    XtGetApplicationResources(toplevel, (XtPointer) &resource,
				      application_resources,
				      XtNumber(application_resources), NULL, 0);
	}

	waiting_for_initial_map = resource.wait_for_map;

	/*
	 * ICCCM delete_window.
	 */
	XtAppAddActions(app_con, actionProcs, XtNumber(actionProcs));

	/*
	 * fill in terminal modes
	 */
	if (resource.tty_modes) {
	    int n = parse_tty_modes (resource.tty_modes, ttymodelist);
	    if (n < 0) {
		fprintf (stderr, "%s:  bad tty modes \"%s\"\n",
			 ProgramName, resource.tty_modes);
	    } else if (n > 0) {
		override_tty_modes = 1;
	    }
	}

#if OPT_ZICONBEEP
	zIconBeep = resource.zIconBeep;
	zIconBeep_flagged = False;
	if ( zIconBeep > 100 || zIconBeep < -100 ) {
	    zIconBeep = 0;	/* was 100, but I prefer to defaulting off. */
	    fprintf( stderr, "a number between -100 and 100 is required for zIconBeep.  0 used by default\n");
	}
#endif /* OPT_ZICONBEEP */
#if OPT_SAME_NAME
        sameName = resource.sameName;
#endif
	hold_screen = resource.hold_screen ? 1 : 0;
	xterm_name = resource.xterm_name;
	if (strcmp(xterm_name, "-") == 0) xterm_name = DFT_TERMTYPE;
	if (resource.icon_geometry != NULL) {
	    int scr, junk;
	    int ix, iy;
	    Arg args[2];

	    for(scr = 0;	/* yyuucchh */
		XtScreen(toplevel) != ScreenOfDisplay(XtDisplay(toplevel),scr);
		scr++);

	    args[0].name = XtNiconX;
	    args[1].name = XtNiconY;
	    XGeometry(XtDisplay(toplevel), scr, resource.icon_geometry, "",
		      0, 0, 0, 0, 0, &ix, &iy, &junk, &junk);
	    args[0].value = (XtArgVal) ix;
	    args[1].value = (XtArgVal) iy;
	    XtSetValues( toplevel, args, 2);
	}

	XtSetValues (toplevel, ourTopLevelShellArgs,
		     number_ourTopLevelShellArgs);

#if OPT_WIDE_CHARS
	/* seems as good a place as any */
	init_classtab();
#endif

	/* Parse the rest of the command line */
	TRACE_ARGV("After XtAppInitialize", argv);
	for (argc--, argv++ ; argc > 0 ; argc--, argv++) {
	    if(**argv != '-') Syntax (*argv);

	    TRACE(("parsing %s\n", argv[0]));
	    switch(argv[0][1]) {
	     case 'h':	/* -help */
		Help();
		continue;
	     case 'v':	/* -version */
		Version();
		continue;
	     case 'C':
		{
		    struct stat sbuf;

		    /* Must be owner and have read/write permission.
		       xdm cooperates to give the console the right user. */
		    if ( !stat("/dev/console", &sbuf) &&
			 (sbuf.st_uid == getuid()) &&
			 !access("/dev/console", R_OK|W_OK))
		    {
			Console = TRUE;
		    } else
			Console = FALSE;
		}
		continue;
	     case 'S':
		if (sscanf(*argv + 2, "%c%c%d", passedPty, passedPty+1,
			   &am_slave) != 3)
		    Syntax(*argv);
		continue;
#ifdef DEBUG
	     case 'D':
		debug = TRUE;
		continue;
#endif	/* DEBUG */
	     case 'c':	/* -class param */
		argc--, argv++;
		continue;
	     case 'e':
		if (argc <= 1) Syntax (*argv);
		command_to_exec = ++argv;
		break;
	     default:
		Syntax (*argv);
	    }
	    break;
	}

#if OPT_WIDE_CHARS
	/* Test whether UTF-8 mode should be active by default */
	{
	    char *s;

	    if (((s = getenv("LC_ALL")) != 0 && *s != '\0') ||
		((s = getenv("LC_CTYPE")) != 0 && *s != '\0') ||
		((s = getenv("LANG")) != 0 && *s != '\0')) {
		if (strstr(s, "UTF-8"))
		    defaultUTF8[0] = '2';
	    }
	}
#endif

	SetupMenus(toplevel, &form_top, &menu_top);

        term = (XtermWidget) XtVaCreateManagedWidget(
		"vt100", xtermWidgetClass, form_top,
#if OPT_TOOLBAR
		XtNmenuBar,	menu_top,
		XtNresizable,	True,
		XtNfromVert,	menu_top,
		XtNleft,	XawChainLeft,
		XtNright,	XawChainRight,
		XtNbottom,	XawChainBottom,
#endif
		0);
	    /* this causes the initialize method to be called */

#if OPT_HP_FUNC_KEYS
	init_keyboard_type(keyboardIsHP, resource.hpFunctionKeys);
#endif
	init_keyboard_type(keyboardIsSun, resource.sunFunctionKeys);
#if OPT_SUNPC_KBD
	init_keyboard_type(keyboardIsVT220, resource.sunKeyboard);
#endif

        screen = &term->screen;

	inhibit = 0;
#ifdef ALLOWLOGGING
	if (term->misc.logInhibit)		inhibit |= I_LOG;
#endif
	if (term->misc.signalInhibit)		inhibit |= I_SIGNAL;
#if OPT_TEK4014
	if (term->misc.tekInhibit)		inhibit |= I_TEK;
#endif

/*
 * Set title and icon name if not specified
 */

	if (command_to_exec) {
	    Arg args[2];

	    if (!resource.title) {
		if (command_to_exec) {
		    resource.title = x_basename (command_to_exec[0]);
		} /* else not reached */
	    }

	    if (!resource.icon_name)
	      resource.icon_name = resource.title;
	    XtSetArg (args[0], XtNtitle, resource.title);
	    XtSetArg (args[1], XtNiconName, resource.icon_name);

	    TRACE(("setting:\n\ttitle \"%s\"\n\ticon \"%s\"\n\tbased on command \"%s\"\n",
		    resource.title,
		    resource.icon_name,
		    *command_to_exec));

	    XtSetValues (toplevel, args, 2);
	}

#if OPT_TEK4014
	if(inhibit & I_TEK)
		screen->TekEmu = FALSE;

	if(screen->TekEmu && !TekInit())
		exit(ERROR_INIT);
#endif

#ifdef DEBUG
    {
	/* Set up stderr properly.  Opening this log file cannot be
	 done securely by a privileged xterm process (although we try),
	 so the debug feature is disabled by default. */
	int i = -1;
	if(debug) {
		creat_as (getuid(), getgid(), True, "xterm.debug.log", 0666);
		i = open ("xterm.debug.log", O_WRONLY | O_TRUNC, 0666);
	}
	if(i >= 0) {
		dup2(i,2);

		/* mark this file as close on exec */
		(void) fcntl(i, F_SETFD, 1);
	}
    }
#endif	/* DEBUG */

	/* open a terminal for client */
	get_terminal ();

	spawn ();

	/* Child process is out there, let's catch its termination */
	(void) signal (SIGCHLD, reapchild);

	/* Realize procs have now been executed */

	if (am_slave >= 0) { /* Write window id so master end can read and use */
	    char buf[80];

	    buf[0] = '\0';
	    sprintf (buf, "%lx\n", XtWindow (XtParent (CURRENT_EMU(screen))));
	    write (screen->respond, buf, strlen (buf));
	}

	screen->inhibit = inhibit;

	if (0 > (mode = fcntl(screen->respond, F_GETFL, 0)))
		Error(1);
	mode |= O_NDELAY;

	if (fcntl(screen->respond, F_SETFL, mode))
		Error(1);

	FD_ZERO (&pty_mask);
	FD_ZERO (&X_mask);
	FD_ZERO (&Select_mask);
	FD_SET (screen->respond, &pty_mask);
	FD_SET (ConnectionNumber(screen->display), &X_mask);
	FD_SET (screen->respond, &Select_mask);
	FD_SET (ConnectionNumber(screen->display), &Select_mask);
	max_plus1 = (screen->respond < ConnectionNumber(screen->display)) ?
		(1 + ConnectionNumber(screen->display)) :
		(1 + screen->respond);

#ifdef DEBUG
	if (debug) printf ("debugging on\n");
#endif	/* DEBUG */
	XSetErrorHandler(xerror);
	XSetIOErrorHandler(xioerror);

#ifdef ALLOWLOGGING
	if (term->misc.log_on) {
		StartLog(screen);
	}
#endif
	for( ; ; ) {
#if OPT_TEK4014
		if(screen->TekEmu)
			TekRun();
		else
#endif
			VTRun();
	}
	return 0;
}

/*
 * Called from get_pty to iterate over likely pseudo terminals
 * we might allocate.  Used on those systems that do not have
 * a functional interface for allocating a pty.
 * Returns 0 if found a pty, 1 if fails.
 */
static int
pty_search(int *pty)
{
	char namebuf[PTMS_BUFSZ];

	/* ask the PTY manager */
	int fd = open("/dev/ptms$",0);
	if (fd && ptioctl(fd,PTMS_GETPTY,namebuf)==0) {
		strcpy(ttydev,namebuf);
		strcpy(ptydev,namebuf);
		*x_basename(ttydev) = 't';
		close (fd);
		if ((*pty = open(ptydev, O_RDWR)) >= 0) {
#ifdef PTYDEBUG
			ptioctl(*pty,XTY_TRACE,0);
#endif
			return 0;
		}
	}
	return 1;
}

/*
 * This function opens up a pty master and stuffs its value into pty.
 *
 * If it finds one, it returns a value of 0.  If it does not find one,
 * it returns a value of !0.  This routine is designed to be re-entrant,
 * so that if a pty master is found and later, we find that the slave
 * has problems, we can re-enter this function and get another one.
 */
static int
get_pty (int *pty)
{
	return pty_search(pty);
}

/*
 * sets up X and initializes the terminal structure except for term.buf.fildes.
 */
static void
get_terminal (void)
{
	register TScreen *screen = &term->screen;

	screen->arrow = make_colored_cursor (XC_left_ptr,
					     screen->mousecolor,
					     screen->mousecolorback);
}

/*
 * The only difference in /etc/termcap between 4014 and 4015 is that
 * the latter has support for switching character sets.  We support the
 * 4015 protocol, but ignore the character switches.  Therefore, we
 * choose 4014 over 4015.
 *
 * Features of the 4014 over the 4012: larger (19") screen, 12-bit
 * graphics addressing (compatible with 4012 10-bit addressing),
 * special point plot mode, incremental plot mode (not implemented in
 * later Tektronix terminals), and 4 character sizes.
 * All of these are supported by xterm.
 */

#if OPT_TEK4014
static char *tekterm[] = {
	"tek4014",
	"tek4015",		/* 4014 with APL character set support */
	"tek4012",		/* 4010 with lower case */
	"tek4013",		/* 4012 with APL character set support */
	"tek4010",		/* small screen, upper-case only */
	"dumb",
	0
};
#endif

/* The VT102 is a VT100 with the Advanced Video Option included standard.
 * It also adds Escape sequences for insert/delete character/line.
 * The VT220 adds 8-bit character sets, selective erase.
 * The VT320 adds a 25th status line, terminal state interrogation.
 * The VT420 has up to 48 lines on the screen.
 */

static char *vtterm[] = {
#ifdef USE_X11TERM
	"x11term",		/* for people who want special term name */
#endif
	DFT_TERMTYPE,		/* for people who want special term name */
	"xterm",		/* the prefered name, should be fastest */
	"vt102",
	"vt100",
	"ansi",
	"dumb",
	0
};

/* ARGSUSED */
static SIGNAL_T hungtty(int i GCC_UNUSED)
{
	longjmp(env, 1);
	SIGNAL_RETURN;
}

struct {
	int rows;
	int cols;
} handshake = {-1,-1};

void first_map_occurred (void)
{
    register TScreen *screen = &term->screen;
    handshake.rows = screen->max_row;
    handshake.cols = screen->max_col;
    waiting_for_initial_map = False;
}

#define THE_PARENT 1
#define THE_CHILD  2
int whoami = -1;

SIGNAL_T killit(int sig)
{
	switch (whoami) {
	case -1:
		signal(sig,killit);
		kill(-getpid(),sig);
		break;
	case THE_PARENT:
		wait(NULL);
		signal(SIGTERM,SIG_DFL);
		kill(-getpid(),SIGTERM);
		Exit(0);
		break;
	case THE_CHILD:
		signal(SIGTERM,SIG_DFL);
		kill(-getppid(),SIGTERM);
		Exit(0);
		break;
	}

	SIGNAL_RETURN;
}

static int
spawn (void)
/*
 *  Inits pty and tty and forks a login process.
 *  Does not close fd Xsocket.
 *  If slave, the pty named in passedPty is already open for use
 */
{
	register TScreen *screen = &term->screen;
	int Xsocket = ConnectionNumber(screen->display);

	int tty = -1;
	struct termio tio;
	int status;

	char termcap[TERMCAP_SIZE], newtc[TERMCAP_SIZE];
	char *TermName = NULL;
	char *ptr, *shname, buf[64];
	int i, no_dev_tty = FALSE, envsize;
	char *dev_tty_name = (char *) 0;
	struct winsize ws;
	int pgrp = getpid();
	char numbuf[12], **envnew;

	screen->uid = getuid();
	screen->gid = getgid();

	if (am_slave >= 0) {
		screen->respond = am_slave;
		ptydev[strlen(ptydev) - 2] =
		ttydev[strlen(ttydev) - 2] = passedPty[0];
		ptydev[strlen(ptydev) - 1] =
		ttydev[strlen(ttydev) - 1] = passedPty[1];

		setgid (screen->gid);
		setuid (screen->uid);
	} else {
		Bool tty_got_hung;

		/*
		 * Sometimes /dev/tty hangs on open (as in the case of a pty
		 * that has gone away).  Simply make up some reasonable
		 * defaults.
		 */

		signal(SIGALRM, hungtty);
		alarm(2);		/* alarm(1) might return too soon */
		if (! setjmp(env)) {
			tty = open ("/dev/tty", O_RDWR, 0);
			alarm(0);
			tty_got_hung = False;
		} else {
			tty_got_hung = True;
			tty = -1;
			errno = ENXIO;
		}
		signal(SIGALRM, SIG_DFL);

		/*
		 * Check results and ignore current control terminal if
		 * necessary.  ENXIO is what is normally returned if there is
		 * no controlling terminal, but some systems (e.g. SunOS 4.0)
		 * seem to return EIO.  Solaris 2.3 is said to return EINVAL.
		 */
		if (tty < 0) {
			if (tty_got_hung || errno == ENXIO || errno == EIO ||
			    errno == EINVAL || errno == ENOTTY) {
				no_dev_tty = TRUE;
				tio = d_tio;
			} else {
			    SysError(ERROR_OPDEVTTY);
			}
		} else {
			/* Get a copy of the current terminal's state,
			 * if we can.  Some systems (e.g., SVR4 and MacII)
			 * may not have a controlling terminal at this point
			 * if started directly from xdm or xinit,
			 * in which case we just use the defaults as above.
			 */
/**/			if(ioctl(tty, TCGETA, &tio) == -1)
				tio = d_tio;

			close (tty);
			/* tty is no longer an open fd! */
			tty = -1;
		}

		if (get_pty (&screen->respond)) {
			/*  no ptys! */
			exit (ERROR_PTYS);
		}
	}

	/* avoid double MapWindow requests */
	XtSetMappedWhenManaged(XtParent(CURRENT_EMU(screen)), False );

	wm_delete_window = XInternAtom(XtDisplay(toplevel), "WM_DELETE_WINDOW",
				       False);

	if (!TEK4014_ACTIVE(screen))
	    VTInit();		/* realize now so know window size for tty driver */

	if (Console) {
	    /*
	     * Inform any running xconsole program
	     * that we are going to steal the console.
	     */
	    XmuGetHostname (mit_console_name + MIT_CONSOLE_LEN, 255);
	    mit_console = XInternAtom(screen->display, mit_console_name, False);
	    /* the user told us to be the console, so we can use CurrentTime */
	    XtOwnSelection(XtParent(CURRENT_EMU(screen)),
			   mit_console, CurrentTime,
			   ConvertConsoleSelection, NULL, NULL);
	}
#if OPT_TEK4014
	if(screen->TekEmu) {
		envnew = tekterm;
		ptr = newtc;
	}
	else
#endif
	{
		envnew = vtterm;
		ptr = termcap;
	}

	/*
	 * This used to exit if no termcap entry was found for the specified
	 * terminal name.  That's a little unfriendly, so instead we'll allow
	 * the program to proceed (but not to set $TERMCAP) if the termcap
	 * entry is not found.
	 */
	get_termcap(TermName = resource.term_name, ptr, newtc);

	/*
	 * This block is invoked only if there was no terminal name specified
	 * by the command-line option "-tn".
	 */
	if (!TermName) {
	    TermName = *envnew;
	    while (*envnew != NULL) {
		if (get_termcap(*envnew, ptr, newtc)) {
		    TermName = *envnew;
		    break;
		}
		envnew++;
	    }
	}

	/* tell tty how big window is */
#if OPT_TEK4014
	if(TEK4014_ACTIVE(screen)) {
		ws.ws_row = 38;
		ws.ws_col = 81;
		ws.ws_xpixel = TFullWidth(screen);
		ws.ws_ypixel = TFullHeight(screen);
	} else
#endif
	{
		ws.ws_row = screen->max_row + 1;
		ws.ws_col = screen->max_col + 1;
		ws.ws_xpixel = FullWidth(screen);
		ws.ws_ypixel = FullHeight(screen);
	}

	if (am_slave < 0) {

		char sema[40];
		HEV sev;
		/* start a child process
		 * use an event sema for sync
		 */
		sprintf(sema,"\\SEM32\\xterm%s",&ptydev[8]);
		if (DosCreateEventSem(sema,&sev,DC_SEM_SHARED,FALSE))
			SysError(ERROR_FORK);

		switch ((screen->pid = fork())) {
		case -1:	/* error */
			SysError (ERROR_FORK);
		default:	/* parent */
			whoami = THE_PARENT;
			DosWaitEventSem(sev,1000l);
			DosCloseEventSem(sev);
			break;
		case 0:		/* child */
			whoami = THE_CHILD;

/*debug fclose(confd);
opencons();*/
			/* we don't need the socket, or the pty master anymore */
			close (ConnectionNumber(screen->display));
			close (screen->respond);

			/* Now is the time to set up our process group and
			 * open up the pty slave.
			 */
			if ((tty = open(ttydev, O_RDWR, 0)) < 0) {
				/* dumm gelaufen */
				fprintf(stderr, "Cannot open slave side of PTY\n");
				exit(1);
			}

			/* use the same tty name that everyone else will use
			 * (from ttyname)
			 */
#ifdef EMXNOTBOGUS
			if ((ptr = ttyname(tty)) != 0)
			{
				/* it may be bigger */
				ttydev = realloc (ttydev,
					(unsigned) (strlen(ptr) + 1));
				(void) strcpy(ttydev, ptr);
			}
#else
			ptr = ttydev;
#endif
			/* for safety: enable DUPs */
			ptioctl(tty,XTY_ENADUP,0);

			/* change ownership of tty to real group and user id */
			chown (ttydev, screen->uid, screen->gid);

			/* change protection of tty */
			chmod (ttydev, (resource.messages? 0622 : 0600));

			/* for the xf86sup-pty, we set the pty to bypass: OS/2 does
			 * not have a line discipline structure
			 */
			{
				struct termio t,t1;
				if (ptioctl(tty, TCGETA, (char*)&t) < 0)
					t = d_tio;

				t.c_iflag = ICRNL;
				t.c_oflag = OPOST|ONLCR;
				t.c_lflag = ISIG|ICANON|ECHO|ECHOE|ECHOK;

				/* ignore error code, user will see it :-) */
				ptioctl(tty, TCSETA, (char*)&t);

				/* set the console mode */
				if (Console) {
					int on = 1;
					if (ioctl (tty, TIOCCONS, (char *)&on) == -1)
					fprintf(stderr, "%s: cannot open console\n", xterm_name);
				}
			}

			signal (SIGCHLD, SIG_DFL);
			signal (SIGHUP, SIG_IGN);

			/* restore various signals to their defaults */
			signal (SIGINT, SIG_DFL);
			signal (SIGQUIT, SIG_DFL);
			signal (SIGTERM, SIG_DFL);

			/* copy the environment before Setenving */
			for (i = 0 ; gblenvp [i] != NULL ; i++)
				;

			/* compute number of xtermSetenv() calls below */
			envsize = 1;	/* (NULL terminating entry) */
			envsize += 3;	/* TERM, WINDOWID, DISPLAY */
			envsize += 2;	/* COLUMNS, LINES */

			envnew = (char **) calloc ((unsigned) i + envsize, sizeof(char *));
			memmove( (char *)envnew, (char *)gblenvp, i * sizeof(char *));
			gblenvp = envnew;
			xtermSetenv ("TERM=", TermName);
			if(!TermName)
				*newtc = 0;

			sprintf (buf, "%lu",
				((unsigned long) XtWindow (XtParent(CURRENT_EMU(screen)))));
			xtermSetenv ("WINDOWID=", buf);

			/* put the display into the environment of the shell*/
			xtermSetenv ("DISPLAY=", XDisplayString (screen->display));

			signal(SIGTERM, SIG_DFL);

			/* this is the time to go and set up stdin, out, and err
			 */
			/* dup the tty */
			for (i = 0; i <= 2; i++)
				if (i != tty) {
					(void) close(i);
					(void) dup(tty);
				}

			/* and close the tty */
			if (tty > 2)
				(void) close(tty);

			setpgrp (0, pgrp);
			setgid (screen->gid);
			setuid (screen->uid);

			if (handshake.rows > 0 && handshake.cols > 0) {
				screen->max_row = handshake.rows;
				screen->max_col = handshake.cols;
				ws.ws_row = screen->max_row + 1;
				ws.ws_col = screen->max_col + 1;
				ws.ws_xpixel = FullWidth(screen);
				ws.ws_ypixel = FullHeight(screen);
			}

			sprintf (numbuf, "%d", screen->max_col + 1);
			xtermSetenv("COLUMNS=", numbuf);
			sprintf (numbuf, "%d", screen->max_row + 1);
			xtermSetenv("LINES=", numbuf);

			/* reconstruct dead environ variable */
			environ = gblenvp;

			/* need to reset after all the ioctl bashing we did above */
			ptioctl (0, TIOCSWINSZ, (char *)&ws);

			signal(SIGHUP, SIG_DFL);

			/* okay everything seems right, so tell the parent, we are going */
			{
				char sema[40];
				HEV sev;
				sprintf(sema,"\\SEM32\\xterm%s",&ttydev[8]);
				DosOpenEventSem(sema,&sev);
				DosPostEventSem(sev);
				DosCloseEventSem(sev);
			}

			if (command_to_exec) {
				TRACE(("spawning command \"%s\"\n", *command_to_exec));
				execvpe(*command_to_exec, command_to_exec,
					gblenvp);

				/* print error message on screen */
				fprintf(stderr, "%s: Can't execvp %s\n",
					xterm_name, *command_to_exec);
			}

			/* use a layered mechanism to find a shell */
			ptr = getenv("X11SHELL");
			if (!ptr) ptr = getenv("SHELL");
			if (!ptr) ptr = getenv("OS2_SHELL");
			if (!ptr) ptr = "SORRY_NO_SHELL_FOUND";

			shname = x_basename(ptr);
			if (command_to_exec) {
				char *exargv[10]; /*XXX*/

				exargv[0] = ptr;
				exargv[1] = "/C";
				exargv[2] = command_to_exec[0];
				exargv[3] = command_to_exec[1];
				exargv[4] = command_to_exec[2];
				exargv[5] = command_to_exec[3];
				exargv[6] = command_to_exec[4];
				exargv[7] = command_to_exec[5];
				exargv[8] = command_to_exec[6];
				exargv[9] = 0;
				execvpe(exargv[0],exargv,gblenvp);
/*
				execvpe(*command_to_exec, command_to_exec,
					gblenvp);
*/
				/* print error message on screen */
				fprintf(stderr, "%s: Can't execvp %s\n",
					xterm_name, *command_to_exec);
			} else {
				execlpe (ptr, shname, 0, gblenvp);

				/* Exec failed. */
				fprintf (stderr, "%s: Could not exec %s!\n",
					xterm_name, ptr);
			}
			sleep(5);

			/* preventively shoot the parent */
			kill (-getppid(),SIGTERM);

			exit(ERROR_EXEC);
		} /* endcase */
	} /* !am_slave */

	signal (SIGHUP, SIG_IGN);
/*
 * Unfortunately, System V seems to have trouble divorcing the child process
 * from the process group of xterm.  This is a problem because hitting the
 * INTR or QUIT characters on the keyboard will cause xterm to go away if we
 * don't ignore the signals.  This is annoying.
 */

/*	signal (SIGINT, SIG_IGN);*/
	signal(SIGINT, killit);
	signal(SIGTERM, killit);

	/* hung shell problem */
	signal (SIGQUIT, SIG_IGN);
/*	signal (SIGTERM, SIG_IGN);*/
	return 0;
}							/* end spawn */

SIGNAL_T
Exit(int n)
{
	register TScreen *screen = &term->screen;
        int pty = term->screen.respond;  /* file descriptor of pty */
        close(pty); /* close explicitly to avoid race with slave side */
#ifdef ALLOWLOGGING
	if(screen->logging)
		CloseLog(screen);
#endif
	if (am_slave < 0) {
		/* restore ownership of tty and pty */
		chown (ttydev, 0, 0);
		chown (ptydev, 0, 0);

		/* restore modes of tty and pty */
		chmod (ttydev, 0666);
		chmod (ptydev, 0666);
	}
	exit(n);
	SIGNAL_RETURN;
}

/* ARGSUSED */
static void
resize(TScreen *screen, register char *oldtc, register char *newtc)
{
}

/*
 * Does a non-blocking wait for a child process.  If the system
 * doesn't support non-blocking wait, do nothing.
 * Returns the pid of the child, or 0 or -1 if none or error.
 */
int
nonblocking_wait(void)
{
        pid_t pid;

	pid = waitpid(-1, NULL, WNOHANG);
	return pid;
}

/* ARGSUSED */
static SIGNAL_T reapchild (int n GCC_UNUSED)
{
    int pid;

    pid = wait(NULL);

    /* cannot re-enable signal before waiting for child
     * because then SVR4 loops.  Sigh.  HP-UX 9.01 too.
     */
    (void) signal(SIGCHLD, reapchild);

    do {
	if (pid == term->screen.pid) {
#ifdef DEBUG
	    if (debug) fputs ("Exiting\n", stderr);
#endif
	    if (!hold_screen)
		Cleanup (0);
	}
    } while ( (pid=nonblocking_wait()) > 0);

    SIGNAL_RETURN;
}

/*
 * parse_tty_modes accepts lines of the following form:
 *
 *         [SETTING] ...
 *
 * where setting consists of the words in the modelist followed by a character
 * or ^char.
 */
static int parse_tty_modes (char *s, struct _xttymodes *modelist)
{
    struct _xttymodes *mp;
    int c;
    int count = 0;

    while (1) {
	while (*s && isascii(CharOf(*s)) && isspace(CharOf(*s))) s++;
	if (!*s) return count;

	for (mp = modelist; mp->name; mp++) {
	    if (strncmp (s, mp->name, mp->len) == 0) break;
	}
	if (!mp->name) return -1;

	s += mp->len;
	while (*s && isascii(CharOf(*s)) && isspace(CharOf(*s))) s++;
	if (!*s) return -1;

	if (*s == '^') {
	    s++;
	    c = ((*s == '?') ? 0177 : CONTROL(*s));
	    if (*s == '-') {
		errno = 0;
		c = fpathconf(0, _PC_VDISABLE);
		if (c == -1) {
		    if (errno != 0)
			continue;	/* skip this (error) */
		    c = 0377;
		}
	    }
	} else {
	    c = *s;
	}
	mp->value = c;
	mp->set = 1;
	count++;
	s++;
    }
}

int GetBytesAvailable (int fd)
{
    long arg;
    ioctl (fd, FIONREAD, (char *) &arg);
    return (int) arg;
}

/* Utility function to try to hide system differences from
   everybody who used to call killpg() */

int
kill_process_group(int pid, int sig)
{
    return kill (-pid, sig);
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d6 1
a6 1
static char *rid = "$XConsortium: main.c,v 1.227.1.2 95/06/29 18:13:15 kaleb Exp $";
d8 1
a8 1
/* $XFree86: xc/programs/xterm/os2main.c,v 3.62 2003/05/21 22:59:13 dickey Exp $ */
d12 1
d36 1
d59 4
a62 1
/* os2main.c */
a65 1
#define I_NEED_OS2_H
d67 1
a67 3
#define XTERM_MAIN

#define RES_OFFSET(field)	XtOffsetOf(XTERM_RESOURCE, field)
d72 2
a79 2

#if defined(HAVE_LIB_XAW)
a80 6
#elif defined(HAVE_LIB_XAW3D)
#include <X11/Xaw3d/Form.h>
#elif defined(HAVE_LIB_NEXTAW)
#include <X11/neXtaw/Form.h>
#elif defined(HAVE_LIB_XAWPLUS)
#include <X11/XawPlus/Form.h>
a82 2
#endif /* OPT_TOOLBAR */

d93 3
a95 22
#if OPT_WIDE_CHARS
#include <charclass.h>
#include <wcwidth.h>
#endif

int
setpgrp(pid_t pid, gid_t pgid)
{
    return 0;
}

int
chown(const char *fn, pid_t pid, gid_t gid)
{
    return 0;
}

char *
ttyname(int fd)
{
    return "/dev/tty";
}
d98 1
a98 1
#include <sys/param.h>		/* for NOFILE */
d102 4
a105 5
static SIGNAL_T reapchild(int n);
static int spawn(void);
static void get_terminal(void);
static void resize(TScreen * s, char *oldtc, char *newtc);
static void set_owner(char *device, int uid, int gid, int mode);
d109 1
a109 12
/*
** Ordinarily it should be okay to omit the assignment in the following
** statement. Apparently the c89 compiler on AIX 4.1.3 has a bug, or does
** it? Without the assignment though the compiler will init command_to_exec
** to 0xffffffff instead of NULL; and subsequent usage, e.g. in spawn() to
** SEGV.
*/
static char **command_to_exec = NULL;

#if OPT_LUIT_PROG
static char **command_to_exec_with_luit = NULL;
#endif
d121 6
d130 5
a134 2
#ifndef CFLUSH
#define CFLUSH   CONTROL('O')
d139 2
a140 5
#ifndef CNUL
#define CNUL 0
#endif
#ifndef CQUIT
#define CQUIT    CONTROL('\\')
d145 2
a146 2
#ifndef CSTART
#define CSTART   CONTROL('Q')
d151 2
a152 8
#ifndef CSUSP
#define CSUSP    CONTROL('Z')
#endif
#ifndef CSWTCH
#define CSWTCH 0
#endif
#ifndef CWERASE
#define CWERASE  CONTROL('W')
a159 1
/* *INDENT-OFF* */
d166 1
a166 1
    { "intr",	4, 0, '\0' },	/* tchars.t_intrc ; VINTR */
d168 1
a168 1
    { "quit",	4, 0, '\0' },	/* tchars.t_quitc ; VQUIT */
d170 1
a170 1
    { "erase",	5, 0, '\0' },	/* sgttyb.sg_erase ; VERASE */
d172 1
a172 1
    { "kill",	4, 0, '\0' },	/* sgttyb.sg_kill ; VKILL */
d174 1
a174 1
    { "eof",	3, 0, '\0' },	/* tchars.t_eofc ; VEOF */
d176 1
a176 1
    { "eol",	3, 0, '\0' },	/* VEOL */
d178 1
a178 1
    { "swtch",	5, 0, '\0' },	/* VSWTCH */
d180 1
a180 1
    { "start",	5, 0, '\0' },	/* tchars.t_startc */
d182 1
a182 1
    { "stop",	4, 0, '\0' },	/* tchars.t_stopc */
d184 1
a184 1
    { "brk",	3, 0, '\0' },	/* tchars.t_brkc */
d186 1
a186 1
    { "susp",	4, 0, '\0' },	/* ltchars.t_suspc ; VSUSP */
d188 1
a188 1
    { "dsusp",	5, 0, '\0' },	/* ltchars.t_dsuspc ; VDSUSP */
d190 1
a190 1
    { "rprnt",	5, 0, '\0' },	/* ltchars.t_rprntc ; VREPRINT */
d192 1
a192 1
    { "flush",	5, 0, '\0' },	/* ltchars.t_flushc ; VDISCARD */
d194 1
a194 1
    { "weras",	5, 0, '\0' },	/* ltchars.t_werasc ; VWERASE */
d196 1
a196 1
    { "lnext",	5, 0, '\0' },	/* ltchars.t_lnextc ; VLNEXT */
d198 1
a198 1
    { NULL,	0, 0, '\0' },	/* end of data */
a199 1
/* *INDENT-ON* */
d201 1
a201 1
static int parse_tty_modes(char *s, struct _xttymodes *modelist);
d206 5
d221 33
d256 23
a278 12
static XtResource application_resources[] =
{
    Sres("name", "Name", xterm_name, DFT_TERMTYPE),
    Sres("iconGeometry", "IconGeometry", icon_geometry, NULL),
    Sres(XtNtitle, XtCTitle, title, NULL),
    Sres(XtNiconName, XtCIconName, icon_name, NULL),
    Sres("termName", "TermName", term_name, NULL),
    Sres("ttyModes", "TtyModes", tty_modes, NULL),
    Bres("hold", "Hold", hold_screen, FALSE),
    Bres("utmpInhibit", "UtmpInhibit", utmpInhibit, FALSE),
    Bres("messages", "Messages", messages, TRUE),
    Bres("sunFunctionKeys", "SunFunctionKeys", sunFunctionKeys, FALSE),
d280 2
a281 1
    Bres("sunKeyboard", "SunKeyboard", sunKeyboard, FALSE),
d284 2
a285 1
    Bres("hpFunctionKeys", "HpFunctionKeys", hpFunctionKeys, FALSE),
d287 4
a290 2
    Bres("waitForMap", "WaitForMap", wait_for_map, FALSE),
    Bres("useInsertMode", "UseInsertMode", useInsertMode, FALSE),
d292 2
a293 1
    Ires("zIconBeep", "ZIconBeep", zIconBeep, 0),
d296 2
a297 4
    Bres("sameName", "SameName", sameName, TRUE),
#endif
#if OPT_SESSION_MGT
    Bres("sessionMgt", "SessionMgt", sessionMgt, TRUE),
d300 1
d302 1
a302 2
static char *fallback_resources[] =
{
d318 1
a318 1
/* *INDENT-OFF* */
a376 4
#if OPT_C1_PRINT
{"-k8",		"*allowC1Printable", XrmoptionNoArg,	(caddr_t) "on"},
{"+k8",		"*allowC1Printable", XrmoptionNoArg,	(caddr_t) "off"},
#endif
a425 6
#if OPT_LUIT_PROG
{"-lc",		"*locale",	XrmoptionNoArg,		(caddr_t) "True"},
{"+lc",		"*locale",	XrmoptionNoArg,		(caddr_t) "False"},
{"-lcc",	"*localeFilter",XrmoptionSepArg,	(caddr_t) NULL},
{"-en",		"*locale",	XrmoptionSepArg,	(caddr_t) NULL},
#endif
a438 2
{"-cjk_width", "*cjkWidth",	XrmoptionNoArg,		(caddr_t) "on"},
{"+cjk_width", "*cjkWidth",	XrmoptionNoArg,		(caddr_t) "off"},
d443 1
a443 1
{"-ziconbeep",	"*zIconBeep",	XrmoptionSepArg,	(caddr_t) NULL},
a448 4
#if OPT_SESSION_MGT
{"-sm",		"*sessionMgt",	XrmoptionNoArg,		(caddr_t) "on"},
{"+sm",		"*sessionMgt",	XrmoptionNoArg,		(caddr_t) "off"},
#endif
a453 1
{"-into",	NULL,		XrmoptionSkipArg,	(caddr_t) NULL},
d455 1
a455 1
   standard XtOpenApplication options now */
d467 1
a467 1
static OptionHelp xtermOptions[] = {
d479 1
a479 1
{ "-/+fbb",                "turn on/off normal/bold font comparison inhibit"},
d494 1
a494 1
{ "-/+132",                "turn on/off 80/132 column switching" },
d497 2
a498 2
{ "-/+ai",                 "turn off/on active icon" },
{ "-fi fontname",          "icon font for active icon" },
d501 3
a503 3
{ "-/+bc",                 "turn on/off text cursor blinking" },
{ "-bcf milliseconds",     "time text cursor is off when blinking"},
{ "-bcn milliseconds",     "time text cursor is on when blinking"},
d511 1
a511 1
{ "-/+dc",                 "turn off/on dynamic color selection" },
d513 1
a513 1
{ "-hc color",             "selection background color" },
d518 2
a519 2
{ "-/+hold",               "turn on/off logic that retains window after exit" },
{ "-/+im",                 "use insert mode for TERMCAP" },
a520 3
#if OPT_C1_PRINT
{ "-/+k8",                 "turn on/off C1-printable classification"},
#endif
d531 1
a531 1
{ "-/+mesg",               "forbid/allow messages" },
d534 1
a534 1
{ "-/+nul",                "turn off/on display of underlining" },
d544 1
a544 1
{ "-/+rvc",                "turn off/on display of reverse as color" },
a560 4
#if OPT_LUIT_PROG
{ "-/+lc",                 "turn on/off locale mode using luit" },
{ "-lcc path",             "filename of locale converter (" DEFLOCALEFILTER ")" },
#endif
a566 1
{ "-/+cjk_width",          "turn on/off legacy CJK width convention" },
a577 1
{ "-into windowId",        "use the window id given to -into as the parent window rather than the default root window" },
a583 3
#if OPT_SESSION_MGT
{ "-/+sm",                 "turn on/off the session-management support" },
#endif
a584 1
/* *INDENT-ON* */
d601 7
a607 67
static char *message[] =
{
    "Fonts should be fixed width and, if both normal and bold are specified, should",
    "have the same size.  If only a normal font is specified, it will be used for",
    "both normal and bold text (by doing overstriking).  The -e option, if given,",
    "must appear at the end of the command line, otherwise the user's default shell",
    "will be started.  Options that start with a plus sign (+) restore the default.",
    NULL};

/*
 * Decode a key-definition.  This combines the termcap and ttyModes, for
 * comparison.  Note that octal escapes in ttyModes are done by the normal
 * resource translation.  Also, ttyModes allows '^-' as a synonym for disabled.
 */
static int
decode_keyvalue(char **ptr, int termcap)
{
    char *string = *ptr;
    int value = -1;

    TRACE(("...decode '%s'\n", string));
    if (*string == '^') {
	switch (*++string) {
	case '?':
	    value = A2E(127);
	    break;
	case '-':
	    if (!termcap) {
		errno = 0;
#if defined(_POSIX_VDISABLE) && defined(HAVE_UNISTD_H)
		value = _POSIX_VDISABLE;
#endif
#if defined(_PC_VDISABLE)
		if (value == -1) {
		    value = fpathconf(0, _PC_VDISABLE);
		    if (value == -1) {
			if (errno != 0)
			    break;	/* skip this (error) */
			value = 0377;
		    }
		}
#elif defined(VDISABLE)
		if (value == -1)
		    value = VDISABLE;
#endif
		break;
	    }
	    /* FALLTHRU */
	default:
	    value = CONTROL(*string);
	    break;
	}
	++string;
    } else if (termcap && (*string == '\\')) {
	char *d;
	int temp = strtol(string + 1, &d, 8);
	if (temp > 0 && d != string) {
	    value = temp;
	    string = d;
	}
    } else {
	value = CharOf(*string);
	++string;
    }
    *ptr = string;
    return value;
}
d609 1
a609 6
/*
 * If we're linked to terminfo, tgetent() will return an empty buffer.  We
 * cannot use that to adjust the $TERMCAP variable.
 */
static Boolean
get_termcap(char *name, char *buffer, char *resized)
d613 1
a613 1
    *buffer = 0;		/* initialize, in case we're using terminfo's tgetent */
d616 1
a616 1
	if (tgetent(buffer, name) == 1) {
d618 3
a620 3
		   (*buffer
		    ? "ok:termcap, we can update $TERMCAP"
		    : "assuming this is terminfo")));
d623 1
a623 1
		    resize(screen, buffer, resized);
d634 1
a634 2
static int
abbrev(char *tst, char *cmp, size_t need)
d636 2
a637 2
    size_t len = strlen(tst);
    return ((len >= need) && (!strncmp(tst, cmp, len)));
d640 1
a640 2
static void
Syntax(char *badOption)
a642 1
    OptionHelp *list = sortedOpts(xtermOptions, optionDescList, XtNumber(optionDescList));
d645 2
a646 2
    fprintf(stderr, "%s:  bad command line option \"%s\"\r\n\n",
	    ProgramName, badOption);
d648 1
a648 1
    fprintf(stderr, "usage:  %s", ProgramName);
d650 2
a651 2
    for (opt = list; opt->opt; opt++) {
	int len = 3 + strlen(opt->opt);		/* space [ string ] */
d653 1
a653 1
	    fprintf(stderr, "\r\n   ");		/* 3 spaces */
d656 1
a656 1
	fprintf(stderr, " [%s]", opt->opt);
d660 3
a662 3
    fprintf(stderr, "\r\n\nType %s -help for a full description.\r\n\n",
	    ProgramName);
    exit(1);
d665 1
a665 2
static void
Version(void)
d671 1
a671 2
static void
Help(void)
a673 1
    OptionHelp *list = sortedOpts(xtermOptions, optionDescList, XtNumber(optionDescList));
d676 5
a680 6
    fprintf(stderr,
	    "%s(%d) usage:\n    %s [-options ...] [-e command args]\n\n",
	    XFREE86_VERSION, XTERM_PATCH, ProgramName);
    fprintf(stderr, "where options include:\n");
    for (opt = list; opt->opt; opt++) {
	fprintf(stderr, "    %-28s %s\n", opt->opt, opt->desc);
d683 1
a683 1
    putc('\n', stderr);
d685 2
a686 2
	fputs(*cpp, stderr);
	putc('\n', stderr);
d688 1
a688 1
    putc('\n', stderr);
d694 8
a701 7
ConvertConsoleSelection(Widget w GCC_UNUSED,
			Atom * selection GCC_UNUSED,
			Atom * target GCC_UNUSED,
			Atom * type GCC_UNUSED,
			XtPointer * value GCC_UNUSED,
			unsigned long *length GCC_UNUSED,
			int *format GCC_UNUSED)
d707 5
a711 19
#if OPT_SESSION_MGT
static void
die_callback(Widget w GCC_UNUSED,
	     XtPointer client_data GCC_UNUSED,
	     XtPointer call_data GCC_UNUSED)
{
    Cleanup(0);
}

static void
save_callback(Widget w GCC_UNUSED,
	      XtPointer client_data GCC_UNUSED,
	      XtPointer call_data)
{
    XtCheckpointToken token = (XtCheckpointToken) call_data;
    /* we have nothing to save */
    token->save_success = True;
}
#endif /* OPT_SESSION_MGT */
d713 1
a713 3
#if OPT_WIDE_CHARS
int (*my_wcwidth) (wchar_t);
#endif
d720 5
a724 4
DeleteWindow(Widget w,
	     XEvent * event GCC_UNUSED,
	     String * params GCC_UNUSED,
	     Cardinal * num_params GCC_UNUSED)
d727 8
a734 7
    if (w == toplevel) {
	if (term->screen.Tshow)
	    hide_vt_window();
	else
	    do_hangup(w, (XtPointer) 0, (XtPointer) 0);
    } else if (term->screen.Vshow)
	hide_tek_window();
d737 1
a737 1
	do_hangup(w, (XtPointer) 0, (XtPointer) 0);
d742 5
a746 4
KeyboardMapping(Widget w GCC_UNUSED,
		XEvent * event,
		String * params GCC_UNUSED,
		Cardinal * num_params GCC_UNUSED)
d749 3
a751 3
    case MappingNotify:
	XRefreshKeyboardMapping(&event->xmapping);
	break;
d755 10
a764 1
XtActionsRec actionProcs[] =
d766 73
a838 3
    {"DeleteWindow", DeleteWindow},
    {"KeyboardMapping", KeyboardMapping},
};
d844 1
a844 1
main(int argc, char **argv ENVP_ARG)
d846 31
a876 26
    Widget form_top, menu_top;
    register TScreen *screen;
    int mode;
    char *my_class = DEFCLASS;
    Window winToEmbedInto = None;

    /* Do these first, since we may not be able to open the display */
    ProgramName = argv[0];
    TRACE_OPTS(xtermOptions, optionDescList, XtNumber(optionDescList));
    TRACE_ARGV("Before XtOpenApplication", argv);
    if (argc > 1) {
	int n;
	int unique = 2;
	Boolean quit = True;

	for (n = 1; n < argc; n++) {
	    TRACE(("parsing %s\n", argv[n]));
	    if (abbrev(argv[n], "-version", unique)) {
		Version();
	    } else if (abbrev(argv[n], "-help", unique)) {
		Help();
	    } else if (abbrev(argv[n], "-class", 3)) {
		if ((my_class = argv[++n]) == 0) {
		    Help();
		} else {
		    quit = False;
d878 2
a879 5
		unique = 3;
	    } else {
		quit = False;
		unique = 3;
	    }
a880 3
	if (quit)
	    exit(0);
    }
d882 4
a885 4
    /* XXX: for some obscure reason EMX seems to lose the value of
     * the environ variable, don't understand why, so save it recently
     */
    gblenvp = envp;
d888 1
a888 1
    setlocale(LC_ALL, NULL);
d893 11
a903 10
    ttydev = (char *) malloc(PTMS_BUFSZ);
    ptydev = (char *) malloc(PTMS_BUFSZ);
    if (!ttydev || !ptydev) {
	fprintf(stderr,
		"%s:  unable to allocate memory for ttydev or ptydev\n",
		ProgramName);
	exit(1);
    }
    strcpy(ttydev, TTYDEV);
    strcpy(ptydev, PTYDEV);
d905 31
a935 38
    /* Initialization is done here rather than above in order
     * to prevent any assumptions about the order of the contents
     * of the various terminal structures (which may change from
     * implementation to implementation).
     */
    d_tio.c_iflag = ICRNL | IXON;
    d_tio.c_oflag = OPOST | ONLCR | TAB3;
    d_tio.c_cflag = B38400 | CS8 | CREAD | PARENB | HUPCL;
    d_tio.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK;
    d_tio.c_line = 0;
    d_tio.c_cc[VINTR] = CONTROL('C');	/* '^C' */
    d_tio.c_cc[VERASE] = 0x7f;	/* DEL  */
    d_tio.c_cc[VKILL] = CONTROL('U');	/* '^U' */
    d_tio.c_cc[VQUIT] = CQUIT;	/* '^\' */
    d_tio.c_cc[VEOF] = CEOF;	/* '^D' */
    d_tio.c_cc[VEOL] = CEOL;	/* '^@@' */

    /* Init the Toolkit. */
    XtSetErrorHandler(xt_error);
#if OPT_SESSION_MGT
    toplevel = XtOpenApplication(&app_con, my_class,
				 optionDescList,
				 XtNumber(optionDescList),
				 &argc, argv, fallback_resources,
				 sessionShellWidgetClass,
				 NULL, 0);
#else
    toplevel = XtAppInitialize(&app_con, my_class,
			       optionDescList,
			       XtNumber(optionDescList),
			       &argc, argv, fallback_resources,
			       NULL, 0);
#endif /* OPT_SESSION_MGT */
    XtSetErrorHandler((XtErrorHandler) 0);

    XtGetApplicationResources(toplevel, (XtPointer) & resource,
			      application_resources,
			      XtNumber(application_resources), NULL, 0);
d937 1
a937 1
    waiting_for_initial_map = resource.wait_for_map;
d939 4
a942 4
    /*
     * ICCCM delete_window.
     */
    XtAppAddActions(app_con, actionProcs, XtNumber(actionProcs));
d944 11
a954 10
    /*
     * fill in terminal modes
     */
    if (resource.tty_modes) {
	int n = parse_tty_modes(resource.tty_modes, ttymodelist);
	if (n < 0) {
	    fprintf(stderr, "%s:  bad tty modes \"%s\"\n",
		    ProgramName, resource.tty_modes);
	} else if (n > 0) {
	    override_tty_modes = 1;
d956 1
a956 1
    }
d958 6
a963 7
    zIconBeep = resource.zIconBeep;
    zIconBeep_flagged = False;
    if (zIconBeep > 100 || zIconBeep < -100) {
	zIconBeep = 0;		/* was 100, but I prefer to defaulting off. */
	fprintf(stderr,
		"a number between -100 and 100 is required for zIconBeep.  0 used by default\n");
    }
d966 1
a966 1
    sameName = resource.sameName;
d968 20
a987 21
    hold_screen = resource.hold_screen ? 1 : 0;
    xterm_name = resource.xterm_name;
    if (strcmp(xterm_name, "-") == 0)
	xterm_name = DFT_TERMTYPE;
    if (resource.icon_geometry != NULL) {
	int scr, junk;
	int ix, iy;
	Arg args[2];

	for (scr = 0;		/* yyuucchh */
	     XtScreen(toplevel) != ScreenOfDisplay(XtDisplay(toplevel), scr);
	     scr++) ;

	args[0].name = XtNiconX;
	args[1].name = XtNiconY;
	XGeometry(XtDisplay(toplevel), scr, resource.icon_geometry, "",
		  0, 0, 0, 0, 0, &ix, &iy, &junk, &junk);
	args[0].value = (XtArgVal) ix;
	args[1].value = (XtArgVal) iy;
	XtSetValues(toplevel, args, 2);
    }
d989 2
a990 2
    XtSetValues(toplevel, ourTopLevelShellArgs,
		number_ourTopLevelShellArgs);
d993 2
a994 2
    /* seems as good a place as any */
    init_classtab();
d997 33
a1029 33
    /* Parse the rest of the command line */
    TRACE_ARGV("After XtOpenApplication", argv);
    for (argc--, argv++; argc > 0; argc--, argv++) {
	if (**argv != '-')
	    Syntax(*argv);

	TRACE(("parsing %s\n", argv[0]));
	switch (argv[0][1]) {
	case 'h':		/* -help */
	    Help();
	    continue;
	case 'v':		/* -version */
	    Version();
	    continue;
	case 'C':
	    {
		struct stat sbuf;

		/* Must be owner and have read/write permission.
		   xdm cooperates to give the console the right user. */
		if (!stat("/dev/console", &sbuf) &&
		    (sbuf.st_uid == getuid()) &&
		    !access("/dev/console", R_OK | W_OK)) {
		    Console = TRUE;
		} else
		    Console = FALSE;
	    }
	    continue;
	case 'S':
	    if (sscanf(*argv + 2, "%c%c%d", passedPty, passedPty + 1,
		       &am_slave) != 3)
		Syntax(*argv);
	    continue;
d1031 5
a1035 6
	case 'D':
	    debug = TRUE;
	    continue;
#endif /* DEBUG */
	case 'c':		/* -class param */
	    if (strcmp(argv[0] + 1, "class") == 0)
d1037 7
a1043 16
	    else
		Syntax(*argv);
	    continue;
	case 'e':
	    if (argc <= 1)
		Syntax(*argv);
	    command_to_exec = ++argv;
	    break;
	case 'i':
	    if (argc <= 1) {
		Syntax(*argv);
	    } else {
		char *endPtr;
		--argc;
		++argv;
		winToEmbedInto = (Window) strtol(argv[0], &endPtr, 10);
d1046 1
d1048 11
a1058 2
	default:
	    Syntax(*argv);
d1060 1
a1060 2
	break;
    }
d1062 1
a1062 1
    SetupMenus(toplevel, &form_top, &menu_top);
d1064 2
a1065 2
    term = (XtermWidget) XtVaCreateManagedWidget("vt100", xtermWidgetClass,
						 form_top,
d1067 6
a1072 6
						 XtNmenuBar, menu_top,
						 XtNresizable, True,
						 XtNfromVert, menu_top,
						 XtNleft, XawChainLeft,
						 XtNright, XawChainRight,
						 XtNbottom, XawChainBottom,
d1074 2
a1075 2
						 (XtPointer) 0);
    /* this causes the initialize method to be called */
d1078 1
a1078 1
    init_keyboard_type(keyboardIsHP, resource.hpFunctionKeys);
d1080 1
a1080 1
    init_keyboard_type(keyboardIsSun, resource.sunFunctionKeys);
d1082 1
a1082 1
    init_keyboard_type(keyboardIsVT220, resource.sunKeyboard);
d1085 1
a1085 1
    screen = &term->screen;
d1087 1
a1087 1
    inhibit = 0;
d1089 1
a1089 2
    if (term->misc.logInhibit)
	inhibit |= I_LOG;
d1091 1
a1091 2
    if (term->misc.signalInhibit)
	inhibit |= I_SIGNAL;
d1093 1
a1093 2
    if (term->misc.tekInhibit)
	inhibit |= I_TEK;
d1096 3
a1098 5
#if OPT_WIDE_CHARS
    my_wcwidth = &mk_wcwidth;
    if (term->misc.cjk_width)
	my_wcwidth = &mk_wcwidth_cjk;
#endif
d1100 2
a1101 7
#if OPT_SESSION_MGT
    if (resource.sessionMgt) {
	TRACE(("Enabling session-management callbacks\n"));
	XtAddCallback(toplevel, XtNdieCallback, die_callback, NULL);
	XtAddCallback(toplevel, XtNsaveCallback, save_callback, NULL);
    }
#endif
d1103 5
a1107 5
    /*
     * Set title and icon name if not specified
     */
    if (command_to_exec) {
	Arg args[2];
d1109 9
a1117 15
	if (!resource.title) {
	    if (command_to_exec) {
		resource.title = x_basename(command_to_exec[0]);
	    }			/* else not reached */
	}

	if (!resource.icon_name)
	    resource.icon_name = resource.title;
	XtSetArg(args[0], XtNtitle, resource.title);
	XtSetArg(args[1], XtNiconName, resource.icon_name);

	TRACE(("setting:\n\ttitle \"%s\"\n\ticon \"%s\"\n\tbased on command \"%s\"\n",
	       resource.title,
	       resource.icon_name,
	       *command_to_exec));
d1119 1
a1119 30
	XtSetValues(toplevel, args, 2);
    }
#if OPT_LUIT_PROG
    if (term->misc.callfilter) {
	int u = (term->misc.use_encoding ? 2 : 0);
	if (command_to_exec) {
	    int n;
	    char **c;
	    for (n = 0, c = command_to_exec; *c; n++, c++) ;
	    c = malloc((n + 3 + u) * sizeof(char *));
	    if (c == NULL)
		SysError(ERROR_LUMALLOC);
	    memcpy(c + 2 + u, command_to_exec, (n + 1) * sizeof(char *));
	    c[0] = term->misc.localefilter;
	    if (u) {
		c[1] = "-encoding";
		c[2] = term->misc.locale_str;
	    }
	    c[1 + u] = "--";
	    command_to_exec_with_luit = c;
	} else {
	    static char *luit[4];
	    luit[0] = term->misc.localefilter;
	    if (u) {
		luit[1] = "-encoding";
		luit[2] = term->misc.locale_str;
		luit[3] = NULL;
	    } else
		luit[1] = NULL;
	    command_to_exec_with_luit = luit;
d1121 1
a1121 2
    }
#endif
d1123 2
a1124 2
    if (inhibit & I_TEK)
	screen->TekEmu = FALSE;
d1126 2
a1127 2
    if (screen->TekEmu && !TekInit())
	exit(ERROR_INIT);
d1133 2
a1134 2
	   done securely by a privileged xterm process (although we try),
	   so the debug feature is disabled by default. */
d1136 3
a1138 3
	if (debug) {
	    creat_as(getuid(), getgid(), True, "xterm.debug.log", 0666);
	    i = open("xterm.debug.log", O_WRONLY | O_TRUNC);
d1140 2
a1141 2
	if (i >= 0) {
	    dup2(i, 2);
d1143 2
a1144 2
	    /* mark this file as close on exec */
	    (void) fcntl(i, F_SETFD, 1);
d1147 1
a1147 1
#endif /* DEBUG */
d1149 2
a1150 2
    /* open a terminal for client */
    get_terminal();
d1152 1
a1152 1
    spawn();
d1154 2
a1155 2
    /* Child process is out there, let's catch its termination */
    (void) signal(SIGCHLD, reapchild);
d1157 1
a1157 1
    /* Realize procs have now been executed */
d1159 2
a1160 2
    if (am_slave >= 0) {	/* Write window id so master end can read and use */
	char buf[80];
d1162 4
a1165 4
	buf[0] = '\0';
	sprintf(buf, "%lx\n", XtWindow(XtParent(CURRENT_EMU(screen))));
	write(screen->respond, buf, strlen(buf));
    }
d1167 1
a1167 1
    screen->inhibit = inhibit;
d1169 17
a1185 17
    if (0 > (mode = fcntl(screen->respond, F_GETFL, 0)))
	SysError(ERROR_F_GETFL);
    mode |= O_NDELAY;

    if (fcntl(screen->respond, F_SETFL, mode))
	SysError(ERROR_F_SETFL);

    FD_ZERO(&pty_mask);
    FD_ZERO(&X_mask);
    FD_ZERO(&Select_mask);
    FD_SET(screen->respond, &pty_mask);
    FD_SET(ConnectionNumber(screen->display), &X_mask);
    FD_SET(screen->respond, &Select_mask);
    FD_SET(ConnectionNumber(screen->display), &Select_mask);
    max_plus1 = ((screen->respond < ConnectionNumber(screen->display))
		 ? (1 + ConnectionNumber(screen->display))
		 : (1 + screen->respond));
d1188 4
a1191 5
    if (debug)
	printf("debugging on\n");
#endif /* DEBUG */
    XSetErrorHandler(xerror);
    XSetIOErrorHandler(xioerror);
d1194 3
a1196 3
    if (term->misc.log_on) {
	StartLog(screen);
    }
d1198 1
a1198 14

    if (winToEmbedInto != None) {
	XtRealizeWidget(toplevel);
	/*
	 * This should probably query the tree or check the attributes of
	 * winToEmbedInto in order to verify that it exists, but I'm still not
	 * certain what is the best way to do it -GPS
	 */
	XReparentWindow(XtDisplay(toplevel),
			XtWindow(toplevel),
			winToEmbedInto, 0, 0);
    }

    for (;;) {
d1200 3
a1202 3
	if (screen->TekEmu)
	    TekRun();
	else
d1204 3
a1206 3
	    VTRun();
    }
    return 0;
d1218 1
a1218 1
    char namebuf[PTMS_BUFSZ];
d1220 8
a1227 8
    /* ask the PTY manager */
    int fd = open("/dev/ptms$", 0);
    if (fd && ptioctl(fd, PTMS_GETPTY, namebuf) == 0) {
	strcpy(ttydev, namebuf);
	strcpy(ptydev, namebuf);
	*x_basename(ttydev) = 't';
	close(fd);
	if ((*pty = open(ptydev, O_RDWR)) >= 0) {
d1229 1
a1229 1
	    ptioctl(*pty, XTY_TRACE, 0);
d1231 2
a1232 3
	    return 0;
	} else {
	    fprintf(stderr, "Unable to open %s, errno=%d\n", ptydev, errno);
d1234 1
a1234 2
    }
    return 1;
d1246 1
a1246 1
get_pty(int *pty)
d1248 1
a1248 1
    return pty_search(pty);
d1255 1
a1255 1
get_terminal(void)
d1257 1
a1257 1
    register TScreen *screen = &term->screen;
d1259 3
a1261 3
    screen->arrow = make_colored_cursor(XC_left_ptr,
					screen->mousecolor,
					screen->mousecolorback);
d1278 8
a1285 9
static char *tekterm[] =
{
    "tek4014",
    "tek4015",			/* 4014 with APL character set support */
    "tek4012",			/* 4010 with lower case */
    "tek4013",			/* 4012 with APL character set support */
    "tek4010",			/* small screen, upper-case only */
    "dumb",
    0
d1296 1
a1296 2
static char *vtterm[] =
{
d1298 1
a1298 1
    "x11term",			/* for people who want special term name */
d1300 7
a1306 7
    DFT_TERMTYPE,		/* for people who want special term name */
    "xterm",			/* the prefered name, should be fastest */
    "vt102",
    "vt100",
    "ansi",
    "dumb",
    0
d1310 1
a1310 2
static SIGNAL_T
hungtty(int i GCC_UNUSED)
d1312 2
a1313 2
    longjmp(env, 1);
    SIGNAL_RETURN;
d1317 3
a1319 3
    int rows;
    int cols;
} handshake = {
d1321 1
a1321 5
    -1, -1
};

void
first_map_occurred(void)
a1328 13
static void
set_owner(char *device, int uid, int gid, int mode)
{
    if (chown(device, uid, gid) < 0) {
	if (errno != ENOENT
	    && getuid() == 0) {
	    fprintf(stderr, "Cannot chown %s to %d,%d: %s\n",
		    device, uid, gid, strerror(errno));
	}
    }
    chmod(device, mode);
}

d1333 1
a1333 2
SIGNAL_T
killit(int sig)
d1335 17
a1351 17
    switch (whoami) {
    case -1:
	signal(sig, killit);
	kill(-getpid(), sig);
	break;
    case THE_PARENT:
	wait(NULL);
	signal(SIGTERM, SIG_DFL);
	kill(-getpid(), SIGTERM);
	Exit(0);
	break;
    case THE_CHILD:
	signal(SIGTERM, SIG_DFL);
	kill(-getppid(), SIGTERM);
	Exit(0);
	break;
    }
d1353 1
a1353 1
    SIGNAL_RETURN;
d1357 1
a1357 1
spawn(void)
d1364 2
a1365 2
    register TScreen *screen = &term->screen;
    int Xsocket = ConnectionNumber(screen->display);
d1367 22
a1388 33
    int tty = -1;
    struct termio tio;
    int status;

    char termcap[TERMCAP_SIZE], newtc[TERMCAP_SIZE];
    char *TermName = NULL;
    char *ptr, *shname, buf[64];
    int i, no_dev_tty = FALSE, envsize;
    char *dev_tty_name = (char *) 0;
    TTYSIZE_STRUCT ts;
    int pgrp = getpid();
    char numbuf[12], **envnew;

    screen->uid = getuid();
    screen->gid = getgid();

    if (am_slave >= 0) {
	screen->respond = am_slave;
	ptydev[strlen(ptydev) - 2] =
	    ttydev[strlen(ttydev) - 2] = passedPty[0];
	ptydev[strlen(ptydev) - 1] =
	    ttydev[strlen(ttydev) - 1] = passedPty[1];

	setgid(screen->gid);
	setuid(screen->uid);
    } else {
	Bool tty_got_hung;

	/*
	 * Sometimes /dev/tty hangs on open (as in the case of a pty
	 * that has gone away).  Simply make up some reasonable
	 * defaults.
	 */
d1390 2
a1391 6
	signal(SIGALRM, hungtty);
	alarm(2);		/* alarm(1) might return too soon */
	if (!setjmp(env)) {
	    tty = open("/dev/tty", O_RDWR);
	    alarm(0);
	    tty_got_hung = False;
d1393 1
a1393 5
	    tty_got_hung = True;
	    tty = -1;
	    errno = ENXIO;
	}
	signal(SIGALRM, SIG_DFL);
d1395 18
a1412 15
	/*
	 * Check results and ignore current control terminal if
	 * necessary.  ENXIO is what is normally returned if there is
	 * no controlling terminal, but some systems (e.g. SunOS 4.0)
	 * seem to return EIO.  Solaris 2.3 is said to return EINVAL.
	 */
	if (tty < 0) {
	    if (tty_got_hung || errno == ENXIO || errno == EIO ||
		errno == EINVAL || errno == ENOTTY) {
		no_dev_tty = TRUE;
		tio = d_tio;
	    } else {
		SysError(ERROR_OPDEVTTY);
	    }
	} else {
d1414 28
a1441 8
	    /* Get a copy of the current terminal's state,
	     * if we can.  Some systems (e.g., SVR4 and MacII)
	     * may not have a controlling terminal at this point
	     * if started directly from xdm or xinit,
	     * in which case we just use the defaults as above.
	     */
	    if (ioctl(tty, TCGETA, &tio) == -1)
		tio = d_tio;
d1443 4
a1446 3
	    close(tty);
	    /* tty is no longer an open fd! */
	    tty = -1;
d1449 2
a1450 5
	if (get_pty(&screen->respond)) {
	    /*  no ptys! */
	    exit(ERROR_PTYS);
	}
    }
d1452 2
a1453 2
    /* avoid double MapWindow requests */
    XtSetMappedWhenManaged(XtParent(CURRENT_EMU(screen)), False);
d1455 2
a1456 2
    wm_delete_window = XInternAtom(XtDisplay(toplevel), "WM_DELETE_WINDOW",
				   False);
d1458 23
a1480 2
    if (!TEK4014_ACTIVE(screen))
	VTInit();		/* realize now so know window size for tty driver */
a1481 1
    if (Console) {
d1483 4
a1486 2
	 * Inform any running xconsole program
	 * that we are going to steal the console.
d1488 1
a1488 17
	XmuGetHostname(mit_console_name + MIT_CONSOLE_LEN, 255);
	mit_console = XInternAtom(screen->display, mit_console_name, False);
	/* the user told us to be the console, so we can use CurrentTime */
	XtOwnSelection(XtParent(CURRENT_EMU(screen)),
		       mit_console, CurrentTime,
		       ConvertConsoleSelection, NULL, NULL);
    }
#if OPT_TEK4014
    if (screen->TekEmu) {
	envnew = tekterm;
	ptr = newtc;
    } else
#endif
    {
	envnew = vtterm;
	ptr = termcap;
    }
d1490 12
a1501 14
    /*
     * This used to exit if no termcap entry was found for the specified
     * terminal name.  That's a little unfriendly, so instead we'll allow
     * the program to proceed (but not to set $TERMCAP) if the termcap
     * entry is not found.
     */
    if (!get_termcap(TermName = resource.term_name, ptr, newtc)) {
	char *last = NULL;
	TermName = *envnew;
	while (*envnew != NULL) {
	    if ((last == NULL || strcmp(last, *envnew))
		&& get_termcap(*envnew, ptr, newtc)) {
		TermName = *envnew;
		break;
a1502 2
	    last = *envnew;
	    envnew++;
a1503 1
    }
d1505 1
a1505 1
    /* tell tty how big window is */
d1507 13
a1519 13
    if (TEK4014_ACTIVE(screen)) {
	TTYSIZE_ROWS(ts) = 38;
	TTYSIZE_COLS(ts) = 81;
	ts.ws_xpixel = TFullWidth(screen);
	ts.ws_ypixel = TFullHeight(screen);
    } else
#endif
    {
	TTYSIZE_ROWS(ts) = screen->max_row + 1;
	TTYSIZE_COLS(ts) = screen->max_col + 1;
	ts.ws_xpixel = FullWidth(screen);
	ts.ws_ypixel = FullHeight(screen);
    }
d1521 1
a1521 1
    if (am_slave < 0) {
d1523 19
a1541 19
	char sema[40];
	HEV sev;
	/* start a child process
	 * use an event sema for sync
	 */
	sprintf(sema, "\\SEM32\\xterm%s", &ptydev[8]);
	if (DosCreateEventSem(sema, &sev, DC_SEM_SHARED, FALSE))
	    SysError(ERROR_FORK);

	switch ((screen->pid = fork())) {
	case -1:		/* error */
	    SysError(ERROR_FORK);
	default:		/* parent */
	    whoami = THE_PARENT;
	    DosWaitEventSem(sev, 1000L);
	    DosCloseEventSem(sev);
	    break;
	case 0:		/* child */
	    whoami = THE_CHILD;
d1545 16
a1560 16
	    /* we don't need the socket, or the pty master anymore */
	    close(ConnectionNumber(screen->display));
	    close(screen->respond);

	    /* Now is the time to set up our process group and
	     * open up the pty slave.
	     */
	    if ((tty = open(ttydev, O_RDWR)) < 0) {
		/* dumm gelaufen */
		fprintf(stderr, "Cannot open slave side of PTY\n");
		exit(1);
	    }

	    /* use the same tty name that everyone else will use
	     * (from ttyname)
	     */
d1562 7
a1568 9
	    if ((ptr = ttyname(tty)) != 0) {
		/* it may be bigger */
		ttydev = realloc(ttydev,
				 (unsigned) (strlen(ptr) + 1));
		if (ttydev == NULL) {
		    SysError(ERROR_SPREALLOC);
		}
		(void) strcpy(ttydev, ptr);
	    }
d1570 1
a1570 1
	    ptr = ttydev;
d1572 2
a1573 70
	    /* for safety: enable DUPs */
	    ptioctl(tty, XTY_ENADUP, 0);

	    /* change ownership of tty to real group and user id */
	    set_owner(ttydev, screen->uid, screen->gid,
		      (resource.messages ? 0622 : 0600));

	    /* for the xf86sup-pty, we set the pty to bypass: OS/2 does
	     * not have a line discipline structure
	     */
	    {
		struct termio t, t1;
		if (ptioctl(tty, TCGETA, (char *) &t) < 0)
		    t = d_tio;

		t.c_iflag = ICRNL;
		t.c_oflag = OPOST | ONLCR;
		t.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK;

		/* ignore error code, user will see it :-) */
		ptioctl(tty, TCSETA, (char *) &t);

		/* set the console mode */
		if (Console) {
		    int on = 1;
		    if (ioctl(tty, TIOCCONS, (char *) &on) == -1)
			fprintf(stderr, "%s: cannot open console\n", xterm_name);
		}
	    }

	    signal(SIGCHLD, SIG_DFL);
	    signal(SIGHUP, SIG_IGN);

	    /* restore various signals to their defaults */
	    signal(SIGINT, SIG_DFL);
	    signal(SIGQUIT, SIG_DFL);
	    signal(SIGTERM, SIG_DFL);

	    /* copy the environment before Setenving */
	    for (i = 0; gblenvp[i] != NULL; i++) ;

	    /* compute number of xtermSetenv() calls below */
	    envsize = 1;	/* (NULL terminating entry) */
	    envsize += 3;	/* TERM, WINDOWID, DISPLAY */
	    envsize += 2;	/* COLUMNS, LINES */

	    envnew = (char **) calloc((unsigned) i + envsize, sizeof(char *));
	    memmove((char *) envnew, (char *) gblenvp, i * sizeof(char *));
	    gblenvp = envnew;
	    xtermSetenv("TERM=", TermName);
	    if (!TermName)
		*newtc = 0;

	    sprintf(buf, "%lu",
		    ((unsigned long) XtWindow(XtParent(CURRENT_EMU(screen)))));
	    xtermSetenv("WINDOWID=", buf);

	    /* put the display into the environment of the shell */
	    xtermSetenv("DISPLAY=", XDisplayString(screen->display));

	    signal(SIGTERM, SIG_DFL);

	    /* this is the time to go and set up stdin, out, and err
	     */
	    /* dup the tty */
	    for (i = 0; i <= 2; i++)
		if (i != tty) {
		    (void) close(i);
		    (void) dup(tty);
		}
d1575 2
a1576 64
	    /* and close the tty */
	    if (tty > 2)
		(void) close(tty);

	    setpgrp(0, pgrp);
	    setgid(screen->gid);
	    setuid(screen->uid);

	    if (handshake.rows > 0 && handshake.cols > 0) {
		screen->max_row = handshake.rows;
		screen->max_col = handshake.cols;
		TTYSIZE_ROWS(ts) = screen->max_row + 1;
		TTYSIZE_COLS(ts) = screen->max_col + 1;
		ts.ws_xpixel = FullWidth(screen);
		ts.ws_ypixel = FullHeight(screen);
	    }

	    sprintf(numbuf, "%d", screen->max_col + 1);
	    xtermSetenv("COLUMNS=", numbuf);
	    sprintf(numbuf, "%d", screen->max_row + 1);
	    xtermSetenv("LINES=", numbuf);

	    /* reconstruct dead environ variable */
	    environ = gblenvp;

	    /* need to reset after all the ioctl bashing we did above */
	    ptioctl(0, TIOCSWINSZ, (char *) &ts);

	    signal(SIGHUP, SIG_DFL);

	    /* okay everything seems right, so tell the parent, we are going */
	    {
		char sema[40];
		HEV sev;
		sprintf(sema, "\\SEM32\\xterm%s", &ttydev[8]);
		DosOpenEventSem(sema, &sev);
		DosPostEventSem(sev);
		DosCloseEventSem(sev);
	    }

#if OPT_LUIT_PROG
	    /*
	     * Use two copies of command_to_exec, in case luit is not actually
	     * there, or refuses to run.  In that case we will fall-through to
	     * to command that the user gave anyway.
	     */
	    if (command_to_exec_with_luit) {
		TRACE(("spawning command \"%s\"\n", *command_to_exec_with_luit));
		execvp(*command_to_exec_with_luit, command_to_exec_with_luit);
		/* print error message on screen */
		fprintf(stderr, "%s: Can't execvp %s: %s\n",
			xterm_name, *command_to_exec_with_luit, strerror(errno));
		fprintf(stderr, "%s: cannot support your locale.\n",
			xterm_name);
	    }
#endif
	    if (command_to_exec) {
		TRACE(("spawning command \"%s\"\n", *command_to_exec));
		execvpe(*command_to_exec, command_to_exec, gblenvp);

		/* print error message on screen */
		fprintf(stderr, "%s: Can't execvp %s\n",
			xterm_name, *command_to_exec);
	    }
d1578 139
a1716 24
	    /* use a layered mechanism to find a shell */
	    ptr = getenv("X11SHELL");
	    if (!ptr)
		ptr = getenv("SHELL");
	    if (!ptr)
		ptr = getenv("OS2_SHELL");
	    if (!ptr)
		ptr = "SORRY_NO_SHELL_FOUND";

	    shname = x_basename(ptr);
	    if (command_to_exec) {
		char *exargv[10];	/*XXX */

		exargv[0] = ptr;
		exargv[1] = "/C";
		exargv[2] = command_to_exec[0];
		exargv[3] = command_to_exec[1];
		exargv[4] = command_to_exec[2];
		exargv[5] = command_to_exec[3];
		exargv[6] = command_to_exec[4];
		exargv[7] = command_to_exec[5];
		exargv[8] = command_to_exec[6];
		exargv[9] = 0;
		execvpe(exargv[0], exargv, gblenvp);
d1718 2
a1719 1
		execvpe(*command_to_exec, command_to_exec, gblenvp);
d1721 18
a1738 14
		/* print error message on screen */
		fprintf(stderr, "%s: Can't execvp %s\n",
			xterm_name, *command_to_exec);
	    } else {
		execlpe(ptr, shname, 0, gblenvp);

		/* Exec failed. */
		fprintf(stderr, "%s: Could not exec %s!\n",
			xterm_name, ptr);
	    }
	    sleep(5);

	    /* preventively shoot the parent */
	    kill(-getppid(), SIGTERM);
d1740 1
a1740 5
	    exit(ERROR_EXEC);
	}			/* endcase */
    }
    /* !am_slave */
    signal(SIGHUP, SIG_IGN);
d1748 9
a1756 9
/*  signal (SIGINT, SIG_IGN);*/
    signal(SIGINT, killit);
    signal(SIGTERM, killit);

    /* hung shell problem */
    signal(SIGQUIT, SIG_IGN);
/*  signal (SIGTERM, SIG_IGN);*/
    return 0;
}				/* end spawn */
d1761 3
a1763 3
    register TScreen *screen = &term->screen;
    int pty = term->screen.respond;	/* file descriptor of pty */
    close(pty);			/* close explicitly to avoid race with slave side */
d1765 2
a1766 2
    if (screen->logging)
	CloseLog(screen);
d1768 11
a1778 7
    if (am_slave < 0) {
	/* restore ownership of tty and pty */
	set_owner(ttydev, 0, 0, 0666);
	set_owner(ptydev, 0, 0, 0666);
    }
    exit(n);
    SIGNAL_RETURN;
d1783 1
a1783 1
resize(TScreen * screen, register char *oldtc, char *newtc)
d1795 1
a1795 1
    pid_t pid;
d1797 2
a1798 2
    pid = waitpid(-1, NULL, WNOHANG);
    return pid;
d1802 1
a1802 2
static SIGNAL_T
reapchild(int n GCC_UNUSED)
a1803 1
    int olderrno = errno;
d1816 1
a1816 2
	    if (debug)
		fputs("Exiting\n", stderr);
d1819 1
a1819 1
		Cleanup(0);
d1821 1
a1821 1
    } while ((pid = nonblocking_wait()) > 0);
a1822 1
    errno = olderrno;
d1834 1
a1834 2
static int
parse_tty_modes(char *s, struct _xttymodes *modelist)
a1839 1
    TRACE(("parse_tty_modes\n"));
d1841 2
a1842 4
	while (*s && isascii(CharOf(*s)) && isspace(CharOf(*s)))
	    s++;
	if (!*s)
	    return count;
d1845 1
a1845 2
	    if (strncmp(s, mp->name, mp->len) == 0)
		break;
d1847 1
a1847 2
	if (!mp->name)
	    return -1;
d1850 4
a1853 1
	while (*s && isascii(CharOf(*s)) && isspace(CharOf(*s)))
d1855 12
a1866 8
	if (!*s)
	    return -1;

	if ((c = decode_keyvalue(&s, False)) != -1) {
	    mp->value = c;
	    mp->set = 1;
	    count++;
	    TRACE(("...parsed #%d: %s=%#x\n", count, mp->name, c));
d1868 4
d1875 1
a1875 2
int
GetBytesAvailable(int fd)
d1878 1
a1878 1
    ioctl(fd, FIONREAD, (char *) &arg);
d1888 1
a1888 78
    return kill(-pid, sig);
}

int
ptioctl(int fd, int func, void *data)
{
    APIRET rc;
    ULONG len;
    struct pt_termios pt;
    struct termio *t;
    int i;

    switch (func) {
    case TCGETA:
	rc = DosDevIOCtl(fd, XFREE86_PTY, func,
			 NULL, 0, NULL,
			 (ULONG *) & pt, sizeof(struct pt_termios), &len);
	if (rc)
	    return -1;
	t = (struct termio *) data;
	t->c_iflag = pt.c_iflag;
	t->c_oflag = pt.c_oflag;
	t->c_cflag = pt.c_cflag;
	t->c_lflag = pt.c_lflag;
	for (i = 0; i < NCC; i++)
	    t->c_cc[i] = pt.c_cc[i];
	return 0;
    case TCSETA:
    case TCSETAW:
    case TCSETAF:
	t = (struct termio *) data;
	pt.c_iflag = t->c_iflag;
	pt.c_oflag = t->c_oflag;
	pt.c_cflag = t->c_cflag;
	pt.c_lflag = t->c_lflag;

	for (i = 0; i < NCC; i++)
	    pt.c_cc[i] = t->c_cc[i];
	if (func == TCSETA)
	    i = XTY_TIOCSETA;
	else if (func == TCSETAW)
	    i = XTY_TIOCSETAW;
	else
	    i = XTY_TIOCSETAF;
	rc = DosDevIOCtl(fd, XFREE86_PTY, i,
			 (ULONG *) & pt, sizeof(struct pt_termios), &len,
			 NULL, 0, NULL);
	return (rc) ? -1 : 0;
    case TIOCCONS:
	return DosDevIOCtl(fd, XFREE86_PTY, XTY_TIOCCONS,
			   (ULONG *) data, sizeof(ULONG), &len,
			   NULL, 0, NULL);
    case TIOCSWINSZ:
	return DosDevIOCtl(fd, XFREE86_PTY, XTY_TIOCSWINSZ,
			   (ULONG *) data, sizeof(TTYSIZE_STRUCT), &len,
			   NULL, 0, NULL);
    case TIOCGWINSZ:
	return DosDevIOCtl(fd, XFREE86_PTY, XTY_TIOCGWINSZ,
			   NULL, 0, NULL,
			   (ULONG *) data, sizeof(TTYSIZE_STRUCT), &len);
    case XTY_ENADUP:
	i = 1;
	return DosDevIOCtl(fd, XFREE86_PTY, XTY_ENADUP,
			   (ULONG *) & i, sizeof(ULONG), &len,
			   NULL, 0, NULL);
    case XTY_TRACE:
	i = 2;
	return DosDevIOCtl(fd, XFREE86_PTY, XTY_TRACE,
			   (ULONG *) & i, sizeof(ULONG), &len,
			   NULL, 0, NULL);
    case PTMS_GETPTY:
	i = 1;
	return DosDevIOCtl(fd, XFREE86_PTY, PTMS_GETPTY,
			   (ULONG *) & i, sizeof(ULONG), &len,
			   (UCHAR *) data, 14, &len);
    default:
	return -1;
    }
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d6 1
a6 1
static char *rid = "$XConsortium: main.c,v 1.227.1.2 95/06/29 18:13:15 kaleb Exp $";
d8 1
a8 1
/* $XFree86: xc/programs/xterm/os2main.c,v 3.57 2002/12/27 21:05:22 dickey Exp $ */
d12 1
d36 1
d59 4
a62 1
/* os2main.c */
a65 1
#define I_NEED_OS2_H
d67 1
a67 1
#define XTERM_MAIN
d72 2
a79 2

#if defined(HAVE_LIB_XAW)
a80 4
#elif defined(HAVE_LIB_XAW3D)
#include <X11/Xaw3d/Form.h>
#elif defined(HAVE_LIB_NEXTAW)
#include <X11/neXtaw/Form.h>
a82 2
#endif /* OPT_TOOLBAR */

d93 3
a95 22
#if OPT_WIDE_CHARS
#include <charclass.h>
#include <wcwidth.h>
#endif

int
setpgrp(pid_t pid, gid_t pgid)
{
    return 0;
}

int
chown(const char *fn, pid_t pid, gid_t gid)
{
    return 0;
}

char *
ttyname(int fd)
{
    return "/dev/tty";
}
d98 1
a98 1
#include <sys/param.h>		/* for NOFILE */
d102 4
a105 5
static SIGNAL_T reapchild(int n);
static int spawn(void);
static void get_terminal(void);
static void resize(TScreen * s, char *oldtc, char *newtc);
static void set_owner(char *device, int uid, int gid, int mode);
d109 1
a109 12
/*
** Ordinarily it should be okay to omit the assignment in the following
** statement. Apparently the c89 compiler on AIX 4.1.3 has a bug, or does
** it? Without the assignment though the compiler will init command_to_exec
** to 0xffffffff instead of NULL; and subsequent usage, e.g. in spawn() to
** SEGV.
*/
static char **command_to_exec = NULL;

#if OPT_LUIT_PROG
static char **command_to_exec_with_luit = NULL;
#endif
d121 6
d130 5
a134 2
#ifndef CFLUSH
#define CFLUSH   CONTROL('O')
d139 2
a140 5
#ifndef CNUL
#define CNUL 0
#endif
#ifndef CQUIT
#define CQUIT    CONTROL('\\')
d145 2
a146 2
#ifndef CSTART
#define CSTART   CONTROL('Q')
d151 2
a152 8
#ifndef CSUSP
#define CSUSP    CONTROL('Z')
#endif
#ifndef CSWTCH
#define CSWTCH 0
#endif
#ifndef CWERASE
#define CWERASE  CONTROL('W')
a159 1
/* *INDENT-OFF* */
d166 1
a166 1
    { "intr",	4, 0, '\0' },	/* tchars.t_intrc ; VINTR */
d168 1
a168 1
    { "quit",	4, 0, '\0' },	/* tchars.t_quitc ; VQUIT */
d170 1
a170 1
    { "erase",	5, 0, '\0' },	/* sgttyb.sg_erase ; VERASE */
d172 1
a172 1
    { "kill",	4, 0, '\0' },	/* sgttyb.sg_kill ; VKILL */
d174 1
a174 1
    { "eof",	3, 0, '\0' },	/* tchars.t_eofc ; VEOF */
d176 1
a176 1
    { "eol",	3, 0, '\0' },	/* VEOL */
d178 1
a178 1
    { "swtch",	5, 0, '\0' },	/* VSWTCH */
d180 1
a180 1
    { "start",	5, 0, '\0' },	/* tchars.t_startc */
d182 1
a182 1
    { "stop",	4, 0, '\0' },	/* tchars.t_stopc */
d184 1
a184 1
    { "brk",	3, 0, '\0' },	/* tchars.t_brkc */
d186 1
a186 1
    { "susp",	4, 0, '\0' },	/* ltchars.t_suspc ; VSUSP */
d188 1
a188 1
    { "dsusp",	5, 0, '\0' },	/* ltchars.t_dsuspc ; VDSUSP */
d190 1
a190 1
    { "rprnt",	5, 0, '\0' },	/* ltchars.t_rprntc ; VREPRINT */
d192 1
a192 1
    { "flush",	5, 0, '\0' },	/* ltchars.t_flushc ; VDISCARD */
d194 1
a194 1
    { "weras",	5, 0, '\0' },	/* ltchars.t_werasc ; VWERASE */
d196 1
a196 1
    { "lnext",	5, 0, '\0' },	/* ltchars.t_lnextc ; VLNEXT */
d198 1
a198 1
    { NULL,	0, 0, '\0' },	/* end of data */
a199 1
/* *INDENT-ON* */
d201 1
a201 1
static int parse_tty_modes(char *s, struct _xttymodes *modelist);
d206 5
d221 33
d256 1
a256 1
#define offset(field)	XtOffsetOf(XTERM_RESOURCE, field)
d258 1
a258 2
static XtResource application_resources[] =
{
d260 1
a260 1
     offset(xterm_name), XtRString, DFT_TERMTYPE},
d262 1
a262 1
     offset(icon_geometry), XtRString, (caddr_t) NULL},
d264 1
a264 1
     offset(title), XtRString, (caddr_t) NULL},
d266 1
a266 1
     offset(icon_name), XtRString, (caddr_t) NULL},
d268 1
a268 1
     offset(term_name), XtRString, (caddr_t) NULL},
d270 9
a278 9
     offset(tty_modes), XtRString, (caddr_t) NULL},
    {"hold", "Hold", XtRBoolean, sizeof(Boolean),
     offset(hold_screen), XtRString, "false"},
    {"utmpInhibit", "UtmpInhibit", XtRBoolean, sizeof(Boolean),
     offset(utmpInhibit), XtRString, "false"},
    {"messages", "Messages", XtRBoolean, sizeof(Boolean),
     offset(messages), XtRString, "true"},
    {"sunFunctionKeys", "SunFunctionKeys", XtRBoolean, sizeof(Boolean),
     offset(sunFunctionKeys), XtRString, "false"},
d280 2
a281 2
    {"sunKeyboard", "SunKeyboard", XtRBoolean, sizeof(Boolean),
     offset(sunKeyboard), XtRString, "false"},
d284 2
a285 2
    {"hpFunctionKeys", "HpFunctionKeys", XtRBoolean, sizeof(Boolean),
     offset(hpFunctionKeys), XtRString, "false"},
d287 4
a290 4
    {"waitForMap", "WaitForMap", XtRBoolean, sizeof(Boolean),
     offset(wait_for_map), XtRString, "false"},
    {"useInsertMode", "UseInsertMode", XtRBoolean, sizeof(Boolean),
     offset(useInsertMode), XtRString, "false"},
d292 2
a293 2
    {"zIconBeep", "ZIconBeep", XtRInt, sizeof(int),
     offset(zIconBeep), XtRImmediate, 0},
d296 2
a297 6
    {"sameName", "SameName", XtRBoolean, sizeof(Boolean),
     offset(sameName), XtRString, "true"},
#endif
#if OPT_SESSION_MGT
    {"sessionMgt", "SessionMgt", XtRBoolean, sizeof(Boolean),
     offset(sessionMgt), XtRString, "true"},
d302 1
a302 2
static char *fallback_resources[] =
{
d318 1
a318 1
/* *INDENT-OFF* */
a425 6
#if OPT_LUIT_PROG
{"-lc",		"*locale",	XrmoptionNoArg,		(caddr_t) "True"},
{"+lc",		"*locale",	XrmoptionNoArg,		(caddr_t) "False"},
{"-lcc",	"*localeFilter",XrmoptionSepArg,	(caddr_t) NULL},
{"-en",		"*locale",	XrmoptionSepArg,	(caddr_t) NULL},
#endif
a438 2
{"-cjk_width", "*cjkWidth",	XrmoptionNoArg,		(caddr_t) "on"},
{"+cjk_width", "*cjkWidth",	XrmoptionNoArg,		(caddr_t) "off"},
d443 1
a443 1
{"-ziconbeep",	"*zIconBeep",	XrmoptionSepArg,	(caddr_t) NULL},
a448 4
#if OPT_SESSION_MGT
{"-sm",		"*sessionMgt",	XrmoptionNoArg,		(caddr_t) "on"},
{"+sm",		"*sessionMgt",	XrmoptionNoArg,		(caddr_t) "off"},
#endif
a453 1
{"-into",	NULL,		XrmoptionSkipArg,	(caddr_t) NULL},
d455 1
a455 1
   standard XtOpenApplication options now */
d467 1
a467 1
static OptionHelp xtermOptions[] = {
d479 1
a479 1
{ "-/+fbb",                "turn on/off normal/bold font comparison inhibit"},
d494 1
a494 1
{ "-/+132",                "turn on/off 80/132 column switching" },
d497 1
a497 1
{ "-/+ai",                 "turn off/on active icon" },
d513 1
a513 1
{ "-hc color",             "selection background color" },
d534 1
a534 1
{ "-/+nul",                "turn off/on display of underlining" },
a560 4
#if OPT_LUIT_PROG
{ "-/+lc",                 "turn on/off locale mode using luit" },
{ "-lcc path",             "filename of locale converter (" DEFLOCALEFILTER ")" },
#endif
a566 1
{ "-/+cjk_width",          "turn on/off legacy CJK width convention" },
a577 1
{ "-into windowId",        "use the window id given to -into as the parent window rather than the default root window" },
a583 3
#if OPT_SESSION_MGT
{ "-/+sm",                 "turn on/off the session-management support" },
#endif
a584 1
/* *INDENT-ON* */
d601 7
a607 19
static char *message[] =
{
    "Fonts should be fixed width and, if both normal and bold are specified, should",
    "have the same size.  If only a normal font is specified, it will be used for",
    "both normal and bold text (by doing overstriking).  The -e option, if given,",
    "must appear at the end of the command line, otherwise the user's default shell",
    "will be started.  Options that start with a plus sign (+) restore the default.",
    NULL};

/*
 * Decode a key-definition.  This combines the termcap and ttyModes, for
 * comparison.  Note that octal escapes in ttyModes are done by the normal
 * resource translation.  Also, ttyModes allows '^-' as a synonym for disabled.
 */
static int
decode_keyvalue(char **ptr, int termcap)
{
    char *string = *ptr;
    int value = -1;
d609 1
a609 54
    TRACE(("...decode '%s'\n", string));
    if (*string == '^') {
	switch (*++string) {
	case '?':
	    value = A2E(127);
	    break;
	case '-':
	    if (!termcap) {
		errno = 0;
#if defined(_POSIX_VDISABLE) && defined(HAVE_UNISTD_H)
		value = _POSIX_VDISABLE;
#endif
#if defined(_PC_VDISABLE)
		if (value == -1) {
		    value = fpathconf(0, _PC_VDISABLE);
		    if (value == -1) {
			if (errno != 0)
			    break;	/* skip this (error) */
			value = 0377;
		    }
		}
#elif defined(VDISABLE)
		if (value == -1)
		    value = VDISABLE;
#endif
		break;
	    }
	    /* FALLTHRU */
	default:
	    value = CONTROL(*string);
	    break;
	}
	++string;
    } else if (termcap && (*string == '\\')) {
	char *d;
	int temp = strtol(string + 1, &d, 8);
	if (temp > 0 && d != string) {
	    value = temp;
	    string = d;
	}
    } else {
	value = CharOf(*string);
	++string;
    }
    *ptr = string;
    return value;
}

/*
 * If we're linked to terminfo, tgetent() will return an empty buffer.  We
 * cannot use that to adjust the $TERMCAP variable.
 */
static Boolean
get_termcap(char *name, char *buffer, char *resized)
d613 1
a613 1
    *buffer = 0;		/* initialize, in case we're using terminfo's tgetent */
d616 1
a616 1
	if (tgetent(buffer, name) == 1) {
d618 3
a620 3
		   (*buffer
		    ? "ok:termcap, we can update $TERMCAP"
		    : "assuming this is terminfo")));
d623 1
a623 1
		    resize(screen, buffer, resized);
d634 1
a634 2
static int
abbrev(char *tst, char *cmp, size_t need)
d636 2
a637 2
    size_t len = strlen(tst);
    return ((len >= need) && (!strncmp(tst, cmp, len)));
d640 1
a640 2
static void
Syntax(char *badOption)
a642 1
    OptionHelp *list = sortedOpts(xtermOptions, optionDescList, XtNumber(optionDescList));
d645 2
a646 2
    fprintf(stderr, "%s:  bad command line option \"%s\"\r\n\n",
	    ProgramName, badOption);
d648 1
a648 1
    fprintf(stderr, "usage:  %s", ProgramName);
d650 2
a651 2
    for (opt = list; opt->opt; opt++) {
	int len = 3 + strlen(opt->opt);		/* space [ string ] */
d653 1
a653 1
	    fprintf(stderr, "\r\n   ");		/* 3 spaces */
d656 1
a656 1
	fprintf(stderr, " [%s]", opt->opt);
d660 3
a662 3
    fprintf(stderr, "\r\n\nType %s -help for a full description.\r\n\n",
	    ProgramName);
    exit(1);
d665 1
a665 2
static void
Version(void)
d671 1
a671 2
static void
Help(void)
a673 1
    OptionHelp *list = sortedOpts(xtermOptions, optionDescList, XtNumber(optionDescList));
d676 5
a680 6
    fprintf(stderr,
	    "%s(%d) usage:\n    %s [-options ...] [-e command args]\n\n",
	    XFREE86_VERSION, XTERM_PATCH, ProgramName);
    fprintf(stderr, "where options include:\n");
    for (opt = list; opt->opt; opt++) {
	fprintf(stderr, "    %-28s %s\n", opt->opt, opt->desc);
d683 1
a683 1
    putc('\n', stderr);
d685 2
a686 2
	fputs(*cpp, stderr);
	putc('\n', stderr);
d688 1
a688 1
    putc('\n', stderr);
d694 8
a701 7
ConvertConsoleSelection(Widget w GCC_UNUSED,
			Atom * selection GCC_UNUSED,
			Atom * target GCC_UNUSED,
			Atom * type GCC_UNUSED,
			XtPointer * value GCC_UNUSED,
			unsigned long *length GCC_UNUSED,
			int *format GCC_UNUSED)
d707 5
a711 19
#if OPT_SESSION_MGT
static void
die_callback(Widget w GCC_UNUSED,
	     XtPointer client_data GCC_UNUSED,
	     XtPointer call_data GCC_UNUSED)
{
    Cleanup(0);
}

static void
save_callback(Widget w GCC_UNUSED,
	      XtPointer client_data GCC_UNUSED,
	      XtPointer call_data)
{
    XtCheckpointToken token = (XtCheckpointToken) call_data;
    /* we have nothing to save */
    token->save_success = True;
}
#endif /* OPT_SESSION_MGT */
d713 1
a713 3
#if OPT_WIDE_CHARS
int (*my_wcwidth) (wchar_t);
#endif
d720 5
a724 4
DeleteWindow(Widget w,
	     XEvent * event GCC_UNUSED,
	     String * params GCC_UNUSED,
	     Cardinal * num_params GCC_UNUSED)
d727 8
a734 7
    if (w == toplevel) {
	if (term->screen.Tshow)
	    hide_vt_window();
	else
	    do_hangup(w, (XtPointer) 0, (XtPointer) 0);
    } else if (term->screen.Vshow)
	hide_tek_window();
d737 1
a737 1
	do_hangup(w, (XtPointer) 0, (XtPointer) 0);
d742 5
a746 4
KeyboardMapping(Widget w GCC_UNUSED,
		XEvent * event,
		String * params GCC_UNUSED,
		Cardinal * num_params GCC_UNUSED)
d749 3
a751 3
    case MappingNotify:
	XRefreshKeyboardMapping(&event->xmapping);
	break;
d755 10
a764 1
XtActionsRec actionProcs[] =
d766 73
a838 3
    {"DeleteWindow", DeleteWindow},
    {"KeyboardMapping", KeyboardMapping},
};
d844 1
a844 1
main(int argc, char **argv ENVP_ARG)
d846 31
a876 26
    Widget form_top, menu_top;
    register TScreen *screen;
    int mode;
    char *my_class = DEFCLASS;
    Window winToEmbedInto = None;

    /* Do these first, since we may not be able to open the display */
    ProgramName = argv[0];
    TRACE_OPTS(xtermOptions, optionDescList, XtNumber(optionDescList));
    TRACE_ARGV("Before XtOpenApplication", argv);
    if (argc > 1) {
	int n;
	int unique = 2;
	Boolean quit = True;

	for (n = 1; n < argc; n++) {
	    TRACE(("parsing %s\n", argv[n]));
	    if (abbrev(argv[n], "-version", unique)) {
		Version();
	    } else if (abbrev(argv[n], "-help", unique)) {
		Help();
	    } else if (abbrev(argv[n], "-class", 3)) {
		if ((my_class = argv[++n]) == 0) {
		    Help();
		} else {
		    quit = False;
d878 2
a879 5
		unique = 3;
	    } else {
		quit = False;
		unique = 3;
	    }
a880 3
	if (quit)
	    exit(0);
    }
d882 4
a885 4
    /* XXX: for some obscure reason EMX seems to lose the value of
     * the environ variable, don't understand why, so save it recently
     */
    gblenvp = envp;
d888 1
a888 1
    setlocale(LC_ALL, NULL);
d893 11
a903 10
    ttydev = (char *) malloc(PTMS_BUFSZ);
    ptydev = (char *) malloc(PTMS_BUFSZ);
    if (!ttydev || !ptydev) {
	fprintf(stderr,
		"%s:  unable to allocate memory for ttydev or ptydev\n",
		ProgramName);
	exit(1);
    }
    strcpy(ttydev, TTYDEV);
    strcpy(ptydev, PTYDEV);
d905 31
a935 38
    /* Initialization is done here rather than above in order
     * to prevent any assumptions about the order of the contents
     * of the various terminal structures (which may change from
     * implementation to implementation).
     */
    d_tio.c_iflag = ICRNL | IXON;
    d_tio.c_oflag = OPOST | ONLCR | TAB3;
    d_tio.c_cflag = B38400 | CS8 | CREAD | PARENB | HUPCL;
    d_tio.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK;
    d_tio.c_line = 0;
    d_tio.c_cc[VINTR] = CONTROL('C');	/* '^C' */
    d_tio.c_cc[VERASE] = 0x7f;	/* DEL  */
    d_tio.c_cc[VKILL] = CONTROL('U');	/* '^U' */
    d_tio.c_cc[VQUIT] = CQUIT;	/* '^\' */
    d_tio.c_cc[VEOF] = CEOF;	/* '^D' */
    d_tio.c_cc[VEOL] = CEOL;	/* '^@@' */

    /* Init the Toolkit. */
    XtSetErrorHandler(xt_error);
#if OPT_SESSION_MGT
    toplevel = XtOpenApplication(&app_con, my_class,
				 optionDescList,
				 XtNumber(optionDescList),
				 &argc, argv, fallback_resources,
				 sessionShellWidgetClass,
				 NULL, 0);
#else
    toplevel = XtAppInitialize(&app_con, my_class,
			       optionDescList,
			       XtNumber(optionDescList),
			       &argc, argv, fallback_resources,
			       NULL, 0);
#endif /* OPT_SESSION_MGT */
    XtSetErrorHandler((XtErrorHandler) 0);

    XtGetApplicationResources(toplevel, (XtPointer) & resource,
			      application_resources,
			      XtNumber(application_resources), NULL, 0);
d937 1
a937 1
    waiting_for_initial_map = resource.wait_for_map;
d939 4
a942 4
    /*
     * ICCCM delete_window.
     */
    XtAppAddActions(app_con, actionProcs, XtNumber(actionProcs));
d944 11
a954 10
    /*
     * fill in terminal modes
     */
    if (resource.tty_modes) {
	int n = parse_tty_modes(resource.tty_modes, ttymodelist);
	if (n < 0) {
	    fprintf(stderr, "%s:  bad tty modes \"%s\"\n",
		    ProgramName, resource.tty_modes);
	} else if (n > 0) {
	    override_tty_modes = 1;
d956 1
a956 1
    }
d958 6
a963 7
    zIconBeep = resource.zIconBeep;
    zIconBeep_flagged = False;
    if (zIconBeep > 100 || zIconBeep < -100) {
	zIconBeep = 0;		/* was 100, but I prefer to defaulting off. */
	fprintf(stderr,
		"a number between -100 and 100 is required for zIconBeep.  0 used by default\n");
    }
d966 1
a966 1
    sameName = resource.sameName;
d968 20
a987 21
    hold_screen = resource.hold_screen ? 1 : 0;
    xterm_name = resource.xterm_name;
    if (strcmp(xterm_name, "-") == 0)
	xterm_name = DFT_TERMTYPE;
    if (resource.icon_geometry != NULL) {
	int scr, junk;
	int ix, iy;
	Arg args[2];

	for (scr = 0;		/* yyuucchh */
	     XtScreen(toplevel) != ScreenOfDisplay(XtDisplay(toplevel), scr);
	     scr++) ;

	args[0].name = XtNiconX;
	args[1].name = XtNiconY;
	XGeometry(XtDisplay(toplevel), scr, resource.icon_geometry, "",
		  0, 0, 0, 0, 0, &ix, &iy, &junk, &junk);
	args[0].value = (XtArgVal) ix;
	args[1].value = (XtArgVal) iy;
	XtSetValues(toplevel, args, 2);
    }
d989 2
a990 2
    XtSetValues(toplevel, ourTopLevelShellArgs,
		number_ourTopLevelShellArgs);
d993 2
a994 2
    /* seems as good a place as any */
    init_classtab();
d997 33
a1029 33
    /* Parse the rest of the command line */
    TRACE_ARGV("After XtOpenApplication", argv);
    for (argc--, argv++; argc > 0; argc--, argv++) {
	if (**argv != '-')
	    Syntax(*argv);

	TRACE(("parsing %s\n", argv[0]));
	switch (argv[0][1]) {
	case 'h':		/* -help */
	    Help();
	    continue;
	case 'v':		/* -version */
	    Version();
	    continue;
	case 'C':
	    {
		struct stat sbuf;

		/* Must be owner and have read/write permission.
		   xdm cooperates to give the console the right user. */
		if (!stat("/dev/console", &sbuf) &&
		    (sbuf.st_uid == getuid()) &&
		    !access("/dev/console", R_OK | W_OK)) {
		    Console = TRUE;
		} else
		    Console = FALSE;
	    }
	    continue;
	case 'S':
	    if (sscanf(*argv + 2, "%c%c%d", passedPty, passedPty + 1,
		       &am_slave) != 3)
		Syntax(*argv);
	    continue;
d1031 5
a1035 6
	case 'D':
	    debug = TRUE;
	    continue;
#endif /* DEBUG */
	case 'c':		/* -class param */
	    if (strcmp(argv[0] + 1, "class") == 0)
d1037 7
a1043 16
	    else
		Syntax(*argv);
	    continue;
	case 'e':
	    if (argc <= 1)
		Syntax(*argv);
	    command_to_exec = ++argv;
	    break;
	case 'i':
	    if (argc <= 1) {
		Syntax(*argv);
	    } else {
		char *endPtr;
		--argc;
		++argv;
		winToEmbedInto = (Window) strtol(argv[0], &endPtr, 10);
d1046 1
d1048 11
a1058 2
	default:
	    Syntax(*argv);
d1060 1
a1060 2
	break;
    }
d1062 1
a1062 1
    SetupMenus(toplevel, &form_top, &menu_top);
d1064 2
a1065 2
    term = (XtermWidget) XtVaCreateManagedWidget("vt100", xtermWidgetClass,
						 form_top,
d1067 6
a1072 6
						 XtNmenuBar, menu_top,
						 XtNresizable, True,
						 XtNfromVert, menu_top,
						 XtNleft, XawChainLeft,
						 XtNright, XawChainRight,
						 XtNbottom, XawChainBottom,
d1074 2
a1075 2
						 (XtPointer) 0);
    /* this causes the initialize method to be called */
d1078 1
a1078 1
    init_keyboard_type(keyboardIsHP, resource.hpFunctionKeys);
d1080 1
a1080 1
    init_keyboard_type(keyboardIsSun, resource.sunFunctionKeys);
d1082 1
a1082 1
    init_keyboard_type(keyboardIsVT220, resource.sunKeyboard);
d1085 1
a1085 1
    screen = &term->screen;
d1087 1
a1087 1
    inhibit = 0;
d1089 1
a1089 2
    if (term->misc.logInhibit)
	inhibit |= I_LOG;
d1091 1
a1091 2
    if (term->misc.signalInhibit)
	inhibit |= I_SIGNAL;
d1093 1
a1093 2
    if (term->misc.tekInhibit)
	inhibit |= I_TEK;
d1096 3
a1098 5
#if OPT_WIDE_CHARS
    my_wcwidth = &mk_wcwidth;
    if (term->misc.cjk_width)
	my_wcwidth = &mk_wcwidth_cjk;
#endif
d1100 2
a1101 7
#if OPT_SESSION_MGT
    if (resource.sessionMgt) {
	TRACE(("Enabling session-management callbacks\n"));
	XtAddCallback(toplevel, XtNdieCallback, die_callback, NULL);
	XtAddCallback(toplevel, XtNsaveCallback, save_callback, NULL);
    }
#endif
d1103 5
a1107 5
    /*
     * Set title and icon name if not specified
     */
    if (command_to_exec) {
	Arg args[2];
d1109 9
a1117 15
	if (!resource.title) {
	    if (command_to_exec) {
		resource.title = x_basename(command_to_exec[0]);
	    }			/* else not reached */
	}

	if (!resource.icon_name)
	    resource.icon_name = resource.title;
	XtSetArg(args[0], XtNtitle, resource.title);
	XtSetArg(args[1], XtNiconName, resource.icon_name);

	TRACE(("setting:\n\ttitle \"%s\"\n\ticon \"%s\"\n\tbased on command \"%s\"\n",
	       resource.title,
	       resource.icon_name,
	       *command_to_exec));
d1119 1
a1119 30
	XtSetValues(toplevel, args, 2);
    }
#if OPT_LUIT_PROG
    if (term->misc.callfilter) {
	int u = (term->misc.use_encoding ? 2 : 0);
	if (command_to_exec) {
	    int n;
	    char **c;
	    for (n = 0, c = command_to_exec; *c; n++, c++) ;
	    c = malloc((n + 3 + u) * sizeof(char *));
	    if (c == NULL)
		SysError(ERROR_LUMALLOC);
	    memcpy(c + 2 + u, command_to_exec, (n + 1) * sizeof(char *));
	    c[0] = term->misc.localefilter;
	    if (u) {
		c[1] = "-encoding";
		c[2] = term->misc.locale_str;
	    }
	    c[1 + u] = "--";
	    command_to_exec_with_luit = c;
	} else {
	    static char *luit[4];
	    luit[0] = term->misc.localefilter;
	    if (u) {
		luit[1] = "-encoding";
		luit[2] = term->misc.locale_str;
		luit[3] = NULL;
	    } else
		luit[1] = NULL;
	    command_to_exec_with_luit = luit;
d1121 1
a1121 2
    }
#endif
d1123 2
a1124 2
    if (inhibit & I_TEK)
	screen->TekEmu = FALSE;
d1126 2
a1127 2
    if (screen->TekEmu && !TekInit())
	exit(ERROR_INIT);
d1133 2
a1134 2
	   done securely by a privileged xterm process (although we try),
	   so the debug feature is disabled by default. */
d1136 3
a1138 3
	if (debug) {
	    creat_as(getuid(), getgid(), True, "xterm.debug.log", 0666);
	    i = open("xterm.debug.log", O_WRONLY | O_TRUNC);
d1140 2
a1141 2
	if (i >= 0) {
	    dup2(i, 2);
d1143 2
a1144 2
	    /* mark this file as close on exec */
	    (void) fcntl(i, F_SETFD, 1);
d1147 1
a1147 1
#endif /* DEBUG */
d1149 2
a1150 2
    /* open a terminal for client */
    get_terminal();
d1152 1
a1152 1
    spawn();
d1154 2
a1155 2
    /* Child process is out there, let's catch its termination */
    (void) signal(SIGCHLD, reapchild);
d1157 1
a1157 1
    /* Realize procs have now been executed */
d1159 2
a1160 2
    if (am_slave >= 0) {	/* Write window id so master end can read and use */
	char buf[80];
d1162 4
a1165 4
	buf[0] = '\0';
	sprintf(buf, "%lx\n", XtWindow(XtParent(CURRENT_EMU(screen))));
	write(screen->respond, buf, strlen(buf));
    }
d1167 1
a1167 1
    screen->inhibit = inhibit;
d1169 17
a1185 17
    if (0 > (mode = fcntl(screen->respond, F_GETFL, 0)))
	SysError(ERROR_F_GETFL);
    mode |= O_NDELAY;

    if (fcntl(screen->respond, F_SETFL, mode))
	SysError(ERROR_F_SETFL);

    FD_ZERO(&pty_mask);
    FD_ZERO(&X_mask);
    FD_ZERO(&Select_mask);
    FD_SET(screen->respond, &pty_mask);
    FD_SET(ConnectionNumber(screen->display), &X_mask);
    FD_SET(screen->respond, &Select_mask);
    FD_SET(ConnectionNumber(screen->display), &Select_mask);
    max_plus1 = ((screen->respond < ConnectionNumber(screen->display))
		 ? (1 + ConnectionNumber(screen->display))
		 : (1 + screen->respond));
d1188 4
a1191 5
    if (debug)
	printf("debugging on\n");
#endif /* DEBUG */
    XSetErrorHandler(xerror);
    XSetIOErrorHandler(xioerror);
d1194 3
a1196 3
    if (term->misc.log_on) {
	StartLog(screen);
    }
d1198 1
a1198 14

    if (winToEmbedInto != None) {
	XtRealizeWidget(toplevel);
	/*
	 * This should probably query the tree or check the attributes of
	 * winToEmbedInto in order to verify that it exists, but I'm still not
	 * certain what is the best way to do it -GPS
	 */
	XReparentWindow(XtDisplay(toplevel),
			XtWindow(toplevel),
			winToEmbedInto, 0, 0);
    }

    for (;;) {
d1200 3
a1202 3
	if (screen->TekEmu)
	    TekRun();
	else
d1204 3
a1206 3
	    VTRun();
    }
    return 0;
d1218 1
a1218 1
    char namebuf[PTMS_BUFSZ];
d1220 8
a1227 8
    /* ask the PTY manager */
    int fd = open("/dev/ptms$", 0);
    if (fd && ptioctl(fd, PTMS_GETPTY, namebuf) == 0) {
	strcpy(ttydev, namebuf);
	strcpy(ptydev, namebuf);
	*x_basename(ttydev) = 't';
	close(fd);
	if ((*pty = open(ptydev, O_RDWR)) >= 0) {
d1229 1
a1229 1
	    ptioctl(*pty, XTY_TRACE, 0);
d1231 2
a1232 1
	    return 0;
d1234 1
a1234 2
    }
    return 1;
d1246 1
a1246 1
get_pty(int *pty)
d1248 1
a1248 1
    return pty_search(pty);
d1255 1
a1255 1
get_terminal(void)
d1257 1
a1257 1
    register TScreen *screen = &term->screen;
d1259 3
a1261 3
    screen->arrow = make_colored_cursor(XC_left_ptr,
					screen->mousecolor,
					screen->mousecolorback);
d1278 8
a1285 9
static char *tekterm[] =
{
    "tek4014",
    "tek4015",			/* 4014 with APL character set support */
    "tek4012",			/* 4010 with lower case */
    "tek4013",			/* 4012 with APL character set support */
    "tek4010",			/* small screen, upper-case only */
    "dumb",
    0
d1296 1
a1296 2
static char *vtterm[] =
{
d1298 1
a1298 1
    "x11term",			/* for people who want special term name */
d1300 7
a1306 7
    DFT_TERMTYPE,		/* for people who want special term name */
    "xterm",			/* the prefered name, should be fastest */
    "vt102",
    "vt100",
    "ansi",
    "dumb",
    0
d1310 1
a1310 2
static SIGNAL_T
hungtty(int i GCC_UNUSED)
d1312 2
a1313 2
    longjmp(env, 1);
    SIGNAL_RETURN;
d1317 3
a1319 3
    int rows;
    int cols;
} handshake = {
d1321 1
a1321 5
    -1, -1
};

void
first_map_occurred(void)
a1328 13
static void
set_owner(char *device, int uid, int gid, int mode)
{
    if (chown(device, uid, gid) < 0) {
	if (errno != ENOENT
	    && getuid() == 0) {
	    fprintf(stderr, "Cannot chown %s to %d,%d: %s\n",
		    device, uid, gid, strerror(errno));
	}
    }
    chmod(device, mode);
}

d1333 1
a1333 2
SIGNAL_T
killit(int sig)
d1335 17
a1351 17
    switch (whoami) {
    case -1:
	signal(sig, killit);
	kill(-getpid(), sig);
	break;
    case THE_PARENT:
	wait(NULL);
	signal(SIGTERM, SIG_DFL);
	kill(-getpid(), SIGTERM);
	Exit(0);
	break;
    case THE_CHILD:
	signal(SIGTERM, SIG_DFL);
	kill(-getppid(), SIGTERM);
	Exit(0);
	break;
    }
d1353 1
a1353 1
    SIGNAL_RETURN;
d1357 1
a1357 1
spawn(void)
d1364 2
a1365 2
    register TScreen *screen = &term->screen;
    int Xsocket = ConnectionNumber(screen->display);
d1367 22
a1388 27
    int tty = -1;
    struct termio tio;
    int status;

    char termcap[TERMCAP_SIZE], newtc[TERMCAP_SIZE];
    char *TermName = NULL;
    char *ptr, *shname, buf[64];
    int i, no_dev_tty = FALSE, envsize;
    char *dev_tty_name = (char *) 0;
    struct winsize ws;
    int pgrp = getpid();
    char numbuf[12], **envnew;

    screen->uid = getuid();
    screen->gid = getgid();

    if (am_slave >= 0) {
	screen->respond = am_slave;
	ptydev[strlen(ptydev) - 2] =
	    ttydev[strlen(ttydev) - 2] = passedPty[0];
	ptydev[strlen(ptydev) - 1] =
	    ttydev[strlen(ttydev) - 1] = passedPty[1];

	setgid(screen->gid);
	setuid(screen->uid);
    } else {
	Bool tty_got_hung;
d1390 2
a1391 12
	/*
	 * Sometimes /dev/tty hangs on open (as in the case of a pty
	 * that has gone away).  Simply make up some reasonable
	 * defaults.
	 */

	signal(SIGALRM, hungtty);
	alarm(2);		/* alarm(1) might return too soon */
	if (!setjmp(env)) {
	    tty = open("/dev/tty", O_RDWR);
	    alarm(0);
	    tty_got_hung = False;
d1393 1
a1393 5
	    tty_got_hung = True;
	    tty = -1;
	    errno = ENXIO;
	}
	signal(SIGALRM, SIG_DFL);
d1395 18
a1412 15
	/*
	 * Check results and ignore current control terminal if
	 * necessary.  ENXIO is what is normally returned if there is
	 * no controlling terminal, but some systems (e.g. SunOS 4.0)
	 * seem to return EIO.  Solaris 2.3 is said to return EINVAL.
	 */
	if (tty < 0) {
	    if (tty_got_hung || errno == ENXIO || errno == EIO ||
		errno == EINVAL || errno == ENOTTY) {
		no_dev_tty = TRUE;
		tio = d_tio;
	    } else {
		SysError(ERROR_OPDEVTTY);
	    }
	} else {
d1414 28
a1441 8
	    /* Get a copy of the current terminal's state,
	     * if we can.  Some systems (e.g., SVR4 and MacII)
	     * may not have a controlling terminal at this point
	     * if started directly from xdm or xinit,
	     * in which case we just use the defaults as above.
	     */
	    if (ioctl(tty, TCGETA, &tio) == -1)
		tio = d_tio;
d1443 4
a1446 3
	    close(tty);
	    /* tty is no longer an open fd! */
	    tty = -1;
d1449 2
a1450 5
	if (get_pty(&screen->respond)) {
	    /*  no ptys! */
	    exit(ERROR_PTYS);
	}
    }
d1452 2
a1453 2
    /* avoid double MapWindow requests */
    XtSetMappedWhenManaged(XtParent(CURRENT_EMU(screen)), False);
d1455 2
a1456 2
    wm_delete_window = XInternAtom(XtDisplay(toplevel), "WM_DELETE_WINDOW",
				   False);
d1458 23
a1480 2
    if (!TEK4014_ACTIVE(screen))
	VTInit();		/* realize now so know window size for tty driver */
a1481 1
    if (Console) {
d1483 4
a1486 2
	 * Inform any running xconsole program
	 * that we are going to steal the console.
d1488 1
a1488 17
	XmuGetHostname(mit_console_name + MIT_CONSOLE_LEN, 255);
	mit_console = XInternAtom(screen->display, mit_console_name, False);
	/* the user told us to be the console, so we can use CurrentTime */
	XtOwnSelection(XtParent(CURRENT_EMU(screen)),
		       mit_console, CurrentTime,
		       ConvertConsoleSelection, NULL, NULL);
    }
#if OPT_TEK4014
    if (screen->TekEmu) {
	envnew = tekterm;
	ptr = newtc;
    } else
#endif
    {
	envnew = vtterm;
	ptr = termcap;
    }
d1490 12
a1501 18
    /*
     * This used to exit if no termcap entry was found for the specified
     * terminal name.  That's a little unfriendly, so instead we'll allow
     * the program to proceed (but not to set $TERMCAP) if the termcap
     * entry is not found.
     */
    get_termcap(TermName = resource.term_name, ptr, newtc);

    /*
     * This block is invoked only if there was no terminal name specified
     * by the command-line option "-tn".
     */
    if (!TermName) {
	TermName = *envnew;
	while (*envnew != NULL) {
	    if (get_termcap(*envnew, ptr, newtc)) {
		TermName = *envnew;
		break;
a1502 1
	    envnew++;
a1503 1
    }
d1505 1
a1505 1
    /* tell tty how big window is */
d1507 6
a1512 66
    if (TEK4014_ACTIVE(screen)) {
	ws.ws_row = 38;
	ws.ws_col = 81;
	ws.ws_xpixel = TFullWidth(screen);
	ws.ws_ypixel = TFullHeight(screen);
    } else
#endif
    {
	ws.ws_row = screen->max_row + 1;
	ws.ws_col = screen->max_col + 1;
	ws.ws_xpixel = FullWidth(screen);
	ws.ws_ypixel = FullHeight(screen);
    }

    if (am_slave < 0) {

	char sema[40];
	HEV sev;
	/* start a child process
	 * use an event sema for sync
	 */
	sprintf(sema, "\\SEM32\\xterm%s", &ptydev[8]);
	if (DosCreateEventSem(sema, &sev, DC_SEM_SHARED, FALSE))
	    SysError(ERROR_FORK);

	switch ((screen->pid = fork())) {
	case -1:		/* error */
	    SysError(ERROR_FORK);
	default:		/* parent */
	    whoami = THE_PARENT;
	    DosWaitEventSem(sev, 1000L);
	    DosCloseEventSem(sev);
	    break;
	case 0:		/* child */
	    whoami = THE_CHILD;

/*debug fclose(confd);
opencons();*/
	    /* we don't need the socket, or the pty master anymore */
	    close(ConnectionNumber(screen->display));
	    close(screen->respond);

	    /* Now is the time to set up our process group and
	     * open up the pty slave.
	     */
	    if ((tty = open(ttydev, O_RDWR)) < 0) {
		/* dumm gelaufen */
		fprintf(stderr, "Cannot open slave side of PTY\n");
		exit(1);
	    }

	    /* use the same tty name that everyone else will use
	     * (from ttyname)
	     */
#ifdef EMXNOTBOGUS
	    if ((ptr = ttyname(tty)) != 0) {
		/* it may be bigger */
		ttydev = realloc(ttydev,
				 (unsigned) (strlen(ptr) + 1));
		if (ttydev == NULL) {
		    SysError(ERROR_SPREALLOC);
		}
		(void) strcpy(ttydev, ptr);
	    }
#else
	    ptr = ttydev;
d1514 1
a1514 82
	    /* for safety: enable DUPs */
	    ptioctl(tty, XTY_ENADUP, 0);

	    /* change ownership of tty to real group and user id */
	    set_owner(ttydev, screen->uid, screen->gid,
		      (resource.messages ? 0622 : 0600));

	    /* for the xf86sup-pty, we set the pty to bypass: OS/2 does
	     * not have a line discipline structure
	     */
	    {
		struct termio t, t1;
		if (ptioctl(tty, TCGETA, (char *) &t) < 0)
		    t = d_tio;

		t.c_iflag = ICRNL;
		t.c_oflag = OPOST | ONLCR;
		t.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK;

		/* ignore error code, user will see it :-) */
		ptioctl(tty, TCSETA, (char *) &t);

		/* set the console mode */
		if (Console) {
		    int on = 1;
		    if (ioctl(tty, TIOCCONS, (char *) &on) == -1)
			fprintf(stderr, "%s: cannot open console\n", xterm_name);
		}
	    }

	    signal(SIGCHLD, SIG_DFL);
	    signal(SIGHUP, SIG_IGN);

	    /* restore various signals to their defaults */
	    signal(SIGINT, SIG_DFL);
	    signal(SIGQUIT, SIG_DFL);
	    signal(SIGTERM, SIG_DFL);

	    /* copy the environment before Setenving */
	    for (i = 0; gblenvp[i] != NULL; i++) ;

	    /* compute number of xtermSetenv() calls below */
	    envsize = 1;	/* (NULL terminating entry) */
	    envsize += 3;	/* TERM, WINDOWID, DISPLAY */
	    envsize += 2;	/* COLUMNS, LINES */

	    envnew = (char **) calloc((unsigned) i + envsize, sizeof(char *));
	    memmove((char *) envnew, (char *) gblenvp, i * sizeof(char *));
	    gblenvp = envnew;
	    xtermSetenv("TERM=", TermName);
	    if (!TermName)
		*newtc = 0;

	    sprintf(buf, "%lu",
		    ((unsigned long) XtWindow(XtParent(CURRENT_EMU(screen)))));
	    xtermSetenv("WINDOWID=", buf);

	    /* put the display into the environment of the shell */
	    xtermSetenv("DISPLAY=", XDisplayString(screen->display));

	    signal(SIGTERM, SIG_DFL);

	    /* this is the time to go and set up stdin, out, and err
	     */
	    /* dup the tty */
	    for (i = 0; i <= 2; i++)
		if (i != tty) {
		    (void) close(i);
		    (void) dup(tty);
		}

	    /* and close the tty */
	    if (tty > 2)
		(void) close(tty);

	    setpgrp(0, pgrp);
	    setgid(screen->gid);
	    setuid(screen->uid);

	    if (handshake.rows > 0 && handshake.cols > 0) {
		screen->max_row = handshake.rows;
		screen->max_col = handshake.cols;
d1519 1
a1519 12
	    }

	    sprintf(numbuf, "%d", screen->max_col + 1);
	    xtermSetenv("COLUMNS=", numbuf);
	    sprintf(numbuf, "%d", screen->max_row + 1);
	    xtermSetenv("LINES=", numbuf);

	    /* reconstruct dead environ variable */
	    environ = gblenvp;

	    /* need to reset after all the ioctl bashing we did above */
	    ptioctl(0, TIOCSWINSZ, (char *) &ws);
d1521 1
a1521 1
	    signal(SIGHUP, SIG_DFL);
a1522 2
	    /* okay everything seems right, so tell the parent, we are going */
	    {
d1525 17
a1541 5
		sprintf(sema, "\\SEM32\\xterm%s", &ttydev[8]);
		DosOpenEventSem(sema, &sev);
		DosPostEventSem(sev);
		DosCloseEventSem(sev);
	    }
d1543 28
a1570 15
#if OPT_LUIT_PROG
	    /*
	     * Use two copies of command_to_exec, in case luit is not actually
	     * there, or refuses to run.  In that case we will fall-through to
	     * to command that the user gave anyway.
	     */
	    if (command_to_exec_with_luit) {
		TRACE(("spawning command \"%s\"\n", *command_to_exec_with_luit));
		execvp(*command_to_exec_with_luit, command_to_exec_with_luit);
		/* print error message on screen */
		fprintf(stderr, "%s: Can't execvp %s: %s\n",
			xterm_name, *command_to_exec_with_luit, strerror(errno));
		fprintf(stderr, "%s: cannot support your locale.\n",
			xterm_name);
	    }
d1572 5
a1576 8
	    if (command_to_exec) {
		TRACE(("spawning command \"%s\"\n", *command_to_exec));
		execvpe(*command_to_exec, command_to_exec, gblenvp);

		/* print error message on screen */
		fprintf(stderr, "%s: Can't execvp %s\n",
			xterm_name, *command_to_exec);
	    }
d1578 139
a1716 24
	    /* use a layered mechanism to find a shell */
	    ptr = getenv("X11SHELL");
	    if (!ptr)
		ptr = getenv("SHELL");
	    if (!ptr)
		ptr = getenv("OS2_SHELL");
	    if (!ptr)
		ptr = "SORRY_NO_SHELL_FOUND";

	    shname = x_basename(ptr);
	    if (command_to_exec) {
		char *exargv[10];	/*XXX */

		exargv[0] = ptr;
		exargv[1] = "/C";
		exargv[2] = command_to_exec[0];
		exargv[3] = command_to_exec[1];
		exargv[4] = command_to_exec[2];
		exargv[5] = command_to_exec[3];
		exargv[6] = command_to_exec[4];
		exargv[7] = command_to_exec[5];
		exargv[8] = command_to_exec[6];
		exargv[9] = 0;
		execvpe(exargv[0], exargv, gblenvp);
d1718 2
a1719 1
		execvpe(*command_to_exec, command_to_exec, gblenvp);
d1721 18
a1738 14
		/* print error message on screen */
		fprintf(stderr, "%s: Can't execvp %s\n",
			xterm_name, *command_to_exec);
	    } else {
		execlpe(ptr, shname, 0, gblenvp);

		/* Exec failed. */
		fprintf(stderr, "%s: Could not exec %s!\n",
			xterm_name, ptr);
	    }
	    sleep(5);

	    /* preventively shoot the parent */
	    kill(-getppid(), SIGTERM);
d1740 1
a1740 5
	    exit(ERROR_EXEC);
	}			/* endcase */
    }
    /* !am_slave */
    signal(SIGHUP, SIG_IGN);
d1748 9
a1756 9
/*  signal (SIGINT, SIG_IGN);*/
    signal(SIGINT, killit);
    signal(SIGTERM, killit);

    /* hung shell problem */
    signal(SIGQUIT, SIG_IGN);
/*  signal (SIGTERM, SIG_IGN);*/
    return 0;
}				/* end spawn */
d1761 3
a1763 3
    register TScreen *screen = &term->screen;
    int pty = term->screen.respond;	/* file descriptor of pty */
    close(pty);			/* close explicitly to avoid race with slave side */
d1765 2
a1766 2
    if (screen->logging)
	CloseLog(screen);
d1768 11
a1778 7
    if (am_slave < 0) {
	/* restore ownership of tty and pty */
	set_owner(ttydev, 0, 0, 0666);
	set_owner(ptydev, 0, 0, 0666);
    }
    exit(n);
    SIGNAL_RETURN;
d1783 1
a1783 1
resize(TScreen * screen, register char *oldtc, char *newtc)
d1795 1
a1795 1
    pid_t pid;
d1797 2
a1798 2
    pid = waitpid(-1, NULL, WNOHANG);
    return pid;
d1802 1
a1802 2
static SIGNAL_T
reapchild(int n GCC_UNUSED)
a1803 1
    int olderrno = errno;
d1816 1
a1816 2
	    if (debug)
		fputs("Exiting\n", stderr);
d1819 1
a1819 1
		Cleanup(0);
d1821 1
a1821 1
    } while ((pid = nonblocking_wait()) > 0);
a1822 1
    errno = olderrno;
d1834 1
a1834 2
static int
parse_tty_modes(char *s, struct _xttymodes *modelist)
a1839 1
    TRACE(("parse_tty_modes\n"));
d1841 2
a1842 4
	while (*s && isascii(CharOf(*s)) && isspace(CharOf(*s)))
	    s++;
	if (!*s)
	    return count;
d1845 1
a1845 2
	    if (strncmp(s, mp->name, mp->len) == 0)
		break;
d1847 1
a1847 2
	if (!mp->name)
	    return -1;
d1850 4
a1853 1
	while (*s && isascii(CharOf(*s)) && isspace(CharOf(*s)))
d1855 12
a1866 8
	if (!*s)
	    return -1;

	if ((c = decode_keyvalue(&s, False)) != -1) {
	    mp->value = c;
	    mp->set = 1;
	    count++;
	    TRACE(("...parsed #%d: %s=%#x\n", count, mp->name, c));
d1868 4
d1875 1
a1875 2
int
GetBytesAvailable(int fd)
d1878 1
a1878 1
    ioctl(fd, FIONREAD, (char *) &arg);
d1888 1
a1888 78
    return kill(-pid, sig);
}

int
ptioctl(int fd, int func, void *data)
{
    APIRET rc;
    ULONG len;
    struct pt_termios pt;
    struct termio *t;
    int i;

    switch (func) {
    case TCGETA:
	rc = DosDevIOCtl(fd, XFREE86_PTY, func,
			 NULL, 0, NULL,
			 (ULONG *) & pt, sizeof(struct pt_termios), &len);
	if (rc)
	    return -1;
	t = (struct termio *) data;
	t->c_iflag = pt.c_iflag;
	t->c_oflag = pt.c_oflag;
	t->c_cflag = pt.c_cflag;
	t->c_lflag = pt.c_lflag;
	for (i = 0; i < NCC; i++)
	    t->c_cc[i] = pt.c_cc[i];
	return 0;
    case TCSETA:
    case TCSETAW:
    case TCSETAF:
	t = (struct termio *) data;
	pt.c_iflag = t->c_iflag;
	pt.c_oflag = t->c_oflag;
	pt.c_cflag = t->c_cflag;
	pt.c_lflag = t->c_lflag;

	for (i = 0; i < NCC; i++)
	    pt.c_cc[i] = t->c_cc[i];
	if (func == TCSETA)
	    i = XTY_TIOCSETA;
	else if (func == TCSETAW)
	    i = XTY_TIOCSETAW;
	else
	    i = XTY_TIOCSETAF;
	rc = DosDevIOCtl(fd, XFREE86_PTY, i,
			 (ULONG *) & pt, sizeof(struct pt_termios), &len,
			 NULL, 0, NULL);
	return (rc) ? -1 : 0;
    case TIOCCONS:
	return DosDevIOCtl(fd, XFREE86_PTY, XTY_TIOCCONS,
			   (ULONG *) data, sizeof(ULONG), &len,
			   NULL, 0, NULL);
    case TIOCSWINSZ:
	return DosDevIOCtl(fd, XFREE86_PTY, XTY_TIOCSWINSZ,
			   (ULONG *) data, sizeof(struct winsize), &len,
			   NULL, 0, NULL);
    case TIOCGWINSZ:
	return DosDevIOCtl(fd, XFREE86_PTY, XTY_TIOCGWINSZ,
			   NULL, 0, NULL,
			   (ULONG *) data, sizeof(struct winsize), &len);
    case XTY_ENADUP:
	i = 1;
	return DosDevIOCtl(fd, XFREE86_PTY, XTY_ENADUP,
			   (ULONG *) & i, sizeof(ULONG), &len,
			   NULL, 0, NULL);
    case XTY_TRACE:
	i = 2;
	return DosDevIOCtl(fd, XFREE86_PTY, XTY_TRACE,
			   (ULONG *) & i, sizeof(ULONG), &len,
			   NULL, 0, NULL);
    case PTMS_GETPTY:
	i = 1;
	return DosDevIOCtl(fd, XFREE86_PTY, PTMS_GETPTY,
			   (ULONG *) & i, sizeof(ULONG), &len,
			   (UCHAR *) data, 14, &len);
    default:
	return -1;
    }
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d8 1
a8 1
/* $XFree86: xc/programs/xterm/os2main.c,v 3.62 2003/05/21 22:59:13 dickey Exp $ */
a64 2
#define RES_OFFSET(field)	XtOffsetOf(XTERM_RESOURCE, field)

a80 2
#elif defined(HAVE_LIB_XAWPLUS)
#include <X11/XawPlus/Form.h>
d253 2
d257 20
a276 10
    Sres("name", "Name", xterm_name, DFT_TERMTYPE),
    Sres("iconGeometry", "IconGeometry", icon_geometry, NULL),
    Sres(XtNtitle, XtCTitle, title, NULL),
    Sres(XtNiconName, XtCIconName, icon_name, NULL),
    Sres("termName", "TermName", term_name, NULL),
    Sres("ttyModes", "TtyModes", tty_modes, NULL),
    Bres("hold", "Hold", hold_screen, FALSE),
    Bres("utmpInhibit", "UtmpInhibit", utmpInhibit, FALSE),
    Bres("messages", "Messages", messages, TRUE),
    Bres("sunFunctionKeys", "SunFunctionKeys", sunFunctionKeys, FALSE),
d278 2
a279 1
    Bres("sunKeyboard", "SunKeyboard", sunKeyboard, FALSE),
d282 2
a283 1
    Bres("hpFunctionKeys", "HpFunctionKeys", hpFunctionKeys, FALSE),
d285 4
a288 2
    Bres("waitForMap", "WaitForMap", wait_for_map, FALSE),
    Bres("useInsertMode", "UseInsertMode", useInsertMode, FALSE),
d290 2
a291 1
    Ires("zIconBeep", "ZIconBeep", zIconBeep, 0),
d294 2
a295 1
    Bres("sameName", "SameName", sameName, TRUE),
d298 2
a299 1
    Bres("sessionMgt", "SessionMgt", sessionMgt, TRUE),
d302 1
a379 4
#if OPT_C1_PRINT
{"-k8",		"*allowC1Printable", XrmoptionNoArg,	(caddr_t) "on"},
{"+k8",		"*allowC1Printable", XrmoptionNoArg,	(caddr_t) "off"},
#endif
d514 1
a514 1
{ "-fi fontname",          "icon font for active icon" },
d517 3
a519 3
{ "-/+bc",                 "turn on/off text cursor blinking" },
{ "-bcf milliseconds",     "time text cursor is off when blinking"},
{ "-bcn milliseconds",     "time text cursor is on when blinking"},
d527 1
a527 1
{ "-/+dc",                 "turn off/on dynamic color selection" },
d534 2
a535 2
{ "-/+hold",               "turn on/off logic that retains window after exit" },
{ "-/+im",                 "use insert mode for TERMCAP" },
a536 3
#if OPT_C1_PRINT
{ "-/+k8",                 "turn on/off C1-printable classification"},
#endif
d547 1
a547 1
{ "-/+mesg",               "forbid/allow messages" },
d560 1
a560 1
{ "-/+rvc",                "turn off/on display of reverse as color" },
a1331 2
	} else {
	    fprintf(stderr, "Unable to open %s, errno=%d\n", ptydev, errno);
d1497 1
a1497 1
    TTYSIZE_STRUCT ts;
d1609 7
a1615 2
    if (!get_termcap(TermName = resource.term_name, ptr, newtc)) {
	char *last = NULL;
d1618 1
a1618 2
	    if ((last == NULL || strcmp(last, *envnew))
		&& get_termcap(*envnew, ptr, newtc)) {
a1621 1
	    last = *envnew;
d1629 4
a1632 4
	TTYSIZE_ROWS(ts) = 38;
	TTYSIZE_COLS(ts) = 81;
	ts.ws_xpixel = TFullWidth(screen);
	ts.ws_ypixel = TFullHeight(screen);
d1636 4
a1639 4
	TTYSIZE_ROWS(ts) = screen->max_row + 1;
	TTYSIZE_COLS(ts) = screen->max_col + 1;
	ts.ws_xpixel = FullWidth(screen);
	ts.ws_ypixel = FullHeight(screen);
d1777 4
a1780 4
		TTYSIZE_ROWS(ts) = screen->max_row + 1;
		TTYSIZE_COLS(ts) = screen->max_col + 1;
		ts.ws_xpixel = FullWidth(screen);
		ts.ws_ypixel = FullHeight(screen);
d1792 1
a1792 1
	    ptioctl(0, TIOCSWINSZ, (char *) &ts);
d2075 1
a2075 1
			   (ULONG *) data, sizeof(TTYSIZE_STRUCT), &len,
d2080 1
a2080 1
			   (ULONG *) data, sizeof(TTYSIZE_STRUCT), &len);
@


