head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.4
	cvs-200410241530:1.1.1.4
	cvs-200410012000:1.1.1.4
	cvs-200407190955:1.1.1.4
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.11.09;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.11.09;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.41.10;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.45.45;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.07.19.09.59.08;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.29.38;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $Xorg: button.c,v 1.3 2000/08/17 19:55:08 cpqbld Exp $ */
/*
 * Copyright 1999,2000,2001,2002 by Thomas E. Dickey
 *
 *                         All Rights Reserved
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name(s) of the above copyright
 * holders shall not be used in advertising or otherwise to promote the
 * sale, use or other dealings in this Software without prior written
 * authorization.
 *
 *
 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */
/* $XFree86: xc/programs/xterm/button.c,v 3.65 2002/01/06 01:34:23 dickey Exp $ */

/*
button.c	Handles button events in the terminal emulator.
		does cut/paste operations, change modes via menu,
		passes button events through to some applications.
				J. Gettys.
*/

#include <xterm.h>

#include <stdio.h>

#include <X11/Xatom.h>
#include <X11/Xmu/Atoms.h>
#include <X11/Xmu/StdSel.h>

#include <xutf8.h>

#include <data.h>
#include <error.h>
#include <menu.h>
#include <xcharmouse.h>

#if OPT_WIDE_CHARS
#include <charclass.h>
#include <wcwidth.h>
#else
#define CharacterClass(value) \
	charClass[value & ((sizeof(charClass)/sizeof(charClass[0]))-1)]
#endif

#define XTERM_CELL(row,col) getXtermCell(screen, row + screen->topline, col)
#define XTERM_CELL_C1(row,col) getXtermCellComb1(screen, row + screen->topline, col)
#define XTERM_CELL_C2(row,col) getXtermCellComb2(screen, row + screen->topline, col)

      /*
       * We reserve shift modifier for cut/paste operations.  In principle we
       * can pass through control and meta modifiers, but in practice, the
       * popup menu uses control, and the window manager is likely to use meta,
       * so those events are not delivered to SendMousePosition.
       */
#define OurModifiers (ShiftMask | ControlMask | Mod1Mask)
#define AllModifiers (ShiftMask | LockMask | ControlMask | Mod1Mask | \
		      Mod2Mask | Mod3Mask | Mod4Mask | Mod5Mask)

#define KeyModifiers (event->xbutton.state & OurModifiers)

#define KeyState(x) (((x) & (ShiftMask|ControlMask)) + (((x) & Mod1Mask) ? 2 : 0))
    /* adds together the bits:
	shift key -> 1
	meta key  -> 2
	control key -> 4 */

#define	Coordinate(r,c)		((r) * (term->screen.max_col+1) + (c))

#if OPT_DEC_LOCATOR
static ANSI reply;
#endif

/* Selection/extension variables */

/* Raw char position where the selection started */
static int rawRow, rawCol;

/* Selected area before CHAR, WORD, LINE selectUnit processing */
static int startRRow, startRCol, endRRow, endRCol = 0;

/* Selected area after CHAR, WORD, LINE selectUnit processing */
static int startSRow, startSCol, endSRow, endSCol = 0;

/* Valid rows for selection clipping */
static int firstValidRow, lastValidRow;

/* Start, end of extension */
static int startERow, startECol, endERow, endECol;

/* Saved values of raw selection for extend to restore to */
static int saveStartRRow, saveStartRCol, saveEndRRow, saveEndRCol;

/* Saved value of WORD selection for LINE processing to restore to */
static int saveStartWRow, saveStartWCol;

/* Multi-click handling */
static int numberOfClicks = 0;
static Time lastButtonUpTime = 0;
typedef int SelectUnit;
#define SELECTCHAR 0
#define SELECTWORD 1
#define SELECTLINE 2
#define NSELECTUNITS 3
static SelectUnit selectUnit;

/* Send emacs escape code when done selecting or extending? */
static int replyToEmacs;

static Char *SaveText (TScreen *screen, int row, int scol, int ecol, Char *lp, int *eol);
static int Length (TScreen *screen, int row, int scol, int ecol);
static void ComputeSelect (int startRow, int startCol, int endRow, int endCol, Bool extend);
static void EditorButton (XButtonEvent *event);
static void EndExtend (Widget w, XEvent *event, String *params, Cardinal num_params, Bool use_cursor_loc);
static void ExtendExtend (int row, int col);
static void PointToRowCol (int y, int x, int *r, int *c);
static void ReHiliteText (int frow, int fcol, int trow, int tcol);
static void SaltTextAway (int crow, int ccol, int row, int col, String *params, Cardinal num_params);
static void SelectSet (Widget w, XEvent *event, String *params, Cardinal num_params);
static void SelectionReceived PROTO_XT_SEL_CB_ARGS;
static void StartSelect (int startrow, int startcol);
static void TrackDown (XButtonEvent *event);
static void _OwnSelection (XtermWidget termw, String *selections, Cardinal count);

Boolean SendMousePosition(Widget w, XEvent* event)
{
    TScreen *screen;

    if (!IsXtermWidget(w))
	return False;

    screen = &((XtermWidget)w)->screen;

    /* If send_mouse_pos mode isn't on, we shouldn't be here */
    if (screen->send_mouse_pos == MOUSE_OFF)
	return False;

#if OPT_DEC_LOCATOR
    if (screen->send_mouse_pos == DEC_LOCATOR) {
	return( SendLocatorPosition( w, event ) );
    }
#endif	/* OPT_DEC_LOCATOR */

    /* Make sure the event is an appropriate type */
    if ((screen->send_mouse_pos != BTN_EVENT_MOUSE)
     && (screen->send_mouse_pos != ANY_EVENT_MOUSE)
     && event->type != ButtonPress
     && event->type != ButtonRelease)
	return False;

    switch (screen->send_mouse_pos) {
      case X10_MOUSE: /* X10 compatibility sequences */

	if (KeyModifiers == 0) {
	    if (event->type == ButtonPress)
		EditorButton((XButtonEvent *)event);
	    return True;
	}
	return False;

      case VT200_HIGHLIGHT_MOUSE: /* DEC vt200 hilite tracking */
	if (  event->type == ButtonPress &&
	      KeyModifiers == 0 &&
	      event->xbutton.button == Button1 ) {
	    TrackDown((XButtonEvent *)event);
	    return True;
	}
	if (KeyModifiers == 0 || KeyModifiers == ControlMask) {
	    EditorButton((XButtonEvent *)event);
	    return True;
	}
	return False;

      case VT200_MOUSE:	/* DEC vt200 compatible */

      /* xterm extension for motion reporting. June 1998 */
      /* EditorButton() will distinguish between the modes */
      case BTN_EVENT_MOUSE:
      case ANY_EVENT_MOUSE:
	if (KeyModifiers == 0 || KeyModifiers == ControlMask) {
	    EditorButton((XButtonEvent *)event);
	    return True;
	}
	return False;

      default:
	return False;
    }
}

#if OPT_DEC_LOCATOR

#define	LocatorCoords( row, col, x, y, oor )			\
    if( screen->locator_pixels ) {				\
	(oor)=FALSE; (row) = (y)+1; (col) = (x)+1;		\
	/* Limit to screen dimensions */			\
	if ((row) < 1) (row) = 1,(oor)=TRUE;			\
	else if ((row) > screen->border*2+Height(screen))	\
	    (row) = screen->border*2+Height(screen),(oor)=TRUE;	\
	if ((col) < 1) (col) = 1,(oor)=TRUE;			\
	else if ((col) > OriginX(screen)*2+Width(screen))	\
	    (col) = OriginX(screen)*2+Width(screen),(oor)=TRUE;	\
    } else {							\
	(oor)=FALSE;						\
	/* Compute character position of mouse pointer */	\
	(row) = ((y) - screen->border) / FontHeight(screen);	\
	(col) = ((x) - OriginX(screen)) / FontWidth(screen);	\
	/* Limit to screen dimensions */			\
	if ((row) < 0) (row) = 0,(oor)=TRUE;			\
	else if ((row) > screen->max_row)			\
	    (row) = screen->max_row,(oor)=TRUE;			\
	if ((col) < 0) (col) = 0,(oor)=TRUE;			\
	else if ((col) > screen->max_col)			\
	    (col) = screen->max_col,(oor)=TRUE;			\
	(row)++; (col)++;					\
    }

#define	MotionOff( s, t ) {						\
	    (s)->event_mask |= ButtonMotionMask;			\
	    (s)->event_mask &= ~PointerMotionMask;			\
	    XSelectInput(XtDisplay((t)), XtWindow((t)), (s)->event_mask); }

#define	MotionOn( s, t ) {						\
	    (s)->event_mask &= ~ButtonMotionMask;			\
	    (s)->event_mask |= PointerMotionMask;			\
	    XSelectInput(XtDisplay((t)), XtWindow((t)), (s)->event_mask); }

Boolean
SendLocatorPosition(Widget w, XEvent* event)
{
    TScreen	*screen = &((XtermWidget)w)->screen;
    int		row, col;
    Boolean	oor;
    int		button;
    int		state;

    /* Make sure the event is an appropriate type */
    if ((event->type != ButtonPress &&
	 event->type != ButtonRelease &&
	 !screen->loc_filter) ||
	(KeyModifiers != 0 && KeyModifiers != ControlMask))
	return( False );

    if ((event->type == ButtonPress &&
	 !(screen->locator_events & LOC_BTNS_DN)) ||
	(event->type == ButtonRelease &&
	 !(screen->locator_events & LOC_BTNS_UP)))
	return( True );

    if( event->type == MotionNotify ) {
	CheckLocatorPosition( w, event );
	return( True );
    }

    /* get button # */
    button = event->xbutton.button - 1;

    LocatorCoords( row, col, event->xbutton.x, event->xbutton.y, oor );

    /*
    * DECterm mouse:
    *
    * ESCAPE '[' event ; mask ; row ; column '&' 'w'
    */
    reply.a_type   = CSI;

    if( oor) {
	reply.a_nparam = 1;
	reply.a_param[0] = 0; /* Event - 0 = locator unavailable */
	reply.a_inters = '&';
	reply.a_final  = 'w';
	unparseseq(&reply, screen->respond);

	if( screen->locator_reset ) {
	    MotionOff( screen, term );
	    screen->send_mouse_pos = MOUSE_OFF;
	}
	return( True );
    }

    /*
    * event:
    *	1	no buttons
    *	2	left button down
    *	3	left button up
    *	4	middle button down
    *	5	middle button up
    *	6	right button down
    *	7	right button up
    *	8	M4 down
    *	9	M4 up
    */
    reply.a_nparam = 4;
    switch(event->type)
    {
	case ButtonPress:
	    reply.a_param[0] = 2 + (button<<1);
	    break;
	case ButtonRelease:
	    reply.a_param[0] = 3 + (button<<1);
	    break;
	default:
	    return( True );
    }
    /*
    * mask:
    * bit 7   bit 6   bit 5   bit 4   bit 3   bit 2       bit 1         bit 0
    *                                 M4 down left down   middle down   right down
    *
    * Notice that Button1 (left) and Button3 (right) are swapped in the mask.
    * Also, mask should be the state after the button press/release,
    * X provides the state not including the button press/release.
    */
    state = (event->xbutton.state & (Button1Mask | Button2Mask | Button3Mask | Button4Mask)) >> 8;
    state ^= 1 << button;	/* update mask to "after" state */
    state = (state & ~(4|1)) | ((state&1)?4:0) | ((state&4)?1:0);	/* swap Button1 & Button3 */

    reply.a_param[1] = state;
    reply.a_param[2] = row;
    reply.a_param[3] = col;
    reply.a_inters = '&';
    reply.a_final  = 'w';

    unparseseq(&reply, screen->respond);

    if( screen->locator_reset ) {
	MotionOff( screen, term );
	screen->send_mouse_pos = MOUSE_OFF;
    }

    /*
    * DECterm turns the Locator off if a button is pressed while a filter rectangle
    * is active. This might be a bug, but I don't know, so I'll emulate it anyways.
    */
    if( screen->loc_filter ) {
	screen->send_mouse_pos = MOUSE_OFF;
	screen->loc_filter = FALSE;
	screen->locator_events = 0;
	MotionOff( screen, term );
    }

    return( True );
}

/*
* mask:
* bit 7   bit 6   bit 5   bit 4   bit 3   bit 2       bit 1         bit 0
*                                 M4 down left down   middle down   right down
*
* Button1 (left) and Button3 (right) are swapped in the mask relative to X.
*/
#define	ButtonState(state, mask)	\
{ (state) = ((mask) & (Button1Mask | Button2Mask | Button3Mask | Button4Mask)) >> 8;	\
  /* swap Button1 & Button3 */								\
  (state) = ((state) & ~(4|1)) | (((state)&1)?4:0) | (((state)&4)?1:0);			\
}

void
GetLocatorPosition(XtermWidget w)
{
    TScreen		*screen = &w->screen;
    Window		root, child;
    int			rx, ry, x, y;
    unsigned int	mask;
    int			row = 0, col = 0;
    Boolean		oor = FALSE;
    Bool		ret = FALSE;
    int			state;

    /*
    * DECterm turns the Locator off if the position is requested while a filter rectangle
    * is active.  This might be a bug, but I don't know, so I'll emulate it anyways.
    */
    if( screen->loc_filter ) {
	screen->send_mouse_pos = MOUSE_OFF;
	screen->loc_filter = FALSE;
	screen->locator_events = 0;
	MotionOff( screen, term );
    }

    reply.a_type   = CSI;

    if (screen->send_mouse_pos == DEC_LOCATOR) {
	ret = XQueryPointer( screen->display, VWindow(screen), &root,
			&child, &rx, &ry, &x, &y, &mask );
	if (ret) {
	    LocatorCoords( row, col, x, y, oor );
	}
    }
    if( ret == FALSE || oor )
    {
	reply.a_nparam = 1;
	reply.a_param[0] = 0; /* Event - 0 = locator unavailable */
	reply.a_inters = '&';
	reply.a_final  = 'w';
	unparseseq(&reply, screen->respond);

	if( screen->locator_reset ) {
	    MotionOff( screen, term );
	    screen->send_mouse_pos = MOUSE_OFF;
	}
	return;
    }

    ButtonState( state, mask );

    reply.a_nparam = 4;
    reply.a_param[0] = 1; /* Event - 1 = response to locator request */
    reply.a_param[1] = state;
    reply.a_param[2] = row;
    reply.a_param[3] = col;
    reply.a_inters = '&';
    reply.a_final  = 'w';
    unparseseq(&reply, screen->respond);

    if( screen->locator_reset ) {
	MotionOff( screen, term );
	screen->send_mouse_pos = MOUSE_OFF;
    }
}

void
InitLocatorFilter( XtermWidget w )
{
    TScreen		*screen = &w->screen;
    Window		root, child;
    int			rx, ry, x, y;
    unsigned int	mask;
    int			row = 0, col = 0;
    Boolean		oor = 0;
    Bool		ret;
    int			state;

    ret = XQueryPointer( screen->display, VWindow(screen),
			    &root, &child, &rx, &ry, &x, &y, &mask );
    if (ret) {
	LocatorCoords( row, col, x, y, oor );
    }
    if( ret == FALSE || oor )
    {
	/* Locator is unavailable */

	if( screen->loc_filter_top    != LOC_FILTER_POS ||
	    screen->loc_filter_left   != LOC_FILTER_POS ||
	    screen->loc_filter_bottom != LOC_FILTER_POS ||
	    screen->loc_filter_right  != LOC_FILTER_POS )
	{
	    /*
	    * If any explicit coordinates were received,
	    * report immediately with no coordinates.
	    */
	    reply.a_type   = CSI;
	    reply.a_nparam = 1;
	    reply.a_param[0] = 0; /* Event - 0 = locator unavailable */
	    reply.a_inters = '&';
	    reply.a_final  = 'w';
	    unparseseq(&reply, screen->respond);

	    if( screen->locator_reset ) {
		MotionOff( screen, term );
		screen->send_mouse_pos = MOUSE_OFF;
	    }
	} else {
	    /*
	    * No explicit coordinates were received, and the pointer is
	    * unavailable.  Report when the pointer re-enters the window.
	    */
	    screen->loc_filter = TRUE;
	    MotionOn( screen, term );
	}
	return;
    }

    /*
    * Adjust rectangle coordinates:
    *  1. Replace "LOC_FILTER_POS" with current coordinates
    *  2. Limit coordinates to screen size
    *  3. make sure top and left are less than bottom and right, resp.
    */
    if( screen->locator_pixels ) {
	rx = OriginX(screen)*2+Width(screen);
	ry = screen->border*2+Height(screen);
    } else {
	rx = screen->max_col;
	ry = screen->max_row;
    }

#define	Adjust( coord, def, max )				\
	if( (coord) == LOC_FILTER_POS )	(coord) = (def);	\
	else if ((coord) < 1)		(coord) = 1;		\
	else if ((coord) > (max))	(coord) = (max)

    Adjust( screen->loc_filter_top, row, ry );
    Adjust( screen->loc_filter_left, col, rx );
    Adjust( screen->loc_filter_bottom, row, ry );
    Adjust( screen->loc_filter_right, col, rx );

    if( screen->loc_filter_top > screen->loc_filter_bottom ) {
	ry = screen->loc_filter_top;
	screen->loc_filter_top = screen->loc_filter_bottom;
	screen->loc_filter_bottom = ry;
    }

    if( screen->loc_filter_left > screen->loc_filter_right ) {
	rx = screen->loc_filter_left;
	screen->loc_filter_left = screen->loc_filter_right;
	screen->loc_filter_right = rx;
    }

    if( (col < screen->loc_filter_left) ||
	(col > screen->loc_filter_right) ||
	(row < screen->loc_filter_top) ||
	(row > screen->loc_filter_bottom) )
    {
	/* Pointer is already outside the rectangle - report immediately */
	ButtonState( state, mask );

	reply.a_type   = CSI;
	reply.a_nparam = 4;
	reply.a_param[0] = 10; /* Event - 10 = locator outside filter */
	reply.a_param[1] = state;
	reply.a_param[2] = row;
	reply.a_param[3] = col;
	reply.a_inters = '&';
	reply.a_final  = 'w';
	unparseseq(&reply, screen->respond);

	if( screen->locator_reset ) {
	    MotionOff( screen, term );
	    screen->send_mouse_pos = MOUSE_OFF;
	}
	return;
    }

    /*
    * Rectangle is set up.  Allow pointer tracking
    * to detect if the mouse leaves the rectangle.
    */
    screen->loc_filter = TRUE;
    MotionOn( screen, term );
}

void
CheckLocatorPosition( Widget w, XEvent *event )
{
    TScreen		*screen = &((XtermWidget)w)->screen;
    int			row, col;
    Boolean		oor;
    int			state;

    LocatorCoords( row, col, event->xbutton.x, event->xbutton.y, oor );

    /*
    * Send report if the pointer left the filter rectangle, if
    * the pointer left the window, or if the filter rectangle
    * had no coordinates and the pointer re-entered the window.
    */
    if (oor || (screen->loc_filter_top == LOC_FILTER_POS) ||
	(col < screen->loc_filter_left)  ||
	(col > screen->loc_filter_right) ||
	(row < screen->loc_filter_top)   ||
	(row > screen->loc_filter_bottom))
    {
	/* Filter triggered - disable it */
	screen->loc_filter = FALSE;
	MotionOff( screen, term );

	reply.a_type   = CSI;
	if (oor) {
	    reply.a_nparam = 1;
	    reply.a_param[0] = 0; /* Event - 0 = locator unavailable */
	} else {
	    ButtonState( state, event->xbutton.state );

	    reply.a_nparam = 4;
	    reply.a_param[0] = 10; /* Event - 10 = locator outside filter */
	    reply.a_param[1] = state;
	    reply.a_param[2] = row;
	    reply.a_param[3] = col;
	}

	reply.a_inters = '&';
	reply.a_final  = 'w';
	unparseseq(&reply, screen->respond);

	if( screen->locator_reset ) {
	    MotionOff( screen, term );
	    screen->send_mouse_pos = MOUSE_OFF;
	}
    }
}
#endif	/* OPT_DEC_LOCATOR */

void
DiredButton(
	Widget w GCC_UNUSED,
	XEvent *event,			/* must be XButtonEvent */
	String *params GCC_UNUSED,	/* selections */
	Cardinal *num_params GCC_UNUSED)
{	/* ^XM-G<line+' '><col+' '> */
    register TScreen *screen = &term->screen;
    Char Line[ 6 ];
    register unsigned line, col;

    if (event->type == ButtonPress || event->type == ButtonRelease) {
	line = ( event->xbutton.y - screen->border ) / FontHeight( screen );
	col  = ( event->xbutton.x - OriginX(screen)) / FontWidth( screen );
	Line[0] = CONTROL('X');
	Line[1] = ESC;
	Line[2] = 'G';
	Line[3] = ' ' + col;
	Line[4] = ' ' + line;
	v_write(screen->respond, Line, 5 );
    }
}

void
ViButton(
	Widget w GCC_UNUSED,
	XEvent *event,			/* must be XButtonEvent */
	String *params GCC_UNUSED,	/* selections */
	Cardinal *num_params GCC_UNUSED)
{	/* ^XM-G<line+' '><col+' '> */
    register TScreen *screen = &term->screen;
    int pty = screen->respond;
    Char Line[ 6 ];
    register int line;

    if (event->type == ButtonPress || event->type == ButtonRelease) {

	line = screen->cur_row -
		(( event->xbutton.y - screen->border ) / FontHeight( screen ));
	if (line != 0) {
	    Line[0] = ESC;	/* force an exit from insert-mode */
	    v_write(pty, Line, 1 );

	    if ( line < 0 ) {
		line = -line;
		Line[0] = CONTROL('n');
	    } else {
		Line[0] = CONTROL('p');
	    }
	    while ( --line >= 0 )
		v_write(pty, Line, 1 );
	}
    }
}


/*
 * This function handles button-motion events
 */
/*ARGSUSED*/
void HandleSelectExtend(
	Widget w,
	XEvent *event,		/* must be XMotionEvent */
	String *params GCC_UNUSED,
	Cardinal *num_params GCC_UNUSED)
{
	register TScreen *screen;
	int row, col;

	if (!IsXtermWidget(w))
		return;

	screen = &((XtermWidget)w)->screen;
	screen->selection_time = event->xmotion.time;
	switch (eventMode) {
		/* If not in one of the DEC mouse-reporting modes */
		case LEFTEXTENSION :
		case RIGHTEXTENSION :
			PointToRowCol (event->xmotion.y, event->xmotion.x,
				       &row, &col);
			ExtendExtend (row, col);
			break;

		/* If in motion reporting mode, send mouse position to
		   character process as a key sequence \E[M... */
		case NORMAL :
			/* will get here if send_mouse_pos != MOUSE_OFF */
			if ( screen->send_mouse_pos == BTN_EVENT_MOUSE
			 ||  screen->send_mouse_pos == ANY_EVENT_MOUSE )
			    SendMousePosition(w,event);
			break;
	}
}

static void do_select_end (
	Widget w,
	XEvent *event,		/* must be XButtonEvent */
	String *params,		/* selections */
	Cardinal *num_params,
	Bool use_cursor_loc)
{
	if (!IsXtermWidget(w))
		return;

	((XtermWidget)w)->screen.selection_time = event->xbutton.time;
	switch (eventMode) {
		case NORMAL :
		    (void) SendMousePosition(w, event);
		    break;
		case LEFTEXTENSION :
		case RIGHTEXTENSION :
		    EndExtend(w, event, params, *num_params, use_cursor_loc);
		    break;
	}
}


void HandleSelectEnd(
	Widget w,
	XEvent *event,		/* must be XButtonEvent */
	String *params,		/* selections */
	Cardinal *num_params)
{
	do_select_end (w, event, params, num_params, False);
}


void HandleKeyboardSelectEnd(
	Widget w,
	XEvent *event,		/* must be XButtonEvent */
	String *params,		/* selections */
	Cardinal *num_params)
{
	do_select_end (w, event, params, num_params, True);
}

struct _SelectionList {
    String *params;
    Cardinal count;
    Atom *targets;
    Time time;
};

/* convert a UTF-8 string to Latin-1, replacing non Latin-1 characters
 * by `#'. */

#if OPT_WIDE_CHARS
static Char *
UTF8toLatin1(Char *s, int len, unsigned long *result)
{
    static Char *buffer;
    static size_t used;

    Char *p = s;
    Char *q;

    if (used == 0) {
	buffer = (Char*)XtMalloc(used = len);
    } else if (len > (int) used) {
	buffer = (Char*)XtRealloc((char*)buffer, used = len);
    }
    q = buffer;

     /* We're assuming that the xterm widget never contains Unicode
	control characters. */

    while (p < s + len) {
	if ((*p & 0x80) == 0) {
	    *q++ = *p++;
	} else if ((*p & 0x7C) == 0x40 && p < s + len - 1) {
	    *q++ = ((*p & 0x03) << 6) | (p[1] & 0x3F);
	    p += 2;
	} else if ((*p & 0x60) == 0x40) {
	    *q++ = '#';
	    p += 2;
	} else if ((*p & 0x50) == 0x40) {
	    *q++ = '#';
	    p += 3;
	} else {		/* this cannot happen */
	    *q++ = '#';
	    p++;
	}
    }
    *result = q - buffer;
    return buffer;
}

#if 0
/* Eliminate all control characters from a UTF-8 string, doing
   something reasonable with PS and LS */

static Char*
filterUTF8(Char *s, int len, int *len_return)
{
    Char *p=s;
    Char *t;
    Char *q;
    unsigned codepoint;
    int size;

    t = (Char *)XtMalloc(len);
    if (t == 0) {
	TRACE(("Couldn't allocate target string\n"));
	return 0;
    }
    q = t;

    while (p < (s + len) && q < (t + len)) {
	if ((*p & 0x80) == 0) {
	    codepoint = *p & 0x7F;
	    size = 1;
	} else if ((*p & 0x60) == 0x40 && p < s + len - 1) {
	    codepoint = ((p[0] & 0x1F) << 6) | (p[1] & 0x3F);
	    size = 2;
	} else if ((*p & 0x70) == 0x60 && p < s + len - 2) {
	    codepoint = ((p[0] & 0x0F) << 12)
		      | ((p[1] & 0x3F) << 6)
		      | (p[2] & 0x3F);
	    size = 3;
	} else if ((*p & 0x78) == 0x70 && p < s + len - 3) {
	    p += 4;		/* eliminate surrogates */
	    continue;
	} else if ((*p & 0x7C) == 0x78 && p < s + len - 4) {
	    p += 5;
	    continue;
	} else if ((*p & 0x7E) == 0x7C && p < s + len - 5) {
	    p += 6;
	    continue;
	} else {		/* wrong UTF-8?  Silently discard. */
	    p++;
	    continue;
	}

	if(codepoint == 0x2028) {
	    /* line separator -- replace by NL*/
	    p += size;
	    *q++ = 0x0A;
	} else if (codepoint == 0x2029) {
	    /* paragraph separator -- replace by NL NL */
	    p += size;
	    *q++ = 0x0A;
	    if (q < t + len)
		*q++ = 0x0A;
	} else if (codepoint >= 0x202A && codepoint <= 0x202E) {
	    /* ignore Unicode control characters; surrogates have already
	       been eliminated */
	    p += size;
	} else {
	    /* just copy the UTF-8 */
	  while (size--)
	    *q++ = *p++;
	}
    }
    *len_return = q - t;
    return t;
}
#endif

#endif /* OPT_WIDE_CHARS */

static Atom *
_SelectionTargets(Widget w)
{
    static Atom *eightBitSelectionTargets = NULL;
    TScreen *screen;
    int n;

    if(!IsXtermWidget(w))
	return NULL;

    screen =  &((XtermWidget)w)->screen;

#if OPT_WIDE_CHARS
    if (screen->wide_chars) {
	static Atom *utf8SelectionTargets = NULL;

	if (utf8SelectionTargets == NULL) {
	    utf8SelectionTargets = (Atom*)XtMalloc(5 * sizeof(Atom));
	    if (utf8SelectionTargets == NULL) {
		TRACE(("Couldn't allocate utf8SelectionTargets\n"));
		return NULL;
	    }
	    n = 0;
	    utf8SelectionTargets[n] = XA_UTF8_STRING(XtDisplay(w)); n++;
#ifdef X_HAVE_UTF8_STRING
	    if (screen->i18nSelections) {
		utf8SelectionTargets[n] = XA_TEXT(XtDisplay(w)); n++;
		utf8SelectionTargets[n] = XA_COMPOUND_TEXT(XtDisplay(w)); n++;
	    }
#endif
	    utf8SelectionTargets[n] = XA_STRING; n++;
	    utf8SelectionTargets[n] = None;
	}
	return utf8SelectionTargets;
    }
#endif

    /* not screen->wide_chars */
    if (eightBitSelectionTargets == NULL) {
	eightBitSelectionTargets = (Atom*)XtMalloc(5 * sizeof(Atom));
	if (eightBitSelectionTargets == NULL) {
	    TRACE(("Couldn't allocate eightBitSelectionTargets\n"));
	    return NULL;
	}
	n = 0;
#ifdef X_HAVE_UTF8_STRING
	eightBitSelectionTargets[n] = XA_UTF8_STRING(XtDisplay(w)); n++;
#endif
	if (screen->i18nSelections) {
	    eightBitSelectionTargets[n] = XA_TEXT(XtDisplay(w)); n++;
	    eightBitSelectionTargets[n] = XA_COMPOUND_TEXT(XtDisplay(w)); n++;
	}
	eightBitSelectionTargets[n] = XA_STRING; n++;
	eightBitSelectionTargets[n] = None;
    }
    return eightBitSelectionTargets;
}

static void _GetSelection(
	Widget w,
	Time ev_time,
	String *params,			/* selections in precedence order */
	Cardinal num_params,
	Atom *targets)
{
    Atom selection;
    int cutbuffer;
    Atom target;

    if (!IsXtermWidget(w))
	return;

    XmuInternStrings(XtDisplay(w), params, (Cardinal)1, &selection);
    switch (selection) {
      case XA_CUT_BUFFER0: cutbuffer = 0; break;
      case XA_CUT_BUFFER1: cutbuffer = 1; break;
      case XA_CUT_BUFFER2: cutbuffer = 2; break;
      case XA_CUT_BUFFER3: cutbuffer = 3; break;
      case XA_CUT_BUFFER4: cutbuffer = 4; break;
      case XA_CUT_BUFFER5: cutbuffer = 5; break;

      case XA_CUT_BUFFER6: cutbuffer = 6; break;
      case XA_CUT_BUFFER7: cutbuffer = 7; break;
      default:		   cutbuffer = -1;
    }
    TRACE(("Cutbuffer: %d, target: %lu\n", cutbuffer,
	   targets ? (unsigned long)targets[0] : 0));
    if (cutbuffer >= 0) {
	int inbytes;
	unsigned long nbytes;
	int fmt8 = 8;
	Atom type = XA_STRING;
	char *line = XFetchBuffer(XtDisplay(w), &inbytes, cutbuffer);
	nbytes = (unsigned long) inbytes;
	if (nbytes > 0)
	    SelectionReceived(w, NULL, &selection, &type, (XtPointer)line,
			      &nbytes, &fmt8);
	else if (num_params > 1)
	    _GetSelection(w, ev_time, params+1, num_params-1, NULL);
	return;
    } else {
	struct _SelectionList* list;

	if (targets == NULL || targets[0] == None) {
	    targets = _SelectionTargets(w);
	}

	if (targets != 0) {
	    target = targets[0];

	    if (targets[1] == None) { /* last target in list */
		params++;
		num_params--;
		targets = _SelectionTargets(w);
	    } else {
		targets = &(targets[1]);
	    }

	    if (num_params) {
		list = XtNew(struct _SelectionList);
		list->params = params;
		list->count = num_params;
		list->targets = targets;
		list->time = ev_time;
	    } else list = NULL;

	    XtGetSelectionValue(w, selection,
				target,
				SelectionReceived,
				(XtPointer)list, ev_time);
	}
    }
}

#if OPT_TRACE && OPT_WIDE_CHARS
static void GettingSelection(Display *dpy, Atom type, Char *line, int len)
{
    Char *cp;
    char *name;

    name = XGetAtomName(dpy, type);

    Trace("Getting %s (%ld)\n", XGetAtomName(dpy, type), (long int)type);
    for (cp = line; cp < line + len; cp++)
	Trace("%c\n", *cp);
}
#else
#define GettingSelection(dpy,type,line,len) /* nothing */
#endif

#ifndef VMS
static void
_WriteSelectionData(int pty, Char *line, int length)
{
    /* Write data to pty a line at a time. */
    /* Doing this one line at a time may no longer be necessary
       because v_write has been re-written. */

    register Char *lag, *cp, *end;

    end = &line[length];
    lag = line;
    for (cp = line; cp != end; cp++) {
	if (*cp == '\n') {
	    *cp = '\r';
	    v_write(pty, lag, cp - lag + 1);
	    lag = cp + 1;
	}
    }
    if (lag != end) {
	v_write(pty, lag, end - lag);
    }
}

#else  /* VMS */

static void
_WriteSelectionData(int pty, Char *line, int length)
{
    /* in the VMS version, if tt_pasting isn't set to TRUE then qio
       reads aren't blocked and an infinite loop is entered, where the
       pasted text shows up as new input, goes in again, shows up
       again, ad nauseum. */

    register Char *lag, *cp, *end;

    tt_pasting = TRUE;

    end = &line[length];
    lag = line;
    for (cp = line; cp != end; cp++) {
	if (*cp == '\n') {
	    *cp = '\r';
	    tt_write(lag, cp - lag + 1);
	    lag = cp + 1;
	}
    }
    if (lag != end) {
	tt_write(lag, end - lag);
    }

    tt_pasting = FALSE;
    tt_start_read();  /* reenable reads or a character may be lost */
}
#endif /* VMS */

/* SelectionReceived: stuff received selection text into pty */

/* ARGSUSED */
static void SelectionReceived(
	Widget w,
	XtPointer client_data,
	Atom *selection GCC_UNUSED,
	Atom *type,
	XtPointer value,
	unsigned long *length,
	int *format GCC_UNUSED)
{
    char **text_list = NULL;
    int text_list_count;
    XTextProperty text_prop;
    TScreen *screen;
    Display *dpy;
#if OPT_TRACE && OPT_WIDE_CHARS
    Char *line = (Char*)value;
#endif

    if (!IsXtermWidget(w))
	return;
    screen = &((XtermWidget)w)->screen;
    dpy = XtDisplay(w);

    if (*type == 0 /*XT_CONVERT_FAIL*/ || *length == 0 || value == NULL)
	goto fail;

    text_prop.value = (unsigned char *)value;
    text_prop.encoding = *type;
    text_prop.format = *format;
    text_prop.nitems = *length;

#if OPT_WIDE_CHARS
    if(screen->wide_chars) {
	if (*type == XA_UTF8_STRING(XtDisplay(w)) ||
            *type == XA_STRING ||
            *type == XA_COMPOUND_TEXT(XtDisplay(w))) {
	    GettingSelection(dpy, *type, line, *length);
	    if(Xutf8TextPropertyToTextList(dpy, &text_prop,
					   &text_list,
					   &text_list_count) < 0) {
		TRACE(("Conversion failed\n"));
		text_list = NULL;
	    }
	}
    } else
#endif /* OPT_WIDE_CHARS */
    {
	/* Convert the selection to locale's multibyte encoding. */

        /* There's no need to special-case UTF8_STRING.  If Xlib
           doesn't know about it, we didn't request it.  If a broken
           selection holder sends it anyhow, the conversion function
           will fail. */

	if (*type == XA_UTF8_STRING(XtDisplay(w)) ||
            *type == XA_STRING ||
            *type == XA_COMPOUND_TEXT(XtDisplay(w))) {
            Status rc;
	    GettingSelection(dpy, *type, line, *length);
            if(*type == XA_STRING && screen->brokenSelections) {
		rc = XTextPropertyToStringList(&text_prop,
					       &text_list, &text_list_count);
            } else {
                rc = XmbTextPropertyToTextList(dpy, &text_prop,
                                               &text_list,
                                               &text_list_count);
            }
            if (rc < 0) {
		TRACE(("Conversion failed\n"));
		text_list = NULL;
	    }
	}
    }

    if(text_list != NULL && text_list_count != 0) {
	int i;
	for(i = 0; i < text_list_count; i++) {
	    int len = strlen(text_list[i]);
            _WriteSelectionData(((XtermWidget)w)->screen.respond,
                                (Char*)text_list[i], len);
	}
	XFreeStringList(text_list);
    } else
	goto fail;

    XtFree((char *)client_data);
    XtFree((char *)value);

    return;

  fail:
    if (client_data != 0) {
	struct _SelectionList* list = (struct _SelectionList*)client_data;
	_GetSelection(w, list->time,
		      list->params, list->count, list->targets);
	XtFree((char *)client_data);
    }
    return;
}


void
HandleInsertSelection(
	Widget w,
	XEvent *event,			/* assumed to be XButtonEvent* */
	String *params,			/* selections in precedence order */
	Cardinal *num_params)
{
    if (SendMousePosition(w, event)) return;
    _GetSelection(w, event->xbutton.time, params, *num_params, NULL);
}

static SelectUnit
EvalSelectUnit(Time buttonDownTime, SelectUnit defaultUnit)
{
    int delta;

    if (lastButtonUpTime == (Time) 0) /* first time and once in a blue moon */
	delta = term->screen.multiClickTime + 1;
    else if (buttonDownTime > lastButtonUpTime) /* most of the time */
	delta = buttonDownTime - lastButtonUpTime;
    else /* time has rolled over since lastButtonUpTime */
	delta = (((Time) ~0) - lastButtonUpTime) + buttonDownTime;

    if (delta > term->screen.multiClickTime) {
	numberOfClicks = 1;
	return defaultUnit;
    } else {
	++numberOfClicks;
	return ((selectUnit + 1) % NSELECTUNITS);
    }
}

static void do_select_start (
	Widget w,
	XEvent *event,			/* must be XButtonEvent* */
	int startrow,
	int startcol)
{
	if (SendMousePosition(w, event)) return;
	selectUnit = EvalSelectUnit(event->xbutton.time, SELECTCHAR);
	replyToEmacs = FALSE;
	StartSelect(startrow, startcol);
}

/* ARGSUSED */
void
HandleSelectStart(
	Widget w,
	XEvent *event,			/* must be XButtonEvent* */
	String *params GCC_UNUSED,
	Cardinal *num_params GCC_UNUSED)
{
	register TScreen *screen;
	int startrow, startcol;

	if (!IsXtermWidget(w))
		return;

	screen = &((XtermWidget)w)->screen;
	firstValidRow = 0;
	lastValidRow  = screen->max_row;
	PointToRowCol(event->xbutton.y, event->xbutton.x, &startrow, &startcol);
	do_select_start (w, event, startrow, startcol);
}


/* ARGSUSED */
void
HandleKeyboardSelectStart(
	Widget w,
	XEvent *event,			/* must be XButtonEvent* */
	String *params GCC_UNUSED,
	Cardinal *num_params GCC_UNUSED)
{
	register TScreen *screen;

	if (!IsXtermWidget(w))
		return;

	screen = &((XtermWidget)w)->screen;
	do_select_start (w, event, screen->cursor_row, screen->cursor_col);
}


static void
TrackDown(register XButtonEvent *event)
{
	int startrow, startcol;

	selectUnit = EvalSelectUnit(event->time, SELECTCHAR);
	if (numberOfClicks > 1 ) {
		PointToRowCol(event->y, event->x, &startrow, &startcol);
		replyToEmacs = TRUE;
		StartSelect(startrow, startcol);
	} else {
		waitingForTrackInfo = 1;
		EditorButton((XButtonEvent *)event);
	}
}


#define boundsCheck(x)	if (x < 0) \
			    x = 0; \
			else if (x >= screen->max_row) \
			    x = screen->max_row;

void
TrackMouse(int func, int startrow, int startcol, int firstrow, int lastrow)
{
	TScreen *screen = &term->screen;

	if (!waitingForTrackInfo) {	/* Timed out, so ignore */
		return;
	}
	waitingForTrackInfo = 0;
	if (func == 0) return;
	boundsCheck (startrow)
	boundsCheck (firstrow)
	boundsCheck (lastrow)
	firstValidRow = firstrow;
	lastValidRow  = lastrow;
	replyToEmacs = TRUE;
	StartSelect(startrow, startcol);
}

static void
StartSelect(int startrow, int startcol)
{
	TScreen *screen = &term->screen;

	TRACE(("StartSelect row=%d, col=%d\n", startrow, startcol));
	if (screen->cursor_state)
	    HideCursor ();
	if (numberOfClicks == 1) {
		/* set start of selection */
		rawRow = startrow;
		rawCol = startcol;

	} /* else use old values in rawRow, Col */

	saveStartRRow = startERow = rawRow;
	saveStartRCol = startECol = rawCol;
	saveEndRRow   = endERow   = rawRow;
	saveEndRCol   = endECol   = rawCol;
	if (Coordinate(startrow, startcol) < Coordinate(rawRow, rawCol)) {
		eventMode = LEFTEXTENSION;
		startERow = startrow;
		startECol = startcol;
	} else {
		eventMode = RIGHTEXTENSION;
		endERow = startrow;
		endECol = startcol;
	}
	ComputeSelect(startERow, startECol, endERow, endECol, False);

}

static void
EndExtend(
	Widget w,
	XEvent *event,			/* must be XButtonEvent */
	String *params,			/* selections */
	Cardinal num_params,
	Bool use_cursor_loc)
{
	int	row, col, count;
	TScreen *screen = &term->screen;
	Char line[9];

	if (use_cursor_loc) {
	    row = screen->cursor_row;
	    col = screen->cursor_col;
	} else {
	    PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
	}
	ExtendExtend (row, col);
	lastButtonUpTime = event->xbutton.time;
	if (startSRow != endSRow || startSCol != endSCol) {
		if (replyToEmacs) {
			count = 0;
			if (screen->control_eight_bits) {
				line[count++] = CSI;
			} else {
				line[count++] = ESC;
				line[count++] = '[';
			}
			if (rawRow == startSRow && rawCol == startSCol
			    && row == endSRow && col == endSCol) {
				/* Use short-form emacs select */
				line[count++] = 't';
				line[count++] = ' ' + endSCol + 1;
				line[count++] = ' ' + endSRow + 1;
			} else {
				/* long-form, specify everything */
				line[count++] = 'T';
				line[count++] = ' ' + startSCol + 1;
				line[count++] = ' ' + startSRow + 1;
				line[count++] = ' ' + endSCol + 1;
				line[count++] = ' ' + endSRow + 1;
				line[count++] = ' ' + col + 1;
				line[count++] = ' ' + row + 1;
			}
			v_write(screen->respond, line, count);
			TrackText(0, 0, 0, 0);
		}
	}
	SelectSet(w, event, params, num_params);
	eventMode = NORMAL;
}

void
HandleSelectSet(
	Widget w,
	XEvent *event,
	String *params,
	Cardinal *num_params)
{
	SelectSet (w, event, params, *num_params);
}

/* ARGSUSED */
static void
SelectSet (
	Widget	w GCC_UNUSED,
	XEvent	*event GCC_UNUSED,
	String	*params,
	Cardinal    num_params)
{
	/* Only do select stuff if non-null select */
	if (startSRow != endSRow || startSCol != endSCol) {
		SaltTextAway(startSRow, startSCol, endSRow, endSCol,
			     params, num_params);
	} else
		DisownSelection(term);
}

#define Abs(x)		((x) < 0 ? -(x) : (x))

/* ARGSUSED */
static void do_start_extend (
	Widget w,
	XEvent *event,			/* must be XButtonEvent* */
	String *params GCC_UNUSED,
	Cardinal *num_params GCC_UNUSED,
	Bool use_cursor_loc)
{
	TScreen *screen;
	int row, col, coord;

	if (!IsXtermWidget(w))
		return;

	screen = &((XtermWidget)w)->screen;
	if (SendMousePosition(w, event)) return;
	firstValidRow = 0;
	lastValidRow  = screen->max_row;
	selectUnit = EvalSelectUnit(event->xbutton.time, selectUnit);
	replyToEmacs = FALSE;

	if (numberOfClicks == 1) {
		/* Save existing selection so we can reestablish it if the guy
		   extends past the other end of the selection */
		saveStartRRow = startERow = startRRow;
		saveStartRCol = startECol = startRCol;
		saveEndRRow   = endERow   = endRRow;
		saveEndRCol   = endECol   = endRCol;
	} else {
		/* He just needed the selection mode changed, use old values. */
		startERow = startRRow = saveStartRRow;
		startECol = startRCol = saveStartRCol;
		endERow   = endRRow   = saveEndRRow;
		endECol   = endRCol   = saveEndRCol;

	}
	if (use_cursor_loc) {
	    row = screen->cursor_row;
	    col = screen->cursor_col;
	} else {
	    PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
	}
	coord = Coordinate(row, col);

	if (Abs(coord - Coordinate(startSRow, startSCol))
	     < Abs(coord - Coordinate(endSRow, endSCol))
	    || coord < Coordinate(startSRow, startSCol)) {
		/* point is close to left side of selection */
		eventMode = LEFTEXTENSION;
		startERow = row;
		startECol = col;
	} else {
		/* point is close to left side of selection */
		eventMode = RIGHTEXTENSION;
		endERow = row;
		endECol = col;
	}
	ComputeSelect(startERow, startECol, endERow, endECol, True);
}

static void
ExtendExtend (int row, int col)
{
	int coord = Coordinate(row, col);

	TRACE(("ExtendExtend row=%d, col=%d\n", row, col));
	if (eventMode == LEFTEXTENSION
	 && (coord + (selectUnit!=SELECTCHAR)) > Coordinate(endSRow, endSCol)) {
		/* Whoops, he's changed his mind.  Do RIGHTEXTENSION */
		eventMode = RIGHTEXTENSION;
		startERow = saveStartRRow;
		startECol = saveStartRCol;
	} else if (eventMode == RIGHTEXTENSION
	 && coord < Coordinate(startSRow, startSCol)) {
		/* Whoops, he's changed his mind.  Do LEFTEXTENSION */
		eventMode = LEFTEXTENSION;
		endERow   = saveEndRRow;
		endECol   = saveEndRCol;
	}
	if (eventMode == LEFTEXTENSION) {
		startERow = row;
		startECol = col;
	} else {
		endERow = row;
		endECol = col;
	}
	ComputeSelect(startERow, startECol, endERow, endECol, False);
}


void HandleStartExtend(
	Widget w,
	XEvent *event,			/* must be XButtonEvent* */
	String *params,			/* unused */
	Cardinal *num_params)		/* unused */
{
    do_start_extend (w, event, params, num_params, False);
}

void HandleKeyboardStartExtend(
	Widget w,
	XEvent *event,			/* must be XButtonEvent* */
	String *params,			/* unused */
	Cardinal *num_params)		/* unused */
{
    do_start_extend (w, event, params, num_params, True);
}

void
ScrollSelection(register TScreen* screen, register int amount)
{
    register int minrow = -screen->savedlines - screen->topline;
    register int maxrow = screen->max_row - screen->topline;
    register int maxcol = screen->max_col;

#define scroll_update_one(row, col) \
	row += amount; \
	if (row < minrow) { \
	    row = minrow; \
	    col = 0; \
	} \
	if (row > maxrow) { \
	    row = maxrow; \
	    col = maxcol; \
	}

    scroll_update_one(startRRow, startRCol);
    scroll_update_one(endRRow,   endRCol);
    scroll_update_one(startSRow, startSCol);
    scroll_update_one(endSRow,   endSCol);

    scroll_update_one(rawRow, rawCol);

    scroll_update_one(screen->startHRow, screen->startHCol);
    scroll_update_one(screen->endHRow,   screen->endHCol);

    screen->startHCoord = Coordinate (screen->startHRow, screen->startHCol);
    screen->endHCoord   = Coordinate (screen->endHRow,   screen->endHCol);
}


/*ARGSUSED*/
void
ResizeSelection (TScreen *screen GCC_UNUSED, int rows, int cols)
{
    rows--;				/* decr to get 0-max */
    cols--;

    if (startRRow > rows) startRRow = rows;
    if (startSRow > rows) startSRow = rows;
    if (endRRow > rows) endRRow = rows;
    if (endSRow > rows) endSRow = rows;
    if (rawRow > rows) rawRow = rows;

    if (startRCol > cols) startRCol = cols;
    if (startSCol > cols) startSCol = cols;
    if (endRCol > cols) endRCol = cols;
    if (endSCol > cols) endSCol = cols;
    if (rawCol > cols) rawCol = cols;
}

#if OPT_WIDE_CHARS
int iswide(int i)
{
    return (i == HIDDEN_CHAR) || (my_wcwidth(i) == 2);
}
#endif

static void
PointToRowCol(
    register int y,
    register int x,
    int *r,
    int *c)
/* Convert pixel coordinates to character coordinates.
   Rows are clipped between firstValidRow and lastValidRow.
   Columns are clipped between to be 0 or greater, but are not clipped to some
       maximum value. */
{
	register TScreen *screen = &term->screen;
	register int row, col;

	row = (y - screen->border) / FontHeight(screen);
	if(row < firstValidRow)
		row = firstValidRow;
	else if(row > lastValidRow)
		row = lastValidRow;
	col = (x - OriginX(screen)) / FontWidth(screen);
	if(col < 0)
		col = 0;
	else if(col > screen->max_col+1) {
		col = screen->max_col+1;
	}
#if OPT_WIDE_CHARS
	/*
	 * If we got a click on the right half of a doublewidth character,
	 * pretend it happened on the left half.
	 */
	if (col > 0
	 && iswide(XTERM_CELL(row, col-1))
	 && (XTERM_CELL(row, col) == HIDDEN_CHAR)) {
		col -= 1;
	}
#endif
	*r = row;
	*c = col;
}

static int
LastTextCol(register int row)
{
	register TScreen *screen =  &term->screen;
	register int i;
	register Char *ch;

	if ((row += screen->topline) + screen->savedlines >= 0) {
		for ( i = screen->max_col,
			ch = SCRN_BUF_ATTRS(screen, row) + i ;
		      i >= 0 && !(*ch & CHARDRAWN) ;
		      ch--, i--)
		    ;
#if OPT_DEC_CHRSET
		if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, row)[0])) {
			i *= 2;
		}
#endif
	} else {
		i = -1;
	}
	return(i);
}

#if !OPT_WIDE_CHARS
/*
** double click table for cut and paste in 8 bits
**
** This table is divided in four parts :
**
**	- control characters	[0,0x1f] U [0x80,0x9f]
**	- separators		[0x20,0x3f] U [0xa0,0xb9]
**	- binding characters	[0x40,0x7f] U [0xc0,0xff]
**	- exceptions
*/
static int charClass[256] = {
/* NUL  SOH  STX  ETX  EOT  ENQ  ACK  BEL */
    32,   1,   1,   1,   1,   1,   1,   1,
/*  BS   HT   NL   VT   NP   CR   SO   SI */
     1,  32,   1,   1,   1,   1,   1,   1,
/* DLE  DC1  DC2  DC3  DC4  NAK  SYN  ETB */
     1,   1,   1,   1,   1,   1,   1,   1,
/* CAN   EM  SUB  ESC   FS   GS   RS   US */
     1,   1,   1,   1,   1,   1,   1,   1,
/*  SP    !    "    #    $    %    &    ' */
    32,  33,  34,  35,  36,  37,  38,  39,
/*   (    )    *    +    ,    -    .    / */
    40,  41,  42,  43,  44,  45,  46,  47,
/*   0    1    2    3    4    5    6    7 */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   8    9    :    ;    <    =    >    ? */
    48,  48,  58,  59,  60,  61,  62,  63,
/*   @@    A    B    C    D    E    F    G */
    64,  48,  48,  48,  48,  48,  48,  48,
/*   H    I    J    K    L    M    N    O */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   P    Q    R    S    T    U    V    W */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   X    Y    Z    [    \    ]    ^    _ */
    48,  48,  48,  91,  92,  93,  94,  48,
/*   `    a    b    c    d    e    f    g */
    96,  48,  48,  48,  48,  48,  48,  48,
/*   h    i    j    k    l    m    n    o */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   p    q    r    s    t    u    v    w */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   x    y    z    {    |    }    ~  DEL */
    48,  48,  48, 123, 124, 125, 126,   1,
/* x80  x81  x82  x83  IND  NEL  SSA  ESA */
     1,   1,   1,   1,   1,   1,   1,   1,
/* HTS  HTJ  VTS  PLD  PLU   RI  SS2  SS3 */
     1,   1,   1,   1,   1,   1,   1,   1,
/* DCS  PU1  PU2  STS  CCH   MW  SPA  EPA */
     1,   1,   1,   1,   1,   1,   1,   1,
/* x98  x99  x9A  CSI   ST  OSC   PM  APC */
     1,   1,   1,   1,   1,   1,   1,   1,
/*   -    i   c/    L   ox   Y-    |   So */
   160, 161, 162, 163, 164, 165, 166, 167,
/*  ..   c0   ip   <<    _        R0    - */
   168, 169, 170, 171, 172, 173, 174, 175,
/*   o   +-    2    3    '    u   q|    . */
   176, 177, 178, 179, 180, 181, 182, 183,
/*   ,    1    2   >>  1/4  1/2  3/4    ? */
   184, 185, 186, 187, 188, 189, 190, 191,
/*  A`   A'   A^   A~   A:   Ao   AE   C, */
    48,  48,  48,  48,  48,  48,  48,  48,
/*  E`   E'   E^   E:   I`   I'   I^   I: */
    48,  48,  48,  48,  48,  48,  48,  48,
/*  D-   N~   O`   O'   O^   O~   O:    X */
    48,  48,  48,  48,  48,  48,  48, 215,
/*  O/   U`   U'   U^   U:   Y'    P    B */
    48,  48,  48,  48,  48,  48,  48,  48,
/*  a`   a'   a^   a~   a:   ao   ae   c, */
    48,  48,  48,  48,  48,  48,  48,  48,
/*  e`   e'   e^   e:    i`  i'   i^   i: */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   d   n~   o`   o'   o^   o~   o:   -: */
    48,  48,  48,  48,  48,  48,  48, 247,
/*  o/   u`   u'   u^   u:   y'    P   y: */
    48,  48,  48,  48,  48,  48,  48,  48};

int SetCharacterClassRange (
    register int low,			/* in range of [0..255] */
    register int high,
    register int value)			/* arbitrary */
{

    if (low < 0 || high > 255 || high < low) return (-1);

    for (; low <= high; low++) charClass[low] = value;

    return (0);
}
#endif

#if OPT_WIDE_CHARS
static int class_of(TScreen *screen, int row, int col)
{
    unsigned value;
#if OPT_DEC_CHRSET
    if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, row + screen->topline)[0])) {
	col /= 2;
    }
#endif
    value = XTERM_CELL(row, col);
    if_OPT_WIDE_CHARS(screen, {
	return CharacterClass(value);
    })
    return CharacterClass(value);
}
#define ClassSelects(screen, row, col, cclass) \
	 (class_of(screen, row, col) == cclass \
	 || XTERM_CELL(row, col) == HIDDEN_CHAR)
#else
#define class_of(screen,row,col) charClass[XTERM_CELL(row, col)]
#define ClassSelects(screen, row, col, cclass) \
	 (class_of(screen,row, col) == cclass)
#endif

/*
 * sets startSRow startSCol endSRow endSCol
 * ensuring that they have legal values
 */

static void
ComputeSelect(
	int startRow,
	int startCol,
	int endRow,
	int endCol,
	Bool extend)
{
	register TScreen *screen = &term->screen;
	register int length;
	register int cclass;

#if OPT_WIDE_CHARS
	if (startCol > 1
	 && iswide(XTERM_CELL(startRow, startCol-1))
	 && XTERM_CELL(startRow, startCol-0) == HIDDEN_CHAR) {
		fprintf(stderr, "Adjusting start. Changing downwards from %i.\n", startCol);
		startCol -= 1;
		if (endCol == (startCol+1)) endCol--;
	}

	if (iswide(XTERM_CELL(endRow, endCol-1))
	 && XTERM_CELL(endRow, endCol) == HIDDEN_CHAR) {
		endCol += 1;
	}
#endif

	if (Coordinate(startRow, startCol) <= Coordinate(endRow, endCol)) {
		startSRow = startRRow = startRow;
		startSCol = startRCol = startCol;
		endSRow   = endRRow   = endRow;
		endSCol   = endRCol   = endCol;
	} else {	/* Swap them */
		startSRow = startRRow = endRow;
		startSCol = startRCol = endCol;
		endSRow   = endRRow   = startRow;
		endSCol   = endRCol   = startCol;
	}

	switch (selectUnit) {
		case SELECTCHAR :
			if (startSCol > (LastTextCol(startSRow) + 1)) {
				startSCol = 0;
				startSRow++;
			}
			if (endSCol > (LastTextCol(endSRow) + 1)) {
				endSCol = 0;
				endSRow++;
			}
			break;
		case SELECTWORD :
			if (startSCol > (LastTextCol(startSRow) + 1)) {
				startSCol = 0;
				startSRow++;
			} else {
				cclass = class_of(screen,startSRow,startSCol);
				do {
				    --startSCol;
				    if (startSCol < 0
				     && ScrnTstWrapped(screen, startSRow - 1)) {
					--startSRow;
					startSCol = LastTextCol(startSRow);
				    }
				} while (startSCol >= 0
				 && ClassSelects(screen, startSRow, startSCol, cclass));
				++startSCol;
			}

#if OPT_WIDE_CHARS
			if (startSCol && XTERM_CELL(startSRow, startSCol) == HIDDEN_CHAR)
				startSCol++;
#endif

			if (endSCol > (LastTextCol(endSRow) + 1)) {
				endSCol = 0;
				endSRow++;
			} else {
				length = LastTextCol(endSRow);
				cclass = class_of(screen,endSRow,endSCol);
				do {
				    ++endSCol;
				    if (endSCol > length
				     && ScrnTstWrapped(screen, endSRow)) {
					endSCol = 0;
					++endSRow;
					length = LastTextCol(endSRow);
				    }
				} while (endSCol <= length
				 && ClassSelects(screen,endSRow,endSCol, cclass));
				/* Word select selects if pointing to any char
				   in "word", especially in that it includes
				   the last character in a word.  So no --endSCol
				   and do special eol handling */
				if (endSCol > length+1) {
					endSCol = 0;
					++endSRow;
				}
			}

#if OPT_WIDE_CHARS
			if (endSCol && XTERM_CELL(endSRow, endSCol) == HIDDEN_CHAR)
				endSCol++;
#endif

			saveStartWRow = startSRow;
			saveStartWCol = startSCol;
			break;
		case SELECTLINE :
			while (ScrnTstWrapped(screen, endSRow)) {
				++endSRow;
			}
			if (term->screen.cutToBeginningOfLine
			    || startSRow < saveStartWRow) {
			    startSCol = 0;
			    while (ScrnTstWrapped(screen, startSRow - 1)) {
				--startSRow;
			    }
			} else if (!extend) {
			    if ((startRow < saveStartWRow)
				|| (startRow == saveStartWRow
				    && startCol < saveStartWCol)) {
				startSCol = 0;
				while (ScrnTstWrapped(screen, startSRow - 1)) {
				    --startSRow;
				}
			    } else {
				startSRow = saveStartWRow;
				startSCol = saveStartWCol;
			    }
			}
			if (term->screen.cutNewline) {
			    endSCol = 0;
			    ++endSRow;
			} else {
			    endSCol = LastTextCol(endSRow) + 1;
			}
			break;
	}

	TrackText(startSRow, startSCol, endSRow, endSCol);
	return;
}

void
TrackText(
	register int frow,
	register int fcol,
	register int trow,
	register int tcol)
    /* Guaranteed (frow, fcol) <= (trow, tcol) */
{
	register int from, to;
	register TScreen *screen = &term->screen;
	int old_startrow, old_startcol, old_endrow, old_endcol;

	old_startrow = screen->startHRow;
	old_startcol = screen->startHCol;
	old_endrow = screen->endHRow;
	old_endcol = screen->endHCol;
	if (frow == old_startrow && fcol == old_startcol &&
	    trow == old_endrow   && tcol == old_endcol) return;
	screen->startHRow = frow;
	screen->startHCol = fcol;
	screen->endHRow   = trow;
	screen->endHCol   = tcol;
	from = Coordinate(frow, fcol);
	to = Coordinate(trow, tcol);
	if (to <= screen->startHCoord || from > screen->endHCoord) {
	    /* No overlap whatsoever between old and new hilite */
	    ReHiliteText(old_startrow, old_startcol, old_endrow, old_endcol);
	    ReHiliteText(frow, fcol, trow, tcol);
	} else {
	    if (from < screen->startHCoord) {
		    /* Extend left end */
		    ReHiliteText(frow, fcol, old_startrow, old_startcol);
	    } else if (from > screen->startHCoord) {
		    /* Shorten left end */
		    ReHiliteText(old_startrow, old_startcol, frow, fcol);
	    }
	    if (to > screen->endHCoord) {
		    /* Extend right end */
		    ReHiliteText(old_endrow, old_endcol, trow, tcol);
	    } else if (to < screen->endHCoord) {
		    /* Shorten right end */
		    ReHiliteText(trow, tcol, old_endrow, old_endcol);
	    }
	}
	screen->startHCoord = from;
	screen->endHCoord = to;
}

static void
ReHiliteText(
    register int frow,
    register int fcol,
    register int trow,
    register int tcol)
    /* Guaranteed that (frow, fcol) <= (trow, tcol) */
{
	register TScreen *screen = &term->screen;
	register int i;

	if (frow < 0)
	    frow = fcol = 0;
	else if (frow > screen->max_row)
	    return;		/* nothing to do, since trow >= frow */

	if (trow < 0)
	    return;		/* nothing to do, since frow <= trow */
	else if (trow > screen->max_row) {
	    trow = screen->max_row;
	    tcol = screen->max_col+1;
	}
	if (frow == trow && fcol == tcol)
		return;

	if(frow != trow) {	/* do multiple rows */
		if((i = screen->max_col - fcol + 1) > 0) {	/* first row */
		    ScrnRefresh(screen, frow, fcol, 1, i, True);
		}
		if((i = trow - frow - 1) > 0) {			/* middle rows*/
		    ScrnRefresh(screen, frow+1, 0,i, screen->max_col+1, True);
		}
		if(tcol > 0 && trow <= screen->max_row) {	/* last row */
		    ScrnRefresh(screen, trow, 0, 1, tcol, True);
		}
	} else {		/* do single row */
		ScrnRefresh(screen, frow, fcol, 1, tcol - fcol, True);
	}
}

static void
SaltTextAway(
    int crow, int ccol, int row, int col,
    String *params,			/* selections */
    Cardinal num_params)
    /* Guaranteed that (crow, ccol) <= (row, col), and that both points are valid
       (may have row = screen->max_row+1, col = 0) */
{
    register TScreen *screen = &term->screen;
    register int i, j = 0;
    int eol;
    char *line;
    Char *lp;

    if (crow == row && ccol > col) {
	int tmp = ccol;
	ccol = col;
	col = tmp;
    }

    --col;
    /* first we need to know how long the string is before we can save it*/

    if ( row == crow ) {
	j = Length(screen, crow, ccol, col);
    } else { /* two cases, cut is on same line, cut spans multiple lines */
	j += Length(screen, crow, ccol, screen->max_col) + 1;
	for (i = crow + 1; i < row; i++)
	    j += Length(screen, i, 0, screen->max_col) + 1;
	if (col >= 0)
	    j += Length(screen, row, 0, col);
    }

    /* UTF-8 may require more space */
    if_OPT_WIDE_CHARS(screen,{j *= 4;})

    /* now get some memory to save it in */

    if (screen->selection_size <= j) {
	if((line = (char *)malloc((unsigned) j + 1)) == 0)
	    SysError(ERROR_BMALLOC2);
	XtFree(screen->selection_data);
	screen->selection_data = line;
	screen->selection_size = j + 1;
    } else {
	line = screen->selection_data;
    }

    if ((line == 0)
     || (j < 0))
	return;

    line[j] = '\0';		/* make sure it is null terminated */
    lp = (Char *)line;		/* lp points to where to save the text */
    if ( row == crow ) {
	lp = SaveText(screen, row, ccol, col, lp, &eol);
    } else {
	lp = SaveText(screen, crow, ccol, screen->max_col, lp, &eol);
	if (eol)
	    *lp ++ = '\n';	/* put in newline at end of line */
	for(i = crow +1; i < row; i++) {
	    lp = SaveText(screen, i, 0, screen->max_col, lp, &eol);
	    if (eol)
		*lp ++ = '\n';
	}
	if (col >= 0)
	    lp = SaveText(screen, row, 0, col, lp, &eol);
    }
    *lp = '\0';			/* make sure we have end marked */

    TRACE(("Salted TEXT:%.*s\n", (char *)lp - line, line));
    screen->selection_length = ((char *)lp - line);
    _OwnSelection(term, params, num_params);
}

static Boolean
_ConvertSelectionHelper(Widget w,
			Atom *type, XtPointer *value,
			unsigned long *length, int *format,
			int (*conversion_function)(Display*,
						   char**, int,
						   XICCEncodingStyle,
						   XTextProperty*),
			XICCEncodingStyle conversion_style)
{
    Display* d = XtDisplay(w);
    TScreen *screen;
    XTextProperty textprop;

    if (!IsXtermWidget(w))
	return False;

    screen = &((XtermWidget)w)->screen;

    if (conversion_function(d, &screen->selection_data, 1,
			    conversion_style,
			    &textprop) < Success)
	return False;
    *value = (XtPointer) textprop.value;
    *length = textprop.nitems;
    *type = textprop.encoding;
    *format = textprop.format;
    return True;
}


static Boolean
ConvertSelection(
	Widget w,
	Atom *selection,
	Atom *target,
	Atom *type,
	XtPointer *value,
	unsigned long *length,
	int *format)
{
    Display* d = XtDisplay(w);
    TScreen *screen;

    if (!IsXtermWidget(w))
	return False;

    screen = &((XtermWidget)w)->screen;

    if (screen->selection_data == NULL)
	return False;		/* can this happen? */

    if (*target == XA_TARGETS(d)) {
	Atom* targetP;
	Atom* std_targets;
	unsigned long std_length;
	XmuConvertStandardSelection(w, screen->selection_time, selection,
				    target, type, (XPointer *)&std_targets,
				    &std_length, format);
	*length = std_length + 6;
	targetP = (Atom*)XtMalloc(sizeof(Atom)*(*length));
	*value = (XtPointer) targetP;
	*targetP++ = XA_STRING;
	*targetP++ = XA_TEXT(d);
#ifdef X_HAVE_UTF8_STRING
	*targetP++ = XA_COMPOUND_TEXT(d);
	*targetP++ = XA_UTF8_STRING(d);
#else
	*targetP = XA_COMPOUND_TEXT(d);
	if_OPT_WIDE_CHARS(screen, {
	    *targetP = XA_UTF8_STRING(d);
	})
	targetP++;
#endif
	*targetP++ = XA_LENGTH(d);
	*targetP++ = XA_LIST_LENGTH(d);
	memcpy ( (char*)targetP, (char*)std_targets, sizeof(Atom)*std_length);
	XtFree((char*)std_targets);
	*type = XA_ATOM;
	*format = 32;
	return True;
    }


#if OPT_WIDE_CHARS
    if (screen->wide_chars && *target == XA_STRING) {
	return
	    _ConvertSelectionHelper(w,
				    type, value, length, format,
				    Xutf8TextListToTextProperty,
				    XStringStyle);
    }
    if (screen->wide_chars && *target == XA_UTF8_STRING(d)) {
        return
            _ConvertSelectionHelper(w,
				    type, value, length, format,
				    Xutf8TextListToTextProperty,
				    XUTF8StringStyle);
    }
    if (screen->wide_chars && *target == XA_TEXT(d)) {
	return
	    _ConvertSelectionHelper(w,
				    type, value, length, format,
				    Xutf8TextListToTextProperty,
				    XStdICCTextStyle);
    }
    if (screen->wide_chars && *target == XA_COMPOUND_TEXT(d)) {
	return
	    _ConvertSelectionHelper(w,
				    type, value, length, format,
				    Xutf8TextListToTextProperty,
				    XCompoundTextStyle);
    }
#endif

    if (*target == XA_STRING) { /* not wide_chars */
	/* We can only reach this point if the selection requestor
	   requested STRING before any of TEXT, COMPOUND_TEXT or
	   UTF8_STRING.	 We therefore assume that the requestor is not
	   properly internationalised, and dump raw eight-bit data
	   with no conversion into the selection.  Yes, this breaks
	   the ICCCM in non-Latin-1 locales. */
	*type = XA_STRING;
	*value = screen->selection_data;
	*length = screen->selection_length;
	*format = 8;
	return True;
    }

    if (*target == XA_TEXT(d)) { /* not wide_chars */
	return
	    _ConvertSelectionHelper(w,
				    type, value, length, format,
				    XmbTextListToTextProperty,
				    XStdICCTextStyle);
    }

    if (*target == XA_COMPOUND_TEXT(d)) { /* not wide_chars */
	return
	    _ConvertSelectionHelper(w,
				    type, value, length, format,
				    XmbTextListToTextProperty,
				    XCompoundTextStyle);
    }

#ifdef X_HAVE_UTF8_STRING
    if (*target == XA_UTF8_STRING(d)) { /* not wide_chars */
	return
	    _ConvertSelectionHelper(w,
				    type, value, length, format,
				    XmbTextListToTextProperty,
				    XUTF8StringStyle);
    }
#endif

    if (*target == XA_LIST_LENGTH(d)) {
	*value = XtMalloc(4);
	if (sizeof(long) == 4)
	    *(long*)*value = 1;
	else {
	    long temp = 1;
	    memcpy ( (char*)*value, ((char*)&temp)+sizeof(long)-4, 4);
	}
	*type = XA_INTEGER;
	*length = 1;
	*format = 32;
	return True;
    }

    if (*target == XA_LENGTH(d)) {
	/* This value is wrong if we have UTF-8 text */
	*value = XtMalloc(4);
	if (sizeof(long) == 4)
	    *(long*)*value = screen->selection_length;
	else {
	    long temp = screen->selection_length;
	    memcpy ( (char*)*value, ((char*)&temp)+sizeof(long)-4, 4);
	}
	*type = XA_INTEGER;
	*length = 1;
	*format = 32;
	return True;
    }

    if (XmuConvertStandardSelection(w, screen->selection_time, selection,
				    target, type, (XPointer *)value,
				    length, format))
	return True;

    /* else */
    return False;
}


static void
LoseSelection(Widget w, Atom *selection)
{
    register TScreen* screen;
    register Atom* atomP;
    Cardinal i;

    if (!IsXtermWidget(w))
	return;

    screen = &((XtermWidget)w)->screen;
    for (i = 0, atomP = screen->selection_atoms;
	 i < screen->selection_count; i++, atomP++)
    {
	if (*selection == *atomP) *atomP = (Atom)0;
	switch (*atomP) {
	  case XA_CUT_BUFFER0:
	  case XA_CUT_BUFFER1:
	  case XA_CUT_BUFFER2:
	  case XA_CUT_BUFFER3:
	  case XA_CUT_BUFFER4:
	  case XA_CUT_BUFFER5:
	  case XA_CUT_BUFFER6:
	  case XA_CUT_BUFFER7:	*atomP = (Atom)0;
	}
    }

    for (i = screen->selection_count; i; i--) {
	if (screen->selection_atoms[i-1] != 0) break;
    }
    screen->selection_count = i;

    for (i = 0, atomP = screen->selection_atoms;
	 i < screen->selection_count; i++, atomP++)
    {
	if (*atomP == (Atom)0) {
	    *atomP = screen->selection_atoms[--screen->selection_count];
	}
    }

    if (screen->selection_count == 0)
	TrackText(0, 0, 0, 0);
}


/* ARGSUSED */
static void SelectionDone(
	Widget w GCC_UNUSED,
	Atom *selection GCC_UNUSED,
	Atom *target GCC_UNUSED)
{
    /* empty proc so Intrinsics know we want to keep storage */
}


static void
_OwnSelection(
	register XtermWidget termw,
	String *selections,
	Cardinal count)
{
    Atom* atoms = termw->screen.selection_atoms;
    Cardinal i;
    Boolean have_selection = False;

    if (termw->screen.selection_length < 0) return;

    if (count > termw->screen.sel_atoms_size) {
	XtFree((char*)atoms);
	atoms = (Atom*)XtMalloc(count*sizeof(Atom));
	termw->screen.selection_atoms = atoms;
	termw->screen.sel_atoms_size = count;
    }
    XmuInternStrings( XtDisplay((Widget)termw), selections, count, atoms );
    for (i = 0; i < count; i++) {
	int cutbuffer;
	switch (atoms[i]) {
	  case XA_CUT_BUFFER0: cutbuffer = 0; break;
	  case XA_CUT_BUFFER1: cutbuffer = 1; break;
	  case XA_CUT_BUFFER2: cutbuffer = 2; break;
	  case XA_CUT_BUFFER3: cutbuffer = 3; break;
	  case XA_CUT_BUFFER4: cutbuffer = 4; break;
	  case XA_CUT_BUFFER5: cutbuffer = 5; break;
	  case XA_CUT_BUFFER6: cutbuffer = 6; break;
	  case XA_CUT_BUFFER7: cutbuffer = 7; break;
	  default:	       cutbuffer = -1;
	}
	if (cutbuffer >= 0) {
	    if ( termw->screen.selection_length >
		 4*XMaxRequestSize(XtDisplay((Widget)termw))-32) {
		fprintf(stderr,
			"%s: selection too big (%d bytes), not storing in CUT_BUFFER%d\n",
			xterm_name, termw->screen.selection_length, cutbuffer);
	    } else {
		/* This used to just use the UTF-8 data, which was totally
		 * broken as not even the corresponding paste code in Xterm
		 * understood this!  So now it converts to Latin1 first.
		 *   Robert Brady, 2000-09-05
		 */
		unsigned long length = termw->screen.selection_length;
		Char *data = (Char *)termw->screen.selection_data;
		if_OPT_WIDE_CHARS((&(termw->screen)), {
		    data = UTF8toLatin1(data, length, &length);
		})
		XStoreBuffer( XtDisplay((Widget)termw),
			      (char *)data, length, cutbuffer );
	    }
	} else if (!replyToEmacs) {
	    have_selection |=
		XtOwnSelection( (Widget)termw, atoms[i],
			    termw->screen.selection_time,
			    ConvertSelection, LoseSelection, SelectionDone );
	}
    }
    if (!replyToEmacs)
	termw->screen.selection_count = count;
    if (!have_selection)
	TrackText(0, 0, 0, 0);
}

void
DisownSelection(register XtermWidget termw)
{
    Atom* atoms = termw->screen.selection_atoms;
    Cardinal count = termw->screen.selection_count;
    Cardinal i;

    for (i = 0; i < count; i++) {
	int cutbuffer;
	switch (atoms[i]) {
	  case XA_CUT_BUFFER0: cutbuffer = 0; break;
	  case XA_CUT_BUFFER1: cutbuffer = 1; break;
	  case XA_CUT_BUFFER2: cutbuffer = 2; break;
	  case XA_CUT_BUFFER3: cutbuffer = 3; break;
	  case XA_CUT_BUFFER4: cutbuffer = 4; break;
	  case XA_CUT_BUFFER5: cutbuffer = 5; break;
	  case XA_CUT_BUFFER6: cutbuffer = 6; break;
	  case XA_CUT_BUFFER7: cutbuffer = 7; break;
	  default:	       cutbuffer = -1;
	}
	if (cutbuffer < 0)
	    XtDisownSelection( (Widget)termw, atoms[i],
			       termw->screen.selection_time );
    }
    termw->screen.selection_count = 0;
    termw->screen.startHRow = termw->screen.startHCol = 0;
    termw->screen.endHRow = termw->screen.endHCol = 0;
}


/* returns number of chars in line from scol to ecol out */
/* ARGSUSED */
static int
Length(
    register TScreen *screen GCC_UNUSED,
    register int row,
    register int scol,
    register int ecol)
{
	register int lastcol = LastTextCol(row);

	if (ecol > lastcol)
	    ecol = lastcol;
	return (ecol - scol + 1);
}

/* copies text into line, preallocated */
static Char *
SaveText(
    TScreen *screen,
    int row,
    int scol,
    int ecol,
    register Char *lp,		/* pointer to where to put the text */
    int *eol)
{
    int i = 0;
    unsigned c;
    Char *result = lp;
#if OPT_WIDE_CHARS
    int previous = 0;
    unsigned c_1 = 0, c_2 = 0;
#endif

    i = Length(screen, row, scol, ecol);
    ecol = scol + i;
#if OPT_DEC_CHRSET
    if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, row + screen->topline)[0])) {
	scol = (scol + 0) / 2;
	ecol = (ecol + 1) / 2;
    }
#endif
    *eol = !ScrnTstWrapped(screen, row);
    for (i = scol; i < ecol; i++) {
	c = E2A(XTERM_CELL(row, i));
#if OPT_WIDE_CHARS
	if (screen->utf8_mode) {
	    c_1 = E2A(XTERM_CELL_C1(row, i));
	    c_2 = E2A(XTERM_CELL_C2(row, i));
	}

	/* We want to strip out every occurrence of HIDDEN_CHAR AFTER a
	 * wide character.
	 */
	if (c == HIDDEN_CHAR && iswide(previous)) {
	    previous = c;
	    /* Combining characters attached to double-width characters
	       are in memory attached to the HIDDEN_CHAR */
	    if (c_1) {
		lp = convertToUTF8(lp, c_1);
		if (c_2)
		    lp = convertToUTF8(lp, c_2);
	    }
	    continue;
	}
	previous = c;
	if (screen->utf8_mode) {
	    lp = convertToUTF8(lp, c);
	    if (c_1) {
		lp = convertToUTF8(lp, c_1);
		if (c_2)
		    lp = convertToUTF8(lp, c_2);
	    }
	}
	else
#endif
	{
	    if (c == 0) {
		c = E2A(' ');
	    } else if (c < E2A(' ')) {
		if (c == XPOUND)
		    c = 0x23;	/* char on screen is pound sterling */
		else
		    c += 0x5f;	/* char is from DEC drawing set */
	    } else if (c == 0x7f) {
		c = 0x5f;
	    }
	    *lp++ = A2E(c);
	}
	if (c != E2A(' '))
	    result = lp;
    }

    /*
     * If requested, trim trailing blanks from selected lines.  Do not do this
     * if the line is wrapped.
     */
    if (!*eol || !screen->trim_selection)
	result = lp;

    return(result);
}

static int
BtnCode(XButtonEvent *event, int button)
{
	int result = 32 + (KeyState(event->state) << 2);

	if (button < 0 || button > 5) {
		result += 3;
	} else {
		if (button > 3)
			result += (64 - 4);
		if (event->type == MotionNotify)
			result += 32;
		result += button;
	}
	return result;
}

#define MOUSE_LIMIT (255 - 32)

static void
EditorButton(register XButtonEvent *event)
{
	TScreen *screen = &term->screen;
	int pty = screen->respond;
	Char line[6];
	int row, col;
	int button, count = 0;

	/* If button event, get button # adjusted for DEC compatibility */
	button = event->button - 1;
	if (button >= 3) button++;

	/* Compute character position of mouse pointer */
	row = (event->y - screen->border) / FontHeight(screen);
	col = (event->x - OriginX(screen)) / FontWidth(screen);

	/* Limit to screen dimensions */
	if (row < 0)
		row = 0;
	else if (row > screen->max_row)
		row = screen->max_row;
	else if (row > MOUSE_LIMIT)
		row = MOUSE_LIMIT;

	if (col < 0)
		col = 0;
	else if (col > screen->max_col)
		col = screen->max_col;
	else if (col > MOUSE_LIMIT)
		col = MOUSE_LIMIT;

	/* Build key sequence starting with \E[M */
	if (screen->control_eight_bits) {
		line[count++] = CSI;
	} else {
		line[count++] = ESC;
		line[count++] = '[';
	}
	line[count++] = 'M';

	/* Add event code to key sequence */
	if (screen->send_mouse_pos == X10_MOUSE) {
		line[count++] = ' ' + button;
	}
	else
	{
	    /* Button-Motion events */
	    switch(event->type)
	    {
	    case ButtonPress:
		line[count++] = BtnCode(event, screen->mouse_button = button);
		break;
	    case ButtonRelease:
		/*
		 * Wheel mouse interface generates release-events for buttons
		 * 4 and 5, coded here as 3 and 4 respectively.  We change the
		 * release for buttons 1..3 to a -1.
		 */
		if (button < 3)
			button = -1;
		line[count++] = BtnCode(event, screen->mouse_button = button);
		break;
	    case MotionNotify:
		/* BTN_EVENT_MOUSE and ANY_EVENT_MOUSE modes send motion
		 * events only if character cell has changed.
		 */
		if ((row == screen->mouse_row)
		 && (col == screen->mouse_col))
			return;
		line[count++] = BtnCode(event, screen->mouse_button);
		break;
	    default:
		return;
	    }
	}

	screen->mouse_row = row;
	screen->mouse_col = col;

	/* Add pointer position to key sequence */
	line[count++] = ' ' + col + 1;
	line[count++] = ' ' + row + 1;

	TRACE(("mouse at %d,%d button+mask = %#x\n", row, col,
		(screen->control_eight_bits) ? line[2] : line[3]));

	/* Transmit key sequence to process running under xterm */
	v_write(pty, line, count);
}


/*ARGSUSED*/
#if OPT_TEK4014
void HandleGINInput (
    Widget w GCC_UNUSED,
    XEvent *event GCC_UNUSED,
    String *param_list,
    Cardinal *nparamsp)
{
    if (term->screen.TekGIN && *nparamsp == 1) {
	int c = param_list[0][0];
	switch (c) {
	  case 'l': case 'm': case 'r':
	  case 'L': case 'M': case 'R':
	    break;
	  default:
	    Bell (XkbBI_MinorError,0);	/* let them know they goofed */
	    c = 'l';				/* provide a default */
	}
	TekEnqMouse (c | 0x80);
	TekGINoff();
    } else {
	Bell (XkbBI_MinorError,0);
    }
}
#endif /* OPT_TEK4014 */


/* ARGSUSED */
void HandleSecure(
    Widget w GCC_UNUSED,
    XEvent *event,			/* unused */
    String *params GCC_UNUSED,		/* [0] = volume */
    Cardinal *param_count GCC_UNUSED)	/* 0 or 1 */
{
    Time ev_time = CurrentTime;

    if ((event->xany.type == KeyPress) ||
	(event->xany.type == KeyRelease))
	ev_time = event->xkey.time;
    else if ((event->xany.type == ButtonPress) ||
	     (event->xany.type == ButtonRelease))
	ev_time = event->xbutton.time;
    DoSecureKeyboard (ev_time);
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d3 1
a3 1
 * Copyright 1999-2002,2003 by Thomas E. Dickey
d53 1
a53 1
/* $XFree86: xc/programs/xterm/button.c,v 3.74 2003/09/21 17:12:45 dickey Exp $ */
a75 1
#include <charclass.h>
d78 1
d103 3
a105 3
       shift key -> 1
       meta key  -> 2
       control key -> 4 */
a138 9

#if OPT_READLINE
static Time lastButtonDownTime = 0;
static int ExtendingSelection = 0;
static Time lastButton3UpTime = 0;
static Time lastButton3DoubleDownTime = 0;
static int lastButton3row, lastButton3col;	/* At the release time */
#endif /* OPT_READLINE */

a139 1

d149 10
a158 14
static Char *SaveText(TScreen * screen, int row, int scol, int ecol, Char *
		      lp, int *eol);
static int Length(TScreen * screen, int row, int scol, int ecol);
static void ComputeSelect(int startRow, int startCol, int endRow, int
			  endCol, Bool extend);
static void EditorButton(XButtonEvent * event);
static void EndExtend(Widget w, XEvent * event, String * params, Cardinal
		      num_params, Bool use_cursor_loc);
static void ExtendExtend(int row, int col);
static void PointToRowCol(int y, int x, int *r, int *c);
static void ReHiliteText(int frow, int fcol, int trow, int tcol);
static void SaltTextAway(int crow, int ccol, int row, int col, String *
			 params, Cardinal num_params);
static void SelectSet(Widget w, XEvent * event, String * params, Cardinal num_params);
d160 3
a162 5
static void StartSelect(int startrow, int startcol);
static void TrackDown(XButtonEvent * event);
static void _OwnSelection(XtermWidget termw, String * selections, Cardinal count);
static void do_select_end(Widget w, XEvent * event, String * params,
			  Cardinal * num_params, Bool use_cursor_loc);
d164 1
a164 2
Boolean
SendMousePosition(Widget w, XEvent * event)
d171 1
a171 1
    screen = &((XtermWidget) w)->screen;
d179 1
a179 1
	return (SendLocatorPosition(w, event));
d181 1
a181 1
#endif /* OPT_DEC_LOCATOR */
d185 3
a187 3
	&& (screen->send_mouse_pos != ANY_EVENT_MOUSE)
	&& event->type != ButtonPress
	&& event->type != ButtonRelease)
d191 1
a191 1
    case X10_MOUSE:		/* X10 compatibility sequences */
d195 1
a195 1
		EditorButton((XButtonEvent *) event);
d200 5
a204 5
    case VT200_HIGHLIGHT_MOUSE:	/* DEC vt200 hilite tracking */
	if (event->type == ButtonPress &&
	    KeyModifiers == 0 &&
	    event->xbutton.button == Button1) {
	    TrackDown((XButtonEvent *) event);
d208 1
a208 1
	    EditorButton((XButtonEvent *) event);
d213 1
a213 1
    case VT200_MOUSE:		/* DEC vt200 compatible */
d215 4
a218 4
	/* xterm extension for motion reporting. June 1998 */
	/* EditorButton() will distinguish between the modes */
    case BTN_EVENT_MOUSE:
    case ANY_EVENT_MOUSE:
d220 1
a220 1
	    EditorButton((XButtonEvent *) event);
d225 1
a225 1
    default:
d268 1
a268 1
SendLocatorPosition(Widget w, XEvent * event)
d270 5
a274 5
    TScreen *screen = &((XtermWidget) w)->screen;
    int row, col;
    Boolean oor;
    int button;
    int state;
d281 1
a281 1
	return (False);
d287 1
a287 1
	return (True);
d289 3
a291 3
    if (event->type == MotionNotify) {
	CheckLocatorPosition(w, event);
	return (True);
d297 1
a297 1
    LocatorCoords(row, col, event->xbutton.x, event->xbutton.y, oor);
d300 5
a304 5
     * DECterm mouse:
     *
     * ESCAPE '[' event ; mask ; row ; column '&' 'w'
     */
    reply.a_type = CSI;
d306 1
a306 1
    if (oor) {
d308 1
a308 1
	reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
d310 1
a310 1
	reply.a_final = 'w';
d313 2
a314 2
	if (screen->locator_reset) {
	    MotionOff(screen, term);
d317 1
a317 1
	return (True);
d321 11
a331 11
     * event:
     *        1       no buttons
     *        2       left button down
     *        3       left button up
     *        4       middle button down
     *        5       middle button up
     *        6       right button down
     *        7       right button up
     *        8       M4 down
     *        9       M4 up
     */
d333 10
a342 9
    switch (event->type) {
    case ButtonPress:
	reply.a_param[0] = 2 + (button << 1);
	break;
    case ButtonRelease:
	reply.a_param[0] = 3 + (button << 1);
	break;
    default:
	return (True);
d345 9
a353 10
     * mask:
     * bit 7   bit 6   bit 5   bit 4   bit 3   bit 2       bit 1         bit 0
     *                                 M4 down left down   middle down   right down
     *
     * Notice that Button1 (left) and Button3 (right) are swapped in the mask.
     * Also, mask should be the state after the button press/release,
     * X provides the state not including the button press/release.
     */
    state = (event->xbutton.state
	     & (Button1Mask | Button2Mask | Button3Mask | Button4Mask)) >> 8;
d355 1
a355 1
    state = (state & ~(4 | 1)) | ((state & 1) ? 4 : 0) | ((state & 4) ? 1 : 0);		/* swap Button1 & Button3 */
d361 1
a361 1
    reply.a_final = 'w';
d365 2
a366 2
    if (screen->locator_reset) {
	MotionOff(screen, term);
d371 4
a374 4
     * DECterm turns the Locator off if a button is pressed while a filter rectangle
     * is active. This might be a bug, but I don't know, so I'll emulate it anyways.
     */
    if (screen->loc_filter) {
d378 1
a378 1
	MotionOff(screen, term);
d381 1
a381 1
    return (True);
d385 6
a390 6
 * mask:
 * bit 7   bit 6   bit 5   bit 4   bit 3   bit 2       bit 1         bit 0
 *                                 M4 down left down   middle down   right down
 *
 * Button1 (left) and Button3 (right) are swapped in the mask relative to X.
 */
d400 8
a407 8
    TScreen *screen = &w->screen;
    Window root, child;
    int rx, ry, x, y;
    unsigned int mask;
    int row = 0, col = 0;
    Boolean oor = FALSE;
    Bool ret = FALSE;
    int state;
d410 4
a413 4
     * DECterm turns the Locator off if the position is requested while a filter rectangle
     * is active.  This might be a bug, but I don't know, so I'll emulate it anyways.
     */
    if (screen->loc_filter) {
d417 1
a417 1
	MotionOff(screen, term);
d420 1
a420 1
    reply.a_type = CSI;
d423 2
a424 2
	ret = XQueryPointer(screen->display, VWindow(screen), &root,
			    &child, &rx, &ry, &x, &y, &mask);
d426 1
a426 1
	    LocatorCoords(row, col, x, y, oor);
d429 2
a430 1
    if (ret == FALSE || oor) {
d432 1
a432 1
	reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
d434 1
a434 1
	reply.a_final = 'w';
d437 2
a438 2
	if (screen->locator_reset) {
	    MotionOff(screen, term);
d444 1
a444 1
    ButtonState(state, mask);
d447 1
a447 1
    reply.a_param[0] = 1;	/* Event - 1 = response to locator request */
d452 1
a452 1
    reply.a_final = 'w';
d455 2
a456 2
    if (screen->locator_reset) {
	MotionOff(screen, term);
d462 1
a462 1
InitLocatorFilter(XtermWidget w)
d464 8
a471 8
    TScreen *screen = &w->screen;
    Window root, child;
    int rx, ry, x, y;
    unsigned int mask;
    int row = 0, col = 0;
    Boolean oor = 0;
    Bool ret;
    int state;
d473 2
a474 2
    ret = XQueryPointer(screen->display, VWindow(screen),
			&root, &child, &rx, &ry, &x, &y, &mask);
d476 1
a476 1
	LocatorCoords(row, col, x, y, oor);
d478 2
a479 1
    if (ret == FALSE || oor) {
d482 2
a483 2
	if (screen->loc_filter_top != LOC_FILTER_POS ||
	    screen->loc_filter_left != LOC_FILTER_POS ||
d485 2
a486 1
	    screen->loc_filter_right != LOC_FILTER_POS) {
d488 4
a491 4
	     * If any explicit coordinates were received,
	     * report immediately with no coordinates.
	     */
	    reply.a_type = CSI;
d493 1
a493 1
	    reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
d495 1
a495 1
	    reply.a_final = 'w';
d498 2
a499 2
	    if (screen->locator_reset) {
		MotionOff(screen, term);
d504 3
a506 3
	     * No explicit coordinates were received, and the pointer is
	     * unavailable.  Report when the pointer re-enters the window.
	     */
d508 1
a508 1
	    MotionOn(screen, term);
d514 8
a521 8
     * Adjust rectangle coordinates:
     *  1. Replace "LOC_FILTER_POS" with current coordinates
     *  2. Limit coordinates to screen size
     *  3. make sure top and left are less than bottom and right, resp.
     */
    if (screen->locator_pixels) {
	rx = OriginX(screen) * 2 + Width(screen);
	ry = screen->border * 2 + Height(screen);
d532 4
a535 4
    Adjust(screen->loc_filter_top, row, ry);
    Adjust(screen->loc_filter_left, col, rx);
    Adjust(screen->loc_filter_bottom, row, ry);
    Adjust(screen->loc_filter_right, col, rx);
d537 1
a537 1
    if (screen->loc_filter_top > screen->loc_filter_bottom) {
d543 1
a543 1
    if (screen->loc_filter_left > screen->loc_filter_right) {
d549 1
a549 1
    if ((col < screen->loc_filter_left) ||
d552 2
a553 1
	(row > screen->loc_filter_bottom)) {
d555 1
a555 1
	ButtonState(state, mask);
d557 1
a557 1
	reply.a_type = CSI;
d559 1
a559 1
	reply.a_param[0] = 10;	/* Event - 10 = locator outside filter */
d564 1
a564 1
	reply.a_final = 'w';
d567 2
a568 2
	if (screen->locator_reset) {
	    MotionOff(screen, term);
d575 3
a577 3
     * Rectangle is set up.  Allow pointer tracking
     * to detect if the mouse leaves the rectangle.
     */
d579 1
a579 1
    MotionOn(screen, term);
d583 1
a583 1
CheckLocatorPosition(Widget w, XEvent * event)
d585 4
a588 4
    TScreen *screen = &((XtermWidget) w)->screen;
    int row, col;
    Boolean oor;
    int state;
d590 1
a590 1
    LocatorCoords(row, col, event->xbutton.x, event->xbutton.y, oor);
d593 4
a596 4
     * Send report if the pointer left the filter rectangle, if
     * the pointer left the window, or if the filter rectangle
     * had no coordinates and the pointer re-entered the window.
     */
d598 1
a598 1
	(col < screen->loc_filter_left) ||
d600 3
a602 2
	(row < screen->loc_filter_top) ||
	(row > screen->loc_filter_bottom)) {
d605 1
a605 1
	MotionOff(screen, term);
d607 1
a607 1
	reply.a_type = CSI;
d610 1
a610 1
	    reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
d612 1
a612 1
	    ButtonState(state, event->xbutton.state);
d615 1
a615 1
	    reply.a_param[0] = 10;	/* Event - 10 = locator outside filter */
d622 1
a622 1
	reply.a_final = 'w';
d625 2
a626 2
	if (screen->locator_reset) {
	    MotionOff(screen, term);
d631 1
a631 125
#endif /* OPT_DEC_LOCATOR */

#if OPT_READLINE
static int
isClick1_clean(XEvent * event)
{
    TScreen *screen = &term->screen;
    int delta;

    if (!(event->type == ButtonPress || event->type == ButtonRelease)
    /* Disable on Shift-Click-1, including the application-mouse modes */
	|| (KeyModifiers & ShiftMask)
	|| (screen->send_mouse_pos != MOUSE_OFF)	/* Kinda duplicate... */
	||ExtendingSelection)	/* Was moved */
	return 0;
    if (event->type != ButtonRelease)
	return 0;
    if (lastButtonDownTime == (Time) 0)		/* first time or once in a blue moon */
	delta = term->screen.multiClickTime + 1;
    else if (event->xbutton.time > lastButtonDownTime)	/* most of the time */
	delta = event->xbutton.time - lastButtonDownTime;
    else			/* time has rolled over since lastButtonUpTime */
	delta = (((Time) ~ 0) - lastButtonDownTime) + event->xbutton.time;
    return delta <= term->screen.multiClickTime;
}

static int
isDoubleClick3(XEvent * event)
{
    int delta;

    if (event->type != ButtonRelease
	|| (KeyModifiers & ShiftMask)
	|| event->xbutton.button != Button3) {
	lastButton3UpTime = 0;	/* Disable the cached info */
	return 0;
    }
    /* Process Btn3Release. */
    if (lastButton3DoubleDownTime == (Time) 0)	/* No previous click
						   or once in a blue moon */
	delta = term->screen.multiClickTime + 1;
    else if (event->xbutton.time > lastButton3DoubleDownTime)	/* most of the time */
	delta = event->xbutton.time - lastButton3DoubleDownTime;
    else			/* time has rolled over since lastButton3DoubleDownTime */
	delta = (((Time) ~ 0) - lastButton3DoubleDownTime) + event->xbutton.time;
    if (delta <= term->screen.multiClickTime) {
	/* Double click */
	int row, col;

	/* Cannot check ExtendingSelection, since mouse-3 always sets it */
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
	if (row == lastButton3row && col == lastButton3col) {
	    lastButton3DoubleDownTime = 0;	/* Disable the third click */
	    return 1;
	}
    }
    /* Not a double click, memorize for future check. */
    lastButton3UpTime = event->xbutton.time;
    PointToRowCol(event->xbutton.y, event->xbutton.x,
		  &lastButton3row, &lastButton3col);
    return 0;
}

static int
CheckSecondPress3(XEvent * event)
{
    int delta, row, col;

    if (event->type != ButtonPress
	|| (KeyModifiers & ShiftMask)
	|| event->xbutton.button != Button3) {
	lastButton3DoubleDownTime = 0;	/* Disable the cached info */
	return 0;
    }
    /* Process Btn3Press. */
    if (lastButton3UpTime == (Time) 0)	/* No previous click
					   or once in a blue moon */
	delta = term->screen.multiClickTime + 1;
    else if (event->xbutton.time > lastButton3UpTime)	/* most of the time */
	delta = event->xbutton.time - lastButton3UpTime;
    else			/* time has rolled over since lastButton3UpTime */
	delta = (((Time) ~ 0) - lastButton3UpTime) + event->xbutton.time;
    if (delta <= term->screen.multiClickTime) {
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
	if (row == lastButton3row && col == lastButton3col) {
	    /* A candidate for a double-click */
	    lastButton3DoubleDownTime = event->xbutton.time;
	    PointToRowCol(event->xbutton.y, event->xbutton.x,
			  &lastButton3row, &lastButton3col);
	    return 1;
	}
	lastButton3UpTime = 0;	/* Disable the info about the previous click */
    }
    /* Either too long, or moved, disable. */
    lastButton3DoubleDownTime = 0;
    return 0;
}

static int
rowOnCurrentLine(int line, int *deltap)		/* must be XButtonEvent */
{
    TScreen *screen = &term->screen;
    int l1, l2;

    *deltap = 0;
    if (line == screen->cur_row)
	return 1;

    if (line < screen->cur_row)
	l1 = line, l2 = screen->cur_row;
    else
	l2 = line, l1 = screen->cur_row;
    l1--;
    while (++l1 < l2)
	if (!ScrnTstWrapped(screen, l1))
	    return 0;
    /* Everything is on one "wrapped line" now */
    *deltap = line - screen->cur_row;
    return 1;
}

static int
eventRow(XEvent * event)	/* must be XButtonEvent */
{
    TScreen *screen = &term->screen;
a632 53
    return (event->xbutton.y - screen->border) / FontHeight(screen);
}

static int
eventColBetween(XEvent * event)	/* must be XButtonEvent */
{
    TScreen *screen = &term->screen;

    /* Correct by half a width - we are acting on a boundary, not on a cell. */
    return ((event->xbutton.x - OriginX(screen) + (FontWidth(screen) - 1) / 2)
	    / FontWidth(screen));
}

static int
ReadLineMovePoint(int col, int ldelta)
{
    TScreen *screen = &term->screen;
    Char line[6];
    int count = 0;

    col += ldelta * (screen->max_col + 1) - screen->cur_col;
    if (col == 0)
	return 0;
    if (screen->control_eight_bits) {
	line[count++] = CSI;
    } else {
	line[count++] = ESC;
	line[count++] = '[';	/* XXX maybe sometimes O is better? */
    }
    line[count++] = (col > 0 ? 'C' : 'D');
    if (col < 0)
	col = -col;
    while (col--)
	v_write(screen->respond, line, 3);
    return 1;
}

static int
ReadLineDelete(int r1, int c1, int r2, int c2)
{
    TScreen *screen = &term->screen;
    int del;

    del = c2 - c1 + (r2 - r1) * (screen->max_col + 1);
    if (del <= 0)		/* Just in case... */
	return 0;
    while (del--)
	v_write(screen->respond, "\177", 1);	/* XXX Sometimes "\08"? */
    return 1;
}
#endif /* OPT_READLINE */

/* ^XM-G<line+' '><col+' '> */
d634 9
a642 8
DiredButton(Widget w GCC_UNUSED,
	    XEvent * event,	/* must be XButtonEvent */
	    String * params GCC_UNUSED,		/* selections */
	    Cardinal * num_params GCC_UNUSED)
{
    TScreen *screen = &term->screen;
    Char Line[6];
    unsigned line, col;
d645 2
a646 2
	line = (event->xbutton.y - screen->border) / FontHeight(screen);
	col = (event->xbutton.x - OriginX(screen)) / FontWidth(screen);
d652 1
a652 1
	v_write(screen->respond, Line, 5);
a655 61
#if OPT_READLINE
void
ReadLineButton(Widget w GCC_UNUSED,
	       XEvent * event,	/* must be XButtonEvent */
	       String * params GCC_UNUSED,	/* selections */
	       Cardinal * num_params GCC_UNUSED)
{
    TScreen *screen = &term->screen;
    Char Line[6];
    int line, col, ldelta = 0;

    if (!(event->type == ButtonPress || event->type == ButtonRelease)
	|| (screen->send_mouse_pos != MOUSE_OFF) || ExtendingSelection)
	goto finish;
    if (event->type == ButtonRelease) {
	int delta;

	if (lastButtonDownTime == (Time) 0)	/* first time and once in a blue moon */
	    delta = screen->multiClickTime + 1;
	else if (event->xbutton.time > lastButtonDownTime)	/* most of the time */
	    delta = event->xbutton.time - lastButtonDownTime;
	else			/* time has rolled over since lastButtonUpTime */
	    delta = (((Time) ~ 0) - lastButtonDownTime) + event->xbutton.time;
	if (delta > screen->multiClickTime)
	    goto finish;	/* All this work for this... */
    }
    line = (event->xbutton.y - screen->border) / FontHeight(screen);
    if (line != screen->cur_row) {
	int l1, l2;

	if (line < screen->cur_row)
	    l1 = line, l2 = screen->cur_row;
	else
	    l2 = line, l1 = screen->cur_row;
	l1--;
	while (++l1 < l2)
	    if (!ScrnTstWrapped(screen, l1))
		goto finish;
	/* Everything is on one "wrapped line" now */
	ldelta = line - screen->cur_row;
    }
    /* Correct by half a width - we are acting on a boundary, not on a cell. */
    col = (event->xbutton.x - OriginX(screen) + (FontWidth(screen) - 1) / 2)
	/ FontWidth(screen) - screen->cur_col + ldelta * (screen->max_col + 1);
    if (col == 0)
	goto finish;
    Line[0] = ESC;
    /* XXX: sometimes it is better to send '['? */
    Line[1] = 'O';
    Line[2] = (col > 0 ? 'C' : 'D');
    if (col < 0)
	col = -col;
    while (col--)
	v_write(screen->respond, Line, 3);
  finish:
    if (event->type == ButtonRelease)
	do_select_end(w, event, params, num_params, False);
}
#endif /* OPT_READLINE */

/* repeats <ESC>n or <ESC>p */
d657 7
a663 6
ViButton(Widget w GCC_UNUSED,
	 XEvent * event,	/* must be XButtonEvent */
	 String * params GCC_UNUSED,	/* selections */
	 Cardinal * num_params GCC_UNUSED)
{
    TScreen *screen = &term->screen;
d665 2
a666 2
    Char Line[6];
    int line;
d671 1
a671 1
	    ((event->xbutton.y - screen->border) / FontHeight(screen));
d674 1
a674 1
	    v_write(pty, Line, 1);
d676 1
a676 1
	    if (line < 0) {
d682 2
a683 2
	    while (--line >= 0)
		v_write(pty, Line, 1);
d688 1
d693 5
a697 5
void
HandleSelectExtend(Widget w,
		   XEvent * event,	/* must be XMotionEvent */
		   String * params GCC_UNUSED,
		   Cardinal * num_params GCC_UNUSED)
d699 2
a700 2
    TScreen *screen;
    int row, col;
d702 2
a703 2
    if (!IsXtermWidget(w))
	return;
d705 20
a724 20
    screen = &((XtermWidget) w)->screen;
    screen->selection_time = event->xmotion.time;
    switch (eventMode) {
	/* If not in one of the DEC mouse-reporting modes */
    case LEFTEXTENSION:
    case RIGHTEXTENSION:
	PointToRowCol(event->xmotion.y, event->xmotion.x,
		      &row, &col);
	ExtendExtend(row, col);
	break;

	/* If in motion reporting mode, send mouse position to
	   character process as a key sequence \E[M... */
    case NORMAL:
	/* will get here if send_mouse_pos != MOUSE_OFF */
	if (screen->send_mouse_pos == BTN_EVENT_MOUSE
	    || screen->send_mouse_pos == ANY_EVENT_MOUSE)
	    SendMousePosition(w, event);
	break;
    }
d727 9
a735 14
static void
do_select_end(Widget w,
	      XEvent * event,	/* must be XButtonEvent */
	      String * params,	/* selections */
	      Cardinal * num_params,
	      Bool use_cursor_loc)
{
#if OPT_READLINE
    int ldelta1, ldelta2;
    TScreen *screen = &term->screen;
#endif

    if (!IsXtermWidget(w))
	return;
d737 9
a745 20
    ((XtermWidget) w)->screen.selection_time = event->xbutton.time;
    switch (eventMode) {
    case NORMAL:
	(void) SendMousePosition(w, event);
	break;
    case LEFTEXTENSION:
    case RIGHTEXTENSION:
	EndExtend(w, event, params, *num_params, use_cursor_loc);
#if OPT_READLINE
	if (isClick1_clean(event)
	    && SCREEN_FLAG(screen, click1_moves)
	    && rowOnCurrentLine(eventRow(event), &ldelta1)) {
	    ReadLineMovePoint(eventColBetween(event), ldelta1);
	}
	if (isDoubleClick3(event)
	    && SCREEN_FLAG(screen, dclick3_deletes)
	    && rowOnCurrentLine(startSRow, &ldelta1)
	    && rowOnCurrentLine(endSRow, &ldelta2)) {
	    ReadLineMovePoint(endSCol, ldelta2);
	    ReadLineDelete(startSRow, startSCol, endSRow, endSCol);
a746 3
#endif /* OPT_READLINE */
	break;
    }
d749 6
a754 5
void
HandleSelectEnd(Widget w,
		XEvent * event,	/* must be XButtonEvent */
		String * params,	/* selections */
		Cardinal * num_params)
d756 1
a756 1
    do_select_end(w, event, params, num_params, False);
d759 6
a764 5
void
HandleKeyboardSelectEnd(Widget w,
			XEvent * event,		/* must be XButtonEvent */
			String * params,	/* selections */
			Cardinal * num_params)
d766 1
a766 1
    do_select_end(w, event, params, num_params, True);
d781 1
a781 1
UTF8toLatin1(Char * s, int len, unsigned long *result)
d790 1
a790 1
	buffer = (Char *) XtMalloc(used = len);
d792 1
a792 1
	buffer = (Char *) XtRealloc((char *) buffer, used = len);
d796 2
a797 2
    /* We're assuming that the xterm widget never contains Unicode
       control characters. */
d819 72
d900 1
a900 1
    if (!IsXtermWidget(w))
d903 1
a903 1
    screen = &((XtermWidget) w)->screen;
d910 1
a910 1
	    utf8SelectionTargets = (Atom *) XtMalloc(5 * sizeof(Atom));
d916 1
a916 1
	    utf8SelectionTargets[n++] = XA_UTF8_STRING(XtDisplay(w));
d919 2
a920 2
		utf8SelectionTargets[n++] = XA_TEXT(XtDisplay(w));
		utf8SelectionTargets[n++] = XA_COMPOUND_TEXT(XtDisplay(w));
d923 1
a923 1
	    utf8SelectionTargets[n++] = XA_STRING;
d932 1
a932 1
	eightBitSelectionTargets = (Atom *) XtMalloc(5 * sizeof(Atom));
d939 1
a939 1
	eightBitSelectionTargets[n++] = XA_UTF8_STRING(XtDisplay(w));
d942 2
a943 2
	    eightBitSelectionTargets[n++] = XA_TEXT(XtDisplay(w));
	    eightBitSelectionTargets[n++] = XA_COMPOUND_TEXT(XtDisplay(w));
d945 1
a945 1
	eightBitSelectionTargets[n++] = XA_STRING;
d951 6
a956 6
static void
_GetSelection(Widget w,
	      Time ev_time,
	      String * params,	/* selections in precedence order */
	      Cardinal num_params,
	      Atom * targets)
d965 1
a965 1
    XmuInternStrings(XtDisplay(w), params, (Cardinal) 1, &selection);
d967 10
a976 26
    case XA_CUT_BUFFER0:
	cutbuffer = 0;
	break;
    case XA_CUT_BUFFER1:
	cutbuffer = 1;
	break;
    case XA_CUT_BUFFER2:
	cutbuffer = 2;
	break;
    case XA_CUT_BUFFER3:
	cutbuffer = 3;
	break;
    case XA_CUT_BUFFER4:
	cutbuffer = 4;
	break;
    case XA_CUT_BUFFER5:
	cutbuffer = 5;
	break;
    case XA_CUT_BUFFER6:
	cutbuffer = 6;
	break;
    case XA_CUT_BUFFER7:
	cutbuffer = 7;
	break;
    default:
	cutbuffer = -1;
d979 1
a979 1
	   targets ? (unsigned long) targets[0] : 0));
d988 1
a988 1
	    SelectionReceived(w, NULL, &selection, &type, (XtPointer) line,
d991 1
a991 1
	    _GetSelection(w, ev_time, params + 1, num_params - 1, NULL);
d994 1
a994 1
	struct _SelectionList *list;
d1003 1
a1003 1
	    if (targets[1] == None) {	/* last target in list */
d1017 1
a1017 2
	    } else
		list = NULL;
d1022 1
a1022 1
				(XtPointer) list, ev_time);
d1028 1
a1028 2
static void
GettingSelection(Display * dpy, Atom type, Char * line, int len)
d1035 1
a1035 1
    Trace("Getting %s (%ld)\n", XGetAtomName(dpy, type), (long int) type);
d1040 1
a1040 1
#define GettingSelection(dpy,type,line,len)	/* nothing */
d1043 1
a1043 6
#ifdef VMS
#  define tty_vwrite(pty,lag,l)		tt_write(lag,l)
#else /* !( VMS ) */
#  define tty_vwrite(pty,lag,l)		v_write(pty,lag,l)
#endif /* defined VMS */

d1045 1
a1045 1
_qWriteSelectionData(TScreen * screen, Char * lag, int length)
d1047 13
a1059 5
#if OPT_READLINE
    if (SCREEN_FLAG(screen, paste_quotes)) {
	while (length--) {
	    tty_vwrite(screen->respond, "\026", 1);	/* Control-V */
	    tty_vwrite(screen->respond, lag++, 1);
d1061 4
a1064 3
    } else
#endif
	tty_vwrite(screen->respond, lag, length);
d1067 2
d1070 1
a1070 1
_WriteSelectionData(TScreen * screen, Char * line, int length)
a1071 6
    /* Write data to pty a line at a time. */
    /* Doing this one line at a time may no longer be necessary
       because v_write has been re-written. */

    Char *lag, *cp, *end;

d1076 3
a1078 1
#ifdef VMS
a1079 1
#endif
d1083 5
a1087 7
    if (!SCREEN_FLAG(screen, paste_literal_nl)) {
	for (cp = line; cp != end; cp++) {
	    if (*cp == '\n') {
		*cp = '\r';
		_qWriteSelectionData(screen, lag, cp - lag + 1);
		lag = cp + 1;
	    }
d1091 1
a1091 1
	_qWriteSelectionData(screen, lag, end - lag);
d1093 1
a1093 1
#ifdef VMS
d1095 1
a1095 21
    tt_start_read();		/* reenable reads or a character may be lost */
#endif
}

#if OPT_READLINE
static void
_WriteKey(TScreen * screen, Char * in)
{
    char line[16];
    int count = 0, length = strlen(in);

    if (screen->control_eight_bits) {
	line[count++] = CSI;
    } else {
	line[count++] = ESC;
	line[count++] = '[';
    }
    while (length--)
	line[count++] = *in++;
    line[count++] = '~';
    tty_vwrite(screen->respond, line, count);
d1097 1
a1097 1
#endif /* OPT_READLINE */
d1102 8
a1109 8
static void
SelectionReceived(Widget w,
		  XtPointer client_data,
		  Atom * selection GCC_UNUSED,
		  Atom * type,
		  XtPointer value,
		  unsigned long *length,
		  int *format GCC_UNUSED)
d1117 1
a1117 1
    Char *line = (Char *) value;
d1122 1
a1122 1
    screen = &((XtermWidget) w)->screen;
d1125 1
a1125 3
    if (*type == 0		/*XT_CONVERT_FAIL */
	|| *length == 0
	|| value == NULL)
d1128 1
a1128 1
    text_prop.value = (unsigned char *) value;
d1134 1
a1134 1
    if (screen->wide_chars) {
d1136 2
a1137 2
	    *type == XA_STRING ||
	    *type == XA_COMPOUND_TEXT(XtDisplay(w))) {
d1139 3
a1141 3
	    if (Xutf8TextPropertyToTextList(dpy, &text_prop,
					    &text_list,
					    &text_list_count) < 0) {
d1151 4
a1154 4
	/* There's no need to special-case UTF8_STRING.  If Xlib
	   doesn't know about it, we didn't request it.  If a broken
	   selection holder sends it anyhow, the conversion function
	   will fail. */
d1157 3
a1159 3
	    *type == XA_STRING ||
	    *type == XA_COMPOUND_TEXT(XtDisplay(w))) {
	    Status rc;
d1161 1
a1161 1
	    if (*type == XA_STRING && screen->brokenSelections) {
d1164 6
a1169 6
	    } else {
		rc = XmbTextPropertyToTextList(dpy, &text_prop,
					       &text_list,
					       &text_list_count);
	    }
	    if (rc < 0) {
d1176 1
a1176 1
    if (text_list != NULL && text_list_count != 0) {
d1178 1
a1178 6

#if OPT_READLINE
	if (SCREEN_FLAG(screen, paste_brackets))
	    _WriteKey(screen, "200");
#endif
	for (i = 0; i < text_list_count; i++) {
d1180 2
a1181 1
	    _WriteSelectionData(screen, (Char *) text_list[i], len);
a1182 4
#if OPT_READLINE
	if (SCREEN_FLAG(screen, paste_brackets))
	    _WriteKey(screen, "201");
#endif
d1187 2
a1188 2
    XtFree((char *) client_data);
    XtFree((char *) value);
d1194 1
a1194 1
	struct _SelectionList *list = (struct _SelectionList *) client_data;
d1197 1
a1197 1
	XtFree((char *) client_data);
d1202 1
d1204 5
a1208 4
HandleInsertSelection(Widget w,
		      XEvent * event,	/* assumed to be XButtonEvent* */
		      String * params,	/* selections in precedence order */
		      Cardinal * num_params)
d1210 1
a1210 18
#if OPT_READLINE
    int ldelta;
    TScreen *screen = &((XtermWidget) w)->screen;
#endif

    if (SendMousePosition(w, event))
	return;

#if OPT_READLINE
    if ((event->type == ButtonPress || event->type == ButtonRelease)
    /* Disable on Shift-mouse, including the application-mouse modes */
	&& !(KeyModifiers & ShiftMask)
	&& (screen->send_mouse_pos == MOUSE_OFF)
	&& SCREEN_FLAG(screen, paste_moves)
	&& rowOnCurrentLine(eventRow(event), &ldelta))
	ReadLineMovePoint(eventColBetween(event), ldelta);
#endif /* OPT_READLINE */

d1219 1
a1219 1
    if (lastButtonUpTime == (Time) 0)	/* first time and once in a blue moon */
d1221 1
a1221 1
    else if (buttonDownTime > lastButtonUpTime)		/* most of the time */
d1223 2
a1224 2
    else			/* time has rolled over since lastButtonUpTime */
	delta = (((Time) ~ 0) - lastButtonUpTime) + buttonDownTime;
d1235 10
a1244 16
static void
do_select_start(Widget w,
		XEvent * event,	/* must be XButtonEvent* */
		int startrow,
		int startcol)
{
    if (SendMousePosition(w, event))
	return;
    selectUnit = EvalSelectUnit(event->xbutton.time, SELECTCHAR);
    replyToEmacs = FALSE;

#if OPT_READLINE
    lastButtonDownTime = event->xbutton.time;
#endif

    StartSelect(startrow, startcol);
d1249 5
a1253 4
HandleSelectStart(Widget w,
		  XEvent * event,	/* must be XButtonEvent* */
		  String * params GCC_UNUSED,
		  Cardinal * num_params GCC_UNUSED)
d1255 2
a1256 2
    TScreen *screen;
    int startrow, startcol;
d1258 2
a1259 2
    if (!IsXtermWidget(w))
	return;
d1261 6
a1266 4
    screen = &((XtermWidget) w)->screen;
    firstValidRow = 0;
    lastValidRow = screen->max_row;
    PointToRowCol(event->xbutton.y, event->xbutton.x, &startrow, &startcol);
a1267 6
#if OPT_READLINE
    ExtendingSelection = 0;
#endif

    do_select_start(w, event, startrow, startcol);
}
d1271 5
a1275 4
HandleKeyboardSelectStart(Widget w,
			  XEvent * event,	/* must be XButtonEvent* */
			  String * params GCC_UNUSED,
			  Cardinal * num_params GCC_UNUSED)
d1277 1
a1277 1
    TScreen *screen;
d1279 2
a1280 2
    if (!IsXtermWidget(w))
	return;
d1282 2
a1283 2
    screen = &((XtermWidget) w)->screen;
    do_select_start(w, event, screen->cursor_row, screen->cursor_col);
d1286 1
d1288 1
a1288 1
TrackDown(XButtonEvent * event)
d1290 1
a1290 1
    int startrow, startcol;
d1292 9
a1300 9
    selectUnit = EvalSelectUnit(event->time, SELECTCHAR);
    if (numberOfClicks > 1) {
	PointToRowCol(event->y, event->x, &startrow, &startcol);
	replyToEmacs = TRUE;
	StartSelect(startrow, startcol);
    } else {
	waitingForTrackInfo = 1;
	EditorButton((XButtonEvent *) event);
    }
d1303 1
d1312 1
a1312 1
    TScreen *screen = &term->screen;
d1314 8
a1321 9
    if (!waitingForTrackInfo) {	/* Timed out, so ignore */
	return;
    }
    waitingForTrackInfo = 0;
    if (func == 0)
	return;
    boundsCheck(startrow)
	boundsCheck(firstrow)
	boundsCheck(lastrow)
d1323 3
a1325 3
    lastValidRow = lastrow;
    replyToEmacs = TRUE;
    StartSelect(startrow, startcol);
d1331 1
a1331 1
    TScreen *screen = &term->screen;
d1333 24
a1356 24
    TRACE(("StartSelect row=%d, col=%d\n", startrow, startcol));
    if (screen->cursor_state)
	HideCursor();
    if (numberOfClicks == 1) {
	/* set start of selection */
	rawRow = startrow;
	rawCol = startcol;

    }
    /* else use old values in rawRow, Col */
    saveStartRRow = startERow = rawRow;
    saveStartRCol = startECol = rawCol;
    saveEndRRow = endERow = rawRow;
    saveEndRCol = endECol = rawCol;
    if (Coordinate(startrow, startcol) < Coordinate(rawRow, rawCol)) {
	eventMode = LEFTEXTENSION;
	startERow = startrow;
	startECol = startcol;
    } else {
	eventMode = RIGHTEXTENSION;
	endERow = startrow;
	endECol = startcol;
    }
    ComputeSelect(startERow, startECol, endERow, endECol, False);
d1361 47
a1407 45
EndExtend(Widget w,
	  XEvent * event,	/* must be XButtonEvent */
	  String * params,	/* selections */
	  Cardinal num_params,
	  Bool use_cursor_loc)
{
    int row, col, count;
    TScreen *screen = &term->screen;
    Char line[9];

    if (use_cursor_loc) {
	row = screen->cursor_row;
	col = screen->cursor_col;
    } else {
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
    }
    ExtendExtend(row, col);
    lastButtonUpTime = event->xbutton.time;
    if (startSRow != endSRow || startSCol != endSCol) {
	if (replyToEmacs) {
	    count = 0;
	    if (screen->control_eight_bits) {
		line[count++] = CSI;
	    } else {
		line[count++] = ESC;
		line[count++] = '[';
	    }
	    if (rawRow == startSRow && rawCol == startSCol
		&& row == endSRow && col == endSCol) {
		/* Use short-form emacs select */
		line[count++] = 't';
		line[count++] = ' ' + endSCol + 1;
		line[count++] = ' ' + endSRow + 1;
	    } else {
		/* long-form, specify everything */
		line[count++] = 'T';
		line[count++] = ' ' + startSCol + 1;
		line[count++] = ' ' + startSRow + 1;
		line[count++] = ' ' + endSCol + 1;
		line[count++] = ' ' + endSRow + 1;
		line[count++] = ' ' + col + 1;
		line[count++] = ' ' + row + 1;
	    }
	    v_write(screen->respond, line, count);
	    TrackText(0, 0, 0, 0);
d1409 2
a1410 3
    }
    SelectSet(w, event, params, num_params);
    eventMode = NORMAL;
d1414 5
a1418 4
HandleSelectSet(Widget w,
		XEvent * event,
		String * params,
		Cardinal * num_params)
d1420 1
a1420 1
    SelectSet(w, event, params, *num_params);
d1425 12
a1436 11
SelectSet(Widget w GCC_UNUSED,
	  XEvent * event GCC_UNUSED,
	  String * params,
	  Cardinal num_params)
{
    /* Only do select stuff if non-null select */
    if (startSRow != endSRow || startSCol != endSCol) {
	SaltTextAway(startSRow, startSCol, endSRow, endSCol,
		     params, num_params);
    } else
	DisownSelection(term);
d1442 6
a1447 6
static void
do_start_extend(Widget w,
		XEvent * event,	/* must be XButtonEvent* */
		String * params GCC_UNUSED,
		Cardinal * num_params GCC_UNUSED,
		Bool use_cursor_loc)
d1449 2
a1450 2
    TScreen *screen;
    int row, col, coord;
d1452 2
a1453 2
    if (!IsXtermWidget(w))
	return;
d1455 4
a1458 10
    screen = &((XtermWidget) w)->screen;
    if (SendMousePosition(w, event))
	return;
    firstValidRow = 0;
    lastValidRow = screen->max_row;
#if OPT_READLINE
    if ((KeyModifiers & ShiftMask)
	|| event->xbutton.button != Button3
	|| !(SCREEN_FLAG(screen, dclick3_deletes)))
#endif
d1460 1
a1460 1
    replyToEmacs = FALSE;
d1462 13
a1474 3
#if OPT_READLINE
    CheckSecondPress3(event);
#endif
d1476 8
a1483 15
    if (numberOfClicks == 1
	|| (SCREEN_FLAG(screen, dclick3_deletes)	/* Dclick special */
	    &&!(KeyModifiers & ShiftMask))) {
	/* Save existing selection so we can reestablish it if the guy
	   extends past the other end of the selection */
	saveStartRRow = startERow = startRRow;
	saveStartRCol = startECol = startRCol;
	saveEndRRow = endERow = endRRow;
	saveEndRCol = endECol = endRCol;
    } else {
	/* He just needed the selection mode changed, use old values. */
	startERow = startRRow = saveStartRRow;
	startECol = startRCol = saveStartRCol;
	endERow = endRRow = saveEndRRow;
	endECol = endRCol = saveEndRCol;
d1485 14
a1498 28
    }
    if (use_cursor_loc) {
	row = screen->cursor_row;
	col = screen->cursor_col;
    } else {
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
    }
    coord = Coordinate(row, col);

    if (Abs(coord - Coordinate(startSRow, startSCol))
	< Abs(coord - Coordinate(endSRow, endSCol))
	|| coord < Coordinate(startSRow, startSCol)) {
	/* point is close to left side of selection */
	eventMode = LEFTEXTENSION;
	startERow = row;
	startECol = col;
    } else {
	/* point is close to left side of selection */
	eventMode = RIGHTEXTENSION;
	endERow = row;
	endECol = col;
    }
    ComputeSelect(startERow, startECol, endERow, endECol, True);

#if OPT_READLINE
    if (startSRow != endSRow || startSCol != endSCol)
	ExtendingSelection = 1;
#endif
d1502 27
a1528 3
ExtendExtend(int row, int col)
{
    int coord = Coordinate(row, col);
a1529 22
    TRACE(("ExtendExtend row=%d, col=%d\n", row, col));
    if (eventMode == LEFTEXTENSION
	&& (coord + (selectUnit != SELECTCHAR)) > Coordinate(endSRow, endSCol)) {
	/* Whoops, he's changed his mind.  Do RIGHTEXTENSION */
	eventMode = RIGHTEXTENSION;
	startERow = saveStartRRow;
	startECol = saveStartRCol;
    } else if (eventMode == RIGHTEXTENSION
	       && coord < Coordinate(startSRow, startSCol)) {
	/* Whoops, he's changed his mind.  Do LEFTEXTENSION */
	eventMode = LEFTEXTENSION;
	endERow = saveEndRRow;
	endECol = saveEndRCol;
    }
    if (eventMode == LEFTEXTENSION) {
	startERow = row;
	startECol = col;
    } else {
	endERow = row;
	endECol = col;
    }
    ComputeSelect(startERow, startECol, endERow, endECol, False);
d1531 5
a1535 11
#if OPT_READLINE
    if (startSRow != endSRow || startSCol != endSCol)
	ExtendingSelection = 1;
#endif
}

void
HandleStartExtend(Widget w,
		  XEvent * event,	/* must be XButtonEvent* */
		  String * params,	/* unused */
		  Cardinal * num_params)	/* unused */
d1537 1
a1537 1
    do_start_extend(w, event, params, num_params, False);
d1540 5
a1544 5
void
HandleKeyboardStartExtend(Widget w,
			  XEvent * event,	/* must be XButtonEvent* */
			  String * params,	/* unused */
			  Cardinal * num_params)	/* unused */
d1546 1
a1546 1
    do_start_extend(w, event, params, num_params, True);
d1550 1
a1550 1
ScrollSelection(TScreen * screen, int amount)
d1552 3
a1554 3
    int minrow = -screen->savedlines - screen->topline;
    int maxrow = screen->max_row - screen->topline;
    int maxcol = screen->max_col;
d1568 1
a1568 1
    scroll_update_one(endRRow, endRCol);
d1570 1
a1570 1
    scroll_update_one(endSRow, endSCol);
d1575 1
a1575 1
    scroll_update_one(screen->endHRow, screen->endHCol);
d1577 2
a1578 2
    screen->startHCoord = Coordinate(screen->startHRow, screen->startHCol);
    screen->endHCoord = Coordinate(screen->endHRow, screen->endHCol);
d1581 1
d1584 1
a1584 1
ResizeSelection(TScreen * screen GCC_UNUSED, int rows, int cols)
d1586 1
a1586 1
    rows--;			/* decr to get 0-max */
d1589 11
a1599 21
    if (startRRow > rows)
	startRRow = rows;
    if (startSRow > rows)
	startSRow = rows;
    if (endRRow > rows)
	endRRow = rows;
    if (endSRow > rows)
	endSRow = rows;
    if (rawRow > rows)
	rawRow = rows;

    if (startRCol > cols)
	startRCol = cols;
    if (startSCol > cols)
	startSCol = cols;
    if (endRCol > cols)
	endRCol = cols;
    if (endSCol > cols)
	endSCol = cols;
    if (rawCol > cols)
	rawCol = cols;
d1603 1
a1603 2
int
iswide(int i)
d1610 5
a1614 4
PointToRowCol(int y,
	      int x,
	      int *r,
	      int *c)
d1620 2
a1621 2
    TScreen *screen = &term->screen;
    int row, col;
d1623 11
a1633 11
    row = (y - screen->border) / FontHeight(screen);
    if (row < firstValidRow)
	row = firstValidRow;
    else if (row > lastValidRow)
	row = lastValidRow;
    col = (x - OriginX(screen)) / FontWidth(screen);
    if (col < 0)
	col = 0;
    else if (col > screen->max_col + 1) {
	col = screen->max_col + 1;
    }
d1635 9
a1643 9
    /*
     * If we got a click on the right half of a doublewidth character,
     * pretend it happened on the left half.
     */
    if (col > 0
	&& iswide(XTERM_CELL(row, col - 1))
	&& (XTERM_CELL(row, col) == HIDDEN_CHAR)) {
	col -= 1;
    }
d1645 2
a1646 2
    *r = row;
    *c = col;
d1650 1
a1650 1
LastTextCol(int row)
d1652 10
a1661 9
    TScreen *screen = &term->screen;
    int i;
    Char *ch;

    if ((row += screen->topline) + screen->savedlines >= 0) {
	for (i = screen->max_col,
	     ch = SCRN_BUF_ATTRS(screen, row) + i;
	     i >= 0 && !(*ch & CHARDRAWN);
	     ch--, i--) ;
d1663 6
a1668 2
	if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, row)[0])) {
	    i *= 2;
d1670 1
a1670 5
#endif
    } else {
	i = -1;
    }
    return (i);
d1684 1
a1684 3
/* *INDENT-OFF* */
static int charClass[256] =
{
d1686 1
a1686 1
    32,  1,    1,   1,   1,   1,   1,   1,
d1718 1
a1718 1
    1,    1,   1,   1,   1,   1,   1,   1,
d1720 1
a1720 1
    1,    1,   1,   1,   1,   1,   1,   1,
d1722 1
a1722 1
    1,    1,   1,   1,   1,   1,   1,   1,
d1724 1
a1724 1
    1,    1,   1,   1,   1,   1,   1,   1,
d1726 1
a1726 1
    160, 161, 162, 163, 164, 165, 166, 167,
d1728 1
a1728 1
    168, 169, 170, 171, 172, 173, 174, 175,
d1730 1
a1730 1
    176, 177, 178, 179, 180, 181, 182, 183,
d1732 1
a1732 1
    184, 185, 186, 187, 188, 189, 190, 191,
d1734 1
a1734 1
     48,  48,  48,  48,  48,  48,  48,  48,
d1736 1
a1736 1
     48,  48,  48,  48,  48,  48,  48,  48,
d1738 1
a1738 1
     48,  48,  48,  48,  48,  48,  48, 215,
d1740 1
a1740 1
     48,  48,  48,  48,  48,  48,  48,  48,
d1742 1
a1742 1
     48,  48,  48,  48,  48,  48,  48,  48,
d1744 1
a1744 1
     48,  48,  48,  48,  48,  48,  48,  48,
d1746 1
a1746 1
     48,  48,  48,  48,  48,  48,  48, 247,
d1748 1
a1748 2
     48,  48,  48,  48,  48,  48,  48,  48};
/* *INDENT-ON* */
d1750 4
a1753 4
int
SetCharacterClassRange(int low,	/* in range of [0..255] */
		       int high,
		       int value)	/* arbitrary */
d1756 1
a1756 2
    if (low < 0 || high > 255 || high < low)
	return (-1);
d1758 1
a1758 2
    for (; low <= high; low++)
	charClass[low] = value;
d1765 1
a1765 2
static int
class_of(TScreen * screen, int row, int col)
d1776 1
a1776 1
    });
d1792 1
d1794 10
a1803 12
ComputeSelect(int startRow,
	      int startCol,
	      int endRow,
	      int endCol,
	      Bool extend)
{
    TScreen *screen = &term->screen;
    int length;
    int cclass;

    TRACE(("ComputeSelect(startRow=%d, startCol=%d, endRow=%d, endCol=%d, %sextend)\n",
	   startRow, startCol, endRow, endCol, extend ? "" : "no"));
d1806 12
a1817 13
    if (startCol > 1
	&& iswide(XTERM_CELL(startRow, startCol - 1))
	&& XTERM_CELL(startRow, startCol - 0) == HIDDEN_CHAR) {
	fprintf(stderr, "Adjusting start. Changing downwards from %i.\n", startCol);
	startCol -= 1;
	if (endCol == (startCol + 1))
	    endCol--;
    }

    if (iswide(XTERM_CELL(endRow, endCol - 1))
	&& XTERM_CELL(endRow, endCol) == HIDDEN_CHAR) {
	endCol += 1;
    }
d1820 40
a1859 40
    if (Coordinate(startRow, startCol) <= Coordinate(endRow, endCol)) {
	startSRow = startRRow = startRow;
	startSCol = startRCol = startCol;
	endSRow = endRRow = endRow;
	endSCol = endRCol = endCol;
    } else {			/* Swap them */
	startSRow = startRRow = endRow;
	startSCol = startRCol = endCol;
	endSRow = endRRow = startRow;
	endSCol = endRCol = startCol;
    }

    switch (selectUnit) {
    case SELECTCHAR:
	if (startSCol > (LastTextCol(startSRow) + 1)) {
	    startSCol = 0;
	    startSRow++;
	}
	if (endSCol > (LastTextCol(endSRow) + 1)) {
	    endSCol = 0;
	    endSRow++;
	}
	break;
    case SELECTWORD:
	if (startSCol > (LastTextCol(startSRow) + 1)) {
	    startSCol = 0;
	    startSRow++;
	} else {
	    cclass = class_of(screen, startSRow, startSCol);
	    do {
		--startSCol;
		if (startSCol < 0
		    && ScrnTstWrapped(screen, startSRow - 1)) {
		    --startSRow;
		    startSCol = LastTextCol(startSRow);
		}
	    } while (startSCol >= 0
		     && ClassSelects(screen, startSRow, startSCol, cclass));
	    ++startSCol;
	}
d1862 2
a1863 2
	if (startSCol && XTERM_CELL(startSRow, startSCol) == HIDDEN_CHAR)
	    startSCol++;
d1866 25
a1890 25
	if (endSCol > (LastTextCol(endSRow) + 1)) {
	    endSCol = 0;
	    endSRow++;
	} else {
	    length = LastTextCol(endSRow);
	    cclass = class_of(screen, endSRow, endSCol);
	    do {
		++endSCol;
		if (endSCol > length
		    && ScrnTstWrapped(screen, endSRow)) {
		    endSCol = 0;
		    ++endSRow;
		    length = LastTextCol(endSRow);
		}
	    } while (endSCol <= length
		     && ClassSelects(screen, endSRow, endSCol, cclass));
	    /* Word select selects if pointing to any char
	       in "word", especially in that it includes
	       the last character in a word.  So no --endSCol
	       and do special eol handling */
	    if (endSCol > length + 1) {
		endSCol = 0;
		++endSRow;
	    }
	}
d1893 2
a1894 2
	if (endSCol && XTERM_CELL(endSRow, endSCol) == HIDDEN_CHAR)
	    endSCol++;
d1897 37
a1933 40
	saveStartWRow = startSRow;
	saveStartWCol = startSCol;
	break;
    case SELECTLINE:
	while (ScrnTstWrapped(screen, endSRow)) {
	    ++endSRow;
	}
	if (term->screen.cutToBeginningOfLine
	    || startSRow < saveStartWRow) {
	    startSCol = 0;
	    while (ScrnTstWrapped(screen, startSRow - 1)) {
		--startSRow;
	    }
	} else if (!extend) {
	    if ((startRow < saveStartWRow)
		|| (startRow == saveStartWRow
		    && startCol < saveStartWCol)) {
		startSCol = 0;
		while (ScrnTstWrapped(screen, startSRow - 1)) {
		    --startSRow;
		}
	    } else {
		startSRow = saveStartWRow;
		startSCol = saveStartWCol;
	    }
	}
	if (term->screen.cutNewline) {
	    endSCol = 0;
	    ++endSRow;
	} else {
	    endSCol = LastTextCol(endSRow) + 1;
	}
	break;
    }

    /* check boundaries */
    ScrollSelection(screen, 0);

    TrackText(startSRow, startSCol, endSRow, endSCol);
    return;
d1937 5
a1941 4
TrackText(int frow,
	  int fcol,
	  int trow,
	  int tcol)
d1944 35
a1978 38
    int from, to;
    TScreen *screen = &term->screen;
    int old_startrow, old_startcol, old_endrow, old_endcol;

    TRACE(("TrackText(frow=%d, fcol=%d, trow=%d, tcol=%d)\n",
	   frow, fcol, trow, tcol));

    old_startrow = screen->startHRow;
    old_startcol = screen->startHCol;
    old_endrow = screen->endHRow;
    old_endcol = screen->endHCol;
    if (frow == old_startrow && fcol == old_startcol &&
	trow == old_endrow && tcol == old_endcol)
	return;
    screen->startHRow = frow;
    screen->startHCol = fcol;
    screen->endHRow = trow;
    screen->endHCol = tcol;
    from = Coordinate(frow, fcol);
    to = Coordinate(trow, tcol);
    if (to <= screen->startHCoord || from > screen->endHCoord) {
	/* No overlap whatsoever between old and new hilite */
	ReHiliteText(old_startrow, old_startcol, old_endrow, old_endcol);
	ReHiliteText(frow, fcol, trow, tcol);
    } else {
	if (from < screen->startHCoord) {
	    /* Extend left end */
	    ReHiliteText(frow, fcol, old_startrow, old_startcol);
	} else if (from > screen->startHCoord) {
	    /* Shorten left end */
	    ReHiliteText(old_startrow, old_startcol, frow, fcol);
	}
	if (to > screen->endHCoord) {
	    /* Extend right end */
	    ReHiliteText(old_endrow, old_endcol, trow, tcol);
	} else if (to < screen->endHCoord) {
	    /* Shorten right end */
	    ReHiliteText(trow, tcol, old_endrow, old_endcol);
d1980 2
a1981 3
    }
    screen->startHCoord = from;
    screen->endHCoord = to;
d1985 5
a1989 4
ReHiliteText(int frow,
	     int fcol,
	     int trow,
	     int tcol)
d1992 2
a1993 2
    TScreen *screen = &term->screen;
    int i;
d1995 13
a2007 13
    if (frow < 0)
	frow = fcol = 0;
    else if (frow > screen->max_row)
	return;			/* nothing to do, since trow >= frow */

    if (trow < 0)
	return;			/* nothing to do, since frow <= trow */
    else if (trow > screen->max_row) {
	trow = screen->max_row;
	tcol = screen->max_col + 1;
    }
    if (frow == trow && fcol == tcol)
	return;
d2009 12
a2020 6
    if (frow != trow) {		/* do multiple rows */
	if ((i = screen->max_col - fcol + 1) > 0) {	/* first row */
	    ScrnRefresh(screen, frow, fcol, 1, i, True);
	}
	if ((i = trow - frow - 1) > 0) {	/* middle rows */
	    ScrnRefresh(screen, frow + 1, 0, i, screen->max_col + 1, True);
a2021 6
	if (tcol > 0 && trow <= screen->max_row) {	/* last row */
	    ScrnRefresh(screen, trow, 0, 1, tcol, True);
	}
    } else {			/* do single row */
	ScrnRefresh(screen, frow, fcol, 1, tcol - fcol, True);
    }
d2025 4
a2028 3
SaltTextAway(int crow, int ccol, int row, int col,
	     String * params,	/* selections */
	     Cardinal num_params)
d2032 2
a2033 2
    TScreen *screen = &term->screen;
    int i, j = 0;
d2035 1
a2035 1
    Char *line;
d2045 1
a2045 1
    /* first we need to know how long the string is before we can save it */
d2047 1
a2047 1
    if (row == crow) {
d2049 1
a2049 1
    } else {			/* two cases, cut is on same line, cut spans multiple lines */
d2058 1
a2058 3
    if_OPT_WIDE_CHARS(screen, {
	j *= 4;
    });
d2063 1
a2063 1
	if ((line = (Char *) malloc((unsigned) j + 1)) == 0)
d2065 1
a2065 1
	XtFree((char *) screen->selection_data);
d2073 1
a2073 1
	|| (j < 0))
d2077 2
a2078 2
    lp = line;			/* lp points to where to save the text */
    if (row == crow) {
d2083 2
a2084 2
	    *lp++ = '\n';	/* put in newline at end of line */
	for (i = crow + 1; i < row; i++) {
d2087 1
a2087 1
		*lp++ = '\n';
d2094 2
a2095 2
    TRACE(("Salted TEXT:%.*s\n", lp - line, line));
    screen->selection_length = (lp - line);
d2101 1
a2101 1
			Atom * type, XtPointer * value,
d2103 4
a2106 4
			int (*conversion_function) (Display *,
						    char **, int,
						    XICCEncodingStyle,
						    XTextProperty *),
d2109 1
a2109 1
    Display *d = XtDisplay(w);
d2116 1
a2116 1
    screen = &((XtermWidget) w)->screen;
d2118 1
a2118 1
    if (conversion_function(d, (char **) &screen->selection_data, 1,
d2129 1
d2131 8
a2138 7
ConvertSelection(Widget w,
		 Atom * selection,
		 Atom * target,
		 Atom * type,
		 XtPointer * value,
		 unsigned long *length,
		 int *format)
d2140 1
a2140 1
    Display *d = XtDisplay(w);
a2141 1
    Boolean result = False;
d2146 1
a2146 1
    screen = &((XtermWidget) w)->screen;
d2152 2
a2153 3
	Atom *targetP;
	Atom *std_targets;
	XPointer std_return = 0;
d2155 8
a2162 9
	if (XmuConvertStandardSelection(w, screen->selection_time, selection,
					target, type, &std_return,
					&std_length, format)) {
	    std_targets = (Atom *) (std_return);
	    *length = std_length + 6;
	    targetP = (Atom *) XtMalloc(sizeof(Atom) * (*length));
	    *value = (XtPointer) targetP;
	    *targetP++ = XA_STRING;
	    *targetP++ = XA_TEXT(d);
d2164 2
a2165 2
	    *targetP++ = XA_COMPOUND_TEXT(d);
	    *targetP++ = XA_UTF8_STRING(d);
d2167 13
a2179 14
	    *targetP = XA_COMPOUND_TEXT(d);
	    if_OPT_WIDE_CHARS(screen, {
		*targetP = XA_UTF8_STRING(d);
	    });
	    targetP++;
#endif
	    *targetP++ = XA_LENGTH(d);
	    *targetP++ = XA_LIST_LENGTH(d);
	    memcpy(targetP, std_targets, sizeof(Atom) * std_length);
	    XtFree((char *) std_targets);
	    *type = XA_ATOM;
	    *format = 32;
	    result = True;
	}
d2181 2
d2184 2
a2185 2
    else if (screen->wide_chars && *target == XA_STRING) {
	result =
d2190 4
a2193 3
    } else if (screen->wide_chars && *target == XA_UTF8_STRING(d)) {
	result =
	    _ConvertSelectionHelper(w,
d2197 3
a2199 2
    } else if (screen->wide_chars && *target == XA_TEXT(d)) {
	result =
d2204 3
a2206 2
    } else if (screen->wide_chars && *target == XA_COMPOUND_TEXT(d)) {
	result =
d2214 1
a2214 1
    else if (*target == XA_STRING) {	/* not wide_chars */
d2217 1
a2217 1
	   UTF8_STRING.  We therefore assume that the requestor is not
d2225 5
a2229 3
	result = True;
    } else if (*target == XA_TEXT(d)) {		/* not wide_chars */
	result =
d2234 4
a2237 2
    } else if (*target == XA_COMPOUND_TEXT(d)) {	/* not wide_chars */
	result =
d2243 1
d2245 2
a2246 2
    else if (*target == XA_UTF8_STRING(d)) {	/* not wide_chars */
	result =
d2253 2
a2254 1
    else if (*target == XA_LIST_LENGTH(d)) {
d2257 1
a2257 1
	     *(long *) *value = 1;
d2260 1
a2260 1
	    memcpy((char *) *value, ((char *) &temp) + sizeof(long) - 4, 4);
d2265 4
a2268 2
	result = True;
    } else if (*target == XA_LENGTH(d)) {
d2272 1
a2272 1
	     *(long *) *value = screen->selection_length;
d2275 1
a2275 1
	    memcpy((char *) *value, ((char *) &temp) + sizeof(long) - 4, 4);
d2280 1
a2280 6
	result = True;
    } else if (XmuConvertStandardSelection(w,
					   screen->selection_time, selection,
					   target, type, (XPointer *) value,
					   length, format)) {
	result = True;
d2283 5
d2289 1
a2289 1
    return result;
d2292 1
d2294 1
a2294 1
LoseSelection(Widget w, Atom * selection)
d2296 2
a2297 2
    TScreen *screen;
    Atom *atomP;
d2303 1
a2303 1
    screen = &((XtermWidget) w)->screen;
d2305 3
a2307 3
	 i < screen->selection_count; i++, atomP++) {
	if (*selection == *atomP)
	    *atomP = (Atom) 0;
d2309 8
a2316 9
	case XA_CUT_BUFFER0:
	case XA_CUT_BUFFER1:
	case XA_CUT_BUFFER2:
	case XA_CUT_BUFFER3:
	case XA_CUT_BUFFER4:
	case XA_CUT_BUFFER5:
	case XA_CUT_BUFFER6:
	case XA_CUT_BUFFER7:
	    *atomP = (Atom) 0;
d2321 1
a2321 2
	if (screen->selection_atoms[i - 1] != 0)
	    break;
d2326 3
a2328 2
	 i < screen->selection_count; i++, atomP++) {
	if (*atomP == (Atom) 0) {
d2337 1
d2339 4
a2342 4
static void
SelectionDone(Widget w GCC_UNUSED,
	      Atom * selection GCC_UNUSED,
	      Atom * target GCC_UNUSED)
d2347 1
d2349 4
a2352 3
_OwnSelection(XtermWidget termw,
	      String * selections,
	      Cardinal count)
d2354 1
a2354 1
    Atom *atoms = termw->screen.selection_atoms;
d2358 1
a2358 2
    if (termw->screen.selection_length < 0)
	return;
d2361 2
a2362 2
	XtFree((char *) atoms);
	atoms = (Atom *) XtMalloc(count * sizeof(Atom));
d2366 1
a2366 1
    XmuInternStrings(XtDisplay((Widget) termw), selections, count, atoms);
d2370 9
a2378 26
	case XA_CUT_BUFFER0:
	    cutbuffer = 0;
	    break;
	case XA_CUT_BUFFER1:
	    cutbuffer = 1;
	    break;
	case XA_CUT_BUFFER2:
	    cutbuffer = 2;
	    break;
	case XA_CUT_BUFFER3:
	    cutbuffer = 3;
	    break;
	case XA_CUT_BUFFER4:
	    cutbuffer = 4;
	    break;
	case XA_CUT_BUFFER5:
	    cutbuffer = 5;
	    break;
	case XA_CUT_BUFFER6:
	    cutbuffer = 6;
	    break;
	case XA_CUT_BUFFER7:
	    cutbuffer = 7;
	    break;
	default:
	    cutbuffer = -1;
d2381 2
a2382 2
	    if (termw->screen.selection_length >
		4 * XMaxRequestSize(XtDisplay((Widget) termw)) - 32) {
d2393 1
a2393 1
		Char *data = termw->screen.selection_data;
d2396 3
a2398 4
		});
		TRACE(("XStoreBuffer(%d)\n", cutbuffer));
		XStoreBuffer(XtDisplay((Widget) termw),
			     (char *) data, length, cutbuffer);
d2402 3
a2404 3
		XtOwnSelection((Widget) termw, atoms[i],
			       termw->screen.selection_time,
			       ConvertSelection, LoseSelection, SelectionDone);
d2414 1
a2414 1
DisownSelection(XtermWidget termw)
d2416 1
a2416 1
    Atom *atoms = termw->screen.selection_atoms;
d2423 9
a2431 26
	case XA_CUT_BUFFER0:
	    cutbuffer = 0;
	    break;
	case XA_CUT_BUFFER1:
	    cutbuffer = 1;
	    break;
	case XA_CUT_BUFFER2:
	    cutbuffer = 2;
	    break;
	case XA_CUT_BUFFER3:
	    cutbuffer = 3;
	    break;
	case XA_CUT_BUFFER4:
	    cutbuffer = 4;
	    break;
	case XA_CUT_BUFFER5:
	    cutbuffer = 5;
	    break;
	case XA_CUT_BUFFER6:
	    cutbuffer = 6;
	    break;
	case XA_CUT_BUFFER7:
	    cutbuffer = 7;
	    break;
	default:
	    cutbuffer = -1;
d2434 2
a2435 2
	    XtDisownSelection((Widget) termw, atoms[i],
			      termw->screen.selection_time);
d2442 1
d2446 11
a2456 10
Length(TScreen * screen GCC_UNUSED,
       int row,
       int scol,
       int ecol)
{
    int lastcol = LastTextCol(row);

    if (ecol > lastcol)
	ecol = lastcol;
    return (ecol - scol + 1);
d2461 7
a2467 6
SaveText(TScreen * screen,
	 int row,
	 int scol,
	 int ecol,
	 Char * lp,		/* pointer to where to put the text */
	 int *eol)
d2516 2
a2517 1
	} else
d2543 1
a2543 1
    return (result);
d2547 1
a2547 1
BtnCode(XButtonEvent * event, int button)
d2549 1
a2549 1
    int result = 32 + (KeyState(event->state) << 2);
d2551 10
a2560 10
    if (button < 0 || button > 5) {
	result += 3;
    } else {
	if (button > 3)
	    result += (64 - 4);
	if (event->type == MotionNotify)
	    result += 32;
	result += button;
    }
    return result;
d2566 1
a2566 1
EditorButton(XButtonEvent * event)
d2568 37
a2604 38
    TScreen *screen = &term->screen;
    int pty = screen->respond;
    Char line[6];
    int row, col;
    int button, count = 0;

    /* If button event, get button # adjusted for DEC compatibility */
    button = event->button - 1;
    if (button >= 3)
	button++;

    /* Compute character position of mouse pointer */
    row = (event->y - screen->border) / FontHeight(screen);
    col = (event->x - OriginX(screen)) / FontWidth(screen);

    /* Limit to screen dimensions */
    if (row < 0)
	row = 0;
    else if (row > screen->max_row)
	row = screen->max_row;
    else if (row > MOUSE_LIMIT)
	row = MOUSE_LIMIT;

    if (col < 0)
	col = 0;
    else if (col > screen->max_col)
	col = screen->max_col;
    else if (col > MOUSE_LIMIT)
	col = MOUSE_LIMIT;

    /* Build key sequence starting with \E[M */
    if (screen->control_eight_bits) {
	line[count++] = CSI;
    } else {
	line[count++] = ESC;
	line[count++] = '[';
    }
    line[count++] = 'M';
d2606 32
a2637 25
    /* Add event code to key sequence */
    if (screen->send_mouse_pos == X10_MOUSE) {
	line[count++] = ' ' + button;
    } else {
	/* Button-Motion events */
	switch (event->type) {
	case ButtonPress:
	    line[count++] = BtnCode(event, screen->mouse_button = button);
	    break;
	case ButtonRelease:
	    /*
	     * Wheel mouse interface generates release-events for buttons
	     * 4 and 5, coded here as 3 and 4 respectively.  We change the
	     * release for buttons 1..3 to a -1.
	     */
	    if (button < 3)
		button = -1;
	    line[count++] = BtnCode(event, screen->mouse_button = button);
	    break;
	case MotionNotify:
	    /* BTN_EVENT_MOUSE and ANY_EVENT_MOUSE modes send motion
	     * events only if character cell has changed.
	     */
	    if ((row == screen->mouse_row)
		&& (col == screen->mouse_col))
d2639 1
a2639 4
	    line[count++] = BtnCode(event, screen->mouse_button);
	    break;
	default:
	    return;
a2640 1
    }
d2642 2
a2643 2
    screen->mouse_row = row;
    screen->mouse_col = col;
d2645 3
a2647 3
    /* Add pointer position to key sequence */
    line[count++] = ' ' + col + 1;
    line[count++] = ' ' + row + 1;
d2649 2
a2650 2
    TRACE(("mouse at %d,%d button+mask = %#x\n", row, col,
	   (screen->control_eight_bits) ? line[2] : line[3]));
d2652 2
a2653 2
    /* Transmit key sequence to process running under xterm */
    v_write(pty, line, count);
d2656 1
d2659 5
a2663 5
void
HandleGINInput(Widget w GCC_UNUSED,
	       XEvent * event GCC_UNUSED,
	       String * param_list,
	       Cardinal * nparamsp)
d2668 2
a2669 6
	case 'l':
	case 'm':
	case 'r':
	case 'L':
	case 'M':
	case 'R':
d2671 3
a2673 3
	default:
	    Bell(XkbBI_MinorError, 0);	/* let them know they goofed */
	    c = 'l';		/* provide a default */
d2675 1
a2675 1
	TekEnqMouse(c | 0x80);
d2678 1
a2678 1
	Bell(XkbBI_MinorError, 0);
d2683 1
d2685 5
a2689 5
void
HandleSecure(Widget w GCC_UNUSED,
	     XEvent * event,	/* unused */
	     String * params GCC_UNUSED,	/* [0] = volume */
	     Cardinal * param_count GCC_UNUSED)		/* 0 or 1 */
d2699 1
a2699 1
    DoSecureKeyboard(ev_time);
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d3 1
a3 1
 * Copyright 1999-2001,2002 by Thomas E. Dickey
d53 1
a53 1
/* $XFree86: xc/programs/xterm/button.c,v 3.71 2002/10/05 17:57:11 dickey Exp $ */
a75 1
#include <charclass.h>
d78 1
d103 3
a105 3
       shift key -> 1
       meta key  -> 2
       control key -> 4 */
a138 9

#if OPT_READLINE
static Time lastButtonDownTime = 0;
static int ExtendingSelection = 0;
static Time lastButton3UpTime = 0;
static Time lastButton3DoubleDownTime = 0;
static int lastButton3row, lastButton3col;	/* At the release time */
#endif /* OPT_READLINE */

a139 1

d149 10
a158 14
static Char *SaveText(TScreen * screen, int row, int scol, int ecol, Char *
		      lp, int *eol);
static int Length(TScreen * screen, int row, int scol, int ecol);
static void ComputeSelect(int startRow, int startCol, int endRow, int
			  endCol, Bool extend);
static void EditorButton(XButtonEvent * event);
static void EndExtend(Widget w, XEvent * event, String * params, Cardinal
		      num_params, Bool use_cursor_loc);
static void ExtendExtend(int row, int col);
static void PointToRowCol(int y, int x, int *r, int *c);
static void ReHiliteText(int frow, int fcol, int trow, int tcol);
static void SaltTextAway(int crow, int ccol, int row, int col, String *
			 params, Cardinal num_params);
static void SelectSet(Widget w, XEvent * event, String * params, Cardinal num_params);
d160 3
a162 5
static void StartSelect(int startrow, int startcol);
static void TrackDown(XButtonEvent * event);
static void _OwnSelection(XtermWidget termw, String * selections, Cardinal count);
static void do_select_end(Widget w, XEvent * event, String * params,
			  Cardinal * num_params, Bool use_cursor_loc);
d164 1
a164 2
Boolean
SendMousePosition(Widget w, XEvent * event)
d171 1
a171 1
    screen = &((XtermWidget) w)->screen;
d179 1
a179 1
	return (SendLocatorPosition(w, event));
d181 1
a181 1
#endif /* OPT_DEC_LOCATOR */
d185 3
a187 3
	&& (screen->send_mouse_pos != ANY_EVENT_MOUSE)
	&& event->type != ButtonPress
	&& event->type != ButtonRelease)
d191 1
a191 1
    case X10_MOUSE:		/* X10 compatibility sequences */
d195 1
a195 1
		EditorButton((XButtonEvent *) event);
d200 5
a204 5
    case VT200_HIGHLIGHT_MOUSE:	/* DEC vt200 hilite tracking */
	if (event->type == ButtonPress &&
	    KeyModifiers == 0 &&
	    event->xbutton.button == Button1) {
	    TrackDown((XButtonEvent *) event);
d208 1
a208 1
	    EditorButton((XButtonEvent *) event);
d213 1
a213 1
    case VT200_MOUSE:		/* DEC vt200 compatible */
d215 4
a218 4
	/* xterm extension for motion reporting. June 1998 */
	/* EditorButton() will distinguish between the modes */
    case BTN_EVENT_MOUSE:
    case ANY_EVENT_MOUSE:
d220 1
a220 1
	    EditorButton((XButtonEvent *) event);
d225 1
a225 1
    default:
d268 1
a268 1
SendLocatorPosition(Widget w, XEvent * event)
d270 5
a274 5
    TScreen *screen = &((XtermWidget) w)->screen;
    int row, col;
    Boolean oor;
    int button;
    int state;
d281 1
a281 1
	return (False);
d287 1
a287 1
	return (True);
d289 3
a291 3
    if (event->type == MotionNotify) {
	CheckLocatorPosition(w, event);
	return (True);
d297 1
a297 1
    LocatorCoords(row, col, event->xbutton.x, event->xbutton.y, oor);
d300 5
a304 5
     * DECterm mouse:
     *
     * ESCAPE '[' event ; mask ; row ; column '&' 'w'
     */
    reply.a_type = CSI;
d306 1
a306 1
    if (oor) {
d308 1
a308 1
	reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
d310 1
a310 1
	reply.a_final = 'w';
d313 2
a314 2
	if (screen->locator_reset) {
	    MotionOff(screen, term);
d317 1
a317 1
	return (True);
d321 11
a331 11
     * event:
     *        1       no buttons
     *        2       left button down
     *        3       left button up
     *        4       middle button down
     *        5       middle button up
     *        6       right button down
     *        7       right button up
     *        8       M4 down
     *        9       M4 up
     */
d333 10
a342 9
    switch (event->type) {
    case ButtonPress:
	reply.a_param[0] = 2 + (button << 1);
	break;
    case ButtonRelease:
	reply.a_param[0] = 3 + (button << 1);
	break;
    default:
	return (True);
d345 9
a353 10
     * mask:
     * bit 7   bit 6   bit 5   bit 4   bit 3   bit 2       bit 1         bit 0
     *                                 M4 down left down   middle down   right down
     *
     * Notice that Button1 (left) and Button3 (right) are swapped in the mask.
     * Also, mask should be the state after the button press/release,
     * X provides the state not including the button press/release.
     */
    state = (event->xbutton.state
	     & (Button1Mask | Button2Mask | Button3Mask | Button4Mask)) >> 8;
d355 1
a355 1
    state = (state & ~(4 | 1)) | ((state & 1) ? 4 : 0) | ((state & 4) ? 1 : 0);		/* swap Button1 & Button3 */
d361 1
a361 1
    reply.a_final = 'w';
d365 2
a366 2
    if (screen->locator_reset) {
	MotionOff(screen, term);
d371 4
a374 4
     * DECterm turns the Locator off if a button is pressed while a filter rectangle
     * is active. This might be a bug, but I don't know, so I'll emulate it anyways.
     */
    if (screen->loc_filter) {
d378 1
a378 1
	MotionOff(screen, term);
d381 1
a381 1
    return (True);
d385 6
a390 6
 * mask:
 * bit 7   bit 6   bit 5   bit 4   bit 3   bit 2       bit 1         bit 0
 *                                 M4 down left down   middle down   right down
 *
 * Button1 (left) and Button3 (right) are swapped in the mask relative to X.
 */
d400 8
a407 8
    TScreen *screen = &w->screen;
    Window root, child;
    int rx, ry, x, y;
    unsigned int mask;
    int row = 0, col = 0;
    Boolean oor = FALSE;
    Bool ret = FALSE;
    int state;
d410 4
a413 4
     * DECterm turns the Locator off if the position is requested while a filter rectangle
     * is active.  This might be a bug, but I don't know, so I'll emulate it anyways.
     */
    if (screen->loc_filter) {
d417 1
a417 1
	MotionOff(screen, term);
d420 1
a420 1
    reply.a_type = CSI;
d423 2
a424 2
	ret = XQueryPointer(screen->display, VWindow(screen), &root,
			    &child, &rx, &ry, &x, &y, &mask);
d426 1
a426 1
	    LocatorCoords(row, col, x, y, oor);
d429 2
a430 1
    if (ret == FALSE || oor) {
d432 1
a432 1
	reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
d434 1
a434 1
	reply.a_final = 'w';
d437 2
a438 2
	if (screen->locator_reset) {
	    MotionOff(screen, term);
d444 1
a444 1
    ButtonState(state, mask);
d447 1
a447 1
    reply.a_param[0] = 1;	/* Event - 1 = response to locator request */
d452 1
a452 1
    reply.a_final = 'w';
d455 2
a456 2
    if (screen->locator_reset) {
	MotionOff(screen, term);
d462 1
a462 1
InitLocatorFilter(XtermWidget w)
d464 8
a471 8
    TScreen *screen = &w->screen;
    Window root, child;
    int rx, ry, x, y;
    unsigned int mask;
    int row = 0, col = 0;
    Boolean oor = 0;
    Bool ret;
    int state;
d473 2
a474 2
    ret = XQueryPointer(screen->display, VWindow(screen),
			&root, &child, &rx, &ry, &x, &y, &mask);
d476 1
a476 1
	LocatorCoords(row, col, x, y, oor);
d478 2
a479 1
    if (ret == FALSE || oor) {
d482 2
a483 2
	if (screen->loc_filter_top != LOC_FILTER_POS ||
	    screen->loc_filter_left != LOC_FILTER_POS ||
d485 2
a486 1
	    screen->loc_filter_right != LOC_FILTER_POS) {
d488 4
a491 4
	     * If any explicit coordinates were received,
	     * report immediately with no coordinates.
	     */
	    reply.a_type = CSI;
d493 1
a493 1
	    reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
d495 1
a495 1
	    reply.a_final = 'w';
d498 2
a499 2
	    if (screen->locator_reset) {
		MotionOff(screen, term);
d504 3
a506 3
	     * No explicit coordinates were received, and the pointer is
	     * unavailable.  Report when the pointer re-enters the window.
	     */
d508 1
a508 1
	    MotionOn(screen, term);
d514 8
a521 8
     * Adjust rectangle coordinates:
     *  1. Replace "LOC_FILTER_POS" with current coordinates
     *  2. Limit coordinates to screen size
     *  3. make sure top and left are less than bottom and right, resp.
     */
    if (screen->locator_pixels) {
	rx = OriginX(screen) * 2 + Width(screen);
	ry = screen->border * 2 + Height(screen);
d532 4
a535 4
    Adjust(screen->loc_filter_top, row, ry);
    Adjust(screen->loc_filter_left, col, rx);
    Adjust(screen->loc_filter_bottom, row, ry);
    Adjust(screen->loc_filter_right, col, rx);
d537 1
a537 1
    if (screen->loc_filter_top > screen->loc_filter_bottom) {
d543 1
a543 1
    if (screen->loc_filter_left > screen->loc_filter_right) {
d549 1
a549 1
    if ((col < screen->loc_filter_left) ||
d552 2
a553 1
	(row > screen->loc_filter_bottom)) {
d555 1
a555 1
	ButtonState(state, mask);
d557 1
a557 1
	reply.a_type = CSI;
d559 1
a559 1
	reply.a_param[0] = 10;	/* Event - 10 = locator outside filter */
d564 1
a564 1
	reply.a_final = 'w';
d567 2
a568 2
	if (screen->locator_reset) {
	    MotionOff(screen, term);
d575 3
a577 3
     * Rectangle is set up.  Allow pointer tracking
     * to detect if the mouse leaves the rectangle.
     */
d579 1
a579 1
    MotionOn(screen, term);
d583 1
a583 1
CheckLocatorPosition(Widget w, XEvent * event)
d585 4
a588 4
    TScreen *screen = &((XtermWidget) w)->screen;
    int row, col;
    Boolean oor;
    int state;
d590 1
a590 1
    LocatorCoords(row, col, event->xbutton.x, event->xbutton.y, oor);
d593 4
a596 4
     * Send report if the pointer left the filter rectangle, if
     * the pointer left the window, or if the filter rectangle
     * had no coordinates and the pointer re-entered the window.
     */
d598 1
a598 1
	(col < screen->loc_filter_left) ||
d600 3
a602 2
	(row < screen->loc_filter_top) ||
	(row > screen->loc_filter_bottom)) {
d605 1
a605 1
	MotionOff(screen, term);
d607 1
a607 1
	reply.a_type = CSI;
d610 1
a610 1
	    reply.a_param[0] = 0;	/* Event - 0 = locator unavailable */
d612 1
a612 1
	    ButtonState(state, event->xbutton.state);
d615 1
a615 1
	    reply.a_param[0] = 10;	/* Event - 10 = locator outside filter */
d622 1
a622 1
	reply.a_final = 'w';
d625 2
a626 2
	if (screen->locator_reset) {
	    MotionOff(screen, term);
d631 1
a631 62
#endif /* OPT_DEC_LOCATOR */

#if OPT_READLINE
static int
isClick1_clean(XEvent * event)
{
    TScreen *screen = &term->screen;
    int delta;

    if (!(event->type == ButtonPress || event->type == ButtonRelease)
    /* Disable on Shift-Click-1, including the application-mouse modes */
	|| (KeyModifiers & ShiftMask)
	|| (screen->send_mouse_pos != MOUSE_OFF)	/* Kinda duplicate... */
	||ExtendingSelection)	/* Was moved */
	return 0;
    if (event->type != ButtonRelease)
	return 0;
    if (lastButtonDownTime == (Time) 0)		/* first time or once in a blue moon */
	delta = term->screen.multiClickTime + 1;
    else if (event->xbutton.time > lastButtonDownTime)	/* most of the time */
	delta = event->xbutton.time - lastButtonDownTime;
    else			/* time has rolled over since lastButtonUpTime */
	delta = (((Time) ~ 0) - lastButtonDownTime) + event->xbutton.time;
    return delta <= term->screen.multiClickTime;
}

static int
isDoubleClick3(XEvent * event)
{
    int delta;

    if (event->type != ButtonRelease
	|| (KeyModifiers & ShiftMask)
	|| event->xbutton.button != Button3) {
	lastButton3UpTime = 0;	/* Disable the cached info */
	return 0;
    }
    /* Process Btn3Release. */
    if (lastButton3DoubleDownTime == (Time) 0)	/* No previous click
						   or once in a blue moon */
	delta = term->screen.multiClickTime + 1;
    else if (event->xbutton.time > lastButton3DoubleDownTime)	/* most of the time */
	delta = event->xbutton.time - lastButton3DoubleDownTime;
    else			/* time has rolled over since lastButton3DoubleDownTime */
	delta = (((Time) ~ 0) - lastButton3DoubleDownTime) + event->xbutton.time;
    if (delta <= term->screen.multiClickTime) {
	/* Double click */
	int row, col;

	/* Cannot check ExtendingSelection, since mouse-3 always sets it */
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
	if (row == lastButton3row && col == lastButton3col) {
	    lastButton3DoubleDownTime = 0;	/* Disable the third click */
	    return 1;
	}
    }
    /* Not a double click, memorize for future check. */
    lastButton3UpTime = event->xbutton.time;
    PointToRowCol(event->xbutton.y, event->xbutton.x,
		  &lastButton3row, &lastButton3col);
    return 0;
}
a632 116
static int
CheckSecondPress3(XEvent * event)
{
    int delta, row, col;

    if (event->type != ButtonPress
	|| (KeyModifiers & ShiftMask)
	|| event->xbutton.button != Button3) {
	lastButton3DoubleDownTime = 0;	/* Disable the cached info */
	return 0;
    }
    /* Process Btn3Press. */
    if (lastButton3UpTime == (Time) 0)	/* No previous click
					   or once in a blue moon */
	delta = term->screen.multiClickTime + 1;
    else if (event->xbutton.time > lastButton3UpTime)	/* most of the time */
	delta = event->xbutton.time - lastButton3UpTime;
    else			/* time has rolled over since lastButton3UpTime */
	delta = (((Time) ~ 0) - lastButton3UpTime) + event->xbutton.time;
    if (delta <= term->screen.multiClickTime) {
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
	if (row == lastButton3row && col == lastButton3col) {
	    /* A candidate for a double-click */
	    lastButton3DoubleDownTime = event->xbutton.time;
	    PointToRowCol(event->xbutton.y, event->xbutton.x,
			  &lastButton3row, &lastButton3col);
	    return 1;
	}
	lastButton3UpTime = 0;	/* Disable the info about the previous click */
    }
    /* Either too long, or moved, disable. */
    lastButton3DoubleDownTime = 0;
    return 0;
}

static int
rowOnCurrentLine(int line, int *deltap)		/* must be XButtonEvent */
{
    TScreen *screen = &term->screen;
    int l1, l2;

    *deltap = 0;
    if (line == screen->cur_row)
	return 1;

    if (line < screen->cur_row)
	l1 = line, l2 = screen->cur_row;
    else
	l2 = line, l1 = screen->cur_row;
    l1--;
    while (++l1 < l2)
	if (!ScrnTstWrapped(screen, l1))
	    return 0;
    /* Everything is on one "wrapped line" now */
    *deltap = line - screen->cur_row;
    return 1;
}

static int
eventRow(XEvent * event)	/* must be XButtonEvent */
{
    TScreen *screen = &term->screen;

    return (event->xbutton.y - screen->border) / FontHeight(screen);
}

static int
eventColBetween(XEvent * event)	/* must be XButtonEvent */
{
    TScreen *screen = &term->screen;

    /* Correct by half a width - we are acting on a boundary, not on a cell. */
    return ((event->xbutton.x - OriginX(screen) + (FontWidth(screen) - 1) / 2)
	    / FontWidth(screen));
}

static int
ReadLineMovePoint(int col, int ldelta)
{
    TScreen *screen = &term->screen;
    Char line[6];
    int count = 0;

    col += ldelta * (screen->max_col + 1) - screen->cur_col;
    if (col == 0)
	return 0;
    if (screen->control_eight_bits) {
	line[count++] = CSI;
    } else {
	line[count++] = ESC;
	line[count++] = '[';	/* XXX maybe sometimes O is better? */
    }
    line[count++] = (col > 0 ? 'C' : 'D');
    if (col < 0)
	col = -col;
    while (col--)
	v_write(screen->respond, line, 3);
    return 1;
}

static int
ReadLineDelete(int r1, int c1, int r2, int c2)
{
    TScreen *screen = &term->screen;
    int del;

    del = c2 - c1 + (r2 - r1) * (screen->max_col + 1);
    if (del <= 0)		/* Just in case... */
	return 0;
    while (del--)
	v_write(screen->respond, "\177", 1);	/* XXX Sometimes "\08"? */
    return 1;
}
#endif /* OPT_READLINE */

/* ^XM-G<line+' '><col+' '> */
d634 9
a642 8
DiredButton(Widget w GCC_UNUSED,
	    XEvent * event,	/* must be XButtonEvent */
	    String * params GCC_UNUSED,		/* selections */
	    Cardinal * num_params GCC_UNUSED)
{
    TScreen *screen = &term->screen;
    Char Line[6];
    unsigned line, col;
d645 2
a646 2
	line = (event->xbutton.y - screen->border) / FontHeight(screen);
	col = (event->xbutton.x - OriginX(screen)) / FontWidth(screen);
d652 1
a652 1
	v_write(screen->respond, Line, 5);
a655 1
#if OPT_READLINE
d657 7
a663 66
ReadLineButton(Widget w GCC_UNUSED,
	       XEvent * event,	/* must be XButtonEvent */
	       String * params GCC_UNUSED,	/* selections */
	       Cardinal * num_params GCC_UNUSED)
{
    TScreen *screen = &term->screen;
    Char Line[6];
    int line, col, ldelta = 0;

    if (!(event->type == ButtonPress || event->type == ButtonRelease)
	|| (screen->send_mouse_pos != MOUSE_OFF) || ExtendingSelection)
	goto finish;
    if (event->type == ButtonRelease) {
	int delta;

	if (lastButtonDownTime == (Time) 0)	/* first time and once in a blue moon */
	    delta = screen->multiClickTime + 1;
	else if (event->xbutton.time > lastButtonDownTime)	/* most of the time */
	    delta = event->xbutton.time - lastButtonDownTime;
	else			/* time has rolled over since lastButtonUpTime */
	    delta = (((Time) ~ 0) - lastButtonDownTime) + event->xbutton.time;
	if (delta > screen->multiClickTime)
	    goto finish;	/* All this work for this... */
    }
    line = (event->xbutton.y - screen->border) / FontHeight(screen);
    if (line != screen->cur_row) {
	int l1, l2;

	if (line < screen->cur_row)
	    l1 = line, l2 = screen->cur_row;
	else
	    l2 = line, l1 = screen->cur_row;
	l1--;
	while (++l1 < l2)
	    if (!ScrnTstWrapped(screen, l1))
		goto finish;
	/* Everything is on one "wrapped line" now */
	ldelta = line - screen->cur_row;
    }
    /* Correct by half a width - we are acting on a boundary, not on a cell. */
    col = (event->xbutton.x - OriginX(screen) + (FontWidth(screen) - 1) / 2)
	/ FontWidth(screen) - screen->cur_col + ldelta * (screen->max_col + 1);
    if (col == 0)
	goto finish;
    Line[0] = ESC;
    /* XXX: sometimes it is better to send '['? */
    Line[1] = 'O';
    Line[2] = (col > 0 ? 'C' : 'D');
    if (col < 0)
	col = -col;
    while (col--)
	v_write(screen->respond, Line, 3);
  finish:
    if (event->type == ButtonRelease)
	do_select_end(w, event, params, num_params, False);
}
#endif /* OPT_READLINE */

/* repeats <ESC>n or <ESC>p */
void
ViButton(Widget w GCC_UNUSED,
	 XEvent * event,	/* must be XButtonEvent */
	 String * params GCC_UNUSED,	/* selections */
	 Cardinal * num_params GCC_UNUSED)
{
    TScreen *screen = &term->screen;
d665 2
a666 2
    Char Line[6];
    int line;
d671 1
a671 1
	    ((event->xbutton.y - screen->border) / FontHeight(screen));
d674 1
a674 1
	    v_write(pty, Line, 1);
d676 1
a676 1
	    if (line < 0) {
d682 2
a683 2
	    while (--line >= 0)
		v_write(pty, Line, 1);
d688 1
d693 5
a697 5
void
HandleSelectExtend(Widget w,
		   XEvent * event,	/* must be XMotionEvent */
		   String * params GCC_UNUSED,
		   Cardinal * num_params GCC_UNUSED)
d699 2
a700 2
    TScreen *screen;
    int row, col;
d702 2
a703 2
    if (!IsXtermWidget(w))
	return;
d705 20
a724 20
    screen = &((XtermWidget) w)->screen;
    screen->selection_time = event->xmotion.time;
    switch (eventMode) {
	/* If not in one of the DEC mouse-reporting modes */
    case LEFTEXTENSION:
    case RIGHTEXTENSION:
	PointToRowCol(event->xmotion.y, event->xmotion.x,
		      &row, &col);
	ExtendExtend(row, col);
	break;

	/* If in motion reporting mode, send mouse position to
	   character process as a key sequence \E[M... */
    case NORMAL:
	/* will get here if send_mouse_pos != MOUSE_OFF */
	if (screen->send_mouse_pos == BTN_EVENT_MOUSE
	    || screen->send_mouse_pos == ANY_EVENT_MOUSE)
	    SendMousePosition(w, event);
	break;
    }
d727 9
a735 14
static void
do_select_end(Widget w,
	      XEvent * event,	/* must be XButtonEvent */
	      String * params,	/* selections */
	      Cardinal * num_params,
	      Bool use_cursor_loc)
{
#if OPT_READLINE
    int ldelta1, ldelta2;
    TScreen *screen = &term->screen;
#endif

    if (!IsXtermWidget(w))
	return;
d737 9
a745 20
    ((XtermWidget) w)->screen.selection_time = event->xbutton.time;
    switch (eventMode) {
    case NORMAL:
	(void) SendMousePosition(w, event);
	break;
    case LEFTEXTENSION:
    case RIGHTEXTENSION:
	EndExtend(w, event, params, *num_params, use_cursor_loc);
#if OPT_READLINE
	if (isClick1_clean(event)
	    && SCREEN_FLAG(screen, click1_moves)
	    && rowOnCurrentLine(eventRow(event), &ldelta1)) {
	    ReadLineMovePoint(eventColBetween(event), ldelta1);
	}
	if (isDoubleClick3(event)
	    && SCREEN_FLAG(screen, dclick3_deletes)
	    && rowOnCurrentLine(startSRow, &ldelta1)
	    && rowOnCurrentLine(endSRow, &ldelta2)) {
	    ReadLineMovePoint(endSCol, ldelta2);
	    ReadLineDelete(startSRow, startSCol, endSRow, endSCol);
a746 3
#endif /* OPT_READLINE */
	break;
    }
d749 6
a754 5
void
HandleSelectEnd(Widget w,
		XEvent * event,	/* must be XButtonEvent */
		String * params,	/* selections */
		Cardinal * num_params)
d756 1
a756 1
    do_select_end(w, event, params, num_params, False);
d759 6
a764 5
void
HandleKeyboardSelectEnd(Widget w,
			XEvent * event,		/* must be XButtonEvent */
			String * params,	/* selections */
			Cardinal * num_params)
d766 1
a766 1
    do_select_end(w, event, params, num_params, True);
d781 1
a781 1
UTF8toLatin1(Char * s, int len, unsigned long *result)
d790 1
a790 1
	buffer = (Char *) XtMalloc(used = len);
d792 1
a792 1
	buffer = (Char *) XtRealloc((char *) buffer, used = len);
d796 2
a797 2
    /* We're assuming that the xterm widget never contains Unicode
       control characters. */
d819 72
d900 1
a900 1
    if (!IsXtermWidget(w))
d903 1
a903 1
    screen = &((XtermWidget) w)->screen;
d910 1
a910 1
	    utf8SelectionTargets = (Atom *) XtMalloc(5 * sizeof(Atom));
d916 1
a916 1
	    utf8SelectionTargets[n++] = XA_UTF8_STRING(XtDisplay(w));
d919 2
a920 2
		utf8SelectionTargets[n++] = XA_TEXT(XtDisplay(w));
		utf8SelectionTargets[n++] = XA_COMPOUND_TEXT(XtDisplay(w));
d923 1
a923 1
	    utf8SelectionTargets[n++] = XA_STRING;
d932 1
a932 1
	eightBitSelectionTargets = (Atom *) XtMalloc(5 * sizeof(Atom));
d939 1
a939 1
	eightBitSelectionTargets[n++] = XA_UTF8_STRING(XtDisplay(w));
d942 2
a943 2
	    eightBitSelectionTargets[n++] = XA_TEXT(XtDisplay(w));
	    eightBitSelectionTargets[n++] = XA_COMPOUND_TEXT(XtDisplay(w));
d945 1
a945 1
	eightBitSelectionTargets[n++] = XA_STRING;
d951 6
a956 6
static void
_GetSelection(Widget w,
	      Time ev_time,
	      String * params,	/* selections in precedence order */
	      Cardinal num_params,
	      Atom * targets)
d965 1
a965 1
    XmuInternStrings(XtDisplay(w), params, (Cardinal) 1, &selection);
d967 10
a976 26
    case XA_CUT_BUFFER0:
	cutbuffer = 0;
	break;
    case XA_CUT_BUFFER1:
	cutbuffer = 1;
	break;
    case XA_CUT_BUFFER2:
	cutbuffer = 2;
	break;
    case XA_CUT_BUFFER3:
	cutbuffer = 3;
	break;
    case XA_CUT_BUFFER4:
	cutbuffer = 4;
	break;
    case XA_CUT_BUFFER5:
	cutbuffer = 5;
	break;
    case XA_CUT_BUFFER6:
	cutbuffer = 6;
	break;
    case XA_CUT_BUFFER7:
	cutbuffer = 7;
	break;
    default:
	cutbuffer = -1;
d979 1
a979 1
	   targets ? (unsigned long) targets[0] : 0));
d988 1
a988 1
	    SelectionReceived(w, NULL, &selection, &type, (XtPointer) line,
d991 1
a991 1
	    _GetSelection(w, ev_time, params + 1, num_params - 1, NULL);
d994 1
a994 1
	struct _SelectionList *list;
d1003 1
a1003 1
	    if (targets[1] == None) {	/* last target in list */
d1017 1
a1017 2
	    } else
		list = NULL;
d1022 1
a1022 1
				(XtPointer) list, ev_time);
d1028 1
a1028 2
static void
GettingSelection(Display * dpy, Atom type, Char * line, int len)
d1035 1
a1035 1
    Trace("Getting %s (%ld)\n", XGetAtomName(dpy, type), (long int) type);
d1040 1
a1040 1
#define GettingSelection(dpy,type,line,len)	/* nothing */
d1043 1
a1043 6
#ifdef VMS
#  define tty_vwrite(pty,lag,l)		tt_write(lag,l)
#else /* !( VMS ) */
#  define tty_vwrite(pty,lag,l)		v_write(pty,lag,l)
#endif /* defined VMS */

d1045 1
a1045 1
_qWriteSelectionData(TScreen * screen, Char * lag, int length)
d1047 13
a1059 5
#if OPT_READLINE
    if (SCREEN_FLAG(screen, paste_quotes)) {
	while (length--) {
	    tty_vwrite(screen->respond, "\026", 1);	/* Control-V */
	    tty_vwrite(screen->respond, lag++, 1);
d1061 4
a1064 3
    } else
#endif
	tty_vwrite(screen->respond, lag, length);
d1067 2
d1070 1
a1070 1
_WriteSelectionData(TScreen * screen, Char * line, int length)
a1071 6
    /* Write data to pty a line at a time. */
    /* Doing this one line at a time may no longer be necessary
       because v_write has been re-written. */

    Char *lag, *cp, *end;

d1076 3
a1078 1
#ifdef VMS
a1079 1
#endif
d1083 5
a1087 7
    if (!SCREEN_FLAG(screen, paste_literal_nl)) {
	for (cp = line; cp != end; cp++) {
	    if (*cp == '\n') {
		*cp = '\r';
		_qWriteSelectionData(screen, lag, cp - lag + 1);
		lag = cp + 1;
	    }
d1091 1
a1091 1
	_qWriteSelectionData(screen, lag, end - lag);
d1093 1
a1093 1
#ifdef VMS
d1095 1
a1095 21
    tt_start_read();		/* reenable reads or a character may be lost */
#endif
}

#if OPT_READLINE
static void
_WriteKey(TScreen * screen, Char * in)
{
    char line[16];
    int count = 0, length = strlen(in);

    if (screen->control_eight_bits) {
	line[count++] = CSI;
    } else {
	line[count++] = ESC;
	line[count++] = '[';
    }
    while (length--)
	line[count++] = *in++;
    line[count++] = '~';
    tty_vwrite(screen->respond, line, count);
d1097 1
a1097 1
#endif /* OPT_READLINE */
d1102 8
a1109 8
static void
SelectionReceived(Widget w,
		  XtPointer client_data,
		  Atom * selection GCC_UNUSED,
		  Atom * type,
		  XtPointer value,
		  unsigned long *length,
		  int *format GCC_UNUSED)
d1117 1
a1117 1
    Char *line = (Char *) value;
d1122 1
a1122 1
    screen = &((XtermWidget) w)->screen;
d1125 1
a1125 3
    if (*type == 0		/*XT_CONVERT_FAIL */
	|| *length == 0
	|| value == NULL)
d1128 1
a1128 1
    text_prop.value = (unsigned char *) value;
d1134 1
a1134 1
    if (screen->wide_chars) {
d1136 2
a1137 2
	    *type == XA_STRING ||
	    *type == XA_COMPOUND_TEXT(XtDisplay(w))) {
d1139 3
a1141 3
	    if (Xutf8TextPropertyToTextList(dpy, &text_prop,
					    &text_list,
					    &text_list_count) < 0) {
d1151 4
a1154 4
	/* There's no need to special-case UTF8_STRING.  If Xlib
	   doesn't know about it, we didn't request it.  If a broken
	   selection holder sends it anyhow, the conversion function
	   will fail. */
d1157 3
a1159 3
	    *type == XA_STRING ||
	    *type == XA_COMPOUND_TEXT(XtDisplay(w))) {
	    Status rc;
d1161 1
a1161 1
	    if (*type == XA_STRING && screen->brokenSelections) {
d1164 6
a1169 6
	    } else {
		rc = XmbTextPropertyToTextList(dpy, &text_prop,
					       &text_list,
					       &text_list_count);
	    }
	    if (rc < 0) {
d1176 1
a1176 1
    if (text_list != NULL && text_list_count != 0) {
d1178 1
a1178 6

#if OPT_READLINE
	if (SCREEN_FLAG(screen, paste_brackets))
	    _WriteKey(screen, "200");
#endif
	for (i = 0; i < text_list_count; i++) {
d1180 2
a1181 1
	    _WriteSelectionData(screen, (Char *) text_list[i], len);
a1182 4
#if OPT_READLINE
	if (SCREEN_FLAG(screen, paste_brackets))
	    _WriteKey(screen, "201");
#endif
d1187 2
a1188 2
    XtFree((char *) client_data);
    XtFree((char *) value);
d1194 1
a1194 1
	struct _SelectionList *list = (struct _SelectionList *) client_data;
d1197 1
a1197 1
	XtFree((char *) client_data);
d1202 1
d1204 5
a1208 4
HandleInsertSelection(Widget w,
		      XEvent * event,	/* assumed to be XButtonEvent* */
		      String * params,	/* selections in precedence order */
		      Cardinal * num_params)
d1210 1
a1210 18
#if OPT_READLINE
    int ldelta;
    TScreen *screen = &((XtermWidget) w)->screen;
#endif

    if (SendMousePosition(w, event))
	return;

#if OPT_READLINE
    if ((event->type == ButtonPress || event->type == ButtonRelease)
    /* Disable on Shift-mouse, including the application-mouse modes */
	&& !(KeyModifiers & ShiftMask)
	&& (screen->send_mouse_pos == MOUSE_OFF)
	&& SCREEN_FLAG(screen, paste_moves)
	&& rowOnCurrentLine(eventRow(event), &ldelta))
	ReadLineMovePoint(eventColBetween(event), ldelta);
#endif /* OPT_READLINE */

d1219 1
a1219 1
    if (lastButtonUpTime == (Time) 0)	/* first time and once in a blue moon */
d1221 1
a1221 1
    else if (buttonDownTime > lastButtonUpTime)		/* most of the time */
d1223 2
a1224 2
    else			/* time has rolled over since lastButtonUpTime */
	delta = (((Time) ~ 0) - lastButtonUpTime) + buttonDownTime;
d1235 10
a1244 16
static void
do_select_start(Widget w,
		XEvent * event,	/* must be XButtonEvent* */
		int startrow,
		int startcol)
{
    if (SendMousePosition(w, event))
	return;
    selectUnit = EvalSelectUnit(event->xbutton.time, SELECTCHAR);
    replyToEmacs = FALSE;

#if OPT_READLINE
    lastButtonDownTime = event->xbutton.time;
#endif

    StartSelect(startrow, startcol);
d1249 5
a1253 4
HandleSelectStart(Widget w,
		  XEvent * event,	/* must be XButtonEvent* */
		  String * params GCC_UNUSED,
		  Cardinal * num_params GCC_UNUSED)
d1255 2
a1256 2
    TScreen *screen;
    int startrow, startcol;
d1258 2
a1259 2
    if (!IsXtermWidget(w))
	return;
d1261 6
a1266 8
    screen = &((XtermWidget) w)->screen;
    firstValidRow = 0;
    lastValidRow = screen->max_row;
    PointToRowCol(event->xbutton.y, event->xbutton.x, &startrow, &startcol);

#if OPT_READLINE
    ExtendingSelection = 0;
#endif
a1267 2
    do_select_start(w, event, startrow, startcol);
}
d1271 5
a1275 4
HandleKeyboardSelectStart(Widget w,
			  XEvent * event,	/* must be XButtonEvent* */
			  String * params GCC_UNUSED,
			  Cardinal * num_params GCC_UNUSED)
d1277 1
a1277 1
    TScreen *screen;
d1279 2
a1280 2
    if (!IsXtermWidget(w))
	return;
d1282 2
a1283 2
    screen = &((XtermWidget) w)->screen;
    do_select_start(w, event, screen->cursor_row, screen->cursor_col);
d1286 1
d1288 1
a1288 1
TrackDown(XButtonEvent * event)
d1290 1
a1290 1
    int startrow, startcol;
d1292 9
a1300 9
    selectUnit = EvalSelectUnit(event->time, SELECTCHAR);
    if (numberOfClicks > 1) {
	PointToRowCol(event->y, event->x, &startrow, &startcol);
	replyToEmacs = TRUE;
	StartSelect(startrow, startcol);
    } else {
	waitingForTrackInfo = 1;
	EditorButton((XButtonEvent *) event);
    }
d1303 1
d1312 1
a1312 1
    TScreen *screen = &term->screen;
d1314 8
a1321 9
    if (!waitingForTrackInfo) {	/* Timed out, so ignore */
	return;
    }
    waitingForTrackInfo = 0;
    if (func == 0)
	return;
    boundsCheck(startrow)
	boundsCheck(firstrow)
	boundsCheck(lastrow)
d1323 3
a1325 3
    lastValidRow = lastrow;
    replyToEmacs = TRUE;
    StartSelect(startrow, startcol);
d1331 1
a1331 1
    TScreen *screen = &term->screen;
d1333 24
a1356 24
    TRACE(("StartSelect row=%d, col=%d\n", startrow, startcol));
    if (screen->cursor_state)
	HideCursor();
    if (numberOfClicks == 1) {
	/* set start of selection */
	rawRow = startrow;
	rawCol = startcol;

    }
    /* else use old values in rawRow, Col */
    saveStartRRow = startERow = rawRow;
    saveStartRCol = startECol = rawCol;
    saveEndRRow = endERow = rawRow;
    saveEndRCol = endECol = rawCol;
    if (Coordinate(startrow, startcol) < Coordinate(rawRow, rawCol)) {
	eventMode = LEFTEXTENSION;
	startERow = startrow;
	startECol = startcol;
    } else {
	eventMode = RIGHTEXTENSION;
	endERow = startrow;
	endECol = startcol;
    }
    ComputeSelect(startERow, startECol, endERow, endECol, False);
d1361 47
a1407 45
EndExtend(Widget w,
	  XEvent * event,	/* must be XButtonEvent */
	  String * params,	/* selections */
	  Cardinal num_params,
	  Bool use_cursor_loc)
{
    int row, col, count;
    TScreen *screen = &term->screen;
    Char line[9];

    if (use_cursor_loc) {
	row = screen->cursor_row;
	col = screen->cursor_col;
    } else {
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
    }
    ExtendExtend(row, col);
    lastButtonUpTime = event->xbutton.time;
    if (startSRow != endSRow || startSCol != endSCol) {
	if (replyToEmacs) {
	    count = 0;
	    if (screen->control_eight_bits) {
		line[count++] = CSI;
	    } else {
		line[count++] = ESC;
		line[count++] = '[';
	    }
	    if (rawRow == startSRow && rawCol == startSCol
		&& row == endSRow && col == endSCol) {
		/* Use short-form emacs select */
		line[count++] = 't';
		line[count++] = ' ' + endSCol + 1;
		line[count++] = ' ' + endSRow + 1;
	    } else {
		/* long-form, specify everything */
		line[count++] = 'T';
		line[count++] = ' ' + startSCol + 1;
		line[count++] = ' ' + startSRow + 1;
		line[count++] = ' ' + endSCol + 1;
		line[count++] = ' ' + endSRow + 1;
		line[count++] = ' ' + col + 1;
		line[count++] = ' ' + row + 1;
	    }
	    v_write(screen->respond, line, count);
	    TrackText(0, 0, 0, 0);
d1409 2
a1410 3
    }
    SelectSet(w, event, params, num_params);
    eventMode = NORMAL;
d1414 5
a1418 4
HandleSelectSet(Widget w,
		XEvent * event,
		String * params,
		Cardinal * num_params)
d1420 1
a1420 1
    SelectSet(w, event, params, *num_params);
d1425 12
a1436 11
SelectSet(Widget w GCC_UNUSED,
	  XEvent * event GCC_UNUSED,
	  String * params,
	  Cardinal num_params)
{
    /* Only do select stuff if non-null select */
    if (startSRow != endSRow || startSCol != endSCol) {
	SaltTextAway(startSRow, startSCol, endSRow, endSCol,
		     params, num_params);
    } else
	DisownSelection(term);
d1442 6
a1447 6
static void
do_start_extend(Widget w,
		XEvent * event,	/* must be XButtonEvent* */
		String * params GCC_UNUSED,
		Cardinal * num_params GCC_UNUSED,
		Bool use_cursor_loc)
d1449 2
a1450 2
    TScreen *screen;
    int row, col, coord;
d1452 2
a1453 2
    if (!IsXtermWidget(w))
	return;
d1455 4
a1458 10
    screen = &((XtermWidget) w)->screen;
    if (SendMousePosition(w, event))
	return;
    firstValidRow = 0;
    lastValidRow = screen->max_row;
#if OPT_READLINE
    if ((KeyModifiers & ShiftMask)
	|| event->xbutton.button != Button3
	|| !(SCREEN_FLAG(screen, dclick3_deletes)))
#endif
d1460 1
a1460 1
    replyToEmacs = FALSE;
d1462 13
a1474 3
#if OPT_READLINE
    CheckSecondPress3(event);
#endif
d1476 8
a1483 15
    if (numberOfClicks == 1
	|| (SCREEN_FLAG(screen, dclick3_deletes)	/* Dclick special */
	    &&!(KeyModifiers & ShiftMask))) {
	/* Save existing selection so we can reestablish it if the guy
	   extends past the other end of the selection */
	saveStartRRow = startERow = startRRow;
	saveStartRCol = startECol = startRCol;
	saveEndRRow = endERow = endRRow;
	saveEndRCol = endECol = endRCol;
    } else {
	/* He just needed the selection mode changed, use old values. */
	startERow = startRRow = saveStartRRow;
	startECol = startRCol = saveStartRCol;
	endERow = endRRow = saveEndRRow;
	endECol = endRCol = saveEndRCol;
d1485 14
a1498 28
    }
    if (use_cursor_loc) {
	row = screen->cursor_row;
	col = screen->cursor_col;
    } else {
	PointToRowCol(event->xbutton.y, event->xbutton.x, &row, &col);
    }
    coord = Coordinate(row, col);

    if (Abs(coord - Coordinate(startSRow, startSCol))
	< Abs(coord - Coordinate(endSRow, endSCol))
	|| coord < Coordinate(startSRow, startSCol)) {
	/* point is close to left side of selection */
	eventMode = LEFTEXTENSION;
	startERow = row;
	startECol = col;
    } else {
	/* point is close to left side of selection */
	eventMode = RIGHTEXTENSION;
	endERow = row;
	endECol = col;
    }
    ComputeSelect(startERow, startECol, endERow, endECol, True);

#if OPT_READLINE
    if (startSRow != endSRow || startSCol != endSCol)
	ExtendingSelection = 1;
#endif
d1502 27
a1528 26
ExtendExtend(int row, int col)
{
    int coord = Coordinate(row, col);

    TRACE(("ExtendExtend row=%d, col=%d\n", row, col));
    if (eventMode == LEFTEXTENSION
	&& (coord + (selectUnit != SELECTCHAR)) > Coordinate(endSRow, endSCol)) {
	/* Whoops, he's changed his mind.  Do RIGHTEXTENSION */
	eventMode = RIGHTEXTENSION;
	startERow = saveStartRRow;
	startECol = saveStartRCol;
    } else if (eventMode == RIGHTEXTENSION
	       && coord < Coordinate(startSRow, startSCol)) {
	/* Whoops, he's changed his mind.  Do LEFTEXTENSION */
	eventMode = LEFTEXTENSION;
	endERow = saveEndRRow;
	endECol = saveEndRCol;
    }
    if (eventMode == LEFTEXTENSION) {
	startERow = row;
	startECol = col;
    } else {
	endERow = row;
	endECol = col;
    }
    ComputeSelect(startERow, startECol, endERow, endECol, False);
a1529 5
#if OPT_READLINE
    if (startSRow != endSRow || startSCol != endSCol)
	ExtendingSelection = 1;
#endif
}
d1531 5
a1535 5
void
HandleStartExtend(Widget w,
		  XEvent * event,	/* must be XButtonEvent* */
		  String * params,	/* unused */
		  Cardinal * num_params)	/* unused */
d1537 1
a1537 1
    do_start_extend(w, event, params, num_params, False);
d1540 5
a1544 5
void
HandleKeyboardStartExtend(Widget w,
			  XEvent * event,	/* must be XButtonEvent* */
			  String * params,	/* unused */
			  Cardinal * num_params)	/* unused */
d1546 1
a1546 1
    do_start_extend(w, event, params, num_params, True);
d1550 1
a1550 1
ScrollSelection(TScreen * screen, int amount)
d1552 3
a1554 3
    int minrow = -screen->savedlines - screen->topline;
    int maxrow = screen->max_row - screen->topline;
    int maxcol = screen->max_col;
d1568 1
a1568 1
    scroll_update_one(endRRow, endRCol);
d1570 1
a1570 1
    scroll_update_one(endSRow, endSCol);
d1575 1
a1575 1
    scroll_update_one(screen->endHRow, screen->endHCol);
d1577 2
a1578 2
    screen->startHCoord = Coordinate(screen->startHRow, screen->startHCol);
    screen->endHCoord = Coordinate(screen->endHRow, screen->endHCol);
d1581 1
d1584 1
a1584 1
ResizeSelection(TScreen * screen GCC_UNUSED, int rows, int cols)
d1586 1
a1586 1
    rows--;			/* decr to get 0-max */
d1589 11
a1599 21
    if (startRRow > rows)
	startRRow = rows;
    if (startSRow > rows)
	startSRow = rows;
    if (endRRow > rows)
	endRRow = rows;
    if (endSRow > rows)
	endSRow = rows;
    if (rawRow > rows)
	rawRow = rows;

    if (startRCol > cols)
	startRCol = cols;
    if (startSCol > cols)
	startSCol = cols;
    if (endRCol > cols)
	endRCol = cols;
    if (endSCol > cols)
	endSCol = cols;
    if (rawCol > cols)
	rawCol = cols;
d1603 1
a1603 2
int
iswide(int i)
d1610 5
a1614 4
PointToRowCol(int y,
	      int x,
	      int *r,
	      int *c)
d1620 2
a1621 2
    TScreen *screen = &term->screen;
    int row, col;
d1623 11
a1633 11
    row = (y - screen->border) / FontHeight(screen);
    if (row < firstValidRow)
	row = firstValidRow;
    else if (row > lastValidRow)
	row = lastValidRow;
    col = (x - OriginX(screen)) / FontWidth(screen);
    if (col < 0)
	col = 0;
    else if (col > screen->max_col + 1) {
	col = screen->max_col + 1;
    }
d1635 9
a1643 9
    /*
     * If we got a click on the right half of a doublewidth character,
     * pretend it happened on the left half.
     */
    if (col > 0
	&& iswide(XTERM_CELL(row, col - 1))
	&& (XTERM_CELL(row, col) == HIDDEN_CHAR)) {
	col -= 1;
    }
d1645 2
a1646 2
    *r = row;
    *c = col;
d1650 1
a1650 1
LastTextCol(int row)
d1652 10
a1661 9
    TScreen *screen = &term->screen;
    int i;
    Char *ch;

    if ((row += screen->topline) + screen->savedlines >= 0) {
	for (i = screen->max_col,
	     ch = SCRN_BUF_ATTRS(screen, row) + i;
	     i >= 0 && !(*ch & CHARDRAWN);
	     ch--, i--) ;
d1663 6
a1668 2
	if (CSET_DOUBLE(SCRN_BUF_CSETS(screen, row)[0])) {
	    i *= 2;
d1670 1
a1670 5
#endif
    } else {
	i = -1;
    }
    return (i);
d1684 1
a1684 3
/* *INDENT-OFF* */
static int charClass[256] =
{
d1686 1
a1686 1
    32,  1,    1,   1,   1,   1,   1,   1,
d1718 1
a1718 1
    1,    1,   1,   1,   1,   1,   1,   1,
d1720 1
a1720 1
    1,    1,   1,   1,   1,   1,   1,   1,
d1722 1
a1722 1
    1,    1,   1,   1,   1,   1,   1,   1,
d1724 1
a1724 1
    1,    1,   1,   1,   1,   1,   1,   1,
d1726 1
a1726 1
    160, 161, 162, 163, 164, 165, 166, 167,
d1728 1
a1728 1
    168, 169, 170, 171, 172, 173, 174, 175,
d1730 1
a1730 1
    176, 177, 178, 179, 180, 181, 182, 183,
d1732 1
a1732 1
    184, 185, 186, 187, 188, 189, 190, 191,
d1734 1
a1734 1
     48,  48,  48,  48,  48,  48,  48,  48,
d1736 1
a1736 1
     48,  48,  48,  48,  48,  48,  48,  48,
d1738 1
a1738 1
     48,  48,  48,  48,  48,  48,  48, 215,
d1740 1
a1740 1
     48,  48,  48,  48,  48,  48,  48,  48,
d1742 1
a1742 1
     48,  48,  48,  48,  48,  48,  48,  48,
d1744 1
a1744 1
     48,  48,  48,  48,  48,  48,  48,  48,
d1746 1
a1746 1
     48,  48,  48,  48,  48,  48,  48, 247,
d1748 1
a1748 2
     48,  48,  48,  48,  48,  48,  48,  48};
/* *INDENT-ON* */
d1750 4
a1753 4
int
SetCharacterClassRange(int low,	/* in range of [0..255] */
		       int high,
		       int value)	/* arbitrary */
d1756 1
a1756 2
    if (low < 0 || high > 255 || high < low)
	return (-1);
d1758 1
a1758 2
    for (; low <= high; low++)
	charClass[low] = value;
d1765 1
a1765 2
static int
class_of(TScreen * screen, int row, int col)
d1776 1
a1776 1
    });
d1792 1
d1794 10
a1803 12
ComputeSelect(int startRow,
	      int startCol,
	      int endRow,
	      int endCol,
	      Bool extend)
{
    TScreen *screen = &term->screen;
    int length;
    int cclass;

    TRACE(("ComputeSelect(startRow=%d, startCol=%d, endRow=%d, endCol=%d, %sextend)\n",
	   startRow, startCol, endRow, endCol, extend ? "" : "no"));
d1806 12
a1817 13
    if (startCol > 1
	&& iswide(XTERM_CELL(startRow, startCol - 1))
	&& XTERM_CELL(startRow, startCol - 0) == HIDDEN_CHAR) {
	fprintf(stderr, "Adjusting start. Changing downwards from %i.\n", startCol);
	startCol -= 1;
	if (endCol == (startCol + 1))
	    endCol--;
    }

    if (iswide(XTERM_CELL(endRow, endCol - 1))
	&& XTERM_CELL(endRow, endCol) == HIDDEN_CHAR) {
	endCol += 1;
    }
d1820 40
a1859 40
    if (Coordinate(startRow, startCol) <= Coordinate(endRow, endCol)) {
	startSRow = startRRow = startRow;
	startSCol = startRCol = startCol;
	endSRow = endRRow = endRow;
	endSCol = endRCol = endCol;
    } else {			/* Swap them */
	startSRow = startRRow = endRow;
	startSCol = startRCol = endCol;
	endSRow = endRRow = startRow;
	endSCol = endRCol = startCol;
    }

    switch (selectUnit) {
    case SELECTCHAR:
	if (startSCol > (LastTextCol(startSRow) + 1)) {
	    startSCol = 0;
	    startSRow++;
	}
	if (endSCol > (LastTextCol(endSRow) + 1)) {
	    endSCol = 0;
	    endSRow++;
	}
	break;
    case SELECTWORD:
	if (startSCol > (LastTextCol(startSRow) + 1)) {
	    startSCol = 0;
	    startSRow++;
	} else {
	    cclass = class_of(screen, startSRow, startSCol);
	    do {
		--startSCol;
		if (startSCol < 0
		    && ScrnTstWrapped(screen, startSRow - 1)) {
		    --startSRow;
		    startSCol = LastTextCol(startSRow);
		}
	    } while (startSCol >= 0
		     && ClassSelects(screen, startSRow, startSCol, cclass));
	    ++startSCol;
	}
d1862 2
a1863 2
	if (startSCol && XTERM_CELL(startSRow, startSCol) == HIDDEN_CHAR)
	    startSCol++;
d1866 25
a1890 25
	if (endSCol > (LastTextCol(endSRow) + 1)) {
	    endSCol = 0;
	    endSRow++;
	} else {
	    length = LastTextCol(endSRow);
	    cclass = class_of(screen, endSRow, endSCol);
	    do {
		++endSCol;
		if (endSCol > length
		    && ScrnTstWrapped(screen, endSRow)) {
		    endSCol = 0;
		    ++endSRow;
		    length = LastTextCol(endSRow);
		}
	    } while (endSCol <= length
		     && ClassSelects(screen, endSRow, endSCol, cclass));
	    /* Word select selects if pointing to any char
	       in "word", especially in that it includes
	       the last character in a word.  So no --endSCol
	       and do special eol handling */
	    if (endSCol > length + 1) {
		endSCol = 0;
		++endSRow;
	    }
	}
d1893 2
a1894 2
	if (endSCol && XTERM_CELL(endSRow, endSCol) == HIDDEN_CHAR)
	    endSCol++;
d1897 37
a1933 40
	saveStartWRow = startSRow;
	saveStartWCol = startSCol;
	break;
    case SELECTLINE:
	while (ScrnTstWrapped(screen, endSRow)) {
	    ++endSRow;
	}
	if (term->screen.cutToBeginningOfLine
	    || startSRow < saveStartWRow) {
	    startSCol = 0;
	    while (ScrnTstWrapped(screen, startSRow - 1)) {
		--startSRow;
	    }
	} else if (!extend) {
	    if ((startRow < saveStartWRow)
		|| (startRow == saveStartWRow
		    && startCol < saveStartWCol)) {
		startSCol = 0;
		while (ScrnTstWrapped(screen, startSRow - 1)) {
		    --startSRow;
		}
	    } else {
		startSRow = saveStartWRow;
		startSCol = saveStartWCol;
	    }
	}
	if (term->screen.cutNewline) {
	    endSCol = 0;
	    ++endSRow;
	} else {
	    endSCol = LastTextCol(endSRow) + 1;
	}
	break;
    }

    /* check boundaries */
    ScrollSelection(screen, 0);

    TrackText(startSRow, startSCol, endSRow, endSCol);
    return;
d1937 5
a1941 4
TrackText(int frow,
	  int fcol,
	  int trow,
	  int tcol)
d1944 35
a1978 38
    int from, to;
    TScreen *screen = &term->screen;
    int old_startrow, old_startcol, old_endrow, old_endcol;

    TRACE(("TrackText(frow=%d, fcol=%d, trow=%d, tcol=%d)\n",
	   frow, fcol, trow, tcol));

    old_startrow = screen->startHRow;
    old_startcol = screen->startHCol;
    old_endrow = screen->endHRow;
    old_endcol = screen->endHCol;
    if (frow == old_startrow && fcol == old_startcol &&
	trow == old_endrow && tcol == old_endcol)
	return;
    screen->startHRow = frow;
    screen->startHCol = fcol;
    screen->endHRow = trow;
    screen->endHCol = tcol;
    from = Coordinate(frow, fcol);
    to = Coordinate(trow, tcol);
    if (to <= screen->startHCoord || from > screen->endHCoord) {
	/* No overlap whatsoever between old and new hilite */
	ReHiliteText(old_startrow, old_startcol, old_endrow, old_endcol);
	ReHiliteText(frow, fcol, trow, tcol);
    } else {
	if (from < screen->startHCoord) {
	    /* Extend left end */
	    ReHiliteText(frow, fcol, old_startrow, old_startcol);
	} else if (from > screen->startHCoord) {
	    /* Shorten left end */
	    ReHiliteText(old_startrow, old_startcol, frow, fcol);
	}
	if (to > screen->endHCoord) {
	    /* Extend right end */
	    ReHiliteText(old_endrow, old_endcol, trow, tcol);
	} else if (to < screen->endHCoord) {
	    /* Shorten right end */
	    ReHiliteText(trow, tcol, old_endrow, old_endcol);
d1980 2
a1981 3
    }
    screen->startHCoord = from;
    screen->endHCoord = to;
d1985 5
a1989 4
ReHiliteText(int frow,
	     int fcol,
	     int trow,
	     int tcol)
d1992 2
a1993 2
    TScreen *screen = &term->screen;
    int i;
d1995 13
a2007 13
    if (frow < 0)
	frow = fcol = 0;
    else if (frow > screen->max_row)
	return;			/* nothing to do, since trow >= frow */

    if (trow < 0)
	return;			/* nothing to do, since frow <= trow */
    else if (trow > screen->max_row) {
	trow = screen->max_row;
	tcol = screen->max_col + 1;
    }
    if (frow == trow && fcol == tcol)
	return;
d2009 12
a2020 3
    if (frow != trow) {		/* do multiple rows */
	if ((i = screen->max_col - fcol + 1) > 0) {	/* first row */
	    ScrnRefresh(screen, frow, fcol, 1, i, True);
a2021 9
	if ((i = trow - frow - 1) > 0) {	/* middle rows */
	    ScrnRefresh(screen, frow + 1, 0, i, screen->max_col + 1, True);
	}
	if (tcol > 0 && trow <= screen->max_row) {	/* last row */
	    ScrnRefresh(screen, trow, 0, 1, tcol, True);
	}
    } else {			/* do single row */
	ScrnRefresh(screen, frow, fcol, 1, tcol - fcol, True);
    }
d2025 4
a2028 3
SaltTextAway(int crow, int ccol, int row, int col,
	     String * params,	/* selections */
	     Cardinal num_params)
d2032 2
a2033 2
    TScreen *screen = &term->screen;
    int i, j = 0;
d2045 1
a2045 1
    /* first we need to know how long the string is before we can save it */
d2047 1
a2047 1
    if (row == crow) {
d2049 1
a2049 1
    } else {			/* two cases, cut is on same line, cut spans multiple lines */
d2058 1
a2058 3
    if_OPT_WIDE_CHARS(screen, {
	j *= 4;
    });
d2063 1
a2063 1
	if ((line = (char *) malloc((unsigned) j + 1)) == 0)
d2073 1
a2073 1
	|| (j < 0))
d2077 2
a2078 2
    lp = (Char *) line;		/* lp points to where to save the text */
    if (row == crow) {
d2083 2
a2084 2
	    *lp++ = '\n';	/* put in newline at end of line */
	for (i = crow + 1; i < row; i++) {
d2087 1
a2087 1
		*lp++ = '\n';
d2094 2
a2095 2
    TRACE(("Salted TEXT:%.*s\n", (char *) lp - line, line));
    screen->selection_length = ((char *) lp - line);
d2101 1
a2101 1
			Atom * type, XtPointer * value,
d2103 4
a2106 4
			int (*conversion_function) (Display *,
						    char **, int,
						    XICCEncodingStyle,
						    XTextProperty *),
d2109 1
a2109 1
    Display *d = XtDisplay(w);
d2116 1
a2116 1
    screen = &((XtermWidget) w)->screen;
d2129 1
d2131 8
a2138 7
ConvertSelection(Widget w,
		 Atom * selection,
		 Atom * target,
		 Atom * type,
		 XtPointer * value,
		 unsigned long *length,
		 int *format)
d2140 1
a2140 1
    Display *d = XtDisplay(w);
d2146 1
a2146 1
    screen = &((XtermWidget) w)->screen;
d2152 2
a2153 2
	Atom *targetP;
	Atom *std_targets;
d2156 1
a2156 1
				    target, type, (XPointer *) & std_targets,
d2159 1
a2159 1
	targetP = (Atom *) XtMalloc(sizeof(Atom) * (*length));
d2170 1
a2170 1
	});
d2175 2
a2176 2
	memcpy((char *) targetP, (char *) std_targets, sizeof(Atom) * std_length);
	XtFree((char *) std_targets);
d2181 2
d2192 2
a2193 2
	return
	    _ConvertSelectionHelper(w,
d2214 1
a2214 1
    if (*target == XA_STRING) {	/* not wide_chars */
d2217 1
a2217 1
	   UTF8_STRING.  We therefore assume that the requestor is not
d2228 1
a2228 1
    if (*target == XA_TEXT(d)) {	/* not wide_chars */
d2236 1
a2236 1
    if (*target == XA_COMPOUND_TEXT(d)) {	/* not wide_chars */
d2243 1
d2245 1
a2245 1
    if (*target == XA_UTF8_STRING(d)) {		/* not wide_chars */
d2257 1
a2257 1
	     *(long *) *value = 1;
d2260 1
a2260 1
	    memcpy((char *) *value, ((char *) &temp) + sizeof(long) - 4, 4);
d2272 1
a2272 1
	     *(long *) *value = screen->selection_length;
d2275 1
a2275 1
	    memcpy((char *) *value, ((char *) &temp) + sizeof(long) - 4, 4);
d2284 1
a2284 1
				    target, type, (XPointer *) value,
d2292 1
d2294 1
a2294 1
LoseSelection(Widget w, Atom * selection)
d2296 2
a2297 2
    TScreen *screen;
    Atom *atomP;
d2303 1
a2303 1
    screen = &((XtermWidget) w)->screen;
d2305 3
a2307 3
	 i < screen->selection_count; i++, atomP++) {
	if (*selection == *atomP)
	    *atomP = (Atom) 0;
d2309 8
a2316 9
	case XA_CUT_BUFFER0:
	case XA_CUT_BUFFER1:
	case XA_CUT_BUFFER2:
	case XA_CUT_BUFFER3:
	case XA_CUT_BUFFER4:
	case XA_CUT_BUFFER5:
	case XA_CUT_BUFFER6:
	case XA_CUT_BUFFER7:
	    *atomP = (Atom) 0;
d2321 1
a2321 2
	if (screen->selection_atoms[i - 1] != 0)
	    break;
d2326 3
a2328 2
	 i < screen->selection_count; i++, atomP++) {
	if (*atomP == (Atom) 0) {
d2337 1
d2339 4
a2342 4
static void
SelectionDone(Widget w GCC_UNUSED,
	      Atom * selection GCC_UNUSED,
	      Atom * target GCC_UNUSED)
d2347 1
d2349 4
a2352 3
_OwnSelection(XtermWidget termw,
	      String * selections,
	      Cardinal count)
d2354 1
a2354 1
    Atom *atoms = termw->screen.selection_atoms;
d2358 1
a2358 2
    if (termw->screen.selection_length < 0)
	return;
d2361 2
a2362 2
	XtFree((char *) atoms);
	atoms = (Atom *) XtMalloc(count * sizeof(Atom));
d2366 1
a2366 1
    XmuInternStrings(XtDisplay((Widget) termw), selections, count, atoms);
d2370 9
a2378 26
	case XA_CUT_BUFFER0:
	    cutbuffer = 0;
	    break;
	case XA_CUT_BUFFER1:
	    cutbuffer = 1;
	    break;
	case XA_CUT_BUFFER2:
	    cutbuffer = 2;
	    break;
	case XA_CUT_BUFFER3:
	    cutbuffer = 3;
	    break;
	case XA_CUT_BUFFER4:
	    cutbuffer = 4;
	    break;
	case XA_CUT_BUFFER5:
	    cutbuffer = 5;
	    break;
	case XA_CUT_BUFFER6:
	    cutbuffer = 6;
	    break;
	case XA_CUT_BUFFER7:
	    cutbuffer = 7;
	    break;
	default:
	    cutbuffer = -1;
d2381 2
a2382 2
	    if (termw->screen.selection_length >
		4 * XMaxRequestSize(XtDisplay((Widget) termw)) - 32) {
d2393 1
a2393 1
		Char *data = (Char *) termw->screen.selection_data;
d2396 3
a2398 3
		});
		XStoreBuffer(XtDisplay((Widget) termw),
			     (char *) data, length, cutbuffer);
d2402 3
a2404 3
		XtOwnSelection((Widget) termw, atoms[i],
			       termw->screen.selection_time,
			       ConvertSelection, LoseSelection, SelectionDone);
d2414 1
a2414 1
DisownSelection(XtermWidget termw)
d2416 1
a2416 1
    Atom *atoms = termw->screen.selection_atoms;
d2423 9
a2431 26
	case XA_CUT_BUFFER0:
	    cutbuffer = 0;
	    break;
	case XA_CUT_BUFFER1:
	    cutbuffer = 1;
	    break;
	case XA_CUT_BUFFER2:
	    cutbuffer = 2;
	    break;
	case XA_CUT_BUFFER3:
	    cutbuffer = 3;
	    break;
	case XA_CUT_BUFFER4:
	    cutbuffer = 4;
	    break;
	case XA_CUT_BUFFER5:
	    cutbuffer = 5;
	    break;
	case XA_CUT_BUFFER6:
	    cutbuffer = 6;
	    break;
	case XA_CUT_BUFFER7:
	    cutbuffer = 7;
	    break;
	default:
	    cutbuffer = -1;
d2434 2
a2435 2
	    XtDisownSelection((Widget) termw, atoms[i],
			      termw->screen.selection_time);
d2442 1
d2446 11
a2456 10
Length(TScreen * screen GCC_UNUSED,
       int row,
       int scol,
       int ecol)
{
    int lastcol = LastTextCol(row);

    if (ecol > lastcol)
	ecol = lastcol;
    return (ecol - scol + 1);
d2461 7
a2467 6
SaveText(TScreen * screen,
	 int row,
	 int scol,
	 int ecol,
	 Char * lp,		/* pointer to where to put the text */
	 int *eol)
d2516 2
a2517 1
	} else
d2543 1
a2543 1
    return (result);
d2547 1
a2547 1
BtnCode(XButtonEvent * event, int button)
d2549 1
a2549 1
    int result = 32 + (KeyState(event->state) << 2);
d2551 10
a2560 10
    if (button < 0 || button > 5) {
	result += 3;
    } else {
	if (button > 3)
	    result += (64 - 4);
	if (event->type == MotionNotify)
	    result += 32;
	result += button;
    }
    return result;
d2566 1
a2566 1
EditorButton(XButtonEvent * event)
d2568 37
a2604 38
    TScreen *screen = &term->screen;
    int pty = screen->respond;
    Char line[6];
    int row, col;
    int button, count = 0;

    /* If button event, get button # adjusted for DEC compatibility */
    button = event->button - 1;
    if (button >= 3)
	button++;

    /* Compute character position of mouse pointer */
    row = (event->y - screen->border) / FontHeight(screen);
    col = (event->x - OriginX(screen)) / FontWidth(screen);

    /* Limit to screen dimensions */
    if (row < 0)
	row = 0;
    else if (row > screen->max_row)
	row = screen->max_row;
    else if (row > MOUSE_LIMIT)
	row = MOUSE_LIMIT;

    if (col < 0)
	col = 0;
    else if (col > screen->max_col)
	col = screen->max_col;
    else if (col > MOUSE_LIMIT)
	col = MOUSE_LIMIT;

    /* Build key sequence starting with \E[M */
    if (screen->control_eight_bits) {
	line[count++] = CSI;
    } else {
	line[count++] = ESC;
	line[count++] = '[';
    }
    line[count++] = 'M';
d2606 32
a2637 25
    /* Add event code to key sequence */
    if (screen->send_mouse_pos == X10_MOUSE) {
	line[count++] = ' ' + button;
    } else {
	/* Button-Motion events */
	switch (event->type) {
	case ButtonPress:
	    line[count++] = BtnCode(event, screen->mouse_button = button);
	    break;
	case ButtonRelease:
	    /*
	     * Wheel mouse interface generates release-events for buttons
	     * 4 and 5, coded here as 3 and 4 respectively.  We change the
	     * release for buttons 1..3 to a -1.
	     */
	    if (button < 3)
		button = -1;
	    line[count++] = BtnCode(event, screen->mouse_button = button);
	    break;
	case MotionNotify:
	    /* BTN_EVENT_MOUSE and ANY_EVENT_MOUSE modes send motion
	     * events only if character cell has changed.
	     */
	    if ((row == screen->mouse_row)
		&& (col == screen->mouse_col))
d2639 1
a2639 4
	    line[count++] = BtnCode(event, screen->mouse_button);
	    break;
	default:
	    return;
a2640 1
    }
d2642 2
a2643 2
    screen->mouse_row = row;
    screen->mouse_col = col;
d2645 3
a2647 3
    /* Add pointer position to key sequence */
    line[count++] = ' ' + col + 1;
    line[count++] = ' ' + row + 1;
d2649 2
a2650 2
    TRACE(("mouse at %d,%d button+mask = %#x\n", row, col,
	   (screen->control_eight_bits) ? line[2] : line[3]));
d2652 2
a2653 2
    /* Transmit key sequence to process running under xterm */
    v_write(pty, line, count);
d2656 1
d2659 5
a2663 5
void
HandleGINInput(Widget w GCC_UNUSED,
	       XEvent * event GCC_UNUSED,
	       String * param_list,
	       Cardinal * nparamsp)
d2668 2
a2669 6
	case 'l':
	case 'm':
	case 'r':
	case 'L':
	case 'M':
	case 'R':
d2671 3
a2673 3
	default:
	    Bell(XkbBI_MinorError, 0);	/* let them know they goofed */
	    c = 'l';		/* provide a default */
d2675 1
a2675 1
	TekEnqMouse(c | 0x80);
d2678 1
a2678 1
	Bell(XkbBI_MinorError, 0);
d2683 1
d2685 5
a2689 5
void
HandleSecure(Widget w GCC_UNUSED,
	     XEvent * event,	/* unused */
	     String * params GCC_UNUSED,	/* [0] = volume */
	     Cardinal * param_count GCC_UNUSED)		/* 0 or 1 */
d2699 1
a2699 1
    DoSecureKeyboard(ev_time);
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d3 1
a3 1
 * Copyright 1999-2002,2003 by Thomas E. Dickey
d53 1
a53 1
/* $XFree86: xc/programs/xterm/button.c,v 3.74 2003/09/21 17:12:45 dickey Exp $ */
d2336 1
a2336 1
    Char *line;
d2366 1
a2366 1
	if ((line = (Char *) malloc((unsigned) j + 1)) == 0)
d2368 1
a2368 1
	XtFree((char *) screen->selection_data);
d2380 1
a2380 1
    lp = line;			/* lp points to where to save the text */
d2397 2
a2398 2
    TRACE(("Salted TEXT:%.*s\n", lp - line, line));
    screen->selection_length = (lp - line);
d2421 1
a2421 1
    if (conversion_function(d, (char **) &screen->selection_data, 1,
a2442 1
    Boolean result = False;
a2454 1
	XPointer std_return = 0;
d2456 8
a2463 9
	if (XmuConvertStandardSelection(w, screen->selection_time, selection,
					target, type, &std_return,
					&std_length, format)) {
	    std_targets = (Atom *) (std_return);
	    *length = std_length + 6;
	    targetP = (Atom *) XtMalloc(sizeof(Atom) * (*length));
	    *value = (XtPointer) targetP;
	    *targetP++ = XA_STRING;
	    *targetP++ = XA_TEXT(d);
d2465 2
a2466 2
	    *targetP++ = XA_COMPOUND_TEXT(d);
	    *targetP++ = XA_UTF8_STRING(d);
d2468 13
a2480 14
	    *targetP = XA_COMPOUND_TEXT(d);
	    if_OPT_WIDE_CHARS(screen, {
		*targetP = XA_UTF8_STRING(d);
	    });
	    targetP++;
#endif
	    *targetP++ = XA_LENGTH(d);
	    *targetP++ = XA_LIST_LENGTH(d);
	    memcpy(targetP, std_targets, sizeof(Atom) * std_length);
	    XtFree((char *) std_targets);
	    *type = XA_ATOM;
	    *format = 32;
	    result = True;
	}
d2483 2
a2484 2
    else if (screen->wide_chars && *target == XA_STRING) {
	result =
d2489 3
a2491 2
    } else if (screen->wide_chars && *target == XA_UTF8_STRING(d)) {
	result =
d2496 3
a2498 2
    } else if (screen->wide_chars && *target == XA_TEXT(d)) {
	result =
d2503 3
a2505 2
    } else if (screen->wide_chars && *target == XA_COMPOUND_TEXT(d)) {
	result =
d2513 1
a2513 1
    else if (*target == XA_STRING) {	/* not wide_chars */
d2524 5
a2528 3
	result = True;
    } else if (*target == XA_TEXT(d)) {		/* not wide_chars */
	result =
d2533 4
a2536 2
    } else if (*target == XA_COMPOUND_TEXT(d)) {	/* not wide_chars */
	result =
d2543 2
a2544 2
    else if (*target == XA_UTF8_STRING(d)) {	/* not wide_chars */
	result =
d2551 2
a2552 1
    else if (*target == XA_LIST_LENGTH(d)) {
d2563 4
a2566 2
	result = True;
    } else if (*target == XA_LENGTH(d)) {
d2578 1
a2578 6
	result = True;
    } else if (XmuConvertStandardSelection(w,
					   screen->selection_time, selection,
					   target, type, (XPointer *) value,
					   length, format)) {
	result = True;
d2581 5
d2587 1
a2587 1
    return result;
d2706 1
a2706 1
		Char *data = termw->screen.selection_data;
a2709 1
		TRACE(("XStoreBuffer(%d)\n", cutbuffer));
@


1.1.1.4
log
@fixes xterm crash on selecting text
@
text
@d2111 1
a2111 2
    if (endCol > 1 
	&& iswide(XTERM_CELL(endRow, endCol - 1))
@


