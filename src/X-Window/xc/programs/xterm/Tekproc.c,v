head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407190955:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.11.06;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.11.06;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.41.09;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.45.34;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.29.36;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * $Xorg: Tekproc.c,v 1.5 2001/02/09 02:06:02 xorgcvs Exp $
 *
 * Warning, there be crufty dragons here.
 */
/* $XFree86: xc/programs/xterm/Tekproc.c,v 3.35 2002/01/05 22:05:02 dickey Exp $ */


/*

Copyright 2001 by Thomas E. Dickey

                        All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name(s) of the above copyright
holders shall not be used in advertising or otherwise to promote the
sale, use or other dealings in this Software without prior written
authorization.


Copyright 1988  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.


 * Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 *
 *                         All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Digital Equipment
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior permission.
 *
 *
 * DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
 * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
 * DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
 * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 */

/* Tekproc.c */

#include <xterm.h>

#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/cursorfont.h>
#include <X11/StringDefs.h>
#include <X11/Shell.h>
#include <X11/Xmu/CharSet.h>

#if OPT_TOOLBAR
#include <X11/Xaw/Form.h>
#endif

#include <stdio.h>
#include <ctype.h>
#include <signal.h>

#include <Tekparse.h>
#include <data.h>
#include <error.h>
#include <menu.h>

#ifdef MINIX
#include <sys/nbio.h>

#define select(n,r,w,x,t) nbio_select(n,r,w,x,t)
#define read(f,b,s) nbio_read(f,b,s)
#define write(f,b,s) nbio_write(f,b,s)
#endif

#define DefaultGCID XGContextFromGC(DefaultGC(screen->display, DefaultScreen(screen->display)))

/* Tek defines */

#define	DOTDASHEDLINE	2
#define	DOTTEDLINE	1
#define	EAST		01
#define	LINEMASK	07
#define	LONGDASHEDLINE	4
#define	MARGIN1		0
#define	MARGIN2		1
#define MAX_PTS		150
#define MAX_VTX		300
#define	NORTH		04
#define	PENDOWN		1
#define	PENUP		0
#define	SHORTDASHEDLINE	3
#define	SOLIDLINE	0
#define	SOUTH		010
#define	TEKBOTTOMPAD	23
#define	TEKDEFHEIGHT	565
#define	TEKDEFWIDTH	750
#define	TEKHEIGHT	3072
#define	TEKHOME		((TekChar[screen->page.fontsize].nlines - 1)\
			 * TekChar[screen->page.fontsize].vsize)
#define	TEKMINHEIGHT	452
#define	TEKMINWIDTH	600
#define	TEKTOPPAD	34
#define	TEKWIDTH	4096
#define	WEST		02

#define	TekMove(x,y)	screen->cur_X = x; screen->cur_Y = y
#define	input()		Tinput()
#define	unput(c)	*Tpushback++ = c

extern Bool waiting_for_initial_map;
extern Arg ourTopLevelShellArgs[];
extern int number_ourTopLevelShellArgs;

static struct Tek_Char {
	int hsize;	/* in Tek units */
	int vsize;	/* in Tek units */
	int charsperline;
	int nlines;
} TekChar[TEKNUMFONTS] = {
	{56, 88, 74, 35},	/* large */
	{51, 82, 81, 38},	/* #2 */
	{34, 53, 121, 58},	/* #3 */
	{31, 48, 133, 64},	/* small */
};

static Cursor GINcursor;
static XSegment *line_pt;
static int nplot;
static TekLink Tek0;
static jmp_buf Tekjump;
static TekLink *TekRecord;
static XSegment *Tline;

static Const int *curstate = Talptable;
static Const int *Tparsestate = Talptable;

static char defaultTranslations[] = "\
                ~Meta<KeyPress>: insert-seven-bit() \n\
                 Meta<KeyPress>: insert-eight-bit() \n\
               !Ctrl <Btn1Down>: popup-menu(mainMenu) \n\
          !Lock Ctrl <Btn1Down>: popup-menu(mainMenu) \n\
!Lock Ctrl @@Num_Lock <Btn1Down>: popup-menu(mainMenu) \n\
     !Ctrl @@Num_Lock <Btn1Down>: popup-menu(mainMenu) \n\
               !Ctrl <Btn2Down>: popup-menu(tekMenu) \n\
          !Lock Ctrl <Btn2Down>: popup-menu(tekMenu) \n\
!Lock Ctrl @@Num_Lock <Btn2Down>: popup-menu(tekMenu) \n\
     !Ctrl @@Num_Lock <Btn2Down>: popup-menu(tekMenu) \n\
          Shift ~Meta<Btn1Down>: gin-press(L) \n\
                ~Meta<Btn1Down>: gin-press(l) \n\
          Shift ~Meta<Btn2Down>: gin-press(M) \n\
                ~Meta<Btn2Down>: gin-press(m) \n\
          Shift ~Meta<Btn3Down>: gin-press(R) \n\
                ~Meta<Btn3Down>: gin-press(r)";


static XtActionsRec actionsList[] = {
    { "string",	HandleStringEvent },
    { "insert",	HandleKeyPressed },	/* alias for insert-seven-bit */
    { "insert-seven-bit",	HandleKeyPressed },
    { "insert-eight-bit",	HandleEightBitKeyPressed },
    { "gin-press",		HandleGINInput },
    { "secure",			HandleSecure },
    { "create-menu",		HandleCreateMenu },
    { "popup-menu",		HandlePopupMenu },
    /* menu actions */
    { "allow-send-events",	HandleAllowSends },
    { "set-visual-bell",	HandleSetVisualBell },
#ifdef ALLOWLOGGING
    { "set-logging",		HandleLogging },
#endif
    { "redraw",			HandleRedraw },
    { "send-signal",		HandleSendSignal },
    { "quit",			HandleQuit },
    { "set-scrollbar",		HandleScrollbar },
    { "set-jumpscroll",		HandleJumpscroll },
    { "set-reverse-video",	HandleReverseVideo },
    { "set-autowrap",		HandleAutoWrap },
    { "set-reversewrap",	HandleReverseWrap },
    { "set-autolinefeed",	HandleAutoLineFeed },
    { "set-appcursor",		HandleAppCursor },
    { "set-appkeypad",		HandleAppKeypad },
    { "set-scroll-on-key",	HandleScrollKey },
    { "set-scroll-on-tty-output",	HandleScrollTtyOutput },
    { "set-allow132",		HandleAllow132 },
    { "set-cursesemul",		HandleCursesEmul },
    { "set-marginbell",		HandleMarginBell },
    { "set-altscreen",		HandleAltScreen },
    { "soft-reset",		HandleSoftReset },
    { "hard-reset",		HandleHardReset },
    { "set-terminal-type",	HandleSetTerminalType },
    { "set-visibility",		HandleVisibility },
    { "set-tek-text",		HandleSetTekText },
    { "tek-page",		HandleTekPage },
    { "tek-reset",		HandleTekReset },
    { "tek-copy",		HandleTekCopy },
};

static Dimension defOne = 1;

#define GIN_TERM_NONE_STR	"none"
#define GIN_TERM_CR_STR		"CRonly"
#define GIN_TERM_EOT_STR	"CR&EOT"

#define GIN_TERM_NONE	0
#define GIN_TERM_CR	1
#define GIN_TERM_EOT	2

#ifdef VMS
#define DFT_FONT_SMALL "FIXED"
#else
#define DFT_FONT_SMALL "6x10"
#endif

static XtResource resources[] = {
#ifdef VMS
    {XtNbackground, XtCBackground, XtRPixel, sizeof(Pixel),
	XtOffset(TekWidget, core.background_pixel),
	XtRString, "White"},
    {XtNforeground, XtCForeground, XtRPixel, sizeof(Pixel),
	XtOffset(TekWidget, Tforeground),
	XtRString, "Black"},
#endif
    {XtNwidth, XtCWidth, XtRDimension, sizeof(Dimension),
	 XtOffsetOf(CoreRec, core.width), XtRDimension, (caddr_t)&defOne},
    {XtNheight, XtCHeight, XtRDimension, sizeof(Dimension),
	 XtOffsetOf(CoreRec, core.height), XtRDimension, (caddr_t)&defOne},
    {"fontLarge", XtCFont, XtRFontStruct, sizeof(XFontStruct *),
       XtOffsetOf(TekWidgetRec, tek.Tfont[TEK_FONT_LARGE]),
       XtRString, "9x15"},
    {"font2", XtCFont, XtRFontStruct, sizeof(XFontStruct *),
       XtOffsetOf(TekWidgetRec, tek.Tfont[TEK_FONT_2]),
       XtRString, "6x13"},
    {"font3", XtCFont, XtRFontStruct, sizeof(XFontStruct *),
       XtOffsetOf(TekWidgetRec, tek.Tfont[TEK_FONT_3]),
       XtRString, "8x13"},
    {"fontSmall", XtCFont, XtRFontStruct, sizeof(XFontStruct *),
       XtOffsetOf(TekWidgetRec, tek.Tfont[TEK_FONT_SMALL]),
       XtRString, DFT_FONT_SMALL},
    {"initialFont", "InitialFont", XtRString, sizeof(char *),
       XtOffsetOf(TekWidgetRec, tek.initial_font),
       XtRString, "large"},
    {"ginTerminator", "GinTerminator", XtRString, sizeof(char *),
       XtOffsetOf(TekWidgetRec, tek.gin_terminator_str),
       XtRString, GIN_TERM_NONE_STR},
#if OPT_TOOLBAR
    {XtNmenuBar, XtCMenuBar, XtRWidget, sizeof(Widget),
       XtOffsetOf(TekWidgetRec, tek.menu_bar),
       XtRWidget, (XtPointer) 0},
    {XtNmenuHeight, XtCMenuHeight, XtRInt, sizeof(int),
       XtOffsetOf(TekWidgetRec, tek.menu_height),
       XtRString, "25"},
#endif
};

static int Tinput (void);
static int getpoint (void);
static void TCursorBack (void);
static void TCursorDown (void);
static void TCursorForward (void);
static void TCursorUp (void);
static void TekBackground (TScreen *screen);
static void TekConfigure (Widget w);
static void TekDraw (int x, int y);
static void TekEnq (int status, int x, int y);
static void TekFlush (void);
static void TekInitialize (Widget request, Widget wnew, ArgList args, Cardinal *num_args);
static void TekPage (void);
static void TekRealize (Widget gw, XtValueMask *valuemaskp, XSetWindowAttributes *values);

static WidgetClassRec tekClassRec = {
  {
/* core_class fields */
    /* superclass	  */	(WidgetClass) &widgetClassRec,
    /* class_name	  */	"Tek4014",
    /* widget_size	  */	sizeof(TekWidgetRec),
    /* class_initialize   */    NULL,
    /* class_part_initialize */ NULL,
    /* class_inited       */	FALSE,
    /* initialize	  */	TekInitialize,
    /* initialize_hook    */    NULL,
    /* realize		  */	TekRealize,
    /* actions		  */	actionsList,
    /* num_actions	  */	XtNumber(actionsList),
    /* resources	  */	resources,
    /* num_resources	  */	XtNumber(resources),
    /* xrm_class	  */	NULLQUARK,
    /* compress_motion	  */	TRUE,
    /* compress_exposure  */	TRUE,
    /* compress_enterleave */   TRUE,
    /* visible_interest	  */	FALSE,
    /* destroy		  */	NULL,
    /* resize		  */	TekConfigure,
    /* expose		  */	TekExpose,
    /* set_values	  */	NULL,
    /* set_values_hook    */    NULL,
    /* set_values_almost  */    NULL,
    /* get_values_hook    */    NULL,
    /* accept_focus	  */	NULL,
    /* version		  */	XtVersion,
    /* callback_offsets   */    NULL,
    /* tm_table		  */	defaultTranslations,
    /* query_geometry     */    XtInheritQueryGeometry,
    /* display_accelerator*/    XtInheritDisplayAccelerator,
    /* extension	  */	NULL
  }
};
#define tekWidgetClass ((WidgetClass)&tekClassRec)

static Boolean Tfailed = FALSE;

int TekInit (void)
{
    Widget form_top, menu_top;

    if (!Tfailed
     && tekWidget == 0) {
	/* this causes the Initialize method to be called */
	tekshellwidget = XtCreatePopupShell (
			"tektronix", topLevelShellWidgetClass,
			toplevel, ourTopLevelShellArgs,
			number_ourTopLevelShellArgs);

	SetupMenus(tekshellwidget, &form_top, &menu_top);

	/* this causes the Realize method to be called */
	tekWidget = (TekWidget) XtVaCreateManagedWidget (
			"tek4014", tekWidgetClass, form_top,
#if OPT_TOOLBAR
			XtNmenuBar,	menu_top,
			XtNresizable,	True,
			XtNfromVert,	menu_top,
			XtNleft,	XawChainLeft,
			XtNright,	XawChainRight,
			XtNbottom,	XawChainBottom,
#endif
			0);
    }
    return (!Tfailed);
}

/*
 * If we haven't allocated the PtyData struct, do so.
 */
int
TekPtyData(void)
{
    if (Tbuffer == 0) {
	if ((Tbuffer = (PtyData *)malloc(sizeof(PtyData))) == NULL
	 || (Tpushb = (Char *)malloc(10)) == NULL
	 || (Tline = (XSegment *)malloc(MAX_VTX * sizeof(XSegment))) == NULL) {
	    fprintf (stderr, "%s: Not enough core for Tek mode\n", xterm_name);
	    if(Tpushb) free((char *)Tpushb);
	    if(Tbuffer) free((char *)Tbuffer);
	    Tfailed = TRUE;
	    return 0;
	}
    }
    return 1;
}

static void Tekparse(void)
{
	register TScreen *screen = &term->screen;
	register int c, x, y;
	Char ch;
	int nextstate;

	for( ; ; ) {
	    c = input();
	    /*
	     * The parsing tables all have 256 entries.  If we're supporting
	     * wide characters, we handle them by treating them the same as
	     * printing characters.
	     */
#if OPT_WIDE_CHARS
	    if (c > 255) {
		nextstate = (Tparsestate == Talptable)
			? CASE_PRINT
			: CASE_IGNORE;
	    } else
#endif
	      nextstate = Tparsestate[c];
	    TRACE(("parse %d -> %d\n", c, nextstate));

	    switch(nextstate) {
		 case CASE_REPORT:
			/* report address */
			if(screen->TekGIN) {
				TekGINoff();
				TekEnqMouse(0);
			} else {
				c = 064;	/* has hard copy unit */
				if(screen->margin == MARGIN2)
					c |= 02;
				TekEnq(c, screen->cur_X, screen->cur_Y);
			}
			TekRecord->ptr[-1] = NAK; /* remove from recording */
			Tparsestate = curstate;
			break;

		 case CASE_VT_MODE:
			/* special return to vt102 mode */
			Tparsestate = curstate;
			TekRecord->ptr[-1] = NAK; /* remove from recording */
#ifdef ALLOWLOGGING
			if(screen->logging) {
				FlushLog(screen);
				screen->logstart = DecodedData(&(VTbuffer));
			}
#endif
			return;

		 case CASE_SPT_STATE:
			/* Enter Special Point Plot mode */
			if(screen->TekGIN)
				TekGINoff();
			Tparsestate = curstate = Tspttable;
			break;

		 case CASE_GIN:
			/* Do Tek GIN mode */
			screen->TekGIN = &TekRecord->ptr[-1];
				/* Set cross-hair cursor raster array */
			if ((GINcursor =
			    make_colored_cursor (XC_tcross, screen->mousecolor,
						 screen->mousecolorback)) != 0)
				XDefineCursor (screen->display, TShellWindow,
					       GINcursor);
			Tparsestate = Tbyptable;	/* Bypass mode */
			break;

		 case CASE_BEL:
			/* BEL */
			if(screen->TekGIN)
				TekGINoff();
			if(!TekRefresh)
				Bell(XkbBI_TerminalBell,0);
			Tparsestate = curstate;	/* clear bypass condition */
			break;

		 case CASE_BS:
			/* BS */
			if(screen->TekGIN)
				TekGINoff();
			Tparsestate = curstate;	/* clear bypass condition */
			TCursorBack();
			break;

		 case CASE_PT_STATE:
			/* Enter Tek Point Plot mode */
			if(screen->TekGIN)
				TekGINoff();
			Tparsestate = curstate = Tpttable;
			break;

		 case CASE_PLT_STATE:
			/* Enter Tek Plot mode */
			if(screen->TekGIN)
				TekGINoff();
			Tparsestate = curstate = Tplttable;
			if((c = input()) == BEL)
				screen->pen = PENDOWN;
			else {
				unput(c);
				screen->pen = PENUP;
			}
			break;

		 case CASE_TAB:
			/* HT */
			if(screen->TekGIN)
				TekGINoff();
			Tparsestate = curstate;	/* clear bypass condition */
			TCursorForward();
			break;

		 case CASE_IPL_STATE:
			/* Enter Tek Incremental Plot mode */
			if(screen->TekGIN)
				TekGINoff();
			Tparsestate = curstate = Tipltable;
			break;

		 case CASE_ALP_STATE:
			/* Enter Tek Alpha mode from any other mode */
			if(screen->TekGIN)
				TekGINoff();
			/* if in one of graphics states, move alpha cursor */
			if(nplot > 0)	/* flush line Tbuffer */
				TekFlush();
			Tparsestate = curstate = Talptable;
			break;

		 case CASE_UP:
			/* cursor up */
			if(screen->TekGIN)
				TekGINoff();
			Tparsestate = curstate;	/* clear bypass condition */
			TCursorUp();
			break;

		 case CASE_COPY:
			/* make copy */
			if(screen->TekGIN)
				TekGINoff();
			TekCopy();
			TekRecord->ptr[-1] = NAK; /* remove from recording */
			Tparsestate = curstate;	/* clear bypass condition */
			break;

		 case CASE_PAGE:
			/* Page Function */
			if(screen->TekGIN)
				TekGINoff();
			TekPage();	/* clear bypass condition */
			break;

		 case CASE_BES_STATE:
			/* Byp: an escape char */
			Tparsestate = Tbestable;
			break;

		 case CASE_BYP_STATE:
			/* set bypass condition */
			Tparsestate = Tbyptable;
			break;

		 case CASE_IGNORE:
			/* Esc: totally ignore CR, ESC, LF, ~ */
			break;

		 case CASE_ASCII:
			/* Select ASCII char set */
			/* ignore for now */
			Tparsestate = curstate;
			break;

		 case CASE_APL:
			/* Select APL char set */
			/* ignore for now */
			Tparsestate = curstate;
			break;

		 case CASE_CHAR_SIZE:
			/* character size selector */
			TekSetFontSize (c & 03);
			Tparsestate = curstate;
			break;

		 case CASE_BEAM_VEC:
			/* beam and vector selector */
			/* only line types */
			if((c &= LINEMASK) != screen->cur.linetype) {
				if(nplot > 0)
				    TekFlush();
				if (c <= TEKNUMLINES)
				    screen->cur.linetype = c;
			}
			Tparsestate = curstate;
			break;

		 case CASE_CURSTATE:
			Tparsestate = curstate;
			break;

		 case CASE_PENUP:
			/* Ipl: penup */
			screen->pen = PENUP;
			break;

		 case CASE_PENDOWN:
			/* Ipl: pendown */
			screen->pen = PENDOWN;
			break;

		 case CASE_IPL_POINT:
			/* Ipl: point */
			x = screen->cur_X;
			y = screen->cur_Y;
			if(c & NORTH)
				y++;
			else if(c & SOUTH)
				y--;
			if(c & EAST)
				x++;
			else if(c & WEST)
				x--;
			if(screen->pen == PENDOWN)
				TekDraw(x, y);
			else
				TekMove(x, y);
			break;

		 case CASE_PLT_VEC:
			/* Plt: vector */
			unput(c);
			if(getpoint()) {
				if(screen->pen == PENDOWN)
					TekDraw(screen->cur.x, screen->cur.y);
				else
					TekMove(screen->cur.x, screen->cur.y);
				screen->pen = PENDOWN;
			}
			break;

		 case CASE_PT_POINT:
			/* Pt: point */
			unput(c);
			if(getpoint()) {
				TekMove(screen->cur.x, screen->cur.y);
				TekDraw(screen->cur.x, screen->cur.y);
			}
			break;

		 case CASE_SPT_POINT:
			/* Spt: point */
			/* ignore intensity character in c */
			if(getpoint()) {
				TekMove(screen->cur.x, screen->cur.y);
				TekDraw(screen->cur.x, screen->cur.y);
			}
			break;

		 case CASE_CR:
			/* CR */
			if(screen->TekGIN)
				TekGINoff();
			if(nplot > 0)	/* flush line Tbuffer */
				TekFlush();
			screen->cur_X = screen->margin == MARGIN1 ? 0 :
			 TEKWIDTH / 2;
			Tparsestate = curstate = Talptable;
			break;

		 case CASE_ESC_STATE:
			/* ESC */
			Tparsestate = Tesctable;
			break;

		 case CASE_LF:
			/* LF */
			if(screen->TekGIN)
				TekGINoff();
			TCursorDown();
			if (!TekRefresh)
				do_xevents();
			break;

		 case CASE_SP:
			/* SP */
			TCursorForward();
			break;

		 case CASE_PRINT:
			/* printable character */
			ch = c;
			c = screen->cur.fontsize;
			x = (int)(screen->cur_X * TekScale(screen)) + screen->border;
			y = (int)((TEKHEIGHT + TEKTOPPAD - screen->cur_Y) * TekScale(screen)) + screen->border;

#if OPT_WIDE_CHARS
			if (screen->wide_chars
			 && (ch > 255)) {
				XChar2b sbuf;
				sbuf.byte2 = CharOf(ch);
				sbuf.byte1 = CharOf(ch >>8);
				XDrawImageString16(
				    screen->display,
				    TWindow(screen),
				    screen->TnormalGC,
				    x,
				    y,
				    &sbuf,
				    1);
			} else
#endif
			XDrawString(
			    screen->display,
			    TWindow(screen),
			    screen->TnormalGC,
			    x,
			    y,
			    (char *)&ch,
			    1);
			TCursorForward();
			break;
		 case CASE_OSC:
			/* FIXME:  someone should disentangle the input queues
			 * of this code so that it can be state-driven.
			 */
			/* do osc escape */
			{
				Char buf2[512];
				int c2, len = 0;
				while ((c2 = Tinput()) != BEL) {
					if (!isprint(c2 & 0x7f)
					 || len+2 >= (int) sizeof(buf2))
						break;
					buf2[len++] = c2;
				}
				if (c2 == BEL)
					do_osc(buf2, len, BEL);
			}
			Tparsestate = curstate;
			break;
		}
	}
}

static int rcnt;
static char *rptr;
#ifdef VMS
static int Tselect_mask;
#else  /* VMS */
static fd_set Tselect_mask;
#endif /* VMS */

static int Tinput(void)
{
	register TScreen *screen = &term->screen;
	register int i;
	register TekLink *tek;

	if(Tpushback > Tpushb)
		return(*--Tpushback);
	if(TekRefresh) {
		if(rcnt-- > 0)
			return(*rptr++);
		if ((tek = TekRefresh->next) != 0) {
			TekRefresh = tek;
			rptr = tek->data;
			rcnt = tek->count - 1;
			TekSetFontSize(tek->fontsize);
			return(*rptr++);
		}
		TekRefresh = (TekLink *)0;
		longjmp(Tekjump, 1);
	}
again:
	if(Tbuffer->cnt-- <= 0) {
		if(nplot > 0)	/* flush line Tbuffer */
			TekFlush();
#ifdef VMS
		Tselect_mask = pty_mask;	/* force a read */
#else /* VMS */
		XFD_COPYSET (&pty_mask, &Tselect_mask);
#endif /* VMS */
		for( ; ; ) {
#ifdef CRAY
			struct timeval crocktimeout;
			crocktimeout.tv_sec = 0;
			crocktimeout.tv_usec = 0;
			(void) Select (max_plus1,
				       &Tselect_mask, NULL, NULL,
				       &crocktimeout);
#endif
#ifdef VMS
			if(Tselect_mask & pty_mask) {
#ifdef ALLOWLOGGING
			   if(screen->logging)
				   FlushLog(screen);
#endif
			   if (read_queue.flink != 0) {
				   Tbuffer->cnt = tt_read(Tbuffer->ptr = Tbuffer->buf);
				   if(Tbuffer->cnt == 0) {
					   Panic("input: read returned zero\n", 0);
				   }
				   else { break; }
			   }
			   else { sys$hiber(); }
			}
#else  /* VMS */
			if (getPtyData(screen, &Tselect_mask, Tbuffer)) {
			    break;
			}
#endif /* VMS */
			if (Ttoggled && curstate == Talptable) {
				TCursorToggle(TOGGLE);
				Ttoggled = FALSE;
			}
#ifndef AMOEBA
			if(XtAppPending(app_con) & XtIMXEvent) {
#ifdef VMS
				Tselect_mask = X_mask;
#else /* VMS */
				XFD_COPYSET (&X_mask, &Tselect_mask);
#endif /* VMS */
			} else {
				XFlush(screen->display);
#ifdef VMS
				Tselect_mask = Select_mask;

#else /* VMS */
				XFD_COPYSET (&Select_mask, &Tselect_mask);
				if((i = Select(max_plus1,
					       &Tselect_mask, NULL, NULL,
					       NULL)) < 0){
					if (errno != EINTR)
						SysError(ERROR_TSELECT);
					continue;
				}
#endif /* VMS */
			}
#else /* AMOEBA */
			XFlush(screen->display);
			i = _X11TransAmSelect(ConnectionNumber(screen->display),
					      1);
			/* if there are X events already in our queue,
			   it counts as being readable */
			if (XtAppPending(app_con) || i > 0) {
				xevents();
				continue;
			} else if (i < 0) {
				extern int exiting;
				if (errno != EINTR && !exiting)
					SysError(ERROR_SELECT);
			}
			if (Tbuffer->cnt > 0)
				goto again;
			if (cb_full(screen->tty_outq) <= 0)
				SleepMainThread();
#endif /* AMOEBA */
#ifdef VMS
			if(Tselect_mask & X_mask) {
				xevents();
				if(Tbuffer->cnt > 0)
					goto again;
			}
#else /* VMS */
			if(FD_ISSET (ConnectionNumber (screen->display), &Tselect_mask)) {
				xevents();
				if(Tbuffer->cnt > 0)
					goto again;
			}
#endif /* VMS */
		}
		Tbuffer->cnt--;
		if (!Ttoggled && curstate == Talptable) {
			TCursorToggle(TOGGLE);
			Ttoggled = TRUE;
		}
	}
	tek = TekRecord;
	if(tek->count >= TEK_LINK_BLOCK_SIZE
	   || tek->fontsize != screen->cur.fontsize) {
		if((TekRecord = tek->next = (TekLink *)malloc(sizeof(TekLink)))
		 == (TekLink *)0)
			Panic("Tinput: malloc error (%d)\n", errno);
		tek = tek->next;
		tek->next = (TekLink *)0;
		tek->fontsize = screen->cur.fontsize;
		tek->count = 0;
		tek->ptr = tek->data;
	}
	tek->count++;
	return(*tek->ptr++ = *(Tbuffer->ptr)++);
}

/* this should become the Tek Widget's Resize proc */
static void TekConfigure(Widget w)
{
    register TScreen *screen = &term->screen;
    register int border = 2 * screen->border;
    register double d;

    if (TWindow(screen)) XClearWindow(screen->display, TWindow(screen));
    TWidth(screen) = w->core.width - border;
    THeight(screen) = w->core.height - border;
    TekScale(screen) = (double)TWidth(screen) / TEKWIDTH;
    if((d = (double)THeight(screen) / (TEKHEIGHT + TEKTOPPAD + TEKBOTTOMPAD))
       < TekScale(screen))
      TekScale(screen) = d;
    TFullWidth(screen) = w->core.width;
    TFullHeight(screen) = w->core.height;
}

/*ARGSUSED*/
void
TekExpose(
    Widget w GCC_UNUSED,
    XEvent *event GCC_UNUSED,
    Region region GCC_UNUSED)
{
	register TScreen *screen = &term->screen;

#ifdef lint
	region = region;
#endif
	if(!Ttoggled)
	    TCursorToggle(CLEAR);
	Ttoggled = TRUE;
	Tpushback = Tpushb;
	screen->cur_X = 0;
	screen->cur_Y = TEKHOME;
	TekSetFontSize(screen->page.fontsize);
	screen->cur = screen->page;
	screen->margin = MARGIN1;
	if(screen->TekGIN) {
		screen->TekGIN = NULL;
		TekGINoff();
	}
	TekRefresh = &Tek0;
	rptr = TekRefresh->data;
	rcnt = TekRefresh->count;
	Tparsestate = curstate = Talptable;
	if (waiting_for_initial_map)
	    first_map_occurred ();
	if(!screen->waitrefresh)
		dorefresh();
}

void
dorefresh(void)
{
	register TScreen *screen = &term->screen;
	static Cursor wait_cursor = None;

	if (wait_cursor == None)
	    wait_cursor = make_colored_cursor (XC_watch, screen->mousecolor,
					       screen->mousecolorback);
	XDefineCursor(screen->display, TShellWindow, wait_cursor);
	XFlush(screen->display);
	if(!setjmp(Tekjump))
		Tekparse();
	XDefineCursor(screen->display, TShellWindow,
	 (screen->TekGIN && GINcursor) ? GINcursor : screen->arrow);
}

static void
TekPage(void)
{
	register TScreen *screen = &term->screen;
	register TekLink *tek;

	XClearWindow(screen->display, TWindow(screen));
	screen->cur_X = 0;
	screen->cur_Y = TEKHOME;
	screen->margin = MARGIN1;
	screen->page = screen->cur;
	if(screen->TekGIN)
		TekGINoff();
	tek = TekRecord = &Tek0;
	tek->fontsize = screen->cur.fontsize;
	tek->count = 0;
	tek->ptr = tek->data;
	tek = tek->next;
	if(tek)
		do {
			TekLink *tek2 = tek->next;

			free((char *)tek);
			tek = tek2;
		} while(tek);
	TekRecord->next = (TekLink *)0;
	TekRefresh = (TekLink *)0;
	Ttoggled = TRUE;
	Tparsestate = curstate = Talptable;	/* Tek Alpha mode */
}

#define	EXTRABITS	017
#define	FIVEBITS	037
#define	HIBITS		(FIVEBITS << SHIFTHI)
#define	LOBITS		(FIVEBITS << SHIFTLO)
#define	SHIFTHI		7
#define	SHIFTLO		2
#define	TWOBITS		03

static int
getpoint(void)
{
	register int c, x, y, e, lo_y = 0;
	register TScreen *screen = &term->screen;

	x = screen->cur.x;
	y = screen->cur.y;
	for( ; ; ) {
		if((c = input()) < ' ') {	/* control character */
			unput(c);
			return(0);
		}
		if(c < '@@') {	/* Hi X or Hi Y */
			if(lo_y) {	/* seen a Lo Y, so this must be Hi X */
				x &= ~HIBITS;
				x |= (c & FIVEBITS) << SHIFTHI;
				continue;
			}
			/* else Hi Y */
			y &= ~HIBITS;
			y |= (c & FIVEBITS) << SHIFTHI;
			continue;
		}
		if(c < '`') {	/* Lo X */
			x &= ~LOBITS;
			x |= (c & FIVEBITS) << SHIFTLO;
			screen->cur.x = x;
			screen->cur.y = y;
			return(1);	/* OK */
		}
		/* else Lo Y */
		if(lo_y) {	/* seen a Lo Y, so other must be extra bits */
			e = (y >> SHIFTLO) & EXTRABITS;
			x &= ~TWOBITS;
			x |= e & TWOBITS;
			y &= ~TWOBITS;
			y |= (e >> SHIFTLO) & TWOBITS;
		}
		y &= ~LOBITS;
		y |= (c & FIVEBITS) << SHIFTLO;
		lo_y++;
	}
}

static void
TCursorBack(void)
{
	register TScreen *screen = &term->screen;
	register struct Tek_Char *t;
	register int x, l;

	x = ( screen->cur_X -=
		(t = &TekChar[screen->cur.fontsize])->hsize
	    );

	if(((screen->margin == MARGIN1) && (x < 0))
	|| ((screen->margin == MARGIN2) && (x < TEKWIDTH / 2))) {
		if((l = (screen->cur_Y + (t->vsize - 1)) / t->vsize + 1) >=
		 t->nlines) {
			screen->margin = !screen->margin;
			l = 0;
		}
		screen->cur_Y = l * t->vsize;
		screen->cur_X = (t->charsperline - 1) * t->hsize;
	}
}

static void
TCursorForward(void)
{
	register TScreen *screen = &term->screen;
	register struct Tek_Char *t;
	register int l;

	if( ( screen->cur_X +=
		( t = &TekChar[screen->cur.fontsize])->hsize
	    ) > TEKWIDTH
	  ) {
		if((l = screen->cur_Y / t->vsize - 1) < 0) {
			screen->margin = !screen->margin;
			l = t->nlines - 1;
		}
		screen->cur_Y = l * t->vsize;
		screen->cur_X = screen->margin == MARGIN1 ? 0 : TEKWIDTH / 2;
	}
}

static void
TCursorUp(void)
{
	register TScreen *screen = &term->screen;
	register struct Tek_Char *t;
	register int l;

	t = &TekChar[screen->cur.fontsize];

	if((l = (screen->cur_Y + (t->vsize - 1)) / t->vsize + 1) >= t->nlines) {
		l = 0;
		if((screen->margin = !screen->margin) != MARGIN1) {
			if(screen->cur_X < TEKWIDTH / 2)
				screen->cur_X += TEKWIDTH / 2;
		} else if(screen->cur_X >= TEKWIDTH / 2)
			screen->cur_X -= TEKWIDTH / 2;
	}
	screen->cur_Y = l * t->vsize;
}

static void
TCursorDown(void)
{
	register TScreen *screen = &term->screen;
	register struct Tek_Char *t;
	register int l;

	t = &TekChar[screen->cur.fontsize];

	if((l = screen->cur_Y / t->vsize - 1) < 0) {
		l = t->nlines - 1;
		if((screen->margin = !screen->margin) != MARGIN1) {
			if(screen->cur_X < TEKWIDTH / 2)
				screen->cur_X += TEKWIDTH / 2;
		} else if(screen->cur_X >= TEKWIDTH / 2)
			screen->cur_X -= TEKWIDTH / 2;
	}
	screen->cur_Y = l * t->vsize;
}

static void
AddToDraw(int x1, int y1, int x2, int y2)
{
	register TScreen *screen = &term->screen;
	register XSegment *lp;

	if(nplot >= MAX_PTS) {
		TekFlush();
	}
	lp = line_pt++;
	lp->x1 = x1 = (int) (x1 * TekScale(screen) + screen->border);
	lp->y1 = y1 = (int) ((TEKHEIGHT + TEKTOPPAD - y1) * TekScale(screen) +
				screen->border);
	lp->x2 = x2 = (int) (x2 * TekScale(screen) + screen->border);
	lp->y2 = y2 = (int) ((TEKHEIGHT + TEKTOPPAD - y2) * TekScale(screen) +
				screen->border);
	nplot++;
}

static void
TekDraw (int x, int y)
{
	register TScreen *screen = &term->screen;

	if(nplot == 0 || T_lastx != screen->cur_X || T_lasty != screen->cur_Y) {
		/*
		 * We flush on each unconnected line segment if the line
		 * type is not solid.  This solves a bug in X when drawing
		 * points while the line type is not solid.
		 */
		if(nplot > 0 && screen->cur.linetype != SOLIDLINE)
			TekFlush();
	}
	AddToDraw(screen->cur_X, screen->cur_Y, x, y);
	T_lastx = screen->cur_X = x;
	T_lasty = screen->cur_Y = y;
}

static void
TekFlush (void)
{
	register TScreen *screen = &term->screen;

	XDrawSegments(screen->display, TWindow(screen),
		((screen->cur.linetype == SOLIDLINE)?  screen->TnormalGC :
		 screen->linepat[screen->cur.linetype - 1]),
		 Tline, nplot);
	nplot = 0;
	line_pt = Tline;
}

void
TekGINoff(void)
{
	register TScreen *screen = &term->screen;

	XDefineCursor(screen->display, TShellWindow, screen->arrow);
	if(GINcursor)
		XFreeCursor(screen->display, GINcursor);
	if(screen->TekGIN) {
		*screen->TekGIN = CAN;	/* modify recording */
		screen->TekGIN = NULL;
	}
}

void
TekEnqMouse(int c)		/* character pressed */
{
	register TScreen *screen = &term->screen;
	int mousex, mousey, rootx, rooty;
	unsigned int mask; /* XQueryPointer */
	Window root, subw;

	XQueryPointer(
	    screen->display, TWindow(screen),
	    &root, &subw,
	    &rootx, &rooty,
	    &mousex, &mousey,
	    &mask);
	if((mousex = (int)((mousex - screen->border) / TekScale(screen))) < 0)
		mousex = 0;
	else if(mousex >= TEKWIDTH)
		mousex = TEKWIDTH - 1;
	if((mousey = (int)(TEKHEIGHT + TEKTOPPAD - (mousey - screen->border) /
	     TekScale(screen))) < 0)
		mousey = 0;
	else if(mousey >= TEKHEIGHT)
		mousey = TEKHEIGHT - 1;
	TekEnq(c, mousex, mousey);
}

static void TekEnq (
    int status,
    register int x,
    register int y)
{
    register TScreen *screen = &term->screen;
    Char cplot [7];
    int len = 5;
    int adj = (status != 0) ? 0 : 1;

    cplot[0] = status;
    /* Translate x and y to Tektronix code */
    cplot[1] = 040 | ((x >> SHIFTHI) & FIVEBITS);
    cplot[2] = 040 | ((x >> SHIFTLO) & FIVEBITS);
    cplot[3] = 040 | ((y >> SHIFTHI) & FIVEBITS);
    cplot[4] = 040 | ((y >> SHIFTLO) & FIVEBITS);

    if (screen->gin_terminator != GIN_TERM_NONE)
	cplot[len++] = '\r';
    if (screen->gin_terminator == GIN_TERM_EOT)
	cplot[len++] = '\004';
#ifdef VMS
    tt_write(cplot+adj, len-adj);
#else /* VMS */
    v_write(screen->respond, cplot+adj, len-adj);
#endif /* VMS */
}

void
TekRun(void)
{
	register TScreen *screen = &term->screen;
	register int i;

	if(!TWindow(screen) && !TekInit()) {
		if(VWindow(screen)) {
			screen->TekEmu = FALSE;
			return;
		}
		Exit(ERROR_TINIT);
	}
	if(!screen->Tshow) {
	    set_tek_visibility (TRUE);
	}
	update_vttekmode();
	update_vtshow();
	update_tekshow();
	set_tekhide_sensitivity();

	Tpushback = Tpushb;
	Tbuffer->ptr = DecodedData(Tbuffer);
	for(i = Tbuffer->cnt = VTbuffer.cnt ; i > 0 ; i--)
		*(Tbuffer->ptr)++ = *(VTbuffer.ptr)++;
	Tbuffer->ptr = DecodedData(Tbuffer);
	Ttoggled = TRUE;
	if(!setjmp(Tekend))
		Tekparse();
	if(!Ttoggled) {
		TCursorToggle(TOGGLE);
		Ttoggled = TRUE;
	}
	screen->TekEmu = FALSE;
}

#define DOTTED_LENGTH 2
#define DOT_DASHED_LENGTH 4
#define SHORT_DASHED_LENGTH 2
#define LONG_DASHED_LENGTH 2

static int dash_length[TEKNUMLINES] = {
	DOTTED_LENGTH,
	DOT_DASHED_LENGTH,
	SHORT_DASHED_LENGTH,
	LONG_DASHED_LENGTH,
};

static unsigned char dotted[DOTTED_LENGTH] = {3, 1};
static unsigned char dot_dashed[DOT_DASHED_LENGTH] = {3, 4, 3, 1};
static unsigned char short_dashed[SHORT_DASHED_LENGTH] = {4, 4};
static unsigned char long_dashed[LONG_DASHED_LENGTH] = {4, 7};

static unsigned char *dashes[TEKNUMLINES] = {
	dotted,
	dot_dashed,
	short_dashed,
	long_dashed,
};



/*
 * The following is called to create the tekWidget
 */

static void TekInitialize(
    Widget request GCC_UNUSED,
    Widget wnew GCC_UNUSED,
    ArgList args GCC_UNUSED,
    Cardinal *num_args GCC_UNUSED)
{
    Widget tekparent = SHELL_OF(wnew);

    /* look for focus related events on the shell, because we need
     * to care about the shell's border being part of our focus.
     */
    XtAddEventHandler(tekparent, EnterWindowMask, FALSE,
		      HandleEnterWindow, (caddr_t)NULL);
    XtAddEventHandler(tekparent, LeaveWindowMask, FALSE,
		      HandleLeaveWindow, (caddr_t)NULL);
    XtAddEventHandler(tekparent, FocusChangeMask, FALSE,
		      HandleFocusChange, (caddr_t)NULL);
    XtAddEventHandler((Widget)wnew, PropertyChangeMask, FALSE,
		      HandleBellPropertyChange, (Opaque)NULL);
}


static void TekRealize (
    Widget gw,
    XtValueMask *valuemaskp,
    XSetWindowAttributes *values)
{
    TekWidget tw = (TekWidget) gw;
    register TScreen *screen = &term->screen;
    register int i;
    register TekLink *tek;
    register double d;
    register int border = 2 * screen->border;
    int pr;
    XGCValues gcv;
    int winX, winY, width, height;
    XSizeHints sizehints;
    char Tdefault[32];

#ifndef NO_ACTIVE_ICON
    term->screen.whichTwin = &term->screen.fullTwin;
#endif /* NO_ACTIVE_ICON */

    tw->core.border_pixel = term->core.border_pixel;

    for (i = 0; i < TEKNUMFONTS; i++) {
	if (!tw->tek.Tfont[i])
	  tw->tek.Tfont[i] = XQueryFont (screen->display, DefaultGCID);
	tw->tek.tobaseline[i] = tw->tek.Tfont[i]->ascent;
    }

    if (!TekPtyData())
	return;

    screen->xorplane = 1;

    screen->Tbackground = term->core.background_pixel;
    screen->Tforeground = screen->foreground;
    screen->Tcursorcolor = screen->cursorcolor;

    if (term->misc.T_geometry == NULL) {
	int defwidth, defheight;

	if (term->misc.tekSmall) {
	    defwidth = TEKMINWIDTH;
	    defheight = TEKMINHEIGHT;
	} else {
	    defwidth = TEKDEFWIDTH;
	    defheight = TEKDEFHEIGHT;
	}
	sprintf (Tdefault, "=%dx%d", defwidth + border, defheight + border);
	term->misc.T_geometry = Tdefault;
    }

    winX = 1;
    winY = 1;
    width = TEKDEFWIDTH + border;
    height = TEKDEFHEIGHT + border;

    pr = XParseGeometry(term->misc.T_geometry, &winX, &winY, (unsigned int *)&width, (unsigned int *)&height);
    if ((pr & XValue) && (pr & XNegative))
      winX += DisplayWidth(screen->display, DefaultScreen(screen->display))
			- width - (SHELL_OF(term)->core.border_width * 2);
    if ((pr & YValue) && (pr & YNegative))
      winY += DisplayHeight(screen->display, DefaultScreen(screen->display))
	- height - (SHELL_OF(term)->core.border_width * 2);

    /* set up size hints */
    sizehints.min_width = TEKMINWIDTH + border;
    sizehints.min_height = TEKMINHEIGHT + border;
    sizehints.width_inc = 1;
    sizehints.height_inc = 1;
    sizehints.flags = PMinSize|PResizeInc;
    sizehints.x = winX;
    sizehints.y = winY;
    if ((XValue&pr) || (YValue&pr)) {
	sizehints.flags |= USSize|USPosition;
	sizehints.flags |= PWinGravity;
	switch (pr & (XNegative | YNegative)) {
	  case 0:
	    sizehints.win_gravity = NorthWestGravity;
	    break;
	  case XNegative:
	    sizehints.win_gravity = NorthEastGravity;
	    break;
	  case YNegative:
	    sizehints.win_gravity = SouthWestGravity;
	    break;
	  default:
	    sizehints.win_gravity = SouthEastGravity;
	    break;
	}
    } else {
	sizehints.flags |= PSize;
    }
    sizehints.width = width;
    sizehints.height = height;
    if ((WidthValue&pr) || (HeightValue&pr))
      sizehints.flags |= USSize;
    else sizehints.flags |= PSize;

    (void) XtMakeResizeRequest ((Widget) tw, width, height,
				&tw->core.width, &tw->core.height);

    /* XXX This is bogus.  We are parsing geometries too late.  This
     * is information that the shell widget ought to have before we get
     * realized, so that it can do the right thing.
     */
    if (sizehints.flags & USPosition)
      XMoveWindow (XtDisplay(tw), XtWindow(SHELL_OF(tw)),
		   sizehints.x, sizehints.y);

    XSetWMNormalHints (XtDisplay(tw), XtWindow(SHELL_OF(tw)),
		       &sizehints);
    XFlush (XtDisplay(tw));	/* get it out to window manager */

    values->win_gravity = NorthWestGravity;
    values->background_pixel = screen->Tbackground;

    XtWindow(tw) = TWindow(screen) =
	XCreateWindow (screen->display,
		       XtWindow(SHELL_OF(tw)),
		       tw->core.x, tw->core.y,
		       tw->core.width, tw->core.height, tw->core.border_width,
		       (int) tw->core.depth,
		       InputOutput, CopyFromParent,
		       ((*valuemaskp)|CWBackPixel|CWWinGravity),
		       values);

    TFullWidth(screen) = width;
    TFullHeight(screen) = height;
    TWidth(screen) = width - border;
    THeight(screen) = height - border;
    TekScale(screen) = (double)TWidth(screen) / TEKWIDTH;
    if((d = (double)THeight(screen) / (TEKHEIGHT + TEKTOPPAD +
				       TEKBOTTOMPAD)) < TekScale(screen))
      TekScale(screen) = d;


    screen->cur.fontsize = TEK_FONT_LARGE;
    if (tw->tek.initial_font) {
	char *s = tw->tek.initial_font;

	if (XmuCompareISOLatin1 (s, "large") == 0)
	  screen->cur.fontsize = TEK_FONT_LARGE;
	else if (XmuCompareISOLatin1 (s, "2") == 0 ||
		 XmuCompareISOLatin1 (s, "two") == 0)
	  screen->cur.fontsize = TEK_FONT_2;
	else if (XmuCompareISOLatin1 (s, "3") == 0 ||
		 XmuCompareISOLatin1 (s, "three") == 0)
	  screen->cur.fontsize = TEK_FONT_3;
	else if (XmuCompareISOLatin1 (s, "small") == 0)
	  screen->cur.fontsize = TEK_FONT_SMALL;
    }

    if(XmuCompareISOLatin1(tw->tek.gin_terminator_str, GIN_TERM_NONE_STR) == 0)
	screen->gin_terminator = GIN_TERM_NONE;
    else if(XmuCompareISOLatin1(tw->tek.gin_terminator_str, GIN_TERM_CR_STR) == 0)
	screen->gin_terminator = GIN_TERM_CR;
    else if(XmuCompareISOLatin1(tw->tek.gin_terminator_str, GIN_TERM_EOT_STR) == 0)
	screen->gin_terminator = GIN_TERM_EOT;
    else
	fprintf(stderr, "%s: illegal GIN terminator setting \"%s\"\n",
		xterm_name, tw->tek.gin_terminator_str);

    gcv.graphics_exposures = TRUE;	/* default */
    gcv.font = tw->tek.Tfont[screen->cur.fontsize]->fid;
    gcv.foreground = screen->Tforeground;
    gcv.background = screen->Tbackground;

    /* if font wasn't successfully opened, then gcv.font will contain
       the Default GC's ID, meaning that we must use the server default font.
     */
    TEKgcFontMask = (gcv.font == DefaultGCID) ? 0 : GCFont;
    screen->TnormalGC = XCreateGC (screen->display, TWindow(screen),
				   (TEKgcFontMask|GCGraphicsExposures|
				    GCForeground|GCBackground), &gcv);

    gcv.function = GXinvert;
    gcv.plane_mask = screen->xorplane = (screen->Tbackground ^
					 screen->Tcursorcolor);
    gcv.join_style = JoinMiter;	/* default */
    gcv.line_width = 1;
    screen->TcursorGC = XCreateGC (screen->display, TWindow(screen),
				   (GCFunction|GCPlaneMask), &gcv);

    gcv.foreground = screen->Tforeground;
    gcv.line_style = LineOnOffDash;
    gcv.line_width = 0;
    for(i = 0 ; i < TEKNUMLINES ; i++) {
	screen->linepat[i] = XCreateGC (screen->display, TWindow(screen),
					(GCForeground|GCLineStyle), &gcv);
	XSetDashes (screen->display, screen->linepat[i], 0,
		    (char *) dashes[i], dash_length[i]);
    }

    TekBackground(screen);

    screen->margin = MARGIN1;		/* Margin 1		*/
    screen->TekGIN = FALSE;			/* GIN off		*/


    XDefineCursor(screen->display, TShellWindow, screen->pointer_cursor);

    {	/* there's gotta be a better way... */
	static Arg args[] = {
	    {XtNtitle, (XtArgVal)NULL},
	    {XtNiconName, (XtArgVal)NULL},
	};
	char *icon_name, *title, *tek_icon_name, *tek_title;

	args[0].value = (XtArgVal)&icon_name;
	args[1].value = (XtArgVal)&title;
	XtGetValues (SHELL_OF(tw), args, 2);
	tek_icon_name = XtMalloc(strlen(icon_name)+7);
	strcpy(tek_icon_name, icon_name);
	strcat(tek_icon_name, "(Tek)");
	tek_title = XtMalloc(strlen(title)+7);
	strcpy(tek_title, title);
	strcat(tek_title, "(Tek)");
	args[0].value = (XtArgVal)tek_icon_name;
	args[1].value = (XtArgVal)tek_title;
	XtSetValues (SHELL_OF(tw), args, 2);
	XtFree( tek_icon_name );
	XtFree( tek_title );
    }

    tek = TekRecord = &Tek0;
    tek->next = (TekLink *)0;
    tek->fontsize = screen->cur.fontsize;
    tek->count = 0;
    tek->ptr = tek->data;
    Tpushback = Tpushb;
    Tbuffer->ptr = DecodedData(Tbuffer);
    screen->cur_X = 0;
    screen->cur_Y = TEKHOME;
    line_pt = Tline;
    Ttoggled = TRUE;
    screen->page = screen->cur;
    return;
}

void TekSetFontSize (int newitem)
{
    register TScreen *screen = &term->screen;
    int oldsize = screen->cur.fontsize;
    int newsize = MI2FS(newitem);
    Font fid;

    if (!tekWidget  ||  oldsize == newsize)
	return;
    if (!Ttoggled) TCursorToggle(TOGGLE);
    set_tekfont_menu_item (oldsize, FALSE);

    fid = tekWidget->tek.Tfont[newsize]->fid;
    if (fid == DefaultGCID)
       /* we didn't succeed in opening a real font
	  for this size.  Instead, use server default. */
       XCopyGC (screen->display,
		DefaultGC(screen->display, DefaultScreen(screen->display)),
		GCFont, screen->TnormalGC);
    else
       XSetFont (screen->display, screen->TnormalGC, fid);

    screen->cur.fontsize = newsize;
    set_tekfont_menu_item (newsize, TRUE);
    if (!Ttoggled) TCursorToggle(TOGGLE);
}

void
ChangeTekColors(register TScreen *screen, ScrnColors *pNew)
{
	register int i;
	XGCValues gcv;


	if (COLOR_DEFINED(pNew,TEK_FG)) {
	    screen->Tforeground=	COLOR_VALUE(pNew,TEK_FG);
	    XSetForeground(screen->display,screen->TnormalGC,
					   screen->Tforeground);
	}
	if (COLOR_DEFINED(pNew,TEK_BG)) {
	    screen->Tbackground=	COLOR_VALUE(pNew,TEK_BG);
	    XSetBackground(screen->display,screen->TnormalGC,
					   screen->Tbackground);
	}


	if (tekWidget) {
	    if (tekWidget->core.border_pixel == screen->Tbackground) {
		tekWidget->core.border_pixel = screen->Tforeground;
		XtParent(tekWidget)->core.border_pixel =
		  screen->Tforeground;
		if (XtWindow(XtParent(tekWidget)))
		  XSetWindowBorder (screen->display,
				    XtWindow(XtParent(tekWidget)),
				    tekWidget->core.border_pixel);
	    }
	}

	for(i = 0 ; i < TEKNUMLINES ; i++) {
		XSetForeground(screen->display, screen->linepat[i],
		 screen->Tforeground);
	}

	screen->Tcursorcolor = screen->Tforeground;

	gcv.plane_mask = screen->xorplane = (screen->Tbackground ^
					     screen->Tcursorcolor);
	XChangeGC (screen->display, screen->TcursorGC, GCPlaneMask, &gcv);
	TekBackground(screen);
	return;
}

void
TekReverseVideo(register TScreen *screen)
{
	register int i;
	XGCValues gcv;


	i = screen->Tbackground;
	screen->Tbackground = screen->Tforeground;
	screen->Tforeground = i;

	XSetForeground(screen->display, screen->TnormalGC,
	 screen->Tforeground);
	XSetBackground(screen->display, screen->TnormalGC,
	 screen->Tbackground);

	if (tekWidget) {
	    if (tekWidget->core.border_pixel == screen->Tbackground) {
		tekWidget->core.border_pixel = screen->Tforeground;
		XtParent(tekWidget)->core.border_pixel =
		  screen->Tforeground;
		if (XtWindow(XtParent(tekWidget)))
		  XSetWindowBorder (screen->display,
				    XtWindow(XtParent(tekWidget)),
				    tekWidget->core.border_pixel);
	    }
	}

	for(i = 0 ; i < TEKNUMLINES ; i++) {
		XSetForeground(screen->display, screen->linepat[i],
		 screen->Tforeground);
	}

	screen->Tcursorcolor = screen->Tforeground;

	gcv.plane_mask = screen->xorplane = (screen->Tbackground ^
					     screen->Tcursorcolor);
	XChangeGC (screen->display, screen->TcursorGC, GCPlaneMask, &gcv);
	TekBackground(screen);
}

static void
TekBackground(register TScreen *screen)
{
	if(TWindow(screen))
		XSetWindowBackground(screen->display, TWindow(screen),
		 screen->Tbackground);
}

/*
 * Toggles cursor on or off at cursor position in screen.
 */
void
TCursorToggle(int toggle)	/* TOGGLE or CLEAR */
{
	register TScreen *screen = &term->screen;
	register int c, x, y;
	unsigned int cellwidth, cellheight;

	if (!screen->Tshow) return;

	c = screen->cur.fontsize;
	cellwidth = (unsigned) tekWidget->tek.Tfont[c]->max_bounds.width;
	cellheight = (unsigned) (tekWidget->tek.Tfont[c]->ascent +
				 tekWidget->tek.Tfont[c]->descent);

	x = (int)((screen->cur_X * TekScale(screen)) + screen->border);
	y = (int)(((TEKHEIGHT + TEKTOPPAD - screen->cur_Y) * TekScale(screen))
	    + screen->border - tekWidget->tek.tobaseline[c]);

	if (toggle == TOGGLE) {
	   if (screen->select || screen->always_highlight)
	       XFillRectangle(screen->display, TWindow(screen),
			      screen->TcursorGC, x, y,
			      cellwidth, cellheight);
	   else { /* fix to use different GC! */
	       XDrawRectangle(screen->display, TWindow(screen),
			      screen->TcursorGC, x, y,
			      cellwidth-1, cellheight-1);
	   }
	} else {
	    /* Clear the entire rectangle, even though we may only
	     * have drawn an outline.  This fits with our refresh
	     * scheme of redrawing the entire window on any expose
	     * event and is easier than trying to figure out exactly
	     * which part of the cursor needs to be erased.
	     */
	    XClearArea(screen->display, TWindow(screen), x, y,
		       cellwidth, cellheight, FALSE);
	}
}

void TekSimulatePageButton (Bool reset)
{
    register TScreen *screen = &term->screen;

    if (!tekWidget)
	return;
    if (reset) {
	bzero ((char *) &screen->cur, sizeof screen->cur);
    }
    TekRefresh = (TekLink *)0;
    TekPage ();
    screen->cur_X = 0;
    screen->cur_Y = TEKHOME;
}

/* write copy of screen to a file */

void
TekCopy(void)
{
    TScreen *screen = &term->screen;

    TekLink *Tp;
    char buf[32];
    char initbuf[5];
    int tekcopyfd;

    timestamp_filename(buf, "COPY");
    if (access(buf, F_OK) >= 0
     && access(buf, W_OK) < 0) {
	Bell(XkbBI_MinorError,0);
	return;
    }

#ifndef VMS
    if(access(".", W_OK) < 0) {	/* can't write in directory */
	Bell(XkbBI_MinorError,0);
	return;
    }
#endif

    if ((tekcopyfd = open_userfile(screen->uid, screen->gid, buf, False)) >= 0) {
	sprintf(initbuf, "%c%c%c%c",
	    ESC, screen->page.fontsize + '8',
	    ESC, screen->page.linetype + '`');
	write(tekcopyfd, initbuf, 4);
	Tp = &Tek0;
	do {
	    write(tekcopyfd, (char *)Tp->data, Tp->count);
	    Tp = Tp->next;
	} while(Tp);
	close(tekcopyfd);
    }
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d6 2
a7 1
/* $XFree86: xc/programs/xterm/Tekproc.c,v 3.46 2003/10/24 20:38:23 tsi Exp $ */
d11 1
a11 1
Copyright 2001-2002,2003 by Thomas E. Dickey
d39 1
d62 1
a86 2
#define RES_OFFSET(field)	XtOffsetOf(TekWidgetRec, field)

d92 2
a96 2

#if defined(HAVE_LIB_XAW)
a97 6
#elif defined(HAVE_LIB_XAW3D)
#include <X11/Xaw3d/Form.h>
#elif defined(HAVE_LIB_NEXTAW)
#include <X11/neXtaw/Form.h>
#elif defined(HAVE_LIB_XAWPLUS)
#include <X11/XawPlus/Form.h>
a99 2
#endif /* OPT_TOOLBAR */

d109 8
d152 4
a155 1
/* *INDENT-OFF* */
d157 4
a160 4
    int hsize;			/* in Tek units */
    int vsize;			/* in Tek units */
    int charsperline;
    int nlines;
d162 4
a165 4
    {56, 88, 74, 35},		/* large */
    {51, 82, 81, 38},		/* #2 */
    {34, 53, 121, 58},		/* #3 */
    {31, 48, 133, 64},		/* small */
a166 1
/* *INDENT-ON* */
d196 2
a197 1
/* *INDENT-OFF* */
d225 1
a225 1
    { "set-scroll-on-tty-output", HandleScrollTtyOutput },
a238 1
/* *INDENT-ON* */
d256 1
a256 2
static XtResource resources[] =
{
d258 3
a260 1
    Cres(XtNbackground, XtCBackground, core.background_pixel, "White"),
d262 2
a263 2
     XtOffset(TekWidget, Tforeground),
     XtRString, "Black"},
d266 1
a266 1
     XtOffsetOf(CoreRec, core.width), XtRDimension, (caddr_t) & defOne},
d268 19
a286 7
     XtOffsetOf(CoreRec, core.height), XtRDimension, (caddr_t) & defOne},
    Fres("fontLarge", XtCFont, tek.Tfont[TEK_FONT_LARGE], "9x15"),
    Fres("font2", XtCFont, tek.Tfont[TEK_FONT_2], "6x13"),
    Fres("font3", XtCFont, tek.Tfont[TEK_FONT_3], "8x13"),
    Fres("fontSmall", XtCFont, tek.Tfont[TEK_FONT_SMALL], DFT_FONT_SMALL),
    Sres("initialFont", "InitialFont", tek.initial_font, "large"),
    Sres("ginTerminator", "GinTerminator", tek.gin_terminator_str, GIN_TERM_NONE_STR),
d289 5
a293 3
     XtOffsetOf(TekWidgetRec, tek.menu_bar),
     XtRWidget, (XtPointer) 0},
    Ires(XtNmenuHeight, XtCMenuHeight, tek.menu_height, 25),
d297 14
a310 19
static IChar Tinput(void);
static int getpoint(void);
static void TCursorBack(void);
static void TCursorDown(void);
static void TCursorForward(void);
static void TCursorUp(void);
static void TekBackground(TScreen * screen);
static void TekConfigure(Widget w);
static void TekDraw(int x, int y);
static void TekEnq(int status, int x, int y);
static void TekFlush(void);
static void TekInitialize(Widget request,
			  Widget wnew,
			  ArgList args,
			  Cardinal * num_args);
static void TekPage(void);
static void TekRealize(Widget gw,
		       XtValueMask * valuemaskp,
		       XSetWindowAttributes * values);
d312 2
a313 3
static WidgetClassRec tekClassRec =
{
    {
d315 33
a347 33
	(WidgetClass) & widgetClassRec,		/* superclass     */
	"Tek4014",		/* class_name                   */
	sizeof(TekWidgetRec),	/* widget_size                  */
	NULL,			/* class_initialize             */
	NULL,			/* class_part_initialize        */
	FALSE,			/* class_inited                 */
	TekInitialize,		/* initialize                   */
	NULL,			/* initialize_hook              */
	TekRealize,		/* realize                      */
	actionsList,		/* actions                      */
	XtNumber(actionsList),	/* num_actions                  */
	resources,		/* resources                    */
	XtNumber(resources),	/* num_resources                */
	NULLQUARK,		/* xrm_class                    */
	TRUE,			/* compress_motion              */
	TRUE,			/* compress_exposure            */
	TRUE,			/* compress_enterleave          */
	FALSE,			/* visible_interest             */
	NULL,			/* destroy                      */
	TekConfigure,		/* resize                       */
	TekExpose,		/* expose                       */
	NULL,			/* set_values                   */
	NULL,			/* set_values_hook              */
	NULL,			/* set_values_almost            */
	NULL,			/* get_values_hook              */
	NULL,			/* accept_focus                 */
	XtVersion,		/* version                      */
	NULL,			/* callback_offsets             */
	defaultTranslations,	/* tm_table                     */
	XtInheritQueryGeometry,	/* query_geometry               */
	XtInheritDisplayAccelerator,	/* display_accelerator  */
	NULL			/* extension                    */
    }
d353 1
a353 2
int
TekInit(void)
d358 1
a358 1
	&& tekWidget == 0) {
d360 4
a363 4
	tekshellwidget =
	    XtCreatePopupShell("tektronix", topLevelShellWidgetClass,
			       toplevel, ourTopLevelShellArgs,
			       number_ourTopLevelShellArgs);
d368 2
a369 3
	tekWidget = (TekWidget)
	    XtVaCreateManagedWidget("tek4014",
				    tekWidgetClass, form_top,
d371 6
a376 6
				    XtNmenuBar, menu_top,
				    XtNresizable, True,
				    XtNfromVert, menu_top,
				    XtNleft, XawChainLeft,
				    XtNright, XawChainRight,
				    XtNbottom, XawChainBottom,
d378 1
a378 1
				    (XtPointer) 0);
d390 6
a395 8
	if ((Tbuffer = (PtyData *) malloc(sizeof(PtyData))) == NULL
	    || (Tpushb = (Char *) malloc(10)) == NULL
	    || (Tline = (XSegment *) malloc(MAX_VTX * sizeof(XSegment))) == NULL) {
	    fprintf(stderr, "%s: Not enough core for Tek mode\n", xterm_name);
	    if (Tpushb)
		free((char *) Tpushb);
	    if (Tbuffer)
		free((char *) Tbuffer);
d403 1
a403 2
static void
Tekparse(void)
d405 12
a416 13
    register TScreen *screen = &term->screen;
    int x, y;
    IChar c = 0;
    IChar ch;
    int nextstate;

    for (;;) {
	c = input();
	/*
	 * The parsing tables all have 256 entries.  If we're supporting
	 * wide characters, we handle them by treating them the same as
	 * printing characters.
	 */
d418 5
a422 5
	if (c > 255) {
	    nextstate = (Tparsestate == Talptable)
		? CASE_PRINT
		: CASE_IGNORE;
	} else
d424 2
a425 2
	    nextstate = Tparsestate[c];
	TRACE(("Tekparse %04X -> %d\n", c, nextstate));
d427 15
a441 15
	switch (nextstate) {
	case CASE_REPORT:
	    TRACE(("case: report address\n"));
	    if (screen->TekGIN) {
		TekGINoff();
		TekEnqMouse(0);
	    } else {
		c = 064;	/* has hard copy unit */
		if (screen->margin == MARGIN2)
		    c |= 02;
		TekEnq(c, screen->cur_X, screen->cur_Y);
	    }
	    TekRecord->ptr[-1] = NAK;	/* remove from recording */
	    Tparsestate = curstate;
	    break;
d443 4
a446 4
	case CASE_VT_MODE:
	    TRACE(("case: special return to vt102 mode\n"));
	    Tparsestate = curstate;
	    TekRecord->ptr[-1] = NAK;	/* remove from recording */
d448 4
a451 4
	    if (screen->logging) {
		FlushLog(screen);
		screen->logstart = DecodedData(&(VTbuffer));
	    }
d453 1
a453 1
	    return;
d455 6
a460 6
	case CASE_SPT_STATE:
	    TRACE(("case: Enter Special Point Plot mode\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    Tparsestate = curstate = Tspttable;
	    break;
d462 11
a472 12
	case CASE_GIN:
	    TRACE(("case: Do Tek GIN mode\n"));
	    screen->TekGIN = &TekRecord->ptr[-1];
	    /* Set cross-hair cursor raster array */
	    if ((GINcursor =
		 make_colored_cursor(XC_tcross, screen->mousecolor,
				     screen->mousecolorback)) != 0) {
		XDefineCursor(screen->display, TWindow(screen),
			      GINcursor);
	    }
	    Tparsestate = Tbyptable;	/* Bypass mode */
	    break;
d474 8
a481 8
	case CASE_BEL:
	    TRACE(("case: BEL\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    if (!TekRefresh)
		Bell(XkbBI_TerminalBell, 0);
	    Tparsestate = curstate;	/* clear bypass condition */
	    break;
d483 7
a489 7
	case CASE_BS:
	    TRACE(("case: BS\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    Tparsestate = curstate;	/* clear bypass condition */
	    TCursorBack();
	    break;
d491 6
a496 6
	case CASE_PT_STATE:
	    TRACE(("case: Enter Tek Point Plot mode\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    Tparsestate = curstate = Tpttable;
	    break;
d498 12
a509 12
	case CASE_PLT_STATE:
	    TRACE(("case: Enter Tek Plot mode\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    Tparsestate = curstate = Tplttable;
	    if ((c = input()) == BEL)
		screen->pen = PENDOWN;
	    else {
		unput(c);
		screen->pen = PENUP;
	    }
	    break;
d511 7
a517 7
	case CASE_TAB:
	    TRACE(("case: HT\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    Tparsestate = curstate;	/* clear bypass condition */
	    TCursorForward();
	    break;
d519 6
a524 6
	case CASE_IPL_STATE:
	    TRACE(("case: Enter Tek Incremental Plot mode\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    Tparsestate = curstate = Tipltable;
	    break;
d526 9
a534 9
	case CASE_ALP_STATE:
	    TRACE(("case: Enter Tek Alpha mode from any other mode\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    /* if in one of graphics states, move alpha cursor */
	    if (nplot > 0)	/* flush line Tbuffer */
		TekFlush();
	    Tparsestate = curstate = Talptable;
	    break;
d536 7
a542 7
	case CASE_UP:
	    TRACE(("case: cursor up\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    Tparsestate = curstate;	/* clear bypass condition */
	    TCursorUp();
	    break;
d544 8
a551 8
	case CASE_COPY:
	    TRACE(("case: make copy\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    TekCopy();
	    TekRecord->ptr[-1] = NAK;	/* remove from recording */
	    Tparsestate = curstate;	/* clear bypass condition */
	    break;
d553 6
a558 6
	case CASE_PAGE:
	    TRACE(("case: Page Function\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    TekPage();		/* clear bypass condition */
	    break;
d560 4
a563 4
	case CASE_BES_STATE:
	    TRACE(("case: Byp: an escape char\n"));
	    Tparsestate = Tbestable;
	    break;
d565 4
a568 4
	case CASE_BYP_STATE:
	    TRACE(("case: set bypass condition\n"));
	    Tparsestate = Tbyptable;
	    break;
d570 3
a572 3
	case CASE_IGNORE:
	    TRACE(("case: Esc: totally ignore CR, ESC, LF, ~\n"));
	    break;
d574 5
a578 5
	case CASE_ASCII:
	    TRACE(("case: Select ASCII char set\n"));
	    /* ignore for now */
	    Tparsestate = curstate;
	    break;
d580 5
a584 5
	case CASE_APL:
	    TRACE(("case: Select APL char set\n"));
	    /* ignore for now */
	    Tparsestate = curstate;
	    break;
d586 5
a590 5
	case CASE_CHAR_SIZE:
	    TRACE(("case: character size selector\n"));
	    TekSetFontSize(c & 03);
	    Tparsestate = curstate;
	    break;
d592 11
a602 11
	case CASE_BEAM_VEC:
	    TRACE(("case: beam and vector selector\n"));
	    /* only line types */
	    if ((c &= LINEMASK) != screen->cur.linetype) {
		if (nplot > 0)
		    TekFlush();
		if (c <= TEKNUMLINES)
		    screen->cur.linetype = c;
	    }
	    Tparsestate = curstate;
	    break;
d604 3
a606 3
	case CASE_CURSTATE:
	    Tparsestate = curstate;
	    break;
d608 4
a611 4
	case CASE_PENUP:
	    TRACE(("case: Ipl: penup\n"));
	    screen->pen = PENUP;
	    break;
d613 4
a616 4
	case CASE_PENDOWN:
	    TRACE(("case: Ipl: pendown\n"));
	    screen->pen = PENDOWN;
	    break;
d618 17
a634 17
	case CASE_IPL_POINT:
	    TRACE(("case: Ipl: point\n"));
	    x = screen->cur_X;
	    y = screen->cur_Y;
	    if (c & NORTH)
		y++;
	    else if (c & SOUTH)
		y--;
	    if (c & EAST)
		x++;
	    else if (c & WEST)
		x--;
	    if (screen->pen == PENDOWN)
		TekDraw(x, y);
	    else
		TekMove(x, y);
	    break;
d636 11
a646 12
	case CASE_PLT_VEC:
	    TRACE(("case: Plt: vector\n"));
	    unput(c);
	    if (getpoint()) {
		if (screen->pen == PENDOWN) {
		    TekDraw(screen->cur.x, screen->cur.y);
		} else {
		    TekMove(screen->cur.x, screen->cur.y);
		}
		screen->pen = PENDOWN;
	    }
	    break;
d648 8
a655 8
	case CASE_PT_POINT:
	    TRACE(("case: Pt: point\n"));
	    unput(c);
	    if (getpoint()) {
		TekMove(screen->cur.x, screen->cur.y);
		TekDraw(screen->cur.x, screen->cur.y);
	    }
	    break;
d657 8
a664 8
	case CASE_SPT_POINT:
	    TRACE(("case: Spt: point\n"));
	    /* ignore intensity character in c */
	    if (getpoint()) {
		TekMove(screen->cur.x, screen->cur.y);
		TekDraw(screen->cur.x, screen->cur.y);
	    }
	    break;
d666 10
a675 10
	case CASE_CR:
	    TRACE(("case: CR\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    if (nplot > 0)	/* flush line Tbuffer */
		TekFlush();
	    screen->cur_X = screen->margin == MARGIN1 ? 0 :
		TEKWIDTH / 2;
	    Tparsestate = curstate = Talptable;
	    break;
d677 4
a680 4
	case CASE_ESC_STATE:
	    TRACE(("case: ESC\n"));
	    Tparsestate = Tesctable;
	    break;
d682 8
a689 8
	case CASE_LF:
	    TRACE(("case: LF\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    TCursorDown();
	    if (!TekRefresh)
		do_xevents();
	    break;
d691 4
a694 4
	case CASE_SP:
	    TRACE(("case: SP\n"));
	    TCursorForward();
	    break;
d696 6
a701 8
	case CASE_PRINT:
	    TRACE(("case: printable character\n"));
	    ch = c;
	    c = screen->cur.fontsize;
	    x = (int) (screen->cur_X * TekScale(screen))
		+ screen->border;
	    y = (int) ((TEKHEIGHT + TEKTOPPAD - screen->cur_Y) * TekScale(screen))
		+ screen->border;
d704 14
a717 13
	    if (screen->wide_chars
		&& (ch > 255)) {
		XChar2b sbuf;
		sbuf.byte2 = CharOf(ch);
		sbuf.byte1 = CharOf(ch >> 8);
		XDrawImageString16(screen->display,
				   TWindow(screen),
				   screen->TnormalGC,
				   x,
				   y,
				   &sbuf,
				   1);
	    } else
d719 2
a720 1
		XDrawString(screen->display,
d725 1
a725 1
			    (char *) &ch,
d727 20
a746 14
	    TCursorForward();
	    break;
	case CASE_OSC:
	    /* FIXME:  someone should disentangle the input queues
	     * of this code so that it can be state-driven.
	     */
	    TRACE(("case: do osc escape\n"));
	    {
		Char buf2[512];
		IChar c2;
		int len = 0;
		while ((c2 = input()) != BEL) {
		    if (!isprint(c2 & 0x7f)
			|| len + 2 >= (int) sizeof(buf2))
a747 1
		    buf2[len++] = c2;
a748 5
		if (c2 == BEL)
		    do_osc(buf2, len, BEL);
	    }
	    Tparsestate = curstate;
	    break;
a749 1
    }
d756 1
a756 1
#else /* VMS */
d760 1
a760 2
static IChar
Tinput(void)
d762 18
a779 14
    register TScreen *screen = &term->screen;
    register TekLink *tek;

    if (Tpushback > Tpushb)
	return (*--Tpushback);
    if (TekRefresh) {
	if (rcnt-- > 0)
	    return (*rptr++);
	if ((tek = TekRefresh->next) != 0) {
	    TekRefresh = tek;
	    rptr = tek->data;
	    rcnt = tek->count - 1;
	    TekSetFontSize(tek->fontsize);
	    return (*rptr++);
d781 4
a784 7
	TekRefresh = (TekLink *) 0;
	longjmp(Tekjump, 1);
    }
  again:
    if (Tbuffer->cnt-- <= 0) {
	if (nplot > 0)		/* flush line Tbuffer */
	    TekFlush();
d786 1
a786 1
	Tselect_mask = pty_mask;	/* force a read */
d788 1
a788 1
	XFD_COPYSET(&pty_mask, &Tselect_mask);
d790 1
a790 1
	for (;;) {
d792 6
a797 6
	    struct timeval crocktimeout;
	    crocktimeout.tv_sec = 0;
	    crocktimeout.tv_usec = 0;
	    (void) Select(max_plus1,
			  &Tselect_mask, NULL, NULL,
			  &crocktimeout);
d800 1
a800 1
	    if (Tselect_mask & pty_mask) {
d802 2
a803 2
		if (screen->logging)
		    FlushLog(screen);
d805 13
a817 15
		if (read_queue.flink != 0) {
		    Tbuffer->cnt = tt_read(Tbuffer->ptr = Tbuffer->buf);
		    if (Tbuffer->cnt == 0) {
			Panic("input: read returned zero\n", 0);
		    } else {
			break;
		    }
		} else {
		    sys$hiber();
		}
	    }
#else /* VMS */
	    if (getPtyData(screen, &Tselect_mask, Tbuffer)) {
		break;
	    }
d819 6
a824 5
	    if (Ttoggled && curstate == Talptable) {
		TCursorToggle(TOGGLE);
		Ttoggled = FALSE;
	    }
	    if (XtAppPending(app_con) & XtIMXEvent) {
d826 1
a826 1
		Tselect_mask = X_mask;
d828 1
a828 1
		XFD_COPYSET(&X_mask, &Tselect_mask);
d830 2
a831 2
	    } else {
		XFlush(screen->display);
d833 1
a833 1
		Tselect_mask = Select_mask;
d836 8
a843 6
		XFD_COPYSET(&Select_mask, &Tselect_mask);
		if (Select(max_plus1, &Tselect_mask, NULL, NULL, NULL) < 0) {
		    if (errno != EINTR)
			SysError(ERROR_TSELECT);
		    continue;
		}
d845 20
a864 1
	    }
d866 5
a870 5
	    if (Tselect_mask & X_mask) {
		xevents();
		if (Tbuffer->cnt > 0)
		    goto again;
	    }
d872 5
a876 5
	    if (FD_ISSET(ConnectionNumber(screen->display), &Tselect_mask)) {
		xevents();
		if (Tbuffer->cnt > 0)
		    goto again;
	    }
d878 6
d885 11
a895 4
	Tbuffer->cnt--;
	if (!Ttoggled && curstate == Talptable) {
	    TCursorToggle(TOGGLE);
	    Ttoggled = TRUE;
d897 2
a898 15
    }
    tek = TekRecord;
    if (tek->count >= TEK_LINK_BLOCK_SIZE
	|| tek->fontsize != screen->cur.fontsize) {
	if ((TekRecord = tek->next = (TekLink *) malloc(sizeof(TekLink)))
	    == (TekLink *) 0)
	    Panic("Tinput: malloc error (%d)\n", errno);
	tek = tek->next;
	tek->next = (TekLink *) 0;
	tek->fontsize = screen->cur.fontsize;
	tek->count = 0;
	tek->ptr = tek->data;
    }
    tek->count++;
    return (*tek->ptr++ = *(Tbuffer->ptr)++);
d902 1
a902 2
static void
TekConfigure(Widget w)
d908 1
a908 2
    if (TWindow(screen))
	XClearWindow(screen->display, TWindow(screen));
d911 4
a914 4
    TekScale(screen) = (double) TWidth(screen) / TEKWIDTH;
    if ((d = (double) THeight(screen) / (TEKHEIGHT + TEKTOPPAD + TEKBOTTOMPAD))
	< TekScale(screen))
	TekScale(screen) = d;
d921 4
a924 3
TekExpose(Widget w GCC_UNUSED,
	  XEvent * event GCC_UNUSED,
	  Region region GCC_UNUSED)
d926 1
a926 1
    register TScreen *screen = &term->screen;
d929 1
a929 1
    region = region;
d931 21
a951 21
    if (!Ttoggled)
	TCursorToggle(CLEAR);
    Ttoggled = TRUE;
    Tpushback = Tpushb;
    screen->cur_X = 0;
    screen->cur_Y = TEKHOME;
    TekSetFontSize(screen->page.fontsize);
    screen->cur = screen->page;
    screen->margin = MARGIN1;
    if (screen->TekGIN) {
	screen->TekGIN = NULL;
	TekGINoff();
    }
    TekRefresh = &Tek0;
    rptr = TekRefresh->data;
    rcnt = TekRefresh->count;
    Tparsestate = curstate = Talptable;
    if (waiting_for_initial_map)
	first_map_occurred();
    if (!screen->waitrefresh)
	dorefresh();
d957 2
a958 2
    register TScreen *screen = &term->screen;
    static Cursor wait_cursor = None;
d960 9
a968 9
    if (wait_cursor == None)
	wait_cursor = make_colored_cursor(XC_watch, screen->mousecolor,
					  screen->mousecolorback);
    XDefineCursor(screen->display, TWindow(screen), wait_cursor);
    XFlush(screen->display);
    if (!setjmp(Tekjump))
	Tekparse();
    XDefineCursor(screen->display, TWindow(screen),
		  (screen->TekGIN && GINcursor) ? GINcursor : screen->arrow);
d974 2
a975 2
    register TScreen *screen = &term->screen;
    register TekLink *tek;
d977 23
a999 23
    XClearWindow(screen->display, TWindow(screen));
    screen->cur_X = 0;
    screen->cur_Y = TEKHOME;
    screen->margin = MARGIN1;
    screen->page = screen->cur;
    if (screen->TekGIN)
	TekGINoff();
    tek = TekRecord = &Tek0;
    tek->fontsize = screen->cur.fontsize;
    tek->count = 0;
    tek->ptr = tek->data;
    tek = tek->next;
    if (tek)
	do {
	    TekLink *tek2 = tek->next;

	    free((char *) tek);
	    tek = tek2;
	} while (tek);
    TekRecord->next = (TekLink *) 0;
    TekRefresh = (TekLink *) 0;
    Ttoggled = TRUE;
    Tparsestate = curstate = Talptable;		/* Tek Alpha mode */
d1013 2
a1014 2
    register int c, x, y, e, lo_y = 0;
    register TScreen *screen = &term->screen;
d1016 37
a1052 37
    x = screen->cur.x;
    y = screen->cur.y;
    for (;;) {
	if ((c = input()) < ' ') {	/* control character */
	    unput(c);
	    return (0);
	}
	if (c < '@@') {		/* Hi X or Hi Y */
	    if (lo_y) {		/* seen a Lo Y, so this must be Hi X */
		x &= ~HIBITS;
		x |= (c & FIVEBITS) << SHIFTHI;
		continue;
	    }
	    /* else Hi Y */
	    y &= ~HIBITS;
	    y |= (c & FIVEBITS) << SHIFTHI;
	    continue;
	}
	if (c < '`') {		/* Lo X */
	    x &= ~LOBITS;
	    x |= (c & FIVEBITS) << SHIFTLO;
	    screen->cur.x = x;
	    screen->cur.y = y;
	    return (1);		/* OK */
	}
	/* else Lo Y */
	if (lo_y) {		/* seen a Lo Y, so other must be extra bits */
	    e = (y >> SHIFTLO) & EXTRABITS;
	    x &= ~TWOBITS;
	    x |= e & TWOBITS;
	    y &= ~TWOBITS;
	    y |= (e >> SHIFTLO) & TWOBITS;
	}
	y &= ~LOBITS;
	y |= (c & FIVEBITS) << SHIFTLO;
	lo_y++;
    }
d1058 7
a1064 7
    register TScreen *screen = &term->screen;
    register struct Tek_Char *t;
    register int x, l;

    x = (screen->cur_X -=
	 (t = &TekChar[screen->cur.fontsize])->hsize
	);
d1066 1
a1066 1
    if (((screen->margin == MARGIN1) && (x < 0))
d1068 7
a1074 4
	if ((l = (screen->cur_Y + (t->vsize - 1)) / t->vsize + 1) >=
	    t->nlines) {
	    screen->margin = !screen->margin;
	    l = 0;
a1075 3
	screen->cur_Y = l * t->vsize;
	screen->cur_X = (t->charsperline - 1) * t->hsize;
    }
d1081 14
a1094 11
    register TScreen *screen = &term->screen;
    register struct Tek_Char *t;
    register int l;

    if ((screen->cur_X +=
	 (t = &TekChar[screen->cur.fontsize])->hsize
	) > TEKWIDTH
	) {
	if ((l = screen->cur_Y / t->vsize - 1) < 0) {
	    screen->margin = !screen->margin;
	    l = t->nlines - 1;
a1095 3
	screen->cur_Y = l * t->vsize;
	screen->cur_X = screen->margin == MARGIN1 ? 0 : TEKWIDTH / 2;
    }
d1101 15
a1115 15
    register TScreen *screen = &term->screen;
    register struct Tek_Char *t;
    register int l;

    t = &TekChar[screen->cur.fontsize];

    if ((l = (screen->cur_Y + (t->vsize - 1)) / t->vsize + 1) >= t->nlines) {
	l = 0;
	if ((screen->margin = !screen->margin) != MARGIN1) {
	    if (screen->cur_X < TEKWIDTH / 2)
		screen->cur_X += TEKWIDTH / 2;
	} else if (screen->cur_X >= TEKWIDTH / 2)
	    screen->cur_X -= TEKWIDTH / 2;
    }
    screen->cur_Y = l * t->vsize;
d1121 15
a1135 15
    register TScreen *screen = &term->screen;
    register struct Tek_Char *t;
    register int l;

    t = &TekChar[screen->cur.fontsize];

    if ((l = screen->cur_Y / t->vsize - 1) < 0) {
	l = t->nlines - 1;
	if ((screen->margin = !screen->margin) != MARGIN1) {
	    if (screen->cur_X < TEKWIDTH / 2)
		screen->cur_X += TEKWIDTH / 2;
	} else if (screen->cur_X >= TEKWIDTH / 2)
	    screen->cur_X -= TEKWIDTH / 2;
    }
    screen->cur_Y = l * t->vsize;
d1141 2
a1142 2
    register TScreen *screen = &term->screen;
    register XSegment *lp;
d1144 11
a1154 13
    TRACE(("AddToDraw (%d,%d) (%d,%d)\n", x1, y1, x2, y2));
    if (nplot >= MAX_PTS) {
	TekFlush();
    }
    lp = line_pt++;
    lp->x1 = x1 = (int) (x1 * TekScale(screen) + screen->border);
    lp->y1 = y1 = (int) ((TEKHEIGHT + TEKTOPPAD - y1) * TekScale(screen) +
			 screen->border);
    lp->x2 = x2 = (int) (x2 * TekScale(screen) + screen->border);
    lp->y2 = y2 = (int) ((TEKHEIGHT + TEKTOPPAD - y2) * TekScale(screen) +
			 screen->border);
    nplot++;
    TRACE(("...AddToDraw %d points\n", nplot));
d1158 1
a1158 1
TekDraw(int x, int y)
d1160 1
a1160 1
    register TScreen *screen = &term->screen;
d1162 12
a1173 12
    if (nplot == 0 || T_lastx != screen->cur_X || T_lasty != screen->cur_Y) {
	/*
	 * We flush on each unconnected line segment if the line
	 * type is not solid.  This solves a bug in X when drawing
	 * points while the line type is not solid.
	 */
	if (nplot > 0 && screen->cur.linetype != SOLIDLINE)
	    TekFlush();
    }
    AddToDraw(screen->cur_X, screen->cur_Y, x, y);
    T_lastx = screen->cur_X = x;
    T_lasty = screen->cur_Y = y;
d1177 1
a1177 1
TekFlush(void)
d1179 1
a1179 1
    register TScreen *screen = &term->screen;
d1181 6
a1186 7
    TRACE(("TekFlush\n"));
    XDrawSegments(screen->display, TWindow(screen),
		  ((screen->cur.linetype == SOLIDLINE) ? screen->TnormalGC :
		   screen->linepat[screen->cur.linetype - 1]),
		  Tline, nplot);
    nplot = 0;
    line_pt = Tline;
d1192 1
a1192 1
    register TScreen *screen = &term->screen;
d1194 7
a1200 8
    TRACE(("TekGINoff\n"));
    XDefineCursor(screen->display, TWindow(screen), screen->arrow);
    if (GINcursor)
	XFreeCursor(screen->display, GINcursor);
    if (screen->TekGIN) {
	*screen->TekGIN = CAN;	/* modify recording */
	screen->TekGIN = NULL;
    }
d1206 27
a1232 28
    register TScreen *screen = &term->screen;
    int mousex, mousey, rootx, rooty;
    unsigned int mask;		/* XQueryPointer */
    Window root, subw;

    TRACE(("TekEnqMouse\n"));
    XQueryPointer(
		     screen->display, TWindow(screen),
		     &root, &subw,
		     &rootx, &rooty,
		     &mousex, &mousey,
		     &mask);
    if ((mousex = (int) ((mousex - screen->border) / TekScale(screen))) < 0)
	mousex = 0;
    else if (mousex >= TEKWIDTH)
	mousex = TEKWIDTH - 1;
    if ((mousey = (int) (TEKHEIGHT + TEKTOPPAD - (mousey - screen->border) /
			 TekScale(screen))) < 0)
	mousey = 0;
    else if (mousey >= TEKHEIGHT)
	mousey = TEKHEIGHT - 1;
    TekEnq(c, mousex, mousey);
}

static void
TekEnq(int status,
       register int x,
       register int y)
d1235 1
a1235 1
    Char cplot[7];
a1238 1
    TRACE(("TekEnq\n"));
d1251 1
a1251 1
    tt_write(cplot + adj, len - adj);
d1253 1
a1253 1
    v_write(screen->respond, cplot + adj, len - adj);
d1260 2
a1261 2
    register TScreen *screen = &term->screen;
    register int i;
d1263 6
a1268 4
    if (!TWindow(screen) && !TekInit()) {
	if (VWindow(screen)) {
	    screen->TekEmu = FALSE;
	    return;
d1270 13
a1282 20
	Exit(ERROR_TINIT);
    }
    if (!screen->Tshow) {
	set_tek_visibility(TRUE);
    }
    update_vttekmode();
    update_vtshow();
    update_tekshow();
    set_tekhide_sensitivity();

    Tpushback = Tpushb;
    Tbuffer->ptr = DecodedData(Tbuffer);
    for (i = Tbuffer->cnt = VTbuffer.cnt; i > 0; i--)
	*(Tbuffer->ptr)++ = *(VTbuffer.ptr)++;
    Tbuffer->ptr = DecodedData(Tbuffer);
    Ttoggled = TRUE;
    if (!setjmp(Tekend))
	Tekparse();
    if (!Ttoggled) {
	TCursorToggle(TOGGLE);
d1284 7
a1290 2
    }
    screen->TekEmu = FALSE;
d1298 5
a1302 6
static int dash_length[TEKNUMLINES] =
{
    DOTTED_LENGTH,
    DOT_DASHED_LENGTH,
    SHORT_DASHED_LENGTH,
    LONG_DASHED_LENGTH,
d1305 10
a1314 15
static unsigned char dotted[DOTTED_LENGTH] =
{3, 1};
static unsigned char dot_dashed[DOT_DASHED_LENGTH] =
{3, 4, 3, 1};
static unsigned char short_dashed[SHORT_DASHED_LENGTH] =
{4, 4};
static unsigned char long_dashed[LONG_DASHED_LENGTH] =
{4, 7};

static unsigned char *dashes[TEKNUMLINES] =
{
    dotted,
    dot_dashed,
    short_dashed,
    long_dashed,
d1317 2
d1323 5
a1327 5
static void
TekInitialize(Widget request GCC_UNUSED,
	      Widget wnew GCC_UNUSED,
	      ArgList args GCC_UNUSED,
	      Cardinal * num_args GCC_UNUSED)
a1330 2
    TRACE(("TekInitialize\n"));

d1335 1
a1335 1
		      HandleEnterWindow, (caddr_t) NULL);
d1337 1
a1337 1
		      HandleLeaveWindow, (caddr_t) NULL);
d1339 3
a1341 3
		      HandleFocusChange, (caddr_t) NULL);
    XtAddEventHandler((Widget) wnew, PropertyChangeMask, FALSE,
		      HandleBellPropertyChange, (Opaque) NULL);
d1344 5
a1348 4
static void
TekRealize(Widget gw,
	   XtValueMask * valuemaskp,
	   XSetWindowAttributes * values)
a1361 2
    TRACE(("TekRealize\n"));

d1369 2
a1370 3
	if (!tw->tek.Tfont[i]) {
	    tw->tek.Tfont[i] = XQueryFont(screen->display, DefaultGCID);
	}
d1393 1
a1393 1
	sprintf(Tdefault, "=%dx%d", defwidth + border, defheight + border);
d1402 1
a1402 5
    pr = XParseGeometry(term->misc.T_geometry,
			&winX,
			&winY,
			(unsigned int *) &width,
			(unsigned int *) &height);
d1404 2
a1405 2
	winX += DisplayWidth(screen->display, DefaultScreen(screen->display))
	    - width - (SHELL_OF(term)->core.border_width * 2);
d1407 2
a1408 2
	winY += DisplayHeight(screen->display, DefaultScreen(screen->display))
	    - height - (SHELL_OF(term)->core.border_width * 2);
d1415 1
a1415 1
    sizehints.flags = PMinSize | PResizeInc;
d1418 2
a1419 2
    if ((XValue & pr) || (YValue & pr)) {
	sizehints.flags |= USSize | USPosition;
d1422 1
a1422 1
	case 0:
d1425 1
a1425 1
	case XNegative:
d1428 1
a1428 1
	case YNegative:
d1431 1
a1431 1
	default:
d1440 3
a1442 4
    if ((WidthValue & pr) || (HeightValue & pr))
	sizehints.flags |= USSize;
    else
	sizehints.flags |= PSize;
d1444 2
a1445 2
    (void) XtMakeResizeRequest((Widget) tw, width, height,
			       &tw->core.width, &tw->core.height);
d1452 2
a1453 2
	XMoveWindow(XtDisplay(tw), XtWindow(SHELL_OF(tw)),
		    sizehints.x, sizehints.y);
d1455 3
a1457 3
    XSetWMNormalHints(XtDisplay(tw), XtWindow(SHELL_OF(tw)),
		      &sizehints);
    XFlush(XtDisplay(tw));	/* get it out to window manager */
d1463 8
a1470 8
	XCreateWindow(screen->display,
		      XtWindow(SHELL_OF(tw)),
		      tw->core.x, tw->core.y,
		      tw->core.width, tw->core.height, tw->core.border_width,
		      (int) tw->core.depth,
		      InputOutput, CopyFromParent,
		      ((*valuemaskp) | CWBackPixel | CWWinGravity),
		      values);
d1476 5
a1480 4
    TekScale(screen) = (double) TWidth(screen) / TEKWIDTH;
    if ((d = (double) THeight(screen) / (TEKHEIGHT + TEKTOPPAD +
					 TEKBOTTOMPAD)) < TekScale(screen))
	TekScale(screen) = d;
d1486 10
a1495 10
	if (XmuCompareISOLatin1(s, "large") == 0)
	    screen->cur.fontsize = TEK_FONT_LARGE;
	else if (XmuCompareISOLatin1(s, "2") == 0 ||
		 XmuCompareISOLatin1(s, "two") == 0)
	    screen->cur.fontsize = TEK_FONT_2;
	else if (XmuCompareISOLatin1(s, "3") == 0 ||
		 XmuCompareISOLatin1(s, "three") == 0)
	    screen->cur.fontsize = TEK_FONT_3;
	else if (XmuCompareISOLatin1(s, "small") == 0)
	    screen->cur.fontsize = TEK_FONT_SMALL;
a1496 1
#define TestGIN(s) XmuCompareISOLatin1(tw->tek.gin_terminator_str, s)
d1498 1
a1498 1
    if (TestGIN(GIN_TERM_NONE_STR) == 0)
d1500 1
a1500 1
    else if (TestGIN(GIN_TERM_CR_STR) == 0)
d1502 1
a1502 1
    else if (TestGIN(GIN_TERM_EOT_STR) == 0)
d1517 3
a1519 3
    screen->TnormalGC = XCreateGC(screen->display, TWindow(screen),
				  (TEKgcFontMask | GCGraphicsExposures |
				   GCForeground | GCBackground), &gcv);
d1526 2
a1527 2
    screen->TcursorGC = XCreateGC(screen->display, TWindow(screen),
				  (GCFunction | GCPlaneMask), &gcv);
d1532 5
a1536 5
    for (i = 0; i < TEKNUMLINES; i++) {
	screen->linepat[i] = XCreateGC(screen->display, TWindow(screen),
				       (GCForeground | GCLineStyle), &gcv);
	XSetDashes(screen->display, screen->linepat[i], 0,
		   (char *) dashes[i], dash_length[i]);
d1541 3
a1543 2
    screen->margin = MARGIN1;	/* Margin 1             */
    screen->TekGIN = FALSE;	/* GIN off              */
d1545 1
a1545 1
    XDefineCursor(screen->display, TWindow(screen), screen->pointer_cursor);
d1547 4
a1550 5
    {				/* there's gotta be a better way... */
	static Arg args[] =
	{
	    {XtNtitle, (XtArgVal) NULL},
	    {XtNiconName, (XtArgVal) NULL},
d1554 4
a1557 4
	args[0].value = (XtArgVal) & icon_name;
	args[1].value = (XtArgVal) & title;
	XtGetValues(SHELL_OF(tw), args, 2);
	tek_icon_name = XtMalloc(strlen(icon_name) + 7);
d1560 1
a1560 1
	tek_title = XtMalloc(strlen(title) + 7);
d1563 5
a1567 5
	args[0].value = (XtArgVal) tek_icon_name;
	args[1].value = (XtArgVal) tek_title;
	XtSetValues(SHELL_OF(tw), args, 2);
	XtFree(tek_icon_name);
	XtFree(tek_title);
d1571 1
a1571 1
    tek->next = (TekLink *) 0;
d1585 1
a1585 2
void
TekSetFontSize(int newitem)
d1592 1
a1592 1
    if (!tekWidget || oldsize == newsize)
d1594 2
a1595 3
    if (!Ttoggled)
	TCursorToggle(TOGGLE);
    set_tekfont_menu_item(oldsize, FALSE);
d1599 3
a1601 3
	/* we didn't succeed in opening a real font
	   for this size.  Instead, use server default. */
	XCopyGC(screen->display,
d1605 1
a1605 1
	XSetFont(screen->display, screen->TnormalGC, fid);
d1608 2
a1609 3
    set_tekfont_menu_item(newsize, TRUE);
    if (!Ttoggled)
	TCursorToggle(TOGGLE);
d1613 1
a1613 1
ChangeTekColors(register TScreen * screen, ScrnColors * pNew)
d1615 14
a1628 2
    register int i;
    XGCValues gcv;
a1629 10
    if (COLOR_DEFINED(pNew, TEK_FG)) {
	screen->Tforeground = COLOR_VALUE(pNew, TEK_FG);
	XSetForeground(screen->display, screen->TnormalGC,
		       screen->Tforeground);
    }
    if (COLOR_DEFINED(pNew, TEK_BG)) {
	screen->Tbackground = COLOR_VALUE(pNew, TEK_BG);
	XSetBackground(screen->display, screen->TnormalGC,
		       screen->Tbackground);
    }
d1631 10
a1640 9
    if (tekWidget) {
	if (tekWidget->core.border_pixel == screen->Tbackground) {
	    tekWidget->core.border_pixel = screen->Tforeground;
	    XtParent(tekWidget)->core.border_pixel =
		screen->Tforeground;
	    if (XtWindow(XtParent(tekWidget)))
		XSetWindowBorder(screen->display,
				 XtWindow(XtParent(tekWidget)),
				 tekWidget->core.border_pixel);
a1641 1
    }
d1643 4
a1646 4
    for (i = 0; i < TEKNUMLINES; i++) {
	XSetForeground(screen->display, screen->linepat[i],
		       screen->Tforeground);
    }
d1648 1
a1648 1
    screen->Tcursorcolor = screen->Tforeground;
d1650 5
a1654 5
    gcv.plane_mask = screen->xorplane = (screen->Tbackground ^
					 screen->Tcursorcolor);
    XChangeGC(screen->display, screen->TcursorGC, GCPlaneMask, &gcv);
    TekBackground(screen);
    return;
d1658 1
a1658 1
TekReverseVideo(register TScreen * screen)
d1660 12
a1671 2
    register int i;
    XGCValues gcv;
d1673 10
a1682 18
    i = screen->Tbackground;
    screen->Tbackground = screen->Tforeground;
    screen->Tforeground = i;

    XSetForeground(screen->display, screen->TnormalGC,
		   screen->Tforeground);
    XSetBackground(screen->display, screen->TnormalGC,
		   screen->Tbackground);

    if (tekWidget) {
	if (tekWidget->core.border_pixel == screen->Tbackground) {
	    tekWidget->core.border_pixel = screen->Tforeground;
	    XtParent(tekWidget)->core.border_pixel =
		screen->Tforeground;
	    if (XtWindow(XtParent(tekWidget)))
		XSetWindowBorder(screen->display,
				 XtWindow(XtParent(tekWidget)),
				 tekWidget->core.border_pixel);
a1683 1
    }
d1685 4
a1688 4
    for (i = 0; i < TEKNUMLINES; i++) {
	XSetForeground(screen->display, screen->linepat[i],
		       screen->Tforeground);
    }
d1690 1
a1690 1
    screen->Tcursorcolor = screen->Tforeground;
d1692 4
a1695 4
    gcv.plane_mask = screen->xorplane = (screen->Tbackground ^
					 screen->Tcursorcolor);
    XChangeGC(screen->display, screen->TcursorGC, GCPlaneMask, &gcv);
    TekBackground(screen);
d1699 1
a1699 1
TekBackground(register TScreen * screen)
d1701 3
a1703 3
    if (TWindow(screen))
	XSetWindowBackground(screen->display, TWindow(screen),
			     screen->Tbackground);
d1712 34
a1745 25
    register TScreen *screen = &term->screen;
    register int c, x, y;
    unsigned int cellwidth, cellheight;

    if (!screen->Tshow)
	return;

    c = screen->cur.fontsize;
    cellwidth = (unsigned) tekWidget->tek.Tfont[c]->max_bounds.width;
    cellheight = (unsigned) (tekWidget->tek.Tfont[c]->ascent +
			     tekWidget->tek.Tfont[c]->descent);

    x = (int) ((screen->cur_X * TekScale(screen)) + screen->border);
    y = (int) (((TEKHEIGHT + TEKTOPPAD - screen->cur_Y) * TekScale(screen))
	       + screen->border - tekWidget->tek.tobaseline[c]);

    if (toggle == TOGGLE) {
	if (screen->select || screen->always_highlight)
	    XFillRectangle(screen->display, TWindow(screen),
			   screen->TcursorGC, x, y,
			   cellwidth, cellheight);
	else {			/* fix to use different GC! */
	    XDrawRectangle(screen->display, TWindow(screen),
			   screen->TcursorGC, x, y,
			   cellwidth - 1, cellheight - 1);
a1746 10
    } else {
	/* Clear the entire rectangle, even though we may only
	 * have drawn an outline.  This fits with our refresh
	 * scheme of redrawing the entire window on any expose
	 * event and is easier than trying to figure out exactly
	 * which part of the cursor needs to be erased.
	 */
	XClearArea(screen->display, TWindow(screen), x, y,
		   cellwidth, cellheight, FALSE);
    }
d1749 1
a1749 2
void
TekSimulatePageButton(Bool reset)
d1756 1
a1756 1
	bzero((char *) &screen->cur, sizeof screen->cur);
d1758 2
a1759 2
    TekRefresh = (TekLink *) 0;
    TekPage();
d1778 2
a1779 2
	&& access(buf, W_OK) < 0) {
	Bell(XkbBI_MinorError, 0);
d1782 1
d1784 2
a1785 2
    if (access(".", W_OK) < 0) {	/* can't write in directory */
	Bell(XkbBI_MinorError, 0);
d1792 2
a1793 2
		ESC, screen->page.fontsize + '8',
		ESC, screen->page.linetype + '`');
d1797 1
a1797 1
	    write(tekcopyfd, (char *) Tp->data, Tp->count);
d1799 1
a1799 1
	} while (Tp);
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d6 2
a7 1
/* $XFree86: xc/programs/xterm/Tekproc.c,v 3.40 2003/02/25 23:36:55 dickey Exp $ */
d11 1
a11 1
Copyright 2001-2002,2003 by Thomas E. Dickey
d39 1
d62 1
d92 2
a96 2

#if defined(HAVE_LIB_XAW)
a97 4
#elif defined(HAVE_LIB_XAW3D)
#include <X11/Xaw3d/Form.h>
#elif defined(HAVE_LIB_NEXTAW)
#include <X11/neXtaw/Form.h>
a99 2
#endif /* OPT_TOOLBAR */

d109 8
d152 4
a155 1
/* *INDENT-OFF* */
d157 4
a160 4
    int hsize;			/* in Tek units */
    int vsize;			/* in Tek units */
    int charsperline;
    int nlines;
d162 4
a165 4
    {56, 88, 74, 35},		/* large */
    {51, 82, 81, 38},		/* #2 */
    {34, 53, 121, 58},		/* #3 */
    {31, 48, 133, 64},		/* small */
a166 1
/* *INDENT-ON* */
d196 2
a197 1
/* *INDENT-OFF* */
d225 1
a225 1
    { "set-scroll-on-tty-output", HandleScrollTtyOutput },
a238 1
/* *INDENT-ON* */
d256 1
a256 2
static XtResource resources[] =
{
d259 2
a260 2
     XtOffset(TekWidget, core.background_pixel),
     XtRString, "White"},
d262 2
a263 2
     XtOffset(TekWidget, Tforeground),
     XtRString, "Black"},
d266 1
a266 1
     XtOffsetOf(CoreRec, core.width), XtRDimension, (caddr_t) & defOne},
d268 1
a268 1
     XtOffsetOf(CoreRec, core.height), XtRDimension, (caddr_t) & defOne},
d270 2
a271 2
     XtOffsetOf(TekWidgetRec, tek.Tfont[TEK_FONT_LARGE]),
     XtRString, "9x15"},
d273 2
a274 2
     XtOffsetOf(TekWidgetRec, tek.Tfont[TEK_FONT_2]),
     XtRString, "6x13"},
d276 2
a277 2
     XtOffsetOf(TekWidgetRec, tek.Tfont[TEK_FONT_3]),
     XtRString, "8x13"},
d279 2
a280 2
     XtOffsetOf(TekWidgetRec, tek.Tfont[TEK_FONT_SMALL]),
     XtRString, DFT_FONT_SMALL},
d282 2
a283 2
     XtOffsetOf(TekWidgetRec, tek.initial_font),
     XtRString, "large"},
d285 2
a286 2
     XtOffsetOf(TekWidgetRec, tek.gin_terminator_str),
     XtRString, GIN_TERM_NONE_STR},
d289 2
a290 2
     XtOffsetOf(TekWidgetRec, tek.menu_bar),
     XtRWidget, (XtPointer) 0},
d292 2
a293 2
     XtOffsetOf(TekWidgetRec, tek.menu_height),
     XtRString, "25"},
d297 14
a310 19
static int Tinput(void);
static int getpoint(void);
static void TCursorBack(void);
static void TCursorDown(void);
static void TCursorForward(void);
static void TCursorUp(void);
static void TekBackground(TScreen * screen);
static void TekConfigure(Widget w);
static void TekDraw(int x, int y);
static void TekEnq(int status, int x, int y);
static void TekFlush(void);
static void TekInitialize(Widget request,
			  Widget wnew,
			  ArgList args,
			  Cardinal * num_args);
static void TekPage(void);
static void TekRealize(Widget gw,
		       XtValueMask * valuemaskp,
		       XSetWindowAttributes * values);
d312 2
a313 3
static WidgetClassRec tekClassRec =
{
    {
d315 33
a347 33
	(WidgetClass) & widgetClassRec,		/* superclass     */
	"Tek4014",		/* class_name                   */
	sizeof(TekWidgetRec),	/* widget_size                  */
	NULL,			/* class_initialize             */
	NULL,			/* class_part_initialize        */
	FALSE,			/* class_inited                 */
	TekInitialize,		/* initialize                   */
	NULL,			/* initialize_hook              */
	TekRealize,		/* realize                      */
	actionsList,		/* actions                      */
	XtNumber(actionsList),	/* num_actions                  */
	resources,		/* resources                    */
	XtNumber(resources),	/* num_resources                */
	NULLQUARK,		/* xrm_class                    */
	TRUE,			/* compress_motion              */
	TRUE,			/* compress_exposure            */
	TRUE,			/* compress_enterleave          */
	FALSE,			/* visible_interest             */
	NULL,			/* destroy                      */
	TekConfigure,		/* resize                       */
	TekExpose,		/* expose                       */
	NULL,			/* set_values                   */
	NULL,			/* set_values_hook              */
	NULL,			/* set_values_almost            */
	NULL,			/* get_values_hook              */
	NULL,			/* accept_focus                 */
	XtVersion,		/* version                      */
	NULL,			/* callback_offsets             */
	defaultTranslations,	/* tm_table                     */
	XtInheritQueryGeometry,	/* query_geometry               */
	XtInheritDisplayAccelerator,	/* display_accelerator  */
	NULL			/* extension                    */
    }
d353 1
a353 2
int
TekInit(void)
d358 1
a358 1
	&& tekWidget == 0) {
d360 4
a363 4
	tekshellwidget =
	    XtCreatePopupShell("tektronix", topLevelShellWidgetClass,
			       toplevel, ourTopLevelShellArgs,
			       number_ourTopLevelShellArgs);
d368 2
a369 3
	tekWidget = (TekWidget)
	    XtVaCreateManagedWidget("tek4014",
				    tekWidgetClass, form_top,
d371 6
a376 6
				    XtNmenuBar, menu_top,
				    XtNresizable, True,
				    XtNfromVert, menu_top,
				    XtNleft, XawChainLeft,
				    XtNright, XawChainRight,
				    XtNbottom, XawChainBottom,
d378 1
a378 1
				    (XtPointer) 0);
d390 6
a395 8
	if ((Tbuffer = (PtyData *) malloc(sizeof(PtyData))) == NULL
	    || (Tpushb = (Char *) malloc(10)) == NULL
	    || (Tline = (XSegment *) malloc(MAX_VTX * sizeof(XSegment))) == NULL) {
	    fprintf(stderr, "%s: Not enough core for Tek mode\n", xterm_name);
	    if (Tpushb)
		free((char *) Tpushb);
	    if (Tbuffer)
		free((char *) Tbuffer);
d403 1
a403 2
static void
Tekparse(void)
d405 12
a416 12
    register TScreen *screen = &term->screen;
    register int c = 0, x, y;
    Char ch;
    int nextstate;

    for (;;) {
	c = input();
	/*
	 * The parsing tables all have 256 entries.  If we're supporting
	 * wide characters, we handle them by treating them the same as
	 * printing characters.
	 */
d418 5
a422 5
	if (c > 255) {
	    nextstate = (Tparsestate == Talptable)
		? CASE_PRINT
		: CASE_IGNORE;
	} else
d424 2
a425 2
	    nextstate = Tparsestate[c];
	TRACE(("Tekparse %d -> %d\n", c, nextstate));
d427 15
a441 15
	switch (nextstate) {
	case CASE_REPORT:
	    TRACE(("case: report address\n"));
	    if (screen->TekGIN) {
		TekGINoff();
		TekEnqMouse(0);
	    } else {
		c = 064;	/* has hard copy unit */
		if (screen->margin == MARGIN2)
		    c |= 02;
		TekEnq(c, screen->cur_X, screen->cur_Y);
	    }
	    TekRecord->ptr[-1] = NAK;	/* remove from recording */
	    Tparsestate = curstate;
	    break;
d443 4
a446 4
	case CASE_VT_MODE:
	    TRACE(("case: special return to vt102 mode\n"));
	    Tparsestate = curstate;
	    TekRecord->ptr[-1] = NAK;	/* remove from recording */
d448 4
a451 4
	    if (screen->logging) {
		FlushLog(screen);
		screen->logstart = DecodedData(&(VTbuffer));
	    }
d453 1
a453 1
	    return;
d455 6
a460 6
	case CASE_SPT_STATE:
	    TRACE(("case: Enter Special Point Plot mode\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    Tparsestate = curstate = Tspttable;
	    break;
d462 11
a472 12
	case CASE_GIN:
	    TRACE(("case: Do Tek GIN mode\n"));
	    screen->TekGIN = &TekRecord->ptr[-1];
	    /* Set cross-hair cursor raster array */
	    if ((GINcursor =
		 make_colored_cursor(XC_tcross, screen->mousecolor,
				     screen->mousecolorback)) != 0) {
		XDefineCursor(screen->display, TWindow(screen),
			      GINcursor);
	    }
	    Tparsestate = Tbyptable;	/* Bypass mode */
	    break;
d474 8
a481 8
	case CASE_BEL:
	    TRACE(("case: BEL\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    if (!TekRefresh)
		Bell(XkbBI_TerminalBell, 0);
	    Tparsestate = curstate;	/* clear bypass condition */
	    break;
d483 7
a489 7
	case CASE_BS:
	    TRACE(("case: BS\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    Tparsestate = curstate;	/* clear bypass condition */
	    TCursorBack();
	    break;
d491 6
a496 6
	case CASE_PT_STATE:
	    TRACE(("case: Enter Tek Point Plot mode\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    Tparsestate = curstate = Tpttable;
	    break;
d498 12
a509 12
	case CASE_PLT_STATE:
	    TRACE(("case: Enter Tek Plot mode\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    Tparsestate = curstate = Tplttable;
	    if ((c = input()) == BEL)
		screen->pen = PENDOWN;
	    else {
		unput(c);
		screen->pen = PENUP;
	    }
	    break;
d511 7
a517 7
	case CASE_TAB:
	    TRACE(("case: HT\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    Tparsestate = curstate;	/* clear bypass condition */
	    TCursorForward();
	    break;
d519 6
a524 6
	case CASE_IPL_STATE:
	    TRACE(("case: Enter Tek Incremental Plot mode\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    Tparsestate = curstate = Tipltable;
	    break;
d526 9
a534 9
	case CASE_ALP_STATE:
	    TRACE(("case: Enter Tek Alpha mode from any other mode\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    /* if in one of graphics states, move alpha cursor */
	    if (nplot > 0)	/* flush line Tbuffer */
		TekFlush();
	    Tparsestate = curstate = Talptable;
	    break;
d536 7
a542 7
	case CASE_UP:
	    TRACE(("case: cursor up\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    Tparsestate = curstate;	/* clear bypass condition */
	    TCursorUp();
	    break;
d544 8
a551 8
	case CASE_COPY:
	    TRACE(("case: make copy\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    TekCopy();
	    TekRecord->ptr[-1] = NAK;	/* remove from recording */
	    Tparsestate = curstate;	/* clear bypass condition */
	    break;
d553 6
a558 6
	case CASE_PAGE:
	    TRACE(("case: Page Function\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    TekPage();		/* clear bypass condition */
	    break;
d560 4
a563 4
	case CASE_BES_STATE:
	    TRACE(("case: Byp: an escape char\n"));
	    Tparsestate = Tbestable;
	    break;
d565 4
a568 4
	case CASE_BYP_STATE:
	    TRACE(("case: set bypass condition\n"));
	    Tparsestate = Tbyptable;
	    break;
d570 3
a572 3
	case CASE_IGNORE:
	    TRACE(("case: Esc: totally ignore CR, ESC, LF, ~\n"));
	    break;
d574 5
a578 5
	case CASE_ASCII:
	    TRACE(("case: Select ASCII char set\n"));
	    /* ignore for now */
	    Tparsestate = curstate;
	    break;
d580 5
a584 5
	case CASE_APL:
	    TRACE(("case: Select APL char set\n"));
	    /* ignore for now */
	    Tparsestate = curstate;
	    break;
d586 5
a590 5
	case CASE_CHAR_SIZE:
	    TRACE(("case: character size selector\n"));
	    TekSetFontSize(c & 03);
	    Tparsestate = curstate;
	    break;
d592 11
a602 11
	case CASE_BEAM_VEC:
	    TRACE(("case: beam and vector selector\n"));
	    /* only line types */
	    if ((c &= LINEMASK) != screen->cur.linetype) {
		if (nplot > 0)
		    TekFlush();
		if (c <= TEKNUMLINES)
		    screen->cur.linetype = c;
	    }
	    Tparsestate = curstate;
	    break;
d604 3
a606 3
	case CASE_CURSTATE:
	    Tparsestate = curstate;
	    break;
d608 4
a611 4
	case CASE_PENUP:
	    TRACE(("case: Ipl: penup\n"));
	    screen->pen = PENUP;
	    break;
d613 4
a616 4
	case CASE_PENDOWN:
	    TRACE(("case: Ipl: pendown\n"));
	    screen->pen = PENDOWN;
	    break;
d618 17
a634 17
	case CASE_IPL_POINT:
	    TRACE(("case: Ipl: point\n"));
	    x = screen->cur_X;
	    y = screen->cur_Y;
	    if (c & NORTH)
		y++;
	    else if (c & SOUTH)
		y--;
	    if (c & EAST)
		x++;
	    else if (c & WEST)
		x--;
	    if (screen->pen == PENDOWN)
		TekDraw(x, y);
	    else
		TekMove(x, y);
	    break;
d636 11
a646 11
	case CASE_PLT_VEC:
	    TRACE(("case: Plt: vector\n"));
	    unput(c);
	    if (getpoint()) {
		if (screen->pen == PENDOWN)
		    TekDraw(screen->cur.x, screen->cur.y);
		else
		    TekMove(screen->cur.x, screen->cur.y);
		screen->pen = PENDOWN;
	    }
	    break;
d648 8
a655 8
	case CASE_PT_POINT:
	    TRACE(("case: Pt: point\n"));
	    unput(c);
	    if (getpoint()) {
		TekMove(screen->cur.x, screen->cur.y);
		TekDraw(screen->cur.x, screen->cur.y);
	    }
	    break;
d657 8
a664 8
	case CASE_SPT_POINT:
	    TRACE(("case: Spt: point\n"));
	    /* ignore intensity character in c */
	    if (getpoint()) {
		TekMove(screen->cur.x, screen->cur.y);
		TekDraw(screen->cur.x, screen->cur.y);
	    }
	    break;
d666 10
a675 10
	case CASE_CR:
	    TRACE(("case: CR\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    if (nplot > 0)	/* flush line Tbuffer */
		TekFlush();
	    screen->cur_X = screen->margin == MARGIN1 ? 0 :
		TEKWIDTH / 2;
	    Tparsestate = curstate = Talptable;
	    break;
d677 4
a680 4
	case CASE_ESC_STATE:
	    TRACE(("case: ESC\n"));
	    Tparsestate = Tesctable;
	    break;
d682 8
a689 8
	case CASE_LF:
	    TRACE(("case: LF\n"));
	    if (screen->TekGIN)
		TekGINoff();
	    TCursorDown();
	    if (!TekRefresh)
		do_xevents();
	    break;
d691 4
a694 4
	case CASE_SP:
	    TRACE(("case: SP\n"));
	    TCursorForward();
	    break;
d696 6
a701 8
	case CASE_PRINT:
	    TRACE(("case: printable character\n"));
	    ch = c;
	    c = screen->cur.fontsize;
	    x = (int) (screen->cur_X * TekScale(screen))
		+ screen->border;
	    y = (int) ((TEKHEIGHT + TEKTOPPAD - screen->cur_Y) * TekScale(screen))
		+ screen->border;
d704 14
a717 13
	    if (screen->wide_chars
		&& (ch > 255)) {
		XChar2b sbuf;
		sbuf.byte2 = CharOf(ch);
		sbuf.byte1 = CharOf(ch >> 8);
		XDrawImageString16(screen->display,
				   TWindow(screen),
				   screen->TnormalGC,
				   x,
				   y,
				   &sbuf,
				   1);
	    } else
d719 2
a720 1
		XDrawString(screen->display,
d725 1
a725 1
			    (char *) &ch,
d727 20
a746 13
	    TCursorForward();
	    break;
	case CASE_OSC:
	    /* FIXME:  someone should disentangle the input queues
	     * of this code so that it can be state-driven.
	     */
	    TRACE(("case: do osc escape\n"));
	    {
		Char buf2[512];
		int c2, len = 0;
		while ((c2 = Tinput()) != BEL) {
		    if (!isprint(c2 & 0x7f)
			|| len + 2 >= (int) sizeof(buf2))
a747 1
		    buf2[len++] = c2;
a748 5
		if (c2 == BEL)
		    do_osc(buf2, len, BEL);
	    }
	    Tparsestate = curstate;
	    break;
a749 1
    }
d756 1
a756 1
#else /* VMS */
d760 1
a760 2
static int
Tinput(void)
d762 18
a779 15
    register TScreen *screen = &term->screen;
    register int i;
    register TekLink *tek;

    if (Tpushback > Tpushb)
	return (*--Tpushback);
    if (TekRefresh) {
	if (rcnt-- > 0)
	    return (*rptr++);
	if ((tek = TekRefresh->next) != 0) {
	    TekRefresh = tek;
	    rptr = tek->data;
	    rcnt = tek->count - 1;
	    TekSetFontSize(tek->fontsize);
	    return (*rptr++);
d781 4
a784 7
	TekRefresh = (TekLink *) 0;
	longjmp(Tekjump, 1);
    }
  again:
    if (Tbuffer->cnt-- <= 0) {
	if (nplot > 0)		/* flush line Tbuffer */
	    TekFlush();
d786 1
a786 1
	Tselect_mask = pty_mask;	/* force a read */
d788 1
a788 1
	XFD_COPYSET(&pty_mask, &Tselect_mask);
d790 1
a790 1
	for (;;) {
d792 6
a797 6
	    struct timeval crocktimeout;
	    crocktimeout.tv_sec = 0;
	    crocktimeout.tv_usec = 0;
	    (void) Select(max_plus1,
			  &Tselect_mask, NULL, NULL,
			  &crocktimeout);
d800 1
a800 1
	    if (Tselect_mask & pty_mask) {
d802 2
a803 2
		if (screen->logging)
		    FlushLog(screen);
d805 13
a817 15
		if (read_queue.flink != 0) {
		    Tbuffer->cnt = tt_read(Tbuffer->ptr = Tbuffer->buf);
		    if (Tbuffer->cnt == 0) {
			Panic("input: read returned zero\n", 0);
		    } else {
			break;
		    }
		} else {
		    sys$hiber();
		}
	    }
#else /* VMS */
	    if (getPtyData(screen, &Tselect_mask, Tbuffer)) {
		break;
	    }
d819 6
a824 5
	    if (Ttoggled && curstate == Talptable) {
		TCursorToggle(TOGGLE);
		Ttoggled = FALSE;
	    }
	    if (XtAppPending(app_con) & XtIMXEvent) {
d826 1
a826 1
		Tselect_mask = X_mask;
d828 1
a828 1
		XFD_COPYSET(&X_mask, &Tselect_mask);
d830 2
a831 2
	    } else {
		XFlush(screen->display);
d833 1
a833 1
		Tselect_mask = Select_mask;
d836 8
a843 8
		XFD_COPYSET(&Select_mask, &Tselect_mask);
		if ((i = Select(max_plus1,
				&Tselect_mask, NULL, NULL,
				NULL)) < 0) {
		    if (errno != EINTR)
			SysError(ERROR_TSELECT);
		    continue;
		}
d845 20
a864 1
	    }
d866 5
a870 5
	    if (Tselect_mask & X_mask) {
		xevents();
		if (Tbuffer->cnt > 0)
		    goto again;
	    }
d872 5
a876 5
	    if (FD_ISSET(ConnectionNumber(screen->display), &Tselect_mask)) {
		xevents();
		if (Tbuffer->cnt > 0)
		    goto again;
	    }
d878 6
d885 11
a895 4
	Tbuffer->cnt--;
	if (!Ttoggled && curstate == Talptable) {
	    TCursorToggle(TOGGLE);
	    Ttoggled = TRUE;
d897 2
a898 15
    }
    tek = TekRecord;
    if (tek->count >= TEK_LINK_BLOCK_SIZE
	|| tek->fontsize != screen->cur.fontsize) {
	if ((TekRecord = tek->next = (TekLink *) malloc(sizeof(TekLink)))
	    == (TekLink *) 0)
	    Panic("Tinput: malloc error (%d)\n", errno);
	tek = tek->next;
	tek->next = (TekLink *) 0;
	tek->fontsize = screen->cur.fontsize;
	tek->count = 0;
	tek->ptr = tek->data;
    }
    tek->count++;
    return (*tek->ptr++ = *(Tbuffer->ptr)++);
d902 1
a902 2
static void
TekConfigure(Widget w)
d908 1
a908 2
    if (TWindow(screen))
	XClearWindow(screen->display, TWindow(screen));
d911 4
a914 4
    TekScale(screen) = (double) TWidth(screen) / TEKWIDTH;
    if ((d = (double) THeight(screen) / (TEKHEIGHT + TEKTOPPAD + TEKBOTTOMPAD))
	< TekScale(screen))
	TekScale(screen) = d;
d921 4
a924 3
TekExpose(Widget w GCC_UNUSED,
	  XEvent * event GCC_UNUSED,
	  Region region GCC_UNUSED)
d926 1
a926 1
    register TScreen *screen = &term->screen;
d929 1
a929 1
    region = region;
d931 21
a951 21
    if (!Ttoggled)
	TCursorToggle(CLEAR);
    Ttoggled = TRUE;
    Tpushback = Tpushb;
    screen->cur_X = 0;
    screen->cur_Y = TEKHOME;
    TekSetFontSize(screen->page.fontsize);
    screen->cur = screen->page;
    screen->margin = MARGIN1;
    if (screen->TekGIN) {
	screen->TekGIN = NULL;
	TekGINoff();
    }
    TekRefresh = &Tek0;
    rptr = TekRefresh->data;
    rcnt = TekRefresh->count;
    Tparsestate = curstate = Talptable;
    if (waiting_for_initial_map)
	first_map_occurred();
    if (!screen->waitrefresh)
	dorefresh();
d957 2
a958 2
    register TScreen *screen = &term->screen;
    static Cursor wait_cursor = None;
d960 9
a968 9
    if (wait_cursor == None)
	wait_cursor = make_colored_cursor(XC_watch, screen->mousecolor,
					  screen->mousecolorback);
    XDefineCursor(screen->display, TShellWindow, wait_cursor);
    XFlush(screen->display);
    if (!setjmp(Tekjump))
	Tekparse();
    XDefineCursor(screen->display, TShellWindow,
		  (screen->TekGIN && GINcursor) ? GINcursor : screen->arrow);
d974 2
a975 2
    register TScreen *screen = &term->screen;
    register TekLink *tek;
d977 23
a999 23
    XClearWindow(screen->display, TWindow(screen));
    screen->cur_X = 0;
    screen->cur_Y = TEKHOME;
    screen->margin = MARGIN1;
    screen->page = screen->cur;
    if (screen->TekGIN)
	TekGINoff();
    tek = TekRecord = &Tek0;
    tek->fontsize = screen->cur.fontsize;
    tek->count = 0;
    tek->ptr = tek->data;
    tek = tek->next;
    if (tek)
	do {
	    TekLink *tek2 = tek->next;

	    free((char *) tek);
	    tek = tek2;
	} while (tek);
    TekRecord->next = (TekLink *) 0;
    TekRefresh = (TekLink *) 0;
    Ttoggled = TRUE;
    Tparsestate = curstate = Talptable;		/* Tek Alpha mode */
d1013 2
a1014 2
    register int c, x, y, e, lo_y = 0;
    register TScreen *screen = &term->screen;
d1016 37
a1052 37
    x = screen->cur.x;
    y = screen->cur.y;
    for (;;) {
	if ((c = input()) < ' ') {	/* control character */
	    unput(c);
	    return (0);
	}
	if (c < '@@') {		/* Hi X or Hi Y */
	    if (lo_y) {		/* seen a Lo Y, so this must be Hi X */
		x &= ~HIBITS;
		x |= (c & FIVEBITS) << SHIFTHI;
		continue;
	    }
	    /* else Hi Y */
	    y &= ~HIBITS;
	    y |= (c & FIVEBITS) << SHIFTHI;
	    continue;
	}
	if (c < '`') {		/* Lo X */
	    x &= ~LOBITS;
	    x |= (c & FIVEBITS) << SHIFTLO;
	    screen->cur.x = x;
	    screen->cur.y = y;
	    return (1);		/* OK */
	}
	/* else Lo Y */
	if (lo_y) {		/* seen a Lo Y, so other must be extra bits */
	    e = (y >> SHIFTLO) & EXTRABITS;
	    x &= ~TWOBITS;
	    x |= e & TWOBITS;
	    y &= ~TWOBITS;
	    y |= (e >> SHIFTLO) & TWOBITS;
	}
	y &= ~LOBITS;
	y |= (c & FIVEBITS) << SHIFTLO;
	lo_y++;
    }
d1058 7
a1064 3
    register TScreen *screen = &term->screen;
    register struct Tek_Char *t;
    register int x, l;
d1066 1
a1066 5
    x = (screen->cur_X -=
	 (t = &TekChar[screen->cur.fontsize])->hsize
	);

    if (((screen->margin == MARGIN1) && (x < 0))
d1068 7
a1074 4
	if ((l = (screen->cur_Y + (t->vsize - 1)) / t->vsize + 1) >=
	    t->nlines) {
	    screen->margin = !screen->margin;
	    l = 0;
a1075 3
	screen->cur_Y = l * t->vsize;
	screen->cur_X = (t->charsperline - 1) * t->hsize;
    }
d1081 14
a1094 11
    register TScreen *screen = &term->screen;
    register struct Tek_Char *t;
    register int l;

    if ((screen->cur_X +=
	 (t = &TekChar[screen->cur.fontsize])->hsize
	) > TEKWIDTH
	) {
	if ((l = screen->cur_Y / t->vsize - 1) < 0) {
	    screen->margin = !screen->margin;
	    l = t->nlines - 1;
a1095 3
	screen->cur_Y = l * t->vsize;
	screen->cur_X = screen->margin == MARGIN1 ? 0 : TEKWIDTH / 2;
    }
d1101 15
a1115 15
    register TScreen *screen = &term->screen;
    register struct Tek_Char *t;
    register int l;

    t = &TekChar[screen->cur.fontsize];

    if ((l = (screen->cur_Y + (t->vsize - 1)) / t->vsize + 1) >= t->nlines) {
	l = 0;
	if ((screen->margin = !screen->margin) != MARGIN1) {
	    if (screen->cur_X < TEKWIDTH / 2)
		screen->cur_X += TEKWIDTH / 2;
	} else if (screen->cur_X >= TEKWIDTH / 2)
	    screen->cur_X -= TEKWIDTH / 2;
    }
    screen->cur_Y = l * t->vsize;
d1121 15
a1135 15
    register TScreen *screen = &term->screen;
    register struct Tek_Char *t;
    register int l;

    t = &TekChar[screen->cur.fontsize];

    if ((l = screen->cur_Y / t->vsize - 1) < 0) {
	l = t->nlines - 1;
	if ((screen->margin = !screen->margin) != MARGIN1) {
	    if (screen->cur_X < TEKWIDTH / 2)
		screen->cur_X += TEKWIDTH / 2;
	} else if (screen->cur_X >= TEKWIDTH / 2)
	    screen->cur_X -= TEKWIDTH / 2;
    }
    screen->cur_Y = l * t->vsize;
d1141 2
a1142 2
    register TScreen *screen = &term->screen;
    register XSegment *lp;
d1144 11
a1154 11
    if (nplot >= MAX_PTS) {
	TekFlush();
    }
    lp = line_pt++;
    lp->x1 = x1 = (int) (x1 * TekScale(screen) + screen->border);
    lp->y1 = y1 = (int) ((TEKHEIGHT + TEKTOPPAD - y1) * TekScale(screen) +
			 screen->border);
    lp->x2 = x2 = (int) (x2 * TekScale(screen) + screen->border);
    lp->y2 = y2 = (int) ((TEKHEIGHT + TEKTOPPAD - y2) * TekScale(screen) +
			 screen->border);
    nplot++;
d1158 1
a1158 1
TekDraw(int x, int y)
d1160 1
a1160 1
    register TScreen *screen = &term->screen;
d1162 12
a1173 12
    if (nplot == 0 || T_lastx != screen->cur_X || T_lasty != screen->cur_Y) {
	/*
	 * We flush on each unconnected line segment if the line
	 * type is not solid.  This solves a bug in X when drawing
	 * points while the line type is not solid.
	 */
	if (nplot > 0 && screen->cur.linetype != SOLIDLINE)
	    TekFlush();
    }
    AddToDraw(screen->cur_X, screen->cur_Y, x, y);
    T_lastx = screen->cur_X = x;
    T_lasty = screen->cur_Y = y;
d1177 1
a1177 1
TekFlush(void)
d1179 1
a1179 1
    register TScreen *screen = &term->screen;
d1181 6
a1186 6
    XDrawSegments(screen->display, TWindow(screen),
		  ((screen->cur.linetype == SOLIDLINE) ? screen->TnormalGC :
		   screen->linepat[screen->cur.linetype - 1]),
		  Tline, nplot);
    nplot = 0;
    line_pt = Tline;
d1192 1
a1192 1
    register TScreen *screen = &term->screen;
d1194 7
a1200 7
    XDefineCursor(screen->display, TShellWindow, screen->arrow);
    if (GINcursor)
	XFreeCursor(screen->display, GINcursor);
    if (screen->TekGIN) {
	*screen->TekGIN = CAN;	/* modify recording */
	screen->TekGIN = NULL;
    }
d1206 27
a1232 27
    register TScreen *screen = &term->screen;
    int mousex, mousey, rootx, rooty;
    unsigned int mask;		/* XQueryPointer */
    Window root, subw;

    XQueryPointer(
		     screen->display, TWindow(screen),
		     &root, &subw,
		     &rootx, &rooty,
		     &mousex, &mousey,
		     &mask);
    if ((mousex = (int) ((mousex - screen->border) / TekScale(screen))) < 0)
	mousex = 0;
    else if (mousex >= TEKWIDTH)
	mousex = TEKWIDTH - 1;
    if ((mousey = (int) (TEKHEIGHT + TEKTOPPAD - (mousey - screen->border) /
			 TekScale(screen))) < 0)
	mousey = 0;
    else if (mousey >= TEKHEIGHT)
	mousey = TEKHEIGHT - 1;
    TekEnq(c, mousex, mousey);
}

static void
TekEnq(int status,
       register int x,
       register int y)
d1235 1
a1235 1
    Char cplot[7];
d1251 1
a1251 1
    tt_write(cplot + adj, len - adj);
d1253 1
a1253 1
    v_write(screen->respond, cplot + adj, len - adj);
d1260 2
a1261 2
    register TScreen *screen = &term->screen;
    register int i;
d1263 6
a1268 4
    if (!TWindow(screen) && !TekInit()) {
	if (VWindow(screen)) {
	    screen->TekEmu = FALSE;
	    return;
d1270 13
a1282 20
	Exit(ERROR_TINIT);
    }
    if (!screen->Tshow) {
	set_tek_visibility(TRUE);
    }
    update_vttekmode();
    update_vtshow();
    update_tekshow();
    set_tekhide_sensitivity();

    Tpushback = Tpushb;
    Tbuffer->ptr = DecodedData(Tbuffer);
    for (i = Tbuffer->cnt = VTbuffer.cnt; i > 0; i--)
	*(Tbuffer->ptr)++ = *(VTbuffer.ptr)++;
    Tbuffer->ptr = DecodedData(Tbuffer);
    Ttoggled = TRUE;
    if (!setjmp(Tekend))
	Tekparse();
    if (!Ttoggled) {
	TCursorToggle(TOGGLE);
d1284 7
a1290 2
    }
    screen->TekEmu = FALSE;
d1298 5
a1302 6
static int dash_length[TEKNUMLINES] =
{
    DOTTED_LENGTH,
    DOT_DASHED_LENGTH,
    SHORT_DASHED_LENGTH,
    LONG_DASHED_LENGTH,
d1305 10
a1314 15
static unsigned char dotted[DOTTED_LENGTH] =
{3, 1};
static unsigned char dot_dashed[DOT_DASHED_LENGTH] =
{3, 4, 3, 1};
static unsigned char short_dashed[SHORT_DASHED_LENGTH] =
{4, 4};
static unsigned char long_dashed[LONG_DASHED_LENGTH] =
{4, 7};

static unsigned char *dashes[TEKNUMLINES] =
{
    dotted,
    dot_dashed,
    short_dashed,
    long_dashed,
d1317 2
d1323 5
a1327 5
static void
TekInitialize(Widget request GCC_UNUSED,
	      Widget wnew GCC_UNUSED,
	      ArgList args GCC_UNUSED,
	      Cardinal * num_args GCC_UNUSED)
d1335 1
a1335 1
		      HandleEnterWindow, (caddr_t) NULL);
d1337 1
a1337 1
		      HandleLeaveWindow, (caddr_t) NULL);
d1339 3
a1341 3
		      HandleFocusChange, (caddr_t) NULL);
    XtAddEventHandler((Widget) wnew, PropertyChangeMask, FALSE,
		      HandleBellPropertyChange, (Opaque) NULL);
d1344 5
a1348 4
static void
TekRealize(Widget gw,
	   XtValueMask * valuemaskp,
	   XSetWindowAttributes * values)
d1370 1
a1370 1
	    tw->tek.Tfont[i] = XQueryFont(screen->display, DefaultGCID);
d1393 1
a1393 1
	sprintf(Tdefault, "=%dx%d", defwidth + border, defheight + border);
d1402 1
a1402 5
    pr = XParseGeometry(term->misc.T_geometry,
			&winX,
			&winY,
			(unsigned int *) &width,
			(unsigned int *) &height);
d1404 2
a1405 2
	winX += DisplayWidth(screen->display, DefaultScreen(screen->display))
	    - width - (SHELL_OF(term)->core.border_width * 2);
d1407 2
a1408 2
	winY += DisplayHeight(screen->display, DefaultScreen(screen->display))
	    - height - (SHELL_OF(term)->core.border_width * 2);
d1415 1
a1415 1
    sizehints.flags = PMinSize | PResizeInc;
d1418 2
a1419 2
    if ((XValue & pr) || (YValue & pr)) {
	sizehints.flags |= USSize | USPosition;
d1422 1
a1422 1
	case 0:
d1425 1
a1425 1
	case XNegative:
d1428 1
a1428 1
	case YNegative:
d1431 1
a1431 1
	default:
d1440 3
a1442 4
    if ((WidthValue & pr) || (HeightValue & pr))
	sizehints.flags |= USSize;
    else
	sizehints.flags |= PSize;
d1444 2
a1445 2
    (void) XtMakeResizeRequest((Widget) tw, width, height,
			       &tw->core.width, &tw->core.height);
d1452 2
a1453 2
	XMoveWindow(XtDisplay(tw), XtWindow(SHELL_OF(tw)),
		    sizehints.x, sizehints.y);
d1455 3
a1457 3
    XSetWMNormalHints(XtDisplay(tw), XtWindow(SHELL_OF(tw)),
		      &sizehints);
    XFlush(XtDisplay(tw));	/* get it out to window manager */
d1463 8
a1470 8
	XCreateWindow(screen->display,
		      XtWindow(SHELL_OF(tw)),
		      tw->core.x, tw->core.y,
		      tw->core.width, tw->core.height, tw->core.border_width,
		      (int) tw->core.depth,
		      InputOutput, CopyFromParent,
		      ((*valuemaskp) | CWBackPixel | CWWinGravity),
		      values);
d1476 5
a1480 4
    TekScale(screen) = (double) TWidth(screen) / TEKWIDTH;
    if ((d = (double) THeight(screen) / (TEKHEIGHT + TEKTOPPAD +
					 TEKBOTTOMPAD)) < TekScale(screen))
	TekScale(screen) = d;
d1486 10
a1495 10
	if (XmuCompareISOLatin1(s, "large") == 0)
	    screen->cur.fontsize = TEK_FONT_LARGE;
	else if (XmuCompareISOLatin1(s, "2") == 0 ||
		 XmuCompareISOLatin1(s, "two") == 0)
	    screen->cur.fontsize = TEK_FONT_2;
	else if (XmuCompareISOLatin1(s, "3") == 0 ||
		 XmuCompareISOLatin1(s, "three") == 0)
	    screen->cur.fontsize = TEK_FONT_3;
	else if (XmuCompareISOLatin1(s, "small") == 0)
	    screen->cur.fontsize = TEK_FONT_SMALL;
a1496 1
#define TestGIN(s) XmuCompareISOLatin1(tw->tek.gin_terminator_str, s)
d1498 1
a1498 1
    if (TestGIN(GIN_TERM_NONE_STR) == 0)
d1500 1
a1500 1
    else if (TestGIN(GIN_TERM_CR_STR) == 0)
d1502 1
a1502 1
    else if (TestGIN(GIN_TERM_EOT_STR) == 0)
d1517 3
a1519 3
    screen->TnormalGC = XCreateGC(screen->display, TWindow(screen),
				  (TEKgcFontMask | GCGraphicsExposures |
				   GCForeground | GCBackground), &gcv);
d1526 2
a1527 2
    screen->TcursorGC = XCreateGC(screen->display, TWindow(screen),
				  (GCFunction | GCPlaneMask), &gcv);
d1532 5
a1536 5
    for (i = 0; i < TEKNUMLINES; i++) {
	screen->linepat[i] = XCreateGC(screen->display, TWindow(screen),
				       (GCForeground | GCLineStyle), &gcv);
	XSetDashes(screen->display, screen->linepat[i], 0,
		   (char *) dashes[i], dash_length[i]);
d1541 3
a1543 2
    screen->margin = MARGIN1;	/* Margin 1             */
    screen->TekGIN = FALSE;	/* GIN off              */
d1547 4
a1550 5
    {				/* there's gotta be a better way... */
	static Arg args[] =
	{
	    {XtNtitle, (XtArgVal) NULL},
	    {XtNiconName, (XtArgVal) NULL},
d1554 4
a1557 4
	args[0].value = (XtArgVal) & icon_name;
	args[1].value = (XtArgVal) & title;
	XtGetValues(SHELL_OF(tw), args, 2);
	tek_icon_name = XtMalloc(strlen(icon_name) + 7);
d1560 1
a1560 1
	tek_title = XtMalloc(strlen(title) + 7);
d1563 5
a1567 5
	args[0].value = (XtArgVal) tek_icon_name;
	args[1].value = (XtArgVal) tek_title;
	XtSetValues(SHELL_OF(tw), args, 2);
	XtFree(tek_icon_name);
	XtFree(tek_title);
d1571 1
a1571 1
    tek->next = (TekLink *) 0;
d1585 1
a1585 2
void
TekSetFontSize(int newitem)
d1592 1
a1592 1
    if (!tekWidget || oldsize == newsize)
d1594 2
a1595 3
    if (!Ttoggled)
	TCursorToggle(TOGGLE);
    set_tekfont_menu_item(oldsize, FALSE);
d1599 3
a1601 3
	/* we didn't succeed in opening a real font
	   for this size.  Instead, use server default. */
	XCopyGC(screen->display,
d1605 1
a1605 1
	XSetFont(screen->display, screen->TnormalGC, fid);
d1608 2
a1609 3
    set_tekfont_menu_item(newsize, TRUE);
    if (!Ttoggled)
	TCursorToggle(TOGGLE);
d1613 1
a1613 1
ChangeTekColors(register TScreen * screen, ScrnColors * pNew)
d1615 14
a1628 2
    register int i;
    XGCValues gcv;
a1629 10
    if (COLOR_DEFINED(pNew, TEK_FG)) {
	screen->Tforeground = COLOR_VALUE(pNew, TEK_FG);
	XSetForeground(screen->display, screen->TnormalGC,
		       screen->Tforeground);
    }
    if (COLOR_DEFINED(pNew, TEK_BG)) {
	screen->Tbackground = COLOR_VALUE(pNew, TEK_BG);
	XSetBackground(screen->display, screen->TnormalGC,
		       screen->Tbackground);
    }
d1631 10
a1640 9
    if (tekWidget) {
	if (tekWidget->core.border_pixel == screen->Tbackground) {
	    tekWidget->core.border_pixel = screen->Tforeground;
	    XtParent(tekWidget)->core.border_pixel =
		screen->Tforeground;
	    if (XtWindow(XtParent(tekWidget)))
		XSetWindowBorder(screen->display,
				 XtWindow(XtParent(tekWidget)),
				 tekWidget->core.border_pixel);
a1641 1
    }
d1643 4
a1646 4
    for (i = 0; i < TEKNUMLINES; i++) {
	XSetForeground(screen->display, screen->linepat[i],
		       screen->Tforeground);
    }
d1648 1
a1648 1
    screen->Tcursorcolor = screen->Tforeground;
d1650 5
a1654 5
    gcv.plane_mask = screen->xorplane = (screen->Tbackground ^
					 screen->Tcursorcolor);
    XChangeGC(screen->display, screen->TcursorGC, GCPlaneMask, &gcv);
    TekBackground(screen);
    return;
d1658 1
a1658 1
TekReverseVideo(register TScreen * screen)
d1660 12
a1671 2
    register int i;
    XGCValues gcv;
d1673 10
a1682 18
    i = screen->Tbackground;
    screen->Tbackground = screen->Tforeground;
    screen->Tforeground = i;

    XSetForeground(screen->display, screen->TnormalGC,
		   screen->Tforeground);
    XSetBackground(screen->display, screen->TnormalGC,
		   screen->Tbackground);

    if (tekWidget) {
	if (tekWidget->core.border_pixel == screen->Tbackground) {
	    tekWidget->core.border_pixel = screen->Tforeground;
	    XtParent(tekWidget)->core.border_pixel =
		screen->Tforeground;
	    if (XtWindow(XtParent(tekWidget)))
		XSetWindowBorder(screen->display,
				 XtWindow(XtParent(tekWidget)),
				 tekWidget->core.border_pixel);
a1683 1
    }
d1685 4
a1688 4
    for (i = 0; i < TEKNUMLINES; i++) {
	XSetForeground(screen->display, screen->linepat[i],
		       screen->Tforeground);
    }
d1690 1
a1690 1
    screen->Tcursorcolor = screen->Tforeground;
d1692 4
a1695 4
    gcv.plane_mask = screen->xorplane = (screen->Tbackground ^
					 screen->Tcursorcolor);
    XChangeGC(screen->display, screen->TcursorGC, GCPlaneMask, &gcv);
    TekBackground(screen);
d1699 1
a1699 1
TekBackground(register TScreen * screen)
d1701 3
a1703 3
    if (TWindow(screen))
	XSetWindowBackground(screen->display, TWindow(screen),
			     screen->Tbackground);
d1712 34
a1745 25
    register TScreen *screen = &term->screen;
    register int c, x, y;
    unsigned int cellwidth, cellheight;

    if (!screen->Tshow)
	return;

    c = screen->cur.fontsize;
    cellwidth = (unsigned) tekWidget->tek.Tfont[c]->max_bounds.width;
    cellheight = (unsigned) (tekWidget->tek.Tfont[c]->ascent +
			     tekWidget->tek.Tfont[c]->descent);

    x = (int) ((screen->cur_X * TekScale(screen)) + screen->border);
    y = (int) (((TEKHEIGHT + TEKTOPPAD - screen->cur_Y) * TekScale(screen))
	       + screen->border - tekWidget->tek.tobaseline[c]);

    if (toggle == TOGGLE) {
	if (screen->select || screen->always_highlight)
	    XFillRectangle(screen->display, TWindow(screen),
			   screen->TcursorGC, x, y,
			   cellwidth, cellheight);
	else {			/* fix to use different GC! */
	    XDrawRectangle(screen->display, TWindow(screen),
			   screen->TcursorGC, x, y,
			   cellwidth - 1, cellheight - 1);
a1746 10
    } else {
	/* Clear the entire rectangle, even though we may only
	 * have drawn an outline.  This fits with our refresh
	 * scheme of redrawing the entire window on any expose
	 * event and is easier than trying to figure out exactly
	 * which part of the cursor needs to be erased.
	 */
	XClearArea(screen->display, TWindow(screen), x, y,
		   cellwidth, cellheight, FALSE);
    }
d1749 1
a1749 2
void
TekSimulatePageButton(Bool reset)
d1756 1
a1756 1
	bzero((char *) &screen->cur, sizeof screen->cur);
d1758 2
a1759 2
    TekRefresh = (TekLink *) 0;
    TekPage();
d1778 2
a1779 2
	&& access(buf, W_OK) < 0) {
	Bell(XkbBI_MinorError, 0);
d1782 1
d1784 2
a1785 2
    if (access(".", W_OK) < 0) {	/* can't write in directory */
	Bell(XkbBI_MinorError, 0);
d1792 2
a1793 2
		ESC, screen->page.fontsize + '8',
		ESC, screen->page.linetype + '`');
d1797 1
a1797 1
	    write(tekcopyfd, (char *) Tp->data, Tp->count);
d1799 1
a1799 1
	} while (Tp);
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d6 1
a6 1
/* $XFree86: xc/programs/xterm/Tekproc.c,v 3.46 2003/10/24 20:38:23 tsi Exp $ */
a83 2
#define RES_OFFSET(field)	XtOffsetOf(TekWidgetRec, field)

a98 2
#elif defined(HAVE_LIB_XAWPLUS)
#include <X11/XawPlus/Form.h>
d252 3
a254 1
    Cres(XtNbackground, XtCBackground, core.background_pixel, "White"),
d263 18
a280 6
    Fres("fontLarge", XtCFont, tek.Tfont[TEK_FONT_LARGE], "9x15"),
    Fres("font2", XtCFont, tek.Tfont[TEK_FONT_2], "6x13"),
    Fres("font3", XtCFont, tek.Tfont[TEK_FONT_3], "8x13"),
    Fres("fontSmall", XtCFont, tek.Tfont[TEK_FONT_SMALL], DFT_FONT_SMALL),
    Sres("initialFont", "InitialFont", tek.initial_font, "large"),
    Sres("ginTerminator", "GinTerminator", tek.gin_terminator_str, GIN_TERM_NONE_STR),
d285 3
a287 1
    Ires(XtNmenuHeight, XtCMenuHeight, tek.menu_height, 25),
d291 1
a291 1
static IChar Tinput(void);
d411 2
a412 3
    int x, y;
    IChar c = 0;
    IChar ch;
d430 1
a430 1
	TRACE(("Tekparse %04X -> %d\n", c, nextstate));
d646 1
a646 1
		if (screen->pen == PENDOWN) {
d648 1
a648 1
		} else {
a649 1
		}
d742 2
a743 3
		IChar c2;
		int len = 0;
		while ((c2 = input()) != BEL) {
d766 1
a766 1
static IChar
d770 1
d845 3
a847 1
		if (Select(max_plus1, &Tselect_mask, NULL, NULL, NULL) < 0) {
d953 1
a953 1
    XDefineCursor(screen->display, TWindow(screen), wait_cursor);
d957 1
a957 1
    XDefineCursor(screen->display, TWindow(screen),
a1133 1
    TRACE(("AddToDraw (%d,%d) (%d,%d)\n", x1, y1, x2, y2));
a1144 1
    TRACE(("...AddToDraw %d points\n", nplot));
a1170 1
    TRACE(("TekFlush\n"));
d1184 1
a1184 2
    TRACE(("TekGINoff\n"));
    XDefineCursor(screen->display, TWindow(screen), screen->arrow);
a1200 1
    TRACE(("TekEnqMouse\n"));
a1228 1
    TRACE(("TekEnq\n"));
a1324 2
    TRACE(("TekInitialize\n"));

a1354 2
    TRACE(("TekRealize\n"));

d1362 1
a1362 1
	if (!tw->tek.Tfont[i]) {
a1363 1
	}
d1542 1
a1542 1
    XDefineCursor(screen->display, TWindow(screen), screen->pointer_cursor);
@


