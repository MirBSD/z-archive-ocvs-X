head	1.2;
access;
symbols
	tg-mergetmp-2:1.2
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407221130:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.2
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.03.07.18.38.28;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.20.08.41;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.08.41;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.37.30;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.24.52;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.25.08;	author tg;	state Exp;
branches;
next	1.1.9.2;

1.1.9.2
date	2004.03.05.22.33.50;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@semi-automagic merge of these files (ie, I've skipped through the diffs,
and most of that was done by cvs or that weird script of some minutes ago)
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/bus/ix86Pci.c,v 1.26 2004/02/13 23:58:47 dawes Exp $ */
/*
 * ix86Pci.c - x86 PCI driver
 *
 * The XFree86 server PCI access functions have been reimplemented as a
 * framework that allows each supported platform/OS to have their own
 * platform/OS specific PCI driver.
 *
 * Most of the code of these functions was simply lifted from the
 * Intel architecture specifric portion of the original Xfree86
 * PCI code in hw/xfree86/common_hw/xf86_PCI.C...
 *
 * Gary Barton
 * Concurrent Computer Corporation
 * garyb@@gate.net
 */

/*
 * Copyright 1998 by Concurrent Computer Corporation
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Concurrent Computer
 * Corporation not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior
 * permission.  Concurrent Computer Corporation makes no representations
 * about the suitability of this software for any purpose.  It is
 * provided "as is" without express or implied warranty.
 *
 * CONCURRENT COMPUTER CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD
 * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL CONCURRENT COMPUTER CORPORATION BE
 * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 *
 * Copyright 1998 by Metro Link Incorporated
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of Metro Link
 * Incorporated not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior
 * permission.  Metro Link Incorporated makes no representations
 * about the suitability of this software for any purpose.  It is
 * provided "as is" without express or implied warranty.
 *
 * METRO LINK INCORPORATED DISCLAIMS ALL WARRANTIES WITH REGARD
 * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL METRO LINK INCORPORATED BE
 * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 * SOFTWARE.
 *
 * This software is derived from the original XFree86 PCI code
 * which includes the following copyright notices as well:
 *
 * Copyright 1995 by Robin Cutshaw <robin@@XFree86.Org>
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the names of the above listed copyright holder(s)
 * not be used in advertising or publicity pertaining to distribution of
 * the software without specific, written prior permission.  The above listed
 * copyright holder(s) make(s) no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without express or
 * implied warranty.
 *
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM(S) ALL WARRANTIES WITH REGARD
 * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
 * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * This code is also based heavily on the code in FreeBSD-current, which was
 * written by Wolfgang Stanglmeier, and contains the following copyright:
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1999-2003 by The XFree86 Project, Inc.
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 *
 *   1.  Redistributions of source code must retain the above copyright
 *       notice, this list of conditions, and the following disclaimer.
 *
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer
 *       in the documentation and/or other materials provided with the
 *       distribution, and in the same place and form as other copyright,
 *       license and disclaimer information.
 *
 *   3.  The end-user documentation included with the redistribution,
 *       if any, must include the following acknowledgment: "This product
 *       includes software developed by The XFree86 Project, Inc
 *       (http://www.xfree86.org/) and its contributors", in the same
 *       place and form as other third-party acknowledgments.  Alternately,
 *       this acknowledgment may appear in the software itself, in the
 *       same form and location as other such third-party acknowledgments.
 *
 *   4.  Except as contained in this notice, the name of The XFree86
 *       Project, Inc shall not be used in advertising or otherwise to
 *       promote the sale, use or other dealings in this Software without
 *       prior written authorization from The XFree86 Project, Inc.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE XFREE86 PROJECT, INC OR ITS CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
#include "compiler.h"
#include "xf86.h"
#include "xf86Priv.h"
#include "Pci.h"

#ifdef PC98
#define outb(port,data) _outb(port,data)
#define outl(port,data) _outl(port,data)
#define inb(port) _inb(port)
#define inl(port) _inl(port)
#endif

#define	PCI_CFGMECH2_ENABLE_REG		0xCF8
#ifdef PC98
#define	PCI_CFGMECH2_FORWARD_REG	0xCF9
#else
#define	PCI_CFGMECH2_FORWARD_REG	0xCFA
#endif

#define PCI_CFGMECH2_MAXDEV	16

#define PCI_ADDR_FROM_TAG_CFG1(tag,reg) (PCI_EN | tag | (reg & 0xfc))
#define PCI_FORWARD_FROM_TAG(tag)       PCI_BUS_FROM_TAG(tag)
#define PCI_ENABLE_FROM_TAG(tag)        (0xf0 | (((tag) & 0x00000700) >> 7))
#define PCI_ADDR_FROM_TAG_CFG2(tag,reg) (0xc000 | (((tag) & 0x0000f800) >> 3) \
                                        | (reg & 0xfc))

/*
 * Intel x86 platform specific PCI access functions
 */
static CARD32 ix86PciReadLongSetup(PCITAG tag, int off);
static void ix86PciWriteLongSetup(PCITAG, int off, CARD32 val);
static void ix86PciSetBitsLongSetup(PCITAG, int off, CARD32 mask, CARD32 val);
static CARD32 ix86PciReadLongCFG1(PCITAG tag, int off);
static void ix86PciWriteLongCFG1(PCITAG, int off, CARD32 val);
static void ix86PciSetBitsLongCFG1(PCITAG, int off, CARD32 mask, CARD32 val);
static CARD32 ix86PciReadLongCFG2(PCITAG tag, int off);
static void ix86PciWriteLongCFG2(PCITAG, int off, CARD32 val);
static void ix86PciSetBitsLongCFG2(PCITAG, int off, CARD32 mask, CARD32 val);

static pciBusFuncs_t ix86Funcs0 = {
/* pciReadLong      */	ix86PciReadLongSetup,
/* pciWriteLong     */	ix86PciWriteLongSetup,
/* pciSetBitsLong   */	ix86PciSetBitsLongSetup,
/* pciAddrHostToBus */	pciAddrNOOP,
/* pciAddrBusToHost */	pciAddrNOOP
};

static pciBusFuncs_t ix86Funcs1 = {
/* pciReadLong      */	ix86PciReadLongCFG1,
/* pciWriteLong     */	ix86PciWriteLongCFG1,
/* pciSetBitsLong   */	ix86PciSetBitsLongCFG1,
/* pciAddrHostToBus */	pciAddrNOOP,
/* pciAddrBusToHost */	pciAddrNOOP
};

static pciBusFuncs_t ix86Funcs2 = {
/* pciReadLong      */	ix86PciReadLongCFG2,
/* pciWriteLong     */	ix86PciWriteLongCFG2,
/* pciSetBitsLong   */	ix86PciSetBitsLongCFG2,
/* pciAddrHostToBus */	pciAddrNOOP,
/* pciAddrBusToHost */	pciAddrNOOP
};

static pciBusInfo_t ix86Pci0 = {
/* configMech  */	PCI_CFG_MECH_UNKNOWN,	/* Set by ix86PciInit() */
/* numDevices  */	0,			/* Set by ix86PciInit() */
/* secondary   */	FALSE,
/* primary_bus */	0,
#ifdef PowerMAX_OS
/* ppc_io_base */	0,
/* ppc_io_size */	0,
#endif
/* funcs       */	&ix86Funcs0,		/* Set by ix86PciInit() */
/* pciBusPriv  */	NULL,
/* bridge      */	NULL
};

static Bool
ix86PciBusCheck(void)
{
    PCITAG tag;
    CARD32 id, class;
    CARD8 device;

    for (device = 0; device < ix86Pci0.numDevices; device++) {
	tag = PCI_MAKE_TAG(0, device, 0);
	id = (*ix86Pci0.funcs->pciReadLong)(tag, PCI_ID_REG);

	if ((CARD16)(id + 1U) <= (CARD16)1UL)
		continue;

	/* The rest of this is inspired by the Linux kernel */
	class = (*ix86Pci0.funcs->pciReadLong)(tag, PCI_CLASS_REG);

	/* Ignore revision id and programming interface */
	switch (class >> 16) {
	case (PCI_CLASS_PREHISTORIC << 8) | PCI_SUBCLASS_PREHISTORIC_MISC:
	    /* Check for vendors of known buggy chipsets */
	    id &= 0x0000ffff;
	    if ((id == PCI_VENDOR_INTEL) || (id == PCI_VENDOR_COMPAQ))
		return TRUE;
	    continue;

	case (PCI_CLASS_PREHISTORIC << 8) | PCI_SUBCLASS_PREHISTORIC_VGA:
	case (PCI_CLASS_DISPLAY << 8) | PCI_SUBCLASS_DISPLAY_VGA:
	case (PCI_CLASS_BRIDGE << 8) | PCI_SUBCLASS_BRIDGE_HOST:
	    return TRUE;

	default:
	    break;
	}
    }
    return FALSE;
}

static
void ix86PciSelectCfgmech(void)
{
    static Bool beenhere = FALSE;
    CARD32 mode1Res1 = 0, mode1Res2 = 0, oldVal1 = 0;
    CARD8  mode2Res1 = 0, mode2Res2 = 0, oldVal2 = 0;
    int stages = 0;

    if (beenhere)
	return; /* Been there, done that */

    beenhere = TRUE;

    /*
     * Determine if motherboard chipset supports PCI Config Mech 1 or 2
     * We rely on xf86Info.pciFlags to tell which mechanisms to try....
     */
    switch (xf86Info.pciFlags) {

    case PCIProbe1: /* { */

      xf86MsgVerb(X_INFO, 2, "PCI: Probing config type using method 1\n");
      oldVal1 = inl(PCI_CFGMECH1_ADDRESS_REG);

#ifdef DEBUGPCI
      if (xf86Verbose > 2) {
	ErrorF("Checking config type 1:\n"
		"\tinitial value of MODE1_ADDR_REG is 0x%08x\n", oldVal1);
	ErrorF("\tChecking that all bits in mask 0x7f000000 are clear\n");
      }
#endif

      /* Assuming config type 1 to start with */
      if ((oldVal1 & 0x7f000000) == 0) {

	stages |= 0x01;

#ifdef DEBUGPCI
	if (xf86Verbose > 2) {
	    ErrorF("\tValue indicates possibly config type 1\n");
	    ErrorF("\tWriting 32-bit value 0x%08x to MODE1_ADDR_REG\n", PCI_EN);
#if 0
	    ErrorF("\tWriting 8-bit value 0x00 to MODE1_ADDR_REG + 3\n");
#endif
	}
#endif

	ix86Pci0.configMech = PCI_CFG_MECH_1;
	ix86Pci0.numDevices = PCI_CFGMECH1_MAXDEV;
	ix86Pci0.funcs = &ix86Funcs1;

	outl(PCI_CFGMECH1_ADDRESS_REG, PCI_EN);

#if 0
	/*
	 * This seems to cause some Neptune-based PCI machines to switch
	 * from config type 1 to config type 2
	 */
	outb(PCI_CFGMECH1_ADDRESS_REG + 3, 0);
#endif
	mode1Res1 = inl(PCI_CFGMECH1_ADDRESS_REG);

#ifdef DEBUGPCI
	if (xf86Verbose > 2) {
	    ErrorF("\tValue read back from MODE1_ADDR_REG is 0x%08x\n",
			mode1Res1);
	    ErrorF("\tRestoring original contents of MODE1_ADDR_REG\n");
	}
#endif

	outl(PCI_CFGMECH1_ADDRESS_REG, oldVal1);

	if (mode1Res1) {

	    stages |= 0x02;

#ifdef DEBUGPCI
	    if (xf86Verbose > 2) {
		ErrorF("\tValue read back is non-zero, and indicates possible"
			" config type 1\n");
	    }
#endif

	    if (ix86PciBusCheck()) {

#ifdef DEBUGPCI
		if (xf86Verbose > 2)
		    ErrorF("\tBus check Confirms this: ");
#endif

		xf86MsgVerb(X_INFO, 2, "PCI: Config type is 1\n");
		xf86MsgVerb(X_INFO, 3,
			"PCI: stages = 0x%02x, oldVal1 = 0x%08lx, mode1Res1"
			" = 0x%08lx\n", stages, (unsigned long)oldVal1,
			(unsigned long)mode1Res1);
		return;
	    }

#ifdef DEBUGPCI
	    if (xf86Verbose > 2) {
		ErrorF("\tBus check fails to confirm this, continuing type 1"
			" check ...\n");
	    }
#endif

	}

	stages |= 0x04;

#ifdef DEBUGPCI
	if (xf86Verbose > 2) {
	    ErrorF("\tWriting 0xff000001 to MODE1_ADDR_REG\n");
	}
#endif
	outl(PCI_CFGMECH1_ADDRESS_REG, 0xff000001);
	mode1Res2 = inl(PCI_CFGMECH1_ADDRESS_REG);

#ifdef DEBUGPCI
	if (xf86Verbose > 2) {
	    ErrorF("\tValue read back from MODE1_ADDR_REG is 0x%08x\n",
			mode1Res2);
	    ErrorF("\tRestoring original contents of MODE1_ADDR_REG\n");
	}
#endif

	outl(PCI_CFGMECH1_ADDRESS_REG, oldVal1);

	if ((mode1Res2 & 0x80000001) == 0x80000000) {

	    stages |= 0x08;

#ifdef DEBUGPCI
	    if (xf86Verbose > 2) {
		ErrorF("\tValue read back has only the msb set\n"
			"\tThis indicates possible config type 1\n");
	    }
#endif

	    if (ix86PciBusCheck()) {

#ifdef DEBUGPCI
		if (xf86Verbose > 2)
		    ErrorF("\tBus check Confirms this: ");
#endif

		xf86MsgVerb(X_INFO, 2, "PCI: Config type is 1\n");
		xf86MsgVerb(X_INFO, 3,
			"PCI: stages = 0x%02x, oldVal1 = 0x%08lx,\n"
			"\tmode1Res1 = 0x%08lx, mode1Res2 = 0x%08lx\n",
			stages, (unsigned long)oldVal1,
			(unsigned long)mode1Res1, (unsigned long)mode1Res2);
		return;
	    }

#ifdef DEBUGPCI
	    if (xf86Verbose > 2) {
		ErrorF("\tBus check fails to confirm this.\n");
	    }
#endif

	}
      }

      xf86MsgVerb(X_INFO, 3, "PCI: Standard check for type 1 failed.\n");
      xf86MsgVerb(X_INFO, 3, "PCI: stages = 0x%02x, oldVal1 = 0x%08lx,\n"
	       "\tmode1Res1 = 0x%08lx, mode1Res2 = 0x%08lx\n",
	       stages, (unsigned long)oldVal1, (unsigned long)mode1Res1,
	       (unsigned long)mode1Res2);

      /* Try config type 2 */
      oldVal2 = inb(PCI_CFGMECH2_ENABLE_REG);
      if ((oldVal2 & 0xf0) == 0) {
	ix86Pci0.configMech = PCI_CFG_MECH_2;
	ix86Pci0.numDevices = PCI_CFGMECH2_MAXDEV;
	ix86Pci0.funcs = &ix86Funcs2;

	outb(PCI_CFGMECH2_ENABLE_REG, 0x0e);
	mode2Res1 = inb(PCI_CFGMECH2_ENABLE_REG);
	outb(PCI_CFGMECH2_ENABLE_REG, oldVal2);

	if (mode2Res1 == 0x0e) {
	    if (ix86PciBusCheck()) {
		xf86MsgVerb(X_INFO, 2, "PCI: Config type is 2\n");
		return;
	    }
	}
      }
      break; /* } */

    case PCIProbe2: /* { */

      /* The scanpci-style detection method */

      xf86MsgVerb(X_INFO, 2, "PCI: Probing config type using method 2\n");

      outb(PCI_CFGMECH2_ENABLE_REG, 0x00);
      outb(PCI_CFGMECH2_FORWARD_REG, 0x00);
      mode2Res1 = inb(PCI_CFGMECH2_ENABLE_REG);
      mode2Res2 = inb(PCI_CFGMECH2_FORWARD_REG);

      if (mode2Res1 == 0 && mode2Res2 == 0) {
	xf86MsgVerb(X_INFO, 2, "PCI: Config type is 2\n");
	ix86Pci0.configMech = PCI_CFG_MECH_2;
	ix86Pci0.numDevices = PCI_CFGMECH2_MAXDEV;
	ix86Pci0.funcs = &ix86Funcs2;
	return;
      }

      oldVal1 = inl(PCI_CFGMECH1_ADDRESS_REG);
      outl(PCI_CFGMECH1_ADDRESS_REG, PCI_EN);
      mode1Res1 = inl(PCI_CFGMECH1_ADDRESS_REG);
      outl(PCI_CFGMECH1_ADDRESS_REG, oldVal1);
      if (mode1Res1 == PCI_EN) {
	xf86MsgVerb(X_INFO, 2, "PCI: Config type is 1\n");
	ix86Pci0.configMech = PCI_CFG_MECH_1;
	ix86Pci0.numDevices = PCI_CFGMECH1_MAXDEV;
	ix86Pci0.funcs = &ix86Funcs1;
	return;
      }
      break; /* } */

    case PCIForceConfig1:

      xf86MsgVerb(X_INFO, 2, "PCI: Forcing config type 1\n");

      ix86Pci0.configMech = PCI_CFG_MECH_1;
      ix86Pci0.numDevices = PCI_CFGMECH1_MAXDEV;
      ix86Pci0.funcs = &ix86Funcs1;
      return;

    case PCIForceConfig2:

      xf86MsgVerb(X_INFO, 2, "PCI: Forcing config type 2\n");

      ix86Pci0.configMech = PCI_CFG_MECH_2;
      ix86Pci0.numDevices = PCI_CFGMECH2_MAXDEV;
      ix86Pci0.funcs = &ix86Funcs2;
      return;

    case PCIOsConfig:
	return;

    case PCIForceNone:
	break;
    }

    /* No PCI found */
    ix86Pci0.configMech = PCI_CFG_MECH_UNKNOWN;
    xf86MsgVerb(X_INFO, 2, "PCI: No PCI bus found or probed for\n");
}

#if 0
static pciTagRec
ix86PcibusTag(CARD8 bus, CARD8 cardnum, CARD8 func)
{
    pciTagRec tag;

    tag.cfg1 = 0;

    if (func > 7 || cardnum >= pciBusInfo[bus]->numDevices)
	return tag;

    switch (ix86Pci0.configMech) {
    case PCI_CFG_MECH_1:
	    tag.cfg1 = PCI_EN | ((CARD32)bus << 16) |
		       ((CARD32)cardnum << 11) |
		       ((CARD32)func << 8);
	    break;

    case PCI_CFG_MECH_2:
	    tag.cfg2.port    = 0xc000 | ((CARD16)cardnum << 8);
	    tag.cfg2.enable  = 0xf0 | (func << 1);
	    tag.cfg2.forward = bus;
	    break;
    }

    return tag;
}
#endif

static CARD32
ix86PciReadLongSetup(PCITAG Tag, int reg)
{
    ix86PciSelectCfgmech();
    return (*ix86Pci0.funcs->pciReadLong)(Tag,reg);
}

static CARD32
ix86PciReadLongCFG1(PCITAG Tag, int reg)
{
    CARD32    addr, data = 0;

#ifdef DEBUGPCI
    ErrorF("ix86PciReadLong 0x%lx, %d\n", Tag, reg);
#endif

    addr = PCI_ADDR_FROM_TAG_CFG1(Tag,reg);
    outl(PCI_CFGMECH1_ADDRESS_REG, addr);
    data = inl(PCI_CFGMECH1_DATA_REG);
    outl(PCI_CFGMECH1_ADDRESS_REG, 0);

#ifdef DEBUGPCI
    ErrorF("ix86PciReadLong 0x%lx\n", data);
#endif

    return data;
}

static CARD32
ix86PciReadLongCFG2(PCITAG Tag, int reg)
{
    CARD32    addr, data = 0;
    CARD8     forward, enable;

#ifdef DEBUGPCI
    ErrorF("ix86PciReadLong 0x%lx, %d\n", Tag, reg);
#endif

    forward  = PCI_FORWARD_FROM_TAG(Tag);
    enable   = PCI_ENABLE_FROM_TAG(Tag);
    addr     = PCI_ADDR_FROM_TAG_CFG2(Tag,reg);

    outb(PCI_CFGMECH2_ENABLE_REG, enable);
    outb(PCI_CFGMECH2_FORWARD_REG, forward);
    data = inl((CARD16)addr);
    outb(PCI_CFGMECH2_ENABLE_REG, 0);
    outb(PCI_CFGMECH2_FORWARD_REG, 0);

#ifdef DEBUGPCI
    ErrorF("ix86PciReadLong 0x%lx\n", data);
#endif

    return data;
}

static void
ix86PciWriteLongSetup(PCITAG Tag, int reg, CARD32 data)
{
    ix86PciSelectCfgmech();
    (*ix86Pci0.funcs->pciWriteLong)(Tag,reg,data);
}

static void
ix86PciWriteLongCFG1(PCITAG Tag, int reg, CARD32 data)
{
    CARD32    addr;

    addr = PCI_ADDR_FROM_TAG_CFG1(Tag,reg);
    outl(PCI_CFGMECH1_ADDRESS_REG, addr);
    outl(PCI_CFGMECH1_DATA_REG, data);
    outl(PCI_CFGMECH1_ADDRESS_REG, 0);
}

static void
ix86PciWriteLongCFG2(PCITAG Tag, int reg, CARD32 data)
{
    CARD32    addr;
    CARD8 forward, enable;

    forward  = PCI_FORWARD_FROM_TAG(Tag);
    enable   = PCI_ENABLE_FROM_TAG(Tag);
    addr     = PCI_ADDR_FROM_TAG_CFG2(Tag,reg);

    outb(PCI_CFGMECH2_ENABLE_REG, enable);
    outb(PCI_CFGMECH2_FORWARD_REG, forward);
    outl((CARD16)addr, data);
    outb(PCI_CFGMECH2_ENABLE_REG, 0);
    outb(PCI_CFGMECH2_FORWARD_REG, 0);
}

static void
ix86PciSetBitsLongSetup(PCITAG Tag, int reg, CARD32 mask, CARD32 val)
{
    ix86PciSelectCfgmech();
    (*ix86Pci0.funcs->pciSetBitsLong)(Tag,reg,mask,val);
}

static void
ix86PciSetBitsLongCFG1(PCITAG Tag, int reg, CARD32 mask, CARD32 val)
{
    CARD32    addr, data = 0;

#ifdef DEBUGPCI
    ErrorF("ix86PciSetBitsLong 0x%lx, %d\n", Tag, reg);
#endif

    addr = PCI_ADDR_FROM_TAG_CFG1(Tag,reg);
    outl(PCI_CFGMECH1_ADDRESS_REG, addr);
    data = inl(PCI_CFGMECH1_DATA_REG);
    data = (data & ~mask) | (val & mask);
    outl(PCI_CFGMECH1_DATA_REG, data);
    outl(PCI_CFGMECH1_ADDRESS_REG, 0);
}

static void
ix86PciSetBitsLongCFG2(PCITAG Tag, int reg, CARD32 mask, CARD32 val)
{
    CARD32    addr, data = 0;
    CARD8 enable, forward;

#ifdef DEBUGPCI
    ErrorF("ix86PciSetBitsLong 0x%lx, %d\n", Tag, reg);
#endif

    forward  = PCI_FORWARD_FROM_TAG(Tag);
    enable   = PCI_ENABLE_FROM_TAG(Tag);
    addr     = PCI_ADDR_FROM_TAG_CFG2(Tag,reg);

    outb(PCI_CFGMECH2_ENABLE_REG, enable);
    outb(PCI_CFGMECH2_FORWARD_REG, forward);
    data = inl((CARD16)addr);
    data = (data & ~mask) | (val & mask);
    outl((CARD16)addr, data);
    outb(PCI_CFGMECH2_ENABLE_REG, 0);
    outb(PCI_CFGMECH2_FORWARD_REG, 0);
}

void
ix86PciInit()
{
    /* Initialize pciBusInfo[] array and function pointers */
    pciNumBuses    = 1;
    pciBusInfo[0]  = &ix86Pci0;
    pciFindFirstFP = pciGenFindFirst;
    pciFindNextFP  = pciGenFindNext;

    /* Make sure that there is a PCI bus present. */
    ix86PciSelectCfgmech();
    if (ix86Pci0.configMech == PCI_CFG_MECH_UNKNOWN) {
	pciNumBuses    = 0;
	pciBusInfo[0]  = NULL;
    }
}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/bus/ix86Pci.c,v 1.8 2000/06/09 07:53:25 eich Exp $ */
d5 1
a5 1
 * The Xfree server PCI access functions have been reimplemented as a
d73 1
a73 1
 * not be used in advertising or publicity pertaining to distribution of 
d75 2
a76 2
 * copyright holder(s) make(s) no representations about the suitability of this 
 * software for any purpose.  It is provided "as is" without express or 
d79 6
a84 6
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM(S) ALL WARRANTIES WITH REGARD 
 * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
 * AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE 
 * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY 
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER 
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING 
d112 47
d190 46
a235 25
CARD32 ix86PciReadLongSetup(PCITAG tag, int off);
void ix86PciWriteLongSetup(PCITAG, int off, CARD32 val);
void ix86PciSetBitsLongSetup(PCITAG, int off, CARD32 mask, CARD32 val);
CARD32 ix86PciReadLongCFG1(PCITAG tag, int off);
void ix86PciWriteLongCFG1(PCITAG, int off, CARD32 val);
void ix86PciSetBitsLongCFG1(PCITAG, int off, CARD32 mask, CARD32 val);
CARD32 ix86PciReadLongCFG2(PCITAG tag, int off);
void ix86PciWriteLongCFG2(PCITAG, int off, CARD32 val);
void ix86PciSetBitsLongCFG2(PCITAG, int off, CARD32 mask, CARD32 val);

pciBusInfo_t ix86Pci0 = {
/* configMech  */	  PCI_CFG_MECH_UNKNOWN, /* Set by ix86PciInit() */
/* numDevices  */	  0,                    /* Set by ix86PciInit() */
/* secondary   */	  FALSE,
/* primary_bus */	  0,
/* ppc_io_base */	  0,
/* ppc_io_size */	  0,		  
/* funcs       */	  {
	                    ix86PciReadLongSetup,
			    ix86PciWriteLongSetup,
			    ix86PciSetBitsLongSetup,
			    pciAddrNOOP,
			    pciAddrNOOP
		          },
/* pciBusPriv  */	  NULL
d241 2
d246 21
a266 3
	CARD32 id;
	id = (*ix86Pci0.funcs.pciReadLong)(PCI_MAKE_TAG(0, device, 0), 0);
	if (id && id != 0xffffffff) {
d268 3
d273 1
a273 1
    return 0;
d325 2
a326 4
	ix86Pci0.funcs.pciReadLong = ix86PciReadLongCFG1;
	ix86Pci0.funcs.pciWriteLong = ix86PciWriteLongCFG1;
	ix86Pci0.funcs.pciSetBitsLong = ix86PciSetBitsLongCFG1;
	
d368 3
a370 2
			"PCI: stages = 0x%02x, oldVal1 = 0x%08x, mode1Res1"
			" = 0x%08x\n", stages, oldVal1, mode1Res1);
d423 4
a426 3
			"PCI: stages = 0x%02x, oldVal1 = 0x%08x,\n"
			"\tmode1Res1 = 0x%08x, mode1Res2 = 0x%08x\n",
			stages, oldVal1, mode1Res1, mode1Res2);
d438 1
a438 1
   
d440 5
a444 4
      xf86MsgVerb(X_INFO, 3, "PCI: stages = 0x%02x, oldVal1 = 0x%08x,\n"
	       "\tmode1Res1 = 0x%08x, mode1Res2 = 0x%08x\n",
	       stages, oldVal1, mode1Res1, mode1Res2);
 
d450 1
a450 3
	ix86Pci0.funcs.pciReadLong = ix86PciReadLongCFG2;
	ix86Pci0.funcs.pciWriteLong = ix86PciWriteLongCFG2;
	ix86Pci0.funcs.pciSetBitsLong = ix86PciSetBitsLongCFG2;
d480 1
a480 3
	ix86Pci0.funcs.pciReadLong = ix86PciReadLongCFG2;
	ix86Pci0.funcs.pciWriteLong = ix86PciWriteLongCFG2;
	ix86Pci0.funcs.pciSetBitsLong = ix86PciSetBitsLongCFG2;
d492 1
a492 3
	ix86Pci0.funcs.pciReadLong = ix86PciReadLongCFG1;
	ix86Pci0.funcs.pciWriteLong = ix86PciWriteLongCFG1;
	ix86Pci0.funcs.pciSetBitsLong = ix86PciSetBitsLongCFG1;
d503 1
a503 3
      ix86Pci0.funcs.pciReadLong = ix86PciReadLongCFG1;
      ix86Pci0.funcs.pciWriteLong = ix86PciWriteLongCFG1;
      ix86Pci0.funcs.pciSetBitsLong = ix86PciSetBitsLongCFG1;
d512 1
a512 3
      ix86Pci0.funcs.pciReadLong = ix86PciReadLongCFG2;
      ix86Pci0.funcs.pciWriteLong = ix86PciWriteLongCFG2;
      ix86Pci0.funcs.pciSetBitsLong = ix86PciSetBitsLongCFG2;
d517 3
d523 2
a524 1
    xf86MsgVerb(X_INFO, 2, "PCI: No PCI bus found\n");
d544 1
a544 1
	    
d551 1
a551 1
    
d555 2
a556 1
CARD32
d560 1
a560 1
    return (*ix86Pci0.funcs.pciReadLong)(Tag,reg);
d562 2
a563 2
    
CARD32
d569 1
a569 1
ErrorF("ix86PciReadLong 0x%lx, %d\n", Tag, reg);
d578 1
a578 1
ErrorF("ix86PciReadLong 0x%lx\n", data);
d584 1
a584 1
CARD32
d589 1
d591 1
a591 1
ErrorF("ix86PciReadLong 0x%lx, %d\n", Tag, reg);
d593 1
d605 1
a605 1
ErrorF("ix86PciReadLong 0x%lx\n", data);
d611 1
a611 1
void
d615 1
a615 1
    (*ix86Pci0.funcs.pciWriteLong)(Tag,reg,data);
d618 1
a618 1
void
d629 1
a629 1
void
d634 1
a634 1
    
d638 1
a638 1
    
d646 1
a646 1
void
d650 1
a650 1
    (*ix86Pci0.funcs.pciSetBitsLong)(Tag,reg,mask,val);
d653 1
a653 1
void
d670 1
a670 1
void
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/bus/ix86Pci.c,v 1.25 2003/09/24 02:43:34 dawes Exp $ */
d5 1
a5 1
 * The XFree86 server PCI access functions have been reimplemented as a
d73 1
a73 1
 * not be used in advertising or publicity pertaining to distribution of
d75 2
a76 2
 * copyright holder(s) make(s) no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without express or
d79 6
a84 6
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM(S) ALL WARRANTIES WITH REGARD
 * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
 * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
a111 27
/*
 * Copyright (c) 1999-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

d143 25
a167 46
static CARD32 ix86PciReadLongSetup(PCITAG tag, int off);
static void ix86PciWriteLongSetup(PCITAG, int off, CARD32 val);
static void ix86PciSetBitsLongSetup(PCITAG, int off, CARD32 mask, CARD32 val);
static CARD32 ix86PciReadLongCFG1(PCITAG tag, int off);
static void ix86PciWriteLongCFG1(PCITAG, int off, CARD32 val);
static void ix86PciSetBitsLongCFG1(PCITAG, int off, CARD32 mask, CARD32 val);
static CARD32 ix86PciReadLongCFG2(PCITAG tag, int off);
static void ix86PciWriteLongCFG2(PCITAG, int off, CARD32 val);
static void ix86PciSetBitsLongCFG2(PCITAG, int off, CARD32 mask, CARD32 val);

static pciBusFuncs_t ix86Funcs0 = {
/* pciReadLong      */	ix86PciReadLongSetup,
/* pciWriteLong     */	ix86PciWriteLongSetup,
/* pciSetBitsLong   */	ix86PciSetBitsLongSetup,
/* pciAddrHostToBus */	pciAddrNOOP,
/* pciAddrBusToHost */	pciAddrNOOP
};

static pciBusFuncs_t ix86Funcs1 = {
/* pciReadLong      */	ix86PciReadLongCFG1,
/* pciWriteLong     */	ix86PciWriteLongCFG1,
/* pciSetBitsLong   */	ix86PciSetBitsLongCFG1,
/* pciAddrHostToBus */	pciAddrNOOP,
/* pciAddrBusToHost */	pciAddrNOOP
};

static pciBusFuncs_t ix86Funcs2 = {
/* pciReadLong      */	ix86PciReadLongCFG2,
/* pciWriteLong     */	ix86PciWriteLongCFG2,
/* pciSetBitsLong   */	ix86PciSetBitsLongCFG2,
/* pciAddrHostToBus */	pciAddrNOOP,
/* pciAddrBusToHost */	pciAddrNOOP
};

static pciBusInfo_t ix86Pci0 = {
/* configMech  */	PCI_CFG_MECH_UNKNOWN,	/* Set by ix86PciInit() */
/* numDevices  */	0,			/* Set by ix86PciInit() */
/* secondary   */	FALSE,
/* primary_bus */	0,
#ifdef PowerMAX_OS
/* ppc_io_base */	0,
/* ppc_io_size */	0,
#endif
/* funcs       */	&ix86Funcs0,		/* Set by ix86PciInit() */
/* pciBusPriv  */	NULL,
/* bridge      */	NULL
a172 2
    PCITAG tag;
    CARD32 id, class;
d176 3
a178 21
	tag = PCI_MAKE_TAG(0, device, 0);
	id = (*ix86Pci0.funcs->pciReadLong)(tag, PCI_ID_REG);

	if ((CARD16)(id + 1U) <= (CARD16)1UL)
		continue;

	/* The rest of this is inspired by the Linux kernel */
	class = (*ix86Pci0.funcs->pciReadLong)(tag, PCI_CLASS_REG);

	/* Ignore revision id and programming interface */
	switch (class >> 16) {
	case (PCI_CLASS_PREHISTORIC << 8) | PCI_SUBCLASS_PREHISTORIC_MISC:
	    /* Check for vendors of known buggy chipsets */
	    id &= 0x0000ffff;
	    if ((id == PCI_VENDOR_INTEL) || (id == PCI_VENDOR_COMPAQ))
		return TRUE;
	    continue;

	case (PCI_CLASS_PREHISTORIC << 8) | PCI_SUBCLASS_PREHISTORIC_VGA:
	case (PCI_CLASS_DISPLAY << 8) | PCI_SUBCLASS_DISPLAY_VGA:
	case (PCI_CLASS_BRIDGE << 8) | PCI_SUBCLASS_BRIDGE_HOST:
a179 3

	default:
	    break;
d182 1
a182 1
    return FALSE;
d234 4
a237 2
	ix86Pci0.funcs = &ix86Funcs1;

d279 2
a280 3
			"PCI: stages = 0x%02x, oldVal1 = 0x%08lx, mode1Res1"
			" = 0x%08lx\n", stages, (unsigned long)oldVal1,
			(unsigned long)mode1Res1);
d333 3
a335 4
			"PCI: stages = 0x%02x, oldVal1 = 0x%08lx,\n"
			"\tmode1Res1 = 0x%08lx, mode1Res2 = 0x%08lx\n",
			stages, (unsigned long)oldVal1,
			(unsigned long)mode1Res1, (unsigned long)mode1Res2);
d347 1
a347 1

d349 4
a352 5
      xf86MsgVerb(X_INFO, 3, "PCI: stages = 0x%02x, oldVal1 = 0x%08lx,\n"
	       "\tmode1Res1 = 0x%08lx, mode1Res2 = 0x%08lx\n",
	       stages, (unsigned long)oldVal1, (unsigned long)mode1Res1,
	       (unsigned long)mode1Res2);

d358 3
a360 1
	ix86Pci0.funcs = &ix86Funcs2;
d390 3
a392 1
	ix86Pci0.funcs = &ix86Funcs2;
d404 3
a406 1
	ix86Pci0.funcs = &ix86Funcs1;
d417 3
a419 1
      ix86Pci0.funcs = &ix86Funcs1;
d428 3
a430 1
      ix86Pci0.funcs = &ix86Funcs2;
a434 3

    case PCIForceNone:
	break;
d438 1
a438 2
    ix86Pci0.configMech = PCI_CFG_MECH_UNKNOWN;
    xf86MsgVerb(X_INFO, 2, "PCI: No PCI bus found or probed for\n");
d458 1
a458 1

d465 1
a465 1

d469 1
a469 2

static CARD32
d473 1
a473 1
    return (*ix86Pci0.funcs->pciReadLong)(Tag,reg);
d475 2
a476 2

static CARD32
d482 1
a482 1
    ErrorF("ix86PciReadLong 0x%lx, %d\n", Tag, reg);
d491 1
a491 1
    ErrorF("ix86PciReadLong 0x%lx\n", data);
d497 1
a497 1
static CARD32
a501 1

d503 1
a503 1
    ErrorF("ix86PciReadLong 0x%lx, %d\n", Tag, reg);
a504 1

d516 1
a516 1
    ErrorF("ix86PciReadLong 0x%lx\n", data);
d522 1
a522 1
static void
d526 1
a526 1
    (*ix86Pci0.funcs->pciWriteLong)(Tag,reg,data);
d529 1
a529 1
static void
d540 1
a540 1
static void
d545 1
a545 1

d549 1
a549 1

d557 1
a557 1
static void
d561 1
a561 1
    (*ix86Pci0.funcs->pciSetBitsLong)(Tag,reg,mask,val);
d564 1
a564 1
static void
d581 1
a581 1
static void
@


1.1.9.2
log
@Import XFree86 4.4 from The XFree86(TM) Project, Inc.
(integrity cannot be checked)

got via cvs -qd anoncvs@@anoncvs.xfree86.org:/cvs co -Prxf-4_4_0 xc
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/bus/ix86Pci.c,v 1.26 2004/02/13 23:58:47 dawes Exp $ */
a113 1
 * All rights reserved.
d115 22
a136 41
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 *
 *   1.  Redistributions of source code must retain the above copyright
 *       notice, this list of conditions, and the following disclaimer.
 *
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer
 *       in the documentation and/or other materials provided with the
 *       distribution, and in the same place and form as other copyright,
 *       license and disclaimer information.
 *
 *   3.  The end-user documentation included with the redistribution,
 *       if any, must include the following acknowledgment: "This product
 *       includes software developed by The XFree86 Project, Inc
 *       (http://www.xfree86.org/) and its contributors", in the same
 *       place and form as other third-party acknowledgments.  Alternately,
 *       this acknowledgment may appear in the software itself, in the
 *       same form and location as other such third-party acknowledgments.
 *
 *   4.  Except as contained in this notice, the name of The XFree86
 *       Project, Inc shall not be used in advertising or otherwise to
 *       promote the sale, use or other dealings in this Software without
 *       prior written authorization from The XFree86 Project, Inc.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE XFREE86 PROJECT, INC OR ITS CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/bus/ix86Pci.c,v 1.18 2003/01/27 00:01:44 tsi Exp $ */
d5 1
a5 1
 * The XFree86 server PCI access functions have been reimplemented as a
d73 1
a73 1
 * not be used in advertising or publicity pertaining to distribution of
d75 2
a76 2
 * copyright holder(s) make(s) no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without express or
d79 6
a84 6
 * THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM(S) ALL WARRANTIES WITH REGARD
 * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
 * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
d143 25
a167 46
static CARD32 ix86PciReadLongSetup(PCITAG tag, int off);
static void ix86PciWriteLongSetup(PCITAG, int off, CARD32 val);
static void ix86PciSetBitsLongSetup(PCITAG, int off, CARD32 mask, CARD32 val);
static CARD32 ix86PciReadLongCFG1(PCITAG tag, int off);
static void ix86PciWriteLongCFG1(PCITAG, int off, CARD32 val);
static void ix86PciSetBitsLongCFG1(PCITAG, int off, CARD32 mask, CARD32 val);
static CARD32 ix86PciReadLongCFG2(PCITAG tag, int off);
static void ix86PciWriteLongCFG2(PCITAG, int off, CARD32 val);
static void ix86PciSetBitsLongCFG2(PCITAG, int off, CARD32 mask, CARD32 val);

static pciBusFuncs_t ix86Funcs0 = {
/* pciReadLong      */	ix86PciReadLongSetup,
/* pciWriteLong     */	ix86PciWriteLongSetup,
/* pciSetBitsLong   */	ix86PciSetBitsLongSetup,
/* pciAddrHostToBus */	pciAddrNOOP,
/* pciAddrBusToHost */	pciAddrNOOP
};

static pciBusFuncs_t ix86Funcs1 = {
/* pciReadLong      */	ix86PciReadLongCFG1,
/* pciWriteLong     */	ix86PciWriteLongCFG1,
/* pciSetBitsLong   */	ix86PciSetBitsLongCFG1,
/* pciAddrHostToBus */	pciAddrNOOP,
/* pciAddrBusToHost */	pciAddrNOOP
};

static pciBusFuncs_t ix86Funcs2 = {
/* pciReadLong      */	ix86PciReadLongCFG2,
/* pciWriteLong     */	ix86PciWriteLongCFG2,
/* pciSetBitsLong   */	ix86PciSetBitsLongCFG2,
/* pciAddrHostToBus */	pciAddrNOOP,
/* pciAddrBusToHost */	pciAddrNOOP
};

static pciBusInfo_t ix86Pci0 = {
/* configMech  */	PCI_CFG_MECH_UNKNOWN,	/* Set by ix86PciInit() */
/* numDevices  */	0,			/* Set by ix86PciInit() */
/* secondary   */	FALSE,
/* primary_bus */	0,
#ifdef PowerMAX_OS
/* ppc_io_base */	0,
/* ppc_io_size */	0,
#endif
/* funcs       */	&ix86Funcs0,		/* Set by ix86PciInit() */
/* pciBusPriv  */	NULL,
/* bridge      */	NULL
a172 2
    PCITAG tag;
    CARD32 id, class;
d176 3
a178 21
	tag = PCI_MAKE_TAG(0, device, 0);
	id = (*ix86Pci0.funcs->pciReadLong)(tag, PCI_ID_REG);

	if ((CARD16)(id + 1U) <= (CARD16)1UL)
		continue;

	/* The rest of this is inspired by the Linux kernel */
	class = (*ix86Pci0.funcs->pciReadLong)(tag, PCI_CLASS_REG);

	/* Ignore revision id and programming interface */
	switch (class >> 16) {
	case (PCI_CLASS_PREHISTORIC << 8) | PCI_SUBCLASS_PREHISTORIC_MISC:
	    /* Check for vendors of known buggy chipsets */
	    id &= 0x0000ffff;
	    if ((id == PCI_VENDOR_INTEL) || (id == PCI_VENDOR_COMPAQ))
		return TRUE;
	    continue;

	case (PCI_CLASS_PREHISTORIC << 8) | PCI_SUBCLASS_PREHISTORIC_VGA:
	case (PCI_CLASS_DISPLAY << 8) | PCI_SUBCLASS_DISPLAY_VGA:
	case (PCI_CLASS_BRIDGE << 8) | PCI_SUBCLASS_BRIDGE_HOST:
a179 3

	default:
	    break;
d182 1
a182 1
    return FALSE;
d234 4
a237 2
	ix86Pci0.funcs = &ix86Funcs1;

d347 1
a347 1

d352 1
a352 1

d358 3
a360 1
	ix86Pci0.funcs = &ix86Funcs2;
d390 3
a392 1
	ix86Pci0.funcs = &ix86Funcs2;
d404 3
a406 1
	ix86Pci0.funcs = &ix86Funcs1;
d417 3
a419 1
      ix86Pci0.funcs = &ix86Funcs1;
d428 3
a430 1
      ix86Pci0.funcs = &ix86Funcs2;
a434 3

    case PCIForceNone:
	break;
d438 1
a438 2
    ix86Pci0.configMech = PCI_CFG_MECH_UNKNOWN;
    xf86MsgVerb(X_INFO, 2, "PCI: No PCI bus found or probed for\n");
d458 1
a458 1

d465 1
a465 1

d469 1
a469 2

static CARD32
d473 1
a473 1
    return (*ix86Pci0.funcs->pciReadLong)(Tag,reg);
d475 2
a476 2

static CARD32
d482 1
a482 1
    ErrorF("ix86PciReadLong 0x%lx, %d\n", Tag, reg);
d491 1
a491 1
    ErrorF("ix86PciReadLong 0x%lx\n", data);
d497 1
a497 1
static CARD32
a501 1

d503 1
a503 1
    ErrorF("ix86PciReadLong 0x%lx, %d\n", Tag, reg);
a504 1

d516 1
a516 1
    ErrorF("ix86PciReadLong 0x%lx\n", data);
d522 1
a522 1
static void
d526 1
a526 1
    (*ix86Pci0.funcs->pciWriteLong)(Tag,reg,data);
d529 1
a529 1
static void
d540 1
a540 1
static void
d545 1
a545 1

d549 1
a549 1

d557 1
a557 1
static void
d561 1
a561 1
    (*ix86Pci0.funcs->pciSetBitsLong)(Tag,reg,mask,val);
d564 1
a564 1
static void
d581 1
a581 1
static void
a619 32

#ifdef ARCH_PCI_HOST_BRIDGE

/*
 * A small table of host bridges that limit the number of PCI buses to less
 * than the maximum of 256.
 */
static struct {
    CARD32 devid;
    int    maxpcibus;
} host_bridges[] = {
    { DEVID(ALI_2,	M1541),			128},
    { DEVID(VIA,	APOLLOVP1),		64},
    { DEVID(VIA,	APOLLOPRO133X),		64},
    { DEVID(INTEL,	430HX_BRIDGE),		16},
    { DEVID(INTEL,	440BX_BRIDGE),		32},
};
#define NUM_BRIDGES (sizeof(host_bridges) / sizeof(host_bridges[0]))

void ARCH_PCI_HOST_BRIDGE(pciConfigPtr pPCI)
{
    int i;

    for (i = 0;  i < NUM_BRIDGES;  i++) {
	if (pPCI->pci_device_vendor == host_bridges[i].devid) {
	    pciMaxBusNum = host_bridges[i].maxpcibus;
	    break;
	}
    }
}

#endif /* ARCH_PCI_HOST_BRIDGE */
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/os-support/bus/ix86Pci.c,v 1.25 2003/09/24 02:43:34 dawes Exp $ */
a111 27
/*
 * Copyright (c) 1999-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

d321 2
a322 3
			"PCI: stages = 0x%02x, oldVal1 = 0x%08lx, mode1Res1"
			" = 0x%08lx\n", stages, (unsigned long)oldVal1,
			(unsigned long)mode1Res1);
d375 3
a377 4
			"PCI: stages = 0x%02x, oldVal1 = 0x%08lx,\n"
			"\tmode1Res1 = 0x%08lx, mode1Res2 = 0x%08lx\n",
			stages, (unsigned long)oldVal1,
			(unsigned long)mode1Res1, (unsigned long)mode1Res2);
d391 3
a393 4
      xf86MsgVerb(X_INFO, 3, "PCI: stages = 0x%02x, oldVal1 = 0x%08lx,\n"
	       "\tmode1Res1 = 0x%08lx, mode1Res2 = 0x%08lx\n",
	       stages, (unsigned long)oldVal1, (unsigned long)mode1Res1,
	       (unsigned long)mode1Res2);
d659 32
@


