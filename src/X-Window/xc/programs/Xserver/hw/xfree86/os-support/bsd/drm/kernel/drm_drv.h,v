head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407221130:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	cvs-200406052200:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.08.32;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.08.32;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.37.30;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.24.36;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.25.05;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* drm_drv.h -- Generic driver template -*- linux-c -*-
 * Created: Thu Nov 23 03:10:50 2000 by gareth@@valinux.com
 *
 * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
 * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Rickard E. (Rik) Faith <faith@@valinux.com>
 *    Gareth Hughes <gareth@@valinux.com>
 */

/*
 * To use this template, you must at least define the following (samples
 * given for the MGA driver):
 *
 * #define DRIVER_AUTHOR	"VA Linux Systems, Inc."
 *
 * #define DRIVER_NAME		"mga"
 * #define DRIVER_DESC		"Matrox G200/G400"
 * #define DRIVER_DATE		"20001127"
 *
 * #define DRIVER_MAJOR		2
 * #define DRIVER_MINOR		0
 * #define DRIVER_PATCHLEVEL	2
 *
 * #define DRIVER_IOCTL_COUNT	DRM_ARRAY_SIZE( mga_ioctls )
 *
 * #define DRM(x)		mga_##x
 */

#ifndef __MUST_HAVE_AGP
#define __MUST_HAVE_AGP			0
#endif
#ifndef __HAVE_CTX_BITMAP
#define __HAVE_CTX_BITMAP		0
#endif
#ifndef __HAVE_DMA_IRQ
#define __HAVE_DMA_IRQ			0
#endif
#ifndef __HAVE_DMA_QUEUE
#define __HAVE_DMA_QUEUE		0
#endif
#ifndef __HAVE_MULTIPLE_DMA_QUEUES
#define __HAVE_MULTIPLE_DMA_QUEUES	0
#endif
#ifndef __HAVE_DMA_SCHEDULE
#define __HAVE_DMA_SCHEDULE		0
#endif
#ifndef __HAVE_DMA_FLUSH
#define __HAVE_DMA_FLUSH		0
#endif
#ifndef __HAVE_DMA_READY
#define __HAVE_DMA_READY		0
#endif
#ifndef __HAVE_DMA_QUIESCENT
#define __HAVE_DMA_QUIESCENT		0
#endif
#ifndef __HAVE_RELEASE
#define __HAVE_RELEASE			0
#endif
#ifndef __HAVE_COUNTERS
#define __HAVE_COUNTERS			0
#endif
#ifndef __HAVE_SG
#define __HAVE_SG			0
#endif
#ifndef __HAVE_KERNEL_CTX_SWITCH
#define __HAVE_KERNEL_CTX_SWITCH	0
#endif
#ifndef PCI_ANY_ID
#define PCI_ANY_ID	~0
#endif

#ifndef DRIVER_PREINIT
#define DRIVER_PREINIT()
#endif
#ifndef DRIVER_POSTINIT
#define DRIVER_POSTINIT()
#endif
#ifndef DRIVER_PRERELEASE
#define DRIVER_PRERELEASE()
#endif
#ifndef DRIVER_PRETAKEDOWN
#define DRIVER_PRETAKEDOWN()
#endif
#ifndef DRIVER_POSTCLEANUP
#define DRIVER_POSTCLEANUP()
#endif
#ifndef DRIVER_PRESETUP
#define DRIVER_PRESETUP()
#endif
#ifndef DRIVER_POSTSETUP
#define DRIVER_POSTSETUP()
#endif
#ifndef DRIVER_IOCTLS
#define DRIVER_IOCTLS
#endif
#ifndef DRIVER_FOPS
#if DRM_LINUX
#include <sys/file.h>
#include <sys/proc.h>
#include <machine/../linux/linux.h>
#include <machine/../linux/linux_proto.h>
#include "drm_linux.h"
#endif
#endif


/*
 * The default number of instances (minor numbers) to initialize.
 */
#ifndef DRIVER_NUM_CARDS
#define DRIVER_NUM_CARDS 1
#endif

static int DRM(init)(device_t nbdev);
static void DRM(cleanup)(device_t nbdev);

#define CDEV_MAJOR	145
#define DRIVER_SOFTC(unit) \
	((drm_device_t *) devclass_get_softc(DRM(devclass), unit))

#if __REALLY_HAVE_AGP
MODULE_DEPEND(DRIVER_NAME, agp, 1, 1, 1);
#endif
#if DRM_LINUX
MODULE_DEPEND(DRIVER_NAME, linux, 1, 1, 1);
#endif

static drm_device_t	*DRM(device);
static int		*DRM(minor);
static int		DRM(numdevs) = 0;


static drm_ioctl_desc_t		  DRM(ioctls)[] = {
	[DRM_IOCTL_NR(DRM_IOCTL_VERSION)]       = { DRM(version),     0, 0 },
	[DRM_IOCTL_NR(DRM_IOCTL_GET_UNIQUE)]    = { DRM(getunique),   0, 0 },
	[DRM_IOCTL_NR(DRM_IOCTL_GET_MAGIC)]     = { DRM(getmagic),    0, 0 },
	[DRM_IOCTL_NR(DRM_IOCTL_IRQ_BUSID)]     = { DRM(irq_busid),   0, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_GET_MAP)]       = { DRM(getmap),      0, 0 },
	[DRM_IOCTL_NR(DRM_IOCTL_GET_CLIENT)]    = { DRM(getclient),   0, 0 },
	[DRM_IOCTL_NR(DRM_IOCTL_GET_STATS)]     = { DRM(getstats),    0, 0 },

	[DRM_IOCTL_NR(DRM_IOCTL_SET_UNIQUE)]    = { DRM(setunique),   1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_BLOCK)]         = { DRM(block),       1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_UNBLOCK)]       = { DRM(unblock),     1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_AUTH_MAGIC)]    = { DRM(authmagic),   1, 1 },

	[DRM_IOCTL_NR(DRM_IOCTL_ADD_MAP)]       = { DRM(addmap),      1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_RM_MAP)]        = { DRM(rmmap),       1, 0 },

#if __HAVE_CTX_BITMAP
	[DRM_IOCTL_NR(DRM_IOCTL_SET_SAREA_CTX)] = { DRM(setsareactx), 1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_GET_SAREA_CTX)] = { DRM(getsareactx), 1, 0 },
#endif

	[DRM_IOCTL_NR(DRM_IOCTL_ADD_CTX)]       = { DRM(addctx),      1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_RM_CTX)]        = { DRM(rmctx),       1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_MOD_CTX)]       = { DRM(modctx),      1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_GET_CTX)]       = { DRM(getctx),      1, 0 },
	[DRM_IOCTL_NR(DRM_IOCTL_SWITCH_CTX)]    = { DRM(switchctx),   1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_NEW_CTX)]       = { DRM(newctx),      1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_RES_CTX)]       = { DRM(resctx),      1, 0 },

	[DRM_IOCTL_NR(DRM_IOCTL_ADD_DRAW)]      = { DRM(adddraw),     1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_RM_DRAW)]       = { DRM(rmdraw),      1, 1 },

	[DRM_IOCTL_NR(DRM_IOCTL_LOCK)]	        = { DRM(lock),        1, 0 },
	[DRM_IOCTL_NR(DRM_IOCTL_UNLOCK)]        = { DRM(unlock),      1, 0 },
	[DRM_IOCTL_NR(DRM_IOCTL_FINISH)]        = { DRM(finish),      1, 0 },

#if __HAVE_DMA
	[DRM_IOCTL_NR(DRM_IOCTL_ADD_BUFS)]      = { DRM(addbufs),     1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_MARK_BUFS)]     = { DRM(markbufs),    1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_INFO_BUFS)]     = { DRM(infobufs),    1, 0 },
	[DRM_IOCTL_NR(DRM_IOCTL_MAP_BUFS)]      = { DRM(mapbufs),     1, 0 },
	[DRM_IOCTL_NR(DRM_IOCTL_FREE_BUFS)]     = { DRM(freebufs),    1, 0 },

	/* The DRM_IOCTL_DMA ioctl should be defined by the driver.
	 */
#if __HAVE_DMA_IRQ
	[DRM_IOCTL_NR(DRM_IOCTL_CONTROL)]       = { DRM(control),     1, 1 },
#endif
#endif

#if __REALLY_HAVE_AGP
	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ACQUIRE)]   = { DRM(agp_acquire), 1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_AGP_RELEASE)]   = { DRM(agp_release), 1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ENABLE)]    = { DRM(agp_enable),  1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_AGP_INFO)]      = { DRM(agp_info),    1, 0 },
	[DRM_IOCTL_NR(DRM_IOCTL_AGP_ALLOC)]     = { DRM(agp_alloc),   1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_AGP_FREE)]      = { DRM(agp_free),    1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_AGP_BIND)]      = { DRM(agp_bind),    1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_AGP_UNBIND)]    = { DRM(agp_unbind),  1, 1 },
#endif

#if __REALLY_HAVE_SG
	[DRM_IOCTL_NR(DRM_IOCTL_SG_ALLOC)]      = { DRM(sg_alloc),    1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_SG_FREE)]       = { DRM(sg_free),     1, 1 },
#endif

	DRIVER_IOCTLS
};

#define DRIVER_IOCTL_COUNT	DRM_ARRAY_SIZE( DRM(ioctls) )


static int DRM(probe)(device_t dev)
{
	const char *s = 0;

	int pciid=pci_get_devid(dev);
	int vendor = (pciid & 0x0000ffff);
	int device = (pciid & 0xffff0000) >> 16;
	int i=0, done=0;
	DRM_INFO("Checking PCI vendor=%d, device=%d\n", vendor, device);
	while ( !done && (DRM(devicelist)[i].vendor != 0 ) ) {
		if ( (DRM(devicelist)[i].vendor == vendor) &&
		     (DRM(devicelist)[i].device == device) ) {
			done=1;
			if ( DRM(devicelist)[i].supported )
				s = DRM(devicelist)[i].name;
			else
				DRM_INFO("%s not supported\n", DRM(devicelist)[i].name);
		}
		i++;
	}
	
	if (s) {
		device_set_desc(dev, s);
		return 0;
	}

	return ENXIO;
}

static int DRM(attach)(device_t dev)
{
	return DRM(init)(dev);
}

static int DRM(detach)(device_t dev)
{
	DRM(cleanup)(dev);
	return 0;
}

static device_method_t DRM(methods)[] = {
	/* Device interface */
	DEVMETHOD(device_probe,		DRM( probe)),
	DEVMETHOD(device_attach,	DRM( attach)),
	DEVMETHOD(device_detach,	DRM( detach)),

	{ 0, 0 }
};

static driver_t DRM(driver) = {
	"drm",
	DRM(methods),
	sizeof(drm_device_t),
};

static devclass_t DRM( devclass);

static struct cdevsw DRM( cdevsw) = {
	/* open */	DRM( open ),
	/* close */	DRM( close ),
	/* read */	DRM( read ),
	/* write */	DRM( write ),
	/* ioctl */	DRM( ioctl ),
	/* poll */	DRM( poll ),
	/* mmap */	DRM( mmap ),
	/* strategy */	nostrategy,
	/* name */	DRIVER_NAME,
	/* maj */	CDEV_MAJOR,
	/* dump */	nodump,
	/* psize */	nopsize,
	/* flags */	D_TTY | D_TRACKCLOSE,
#if __FreeBSD_version >= 500000
	/* kqfilter */	0
#else
	/* bmaj */	-1
#endif
};

static int DRM(setup)( drm_device_t *dev )
{
	int i;

	DRIVER_PRESETUP();
	atomic_set( &dev->ioctl_count, 0 );
	atomic_set( &dev->vma_count, 0 );
	dev->buf_use = 0;
	atomic_set( &dev->buf_alloc, 0 );

#if __HAVE_DMA
	i = DRM(dma_setup)( dev );
	if ( i < 0 )
		return i;
#endif

	dev->counters  = 6 + __HAVE_COUNTERS;
	dev->types[0]  = _DRM_STAT_LOCK;
	dev->types[1]  = _DRM_STAT_OPENS;
	dev->types[2]  = _DRM_STAT_CLOSES;
	dev->types[3]  = _DRM_STAT_IOCTLS;
	dev->types[4]  = _DRM_STAT_LOCKS;
	dev->types[5]  = _DRM_STAT_UNLOCKS;
#ifdef __HAVE_COUNTER6
	dev->types[6]  = __HAVE_COUNTER6;
#endif
#ifdef __HAVE_COUNTER7
	dev->types[7]  = __HAVE_COUNTER7;
#endif
#ifdef __HAVE_COUNTER8
	dev->types[8]  = __HAVE_COUNTER8;
#endif
#ifdef __HAVE_COUNTER9
	dev->types[9]  = __HAVE_COUNTER9;
#endif
#ifdef __HAVE_COUNTER10
	dev->types[10] = __HAVE_COUNTER10;
#endif
#ifdef __HAVE_COUNTER11
	dev->types[11] = __HAVE_COUNTER11;
#endif
#ifdef __HAVE_COUNTER12
	dev->types[12] = __HAVE_COUNTER12;
#endif
#ifdef __HAVE_COUNTER13
	dev->types[13] = __HAVE_COUNTER13;
#endif
#ifdef __HAVE_COUNTER14
	dev->types[14] = __HAVE_COUNTER14;
#endif
#ifdef __HAVE_COUNTER15
	dev->types[14] = __HAVE_COUNTER14;
#endif

	for ( i = 0 ; i < DRM_ARRAY_SIZE(dev->counts) ; i++ )
		atomic_set( &dev->counts[i], 0 );

	for ( i = 0 ; i < DRM_HASH_SIZE ; i++ ) {
		dev->magiclist[i].head = NULL;
		dev->magiclist[i].tail = NULL;
	}

	dev->maplist = DRM(alloc)(sizeof(*dev->maplist),
				  DRM_MEM_MAPS);
	if(dev->maplist == NULL) DRM_OS_RETURN(ENOMEM);
	memset(dev->maplist, 0, sizeof(*dev->maplist));
	TAILQ_INIT(dev->maplist);
	dev->map_count = 0;

	dev->vmalist = NULL;
	dev->lock.hw_lock = NULL;
	dev->lock.lock_queue = 0;
	dev->queue_count = 0;
	dev->queue_reserved = 0;
	dev->queue_slots = 0;
	dev->queuelist = NULL;
	dev->irq = 0;
	dev->context_flag = 0;
	dev->interrupt_flag = 0;
	dev->dma_flag = 0;
	dev->last_context = 0;
	dev->last_switch = 0;
	dev->last_checked = 0;
#if __FreeBSD_version >= 500000
	callout_init( &dev->timer, 1 );
#else
	callout_init( &dev->timer );
#endif
	dev->context_wait = 0;

	dev->ctx_start = 0;
	dev->lck_start = 0;

	dev->buf_rp = dev->buf;
	dev->buf_wp = dev->buf;
	dev->buf_end = dev->buf + DRM_BSZ;
	dev->buf_sigio = NULL;
	dev->buf_readers = 0;
	dev->buf_writers = 0;
	dev->buf_selecting = 0;

	DRM_DEBUG( "\n" );

	/* The kernel's context could be created here, but is now created
	 * in drm_dma_enqueue.	This is more resource-efficient for
	 * hardware that does not do DMA, but may mean that
	 * drm_select_queue fails between the time the interrupt is
	 * initialized and the time the queues are initialized.
	 */
	DRIVER_POSTSETUP();
	return 0;
}


static int DRM(takedown)( drm_device_t *dev )
{
	drm_magic_entry_t *pt, *next;
	drm_map_t *map;
	drm_map_list_entry_t *list;
	drm_vma_entry_t *vma, *vma_next;
	int i;

	DRM_DEBUG( "\n" );

	DRIVER_PRETAKEDOWN();
#if __HAVE_DMA_IRQ
	if ( dev->irq ) DRM(irq_uninstall)( dev );
#endif

	DRM_OS_LOCK;
	callout_stop( &dev->timer );

	if ( dev->devname ) {
		DRM(free)( dev->devname, strlen( dev->devname ) + 1,
			   DRM_MEM_DRIVER );
		dev->devname = NULL;
	}

	if ( dev->unique ) {
		DRM(free)( dev->unique, strlen( dev->unique ) + 1,
			   DRM_MEM_DRIVER );
		dev->unique = NULL;
		dev->unique_len = 0;
	}
				/* Clear pid list */
	for ( i = 0 ; i < DRM_HASH_SIZE ; i++ ) {
		for ( pt = dev->magiclist[i].head ; pt ; pt = next ) {
			next = pt->next;
			DRM(free)( pt, sizeof(*pt), DRM_MEM_MAGIC );
		}
		dev->magiclist[i].head = dev->magiclist[i].tail = NULL;
	}

#if __REALLY_HAVE_AGP
				/* Clear AGP information */
	if ( dev->agp ) {
		drm_agp_mem_t *entry;
		drm_agp_mem_t *nexte;

				/* Remove AGP resources, but leave dev->agp
                                   intact until drv_cleanup is called. */
		for ( entry = dev->agp->memory ; entry ; entry = nexte ) {
			nexte = entry->next;
			if ( entry->bound ) DRM(unbind_agp)( entry->handle );
			DRM(free_agp)( entry->handle, entry->pages );
			DRM(free)( entry, sizeof(*entry), DRM_MEM_AGPLISTS );
		}
		dev->agp->memory = NULL;

		if ( dev->agp->acquired ) DRM(agp_do_release)();

		dev->agp->acquired = 0;
		dev->agp->enabled  = 0;
	}
#endif

				/* Clear vma list (only built for debugging) */
	if ( dev->vmalist ) {
		for ( vma = dev->vmalist ; vma ; vma = vma_next ) {
			vma_next = vma->next;
			DRM(free)( vma, sizeof(*vma), DRM_MEM_VMAS );
		}
		dev->vmalist = NULL;
	}

	if( dev->maplist ) {
		while ((list=TAILQ_FIRST(dev->maplist))) {
			map = list->map;
			switch ( map->type ) {
			case _DRM_REGISTERS:
			case _DRM_FRAME_BUFFER:
#if __REALLY_HAVE_MTRR
				if ( map->mtrr >= 0 ) {
					int retcode;
					retcode = mtrr_del( map->mtrr,
							    map->offset,
							    map->size );
					DRM_DEBUG( "mtrr_del=%d\n", retcode );
				}
#endif
				DRM(ioremapfree)( map->handle, map->size );
				break;
			case _DRM_SHM:
				DRM(free_pages)((unsigned long)map->handle,
					       DRM(order)(map->size)
					       - PAGE_SHIFT,
					       DRM_MEM_SAREA);
				break;

			case _DRM_AGP:
				/* Do nothing here, because this is all
				 * handled in the AGP/GART driver.
				 */
				break;
                       case _DRM_SCATTER_GATHER:
				/* Handle it, but do nothing, if REALLY_HAVE_SG
				 * isn't defined.
				 */
#if __REALLY_HAVE_SG
				if(dev->sg) {
					DRM(sg_cleanup)(dev->sg);
					dev->sg = NULL;
				}
#endif
				break;
			}
			TAILQ_REMOVE(dev->maplist, list, link);
			DRM(free)(list, sizeof(*list), DRM_MEM_MAPS);
			DRM(free)(map, sizeof(*map), DRM_MEM_MAPS);
		}
		DRM(free)(dev->maplist, sizeof(*dev->maplist), DRM_MEM_MAPS);
		dev->maplist   = NULL;
 	}

#if __HAVE_DMA_QUEUE || __HAVE_MULTIPLE_DMA_QUEUES
	if ( dev->queuelist ) {
		for ( i = 0 ; i < dev->queue_count ; i++ ) {
			DRM(waitlist_destroy)( &dev->queuelist[i]->waitlist );
			if ( dev->queuelist[i] ) {
				DRM(free)( dev->queuelist[i],
					  sizeof(*dev->queuelist[0]),
					  DRM_MEM_QUEUES );
				dev->queuelist[i] = NULL;
			}
		}
		DRM(free)( dev->queuelist,
			  dev->queue_slots * sizeof(*dev->queuelist),
			  DRM_MEM_QUEUES );
		dev->queuelist = NULL;
	}
	dev->queue_count = 0;
#endif

#if __HAVE_DMA
	DRM(dma_takedown)( dev );
#endif
	if ( dev->lock.hw_lock ) {
		dev->lock.hw_lock = NULL; /* SHM removed */
		dev->lock.pid = 0;
		DRM_OS_WAKEUP_INT(&dev->lock.lock_queue);
	}
	DRM_OS_UNLOCK;

	return 0;
}

/*
 * Figure out how many instances to initialize.
 */
static int drm_count_cards(void)
{
	int num = 0;
#if defined(DRIVER_CARD_LIST)
	int i;
	drm_pci_list_t *l;
	u16 device, vendor;
	struct pci_dev *pdev = NULL;
#endif

	DRM_DEBUG( "\n" );

#if defined(DRIVER_COUNT_CARDS)
	num = DRIVER_COUNT_CARDS();
#elif defined(DRIVER_CARD_LIST)
	for (i = 0, l = DRIVER_CARD_LIST; l[i].vendor != 0; i++) {
		pdev = NULL;
		vendor = l[i].vendor;
		device = l[i].device;
		if(device == 0xffff) device = PCI_ANY_ID;
		if(vendor == 0xffff) vendor = PCI_ANY_ID;
		while ((pdev = pci_find_device(vendor, device, pdev))) {
			num++;	/* FIXME: What about two cards of the same device id? */
		}
	}
#else
	num = DRIVER_NUM_CARDS;
#endif
	DRM_DEBUG("numdevs = %d\n", num);
	return num;
}

/* drm_init is called via init_module at module load time, or via
 * linux/init/main.c (this is not currently supported).
 */
static int DRM(init)( device_t nbdev )
{

	drm_device_t *dev;
	int i;
#if __HAVE_CTX_BITMAP
	int retcode;
#endif
	DRM_DEBUG( "\n" );

#ifdef MODULE
	DRM(parse_options)( drm_opts );
#endif

	DRM(numdevs) = drm_count_cards();
	/* Force at least one instance. */
	if (DRM(numdevs) <= 0)
		DRM(numdevs) = 1;

	DRM(device) = DRM_OS_MALLOC(sizeof(*DRM(device)) * DRM(numdevs));
	if (!DRM(device)) {
		DRM_OS_RETURN(ENOMEM);
	}
	DRM(minor) = DRM_OS_MALLOC(sizeof(*(DRM(minor))) * DRM(numdevs));
	if (!DRM(minor)) {
		DRM_OS_FREE(DRM(device));
		DRM_OS_RETURN(ENOMEM);
	}

	DRIVER_PREINIT();


	for (i = 0; i < DRM(numdevs); i++) {
		int unit = device_get_unit(nbdev);
		/* FIXME??? - multihead !!! */
		dev = device_get_softc(nbdev);
		memset( (void *)dev, 0, sizeof(*dev) );
		DRM(minor)[i]=unit;
		DRM_OS_SPININIT(dev->count_lock, "drm device");
		lockinit(&dev->dev_lock, PZERO, "drmlk", 0, 0);
		dev->device = nbdev;
		dev->devnode = make_dev( &DRM(cdevsw),
				unit,
				DRM_DEV_UID,
				DRM_DEV_GID,
				DRM_DEV_MODE,
				"dri/card%d", unit );
		dev->name   = DRIVER_NAME;
		DRM(mem_init)();
		DRM(sysctl_init)(dev);
		TAILQ_INIT(&dev->files);

#if __REALLY_HAVE_AGP
		dev->agp = DRM(agp_init)();
#if __MUST_HAVE_AGP
		if ( dev->agp == NULL ) {
			DRM_ERROR( "Cannot initialize the agpgart module.\n" );
			DRM(sysctl_cleanup)( dev );
			destroy_dev(dev->devnode);
			DRM(takedown)( dev );
			DRM_OS_RETURN(ENOMEM);
		}
#endif
#if __REALLY_HAVE_MTRR
		if (dev->agp)
			dev->agp->agp_mtrr = mtrr_add( dev->agp->agp_info.aper_base,
				       dev->agp->agp_info.aper_size*1024*1024,
				       MTRR_TYPE_WRCOMB,
				       1 );
#endif
#endif

#if __HAVE_CTX_BITMAP
		retcode = DRM(ctxbitmap_init)( dev );
		if( retcode ) {
			DRM_ERROR( "Cannot allocate memory for context bitmap.\n" );
			DRM(sysctl_cleanup)( dev );
			destroy_dev(dev->devnode);
			DRM(takedown)( dev );
			return retcode;
		}
#endif
		DRM_INFO( "Initialized %s %d.%d.%d %s on minor %d\n",
		  	DRIVER_NAME,
		  	DRIVER_MAJOR,
		  	DRIVER_MINOR,
		  	DRIVER_PATCHLEVEL,
		  	DRIVER_DATE,
		  	DRM(minor)[i] );
	}

	DRIVER_POSTINIT();

	return 0;
}

/* drm_cleanup is called via cleanup_module at module unload time.
 */
static void DRM(cleanup)(device_t nbdev)
{
	drm_device_t *dev;
	int i;

	DRM_DEBUG( "\n" );

	for (i = DRM(numdevs) - 1; i >= 0; i--) {
		/* FIXME??? - multihead */
		dev = device_get_softc(nbdev);
		DRM(sysctl_cleanup)( dev );
		destroy_dev(dev->devnode);
#if __HAVE_CTX_BITMAP
		DRM(ctxbitmap_cleanup)( dev );
#endif

#if __REALLY_HAVE_AGP && __REALLY_HAVE_MTRR
		if ( dev->agp && dev->agp->agp_mtrr >= 0) {
			int retval;
			retval = mtrr_del( dev->agp->agp_mtrr,
				   dev->agp->agp_info.aper_base,
				   dev->agp->agp_info.aper_size*1024*1024 );
			DRM_DEBUG( "mtrr_del=%d\n", retval );
		}
#endif

		DRM(takedown)( dev );

#if __REALLY_HAVE_AGP
		if ( dev->agp ) {
			DRM(agp_uninit)();
			DRM(free)( dev->agp, sizeof(*dev->agp), DRM_MEM_AGPLISTS );
			dev->agp = NULL;
		}
#endif
	}
	DRIVER_POSTCLEANUP();
	DRM_OS_FREE(DRM(minor));
	DRM_OS_FREE(DRM(device));
	DRM(numdevs) = 0;
}


int DRM(version)( DRM_OS_IOCTL )
{
	drm_version_t version;
	int len;

	DRM_OS_KRNFROMUSR( version, (drm_version_t *)data, sizeof(version) );

#define DRM_COPY( name, value )						\
	len = strlen( value );						\
	if ( len > name##_len ) len = name##_len;			\
	name##_len = strlen( value );					\
	if ( len && name ) {						\
		if ( DRM_OS_COPYTOUSR( name, value, len ) )		\
			DRM_OS_RETURN(EFAULT);				\
	}

	version.version_major = DRIVER_MAJOR;
	version.version_minor = DRIVER_MINOR;
	version.version_patchlevel = DRIVER_PATCHLEVEL;

	DRM_COPY( version.name, DRIVER_NAME );
	DRM_COPY( version.date, DRIVER_DATE );
	DRM_COPY( version.desc, DRIVER_DESC );

	DRM_OS_KRNTOUSR( (drm_version_t *)data, version, sizeof(version) );

	return 0;
}

int DRM( open)(dev_t kdev, int flags, int fmt, DRM_OS_STRUCTPROC *p)
{
	drm_device_t *dev = NULL;
	int retcode = 0;
	int i;

	for (i = 0; i < DRM(numdevs); i++) {
		/* FIXME ??? - multihead */
		dev    = DRIVER_SOFTC(minor(kdev));
	}
	if (!dev) {
		DRM_OS_RETURN(ENODEV);
	}

	DRM_DEBUG( "open_count = %d\n", dev->open_count );

	device_busy(dev->device);
	retcode = DRM(open_helper)(kdev, flags, fmt, p, dev);

	if ( !retcode ) {
		atomic_inc( &dev->counts[_DRM_STAT_OPENS] );
		DRM_OS_SPINLOCK( &dev->count_lock );
		if ( !dev->open_count++ ) {
			DRM_OS_SPINUNLOCK( &dev->count_lock );
			return DRM(setup)( dev );
		}
		DRM_OS_SPINUNLOCK( &dev->count_lock );
	}
	device_unbusy(dev->device);

	return retcode;
}

int DRM( close)(dev_t kdev, int flags, int fmt, DRM_OS_STRUCTPROC *p)
{
	drm_file_t *priv;
	drm_device_t  *dev    = kdev->si_drv1;
	int retcode = 0;

	DRM_DEBUG( "open_count = %d\n", dev->open_count );
	priv = DRM(find_file_by_proc)(dev, p);
	if (!priv) {
		DRM_DEBUG("can't find authenticator\n");
		return EINVAL;
	}

	DRIVER_PRERELEASE();

	/* ========================================================
	 * Begin inline drm_release
	 */

	DRM_DEBUG( "pid = %d, device = 0x%lx, open_count = %d\n",
		   DRM_OS_CURRENTPID, (long)dev->device, dev->open_count );

	if (dev->lock.hw_lock && _DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)
	    && dev->lock.pid == DRM_OS_CURRENTPID) {
		DRM_DEBUG("Process %d dead, freeing lock for context %d\n",
			  DRM_OS_CURRENTPID,
			  _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
#if HAVE_DRIVER_RELEASE
		DRIVER_RELEASE();
#endif
		DRM(lock_free)(dev,
			      &dev->lock.hw_lock->lock,
			      _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
		
				/* FIXME: may require heavy-handed reset of
                                   hardware at this point, possibly
                                   processed via a callback to the X
                                   server. */
	}
#if __HAVE_RELEASE
	else if ( dev->lock.hw_lock ) {
		/* The lock is required to reclaim buffers */
		for (;;) {
			if ( !dev->lock.hw_lock ) {
				/* Device has been unregistered */
				retcode = EINTR;
				break;
			}
			if ( DRM(lock_take)( &dev->lock.hw_lock->lock,
					     DRM_KERNEL_CONTEXT ) ) {
				dev->lock.pid       = p->p_pid;
				dev->lock.lock_time = jiffies;
                                atomic_inc( &dev->counts[_DRM_STAT_LOCKS] );
				break;	/* Got lock */
			}
				/* Contention */
#if 0
			atomic_inc( &dev->total_sleeps );
#endif
			retcode = tsleep(&dev->lock.lock_queue,
					PZERO|PCATCH,
					"drmlk2",
					0);
			if (retcode)
				break;
		}
		if( !retcode ) {
			DRIVER_RELEASE();
			DRM(lock_free)( dev, &dev->lock.hw_lock->lock,
					DRM_KERNEL_CONTEXT );
		}
	}
#elif __HAVE_DMA
	DRM(reclaim_buffers)( dev, priv->pid );
#endif

	funsetown(dev->buf_sigio);

	DRM_OS_LOCK;
	priv = DRM(find_file_by_proc)(dev, p);
	if (priv) {
		priv->refs--;
		if (!priv->refs) {
			TAILQ_REMOVE(&dev->files, priv, link);
		}
	}
	DRM_OS_UNLOCK;

	DRM(free)( priv, sizeof(*priv), DRM_MEM_FILES );

	/* ========================================================
	 * End inline drm_release
	 */

	atomic_inc( &dev->counts[_DRM_STAT_CLOSES] );
	DRM_OS_SPINLOCK( &dev->count_lock );
	if ( !--dev->open_count ) {
		if ( atomic_read( &dev->ioctl_count ) || dev->blocked ) {
			DRM_ERROR( "Device busy: %ld %d\n",
				(unsigned long)atomic_read( &dev->ioctl_count ),
				   dev->blocked );
			DRM_OS_SPINUNLOCK( &dev->count_lock );
			DRM_OS_RETURN(EBUSY);
		}
		DRM_OS_SPINUNLOCK( &dev->count_lock );
		device_unbusy(dev->device);
		return DRM(takedown)( dev );
	}
	DRM_OS_SPINUNLOCK( &dev->count_lock );

	
	DRM_OS_RETURN(retcode);
}

/* DRM(ioctl) is called whenever a process performs an ioctl on /dev/drm.
 */
int DRM(ioctl)( DRM_OS_IOCTL )
{
	DRM_OS_DEVICE;
	int retcode = 0;
	drm_ioctl_desc_t *ioctl;
	d_ioctl_t *func;
	int nr = DRM_IOCTL_NR(cmd);
	DRM_OS_PRIV;

	atomic_inc( &dev->ioctl_count );
	atomic_inc( &dev->counts[_DRM_STAT_IOCTLS] );
	++priv->ioctl_count;

	DRM_DEBUG( "pid=%d, cmd=0x%02lx, nr=0x%02x, dev 0x%lx, auth=%d\n",
		 DRM_OS_CURRENTPID, cmd, nr, (long)dev->device, priv->authenticated );

	switch (cmd) {
	case FIONBIO:
		atomic_dec(&dev->ioctl_count);
		return 0;

	case FIOASYNC:
		atomic_dec(&dev->ioctl_count);
		dev->flags |= FASYNC;
		return 0;

	case FIOSETOWN:
		atomic_dec(&dev->ioctl_count);
		return fsetown(*(int *)data, &dev->buf_sigio);

	case FIOGETOWN:
		atomic_dec(&dev->ioctl_count);
		*(int *) data = fgetown(dev->buf_sigio);
		return 0;
	}

	if ( nr >= DRIVER_IOCTL_COUNT ) {
		retcode = EINVAL;
	} else {
		ioctl = &DRM(ioctls)[nr];
		func = ioctl->func;

		if ( !func ) {
			DRM_DEBUG( "no function\n" );
			retcode = EINVAL;
		} else if ( ( ioctl->root_only && DRM_OS_CHECKSUSER ) 
			 || ( ioctl->auth_needed && !priv->authenticated ) ) {
			retcode = EACCES;
		} else {
			retcode = func( kdev, cmd, data, flags, p );
		}
	}

	atomic_dec( &dev->ioctl_count );
	DRM_OS_RETURN(retcode);
}

int DRM(lock)( DRM_OS_IOCTL )
{
	DRM_OS_DEVICE;
        drm_lock_t lock;
        int ret = 0;
#if __HAVE_MULTIPLE_DMA_QUEUES
	drm_queue_t *q;
#endif
#if __HAVE_DMA_HISTOGRAM
        cycles_t start;

        dev->lck_start = start = get_cycles();
#endif

	DRM_OS_KRNFROMUSR( lock, (drm_lock_t *)data, sizeof(lock) );

        if ( lock.context == DRM_KERNEL_CONTEXT ) {
                DRM_ERROR( "Process %d using kernel context %d\n",
			   DRM_OS_CURRENTPID, lock.context );
                DRM_OS_RETURN(EINVAL);
        }

        DRM_DEBUG( "%d (pid %d) requests lock (0x%08x), flags = 0x%08x\n",
		   lock.context, DRM_OS_CURRENTPID,
		   dev->lock.hw_lock->lock, lock.flags );

#if __HAVE_DMA_QUEUE
        if ( lock.context < 0 )
                DRM_OS_RETURN(EINVAL);
#elif __HAVE_MULTIPLE_DMA_QUEUES
        if ( lock.context < 0 || lock.context >= dev->queue_count )
                DRM_OS_RETURN(EINVAL);
	q = dev->queuelist[lock.context];
#endif

#if __HAVE_DMA_FLUSH
	ret = DRM(flush_block_and_flush)( dev, lock.context, lock.flags );
#endif
        if ( !ret ) {
                for (;;) {
                        if ( !dev->lock.hw_lock ) {
                                /* Device has been unregistered */
                                ret = EINTR;
                                break;
                        }
                        if ( DRM(lock_take)( &dev->lock.hw_lock->lock,
					     lock.context ) ) {
                                dev->lock.pid       = DRM_OS_CURRENTPID;
                                dev->lock.lock_time = jiffies;
                                atomic_inc( &dev->counts[_DRM_STAT_LOCKS] );
                                break;  /* Got lock */
                        }

                                /* Contention */
			ret = tsleep(&dev->lock.lock_queue,
					PZERO|PCATCH,
					"drmlk2",
					0);
			if (ret)
				break;
                }
        }

#if __HAVE_DMA_FLUSH
	DRM(flush_unblock)( dev, lock.context, lock.flags ); /* cleanup phase */
#endif

        if ( !ret ) {

#if __HAVE_DMA_READY
                if ( lock.flags & _DRM_LOCK_READY ) {
			DRIVER_DMA_READY();
		}
#endif
#if __HAVE_DMA_QUIESCENT
                if ( lock.flags & _DRM_LOCK_QUIESCENT ) {
			DRIVER_DMA_QUIESCENT();
		}
#endif
#if __HAVE_KERNEL_CTX_SWITCH
		if ( dev->last_context != lock.context ) {
			DRM(context_switch)(dev, dev->last_context,
					    lock.context);
		}
#endif
        }

        DRM_DEBUG( "%d %s\n", lock.context, ret ? "interrupted" : "has lock" );

#if __HAVE_DMA_HISTOGRAM
        atomic_inc(&dev->histo.lacq[DRM(histogram_slot)(get_cycles()-start)]);
#endif

	DRM_OS_RETURN(ret);
}


int DRM(unlock)( DRM_OS_IOCTL )
{
	DRM_OS_DEVICE;
	drm_lock_t lock;

	DRM_OS_KRNFROMUSR( lock, (drm_lock_t *)data, sizeof(lock) ) ;

	if ( lock.context == DRM_KERNEL_CONTEXT ) {
		DRM_ERROR( "Process %d using kernel context %d\n",
			   DRM_OS_CURRENTPID, lock.context );
		DRM_OS_RETURN(EINVAL);
	}

	atomic_inc( &dev->counts[_DRM_STAT_UNLOCKS] );

#if __HAVE_KERNEL_CTX_SWITCH
	/* We no longer really hold it, but if we are the next
	 * agent to request it then we should just be able to
	 * take it immediately and not eat the ioctl.
	 */
	dev->lock.pid = 0;
	{
		__volatile__ unsigned int *plock = &dev->lock.hw_lock->lock;
		unsigned int old, new, prev, ctx;

		ctx = lock.context;
		do {
			old  = *plock;
			new  = ctx;
			prev = cmpxchg(plock, old, new);
		} while (prev != old);
	}
	wake_up_interruptible(&dev->lock.lock_queue);
#else
	DRM(lock_transfer)( dev, &dev->lock.hw_lock->lock,
			    DRM_KERNEL_CONTEXT );
#if __HAVE_DMA_SCHEDULE
	DRM(dma_schedule)( dev, 1 );
#endif

	/* FIXME: Do we ever really need to check this???
	 */
	if ( 1 /* !dev->context_flag */ ) {
		if ( DRM(lock_free)( dev, &dev->lock.hw_lock->lock,
				     DRM_KERNEL_CONTEXT ) ) {
			DRM_ERROR( "\n" );
		}
	}
#endif /* !__HAVE_KERNEL_CTX_SWITCH */

	return 0;
}

#if DRM_LINUX
static linux_ioctl_function_t DRM( linux_ioctl);
static struct linux_ioctl_handler DRM( handler) = {DRM( linux_ioctl), LINUX_IOCTL_DRM_MIN, LINUX_IOCTL_DRM_MAX};
SYSINIT  (DRM( register),   SI_SUB_KLD, SI_ORDER_MIDDLE, linux_ioctl_register_handler, &DRM( handler));
SYSUNINIT(DRM( unregister), SI_SUB_KLD, SI_ORDER_MIDDLE, linux_ioctl_unregister_handler, &DRM( handler));

/*
 * Linux emulation IOCTL
 */
static int
DRM(linux_ioctl)(DRM_OS_STRUCTPROC *p, struct linux_ioctl_args* args)
{
#if (__FreeBSD_version >= 500000)
    struct file		*fp = p->td_proc->p_fd->fd_ofiles[args->fd];
#else
    struct file		*fp = p->p_fd->fd_ofiles[args->fd];
#endif
    u_long		cmd = args->cmd;
    caddr_t             data = (caddr_t) args->arg;
    /*
     * Pass the ioctl off to our standard handler.
     */
    return(fo_ioctl(fp, cmd, data, p));
}
#endif /* DRM_LINUX */
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@a29 1
 *
d57 2
a58 2
#ifndef __HAVE_IRQ
#define __HAVE_IRQ			0
d63 3
d69 6
d87 6
d118 7
a124 2
#ifndef DRIVER_OPEN_HELPER
#define DRIVER_OPEN_HELPER( priv, dev )
a125 1
#ifndef DRIVER_FOPS
d128 6
a133 4
#if 1 && DRM_DEBUG_CODE
int DRM(flags) = DRM_FLAG_DEBUG;
#else
int DRM(flags) = 0;
d137 1
a137 1
static void DRM(cleanup)(drm_device_t *dev);
d139 1
a139 1
#ifdef __FreeBSD__
d146 7
a152 1
#endif /* __FreeBSD__ */
a153 4
#ifdef __NetBSD__
#define DRIVER_SOFTC(unit) \
	((drm_device_t *) device_lookup(&DRM(cd), unit))
#endif /* __NetBSD__ */
d159 1
a159 3
#if __HAVE_IRQ
	[DRM_IOCTL_NR(DRM_IOCTL_IRQ_BUSID)]     = { DRM(irq_by_busid), 0, 1 },
#endif
a162 1
	[DRM_IOCTL_NR(DRM_IOCTL_SET_VERSION)]   = { DRM(setversion),  0, 1 },
d165 2
a166 2
	[DRM_IOCTL_NR(DRM_IOCTL_BLOCK)]         = { DRM(noop),        1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_UNBLOCK)]       = { DRM(noop),        1, 1 },
d190 1
a190 1
	[DRM_IOCTL_NR(DRM_IOCTL_FINISH)]        = { DRM(noop),        1, 0 },
d198 5
a202 1
	/* The DRM_IOCTL_DMA ioctl should be defined by the driver. */
a203 2
#if __HAVE_IRQ || __HAVE_DMA
	[DRM_IOCTL_NR(DRM_IOCTL_CONTROL)]       = { DRM(control),     1, 1 },
d217 1
a217 1
#if __HAVE_SG
a221 4
#if __HAVE_VBL_IRQ
	[DRM_IOCTL_NR(DRM_IOCTL_WAIT_VBLANK)]   = { DRM(wait_vblank), 0, 0 },
#endif

a226 21
const char *DRM(find_description)(int vendor, int device);

#ifdef __FreeBSD__
static struct cdevsw DRM(cdevsw) = {
	.d_open =	DRM( open ),
	.d_close =	DRM( close ),
	.d_read =	DRM( read ),
	.d_ioctl =	DRM( ioctl ),
	.d_poll =	DRM( poll ),
	.d_mmap =	DRM( mmap ),
	.d_name =	DRIVER_NAME,
	.d_maj =	CDEV_MAJOR,
	.d_flags =	D_TTY | D_TRACKCLOSE,
#if __FreeBSD_version < 500000
	.d_bmaj =	-1
#endif
};

static drm_pci_id_list_t DRM(pciidlist)[] = {
	DRIVER_PCI_IDS
};
d230 1
a230 2
	const char *s = NULL;
	int pciid, vendor, device;
d232 16
a247 8
	/* XXX: Cope with agp bridge device? */
	if (!strcmp(device_get_name(dev), "drmsub"))
		pciid = pci_get_devid(device_get_parent(dev));
	else
		pciid = pci_get_devid(dev);

	vendor = (pciid & 0x0000ffff);
	device = (pciid & 0xffff0000) >> 16;
d249 1
a249 2
	s = DRM(find_description)(vendor, device);
	if (s != NULL) {
d264 1
a264 1
	DRM(cleanup)(device_get_softc(dev));
d267 1
d270 3
a272 3
	DEVMETHOD(device_probe,		DRM(probe)),
	DEVMETHOD(device_attach,	DRM(attach)),
	DEVMETHOD(device_detach,	DRM(detach)),
d283 1
a283 1
static devclass_t DRM(devclass);
d285 16
a300 19
#elif defined(__NetBSD__)

static struct cdevsw DRM(cdevsw) = {
	DRM(open),
	DRM(close),
	DRM(read),
	nowrite,
	DRM(ioctl),
	nostop,
	notty,
	DRM(poll),
	DRM(mmap),
	nokqfilter,
	D_TTY
};

int DRM(refcnt) = 0;
#if __NetBSD_Version__ >= 106080000
MOD_DEV( DRIVER_NAME, DRIVER_NAME, NULL, -1, &DRM(cdevsw), CDEV_MAJOR);
d302 1
a302 1
MOD_DEV( DRIVER_NAME, LM_DT_CHAR, CDEV_MAJOR, &DRM(cdevsw) );
d304 1
a305 116
int DRM(lkmentry)(struct lkm_table *lkmtp, int cmd, int ver);
static int DRM(lkmhandle)(struct lkm_table *lkmtp, int cmd);

int DRM(modprobe)();
int DRM(probe)(struct pci_attach_args *pa);
void DRM(attach)(struct pci_attach_args *pa, dev_t kdev);

int DRM(lkmentry)(struct lkm_table *lkmtp, int cmd, int ver) {
	DISPATCH(lkmtp, cmd, ver, DRM(lkmhandle), DRM(lkmhandle), DRM(lkmhandle));
}

static int DRM(lkmhandle)(struct lkm_table *lkmtp, int cmd)
{
	int j, error = 0;
#if defined(__NetBSD__) && (__NetBSD_Version__ > 106080000)
	struct lkm_dev *args = lkmtp->private.lkm_dev;
#endif

	switch(cmd) {
	case LKM_E_LOAD:
		if (lkmexists(lkmtp))
			return EEXIST;

		if(DRM(modprobe)())
			return 0;

		return 1;

	case LKM_E_UNLOAD:
		if (DRM(refcnt) > 0)
			return (EBUSY);
		break;
	case LKM_E_STAT:
		break;

	default:
		error = EIO;
		break;
	}
	
	return error;
}

int DRM(modprobe)() {
	struct pci_attach_args pa;
	int error = 0;
	if((error = pci_find_device(&pa, DRM(probe))) != 0)
		DRM(attach)(&pa, 0);

	return error;
}

int DRM(probe)(struct pci_attach_args *pa)
{
	const char *desc;

	desc = DRM(find_description)(PCI_VENDOR(pa->pa_id),
	    PCI_PRODUCT(pa->pa_id));
	if (desc != NULL) {
		return 1;
	}

	return 0;
}

void DRM(attach)(struct pci_attach_args *pa, dev_t kdev)
{
	int i;
	drm_device_t *dev;

	config_makeroom(kdev, &DRM(cd));
	DRM(cd).cd_devs[(kdev)] = DRM(alloc)(sizeof(drm_device_t),
	    DRM_MEM_DRIVER);
	dev = DRIVER_SOFTC(kdev);

	memset(dev, 0, sizeof(drm_device_t));
	memcpy(&dev->pa, pa, sizeof(dev->pa));

	DRM_INFO("%s", DRM(find_description)(PCI_VENDOR(pa->pa_id), PCI_PRODUCT(pa->pa_id)));
	DRM(init)(dev);
}

int DRM(detach)(struct device *self, int flags)
{
	DRM(cleanup)((drm_device_t *)self);
	return 0;
}

int DRM(activate)(struct device *self, enum devact act)
{
	switch (act) {
	case DVACT_ACTIVATE:
		return (EOPNOTSUPP);
		break;

	case DVACT_DEACTIVATE:
		/* FIXME */
		break;
	}
	return (0);
}
#endif /* __NetBSD__ */

const char *DRM(find_description)(int vendor, int device) {
	int i = 0;
	
	for (i = 0; DRM(pciidlist)[i].vendor != 0; i++) {
		if ((DRM(pciidlist)[i].vendor == vendor) &&
		    (DRM(pciidlist)[i].device == device)) {
			return DRM(pciidlist)[i].name;
		}
	}
	return NULL;
}

/* Initialize the DRM on first open. */
a309 2
	DRM_SPINLOCK_ASSERT(&dev->dev_lock);

d311 2
d314 1
d318 1
a318 1
	if ( i != 0 )
d368 8
d378 5
a382 1
	dev->irq_enabled = 0;
d384 2
d387 11
a397 1
	dev->if_version = 0;
d399 3
a401 1
#ifdef __FreeBSD__
d403 3
a405 3
#elif defined(__NetBSD__)
	dev->buf_pgid = 0;
#endif
d409 6
d419 1
a419 1
/* Free resources associated with the DRM on the last close. */
d423 1
a423 1
	drm_local_map_t *map;
d425 1
a427 2
	DRM_SPINLOCK_ASSERT(&dev->dev_lock);

d431 2
a432 3
#if __HAVE_IRQ
	if (dev->irq_enabled)
		DRM(irq_uninstall)( dev );
d435 9
d466 1
a466 1
                                   intact until DRM(cleanup) is called. */
d481 8
a488 4
#if __REALLY_HAVE_SG
	if (dev->sg != NULL) {
		DRM(sg_cleanup)(dev->sg);
		dev->sg = NULL;
a489 1
#endif
d491 1
a491 1
	if (dev->maplist != NULL) {
d499 5
a503 5
					int __unused mtrr;

					mtrr = DRM(mtrr_del)(map->offset,
					    map->size, DRM_MTRR_WC);
					DRM_DEBUG("mtrr_del=%d\n", mtrr);
d506 1
a506 1
				DRM(ioremapfree)( map );
d509 3
a511 2
				DRM(free)(map->handle,
					       map->size,
a515 1
			case _DRM_SCATTER_GATHER:
d517 1
a517 1
				 * handled in the AGP/GART/SG functions.
d520 11
d536 2
d540 19
d564 2
a565 2
		dev->lock.filp = NULL;
		DRM_WAKEUP_INT((void *)&dev->lock.lock_queue);
d567 1
d572 37
a608 3
/* linux: drm_init is called via init_module at module load time, or via
 *        linux/init/main.c (this is not currently supported).
 * bsd:   drm_init is called via the attach function per device.
d612 1
a612 2
	int unit;
#ifdef __FreeBSD__
d614 1
a614 3
#elif defined(__NetBSD__)
	drm_device_t *dev = nbdev;
#endif
a618 11
	DRIVER_PREINIT();

#ifdef __FreeBSD__
	unit = device_get_unit(nbdev);
	dev = device_get_softc(nbdev);
	memset( (void *)dev, 0, sizeof(*dev) );

	if (!strcmp(device_get_name(nbdev), "drmsub"))
		dev->device = device_get_parent(nbdev);
	else
		dev->device = nbdev;
d620 2
a621 11
	dev->devnode = make_dev( &DRM(cdevsw),
			unit,
			DRM_DEV_UID,
			DRM_DEV_GID,
			DRM_DEV_MODE,
			"dri/card%d", unit );
#if __FreeBSD_version >= 500000
	mtx_init(&dev->dev_lock, "drm device", NULL, MTX_DEF);
#endif
#elif defined(__NetBSD__)
	unit = minor(dev->device.dv_unit);
d624 13
a636 11
	dev->irq = pci_get_irq(dev->device);
	/* XXX Fix domain number (alpha hoses) */
	dev->pci_domain = 0;
	dev->pci_bus = pci_get_bus(dev->device);
	dev->pci_slot = pci_get_slot(dev->device);
	dev->pci_func = pci_get_function(dev->device);

	dev->maplist = DRM(calloc)(1, sizeof(*dev->maplist), DRM_MEM_MAPS);
	if (dev->maplist == NULL) {
		retcode = ENOMEM;
		goto error;
a637 1
	TAILQ_INIT(dev->maplist);
d639 22
a660 4
	dev->name = DRIVER_NAME;
	DRM(mem_init)();
	DRM(sysctl_init)(dev);
	TAILQ_INIT(&dev->files);
d663 1
a663 1
	dev->agp = DRM(agp_init)();
d665 8
a672 6
	if ( dev->agp == NULL ) {
		DRM_ERROR( "Cannot initialize the agpgart module.\n" );
		retcode = DRM_ERR(ENOMEM);
		goto error;
	}
#endif /* __MUST_HAVE_AGP */
d674 7
a680 10
	if (dev->agp) {
		int retcode;
		
		retcode = DRM(mtrr_add)(dev->agp->info.ai_aperture_base,
		    dev->agp->info.ai_aperture_size, DRM_MTRR_WC);
		if (retcode == 0)
			dev->agp->agp_mtrr=1;
	}
#endif /* __REALLY_HAVE_MTRR */
#endif /* __REALLY_HAVE_AGP */
d683 16
a698 4
	retcode = DRM(ctxbitmap_init)( dev );
	if (retcode != 0) {
		DRM_ERROR( "Cannot allocate memory for context bitmap.\n" );
		goto error;
a699 9
#endif
	
	DRM_INFO( "Initialized %s %d.%d.%d %s on minor %d\n",
	  	DRIVER_NAME,
	  	DRIVER_MAJOR,
	  	DRIVER_MINOR,
	  	DRIVER_PATCHLEVEL,
	  	DRIVER_DATE,
	  	unit );
a703 14

error:
	DRM(sysctl_cleanup)(dev);
	DRM_LOCK();
	DRM(takedown)(dev);
	DRM_UNLOCK();
#ifdef __FreeBSD__
	destroy_dev(dev->devnode);
#if __FreeBSD_version >= 500000
	mtx_destroy(&dev->dev_lock);
#endif
#endif
	DRM(free)(dev->maplist, sizeof(*dev->maplist), DRM_MEM_MAPS);
	return retcode;
d706 1
a706 3
/* linux: drm_cleanup is called via cleanup_module at module unload time.
 * bsd:   drm_cleanup is called per device at module unload time.
 * FIXME: NetBSD
d708 1
a708 1
static void DRM(cleanup)(drm_device_t *dev)
d710 2
d715 5
a719 4
	DRM(sysctl_cleanup)( dev );
#ifdef __FreeBSD__
	destroy_dev(dev->devnode);
#endif
d721 1
a721 1
	DRM(ctxbitmap_cleanup)( dev );
d725 7
a731 7
	if ( dev->agp && dev->agp->agp_mtrr >= 0) {
		int __unused mtrr;

		mtrr = DRM(mtrr_del)(dev->agp->info.ai_aperture_base,
		    dev->agp->info.ai_aperture_size, DRM_MTRR_WC);
		DRM_DEBUG("mtrr_del=%d\n", mtrr);
	}
d734 1
a734 3
	DRM_LOCK();
	DRM(takedown)( dev );
	DRM_UNLOCK();
d737 6
a742 4
	if ( dev->agp ) {
		DRM(agp_uninit)();
		DRM(free)( dev->agp, sizeof(*dev->agp), DRM_MEM_AGPLISTS );
		dev->agp = NULL;
a743 1
#endif
d745 3
a747 5
	DRM(mem_uninit)();
#if defined(__FreeBSD__) &&  __FreeBSD_version >= 500000
	mtx_destroy(&dev->dev_lock);
#endif
	DRM(free)(dev->maplist, sizeof(*dev->maplist), DRM_MEM_MAPS);
d751 1
a751 1
int DRM(version)( DRM_IOCTL_ARGS )
d756 1
a756 1
	DRM_COPY_FROM_USER_IOCTL( version, (drm_version_t *)data, sizeof(version) );
d763 2
a764 2
		if ( DRM_COPY_TO_USER( name, value, len ) )		\
			return DRM_ERR(EFAULT);				\
d775 1
a775 1
	DRM_COPY_TO_USER_IOCTL( (drm_version_t *)data, version, sizeof(version) );
d780 1
a780 1
int DRM(open)(dev_t kdev, int flags, int fmt, DRM_STRUCTPROC *p)
d784 1
d786 7
a792 1
	dev = DRIVER_SOFTC(minor(kdev));
d796 1
d801 6
a806 7
		DRM_LOCK();
#ifdef __FreeBSD__
		device_busy(dev->device);
#endif
		if ( !dev->open_count++ )
			retcode = DRM(setup)( dev );
		DRM_UNLOCK();
d808 1
d813 1
a813 1
int DRM(close)(dev_t kdev, int flags, int fmt, DRM_STRUCTPROC *p)
d816 1
a816 1
	DRM_DEVICE;
d818 1
a818 2
	DRMFILE filp = (void *)(DRM_CURRENTPID);
	
a819 3

	DRM_LOCK();

d822 1
a822 2
		DRM_UNLOCK();
		DRM_ERROR("can't find authenticator\n");
a831 4
#ifdef __FreeBSD__
	DRM_DEBUG( "pid = %d, device = 0x%lx, open_count = %d\n",
		   DRM_CURRENTPID, (long)dev->device, dev->open_count );
#elif defined(__NetBSD__)
d833 1
a833 2
		   DRM_CURRENTPID, (long)&dev->device, dev->open_count);
#endif
d836 1
a836 1
	    && dev->lock.filp == filp) {
d838 1
a838 1
			  DRM_CURRENTPID,
d840 1
a840 1
#if __HAVE_RELEASE
d858 1
a858 1
				retcode = DRM_ERR(EINTR);
d863 1
a863 1
				dev->lock.pid       = DRM_CURRENTPID;
d869 2
a870 6
#if defined(__FreeBSD__) && __FreeBSD_version > 500000
			retcode = msleep((void *)&dev->lock.lock_queue,
			    dev->dev_lock, PZERO | PCATCH, "drmlk2", 0);
#else
			retcode = tsleep((void *)&dev->lock.lock_queue,
			    PZERO | PCATCH, "drmlk2", 0);
d872 4
d879 1
a879 1
		if (retcode == 0) {
d886 1
a886 1
	DRM(reclaim_buffers)( dev, (void *)priv->pid );
a888 3
#if defined (__FreeBSD__) && (__FreeBSD_version >= 500000)
	funsetown(&dev->buf_sigio);
#elif defined(__FreeBSD__)
d890 8
a897 7
#elif defined(__NetBSD__)
	dev->buf_pgid = 0;
#endif /* __NetBSD__ */

	if (--priv->refs == 0) {
		TAILQ_REMOVE(&dev->files, priv, link);
		DRM(free)( priv, sizeof(*priv), DRM_MEM_FILES );
d899 3
d908 12
a919 5
#ifdef __FreeBSD__
	device_unbusy(dev->device);
#endif
	if (--dev->open_count == 0) {
		retcode = DRM(takedown)(dev);
d921 1
a922 1
	DRM_UNLOCK();
d924 1
a924 1
	return retcode;
d929 1
a929 2
int DRM(ioctl)(dev_t kdev, u_long cmd, caddr_t data, int flags, 
    DRM_STRUCTPROC *p)
d931 1
a931 1
	DRM_DEVICE;
d934 1
a934 1
	int (*func)(DRM_IOCTL_ARGS);
d936 1
a936 3
	drm_file_t *priv;

	DRM_GET_PRIV_WITH_RETURN(priv, (DRMFILE)DRM_CURRENTPID);
d938 1
a941 1
#ifdef __FreeBSD__
d943 1
a943 5
		 DRM_CURRENTPID, cmd, nr, (long)dev->device, priv->authenticated );
#elif defined(__NetBSD__)
	DRM_DEBUG( "pid=%d, cmd=0x%02lx, nr=0x%02x, dev 0x%lx, auth=%d\n",
		 DRM_CURRENTPID, cmd, nr, (long)&dev->device, priv->authenticated );
#endif
d947 3
d951 2
a954 1
#ifdef __FreeBSD__
d956 1
d960 1
a960 3
#if (__FreeBSD_version >= 500000)
		*(int *) data = fgetown(&dev->buf_sigio);
#else
a961 6
#endif
		return 0;
#endif /* __FreeBSD__ */
#ifdef __NetBSD__
	case TIOCSPGRP:
		dev->buf_pgid = *(int *)data;
a962 5

	case TIOCGPGRP:
		*(int *)data = dev->buf_pgid;
		return 0;
#endif /* __NetBSD__ */
d965 15
a979 9
	if (nr >= DRIVER_IOCTL_COUNT || IOCGROUP(cmd) != DRM_IOCTL_BASE)
		return EINVAL;

	ioctl = &DRM(ioctls)[nr];
	func = ioctl->func;

	if (func == NULL) {
		DRM_DEBUG( "no function\n" );
		return EINVAL;
a980 3
	if ((ioctl->root_only && DRM_SUSER(p)) || (ioctl->auth_needed &&
	    !priv->authenticated))
		return EACCES;
d982 2
a983 3
	retcode = func(kdev, cmd, data, flags, p, (void *)DRM_CURRENTPID);

	return DRM_ERR(retcode);
d986 1
a986 1
int DRM(lock)( DRM_IOCTL_ARGS )
d988 1
a988 1
	DRM_DEVICE;
d991 8
d1000 1
a1000 1
	DRM_COPY_FROM_USER_IOCTL( lock, (drm_lock_t *)data, sizeof(lock) );
d1004 2
a1005 2
			   DRM_CURRENTPID, lock.context );
                return DRM_ERR(EINVAL);
d1009 1
a1009 1
		   lock.context, DRM_CURRENTPID,
d1014 37
a1050 1
                return DRM_ERR(EINVAL);
d1053 17
a1069 16
	DRM_LOCK();
	for (;;) {
		if (DRM(lock_take)(&dev->lock.hw_lock->lock, lock.context)) {
			dev->lock.filp = (void *)DRM_CURRENTPID;
			dev->lock.lock_time = jiffies;
			atomic_inc(&dev->counts[_DRM_STAT_LOCKS]);
			break;  /* Got lock */
		}

		/* Contention */
#if defined(__FreeBSD__) && __FreeBSD_version > 500000
		ret = msleep((void *)&dev->lock.lock_queue, &dev->dev_lock,
		    PZERO | PCATCH, "drmlk2", 0);
#else
		ret = tsleep((void *)&dev->lock.lock_queue, PZERO | PCATCH,
		    "drmlk2", 0);
d1071 1
a1071 5
		if (ret != 0)
			break;
	}
	DRM_UNLOCK();
	DRM_DEBUG( "%d %s\n", lock.context, ret ? "interrupted" : "has lock" );
d1073 1
a1073 2
	if (ret != 0)
		return ret;
d1075 2
a1076 6
	/* XXX: Add signal blocking here */

#if __HAVE_DMA_QUIESCENT
	if (lock.flags & _DRM_LOCK_QUIESCENT) {
		DRIVER_DMA_QUIESCENT();
	}
d1079 1
a1079 1
	return 0;
d1083 1
a1083 1
int DRM(unlock)( DRM_IOCTL_ARGS )
d1085 1
a1085 1
	DRM_DEVICE;
d1088 1
a1088 1
	DRM_COPY_FROM_USER_IOCTL( lock, (drm_lock_t *)data, sizeof(lock) ) ;
d1092 2
a1093 2
			   DRM_CURRENTPID, lock.context );
		return DRM_ERR(EINVAL);
d1098 19
a1116 1
	DRM_LOCK();
d1123 7
a1129 3
	if ( DRM(lock_free)( dev, &dev->lock.hw_lock->lock,
			     DRM_KERNEL_CONTEXT ) ) {
		DRM_ERROR( "\n" );
d1131 1
a1131 1
	DRM_UNLOCK();
d1137 4
d1142 3
a1144 20
#include <sys/sysproto.h>

MODULE_DEPEND(DRIVER_NAME, linux, 1, 1, 1);

#define LINUX_IOCTL_DRM_MIN		0x6400
#define LINUX_IOCTL_DRM_MAX		0x64ff

static linux_ioctl_function_t DRM(linux_ioctl);
static struct linux_ioctl_handler DRM(handler) = {DRM(linux_ioctl), 
    LINUX_IOCTL_DRM_MIN, LINUX_IOCTL_DRM_MAX};

SYSINIT(DRM(register), SI_SUB_KLD, SI_ORDER_MIDDLE, 
    linux_ioctl_register_handler, &DRM(handler));
SYSUNINIT(DRM(unregister), SI_SUB_KLD, SI_ORDER_MIDDLE, 
    linux_ioctl_unregister_handler, &DRM(handler));

/* The bits for in/out are switched on Linux */
#define LINUX_IOC_IN	IOC_OUT
#define LINUX_IOC_OUT	IOC_IN

d1146 1
a1146 1
DRM(linux_ioctl)(DRM_STRUCTPROC *p, struct linux_ioctl_args* args)
d1148 11
a1158 12
	int error;
	int cmd = args->cmd;

	args->cmd &= ~(LINUX_IOC_IN | LINUX_IOC_OUT);
	if (cmd & LINUX_IOC_IN)
		args->cmd |= IOC_IN;
	if (cmd & LINUX_IOC_OUT)
		args->cmd |= IOC_OUT;
	
	error = ioctl(p, (struct ioctl_args *)args);

	return error;
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d119 7
d128 1
a135 1
#ifdef __FreeBSD__
a137 4
#elif defined(__NetBSD__)
static int DRM(init)(drm_device_t *);
static void DRM(cleanup)(drm_device_t *);
#endif
a138 1
#ifdef __FreeBSD__
a148 1
#endif /* __FreeBSD__ */
d150 4
a153 5
#ifdef __NetBSD__
#define CDEV_MAJOR	90
#define DRIVER_SOFTC(unit) \
	((drm_device_t *) device_lookup(&DRM(_cd), unit))
#endif /* __NetBSD__ */
d201 1
d204 1
d217 1
a217 1
#if __HAVE_SG
a221 4
#if __HAVE_VBL_IRQ
	[DRM_IOCTL_NR(DRM_IOCTL_WAIT_VBLANK)]   = { DRM(wait_vblank), 0, 0 },
#endif

a226 1
const char *DRM(find_description)(int vendor, int device);
a227 1
#ifdef __FreeBSD__
d230 1
a230 1
	const char *s = NULL;
d235 13
a248 1
	s = DRM(find_description)(vendor, device);
d267 1
a305 72
#elif defined(__NetBSD__)
int DRM(probe)(struct device *parent, struct cfdata *match, void *aux);
void DRM(attach)(struct device *parent, struct device *self, void *aux);
int DRM(detach)(struct device *self, int flags);
int DRM(activate)(struct device *self, enum devact act);

struct cfattach DRM(_ca) = {
	sizeof(drm_device_t), DRM(probe), 
	DRM(attach), DRM(detach), DRM(activate) };
	
int DRM(probe)(struct device *parent, struct cfdata *match, void *aux)
{
	struct pci_attach_args *pa = aux;
	const char *desc;

	desc = DRM(find_description)(PCI_VENDOR(pa->pa_id), PCI_PRODUCT(pa->pa_id));
	if (desc != NULL)
		return 10;
	return 0;
}

void DRM(attach)(struct device *parent, struct device *self, void *aux)
{
	struct pci_attach_args *pa = aux;
	drm_device_t *dev = (drm_device_t *)self;
	
	memcpy(&dev->pa, aux, sizeof(dev->pa));
	
	DRM_INFO("%s", DRM(find_description)(PCI_VENDOR(pa->pa_id), PCI_PRODUCT(pa->pa_id)));
	DRM(init)(dev);
}

int DRM(detach)(struct device *self, int flags)
{
	DRM(cleanup)((drm_device_t *)self);
	return 0;
}

int DRM(activate)(struct device *self, enum devact act)
{
	switch (act) {
	case DVACT_ACTIVATE:
		return (EOPNOTSUPP);
		break;

	case DVACT_DEACTIVATE:
		/* FIXME */
		break;
	}
	return (0);
}

#endif

const char *DRM(find_description)(int vendor, int device) {
	const char *s = NULL;
	int i=0, done=0;
	
	while ( !done && (DRM(devicelist)[i].vendor != 0 ) ) {
		if ( (DRM(devicelist)[i].vendor == vendor) &&
		     (DRM(devicelist)[i].device == device) ) {
			done=1;
			if ( DRM(devicelist)[i].supported )
				s = DRM(devicelist)[i].name;
			else
				DRM_INFO("%s not supported\n", DRM(devicelist)[i].name);
		}
		i++;
	}
	return s;
}

d370 1
a370 1
	if(dev->maplist == NULL) return DRM_ERR(ENOMEM);
a401 1
#ifdef __FreeBSD__
a402 3
#elif defined(__NetBSD__)
	dev->buf_pgid = 0;
#endif
d435 1
a435 1
	DRM_LOCK;
d500 3
a502 22
#ifdef __FreeBSD__
					int act;
					struct mem_range_desc mrdesc;
					mrdesc.mr_base = map->offset;
					mrdesc.mr_len = map->size;
					mrdesc.mr_flags = MDF_WRITECOMBINE;
					act = MEMRANGE_SET_UPDATE;
					bcopy(DRIVER_NAME, &mrdesc.mr_owner, strlen(DRIVER_NAME));
					retcode = mem_range_attr_set(&mrdesc, &act);
					map->mtrr=1;
#elif defined __NetBSD__
					struct mtrr mtrrmap;
					int one = 1;
					mtrrmap.base = map->offset;
					mtrrmap.len = map->size;
					mtrrmap.type = MTRR_TYPE_WC;
					mtrrmap.flags = 0;
					/*mtrrmap.owner = p->p_pid;*/
					/* XXX: Use curproc here? */
					retcode = mtrr_set( &mtrrmap, &one, 
						DRM_CURPROC, MTRR_GETSET_KERNEL);
#endif
d509 3
a511 2
				DRM(free)(map->handle,
					       map->size,
d565 1
a565 1
		DRM_WAKEUP_INT((void *)&dev->lock.lock_queue);
d567 1
a567 1
	DRM_UNLOCK;
d572 37
a608 3
/* linux: drm_init is called via init_module at module load time, or via
 *        linux/init/main.c (this is not currently supported).
 * bsd:   drm_init is called via the attach function per device.
a609 1
#ifdef __FreeBSD__
a610 3
#elif defined(__NetBSD__)
static int DRM(init)( drm_device_t *dev )
#endif
d612 1
a612 2
	int unit;
#ifdef __FreeBSD__
d614 1
a614 1
#endif
d619 20
d641 20
a660 20
#ifdef __FreeBSD__
	unit = device_get_unit(nbdev);
	dev = device_get_softc(nbdev);
	memset( (void *)dev, 0, sizeof(*dev) );
	dev->device = nbdev;
	dev->devnode = make_dev( &DRM(cdevsw),
			unit,
			DRM_DEV_UID,
			DRM_DEV_GID,
			DRM_DEV_MODE,
			"dri/card%d", unit );
#elif defined(__NetBSD__)
	unit = minor(dev->device.dv_unit);
#endif
	DRM_SPININIT(dev->count_lock, "drm device");
	lockinit(&dev->dev_lock, PZERO, "drmlk", 0, 0);
	dev->name = DRIVER_NAME;
	DRM(mem_init)();
	DRM(sysctl_init)(dev);
	TAILQ_INIT(&dev->files);
d663 1
a663 1
	dev->agp = DRM(agp_init)();
d665 7
a671 5
	if ( dev->agp == NULL ) {
		DRM_ERROR( "Cannot initialize the agpgart module.\n" );
		DRM(sysctl_cleanup)( dev );
#ifdef __FreeBSD__
		destroy_dev(dev->devnode);
a672 4
		DRM(takedown)( dev );
		return DRM_ERR(ENOMEM);
	}
#endif /* __MUST_HAVE_AGP */
d674 7
a680 24
	if (dev->agp) {
#ifdef __FreeBSD__
		int retcode = 0, act;
		struct mem_range_desc mrdesc;
		mrdesc.mr_base = dev->agp->info.ai_aperture_base;
		mrdesc.mr_len = dev->agp->info.ai_aperture_size;
		mrdesc.mr_flags = MDF_WRITECOMBINE;
		act = MEMRANGE_SET_UPDATE;
		bcopy(DRIVER_NAME, &mrdesc.mr_owner, strlen(DRIVER_NAME));
		retcode = mem_range_attr_set(&mrdesc, &act);
		dev->agp->agp_mtrr=1;
#elif defined __NetBSD__
		struct mtrr mtrrmap;
		int one = 1;
		mtrrmap.base = dev->agp->info.ai_aperture_base;
		/* Might need a multiplier here XXX */
		mtrrmap.len = dev->agp->info.ai_aperture_size;
		mtrrmap.type = MTRR_TYPE_WC;
		mtrrmap.flags = MTRR_VALID;
		dev->agp->agp_mtrr = mtrr_set( &mtrrmap, &one, NULL, MTRR_GETSET_KERNEL);
#endif /* __NetBSD__ */
	}
#endif /* __REALLY_HAVE_MTRR */
#endif /* __REALLY_HAVE_AGP */
d683 8
a690 6
	retcode = DRM(ctxbitmap_init)( dev );
	if( retcode ) {
		DRM_ERROR( "Cannot allocate memory for context bitmap.\n" );
		DRM(sysctl_cleanup)( dev );
#ifdef __FreeBSD__
		destroy_dev(dev->devnode);
d692 7
a698 2
		DRM(takedown)( dev );
		return retcode;
a699 8
#endif
	DRM_INFO( "Initialized %s %d.%d.%d %s on minor %d\n",
	  	DRIVER_NAME,
	  	DRIVER_MAJOR,
	  	DRIVER_MINOR,
	  	DRIVER_PATCHLEVEL,
	  	DRIVER_DATE,
	  	unit );
d706 1
a706 3
/* linux: drm_cleanup is called via cleanup_module at module unload time.
 * bsd:   drm_cleanup is called per device at module unload time.
 * FIXME: NetBSD
a707 1
#ifdef __FreeBSD__
a708 3
#elif defined(__NetBSD__)
static void DRM(cleanup)(drm_device_t *dev)
#endif
a709 1
#ifdef __FreeBSD__
d711 1
a711 7
#endif
#if __REALLY_HAVE_MTRR
#ifdef __NetBSD__
	struct mtrr mtrrmap;
	int one = 1;
#endif /* __NetBSD__ */
#endif /* __REALLY_HAVE_MTRR */
d715 5
a719 7
#ifdef __FreeBSD__
	dev = device_get_softc(nbdev);
#endif
	DRM(sysctl_cleanup)( dev );
#ifdef __FreeBSD__
	destroy_dev(dev->devnode);
#endif
d721 1
a721 1
	DRM(ctxbitmap_cleanup)( dev );
d725 7
a731 9
	if ( dev->agp && dev->agp->agp_mtrr >= 0) {
#if defined(__NetBSD__)
		mtrrmap.base = dev->agp->info.ai_aperture_base;
		mtrrmap.len = dev->agp->info.ai_aperture_size;
		mtrrmap.type = 0;
		mtrrmap.flags = 0;
		retval = mtrr_set( &mtrrmap, &one, NULL, MTRR_GETSET_KERNEL);
#endif
	}
d734 1
a734 1
	DRM(takedown)( dev );
d737 6
a742 4
	if ( dev->agp ) {
		DRM(agp_uninit)();
		DRM(free)( dev->agp, sizeof(*dev->agp), DRM_MEM_AGPLISTS );
		dev->agp = NULL;
a743 1
#endif
d745 3
a747 2
	DRM(mem_uninit)();
	DRM_SPINUNINIT(dev->count_lock);
d751 1
a751 1
int DRM(version)( DRM_IOCTL_ARGS )
d756 1
a756 1
	DRM_COPY_FROM_USER_IOCTL( version, (drm_version_t *)data, sizeof(version) );
d763 2
a764 2
		if ( DRM_COPY_TO_USER( name, value, len ) )		\
			return DRM_ERR(EFAULT);				\
d775 1
a775 1
	DRM_COPY_TO_USER_IOCTL( (drm_version_t *)data, version, sizeof(version) );
d780 1
a780 1
int DRM(open)(dev_t kdev, int flags, int fmt, DRM_STRUCTPROC *p)
d784 1
d786 7
a792 1
	dev = DRIVER_SOFTC(minor(kdev));
d796 1
d801 6
a806 7
		DRM_SPINLOCK( &dev->count_lock );
#ifdef __FreeBSD__
		device_busy(dev->device);
#endif
		if ( !dev->open_count++ )
			retcode = DRM(setup)( dev );
		DRM_SPINUNLOCK( &dev->count_lock );
d808 1
d813 1
a813 1
int DRM(close)(dev_t kdev, int flags, int fmt, DRM_STRUCTPROC *p)
d816 1
a816 1
	DRM_DEVICE;
a831 4
#ifdef __FreeBSD__
	DRM_DEBUG( "pid = %d, device = 0x%lx, open_count = %d\n",
		   DRM_CURRENTPID, (long)dev->device, dev->open_count );
#elif defined(__NetBSD__)
d833 1
a833 2
		   DRM_CURRENTPID, (long)&dev->device, dev->open_count);
#endif
d836 1
a836 1
	    && dev->lock.pid == DRM_CURRENTPID) {
d838 1
a838 1
			  DRM_CURRENTPID,
d858 1
a858 1
				retcode = DRM_ERR(EINTR);
a888 3
#if defined (__FreeBSD__) && (__FreeBSD_version >= 500000)
	funsetown(&dev->buf_sigio);
#elif defined(__FreeBSD__)
a889 3
#elif defined(__NetBSD__)
	dev->buf_pgid = 0;
#endif /* __NetBSD__ */
d891 1
a891 1
	DRM_LOCK;
a896 1
			DRM(free)( priv, sizeof(*priv), DRM_MEM_FILES );
d899 1
a899 1
	DRM_UNLOCK;
d901 1
d908 1
a908 4
	DRM_SPINLOCK( &dev->count_lock );
#ifdef __FreeBSD__
	device_unbusy(dev->device);
#endif
d914 2
a915 2
			DRM_SPINUNLOCK( &dev->count_lock );
			return DRM_ERR(EBUSY);
d917 2
a918 1
		DRM_SPINUNLOCK( &dev->count_lock );
d921 2
a922 1
	DRM_SPINUNLOCK( &dev->count_lock );
d924 1
a924 1
	return retcode;
d929 1
a929 1
int DRM(ioctl)( DRM_IOCTL_ARGS )
d931 1
a931 1
	DRM_DEVICE;
d936 1
a936 1
	DRM_PRIV;
a941 1
#ifdef __FreeBSD__
d943 1
a943 5
		 DRM_CURRENTPID, cmd, nr, (long)dev->device, priv->authenticated );
#elif defined(__NetBSD__)
	DRM_DEBUG( "pid=%d, cmd=0x%02lx, nr=0x%02x, dev 0x%lx, auth=%d\n",
		 DRM_CURRENTPID, cmd, nr, (long)&dev->device, priv->authenticated );
#endif
a954 1
#ifdef __FreeBSD__
a960 3
#if (__FreeBSD_version >= 500000)
		*(int *) data = fgetown(&dev->buf_sigio);
#else
a961 1
#endif
a963 12
#endif /* __FreeBSD__ */
#ifdef __NetBSD__
	case TIOCSPGRP:
		atomic_dec(&dev->ioctl_count);
		dev->buf_pgid = *(int *)data;
		return 0;

	case TIOCGPGRP:
		atomic_dec(&dev->ioctl_count);
		*(int *)data = dev->buf_pgid;
		return 0;
#endif /* __NetBSD__ */
d974 1
a974 1
		} else if ( ( ioctl->root_only && DRM_SUSER(p) ) 
d983 1
a983 1
	return DRM_ERR(retcode);
d986 1
a986 1
int DRM(lock)( DRM_IOCTL_ARGS )
d988 1
a988 1
	DRM_DEVICE;
d1000 1
a1000 1
	DRM_COPY_FROM_USER_IOCTL( lock, (drm_lock_t *)data, sizeof(lock) );
d1004 2
a1005 2
			   DRM_CURRENTPID, lock.context );
                return DRM_ERR(EINVAL);
d1009 1
a1009 1
		   lock.context, DRM_CURRENTPID,
d1014 1
a1014 1
                return DRM_ERR(EINVAL);
d1017 1
a1017 1
                return DRM_ERR(EINVAL);
d1033 1
a1033 1
                                dev->lock.pid       = DRM_CURRENTPID;
d1040 1
a1040 1
			ret = tsleep((void *)&dev->lock.lock_queue,
d1079 1
a1079 1
	return DRM_ERR(ret);
d1083 1
a1083 1
int DRM(unlock)( DRM_IOCTL_ARGS )
d1085 1
a1085 1
	DRM_DEVICE;
d1088 1
a1088 1
	DRM_COPY_FROM_USER_IOCTL( lock, (drm_lock_t *)data, sizeof(lock) ) ;
d1092 2
a1093 2
			   DRM_CURRENTPID, lock.context );
		return DRM_ERR(EINVAL);
d1123 1
a1123 1
	/* FIXME: Do we ever really need to check this?
a1136 3
#define LINUX_IOCTL_DRM_MIN		0x6400
#define LINUX_IOCTL_DRM_MAX		0x64ff

a1141 4
#define LINUX_IOC_VOID	IOC_VOID
#define LINUX_IOC_IN	IOC_OUT		/* Linux has the values the other way around */
#define LINUX_IOC_OUT	IOC_IN

d1146 1
a1146 1
DRM(linux_ioctl)(DRM_STRUCTPROC *p, struct linux_ioctl_args* args)
a1147 44
	u_long		cmd = args->cmd;
#define STK_PARAMS	128
	union {
	    char stkbuf[STK_PARAMS];
	    long align;
	} ubuf;
	caddr_t		data=NULL, memp=NULL;
	u_int		size = IOCPARM_LEN(cmd);
	int		error;
#if (__FreeBSD_version >= 500000)
	struct file	*fp;
#else
	struct file	*fp = p->p_fd->fd_ofiles[args->fd];
#endif
	if ( size > STK_PARAMS ) {
		if ( size > IOCPARM_MAX )
			return EINVAL;
		memp = malloc( (u_long)size, DRM(M_DRM), M_WAITOK );
		data = memp;
	} else {
		data = ubuf.stkbuf;
	}

	if ( cmd & LINUX_IOC_IN ) {
		if ( size ) {
			error = copyin( (caddr_t)args->arg, data, (u_int)size );
			if (error) {
				if ( memp )
					free( data, DRM(M_DRM) );
				return error;
			}
		} else {
			data = (caddr_t)args->arg;
		}
	} else if ( (cmd & LINUX_IOC_OUT) && size ) {
		/*
		 * Zero the buffer so the user always
		 * gets back something deterministic.
		 */
		bzero( data, size );
	} else if ( cmd & LINUX_IOC_VOID ) {
		*(caddr_t *)data = (caddr_t)args->arg;
	}

d1149 1
a1149 7
	if ( (error = fget( p, args->fd, &fp )) != 0 ) {
		if ( memp )
			free( memp, DRM(M_DRM) );
		return (error);
	}
	error = fo_ioctl( fp, cmd, data, p->td_ucred, p );
	fdrop( fp, p );
d1151 1
a1151 1
	error = fo_ioctl( fp, cmd, data, p );
d1153 6
a1158 5
	if ( error == 0 && (cmd & LINUX_IOC_OUT) && size )
		error = copyout( data, (caddr_t)args->arg, (u_int)size );
	if ( memp )
		free( memp, DRM(M_DRM) );
	return error;
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@a29 1
 *
d57 2
a58 2
#ifndef __HAVE_IRQ
#define __HAVE_IRQ			0
d63 3
d69 6
d87 6
a117 3
#ifndef DRIVER_OPEN_HELPER
#define DRIVER_OPEN_HELPER( priv, dev )
#endif
d121 5
a125 4
#if 1 && DRM_DEBUG_CODE
int DRM(flags) = DRM_FLAG_DEBUG;
#else
int DRM(flags) = 0;
d128 1
d130 5
a134 1
static void DRM(cleanup)(drm_device_t *dev);
d137 1
d144 3
d150 1
d152 1
a152 1
	((drm_device_t *) device_lookup(&DRM(cd), unit))
d159 1
a159 3
#if __HAVE_IRQ
	[DRM_IOCTL_NR(DRM_IOCTL_IRQ_BUSID)]     = { DRM(irq_by_busid), 0, 1 },
#endif
a162 1
	[DRM_IOCTL_NR(DRM_IOCTL_SET_VERSION)]   = { DRM(setversion),  0, 1 },
d165 2
a166 2
	[DRM_IOCTL_NR(DRM_IOCTL_BLOCK)]         = { DRM(noop),        1, 1 },
	[DRM_IOCTL_NR(DRM_IOCTL_UNBLOCK)]       = { DRM(noop),        1, 1 },
d190 1
a190 1
	[DRM_IOCTL_NR(DRM_IOCTL_FINISH)]        = { DRM(noop),        1, 0 },
d198 3
a200 3
	/* The DRM_IOCTL_DMA ioctl should be defined by the driver. */
#endif
#if __HAVE_IRQ || __HAVE_DMA
a231 19
static struct cdevsw DRM(cdevsw) = {
	.d_open =	DRM( open ),
	.d_close =	DRM( close ),
	.d_read =	DRM( read ),
	.d_ioctl =	DRM( ioctl ),
	.d_poll =	DRM( poll ),
	.d_mmap =	DRM( mmap ),
	.d_name =	DRIVER_NAME,
	.d_maj =	CDEV_MAJOR,
	.d_flags =	D_TTY | D_TRACKCLOSE,
#if __FreeBSD_version < 500000
	.d_bmaj =	-1
#endif
};

static drm_pci_id_list_t DRM(pciidlist)[] = {
	DRIVER_PCI_IDS
};

a234 7
	int pciid, vendor, device;

	/* XXX: Cope with agp bridge device? */
	if (!strcmp(device_get_name(dev), "drmsub"))
		pciid = pci_get_devid(device_get_parent(dev));
	else
		pciid = pci_get_devid(dev);
d236 3
a238 2
	vendor = (pciid & 0x0000ffff);
	device = (pciid & 0xffff0000) >> 16;
d241 1
a241 1
	if (s != NULL) {
d256 1
a256 1
	DRM(cleanup)(device_get_softc(dev));
d261 3
a263 3
	DEVMETHOD(device_probe,		DRM(probe)),
	DEVMETHOD(device_attach,	DRM(attach)),
	DEVMETHOD(device_detach,	DRM(detach)),
d274 1
a274 1
static devclass_t DRM(devclass);
d276 16
a291 19
#elif defined(__NetBSD__)

static struct cdevsw DRM(cdevsw) = {
	DRM(open),
	DRM(close),
	DRM(read),
	nowrite,
	DRM(ioctl),
	nostop,
	notty,
	DRM(poll),
	DRM(mmap),
	nokqfilter,
	D_TTY
};

int DRM(refcnt) = 0;
#if __NetBSD_Version__ >= 106080000
MOD_DEV( DRIVER_NAME, DRIVER_NAME, NULL, -1, &DRM(cdevsw), CDEV_MAJOR);
d293 1
a293 1
MOD_DEV( DRIVER_NAME, LM_DT_CHAR, CDEV_MAJOR, &DRM(cdevsw) );
d295 1
d297 9
a305 39
int DRM(lkmentry)(struct lkm_table *lkmtp, int cmd, int ver);
static int DRM(lkmhandle)(struct lkm_table *lkmtp, int cmd);

int DRM(modprobe)();
int DRM(probe)(struct pci_attach_args *pa);
void DRM(attach)(struct pci_attach_args *pa, dev_t kdev);

int DRM(lkmentry)(struct lkm_table *lkmtp, int cmd, int ver) {
	DISPATCH(lkmtp, cmd, ver, DRM(lkmhandle), DRM(lkmhandle), DRM(lkmhandle));
}

static int DRM(lkmhandle)(struct lkm_table *lkmtp, int cmd)
{
	int j, error = 0;
#if defined(__NetBSD__) && (__NetBSD_Version__ > 106080000)
	struct lkm_dev *args = lkmtp->private.lkm_dev;
#endif

	switch(cmd) {
	case LKM_E_LOAD:
		if (lkmexists(lkmtp))
			return EEXIST;

		if(DRM(modprobe)())
			return 0;

		return 1;

	case LKM_E_UNLOAD:
		if (DRM(refcnt) > 0)
			return (EBUSY);
		break;
	case LKM_E_STAT:
		break;

	default:
		error = EIO;
		break;
	}
d307 1
a307 13
	return error;
}

int DRM(modprobe)() {
	struct pci_attach_args pa;
	int error = 0;
	if((error = pci_find_device(&pa, DRM(probe))) != 0)
		DRM(attach)(&pa, 0);

	return error;
}

int DRM(probe)(struct pci_attach_args *pa)
d309 1
d312 3
a314 6
	desc = DRM(find_description)(PCI_VENDOR(pa->pa_id),
	    PCI_PRODUCT(pa->pa_id));
	if (desc != NULL) {
		return 1;
	}

d318 1
a318 1
void DRM(attach)(struct pci_attach_args *pa, dev_t kdev)
d320 5
a324 11
	int i;
	drm_device_t *dev;

	config_makeroom(kdev, &DRM(cd));
	DRM(cd).cd_devs[(kdev)] = DRM(alloc)(sizeof(drm_device_t),
	    DRM_MEM_DRIVER);
	dev = DRIVER_SOFTC(kdev);

	memset(dev, 0, sizeof(drm_device_t));
	memcpy(&dev->pa, pa, sizeof(dev->pa));

d348 2
a349 1
#endif /* __NetBSD__ */
d352 2
a353 1
	int i = 0;
d355 8
a362 4
	for (i = 0; DRM(pciidlist)[i].vendor != 0; i++) {
		if ((DRM(pciidlist)[i].vendor == vendor) &&
		    (DRM(pciidlist)[i].device == device)) {
			return DRM(pciidlist)[i].name;
d364 1
d366 1
a366 1
	return NULL;
a368 1
/* Initialize the DRM on first open. */
a372 2
	DRM_SPINLOCK_ASSERT(&dev->dev_lock);

d374 2
d377 1
d381 1
a381 1
	if ( i != 0 )
d431 8
d441 5
a445 1
	dev->irq_enabled = 0;
d447 2
d450 11
a460 1
	dev->if_version = 0;
d462 3
d470 3
d476 6
d486 1
a486 1
/* Free resources associated with the DRM on the last close. */
d490 1
a490 1
	drm_local_map_t *map;
d492 1
a494 2
	DRM_SPINLOCK_ASSERT(&dev->dev_lock);

d498 2
a499 3
#if __HAVE_IRQ
	if (dev->irq_enabled)
		DRM(irq_uninstall)( dev );
d502 9
d533 1
a533 1
                                   intact until DRM(cleanup) is called. */
d548 8
a555 4
#if __REALLY_HAVE_SG
	if (dev->sg != NULL) {
		DRM(sg_cleanup)(dev->sg);
		dev->sg = NULL;
a556 1
#endif
d558 1
a558 1
	if (dev->maplist != NULL) {
d566 24
a589 5
					int __unused mtrr;

					mtrr = DRM(mtrr_del)(map->offset,
					    map->size, DRM_MTRR_WC);
					DRM_DEBUG("mtrr_del=%d\n", mtrr);
d592 1
a592 1
				DRM(ioremapfree)( map );
a600 1
			case _DRM_SCATTER_GATHER:
d602 1
a602 1
				 * handled in the AGP/GART/SG functions.
d605 11
d621 2
d625 19
d649 1
a649 1
		dev->lock.filp = NULL;
d652 1
d661 1
d663 3
a669 2
#elif defined(__NetBSD__)
	drm_device_t *dev = nbdev;
d681 1
a681 6

	if (!strcmp(device_get_name(nbdev), "drmsub"))
		dev->device = device_get_parent(nbdev);
	else
		dev->device = nbdev;

a687 3
#if __FreeBSD_version >= 500000
	mtx_init(&dev->dev_lock, "drm device", NULL, MTX_DEF);
#endif
d691 2
a692 15

	dev->irq = pci_get_irq(dev->device);
	/* XXX Fix domain number (alpha hoses) */
	dev->pci_domain = 0;
	dev->pci_bus = pci_get_bus(dev->device);
	dev->pci_slot = pci_get_slot(dev->device);
	dev->pci_func = pci_get_function(dev->device);

	dev->maplist = DRM(calloc)(1, sizeof(*dev->maplist), DRM_MEM_MAPS);
	if (dev->maplist == NULL) {
		retcode = ENOMEM;
		goto error;
	}
	TAILQ_INIT(dev->maplist);

d703 6
a708 2
		retcode = DRM_ERR(ENOMEM);
		goto error;
d713 20
a732 6
		int retcode;
		
		retcode = DRM(mtrr_add)(dev->agp->info.ai_aperture_base,
		    dev->agp->info.ai_aperture_size, DRM_MTRR_WC);
		if (retcode == 0)
			dev->agp->agp_mtrr=1;
d739 1
a739 1
	if (retcode != 0) {
d741 6
a746 1
		goto error;
a748 1
	
a759 14

error:
	DRM(sysctl_cleanup)(dev);
	DRM_LOCK();
	DRM(takedown)(dev);
	DRM_UNLOCK();
#ifdef __FreeBSD__
	destroy_dev(dev->devnode);
#if __FreeBSD_version >= 500000
	mtx_destroy(&dev->dev_lock);
#endif
#endif
	DRM(free)(dev->maplist, sizeof(*dev->maplist), DRM_MEM_MAPS);
	return retcode;
d766 3
d770 1
d772 9
d784 3
d797 7
a803 5
		int __unused mtrr;

		mtrr = DRM(mtrr_del)(dev->agp->info.ai_aperture_base,
		    dev->agp->info.ai_aperture_size, DRM_MTRR_WC);
		DRM_DEBUG("mtrr_del=%d\n", mtrr);
a806 1
	DRM_LOCK();
a807 1
	DRM_UNLOCK();
d818 1
a818 4
#if defined(__FreeBSD__) &&  __FreeBSD_version >= 500000
	mtx_destroy(&dev->dev_lock);
#endif
	DRM(free)(dev->maplist, sizeof(*dev->maplist), DRM_MEM_MAPS);
d864 1
a864 1
		DRM_LOCK();
d870 1
a870 1
		DRM_UNLOCK();
d881 1
a881 2
	DRMFILE filp = (void *)(DRM_CURRENTPID);
	
a882 3

	DRM_LOCK();

d885 1
a885 2
		DRM_UNLOCK();
		DRM_ERROR("can't find authenticator\n");
d904 1
a904 1
	    && dev->lock.filp == filp) {
d908 1
a908 1
#if __HAVE_RELEASE
d931 1
a931 1
				dev->lock.pid       = DRM_CURRENTPID;
d937 2
a938 6
#if defined(__FreeBSD__) && __FreeBSD_version > 500000
			retcode = msleep((void *)&dev->lock.lock_queue,
			    dev->dev_lock, PZERO | PCATCH, "drmlk2", 0);
#else
			retcode = tsleep((void *)&dev->lock.lock_queue,
			    PZERO | PCATCH, "drmlk2", 0);
d940 4
d947 1
a947 1
		if (retcode == 0) {
d954 1
a954 1
	DRM(reclaim_buffers)( dev, (void *)priv->pid );
d965 8
a972 3
	if (--priv->refs == 0) {
		TAILQ_REMOVE(&dev->files, priv, link);
		DRM(free)( priv, sizeof(*priv), DRM_MEM_FILES );
d974 2
d982 1
d986 10
a995 2
	if (--dev->open_count == 0) {
		retcode = DRM(takedown)(dev);
d997 1
a997 2

	DRM_UNLOCK();
d1004 1
a1004 2
int DRM(ioctl)(dev_t kdev, u_long cmd, caddr_t data, int flags, 
    DRM_STRUCTPROC *p)
d1009 1
a1009 1
	int (*func)(DRM_IOCTL_ARGS);
d1011 1
a1011 3
	drm_file_t *priv;

	DRM_GET_PRIV_WITH_RETURN(priv, (DRMFILE)DRM_CURRENTPID);
d1013 1
d1027 3
d1031 2
d1037 1
d1041 1
d1048 1
d1052 1
d1057 1
a1060 1
	}
d1062 15
a1076 9
	if (nr >= DRIVER_IOCTL_COUNT || IOCGROUP(cmd) != DRM_IOCTL_BASE)
		return EINVAL;

	ioctl = &DRM(ioctls)[nr];
	func = ioctl->func;

	if (func == NULL) {
		DRM_DEBUG( "no function\n" );
		return EINVAL;
a1077 5
	if ((ioctl->root_only && DRM_SUSER(p)) || (ioctl->auth_needed &&
	    !priv->authenticated))
		return EACCES;

	retcode = func(kdev, cmd, data, flags, p, (void *)DRM_CURRENTPID);
d1079 1
d1088 8
d1112 8
d1121 14
d1136 9
a1144 8
	DRM_LOCK();
	for (;;) {
		if (DRM(lock_take)(&dev->lock.hw_lock->lock, lock.context)) {
			dev->lock.filp = (void *)DRM_CURRENTPID;
			dev->lock.lock_time = jiffies;
			atomic_inc(&dev->counts[_DRM_STAT_LOCKS]);
			break;  /* Got lock */
		}
d1146 2
a1147 7
		/* Contention */
#if defined(__FreeBSD__) && __FreeBSD_version > 500000
		ret = msleep((void *)&dev->lock.lock_queue, &dev->dev_lock,
		    PZERO | PCATCH, "drmlk2", 0);
#else
		ret = tsleep((void *)&dev->lock.lock_queue, PZERO | PCATCH,
		    "drmlk2", 0);
a1148 5
		if (ret != 0)
			break;
	}
	DRM_UNLOCK();
	DRM_DEBUG( "%d %s\n", lock.context, ret ? "interrupted" : "has lock" );
d1150 19
a1168 2
	if (ret != 0)
		return ret;
d1170 1
a1170 1
	/* XXX: Add signal blocking here */
d1172 2
a1173 4
#if __HAVE_DMA_QUIESCENT
	if (lock.flags & _DRM_LOCK_QUIESCENT) {
		DRIVER_DMA_QUIESCENT();
	}
d1176 1
a1176 1
	return 0;
d1195 19
a1213 1
	DRM_LOCK();
d1220 7
a1226 3
	if ( DRM(lock_free)( dev, &dev->lock.hw_lock->lock,
			     DRM_KERNEL_CONTEXT ) ) {
		DRM_ERROR( "\n" );
d1228 1
a1228 1
	DRM_UNLOCK();
a1233 5

#include <sys/sysproto.h>

MODULE_DEPEND(DRIVER_NAME, linux, 1, 1, 1);

d1237 4
a1240 8
static linux_ioctl_function_t DRM(linux_ioctl);
static struct linux_ioctl_handler DRM(handler) = {DRM(linux_ioctl), 
    LINUX_IOCTL_DRM_MIN, LINUX_IOCTL_DRM_MAX};

SYSINIT(DRM(register), SI_SUB_KLD, SI_ORDER_MIDDLE, 
    linux_ioctl_register_handler, &DRM(handler));
SYSUNINIT(DRM(unregister), SI_SUB_KLD, SI_ORDER_MIDDLE, 
    linux_ioctl_unregister_handler, &DRM(handler));
d1242 2
a1243 2
/* The bits for in/out are switched on Linux */
#define LINUX_IOC_IN	IOC_OUT
d1246 3
d1252 43
a1294 10
	int error;
	int cmd = args->cmd;

	args->cmd &= ~(LINUX_IOC_IN | LINUX_IOC_OUT);
	if (cmd & LINUX_IOC_IN)
		args->cmd |= IOC_IN;
	if (cmd & LINUX_IOC_OUT)
		args->cmd |= IOC_OUT;
	
	error = ioctl(p, (struct ioctl_args *)args);
d1296 15
@


