head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407221130:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	cvs-200406052200:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.08.32;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.08.32;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.37.29;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.24.33;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.25.04;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* drmP.h -- Private header for Direct Rendering Manager -*- linux-c -*-
 * Created: Mon Jan  4 10:05:05 1999 by faith@@precisioninsight.com
 *
 * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
 * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Rickard E. (Rik) Faith <faith@@valinux.com>
 *    Gareth Hughes <gareth@@valinux.com>
 */

#ifndef _DRM_P_H_
#define _DRM_P_H_

#if defined(_KERNEL) || defined(__KERNEL__)

/* DRM template customization defaults
 */
#ifndef __HAVE_AGP
#define __HAVE_AGP		0
#endif
#ifndef __HAVE_MTRR
#define __HAVE_MTRR		0
#endif
#ifndef __HAVE_CTX_BITMAP
#define __HAVE_CTX_BITMAP	0
#endif
#ifndef __HAVE_DMA
#define __HAVE_DMA		0
#endif
#ifndef __HAVE_DMA_IRQ
#define __HAVE_DMA_IRQ		0
#endif
#ifndef __HAVE_DMA_WAITLIST
#define __HAVE_DMA_WAITLIST	0
#endif
#ifndef __HAVE_DMA_FREELIST
#define __HAVE_DMA_FREELIST	0
#endif
#ifndef __HAVE_DMA_HISTOGRAM
#define __HAVE_DMA_HISTOGRAM	0
#endif

#define DRM_DEBUG_CODE 0	  /* Include debugging code (if > 1, then
				     also include looping detection. */

typedef struct drm_device drm_device_t;
typedef struct drm_file drm_file_t;

/* There's undoubtably more of this file to go into these OS dependent ones. */

#include "drm_os_freebsd.h"

#include "drm.h"

/* Begin the DRM... */

#define DRM_HASH_SIZE	      16 /* Size of key hash table		  */
#define DRM_KERNEL_CONTEXT    0	 /* Change drm_resctx if changed	  */
#define DRM_RESERVED_CONTEXTS 1	 /* Change drm_resctx if changed	  */
#define DRM_LOOPING_LIMIT     5000000
#define DRM_BSZ		      1024 /* Buffer size for /dev/drm? output	  */
#define DRM_LOCK_SLICE	      1	/* Time slice for lock, in jiffies	  */

#define DRM_FLAG_DEBUG	  0x01
#define DRM_FLAG_NOCTX	  0x02

#define DRM_MEM_DMA	   0
#define DRM_MEM_SAREA	   1
#define DRM_MEM_DRIVER	   2
#define DRM_MEM_MAGIC	   3
#define DRM_MEM_IOCTLS	   4
#define DRM_MEM_MAPS	   5
#define DRM_MEM_VMAS	   6
#define DRM_MEM_BUFS	   7
#define DRM_MEM_SEGS	   8
#define DRM_MEM_PAGES	   9
#define DRM_MEM_FILES	  10
#define DRM_MEM_QUEUES	  11
#define DRM_MEM_CMDS	  12
#define DRM_MEM_MAPPINGS  13
#define DRM_MEM_BUFLISTS  14
#define DRM_MEM_AGPLISTS  15
#define DRM_MEM_TOTALAGP  16
#define DRM_MEM_BOUNDAGP  17
#define DRM_MEM_CTXBITMAP 18
#define DRM_MEM_STUB      19
#define DRM_MEM_SGLISTS   20

#define DRM_MAX_CTXBITMAP (PAGE_SIZE * 8)

				/* Backward compatibility section */
				/* _PAGE_WT changed to _PAGE_PWT in 2.2.6 */
#ifndef _PAGE_PWT
#define _PAGE_PWT _PAGE_WT
#endif

				/* Mapping helper macros */
#define DRM_IOREMAP(map)						\
	(map)->handle = DRM(ioremap)( (map)->offset, (map)->size )

#define DRM_IOREMAPFREE(map)						\
	do {								\
		if ( (map)->handle && (map)->size )			\
			DRM(ioremapfree)( (map)->handle, (map)->size );	\
	} while (0)

				/* Internal types and structures */
#define DRM_ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))
#define DRM_MIN(a,b) ((a)<(b)?(a):(b))
#define DRM_MAX(a,b) ((a)>(b)?(a):(b))

#define DRM_LEFTCOUNT(x) (((x)->rp + (x)->count - (x)->wp) % ((x)->count + 1))
#define DRM_BUFCOUNT(x) ((x)->count - DRM_LEFTCOUNT(x))
#define DRM_WAITCOUNT(dev,idx) DRM_BUFCOUNT(&dev->queuelist[idx]->waitlist)

#define DRM_GET_PRIV_SAREA(_dev, _ctx, _map) do {	\
	(_map) = (_dev)->context_sareas[_ctx];		\
} while(0)


typedef struct drm_pci_list {
	u16 vendor;
	u16 device;
} drm_pci_list_t;

typedef struct drm_ioctl_desc {
	d_ioctl_t            *func;
	int		     auth_needed;
	int		     root_only;
} drm_ioctl_desc_t;

typedef struct drm_devstate {
	pid_t		  owner;	/* X server pid holding x_lock */

} drm_devstate_t;

typedef struct drm_magic_entry {
	drm_magic_t	       magic;
	struct drm_file	       *priv;
	struct drm_magic_entry *next;
} drm_magic_entry_t;

typedef struct drm_magic_head {
	struct drm_magic_entry *head;
	struct drm_magic_entry *tail;
} drm_magic_head_t;

typedef struct drm_vma_entry {
	struct vm_area_struct *vma;
	struct drm_vma_entry  *next;
	pid_t		      pid;
} drm_vma_entry_t;

typedef struct drm_buf {
	int		  idx;	       /* Index into master buflist	     */
	int		  total;       /* Buffer size			     */
	int		  order;       /* log-base-2(total)		     */
	int		  used;	       /* Amount of buffer in use (for DMA)  */
	unsigned long	  offset;      /* Byte offset (used internally)	     */
	void		  *address;    /* Address of buffer		     */
	unsigned long	  bus_address; /* Bus address of buffer		     */
	struct drm_buf	  *next;       /* Kernel-only: used for free list    */
	__volatile__ int  waiting;     /* On kernel DMA queue		     */
	__volatile__ int  pending;     /* On hardware DMA queue		     */
	wait_queue_head_t dma_wait;    /* Processes waiting		     */
	pid_t		  pid;	       /* PID of holding process	     */
	int		  context;     /* Kernel queue for this buffer	     */
	int		  while_locked;/* Dispatch this buffer while locked  */
	enum {
		DRM_LIST_NONE	 = 0,
		DRM_LIST_FREE	 = 1,
		DRM_LIST_WAIT	 = 2,
		DRM_LIST_PEND	 = 3,
		DRM_LIST_PRIO	 = 4,
		DRM_LIST_RECLAIM = 5
	}		  list;	       /* Which list we're on		     */

#if DRM_DMA_HISTOGRAM
	cycles_t	  time_queued;	   /* Queued to kernel DMA queue     */
	cycles_t	  time_dispatched; /* Dispatched to hardware	     */
	cycles_t	  time_completed;  /* Completed by hardware	     */
	cycles_t	  time_freed;	   /* Back on freelist		     */
#endif

	int		  dev_priv_size; /* Size of buffer private stoarge   */
	void		  *dev_private;  /* Per-buffer private storage       */
} drm_buf_t;

#if DRM_DMA_HISTOGRAM
#define DRM_DMA_HISTOGRAM_SLOTS		  9
#define DRM_DMA_HISTOGRAM_INITIAL	 10
#define DRM_DMA_HISTOGRAM_NEXT(current)	 ((current)*10)
typedef struct drm_histogram {
	atomic_t	  total;

	atomic_t	  queued_to_dispatched[DRM_DMA_HISTOGRAM_SLOTS];
	atomic_t	  dispatched_to_completed[DRM_DMA_HISTOGRAM_SLOTS];
	atomic_t	  completed_to_freed[DRM_DMA_HISTOGRAM_SLOTS];

	atomic_t	  queued_to_completed[DRM_DMA_HISTOGRAM_SLOTS];
	atomic_t	  queued_to_freed[DRM_DMA_HISTOGRAM_SLOTS];

	atomic_t	  dma[DRM_DMA_HISTOGRAM_SLOTS];
	atomic_t	  schedule[DRM_DMA_HISTOGRAM_SLOTS];
	atomic_t	  ctx[DRM_DMA_HISTOGRAM_SLOTS];
	atomic_t	  lacq[DRM_DMA_HISTOGRAM_SLOTS];
	atomic_t	  lhld[DRM_DMA_HISTOGRAM_SLOTS];
} drm_histogram_t;
#endif

				/* bufs is one longer than it has to be */
typedef struct drm_waitlist {
	int		  count;	/* Number of possible buffers	   */
	drm_buf_t	  **bufs;	/* List of pointers to buffers	   */
	drm_buf_t	  **rp;		/* Read pointer			   */
	drm_buf_t	  **wp;		/* Write pointer		   */
	drm_buf_t	  **end;	/* End pointer			   */
	DRM_OS_SPINTYPE	  read_lock;
	DRM_OS_SPINTYPE	  write_lock;
} drm_waitlist_t;

typedef struct drm_freelist {
	int		  initialized; /* Freelist in use		   */
	atomic_t	  count;       /* Number of free buffers	   */
	drm_buf_t	  *next;       /* End pointer			   */

	wait_queue_head_t waiting;     /* Processes waiting on free bufs   */
	int		  low_mark;    /* Low water mark		   */
	int		  high_mark;   /* High water mark		   */
	atomic_t	  wfh;	       /* If waiting for high mark	   */
	DRM_OS_SPINTYPE   lock;
} drm_freelist_t;

typedef struct drm_buf_entry {
	int		  buf_size;
	int		  buf_count;
	drm_buf_t	  *buflist;
	int		  seg_count;
	int		  page_order;
	unsigned long	  *seglist;

	drm_freelist_t	  freelist;
} drm_buf_entry_t;

typedef struct drm_hw_lock {
	__volatile__ unsigned int lock;
	char			  padding[60]; /* Pad to cache line */
} drm_hw_lock_t;

typedef TAILQ_HEAD(drm_file_list, drm_file) drm_file_list_t;
struct drm_file {
	TAILQ_ENTRY(drm_file) link;
	int		  authenticated;
	int		  minor;
	pid_t		  pid;
	uid_t		  uid;
	int		  refs;
	drm_magic_t	  magic;
	unsigned long	  ioctl_count;
	struct drm_device *devXX;
};

typedef struct drm_queue {
	atomic_t	  use_count;	/* Outstanding uses (+1)	    */
	atomic_t	  finalization;	/* Finalization in progress	    */
	atomic_t	  block_count;	/* Count of processes waiting	    */
	atomic_t	  block_read;	/* Queue blocked for reads	    */
	wait_queue_head_t read_queue;	/* Processes waiting on block_read  */
	atomic_t	  block_write;	/* Queue blocked for writes	    */
	wait_queue_head_t write_queue;	/* Processes waiting on block_write */
#if 1
	atomic_t	  total_queued;	/* Total queued statistic	    */
	atomic_t	  total_flushed;/* Total flushes statistic	    */
	atomic_t	  total_locks;	/* Total locks statistics	    */
#endif
	drm_ctx_flags_t	  flags;	/* Context preserving and 2D-only   */
	drm_waitlist_t	  waitlist;	/* Pending buffers		    */
	wait_queue_head_t flush_queue;	/* Processes waiting until flush    */
} drm_queue_t;

typedef struct drm_lock_data {
	drm_hw_lock_t	  *hw_lock;	/* Hardware lock		   */
	pid_t		  pid;		/* PID of lock holder (0=kernel)   */
	wait_queue_head_t lock_queue;	/* Queue of blocked processes	   */
	unsigned long	  lock_time;	/* Time of last lock in jiffies	   */
} drm_lock_data_t;

typedef struct drm_device_dma {
#if 0
				/* Performance Counters */
	atomic_t	  total_prio;	/* Total DRM_DMA_PRIORITY	   */
	atomic_t	  total_bytes;	/* Total bytes DMA'd		   */
	atomic_t	  total_dmas;	/* Total DMA buffers dispatched	   */

	atomic_t	  total_missed_dma;  /* Missed drm_do_dma	    */
	atomic_t	  total_missed_lock; /* Missed lock in drm_do_dma   */
	atomic_t	  total_missed_free; /* Missed drm_free_this_buffer */
	atomic_t	  total_missed_sched;/* Missed drm_dma_schedule	    */

	atomic_t	  total_tried;	/* Tried next_buffer		    */
	atomic_t	  total_hit;	/* Sent next_buffer		    */
	atomic_t	  total_lost;	/* Lost interrupt		    */
#endif

	drm_buf_entry_t	  bufs[DRM_MAX_ORDER+1];
	int		  buf_count;
	drm_buf_t	  **buflist;	/* Vector of pointers info bufs	   */
	int		  seg_count;
	int		  page_count;
	unsigned long	  *pagelist;
	unsigned long	  byte_count;
	enum {
		_DRM_DMA_USE_AGP = 0x01,
		_DRM_DMA_USE_SG  = 0x02
	} flags;

				/* DMA support */
	drm_buf_t	  *this_buffer;	/* Buffer being sent		   */
	drm_buf_t	  *next_buffer; /* Selected buffer to send	   */
	drm_queue_t	  *next_queue;	/* Queue from which buffer selected*/
	wait_queue_head_t waiting;	/* Processes waiting on free bufs  */
} drm_device_dma_t;

#if __REALLY_HAVE_AGP
typedef struct drm_agp_mem {
	void               *handle;
	unsigned long      bound; /* address */
	int                pages;
	struct drm_agp_mem *prev;
	struct drm_agp_mem *next;
} drm_agp_mem_t;

typedef struct drm_agp_head {
	device_t	   agpdev;
	struct agp_info    info;
	const char         *chipset;
	drm_agp_mem_t      *memory;
	unsigned long      mode;
	int                enabled;
	int                acquired;
	unsigned long      base;
   	int 		   agp_mtrr;
	int		   cant_use_aperture;
	unsigned long	   page_mask;
} drm_agp_head_t;
#endif

typedef struct drm_sg_mem {
	unsigned long   handle;
	void            *virtual;
	int             pages;
	struct page     **pagelist;
} drm_sg_mem_t;

typedef struct drm_sigdata {
	int           context;
	drm_hw_lock_t *lock;
} drm_sigdata_t;

typedef TAILQ_HEAD(drm_map_list, drm_map_list_entry) drm_map_list_t;
typedef struct drm_map_list_entry {
	TAILQ_ENTRY(drm_map_list_entry) link;
	drm_map_t	*map;
} drm_map_list_entry_t;

struct drm_device {
	const char	  *name;	/* Simple driver name		   */
	char		  *unique;	/* Unique identifier: e.g., busid  */
	int		  unique_len;	/* Length of unique field	   */
	device_t	  device;	/* Device instance from newbus     */
	dev_t		  devnode;	/* Device number for mknod	   */
	char		  *devname;	/* For /proc/interrupts		   */

	int		  blocked;	/* Blocked due to VC switch?	   */
	int		  flags;	/* Flags to open(2)		   */
	int		  writable;	/* Opened with FWRITE		   */
	struct proc_dir_entry *root;	/* Root for this device's entries  */

				/* Locks */
	DRM_OS_SPINTYPE	  count_lock;	/* For inuse, open_count, buf_use  */
	struct lock       dev_lock;	/* For others			   */
				/* Usage Counters */
	int		  open_count;	/* Outstanding files open	   */
	atomic_t	  ioctl_count;	/* Outstanding IOCTLs pending	   */
	atomic_t	  vma_count;	/* Outstanding vma areas open	   */
	int		  buf_use;	/* Buffers in use -- cannot alloc  */
	atomic_t	  buf_alloc;	/* Buffer allocation in progress   */

				/* Performance counters */
	unsigned long     counters;
	drm_stat_type_t   types[15];
	atomic_t          counts[15];

				/* Authentication */
	drm_file_list_t   files;
	drm_magic_head_t  magiclist[DRM_HASH_SIZE];

				/* Memory management */
	drm_map_list_t	  *maplist;	/* Linked list of regions	   */
	int		  map_count;	/* Number of mappable regions	   */

	drm_map_t	  **context_sareas;
	int		  max_context;

	drm_vma_entry_t	  *vmalist;	/* List of vmas (for debugging)	   */
	drm_lock_data_t	  lock;		/* Information on hardware lock	   */

				/* DMA queues (contexts) */
	int		  queue_count;	/* Number of active DMA queues	   */
	int		  queue_reserved; /* Number of reserved DMA queues */
	int		  queue_slots;	/* Actual length of queuelist	   */
	drm_queue_t	  **queuelist;	/* Vector of pointers to DMA queues */
	drm_device_dma_t  *dma;		/* Optional pointer for DMA support */

				/* Context support */
	int		  irq;		/* Interrupt used by board	   */
	struct resource   *irqr;	/* Resource for interrupt used by board	   */
	void		  *irqh;	/* Handle from bus_setup_intr      */
	__volatile__ long context_flag;	/* Context swapping flag	   */
	__volatile__ long interrupt_flag; /* Interruption handler flag	   */
	__volatile__ long dma_flag;	/* DMA dispatch flag		   */
	struct callout    timer;	/* Timer for delaying ctx switch   */
	wait_queue_head_t context_wait; /* Processes waiting on ctx switch */
	int		  last_checked;	/* Last context checked for DMA	   */
	int		  last_context;	/* Last current context		   */
	unsigned long	  last_switch;	/* jiffies at last context switch  */
#if __FreeBSD_version >= 400005
	struct task       task;
#endif
	cycles_t	  ctx_start;
	cycles_t	  lck_start;
#if __HAVE_DMA_HISTOGRAM
	drm_histogram_t	  histo;
#endif

				/* Callback to X server for context switch
				   and for heavy-handed reset. */
	char		  buf[DRM_BSZ]; /* Output buffer		   */
	char		  *buf_rp;	/* Read pointer			   */
	char		  *buf_wp;	/* Write pointer		   */
	char		  *buf_end;	/* End pointer			   */
	struct sigio      *buf_sigio;	/* Processes waiting for SIGIO     */
	struct selinfo    buf_sel;	/* Workspace for select/poll       */
	int               buf_selecting;/* True if poll sleeper            */
	wait_queue_head_t buf_readers;	/* Processes waiting to read	   */
	wait_queue_head_t buf_writers;	/* Processes waiting to ctx switch */

				/* Sysctl support */
	struct drm_sysctl_info *sysctl;

#if __REALLY_HAVE_AGP
	drm_agp_head_t    *agp;
#endif
	struct pci_dev *pdev;
#ifdef __alpha__
#if LINUX_VERSION_CODE < 0x020403
	struct pci_controler *hose;
#else
	struct pci_controller *hose;
#endif
#endif
	drm_sg_mem_t      *sg;  /* Scatter gather memory */
	unsigned long     *ctx_bitmap;
	void		  *dev_private;
	drm_sigdata_t     sigdata; /* For block_all_signals */
	sigset_t          sigmask;
};

extern int	     DRM(flags);
extern void	     DRM(parse_options)( char *s );
extern int           DRM(cpu_valid)( void );

				/* Authentication (drm_auth.h) */
extern int           DRM(add_magic)(drm_device_t *dev, drm_file_t *priv, 
				    drm_magic_t magic);
extern int           DRM(remove_magic)(drm_device_t *dev, drm_magic_t magic);

				/* Driver support (drm_drv.h) */
extern int           DRM(version)( DRM_OS_IOCTL );
extern int	     DRM(write_string)(drm_device_t *dev, const char *s);

				/* Memory management support (drm_memory.h) */
extern void	     DRM(mem_init)(void);
extern void	     *DRM(alloc)(size_t size, int area);
extern void	     *DRM(realloc)(void *oldpt, size_t oldsize, size_t size,
				   int area);
extern char	     *DRM(strdup)(const char *s, int area);
extern void	     DRM(strfree)(char *s, int area);
extern void	     DRM(free)(void *pt, size_t size, int area);
extern unsigned long DRM(alloc_pages)(int order, int area);
extern void	     DRM(free_pages)(unsigned long address, int order,
				     int area);
extern void	     *DRM(ioremap)(unsigned long offset, unsigned long size);
extern void	     DRM(ioremapfree)(void *pt, unsigned long size);

#if __REALLY_HAVE_AGP
extern agp_memory    *DRM(alloc_agp)(int pages, u32 type);
extern int           DRM(free_agp)(agp_memory *handle, int pages);
extern int           DRM(bind_agp)(agp_memory *handle, unsigned int start);
extern int           DRM(unbind_agp)(agp_memory *handle);
#endif

extern int	     DRM(context_switch)(drm_device_t *dev, int old, int new);
extern int	     DRM(context_switch_complete)(drm_device_t *dev, int new);

#if __HAVE_CTX_BITMAP
extern int	     DRM(ctxbitmap_init)( drm_device_t *dev );
extern void	     DRM(ctxbitmap_cleanup)( drm_device_t *dev );
extern void          DRM(ctxbitmap_free)( drm_device_t *dev, int ctx_handle );
extern int           DRM(ctxbitmap_next)( drm_device_t *dev );
#endif

				/* Locking IOCTL support (drm_lock.h) */
extern int	     DRM(lock_take)(__volatile__ unsigned int *lock,
				    unsigned int context);
extern int	     DRM(lock_transfer)(drm_device_t *dev,
					__volatile__ unsigned int *lock,
					unsigned int context);
extern int	     DRM(lock_free)(drm_device_t *dev,
				    __volatile__ unsigned int *lock,
				    unsigned int context);
extern int	     DRM(flush_unblock)(drm_device_t *dev, int context,
					drm_lock_flags_t flags);
extern int	     DRM(flush_block_and_flush)(drm_device_t *dev, int context,
						drm_lock_flags_t flags);
extern int           DRM(notifier)(void *priv);

				/* Buffer management support (drm_bufs.h) */
extern int	     DRM(order)( unsigned long size );

#if __HAVE_DMA
				/* DMA support (drm_dma.h) */
extern int	     DRM(dma_setup)(drm_device_t *dev);
extern void	     DRM(dma_takedown)(drm_device_t *dev);
extern void	     DRM(free_buffer)(drm_device_t *dev, drm_buf_t *buf);
extern void	     DRM(reclaim_buffers)(drm_device_t *dev, pid_t pid);
#if __HAVE_OLD_DMA
/* GH: This is a dirty hack for now...
 */
extern void	     DRM(clear_next_buffer)(drm_device_t *dev);
extern int	     DRM(select_queue)(drm_device_t *dev,
				       void (*wrapper)(unsigned long));
extern int	     DRM(dma_enqueue)(drm_device_t *dev, drm_dma_t *dma);
extern int	     DRM(dma_get_buffers)(drm_device_t *dev, drm_dma_t *dma);
#endif
#if __HAVE_DMA_IRQ
extern int           DRM(irq_install)( drm_device_t *dev, int irq );
extern int           DRM(irq_uninstall)( drm_device_t *dev );
extern void          DRM(dma_service)( DRM_OS_IRQ_ARGS );
#if __HAVE_DMA_IRQ_BH
extern void          DRM(dma_immediate_bh)( DRM_OS_TASKQUEUE_ARGS );
#endif
#endif
#if DRM_DMA_HISTOGRAM
extern int	     DRM(histogram_slot)(unsigned long count);
extern void	     DRM(histogram_compute)(drm_device_t *dev, drm_buf_t *buf);
#endif

				/* Buffer list support (drm_lists.h) */
#if __HAVE_DMA_WAITLIST
extern int	     DRM(waitlist_create)(drm_waitlist_t *bl, int count);
extern int	     DRM(waitlist_destroy)(drm_waitlist_t *bl);
extern int	     DRM(waitlist_put)(drm_waitlist_t *bl, drm_buf_t *buf);
extern drm_buf_t     *DRM(waitlist_get)(drm_waitlist_t *bl);
#endif
#if __HAVE_DMA_FREELIST
extern int	     DRM(freelist_create)(drm_freelist_t *bl, int count);
extern int	     DRM(freelist_destroy)(drm_freelist_t *bl);
extern int	     DRM(freelist_put)(drm_device_t *dev, drm_freelist_t *bl,
				       drm_buf_t *buf);
extern drm_buf_t     *DRM(freelist_get)(drm_freelist_t *bl, int block);
#endif
#endif /* __HAVE_DMA */

#if __REALLY_HAVE_AGP
				/* AGP/GART support (drm_agpsupport.h) */
extern drm_agp_head_t *DRM(agp_init)(void);
extern void           DRM(agp_uninit)(void);
extern void           DRM(agp_do_release)(void);
extern agp_memory     *DRM(agp_allocate_memory)(size_t pages, u32 type);
extern int            DRM(agp_free_memory)(agp_memory *handle);
extern int            DRM(agp_bind_memory)(agp_memory *handle, off_t start);
extern int            DRM(agp_unbind_memory)(agp_memory *handle);
#endif

				/* Proc support (drm_proc.h) */
extern struct proc_dir_entry *DRM(proc_init)(drm_device_t *dev,
					     int minor,
					     struct proc_dir_entry *root,
					     struct proc_dir_entry **dev_root);
extern int            DRM(proc_cleanup)(int minor,
					struct proc_dir_entry *root,
					struct proc_dir_entry *dev_root);

#if __HAVE_SG
				/* Scatter Gather Support (drm_scatter.h) */
extern void           DRM(sg_cleanup)(drm_sg_mem_t *entry);
#endif

#if __REALLY_HAVE_SG
                               /* ATI PCIGART support (ati_pcigart.h) */
extern int            DRM(ati_pcigart_init)(drm_device_t *dev,
					    unsigned long *addr,
					    dma_addr_t *bus_addr);
extern int            DRM(ati_pcigart_cleanup)(drm_device_t *dev,
					       unsigned long addr,
					       dma_addr_t bus_addr);
#endif

#endif /* __KERNEL__ */
#endif
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@a29 1
 *
d51 11
a61 2
#ifndef __HAVE_IRQ
#define __HAVE_IRQ		0
a71 1
#ifdef __FreeBSD__
a72 3
#elif defined __NetBSD__
#include "drm_os_netbsd.h"
#endif
d81 3
d86 1
d94 15
a108 14
#define DRM_MEM_BUFS	   6
#define DRM_MEM_SEGS	   7
#define DRM_MEM_PAGES	   8
#define DRM_MEM_FILES	  9
#define DRM_MEM_QUEUES	  10
#define DRM_MEM_CMDS	  11
#define DRM_MEM_MAPPINGS  12
#define DRM_MEM_BUFLISTS  13
#define DRM_MEM_AGPLISTS  14
#define DRM_MEM_TOTALAGP  15
#define DRM_MEM_BOUNDAGP  16
#define DRM_MEM_CTXBITMAP 17
#define DRM_MEM_STUB	  18
#define DRM_MEM_SGLISTS	  19
d112 6
d119 2
a120 5
#define DRM_IOREMAP(map, dev)						\
	(map)->handle = DRM(ioremap)( dev, map )

#define DRM_IOREMAP_NOCACHE(map, dev)					\
	(map)->handle = DRM(ioremap_nocache)( dev, map )
d122 1
a122 1
#define DRM_IOREMAPFREE(map, dev)						\
d125 1
a125 1
			DRM(ioremapfree)( map );			\
d133 3
a135 1
#define DRM_IF_VERSION(maj, min) (maj << 16 | min)
d142 4
a145 7
typedef struct drm_pci_id_list
{
	int vendor;
	int device;
	long driver_private;
	char *name;
} drm_pci_id_list_t;
d148 1
a148 1
	int		     (*func)(DRM_IOCTL_ARGS);
d153 5
d169 6
d184 1
d186 2
a187 1
	DRMFILE		  filp;	       /* Unique identifier of holding process */
d189 1
d199 7
d210 33
d248 1
d251 2
d261 1
a261 2
	vm_offset_t	  *seglist;
	dma_addr_t	  *seglist_bus;
a281 3
#ifdef DRIVER_FILE_FIELDS
	DRIVER_FILE_FIELDS;
#endif
d284 18
d304 2
a305 2
	DRMFILE		  filp;	        /* Unique identifier of holding process (NULL is kernel)*/
	int		  lock_queue;	/* Queue of blocked processes	   */
a308 7
/* This structure, in the drm_device_t, is always initialized while the device
 * is open.  dev->dma_lock protects the incrementing of dev->buf_use, which
 * when set marks that no further bufs may be allocated until device teardown
 * occurs (when the last open of the device has closed).  The high/low
 * watermarks of bufs are only touched by the X Server, and thus not
 * concurrently accessed, so no locking is needed.
 */
d310 16
d341 2
d373 1
a373 1
	dma_addr_t	*busaddr;
d376 4
a379 12
typedef struct drm_local_map {
	unsigned long	offset;	 /* Physical address (0 for SAREA)*/
	unsigned long	size;	 /* Physical size (bytes)	    */
	drm_map_type_t	type;	 /* Type of memory mapped		    */
	drm_map_flags_t flags;	 /* Flags				    */
	void		*handle; /* User-space: "Handle" to pass to mmap    */
				 /* Kernel-space: kernel-virtual address    */
	int		mtrr;	 /* MTRR slot used			    */
				 /* Private data			    */
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
} drm_local_map_t;
d384 1
a384 1
	drm_local_map_t	*map;
a386 8
TAILQ_HEAD(drm_vbl_sig_list, drm_vbl_sig);
typedef struct drm_vbl_sig {
	TAILQ_ENTRY(drm_vbl_sig) link;
	unsigned int	sequence;
	int		signo;
	int		pid;
} drm_vbl_sig_t;

a387 3
#ifdef __NetBSD__
	struct device	  device;	/* NetBSD's softc is an extension of struct device */
#endif
a390 1
#ifdef __FreeBSD__
a391 1
#endif
d393 1
a393 1
	int		  if_version;	/* Highest interface version set */
d395 1
d397 2
d401 2
a402 9
#if defined(__FreeBSD__) && __FreeBSD_version > 500000
#if __HAVE_DMA
	struct mtx	  dma_lock;	/* protects dev->dma */
#endif
#if __HAVE_IRQ
	struct mtx	  irq_lock; /* protects irq condition checks */
#endif
	struct mtx	  dev_lock;	/* protects everything else */
#endif
d405 2
d408 1
d419 3
a421 2
	/* Linked list of mappable regions. Protected by dev_lock */
	drm_map_list_t	  *maplist;
d423 1
a423 1
	drm_local_map_t	  **context_sareas;
d426 1
d430 4
a437 3
	int		  irq_enabled;	/* True if the irq handler is enabled */
#ifdef __FreeBSD__
	int		  irqrid;	/* Interrupt used by board */
a438 4
#elif defined(__NetBSD__)
	struct pci_attach_args  pa;
	pci_intr_handle_t	ih;
#endif
d440 6
a445 7

	int		  pci_domain;
	int		  pci_bus;
	int		  pci_slot;
	int		  pci_func;

	atomic_t	  context_flag;	/* Context swapping flag	   */
d447 1
d451 4
a454 3
#if __HAVE_VBL_IRQ
   	int		  vbl_queue;	/* vbl wait channel */
   	atomic_t          vbl_received;
d457 6
a462 1
#ifdef __FreeBSD__
d464 4
a467 3
#elif defined(__NetBSD__)
	pid_t		  buf_pgid;
#endif
d475 8
d484 1
a484 1
	atomic_t          *ctx_bitmap;
d486 2
d491 11
a504 1
extern void	     DRM(mem_uninit)(void);
a505 1
extern void	     *DRM(calloc)(size_t nmemb, size_t size, int area);
d508 2
d511 5
a515 4
extern void	     *DRM(ioremap)(drm_device_t *dev, drm_local_map_t *map);
extern void	     DRM(ioremapfree)(drm_local_map_t *map);
extern int	 DRM(mtrr_add)(unsigned long offset, size_t size, int flags);
extern int	 DRM(mtrr_del)(unsigned long offset, size_t size, int flags);
d543 5
d557 9
a565 1
extern void	     DRM(reclaim_buffers)(drm_device_t *dev, DRMFILE filp);
d567 2
a568 4

#if __HAVE_IRQ
				/* IRQ support (drm_irq.h) */
extern int	     DRM(irq_install)(drm_device_t *dev);
d570 23
a592 12
extern irqreturn_t   DRM(irq_handler)( DRM_IRQ_ARGS );
extern void          DRM(driver_irq_preinstall)( drm_device_t *dev );
extern void          DRM(driver_irq_postinstall)( drm_device_t *dev );
extern void          DRM(driver_irq_uninstall)( drm_device_t *dev );
#if __HAVE_IRQ_BH
extern void          DRM(irq_immediate_bh)( DRM_TASKQUEUE_ARGS );
#endif
#endif

#if __HAVE_VBL_IRQ
extern int           DRM(vblank_wait)(drm_device_t *dev, unsigned int *vbl_seq);
extern void          DRM(vbl_send_signals)( drm_device_t *dev );
d594 1
d607 9
d631 1
a631 63
/* Locking IOCTL support (drm_drv.h) */
extern int		DRM(lock)(DRM_IOCTL_ARGS);
extern int		DRM(unlock)(DRM_IOCTL_ARGS);
extern int		DRM(version)( DRM_IOCTL_ARGS );
extern int		DRM(setversion)( DRM_IOCTL_ARGS );

/* Misc. IOCTL support (drm_ioctl.h) */
extern int		DRM(irq_by_busid)(DRM_IOCTL_ARGS);
extern int		DRM(getunique)(DRM_IOCTL_ARGS);
extern int		DRM(setunique)(DRM_IOCTL_ARGS);
extern int		DRM(getmap)(DRM_IOCTL_ARGS);
extern int		DRM(getclient)(DRM_IOCTL_ARGS);
extern int		DRM(getstats)(DRM_IOCTL_ARGS);
extern int		DRM(noop)(DRM_IOCTL_ARGS);

/* Context IOCTL support (drm_context.h) */
extern int		DRM(resctx)(DRM_IOCTL_ARGS);
extern int		DRM(addctx)(DRM_IOCTL_ARGS);
extern int		DRM(modctx)(DRM_IOCTL_ARGS);
extern int		DRM(getctx)(DRM_IOCTL_ARGS);
extern int		DRM(switchctx)(DRM_IOCTL_ARGS);
extern int		DRM(newctx)(DRM_IOCTL_ARGS);
extern int		DRM(rmctx)(DRM_IOCTL_ARGS);
extern int		DRM(setsareactx)(DRM_IOCTL_ARGS);
extern int		DRM(getsareactx)(DRM_IOCTL_ARGS);

/* Drawable IOCTL support (drm_drawable.h) */
extern int		DRM(adddraw)(DRM_IOCTL_ARGS);
extern int		DRM(rmdraw)(DRM_IOCTL_ARGS);

/* Authentication IOCTL support (drm_auth.h) */
extern int		DRM(getmagic)(DRM_IOCTL_ARGS);
extern int		DRM(authmagic)(DRM_IOCTL_ARGS);

/* Buffer management support (drm_bufs.h) */
extern int		DRM(addmap)(DRM_IOCTL_ARGS);
extern int		DRM(rmmap)(DRM_IOCTL_ARGS);
#if __HAVE_DMA
extern int		DRM(addbufs)(DRM_IOCTL_ARGS);
extern int		DRM(infobufs)(DRM_IOCTL_ARGS);
extern int		DRM(markbufs)(DRM_IOCTL_ARGS);
extern int		DRM(freebufs)(DRM_IOCTL_ARGS);
extern int		DRM(mapbufs)(DRM_IOCTL_ARGS);
#endif

/* IRQ support (drm_irq.h) */
#if __HAVE_IRQ || __HAVE_DMA
extern int		DRM(control)(DRM_IOCTL_ARGS);
#endif
#if __HAVE_VBL_IRQ
extern int		DRM(wait_vblank)(DRM_IOCTL_ARGS);
#endif

/* AGP/GART support (drm_agpsupport.h) */
#if __REALLY_HAVE_AGP
extern int		DRM(agp_acquire)(DRM_IOCTL_ARGS);
extern int		DRM(agp_release)(DRM_IOCTL_ARGS);
extern int		DRM(agp_enable)(DRM_IOCTL_ARGS);
extern int		DRM(agp_info)(DRM_IOCTL_ARGS);
extern int		DRM(agp_alloc)(DRM_IOCTL_ARGS);
extern int		DRM(agp_free)(DRM_IOCTL_ARGS);
extern int		DRM(agp_unbind)(DRM_IOCTL_ARGS);
extern int		DRM(agp_bind)(DRM_IOCTL_ARGS);
a632 16

/* Scatter Gather Support (drm_scatter.h) */
#if __HAVE_SG
extern int		DRM(sg_alloc)(DRM_IOCTL_ARGS);
extern int		DRM(sg_free)(DRM_IOCTL_ARGS);
#endif

/* consistent PCI memory functions (drm_pci.h) */
extern void		*DRM(pci_alloc)(drm_device_t *dev, size_t size, 
					size_t align, dma_addr_t maxaddr,
					dma_addr_t *busaddr);
extern void		DRM(pci_free)(drm_device_t *dev, size_t size, 
				      void *vaddr, dma_addr_t busaddr);

#endif /* __KERNEL__ */
#endif /* _DRM_P_H_ */
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@a71 1
#ifdef __FreeBSD__
a72 3
#elif defined __NetBSD__
#include "drm_os_netbsd.h"
#endif
a121 3
#define DRM_IOREMAP_NOCACHE(map)					\
	(map)->handle = DRM(ioremap_nocache)((map)->offset, (map)->size)

d239 2
a240 2
	DRM_SPINTYPE	  read_lock;
	DRM_SPINTYPE	  write_lock;
d252 1
a252 1
	DRM_SPINTYPE   lock;
a373 1
	dma_addr_t	*busaddr;
a387 3
#ifdef __NetBSD__
	struct device	  device;	/* NetBSD's softc is an extension of struct device */
#endif
a390 1
#ifdef __FreeBSD__
a391 1
#endif
d398 1
d401 1
a401 1
	DRM_SPINTYPE	  count_lock;	/* For inuse, open_count, buf_use  */
a436 1
#ifdef __FreeBSD__
a437 1
	int		  irqrid;		/* Interrupt used by board	   */
a438 4
#elif defined(__NetBSD__)
	struct pci_attach_args  pa;
	pci_intr_handle_t	ih;
#endif
d440 3
a442 3
	atomic_t	  context_flag;	/* Context swapping flag	   */
	atomic_t	  interrupt_flag; /* Interruption handler flag	   */
	atomic_t	  dma_flag;	/* DMA dispatch flag		   */
a450 4
#if __HAVE_VBL_IRQ
   	wait_queue_head_t vbl_queue;	/* vbl wait channel */
   	atomic_t          vbl_received;
#endif
a462 1
#ifdef __FreeBSD__
a463 3
#elif defined(__NetBSD__)
	pid_t		  buf_pgid;
#endif
d475 8
d484 1
a484 1
	atomic_t          *ctx_bitmap;
d500 1
a500 1
extern int           DRM(version)( DRM_IOCTL_ARGS );
a504 1
extern void	     DRM(mem_uninit)(void);
d511 3
a514 1
extern void	     *DRM(ioremap_nocache)(unsigned long offset, unsigned long size);
d570 1
a570 4
extern void          DRM(dma_service)( DRM_IRQ_ARGS );
extern void          DRM(driver_irq_preinstall)( drm_device_t *dev );
extern void          DRM(driver_irq_postinstall)( drm_device_t *dev );
extern void          DRM(driver_irq_uninstall)( drm_device_t *dev );
d572 1
a572 1
extern void          DRM(dma_immediate_bh)( DRM_TASKQUEUE_ARGS );
a594 4
#if __HAVE_VBL_IRQ
extern int           DRM(vblank_wait)(drm_device_t *dev, unsigned int *vbl_seq);
extern void          DRM(vbl_send_signals)( drm_device_t *dev );
#endif
d607 9
d632 1
a632 1
#endif /* _DRM_P_H_ */
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@a29 1
 *
d51 11
a61 2
#ifndef __HAVE_IRQ
#define __HAVE_IRQ		0
d85 3
d90 1
d98 15
a112 14
#define DRM_MEM_BUFS	   6
#define DRM_MEM_SEGS	   7
#define DRM_MEM_PAGES	   8
#define DRM_MEM_FILES	  9
#define DRM_MEM_QUEUES	  10
#define DRM_MEM_CMDS	  11
#define DRM_MEM_MAPPINGS  12
#define DRM_MEM_BUFLISTS  13
#define DRM_MEM_AGPLISTS  14
#define DRM_MEM_TOTALAGP  15
#define DRM_MEM_BOUNDAGP  16
#define DRM_MEM_CTXBITMAP 17
#define DRM_MEM_STUB	  18
#define DRM_MEM_SGLISTS	  19
d116 6
d123 2
a124 2
#define DRM_IOREMAP(map, dev)						\
	(map)->handle = DRM(ioremap)( dev, map )
d126 2
a127 2
#define DRM_IOREMAP_NOCACHE(map, dev)					\
	(map)->handle = DRM(ioremap_nocache)( dev, map )
d129 1
a129 1
#define DRM_IOREMAPFREE(map, dev)						\
d132 1
a132 1
			DRM(ioremapfree)( map );			\
d140 3
a142 1
#define DRM_IF_VERSION(maj, min) (maj << 16 | min)
d149 4
a152 7
typedef struct drm_pci_id_list
{
	int vendor;
	int device;
	long driver_private;
	char *name;
} drm_pci_id_list_t;
d155 1
a155 1
	int		     (*func)(DRM_IOCTL_ARGS);
d160 5
d176 6
d191 1
d193 2
a194 1
	DRMFILE		  filp;	       /* Unique identifier of holding process */
d196 1
d206 7
d217 33
d255 1
d258 2
d268 1
a268 2
	vm_offset_t	  *seglist;
	dma_addr_t	  *seglist_bus;
a288 3
#ifdef DRIVER_FILE_FIELDS
	DRIVER_FILE_FIELDS;
#endif
d291 18
d311 2
a312 2
	DRMFILE		  filp;	        /* Unique identifier of holding process (NULL is kernel)*/
	int		  lock_queue;	/* Queue of blocked processes	   */
a315 7
/* This structure, in the drm_device_t, is always initialized while the device
 * is open.  dev->dma_lock protects the incrementing of dev->buf_use, which
 * when set marks that no further bufs may be allocated until device teardown
 * occurs (when the last open of the device has closed).  The high/low
 * watermarks of bufs are only touched by the X Server, and thus not
 * concurrently accessed, so no locking is needed.
 */
d317 16
d348 2
d380 1
d384 4
a387 12
typedef struct drm_local_map {
	unsigned long	offset;	 /* Physical address (0 for SAREA)*/
	unsigned long	size;	 /* Physical size (bytes)	    */
	drm_map_type_t	type;	 /* Type of memory mapped		    */
	drm_map_flags_t flags;	 /* Flags				    */
	void		*handle; /* User-space: "Handle" to pass to mmap    */
				 /* Kernel-space: kernel-virtual address    */
	int		mtrr;	 /* MTRR slot used			    */
				 /* Private data			    */
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
} drm_local_map_t;
d392 1
a392 1
	drm_local_map_t	*map;
a394 8
TAILQ_HEAD(drm_vbl_sig_list, drm_vbl_sig);
typedef struct drm_vbl_sig {
	TAILQ_ENTRY(drm_vbl_sig) link;
	unsigned int	sequence;
	int		signo;
	int		pid;
} drm_vbl_sig_t;

d406 1
a406 1
	int		  if_version;	/* Highest interface version set */
d408 1
d410 1
d413 2
a414 9
#if defined(__FreeBSD__) && __FreeBSD_version > 500000
#if __HAVE_DMA
	struct mtx	  dma_lock;	/* protects dev->dma */
#endif
#if __HAVE_IRQ
	struct mtx	  irq_lock; /* protects irq condition checks */
#endif
	struct mtx	  dev_lock;	/* protects everything else */
#endif
d417 2
d420 1
d431 3
a433 2
	/* Linked list of mappable regions. Protected by dev_lock */
	drm_map_list_t	  *maplist;
d435 1
a435 1
	drm_local_map_t	  **context_sareas;
d438 1
d442 4
d449 1
d451 1
a451 3
	int		  irq_enabled;	/* True if the irq handler is enabled */
#ifdef __FreeBSD__
	int		  irqrid;	/* Interrupt used by board */
a457 6

	int		  pci_domain;
	int		  pci_bus;
	int		  pci_slot;
	int		  pci_func;

d459 5
d465 1
d470 1
a470 1
   	int		  vbl_queue;	/* vbl wait channel */
d473 5
d479 6
d490 4
d504 2
d509 11
a524 1
extern void	     *DRM(calloc)(size_t nmemb, size_t size, int area);
d527 2
d530 3
a532 4
extern void	     *DRM(ioremap)(drm_device_t *dev, drm_local_map_t *map);
extern void	     DRM(ioremapfree)(drm_local_map_t *map);
extern int	 DRM(mtrr_add)(unsigned long offset, size_t size, int flags);
extern int	 DRM(mtrr_del)(unsigned long offset, size_t size, int flags);
d560 5
d574 9
a582 1
extern void	     DRM(reclaim_buffers)(drm_device_t *dev, DRMFILE filp);
d584 2
a585 4

#if __HAVE_IRQ
				/* IRQ support (drm_irq.h) */
extern int	     DRM(irq_install)(drm_device_t *dev);
d587 1
a587 1
extern irqreturn_t   DRM(irq_handler)( DRM_IRQ_ARGS );
d591 2
a592 2
#if __HAVE_IRQ_BH
extern void          DRM(irq_immediate_bh)( DRM_TASKQUEUE_ARGS );
d595 20
a614 1

a644 78

/* Locking IOCTL support (drm_drv.h) */
extern int		DRM(lock)(DRM_IOCTL_ARGS);
extern int		DRM(unlock)(DRM_IOCTL_ARGS);
extern int		DRM(version)( DRM_IOCTL_ARGS );
extern int		DRM(setversion)( DRM_IOCTL_ARGS );

/* Misc. IOCTL support (drm_ioctl.h) */
extern int		DRM(irq_by_busid)(DRM_IOCTL_ARGS);
extern int		DRM(getunique)(DRM_IOCTL_ARGS);
extern int		DRM(setunique)(DRM_IOCTL_ARGS);
extern int		DRM(getmap)(DRM_IOCTL_ARGS);
extern int		DRM(getclient)(DRM_IOCTL_ARGS);
extern int		DRM(getstats)(DRM_IOCTL_ARGS);
extern int		DRM(noop)(DRM_IOCTL_ARGS);

/* Context IOCTL support (drm_context.h) */
extern int		DRM(resctx)(DRM_IOCTL_ARGS);
extern int		DRM(addctx)(DRM_IOCTL_ARGS);
extern int		DRM(modctx)(DRM_IOCTL_ARGS);
extern int		DRM(getctx)(DRM_IOCTL_ARGS);
extern int		DRM(switchctx)(DRM_IOCTL_ARGS);
extern int		DRM(newctx)(DRM_IOCTL_ARGS);
extern int		DRM(rmctx)(DRM_IOCTL_ARGS);
extern int		DRM(setsareactx)(DRM_IOCTL_ARGS);
extern int		DRM(getsareactx)(DRM_IOCTL_ARGS);

/* Drawable IOCTL support (drm_drawable.h) */
extern int		DRM(adddraw)(DRM_IOCTL_ARGS);
extern int		DRM(rmdraw)(DRM_IOCTL_ARGS);

/* Authentication IOCTL support (drm_auth.h) */
extern int		DRM(getmagic)(DRM_IOCTL_ARGS);
extern int		DRM(authmagic)(DRM_IOCTL_ARGS);

/* Buffer management support (drm_bufs.h) */
extern int		DRM(addmap)(DRM_IOCTL_ARGS);
extern int		DRM(rmmap)(DRM_IOCTL_ARGS);
#if __HAVE_DMA
extern int		DRM(addbufs)(DRM_IOCTL_ARGS);
extern int		DRM(infobufs)(DRM_IOCTL_ARGS);
extern int		DRM(markbufs)(DRM_IOCTL_ARGS);
extern int		DRM(freebufs)(DRM_IOCTL_ARGS);
extern int		DRM(mapbufs)(DRM_IOCTL_ARGS);
#endif

/* IRQ support (drm_irq.h) */
#if __HAVE_IRQ || __HAVE_DMA
extern int		DRM(control)(DRM_IOCTL_ARGS);
#endif
#if __HAVE_VBL_IRQ
extern int		DRM(wait_vblank)(DRM_IOCTL_ARGS);
#endif

/* AGP/GART support (drm_agpsupport.h) */
#if __REALLY_HAVE_AGP
extern int		DRM(agp_acquire)(DRM_IOCTL_ARGS);
extern int		DRM(agp_release)(DRM_IOCTL_ARGS);
extern int		DRM(agp_enable)(DRM_IOCTL_ARGS);
extern int		DRM(agp_info)(DRM_IOCTL_ARGS);
extern int		DRM(agp_alloc)(DRM_IOCTL_ARGS);
extern int		DRM(agp_free)(DRM_IOCTL_ARGS);
extern int		DRM(agp_unbind)(DRM_IOCTL_ARGS);
extern int		DRM(agp_bind)(DRM_IOCTL_ARGS);
#endif

/* Scatter Gather Support (drm_scatter.h) */
#if __HAVE_SG
extern int		DRM(sg_alloc)(DRM_IOCTL_ARGS);
extern int		DRM(sg_free)(DRM_IOCTL_ARGS);
#endif

/* consistent PCI memory functions (drm_pci.h) */
extern void		*DRM(pci_alloc)(drm_device_t *dev, size_t size, 
					size_t align, dma_addr_t maxaddr,
					dma_addr_t *busaddr);
extern void		DRM(pci_free)(drm_device_t *dev, size_t size, 
				      void *vaddr, dma_addr_t busaddr);
@


