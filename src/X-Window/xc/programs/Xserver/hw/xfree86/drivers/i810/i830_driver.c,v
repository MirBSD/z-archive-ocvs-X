head	1.2;
access;
symbols
	tg-mergetmp-2:1.2
	cvs-200410241530:1.1.1.4
	cvs-200410012000:1.1.1.4
	cvs-200407221130:1.1.1.4
	cvs-200407141120:1.1.1.4
	cvs-200406231010:1.1.1.4
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.4
	XFree86_4_4_0:1.1.9.2
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.03.07.18.36.22;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.20.07.12;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.07.12;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.36.17;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.17.39;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.27.16.31.53;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.23.16;	author tg;	state Exp;
branches;
next	1.1.9.2;

1.1.9.2
date	2004.03.05.22.27.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@semi-automagic merge of these files (ie, I've skipped through the diffs,
and most of that was done by cvs or that weird script of some minutes ago)
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_driver.c,v 1.51 2004/02/25 12:53:14 eich Exp $ */
/**************************************************************************

Copyright 2001 VA Linux Systems Inc., Fremont, California.
Copyright © 2002 by David Dawes

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
on the rights to use, copy, modify, merge, publish, distribute, sub
license, and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
THE COPYRIGHT HOLDERS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Reformatted with GNU indent (2.2.8), using the following options:
 *
 *    -bad -bap -c41 -cd0 -ncdb -ci6 -cli0 -cp0 -ncs -d0 -di3 -i3 -ip3 -l78
 *    -lp -npcs -psl -sob -ss -br -ce -sc -hnl
 *
 * This provides a good match with the original i810 code and preferred
 * XFree86 formatting conventions.
 *
 * When editing this driver, please follow the existing formatting, and edit
 * with <TAB> characters expanded at 8-column intervals.
 */

/*
 * Authors: Jeff Hartmann <jhartmann@@valinux.com>
 *          Abraham van der Merwe <abraham@@2d3d.co.za>
 *          David Dawes <dawes@@xfree86.org>
 */

/*
 * Mode handling is based on the VESA driver written by:
 * Paulo César Pereira de Andrade <pcpa@@conectiva.com.br>
 */

/*
 * Changes:
 *
 *    23/08/2001 Abraham van der Merwe <abraham@@2d3d.co.za>
 *        - Fixed display timing bug (mode information for some
 *          modes were not initialized correctly)
 *        - Added workarounds for GTT corruptions (I don't adjust
 *          the pitches for 1280x and 1600x modes so we don't
 *          need extra memory)
 *        - The code will now default to 60Hz if LFP is connected
 *        - Added different refresh rate setting code to work
 *          around 0x4f02 BIOS bug
 *        - BIOS workaround for some mode sets (I use legacy BIOS
 *          calls for setting those)
 *        - Removed 0x4f04, 0x01 (save state) BIOS call which causes
 *          LFP to malfunction (do some house keeping and restore
 *          modes ourselves instead - not perfect, but at least the
 *          LFP is working now)
 *        - Several other smaller bug fixes
 *
 *    06/09/2001 Abraham van der Merwe <abraham@@2d3d.co.za>
 *        - Preliminary local memory support (works without agpgart)
 *        - DGA fixes (the code were still using i810 mode sets, etc.)
 *        - agpgart fixes
 *
 *    18/09/2001
 *        - Proper local memory support (should work correctly now
 *          with/without agpgart module)
 *        - more agpgart fixes
 *        - got rid of incorrect GTT adjustments
 *
 *    09/10/2001
 *        - Changed the DPRINTF() variadic macro to an ANSI C compatible
 *          version
 *
 *    10/10/2001
 *        - Fixed DPRINTF_stub(). I forgot the __...__ macros in there
 *          instead of the function arguments :P
 *        - Added a workaround for the 1600x1200 bug (Text mode corrupts
 *          when you exit from any 1600x1200 mode and 1280x1024@@85Hz. I
 *          suspect this is a BIOS bug (hence the 1280x1024@@85Hz case)).
 *          For now I'm switching to 800x600@@60Hz then to 80x25 text mode
 *          and then restoring the registers - very ugly indeed.
 *
 *    15/10/2001
 *        - Improved 1600x1200 mode set workaround. The previous workaround
 *          was causing mode set problems later on.
 *
 *    18/10/2001
 *        - Fixed a bug in I830BIOSLeaveVT() which caused a bug when you
 *          switched VT's
 */
/*
 *    07/2002 David Dawes
 *        - Add Intel(R) 855GM/852GM support.
 */
/*
 *    07/2002 David Dawes
 *        - Cleanup code formatting.
 *        - Improve VESA mode selection, and fix refresh rate selection.
 *        - Don't duplicate functions provided in 4.2 vbe modules.
 *        - Don't duplicate functions provided in the vgahw module.
 *        - Rewrite memory allocation.
 *        - Rewrite initialisation and save/restore state handling.
 *        - Decouple the i810 support from i830 and later.
 *        - Remove various unnecessary hacks and workarounds.
 *        - Fix an 845G problem with the ring buffer not in pre-allocated
 *          memory.
 *        - Fix screen blanking.
 *        - Clear the screen at startup so you don't see the previous session.
 *        - Fix some HW cursor glitches, and turn HW cursor off at VT switch
 *          and exit.
 *
 *    08/2002 Keith Whitwell
 *        - Fix DRI initialisation.
 */
/*
 *    08/2002 Alan Hourihane and David Dawes
 *        - Add XVideo support.
 */
/*
 *    10/2002 David Dawes
 *        - Add Intel(R) 865G support.
 */


#ifndef PRINT_MODE_INFO
#define PRINT_MODE_INFO 0
#endif

#include "xf86.h"
#include "xf86_ansic.h"
#include "xf86_OSproc.h"
#include "xf86Resources.h"
#include "xf86RAC.h"
#include "xf86cmap.h"
#include "compiler.h"
#include "mibstore.h"
#include "vgaHW.h"
#include "mipointer.h"
#include "micmap.h"

#include "fb.h"
#include "regionstr.h"
#include "xf86xv.h"
#include "Xv.h"
#include "vbe.h"
#include "vbeModes.h"

#include "i830.h"

#ifdef XF86DRI
#include "dri.h"
#endif

#define BIT(x) (1 << (x))
#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define NB_OF(x) (sizeof (x) / sizeof (*x))

/* *INDENT-OFF* */
static SymTabRec I830BIOSChipsets[] = {
   {PCI_CHIP_I830_M,		"i830"},
   {PCI_CHIP_845_G,		"845G"},
   {PCI_CHIP_I855_GM,		"852GM/855GM"},
   {PCI_CHIP_I865_G,		"865G"},
   {-1,				NULL}
};

static PciChipsets I830BIOSPciChipsets[] = {
   {PCI_CHIP_I830_M,		PCI_CHIP_I830_M,	RES_SHARED_VGA},
   {PCI_CHIP_845_G,		PCI_CHIP_845_G,		RES_SHARED_VGA},
   {PCI_CHIP_I855_GM,		PCI_CHIP_I855_GM,	RES_SHARED_VGA},
   {PCI_CHIP_I865_G,		PCI_CHIP_I865_G,	RES_SHARED_VGA},
   {-1,				-1,			RES_UNDEFINED}
};

/*
 * Note: "ColorKey" is provided for compatibility with the i810 driver.
 * However, the correct option name is "VideoKey".  "ColorKey" usually
 * refers to the tranparency key for 8+24 overlays, not for video overlays.
 */

typedef enum {
   OPTION_NOACCEL,
   OPTION_SW_CURSOR,
   OPTION_CACHE_LINES,
   OPTION_DRI,
   OPTION_PAGEFLIP,
   OPTION_XVIDEO,
   OPTION_VIDEO_KEY,
   OPTION_COLOR_KEY,
   OPTION_VBE_RESTORE,
   OPTION_DISPLAY_INFO
} I830Opts;

static OptionInfoRec I830BIOSOptions[] = {
   {OPTION_NOACCEL,	"NoAccel",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_SW_CURSOR,	"SWcursor",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_CACHE_LINES,	"CacheLines",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_DRI,		"DRI",		OPTV_BOOLEAN,	{0},	TRUE},
   {OPTION_PAGEFLIP,	"PageFlip",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_XVIDEO,	"XVideo",	OPTV_BOOLEAN,	{0},	TRUE},
   {OPTION_COLOR_KEY,	"ColorKey",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_VIDEO_KEY,	"VideoKey",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_VBE_RESTORE,	"VBERestore",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_DISPLAY_INFO,"DisplayInfo",	OPTV_BOOLEAN,	{0},	FALSE},
   {-1,			NULL,		OPTV_NONE,	{0},	FALSE}
};
/* *INDENT-ON* */

static void I830DisplayPowerManagementSet(ScrnInfoPtr pScrn,
					  int PowerManagementMode, int flags);
static void I830BIOSAdjustFrame(int scrnIndex, int x, int y, int flags);
static Bool I830BIOSCloseScreen(int scrnIndex, ScreenPtr pScreen);
static Bool I830BIOSSaveScreen(ScreenPtr pScreen, int unblack);
static Bool I830BIOSEnterVT(int scrnIndex, int flags);
static Bool I830VESASetVBEMode(ScrnInfoPtr pScrn, int mode,
			       VbeCRTCInfoBlock *block);


#ifdef I830DEBUG
void
I830DPRINTF_stub(const char *filename, int line, const char *function,
		 const char *fmt, ...)
{
   va_list ap;

   ErrorF("\n##############################################\n"
	  "*** In function %s, on line %d, in file %s ***\n",
	  function, line, filename);
   va_start(ap, fmt);
   VErrorF(fmt, ap);
   va_end(ap);
   ErrorF("##############################################\n\n");
}
#else /* #ifdef I830DEBUG */
void
I830DPRINTF_stub(const char *filename, int line, const char *function,
		 const char *fmt, ...)
{
   /* do nothing */
}
#endif /* #ifdef I830DEBUG */

/* XXX Check if this is still needed. */
const OptionInfoRec *
I830BIOSAvailableOptions(int chipid, int busid)
{
   int i;

   for (i = 0; I830BIOSPciChipsets[i].PCIid > 0; i++) {
      if (chipid == I830BIOSPciChipsets[i].PCIid)
	 return I830BIOSOptions;
   }
   return NULL;
}

static Bool
I830BIOSGetRec(ScrnInfoPtr pScrn)
{
   I830Ptr pI830;

   if (pScrn->driverPrivate)
      return TRUE;
   pI830 = pScrn->driverPrivate = xnfcalloc(sizeof(I830Rec), 1);
   pI830->vesa = xnfcalloc(sizeof(VESARec), 1);
   return TRUE;
}

static void
I830BIOSFreeRec(ScrnInfoPtr pScrn)
{
   I830Ptr pI830;
   VESAPtr pVesa;
   DisplayModePtr mode;

   if (!pScrn)
      return;
   if (!pScrn->driverPrivate)
      return;

   pI830 = I830PTR(pScrn);
   mode = pScrn->modes;

   if (mode) {
      do {
	 if (mode->Private) {
	    VbeModeInfoData *data = (VbeModeInfoData *) mode->Private;

	    if (data->block)
	       xfree(data->block);
	    xfree(data);
	    mode->Private = NULL;
	 }
	 mode = mode->next;
      } while (mode && mode != pScrn->modes);
   }

   if (pI830->vbeInfo)
      VBEFreeVBEInfo(pI830->vbeInfo);
   if (pI830->pVbe)
      vbeFree(pI830->pVbe);

   pVesa = pI830->vesa;
   if (pVesa->monitor)
      xfree(pVesa->monitor);
   if (pVesa->savedPal)
      xfree(pVesa->savedPal);
   xfree(pVesa);

   xfree(pScrn->driverPrivate);
   pScrn->driverPrivate = NULL;
}

static void
I830BIOSProbeDDC(ScrnInfoPtr pScrn, int index)
{
   vbeInfoPtr pVbe;

   /* The vbe module gets loaded in PreInit(), so no need to load it here. */

   pVbe = VBEInit(NULL, index);
   ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
}

/* Various extended video BIOS functions. */
static const int refreshes[] = {
   43, 56, 60, 70, 72, 75, 85, 100, 120
};
static const int nrefreshes = sizeof(refreshes) / sizeof(refreshes[0]);

static Bool
Check5fStatus(ScrnInfoPtr pScrn, int func, int ax)
{
   if (ax == 0x005f)
      return TRUE;
   else if (ax == 0x015f) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Extended BIOS function 0x%04x failed.\n", func);
      return FALSE;
   } else if ((ax & 0xff) != 0x5f) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Extended BIOS function 0x%04x not supported.\n", func);
      return FALSE;
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Extended BIOS function 0x%04x returns 0x%04x.\n",
		 func, ax & 0xffff);
      return FALSE;
   }
}

#if 0
static int
BitToRefresh(int bits)
{
   int i;

   for (i = 0; i < nrefreshes; i++)
      if (bits & (1 << i))
	 return refreshes[i];
   return 0;
}

static int
GetRefreshRate(ScrnInfoPtr pScrn, int mode, int refresh, int *availRefresh)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "GetRefreshRate\n");

   /* Only 8-bit mode numbers are supported. */
   if (mode & 0x100)
      return 0;

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f05;
   pVbe->pInt10->bx = (mode & 0xff) | 0x100;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f05, pVbe->pInt10->ax)) {
      if (availRefresh)
         *availRefresh = pVbe->pInt10->bx;
      return BitToRefresh(pVbe->pInt10->cx);
   } else
      return 0;
}
#endif

static int
SetRefreshRate(ScrnInfoPtr pScrn, int mode, int refresh)
{
   int i;
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "SetRefreshRate: mode 0x%x, refresh: %d\n", mode, refresh);

   /* Only 8-bit mode numbers are supported. */
   if (mode & 0x100)
      return 0;

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f05;
   pVbe->pInt10->bx = mode & 0xff;

   for (i = nrefreshes - 1; i >= 0; i--) {
      /*
       * Look for the highest value that the requested (refresh + 2) is
       * greater than or equal to.
       */
      if (refreshes[i] <= (refresh + 2))
	 break;
   }
   /* i can be 0 if the requested refresh was higher than the max. */
   if (i == 0) {
      if (refresh >= refreshes[nrefreshes - 1])
         i = nrefreshes - 1;
   }
   DPRINTF(PFX, "Setting refresh rate to %dHz for mode 0x%02x\n",
	   refreshes[i], mode & 0xff);
   pVbe->pInt10->cx = 1 << i;
   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f05, pVbe->pInt10->ax))
      return refreshes[i];
   else
      return 0;
}

static Bool
GetModeSupport(ScrnInfoPtr pScrn, int modePipeA, int modePipeB,
	       int devicesPipeA, int devicesPipeB, int *maxBandwidth,
	       int *bandwidthPipeA, int *bandwidthPipeB)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "GetModeSupport: modes 0x%x, 0x%x, devices: 0x%x, 0x%x\n",
	   modePipeA, modePipeB, devicesPipeA, devicesPipeB);

   /* Only 8-bit mode numbers are supported. */
   if ((modePipeA & 0x100) || (modePipeB & 0x100))
      return 0;

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f28;
   pVbe->pInt10->bx = (modePipeA & 0xff) | ((modePipeB & 0xff) << 8);
   if ((devicesPipeA & 0x80) || (devicesPipeB & 0x80))
      pVbe->pInt10->cx = 0x8000;
   else
      pVbe->pInt10->cx = (devicesPipeA & 0xff) | ((devicesPipeB & 0xff) << 8);

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f28, pVbe->pInt10->ax)) {
      if (maxBandwidth)
	 *maxBandwidth = pVbe->pInt10->cx;
      if (bandwidthPipeA)
	 *bandwidthPipeA = pVbe->pInt10->dx & 0xffff;
      /* XXX For XFree86 4.2.0 and earlier, ->dx is truncated to 16 bits. */
      if (bandwidthPipeB)
	 *bandwidthPipeB = (pVbe->pInt10->dx >> 16) & 0xffff;
      return TRUE;
   } else
      return FALSE;
}

static int
GetLFPCompMode(ScrnInfoPtr pScrn)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "GetLFPCompMode\n");

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f61;
   pVbe->pInt10->bx = 0x100;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f61, pVbe->pInt10->ax))
      return pVbe->pInt10->cx & 0xffff;
   else
      return -1;
}

#if 0
static Bool
SetLFPCompMode(ScrnInfoPtr pScrn, int compMode)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "SetLFPCompMode: compMode %d\n", compMode);

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f61;
   pVbe->pInt10->bx = 0;
   pVbe->pInt10->cx = compMode;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   return Check5fStatus(pScrn, 0x5f61, pVbe->pInt10->ax);
}
#endif

static int
GetDisplayDevices(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;

   DPRINTF(PFX, "GetDisplayDevices\n");

#if 0
   {
      CARD32 temp;
      ErrorF("ADPA is 0x%08x\n", INREG(ADPA));
      ErrorF("DVOA is 0x%08x\n", INREG(DVOA));
      ErrorF("DVOB is 0x%08x\n", INREG(DVOB));
      ErrorF("DVOC is 0x%08x\n", INREG(DVOC));
      ErrorF("LVDS is 0x%08x\n", INREG(LVDS));
      temp = INREG(DVOA_SRCDIM);
      ErrorF("DVOA_SRCDIM is 0x%08x (%d x %d)\n", temp,
	     (temp >> 12) & 0xfff, temp & 0xfff);
      temp = INREG(DVOB_SRCDIM);
      ErrorF("DVOB_SRCDIM is 0x%08x (%d x %d)\n", temp,
	     (temp >> 12) & 0xfff, temp & 0xfff);
      temp = INREG(DVOC_SRCDIM);
      ErrorF("DVOC_SRCDIM is 0x%08x (%d x %d)\n", temp,
	     (temp >> 12) & 0xfff, temp & 0xfff);
      ErrorF("SWF0 is 0x%08x\n", INREG(SWF0));
      ErrorF("SWF4 is 0x%08x\n", INREG(SWF4));
   }
#endif

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x100;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax))
      return pVbe->pInt10->cx & 0xffff;
   else
      return -1;
}

static Bool
SetDisplayDevices(ScrnInfoPtr pScrn, int devices)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   CARD32 temp;

   DPRINTF(PFX, "SetDisplayDevices: devices 0x%x\n", devices);

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x1;
   pVbe->pInt10->cx = devices;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax))
      return TRUE;
   else {
      ErrorF("Writing config directly to SWF0\n");
      temp = INREG(SWF0);
      OUTREG(SWF0, (temp & ~(0xffff)) | (devices & 0xffff));
      ErrorF("SetDisplayDevices failed.  devices is 0x%x instead of 0x%x\n",
	     GetDisplayDevices(pScrn), devices);
      return FALSE;
   }
}

#if 0
static Bool
GetDevicePresence(ScrnInfoPtr pScrn, Bool *required, int *attached,
		  int *encoderPresent)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "GetDevicePresence\n");

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x200;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax)) {
      if (required)
	 *required = ((pVbe->pInt10->bx & 0x1) == 0);
      if (attached)
	 *attached = (pVbe->pInt10->cx >> 8) & 0xff;
      if (encoderPresent)
	 *encoderPresent = pVbe->pInt10->cx & 0xff;
      return TRUE;
   } else
      return FALSE;
}
#endif

static Bool
GetDisplayInfo(ScrnInfoPtr pScrn, int device, Bool *attached, Bool *present,
	       short *x, short *y)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "GetDisplayInfo: device: 0x%x\n", device);

   switch (device & 0xff) {
   case 0x01:
   case 0x02:
   case 0x04:
   case 0x08:
   case 0x10:
   case 0x20:
      break;
   default:
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "GetDisplayInfo: invalid device: 0x%x\n", device & 0xff);
      return FALSE;
   }

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x300;
   pVbe->pInt10->cx = device & 0xff;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax)) {
      if (attached)
	 *attached = ((pVbe->pInt10->bx & 0x2) != 0);
      if (present)
	 *present = ((pVbe->pInt10->bx & 0x1) != 0);
      if (pVbe->pInt10->cx != (device & 0xff)) {
	 if (y) {
	    *y = pVbe->pInt10->cx & 0xffff;
	 }
	 if (x) {
	    *x = (pVbe->pInt10->cx >> 16) & 0xffff;
	 }
      }
      return TRUE;
   } else
      return FALSE;
}

/*
 * Returns a string matching the device corresponding to the first bit set
 * in "device".  savedDevice is then set to device with that bit cleared.
 * Subsequent calls with device == -1 will use savedDevice.
 */

static const char *displayDevices[] = {
   "CRT",
   "TV",
   "DFP (digital flat panel)",
   "LFP (local flat panel)",
   "TV2 (second TV)",
   "DFP2 (second digital flat panel)",
   NULL
};

static const char *
DeviceToString(int device)
{
   static int savedDevice = -1;
   static int bit = 0;
   const char *name;

   if (device == -1) {
      device = savedDevice;
      bit = 0;
   }

   if (device == -1)
      return NULL;

   while (displayDevices[bit]) {
      if (device & (1 << bit)) {
	 name = displayDevices[bit];
	 savedDevice = device & ~(1 << bit);
	 bit++;
	 return name;
      }
      bit++;
   }
   return NULL;
}

static void
PrintDisplayDeviceInfo(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int pipe, n;
   int displays;

   DPRINTF(PFX, "PrintDisplayDeviceInfo\n");

   displays = pI830->configuredDevices;
   if (displays == -1) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "No active display devices.\n");
      return;
   }

   /* Check for active devices connected to each display pipe. */
   for (n = 0; n < pI830->availablePipes; n++) {
      pipe = ((displays >> PIPE_SHIFT(n)) & PIPE_ACTIVE_MASK);
      if (pipe) {
	 const char *name;

	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Currently active displays on Pipe %c:\n", PIPE_NAME(n));
	 name = DeviceToString(pipe);
	 do {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "\t%s\n", name);
	    name = DeviceToString(-1);
	 } while (name);

	 if (pipe & PIPE_UNKNOWN_ACTIVE)
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "\tSome unknown display devices may also be present\n");

      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "No active displays on Pipe %c.\n", PIPE_NAME(n));
      }

      if (pI830->pipeDisplaySize[n].x2 != 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Lowest common panel size for pipe %c is %d x %d\n",
		    PIPE_NAME(n), pI830->pipeDisplaySize[n].x2,
		    pI830->pipeDisplaySize[n].y2);
      } else if (pI830->pipeEnabled[n] && pipe & ~PIPE_CRT_ACTIVE) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "No display size information available for pipe %c.\n",
		    PIPE_NAME(n));
      }
   }
}

static void
GetPipeSizes(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int pipe, n;
   DisplayType i;

   DPRINTF(PFX, "GetPipeSizes\n");


   for (n = 0; n < pI830->availablePipes; n++) {
      pipe = (pI830->configuredDevices >> PIPE_SHIFT(n)) & PIPE_ACTIVE_MASK;
      pI830->pipeDisplaySize[n].x1 = pI830->pipeDisplaySize[n].y1 = 0;
      pI830->pipeDisplaySize[n].x2 = pI830->pipeDisplaySize[n].y2 = 4096;
      for (i = 0; i < NumKnownDisplayTypes; i++) {
         if (pipe & (1 << i) & PIPE_SIZED_DISP_MASK) {
	    if (pI830->displaySize[i].x2 != 0) {
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		          "Size of device %s is %d x %d\n",
		          displayDevices[i],
		          pI830->displaySize[i].x2,
		          pI830->displaySize[i].y2);
	       if (pI830->displaySize[i].x2 < pI830->pipeDisplaySize[n].x2)
	          pI830->pipeDisplaySize[n].x2 = pI830->displaySize[i].x2;
	       if (pI830->displaySize[i].y2 < pI830->pipeDisplaySize[n].y2)
	          pI830->pipeDisplaySize[n].y2 = pI830->displaySize[i].y2;
	    }
         }
      }

      if (pI830->pipeDisplaySize[n].x2 == 4096)
         pI830->pipeDisplaySize[n].x2 = 0;
      if (pI830->pipeDisplaySize[n].y2 == 4096)
         pI830->pipeDisplaySize[n].y2 = 0;
   }
}

static Bool
I830DetectDisplayDevice(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int pipe, n;
   DisplayType i;
   
   /* This seems to lockup some Dell BIOS'. So it's on option to turn on */
   if (pI830->displayInfo) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		  "Broken BIOSes cause the system to hang here.\n"
		  "\t      If you encounter this problem please add \n"
		  "\t\t Option \"DisplayInfo\" \"FALSE\"\n"
		  "\t      to the Device section of your XF86Config file.\n");
      for (i = 0; i < NumKnownDisplayTypes; i++) {
         if (GetDisplayInfo(pScrn, 1 << i, &pI830->displayAttached[i],
			 &pI830->displayPresent[i],
			 &pI830->displaySize[i].x2,
			 &pI830->displaySize[i].y2)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Display Info: %s: attached: %s, present: %s, size: "
		    "(%d,%d)\n", displayDevices[i],
		    BOOLTOSTRING(pI830->displayAttached[i]),
		    BOOLTOSTRING(pI830->displayPresent[i]),
		    pI830->displaySize[i].x2, pI830->displaySize[i].y2);
         }
      }
   }

   pI830->configuredDevices = GetDisplayDevices(pScrn);
   if (pI830->configuredDevices == -1) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Failed to detect active display devices\n");
      return FALSE;
   }

   /* Check for active devices connected to each display pipe. */
   for (n = 0; n < pI830->availablePipes; n++) {
      pipe = ((pI830->configuredDevices >> PIPE_SHIFT(n)) & PIPE_ACTIVE_MASK);
      if (pipe) {
	 pI830->pipeEnabled[n] = TRUE;
      }
   }

   GetPipeSizes(pScrn);
   PrintDisplayDeviceInfo(pScrn);

#if 0
   /* A quick hack to change the set of enabled devices. */
   enabledDevices = PIPE_CRT_ACTIVE;
   if (!SetDisplayDevices(pScrn, enabledDevices)) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Failed to switch to configured display devices\n");
   }
#endif

   return TRUE;
}

static int
I830DetectMemory(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   PCITAG bridge;
   CARD16 gmch_ctrl;
   int memsize = 0;

   bridge = pciTag(0, 0, 0);		/* This is always the host bridge */
   gmch_ctrl = pciReadWord(bridge, I830_GMCH_CTRL);

   if (IS_I85X(pI830) || IS_I865G(pI830))
   {
      switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
      case I855_GMCH_GMS_STOLEN_1M:
	 memsize = MB(1) - KB(132);
	 break;
      case I855_GMCH_GMS_STOLEN_4M:
	 memsize = MB(4) - KB(132);
	 break;
      case I855_GMCH_GMS_STOLEN_8M:
	 memsize = MB(8) - KB(132);
	 break;
      case I855_GMCH_GMS_STOLEN_16M:
	 memsize = MB(16) - KB(132);
	 break;
      case I855_GMCH_GMS_STOLEN_32M:
	 memsize = MB(32) - KB(132);
	 break;
      }
   } else
   {
      switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
      case I830_GMCH_GMS_STOLEN_512:
	 memsize = KB(512) - KB(132);
	 break;
      case I830_GMCH_GMS_STOLEN_1024:
	 memsize = MB(1) - KB(132);
	 break;
      case I830_GMCH_GMS_STOLEN_8192:
	 memsize = MB(8) - KB(132);
	 break;
      case I830_GMCH_GMS_LOCAL:
	 memsize = 0;
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Local memory found, but won't be used.\n");
	 break;
      }
   }
   if (memsize > 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "detected %d kB stolen memory.\n", memsize / 1024);
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "no video memory detected.\n");
   }
   return memsize;
}

static Bool
I830MapMMIO(ScrnInfoPtr pScrn)
{
   int mmioFlags;
   I830Ptr pI830 = I830PTR(pScrn);

#if !defined(__alpha__)
   mmioFlags = VIDMEM_MMIO | VIDMEM_READSIDEEFFECT;
#else
   mmioFlags = VIDMEM_MMIO | VIDMEM_READSIDEEFFECT | VIDMEM_SPARSE;
#endif

   pI830->MMIOBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
				   pI830->PciTag,
				   pI830->MMIOAddr, I810_REG_SIZE);
   if (!pI830->MMIOBase)
      return FALSE;
   return TRUE;
}

static Bool
I830MapMem(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned i;

   for (i = 2; i < pI830->FbMapSize; i <<= 1) ;
   pI830->FbMapSize = i;

   if (!I830MapMMIO(pScrn))
      return FALSE;

   pI830->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
				 pI830->PciTag,
				 pI830->LinearAddr, pI830->FbMapSize);
   if (!pI830->FbBase)
      return FALSE;

   pI830->LpRing.virtual_start = pI830->FbBase + pI830->LpRing.mem.Start;

   return TRUE;
}

static void
I830UnmapMMIO(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pI830->MMIOBase,
		   I810_REG_SIZE);
   pI830->MMIOBase = 0;
}

static Bool
I830UnmapMem(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pI830->FbBase,
		   pI830->FbMapSize);
   pI830->FbBase = 0;
   I830UnmapMMIO(pScrn);
   return TRUE;
}

#ifndef HAVE_GET_PUT_BIOSMEMSIZE
#define HAVE_GET_PUT_BIOSMEMSIZE 1
#endif

#if HAVE_GET_PUT_BIOSMEMSIZE
/*
 * Tell the BIOS how much video memory is available.  The BIOS call used
 * here won't always be available.
 */
static Bool
PutBIOSMemSize(ScrnInfoPtr pScrn, int memSize)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "PutBIOSMemSize: %d kB\n", memSize / 1024);

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f11;
   pVbe->pInt10->bx = 0;
   pVbe->pInt10->cx = memSize / GTT_PAGE_SIZE;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   return Check5fStatus(pScrn, 0x5f11, pVbe->pInt10->ax);
}

/*
 * This reports what the previous VBEGetVBEInfo() found.  Be sure to call
 * VBEGetVBEInfo() after changing the BIOS memory size view.  If
 * a separate BIOS call is added for this, it can be put here.  Only
 * return a valid value if the funtionality for PutBIOSMemSize()
 * is available.
 */
static int
GetBIOSMemSize(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int memSize = KB(pI830->vbeInfo->TotalMemory * 64);

   DPRINTF(PFX, "GetBIOSMemSize\n");

   if (PutBIOSMemSize(pScrn, memSize))
      return memSize;
   else
      return -1;
}
#endif

/*
 * These three functions allow the video BIOS's view of the available video
 * memory to be changed.  This is currently implemented only for the 830
 * and 845G, which can do this via a BIOS scratch register that holds the
 * BIOS's view of the (pre-reserved) memory size.  If another mechanism
 * is available in the future, it can be plugged in here.  
 *
 * The mapping used for the 830/845G scratch register's low 4 bits is:
 *
 *             320k => 0
 *             832k => 1
 *            8000k => 8
 *
 * The "unusual" values are the 512k, 1M, 8M pre-reserved memory, less
 * overhead, rounded down to the BIOS-reported 64k granularity.
 */

static Bool
SaveBIOSMemSize(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "SaveBIOSMemSize\n");

   pI830->useSWF1 = FALSE;

#if HAVE_GET_PUT_BIOSMEMSIZE
   if ((pI830->saveBIOSMemSize = GetBIOSMemSize(pScrn)) != -1)
      return TRUE;
#endif

   if (IS_I830(pI830) || IS_845G(pI830)) {
      pI830->useSWF1 = TRUE;
      pI830->saveSWF1 = INREG(SWF1) & 0x0f;

      /*
       * This is for sample purposes only.  pI830->saveBIOSMemSize isn't used
       * when pI830->useSWF1 is TRUE.
       */
      switch (pI830->saveSWF1) {
      case 0:
	 pI830->saveBIOSMemSize = KB(320);
	 break;
      case 1:
	 pI830->saveBIOSMemSize = KB(832);
	 break;
      case 8:
	 pI830->saveBIOSMemSize = KB(8000);
	 break;
      default:
	 pI830->saveBIOSMemSize = 0;
	 break;
      }
      return TRUE;
   }
   return FALSE;
}

/*
 * TweakMemorySize() tweaks the BIOS image to set the correct size.
 * Original implementation by Christian Zietz in a stand-alone tool.
 */
static CARD32
TweakMemorySize(ScrnInfoPtr pScrn, CARD32 newsize, Bool preinit)
{
#define SIZE 0x10000
#define IDOFFSET (-23)
    const char *MAGICstring = "Total time for VGA POST:";
    const int len = strlen(MAGICstring);
    I830Ptr pI830 = I830PTR(pScrn);
    char *position;
    char *biosAddr;
    CARD32 oldsize;
    CARD32 oldpermission;
    CARD32 ret = 0;
    int i,j = 0;
    PCITAG tag =pciTag(0,0,0);

    if(!pI830->PciInfo 
       || !(pI830->PciInfo->chipType == PCI_CHIP_I855_GM
	    || pI830->PciInfo->chipType == PCI_CHIP_I865_G))
	return 0;

    if (!pI830->pVbe)
	return 0;

    biosAddr = xf86int10Addr(pI830->pVbe->pInt10, 
				    pI830->pVbe->pInt10->BIOSseg << 4);

    if (!pI830->BIOSMemSizeLoc) {

	if (!preinit)
	    return 0;

	/* Search for MAGIC string */
	for (i = 0; i < SIZE; i++) {
	    if (biosAddr[i] == MAGICstring[j]) {
		if (++j == len)
		    break;
	    } else {
		i -= j;
		j = 0;
	    }
	}
	if (j < len) return 0;

	pI830->BIOSMemSizeLoc =  (i - j + 1 + IDOFFSET);
    }

    position = biosAddr + pI830->BIOSMemSizeLoc;
    oldsize = *(CARD32 *)position;
    ret = oldsize - (3 << 16);

    /* verify that register really contains current size */
    if (preinit && ((oldsize) >> 16) - 3 !=  pI830->vbeInfo->TotalMemory)
	return 0;

    oldpermission = pciReadLong(tag, DRAM_RW_CONTROL);
    pciWriteLong(tag, DRAM_RW_CONTROL, 0x33330000);

    *(CARD32 *)position = newsize + (3 << 16);
    if (preinit) {
	/* reinitialize VBE for new size */
	VBEFreeVBEInfo(pI830->vbeInfo);
	vbeFree(pI830->pVbe);
	pI830->pVbe = VBEInit(NULL, pI830->pEnt->index);
	pI830->vbeInfo = VBEGetVBEInfo(pI830->pVbe);

	/* verify that change was successful */
	if (pI830->vbeInfo->TotalMemory * 64 * 1024 != pI830->newBIOSMemSize) {
	    ret = 0;
	    *(CARD32 *)position = oldsize;
	} else {
	    pI830->BIOSMemorySize = KB(pI830->vbeInfo->TotalMemory * 64);
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		       "Tweak BIOS image to %d kB VideoRAM\n",
		       (int)(pI830->BIOSMemorySize / 1024));
	}
    }

     pciWriteLong(tag, DRAM_RW_CONTROL, oldpermission);

     return ret;
}

static void
RestoreBIOSMemSize(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   CARD32 swf1;

   DPRINTF(PFX, "RestoreBIOSMemSize\n");

   if (TweakMemorySize(pScrn, pI830->saveBIOSMemSize,FALSE))
       return;

   if (!pI830->overrideBIOSMemSize)
      return;

#if HAVE_GET_PUT_BIOSMEMSIZE
   if (!pI830->useSWF1) {
      PutBIOSMemSize(pScrn, pI830->saveBIOSMemSize);
      return;
   }
#endif

   if ((IS_I830(pI830) || IS_845G(pI830)) && pI830->useSWF1) {
      swf1 = INREG(SWF1);
      swf1 &= ~0x0f;
      swf1 |= (pI830->saveSWF1 & 0x0f);
      OUTREG(SWF1, swf1);
   }
}

static void
SetBIOSMemSize(ScrnInfoPtr pScrn, int newSize)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned long swf1;
   Bool mapped;

   DPRINTF(PFX, "SetBIOSMemSize: %d kB\n", newSize / 1024);

   if (!pI830->overrideBIOSMemSize)
      return;

#if HAVE_GET_PUT_BIOSMEMSIZE
   if (!pI830->useSWF1) {
      PutBIOSMemSize(pScrn, newSize);
      return;
   }
#endif

   if ((IS_I830(pI830) || IS_845G(pI830)) && pI830->useSWF1) {
      unsigned long newSWF1;

      /* Need MMIO access here. */
      mapped = (pI830->MMIOBase != NULL);
      if (!mapped)
	 I830MapMMIO(pScrn);

      if (newSize <= KB(832))
	 newSWF1 = 1;
      else
	 newSWF1 = 8;

      swf1 = INREG(SWF1);
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Before: SWF1 is 0x%08lx\n", swf1);
      swf1 &= ~0x0f;
      swf1 |= (newSWF1 & 0x0f);
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "After: SWF1 is 0x%08lx\n", swf1);
      OUTREG(SWF1, swf1);
      if (!mapped)
	 I830UnmapMMIO(pScrn);
   }
}

/*
 * Use the native method instead of the vgahw method.  So far this is
 * only used for 8-bit mode.
 *
 * XXX Look into using the 10-bit gamma correction mode for 15/16/24 bit,
 * and see if a DirectColor visual can be offered.
 */
static void
I830LoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
		LOCO * colors, VisualPtr pVisual)
{
   I830Ptr pI830;
   int i, index;
   unsigned char r, g, b;
   CARD32 val, temp;

   DPRINTF(PFX, "I830LoadPalette: numColors: %d\n", numColors);
   pI830 = I830PTR(pScrn);

   if (pI830->pipeEnabled[0]) {
      /* It seems that an initial read is needed. */
      temp = INREG(PALETTE_A);
      for (i = 0; i < numColors; i++) {
	 index = indices[i];
	 r = colors[index].red;
	 g = colors[index].green;
	 b = colors[index].blue;
	 val = (r << 16) | (g << 8) | b;
	 OUTREG(PALETTE_A + index * 4, val);
      }
   }
   if (pI830->pipeEnabled[1]) {
      /* It seems that an initial read is needed. */
      temp = INREG(PALETTE_B);
      for (i = 0; i < numColors; i++) {
	 index = indices[i];
	 r = colors[index].red;
	 g = colors[index].green;
	 b = colors[index].blue;
	 val = (r << 16) | (g << 8) | b;
	 OUTREG(PALETTE_B + index * 4, val);
      }
   }
}

static void
PreInitCleanup(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   RestoreBIOSMemSize(pScrn);
   if (pI830->swfSaved) {
      OUTREG(SWF0, pI830->saveSWF0);
      OUTREG(SWF4, pI830->saveSWF4);
   }
   if (pI830->MMIOBase)
      I830UnmapMMIO(pScrn);
   I830BIOSFreeRec(pScrn);
}

static Bool
I830BIOSPreInit(ScrnInfoPtr pScrn, int flags)
{
   vgaHWPtr hwp;
   I830Ptr pI830;
   MessageType from;
   rgb defaultWeight = { 0, 0, 0 };
   vbeInfoPtr pVbe;
   EntityInfoPtr pEnt;
   int mem, memsize;
   int flags24;
   int i, n;
   pointer pDDCModule, pVBEModule;
   Bool enable;
   const char *chipname;

   if (pScrn->numEntities != 1)
      return FALSE;

   /* Load int10 module */
   if (!xf86LoadSubModule(pScrn, "int10"))
      return FALSE;
   xf86LoaderReqSymLists(I810int10Symbols, NULL);

   /* Load vbe module */
   if (!(pVBEModule = xf86LoadSubModule(pScrn, "vbe")))
      return FALSE;
   xf86LoaderReqSymLists(I810vbeSymbols, NULL);

   pEnt = xf86GetEntityInfo(pScrn->entityList[0]);

   if (flags & PROBE_DETECT) {
      I830BIOSProbeDDC(pScrn, pEnt->index);
      return TRUE;
   }

   /* The vgahw module should be loaded here when needed */
   if (!xf86LoadSubModule(pScrn, "vgahw"))
      return FALSE;
   xf86LoaderReqSymLists(I810vgahwSymbols, NULL);


   /* Allocate a vgaHWRec */
   if (!vgaHWGetHWRec(pScrn))
      return FALSE;

   /* Allocate driverPrivate */
   if (!I830BIOSGetRec(pScrn))
      return FALSE;

   pI830 = I830PTR(pScrn);
   pI830->SaveGeneration = -1;
   pI830->pEnt = pEnt;

   if (pI830->pEnt->location.type != BUS_PCI)
      return FALSE;

   pI830->PciInfo = xf86GetPciInfoForEntity(pI830->pEnt->index);
   pI830->PciTag = pciTag(pI830->PciInfo->bus, pI830->PciInfo->device,
			  pI830->PciInfo->func);

   if (xf86RegisterResources(pI830->pEnt->index, 0, ResNone)) {
      PreInitCleanup(pScrn);
      return FALSE;

   }

   pScrn->racMemFlags = RAC_FB | RAC_COLORMAP;
   pScrn->monitor = pScrn->confScreen->monitor;
   pScrn->progClock = TRUE;
   pScrn->rgbBits = 8;

   flags24 = Support32bppFb | PreferConvert24to32 | SupportConvert24to32;

   if (!xf86SetDepthBpp(pScrn, 0, 0, 0, flags24))
      return FALSE;

   switch (pScrn->depth) {
   case 8:
   case 15:
   case 16:
   case 24:
      break;
   default:
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Given depth (%d) is not supported by I830 driver\n",
		 pScrn->depth);
      return FALSE;
   }
   xf86PrintDepthBpp(pScrn);

   if (!xf86SetWeight(pScrn, defaultWeight, defaultWeight))
      return FALSE;
   if (!xf86SetDefaultVisual(pScrn, -1))
      return FALSE;

   hwp = VGAHWPTR(pScrn);
   pI830->cpp = pScrn->bitsPerPixel / 8;

   /* Process the options */
   xf86CollectOptions(pScrn, NULL);
   if (!(pI830->Options = xalloc(sizeof(I830BIOSOptions))))
      return FALSE;
   memcpy(pI830->Options, I830BIOSOptions, sizeof(I830BIOSOptions));
   xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pI830->Options);

   /* We have to use PIO to probe, because we haven't mapped yet. */
   I830SetPIOAccess(pI830);

   /* Initialize VBE record */
   if ((pI830->pVbe = VBEInit(NULL, pI830->pEnt->index)) == NULL) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "VBE initialization failed.\n");
      return FALSE;
   }

   switch (pI830->PciInfo->chipType) {
   case PCI_CHIP_I830_M:
      chipname = "830M";
      break;
   case PCI_CHIP_845_G:
      chipname = "845G";
      break;
   case PCI_CHIP_I855_GM:
      /* Check capid register to find the chipset variant */
      pI830->variant = (pciReadLong(pI830->PciTag, I85X_CAPID)
				>> I85X_VARIANT_SHIFT) & I85X_VARIANT_MASK;
      switch (pI830->variant) {
      case I855_GM:
	 chipname = "855GM";
	 break;
      case I855_GME:
	 chipname = "855GME";
	 break;
      case I852_GM:
	 chipname = "852GM";
	 break;
      case I852_GME:
	 chipname = "852GME";
	 break;
      default:
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Unknown 852GM/855GM variant: 0x%x)\n", pI830->variant);
	 chipname = "852GM/855GM (unknown variant)";
	 break;
      }
      break;
   case PCI_CHIP_I865_G:
      chipname = "865G";
      break;
   default:
      chipname = "unknown chipset";
      break;
   }
   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "Integrated Graphics Chipset: Intel(R) %s\n", chipname);

   pVbe = pI830->pVbe;

   pI830->vbeInfo = VBEGetVBEInfo(pVbe);

   /* Set the Chipset and ChipRev, allowing config file entries to override. */
   if (pI830->pEnt->device->chipset && *pI830->pEnt->device->chipset) {
      pScrn->chipset = pI830->pEnt->device->chipset;
      from = X_CONFIG;
   } else if (pI830->pEnt->device->chipID >= 0) {
      pScrn->chipset = (char *)xf86TokenToString(I830BIOSChipsets,
						 pI830->pEnt->device->chipID);
      from = X_CONFIG;
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
		 pI830->pEnt->device->chipID);
   } else {
      from = X_PROBED;
      pScrn->chipset = (char *)xf86TokenToString(I830BIOSChipsets,
						 pI830->PciInfo->chipType);
   }

   if (pI830->pEnt->device->chipRev >= 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
		 pI830->pEnt->device->chipRev);
   }

   xf86DrvMsg(pScrn->scrnIndex, from, "Chipset: \"%s\"\n",
	      (pScrn->chipset != NULL) ? pScrn->chipset : "Unknown i8xx");

   if (pI830->pEnt->device->MemBase != 0) {
      pI830->LinearAddr = pI830->pEnt->device->MemBase;
      from = X_CONFIG;
   } else {
      if (pI830->PciInfo->memBase[1] != 0) {
	 /* XXX Check mask. */
	 pI830->LinearAddr = pI830->PciInfo->memBase[0] & 0xFF000000;
	 from = X_PROBED;
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "No valid FB address in PCI config space\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
   }

   xf86DrvMsg(pScrn->scrnIndex, from, "Linear framebuffer at 0x%lX\n",
	      (unsigned long)pI830->LinearAddr);

   if (pI830->pEnt->device->IOBase != 0) {
      pI830->MMIOAddr = pI830->pEnt->device->IOBase;
      from = X_CONFIG;
   } else {
      if (pI830->PciInfo->memBase[1]) {
	 pI830->MMIOAddr = pI830->PciInfo->memBase[1] & 0xFFF80000;
	 from = X_PROBED;
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "No valid MMIO address in PCI config space\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
   }

   xf86DrvMsg(pScrn->scrnIndex, from, "IO registers at addr 0x%lX\n",
	      (unsigned long)pI830->MMIOAddr);

   /* Some of the probing needs MMIO access, so map it here. */
   I830MapMMIO(pScrn);

#if 1
   pI830->saveSWF0 = INREG(SWF0);
   pI830->saveSWF4 = INREG(SWF4);
   pI830->swfSaved = TRUE;

   /* Set "extended desktop" */
   OUTREG(SWF0, pI830->saveSWF0 | (1 << 21));

   /* Set "driver loaded",  "OS unknown", "APM 1.2" */
   OUTREG(SWF4, (pI830->saveSWF4 & ~((3 << 19) | (7 << 16))) |
		(1 << 23) | (2 << 16));
#endif

   if (IS_I830(pI830) || IS_845G(pI830)) {
      PCITAG bridge;
      CARD16 gmch_ctrl;

      bridge = pciTag(0, 0, 0);		/* This is always the host bridge */
      gmch_ctrl = pciReadWord(bridge, I830_GMCH_CTRL);
      if ((gmch_ctrl & I830_GMCH_MEM_MASK) == I830_GMCH_MEM_128M) {
	 pI830->FbMapSize = 0x8000000;
      } else {
	 pI830->FbMapSize = 0x4000000;
      }
   }
   else {
      /* 128MB aperture for later chips */
      pI830->FbMapSize = 0x8000000;
   }

   /*
    * Get the pre-allocated (stolen) memory size.
    */
   pI830->StolenMemory.Size = I830DetectMemory(pScrn);
   pI830->StolenMemory.Start = 0;
   pI830->StolenMemory.End = pI830->StolenMemory.Size;

   /* Sanity check: compare with what the BIOS thinks. */
   if (pI830->vbeInfo->TotalMemory != pI830->StolenMemory.Size / 1024 / 64) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Detected stolen memory (%ld kB) doesn't match what the BIOS"
		 " reports (%d kB)\n",
		 ROUND_DOWN_TO(pI830->StolenMemory.Size / 1024, 64),
		 pI830->vbeInfo->TotalMemory * 64);
   }

   /* Find the maximum amount of agpgart memory available. */
   mem = I830CheckAvailableMemory(pScrn);
   pI830->StolenOnly = FALSE;

   if (mem <= 0) {
      if (pI830->StolenMemory.Size <= 0) {
	 /* Shouldn't happen. */
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "/dev/agpgart is either not available, or no memory "
		 "is available\nfor allocation, "
		 "and no pre-allocated memory is available.\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "/dev/agpgart is either not available, or no memory "
		 "is available\nfor allocation.  "
		 "Using pre-allocated memory only.\n");
      mem = 0;
      pI830->StolenOnly = TRUE;
   }

   if (xf86ReturnOptValBool(pI830->Options, OPTION_NOACCEL, FALSE)) {
      pI830->noAccel = TRUE;
   }
   if (xf86ReturnOptValBool(pI830->Options, OPTION_SW_CURSOR, FALSE)) {
      pI830->SWCursor = TRUE;
   }

   pI830->directRenderingDisabled =
	!xf86ReturnOptValBool(pI830->Options, OPTION_DRI, TRUE);

#ifdef XF86DRI
   if (!pI830->directRenderingDisabled) {
      if (pI830->noAccel || pI830->SWCursor) {
	 xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "DRI is disabled because it "
		    "needs HW cursor and 2D acceleration.\n");
	 pI830->directRenderingDisabled = TRUE;
      } else if (pScrn->depth != 16 && pScrn->depth != 24) {
	 xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "DRI is disabled because it "
		    "runs only at depths 16 and 24.\n");
	 pI830->directRenderingDisabled = TRUE;
      }
   }
#endif

   /*
    * The "VideoRam" config file parameter specifies the total amount of
    * memory that will be used/allocated.  When agpgart support isn't
    * available (StolenOnly == TRUE), this is limited to the amount of
    * pre-allocated ("stolen") memory.
    */

   /*
    * Default to I830_DEFAULT_VIDEOMEM_2D (8192KB) for 2D-only,
    * or I830_DEFAULT_VIDEOMEM_3D (32768KB) for 3D.  If the stolen memory
    * amount is higher, default to it rounded up to the nearest MB.  This
    * guarantees that by default there will be at least some run-time
    * space for things that need a physical address.
    */
   if (!pI830->pEnt->device->videoRam) {
      from = X_DEFAULT;
#ifdef XF86DRI
      if (!pI830->directRenderingDisabled)
	 pScrn->videoRam = I830_DEFAULT_VIDEOMEM_3D;
      else
#endif
	 pScrn->videoRam = I830_DEFAULT_VIDEOMEM_2D;
      if (pI830->StolenMemory.Size / 1024 > pScrn->videoRam)
	 pScrn->videoRam = ROUND_TO(pI830->StolenMemory.Size / 1024, 1024);
   } else {
      from = X_CONFIG;
      pScrn->videoRam = pI830->pEnt->device->videoRam;
   }

   DPRINTF(PFX,
	   "Available memory: %dk\n"
	   "Requested memory: %dk\n", mem, pScrn->videoRam);


   if (mem + (pI830->StolenMemory.Size / 1024) < pScrn->videoRam) {
      pScrn->videoRam = mem + (pI830->StolenMemory.Size / 1024);
      from = X_PROBED;
      if (mem + (pI830->StolenMemory.Size / 1024) <
	  pI830->pEnt->device->videoRam) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "VideoRAM reduced to %d kByte "
		    "(limited to available sysmem)\n", pScrn->videoRam);
      }
   }

   if (pScrn->videoRam > pI830->FbMapSize / 1024) {
      pScrn->videoRam = pI830->FbMapSize / 1024;
      if (pI830->FbMapSize / 1024 < pI830->pEnt->device->videoRam)
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "VideoRam reduced to %d kByte (limited to aperture size)\n",
		    pScrn->videoRam);
   }

   if (mem > 0) {
      /*
       * If the reserved (BIOS accessible) memory is less than the desired
       * amount, try to increase it.  So far this is only implemented for
       * the 845G and 830, but those details are handled in SetBIOSMemSize().
       * 
       * The BIOS-accessible amount is only important for setting video
       * modes.  The maximum amount we try to set is limited to what would
       * be enough for 1920x1440 with a 2048 pitch.
       *
       * If ALLOCATE_ALL_BIOSMEM is enabled in i830_memory.c, all of the
       * BIOS-aware memory will get allocated.  If it isn't then it may
       * not be, and in that case there is an assumption that the video
       * BIOS won't attempt to access memory beyond what is needed for
       * modes that are actually used.  ALLOCATE_ALL_BIOSMEM is enabled by
       * default.
       */

      /* Try to keep HW cursor and Overlay amounts separate from this. */
      int reserve = (HWCURSOR_SIZE + OVERLAY_SIZE) / 1024;

      if (pScrn->videoRam - reserve >= I830_MAXIMUM_VBIOS_MEM)
	 pI830->newBIOSMemSize = KB(I830_MAXIMUM_VBIOS_MEM);
      else 
	 pI830->newBIOSMemSize =
			KB(ROUND_DOWN_TO(pScrn->videoRam - reserve, 64));
      if (pI830->vbeInfo->TotalMemory * 64 < pI830->newBIOSMemSize / 1024) {

	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Will attempt to tell the BIOS that there is "
		    "%d kB VideoRAM\n", pI830->newBIOSMemSize / 1024);
	 if (SaveBIOSMemSize(pScrn)) {
	    pI830->overrideBIOSMemSize = TRUE;
	    SetBIOSMemSize(pScrn, pI830->newBIOSMemSize);

	    VBEFreeVBEInfo(pI830->vbeInfo);
	    vbeFree(pI830->pVbe);
	    pI830->pVbe = VBEInit(NULL, pI830->pEnt->index);
	    pVbe = pI830->pVbe;
	    pI830->vbeInfo = VBEGetVBEInfo(pVbe);

	    pI830->BIOSMemorySize = KB(pI830->vbeInfo->TotalMemory * 64);
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "BIOS now sees %ld kB VideoRAM\n",
		       pI830->BIOSMemorySize / 1024);
 	 } else if ((pI830->saveBIOSMemSize 
 		  = TweakMemorySize(pScrn, pI830->newBIOSMemSize, TRUE)) != 0) 
 		 pI830->overrideBIOSMemSize = TRUE;
 	     else {
 		 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 			    "BIOS view of memory size can't be changed "
 			    "(this is not an error).\n");
	 }
      }
   }

   pVbe = pI830->pVbe;

   xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Pre-allocated VideoRAM: %ld kByte\n",
	      pI830->StolenMemory.Size / 1024);
   xf86DrvMsg(pScrn->scrnIndex, from, "VideoRAM: %d kByte\n", pScrn->videoRam);
   pI830->TotalVideoRam = KB(pScrn->videoRam);

   /*
    * If the requested videoRam amount is less than the stolen memory size,
    * reduce the stolen memory size accordingly.
    */
   if (pI830->StolenMemory.Size > pI830->TotalVideoRam) {
      pI830->StolenMemory.Size = pI830->TotalVideoRam;
      pI830->StolenMemory.End = pI830->TotalVideoRam;
   }

   if (xf86GetOptValInteger(pI830->Options, OPTION_CACHE_LINES,
			    &(pI830->CacheLines))) {
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Requested %d cache lines\n",
		 pI830->CacheLines);
   } else {
      pI830->CacheLines = -1;
   }

   pI830->XvDisabled =
	!xf86ReturnOptValBool(pI830->Options, OPTION_XVIDEO, TRUE);

#ifdef I830_XV
   if (xf86GetOptValInteger(pI830->Options, OPTION_VIDEO_KEY,
			    &(pI830->colorKey))) {
      from = X_CONFIG;
   } else if (xf86GetOptValInteger(pI830->Options, OPTION_COLOR_KEY,
			    &(pI830->colorKey))) {
      from = X_CONFIG;
   } else {
      pI830->colorKey = (1 << pScrn->offset.red) |
			(1 << pScrn->offset.green) |
			(((pScrn->mask.blue >> pScrn->offset.blue) - 1) <<
			 pScrn->offset.blue);
      from = X_DEFAULT;
   }
   xf86DrvMsg(pScrn->scrnIndex, from, "video overlay key set to 0x%x\n",
	      pI830->colorKey);
#endif

   pI830->allowPageFlip = FALSE;
   enable = xf86ReturnOptValBool(pI830->Options, OPTION_PAGEFLIP, FALSE);
#ifdef XF86DRI
   if (!pI830->directRenderingDisabled) {
      pI830->allowPageFlip = enable;
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "page flipping %s\n",
		 enable ? "enabled" : "disabled");
   }
#endif

   /* Check if the HW cursor needs physical address. */
   if (IS_MOBILE(pI830))
      pI830->CursorNeedsPhysical = TRUE;
   else
      pI830->CursorNeedsPhysical = FALSE;

   /* Force ring buffer to be in low memory for the 845G and later. */
   if (IS_845G(pI830) || IS_I85X(pI830) || IS_I865G(pI830))
      pI830->NeedRingBufferLow = TRUE;

   /*
    * XXX If we knew the pre-initialised GTT format for certain, we could
    * probably figure out the physical address even in the StolenOnly case.
    */
   if (pI830->StolenOnly && pI830->CursorNeedsPhysical && !pI830->SWCursor) {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		 "HW Cursor disabled because it needs agpgart memory.\n");
      pI830->SWCursor = TRUE;
   }

   /*
    * Reduce the maximum videoram available for video modes by the ring buffer,
    * minimum scratch space and HW cursor amounts.
    */
   if (!pI830->SWCursor)
      pScrn->videoRam -= (HWCURSOR_SIZE / 1024);
   if (!pI830->XvDisabled)
      pScrn->videoRam -= (OVERLAY_SIZE / 1024);
   if (!pI830->noAccel) {
      pScrn->videoRam -= (PRIMARY_RINGBUFFER_SIZE / 1024);
      pScrn->videoRam -= (MIN_SCRATCH_BUFFER_SIZE / 1024);
   }

   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      "Maximum frambuffer space: %d kByte\n", pScrn->videoRam);

   /*
    * If the driver can do gamma correction, it should call xf86SetGamma() here.
    */

   {
      Gamma zeros = { 0.0, 0.0, 0.0 };

      if (!xf86SetGamma(pScrn, zeros))
	 return FALSE;
   }

   if (IS_MOBILE(pI830))
      pI830->availablePipes = 2;
   else
      pI830->availablePipes = 1;
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%d display pipe%s available.\n",
	      pI830->availablePipes, pI830->availablePipes > 1 ? "s" : "");

   pI830->displayInfo = TRUE;
   from = X_DEFAULT;
   if (!xf86ReturnOptValBool(pI830->Options, OPTION_DISPLAY_INFO, TRUE)) {
      from = X_CONFIG;
      pI830->displayInfo = FALSE;
   }
   xf86DrvMsg(pScrn->scrnIndex, from, "Display Info: %s.\n",
	      pI830->displayInfo ? "enabled" : "disabled");

   if (!I830DetectDisplayDevice(pScrn)) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Couldn't detect display devices.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

   if ((pDDCModule = xf86LoadSubModule(pScrn, "ddc")) == NULL) {
      PreInitCleanup(pScrn);
      return FALSE;
   }

   if ((pI830->vesa->monitor = vbeDoEDID(pVbe, pDDCModule)) != NULL) {
      xf86PrintEDID(pI830->vesa->monitor);
   }
   if ((pScrn->monitor->DDC = pI830->vesa->monitor) != NULL)
      xf86SetDDCproperties(pScrn, pI830->vesa->monitor);
   xf86UnloadSubModule(pDDCModule);

   /* XXX Move this to a header. */
#define VIDEO_BIOS_SCRATCH 0x18

#if 1
   /*
    * XXX This should be in ScreenInit/EnterVT.  PreInit should not leave the
    * state changed.
    */
   /* Enable hot keys by writing the proper value to GR18 */
   {
      CARD8 gr18;

      gr18 = pI830->readControl(pI830, GRX, VIDEO_BIOS_SCRATCH);
      gr18 &= ~0x80;			/*
					 * Clear Hot key bit so that Video
					 * BIOS performs the hot key
					 * servicing
					 */
      pI830->writeControl(pI830, GRX, VIDEO_BIOS_SCRATCH, gr18);
   }
#endif

   for (i = 0; i < pI830->availablePipes; i++) {
      int pipe =
	  (pI830->configuredDevices >> PIPE_SHIFT(i)) & PIPE_ACTIVE_MASK;
      if (pipe & ~PIPE_CRT_ACTIVE) {
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		    "A non-CRT device is attached to pipe %c.\n"
		    "\tNo refresh rate overrides will be attempted.\n",
		    PIPE_NAME(i));
	 pI830->vesa->useDefaultRefresh = TRUE;
      }
      /*
       * Some desktop platforms might not have 0x5f05, so useExtendedRefresh
       * would need to be set to FALSE for those cases.
       */
      if (!pI830->vesa->useDefaultRefresh)
	 pI830->useExtendedRefresh = TRUE;
   }

   if (pI830->useExtendedRefresh) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Will use BIOS call 0x5f05 to set refresh rates for CRTs.\n");
   }

   /*
    * Calling 0x5f64 can reset the refresh rate, so only do this when
    * using 0x5f05, or when not overriding the default refresh rate.
    * Also, 0x5f64 doesn't work correctly in i830 platforms.
    */
   pI830->enableDisplays = !IS_I830(pI830) && pI830->useExtendedRefresh;

   if (pI830->enableDisplays) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Will use BIOS call 0x5f64 to enable displays.\n");
   }

   /*
    * Limit videoram available for mode selection to what the video
    * BIOS can see.
    */
   if (pScrn->videoRam > (pI830->vbeInfo->TotalMemory * 64))
      memsize = pI830->vbeInfo->TotalMemory * 64;
   else
      memsize = pScrn->videoRam;
   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      "Maximum space available for video modes: %d kByte\n", memsize);

   /*
    * Note: VBE modes (> 0x7f) won't work with Intel's extended BIOS
    * functions.  For that reason it's important to set only
    * V_MODETYPE_VGA in the flags for VBEGetModePool().
    */
   pScrn->modePool = VBEGetModePool(pScrn, pVbe, pI830->vbeInfo,
				    V_MODETYPE_VGA);

   if (!pScrn->modePool) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "No Video BIOS modes for chosen depth.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

   VBESetModeNames(pScrn->modePool);

   /*
    * XXX DDC information: There's code in xf86ValidateModes
    * (VBEValidateModes) to set monitor defaults based on DDC information
    * where available.  If we need something that does better than this,
    * there's code in vesa/vesa.c.
    */

   /* XXX Need to get relevant modes and virtual parameters. */
   /* Do the mode validation without regard to special scanline pitches. */
   n = VBEValidateModes(pScrn, NULL, pScrn->display->modes, NULL,
			NULL, 0, MAX_DISPLAY_PITCH, 1,
			0, MAX_DISPLAY_HEIGHT,
			pScrn->display->virtualX,
			pScrn->display->virtualY,
			memsize, LOOKUP_BEST_REFRESH);
   if (n <= 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

   xf86PruneDriverModes(pScrn);

   pScrn->currentMode = pScrn->modes;

   if (pScrn->modes == NULL) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No modes.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

#ifndef USE_PITCHES
#define USE_PITCHES 1
#endif

   /*
    * If DRI is potentially usable, check if there is enough memory available
    * for it, and if there's also enough to allow tiling to be enabled.
    */
#if defined(XF86DRI)
   if (!pI830->directRenderingDisabled) {
      int savedDisplayWidth = pScrn->displayWidth;
      int memNeeded = 0;
      /* Good pitches to allow tiling.  Don't care about pitches < 256. */
      static const int pitches[] = {
	 128 * 2,
	 128 * 4,
	 128 * 8,
	 128 * 16,
	 128 * 32,
	 128 * 64,
	 0
      };

#ifdef I830_XV
      /*
       * Set this so that the overlay allocation is factored in when
       * appropriate.
       */
      pI830->XvEnabled = !pI830->XvDisabled;
#endif

      for (i = 0; pitches[i] != 0; i++) {
#if USE_PITCHES
	 if (pitches[i] >= pScrn->displayWidth) {
	    pScrn->displayWidth = pitches[i];
	    break;
	 }
#else
	 if (pitches[i] == pScrn->displayWidth)
	    break;
#endif
      }

      /*
       * If the displayWidth is a tilable pitch, test if there's enough
       * memory available to enable tiling.
       */
      if (pScrn->displayWidth == pitches[i]) {
	 I830ResetAllocations(pScrn, 0);
	 if (I830Allocate2DMemory(pScrn, ALLOCATE_DRY_RUN | ALLOC_INITIAL) &&
	     I830Allocate3DMemory(pScrn, ALLOCATE_DRY_RUN)) {
	    memNeeded = I830GetExcessMemoryAllocations(pScrn);
	    if (memNeeded > 0 || pI830->MemoryAperture.Size < 0) {
	       if (memNeeded > 0) {
		  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			     "%d kBytes additional video memory is "
			     "required to\n\tenable tiling mode for DRI.\n",
			     (memNeeded + 1023) / 1024);
	       }
	       if (pI830->MemoryAperture.Size < 0) {
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			     "Allocation with DRI tiling enabled would "
			     "exceed the\n"
			     "\tmemory aperture size (%ld kB) by %ld kB.\n"
			     "\tReduce VideoRam amount to avoid this!\n",
			     pI830->FbMapSize / 1024,
			     -pI830->MemoryAperture.Size / 1024);
	       }
	       pScrn->displayWidth = savedDisplayWidth;
	       pI830->allowPageFlip = FALSE;
	    } else if (pScrn->displayWidth != savedDisplayWidth) {
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			  "Increasing the scanline pitch to allow tiling mode "
			  "(%d -> %d).\n",
			  savedDisplayWidth, pScrn->displayWidth);
	    }
	 } else {
	    memNeeded = 0;
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Unexpected dry run allocation failure (1).\n");
	 }
      }
      if (memNeeded > 0 || pI830->MemoryAperture.Size < 0) {
	 /*
	  * Tiling can't be enabled.  Check if there's enough memory for DRI
	  * without tiling.
	  */
	 pI830->disableTiling = TRUE;
	 I830ResetAllocations(pScrn, 0);
	 if (I830Allocate2DMemory(pScrn, ALLOCATE_DRY_RUN | ALLOC_INITIAL) &&
	     I830Allocate3DMemory(pScrn, ALLOCATE_DRY_RUN | ALLOC_NO_TILING)) {
	    memNeeded = I830GetExcessMemoryAllocations(pScrn);
	    if (memNeeded > 0 || pI830->MemoryAperture.Size < 0) {
	       if (memNeeded > 0) {
		  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			     "%d kBytes additional video memory is required "
			     "to enable DRI.\n",
			     (memNeeded + 1023) / 1024);
	       }
	       if (pI830->MemoryAperture.Size < 0) {
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			     "Allocation with DRI enabled would "
			     "exceed the\n"
			     "\tmemory aperture size (%ld kB) by %ld kB.\n"
			     "\tReduce VideoRam amount to avoid this!\n",
			     pI830->FbMapSize / 1024,
			     -pI830->MemoryAperture.Size / 1024);
	       }
	       pI830->directRenderingDisabled = TRUE;
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Disabling DRI.\n");
	    }
	 } else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Unexpected dry run allocation failure (2).\n");
	 }
      }
   }
#endif

   VBEPrintModes(pScrn);

   if (!pI830->vesa->useDefaultRefresh) {
      /*
       * This sets the parameters for the VBE modes according to the best
       * usable parameters from the Monitor sections modes (usually the
       * default VESA modes), allowing for better than default refresh rates.
       * This only works for VBE 3.0 and later.  Also, we only do this
       * if there are no non-CRT devices attached.
       */
      VBESetModeParameters(pScrn, pVbe);
   }

   /* PreInit shouldn't leave any state changes, so restore this. */
   RestoreBIOSMemSize(pScrn);

   /* Don't need MMIO access anymore. */
   if (pI830->swfSaved) {
      OUTREG(SWF0, pI830->saveSWF0);
      OUTREG(SWF4, pI830->saveSWF4);
   }
   I830UnmapMMIO(pScrn);

   /* Set display resolution */
   xf86SetDpi(pScrn, 0, 0);

   /* Load the required sub modules */
   if (!xf86LoadSubModule(pScrn, "fb")) {
      PreInitCleanup(pScrn);
      return FALSE;
   }

   xf86LoaderReqSymLists(I810fbSymbols, NULL);

   if (!pI830->noAccel) {
      if (!xf86LoadSubModule(pScrn, "xaa")) {
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I810xaaSymbols, NULL);
   }

   if (!pI830->SWCursor) {
      if (!xf86LoadSubModule(pScrn, "ramdac")) {
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I810ramdacSymbols, NULL);
   }

   /*  We won't be using the VGA access after the probe. */
   I830SetMMIOAccess(pI830);
   xf86SetOperatingState(resVgaIo, pI830->pEnt->index, ResUnusedOpr);
   xf86SetOperatingState(resVgaMem, pI830->pEnt->index, ResDisableOpr);

   VBEFreeVBEInfo(pI830->vbeInfo);
   vbeFree(pVbe);

   /* Use the VBE mode restore workaround by default. */
   pI830->vbeRestoreWorkaround = TRUE;
   from = X_DEFAULT;
   if (xf86ReturnOptValBool(pI830->Options, OPTION_VBE_RESTORE, FALSE)) {
      pI830->vbeRestoreWorkaround = FALSE;
      from = X_CONFIG;
   }
   xf86DrvMsg(pScrn->scrnIndex, from, "VBE Restore workaround: %s.\n",
	      pI830->vbeRestoreWorkaround ? "enabled" : "disabled");
      
#if defined(XF86DRI)
   /* Load the dri module if requested. */
   if (xf86ReturnOptValBool(pI830->Options, OPTION_DRI, FALSE) &&
       !pI830->directRenderingDisabled) {
      if (xf86LoadSubModule(pScrn, "dri")) {
	 xf86LoaderReqSymLists(I810driSymbols, I810drmSymbols, NULL);
      }
   }

   if (!pI830->directRenderingDisabled) {
      if (!xf86LoadSubModule(pScrn, "shadow")) {
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I810shadowSymbols, NULL);
   }
#endif

   return TRUE;
}

/*
 * As the name says.  Check that the initial state is reasonable.
 * If any unrecoverable problems are found, bail out here.
 */
static Bool
CheckInheritedState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int errors = 0, fatal = 0;
   unsigned long temp, head, tail;

   /* Check first for page table errors */
   temp = INREG(PGE_ERR);
   if (temp != 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "PGTBL_ER is 0x%08lx\n", temp);
      errors++;
   }
   temp = INREG(PGETBL_CTL);
   if (!(temp & 1)) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "PGTBL_CTL (0x%08lx) indicates GTT is disabled\n", temp);
      errors++;
   }
   temp = INREG(LP_RING + RING_LEN);
   if (temp & 1) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "PRB0_CTL (0x%08lx) indicates ring buffer enabled\n", temp);
      errors++;
   }
   head = INREG(LP_RING + RING_HEAD);
   tail = INREG(LP_RING + RING_TAIL);
   if ((tail & I830_TAIL_MASK) != (head & I830_HEAD_MASK)) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "PRB0_HEAD (0x%08lx) and PRB0_TAIL (0x%08lx) indicate "
		 "ring buffer not flushed\n", head, tail);
      errors++;
   }
#if 0
   if (errors)
      I830PrintErrorState(pScrn);
#endif

   if (fatal)
      FatalError("CheckInheritedState: can't recover from the above\n");

   return (errors != 0);
}

/*
 * Reset registers that it doesn't make sense to save/restore to a sane state.
 * This is basically the ring buffer and fence registers.  Restoring these
 * doesn't make sense without restoring GTT mappings.  This is something that
 * whoever gets control next should do.
 */
static void
ResetState(ScrnInfoPtr pScrn, Bool flush)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int i;
   unsigned long temp;

   DPRINTF(PFX, "ResetState: flush is %s\n", BOOLTOSTRING(flush));

   /* Reset the fence registers to 0 */
   for (i = 0; i < 8; i++)
      OUTREG(FENCE + i * 4, 0);

   /* Flush the ring buffer (if enabled), then disable it. */
   if (pI830->AccelInfoRec != NULL && flush) {
      temp = INREG(LP_RING + RING_LEN);
      if (temp & 1) {
	 I830RefreshRing(pScrn);
	 I830Sync(pScrn);
	 DO_RING_IDLE();
      }
   }
   OUTREG(LP_RING + RING_LEN, 0);
   OUTREG(LP_RING + RING_HEAD, 0);
   OUTREG(LP_RING + RING_TAIL, 0);
   OUTREG(LP_RING + RING_START, 0);

   if (pI830->CursorInfoRec && pI830->CursorInfoRec->HideCursor)
       pI830->CursorInfoRec->HideCursor(pScrn);
}

static void
SetFenceRegs(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int i;

   DPRINTF(PFX, "SetFenceRegs\n");

   for (i = 0; i < 8; i++) {
      OUTREG(FENCE + i * 4, pI830->ModeReg.Fence[i]);
      if (I810_DEBUG & DEBUG_VERBOSE_VGA)
	 ErrorF("Fence Register : %x\n", pI830->ModeReg.Fence[i]);
   }
}

static void
SetRingRegs(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned int itemp;

   DPRINTF(PFX, "SetRingRegs\n");

   if (pI830->noAccel)
      return;

   OUTREG(LP_RING + RING_LEN, 0);
   OUTREG(LP_RING + RING_TAIL, 0);
   OUTREG(LP_RING + RING_HEAD, 0);

   if ((pI830->LpRing.mem.Start & I830_RING_START_MASK) !=
       pI830->LpRing.mem.Start) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "I830SetRingRegs: Ring buffer start (%lx) violates its "
		 "mask (%x)\n", pI830->LpRing.mem.Start, I830_RING_START_MASK);
   }
   /* Don't care about the old value.  Reserved bits must be zero anyway. */
   itemp = pI830->LpRing.mem.Start & I830_RING_START_MASK;
   OUTREG(LP_RING + RING_START, itemp);

   if (((pI830->LpRing.mem.Size - 4096) & I830_RING_NR_PAGES) !=
       pI830->LpRing.mem.Size - 4096) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "I830SetRingRegs: Ring buffer size - 4096 (%lx) violates its "
		 "mask (%x)\n", pI830->LpRing.mem.Size - 4096,
		 I830_RING_NR_PAGES);
   }
   /* Don't care about the old value.  Reserved bits must be zero anyway. */
   itemp = (pI830->LpRing.mem.Size - 4096) & I830_RING_NR_PAGES;
   itemp |= (RING_NO_REPORT | RING_VALID);
   OUTREG(LP_RING + RING_LEN, itemp);
   I830RefreshRing(pScrn);
}

/*
 * This should be called everytime the X server gains control of the screen,
 * before any video modes are programmed (ScreenInit, EnterVT).
 */
static void
SetHWOperatingState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "SetHWOperatingState\n");

   if (!pI830->noAccel)
      SetRingRegs(pScrn);
   SetFenceRegs(pScrn);
   if (!pI830->SWCursor)
      I830InitHWCursor(pScrn);
}

static Bool
SaveHWState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   vgaHWPtr hwp = VGAHWPTR(pScrn);
   vgaRegPtr vgaReg = &hwp->SavedReg;
   VbeModeInfoBlock *modeInfo;
   VESAPtr pVesa;

   DPRINTF(PFX, "SaveHWState\n");

   pVesa = pI830->vesa;
   /* Make sure we save at least this information in case of failure. */
   VBEGetVBEMode(pVbe, &pVesa->stateMode);
   modeInfo = VBEGetModeInfo(pVbe, pVesa->stateMode);
   pVesa->savedScanlinePitch = 0;
   if (modeInfo) {
      if (VBE_MODE_GRAPHICS(modeInfo)) {
         VBEGetLogicalScanline(pVbe, &pVesa->savedScanlinePitch, NULL, NULL);
      }
      VBEFreeModeInfo(modeInfo);
   }

   vgaHWUnlock(hwp);
   vgaHWSave(pScrn, vgaReg, VGA_SR_FONTS);

   pVesa = pI830->vesa;
   /*
    * This save/restore method doesn't work for 845G BIOS, or for some
    * other platforms.  Enable it in all cases.
    */
   /*
    * KW: This may have been because of the behaviour I've found on my
    * board: The 'save' command actually modifies the interrupt
    * registers, turning off the irq & breaking the kernel module
    * behaviour.
    */
   if (!pI830->vbeRestoreWorkaround) {
      CARD16 imr = INREG16(IMR);
      CARD16 ier = INREG16(IER);
      CARD16 hwstam = INREG16(HWSTAM);

      if (!VBESaveRestore(pVbe, MODE_SAVE, &pVesa->state, &pVesa->stateSize,
			  &pVesa->statePage)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "SaveHWState: VBESaveRestore(MODE_SAVE) failed.\n");
	 return FALSE;
      }

      OUTREG16(IMR, imr);
      OUTREG16(IER, ier);
      OUTREG16(HWSTAM, hwstam);
   }

   pVesa->savedPal = VBESetGetPaletteData(pVbe, FALSE, 0, 256,
					     NULL, FALSE, FALSE);
   if (!pVesa->savedPal) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "SaveHWState: VBESetGetPaletteData(GET) failed.\n");
      return FALSE;
   }

   return TRUE;
}

static Bool
RestoreHWState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   vgaHWPtr hwp = VGAHWPTR(pScrn);
   vgaRegPtr vgaReg = &hwp->SavedReg;
   VESAPtr pVesa;
   Bool restored = FALSE;

   DPRINTF(PFX, "RestoreHWState\n");

   pVesa = pI830->vesa;

   /*
    * Workaround for text mode restoration with some flat panels.
    * Temporarily program a 640x480 mode before switching back to
    * text mode.
    */
   if (pVesa->useDefaultRefresh) {
      int mode = 0;

      switch (pScrn->depth) {
      case 8:
	 mode = 0x30;
	 break;
      case 15:
	 mode = 0x40;
	 break;
      case 16:
	 mode = 0x41;
	 break;
      case 24:
	 mode = 0x50;
	 break;
      }
      mode |= (1 << 15) | (1 << 14);
      I830VESASetVBEMode(pScrn, mode, NULL);
   }

   if (pVesa->state && pVesa->stateSize) {
      CARD16 imr = INREG16(IMR);
      CARD16 ier = INREG16(IER);
      CARD16 hwstam = INREG16(HWSTAM);

      /* Make a copy of the state.  Don't rely on it not being touched. */
      if (!pVesa->pstate) {
	 pVesa->pstate = xalloc(pVesa->stateSize);
	 if (pVesa->pstate)
	    memcpy(pVesa->pstate, pVesa->state, pVesa->stateSize);
      }
      restored = VBESaveRestore(pVbe, MODE_RESTORE, &pVesa->state,
				   &pVesa->stateSize, &pVesa->statePage);
      if (!restored) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "RestoreHWState: VBESaveRestore failed.\n");
      }
      /* Copy back */
      if (pVesa->pstate)
	 memcpy(pVesa->state, pVesa->pstate, pVesa->stateSize);

      OUTREG16(IMR, imr);
      OUTREG16(IER, ier);
      OUTREG16(HWSTAM, hwstam);
   }
   /* If that failed, restore the original mode. */
   if (!restored) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Setting the original video mode instead of restoring\n\t"
		 "the saved state\n");
      I830VESASetVBEMode(pScrn, pVesa->stateMode, NULL);
   }
   if (pVesa->savedScanlinePitch)
       VBESetLogicalScanline(pVbe, pVesa->savedScanlinePitch);

   if (pVesa->savedPal)
      VBESetGetPaletteData(pVbe, TRUE, 0, 256, pVesa->savedPal, FALSE, TRUE);

   vgaHWRestore(pScrn, vgaReg, VGA_SR_FONTS);
   vgaHWLock(hwp);
   return TRUE;
}

#ifndef USE_VBE
#define USE_VBE 1
#endif

static Bool
I830VESASetVBEMode(ScrnInfoPtr pScrn, int mode, VbeCRTCInfoBlock * block)
{
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "Setting mode 0x%.8x\n", mode);
#if USE_VBE
   return VBESetVBEMode(pI830->pVbe, mode, block);
#else
   {
      vbeInfoPtr pVbe = pI830->pVbe;
      pVbe->pInt10->num = 0x10;
      pVbe->pInt10->ax = 0x80 | (mode & 0x7f);
      xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
      pVbe->pInt10->ax = 0x0f00;
      xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
      if ((pVbe->pInt10->ax & 0x7f) == (mode & 0x7f))
	 return TRUE;
      else
	 return FALSE;
   }
#endif
}

static Bool
I830VESASetMode(ScrnInfoPtr pScrn, DisplayModePtr pMode)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   VbeModeInfoData *data;
   int mode, i;
   CARD32 planeA, planeB, temp;
   int refresh = 60;
#ifdef XF86DRI
   Bool didLock = FALSE;
#endif

   DPRINTF(PFX, "I830VESASetMode\n");

   data = (VbeModeInfoData *) pMode->Private;

   /* Always Enable Linear Addressing */
   mode = data->mode | (1 << 15) | (1 << 14);

#ifdef XF86DRI
   if (pI830->directRenderingEnabled && !pI830->LockHeld) {
      DRILock(screenInfo.screens[pScrn->scrnIndex], 0);
      pI830->LockHeld = 1;
      didLock = TRUE;
   }
#endif

#ifndef MODESWITCH_RESET_STATE
#define MODESWITCH_RESET_STATE 0
#endif
#if MODESWITCH_RESET_STATE
   ResetState(pScrn, TRUE);
#endif

   /* XXX Add macros for the various mode parameter bits. */

   if (pI830->vesa->useDefaultRefresh)
      mode &= ~(1 << 11);

   if (I830VESASetVBEMode(pScrn, mode, data->block) == FALSE) {
      if ((data->block && (mode & (1 << 11))) &&
	  I830VESASetVBEMode(pScrn, (mode & ~(1 << 11)), NULL) == TRUE) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Set VBE Mode rejected this modeline.\n\t"
		    "Trying standard mode instead!\n");
	 DPRINTF(PFX, "OOPS!\n");
	 xfree(data->block);
	 data->block = NULL;
	 data->mode &= ~(1 << 11);
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Set VBE Mode failed!\n");
	 return FALSE;
      }
   }

   /*
    * Test if the extendedRefresh BIOS function is supported.
    */
   if (pI830->useExtendedRefresh && !pI830->vesa->useDefaultRefresh &&
       (mode & (1 << 11)) && data && data->data && data->block) {
      if (!SetRefreshRate(pScrn, mode, 60)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "BIOS call 0x5f05 not supported, "
		    "setting refresh with VBE 3 method.\n");
	 pI830->useExtendedRefresh = FALSE;
	 pI830->enableDisplays = FALSE;
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Not using BIOS call 0x5f64 to enable displays.\n");
      }
   }

   /*
    * The BIOS may not set a scanline pitch that would require more video
    * memory than it's aware of.  We check for this later, and set it
    * explicitly if necessary.
    */
   if (data->data->XResolution != pScrn->displayWidth)
      VBESetLogicalScanline(pVbe, pScrn->displayWidth);

   if (pScrn->bitsPerPixel >= 8 && pI830->vbeInfo->Capabilities[0] & 0x01)
      VBESetGetDACPaletteFormat(pVbe, 8);

   /*
    * XXX This location of this isn't correct.
    *
    * Turn on the configured displays.  This has the effect of resetting
    * the default refresh rates to values that the configured displays
    * can handle.  This seems to be the safest way to make sure that this
    * happens.  When it's safe to set higher values, we do that after this.
    *
    * Note: When a DFP is connected to an 830, this causes the mode setting
    * to be trashed.  So, we don't do it on the 830.
    *
    * XXX Need to test an 830 with a LFP.
    */
   if (pI830->enableDisplays) {
      if (!SetDisplayDevices(pScrn, pI830->configuredDevices)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Failed to switch to configured display devices\n");
      }
   }

   /*
    * When it's OK to set better than default refresh rates, set them here.
    */
   if (pI830->useExtendedRefresh && !pI830->vesa->useDefaultRefresh &&
       (mode & (1 << 11)) && data && data->data && data->block) {
      refresh = SetRefreshRate(pScrn, mode, data->block->RefreshRate / 100);
      if (!refresh) {
	 refresh = 60;
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Failed to set refresh rate to %dHz.\n",
		    data->block->RefreshRate / 100);
      }
   }


   /* XXX Fix plane A with pipe A, and plane B with pipe B. */
   planeA = INREG(DSPACNTR);
   planeB = INREG(DSPBCNTR);

   pI830->planeEnabled[0] = ((planeA & DISPLAY_PLANE_ENABLE) != 0);
   pI830->planeEnabled[1] = ((planeB & DISPLAY_PLANE_ENABLE) != 0);

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Display plane A is %s.\n",
	      pI830->planeEnabled[0] ? "enabled" : "disabled");
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Display plane B is %s.\n",
	      pI830->planeEnabled[1] ? "enabled" : "disabled");

   /*
    * Sometimes it seems that no display planes are enabled at this point.
    * For mobile platforms pick the plane(s) connected to enabled pipes.
    * For others choose plane A.
    */
   if (!pI830->planeEnabled[0] && !pI830->planeEnabled[1]) {
      if (IS_MOBILE(pI830)) {
	 if ((pI830->pipeEnabled[0] &&
	      ((planeA & DISPPLANE_SEL_PIPE_MASK) == DISPPLANE_SEL_PIPE_A)) ||
	     (pI830->pipeEnabled[1] &&
	      ((planeA & DISPPLANE_SEL_PIPE_MASK) == DISPPLANE_SEL_PIPE_B))) {
	    pI830->planeEnabled[0] = TRUE;
	 }
	 if ((pI830->pipeEnabled[0] &&
	      ((planeB & DISPPLANE_SEL_PIPE_MASK) == DISPPLANE_SEL_PIPE_A)) ||
	     (pI830->pipeEnabled[1] &&
	      ((planeB & DISPPLANE_SEL_PIPE_MASK) == DISPPLANE_SEL_PIPE_B))) {
	    pI830->planeEnabled[1] = TRUE;
	 }
      } else {
	 pI830->planeEnabled[0] = TRUE;
      }
      if (pI830->planeEnabled[0]) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Enabling plane A.\n");
	 planeA |= DISPLAY_PLANE_ENABLE;
	 OUTREG(DSPACNTR, planeA);
	 /* flush the change. */
	 temp = INREG(DSPABASE);
	 OUTREG(DSPABASE, temp);
      }
      if (pI830->planeEnabled[1]) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Enabling plane B.\n");
	 planeB |= DISPLAY_PLANE_ENABLE;
	 OUTREG(DSPBCNTR, planeB);
	 /* flush the change. */
	 temp = INREG(DSPBADDR);
	 OUTREG(DSPBADDR, temp);
      }
   }

   /* XXX Plane C is ignored for now (overlay). */

   /*
    * Print out the PIPEACONF and PIPEBCONF registers.
    */
   temp = INREG(PIPEACONF);
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PIPEACONF is 0x%08lx\n", temp);
   if (IS_MOBILE(pI830)) {
      temp = INREG(PIPEBCONF);
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PIPEBCONF is 0x%08lx\n", temp);
   }

#if PRINT_MODE_INFO
   /* Print out some CRTC/display information. */
   temp = INREG(HTOTAL_A);
   ErrorF("Horiz active: %d, Horiz total: %d\n", temp & 0x7ff,
	  (temp >> 16) & 0xfff);
   temp = INREG(HBLANK_A);
   ErrorF("Horiz blank start: %d, Horiz blank end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(HSYNC_A);
   ErrorF("Horiz sync start: %d, Horiz sync end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(VTOTAL_A);
   ErrorF("Vert active: %d, Vert total: %d\n", temp & 0x7ff,
	  (temp >> 16) & 0xfff);
   temp = INREG(VBLANK_A);
   ErrorF("Vert blank start: %d, Vert blank end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(VSYNC_A);
   ErrorF("Vert sync start: %d, Vert sync end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(PIPEASRC);
   ErrorF("Image size: %dx%d (%dx%d)\n",
          (temp >> 16) & 0x7ff, temp & 0x7ff,
	  (((temp >> 16) & 0x7ff) + 1), ((temp & 0x7ff) + 1));
   ErrorF("Pixel multiply is %d\n", (planeA >> 20) & 0x3);
   temp = INREG(DSPABASE);
   ErrorF("Plane A start offset is %d\n", temp);
   temp = INREG(DSPASTRIDE);
   ErrorF("Plane A stride is %d bytes (%d pixels)\n", temp, temp / pI830->cpp);
#endif

   for (i = 0; i < MAX_DISPLAY_PIPES; i++) {
      CARD32 stridereg = i ? DSPBSTRIDE : DSPASTRIDE;
      CARD32 basereg = i ? DSPBBASE : DSPABASE;

      if (!pI830->planeEnabled[i])
	 continue;

      temp = INREG(stridereg);
      if (temp / pI830->cpp != pScrn->displayWidth) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Correcting plane %c stride (%d -> %d)\n", PIPE_NAME(i),
		    (int)(temp / pI830->cpp), pScrn->displayWidth);
	 OUTREG(stridereg, pScrn->displayWidth * pI830->cpp);
	 /* Trigger update */
	 temp = INREG(basereg);
	 OUTREG(basereg, temp);
      }
   }

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Mode bandwidth is %d Mpixel/s\n",
	      pMode->HDisplay * pMode->VDisplay * refresh / 1000000);

   {
      int maxBandwidth, bandwidthA, bandwidthB;

      if (GetModeSupport(pScrn, 0x80, 0x80, 0x80, 0x80,
			&maxBandwidth, &bandwidthA, &bandwidthB)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "maxBandwidth is %d Mbyte/s, "
		    "pipe bandwidths are %d Mbyte/s, %d Mbyte/s\n",
		    maxBandwidth, bandwidthA, bandwidthB);
      }
   }

   {
      int ret;

      ret = GetLFPCompMode(pScrn);
      if (ret != -1) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "LFP compensation mode: 0x%x\n", ret);
      }
   }

#if MODESWITCH_RESET_STATE
   ResetState(pScrn, TRUE);
   SetHWOperatingState(pScrn);
#endif

#ifdef XF86DRI
   if (pI830->directRenderingEnabled && didLock) {
      DRIUnlock(screenInfo.screens[pScrn->scrnIndex]);
      pI830->LockHeld = 0;
   }
#endif

   pScrn->vtSema = TRUE;
   return TRUE;
}

static void
InitRegisterRec(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   I830RegPtr i830Reg = &pI830->ModeReg;
   int i;

   for (i = 0; i < 8; i++)
      i830Reg->Fence[i] = 0;
}

/* Famous last words
 */
void
I830PrintErrorState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   ErrorF("pgetbl_ctl: 0x%lx pgetbl_err: 0x%lx\n",
	  INREG(PGETBL_CTL), INREG(PGE_ERR));

   ErrorF("ipeir: %lx iphdr: %lx\n", INREG(IPEIR), INREG(IPEHR));

   ErrorF("LP ring tail: %lx head: %lx len: %lx start %lx\n",
	  INREG(LP_RING + RING_TAIL),
	  INREG(LP_RING + RING_HEAD) & HEAD_ADDR,
	  INREG(LP_RING + RING_LEN), INREG(LP_RING + RING_START));

   ErrorF("eir: %x esr: %x emr: %x\n",
	  INREG16(EIR), INREG16(ESR), INREG16(EMR));

   ErrorF("instdone: %x instpm: %x\n", INREG16(INST_DONE), INREG8(INST_PM));

   ErrorF("memmode: %lx instps: %lx\n", INREG(MEMMODE), INREG(INST_PS));

   ErrorF("hwstam: %x ier: %x imr: %x iir: %x\n",
	  INREG16(HWSTAM), INREG16(IER), INREG16(IMR), INREG16(IIR));
}

#ifdef I830DEBUG
static void
dump_DSPACNTR(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned int tmp;

   /* Display A Control */
   tmp = INREG(0x70180);
   ErrorF("Display A Plane Control Register (0x%.8x)\n", tmp);

   if (tmp & BIT(31))
      ErrorF("   Display Plane A (Primary) Enable\n");
   else
      ErrorF("   Display Plane A (Primary) Disabled\n");

   if (tmp & BIT(30))
      ErrorF("   Display A pixel data is gamma corrected\n");
   else
      ErrorF("   Display A pixel data bypasses gamma correction logic (default)\n");

   switch ((tmp & 0x3c000000) >> 26) {	/* bit 29:26 */
   case 0x00:
   case 0x01:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
   case 0x02:
      ErrorF("   8-bpp Indexed\n");
      break;
   case 0x04:
      ErrorF("   15-bit (5-5-5) pixel format (Targa compatible)\n");
      break;
   case 0x05:
      ErrorF("   16-bit (5-6-5) pixel format (XGA compatible)\n");
      break;
   case 0x06:
      ErrorF("   32-bit format (X:8:8:8)\n");
      break;
   case 0x07:
      ErrorF("   32-bit format (8:8:8:8)\n");
      break;
   default:
      ErrorF("   Unknown - Invalid register value maybe?\n");
   }

   if (tmp & BIT(25))
      ErrorF("   Stereo Enable\n");
   else
      ErrorF("   Stereo Disable\n");

   if (tmp & BIT(24))
      ErrorF("   Display A, Pipe B Select\n");
   else
      ErrorF("   Display A, Pipe A Select\n");

   if (tmp & BIT(22))
      ErrorF("   Source key is enabled\n");
   else
      ErrorF("   Source key is disabled\n");

   switch ((tmp & 0x00300000) >> 20) {	/* bit 21:20 */
   case 0x00:
      ErrorF("   No line duplication\n");
      break;
   case 0x01:
      ErrorF("   Line/pixel Doubling\n");
      break;
   case 0x02:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
   }

   if (tmp & BIT(18))
      ErrorF("   Stereo output is high during second image\n");
   else
      ErrorF("   Stereo output is high during first image\n");
}

static void
dump_DSPBCNTR(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned int tmp;

   /* Display B/Sprite Control */
   tmp = INREG(0x71180);
   ErrorF("Display B/Sprite Plane Control Register (0x%.8x)\n", tmp);

   if (tmp & BIT(31))
      ErrorF("   Display B/Sprite Enable\n");
   else
      ErrorF("   Display B/Sprite Disable\n");

   if (tmp & BIT(30))
      ErrorF("   Display B pixel data is gamma corrected\n");
   else
      ErrorF("   Display B pixel data bypasses gamma correction logic (default)\n");

   switch ((tmp & 0x3c000000) >> 26) {	/* bit 29:26 */
   case 0x00:
   case 0x01:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
   case 0x02:
      ErrorF("   8-bpp Indexed\n");
      break;
   case 0x04:
      ErrorF("   15-bit (5-5-5) pixel format (Targa compatible)\n");
      break;
   case 0x05:
      ErrorF("   16-bit (5-6-5) pixel format (XGA compatible)\n");
      break;
   case 0x06:
      ErrorF("   32-bit format (X:8:8:8)\n");
      break;
   case 0x07:
      ErrorF("   32-bit format (8:8:8:8)\n");
      break;
   default:
      ErrorF("   Unknown - Invalid register value maybe?\n");
   }

   if (tmp & BIT(25))
      ErrorF("   Stereo is enabled and both start addresses are used in a two frame sequence\n");
   else
      ErrorF("   Stereo disable and only a single start address is used\n");

   if (tmp & BIT(24))
      ErrorF("   Display B/Sprite, Pipe B Select\n");
   else
      ErrorF("   Display B/Sprite, Pipe A Select\n");

   if (tmp & BIT(22))
      ErrorF("   Sprite source key is enabled\n");
   else
      ErrorF("   Sprite source key is disabled (default)\n");

   switch ((tmp & 0x00300000) >> 20) {	/* bit 21:20 */
   case 0x00:
      ErrorF("   No line duplication\n");
      break;
   case 0x01:
      ErrorF("   Line/pixel Doubling\n");
      break;
   case 0x02:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
   }

   if (tmp & BIT(18))
      ErrorF("   Stereo output is high during second image\n");
   else
      ErrorF("   Stereo output is high during first image\n");

   if (tmp & BIT(15))
      ErrorF("   Alpha transfer mode enabled\n");
   else
      ErrorF("   Alpha transfer mode disabled\n");

   if (tmp & BIT(0))
      ErrorF("   Sprite is above overlay\n");
   else
      ErrorF("   Sprite is above display A (default)\n");
}

void
I830_dump_registers(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned int i;

   ErrorF("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");

   dump_DSPACNTR(pScrn);
   dump_DSPBCNTR(pScrn);

   ErrorF("0x71400 == 0x%.8x\n", INREG(0x71400));
   ErrorF("0x70008 == 0x%.8x\n", INREG(0x70008));
   for (i = 0x71410; i <= 0x71428; i += 4)
      ErrorF("0x%x == 0x%.8x\n", i, INREG(i));

   ErrorF("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");
}
#endif

static Bool
I830BIOSScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
{
   ScrnInfoPtr pScrn;
   vgaHWPtr hwp;
   I830Ptr pI830;
   VisualPtr visual;
#ifdef XF86DRI
   Bool driDisabled;
#endif

   pScrn = xf86Screens[pScreen->myNum];
   pI830 = I830PTR(pScrn);
   hwp = VGAHWPTR(pScrn);

   pI830->starting = TRUE;

   /*
    * If we're changing the BIOS's view of the video memory size, do that
    * first, then re-initialise the VBE information.
    */
   pI830->pVbe = VBEInit(NULL, pI830->pEnt->index);
   if (!TweakMemorySize(pScrn, pI830->newBIOSMemSize,FALSE))
       SetBIOSMemSize(pScrn, pI830->newBIOSMemSize);
   if (!pI830->pVbe)
      return FALSE;
   pI830->vbeInfo = VBEGetVBEInfo(pI830->pVbe);

   miClearVisualTypes();
   if (!xf86SetDefaultVisual(pScrn, -1))
      return FALSE;
   if (pScrn->bitsPerPixel > 8) {
      if (!miSetVisualTypes(pScrn->depth, TrueColorMask,
			    pScrn->rgbBits, TrueColor))
	 return FALSE;
   } else {
      if (!miSetVisualTypes(pScrn->depth,
			    miGetDefaultVisualMask(pScrn->depth),
			    pScrn->rgbBits, pScrn->defaultVisual))
	 return FALSE;
   }
   if (!miSetPixmapDepths())
      return FALSE;

#ifdef I830_XV
   pI830->XvEnabled = !pI830->XvDisabled;
   if (pI830->XvEnabled) {
      if (pI830->noAccel || pI830->StolenOnly) {
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Xv is disabled because it "
		    "needs 2D accel and AGPGART.\n");
	 pI830->XvEnabled = FALSE;
      }
   }
#else
   pI830->XvEnabled = FALSE;
#endif

   I830ResetAllocations(pScrn, 0);

   I830Allocate2DMemory(pScrn, ALLOC_INITIAL);

   if (!pI830->noAccel) {
      if (pI830->LpRing.mem.Size == 0) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     "Disabling acceleration because the ring buffer "
		      "allocation failed.\n");
	   pI830->noAccel = TRUE;
      }
   }

   if (!pI830->SWCursor) {
      if (pI830->CursorMem.Size == 0) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     "Disabling HW cursor because the cursor memory "
		      "allocation failed.\n");
	   pI830->SWCursor = TRUE;
      }
   }

#ifdef I830_XV
   if (pI830->XvEnabled) {
      if (pI830->noAccel) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Disabling Xv because it "
		    "needs 2D acceleration.\n");
	 pI830->XvEnabled = FALSE;
      }
      if (pI830->OverlayMem.Physical == 0) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     "Disabling Xv because the overlay register buffer "
		      "allocation failed.\n");
	 pI830->XvEnabled = FALSE;
      }
   }
#endif

   InitRegisterRec(pScrn);

#ifdef XF86DRI
   /*
    * pI830->directRenderingDisabled is set once in PreInit.  Reinitialise
    * pI830->directRenderingEnabled based on it each generation.
    */
   pI830->directRenderingEnabled = !pI830->directRenderingDisabled;
   /*
    * Setup DRI after visuals have been established, but before fbScreenInit
    * is called.   fbScreenInit will eventually call into the drivers
    * InitGLXVisuals call back.
    */

   if (pI830->directRenderingEnabled) {
      if (pI830->noAccel || pI830->SWCursor || pI830->StolenOnly) {
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "DRI is disabled because it "
		    "needs HW cursor, 2D accel and AGPGART.\n");
	 pI830->directRenderingEnabled = FALSE;
      }
   }

   driDisabled = !pI830->directRenderingEnabled;

   if (pI830->directRenderingEnabled)
      pI830->directRenderingEnabled = I830DRIScreenInit(pScreen);

   if (pI830->directRenderingEnabled) {
      pI830->directRenderingEnabled =
	 I830Allocate3DMemory(pScrn,
			      pI830->disableTiling ? ALLOC_NO_TILING : 0);
      if (!pI830->directRenderingEnabled)
	  I830DRICloseScreen(pScreen);
   }

#else
   pI830->directRenderingEnabled = FALSE;
#endif

   /*
    * After the 3D allocations have been done, see if there's any free space
    * that can be added to the framebuffer allocation.
    */
   I830Allocate2DMemory(pScrn, 0);

   DPRINTF(PFX, "assert(if(!I830DoPoolAllocation(pScrn, pI830->StolenPool)))\n");
   if (!I830DoPoolAllocation(pScrn, &(pI830->StolenPool)))
      return FALSE;

   DPRINTF(PFX, "assert( if(!I830FixupOffsets(pScrn)) )\n");
   if (!I830FixupOffsets(pScrn))
      return FALSE;

#ifdef XF86DRI
   if (pI830->directRenderingEnabled) {
      I830SetupMemoryTiling(pScrn);
      pI830->directRenderingEnabled = I830DRIDoMappings(pScreen);
   }
#endif

   DPRINTF(PFX, "assert( if(!I830MapMem(pScrn)) )\n");
   if (!I830MapMem(pScrn))
      return FALSE;

   pScrn->memPhysBase = (unsigned long)pI830->FbBase;
   pScrn->fbOffset = pI830->FrontBuffer.Start;

   pI830->xoffset = (pScrn->fbOffset / pI830->cpp) % pScrn->displayWidth;
   pI830->yoffset = (pScrn->fbOffset / pI830->cpp) / pScrn->displayWidth;

   vgaHWSetMmioFuncs(hwp, pI830->MMIOBase, 0);
   vgaHWGetIOBase(hwp);
   DPRINTF(PFX, "assert( if(!vgaHWMapMem(pScrn)) )\n");
   if (!vgaHWMapMem(pScrn))
      return FALSE;

   /* Clear SavedReg */
   memset(&pI830->SavedReg, 0, sizeof(pI830->SavedReg));

   DPRINTF(PFX, "assert( if(!I830BIOSEnterVT(scrnIndex, 0)) )\n");
   if (!I830BIOSEnterVT(scrnIndex, 0))
      return FALSE;

   DPRINTF(PFX, "assert( if(!fbScreenInit(pScreen, ...) )\n");
   if (!fbScreenInit(pScreen, pI830->FbBase + pScrn->fbOffset,
		     pScrn->virtualX, pScrn->virtualY,
		     pScrn->xDpi, pScrn->yDpi,
		     pScrn->displayWidth, pScrn->bitsPerPixel))
      return FALSE;

   if (pScrn->bitsPerPixel > 8) {
      /* Fixup RGB ordering */
      visual = pScreen->visuals + pScreen->numVisuals;
      while (--visual >= pScreen->visuals) {
	 if ((visual->class | DynamicClass) == DirectColor) {
	    visual->offsetRed = pScrn->offset.red;
	    visual->offsetGreen = pScrn->offset.green;
	    visual->offsetBlue = pScrn->offset.blue;
	    visual->redMask = pScrn->mask.red;
	    visual->greenMask = pScrn->mask.green;
	    visual->blueMask = pScrn->mask.blue;
	 }
      }
   }

   fbPictureInit(pScreen, 0, 0);

   xf86SetBlackWhitePixels(pScreen);

#if 1
   I830DGAInit(pScreen);
#endif

   DPRINTF(PFX,
	   "assert( if(!xf86InitFBManager(pScreen, &(pI830->FbMemBox))) )\n");
   if (!xf86InitFBManager(pScreen, &(pI830->FbMemBox))) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Failed to init memory manager\n");
      return FALSE;
   }

   if (!pI830->noAccel) {
      if (!I830AccelInit(pScreen)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Hardware acceleration initialization failed\n");
      }
   }

   miInitializeBackingStore(pScreen);
   xf86SetBackingStore(pScreen);
   xf86SetSilkenMouse(pScreen);
   miDCInitialize(pScreen, xf86GetPointerScreenFuncs());

   if (!pI830->SWCursor) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Initializing HW Cursor\n");
      if (!I830CursorInit(pScreen))
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Hardware cursor initialization failed\n");
   } else
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Initializing SW Cursor!\n");

   DPRINTF(PFX, "assert( if(!miCreateDefColormap(pScreen)) )\n");
   if (!miCreateDefColormap(pScreen))
      return FALSE;

   DPRINTF(PFX, "assert( if(!xf86HandleColormaps(pScreen, ...)) )\n");
   if (!xf86HandleColormaps(pScreen, 256, 8, I830LoadPalette, 0,
			    CMAP_RELOAD_ON_MODE_SWITCH)) {
      return FALSE;
   }

   xf86DPMSInit(pScreen, I830DisplayPowerManagementSet, 0);

#ifdef I830_XV
   /* Init video */
   if (pI830->XvEnabled)
      I830InitVideo(pScreen);
#endif

#ifdef XF86DRI
   if (pI830->directRenderingEnabled) {
      pI830->directRenderingEnabled = I830DRIFinishScreenInit(pScreen);
   }
#endif

#ifdef XF86DRI
   if (pI830->directRenderingEnabled) {
      pI830->directRenderingOpen = TRUE;
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "direct rendering: Enabled\n");
      /* Setup 3D engine */
      I830EmitInvarientState(pScrn);
   } else {
      if (driDisabled)
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "direct rendering: Disabled\n");
      else
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "direct rendering: Failed\n");
   }
#else
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "direct rendering: Not available\n");
#endif

   pScreen->SaveScreen = I830BIOSSaveScreen;
   pI830->CloseScreen = pScreen->CloseScreen;
   pScreen->CloseScreen = I830BIOSCloseScreen;

   if (serverGeneration == 1)
      xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
#if 0
#ifdef I830DEBUG
   I830_dump_registers(pScrn);
#endif
#endif

   pI830->starting = FALSE;
   pI830->closing = FALSE;
   pI830->suspended = FALSE;
   return TRUE;
}

static void
I830BIOSAdjustFrame(int scrnIndex, int x, int y, int flags)
{
   ScrnInfoPtr pScrn;
   I830Ptr pI830;
   vbeInfoPtr pVbe;

   pScrn = xf86Screens[scrnIndex];
   pI830 = I830PTR(pScrn);
   pVbe = pI830->pVbe;

   DPRINTF(PFX, "I830BIOSAdjustFrame: y = %d (+ %d), x = %d (+ %d)\n",
	   x, pI830->xoffset, y, pI830->yoffset);

   VBESetDisplayStart(pVbe, x + pI830->xoffset, y + pI830->yoffset, TRUE);
}

static void
I830BIOSFreeScreen(int scrnIndex, int flags)
{
   I830BIOSFreeRec(xf86Screens[scrnIndex]);
   if (xf86LoaderCheckSymbol("vgaHWFreeHWRec"))
      vgaHWFreeHWRec(xf86Screens[scrnIndex]);
}

#ifndef SAVERESTORE_HWSTATE
#define SAVERESTORE_HWSTATE 0
#endif

#if SAVERESTORE_HWSTATE
static void
SaveHWOperatingState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   I830RegPtr save = &pI830->SavedReg;

   DPRINTF(PFX, "SaveHWOperatingState\n");

   return;
}

static void
RestoreHWOperatingState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   I830RegPtr save = &pI830->SavedReg;

   DPRINTF(PFX, "RestoreHWOperatingState\n");

   return;
}
#endif

static void
I830BIOSLeaveVT(int scrnIndex, int flags)
{
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "Leave VT\n");

#ifdef XF86DRI
   if (pI830->directRenderingOpen) {
      DPRINTF(PFX, "calling dri lock\n");
      DRILock(screenInfo.screens[scrnIndex], 0);
      pI830->LockHeld = 1;
   }
#endif

#if SAVERESTORE_HWSTATE
   if (!pI830->closing)
      SaveHWOperatingState(pScrn);
#endif

   ResetState(pScrn, TRUE);
   RestoreHWState(pScrn);
   RestoreBIOSMemSize(pScrn);
   I830UnbindGARTMemory(pScrn);
   if (pI830->AccelInfoRec)
      pI830->AccelInfoRec->NeedToSync = FALSE;
}

/*
 * This gets called when gaining control of the VT, and from ScreenInit().
 */
static Bool
I830BIOSEnterVT(int scrnIndex, int flags)
{
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "Enter VT\n");

   if (!I830BindGARTMemory(pScrn))
      return FALSE;

   CheckInheritedState(pScrn);
   if (!TweakMemorySize(pScrn, pI830->newBIOSMemSize,FALSE))
       SetBIOSMemSize(pScrn, pI830->newBIOSMemSize);

   /*
    * Only save state once per server generation since that's what most
    * drivers do.  Could change this to save state at each VT enter.
    */
   if (pI830->SaveGeneration != serverGeneration) {
      pI830->SaveGeneration = serverGeneration;
      SaveHWState(pScrn);
   }
   ResetState(pScrn, FALSE);
   SetHWOperatingState(pScrn);

#if 1
   /* Clear the framebuffer */
   memset(pI830->FbBase + pScrn->fbOffset, 0,
	  pScrn->virtualY * pScrn->displayWidth * pI830->cpp);
#endif

   if (!I830VESASetMode(pScrn, pScrn->currentMode))
      return FALSE;
#ifdef I830_XV
   I830VideoSwitchModeAfter(pScrn, pScrn->currentMode);
#endif

   ResetState(pScrn, TRUE);
   SetHWOperatingState(pScrn);

   pScrn->AdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);

#if SAVERESTORE_HWSTATE
   RestoreHWOperatingState(pScrn);
#endif

#ifdef XF86DRI
   if (pI830->directRenderingEnabled) {
      if (!pI830->starting) {
	 I830EmitInvarientState(pScrn);
	 I830RefreshRing(pScrn);
	 I830Sync(pScrn);
	 DO_RING_IDLE();

	 DPRINTF(PFX, "calling dri unlock\n");
	 DRIUnlock(screenInfo.screens[scrnIndex]);
      }
      pI830->LockHeld = 0;
   }
#endif

   return TRUE;
}

static Bool
I830BIOSSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
{

   int _head;
   int _tail;
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);
   int ret = TRUE;

   DPRINTF(PFX, "I830BIOSSwitchMode: mode == %p\n", mode);

   /* Stops head pointer freezes for 845G */
   if (!pI830->noAccel && (1 || IS_845G(pI830))) {
      do {
	 _head = INREG(LP_RING + RING_HEAD) & I830_HEAD_MASK;
	 _tail = INREG(LP_RING + RING_TAIL) & I830_TAIL_MASK;
	 DELAY(1000);
      } while (_head != _tail);
   }

#ifndef BINDUNBIND
#define BINDUNBIND 0
#endif
#if BINDUNBIND
   I830UnbindGARTMemory(pScrn);
#endif
#ifdef I830_XV
   /* Give the video overlay code a chance to see the new mode. */
   I830VideoSwitchModeBefore(pScrn, mode);
#endif
   if (!I830VESASetMode(pScrn, mode))
      ret = FALSE;
#ifdef I830_XV
   /* Give the video overlay code a chance to see the new mode. */
   I830VideoSwitchModeAfter(pScrn, mode);
#endif
#if BINDUNBIND
   I830BindGARTMemory(pScrn);
#endif

   return ret;
}

static Bool
I830BIOSSaveScreen(ScreenPtr pScreen, int mode)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   Bool on = xf86IsUnblank(mode);
   CARD32 temp, ctrl, base, i;

   DPRINTF(PFX, "I830BIOSSaveScreen: %d, on is %s\n", mode, BOOLTOSTRING(on));

   if (pScrn->vtSema) {
      for (i = 0; i < MAX_DISPLAY_PIPES; i++) {
	 if (i == 0) {
	    ctrl = DSPACNTR;
	    base = DSPABASE;
	 } else {
	    ctrl = DSPBCNTR;
	    base = DSPBADDR;
	 }
	 if (pI830->planeEnabled[i]) {
	    temp = INREG(ctrl);
	    if (on)
	       temp |= DISPLAY_PLANE_ENABLE;
	    else
	       temp &= ~DISPLAY_PLANE_ENABLE;
	    OUTREG(ctrl, temp);
	    /* Flush changes */
	    temp = INREG(base);
	    OUTREG(base, temp);
	 }
      }

      if (pI830->CursorInfoRec && !pI830->SWCursor && pI830->cursorOn) {
	 if (on)
	    pI830->CursorInfoRec->ShowCursor(pScrn);
	 else
	    pI830->CursorInfoRec->HideCursor(pScrn);
	 pI830->cursorOn = TRUE;
      }
   }
   return TRUE;
}

/* Use the VBE version when available. */
static void
I830DisplayPowerManagementSet(ScrnInfoPtr pScrn, int PowerManagementMode,
			      int flags)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;

   if (xf86LoaderCheckSymbol("VBEDPMSSet")) {
      VBEDPMSSet(pVbe, PowerManagementMode);
   } else {
      pVbe->pInt10->num = 0x10;
      pVbe->pInt10->ax = 0x4f10;
      pVbe->pInt10->bx = 0x01;

      switch (PowerManagementMode) {
      case DPMSModeOn:
	 break;
      case DPMSModeStandby:
	 pVbe->pInt10->bx |= 0x0100;
	 break;
      case DPMSModeSuspend:
	 pVbe->pInt10->bx |= 0x0200;
	 break;
      case DPMSModeOff:
	 pVbe->pInt10->bx |= 0x0400;
	 break;
      }
      xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   }
}

static Bool
I830BIOSCloseScreen(int scrnIndex, ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);
   XAAInfoRecPtr infoPtr = pI830->AccelInfoRec;

   pI830->closing = TRUE;
#ifdef XF86DRI
   if (pI830->directRenderingOpen) {
      pI830->directRenderingOpen = FALSE;
      I830DRICloseScreen(pScreen);
   }
#endif

   if (pScrn->vtSema == TRUE) {
      I830BIOSLeaveVT(scrnIndex, 0);
   }

   DPRINTF(PFX, "\nUnmapping memory\n");
   I830UnmapMem(pScrn);
   vgaHWUnmapMem(pScrn);

   if (pI830->ScanlineColorExpandBuffers) {
      xfree(pI830->ScanlineColorExpandBuffers);
      pI830->ScanlineColorExpandBuffers = 0;
   }

   if (infoPtr) {
      if (infoPtr->ScanlineColorExpandBuffers)
	 xfree(infoPtr->ScanlineColorExpandBuffers);
      XAADestroyInfoRec(infoPtr);
      pI830->AccelInfoRec = NULL;
   }

   if (pI830->CursorInfoRec) {
      xf86DestroyCursorInfoRec(pI830->CursorInfoRec);
      pI830->CursorInfoRec = 0;
   }

   xf86GARTCloseScreen(scrnIndex);

   pScrn->vtSema = FALSE;
   pI830->closing = FALSE;
   pScreen->CloseScreen = pI830->CloseScreen;
   return (*pScreen->CloseScreen) (scrnIndex, pScreen);
}

static ModeStatus
I830ValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
{
   if (mode->Flags & V_INTERLACE) {
      if (verbose) {
	 xf86DrvMsg(scrnIndex, X_PROBED,
		    "Removing interlaced mode \"%s\"\n", mode->name);
      }
      return MODE_BAD;
   }
   return MODE_OK;
}

#ifndef SUSPEND_SLEEP
#define SUSPEND_SLEEP 0
#endif
#ifndef RESUME_SLEEP
#define RESUME_SLEEP 0
#endif

/*
 * This function is only required if we need to do anything differently from
 * DoApmEvent() in common/xf86PM.c, including if we want to see events other
 * than suspend/resume.
 */
static Bool
I830PMEvent(int scrnIndex, pmEvent event, Bool undo)
{
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "Enter VT, event %d, undo: %s\n", event, BOOLTOSTRING(undo));

   switch(event) {
   case XF86_APM_SYS_SUSPEND:
   case XF86_APM_CRITICAL_SUSPEND: /*do we want to delay a critical suspend?*/
   case XF86_APM_USER_SUSPEND:
   case XF86_APM_SYS_STANDBY:
   case XF86_APM_USER_STANDBY:
      if (!undo && !pI830->suspended) {
	 pScrn->LeaveVT(scrnIndex, 0);
	 pI830->suspended = TRUE;
	 sleep(SUSPEND_SLEEP);
      } else if (undo && pI830->suspended) {
	 sleep(RESUME_SLEEP);
	 pScrn->EnterVT(scrnIndex, 0);
	 pI830->suspended = FALSE;
      }
      break;
   case XF86_APM_STANDBY_RESUME:
   case XF86_APM_NORMAL_RESUME:
   case XF86_APM_CRITICAL_RESUME:
      if (pI830->suspended) {
	 sleep(RESUME_SLEEP);
	 pScrn->EnterVT(scrnIndex, 0);
	 pI830->suspended = FALSE;
	 /*
	  * Turn the screen saver off when resuming.  This seems to be
	  * needed to stop xscreensaver kicking in (when used).
	  *
	  * XXX DoApmEvent() should probably call this just like
	  * xf86VTSwitch() does.  Maybe do it here only in 4.2
	  * compatibility mode.
	  */
	 SaveScreens(SCREEN_SAVER_FORCER, ScreenSaverReset);
      }
      break;
   default:
      ErrorF("I830PMEvent: received APM event %d\n", event);
   }
   return TRUE;
}

void
I830InitpScrn(ScrnInfoPtr pScrn)
{
   pScrn->PreInit = I830BIOSPreInit;
   pScrn->ScreenInit = I830BIOSScreenInit;
   pScrn->SwitchMode = I830BIOSSwitchMode;
   pScrn->AdjustFrame = I830BIOSAdjustFrame;
   pScrn->EnterVT = I830BIOSEnterVT;
   pScrn->LeaveVT = I830BIOSLeaveVT;
   pScrn->FreeScreen = I830BIOSFreeScreen;
   pScrn->ValidMode = I830ValidMode;
   pScrn->PMEvent = I830PMEvent;
}


@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_driver.c,v 1.7 2002/01/08 18:59:29 dawes Exp $ */
d5 1
d23 1
a23 1
ATI, VA LINUX SYSTEMS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
d28 1
d30 12
a41 1
**************************************************************************/
d43 4
a46 1
/* Author: Jeff Hartmann <jhartmann@@valinux.com>
d49 3
a51 2
/* Heavily based on the VESA driver written by:
 * Paulo César Pereira de Andrade <pcpa@@conectiva.com.br>
d94 1
a94 1
 *          suspect this is a BIOS bug (hence the 1280x1024@@85Hz case).
d106 37
d157 1
a157 1
#include "miscstruct.h"
d161 1
d163 1
a163 1
#include "i810.h"
d173 1
d175 5
a179 2
   { PCI_CHIP_I830_M,	  "i830"},
   { -1, NULL }
d183 5
a187 2
   { PCI_CHIP_I830_M,	  PCI_CHIP_I830_M,	       RES_SHARED_VGA },
   { -1, -1, RES_UNDEFINED }
d190 19
d210 11
a220 7
   { OPTION_NOACCEL, "NoAccel", OPTV_BOOLEAN, {0}, FALSE },
   { OPTION_SW_CURSOR, "SWcursor", OPTV_BOOLEAN, {0}, FALSE },
   { OPTION_CACHE_LINES, "CacheLines", OPTV_INTEGER, {0}, FALSE},
   { OPTION_DRI, "DRI", OPTV_BOOLEAN, {0}, TRUE},
   { OPTION_STRETCH, "Stretch", OPTV_BOOLEAN, {0}, FALSE},
   { OPTION_CENTER, "Center", OPTV_BOOLEAN, {0}, FALSE},
   { -1, NULL, OPTV_NONE, {0}, FALSE}
d222 1
d224 8
a232 9
static VBEInfoBlock *I830VESAGetVBEInfo(ScrnInfoPtr pScrn);
static Bool I830BIOSGetRec(ScrnInfoPtr pScrn);
static void I830BIOSFreeRec(ScrnInfoPtr pScrn);
static void SaveFonts(ScrnInfoPtr pScrn);
static void RestoreFonts(ScrnInfoPtr pScrn);
static Bool I830VESASetMode(ScrnInfoPtr pScrn, DisplayModePtr pMode);
static void I830DisplayPowerManagementSet(ScrnInfoPtr pScrn,
					  int PowerManagementMode,
					  int flags);
d235 20
a254 16
void DPRINTF_stub (const char *filename,int line,const char *function,const char *fmt, ...) {
	va_list ap;
	fprintf (stderr,
			 "\n##############################################\n"
			 "*** In function %s, on line %d, in file %s ***\n",
			 function,line,filename);
	va_start (ap,fmt);
	vfprintf (stderr,fmt,ap);
	va_end (ap);
	fprintf (stderr,
			 "##############################################\n\n");
	fflush (stderr);
}
#else	/* #ifdef I830DEBUG */
void DPRINTF_stub (const char *filename,int line,const char *function,const char *fmt, ...) {
	/* do nothing */
d256 1
a256 1
#endif	/* #ifdef I830DEBUG */
d258 1
d264 3
a266 2
   for(i = 0; I830BIOSPciChipsets[i].PCIid > 0; i++) {
      if(chipid == I830BIOSPciChipsets[i].PCIid) return I830BIOSOptions;
a270 162
static VBEInfoBlock *
I830VESAGetVBEInfo(ScrnInfoPtr pScrn)
{
   I810Ptr pI810;
   VESAPtr pVesa;
   VBEInfoBlock *block = NULL;
   int i, pStr, pModes;
   char *str;
   CARD16 major, minor, *modes;

   pI810 = I810PTR(pScrn);
   pVesa = pI810->vesa;

   bzero(pVesa->block, sizeof(VBEInfoBlock));

   pVesa->block[0] = 'V';
   pVesa->block[1] = 'B';
   pVesa->block[2] = 'E';
   pVesa->block[3] = '2';

   pVesa->pInt->num = 0x10;
   pVesa->pInt->ax = 0x4f00;
   pVesa->pInt->es = SEG_ADDR(pVesa->page);
   pVesa->pInt->di = SEG_OFF(pVesa->page);
   xf86ExecX86int10_wrapper(pVesa->pInt, pScrn);

   if(pVesa->pInt->ax != 0x4f) return NULL;

   block = xcalloc(sizeof(VBEInfoBlock), 1);
   block->VESASignature[0] = pVesa->block[0];
   block->VESASignature[1] = pVesa->block[1];
   block->VESASignature[2] = pVesa->block[2];
   block->VESASignature[3] = pVesa->block[3];

   block->VESAVersion = *(CARD16*)(pVesa->block + 4);
   major = (unsigned)block->VESAVersion >> 8;
   minor = block->VESAVersion & 0xff;

   pStr = *(CARD32*)(pVesa->block + 6);
   str = xf86int10Addr(pVesa->pInt, FARP(pStr));
   block->OEMStringPtr = strdup(str);

   block->Capabilities[0] = pVesa->block[10];
   block->Capabilities[1] = pVesa->block[11];
   block->Capabilities[2] = pVesa->block[12];
   block->Capabilities[3] = pVesa->block[13];

   pModes = *(CARD32*)(pVesa->block + 14);
   modes = xf86int10Addr(pVesa->pInt, FARP(pModes));
   i = 0;
   while(modes[i] != 0xffff) i++;
   block->VideoModePtr = xalloc(sizeof(CARD16) * i + 1);
   memcpy(block->VideoModePtr, modes, sizeof(CARD16) * i);
   block->VideoModePtr[i] = 0xffff;

   block->TotalMemory = *(CARD16*)(pVesa->block + 18);

   if(major < 2) memcpy(&block->OemSoftwareRev, pVesa->block + 20, 236);
   else {
      block->OemSoftwareRev = *(CARD16*)(pVesa->block + 20);
      pStr = *(CARD32*)(pVesa->block + 22);
      str = xf86int10Addr(pVesa->pInt, FARP(pStr));
      block->OemVendorNamePtr = strdup(str);
      pStr = *(CARD32*)(pVesa->block + 26);
      str = xf86int10Addr(pVesa->pInt, FARP(pStr));
      block->OemProductNamePtr = strdup(str);
      pStr = *(CARD32*)(pVesa->block + 30);
      str = xf86int10Addr(pVesa->pInt, FARP(pStr));
      block->OemProductRevPtr = strdup(str);
      memcpy(&block->Reserved, pVesa->block + 34, 222);
      memcpy(&block->OemData, pVesa->block + 256, 256);
   }

   return block;
}

ModeInfoBlock * I830VESAGetModeInfo (ScrnInfoPtr pScrn,int mode)
{
   I810Ptr pI810;
   VESAPtr pVesa;
   ModeInfoBlock *block = NULL;

   pI810 = I810PTR (pScrn);
   pVesa = pI810->vesa;

   bzero (pVesa->block,sizeof (ModeInfoBlock));

   pVesa->pInt->num = 0x10;
   pVesa->pInt->ax = 0x4f01;
   pVesa->pInt->cx = mode;
   pVesa->pInt->es = SEG_ADDR (pVesa->page);
   pVesa->pInt->di = SEG_OFF (pVesa->page);
   xf86ExecX86int10_wrapper (pVesa->pInt,pScrn);
   if (pVesa->pInt->ax != 0x4f) return (NULL);

   block = xcalloc (sizeof (ModeInfoBlock),1);

   block->ModeAttributes = *(CARD16 *) pVesa->block;
   block->WinAAttributes = pVesa->block[2];
   block->WinBAttributes = pVesa->block[3];
   block->WinGranularity = *(CARD16 *) (pVesa->block + 4);
   block->WinSize = *(CARD16 *) (pVesa->block + 6);
   block->WinASegment = *(CARD16 *) (pVesa->block + 8);
   block->WinBSegment = *(CARD16 *) (pVesa->block + 10);
   block->WinFuncPtr = *(CARD32 *) (pVesa->block + 12);
   block->BytesPerScanline = *(CARD16 *) (pVesa->block + 16);

   /* mandatory information for VBE 1.2 and above */
   block->XResolution = *(CARD16 *) (pVesa->block + 18);
   block->YResolution = *(CARD16 *) (pVesa->block + 20);
   block->XCharSize = pVesa->block[22];
   block->YCharSize = pVesa->block[23];
   block->NumberOfPlanes = pVesa->block[24];
   block->BitsPerPixel = pVesa->block[25];
   block->NumberOfBanks = pVesa->block[26];
   block->MemoryModel = pVesa->block[27];
   block->BankSize = pVesa->block[28];
   block->NumberOfImages = pVesa->block[29];
   block->Reserved = pVesa->block[30];

   /* Direct color fields (required for direct/6 and YUV/7 memory models) */
   block->RedMaskSize = pVesa->block[31];
   block->RedFieldPosition = pVesa->block[32];
   block->GreenMaskSize = pVesa->block[33];
   block->GreenFieldPosition = pVesa->block[34];
   block->BlueMaskSize = pVesa->block[35];
   block->BlueFieldPosition = pVesa->block[36];
   block->RsvdMaskSize = pVesa->block[37];
   block->RsvdFieldPosition = pVesa->block[38];
   block->DirectColorModeInfo = pVesa->block[39];

   /* Mandatory information for VBE 2.0 and above */
   if(pVesa->major >= 2)
	 {
		block->PhysBasePtr = *(CARD32 *) (pVesa->block + 40);
		block->Reserved32 = *(CARD32 *) (pVesa->block + 44);
		block->Reserved16 = *(CARD16 *) (pVesa->block + 48);

		/* Mandatory information for VBE 3.0 and above */
		if (pVesa->major >= 3)
		  {
			 block->LinBytesPerScanLine = *(CARD16 *) (pVesa->block + 50);
			 block->BnkNumberOfImagePages = pVesa->block[52];
			 block->LinNumberOfImagePages = pVesa->block[53];
			 block->LinRedMaskSize = pVesa->block[54];
			 block->LinRedFieldPosition = pVesa->block[55];
			 block->LinGreenMaskSize = pVesa->block[56];
			 block->LinGreenFieldPosition = pVesa->block[57];
			 block->LinBlueMaskSize = pVesa->block[58];
			 block->LinBlueFieldPosition = pVesa->block[59];
			 block->LinRsvdMaskSize = pVesa->block[60];
			 block->LinRsvdFieldPosition = pVesa->block[61];
			 block->MaxPixelClock = *(CARD32 *) (pVesa->block + 62);
			 memcpy (&block->Reserved2,pVesa->block + 66,188);
		  }
		else memcpy (&block->LinBytesPerScanLine,pVesa->block + 50,206);
	 }
   else memcpy (&block->PhysBasePtr,pVesa->block + 40,216);

   return (block);
}

d274 1
a274 1
   I810Ptr pI810;
d276 4
a279 3
   if(pScrn->driverPrivate) return TRUE;
   pI810 = pScrn->driverPrivate = xnfcalloc(sizeof(I810Rec), 1);
   pI810->vesa = xcalloc(sizeof(VESARec), 1);
d286 1
a286 1
   I810Ptr pI810;
d290 4
a293 2
   if(!pScrn) return;
   if(!pScrn->driverPrivate) return;
d295 1
a295 1
   pI810 = I810PTR(pScrn);
a296 1
   pVesa = pI810->vesa;
d300 2
a301 2
	 if(mode->Private) {
	    ModeInfoData *data = (ModeInfoData*)mode->Private;
d303 2
a304 1
	    if(data->block) xfree(data->block);
d309 1
a309 1
      } while(mode && mode != pScrn->modes);
d312 12
a323 5
   if(pVesa->monitor) xfree(pVesa->monitor);
   if(pVesa->vbeInfo) xfree(pVesa->vbeInfo);
   if(pVesa->pal) xfree(pVesa->pal);
   if(pVesa->savedPal) xfree(pVesa->savedPal);
   if(pVesa->fonts) xfree(pVesa->fonts);
d325 1
a325 1
   pScrn->driverPrivate=0;
d328 1
a328 1
void
d332 5
a336 5
   
   if (xf86LoadSubModule(pScrn, "vbe")) {
      pVbe = VBEInit(NULL,index);
      ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
   }
d339 8
a346 2
void
I830VESAFreeModeInfo(ModeInfoBlock *block)
d348 16
a363 1
   xfree(block);
d366 3
a368 2
static Bool
I830DetectDisplayDevice(ScrnInfoPtr pScrn)
d370 1
a370 2
   I810Ptr pI810;
   VESAPtr pVesa;
d372 5
a376 2
   pI810 = I810PTR (pScrn);
   pVesa = pI810->vesa;
d378 4
a381 10
   pVesa->pInt->num = 0x10;
   pVesa->pInt->ax = 0x5f64;
   pVesa->pInt->bx = 0x0100;
   xf86ExecX86int10_wrapper (pVesa->pInt,pScrn);

   if (pVesa->pInt->ax != 0x005f)
	 {
		xf86DrvMsg (pScrn->scrnIndex,X_INFO,"Failed to detect active display devices\n");
		return (FALSE);
	 }
d383 1
a383 1
   pI810->configured_device = pVesa->pInt->cx;
d385 17
a401 6
#define PIPEA_CRT_ACTIVE	0x01
#define PIPEA_LCD_ACTIVE	0x08
   /* Anything on Pipe A? */
   if (pVesa->pInt->cx & 0xff)
	 {
		xf86DrvMsg (pScrn->scrnIndex,X_INFO,"Currently active displays on Pipe A:\n");
d403 5
a407 2
		if (pVesa->pInt->cx & PIPEA_CRT_ACTIVE)
		  xf86DrvMsg (pScrn->scrnIndex,X_INFO,"    CRT\n");
d409 1
a409 2
		if (pVesa->pInt->cx & 0x02)
		  xf86DrvMsg (pScrn->scrnIndex,X_INFO,"    TV child device\n");
d411 30
a440 2
		if (pVesa->pInt->cx & 0x04)
		  xf86DrvMsg (pScrn->scrnIndex,X_INFO,"    DFP child device\n");
d442 21
a462 2
		if (pVesa->pInt->cx & PIPEA_LCD_ACTIVE)
		  xf86DrvMsg (pScrn->scrnIndex,X_INFO,"    LFP (Local Flat Panel) child device\n");
d464 13
a476 3
		if (pVesa->pInt->cx & 0xf0)
		  xf86DrvMsg (pScrn->scrnIndex,X_INFO,"    Some unknown display devices may also be present\n");
	 }
d478 4
a481 12
#define PIPEB_CRT_ACTIVE	0x0100
#define PIPEB_LCD_ACTIVE	0x0800
   /* Anything on Pipe B? */
   if (pVesa->pInt->cx & 0xff00)
	 {
		xf86DrvMsg (pScrn->scrnIndex,X_INFO,"Currently active displays on Pipe B:\n");

		if (pVesa->pInt->cx & PIPEB_CRT_ACTIVE)
		  xf86DrvMsg (pScrn->scrnIndex,X_INFO,"    CRT\n");

		if (pVesa->pInt->cx & 0x0200)
		  xf86DrvMsg (pScrn->scrnIndex,X_INFO,"    TV child device\n");
d483 1
a483 2
		if (pVesa->pInt->cx & 0x0400)
		  xf86DrvMsg (pScrn->scrnIndex,X_INFO,"    DFP child device\n");
d485 3
a487 2
		if (pVesa->pInt->cx & PIPEB_LCD_ACTIVE)
		  xf86DrvMsg (pScrn->scrnIndex,X_INFO,"    LFP (Local Flat Panel) child device\n");
d489 5
a493 5
		if (pVesa->pInt->cx & 0xf000)
		  xf86DrvMsg (pScrn->scrnIndex,X_INFO,"    Some unknown display devices may also be present\n");
	 }

   return (TRUE);
d496 3
a498 1
static int I830DetectMemory (ScrnInfoPtr pScrn)
d500 1
a500 5
   I810Ptr pI810;
   VESAPtr pVesa;
   PCITAG bridge;
   CARD16 gmch_ctrl;
   int memsize;
d502 1
a502 2
   pI810 = I810PTR (pScrn);
   pVesa = pI810->vesa;
d504 4
a507 31
   bridge = pciTag (0,0,0);	/* This is always the host bridge */
   gmch_ctrl = pciReadWord (bridge,I830_GMCH_CTRL);

   switch (gmch_ctrl & I830_GMCH_GMS_MASK)
	 {
	  case I830_GMCH_GMS_STOLEN_512:
		memsize = KB (512);
		xf86DrvMsg (pScrn->scrnIndex,X_INFO,"detected %dK stolen memory.\n",memsize / 1024);
		break;
	  case I830_GMCH_GMS_STOLEN_1024:
		memsize = MB (1);
		xf86DrvMsg (pScrn->scrnIndex,X_INFO,"detected %dK stolen memory.\n",memsize / 1024);
		break;
	  case I830_GMCH_GMS_STOLEN_8192:
		memsize = MB (8);
		xf86DrvMsg (pScrn->scrnIndex,X_INFO,"detected %dK stolen memory.\n",memsize / 1024);
		break;
	  case I830_GMCH_GMS_LOCAL:
		/* I'd like to use the VGA controller registers here, but MMIOBase isn't
		 * yet, so for now, we'll just use the BIOS instead... */
		pVesa->pInt->num = 0x10;
		pVesa->pInt->ax = 0x5f10;
		xf86ExecX86int10_wrapper (pVesa->pInt,pScrn);
		memsize = pVesa->pInt->cx * KB (1);
		xf86DrvMsg (pScrn->scrnIndex,X_INFO,"detected %dK local memory.\n",memsize / 1024);
		break;
	  default:
		/* not that this is possible, but anyway (: */
		memsize = 0;
		xf86DrvMsg (pScrn->scrnIndex,X_INFO,"no video memory detected.\n");
	 }
d509 2
a510 1
   return (memsize);
d512 1
d514 2
a515 1
Bool I830BIOSPreInit (ScrnInfoPtr pScrn,int flags)
d517 4
a520 14
   vgaHWPtr hwp;
   I810Ptr pI810;
   MessageType from;
   rgb defaultWeight = { 0, 0, 0 };
   VESAPtr pVesa;
   VBEInfoBlock *vbe;
   DisplayModePtr pMode,tmp;
   ModeInfoBlock *mode;
   ModeInfoData *data = NULL;
   vbeInfoPtr pVbe;
   pointer pVbeModule,pDDCModule;
   int mem;
   int flags24;
   int i = 0;
d522 21
a542 1
   if(pScrn->numEntities != 1) return (FALSE);
d544 10
a553 3
   /* The vgahw module should be loaded here when needed */
   if (!xf86LoadSubModule (pScrn,"vgahw")) return (FALSE);
   xf86LoaderReqSymLists (I810vgahwSymbols,NULL);
d555 6
a560 3
    /* Load int10 module */
   if (!xf86LoadSubModule (pScrn,"int10")) return (FALSE);
   xf86LoaderReqSymLists (I810int10Symbols,NULL);
d562 1
a562 2
   /* Allocate a vgaHWRec */
   if (!vgaHWGetHWRec (pScrn)) return (FALSE);
d564 4
a567 2
   /* Allocate driverPrivate */
   if (!I830BIOSGetRec (pScrn)) return (FALSE);
d569 12
a580 2
   pI810 = I810PTR (pScrn);
   pI810->pEnt = xf86GetEntityInfo (pScrn->entityList[0]);
d582 6
a587 1
   if (pI810->pEnt->location.type != BUS_PCI) return (FALSE);
d589 1
a589 5
   if (flags & PROBE_DETECT)
	 {
		I830BIOSProbeDDC (pScrn,pI810->pEnt->index);
		return (TRUE);
	 }
d591 17
a607 2
   pI810->PciInfo = xf86GetPciInfoForEntity (pI810->pEnt->index);
   pI810->PciTag = pciTag (pI810->PciInfo->bus,pI810->PciInfo->device,pI810->PciInfo->func);
d609 5
a613 2
   if (xf86RegisterResources (pI810->pEnt->index,0,ResNone))
	 return (FALSE);
d615 1
a615 4
   pScrn->racMemFlags = RAC_FB | RAC_COLORMAP;
   pScrn->monitor = pScrn->confScreen->monitor;
   pScrn->progClock = TRUE;
   pScrn->rgbBits = 8;
d617 13
a629 1
   flags24 = Support32bppFb | PreferConvert24to32 | SupportConvert24to32;
d631 17
a647 11
   if (!xf86SetDepthBpp (pScrn,8,8,8,flags24)) return (FALSE);
   switch (pScrn->depth)
	 {
      case 8:
      case 15:
      case 16:
      case 24:
		break;
      default:
		xf86DrvMsg (pScrn->scrnIndex,X_ERROR,"Given depth (%d) is not supported by I830 driver\n",pScrn->depth);
		return (FALSE);
d649 5
a653 1
   xf86PrintDepthBpp (pScrn);
d655 5
a659 4
   if (!xf86SetWeight (pScrn,defaultWeight,defaultWeight))
	 return (FALSE);
   if (!xf86SetDefaultVisual (pScrn,-1))
	 return (FALSE);
d661 9
a669 2
   hwp = VGAHWPTR (pScrn);
   pI810->cpp = pScrn->bitsPerPixel / 8;
d671 26
a696 3
   /* Process the options */
   xf86CollectOptions (pScrn,NULL);
   xf86ProcessOptions (pScrn->scrnIndex,pScrn->options,I830BIOSOptions);
d698 33
a730 2
   /* We have to use PIO to probe, because we haven't mapped yet */
   I810SetPIOAccess (pI810);
d732 4
a735 1
   pVesa = pI810->vesa;
d737 12
a748 1
   /* Initialize Vesa record */
d750 29
a778 10
   if ((pVesa->pInt = xf86InitInt10(pI810->pEnt->index)) == NULL)
	 {
		xf86DrvMsg (pScrn->scrnIndex,X_ERROR,"Int10 initialization failed.\n");
		return (FALSE);
	 }
   if ((pVesa->block = xf86Int10AllocPages (pVesa->pInt,1,&pVesa->page)) == NULL)
	 {
		xf86DrvMsg (pScrn->scrnIndex,X_ERROR,"Cannot allocate one scratch page in real mode memory.\n");
		return (FALSE);
	 }
d780 6
a785 17
   /* Set the Chipset and ChipRev, allowing config file entries to override. */
   if (pI810->pEnt->device->chipset && *pI810->pEnt->device->chipset)
	 {
		pScrn->chipset = pI810->pEnt->device->chipset;
		from = X_CONFIG;
	 }
   else if (pI810->pEnt->device->chipID >= 0)
	 {
		pScrn->chipset = (char *) xf86TokenToString (I830BIOSChipsets,pI810->pEnt->device->chipID);
		from = X_CONFIG;
		xf86DrvMsg (pScrn->scrnIndex,X_CONFIG,"ChipID override: 0x%04X\n",pI810->pEnt->device->chipID);
	 }
   else
	 {
		from = X_PROBED;
		pScrn->chipset = (char *) xf86TokenToString (I830BIOSChipsets,pI810->PciInfo->chipType);
	 }
d787 28
a814 2
   if (pI810->pEnt->device->chipRev >= 0)
	 xf86DrvMsg (pScrn->scrnIndex,X_CONFIG,"ChipRev override: %d\n",pI810->pEnt->device->chipRev);
d816 6
a821 1
   xf86DrvMsg (pScrn->scrnIndex,from,"Chipset: \"%s\"\n",(pScrn->chipset != NULL) ? pScrn->chipset : "Unknown i810");
d823 7
a829 19
   if (pI810->pEnt->device->MemBase != 0)
	 {
		pI810->LinearAddr = pI810->pEnt->device->MemBase;
		from = X_CONFIG;
	 }
   else
	 {
		if (pI810->PciInfo->memBase[1] != 0)
		  {
			 pI810->LinearAddr = pI810->PciInfo->memBase[0] & 0xFF000000;
			 from = X_PROBED;
		  }
		else
		  {
			 xf86DrvMsg (pScrn->scrnIndex,X_ERROR,"No valid FB address in PCI config space\n");
			 I830BIOSFreeRec (pScrn);
			 return (FALSE);
		  }
	 }
d831 2
a832 1
   xf86DrvMsg (pScrn->scrnIndex,from,"Linear framebuffer at 0x%lX\n",(unsigned long) pI810->LinearAddr);
d834 8
a841 19
   if (pI810->pEnt->device->IOBase != 0)
	 {
		pI810->MMIOAddr = pI810->pEnt->device->IOBase;
		from = X_CONFIG;
	 }
   else
	 {
		if (pI810->PciInfo->memBase[1])
		  {
			 pI810->MMIOAddr = pI810->PciInfo->memBase[1] & 0xFFF80000;
			 from = X_PROBED;
		  }
		else
		  {
			 xf86DrvMsg (pScrn->scrnIndex,X_ERROR,"No valid MMIO address in PCI config space\n");
			 I830BIOSFreeRec (pScrn);
			 return (FALSE);
		  }
	 }
d843 2
a844 1
   xf86DrvMsg (pScrn->scrnIndex,from,"IO registers at addr 0x%lX\n",(unsigned long) pI810->MMIOAddr);
d846 7
a852 19
	 {
		PCITAG bridge;
		CARD16 gmch_ctrl;

		bridge = pciTag (0,0,0); /* This is always the host bridge */
		gmch_ctrl = pciReadWord (bridge,I830_GMCH_CTRL);
		if ((gmch_ctrl & I830_GMCH_MEM_MASK) == I830_GMCH_MEM_128M)
		  {
			 pI810->FbMapSize = 0x7000000;
			 pI810->DepthOffset = 0x7000000;
			 pI810->BackOffset = 0x7800000;
		  }
		else
		  {
			 pI810->FbMapSize = 0x3000000;
			 pI810->DepthOffset = 0x3000000;
			 pI810->BackOffset = 0x3800000;
		  }
	 }
d854 2
a855 2
   /* FIXME: Get rid of StolenSize/StolenOnly */
   pI810->StolenSize = I830DetectMemory (pScrn);
d857 46
a902 12
   /* Default to stolen/local memory size or 8MB whichever is bigger */
   if (!pI810->pEnt->device->videoRam)
	 {
		from = X_DEFAULT;
		pScrn->videoRam = pI810->StolenSize / 1024;
		if (pScrn->videoRam < 8192) pScrn->videoRam = 8192;
	 }
   else
	 {
		from = X_DEFAULT;
		pScrn->videoRam = pI810->pEnt->device->videoRam;
	 }
d904 5
a908 2
   mem = I810CheckAvailableMemory (pScrn);
   pI810->StolenOnly = FALSE;
d910 5
a914 13
   DPRINTF (PFX,
			"Available memory: %dk\n"
			"Requested memory: %dk (see XF86Config-4)\n",
			mem,pScrn->videoRam);

   if (mem < 0)
	 {
		xf86DrvMsg (pScrn->scrnIndex,X_WARNING,
					"/dev/agpgart is either not available, or no memory "
					"is available\nfor allocation. Using stolen memory only.\n");
		pScrn->videoRam = pI810->StolenSize / 1024;
		pI810->StolenOnly = TRUE;
	 }
d916 7
a922 1
   xf86DrvMsg (pScrn->scrnIndex,from,"Will alloc AGP framebuffer: %d kByte\n",pScrn->videoRam);
d924 5
a928 3
   /*
	* If the driver can do gamma correction, it should call xf86SetGamma() here.
    */
d930 2
a931 2
	 {
		Gamma zeros = { 0.0, 0.0, 0.0 };
d933 2
a934 2
		if (!xf86SetGamma (pScrn,zeros)) return (FALSE);
	 }
d936 5
a940 5
   if (!I830DetectDisplayDevice (pScrn))
	 {
		xf86DrvMsg (pScrn->scrnIndex,X_ERROR,"Couldn't detect display devices.\n");
		return (FALSE);
	 }
d942 1
a942 4
   vbe = I830VESAGetVBEInfo(pScrn);
   pVesa->major = (unsigned)(vbe->VESAVersion >> 8);
   pVesa->minor = vbe->VESAVersion & 0xff;
   pVesa->vbeInfo = vbe;
d944 2
a945 4
   /* Load vbe module */
   if((pVbeModule = xf86LoadSubModule(pScrn, "vbe")) == NULL) return FALSE;
   xf86LoaderReqSymLists(I810vbeSymbols, NULL);
   if((pVbe = VBEInit(pVesa->pInt, pVesa->pEnt->index)) == NULL) return FALSE;
d947 4
a950 3
   /* Load ddc module */
   if((pDDCModule = xf86LoadSubModule(pScrn, "ddc")) == NULL) return FALSE;
   xf86LoaderReqSymLists(I810ddcSymbols, NULL);
d952 4
a955 3
   if((pVesa->monitor = vbeDoEDID(pVbe, pDDCModule)) != NULL) {
      xf86PrintEDID(pVesa->monitor);
   }
d957 4
a960 5
   /* unload modules */
   xf86UnloadSubModule(pVbeModule);
   xf86UnloadSubModule(pDDCModule);
   /* Set display resolution */
   xf86SetDpi(pScrn, 0, 0);
d962 6
a967 1
#define VIDEO_BIOS_SCRATCH 0x18
d969 15
a983 68
   /* Enable hot keys by writing the proper value to GR18 */
   {
      CARD8 gr18;
      gr18 = pI810->readControl(pI810, GRX, VIDEO_BIOS_SCRATCH);
      gr18 &= ~0x80; /* Clear Hot key bit so that Video BIOS performs
		      * the hot key servicing */
      pI810->writeControl(pI810, GRX, VIDEO_BIOS_SCRATCH, gr18);
   }

   if((pScrn->monitor->DDC = pVesa->monitor) != NULL)
     xf86SetDDCproperties(pScrn, pVesa->monitor);

   /* New way of processing video modes */
   for (i = 0; i <= 0x7f; i++)
	 {
		pVesa->pInt->num = 0x10;
		pVesa->pInt->ax = 0x5f28;
		pVesa->pInt->bx = 0x8000 | i;
		pVesa->pInt->cx = 0x8000; /* Current display device */
		xf86ExecX86int10_wrapper (pVesa->pInt,pScrn);

		if(pVesa->pInt->ax != 0x005f) continue;

		if ((mode = I830VESAGetModeInfo (pScrn,i)) == NULL) continue;

		if (!(mode->ModeAttributes & (1 << 0)) ||	/* supported in the configured hardware */
			!(mode->ModeAttributes & (1 << 4)) ||	/* text mode */
			(pScrn->bitsPerPixel != 1 && !(mode->ModeAttributes & (1 << 3))) || /* monochrome */
			(mode->BitsPerPixel > 8 && (mode->RedMaskSize + mode->GreenMaskSize + mode->BlueMaskSize != pScrn->depth)) ||
			/* only linear mode, but no PhysBasePtr */
			((mode->ModeAttributes & (1 << 6)) && (mode->ModeAttributes & (1 << 7)) && !mode->PhysBasePtr) ||
			((mode->ModeAttributes & (1 << 6)) && !(mode->ModeAttributes & (1 << 7))) || mode->BitsPerPixel != pScrn->bitsPerPixel)
		  {
			 I830VESAFreeModeInfo (mode);
			 continue;
		  }

		pMode = xcalloc (sizeof (DisplayModeRec),1);
		pMode->prev = pMode->next = NULL;

		pMode->status = MODE_OK;
		pMode->type = M_T_DEFAULT;	/*M_T_BUILTIN;*/

		/* for adjust frame */
		pMode->HDisplay = mode->XResolution;
		pMode->VDisplay = mode->YResolution;

		data = xcalloc (sizeof (ModeInfoData),1);
		data->mode = i;
		data->data = mode;
		pMode->PrivSize = sizeof (ModeInfoData);
		pMode->Private = (INT32*) data;

		if (pScrn->modePool == NULL)
		  {
			 pScrn->modePool = pMode;
			 pMode->next = pMode->prev = pMode;
		  }
		else
		  {
			 tmp = pScrn->modePool;
			 tmp->prev = pMode;
			 while (tmp->next != pScrn->modePool) tmp = tmp->next;
			 tmp->next = pMode;
			 pMode->prev = tmp;
			 pMode->next = pScrn->modePool;
		  }
	 }
d985 4
a988 1
   if (pScrn->modePool == NULL) return FALSE;
d990 3
a992 41
   for (i = 0; pScrn->modePool != NULL && pScrn->display->modes[i] != NULL; i++)
	 {
		pMode = pScrn->modePool;

		do
		  {
			 DisplayModePtr next = pMode->next;
			 int width, height;

			 if (sscanf (pScrn->display->modes[i],"%dx%d",&width,&height) == 2 &&
				 width == pMode->HDisplay && height == pMode->VDisplay)
			   {
				  pMode->name = strdup(pScrn->display->modes[i]);

				  pMode->prev->next = pMode->next;
				  pMode->next->prev = pMode->prev;

				  if (pScrn->modes == NULL)
					{
					   pScrn->modes = pMode;
					   pMode->next = pMode->prev = pMode;
					}
				  else
					{
					   tmp = pScrn->modes;
					   tmp->prev = pMode;
					   while (tmp->next != pScrn->modes) tmp = tmp->next;
					   pMode->prev = tmp;
					   tmp->next = pMode;
					   pMode->next = pScrn->modes;
					}

				  if (pMode == pScrn->modePool)
					pScrn->modePool = next == pMode ? NULL : next;
				  break;
			   }

			 pMode = next;
		  }
		while (pMode != pScrn->modePool && pScrn->modePool != NULL);
	 }
d994 12
a1005 13
   if (pScrn->modes == NULL)
	 {
		xf86DrvMsg (pScrn->scrnIndex,X_ERROR,"No matching modes found in configuration file.\n");
		xf86DrvMsg (pScrn->scrnIndex,X_ERROR,"Only the following modes are supported by the BIOS in this bpp:\n");
		pMode = pScrn->modePool;
		do
		  {
			 data = (ModeInfoData *) pMode->Private;
			 mode = data->data;
			 xf86DrvMsg (pScrn->scrnIndex,X_ERROR,"%dx%d\n",mode->XResolution,mode->YResolution);
			 pMode = pMode->next;
		  }
		while (pMode != pScrn->modePool);
d1007 1
a1007 1
		xf86DrvMsg (pScrn->scrnIndex,X_ERROR,"Please choose one of these modes.\n");
d1009 6
a1014 2
		return (FALSE);
	 }
d1016 16
a1031 13
   tmp = pScrn->modes;
   do
	 {
		mode = ((ModeInfoData *) tmp->Private)->data;
		if (mode->XResolution > pScrn->virtualX)
		  {
			 pScrn->virtualX = mode->XResolution;
			 pVesa->maxBytesPerScanline = mode->BytesPerScanline;
		  }
		if (mode->YResolution > pScrn->virtualY)
		  pScrn->virtualY = mode->YResolution;
	 }
   while ((tmp = tmp->next) != pScrn->modes);
d1033 4
a1036 103
   if (pVesa->monitor != NULL)
	 {
		DisplayModePtr tmp;
		int dotclock = 0;
		float hsync,vrefresh;

		pMode = pScrn->modes;
		do
		  {
			 for (tmp = pScrn->monitor->Modes; tmp != NULL; tmp = tmp->next)
			   if (!strcmp (pMode->name,tmp->name) && dotclock < tmp->Clock)
				 {
#ifdef I830DEBUG
					fprintf (stderr,"##############################################\n");
					  {
						 char flags[256];

						 *flags = '\0';

						 if (tmp->HSkew) sprintf (flags,"%s hskew %d",flags,tmp->HSkew);
						 if (tmp->VScan) sprintf (flags,"%s vscan %d",flags,tmp->VScan);
						 if (tmp->Flags & V_INTERLACE) strcat (flags," interlace");
						 if (tmp->Flags & V_CSYNC) strcat (flags," composite");
						 if (tmp->Flags & V_DBLSCAN) strcat (flags," doublescan");
						 if (tmp->Flags & V_BCAST) strcat (flags," bcast");
						 if (tmp->Flags & V_PHSYNC) strcat (flags," +hsync");
						 if (tmp->Flags & V_NHSYNC) strcat (flags," -hsync");
						 if (tmp->Flags & V_PVSYNC) strcat (flags," +vsync");
						 if (tmp->Flags & V_NVSYNC) strcat (flags," -vsync");
						 if (tmp->Flags & V_PCSYNC) strcat (flags," +csync");
						 if (tmp->Flags & V_NCSYNC) strcat (flags," -csync");
						 fprintf (stderr,
								  "Modeline \"%s\"  %6.2f  %d %d %d %d   %d %d %d %d%s\n",
								  tmp->name,
								  tmp->Clock / 1000.0,
								  tmp->HDisplay,tmp->HSyncStart,tmp->HSyncEnd,tmp->HTotal,
								  tmp->VDisplay,tmp->VSyncStart,tmp->VSyncEnd,tmp->VTotal,
								  flags);
					  }
					fprintf (stderr,"##############################################\n");
#endif

					pMode->Clock = tmp->Clock;
					pMode->HDisplay = tmp->HDisplay;
					pMode->HSyncStart = tmp->HSyncStart;
					pMode->HSyncEnd = tmp->HSyncEnd;
					pMode->HTotal = tmp->HTotal;
					pMode->HSkew = tmp->HSkew;
					pMode->VDisplay = tmp->VDisplay;
					pMode->VSyncStart = tmp->VSyncStart;
					pMode->VSyncEnd = tmp->VSyncEnd;
					pMode->VTotal = tmp->VTotal;
					pMode->VScan = tmp->VScan;
					pMode->Flags = tmp->Flags;

					dotclock = tmp->Clock;
				 }

			 data->mode |= 1 << 11;	/* FIXME: What is this used for? */

			 data = (ModeInfoData *) pMode->Private;
			 data->block = xcalloc (sizeof (CRTCInfoBlock),1);
			 data->block->HorizontalTotal = pMode->HTotal;
			 data->block->HorizontalSyncStart = pMode->HSyncStart;
			 data->block->HorizontalSyncEnd = pMode->HSyncEnd;
			 data->block->VerticalTotal = pMode->VTotal;
			 data->block->VerticalSyncStart = pMode->VSyncStart;
			 data->block->VerticalSyncEnd = pMode->VSyncEnd;
			 data->block->Flags = pMode->Flags;
			 data->block->PixelClock = pMode->Clock * 1000;

			 hsync = 0;
			 if (pMode->HSync > 0.0)
			   hsync = pMode->HSync;
			 else if (pMode->HTotal > 0)
			   hsync = (float) pMode->Clock / (float) pMode->HTotal;

			 vrefresh = 0;
			 if (pMode->VTotal > 0) vrefresh = hsync * 1000.0 / pMode->VTotal;
			 if (pMode->Flags & V_INTERLACE) vrefresh *= 2.0;
			 if (pMode->Flags & V_DBLSCAN) vrefresh /= 2.0;
			 if (pMode->VScan > 1) vrefresh /= pMode->VScan;
			 if (pMode->VRefresh > 0.0) vrefresh = pMode->VRefresh;

			 pMode->HSync = hsync;
			 pMode->VRefresh = vrefresh;

			 DPRINTF (PFX,
					  "pMode->HSync == %.1f KHz\n"
					  "pMode->VRefresh == %.1f Hz\n",
					  pMode->HSync,
					  pMode->VRefresh);

			 data->block->RefreshRate = vrefresh;

			 /* do some very primitive rounding to the nearest integer */
			 if ((vrefresh - data->block->RefreshRate) * 10.0 >= 5.0)
			   data->block->RefreshRate++;

			 data->block->RefreshRate *= 100;
		  }
		while (pMode != pScrn->modes);
	 }
d1038 1
a1038 19
   DPRINTF (PFX,
			"data->block->HorizontalTotal = %lu\n"
			"data->block->HorizontalSyncStart = %lu\n"
			"data->block->HorizontalSyncEnd = %lu\n"
			"data->block->VerticalTotal = %lu\n"
			"data->block->VerticalSyncStart = %lu\n"
			"data->block->VerticalSyncEnd = %lu\n"
			"data->block->Flags = %lu\n"
			"data->block->PixelClock = %lu\n"
			"data->block->RefreshRate = %lu\n",
			data->block->HorizontalTotal,
			data->block->HorizontalSyncStart,
			data->block->HorizontalSyncEnd,
			data->block->VerticalTotal,
			data->block->VerticalSyncStart,
			data->block->VerticalSyncEnd,
			data->block->Flags,
			data->block->PixelClock,
			data->block->RefreshRate);
d1040 1
a1040 1
   pScrn->currentMode = pScrn->modes;
d1042 3
a1044 7
#ifdef XF86DRI
   /* Need to find largest sized mode then pick the best pitch, this allows us to use tiled memory. */
	 {
		int maxXResolution = 0;
		int calc_pitch;
#if 0
		int i,i830_pitches[] = { 512, 1024, 2048, 4096, 8192 };
d1047 74
a1120 7
		pMode = pScrn->modes;
		do
		  {
			 if (pMode->HDisplay > maxXResolution) maxXResolution = pMode->HDisplay;
			 pMode = pMode->next;
		  }
		while (pMode != pScrn->modes);
d1122 2
a1123 1
		calc_pitch = 0;
d1125 41
a1165 50
/* FIXME: why isn't this working? */
#if 0
		for (i = 0; i < NB_OF (i830_pitches); i++)
		  if ((maxXResolution * pI810->cpp) <= i830_pitches[i])
			{
			   calc_pitch = i830_pitches[i] / pI810->cpp;
			   break;
			}
#endif

		pScrn->displayWidth = calc_pitch ? calc_pitch : pScrn->virtualX;
		if (pScrn->virtualY * pScrn->displayWidth * pI810->cpp > pI810->StolenSize)
		  {
			 xf86DrvMsg (pScrn->scrnIndex,X_WARNING,"Pitch is bigger than local/stolen size. Defaulting\n\tto original display width\n");
			 pScrn->displayWidth = pScrn->virtualX;
		  }

		DPRINTF (PFX,
				 "calc_pitch == %lu\n"
				 "pScrn->displayWidth == %lu\n"
				 "virtualX == %lu\n"
				 "virtualY == %lu\n"
				 "Memory needed: %lu x %lu x %lu == %luK\n",
				 calc_pitch,
				 pScrn->displayWidth,
				 pScrn->virtualX,
				 pScrn->virtualY,
				 pScrn->virtualY,MAX(pScrn->displayWidth,pScrn->virtualX),pI810->cpp,
				 (pScrn->virtualY * MAX(pScrn->displayWidth,pScrn->virtualX) * pI810->cpp) / 1024);
   }
#endif /* XF86DRI */

   if (pScrn->modes == NULL) return FALSE;

   /* Further validate the mode */
   mode = ((ModeInfoData *) pScrn->modes->Private)->data;
   switch (mode->MemoryModel)
	 {
	  case 0x0:	/* Text mode */
	  case 0x1:	/* CGA graphics */
	  case 0x2:	/* Hercules graphics */
	  case 0x3:	/* Planar */
	  case 0x5:	/* Non-chain 4, 256 color */
	  case 0x7:	/* YUV */
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,"Unsupported Memory Model: %d",mode->MemoryModel);
		return FALSE;
	  case 0x4:	/* Packed pixel */
	  case 0x6:	/*  Direct Color */
		break;
	 }
d1167 1
a1167 1
   xf86PrintModes (pScrn);
d1169 2
a1170 6
   /* Load the required sub modules */
   if (!xf86LoadSubModule (pScrn,"fb"))
	 {
		I830BIOSFreeRec (pScrn);
		return FALSE;
	 }
d1172 2
a1173 1
   xf86LoaderReqSymLists(I810fbSymbols, NULL);
d1175 4
a1178 6
   if (!xf86ReturnOptValBool(I810AvailableOptions(0,0), OPTION_NOACCEL, FALSE)) {
      if (!xf86LoadSubModule(pScrn, "xaa")) {
	 I830BIOSFreeRec(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I810xaaSymbols, NULL);
d1180 1
d1182 5
a1186 6
   if (!xf86ReturnOptValBool(I810AvailableOptions(0,0), OPTION_SW_CURSOR, FALSE)) {
      if (!xf86LoadSubModule(pScrn, "ramdac")) {
	 I830BIOSFreeRec(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I810ramdacSymbols, NULL);
d1188 10
d1199 7
a1205 13
   /*  We wont be using the VGA access after the probe */
   {
      resRange vgaio[] = { {ResShrIoBlock,0x3B0,0x3BB},
			   {ResShrIoBlock,0x3C0,0x3DF},
			   _END };
      resRange vgamem[] = {{ResShrMemBlock,0xA0000,0xAFFFF},
			   {ResShrMemBlock,0xB8000,0xBFFFF},
			   {ResShrMemBlock,0xB0000,0xB7FFF},
			   _END };

      I810SetMMIOAccess(pI810);
      xf86SetOperatingState(vgaio, pI810->pEnt->index, ResUnusedOpr);
      xf86SetOperatingState(vgamem, pI810->pEnt->index, ResDisableOpr);
d1207 14
d1222 9
a1230 1
   return TRUE;
d1234 5
a1238 1
 * Just adapted from the std* functions in vgaHW.c
d1240 37
d1279 1
a1279 1
WriteAttr(int index, int value)
d1281 1
a1281 1
   CARD8 tmp;
d1283 8
a1290 5
   tmp = inb(VGA_IOBASE_COLOR + VGA_IN_STAT_1_OFFSET);

   index |= 0x20;
   outb(VGA_ATTR_INDEX, index);
   outb(VGA_ATTR_DATA_W, value);
d1293 2
a1294 2
static int
ReadAttr(int index)
d1296 32
a1327 1
   CARD8 tmp;
d1329 30
a1358 1
   tmp = inb(VGA_IOBASE_COLOR + VGA_IN_STAT_1_OFFSET);
d1360 9
a1368 4
   index |= 0x20;
   outb(VGA_ATTR_INDEX, index);
   return (inb(VGA_ATTR_DATA_R));
}
d1370 13
a1382 4
#define WriteMiscOut(value)	outb(VGA_MISC_OUT_W, value)
#define ReadMiscOut()		inb(VGA_MISC_OUT_R)
#define WriteSeq(index, value)	outb(VGA_SEQ_INDEX, index);\
				outb(VGA_SEQ_DATA, value)
d1384 4
a1387 4
static int
ReadSeq(int index)
{
   outb(VGA_SEQ_INDEX, index);
d1389 2
a1390 2
   return (inb(VGA_SEQ_DATA));
}
d1392 6
a1397 6
#define WriteGr(index, value)	outb(VGA_GRAPH_INDEX, index);\
				outb(VGA_GRAPH_DATA, value)
static int
ReadGr(int index)
{
   outb(VGA_GRAPH_INDEX, index);
d1399 2
a1400 2
   return (inb(VGA_GRAPH_DATA));
}
d1402 4
a1405 7
static void
SeqReset(Bool start)
{
   if(start) {
      WriteSeq(0x00, 0x01);		/* Synchronous Reset */
   } else {
      WriteSeq(0x00, 0x03);			/* End Reset */
a1406 1
}
d1408 40
a1447 6
static void
SaveFonts(ScrnInfoPtr pScrn)
{
   I810Ptr pI810;
   VESAPtr pVesa;
   unsigned char miscOut, attr10, gr4, gr5, gr6, seq2, seq4, scrn;
d1449 1
a1449 2
   pI810 = I810PTR(pScrn);
   pVesa = pI810->vesa;
d1451 1
a1451 1
   if(pVesa->fonts != NULL) return;
d1453 15
a1467 54
   /* If in graphics mode, don't save anything */
   attr10 = ReadAttr(0x10);
   if(attr10 & 0x01) return;

   pVesa->fonts = xalloc(16384);

   /* save the registers that are needed here */
   miscOut = ReadMiscOut();
   gr4 = ReadGr(0x04);
   gr5 = ReadGr(0x05);
   gr6 = ReadGr(0x06);
   seq2 = ReadSeq(0x02);
   seq4 = ReadSeq(0x04);

   /* Force into colour mode */
   WriteMiscOut(miscOut | 0x01);

   scrn = ReadSeq(0x01) | 0x20;
   SeqReset(TRUE);
   WriteSeq(0x01, scrn);
   SeqReset(FALSE);

   WriteAttr(0x10, 0x01);	/* graphics mode */

   /*font1 */
   WriteSeq(0x02, 0x04);	/* write to plane 2 */
   WriteSeq(0x04, 0x06);	/* enable plane graphics */
   WriteGr(0x04, 0x02); 	/* read plane 2 */
   WriteGr(0x05, 0x00); 	/* write mode 0, read mode 0 */
   WriteGr(0x06, 0x05); 	/* set graphics */
   slowbcopy_frombus(pVesa->VGAbase, pVesa->fonts, 8192);

   /* font2 */
   WriteSeq(0x02, 0x08);	/* write to plane 3 */
   WriteSeq(0x04, 0x06);	/* enable plane graphics */
   WriteGr(0x04, 0x03); 	/* read plane 3 */
   WriteGr(0x05, 0x00); 	/* write mode 0, read mode 0 */
   WriteGr(0x06, 0x05); 	/* set graphics */
   slowbcopy_frombus(pVesa->VGAbase, pVesa->fonts + 8192, 8192);

   scrn = ReadSeq(0x01) & ~0x20;
   SeqReset(TRUE);
   WriteSeq(0x01, scrn);
   SeqReset(FALSE);

   /* Restore clobbered registers */
   WriteAttr(0x10, attr10);
   WriteSeq(0x02, seq2);
   WriteSeq(0x04, seq4);
   WriteGr(0x04, gr4);
   WriteGr(0x05, gr5);
   WriteGr(0x06, gr6);
   WriteMiscOut(miscOut);
}
d1469 4
a1472 6
static void
RestoreFonts(ScrnInfoPtr pScrn)
{
   I810Ptr pI810;
   VESAPtr pVesa;
   unsigned char miscOut, attr10, gr1, gr3, gr4, gr5, gr6, gr8, seq2, seq4, scrn;
d1474 2
a1475 2
   pI810 = I810PTR(pScrn);
   pVesa = pI810->vesa;
d1477 15
a1491 1
   if(pVesa->fonts == NULL) return;
d1493 2
a1494 53
   /* save the registers that are needed here */
   miscOut = ReadMiscOut();
   attr10 = ReadAttr(0x10);
   gr1 = ReadGr(0x01);
   gr3 = ReadGr(0x03);
   gr4 = ReadGr(0x04);
   gr5 = ReadGr(0x05);
   gr6 = ReadGr(0x06);
   gr8 = ReadGr(0x08);
   seq2 = ReadSeq(0x02);
   seq4 = ReadSeq(0x04);

   /* Force into colour mode */
   WriteMiscOut(miscOut | 0x01);

   scrn = ReadSeq(0x01) | 0x20;
   SeqReset(TRUE);
   WriteSeq(0x01, scrn);
   SeqReset(FALSE);

   WriteAttr(0x10, 0x01);	/* graphics mode */

   WriteSeq(0x02, 0x04);   /* write to plane 2 */
   WriteSeq(0x04, 0x06);   /* enable plane graphics */
   WriteGr(0x04, 0x02);    /* read plane 2 */
   WriteGr(0x05, 0x00);    /* write mode 0, read mode 0 */
   WriteGr(0x06, 0x05);    /* set graphics */
   slowbcopy_tobus(pVesa->fonts, pVesa->VGAbase, 8192);

   WriteSeq(0x02, 0x08);   /* write to plane 3 */
   WriteSeq(0x04, 0x06);   /* enable plane graphics */
   WriteGr(0x04, 0x03);    /* read plane 3 */
   WriteGr(0x05, 0x00);    /* write mode 0, read mode 0 */
   WriteGr(0x06, 0x05);    /* set graphics */
   slowbcopy_tobus(pVesa->fonts + 8192, pVesa->VGAbase, 8192);

   scrn = ReadSeq(0x01) & ~0x20;
   SeqReset(TRUE);
   WriteSeq(0x01, scrn);
   SeqReset(FALSE);

   /* restore the registers that were changed */
   WriteMiscOut(miscOut);
   WriteAttr(0x10, attr10);
   WriteGr(0x01, gr1);
   WriteGr(0x03, gr3);
   WriteGr(0x04, gr4);
   WriteGr(0x05, gr5);
   WriteGr(0x06, gr6);
   WriteGr(0x08, gr8);
   WriteSeq(0x02, seq2);
   WriteSeq(0x04, seq4);
}
d1496 14
a1509 1
/* End font code */
d1511 2
a1512 6
void
I830BIOSSaveRegisters(ScrnInfoPtr pScrn)
{
   I810Ptr pI810 = I810PTR(pScrn);
   I830RegPtr i830Reg = &pI810->i830_SavedReg;
   int i;
d1514 2
a1515 2
   for (i = 0 ; i < 8 ; i++)
      i830Reg->Fence[i] = INREG(FENCE+i*4);
d1517 29
a1545 4
   i830Reg->LprbTail = INREG(LP_RING + RING_TAIL);
   i830Reg->LprbHead = INREG(LP_RING + RING_HEAD);
   i830Reg->LprbStart = INREG(LP_RING + RING_START);
   i830Reg->LprbLen = INREG(LP_RING + RING_LEN);
d1547 43
a1589 4
   if ((i830Reg->LprbTail & TAIL_ADDR) != (i830Reg->LprbHead & HEAD_ADDR) &&
       i830Reg->LprbLen & RING_VALID) {
      I810PrintErrorState( pScrn );
      FatalError( "Active ring not flushed\n");
a1590 1
}
d1592 16
a1607 4
static void I830SetRingRegisters(ScrnInfoPtr pScrn, I830RegPtr i830Reg)
{
   I810Ptr pI810 = I810PTR(pScrn);
   unsigned int temp;
d1609 5
a1613 2
   /* First disable the ring buffer (Need to wait for empty first?, if so
    * should probably do it before entering this section)
a1614 3
   temp = INREG(LP_RING + RING_LEN);
   temp &= ~RING_VALID_MASK;
   OUTREG(LP_RING + RING_LEN, temp );
d1616 6
a1621 1
   /* Set up the low priority ring buffer.
d1623 14
a1636 2
   OUTREG(LP_RING + RING_TAIL, 0 );
   OUTREG(LP_RING + RING_HEAD, 0 );
d1638 15
a1652 2
   pI810->LpRing.head = 0;
   pI810->LpRing.tail = 0;
d1654 63
a1716 4
   temp = INREG(LP_RING + RING_START);
   temp &= ~(START_ADDR);
   temp |= i830Reg->LprbStart;
   OUTREG(LP_RING + RING_START, temp );
d1718 6
a1723 5
   temp = INREG(LP_RING + RING_LEN);
   temp &= ~(I830_RING_NR_PAGES | RING_REPORT_MASK | RING_VALID_MASK);
   temp |= i830Reg->LprbLen;
   OUTREG(LP_RING + RING_LEN, temp );
}
d1725 8
a1732 4
static void I830SetFenceRegisters(ScrnInfoPtr pScrn, I830RegPtr i830Reg)
{
   I810Ptr pI810 = I810PTR(pScrn);
   int i;
d1734 6
a1739 4
   for (i = 0 ; i < 8 ; i++) {
      OUTREG( FENCE+i*4, i830Reg->Fence[i] );
      if (I810_DEBUG & DEBUG_VERBOSE_VGA)
	 ErrorF("Fence Register : %x\n",  i830Reg->Fence[i]);
a1740 1
}
d1742 2
a1743 5
void
I830BIOSSetRegisters(ScrnInfoPtr pScrn, int mode)
{
   I810Ptr pI810 = I810PTR(pScrn);
   I830RegPtr i830Reg;
d1745 7
a1751 2
   if(mode == SET_SAVED_MODE) {
      i830Reg = &pI810->i830_SavedReg;
d1753 17
a1769 1
      i830Reg = &pI810->i830_ModeReg;
d1771 11
d1783 9
a1791 3
   I830SetRingRegisters(pScrn, i830Reg);
   I830SetFenceRegisters(pScrn, i830Reg);
}
d1793 12
a1804 5
Bool
I830VESAGetVBEMode(ScrnInfoPtr pScrn, int *mode)
{
   I810Ptr pI810;
   VESAPtr pVesa;
d1806 2
a1807 2
   pI810 = I810PTR(pScrn);
   pVesa = pI810->vesa;
d1809 3
a1811 2
   pVesa->pInt->num = 0x10;
   pVesa->pInt->ax = 0x4f03;
d1813 2
a1814 1
   xf86ExecX86int10_wrapper(pVesa->pInt, pScrn);
d1816 19
a1834 2
   if (pVesa->pInt->ax == 0x4f) {
      *mode = pVesa->pInt->bx;
d1836 5
a1840 1
      return TRUE;
d1843 4
a1846 2
   return FALSE;
}
d1848 6
a1853 6
/* At the moment some of the BIOS vesa mode sets doesn't seem to work, so
 * we set those modes using the legacy BIOS calls */
Bool I830VESASetVBEMode (ScrnInfoPtr pScrn,int mode,CRTCInfoBlock *block)
{
   I810Ptr pI810;
   VESAPtr pVesa;
d1855 2
a1856 2
   pI810 = I810PTR (pScrn);
   pVesa = pI810->vesa;
d1858 8
a1865 1
   DPRINTF(PFX,"Setting mode 0x%.8x\n",mode);
d1867 8
a1874 28
   pVesa->pInt->num = 0x10;
   switch (mode)
	 {
	  case 0x0118:
		pVesa->pInt->ax = 0x0054;
		xf86ExecX86int10_wrapper (pVesa->pInt,pScrn);
		return (TRUE);
	  case 0x011a:
		pVesa->pInt->ax = 0x0049;
		xf86ExecX86int10_wrapper (pVesa->pInt,pScrn);
		return (TRUE);
	  case 0x4003:
	  case 0x03:
		pVesa->pInt->ax = 0x0003;
		xf86ExecX86int10_wrapper (pVesa->pInt,pScrn);
		return (TRUE);
	  default:
		pVesa->pInt->ax = 0x4f02;
		pVesa->pInt->bx = mode & ~(1 << 11);
/* This doesn't work. The BIOS is f**cked */
#if 0
		if (block != NULL)
		  {
			 pVesa->pInt->bx |= 1 << 11;
			 memcpy (pVesa->block,block,sizeof (CRTCInfoBlock));
			 pVesa->pInt->es = SEG_ADDR (pVesa->page);
			 pVesa->pInt->di = SEG_OFF (pVesa->page);
		  }
a1875 4
		xf86ExecX86int10_wrapper (pVesa->pInt,pScrn);
		return (pVesa->pInt->ax == 0x004f);
	 }
}
d1877 85
a1961 4
Bool I830VESASaveRestore (ScrnInfoPtr pScrn,int function)
{
   I810Ptr pI810;
   VESAPtr pVesa;
d1963 1
a1963 2
   pI810 = I810PTR (pScrn);
   pVesa = pI810->vesa;
d1965 5
a1969 1
   if(MODE_QUERY < 0 || function > MODE_RESTORE) return (FALSE);
d1971 42
a2012 1
   /* Insure that if the Ring is active we are Synced */
d2014 71
a2084 5
#if 0
   if(pI810->AccelInfoRec != NULL)
	 {
		I810RefreshRing (pScrn);
		I810Sync (pScrn);
d2086 2
d2090 49
a2138 28
   /* FIXME: Workaround for 1600x1200 mode set problem */
#if 1
   if (function == MODE_RESTORE) {
	   int thisMode;
	   I830VESAGetVBEMode (pScrn,&thisMode);

	   DPRINTF (PFX,"Current mode: 0x%.8x\n",thisMode);

	   thisMode &= 0xff;

	   if (thisMode == 0x3a || thisMode == 0x4a || thisMode == 0x4b || thisMode == 0x5a || /* 1600x1200 */
		   thisMode == 0x38 || thisMode == 0x48 || thisMode == 0x49 || thisMode == 0x58) {	/* 1280x1024 */
		   DPRINTF (PFX,"Doing 1600x1200 / 1280x1024 mode hack\n");

		   /* first we restore everything the way we're supposed to do it */
		   I830VESASetVBEMode (pScrn,pVesa->stateMode,NULL);
		   RestoreFonts (pScrn);
		   I830BIOSSetRegisters (pScrn,SET_SAVED_MODE);

		   /* now we fake a 800x600x8 mode save and restore */
 		   I830VESASetVBEMode (pScrn,pVesa->stateMode,NULL);
		   I830BIOSSaveRegisters (pScrn);
		   SaveFonts (pScrn);
		   I830VESASetVBEMode (pScrn,0xc032,NULL);
		   I830VESASetVBEMode (pScrn,pVesa->stateMode,NULL);
		   RestoreFonts (pScrn);
		   I830BIOSSetRegisters (pScrn,SET_SAVED_MODE);
		   I830VESASetVBEMode (pScrn,pVesa->stateMode,NULL);
d2140 25
a2164 2
		   return (TRUE);
	   }
a2165 1
#endif
d2167 6
a2172 17
#if 1
   /* This is a workaround that is needed to avoid a bug in VESA Save/Restore,
    * I will remove it as soon as the problem is fixed in the BIOS.
    * Basically it is a problem with 0x4f04 in that it corrupts the
    * GATT table after it has been executed.  We are working around this
    * by just setting the BIOS mode to the save one.  This is not completely
    * correct behavior, especially since it doesn't reset all the registers
    * to their correct state (if something other than the BIOS has set the
    * mode.)
    */

   if(function == MODE_RESTORE) {
	   I830VESASetVBEMode (pScrn,pVesa->stateMode,NULL);
	   RestoreFonts (pScrn);
	   I830BIOSSetRegisters (pScrn,SET_SAVED_MODE);
	   I830VESASetVBEMode (pScrn,pVesa->stateMode,NULL);
	   return (TRUE);
d2176 2
a2177 33
   /* Save the accel and fence state */
   if(function == MODE_SAVE) I830BIOSSaveRegisters (pScrn);

   /* Query amount of memory to save state */
   if(function == MODE_QUERY || (function == MODE_SAVE && pVesa->state == NULL))
	 {
		int npages;

		/* Make sure we save at least this information in case of failure */
		I830VESAGetVBEMode (pScrn,&pVesa->stateMode);
		SaveFonts (pScrn);

		if (pVesa->major > 1)
		  {
			 pVesa->pInt->num = 0x10;
			 pVesa->pInt->ax = 0x4f04;
			 pVesa->pInt->dx = 0;
			 pVesa->pInt->cx = 0x000f;
			 xf86ExecX86int10_wrapper (pVesa->pInt,pScrn);
			 if(pVesa->pInt->ax != 0x4f) return (FALSE);

			 npages = (pVesa->pInt->bx * 64) / 4096 + 1;
			 if ((pVesa->state = xf86Int10AllocPages (pVesa->pInt,npages,&pVesa->statePage)) == NULL)
			   {
				  xf86DrvMsg (pScrn->scrnIndex,X_ERROR,"Cannot allocate memory to save SVGA state.\n");
				  return (FALSE);
			   }
			 DPRINTF (PFX,
					  "BIOS returned bx == %d\n"
					  "therefore I need npages == %d (4k pages)\n",
					  pVesa->pInt->bx,npages);
		  }
	 }
d2179 37
d2217 2
a2218 41
   /* Save/Restore Super VGA state */
   if(function != MODE_QUERY)
	 {
		int ax_reg = 0;

		if (pVesa->major > 1)
		  {
			 pVesa->pInt->num = 0x10;
			 pVesa->pInt->ax = 0x4f04;
			 pVesa->pInt->dx = function;
			 pVesa->pInt->cx = 0x000f;

			 if (function == MODE_RESTORE)
			   memcpy (pVesa->state,pVesa->pstate,pVesa->stateSize);

			 pVesa->pInt->es = SEG_ADDR (pVesa->statePage);
			 pVesa->pInt->bx = SEG_OFF (pVesa->statePage);
			 xf86ExecX86int10_wrapper (pVesa->pInt,pScrn);
			 ax_reg = pVesa->pInt->ax;
		  }

		if(function == MODE_RESTORE)
		  {
			 I830VESASetVBEMode (pScrn,pVesa->stateMode,NULL);
			 RestoreFonts (pScrn);
			 I830BIOSSetRegisters (pScrn,SET_SAVED_MODE);
		  }

		if (pVesa->major > 1)
		  {
			 if (ax_reg != 0x4f) return (FALSE);

			 if (function == MODE_SAVE && pVesa->pstate == NULL)
			   {
				  /* don't rely on the memory not being touched */
				  pVesa->stateSize = pVesa->pInt->bx * 64;
				  pVesa->pstate = xalloc (pVesa->stateSize);
				  memcpy (pVesa->pstate,pVesa->state,pVesa->stateSize);
			   }
		  }
	 }
d2221 107
a2327 2
   /* Now that the modes setup, we can do our I830 specific fu */
   if(function == MODE_RESTORE) I830BIOSSetRegisters (pScrn,SET_SAVED_MODE);
d2329 5
a2333 1
   return (TRUE);
d2336 2
a2337 3
Bool
I830VESASetGetLogicalScanlineLength(ScrnInfoPtr pScrn, int command, int width,
				    int *pixels, int *bytes, int *max)
d2339 5
a2343 1
   I810Ptr pI810;
d2346 13
a2358 2
   pI810 = I810PTR(pScrn);
   pVesa = pI810->vesa;
d2360 2
a2361 2
   if(command < SCANWID_SET || command > SCANWID_GET_MAX)
     return FALSE;
d2363 34
a2396 14
   pVesa->pInt->num = 0x10;
   pVesa->pInt->ax = 0x4f06;
   pVesa->pInt->bx = command;
   if(command == SCANWID_SET || command == SCANWID_SET_BYTES)
     pVesa->pInt->cx = width;
   xf86ExecX86int10_wrapper(pVesa->pInt, pScrn);

   if(pVesa->pInt->ax != 0x4f)
     return FALSE;

   if(command == SCANWID_GET || command == SCANWID_GET_MAX) {
      if(pixels) *pixels = pVesa->pInt->cx;
      if(bytes) *bytes = pVesa->pInt->bx;
      if(max) *max = pVesa->pInt->dx;
d2402 2
a2403 2
int
I830VESASetGetDACPaletteFormat(ScrnInfoPtr pScrn, int bits)
d2405 4
a2408 1
   I810Ptr pI810;
d2410 1
d2412 1
a2412 2
   pI810 = I810PTR(pScrn);
   pVesa = pI810->vesa;
d2414 1
a2414 5
   pVesa->pInt->num = 0x10;
   pVesa->pInt->ax = 0x4f08;
   if(!bits) pVesa->pInt->bx = 0x01;
   else pVesa->pInt->bx = (bits & 0x00ff) << 8;
   xf86ExecX86int10_wrapper(pVesa->pInt, pScrn);
d2416 7
a2422 1
   if(pVesa->pInt->ax != 0x4f) return 0;
d2424 59
a2482 1
   return (bits != 0 ? bits : (pVesa->pInt->bx >> 8) & 0x00ff);
d2485 6
a2490 1
static Bool I830VESASetMode (ScrnInfoPtr pScrn,DisplayModePtr pMode)
d2492 33
a2524 4
   I810Ptr pI810;
   VESAPtr pVesa;
   ModeInfoData *data;
   int mode;
d2526 1
a2526 2
   pI810 = I810PTR (pScrn);
   pVesa = pI810->vesa;
d2528 1
a2528 1
   data = (ModeInfoData *) pMode->Private;
d2533 214
a2746 7
#ifdef XF86DRI
   if(pI810->directRenderingEnabled)
	 {
		DRILock (screenInfo.screens[pScrn->scrnIndex],0);
		pI810->LockHeld = 1;
	 }
#endif
d2748 2
a2749 17
   if (I830VESASetVBEMode (pScrn,mode,data->block) == FALSE)
	 {
		if ((data->block || (data->mode & (1 << 11))) &&
			I830VESASetVBEMode (pScrn,(mode & ~(1 << 11)),NULL) == TRUE)
		  {
			 xf86DrvMsg (pScrn->scrnIndex,X_WARNING,"Set VBE Mode rejected this modeline. Trying current mode instead!\n");
			 DPRINTF (PFX,"OOPS!\n");
			 xfree (data->block);
			 data->block = NULL;
			 data->mode &= ~(1 << 11);
		  }
		else
		  {
			 xf86DrvMsg (pScrn->scrnIndex,X_ERROR,"Set VBE Mode failed!\n");
			 return (FALSE);
		  }
	 }
d2751 7
a2757 61
   /* test if CRT display is present */
   pVesa->pInt->num = 0x10;
   pVesa->pInt->ax = 0x5f55;
   xf86ExecX86int10_wrapper (pVesa->pInt,pScrn);

   /* is this a CRT? */
   if (pVesa->pInt->ax == 0x005f && pVesa->pInt->bx != 0x0002)
	 {
		DPRINTF (PFX,
				 "data->data = {\n"
				 "   XResolution: %d\n"
				 "   YResolution: %d\n"
				 "}\n",
				 data->data->XResolution,data->data->YResolution);
		if (data->block != NULL)
		  DPRINTF (PFX,
				   "data->block = {\n"
				   "       HorizontalTotal: %d\n"
				   "   HorizontalSyncStart: %d\n"
				   "     HorizontalSyncEnd: %d\n"
				   "         VerticalTotal: %d\n"
				   "     VerticalSyncStart: %d\n"
				   "       VerticalSyncEnd: %d\n"
				   "                 Flags: %d\n"
				   "            PixelClock: %d\n"
				   "           RefreshRate: %d\n"
				   "}\n",
				   data->block->HorizontalTotal,data->block->HorizontalSyncStart,data->block->HorizontalSyncEnd,
				   data->block->VerticalTotal,data->block->VerticalSyncStart,data->block->VerticalSyncEnd,
				   data->block->Flags,data->block->PixelClock,data->block->RefreshRate / 100);

		/* make double sure it's not an LCD */
		pVesa->pInt->num = 0x10;
		pVesa->pInt->ax = 0x5f64;
		pVesa->pInt->bx = 0x0100;
		xf86ExecX86int10_wrapper (pVesa->pInt,pScrn);
		if (data->data != NULL && data->block != NULL && pVesa->pInt->ax == 0x005f && !(pVesa->pInt->cx & 0x0008))
		  {
			 int i;
			 static const int VesaRefresh[] = { 43, 56, 60, 70, 72, 75, 85, 100, 120, -1 };

			 for (i = 0; VesaRefresh[i] != -1 && VesaRefresh[i] != data->block->RefreshRate / 100; i++) ;

			 if (VesaRefresh[i] == data->block->RefreshRate / 100)
			   {
				  DPRINTF (PFX,
						   "Setting refresh rate to %dHz for mode %d\n",
						   VesaRefresh[i],
						   mode & 0xff);

				  pVesa->pInt->num = 0x10;
				  pVesa->pInt->ax = 0x5f05;
				  pVesa->pInt->bx = mode & 0xff;
				  pVesa->pInt->cx = 1 << i;
				  xf86ExecX86int10_wrapper (pVesa->pInt,pScrn);

				  if (pVesa->pInt->ax != 0x5f)
					xf86DrvMsg (pScrn->scrnIndex,X_WARNING,"Failed to set refresh rate to %dHz!\n",VesaRefresh[i]);
			   }
		  }
	 }
d2759 2
a2760 2
   if (data->data->XResolution != pScrn->displayWidth)
	 I830VESASetLogicalScanline (pScrn,pScrn->displayWidth);
d2762 6
a2767 2
   if (pScrn->bitsPerPixel >= 8 && pVesa->vbeInfo->Capabilities[0] & 0x01)
	 I830VESASetGetDACPaletteFormat (pScrn,8);
d2769 4
a2772 2
   I830BIOSSetRegisters (pScrn,SET_CURRENT_MODE);
   I810SetRingRegs (pScrn);
d2775 4
a2778 5
   if (pI810->directRenderingEnabled)
	 {
		DRIUnlock (screenInfo.screens[pScrn->scrnIndex]);
		pI810->LockHeld = 0;
	 }
d2782 1
a2782 1
   return (TRUE);
d2785 2
a2786 3
CARD32 *
I830VESASetGetPaletteData(ScrnInfoPtr pScrn, Bool set, int first, int num,
			  CARD32 *data, Bool secondary, Bool wait_retrace)
d2788 3
a2790 2
   I810Ptr pI810;
   VESAPtr pVesa;
d2792 3
a2794 2
   pI810 = I810PTR(pScrn);
   pVesa = pI810->vesa;
d2796 6
a2801 5
   pVesa->pInt->num = 0x10;
   pVesa->pInt->ax = 0x4f09;

   if(!secondary) pVesa->pInt->bx = set && wait_retrace ? 0x80 : set ? 0 : 1;
   else pVesa->pInt->bx = set ? 2 : 3;
d2803 2
a2804 4
   pVesa->pInt->cx = num;
   pVesa->pInt->dx = first;
   pVesa->pInt->es = SEG_ADDR(pVesa->page);
   pVesa->pInt->di = SEG_OFF(pVesa->page);
d2806 1
a2806 1
   if(set) memcpy(pVesa->block, data, num * sizeof(CARD32));
d2808 4
a2811 20
   xf86ExecX86int10_wrapper(pVesa->pInt, pScrn);

   if(pVesa->pInt->ax != 0x4f) return NULL;

   if(set) return data;

   data = xalloc(num * sizeof(CARD32));
   memcpy(data, pVesa->block, num * sizeof(CARD32));

   return data;
}

Bool
I830BIOSInitializeFirstMode(int scrnIndex)
{
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I810Ptr pI810 = I810PTR(pScrn);
   VESAPtr pVesa = pI810->vesa;
   I830RegPtr i830Reg = &pI810->i830_ModeReg;
   int i;
d2813 2
a2814 2
   for (i = 0 ; i < 8 ; i++)
     i830Reg->Fence[i] = 0;
d2816 1
a2816 19
   /* Setup the ring buffer */
   i830Reg->LprbTail = 0;
   i830Reg->LprbHead = 0;
   i830Reg->LprbStart = pI810->LpRing.mem.Start;

   if (i830Reg->LprbStart) 
     i830Reg->LprbLen = ((pI810->LpRing.mem.Size-4096) |
			 RING_NO_REPORT | RING_VALID);
   else
     i830Reg->LprbLen = RING_INVALID;

   /* save current video state */ 
   if(!I830VESASaveRestore(pScrn, MODE_SAVE)) return FALSE;
   pVesa->savedPal = I830VESASetGetPaletteData(pScrn, FALSE, 0, 256,
					      NULL, FALSE, FALSE);

   /* set first video mode */
   if(!I830VESASetMode(pScrn, pScrn->currentMode))
     return FALSE;
d2818 1
a2818 1
   I830BIOSAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
d2820 2
a2821 1
   return TRUE;
d2825 2
a2826 1
static void dump_DSPACNTR (ScrnInfoPtr pScrn)
d2828 1
a2828 1
   I810Ptr pI810 = I810PTR (pScrn);
d2832 2
a2833 2
   tmp = INREG (0x70180);
   fprintf (stderr,"Display A Plane Control Register (0x%.8x)\n",tmp);
d2836 1
a2836 1
	 fprintf (stderr,"   Display Plane A (Primary) Enable\n");
d2838 1
a2838 1
	 fprintf (stderr,"   Display Plane A (Primary) Disabled\n");
d2841 1
a2841 1
	 fprintf (stderr,"   Display A pixel data is gamma corrected\n");
d2843 1
a2843 1
	 fprintf (stderr,"   Display A pixel data bypasses gamma correction logic (default)\n");
d2845 24
a2868 25
   switch ((tmp & 0x3c000000) >> 26)	/* bit 29:26 */
	 {
	  case 0x00:
	  case 0x01:
	  case 0x03:
		fprintf (stderr,"   Reserved\n");
		break;
	  case 0x02:
		fprintf (stderr,"   8-bpp Indexed\n");
		break;
	  case 0x04:
		fprintf (stderr,"   15-bit (5-5-5) pixel format (Targa compatible)\n");
		break;
	  case 0x05:
		fprintf (stderr,"   16-bit (5-6-5) pixel format (XGA compatible)\n");
		break;
	  case 0x06:
		fprintf (stderr,"   32-bit format (X:8:8:8)\n");
		break;
	  case 0x07:
		fprintf (stderr,"   32-bit format (8:8:8:8)\n");
		break;
	  default:
		fprintf (stderr,"   Unknown - Invalid register value maybe?\n");
	 }
d2871 1
a2871 1
	 fprintf (stderr,"   Stereo Enable\n");
d2873 1
a2873 1
	 fprintf (stderr,"   Stereo Disable\n");
d2876 1
a2876 1
	 fprintf (stderr,"   Display A, Pipe B Select\n");
d2878 1
a2878 1
	 fprintf (stderr,"   Display A, Pipe A Select\n");
d2881 1
a2881 1
	 fprintf (stderr,"   Source key is enabled\n");
d2883 1
a2883 1
	 fprintf (stderr,"   Source key is disabled\n");
d2885 12
a2896 13
   switch ((tmp & 0x00300000) >> 20)	/* bit 21:20 */
	 {
	  case 0x00:
		fprintf (stderr,"   No line duplication\n");
		break;
	  case 0x01:
		fprintf (stderr,"   Line/pixel Doubling\n");
		break;
	  case 0x02:
	  case 0x03:
		fprintf (stderr,"   Reserved\n");
		break;
	 }
d2899 1
a2899 1
	 fprintf (stderr,"   Stereo output is high during second image\n");
d2901 1
a2901 1
	 fprintf (stderr,"   Stereo output is high during first image\n");
d2904 2
a2905 1
static void dump_DSPBCNTR (ScrnInfoPtr pScrn)
d2907 1
a2907 1
   I810Ptr pI810 = I810PTR (pScrn);
d2911 2
a2912 2
   tmp = INREG (0x71180);
   fprintf (stderr,"Display B/Sprite Plane Control Register (0x%.8x)\n",tmp);
d2915 1
a2915 1
	 fprintf (stderr,"   Display B/Sprite Enable\n");
d2917 1
a2917 1
	 fprintf (stderr,"   Display B/Sprite Disable\n");
d2920 1
a2920 1
	 fprintf (stderr,"   Display B pixel data is gamma corrected\n");
d2922 1
a2922 1
	 fprintf (stderr,"   Display B pixel data bypasses gamma correction logic (default)\n");
d2924 24
a2947 25
   switch ((tmp & 0x3c000000) >> 26)	/* bit 29:26 */
	 {
	  case 0x00:
	  case 0x01:
	  case 0x03:
		fprintf (stderr,"   Reserved\n");
		break;
	  case 0x02:
		fprintf (stderr,"   8-bpp Indexed\n");
		break;
	  case 0x04:
		fprintf (stderr,"   15-bit (5-5-5) pixel format (Targa compatible)\n");
		break;
	  case 0x05:
		fprintf (stderr,"   16-bit (5-6-5) pixel format (XGA compatible)\n");
		break;
	  case 0x06:
		fprintf (stderr,"   32-bit format (X:8:8:8)\n");
		break;
	  case 0x07:
		fprintf (stderr,"   32-bit format (8:8:8:8)\n");
		break;
	  default:
		fprintf (stderr,"   Unknown - Invalid register value maybe?\n");
	 }
d2950 1
a2950 1
	 fprintf (stderr,"   Stereo is enabled and both start addresses are used in a two frame sequence\n");
d2952 1
a2952 1
	 fprintf (stderr,"   Stereo disable and only a single start address is used\n");
d2955 1
a2955 1
	 fprintf (stderr,"   Display B/Sprite, Pipe B Select\n");
d2957 1
a2957 1
	 fprintf (stderr,"   Display B/Sprite, Pipe A Select\n");
d2960 1
a2960 1
	 fprintf (stderr,"   Sprite source key is enabled\n");
d2962 1
a2962 1
	 fprintf (stderr,"   Sprite source key is disabled (default)\n");
d2964 12
a2975 13
   switch ((tmp & 0x00300000) >> 20)	/* bit 21:20 */
	 {
	  case 0x00:
		fprintf (stderr,"   No line duplication\n");
		break;
	  case 0x01:
		fprintf (stderr,"   Line/pixel Doubling\n");
		break;
	  case 0x02:
	  case 0x03:
		fprintf (stderr,"   Reserved\n");
		break;
	 }
d2978 1
a2978 1
	 fprintf (stderr,"   Stereo output is high during second image\n");
d2980 1
a2980 1
	 fprintf (stderr,"   Stereo output is high during first image\n");
d2983 1
a2983 1
	 fprintf (stderr,"   Alpha transfer mode enabled\n");
d2985 1
a2985 1
	 fprintf (stderr,"   Alpha transfer mode disabled\n");
d2988 1
a2988 1
	 fprintf (stderr,"   Sprite is above overlay\n");
d2990 1
a2990 1
	 fprintf (stderr,"   Sprite is above display A (default)\n");
d2993 2
a2994 1
static void dump_registers (ScrnInfoPtr pScrn)
d2996 1
a2996 1
   I810Ptr pI810 = I810PTR (pScrn);
a2997 1
   fprintf (stderr,"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");
d2999 4
a3002 2
   dump_DSPACNTR (pScrn);
   dump_DSPBCNTR (pScrn);
d3004 2
a3005 2
   fprintf (stderr,"0x71400 == 0x%.8x\n",INREG(0x71400));
   fprintf (stderr,"0x70008 == 0x%.8x\n",INREG(0x70008));
d3007 1
a3007 1
	 fprintf (stderr,"0x%x == 0x%.8x\n",i,INREG(i));
d3009 1
a3009 1
   fprintf (stderr,"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");
d3013 1
a3013 1
Bool
d3018 1
a3018 2
   I810Ptr pI810;
   VESAPtr pVesa;
d3020 3
d3025 1
a3025 2
   pI810 = I810PTR(pScrn);
   pVesa = pI810->vesa;
d3028 13
d3042 6
a3047 4
   if(!xf86SetDefaultVisual(pScrn, -1)) return FALSE;
   if(pScrn->bitsPerPixel > 8) {
      if(!miSetVisualTypes(pScrn->depth, TrueColorMask,
			   pScrn->rgbBits, TrueColor)) return FALSE;
d3049 41
a3089 3
      if(!miSetVisualTypes(pScrn->depth,
			   miGetDefaultVisualMask(pScrn->depth),
			   pScrn->rgbBits, pScrn->defaultVisual)) return FALSE;
d3091 18
a3108 1
   if (!miSetPixmapDepths()) return FALSE;
d3112 7
a3118 2
    * Setup DRI after visuals have been established, but before cfbScreenInit
    * is called.   cfbScreenInit will eventually call into the drivers
d3122 19
a3140 6
   if (!xf86ReturnOptValBool(I810AvailableOptions(0,0), OPTION_NOACCEL, 
			     FALSE) &&
       xf86ReturnOptValBool(I810AvailableOptions(0,0), OPTION_DRI, TRUE)) {
      pI810->directRenderingEnabled = I830DRIScreenInit(pScreen); 
   } else {
      pI810->directRenderingEnabled = FALSE;
d3142 1
d3144 11
a3154 2
   pI810->directRenderingEnabled = FALSE;
   if(!I810AllocateGARTMemory( pScrn )) 
d3156 3
a3158 1
   if(!I810AllocateFront(pScrn))
d3160 6
d3168 6
a3173 2
	DPRINTF(PFX,"assert( if(!I810MapMem(pScrn)) )\n");
   if(!I810MapMem(pScrn)) return FALSE;
d3175 2
a3176 2
   pScrn->memPhysBase = (unsigned long)pI810->FbBase;
   pScrn->fbOffset = 0;
d3178 1
a3178 1
   vgaHWSetMmioFuncs(hwp, pI810->MMIOBase, 0);
d3180 6
a3185 2
	DPRINTF(PFX,"assert( if(!vgaHWMapMem(pScrn)) )\n");
   if(!vgaHWMapMem(pScrn)) return FALSE;
d3187 10
a3196 10
   /* Handle Setup of the mode here */
	DPRINTF(PFX,"assert( if(!(I830BIOSInitializeFirstMode(scrnIndex))) )\n");
   if(!(I830BIOSInitializeFirstMode(scrnIndex))) return FALSE;

	DPRINTF(PFX,"assert( if(!fbScreenInit(pScreen, ...) )\n");
   if(!fbScreenInit(pScreen, pI810->FbBase + pScrn->fbOffset,
		        pScrn->virtualX, pScrn->virtualY,
                        pScrn->xDpi, pScrn->yDpi,
                        pScrn->displayWidth, pScrn->bitsPerPixel))
       return FALSE;
d3198 1
a3198 1
   if(pScrn->bitsPerPixel > 8) {
d3201 2
a3202 2
      while(--visual >= pScreen->visuals) {
	 if((visual->class | DynamicClass) == DirectColor) {
d3213 2
d3217 2
a3218 15
#ifdef XF86DRI
   if(pI810->LpRing.mem.Start == 0 && pI810->directRenderingEnabled) {
      pI810->directRenderingEnabled = 0;
      I830DRICloseScreen(pScreen);
   }

   if(!pI810->directRenderingEnabled) {
      pI810->DoneFrontAlloc = FALSE;
	   DPRINTF(PFX,"assert( if(!I810AllocateGARTMemory( pScrn )) )\n");
      if(!I810AllocateGARTMemory( pScrn ))
         return FALSE;
	   DPRINTF(PFX,"assert( if(!I810AllocateFront(pScrn)) )\n");
      if(!I810AllocateFront(pScrn))
	 return FALSE;
   }
d3221 3
a3223 4
   I810DGAInit(pScreen);

	DPRINTF(PFX,"assert( if(!xf86InitFBManager(pScreen, &(pI810->FbMemBox))) )\n");
   if(!xf86InitFBManager(pScreen, &(pI810->FbMemBox))) {
d3225 1
a3225 1
                 "Failed to init memory manager\n");
d3229 4
a3232 8
   if(!xf86ReturnOptValBool(I830BIOSOptions, OPTION_NOACCEL, FALSE)) {
      if(pI810->LpRing.mem.Size != 0) {
         I810SetRingRegs( pScrn );

         if(!I830AccelInit(pScreen)) {
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                       "Hardware acceleration initialization failed\n");
         }
d3241 7
a3247 7
   if(!xf86ReturnOptValBool(I830BIOSOptions, OPTION_SW_CURSOR, FALSE))
	 {
		xf86DrvMsg (pScrn->scrnIndex,X_INFO,"Initializing HW Cursor\n");
		if(!I810CursorInit(pScreen))
		  xf86DrvMsg (pScrn->scrnIndex,X_ERROR,"Hardware cursor initialization failed\n");
	 }
   else xf86DrvMsg (pScrn->scrnIndex,X_INFO,"Initializing SW Cursor!\n");
d3249 3
a3251 2
	DPRINTF(PFX,"assert( if(!miCreateDefColormap(pScreen)) )\n");
   if(!miCreateDefColormap(pScreen)) return FALSE;
d3253 5
a3257 2
	DPRINTF(PFX,"assert( if(!vgaHWHandleColormaps(pScreen)) )\n");
   if(!vgaHWHandleColormaps(pScreen)) return FALSE;
a3258 1
#ifdef DPMSExtension
d3260 5
a3266 2
   /* Init video here - Not supported as of yet */

d3268 2
a3269 5
   if(pI810->directRenderingEnabled) {
      pI810->directRenderingEnabled = I830DRIFinishScreenInit(pScreen);
      if(!pI810->directRenderingEnabled) {
	 pI810->agpAcquired2d = FALSE;
      }
d3273 3
a3275 1
   if(pI810->directRenderingEnabled) {
a3277 1
#ifdef XF86DRI
a3278 4
#if 0
      I830EmitInvarientState2(pScrn);
#endif
#endif
d3280 1
a3280 1
      if(pI810->agpAcquired2d == TRUE) {
d3282 1
a3282 1
      } else {
a3283 2
	 return FALSE;
      }
d3285 4
a3288 1
   
d3290 1
a3290 1
   pI810->CloseScreen = pScreen->CloseScreen;
d3295 1
a3295 1
/*
d3297 2
a3298 1
   dump_registers (pScrn);
a3299 12
*/
   return TRUE;
}

Bool
I830VESASetDisplayStart(ScrnInfoPtr pScrn, int x, int y, Bool wait_retrace)
{
   I810Ptr pI810;
   VESAPtr pVesa;

   pI810 = I810PTR(pScrn);
   pVesa = pI810->vesa;
d3301 3
a3303 8
   pVesa->pInt->num = 0x10;
   pVesa->pInt->ax = 0x4f07;
   pVesa->pInt->bx = wait_retrace ? 0x80 : 0x00;
   pVesa->pInt->cx = x;
   pVesa->pInt->dx = y;
   xf86ExecX86int10_wrapper(pVesa->pInt, pScrn);

   if(pVesa->pInt->ax != 0x4f) return FALSE;
d3307 1
a3307 1
void
d3311 2
d3315 7
a3321 1
   I830VESASetDisplayStart(pScrn, x, y, TRUE);
d3324 1
a3324 1
void
d3329 17
a3345 1
       vgaHWFreeHWRec(xf86Screens[scrnIndex]);
d3348 10
a3357 6
void
I830BIOSLeaveVT (int scrnIndex,int flags) {
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
	vgaHWPtr hwp = VGAHWPTR (pScrn);
#if defined(XF86DRI) || 0
	I810Ptr pI810 = I810PTR (pScrn);
d3360 7
a3366 1
	DPRINTF (PFX,"Leave VT\n");
d3369 5
a3373 5
	if (pI810->directRenderingEnabled) {
		DPRINTF (PFX,"calling dri lock\n");
		DRILock (screenInfo.screens[scrnIndex],0);
		pI810->LockHeld = 1;
	}
d3376 3
a3378 6
#if 0
	if (pI810->AccelInfoRec != NULL) {
		DPRINTF (PFX,"syncing ring buffer\n");
		I810Sync (pScrn);
		DO_RING_IDLE ();
	}
d3381 7
a3387 1
	I830VESASaveRestore (pScrn,MODE_RESTORE);
d3389 8
a3396 1
	if (!I810UnbindGARTMemory (pScrn)) return;
d3398 1
a3398 2
	vgaHWLock(hwp);
}
d3400 2
a3401 4
Bool
I830BIOSEnterVT (int scrnIndex,int flags) {
	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
	I810Ptr pI810 = I810PTR (pScrn);
d3403 3
a3405 1
	DPRINTF (PFX,"Enter VT\n");
d3407 10
a3416 1
	if (!I810BindGARTMemory (pScrn)) return FALSE;
d3418 4
a3421 6
#ifdef XF86DRI
	if (pI810->directRenderingEnabled) {
		DPRINTF (PFX,"calling dri unlock\n");
		DRIUnlock (screenInfo.screens[scrnIndex]);
		pI810->LockHeld = 0;
	}
d3424 4
a3427 14
	/* FIXME: Is this really necessary? */
#if 0
	VESAPtr pVesa = pI810->vesa;
	/* Switch to configured display device */
	pVesa->pInt->num = 0x10;
	pVesa->pInt->ax = 0x5f64;
	pVesa->pInt->bx = 0x0001;
	pVesa->pInt->cx = (CARD16) pI810->configured_device;
	xf86ExecX86int10_wrapper (pVesa->pInt,pScrn);

	if (pVesa->pInt->ax != 0x005f) {
		xf86DrvMsg (pScrn->scrnIndex,X_INFO,"Failed to switch to configured display device\n");
		return FALSE;
	}
d3430 8
a3437 2
	if (!I830VESASetMode (pScrn,pScrn->currentMode))
		return FALSE;
d3439 7
a3445 1
	I830BIOSAdjustFrame (scrnIndex,pScrn->frameX0,pScrn->frameY0,0);
d3447 5
a3451 6
#if 1
	if (pI810->AccelInfoRec != NULL) {
		DPRINTF (PFX,"syncing ring buffer\n");
		I810Sync (pScrn);
		DO_RING_IDLE ();
	}
d3454 1
a3454 1
	return TRUE;
d3457 1
a3457 1
Bool
d3460 39
a3498 2
   DPRINTF (PFX,"mode == %s\n",mode);
   return I830VESASetMode(xf86Screens[scrnIndex], mode);
d3501 2
a3502 2
Bool
I830BIOSSaveScreen(ScreenPtr pScreen, Bool unblack)
d3504 38
a3541 1
   return vgaHWSaveScreen(pScreen, unblack);
d3544 1
d3547 1
a3547 1
			     int flags)
d3549 2
a3550 2
   I810Ptr pI810 = I810PTR(pScrn);
   VESAPtr pVesa = pI810->vesa;
d3552 21
a3572 9
   pVesa->pInt->num = 0x10;
   pVesa->pInt->ax = 0x4f10;

   switch (PowerManagementMode) {
   case DPMSModeOn: pVesa->pInt->bx = 0x0001; break;
   case DPMSModeStandby: pVesa->pInt->bx = 0x0101; break;
   case DPMSModeSuspend: pVesa->pInt->bx = 0x0201; break;
   case DPMSModeOff: pVesa->pInt->bx = 0x0401; break;
   default: pVesa->pInt->bx = 0x0001; break;
a3573 2

   xf86ExecX86int10_wrapper(pVesa->pInt, pScrn);   
d3576 1
a3576 1
Bool
d3580 2
a3581 4
   vgaHWPtr hwp = VGAHWPTR(pScrn);
   I810Ptr pI810 = I810PTR(pScrn);
   VESAPtr pVesa = pI810->vesa;
   XAAInfoRecPtr infoPtr = pI810->AccelInfoRec;
d3583 1
d3585 3
a3587 3
   if (pI810->directRenderingEnabled) {
       I830DRICloseScreen(pScreen);
       pI810->directRenderingEnabled = FALSE;
d3592 1
a3592 9
      if(pI810->AccelInfoRec) {
	 I810Sync(pScrn);
	 DO_RING_IDLE();
      }
      I830VESASaveRestore(pScrn, MODE_RESTORE);
      I830VESASetGetPaletteData(pScrn, TRUE, 0, 256,
				pVesa->savedPal, FALSE, TRUE);
      I810UnbindGARTMemory(pScrn);
      vgaHWLock(hwp);
d3595 2
a3596 1
   I810UnmapMem(pScrn);
d3599 3
a3601 3
   if(pI810->ScanlineColorExpandBuffers) {
      xfree(pI810->ScanlineColorExpandBuffers);
      pI810->ScanlineColorExpandBuffers = 0;
d3604 3
a3606 3
   if(infoPtr) {
      if(infoPtr->ScanlineColorExpandBuffers)
	xfree(infoPtr->ScanlineColorExpandBuffers);
d3608 6
a3613 1
      pI810->AccelInfoRec=0;
d3616 17
a3632 3
   if(pI810->CursorInfoRec) {
      xf86DestroyCursorInfoRec(pI810->CursorInfoRec);
      pI810->CursorInfoRec=0;
d3634 9
d3644 12
a3655 5
   /* Free all allocated video ram.
    */
   pI810->SysMem = pI810->SavedSysMem;
   pI810->DcacheMem = pI810->SavedDcacheMem;
   pI810->DoneFrontAlloc = FALSE;
d3657 39
a3695 1
   xf86GARTCloseScreen(scrnIndex);
d3697 12
a3708 3
   pScrn->vtSema=FALSE;
   pScreen->CloseScreen = pI810->CloseScreen;
   return (*pScreen->CloseScreen)(scrnIndex, pScreen);
d3710 1
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_driver.c,v 1.49 2004/01/25 16:57:48 dawes Exp $ */
a4 1
Copyright © 2002 by David Dawes
d22 1
a22 1
THE COPYRIGHT HOLDERS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
d27 1
d30 1
a30 17
/*
 * Reformatted with GNU indent (2.2.8), using the following options:
 *
 *    -bad -bap -c41 -cd0 -ncdb -ci6 -cli0 -cp0 -ncs -d0 -di3 -i3 -ip3 -l78
 *    -lp -npcs -psl -sob -ss -br -ce -sc -hnl
 *
 * This provides a good match with the original i810 code and preferred
 * XFree86 formatting conventions.
 *
 * When editing this driver, please follow the existing formatting, and edit
 * with <TAB> characters expanded at 8-column intervals.
 */

/*
 * Authors: Jeff Hartmann <jhartmann@@valinux.com>
 *          Abraham van der Merwe <abraham@@2d3d.co.za>
 *          David Dawes <dawes@@xfree86.org>
d33 2
a34 3
/*
 * Mode handling is based on the VESA driver written by:
 * Paulo César Pereira de Andrade <pcpa@@conectiva.com.br>
d77 1
a77 1
 *          suspect this is a BIOS bug (hence the 1280x1024@@85Hz case)).
a88 37
/*
 *    07/2002 David Dawes
 *        - Add Intel(R) 855GM/852GM support.
 */
/*
 *    07/2002 David Dawes
 *        - Cleanup code formatting.
 *        - Improve VESA mode selection, and fix refresh rate selection.
 *        - Don't duplicate functions provided in 4.2 vbe modules.
 *        - Don't duplicate functions provided in the vgahw module.
 *        - Rewrite memory allocation.
 *        - Rewrite initialisation and save/restore state handling.
 *        - Decouple the i810 support from i830 and later.
 *        - Remove various unnecessary hacks and workarounds.
 *        - Fix an 845G problem with the ring buffer not in pre-allocated
 *          memory.
 *        - Fix screen blanking.
 *        - Clear the screen at startup so you don't see the previous session.
 *        - Fix some HW cursor glitches, and turn HW cursor off at VT switch
 *          and exit.
 *
 *    08/2002 Keith Whitwell
 *        - Fix DRI initialisation.
 */
/*
 *    08/2002 Alan Hourihane and David Dawes
 *        - Add XVideo support.
 */
/*
 *    10/2002 David Dawes
 *        - Add Intel(R) 865G support.
 */


#ifndef PRINT_MODE_INFO
#define PRINT_MODE_INFO 0
#endif
d103 1
a103 1
#include "regionstr.h"
a106 1
#include "vbeModes.h"
d108 1
a108 1
#include "i830.h"
a117 1
/* *INDENT-OFF* */
d119 2
a120 5
   {PCI_CHIP_I830_M,		"i830"},
   {PCI_CHIP_845_G,		"845G"},
   {PCI_CHIP_I855_GM,		"852GM/855GM"},
   {PCI_CHIP_I865_G,		"865G"},
   {-1,				NULL}
d124 2
a125 5
   {PCI_CHIP_I830_M,		PCI_CHIP_I830_M,	RES_SHARED_VGA},
   {PCI_CHIP_845_G,		PCI_CHIP_845_G,		RES_SHARED_VGA},
   {PCI_CHIP_I855_GM,		PCI_CHIP_I855_GM,	RES_SHARED_VGA},
   {PCI_CHIP_I865_G,		PCI_CHIP_I865_G,	RES_SHARED_VGA},
   {-1,				-1,			RES_UNDEFINED}
a127 18
/*
 * Note: "ColorKey" is provided for compatibility with the i810 driver.
 * However, the correct option name is "VideoKey".  "ColorKey" usually
 * refers to the tranparency key for 8+24 overlays, not for video overlays.
 */

typedef enum {
   OPTION_NOACCEL,
   OPTION_SW_CURSOR,
   OPTION_CACHE_LINES,
   OPTION_DRI,
   OPTION_PAGEFLIP,
   OPTION_XVIDEO,
   OPTION_VIDEO_KEY,
   OPTION_COLOR_KEY,
   OPTION_VBE_RESTORE
} I830Opts;

d129 7
a135 10
   {OPTION_NOACCEL,	"NoAccel",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_SW_CURSOR,	"SWcursor",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_CACHE_LINES,	"CacheLines",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_DRI,		"DRI",		OPTV_BOOLEAN,	{0},	TRUE},
   {OPTION_PAGEFLIP,	"PageFlip",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_XVIDEO,	"XVideo",	OPTV_BOOLEAN,	{0},	TRUE},
   {OPTION_COLOR_KEY,	"ColorKey",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_VIDEO_KEY,	"VideoKey",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_VBE_RESTORE,	"VBERestore",	OPTV_BOOLEAN,	{0},	FALSE},
   {-1,			NULL,		OPTV_NONE,	{0},	FALSE}
a136 1
/* *INDENT-ON* */
d138 7
d146 2
a147 8
					  int PowerManagementMode, int flags);
static void I830BIOSAdjustFrame(int scrnIndex, int x, int y, int flags);
static Bool I830BIOSCloseScreen(int scrnIndex, ScreenPtr pScreen);
static Bool I830BIOSSaveScreen(ScreenPtr pScreen, int unblack);
static Bool I830BIOSEnterVT(int scrnIndex, int flags);
static Bool I830VESASetVBEMode(ScrnInfoPtr pScrn, int mode,
			       VbeCRTCInfoBlock *block);

d150 16
a165 20
void
I830DPRINTF_stub(const char *filename, int line, const char *function,
		 const char *fmt, ...)
{
   va_list ap;

   ErrorF("\n##############################################\n"
	  "*** In function %s, on line %d, in file %s ***\n",
	  function, line, filename);
   va_start(ap, fmt);
   VErrorF(fmt, ap);
   va_end(ap);
   ErrorF("##############################################\n\n");
}
#else /* #ifdef I830DEBUG */
void
I830DPRINTF_stub(const char *filename, int line, const char *function,
		 const char *fmt, ...)
{
   /* do nothing */
d167 1
a167 1
#endif /* #ifdef I830DEBUG */
a168 1
/* XXX Check if this is still needed. */
d174 2
a175 3
   for (i = 0; I830BIOSPciChipsets[i].PCIid > 0; i++) {
      if (chipid == I830BIOSPciChipsets[i].PCIid)
	 return I830BIOSOptions;
d180 162
d345 1
a345 1
   I830Ptr pI830;
d347 3
a349 4
   if (pScrn->driverPrivate)
      return TRUE;
   pI830 = pScrn->driverPrivate = xnfcalloc(sizeof(I830Rec), 1);
   pI830->vesa = xnfcalloc(sizeof(VESARec), 1);
d356 1
a356 1
   I830Ptr pI830;
d360 2
a361 4
   if (!pScrn)
      return;
   if (!pScrn->driverPrivate)
      return;
d363 1
a363 1
   pI830 = I830PTR(pScrn);
d365 1
d369 2
a370 2
	 if (mode->Private) {
	    VbeModeInfoData *data = (VbeModeInfoData *) mode->Private;
d372 1
a372 2
	    if (data->block)
	       xfree(data->block);
d377 1
a377 1
      } while (mode && mode != pScrn->modes);
d380 5
a384 12
   if (pI830->vbeInfo)
      VBEFreeVBEInfo(pI830->vbeInfo);
   if (pI830->pVbe)
      vbeFree(pI830->pVbe);

   pVesa = pI830->vesa;
   if (pVesa->monitor)
      xfree(pVesa->monitor);
   if (pVesa->savedPal)
      xfree(pVesa->savedPal);
   xfree(pVesa);

d386 1
a386 1
   pScrn->driverPrivate = NULL;
d389 1
a389 1
static void
d393 6
d400 4
a403 4
   /* The vbe module gets loaded in PreInit(), so no need to load it here. */

   pVbe = VBEInit(NULL, index);
   ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
a405 6
/* Various extended video BIOS functions. */
static const int refreshes[] = {
   43, 56, 60, 70, 72, 75, 85, 100, 120
};
static const int nrefreshes = sizeof(refreshes) / sizeof(refreshes[0]);

d407 1
a407 1
Check5fStatus(ScrnInfoPtr pScrn, int func, int ax)
d409 2
a410 17
   if (ax == 0x005f)
      return TRUE;
   else if (ax == 0x015f) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Extended BIOS function 0x%04x failed.\n", func);
      return FALSE;
   } else if ((ax & 0xff) != 0x5f) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Extended BIOS function 0x%04x not supported.\n", func);
      return FALSE;
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Extended BIOS function 0x%04x returns 0x%04x.\n",
		 func, ax & 0xffff);
      return FALSE;
   }
}
d412 2
a413 5
#if 0
static int
BitToRefresh(int bits)
{
   int i;
d415 10
a424 5
   for (i = 0; i < nrefreshes; i++)
      if (bits & (1 << i))
	 return refreshes[i];
   return 0;
}
d426 1
a426 4
static int
GetRefreshRate(ScrnInfoPtr pScrn, int mode, int refresh, int *availRefresh)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
d428 6
a433 1
   DPRINTF(PFX, "GetRefreshRate\n");
d435 2
a436 17
   /* Only 8-bit mode numbers are supported. */
   if (mode & 0x100)
      return 0;

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f05;
   pVbe->pInt10->bx = (mode & 0xff) | 0x100;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f05, pVbe->pInt10->ax)) {
      if (availRefresh)
         *availRefresh = pVbe->pInt10->bx;
      return BitToRefresh(pVbe->pInt10->cx);
   } else
      return 0;
}
#endif
d438 2
a439 5
static int
SetRefreshRate(ScrnInfoPtr pScrn, int mode, int refresh)
{
   int i;
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
d441 2
a442 1
   DPRINTF(PFX, "SetRefreshRate: mode 0x%x, refresh: %d\n", mode, refresh);
d444 2
a445 30
   /* Only 8-bit mode numbers are supported. */
   if (mode & 0x100)
      return 0;

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f05;
   pVbe->pInt10->bx = mode & 0xff;

   for (i = nrefreshes - 1; i >= 0; i--) {
      /*
       * Look for the highest value that the requested (refresh + 2) is
       * greater than or equal to.
       */
      if (refreshes[i] <= (refresh + 2))
	 break;
   }
   /* i can be 0 if the requested refresh was higher than the max. */
   if (i == 0) {
      if (refresh >= refreshes[nrefreshes - 1])
         i = nrefreshes - 1;
   }
   DPRINTF(PFX, "Setting refresh rate to %dHz for mode 0x%02x\n",
	   refreshes[i], mode & 0xff);
   pVbe->pInt10->cx = 1 << i;
   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f05, pVbe->pInt10->ax))
      return refreshes[i];
   else
      return 0;
}
d447 3
a449 21
static Bool
GetModeSupport(ScrnInfoPtr pScrn, int modePipeA, int modePipeB,
	       int devicesPipeA, int devicesPipeB, int *maxBandwidth,
	       int *bandwidthPipeA, int *bandwidthPipeB)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "GetModeSupport: modes 0x%x, 0x%x, devices: 0x%x, 0x%x\n",
	   modePipeA, modePipeB, devicesPipeA, devicesPipeB);

   /* Only 8-bit mode numbers are supported. */
   if ((modePipeA & 0x100) || (modePipeB & 0x100))
      return 0;

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f28;
   pVbe->pInt10->bx = (modePipeA & 0xff) | ((modePipeB & 0xff) << 8);
   if ((devicesPipeA & 0x80) || (devicesPipeB & 0x80))
      pVbe->pInt10->cx = 0x8000;
   else
      pVbe->pInt10->cx = (devicesPipeA & 0xff) | ((devicesPipeB & 0xff) << 8);
d451 12
a462 13
   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f28, pVbe->pInt10->ax)) {
      if (maxBandwidth)
	 *maxBandwidth = pVbe->pInt10->cx;
      if (bandwidthPipeA)
	 *bandwidthPipeA = pVbe->pInt10->dx & 0xffff;
      /* XXX For XFree86 4.2.0 and earlier, ->dx is truncated to 16 bits. */
      if (bandwidthPipeB)
	 *bandwidthPipeB = (pVbe->pInt10->dx >> 16) & 0xffff;
      return TRUE;
   } else
      return FALSE;
}
d464 2
a465 4
static int
GetLFPCompMode(ScrnInfoPtr pScrn)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
d467 2
a468 1
   DPRINTF(PFX, "GetLFPCompMode\n");
d470 3
a472 3
   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f61;
   pVbe->pInt10->bx = 0x100;
d474 1
a474 5
   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f61, pVbe->pInt10->ax))
      return pVbe->pInt10->cx & 0xffff;
   else
      return -1;
d477 1
a477 3
#if 0
static Bool
SetLFPCompMode(ScrnInfoPtr pScrn, int compMode)
d479 8
a486 1
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
d488 2
a489 1
   DPRINTF(PFX, "SetLFPCompMode: compMode %d\n", compMode);
d491 28
a518 4
   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f61;
   pVbe->pInt10->bx = 0;
   pVbe->pInt10->cx = compMode;
d520 1
a520 2
   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   return Check5fStatus(pScrn, 0x5f61, pVbe->pInt10->ax);
a521 1
#endif
d523 1
a523 2
static int
GetDisplayDevices(ScrnInfoPtr pScrn)
d525 14
a538 2
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
d540 1
a540 1
   DPRINTF(PFX, "GetDisplayDevices\n");
d542 3
a544 21
#if 0
   {
      CARD32 temp;
      ErrorF("ADPA is 0x%08x\n", INREG(ADPA));
      ErrorF("DVOA is 0x%08x\n", INREG(DVOA));
      ErrorF("DVOB is 0x%08x\n", INREG(DVOB));
      ErrorF("DVOC is 0x%08x\n", INREG(DVOC));
      ErrorF("LVDS is 0x%08x\n", INREG(LVDS));
      temp = INREG(DVOA_SRCDIM);
      ErrorF("DVOA_SRCDIM is 0x%08x (%d x %d)\n", temp,
	     (temp >> 12) & 0xfff, temp & 0xfff);
      temp = INREG(DVOB_SRCDIM);
      ErrorF("DVOB_SRCDIM is 0x%08x (%d x %d)\n", temp,
	     (temp >> 12) & 0xfff, temp & 0xfff);
      temp = INREG(DVOC_SRCDIM);
      ErrorF("DVOC_SRCDIM is 0x%08x (%d x %d)\n", temp,
	     (temp >> 12) & 0xfff, temp & 0xfff);
      ErrorF("SWF0 is 0x%08x\n", INREG(SWF0));
      ErrorF("SWF4 is 0x%08x\n", INREG(SWF4));
   }
#endif
d546 3
a548 10
   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x100;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax))
      return pVbe->pInt10->cx & 0xffff;
   else
      return -1;
}
d550 2
a551 6
static Bool
SetDisplayDevices(ScrnInfoPtr pScrn, int devices)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   CARD32 temp;
d553 2
a554 1
   DPRINTF(PFX, "SetDisplayDevices: devices 0x%x\n", devices);
d556 2
a557 4
   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x1;
   pVbe->pInt10->cx = devices;
d559 1
a559 12
   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax))
      return TRUE;
   else {
      ErrorF("Writing config directly to SWF0\n");
      temp = INREG(SWF0);
      OUTREG(SWF0, (temp & ~(0xffff)) | (devices & 0xffff));
      ErrorF("SetDisplayDevices failed.  devices is 0x%x instead of 0x%x\n",
	     GetDisplayDevices(pScrn), devices);
      return FALSE;
   }
}
d561 5
a565 6
#if 0
static Bool
GetDevicePresence(ScrnInfoPtr pScrn, Bool *required, int *attached,
		  int *encoderPresent)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
d567 2
a568 1
   DPRINTF(PFX, "GetDevicePresence\n");
d570 2
a571 17
   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x200;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax)) {
      if (required)
	 *required = ((pVbe->pInt10->bx & 0x1) == 0);
      if (attached)
	 *attached = (pVbe->pInt10->cx >> 8) & 0xff;
      if (encoderPresent)
	 *encoderPresent = pVbe->pInt10->cx & 0xff;
      return TRUE;
   } else
      return FALSE;
}
#endif
d573 4
a576 5
static Bool
GetDisplayInfo(ScrnInfoPtr pScrn, int device, Bool *attached, Bool *present,
	       short *x, short *y)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
d578 1
a578 1
   DPRINTF(PFX, "GetDisplayInfo: device: 0x%x\n", device);
d580 11
a590 31
   switch (device & 0xff) {
   case 0x01:
   case 0x02:
   case 0x04:
   case 0x08:
   case 0x10:
   case 0x20:
      break;
   default:
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "GetDisplayInfo: invalid device: 0x%x\n", device & 0xff);
      return FALSE;
   }

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x300;
   pVbe->pInt10->cx = device & 0xff;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax)) {
      if (attached)
	 *attached = ((pVbe->pInt10->bx & 0x2) != 0);
      if (present)
	 *present = ((pVbe->pInt10->bx & 0x1) != 0);
      if (pVbe->pInt10->cx != (device & 0xff)) {
	 if (y) {
	    *y = pVbe->pInt10->cx & 0xffff;
	 }
	 if (x) {
	    *x = (pVbe->pInt10->cx >> 16) & 0xffff;
d592 1
a592 5
      }
      return TRUE;
   } else
      return FALSE;
}
d594 4
a597 5
/*
 * Returns a string matching the device corresponding to the first bit set
 * in "device".  savedDevice is then set to device with that bit cleared.
 * Subsequent calls with device == -1 will use savedDevice.
 */
d599 2
a600 9
static const char *displayDevices[] = {
   "CRT",
   "TV",
   "DFP (digital flat panel)",
   "LFP (local flat panel)",
   "TV2 (second TV)",
   "DFP2 (second digital flat panel)",
   NULL
};
d602 3
a604 26
static const char *
DeviceToString(int device)
{
   static int savedDevice = -1;
   static int bit = 0;
   const char *name;

   if (device == -1) {
      device = savedDevice;
      bit = 0;
   }

   if (device == -1)
      return NULL;

   while (displayDevices[bit]) {
      if (device & (1 << bit)) {
	 name = displayDevices[bit];
	 savedDevice = device & ~(1 << bit);
	 bit++;
	 return name;
      }
      bit++;
   }
   return NULL;
}
d606 2
a607 33
static void
PrintDisplayDeviceInfo(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int pipe, n;
   int displays;

   DPRINTF(PFX, "PrintDisplayDeviceInfo\n");

   displays = pI830->configuredDevices;
   if (displays == -1) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "No active display devices.\n");
      return;
   }

   /* Check for active devices connected to each display pipe. */
   for (n = 0; n < pI830->availablePipes; n++) {
      pipe = ((displays >> PIPE_SHIFT(n)) & PIPE_ACTIVE_MASK);
      if (pipe) {
	 const char *name;

	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Currently active displays on Pipe %c:\n", PIPE_NAME(n));
	 name = DeviceToString(pipe);
	 do {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "\t%s\n", name);
	    name = DeviceToString(-1);
	 } while (name);

	 if (pipe & PIPE_UNKNOWN_ACTIVE)
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "\tSome unknown display devices may also be present\n");
d609 1
a609 4
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "No active displays on Pipe %c.\n", PIPE_NAME(n));
      }
d611 1
a611 12
      if (pI830->pipeDisplaySize[n].x2 != 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Lowest common panel size for pipe %c is %d x %d\n",
		    PIPE_NAME(n), pI830->pipeDisplaySize[n].x2,
		    pI830->pipeDisplaySize[n].y2);
      } else if (pI830->pipeEnabled[n] && pipe & ~PIPE_CRT_ACTIVE) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "No display size information available for pipe %c.\n",
		    PIPE_NAME(n));
      }
   }
}
d613 10
a622 29
static void
GetPipeSizes(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int pipe, n;
   DisplayType i;

   DPRINTF(PFX, "GetPipeSizes\n");


   for (n = 0; n < pI830->availablePipes; n++) {
      pipe = (pI830->configuredDevices >> PIPE_SHIFT(n)) & PIPE_ACTIVE_MASK;
      pI830->pipeDisplaySize[n].x1 = pI830->pipeDisplaySize[n].y1 = 0;
      pI830->pipeDisplaySize[n].x2 = pI830->pipeDisplaySize[n].y2 = 4096;
      for (i = 0; i < NumKnownDisplayTypes; i++) {
         if (pipe & (1 << i) & PIPE_SIZED_DISP_MASK) {
	    if (pI830->displaySize[i].x2 != 0) {
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		          "Size of device %s is %d x %d\n",
		          displayDevices[i],
		          pI830->displaySize[i].x2,
		          pI830->displaySize[i].y2);
	       if (pI830->displaySize[i].x2 < pI830->pipeDisplaySize[n].x2)
	          pI830->pipeDisplaySize[n].x2 = pI830->displaySize[i].x2;
	       if (pI830->displaySize[i].y2 < pI830->pipeDisplaySize[n].y2)
	          pI830->pipeDisplaySize[n].y2 = pI830->displaySize[i].y2;
	    }
         }
      }
d624 17
a640 6
      if (pI830->pipeDisplaySize[n].x2 == 4096)
         pI830->pipeDisplaySize[n].x2 = 0;
      if (pI830->pipeDisplaySize[n].y2 == 4096)
         pI830->pipeDisplaySize[n].y2 = 0;
   }
}
d642 2
a643 20
static Bool
I830DetectDisplayDevice(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int pipe, n;
   DisplayType i;

   for (i = 0; i < NumKnownDisplayTypes; i++) {
      if (GetDisplayInfo(pScrn, 1 << i, &pI830->displayAttached[i],
			 &pI830->displayPresent[i],
			 &pI830->displaySize[i].x2,
			 &pI830->displaySize[i].y2)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Display Info: %s: attached: %s, present: %s, size: "
		    "(%d,%d)\n", displayDevices[i],
		    BOOLTOSTRING(pI830->displayAttached[i]),
		    BOOLTOSTRING(pI830->displayPresent[i]),
		    pI830->displaySize[i].x2, pI830->displaySize[i].y2);
      }
   }
d645 1
a645 6
   pI830->configuredDevices = GetDisplayDevices(pScrn);
   if (pI830->configuredDevices == -1) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Failed to detect active display devices\n");
      return FALSE;
   }
d647 19
a665 7
   /* Check for active devices connected to each display pipe. */
   for (n = 0; n < pI830->availablePipes; n++) {
      pipe = ((pI830->configuredDevices >> PIPE_SHIFT(n)) & PIPE_ACTIVE_MASK);
      if (pipe) {
	 pI830->pipeEnabled[n] = TRUE;
      }
   }
d667 1
a667 2
   GetPipeSizes(pScrn);
   PrintDisplayDeviceInfo(pScrn);
d669 19
a687 8
#if 0
   /* A quick hack to change the set of enabled devices. */
   enabledDevices = PIPE_CRT_ACTIVE;
   if (!SetDisplayDevices(pScrn, enabledDevices)) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Failed to switch to configured display devices\n");
   }
#endif
d689 1
a689 2
   return TRUE;
}
d691 19
a709 7
static int
I830DetectMemory(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   PCITAG bridge;
   CARD16 gmch_ctrl;
   int memsize = 0;
d711 2
a712 2
   bridge = pciTag(0, 0, 0);		/* This is always the host bridge */
   gmch_ctrl = pciReadWord(bridge, I830_GMCH_CTRL);
d714 12
a725 46
   if (IS_I85X(pI830) || IS_I865G(pI830))
   {
      switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
      case I855_GMCH_GMS_STOLEN_1M:
	 memsize = MB(1) - KB(132);
	 break;
      case I855_GMCH_GMS_STOLEN_4M:
	 memsize = MB(4) - KB(132);
	 break;
      case I855_GMCH_GMS_STOLEN_8M:
	 memsize = MB(8) - KB(132);
	 break;
      case I855_GMCH_GMS_STOLEN_16M:
	 memsize = MB(16) - KB(132);
	 break;
      case I855_GMCH_GMS_STOLEN_32M:
	 memsize = MB(32) - KB(132);
	 break;
      }
   } else
   {
      switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
      case I830_GMCH_GMS_STOLEN_512:
	 memsize = KB(512) - KB(132);
	 break;
      case I830_GMCH_GMS_STOLEN_1024:
	 memsize = MB(1) - KB(132);
	 break;
      case I830_GMCH_GMS_STOLEN_8192:
	 memsize = MB(8) - KB(132);
	 break;
      case I830_GMCH_GMS_LOCAL:
	 memsize = 0;
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Local memory found, but won't be used.\n");
	 break;
      }
   }
   if (memsize > 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "detected %d kB stolen memory.\n", memsize / 1024);
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "no video memory detected.\n");
   }
   return memsize;
}
d727 2
a728 5
static Bool
I830MapMMIO(ScrnInfoPtr pScrn)
{
   int mmioFlags;
   I830Ptr pI830 = I830PTR(pScrn);
d730 13
a742 5
#if !defined(__alpha__)
   mmioFlags = VIDMEM_MMIO | VIDMEM_READSIDEEFFECT;
#else
   mmioFlags = VIDMEM_MMIO | VIDMEM_READSIDEEFFECT | VIDMEM_SPARSE;
#endif
d744 1
a744 7
   pI830->MMIOBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
				   pI830->PciTag,
				   pI830->MMIOAddr, I810_REG_SIZE);
   if (!pI830->MMIOBase)
      return FALSE;
   return TRUE;
}
d746 3
a748 5
static Bool
I830MapMem(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned i;
d750 2
a751 2
   for (i = 2; i < pI830->FbMapSize; i <<= 1) ;
   pI830->FbMapSize = i;
d753 2
a754 2
   if (!I830MapMMIO(pScrn))
      return FALSE;
d756 5
a760 5
   pI830->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
				 pI830->PciTag,
				 pI830->LinearAddr, pI830->FbMapSize);
   if (!pI830->FbBase)
      return FALSE;
d762 4
a765 1
   pI830->LpRing.virtual_start = pI830->FbBase + pI830->LpRing.mem.Start;
d767 4
a770 2
   return TRUE;
}
d772 3
a774 4
static void
I830UnmapMMIO(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
d776 3
a778 4
   xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pI830->MMIOBase,
		   I810_REG_SIZE);
   pI830->MMIOBase = 0;
}
d780 5
a784 4
static Bool
I830UnmapMem(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
d786 1
a786 6
   xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pI830->FbBase,
		   pI830->FbMapSize);
   pI830->FbBase = 0;
   I830UnmapMMIO(pScrn);
   return TRUE;
}
d788 68
a855 3
#ifndef HAVE_GET_PUT_BIOSMEMSIZE
#define HAVE_GET_PUT_BIOSMEMSIZE 1
#endif
d857 1
a857 9
#if HAVE_GET_PUT_BIOSMEMSIZE
/*
 * Tell the BIOS how much video memory is available.  The BIOS call used
 * here won't always be available.
 */
static Bool
PutBIOSMemSize(ScrnInfoPtr pScrn, int memSize)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
d859 41
a899 1
   DPRINTF(PFX, "PutBIOSMemSize: %d kB\n", memSize / 1024);
d901 13
a913 4
   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f11;
   pVbe->pInt10->bx = 0;
   pVbe->pInt10->cx = memSize / GTT_PAGE_SIZE;
d915 1
a915 3
   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   return Check5fStatus(pScrn, 0x5f11, pVbe->pInt10->ax);
}
d917 2
a918 12
/*
 * This reports what the previous VBEGetVBEInfo() found.  Be sure to call
 * VBEGetVBEInfo() after changing the BIOS memory size view.  If
 * a separate BIOS call is added for this, it can be put here.  Only
 * return a valid value if the funtionality for PutBIOSMemSize()
 * is available.
 */
static int
GetBIOSMemSize(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int memSize = KB(pI830->vbeInfo->TotalMemory * 64);
d920 13
a932 1
   DPRINTF(PFX, "GetBIOSMemSize\n");
d934 103
a1036 6
   if (PutBIOSMemSize(pScrn, memSize))
      return memSize;
   else
      return -1;
}
#endif
d1038 19
a1056 16
/*
 * These three functions allow the video BIOS's view of the available video
 * memory to be changed.  This is currently implemented only for the 830
 * and 845G, which can do this via a BIOS scratch register that holds the
 * BIOS's view of the (pre-reserved) memory size.  If another mechanism
 * is available in the future, it can be plugged in here.  
 *
 * The mapping used for the 830/845G scratch register's low 4 bits is:
 *
 *             320k => 0
 *             832k => 1
 *            8000k => 8
 *
 * The "unusual" values are the 512k, 1M, 8M pre-reserved memory, less
 * overhead, rounded down to the BIOS-reported 64k granularity.
 */
d1058 1
a1058 4
static Bool
SaveBIOSMemSize(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
d1060 7
a1066 7
   DPRINTF(PFX, "SaveBIOSMemSize\n");

   pI830->useSWF1 = FALSE;

#if HAVE_GET_PUT_BIOSMEMSIZE
   if ((pI830->saveBIOSMemSize = GetBIOSMemSize(pScrn)) != -1)
      return TRUE;
d1069 7
a1075 26
   if (IS_I830(pI830) || IS_845G(pI830)) {
      pI830->useSWF1 = TRUE;
      pI830->saveSWF1 = INREG(SWF1) & 0x0f;

      /*
       * This is for sample purposes only.  pI830->saveBIOSMemSize isn't used
       * when pI830->useSWF1 is TRUE.
       */
      switch (pI830->saveSWF1) {
      case 0:
	 pI830->saveBIOSMemSize = KB(320);
	 break;
      case 1:
	 pI830->saveBIOSMemSize = KB(832);
	 break;
      case 8:
	 pI830->saveBIOSMemSize = KB(8000);
	 break;
      default:
	 pI830->saveBIOSMemSize = 0;
	 break;
      }
      return TRUE;
   }
   return FALSE;
}
d1077 1
a1077 47
/*
 * TweakMemorySize() tweaks the BIOS image to set the correct size.
 * Original implementation by Christian Zietz in a stand-alone tool.
 */
static CARD32
TweakMemorySize(ScrnInfoPtr pScrn, CARD32 newsize, Bool preinit)
{
#define SIZE 0x10000
#define IDOFFSET (-23)
    const char *MAGICstring = "Total time for VGA POST:";
    const int len = strlen(MAGICstring);
    I830Ptr pI830 = I830PTR(pScrn);
    char *position;
    char *biosAddr;
    CARD32 oldsize;
    CARD32 oldpermission;
    CARD32 ret = 0;
    int i,j = 0;
    PCITAG tag =pciTag(0,0,0);

    if(!pI830->PciInfo 
       || !(pI830->PciInfo->chipType == PCI_CHIP_I855_GM
	    || pI830->PciInfo->chipType == PCI_CHIP_I865_G))
	return 0;

    if (!pI830->pVbe)
	return 0;

    biosAddr = xf86int10Addr(pI830->pVbe->pInt10, 
				    pI830->pVbe->pInt10->BIOSseg << 4);

    if (!pI830->BIOSMemSizeLoc) {

	if (!preinit)
	    return 0;

	/* Search for MAGIC string */
	for (i = 0; i < SIZE; i++) {
	    if (biosAddr[i] == MAGICstring[j]) {
		if (++j == len)
		    break;
	    } else {
		i -= j;
		j = 0;
	    }
	}
	if (j < len) return 0;
d1079 50
a1128 2
	pI830->BIOSMemSizeLoc =  (i - j + 1 + IDOFFSET);
    }
d1130 1
a1130 30
    position = biosAddr + pI830->BIOSMemSizeLoc;
    oldsize = *(CARD32 *)position;
    ret = oldsize - (3 << 16);

    /* verify that register really contains current size */
    if (preinit && ((oldsize) >> 16) - 3 !=  pI830->vbeInfo->TotalMemory)
	return 0;

    oldpermission = pciReadLong(tag, DRAM_RW_CONTROL);
    pciWriteLong(tag, DRAM_RW_CONTROL, 0x33330000);

    *(CARD32 *)position = newsize + (3 << 16);
    if (preinit) {
	/* reinitialize VBE for new size */
	VBEFreeVBEInfo(pI830->vbeInfo);
	vbeFree(pI830->pVbe);
	pI830->pVbe = VBEInit(NULL, pI830->pEnt->index);
	pI830->vbeInfo = VBEGetVBEInfo(pI830->pVbe);

	/* verify that change was successful */
	if (pI830->vbeInfo->TotalMemory * 64 * 1024 != pI830->newBIOSMemSize) {
	    ret = 0;
	    *(CARD32 *)position = oldsize;
	} else {
	    pI830->BIOSMemorySize = KB(pI830->vbeInfo->TotalMemory * 64);
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		       "Tweak BIOS image to %d kB VideoRAM\n",
		       (int)(pI830->BIOSMemorySize / 1024));
	}
    }
d1132 6
a1137 1
     pciWriteLong(tag, DRAM_RW_CONTROL, oldpermission);
d1139 1
a1139 2
     return ret;
}
d1141 6
a1146 18
static void
RestoreBIOSMemSize(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   CARD32 swf1;

   DPRINTF(PFX, "RestoreBIOSMemSize\n");

   if (TweakMemorySize(pScrn, pI830->saveBIOSMemSize,FALSE))
       return;

   if (!pI830->overrideBIOSMemSize)
      return;

#if HAVE_GET_PUT_BIOSMEMSIZE
   if (!pI830->useSWF1) {
      PutBIOSMemSize(pScrn, pI830->saveBIOSMemSize);
      return;
a1147 1
#endif
d1149 6
a1154 5
   if ((IS_I830(pI830) || IS_845G(pI830)) && pI830->useSWF1) {
      swf1 = INREG(SWF1);
      swf1 &= ~0x0f;
      swf1 |= (pI830->saveSWF1 & 0x0f);
      OUTREG(SWF1, swf1);
a1155 1
}
d1157 13
a1169 16
static void
SetBIOSMemSize(ScrnInfoPtr pScrn, int newSize)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned long swf1;
   Bool mapped;

   DPRINTF(PFX, "SetBIOSMemSize: %d kB\n", newSize / 1024);

   if (!pI830->overrideBIOSMemSize)
      return;

#if HAVE_GET_PUT_BIOSMEMSIZE
   if (!pI830->useSWF1) {
      PutBIOSMemSize(pScrn, newSize);
      return;
a1170 1
#endif
d1172 1
a1172 22
   if ((IS_I830(pI830) || IS_845G(pI830)) && pI830->useSWF1) {
      unsigned long newSWF1;

      /* Need MMIO access here. */
      mapped = (pI830->MMIOBase != NULL);
      if (!mapped)
	 I830MapMMIO(pScrn);

      if (newSize <= KB(832))
	 newSWF1 = 1;
      else
	 newSWF1 = 8;

      swf1 = INREG(SWF1);
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Before: SWF1 is 0x%08lx\n", swf1);
      swf1 &= ~0x0f;
      swf1 |= (newSWF1 & 0x0f);
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "After: SWF1 is 0x%08lx\n", swf1);
      OUTREG(SWF1, swf1);
      if (!mapped)
	 I830UnmapMMIO(pScrn);
   }
d1176 1
a1176 5
 * Use the native method instead of the vgahw method.  So far this is
 * only used for 8-bit mode.
 *
 * XXX Look into using the 10-bit gamma correction mode for 15/16/24 bit,
 * and see if a DirectColor visual can be offered.
d1178 1
d1180 1
a1180 2
I830LoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
		LOCO * colors, VisualPtr pVisual)
d1182 1
a1182 33
   I830Ptr pI830;
   int i, index;
   unsigned char r, g, b;
   CARD32 val, temp;

   DPRINTF(PFX, "I830LoadPalette: numColors: %d\n", numColors);
   pI830 = I830PTR(pScrn);

   if (pI830->pipeEnabled[0]) {
      /* It seems that an initial read is needed. */
      temp = INREG(PALETTE_A);
      for (i = 0; i < numColors; i++) {
	 index = indices[i];
	 r = colors[index].red;
	 g = colors[index].green;
	 b = colors[index].blue;
	 val = (r << 16) | (g << 8) | b;
	 OUTREG(PALETTE_A + index * 4, val);
      }
   }
   if (pI830->pipeEnabled[1]) {
      /* It seems that an initial read is needed. */
      temp = INREG(PALETTE_B);
      for (i = 0; i < numColors; i++) {
	 index = indices[i];
	 r = colors[index].red;
	 g = colors[index].green;
	 b = colors[index].blue;
	 val = (r << 16) | (g << 8) | b;
	 OUTREG(PALETTE_B + index * 4, val);
      }
   }
}
d1184 1
a1184 4
static void
PreInitCleanup(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
d1186 3
a1188 8
   RestoreBIOSMemSize(pScrn);
   if (pI830->swfSaved) {
      OUTREG(SWF0, pI830->saveSWF0);
      OUTREG(SWF4, pI830->saveSWF4);
   }
   if (pI830->MMIOBase)
      I830UnmapMMIO(pScrn);
   I830BIOSFreeRec(pScrn);
d1191 2
a1192 2
static Bool
I830BIOSPreInit(ScrnInfoPtr pScrn, int flags)
d1194 1
a1194 12
   vgaHWPtr hwp;
   I830Ptr pI830;
   MessageType from;
   rgb defaultWeight = { 0, 0, 0 };
   vbeInfoPtr pVbe;
   EntityInfoPtr pEnt;
   int mem, memsize;
   int flags24;
   int i, n;
   pointer pDDCModule, pVBEModule;
   Bool enable;
   const char *chipname;
d1196 1
a1196 2
   if (pScrn->numEntities != 1)
      return FALSE;
d1198 4
a1201 4
   /* Load int10 module */
   if (!xf86LoadSubModule(pScrn, "int10"))
      return FALSE;
   xf86LoaderReqSymLists(I810int10Symbols, NULL);
d1203 4
a1206 4
   /* Load vbe module */
   if (!(pVBEModule = xf86LoadSubModule(pScrn, "vbe")))
      return FALSE;
   xf86LoaderReqSymLists(I810vbeSymbols, NULL);
d1208 4
a1211 1
   pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
d1213 2
a1214 4
   if (flags & PROBE_DETECT) {
      I830BIOSProbeDDC(pScrn, pEnt->index);
      return TRUE;
   }
d1216 6
a1221 4
   /* The vgahw module should be loaded here when needed */
   if (!xf86LoadSubModule(pScrn, "vgahw"))
      return FALSE;
   xf86LoaderReqSymLists(I810vgahwSymbols, NULL);
d1223 2
d1226 7
a1232 23
   /* Allocate a vgaHWRec */
   if (!vgaHWGetHWRec(pScrn))
      return FALSE;

   /* Allocate driverPrivate */
   if (!I830BIOSGetRec(pScrn))
      return FALSE;

   pI830 = I830PTR(pScrn);
   pI830->SaveGeneration = -1;
   pI830->pEnt = pEnt;

   if (pI830->pEnt->location.type != BUS_PCI)
      return FALSE;

   pI830->PciInfo = xf86GetPciInfoForEntity(pI830->pEnt->index);
   pI830->PciTag = pciTag(pI830->PciInfo->bus, pI830->PciInfo->device,
			  pI830->PciInfo->func);

   if (xf86RegisterResources(pI830->pEnt->index, 0, ResNone)) {
      PreInitCleanup(pScrn);
      return FALSE;

d1234 1
d1236 6
a1241 4
   pScrn->racMemFlags = RAC_FB | RAC_COLORMAP;
   pScrn->monitor = pScrn->confScreen->monitor;
   pScrn->progClock = TRUE;
   pScrn->rgbBits = 8;
d1243 2
a1244 1
   flags24 = Support32bppFb | PreferConvert24to32 | SupportConvert24to32;
d1246 1
a1246 2
   if (!xf86SetDepthBpp(pScrn, 0, 0, 0, flags24))
      return FALSE;
d1248 54
a1301 13
   switch (pScrn->depth) {
   case 8:
   case 15:
   case 16:
   case 24:
      break;
   default:
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Given depth (%d) is not supported by I830 driver\n",
		 pScrn->depth);
      return FALSE;
   }
   xf86PrintDepthBpp(pScrn);
d1303 6
a1308 4
   if (!xf86SetWeight(pScrn, defaultWeight, defaultWeight))
      return FALSE;
   if (!xf86SetDefaultVisual(pScrn, -1))
      return FALSE;
d1310 2
a1311 2
   hwp = VGAHWPTR(pScrn);
   pI830->cpp = pScrn->bitsPerPixel / 8;
d1313 1
a1313 6
   /* Process the options */
   xf86CollectOptions(pScrn, NULL);
   if (!(pI830->Options = xalloc(sizeof(I830BIOSOptions))))
      return FALSE;
   memcpy(pI830->Options, I830BIOSOptions, sizeof(I830BIOSOptions));
   xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pI830->Options);
d1315 53
a1367 2
   /* We have to use PIO to probe, because we haven't mapped yet. */
   I830SetPIOAccess(pI830);
d1369 1
a1369 5
   /* Initialize VBE record */
   if ((pI830->pVbe = VBEInit(NULL, pI830->pEnt->index)) == NULL) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "VBE initialization failed.\n");
      return FALSE;
   }
d1371 6
a1376 40
   switch (pI830->PciInfo->chipType) {
   case PCI_CHIP_I830_M:
      chipname = "830M";
      break;
   case PCI_CHIP_845_G:
      chipname = "845G";
      break;
   case PCI_CHIP_I855_GM:
      /* Check capid register to find the chipset variant */
      pI830->variant = (pciReadLong(pI830->PciTag, I85X_CAPID)
				>> I85X_VARIANT_SHIFT) & I85X_VARIANT_MASK;
      switch (pI830->variant) {
      case I855_GM:
	 chipname = "855GM";
	 break;
      case I855_GME:
	 chipname = "855GME";
	 break;
      case I852_GM:
	 chipname = "852GM";
	 break;
      case I852_GME:
	 chipname = "852GME";
	 break;
      default:
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Unknown 852GM/855GM variant: 0x%x)\n", pI830->variant);
	 chipname = "852GM/855GM (unknown variant)";
	 break;
      }
      break;
   case PCI_CHIP_I865_G:
      chipname = "865G";
      break;
   default:
      chipname = "unknown chipset";
      break;
   }
   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "Integrated Graphics Chipset: Intel(R) %s\n", chipname);
d1378 2
a1379 1
   pVbe = pI830->pVbe;
d1381 4
a1384 1
   pI830->vbeInfo = VBEGetVBEInfo(pVbe);
d1386 4
a1389 14
   /* Set the Chipset and ChipRev, allowing config file entries to override. */
   if (pI830->pEnt->device->chipset && *pI830->pEnt->device->chipset) {
      pScrn->chipset = pI830->pEnt->device->chipset;
      from = X_CONFIG;
   } else if (pI830->pEnt->device->chipID >= 0) {
      pScrn->chipset = (char *)xf86TokenToString(I830BIOSChipsets,
						 pI830->pEnt->device->chipID);
      from = X_CONFIG;
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
		 pI830->pEnt->device->chipID);
   } else {
      from = X_PROBED;
      pScrn->chipset = (char *)xf86TokenToString(I830BIOSChipsets,
						 pI830->PciInfo->chipType);
d1391 1
d1393 4
a1396 26
   if (pI830->pEnt->device->chipRev >= 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
		 pI830->pEnt->device->chipRev);
   }

   xf86DrvMsg(pScrn->scrnIndex, from, "Chipset: \"%s\"\n",
	      (pScrn->chipset != NULL) ? pScrn->chipset : "Unknown i8xx");

   if (pI830->pEnt->device->MemBase != 0) {
      pI830->LinearAddr = pI830->pEnt->device->MemBase;
      from = X_CONFIG;
   } else {
      if (pI830->PciInfo->memBase[1] != 0) {
	 /* XXX Check mask. */
	 pI830->LinearAddr = pI830->PciInfo->memBase[0] & 0xFF000000;
	 from = X_PROBED;
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "No valid FB address in PCI config space\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
   }

   xf86DrvMsg(pScrn->scrnIndex, from, "Linear framebuffer at 0x%lX\n",
	      (unsigned long)pI830->LinearAddr);
d1398 2
a1399 53
   if (pI830->pEnt->device->IOBase != 0) {
      pI830->MMIOAddr = pI830->pEnt->device->IOBase;
      from = X_CONFIG;
   } else {
      if (pI830->PciInfo->memBase[1]) {
	 pI830->MMIOAddr = pI830->PciInfo->memBase[1] & 0xFFF80000;
	 from = X_PROBED;
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "No valid MMIO address in PCI config space\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
   }

   xf86DrvMsg(pScrn->scrnIndex, from, "IO registers at addr 0x%lX\n",
	      (unsigned long)pI830->MMIOAddr);

   /* Some of the probing needs MMIO access, so map it here. */
   I830MapMMIO(pScrn);

#if 1
   pI830->saveSWF0 = INREG(SWF0);
   pI830->saveSWF4 = INREG(SWF4);
   pI830->swfSaved = TRUE;

   /* Set "extended desktop" */
   OUTREG(SWF0, pI830->saveSWF0 | (1 << 21));

   /* Set "driver loaded",  "OS unknown", "APM 1.2" */
   OUTREG(SWF4, (pI830->saveSWF4 & ~((3 << 19) | (7 << 16))) |
		(1 << 23) | (2 << 16));
#endif

   if (IS_I830(pI830) || IS_845G(pI830)) {
      PCITAG bridge;
      CARD16 gmch_ctrl;

      bridge = pciTag(0, 0, 0);		/* This is always the host bridge */
      gmch_ctrl = pciReadWord(bridge, I830_GMCH_CTRL);
      if ((gmch_ctrl & I830_GMCH_MEM_MASK) == I830_GMCH_MEM_128M) {
	 pI830->FbMapSize = 0x8000000;
      } else {
	 pI830->FbMapSize = 0x4000000;
      }
   }
   else {
      /* 128MB aperture for later chips */
      pI830->FbMapSize = 0x8000000;
   }

   /*
    * Get the pre-allocated (stolen) memory size.
d1401 3
a1403 58
   pI830->StolenMemory.Size = I830DetectMemory(pScrn);
   pI830->StolenMemory.Start = 0;
   pI830->StolenMemory.End = pI830->StolenMemory.Size;

   /* Sanity check: compare with what the BIOS thinks. */
   if (pI830->vbeInfo->TotalMemory != pI830->StolenMemory.Size / 1024 / 64) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Detected stolen memory (%ld kB) doesn't match what the BIOS"
		 " reports (%d kB)\n",
		 ROUND_DOWN_TO(pI830->StolenMemory.Size / 1024, 64),
		 pI830->vbeInfo->TotalMemory * 64);
   }

   /* Find the maximum amount of agpgart memory available. */
   mem = I830CheckAvailableMemory(pScrn);
   pI830->StolenOnly = FALSE;

   if (mem <= 0) {
      if (pI830->StolenMemory.Size <= 0) {
	 /* Shouldn't happen. */
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "/dev/agpgart is either not available, or no memory "
		 "is available\nfor allocation, "
		 "and no pre-allocated memory is available.\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "/dev/agpgart is either not available, or no memory "
		 "is available\nfor allocation.  "
		 "Using pre-allocated memory only.\n");
      mem = 0;
      pI830->StolenOnly = TRUE;
   }

   if (xf86ReturnOptValBool(pI830->Options, OPTION_NOACCEL, FALSE)) {
      pI830->noAccel = TRUE;
   }
   if (xf86ReturnOptValBool(pI830->Options, OPTION_SW_CURSOR, FALSE)) {
      pI830->SWCursor = TRUE;
   }

   pI830->directRenderingDisabled =
	!xf86ReturnOptValBool(pI830->Options, OPTION_DRI, TRUE);

#ifdef XF86DRI
   if (!pI830->directRenderingDisabled) {
      if (pI830->noAccel || pI830->SWCursor) {
	 xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "DRI is disabled because it "
		    "needs HW cursor and 2D acceleration.\n");
	 pI830->directRenderingDisabled = TRUE;
      } else if (pScrn->depth != 16 && pScrn->depth != 24) {
	 xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "DRI is disabled because it "
		    "runs only at depths 16 and 24.\n");
	 pI830->directRenderingDisabled = TRUE;
      }
   }
#endif
d1405 1
a1405 5
   /*
    * The "VideoRam" config file parameter specifies the total amount of
    * memory that will be used/allocated.  When agpgart support isn't
    * available (StolenOnly == TRUE), this is limited to the amount of
    * pre-allocated ("stolen") memory.
d1407 2
d1410 2
a1411 21
   /*
    * Default to I830_DEFAULT_VIDEOMEM_2D (8192KB) for 2D-only,
    * or I830_DEFAULT_VIDEOMEM_3D (32768KB) for 3D.  If the stolen memory
    * amount is higher, default to it rounded up to the nearest MB.  This
    * guarantees that by default there will be at least some run-time
    * space for things that need a physical address.
    */
   if (!pI830->pEnt->device->videoRam) {
      from = X_DEFAULT;
#ifdef XF86DRI
      if (!pI830->directRenderingDisabled)
	 pScrn->videoRam = I830_DEFAULT_VIDEOMEM_3D;
      else
#endif
	 pScrn->videoRam = I830_DEFAULT_VIDEOMEM_2D;
      if (pI830->StolenMemory.Size / 1024 > pScrn->videoRam)
	 pScrn->videoRam = ROUND_TO(pI830->StolenMemory.Size / 1024, 1024);
   } else {
      from = X_CONFIG;
      pScrn->videoRam = pI830->pEnt->device->videoRam;
   }
d1413 4
a1416 15
   DPRINTF(PFX,
	   "Available memory: %dk\n"
	   "Requested memory: %dk\n", mem, pScrn->videoRam);


   if (mem + (pI830->StolenMemory.Size / 1024) < pScrn->videoRam) {
      pScrn->videoRam = mem + (pI830->StolenMemory.Size / 1024);
      from = X_PROBED;
      if (mem + (pI830->StolenMemory.Size / 1024) <
	  pI830->pEnt->device->videoRam) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "VideoRAM reduced to %d kByte "
		    "(limited to available sysmem)\n", pScrn->videoRam);
      }
   }
d1418 5
a1422 63
   if (pScrn->videoRam > pI830->FbMapSize / 1024) {
      pScrn->videoRam = pI830->FbMapSize / 1024;
      if (pI830->FbMapSize / 1024 < pI830->pEnt->device->videoRam)
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "VideoRam reduced to %d kByte (limited to aperture size)\n",
		    pScrn->videoRam);
   }

   if (mem > 0) {
      /*
       * If the reserved (BIOS accessible) memory is less than the desired
       * amount, try to increase it.  So far this is only implemented for
       * the 845G and 830, but those details are handled in SetBIOSMemSize().
       * 
       * The BIOS-accessible amount is only important for setting video
       * modes.  The maximum amount we try to set is limited to what would
       * be enough for 1920x1440 with a 2048 pitch.
       *
       * If ALLOCATE_ALL_BIOSMEM is enabled in i830_memory.c, all of the
       * BIOS-aware memory will get allocated.  If it isn't then it may
       * not be, and in that case there is an assumption that the video
       * BIOS won't attempt to access memory beyond what is needed for
       * modes that are actually used.  ALLOCATE_ALL_BIOSMEM is enabled by
       * default.
       */

      /* Try to keep HW cursor and Overlay amounts separate from this. */
      int reserve = (HWCURSOR_SIZE + OVERLAY_SIZE) / 1024;

      if (pScrn->videoRam - reserve >= I830_MAXIMUM_VBIOS_MEM)
	 pI830->newBIOSMemSize = KB(I830_MAXIMUM_VBIOS_MEM);
      else 
	 pI830->newBIOSMemSize =
			KB(ROUND_DOWN_TO(pScrn->videoRam - reserve, 64));
      if (pI830->vbeInfo->TotalMemory * 64 < pI830->newBIOSMemSize / 1024) {

	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Will attempt to tell the BIOS that there is "
		    "%d kB VideoRAM\n", pI830->newBIOSMemSize / 1024);
	 if (SaveBIOSMemSize(pScrn)) {
	    pI830->overrideBIOSMemSize = TRUE;
	    SetBIOSMemSize(pScrn, pI830->newBIOSMemSize);

	    VBEFreeVBEInfo(pI830->vbeInfo);
	    vbeFree(pI830->pVbe);
	    pI830->pVbe = VBEInit(NULL, pI830->pEnt->index);
	    pVbe = pI830->pVbe;
	    pI830->vbeInfo = VBEGetVBEInfo(pVbe);

	    pI830->BIOSMemorySize = KB(pI830->vbeInfo->TotalMemory * 64);
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "BIOS now sees %ld kB VideoRAM\n",
		       pI830->BIOSMemorySize / 1024);
 	 } else if ((pI830->saveBIOSMemSize 
 		  = TweakMemorySize(pScrn, pI830->newBIOSMemSize, TRUE)) != 0) 
 		 pI830->overrideBIOSMemSize = TRUE;
 	     else {
 		 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 			    "BIOS view of memory size can't be changed "
 			    "(this is not an error).\n");
	 }
      }
   }
d1424 4
a1427 1
   pVbe = pI830->pVbe;
d1429 4
a1432 12
   xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Pre-allocated VideoRAM: %ld kByte\n",
	      pI830->StolenMemory.Size / 1024);
   xf86DrvMsg(pScrn->scrnIndex, from, "VideoRAM: %d kByte\n", pScrn->videoRam);
   pI830->TotalVideoRam = KB(pScrn->videoRam);

   /*
    * If the requested videoRam amount is less than the stolen memory size,
    * reduce the stolen memory size accordingly.
    */
   if (pI830->StolenMemory.Size > pI830->TotalVideoRam) {
      pI830->StolenMemory.Size = pI830->TotalVideoRam;
      pI830->StolenMemory.End = pI830->TotalVideoRam;
d1434 1
d1436 5
a1440 10
   if (xf86GetOptValInteger(pI830->Options, OPTION_CACHE_LINES,
			    &(pI830->CacheLines))) {
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Requested %d cache lines\n",
		 pI830->CacheLines);
   } else {
      pI830->CacheLines = -1;
   }

   pI830->XvDisabled =
	!xf86ReturnOptValBool(pI830->Options, OPTION_XVIDEO, TRUE);
d1442 2
a1443 7
#ifdef I830_XV
   if (xf86GetOptValInteger(pI830->Options, OPTION_VIDEO_KEY,
			    &(pI830->colorKey))) {
      from = X_CONFIG;
   } else if (xf86GetOptValInteger(pI830->Options, OPTION_COLOR_KEY,
			    &(pI830->colorKey))) {
      from = X_CONFIG;
d1445 1
a1445 5
      pI830->colorKey = (1 << pScrn->offset.red) |
			(1 << pScrn->offset.green) |
			(((pScrn->mask.blue >> pScrn->offset.blue) - 1) <<
			 pScrn->offset.blue);
      from = X_DEFAULT;
a1446 3
   xf86DrvMsg(pScrn->scrnIndex, from, "video overlay key set to 0x%x\n",
	      pI830->colorKey);
#endif
d1448 3
a1450 9
   pI830->allowPageFlip = FALSE;
   enable = xf86ReturnOptValBool(pI830->Options, OPTION_PAGEFLIP, FALSE);
#ifdef XF86DRI
   if (!pI830->directRenderingDisabled) {
      pI830->allowPageFlip = enable;
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "page flipping %s\n",
		 enable ? "enabled" : "disabled");
   }
#endif
d1452 5
a1456 5
   /* Check if the HW cursor needs physical address. */
   if (IS_MOBILE(pI830))
      pI830->CursorNeedsPhysical = TRUE;
   else
      pI830->CursorNeedsPhysical = FALSE;
d1458 2
a1459 3
   /* Force ring buffer to be in low memory for the 845G and later. */
   if (IS_845G(pI830) || IS_I85X(pI830) || IS_I865G(pI830))
      pI830->NeedRingBufferLow = TRUE;
d1461 2
a1462 22
   /*
    * XXX If we knew the pre-initialised GTT format for certain, we could
    * probably figure out the physical address even in the StolenOnly case.
    */
   if (pI830->StolenOnly && pI830->CursorNeedsPhysical && !pI830->SWCursor) {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		 "HW Cursor disabled because it needs agpgart memory.\n");
      pI830->SWCursor = TRUE;
   }

   /*
    * Reduce the maximum videoram available for video modes by the ring buffer,
    * minimum scratch space and HW cursor amounts.
    */
   if (!pI830->SWCursor)
      pScrn->videoRam -= (HWCURSOR_SIZE / 1024);
   if (!pI830->XvDisabled)
      pScrn->videoRam -= (OVERLAY_SIZE / 1024);
   if (!pI830->noAccel) {
      pScrn->videoRam -= (PRIMARY_RINGBUFFER_SIZE / 1024);
      pScrn->videoRam -= (MIN_SCRATCH_BUFFER_SIZE / 1024);
   }
d1464 1
a1464 2
   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      "Maximum frambuffer space: %d kByte\n", pScrn->videoRam);
d1466 2
a1467 3
   /*
    * If the driver can do gamma correction, it should call xf86SetGamma() here.
    */
d1469 1
a1469 5
   {
      Gamma zeros = { 0.0, 0.0, 0.0 };

      if (!xf86SetGamma(pScrn, zeros))
	 return FALSE;
d1472 2
a1473 6
   if (IS_MOBILE(pI830))
      pI830->availablePipes = 2;
   else
      pI830->availablePipes = 1;
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%d display pipe%s available.\n",
	      pI830->availablePipes, pI830->availablePipes > 1 ? "s" : "");
d1475 6
a1480 6
   if (!I830DetectDisplayDevice(pScrn)) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Couldn't detect display devices.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }
d1482 2
a1483 11
   if ((pDDCModule = xf86LoadSubModule(pScrn, "ddc")) == NULL) {
      PreInitCleanup(pScrn);
      return FALSE;
   }

   if ((pI830->vesa->monitor = vbeDoEDID(pVbe, pDDCModule)) != NULL) {
      xf86PrintEDID(pI830->vesa->monitor);
   }
   if ((pScrn->monitor->DDC = pI830->vesa->monitor) != NULL)
      xf86SetDDCproperties(pScrn, pI830->vesa->monitor);
   xf86UnloadSubModule(pDDCModule);
d1485 1
a1485 2
   /* XXX Move this to a header. */
#define VIDEO_BIOS_SCRATCH 0x18
d1487 28
a1514 17
#if 1
   /*
    * XXX This should be in ScreenInit/EnterVT.  PreInit should not leave the
    * state changed.
    */
   /* Enable hot keys by writing the proper value to GR18 */
   {
      CARD8 gr18;

      gr18 = pI830->readControl(pI830, GRX, VIDEO_BIOS_SCRATCH);
      gr18 &= ~0x80;			/*
					 * Clear Hot key bit so that Video
					 * BIOS performs the hot key
					 * servicing
					 */
      pI830->writeControl(pI830, GRX, VIDEO_BIOS_SCRATCH, gr18);
   }
d1516 4
d1521 4
a1524 17
   for (i = 0; i < pI830->availablePipes; i++) {
      int pipe =
	  (pI830->configuredDevices >> PIPE_SHIFT(i)) & PIPE_ACTIVE_MASK;
      if (pipe & ~PIPE_CRT_ACTIVE) {
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		    "A non-CRT device is attached to pipe %c.\n"
		    "\tNo refresh rate overrides will be attempted.\n",
		    PIPE_NAME(i));
	 pI830->vesa->useDefaultRefresh = TRUE;
      }
      /*
       * Some desktop platforms might not have 0x5f05, so useExtendedRefresh
       * would need to be set to FALSE for those cases.
       */
      if (!pI830->vesa->useDefaultRefresh)
	 pI830->useExtendedRefresh = TRUE;
   }
d1526 2
a1527 4
   if (pI830->useExtendedRefresh) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Will use BIOS call 0x5f05 to set refresh rates for CRTs.\n");
   }
d1529 1
a1529 6
   /*
    * Calling 0x5f64 can reset the refresh rate, so only do this when
    * using 0x5f05, or when not overriding the default refresh rate.
    * Also, 0x5f64 doesn't work correctly in i830 platforms.
    */
   pI830->enableDisplays = !IS_I830(pI830) && pI830->useExtendedRefresh;
d1531 1
a1531 4
   if (pI830->enableDisplays) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Will use BIOS call 0x5f64 to enable displays.\n");
   }
d1533 6
a1538 61
   /*
    * Limit videoram available for mode selection to what the video
    * BIOS can see.
    */
   if (pScrn->videoRam > (pI830->vbeInfo->TotalMemory * 64))
      memsize = pI830->vbeInfo->TotalMemory * 64;
   else
      memsize = pScrn->videoRam;
   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      "Maximum space available for video modes: %d kByte\n", memsize);

   /*
    * Note: VBE modes (> 0x7f) won't work with Intel's extended BIOS
    * functions.  For that reason it's important to set only
    * V_MODETYPE_VGA in the flags for VBEGetModePool().
    */
   pScrn->modePool = VBEGetModePool(pScrn, pVbe, pI830->vbeInfo,
				    V_MODETYPE_VGA);

   if (!pScrn->modePool) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "No Video BIOS modes for chosen depth.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

   VBESetModeNames(pScrn->modePool);

   /*
    * XXX DDC information: There's code in xf86ValidateModes
    * (VBEValidateModes) to set monitor defaults based on DDC information
    * where available.  If we need something that does better than this,
    * there's code in vesa/vesa.c.
    */

   /* XXX Need to get relevant modes and virtual parameters. */
   /* Do the mode validation without regard to special scanline pitches. */
   n = VBEValidateModes(pScrn, NULL, pScrn->display->modes, NULL,
			NULL, 0, MAX_DISPLAY_PITCH, 1,
			0, MAX_DISPLAY_HEIGHT,
			pScrn->display->virtualX,
			pScrn->display->virtualY,
			memsize, LOOKUP_BEST_REFRESH);
   if (n <= 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

   xf86PruneDriverModes(pScrn);

   pScrn->currentMode = pScrn->modes;

   if (pScrn->modes == NULL) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No modes.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

#ifndef USE_PITCHES
#define USE_PITCHES 1
d1541 28
a1568 38
   /*
    * If DRI is potentially usable, check if there is enough memory available
    * for it, and if there's also enough to allow tiling to be enabled.
    */
#if defined(XF86DRI)
   if (!pI830->directRenderingDisabled) {
      int savedDisplayWidth = pScrn->displayWidth;
      int memNeeded = 0;
      /* Good pitches to allow tiling.  Don't care about pitches < 256. */
      static const int pitches[] = {
	 128 * 2,
	 128 * 4,
	 128 * 8,
	 128 * 16,
	 128 * 32,
	 128 * 64,
	 0
      };

#ifdef I830_XV
      /*
       * Set this so that the overlay allocation is factored in when
       * appropriate.
       */
      pI830->XvEnabled = !pI830->XvDisabled;
#endif

      for (i = 0; pitches[i] != 0; i++) {
#if USE_PITCHES
	 if (pitches[i] >= pScrn->displayWidth) {
	    pScrn->displayWidth = pitches[i];
	    break;
	 }
#else
	 if (pitches[i] == pScrn->displayWidth)
	    break;
#endif
      }
d1570 2
a1571 73
      /*
       * If the displayWidth is a tilable pitch, test if there's enough
       * memory available to enable tiling.
       */
      if (pScrn->displayWidth == pitches[i]) {
	 I830ResetAllocations(pScrn, 0);
	 if (I830Allocate2DMemory(pScrn, ALLOCATE_DRY_RUN | ALLOC_INITIAL) &&
	     I830Allocate3DMemory(pScrn, ALLOCATE_DRY_RUN)) {
	    memNeeded = I830GetExcessMemoryAllocations(pScrn);
	    if (memNeeded > 0 || pI830->MemoryAperture.Size < 0) {
	       if (memNeeded > 0) {
		  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			     "%d kBytes additional video memory is "
			     "required to\n\tenable tiling mode for DRI.\n",
			     (memNeeded + 1023) / 1024);
	       }
	       if (pI830->MemoryAperture.Size < 0) {
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			     "Allocation with DRI tiling enabled would "
			     "exceed the\n"
			     "\tmemory aperture size (%ld kB) by %ld kB.\n"
			     "\tReduce VideoRam amount to avoid this!\n",
			     pI830->FbMapSize / 1024,
			     -pI830->MemoryAperture.Size / 1024);
	       }
	       pScrn->displayWidth = savedDisplayWidth;
	       pI830->allowPageFlip = FALSE;
	    } else if (pScrn->displayWidth != savedDisplayWidth) {
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			  "Increasing the scanline pitch to allow tiling mode "
			  "(%d -> %d).\n",
			  savedDisplayWidth, pScrn->displayWidth);
	    }
	 } else {
	    memNeeded = 0;
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Unexpected dry run allocation failure (1).\n");
	 }
      }
      if (memNeeded > 0 || pI830->MemoryAperture.Size < 0) {
	 /*
	  * Tiling can't be enabled.  Check if there's enough memory for DRI
	  * without tiling.
	  */
	 pI830->disableTiling = TRUE;
	 I830ResetAllocations(pScrn, 0);
	 if (I830Allocate2DMemory(pScrn, ALLOCATE_DRY_RUN | ALLOC_INITIAL) &&
	     I830Allocate3DMemory(pScrn, ALLOCATE_DRY_RUN | ALLOC_NO_TILING)) {
	    memNeeded = I830GetExcessMemoryAllocations(pScrn);
	    if (memNeeded > 0 || pI830->MemoryAperture.Size < 0) {
	       if (memNeeded > 0) {
		  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			     "%d kBytes additional video memory is required "
			     "to enable DRI.\n",
			     (memNeeded + 1023) / 1024);
	       }
	       if (pI830->MemoryAperture.Size < 0) {
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			     "Allocation with DRI enabled would "
			     "exceed the\n"
			     "\tmemory aperture size (%ld kB) by %ld kB.\n"
			     "\tReduce VideoRam amount to avoid this!\n",
			     pI830->FbMapSize / 1024,
			     -pI830->MemoryAperture.Size / 1024);
	       }
	       pI830->directRenderingDisabled = TRUE;
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Disabling DRI.\n");
	    }
	 } else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Unexpected dry run allocation failure (2).\n");
	 }
      }
d1575 17
a1591 83
   VBEPrintModes(pScrn);

   if (!pI830->vesa->useDefaultRefresh) {
      /*
       * This sets the parameters for the VBE modes according to the best
       * usable parameters from the Monitor sections modes (usually the
       * default VESA modes), allowing for better than default refresh rates.
       * This only works for VBE 3.0 and later.  Also, we only do this
       * if there are no non-CRT devices attached.
       */
      VBESetModeParameters(pScrn, pVbe);
   }

   /* PreInit shouldn't leave any state changes, so restore this. */
   RestoreBIOSMemSize(pScrn);

   /* Don't need MMIO access anymore. */
   if (pI830->swfSaved) {
      OUTREG(SWF0, pI830->saveSWF0);
      OUTREG(SWF4, pI830->saveSWF4);
   }
   I830UnmapMMIO(pScrn);

   /* Set display resolution */
   xf86SetDpi(pScrn, 0, 0);

   /* Load the required sub modules */
   if (!xf86LoadSubModule(pScrn, "fb")) {
      PreInitCleanup(pScrn);
      return FALSE;
   }

   xf86LoaderReqSymLists(I810fbSymbols, NULL);

   if (!pI830->noAccel) {
      if (!xf86LoadSubModule(pScrn, "xaa")) {
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I810xaaSymbols, NULL);
   }

   if (!pI830->SWCursor) {
      if (!xf86LoadSubModule(pScrn, "ramdac")) {
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I810ramdacSymbols, NULL);
   }

   /*  We won't be using the VGA access after the probe. */
   I830SetMMIOAccess(pI830);
   xf86SetOperatingState(resVgaIo, pI830->pEnt->index, ResUnusedOpr);
   xf86SetOperatingState(resVgaMem, pI830->pEnt->index, ResDisableOpr);

   VBEFreeVBEInfo(pI830->vbeInfo);
   vbeFree(pVbe);

   /* Use the VBE mode restore workaround by default. */
   pI830->vbeRestoreWorkaround = TRUE;
   from = X_DEFAULT;
   if (xf86ReturnOptValBool(pI830->Options, OPTION_VBE_RESTORE, FALSE)) {
      pI830->vbeRestoreWorkaround = FALSE;
      from = X_CONFIG;
   }
   xf86DrvMsg(pScrn->scrnIndex, from, "VBE Restore workaround: %s.\n",
	      pI830->vbeRestoreWorkaround ? "enabled" : "disabled");
      
#if defined(XF86DRI)
   /* Load the dri module if requested. */
   if (xf86ReturnOptValBool(pI830->Options, OPTION_DRI, FALSE) &&
       !pI830->directRenderingDisabled) {
      if (xf86LoadSubModule(pScrn, "dri")) {
	 xf86LoaderReqSymLists(I810driSymbols, I810drmSymbols, NULL);
      }
   }

   if (!pI830->directRenderingDisabled) {
      if (!xf86LoadSubModule(pScrn, "shadow")) {
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I810shadowSymbols, NULL);
d1595 33
a1627 2
   return TRUE;
}
a1628 37
/*
 * As the name says.  Check that the initial state is reasonable.
 * If any unrecoverable problems are found, bail out here.
 */
static Bool
CheckInheritedState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int errors = 0, fatal = 0;
   unsigned long temp, head, tail;

   /* Check first for page table errors */
   temp = INREG(PGE_ERR);
   if (temp != 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "PGTBL_ER is 0x%08lx\n", temp);
      errors++;
   }
   temp = INREG(PGETBL_CTL);
   if (!(temp & 1)) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "PGTBL_CTL (0x%08lx) indicates GTT is disabled\n", temp);
      errors++;
   }
   temp = INREG(LP_RING + RING_LEN);
   if (temp & 1) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "PRB0_CTL (0x%08lx) indicates ring buffer enabled\n", temp);
      errors++;
   }
   head = INREG(LP_RING + RING_HEAD);
   tail = INREG(LP_RING + RING_TAIL);
   if ((tail & I830_TAIL_MASK) != (head & I830_HEAD_MASK)) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "PRB0_HEAD (0x%08lx) and PRB0_TAIL (0x%08lx) indicate "
		 "ring buffer not flushed\n", head, tail);
      errors++;
   }
d1630 41
a1670 2
   if (errors)
      I830PrintErrorState(pScrn);
d1673 2
a1674 50
   if (fatal)
      FatalError("CheckInheritedState: can't recover from the above\n");

   return (errors != 0);
}

/*
 * Reset registers that it doesn't make sense to save/restore to a sane state.
 * This is basically the ring buffer and fence registers.  Restoring these
 * doesn't make sense without restoring GTT mappings.  This is something that
 * whoever gets control next should do.
 */
static void
ResetState(ScrnInfoPtr pScrn, Bool flush)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int i;
   unsigned long temp;

   DPRINTF(PFX, "ResetState: flush is %s\n", BOOLTOSTRING(flush));

   /* Reset the fence registers to 0 */
   for (i = 0; i < 8; i++)
      OUTREG(FENCE + i * 4, 0);

   /* Flush the ring buffer (if enabled), then disable it. */
   if (pI830->AccelInfoRec != NULL && flush) {
      temp = INREG(LP_RING + RING_LEN);
      if (temp & 1) {
	 I830RefreshRing(pScrn);
	 I830Sync(pScrn);
	 DO_RING_IDLE();
      }
   }
   OUTREG(LP_RING + RING_LEN, 0);
   OUTREG(LP_RING + RING_HEAD, 0);
   OUTREG(LP_RING + RING_TAIL, 0);
   OUTREG(LP_RING + RING_START, 0);

   if (pI830->CursorInfoRec && pI830->CursorInfoRec->HideCursor)
       pI830->CursorInfoRec->HideCursor(pScrn);
}

static void
SetFenceRegs(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int i;

   DPRINTF(PFX, "SetFenceRegs\n");
d1676 1
a1676 5
   for (i = 0; i < 8; i++) {
      OUTREG(FENCE + i * 4, pI830->ModeReg.Fence[i]);
      if (I810_DEBUG & DEBUG_VERBOSE_VGA)
	 ErrorF("Fence Register : %x\n", pI830->ModeReg.Fence[i]);
   }
d1679 3
a1681 2
static void
SetRingRegs(ScrnInfoPtr pScrn)
d1683 1
a1683 62
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned int itemp;

   DPRINTF(PFX, "SetRingRegs\n");

   if (pI830->noAccel)
      return;

   OUTREG(LP_RING + RING_LEN, 0);
   OUTREG(LP_RING + RING_TAIL, 0);
   OUTREG(LP_RING + RING_HEAD, 0);

   if ((pI830->LpRing.mem.Start & I830_RING_START_MASK) !=
       pI830->LpRing.mem.Start) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "I830SetRingRegs: Ring buffer start (%lx) violates its "
		 "mask (%x)\n", pI830->LpRing.mem.Start, I830_RING_START_MASK);
   }
   /* Don't care about the old value.  Reserved bits must be zero anyway. */
   itemp = pI830->LpRing.mem.Start & I830_RING_START_MASK;
   OUTREG(LP_RING + RING_START, itemp);

   if (((pI830->LpRing.mem.Size - 4096) & I830_RING_NR_PAGES) !=
       pI830->LpRing.mem.Size - 4096) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "I830SetRingRegs: Ring buffer size - 4096 (%lx) violates its "
		 "mask (%x)\n", pI830->LpRing.mem.Size - 4096,
		 I830_RING_NR_PAGES);
   }
   /* Don't care about the old value.  Reserved bits must be zero anyway. */
   itemp = (pI830->LpRing.mem.Size - 4096) & I830_RING_NR_PAGES;
   itemp |= (RING_NO_REPORT | RING_VALID);
   OUTREG(LP_RING + RING_LEN, itemp);
   I830RefreshRing(pScrn);
}

/*
 * This should be called everytime the X server gains control of the screen,
 * before any video modes are programmed (ScreenInit, EnterVT).
 */
static void
SetHWOperatingState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "SetHWOperatingState\n");

   if (!pI830->noAccel)
      SetRingRegs(pScrn);
   SetFenceRegs(pScrn);
   if (!pI830->SWCursor)
      I830InitHWCursor(pScrn);
}

static Bool
SaveHWState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   vgaHWPtr hwp = VGAHWPTR(pScrn);
   vgaRegPtr vgaReg = &hwp->SavedReg;
   VbeModeInfoBlock *modeInfo;
d1686 2
a1687 16
   DPRINTF(PFX, "SaveHWState\n");

   pVesa = pI830->vesa;
   /* Make sure we save at least this information in case of failure. */
   VBEGetVBEMode(pVbe, &pVesa->stateMode);
   modeInfo = VBEGetModeInfo(pVbe, pVesa->stateMode);
   pVesa->savedScanlinePitch = 0;
   if (modeInfo) {
      if (VBE_MODE_GRAPHICS(modeInfo)) {
         VBEGetLogicalScanline(pVbe, &pVesa->savedScanlinePitch, NULL, NULL);
      }
      VBEFreeModeInfo(modeInfo);
   }

   vgaHWUnlock(hwp);
   vgaHWSave(pScrn, vgaReg, VGA_SR_FONTS);
d1689 2
a1690 27
   pVesa = pI830->vesa;
   /*
    * This save/restore method doesn't work for 845G BIOS, or for some
    * other platforms.  Enable it in all cases.
    */
   /*
    * KW: This may have been because of the behaviour I've found on my
    * board: The 'save' command actually modifies the interrupt
    * registers, turning off the irq & breaking the kernel module
    * behaviour.
    */
   if (!pI830->vbeRestoreWorkaround) {
      CARD16 imr = INREG16(IMR);
      CARD16 ier = INREG16(IER);
      CARD16 hwstam = INREG16(HWSTAM);

      if (!VBESaveRestore(pVbe, MODE_SAVE, &pVesa->state, &pVesa->stateSize,
			  &pVesa->statePage)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "SaveHWState: VBESaveRestore(MODE_SAVE) failed.\n");
	 return FALSE;
      }

      OUTREG16(IMR, imr);
      OUTREG16(IER, ier);
      OUTREG16(HWSTAM, hwstam);
   }
d1692 14
a1705 6
   pVesa->savedPal = VBESetGetPaletteData(pVbe, FALSE, 0, 256,
					     NULL, FALSE, FALSE);
   if (!pVesa->savedPal) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "SaveHWState: VBESetGetPaletteData(GET) failed.\n");
      return FALSE;
d1711 2
a1712 2
static Bool
RestoreHWState(ScrnInfoPtr pScrn)
d1714 1
a1714 4
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   vgaHWPtr hwp = VGAHWPTR(pScrn);
   vgaRegPtr vgaReg = &hwp->SavedReg;
a1715 1
   Bool restored = FALSE;
d1717 2
a1718 1
   DPRINTF(PFX, "RestoreHWState\n");
d1720 5
a1724 1
   pVesa = pI830->vesa;
d1726 1
a1726 7
   /*
    * Workaround for text mode restoration with some flat panels.
    * Temporarily program a 640x480 mode before switching back to
    * text mode.
    */
   if (pVesa->useDefaultRefresh) {
      int mode = 0;
d1728 1
a1728 59
      switch (pScrn->depth) {
      case 8:
	 mode = 0x30;
	 break;
      case 15:
	 mode = 0x40;
	 break;
      case 16:
	 mode = 0x41;
	 break;
      case 24:
	 mode = 0x50;
	 break;
      }
      mode |= (1 << 15) | (1 << 14);
      I830VESASetVBEMode(pScrn, mode, NULL);
   }

   if (pVesa->state && pVesa->stateSize) {
      CARD16 imr = INREG16(IMR);
      CARD16 ier = INREG16(IER);
      CARD16 hwstam = INREG16(HWSTAM);

      /* Make a copy of the state.  Don't rely on it not being touched. */
      if (!pVesa->pstate) {
	 pVesa->pstate = xalloc(pVesa->stateSize);
	 if (pVesa->pstate)
	    memcpy(pVesa->pstate, pVesa->state, pVesa->stateSize);
      }
      restored = VBESaveRestore(pVbe, MODE_RESTORE, &pVesa->state,
				   &pVesa->stateSize, &pVesa->statePage);
      if (!restored) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "RestoreHWState: VBESaveRestore failed.\n");
      }
      /* Copy back */
      if (pVesa->pstate)
	 memcpy(pVesa->state, pVesa->pstate, pVesa->stateSize);

      OUTREG16(IMR, imr);
      OUTREG16(IER, ier);
      OUTREG16(HWSTAM, hwstam);
   }
   /* If that failed, restore the original mode. */
   if (!restored) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Setting the original video mode instead of restoring\n\t"
		 "the saved state\n");
      I830VESASetVBEMode(pScrn, pVesa->stateMode, NULL);
   }
   if (pVesa->savedScanlinePitch)
       VBESetLogicalScanline(pVbe, pVesa->savedScanlinePitch);

   if (pVesa->savedPal)
      VBESetGetPaletteData(pVbe, TRUE, 0, 256, pVesa->savedPal, FALSE, TRUE);

   vgaHWRestore(pScrn, vgaReg, VGA_SR_FONTS);
   vgaHWLock(hwp);
   return TRUE;
d1731 1
a1731 6
#ifndef USE_VBE
#define USE_VBE 1
#endif

static Bool
I830VESASetVBEMode(ScrnInfoPtr pScrn, int mode, VbeCRTCInfoBlock * block)
d1733 4
a1736 1
   I830Ptr pI830 = I830PTR(pScrn);
d1738 2
a1739 33
   DPRINTF(PFX, "Setting mode 0x%.8x\n", mode);
#if USE_VBE
   return VBESetVBEMode(pI830->pVbe, mode, block);
#else
   {
      vbeInfoPtr pVbe = pI830->pVbe;
      pVbe->pInt10->num = 0x10;
      pVbe->pInt10->ax = 0x80 | (mode & 0x7f);
      xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
      pVbe->pInt10->ax = 0x0f00;
      xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
      if ((pVbe->pInt10->ax & 0x7f) == (mode & 0x7f))
	 return TRUE;
      else
	 return FALSE;
   }
#endif
}

static Bool
I830VESASetMode(ScrnInfoPtr pScrn, DisplayModePtr pMode)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   VbeModeInfoData *data;
   int mode, i;
   CARD32 planeA, planeB, temp;
   int refresh = 60;
#ifdef XF86DRI
   Bool didLock = FALSE;
#endif

   DPRINTF(PFX, "I830VESASetMode\n");
d1741 1
a1741 1
   data = (VbeModeInfoData *) pMode->Private;
d1746 7
a1752 214
#ifdef XF86DRI
   if (pI830->directRenderingEnabled && !pI830->LockHeld) {
      DRILock(screenInfo.screens[pScrn->scrnIndex], 0);
      pI830->LockHeld = 1;
      didLock = TRUE;
   }
#endif

#ifndef MODESWITCH_RESET_STATE
#define MODESWITCH_RESET_STATE 0
#endif
#if MODESWITCH_RESET_STATE
   ResetState(pScrn, TRUE);
#endif

   /* XXX Add macros for the various mode parameter bits. */

   if (pI830->vesa->useDefaultRefresh)
      mode &= ~(1 << 11);

   if (I830VESASetVBEMode(pScrn, mode, data->block) == FALSE) {
      if ((data->block && (mode & (1 << 11))) &&
	  I830VESASetVBEMode(pScrn, (mode & ~(1 << 11)), NULL) == TRUE) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Set VBE Mode rejected this modeline.\n\t"
		    "Trying standard mode instead!\n");
	 DPRINTF(PFX, "OOPS!\n");
	 xfree(data->block);
	 data->block = NULL;
	 data->mode &= ~(1 << 11);
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Set VBE Mode failed!\n");
	 return FALSE;
      }
   }

   /*
    * Test if the extendedRefresh BIOS function is supported.
    */
   if (pI830->useExtendedRefresh && !pI830->vesa->useDefaultRefresh &&
       (mode & (1 << 11)) && data && data->data && data->block) {
      if (!SetRefreshRate(pScrn, mode, 60)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "BIOS call 0x5f05 not supported, "
		    "setting refresh with VBE 3 method.\n");
	 pI830->useExtendedRefresh = FALSE;
	 pI830->enableDisplays = FALSE;
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Not using BIOS call 0x5f64 to enable displays.\n");
      }
   }

   /*
    * The BIOS may not set a scanline pitch that would require more video
    * memory than it's aware of.  We check for this later, and set it
    * explicitly if necessary.
    */
   if (data->data->XResolution != pScrn->displayWidth)
      VBESetLogicalScanline(pVbe, pScrn->displayWidth);

   if (pScrn->bitsPerPixel >= 8 && pI830->vbeInfo->Capabilities[0] & 0x01)
      VBESetGetDACPaletteFormat(pVbe, 8);

   /*
    * XXX This location of this isn't correct.
    *
    * Turn on the configured displays.  This has the effect of resetting
    * the default refresh rates to values that the configured displays
    * can handle.  This seems to be the safest way to make sure that this
    * happens.  When it's safe to set higher values, we do that after this.
    *
    * Note: When a DFP is connected to an 830, this causes the mode setting
    * to be trashed.  So, we don't do it on the 830.
    *
    * XXX Need to test an 830 with a LFP.
    */
   if (pI830->enableDisplays) {
      if (!SetDisplayDevices(pScrn, pI830->configuredDevices)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Failed to switch to configured display devices\n");
      }
   }

   /*
    * When it's OK to set better than default refresh rates, set them here.
    */
   if (pI830->useExtendedRefresh && !pI830->vesa->useDefaultRefresh &&
       (mode & (1 << 11)) && data && data->data && data->block) {
      refresh = SetRefreshRate(pScrn, mode, data->block->RefreshRate / 100);
      if (!refresh) {
	 refresh = 60;
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Failed to set refresh rate to %dHz.\n",
		    data->block->RefreshRate / 100);
      }
   }


   /* XXX Fix plane A with pipe A, and plane B with pipe B. */
   planeA = INREG(DSPACNTR);
   planeB = INREG(DSPBCNTR);

   pI830->planeEnabled[0] = ((planeA & DISPLAY_PLANE_ENABLE) != 0);
   pI830->planeEnabled[1] = ((planeB & DISPLAY_PLANE_ENABLE) != 0);

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Display plane A is %s.\n",
	      pI830->planeEnabled[0] ? "enabled" : "disabled");
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Display plane B is %s.\n",
	      pI830->planeEnabled[1] ? "enabled" : "disabled");

   /*
    * Sometimes it seems that no display planes are enabled at this point.
    * For mobile platforms pick the plane(s) connected to enabled pipes.
    * For others choose plane A.
    */
   if (!pI830->planeEnabled[0] && !pI830->planeEnabled[1]) {
      if (IS_MOBILE(pI830)) {
	 if ((pI830->pipeEnabled[0] &&
	      ((planeA & DISPPLANE_SEL_PIPE_MASK) == DISPPLANE_SEL_PIPE_A)) ||
	     (pI830->pipeEnabled[1] &&
	      ((planeA & DISPPLANE_SEL_PIPE_MASK) == DISPPLANE_SEL_PIPE_B))) {
	    pI830->planeEnabled[0] = TRUE;
	 }
	 if ((pI830->pipeEnabled[0] &&
	      ((planeB & DISPPLANE_SEL_PIPE_MASK) == DISPPLANE_SEL_PIPE_A)) ||
	     (pI830->pipeEnabled[1] &&
	      ((planeB & DISPPLANE_SEL_PIPE_MASK) == DISPPLANE_SEL_PIPE_B))) {
	    pI830->planeEnabled[1] = TRUE;
	 }
      } else {
	 pI830->planeEnabled[0] = TRUE;
      }
      if (pI830->planeEnabled[0]) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Enabling plane A.\n");
	 planeA |= DISPLAY_PLANE_ENABLE;
	 OUTREG(DSPACNTR, planeA);
	 /* flush the change. */
	 temp = INREG(DSPABASE);
	 OUTREG(DSPABASE, temp);
      }
      if (pI830->planeEnabled[1]) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Enabling plane B.\n");
	 planeB |= DISPLAY_PLANE_ENABLE;
	 OUTREG(DSPBCNTR, planeB);
	 /* flush the change. */
	 temp = INREG(DSPBADDR);
	 OUTREG(DSPBADDR, temp);
      }
   }

   /* XXX Plane C is ignored for now (overlay). */

   /*
    * Print out the PIPEACONF and PIPEBCONF registers.
    */
   temp = INREG(PIPEACONF);
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PIPEACONF is 0x%08lx\n", temp);
   if (IS_MOBILE(pI830)) {
      temp = INREG(PIPEBCONF);
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PIPEBCONF is 0x%08lx\n", temp);
   }

#if PRINT_MODE_INFO
   /* Print out some CRTC/display information. */
   temp = INREG(HTOTAL_A);
   ErrorF("Horiz active: %d, Horiz total: %d\n", temp & 0x7ff,
	  (temp >> 16) & 0xfff);
   temp = INREG(HBLANK_A);
   ErrorF("Horiz blank start: %d, Horiz blank end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(HSYNC_A);
   ErrorF("Horiz sync start: %d, Horiz sync end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(VTOTAL_A);
   ErrorF("Vert active: %d, Vert total: %d\n", temp & 0x7ff,
	  (temp >> 16) & 0xfff);
   temp = INREG(VBLANK_A);
   ErrorF("Vert blank start: %d, Vert blank end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(VSYNC_A);
   ErrorF("Vert sync start: %d, Vert sync end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(PIPEASRC);
   ErrorF("Image size: %dx%d (%dx%d)\n",
          (temp >> 16) & 0x7ff, temp & 0x7ff,
	  (((temp >> 16) & 0x7ff) + 1), ((temp & 0x7ff) + 1));
   ErrorF("Pixel multiply is %d\n", (planeA >> 20) & 0x3);
   temp = INREG(DSPABASE);
   ErrorF("Plane A start offset is %d\n", temp);
   temp = INREG(DSPASTRIDE);
   ErrorF("Plane A stride is %d bytes (%d pixels)\n", temp, temp / pI830->cpp);
#endif

   for (i = 0; i < MAX_DISPLAY_PIPES; i++) {
      CARD32 stridereg = i ? DSPBSTRIDE : DSPASTRIDE;
      CARD32 basereg = i ? DSPBBASE : DSPABASE;

      if (!pI830->planeEnabled[i])
	 continue;

      temp = INREG(stridereg);
      if (temp / pI830->cpp != pScrn->displayWidth) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Correcting plane %c stride (%d -> %d)\n", PIPE_NAME(i),
		    (int)(temp / pI830->cpp), pScrn->displayWidth);
	 OUTREG(stridereg, pScrn->displayWidth * pI830->cpp);
	 /* Trigger update */
	 temp = INREG(basereg);
	 OUTREG(basereg, temp);
      }
   }

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Mode bandwidth is %d Mpixel/s\n",
	      pMode->HDisplay * pMode->VDisplay * refresh / 1000000);
d1754 17
a1770 2
   {
      int maxBandwidth, bandwidthA, bandwidthB;
d1772 61
a1832 7
      if (GetModeSupport(pScrn, 0x80, 0x80, 0x80, 0x80,
			&maxBandwidth, &bandwidthA, &bandwidthB)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "maxBandwidth is %d Mbyte/s, "
		    "pipe bandwidths are %d Mbyte/s, %d Mbyte/s\n",
		    maxBandwidth, bandwidthA, bandwidthB);
      }
   }
d1834 2
a1835 2
   {
      int ret;
d1837 2
a1838 6
      ret = GetLFPCompMode(pScrn);
      if (ret != -1) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "LFP compensation mode: 0x%x\n", ret);
      }
   }
d1840 2
a1841 4
#if MODESWITCH_RESET_STATE
   ResetState(pScrn, TRUE);
   SetHWOperatingState(pScrn);
#endif
d1844 5
a1848 4
   if (pI830->directRenderingEnabled && didLock) {
      DRIUnlock(screenInfo.screens[pScrn->scrnIndex]);
      pI830->LockHeld = 0;
   }
d1852 1
a1852 1
   return TRUE;
d1855 3
a1857 2
static void
InitRegisterRec(ScrnInfoPtr pScrn)
d1859 20
a1878 3
   I830Ptr pI830 = I830PTR(pScrn);
   I830RegPtr i830Reg = &pI830->ModeReg;
   int i;
d1880 1
a1880 3
   for (i = 0; i < 8; i++)
      i830Reg->Fence[i] = 0;
}
d1882 1
a1882 6
/* Famous last words
 */
void
I830PrintErrorState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
d1884 2
a1885 2
   ErrorF("pgetbl_ctl: 0x%lx pgetbl_err: 0x%lx\n",
	  INREG(PGETBL_CTL), INREG(PGE_ERR));
d1887 2
a1888 1
   ErrorF("ipeir: %lx iphdr: %lx\n", INREG(IPEIR), INREG(IPEHR));
d1890 8
a1897 4
   ErrorF("LP ring tail: %lx head: %lx len: %lx start %lx\n",
	  INREG(LP_RING + RING_TAIL),
	  INREG(LP_RING + RING_HEAD) & HEAD_ADDR,
	  INREG(LP_RING + RING_LEN), INREG(LP_RING + RING_START));
d1899 2
a1900 2
   ErrorF("eir: %x esr: %x emr: %x\n",
	  INREG16(EIR), INREG16(ESR), INREG16(EMR));
d1902 19
a1920 1
   ErrorF("instdone: %x instpm: %x\n", INREG16(INST_DONE), INREG8(INST_PM));
d1922 1
a1922 1
   ErrorF("memmode: %lx instps: %lx\n", INREG(MEMMODE), INREG(INST_PS));
d1924 1
a1924 2
   ErrorF("hwstam: %x ier: %x imr: %x iir: %x\n",
	  INREG16(HWSTAM), INREG16(IER), INREG16(IMR), INREG16(IIR));
d1928 1
a1928 2
static void
dump_DSPACNTR(ScrnInfoPtr pScrn)
d1930 1
a1930 1
   I830Ptr pI830 = I830PTR(pScrn);
d1934 2
a1935 2
   tmp = INREG(0x70180);
   ErrorF("Display A Plane Control Register (0x%.8x)\n", tmp);
d1938 1
a1938 1
      ErrorF("   Display Plane A (Primary) Enable\n");
d1940 1
a1940 1
      ErrorF("   Display Plane A (Primary) Disabled\n");
d1943 1
a1943 1
      ErrorF("   Display A pixel data is gamma corrected\n");
d1945 1
a1945 1
      ErrorF("   Display A pixel data bypasses gamma correction logic (default)\n");
d1947 25
a1971 24
   switch ((tmp & 0x3c000000) >> 26) {	/* bit 29:26 */
   case 0x00:
   case 0x01:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
   case 0x02:
      ErrorF("   8-bpp Indexed\n");
      break;
   case 0x04:
      ErrorF("   15-bit (5-5-5) pixel format (Targa compatible)\n");
      break;
   case 0x05:
      ErrorF("   16-bit (5-6-5) pixel format (XGA compatible)\n");
      break;
   case 0x06:
      ErrorF("   32-bit format (X:8:8:8)\n");
      break;
   case 0x07:
      ErrorF("   32-bit format (8:8:8:8)\n");
      break;
   default:
      ErrorF("   Unknown - Invalid register value maybe?\n");
   }
d1974 1
a1974 1
      ErrorF("   Stereo Enable\n");
d1976 1
a1976 1
      ErrorF("   Stereo Disable\n");
d1979 1
a1979 1
      ErrorF("   Display A, Pipe B Select\n");
d1981 1
a1981 1
      ErrorF("   Display A, Pipe A Select\n");
d1984 1
a1984 1
      ErrorF("   Source key is enabled\n");
d1986 1
a1986 1
      ErrorF("   Source key is disabled\n");
d1988 13
a2000 12
   switch ((tmp & 0x00300000) >> 20) {	/* bit 21:20 */
   case 0x00:
      ErrorF("   No line duplication\n");
      break;
   case 0x01:
      ErrorF("   Line/pixel Doubling\n");
      break;
   case 0x02:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
   }
d2003 1
a2003 1
      ErrorF("   Stereo output is high during second image\n");
d2005 1
a2005 1
      ErrorF("   Stereo output is high during first image\n");
d2008 1
a2008 2
static void
dump_DSPBCNTR(ScrnInfoPtr pScrn)
d2010 1
a2010 1
   I830Ptr pI830 = I830PTR(pScrn);
d2014 2
a2015 2
   tmp = INREG(0x71180);
   ErrorF("Display B/Sprite Plane Control Register (0x%.8x)\n", tmp);
d2018 1
a2018 1
      ErrorF("   Display B/Sprite Enable\n");
d2020 1
a2020 1
      ErrorF("   Display B/Sprite Disable\n");
d2023 1
a2023 1
      ErrorF("   Display B pixel data is gamma corrected\n");
d2025 1
a2025 1
      ErrorF("   Display B pixel data bypasses gamma correction logic (default)\n");
d2027 25
a2051 24
   switch ((tmp & 0x3c000000) >> 26) {	/* bit 29:26 */
   case 0x00:
   case 0x01:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
   case 0x02:
      ErrorF("   8-bpp Indexed\n");
      break;
   case 0x04:
      ErrorF("   15-bit (5-5-5) pixel format (Targa compatible)\n");
      break;
   case 0x05:
      ErrorF("   16-bit (5-6-5) pixel format (XGA compatible)\n");
      break;
   case 0x06:
      ErrorF("   32-bit format (X:8:8:8)\n");
      break;
   case 0x07:
      ErrorF("   32-bit format (8:8:8:8)\n");
      break;
   default:
      ErrorF("   Unknown - Invalid register value maybe?\n");
   }
d2054 1
a2054 1
      ErrorF("   Stereo is enabled and both start addresses are used in a two frame sequence\n");
d2056 1
a2056 1
      ErrorF("   Stereo disable and only a single start address is used\n");
d2059 1
a2059 1
      ErrorF("   Display B/Sprite, Pipe B Select\n");
d2061 1
a2061 1
      ErrorF("   Display B/Sprite, Pipe A Select\n");
d2064 1
a2064 1
      ErrorF("   Sprite source key is enabled\n");
d2066 1
a2066 1
      ErrorF("   Sprite source key is disabled (default)\n");
d2068 13
a2080 12
   switch ((tmp & 0x00300000) >> 20) {	/* bit 21:20 */
   case 0x00:
      ErrorF("   No line duplication\n");
      break;
   case 0x01:
      ErrorF("   Line/pixel Doubling\n");
      break;
   case 0x02:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
   }
d2083 1
a2083 1
      ErrorF("   Stereo output is high during second image\n");
d2085 1
a2085 1
      ErrorF("   Stereo output is high during first image\n");
d2088 1
a2088 1
      ErrorF("   Alpha transfer mode enabled\n");
d2090 1
a2090 1
      ErrorF("   Alpha transfer mode disabled\n");
d2093 1
a2093 1
      ErrorF("   Sprite is above overlay\n");
d2095 1
a2095 1
      ErrorF("   Sprite is above display A (default)\n");
d2098 1
a2098 2
void
I830_dump_registers(ScrnInfoPtr pScrn)
d2100 1
a2100 1
   I830Ptr pI830 = I830PTR(pScrn);
d2102 1
d2104 2
a2105 1
   ErrorF("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");
d2107 2
a2108 5
   dump_DSPACNTR(pScrn);
   dump_DSPBCNTR(pScrn);

   ErrorF("0x71400 == 0x%.8x\n", INREG(0x71400));
   ErrorF("0x70008 == 0x%.8x\n", INREG(0x70008));
d2110 1
a2110 1
      ErrorF("0x%x == 0x%.8x\n", i, INREG(i));
d2112 1
a2112 1
   ErrorF("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");
d2116 1
a2116 1
static Bool
d2121 2
a2122 1
   I830Ptr pI830;
a2123 3
#ifdef XF86DRI
   Bool driDisabled;
#endif
d2126 2
a2127 1
   pI830 = I830PTR(pScrn);
a2129 13
   pI830->starting = TRUE;

   /*
    * If we're changing the BIOS's view of the video memory size, do that
    * first, then re-initialise the VBE information.
    */
   pI830->pVbe = VBEInit(NULL, pI830->pEnt->index);
   if (!TweakMemorySize(pScrn, pI830->newBIOSMemSize,FALSE))
       SetBIOSMemSize(pScrn, pI830->newBIOSMemSize);
   if (!pI830->pVbe)
      return FALSE;
   pI830->vbeInfo = VBEGetVBEInfo(pI830->pVbe);

d2131 4
a2134 6
   if (!xf86SetDefaultVisual(pScrn, -1))
      return FALSE;
   if (pScrn->bitsPerPixel > 8) {
      if (!miSetVisualTypes(pScrn->depth, TrueColorMask,
			    pScrn->rgbBits, TrueColor))
	 return FALSE;
d2136 3
a2138 56
      if (!miSetVisualTypes(pScrn->depth,
			    miGetDefaultVisualMask(pScrn->depth),
			    pScrn->rgbBits, pScrn->defaultVisual))
	 return FALSE;
   }
   if (!miSetPixmapDepths())
      return FALSE;

#ifdef I830_XV
   pI830->XvEnabled = !pI830->XvDisabled;
   if (pI830->XvEnabled) {
      if (pI830->noAccel || pI830->StolenOnly) {
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Xv is disabled because it "
		    "needs 2D accel and AGPGART.\n");
	 pI830->XvEnabled = FALSE;
      }
   }
#else
   pI830->XvEnabled = FALSE;
#endif

   I830ResetAllocations(pScrn, 0);

   I830Allocate2DMemory(pScrn, ALLOC_INITIAL);

   if (!pI830->noAccel) {
      if (pI830->LpRing.mem.Size == 0) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     "Disabling acceleration because the ring buffer "
		      "allocation failed.\n");
	   pI830->noAccel = TRUE;
      }
   }

   if (!pI830->SWCursor) {
      if (pI830->CursorMem.Size == 0) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     "Disabling HW cursor because the cursor memory "
		      "allocation failed.\n");
	   pI830->SWCursor = TRUE;
      }
   }

#ifdef I830_XV
   if (pI830->XvEnabled) {
      if (pI830->noAccel) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Disabling Xv because it "
		    "needs 2D acceleration.\n");
	 pI830->XvEnabled = FALSE;
      }
      if (pI830->OverlayMem.Physical == 0) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     "Disabling Xv because the overlay register buffer "
		      "allocation failed.\n");
	 pI830->XvEnabled = FALSE;
      }
d2140 1
a2140 3
#endif

   InitRegisterRec(pScrn);
d2144 2
a2145 7
    * pI830->directRenderingDisabled is set once in PreInit.  Reinitialise
    * pI830->directRenderingEnabled based on it each generation.
    */
   pI830->directRenderingEnabled = !pI830->directRenderingDisabled;
   /*
    * Setup DRI after visuals have been established, but before fbScreenInit
    * is called.   fbScreenInit will eventually call into the drivers
d2149 6
a2154 19
   if (pI830->directRenderingEnabled) {
      if (pI830->noAccel || pI830->SWCursor || pI830->StolenOnly) {
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "DRI is disabled because it "
		    "needs HW cursor, 2D accel and AGPGART.\n");
	 pI830->directRenderingEnabled = FALSE;
      }
   }

   driDisabled = !pI830->directRenderingEnabled;

   if (pI830->directRenderingEnabled)
      pI830->directRenderingEnabled = I830DRIScreenInit(pScreen);

   if (pI830->directRenderingEnabled) {
      pI830->directRenderingEnabled =
	 I830Allocate3DMemory(pScrn,
			      pI830->disableTiling ? ALLOC_NO_TILING : 0);
      if (!pI830->directRenderingEnabled)
	  I830DRICloseScreen(pScreen);
a2155 1

d2157 2
a2158 11
   pI830->directRenderingEnabled = FALSE;
#endif

   /*
    * After the 3D allocations have been done, see if there's any free space
    * that can be added to the framebuffer allocation.
    */
   I830Allocate2DMemory(pScrn, 0);

   DPRINTF(PFX, "assert(if(!I830DoPoolAllocation(pScrn, pI830->StolenPool)))\n");
   if (!I830DoPoolAllocation(pScrn, &(pI830->StolenPool)))
d2160 1
a2160 3

   DPRINTF(PFX, "assert( if(!I830FixupOffsets(pScrn)) )\n");
   if (!I830FixupOffsets(pScrn))
a2161 6

#ifdef XF86DRI
   if (pI830->directRenderingEnabled) {
      I830SetupMemoryTiling(pScrn);
      pI830->directRenderingEnabled = I830DRIDoMappings(pScreen);
   }
d2164 2
a2165 6
   DPRINTF(PFX, "assert( if(!I830MapMem(pScrn)) )\n");
   if (!I830MapMem(pScrn))
      return FALSE;

   pScrn->memPhysBase = (unsigned long)pI830->FbBase;
   pScrn->fbOffset = pI830->FrontBuffer.Start;
d2167 2
a2168 2
   pI830->xoffset = (pScrn->fbOffset / pI830->cpp) % pScrn->displayWidth;
   pI830->yoffset = (pScrn->fbOffset / pI830->cpp) / pScrn->displayWidth;
d2170 1
a2170 1
   vgaHWSetMmioFuncs(hwp, pI830->MMIOBase, 0);
d2172 2
a2173 3
   DPRINTF(PFX, "assert( if(!vgaHWMapMem(pScrn)) )\n");
   if (!vgaHWMapMem(pScrn))
      return FALSE;
d2175 10
a2184 13
   /* Clear SavedReg */
   memset(&pI830->SavedReg, 0, sizeof(pI830->SavedReg));

   DPRINTF(PFX, "assert( if(!I830BIOSEnterVT(scrnIndex, 0)) )\n");
   if (!I830BIOSEnterVT(scrnIndex, 0))
      return FALSE;

   DPRINTF(PFX, "assert( if(!fbScreenInit(pScreen, ...) )\n");
   if (!fbScreenInit(pScreen, pI830->FbBase + pScrn->fbOffset,
		     pScrn->virtualX, pScrn->virtualY,
		     pScrn->xDpi, pScrn->yDpi,
		     pScrn->displayWidth, pScrn->bitsPerPixel))
      return FALSE;
d2186 1
a2186 1
   if (pScrn->bitsPerPixel > 8) {
d2189 2
a2190 2
      while (--visual >= pScreen->visuals) {
	 if ((visual->class | DynamicClass) == DirectColor) {
d2201 1
a2201 1
   fbPictureInit(pScreen, 0, 0);
d2203 5
a2207 1
   xf86SetBlackWhitePixels(pScreen);
d2209 9
a2217 2
#if 1
   I830DGAInit(pScreen);
d2220 4
a2223 3
   DPRINTF(PFX,
	   "assert( if(!xf86InitFBManager(pScreen, &(pI830->FbMemBox))) )\n");
   if (!xf86InitFBManager(pScreen, &(pI830->FbMemBox))) {
d2225 1
a2225 1
		 "Failed to init memory manager\n");
d2229 8
a2236 4
   if (!pI830->noAccel) {
      if (!I830AccelInit(pScreen)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Hardware acceleration initialization failed\n");
d2245 7
a2251 7
   if (!pI830->SWCursor) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Initializing HW Cursor\n");
      if (!I830CursorInit(pScreen))
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Hardware cursor initialization failed\n");
   } else
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Initializing SW Cursor!\n");
d2253 2
a2254 3
   DPRINTF(PFX, "assert( if(!miCreateDefColormap(pScreen)) )\n");
   if (!miCreateDefColormap(pScreen))
      return FALSE;
d2256 2
a2257 5
   DPRINTF(PFX, "assert( if(!xf86HandleColormaps(pScreen, ...)) )\n");
   if (!xf86HandleColormaps(pScreen, 256, 8, I830LoadPalette, 0,
			    CMAP_RELOAD_ON_MODE_SWITCH)) {
      return FALSE;
   }
d2259 1
d2261 1
d2263 1
a2263 5
#ifdef I830_XV
   /* Init video */
   if (pI830->XvEnabled)
      I830InitVideo(pScreen);
#endif
d2266 5
a2270 2
   if (pI830->directRenderingEnabled) {
      pI830->directRenderingEnabled = I830DRIFinishScreenInit(pScreen);
d2274 1
a2274 3
#ifdef XF86DRI
   if (pI830->directRenderingEnabled) {
      pI830->directRenderingOpen = TRUE;
d2277 1
d2279 4
d2284 1
a2284 1
      if (driDisabled)
d2286 1
a2286 1
      else
d2288 2
d2291 1
a2291 4
#else
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "direct rendering: Not available\n");
#endif

d2293 1
a2293 1
   pI830->CloseScreen = pScreen->CloseScreen;
d2298 1
a2298 1
#if 0
d2300 1
a2300 2
   I830_dump_registers(pScrn);
#endif
d2302 19
d2322 1
a2322 3
   pI830->starting = FALSE;
   pI830->closing = FALSE;
   pI830->suspended = FALSE;
d2326 1
a2326 1
static void
a2329 2
   I830Ptr pI830;
   vbeInfoPtr pVbe;
d2332 1
a2332 7
   pI830 = I830PTR(pScrn);
   pVbe = pI830->pVbe;

   DPRINTF(PFX, "I830BIOSAdjustFrame: y = %d (+ %d), x = %d (+ %d)\n",
	   x, pI830->xoffset, y, pI830->yoffset);

   VBESetDisplayStart(pVbe, x + pI830->xoffset, y + pI830->yoffset, TRUE);
d2335 1
a2335 1
static void
d2340 1
a2340 1
      vgaHWFreeHWRec(xf86Screens[scrnIndex]);
d2343 6
a2348 26
#ifndef SAVERESTORE_HWSTATE
#define SAVERESTORE_HWSTATE 0
#endif

#if SAVERESTORE_HWSTATE
static void
SaveHWOperatingState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   I830RegPtr save = &pI830->SavedReg;

   DPRINTF(PFX, "SaveHWOperatingState\n");

   return;
}

static void
RestoreHWOperatingState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   I830RegPtr save = &pI830->SavedReg;

   DPRINTF(PFX, "RestoreHWOperatingState\n");

   return;
}
d2351 1
a2351 7
static void
I830BIOSLeaveVT(int scrnIndex, int flags)
{
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "Leave VT\n");
d2354 5
a2358 5
   if (pI830->directRenderingOpen) {
      DPRINTF(PFX, "calling dri lock\n");
      DRILock(screenInfo.screens[scrnIndex], 0);
      pI830->LockHeld = 1;
   }
d2361 6
a2366 3
#if SAVERESTORE_HWSTATE
   if (!pI830->closing)
      SaveHWOperatingState(pScrn);
d2369 1
a2369 7
   ResetState(pScrn, TRUE);
   RestoreHWState(pScrn);
   RestoreBIOSMemSize(pScrn);
   I830UnbindGARTMemory(pScrn);
   if (pI830->AccelInfoRec)
      pI830->AccelInfoRec->NeedToSync = FALSE;
}
d2371 1
a2371 8
/*
 * This gets called when gaining control of the VT, and from ScreenInit().
 */
static Bool
I830BIOSEnterVT(int scrnIndex, int flags)
{
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);
d2373 2
a2374 1
   DPRINTF(PFX, "Enter VT\n");
d2376 4
a2379 2
   if (!I830BindGARTMemory(pScrn))
      return FALSE;
d2381 1
a2381 3
   CheckInheritedState(pScrn);
   if (!TweakMemorySize(pScrn, pI830->newBIOSMemSize,FALSE))
       SetBIOSMemSize(pScrn, pI830->newBIOSMemSize);
d2383 1
a2383 10
   /*
    * Only save state once per server generation since that's what most
    * drivers do.  Could change this to save state at each VT enter.
    */
   if (pI830->SaveGeneration != serverGeneration) {
      pI830->SaveGeneration = serverGeneration;
      SaveHWState(pScrn);
   }
   ResetState(pScrn, FALSE);
   SetHWOperatingState(pScrn);
d2385 6
a2390 4
#if 1
   /* Clear the framebuffer */
   memset(pI830->FbBase + pScrn->fbOffset, 0,
	  pScrn->virtualY * pScrn->displayWidth * pI830->cpp);
d2393 14
a2406 4
   if (!I830VESASetMode(pScrn, pScrn->currentMode))
      return FALSE;
#ifdef I830_XV
   I830VideoSwitchModeAfter(pScrn, pScrn->currentMode);
d2409 2
a2410 2
   ResetState(pScrn, TRUE);
   SetHWOperatingState(pScrn);
d2412 1
a2412 1
   pScrn->AdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
d2414 6
a2419 17
#if SAVERESTORE_HWSTATE
   RestoreHWOperatingState(pScrn);
#endif

#ifdef XF86DRI
   if (pI830->directRenderingEnabled) {
      if (!pI830->starting) {
	 I830EmitInvarientState(pScrn);
	 I830RefreshRing(pScrn);
	 I830Sync(pScrn);
	 DO_RING_IDLE();

	 DPRINTF(PFX, "calling dri unlock\n");
	 DRIUnlock(screenInfo.screens[scrnIndex]);
      }
      pI830->LockHeld = 0;
   }
d2422 1
a2422 1
   return TRUE;
d2425 1
a2425 1
static Bool
d2428 2
a2429 39

   int _head;
   int _tail;
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);
   int ret = TRUE;

   DPRINTF(PFX, "I830BIOSSwitchMode: mode == %p\n", mode);

   /* Stops head pointer freezes for 845G */
   if (!pI830->noAccel && (1 || IS_845G(pI830))) {
      do {
	 _head = INREG(LP_RING + RING_HEAD) & I830_HEAD_MASK;
	 _tail = INREG(LP_RING + RING_TAIL) & I830_TAIL_MASK;
	 DELAY(1000);
      } while (_head != _tail);
   }

#ifndef BINDUNBIND
#define BINDUNBIND 0
#endif
#if BINDUNBIND
   I830UnbindGARTMemory(pScrn);
#endif
#ifdef I830_XV
   /* Give the video overlay code a chance to see the new mode. */
   I830VideoSwitchModeBefore(pScrn, mode);
#endif
   if (!I830VESASetMode(pScrn, mode))
      ret = FALSE;
#ifdef I830_XV
   /* Give the video overlay code a chance to see the new mode. */
   I830VideoSwitchModeAfter(pScrn, mode);
#endif
#if BINDUNBIND
   I830BindGARTMemory(pScrn);
#endif

   return ret;
d2432 2
a2433 2
static Bool
I830BIOSSaveScreen(ScreenPtr pScreen, int mode)
d2435 1
a2435 38
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   Bool on = xf86IsUnblank(mode);
   CARD32 temp, ctrl, base, i;

   DPRINTF(PFX, "I830BIOSSaveScreen: %d, on is %s\n", mode, BOOLTOSTRING(on));

   if (pScrn->vtSema) {
      for (i = 0; i < MAX_DISPLAY_PIPES; i++) {
	 if (i == 0) {
	    ctrl = DSPACNTR;
	    base = DSPABASE;
	 } else {
	    ctrl = DSPBCNTR;
	    base = DSPBADDR;
	 }
	 if (pI830->planeEnabled[i]) {
	    temp = INREG(ctrl);
	    if (on)
	       temp |= DISPLAY_PLANE_ENABLE;
	    else
	       temp &= ~DISPLAY_PLANE_ENABLE;
	    OUTREG(ctrl, temp);
	    /* Flush changes */
	    temp = INREG(base);
	    OUTREG(base, temp);
	 }
      }

      if (pI830->CursorInfoRec && !pI830->SWCursor && pI830->cursorOn) {
	 if (on)
	    pI830->CursorInfoRec->ShowCursor(pScrn);
	 else
	    pI830->CursorInfoRec->HideCursor(pScrn);
	 pI830->cursorOn = TRUE;
      }
   }
   return TRUE;
a2437 1
/* Use the VBE version when available. */
d2440 1
a2440 1
			      int flags)
d2442 2
a2443 2
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
d2445 9
a2453 21
   if (xf86LoaderCheckSymbol("VBEDPMSSet")) {
      VBEDPMSSet(pVbe, PowerManagementMode);
   } else {
      pVbe->pInt10->num = 0x10;
      pVbe->pInt10->ax = 0x4f10;
      pVbe->pInt10->bx = 0x01;

      switch (PowerManagementMode) {
      case DPMSModeOn:
	 break;
      case DPMSModeStandby:
	 pVbe->pInt10->bx |= 0x0100;
	 break;
      case DPMSModeSuspend:
	 pVbe->pInt10->bx |= 0x0200;
	 break;
      case DPMSModeOff:
	 pVbe->pInt10->bx |= 0x0400;
	 break;
      }
      xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
d2455 2
d2459 1
a2459 1
static Bool
d2463 4
a2466 2
   I830Ptr pI830 = I830PTR(pScrn);
   XAAInfoRecPtr infoPtr = pI830->AccelInfoRec;
a2467 1
   pI830->closing = TRUE;
d2469 3
a2471 3
   if (pI830->directRenderingOpen) {
      pI830->directRenderingOpen = FALSE;
      I830DRICloseScreen(pScreen);
d2476 9
a2484 1
      I830BIOSLeaveVT(scrnIndex, 0);
d2487 1
a2487 2
   DPRINTF(PFX, "\nUnmapping memory\n");
   I830UnmapMem(pScrn);
d2490 3
a2492 3
   if (pI830->ScanlineColorExpandBuffers) {
      xfree(pI830->ScanlineColorExpandBuffers);
      pI830->ScanlineColorExpandBuffers = 0;
d2495 3
a2497 3
   if (infoPtr) {
      if (infoPtr->ScanlineColorExpandBuffers)
	 xfree(infoPtr->ScanlineColorExpandBuffers);
d2499 1
a2499 1
      pI830->AccelInfoRec = NULL;
d2502 3
a2504 3
   if (pI830->CursorInfoRec) {
      xf86DestroyCursorInfoRec(pI830->CursorInfoRec);
      pI830->CursorInfoRec = 0;
d2507 6
d2515 3
a2517 91
   pScrn->vtSema = FALSE;
   pI830->closing = FALSE;
   pScreen->CloseScreen = pI830->CloseScreen;
   return (*pScreen->CloseScreen) (scrnIndex, pScreen);
}

static ModeStatus
I830ValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
{
   if (mode->Flags & V_INTERLACE) {
      if (verbose) {
	 xf86DrvMsg(scrnIndex, X_PROBED,
		    "Removing interlaced mode \"%s\"\n", mode->name);
      }
      return MODE_BAD;
   }
   return MODE_OK;
}

#ifndef SUSPEND_SLEEP
#define SUSPEND_SLEEP 0
#endif
#ifndef RESUME_SLEEP
#define RESUME_SLEEP 0
#endif

/*
 * This function is only required if we need to do anything differently from
 * DoApmEvent() in common/xf86PM.c, including if we want to see events other
 * than suspend/resume.
 */
static Bool
I830PMEvent(int scrnIndex, pmEvent event, Bool undo)
{
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "Enter VT, event %d, undo: %s\n", event, BOOLTOSTRING(undo));

   switch(event) {
   case XF86_APM_SYS_SUSPEND:
   case XF86_APM_CRITICAL_SUSPEND: /*do we want to delay a critical suspend?*/
   case XF86_APM_USER_SUSPEND:
   case XF86_APM_SYS_STANDBY:
   case XF86_APM_USER_STANDBY:
      if (!undo && !pI830->suspended) {
	 pScrn->LeaveVT(scrnIndex, 0);
	 pI830->suspended = TRUE;
	 sleep(SUSPEND_SLEEP);
      } else if (undo && pI830->suspended) {
	 sleep(RESUME_SLEEP);
	 pScrn->EnterVT(scrnIndex, 0);
	 pI830->suspended = FALSE;
      }
      break;
   case XF86_APM_STANDBY_RESUME:
   case XF86_APM_NORMAL_RESUME:
   case XF86_APM_CRITICAL_RESUME:
      if (pI830->suspended) {
	 sleep(RESUME_SLEEP);
	 pScrn->EnterVT(scrnIndex, 0);
	 pI830->suspended = FALSE;
	 /*
	  * Turn the screen saver off when resuming.  This seems to be
	  * needed to stop xscreensaver kicking in (when used).
	  *
	  * XXX DoApmEvent() should probably call this just like
	  * xf86VTSwitch() does.  Maybe do it here only in 4.2
	  * compatibility mode.
	  */
	 SaveScreens(SCREEN_SAVER_FORCER, ScreenSaverReset);
      }
      break;
   default:
      ErrorF("I830PMEvent: received APM event %d\n", event);
   }
   return TRUE;
}

void
I830InitpScrn(ScrnInfoPtr pScrn)
{
   pScrn->PreInit = I830BIOSPreInit;
   pScrn->ScreenInit = I830BIOSScreenInit;
   pScrn->SwitchMode = I830BIOSSwitchMode;
   pScrn->AdjustFrame = I830BIOSAdjustFrame;
   pScrn->EnterVT = I830BIOSEnterVT;
   pScrn->LeaveVT = I830BIOSLeaveVT;
   pScrn->FreeScreen = I830BIOSFreeScreen;
   pScrn->ValidMode = I830ValidMode;
   pScrn->PMEvent = I830PMEvent;
a2518 1

@


1.1.9.2
log
@Import XFree86 4.4 from The XFree86(TM) Project, Inc.
(integrity cannot be checked)

got via cvs -qd anoncvs@@anoncvs.xfree86.org:/cvs co -Prxf-4_4_0 xc
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_driver.c,v 1.51 2004/02/25 12:53:14 eich Exp $ */
d205 1
a205 2
   OPTION_VBE_RESTORE,
   OPTION_DISPLAY_INFO
a217 1
   {OPTION_DISPLAY_INFO,"DisplayInfo",	OPTV_BOOLEAN,	{0},	FALSE},
d791 3
a793 10
   
   /* This seems to lockup some Dell BIOS'. So it's on option to turn on */
   if (pI830->displayInfo) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		  "Broken BIOSes cause the system to hang here.\n"
		  "\t      If you encounter this problem please add \n"
		  "\t\t Option \"DisplayInfo\" \"FALSE\"\n"
		  "\t      to the Device section of your XF86Config file.\n");
      for (i = 0; i < NumKnownDisplayTypes; i++) {
         if (GetDisplayInfo(pScrn, 1 << i, &pI830->displayAttached[i],
d797 1
a797 1
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
a802 1
         }
a1815 9

   pI830->displayInfo = TRUE;
   from = X_DEFAULT;
   if (!xf86ReturnOptValBool(pI830->Options, OPTION_DISPLAY_INFO, TRUE)) {
      from = X_CONFIG;
      pI830->displayInfo = FALSE;
   }
   xf86DrvMsg(pScrn->scrnIndex, from, "Display Info: %s.\n",
	      pI830->displayInfo ? "enabled" : "disabled");
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_driver.c,v 1.27 2003/02/14 17:12:42 dawes Exp $ */
a4 1
Copyright © 2002 by David Dawes
d22 1
a22 1
THE COPYRIGHT HOLDERS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
d27 1
d30 1
a30 17
/*
 * Reformatted with GNU indent (2.2.8), using the following options:
 *
 *    -bad -bap -c41 -cd0 -ncdb -ci6 -cli0 -cp0 -ncs -d0 -di3 -i3 -ip3 -l78
 *    -lp -npcs -psl -sob -ss -br -ce -sc -hnl
 *
 * This provides a good match with the original i810 code and preferred
 * XFree86 formatting conventions.
 *
 * When editing this driver, please follow the existing formatting, and edit
 * with <TAB> characters expanded at 8-column intervals.
 */

/*
 * Authors: Jeff Hartmann <jhartmann@@valinux.com>
 *          Abraham van der Merwe <abraham@@2d3d.co.za>
 *          David Dawes <dawes@@tungstengraphics.com>
d33 2
a34 3
/*
 * Mode handling is based on the VESA driver written by:
 * Paulo César Pereira de Andrade <pcpa@@conectiva.com.br>
d77 1
a77 1
 *          suspect this is a BIOS bug (hence the 1280x1024@@85Hz case)).
a88 37
/*
 *    07/2002 David Dawes
 *        - Add Intel(R) 855GM/852GM support.
 */
/*
 *    07/2002 David Dawes
 *        - Cleanup code formatting.
 *        - Improve VESA mode selection, and fix refresh rate selection.
 *        - Don't duplicate functions provided in 4.2 vbe modules.
 *        - Don't duplicate functions provided in the vgahw module.
 *        - Rewrite memory allocation.
 *        - Rewrite initialisation and save/restore state handling.
 *        - Decouple the i810 support from i830 and later.
 *        - Remove various unnecessary hacks and workarounds.
 *        - Fix an 845G problem with the ring buffer not in pre-allocated
 *          memory.
 *        - Fix screen blanking.
 *        - Clear the screen at startup so you don't see the previous session.
 *        - Fix some HW cursor glitches, and turn HW cursor off at VT switch
 *          and exit.
 *
 *    08/2002 Keith Whitwell
 *        - Fix DRI initialisation.
 */
/*
 *    08/2002 Alan Hourihane and David Dawes
 *        - Add XVideo support.
 */
/*
 *    10/2002 David Dawes
 *        - Add Intel(R) 865G support.
 */


#ifndef PRINT_MODE_INFO
#define PRINT_MODE_INFO 0
#endif
a106 1
#include "vbeModes.h"
d108 1
a108 1
#include "i830.h"
a117 1
/* *INDENT-OFF* */
d119 2
a120 5
   {PCI_CHIP_I830_M,		"i830"},
   {PCI_CHIP_845_G,		"845G"},
   {PCI_CHIP_I855_GM,		"852GM/855GM"},
   {PCI_CHIP_I865_G,		"865G"},
   {-1,				NULL}
d124 2
a125 5
   {PCI_CHIP_I830_M,		PCI_CHIP_I830_M,	RES_SHARED_VGA},
   {PCI_CHIP_845_G,		PCI_CHIP_845_G,		RES_SHARED_VGA},
   {PCI_CHIP_I855_GM,		PCI_CHIP_I855_GM,	RES_SHARED_VGA},
   {PCI_CHIP_I865_G,		PCI_CHIP_I865_G,	RES_SHARED_VGA},
   {-1,				-1,			RES_UNDEFINED}
a127 19
/*
 * Note: "ColorKey" is provided for compatibility with the i810 driver.
 * However, the correct option name is "VideoKey".  "ColorKey" usually
 * refers to the tranparency key for 8+24 overlays, not for video overlays.
 */

typedef enum {
   OPTION_NOACCEL,
   OPTION_SW_CURSOR,
   OPTION_CACHE_LINES,
   OPTION_DRI,
   OPTION_PAGEFLIP,
   OPTION_XVIDEO,
   OPTION_VIDEO_KEY,
   OPTION_COLOR_KEY,
   OPTION_STRETCH,
   OPTION_CENTER
} I830Opts;

d129 7
a135 11
   {OPTION_NOACCEL,	"NoAccel",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_SW_CURSOR,	"SWcursor",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_CACHE_LINES,	"CacheLines",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_DRI,		"DRI",		OPTV_BOOLEAN,	{0},	TRUE},
   {OPTION_PAGEFLIP,	"PageFlip",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_XVIDEO,	"XVideo",	OPTV_BOOLEAN,	{0},	TRUE},
   {OPTION_COLOR_KEY,	"ColorKey",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_VIDEO_KEY,	"VideoKey",	OPTV_INTEGER,	{0},	FALSE},
   {OPTION_STRETCH,	"Stretch",	OPTV_BOOLEAN,	{0},	FALSE},
   {OPTION_CENTER,	"Center",	OPTV_BOOLEAN,	{0},	FALSE},
   {-1,			NULL,		OPTV_NONE,	{0},	FALSE}
a136 1
/* *INDENT-ON* */
d138 7
d146 2
a147 11
					  int PowerManagementMode, int flags);
static void I830BIOSAdjustFrame(int scrnIndex, int x, int y, int flags);
static Bool I830BIOSCloseScreen(int scrnIndex, ScreenPtr pScreen);
static Bool I830BIOSSaveScreen(ScreenPtr pScreen, int unblack);
static Bool I830BIOSEnterVT(int scrnIndex, int flags);
static Bool I830VESASetVBEMode(ScrnInfoPtr pScrn, int mode,
			       VbeCRTCInfoBlock *block);

static Bool OffsetFrame = FALSE;


d150 16
a165 13
void
I830DPRINTF_stub(const char *filename, int line, const char *function,
		 const char *fmt, ...)
{
   va_list ap;

   ErrorF("\n##############################################\n"
	  "*** In function %s, on line %d, in file %s ***\n",
	  function, line, filename);
   va_start(ap, fmt);
   VErrorF(fmt, ap);
   va_end(ap);
   ErrorF("##############################################\n\n");
d167 1
a167 8
#else /* #ifdef I830DEBUG */
void
I830DPRINTF_stub(const char *filename, int line, const char *function,
		 const char *fmt, ...)
{
   /* do nothing */
}
#endif /* #ifdef I830DEBUG */
a168 1
/* XXX Check if this is still needed. */
d174 2
a175 3
   for (i = 0; I830BIOSPciChipsets[i].PCIid > 0; i++) {
      if (chipid == I830BIOSPciChipsets[i].PCIid)
	 return I830BIOSOptions;
d180 162
d345 1
a345 1
   I830Ptr pI830;
d347 3
a349 4
   if (pScrn->driverPrivate)
      return TRUE;
   pI830 = pScrn->driverPrivate = xnfcalloc(sizeof(I830Rec), 1);
   pI830->vesa = xnfcalloc(sizeof(VESARec), 1);
d356 1
a356 1
   I830Ptr pI830;
d360 2
a361 4
   if (!pScrn)
      return;
   if (!pScrn->driverPrivate)
      return;
d363 1
a363 1
   pI830 = I830PTR(pScrn);
d365 1
d369 2
a370 2
	 if (mode->Private) {
	    VbeModeInfoData *data = (VbeModeInfoData *) mode->Private;
d372 1
a372 2
	    if (data->block)
	       xfree(data->block);
d377 1
a377 1
      } while (mode && mode != pScrn->modes);
d380 5
a384 12
   if (pI830->vbeInfo)
      VBEFreeVBEInfo(pI830->vbeInfo);
   if (pI830->pVbe)
      vbeFree(pI830->pVbe);

   pVesa = pI830->vesa;
   if (pVesa->monitor)
      xfree(pVesa->monitor);
   if (pVesa->savedPal)
      xfree(pVesa->savedPal);
   xfree(pVesa);

d386 1
a386 1
   pScrn->driverPrivate = NULL;
d389 1
a389 1
static void
d393 6
d400 4
a403 4
   /* The vbe module gets loaded in PreInit(), so no need to load it here. */

   pVbe = VBEInit(NULL, index);
   ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
a405 6
/* Various extended video BIOS functions. */
static const int refreshes[] = {
   43, 56, 60, 70, 72, 75, 85, 100, 120
};
static const int nrefreshes = sizeof(refreshes) / sizeof(refreshes[0]);

d407 1
a407 1
Check5fStatus(ScrnInfoPtr pScrn, int func, int ax)
d409 2
a410 17
   if (ax == 0x005f)
      return TRUE;
   else if (ax == 0x015f) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Extended BIOS function 0x%04x failed.\n", func);
      return FALSE;
   } else if ((ax & 0xff) != 0x5f) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Extended BIOS function 0x%04x not supported.\n", func);
      return FALSE;
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Extended BIOS function 0x%04x returns 0x%04x.\n",
		 func, ax & 0xffff);
      return FALSE;
   }
}
d412 2
a413 5
#if 0
static int
BitToRefresh(int bits)
{
   int i;
d415 10
a424 5
   for (i = 0; i < nrefreshes; i++)
      if (bits & (1 << i))
	 return refreshes[i];
   return 0;
}
d426 1
a426 4
static int
GetRefreshRate(ScrnInfoPtr pScrn, int mode, int refresh, int *availRefresh)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
d428 6
a433 1
   DPRINTF(PFX, "GetRefreshRate\n");
d435 2
a436 17
   /* Only 8-bit mode numbers are supported. */
   if (mode & 0x100)
      return 0;

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f05;
   pVbe->pInt10->bx = (mode & 0xff) | 0x100;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f05, pVbe->pInt10->ax)) {
      if (availRefresh)
         *availRefresh = pVbe->pInt10->bx;
      return BitToRefresh(pVbe->pInt10->cx);
   } else
      return 0;
}
#endif
d438 2
a439 5
static int
SetRefreshRate(ScrnInfoPtr pScrn, int mode, int refresh)
{
   int i;
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
d441 2
a442 1
   DPRINTF(PFX, "SetRefreshRate: mode 0x%x, refresh: %d\n", mode, refresh);
d444 2
a445 30
   /* Only 8-bit mode numbers are supported. */
   if (mode & 0x100)
      return 0;

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f05;
   pVbe->pInt10->bx = mode & 0xff;

   for (i = nrefreshes - 1; i >= 0; i--) {
      /*
       * Look for the highest value that the requested (refresh + 2) is
       * greater than or equal to.
       */
      if (refreshes[i] <= (refresh + 2))
	 break;
   }
   /* i can be 0 if the requested refresh was higher than the max. */
   if (i == 0) {
      if (refresh >= refreshes[nrefreshes - 1])
         i = nrefreshes - 1;
   }
   DPRINTF(PFX, "Setting refresh rate to %dHz for mode 0x%02x\n",
	   refreshes[i], mode & 0xff);
   pVbe->pInt10->cx = 1 << i;
   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f05, pVbe->pInt10->ax))
      return refreshes[i];
   else
      return 0;
}
d447 3
a449 21
static Bool
GetModeSupport(ScrnInfoPtr pScrn, int modePipeA, int modePipeB,
	       int devicesPipeA, int devicesPipeB, int *maxBandwidth,
	       int *bandwidthPipeA, int *bandwidthPipeB)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;

   DPRINTF(PFX, "GetModeSupport: modes 0x%x, 0x%x, devices: 0x%x, 0x%x\n",
	   modePipeA, modePipeB, devicesPipeA, devicesPipeB);

   /* Only 8-bit mode numbers are supported. */
   if ((modePipeA & 0x100) || (modePipeB & 0x100))
      return 0;

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f28;
   pVbe->pInt10->bx = (modePipeA & 0xff) | ((modePipeB & 0xff) << 8);
   if ((devicesPipeA & 0x80) || (devicesPipeB & 0x80))
      pVbe->pInt10->cx = 0x8000;
   else
      pVbe->pInt10->cx = (devicesPipeA & 0xff) | ((devicesPipeB & 0xff) << 8);
d451 12
a462 13
   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f28, pVbe->pInt10->ax)) {
      if (maxBandwidth)
	 *maxBandwidth = pVbe->pInt10->cx;
      if (bandwidthPipeA)
	 *bandwidthPipeA = pVbe->pInt10->dx & 0xffff;
      /* XXX For XFree86 4.2.0 and earlier, ->dx is truncated to 16 bits. */
      if (bandwidthPipeB)
	 *bandwidthPipeB = (pVbe->pInt10->dx >> 16) & 0xffff;
      return TRUE;
   } else
      return FALSE;
}
d464 2
a465 4
static int
GetLFPCompMode(ScrnInfoPtr pScrn)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
d467 2
a468 1
   DPRINTF(PFX, "GetLFPCompMode\n");
d470 3
a472 3
   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f61;
   pVbe->pInt10->bx = 0x100;
d474 1
a474 5
   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f61, pVbe->pInt10->ax))
      return pVbe->pInt10->cx & 0xffff;
   else
      return -1;
d477 1
a477 3
#if 0
static Bool
SetLFPCompMode(ScrnInfoPtr pScrn, int compMode)
d479 8
a486 1
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
d488 2
a489 1
   DPRINTF(PFX, "SetLFPCompMode: compMode %d\n", compMode);
d491 28
a518 4
   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f61;
   pVbe->pInt10->bx = 0;
   pVbe->pInt10->cx = compMode;
d520 1
a520 2
   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   return Check5fStatus(pScrn, 0x5f61, pVbe->pInt10->ax);
a521 1
#endif
d523 1
a523 2
static int
GetDisplayDevices(ScrnInfoPtr pScrn)
d525 14
a538 2
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
d540 1
a540 1
   DPRINTF(PFX, "GetDisplayDevices\n");
d542 3
a544 32
#if 0
   {
      CARD32 temp;
      ErrorF("ADPA is 0x%08x\n", INREG(ADPA));
      ErrorF("DVOA is 0x%08x\n", INREG(DVOA));
      ErrorF("DVOB is 0x%08x\n", INREG(DVOB));
      ErrorF("DVOC is 0x%08x\n", INREG(DVOC));
      ErrorF("LVDS is 0x%08x\n", INREG(LVDS));
      temp = INREG(DVOA_SRCDIM);
      ErrorF("DVOA_SRCDIM is 0x%08x (%d x %d)\n", temp,
	     (temp >> 12) & 0xfff, temp & 0xfff);
      temp = INREG(DVOB_SRCDIM);
      ErrorF("DVOB_SRCDIM is 0x%08x (%d x %d)\n", temp,
	     (temp >> 12) & 0xfff, temp & 0xfff);
      temp = INREG(DVOC_SRCDIM);
      ErrorF("DVOC_SRCDIM is 0x%08x (%d x %d)\n", temp,
	     (temp >> 12) & 0xfff, temp & 0xfff);
      ErrorF("SWF0 is 0x%08x\n", INREG(SWF0));
      ErrorF("SWF4 is 0x%08x\n", INREG(SWF4));
   }
#endif

   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x100;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax))
      return pVbe->pInt10->cx & 0xffff;
   else
      return -1;
}
d546 3
a548 6
static Bool
SetDisplayDevices(ScrnInfoPtr pScrn, int devices)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   CARD32 temp;
d550 2
a551 1
   DPRINTF(PFX, "SetDisplayDevices: devices 0x%x\n", devices);
d553 2
a554 4
   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x1;
   pVbe->pInt10->cx = devices;
d556 2
a557 12
   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax))
      return TRUE;
   else {
      ErrorF("Writing config directly to SWF0\n");
      temp = INREG(SWF0);
      OUTREG(SWF0, (temp & ~(0xffff)) | (devices & 0xffff));
      ErrorF("SetDisplayDevices failed.  devices is 0x%x instead of 0x%x\n",
	     GetDisplayDevices(pScrn), devices);
      return FALSE;
   }
}
d559 1
a559 6
#if 0
static Bool
GetDevicePresence(ScrnInfoPtr pScrn, Bool *required, int *attached,
		  int *encoderPresent)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
d561 5
a565 1
   DPRINTF(PFX, "GetDevicePresence\n");
d567 2
a568 17
   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x200;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax)) {
      if (required)
	 *required = ((pVbe->pInt10->bx & 0x1) == 0);
      if (attached)
	 *attached = (pVbe->pInt10->cx >> 8) & 0xff;
      if (encoderPresent)
	 *encoderPresent = pVbe->pInt10->cx & 0xff;
      return TRUE;
   } else
      return FALSE;
}
#endif
d570 2
a571 5
static Bool
GetDisplayInfo(ScrnInfoPtr pScrn, int device, Bool *attached, Bool *present,
	       short *x, short *y)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
d573 4
a576 1
   DPRINTF(PFX, "GetDisplayInfo: device: 0x%x\n", device);
d578 1
a578 13
   switch (device & 0xff) {
   case 0x01:
   case 0x02:
   case 0x04:
   case 0x08:
   case 0x10:
   case 0x20:
      break;
   default:
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "GetDisplayInfo: invalid device: 0x%x\n", device & 0xff);
      return FALSE;
   }
d580 11
a590 17
   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f64;
   pVbe->pInt10->bx = 0x300;
   pVbe->pInt10->cx = device & 0xff;

   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   if (Check5fStatus(pScrn, 0x5f64, pVbe->pInt10->ax)) {
      if (attached)
	 *attached = ((pVbe->pInt10->bx & 0x2) != 0);
      if (present)
	 *present = ((pVbe->pInt10->bx & 0x1) != 0);
      if (pVbe->pInt10->cx != (device & 0xff)) {
	 if (y) {
	    *y = pVbe->pInt10->cx & 0xffff;
	 }
	 if (x) {
	    *x = (pVbe->pInt10->cx >> 16) & 0xffff;
d592 1
a592 5
      }
      return TRUE;
   } else
      return FALSE;
}
d594 4
a597 5
/*
 * Returns a string matching the device corresponding to the first bit set
 * in "device".  savedDevice is then set to device with that bit cleared.
 * Subsequent calls with device == -1 will use savedDevice.
 */
d599 2
a600 9
static const char *displayDevices[] = {
   "CRT",
   "TV",
   "DFP (digital flat panel)",
   "LFP (local flat panel)",
   "TV2 (second TV)",
   "DFP2 (second digital flat panel)",
   NULL
};
d602 3
a604 26
static const char *
DeviceToString(int device)
{
   static int savedDevice = -1;
   static int bit = 0;
   const char *name;

   if (device == -1) {
      device = savedDevice;
      bit = 0;
   }

   if (device == -1)
      return NULL;

   while (displayDevices[bit]) {
      if (device & (1 << bit)) {
	 name = displayDevices[bit];
	 savedDevice = device & ~(1 << bit);
	 bit++;
	 return name;
      }
      bit++;
   }
   return NULL;
}
d606 2
a607 33
static void
PrintDisplayDeviceInfo(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int pipe, n;
   int displays;

   DPRINTF(PFX, "PrintDisplayDeviceInfo\n");

   displays = pI830->configuredDevices;
   if (displays == -1) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "No active display devices.\n");
      return;
   }

   /* Check for active devices connected to each display pipe. */
   for (n = 0; n < pI830->availablePipes; n++) {
      pipe = ((displays >> PIPE_SHIFT(n)) & PIPE_ACTIVE_MASK);
      if (pipe) {
	 const char *name;

	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Currently active displays on Pipe %c:\n", PIPE_NAME(n));
	 name = DeviceToString(pipe);
	 do {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "\t%s\n", name);
	    name = DeviceToString(-1);
	 } while (name);

	 if (pipe & PIPE_UNKNOWN_ACTIVE)
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "\tSome unknown display devices may also be present\n");
d609 1
a609 4
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "No active displays on Pipe %c.\n", PIPE_NAME(n));
      }
d611 1
a611 12
      if (pI830->pipeDisplaySize[n].x2 != 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Lowest common panel size for pipe %c is %d x %d\n",
		    PIPE_NAME(n), pI830->pipeDisplaySize[n].x2,
		    pI830->pipeDisplaySize[n].y2);
      } else if (pI830->pipeEnabled[n] && pipe & ~PIPE_CRT_ACTIVE) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "No display size information available for pipe %c.\n",
		    PIPE_NAME(n));
      }
   }
}
d613 10
a622 29
static void
GetPipeSizes(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int pipe, n;
   DisplayType i;

   DPRINTF(PFX, "GetPipeSizes\n");


   for (n = 0; n < pI830->availablePipes; n++) {
      pipe = (pI830->configuredDevices >> PIPE_SHIFT(n)) & PIPE_ACTIVE_MASK;
      pI830->pipeDisplaySize[n].x1 = pI830->pipeDisplaySize[n].y1 = 0;
      pI830->pipeDisplaySize[n].x2 = pI830->pipeDisplaySize[n].y2 = 4096;
      for (i = 0; i < NumKnownDisplayTypes; i++) {
         if (pipe & (1 << i) & PIPE_SIZED_DISP_MASK) {
	    if (pI830->displaySize[i].x2 != 0) {
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		          "Size of device %s is %d x %d\n",
		          displayDevices[i],
		          pI830->displaySize[i].x2,
		          pI830->displaySize[i].y2);
	       if (pI830->displaySize[i].x2 < pI830->pipeDisplaySize[n].x2)
	          pI830->pipeDisplaySize[n].x2 = pI830->displaySize[i].x2;
	       if (pI830->displaySize[i].y2 < pI830->pipeDisplaySize[n].y2)
	          pI830->pipeDisplaySize[n].y2 = pI830->displaySize[i].y2;
	    }
         }
      }
d624 17
a640 6
      if (pI830->pipeDisplaySize[n].x2 == 4096)
         pI830->pipeDisplaySize[n].x2 = 0;
      if (pI830->pipeDisplaySize[n].y2 == 4096)
         pI830->pipeDisplaySize[n].y2 = 0;
   }
}
d642 2
a643 20
static Bool
I830DetectDisplayDevice(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int pipe, n;
   DisplayType i;

   for (i = 0; i < NumKnownDisplayTypes; i++) {
      if (GetDisplayInfo(pScrn, 1 << i, &pI830->displayAttached[i],
			 &pI830->displayPresent[i],
			 &pI830->displaySize[i].x2,
			 &pI830->displaySize[i].y2)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Display Info: %s: attached: %s, present: %s, size: "
		    "(%d,%d)\n", displayDevices[i],
		    BOOLTOSTRING(pI830->displayAttached[i]),
		    BOOLTOSTRING(pI830->displayPresent[i]),
		    pI830->displaySize[i].x2, pI830->displaySize[i].y2);
      }
   }
d645 1
a645 6
   pI830->configuredDevices = GetDisplayDevices(pScrn);
   if (pI830->configuredDevices == -1) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Failed to detect active display devices\n");
      return FALSE;
   }
d647 19
a665 7
   /* Check for active devices connected to each display pipe. */
   for (n = 0; n < pI830->availablePipes; n++) {
      pipe = ((pI830->configuredDevices >> PIPE_SHIFT(n)) & PIPE_ACTIVE_MASK);
      if (pipe) {
	 pI830->pipeEnabled[n] = TRUE;
      }
   }
d667 1
a667 2
   GetPipeSizes(pScrn);
   PrintDisplayDeviceInfo(pScrn);
d669 19
a687 8
#if 0
   /* A quick hack to change the set of enabled devices. */
   enabledDevices = PIPE_CRT_ACTIVE;
   if (!SetDisplayDevices(pScrn, enabledDevices)) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Failed to switch to configured display devices\n");
   }
#endif
d689 1
a689 2
   return TRUE;
}
d691 19
a709 7
static int
I830DetectMemory(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   PCITAG bridge;
   CARD16 gmch_ctrl;
   int memsize = 0;
d711 2
a712 2
   bridge = pciTag(0, 0, 0);		/* This is always the host bridge */
   gmch_ctrl = pciReadWord(bridge, I830_GMCH_CTRL);
d714 12
a725 46
   if (IS_I85X(pI830) || IS_I865G(pI830))
   {
      switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
      case I855_GMCH_GMS_STOLEN_1M:
	 memsize = MB(1) - KB(132);
	 break;
      case I855_GMCH_GMS_STOLEN_4M:
	 memsize = MB(4) - KB(132);
	 break;
      case I855_GMCH_GMS_STOLEN_8M:
	 memsize = MB(8) - KB(132);
	 break;
      case I855_GMCH_GMS_STOLEN_16M:
	 memsize = MB(16) - KB(132);
	 break;
      case I855_GMCH_GMS_STOLEN_32M:
	 memsize = MB(32) - KB(132);
	 break;
      }
   } else
   {
      switch (gmch_ctrl & I830_GMCH_GMS_MASK) {
      case I830_GMCH_GMS_STOLEN_512:
	 memsize = KB(512) - KB(132);
	 break;
      case I830_GMCH_GMS_STOLEN_1024:
	 memsize = MB(1) - KB(132);
	 break;
      case I830_GMCH_GMS_STOLEN_8192:
	 memsize = MB(8) - KB(132);
	 break;
      case I830_GMCH_GMS_LOCAL:
	 memsize = 0;
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Local memory found, but won't be used.\n");
	 break;
      }
   }
   if (memsize > 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "detected %d kB stolen memory.\n", memsize / 1024);
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "no video memory detected.\n");
   }
   return memsize;
}
d727 2
a728 5
static Bool
I830MapMMIO(ScrnInfoPtr pScrn)
{
   int mmioFlags;
   I830Ptr pI830 = I830PTR(pScrn);
d730 13
a742 5
#if !defined(__alpha__)
   mmioFlags = VIDMEM_MMIO | VIDMEM_READSIDEEFFECT;
#else
   mmioFlags = VIDMEM_MMIO | VIDMEM_READSIDEEFFECT | VIDMEM_SPARSE;
#endif
d744 1
a744 7
   pI830->MMIOBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
				   pI830->PciTag,
				   pI830->MMIOAddr, I810_REG_SIZE);
   if (!pI830->MMIOBase)
      return FALSE;
   return TRUE;
}
d746 3
a748 5
static Bool
I830MapMem(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned i;
d750 2
a751 2
   for (i = 2; i < pI830->FbMapSize; i <<= 1) ;
   pI830->FbMapSize = i;
d753 2
a754 2
   if (!I830MapMMIO(pScrn))
      return FALSE;
d756 5
a760 5
   pI830->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
				 pI830->PciTag,
				 pI830->LinearAddr, pI830->FbMapSize);
   if (!pI830->FbBase)
      return FALSE;
d762 4
a765 1
   pI830->LpRing.virtual_start = pI830->FbBase + pI830->LpRing.mem.Start;
d767 4
a770 2
   return TRUE;
}
d772 3
a774 4
static void
I830UnmapMMIO(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
d776 3
a778 4
   xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pI830->MMIOBase,
		   I810_REG_SIZE);
   pI830->MMIOBase = 0;
}
d780 5
a784 4
static Bool
I830UnmapMem(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
d786 1
a786 6
   xf86UnMapVidMem(pScrn->scrnIndex, (pointer) pI830->FbBase,
		   pI830->FbMapSize);
   pI830->FbBase = 0;
   I830UnmapMMIO(pScrn);
   return TRUE;
}
d788 68
a855 3
#ifndef HAVE_GET_PUT_BIOSMEMSIZE
#define HAVE_GET_PUT_BIOSMEMSIZE 1
#endif
d857 1
a857 9
#if HAVE_GET_PUT_BIOSMEMSIZE
/*
 * Tell the BIOS how much video memory is available.  The BIOS call used
 * here won't always be available.
 */
static Bool
PutBIOSMemSize(ScrnInfoPtr pScrn, int memSize)
{
   vbeInfoPtr pVbe = I830PTR(pScrn)->pVbe;
d859 41
a899 1
   DPRINTF(PFX, "PutBIOSMemSize: %d kB\n", memSize / 1024);
d901 13
a913 4
   pVbe->pInt10->num = 0x10;
   pVbe->pInt10->ax = 0x5f11;
   pVbe->pInt10->bx = 0;
   pVbe->pInt10->cx = memSize / GTT_PAGE_SIZE;
d915 1
a915 3
   xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
   return Check5fStatus(pScrn, 0x5f11, pVbe->pInt10->ax);
}
d917 2
a918 12
/*
 * This reports what the previous VBEGetVBEInfo() found.  Be sure to call
 * VBEGetVBEInfo() after changing the BIOS memory size view.  If
 * a separate BIOS call is added for this, it can be put here.  Only
 * return a valid value if the funtionality for PutBIOSMemSize()
 * is available.
 */
static int
GetBIOSMemSize(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int memSize = KB(pI830->vbeInfo->TotalMemory * 64);
d920 13
a932 1
   DPRINTF(PFX, "GetBIOSMemSize\n");
d934 103
a1036 6
   if (PutBIOSMemSize(pScrn, memSize))
      return memSize;
   else
      return -1;
}
#endif
d1038 19
a1056 16
/*
 * These three functions allow the video BIOS's view of the available video
 * memory to be changed.  This is currently implemented only for the 830
 * and 845G, which can do this via a BIOS scratch register that holds the
 * BIOS's view of the (pre-reserved) memory size.  If another mechanism
 * is available in the future, it can be plugged in here.  
 *
 * The mapping used for the 830/845G scratch register's low 4 bits is:
 *
 *             320k => 0
 *             832k => 1
 *            8000k => 8
 *
 * The "unusual" values are the 512k, 1M, 8M pre-reserved memory, less
 * overhead, rounded down to the BIOS-reported 64k granularity.
 */
d1058 1
a1058 4
static Bool
SaveBIOSMemSize(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
d1060 8
a1067 1
   DPRINTF(PFX, "SaveBIOSMemSize\n");
d1069 7
a1075 1
   pI830->useSWF1 = FALSE;
d1077 1
a1077 4
#if HAVE_GET_PUT_BIOSMEMSIZE
   if ((pI830->saveBIOSMemSize = GetBIOSMemSize(pScrn)) != -1)
      return TRUE;
#endif
d1079 50
a1128 26
   if (IS_I830(pI830) || IS_845G(pI830)) {
      pI830->useSWF1 = TRUE;
      pI830->saveSWF1 = INREG(SWF1) & 0x0f;

      /*
       * This is for sample purposes only.  pI830->saveBIOSMemSize isn't used
       * when pI830->useSWF1 is TRUE.
       */
      switch (pI830->saveSWF1) {
      case 0:
	 pI830->saveBIOSMemSize = KB(320);
	 break;
      case 1:
	 pI830->saveBIOSMemSize = KB(832);
	 break;
      case 8:
	 pI830->saveBIOSMemSize = KB(8000);
	 break;
      default:
	 pI830->saveBIOSMemSize = 0;
	 break;
      }
      return TRUE;
   }
   return FALSE;
}
d1130 1
a1130 5
static void
RestoreBIOSMemSize(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   CARD32 swf1;
d1132 6
a1137 1
   DPRINTF(PFX, "RestoreBIOSMemSize\n");
d1139 1
a1139 2
   if (!pI830->overrideBIOSMemSize)
      return;
d1141 6
a1146 4
#if HAVE_GET_PUT_BIOSMEMSIZE
   if (!pI830->useSWF1) {
      PutBIOSMemSize(pScrn, pI830->saveBIOSMemSize);
      return;
a1147 1
#endif
d1149 6
a1154 5
   if ((IS_I830(pI830) || IS_845G(pI830)) && pI830->useSWF1) {
      swf1 = INREG(SWF1);
      swf1 &= ~0x0f;
      swf1 |= (pI830->saveSWF1 & 0x0f);
      OUTREG(SWF1, swf1);
a1155 1
}
d1157 13
a1169 16
static void
SetBIOSMemSize(ScrnInfoPtr pScrn, int newSize)
{
   I830Ptr pI830 = I830PTR(pScrn);
   CARD32 swf1;
   Bool mapped;

   DPRINTF(PFX, "SetBIOSMemSize: %d kB\n", newSize / 1024);

   if (!pI830->overrideBIOSMemSize)
      return;

#if HAVE_GET_PUT_BIOSMEMSIZE
   if (!pI830->useSWF1) {
      PutBIOSMemSize(pScrn, newSize);
      return;
a1170 1
#endif
d1172 1
a1172 22
   if ((IS_I830(pI830) || IS_845G(pI830)) && pI830->useSWF1) {
      CARD32 newSWF1;

      /* Need MMIO access here. */
      mapped = (pI830->MMIOBase != NULL);
      if (!mapped)
	 I830MapMMIO(pScrn);

      if (newSize <= KB(832))
	 newSWF1 = 1;
      else
	 newSWF1 = 8;

      swf1 = INREG(SWF1);
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Before: SWF1 is 0x%08x\n", swf1);
      swf1 &= ~0x0f;
      swf1 |= (newSWF1 & 0x0f);
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "After: SWF1 is 0x%08x\n", swf1);
      OUTREG(SWF1, swf1);
      if (!mapped)
	 I830UnmapMMIO(pScrn);
   }
d1176 1
a1176 5
 * Use the native method instead of the vgahw method.  So far this is
 * only used for 8-bit mode.
 *
 * XXX Look into using the 10-bit gamma correction mode for 15/16/24 bit,
 * and see if a DirectColor visual can be offered.
d1178 1
d1180 1
a1180 2
I830LoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
		LOCO * colors, VisualPtr pVisual)
d1182 1
a1182 33
   I830Ptr pI830;
   int i, index;
   unsigned char r, g, b;
   CARD32 val, temp;

   DPRINTF(PFX, "I830LoadPalette: numColors: %d\n", numColors);
   pI830 = I830PTR(pScrn);

   if (pI830->pipeEnabled[0]) {
      /* It seems that an initial read is needed. */
      temp = INREG(PALETTE_A);
      for (i = 0; i < numColors; i++) {
	 index = indices[i];
	 r = colors[index].red;
	 g = colors[index].green;
	 b = colors[index].blue;
	 val = (r << 16) | (g << 8) | b;
	 OUTREG(PALETTE_A + index * 4, val);
      }
   }
   if (pI830->pipeEnabled[1]) {
      /* It seems that an initial read is needed. */
      temp = INREG(PALETTE_B);
      for (i = 0; i < numColors; i++) {
	 index = indices[i];
	 r = colors[index].red;
	 g = colors[index].green;
	 b = colors[index].blue;
	 val = (r << 16) | (g << 8) | b;
	 OUTREG(PALETTE_B + index * 4, val);
      }
   }
}
d1184 1
a1184 4
static void
PreInitCleanup(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
d1186 3
a1188 8
   RestoreBIOSMemSize(pScrn);
   if (pI830->swfSaved) {
      OUTREG(SWF0, pI830->saveSWF0);
      OUTREG(SWF4, pI830->saveSWF4);
   }
   if (pI830->MMIOBase)
      I830UnmapMMIO(pScrn);
   I830BIOSFreeRec(pScrn);
d1191 2
a1192 2
static Bool
I830BIOSPreInit(ScrnInfoPtr pScrn, int flags)
d1194 1
a1194 12
   vgaHWPtr hwp;
   I830Ptr pI830;
   MessageType from;
   rgb defaultWeight = { 0, 0, 0 };
   vbeInfoPtr pVbe;
   EntityInfoPtr pEnt;
   int mem, memsize;
   int flags24;
   int i, n;
   pointer pDDCModule, pVBEModule;
   Bool enable;
   const char *chipname;
d1196 1
a1196 2
   if (pScrn->numEntities != 1)
      return FALSE;
d1198 4
a1201 9
   /* Load int10 module */
   if (!xf86LoadSubModule(pScrn, "int10"))
      return FALSE;
   xf86LoaderReqSymLists(I810int10Symbols, NULL);

   /* Load vbe module */
   if (!(pVBEModule = xf86LoadSubModule(pScrn, "vbe")))
      return FALSE;
   xf86LoaderReqSymLists(I810vbeSymbols, NULL);
d1203 4
a1206 1
   pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
d1208 4
a1211 4
   if (flags & PROBE_DETECT) {
      I830BIOSProbeDDC(pScrn, pEnt->index);
      return TRUE;
   }
d1213 2
a1214 4
   /* The vgahw module should be loaded here when needed */
   if (!xf86LoadSubModule(pScrn, "vgahw"))
      return FALSE;
   xf86LoaderReqSymLists(I810vgahwSymbols, NULL);
d1216 6
d1223 2
a1224 21
   /* Allocate a vgaHWRec */
   if (!vgaHWGetHWRec(pScrn))
      return FALSE;

   /* Allocate driverPrivate */
   if (!I830BIOSGetRec(pScrn))
      return FALSE;

   pI830 = I830PTR(pScrn);
   pI830->pEnt = pEnt;

   if (pI830->pEnt->location.type != BUS_PCI)
      return FALSE;

   pI830->PciInfo = xf86GetPciInfoForEntity(pI830->pEnt->index);
   pI830->PciTag = pciTag(pI830->PciInfo->bus, pI830->PciInfo->device,
			  pI830->PciInfo->func);

   if (xf86RegisterResources(pI830->pEnt->index, 0, ResNone)) {
      PreInitCleanup(pScrn);
      return FALSE;
d1226 7
d1234 1
d1236 6
a1241 4
   pScrn->racMemFlags = RAC_FB | RAC_COLORMAP;
   pScrn->monitor = pScrn->confScreen->monitor;
   pScrn->progClock = TRUE;
   pScrn->rgbBits = 8;
d1243 2
a1244 1
   flags24 = Support32bppFb | PreferConvert24to32 | SupportConvert24to32;
d1246 1
a1246 2
   if (!xf86SetDepthBpp(pScrn, 0, 0, 0, flags24))
      return FALSE;
d1248 54
a1301 13
   switch (pScrn->depth) {
   case 8:
   case 15:
   case 16:
   case 24:
      break;
   default:
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Given depth (%d) is not supported by I830 driver\n",
		 pScrn->depth);
      return FALSE;
   }
   xf86PrintDepthBpp(pScrn);
d1303 6
a1308 4
   if (!xf86SetWeight(pScrn, defaultWeight, defaultWeight))
      return FALSE;
   if (!xf86SetDefaultVisual(pScrn, -1))
      return FALSE;
d1310 2
a1311 2
   hwp = VGAHWPTR(pScrn);
   pI830->cpp = pScrn->bitsPerPixel / 8;
d1313 1
a1313 6
   /* Process the options */
   xf86CollectOptions(pScrn, NULL);
   if (!(pI830->Options = xalloc(sizeof(I830BIOSOptions))))
      return FALSE;
   memcpy(pI830->Options, I830BIOSOptions, sizeof(I830BIOSOptions));
   xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pI830->Options);
d1315 53
a1367 2
   /* We have to use PIO to probe, because we haven't mapped yet. */
   I830SetPIOAccess(pI830);
d1369 1
a1369 5
   /* Initialize VBE record */
   if ((pI830->pVbe = VBEInit(NULL, pI830->pEnt->index)) == NULL) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "VBE initialization failed.\n");
      return FALSE;
   }
d1371 6
a1376 44
   switch (pI830->PciInfo->chipType) {
   case PCI_CHIP_I830_M:
      chipname = "830M";
      break;
   case PCI_CHIP_845_G:
      chipname = "845G";
      break;
   case PCI_CHIP_I855_GM:
      /* Check capid register to find the chipset variant */
      pI830->variant = (pciReadLong(pI830->PciTag, I85X_CAPID)
				>> I85X_VARIANT_SHIFT) & I85X_VARIANT_MASK;
      switch (pI830->variant) {
      case I855_GM:
	 chipname = "855GM";
	 break;
      case I855_GME:
	 chipname = "855GME";
	 break;
      case I852_GM:
	 chipname = "852GM";
	 break;
      case I852_GME:
	 chipname = "852GME";
	 break;
      default:
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Unknown 852GM/855GM variant: 0x%x)\n", pI830->variant);
	 chipname = "852GM/855GM (unknown variant)";
	 break;
      }
      break;
   case PCI_CHIP_I865_G:
      chipname = "865G";
      break;
   default:
      chipname = "unknown chipset";
      break;
   }
   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "Integrated Graphics Chipset: Intel(R) %s\n", chipname);

   pVbe = pI830->pVbe;

   pI830->vbeInfo = VBEGetVBEInfo(pVbe);
d1378 2
a1379 20
   /* Set the Chipset and ChipRev, allowing config file entries to override. */
   if (pI830->pEnt->device->chipset && *pI830->pEnt->device->chipset) {
      pScrn->chipset = pI830->pEnt->device->chipset;
      from = X_CONFIG;
   } else if (pI830->pEnt->device->chipID >= 0) {
      pScrn->chipset = (char *)xf86TokenToString(I830BIOSChipsets,
						 pI830->pEnt->device->chipID);
      from = X_CONFIG;
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
		 pI830->pEnt->device->chipID);
   } else {
      from = X_PROBED;
      pScrn->chipset = (char *)xf86TokenToString(I830BIOSChipsets,
						 pI830->PciInfo->chipType);
   }

   if (pI830->pEnt->device->chipRev >= 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
		 pI830->pEnt->device->chipRev);
   }
d1381 4
a1384 2
   xf86DrvMsg(pScrn->scrnIndex, from, "Chipset: \"%s\"\n",
	      (pScrn->chipset != NULL) ? pScrn->chipset : "Unknown i8xx");
d1386 4
a1389 14
   if (pI830->pEnt->device->MemBase != 0) {
      pI830->LinearAddr = pI830->pEnt->device->MemBase;
      from = X_CONFIG;
   } else {
      if (pI830->PciInfo->memBase[1] != 0) {
	 /* XXX Check mask. */
	 pI830->LinearAddr = pI830->PciInfo->memBase[0] & 0xFF000000;
	 from = X_PROBED;
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "No valid FB address in PCI config space\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
d1391 1
d1393 4
a1396 23
   xf86DrvMsg(pScrn->scrnIndex, from, "Linear framebuffer at 0x%lX\n",
	      (unsigned long)pI830->LinearAddr);

   if (pI830->pEnt->device->IOBase != 0) {
      pI830->MMIOAddr = pI830->pEnt->device->IOBase;
      from = X_CONFIG;
   } else {
      if (pI830->PciInfo->memBase[1]) {
	 pI830->MMIOAddr = pI830->PciInfo->memBase[1] & 0xFFF80000;
	 from = X_PROBED;
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "No valid MMIO address in PCI config space\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
   }

   xf86DrvMsg(pScrn->scrnIndex, from, "IO registers at addr 0x%lX\n",
	      (unsigned long)pI830->MMIOAddr);

   /* Some of the probing needs MMIO access, so map it here. */
   I830MapMMIO(pScrn);
d1398 2
a1399 32
#if 1
   pI830->saveSWF0 = INREG(SWF0);
   pI830->saveSWF4 = INREG(SWF4);
   pI830->swfSaved = TRUE;

   /* Set "extended desktop" */
   OUTREG(SWF0, pI830->saveSWF0 | (1 << 21));

   /* Set "driver loaded",  "OS unknown", "APM 1.2" */
   OUTREG(SWF4, (pI830->saveSWF4 & ~((3 << 19) | (7 << 16))) |
		(1 << 23) | (2 << 16));
#endif

   if (IS_I830(pI830) || IS_845G(pI830)) {
      PCITAG bridge;
      CARD16 gmch_ctrl;

      bridge = pciTag(0, 0, 0);		/* This is always the host bridge */
      gmch_ctrl = pciReadWord(bridge, I830_GMCH_CTRL);
      if ((gmch_ctrl & I830_GMCH_MEM_MASK) == I830_GMCH_MEM_128M) {
	 pI830->FbMapSize = 0x8000000;
      } else {
	 pI830->FbMapSize = 0x4000000;
      }
   }
   else {
      /* 128MB aperture for later chips */
      pI830->FbMapSize = 0x8000000;
   }

   /*
    * Get the pre-allocated (stolen) memory size.
d1401 3
a1403 41
   pI830->StolenMemory.Size = I830DetectMemory(pScrn);
   pI830->StolenMemory.Start = 0;
   pI830->StolenMemory.End = pI830->StolenMemory.Size;

   /* Sanity check: compare with what the BIOS thinks. */
   if (pI830->vbeInfo->TotalMemory != pI830->StolenMemory.Size / 1024 / 64) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Detected stolen memory (%d kB) doesn't match what the BIOS"
		 " reports (%d kB)\n",
		 ROUND_DOWN_TO(pI830->StolenMemory.Size / 1024, 64),
		 pI830->vbeInfo->TotalMemory * 64);
   }

   /* Find the maximum amount of agpgart memory available. */
   mem = I830CheckAvailableMemory(pScrn);
   pI830->StolenOnly = FALSE;

   if (mem <= 0) {
      if (pI830->StolenMemory.Size <= 0) {
	 /* Shouldn't happen. */
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "/dev/agpgart is either not available, or no memory "
		 "is available\nfor allocation, "
		 "and no pre-allocated memory is available.\n");
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "/dev/agpgart is either not available, or no memory "
		 "is available\nfor allocation.  "
		 "Using pre-allocated memory only.\n");
      mem = 0;
      pI830->StolenOnly = TRUE;
   }

   if (xf86ReturnOptValBool(pI830->Options, OPTION_NOACCEL, FALSE)) {
      pI830->noAccel = TRUE;
   }
   if (xf86ReturnOptValBool(pI830->Options, OPTION_SW_CURSOR, FALSE)) {
      pI830->SWCursor = TRUE;
   }
d1405 1
a1405 22
   pI830->directRenderingDisabled =
	!xf86ReturnOptValBool(pI830->Options, OPTION_DRI, TRUE);

#ifdef XF86DRI
   if (!pI830->directRenderingDisabled) {
      if (pI830->noAccel || pI830->SWCursor) {
	 xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "DRI is disabled because it "
		    "needs HW cursor and 2D acceleration.\n");
	 pI830->directRenderingDisabled = TRUE;
      } else if (pScrn->depth != 16 && pScrn->depth != 24) {
	 xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "DRI is disabled because it "
		    "runs only at depths 16 and 24.\n");
	 pI830->directRenderingDisabled = TRUE;
      }
   }
#endif

   /*
    * The "VideoRam" config file parameter specifies the total amount of
    * memory that will be used/allocated.  When agpgart support isn't
    * available (StolenOnly == TRUE), this is limited to the amount of
    * pre-allocated ("stolen") memory.
d1407 2
d1410 2
a1411 21
   /*
    * Default to I830_DEFAULT_VIDEOMEM_2D (8192KB) for 2D-only,
    * or I830_DEFAULT_VIDEOMEM_3D (32768KB) for 3D.  If the stolen memory
    * amount is higher, default to it rounded up to the nearest MB.  This
    * guarantees that by default there will be at least some run-time
    * space for things that need a physical address.
    */
   if (!pI830->pEnt->device->videoRam) {
      from = X_DEFAULT;
#ifdef XF86DRI
      if (!pI830->directRenderingDisabled)
	 pScrn->videoRam = I830_DEFAULT_VIDEOMEM_3D;
      else
#endif
	 pScrn->videoRam = I830_DEFAULT_VIDEOMEM_2D;
      if (pI830->StolenMemory.Size / 1024 > pScrn->videoRam)
	 pScrn->videoRam = ROUND_TO(pI830->StolenMemory.Size / 1024, 1024);
   } else {
      from = X_CONFIG;
      pScrn->videoRam = pI830->pEnt->device->videoRam;
   }
d1413 4
a1416 15
   DPRINTF(PFX,
	   "Available memory: %dk\n"
	   "Requested memory: %dk\n", mem, pScrn->videoRam);


   if (mem + (pI830->StolenMemory.Size / 1024) < pScrn->videoRam) {
      pScrn->videoRam = mem + (pI830->StolenMemory.Size / 1024);
      from = X_PROBED;
      if (mem + (pI830->StolenMemory.Size / 1024) <
	  pI830->pEnt->device->videoRam) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "VideoRAM reduced to %d kByte "
		    "(limited to available sysmem)\n", pScrn->videoRam);
      }
   }
d1418 5
a1422 62
   if (pScrn->videoRam > pI830->FbMapSize / 1024) {
      pScrn->videoRam = pI830->FbMapSize / 1024;
      if (pI830->FbMapSize / 1024 < pI830->pEnt->device->videoRam)
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "VideoRam reduced to %d kByte (limited to aperture size)\n",
		    pScrn->videoRam);
   }
      
   if (mem > 0) {
      /*
       * If the reserved (BIOS accessible) memory is less than the desired
       * amount, try to increase it.  So far this is only implemented for
       * the 845G and 830, but those details are handled in SetBIOSMemSize().
       * 
       * The BIOS-accessible amount is only important for setting video
       * modes.  The maximum amount we try to set is limited to what would
       * be enough for 1920x1440 with a 2048 pitch.
       *
       * If ALLOCATE_ALL_BIOSMEM is enabled in i830_memory.c, all of the
       * BIOS-aware memory will get allocated.  If it isn't then it may
       * not be, and in that case there is an assumption that the video
       * BIOS won't attempt to access memory beyond what is needed for
       * modes that are actually used.  ALLOCATE_ALL_BIOSMEM is enabled by
       * default.
       */

      /* Try to keep HW cursor and Overlay amounts separate from this. */
      int reserve = (HWCURSOR_SIZE + OVERLAY_SIZE) / 1024;

      if (pScrn->videoRam - reserve >= I830_MAXIMUM_VBIOS_MEM)
	 pI830->newBIOSMemSize = KB(I830_MAXIMUM_VBIOS_MEM);
      else 
	 pI830->newBIOSMemSize =
			KB(ROUND_DOWN_TO(pScrn->videoRam - reserve, 64));

      if (pI830->vbeInfo->TotalMemory * 64 < pI830->newBIOSMemSize / 1024) {

	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Will attempt to tell the BIOS that there is "
		    "%d kB VideoRAM\n", pI830->newBIOSMemSize / 1024);

	 if (SaveBIOSMemSize(pScrn)) {
	    pI830->overrideBIOSMemSize = TRUE;
	    SetBIOSMemSize(pScrn, pI830->newBIOSMemSize);

	    VBEFreeVBEInfo(pI830->vbeInfo);
	    vbeFree(pI830->pVbe);
	    pI830->pVbe = VBEInit(NULL, pI830->pEnt->index);
	    pVbe = pI830->pVbe;
	    pI830->vbeInfo = VBEGetVBEInfo(pVbe);

	    pI830->BIOSMemorySize = KB(pI830->vbeInfo->TotalMemory * 64);
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "BIOS now sees %d kB VideoRAM\n",
		       pI830->BIOSMemorySize / 1024);
	 } else {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "BIOS view of memory size can't be changed "
		       "(this is not an error).\n");
	 }
      }
   }
d1424 4
a1427 4
   xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Pre-allocated VideoRAM: %d kByte\n",
	      pI830->StolenMemory.Size / 1024);
   xf86DrvMsg(pScrn->scrnIndex, from, "VideoRAM: %d kByte\n", pScrn->videoRam);
   pI830->TotalVideoRam = KB(pScrn->videoRam);
d1429 4
a1432 7
   /*
    * If the requested videoRam amount is less than the stolen memory size,
    * reduce the stolen memory size accordingly.
    */
   if (pI830->StolenMemory.Size > pI830->TotalVideoRam) {
      pI830->StolenMemory.Size = pI830->TotalVideoRam;
      pI830->StolenMemory.End = pI830->TotalVideoRam;
d1434 1
d1436 5
a1440 10
   if (xf86GetOptValInteger(pI830->Options, OPTION_CACHE_LINES,
			    &(pI830->CacheLines))) {
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Requested %d cache lines\n",
		 pI830->CacheLines);
   } else {
      pI830->CacheLines = -1;
   }

   pI830->XvDisabled =
	!xf86ReturnOptValBool(pI830->Options, OPTION_XVIDEO, TRUE);
d1442 2
a1443 7
#ifdef I830_XV
   if (xf86GetOptValInteger(pI830->Options, OPTION_VIDEO_KEY,
			    &(pI830->colorKey))) {
      from = X_CONFIG;
   } else if (xf86GetOptValInteger(pI830->Options, OPTION_COLOR_KEY,
			    &(pI830->colorKey))) {
      from = X_CONFIG;
d1445 1
a1445 5
      pI830->colorKey = (1 << pScrn->offset.red) |
			(1 << pScrn->offset.green) |
			(((pScrn->mask.blue >> pScrn->offset.blue) - 1) <<
			 pScrn->offset.blue);
      from = X_DEFAULT;
a1446 3
   xf86DrvMsg(pScrn->scrnIndex, from, "video overlay key set to 0x%x\n",
	      pI830->colorKey);
#endif
d1448 3
a1450 9
   pI830->allowPageFlip = FALSE;
   enable = xf86ReturnOptValBool(pI830->Options, OPTION_PAGEFLIP, FALSE);
#ifdef XF86DRI
   if (!pI830->directRenderingDisabled) {
      pI830->allowPageFlip = enable;
      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "page flipping %s\n",
		 enable ? "enabled" : "disabled");
   }
#endif
d1452 5
a1456 19
   /* Check if the HW cursor needs physical address. */
   if (IS_MOBILE(pI830))
      pI830->CursorNeedsPhysical = TRUE;
   else
      pI830->CursorNeedsPhysical = FALSE;

   /* Force ring buffer to be in low memory for the 845G. */
   if (IS_845G(pI830))
      pI830->NeedRingBufferLow = TRUE;

   /*
    * XXX If we knew the pre-initialised GTT format for certain, we could
    * probably figure out the physical address even in the StolenOnly case.
    */
   if (pI830->StolenOnly && pI830->CursorNeedsPhysical && !pI830->SWCursor) {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		 "HW Cursor disabled because it needs agpgart memory.\n");
      pI830->SWCursor = TRUE;
   }
d1458 2
a1459 12
   /*
    * Reduce the maximum videoram available for video modes by the ring buffer,
    * minimum scratch space and HW cursor amounts.
    */
   if (!pI830->SWCursor)
      pScrn->videoRam -= (HWCURSOR_SIZE / 1024);
   if (!pI830->XvDisabled)
      pScrn->videoRam -= (OVERLAY_SIZE / 1024);
   if (!pI830->noAccel) {
      pScrn->videoRam -= (PRIMARY_RINGBUFFER_SIZE / 1024);
      pScrn->videoRam -= (MIN_SCRATCH_BUFFER_SIZE / 1024);
   }
d1461 2
a1462 2
   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      "Maximum frambuffer space: %d kByte\n", pScrn->videoRam);
d1464 1
a1464 3
   /*
    * If the driver can do gamma correction, it should call xf86SetGamma() here.
    */
d1466 2
a1467 2
   {
      Gamma zeros = { 0.0, 0.0, 0.0 };
d1469 1
a1469 2
      if (!xf86SetGamma(pScrn, zeros))
	 return FALSE;
d1472 2
a1473 6
   if (IS_MOBILE(pI830))
      pI830->availablePipes = 2;
   else
      pI830->availablePipes = 1;
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%d display pipe%s available.\n",
	      pI830->availablePipes, pI830->availablePipes > 1 ? "s" : "");
d1475 6
a1480 6
   if (!I830DetectDisplayDevice(pScrn)) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "Couldn't detect display devices.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }
d1482 2
a1483 4
   if ((pDDCModule = xf86LoadSubModule(pScrn, "ddc")) == NULL) {
      PreInitCleanup(pScrn);
      return FALSE;
   }
d1485 1
a1485 6
   if ((pI830->vesa->monitor = vbeDoEDID(pVbe, pDDCModule)) != NULL) {
      xf86PrintEDID(pI830->vesa->monitor);
   }
   if ((pScrn->monitor->DDC = pI830->vesa->monitor) != NULL)
      xf86SetDDCproperties(pScrn, pI830->vesa->monitor);
   xf86UnloadSubModule(pDDCModule);
d1487 28
a1514 20
   /* XXX Move this to a header. */
#define VIDEO_BIOS_SCRATCH 0x18

#if 1
   /*
    * XXX This should be in ScreenInit/EnterVT.  PreInit should not leave the
    * state changed.
    */
   /* Enable hot keys by writing the proper value to GR18 */
   {
      CARD8 gr18;

      gr18 = pI830->readControl(pI830, GRX, VIDEO_BIOS_SCRATCH);
      gr18 &= ~0x80;			/*
					 * Clear Hot key bit so that Video
					 * BIOS performs the hot key
					 * servicing
					 */
      pI830->writeControl(pI830, GRX, VIDEO_BIOS_SCRATCH, gr18);
   }
d1516 4
d1521 4
a1524 17
   for (i = 0; i < pI830->availablePipes; i++) {
      int pipe =
	  (pI830->configuredDevices >> PIPE_SHIFT(i)) & PIPE_ACTIVE_MASK;
      if (pipe & ~PIPE_CRT_ACTIVE) {
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		    "A non-CRT device is attached to pipe %c.\n"
		    "\tNo refresh rate overrides will be attempted.\n",
		    PIPE_NAME(i));
	 pI830->vesa->useDefaultRefresh = TRUE;
      }
      /*
       * Some desktop platforms might not have 0x5f05, so useExtendedRefresh
       * would need to be set to FALSE for those cases.
       */
      if (!pI830->vesa->useDefaultRefresh)
	 pI830->useExtendedRefresh = TRUE;
   }
d1526 2
a1527 4
   if (pI830->useExtendedRefresh) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Will use BIOS call 0x5f05 to set refresh rates for CRTs.\n");
   }
d1529 1
a1529 6
   /*
    * Calling 0x5f64 can reset the refresh rate, so only do this when
    * using 0x5f05, or when not overriding the default refresh rate.
    * Also, 0x5f64 doesn't work correctly in i830 platforms.
    */
   pI830->enableDisplays = !IS_I830(pI830) && pI830->useExtendedRefresh;
d1531 1
a1531 4
   if (pI830->enableDisplays) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Will use BIOS call 0x5f64 to enable displays.\n");
   }
d1533 6
a1538 61
   /*
    * Limit videoram available for mode selection to what the video
    * BIOS can see.
    */
   if (pScrn->videoRam > (pI830->vbeInfo->TotalMemory * 64))
      memsize = pI830->vbeInfo->TotalMemory * 64;
   else
      memsize = pScrn->videoRam;
   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      "Maximum space available for video modes: %d kByte\n", memsize);

   /*
    * Note: VBE modes (> 0x7f) won't work with Intel's extended BIOS
    * functions.  For that reason it's important to set only
    * V_MODETYPE_VGA in the flags for VBEGetModePool().
    */
   pScrn->modePool = VBEGetModePool(pScrn, pVbe, pI830->vbeInfo,
				    V_MODETYPE_VGA);

   if (!pScrn->modePool) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "No Video BIOS modes for chosen depth.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

   VBESetModeNames(pScrn->modePool);

   /*
    * XXX DDC information: There's code in xf86ValidateModes
    * (VBEValidateModes) to set monitor defaults based on DDC information
    * where available.  If we need something that does better than this,
    * there's code in vesa/vesa.c.
    */

   /* XXX Need to get relevant modes and virtual parameters. */
   /* Do the mode validation without regard to special scanline pitches. */
   n = VBEValidateModes(pScrn, NULL, pScrn->display->modes, NULL,
			NULL, 0, MAX_DISPLAY_PITCH, 1,
			0, MAX_DISPLAY_HEIGHT,
			pScrn->display->virtualX,
			pScrn->display->virtualY,
			memsize, LOOKUP_BEST_REFRESH);
   if (n <= 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

   xf86PruneDriverModes(pScrn);

   pScrn->currentMode = pScrn->modes;

   if (pScrn->modes == NULL) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No modes.\n");
      PreInitCleanup(pScrn);
      return FALSE;
   }

#ifndef USE_PITCHES
#define USE_PITCHES 1
d1541 28
a1568 38
   /*
    * If DRI is potentially usable, check if there is enough memory available
    * for it, and if there's also enough to allow tiling to be enabled.
    */
#if defined(XF86DRI)
   if (!pI830->directRenderingDisabled) {
      int savedDisplayWidth = pScrn->displayWidth;
      int memNeeded = 0;
      /* Good pitches to allow tiling.  Don't care about pitches < 256. */
      static const int pitches[] = {
	 128 * 2,
	 128 * 4,
	 128 * 8,
	 128 * 16,
	 128 * 32,
	 128 * 64,
	 0
      };

#ifdef I830_XV
      /*
       * Set this so that the overlay allocation is factored in when
       * appropriate.
       */
      pI830->XvEnabled = !pI830->XvDisabled;
#endif

      for (i = 0; pitches[i] != 0; i++) {
#if USE_PITCHES
	 if (pitches[i] >= pScrn->displayWidth) {
	    pScrn->displayWidth = pitches[i];
	    break;
	 }
#else
	 if (pitches[i] == pScrn->displayWidth)
	    break;
#endif
      }
d1570 2
a1571 72
      /*
       * If the displayWidth is a tilable pitch, test if there's enough
       * memory available to enable tiling.
       */
      if (pScrn->displayWidth == pitches[i]) {
	 I830ResetAllocations(pScrn, 0);
	 if (I830Allocate2DMemory(pScrn, ALLOCATE_DRY_RUN | ALLOC_INITIAL) &&
	     I830Allocate3DMemory(pScrn, ALLOCATE_DRY_RUN)) {
	    memNeeded = I830GetExcessMemoryAllocations(pScrn);
	    if (memNeeded > 0 || pI830->MemoryAperture.Size < 0) {
	       if (memNeeded > 0) {
		  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			     "%d kBytes additional video memory is "
			     "required to\n\tenable tiling mode for DRI.\n",
			     (memNeeded + 1023) / 1024);
	       }
	       if (pI830->MemoryAperture.Size < 0) {
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			     "Allocation with DRI tiling enabled would "
			     "exceed the\n"
			     "\tmemory aperture size (%d kB) by %d kB.\n"
			     "\tReduce VideoRam amount to avoid this!\n",
			     pI830->FbMapSize / 1024,
			     -pI830->MemoryAperture.Size / 1024);
	       }
	       pScrn->displayWidth = savedDisplayWidth;
	       pI830->allowPageFlip = FALSE;
	    } else if (pScrn->displayWidth != savedDisplayWidth) {
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			  "Increasing the scanline pitch to allow tiling mode "
			  "(%d -> %d).\n",
			  savedDisplayWidth, pScrn->displayWidth);
	    }
	 } else {
	    memNeeded = 0;
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Unexpected dry run allocation failure (1).\n");
	 }
      }
      if (memNeeded > 0 || pI830->MemoryAperture.Size < 0) {
	 /*
	  * Tiling can't be enabled.  Check if there's enough memory for DRI
	  * without tiling.
	  */
	 I830ResetAllocations(pScrn, 0);
	 if (I830Allocate2DMemory(pScrn, ALLOCATE_DRY_RUN | ALLOC_INITIAL) &&
	     I830Allocate3DMemory(pScrn, ALLOCATE_DRY_RUN | ALLOC_NO_TILING)) {
	    memNeeded = I830GetExcessMemoryAllocations(pScrn);
	    if (memNeeded > 0 || pI830->MemoryAperture.Size < 0) {
	       if (memNeeded > 0) {
		  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			     "%d kBytes additional video memory is required "
			     "to enable DRI.\n",
			     (memNeeded + 1023) / 1024);
	       }
	       if (pI830->MemoryAperture.Size < 0) {
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			     "Allocation with DRI enabled would "
			     "exceed the\n"
			     "\tmemory aperture size (%d kB) by %d kB.\n"
			     "\tReduce VideoRam amount to avoid this!\n",
			     pI830->FbMapSize / 1024,
			     -pI830->MemoryAperture.Size / 1024);
	       }
	       pI830->directRenderingDisabled = TRUE;
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Disabling DRI.\n");
	    }
	 } else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Unexpected dry run allocation failure (2).\n");
	 }
      }
d1575 17
a1591 65
   VBEPrintModes(pScrn);

   if (!pI830->vesa->useDefaultRefresh) {
      /*
       * This sets the parameters for the VBE modes according to the best
       * usable parameters from the Monitor sections modes (usually the
       * default VESA modes), allowing for better than default refresh rates.
       * This only works for VBE 3.0 and later.  Also, we only do this
       * if there are no non-CRT devices attached.
       */
      VBESetModeParameters(pScrn, pVbe);
   }

   /* PreInit shouldn't leave any state changes, so restore this. */
   RestoreBIOSMemSize(pScrn);

   /* Don't need MMIO access anymore. */
   if (pI830->swfSaved) {
      OUTREG(SWF0, pI830->saveSWF0);
      OUTREG(SWF4, pI830->saveSWF4);
   }
   I830UnmapMMIO(pScrn);

   /* Set display resolution */
   xf86SetDpi(pScrn, 0, 0);

   /* Load the required sub modules */
   if (!xf86LoadSubModule(pScrn, "fb")) {
      PreInitCleanup(pScrn);
      return FALSE;
   }

   xf86LoaderReqSymLists(I810fbSymbols, NULL);

   if (!pI830->noAccel) {
      if (!xf86LoadSubModule(pScrn, "xaa")) {
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I810xaaSymbols, NULL);
   }

   if (!pI830->SWCursor) {
      if (!xf86LoadSubModule(pScrn, "ramdac")) {
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I810ramdacSymbols, NULL);
   }

   /*  We won't be using the VGA access after the probe. */
   I830SetMMIOAccess(pI830);
   xf86SetOperatingState(resVgaIo, pI830->pEnt->index, ResUnusedOpr);
   xf86SetOperatingState(resVgaMem, pI830->pEnt->index, ResDisableOpr);

   VBEFreeVBEInfo(pI830->vbeInfo);
   vbeFree(pVbe);

#if defined(XF86DRI)
   if (!pI830->directRenderingDisabled) {
      if (!xf86LoadSubModule(pScrn, "shadow")) {
	 PreInitCleanup(pScrn);
	 return FALSE;
      }
      xf86LoaderReqSymLists(I810shadowSymbols, NULL);
d1595 33
a1627 2
   return TRUE;
}
a1628 37
/*
 * As the name says.  Check that the initial state is reasonable.
 * If any unrecoverable problems are found, bail out here.
 */
static Bool
CheckInheritedState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int errors = 0, fatal = 0;
   unsigned long temp, head, tail;

   /* Check first for page table errors */
   temp = INREG(PGE_ERR);
   if (temp != 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "PGTBL_ER is 0x%08x\n", temp);
      errors++;
   }
   temp = INREG(PGETBL_CTL);
   if (!(temp & 1)) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "PGTBL_CTL (0x%08x) indicates GTT is disabled\n", temp);
      errors++;
   }
   temp = INREG(LP_RING + RING_LEN);
   if (temp & 1) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "PRB0_CTL (0x%08x) indicates ring buffer enabled\n", temp);
      errors++;
   }
   head = INREG(LP_RING + RING_HEAD);
   tail = INREG(LP_RING + RING_TAIL);
   if ((tail & I830_TAIL_MASK) != (head & I830_HEAD_MASK)) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "PRB0_HEAD (0x%08x) and PRB0_TAIL (0x%08x) indicate "
		 "ring buffer not flushed\n", head, tail);
      errors++;
   }
d1630 41
a1670 2
   if (errors)
      I830PrintErrorState(pScrn);
d1673 2
a1674 20
   if (fatal)
      FatalError("CheckInheritedState: can't recover from the above\n");

   return (errors != 0);
}

/*
 * Reset registers that it doesn't make sense to save/restore to a sane state.
 * This is basically the ring buffer and fence registers.  Restoring these
 * doesn't make sense without restoring GTT mappings.  This is something that
 * whoever gets control next should do.
 */
static void
ResetState(ScrnInfoPtr pScrn, Bool flush)
{
   I830Ptr pI830 = I830PTR(pScrn);
   int i;
   unsigned long temp;

   DPRINTF(PFX, "ResetState: flush is %s\n", BOOLTOSTRING(flush));
d1676 1
a1676 20
   /* Reset the fence registers to 0 */
   for (i = 0; i < 8; i++)
      OUTREG(FENCE + i * 4, 0);

   /* Flush the ring buffer (if enabled), then disable it. */
   if (pI830->AccelInfoRec != NULL && flush) {
      temp = INREG(LP_RING + RING_LEN);
      if (temp & 1) {
	 I830RefreshRing(pScrn);
	 I830Sync(pScrn);
	 DO_RING_IDLE();
      }
   }
   OUTREG(LP_RING + RING_LEN, 0);
   OUTREG(LP_RING + RING_HEAD, 0);
   OUTREG(LP_RING + RING_TAIL, 0);
   OUTREG(LP_RING + RING_START, 0);

   if (pI830->CursorInfoRec && pI830->CursorInfoRec->HideCursor)
       pI830->CursorInfoRec->HideCursor(pScrn);
d1679 3
a1681 2
static void
SetFenceRegs(ScrnInfoPtr pScrn)
d1683 1
a1683 77
   I830Ptr pI830 = I830PTR(pScrn);
   int i;

   DPRINTF(PFX, "SetFenceRegs\n");

   for (i = 0; i < 8; i++) {
      OUTREG(FENCE + i * 4, pI830->ModeReg.Fence[i]);
      if (I810_DEBUG & DEBUG_VERBOSE_VGA)
	 ErrorF("Fence Register : %x\n", pI830->ModeReg.Fence[i]);
   }
}

static void
SetRingRegs(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   unsigned int itemp;

   DPRINTF(PFX, "SetRingRegs\n");

   if (pI830->noAccel)
      return;

   OUTREG(LP_RING + RING_LEN, 0);
   OUTREG(LP_RING + RING_TAIL, 0);
   OUTREG(LP_RING + RING_HEAD, 0);

   if ((pI830->LpRing.mem.Start & I830_RING_START_MASK) !=
       pI830->LpRing.mem.Start) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "I830SetRingRegs: Ring buffer start (%x) violates its "
		 "mask (%x)\n", pI830->LpRing.mem.Start, I830_RING_START_MASK);
   }
   /* Don't care about the old value.  Reserved bits must be zero anyway. */
   itemp = pI830->LpRing.mem.Start & I830_RING_START_MASK;
   OUTREG(LP_RING + RING_START, itemp);

   if (((pI830->LpRing.mem.Size - 4096) & I830_RING_NR_PAGES) !=
       pI830->LpRing.mem.Size - 4096) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "I830SetRingRegs: Ring buffer size - 4096 (%x) violates its "
		 "mask (%x)\n", pI830->LpRing.mem.Size - 4096,
		 I830_RING_NR_PAGES);
   }
   /* Don't care about the old value.  Reserved bits must be zero anyway. */
   itemp = (pI830->LpRing.mem.Size - 4096) & I830_RING_NR_PAGES;
   itemp |= (RING_NO_REPORT | RING_VALID);
   OUTREG(LP_RING + RING_LEN, itemp);
   I830RefreshRing(pScrn);
}

/*
 * This should be called everytime the X server gains control of the screen,
 * before any video modes are programmed (ScreenInit, EnterVT).
 */
static void
SetHWOperatingState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "SetHWOperatingState\n");

   if (!pI830->noAccel)
      SetRingRegs(pScrn);
   SetFenceRegs(pScrn);
   if (!pI830->SWCursor)
      I830InitHWCursor(pScrn);
}

static Bool
SaveHWState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   vgaHWPtr hwp = VGAHWPTR(pScrn);
   vgaRegPtr vgaReg = &hwp->SavedReg;
   VbeModeInfoBlock *modeInfo;
d1686 2
a1687 20
   DPRINTF(PFX, "SaveHWState\n");

   pVesa = pI830->vesa;
   /* Make sure we save at least this information in case of failure. */
   VBEGetVBEMode(pVbe, &pVesa->stateMode);
   modeInfo = VBEGetModeInfo(pVbe, pVesa->stateMode);
   pVesa->savedScanlinePitch = 0;
   if (modeInfo) {
      if (VBE_MODE_GRAPHICS(modeInfo)) {
         VBEGetLogicalScanline(pVbe, &pVesa->savedScanlinePitch, NULL, NULL);
      }
      VBEFreeModeInfo(modeInfo);
   }

   vgaHWUnlock(hwp);
   vgaHWSave(pScrn, vgaReg, VGA_SR_FONTS);

#ifndef I845G_VBE_WORKAROUND
#define I845G_VBE_WORKAROUND 1
#endif
d1689 2
a1690 21
   pVesa = pI830->vesa;
   /* This save/restore method doesn't work for 845G BIOS */
   /*
    * XXX If it's fixed in production versions, this could be removed.
    *
    * KW: This may have been because of the behaviour I've found on my
    * board: The 'save' command actually modifies the interrupt
    * registers, turning off the irq & breaking the kernel module
    * behaviour.
    */
   if (!I845G_VBE_WORKAROUND || !IS_845G(pI830)) {
      CARD16 imr = INREG16(IMR);
      CARD16 ier = INREG16(IER);
      CARD16 hwstam = INREG16(HWSTAM);

      if (!VBESaveRestore(pVbe, MODE_SAVE, &pVesa->state, &pVesa->stateSize,
			  &pVesa->statePage)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "SaveHWState: VBESaveRestore(MODE_SAVE) failed.\n");
	 return FALSE;
      }
d1692 14
a1705 11
      OUTREG16(IMR, imr);
      OUTREG16(IER, ier);
      OUTREG16(HWSTAM, hwstam);
   }

   pVesa->savedPal = VBESetGetPaletteData(pVbe, FALSE, 0, 256,
					     NULL, FALSE, FALSE);
   if (!pVesa->savedPal) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "SaveHWState: VBESetGetPaletteData(GET) failed.\n");
      return FALSE;
d1711 2
a1712 2
static Bool
RestoreHWState(ScrnInfoPtr pScrn)
d1714 1
a1714 4
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   vgaHWPtr hwp = VGAHWPTR(pScrn);
   vgaRegPtr vgaReg = &hwp->SavedReg;
a1715 5
   Bool restored = FALSE;

   DPRINTF(PFX, "RestoreHWState\n");

   pVesa = pI830->vesa;
d1717 2
a1718 7
   /*
    * Workaround for text mode restoration with some flat panels.
    * Temporarily program a 640x480 mode before switching back to
    * text mode.
    */
   if (pVesa->useDefaultRefresh) {
      int mode = 0;
d1720 5
a1724 17
      switch (pScrn->depth) {
      case 8:
	 mode = 0x30;
	 break;
      case 15:
	 mode = 0x40;
	 break;
      case 16:
	 mode = 0x41;
	 break;
      case 24:
	 mode = 0x50;
	 break;
      }
      mode |= (1 << 15) | (1 << 14);
      I830VESASetVBEMode(pScrn, mode, NULL);
   }
d1726 1
a1726 37
   if (pVesa->state && pVesa->stateSize) {
      CARD16 imr = INREG16(IMR);
      CARD16 ier = INREG16(IER);
      CARD16 hwstam = INREG16(HWSTAM);

      /* Make a copy of the state.  Don't rely on it not being touched. */
      if (!pVesa->pstate) {
	 pVesa->pstate = xalloc(pVesa->stateSize);
	 if (pVesa->pstate)
	    memcpy(pVesa->pstate, pVesa->state, pVesa->stateSize);
      }
      restored = VBESaveRestore(pVbe, MODE_RESTORE, &pVesa->state,
				   &pVesa->stateSize, &pVesa->statePage);
      if (!restored) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "RestoreHWState: VBESaveRestore failed.\n");
      }
      /* Copy back */
      if (pVesa->pstate)
	 memcpy(pVesa->state, pVesa->pstate, pVesa->stateSize);

      OUTREG16(IMR, imr);
      OUTREG16(IER, ier);
      OUTREG16(HWSTAM, hwstam);
   }
   /* If that failed, restore the original mode. */
   if (!restored) {
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		 "Setting the original video mode instead of restoring\n\t"
		 "the saved state\n");
      I830VESASetVBEMode(pScrn, pVesa->stateMode, NULL);
   }
   if (pVesa->savedScanlinePitch)
       VBESetLogicalScanline(pVbe, pVesa->savedScanlinePitch);

   if (pVesa->savedPal)
      VBESetGetPaletteData(pVbe, TRUE, 0, 256, pVesa->savedPal, FALSE, TRUE);
d1728 1
a1728 3
   vgaHWRestore(pScrn, vgaReg, VGA_SR_FONTS);
   vgaHWLock(hwp);
   return TRUE;
d1731 1
a1731 6
#ifndef USE_VBE
#define USE_VBE 1
#endif

static Bool
I830VESASetVBEMode(ScrnInfoPtr pScrn, int mode, VbeCRTCInfoBlock * block)
d1733 4
a1736 1
   I830Ptr pI830 = I830PTR(pScrn);
d1738 2
a1739 18
   DPRINTF(PFX, "Setting mode 0x%.8x\n", mode);
#if USE_VBE
   return VBESetVBEMode(pI830->pVbe, mode, block);
#else
   {
      vbeInfoPtr pVbe = pI830->pVbe;
      pVbe->pInt10->num = 0x10;
      pVbe->pInt10->ax = 0x80 | (mode & 0x7f);
      xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
      pVbe->pInt10->ax = 0x0f00;
      xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
      if ((pVbe->pInt10->ax & 0x7f) == (mode & 0x7f))
	 return TRUE;
      else
	 return FALSE;
   }
#endif
}
d1741 1
a1741 16
static Bool
I830VESASetMode(ScrnInfoPtr pScrn, DisplayModePtr pMode)
{
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
   VbeModeInfoData *data;
   int mode, i;
   CARD32 planeA, planeB, temp;
   int refresh = 60;
#ifdef XF86DRI
   Bool didLock = FALSE;
#endif

   DPRINTF(PFX, "I830VESASetMode\n");

   data = (VbeModeInfoData *) pMode->Private;
d1747 5
a1751 12
   if (pI830->directRenderingEnabled && !pI830->LockHeld) {
      DRILock(screenInfo.screens[pScrn->scrnIndex], 0);
      pI830->LockHeld = 1;
      didLock = TRUE;
   }
#endif

#ifndef MODESWITCH_RESET_STATE
#define MODESWITCH_RESET_STATE 0
#endif
#if MODESWITCH_RESET_STATE
   ResetState(pScrn, TRUE);
d1754 17
a1770 186
   /* XXX Add macros for the various mode parameter bits. */

   if (pI830->vesa->useDefaultRefresh)
      mode &= ~(1 << 11);

   if (I830VESASetVBEMode(pScrn, mode, data->block) == FALSE) {
      if ((data->block && (mode & (1 << 11))) &&
	  I830VESASetVBEMode(pScrn, (mode & ~(1 << 11)), NULL) == TRUE) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Set VBE Mode rejected this modeline.\n\t"
		    "Trying standard mode instead!\n");
	 DPRINTF(PFX, "OOPS!\n");
	 xfree(data->block);
	 data->block = NULL;
	 data->mode &= ~(1 << 11);
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Set VBE Mode failed!\n");
	 return FALSE;
      }
   }

   /*
    * The BIOS may not set a scanline pitch that would require more video
    * memory than it's aware of.  We check for this later, and set it
    * explicitly if necessary.
    */
   if (data->data->XResolution != pScrn->displayWidth)
      VBESetLogicalScanline(pVbe, pScrn->displayWidth);

   if (pScrn->bitsPerPixel >= 8 && pI830->vbeInfo->Capabilities[0] & 0x01)
      VBESetGetDACPaletteFormat(pVbe, 8);

   /*
    * XXX This location of this isn't correct.
    *
    * Turn on the configured displays.  This has the effect of resetting
    * the default refresh rates to values that the configured displays
    * can handle.  This seems to be the safest way to make sure that this
    * happens.  When it's safe to set higher values, we do that after this.
    *
    * Note: When a DFP is connected to an 830, this causes the mode setting
    * to be trashed.  So, we don't do it on the 830.
    *
    * XXX Need to test an 830 with a LFP.
    */
   if (pI830->enableDisplays) {
      if (!SetDisplayDevices(pScrn, pI830->configuredDevices)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Failed to switch to configured display devices\n");
      }
   }

   /*
    * When it's OK to set better than default refresh rates, set them here.
    */
   if (pI830->useExtendedRefresh && !pI830->vesa->useDefaultRefresh &&
       (mode & (1 << 11)) && data && data->data && data->block) {
      refresh = SetRefreshRate(pScrn, mode, data->block->RefreshRate / 100);
      if (!refresh) {
	 refresh = 60;
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Failed to set refresh rate to %dHz.\n",
		    data->block->RefreshRate / 100);
      }
   }


   /* XXX Fix plane A with pipe A, and plane B with pipe B. */
   planeA = INREG(DSPACNTR);
   planeB = INREG(DSPBCNTR);

   pI830->planeEnabled[0] = ((planeA & DISPLAY_PLANE_ENABLE) != 0);
   pI830->planeEnabled[1] = ((planeB & DISPLAY_PLANE_ENABLE) != 0);

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Display plane A is %s.\n",
	      pI830->planeEnabled[0] ? "enabled" : "disabled");
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Display plane B is %s.\n",
	      pI830->planeEnabled[1] ? "enabled" : "disabled");

   /*
    * Sometimes it seems that no display planes are enabled at this point.
    * For mobile platforms pick the plane(s) connected to enabled pipes.
    * For others choose plane A.
    */
   if (!pI830->planeEnabled[0] && !pI830->planeEnabled[1]) {
      if (IS_MOBILE(pI830)) {
	 if ((pI830->pipeEnabled[0] &&
	      ((planeA & DISPPLANE_SEL_PIPE_MASK) == DISPPLANE_SEL_PIPE_A)) ||
	     (pI830->pipeEnabled[1] &&
	      ((planeA & DISPPLANE_SEL_PIPE_MASK) == DISPPLANE_SEL_PIPE_B))) {
	    pI830->planeEnabled[0] = TRUE;
	 }
	 if ((pI830->pipeEnabled[0] &&
	      ((planeB & DISPPLANE_SEL_PIPE_MASK) == DISPPLANE_SEL_PIPE_A)) ||
	     (pI830->pipeEnabled[1] &&
	      ((planeB & DISPPLANE_SEL_PIPE_MASK) == DISPPLANE_SEL_PIPE_B))) {
	    pI830->planeEnabled[1] = TRUE;
	 }
      } else {
	 pI830->planeEnabled[0] = TRUE;
      }
      if (pI830->planeEnabled[0]) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Enabling plane A.\n");
	 planeA |= DISPLAY_PLANE_ENABLE;
	 OUTREG(DSPACNTR, planeA);
	 /* flush the change. */
	 temp = INREG(DSPABASE);
	 OUTREG(DSPABASE, temp);
      }
      if (pI830->planeEnabled[1]) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Enabling plane B.\n");
	 planeB |= DISPLAY_PLANE_ENABLE;
	 OUTREG(DSPBCNTR, planeB);
	 /* flush the change. */
	 temp = INREG(DSPBADDR);
	 OUTREG(DSPBADDR, temp);
      }
   }

   /* XXX Plane C is ignored for now (overlay). */

   /*
    * Print out the PIPEACONF and PIPEBCONF registers.
    */
   temp = INREG(PIPEACONF);
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PIPEACONF is 0x%08x\n", temp);
   if (IS_MOBILE(pI830)) {
      temp = INREG(PIPEBCONF);
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PIPEBCONF is 0x%08x\n", temp);
   }

#if PRINT_MODE_INFO
   /* Print out some CRTC/display information. */
   temp = INREG(HTOTAL_A);
   ErrorF("Horiz active: %d, Horiz total: %d\n", temp & 0x7ff,
	  (temp >> 16) & 0xfff);
   temp = INREG(HBLANK_A);
   ErrorF("Horiz blank start: %d, Horiz blank end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(HSYNC_A);
   ErrorF("Horiz sync start: %d, Horiz sync end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(VTOTAL_A);
   ErrorF("Vert active: %d, Vert total: %d\n", temp & 0x7ff,
	  (temp >> 16) & 0xfff);
   temp = INREG(VBLANK_A);
   ErrorF("Vert blank start: %d, Vert blank end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(VSYNC_A);
   ErrorF("Vert sync start: %d, Vert sync end: %d\n", temp & 0xfff,
	  (temp >> 16) & 0xfff);
   temp = INREG(PIPEASRC);
   ErrorF("Image size: %dx%d (%dx%d)\n",
          (temp >> 16) & 0x7ff, temp & 0x7ff,
	  (((temp >> 16) & 0x7ff) + 1), ((temp & 0x7ff) + 1));
   ErrorF("Pixel multiply is %d\n", (planeA >> 20) & 0x3);
   temp = INREG(DSPABASE);
   ErrorF("Plane A start offset is %d\n", temp);
   temp = INREG(DSPASTRIDE);
   ErrorF("Plane A stride is %d bytes (%d pixels)\n", temp, temp / pI830->cpp);
#endif

   for (i = 0; i < MAX_DISPLAY_PIPES; i++) {
      CARD32 stridereg = i ? DSPBSTRIDE : DSPASTRIDE;
      CARD32 basereg = i ? DSPBBASE : DSPABASE;

      if (!pI830->planeEnabled[i])
	 continue;

      temp = INREG(stridereg);
      if (temp / pI830->cpp != pScrn->displayWidth) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		    "Correcting plane %c stride (%d -> %d)\n", PIPE_NAME(i),
		    temp / pI830->cpp, pScrn->displayWidth);
	 OUTREG(stridereg, pScrn->displayWidth * pI830->cpp);
	 /* Trigger update */
	 temp = INREG(basereg);
	 OUTREG(basereg, temp);
      }
   }

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Mode bandwidth is %d Mpixel/s\n",
	      pMode->HDisplay * pMode->VDisplay * refresh / 1000000);

   {
      int maxBandwidth, bandwidthA, bandwidthB;
d1772 61
a1832 7
      if (GetModeSupport(pScrn, 0x80, 0x80, 0x80, 0x80,
			&maxBandwidth, &bandwidthA, &bandwidthB)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "maxBandwidth is %d Mbyte/s, "
		    "pipe bandwidths are %d Mbyte/s, %d Mbyte/s\n",
		    maxBandwidth, bandwidthA, bandwidthB);
      }
   }
d1834 2
a1835 2
   {
      int ret;
d1837 2
a1838 6
      ret = GetLFPCompMode(pScrn);
      if (ret != -1) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "LFP compensation mode: 0x%x\n", ret);
      }
   }
d1840 2
a1841 4
#if MODESWITCH_RESET_STATE
   ResetState(pScrn, TRUE);
   SetHWOperatingState(pScrn);
#endif
d1844 5
a1848 4
   if (pI830->directRenderingEnabled && didLock) {
      DRIUnlock(screenInfo.screens[pScrn->scrnIndex]);
      pI830->LockHeld = 0;
   }
d1852 1
a1852 1
   return TRUE;
d1855 3
a1857 2
static void
InitRegisterRec(ScrnInfoPtr pScrn)
d1859 20
a1878 3
   I830Ptr pI830 = I830PTR(pScrn);
   I830RegPtr i830Reg = &pI830->ModeReg;
   int i;
d1880 1
a1880 3
   for (i = 0; i < 8; i++)
      i830Reg->Fence[i] = 0;
}
d1882 1
a1882 6
/* Famous last words
 */
void
I830PrintErrorState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
d1884 2
a1885 2
   ErrorF("pgetbl_ctl: 0x%lx pgetbl_err: 0x%lx\n",
	  INREG(PGETBL_CTL), INREG(PGE_ERR));
d1887 2
a1888 1
   ErrorF("ipeir: %lx iphdr: %lx\n", INREG(IPEIR), INREG(IPEHR));
d1890 8
a1897 4
   ErrorF("LP ring tail: %lx head: %lx len: %lx start %lx\n",
	  INREG(LP_RING + RING_TAIL),
	  INREG(LP_RING + RING_HEAD) & HEAD_ADDR,
	  INREG(LP_RING + RING_LEN), INREG(LP_RING + RING_START));
d1899 2
a1900 2
   ErrorF("eir: %x esr: %x emr: %x\n",
	  INREG16(EIR), INREG16(ESR), INREG16(EMR));
d1902 19
a1920 1
   ErrorF("instdone: %x instpm: %x\n", INREG16(INST_DONE), INREG8(INST_PM));
d1922 1
a1922 1
   ErrorF("memmode: %lx instps: %lx\n", INREG(MEMMODE), INREG(INST_PS));
d1924 1
a1924 2
   ErrorF("hwstam: %x ier: %x imr: %x iir: %x\n",
	  INREG16(HWSTAM), INREG16(IER), INREG16(IMR), INREG16(IIR));
d1928 1
a1928 2
static void
dump_DSPACNTR(ScrnInfoPtr pScrn)
d1930 1
a1930 1
   I830Ptr pI830 = I830PTR(pScrn);
d1934 2
a1935 2
   tmp = INREG(0x70180);
   ErrorF("Display A Plane Control Register (0x%.8x)\n", tmp);
d1938 1
a1938 1
      ErrorF("   Display Plane A (Primary) Enable\n");
d1940 1
a1940 1
      ErrorF("   Display Plane A (Primary) Disabled\n");
d1943 1
a1943 1
      ErrorF("   Display A pixel data is gamma corrected\n");
d1945 1
a1945 1
      ErrorF("   Display A pixel data bypasses gamma correction logic (default)\n");
d1947 25
a1971 24
   switch ((tmp & 0x3c000000) >> 26) {	/* bit 29:26 */
   case 0x00:
   case 0x01:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
   case 0x02:
      ErrorF("   8-bpp Indexed\n");
      break;
   case 0x04:
      ErrorF("   15-bit (5-5-5) pixel format (Targa compatible)\n");
      break;
   case 0x05:
      ErrorF("   16-bit (5-6-5) pixel format (XGA compatible)\n");
      break;
   case 0x06:
      ErrorF("   32-bit format (X:8:8:8)\n");
      break;
   case 0x07:
      ErrorF("   32-bit format (8:8:8:8)\n");
      break;
   default:
      ErrorF("   Unknown - Invalid register value maybe?\n");
   }
d1974 1
a1974 1
      ErrorF("   Stereo Enable\n");
d1976 1
a1976 1
      ErrorF("   Stereo Disable\n");
d1979 1
a1979 1
      ErrorF("   Display A, Pipe B Select\n");
d1981 1
a1981 1
      ErrorF("   Display A, Pipe A Select\n");
d1984 1
a1984 1
      ErrorF("   Source key is enabled\n");
d1986 1
a1986 1
      ErrorF("   Source key is disabled\n");
d1988 13
a2000 12
   switch ((tmp & 0x00300000) >> 20) {	/* bit 21:20 */
   case 0x00:
      ErrorF("   No line duplication\n");
      break;
   case 0x01:
      ErrorF("   Line/pixel Doubling\n");
      break;
   case 0x02:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
   }
d2003 1
a2003 1
      ErrorF("   Stereo output is high during second image\n");
d2005 1
a2005 1
      ErrorF("   Stereo output is high during first image\n");
d2008 1
a2008 2
static void
dump_DSPBCNTR(ScrnInfoPtr pScrn)
d2010 1
a2010 1
   I830Ptr pI830 = I830PTR(pScrn);
d2014 2
a2015 2
   tmp = INREG(0x71180);
   ErrorF("Display B/Sprite Plane Control Register (0x%.8x)\n", tmp);
d2018 1
a2018 1
      ErrorF("   Display B/Sprite Enable\n");
d2020 1
a2020 1
      ErrorF("   Display B/Sprite Disable\n");
d2023 1
a2023 1
      ErrorF("   Display B pixel data is gamma corrected\n");
d2025 1
a2025 1
      ErrorF("   Display B pixel data bypasses gamma correction logic (default)\n");
d2027 25
a2051 24
   switch ((tmp & 0x3c000000) >> 26) {	/* bit 29:26 */
   case 0x00:
   case 0x01:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
   case 0x02:
      ErrorF("   8-bpp Indexed\n");
      break;
   case 0x04:
      ErrorF("   15-bit (5-5-5) pixel format (Targa compatible)\n");
      break;
   case 0x05:
      ErrorF("   16-bit (5-6-5) pixel format (XGA compatible)\n");
      break;
   case 0x06:
      ErrorF("   32-bit format (X:8:8:8)\n");
      break;
   case 0x07:
      ErrorF("   32-bit format (8:8:8:8)\n");
      break;
   default:
      ErrorF("   Unknown - Invalid register value maybe?\n");
   }
d2054 1
a2054 1
      ErrorF("   Stereo is enabled and both start addresses are used in a two frame sequence\n");
d2056 1
a2056 1
      ErrorF("   Stereo disable and only a single start address is used\n");
d2059 1
a2059 1
      ErrorF("   Display B/Sprite, Pipe B Select\n");
d2061 1
a2061 1
      ErrorF("   Display B/Sprite, Pipe A Select\n");
d2064 1
a2064 1
      ErrorF("   Sprite source key is enabled\n");
d2066 1
a2066 1
      ErrorF("   Sprite source key is disabled (default)\n");
d2068 13
a2080 12
   switch ((tmp & 0x00300000) >> 20) {	/* bit 21:20 */
   case 0x00:
      ErrorF("   No line duplication\n");
      break;
   case 0x01:
      ErrorF("   Line/pixel Doubling\n");
      break;
   case 0x02:
   case 0x03:
      ErrorF("   Reserved\n");
      break;
   }
d2083 1
a2083 1
      ErrorF("   Stereo output is high during second image\n");
d2085 1
a2085 1
      ErrorF("   Stereo output is high during first image\n");
d2088 1
a2088 1
      ErrorF("   Alpha transfer mode enabled\n");
d2090 1
a2090 1
      ErrorF("   Alpha transfer mode disabled\n");
d2093 1
a2093 1
      ErrorF("   Sprite is above overlay\n");
d2095 1
a2095 1
      ErrorF("   Sprite is above display A (default)\n");
d2098 1
a2098 2
void
I830_dump_registers(ScrnInfoPtr pScrn)
d2100 1
a2100 1
   I830Ptr pI830 = I830PTR(pScrn);
d2102 1
d2104 2
a2105 1
   ErrorF("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");
d2107 2
a2108 5
   dump_DSPACNTR(pScrn);
   dump_DSPBCNTR(pScrn);

   ErrorF("0x71400 == 0x%.8x\n", INREG(0x71400));
   ErrorF("0x70008 == 0x%.8x\n", INREG(0x70008));
d2110 1
a2110 1
      ErrorF("0x%x == 0x%.8x\n", i, INREG(i));
d2112 1
a2112 1
   ErrorF("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n");
d2116 1
a2116 1
static Bool
d2121 2
a2122 1
   I830Ptr pI830;
a2123 3
#ifdef XF86DRI
   Bool driDisabled;
#endif
d2126 2
a2127 1
   pI830 = I830PTR(pScrn);
a2129 12
   pI830->starting = TRUE;

   /*
    * If we're changing the BIOS's view of the video memory size, do that
    * first, then re-initialise the VBE information.
    */
   pI830->pVbe = VBEInit(NULL, pI830->pEnt->index);
   SetBIOSMemSize(pScrn, pI830->newBIOSMemSize);
   if (!pI830->pVbe)
      return FALSE;
   pI830->vbeInfo = VBEGetVBEInfo(pI830->pVbe);

d2131 4
a2134 6
   if (!xf86SetDefaultVisual(pScrn, -1))
      return FALSE;
   if (pScrn->bitsPerPixel > 8) {
      if (!miSetVisualTypes(pScrn->depth, TrueColorMask,
			    pScrn->rgbBits, TrueColor))
	 return FALSE;
d2136 3
a2138 56
      if (!miSetVisualTypes(pScrn->depth,
			    miGetDefaultVisualMask(pScrn->depth),
			    pScrn->rgbBits, pScrn->defaultVisual))
	 return FALSE;
   }
   if (!miSetPixmapDepths())
      return FALSE;

#ifdef I830_XV
   pI830->XvEnabled = !pI830->XvDisabled;
   if (pI830->XvEnabled) {
      if (pI830->noAccel || pI830->StolenOnly) {
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Xv is disabled because it "
		    "needs 2D accel and AGPGART.\n");
	 pI830->XvEnabled = FALSE;
      }
   }
#else
   pI830->XvEnabled = FALSE;
#endif

   I830ResetAllocations(pScrn, 0);

   I830Allocate2DMemory(pScrn, ALLOC_INITIAL);

   if (!pI830->noAccel) {
      if (pI830->LpRing.mem.Size == 0) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     "Disabling acceleration because the ring buffer "
		      "allocation failed.\n");
	   pI830->noAccel = TRUE;
      }
   }

   if (!pI830->SWCursor) {
      if (pI830->CursorMem.Size == 0) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     "Disabling HW cursor because the cursor memory "
		      "allocation failed.\n");
	   pI830->SWCursor = TRUE;
      }
   }

#ifdef I830_XV
   if (pI830->XvEnabled) {
      if (pI830->noAccel) {
	 xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Disabling Xv because it "
		    "needs 2D acceleration.\n");
	 pI830->XvEnabled = FALSE;
      }
      if (pI830->OverlayMem.Physical == 0) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     "Disabling Xv because the overlay register buffer "
		      "allocation failed.\n");
	 pI830->XvEnabled = FALSE;
      }
d2140 1
a2140 3
#endif

   InitRegisterRec(pScrn);
d2144 2
a2145 7
    * pI830->directRenderingDisabled is set once in PreInit.  Reinitialise
    * pI830->directRenderingEnabled based on it each generation.
    */
   pI830->directRenderingEnabled = !pI830->directRenderingDisabled;
   /*
    * Setup DRI after visuals have been established, but before fbScreenInit
    * is called.   fbScreenInit will eventually call into the drivers
d2149 6
a2154 6
   if (pI830->directRenderingEnabled) {
      if (pI830->noAccel || pI830->SWCursor || pI830->StolenOnly) {
	 xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "DRI is disabled because it "
		    "needs HW cursor, 2D accel and AGPGART.\n");
	 pI830->directRenderingEnabled = FALSE;
      }
a2155 10

   driDisabled = !pI830->directRenderingEnabled;

   if (pI830->directRenderingEnabled)
      pI830->directRenderingEnabled = I830DRIScreenInit(pScreen);

   if (pI830->directRenderingEnabled)
      if (!(pI830->directRenderingEnabled = I830Allocate3DMemory(pScrn, 0)))
	  I830DRICloseScreen(pScreen);

d2157 2
a2158 11
   pI830->directRenderingEnabled = FALSE;
#endif

   /*
    * After the 3D allocations have been done, see if there's any free space
    * that can be added to the framebuffer allocation.
    */
   I830Allocate2DMemory(pScrn, 0);

   DPRINTF(PFX, "assert(if(!I830DoPoolAllocation(pScrn, pI830->StolenPool)))\n");
   if (!I830DoPoolAllocation(pScrn, &(pI830->StolenPool)))
d2160 1
a2160 3

   DPRINTF(PFX, "assert( if(!I830FixupOffsets(pScrn)) )\n");
   if (!I830FixupOffsets(pScrn))
a2161 6

#ifdef XF86DRI
   if (pI830->directRenderingEnabled) {
      I830SetupMemoryTiling(pScrn);
      pI830->directRenderingEnabled = I830DRIDoMappings(pScreen);
   }
d2164 2
a2165 3
   DPRINTF(PFX, "assert( if(!I830MapMem(pScrn)) )\n");
   if (!I830MapMem(pScrn))
      return FALSE;
d2167 2
a2168 2
   pScrn->memPhysBase = (unsigned long)pI830->FbBase;
   pScrn->fbOffset = pI830->FrontBuffer.Start;
d2170 1
a2170 1
   vgaHWSetMmioFuncs(hwp, pI830->MMIOBase, 0);
d2172 2
a2173 10
   DPRINTF(PFX, "assert( if(!vgaHWMapMem(pScrn)) )\n");
   if (!vgaHWMapMem(pScrn))
      return FALSE;

   /* Clear SavedReg */
   memset(&pI830->SavedReg, 0, sizeof(pI830->SavedReg));

   DPRINTF(PFX, "assert( if(!I830BIOSEnterVT(scrnIndex, 0)) )\n");
   if (!I830BIOSEnterVT(scrnIndex, 0))
      return FALSE;
d2175 10
a2184 6
   DPRINTF(PFX, "assert( if(!fbScreenInit(pScreen, ...) )\n");
   if (!fbScreenInit(pScreen, pI830->FbBase + pScrn->fbOffset,
		     pScrn->virtualX, pScrn->virtualY,
		     pScrn->xDpi, pScrn->yDpi,
		     pScrn->displayWidth, pScrn->bitsPerPixel))
      return FALSE;
d2186 1
a2186 1
   if (pScrn->bitsPerPixel > 8) {
d2189 2
a2190 2
      while (--visual >= pScreen->visuals) {
	 if ((visual->class | DynamicClass) == DirectColor) {
d2201 1
a2201 1
   fbPictureInit(pScreen, 0, 0);
d2203 5
a2207 1
   xf86SetBlackWhitePixels(pScreen);
d2209 9
a2217 2
#if 1
   I830DGAInit(pScreen);
d2220 4
a2223 3
   DPRINTF(PFX,
	   "assert( if(!xf86InitFBManager(pScreen, &(pI830->FbMemBox))) )\n");
   if (!xf86InitFBManager(pScreen, &(pI830->FbMemBox))) {
d2225 1
a2225 1
		 "Failed to init memory manager\n");
d2229 8
a2236 4
   if (!pI830->noAccel) {
      if (!I830AccelInit(pScreen)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Hardware acceleration initialization failed\n");
d2245 7
a2251 7
   if (!pI830->SWCursor) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Initializing HW Cursor\n");
      if (!I830CursorInit(pScreen))
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Hardware cursor initialization failed\n");
   } else
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Initializing SW Cursor!\n");
d2253 2
a2254 3
   DPRINTF(PFX, "assert( if(!miCreateDefColormap(pScreen)) )\n");
   if (!miCreateDefColormap(pScreen))
      return FALSE;
d2256 2
a2257 5
   DPRINTF(PFX, "assert( if(!xf86HandleColormaps(pScreen, ...)) )\n");
   if (!xf86HandleColormaps(pScreen, 256, 8, I830LoadPalette, 0,
			    CMAP_RELOAD_ON_MODE_SWITCH)) {
      return FALSE;
   }
d2263 1
a2263 5
#ifdef I830_XV
   /* Init video */
   if (pI830->XvEnabled)
      I830InitVideo(pScreen);
#endif
d2266 5
a2270 2
   if (pI830->directRenderingEnabled) {
      pI830->directRenderingEnabled = I830DRIFinishScreenInit(pScreen);
d2274 1
a2274 3
#ifdef XF86DRI
   if (pI830->directRenderingEnabled) {
      pI830->directRenderingOpen = TRUE;
d2277 1
d2279 4
d2284 1
a2284 1
      if (driDisabled)
d2286 1
a2286 1
      else
d2288 2
d2291 1
a2291 4
#else
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "direct rendering: Not available\n");
#endif

d2293 1
a2293 1
   pI830->CloseScreen = pScreen->CloseScreen;
d2298 1
a2298 1
#if 0
d2300 1
a2300 2
   I830_dump_registers(pScrn);
#endif
d2302 19
d2322 1
a2322 3
   pI830->starting = FALSE;
   pI830->closing = FALSE;
   pI830->suspended = FALSE;
d2326 1
a2326 1
static void
a2329 4
   I830Ptr pI830;
   vbeInfoPtr pVbe;
   static int xoffset = 0, yoffset = 0;
   static int adjustGeneration = -1;
d2332 1
a2332 24
   pI830 = I830PTR(pScrn);
   pVbe = pI830->pVbe;

   DPRINTF(PFX, "I830BIOSAdjustFrame: y = %d (+ %d), x = %d (+ %d)\n",
	   x, xoffset, y, yoffset);

   /* Calculate the offsets once per server generation. */
   if (adjustGeneration != serverGeneration) {
      adjustGeneration = serverGeneration;
      xoffset = (pScrn->fbOffset / pI830->cpp) % pScrn->displayWidth;
      yoffset = (pScrn->fbOffset / pI830->cpp) / pScrn->displayWidth;
   }

   if (OffsetFrame) {
      y = (pI830->FbMemBox.y2 - pScrn->currentMode->VDisplay);
      ErrorF("AdjustFrame: OffsetFrame is set, setting y to %d\n", y);
   }
   x += xoffset;
   y += yoffset;
#if 0
   x >>= 4;
   x <<= 4;
#endif
   VBESetDisplayStart(pVbe, x, y, TRUE);
d2335 1
a2335 1
static void
d2340 1
a2340 1
      vgaHWFreeHWRec(xf86Screens[scrnIndex]);
d2343 6
a2348 2
#ifndef SAVERESTORE_HWSTATE
#define SAVERESTORE_HWSTATE 0
d2351 1
a2351 6
#if SAVERESTORE_HWSTATE
static void
SaveHWOperatingState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   I830RegPtr save = &pI830->SavedReg;
d2353 6
a2358 15
   DPRINTF(PFX, "SaveHWOperatingState\n");

   return;
}

static void
RestoreHWOperatingState(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   I830RegPtr save = &pI830->SavedReg;

   DPRINTF(PFX, "RestoreHWOperatingState\n");

   return;
}
d2361 6
a2366 6
static void
I830BIOSLeaveVT(int scrnIndex, int flags)
{
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
#ifdef XF86DRI
   I830Ptr pI830 = I830PTR(pScrn);
d2369 1
a2369 9
   DPRINTF(PFX, "Leave VT\n");

#ifdef XF86DRI
   if (pI830->directRenderingOpen) {
      DPRINTF(PFX, "calling dri lock\n");
      DRILock(screenInfo.screens[scrnIndex], 0);
      pI830->LockHeld = 1;
   }
#endif
d2371 1
a2371 4
#if SAVERESTORE_HWSTATE
   if (!pI830->closing)
      SaveHWOperatingState(pScrn);
#endif
d2373 1
a2373 4
   ResetState(pScrn, TRUE);
   RestoreHWState(pScrn);
   RestoreBIOSMemSize(pScrn);
   I830UnbindGARTMemory(pScrn);
d2376 4
a2379 11
/*
 * This gets called when gaining control of the VT, and from ScreenInit().
 */
static Bool
I830BIOSEnterVT(int scrnIndex, int flags)
{
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);
   static int SaveGeneration = -1;

   DPRINTF(PFX, "Enter VT\n");
d2381 1
a2381 2
   if (!I830BindGARTMemory(pScrn))
      return FALSE;
d2383 1
a2383 2
   CheckInheritedState(pScrn);
   SetBIOSMemSize(pScrn, pI830->newBIOSMemSize);
d2385 6
a2390 15
   /*
    * Only save state once per server generation since that's what most
    * drivers do.  Could change this to save state at each VT enter.
    */
   if (SaveGeneration != serverGeneration) {
      SaveGeneration = serverGeneration;
      SaveHWState(pScrn);
   }
   ResetState(pScrn, FALSE);
   SetHWOperatingState(pScrn);

#if 1
   /* Clear the framebuffer */
   memset(pI830->FbBase + pScrn->fbOffset, 0,
	  pScrn->virtualY * pScrn->displayWidth * pI830->cpp);
d2393 14
a2406 4
   if (!I830VESASetMode(pScrn, pScrn->currentMode))
      return FALSE;
#ifdef I830_XV
   I830VideoSwitchModeAfter(pScrn, pScrn->currentMode);
d2409 2
a2410 2
   ResetState(pScrn, TRUE);
   SetHWOperatingState(pScrn);
d2412 1
a2412 1
   pScrn->AdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
d2414 6
a2419 17
#if SAVERESTORE_HWSTATE
   RestoreHWOperatingState(pScrn);
#endif

#ifdef XF86DRI
   if (pI830->directRenderingEnabled) {
      if (!pI830->starting) {
	 I830EmitInvarientState(pScrn);
	 I830RefreshRing(pScrn);
	 I830Sync(pScrn);
	 DO_RING_IDLE();

	 DPRINTF(PFX, "calling dri unlock\n");
	 DRIUnlock(screenInfo.screens[scrnIndex]);
      }
      pI830->LockHeld = 0;
   }
d2422 1
a2422 1
   return TRUE;
d2425 1
a2425 1
static Bool
d2428 2
a2429 44

   int _head;
   int _tail;
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);
   int ret = TRUE;

   DPRINTF(PFX, "I830BIOSSwitchMode: mode == %p\n", mode);

   /* Stops head pointer freezes for 845G */
   if (!pI830->noAccel && (1 || IS_845G(pI830))) {
      do {
	 _head = INREG(LP_RING + RING_HEAD) & I830_HEAD_MASK;
	 _tail = INREG(LP_RING + RING_TAIL) & I830_TAIL_MASK;
	 DELAY(1000);
      } while (_head != _tail);
   }

#if 0
   OffsetFrame = !OffsetFrame;
   pScrn->AdjustFrame(scrnIndex, 0, 0, 0);
#endif

#ifndef BINDUNBIND
#define BINDUNBIND 0
#endif
#if BINDUNBIND
   I830UnbindGARTMemory(pScrn);
#endif
#ifdef I830_XV
   /* Give the video overlay code a chance to see the new mode. */
   I830VideoSwitchModeBefore(pScrn, mode);
#endif
   if (!I830VESASetMode(pScrn, mode))
      ret = FALSE;
#ifdef I830_XV
   /* Give the video overlay code a chance to see the new mode. */
   I830VideoSwitchModeAfter(pScrn, mode);
#endif
#if BINDUNBIND
   I830BindGARTMemory(pScrn);
#endif

   return ret;
d2432 2
a2433 2
static Bool
I830BIOSSaveScreen(ScreenPtr pScreen, int mode)
d2435 1
a2435 37
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   Bool on = xf86IsUnblank(mode);
   CARD32 temp, ctrl, base, i;

   DPRINTF(PFX, "I830BIOSSaveScreen: %d, on is %s\n", mode, BOOLTOSTRING(on));

   for (i = 0; i < MAX_DISPLAY_PIPES; i++) {
      if (i == 0) {
	 ctrl = DSPACNTR;
	 base = DSPABASE;
      } else {
	 ctrl = DSPBCNTR;
	 base = DSPBADDR;
      }
      if (pI830->planeEnabled[i]) {
	 temp = INREG(ctrl);
	 if (on)
	    temp |= DISPLAY_PLANE_ENABLE;
	 else
	    temp &= ~DISPLAY_PLANE_ENABLE;
	 OUTREG(ctrl, temp);
	 /* Flush changes */
	 temp = INREG(base);
	 OUTREG(base, temp);
      }
   }

   if (pI830->CursorInfoRec && !pI830->SWCursor && pI830->cursorOn) {
      if (on)
	 pI830->CursorInfoRec->ShowCursor(pScrn);
      else
	 pI830->CursorInfoRec->HideCursor(pScrn);
      pI830->cursorOn = TRUE;
   }

   return TRUE;
a2437 1
/* Use the VBE version when available. */
d2440 1
a2440 1
			      int flags)
d2442 2
a2443 2
   I830Ptr pI830 = I830PTR(pScrn);
   vbeInfoPtr pVbe = pI830->pVbe;
d2445 9
a2453 21
   if (xf86LoaderCheckSymbol("VBEDPMSSet")) {
      VBEDPMSSet(pVbe, PowerManagementMode);
   } else {
      pVbe->pInt10->num = 0x10;
      pVbe->pInt10->ax = 0x4f10;
      pVbe->pInt10->bx = 0x01;

      switch (PowerManagementMode) {
      case DPMSModeOn:
	 break;
      case DPMSModeStandby:
	 pVbe->pInt10->bx |= 0x0100;
	 break;
      case DPMSModeSuspend:
	 pVbe->pInt10->bx |= 0x0200;
	 break;
      case DPMSModeOff:
	 pVbe->pInt10->bx |= 0x0400;
	 break;
      }
      xf86ExecX86int10_wrapper(pVbe->pInt10, pScrn);
d2455 2
d2459 1
a2459 1
static Bool
d2463 4
a2466 2
   I830Ptr pI830 = I830PTR(pScrn);
   XAAInfoRecPtr infoPtr = pI830->AccelInfoRec;
a2467 1
   pI830->closing = TRUE;
d2469 3
a2471 3
   if (pI830->directRenderingOpen) {
      pI830->directRenderingOpen = FALSE;
      I830DRICloseScreen(pScreen);
d2476 9
a2484 1
      I830BIOSLeaveVT(scrnIndex, 0);
d2487 1
a2487 2
   DPRINTF(PFX, "\nUnmapping memory\n");
   I830UnmapMem(pScrn);
d2490 3
a2492 3
   if (pI830->ScanlineColorExpandBuffers) {
      xfree(pI830->ScanlineColorExpandBuffers);
      pI830->ScanlineColorExpandBuffers = 0;
d2495 3
a2497 3
   if (infoPtr) {
      if (infoPtr->ScanlineColorExpandBuffers)
	 xfree(infoPtr->ScanlineColorExpandBuffers);
d2499 1
a2499 1
      pI830->AccelInfoRec = NULL;
d2502 3
a2504 3
   if (pI830->CursorInfoRec) {
      xf86DestroyCursorInfoRec(pI830->CursorInfoRec);
      pI830->CursorInfoRec = 0;
d2507 6
d2515 3
a2517 77
   pScrn->vtSema = FALSE;
   pI830->closing = FALSE;
   pScreen->CloseScreen = pI830->CloseScreen;
   return (*pScreen->CloseScreen) (scrnIndex, pScreen);
}

static int
I830ValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
{
   if (mode->Flags & V_INTERLACE) {
      if (verbose) {
	 xf86DrvMsg(scrnIndex, X_PROBED,
		    "Removing interlaced mode \"%s\"\n", mode->name);
      }
      return MODE_BAD;
   }
   return MODE_OK;
}

#ifndef SUSPEND_SLEEP
#define SUSPEND_SLEEP 0
#endif
#ifndef RESUME_SLEEP
#define RESUME_SLEEP 0
#endif

/*
 * This function is only required if we need to do anything differently from
 * DoApmEvent() in common/xf86PM.c, including if we want to see events other
 * than suspend/resume.
 */
static Bool
I830PMEvent(int scrnIndex, pmEvent event, Bool undo)
{
   ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "Enter VT, event %d, undo: %s\n", event, BOOLTOSTRING(undo));

   switch(event) {
   case XF86_APM_SYS_SUSPEND:
   case XF86_APM_CRITICAL_SUSPEND: /*do we want to delay a critical suspend?*/
   case XF86_APM_USER_SUSPEND:
   case XF86_APM_SYS_STANDBY:
   case XF86_APM_USER_STANDBY:
      if (!undo && !pI830->suspended) {
	 pScrn->LeaveVT(scrnIndex, 0);
	 pI830->suspended = TRUE;
	 sleep(SUSPEND_SLEEP);
      } else if (undo && pI830->suspended) {
	 sleep(RESUME_SLEEP);
	 pScrn->EnterVT(scrnIndex, 0);
	 pI830->suspended = FALSE;
      }
      break;
   case XF86_APM_STANDBY_RESUME:
   case XF86_APM_NORMAL_RESUME:
   case XF86_APM_CRITICAL_RESUME:
      if (pI830->suspended) {
	 sleep(RESUME_SLEEP);
	 pScrn->EnterVT(scrnIndex, 0);
	 pI830->suspended = FALSE;
	 /*
	  * Turn the screen saver off when resuming.  This seems to be
	  * needed to stop xscreensaver kicking in (when used).
	  *
	  * XXX DoApmEvent() should probably call this just like
	  * xf86VTSwitch() does.  Maybe do it here only in 4.2
	  * compatibility mode.
	  */
	 SaveScreens(SCREEN_SAVER_FORCER, ScreenSaverReset);
      }
      break;
   default:
      ErrorF("I830PMEvent: received APM event %d\n", event);
   }
   return TRUE;
a2519 13
void
I830InitpScrn(ScrnInfoPtr pScrn)
{
   pScrn->PreInit = I830BIOSPreInit;
   pScrn->ScreenInit = I830BIOSScreenInit;
   pScrn->SwitchMode = I830BIOSSwitchMode;
   pScrn->AdjustFrame = I830BIOSAdjustFrame;
   pScrn->EnterVT = I830BIOSEnterVT;
   pScrn->LeaveVT = I830BIOSLeaveVT;
   pScrn->FreeScreen = I830BIOSFreeScreen;
   pScrn->ValidMode = I830ValidMode;
   pScrn->PMEvent = I830PMEvent;
}
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_driver.c,v 1.49 2004/01/25 16:57:48 dawes Exp $ */
d46 1
a46 1
 *          David Dawes <dawes@@xfree86.org>
d157 1
a157 1
#include "regionstr.h"
d205 2
a206 1
   OPTION_VBE_RESTORE
d218 2
a219 1
   {OPTION_VBE_RESTORE,	"VBERestore",	OPTV_BOOLEAN,	{0},	FALSE},
d233 3
a1068 87
/*
 * TweakMemorySize() tweaks the BIOS image to set the correct size.
 * Original implementation by Christian Zietz in a stand-alone tool.
 */
static CARD32
TweakMemorySize(ScrnInfoPtr pScrn, CARD32 newsize, Bool preinit)
{
#define SIZE 0x10000
#define IDOFFSET (-23)
    const char *MAGICstring = "Total time for VGA POST:";
    const int len = strlen(MAGICstring);
    I830Ptr pI830 = I830PTR(pScrn);
    char *position;
    char *biosAddr;
    CARD32 oldsize;
    CARD32 oldpermission;
    CARD32 ret = 0;
    int i,j = 0;
    PCITAG tag =pciTag(0,0,0);

    if(!pI830->PciInfo 
       || !(pI830->PciInfo->chipType == PCI_CHIP_I855_GM
	    || pI830->PciInfo->chipType == PCI_CHIP_I865_G))
	return 0;

    if (!pI830->pVbe)
	return 0;

    biosAddr = xf86int10Addr(pI830->pVbe->pInt10, 
				    pI830->pVbe->pInt10->BIOSseg << 4);

    if (!pI830->BIOSMemSizeLoc) {

	if (!preinit)
	    return 0;

	/* Search for MAGIC string */
	for (i = 0; i < SIZE; i++) {
	    if (biosAddr[i] == MAGICstring[j]) {
		if (++j == len)
		    break;
	    } else {
		i -= j;
		j = 0;
	    }
	}
	if (j < len) return 0;

	pI830->BIOSMemSizeLoc =  (i - j + 1 + IDOFFSET);
    }

    position = biosAddr + pI830->BIOSMemSizeLoc;
    oldsize = *(CARD32 *)position;
    ret = oldsize - (3 << 16);

    /* verify that register really contains current size */
    if (preinit && ((oldsize) >> 16) - 3 !=  pI830->vbeInfo->TotalMemory)
	return 0;

    oldpermission = pciReadLong(tag, DRAM_RW_CONTROL);
    pciWriteLong(tag, DRAM_RW_CONTROL, 0x33330000);

    *(CARD32 *)position = newsize + (3 << 16);
    if (preinit) {
	/* reinitialize VBE for new size */
	VBEFreeVBEInfo(pI830->vbeInfo);
	vbeFree(pI830->pVbe);
	pI830->pVbe = VBEInit(NULL, pI830->pEnt->index);
	pI830->vbeInfo = VBEGetVBEInfo(pI830->pVbe);

	/* verify that change was successful */
	if (pI830->vbeInfo->TotalMemory * 64 * 1024 != pI830->newBIOSMemSize) {
	    ret = 0;
	    *(CARD32 *)position = oldsize;
	} else {
	    pI830->BIOSMemorySize = KB(pI830->vbeInfo->TotalMemory * 64);
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		       "Tweak BIOS image to %d kB VideoRAM\n",
		       (int)(pI830->BIOSMemorySize / 1024));
	}
    }

     pciWriteLong(tag, DRAM_RW_CONTROL, oldpermission);

     return ret;
}

a1076 3
   if (TweakMemorySize(pScrn, pI830->saveBIOSMemSize,FALSE))
       return;

d1099 1
a1099 1
   unsigned long swf1;
d1115 1
a1115 1
      unsigned long newSWF1;
d1128 1
a1128 1
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Before: SWF1 is 0x%08lx\n", swf1);
d1131 1
a1131 1
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "After: SWF1 is 0x%08lx\n", swf1);
a1248 1
   pI830->SaveGeneration = -1;
d1461 1
a1461 1
		 "Detected stolen memory (%ld kB) doesn't match what the BIOS"
d1565 1
a1565 1

d1592 1
d1598 1
d1611 1
a1611 1
		       "BIOS now sees %ld kB VideoRAM\n",
d1613 4
a1616 7
 	 } else if ((pI830->saveBIOSMemSize 
 		  = TweakMemorySize(pScrn, pI830->newBIOSMemSize, TRUE)) != 0) 
 		 pI830->overrideBIOSMemSize = TRUE;
 	     else {
 		 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 			    "BIOS view of memory size can't be changed "
 			    "(this is not an error).\n");
d1621 1
a1621 3
   pVbe = pI830->pVbe;

   xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Pre-allocated VideoRAM: %ld kByte\n",
d1680 2
a1681 2
   /* Force ring buffer to be in low memory for the 845G and later. */
   if (IS_845G(pI830) || IS_I85X(pI830) || IS_I865G(pI830))
d1926 1
a1926 1
			     "\tmemory aperture size (%ld kB) by %ld kB.\n"
a1949 1
	 pI830->disableTiling = TRUE;
d1965 1
a1965 1
			     "\tmemory aperture size (%ld kB) by %ld kB.\n"
a2038 10
   /* Use the VBE mode restore workaround by default. */
   pI830->vbeRestoreWorkaround = TRUE;
   from = X_DEFAULT;
   if (xf86ReturnOptValBool(pI830->Options, OPTION_VBE_RESTORE, FALSE)) {
      pI830->vbeRestoreWorkaround = FALSE;
      from = X_CONFIG;
   }
   xf86DrvMsg(pScrn->scrnIndex, from, "VBE Restore workaround: %s.\n",
	      pI830->vbeRestoreWorkaround ? "enabled" : "disabled");
      
a2039 8
   /* Load the dri module if requested. */
   if (xf86ReturnOptValBool(pI830->Options, OPTION_DRI, FALSE) &&
       !pI830->directRenderingDisabled) {
      if (xf86LoadSubModule(pScrn, "dri")) {
	 xf86LoaderReqSymLists(I810driSymbols, I810drmSymbols, NULL);
      }
   }

d2066 1
a2066 1
      xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "PGTBL_ER is 0x%08lx\n", temp);
d2072 1
a2072 1
		 "PGTBL_CTL (0x%08lx) indicates GTT is disabled\n", temp);
d2078 1
a2078 1
		 "PRB0_CTL (0x%08lx) indicates ring buffer enabled\n", temp);
d2085 1
a2085 1
		 "PRB0_HEAD (0x%08lx) and PRB0_TAIL (0x%08lx) indicate "
d2170 1
a2170 1
		 "I830SetRingRegs: Ring buffer start (%lx) violates its "
d2180 1
a2180 1
		 "I830SetRingRegs: Ring buffer size - 4096 (%lx) violates its "
d2236 4
d2241 1
d2243 2
a2244 4
    * This save/restore method doesn't work for 845G BIOS, or for some
    * other platforms.  Enable it in all cases.
    */
   /*
d2250 1
a2250 1
   if (!pI830->vbeRestoreWorkaround) {
a2445 16
    * Test if the extendedRefresh BIOS function is supported.
    */
   if (pI830->useExtendedRefresh && !pI830->vesa->useDefaultRefresh &&
       (mode & (1 << 11)) && data && data->data && data->block) {
      if (!SetRefreshRate(pScrn, mode, 60)) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "BIOS call 0x5f05 not supported, "
		    "setting refresh with VBE 3 method.\n");
	 pI830->useExtendedRefresh = FALSE;
	 pI830->enableDisplays = FALSE;
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "Not using BIOS call 0x5f64 to enable displays.\n");
      }
   }

   /*
d2549 1
a2549 1
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PIPEACONF is 0x%08lx\n", temp);
d2552 1
a2552 1
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PIPEBCONF is 0x%08lx\n", temp);
d2597 1
a2597 1
		    (int)(temp / pI830->cpp), pScrn->displayWidth);
d2895 1
a2895 2
   if (!TweakMemorySize(pScrn, pI830->newBIOSMemSize,FALSE))
       SetBIOSMemSize(pScrn, pI830->newBIOSMemSize);
d2994 2
a2995 5
   if (pI830->directRenderingEnabled) {
      pI830->directRenderingEnabled =
	 I830Allocate3DMemory(pScrn,
			      pI830->disableTiling ? ALLOC_NO_TILING : 0);
      if (!pI830->directRenderingEnabled)
a2996 1
   }
a3029 3
   pI830->xoffset = (pScrn->fbOffset / pI830->cpp) % pScrn->displayWidth;
   pI830->yoffset = (pScrn->fbOffset / pI830->cpp) / pScrn->displayWidth;

d3111 1
d3113 1
d3167 2
d3175 8
a3182 1
	   x, pI830->xoffset, y, pI830->yoffset);
d3184 11
a3194 1
   VBESetDisplayStart(pVbe, x + pI830->xoffset, y + pI830->yoffset, TRUE);
d3237 1
d3239 1
a3259 2
   if (pI830->AccelInfoRec)
      pI830->AccelInfoRec->NeedToSync = FALSE;
d3270 1
d3278 1
a3278 2
   if (!TweakMemorySize(pScrn, pI830->newBIOSMemSize,FALSE))
       SetBIOSMemSize(pScrn, pI830->newBIOSMemSize);
d3284 2
a3285 2
   if (pI830->SaveGeneration != serverGeneration) {
      pI830->SaveGeneration = serverGeneration;
d3351 5
d3389 7
a3395 20
   if (pScrn->vtSema) {
      for (i = 0; i < MAX_DISPLAY_PIPES; i++) {
	 if (i == 0) {
	    ctrl = DSPACNTR;
	    base = DSPABASE;
	 } else {
	    ctrl = DSPBCNTR;
	    base = DSPBADDR;
	 }
	 if (pI830->planeEnabled[i]) {
	    temp = INREG(ctrl);
	    if (on)
	       temp |= DISPLAY_PLANE_ENABLE;
	    else
	       temp &= ~DISPLAY_PLANE_ENABLE;
	    OUTREG(ctrl, temp);
	    /* Flush changes */
	    temp = INREG(base);
	    OUTREG(base, temp);
	 }
d3397 2
a3398 2

      if (pI830->CursorInfoRec && !pI830->SWCursor && pI830->cursorOn) {
d3400 1
a3400 1
	    pI830->CursorInfoRec->ShowCursor(pScrn);
d3402 5
a3406 2
	    pI830->CursorInfoRec->HideCursor(pScrn);
	 pI830->cursorOn = TRUE;
d3409 9
d3501 1
a3501 1
static ModeStatus
a3586 2


@


1.1.1.4
log
@Import OpenBSD X-Window subsystem (based upon XFree86 4.4RC2)
into vendor branch
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_driver.c,v 1.51 2004/02/25 12:53:14 eich Exp $ */
d205 1
a205 2
   OPTION_VBE_RESTORE,
   OPTION_DISPLAY_INFO
a217 1
   {OPTION_DISPLAY_INFO,"DisplayInfo",	OPTV_BOOLEAN,	{0},	FALSE},
d791 3
a793 10
   
   /* This seems to lockup some Dell BIOS'. So it's on option to turn on */
   if (pI830->displayInfo) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		  "Broken BIOSes cause the system to hang here.\n"
		  "\t      If you encounter this problem please add \n"
		  "\t\t Option \"DisplayInfo\" \"FALSE\"\n"
		  "\t      to the Device section of your XF86Config file.\n");
      for (i = 0; i < NumKnownDisplayTypes; i++) {
         if (GetDisplayInfo(pScrn, 1 << i, &pI830->displayAttached[i],
d797 1
a797 1
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
a802 1
         }
a1815 9

   pI830->displayInfo = TRUE;
   from = X_DEFAULT;
   if (!xf86ReturnOptValBool(pI830->Options, OPTION_DISPLAY_INFO, TRUE)) {
      from = X_CONFIG;
      pI830->displayInfo = FALSE;
   }
   xf86DrvMsg(pScrn->scrnIndex, from, "Display Info: %s.\n",
	      pI830->displayInfo ? "enabled" : "disabled");
@


