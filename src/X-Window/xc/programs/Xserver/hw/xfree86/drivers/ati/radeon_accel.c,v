head	1.2;
access;
symbols
	tg-mergetmp-2:1.2
	cvs-200410241530:1.1.1.4
	cvs-200410012000:1.1.1.4
	cvs-200407221130:1.1.1.4
	cvs-200407141120:1.1.1.4
	cvs-200406231010:1.1.1.4
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.4
	XFree86_4_4_0:1.1.9.2
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.03.07.18.36.08;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.20.06.58;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.06.58;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.36.03;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.16.37;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.27.16.31.29;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.22.56;	author tg;	state Exp;
branches;
next	1.1.9.2;

1.1.9.2
date	2004.03.05.22.26.59;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@semi-automagic merge of these files (ie, I've skipped through the diffs,
and most of that was done by cvs or that weird script of some minutes ago)
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c,v 1.37 2004/02/19 22:38:12 tsi Exp $ */
/*
 * Copyright 2000 ATI Technologies Inc., Markham, Ontario, and
 *                VA Linux Systems Inc., Fremont, California.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL ATI, VA LINUX SYSTEMS AND/OR
 * THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*
 * Authors:
 *   Kevin E. Martin <martin@@xfree86.org>
 *   Rickard E. Faith <faith@@valinux.com>
 *   Alan Hourihane <alanh@@fairlite.demon.co.uk>
 *
 * Credits:
 *
 *   Thanks to Ani Joshi <ajoshi@@shell.unixbox.com> for providing source
 *   code to his Radeon driver.  Portions of this file are based on the
 *   initialization code for that driver.
 *
 * References:
 *
 * !!!! FIXME !!!!
 *   RAGE 128 VR/ RAGE 128 GL Register Reference Manual (Technical
 *   Reference Manual P/N RRG-G04100-C Rev. 0.04), ATI Technologies: April
 *   1999.
 *
 *   RAGE 128 Software Development Manual (Technical Reference Manual P/N
 *   SDK-G04000 Rev. 0.01), ATI Technologies: June 1999.
 *
 * Notes on unimplemented XAA optimizations:
 *
 *   SetClipping:   This has been removed as XAA expects 16bit registers
 *                  for full clipping.
 *   TwoPointLine:  The Radeon supports this. Not Bresenham.
 *   DashedLine with non-power-of-two pattern length: Apparently, there is
 *                  no way to set the length of the pattern -- it is always
 *                  assumed to be 8 or 32 (or 1024?).
 *   ScreenToScreenColorExpandFill: See p. 4-17 of the Technical Reference
 *                  Manual where it states that monochrome expansion of frame
 *                  buffer data is not supported.
 *   CPUToScreenColorExpandFill, direct: The implementation here uses a hybrid
 *                  direct/indirect method.  If we had more data registers,
 *                  then we could do better.  If XAA supported a trigger write
 *                  address, the code would be simpler.
 *   Color8x8PatternFill: Apparently, an 8x8 color brush cannot take an 8x8
 *                  pattern from frame buffer memory.
 *   ImageWrites:   Same as CPUToScreenColorExpandFill
 *
 */

				/* Driver data structures */
#include "radeon.h"
#include "radeon_macros.h"
#include "radeon_probe.h"
#include "radeon_reg.h"
#include "radeon_version.h"
#ifdef XF86DRI
#define _XF86DRI_SERVER_
#include "radeon_dri.h"
#include "radeon_sarea.h"
#endif

				/* Line support */
#include "miline.h"

				/* X and server generic header files */
#include "xf86.h"

static struct {
    int rop;
    int pattern;
} RADEON_ROP[] = {
    { RADEON_ROP3_ZERO, RADEON_ROP3_ZERO }, /* GXclear        */
    { RADEON_ROP3_DSa,  RADEON_ROP3_DPa  }, /* Gxand          */
    { RADEON_ROP3_SDna, RADEON_ROP3_PDna }, /* GXandReverse   */
    { RADEON_ROP3_S,    RADEON_ROP3_P    }, /* GXcopy         */
    { RADEON_ROP3_DSna, RADEON_ROP3_DPna }, /* GXandInverted  */
    { RADEON_ROP3_D,    RADEON_ROP3_D    }, /* GXnoop         */
    { RADEON_ROP3_DSx,  RADEON_ROP3_DPx  }, /* GXxor          */
    { RADEON_ROP3_DSo,  RADEON_ROP3_DPo  }, /* GXor           */
    { RADEON_ROP3_DSon, RADEON_ROP3_DPon }, /* GXnor          */
    { RADEON_ROP3_DSxn, RADEON_ROP3_PDxn }, /* GXequiv        */
    { RADEON_ROP3_Dn,   RADEON_ROP3_Dn   }, /* GXinvert       */
    { RADEON_ROP3_SDno, RADEON_ROP3_PDno }, /* GXorReverse    */
    { RADEON_ROP3_Sn,   RADEON_ROP3_Pn   }, /* GXcopyInverted */
    { RADEON_ROP3_DSno, RADEON_ROP3_DPno }, /* GXorInverted   */
    { RADEON_ROP3_DSan, RADEON_ROP3_DPan }, /* GXnand         */
    { RADEON_ROP3_ONE,  RADEON_ROP3_ONE  }  /* GXset          */
};

extern int gRADEONEntityIndex;

/* The FIFO has 64 slots.  This routines waits until at least `entries'
 * of these slots are empty.
 */
void RADEONWaitForFifoFunction(ScrnInfoPtr pScrn, int entries)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int            i;

    for (;;) {
	for (i = 0; i < RADEON_TIMEOUT; i++) {
	    info->fifo_slots =
		INREG(RADEON_RBBM_STATUS) & RADEON_RBBM_FIFOCNT_MASK;
	    if (info->fifo_slots >= entries) return;
	}
	RADEONTRACE(("FIFO timed out: %d entries, stat=0x%08x\n",
		     INREG(RADEON_RBBM_STATUS) & RADEON_RBBM_FIFOCNT_MASK,
		     INREG(RADEON_RBBM_STATUS)));
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "FIFO timed out, resetting engine...\n");
	RADEONEngineReset(pScrn);
	RADEONEngineRestore(pScrn);
#ifdef XF86DRI
	if (info->directRenderingEnabled) {
	    RADEONCP_RESET(pScrn, info);
	    RADEONCP_START(pScrn, info);
	}
#endif
    }
}

/* Flush all dirty data in the Pixel Cache to memory */
void RADEONEngineFlush(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int            i;

    OUTREGP(RADEON_RB2D_DSTCACHE_CTLSTAT,
	    RADEON_RB2D_DC_FLUSH_ALL,
	    ~RADEON_RB2D_DC_FLUSH_ALL);
    for (i = 0; i < RADEON_TIMEOUT; i++) {
	if (!(INREG(RADEON_RB2D_DSTCACHE_CTLSTAT) & RADEON_RB2D_DC_BUSY))
	    break;
    }
}

/* Reset graphics card to known state */
void RADEONEngineReset(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    CARD32         clock_cntl_index;
    CARD32         mclk_cntl;
    CARD32         rbbm_soft_reset;
    CARD32         host_path_cntl;

    RADEONEngineFlush(pScrn);

    clock_cntl_index = INREG(RADEON_CLOCK_CNTL_INDEX);
    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);

    /* Some ASICs have bugs with dynamic-on feature, which are
     * ASIC-version dependent, so we force all blocks on for now
     */
    if (info->HasCRTC2) {
	CARD32 tmp;

	tmp = INPLL(pScrn, RADEON_SCLK_CNTL);
	OUTPLL(RADEON_SCLK_CNTL, ((tmp & ~RADEON_DYN_STOP_LAT_MASK) |
				  RADEON_CP_MAX_DYN_STOP_LAT |
				  RADEON_SCLK_FORCEON_MASK));

	if (info->ChipFamily == CHIP_FAMILY_RV200) {
	    tmp = INPLL(pScrn, RADEON_SCLK_MORE_CNTL);
	    OUTPLL(RADEON_SCLK_MORE_CNTL, tmp | RADEON_SCLK_MORE_FORCEON);
	}
    }

    mclk_cntl = INPLL(pScrn, RADEON_MCLK_CNTL);
    OUTPLL(RADEON_MCLK_CNTL, (mclk_cntl |
			      RADEON_FORCEON_MCLKA |
			      RADEON_FORCEON_MCLKB |
			      RADEON_FORCEON_YCLKA |
			      RADEON_FORCEON_YCLKB |
			      RADEON_FORCEON_MC |
			      RADEON_FORCEON_AIC));

    /* Soft resetting HDP thru RBBM_SOFT_RESET register can cause some
     * unexpected behaviour on some machines.  Here we use
     * RADEON_HOST_PATH_CNTL to reset it.
     */
    host_path_cntl = INREG(RADEON_HOST_PATH_CNTL);
    rbbm_soft_reset = INREG(RADEON_RBBM_SOFT_RESET);

    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {
	CARD32 tmp;

	OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset |
					RADEON_SOFT_RESET_CP |
					RADEON_SOFT_RESET_HI |
					RADEON_SOFT_RESET_E2));
	INREG(RADEON_RBBM_SOFT_RESET);
	OUTREG(RADEON_RBBM_SOFT_RESET, 0);
	tmp = INREG(RADEON_RB2D_DSTCACHE_MODE);
	OUTREG(RADEON_RB2D_DSTCACHE_MODE, tmp | (1 << 17)); /* FIXME */
    } else {
	OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset |
					RADEON_SOFT_RESET_CP |
					RADEON_SOFT_RESET_HI |
					RADEON_SOFT_RESET_SE |
					RADEON_SOFT_RESET_RE |
					RADEON_SOFT_RESET_PP |
					RADEON_SOFT_RESET_E2 |
					RADEON_SOFT_RESET_RB));
	INREG(RADEON_RBBM_SOFT_RESET);
	OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset & (CARD32)
					~(RADEON_SOFT_RESET_CP |
					  RADEON_SOFT_RESET_HI |
					  RADEON_SOFT_RESET_SE |
					  RADEON_SOFT_RESET_RE |
					  RADEON_SOFT_RESET_PP |
					  RADEON_SOFT_RESET_E2 |
					  RADEON_SOFT_RESET_RB)));
	INREG(RADEON_RBBM_SOFT_RESET);
    }

    OUTREG(RADEON_HOST_PATH_CNTL, host_path_cntl | RADEON_HDP_SOFT_RESET);
    INREG(RADEON_HOST_PATH_CNTL);
    OUTREG(RADEON_HOST_PATH_CNTL, host_path_cntl);

    if ((info->ChipFamily != CHIP_FAMILY_R300) &&
        (info->ChipFamily != CHIP_FAMILY_R350) &&
        (info->ChipFamily != CHIP_FAMILY_RV350))
	OUTREG(RADEON_RBBM_SOFT_RESET, rbbm_soft_reset);

    OUTREG(RADEON_CLOCK_CNTL_INDEX, clock_cntl_index);
    OUTPLL(RADEON_MCLK_CNTL, mclk_cntl);
    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);
}

/* Restore the acceleration hardware to its previous state */
void RADEONEngineRestore(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int            pitch64;

    RADEONTRACE(("EngineRestore (%d/%d)\n",
		 info->CurrentLayout.pixel_code,
		 info->CurrentLayout.bitsPerPixel));

    RADEONWaitForFifo(pScrn, 1);

    /* NOTE: The following RB2D_DSTCACHE_MODE setting will cause the
     * R300 to hang.  ATI does not see a reason to change it from the
     * default BIOS settings (even on non-R300 cards).  This setting
     * might be removed in future versions of the Radeon driver.
     */

    /* Turn of all automatic flushing - we'll do it all */
    if ((info->ChipFamily != CHIP_FAMILY_R300) &&
	(info->ChipFamily != CHIP_FAMILY_R350) &&
	(info->ChipFamily != CHIP_FAMILY_RV350))
	OUTREG(RADEON_RB2D_DSTCACHE_MODE, 0);

    pitch64 = ((pScrn->displayWidth * (pScrn->bitsPerPixel / 8) + 0x3f)) >> 6;

    RADEONWaitForFifo(pScrn, 1);
    OUTREG(RADEON_DEFAULT_OFFSET, ((INREG(RADEON_DISPLAY_BASE_ADDR) >> 10)
				   | (pitch64 << 22)));

    RADEONWaitForFifo(pScrn, 1);
#if X_BYTE_ORDER == X_BIG_ENDIAN
    OUTREGP(RADEON_DP_DATATYPE,
	    RADEON_HOST_BIG_ENDIAN_EN,
	    ~RADEON_HOST_BIG_ENDIAN_EN);
#else
    OUTREGP(RADEON_DP_DATATYPE, 0, ~RADEON_HOST_BIG_ENDIAN_EN);
#endif

    /* Restore SURFACE_CNTL - only the first head contains valid data -ReneR */
    if (!info->IsSecondary) {
	OUTREG(RADEON_SURFACE_CNTL, info->ModeReg.surface_cntl);
    }

    RADEONWaitForFifo(pScrn, 1);
    OUTREG(RADEON_DEFAULT_SC_BOTTOM_RIGHT, (RADEON_DEFAULT_SC_RIGHT_MAX
					    | RADEON_DEFAULT_SC_BOTTOM_MAX));
    RADEONWaitForFifo(pScrn, 1);
    OUTREG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl
				       | RADEON_GMC_BRUSH_SOLID_COLOR
				       | RADEON_GMC_SRC_DATATYPE_COLOR));

    RADEONWaitForFifo(pScrn, 7);
    OUTREG(RADEON_DST_LINE_START,    0);
    OUTREG(RADEON_DST_LINE_END,      0);
    OUTREG(RADEON_DP_BRUSH_FRGD_CLR, 0xffffffff);
    OUTREG(RADEON_DP_BRUSH_BKGD_CLR, 0x00000000);
    OUTREG(RADEON_DP_SRC_FRGD_CLR,   0xffffffff);
    OUTREG(RADEON_DP_SRC_BKGD_CLR,   0x00000000);
    OUTREG(RADEON_DP_WRITE_MASK,     0xffffffff);

    RADEONWaitForIdleMMIO(pScrn);
}

/* Initialize the acceleration hardware */
void RADEONEngineInit(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    RADEONTRACE(("EngineInit (%d/%d)\n",
		 info->CurrentLayout.pixel_code,
		 info->CurrentLayout.bitsPerPixel));

    OUTREG(RADEON_RB3D_CNTL, 0);
#if defined(__powerpc__)
#if defined(XF86_DRI)
    if(!info->directRenderingEnabled)
#endif
    {
	OUTREG(RADEON_MC_FB_LOCATION, 0xffff0000);
	OUTREG(RADEON_MC_AGP_LOCATION, 0xfffff000);
    }
#endif

    RADEONEngineReset(pScrn);

    switch (info->CurrentLayout.pixel_code) {
    case 8:  info->datatype = 2; break;
    case 15: info->datatype = 3; break;
    case 16: info->datatype = 4; break;
    case 24: info->datatype = 5; break;
    case 32: info->datatype = 6; break;
    default:
	RADEONTRACE(("Unknown depth/bpp = %d/%d (code = %d)\n",
		     info->CurrentLayout.depth,
		     info->CurrentLayout.bitsPerPixel,
		     info->CurrentLayout.pixel_code));
    }
    info->pitch = ((info->CurrentLayout.displayWidth / 8) *
		   (info->CurrentLayout.pixel_bytes == 3 ? 3 : 1));

    RADEONTRACE(("Pitch for acceleration = %d\n", info->pitch));

    info->dp_gui_master_cntl =
	((info->datatype << RADEON_GMC_DST_DATATYPE_SHIFT)
	 | RADEON_GMC_CLR_CMP_CNTL_DIS);

#ifdef XF86DRI
    info->sc_left         = 0x00000000;
    info->sc_right        = RADEON_DEFAULT_SC_RIGHT_MAX;
    info->sc_top          = 0x00000000;
    info->sc_bottom       = RADEON_DEFAULT_SC_BOTTOM_MAX;

    info->re_top_left     = 0x00000000;
    info->re_width_height = ((0x7ff << RADEON_RE_WIDTH_SHIFT) |
			     (0x7ff << RADEON_RE_HEIGHT_SHIFT));

    info->aux_sc_cntl     = 0x00000000;
#endif

    RADEONEngineRestore(pScrn);
}

#define ACCEL_MMIO
#define ACCEL_PREAMBLE()        unsigned char *RADEONMMIO = info->MMIO
#define BEGIN_ACCEL(n)          RADEONWaitForFifo(pScrn, (n))
#define OUT_ACCEL_REG(reg, val) OUTREG(reg, val)
#define FINISH_ACCEL()

#include "radeon_accelfuncs.c"

#undef ACCEL_MMIO
#undef ACCEL_PREAMBLE
#undef BEGIN_ACCEL
#undef OUT_ACCEL_REG
#undef FINISH_ACCEL

#ifdef XF86DRI

#define ACCEL_CP
#define ACCEL_PREAMBLE()						\
    RING_LOCALS;							\
    RADEONCP_REFRESH(pScrn, info)
#define BEGIN_ACCEL(n)          BEGIN_RING(2*(n))
#define OUT_ACCEL_REG(reg, val) OUT_RING_REG(reg, val)
#define FINISH_ACCEL()          ADVANCE_RING()

#include "radeon_accelfuncs.c"

#undef ACCEL_CP
#undef ACCEL_PREAMBLE
#undef BEGIN_ACCEL
#undef OUT_ACCEL_REG
#undef FINISH_ACCEL

/* Stop the CP */
int RADEONCPStop(ScrnInfoPtr pScrn, RADEONInfoPtr info)
{
    drmRadeonCPStop  stop;
    int              ret, i;

    stop.flush = 1;
    stop.idle  = 1;

    ret = drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP, &stop,
			  sizeof(drmRadeonCPStop));

    if (ret == 0) {
	return 0;
    } else if (errno != EBUSY) {
	return -errno;
    }

    stop.flush = 0;

    i = 0;
    do {
	ret = drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP, &stop,
			      sizeof(drmRadeonCPStop));
    } while (ret && errno == EBUSY && i++ < RADEON_IDLE_RETRY);

    if (ret == 0) {
	return 0;
    } else if (errno != EBUSY) {
	return -errno;
    }

    stop.idle = 0;

    if (drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP,
			&stop, sizeof(drmRadeonCPStop))) {
	return -errno;
    } else {
	return 0;
    }
}

/* Get an indirect buffer for the CP 2D acceleration commands  */
drmBufPtr RADEONCPGetBuffer(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    drmDMAReq      dma;
    drmBufPtr      buf = NULL;
    int            indx = 0;
    int            size = 0;
    int            i = 0;
    int            ret;

#if 0
    /* FIXME: pScrn->pScreen has not been initialized when this is first
     * called from RADEONSelectBuffer via RADEONDRICPInit.  We could use
     * the screen index from pScrn, which is initialized, and then get
     * the screen from screenInfo.screens[index], but that is a hack.
     */
    dma.context = DRIGetContext(pScrn->pScreen);
#else
    /* This is the X server's context */
    dma.context = 0x00000001;
#endif

    dma.send_count    = 0;
    dma.send_list     = NULL;
    dma.send_sizes    = NULL;
    dma.flags         = 0;
    dma.request_count = 1;
    dma.request_size  = RADEON_BUFFER_SIZE;
    dma.request_list  = &indx;
    dma.request_sizes = &size;
    dma.granted_count = 0;

    while (1) {
	do {
	    ret = drmDMA(info->drmFD, &dma);
	    if (ret && ret != -EBUSY) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "%s: CP GetBuffer %d\n", __FUNCTION__, ret);
	    }
	} while ((ret == -EBUSY) && (i++ < RADEON_TIMEOUT));

	if (ret == 0) {
	    buf = &info->buffers->list[indx];
	    buf->used = 0;
	    if (RADEON_VERBOSE) {
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "   GetBuffer returning %d %p\n",
			   buf->idx, buf->address);
	    }
	    return buf;
	}

	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "GetBuffer timed out, resetting engine...\n");
	RADEONEngineReset(pScrn);
	RADEONEngineRestore(pScrn);

	/* Always restart the engine when doing CP 2D acceleration */
	RADEONCP_RESET(pScrn, info);
	RADEONCP_START(pScrn, info);
    }
}

/* Flush the indirect buffer to the kernel for submission to the card */
void RADEONCPFlushIndirect(ScrnInfoPtr pScrn, int discard)
{
    RADEONInfoPtr      info   = RADEONPTR(pScrn);
    drmBufPtr          buffer = info->indirectBuffer;
    int                start  = info->indirectStart;
    drmRadeonIndirect  indirect;

    if (!buffer) return;
    if (start == buffer->used && !discard) return;

    if (RADEON_VERBOSE) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Flushing buffer %d\n",
		   buffer->idx);
    }

    indirect.idx     = buffer->idx;
    indirect.start   = start;
    indirect.end     = buffer->used;
    indirect.discard = discard;

    drmCommandWriteRead(info->drmFD, DRM_RADEON_INDIRECT,
			&indirect, sizeof(drmRadeonIndirect));

    if (discard) {
	info->indirectBuffer = RADEONCPGetBuffer(pScrn);
	info->indirectStart  = 0;
    } else {
	/* Start on a double word boundary */
	info->indirectStart  = buffer->used = (buffer->used + 7) & ~7;
	if (RADEON_VERBOSE) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "   Starting at %d\n",
		       info->indirectStart);
	}
    }
}

/* Flush and release the indirect buffer */
void RADEONCPReleaseIndirect(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr      info   = RADEONPTR(pScrn);
    drmBufPtr          buffer = info->indirectBuffer;
    int                start  = info->indirectStart;
    drmRadeonIndirect  indirect;

    info->indirectBuffer = NULL;
    info->indirectStart  = 0;

    if (!buffer) return;

    if (RADEON_VERBOSE) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Releasing buffer %d\n",
		   buffer->idx);
    }

    indirect.idx     = buffer->idx;
    indirect.start   = start;
    indirect.end     = buffer->used;
    indirect.discard = 1;

    drmCommandWriteRead(info->drmFD, DRM_RADEON_INDIRECT,
			&indirect, sizeof(drmRadeonIndirect));
}
#endif

/* Initialize XAA for supported acceleration and also initialize the
 * graphics hardware for acceleration
 */
Bool RADEONAccelInit(ScreenPtr pScreen)
{
    ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
    RADEONInfoPtr  info  = RADEONPTR(pScrn);
    XAAInfoRecPtr  a;

    if (!(a = info->accel = XAACreateInfoRec())) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "XAACreateInfoRec Error\n");
	return FALSE;
    }

#ifdef XF86DRI
    if (info->directRenderingEnabled)
	RADEONAccelInitCP(pScreen, a);
    else
#endif
	RADEONAccelInitMMIO(pScreen, a);

    RADEONEngineInit(pScrn);

    if (!XAAInit(pScreen, a)) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "XAAInit Error\n");
	return FALSE;
    }

    return TRUE;
}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c,v 1.23 2001/11/24 14:38:19 tsi Exp $ */
d32 1
a32 1
 *   Kevin E. Martin <martin@@valinux.com>
d34 1
a34 1
 *   Alan Hourihane <ahourihane@@valinux.com>
d75 1
d115 3
a117 2
/* The FIFO has 64 slots.  This routines waits until at least `entries' of
   these slots are empty. */
d120 1
a120 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d122 1
a122 1
    int           i;
a137 1
	RADEONCP_RESET(pScrn, info);
d139 1
d146 1
a146 74
/* Wait for the graphics engine to be completely idle: the FIFO has
   drained, the Pixel Cache is flushed, and the engine is idle.  This is a
   standard "sync" function that will make the hardware "quiescent". */
void RADEONWaitForIdle(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int           i;

    RADEONTRACE(("WaitForIdle (entering): %d entries, stat=0x%08x\n",
		     INREG(RADEON_RBBM_STATUS) & RADEON_RBBM_FIFOCNT_MASK,
		     INREG(RADEON_RBBM_STATUS)));

    RADEONWaitForFifoFunction(pScrn, 64);

    for (;;) {
	for (i = 0; i < RADEON_TIMEOUT; i++) {
	    if (!(INREG(RADEON_RBBM_STATUS) & RADEON_RBBM_ACTIVE)) {
		RADEONEngineFlush(pScrn);
		return;
	    }
	}
	RADEONTRACE(("Idle timed out: %d entries, stat=0x%08x\n",
		     INREG(RADEON_RBBM_STATUS) & RADEON_RBBM_FIFOCNT_MASK,
		     INREG(RADEON_RBBM_STATUS)));
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Idle timed out, resetting engine...\n");
	RADEONEngineReset(pScrn);
	RADEONEngineRestore(pScrn);
#ifdef XF86DRI
	RADEONCP_RESET(pScrn, info);
	if (info->directRenderingEnabled) {
	    RADEONCP_START(pScrn, info);
	}
#endif
    }
}

#ifdef XF86DRI
/* Wait until the CP is completely idle: the FIFO has drained and the
 * CP is idle.
 */
static void RADEONCPWaitForIdle(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    int         ret;
    int         i    = 0;

    FLUSH_RING();

    for (;;) {
	do {
	    ret = drmRadeonWaitForIdleCP(info->drmFD);
	    if (ret && ret != -EBUSY) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "%s: CP idle %d\n", __FUNCTION__, ret);
	    }
	} while ((ret == -EBUSY) && (i++ < RADEON_TIMEOUT));

	if (ret == 0) return;

	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Idle timed out, resetting engine...\n");
	RADEONEngineReset(pScrn);
	RADEONEngineRestore(pScrn);

	/* Always restart the engine when doing CP 2D acceleration */
	RADEONCP_RESET(pScrn, info);
	RADEONCP_START(pScrn, info);
    }
}
#endif

/* Flush all dirty data in the Pixel Cache to memory. */
d149 1
a149 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d151 1
a151 1
    int           i;
d153 3
a155 2
    OUTREGP(RADEON_RB2D_DSTCACHE_CTLSTAT, RADEON_RB2D_DC_FLUSH_ALL,
						~RADEON_RB2D_DC_FLUSH_ALL);
d157 2
a158 1
	if (!(INREG(RADEON_RB2D_DSTCACHE_CTLSTAT) & RADEON_RB2D_DC_BUSY)) break;
d162 1
a162 1
/* Reset graphics card to known state. */
d165 1
a165 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d167 4
a170 4
    CARD32        clock_cntl_index;
    CARD32        mclk_cntl;
    CARD32        rbbm_soft_reset;
    CARD32        host_path_cntl;
d175 18
a192 1
    mclk_cntl        = INPLL(pScrn, RADEON_MCLK_CNTL);
d194 1
d203 40
a242 25
    /*Soft resetting HDP thru RBBM_SOFT_RESET register can
      cause some unexpected behaviour on some machines.
      Here we use RADEON_HOST_PATH_CNTL to reset it.*/ 
    host_path_cntl   = INREG(RADEON_HOST_PATH_CNTL);

    rbbm_soft_reset   = INREG(RADEON_RBBM_SOFT_RESET);

    OUTREG(RADEON_RBBM_SOFT_RESET, rbbm_soft_reset |
				   RADEON_SOFT_RESET_CP |
				   RADEON_SOFT_RESET_HI |
				   RADEON_SOFT_RESET_SE |
				   RADEON_SOFT_RESET_RE |
				   RADEON_SOFT_RESET_PP |
				   RADEON_SOFT_RESET_E2 |
				   RADEON_SOFT_RESET_RB );
    INREG(RADEON_RBBM_SOFT_RESET);
    OUTREG(RADEON_RBBM_SOFT_RESET, rbbm_soft_reset & (CARD32)
				 ~(RADEON_SOFT_RESET_CP |
				   RADEON_SOFT_RESET_HI |
				   RADEON_SOFT_RESET_SE |
				   RADEON_SOFT_RESET_RE |
				   RADEON_SOFT_RESET_PP |
				   RADEON_SOFT_RESET_E2 |
				   RADEON_SOFT_RESET_RB ));
    INREG(RADEON_RBBM_SOFT_RESET);
d248 4
a251 1
    OUTREG(RADEON_RBBM_SOFT_RESET,  rbbm_soft_reset);
d254 2
a255 2
    OUTPLL(RADEON_MCLK_CNTL,        mclk_cntl);

d258 1
a258 1
/* Restore the acceleration hardware to its previous state. */
d261 1
a261 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d263 1
a263 1
    int           pitch64;
d270 12
a281 2
    /* turn of all automatic flushing - we'll do it all */
    OUTREG(RADEON_RB2D_DSTCACHE_MODE, 0);
d286 2
a287 2
    OUTREG(RADEON_DEFAULT_OFFSET, (INREG(RADEON_DEFAULT_OFFSET) & 0xC0000000) |
				  (pitch64 << 22));
d292 2
a293 1
	    RADEON_HOST_BIG_ENDIAN_EN, ~RADEON_HOST_BIG_ENDIAN_EN);
d298 4
a301 2
    /* restore SURFACE_CNTL */
    OUTREG(RADEON_SURFACE_CNTL, info->ModeReg.surface_cntl);
d320 1
a320 1
    RADEONWaitForIdle(pScrn);
d323 2
a324 3
/* This callback is required for multiheader cards using XAA */
static
void RADEONRestoreAccelState(ScrnInfoPtr pScrn)
d326 1
a326 58
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    CARD32 pitch64;
    RADEONEntPtr pRADEONEnt;
    DevUnion* pPriv;

    pPriv = xf86GetEntityPrivate(pScrn->entityList[0],
            gRADEONEntityIndex);
    pRADEONEnt = pPriv->ptr;
    if(pRADEONEnt->IsDRIEnabled)
    {
        /*not working yet*/
        /*
        RADEONInfoPtr info0 = RADEONPTR(pRADEONEnt->pPrimaryScrn);
        RADEONCP_TO_MMIO(pRADEONEnt->pPrimaryScrn, info0);
        */
    }
    pitch64 = ((pScrn->displayWidth * (pScrn->bitsPerPixel / 8) + 0x3f)) >> 6;

    OUTREG(RADEON_DEFAULT_OFFSET, (pScrn->fbOffset>>10) |
				  (pitch64 << 22));

    /* FIXME: May need to restore other things, 
       like BKGD_CLK FG_CLK...*/

    RADEONWaitForIdle(pScrn);

}

/* This callback is required for multiheader cards using XAA */
#ifdef XF86DRI
static
void RADEONRestoreCPAccelState(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    /*xf86DrvMsg(pScrn->scrnIndex, X_INFO, "===>RestoreCP\n");*/

    RADEONWaitForFifo(pScrn, 1);
    OUTREG( RADEON_DEFAULT_OFFSET, info->frontPitchOffset);

    RADEONWaitForIdle(pScrn);

    /*Not working yet*/
    /*
    RADEONMMIO_TO_CP(pScrn, info);
    */
   
    /* FIXME: May need to restore other things, 
       like BKGD_CLK FG_CLK...*/

}
#endif 

/* Initialize the acceleration hardware. */
static void RADEONEngineInit(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d336 1
a336 1
    if(!info->directRenderinEnabled)
d340 1
a340 1
    	OUTREG(RADEON_MC_AGP_LOCATION, 0xfffff000);
d343 1
d383 13
a395 6
/* Setup for XAA SolidFill. */
static void RADEONSetupForSolidFill(ScrnInfoPtr pScrn,
				    int color, int rop, unsigned int planemask)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
d397 1
a397 34
    RADEONWaitForFifo(pScrn, 4);
    OUTREG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl
				       | RADEON_GMC_BRUSH_SOLID_COLOR
				       | RADEON_GMC_SRC_DATATYPE_COLOR
				       | RADEON_ROP[rop].pattern));
    OUTREG(RADEON_DP_BRUSH_FRGD_CLR,  color);
    OUTREG(RADEON_DP_WRITE_MASK,      planemask);
    OUTREG(RADEON_DP_CNTL,            (RADEON_DST_X_LEFT_TO_RIGHT
				       | RADEON_DST_Y_TOP_TO_BOTTOM));
}

/* Subsequent XAA SolidFillRect.

   Tests: xtest CH06/fllrctngl, xterm
*/
static void  RADEONSubsequentSolidFillRect(ScrnInfoPtr pScrn,
					   int x, int y, int w, int h)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    RADEONWaitForFifo(pScrn, 2);
    OUTREG(RADEON_DST_Y_X,          (y << 16) | x);
    OUTREG(RADEON_DST_WIDTH_HEIGHT, (w << 16) | h);
}

/* Setup for XAA solid lines. */

/* unlike r128, Radeon don't have the Last-Pel controlling bit in DP_CNTL_XDIR_YDIR_YMAJOR
   for line drawing, so we have to do it using our own extrapolation routine*/
static void LastLinePel(int *X1, int *Y1, int *X2, int *Y2)
{
	int tg, deltax, deltay;
	int xa = *X1, ya = *Y1, xb = *X2, yb = *Y2;
d399 7
a405 2
	deltax = xb - xa;
	deltay = yb - ya;
d407 1
a407 153
    	if(deltax == 0) 
		tg = 40;
       	else
		tg = labs((deltay<<4) / deltax);

	if((tg >= 7) && (tg <= 39))
	{
		if(deltax > 0)xb++;
		else xb--;
		if(deltay > 0)yb++;
		else yb--;
	}
	else
	{
		if(labs(deltax) > labs(deltay))
		{
			if(deltax > 0) xb++;
			else xb--;
		}
		else
		{
			if(deltay > 0) yb++;
			else yb--;
		}
		   
	}
}


/* Setup for XAA solid lines. */
static void RADEONSetupForSolidLine(ScrnInfoPtr pScrn,
				    int color, int rop, unsigned int planemask)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    RADEONWaitForFifo(pScrn, 3);
    OUTREG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl
				       | RADEON_GMC_BRUSH_SOLID_COLOR
				       | RADEON_GMC_SRC_DATATYPE_COLOR
				       | RADEON_ROP[rop].pattern));
    OUTREG(RADEON_DP_BRUSH_FRGD_CLR,  color);
    OUTREG(RADEON_DP_WRITE_MASK,      planemask);
}


/* Subsequent XAA solid TwoPointLine line.

   Tests: xtest CH06/drwln, ico, Mark Vojkovich's linetest program

   [See http://www.xfree86.org/devel/archives/devel/1999-Jun/0102.shtml for
   Mark Vojkovich's linetest program, posted 2Jun99 to devel@@xfree86.org.]
*/
static void RADEONSubsequentSolidTwoPointLine(ScrnInfoPtr pScrn,
					      int xa, int ya, int xb, int yb,
					      int flags)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    if (!(flags & OMIT_LAST))
		LastLinePel(&xa, &ya, &xb, &yb);

    RADEONWaitForFifo(pScrn, 2);
    OUTREG(RADEON_DST_LINE_START,           (ya << 16) | xa);
    OUTREG(RADEON_DST_LINE_END,             (yb << 16) | xb);

}

/* Subsequent XAA solid horizontal and vertical lines */
static void RADEONSubsequentSolidHorVertLine(ScrnInfoPtr pScrn,
					     int x, int y, int len, int dir )
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    RADEONWaitForFifo(pScrn, 1);
    OUTREG(RADEON_DP_CNTL, (RADEON_DST_X_LEFT_TO_RIGHT
			    | RADEON_DST_Y_TOP_TO_BOTTOM));

    if (dir == DEGREES_0) {
	RADEONSubsequentSolidFillRect(pScrn, x, y, len, 1);
    } else {
	RADEONSubsequentSolidFillRect(pScrn, x, y, 1, len);
    }
}

/* Setup for XAA dashed lines.

   Tests: xtest CH05/stdshs, XFree86/drwln

   NOTE: Since we can only accelerate lines with power-of-2 patterns of
   length <= 32.
*/
static void RADEONSetupForDashedLine(ScrnInfoPtr pScrn,
				     int fg, int bg,
				     int rop, unsigned int planemask,
				     int length, unsigned char *pattern)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    CARD32        pat         = *(CARD32 *)(pointer)pattern;

    switch (length) {
    case  2: pat |= pat <<  2;  /* fall through */
    case  4: pat |= pat <<  4;  /* fall through */
    case  8: pat |= pat <<  8;  /* fall through */
    case 16: pat |= pat << 16;
    }

    RADEONWaitForFifo(pScrn, 5);
    OUTREG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl
				       | (bg == -1
					  ? RADEON_GMC_BRUSH_32x1_MONO_FG_LA
					  : RADEON_GMC_BRUSH_32x1_MONO_FG_BG)
				       | RADEON_ROP[rop].pattern
				       | RADEON_GMC_BYTE_LSB_TO_MSB));
    OUTREG(RADEON_DP_WRITE_MASK,      planemask);
    OUTREG(RADEON_DP_BRUSH_FRGD_CLR,  fg);
    OUTREG(RADEON_DP_BRUSH_BKGD_CLR,  bg);
    OUTREG(RADEON_BRUSH_DATA0,        pat);
}

/* Subsequent XAA dashed line. */
static void RADEONSubsequentDashedTwoPointLine(ScrnInfoPtr pScrn,
					       int xa, int ya,
					       int xb, int yb,
					       int flags,
					       int phase)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    RADEONWaitForFifo(pScrn, 3);
    if (!(flags & OMIT_LAST))
		LastLinePel(&xa, &ya, &xb, &yb);

    OUTREG(RADEON_DST_LINE_START,   (ya << 16) | xa);
	OUTREG(RADEON_DST_LINE_PATCOUNT, phase);
    OUTREG(RADEON_DST_LINE_END,     (yb << 16) | xb);
}

/* Setup for XAA screen-to-screen copy.

   Tests: xtest CH06/fllrctngl (also tests transparency).
*/
static void RADEONSetupForScreenToScreenCopy(ScrnInfoPtr pScrn,
					     int xdir, int ydir, int rop,
					     unsigned int planemask,
					     int trans_color)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
d409 5
a413 28
    info->xdir = xdir;
    info->ydir = ydir;
    RADEONWaitForFifo(pScrn, 3);
    OUTREG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl
				       | RADEON_GMC_BRUSH_NONE
				       | RADEON_GMC_SRC_DATATYPE_COLOR
				       | RADEON_ROP[rop].rop
				       | RADEON_DP_SRC_SOURCE_MEMORY));
    OUTREG(RADEON_DP_WRITE_MASK,      planemask);
    OUTREG(RADEON_DP_CNTL,            ((xdir >= 0
					? RADEON_DST_X_LEFT_TO_RIGHT
					: 0)
				       | (ydir >= 0
					  ? RADEON_DST_Y_TOP_TO_BOTTOM
					  : 0)));

    if ((trans_color != -1) || (info->XAAForceTransBlit == TRUE)) {
				/* Set up for transparency */
	RADEONWaitForFifo(pScrn, 3);
	OUTREG(RADEON_CLR_CMP_CLR_SRC, trans_color);
	OUTREG(RADEON_CLR_CMP_MASK,    RADEON_CLR_CMP_MSK);
	/* Mmmm, Seems as though the transparency compare is opposite to r128
	 * It should only draw when source != trans_color,
	 * this is the opposite of that. */
	OUTREG(RADEON_CLR_CMP_CNTL,    (RADEON_SRC_CMP_EQ_COLOR
					| RADEON_CLR_CMP_SRC_SOURCE));
    }
}
d415 2
a416 5
/* Subsequent XAA screen-to-screen copy. */
static void RADEONSubsequentScreenToScreenCopy(ScrnInfoPtr pScrn,
					       int xa, int ya,
					       int xb, int yb,
					       int w, int h)
d418 2
a419 40
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    if (info->xdir < 0) xa += w - 1, xb += w - 1;
    if (info->ydir < 0) ya += h - 1, yb += h - 1;

    RADEONWaitForFifo(pScrn, 3);
    OUTREG(RADEON_SRC_Y_X,          (ya << 16) | xa);
    OUTREG(RADEON_DST_Y_X,          (yb << 16) | xb);
    OUTREG(RADEON_DST_HEIGHT_WIDTH, (h << 16) | w);
}

/* Setup for XAA mono 8x8 pattern color expansion.  Patterns with
   transparency use `bg == -1'.  This routine is only used if the XAA
   pixmap cache is turned on.

   Tests: xtest XFree86/fllrctngl (no other test will test this routine with
                                   both transparency and non-transparency)
*/
static void RADEONSetupForMono8x8PatternFill(ScrnInfoPtr pScrn,
					     int patternx, int patterny,
					     int fg, int bg, int rop,
					     unsigned int planemask)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    RADEONWaitForFifo(pScrn, 6);
    OUTREG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl
				       | (bg == -1
					  ? RADEON_GMC_BRUSH_8X8_MONO_FG_LA
					  : RADEON_GMC_BRUSH_8X8_MONO_FG_BG)
				       | RADEON_ROP[rop].pattern
				       | RADEON_GMC_BYTE_LSB_TO_MSB));
    OUTREG(RADEON_DP_WRITE_MASK,      planemask);
    OUTREG(RADEON_DP_BRUSH_FRGD_CLR,  fg);
    OUTREG(RADEON_DP_BRUSH_BKGD_CLR,  bg);
    OUTREG(RADEON_BRUSH_DATA0,        patternx);
    OUTREG(RADEON_BRUSH_DATA1,        patterny);
}
d421 2
a422 131
/* Subsequent XAA 8x8 pattern color expansion.  Because they are used in
   the setup function, `patternx' and `patterny' are not used here. */
static void RADEONSubsequentMono8x8PatternFillRect(ScrnInfoPtr pScrn,
						   int patternx, int patterny,
						   int x, int y, int w, int h)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    RADEONWaitForFifo(pScrn, 3);
    OUTREG(RADEON_BRUSH_Y_X,        (patterny << 8) | patternx);
    OUTREG(RADEON_DST_Y_X,          (y << 16) | x);
    OUTREG(RADEON_DST_HEIGHT_WIDTH, (h << 16) | w);
}

#if 0
/* Setup for XAA color 8x8 pattern fill.

   Tests: xtest XFree86/fllrctngl (with Mono8x8PatternFill off)
*/
static void RADEONSetupForColor8x8PatternFill(ScrnInfoPtr pScrn,
					      int patx, int paty,
					      int rop, unsigned int planemask,
					      int trans_color)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    ErrorF("Color8x8 %d %d %d\n", trans_color, patx, paty);

    RADEONWaitForFifo(pScrn, 3);
    OUTREG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl
				       | RADEON_GMC_BRUSH_8x8_COLOR
				       | RADEON_GMC_SRC_DATATYPE_COLOR
				       | RADEON_ROP[rop].pattern
				       | RADEON_DP_SRC_SOURCE_MEMORY));
    OUTREG(RADEON_DP_WRITE_MASK,      planemask);
    OUTREG(RADEON_SRC_Y_X, (paty << 16) | patx);

    if (trans_color != -1) {
				/* Set up for transparency */
	RADEONWaitForFifo(pScrn, 3);
	OUTREG(RADEON_CLR_CMP_CLR_SRC, trans_color);
	OUTREG(RADEON_CLR_CMP_MASK,    RADEON_CLR_CMP_MSK);
	/* Mmmm, Seems as though the transparency compare is opposite to r128
	 * It should only draw when source != trans_color,
	 * this is the opposite of that. */
	OUTREG(RADEON_CLR_CMP_CNTL,    (RADEON_SRC_CMP_EQ_COLOR
					| RADEON_CLR_CMP_SRC_SOURCE));
    }
}

/* Subsequent XAA 8x8 pattern color expansion. */
static void RADEONSubsequentColor8x8PatternFillRect(ScrnInfoPtr pScrn,
						    int patx, int paty,
						    int x, int y, int w, int h)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    ErrorF("Color8x8 %d,%d %d,%d %d %d\n", patx, paty, x, y, w, h);

    RADEONWaitForFifo(pScrn, 4);
    OUTREG(RADEON_BRUSH_Y_X, (paty << 16) | patx);
    OUTREG(RADEON_DST_Y_X, (y << 16) | x);
    OUTREG(RADEON_DST_HEIGHT_WIDTH, (h << 16) | w);
}
#endif

/* Setup for XAA indirect CPU-to-screen color expansion (indirect).
   Because of how the scratch buffer is initialized, this is really a
   mainstore-to-screen color expansion.  Transparency is supported when `bg
   == -1'.
   Implementing the hybrid indirect/direct scheme improved performance in a
   few areas:
*/
static void RADEONSetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
							     int fg, int bg,
							     int rop,
							     unsigned int
							     planemask)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    RADEONWaitForFifo(pScrn, 4);
    OUTREG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl
				       | RADEON_GMC_DST_CLIPPING
				       | RADEON_GMC_BRUSH_NONE
				       | (bg == -1
					  ? RADEON_GMC_SRC_DATATYPE_MONO_FG_LA
					  : RADEON_GMC_SRC_DATATYPE_MONO_FG_BG)
				       | RADEON_ROP[rop].rop
				       | RADEON_GMC_BYTE_LSB_TO_MSB
				       | RADEON_DP_SRC_SOURCE_HOST_DATA));
    OUTREG(RADEON_DP_WRITE_MASK,      planemask);
    OUTREG(RADEON_DP_SRC_FRGD_CLR,    fg);
    OUTREG(RADEON_DP_SRC_BKGD_CLR,    bg);
}

/* Subsequent XAA indirect CPU-to-screen color expansion.  This is only
   called once for each rectangle. */
static void RADEONSubsequentScanlineCPUToScreenColorExpandFill(ScrnInfoPtr
							       pScrn,
							       int x, int y,
							       int w, int h,
							       int skipleft)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    info->scanline_h      = h;
    info->scanline_words  = (w + 31) >> 5;

#ifdef __alpha__
    /* always use indirect for Alpha */
    if (0)
#else
    if ((info->scanline_words * h) <= 9)
#endif
    {
	/* Turn on direct for less than 9 dword colour expansion */
	info->scratch_buffer[0]
	    = (unsigned char *)(ADDRREG(RADEON_HOST_DATA_LAST)
				- (info->scanline_words - 1));
	info->scanline_direct = 1;
    } else {
	/* Use indirect for anything else */
	info->scratch_buffer[0]            = info->scratch_save;
	info->scanline_direct = 0;
    }
d424 2
a425 9
    RADEONWaitForFifo(pScrn, 4 + (info->scanline_direct ?
					(info->scanline_words * h) : 0) );
    OUTREG(RADEON_SC_TOP_LEFT,      (y << 16)       | ((x+skipleft) & 0xffff));
    /* MMmm, we don't need the -1 on both y+h or x+w, why ? */
    OUTREG(RADEON_SC_BOTTOM_RIGHT,  ((y+h) << 16)   | ((x+w) & 0xffff));
    OUTREG(RADEON_DST_Y_X,          (y << 16)       | (x & 0xffff));
    /* Have to pad the width here and use clipping engine */
    OUTREG(RADEON_DST_HEIGHT_WIDTH, (h << 16)       | ((w + 31) & ~31));
}
d427 4
a430 36
/* Subsequent XAA indirect CPU-to-screen color expansion.  This is called
   once for each scanline. */
static void RADEONSubsequentColorExpandScanline(ScrnInfoPtr pScrn, int bufno)
{
    RADEONInfoPtr   info        = RADEONPTR(pScrn);
    unsigned char   *RADEONMMIO = info->MMIO;
    CARD32          *p          = (pointer)info->scratch_buffer[bufno];
    int             i;
    int             left        = info->scanline_words;
    volatile CARD32 *d;

    if (info->scanline_direct) return;
    --info->scanline_h;
    while (left) {
	write_mem_barrier();
	if (left <= 8) {
	  /* Last scanline - finish write to DATA_LAST */
	  if (info->scanline_h == 0) {
	    RADEONWaitForFifo(pScrn, left);
				/* Unrolling doesn't improve performance */
	    for (d = ADDRREG(RADEON_HOST_DATA_LAST) - (left - 1); left; --left)
		*d++ = *p++;
	    return;
	  } else {
	    RADEONWaitForFifo(pScrn, left);
				/* Unrolling doesn't improve performance */
	    for (d = ADDRREG(RADEON_HOST_DATA7) - (left - 1); left; --left)
		*d++ = *p++;
	  }
	} else {
	    RADEONWaitForFifo(pScrn, 8);
				/* Unrolling doesn't improve performance */
	    for (d = ADDRREG(RADEON_HOST_DATA0), i = 0; i < 8; i++)
		*d++ = *p++;
	    left -= 8;
	}
a431 1
}
d433 1
a433 10
/* Setup for XAA indirect image write. */
static void RADEONSetupForScanlineImageWrite(ScrnInfoPtr pScrn,
					     int rop,
					     unsigned int planemask,
					     int trans_color,
					     int bpp,
					     int depth)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
d435 5
a439 1
    info->scanline_bpp = bpp;
d441 4
a444 20
    RADEONWaitForFifo(pScrn, 2);
    OUTREG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl
				       | RADEON_GMC_DST_CLIPPING
				       | RADEON_GMC_BRUSH_NONE
				       | RADEON_GMC_SRC_DATATYPE_COLOR
				       | RADEON_ROP[rop].rop
				       | RADEON_GMC_BYTE_LSB_TO_MSB
				       | RADEON_DP_SRC_SOURCE_HOST_DATA));
    OUTREG(RADEON_DP_WRITE_MASK,      planemask);

    if (trans_color != -1) {
				/* Set up for transparency */
	RADEONWaitForFifo(pScrn, 3);
	OUTREG(RADEON_CLR_CMP_CLR_SRC, trans_color);
	OUTREG(RADEON_CLR_CMP_MASK,    RADEON_CLR_CMP_MSK);
	/* Mmmm, Seems as though the transparency compare is opposite to r128
	 * It should only draw when source != trans_color,
	 * this is the opposite of that. */
	OUTREG(RADEON_CLR_CMP_CNTL,    (RADEON_SRC_CMP_EQ_COLOR
					| RADEON_CLR_CMP_SRC_SOURCE));
a445 15
}

/* Subsequent XAA indirect image write. This is only called once for each
   rectangle. */
static void RADEONSubsequentScanlineImageWriteRect(ScrnInfoPtr pScrn,
						   int x, int y,
						   int w, int h,
						   int skipleft)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int           shift       = 0; /* 32bpp */

    if (pScrn->bitsPerPixel == 8) shift = 3;
    else if (pScrn->bitsPerPixel == 16) shift = 1;
d447 1
a447 2
    info->scanline_h      = h;
    info->scanline_words  = (w * info->scanline_bpp + 31) >> 5;
d449 3
a451 12
#ifdef __alpha__
    /* always use indirect for Alpha */
    if (0)
#else
    if ((info->scanline_words * h) <= 9)
#endif
    {
	/* Turn on direct for less than 9 dword colour expansion */
	info->scratch_buffer[0]
	    = (unsigned char *)(ADDRREG(RADEON_HOST_DATA_LAST)
				- (info->scanline_words - 1));
	info->scanline_direct = 1;
d453 1
a453 454
	/* Use indirect for anything else */
	info->scratch_buffer[0]            = info->scratch_save;
	info->scanline_direct = 0;
    }

    RADEONWaitForFifo(pScrn, 4 + (info->scanline_direct ?
					(info->scanline_words * h) : 0) );
    OUTREG(RADEON_SC_TOP_LEFT,      (y << 16)       | ((x+skipleft) & 0xffff));
    /* MMmm, we don't need the -1 on both y+h or x+w, why ? */
    OUTREG(RADEON_SC_BOTTOM_RIGHT,  ((y+h) << 16)   | ((x+w) & 0xffff));
    OUTREG(RADEON_DST_Y_X,          (y << 16)       | (x & 0xffff));
    /* Have to pad the width here and use clipping engine */
    OUTREG(RADEON_DST_HEIGHT_WIDTH, (h << 16)       | ((w + shift) & ~shift));
}

/* Subsequent XAA indirect image write.  This is called once for each
   scanline. */
static void RADEONSubsequentImageWriteScanline(ScrnInfoPtr pScrn, int bufno)
{
    RADEONInfoPtr   info        = RADEONPTR(pScrn);
    unsigned char   *RADEONMMIO = info->MMIO;
    CARD32          *p          = (pointer)info->scratch_buffer[bufno];
    int             i;
    int             left        = info->scanline_words;
    volatile CARD32 *d;

    if (info->scanline_direct) return;
    --info->scanline_h;
    while (left) {
	write_mem_barrier();
	if (left <= 8) {
	  /* Last scanline - finish write to DATA_LAST */
	  if (info->scanline_h == 0) {
	    RADEONWaitForFifo(pScrn, left);
				/* Unrolling doesn't improve performance */
	    for (d = ADDRREG(RADEON_HOST_DATA_LAST) - (left - 1); left; --left)
		*d++ = *p++;
	    return;
	  } else {
	    RADEONWaitForFifo(pScrn, left);
				/* Unrolling doesn't improve performance */
	    for (d = ADDRREG(RADEON_HOST_DATA7) - (left - 1); left; --left)
		*d++ = *p++;
	  }
	} else {
	    RADEONWaitForFifo(pScrn, 8);
				/* Unrolling doesn't improve performance */
	    for (d = ADDRREG(RADEON_HOST_DATA0), i = 0; i < 8; i++)
		*d++ = *p++;
	    left -= 8;
	}
    }
}

static void RADEONSetClippingRectangle(ScrnInfoPtr pScrn,
							  int xa, int ya, int xb, int yb)
{
	RADEONInfoPtr   info        = RADEONPTR(pScrn);
	unsigned char *RADEONMMIO = info->MMIO;
	unsigned long tmp = 0;

	if(xa < 0)
	{
		tmp = -xa;
		tmp |= RADEON_SC_SIGN_MASK_LO;
	}
	else tmp = xa;

	if(ya < 0)
	{
		tmp |= ((-ya) << 16);
		tmp |= RADEON_SC_SIGN_MASK_HI;
	}
	else tmp |= (ya << 16);

	OUTREG(RADEON_SC_TOP_LEFT, tmp);

	if(xb < 0)
	{
		tmp = -xb;
		tmp |= RADEON_SC_SIGN_MASK_LO;
	}
	else tmp = xb;

	if(yb < 0)
	{
		tmp |= ((-yb) << 16);
		tmp |= RADEON_SC_SIGN_MASK_HI;
	}
	else tmp |= (yb << 16);
    OUTREG(RADEON_SC_BOTTOM_RIGHT, tmp);

    OUTREG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl | RADEON_GMC_DST_CLIPPING));

}

static void
RADEONDisableClipping(ScrnInfoPtr pScrn)
{
	RADEONInfoPtr   info        = RADEONPTR(pScrn);
	unsigned char *RADEONMMIO = info->MMIO;

	OUTREG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl & ~(CARD32)RADEON_GMC_DST_CLIPPING));

	OUTREG(RADEON_SC_TOP_LEFT, 0);
	OUTREG(RADEON_SC_BOTTOM_RIGHT, INREG(RADEON_DEFAULT_SC_BOTTOM_RIGHT));

}



/* ================================================================
 * CP-based 2D acceleration
 */
#ifdef XF86DRI

/* Setup for XAA SolidFill. */
static void RADEONCPSetupForSolidFill(ScrnInfoPtr pScrn,
				      int color, int rop,
				      unsigned int planemask)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RING_LOCALS;

    RADEONCP_REFRESH( pScrn, info );

    BEGIN_RING( 8 );

    OUT_RING_REG( RADEON_DP_GUI_MASTER_CNTL,
		  (info->dp_gui_master_cntl
		   | RADEON_GMC_BRUSH_SOLID_COLOR
		   | RADEON_GMC_SRC_DATATYPE_COLOR
		   | RADEON_ROP[rop].pattern) );

    OUT_RING_REG( RADEON_DP_BRUSH_FRGD_CLR,  color );
    OUT_RING_REG( RADEON_DP_WRITE_MASK,	     planemask );
    OUT_RING_REG( RADEON_DP_CNTL,	     (RADEON_DST_X_LEFT_TO_RIGHT |
					      RADEON_DST_Y_TOP_TO_BOTTOM) );
    ADVANCE_RING();
}

/* Subsequent XAA SolidFillRect.

   Tests: xtest CH06/fllrctngl, xterm
*/
static void RADEONCPSubsequentSolidFillRect(ScrnInfoPtr pScrn,
					    int x, int y, int w, int h)
{
    RADEONInfoPtr info  = RADEONPTR(pScrn);
    RING_LOCALS;

    RADEONCP_REFRESH( pScrn, info );

    BEGIN_RING( 4 );

    OUT_RING_REG( RADEON_DST_Y_X,          (y << 16) | x );
    OUT_RING_REG( RADEON_DST_WIDTH_HEIGHT, (w << 16) | h );

    ADVANCE_RING();
}

/* Setup for XAA screen-to-screen copy.

   Tests: xtest CH06/fllrctngl (also tests transparency).
*/
static void RADEONCPSetupForScreenToScreenCopy(ScrnInfoPtr pScrn,
					       int xdir, int ydir, int rop,
					       unsigned int planemask,
					       int trans_color)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RING_LOCALS;

    RADEONCP_REFRESH( pScrn, info );

    info->xdir = xdir;
    info->ydir = ydir;

    BEGIN_RING( 6 );

    OUT_RING_REG( RADEON_DP_GUI_MASTER_CNTL,
		  (info->dp_gui_master_cntl
		   | RADEON_GMC_BRUSH_NONE
		   | RADEON_GMC_SRC_DATATYPE_COLOR
		   | RADEON_ROP[rop].rop
		   | RADEON_DP_SRC_SOURCE_MEMORY) );

    OUT_RING_REG( RADEON_DP_WRITE_MASK, planemask );
    OUT_RING_REG( RADEON_DP_CNTL,
		  ((xdir >= 0 ? RADEON_DST_X_LEFT_TO_RIGHT : 0) |
		   (ydir >= 0 ? RADEON_DST_Y_TOP_TO_BOTTOM : 0)) );

    ADVANCE_RING();

    if ((trans_color != -1) || (info->XAAForceTransBlit == TRUE)) {
	BEGIN_RING( 6 );

	OUT_RING_REG( RADEON_CLR_CMP_CLR_SRC, trans_color );
	OUT_RING_REG( RADEON_CLR_CMP_MASK,    RADEON_CLR_CMP_MSK );
	/* Mmmm, Seems as though the transparency compare is opposite to r128
	 * It should only draw when source != trans_color,
	 * this is the opposite of that. */
	OUT_RING_REG( RADEON_CLR_CMP_CNTL,    (RADEON_SRC_CMP_EQ_COLOR |
					       RADEON_CLR_CMP_SRC_SOURCE) );

	ADVANCE_RING();
    }
}

/* Subsequent XAA screen-to-screen copy. */
static void RADEONCPSubsequentScreenToScreenCopy(ScrnInfoPtr pScrn,
						 int xa, int ya,
						 int xb, int yb,
						 int w, int h)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RING_LOCALS;

    RADEONCP_REFRESH( pScrn, info );

    if (info->xdir < 0) xa += w - 1, xb += w - 1;
    if (info->ydir < 0) ya += h - 1, yb += h - 1;

    BEGIN_RING( 6 );

    OUT_RING_REG( RADEON_SRC_Y_X,          (ya << 16) | xa );
    OUT_RING_REG( RADEON_DST_Y_X,          (yb << 16) | xb );
    OUT_RING_REG( RADEON_DST_HEIGHT_WIDTH, (h << 16) | w );

    ADVANCE_RING();
}

/* Setup for XAA solid lines. */
static void RADEONCPSetupForSolidLine(ScrnInfoPtr pScrn,
				    int color, int rop, unsigned int planemask)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    RING_LOCALS;
    BEGIN_RING( 6 );
    OUT_RING_REG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl
										   | RADEON_GMC_BRUSH_SOLID_COLOR
										   | RADEON_GMC_SRC_DATATYPE_COLOR
										   | RADEON_ROP[rop].pattern));
    OUT_RING_REG(RADEON_DP_BRUSH_FRGD_CLR,  color);
    OUT_RING_REG(RADEON_DP_WRITE_MASK,      planemask);

    ADVANCE_RING();

}


/* Subsequent XAA solid TwoPointLine line.

   Tests: xtest CH06/drwln, ico, Mark Vojkovich's linetest program

   [See http://www.xfree86.org/devel/archives/devel/1999-Jun/0102.shtml for
   Mark Vojkovich's linetest program, posted 2Jun99 to devel@@xfree86.org.]
*/
static void RADEONCPSubsequentSolidTwoPointLine(ScrnInfoPtr pScrn,
					      int xa, int ya, int xb, int yb,
					      int flags)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    RING_LOCALS;
    BEGIN_RING( 4 );

    if (!(flags & OMIT_LAST))
	{
		LastLinePel(&xa, &ya, &xb, &yb);
	}

	OUT_RING_REG(RADEON_DST_LINE_START,           (ya << 16) | xa);
	OUT_RING_REG(RADEON_DST_LINE_END,             (yb << 16) | xb);

	ADVANCE_RING();

}

/* Subsequent XAA solid horizontal and vertical lines */
static void RADEONCPSubsequentSolidHorVertLine(ScrnInfoPtr pScrn,
					     int x, int y, int len, int dir )
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);

    RING_LOCALS;
    BEGIN_RING( 6 );

    OUT_RING_REG(RADEON_DP_CNTL, (RADEON_DST_X_LEFT_TO_RIGHT
			    | RADEON_DST_Y_TOP_TO_BOTTOM));
	
    if (dir == DEGREES_0) 
	{
		OUT_RING_REG( RADEON_DST_Y_X,          (y << 16) | x );
		OUT_RING_REG( RADEON_DST_WIDTH_HEIGHT, (len << 16) | 1 );		
    } 
	else 
	{
		OUT_RING_REG( RADEON_DST_Y_X,          (y << 16) | x );
		OUT_RING_REG( RADEON_DST_WIDTH_HEIGHT, (1 << 16) | len );		
    }
    ADVANCE_RING();
}


/* Setup for XAA dashed lines.

   Tests: xtest CH05/stdshs, XFree86/drwln

   NOTE: Since we can only accelerate lines with power-of-2 patterns of
   length <= 32.
*/
static void RADEONCPSetupForDashedLine(ScrnInfoPtr pScrn,
				     int fg, int bg,
				     int rop, unsigned int planemask,
				     int length, unsigned char *pattern)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    CARD32        pat         = *(CARD32 *)(pointer)pattern;

    RING_LOCALS;

    switch (length) {
    case  2: pat |= pat <<  2;  /* fall through */
    case  4: pat |= pat <<  4;  /* fall through */
    case  8: pat |= pat <<  8;  /* fall through */
    case 16: pat |= pat << 16;
    }

    BEGIN_RING( 12 );
    OUT_RING_REG(RADEON_DP_GUI_MASTER_CNTL, (info->dp_gui_master_cntl
									 | (bg == -1
										? RADEON_GMC_BRUSH_32x1_MONO_FG_LA
										: RADEON_GMC_BRUSH_32x1_MONO_FG_BG)
									 | RADEON_ROP[rop].pattern
									 | RADEON_GMC_BYTE_LSB_TO_MSB));
    OUT_RING_REG(RADEON_DP_WRITE_MASK,      planemask);
    OUT_RING_REG(RADEON_DP_BRUSH_FRGD_CLR,  fg);
    if(bg != -1) OUT_RING_REG(RADEON_DP_BRUSH_BKGD_CLR,  bg);
    OUT_RING_REG(RADEON_BRUSH_DATA0, pat);
	ADVANCE_RING();

}

/* Subsequent XAA dashed line. */
static void RADEONCPSubsequentDashedTwoPointLine(ScrnInfoPtr pScrn,
					       int xa, int ya,
					       int xb, int yb,
					       int flags,
					       int phase)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);

    RING_LOCALS;

    if (!(flags & OMIT_LAST))
	{
		LastLinePel(&xa, &ya, &xb, &yb);
	}

	BEGIN_RING(6);
    OUT_RING_REG(RADEON_DST_LINE_START,   (ya << 16) | xa);
	OUT_RING_REG(RADEON_DST_LINE_PATCOUNT, phase);
    OUT_RING_REG(RADEON_DST_LINE_END,     (yb << 16) | xb);
	ADVANCE_RING();
}


static void RADEONCPSetClippingRectangle(ScrnInfoPtr pScrn,
							  int xa, int ya, int xb, int yb)
{
	RADEONInfoPtr   info        = RADEONPTR(pScrn);
	unsigned long tmp1 = 0, tmp2 = 0;

	if(xa < 0)
	{
		tmp1 = -xa;
		tmp1 |= RADEON_SC_SIGN_MASK_LO;
	}
	else tmp1 = xa;

	if(ya < 0)
	{
		tmp1 |= ((-ya) << 16);
		tmp1 |= RADEON_SC_SIGN_MASK_HI;
	}
	else tmp1 |= (ya << 16);

	if(xb < 0)
	{
		tmp2 = -xb;
		tmp2 |= RADEON_SC_SIGN_MASK_LO;
	}
	else tmp2 = xb;

	if(yb < 0)
	{
		tmp2 |= ((-yb) << 16);
		tmp2 |= RADEON_SC_SIGN_MASK_HI;
	}
	else tmp2 |= (yb << 16);

	{
	
	RING_LOCALS;
	BEGIN_RING( 3 );
	OUT_RING_REG(RADEON_SC_TOP_LEFT, tmp1);
	OUT_RING_REG(RADEON_SC_BOTTOM_RIGHT, tmp2);
	OUT_RING_REG(RADEON_DP_GUI_MASTER_CNTL, 
				 (info->dp_gui_master_cntl | RADEON_GMC_DST_CLIPPING));

	ADVANCE_RING();
	}
}

static void
RADEONCPDisableClipping(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr   info        = RADEONPTR(pScrn);
	/* unsigned char *RADEONMMIO = info->MMIO;*/
    RING_LOCALS;
    BEGIN_RING( 3 );
    OUT_RING_REG(RADEON_DP_GUI_MASTER_CNTL, 
					 (info->dp_gui_master_cntl & ~(CARD32)(RADEON_GMC_DST_CLIPPING)));
	OUT_RING_REG(RADEON_SC_TOP_LEFT, 0);
    OUT_RING_REG(RADEON_SC_BOTTOM_RIGHT, (RADEON_DEFAULT_SC_RIGHT_MAX
					    | RADEON_DEFAULT_SC_BOTTOM_MAX));

	ADVANCE_RING();

}


/* Point the DST_PITCH_OFFSET register at the current buffer.  This
 * allows us to interact with the back and depth buffers.  All CP 2D
 * acceleration commands use the DST_PITCH_OFFSET register.
 */
void RADEONSelectBuffer(ScrnInfoPtr pScrn, int buffer)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RING_LOCALS;

    switch (buffer) {
    case RADEON_BACK:
	info->dst_pitch_offset = info->backPitchOffset;
	break;
    case RADEON_DEPTH:
	info->dst_pitch_offset = info->depthPitchOffset;
	break;
    default:
    case RADEON_FRONT:
	info->dst_pitch_offset = info->frontPitchOffset;
	break;
a454 6

    BEGIN_RING( 2 );

    OUT_RING_REG( RADEON_DEFAULT_OFFSET, info->dst_pitch_offset );

    ADVANCE_RING();
d457 2
a458 3
/* Get an indirect buffer for the CP 2D acceleration commands.
 */
drmBufPtr RADEONCPGetBuffer( ScrnInfoPtr pScrn )
d460 7
a466 6
    RADEONInfoPtr info = RADEONPTR(pScrn);
    drmDMAReq dma;
    drmBufPtr buf = NULL;
    int indx = 0;
    int size = 0;
    int ret, i = 0;
d470 4
a473 3
       called from RADEONSelectBuffer via RADEONDRICPInit.  We could use
       the screen index from pScrn, which is initialized, and then get
       the screen from screenInfo.screens[index], but that is a hack. */
d476 2
a477 1
    dma.context = 0x00000001; /* This is the X server's context */
d479 5
a483 4
    dma.send_count = 0;
    dma.send_list = NULL;
    dma.send_sizes = NULL;
    dma.flags = 0;
d485 2
a486 2
    dma.request_size = RADEON_BUFFER_SIZE;
    dma.request_list = &indx;
d490 1
a490 1
    while ( 1 ) {
d492 4
a495 4
	    ret = drmDMA( info->drmFD, &dma );
	    if ( ret && ret != -EBUSY ) {
		xf86DrvMsg( pScrn->scrnIndex, X_ERROR,
			    "%s: CP GetBuffer %d\n", __FUNCTION__, ret );
d497 1
a497 1
	} while ( ( ret == -EBUSY ) && ( i++ < RADEON_TIMEOUT ) );
d499 1
a499 1
	if ( ret == 0 ) {
d502 4
a505 3
	    if ( RADEON_VERBOSE ) {
		xf86DrvMsg( pScrn->scrnIndex, X_INFO,
			    "   GetBuffer returning %d\n", buf->idx );
d510 4
a513 4
	xf86DrvMsg( pScrn->scrnIndex, X_ERROR,
		    "GetBuffer timed out, resetting engine...\n");
	RADEONEngineReset( pScrn );
	RADEONEngineRestore( pScrn );
d516 2
a517 2
	RADEONCP_RESET( pScrn, info );
	RADEONCP_START( pScrn, info );
d521 2
a522 3
/* Flush the indirect buffer to the kernel for submission to the card.
 */
void RADEONCPFlushIndirect( ScrnInfoPtr pScrn )
d524 4
a527 4
    RADEONInfoPtr info = RADEONPTR(pScrn);
    drmBufPtr buffer = info->indirectBuffer;
    int start = info->indirectStart;
    int discard;
d529 2
a530 2
    if ( !buffer )
	return;
d532 4
a535 2
    if ( start == buffer->used )
	return;
d537 4
a540 1
    discard = ( buffer->used + RING_THRESHOLD > buffer->total );
d542 2
a543 2
    drmRadeonFlushIndirectBuffer( info->drmFD, buffer->idx,
				  start, buffer->used, discard );
d545 3
a547 3
    if ( discard ) {
	info->indirectBuffer = RADEONCPGetBuffer( pScrn );
	info->indirectStart = 0;
d549 6
a554 1
	info->indirectStart = buffer->used;
d558 2
a559 3
/* Flush and release the indirect buffer.
 */
void RADEONCPReleaseIndirect( ScrnInfoPtr pScrn )
d561 4
a564 3
    RADEONInfoPtr info = RADEONPTR(pScrn);
    drmBufPtr buffer = info->indirectBuffer;
    int start = info->indirectStart;
d567 1
a567 1
    info->indirectStart = 0;
d569 1
a569 2
    if ( !buffer )
	return;
d571 4
a574 15
    drmRadeonFlushIndirectBuffer( info->drmFD, buffer->idx,
				  start, buffer->used, 1 );
}

static void RADEONCPAccelInit(ScrnInfoPtr pScrn, XAAInfoRecPtr a)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

#if 1
    a->Flags                            = (PIXMAP_CACHE
					   | OFFSCREEN_PIXMAPS
					   | LINEAR_FRAMEBUFFER);
#else
    a->Flags                            = 0; /* GH: Do we really need this? */
#endif
d576 4
a579 44
				/* Sync */
    a->Sync                             = RADEONCPWaitForIdle;

    /* If direct rendering is disabled, then do not enable any CP
       acceleration routines */
    if (!info->directRenderingEnabled) return;

				/* Solid Filled Rectangle */
    a->PolyFillRectSolidFlags           = 0;
    a->SetupForSolidFill                = RADEONCPSetupForSolidFill;
    a->SubsequentSolidFillRect          = RADEONCPSubsequentSolidFillRect;

				/* Screen-to-screen Copy */
    a->ScreenToScreenCopyFlags          = 0;
    a->SetupForScreenToScreenCopy       = RADEONCPSetupForScreenToScreenCopy;
    a->SubsequentScreenToScreenCopy     = RADEONCPSubsequentScreenToScreenCopy;


    a->SetupForDashedLine              = RADEONCPSetupForDashedLine;
    a->SubsequentDashedTwoPointLine    = RADEONCPSubsequentDashedTwoPointLine;
    a->DashPatternMaxLength            = 32;
	/*ROP3 doesn't seem to work properly for dashedline with GXinvert*/
    a->DashedLineFlags                 = (LINE_PATTERN_LSBFIRST_LSBJUSTIFIED
										  | LINE_PATTERN_POWER_OF_2_ONLY 
										  | ROP_NEEDS_SOURCE); 


	a->SolidLineFlags 		= 0;
    a->SetupForSolidLine               = RADEONCPSetupForSolidLine;
    a->SubsequentSolidTwoPointLine     = RADEONCPSubsequentSolidTwoPointLine;
    a->SubsequentSolidHorVertLine      = RADEONCPSubsequentSolidHorVertLine;
    a->SubsequentSolidBresenhamLine 	= NULL;

    /* clipping */
    a->SetClippingRectangle = RADEONCPSetClippingRectangle;
    a->DisableClipping = RADEONCPDisableClipping;
    a->ClippingFlags = 	HARDWARE_CLIP_SOLID_LINE  |
		HARDWARE_CLIP_DASHED_LINE |
		/*HARDWARE_CLIP_SOLID_FILL  |*/ /* seems very slow with this on ???*/
		HARDWARE_CLIP_MONO_8x8_FILL |
		HARDWARE_CLIP_SCREEN_TO_SCREEN_COPY;

    if(!info->IsSecondary && xf86IsEntityShared(pScrn->entityList[0]))
        a->RestoreAccelState           = RADEONRestoreCPAccelState;
d581 2
a585 128
static void RADEONMMIOAccelInit(ScrnInfoPtr pScrn, XAAInfoRecPtr a)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);

    a->Flags                            = (PIXMAP_CACHE
					   | OFFSCREEN_PIXMAPS
					   | LINEAR_FRAMEBUFFER);

				/* Sync */
    a->Sync                             = RADEONWaitForIdle;

				/* Solid Filled Rectangle */
    a->PolyFillRectSolidFlags           = 0;
    a->SetupForSolidFill                = RADEONSetupForSolidFill;
    a->SubsequentSolidFillRect          = RADEONSubsequentSolidFillRect;

				/* Screen-to-screen Copy */
    a->ScreenToScreenCopyFlags          = 0;
    a->SetupForScreenToScreenCopy       = RADEONSetupForScreenToScreenCopy;
    a->SubsequentScreenToScreenCopy     = RADEONSubsequentScreenToScreenCopy;

				/* Mono 8x8 Pattern Fill (Color Expand) */
    a->SetupForMono8x8PatternFill
	= RADEONSetupForMono8x8PatternFill;
    a->SubsequentMono8x8PatternFillRect
	= RADEONSubsequentMono8x8PatternFillRect;
    a->Mono8x8PatternFillFlags          = (HARDWARE_PATTERN_PROGRAMMED_BITS
					   | HARDWARE_PATTERN_PROGRAMMED_ORIGIN
					   | HARDWARE_PATTERN_SCREEN_ORIGIN
					   | BIT_ORDER_IN_BYTE_LSBFIRST);

				/* Indirect CPU-To-Screen Color Expand */
#if X_BYTE_ORDER == X_LITTLE_ENDIAN
    a->ScanlineCPUToScreenColorExpandFillFlags = LEFT_EDGE_CLIPPING
		/* RADEON gets upset, when using HOST provided data
		 * without a source rop. To show run 'xtest's drwarc */
					       | ROP_NEEDS_SOURCE
					       | LEFT_EDGE_CLIPPING_NEGATIVE_X;
#else
    a->ScanlineCPUToScreenColorExpandFillFlags = BIT_ORDER_IN_BYTE_MSBFIRST
		/* RADEON gets upset, when using HOST provided data
		 * without a source rop. To show run 'xtest's drwarc */
					       | ROP_NEEDS_SOURCE
					       | LEFT_EDGE_CLIPPING
					       | LEFT_EDGE_CLIPPING_NEGATIVE_X;
#endif
    a->NumScanlineColorExpandBuffers   = 1;
    a->ScanlineColorExpandBuffers      = info->scratch_buffer;
    info->scratch_save                 = xalloc(((pScrn->virtualX+31)/32*4)
					    + (pScrn->virtualX
					    * info->CurrentLayout.pixel_bytes));
    info->scratch_buffer[0]            = info->scratch_save;
    a->SetupForScanlineCPUToScreenColorExpandFill
	= RADEONSetupForScanlineCPUToScreenColorExpandFill;
    a->SubsequentScanlineCPUToScreenColorExpandFill
	= RADEONSubsequentScanlineCPUToScreenColorExpandFill;
    a->SubsequentColorExpandScanline   = RADEONSubsequentColorExpandScanline;

    a->SetupForSolidLine               = RADEONSetupForSolidLine;
    a->SubsequentSolidTwoPointLine     = RADEONSubsequentSolidTwoPointLine;
    a->SubsequentSolidHorVertLine      = RADEONSubsequentSolidHorVertLine;

    a->SetupForDashedLine              = RADEONSetupForDashedLine;
    a->SubsequentDashedTwoPointLine    = RADEONSubsequentDashedTwoPointLine;
    a->DashPatternMaxLength            = 32;
	/*ROP3 doesn't seem to work properly for dashedline with GXinvert*/
    a->DashedLineFlags                 = (LINE_PATTERN_LSBFIRST_LSBJUSTIFIED
										  | LINE_PATTERN_POWER_OF_2_ONLY 
										  | ROP_NEEDS_SOURCE); 

    /* clipping, note without this, 
       all line accelerations will not be called */
    a->SetClippingRectangle = RADEONSetClippingRectangle;
    a->DisableClipping = RADEONDisableClipping;
    a->ClippingFlags = 	HARDWARE_CLIP_SOLID_LINE  |
		HARDWARE_CLIP_DASHED_LINE |
		/*HARDWARE_CLIP_SOLID_FILL  |*/ /* seems very slow with this on ???*/
		HARDWARE_CLIP_MONO_8x8_FILL |
		HARDWARE_CLIP_SCREEN_TO_SCREEN_COPY;


    if(xf86IsEntityShared(pScrn->entityList[0]))
    {
        DevUnion* pPriv;
        RADEONEntPtr pRADEONEnt;
        pPriv = xf86GetEntityPrivate(pScrn->entityList[0],
                gRADEONEntityIndex);
        pRADEONEnt = pPriv->ptr;
        
        /*if there are more than one devices sharing this entity, we
          have to assign this call back, otherwise the XAA will be
          disabled */
        if(pRADEONEnt->HasSecondary || pRADEONEnt->BypassSecondary)
           a->RestoreAccelState           = RADEONRestoreAccelState;
    }

				/* ImageWrite */
    a->NumScanlineImageWriteBuffers    = 1;
    a->ScanlineImageWriteBuffers       = info->scratch_buffer;
    info->scratch_buffer[0]            = info->scratch_save;
    a->SetupForScanlineImageWrite      = RADEONSetupForScanlineImageWrite;
    a->SubsequentScanlineImageWriteRect
	= RADEONSubsequentScanlineImageWriteRect;
    a->SubsequentImageWriteScanline    = RADEONSubsequentImageWriteScanline;
    a->ScanlineImageWriteFlags           = CPU_TRANSFER_PAD_DWORD
		/* Performance tests show that we shouldn't use GXcopy for
		 * uploads as a memcpy is faster */
					 | NO_GXCOPY
		/* RADEON gets upset, when using HOST provided data
		 * without a source rop. To show run 'xtest's ptimg */
					 | ROP_NEEDS_SOURCE
					 | SCANLINE_PAD_DWORD
					 | LEFT_EDGE_CLIPPING
					 | LEFT_EDGE_CLIPPING_NEGATIVE_X;

#if 0
				/* Color 8x8 Pattern Fill */
    a->SetupForColor8x8PatternFill
	= RADEONSetupForColor8x8PatternFill;
    a->SubsequentColor8x8PatternFillRect
	= RADEONSubsequentColor8x8PatternFillRect;
    a->Color8x8PatternFillFlags          =
					    HARDWARE_PATTERN_PROGRAMMED_ORIGIN
					   | HARDWARE_PATTERN_SCREEN_ORIGIN
					   | BIT_ORDER_IN_BYTE_LSBFIRST;
#endif
}

d587 2
a588 1
   graphics hardware for acceleration. */
d591 8
a598 3
    ScrnInfoPtr   pScrn = xf86Screens[pScreen->myNum];
    RADEONInfoPtr info  = RADEONPTR(pScrn);
    XAAInfoRecPtr a;
a599 6
    if (!(a = info->accel = XAACreateInfoRec())) 
    {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR, 
            "XAACreateInfoRec Error\n");
        return FALSE;
    }
d602 1
a602 1
	RADEONCPAccelInit(pScrn, a);
d605 1
a605 1
	RADEONMMIOAccelInit(pScrn, a);
d608 6
a613 7
    
    if(!XAAInit(pScreen, a))
    {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR, 
            "XAAInit Error\n");
        return FALSE;
    }    
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c,v 1.36 2003/11/10 18:41:22 tsi Exp $ */
d32 1
a32 1
 *   Kevin E. Martin <martin@@xfree86.org>
d34 1
a34 1
 *   Alan Hourihane <alanh@@fairlite.demon.co.uk>
a74 1
#include "radeon_macros.h"
d114 2
a115 3
/* The FIFO has 64 slots.  This routines waits until at least `entries'
 * of these slots are empty.
 */
d118 1
a118 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d120 1
a120 1
    int            i;
d136 1
a137 1
	    RADEONCP_RESET(pScrn, info);
d144 74
a217 1
/* Flush all dirty data in the Pixel Cache to memory */
d220 1
a220 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d222 1
a222 1
    int            i;
d224 2
a225 3
    OUTREGP(RADEON_RB2D_DSTCACHE_CTLSTAT,
	    RADEON_RB2D_DC_FLUSH_ALL,
	    ~RADEON_RB2D_DC_FLUSH_ALL);
d227 1
a227 2
	if (!(INREG(RADEON_RB2D_DSTCACHE_CTLSTAT) & RADEON_RB2D_DC_BUSY))
	    break;
d231 1
a231 1
/* Reset graphics card to known state */
d234 1
a234 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d236 4
a239 4
    CARD32         clock_cntl_index;
    CARD32         mclk_cntl;
    CARD32         rbbm_soft_reset;
    CARD32         host_path_cntl;
d244 1
a244 18
    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);

    /* Some ASICs have bugs with dynamic-on feature, which are
     * ASIC-version dependent, so we force all blocks on for now
     */
    if (info->HasCRTC2) {
	CARD32 tmp;

	tmp = INPLL(pScrn, RADEON_SCLK_CNTL);
	OUTPLL(RADEON_SCLK_CNTL, ((tmp & ~RADEON_DYN_STOP_LAT_MASK) |
				  RADEON_CP_MAX_DYN_STOP_LAT |
				  RADEON_SCLK_FORCEON_MASK));

	if (info->ChipFamily == CHIP_FAMILY_RV200) {
	    tmp = INPLL(pScrn, RADEON_SCLK_MORE_CNTL);
	    OUTPLL(RADEON_SCLK_MORE_CNTL, tmp | RADEON_SCLK_MORE_FORCEON);
	}
    }
a245 1
    mclk_cntl = INPLL(pScrn, RADEON_MCLK_CNTL);
d254 25
a278 40
    /* Soft resetting HDP thru RBBM_SOFT_RESET register can cause some
     * unexpected behaviour on some machines.  Here we use
     * RADEON_HOST_PATH_CNTL to reset it.
     */
    host_path_cntl = INREG(RADEON_HOST_PATH_CNTL);
    rbbm_soft_reset = INREG(RADEON_RBBM_SOFT_RESET);

    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {
	CARD32 tmp;

	OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset |
					RADEON_SOFT_RESET_CP |
					RADEON_SOFT_RESET_HI |
					RADEON_SOFT_RESET_E2));
	INREG(RADEON_RBBM_SOFT_RESET);
	OUTREG(RADEON_RBBM_SOFT_RESET, 0);
	tmp = INREG(RADEON_RB2D_DSTCACHE_MODE);
	OUTREG(RADEON_RB2D_DSTCACHE_MODE, tmp | (1 << 17)); /* FIXME */
    } else {
	OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset |
					RADEON_SOFT_RESET_CP |
					RADEON_SOFT_RESET_HI |
					RADEON_SOFT_RESET_SE |
					RADEON_SOFT_RESET_RE |
					RADEON_SOFT_RESET_PP |
					RADEON_SOFT_RESET_E2 |
					RADEON_SOFT_RESET_RB));
	INREG(RADEON_RBBM_SOFT_RESET);
	OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset & (CARD32)
					~(RADEON_SOFT_RESET_CP |
					  RADEON_SOFT_RESET_HI |
					  RADEON_SOFT_RESET_SE |
					  RADEON_SOFT_RESET_RE |
					  RADEON_SOFT_RESET_PP |
					  RADEON_SOFT_RESET_E2 |
					  RADEON_SOFT_RESET_RB)));
	INREG(RADEON_RBBM_SOFT_RESET);
    }
d284 1
a284 4
    if ((info->ChipFamily != CHIP_FAMILY_R300) &&
        (info->ChipFamily != CHIP_FAMILY_R350) &&
        (info->ChipFamily != CHIP_FAMILY_RV350))
	OUTREG(RADEON_RBBM_SOFT_RESET, rbbm_soft_reset);
d287 2
a288 2
    OUTPLL(RADEON_MCLK_CNTL, mclk_cntl);
    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);
d291 1
a291 1
/* Restore the acceleration hardware to its previous state */
d294 1
a294 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d296 1
a296 1
    int            pitch64;
d303 2
a304 12

    /* NOTE: The following RB2D_DSTCACHE_MODE setting will cause the
     * R300 to hang.  ATI does not see a reason to change it from the
     * default BIOS settings (even on non-R300 cards).  This setting
     * might be removed in future versions of the Radeon driver.
     */

    /* Turn of all automatic flushing - we'll do it all */
    if ((info->ChipFamily != CHIP_FAMILY_R300) &&
	(info->ChipFamily != CHIP_FAMILY_R350) &&
	(info->ChipFamily != CHIP_FAMILY_RV350))
	OUTREG(RADEON_RB2D_DSTCACHE_MODE, 0);
d309 2
a310 2
    OUTREG(RADEON_DEFAULT_OFFSET, ((INREG(RADEON_DISPLAY_BASE_ADDR) >> 10)
				   | (pitch64 << 22)));
d315 1
a315 2
	    RADEON_HOST_BIG_ENDIAN_EN,
	    ~RADEON_HOST_BIG_ENDIAN_EN);
d320 1
a320 1
    /* Restore SURFACE_CNTL */
d340 1
a340 1
    RADEONWaitForIdleMMIO(pScrn);
d343 3
a345 2
/* Initialize the acceleration hardware */
void RADEONEngineInit(ScrnInfoPtr pScrn)
d347 58
a404 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d414 1
a414 1
    if(!info->directRenderingEnabled)
d418 1
a418 1
	OUTREG(RADEON_MC_AGP_LOCATION, 0xfffff000);
a420 1

d460 388
a847 13
#define ACCEL_MMIO
#define ACCEL_PREAMBLE()        unsigned char *RADEONMMIO = info->MMIO
#define BEGIN_ACCEL(n)          RADEONWaitForFifo(pScrn, (n))
#define OUT_ACCEL_REG(reg, val) OUTREG(reg, val)
#define FINISH_ACCEL()

#include "radeon_accelfuncs.c"

#undef ACCEL_MMIO
#undef ACCEL_PREAMBLE
#undef BEGIN_ACCEL
#undef OUT_ACCEL_REG
#undef FINISH_ACCEL
d849 247
d1098 7
a1104 7
#define ACCEL_CP
#define ACCEL_PREAMBLE()						\
    RING_LOCALS;							\
    RADEONCP_REFRESH(pScrn, info)
#define BEGIN_ACCEL(n)          BEGIN_RING(2*(n))
#define OUT_ACCEL_REG(reg, val) OUT_RING_REG(reg, val)
#define FINISH_ACCEL()          ADVANCE_RING()
d1106 1
a1106 1
#include "radeon_accelfuncs.c"
d1108 1
a1108 5
#undef ACCEL_CP
#undef ACCEL_PREAMBLE
#undef BEGIN_ACCEL
#undef OUT_ACCEL_REG
#undef FINISH_ACCEL
d1110 41
a1150 2
/* Stop the CP */
int RADEONCPStop(ScrnInfoPtr pScrn, RADEONInfoPtr info)
d1152 4
a1155 2
    drmRadeonCPStop  stop;
    int              ret, i;
d1157 2
a1158 2
    stop.flush = 1;
    stop.idle  = 1;
d1160 26
a1185 2
    ret = drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP, &stop,
			  sizeof(drmRadeonCPStop));
d1187 1
a1187 4
    if (ret == 0) {
	return 0;
    } else if (errno != EBUSY) {
	return -errno;
d1189 39
d1229 1
a1229 1
    stop.flush = 0;
d1231 15
a1245 5
    i = 0;
    do {
	ret = drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP, &stop,
			      sizeof(drmRadeonCPStop));
    } while (ret && errno == EBUSY && i++ < RADEON_IDLE_RETRY);
d1247 36
a1282 4
    if (ret == 0) {
	return 0;
    } else if (errno != EBUSY) {
	return -errno;
d1284 5
d1290 1
a1290 1
    stop.idle = 0;
d1292 18
a1309 5
    if (drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP,
			&stop, sizeof(drmRadeonCPStop))) {
	return -errno;
    } else {
	return 0;
d1311 14
d1327 6
a1332 2
/* Get an indirect buffer for the CP 2D acceleration commands  */
drmBufPtr RADEONCPGetBuffer(ScrnInfoPtr pScrn)
d1334 121
a1454 7
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    drmDMAReq      dma;
    drmBufPtr      buf = NULL;
    int            indx = 0;
    int            size = 0;
    int            i = 0;
    int            ret;
d1458 3
a1460 4
     * called from RADEONSelectBuffer via RADEONDRICPInit.  We could use
     * the screen index from pScrn, which is initialized, and then get
     * the screen from screenInfo.screens[index], but that is a hack.
     */
d1463 1
a1463 2
    /* This is the X server's context */
    dma.context = 0x00000001;
d1465 4
a1468 5

    dma.send_count    = 0;
    dma.send_list     = NULL;
    dma.send_sizes    = NULL;
    dma.flags         = 0;
d1470 2
a1471 2
    dma.request_size  = RADEON_BUFFER_SIZE;
    dma.request_list  = &indx;
d1475 1
a1475 1
    while (1) {
d1477 4
a1480 4
	    ret = drmDMA(info->drmFD, &dma);
	    if (ret && ret != -EBUSY) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "%s: CP GetBuffer %d\n", __FUNCTION__, ret);
d1482 1
a1482 1
	} while ((ret == -EBUSY) && (i++ < RADEON_TIMEOUT));
d1484 1
a1484 1
	if (ret == 0) {
d1487 3
a1489 4
	    if (RADEON_VERBOSE) {
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "   GetBuffer returning %d %p\n",
			   buf->idx, buf->address);
d1494 4
a1497 4
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "GetBuffer timed out, resetting engine...\n");
	RADEONEngineReset(pScrn);
	RADEONEngineRestore(pScrn);
d1500 2
a1501 2
	RADEONCP_RESET(pScrn, info);
	RADEONCP_START(pScrn, info);
d1505 3
a1507 2
/* Flush the indirect buffer to the kernel for submission to the card */
void RADEONCPFlushIndirect(ScrnInfoPtr pScrn, int discard)
d1509 4
a1512 4
    RADEONInfoPtr      info   = RADEONPTR(pScrn);
    drmBufPtr          buffer = info->indirectBuffer;
    int                start  = info->indirectStart;
    drmRadeonIndirect  indirect;
d1514 2
a1515 2
    if (!buffer) return;
    if (start == buffer->used && !discard) return;
d1517 2
a1518 4
    if (RADEON_VERBOSE) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Flushing buffer %d\n",
		   buffer->idx);
    }
d1520 1
a1520 4
    indirect.idx     = buffer->idx;
    indirect.start   = start;
    indirect.end     = buffer->used;
    indirect.discard = discard;
d1522 2
a1523 2
    drmCommandWriteRead(info->drmFD, DRM_RADEON_INDIRECT,
			&indirect, sizeof(drmRadeonIndirect));
d1525 3
a1527 3
    if (discard) {
	info->indirectBuffer = RADEONCPGetBuffer(pScrn);
	info->indirectStart  = 0;
d1529 1
a1529 6
	/* Start on a double word boundary */
	info->indirectStart  = buffer->used = (buffer->used + 7) & ~7;
	if (RADEON_VERBOSE) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "   Starting at %d\n",
		       info->indirectStart);
	}
d1533 3
a1535 2
/* Flush and release the indirect buffer */
void RADEONCPReleaseIndirect(ScrnInfoPtr pScrn)
d1537 3
a1539 4
    RADEONInfoPtr      info   = RADEONPTR(pScrn);
    drmBufPtr          buffer = info->indirectBuffer;
    int                start  = info->indirectStart;
    drmRadeonIndirect  indirect;
d1542 148
a1689 1
    info->indirectStart  = 0;
a1690 1
    if (!buffer) return;
d1692 13
a1704 3
    if (RADEON_VERBOSE) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Releasing buffer %d\n",
		   buffer->idx);
d1707 18
a1724 4
    indirect.idx     = buffer->idx;
    indirect.start   = start;
    indirect.end     = buffer->used;
    indirect.discard = 1;
d1726 11
a1736 2
    drmCommandWriteRead(info->drmFD, DRM_RADEON_INDIRECT,
			&indirect, sizeof(drmRadeonIndirect));
a1737 1
#endif
d1740 1
a1740 2
 * graphics hardware for acceleration
 */
d1743 9
a1751 7
    ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
    RADEONInfoPtr  info  = RADEONPTR(pScrn);
    XAAInfoRecPtr  a;

    if (!(a = info->accel = XAACreateInfoRec())) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "XAACreateInfoRec Error\n");
	return FALSE;
a1752 1

d1755 1
a1755 1
	RADEONAccelInitCP(pScreen, a);
d1758 1
a1758 1
	RADEONAccelInitMMIO(pScreen, a);
d1761 7
a1767 6

    if (!XAAInit(pScreen, a)) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "XAAInit Error\n");
	return FALSE;
    }

@


1.1.9.2
log
@Import XFree86 4.4 from The XFree86(TM) Project, Inc.
(integrity cannot be checked)

got via cvs -qd anoncvs@@anoncvs.xfree86.org:/cvs co -Prxf-4_4_0 xc
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c,v 1.37 2004/02/19 22:38:12 tsi Exp $ */
d298 2
a299 4
    /* Restore SURFACE_CNTL - only the first head contains valid data -ReneR */
    if (!info->IsSecondary) {
	OUTREG(RADEON_SURFACE_CNTL, info->ModeReg.surface_cntl);
    }
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c,v 1.32 2003/01/17 19:54:03 martin Exp $ */
d32 1
a32 1
 *   Kevin E. Martin <martin@@xfree86.org>
d34 1
a34 1
 *   Alan Hourihane <alanh@@fairlite.demon.co.uk>
a74 1
#include "radeon_macros.h"
d114 2
a115 3
/* The FIFO has 64 slots.  This routines waits until at least `entries'
 * of these slots are empty.
 */
d118 1
a118 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d120 1
a120 1
    int            i;
d136 1
a137 1
	    RADEONCP_RESET(pScrn, info);
d144 74
a217 1
/* Flush all dirty data in the Pixel Cache to memory */
d220 1
a220 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d222 1
a222 1
    int            i;
d224 2
a225 3
    OUTREGP(RADEON_RB2D_DSTCACHE_CTLSTAT,
	    RADEON_RB2D_DC_FLUSH_ALL,
	    ~RADEON_RB2D_DC_FLUSH_ALL);
d227 1
a227 2
	if (!(INREG(RADEON_RB2D_DSTCACHE_CTLSTAT) & RADEON_RB2D_DC_BUSY))
	    break;
d231 1
a231 1
/* Reset graphics card to known state */
d234 1
a234 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d236 4
a239 4
    CARD32         clock_cntl_index;
    CARD32         mclk_cntl;
    CARD32         rbbm_soft_reset;
    CARD32         host_path_cntl;
d244 1
a244 1
    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);
a245 18
    /* Some ASICs have bugs with dynamic-on feature, which are
     * ASIC-version dependent, so we force all blocks on for now
     */
    if (info->HasCRTC2) {
	CARD32 tmp;

	tmp = INPLL(pScrn, RADEON_SCLK_CNTL);
	OUTPLL(RADEON_SCLK_CNTL, ((tmp & ~RADEON_DYN_STOP_LAT_MASK) |
				  RADEON_CP_MAX_DYN_STOP_LAT |
				  RADEON_SCLK_FORCEON_MASK));

	if (info->ChipFamily == CHIP_FAMILY_RV200) {
	    tmp = INPLL(pScrn, RADEON_SCLK_MORE_CNTL);
	    OUTPLL(RADEON_SCLK_MORE_CNTL, tmp | RADEON_SCLK_MORE_FORCEON);
	}
    }

    mclk_cntl = INPLL(pScrn, RADEON_MCLK_CNTL);
d254 25
a278 38
    /* Soft resetting HDP thru RBBM_SOFT_RESET register can cause some
     * unexpected behaviour on some machines.  Here we use
     * RADEON_HOST_PATH_CNTL to reset it.
     */
    host_path_cntl = INREG(RADEON_HOST_PATH_CNTL);
    rbbm_soft_reset = INREG(RADEON_RBBM_SOFT_RESET);

    if (info->ChipFamily == CHIP_FAMILY_R300) {
	CARD32 tmp;

	OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset |
					RADEON_SOFT_RESET_CP |
					RADEON_SOFT_RESET_HI |
					RADEON_SOFT_RESET_E2));
	INREG(RADEON_RBBM_SOFT_RESET);
	OUTREG(RADEON_RBBM_SOFT_RESET, 0);
	tmp = INREG(RADEON_RB2D_DSTCACHE_MODE);
	OUTREG(RADEON_RB2D_DSTCACHE_MODE, tmp | (1 << 17)); /* FIXME */
    } else {
	OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset |
					RADEON_SOFT_RESET_CP |
					RADEON_SOFT_RESET_HI |
					RADEON_SOFT_RESET_SE |
					RADEON_SOFT_RESET_RE |
					RADEON_SOFT_RESET_PP |
					RADEON_SOFT_RESET_E2 |
					RADEON_SOFT_RESET_RB));
	INREG(RADEON_RBBM_SOFT_RESET);
	OUTREG(RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset & (CARD32)
					~(RADEON_SOFT_RESET_CP |
					  RADEON_SOFT_RESET_HI |
					  RADEON_SOFT_RESET_SE |
					  RADEON_SOFT_RESET_RE |
					  RADEON_SOFT_RESET_PP |
					  RADEON_SOFT_RESET_E2 |
					  RADEON_SOFT_RESET_RB)));
	INREG(RADEON_RBBM_SOFT_RESET);
    }
d284 1
a284 2
    if (info->ChipFamily != CHIP_FAMILY_R300)
	OUTREG(RADEON_RBBM_SOFT_RESET, rbbm_soft_reset);
d287 2
a288 2
    OUTPLL(RADEON_MCLK_CNTL, mclk_cntl);
    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);
d291 1
a291 1
/* Restore the acceleration hardware to its previous state */
d294 1
a294 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d296 1
a296 1
    int            pitch64;
d303 2
a304 10

    /* NOTE: The following RB2D_DSTCACHE_MODE setting will cause the
     * R300 to hang.  ATI does not see a reason to change it from the
     * default BIOS settings (even on non-R300 cards).  This setting
     * might be removed in future versions of the Radeon driver.
     */

    /* Turn of all automatic flushing - we'll do it all */
    if (info->ChipFamily != CHIP_FAMILY_R300)
	OUTREG(RADEON_RB2D_DSTCACHE_MODE, 0);
d309 2
a310 2
    OUTREG(RADEON_DEFAULT_OFFSET, ((INREG(RADEON_DEFAULT_OFFSET) & 0xC0000000)
				   | (pitch64 << 22)));
d315 1
a315 2
	    RADEON_HOST_BIG_ENDIAN_EN,
	    ~RADEON_HOST_BIG_ENDIAN_EN);
d320 1
a320 1
    /* Restore SURFACE_CNTL */
d340 34
a373 1
    RADEONWaitForIdleMMIO(pScrn);
d376 4
a379 2
/* Initialize the acceleration hardware */
void RADEONEngineInit(ScrnInfoPtr pScrn)
d381 24
a404 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d414 1
a414 1
    if(!info->directRenderingEnabled)
a420 1

d460 72
a531 13
#define ACCEL_MMIO
#define ACCEL_PREAMBLE()        unsigned char *RADEONMMIO = info->MMIO
#define BEGIN_ACCEL(n)          RADEONWaitForFifo(pScrn, (n))
#define OUT_ACCEL_REG(reg, val) OUTREG(reg, val)
#define FINISH_ACCEL()

#include "radeon_accelfuncs.c"

#undef ACCEL_MMIO
#undef ACCEL_PREAMBLE
#undef BEGIN_ACCEL
#undef OUT_ACCEL_REG
#undef FINISH_ACCEL
d533 563
d1098 338
a1435 55
#define ACCEL_CP
#define ACCEL_PREAMBLE()						\
    RING_LOCALS;							\
    RADEONCP_REFRESH(pScrn, info)
#define BEGIN_ACCEL(n)          BEGIN_RING(2*(n))
#define OUT_ACCEL_REG(reg, val) OUT_RING_REG(reg, val)
#define FINISH_ACCEL()          ADVANCE_RING()

#include "radeon_accelfuncs.c"

#undef ACCEL_CP
#undef ACCEL_PREAMBLE
#undef BEGIN_ACCEL
#undef OUT_ACCEL_REG
#undef FINISH_ACCEL

/* Stop the CP */
int RADEONCPStop(ScrnInfoPtr pScrn, RADEONInfoPtr info)
{
    drmRadeonCPStop  stop;
    int              ret, i;

    stop.flush = 1;
    stop.idle  = 1;

    ret = drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP, &stop, 
			  sizeof(drmRadeonCPStop));

    if (ret == 0) {
	return 0;
    } else if (errno != EBUSY) {
	return -errno;
    }

    stop.flush = 0;
 
    i = 0;
    do {
	ret = drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP, &stop, 
			      sizeof(drmRadeonCPStop));
    } while (ret && errno == EBUSY && i++ < RADEON_IDLE_RETRY);

    if (ret == 0) {
	return 0;
    } else if (errno != EBUSY) {
	return -errno;
    }

    stop.idle = 0;

    if (drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP,
			&stop, sizeof(drmRadeonCPStop))) {
	return -errno;
    } else {
	return 0;
d1437 6
d1445 3
a1447 2
/* Get an indirect buffer for the CP 2D acceleration commands  */
drmBufPtr RADEONCPGetBuffer(ScrnInfoPtr pScrn)
d1449 6
a1454 7
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    drmDMAReq      dma;
    drmBufPtr      buf = NULL;
    int            indx = 0;
    int            size = 0;
    int            i = 0;
    int            ret;
d1458 3
a1460 4
     * called from RADEONSelectBuffer via RADEONDRICPInit.  We could use
     * the screen index from pScrn, which is initialized, and then get
     * the screen from screenInfo.screens[index], but that is a hack.
     */
d1463 1
a1463 2
    /* This is the X server's context */
    dma.context = 0x00000001;
d1465 4
a1468 5

    dma.send_count    = 0;
    dma.send_list     = NULL;
    dma.send_sizes    = NULL;
    dma.flags         = 0;
d1470 2
a1471 2
    dma.request_size  = RADEON_BUFFER_SIZE;
    dma.request_list  = &indx;
d1475 1
a1475 1
    while (1) {
d1477 4
a1480 4
	    ret = drmDMA(info->drmFD, &dma);
	    if (ret && ret != -EBUSY) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "%s: CP GetBuffer %d\n", __FUNCTION__, ret);
d1482 1
a1482 1
	} while ((ret == -EBUSY) && (i++ < RADEON_TIMEOUT));
d1484 1
a1484 1
	if (ret == 0) {
d1487 3
a1489 4
	    if (RADEON_VERBOSE) {
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "   GetBuffer returning %d %08x\n",
			   buf->idx, buf->address);
d1494 4
a1497 4
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "GetBuffer timed out, resetting engine...\n");
	RADEONEngineReset(pScrn);
	RADEONEngineRestore(pScrn);
d1500 2
a1501 2
	RADEONCP_RESET(pScrn, info);
	RADEONCP_START(pScrn, info);
d1505 3
a1507 2
/* Flush the indirect buffer to the kernel for submission to the card */
void RADEONCPFlushIndirect(ScrnInfoPtr pScrn, int discard)
d1509 4
a1512 4
    RADEONInfoPtr      info   = RADEONPTR(pScrn);
    drmBufPtr          buffer = info->indirectBuffer;
    int                start  = info->indirectStart;
    drmRadeonIndirect  indirect;
d1514 2
a1515 2
    if (!buffer) return;
    if (start == buffer->used && !discard) return;
d1517 2
a1518 4
    if (RADEON_VERBOSE) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Flushing buffer %d\n",
		   buffer->idx);
    }
d1520 1
a1520 4
    indirect.idx     = buffer->idx;
    indirect.start   = start;
    indirect.end     = buffer->used;
    indirect.discard = discard;
d1522 2
a1523 2
    drmCommandWriteRead(info->drmFD, DRM_RADEON_INDIRECT,
			&indirect, sizeof(drmRadeonIndirect));
d1525 3
a1527 3
    if (discard) {
	info->indirectBuffer = RADEONCPGetBuffer(pScrn);
	info->indirectStart  = 0;
d1529 1
a1529 6
	/* Start on a double word boundary */
	info->indirectStart  = buffer->used = (buffer->used + 7) & ~7;
	if (RADEON_VERBOSE) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "   Starting at %d\n",
		       info->indirectStart);
	}
d1533 3
a1535 2
/* Flush and release the indirect buffer */
void RADEONCPReleaseIndirect(ScrnInfoPtr pScrn)
d1537 3
a1539 4
    RADEONInfoPtr      info   = RADEONPTR(pScrn);
    drmBufPtr          buffer = info->indirectBuffer;
    int                start  = info->indirectStart;
    drmRadeonIndirect  indirect;
d1542 148
a1689 1
    info->indirectStart  = 0;
a1690 1
    if (!buffer) return;
d1692 13
a1704 3
    if (RADEON_VERBOSE) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Releasing buffer %d\n",
		   buffer->idx);
d1707 18
a1724 4
    indirect.idx     = buffer->idx;
    indirect.start   = start;
    indirect.end     = buffer->used;
    indirect.discard = 1;
d1726 11
a1736 2
    drmCommandWriteRead(info->drmFD, DRM_RADEON_INDIRECT,
			&indirect, sizeof(drmRadeonIndirect));
a1737 1
#endif
d1740 1
a1740 2
 * graphics hardware for acceleration
 */
d1743 9
a1751 7
    ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
    RADEONInfoPtr  info  = RADEONPTR(pScrn);
    XAAInfoRecPtr  a;

    if (!(a = info->accel = XAACreateInfoRec())) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "XAACreateInfoRec Error\n");
	return FALSE;
a1752 1

d1755 1
a1755 1
	RADEONAccelInitCP(pScreen, a);
d1758 1
a1758 1
	RADEONAccelInitMMIO(pScreen, a);
d1761 7
a1767 6

    if (!XAAInit(pScreen, a)) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "XAAInit Error\n");
	return FALSE;
    }

@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c,v 1.36 2003/11/10 18:41:22 tsi Exp $ */
d210 1
a210 3
    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {
d246 1
a246 3
    if ((info->ChipFamily != CHIP_FAMILY_R300) &&
        (info->ChipFamily != CHIP_FAMILY_R350) &&
        (info->ChipFamily != CHIP_FAMILY_RV350))
d274 1
a274 3
    if ((info->ChipFamily != CHIP_FAMILY_R300) &&
	(info->ChipFamily != CHIP_FAMILY_R350) &&
	(info->ChipFamily != CHIP_FAMILY_RV350))
d280 1
a280 1
    OUTREG(RADEON_DEFAULT_OFFSET, ((INREG(RADEON_DISPLAY_BASE_ADDR) >> 10)
d332 1
a332 1
	OUTREG(RADEON_MC_AGP_LOCATION, 0xfffff000);
d416 1
a416 1
    ret = drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP, &stop,
d426 1
a426 1

d429 1
a429 1
	ret = drmCommandWrite(info->drmFD, DRM_RADEON_CP_STOP, &stop,
d496 1
a496 1
			   "   GetBuffer returning %d %p\n",
@


1.1.1.4
log
@Import OpenBSD X-Window subsystem (based upon XFree86 4.4RC2)
into vendor branch
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_accel.c,v 1.37 2004/02/19 22:38:12 tsi Exp $ */
d298 2
a299 4
    /* Restore SURFACE_CNTL - only the first head contains valid data -ReneR */
    if (!info->IsSecondary) {
	OUTREG(RADEON_SURFACE_CNTL, info->ModeReg.surface_cntl);
    }
@


