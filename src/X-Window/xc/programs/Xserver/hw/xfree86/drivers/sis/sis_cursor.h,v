head	1.2;
access;
symbols
	tg-mergetmp-2:1.2
	cvs-200410241530:1.1.1.4
	cvs-200410012000:1.1.1.4
	cvs-200407221130:1.1.1.4
	cvs-200407141120:1.1.1.4
	cvs-200406231010:1.1.1.4
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.4
	XFree86_4_4_0:1.1.9.2
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.03.07.18.37.31;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.20.07.29;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.07.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.36.42;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.19.42;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.27.16.33.05;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.23.53;	author tg;	state Exp;
branches;
next	1.1.9.2;

1.1.9.2
date	2004.03.05.22.30.08;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@semi-automagic merge of these files (ie, I've skipped through the diffs,
and most of that was done by cvs or that weird script of some minutes ago)
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_cursor.h,v 1.17 2004/02/25 17:45:13 twini Exp $ */
/*
 * SiS hardware cursor handling
 * Definitions
 *
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author:   Thomas Winischhofer <thomas@@winischhofer.net>
 *
 * Idea based on code by Can-Ru Yeou, SiS Inc.
 *
 */

#define CS(x)   (0x8500 + (x << 2))

/* 300 series, CRT1 */

/* 80000000 = RGB(1) - MONO(0)
 * 40000000 = enable(1) - disable(0)
 * 20000000 = 32(1) / 16(1) bit RGB
 * 10000000 = "ghost"(1) - [other effect](0)
 */

#define sis300GetCursorStatus \
  MMIO_IN32(pSiS->IOBase, CS(0)) & 0x40000000;
  
#define sis300SetCursorStatus(status) \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0xbfffffff; \
  temp |= status; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }

#define sis300EnableHWCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0x0fffffff; \
  temp |= 0x40000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }
  
#define sis300EnableHWARGBCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp |= 0xF0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }

#define sis300EnableHWARGB16Cursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0x0fffffff; \
  temp |= 0xD0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }

#define sis300SwitchToMONOCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0x4fffffff; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }
  
#define sis300SwitchToRGBCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp |= 0xB0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }
  
#define sis300DisableHWCursor()\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0xbFFFFFFF; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }

#define sis300SetCursorBGColor(color)\
  MMIO_OUT32(pSiS->IOBase, CS(1), (color));
#define sis300SetCursorFGColor(color)\
  MMIO_OUT32(pSiS->IOBase, CS(2), (color));

#define sis300SetCursorPositionX(x,preset)\
  MMIO_OUT32(pSiS->IOBase, CS(3), ((x) | ((preset) << 16)));
#define sis300SetCursorPositionY(y,preset)\
  MMIO_OUT32(pSiS->IOBase, CS(4), ((y) | ((preset) << 16)));

#define sis300SetCursorAddress(address)\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0xF0FF0000; \
  temp |= address; \
  MMIO_OUT32(pSiS->IOBase,CS(0),temp); \
  }

/* 300 series, CRT2 */

/* 80000000 = RGB(1) - MONO(0)
 * 40000000 = enable(1) - disable(0)
 * 20000000 = 32(1) / 16(1) bit RGB
 * 10000000 = unused (always "ghosting")
 */

#define sis301GetCursorStatus \
  MMIO_IN32(pSiS->IOBase, CS(8)) & 0x40000000;
  
#define sis301SetCursorStatus(status) \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0xbfffffff; \
  temp |= status; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301EnableHWCursor()\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0x0fffffff; \
  temp |= 0x40000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301EnableHWARGBCursor()\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp |= 0xF0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301EnableHWARGB16Cursor()\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0x0FFFFFFF; \
  temp |= 0xD0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301SwitchToRGBCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp |= 0xB0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301SwitchToMONOCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0x4fffffff; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
 
#define sis301DisableHWCursor()\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0xbFFFFFFF; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301SetCursorBGColor(color)\
  MMIO_OUT32(pSiS->IOBase, CS(9), (color));
#define sis301SetCursorFGColor(color)\
  MMIO_OUT32(pSiS->IOBase, CS(10), (color));

#define sis301SetCursorPositionX(x,preset)\
  MMIO_OUT32(pSiS->IOBase, CS(11), ((x) | ((preset) << 16)));
#define sis301SetCursorPositionY(y,preset)\
  MMIO_OUT32(pSiS->IOBase, CS(12), ((y) | ((preset) << 16)));

#define sis301SetCursorAddress(address)\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0xF0FF0000; \
  temp |= address; \
  MMIO_OUT32(pSiS->IOBase,CS(8),temp); \
  }

/* 315/330 series CRT1 */

/* 80000000 = RGB(1) - MONO(0)
 * 40000000 = enable(1) - disable(0)
 * 20000000 = 32(1) / 16(1) bit RGB
 * 10000000 = "ghost"(1) - Alpha Blend(0)
 */
 
#define sis310GetCursorStatus \
  MMIO_IN32(pSiS->IOBase, CS(0)) & 0x40000000;
  
#define sis310SetCursorStatus(status) \
  pSiS->HWCursorBackup[0] &= 0xbfffffff; \
  pSiS->HWCursorBackup[0] |= status; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);

#define sis310EnableHWCursor()\
  pSiS->HWCursorBackup[0] &= 0x0fffffff; \
  pSiS->HWCursorBackup[0] |= 0x40000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);
  
#define sis310EnableHWARGBCursor()\
  pSiS->HWCursorBackup[0] &= 0x0FFFFFFF; \
  pSiS->HWCursorBackup[0] |= 0xE0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);

#define sis310SwitchToMONOCursor() \
  pSiS->HWCursorBackup[0] &= 0x4fffffff; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);

#define sis310SwitchToRGBCursor() \
  pSiS->HWCursorBackup[0] &= 0xBFFFFFFF; \
  pSiS->HWCursorBackup[0] |= 0xA0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);

#define sis310DisableHWCursor()\
  pSiS->HWCursorBackup[0] &= 0xBFFFFFFF; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);
  
#define sis310SetCursorBGColor(color) \
  MMIO_OUT32(pSiS->IOBase, CS(1), (color)); \
  pSiS->HWCursorBackup[1] = color;

#define sis310SetCursorFGColor(color)\
  MMIO_OUT32(pSiS->IOBase, CS(2), (color)); \
  pSiS->HWCursorBackup[2] = color;

#define sis310SetCursorPositionX(x,preset) \
  pSiS->HWCursorBackup[3] = ((x) | ((preset) << 16)); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]);

#define sis310SetCursorPositionY(y,preset) \
  pSiS->HWCursorBackup[4] = ((y) | ((preset) << 16)); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);

#define sis310SetCursorAddress(address)\
  pSiS->HWCursorBackup[0] &= 0xF0F00000; \
  pSiS->HWCursorBackup[0] |= address; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(1), pSiS->HWCursorBackup[1]); \
  MMIO_OUT32(pSiS->IOBase, CS(2), pSiS->HWCursorBackup[2]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);

/* 315 series CRT2 */

/* 80000000 = RGB(1) - MONO(0)
 * 40000000 = enable(1) - disable(0)
 * 20000000 = 32(1) / 16(1) bit RGB
 * 10000000 = "ghost"(1) - Alpha Blend(0)  ?
 */

#define sis301GetCursorStatus310 \
  MMIO_IN32(pSiS->IOBase, CS(8)) & 0x40000000;

#define sis301SetCursorStatus310(status) \
  pSiS->HWCursorBackup[8] &= 0xbfffffff; \
  pSiS->HWCursorBackup[8] |= status; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

#define sis301EnableHWCursor310()\
  pSiS->HWCursorBackup[8] &= 0x0fffffff; \
  pSiS->HWCursorBackup[8] |= 0x40000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

#define sis301EnableHWARGBCursor310()\
  pSiS->HWCursorBackup[8] &= 0x0FFFFFFF; \
  pSiS->HWCursorBackup[8] |= 0xE0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

#define sis301SwitchToRGBCursor310() \
  pSiS->HWCursorBackup[8] &= 0xBFFFFFFF; \
  pSiS->HWCursorBackup[8] |= 0xA0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

#define sis301SwitchToMONOCursor310() \
  pSiS->HWCursorBackup[8] &= 0x4fffffff; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

#define sis301DisableHWCursor310()\
  pSiS->HWCursorBackup[8] &= 0xBFFFFFFF; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

#define sis301SetCursorBGColor310(color) \
  MMIO_OUT32(pSiS->IOBase, CS(9), (color)); \
  pSiS->HWCursorBackup[9] = color;

#define sis301SetCursorFGColor310(color) \
  MMIO_OUT32(pSiS->IOBase, CS(10), (color)); \
  pSiS->HWCursorBackup[10] = color;

#define sis301SetCursorPositionX310(x,preset) \
  pSiS->HWCursorBackup[11] = ((x) | ((preset) << 16)); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]);

#define sis301SetCursorPositionY310(y,preset) \
  pSiS->HWCursorBackup[12] = ((y) | ((preset) << 16)); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

#define sis301SetCursorAddress310(address) \
  if(pSiS->sishw_ext.jChipType == SIS_315H) { \
     if(address & 0x10000) { \
        address &= ~0x10000; \
	orSISIDXREG(SISSR, 0x37, 0x80); \
     } else { \
        andSISIDXREG(SISSR, 0x37, 0x7f); \
     } \
  } \
  pSiS->HWCursorBackup[8] &= 0xF0F00000; \
  pSiS->HWCursorBackup[8] |= address; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]);  \
  MMIO_OUT32(pSiS->IOBase, CS(9),  pSiS->HWCursorBackup[9]);  \
  MMIO_OUT32(pSiS->IOBase, CS(10), pSiS->HWCursorBackup[10]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

/* 330 series CRT2 */

/* Mono cursor engine for CRT2 on SiS330 (Xabre) has bugs
 * and cannot be used! Will hang engine.
 */

/* 80000000 = RGB(1) - MONO(0)
 * 40000000 = enable(1) - disable(0)
 * 20000000 = 32(1) / 16(1) bit RGB
 * 10000000 = "ghost"(1) - Alpha Blend(0)  ?
 */

#define sis301EnableHWCursor330() \
  /* andSISIDXREG(SISCR,0x5b,~0x10); */ \
  pSiS->HWCursorBackup[8] &= 0x0fffffff; \
  pSiS->HWCursorBackup[8] |= 0xE0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]); \
  /* orSISIDXREG(SISCR,0x5b,0x10); */



@


1.1
log
@Initial revision
@
text
@d1 1
d3 30
a32 1
 * Copyright 1998,1999 by Alan Hourihane, Wigan, England.
a33 23
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Alan Hourihane not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Alan Hourihane makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
 *
 * ALAN HOURIHANE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL ALAN HOURIHANE BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors:  Alan Hourihane, alanh@@fairlite.demon.co.uk
 *           Mike Chapman <mike@@paranoia.com>, 
 *           Juanjo Santamarta <santamarta@@ctv.es>, 
 *           Mitani Hiroshi <hmitani@@drl.mei.co.jp> 
 *           David Thomas <davtom@@dream.org.uk>. 
a34 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_cursor.h,v 1.2 2001/04/19 12:40:33 alanh Exp $ */
d36 3
a38 1
#define CS(x)   (0x8500+(x<<2))
d40 60
a99 2
#define sis300EnableHWCursor()\
  *(volatile CARD32 *)(pSiS->IOBase + CS(0)) |= 0x40000000;
d101 6
a106 1
  *(volatile CARD32 *)(pSiS->IOBase + CS(0)) &= 0x3FFFFFFF;
d109 1
a109 1
  *(volatile CARD32 *)(pSiS->IOBase + CS(1)) = (color);
d111 1
a111 1
  *(volatile CARD32 *)(pSiS->IOBase + CS(2)) = (color);
d114 1
a114 1
  *(volatile CARD32 *)(pSiS->IOBase + CS(3)) = (x) | ((preset) << 16);
d116 1
a116 1
  *(volatile CARD32 *)(pSiS->IOBase + CS(4)) = (y) | ((preset) << 16);
d119 15
a133 8
  *(volatile CARD32 *)(pSiS->IOBase + CS(0)) &= 0xFFFF0000;\
  *(volatile CARD32 *)(pSiS->IOBase + CS(0)) |= address;

#define sis300SetCursorPatternSelect(pat_id)\
  *(volatile CARD32 *)(pSiS->IOBase + CS(0)) &= 0xF0FFFFFF;\
  *(volatile CARD32 *)(pSiS->IOBase + CS(0)) |= ((pat_id) << 24);


d135 12
d148 41
a188 1
  *(volatile CARD32 *)(pSiS->IOBase + CS(8)) |= 0x40000000;
d190 7
a196 2
  *(volatile CARD32 *)(pSiS->IOBase + CS(8)) &= 0xBFFFFFFF;

d198 1
a198 1
  *(volatile CARD32 *)(pSiS->IOBase + CS(9)) = (color);
d200 1
a200 1
  *(volatile CARD32 *)(pSiS->IOBase + CS(10)) = (color);
d203 1
a203 1
  *(volatile CARD32 *)(pSiS->IOBase + CS(11)) = (x) | ((preset) << 16);
d205 1
a205 1
  *(volatile CARD32 *)(pSiS->IOBase + CS(12)) = (y) | ((preset) << 16);
d208 190
a397 2
  *(volatile CARD32 *)(pSiS->IOBase + CS(8)) &= 0xFFFF0000;\
  *(volatile CARD32 *)(pSiS->IOBase + CS(8)) |= address;
a398 3
#define sis301SetCursorPatternSelect(pat_id)\
  *(volatile CARD32 *)(pSiS->IOBase + CS(8)) &= 0xF0FFFFFF;\
  *(volatile CARD32 *)(pSiS->IOBase + CS(8)) |= ((pat_id) << 24);
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@a0 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_cursor.h,v 1.15 2004/01/23 22:29:04 twini Exp $ */
d2 1
a2 33
 * SiS hardware cursor handling
 * Definitions
 *
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement: "This product includes
 *    software developed by Thomas Winischhofer, Vienna, Austria."
 * 4) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author:   Thomas Winischhofer <thomas@@winischhofer.net>
 *
 * Idea based on code by Can-Ru Yeou, SiS Inc.
d4 23
d28 1
d30 1
a30 3
#define CS(x)   (0x8500 + (x << 2))

/* 300 series, CRT1 */
d32 2
a33 60
/* 80000000 = RGB(1) - MONO(0)
 * 40000000 = enable(1) - disable(0)
 * 20000000 = 32(1) / 16(1) bit RGB
 * 10000000 = "ghost"(1) - [other effect](0)
 */

#define sis300GetCursorStatus \
  MMIO_IN32(pSiS->IOBase, CS(0)) & 0x40000000;
  
#define sis300SetCursorStatus(status) \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0xbfffffff; \
  temp |= status; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }

#define sis300EnableHWCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0x0fffffff; \
  temp |= 0x40000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }
  
#define sis300EnableHWARGBCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp |= 0xF0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }

#define sis300EnableHWARGB16Cursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0x0fffffff; \
  temp |= 0xD0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }

#define sis300SwitchToMONOCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0x4fffffff; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }
  
#define sis300SwitchToRGBCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp |= 0xB0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }
  
d35 1
a35 6
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0xbFFFFFFF; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }
d38 1
a38 1
  MMIO_OUT32(pSiS->IOBase, CS(1), (color));
d40 1
a40 1
  MMIO_OUT32(pSiS->IOBase, CS(2), (color));
d43 1
a43 1
  MMIO_OUT32(pSiS->IOBase, CS(3), ((x) | ((preset) << 16)));
d45 1
a45 1
  MMIO_OUT32(pSiS->IOBase, CS(4), ((y) | ((preset) << 16)));
d48 8
a55 15
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0xF0FF0000; \
  temp |= address; \
  MMIO_OUT32(pSiS->IOBase,CS(0),temp); \
  }

/* 300 series, CRT2 */

/* 80000000 = RGB(1) - MONO(0)
 * 40000000 = enable(1) - disable(0)
 * 20000000 = 32(1) / 16(1) bit RGB
 * 10000000 = unused (always "ghosting")
 */
a56 12
#define sis301GetCursorStatus \
  MMIO_IN32(pSiS->IOBase, CS(8)) & 0x40000000;
  
#define sis301SetCursorStatus(status) \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0xbfffffff; \
  temp |= status; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
d58 1
a58 41
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0x0fffffff; \
  temp |= 0x40000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301EnableHWARGBCursor()\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp |= 0xF0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301EnableHWARGB16Cursor()\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0x0FFFFFFF; \
  temp |= 0xD0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301SwitchToRGBCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp |= 0xB0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301SwitchToMONOCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0x4fffffff; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
 
d60 2
a61 7
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0xbFFFFFFF; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
d63 1
a63 1
  MMIO_OUT32(pSiS->IOBase, CS(9), (color));
d65 1
a65 1
  MMIO_OUT32(pSiS->IOBase, CS(10), (color));
d68 1
a68 1
  MMIO_OUT32(pSiS->IOBase, CS(11), ((x) | ((preset) << 16)));
d70 1
a70 1
  MMIO_OUT32(pSiS->IOBase, CS(12), ((y) | ((preset) << 16)));
d73 2
a74 190
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0xF0FF0000; \
  temp |= address; \
  MMIO_OUT32(pSiS->IOBase,CS(8),temp); \
  }

/* 315/330 series CRT1 */

/* 80000000 = RGB(1) - MONO(0)
 * 40000000 = enable(1) - disable(0)
 * 20000000 = 32(1) / 16(1) bit RGB
 * 10000000 = "ghost"(1) - Alpha Blend(0)
 */
 
#define sis310GetCursorStatus \
  MMIO_IN32(pSiS->IOBase, CS(0)) & 0x40000000;
  
#define sis310SetCursorStatus(status) \
  pSiS->HWCursorBackup[0] &= 0xbfffffff; \
  pSiS->HWCursorBackup[0] |= status; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);

#define sis310EnableHWCursor()\
  pSiS->HWCursorBackup[0] &= 0x0fffffff; \
  pSiS->HWCursorBackup[0] |= 0x40000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);
  
#define sis310EnableHWARGBCursor()\
  pSiS->HWCursorBackup[0] &= 0x0FFFFFFF; \
  pSiS->HWCursorBackup[0] |= 0xE0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);

#define sis310SwitchToMONOCursor() \
  pSiS->HWCursorBackup[0] &= 0x4fffffff; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);

#define sis310SwitchToRGBCursor() \
  pSiS->HWCursorBackup[0] &= 0xBFFFFFFF; \
  pSiS->HWCursorBackup[0] |= 0xA0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);

#define sis310DisableHWCursor()\
  pSiS->HWCursorBackup[0] &= 0xBFFFFFFF; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);
  
#define sis310SetCursorBGColor(color) \
  MMIO_OUT32(pSiS->IOBase, CS(1), (color)); \
  pSiS->HWCursorBackup[1] = color;

#define sis310SetCursorFGColor(color)\
  MMIO_OUT32(pSiS->IOBase, CS(2), (color)); \
  pSiS->HWCursorBackup[2] = color;

#define sis310SetCursorPositionX(x,preset) \
  pSiS->HWCursorBackup[3] = ((x) | ((preset) << 16)); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]);

#define sis310SetCursorPositionY(y,preset) \
  pSiS->HWCursorBackup[4] = ((y) | ((preset) << 16)); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);

#define sis310SetCursorAddress(address)\
  pSiS->HWCursorBackup[0] &= 0xF0F00000; \
  pSiS->HWCursorBackup[0] |= address; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(1), pSiS->HWCursorBackup[1]); \
  MMIO_OUT32(pSiS->IOBase, CS(2), pSiS->HWCursorBackup[2]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);

/* 315 series CRT2 */

/* 80000000 = RGB(1) - MONO(0)
 * 40000000 = enable(1) - disable(0)
 * 20000000 = 32(1) / 16(1) bit RGB
 * 10000000 = "ghost"(1) - Alpha Blend(0)  ?
 */

#define sis301GetCursorStatus310 \
  MMIO_IN32(pSiS->IOBase, CS(8)) & 0x40000000;

#define sis301SetCursorStatus310(status) \
  pSiS->HWCursorBackup[8] &= 0xbfffffff; \
  pSiS->HWCursorBackup[8] |= status; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

#define sis301EnableHWCursor310()\
  pSiS->HWCursorBackup[8] &= 0x0fffffff; \
  pSiS->HWCursorBackup[8] |= 0x40000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

#define sis301EnableHWARGBCursor310()\
  pSiS->HWCursorBackup[8] &= 0x0FFFFFFF; \
  pSiS->HWCursorBackup[8] |= 0xE0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

#define sis301SwitchToRGBCursor310() \
  pSiS->HWCursorBackup[8] &= 0xBFFFFFFF; \
  pSiS->HWCursorBackup[8] |= 0xA0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

#define sis301SwitchToMONOCursor310() \
  pSiS->HWCursorBackup[8] &= 0x4fffffff; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

#define sis301DisableHWCursor310()\
  pSiS->HWCursorBackup[8] &= 0xBFFFFFFF; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

#define sis301SetCursorBGColor310(color) \
  MMIO_OUT32(pSiS->IOBase, CS(9), (color)); \
  pSiS->HWCursorBackup[9] = color;

#define sis301SetCursorFGColor310(color) \
  MMIO_OUT32(pSiS->IOBase, CS(10), (color)); \
  pSiS->HWCursorBackup[10] = color;

#define sis301SetCursorPositionX310(x,preset) \
  pSiS->HWCursorBackup[11] = ((x) | ((preset) << 16)); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]);

#define sis301SetCursorPositionY310(y,preset) \
  pSiS->HWCursorBackup[12] = ((y) | ((preset) << 16)); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

#define sis301SetCursorAddress310(address) \
  if(pSiS->sishw_ext.jChipType == SIS_315H) { \
     if(address & 0x10000) { \
        address &= ~0x10000; \
	orSISIDXREG(SISSR, 0x37, 0x80); \
     } else { \
        andSISIDXREG(SISSR, 0x37, 0x7f); \
     } \
  } \
  pSiS->HWCursorBackup[8] &= 0xF0F00000; \
  pSiS->HWCursorBackup[8] |= address; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]);  \
  MMIO_OUT32(pSiS->IOBase, CS(9),  pSiS->HWCursorBackup[9]);  \
  MMIO_OUT32(pSiS->IOBase, CS(10), pSiS->HWCursorBackup[10]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

/* 330 series CRT2 */

/* Mono cursor engine for CRT2 on SiS330 (Xabre) has bugs
 * and cannot be used! Will hang engine.
 */

/* 80000000 = RGB(1) - MONO(0)
 * 40000000 = enable(1) - disable(0)
 * 20000000 = 32(1) / 16(1) bit RGB
 * 10000000 = "ghost"(1) - Alpha Blend(0)  ?
 */

#define sis301EnableHWCursor330() \
  /* andSISIDXREG(SISCR,0x5b,~0x10); */ \
  pSiS->HWCursorBackup[8] &= 0x0fffffff; \
  pSiS->HWCursorBackup[8] |= 0xE0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]); \
  /* orSISIDXREG(SISCR,0x5b,0x10); */


d76 3
@


1.1.9.2
log
@Import XFree86 4.4 from The XFree86(TM) Project, Inc.
(integrity cannot be checked)

got via cvs -qd anoncvs@@anoncvs.xfree86.org:/cvs co -Prxf-4_4_0 xc
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_cursor.h,v 1.17 2004/02/25 17:45:13 twini Exp $ */
d16 4
a19 1
 * 3) The name of the author may not be used to endorse or promote products
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@a0 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_cursor.h,v 1.5 2003/02/06 13:14:04 eich Exp $ */
a2 1
 * Parts Copyright 2001, 2002 by Thomas Winischhofer, Vienna, Austria.
d8 1
a8 1
 * documentation, and that the name of the copyright holders not be used in
d10 1
a10 1
 * specific, written prior permission.  The copyright holders make no representations
d14 1
a14 1
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
d16 1
a16 1
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
d23 4
a26 5
 *           Mike Chapman <mike@@paranoia.com>,
 *           Juanjo Santamarta <santamarta@@ctv.es>,
 *           Mitani Hiroshi <hmitani@@drl.mei.co.jp>
 *           David Thomas <davtom@@dream.org.uk>.
 *	     Thomas Winischhofer <thomas@@winischhofer.net>:
d28 1
d32 2
a33 62
/* 300 series, CRT1 */

/* 80000000 = RGB(1) - MONO(0)
 * 40000000 = enable(1) - disable(0)
 * 20000000 = 32(1) / 16(1) bit RGB
 * 10000000 = "ghost"(1) - [other effect](0)
 */

#define sis300GetCursorStatus \
  MMIO_IN32(pSiS->IOBase, CS(0)) & 0x40000000;
  
#define sis300SetCursorStatus(status) \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0xbfffffff; \
  temp |= status; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }

#define sis300EnableHWCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0x0fffffff; \
  temp |= 0x40000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }
  
#define sis300EnableHWARGBCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp |= 0xF0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }

#define sis300EnableHWARGB16Cursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0x0fffffff; \
  temp |= 0xD0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }

#define sis300SwitchToMONOCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0x4fffffff; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }
  
#define sis300SwitchToRGBCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp |= 0xB0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }
  
d35 1
a35 6
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0xbFFFFFFF; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }
d38 1
a38 1
  MMIO_OUT32(pSiS->IOBase, CS(1), (color));
d40 1
a40 1
  MMIO_OUT32(pSiS->IOBase, CS(2), (color));
d43 1
a43 1
  MMIO_OUT32(pSiS->IOBase, CS(3), ((x) | ((preset) << 16)));
d45 1
a45 1
  MMIO_OUT32(pSiS->IOBase, CS(4), ((y) | ((preset) << 16)));
d48 2
a49 7
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0xFFFF0000; \
  temp |= address; \
  MMIO_OUT32(pSiS->IOBase,CS(0),temp); \
  }
d52 4
a55 15
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0xF0FFFFFF; \
  temp |= (pat_id) << 24; \
  MMIO_OUT32(pSiS->IOBase,CS(0),temp); \
  }

/* 300 series, CRT2 */

/* 80000000 = RGB(1) - MONO(0)
 * 40000000 = enable(1) - disable(0)
 * 20000000 = 32(1) / 16(1) bit RGB
 * 10000000 = unused (always "ghosting")
 */
a56 12
#define sis301GetCursorStatus \
  MMIO_IN32(pSiS->IOBase, CS(8)) & 0x40000000;
  
#define sis301SetCursorStatus(status) \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0xbfffffff; \
  temp |= status; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
d58 1
a58 41
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0x0fffffff; \
  temp |= 0x40000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301EnableHWARGBCursor()\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp |= 0xF0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301EnableHWARGB16Cursor()\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0x0FFFFFFF; \
  temp |= 0xD0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301SwitchToRGBCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp |= 0xB0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301SwitchToMONOCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0x4fffffff; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
 
d60 2
a61 7
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0xbFFFFFFF; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
d63 1
a63 1
  MMIO_OUT32(pSiS->IOBase, CS(9), (color));
d65 1
a65 1
  MMIO_OUT32(pSiS->IOBase, CS(10), (color));
d68 1
a68 1
  MMIO_OUT32(pSiS->IOBase, CS(11), ((x) | ((preset) << 16)));
d70 1
a70 1
  MMIO_OUT32(pSiS->IOBase, CS(12), ((y) | ((preset) << 16)));
d73 2
a74 7
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0xFFFF0000; \
  temp |= address; \
  MMIO_OUT32(pSiS->IOBase,CS(8),temp); \
  }
d77 2
a78 206
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0xF0FFFFFF; \
  temp |= (pat_id) << 24; \
  MMIO_OUT32(pSiS->IOBase,CS(8),temp); \
  }

/* 310/325/330 series CRT1 */

/* 80000000 = RGB(1) - MONO(0)
 * 40000000 = enable(1) - disable(0)
 * 20000000 = 32(1) / 16(1) bit RGB
 * 10000000 = "ghost"(1) - Alpha Blend(0)
 */
 
#define sis310GetCursorStatus \
  MMIO_IN32(pSiS->IOBase, CS(0)) & 0x40000000;
  
#define sis310SetCursorStatus(status) \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0xbfffffff; \
  temp |= status; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }
  
#define sis310EnableHWCursor()\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0x0fffffff; \
  temp |= 0x40000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }
  
#define sis310EnableHWARGBCursor()\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0x0FFFFFFF; \
  temp |= 0xE0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }

#define sis310SwitchToMONOCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0x4fffffff; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }   
  
#define sis310SwitchToRGBCursor() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0xBFFFFFFF; \
  temp |= 0xA0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }
  
#define sis310DisableHWCursor()\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0xBFFFFFFF; \
  MMIO_OUT32(pSiS->IOBase, CS(0), temp); \
  }
  
#define sis310SetCursorBGColor(color)\
  MMIO_OUT32(pSiS->IOBase, CS(1), (color));
#define sis310SetCursorFGColor(color)\
  MMIO_OUT32(pSiS->IOBase, CS(2), (color));

#define sis310SetCursorPositionX(x,preset)\
  MMIO_OUT32(pSiS->IOBase, CS(3), ((x) | ((preset) << 16)));
#define sis310SetCursorPositionY(y,preset)\
  MMIO_OUT32(pSiS->IOBase, CS(4), ((y) | ((preset) << 16)));

#define sis310SetCursorAddress(address)\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0xFFF00000; \
  temp |= address; \
  MMIO_OUT32(pSiS->IOBase,CS(0),temp); \
  }

#define sis310SetCursorPatternSelect(pat_id)\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(0)); \
  temp &= 0xF0FFFFFF; \
  temp |= (pat_id) << 24; \
  MMIO_OUT32(pSiS->IOBase,CS(0),temp); \
  }

/* 310/325/330 series CRT2 */

/* 80000000 = RGB(1) - MONO(0)
 * 40000000 = enable(1) - disable(0)
 * 20000000 = 32(1) / 16(1) bit RGB
 * 10000000 = "ghost"(1) - Alpha Blend(0)  ?
 */
 
#define sis301GetCursorStatus310 \
  MMIO_IN32(pSiS->IOBase, CS(8)) & 0x40000000;
  
#define sis301SetCursorStatus310(status) \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0xbfffffff; \
  temp |= status; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301EnableHWCursor310()\
   { \
   unsigned long temp, temp1, temp2; \
   temp1 = MMIO_IN32(pSiS->IOBase, CS(11)); \
   temp2 = MMIO_IN32(pSiS->IOBase, CS(12)); \
   temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
   temp &= 0x0fffffff; \
   temp |= 0x40000000; \
   MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
   MMIO_OUT32(pSiS->IOBase, CS(11), temp1); \
   MMIO_OUT32(pSiS->IOBase, CS(12), temp2); \
   }

#define sis301EnableHWARGBCursor310()\
   { \
   unsigned long temp, temp1, temp2; \
   temp1 = MMIO_IN32(pSiS->IOBase, CS(11)); \
   temp2 = MMIO_IN32(pSiS->IOBase, CS(12)); \
   temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
   temp &= 0x0FFFFFFF; \
   temp |= 0xE0000000; \
   MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
   MMIO_OUT32(pSiS->IOBase, CS(11), temp1); \
   MMIO_OUT32(pSiS->IOBase, CS(12), temp2); \
   }

#define sis301SwitchToRGBCursor310() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0xBFFFFFFF; \
  temp |= 0xA0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301SwitchToMONOCursor310() \
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0x4fffffff; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }
  
#define sis301DisableHWCursor310()\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0xBFFFFFFF; \
  MMIO_OUT32(pSiS->IOBase, CS(8), temp); \
  }

#define sis301SetCursorBGColor310(color)\
  MMIO_OUT32(pSiS->IOBase, CS(9), (color));
#define sis301SetCursorFGColor310(color)\
  MMIO_OUT32(pSiS->IOBase, CS(10), (color));

#define sis301SetCursorPositionX310(x,preset)\
  MMIO_OUT32(pSiS->IOBase, CS(11), ((x) | ((preset) << 16)));
#define sis301SetCursorPositionY310(y,preset)\
  MMIO_OUT32(pSiS->IOBase, CS(12), ((y) | ((preset) << 16)));
  
#define sis301SetCursorAddress310(address)\
  { \
  unsigned long temp; \
  if(pSiS->sishw_ext.jChipType == SIS_315H) { \
     if(address & 0x10000) { \
        address &= ~0x10000; \
	orSISIDXREG(SISSR, 0x37, 0x80); \
     } else { \
        andSISIDXREG(SISSR, 0x37, 0x7f); \
     } \
  } \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0xFFF00000; \
  temp |= address; \
  MMIO_OUT32(pSiS->IOBase,CS(8),temp); \
  }

#define sis301SetCursorPatternSelect310(pat_id)\
  { \
  unsigned long temp; \
  temp = MMIO_IN32(pSiS->IOBase, CS(8)); \
  temp &= 0xF0FFFFFF; \
  temp |= (pat_id) << 24; \
  MMIO_OUT32(pSiS->IOBase,CS(8),temp); \
  }

@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_cursor.h,v 1.15 2004/01/23 22:29:04 twini Exp $ */
d3 2
a4 2
 * SiS hardware cursor handling
 * Definitions
d6 9
a14 1
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria.
d16 7
a22 28
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement: "This product includes
 *    software developed by Thomas Winischhofer, Vienna, Austria."
 * 4) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author:   Thomas Winischhofer <thomas@@winischhofer.net>
 *
 * Idea based on code by Can-Ru Yeou, SiS Inc.
d24 6
d32 1
a32 1
#define CS(x)   (0x8500 + (x << 2))
d118 1
a118 1
  temp &= 0xF0FF0000; \
d123 9
d216 1
a216 1
  temp &= 0xF0FF0000; \
d221 10
a230 1
/* 315/330 series CRT1 */
d242 8
a249 6
  pSiS->HWCursorBackup[0] &= 0xbfffffff; \
  pSiS->HWCursorBackup[0] |= status; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);

d251 7
a257 5
  pSiS->HWCursorBackup[0] &= 0x0fffffff; \
  pSiS->HWCursorBackup[0] |= 0x40000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);
d260 7
a266 5
  pSiS->HWCursorBackup[0] &= 0x0FFFFFFF; \
  pSiS->HWCursorBackup[0] |= 0xE0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);
d269 7
a275 5
  pSiS->HWCursorBackup[0] &= 0x4fffffff; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);

d277 8
a284 6
  pSiS->HWCursorBackup[0] &= 0xBFFFFFFF; \
  pSiS->HWCursorBackup[0] |= 0xA0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);

d286 9
a294 9
  pSiS->HWCursorBackup[0] &= 0xBFFFFFFF; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);
  
#define sis310SetCursorBGColor(color) \
  MMIO_OUT32(pSiS->IOBase, CS(1), (color)); \
  pSiS->HWCursorBackup[1] = color;

d296 1
a296 2
  MMIO_OUT32(pSiS->IOBase, CS(2), (color)); \
  pSiS->HWCursorBackup[2] = color;
d298 4
a301 7
#define sis310SetCursorPositionX(x,preset) \
  pSiS->HWCursorBackup[3] = ((x) | ((preset) << 16)); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]);

#define sis310SetCursorPositionY(y,preset) \
  pSiS->HWCursorBackup[4] = ((y) | ((preset) << 16)); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);
d304 7
a310 7
  pSiS->HWCursorBackup[0] &= 0xF0F00000; \
  pSiS->HWCursorBackup[0] |= address; \
  MMIO_OUT32(pSiS->IOBase, CS(0), pSiS->HWCursorBackup[0]); \
  MMIO_OUT32(pSiS->IOBase, CS(1), pSiS->HWCursorBackup[1]); \
  MMIO_OUT32(pSiS->IOBase, CS(2), pSiS->HWCursorBackup[2]); \
  MMIO_OUT32(pSiS->IOBase, CS(3), pSiS->HWCursorBackup[3]); \
  MMIO_OUT32(pSiS->IOBase, CS(4), pSiS->HWCursorBackup[4]);
d312 10
a321 1
/* 315 series CRT2 */
d328 1
a328 1

d331 1
a331 1

d333 8
a340 6
  pSiS->HWCursorBackup[8] &= 0xbfffffff; \
  pSiS->HWCursorBackup[8] |= status; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

d342 11
a352 5
  pSiS->HWCursorBackup[8] &= 0x0fffffff; \
  pSiS->HWCursorBackup[8] |= 0x40000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);
d355 11
a365 5
  pSiS->HWCursorBackup[8] &= 0x0FFFFFFF; \
  pSiS->HWCursorBackup[8] |= 0xE0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);
d368 8
a375 6
  pSiS->HWCursorBackup[8] &= 0xBFFFFFFF; \
  pSiS->HWCursorBackup[8] |= 0xA0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

d377 14
a390 4
  pSiS->HWCursorBackup[8] &= 0x4fffffff; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);
d392 4
a395 21
#define sis301DisableHWCursor310()\
  pSiS->HWCursorBackup[8] &= 0xBFFFFFFF; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

#define sis301SetCursorBGColor310(color) \
  MMIO_OUT32(pSiS->IOBase, CS(9), (color)); \
  pSiS->HWCursorBackup[9] = color;

#define sis301SetCursorFGColor310(color) \
  MMIO_OUT32(pSiS->IOBase, CS(10), (color)); \
  pSiS->HWCursorBackup[10] = color;

#define sis301SetCursorPositionX310(x,preset) \
  pSiS->HWCursorBackup[11] = ((x) | ((preset) << 16)); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]);

#define sis301SetCursorPositionY310(y,preset) \
  pSiS->HWCursorBackup[12] = ((y) | ((preset) << 16)); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);
d397 8
a404 1
#define sis301SetCursorAddress310(address) \
d413 5
a417 29
  pSiS->HWCursorBackup[8] &= 0xF0F00000; \
  pSiS->HWCursorBackup[8] |= address; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]);  \
  MMIO_OUT32(pSiS->IOBase, CS(9),  pSiS->HWCursorBackup[9]);  \
  MMIO_OUT32(pSiS->IOBase, CS(10), pSiS->HWCursorBackup[10]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]);

/* 330 series CRT2 */

/* Mono cursor engine for CRT2 on SiS330 (Xabre) has bugs
 * and cannot be used! Will hang engine.
 */

/* 80000000 = RGB(1) - MONO(0)
 * 40000000 = enable(1) - disable(0)
 * 20000000 = 32(1) / 16(1) bit RGB
 * 10000000 = "ghost"(1) - Alpha Blend(0)  ?
 */

#define sis301EnableHWCursor330() \
  /* andSISIDXREG(SISCR,0x5b,~0x10); */ \
  pSiS->HWCursorBackup[8] &= 0x0fffffff; \
  pSiS->HWCursorBackup[8] |= 0xE0000000; \
  MMIO_OUT32(pSiS->IOBase, CS(8),  pSiS->HWCursorBackup[8]); \
  MMIO_OUT32(pSiS->IOBase, CS(11), pSiS->HWCursorBackup[11]); \
  MMIO_OUT32(pSiS->IOBase, CS(12), pSiS->HWCursorBackup[12]); \
  /* orSISIDXREG(SISCR,0x5b,0x10); */

d419 8
@


1.1.1.4
log
@Import OpenBSD X-Window subsystem (based upon XFree86 4.4RC2)
into vendor branch
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_cursor.h,v 1.17 2004/02/25 17:45:13 twini Exp $ */
d16 4
a19 1
 * 3) The name of the author may not be used to endorse or promote products
@


