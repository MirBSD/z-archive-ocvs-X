head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407221130:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.07.33;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.07.33;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.36.42;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.19.45;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.23.54;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_dri.c,v 1.20 2001/12/15 00:59:11 dawes Exp $ */

/* modified from tdfx_dri.c, mga_dri.c */

#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86_ansic.h"
#include "xf86Priv.h"

#include "xf86PciInfo.h"
#include "xf86Pci.h"
#include "fb.h"

#include "GL/glxtokens.h"

#include "sis.h"
#include "sis_dri.h"
#include "xf86drmSiS.h"

#define BR(x)   (0x8200 | (x) << 2)
#define SiSIdle \
  while((MMIO_IN16(pSiS->IOBase, BR(16)+2) & 0xE000) != 0xE000){}; \
  while((MMIO_IN16(pSiS->IOBase, BR(16)+2) & 0xE000) != 0xE000){}; \
  MMIO_IN16(pSiS->IOBase, 0x8240);

extern void GlxSetVisualConfigs(
    int nconfigs,
    __GLXvisualConfig *configs,
    void **configprivs
);

#define AGP_PAGE_SIZE 4096
#define AGP_PAGES 2048
#define AGP_SIZE (AGP_PAGE_SIZE * AGP_PAGES)
#define AGP_CMDBUF_PAGES 256
#define AGP_CMDBUF_SIZE (AGP_PAGE_SIZE * AGP_CMDBUF_PAGES)

static char SISKernelDriverName[] = "sis";
static char SISClientDriverName[] = "sis";

static Bool SISInitVisualConfigs(ScreenPtr pScreen);
static Bool SISCreateContext(ScreenPtr pScreen, VisualPtr visual, 
                   drmContext hwContext, void *pVisualConfigPriv,
                   DRIContextType contextStore);
static void SISDestroyContext(ScreenPtr pScreen, drmContext hwContext,
                   DRIContextType contextStore);
static void SISDRISwapContext(ScreenPtr pScreen, DRISyncType syncType, 
                   DRIContextType readContextType, 
                   void *readContextStore,
                   DRIContextType writeContextType, 
                   void *writeContextStore);
static void SISDRIInitBuffers(WindowPtr pWin, RegionPtr prgn, CARD32 index);
static void SISDRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg, 
                   RegionPtr prgnSrc, CARD32 index);

static Bool
SISInitVisualConfigs(ScreenPtr pScreen)
{
  ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
  SISPtr pSIS = SISPTR(pScrn);
  int numConfigs = 0;
  __GLXvisualConfig *pConfigs = 0;
  SISConfigPrivPtr pSISConfigs = 0;
  SISConfigPrivPtr *pSISConfigPtrs = 0;
  int i, db, z_stencil, accum;
  Bool useZ16 = FALSE;
  
  if(getenv("SIS_FORCE_Z16")){
    useZ16 = TRUE;
  }

  switch (pScrn->bitsPerPixel) {
  case 8:
  case 24:
    break;
  case 16:
  case 32:
    numConfigs = (useZ16)?8:16;

    if (!(pConfigs = (__GLXvisualConfig*)xcalloc(sizeof(__GLXvisualConfig),
						   numConfigs))) {
      return FALSE;
    }
    if (!(pSISConfigs = (SISConfigPrivPtr)xcalloc(sizeof(SISConfigPrivRec),
						    numConfigs))) {
      xfree(pConfigs);
      return FALSE;
    }
    if (!(pSISConfigPtrs = (SISConfigPrivPtr*)xcalloc(sizeof(SISConfigPrivPtr),
							  numConfigs))) {
      xfree(pConfigs);
      xfree(pSISConfigs);
      return FALSE;
    }
    for (i=0; i<numConfigs; i++) 
      pSISConfigPtrs[i] = &pSISConfigs[i];

    i = 0;
    for (accum = 0; accum <= 1; accum++) {
      for (z_stencil=0; z_stencil<(useZ16?2:4); z_stencil++) {
        for (db = 0; db <= 1; db++) {
          pConfigs[i].vid = -1;
          pConfigs[i].class = -1;
          pConfigs[i].rgba = TRUE;
          pConfigs[i].redSize = -1;
          pConfigs[i].greenSize = -1;
          pConfigs[i].blueSize = -1;
          pConfigs[i].redMask = -1;
          pConfigs[i].greenMask = -1;
          pConfigs[i].blueMask = -1;
          pConfigs[i].alphaMask = 0;
          if (accum) {
            pConfigs[i].accumRedSize = 16;
            pConfigs[i].accumGreenSize = 16;
            pConfigs[i].accumBlueSize = 16;
            pConfigs[i].accumAlphaSize = 16;
          } else {
            pConfigs[i].accumRedSize = 0;
            pConfigs[i].accumGreenSize = 0;
            pConfigs[i].accumBlueSize = 0;
            pConfigs[i].accumAlphaSize = 0;
          }
          if (db)
            pConfigs[i].doubleBuffer = TRUE;
          else
            pConfigs[i].doubleBuffer = FALSE;
          pConfigs[i].stereo = FALSE;
          pConfigs[i].bufferSize = -1;
          switch (z_stencil){
            case 0:
              pConfigs[i].depthSize = 0;
              pConfigs[i].stencilSize = 0;
              break;
            case 1:
              pConfigs[i].depthSize = 16;
              pConfigs[i].stencilSize = 0;
              break;
            case 2:
              pConfigs[i].depthSize = 32;
              pConfigs[i].stencilSize = 0;
              break;
            case 3:
              pConfigs[i].depthSize = 24;
              pConfigs[i].stencilSize = 8;
              break;
          }
          pConfigs[i].auxBuffers = 0;
          pConfigs[i].level = 0;
          pConfigs[i].visualRating = GLX_NONE_EXT;
          pConfigs[i].transparentPixel = 0;
          pConfigs[i].transparentRed = 0;
          pConfigs[i].transparentGreen = 0;
          pConfigs[i].transparentBlue = 0;
          pConfigs[i].transparentAlpha = 0;
          pConfigs[i].transparentIndex = 0;
          i++;
        }
      }
    }
    if (i != numConfigs) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                 "[dri] Incorrect initialization of visuals.  Disabling DRI.\n");
      return FALSE;
    }
    break;
  }
 
  pSIS->numVisualConfigs = numConfigs;
  pSIS->pVisualConfigs = pConfigs;
  pSIS->pVisualConfigsPriv = pSISConfigs;
  GlxSetVisualConfigs(numConfigs, pConfigs, (void**)pSISConfigPtrs);

  return TRUE;
}

Bool SISDRIScreenInit(ScreenPtr pScreen)
{
  ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
  SISPtr pSIS = SISPTR(pScrn);
  DRIInfoPtr pDRIInfo;
  SISDRIPtr pSISDRI;
#if 000
  drmVersionPtr version;
#endif

   /* Check that the GLX, DRI, and DRM modules have been loaded by testing
    * for canonical symbols in each module. */
   if (!xf86LoaderCheckSymbol("GlxSetVisualConfigs")) return FALSE;
   if (!xf86LoaderCheckSymbol("DRIScreenInit"))       return FALSE;
   if (!xf86LoaderCheckSymbol("drmAvailable"))        return FALSE;
   if (!xf86LoaderCheckSymbol("DRIQueryVersion")) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
                 "[dri] SISDRIScreenInit failed (libdri.a too old)\n");
      return FALSE;
   }
     
   /* Check the DRI version */
   {
      int major, minor, patch;
      DRIQueryVersion(&major, &minor, &patch);
      if (major != 4 || minor < 0) {
         xf86DrvMsg(pScreen->myNum, X_ERROR,
                    "[dri] SISDRIScreenInit failed because of a version mismatch.\n"
                    "[dri] libDRI version is %d.%d.%d but version 4.0.x is needed.\n"
                    "[dri] Disabling DRI.\n",
                    major, minor, patch);
         return FALSE;
      }
   }

  pDRIInfo = DRICreateInfoRec();
  if (!pDRIInfo) return FALSE;
  pSIS->pDRIInfo = pDRIInfo;

  pDRIInfo->drmDriverName = SISKernelDriverName;
  pDRIInfo->clientDriverName = SISClientDriverName;
  pDRIInfo->busIdString = xalloc(64);
  sprintf(pDRIInfo->busIdString, "PCI:%d:%d:%d",
      ((pciConfigPtr)pSIS->PciInfo->thisCard)->busnum,
      ((pciConfigPtr)pSIS->PciInfo->thisCard)->devnum,
      ((pciConfigPtr)pSIS->PciInfo->thisCard)->funcnum);
  pDRIInfo->ddxDriverMajorVersion = 0;
  pDRIInfo->ddxDriverMinorVersion = 1;
  pDRIInfo->ddxDriverPatchVersion = 0;
  pDRIInfo->frameBufferPhysicalAddress = pSIS->FbAddress;
  pDRIInfo->frameBufferSize = pSIS->FbMapSize;  
  
  /* ?? */
  pDRIInfo->frameBufferStride = pSIS->scrnOffset;
  pDRIInfo->ddxDrawableTableEntry = SIS_MAX_DRAWABLES;

  if (SAREA_MAX_DRAWABLES < SIS_MAX_DRAWABLES)
    pDRIInfo->maxDrawableTableEntry = SAREA_MAX_DRAWABLES;
  else
    pDRIInfo->maxDrawableTableEntry = SIS_MAX_DRAWABLES;

#ifdef NOT_DONE
  /* FIXME need to extend DRI protocol to pass this size back to client 
   * for SAREA mapping that includes a device private record
   */
  pDRIInfo->SAREASize = 
    ((sizeof(XF86DRISAREARec) + 0xfff) & 0x1000); /* round to page */
  /* + shared memory device private rec */
#else
  /* For now the mapping works by using a fixed size defined
   * in the SAREA header
   */
  if (sizeof(XF86DRISAREARec)+sizeof(SISSAREAPriv) > SAREA_MAX) {
    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			"Data does not fit in SAREA\n");
    return FALSE;
  }
  pDRIInfo->SAREASize = SAREA_MAX;
#endif

  if (!(pSISDRI = (SISDRIPtr)xcalloc(sizeof(SISDRIRec),1))) {
    DRIDestroyInfoRec(pSIS->pDRIInfo);
    pSIS->pDRIInfo=0;
    return FALSE;
  }
  pDRIInfo->devPrivate = pSISDRI;
  pDRIInfo->devPrivateSize = sizeof(SISDRIRec);
  pDRIInfo->contextSize = sizeof(SISDRIContextRec);

  pDRIInfo->CreateContext = SISCreateContext;
  pDRIInfo->DestroyContext = SISDestroyContext;
  pDRIInfo->SwapContext = SISDRISwapContext;
  pDRIInfo->InitBuffers = SISDRIInitBuffers;
  pDRIInfo->MoveBuffers = SISDRIMoveBuffers;
  pDRIInfo->bufferRequests = DRI_ALL_WINDOWS;

  if (!DRIScreenInit(pScreen, pDRIInfo, &pSIS->drmSubFD)) {
	xf86DrvMsg(pScreen->myNum, X_ERROR,
                   "[dri] DRIScreenInit failed.  Disabling DRI.\n");
    xfree(pDRIInfo->devPrivate);
    pDRIInfo->devPrivate=0;
    DRIDestroyInfoRec(pSIS->pDRIInfo);
    pSIS->pDRIInfo=0;
    pSIS->drmSubFD = -1;
    return FALSE;
  }

#if 000
  /* XXX Check DRM kernel version here */
  version = drmGetVersion(info->drmFD);
  if (version) {
    if (version->version_major != 1 ||
      version->version_minor < 0) {
      /* incompatible drm version */
      xf86DrvMsg(pScreen->myNum, X_ERROR,
                 "[dri] SISDRIScreenInit failed because of a version mismatch.\n"
                 "[dri] sis.o kernel module version is %d.%d.%d but version 1.0.x is needed.\n"
                 "[dri] Disabling the DRI.\n",
                 version->version_major,
                 version->version_minor,
                 version->version_patchlevel);
      drmFreeVersion(version);
      R128DRICloseScreen(pScreen);
      return FALSE;
    }
    drmFreeVersion(version);
  }
#endif

  pSISDRI->regs.size = SISIOMAPSIZE;
  pSISDRI->regs.map = 0;
  if (drmAddMap(pSIS->drmSubFD, (drmHandle)pSIS->IOAddress, 
        pSISDRI->regs.size, DRM_REGISTERS, 0, 
        &pSISDRI->regs.handle)<0) 
  {
    SISDRICloseScreen(pScreen);
    return FALSE;
  }

  xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Registers = 0x%08lx\n",
           pSISDRI->regs.handle);

  /* AGP */
  do{
    pSIS->agpSize = 0;
    pSIS->agpCmdBufSize = 0;
    pSISDRI->AGPCmdBufSize = 0;
    
    if (drmAgpAcquire(pSIS->drmSubFD) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] drmAgpAcquire failed\n");
      break;
    }
   
    /* TODO: default value is 2x? */
    if (drmAgpEnable(pSIS->drmSubFD, drmAgpGetMode(pSIS->drmSubFD)&~0x0) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] drmAgpEnable failed\n");
      break;
    }
	xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] drmAgpEnabled succeeded\n");

    if (drmAgpAlloc(pSIS->drmSubFD, AGP_SIZE, 0, NULL, &pSIS->agpHandle) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
                 "[drm] drmAgpAlloc failed\n");
      drmAgpRelease(pSIS->drmSubFD);
      break;
    }
   
    if (drmAgpBind(pSIS->drmSubFD, pSIS->agpHandle, 0) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
                 "[drm] drmAgpBind failed\n");
      drmAgpFree(pSIS->drmSubFD, pSIS->agpHandle);
      drmAgpRelease(pSIS->drmSubFD);

      break;
    }

    pSIS->agpSize = AGP_SIZE;
    pSIS->agpAddr = drmAgpBase(pSIS->drmSubFD);
    /* pSIS->agpBase = */

    pSISDRI->agp.size = pSIS->agpSize;
    if (drmAddMap(pSIS->drmSubFD, (drmHandle)0,
                 pSISDRI->agp.size, DRM_AGP, 0, 
                 &pSISDRI->agp.handle) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
                 "[drm] Failed to map public agp area\n");
      pSISDRI->agp.size = 0;
      break;
    }  

    pSIS->agpCmdBufSize = AGP_CMDBUF_SIZE;      
    pSIS->agpCmdBufAddr = pSIS->agpAddr;
    pSIS->agpCmdBufBase = pSIS->agpCmdBufAddr - pSIS->agpAddr + 
                          pSIS->agpBase;
    pSIS->agpCmdBufFree = 0;
         
    pSISDRI->AGPCmdBufOffset = pSIS->agpCmdBufAddr - pSIS->agpAddr;
    pSISDRI->AGPCmdBufSize = pSIS->agpCmdBufSize;

    drmSiSAgpInit(pSIS->drmSubFD, AGP_CMDBUF_SIZE,(AGP_SIZE - AGP_CMDBUF_SIZE));
  }
  while(0);
    
  /* enable IRQ */
  pSIS->irq = drmGetInterruptFromBusID(pSIS->drmSubFD,
           ((pciConfigPtr)pSIS->PciInfo->thisCard)->busnum,
           ((pciConfigPtr)pSIS->PciInfo->thisCard)->devnum,
           ((pciConfigPtr)pSIS->PciInfo->thisCard)->funcnum);

  if((drmCtlInstHandler(pSIS->drmSubFD, pSIS->irq)) != 0) 
    {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
         "[drm] failure adding irq %d handler, stereo disabled\n",
         pSIS->irq);
      pSIS->irqEnabled = FALSE;
    }
  else
    {
      pSIS->irqEnabled = TRUE;
    }
  
  pSISDRI->irqEnabled = pSIS->irqEnabled;
  
  if (!(SISInitVisualConfigs(pScreen))) {
    SISDRICloseScreen(pScreen);
    return FALSE;
  }
  xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[dri] visual configs initialized.\n" );

  return TRUE;
}

void
SISDRICloseScreen(ScreenPtr pScreen)
{
  ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
  SISPtr pSIS = SISPTR(pScrn);

  DRICloseScreen(pScreen);

  if (pSIS->pDRIInfo) {
    if (pSIS->pDRIInfo->devPrivate) {
      xfree(pSIS->pDRIInfo->devPrivate);
      pSIS->pDRIInfo->devPrivate=0;
    }
    DRIDestroyInfoRec(pSIS->pDRIInfo);
    pSIS->pDRIInfo=0;
  }
  if (pSIS->pVisualConfigs) xfree(pSIS->pVisualConfigs);
  if (pSIS->pVisualConfigsPriv) xfree(pSIS->pVisualConfigsPriv);

  if(pSIS->agpSize){
	 xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Freeing agp memory\n");
     drmAgpFree(pSIS->drmSubFD, pSIS->agpHandle);
	 xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Releasing agp module\n");
     drmAgpRelease(pSIS->drmSubFD);
  }
}

/* TODO: xserver receives driver's swapping event and do something
 *       according the data initialized in this function
 */
static Bool
SISCreateContext(ScreenPtr pScreen, VisualPtr visual, 
          drmContext hwContext, void *pVisualConfigPriv,
          DRIContextType contextStore)
{
  return TRUE;
}

static void
SISDestroyContext(ScreenPtr pScreen, drmContext hwContext, 
           DRIContextType contextStore)
{
}

Bool
SISDRIFinishScreenInit(ScreenPtr pScreen)
{
  ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
  SISPtr pSiS = SISPTR(pScrn);
  SISDRIPtr pSISDRI;

  pSiS->pDRIInfo->driverSwapMethod = DRI_HIDE_X_CONTEXT;
  /* pSiS->pDRIInfo->driverSwapMethod = DRI_SERVER_SWAP; */

  pSISDRI=(SISDRIPtr)pSiS->pDRIInfo->devPrivate;
  pSISDRI->deviceID=pSiS->Chipset;  
  pSISDRI->width=pScrn->virtualX;
  pSISDRI->height=pScrn->virtualY;
  pSISDRI->mem=pScrn->videoRam*1024;
  pSISDRI->bytesPerPixel= (pScrn->bitsPerPixel+7) / 8; 
  /* TODO */
  pSISDRI->scrnX=pSISDRI->width;
  pSISDRI->scrnY=pSISDRI->height;
  
/*
  pSISDRI->textureOffset=pSiS->texOffset;
  pSISDRI->textureSize=pSiS->texSize;
  pSISDRI->fbOffset=pSiS->fbOffset;
  pSISDRI->backOffset=pSiS->backOffset;
  pSISDRI->depthOffset=pSiS->depthOffset;
*/

  /* set SAREA value */
  {
    SISSAREAPriv *saPriv;

    saPriv=(SISSAREAPriv*)DRIGetSAREAPrivate(pScreen);
    
    assert(saPriv);
          
    saPriv->CtxOwner = -1;
    saPriv->QueueLength = 0;    
    pSiS->cmdQueueLenPtr = &(saPriv->QueueLength);
    saPriv->AGPCmdBufNext = 0;

    /* frame control */
    saPriv->FrameCount = 0;
    *(unsigned long *)(pSiS->IOBase+0x8a2c) = 0;
    SiSIdle
  }
  
  return DRIFinishScreenInit(pScreen);
}

static void
SISDRISwapContext(ScreenPtr pScreen, DRISyncType syncType, 
           DRIContextType oldContextType, void *oldContext,
           DRIContextType newContextType, void *newContext)
{
  ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
  SISPtr pSIS = SISPTR(pScrn);

#if 0
  if ((syncType==DRI_3D_SYNC) && (oldContextType==DRI_2D_CONTEXT) &&
      (newContextType==DRI_2D_CONTEXT)) { /* Entering from Wakeup */
    SISSwapContextPrivate(pScreen);
  }
  if ((syncType==DRI_2D_SYNC) && (oldContextType==DRI_NO_CONTEXT) &&
      (newContextType==DRI_2D_CONTEXT)) { /* Exiting from Block Handler */
    SISLostContext(pScreen);
  }
#endif
  
  /* mEndPrimitive */
  /* 
   * TODO: do this only if X-Server get lock. If kernel supports delayed
   * signal, needless to do this
   */ 
  *(pSIS->IOBase + 0X8B50) = 0xff;
  *(unsigned int *)(pSIS->IOBase + 0x8B60) = -1;
    
}

static void
SISDRIInitBuffers(WindowPtr pWin, RegionPtr prgn, CARD32 index)
{
  ScreenPtr pScreen = pWin->drawable.pScreen;
  ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
  SISPtr pSiS = SISPTR(pScrn);

  SiSIdle  
}

static void
SISDRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg, 
           RegionPtr prgnSrc, CARD32 index)
{
  ScreenPtr pScreen = pParent->drawable.pScreen;
  ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
  SISPtr pSiS = SISPTR(pScrn);

  SiSIdle  
}

#if 0
void SISLostContext(ScreenPtr pScreen) 
{
}

void SISSwapContextPrivate(ScreenPtr pScreen) 
{
}
#endif
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 3
a3 36
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_dri.c,v 1.41 2004/01/04 18:08:00 twini Exp $ */
/*
 * DRI wrapper for 300 and 315 series
 *
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria
 *
 * Preliminary 315/330 support by Thomas Winischhofer
 * Portions of Mesa 4/5 changes by Eric Anholt
 *
 * Licensed under the following terms:
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appears in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * and that the name of the copyright holder not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. The copyright holder makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without expressed or implied warranty.
 *
 * THE COPYRIGHT HOLDER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO
 * EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Previously taken and modified from tdfx_dri.c, mga_dri.c
 *
 * Authors:	Can-Ru Yeou, SiS Inc.
 *		Alan Hourihane, Wigan, England,
 *		Thomas Winischhofer <thomas@@winischhofer.net>
 *		others.
 */
d17 2
a18 3
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
#include "xf86drmCompat.h"
#endif
a19 5
#ifdef SISNEWDRI
#include "sis_common.h"
#endif

/* Idle function for 300 series */
a25 9
/* Idle function for 315/330 series */
#define Q_STATUS 0x85CC
#define SiS315Idle \
  { \
  while( (MMIO_IN16(pSiS->IOBase, Q_STATUS+2) & 0x8000) != 0x8000){}; \
  while( (MMIO_IN16(pSiS->IOBase, Q_STATUS+2) & 0x8000) != 0x8000){}; \
  }


d32 6
a55 4
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
extern Bool drmSiSAgpInit(int driSubFD, int offset, int size);
#endif

d67 3
a69 3

  if(getenv("SIS_FORCE_Z16")) {
     useZ16 = TRUE;
d78 1
a78 1
    numConfigs = (useZ16) ? 8 : 16;
d80 1
a80 1
    if(!(pConfigs = (__GLXvisualConfig*)xcalloc(sizeof(__GLXvisualConfig),
d82 1
a82 1
       return FALSE;
d84 1
a84 1
    if(!(pSISConfigs = (SISConfigPrivPtr)xcalloc(sizeof(SISConfigPrivRec),
d86 2
a87 2
       xfree(pConfigs);
       return FALSE;
d89 1
a89 1
    if(!(pSISConfigPtrs = (SISConfigPrivPtr*)xcalloc(sizeof(SISConfigPrivPtr),
d91 3
a93 3
       xfree(pConfigs);
       xfree(pSISConfigs);
       return FALSE;
d95 2
a96 1
    for(i=0; i<numConfigs; i++)  pSISConfigPtrs[i] = &pSISConfigs[i];
d99 3
a101 3
    for(accum = 0; accum <= 1; accum++) {
      for(z_stencil=0; z_stencil<(useZ16?2:4); z_stencil++) {
        for(db = 0; db <= 1; db++) {
d112 1
a112 1
          if(accum) {
d123 4
a126 2
          if(db) pConfigs[i].doubleBuffer = TRUE;
          else   pConfigs[i].doubleBuffer = FALSE;
d129 1
a129 1
          switch(z_stencil) {
d160 4
a163 4
    if(i != numConfigs) {
       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                 "[dri] Incorrect initialization of visuals. Disabling DRI.\n");
       return FALSE;
d182 1
a182 1
#ifdef SISNEWDRI
a185 5
   pSIS->cmdQueueLenPtrBackup = NULL;
#ifdef SIS315DRI
   pSIS->cmdQ_SharedWritePortBackup = NULL;
#endif

d187 5
a191 6
    * for canonical symbols in each module.
    */
   if(!xf86LoaderCheckSymbol("GlxSetVisualConfigs")) return FALSE;
   if(!xf86LoaderCheckSymbol("DRIScreenInit"))       return FALSE;
   if(!xf86LoaderCheckSymbol("drmAvailable"))        return FALSE;
   if(!xf86LoaderCheckSymbol("DRIQueryVersion")) {
d193 1
a193 1
                "[dri] SISDRIScreenInit failed (libdri.a too old)\n");
d201 1
a201 1
      if(major != 4 || minor < 0) {
d204 2
a205 2
                    "\t[dri] libDRI version is %d.%d.%d but version 4.0.x is needed.\n"
                    "\t[dri] Disabling DRI.\n",
d217 5
a221 22
#ifdef SISNEWDRI2
  if(xf86LoaderCheckSymbol("DRICreatePCIBusID")) {
     pDRIInfo->busIdString = DRICreatePCIBusID(pSiS->PciInfo);
  } else {
#endif
     pDRIInfo->busIdString = xalloc(64);
     sprintf(pDRIInfo->busIdString, "PCI:%d:%d:%d",
             ((pciConfigPtr)pSIS->PciInfo->thisCard)->busnum,
      	     ((pciConfigPtr)pSIS->PciInfo->thisCard)->devnum,
      	     ((pciConfigPtr)pSIS->PciInfo->thisCard)->funcnum);
#ifdef SISNEWDRI2
  }
#endif

  /* Hack to keep old DRI working -- checked for major==1 and
   * minor==1.
   */
#ifdef SISNEWDRI
  pDRIInfo->ddxDriverMajorVersion = SIS_MAJOR_VERSION;
  pDRIInfo->ddxDriverMinorVersion = SIS_MINOR_VERSION;
  pDRIInfo->ddxDriverPatchVersion = SIS_PATCHLEVEL;
#else
a224 2
#endif

d226 1
a226 10

  /* TW: This was FbMapSize which is wrong as we must not
   *     ever overwrite HWCursor and TQ area. On the other
   *     hand, using availMem here causes MTRR allocation
   *     to fail ("base is not aligned to size"). Since
   *     DRI memory management is done via framebuffer
   *     device, I assume that the size given here
   *     is NOT used for eventual memory management.
   */
  pDRIInfo->frameBufferSize = pSIS->FbMapSize;   /* availMem; */
d228 1
a228 1
  /* TW: scrnOffset is being calulated in sis_vga.c */
a229 1
  
d232 2
a233 2
  if(SAREA_MAX_DRAWABLES < SIS_MAX_DRAWABLES)
     pDRIInfo->maxDrawableTableEntry = SAREA_MAX_DRAWABLES;
d235 1
a235 1
     pDRIInfo->maxDrawableTableEntry = SIS_MAX_DRAWABLES;
d238 1
a238 1
  /* FIXME need to extend DRI protocol to pass this size back to client
d241 2
a242 3
  pDRIInfo->SAREASize =
    ((sizeof(XF86DRISAREARec) + getpagesize() - 1) & getpagesize()); /* round to page */
    /* ((sizeof(XF86DRISAREARec) + 0xfff) & 0x1000); */ /* round to page */
d248 4
a251 4
  if(sizeof(XF86DRISAREARec)+sizeof(SISSAREAPriv) > SAREA_MAX) {
     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"Data does not fit in SAREA\n");
     return FALSE;
d256 4
a259 4
  if(!(pSISDRI = (SISDRIPtr)xcalloc(sizeof(SISDRIRec),1))) {
     DRIDestroyInfoRec(pSIS->pDRIInfo);
     pSIS->pDRIInfo = 0;
     return FALSE;
d272 17
a288 17
  if(!DRIScreenInit(pScreen, pDRIInfo, &pSIS->drmSubFD)) {
     xf86DrvMsg(pScreen->myNum, X_ERROR,
               "[dri] DRIScreenInit failed. Disabling DRI.\n");
     xfree(pDRIInfo->devPrivate);
     pDRIInfo->devPrivate = 0;
     DRIDestroyInfoRec(pSIS->pDRIInfo);
     pSIS->pDRIInfo = 0;
     pSIS->drmSubFD = -1;
     return FALSE;
  }

#ifdef SISNEWDRI
  /* Check DRM kernel version */
  version = drmGetVersion(pSIS->drmSubFD);
  if(version) {
    if(version->version_major != 1 ||
       version->version_minor < 0) {
d292 2
a293 2
                 "\t[dri] sis.o kernel module version is %d.%d.%d but version 1.0.x is needed.\n"
                 "\t[dri] Disabling the DRI.\n",
d298 1
a298 1
      SISDRICloseScreen(pScreen);
a300 11
    if(version->version_minor >= 1) {
      /* Includes support for framebuffer memory allocation without sisfb */
      drm_sis_fb_t fb;
      fb.offset = pSIS->DRIheapstart;
      fb.size = pSIS->DRIheapend - pSIS->DRIheapstart;
      drmCommandWrite(pSIS->drmSubFD, DRM_SIS_FB_INIT, &fb, sizeof(fb));
      xf86DrvMsg(pScreen->myNum, X_INFO,
                 "[dri] DRI video RAM memory heap: 0x%lx to 0x%lx (%dKB)\n",
                 pSIS->DRIheapstart, pSIS->DRIheapend,
                 (int)((pSIS->DRIheapend - pSIS->DRIheapstart) >> 10));
    }
d307 6
a312 5
  if(drmAddMap(pSIS->drmSubFD, (drmHandle)pSIS->IOAddress,
        	pSISDRI->regs.size, DRM_REGISTERS, 0,
        	&pSISDRI->regs.handle) < 0) {
     SISDRICloseScreen(pScreen);
     return FALSE;
d319 1
a319 2
  do {
    pSIS->agpWantedSize = pSIS->agpWantedPages * AGP_PAGE_SIZE;
d323 12
d336 5
a340 6
    if(!pSIS->IsAGPCard)
       break;

    if(drmAgpAcquire(pSIS->drmSubFD) < 0) {
       xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to acquire AGP, AGP disabled\n");
       break;
d342 6
d349 1
a349 62
    if(pSIS->VGAEngine == SIS_315_VGA) {
#ifdef SIS315DRI
       /* Default to 1X agp mode in SIS315 */
       if(drmAgpEnable(pSIS->drmSubFD, drmAgpGetMode(pSIS->drmSubFD) & ~0x00000002) < 0) {
          xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to enable AGP, AGP disabled\n");
          break;
       }
#endif
    } else {
       /* TODO: default value is 2x? */
       if(drmAgpEnable(pSIS->drmSubFD, drmAgpGetMode(pSIS->drmSubFD) & ~0x0) < 0) {
          xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to enable AGP, AGP disabled\n");
          break;
       }
    }

    xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] AGP enabled\n");

#define AGP_DEFAULT_SIZE_MB 8
#define AGP_DEFAULT_SIZE    (AGP_DEFAULT_SIZE_MB * 1024 * 1024)

    if(drmAgpAlloc(pSIS->drmSubFD, pSIS->agpWantedSize, 0, NULL, &pSIS->agpHandle) < 0) {
       xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to allocate %dMB AGP memory\n",
                  (int)(pSIS->agpWantedSize / (1024 * 1024)));
       if(pSIS->agpWantedSize > AGP_DEFAULT_SIZE) {
          xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Retrying with %dMB\n", AGP_DEFAULT_SIZE_MB);
          pSIS->agpWantedSize = AGP_DEFAULT_SIZE;
          if(drmAgpAlloc(pSIS->drmSubFD, pSIS->agpWantedSize, 0, NULL, &pSIS->agpHandle) < 0) {
             xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to allocate %dMB AGP memory, AGP disabled\n",
	  	        AGP_DEFAULT_SIZE_MB);
             drmAgpRelease(pSIS->drmSubFD);
             break;
	  }
       } else {
          drmAgpRelease(pSIS->drmSubFD);
          break;
       }
    }

    xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Allocated %dMB AGP memory\n",
    		(int)(pSIS->agpWantedSize / (1024 * 1024)));

    if(drmAgpBind(pSIS->drmSubFD, pSIS->agpHandle, 0) < 0) {
       xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to bind AGP memory\n");
       drmAgpFree(pSIS->drmSubFD, pSIS->agpHandle);
       if(pSIS->agpWantedSize > AGP_DEFAULT_SIZE) {
          xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Retrying with %dMB\n", AGP_DEFAULT_SIZE_MB);
          pSIS->agpWantedSize = AGP_DEFAULT_SIZE;
          if(drmAgpAlloc(pSIS->drmSubFD, pSIS->agpWantedSize, 0, NULL, &pSIS->agpHandle) < 0) {
	     xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to re-allocate AGP memory, AGP disabled\n");
	     drmAgpRelease(pSIS->drmSubFD);
             break;
	  } else if(drmAgpBind(pSIS->drmSubFD, pSIS->agpHandle, 0) < 0) {
	     xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to bind AGP memory again, AGP disabled\n");
             drmAgpFree(pSIS->drmSubFD, pSIS->agpHandle);
	     drmAgpRelease(pSIS->drmSubFD);
             break;
	  }
       } else {
          drmAgpRelease(pSIS->drmSubFD);
          break;
       }
d352 1
a352 4
    xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Bound %dMB AGP memory\n",
	       (int)(pSIS->agpWantedSize / (1024 * 1024)));

    pSIS->agpSize = pSIS->agpWantedSize;
d357 14
a370 24
    if(drmAddMap(pSIS->drmSubFD, (drmHandle)0, pSISDRI->agp.size, DRM_AGP, 0, &pSISDRI->agp.handle) < 0) {
       xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to map public AGP area, AGP disabled\n");
       pSISDRI->agp.size = 0;
       break;
    }

    if(pSIS->VGAEngine == SIS_315_VGA) {
#ifdef SIS315DRI
       pSIS->agpVtxBufSize = AGP_VTXBUF_SIZE; /* = 2MB */
       pSIS->agpVtxBufAddr = pSIS->agpAddr;
       pSIS->agpVtxBufBase = pSIS->agpVtxBufAddr - pSIS->agpAddr + pSIS->agpBase;
       pSIS->agpVtxBufFree = 0;

       pSISDRI->AGPVtxBufOffset = pSIS->agpVtxBufAddr - pSIS->agpAddr;
       pSISDRI->AGPVtxBufSize = pSIS->agpVtxBufSize;

       drmSiSAgpInit(pSIS->drmSubFD, AGP_VTXBUF_SIZE,(pSIS->agpSize - AGP_VTXBUF_SIZE));
#endif
    } else {

       pSIS->agpCmdBufSize = AGP_CMDBUF_SIZE;
       pSIS->agpCmdBufAddr = pSIS->agpAddr;
       pSIS->agpCmdBufBase = pSIS->agpCmdBufAddr - pSIS->agpAddr + pSIS->agpBase;
       pSIS->agpCmdBufFree = 0;
d372 2
a373 2
       pSISDRI->AGPCmdBufOffset = pSIS->agpCmdBufAddr - pSIS->agpAddr;
       pSISDRI->AGPCmdBufSize = pSIS->agpCmdBufSize;
d375 1
a375 2
       drmSiSAgpInit(pSIS->drmSubFD, AGP_CMDBUF_SIZE,(pSIS->agpSize - AGP_CMDBUF_SIZE));
    }
d385 4
a388 3
  if((drmCtlInstHandler(pSIS->drmSubFD, pSIS->irq)) != 0) {
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
         "[drm] Failed to add IRQ %d handler, stereo disabled\n",
d390 6
a395 4
     pSIS->irqEnabled = FALSE;
  } else {
     pSIS->irqEnabled = TRUE;
  }
d399 3
a401 3
  if(!(SISInitVisualConfigs(pScreen))) {
     SISDRICloseScreen(pScreen);
     return FALSE;
d403 1
a403 2

  xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[dri] Visual configs initialized.\n" );
a413 13
  if(pSIS->VGAEngine == SIS_315_VGA) {
#ifdef SIS315DRI
     if(pSIS->cmdQ_SharedWritePortBackup) {
        pSIS->cmdQ_SharedWritePort = pSIS->cmdQ_SharedWritePortBackup;
     }
#endif
  } else {
     if(pSIS->cmdQueueLenPtrBackup) {
        pSIS->cmdQueueLenPtr = pSIS->cmdQueueLenPtrBackup;
        *(pSIS->cmdQueueLenPtr) = 0;
     }
  }

d416 7
a422 7
  if(pSIS->pDRIInfo) {
     if(pSIS->pDRIInfo->devPrivate) {
        xfree(pSIS->pDRIInfo->devPrivate);
        pSIS->pDRIInfo->devPrivate=0;
     }
     DRIDestroyInfoRec(pSIS->pDRIInfo);
     pSIS->pDRIInfo=0;
d424 2
a425 2
  if(pSIS->pVisualConfigs) xfree(pSIS->pVisualConfigs);
  if(pSIS->pVisualConfigsPriv) xfree(pSIS->pVisualConfigsPriv);
d428 1
a428 1
     xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Freeing AGP memory\n");
d430 1
a430 1
     xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Releasing AGP module\n");
d484 1
a484 1
    saPriv = (SISSAREAPriv*)DRIGetSAREAPrivate(pScreen);
d489 1
a489 2
    saPriv->QueueLength = *(pSiS->cmdQueueLenPtr);
    pSiS->cmdQueueLenPtrBackup = pSiS->cmdQueueLenPtr;
d491 1
d493 4
a496 15
    if(pSiS->VGAEngine == SIS_315_VGA) {
#ifdef SIS315DRI
       saPriv->AGPVtxBufNext = 0;
       saPriv->sharedWPoffset = pSiS->cmdQ_SharedWritePort_2D;
       pSiS->cmdQ_SharedWritePortBackup = pSiS->cmdQ_SharedWritePort;
       pSiS->cmdQ_SharedWritePort = &(saPriv->sharedWPoffset);
#endif
    } else {
       saPriv->AGPCmdBufNext = 0;

       /* frame control */
       saPriv->FrameCount = 0;
       *(unsigned long *)(pSiS->IOBase+0x8a2c) = 0;
       SiSIdle
    }
d498 1
a498 1

d508 1
a508 1
  SISPtr pSiS = SISPTR(pScrn);
d525 4
a528 9
   */
  if(pSiS->VGAEngine == SIS_315_VGA) {
#ifdef SIS315DRI
     /* ? */
#endif
  } else {
     *(pSiS->IOBase + 0x8B50) = 0xff;
     *(unsigned int *)(pSiS->IOBase + 0x8B60) = -1;
  }
d538 1
a538 7
  if(pSiS->VGAEngine == SIS_315_VGA) {
#ifdef SIS315DRI
     SiS315Idle		/* 315 series */
#endif
  } else {
     SiSIdle		/* 300 series */
  }
d549 1
a549 7
  if(pSiS->VGAEngine == SIS_315_VGA) {
#ifdef SIS315DRI
     SiS315Idle		/* 315 series */
#endif
  } else {
     SiSIdle		/* 300 series */
  }
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_dri.c,v 1.25 2003/01/29 15:42:17 eich Exp $ */
d3 1
a3 6
/*
 *  DRI wrapper for 300, 540, 630, 730
 *  (310/325 series experimental and incomplete)
 *
 * taken and modified from tdfx_dri.c, mga_dri.c
 */
d18 1
a18 3
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
#include "xf86drmCompat.h"
#endif
a19 1
/* TW: Idle function for 300 series */
a25 11
/* TW: Idle function for 310/325 series */
#define Q_STATUS 0x85CC
#define SiS310Idle \
  { \
  while( (MMIO_IN16(pSiS->IOBase, Q_STATUS+2) & 0x8000) != 0x8000){}; \
  while( (MMIO_IN16(pSiS->IOBase, Q_STATUS+2) & 0x8000) != 0x8000){}; \
  while( (MMIO_IN16(pSiS->IOBase, Q_STATUS+2) & 0x8000) != 0x8000){}; \
  MMIO_IN16(pSiS->IOBase, Q_STATUS); \
  }


a55 4
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
extern Bool drmSiSAgpInit(int driSubFD, int offset, int size);
#endif

a224 1
  
d226 1
a226 10

  /* TW: This was FbMapSize which is wrong as we must not
   *     ever overwrite HWCursor and TQ area. On the other
   *     hand, using availMem here causes MTRR allocation
   *     to fail ("base is not aligned to size"). Since
   *     DRI memory management is done via framebuffer
   *     device, I assume that the size given here
   *     is NOT used for eventual memory management.
   */
  pDRIInfo->frameBufferSize = pSIS->FbMapSize;   /* availMem; */
d228 1
a228 1
  /* TW: scrnOffset is being calulated in sis_vga.c */
a229 1
  
d238 1
a238 1
  /* FIXME need to extend DRI protocol to pass this size back to client
d241 2
a242 3
  pDRIInfo->SAREASize =
    ((sizeof(XF86DRISAREARec) + getpagesize() - 1) & getpagesize()); /* round to page */
    /* ((sizeof(XF86DRISAREARec) + 0xfff) & 0x1000); */ /* round to page */
d495 2
a496 9
    if (pSiS->VGAEngine == SIS_315_VGA) {	/* 310/325 series */
#if 0
       *(unsigned long *)(pSiS->IOBase+0x8a2c) = 0;	/* FIXME: Where is this on the 310 series ? */
#endif
       SiS310Idle
    } else {					/* 300 series (and below) */
       *(unsigned long *)(pSiS->IOBase+0x8a2c) = 0;
       SiSIdle
    }
d508 1
a508 1
  SISPtr pSiS = SISPTR(pScrn);
d525 4
a528 10
   */
  if (pSiS->VGAEngine == SIS_315_VGA) {
#if 0
        *(pSiS->IOBase + 0x8B50) = 0xff;		/* FIXME: Where is this on 310 series */
  	*(unsigned int *)(pSiS->IOBase + 0x8B60) = -1;  /* FIXME: Where is this on 310 series */
#endif
  } else {
  	*(pSiS->IOBase + 0x8B50) = 0xff;
  	*(unsigned int *)(pSiS->IOBase + 0x8B60) = -1;
  }
d538 1
a538 5
  if (pSiS->VGAEngine == SIS_315_VGA) {
  	SiS310Idle		/* 310/325 series */
  } else {
    	SiSIdle			/* 300 series */
  }
d549 1
a549 5
  if (pSiS->VGAEngine == SIS_315_VGA) {
  	SiS310Idle		/* 310/325 series */
  } else {
  	SiSIdle			/* 300 series and below */
  }
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 2
a2 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_dri.c,v 1.41 2004/01/04 18:08:00 twini Exp $ */
d4 2
a5 8
 * DRI wrapper for 300 and 315 series
 *
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria
 *
 * Preliminary 315/330 support by Thomas Winischhofer
 * Portions of Mesa 4/5 changes by Eric Anholt
 *
 * Licensed under the following terms:
d7 1
a7 24
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appears in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * and that the name of the copyright holder not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. The copyright holder makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without expressed or implied warranty.
 *
 * THE COPYRIGHT HOLDER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO
 * EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Previously taken and modified from tdfx_dri.c, mga_dri.c
 *
 * Authors:	Can-Ru Yeou, SiS Inc.
 *		Alan Hourihane, Wigan, England,
 *		Thomas Winischhofer <thomas@@winischhofer.net>
 *		others.
d22 1
d27 1
a27 5
#ifdef SISNEWDRI
#include "sis_common.h"
#endif

/* Idle function for 300 series */
d34 1
a34 1
/* Idle function for 315/330 series */
d36 1
a36 1
#define SiS315Idle \
d40 2
d51 6
d90 3
a92 3

  if(getenv("SIS_FORCE_Z16")) {
     useZ16 = TRUE;
d101 1
a101 1
    numConfigs = (useZ16) ? 8 : 16;
d103 1
a103 1
    if(!(pConfigs = (__GLXvisualConfig*)xcalloc(sizeof(__GLXvisualConfig),
d105 1
a105 1
       return FALSE;
d107 1
a107 1
    if(!(pSISConfigs = (SISConfigPrivPtr)xcalloc(sizeof(SISConfigPrivRec),
d109 2
a110 2
       xfree(pConfigs);
       return FALSE;
d112 1
a112 1
    if(!(pSISConfigPtrs = (SISConfigPrivPtr*)xcalloc(sizeof(SISConfigPrivPtr),
d114 3
a116 3
       xfree(pConfigs);
       xfree(pSISConfigs);
       return FALSE;
d118 2
a119 1
    for(i=0; i<numConfigs; i++)  pSISConfigPtrs[i] = &pSISConfigs[i];
d122 3
a124 3
    for(accum = 0; accum <= 1; accum++) {
      for(z_stencil=0; z_stencil<(useZ16?2:4); z_stencil++) {
        for(db = 0; db <= 1; db++) {
d135 1
a135 1
          if(accum) {
d146 4
a149 2
          if(db) pConfigs[i].doubleBuffer = TRUE;
          else   pConfigs[i].doubleBuffer = FALSE;
d152 1
a152 1
          switch(z_stencil) {
d183 4
a186 4
    if(i != numConfigs) {
       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                 "[dri] Incorrect initialization of visuals. Disabling DRI.\n");
       return FALSE;
d205 1
a205 1
#ifdef SISNEWDRI
a208 5
   pSIS->cmdQueueLenPtrBackup = NULL;
#ifdef SIS315DRI
   pSIS->cmdQ_SharedWritePortBackup = NULL;
#endif

d210 5
a214 6
    * for canonical symbols in each module.
    */
   if(!xf86LoaderCheckSymbol("GlxSetVisualConfigs")) return FALSE;
   if(!xf86LoaderCheckSymbol("DRIScreenInit"))       return FALSE;
   if(!xf86LoaderCheckSymbol("drmAvailable"))        return FALSE;
   if(!xf86LoaderCheckSymbol("DRIQueryVersion")) {
d216 1
a216 1
                "[dri] SISDRIScreenInit failed (libdri.a too old)\n");
d224 1
a224 1
      if(major != 4 || minor < 0) {
d227 2
a228 2
                    "\t[dri] libDRI version is %d.%d.%d but version 4.0.x is needed.\n"
                    "\t[dri] Disabling DRI.\n",
d240 5
a244 22
#ifdef SISNEWDRI2
  if(xf86LoaderCheckSymbol("DRICreatePCIBusID")) {
     pDRIInfo->busIdString = DRICreatePCIBusID(pSiS->PciInfo);
  } else {
#endif
     pDRIInfo->busIdString = xalloc(64);
     sprintf(pDRIInfo->busIdString, "PCI:%d:%d:%d",
             ((pciConfigPtr)pSIS->PciInfo->thisCard)->busnum,
      	     ((pciConfigPtr)pSIS->PciInfo->thisCard)->devnum,
      	     ((pciConfigPtr)pSIS->PciInfo->thisCard)->funcnum);
#ifdef SISNEWDRI2
  }
#endif

  /* Hack to keep old DRI working -- checked for major==1 and
   * minor==1.
   */
#ifdef SISNEWDRI
  pDRIInfo->ddxDriverMajorVersion = SIS_MAJOR_VERSION;
  pDRIInfo->ddxDriverMinorVersion = SIS_MINOR_VERSION;
  pDRIInfo->ddxDriverPatchVersion = SIS_PATCHLEVEL;
#else
d248 1
a248 2
#endif

d266 2
a267 2
  if(SAREA_MAX_DRAWABLES < SIS_MAX_DRAWABLES)
     pDRIInfo->maxDrawableTableEntry = SAREA_MAX_DRAWABLES;
d269 1
a269 1
     pDRIInfo->maxDrawableTableEntry = SIS_MAX_DRAWABLES;
d283 4
a286 4
  if(sizeof(XF86DRISAREARec)+sizeof(SISSAREAPriv) > SAREA_MAX) {
     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"Data does not fit in SAREA\n");
     return FALSE;
d291 4
a294 4
  if(!(pSISDRI = (SISDRIPtr)xcalloc(sizeof(SISDRIRec),1))) {
     DRIDestroyInfoRec(pSIS->pDRIInfo);
     pSIS->pDRIInfo = 0;
     return FALSE;
d307 17
a323 17
  if(!DRIScreenInit(pScreen, pDRIInfo, &pSIS->drmSubFD)) {
     xf86DrvMsg(pScreen->myNum, X_ERROR,
               "[dri] DRIScreenInit failed. Disabling DRI.\n");
     xfree(pDRIInfo->devPrivate);
     pDRIInfo->devPrivate = 0;
     DRIDestroyInfoRec(pSIS->pDRIInfo);
     pSIS->pDRIInfo = 0;
     pSIS->drmSubFD = -1;
     return FALSE;
  }

#ifdef SISNEWDRI
  /* Check DRM kernel version */
  version = drmGetVersion(pSIS->drmSubFD);
  if(version) {
    if(version->version_major != 1 ||
       version->version_minor < 0) {
d327 2
a328 2
                 "\t[dri] sis.o kernel module version is %d.%d.%d but version 1.0.x is needed.\n"
                 "\t[dri] Disabling the DRI.\n",
d333 1
a333 1
      SISDRICloseScreen(pScreen);
a335 11
    if(version->version_minor >= 1) {
      /* Includes support for framebuffer memory allocation without sisfb */
      drm_sis_fb_t fb;
      fb.offset = pSIS->DRIheapstart;
      fb.size = pSIS->DRIheapend - pSIS->DRIheapstart;
      drmCommandWrite(pSIS->drmSubFD, DRM_SIS_FB_INIT, &fb, sizeof(fb));
      xf86DrvMsg(pScreen->myNum, X_INFO,
                 "[dri] DRI video RAM memory heap: 0x%lx to 0x%lx (%dKB)\n",
                 pSIS->DRIheapstart, pSIS->DRIheapend,
                 (int)((pSIS->DRIheapend - pSIS->DRIheapstart) >> 10));
    }
d342 6
a347 5
  if(drmAddMap(pSIS->drmSubFD, (drmHandle)pSIS->IOAddress,
        	pSISDRI->regs.size, DRM_REGISTERS, 0,
        	&pSISDRI->regs.handle) < 0) {
     SISDRICloseScreen(pScreen);
     return FALSE;
d354 1
a354 2
  do {
    pSIS->agpWantedSize = pSIS->agpWantedPages * AGP_PAGE_SIZE;
d358 12
d371 5
a375 6
    if(!pSIS->IsAGPCard)
       break;

    if(drmAgpAcquire(pSIS->drmSubFD) < 0) {
       xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to acquire AGP, AGP disabled\n");
       break;
d377 6
d384 1
a384 62
    if(pSIS->VGAEngine == SIS_315_VGA) {
#ifdef SIS315DRI
       /* Default to 1X agp mode in SIS315 */
       if(drmAgpEnable(pSIS->drmSubFD, drmAgpGetMode(pSIS->drmSubFD) & ~0x00000002) < 0) {
          xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to enable AGP, AGP disabled\n");
          break;
       }
#endif
    } else {
       /* TODO: default value is 2x? */
       if(drmAgpEnable(pSIS->drmSubFD, drmAgpGetMode(pSIS->drmSubFD) & ~0x0) < 0) {
          xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to enable AGP, AGP disabled\n");
          break;
       }
    }

    xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] AGP enabled\n");

#define AGP_DEFAULT_SIZE_MB 8
#define AGP_DEFAULT_SIZE    (AGP_DEFAULT_SIZE_MB * 1024 * 1024)

    if(drmAgpAlloc(pSIS->drmSubFD, pSIS->agpWantedSize, 0, NULL, &pSIS->agpHandle) < 0) {
       xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to allocate %dMB AGP memory\n",
                  (int)(pSIS->agpWantedSize / (1024 * 1024)));
       if(pSIS->agpWantedSize > AGP_DEFAULT_SIZE) {
          xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Retrying with %dMB\n", AGP_DEFAULT_SIZE_MB);
          pSIS->agpWantedSize = AGP_DEFAULT_SIZE;
          if(drmAgpAlloc(pSIS->drmSubFD, pSIS->agpWantedSize, 0, NULL, &pSIS->agpHandle) < 0) {
             xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to allocate %dMB AGP memory, AGP disabled\n",
	  	        AGP_DEFAULT_SIZE_MB);
             drmAgpRelease(pSIS->drmSubFD);
             break;
	  }
       } else {
          drmAgpRelease(pSIS->drmSubFD);
          break;
       }
    }

    xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Allocated %dMB AGP memory\n",
    		(int)(pSIS->agpWantedSize / (1024 * 1024)));

    if(drmAgpBind(pSIS->drmSubFD, pSIS->agpHandle, 0) < 0) {
       xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to bind AGP memory\n");
       drmAgpFree(pSIS->drmSubFD, pSIS->agpHandle);
       if(pSIS->agpWantedSize > AGP_DEFAULT_SIZE) {
          xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Retrying with %dMB\n", AGP_DEFAULT_SIZE_MB);
          pSIS->agpWantedSize = AGP_DEFAULT_SIZE;
          if(drmAgpAlloc(pSIS->drmSubFD, pSIS->agpWantedSize, 0, NULL, &pSIS->agpHandle) < 0) {
	     xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to re-allocate AGP memory, AGP disabled\n");
	     drmAgpRelease(pSIS->drmSubFD);
             break;
	  } else if(drmAgpBind(pSIS->drmSubFD, pSIS->agpHandle, 0) < 0) {
	     xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to bind AGP memory again, AGP disabled\n");
             drmAgpFree(pSIS->drmSubFD, pSIS->agpHandle);
	     drmAgpRelease(pSIS->drmSubFD);
             break;
	  }
       } else {
          drmAgpRelease(pSIS->drmSubFD);
          break;
       }
d387 1
a387 4
    xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Bound %dMB AGP memory\n",
	       (int)(pSIS->agpWantedSize / (1024 * 1024)));

    pSIS->agpSize = pSIS->agpWantedSize;
d392 14
a405 24
    if(drmAddMap(pSIS->drmSubFD, (drmHandle)0, pSISDRI->agp.size, DRM_AGP, 0, &pSISDRI->agp.handle) < 0) {
       xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] Failed to map public AGP area, AGP disabled\n");
       pSISDRI->agp.size = 0;
       break;
    }

    if(pSIS->VGAEngine == SIS_315_VGA) {
#ifdef SIS315DRI
       pSIS->agpVtxBufSize = AGP_VTXBUF_SIZE; /* = 2MB */
       pSIS->agpVtxBufAddr = pSIS->agpAddr;
       pSIS->agpVtxBufBase = pSIS->agpVtxBufAddr - pSIS->agpAddr + pSIS->agpBase;
       pSIS->agpVtxBufFree = 0;

       pSISDRI->AGPVtxBufOffset = pSIS->agpVtxBufAddr - pSIS->agpAddr;
       pSISDRI->AGPVtxBufSize = pSIS->agpVtxBufSize;

       drmSiSAgpInit(pSIS->drmSubFD, AGP_VTXBUF_SIZE,(pSIS->agpSize - AGP_VTXBUF_SIZE));
#endif
    } else {

       pSIS->agpCmdBufSize = AGP_CMDBUF_SIZE;
       pSIS->agpCmdBufAddr = pSIS->agpAddr;
       pSIS->agpCmdBufBase = pSIS->agpCmdBufAddr - pSIS->agpAddr + pSIS->agpBase;
       pSIS->agpCmdBufFree = 0;
d407 2
a408 2
       pSISDRI->AGPCmdBufOffset = pSIS->agpCmdBufAddr - pSIS->agpAddr;
       pSISDRI->AGPCmdBufSize = pSIS->agpCmdBufSize;
d410 1
a410 2
       drmSiSAgpInit(pSIS->drmSubFD, AGP_CMDBUF_SIZE,(pSIS->agpSize - AGP_CMDBUF_SIZE));
    }
d420 4
a423 3
  if((drmCtlInstHandler(pSIS->drmSubFD, pSIS->irq)) != 0) {
     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
         "[drm] Failed to add IRQ %d handler, stereo disabled\n",
d425 6
a430 4
     pSIS->irqEnabled = FALSE;
  } else {
     pSIS->irqEnabled = TRUE;
  }
d434 3
a436 3
  if(!(SISInitVisualConfigs(pScreen))) {
     SISDRICloseScreen(pScreen);
     return FALSE;
d438 1
a438 2

  xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[dri] Visual configs initialized.\n" );
a448 13
  if(pSIS->VGAEngine == SIS_315_VGA) {
#ifdef SIS315DRI
     if(pSIS->cmdQ_SharedWritePortBackup) {
        pSIS->cmdQ_SharedWritePort = pSIS->cmdQ_SharedWritePortBackup;
     }
#endif
  } else {
     if(pSIS->cmdQueueLenPtrBackup) {
        pSIS->cmdQueueLenPtr = pSIS->cmdQueueLenPtrBackup;
        *(pSIS->cmdQueueLenPtr) = 0;
     }
  }

d451 7
a457 7
  if(pSIS->pDRIInfo) {
     if(pSIS->pDRIInfo->devPrivate) {
        xfree(pSIS->pDRIInfo->devPrivate);
        pSIS->pDRIInfo->devPrivate=0;
     }
     DRIDestroyInfoRec(pSIS->pDRIInfo);
     pSIS->pDRIInfo=0;
d459 2
a460 2
  if(pSIS->pVisualConfigs) xfree(pSIS->pVisualConfigs);
  if(pSIS->pVisualConfigsPriv) xfree(pSIS->pVisualConfigsPriv);
d463 1
a463 1
     xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Freeing AGP memory\n");
d465 1
a465 1
     xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Releasing AGP module\n");
d519 1
a519 1
    saPriv = (SISSAREAPriv*)DRIGetSAREAPrivate(pScreen);
d524 1
a524 2
    saPriv->QueueLength = *(pSiS->cmdQueueLenPtr);
    pSiS->cmdQueueLenPtrBackup = pSiS->cmdQueueLenPtr;
d526 1
d528 5
a532 6
    if(pSiS->VGAEngine == SIS_315_VGA) {
#ifdef SIS315DRI
       saPriv->AGPVtxBufNext = 0;
       saPriv->sharedWPoffset = pSiS->cmdQ_SharedWritePort_2D;
       pSiS->cmdQ_SharedWritePortBackup = pSiS->cmdQ_SharedWritePort;
       pSiS->cmdQ_SharedWritePort = &(saPriv->sharedWPoffset);
d534 2
a535 5
    } else {
       saPriv->AGPCmdBufNext = 0;

       /* frame control */
       saPriv->FrameCount = 0;
d540 1
a540 1

d568 4
a571 3
  if(pSiS->VGAEngine == SIS_315_VGA) {
#ifdef SIS315DRI
     /* ? */
d574 2
a575 2
     *(pSiS->IOBase + 0x8B50) = 0xff;
     *(unsigned int *)(pSiS->IOBase + 0x8B60) = -1;
d586 2
a587 4
  if(pSiS->VGAEngine == SIS_315_VGA) {
#ifdef SIS315DRI
     SiS315Idle		/* 315 series */
#endif
d589 1
a589 1
     SiSIdle		/* 300 series */
d601 2
a602 4
  if(pSiS->VGAEngine == SIS_315_VGA) {
#ifdef SIS315DRI
     SiS315Idle		/* 315 series */
#endif
d604 1
a604 1
     SiSIdle		/* 300 series */
@


