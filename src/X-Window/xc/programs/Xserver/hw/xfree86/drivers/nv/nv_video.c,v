head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407221130:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	cvs-200311162121:1.1.1.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.07.20;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.07.20;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.36.30;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.18.39;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.23.36;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/nv_video.c,v 1.6 2001/12/14 01:20:44 mvojkovi Exp $ */

#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86Resources.h"
#include "xf86_ansic.h"
#include "compiler.h"
#include "xf86PciInfo.h"
#include "xf86Pci.h"
#include "xf86fbman.h"
#include "regionstr.h"

#include "xf86xv.h"
#include "Xv.h"
#include "xaa.h"
#include "xaalocal.h"
#include "dixstruct.h"
#include "fourcc.h"

#include "nv_include.h"
#include "nvreg.h"
#include "nvvga.h"



#define OFF_DELAY 	450  /* milliseconds */
#define FREE_DELAY 	10000

#define OFF_TIMER 	0x01
#define FREE_TIMER	0x02
#define CLIENT_VIDEO_ON	0x04

#define TIMER_MASK      (OFF_TIMER | FREE_TIMER)



#ifndef XvExtension
void NVInitVideo(ScreenPtr pScreen) {}
#else

typedef struct _NVPortPrivRec {
   short        brightness;
   short        contrast;
   short        saturation;
   short        hue;
   RegionRec    clip;
   CARD32       colorKey;
   Bool         autopaintColorKey;
   Bool		doubleBuffer;
   CARD32       videoStatus;
   int		currentBuffer;
   Time         videoTime;
   Bool		grabbedByV4L;
   FBLinearPtr  linear;
   int pitch;
   int offset;
} NVPortPrivRec, *NVPortPrivPtr;


static XF86VideoAdaptorPtr NVSetupImageVideo(ScreenPtr);

static void NVResetVideo(ScrnInfoPtr);

static void NVStopOverlay (ScrnInfoPtr);
static void NVPutOverlayImage(ScrnInfoPtr pScrnInfo,
                              int offset,
			      int id,
			      int dstPitch,
                              BoxPtr dstBox,
			      int x1, int y1, int x2, int y2,
                              short width, short height,
                              short src_w, short src_h,
                              short dst_w, short dst_h,
                              RegionPtr cliplist);

static int  NVSetPortAttribute(ScrnInfoPtr, Atom, INT32, pointer);
static int  NVGetPortAttribute(ScrnInfoPtr, Atom ,INT32 *, pointer);

static void NVStopOverlayVideo(ScrnInfoPtr, pointer, Bool);

static int  NVPutImage( ScrnInfoPtr, short, short, short, short, short, short, short, short, int, unsigned char*, short, short, Bool, RegionPtr, pointer);
static void NVQueryBestSize(ScrnInfoPtr, Bool, short, short, short, short, unsigned int *, unsigned int *, pointer);
static int  NVQueryImageAttributes(ScrnInfoPtr, int, unsigned short *, unsigned short *,  int *, int *);

static void NVVideoTimerCallback(ScrnInfoPtr, Time);

static void NVInitOffscreenImages (ScreenPtr pScreen);


#define GET_OVERLAY_PRIVATE(pNv) \
   (NVPortPrivPtr)((pNv)->overlayAdaptor->pPortPrivates[0].ptr)

#define GET_BLIT_PRIVATE(pNv) \
   (NVPortPrivPtr)((pNv)->blitAdaptor->pPortPrivates[0].ptr)

#define MAKE_ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)

static Atom xvBrightness, xvContrast, xvColorKey, xvSaturation, 
            xvHue, xvAutopaintColorKey, xvSetDefaults, xvDoubleBuffer;

/* client libraries expect an encoding */
static XF86VideoEncodingRec DummyEncoding =
{ 
   0,
   "XV_IMAGE",
   2046, 2047,
   {1, 1}
};

#define NUM_FORMATS_ALL 6

XF86VideoFormatRec NVFormats[NUM_FORMATS_ALL] = 
{
   {15, TrueColor}, {16, TrueColor}, {24, TrueColor},
   {15, DirectColor}, {16, DirectColor}, {24, DirectColor}
};

#define NUM_ATTRIBUTES 8

XF86AttributeRec NVAttributes[NUM_ATTRIBUTES] =
{
   {XvSettable | XvGettable, 0, 1, "XV_DOUBLE_BUFFER"},
   {XvSettable | XvGettable, 0, (1 << 24) - 1, "XV_COLORKEY"},
   {XvSettable | XvGettable, 0, 1, "XV_AUTOPAINT_COLORKEY"},
   {XvSettable             , 0, 0, "XV_SET_DEFAULTS"},
   {XvSettable | XvGettable, -512, 511, "XV_BRIGHTNESS"},
   {XvSettable | XvGettable, 0, 8191, "XV_CONTRAST"},
   {XvSettable | XvGettable, 0, 8191, "XV_SATURATION"},
   {XvSettable | XvGettable, 0, 360, "XV_HUE"}
};

#define NUM_IMAGES_ALL 4

static XF86ImageRec NVImages[NUM_IMAGES_ALL] =
{
    XVIMAGE_YUY2,
    XVIMAGE_YV12,
    XVIMAGE_UYVY,
    XVIMAGE_I420
};

static void 
NVSetPortDefaults (ScrnInfoPtr pScrnInfo, NVPortPrivPtr pPriv)
{
    NVPtr pNv = NVPTR(pScrnInfo);

    pPriv->brightness           = 0;
    pPriv->contrast             = 4096;
    pPriv->saturation           = 4096;
    pPriv->hue                  = 0;
    pPriv->colorKey             = pNv->videoKey;
    pPriv->autopaintColorKey    = TRUE;
    pPriv->doubleBuffer		= TRUE;
}


static void 
NVResetVideo (ScrnInfoPtr pScrnInfo)
{
    NVPtr          pNv     = NVPTR(pScrnInfo);
    NVPortPrivPtr  pPriv   = GET_OVERLAY_PRIVATE(pNv);
    RIVA_HW_INST  *pRiva   = &(pNv->riva);
    int            satSine, satCosine;
    double         angle;
    
    angle = (double)pPriv->hue * 3.1415927 / 180.0;
    
    satSine = pPriv->saturation * sin(angle);
    if (satSine < -1024)
        satSine = -1024;
    satCosine = pPriv->saturation * cos(angle);
    if (satCosine < -1024)
        satCosine = -1024;
    
    pRiva->PMC[0x00008910/4] = (pPriv->brightness << 16) | pPriv->contrast;
    pRiva->PMC[0x00008914/4] = (pPriv->brightness << 16) | pPriv->contrast;
    pRiva->PMC[0x00008918/4] = (satSine << 16) | (satCosine & 0xffff);
    pRiva->PMC[0x0000891C/4] = (satSine << 16) | (satCosine & 0xffff);
    pRiva->PMC[0x00008b00/4] = pPriv->colorKey;
}



static void 
NVStopOverlay (ScrnInfoPtr pScrnInfo)
{
    NVPtr          pNv     = NVPTR(pScrnInfo);
    RIVA_HW_INST  *pRiva   = &(pNv->riva);

    pRiva->PMC[0x00008704/4] = 1;
}

static FBLinearPtr
NVAllocateOverlayMemory(
   ScrnInfoPtr pScrn,
   FBLinearPtr linear,
   int size
){
   ScreenPtr pScreen;
   FBLinearPtr new_linear;

   if(linear) {
        if(linear->size >= size) 
           return linear;
        
        if(xf86ResizeOffscreenLinear(linear, size))
           return linear;

        xf86FreeOffscreenLinear(linear);
   }

   pScreen = screenInfo.screens[pScrn->scrnIndex];

   new_linear = xf86AllocateOffscreenLinear(pScreen, size, 32, 
                                                NULL, NULL, NULL);

   if(!new_linear) {
        int max_size;

        xf86QueryLargestOffscreenLinear(pScreen, &max_size, 32, 
                                                PRIORITY_EXTREME);
        
        if(max_size < size)
           return NULL;

        xf86PurgeUnlockedOffscreenAreas(pScreen);
        new_linear = xf86AllocateOffscreenLinear(pScreen, size, 32, 
                                                NULL, NULL, NULL);
   }

   return new_linear;
}

static void NVFreeOverlayMemory(ScrnInfoPtr pScrnInfo)
{
    NVPtr               pNv   = NVPTR(pScrnInfo);
    NVPortPrivPtr  pPriv   = GET_OVERLAY_PRIVATE(pNv);

    if(pPriv->linear) {
        xf86FreeOffscreenLinear(pPriv->linear);
	pPriv->linear = NULL;
    }
}


void NVInitVideo (ScreenPtr pScreen)
{
    ScrnInfoPtr 	pScrn = xf86Screens[pScreen->myNum];
    XF86VideoAdaptorPtr *adaptors, *newAdaptors = NULL;
    XF86VideoAdaptorPtr overlayAdaptor = NULL;
    NVPtr         	pNv   = NVPTR(pScrn);
    int 		num_adaptors;

    if((pScrn->bitsPerPixel != 8) && (pNv->riva.Architecture >= NV_ARCH_10))
    {
	overlayAdaptor = NVSetupImageVideo(pScreen);
  
	if(overlayAdaptor)
	    NVInitOffscreenImages(pScreen);
    }

    num_adaptors = xf86XVListGenericAdaptors(pScrn, &adaptors);
    
    if(overlayAdaptor) {
	int size = num_adaptors + 1;

        if((newAdaptors = xalloc(size * sizeof(XF86VideoAdaptorPtr*)))) {
	    if(num_adaptors)
		memcpy(newAdaptors, adaptors,
			num_adaptors * sizeof(XF86VideoAdaptorPtr));

	    if(overlayAdaptor) {
		newAdaptors[num_adaptors] = overlayAdaptor;
		num_adaptors++;
	    }
	    adaptors = newAdaptors;
	}
    }

    if (num_adaptors)
        xf86XVScreenInit(pScreen, adaptors, num_adaptors);

    if (newAdaptors)
	xfree(newAdaptors);    
}


static XF86VideoAdaptorPtr 
NVSetupImageVideo (ScreenPtr pScreen)
{
    ScrnInfoPtr pScrnInfo = xf86Screens[pScreen->myNum];
    NVPtr       pNv       = NVPTR(pScrnInfo);
    XF86VideoAdaptorPtr adapt;
    NVPortPrivPtr       pPriv;
    
    if (!(adapt = xcalloc(1, sizeof(XF86VideoAdaptorRec) + 
                             sizeof(NVPortPrivRec) + 
                             sizeof(DevUnion))))
    {
        return NULL;
    } 

    adapt->type                 = XvWindowMask | XvInputMask | XvImageMask;
    adapt->flags                = VIDEO_OVERLAID_IMAGES|VIDEO_CLIP_TO_VIEWPORT;
    adapt->name                 = "NV Video Overlay";
    adapt->nEncodings           = 1;
    adapt->pEncodings           = &DummyEncoding;
    adapt->nFormats             = NUM_FORMATS_ALL;
    adapt->pFormats             = NVFormats;
    adapt->nPorts               = 1;
    adapt->pPortPrivates        = (DevUnion*)(&adapt[1]);
    pPriv                       = (NVPortPrivPtr)(&adapt->pPortPrivates[1]);
    adapt->pPortPrivates[0].ptr = (pointer)(pPriv);
    adapt->pAttributes          = NVAttributes;
    adapt->nAttributes          = NUM_ATTRIBUTES;
    adapt->pImages              = NVImages;
    adapt->nImages              = NUM_IMAGES_ALL;
    adapt->PutVideo             = NULL;
    adapt->PutStill             = NULL;
    adapt->GetVideo             = NULL;
    adapt->GetStill             = NULL;
    adapt->StopVideo            = NVStopOverlayVideo;
    adapt->SetPortAttribute     = NVSetPortAttribute;
    adapt->GetPortAttribute     = NVGetPortAttribute;
    adapt->QueryBestSize        = NVQueryBestSize;
    adapt->PutImage             = NVPutImage;
    adapt->QueryImageAttributes = NVQueryImageAttributes;
    
    pPriv->videoStatus		= 0;
    pPriv->currentBuffer	= 0;
    pPriv->grabbedByV4L		= FALSE;

    NVSetPortDefaults (pScrnInfo, pPriv);
    
    /* gotta uninit this someplace */
    REGION_INIT(pScreen, &pPriv->clip, NullBox, 0); 
    
    pNv->overlayAdaptor		= adapt;
    
    xvBrightness        = MAKE_ATOM("XV_BRIGHTNESS");
    xvDoubleBuffer      = MAKE_ATOM("XV_DOUBLE_BUFFER");
    xvContrast          = MAKE_ATOM("XV_CONTRAST");
    xvColorKey          = MAKE_ATOM("XV_COLORKEY");
    xvSaturation        = MAKE_ATOM("XV_SATURATION");
    xvHue               = MAKE_ATOM("XV_HUE");
    xvAutopaintColorKey = MAKE_ATOM("XV_AUTOPAINT_COLORKEY");
    xvSetDefaults       = MAKE_ATOM("XV_SET_DEFAULTS");

    NVResetVideo(pScrnInfo);

    return adapt;
}

/*
 * RegionsEqual
 */
static Bool RegionsEqual
(
    RegionPtr A,
    RegionPtr B
)
{
    int *dataA, *dataB;
    int num;
    
    num = REGION_NUM_RECTS(A);
    if (num != REGION_NUM_RECTS(B))
        return FALSE;
    
    if ((A->extents.x1 != B->extents.x1) ||
        (A->extents.x2 != B->extents.x2) ||
        (A->extents.y1 != B->extents.y1) ||
        (A->extents.y2 != B->extents.y2))
        return FALSE;
    
    dataA = (int*)REGION_RECTS(A);
    dataB = (int*)REGION_RECTS(B);
    
    while(num--)
    {
        if((dataA[0] != dataB[0]) || (dataA[1] != dataB[1]))
            return FALSE;
        dataA += 2; 
        dataB += 2;
    }
    return TRUE;
}

static void
NVPutOverlayImage (
    ScrnInfoPtr pScrnInfo,
    int         offset,
    int         id,
    int         dstPitch,
    BoxPtr      dstBox,
    int         x1,
    int         y1,
    int		x2,
    int		y2,
    short       width,
    short       height,
    short       src_w,
    short       src_h,
    short       drw_w,
    short       drw_h,
    RegionPtr   clipBoxes
)
{
    NVPtr          pNv     = NVPTR(pScrnInfo);
    NVPortPrivPtr  pPriv   = GET_OVERLAY_PRIVATE(pNv);
    RIVA_HW_INST  *pRiva   = &(pNv->riva);
    int buffer = pPriv->currentBuffer;

    /* paint the color key */
    if(pPriv->autopaintColorKey && 
       (pPriv->grabbedByV4L || !RegionsEqual(&pPriv->clip, clipBoxes)))
    {
	/* we always paint V4L's color key */
	if(!pPriv->grabbedByV4L)
           REGION_COPY(pScrnInfo->pScreen, &pPriv->clip, clipBoxes);
        xf86XVFillKeyHelper(pScrnInfo->pScreen, pPriv->colorKey, clipBoxes);
    }

    pRiva->PMC[(0x8900/4) + buffer] = offset;
    pRiva->PMC[(0x8928/4) + buffer] = (height << 16) | width;
    pRiva->PMC[(0x8930/4) + buffer] = ((y1 << 4) & 0xffff0000) | (x1 >> 12);
    pRiva->PMC[(0x8938/4) + buffer] = (src_w << 20) / drw_w;
    pRiva->PMC[(0x8940/4) + buffer] = (src_h << 20) / drw_h;
    pRiva->PMC[(0x8948/4) + buffer] = (dstBox->y1 << 16) | dstBox->x1;
    pRiva->PMC[(0x8950/4) + buffer] = ((dstBox->y2 - dstBox->y1) << 16) |
                               	       (dstBox->x2 - dstBox->x1);

    dstPitch |= 1 << 20;   /* use color key */

    if(id != FOURCC_UYVY)
	dstPitch |= 1 << 16;

    pRiva->PMC[(0x8958/4) + buffer] = dstPitch;
    pRiva->PMC[0x00008704/4] = 0;
    pRiva->PMC[0x8700/4] = 1 << (buffer << 2);

    pPriv->videoStatus = CLIENT_VIDEO_ON;
}



/*
 * StopVideo
 */
static void NVStopOverlayVideo
(
    ScrnInfoPtr pScrnInfo,
    pointer     data,
    Bool        Exit
)
{
    NVPtr pNv = NVPTR(pScrnInfo);
    NVPortPrivPtr pPriv = (NVPortPrivPtr)data;

    if(pPriv->grabbedByV4L) return;
    
    REGION_EMPTY(pScrnInfo->pScreen, &pPriv->clip);   

    if(Exit)
    {
	if(pPriv->videoStatus & CLIENT_VIDEO_ON) 
            NVStopOverlay(pScrnInfo);
	NVFreeOverlayMemory(pScrnInfo);
	pPriv->videoStatus = 0;
	pNv->VideoTimerCallback = NULL;
    } 
    else 
    {
	if(pPriv->videoStatus & CLIENT_VIDEO_ON) 
        {
	    pPriv->videoStatus = OFF_TIMER | CLIENT_VIDEO_ON;
	    pPriv->videoTime = currentTime.milliseconds + OFF_DELAY; 
	    pNv->VideoTimerCallback = NVVideoTimerCallback;
	}
    }
}



static int NVSetPortAttribute
(
    ScrnInfoPtr pScrnInfo, 
    Atom        attribute,
    INT32       value, 
    pointer     data
)
{
    NVPortPrivPtr pPriv = (NVPortPrivPtr)data;
    
    if (attribute == xvBrightness)
    {
        if ((value < -512) || (value > 512))
            return BadValue;
        pPriv->brightness = value;
    }
    else if (attribute == xvDoubleBuffer)
    {
        if ((value < 0) || (value > 1))
            return BadValue;
        pPriv->doubleBuffer = value;
    }
    else if (attribute == xvContrast)
    {
        if ((value < 0) || (value > 8191))
            return BadValue;
        pPriv->contrast = value;
    }
    else if (attribute == xvHue)
    {
        value %= 360;
        if (value < 0)
            value += 360;
        pPriv->hue = value;
    }
    else if (attribute == xvSaturation)
    {
        if ((value < 0) || (value > 8191))
            return BadValue;
        pPriv->saturation = value;
    }
    else if (attribute == xvColorKey)
    {
        pPriv->colorKey = value;
        REGION_EMPTY(pScrnInfo->pScreen, &pPriv->clip);   
    }
    else if (attribute == xvAutopaintColorKey)
    {
        if ((value < 0) || (value > 1))
            return BadValue;
        pPriv->autopaintColorKey = value;
    }
    else if (attribute == xvSetDefaults)
    {
        NVSetPortDefaults(pScrnInfo, pPriv);
    }
    else
        return BadMatch;
    
    NVResetVideo(pScrnInfo);
    return Success;
}




static int NVGetPortAttribute
(
    ScrnInfoPtr  pScrnInfo, 
    Atom         attribute,
    INT32       *value, 
    pointer      data
)
{
    NVPortPrivPtr pPriv = (NVPortPrivPtr)data;
    
    if (attribute == xvBrightness)
        *value = pPriv->brightness;
    else if (attribute == xvDoubleBuffer)
        *value = (pPriv->doubleBuffer) ? 1 : 0;
    else if (attribute == xvContrast)
        *value = pPriv->contrast;
    else if (attribute == xvSaturation)
        *value = pPriv->saturation;
    else if (attribute == xvHue)
        *value = pPriv->hue;
    else if (attribute == xvColorKey)
        *value = pPriv->colorKey;
    else if (attribute == xvAutopaintColorKey)
        *value = (pPriv->autopaintColorKey) ? 1 : 0;
    else
        return BadMatch;
    
    return Success;
}


/*
 * QueryBestSize
 */
static void NVQueryBestSize
(
    ScrnInfoPtr   pScrnInfo, 
    Bool          motion,
    short         vid_w,
    short         vid_h, 
    short         drw_w,
    short         drw_h, 
    unsigned int *p_w,
    unsigned int *p_h, 
    pointer       data
)
{
    if(vid_w > (drw_w << 3))
	drw_w = vid_w >> 3;
    if(vid_h > (drw_h << 3))
	drw_h = vid_h >> 3;

    *p_w = drw_w;
    *p_h = drw_h; 
}
/*
 * CopyData
 */
static void NVCopyData422
(
  unsigned char *src,
  unsigned char *dst,
  int            srcPitch,
  int            dstPitch,
  int            h,
  int            w
)
{
    w <<= 1;
    while(h--)
    {
        memcpy(dst, src, w);
        src += srcPitch;
        dst += dstPitch;
    }
}
/*
 * CopyMungedData
 */
static void NVCopyData420
(
    unsigned char *src1,
    unsigned char *src2,
    unsigned char *src3,
    unsigned char *dst1,
    int            srcPitch,
    int            srcPitch2,
    int            dstPitch,
    int            h,
    int            w
)
{
   CARD32 *dst;
   CARD8 *s1, *s2, *s3;
   int i, j;

   w >>= 1;

   for(j = 0; j < h; j++) {
        dst = (CARD32*)dst1;
        s1 = src1;  s2 = src2;  s3 = src3;
        i = w;
        while(i > 4) {
#if X_BYTE_ORDER == X_BIG_ENDIAN
           dst[0] = (s1[0] << 24) | (s1[1] << 8) | (s3[0] << 16) | s2[0];
           dst[1] = (s1[2] << 24) | (s1[3] << 8) | (s3[1] << 16) | s2[1];
           dst[2] = (s1[4] << 24) | (s1[5] << 8) | (s3[2] << 16) | s2[2];
           dst[3] = (s1[6] << 24) | (s1[7] << 8) | (s3[3] << 16) | s2[3];
#else
           dst[0] = s1[0] | (s1[1] << 16) | (s3[0] << 8) | (s2[0] << 24);
           dst[1] = s1[2] | (s1[3] << 16) | (s3[1] << 8) | (s2[1] << 24);
           dst[2] = s1[4] | (s1[5] << 16) | (s3[2] << 8) | (s2[2] << 24);
           dst[3] = s1[6] | (s1[7] << 16) | (s3[3] << 8) | (s2[3] << 24);
#endif
           dst += 4; s2 += 4; s3 += 4; s1 += 8;
           i -= 4;
        }

        while(i--) {
#if X_BYTE_ORDER == X_BIG_ENDIAN
           dst[0] = (s1[0] << 24) | (s1[1] << 8) | (s3[0] << 16) | s2[0];
#else
           dst[0] = s1[0] | (s1[1] << 16) | (s3[0] << 8) | (s2[0] << 24);
#endif
           dst++; s2++; s3++;
           s1 += 2;
        }

        dst1 += dstPitch;
        src1 += srcPitch;
        if(j & 1) {
            src2 += srcPitch2;
            src3 += srcPitch2;
        }
   }
}
/*
 * PutImage
 */
static int NVPutImage
( 
    ScrnInfoPtr  pScrnInfo, 
    short        src_x,
    short        src_y, 
    short        drw_x,
    short        drw_y,
    short        src_w,
    short        src_h, 
    short        drw_w,
    short        drw_h,
    int          id,
    unsigned char *buf, 
    short        width,
    short        height, 
    Bool         Sync,
    RegionPtr    clipBoxes,
    pointer      data
)
{
    NVPortPrivPtr pPriv = (NVPortPrivPtr)data;
    NVPtr pNv = NVPTR(pScrnInfo);
    INT32 xa, xb, ya, yb;
    unsigned char *dst_start;
    int pitch, newSize, offset, s2offset, s3offset;
    int srcPitch, srcPitch2, dstPitch;
    int top, left, npixels, nlines, bpp;
    BoxRec dstBox;
    CARD32 tmp;

   /*
    * s2offset, s3offset - byte offsets into U and V plane of the
    *                      source where copying starts.  Y plane is
    *                      done by editing "buf".
    *
    * offset - byte offset to the first line of the destination.
    *
    * dst_start - byte address to the first displayed pel.
    *
    */

    if(pPriv->grabbedByV4L) return Success;

    /* make the compiler happy */
    s2offset = s3offset = srcPitch2 = 0;
    
    if(src_w > (drw_w << 3))
	drw_w = src_w >> 3;
    if(src_h > (drw_h << 3))
	drw_h = src_h >> 3;

    /* Clip */
    xa = src_x;
    xb = src_x + src_w;
    ya = src_y;
    yb = src_y + src_h;
    
    dstBox.x1 = drw_x;
    dstBox.x2 = drw_x + drw_w;
    dstBox.y1 = drw_y;
    dstBox.y2 = drw_y + drw_h;
    
    if(!xf86XVClipVideoHelper(&dstBox, &xa, &xb, &ya, &yb, clipBoxes, 
                              width, height))
    	return Success;
    
    dstBox.x1 -= pScrnInfo->frameX0;
    dstBox.x2 -= pScrnInfo->frameX0;
    dstBox.y1 -= pScrnInfo->frameY0;
    dstBox.y2 -= pScrnInfo->frameY0;

    bpp = pScrnInfo->bitsPerPixel >> 3;
    pitch = bpp * pScrnInfo->displayWidth;

    dstPitch = ((width << 1) + 63) & ~63;

    switch(id) {
    case FOURCC_YV12:
    case FOURCC_I420:
        srcPitch = (width + 3) & ~3;	/* of luma */
        s2offset = srcPitch * height;
        srcPitch2 = ((width >> 1) + 3) & ~3;
        s3offset = (srcPitch2 * (height >> 1)) + s2offset;
        break;
    case FOURCC_UYVY:
    case FOURCC_YUY2:
    default:
        srcPitch = (width << 1);
        break;
    }

    newSize = height * dstPitch / bpp;

    if(pPriv->doubleBuffer)
	newSize <<= 1;

    pPriv->linear = NVAllocateOverlayMemory(pScrnInfo, 
					    pPriv->linear, 
					    newSize);

    if(!pPriv->linear) return BadAlloc;

    offset = pPriv->linear->offset * bpp; 

    if(pPriv->doubleBuffer && pPriv->currentBuffer) 
	offset += (newSize * bpp) >> 1;

    dst_start = pNv->FbStart + offset;
        
    /* copy data */
    top = ya >> 16;
    left = (xa >> 16) & ~1;
    npixels = ((((xb + 0xffff) >> 16) + 1) & ~1) - left;

#if 0
    /* I have my reservations about this */
    if(pPriv->doubleBuffer) {
	RIVA_HW_INST  *pRiva   = &(pNv->riva);
	int mask = 1 << (pPriv->currentBuffer << 2);
	while(pRiva->PMC[0x00008700/4] & mask);
    }
#endif

    switch(id) {
    case FOURCC_YV12:
    case FOURCC_I420:
        top &= ~1;
        dst_start += (left << 1) + (top * dstPitch);
        tmp = ((top >> 1) * srcPitch2) + (left >> 1);
        s2offset += tmp;
        s3offset += tmp;
        if(id == FOURCC_I420) {
           tmp = s2offset;
           s2offset = s3offset;
           s3offset = tmp;
        }
        nlines = ((((yb + 0xffff) >> 16) + 1) & ~1) - top;
        NVCopyData420(buf + (top * srcPitch) + left, buf + s2offset,
                           buf + s3offset, dst_start, srcPitch, srcPitch2,
                           dstPitch, nlines, npixels);
        break;
    case FOURCC_UYVY:
    case FOURCC_YUY2:
    default:
        left <<= 1;
        buf += (top * srcPitch) + left;
        nlines = ((yb + 0xffff) >> 16) - top;
        dst_start += left + (top * dstPitch);
        NVCopyData422(buf, dst_start, srcPitch, dstPitch, nlines, npixels);
        break;
    }

    NVPutOverlayImage(pScrnInfo, offset, id, dstPitch, &dstBox, xa, ya, xb, yb,
                       width, height, src_w, src_h, drw_w, drw_h, clipBoxes);

    pPriv->currentBuffer ^= 1;

    return Success;
}
/*
 * QueryImageAttributes
 */
static int NVQueryImageAttributes
(
    ScrnInfoPtr pScrnInfo, 
    int         id, 
    unsigned short *w,
    unsigned short *h, 
    int         *pitches,
    int         *offsets
)
{
    int size, tmp;
    
    if(*w > 2046)
        *w = 2046;
    if(*h > 2047)
        *h = 2047;
    
    *w = (*w + 1) & ~1;
    if (offsets)
        offsets[0] = 0;
    
    switch (id)
    {
        case FOURCC_YV12:
        case FOURCC_I420:
            *h = (*h + 1) & ~1;
            size = (*w + 3) & ~3;
            if (pitches)
                pitches[0] = size;
            size *= *h;
            if (offsets)
                offsets[1] = size;
            tmp = ((*w >> 1) + 3) & ~3;
            if (pitches)
                pitches[1] = pitches[2] = tmp;
            tmp *= (*h >> 1);
            size += tmp;
            if (offsets)
                offsets[2] = size;
            size += tmp;
            break;
        case FOURCC_UYVY:
        case FOURCC_YUY2:
        default:
            size = *w << 1;
            if (pitches)
                pitches[0] = size;
            size *= *h;
            break;
    }
    return size;
}

static void NVVideoTimerCallback 
(
    ScrnInfoPtr pScrnInfo,
    Time currentTime
)
{
    NVPtr         pNv = NVPTR(pScrnInfo);
    NVPortPrivPtr pOverPriv = NULL;

    pNv->VideoTimerCallback = NULL;

    if(!pScrnInfo->vtSema) return; 

    if(pNv->overlayAdaptor) {
	pOverPriv = GET_OVERLAY_PRIVATE(pNv);
	if(!pOverPriv->videoStatus)
	   pOverPriv = NULL;
    }

    if(pOverPriv) {
         if(pOverPriv->videoTime < currentTime) {
	    if(pOverPriv->videoStatus & OFF_TIMER) {
		NVStopOverlay(pScrnInfo);
		pOverPriv->videoStatus = FREE_TIMER;
                pOverPriv->videoTime = currentTime + FREE_DELAY;
		pNv->VideoTimerCallback = NVVideoTimerCallback;
	    } else
            if(pOverPriv->videoStatus & FREE_TIMER) {
		NVFreeOverlayMemory(pScrnInfo);
		pOverPriv->videoStatus = 0;
	    }	
	 } else
	    pNv->VideoTimerCallback = NVVideoTimerCallback;
    }
}


/***** Exported offscreen surface stuff ****/


static int
NVAllocSurface (
    ScrnInfoPtr pScrnInfo,
    int id,
    unsigned short w,   
    unsigned short h,
    XF86SurfacePtr surface
)
{
    NVPtr pNv = NVPTR(pScrnInfo);
    NVPortPrivPtr pPriv = GET_OVERLAY_PRIVATE(pNv); 
    CARD8 *address;
    int size, bpp;

    bpp = pScrnInfo->bitsPerPixel >> 3;

    if(pPriv->grabbedByV4L) return BadAlloc;

    if((w > 2046) || (h > 2047)) return BadValue;

    w = (w + 1) & ~1;
    pPriv->pitch = ((w << 1) + 63) & ~63;
    size = h * pPriv->pitch / bpp;

    pPriv->linear = NVAllocateOverlayMemory(pScrnInfo, pPriv->linear,
					    size);

    if(!pPriv->linear) return BadAlloc;

    pPriv->offset = pPriv->linear->offset * bpp;
    address = pPriv->offset + pNv->FbStart;

    surface->width = w;
    surface->height = h;
    surface->pScrn = pScrnInfo;
    surface->pitches = &pPriv->pitch; 
    surface->offsets = &pPriv->offset;
    surface->devPrivate.ptr = (pointer)pPriv;

    /* grab the video */
    NVStopOverlay(pScrnInfo);
    pPriv->videoStatus = 0;
    REGION_EMPTY(pScrnInfo->pScreen, &pPriv->clip);
    pNv->VideoTimerCallback = NULL;
    pPriv->grabbedByV4L = TRUE;

    return Success;
}

static int
NVStopSurface (XF86SurfacePtr surface)
{
    NVPortPrivPtr pPriv = (NVPortPrivPtr)(surface->devPrivate.ptr);

    if(pPriv->grabbedByV4L && pPriv->videoStatus) {
	NVStopOverlay(surface->pScrn);
	pPriv->videoStatus = 0;
    }

    return Success;
}

static int 
NVFreeSurface (XF86SurfacePtr surface)
{
    NVPortPrivPtr pPriv = (NVPortPrivPtr)(surface->devPrivate.ptr);

    if(pPriv->grabbedByV4L) {
	NVStopSurface(surface);
	NVFreeOverlayMemory(surface->pScrn);
	pPriv->grabbedByV4L = FALSE;
    }

    return Success;
}

static int
NVGetSurfaceAttribute (
    ScrnInfoPtr pScrnInfo,
    Atom attribute,
    INT32 *value
)
{
    NVPtr pNv = NVPTR(pScrnInfo);
    NVPortPrivPtr pPriv = GET_OVERLAY_PRIVATE(pNv);
    
    return NVGetPortAttribute(pScrnInfo, attribute, value, (pointer)pPriv);
}

static int
NVSetSurfaceAttribute(
    ScrnInfoPtr pScrnInfo,
    Atom attribute,
    INT32 value
)
{
    NVPtr pNv = NVPTR(pScrnInfo);
    NVPortPrivPtr pPriv = GET_OVERLAY_PRIVATE(pNv);
   
    return NVSetPortAttribute(pScrnInfo, attribute, value, (pointer)pPriv);
}

static int
NVDisplaySurface (
    XF86SurfacePtr surface,
    short src_x, short src_y, 
    short drw_x, short drw_y,
    short src_w, short src_h, 
    short drw_w, short drw_h,
    RegionPtr clipBoxes
)
{
    ScrnInfoPtr pScrnInfo = surface->pScrn;
    NVPortPrivPtr pPriv = (NVPortPrivPtr)(surface->devPrivate.ptr);
    INT32 xa, xb, ya, yb;
    BoxRec dstBox;

    if(!pPriv->grabbedByV4L) return Success;

    if(src_w > (drw_w << 3))
	drw_w = src_w >> 3;
    if(src_h > (drw_h << 3))
	drw_h = src_h >> 3;

    /* Clip */
    xa = src_x;
    xb = src_x + src_w;
    ya = src_y;
    yb = src_y + src_h;
    
    dstBox.x1 = drw_x;
    dstBox.x2 = drw_x + drw_w;
    dstBox.y1 = drw_y;
    dstBox.y2 = drw_y + drw_h;
    
    if(!xf86XVClipVideoHelper(&dstBox, &xa, &xb, &ya, &yb, clipBoxes, 
		    surface->width, surface->height))
    {
        return Success;
    }
    
    dstBox.x1 -= pScrnInfo->frameX0;
    dstBox.x2 -= pScrnInfo->frameX0;
    dstBox.y1 -= pScrnInfo->frameY0;
    dstBox.y2 -= pScrnInfo->frameY0;

    pPriv->currentBuffer = 0;

    NVPutOverlayImage (pScrnInfo, surface->offsets[0], surface->id,
			surface->pitches[0], &dstBox, xa, ya, xb, yb,
			surface->width, surface->height, src_w, src_h,
			drw_w, drw_h, clipBoxes);

    return Success;
}

XF86OffscreenImageRec NVOffscreenImages[2] =
{
 {
   &NVImages[0],
   VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT,
   NVAllocSurface,
   NVFreeSurface,
   NVDisplaySurface,
   NVStopSurface,
   NVGetSurfaceAttribute,
   NVSetSurfaceAttribute,
   2046, 2047,
   NUM_ATTRIBUTES - 1,
   &NVAttributes[1]
  },
 {
   &NVImages[2],
   VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT,
   NVAllocSurface,
   NVFreeSurface,
   NVDisplaySurface,
   NVStopSurface,
   NVGetSurfaceAttribute,
   NVSetSurfaceAttribute,
   2046, 2047,
   NUM_ATTRIBUTES - 1,
   &NVAttributes[1]
  },
};

static void
NVInitOffscreenImages (ScreenPtr pScreen)
{
    xf86XVRegisterOffscreenImages(pScreen, NVOffscreenImages, 2);
}

#endif


@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/nv_video.c,v 1.21 2003/11/10 18:22:24 tsi Exp $ */
d21 2
a22 1
#include "nv_dma.h"
d24 4
a27 2
#define OFF_DELAY 	500  /* milliseconds */
#define FREE_DELAY 	5000
d35 5
a39 1
#define NUM_BLIT_PORTS 32
a53 2
   Bool         iturbt_709;
   Bool         blitter;
d60 3
a62 2
static XF86VideoAdaptorPtr NVSetupOverlayVideo(ScreenPtr);
static XF86VideoAdaptorPtr NVSetupBlitVideo(ScreenPtr);
d76 2
a77 5
static int  NVSetOverlayPortAttribute(ScrnInfoPtr, Atom, INT32, pointer);
static int  NVGetOverlayPortAttribute(ScrnInfoPtr, Atom ,INT32 *, pointer);
static int  NVSetBlitPortAttribute(ScrnInfoPtr, Atom, INT32, pointer);
static int  NVGetBlitPortAttribute(ScrnInfoPtr, Atom ,INT32 *, pointer);

a79 1
static void NVStopBlitVideo(ScrnInfoPtr, pointer, Bool);
d99 1
a99 2
            xvHue, xvAutopaintColorKey, xvSetDefaults, xvDoubleBuffer,
            xvITURBT709;
d106 1
a106 1
   2046, 2046,
d118 1
a118 1
#define NUM_ATTRIBUTES 9
d129 1
a129 2
   {XvSettable | XvGettable, 0, 360, "XV_HUE"},
   {XvSettable | XvGettable, 0, 1, "XV_ITURBT_709"}
d132 1
a132 22
#define NUM_IMAGES_YUV 4
#define NUM_IMAGES_ALL 5

#define FOURCC_RGB 0x0000003
#define XVIMAGE_RGB \
   { \
        FOURCC_RGB, \
        XvRGB, \
        LSBFirst, \
        { 0x03, 0x00, 0x00, 0x00, \
          0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
        32, \
        XvPacked, \
        1, \
        24, 0x00ff0000, 0x0000ff00, 0x000000ff, \
        0, 0, 0, \
        0, 0, 0, \
        0, 0, 0, \
        {'B','G','R','X',\
          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
        XvTopToBottom \
   }
d139 1
a139 2
    XVIMAGE_I420,
    XVIMAGE_RGB
a153 1
    pPriv->iturbt_709           = FALSE;
d157 1
a157 1
void 
d162 1
d175 5
a179 5
    pNv->PMC[0x8910/4] = (pPriv->brightness << 16) | pPriv->contrast;
    pNv->PMC[0x8914/4] = (pPriv->brightness << 16) | pPriv->contrast;
    pNv->PMC[0x8918/4] = (satSine << 16) | (satCosine & 0xffff);
    pNv->PMC[0x891C/4] = (satSine << 16) | (satCosine & 0xffff);
    pNv->PMC[0x8b00/4] = pPriv->colorKey;
d188 1
d190 1
a190 1
    pNv->PMC[0x00008704/4] = 1;
a245 12
static void NVFreeBlitMemory(ScrnInfoPtr pScrnInfo)
{
    NVPtr               pNv   = NVPTR(pScrnInfo);
    NVPortPrivPtr  pPriv   = GET_BLIT_PRIVATE(pNv);

    if(pPriv->linear) {
        xf86FreeOffscreenLinear(pPriv->linear);
        pPriv->linear = NULL;
    }
}


a250 1
    XF86VideoAdaptorPtr blitAdaptor = NULL;
d254 3
a256 2
    if((pScrn->bitsPerPixel != 8) && (pNv->Architecture >= NV_ARCH_10)) {
	overlayAdaptor = NVSetupOverlayVideo(pScreen);
a261 3
    if((pScrn->bitsPerPixel != 8) && !pNv->NoAccel)
        blitAdaptor = NVSetupBlitVideo(pScreen);

d264 2
a265 5
    if(blitAdaptor || overlayAdaptor) {
        int size = num_adaptors;

        if(overlayAdaptor) size++;
        if(blitAdaptor)    size++;
d268 7
a274 7
            if(num_adaptors) {
                 memcpy(newAdaptors, adaptors,
                        num_adaptors * sizeof(XF86VideoAdaptorPtr));
            }
            if(overlayAdaptor) {
                newAdaptors[num_adaptors] = overlayAdaptor;
                num_adaptors++;
a275 4
            if(blitAdaptor) {
                newAdaptors[num_adaptors] = blitAdaptor;
                num_adaptors++;
            }
d277 1
a277 1
        }
a287 55
static XF86VideoAdaptorPtr
NVSetupBlitVideo (ScreenPtr pScreen)
{
    ScrnInfoPtr pScrnInfo = xf86Screens[pScreen->myNum];
    NVPtr       pNv       = NVPTR(pScrnInfo);
    XF86VideoAdaptorPtr adapt;
    NVPortPrivPtr       pPriv;
    int         i;

    if (!(adapt = xcalloc(1, sizeof(XF86VideoAdaptorRec) +
                             sizeof(NVPortPrivRec) +
                             (sizeof(DevUnion) * NUM_BLIT_PORTS))))
    {
        return NULL;
    }

    adapt->type                 = XvWindowMask | XvInputMask | XvImageMask;
    adapt->flags                = 0;
    adapt->name                 = "NV Video Blitter";
    adapt->nEncodings           = 1;
    adapt->pEncodings           = &DummyEncoding;
    adapt->nFormats             = NUM_FORMATS_ALL;
    adapt->pFormats             = NVFormats;
    adapt->nPorts               = NUM_BLIT_PORTS;
    adapt->pPortPrivates        = (DevUnion*)(&adapt[1]);

    pPriv = (NVPortPrivPtr)(&adapt->pPortPrivates[NUM_BLIT_PORTS]);
    for(i = 0; i < NUM_BLIT_PORTS; i++)
       adapt->pPortPrivates[i].ptr = (pointer)(pPriv);

    adapt->pAttributes          = NULL;
    adapt->nAttributes          = 0;
    adapt->pImages              = NVImages;
    adapt->nImages              = NUM_IMAGES_ALL;
    adapt->PutVideo             = NULL;
    adapt->PutStill             = NULL;
    adapt->GetVideo             = NULL;
    adapt->GetStill             = NULL;
    adapt->StopVideo            = NVStopBlitVideo;
    adapt->SetPortAttribute     = NVSetBlitPortAttribute;
    adapt->GetPortAttribute     = NVGetBlitPortAttribute;
    adapt->QueryBestSize        = NVQueryBestSize;
    adapt->PutImage             = NVPutImage;
    adapt->QueryImageAttributes = NVQueryImageAttributes;

    pPriv->videoStatus          = 0;
    pPriv->grabbedByV4L         = FALSE;
    pPriv->blitter              = TRUE;
    pPriv->doubleBuffer         = FALSE;

    pNv->blitAdaptor            = adapt;

    return adapt;
}

d289 1
a289 1
NVSetupOverlayVideo (ScreenPtr pScreen)
d317 1
a317 1
    adapt->nImages              = NUM_IMAGES_YUV;
d323 2
a324 2
    adapt->SetPortAttribute     = NVSetOverlayPortAttribute;
    adapt->GetPortAttribute     = NVGetOverlayPortAttribute;
a331 1
    pPriv->blitter              = FALSE;
d336 1
a336 1
    REGION_NULL(pScreen, &pPriv->clip);
a347 1
    xvITURBT709         = MAKE_ATOM("XV_ITURBT_709");
d354 35
d411 1
d416 1
a416 2
       (pPriv->grabbedByV4L ||
	!REGION_EQUAL(pScrnInfo->pScreen, &pPriv->clip, clipBoxes)))
d424 7
a430 13
    if(pNv->CurrentLayout.mode->Flags & V_DBLSCAN) {
        dstBox->y1 <<= 1;
        dstBox->y2 <<= 1;
        drw_h <<= 1;
    }

    pNv->PMC[(0x8900/4) + buffer] = offset;
    pNv->PMC[(0x8928/4) + buffer] = (height << 16) | width;
    pNv->PMC[(0x8930/4) + buffer] = ((y1 << 4) & 0xffff0000) | (x1 >> 12);
    pNv->PMC[(0x8938/4) + buffer] = (src_w << 20) / drw_w;
    pNv->PMC[(0x8940/4) + buffer] = (src_h << 20) / drw_h;
    pNv->PMC[(0x8948/4) + buffer] = (dstBox->y1 << 16) | dstBox->x1;
    pNv->PMC[(0x8950/4) + buffer] = ((dstBox->y2 - dstBox->y1) << 16) |
a436 2
    if(pPriv->iturbt_709)
        dstPitch |= 1 << 24;
d438 3
a440 3
    pNv->PMC[(0x8958/4) + buffer] = dstPitch;
    pNv->PMC[0x00008704/4] = 0;
    pNv->PMC[0x8700/4] = 1 << (buffer << 2);
a446 90
static void
NVPutBlitImage (
    ScrnInfoPtr pScrnInfo,
    int         offset,
    int         id,
    int         dstPitch,
    BoxPtr      dstBox,
    int         x1,
    int         y1,
    int         x2,
    int         y2,
    short       width,
    short       height,
    short       src_w,
    short       src_h,
    short       drw_w,
    short       drw_h,
    RegionPtr   clipBoxes
)
{
    NVPtr          pNv     = NVPTR(pScrnInfo);
    NVPortPrivPtr  pPriv   = GET_BLIT_PRIVATE(pNv);
    BoxPtr         pbox    = REGION_RECTS(clipBoxes);
    int            nbox    = REGION_NUM_RECTS(clipBoxes);
    CARD32         dsdx, dtdy, size, point, srcpoint, format;

    dsdx = (src_w << 20) / drw_w;
    dtdy = (src_h << 20) / drw_h;

    size = ((dstBox->y2 - dstBox->y1) << 16) | (dstBox->x2 - dstBox->x1);
    point = (dstBox->y1 << 16) | dstBox->x1;

    dstPitch |= (STRETCH_BLIT_SRC_FORMAT_ORIGIN_CENTER << 16) |
                (STRETCH_BLIT_SRC_FORMAT_FILTER_BILINEAR << 24);

    srcpoint = ((y1 << 4) & 0xffff0000) | (x1 >> 12);

    switch(id) {
    case FOURCC_RGB:
        format = STRETCH_BLIT_FORMAT_X8R8G8B8;
        break;
    case FOURCC_UYVY:
        format = STRETCH_BLIT_FORMAT_UYVY;
        break;
    default:
        format = STRETCH_BLIT_FORMAT_YUYV;
        break;
    }

    if(pNv->CurrentLayout.depth == 15) {
        NVDmaStart(pNv, SURFACE_FORMAT, 1);
        NVDmaNext (pNv, SURFACE_FORMAT_DEPTH15);
    }

    NVDmaStart(pNv, STRETCH_BLIT_FORMAT, 1);
    NVDmaNext (pNv, format);

    while(nbox--) {
       NVDmaStart(pNv, RECT_SOLID_COLOR, 1);
       NVDmaNext (pNv, 0);

       NVDmaStart(pNv, STRETCH_BLIT_CLIP_POINT, 6);
       NVDmaNext (pNv, (pbox->y1 << 16) | pbox->x1); 
       NVDmaNext (pNv, ((pbox->y2 - pbox->y1) << 16) | (pbox->x2 - pbox->x1));
       NVDmaNext (pNv, point);
       NVDmaNext (pNv, size);
       NVDmaNext (pNv, dsdx);
       NVDmaNext (pNv, dtdy);

       NVDmaStart(pNv, STRETCH_BLIT_SRC_SIZE, 4);
       NVDmaNext (pNv, (height << 16) | width);
       NVDmaNext (pNv, dstPitch);
       NVDmaNext (pNv, offset);
       NVDmaNext (pNv, srcpoint);
       pbox++;
    }

    if(pNv->CurrentLayout.depth == 15) {
        NVDmaStart(pNv, SURFACE_FORMAT, 1);
        NVDmaNext (pNv, SURFACE_FORMAT_DEPTH16);
    }

    NVDmaKickoff(pNv);
    SET_SYNC_FLAG(pNv->AccelInfoRec);

    pPriv->videoStatus = FREE_TIMER;
    pPriv->videoTime = currentTime.milliseconds + FREE_DELAY;
    pNv->VideoTimerCallback = NVVideoTimerCallback;
}

d464 2
a465 1
    if(Exit) {
d470 6
a475 2
    } else { 
	if(pPriv->videoStatus & CLIENT_VIDEO_ON) {
a482 8
static void NVStopBlitVideo
(
    ScrnInfoPtr pScrnInfo,
    pointer     data,
    Bool        Exit
)
{
}
d484 2
a485 1
static int NVSetOverlayPortAttribute
a536 6
    else if (attribute == xvITURBT709)
    {
        if ((value < 0) || (value > 1))
            return BadValue;
        pPriv->iturbt_709 = value;
    }
d549 3
a551 1
static int NVGetOverlayPortAttribute
a574 2
    else if (attribute == xvITURBT709)
        *value = (pPriv->iturbt_709) ? 1 : 0;
a580 22
static int NVSetBlitPortAttribute
(
    ScrnInfoPtr pScrnInfo,
    Atom        attribute,
    INT32       value,
    pointer     data
)
{
    return BadMatch;
}

static int NVGetBlitPortAttribute
(
    ScrnInfoPtr  pScrnInfo,
    Atom         attribute,
    INT32       *value,
    pointer      data
)
{
    return BadMatch;
}

d606 24
a629 1

a686 77


static void NVMoveDWORDS(
   CARD32* dest,
   CARD32* src,
   int dwords )
{
     while(dwords & ~0x03) {
        *dest = *src;
        *(dest + 1) = *(src + 1);
        *(dest + 2) = *(src + 2);
        *(dest + 3) = *(src + 3);
        src += 4;
        dest += 4;
        dwords -= 4;
     }
     if(!dwords) return;
     *dest = *src;
     if(dwords == 1) return;
     *(dest + 1) = *(src + 1);
     if(dwords == 2) return;
     *(dest + 2) = *(src + 2);
}

#if X_BYTE_ORDER == X_BIG_ENDIAN
static void NVMoveDWORDSSwapped(
   CARD32* dest,
   CARD8* src,
   int dwords )
{
     while(dwords--) {
        *dest++ = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
        src += 4;
     }
}
#endif

static void NVCopyData422
(
  unsigned char *src,
  unsigned char *dst,
  int            srcPitch,
  int            dstPitch,
  int            h,
  int            w
)
{
    w >>= 1;  /* pixels to DWORDS */
    while(h--) {
        NVMoveDWORDS((CARD32*)dst, (CARD32*)src, w);
        src += srcPitch;
        dst += dstPitch;
    }
}

static void NVCopyDataRGB
(
  unsigned char *src,
  unsigned char *dst,
  int            srcPitch,
  int            dstPitch,
  int            h,
  int            w
)
{
    while(h--) {
#if X_BYTE_ORDER == X_BIG_ENDIAN
        NVMoveDWORDSSwapped((CARD32*)dst, (CARD8*)src, w);
#else
        NVMoveDWORDS((CARD32*)dst, (CARD32*)src, w);
#endif
        src += srcPitch;
        dst += dstPitch;
    }
}


d714 1
a714 1
    int newSize, offset, s2offset, s3offset;
d716 1
a716 2
    int top, left, right, bottom, npixels, nlines, bpp;
    Bool skip = FALSE;
d736 4
a739 6
    if(!pPriv->blitter) {
       if(src_w > (drw_w << 3))
          drw_w = src_w >> 3;
       if(src_h > (drw_h << 3))
          drw_h = src_h >> 3;
    }
d756 4
a759 6
    if(!pPriv->blitter) {
        dstBox.x1 -= pScrnInfo->frameX0;
        dstBox.x2 -= pScrnInfo->frameX0;
        dstBox.y1 -= pScrnInfo->frameY0;
        dstBox.y2 -= pScrnInfo->frameY0;
    }
d762 3
a772 1
        dstPitch = ((width << 1) + 63) & ~63;
d776 2
a777 2
        srcPitch = width << 1;
        dstPitch = ((width << 1) + 63) & ~63;
a778 6
    case FOURCC_RGB:
        srcPitch = width << 2;
        dstPitch = ((width << 2) + 63) & ~63;
        break;
    default:
        return BadImplementation;
d792 1
a792 1
    offset = pPriv->linear->offset * bpp;
d794 2
a795 17
    if(pPriv->doubleBuffer) {
        int mask = 1 << (pPriv->currentBuffer << 2);

#if 0
        /* burn the CPU until the next buffer is available */
        while(pNv->PMC[0x00008700/4] & mask);
#else
        /* overwrite the newest buffer if there's not one free */
        if(pNv->PMC[0x00008700/4] & mask) {
           if(!pPriv->currentBuffer)
              offset += (newSize * bpp) >> 1;
           skip = TRUE;
        } else 
#endif
        if(pPriv->currentBuffer)
            offset += (newSize * bpp) >> 1;
    }
d799 4
a802 2
    /* We need to enlarge the copied rectangle by a pixel so the HW 
       filtering doesn't pick up junk laying outside of the source */
d804 8
a811 10
    left = (xa - 0x00010000) >> 16;
    if(left < 0) left = 0;
    top = (ya - 0x00010000) >> 16;
    if(top < 0) top = 0;
    right = (xb + 0x0001ffff) >> 16;
    if(right > width) right = width;
    bottom = (yb + 0x0001ffff) >> 16;
    if(bottom > height) bottom = height;

    if(pPriv->blitter) NVSync(pScrnInfo);
a815 2
        left &= ~1;
        npixels = ((right + 1) & ~1) - left;
a816 2
        nlines = ((bottom + 1) & ~1) - top;

d826 4
a829 4
        NVCopyData420(buf + (top * srcPitch) + left,
				buf + s2offset, buf + s3offset,
				dst_start, srcPitch, srcPitch2,
				dstPitch, nlines, npixels);
d833 1
a833 4
        left &= ~1;
        npixels = ((right + 1) & ~1) - left;
        nlines = bottom - top;
        
d836 1
a837 1

d840 1
a840 3
    case FOURCC_RGB:
        npixels = right - left;
        nlines = bottom - top;
d842 2
a843 9
        left <<= 2;
        buf += (top * srcPitch) + left;
        dst_start += left + (top * dstPitch);

        NVCopyDataRGB(buf, dst_start, srcPitch, dstPitch, nlines, npixels);
        break;
    default:
        return BadImplementation;
    }
d845 1
a845 14
    if(!skip) {
       if(pPriv->blitter) {
            NVPutBlitImage(pScrnInfo, offset, id, dstPitch, &dstBox,
                           xa, ya, xb, yb,
                           width, height, src_w, src_h, drw_w, drw_h,
                           clipBoxes);
       } else {
            NVPutOverlayImage(pScrnInfo, offset, id, dstPitch, &dstBox, 
                             xa, ya, xb, yb,
                             width, height, src_w, src_h, drw_w, drw_h, 
                             clipBoxes);
            pPriv->currentBuffer ^= 1;
       }
    } 
d866 2
a867 2
    if(*h > 2046)
        *h = 2046;
d895 1
a900 9
        case FOURCC_RGB:
            size = *w << 2;
            if(pitches)
               pitches[0] = size;
            size *= *h;
            break;
        default:
            *w = *h = size = 0;
            break;
d913 2
a914 2
    NVPortPrivPtr pBlitPriv = NULL;
    Bool needCallback = FALSE;
a923 6
    if(pNv->blitAdaptor) {
        pBlitPriv = GET_BLIT_PRIVATE(pNv);
        if(!pBlitPriv->videoStatus)
           pBlitPriv = NULL;
    }
   
d930 1
a930 1
                needCallback = TRUE;
d936 2
a937 3
	 } else {
            needCallback = TRUE;
         }
a938 11

    if(pBlitPriv) {
        if(pBlitPriv->videoTime < currentTime) {
            NVFreeBlitMemory(pScrnInfo);
            pBlitPriv->videoStatus = 0;              
        } else {
            needCallback = TRUE;
        }
    }

    pNv->VideoTimerCallback = needCallback ? NVVideoTimerCallback : NULL;
d956 1
d963 1
a963 1
    if((w > 2046) || (h > 2046)) return BadValue;
d975 1
a982 1
    surface->id = id;
d988 1
d1031 1
a1031 1
    return NVGetOverlayPortAttribute(pScrnInfo, attribute, value, (pointer)pPriv);
d1044 1
a1044 1
    return NVSetOverlayPortAttribute(pScrnInfo, attribute, value, (pointer)pPriv);
d1112 1
a1112 1
   2046, 2046,
d1125 1
a1125 1
   2046, 2046,
d1136 4
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/nv_video.c,v 1.11 2002/11/26 23:41:59 mvojkovi Exp $ */
d21 3
a53 1
   Bool         iturbt_709;
d62 2
d99 1
a99 2
            xvHue, xvAutopaintColorKey, xvSetDefaults, xvDoubleBuffer,
            xvITURBT709;
d106 1
a106 1
   2046, 2046,
d118 1
a118 1
#define NUM_ATTRIBUTES 9
d129 1
a129 2
   {XvSettable | XvGettable, 0, 360, "XV_HUE"},
   {XvSettable | XvGettable, 0, 1, "XV_ITURBT_709"}
a153 1
    pPriv->iturbt_709           = FALSE;
d157 1
a157 1
void 
a347 1
    xvITURBT709         = MAKE_ATOM("XV_ITURBT_709");
a436 2
    if(pPriv->iturbt_709)
        dstPitch |= 1 << 24;
a536 6
    else if (attribute == xvITURBT709)
    {
        if ((value < 0) || (value > 1))
            return BadValue;
        pPriv->iturbt_709 = value;
    }
a574 2
    else if (attribute == xvITURBT709)
        *value = (pPriv->iturbt_709) ? 1 : 0;
a716 1
    Bool skip = FALSE;
d792 1
a792 1
    offset = pPriv->linear->offset * bpp;
d794 2
a795 18
    if(pPriv->doubleBuffer) {
        RIVA_HW_INST  *pRiva   = &(pNv->riva);
        int mask = 1 << (pPriv->currentBuffer << 2);

#if 0
        /* burn the CPU until the next buffer is available */
        while(pRiva->PMC[0x00008700/4] & mask);
#else
        /* overwrite the newest buffer if there's not one free */
        if(pRiva->PMC[0x00008700/4] & mask) {
           if(!pPriv->currentBuffer)
              offset += (newSize * bpp) >> 1;
           skip = TRUE;
        } else 
#endif
        if(pPriv->currentBuffer)
            offset += (newSize * bpp) >> 1;
    }
d804 9
d842 4
a845 6
    if(!skip) {
       NVPutOverlayImage(pScrnInfo, offset, id, dstPitch, &dstBox, 
                         xa, ya, xb, yb,
                         width, height, src_w, src_h, drw_w, drw_h, clipBoxes);
       pPriv->currentBuffer ^= 1;
    } 
d866 2
a867 2
    if(*h > 2046)
        *h = 2046;
d963 1
a963 1
    if((w > 2046) || (h > 2046)) return BadValue;
a982 1
    surface->id = id;
d1112 1
a1112 1
   2046, 2046,
d1125 1
a1125 1
   2046, 2046,
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/nv_video.c,v 1.21 2003/11/10 18:22:24 tsi Exp $ */
a20 1
#include "nv_dma.h"
d22 3
a24 2
#define OFF_DELAY 	500  /* milliseconds */
#define FREE_DELAY 	5000
d32 5
a36 1
#define NUM_BLIT_PORTS 32
a51 1
   Bool         blitter;
d58 1
a58 2
static XF86VideoAdaptorPtr NVSetupOverlayVideo(ScreenPtr);
static XF86VideoAdaptorPtr NVSetupBlitVideo(ScreenPtr);
d72 2
a73 5
static int  NVSetOverlayPortAttribute(ScrnInfoPtr, Atom, INT32, pointer);
static int  NVGetOverlayPortAttribute(ScrnInfoPtr, Atom ,INT32 *, pointer);
static int  NVSetBlitPortAttribute(ScrnInfoPtr, Atom, INT32, pointer);
static int  NVGetBlitPortAttribute(ScrnInfoPtr, Atom ,INT32 *, pointer);

a75 1
static void NVStopBlitVideo(ScrnInfoPtr, pointer, Bool);
d130 1
a130 22
#define NUM_IMAGES_YUV 4
#define NUM_IMAGES_ALL 5

#define FOURCC_RGB 0x0000003
#define XVIMAGE_RGB \
   { \
        FOURCC_RGB, \
        XvRGB, \
        LSBFirst, \
        { 0x03, 0x00, 0x00, 0x00, \
          0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
        32, \
        XvPacked, \
        1, \
        24, 0x00ff0000, 0x0000ff00, 0x000000ff, \
        0, 0, 0, \
        0, 0, 0, \
        0, 0, 0, \
        {'B','G','R','X',\
          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
        XvTopToBottom \
   }
d137 1
a137 2
    XVIMAGE_I420,
    XVIMAGE_RGB
d161 1
d174 5
a178 5
    pNv->PMC[0x8910/4] = (pPriv->brightness << 16) | pPriv->contrast;
    pNv->PMC[0x8914/4] = (pPriv->brightness << 16) | pPriv->contrast;
    pNv->PMC[0x8918/4] = (satSine << 16) | (satCosine & 0xffff);
    pNv->PMC[0x891C/4] = (satSine << 16) | (satCosine & 0xffff);
    pNv->PMC[0x8b00/4] = pPriv->colorKey;
d187 1
d189 1
a189 1
    pNv->PMC[0x00008704/4] = 1;
a244 12
static void NVFreeBlitMemory(ScrnInfoPtr pScrnInfo)
{
    NVPtr               pNv   = NVPTR(pScrnInfo);
    NVPortPrivPtr  pPriv   = GET_BLIT_PRIVATE(pNv);

    if(pPriv->linear) {
        xf86FreeOffscreenLinear(pPriv->linear);
        pPriv->linear = NULL;
    }
}


a249 1
    XF86VideoAdaptorPtr blitAdaptor = NULL;
d253 3
a255 2
    if((pScrn->bitsPerPixel != 8) && (pNv->Architecture >= NV_ARCH_10)) {
	overlayAdaptor = NVSetupOverlayVideo(pScreen);
a260 3
    if((pScrn->bitsPerPixel != 8) && !pNv->NoAccel)
        blitAdaptor = NVSetupBlitVideo(pScreen);

d263 2
a264 5
    if(blitAdaptor || overlayAdaptor) {
        int size = num_adaptors;

        if(overlayAdaptor) size++;
        if(blitAdaptor)    size++;
d267 7
a273 7
            if(num_adaptors) {
                 memcpy(newAdaptors, adaptors,
                        num_adaptors * sizeof(XF86VideoAdaptorPtr));
            }
            if(overlayAdaptor) {
                newAdaptors[num_adaptors] = overlayAdaptor;
                num_adaptors++;
a274 4
            if(blitAdaptor) {
                newAdaptors[num_adaptors] = blitAdaptor;
                num_adaptors++;
            }
d276 1
a276 1
        }
a286 55
static XF86VideoAdaptorPtr
NVSetupBlitVideo (ScreenPtr pScreen)
{
    ScrnInfoPtr pScrnInfo = xf86Screens[pScreen->myNum];
    NVPtr       pNv       = NVPTR(pScrnInfo);
    XF86VideoAdaptorPtr adapt;
    NVPortPrivPtr       pPriv;
    int         i;

    if (!(adapt = xcalloc(1, sizeof(XF86VideoAdaptorRec) +
                             sizeof(NVPortPrivRec) +
                             (sizeof(DevUnion) * NUM_BLIT_PORTS))))
    {
        return NULL;
    }

    adapt->type                 = XvWindowMask | XvInputMask | XvImageMask;
    adapt->flags                = 0;
    adapt->name                 = "NV Video Blitter";
    adapt->nEncodings           = 1;
    adapt->pEncodings           = &DummyEncoding;
    adapt->nFormats             = NUM_FORMATS_ALL;
    adapt->pFormats             = NVFormats;
    adapt->nPorts               = NUM_BLIT_PORTS;
    adapt->pPortPrivates        = (DevUnion*)(&adapt[1]);

    pPriv = (NVPortPrivPtr)(&adapt->pPortPrivates[NUM_BLIT_PORTS]);
    for(i = 0; i < NUM_BLIT_PORTS; i++)
       adapt->pPortPrivates[i].ptr = (pointer)(pPriv);

    adapt->pAttributes          = NULL;
    adapt->nAttributes          = 0;
    adapt->pImages              = NVImages;
    adapt->nImages              = NUM_IMAGES_ALL;
    adapt->PutVideo             = NULL;
    adapt->PutStill             = NULL;
    adapt->GetVideo             = NULL;
    adapt->GetStill             = NULL;
    adapt->StopVideo            = NVStopBlitVideo;
    adapt->SetPortAttribute     = NVSetBlitPortAttribute;
    adapt->GetPortAttribute     = NVGetBlitPortAttribute;
    adapt->QueryBestSize        = NVQueryBestSize;
    adapt->PutImage             = NVPutImage;
    adapt->QueryImageAttributes = NVQueryImageAttributes;

    pPriv->videoStatus          = 0;
    pPriv->grabbedByV4L         = FALSE;
    pPriv->blitter              = TRUE;
    pPriv->doubleBuffer         = FALSE;

    pNv->blitAdaptor            = adapt;

    return adapt;
}

d288 1
a288 1
NVSetupOverlayVideo (ScreenPtr pScreen)
d316 1
a316 1
    adapt->nImages              = NUM_IMAGES_YUV;
d322 2
a323 2
    adapt->SetPortAttribute     = NVSetOverlayPortAttribute;
    adapt->GetPortAttribute     = NVGetOverlayPortAttribute;
a330 1
    pPriv->blitter              = FALSE;
d335 1
a335 1
    REGION_NULL(pScreen, &pPriv->clip);
d354 35
d411 1
d416 1
a416 2
       (pPriv->grabbedByV4L ||
	!REGION_EQUAL(pScrnInfo->pScreen, &pPriv->clip, clipBoxes)))
d424 7
a430 13
    if(pNv->CurrentLayout.mode->Flags & V_DBLSCAN) {
        dstBox->y1 <<= 1;
        dstBox->y2 <<= 1;
        drw_h <<= 1;
    }

    pNv->PMC[(0x8900/4) + buffer] = offset;
    pNv->PMC[(0x8928/4) + buffer] = (height << 16) | width;
    pNv->PMC[(0x8930/4) + buffer] = ((y1 << 4) & 0xffff0000) | (x1 >> 12);
    pNv->PMC[(0x8938/4) + buffer] = (src_w << 20) / drw_w;
    pNv->PMC[(0x8940/4) + buffer] = (src_h << 20) / drw_h;
    pNv->PMC[(0x8948/4) + buffer] = (dstBox->y1 << 16) | dstBox->x1;
    pNv->PMC[(0x8950/4) + buffer] = ((dstBox->y2 - dstBox->y1) << 16) |
d440 3
a442 3
    pNv->PMC[(0x8958/4) + buffer] = dstPitch;
    pNv->PMC[0x00008704/4] = 0;
    pNv->PMC[0x8700/4] = 1 << (buffer << 2);
a448 90
static void
NVPutBlitImage (
    ScrnInfoPtr pScrnInfo,
    int         offset,
    int         id,
    int         dstPitch,
    BoxPtr      dstBox,
    int         x1,
    int         y1,
    int         x2,
    int         y2,
    short       width,
    short       height,
    short       src_w,
    short       src_h,
    short       drw_w,
    short       drw_h,
    RegionPtr   clipBoxes
)
{
    NVPtr          pNv     = NVPTR(pScrnInfo);
    NVPortPrivPtr  pPriv   = GET_BLIT_PRIVATE(pNv);
    BoxPtr         pbox    = REGION_RECTS(clipBoxes);
    int            nbox    = REGION_NUM_RECTS(clipBoxes);
    CARD32         dsdx, dtdy, size, point, srcpoint, format;

    dsdx = (src_w << 20) / drw_w;
    dtdy = (src_h << 20) / drw_h;

    size = ((dstBox->y2 - dstBox->y1) << 16) | (dstBox->x2 - dstBox->x1);
    point = (dstBox->y1 << 16) | dstBox->x1;

    dstPitch |= (STRETCH_BLIT_SRC_FORMAT_ORIGIN_CENTER << 16) |
                (STRETCH_BLIT_SRC_FORMAT_FILTER_BILINEAR << 24);

    srcpoint = ((y1 << 4) & 0xffff0000) | (x1 >> 12);

    switch(id) {
    case FOURCC_RGB:
        format = STRETCH_BLIT_FORMAT_X8R8G8B8;
        break;
    case FOURCC_UYVY:
        format = STRETCH_BLIT_FORMAT_UYVY;
        break;
    default:
        format = STRETCH_BLIT_FORMAT_YUYV;
        break;
    }

    if(pNv->CurrentLayout.depth == 15) {
        NVDmaStart(pNv, SURFACE_FORMAT, 1);
        NVDmaNext (pNv, SURFACE_FORMAT_DEPTH15);
    }

    NVDmaStart(pNv, STRETCH_BLIT_FORMAT, 1);
    NVDmaNext (pNv, format);

    while(nbox--) {
       NVDmaStart(pNv, RECT_SOLID_COLOR, 1);
       NVDmaNext (pNv, 0);

       NVDmaStart(pNv, STRETCH_BLIT_CLIP_POINT, 6);
       NVDmaNext (pNv, (pbox->y1 << 16) | pbox->x1); 
       NVDmaNext (pNv, ((pbox->y2 - pbox->y1) << 16) | (pbox->x2 - pbox->x1));
       NVDmaNext (pNv, point);
       NVDmaNext (pNv, size);
       NVDmaNext (pNv, dsdx);
       NVDmaNext (pNv, dtdy);

       NVDmaStart(pNv, STRETCH_BLIT_SRC_SIZE, 4);
       NVDmaNext (pNv, (height << 16) | width);
       NVDmaNext (pNv, dstPitch);
       NVDmaNext (pNv, offset);
       NVDmaNext (pNv, srcpoint);
       pbox++;
    }

    if(pNv->CurrentLayout.depth == 15) {
        NVDmaStart(pNv, SURFACE_FORMAT, 1);
        NVDmaNext (pNv, SURFACE_FORMAT_DEPTH16);
    }

    NVDmaKickoff(pNv);
    SET_SYNC_FLAG(pNv->AccelInfoRec);

    pPriv->videoStatus = FREE_TIMER;
    pPriv->videoTime = currentTime.milliseconds + FREE_DELAY;
    pNv->VideoTimerCallback = NVVideoTimerCallback;
}

d466 2
a467 1
    if(Exit) {
d472 6
a477 2
    } else { 
	if(pPriv->videoStatus & CLIENT_VIDEO_ON) {
a484 8
static void NVStopBlitVideo
(
    ScrnInfoPtr pScrnInfo,
    pointer     data,
    Bool        Exit
)
{
}
d486 2
a487 1
static int NVSetOverlayPortAttribute
d557 3
a559 1
static int NVGetOverlayPortAttribute
a590 22
static int NVSetBlitPortAttribute
(
    ScrnInfoPtr pScrnInfo,
    Atom        attribute,
    INT32       value,
    pointer     data
)
{
    return BadMatch;
}

static int NVGetBlitPortAttribute
(
    ScrnInfoPtr  pScrnInfo,
    Atom         attribute,
    INT32       *value,
    pointer      data
)
{
    return BadMatch;
}

d616 24
a639 1

a696 77


static void NVMoveDWORDS(
   CARD32* dest,
   CARD32* src,
   int dwords )
{
     while(dwords & ~0x03) {
        *dest = *src;
        *(dest + 1) = *(src + 1);
        *(dest + 2) = *(src + 2);
        *(dest + 3) = *(src + 3);
        src += 4;
        dest += 4;
        dwords -= 4;
     }
     if(!dwords) return;
     *dest = *src;
     if(dwords == 1) return;
     *(dest + 1) = *(src + 1);
     if(dwords == 2) return;
     *(dest + 2) = *(src + 2);
}

#if X_BYTE_ORDER == X_BIG_ENDIAN
static void NVMoveDWORDSSwapped(
   CARD32* dest,
   CARD8* src,
   int dwords )
{
     while(dwords--) {
        *dest++ = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];
        src += 4;
     }
}
#endif

static void NVCopyData422
(
  unsigned char *src,
  unsigned char *dst,
  int            srcPitch,
  int            dstPitch,
  int            h,
  int            w
)
{
    w >>= 1;  /* pixels to DWORDS */
    while(h--) {
        NVMoveDWORDS((CARD32*)dst, (CARD32*)src, w);
        src += srcPitch;
        dst += dstPitch;
    }
}

static void NVCopyDataRGB
(
  unsigned char *src,
  unsigned char *dst,
  int            srcPitch,
  int            dstPitch,
  int            h,
  int            w
)
{
    while(h--) {
#if X_BYTE_ORDER == X_BIG_ENDIAN
        NVMoveDWORDSSwapped((CARD32*)dst, (CARD8*)src, w);
#else
        NVMoveDWORDS((CARD32*)dst, (CARD32*)src, w);
#endif
        src += srcPitch;
        dst += dstPitch;
    }
}


d724 1
a724 1
    int newSize, offset, s2offset, s3offset;
d726 1
a726 1
    int top, left, right, bottom, npixels, nlines, bpp;
d747 4
a750 6
    if(!pPriv->blitter) {
       if(src_w > (drw_w << 3))
          drw_w = src_w >> 3;
       if(src_h > (drw_h << 3))
          drw_h = src_h >> 3;
    }
d767 4
a770 6
    if(!pPriv->blitter) {
        dstBox.x1 -= pScrnInfo->frameX0;
        dstBox.x2 -= pScrnInfo->frameX0;
        dstBox.y1 -= pScrnInfo->frameY0;
        dstBox.y2 -= pScrnInfo->frameY0;
    }
d773 3
a783 1
        dstPitch = ((width << 1) + 63) & ~63;
d787 2
a788 6
        srcPitch = width << 1;
        dstPitch = ((width << 1) + 63) & ~63;
        break;
    case FOURCC_RGB:
        srcPitch = width << 2;
        dstPitch = ((width << 2) + 63) & ~63;
a789 2
    default:
        return BadImplementation;
d806 1
d811 1
a811 1
        while(pNv->PMC[0x00008700/4] & mask);
d814 1
a814 1
        if(pNv->PMC[0x00008700/4] & mask) {
d826 4
a829 13
    /* We need to enlarge the copied rectangle by a pixel so the HW 
       filtering doesn't pick up junk laying outside of the source */

    left = (xa - 0x00010000) >> 16;
    if(left < 0) left = 0;
    top = (ya - 0x00010000) >> 16;
    if(top < 0) top = 0;
    right = (xb + 0x0001ffff) >> 16;
    if(right > width) right = width;
    bottom = (yb + 0x0001ffff) >> 16;
    if(bottom > height) bottom = height;

    if(pPriv->blitter) NVSync(pScrnInfo);
a833 2
        left &= ~1;
        npixels = ((right + 1) & ~1) - left;
a834 2
        nlines = ((bottom + 1) & ~1) - top;

d844 4
a847 4
        NVCopyData420(buf + (top * srcPitch) + left,
				buf + s2offset, buf + s3offset,
				dst_start, srcPitch, srcPitch2,
				dstPitch, nlines, npixels);
d851 1
a851 4
        left &= ~1;
        npixels = ((right + 1) & ~1) - left;
        nlines = bottom - top;
        
d854 1
a855 1

a857 12
    case FOURCC_RGB:
        npixels = right - left;
        nlines = bottom - top;

        left <<= 2;
        buf += (top * srcPitch) + left;
        dst_start += left + (top * dstPitch);

        NVCopyDataRGB(buf, dst_start, srcPitch, dstPitch, nlines, npixels);
        break;
    default:
        return BadImplementation;
d861 4
a864 12
       if(pPriv->blitter) {
            NVPutBlitImage(pScrnInfo, offset, id, dstPitch, &dstBox,
                           xa, ya, xb, yb,
                           width, height, src_w, src_h, drw_w, drw_h,
                           clipBoxes);
       } else {
            NVPutOverlayImage(pScrnInfo, offset, id, dstPitch, &dstBox, 
                             xa, ya, xb, yb,
                             width, height, src_w, src_h, drw_w, drw_h, 
                             clipBoxes);
            pPriv->currentBuffer ^= 1;
       }
d915 1
a920 9
        case FOURCC_RGB:
            size = *w << 2;
            if(pitches)
               pitches[0] = size;
            size *= *h;
            break;
        default:
            *w = *h = size = 0;
            break;
d933 2
a934 2
    NVPortPrivPtr pBlitPriv = NULL;
    Bool needCallback = FALSE;
a943 6
    if(pNv->blitAdaptor) {
        pBlitPriv = GET_BLIT_PRIVATE(pNv);
        if(!pBlitPriv->videoStatus)
           pBlitPriv = NULL;
    }
   
d950 1
a950 1
                needCallback = TRUE;
d956 2
a957 3
	 } else {
            needCallback = TRUE;
         }
a958 11

    if(pBlitPriv) {
        if(pBlitPriv->videoTime < currentTime) {
            NVFreeBlitMemory(pScrnInfo);
            pBlitPriv->videoStatus = 0;              
        } else {
            needCallback = TRUE;
        }
    }

    pNv->VideoTimerCallback = needCallback ? NVVideoTimerCallback : NULL;
d976 1
d995 1
d1009 1
d1052 1
a1052 1
    return NVGetOverlayPortAttribute(pScrnInfo, attribute, value, (pointer)pPriv);
d1065 1
a1065 1
    return NVSetOverlayPortAttribute(pScrnInfo, attribute, value, (pointer)pPriv);
d1157 4
@


