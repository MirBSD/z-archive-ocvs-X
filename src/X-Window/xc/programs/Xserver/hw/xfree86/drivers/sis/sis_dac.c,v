head	1.2;
access;
symbols
	tg-mergetmp-2:1.2
	cvs-200410241530:1.1.1.4
	cvs-200410012000:1.1.1.4
	cvs-200407221130:1.1.1.4
	cvs-200407141120:1.1.1.4
	cvs-200406231010:1.1.1.4
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.4
	XFree86_4_4_0:1.1.9.2
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.03.07.18.37.33;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.20.07.30;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.07.30;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.36.42;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.19.43;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.27.16.33.05;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.23.53;	author tg;	state Exp;
branches;
next	1.1.9.2;

1.1.9.2
date	2004.03.05.22.30.09;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@semi-automagic merge of these files (ie, I've skipped through the diffs,
and most of that was done by cvs or that weird script of some minutes ago)
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_dac.c,v 1.61 2004/02/25 23:22:16 twini Exp $ */
/*
 * DAC helper functions (Save/Restore, MemClk, etc)
 *
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author:  	Thomas Winischhofer <thomas@@winischhofer.net>
 *
 * SiS_compute_vclk(), SiSCalcClock() and parts of SiSMclk():
 * Copyright (C) 1998, 1999 by Alan Hourihane, Wigan, England
 * Written by:
 *	 Alan Hourihane <alanh@@fairlite.demon.co.uk>,
 *       Mike Chapman <mike@@paranoia.com>,
 *       Juanjo Santamarta <santamarta@@ctv.es>,
 *       Mitani Hiroshi <hmitani@@drl.mei.co.jp>,
 *       David Thomas <davtom@@dream.org.uk>,
 *	 Thomas Winischhofer <thomas@@winischhofer.net>.
 * Licensed under the terms of the XFree86 license
 * (http://www.xfree86.org/current/LICENSE1.html)
 *
 */

#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86_ansic.h"
#include "xf86Version.h"
#include "xf86PciInfo.h"
#include "xf86Pci.h"
#include "xf86DDC.h"

#include "sis.h"
#include "sis_dac.h"
#include "sis_regs.h"
#include "sis_vb.h"

static void SiSSave(ScrnInfoPtr pScrn, SISRegPtr sisReg);
static void SiSRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg);

static void SiS300Save(ScrnInfoPtr pScrn, SISRegPtr sisReg);
static void SiS315Save(ScrnInfoPtr pScrn, SISRegPtr sisReg);
static void SiS301Save(ScrnInfoPtr pScrn, SISRegPtr sisReg);
static void SiS301BSave(ScrnInfoPtr pScrn, SISRegPtr sisReg);
static void SiSLVDSChrontelSave(ScrnInfoPtr pScrn, SISRegPtr sisReg);
static void SiS300Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg);
static void SiS315Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg);
static void SiS301Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg);
static void SiS301BRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg);
static void SiSLVDSChrontelRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg);
static void SiS301LoadPalette(ScrnInfoPtr pScrn, int numColors,
                      int *indicies, LOCO *colors, VisualPtr pVisual);
static void SetBlock(CARD16 port, CARD8 from, CARD8 to, CARD8 *DataPtr);

static const unsigned short ch700xidx[] = {
      0x00,0x07,0x08,0x0a,0x0b,0x04,0x09,0x20,0x21,0x18,0x19,0x1a,
      0x1b,0x1c,0x1d,0x1e,0x1f,  /* 0x0e,  - TW: Don't save the power register */
      0x01,0x03,0x06,0x0d,0x11,0x13,0x14,0x15,0x17,0x22,0x23,0x24
   };

static const unsigned short ch701xidx[] = {
      0x1c,0x5f,0x64,0x6f,0x70,0x71,0x72,0x73,0x74,0x76,0x78,0x7d,
      0x67,0x68,0x69,0x6a,0x6b,0x1e,0x00,0x01,0x02,0x04,0x03,0x05,
      0x06,0x07,0x08,0x15,0x1f,0x0c,0x0d,0x0e,0x0f,0x10,0x66
   };

int SiS_compute_vclk(
        int Clock,
        int *out_n,
        int *out_dn,
        int *out_div,
        int *out_sbit,
        int *out_scale)
{
    float f,x,y,t, error, min_error;
    int n, dn, best_n=0, best_dn=0;

    /*
     * Rules
     *
     * VCLK = 14.318 * (Divider/Post Scalar) * (Numerator/DeNumerator)
     * Factor = (Divider/Post Scalar)
     * Divider is 1 or 2
     * Post Scalar is 1, 2, 3, 4, 6 or 8
     * Numberator ranged from 1 to 128
     * DeNumerator ranged from 1 to 32
     * a. VCO = VCLK/Factor, suggest range is 150 to 250 Mhz
     * b. Post Scalar selected from 1, 2, 4 or 8 first.
     * c. DeNumerator selected from 2.
     *
     * According to rule a and b, the VCO ranges that can be scaled by
     * rule b are:
     *      150    - 250    (Factor = 1)
     *       75    - 125    (Factor = 2)
     *       37.5  -  62.5  (Factor = 4)
     *       18.75 -  31.25 (Factor = 8)
     *
     * The following ranges use Post Scalar 3 or 6:
     *      125    - 150    (Factor = 1.5)
     *       62.5  -  75    (Factor = 3)
     *       31.25 -  37.5  (Factor = 6)
     *
     * Steps:
     * 1. divide the Clock by 2 until the Clock is less or equal to 31.25.
     * 2. if the divided Clock is range from 18.25 to 31.25, than
     *    the Factor is 1, 2, 4 or 8.
     * 3. if the divided Clock is range from 15.625 to 18.25, than
     *    the Factor is 1.5, 3 or 6.
     * 4. select the Numberator and DeNumberator with minimum deviation.
     *
     * ** this function can select VCLK ranged from 18.75 to 250 Mhz
     */

    f = (float) Clock;
    f /= 1000.0;
    if((f > 250.0) || (f < 18.75))
       return 0;

    min_error = f;
    y = 1.0;
    x = f;
    while(x > 31.25) {
       y *= 2.0;
       x /= 2.0;
    }
    if(x >= 18.25) {
       x *= 8.0;
       y = 8.0 / y;
    } else if(x >= 15.625) {
       x *= 12.0;
       y = 12.0 / y;
    }

    t = y;
    if(t == (float) 1.5) {
       *out_div = 2;
       t *= 2.0;
    } else {
       *out_div = 1;
    }
    if(t > (float) 4.0) {
       *out_sbit = 1;
       t /= 2.0;
    } else {
       *out_sbit = 0;
    }

    *out_scale = (int) t;

    for(dn = 2; dn <= 32; dn++) {
       for(n = 1; n <= 128; n++) {
          error = x;
          error -= ((float) 14.318 * (float) n / (float) dn);
          if(error < (float) 0)
             error = -error;
          if(error < min_error) {
             min_error = error;
             best_n = n;
             best_dn = dn;
          }
       }
    }
    *out_n = best_n;
    *out_dn = best_dn;
    PDEBUG(ErrorF("SiS_compute_vclk: Clock=%d, n=%d, dn=%d, div=%d, sbit=%d,"
                    " scale=%d\n", Clock, best_n, best_dn, *out_div,
                    *out_sbit, *out_scale));
    return 1;
}


void
SiSCalcClock(ScrnInfoPtr pScrn, int clock, int max_VLD, unsigned int *vclk)
{
    SISPtr pSiS = SISPTR(pScrn);
    int M, N, P , PSN, VLD , PSNx ;
    int bestM=0, bestN=0, bestP=0, bestPSN=0, bestVLD=0;
    double abest = 42.0;
    double target;
    double Fvco, Fout;
    double error, aerror;
#ifdef DEBUG
    double bestFout;
#endif

    /*
     *  fd = fref*(Numerator/Denumerator)*(Divider/PostScaler)
     *
     *  M       = Numerator [1:128]
     *  N       = DeNumerator [1:32]
     *  VLD     = Divider (Vco Loop Divider) : divide by 1, 2
     *  P       = Post Scaler : divide by 1, 2, 3, 4
     *  PSN     = Pre Scaler (Reference Divisor Select) 
     * 
     * result in vclk[]
     */
#define Midx    0
#define Nidx    1
#define VLDidx  2
#define Pidx    3
#define PSNidx  4
#define Fref 14318180
/* stability constraints for internal VCO -- MAX_VCO also determines 
 * the maximum Video pixel clock */
#define MIN_VCO      Fref
#define MAX_VCO      135000000
#define MAX_VCO_5597 353000000
#define MAX_PSN      0          /* no pre scaler for this chip */
#define TOLERANCE    0.01       /* search smallest M and N in this tolerance */
  
  int M_min = 2;
  int M_max = 128;

  target = clock * 1000;

  if(pSiS->Chipset == PCI_CHIP_SIS5597 || pSiS->Chipset == PCI_CHIP_SIS6326) {

     int low_N = 2;
     int high_N = 5;

     PSN = 1;
     P = 1;
     if(target < MAX_VCO_5597 / 2)  P = 2;
     if(target < MAX_VCO_5597 / 3)  P = 3;
     if(target < MAX_VCO_5597 / 4)  P = 4;
     if(target < MAX_VCO_5597 / 6)  P = 6;
     if(target < MAX_VCO_5597 / 8)  P = 8;

     Fvco = P * target;

     for(N = low_N; N <= high_N; N++) {

         double M_desired = Fvco / Fref * N;
         if(M_desired > M_max * max_VLD)  continue;

         if(M_desired > M_max) {
            M = M_desired / 2 + 0.5;
            VLD = 2;
         } else {
            M = Fvco / Fref * N + 0.5;
            VLD = 1;
         }

         Fout = (double)Fref * (M * VLD)/(N * P);

         error = (target - Fout) / target;
         aerror = (error < 0) ? -error : error;
         if(aerror < abest) {
            abest = aerror;
            bestM = M;
            bestN = N;
            bestP = P;
            bestPSN = PSN;
            bestVLD = VLD;
#ifdef DEBUG
            bestFout = Fout;
#endif	    
         }
     }

  } else {

     for(PSNx = 0; PSNx <= MAX_PSN ; PSNx++) {

        int low_N, high_N;
        double FrefVLDPSN;

        PSN = !PSNx ? 1 : 4;

        low_N = 2;
        high_N = 32;

        for(VLD = 1 ; VLD <= max_VLD ; VLD++) {

           FrefVLDPSN = (double)Fref * VLD / PSN;

	   for(N = low_N; N <= high_N; N++) {
              double tmp = FrefVLDPSN / N;

              for(P = 1; P <= 4; P++) {
                 double Fvco_desired = target * ( P );
                 double M_desired = Fvco_desired / tmp;

                 /* Which way will M_desired be rounded?
                  *  Do all three just to be safe.
                  */
                 int M_low = M_desired - 1;
                 int M_hi = M_desired + 1;

                 if(M_hi < M_min || M_low > M_max) continue;

		 if(M_low < M_min)  M_low = M_min;

		 if(M_hi > M_max)   M_hi = M_max;

                 for(M = M_low; M <= M_hi; M++) {
                    Fvco = tmp * M;
                    if(Fvco <= MIN_VCO) continue;
                    if(Fvco > MAX_VCO)  break;

                    Fout = Fvco / ( P );

                    error = (target - Fout) / target;
                    aerror = (error < 0) ? -error : error;
                    if(aerror < abest) {
                       abest = aerror;
                       bestM = M;
                       bestN = N;
                       bestP = P;
                       bestPSN = PSN;
                       bestVLD = VLD;
#ifdef DEBUG
                       bestFout = Fout;
#endif
                    }
#ifdef TWDEBUG
                    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,3,
			       "Freq. selected: %.2f MHz, M=%d, N=%d, VLD=%d, P=%d, PSN=%d\n",
                               (float)(clock / 1000.), M, N, P, VLD, PSN);
                    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,3,
			       "Freq. set: %.2f MHz\n", Fout / 1.0e6);
#endif
                 }
              }
           }
        }
     }
  }

  vclk[Midx]   = bestM;
  vclk[Nidx]   = bestN;
  vclk[VLDidx] = bestVLD;
  vclk[Pidx]   = bestP;
  vclk[PSNidx] = bestPSN;

  PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
                "Freq. selected: %.2f MHz, M=%d, N=%d, VLD=%d, P=%d, PSN=%d\n",
                (float)(clock / 1000.), vclk[Midx], vclk[Nidx], vclk[VLDidx],
                vclk[Pidx], vclk[PSNidx]));
  PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
                "Freq. set: %.2f MHz\n", bestFout / 1.0e6));
  PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
                "VCO Freq.: %.2f MHz\n", bestFout*bestP / 1.0e6));
}


static void
SiSSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr pSiS = SISPTR(pScrn);
    int i,max;

    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
             "SiSSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n"));

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    switch(pSiS->Chipset) {
        case PCI_CHIP_SIS5597:
           max=0x3C;
           break;
        case PCI_CHIP_SIS6326:
        case PCI_CHIP_SIS530:
           max=0x3F; 
           break;
        default:
           max=0x37;
           break;
        }

    /* Save extended SR registers */
    for(i = 0x00; i <= max; i++) {
       inSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "SR%02X - %02X \n", i,sisReg->sisRegs3C4[i]);
#endif
    }

#ifdef TWDEBUG
    for(i = 0x00; i <= 0x3f; i++) {
       inSISIDXREG(SISCR, i, max);
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "CR%02X - %02X \n", i,max);
    }
#endif

    /* Save lock (will not be restored in SiSRestore()!) */
    inSISIDXREG(SISCR, 0x80, sisReg->sisRegs3D4[0x80]);

    sisReg->sisRegs3C2 = inSISREG(SISMISCR);	 /* Misc */

    /* TW: Save TV registers */
    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
       outSISIDXREG(SISCR, 0x80, 0x86);
       for(i = 0x00; i <= 0x44; i++) {
          sisReg->sis6326tv[i] = SiS6326GetTVReg(pScrn, i);
#ifdef TWDEBUG
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "VR%02X - %02X \n", i,sisReg->sis6326tv[i]);
#endif
       }
    }
}

static void
SiSRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr pSiS = SISPTR(pScrn);
    int i,max;
    unsigned char tmp;

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
                "SiSRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n");

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    switch(pSiS->Chipset) {
        case PCI_CHIP_SIS5597:
           max = 0x3C;
           break;
        case PCI_CHIP_SIS6326:
	case PCI_CHIP_SIS530:
           max = 0x3F;
           break;
        default:
           max = 0x37;
           break;
    }

    /* Disable TV on 6326 before restoring */
    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
       outSISIDXREG(SISCR, 0x80, 0x86);
       tmp = SiS6326GetTVReg(pScrn, 0x00);
       tmp &= ~0x04;
       SiS6326SetTVReg(pScrn, 0x00, tmp);
    }

    /* Restore other extended SR registers */
    for(i = 0x06; i <= max; i++) {
       if((i == 0x13) || (i == 0x2a) || (i == 0x2b)) continue;
       outSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
    }

    /* Now restore VCLK (with correct SR38 setting) */
    outSISIDXREG(SISSR, 0x13, sisReg->sisRegs3C4[0x13]);
    outSISIDXREG(SISSR, 0x2a, sisReg->sisRegs3C4[0x2a]);
    outSISIDXREG(SISSR, 0x2b, sisReg->sisRegs3C4[0x2b]);

    /* Misc */
    outSISREG(SISMISCW, sisReg->sisRegs3C2);

    /* MemClock needs this to take effect */
    outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
    usleep(10000);
    outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */

    /* TW: Restore TV registers */
    pSiS->SiS6326Flags &= ~SIS6326_TVON;
    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
       for(i = 0x01; i <= 0x44; i++) {
          SiS6326SetTVReg(pScrn, i, sisReg->sis6326tv[i]);
#ifdef TWDEBUG
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	 	"VR%02x restored to %02x\n",
		i, sisReg->sis6326tv[i]);
#endif
       }
       tmp = SiS6326GetXXReg(pScrn, 0x13);
       SiS6326SetXXReg(pScrn, 0x13, 0xfa);
       tmp = SiS6326GetXXReg(pScrn, 0x14);
       SiS6326SetXXReg(pScrn, 0x14, 0xc8);
       if(!(sisReg->sisRegs3C4[0x0D] & 0x04)) {
    	  tmp = SiS6326GetXXReg(pScrn, 0x13);
	  SiS6326SetXXReg(pScrn, 0x13, 0xf6);
	  tmp = SiS6326GetXXReg(pScrn, 0x14);
	  SiS6326SetXXReg(pScrn, 0x14, 0xbf);
       }
       if(sisReg->sis6326tv[0] & 0x04) pSiS->SiS6326Flags |= SIS6326_TVON;
    }
}

/* Save SiS 300 series register contents */
static void
SiS300Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr pSiS = SISPTR(pScrn);
    int i;

    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
     		"SiS300Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n"));

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    /* Save SR registers */
    for(i = 0x00; i <= 0x3D; i++) {
       inSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "SR%02X - %02X \n", i,sisReg->sisRegs3C4[i]);
#endif
    }

    /* Save CR registers */
    for(i = 0x00; i < 0x40; i++)  {
       inSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"CR%02X Contents - %02X \n", i,sisReg->sisRegs3D4[i]);
#endif
    }
    
    /* Save Misc register */
    sisReg->sisRegs3C2 = inSISREG(SISMISCR);	 
    
    /* Save FQBQ and GUI timer settings */
    if(pSiS->Chipset == PCI_CHIP_SIS630) {
       sisReg->sisRegsPCI50 = pciReadLong(0x00000000, 0x50);
       sisReg->sisRegsPCIA0 = pciReadLong(0x00000000, 0xA0);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       		"PCI Config 50 = %lx\n", sisReg->sisRegsPCI50);
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       		"PCI Config A0 = %lx\n", sisReg->sisRegsPCIA0);		
#endif       
    }

    /* Save panel link/video bridge registers */
#ifndef TWDEBUG
    if(!pSiS->UseVESA) {
#endif
       if(pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
          (*pSiS->SiSSaveLVDSChrontel)(pScrn, sisReg);
       if(pSiS->VBFlags & VB_301)
          (*pSiS->SiSSave2)(pScrn, sisReg);
       if(pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV))
          (*pSiS->SiSSave3)(pScrn, sisReg);
#ifndef TWDEBUG
    }
#endif

    /* Save Mode number */
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
    if(!(pSiS->UseVESA))
#endif
       pSiS->BIOSModeSave = SiS_GetSetModeID(pScrn,0xFF);
	
#ifdef TWDEBUG	
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
    	"BIOS mode ds:449 = 0x%x\n", pSiS->BIOSModeSave);
#endif	
}


/* Restore SiS300 series register contents */
static void
SiS300Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr pSiS = SISPTR(pScrn);
    int i,temp;
    CARD32 temp1;

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
                "SiS300Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n");

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    /* Wait for accelerator to finish on-going drawing operations. */
    inSISIDXREG(SISSR, 0x1E, temp);
    if(temp & (0x40|0x10|0x02))  {
       while ( (MMIO_IN16(pSiS->IOBase, 0x8242) & 0xE000) != 0xE000){};
       while ( (MMIO_IN16(pSiS->IOBase, 0x8242) & 0xE000) != 0xE000){};
       while ( (MMIO_IN16(pSiS->IOBase, 0x8242) & 0xE000) != 0xE000){};
    }

    if(!(pSiS->UseVESA)) {
       if(pSiS->VBFlags & VB_LVDS) {
          SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
          SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
       }
    }

    /* Restore extended CR registers */
    for(i = 0x19; i < 0x40; i++)  {
       outSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
    }

    if(pSiS->Chipset != PCI_CHIP_SIS300)  {
       unsigned char val;
       inSISIDXREG(SISCR, 0x1A, val);
       if(val == sisReg->sisRegs3D4[0x19])
	  outSISIDXREG(SISCR, 0x1A, sisReg->sisRegs3D4[0x19]);
       inSISIDXREG(SISCR,0x19,val);
       if(val == sisReg->sisRegs3D4[0x1A])
          outSISIDXREG(SISCR, 0x19, sisReg->sisRegs3D4[0x1A]);
    }

    /* Set (and leave) PCI_IO_ENABLE on if accelerators are on */
    if(sisReg->sisRegs3C4[0x1e] & 0x50) {
       sisReg->sisRegs3C4[0x20] |= 0x20;
       outSISIDXREG(SISSR, 0x20, sisReg->sisRegs3C4[0x20]);
    }

    /* If TQ is switched on, don't switch it off ever again!
     * Therefore, always restore registers with TQ enabled.
     */
    if((!pSiS->NoAccel) && (pSiS->TurboQueue)) {
       temp = (pScrn->videoRam/64) - 8;
       sisReg->sisRegs3C4[0x26] = temp & 0xFF;
       sisReg->sisRegs3C4[0x27] = ((temp >> 8) & 3) | 0xF0;
    }

    /* Restore extended SR registers */
    for(i = 0x06; i <= 0x3D; i++) {
       temp = sisReg->sisRegs3C4[i];
       if(!(pSiS->UseVESA)) {
          if(pSiS->VBFlags & VB_LVDS) {
             if(i == 0x11) {
	        inSISIDXREG(SISSR,0x11,temp);
	    	temp &= 0x0c;
		temp |= (sisReg->sisRegs3C4[i] & 0xf3);
	     }
          }
       }
       outSISIDXREG(SISSR, i, temp);
    }

    /* Restore VCLK and ECLK */
    if(pSiS->VBFlags & (VB_LVDS | VB_301B | VB_301C)) {
       outSISIDXREG(SISSR,0x31,0x20);
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x80);
       outSISIDXREG(SISSR,0x31,0x10);
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x80);
    }
    outSISIDXREG(SISSR,0x31,0x00);
    outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
    outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
    outSISIDXREG(SISSR,0x2d,0x80);
    if(pSiS->VBFlags & (VB_LVDS | VB_301B | VB_301C)) {
       outSISIDXREG(SISSR,0x31,0x20);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
       outSISIDXREG(SISSR,0x31,0x10);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
       outSISIDXREG(SISSR,0x31,0x00);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
    }

    /* Restore Misc register */
    outSISREG(SISMISCW, sisReg->sisRegs3C2);

    /* Restore FQBQ and GUI timer settings */
    if(pSiS->Chipset == PCI_CHIP_SIS630) {
       temp1 = pciReadLong(0x00000000, 0x50);
       if(pciReadLong(0x00000000, 0x00) == 0x06301039) {
          temp1 &= 0xf0ffffff;
          temp1 |= (sisReg->sisRegsPCI50 & ~0xf0ffffff);
       } else {  /* 730 */
          temp1 &= 0xfffff9ff;
          temp1 |= (sisReg->sisRegsPCI50 & ~0xfffff9ff);
       }
       pciWriteLong(0x00000000, 0x50, temp1);

       temp1 = pciReadLong(0x00000000, 0xA0);
       if(pciReadLong(0x00000000, 0x00) == 0x06301039) {
          temp1 &= 0xf0ffffff;
          temp1 |= (sisReg->sisRegsPCIA0 & ~0xf0ffffff);
       } else {	/* 730 */
          temp1 &= 0x00ffffff;
          temp1 |= (sisReg->sisRegsPCIA0 & ~0x00ffffff);
       }
       pciWriteLong(0x00000000, 0xA0, temp1);
    }

    /* Restore panel link/video bridge registers */
    if(!(pSiS->UseVESA)) {
       if(pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
          (*pSiS->SiSRestoreLVDSChrontel)(pScrn, sisReg);
       if(pSiS->VBFlags & VB_301)
          (*pSiS->SiSRestore2)(pScrn, sisReg);
       if(pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV))
          (*pSiS->SiSRestore3)(pScrn, sisReg);
    }

    /* MemClock needs this to take effect */
    outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
    outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */

    /* Restore mode number */
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
    if(!(pSiS->UseVESA))
#endif
       SiS_GetSetModeID(pScrn,pSiS->BIOSModeSave);
}

/* Save SiS315 series register contents */
static void
SiS315Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr pSiS = SISPTR(pScrn);
    int i;

    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
    		"SiS315Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n"));

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    /* Save SR registers */
    for(i = 0x00; i <= 0x3F; i++) {
       inSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			 "SR%02X - %02X \n", i,sisReg->sisRegs3C4[i]);
#endif
    }

    /* Save command queue location */
    sisReg->sisMMIO85C0 = MMIO_IN32(pSiS->IOBase, 0x85C0);

    /* Save CR registers */
    for(i = 0x00; i <= 0x7c; i++)  {
       inSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"CR%02X Contents - %02X \n", i,sisReg->sisRegs3D4[i]);
#endif
    }

    /* Save video capture registers */
    for(i = 0x00; i <= 0x4f; i++)  {
       inSISIDXREG(SISCAP, i, sisReg->sisCapt[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"Capt%02X Contents - %02X \n", i,sisReg->sisCapt[i]);
#endif
    }

    /* Save video playback registers */
    for(i = 0x00; i <= 0x3f; i++)  {
       inSISIDXREG(SISVID, i, sisReg->sisVid[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"Vid%02X Contents - %02X \n", i,sisReg->sisVid[i]);
#endif
    }

    /* Save Misc register */
    sisReg->sisRegs3C2 = inSISREG(SISMISCR);

    /* Save panel link/video bridge registers */
#ifndef TWDEBUG
    if(!pSiS->UseVESA) {
#endif
       if(pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
          (*pSiS->SiSSaveLVDSChrontel)(pScrn, sisReg);
       if(pSiS->VBFlags & VB_301)
          (*pSiS->SiSSave2)(pScrn, sisReg);
       if(pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV))
          (*pSiS->SiSSave3)(pScrn, sisReg);
#ifndef TWDEBUG
    }
#endif

    /* Save mode number */
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
    if(!(pSiS->UseVESA))
#endif
       pSiS->BIOSModeSave = SiS_GetSetModeID(pScrn,0xFF);

#ifdef TWDEBUG
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
    	"BIOS mode ds:449 = 0x%x\n", pSiS->BIOSModeSave);
#endif
}

/* Restore SiS315/330 series register contents */
static void
SiS315Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr pSiS = SISPTR(pScrn);
    int i,temp;

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
                "SiS315Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n");

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    /* Wait for accelerator to finish on-going drawing operations. */
    inSISIDXREG(SISSR, 0x1E, temp);
    if(temp & (0x40|0x10|0x02))  {	/* 0x40 = 2D, 0x10 = 3D enabled*/
       while ( (MMIO_IN32(pSiS->IOBase, 0x85CC) & 0x80000000) != 0x80000000){};
       while ( (MMIO_IN32(pSiS->IOBase, 0x85CC) & 0x80000000) != 0x80000000){};
       while ( (MMIO_IN32(pSiS->IOBase, 0x85CC) & 0x80000000) != 0x80000000){};
    }

    /* We reset the command queue before restoring.
     * This might be required because we never know what
     * console driver (like the kernel framebuffer driver)
     * or application is running and which queue mode it
     * uses.
     */
    outSISIDXREG(SISSR, 0x27, 0x1F);
    outSISIDXREG(SISSR, 0x26, 0x01);

    /* Restore extended CR registers */
    for(i = 0x19; i < 0x5C; i++)  {
       outSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
    }
    if(pSiS->sishw_ext.jChipType < SIS_661) {
       outSISIDXREG(SISCR, 0x79, sisReg->sisRegs3D4[0x79]);
    }
    outSISIDXREG(SISCR, pSiS->myCR63, sisReg->sisRegs3D4[pSiS->myCR63]);

    /* Leave PCI_IO_ENABLE on if accelerators are on (Is this required?) */
    if(sisReg->sisRegs3C4[0x1e] & 0x50) {  /*0x40=2D, 0x10=3D*/
       sisReg->sisRegs3C4[0x20] |= 0x20;
       outSISIDXREG(SISSR, 0x20, sisReg->sisRegs3C4[0x20]);
    }

    /* Restore extended SR registers */
    if(pSiS->sishw_ext.jChipType >= SIS_661) {
       sisReg->sisRegs3C4[0x11] &= 0x0f;
    }
    for(i = 0x06; i <= 0x3F; i++) {
       outSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
    }
    /* Restore VCLK and ECLK */
    andSISIDXREG(SISSR,0x31,0xcf);
    if(pSiS->VBFlags & VB_LVDS) {
       orSISIDXREG(SISSR,0x31,0x20);
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x80);
       andSISIDXREG(SISSR,0x31,0xcf);
       orSISIDXREG(SISSR,0x31,0x10);
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x80);
       andSISIDXREG(SISSR,0x31,0xcf);
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x01);
       outSISIDXREG(SISSR,0x31,0x20);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
       outSISIDXREG(SISSR,0x31,0x10);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
       outSISIDXREG(SISSR,0x31,0x00);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
    } else {
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x01);
    }

#ifndef SISVRAMQ
    /* Initialize read/write pointer for command queue */
    MMIO_OUT32(pSiS->IOBase, 0x85C4, MMIO_IN32(pSiS->IOBase, 0x85C8));
#endif
    /* Restore queue location */
    MMIO_OUT32(pSiS->IOBase, 0x85C0, sisReg->sisMMIO85C0);

    /* Restore Misc register */
    outSISREG(SISMISCW, sisReg->sisRegs3C2);   

    /* Restore panel link/video bridge registers */
    if(!(pSiS->UseVESA)) {
       if(pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
          (*pSiS->SiSRestoreLVDSChrontel)(pScrn, sisReg);
       if(pSiS->VBFlags & VB_301)
          (*pSiS->SiSRestore2)(pScrn, sisReg);
       if(pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV))
          (*pSiS->SiSRestore3)(pScrn, sisReg);
    }

    /* MemClock needs this to take effect */
    outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
    outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */

    /* Restore Mode number */
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
    if(!(pSiS->UseVESA))
#endif
       SiS_GetSetModeID(pScrn,pSiS->BIOSModeSave);
}

static void
SiSVBSave(ScrnInfoPtr pScrn, SISRegPtr sisReg, int p1, int p2, int p3, int p4)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int     i;

    for(i=0; i<=p1; i++)  {
       inSISIDXREG(SISPART1, i, sisReg->VBPart1[i]);
#ifdef TWDEBUG
       xf86DrvMsg(0, X_INFO, "301xSave: Part1Port 0x%02x = 0x%02x\n", i, sisReg->VBPart1[i]);
#endif
    }
    for(i=0; i<=p2; i++)  {
       inSISIDXREG(SISPART2, i, sisReg->VBPart2[i]);
#ifdef TWDEBUG
       xf86DrvMsg(0, X_INFO, "301xSave: Part2Port 0x%02x = 0x%02x\n", i, sisReg->VBPart2[i]);
#endif
    }
    for(i=0; i<=p3; i++)  {
       inSISIDXREG(SISPART3, i, sisReg->VBPart3[i]);
#ifdef TWDEBUG
       xf86DrvMsg(0, X_INFO, "301xSave: Part3Port 0x%02x = 0x%02x\n", i, sisReg->VBPart3[i]);
#endif
    }
    for(i=0; i<=p4; i++)  {
       inSISIDXREG(SISPART4, i, sisReg->VBPart4[i]);
#ifdef TWDEBUG
       xf86DrvMsg(0, X_INFO, "301xSave: Part4Port 0x%02x = 0x%02x\n", i, sisReg->VBPart4[i]);
#endif
    }
}

/* Save SiS301 bridge register contents */
static void
SiS301Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int     Part1max, Part2max, Part3max, Part4max;

    /* Highest register number to save/restore */
    if(pSiS->VGAEngine == SIS_300_VGA) Part1max = 0x1d;
    else Part1max = 0x2e;  /* 0x23, but we also need 2d-2e */

    Part2max = 0x45;
    Part3max = 0x3e;
    Part4max = 0x1b;

    SiSVBSave(pScrn, sisReg, Part1max, Part2max, Part3max, Part4max);

    sisReg->VBPart2[0x00] &= ~0x20;      /* Disable VB Processor */
    sisReg->sisRegs3C4[0x32] &= ~0x20;   /* Disable Lock Mode */
}

/* Restore SiS301 bridge register contents */
static void
SiS301Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int     Part1max, Part2max, Part3max, Part4max;

    /* Highest register number to save/restore */
    if(pSiS->VGAEngine == SIS_300_VGA) Part1max = 0x1d;
    else Part1max = 0x23;

    Part2max = 0x45;
    Part3max = 0x3e;
    Part4max = 0x1b;

    SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);

    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);

    /* Pre-restore Part1 */
    outSISIDXREG(SISPART1, 0x04, 0x00);
    outSISIDXREG(SISPART1, 0x05, 0x00);
    outSISIDXREG(SISPART1, 0x06, 0x00);
    outSISIDXREG(SISPART1, 0x00, sisReg->VBPart1[0]);
    outSISIDXREG(SISPART1, 0x01, sisReg->VBPart1[1]);

    /* Pre-restore Part4 */
    outSISIDXREG(SISPART4, 0x0D, sisReg->VBPart4[0x0D]);
    outSISIDXREG(SISPART4, 0x0C, sisReg->VBPart4[0x0C]);

    if((!(sisReg->sisRegs3D4[0x30] & 0x03)) &&
       (sisReg->sisRegs3D4[0x31] & 0x20))  {      /* disable CRT2 */
       SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
       return;
    }

    /* Restore Part1 */
    SetBlock(SISPART1, 0x02, Part1max, &(sisReg->VBPart1[0x02]));
    if(pSiS->VGAEngine == SIS_315_VGA) {
       /* Restore extra registers on 315 series */
       SetBlock(SISPART1, 0x2C, 0x2E, &(sisReg->VBPart1[0x2C]));
    }

    /* Restore Part2 */
    SetBlock(SISPART2, 0x00, Part2max, &(sisReg->VBPart2[0x00]));

    /* Restore Part3 */
    SetBlock(SISPART3, 0x00, Part3max, &(sisReg->VBPart3[0x00]));

    /* Restore Part4 */
    SetBlock(SISPART4, 0x0E, 0x11, &(sisReg->VBPart4[0x0E]));
    SetBlock(SISPART4, 0x13, Part4max, &(sisReg->VBPart4[0x13]));

    /* Post-restore Part4 (CRT2VCLK) */
    outSISIDXREG(SISPART4, 0x0A, 0x01);
    outSISIDXREG(SISPART4, 0x0B, sisReg->VBPart4[0x0B]);
    outSISIDXREG(SISPART4, 0x0A, sisReg->VBPart4[0x0A]);
    outSISIDXREG(SISPART4, 0x12, 0x00);
    outSISIDXREG(SISPART4, 0x12, sisReg->VBPart4[0x12]);

    SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
    SiS_DisplayOn(pSiS->SiS_Pr);
    SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
}

/* Save SiS30xB/30xLV bridge register contents */
static void
SiS301BSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int     Part1max, Part2max, Part3max, Part4max;

    Part1max = 0x4c;
    Part2max = 0x4d;
    Part3max = 0x3e;
    Part4max = 0x23;
    if(pSiS->VBFlags & (VB_301C|VB_302ELV)) {
       Part2max = 0xff;
       Part4max = 0x3c;
    }
    if(pSiS->VBFlags & (VB_301LV|VB_302LV)) {
       Part4max = 0x34;
    }

    SiSVBSave(pScrn, sisReg, Part1max, Part2max, Part3max, Part4max);

    sisReg->VBPart2[0x00] &= ~0x20;      /* Disable VB Processor */
    sisReg->sisRegs3C4[0x32] &= ~0x20;   /* Disable Lock Mode */
}

/* Restore SiS30xB/30xLV bridge register contents */
static void
SiS301BRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int     Part1max, Part2max, Part3max, Part4max;

    Part1max = 0x23;
    Part2max = 0x4d;
    Part3max = 0x3e;
    Part4max = 0x22;
    if(pSiS->VBFlags & (VB_301C|VB_302ELV)) {
       Part2max = 0xff;
       Part4max = 0x3c;
    }
    if(pSiS->VBFlags & (VB_301LV|VB_302LV)) {
       Part4max = 0x34;
    }

    SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);

    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);

    /* Pre-restore Part1 */
    outSISIDXREG(SISPART1, 0x04, 0x00);
    outSISIDXREG(SISPART1, 0x05, 0x00);
    outSISIDXREG(SISPART1, 0x06, 0x00);
    outSISIDXREG(SISPART1, 0x00, sisReg->VBPart1[0x00]);
    outSISIDXREG(SISPART1, 0x01, sisReg->VBPart1[0x01]);
    /* Mode reg 0x01 became 0x2e on 315 series (0x01 still contains FIFO) */
    if(pSiS->VGAEngine == SIS_315_VGA) {
       outSISIDXREG(SISPART1, 0x2e, sisReg->VBPart1[0x2e]);
    }

    /* Pre-restore Part4 */
    outSISIDXREG(SISPART4, 0x0D, sisReg->VBPart4[0x0D]);
    outSISIDXREG(SISPART4, 0x0C, sisReg->VBPart4[0x0C]);

    if((!(sisReg->sisRegs3D4[0x30] & 0x03)) &&
       (sisReg->sisRegs3D4[0x31] & 0x20))  {      /* disable CRT2 */
       SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
       return;
    }

    /* Restore Part1  */
    SetBlock(SISPART1, 0x02, Part1max, &(sisReg->VBPart1[0x02]));
    if(pSiS->VGAEngine == SIS_315_VGA) {
       SetBlock(SISPART1, 0x2C, 0x2D, &(sisReg->VBPart1[0x2C]));
       SetBlock(SISPART1, 0x35, 0x37, &(sisReg->VBPart1[0x35]));
    }

    /* Restore Part2 */
    SetBlock(SISPART2, 0x00, Part2max, &(sisReg->VBPart2[0x00]));

    /* Restore Part3 */
    SetBlock(SISPART3, 0x00, Part3max, &(sisReg->VBPart3[0x00]));

    /* Restore Part4 */
    SetBlock(SISPART4, 0x0E, 0x11, &(sisReg->VBPart4[0x0E]));
    SetBlock(SISPART4, 0x13, Part4max, &(sisReg->VBPart4[0x13]));

    /* Post-restore Part4 (CRT2VCLK) */
    outSISIDXREG(SISPART4, 0x0A, sisReg->VBPart4[0x0A]);
    outSISIDXREG(SISPART4, 0x0B, sisReg->VBPart4[0x0B]);
    outSISIDXREG(SISPART4, 0x12, 0x00);
    outSISIDXREG(SISPART4, 0x12, sisReg->VBPart4[0x12]);

    SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
    SiS_DisplayOn(pSiS->SiS_Pr);
    SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
}

/* Save LVDS bridge (+ Chrontel) register contents */
static void
SiSLVDSChrontelSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int     i;

    /* Save Part1 */
    for(i=0; i<0x46; i++)  {
       inSISIDXREG(SISPART1, i, sisReg->VBPart1[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	                "LVDSSave: Part1Port 0x%02x = 0x%02x\n",
			i, sisReg->VBPart1[i]);
#endif
    }

    /* Save Chrontel registers */
    if(pSiS->VBFlags & VB_CHRONTEL) {
       if(pSiS->ChrontelType == CHRONTEL_700x) {
          for(i=0; i<0x1D; i++)  {
             sisReg->ch70xx[i] = SiS_GetCH700x(pSiS->SiS_Pr, ch700xidx[i]);
#ifdef TWDEBUG
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	                "LVDSSave: Chrontel 0x%02x = 0x%02x\n",
			ch700xidx[i], sisReg->ch70xx[i]);
#endif
	  }
       } else {
          for(i=0; i<35; i++)  {
             sisReg->ch70xx[i] = SiS_GetCH701x(pSiS->SiS_Pr, ch701xidx[i]);
#ifdef TWDEBUG
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	                "LVDSSave: Chrontel 0x%02x = 0x%02x\n",
			ch701xidx[i], sisReg->ch70xx[i]);
#endif
          }
       }
    }

    sisReg->sisRegs3C4[0x32] &= ~0x20;      /* Disable Lock Mode */
}

/* Restore LVDS bridge (+ Chrontel) register contents */
static void
SiSLVDSChrontelRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int i;
    USHORT wtemp;

    SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
    if(pSiS->sishw_ext.jChipType == SIS_730) {
       outSISIDXREG(SISPART1, 0x00, 0x80);
    }

    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);

    if(pSiS->VBFlags & VB_CHRONTEL) {
       /* Restore Chrontel registers */
       if(pSiS->ChrontelType == CHRONTEL_700x) {
          for(i=0; i<0x11; i++) {
             wtemp = ((sisReg->ch70xx[i]) << 8) | (ch700xidx[i] & 0x00FF);
             SiS_SetCH700x(pSiS->SiS_Pr, wtemp);
          }
       } else {
          for(i=0; i<34; i++) {
             wtemp = ((sisReg->ch70xx[i]) << 8) | (ch701xidx[i] & 0x00FF);
             SiS_SetCH701x(pSiS->SiS_Pr, wtemp);
          }
       }
    }

    /* pre-restore Part1 */
    outSISIDXREG(SISPART1, 0x04, 0x00);
    outSISIDXREG(SISPART1, 0x05, 0x00);
    outSISIDXREG(SISPART1, 0x06, 0x00);
    outSISIDXREG(SISPART1, 0x00, sisReg->VBPart1[0]);
    if(pSiS->VGAEngine == SIS_300_VGA) {
       outSISIDXREG(SISPART1, 0x01, (sisReg->VBPart1[1] | 0x80));
    } else {
       outSISIDXREG(SISPART1, 0x01, sisReg->VBPart1[1]);
    }

    if((!(sisReg->sisRegs3D4[0x30] & 0x03)) &&
       (sisReg->sisRegs3D4[0x31] & 0x20))  {      /* disable CRT2 */
       SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
       return;
    }

    /* Restore Part1 */
    if(pSiS->VGAEngine == SIS_300_VGA) {
       outSISIDXREG(SISPART1, 0x02, (sisReg->VBPart1[2] | 0x40));
    } else {
       outSISIDXREG(SISPART1, 0x02, sisReg->VBPart1[2]);
    }
    SetBlock(SISPART1, 0x03, 0x23, &(sisReg->VBPart1[0x03]));
    if(pSiS->VGAEngine == SIS_315_VGA) {
       SetBlock(SISPART1, 0x2C, 0x2E, &(sisReg->VBPart1[0x2C]));
       SetBlock(SISPART1, 0x35, 0x37, &(sisReg->VBPart1[0x35]));  /* Panel Link Scaler */
    }

    /* For 550 DSTN registers */
    if(pSiS->DSTN || pSiS->FSTN) {
       SetBlock(SISPART1, 0x25, 0x2E, &(sisReg->VBPart1[0x25]));
       SetBlock(SISPART1, 0x30, 0x45, &(sisReg->VBPart1[0x30]));
    }

    SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
    SiS_DisplayOn(pSiS->SiS_Pr);
    SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
}

/* Restore output selection registers */
void
SiSRestoreBridge(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
   SISPtr pSiS = SISPTR(pScrn);
   int i;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   for(i = 0x30; i <= 0x3b; i++) {
      if(i == 0x34) continue;
      outSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
   }

   if(pSiS->VGAEngine == SIS_315_VGA) {
      outSISIDXREG(SISCR, pSiS->myCR63, sisReg->sisRegs3D4[pSiS->myCR63]);
      if(pSiS->sishw_ext.jChipType < SIS_661) {
         outSISIDXREG(SISCR, 0x79, sisReg->sisRegs3D4[0x79]);
      }
   }
}

/* Auxiliary function to find real memory clock (in Khz) */
/* Not for 530/620 if UMA (on these, the mclk is stored in SR10) */
int
SiSMclk(SISPtr pSiS)
{
    int mclk;
    unsigned char Num, Denum, Base;

    switch (pSiS->Chipset)  {

    case PCI_CHIP_SIS300:
    case PCI_CHIP_SIS540:
    case PCI_CHIP_SIS630:
    case PCI_CHIP_SIS550:
    case PCI_CHIP_SIS650:
    case PCI_CHIP_SIS315:
    case PCI_CHIP_SIS315H:
    case PCI_CHIP_SIS315PRO:
    case PCI_CHIP_SIS330:
    case PCI_CHIP_SIS660:
        /* Numerator */
	inSISIDXREG(SISSR, 0x28, Num);
        mclk = 14318 * ((Num & 0x7f) + 1);

        /* Denumerator */
	inSISIDXREG(SISSR, 0x29, Denum);
        mclk = mclk / ((Denum & 0x1f) + 1);

        /* Divider */
        if((Num & 0x80) != 0)  mclk *= 2;

        /* Post-Scaler */
        if((Denum & 0x80) == 0) {
           mclk = mclk / (((Denum & 0x60) >> 5) + 1);
        } else {
           mclk = mclk / ((((Denum & 0x60) >> 5) + 1) * 2);
        }
        break;

    case PCI_CHIP_SIS5597:
    case PCI_CHIP_SIS6326:
    case PCI_CHIP_SIS530:
    default:
        /* Numerator */
        inSISIDXREG(SISSR, 0x28, Num);
        mclk = 14318 * ((Num & 0x7f) + 1);

        /* Denumerator */
	inSISIDXREG(SISSR, 0x29, Denum);
        mclk = mclk / ((Denum & 0x1f) + 1);

        /* Divider. Doesn't work on older cards */
	if(pSiS->oldChipset >= OC_SIS5597) {
           if(Num & 0x80) mclk *= 2;
	}

        /* Post-scaler. Values' meaning depends on SR13 bit 7  */
	inSISIDXREG(SISSR, 0x13, Base);
        if((Base & 0x80) == 0) {
           mclk = mclk / (((Denum & 0x60) >> 5) + 1);
        } else {
           /* Values 00 and 01 are reserved */
           if ((Denum & 0x60) == 0x40)  mclk /= 6;
           if ((Denum & 0x60) == 0x60)  mclk /= 8;
        }
        break;
    }

    return(mclk);
}

/* This estimates the CRT2 clock we are going to use.
 * The total bandwidth is to be reduced by the value
 * returned here in order to get an idea of the maximum
 * dotclock left for CRT1.
 * Since we don't know yet, what mode the user chose,
 * we return the maximum dotclock used by
 * - either the LCD attached, or
 * - TV
 * For VGA2, we share the bandwith equally.
 */
static int
SiSEstimateCRT2Clock(ScrnInfoPtr pScrn, BOOLEAN IsForMergedFBCRT2)
{
        SISPtr pSiS = SISPTR(pScrn);

	if(pSiS->VBFlags & CRT2_LCD) {
  	   if(pSiS->VBLCDFlags & (VB_LCD_320x480 | VB_LCD_800x600 | VB_LCD_640x480)) {
	      return 40000;
	   } else if(pSiS->VBLCDFlags & (VB_LCD_1024x768 | VB_LCD_1024x600 | VB_LCD_1152x768)) {
	      return 65000;
	   } else if(pSiS->VBLCDFlags & VB_LCD_1280x720) {
	      return 75000;
	   } else if(pSiS->VBLCDFlags & VB_LCD_1280x768) {
	      return 81000;
	   } else if(pSiS->VBLCDFlags & VB_LCD_1280x800) {
	      /* Must fake clock; built-in mode shows 83 for VGA, but uses only 70 for LCD */
	      if(IsForMergedFBCRT2) return 83000;
	      else                  return 70000;
	   } else if(pSiS->VBLCDFlags & VB_LCD_1400x1050) {
	      /* Must fake clock; built-in mode shows 122 for VGA, but uses only 108 for LCD */
	      if(IsForMergedFBCRT2) return 123000;
	      else                  return 108000;
	   } else if(pSiS->VBLCDFlags & (VB_LCD_1280x1024 | VB_LCD_1280x960)) {
	      return 108000;
	   } else if(pSiS->VBLCDFlags & VB_LCD_1680x1050) {
	      /* Must fake clock; built-in mode shows 147 for VGA, but uses only 122 for LCD */
	      if(IsForMergedFBCRT2) return 148000;
	      else                  return 122000;
	   } else if(pSiS->VBLCDFlags & VB_LCD_1600x1200) {
	      return 162000;
	   } else if((pSiS->VBLCDFlags & VB_LCD_CUSTOM) && (pSiS->SiS_Pr->CP_HaveCustomData)) {
	      return pSiS->SiS_Pr->CP_MaxClock;
	   } else
	      return 108000;
	} else if(pSiS->VBFlags & CRT2_TV) {
	   if(pSiS->VBFlags & VB_CHRONTEL) {
	      switch(pSiS->VGAEngine) {
	      case SIS_300_VGA:
                 return 50000;
	      case SIS_315_VGA:
	      default:
		 return 70000;
	      }
	   } else if(pSiS->VBFlags & VB_SISBRIDGE) {
	      if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPR)
	         return 75000;
	      else
	         return 70000;
	   }
	}

	return 0;
}

/* Calculate the maximum dotclock */
int SiSMemBandWidth(ScrnInfoPtr pScrn, BOOLEAN IsForCRT2)
{
        SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
        SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

        int             bus = pSiS->BusWidth;
        int             mclk = pSiS->MemClock;
        int             bpp = pSiS->CurrentLayout.bitsPerPixel;
	int             bytesperpixel = (bpp + 7) / 8;
        float   	magic=0.0, total, crt2used, maxcrt2;
	int		crt2clock, max=0;
#ifdef __SUNPRO_C
#define const
#endif
        const float     magic300[4] = { 1.2,      1.368421, 2.263158, 1.2};
        const float     magic630[4] = { 1.441177, 1.441177, 2.588235, 1.441177 };
	const float     magic315[4] = { 1.2,      1.368421, 1.368421, 1.2 };
	const float     magic550[4] = { 1.441177, 1.441177, 2.588235, 1.441177 };
#ifdef __SUNPRO_C
#undef const
#endif
	BOOLEAN	        DHM, GetForCRT1;

        switch(pSiS->Chipset) {

        case PCI_CHIP_SIS5597:
	        total = ((mclk * (bus / 8)) * 0.7) / bytesperpixel;
		if(total > 135000) total = 135000;
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			"Maximum pixel clock at %d bpp is %g MHz\n",
			bpp, total/1000);
                return(int)(total);

        case PCI_CHIP_SIS6326:
		total = ((mclk * (bus / 8)) * 0.7) / bytesperpixel;
		if(total > 175500) total = 175500;
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			"Maximum pixel clock at %d bpp is %g MHz\n",
			bpp, total/1000);
		return(int)(total);

        case PCI_CHIP_SIS530:
	        total = ((mclk * (bus / 8)) * 0.7) / bytesperpixel;
		if(total > 230000) total = 230000;
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			"Maximum pixel clock at %d bpp is %g MHz\n",
			bpp, total/1000);
		return(int)(total);

        case PCI_CHIP_SIS300:
        case PCI_CHIP_SIS540:
        case PCI_CHIP_SIS630:
	case PCI_CHIP_SIS315:
	case PCI_CHIP_SIS315H:
	case PCI_CHIP_SIS315PRO:
	case PCI_CHIP_SIS550:
	case PCI_CHIP_SIS650:
	case PCI_CHIP_SIS330:
	case PCI_CHIP_SIS660:
	        switch(pSiS->Chipset) {
        	case PCI_CHIP_SIS300:
	            magic = magic300[bus/64];
		    max = 540000;
                    break;
        	case PCI_CHIP_SIS540:
       	 	case PCI_CHIP_SIS630:
		    magic = magic630[bus/64];
		    max = 540000;
                    break;
		case PCI_CHIP_SIS315:
		case PCI_CHIP_SIS315H:
		case PCI_CHIP_SIS315PRO:
		case PCI_CHIP_SIS330:
		    magic = magic315[bus/64];
		    max = 780000;
		    break;
		case PCI_CHIP_SIS550:
		    magic = magic550[bus/64];
		    max = 620000;
		    break;
		case PCI_CHIP_SIS650:
		    magic = magic550[bus/64];
		    max = 680000;
		    break;
		case PCI_CHIP_SIS660:
		    if((pSiS->sishw_ext.jChipType >= SIS_660) &&
		       (!(pSiS->ChipFlags & SiSCF_760UMA))) {
		       magic = magic315[bus/64];
		    } else {
		       magic = magic550[bus/64];
		    }
		    max = 680000;
                }

                PDEBUG(ErrorF("mclk: %d, bus: %d, magic: %g, bpp: %d\n",
                                mclk, bus, magic, bpp));

                total = mclk * bus / bpp;

                xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			"Memory bandwidth at %d bpp is %g MHz\n", bpp, total/1000);

                if((pSiS->VBFlags & CRT2_ENABLE) && (!pSiS->CRT1off)) {

		    maxcrt2 = 135000;
		    if(pSiS->VBFlags & (VB_301B|VB_302B)) maxcrt2 = 162000;
		    else if(pSiS->VBFlags & VB_301C)      maxcrt2 = 203000;
		    /* if(pSiS->VBFlags & VB_30xBDH)      maxcrt2 = 100000;
		       Ignore 301B-DH here; seems the current version is like
		       301B anyway */

		    crt2used = 0.0;
		    crt2clock = SiSEstimateCRT2Clock(pScrn, IsForCRT2);
		    if(crt2clock) {
		    	crt2used = crt2clock + 2000;
		    }
		    DHM = FALSE;
		    GetForCRT1 = FALSE;

#ifdef SISDUALHEAD
		    if((pSiS->DualHeadMode) && (pSiSEnt)) {
		       DHM = TRUE;
		       if(pSiS->SecondHead) GetForCRT1 = TRUE;
		    }
#endif
#ifdef SISMERGED
		    if(pSiS->MergedFB && IsForCRT2) {
		       DHM = TRUE;
		       GetForCRT1 = FALSE;
		    }
#endif

		    if(DHM) {

		        if(!GetForCRT1) {

			     /* TW: First head = CRT2 */

			     if(crt2clock) {
			        /* TW: We use the mem bandwidth as max clock; this
				 *     might exceed the 70% limit a bit, but that
				 *     does not matter; we take care of that limit
				 *     when we calc CRT1. Overall, we might use up
				 *     to 85% of the memory bandwidth, which seems
				 *     enough to use accel and video.
				 *     The "* macic" is just to compensate the
				 *     calculation below.
				*/
			        total = crt2used * magic;
				
			     } else {
			        /*  We don't know about the second head's
				 *  depth yet. So we assume it uses the
			         *  same. But since the maximum dotclock
				 *  is limited on CRT2, we can assume a
				 *  maximum here.
			         */
                                if((total / 2) > (maxcrt2 + 2000)) {
				    total = (maxcrt2 + 2000) * magic;
				    crt2used = maxcrt2 + 2000;
				} else {
				    total /= 2;
				    crt2used = total;
				}
				
                             }
			     
			     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	           "Bandwidth reserved for CRT2 is %g Mhz\n",
				      crt2used/1000);

			} else {
#ifdef SISDUALHEAD
			     /* TW: Second head = CRT1 */

			     /*     Now We know about the first head's depth,
			      *     so we can calculate more accurately.
			      */

			     if(crt2clock) {
			        total -= (crt2used * pSiSEnt->pScrn_1->bitsPerPixel / bpp);
				xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	           "Bandwidth reserved for CRT2 at %d bpp is %g Mhz\n",
				      bpp,
				      (crt2used * pSiSEnt->pScrn_1->bitsPerPixel / bpp)/1000);
			     } else {
			        total -= (pSiSEnt->maxUsedClock * pSiSEnt->pScrn_1->bitsPerPixel / bpp);
				xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	           "Bandwidth reserved for CRT2 at %d bpp is %d Mhz\n",
				      bpp,
				      (pSiSEnt->maxUsedClock * pSiSEnt->pScrn_1->bitsPerPixel / bpp)/1000);
			     }

			     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			        "Bandwidth available for CRT1 is %g MHz\n", total/1000);
#endif
			}

		    } else {

			if(crt2clock) {
			    total -= crt2used;
			} else {
                            if((total / 2) > (maxcrt2 + 2000)) {
			    	total -= (maxcrt2 + 2000);
				crt2used = maxcrt2 + 2000;
			    } else {  
			    	total /= 2;
				crt2used = total;
			    }		   
			}
			xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	  "Bandwidth reserved for CRT2 is %g Mhz\n", crt2used/1000);

			xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			  "Bandwidth available for CRT1 is %g MHz\n", total/1000);

                    }

                }
		total /= magic;
		if(total > (max / 2)) total = max / 2;
                return(int)(total);

        default:
                return(135000);
        }
}

/* Load the palette. We do this for all supported color depths
 * in order to support gamma correction. We hereby convert the
 * given colormap to a complete 24bit color palette and enable
 * the correspoding bit in SR7 to enable the 24bit lookup table.
 * Gamma correction is only supported on CRT1.
 * Why are there 6-bit-RGB values submitted even if bpp is 16 and
 * weight is 565? (Maybe because rgbBits is 6?)
 */
void
SISLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices, LOCO *colors,
               VisualPtr pVisual)
{
     SISPtr  pSiS = SISPTR(pScrn);
     int     i, j, index;
     unsigned char backup = 0;
     Bool    dogamma1 = pSiS->CRT1gamma;
     Bool    resetxvgamma = FALSE;
#ifdef SISDUALHEAD
     SISEntPtr pSiSEnt = pSiS->entityPrivate;

     if(pSiS->DualHeadMode) dogamma1 = pSiSEnt->CRT1gamma;
#endif

     PDEBUG(ErrorF("SiSLoadPalette(%d)\n", numColors));

#ifdef SISDUALHEAD
     if((!pSiS->DualHeadMode) || (pSiS->SecondHead)) {
#endif

        if(pSiS->VGAEngine == SIS_315_VGA) {
	   inSISIDXREG(SISSR, 0x1f, backup);
	   andSISIDXREG(SISSR, 0x1f, 0xe7);
	   if( (pSiS->XvGamma) &&
	       (pSiS->MiscFlags & MISC_CRT1OVERLAYGAMMA) &&
	       ((pSiS->CurrentLayout.depth == 16) ||
	        (pSiS->CurrentLayout.depth == 24)) ) {
	      orSISIDXREG(SISSR, 0x1f, 0x10);
	      resetxvgamma = TRUE;
	   }
        }

        switch(pSiS->CurrentLayout.depth) {
#ifdef SISGAMMA
          case 15:
	     if(dogamma1) {
	        orSISIDXREG(SISSR, 0x07, 0x04);
	        for(i=0; i<numColors; i++) {
                   index = indices[i];
		   if(index < 32) {   /* Paranoia */
		      for(j=0; j<8; j++) {
		         outSISREG(SISCOLIDX, (index * 8) + j);
                         outSISREG(SISCOLDATA, colors[index].red << (8- pScrn->rgbBits));
                         outSISREG(SISCOLDATA, colors[index].green << (8 - pScrn->rgbBits));
                         outSISREG(SISCOLDATA, colors[index].blue << (8 - pScrn->rgbBits));
		      }
		   }
                }
	     } else {
	        andSISIDXREG(SISSR, 0x07, ~0x04);
	     }
	     break;
	  case 16:
	     if(dogamma1) {
                orSISIDXREG(SISSR, 0x07, 0x04);
	        for(i=0; i<numColors; i++) {
                   index = indices[i];
		   if(index < 64) {  /* Paranoia */
		      for(j=0; j<4; j++) {
		         outSISREG(SISCOLIDX, (index * 4) + j);
                         outSISREG(SISCOLDATA, colors[index/2].red << (8 - pScrn->rgbBits));
                         outSISREG(SISCOLDATA, colors[index].green << (8 - pScrn->rgbBits));
                         outSISREG(SISCOLDATA, colors[index/2].blue << (8 - pScrn->rgbBits));
		      }
		   }
                }
	     } else {
	        andSISIDXREG(SISSR, 0x07, ~0x04);
	     }
	     break;
          case 24:
	     if(dogamma1) {
	        orSISIDXREG(SISSR, 0x07, 0x04);
                for(i=0; i<numColors; i++)  {
                   index = indices[i];
		   if(index < 256) {   /* Paranoia */
                      outSISREG(SISCOLIDX, index);
                      outSISREG(SISCOLDATA, colors[index].red);
                      outSISREG(SISCOLDATA, colors[index].green);
                      outSISREG(SISCOLDATA, colors[index].blue);
		   }
                }
	     } else {
	        andSISIDXREG(SISSR, 0x07, ~0x04);
	     }
	     break;
#endif
	  default:
	     if((pScrn->rgbBits == 8) && (dogamma1))
	        orSISIDXREG(SISSR, 0x07, 0x04);
	     else
	        andSISIDXREG(SISSR, 0x07, ~0x04);
             for(i=0; i<numColors; i++)  {
                index = indices[i];
                outSISREG(SISCOLIDX, index);
                outSISREG(SISCOLDATA, colors[index].red >> (8 - pScrn->rgbBits));
                outSISREG(SISCOLDATA, colors[index].green >> (8 - pScrn->rgbBits));
                outSISREG(SISCOLDATA, colors[index].blue >> (8 - pScrn->rgbBits));
             }
	}

	if(pSiS->VGAEngine == SIS_315_VGA) {
	   outSISIDXREG(SISSR, 0x1f, backup);
	   inSISIDXREG(SISSR, 0x07, backup);
	   if((backup & 0x04) && (resetxvgamma) && (pSiS->ResetXvGamma)) {
	      (pSiS->ResetXvGamma)(pScrn);
	   }
	}

#ifdef SISDUALHEAD		
    }	

    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead)) {
#endif

       switch(pSiS->VGAEngine) {
       case SIS_300_VGA:
       case SIS_315_VGA:
          if(pSiS->VBFlags & CRT2_ENABLE) {
	     /* Only the SiS bridges support a CRT2 palette */
	     if(pSiS->VBFlags & VB_SISBRIDGE) {
                (*pSiS->LoadCRT2Palette)(pScrn, numColors, indices, colors, pVisual);
	     }
          }
       }
	
#ifdef SISDUALHEAD		
    }
#endif

}

static  void
SiS301LoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
                                        LOCO *colors, VisualPtr pVisual)
{
        SISPtr  pSiS = SISPTR(pScrn);
        int     i, j, index;
	Bool    dogamma2 = pSiS->CRT2gamma;
#ifdef SISDUALHEAD
        SISEntPtr pSiSEnt = pSiS->entityPrivate;

	if(pSiS->DualHeadMode) dogamma2 = pSiSEnt->CRT2gamma;
#endif

        PDEBUG(ErrorF("SiS301LoadPalette(%d)\n", numColors));

	/* 301B-DH does not support a color palette for LCD */
	if((pSiS->VBFlags & VB_30xBDH) && (pSiS->VBFlags & CRT2_LCD)) return;
	
	switch(pSiS->CurrentLayout.depth) {
#ifdef SISGAMMA
          case 15:
	     if(dogamma2) {
	        orSISIDXREG(SISPART4, 0x0d, 0x08);
	        for(i=0; i<numColors; i++) {
                   index = indices[i];
		   if(index < 32) {   /* Paranoia */
		      for(j=0; j<8; j++) {
		         outSISREG(SISCOL2IDX, (index * 8) + j);
                         outSISREG(SISCOL2DATA, colors[index].red << (8- pScrn->rgbBits));
                         outSISREG(SISCOL2DATA, colors[index].green << (8 - pScrn->rgbBits));
                         outSISREG(SISCOL2DATA, colors[index].blue << (8 - pScrn->rgbBits));
		      }
		   }
                }
	     } else {
	        andSISIDXREG(SISPART4, 0x0d, ~0x08);
	     }
	     break;
	  case 16:
	     if(dogamma2) {
                orSISIDXREG(SISPART4, 0x0d, 0x08);
	        for(i=0; i<numColors; i++) {
                   index = indices[i];
		   if(index < 64) {  /* Paranoia */
		      for(j=0; j<4; j++) {
		         outSISREG(SISCOL2IDX, (index * 4) + j);
                         outSISREG(SISCOL2DATA, colors[index/2].red << (8 - pScrn->rgbBits));
                         outSISREG(SISCOL2DATA, colors[index].green << (8 - pScrn->rgbBits));
                         outSISREG(SISCOL2DATA, colors[index/2].blue << (8 - pScrn->rgbBits));
		      }
		   }
                }
	     } else {
	        andSISIDXREG(SISPART4, 0x0d, ~0x08);
	     }
	     break;
          case 24:
	     if(dogamma2) {
	        orSISIDXREG(SISPART4, 0x0d, 0x08);
                for(i=0; i<numColors; i++)  {
                   index = indices[i];
		   if(index < 256) {   /* Paranoia */
                      outSISREG(SISCOL2IDX, index);
                      outSISREG(SISCOL2DATA, colors[index].red);
                      outSISREG(SISCOL2DATA, colors[index].green);
                      outSISREG(SISCOL2DATA, colors[index].blue);
		   }
                }
	     } else {
	        andSISIDXREG(SISPART4, 0x0d, ~0x08);
	     }
	     break;
#endif
	  default:
	     if((pScrn->rgbBits == 8) && (dogamma2))
	        orSISIDXREG(SISPART4, 0x0d, 0x08);
	     else
	        andSISIDXREG(SISPART4, 0x0d, ~0x08);
             for(i=0; i<numColors; i++)  {
                index = indices[i];
                outSISREG(SISCOL2IDX,  index);
                outSISREG(SISCOL2DATA, colors[index].red);
                outSISREG(SISCOL2DATA, colors[index].green);
                outSISREG(SISCOL2DATA, colors[index].blue);
             }
	 }
}

void
SISDACPreInit(ScrnInfoPtr pScrn)
{
    SISPtr  pSiS = SISPTR(pScrn);

    switch (pSiS->Chipset)  {
      case PCI_CHIP_SIS550:
      case PCI_CHIP_SIS650:
      case PCI_CHIP_SIS315:
      case PCI_CHIP_SIS315H:
      case PCI_CHIP_SIS315PRO:
      case PCI_CHIP_SIS330:
      case PCI_CHIP_SIS660:
        pSiS->MaxClock               = SiSMemBandWidth(pScrn, FALSE);
        pSiS->SiSSave                = SiS315Save;
        pSiS->SiSSave2               = SiS301Save;
        pSiS->SiSSave3               = SiS301BSave;
        pSiS->SiSSaveLVDSChrontel    = SiSLVDSChrontelSave;
        pSiS->SiSRestore             = SiS315Restore;
        pSiS->SiSRestore2            = SiS301Restore;
        pSiS->SiSRestore3            = SiS301BRestore;
        pSiS->SiSRestoreLVDSChrontel = SiSLVDSChrontelRestore;
        pSiS->LoadCRT2Palette        = SiS301LoadPalette;
        break;
      case PCI_CHIP_SIS300:
      case PCI_CHIP_SIS630:
      case PCI_CHIP_SIS540:
        pSiS->MaxClock               = SiSMemBandWidth(pScrn, FALSE);
        pSiS->SiSSave                = SiS300Save;
        pSiS->SiSSave2               = SiS301Save;
        pSiS->SiSSave3               = SiS301BSave;
        pSiS->SiSSaveLVDSChrontel    = SiSLVDSChrontelSave;
        pSiS->SiSRestore             = SiS300Restore;
        pSiS->SiSRestore2            = SiS301Restore;
        pSiS->SiSRestore3            = SiS301BRestore;
        pSiS->SiSRestoreLVDSChrontel = SiSLVDSChrontelRestore;
        pSiS->LoadCRT2Palette        = SiS301LoadPalette;
        break;
      case PCI_CHIP_SIS5597:
      case PCI_CHIP_SIS6326:
      case PCI_CHIP_SIS530:
      default:
        pSiS->MaxClock               = SiSMemBandWidth(pScrn, FALSE);
        pSiS->SiSRestore             = SiSRestore;
        pSiS->SiSSave                = SiSSave;
        break;
    }
}

static void
SetBlock(CARD16 port, CARD8 from, CARD8 to, CARD8 *DataPtr)
{
    CARD8   index;

    for(index = from; index <= to; index++, DataPtr++) {
       outSISIDXREG(port, index, *DataPtr);
    }
}

void
SiS6326SetTVReg(ScrnInfoPtr pScrn, CARD8 index, CARD8 data)
{
    SISPtr  pSiS = SISPTR(pScrn);
    outSISIDXREG(SISCR, 0xE0, index);
    outSISIDXREG(SISCR, 0xE1, data);
#ifdef TWDEBUG
    xf86DrvMsg(0, X_INFO, "SiS6326: Setting Tv %02x to %02x\n", index, data);
#endif
}

unsigned char
SiS6326GetTVReg(ScrnInfoPtr pScrn, CARD8 index)
{
    SISPtr  pSiS = SISPTR(pScrn);
    unsigned char data;

    outSISIDXREG(SISCR, 0xE0, index);
    inSISIDXREG(SISCR, 0xE1, data);
    return(data);
}

void
SiS6326SetXXReg(ScrnInfoPtr pScrn, CARD8 index, CARD8 data)
{
    SISPtr  pSiS = SISPTR(pScrn);
    outSISIDXREG(SISCR, 0xE2, index);
    outSISIDXREG(SISCR, 0xE3, data);
}

unsigned char
SiS6326GetXXReg(ScrnInfoPtr pScrn, CARD8 index)
{
    SISPtr  pSiS = SISPTR(pScrn);
    unsigned char data;

    outSISIDXREG(SISCR, 0xE2, index);
    inSISIDXREG(SISCR, 0xE3, data);
    return(data);
}
@


1.1
log
@Initial revision
@
text
@d1 1
d3 1
a3 1
 * Copyright 1998,1999 by Alan Hourihane, Wigan, England.
d5 1
a5 9
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Alan Hourihane not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Alan Hourihane makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
d7 35
a41 7
 * ALAN HOURIHANE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL ALAN HOURIHANE BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
a42 5
 * Authors:  Alan Hourihane, alanh@@fairlite.demon.co.uk
 *           Mike Chapman <mike@@paranoia.com>, 
 *           Juanjo Santamarta <santamarta@@ctv.es>, 
 *           Mitani Hiroshi <hmitani@@drl.mei.co.jp> 
 *           David Thomas <davtom@@dream.org.uk>. 
a43 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_dac.c,v 1.24 2002/01/17 09:57:30 eich Exp $ */
d51 1
a51 2

#include "vgaHW.h"
a56 1
#include "sis_bios.h"
d62 1
d65 1
a65 1
static void SiSLVDSSave(ScrnInfoPtr pScrn, SISRegPtr sisReg);
d67 1
d70 1
a70 2
static void SiSLVDSRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg);
static void SiSChrontelSave(ScrnInfoPtr pScrn, SISRegPtr sisReg);
a72 8
static void SiS300Threshold(ScrnInfoPtr pScrn, DisplayModePtr mode,
                      unsigned short *Low, unsigned short *High);
static void SiS630Threshold(ScrnInfoPtr pScrn, DisplayModePtr mode,
                      unsigned short *Low, unsigned short *High);
static void SiS530Threshold(ScrnInfoPtr pScrn, DisplayModePtr mode,
                      unsigned short *Low, unsigned short *High);
static void SiSThreshold(ScrnInfoPtr pScrn, DisplayModePtr mode,
                      unsigned short *Low, unsigned short *High);
d75 11
a85 1
static unsigned short ch7005idx[0x11]={0x00,0x07,0x08,0x0a,0x0b,0x04,0x09,0x20,0x21,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f};
d87 1
a87 2
int
SiScompute_vclk(
d133 1
d136 2
a137 2
    if ((f > 250.0) || (f < 18.75))
        return 0;
d142 10
a151 10
    while (x > 31.25) {
        y *= 2.0;
        x /= 2.0;
    }
    if (x >= 18.25) {
        x *= 8.0;
        y = 8.0 / y;
    } else if (x >= 15.625) {
        x *= 12.0;
        y = 12.0 / y;
d155 3
a157 3
    if (t == (float) 1.5) {
        *out_div = 2;
        t *= 2.0;
d159 1
a159 1
        *out_div = 1;
d161 3
a163 3
    if (t > (float) 4.0) {
        *out_sbit = 1;
        t /= 2.0;
d165 1
a165 1
        *out_sbit = 0;
d170 12
a181 12
    for (dn=2;dn<=32;dn++) {
        for (n=1;n<=128;n++) {
            error = x;
            error -= ((float) 14.318 * (float) n / (float) dn);
            if (error < (float) 0)
                    error = -error;
            if (error < min_error) {
                min_error = error;
                best_n = n;
                best_dn = dn;
            }
        }
d185 1
a185 1
    PDEBUG(ErrorF("SiScompute_vclk: Clock=%d, n=%d, dn=%d, div=%d, sbit=%d,"
d198 1
a198 1
    double bestError, abest = 42.0, bestFout;
d202 3
d209 1
a209 1
     *  M       = Numerator [1:128] 
d225 2
a226 2
#define MIN_VCO Fref
#define MAX_VCO 135000000
d228 2
a229 2
#define MAX_PSN 0 /* no pre scaler for this chip */
#define TOLERANCE 0.01  /* search smallest M and N in this tolerance */
d231 1
a231 1
  int M_min = 2; 
d233 1
a233 3
  
/*  abest=10000.0; */
 
a234 1
 
d236 110
a345 47
  if (pSiS->Chipset == PCI_CHIP_SIS5597 || pSiS->Chipset == PCI_CHIP_SIS6326){
        int low_N = 2;
        int high_N = 5;
 
	PSN = 1;
        P = 1;
        if (target < MAX_VCO_5597 / 2)
            P = 2;
        if (target < MAX_VCO_5597 / 3)
            P = 3;
        if (target < MAX_VCO_5597 / 4)
            P = 4;
        if (target < MAX_VCO_5597 / 6)
            P = 6;
        if (target < MAX_VCO_5597 / 8)
            P = 8;
 
        Fvco = P * target;
 
        for (N = low_N; N <= high_N; N++){
            double M_desired = Fvco / Fref * N;
            if (M_desired > M_max * max_VLD)
                continue;
 
            if ( M_desired > M_max ) {
                M = M_desired / 2 + 0.5;
                VLD = 2;
            } else {
                M = Fvco / Fref * N + 0.5;
                VLD = 1;
            }
 
            Fout = (double)Fref * (M * VLD)/(N * P);
 
            error = (target - Fout) / target;
            aerror = (error < 0) ? -error : error;
/*          if (aerror < abest && abest > TOLERANCE) */
            if (aerror < abest) {
                abest = aerror;
                bestError = error;
                bestM = M;
                bestN = N;
                bestP = P;
                bestPSN = PSN;
                bestVLD = VLD;
                bestFout = Fout;
            }
a347 64
     else {
         for (PSNx = 0; PSNx <= MAX_PSN ; PSNx++) {
            int low_N, high_N;
            double FrefVLDPSN;
 
            PSN = !PSNx ? 1 : 4;
 
            low_N = 2;
            high_N = 32;
 
            for ( VLD = 1 ; VLD <= max_VLD ; VLD++ ) {
 
                FrefVLDPSN = (double)Fref * VLD / PSN;
                for (N = low_N; N <= high_N; N++) {
                    double tmp = FrefVLDPSN / N;
 
                    for (P = 1; P <= 4; P++) {  
                        double Fvco_desired = target * ( P );
                        double M_desired = Fvco_desired / tmp;
 
                        /* Which way will M_desired be rounded?  
                         *  Do all three just to be safe.  
                         */
                        int M_low = M_desired - 1;
                        int M_hi = M_desired + 1;
 
                        if (M_hi < M_min || M_low > M_max)
                            continue;
 
                        if (M_low < M_min)
                            M_low = M_min;
                        if (M_hi > M_max)
                            M_hi = M_max;
 
                        for (M = M_low; M <= M_hi; M++) {
                            Fvco = tmp * M;
                            if (Fvco <= MIN_VCO)
                                continue;
                            if (Fvco > MAX_VCO)
                                break;
 
                            Fout = Fvco / ( P );
 
                            error = (target - Fout) / target;
                            aerror = (error < 0) ? -error : error;
                            if (aerror < abest) {
                                abest = aerror;
                                bestError = error;
                                bestM = M;
                                bestN = N;
                                bestP = P;
                                bestPSN = PSN;
                                bestVLD = VLD;
                                bestFout = Fout;
                            }
                        xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,3,"Freq. selected: %.2f MHz, M=%d, N=%d, VLD=%d,"
                               " P=%d, PSN=%d\n",
                               (float)(clock / 1000.), M, N, P, VLD, PSN);
                        xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,3,"Freq. set: %.2f MHz\n", Fout / 1.0e6);
                        }
                    }
                }
            }
         }
d350 5
a354 5
  vclk[Midx]    = bestM;
  vclk[Nidx]    = bestN;
  vclk[VLDidx]  = bestVLD;
  vclk[Pidx]    = bestP;
  vclk[PSNidx]  = bestPSN;
d356 1
a356 1
        PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
d358 1
a358 1
                (float)(clock / 1000.), vclk[Midx], vclk[Nidx], vclk[VLDidx], 
d360 1
a360 1
        PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
d362 1
a362 1
        PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
a370 1
    int vgaIOBase;
a371 3
    
        PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
                        "SiSSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n"));
d373 2
a374 2
    vgaHWGetIOBase(VGAHWPTR(pScrn));
    vgaIOBase = VGAHWPTR(pScrn)->IOBase;
d376 3
a378 1
    outw(VGA_SEQ_INDEX, 0x8605);
d380 1
a380 1
    switch (pSiS->Chipset) {
d382 1
a382 1
           max=0x39;
d386 1
a386 1
           max=0x3F;
d393 14
a406 5
    for (i = 0x06; i <= max; i++) {
        outb(VGA_SEQ_INDEX, i);
        xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
                    "XR%02X Contents - %02X \n", i, inb(VGA_SEQ_DATA));
        sisReg->sisRegs3C4[i] = inb(VGA_SEQ_DATA);
d408 1
d410 16
a425 2
    /*sisReg->sisRegs3C2 = inb(0x3CC);*/
    sisReg->sisRegs3C2 = inb(pSiS->RelIO+0x4c);
a431 1
    int vgaIOBase;
d433 1
d438 3
a440 4
    vgaHWGetIOBase(VGAHWPTR(pScrn));
    vgaIOBase = VGAHWPTR(pScrn)->IOBase;

    outw(VGA_SEQ_INDEX, 0x8605);
d442 1
a442 1
    switch (pSiS->Chipset) {
d444 1
a444 1
           max=0x39;
d447 2
a448 4
           max=0x3F;
           break;
        case PCI_CHIP_SIS530:
           max=0x3F;
d451 1
a451 1
           max=0x37;
d455 18
a472 4
    for (i = 0x06; i <= max; i++) {
        outb(VGA_SEQ_INDEX,i);
        xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,4,
                    "XR%X Contents - %02X ", i, inb(VGA_SEQ_DATA));
d474 2
a475 1
        outb(VGA_SEQ_DATA,sisReg->sisRegs3C4[i]);
d477 27
a503 3
        xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,4,
                        "Restore to - %02X Read after - %02X\n",
                        sisReg->sisRegs3C4[i], inb(VGA_SEQ_DATA));
d505 1
d507 9
a515 2
    /*outb(0x3C2, sisReg->sisRegs3C2);*/
    outb(pSiS->RelIO+0x42, sisReg->sisRegs3C2);
d517 36
a552 1
    /* MemClock needs this to take effect */
d554 13
a566 2
    outw(VGA_SEQ_INDEX, 0x0100);        /* Synchronous Reset */
    outw(VGA_SEQ_INDEX, 0x0300);        /* End Reset */
d568 10
d580 2
d583 1
a583 1
SiS300Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d586 2
a587 2
    int vgaIOBase;
    int i,max;
d589 2
a590 2
    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
			  "SiS300Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n"));
d592 3
a594 2
    vgaHWGetIOBase(VGAHWPTR(pScrn));
    vgaIOBase = VGAHWPTR(pScrn)->IOBase;
d596 7
a602 1
    outw(VGA_SEQ_INDEX, 0x8605);
d604 6
a609 1
    max=0x3D;
d611 3
a613 5
    for (i = 0x06; i <= max; i++) {
        outb(VGA_SEQ_INDEX, i);
        sisReg->sisRegs3C4[i] = inb(VGA_SEQ_DATA);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
		       "XR%02X Contents - %02X \n", i,sisReg->sisRegs3C4[i]);
d616 8
a623 4
    for (i=0x19; i<0x40; i++)  {
        inSISIDXREG(pSiS->RelIO+CROFFSET, i, sisReg->sisRegs3D4[i]);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
		       "3D4-%02X Contents - %02X \n", i,sisReg->sisRegs3D4[i]);
d626 5
a630 2
    /*sisReg->sisRegs3C2 = inb(0x3CC);*/
    sisReg->sisRegs3C2 = inb(pSiS->RelIO+0x4c);
d632 85
a716 18
#if 1 /* TW: Saving bridge data not yet needed; will possibly be when fixing VESA scaling problem */
    if (!pSiS->UseVESA) { /* TW: No need for touching the bridge registers when using VESA */
#endif
	if ((pSiS->VBFlags & VB_LVDS)) /* && (pSiS->VBFlags & CRT2_LCD)) */
	    (*pSiS->SiSSaveLVDS)(pScrn, sisReg);
	if ((pSiS->VBFlags & (VB_CHRONTEL))) /* | CRT2_TV))==(VB_CHRONTEL|CRT2_TV)) */
	    (*pSiS->SiSSaveChrontel)(pScrn,sisReg);
#if 1
    }
#endif
    if ((pSiS->VBFlags & (VB_301|VB_303))) /* && (pSiS->VBFlags & (CRT2_LCD|CRT2_TV|CRT2_VGA))) */
	(*pSiS->SiSSave2)(pScrn, sisReg);
#if 1
    if (!pSiS->UseVESA) {  /* TW: Don't touch the 301B/302 when using VESA (PRILIMINARY) */
#endif
	if ((pSiS->VBFlags & (VB_301B|VB_302))) /* && (pSiS->VBFlags & (CRT2_LCD|CRT2_TV|CRT2_VGA))) */
	    (*pSiS->SiSSave3)(pScrn, sisReg);
#if 1
d718 8
d727 1
a727 3
 
    if ((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_LCD))
  	pSiS->BIOSModeSave = SiSGetSetModeID(pScrn,0xFF);    
d730 1
d732 1
a732 1
SiS300Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d735 4
a738 2
    int vgaIOBase;
    int i,max, temp;
d740 3
a742 2
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
		   "SiS300Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n");
d744 8
a751 2
    vgaHWGetIOBase(VGAHWPTR(pScrn));
    vgaIOBase = VGAHWPTR(pScrn)->IOBase;
d753 2
a754 1
    outw(VGA_SEQ_INDEX, 0x8605); /* Unlock registers */
d756 7
a762 39
    /* TW: Wait for accellerator to finish on-going drawing operations. */
    xf86DrvMsg(0, X_PROBED, "Before wait\n");
    outb(VGA_SEQ_INDEX, 0x1E);
    temp = inb(VGA_SEQ_DATA);
    if (temp & (0x40|0x10))  {	/* TW: 0x40 = 2D, 0x10 = 3D enabled*/
        while ( (MMIO_IN16(pSiS->IOBase, 0x8242) & 0xE000) != 0xE000){};
	while ( (MMIO_IN16(pSiS->IOBase, 0x8242) & 0xE000) != 0xE000){};
    } /* TW: do it twice as in sis300_accel.h */
    xf86DrvMsg(0, X_PROBED, "After wait\n");

    max=0x3D;
    for (i = 0x19; i < 0x40; i++)  {
        outSISIDXREG(pSiS->RelIO+CROFFSET, i, sisReg->sisRegs3D4[i]);
    }
    if (pSiS->Chipset != PCI_CHIP_SIS300)  {
	unsigned char val;
	inSISIDXREG(pSiS->RelIO+CROFFSET,0x1A,val);
	if (val == sisReg->sisRegs3D4[0x19])
	    outSISIDXREG(pSiS->RelIO+CROFFSET, 0x1A, sisReg->sisRegs3D4[0x19]);
	inSISIDXREG(pSiS->RelIO+CROFFSET,0x19,val);
	if (val == sisReg->sisRegs3D4[0x1A])
	    outSISIDXREG(pSiS->RelIO+CROFFSET, 0x19, sisReg->sisRegs3D4[0x1A]);
    }

    /* On 630, set SR20 | 0x20 if accellerators are on */               /*0x40*/
    if ((pSiS->Chipset == PCI_CHIP_SIS630) && (sisReg->sisRegs3C4[0x1e] & 0x50)) {
	sisReg->sisRegs3C4[0x20] |= 0x20;
	outb(VGA_SEQ_INDEX, 0x20);
	outb(VGA_SEQ_DATA, sisReg->sisRegs3C4[0x20]);
        /* outw(VGA_SEQ_INDEX, sisReg->sisRegs3C4[0x20] << 8 | 0x20); */
    }

    /* TW: If TQ is switched on, don't switch it off ever again */
    if (!pSiS->NoAccel) {
	if (pSiS->TurboQueue) {
	    temp = (pScrn->videoRam/64) - 8;
	    sisReg->sisRegs3C4[0x26] = temp & 0xFF;
	    sisReg->sisRegs3C4[0x27] = ((temp >> 8) & 3) | 0xF0;
	}
d765 7
a771 27
    for (i = 0x06; i <= max; i++) {
	outb(VGA_SEQ_INDEX,i);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
		       "XR%X Contents - %02X ", i, inb(VGA_SEQ_DATA));
	outb(VGA_SEQ_DATA,sisReg->sisRegs3C4[i]);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
		       "Restore to - %02X Read after - %02X\n",
		       sisReg->sisRegs3C4[i], inb(VGA_SEQ_DATA));
    }
#if 1 /* TW: Saving bridge data not yet needed; will possibly be when fixing VESA scaling problem */
    if (!pSiS->UseVESA) { /* TW: No need for touching the bridge registers when using VESA */
#endif
	if ((pSiS->VBFlags & VB_LVDS)) /* && (pSiS->VBFlags & CRT2_LCD)) */
	    (*pSiS->SiSRestoreLVDS)(pScrn, sisReg);
	if ((pSiS->VBFlags & (VB_CHRONTEL))) /* | CRT2_TV))==(VB_CHRONTEL|CRT2_TV)) */
	    (*pSiS->SiSRestoreChrontel)(pScrn,sisReg);
#if 1
    }
#endif
    if ((pSiS->VBFlags & (VB_301|VB_303))) /* && (pSiS->VBFlags & (CRT2_LCD|CRT2_TV|CRT2_VGA))) */
	(*pSiS->SiSRestore2)(pScrn, sisReg);
#if 1
    if (!pSiS->UseVESA) {  /* TW: Don't touch the 301B/302 when using VESA */
#endif
	if ((pSiS->VBFlags & (VB_301B|VB_302))) /* && (pSiS->VBFlags & (CRT2_LCD|CRT2_TV|CRT2_VGA))) */
	    (*pSiS->SiSRestore3)(pScrn, sisReg);
#if 1
d773 7
d781 1
d783 2
a784 2
    /*outb(0x3C2, sisReg->sisRegs3C2);*/
    outb(pSiS->RelIO+0x42, sisReg->sisRegs3C2);
d786 13
a798 3
    /* MemClock needs this to take effect */
    outw(VGA_SEQ_INDEX, 0x0100);        /* Synchronous Reset */
    outw(VGA_SEQ_INDEX, 0x0300);        /* End Reset */
d800 5
a804 2
    if ((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_LCD))
	SiSGetSetModeID(pScrn,pSiS->BIOSModeSave);
d806 4
d812 1
d814 1
a814 1
SiS301Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d816 9
a824 2
    SISPtr  pSiS = SISPTR(pScrn);
    int     i;
d826 6
a831 3
    /* for SiS301 only */
    for (i=0; i<0x29; i++)  {
        inSISIDXREG(pSiS->RelIO+4, i, sisReg->VBPart1[i]);
d833 61
a893 2
    for (i=0; i<0x46; i++)  {
        inSISIDXREG(pSiS->RelIO+0x10, i, sisReg->VBPart2[i]);
d895 19
a913 2
    for (i=0; i<0x3F; i++)  {
        inSISIDXREG(pSiS->RelIO+0x12, i, sisReg->VBPart3[i]);
d915 10
a924 5
    for (i=0; i<0x1C; i++)  {
        inSISIDXREG(pSiS->RelIO+0x14, i, sisReg->VBPart4[i]);
    }
    sisReg->VBPart2[0] &= ~0x20;    /* Disable VB Processor */
    sisReg->sisRegs3C4[0x32] &= ~0x20;      /* Disable Lock Mode */
d928 1
a928 1
SiS301BSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d933 5
a937 3
    /* for SiS301 only */
    for (i=0; i<0x29; i++)  {
        inSISIDXREG(pSiS->RelIO+4, i, sisReg->VBPart1[i]);
d939 5
a943 2
    for (i=0; i<0x46; i++)  {
        inSISIDXREG(pSiS->RelIO+0x10, i, sisReg->VBPart2[i]);
d945 5
a949 2
    for (i=0; i<0x3F; i++)  {
        inSISIDXREG(pSiS->RelIO+0x12, i, sisReg->VBPart3[i]);
d951 5
a955 2
    for (i=0; i<0x1C; i++)  {
        inSISIDXREG(pSiS->RelIO+0x14, i, sisReg->VBPart4[i]);
a956 2
    sisReg->VBPart2[0] &= ~0x20;    /* Disable VB Processor */
    sisReg->sisRegs3C4[0x32] &= ~0x20;      /* Disable Lock Mode */
d959 1
d961 1
a961 1
SiSLVDSSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d964 11
a974 1
    int     i;
d976 2
a977 5
    /* for SiS LVDS only */
    for (i=0; i<0x29; i++)  {
        inSISIDXREG(pSiS->RelIO+4, i, sisReg->VBPart1[i]);
    }
    sisReg->sisRegs3C4[0x32] &= ~0x20;      /* Disable Lock Mode */
d980 1
d982 1
a982 1
SiSChrontelSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d985 30
a1014 1
    int     i;
d1016 5
a1020 3
    /* for SiS Chrontel TV */
    for (i=0; i<0x29; i++)  {
        inSISIDXREG(pSiS->RelIO+4, i, sisReg->VBPart1[i]);
a1021 2
    for (i=0; i<0x11; i++)
        sisReg->ch7005[i]=SiSGetCH7005(ch7005idx[i]);
d1023 20
a1042 1
    sisReg->sisRegs3C4[0x32] &= ~0x20;      /* Disable Lock Mode */
d1045 1
d1047 1
a1047 1
SiS301Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d1050 1
a1050 1
    unsigned char   temp, temp1;
d1052 11
a1062 2
    SiSDisableBridge301(pSiS->RelIO+0x30); 
    SiSUnLockCRT2(pSiS->RelIO+0x30);  
d1064 1
a1064 39
    /* SetCRT2ModeRegs() */
    outSISIDXREG(pSiS->RelIO+0x04, 4, 0);
    outSISIDXREG(pSiS->RelIO+0x04, 5, 0);
    outSISIDXREG(pSiS->RelIO+0x04, 6, 0);
    outSISIDXREG(pSiS->RelIO+0x04, 0, sisReg->VBPart1[0]);
    outSISIDXREG(pSiS->RelIO+0x04, 1, sisReg->VBPart1[1]);
    outSISIDXREG(pSiS->RelIO+0x14, 0x0D, sisReg->VBPart4[0x0D]);
    outSISIDXREG(pSiS->RelIO+0x14, 0x0C, sisReg->VBPart4[0x0C]); 

    if (!(sisReg->sisRegs3D4[0x30] & 0x03) &&
         (sisReg->sisRegs3D4[0x31] & 0x20))  {      /* disable CRT2 */
            SiSLockCRT2(pSiS->RelIO+0x30);  
            return;
    }
    SetBlock(pSiS->RelIO+0x04, 0x02, 0x23, &(sisReg->VBPart1[0x02]));
    SetBlock(pSiS->RelIO+0x10, 0x00, 0x45, &(sisReg->VBPart2[0x00]));
    SetBlock(pSiS->RelIO+0x12, 0x00, 0x3E, &(sisReg->VBPart3[0x00]));
    SetBlock(pSiS->RelIO+0x14, 0x0E, 0x11, &(sisReg->VBPart4[0x0E]));
    SetBlock(pSiS->RelIO+0x14, 0x13, 0x1B, &(sisReg->VBPart4[0x13])); 

    outSISIDXREG(pSiS->RelIO+0x14, 0x0A, 1);
    outSISIDXREG(pSiS->RelIO+0x14, 0x0B, sisReg->VBPart4[0x0B]);
    outSISIDXREG(pSiS->RelIO+0x14, 0x0A, sisReg->VBPart4[0x0A]);
    outSISIDXREG(pSiS->RelIO+0x14, 0x12, 0);
    outSISIDXREG(pSiS->RelIO+0x14, 0x12, sisReg->VBPart4[0x12]); 

    temp1 = 0;
    if(!(pSiS->VBFlags & CRT2_VGA)) {
      inSISIDXREG(pSiS->RelIO+CROFFSET, 0x31, temp);
      if (temp & (SET_IN_SLAVE_MODE >> 8)) { 
         inSISIDXREG(pSiS->RelIO+CROFFSET, 0x30, temp);
         if (!(temp & (SET_CRT2_TO_RAMDAC >> 8))) {
            temp1 = 0x20;
         }
      }
    }
    setSISIDXREG(pSiS->RelIO+SROFFSET, 0x32, ~0x20, temp1);
    orSISIDXREG(pSiS->RelIO+SROFFSET, 0x1E, 0x20);
    andSISIDXREG(pSiS->RelIO+SROFFSET, 1, ~0x20);   /* DisplayOn */
d1066 2
a1067 2
    SiSEnableBridge301(pSiS->RelIO+0x30);
    SiSLockCRT2(pSiS->RelIO+0x30);
d1070 1
a1070 1
/* TW: Preliminary - do the same as for 301 */
d1075 15
a1089 1
    unsigned char   temp, temp1;
d1091 1
a1091 2
    SiSDisableBridge301B(pSiS->RelIO+0x30);
    SiSUnLockCRT2(pSiS->RelIO+0x30);
d1093 43
a1135 39
    /* SetCRT2ModeRegs() */
    outSISIDXREG(pSiS->RelIO+0x04, 4, 0);
    outSISIDXREG(pSiS->RelIO+0x04, 5, 0);
    outSISIDXREG(pSiS->RelIO+0x04, 6, 0);
    outSISIDXREG(pSiS->RelIO+0x04, 0, sisReg->VBPart1[0]);
    outSISIDXREG(pSiS->RelIO+0x04, 1, sisReg->VBPart1[1]);
    outSISIDXREG(pSiS->RelIO+0x14, 0x0D, sisReg->VBPart4[0x0D]);
    outSISIDXREG(pSiS->RelIO+0x14, 0x0C, sisReg->VBPart4[0x0C]);

    if (!(sisReg->sisRegs3D4[0x30] & 0x03) &&
         (sisReg->sisRegs3D4[0x31] & 0x20))  {      /* disable CRT2 */
            SiSLockCRT2(pSiS->RelIO+0x30);
            return;
    }
    SetBlock(pSiS->RelIO+0x04, 0x02, 0x23, &(sisReg->VBPart1[0x02]));
    SetBlock(pSiS->RelIO+0x10, 0x00, 0x45, &(sisReg->VBPart2[0x00]));
    SetBlock(pSiS->RelIO+0x12, 0x00, 0x3E, &(sisReg->VBPart3[0x00]));
    SetBlock(pSiS->RelIO+0x14, 0x0E, 0x11, &(sisReg->VBPart4[0x0E]));
    SetBlock(pSiS->RelIO+0x14, 0x13, 0x1B, &(sisReg->VBPart4[0x13]));

    outSISIDXREG(pSiS->RelIO+0x14, 0x0A, 1);
    outSISIDXREG(pSiS->RelIO+0x14, 0x0B, sisReg->VBPart4[0x0B]);
    outSISIDXREG(pSiS->RelIO+0x14, 0x0A, sisReg->VBPart4[0x0A]);
    outSISIDXREG(pSiS->RelIO+0x14, 0x12, 0);
    outSISIDXREG(pSiS->RelIO+0x14, 0x12, sisReg->VBPart4[0x12]);
    
    temp1 = 0;
    if(!(pSiS->VBFlags & CRT2_VGA)) {
      inSISIDXREG(pSiS->RelIO+CROFFSET, 0x31, temp);
      if (temp & (SET_IN_SLAVE_MODE >> 8)) { 
         inSISIDXREG(pSiS->RelIO+CROFFSET, 0x30, temp);
         if (!(temp & (SET_CRT2_TO_RAMDAC >> 8))) { 
            temp1 = 0x20;
         }
      }
    }  
    setSISIDXREG(pSiS->RelIO+SROFFSET, 0x32, ~0x20, temp1); 
    orSISIDXREG(pSiS->RelIO+SROFFSET, 0x1E, 0x20);
    andSISIDXREG(pSiS->RelIO+SROFFSET, 1, ~0x20);   /* DisplayOn */
d1137 3
a1139 2
    SiSEnableBridge301B(pSiS->RelIO+0x30);  
    SiSLockCRT2(pSiS->RelIO+0x30);  
d1142 1
d1144 1
a1144 1
SiSLVDSRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d1146 2
a1147 1
        SISPtr  pSiS = SISPTR(pScrn);
d1149 9
a1157 2
        SiSDisableBridgeLVDS(pSiS->RelIO+0x30);
        SiSUnLockCRT2(pSiS->RelIO+0x30);  
d1159 22
a1180 13
        /* SetCRT2ModeRegs() */
        outSISIDXREG(pSiS->RelIO+0x04, 4, 0);
        outSISIDXREG(pSiS->RelIO+0x04, 5, 0);
        outSISIDXREG(pSiS->RelIO+0x04, 6, 0);
        outSISIDXREG(pSiS->RelIO+0x04, 0, sisReg->VBPart1[0]);
        outSISIDXREG(pSiS->RelIO+0x04, 1, sisReg->VBPart1[1]);

        if (!(sisReg->sisRegs3D4[0x30] & 0x03) &&
             (sisReg->sisRegs3D4[0x31] & 0x20))  {      /* disable CRT2 */
                SiSLockCRT2(pSiS->RelIO+0x30);  
                return;
        }
        SetBlock(pSiS->RelIO+0x04, 0x02, 0x23, &(sisReg->VBPart1[0x02]));
d1182 1
a1182 5
        orSISIDXREG(pSiS->RelIO+SROFFSET, 0x1E, 0x20);
        andSISIDXREG(pSiS->RelIO+SROFFSET, 1, ~0x20);   /* DisplayOn */

        SiSEnableBridgeLVDS(pSiS->RelIO+0x30);
        SiSLockCRT2(pSiS->RelIO+0x30);
d1185 1
d1187 1
a1187 1
SiSChrontelRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d1189 3
a1191 3
        SISPtr  pSiS = SISPTR(pScrn);
        int i;
        unsigned short wtemp;
d1193 32
a1224 2
        SiSDisableBridgeLVDS(pSiS->RelIO+0x30); 
        SiSUnLockCRT2(pSiS->RelIO+0x30);  
d1226 5
a1230 4
        for (i=0; i<0x11; i++)
        {       wtemp = ((sisReg->ch7005[i]) << 8) + (ch7005idx[i] & 0x00FF);
                SiSSetCH7005(wtemp);
        }
d1232 11
a1242 13
        /* SetCRT2ModeRegs() */
        outSISIDXREG(pSiS->RelIO+0x04, 4, 0);
        outSISIDXREG(pSiS->RelIO+0x04, 5, 0);
        outSISIDXREG(pSiS->RelIO+0x04, 6, 0);
        outSISIDXREG(pSiS->RelIO+0x04, 0, sisReg->VBPart1[0]);
        outSISIDXREG(pSiS->RelIO+0x04, 1, sisReg->VBPart1[1]);

        if (!(sisReg->sisRegs3D4[0x30] & 0x03) &&
             (sisReg->sisRegs3D4[0x31] & 0x20))  {      /* disable CRT2 */
                SiSLockCRT2(pSiS->RelIO+0x30);  
                return;
        }
        SetBlock(pSiS->RelIO+0x04, 0x02, 0x23, &(sisReg->VBPart1[0x02]));
d1244 5
a1248 2
        orSISIDXREG(pSiS->RelIO+SROFFSET, 0x1E, 0x20);
        andSISIDXREG(pSiS->RelIO+SROFFSET, 1, ~0x20);   /* DisplayOn */
d1250 3
a1252 2
        SiSEnableBridgeLVDS(pSiS->RelIO+0x30);  
        SiSLockCRT2(pSiS->RelIO+0x30);  
d1255 1
a1255 1
/* TW: Restores CRT2 output registers (needs to be called before VESARestore) */
d1260 1
d1262 2
a1263 14
   outw(VGA_SEQ_INDEX, 0x8605); /* Unlock registers */

   outSISIDXREG(pSiS->RelIO+CROFFSET, 0x33, sisReg->sisRegs3D4[0x33]);
   usleep(2000);
   outSISIDXREG(pSiS->RelIO+CROFFSET, 0x30, sisReg->sisRegs3D4[0x30]);
   outSISIDXREG(pSiS->RelIO+CROFFSET, 0x31, sisReg->sisRegs3D4[0x31]);
}


unsigned int
SiSddc1Read(ScrnInfoPtr pScrn)
{
#if 0
    SISPtr pSiS = SISPTR(pScrn);
a1264 2
    int vgaIOBase = VGAHWPTR(pScrn)->IOBase;
    unsigned char temp, temp2;
d1266 11
a1276 14
    outb(VGA_SEQ_INDEX, 0x05); /* Unlock Registers */
    temp2 = inb(VGA_SEQ_DATA);
    outw(VGA_SEQ_INDEX, 0x8605);

    /* Wait until vertical retrace is in progress. */
    while (inb(vgaIOBase + 0xA) & 0x08);
    while (!(inb(vgaIOBase + 0xA) & 0x08));

    /* Get the result */
    outb(VGA_SEQ_INDEX, 0x11); temp = inb(VGA_SEQ_DATA);

    outw(VGA_SEQ_INDEX, (temp2 << 8) | 0x05);

    return ((temp & 0x02)>>1);
d1280 1
d1283 3
a1285 3
{ 
	int mclk;
  	unsigned char Num, Denum, Base;
a1286 1
    /* Numerator */
a1287 10
    case PCI_CHIP_SG86C201:
    case PCI_CHIP_SG86C202:
    case PCI_CHIP_SG86C205:
    case PCI_CHIP_SG86C215:
    case PCI_CHIP_SG86C225:
    case PCI_CHIP_SIS5597:
    case PCI_CHIP_SIS6326:
    case PCI_CHIP_SIS530:
        read_xr(MemClock0,Num);
        mclk=14318*((Num & 0x7f)+1);
a1288 22
        /* Denumerator */
        read_xr(MemClock1,Denum);
        mclk=mclk/((Denum & 0x1f)+1);

        /* Divider. Don't seems to work for mclk in older cards */
        if ( (Num & 0x80)!=0 ) { 
            mclk = mclk*2;
        }

        /* Post-scaler. Values depends on SR13 bit 7  */
        outb(VGA_SEQ_INDEX, ClockBase); 
        Base = inb(VGA_SEQ_DATA);

        if ( (Base & 0x80)==0 ) {
            mclk = mclk / (((Denum & 0x60) >> 5)+1);
        }
        else {
            /* Values 00 and 01 are reserved */
            if ((Denum & 0x60) == 0x40) { mclk=mclk/6; }
            if ((Denum & 0x60) == 0x60) { mclk=mclk/8; }
        }
        break;
d1292 7
d1300 2
a1301 2
        read_xr(0x28, Num);
        mclk = 14318*((Num &0x7f)+1);
d1304 2
a1305 2
        read_xr(0x29, Denum);
        mclk = mclk/((Denum & 0x1f)+1);
d1308 1
a1308 3
        if ((Num & 0x80)!=0)  {
            mclk = mclk * 2;
        }
d1311 4
a1314 5
        if ((Denum & 0x80)==0)  {
            mclk = mclk / (((Denum & 0x60) >> 5) + 1);
        }  
        else  {
            mclk = mclk / ((((Denum & 0x60) >> 5) + 1) * 2);
d1317 4
d1322 23
a1344 1
        mclk = 0;
d1350 13
a1362 2
int SiSMemBandWidth(ScrnInfoPtr pScrn)
{ 
d1364 57
a1420 1
        SISRegPtr pReg = &pSiS->ModeReg;
d1424 8
a1431 3
        int             bpp = pScrn->bitsPerPixel;
        float   magic, total;
        const float     magic300[4] = { 1.2, 1.368421, 2.263158, 1.2};
d1433 16
a1449 1
        switch (pSiS->Chipset) {
d1451 14
a1464 10
                return 175000;    /* guest */
                
        case PCI_CHIP_SIS5597:
                if (((pReg->sisRegs3C4[Mode64] >> 1) & 3) == 0) /* Only 1 bank Vram */
                        mclk = (mclk * 8);
                else
                        mclk = (mclk * 16);
                if ((pReg->sisRegs3C4[ExtMiscCont5] & 0xC0) == 0xC0) 
                        mclk=mclk*2;
                return(mclk);
d1469 42
a1510 5
                if (pSiS->Chipset==PCI_CHIP_SIS300)
                        magic = magic300[bus/64];
                else
                        magic = magic630[bus/64];
                
d1513 123
a1635 11
                
                total = mclk*bus/bpp;
                
                ErrorF("Total Adapter Bandwidth is %gM\n", total/1000);
                
                if (pSiS->VBFlags & CRT2_ENABLE)  {
                        if (total/2 > 540000)
                                total -= 540000;
                        else
                                total /= 2;
                        ErrorF("CRT1 Used Bandwidth is %gM\n", total/1000);
d1637 3
a1639 1
                return (int)(total/magic);
a1640 2
        case PCI_CHIP_SIS530:
                return 230000;    /* guest */
d1642 1
a1642 1
                return 135000;    /* guest */
d1646 8
d1655 2
a1656 2
SISLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indicies, LOCO *colors,
                VisualPtr pVisual)
d1658 16
a1673 2
        SISPtr  pSiS = SISPTR(pScrn);
        int     i, index;
d1675 10
a1684 13
        PDEBUG(ErrorF("SiSLoadPalette(%d)\n", numColors));
        for (i=0; i<numColors; i++)  {
                index = indicies[i];
#if 0
                outSISREG(0x3c8, index);
                outSISREG(0x3c9, colors[index].red >> 2);
                outSISREG(0x3c9, colors[index].green >> 2);
                outSISREG(0x3c9, colors[index].blue >> 2);
#endif
                outSISREG(pSiS->RelIO+0x48, index);
                outSISREG(pSiS->RelIO+0x49, colors[index].red >> 2);
                outSISREG(pSiS->RelIO+0x49, colors[index].green >> 2);
                outSISREG(pSiS->RelIO+0x49, colors[index].blue >> 2);
d1686 16
a1701 7
        switch (pSiS->Chipset) {
            case PCI_CHIP_SIS630:
            case PCI_CHIP_SIS540:
            case PCI_CHIP_SIS300:
                if (pSiS->VBFlags & CRT2_ENABLE)  {
                        (*pSiS->LoadCRT2Palette)(pScrn, numColors, indicies,
                                                        colors, pVisual);
d1703 52
a1754 3
                break;
        }
}
d1756 7
a1762 6
static  void
SiS301LoadPalette(ScrnInfoPtr pScrn, int numColors, int *indicies,
                                        LOCO *colors, VisualPtr pVisual)
{
        SISPtr  pSiS = SISPTR(pScrn);
        int     i, index;
d1764 2
a1765 9
        PDEBUG(ErrorF("SiS301LoadPalette(%d)\n", numColors));
        for (i=0; i<numColors; i++)  {
                index = indicies[i];
                outSISREG(pSiS->RelIO+0x16, index);
                outSISREG(pSiS->RelIO+0x17, colors[index].red);
                outSISREG(pSiS->RelIO+0x17, colors[index].green);
                outSISREG(pSiS->RelIO+0x17, colors[index].blue);
        }
}
d1767 2
d1770 14
a1783 16
struct QConfig  {
        int     GT;
        int     QC;
};

static  struct  QConfig qconfig[20] = {
        {1, 0x0}, {1, 0x2}, {1, 0x4}, {1, 0x6}, {1, 0x8},
        {1, 0x3}, {1, 0x5}, {1, 0x7}, {1, 0x9}, {1, 0xb},
        {0, 0x0}, {0, 0x2}, {0, 0x4}, {0, 0x6}, {0, 0x8},
        {0, 0x3}, {0, 0x5}, {0, 0x7}, {0, 0x9}, {0, 0xb}};

static  int cycleA[20][2] = {
        {88,88}, {80,80}, {78,78}, {72,72}, {70,70},
        {79,72}, {77,70}, {71,64}, {69,62}, {49,44},
        {73,78}, {65,70}, {63,68}, {57,62}, {55,60},
        {64,62}, {62,60}, {56,54}, {54,52}, {34,34}};
d1785 1
a1785 79
static  void
SiS630Threshold(ScrnInfoPtr pScrn, DisplayModePtr mode,
                                unsigned short *Low, unsigned short *High)
{
    SISPtr   pSiS = SISPTR(pScrn);
    int      mclk = pSiS->MemClock;
    int      vclk = mode->Clock;
    int      bpp = pScrn->bitsPerPixel/8;
    int      buswidth = pSiS->BusWidth;
    CARD32   temp;
    PCITAG   NBridge;
    int      cyclea;
    int      low, lowa;

    int      i, j;


    if (!bpp)
        bpp = 1;

    i = 0;
    j = buswidth/128;

    while (1)  {
#ifdef  DEBUG
        ErrorF("Config %d GT = %d, QC = %x, CycleA = %d\n",
            i, qconfig[i].GT, qconfig[i].QC, cycleA[i][j]);
#endif
        cyclea = cycleA[i][j];
        lowa = cyclea * vclk * bpp;
        lowa = (lowa + (mclk-1)) / mclk;
        lowa = (lowa + 15) / 16;
        low = lowa + 1;
        if (low <= 0x13)
            break;
        else
            if (i < 19)
                i++;
            else  {
                low = 0x13;
                PDEBUG(ErrorF("This mode may has threshold "
                        "problem and had better removed\n"));
                break;
            }
    }
    PDEBUG(ErrorF("Using Config %d with CycleA = %d\n", i, cyclea));
    *Low = low;
    if (lowa+4 > 15)
            *High = 0x0F;
    else
            *High = lowa+4;

    /* write PCI configuration space */
    NBridge = pciTag(0, 0, 0);
    temp = pciReadLong(NBridge, 0x50);
    temp &= 0xF0FFFFFF;
    temp |= qconfig[i].QC << 24;
    pciWriteLong(NBridge, 0x50, temp);

    temp = pciReadLong(NBridge, 0xA0);
    temp &= 0xF0FFFFFF;
    temp |= qconfig[i].GT << 24;
    pciWriteLong(NBridge, 0xA0, temp);
}

struct funcargc {
        char    base;
        char    inc;
};

static  struct funcargc funca[12] = {
        {61, 3}, {52, 5}, {68, 7}, {100, 11},
        {43, 3}, {42, 5}, {54, 7}, {78, 11},
        {34, 3}, {37, 5}, {47, 7}, {67, 11}};
static  struct funcargc funcb[12] = {
        {81, 4}, {72, 6}, {88, 8}, {120, 12},
        {55, 4}, {54, 6}, {66, 8}, {90, 12},
        {42, 4}, {45, 6}, {55, 8}, {75, 12}};
static  char timing[8] = {1, 2, 2, 3, 0, 1, 1, 2};
d1788 2
a1789 2
SiS300Threshold(ScrnInfoPtr pScrn, DisplayModePtr mode,
                                unsigned short *Low, unsigned short *High)
d1791 5
a1795 33
    SISPtr          pSiS = SISPTR(pScrn);
    SISRegPtr       pReg = &pSiS->ModeReg;
    int             mclk = pSiS->MemClock;
    int             vclk = mode->Clock;
    int             bpp = pScrn->bitsPerPixel/8;
    int             lowa, lowb, low;
    struct funcargc *p;
    unsigned int    i, j;

    pReg->sisRegs3C4[0x16] = pSiS->SavedReg.sisRegs3C4[0x16];

    if (!bpp)       bpp = 1;

    do {
        i = GETBITSTR(pReg->sisRegs3C4[0x18], 6:5, 2:1) |
              GETBITS(pReg->sisRegs3C4[0x18], 1:1);
        j = GETBITSTR(pReg->sisRegs3C4[0x14], 7:6, 3:2) |
              GETBITS(pReg->sisRegs3C4[0x16], 7:6);
        p = &funca[j];

        lowa = (p->base + p->inc*timing[i])*vclk*bpp;
        lowa = (lowa + (mclk-1)) / mclk;
        lowa = (lowa + 15)/16;

        p = &funcb[j];
        lowb = (p->base + p->inc*timing[i])*vclk*bpp;
        lowb = (lowb + (mclk-1)) / mclk;
        lowb = (lowb + 15)/16;

        if (lowb < 4)
            lowb = 0;
        else
            lowb -= 4;
d1797 2
a1798 1
        low = (lowa > lowb)? lowa: lowb;
d1800 1
a1800 1
        low++;
d1802 71
a1872 20
        if (low <= 0x13) {
            break;
        } else {
            i = GETBITS(pReg->sisRegs3C4[0x16], 7:6);
            if (!i) {
                low = 0x13;
                break;
            } else {
                i--;
                pReg->sisRegs3C4[0x16] &= 0x3C;
                pReg->sisRegs3C4[0x16] |= (i << 6);
            }
        }
    } while (1);

    *Low = low;
    if (low+3 > 15)
            *High = 0x0F;
    else
            *High = low+3;
d1875 2
a1876 3
static void
SiS530Threshold(ScrnInfoPtr pScrn, DisplayModePtr mode,
                                unsigned short *Low, unsigned short *High)
a1878 15
    unsigned int    factor, z;
    unsigned int    vclk = mode->Clock,
                    bpp = pScrn->bitsPerPixel,
                    mclk = pSiS->MemClock,
                    buswidth = pSiS->BusWidth;
    
    if (pSiS->Flags & UMA)
        factor = 0x60;
    else
        factor = 0x30;
    z = factor * vclk * bpp;
    z = z / mclk / buswidth;
    *Low = (z+1)/2 + 4;
    if (*Low > 0x1F)
        *Low = 0x1F;
d1880 42
a1921 1
    *High = 0x1F;
d1925 1
a1925 2
SiSThreshold(ScrnInfoPtr pScrn, DisplayModePtr mode,
                                unsigned short *Low, unsigned short *High)
d1927 6
a1932 1
    return;
d1934 9
d1945 5
a1949 5
void SiSIODump(ScrnInfoPtr pScrn)
{       SISPtr          pSiS = SISPTR(pScrn);
        int     i, max3c4, min3d4, max3d4;
        int     SR5State;
        unsigned char   temp;
d1951 3
a1953 87
    switch (pSiS->Chipset)  {
        case PCI_CHIP_SIS6326:
            max3c4 = 0x3F;
            max3d4 = 0x19;
            min3d4 = 0x26;
            break;
        case PCI_CHIP_SIS530:
            max3c4 = 0x3F;
            max3d4 = 0x19;
            min3d4 = 0x26;
            break;
        case PCI_CHIP_SIS300:
        case PCI_CHIP_SIS630:
        case PCI_CHIP_SIS540:
            max3c4 = 0x3D;
            max3d4 = 0x37;
            min3d4 = 0x30;
            break;
        default:
            max3c4 = 0x38;
            max3d4 = 0x19;
            min3d4 = 0x26;
    }
    /* dump Misc Registers */
    /*temp = inb(0x3CC);*/
    temp = inb(pSiS->RelIO+0x4c);
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Misc Output 3CC=%x\n", temp);
    /*temp = inb(0x3CA);*/
    temp = inb(pSiS->RelIO+0x4a);
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Feature Control 3CA=%x\n", temp);

    /* Dump GR */
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "-------------\n");
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Registers 3CE\n");
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "-------------\n");
    for (i=0; i<=8; i++)  {
        /*outb(0x3ce, i);
        temp = inb(0x3cf);*/
        outb(pSiS->RelIO+0x4e, i);
        temp = inb(pSiS->RelIO+0x4f);
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[%2x]=%2x\n", i, temp);
    }

    /* dump SR0 ~ SR4 */
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "-------------\n");
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Registers 3C4\n");
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "-------------\n");
    for (i=0; i<=4; i++)  {
        /*outb(0x3c4, i);
        temp = inb(0x3c5);*/
        outb(pSiS->RelIO+0x44, i);
        temp = inb(pSiS->RelIO+0x45);
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[%2x]=%2x\n", i, temp);
    }

    /* dump extended SR */
    /*outb(0x3c4, 5);
    SR5State = inb(0x3c5);*/
    outb(pSiS->RelIO+0x44, 5);
    SR5State = inb(pSiS->RelIO+0x45);
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[05]=%2x\n", SR5State);
    /*outw(0x3c4, 0x8605);*/
    outw(pSiS->RelIO+0x44, 0x8605);
    for (i=6; i<=max3c4; i++)  {
        /*outb(0x3c4, i);
        temp = inb(0x3c5);*/
        outb(pSiS->RelIO+0x44, i);
        temp = inb(pSiS->RelIO+0x45);
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[%2x]=%2x\n", i, temp);
    }

    /* dump CR0 ~ CR18 */
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "-------------\n");
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Registers 3D4\n");
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "-------------\n");
    for (i=0; i<=0x18; i++)  {
        outb(0x3d4, i);
        temp = inb(0x3d5);
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[%2x]=%2x\n", i, temp);
    }
    for (i=min3d4; i<=max3d4; i++)  {   /* dump extended CR */
        outb(0x3d4, i);
        temp = inb(0x3d5);
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[%2x]=%2x\n", i, temp);
    }
    /*outw(0x3c4, SR5State << 8 | 0x05);*/
    outw(pSiS->RelIO+0x44, SR5State << 8 | 0x05);
a1955 1

d1957 1
a1957 1
SISDACPreInit(ScrnInfoPtr pScrn)
d1960 2
a1961 51

    switch (pSiS->Chipset)  {
    case PCI_CHIP_SIS630:
    case PCI_CHIP_SIS540:
        pSiS->MaxClock = SiSMemBandWidth(pScrn);
        pSiS->SiSSave           = SiS300Save;
        pSiS->SiSSave2          = SiS301Save;
        pSiS->SiSSave3          = SiS301BSave;
        pSiS->SiSSaveLVDS       = SiSLVDSSave;
        pSiS->SiSSaveChrontel   = SiSChrontelSave;
        pSiS->SiSRestore        = SiS300Restore;
        pSiS->SiSRestore2       = SiS301Restore;
        pSiS->SiSRestore3       = SiS301BRestore;
        pSiS->SiSRestoreLVDS    = SiSLVDSRestore;
        pSiS->SiSRestoreChrontel= SiSChrontelRestore;
        pSiS->LoadCRT2Palette   = SiS301LoadPalette;
        pSiS->SetThreshold      = SiS630Threshold;
        break;
    case PCI_CHIP_SIS300:
        pSiS->MaxClock = SiSMemBandWidth(pScrn);
        pSiS->SiSSave           = SiS300Save;
        pSiS->SiSSave2          = SiS301Save;
        pSiS->SiSSave3          = SiS301BSave;
        pSiS->SiSSaveLVDS       = SiSLVDSSave;
        pSiS->SiSSaveChrontel   = SiSChrontelSave;
        pSiS->SiSRestore        = SiS300Restore;
        pSiS->SiSRestore2       = SiS301Restore;
        pSiS->SiSRestore3       = SiS301BRestore;
        pSiS->SiSRestoreLVDS    = SiSLVDSRestore;
        pSiS->SiSRestoreChrontel= SiSChrontelRestore;
        pSiS->LoadCRT2Palette   = SiS301LoadPalette;
        pSiS->SetThreshold      = SiS300Threshold;
        break;
    case PCI_CHIP_SIS530:
        pSiS->MaxClock = SiSMemBandWidth(pScrn);
        pSiS->SiSRestore        = SiSRestore;
        pSiS->SiSSave           = SiSSave;
        pSiS->SetThreshold      = SiS530Threshold;
        break;
    case PCI_CHIP_SIS6326:
        pSiS->MaxClock = SiSMemBandWidth(pScrn);
        pSiS->SiSRestore        = SiSRestore;
        pSiS->SiSSave           = SiSSave;
        pSiS->SetThreshold      = SiSThreshold;
        break;
    default:
        pSiS->MaxClock = SiSMemBandWidth(pScrn);
        pSiS->SiSRestore        = SiSRestore;
        pSiS->SiSSave           = SiSSave;
        pSiS->SetThreshold      = SiSThreshold;
    }
d1964 2
a1965 2
static void
SetBlock(CARD16 port, CARD8 from, CARD8 to, CARD8 *DataPtr)
d1967 2
a1968 1
    CARD8   index;
d1970 3
a1972 3
    for (index=from; index <= to; index++, DataPtr++)  {
        outSISIDXREG(port, index, *DataPtr);
    }
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@a0 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_dac.c,v 1.57 2004/02/02 03:55:29 dawes Exp $ */
d2 1
a2 1
 * DAC helper functions (Save/Restore, MemClk, etc)
d4 9
a12 1
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria.
d14 7
a20 38
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement: "This product includes
 *    software developed by Thomas Winischhofer, Vienna, Austria."
 * 4) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author:  	Thomas Winischhofer <thomas@@winischhofer.net>
 *
 * SiS_compute_vclk(), SiSCalcClock() and parts of SiSMclk():
 * Copyright (C) 1998, 1999 by Alan Hourihane, Wigan, England
 * Written by:
 *	 Alan Hourihane <alanh@@fairlite.demon.co.uk>,
 *       Mike Chapman <mike@@paranoia.com>,
 *       Juanjo Santamarta <santamarta@@ctv.es>,
 *       Mitani Hiroshi <hmitani@@drl.mei.co.jp>,
 *       David Thomas <davtom@@dream.org.uk>,
 *	 Thomas Winischhofer <thomas@@winischhofer.net>.
 * Licensed under the terms of the XFree86 license
 * (http://www.xfree86.org/current/LICENSE1.html)
d22 5
d28 1
d36 2
a37 1
#include "xf86DDC.h"
d43 1
a48 1
static void SiS315Save(ScrnInfoPtr pScrn, SISRegPtr sisReg);
d51 1
a51 1
static void SiSLVDSChrontelSave(ScrnInfoPtr pScrn, SISRegPtr sisReg);
a52 1
static void SiS315Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg);
d55 2
a56 1
static void SiSLVDSChrontelRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg);
d59 8
d69 1
a69 11
static const unsigned short ch700xidx[] = {
      0x00,0x07,0x08,0x0a,0x0b,0x04,0x09,0x20,0x21,0x18,0x19,0x1a,
      0x1b,0x1c,0x1d,0x1e,0x1f,  /* 0x0e,  - TW: Don't save the power register */
      0x01,0x03,0x06,0x0d,0x11,0x13,0x14,0x15,0x17,0x22,0x23,0x24
   };

static const unsigned short ch701xidx[] = {
      0x1c,0x5f,0x64,0x6f,0x70,0x71,0x72,0x73,0x74,0x76,0x78,0x7d,
      0x67,0x68,0x69,0x6a,0x6b,0x1e,0x00,0x01,0x02,0x04,0x03,0x05,
      0x06,0x07,0x08,0x15,0x1f,0x0c,0x0d,0x0e,0x0f,0x10,0x66
   };  
d71 2
a72 1
int SiS_compute_vclk(
a117 1

d120 2
a121 2
    if((f > 250.0) || (f < 18.75))
       return 0;
d126 10
a135 10
    while(x > 31.25) {
       y *= 2.0;
       x /= 2.0;
    }
    if(x >= 18.25) {
       x *= 8.0;
       y = 8.0 / y;
    } else if(x >= 15.625) {
       x *= 12.0;
       y = 12.0 / y;
d139 3
a141 3
    if(t == (float) 1.5) {
       *out_div = 2;
       t *= 2.0;
d143 1
a143 1
       *out_div = 1;
d145 3
a147 3
    if(t > (float) 4.0) {
       *out_sbit = 1;
       t /= 2.0;
d149 1
a149 1
       *out_sbit = 0;
d154 12
a165 12
    for(dn = 2; dn <= 32; dn++) {
       for(n = 1; n <= 128; n++) {
          error = x;
          error -= ((float) 14.318 * (float) n / (float) dn);
          if(error < (float) 0)
             error = -error;
          if(error < min_error) {
             min_error = error;
             best_n = n;
             best_dn = dn;
          }
       }
d169 1
a169 1
    PDEBUG(ErrorF("SiS_compute_vclk: Clock=%d, n=%d, dn=%d, div=%d, sbit=%d,"
d182 1
a182 1
    double abest = 42.0;
a185 3
#ifdef DEBUG
    double bestFout;
#endif
d190 1
a190 1
     *  M       = Numerator [1:128]
d206 2
a207 2
#define MIN_VCO      Fref
#define MAX_VCO      135000000
d209 2
a210 2
#define MAX_PSN      0          /* no pre scaler for this chip */
#define TOLERANCE    0.01       /* search smallest M and N in this tolerance */
d212 1
a212 1
  int M_min = 2;
d214 3
a216 1

d218 1
d220 48
a267 43
  if(pSiS->Chipset == PCI_CHIP_SIS5597 || pSiS->Chipset == PCI_CHIP_SIS6326) {

     int low_N = 2;
     int high_N = 5;

     PSN = 1;
     P = 1;
     if(target < MAX_VCO_5597 / 2)  P = 2;
     if(target < MAX_VCO_5597 / 3)  P = 3;
     if(target < MAX_VCO_5597 / 4)  P = 4;
     if(target < MAX_VCO_5597 / 6)  P = 6;
     if(target < MAX_VCO_5597 / 8)  P = 8;

     Fvco = P * target;

     for(N = low_N; N <= high_N; N++) {

         double M_desired = Fvco / Fref * N;
         if(M_desired > M_max * max_VLD)  continue;

         if(M_desired > M_max) {
            M = M_desired / 2 + 0.5;
            VLD = 2;
         } else {
            M = Fvco / Fref * N + 0.5;
            VLD = 1;
         }

         Fout = (double)Fref * (M * VLD)/(N * P);

         error = (target - Fout) / target;
         aerror = (error < 0) ? -error : error;
         if(aerror < abest) {
            abest = aerror;
            bestM = M;
            bestN = N;
            bestP = P;
            bestPSN = PSN;
            bestVLD = VLD;
#ifdef DEBUG
            bestFout = Fout;
#endif	    
         }
d269 60
a328 55

  } else {

     for(PSNx = 0; PSNx <= MAX_PSN ; PSNx++) {

        int low_N, high_N;
        double FrefVLDPSN;

        PSN = !PSNx ? 1 : 4;

        low_N = 2;
        high_N = 32;

        for(VLD = 1 ; VLD <= max_VLD ; VLD++) {

           FrefVLDPSN = (double)Fref * VLD / PSN;

	   for(N = low_N; N <= high_N; N++) {
              double tmp = FrefVLDPSN / N;

              for(P = 1; P <= 4; P++) {
                 double Fvco_desired = target * ( P );
                 double M_desired = Fvco_desired / tmp;

                 /* Which way will M_desired be rounded?
                  *  Do all three just to be safe.
                  */
                 int M_low = M_desired - 1;
                 int M_hi = M_desired + 1;

                 if(M_hi < M_min || M_low > M_max) continue;

		 if(M_low < M_min)  M_low = M_min;

		 if(M_hi > M_max)   M_hi = M_max;

                 for(M = M_low; M <= M_hi; M++) {
                    Fvco = tmp * M;
                    if(Fvco <= MIN_VCO) continue;
                    if(Fvco > MAX_VCO)  break;

                    Fout = Fvco / ( P );

                    error = (target - Fout) / target;
                    aerror = (error < 0) ? -error : error;
                    if(aerror < abest) {
                       abest = aerror;
                       bestM = M;
                       bestN = N;
                       bestP = P;
                       bestPSN = PSN;
                       bestVLD = VLD;
#ifdef DEBUG
                       bestFout = Fout;
#endif
d330 3
a332 12
#ifdef TWDEBUG
                    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,3,
			       "Freq. selected: %.2f MHz, M=%d, N=%d, VLD=%d, P=%d, PSN=%d\n",
                               (float)(clock / 1000.), M, N, P, VLD, PSN);
                    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,3,
			       "Freq. set: %.2f MHz\n", Fout / 1.0e6);
#endif
                 }
              }
           }
        }
     }
d335 5
a339 5
  vclk[Midx]   = bestM;
  vclk[Nidx]   = bestN;
  vclk[VLDidx] = bestVLD;
  vclk[Pidx]   = bestP;
  vclk[PSNidx] = bestPSN;
d341 1
a341 1
  PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
d343 1
a343 1
                (float)(clock / 1000.), vclk[Midx], vclk[Nidx], vclk[VLDidx],
d345 1
a345 1
  PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
d347 1
a347 1
  PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
d356 1
d358 3
d362 2
a363 2
    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
             "SiSSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n"));
d365 1
a365 3
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d367 1
a367 1
    switch(pSiS->Chipset) {
d369 1
a369 1
           max=0x3C;
d373 1
a373 1
           max=0x3F; 
d380 5
a384 14
    /* Save extended SR registers */
    for(i = 0x00; i <= max; i++) {
       inSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "SR%02X - %02X \n", i,sisReg->sisRegs3C4[i]);
#endif
    }

#ifdef TWDEBUG
    for(i = 0x00; i <= 0x3f; i++) {
       inSISIDXREG(SISCR, i, max);
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "CR%02X - %02X \n", i,max);
a385 1
#endif
d387 2
a388 16
    /* Save lock (will not be restored in SiSRestore()!) */
    inSISIDXREG(SISCR, 0x80, sisReg->sisRegs3D4[0x80]);

    sisReg->sisRegs3C2 = inSISREG(SISMISCR);	 /* Misc */

    /* TW: Save TV registers */
    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
       outSISIDXREG(SISCR, 0x80, 0x86);
       for(i = 0x00; i <= 0x44; i++) {
          sisReg->sis6326tv[i] = SiS6326GetTVReg(pScrn, i);
#ifdef TWDEBUG
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "VR%02X - %02X \n", i,sisReg->sis6326tv[i]);
#endif
       }
    }
d395 1
a396 1
    unsigned char tmp;
d401 4
a404 3
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d406 1
a406 1
    switch(pSiS->Chipset) {
d408 1
a408 1
           max = 0x3C;
d411 4
a414 2
	case PCI_CHIP_SIS530:
           max = 0x3F;
d417 1
a417 1
           max = 0x37;
d421 4
a424 18
    /* Disable TV on 6326 before restoring */
    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
       outSISIDXREG(SISCR, 0x80, 0x86);
       tmp = SiS6326GetTVReg(pScrn, 0x00);
       tmp &= ~0x04;
       SiS6326SetTVReg(pScrn, 0x00, tmp);
    }

    /* Restore other extended SR registers */
    for(i = 0x06; i <= max; i++) {
       if((i == 0x13) || (i == 0x2a) || (i == 0x2b)) continue;
       outSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
    }

    /* Now restore VCLK (with correct SR38 setting) */
    outSISIDXREG(SISSR, 0x13, sisReg->sisRegs3C4[0x13]);
    outSISIDXREG(SISSR, 0x2a, sisReg->sisRegs3C4[0x2a]);
    outSISIDXREG(SISSR, 0x2b, sisReg->sisRegs3C4[0x2b]);
d426 1
a426 2
    /* Misc */
    outSISREG(SISMISCW, sisReg->sisRegs3C2);
d428 3
a430 27
    /* MemClock needs this to take effect */
    outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
    usleep(10000);
    outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */

    /* TW: Restore TV registers */
    pSiS->SiS6326Flags &= ~SIS6326_TVON;
    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
       for(i = 0x01; i <= 0x44; i++) {
          SiS6326SetTVReg(pScrn, i, sisReg->sis6326tv[i]);
#ifdef TWDEBUG
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	 	"VR%02x restored to %02x\n",
		i, sisReg->sis6326tv[i]);
#endif
       }
       tmp = SiS6326GetXXReg(pScrn, 0x13);
       SiS6326SetXXReg(pScrn, 0x13, 0xfa);
       tmp = SiS6326GetXXReg(pScrn, 0x14);
       SiS6326SetXXReg(pScrn, 0x14, 0xc8);
       if(!(sisReg->sisRegs3C4[0x0D] & 0x04)) {
    	  tmp = SiS6326GetXXReg(pScrn, 0x13);
	  SiS6326SetXXReg(pScrn, 0x13, 0xf6);
	  tmp = SiS6326GetXXReg(pScrn, 0x14);
	  SiS6326SetXXReg(pScrn, 0x14, 0xbf);
       }
       if(sisReg->sis6326tv[0] & 0x04) pSiS->SiS6326Flags |= SIS6326_TVON;
a431 1
}
d433 2
a434 6
/* Save SiS 300 series register contents */
static void
SiS300Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr pSiS = SISPTR(pScrn);
    int i;
d436 1
a436 2
    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
     		"SiS300Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n"));
d438 2
a439 12
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    /* Save SR registers */
    for(i = 0x00; i <= 0x3D; i++) {
       inSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "SR%02X - %02X \n", i,sisReg->sisRegs3C4[i]);
#endif
    }
a440 48
    /* Save CR registers */
    for(i = 0x00; i < 0x40; i++)  {
       inSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"CR%02X Contents - %02X \n", i,sisReg->sisRegs3D4[i]);
#endif
    }
    
    /* Save Misc register */
    sisReg->sisRegs3C2 = inSISREG(SISMISCR);	 
    
    /* Save FQBQ and GUI timer settings */
    if(pSiS->Chipset == PCI_CHIP_SIS630) {
       sisReg->sisRegsPCI50 = pciReadLong(0x00000000, 0x50);
       sisReg->sisRegsPCIA0 = pciReadLong(0x00000000, 0xA0);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       		"PCI Config 50 = %lx\n", sisReg->sisRegsPCI50);
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       		"PCI Config A0 = %lx\n", sisReg->sisRegsPCIA0);		
#endif       
    }

    /* Save panel link/video bridge registers */
#ifndef TWDEBUG
    if(!pSiS->UseVESA) {
#endif
       if(pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
          (*pSiS->SiSSaveLVDSChrontel)(pScrn, sisReg);
       if(pSiS->VBFlags & VB_301)
          (*pSiS->SiSSave2)(pScrn, sisReg);
       if(pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV))
          (*pSiS->SiSSave3)(pScrn, sisReg);
#ifndef TWDEBUG
    }
#endif

    /* Save Mode number */
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
    if(!(pSiS->UseVESA))
#endif
       pSiS->BIOSModeSave = SiS_GetSetModeID(pScrn,0xFF);
	
#ifdef TWDEBUG	
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
    	"BIOS mode ds:449 = 0x%x\n", pSiS->BIOSModeSave);
#endif	
a442 2

/* Restore SiS300 series register contents */
d444 1
a444 1
SiS300Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d447 5
a451 2
    int i,temp;
    CARD32 temp1;
d453 2
a454 2
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
                "SiS300Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n");
d456 1
a456 3
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d458 1
a458 7
    /* Wait for accelerator to finish on-going drawing operations. */
    inSISIDXREG(SISSR, 0x1E, temp);
    if(temp & (0x40|0x10|0x02))  {
       while ( (MMIO_IN16(pSiS->IOBase, 0x8242) & 0xE000) != 0xE000){};
       while ( (MMIO_IN16(pSiS->IOBase, 0x8242) & 0xE000) != 0xE000){};
       while ( (MMIO_IN16(pSiS->IOBase, 0x8242) & 0xE000) != 0xE000){};
    }
d460 5
a464 5
    if(!(pSiS->UseVESA)) {
       if(pSiS->VBFlags & VB_LVDS) {
          SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
          SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
       }
d467 4
a470 3
    /* Restore extended CR registers */
    for(i = 0x19; i < 0x40; i++)  {
       outSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
d473 2
a474 9
    if(pSiS->Chipset != PCI_CHIP_SIS300)  {
       unsigned char val;
       inSISIDXREG(SISCR, 0x1A, val);
       if(val == sisReg->sisRegs3D4[0x19])
	  outSISIDXREG(SISCR, 0x1A, sisReg->sisRegs3D4[0x19]);
       inSISIDXREG(SISCR,0x19,val);
       if(val == sisReg->sisRegs3D4[0x1A])
          outSISIDXREG(SISCR, 0x19, sisReg->sisRegs3D4[0x1A]);
    }
d476 8
a483 4
    /* Set (and leave) PCI_IO_ENABLE on if accelerators are on */
    if(sisReg->sisRegs3C4[0x1e] & 0x50) {
       sisReg->sisRegs3C4[0x20] |= 0x20;
       outSISIDXREG(SISSR, 0x20, sisReg->sisRegs3C4[0x20]);
d485 9
a493 86

    /* If TQ is switched on, don't switch it off ever again!
     * Therefore, always restore registers with TQ enabled.
     */
    if((!pSiS->NoAccel) && (pSiS->TurboQueue)) {
       temp = (pScrn->videoRam/64) - 8;
       sisReg->sisRegs3C4[0x26] = temp & 0xFF;
       sisReg->sisRegs3C4[0x27] = ((temp >> 8) & 3) | 0xF0;
    }

    /* Restore extended SR registers */
    for(i = 0x06; i <= 0x3D; i++) {
       temp = sisReg->sisRegs3C4[i];
       if(!(pSiS->UseVESA)) {
          if(pSiS->VBFlags & VB_LVDS) {
             if(i == 0x11) {
	        inSISIDXREG(SISSR,0x11,temp);
	    	temp &= 0x0c;
		temp |= (sisReg->sisRegs3C4[i] & 0xf3);
	     }
          }
       }
       outSISIDXREG(SISSR, i, temp);
    }

    /* Restore VCLK and ECLK */
    if(pSiS->VBFlags & (VB_LVDS | VB_301B | VB_301C)) {
       outSISIDXREG(SISSR,0x31,0x20);
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x80);
       outSISIDXREG(SISSR,0x31,0x10);
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x80);
    }
    outSISIDXREG(SISSR,0x31,0x00);
    outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
    outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
    outSISIDXREG(SISSR,0x2d,0x80);
    if(pSiS->VBFlags & (VB_LVDS | VB_301B | VB_301C)) {
       outSISIDXREG(SISSR,0x31,0x20);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
       outSISIDXREG(SISSR,0x31,0x10);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
       outSISIDXREG(SISSR,0x31,0x00);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
    }

    /* Restore Misc register */
    outSISREG(SISMISCW, sisReg->sisRegs3C2);

    /* Restore FQBQ and GUI timer settings */
    if(pSiS->Chipset == PCI_CHIP_SIS630) {
       temp1 = pciReadLong(0x00000000, 0x50);
       if(pciReadLong(0x00000000, 0x00) == 0x06301039) {
          temp1 &= 0xf0ffffff;
          temp1 |= (sisReg->sisRegsPCI50 & ~0xf0ffffff);
       } else {  /* 730 */
          temp1 &= 0xfffff9ff;
          temp1 |= (sisReg->sisRegsPCI50 & ~0xfffff9ff);
       }
       pciWriteLong(0x00000000, 0x50, temp1);

       temp1 = pciReadLong(0x00000000, 0xA0);
       if(pciReadLong(0x00000000, 0x00) == 0x06301039) {
          temp1 &= 0xf0ffffff;
          temp1 |= (sisReg->sisRegsPCIA0 & ~0xf0ffffff);
       } else {	/* 730 */
          temp1 &= 0x00ffffff;
          temp1 |= (sisReg->sisRegsPCIA0 & ~0x00ffffff);
       }
       pciWriteLong(0x00000000, 0xA0, temp1);
    }

    /* Restore panel link/video bridge registers */
    if(!(pSiS->UseVESA)) {
       if(pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
          (*pSiS->SiSRestoreLVDSChrontel)(pScrn, sisReg);
       if(pSiS->VBFlags & VB_301)
          (*pSiS->SiSRestore2)(pScrn, sisReg);
       if(pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV))
          (*pSiS->SiSRestore3)(pScrn, sisReg);
a494 8

    /* MemClock needs this to take effect */
    outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
    outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */

    /* Restore mode number */
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
    if(!(pSiS->UseVESA))
d496 3
a498 1
       SiS_GetSetModeID(pScrn,pSiS->BIOSModeSave);
a500 1
/* Save SiS315 series register contents */
d502 1
a502 1
SiS315Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d505 2
a506 1
    int i;
d508 2
a509 6
    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
    		"SiS315Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n"));

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d511 2
a512 8
    /* Save SR registers */
    for(i = 0x00; i <= 0x3F; i++) {
       inSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			 "SR%02X - %02X \n", i,sisReg->sisRegs3C4[i]);
#endif
    }
d514 1
a514 2
    /* Save command queue location */
    sisReg->sisMMIO85C0 = MMIO_IN32(pSiS->IOBase, 0x85C0);
d516 39
a554 7
    /* Save CR registers */
    for(i = 0x00; i <= 0x7a; i++)  {
       inSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"CR%02X Contents - %02X \n", i,sisReg->sisRegs3D4[i]);
#endif
d557 27
a583 7
    /* Save video capture registers */
    for(i = 0x00; i <= 0x4f; i++)  {
       inSISIDXREG(SISCAP, i, sisReg->sisCapt[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"Capt%02X Contents - %02X \n", i,sisReg->sisCapt[i]);
#endif
a584 7

    /* Save video playback registers */
    for(i = 0x00; i <= 0x3f; i++)  {
       inSISIDXREG(SISVID, i, sisReg->sisVid[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"Vid%02X Contents - %02X \n", i,sisReg->sisVid[i]);
a585 1
    }
d587 2
a588 2
    /* Save Misc register */
    sisReg->sisRegs3C2 = inSISREG(SISMISCR);
d590 3
a592 13
    /* Save panel link/video bridge registers */
#ifndef TWDEBUG
    if(!pSiS->UseVESA) {
#endif
       if(pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
          (*pSiS->SiSSaveLVDSChrontel)(pScrn, sisReg);
       if(pSiS->VBFlags & VB_301)
          (*pSiS->SiSSave2)(pScrn, sisReg);
       if(pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV))
          (*pSiS->SiSSave3)(pScrn, sisReg);
#ifndef TWDEBUG
    }
#endif
d594 2
a595 5
    /* Save mode number */
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
    if(!(pSiS->UseVESA))
#endif
       pSiS->BIOSModeSave = SiS_GetSetModeID(pScrn,0xFF);
a596 4
#ifdef TWDEBUG
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
    	"BIOS mode ds:449 = 0x%x\n", pSiS->BIOSModeSave);
#endif
a598 1
/* Restore SiS315/330 series register contents */
d600 1
a600 1
SiS315Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d602 2
a603 2
    SISPtr pSiS = SISPTR(pScrn);
    int i,temp;
d605 6
a610 13
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
                "SiS315Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n");

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    /* Wait for accelerator to finish on-going drawing operations. */
    inSISIDXREG(SISSR, 0x1E, temp);
    if(temp & (0x40|0x10|0x02))  {	/* 0x40 = 2D, 0x10 = 3D enabled*/
       while ( (MMIO_IN32(pSiS->IOBase, 0x85CC) & 0x80000000) != 0x80000000){};
       while ( (MMIO_IN32(pSiS->IOBase, 0x85CC) & 0x80000000) != 0x80000000){};
       while ( (MMIO_IN32(pSiS->IOBase, 0x85CC) & 0x80000000) != 0x80000000){};
d612 2
a613 61

    /* We reset the command queue before restoring.
     * This might be required because we never know what
     * console driver (like the kernel framebuffer driver)
     * or application is running and which queue mode it
     * uses.
     */
    outSISIDXREG(SISSR, 0x27, 0x1F);
    outSISIDXREG(SISSR, 0x26, 0x01);

    /* Restore extended CR registers */
    for(i = 0x19; i < 0x5C; i++)  {
       outSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
    }
    if(pSiS->sishw_ext.jChipType < SIS_661) {
       outSISIDXREG(SISCR, 0x79, sisReg->sisRegs3D4[0x79]);
    }
    outSISIDXREG(SISCR, pSiS->myCR63, sisReg->sisRegs3D4[pSiS->myCR63]);

    /* Leave PCI_IO_ENABLE on if accelerators are on (Is this required?) */
    if(sisReg->sisRegs3C4[0x1e] & 0x50) {  /*0x40=2D, 0x10=3D*/
       sisReg->sisRegs3C4[0x20] |= 0x20;
       outSISIDXREG(SISSR, 0x20, sisReg->sisRegs3C4[0x20]);
    }

    /* Restore extended SR registers */
    if(pSiS->sishw_ext.jChipType >= SIS_661) {
       sisReg->sisRegs3C4[0x11] &= 0x0f;
    }
    for(i = 0x06; i <= 0x3F; i++) {
       outSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
    }
    /* Restore VCLK and ECLK */
    andSISIDXREG(SISSR,0x31,0xcf);
    if(pSiS->VBFlags & VB_LVDS) {
       orSISIDXREG(SISSR,0x31,0x20);
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x80);
       andSISIDXREG(SISSR,0x31,0xcf);
       orSISIDXREG(SISSR,0x31,0x10);
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x80);
       andSISIDXREG(SISSR,0x31,0xcf);
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x01);
       outSISIDXREG(SISSR,0x31,0x20);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
       outSISIDXREG(SISSR,0x31,0x10);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
       outSISIDXREG(SISSR,0x31,0x00);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
    } else {
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x01);
d615 2
a616 19

#ifndef SISVRAMQ
    /* Initialize read/write pointer for command queue */
    MMIO_OUT32(pSiS->IOBase, 0x85C4, MMIO_IN32(pSiS->IOBase, 0x85C8));
#endif
    /* Restore queue location */
    MMIO_OUT32(pSiS->IOBase, 0x85C0, sisReg->sisMMIO85C0);

    /* Restore Misc register */
    outSISREG(SISMISCW, sisReg->sisRegs3C2);   

    /* Restore panel link/video bridge registers */
    if(!(pSiS->UseVESA)) {
       if(pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
          (*pSiS->SiSRestoreLVDSChrontel)(pScrn, sisReg);
       if(pSiS->VBFlags & VB_301)
          (*pSiS->SiSRestore2)(pScrn, sisReg);
       if(pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV))
          (*pSiS->SiSRestore3)(pScrn, sisReg);
d618 2
a619 10

    /* MemClock needs this to take effect */
    outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
    outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */

    /* Restore Mode number */
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
    if(!(pSiS->UseVESA))
#endif
       SiS_GetSetModeID(pScrn,pSiS->BIOSModeSave);
d623 1
a623 1
SiSVBSave(ScrnInfoPtr pScrn, SISRegPtr sisReg, int p1, int p2, int p3, int p4)
d628 3
a630 5
    for(i=0; i<=p1; i++)  {
       inSISIDXREG(SISPART1, i, sisReg->VBPart1[i]);
#ifdef TWDEBUG
       xf86DrvMsg(0, X_INFO, "301xSave: Part1Port 0x%02x = 0x%02x\n", i, sisReg->VBPart1[i]);
#endif
d632 2
a633 5
    for(i=0; i<=p2; i++)  {
       inSISIDXREG(SISPART2, i, sisReg->VBPart2[i]);
#ifdef TWDEBUG
       xf86DrvMsg(0, X_INFO, "301xSave: Part2Port 0x%02x = 0x%02x\n", i, sisReg->VBPart2[i]);
#endif
d635 2
a636 5
    for(i=0; i<=p3; i++)  {
       inSISIDXREG(SISPART3, i, sisReg->VBPart3[i]);
#ifdef TWDEBUG
       xf86DrvMsg(0, X_INFO, "301xSave: Part3Port 0x%02x = 0x%02x\n", i, sisReg->VBPart3[i]);
#endif
d638 2
a639 5
    for(i=0; i<=p4; i++)  {
       inSISIDXREG(SISPART4, i, sisReg->VBPart4[i]);
#ifdef TWDEBUG
       xf86DrvMsg(0, X_INFO, "301xSave: Part4Port 0x%02x = 0x%02x\n", i, sisReg->VBPart4[i]);
#endif
d641 2
a644 1
/* Save SiS301 bridge register contents */
d646 1
a646 1
SiS301Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d649 1
a649 1
    int     Part1max, Part2max, Part3max, Part4max;
d651 5
a655 12
    /* Highest register number to save/restore */
    if(pSiS->VGAEngine == SIS_300_VGA) Part1max = 0x1d;
    else Part1max = 0x2e;  /* 0x23, but we also need 2d-2e */

    Part2max = 0x45;
    Part3max = 0x3e;
    Part4max = 0x1b;

    SiSVBSave(pScrn, sisReg, Part1max, Part2max, Part3max, Part4max);

    sisReg->VBPart2[0x00] &= ~0x20;      /* Disable VB Processor */
    sisReg->sisRegs3C4[0x32] &= ~0x20;   /* Disable Lock Mode */
a657 1
/* Restore SiS301 bridge register contents */
d659 1
a659 1
SiS301Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d662 1
a662 5
    int     Part1max, Part2max, Part3max, Part4max;

    /* Highest register number to save/restore */
    if(pSiS->VGAEngine == SIS_300_VGA) Part1max = 0x1d;
    else Part1max = 0x23;
d664 3
a666 23
    Part2max = 0x45;
    Part3max = 0x3e;
    Part4max = 0x1b;

    SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);

    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);

    /* Pre-restore Part1 */
    outSISIDXREG(SISPART1, 0x04, 0x00);
    outSISIDXREG(SISPART1, 0x05, 0x00);
    outSISIDXREG(SISPART1, 0x06, 0x00);
    outSISIDXREG(SISPART1, 0x00, sisReg->VBPart1[0]);
    outSISIDXREG(SISPART1, 0x01, sisReg->VBPart1[1]);

    /* Pre-restore Part4 */
    outSISIDXREG(SISPART4, 0x0D, sisReg->VBPart4[0x0D]);
    outSISIDXREG(SISPART4, 0x0C, sisReg->VBPart4[0x0C]);

    if((!(sisReg->sisRegs3D4[0x30] & 0x03)) &&
       (sisReg->sisRegs3D4[0x31] & 0x20))  {      /* disable CRT2 */
       SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
       return;
d668 2
d671 1
a671 27
    /* Restore Part1 */
    SetBlock(SISPART1, 0x02, Part1max, &(sisReg->VBPart1[0x02]));
    if(pSiS->VGAEngine == SIS_315_VGA) {
       /* Restore extra registers on 315 series */
       SetBlock(SISPART1, 0x2C, 0x2E, &(sisReg->VBPart1[0x2C]));
    }

    /* Restore Part2 */
    SetBlock(SISPART2, 0x00, Part2max, &(sisReg->VBPart2[0x00]));

    /* Restore Part3 */
    SetBlock(SISPART3, 0x00, Part3max, &(sisReg->VBPart3[0x00]));

    /* Restore Part4 */
    SetBlock(SISPART4, 0x0E, 0x11, &(sisReg->VBPart4[0x0E]));
    SetBlock(SISPART4, 0x13, Part4max, &(sisReg->VBPart4[0x13]));

    /* Post-restore Part4 (CRT2VCLK) */
    outSISIDXREG(SISPART4, 0x0A, 0x01);
    outSISIDXREG(SISPART4, 0x0B, sisReg->VBPart4[0x0B]);
    outSISIDXREG(SISPART4, 0x0A, sisReg->VBPart4[0x0A]);
    outSISIDXREG(SISPART4, 0x12, 0x00);
    outSISIDXREG(SISPART4, 0x12, sisReg->VBPart4[0x12]);

    SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
    SiS_DisplayOn(pSiS->SiS_Pr);
    SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
a673 1
/* Save SiS30xB/30xLV bridge register contents */
d675 1
a675 1
SiS301BSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d678 4
a681 1
    int     Part1max, Part2max, Part3max, Part4max;
d683 35
a717 10
    Part1max = 0x4c;
    Part2max = 0x4d;
    Part3max = 0x3e;
    Part4max = 0x23;
    if(pSiS->VBFlags & (VB_301C|VB_302ELV)) {
       Part2max = 0xff;
       Part4max = 0x3c;
    }
    if(pSiS->VBFlags & (VB_301LV|VB_302LV)) {
       Part4max = 0x34;
d719 3
d723 2
a724 4
    SiSVBSave(pScrn, sisReg, Part1max, Part2max, Part3max, Part4max);

    sisReg->VBPart2[0x00] &= ~0x20;      /* Disable VB Processor */
    sisReg->sisRegs3C4[0x32] &= ~0x20;   /* Disable Lock Mode */
d727 1
a727 1
/* Restore SiS30xB/30xLV bridge register contents */
d732 1
a732 1
    int     Part1max, Part2max, Part3max, Part4max;
d734 2
a735 11
    Part1max = 0x23;
    Part2max = 0x4d;
    Part3max = 0x3e;
    Part4max = 0x22;
    if(pSiS->VBFlags & (VB_301C|VB_302ELV)) {
       Part2max = 0xff;
       Part4max = 0x3c;
    }
    if(pSiS->VBFlags & (VB_301LV|VB_302LV)) {
       Part4max = 0x34;
    }
d737 39
a775 41
    SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);

    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);

    /* Pre-restore Part1 */
    outSISIDXREG(SISPART1, 0x04, 0x00);
    outSISIDXREG(SISPART1, 0x05, 0x00);
    outSISIDXREG(SISPART1, 0x06, 0x00);
    outSISIDXREG(SISPART1, 0x00, sisReg->VBPart1[0x00]);
    outSISIDXREG(SISPART1, 0x01, sisReg->VBPart1[0x01]);
    /* Mode reg 0x01 became 0x2e on 315 series (0x01 still contains FIFO) */
    if(pSiS->VGAEngine == SIS_315_VGA) {
       outSISIDXREG(SISPART1, 0x2e, sisReg->VBPart1[0x2e]);
    }

    /* Pre-restore Part4 */
    outSISIDXREG(SISPART4, 0x0D, sisReg->VBPart4[0x0D]);
    outSISIDXREG(SISPART4, 0x0C, sisReg->VBPart4[0x0C]);

    if((!(sisReg->sisRegs3D4[0x30] & 0x03)) &&
       (sisReg->sisRegs3D4[0x31] & 0x20))  {      /* disable CRT2 */
       SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
       return;
    }

    /* Restore Part1  */
    SetBlock(SISPART1, 0x02, Part1max, &(sisReg->VBPart1[0x02]));
    if(pSiS->VGAEngine == SIS_315_VGA) {
       SetBlock(SISPART1, 0x2C, 0x2D, &(sisReg->VBPart1[0x2C]));
       SetBlock(SISPART1, 0x35, 0x37, &(sisReg->VBPart1[0x35]));
    }

    /* Restore Part2 */
    SetBlock(SISPART2, 0x00, Part2max, &(sisReg->VBPart2[0x00]));

    /* Restore Part3 */
    SetBlock(SISPART3, 0x00, Part3max, &(sisReg->VBPart3[0x00]));

    /* Restore Part4 */
    SetBlock(SISPART4, 0x0E, 0x11, &(sisReg->VBPart4[0x0E]));
    SetBlock(SISPART4, 0x13, Part4max, &(sisReg->VBPart4[0x13]));
d777 2
a778 9
    /* Post-restore Part4 (CRT2VCLK) */
    outSISIDXREG(SISPART4, 0x0A, sisReg->VBPart4[0x0A]);
    outSISIDXREG(SISPART4, 0x0B, sisReg->VBPart4[0x0B]);
    outSISIDXREG(SISPART4, 0x12, 0x00);
    outSISIDXREG(SISPART4, 0x12, sisReg->VBPart4[0x12]);

    SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
    SiS_DisplayOn(pSiS->SiS_Pr);
    SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
a780 1
/* Save LVDS bridge (+ Chrontel) register contents */
d782 1
a782 1
SiSLVDSChrontelSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d784 4
a787 2
    SISPtr  pSiS = SISPTR(pScrn);
    int     i;
d789 13
a801 9
    /* Save Part1 */
    for(i=0; i<0x46; i++)  {
       inSISIDXREG(SISPART1, i, sisReg->VBPart1[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	                "LVDSSave: Part1Port 0x%02x = 0x%02x\n",
			i, sisReg->VBPart1[i]);
#endif
    }
d803 2
a804 22
    /* Save Chrontel registers */
    if(pSiS->VBFlags & VB_CHRONTEL) {
       if(pSiS->ChrontelType == CHRONTEL_700x) {
          for(i=0; i<0x1D; i++)  {
             sisReg->ch70xx[i] = SiS_GetCH700x(pSiS->SiS_Pr, ch700xidx[i]);
#ifdef TWDEBUG
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	                "LVDSSave: Chrontel 0x%02x = 0x%02x\n",
			ch700xidx[i], sisReg->ch70xx[i]);
#endif
	  }
       } else {
          for(i=0; i<35; i++)  {
             sisReg->ch70xx[i] = SiS_GetCH701x(pSiS->SiS_Pr, ch701xidx[i]);
#ifdef TWDEBUG
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	                "LVDSSave: Chrontel 0x%02x = 0x%02x\n",
			ch701xidx[i], sisReg->ch70xx[i]);
#endif
          }
       }
    }
d806 2
a807 1
    sisReg->sisRegs3C4[0x32] &= ~0x20;      /* Disable Lock Mode */
a809 1
/* Restore LVDS bridge (+ Chrontel) register contents */
d811 1
a811 1
SiSLVDSChrontelRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d813 3
a815 3
    SISPtr  pSiS = SISPTR(pScrn);
    int i;
    USHORT wtemp;
d817 2
a818 32
    SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
    if(pSiS->sishw_ext.jChipType == SIS_730) {
       outSISIDXREG(SISPART1, 0x00, 0x80);
    }

    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);

    if(pSiS->VBFlags & VB_CHRONTEL) {
       /* Restore Chrontel registers */
       if(pSiS->ChrontelType == CHRONTEL_700x) {
          for(i=0; i<0x11; i++) {
             wtemp = ((sisReg->ch70xx[i]) << 8) | (ch700xidx[i] & 0x00FF);
             SiS_SetCH700x(pSiS->SiS_Pr, wtemp);
          }
       } else {
          for(i=0; i<34; i++) {
             wtemp = ((sisReg->ch70xx[i]) << 8) | (ch701xidx[i] & 0x00FF);
             SiS_SetCH701x(pSiS->SiS_Pr, wtemp);
          }
       }
    }

    /* pre-restore Part1 */
    outSISIDXREG(SISPART1, 0x04, 0x00);
    outSISIDXREG(SISPART1, 0x05, 0x00);
    outSISIDXREG(SISPART1, 0x06, 0x00);
    outSISIDXREG(SISPART1, 0x00, sisReg->VBPart1[0]);
    if(pSiS->VGAEngine == SIS_300_VGA) {
       outSISIDXREG(SISPART1, 0x01, (sisReg->VBPart1[1] | 0x80));
    } else {
       outSISIDXREG(SISPART1, 0x01, sisReg->VBPart1[1]);
    }
d820 4
a823 5
    if((!(sisReg->sisRegs3D4[0x30] & 0x03)) &&
       (sisReg->sisRegs3D4[0x31] & 0x20))  {      /* disable CRT2 */
       SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
       return;
    }
d825 13
a837 11
    /* Restore Part1 */
    if(pSiS->VGAEngine == SIS_300_VGA) {
       outSISIDXREG(SISPART1, 0x02, (sisReg->VBPart1[2] | 0x40));
    } else {
       outSISIDXREG(SISPART1, 0x02, sisReg->VBPart1[2]);
    }
    SetBlock(SISPART1, 0x03, 0x23, &(sisReg->VBPart1[0x03]));
    if(pSiS->VGAEngine == SIS_315_VGA) {
       SetBlock(SISPART1, 0x2C, 0x2E, &(sisReg->VBPart1[0x2C]));
       SetBlock(SISPART1, 0x35, 0x37, &(sisReg->VBPart1[0x35]));  /* Panel Link Scaler */
    }
d839 2
a840 5
    /* For 550 DSTN registers */
    if(pSiS->DSTN || pSiS->FSTN) {
       SetBlock(SISPART1, 0x25, 0x2E, &(sisReg->VBPart1[0x25]));
       SetBlock(SISPART1, 0x30, 0x45, &(sisReg->VBPart1[0x30]));
    }
d842 2
a843 3
    SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
    SiS_DisplayOn(pSiS->SiS_Pr);
    SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
d846 1
a846 1
/* Restore output selection registers */
a850 1
   int i;
d852 1
a852 3
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d854 4
a857 11
   for(i = 0x30; i <= 0x3b; i++) {
      if(i == 0x34) continue;
      outSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
   }

   if(pSiS->VGAEngine == SIS_315_VGA) {
      outSISIDXREG(SISCR, pSiS->myCR63, sisReg->sisRegs3D4[pSiS->myCR63]);
      if(pSiS->sishw_ext.jChipType < SIS_661) {
         outSISIDXREG(SISCR, 0x79, sisReg->sisRegs3D4[0x79]);
      }
   }
d860 3
a862 8
#if 0  /* The following function should take a threshold value
        * from predefined tables. This is only needed on some
	* 530 boards, which have an ESS sound device on-board.
	* However, I don't know how to calculate the index to
	* be submitted to this function.
	*/
unsigned short
SiS_CalcSpecial530Threshold(ScrnInfoPtr pScrn, DisplayModePtr mode, int index)
d864 20
a883 43
    SISPtr  pSiS = SISPTR(pScrn);
    static const unsigned char t640x480[3][24] = {
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,A9,   /* b4 - 9d - depth 8 */
	  0, 0,11,14,14, 0, 0, 0, 0, 0, 0,9D },
	{ 0, 0, 0, 0, 0,12,15, 0, 0, 0,92,91,   /* 9c - 85 - depth 16 */
	  0,31,31,31,31, 0, 0, 0, 0, 0, 0,85 },
	{ 0, 0, 0, 0, 0,17,22,25, 0, 0, 0,79,   /* 84 - ?  - depth 32 */
	  0,31,31, 0, 0, 0, 0, 0, 0, 0, 0,6d }
    }
    static const unsigned char t800x600[3][24] = {
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,61,
	  0,18,25,30,27,31,31,31, 0, 0, 0, 0 },
	{55, 0, 0, 0, 0, 9,10,15,18,19, 0, 0,
	... to be continued

    depthindex = (pSiS->CurrentLayout.bitsPerPixel + 1) >> 3;
    if(depthindex == 3) return(0);
    if(depthindex == 4) depthindex--;
    depthindex--;

    switch(mode->HDisplay) {
    case 640:
       if(mode->VDisplay == 480) {
          return(t640x480[depthindex][index];
       } else return(0);
    case 800:
       if(mode->VDisplay == 600) {
          return(t800x600[depthindex][index];
       } else return(0);
    case 1024:
       if(mode->VDisplay == 768) {
          return(t1024x768[depthindex][index];
       } else return(0);
    case 1280:
       if(mode->VDisplay == 1024) {
          return(t1280x1024[depthindex][index];
       } else return(0);
    case 1600:
       if(mode->VDisplay == 1200) {
          return(t1600x1200[depthindex][index];
       } else return(0);
    default: return(0);
    }
a884 1
#endif
a886 1
/* Not for 530/620 if UMA (on these, the mclk is stored in SR10) */
d890 2
a891 2
    int mclk;
    unsigned char Num, Denum, Base;
d893 1
d895 23
d919 9
a930 7
    case PCI_CHIP_SIS550:
    case PCI_CHIP_SIS650:
    case PCI_CHIP_SIS315:
    case PCI_CHIP_SIS315H:
    case PCI_CHIP_SIS315PRO:
    case PCI_CHIP_SIS330:
    case PCI_CHIP_SIS660:
d932 2
a933 2
	inSISIDXREG(SISSR, 0x28, Num);
        mclk = 14318 * ((Num & 0x7f) + 1);
d936 2
a937 2
	inSISIDXREG(SISSR, 0x29, Denum);
        mclk = mclk / ((Denum & 0x1f) + 1);
d940 3
a942 1
        if((Num & 0x80) != 0)  mclk *= 2;
d945 5
a949 4
        if((Denum & 0x80) == 0) {
           mclk = mclk / (((Denum & 0x60) >> 5) + 1);
        } else {
           mclk = mclk / ((((Denum & 0x60) >> 5) + 1) * 2);
a951 4

    case PCI_CHIP_SIS5597:
    case PCI_CHIP_SIS6326:
    case PCI_CHIP_SIS530:
d953 1
a953 23
        /* Numerator */
        inSISIDXREG(SISSR, 0x28, Num);
        mclk = 14318 * ((Num & 0x7f) + 1);

        /* Denumerator */
	inSISIDXREG(SISSR, 0x29, Denum);
        mclk = mclk / ((Denum & 0x1f) + 1);

        /* Divider. Doesn't work on older cards */
	if(pSiS->oldChipset >= OC_SIS5597) {
           if(Num & 0x80) mclk *= 2;
	}

        /* Post-scaler. Values' meaning depends on SR13 bit 7  */
	inSISIDXREG(SISSR, 0x13, Base);
        if((Base & 0x80) == 0) {
           mclk = mclk / (((Denum & 0x60) >> 5) + 1);
        } else {
           /* Values 00 and 01 are reserved */
           if ((Denum & 0x60) == 0x40)  mclk /= 6;
           if ((Denum & 0x60) == 0x60)  mclk /= 8;
        }
        break;
d959 2
a960 13
/* This estimates the CRT2 clock we are going to use.
 * The total bandwidth is to be reduced by the value
 * returned here in order to get an idea of the maximum
 * dotclock left for CRT1.
 * Since we don't know yet, what mode the user chose,
 * we return the maximum dotclock used by
 * - either the LCD attached, or
 * - TV
 * For VGA2, we share the bandwith equally.
 */
static int
SiSEstimateCRT2Clock(ScrnInfoPtr pScrn, BOOLEAN IsForMergedFBCRT2)
{
d962 1
a962 47

	if(pSiS->VBFlags & CRT2_LCD) {
  	   if(pSiS->VBLCDFlags & (VB_LCD_320x480 | VB_LCD_800x600 | VB_LCD_640x480))
	      return 40000;
	   else if(pSiS->VBLCDFlags & (VB_LCD_1024x768 | VB_LCD_1024x600 | VB_LCD_1152x768))
	      return 65000;
	   else if(pSiS->VBLCDFlags & VB_LCD_1280x768)
	      return 81000;
	   else if(pSiS->VBLCDFlags & VB_LCD_1400x1050) {
	      /* Must fake clock; built-in mode shows 122 for VGA, but uses only 108 for LCD */
	      if(IsForMergedFBCRT2) return 123000;
	      else                  return 108000;
	   } else if(pSiS->VBLCDFlags & (VB_LCD_1280x1024 | VB_LCD_1280x960))
	      return 108000;
	   else if(pSiS->VBLCDFlags & VB_LCD_1600x1200)
	      return 162000;
	   else if((pSiS->VBLCDFlags & VB_LCD_CUSTOM) && (pSiS->SiS_Pr->CP_HaveCustomData))
	      return pSiS->SiS_Pr->CP_MaxClock;
	   else
	      return 108000;
	} else if(pSiS->VBFlags & CRT2_TV) {
	   if(pSiS->VBFlags & VB_CHRONTEL) {
	      switch(pSiS->VGAEngine) {
	      case SIS_300_VGA:
                 return 50000;
	      case SIS_315_VGA:
	      default:
		 return 70000;
	      }
	   } else if(pSiS->VBFlags & VB_SISBRIDGE) {
	      if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPR)
	         return 75000;
	      else
	         return 70000;
	   }
	}

	return 0;
}

/* Calculate the maximum dotclock */
int SiSMemBandWidth(ScrnInfoPtr pScrn, BOOLEAN IsForCRT2)
{
        SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
        SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
d966 3
a968 8
        int             bpp = pSiS->CurrentLayout.bitsPerPixel;
	int             bytesperpixel = (bpp + 7) / 8;
        float   	magic=0.0, total, crt2used, maxcrt2;
	int		crt2clock, max=0;
#ifdef __SUNPRO_C
#define const
#endif
        const float     magic300[4] = { 1.2,      1.368421, 2.263158, 1.2};
a969 8
	const float     magic315[4] = { 1.2,      1.368421, 1.368421, 1.2 };
	const float     magic550[4] = { 1.441177, 1.441177, 2.588235, 1.441177 };
#ifdef __SUNPRO_C
#undef const
#endif
	BOOLEAN	        DHM, GetForCRT1;

        switch(pSiS->Chipset) {
d971 4
d976 7
a982 22
	        total = ((mclk * (bus / 8)) * 0.7) / bytesperpixel;
		if(total > 135000) total = 135000;
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			"Maximum pixel clock at %d bpp is %g MHz\n",
			bpp, total/1000);
                return(int)(total);

        case PCI_CHIP_SIS6326:
		total = ((mclk * (bus / 8)) * 0.7) / bytesperpixel;
		if(total > 175500) total = 175500;
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			"Maximum pixel clock at %d bpp is %g MHz\n",
			bpp, total/1000);
		return(int)(total);

        case PCI_CHIP_SIS530:
	        total = ((mclk * (bus / 8)) * 0.7) / bytesperpixel;
		if(total > 230000) total = 230000;
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			"Maximum pixel clock at %d bpp is %g MHz\n",
			bpp, total/1000);
		return(int)(total);
d987 5
a991 42
	case PCI_CHIP_SIS315:
	case PCI_CHIP_SIS315H:
	case PCI_CHIP_SIS315PRO:
	case PCI_CHIP_SIS550:
	case PCI_CHIP_SIS650:
	case PCI_CHIP_SIS330:
	case PCI_CHIP_SIS660:
	        switch(pSiS->Chipset) {
        	case PCI_CHIP_SIS300:
	            magic = magic300[bus/64];
		    max = 540000;
                    break;
        	case PCI_CHIP_SIS540:
       	 	case PCI_CHIP_SIS630:
		    magic = magic630[bus/64];
		    max = 540000;
                    break;
		case PCI_CHIP_SIS315:
		case PCI_CHIP_SIS315H:
		case PCI_CHIP_SIS315PRO:
		case PCI_CHIP_SIS330:
		    magic = magic315[bus/64];
		    max = 780000;
		    break;
		case PCI_CHIP_SIS550:
		    magic = magic550[bus/64];
		    max = 620000;
		    break;
		case PCI_CHIP_SIS650:
		    magic = magic550[bus/64];
		    max = 680000;
		    break;
		case PCI_CHIP_SIS660:
		    if((pSiS->sishw_ext.jChipType >= SIS_660) &&
		       (!(pSiS->ChipFlags & SiSCF_760UMA))) {
		       magic = magic315[bus/64];
		    } else {
		       magic = magic550[bus/64];
		    }
		    max = 680000;
                }

d994 13
d1008 6
a1013 1
                total = mclk * bus / bpp;
d1015 6
a1020 119
                xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			"Memory bandwidth at %d bpp is %g MHz\n", bpp, total/1000);

                if((pSiS->VBFlags & CRT2_ENABLE) && (!pSiS->CRT1off)) {

		    maxcrt2 = 135000;
		    if(pSiS->VBFlags & (VB_301B|VB_302B)) maxcrt2 = 162000;
		    else if(pSiS->VBFlags & VB_301C)      maxcrt2 = 203000;
		    /* if(pSiS->VBFlags & VB_30xBDH)      maxcrt2 = 100000;
		       Ignore 301B-DH here; seems the current version is like
		       301B anyway */

		    crt2used = 0.0;
		    crt2clock = SiSEstimateCRT2Clock(pScrn, IsForCRT2);
		    if(crt2clock) {
		    	crt2used = crt2clock + 2000;
		    }
		    DHM = FALSE;
		    GetForCRT1 = FALSE;

#ifdef SISDUALHEAD
		    if((pSiS->DualHeadMode) && (pSiSEnt)) {
		       DHM = TRUE;
		       if(pSiS->SecondHead) GetForCRT1 = TRUE;
		    }
#endif
#ifdef SISMERGED
		    if(pSiS->MergedFB && IsForCRT2) {
		       DHM = TRUE;
		       GetForCRT1 = FALSE;
		    }
#endif

		    if(DHM) {

		        if(!GetForCRT1) {

			     /* TW: First head = CRT2 */

			     if(crt2clock) {
			        /* TW: We use the mem bandwidth as max clock; this
				 *     might exceed the 70% limit a bit, but that
				 *     does not matter; we take care of that limit
				 *     when we calc CRT1. Overall, we might use up
				 *     to 85% of the memory bandwidth, which seems
				 *     enough to use accel and video.
				 *     The "* macic" is just to compensate the
				 *     calculation below.
				*/
			        total = crt2used * magic;
				
			     } else {
			        /*  We don't know about the second head's
				 *  depth yet. So we assume it uses the
			         *  same. But since the maximum dotclock
				 *  is limited on CRT2, we can assume a
				 *  maximum here.
			         */
                                if((total / 2) > (maxcrt2 + 2000)) {
				    total = (maxcrt2 + 2000) * magic;
				    crt2used = maxcrt2 + 2000;
				} else {
				    total /= 2;
				    crt2used = total;
				}
				
                             }
			     
			     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	           "Bandwidth reserved for CRT2 is %g Mhz\n",
				      crt2used/1000);

			} else {
#ifdef SISDUALHEAD
			     /* TW: Second head = CRT1 */

			     /*     Now We know about the first head's depth,
			      *     so we can calculate more accurately.
			      */

			     if(crt2clock) {
			        total -= (crt2used * pSiSEnt->pScrn_1->bitsPerPixel / bpp);
				xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	           "Bandwidth reserved for CRT2 at %d bpp is %g Mhz\n",
				      bpp,
				      (crt2used * pSiSEnt->pScrn_1->bitsPerPixel / bpp)/1000);
			     } else {
			        total -= (pSiSEnt->maxUsedClock * pSiSEnt->pScrn_1->bitsPerPixel / bpp);
				xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	           "Bandwidth reserved for CRT2 at %d bpp is %d Mhz\n",
				      bpp,
				      (pSiSEnt->maxUsedClock * pSiSEnt->pScrn_1->bitsPerPixel / bpp)/1000);
			     }

			     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			        "Bandwidth available for CRT1 is %g MHz\n", total/1000);
#endif
			}

		    } else {

			if(crt2clock) {
			    total -= crt2used;
			} else {
                            if((total / 2) > (maxcrt2 + 2000)) {
			    	total -= (maxcrt2 + 2000);
				crt2used = maxcrt2 + 2000;
			    } else {  
			    	total /= 2;
				crt2used = total;
			    }		   
			}
			xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	  "Bandwidth reserved for CRT2 is %g Mhz\n", crt2used/1000);

			xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			  "Bandwidth available for CRT1 is %g MHz\n", total/1000);

                    }
d1022 21
d1044 1
a1044 6
		total /= magic;
		if(total > (max / 2)) total = max / 2;
                return(int)(total);

        default:
                return(135000);
d1048 3
a1050 11
/* Load the palette. We do this for all supported color depths
 * in order to support gamma correction. We hereby convert the
 * given colormap to a complete 24bit color palette and enable
 * the correspoding bit in SR7 to enable the 24bit lookup table.
 * Gamma correction is only supported on CRT1.
 * Why are there 6-bit-RGB values submitted even if bpp is 16 and
 * weight is 565? (Maybe because rgbBits is 6?)
 */
void
SISLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices, LOCO *colors,
               VisualPtr pVisual)
d1052 12
a1063 7
     SISPtr  pSiS = SISPTR(pScrn);
     int     i, j, index;
     unsigned char backup = 0;
     Bool    dogamma1 = pSiS->CRT1gamma;
     Bool    resetxvgamma = FALSE;
#ifdef SISDUALHEAD
     SISEntPtr pSiSEnt = pSiS->entityPrivate;
a1064 2
     if(pSiS->DualHeadMode) dogamma1 = pSiSEnt->CRT1gamma;
#endif
d1066 16
a1081 1
     PDEBUG(ErrorF("SiSLoadPalette(%d)\n", numColors));
d1083 79
a1161 3
#ifdef SISDUALHEAD
     if((!pSiS->DualHeadMode) || (pSiS->SecondHead)) {
#endif
d1163 37
a1199 11
        if(pSiS->VGAEngine == SIS_315_VGA) {
	   inSISIDXREG(SISSR, 0x1f, backup);
	   andSISIDXREG(SISSR, 0x1f, 0xe7);
	   if( (pSiS->XvGamma) &&
	       (pSiS->MiscFlags & MISC_CRT1OVERLAYGAMMA) &&
	       ((pSiS->CurrentLayout.depth == 16) ||
	        (pSiS->CurrentLayout.depth == 24)) ) {
	      orSISIDXREG(SISSR, 0x1f, 0x10);
	      resetxvgamma = TRUE;
	   }
        }
d1201 1
a1201 68
        switch(pSiS->CurrentLayout.depth) {
#ifdef SISGAMMA
          case 15:
	     if(dogamma1) {
	        orSISIDXREG(SISSR, 0x07, 0x04);
	        for(i=0; i<numColors; i++) {
                   index = indices[i];
		   if(index < 32) {   /* Paranoia */
		      for(j=0; j<8; j++) {
		         outSISREG(SISCOLIDX, (index * 8) + j);
                         outSISREG(SISCOLDATA, colors[index].red << (8- pScrn->rgbBits));
                         outSISREG(SISCOLDATA, colors[index].green << (8 - pScrn->rgbBits));
                         outSISREG(SISCOLDATA, colors[index].blue << (8 - pScrn->rgbBits));
		      }
		   }
                }
	     } else {
	        andSISIDXREG(SISSR, 0x07, ~0x04);
	     }
	     break;
	  case 16:
	     if(dogamma1) {
                orSISIDXREG(SISSR, 0x07, 0x04);
	        for(i=0; i<numColors; i++) {
                   index = indices[i];
		   if(index < 64) {  /* Paranoia */
		      for(j=0; j<4; j++) {
		         outSISREG(SISCOLIDX, (index * 4) + j);
                         outSISREG(SISCOLDATA, colors[index/2].red << (8 - pScrn->rgbBits));
                         outSISREG(SISCOLDATA, colors[index].green << (8 - pScrn->rgbBits));
                         outSISREG(SISCOLDATA, colors[index/2].blue << (8 - pScrn->rgbBits));
		      }
		   }
                }
	     } else {
	        andSISIDXREG(SISSR, 0x07, ~0x04);
	     }
	     break;
          case 24:
	     if(dogamma1) {
	        orSISIDXREG(SISSR, 0x07, 0x04);
                for(i=0; i<numColors; i++)  {
                   index = indices[i];
		   if(index < 256) {   /* Paranoia */
                      outSISREG(SISCOLIDX, index);
                      outSISREG(SISCOLDATA, colors[index].red);
                      outSISREG(SISCOLDATA, colors[index].green);
                      outSISREG(SISCOLDATA, colors[index].blue);
		   }
                }
	     } else {
	        andSISIDXREG(SISSR, 0x07, ~0x04);
	     }
	     break;
#endif
	  default:
	     if((pScrn->rgbBits == 8) && (dogamma1))
	        orSISIDXREG(SISSR, 0x07, 0x04);
	     else
	        andSISIDXREG(SISSR, 0x07, ~0x04);
             for(i=0; i<numColors; i++)  {
                index = indices[i];
                outSISREG(SISCOLIDX, index);
                outSISREG(SISCOLDATA, colors[index].red >> (8 - pScrn->rgbBits));
                outSISREG(SISCOLDATA, colors[index].green >> (8 - pScrn->rgbBits));
                outSISREG(SISCOLDATA, colors[index].blue >> (8 - pScrn->rgbBits));
             }
	}
d1203 1
a1203 7
	if(pSiS->VGAEngine == SIS_315_VGA) {
	   outSISIDXREG(SISSR, 0x1f, backup);
	   inSISIDXREG(SISSR, 0x07, backup);
	   if((backup & 0x04) && (resetxvgamma) && (pSiS->ResetXvGamma)) {
	      (pSiS->ResetXvGamma)(pScrn);
	   }
	}
d1205 14
a1218 2
#ifdef SISDUALHEAD		
    }	
d1220 6
a1225 2
    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead)) {
#endif
d1227 20
a1246 14
       switch(pSiS->VGAEngine) {
       case SIS_300_VGA:
       case SIS_315_VGA:
          if(pSiS->VBFlags & CRT2_ENABLE) {
	     /* Only the SiS bridges support a CRT2 palette */
	     if(pSiS->VBFlags & VB_SISBRIDGE) {
                (*pSiS->LoadCRT2Palette)(pScrn, numColors, indices, colors, pVisual);
	     }
          }
       }
	
#ifdef SISDUALHEAD		
    }
#endif
d1248 1
d1251 3
a1253 3
static  void
SiS301LoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
                                        LOCO *colors, VisualPtr pVisual)
d1255 1
a1255 5
        SISPtr  pSiS = SISPTR(pScrn);
        int     i, j, index;
	Bool    dogamma2 = pSiS->CRT2gamma;
#ifdef SISDUALHEAD
        SISEntPtr pSiSEnt = pSiS->entityPrivate;
d1257 1
a1257 2
	if(pSiS->DualHeadMode) dogamma2 = pSiSEnt->CRT2gamma;
#endif
d1259 5
a1263 1
        PDEBUG(ErrorF("SiS301LoadPalette(%d)\n", numColors));
d1265 87
a1351 71
	/* 301B-DH does not support a color palette for LCD */
	if((pSiS->VBFlags & VB_30xBDH) && (pSiS->VBFlags & CRT2_LCD)) return;
	
	switch(pSiS->CurrentLayout.depth) {
#ifdef SISGAMMA
          case 15:
	     if(dogamma2) {
	        orSISIDXREG(SISPART4, 0x0d, 0x08);
	        for(i=0; i<numColors; i++) {
                   index = indices[i];
		   if(index < 32) {   /* Paranoia */
		      for(j=0; j<8; j++) {
		         outSISREG(SISCOL2IDX, (index * 8) + j);
                         outSISREG(SISCOL2DATA, colors[index].red << (8- pScrn->rgbBits));
                         outSISREG(SISCOL2DATA, colors[index].green << (8 - pScrn->rgbBits));
                         outSISREG(SISCOL2DATA, colors[index].blue << (8 - pScrn->rgbBits));
		      }
		   }
                }
	     } else {
	        andSISIDXREG(SISPART4, 0x0d, ~0x08);
	     }
	     break;
	  case 16:
	     if(dogamma2) {
                orSISIDXREG(SISPART4, 0x0d, 0x08);
	        for(i=0; i<numColors; i++) {
                   index = indices[i];
		   if(index < 64) {  /* Paranoia */
		      for(j=0; j<4; j++) {
		         outSISREG(SISCOL2IDX, (index * 4) + j);
                         outSISREG(SISCOL2DATA, colors[index/2].red << (8 - pScrn->rgbBits));
                         outSISREG(SISCOL2DATA, colors[index].green << (8 - pScrn->rgbBits));
                         outSISREG(SISCOL2DATA, colors[index/2].blue << (8 - pScrn->rgbBits));
		      }
		   }
                }
	     } else {
	        andSISIDXREG(SISPART4, 0x0d, ~0x08);
	     }
	     break;
          case 24:
	     if(dogamma2) {
	        orSISIDXREG(SISPART4, 0x0d, 0x08);
                for(i=0; i<numColors; i++)  {
                   index = indices[i];
		   if(index < 256) {   /* Paranoia */
                      outSISREG(SISCOL2IDX, index);
                      outSISREG(SISCOL2DATA, colors[index].red);
                      outSISREG(SISCOL2DATA, colors[index].green);
                      outSISREG(SISCOL2DATA, colors[index].blue);
		   }
                }
	     } else {
	        andSISIDXREG(SISPART4, 0x0d, ~0x08);
	     }
	     break;
#endif
	  default:
	     if((pScrn->rgbBits == 8) && (dogamma2))
	        orSISIDXREG(SISPART4, 0x0d, 0x08);
	     else
	        andSISIDXREG(SISPART4, 0x0d, ~0x08);
             for(i=0; i<numColors; i++)  {
                index = indices[i];
                outSISREG(SISCOL2IDX,  index);
                outSISREG(SISCOL2DATA, colors[index].red);
                outSISREG(SISCOL2DATA, colors[index].green);
                outSISREG(SISCOL2DATA, colors[index].blue);
             }
	 }
d1354 1
d1361 15
a1375 17
      case PCI_CHIP_SIS550:
      case PCI_CHIP_SIS650:
      case PCI_CHIP_SIS315:
      case PCI_CHIP_SIS315H:
      case PCI_CHIP_SIS315PRO:
      case PCI_CHIP_SIS330:
      case PCI_CHIP_SIS660:
        pSiS->MaxClock               = SiSMemBandWidth(pScrn, FALSE);
        pSiS->SiSSave                = SiS315Save;
        pSiS->SiSSave2               = SiS301Save;
        pSiS->SiSSave3               = SiS301BSave;
        pSiS->SiSSaveLVDSChrontel    = SiSLVDSChrontelSave;
        pSiS->SiSRestore             = SiS315Restore;
        pSiS->SiSRestore2            = SiS301Restore;
        pSiS->SiSRestore3            = SiS301BRestore;
        pSiS->SiSRestoreLVDSChrontel = SiSLVDSChrontelRestore;
        pSiS->LoadCRT2Palette        = SiS301LoadPalette;
d1377 14
a1390 13
      case PCI_CHIP_SIS300:
      case PCI_CHIP_SIS630:
      case PCI_CHIP_SIS540:
        pSiS->MaxClock               = SiSMemBandWidth(pScrn, FALSE);
        pSiS->SiSSave                = SiS300Save;
        pSiS->SiSSave2               = SiS301Save;
        pSiS->SiSSave3               = SiS301BSave;
        pSiS->SiSSaveLVDSChrontel    = SiSLVDSChrontelSave;
        pSiS->SiSRestore             = SiS300Restore;
        pSiS->SiSRestore2            = SiS301Restore;
        pSiS->SiSRestore3            = SiS301BRestore;
        pSiS->SiSRestoreLVDSChrontel = SiSLVDSChrontelRestore;
        pSiS->LoadCRT2Palette        = SiS301LoadPalette;
d1392 5
a1396 7
      case PCI_CHIP_SIS5597:
      case PCI_CHIP_SIS6326:
      case PCI_CHIP_SIS530:
      default:
        pSiS->MaxClock               = SiSMemBandWidth(pScrn, FALSE);
        pSiS->SiSRestore             = SiSRestore;
        pSiS->SiSSave                = SiSSave;
d1398 11
d1417 2
a1418 2
    for(index = from; index <= to; index++, DataPtr++) {
       outSISIDXREG(port, index, *DataPtr);
a1419 41
}

void
SiS6326SetTVReg(ScrnInfoPtr pScrn, CARD8 index, CARD8 data)
{
    SISPtr  pSiS = SISPTR(pScrn);
    outSISIDXREG(SISCR, 0xE0, index);
    outSISIDXREG(SISCR, 0xE1, data);
#ifdef TWDEBUG
    xf86DrvMsg(0, X_INFO, "SiS6326: Setting Tv %02x to %02x\n", index, data);
#endif
}

unsigned char
SiS6326GetTVReg(ScrnInfoPtr pScrn, CARD8 index)
{
    SISPtr  pSiS = SISPTR(pScrn);
    unsigned char data;

    outSISIDXREG(SISCR, 0xE0, index);
    inSISIDXREG(SISCR, 0xE1, data);
    return(data);
}

void
SiS6326SetXXReg(ScrnInfoPtr pScrn, CARD8 index, CARD8 data)
{
    SISPtr  pSiS = SISPTR(pScrn);
    outSISIDXREG(SISCR, 0xE2, index);
    outSISIDXREG(SISCR, 0xE3, data);
}

unsigned char
SiS6326GetXXReg(ScrnInfoPtr pScrn, CARD8 index)
{
    SISPtr  pSiS = SISPTR(pScrn);
    unsigned char data;

    outSISIDXREG(SISCR, 0xE2, index);
    inSISIDXREG(SISCR, 0xE3, data);
    return(data);
@


1.1.9.2
log
@Import XFree86 4.4 from The XFree86(TM) Project, Inc.
(integrity cannot be checked)

got via cvs -qd anoncvs@@anoncvs.xfree86.org:/cvs co -Prxf-4_4_0 xc
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_dac.c,v 1.61 2004/02/25 23:22:16 twini Exp $ */
d15 4
a18 1
 * 3) The name of the author may not be used to endorse or promote products
d88 1
a88 1
   };
d760 1
a760 1
    for(i = 0x00; i <= 0x7c; i++)  {
d1282 55
d1341 1
a1341 1
{
d1424 1
a1424 1
  	   if(pSiS->VBLCDFlags & (VB_LCD_320x480 | VB_LCD_800x600 | VB_LCD_640x480)) {
d1426 1
a1426 1
	   } else if(pSiS->VBLCDFlags & (VB_LCD_1024x768 | VB_LCD_1024x600 | VB_LCD_1152x768)) {
d1428 1
a1428 3
	   } else if(pSiS->VBLCDFlags & VB_LCD_1280x720) {
	      return 75000;
	   } else if(pSiS->VBLCDFlags & VB_LCD_1280x768) {
d1430 1
a1430 5
	   } else if(pSiS->VBLCDFlags & VB_LCD_1280x800) {
	      /* Must fake clock; built-in mode shows 83 for VGA, but uses only 70 for LCD */
	      if(IsForMergedFBCRT2) return 83000;
	      else                  return 70000;
	   } else if(pSiS->VBLCDFlags & VB_LCD_1400x1050) {
d1434 1
a1434 1
	   } else if(pSiS->VBLCDFlags & (VB_LCD_1280x1024 | VB_LCD_1280x960)) {
d1436 1
a1436 5
	   } else if(pSiS->VBLCDFlags & VB_LCD_1680x1050) {
	      /* Must fake clock; built-in mode shows 147 for VGA, but uses only 122 for LCD */
	      if(IsForMergedFBCRT2) return 148000;
	      else                  return 122000;
	   } else if(pSiS->VBLCDFlags & VB_LCD_1600x1200) {
d1438 1
a1438 1
	   } else if((pSiS->VBLCDFlags & VB_LCD_CUSTOM) && (pSiS->SiS_Pr->CP_HaveCustomData)) {
d1440 1
a1440 1
	   } else
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@a0 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_dac.c,v 1.30 2003/02/05 17:53:22 eich Exp $ */
a2 1
 * Parts Copyright 2001, 2002 by Thomas Winischhofer, Vienna, Austria.
d8 1
a8 1
 * documentation, and that the name of the provider not be used in
d10 1
a10 1
 * specific, written prior permission.  The provider makes no representations
d14 1
a14 1
 * THE PROVIDER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
d16 1
a16 1
 * EVENT SHALL THE PROVIDER BE LIABLE FOR ANY SPECIAL, INDIRECT OR
d22 5
a26 6
 * Authors:  Alan Hourihane <alanh@@fairlite.demon.co.uk>
 *           Mike Chapman <mike@@paranoia.com>,
 *           Juanjo Santamarta <santamarta@@ctv.es>,
 *           Mitani Hiroshi <hmitani@@drl.mei.co.jp>
 *           David Thomas <davtom@@dream.org.uk>.
 *	     Thomas Winischhofer <thomas@@winischhofer.net>
d28 1
d36 2
a37 1
#include "xf86DDC.h"
d43 1
a48 1
static void SiS310Save(ScrnInfoPtr pScrn, SISRegPtr sisReg);
d51 1
a51 1
static void SiSLVDSChrontelSave(ScrnInfoPtr pScrn, SISRegPtr sisReg);
a52 1
static void SiS310Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg);
d55 2
a56 1
static void SiSLVDSChrontelRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg);
d59 6
a67 3
#if 0
Bool        SiSI2CInit(ScrnInfoPtr pScrn);
#endif
d69 1
a69 11
static const unsigned short ch700xidx[] = {
      0x00,0x07,0x08,0x0a,0x0b,0x04,0x09,0x20,0x21,0x18,0x19,0x1a,
      0x1b,0x1c,0x1d,0x1e,0x1f,  /* 0x0e,  - TW: Don't save the power register */
      0x01,0x03,0x06,0x0d,0x11,0x13,0x14,0x15,0x17,0x22,0x23,0x24
   };

static const unsigned short ch701xidx[] = {
      0x1c,0x5f,0x64,0x6f,0x70,0x71,0x72,0x73,0x74,0x76,0x78,0x7d,
      0x67,0x68,0x69,0x6a,0x6b,0x1e,0x00,0x01,0x02,0x04,0x03,0x05,
      0x06,0x07,0x08,0x15,0x1f,0x0c,0x0d,0x0e,0x0f,0x10
   };
d71 2
a72 1
int SiS_compute_vclk(
d169 1
a169 1
    PDEBUG(ErrorF("SiS_compute_vclk: Clock=%d, n=%d, dn=%d, div=%d, sbit=%d,"
d206 2
a207 2
#define MIN_VCO      Fref
#define MAX_VCO      135000000
d209 2
a210 2
#define MAX_PSN      0          /* no pre scaler for this chip */
#define TOLERANCE    0.01       /* search smallest M and N in this tolerance */
d219 1
d324 2
a325 2
                        xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,3,
			       "Freq. selected: %.2f MHz, M=%d, N=%d, VLD=%d, P=%d, PSN=%d\n",
d327 1
a327 2
                        xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,3,
			       "Freq. set: %.2f MHz\n", Fout / 1.0e6);
d356 1
d358 3
d362 2
a363 2
    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
             "SiSSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n"));
d365 1
a365 3
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d369 1
a369 1
           max=0x3C;
d373 1
a373 1
           max=0x3F; 
a379 1
    /* Save extended SR registers */
d381 4
a384 16
        inSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
#ifdef DEBUG
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
                 "XR%02X Contents - %02X \n", i, sisReg->sisRegs3C4[i]);
#endif
#ifdef TWDEBUG
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "SR%02X - %02X \n", i,sisReg->sisRegs3C4[i]);
#endif
    }

#ifdef TWDEBUG
    for (i = 0x00; i <= 0x3f; i++) {
        inSISIDXREG(SISCR, i, max);
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "CR%02X - %02X \n", i,max);
a385 6
#endif

    /* Save lock (will not be restored in SiSRestore()!) */
    inSISIDXREG(SISCR, 0x80, sisReg->sisRegs3D4[0x80]);

    sisReg->sisRegs3C2 = inSISREG(SISMISCR);	 /* Misc */
d387 2
a388 11
    /* TW: Save TV registers */
    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
       outSISIDXREG(SISCR, 0x80, 0x86);
       for(i = 0x00; i <= 0x44; i++) {
         sisReg->sis6326tv[i] = SiS6326GetTVReg(pScrn, i);
#ifdef TWDEBUG
         xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "VR%02X - %02X \n", i,sisReg->sis6326tv[i]);
#endif
       }
    }
d395 1
a396 4
    unsigned char tmp;
#ifdef DEBUG
    int temp;
#endif
d401 4
a404 3
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d408 1
a408 1
           max = 0x3C;
d411 4
a414 2
	case PCI_CHIP_SIS530:
           max = 0x3F;
d417 1
a417 1
           max = 0x37;
d421 6
a426 34
    /* Disable TV on 6326 before restoring */
    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
       outSISIDXREG(SISCR, 0x80, 0x86);
       tmp = SiS6326GetTVReg(pScrn, 0x00);
       tmp &= ~0x04;
       SiS6326SetTVReg(pScrn, 0x00, tmp);
    }

    /* Restore VCLKs */
#if 0  /* TW: No, we didn't save SR2x-1 and SR2x-2! */
    andSISIDXREG(SISSR, 0x38, 0xfc);
    inSISIDXREG(SISSR, 0x13, tmp);
    tmp &= ~0x40;
    tmp |= (sisReg->sisRegs3C4[0x13] & 0x40);
    outSISIDXREG(SISSR, 0x13, tmp);
    outSISIDXREG(SISSR, 0x2a, sisReg->sisRegs3C4[0x2a]);
    outSISIDXREG(SISSR, 0x2b, sisReg->sisRegs3C4[0x2b]);
    orSISIDXREG(SISSR, 0x38, 0x01);
    inSISIDXREG(SISSR, 0x13, tmp);
    tmp &= ~0x40;
    tmp |= (sisReg->sisRegs3C4[0x13] & 0x40);
    outSISIDXREG(SISSR, 0x13, tmp);
    outSISIDXREG(SISSR, 0x2a, sisReg->sisRegs3C4[0x2a]);
    outSISIDXREG(SISSR, 0x2b, sisReg->sisRegs3C4[0x2b]);
    andSISIDXREG(SISSR, 0x38, 0xfc);
    orSISIDXREG(SISSR, 0x38, 0x02);
    inSISIDXREG(SISSR, 0x13, tmp);
    tmp &= ~0x40;
    tmp |= (sisReg->sisRegs3C4[0x13] & 0x40);
    outSISIDXREG(SISSR, 0x13, tmp);
    outSISIDXREG(SISSR, 0x2a, sisReg->sisRegs3C4[0x2a]);
    outSISIDXREG(SISSR, 0x2b, sisReg->sisRegs3C4[0x2b]);
    andSISIDXREG(SISSR, 0x38, 0xfc);
#endif
d428 3
a430 15
    /* Restore other extended SR registers */
    for (i = 0x06; i <= max; i++) {
        if((i == 0x13) || (i == 0x2a) || (i == 0x2b)) continue;
#ifdef DEBUG
        inSISIDXREG(SISSR, i, temp);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
                    "SR%X Contents: %02X - ", i, temp);
#endif
	outSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
#ifdef DEBUG
	inSISIDXREG(SISSR, i, temp);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
                        "Restored to %02X - Read: %02X\n",
                        sisReg->sisRegs3C4[i], temp);
#endif
d433 4
a436 4
    /* Now restore VCLK (with correct SR38 setting) */
    outSISIDXREG(SISSR, 0x13, sisReg->sisRegs3C4[0x13]);
    outSISIDXREG(SISSR, 0x2a, sisReg->sisRegs3C4[0x2a]);
    outSISIDXREG(SISSR, 0x2b, sisReg->sisRegs3C4[0x2b]);
d438 2
a439 2
    /* Misc */
    outSISREG(SISMISCW, sisReg->sisRegs3C2);
a440 28
    /* MemClock needs this to take effect */
    outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
    usleep(10000);
    outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */

    /* TW: Restore TV registers */
    pSiS->SiS6326Flags &= ~SIS6326_TVON;
    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
       for(i = 0x01; i <= 0x44; i++) {
         SiS6326SetTVReg(pScrn, i, sisReg->sis6326tv[i]);
#ifdef TWDEBUG
         xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	 	"VR%02x restored to %02x\n",
		i, sisReg->sis6326tv[i]);
#endif
       }
       tmp = SiS6326GetXXReg(pScrn, 0x13);
       SiS6326SetXXReg(pScrn, 0x13, 0xfa);
       tmp = SiS6326GetXXReg(pScrn, 0x14);
       SiS6326SetXXReg(pScrn, 0x14, 0xc8);
       if(!(sisReg->sisRegs3C4[0x0D] & 0x04)) {
    	  tmp = SiS6326GetXXReg(pScrn, 0x13);
	  SiS6326SetXXReg(pScrn, 0x13, 0xf6);
	  tmp = SiS6326GetXXReg(pScrn, 0x14);
	  SiS6326SetXXReg(pScrn, 0x14, 0xbf);
       }
       if(sisReg->sis6326tv[0] & 0x04) pSiS->SiS6326Flags |= SIS6326_TVON;
    }
a442 1
/* Save SiS 300 series register contents */
d447 2
a448 1
    int i;
d451 6
a456 1
     		"SiS300Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n"));
d458 1
a458 3
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d460 5
a464 7
    /* Save SR registers */
    for (i = 0x00; i <= 0x3D; i++) {
        inSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
#ifdef TWDEBUG
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "SR%02X - %02X \n", i,sisReg->sisRegs3C4[i]);
#endif
d467 4
a470 7
    /* Save CR registers */
    for (i = 0x00; i < 0x40; i++)  {
        inSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
#ifdef TWDEBUG
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"CR%02X Contents - %02X \n", i,sisReg->sisRegs3D4[i]);
#endif
d473 2
a474 14
    /* Save Misc register */
    sisReg->sisRegs3C2 = inSISREG(SISMISCR);	 
    
    /* Save FQBQ and GUI timer settings */
    if(pSiS->Chipset == PCI_CHIP_SIS630) {
       sisReg->sisRegsPCI50 = pciReadLong(0x00000000, 0x50);
       sisReg->sisRegsPCIA0 = pciReadLong(0x00000000, 0xA0);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       		"PCI Config 50 = %lx\n", sisReg->sisRegsPCI50);
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       		"PCI Config A0 = %lx\n", sisReg->sisRegsPCIA0);		
#endif       
    }
d476 2
a477 3
    /* Save panel link/video bridge registers */
#ifndef TWDEBUG
    if(!pSiS->UseVESA) {
d479 5
a483 7
      if (pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
        (*pSiS->SiSSaveLVDSChrontel)(pScrn, sisReg);
      if (pSiS->VBFlags & (VB_301|VB_303))
        (*pSiS->SiSSave2)(pScrn, sisReg);
      if (pSiS->VBFlags & (VB_301B|VB_302B|VB_30xLV|VB_30xLVX))
        (*pSiS->SiSSave3)(pScrn, sisReg);
#ifndef TWDEBUG
d486 9
a494 4

    /* Save Mode number */
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
    if(!(pSiS->UseVESA))
d496 3
a498 6
        pSiS->BIOSModeSave = SiS_GetSetModeID(pScrn,0xFF);
	
#ifdef TWDEBUG	
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
    	"BIOS mode ds:449 = 0x%x\n", pSiS->BIOSModeSave);
#endif	
a500 2

/* Restore SiS300 series register contents */
d505 2
a506 2
    int i,temp;
    CARD32 temp1;
d509 4
a512 1
                "SiS300Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n");
d514 1
a514 3
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d516 5
a520 3
    /* TW: Wait for accelerator to finish on-going drawing operations. */
    inSISIDXREG(SISSR, 0x1E, temp);
    if(temp & (0x40|0x10|0x02))  {
d523 2
a524 9
	while ( (MMIO_IN16(pSiS->IOBase, 0x8242) & 0xE000) != 0xE000){};
    }
    
    if (!(pSiS->UseVESA)) {
       if(pSiS->VBFlags & VB_LVDS) {
          SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
          SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
       }
    }
d526 3
a528 3
    /* Restore extended CR registers */
    for(i = 0x19; i < 0x40; i++)  {
        outSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
d530 1
a530 2

    if(pSiS->Chipset != PCI_CHIP_SIS300)  {
d532 6
a537 6
	inSISIDXREG(SISCR, 0x1A, val);
	if(val == sisReg->sisRegs3D4[0x19])
	   outSISIDXREG(SISCR, 0x1A, sisReg->sisRegs3D4[0x19]);
	inSISIDXREG(SISCR,0x19,val);
	if(val == sisReg->sisRegs3D4[0x1A])
           outSISIDXREG(SISCR, 0x19, sisReg->sisRegs3D4[0x1A]);
d540 2
a541 2
    /* Set (and leave) PCI_IO_ENABLE on if accelerators are on */
    if(sisReg->sisRegs3C4[0x1e] & 0x50) {
d543 3
a545 1
	outSISIDXREG(SISSR, 0x20, sisReg->sisRegs3C4[0x20]);
d548 7
a554 22
    /* TW: If TQ is switched on, don't switch it off ever again!
     *     Therefore, always restore registers with TQ enabled.
     */
    if((!pSiS->NoAccel) && (pSiS->TurboQueue)) {
        temp = (pScrn->videoRam/64) - 8;
        sisReg->sisRegs3C4[0x26] = temp & 0xFF;
	sisReg->sisRegs3C4[0x27] = ((temp >> 8) & 3) | 0xF0;
    }

    /* Restore extended SR registers */
    for (i = 0x06; i <= 0x3D; i++) {
        temp = sisReg->sisRegs3C4[i];
        if(!(pSiS->UseVESA)) {
           if(pSiS->VBFlags & VB_LVDS) {
               if(i == 0x11) {
	                inSISIDXREG(SISSR,0x11,temp);
	       		temp &= 0x0c; 
			temp |= (sisReg->sisRegs3C4[i] & 0xf3);
	       }
           }
        }
	outSISIDXREG(SISSR, i, temp);
a555 67
    
    /* TW: Restore VCLK and ECLK */
    if(pSiS->VBFlags & (VB_LVDS | VB_301B)) {
       outSISIDXREG(SISSR,0x31,0x20);
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x80);
       outSISIDXREG(SISSR,0x31,0x10);
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x80);
    }
    outSISIDXREG(SISSR,0x31,0x00);
    outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
    outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
    outSISIDXREG(SISSR,0x2d,0x80);
    if(pSiS->VBFlags & (VB_LVDS | VB_301B)) {
       outSISIDXREG(SISSR,0x31,0x20);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
       outSISIDXREG(SISSR,0x31,0x10);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
       outSISIDXREG(SISSR,0x31,0x00);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
    }
    
    /* Restore Misc register */
    outSISREG(SISMISCW, sisReg->sisRegs3C2);  
    
    /* Restore FQBQ and GUI timer settings */
    if(pSiS->Chipset == PCI_CHIP_SIS630) {
       temp1 = pciReadLong(0x00000000, 0x50);
       if(pciReadLong(0x00000000, 0x00) == 0x06301039) {
          temp1 &= 0xf0ffffff;
          temp1 |= (sisReg->sisRegsPCI50 & ~0xf0ffffff);
       } else {  /* 730 */
          temp1 &= 0xfffff9ff;
          temp1 |= (sisReg->sisRegsPCI50 & ~0xfffff9ff);
       }   
       pciWriteLong(0x00000000, 0x50, temp1);
    
       temp1 = pciReadLong(0x00000000, 0xA0);
       if(pciReadLong(0x00000000, 0x00) == 0x06301039) {
          temp1 &= 0xf0ffffff;
          temp1 |= (sisReg->sisRegsPCIA0 & ~0xf0ffffff);
       } else {	/* 730 */
          temp1 &= 0x00ffffff;
          temp1 |= (sisReg->sisRegsPCIA0 & ~0x00ffffff);
       } 
       pciWriteLong(0x00000000, 0xA0, temp1);
    }

    /* Restore panel link/video bridge registers */
    if (!(pSiS->UseVESA)) {
      if (pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
        (*pSiS->SiSRestoreLVDSChrontel)(pScrn, sisReg);
      if (pSiS->VBFlags & (VB_301|VB_303))
        (*pSiS->SiSRestore2)(pScrn, sisReg);
      if (pSiS->VBFlags & (VB_301B|VB_302B|VB_30xLV|VB_30xLVX))
        (*pSiS->SiSRestore3)(pScrn, sisReg);
    }
    
    /* MemClock needs this to take effect */
    outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
    outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */
d557 5
a561 41
    /* Restore mode number */
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
    if(!(pSiS->UseVESA))
#endif
        SiS_GetSetModeID(pScrn,pSiS->BIOSModeSave);
}

/* Save SiS310 series register contents */
static void
SiS310Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr pSiS = SISPTR(pScrn);
    int i;

    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
    		"SiS310Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n"));

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    /* Save SR registers */
    for (i = 0x00; i <= 0x3F; i++) {
        inSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
#ifdef DEBUG
        xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
		       "SR%02X - %02X \n", i,sisReg->sisRegs3C4[i]);
#endif
#ifdef TWDEBUG
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			 "SR%02X - %02X \n", i,sisReg->sisRegs3C4[i]);
#endif
    }

    /* TW: Save command queue location */
    sisReg->sisMMIO85C0 = MMIO_IN32(pSiS->IOBase, 0x85C0);

    /* Save CR registers */
    for (i = 0x00; i <= 0x5f; i++)  {
        inSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
#ifdef DEBUG
d563 2
a564 6
		       "CR%02X - %02X \n", i,sisReg->sisRegs3D4[i]);
#endif
#ifdef TWDEBUG
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"CR%02X Contents - %02X \n", i,sisReg->sisRegs3D4[i]);
#endif
d566 2
a567 7

    /* Save Misc register */
    sisReg->sisRegs3C2 = inSISREG(SISMISCR);   

    /* Save panel link/video bridge registers */
#ifndef TWDEBUG
    if (!pSiS->UseVESA) {
d569 5
a573 7
      if (pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
        (*pSiS->SiSSaveLVDSChrontel)(pScrn, sisReg);
      if (pSiS->VBFlags & (VB_301|VB_303))
        (*pSiS->SiSSave2)(pScrn, sisReg);
      if (pSiS->VBFlags & (VB_301B|VB_302B|VB_30xLV|VB_30xLVX))
        (*pSiS->SiSSave3)(pScrn, sisReg);
#ifndef TWDEBUG
d576 4
a579 4

    /* Save mode number */
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
    if(!(pSiS->UseVESA))
d581 4
a584 15
        pSiS->BIOSModeSave = SiS_GetSetModeID(pScrn,0xFF);
}

/* Restore SiS310 series register contents */
static void
SiS310Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr pSiS = SISPTR(pScrn);
    int i,temp;

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
                "SiS310Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n");

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
d587 2
a588 7
    /* TW: Wait for accelerator to finish on-going drawing operations. */
    inSISIDXREG(SISSR, 0x1E, temp);
    if (temp & (0x40|0x10|0x02))  {	/* TW: 0x40 = 2D, 0x10 = 3D enabled*/
        while ( (MMIO_IN32(pSiS->IOBase, 0x85CC) & 0x80000000) != 0x80000000){};
	while ( (MMIO_IN32(pSiS->IOBase, 0x85CC) & 0x80000000) != 0x80000000){};
	while ( (MMIO_IN32(pSiS->IOBase, 0x85CC) & 0x80000000) != 0x80000000){};
    }
d590 3
a592 4
    /* Restore extended CR registers */
    for (i = 0x19; i < 0x5C; i++)  {
        outSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
    }
d594 2
a595 14
    /* TW: Leave PCI_IO_ENABLE on if accelerators are on (Is this required?) */
    if (sisReg->sisRegs3C4[0x1e] & 0x50) {  /*0x40=2D, 0x10=3D*/
	sisReg->sisRegs3C4[0x20] |= 0x20;
	outSISIDXREG(SISSR, 0x20, sisReg->sisRegs3C4[0x20]);
    }

    /* TW: We reset the command queue before restoring.
     * This might be required because we never know what
     * console driver (like the kernel framebuffer driver)
     * or application is running and which queue mode it
     * uses.
     */
    outSISIDXREG(SISSR, 0x27, 0x1F);
    outSISIDXREG(SISSR, 0x26, 0x01);
a596 73
    /* Restore extended SR registers */
    for (i = 0x06; i <= 0x3F; i++) {
#ifdef DEBUG
        inSISIDXREG(SISSR, i, temp);
#endif
	outSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
#ifdef DEBUG
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
                    "XR%X Contents %02X - ", i, temp);
	inSISIDXREG(SISSR, i, temp);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
        	    "Restored to %02X - Read: %02X\n",
                    sisReg->sisRegs3C4[i], temp);
#endif
    }
    /* TW: Restore VCLK and ECLK */
    andSISIDXREG(SISSR,0x31,0xcf);
    if(pSiS->VBFlags & VB_LVDS) {
        orSISIDXREG(SISSR,0x31,0x20);
	outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
        outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
	outSISIDXREG(SISSR,0x2d,0x80);
	andSISIDXREG(SISSR,0x31,0xcf);
        orSISIDXREG(SISSR,0x31,0x10);
	outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
        outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
	outSISIDXREG(SISSR,0x2d,0x80);
	andSISIDXREG(SISSR,0x31,0xcf);
	outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
        outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
	outSISIDXREG(SISSR,0x2d,0x01);
	outSISIDXREG(SISSR,0x31,0x20);
	outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
        outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
	outSISIDXREG(SISSR,0x31,0x10);
	outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
        outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
	outSISIDXREG(SISSR,0x31,0x00);
	outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
        outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
    } else {
        outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
        outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
        outSISIDXREG(SISSR,0x2d,0x01);
    }

    /* TW: Initialize read/write pointer for command queue */
    MMIO_OUT32(pSiS->IOBase, 0x85C4, MMIO_IN32(pSiS->IOBase, 0x85C8));
    /* TW: Restore queue location */
    MMIO_OUT32(pSiS->IOBase, 0x85C0, sisReg->sisMMIO85C0);

    /* Restore Misc register */
    outSISREG(SISMISCW, sisReg->sisRegs3C2);   

    /* Restore panel link/video bridge registers */
    if (!(pSiS->UseVESA)) {
      if (pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
        (*pSiS->SiSRestoreLVDSChrontel)(pScrn, sisReg);
      if (pSiS->VBFlags & (VB_301|VB_303))
        (*pSiS->SiSRestore2)(pScrn, sisReg);
      if (pSiS->VBFlags & (VB_301B|VB_302B|VB_30xLV|VB_30xLVX))
        (*pSiS->SiSRestore3)(pScrn, sisReg);
    }

    /* MemClock needs this to take effect */
    outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
    outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */

    /* Restore Mode number */
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
    if(!(pSiS->UseVESA))
#endif
       SiS_GetSetModeID(pScrn,pSiS->BIOSModeSave);
a598 1
/* Save SiS301 bridge register contents */
a603 1
    int     Part1max=0, Part2max=0, Part3max=0, Part4max=0;
d605 3
a607 21
    /* Highest register number to save/restore */
    switch (pSiS->VGAEngine) {
    case SIS_300_VGA:
         Part1max = 0x1d;
	 Part2max = 0x45;
	 Part3max = 0x3e;
	 Part4max = 0x1b;
	 break;
    case SIS_315_VGA:
         Part1max = 0x2e;  /* 0x23, but we also need 2d-2e */
	 Part2max = 0x45;
	 Part3max = 0x3e;
	 Part4max = 0x1b;
	 break;
    }

    for (i=0; i<=Part1max; i++)  {
        inSISIDXREG(SISPART1, i, sisReg->VBPart1[i]);
#ifdef TWDEBUG
	xf86DrvMsg(0, X_INFO, "301Save: Part1Port 0x%02x = 0x%02x\n", i, sisReg->VBPart1[i]);
#endif
d609 2
a610 5
    for (i=0; i<=Part2max; i++)  {
        inSISIDXREG(SISPART2, i, sisReg->VBPart2[i]);
#ifdef TWDEBUG
	xf86DrvMsg(0, X_INFO, "301Save: Part2Port 0x%02x = 0x%02x\n", i, sisReg->VBPart2[i]);
#endif
d612 2
a613 5
    for (i=0; i<=Part3max; i++)  {
        inSISIDXREG(SISPART3, i, sisReg->VBPart3[i]);
#ifdef TWDEBUG
	xf86DrvMsg(0, X_INFO, "301Save: Part3Port 0x%02x = 0x%02x\n", i, sisReg->VBPart3[i]);
#endif
d615 2
a616 5
    for (i=0; i<=Part4max; i++)  {
        inSISIDXREG(SISPART4, i, sisReg->VBPart4[i]);
#ifdef TWDEBUG
	xf86DrvMsg(0, X_INFO, "301Save: Part4Port 0x%02x = 0x%02x\n", i, sisReg->VBPart4[i]);
#endif
d618 2
a619 81

    sisReg->VBPart2[0] &= ~0x20;         /* Disable VB Processor */
    sisReg->sisRegs3C4[0x32] &= ~0x20;   /* Disable Lock Mode */
}

/* Restore SiS301 bridge register contents */
static void
SiS301Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int     Part1max=0, Part2max=0, Part3max=0, Part4max=0;

    /* Highest register number to save/restore */
    switch (pSiS->VGAEngine) {
    case SIS_300_VGA:
         Part1max = 0x1d;
	 Part2max = 0x45;
	 Part3max = 0x3e;
	 Part4max = 0x1b;
	 break;
    case SIS_315_VGA:
         Part1max = 0x23;
	 Part2max = 0x45;
	 Part3max = 0x3e;
	 Part4max = 0x1b;
	 break;
    }

    SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);

    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);

    /* Pre-restore Part1 */
    outSISIDXREG(SISPART1, 0x04, 0x00);
    outSISIDXREG(SISPART1, 0x05, 0x00);
    outSISIDXREG(SISPART1, 0x06, 0x00);
    outSISIDXREG(SISPART1, 0x00, sisReg->VBPart1[0]);
    outSISIDXREG(SISPART1, 0x01, sisReg->VBPart1[1]);

    /* Pre-restore Part4 */
    outSISIDXREG(SISPART4, 0x0D, sisReg->VBPart4[0x0D]);
    outSISIDXREG(SISPART4, 0x0C, sisReg->VBPart4[0x0C]);

    if (!(sisReg->sisRegs3D4[0x30] & 0x03) &&
         (sisReg->sisRegs3D4[0x31] & 0x20))  {      /* disable CRT2 */
            SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
            return;
    }

    /* Restore Part1 */
    SetBlock(SISPART1, 0x02, Part1max, &(sisReg->VBPart1[0x02]));
    switch (pSiS->VGAEngine) {
      case SIS_300_VGA:
        /* TW: Nothing special here. */
      	break;
      case SIS_315_VGA:
        /* TW: Restore extra registers on 310 series */
	SetBlock(SISPART1, 0x2C, 0x2E, &(sisReg->VBPart1[0x2C]));
      	break;
    }

    /* Restore Part2 */
    SetBlock(SISPART2, 0x00, Part2max, &(sisReg->VBPart2[0x00]));

    /* Restore Part3 */
    SetBlock(SISPART3, 0x00, Part3max, &(sisReg->VBPart3[0x00]));

    /* Restore Part4 */
    SetBlock(SISPART4, 0x0E, 0x11, &(sisReg->VBPart4[0x0E]));
    SetBlock(SISPART4, 0x13, Part4max, &(sisReg->VBPart4[0x13]));

    /* Post-restore Part4 (CRT2VCLK) */
    outSISIDXREG(SISPART4, 0x0A, 0x01);
    outSISIDXREG(SISPART4, 0x0B, sisReg->VBPart4[0x0B]);
    outSISIDXREG(SISPART4, 0x0A, sisReg->VBPart4[0x0A]);
    outSISIDXREG(SISPART4, 0x12, 0x00);
    outSISIDXREG(SISPART4, 0x12, sisReg->VBPart4[0x12]);

    SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
    SiS_DisplayOn(pSiS->SiS_Pr);
    SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
a621 1
/* Save SiS301B/302B/30xLV bridge register contents */
a626 1
    int     Part1max=0, Part2max=0, Part3max=0, Part4max=0;
d628 3
a630 26
    switch (pSiS->VGAEngine) {
    case SIS_300_VGA:
         Part1max = 0x37; /* 0x1d, but we also need 2c-2e, 35-37 */
	 Part2max = 0x4d;
	 Part3max = 0x3e;
	 if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX))
	   Part4max = 0x24;
	 else
	   Part4max = 0x23;
	 break;
    case SIS_315_VGA:
         Part1max = 0x37; /* 0x23, but we also need 2c-2e, 35-37 */
	 Part2max = 0x4d;
	 Part3max = 0x3e;
	 if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX))
	   Part4max = 0x24;
	 else
	   Part4max = 0x23;
	 break;
    }

    for (i=0; i<=Part1max; i++)  {
        inSISIDXREG(SISPART1, i, sisReg->VBPart1[i]);
#ifdef TWDEBUG
	xf86DrvMsg(0, X_INFO, "301BSave: Part1Port 0x%02x = 0x%02x\n", i, sisReg->VBPart1[i]);
#endif
d632 2
a633 5
    for (i=0; i<=Part2max; i++)  {
        inSISIDXREG(SISPART2, i, sisReg->VBPart2[i]);
#ifdef TWDEBUG
	xf86DrvMsg(0, X_INFO, "301BSave: Part2Port 0x%02x = 0x%02x\n", i, sisReg->VBPart2[i]);
#endif
d635 2
a636 5
    for (i=0; i<=Part3max; i++)  {
        inSISIDXREG(SISPART3, i, sisReg->VBPart3[i]);
#ifdef TWDEBUG
	xf86DrvMsg(0, X_INFO, "301BSave: Part3Port 0x%02x = 0x%02x\n", i, sisReg->VBPart3[i]);
#endif
d638 2
a639 5
    for (i=0; i<=Part4max; i++)  {
        inSISIDXREG(SISPART4, i, sisReg->VBPart4[i]);
#ifdef TWDEBUG
	xf86DrvMsg(0, X_INFO, "301BSave: Part4Port 0x%02x = 0x%02x\n", i, sisReg->VBPart4[i]);
#endif
d641 2
a642 2
    sisReg->VBPart2[0] &= ~0x20;         /* Disable VB Processor */
    sisReg->sisRegs3C4[0x32] &= ~0x20;   /* Disable Lock Mode */
a644 1
/* Restore SiS301B/302B/301LV/302LV bridge register contents */
d646 1
a646 1
SiS301BRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d649 1
a649 46
    int     Part1max=0, Part2max=0, Part3max=0, Part4max=0;

    switch (pSiS->VGAEngine) {
    case SIS_300_VGA:
         Part1max = 0x23;
	 Part2max = 0x4d;
	 Part3max = 0x3e;
	 if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX))
	   Part4max = 0x24;
	 else
	   Part4max = 0x22;
	 break;
    case SIS_315_VGA:
         Part1max = 0x23;
	 Part2max = 0x4d;
	 Part3max = 0x3e;
	 if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX))
	   Part4max = 0x24;
	 else
	   Part4max = 0x22;
	 break;
    }

    SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);

    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);

    /* Pre-restore Part1 */
    outSISIDXREG(SISPART1, 0x04, 0x00);
    outSISIDXREG(SISPART1, 0x05, 0x00);
    outSISIDXREG(SISPART1, 0x06, 0x00);
    outSISIDXREG(SISPART1, 0x00, sisReg->VBPart1[0x00]);
    outSISIDXREG(SISPART1, 0x01, sisReg->VBPart1[0x01]);
    /* Mode reg 0x01 became 0x2e on 310 series (0x01 still contains FIFO) */
    if(pSiS->VGAEngine == SIS_315_VGA)
        outSISIDXREG(SISPART1, 0x2e, sisReg->VBPart1[0x2e]);

    /* Pre-restore Part4 */
    outSISIDXREG(SISPART4, 0x0D, sisReg->VBPart4[0x0D]);
    outSISIDXREG(SISPART4, 0x0C, sisReg->VBPart4[0x0C]);

    if (!(sisReg->sisRegs3D4[0x30] & 0x03) &&
         (sisReg->sisRegs3D4[0x31] & 0x20))  {      /* disable CRT2 */
            SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
            return;
    }
d651 3
a653 5
    /* Restore Part1  */
    SetBlock(SISPART1, 0x02, Part1max, &(sisReg->VBPart1[0x02]));
    if(pSiS->VGAEngine == SIS_315_VGA) {
       SetBlock(SISPART1, 0x2C, 0x2D, &(sisReg->VBPart1[0x2C]));
       SetBlock(SISPART1, 0x35, 0x37, &(sisReg->VBPart1[0x35]));
d655 1
a655 20

    /* Restore Part2 */
    SetBlock(SISPART2, 0x00, Part2max, &(sisReg->VBPart2[0x00]));

    /* Restore Part3 */
    SetBlock(SISPART3, 0x00, Part3max, &(sisReg->VBPart3[0x00]));

    /* Restore Part4 */
    SetBlock(SISPART4, 0x0E, 0x11, &(sisReg->VBPart4[0x0E]));
    SetBlock(SISPART4, 0x13, Part4max, &(sisReg->VBPart4[0x13]));

    /* Post-restore Part4 (CRT2VCLK) */
    outSISIDXREG(SISPART4, 0x0A, sisReg->VBPart4[0x0A]);
    outSISIDXREG(SISPART4, 0x0B, sisReg->VBPart4[0x0B]);
    outSISIDXREG(SISPART4, 0x12, 0x00);
    outSISIDXREG(SISPART4, 0x12, sisReg->VBPart4[0x12]);

    SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
    SiS_DisplayOn(pSiS->SiS_Pr);
    SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
a657 1
/* Save LVDS bridge (+ Chrontel) register contents */
d659 1
a659 1
SiSLVDSChrontelSave(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d664 3
a666 27
    /* Save Part1 */
    for (i=0; i<0x46; i++)  {
        inSISIDXREG(SISPART1, i, sisReg->VBPart1[i]);
#ifdef TWDEBUG
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	                "LVDSSave: Part1Port 0x%02x = 0x%02x\n",
			i, sisReg->VBPart1[i]);
#endif
    }

    /* Save Chrontel registers */
    if (pSiS->VBFlags & VB_CHRONTEL) {
       if (pSiS->ChrontelType == CHRONTEL_700x) {
          for (i=0; i<0x1D; i++)  {
              sisReg->ch70xx[i] = SiS_GetCH700x(pSiS->SiS_Pr, ch700xidx[i]);
#ifdef TWDEBUG
	      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	                "LVDSSave: Chrontel 0x%02x = 0x%02x\n",
			ch700xidx[i], sisReg->ch70xx[i]);
#endif

	  }
       } else {
          for (i=0; i<34; i++)  {
              sisReg->ch70xx[i] = SiS_GetCH701x(pSiS->SiS_Pr, ch701xidx[i]);
          }
       }
d668 2
a673 1
/* Restore LVDS bridge (+ Chrontel) register contents */
d675 1
a675 1
SiSLVDSChrontelRestore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d678 1
a678 2
    int i;
    USHORT wtemp;
d680 11
a690 32
    SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
    if(pSiS->sishw_ext.jChipType == SIS_730) {
        outSISIDXREG(SISPART1, 0x00, 0x80);
    }

    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);

    if(pSiS->VBFlags & VB_CHRONTEL) {
       /* Restore Chrontel registers */
       if(pSiS->ChrontelType == CHRONTEL_700x) {
          for(i=0; i<0x11; i++) {
            wtemp = ((sisReg->ch70xx[i]) << 8) | (ch700xidx[i] & 0x00FF);
            SiS_SetCH700x(pSiS->SiS_Pr, wtemp);
          }
       } else {
          for(i=0; i<34; i++) {
            wtemp = ((sisReg->ch70xx[i]) << 8) | (ch701xidx[i] & 0x00FF);
            SiS_SetCH701x(pSiS->SiS_Pr, wtemp);
          }
       }
    }

    /* pre-restore Part1 */
    outSISIDXREG(SISPART1, 0x04, 0x00);
    outSISIDXREG(SISPART1, 0x05, 0x00);
    outSISIDXREG(SISPART1, 0x06, 0x00);
    outSISIDXREG(SISPART1, 0x00, sisReg->VBPart1[0]);
    if(pSiS->VGAEngine == SIS_300_VGA) {    
       outSISIDXREG(SISPART1, 0x01, (sisReg->VBPart1[1] | 0x80));
    } else {
       outSISIDXREG(SISPART1, 0x01, sisReg->VBPart1[1]);
    }
d694 1
a694 1
            SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
d697 21
a717 11

    /* Restore Part1 */
    if(pSiS->VGAEngine == SIS_300_VGA) {    
       outSISIDXREG(SISPART1, 0x02, (sisReg->VBPart1[2] | 0x40));
    } else {
       outSISIDXREG(SISPART1, 0x02, sisReg->VBPart1[2]);
    }
    SetBlock(SISPART1, 0x03, 0x23, &(sisReg->VBPart1[0x03]));
    if(pSiS->VGAEngine == SIS_315_VGA) {
         SetBlock(SISPART1, 0x2C, 0x2E, &(sisReg->VBPart1[0x2C]));
	 SetBlock(SISPART1, 0x35, 0x37, &(sisReg->VBPart1[0x35]));  /* Panel Link Scaler */
d719 3
d723 2
a724 9
    /* TW: For 550 DSTN registers */
    if (pSiS->DSTN) {
        SetBlock(SISPART1, 0x25, 0x2E, &(sisReg->VBPart1[0x25]));
	SetBlock(SISPART1, 0x30, 0x45, &(sisReg->VBPart1[0x30]));
    }

    SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
    SiS_DisplayOn(pSiS->SiS_Pr);
    SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
d727 3
a729 3
/* TW: Restore output selection registers (CR30, 31, 33, 35/38) */
void
SiSRestoreBridge(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d731 5
a735 2
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char temp = 0;
d737 8
a744 3
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d746 25
a770 7
   outSISIDXREG(SISCR, 0x30, sisReg->sisRegs3D4[0x30]);
   outSISIDXREG(SISCR, 0x31, sisReg->sisRegs3D4[0x31]);
   outSISIDXREG(SISCR, 0x33, sisReg->sisRegs3D4[0x33]);
   if(pSiS->Chipset != PCI_CHIP_SIS300) {
      switch(pSiS->VGAEngine) {
        case SIS_300_VGA: temp = 0x35; break;
        case SIS_315_VGA: temp = 0x38; break;
d772 7
a778 4
      if(temp) {
         outSISIDXREG(SISCR, temp, sisReg->sisRegs3D4[temp]);
      }
   }
d781 2
a782 2
unsigned int
SiSddc1Read(ScrnInfoPtr pScrn)
d784 1
a784 2
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char temp;
d786 2
a787 3
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d789 13
a801 3
    /* Wait until vertical retrace is in progress. */
    while(inSISREG(SISINPSTAT) & 0x08);
    while(!(inSISREG(SISINPSTAT) & 0x08));
d803 2
a804 2
    /* Get the result */
    inSISIDXREG(SISSR, 0x11, temp);
d806 2
a807 1
    return((temp & 0x02)>>1);
a809 2
#if 0  /* TW: I2C functions not in use */
/*
d811 1
a811 1
SiS_I2CGetBits(I2CBusPtr b, int *clock, int *data)
d813 3
a815 2
  SISPtr pSiS = SISPTR(xf86Screens[b->scrnIndex]);
  unsigned char val;
d817 2
a818 5
  outSISIDXREG(SISSR, 0x05, 0x86);
  inSISIDXREG(SISSR, pSiS->SiS_DDC2_Index, val);
  *clock = (val & pSiS->SiS_DDC2_Clk) != 0;
  *data  = (val & pSiS->SiS_DDC2_Data) != 0;
}
d820 4
a823 5
static void
SiS_I2CPutBits(I2CBusPtr b, int clock, int data)
{
  SISPtr pSiS = SISPTR(xf86Screens[b->scrnIndex]);
  unsigned char temp;
d825 13
a837 4
  outSISIDXREG(SISSR, 0x05, 0x86);
  inSISIDXREG(SISSR, pSiS->SiS_DDC2_Index, temp);

  temp &= ~(pSiS->SiS_DDC2_Clk | pSiS->SiS_DDC2_Data);
d839 2
a840 1
  temp |= ((clock ? pSiS->SiS_DDC2_Clk : 0) | (data ? pSiS->SiS_DDC2_Data : 0));
d842 2
a843 1
  outSISIDXREG(SISSR, pSiS->SiS_DDC2_Index, temp);
a844 1
*/
d846 3
a848 2
static Bool
SiS_I2CAddress(I2CDevPtr d, I2CSlaveAddr addr)
d850 1
a850 5
   I2CBusPtr b = d->pI2CBus;
   SISPtr pSiS = SISPTR(xf86Screens[b->scrnIndex]);
   SiS_SetSwitchDDC2(pSiS->SiS_Pr);
   return(SiS_I2C_Address(pSiS->SiS_Pr, addr));
}
d852 1
a852 7
static void
SiS_I2CStop(I2CDevPtr d)
{
  I2CBusPtr b = d->pI2CBus;
  SISPtr pSiS = SISPTR(xf86Screens[b->scrnIndex]);
  SiS_I2C_Stop(pSiS->SiS_Pr);
}
d854 4
a857 8
static Bool
SiS_I2CGetByte(I2CDevPtr d, I2CByte *data, Bool last)
{
  I2CBusPtr b = d->pI2CBus;
  SISPtr pSiS = SISPTR(xf86Screens[b->scrnIndex]);
  USHORT temp = SiS_I2C_GetByte(pSiS->SiS_Pr);
  if(temp == 0xffff) return FALSE;
  return TRUE;
a859 7
static Bool
SiS_I2CPutByte(I2CDevPtr d, I2CByte data)
{
  I2CBusPtr b = d->pI2CBus;
  SISPtr pSiS = SISPTR(xf86Screens[b->scrnIndex]);
  return(SiS_I2C_PutByte(pSiS->SiS_Pr, (USHORT)data));
}
d861 2
a862 2
Bool
SiSI2CInit(ScrnInfoPtr pScrn)
d864 1
d866 3
a868 4
    I2CBusPtr I2CPtr;
    USHORT temp, i;
    unsigned char buffer[256];
    xf86MonPtr    pMonitor;
d870 3
a872 2
    I2CPtr = xf86CreateI2CBusRec();
    if(!I2CPtr) return FALSE;
d874 3
a876 13
    pSiS->I2C = I2CPtr;

    I2CPtr->BusName    = "DDC";
    I2CPtr->scrnIndex  = pScrn->scrnIndex;
/*
    I2CPtr->I2CPutBits = SiS_I2CPutBits;
    I2CPtr->I2CGetBits = SiS_I2CGetBits;
*/
    I2CPtr->I2CPutByte = SiS_I2CPutByte;
    I2CPtr->I2CGetByte = SiS_I2CGetByte;
    I2CPtr->I2CAddress = SiS_I2CAddress;
    I2CPtr->I2CStop    = SiS_I2CStop;
    I2CPtr->AcknTimeout = 30;
d878 2
d881 1
d883 1
a883 76
    pSiS->SiS_Pr->SiS_DDC_Index = pSiS->SiS_DDC2_Index;
    pSiS->SiS_Pr->SiS_DDC_Data  = pSiS->SiS_DDC2_Data;
    pSiS->SiS_Pr->SiS_DDC_Clk   = pSiS->SiS_DDC2_Clk;
    pSiS->SiS_Pr->SiS_DDC_DataShift = 0x00;

    if (!xf86I2CBusInit(I2CPtr)) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    "Could not create I2C bus record\n");
	return FALSE;
    }

    return TRUE;
}
#endif

#if 0  /* TW: The following function should take a threshold value
        *     from predefined tables. This is only needed on some
	*     530 boards, which have an ESS sound device on-board.
	*     However, I don't know how to calculate the index to
	*     be submitted to this function.
	*/
unsigned short
SiS_CalcSpecial530Threshold(ScrnInfoPtr pScrn, DisplayModePtr mode, int index)
{
    SISPtr  pSiS = SISPTR(pScrn);
    static const unsigned char t640x480[3][24] = {
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,A9,   /* b4 - 9d - depth 8 */
	  0, 0,11,14,14, 0, 0, 0, 0, 0, 0,9D },
	{ 0, 0, 0, 0, 0,12,15, 0, 0, 0,92,91,   /* 9c - 85 - depth 16 */
	  0,31,31,31,31, 0, 0, 0, 0, 0, 0,85 },
	{ 0, 0, 0, 0, 0,17,22,25, 0, 0, 0,79,   /* 84 - ?  - depth 32 */
	  0,31,31, 0, 0, 0, 0, 0, 0, 0, 0,6d }
    }
    static const unsigned char t800x600[3][24] = {
        { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,61,
	  0,18,25,30,27,31,31,31, 0, 0, 0, 0 },
	{55, 0, 0, 0, 0, 9,10,15,18,19, 0, 0,
	... to be continued

    depthindex = (pSiS->CurrentLayout.bitsPerPixel + 1) >> 3;
    if(depthindex == 3) return(0);
    if(depthindex == 4) depthindex--;
    depthindex--;

    switch(mode->HDisplay) {
    case 640:
       if(mode->VDisplay == 480) {
          return(t640x480[depthindex][index];
       } else return(0);
    case 800:
       if(mode->VDisplay == 600) {
          return(t800x600[depthindex][index];
       } else return(0);
    case 1024:
       if(mode->VDisplay == 768) {
          return(t1024x768[depthindex][index];
       } else return(0);
    case 1280:
       if(mode->VDisplay == 1024) {
          return(t1280x1024[depthindex][index];
       } else return(0);
    case 1600:
       if(mode->VDisplay == 1200) {
          return(t1600x1200[depthindex][index];
       } else return(0);
    default: return(0);
    }
}
#endif

/* TW: Stub */
static void
SiSThreshold(ScrnInfoPtr pScrn, DisplayModePtr mode,
             unsigned short *Low, unsigned short *High)
{
    return;
a885 1

a886 1
/* TW: Not for 530/620 if UMA (on these, the mclk is stored in SR10) */
d890 2
a891 2
    int mclk;
    unsigned char Num, Denum, Base;
d893 1
d895 5
d903 2
a904 3
        /* Numerator */
        inSISIDXREG(SISSR, MemClock0, Num);
        mclk = 14318 * ((Num & 0x7f) + 1);
d907 2
a908 2
	inSISIDXREG(SISSR, MemClock1, Denum);
        mclk = mclk / ((Denum & 0x1f) + 1);
d910 8
a917 2
        /* Divider. Doesn't seem to work for mclk in older cards */
        if((Num & 0x80) != 0)  mclk *= 2;
d919 4
a922 5
        /* Post-scaler. Values' meaning depends on SR13 bit 7  */
	inSISIDXREG(SISSR, ClockBase, Base);
        if((Base & 0x80) == 0) {
            mclk = mclk / (((Denum & 0x60) >> 5) + 1);
        } else {
d924 2
a925 2
            if ((Denum & 0x60) == 0x40)  mclk /= 6;
            if ((Denum & 0x60) == 0x60)  mclk /= 8;
a930 6
    case PCI_CHIP_SIS550:
    case PCI_CHIP_SIS650:
    case PCI_CHIP_SIS315:
    case PCI_CHIP_SIS315H:
    case PCI_CHIP_SIS315PRO:
    case PCI_CHIP_SIS330:
d932 2
a933 2
	inSISIDXREG(SISSR, 0x28, Num);
        mclk = 14318 * ((Num & 0x7f) + 1);
d936 2
a937 2
	inSISIDXREG(SISSR, 0x29, Denum);
        mclk = mclk / ((Denum & 0x1f) + 1);
d940 3
a942 1
        if((Num & 0x80) != 0)  mclk *= 2;
d945 1
a945 1
        if((Denum & 0x80) == 0) {
d947 2
a948 1
        } else {
a952 3
    	xf86DrvMsg(pSiS->pScrn->scrnIndex, X_ERROR,
		"Internal error: SiSMClk() called with invalid chipset (0x%x)\n",
		pSiS->Chipset);
a958 46
/* TW: This estimates the CRT2 clock we are going to use.
 *     The total bandwidth is to be reduced by the value
 *     returned here in order to get an idea of the maximum
 *     dotclock left for CRT1.
 *     Since we don't know yet, what mode the user chose,
 *     we return the maximum dotclock used by
 *     - either the LCD attached, or
 *     - TV
 *     For VGA2, we share the bandwith equally.
 */
static int
SiSEstimateCRT2Clock(ScrnInfoPtr pScrn)
{
        SISPtr pSiS = SISPTR(pScrn);

	if(pSiS->VBFlags & CRT2_LCD) {
  	       if(pSiS->VBLCDFlags & (VB_LCD_320x480 | VB_LCD_800x600 | VB_LCD_640x480))
	           return 40000;
	       else if(pSiS->VBLCDFlags & (VB_LCD_1024x768 | VB_LCD_1024x600))
	           return 65000;
	       else if(pSiS->VBLCDFlags & (VB_LCD_1152x768 | VB_LCD_1280x1024 | VB_LCD_1280x960))
		   return 108000;
	       else if(pSiS->VBLCDFlags & VB_LCD_1400x1050)
		   return 122000;
	       else if(pSiS->VBLCDFlags & VB_LCD_1600x1200)
		   return 162000;
	       else
	           return 108000;
	} else if(pSiS->VBFlags & CRT2_TV) {
	    if(pSiS->VBFlags & VB_CHRONTEL) {
	        switch(pSiS->VGAEngine) {
		case SIS_300_VGA:
                   return 50000;
		case SIS_315_VGA:
		default:
		   return 70000;
		}
	    } else if(pSiS->VBFlags & VB_SISBRIDGE) {
	        return 70000;
	    }
	}

	return 0;
}

/* Calculate the maximum dotclock */
d960 1
a960 1
{
d962 1
a962 3
#ifdef SISDUALHEAD
        SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
d966 3
a968 5
        int             bpp = pSiS->CurrentLayout.bitsPerPixel;
	int             bytesperpixel = (bpp + 7) / 8;
        float   	magic=0.0, total, crt2used;
	int		crt2clock, max=0;
        const float     magic300[4] = { 1.2,      1.368421, 2.263158, 1.2};
a969 2
	const float     magic315[4] = { 1.2,      1.368421, 1.368421, 1.2 };
	const float     magic550[4] = { 1.441177, 1.441177, 2.588235, 1.441177 };
d972 3
a974 1

d976 7
a982 22
	        total = ((mclk * (bus / 8)) * 0.7) / bytesperpixel;
		if(total > 135000) total = 135000;
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			"Maximum pixel clock at %d bpp is %g MHz\n",
			bpp, total/1000);
                return(int)(total);

        case PCI_CHIP_SIS6326:
		total = ((mclk * (bus / 8)) * 0.7) / bytesperpixel;
		if(total > 175500) total = 175500;
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			"Maximum pixel clock at %d bpp is %g MHz\n",
			bpp, total/1000);
		return(int)(total);

        case PCI_CHIP_SIS530:
	        total = ((mclk * (bus / 8)) * 0.7) / bytesperpixel;
		if(total > 230000) total = 230000;
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			"Maximum pixel clock at %d bpp is %g MHz\n",
			bpp, total/1000);
		return(int)(total);
d987 5
a991 29
	case PCI_CHIP_SIS315:
	case PCI_CHIP_SIS315H:
	case PCI_CHIP_SIS315PRO:
	case PCI_CHIP_SIS550:
	case PCI_CHIP_SIS650:
	case PCI_CHIP_SIS330:
	        switch(pSiS->Chipset) {
        	case PCI_CHIP_SIS300:
	            magic = magic300[bus/64];
		    max = 540000;
                    break;
        	case PCI_CHIP_SIS540:
       	 	case PCI_CHIP_SIS630:
		    magic = magic630[bus/64];
		    max = 540000;
                    break;
		case PCI_CHIP_SIS315:
		case PCI_CHIP_SIS315H:
		case PCI_CHIP_SIS315PRO:
		case PCI_CHIP_SIS330:
		    magic = magic315[bus/64];
		    max = 780000;
		    break;
		case PCI_CHIP_SIS550:
		case PCI_CHIP_SIS650:
		    magic = magic550[bus/64];
		    max = 780000;
                }

d994 9
a1002 40

                total = mclk * bus / bpp;

                xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			"Memory bandwidth at %d bpp is %g MHz\n", bpp, total/1000);

                if(pSiS->VBFlags & CRT2_ENABLE)  {

		    crt2used = 0.0;
		    crt2clock = SiSEstimateCRT2Clock(pScrn);
		    if(crt2clock) {
		    	crt2used = crt2clock + 2000;
		    }

#ifdef SISDUALHEAD
		    if((pSiS->DualHeadMode) && (pSiSEnt)) {

		        if(!pSiS->SecondHead) {

			     /* TW: First head = CRT2 */

			     if(crt2clock) {
			        /* TW: We use the mem bandwidth as max clock; this
				 *     might exceed the 70% limit a bit, but that
				 *     does not matter; we take care of that limit
				 *     when we calc CRT1. Overall, we might use up
				 *     to 85% of the memory bandwidth, which seems
				 *     enough to use accel and video.
				 *     The "* macic" is just to compensate the
				 *     calculation below.
				*/
			        total = crt2used * magic;
				xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	           "Bandwidth reserved for CRT2 is %g Mhz\n",
				      crt2used/1000);
			     } else {
			        /*  We don't know about the second head's
				 *  depth yet. So we assume it uses the
			         *  same.
			         */
d1004 1
a1004 50
				xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	           "Bandwidth reserved for CRT2 is %g Mhz\n",
				      total/1000);
                             }

			} else {

			     /* TW: Second head = CRT1 */

			     /*     Now We know about the first head's depth,
			      *     so we can calculate more accurately.
			      */

			     if(crt2clock) {
			        total -= (crt2used * pSiSEnt->pScrn_1->bitsPerPixel / bpp);
				xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	           "Bandwidth reserved for CRT2 at %d bpp is %g Mhz\n",
				      bpp,
				      (crt2used * pSiSEnt->pScrn_1->bitsPerPixel / bpp)/1000);
			     } else {
			        total -= (pSiSEnt->maxUsedClock * pSiSEnt->pScrn_1->bitsPerPixel / bpp);
				xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	           "Bandwidth reserved for CRT2 at %d bpp is %d Mhz\n",
				      bpp,
				      (pSiSEnt->maxUsedClock * pSiSEnt->pScrn_1->bitsPerPixel / bpp)/1000);
			     }

			     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			        "Bandwidth available for CRT1 is %g MHz\n", total/1000);

			}

		    } else {
#endif
			if(crt2clock) {
			    total -= crt2used;
			    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	       "Bandwidth reserved for CRT2 is %g Mhz\n", crt2used/1000);
			} else {
                            total /= 2;
			    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	       "Bandwidth reserved for CRT2 is %g Mhz\n", total/1000);
			}

			xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			  "Bandwidth available for CRT1 is %g MHz\n", total/1000);
#ifdef SISDUALHEAD
                    }
#endif

d1006 1
a1006 3
		total /= magic;
		if(total > (max / 2)) total = max / 2;
                return (int)(total);
d1008 2
d1011 1
a1011 1
                return 135000;    /* guessed */
a1014 8
/* TW: Load the palette. We do this for all supported color depths
 *     in order to support gamma correction. We hereby convert the
 *     given colormap to a complete 24bit color palette and enable
 *     the correspoding bit in SR7 to enable the 24bit lookup table.
 *     Gamma correction is only supported on CRT1.
 *     Why are there 6-bit-RGB values submitted even if bpp is 16 and
 *     weight is 565? (Maybe because rgbBits is 6?)
 */
d1016 2
a1017 2
SISLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices, LOCO *colors,
               VisualPtr pVisual)
d1020 1
a1020 1
        int     i, j, index;
d1023 20
a1042 72

#ifdef SISDUALHEAD
        /* TW: No palette changes on CRT2 if in dual head mode */
        if((pSiS->DualHeadMode) && (!pSiS->SecondHead)) return;
#endif

        switch(pSiS->CurrentLayout.depth) {
#ifdef SISGAMMA
          case 15:
	     orSISIDXREG(SISSR, 0x07, 0x04);
	     for(i=0; i<numColors; i++) {
                index = indices[i];
		if(index < 32) {   /* Paranoia */
		   for(j=0; j<8; j++) {
		      outSISREG(SISCOLIDX, (index * 8) + j);
                      outSISREG(SISCOLDATA, colors[index].red << (8- pScrn->rgbBits));
                      outSISREG(SISCOLDATA, colors[index].green << (8 - pScrn->rgbBits));
                      outSISREG(SISCOLDATA, colors[index].blue << (8 - pScrn->rgbBits));
		   }
		}
             }
	     break;
	  case 16:
             orSISIDXREG(SISSR, 0x07, 0x04);
	     for(i=0; i<numColors; i++) {
                index = indices[i];
		if(index < 64) {  /* Paranoia */
		   for(j=0; j<4; j++) {
		      outSISREG(SISCOLIDX, (index * 4) + j);
                      outSISREG(SISCOLDATA, colors[index/2].red << (8 - pScrn->rgbBits));
                      outSISREG(SISCOLDATA, colors[index].green << (8 - pScrn->rgbBits));
                      outSISREG(SISCOLDATA, colors[index/2].blue << (8 - pScrn->rgbBits));
		   }
		}
             }
	     break;
          case 24:
	     orSISIDXREG(SISSR, 0x07, 0x04);
             for(i=0; i<numColors; i++)  {
                index = indices[i];
		if(index < 256) {   /* Paranoia */
                   outSISREG(SISCOLIDX, index);
                   outSISREG(SISCOLDATA, colors[index].red);
                   outSISREG(SISCOLDATA, colors[index].green);
                   outSISREG(SISCOLDATA, colors[index].blue);
		}
             }
	     break;
#endif
	  default:
	     if(pScrn->rgbBits == 8)
	        orSISIDXREG(SISSR, 0x07, 0x04);
	     else
	        andSISIDXREG(SISSR, 0x07, ~0x04);
             for(i=0; i<numColors; i++)  {
                index = indices[i];
                outSISREG(SISCOLIDX, index);
                outSISREG(SISCOLDATA, colors[index].red >> (8 - pScrn->rgbBits));
                outSISREG(SISCOLDATA, colors[index].green >> (8 - pScrn->rgbBits));
                outSISREG(SISCOLDATA, colors[index].blue >> (8 - pScrn->rgbBits));
             }
	}

        switch(pSiS->VGAEngine) {
            case SIS_300_VGA:
            case SIS_315_VGA:
                if(pSiS->VBFlags & CRT2_ENABLE) {
		    /* TW: Only the SiS bridges support a CRT2 palette */
		    if(pSiS->VBFlags & VB_SISBRIDGE) {
                        (*pSiS->LoadCRT2Palette)(pScrn, numColors, indices,
                                                 colors, pVisual);
		    }  
a1045 1

d1049 1
a1049 1
SiS301LoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
d1056 9
d1066 151
a1216 6
        for(i=0; i<numColors; i++)  {
                index = indices[i];
                outSISREG(SISCOL2IDX,  index);
                outSISREG(SISCOL2DATA, colors[index].red);
                outSISREG(SISCOL2DATA, colors[index].green);
                outSISREG(SISCOL2DATA, colors[index].blue);
d1218 7
d1227 31
a1258 2
#ifdef DEBUG
/* TW: Debug function to dump registers */
d1260 4
a1263 4
{
    SISPtr  pSiS = SISPTR(pScrn);
    int     i, max3c4, min3d4, max3d4;
    unsigned char   temp;
d1279 1
a1279 1
	    max3c4 = 0x3D;
a1282 10
	case PCI_CHIP_SIS550:
	case PCI_CHIP_SIS650:
	case PCI_CHIP_SIS315:
	case PCI_CHIP_SIS315H:
	case PCI_CHIP_SIS315PRO:
	case PCI_CHIP_SIS330:
            max3c4 = 0x3D;
            max3d4 = 0x5f;
            min3d4 = 0x30;
            break;
d1289 1
d1292 1
a1292 1

d1301 4
a1304 1
        inSISIDXREG(SISGR, i, temp);
d1313 4
a1316 1
        inSISIDXREG(SISSR, i, temp);
d1321 12
a1332 5
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
    for (i=5; i<=max3c4; i++)  {
        inSISIDXREG(SISSR, i, temp);
d1341 2
a1342 1
        inSISIDXREG(SISCR, i, temp);
d1345 4
a1348 4
    /* dump extended CR */
    for (i=min3d4; i<=max3d4; i++)  {
        inSISIDXREG(SISCR, i, temp);
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[%2x]=%2x\n", i, temp);
d1350 2
d1353 1
a1353 1
#endif
d1361 30
a1390 18
      case PCI_CHIP_SIS550:
      case PCI_CHIP_SIS650:
      case PCI_CHIP_SIS315:
      case PCI_CHIP_SIS315H:
      case PCI_CHIP_SIS315PRO:
      case PCI_CHIP_SIS330:
        pSiS->MaxClock               = SiSMemBandWidth(pScrn);
        pSiS->SiSSave                = SiS310Save;
        pSiS->SiSSave2               = SiS301Save;
        pSiS->SiSSave3               = SiS301BSave;
        pSiS->SiSSaveLVDSChrontel    = SiSLVDSChrontelSave;
        pSiS->SiSRestore             = SiS310Restore;
        pSiS->SiSRestore2            = SiS301Restore;
        pSiS->SiSRestore3            = SiS301BRestore;
        pSiS->SiSRestoreLVDSChrontel = SiSLVDSChrontelRestore;
        pSiS->LoadCRT2Palette        = SiS301LoadPalette;
        pSiS->SetThreshold           = SiSThreshold;
	pSiS->i2cInit		     = NULL; /* SiSI2CInit;  */
d1392 5
a1396 15
      case PCI_CHIP_SIS300:
      case PCI_CHIP_SIS630:
      case PCI_CHIP_SIS540:
        pSiS->MaxClock               = SiSMemBandWidth(pScrn);
        pSiS->SiSSave                = SiS300Save;
        pSiS->SiSSave2               = SiS301Save;
        pSiS->SiSSave3               = SiS301BSave;
        pSiS->SiSSaveLVDSChrontel    = SiSLVDSChrontelSave;
        pSiS->SiSRestore             = SiS300Restore;
        pSiS->SiSRestore2            = SiS301Restore;
        pSiS->SiSRestore3            = SiS301BRestore;
        pSiS->SiSRestoreLVDSChrontel = SiSLVDSChrontelRestore;
        pSiS->LoadCRT2Palette        = SiS301LoadPalette;
        pSiS->SetThreshold           = SiSThreshold;
	pSiS->i2cInit		     = NULL;  /* SiSI2CInit;  */
d1398 5
a1402 9
      case PCI_CHIP_SIS5597:
      case PCI_CHIP_SIS6326:
      case PCI_CHIP_SIS530:
      default:
        pSiS->MaxClock               = SiSMemBandWidth(pScrn);
        pSiS->SiSRestore             = SiSRestore;
        pSiS->SiSSave                = SiSSave;
        pSiS->SetThreshold           = SiSThreshold;
	pSiS->i2cInit		     = NULL;
d1404 5
a1419 41
}

void
SiS6326SetTVReg(ScrnInfoPtr pScrn, CARD8 index, CARD8 data)
{
    SISPtr  pSiS = SISPTR(pScrn);
    outSISIDXREG(SISCR, 0xE0, index);
    outSISIDXREG(SISCR, 0xE1, data);
#ifdef TWDEBUG
    xf86DrvMsg(0, X_INFO, "SiS6326: Setting Tv %02x to %02x\n", index, data);
#endif
}

unsigned char
SiS6326GetTVReg(ScrnInfoPtr pScrn, CARD8 index)
{
   SISPtr  pSiS = SISPTR(pScrn);
   unsigned char data;

   outSISIDXREG(SISCR, 0xE0, index);
   inSISIDXREG(SISCR, 0xE1, data);
   return(data);
}

void
SiS6326SetXXReg(ScrnInfoPtr pScrn, CARD8 index, CARD8 data)
{
    SISPtr  pSiS = SISPTR(pScrn);
    outSISIDXREG(SISCR, 0xE2, index);
    outSISIDXREG(SISCR, 0xE3, data);
}

unsigned char
SiS6326GetXXReg(ScrnInfoPtr pScrn, CARD8 index)
{
   SISPtr  pSiS = SISPTR(pScrn);
   unsigned char data;

   outSISIDXREG(SISCR, 0xE2, index);
   inSISIDXREG(SISCR, 0xE3, data);
   return(data);
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_dac.c,v 1.57 2004/02/02 03:55:29 dawes Exp $ */
d3 2
a4 1
 * DAC helper functions (Save/Restore, MemClk, etc)
d6 9
a14 1
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria.
d16 7
a22 38
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement: "This product includes
 *    software developed by Thomas Winischhofer, Vienna, Austria."
 * 4) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author:  	Thomas Winischhofer <thomas@@winischhofer.net>
 *
 * SiS_compute_vclk(), SiSCalcClock() and parts of SiSMclk():
 * Copyright (C) 1998, 1999 by Alan Hourihane, Wigan, England
 * Written by:
 *	 Alan Hourihane <alanh@@fairlite.demon.co.uk>,
 *       Mike Chapman <mike@@paranoia.com>,
 *       Juanjo Santamarta <santamarta@@ctv.es>,
 *       Mitani Hiroshi <hmitani@@drl.mei.co.jp>,
 *       David Thomas <davtom@@dream.org.uk>,
 *	 Thomas Winischhofer <thomas@@winischhofer.net>.
 * Licensed under the terms of the XFree86 license
 * (http://www.xfree86.org/current/LICENSE1.html)
d24 6
d49 1
a49 1
static void SiS315Save(ScrnInfoPtr pScrn, SISRegPtr sisReg);
d54 1
a54 1
static void SiS315Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg);
d60 2
d63 3
d76 2
a77 2
      0x06,0x07,0x08,0x15,0x1f,0x0c,0x0d,0x0e,0x0f,0x10,0x66
   };  
a124 1

d127 2
a128 2
    if((f > 250.0) || (f < 18.75))
       return 0;
d133 10
a142 10
    while(x > 31.25) {
       y *= 2.0;
       x /= 2.0;
    }
    if(x >= 18.25) {
       x *= 8.0;
       y = 8.0 / y;
    } else if(x >= 15.625) {
       x *= 12.0;
       y = 12.0 / y;
d146 3
a148 3
    if(t == (float) 1.5) {
       *out_div = 2;
       t *= 2.0;
d150 1
a150 1
       *out_div = 1;
d152 3
a154 3
    if(t > (float) 4.0) {
       *out_sbit = 1;
       t /= 2.0;
d156 1
a156 1
       *out_sbit = 0;
d161 12
a172 12
    for(dn = 2; dn <= 32; dn++) {
       for(n = 1; n <= 128; n++) {
          error = x;
          error -= ((float) 14.318 * (float) n / (float) dn);
          if(error < (float) 0)
             error = -error;
          if(error < min_error) {
             min_error = error;
             best_n = n;
             best_dn = dn;
          }
       }
d189 1
a189 1
    double abest = 42.0;
a192 3
#ifdef DEBUG
    double bestFout;
#endif
d197 1
a197 1
     *  M       = Numerator [1:128]
d219 1
a219 1
  int M_min = 2;
d221 3
a223 1

d225 49
a273 44

  if(pSiS->Chipset == PCI_CHIP_SIS5597 || pSiS->Chipset == PCI_CHIP_SIS6326) {

     int low_N = 2;
     int high_N = 5;

     PSN = 1;
     P = 1;
     if(target < MAX_VCO_5597 / 2)  P = 2;
     if(target < MAX_VCO_5597 / 3)  P = 3;
     if(target < MAX_VCO_5597 / 4)  P = 4;
     if(target < MAX_VCO_5597 / 6)  P = 6;
     if(target < MAX_VCO_5597 / 8)  P = 8;

     Fvco = P * target;

     for(N = low_N; N <= high_N; N++) {

         double M_desired = Fvco / Fref * N;
         if(M_desired > M_max * max_VLD)  continue;

         if(M_desired > M_max) {
            M = M_desired / 2 + 0.5;
            VLD = 2;
         } else {
            M = Fvco / Fref * N + 0.5;
            VLD = 1;
         }

         Fout = (double)Fref * (M * VLD)/(N * P);

         error = (target - Fout) / target;
         aerror = (error < 0) ? -error : error;
         if(aerror < abest) {
            abest = aerror;
            bestM = M;
            bestN = N;
            bestP = P;
            bestPSN = PSN;
            bestVLD = VLD;
#ifdef DEBUG
            bestFout = Fout;
#endif	    
         }
d275 56
a330 58

  } else {

     for(PSNx = 0; PSNx <= MAX_PSN ; PSNx++) {

        int low_N, high_N;
        double FrefVLDPSN;

        PSN = !PSNx ? 1 : 4;

        low_N = 2;
        high_N = 32;

        for(VLD = 1 ; VLD <= max_VLD ; VLD++) {

           FrefVLDPSN = (double)Fref * VLD / PSN;

	   for(N = low_N; N <= high_N; N++) {
              double tmp = FrefVLDPSN / N;

              for(P = 1; P <= 4; P++) {
                 double Fvco_desired = target * ( P );
                 double M_desired = Fvco_desired / tmp;

                 /* Which way will M_desired be rounded?
                  *  Do all three just to be safe.
                  */
                 int M_low = M_desired - 1;
                 int M_hi = M_desired + 1;

                 if(M_hi < M_min || M_low > M_max) continue;

		 if(M_low < M_min)  M_low = M_min;

		 if(M_hi > M_max)   M_hi = M_max;

                 for(M = M_low; M <= M_hi; M++) {
                    Fvco = tmp * M;
                    if(Fvco <= MIN_VCO) continue;
                    if(Fvco > MAX_VCO)  break;

                    Fout = Fvco / ( P );

                    error = (target - Fout) / target;
                    aerror = (error < 0) ? -error : error;
                    if(aerror < abest) {
                       abest = aerror;
                       bestM = M;
                       bestN = N;
                       bestP = P;
                       bestPSN = PSN;
                       bestVLD = VLD;
#ifdef DEBUG
                       bestFout = Fout;
#endif
                    }
#ifdef TWDEBUG
                    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,3,
d333 1
a333 1
                    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,3,
d335 5
a339 6
#endif
                 }
              }
           }
        }
     }
d342 5
a346 5
  vclk[Midx]   = bestM;
  vclk[Nidx]   = bestN;
  vclk[VLDidx] = bestVLD;
  vclk[Pidx]   = bestP;
  vclk[PSNidx] = bestPSN;
d348 1
a348 1
  PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
d350 1
a350 1
                (float)(clock / 1000.), vclk[Midx], vclk[Nidx], vclk[VLDidx],
d352 1
a352 1
  PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
d354 1
a354 1
  PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
d372 1
a372 1
    switch(pSiS->Chipset) {
d386 6
a391 2
    for(i = 0x00; i <= max; i++) {
       inSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
d393 1
a393 1
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d399 3
a401 3
    for(i = 0x00; i <= 0x3f; i++) {
       inSISIDXREG(SISCR, i, max);
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d415 1
a415 1
          sisReg->sis6326tv[i] = SiS6326GetTVReg(pScrn, i);
d417 1
a417 1
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d430 3
d441 1
a441 1
    switch(pSiS->Chipset) {
d462 27
d490 14
a503 3
    for(i = 0x06; i <= max; i++) {
       if((i == 0x13) || (i == 0x2a) || (i == 0x2b)) continue;
       outSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
d523 1
a523 1
          SiS6326SetTVReg(pScrn, i, sisReg->sis6326tv[i]);
d525 1
a525 1
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d559 2
a560 2
    for(i = 0x00; i <= 0x3D; i++) {
       inSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
d562 1
a562 1
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d568 2
a569 2
    for(i = 0x00; i < 0x40; i++)  {
       inSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
d571 1
a571 1
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d575 1
a575 1
    
d595 6
a600 6
       if(pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
          (*pSiS->SiSSaveLVDSChrontel)(pScrn, sisReg);
       if(pSiS->VBFlags & VB_301)
          (*pSiS->SiSSave2)(pScrn, sisReg);
       if(pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV))
          (*pSiS->SiSSave3)(pScrn, sisReg);
d609 1
a609 1
       pSiS->BIOSModeSave = SiS_GetSetModeID(pScrn,0xFF);
d633 1
a633 1
    /* Wait for accelerator to finish on-going drawing operations. */
d636 3
a638 3
       while ( (MMIO_IN16(pSiS->IOBase, 0x8242) & 0xE000) != 0xE000){};
       while ( (MMIO_IN16(pSiS->IOBase, 0x8242) & 0xE000) != 0xE000){};
       while ( (MMIO_IN16(pSiS->IOBase, 0x8242) & 0xE000) != 0xE000){};
d640 2
a641 2

    if(!(pSiS->UseVESA)) {
d643 2
a644 2
          SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
          SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
d650 1
a650 1
       outSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
d654 7
a660 7
       unsigned char val;
       inSISIDXREG(SISCR, 0x1A, val);
       if(val == sisReg->sisRegs3D4[0x19])
	  outSISIDXREG(SISCR, 0x1A, sisReg->sisRegs3D4[0x19]);
       inSISIDXREG(SISCR,0x19,val);
       if(val == sisReg->sisRegs3D4[0x1A])
          outSISIDXREG(SISCR, 0x19, sisReg->sisRegs3D4[0x1A]);
d665 2
a666 2
       sisReg->sisRegs3C4[0x20] |= 0x20;
       outSISIDXREG(SISSR, 0x20, sisReg->sisRegs3C4[0x20]);
d669 2
a670 2
    /* If TQ is switched on, don't switch it off ever again!
     * Therefore, always restore registers with TQ enabled.
d673 3
a675 3
       temp = (pScrn->videoRam/64) - 8;
       sisReg->sisRegs3C4[0x26] = temp & 0xFF;
       sisReg->sisRegs3C4[0x27] = ((temp >> 8) & 3) | 0xF0;
d679 12
a690 12
    for(i = 0x06; i <= 0x3D; i++) {
       temp = sisReg->sisRegs3C4[i];
       if(!(pSiS->UseVESA)) {
          if(pSiS->VBFlags & VB_LVDS) {
             if(i == 0x11) {
	        inSISIDXREG(SISSR,0x11,temp);
	    	temp &= 0x0c;
		temp |= (sisReg->sisRegs3C4[i] & 0xf3);
	     }
          }
       }
       outSISIDXREG(SISSR, i, temp);
d692 3
a694 3

    /* Restore VCLK and ECLK */
    if(pSiS->VBFlags & (VB_LVDS | VB_301B | VB_301C)) {
d708 1
a708 1
    if(pSiS->VBFlags & (VB_LVDS | VB_301B | VB_301C)) {
d719 1
a719 1

d721 2
a722 2
    outSISREG(SISMISCW, sisReg->sisRegs3C2);

d732 1
a732 1
       }
d734 1
a734 1

d742 1
a742 1
       }
d747 7
a753 7
    if(!(pSiS->UseVESA)) {
       if(pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
          (*pSiS->SiSRestoreLVDSChrontel)(pScrn, sisReg);
       if(pSiS->VBFlags & VB_301)
          (*pSiS->SiSRestore2)(pScrn, sisReg);
       if(pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV))
          (*pSiS->SiSRestore3)(pScrn, sisReg);
d755 1
a755 1

d764 1
a764 1
       SiS_GetSetModeID(pScrn,pSiS->BIOSModeSave);
d767 1
a767 1
/* Save SiS315 series register contents */
d769 1
a769 1
SiS315Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d775 1
a775 1
    		"SiS315Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n"));
d782 6
a787 2
    for(i = 0x00; i <= 0x3F; i++) {
       inSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
d789 1
a789 1
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d794 1
a794 1
    /* Save command queue location */
d798 6
a803 2
    for(i = 0x00; i <= 0x7a; i++)  {
       inSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
d805 1
a805 1
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
a809 18
    /* Save video capture registers */
    for(i = 0x00; i <= 0x4f; i++)  {
       inSISIDXREG(SISCAP, i, sisReg->sisCapt[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"Capt%02X Contents - %02X \n", i,sisReg->sisCapt[i]);
#endif
    }

    /* Save video playback registers */
    for(i = 0x00; i <= 0x3f; i++)  {
       inSISIDXREG(SISVID, i, sisReg->sisVid[i]);
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"Vid%02X Contents - %02X \n", i,sisReg->sisVid[i]);
#endif
    }

d811 1
a811 1
    sisReg->sisRegs3C2 = inSISREG(SISMISCR);
d815 1
a815 1
    if(!pSiS->UseVESA) {
d817 6
a822 6
       if(pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
          (*pSiS->SiSSaveLVDSChrontel)(pScrn, sisReg);
       if(pSiS->VBFlags & VB_301)
          (*pSiS->SiSSave2)(pScrn, sisReg);
       if(pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV))
          (*pSiS->SiSSave3)(pScrn, sisReg);
d831 1
a831 6
       pSiS->BIOSModeSave = SiS_GetSetModeID(pScrn,0xFF);

#ifdef TWDEBUG
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
    	"BIOS mode ds:449 = 0x%x\n", pSiS->BIOSModeSave);
#endif
d834 1
a834 1
/* Restore SiS315/330 series register contents */
d836 1
a836 1
SiS315Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d842 1
a842 1
                "SiS315Restore(ScrnInfoPtr pScrn, SISRegPtr sisReg)\n");
d848 1
a848 1
    /* Wait for accelerator to finish on-going drawing operations. */
d850 9
a858 4
    if(temp & (0x40|0x10|0x02))  {	/* 0x40 = 2D, 0x10 = 3D enabled*/
       while ( (MMIO_IN32(pSiS->IOBase, 0x85CC) & 0x80000000) != 0x80000000){};
       while ( (MMIO_IN32(pSiS->IOBase, 0x85CC) & 0x80000000) != 0x80000000){};
       while ( (MMIO_IN32(pSiS->IOBase, 0x85CC) & 0x80000000) != 0x80000000){};
d861 7
a867 1
    /* We reset the command queue before restoring.
a875 15
    /* Restore extended CR registers */
    for(i = 0x19; i < 0x5C; i++)  {
       outSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
    }
    if(pSiS->sishw_ext.jChipType < SIS_661) {
       outSISIDXREG(SISCR, 0x79, sisReg->sisRegs3D4[0x79]);
    }
    outSISIDXREG(SISCR, pSiS->myCR63, sisReg->sisRegs3D4[pSiS->myCR63]);

    /* Leave PCI_IO_ENABLE on if accelerators are on (Is this required?) */
    if(sisReg->sisRegs3C4[0x1e] & 0x50) {  /*0x40=2D, 0x10=3D*/
       sisReg->sisRegs3C4[0x20] |= 0x20;
       outSISIDXREG(SISSR, 0x20, sisReg->sisRegs3C4[0x20]);
    }

d877 13
a889 5
    if(pSiS->sishw_ext.jChipType >= SIS_661) {
       sisReg->sisRegs3C4[0x11] &= 0x0f;
    }
    for(i = 0x06; i <= 0x3F; i++) {
       outSISIDXREG(SISSR, i, sisReg->sisRegs3C4[i]);
d891 1
a891 1
    /* Restore VCLK and ECLK */
d894 22
a915 22
       orSISIDXREG(SISSR,0x31,0x20);
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x80);
       andSISIDXREG(SISSR,0x31,0xcf);
       orSISIDXREG(SISSR,0x31,0x10);
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x80);
       andSISIDXREG(SISSR,0x31,0xcf);
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x01);
       outSISIDXREG(SISSR,0x31,0x20);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
       outSISIDXREG(SISSR,0x31,0x10);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
       outSISIDXREG(SISSR,0x31,0x00);
       outSISIDXREG(SISSR,0x2e,sisReg->sisRegs3C4[0x2e]);
       outSISIDXREG(SISSR,0x2f,sisReg->sisRegs3C4[0x2f]);
d917 3
a919 3
       outSISIDXREG(SISSR,0x2b,sisReg->sisRegs3C4[0x2b]);
       outSISIDXREG(SISSR,0x2c,sisReg->sisRegs3C4[0x2c]);
       outSISIDXREG(SISSR,0x2d,0x01);
d922 1
a922 2
#ifndef SISVRAMQ
    /* Initialize read/write pointer for command queue */
d924 1
a924 2
#endif
    /* Restore queue location */
d931 7
a937 7
    if(!(pSiS->UseVESA)) {
       if(pSiS->VBFlags & (VB_LVDS|VB_CHRONTEL))
          (*pSiS->SiSRestoreLVDSChrontel)(pScrn, sisReg);
       if(pSiS->VBFlags & VB_301)
          (*pSiS->SiSRestore2)(pScrn, sisReg);
       if(pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV))
          (*pSiS->SiSRestore3)(pScrn, sisReg);
d951 1
d953 1
a953 1
SiSVBSave(ScrnInfoPtr pScrn, SISRegPtr sisReg, int p1, int p2, int p3, int p4)
d957 17
d975 2
a976 2
    for(i=0; i<=p1; i++)  {
       inSISIDXREG(SISPART1, i, sisReg->VBPart1[i]);
d978 1
a978 1
       xf86DrvMsg(0, X_INFO, "301xSave: Part1Port 0x%02x = 0x%02x\n", i, sisReg->VBPart1[i]);
d981 2
a982 2
    for(i=0; i<=p2; i++)  {
       inSISIDXREG(SISPART2, i, sisReg->VBPart2[i]);
d984 1
a984 1
       xf86DrvMsg(0, X_INFO, "301xSave: Part2Port 0x%02x = 0x%02x\n", i, sisReg->VBPart2[i]);
d987 2
a988 2
    for(i=0; i<=p3; i++)  {
       inSISIDXREG(SISPART3, i, sisReg->VBPart3[i]);
d990 1
a990 1
       xf86DrvMsg(0, X_INFO, "301xSave: Part3Port 0x%02x = 0x%02x\n", i, sisReg->VBPart3[i]);
d993 2
a994 2
    for(i=0; i<=p4; i++)  {
       inSISIDXREG(SISPART4, i, sisReg->VBPart4[i]);
d996 1
a996 1
       xf86DrvMsg(0, X_INFO, "301xSave: Part4Port 0x%02x = 0x%02x\n", i, sisReg->VBPart4[i]);
a998 1
}
d1000 1
a1000 18
/* Save SiS301 bridge register contents */
static void
SiS301Save(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int     Part1max, Part2max, Part3max, Part4max;

    /* Highest register number to save/restore */
    if(pSiS->VGAEngine == SIS_300_VGA) Part1max = 0x1d;
    else Part1max = 0x2e;  /* 0x23, but we also need 2d-2e */

    Part2max = 0x45;
    Part3max = 0x3e;
    Part4max = 0x1b;

    SiSVBSave(pScrn, sisReg, Part1max, Part2max, Part3max, Part4max);

    sisReg->VBPart2[0x00] &= ~0x20;      /* Disable VB Processor */
d1009 1
a1009 1
    int     Part1max, Part2max, Part3max, Part4max;
d1012 14
a1025 6
    if(pSiS->VGAEngine == SIS_300_VGA) Part1max = 0x1d;
    else Part1max = 0x23;

    Part2max = 0x45;
    Part3max = 0x3e;
    Part4max = 0x1b;
d1027 1
a1027 1
    SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
d1029 1
a1029 1
    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
d1042 4
a1045 4
    if((!(sisReg->sisRegs3D4[0x30] & 0x03)) &&
       (sisReg->sisRegs3D4[0x31] & 0x20))  {      /* disable CRT2 */
       SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
       return;
d1050 8
a1057 3
    if(pSiS->VGAEngine == SIS_315_VGA) {
       /* Restore extra registers on 315 series */
       SetBlock(SISPART1, 0x2C, 0x2E, &(sisReg->VBPart1[0x2C]));
d1077 1
a1077 1
    SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
d1079 1
a1079 1
    SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
d1082 1
a1082 1
/* Save SiS30xB/30xLV bridge register contents */
d1087 2
a1088 1
    int     Part1max, Part2max, Part3max, Part4max;
d1090 19
a1108 7
    Part1max = 0x4c;
    Part2max = 0x4d;
    Part3max = 0x3e;
    Part4max = 0x23;
    if(pSiS->VBFlags & (VB_301C|VB_302ELV)) {
       Part2max = 0xff;
       Part4max = 0x3c;
d1110 24
a1133 2
    if(pSiS->VBFlags & (VB_301LV|VB_302LV)) {
       Part4max = 0x34;
d1135 1
a1135 4

    SiSVBSave(pScrn, sisReg, Part1max, Part2max, Part3max, Part4max);

    sisReg->VBPart2[0x00] &= ~0x20;      /* Disable VB Processor */
d1139 1
a1139 1
/* Restore SiS30xB/30xLV bridge register contents */
d1144 1
a1144 1
    int     Part1max, Part2max, Part3max, Part4max;
d1146 19
a1164 10
    Part1max = 0x23;
    Part2max = 0x4d;
    Part3max = 0x3e;
    Part4max = 0x22;
    if(pSiS->VBFlags & (VB_301C|VB_302ELV)) {
       Part2max = 0xff;
       Part4max = 0x3c;
    }
    if(pSiS->VBFlags & (VB_301LV|VB_302LV)) {
       Part4max = 0x34;
d1167 1
a1167 1
    SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
d1169 1
a1169 1
    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
d1177 3
a1179 4
    /* Mode reg 0x01 became 0x2e on 315 series (0x01 still contains FIFO) */
    if(pSiS->VGAEngine == SIS_315_VGA) {
       outSISIDXREG(SISPART1, 0x2e, sisReg->VBPart1[0x2e]);
    }
d1185 4
a1188 4
    if((!(sisReg->sisRegs3D4[0x30] & 0x03)) &&
       (sisReg->sisRegs3D4[0x31] & 0x20))  {      /* disable CRT2 */
       SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
       return;
d1214 1
a1214 1
    SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
d1216 1
a1216 1
    SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
d1227 2
a1228 2
    for(i=0; i<0x46; i++)  {
       inSISIDXREG(SISPART1, i, sisReg->VBPart1[i]);
d1230 1
a1230 1
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d1237 4
a1240 4
    if(pSiS->VBFlags & VB_CHRONTEL) {
       if(pSiS->ChrontelType == CHRONTEL_700x) {
          for(i=0; i<0x1D; i++)  {
             sisReg->ch70xx[i] = SiS_GetCH700x(pSiS->SiS_Pr, ch700xidx[i]);
d1242 1
a1242 1
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d1246 1
d1249 2
a1250 7
          for(i=0; i<35; i++)  {
             sisReg->ch70xx[i] = SiS_GetCH701x(pSiS->SiS_Pr, ch701xidx[i]);
#ifdef TWDEBUG
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	                "LVDSSave: Chrontel 0x%02x = 0x%02x\n",
			ch701xidx[i], sisReg->ch70xx[i]);
#endif
d1266 1
a1266 1
    SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
d1268 1
a1268 1
       outSISIDXREG(SISPART1, 0x00, 0x80);
d1271 1
a1271 1
    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
d1277 2
a1278 2
             wtemp = ((sisReg->ch70xx[i]) << 8) | (ch700xidx[i] & 0x00FF);
             SiS_SetCH700x(pSiS->SiS_Pr, wtemp);
d1282 2
a1283 2
             wtemp = ((sisReg->ch70xx[i]) << 8) | (ch701xidx[i] & 0x00FF);
             SiS_SetCH701x(pSiS->SiS_Pr, wtemp);
d1293 1
a1293 1
    if(pSiS->VGAEngine == SIS_300_VGA) {
d1299 4
a1302 4
    if((!(sisReg->sisRegs3D4[0x30] & 0x03)) &&
       (sisReg->sisRegs3D4[0x31] & 0x20))  {      /* disable CRT2 */
       SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
       return;
d1306 1
a1306 1
    if(pSiS->VGAEngine == SIS_300_VGA) {
d1313 2
a1314 2
       SetBlock(SISPART1, 0x2C, 0x2E, &(sisReg->VBPart1[0x2C]));
       SetBlock(SISPART1, 0x35, 0x37, &(sisReg->VBPart1[0x35]));  /* Panel Link Scaler */
d1317 4
a1320 4
    /* For 550 DSTN registers */
    if(pSiS->DSTN || pSiS->FSTN) {
       SetBlock(SISPART1, 0x25, 0x2E, &(sisReg->VBPart1[0x25]));
       SetBlock(SISPART1, 0x30, 0x45, &(sisReg->VBPart1[0x30]));
d1323 1
a1323 1
    SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
d1325 1
a1325 1
    SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
d1328 1
a1328 1
/* Restore output selection registers */
d1333 1
a1333 1
   int i;
d1339 11
a1349 3
   for(i = 0x30; i <= 0x3b; i++) {
      if(i == 0x34) continue;
      outSISIDXREG(SISCR, i, sisReg->sisRegs3D4[i]);
d1351 11
d1363 116
a1478 6
   if(pSiS->VGAEngine == SIS_315_VGA) {
      outSISIDXREG(SISCR, pSiS->myCR63, sisReg->sisRegs3D4[pSiS->myCR63]);
      if(pSiS->sishw_ext.jChipType < SIS_661) {
         outSISIDXREG(SISCR, 0x79, sisReg->sisRegs3D4[0x79]);
      }
   }
d1480 1
d1482 5
a1486 5
#if 0  /* The following function should take a threshold value
        * from predefined tables. This is only needed on some
	* 530 boards, which have an ESS sound device on-board.
	* However, I don't know how to calculate the index to
	* be submitted to this function.
d1537 9
d1547 1
a1547 1
/* Not for 530/620 if UMA (on these, the mclk is stored in SR10) */
d1555 10
d1566 13
a1587 1
    case PCI_CHIP_SIS660:
d1601 1
a1601 1
           mclk = mclk / (((Denum & 0x60) >> 5) + 1);
d1603 1
a1603 1
           mclk = mclk / ((((Denum & 0x60) >> 5) + 1) * 2);
a1605 4

    case PCI_CHIP_SIS5597:
    case PCI_CHIP_SIS6326:
    case PCI_CHIP_SIS530:
d1607 4
a1610 23
        /* Numerator */
        inSISIDXREG(SISSR, 0x28, Num);
        mclk = 14318 * ((Num & 0x7f) + 1);

        /* Denumerator */
	inSISIDXREG(SISSR, 0x29, Denum);
        mclk = mclk / ((Denum & 0x1f) + 1);

        /* Divider. Doesn't work on older cards */
	if(pSiS->oldChipset >= OC_SIS5597) {
           if(Num & 0x80) mclk *= 2;
	}

        /* Post-scaler. Values' meaning depends on SR13 bit 7  */
	inSISIDXREG(SISSR, 0x13, Base);
        if((Base & 0x80) == 0) {
           mclk = mclk / (((Denum & 0x60) >> 5) + 1);
        } else {
           /* Values 00 and 01 are reserved */
           if ((Denum & 0x60) == 0x40)  mclk /= 6;
           if ((Denum & 0x60) == 0x60)  mclk /= 8;
        }
        break;
d1616 9
a1624 9
/* This estimates the CRT2 clock we are going to use.
 * The total bandwidth is to be reduced by the value
 * returned here in order to get an idea of the maximum
 * dotclock left for CRT1.
 * Since we don't know yet, what mode the user chose,
 * we return the maximum dotclock used by
 * - either the LCD attached, or
 * - TV
 * For VGA2, we share the bandwith equally.
d1627 1
a1627 1
SiSEstimateCRT2Clock(ScrnInfoPtr pScrn, BOOLEAN IsForMergedFBCRT2)
d1632 12
a1643 18
  	   if(pSiS->VBLCDFlags & (VB_LCD_320x480 | VB_LCD_800x600 | VB_LCD_640x480))
	      return 40000;
	   else if(pSiS->VBLCDFlags & (VB_LCD_1024x768 | VB_LCD_1024x600 | VB_LCD_1152x768))
	      return 65000;
	   else if(pSiS->VBLCDFlags & VB_LCD_1280x768)
	      return 81000;
	   else if(pSiS->VBLCDFlags & VB_LCD_1400x1050) {
	      /* Must fake clock; built-in mode shows 122 for VGA, but uses only 108 for LCD */
	      if(IsForMergedFBCRT2) return 123000;
	      else                  return 108000;
	   } else if(pSiS->VBLCDFlags & (VB_LCD_1280x1024 | VB_LCD_1280x960))
	      return 108000;
	   else if(pSiS->VBLCDFlags & VB_LCD_1600x1200)
	      return 162000;
	   else if((pSiS->VBLCDFlags & VB_LCD_CUSTOM) && (pSiS->SiS_Pr->CP_HaveCustomData))
	      return pSiS->SiS_Pr->CP_MaxClock;
	   else
	      return 108000;
d1645 11
a1655 14
	   if(pSiS->VBFlags & VB_CHRONTEL) {
	      switch(pSiS->VGAEngine) {
	      case SIS_300_VGA:
                 return 50000;
	      case SIS_315_VGA:
	      default:
		 return 70000;
	      }
	   } else if(pSiS->VBFlags & VB_SISBRIDGE) {
	      if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPR)
	         return 75000;
	      else
	         return 70000;
	   }
d1662 1
a1662 1
int SiSMemBandWidth(ScrnInfoPtr pScrn, BOOLEAN IsForCRT2)
d1673 1
a1673 1
        float   	magic=0.0, total, crt2used, maxcrt2;
a1674 3
#ifdef __SUNPRO_C
#define const
#endif
a1678 4
#ifdef __SUNPRO_C
#undef const
#endif
	BOOLEAN	        DHM, GetForCRT1;
d1680 1
a1680 1
        switch(pSiS->Chipset) {
a1714 1
	case PCI_CHIP_SIS660:
a1732 3
		    magic = magic550[bus/64];
		    max = 620000;
		    break;
d1735 1
a1735 10
		    max = 680000;
		    break;
		case PCI_CHIP_SIS660:
		    if((pSiS->sishw_ext.jChipType >= SIS_660) &&
		       (!(pSiS->ChipFlags & SiSCF_760UMA))) {
		       magic = magic315[bus/64];
		    } else {
		       magic = magic550[bus/64];
		    }
		    max = 680000;
d1746 1
a1746 8
                if((pSiS->VBFlags & CRT2_ENABLE) && (!pSiS->CRT1off)) {

		    maxcrt2 = 135000;
		    if(pSiS->VBFlags & (VB_301B|VB_302B)) maxcrt2 = 162000;
		    else if(pSiS->VBFlags & VB_301C)      maxcrt2 = 203000;
		    /* if(pSiS->VBFlags & VB_30xBDH)      maxcrt2 = 100000;
		       Ignore 301B-DH here; seems the current version is like
		       301B anyway */
d1749 1
a1749 1
		    crt2clock = SiSEstimateCRT2Clock(pScrn, IsForCRT2);
a1752 2
		    DHM = FALSE;
		    GetForCRT1 = FALSE;
a1755 10
		       DHM = TRUE;
		       if(pSiS->SecondHead) GetForCRT1 = TRUE;
		    }
#endif
#ifdef SISMERGED
		    if(pSiS->MergedFB && IsForCRT2) {
		       DHM = TRUE;
		       GetForCRT1 = FALSE;
		    }
#endif
d1757 1
a1757 3
		    if(DHM) {

		        if(!GetForCRT1) {
d1772 3
a1774 1
				
d1778 1
a1778 3
			         *  same. But since the maximum dotclock
				 *  is limited on CRT2, we can assume a
				 *  maximum here.
d1780 4
a1783 8
                                if((total / 2) > (maxcrt2 + 2000)) {
				    total = (maxcrt2 + 2000) * magic;
				    crt2used = maxcrt2 + 2000;
				} else {
				    total /= 2;
				    crt2used = total;
				}
				
a1784 4
			     
			     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	           "Bandwidth reserved for CRT2 is %g Mhz\n",
				      crt2used/1000);
d1787 1
a1787 1
#ifdef SISDUALHEAD
d1810 1
a1810 1
#endif
d1814 1
a1814 1

d1817 2
d1820 3
a1822 7
                            if((total / 2) > (maxcrt2 + 2000)) {
			    	total -= (maxcrt2 + 2000);
				crt2used = maxcrt2 + 2000;
			    } else {  
			    	total /= 2;
				crt2used = total;
			    }		   
a1823 2
			xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		       	  "Bandwidth reserved for CRT2 is %g Mhz\n", crt2used/1000);
d1827 1
a1827 1

d1829 1
d1834 1
a1834 1
                return(int)(total);
d1837 1
a1837 1
                return(135000);
d1841 7
a1847 7
/* Load the palette. We do this for all supported color depths
 * in order to support gamma correction. We hereby convert the
 * given colormap to a complete 24bit color palette and enable
 * the correspoding bit in SR7 to enable the 24bit lookup table.
 * Gamma correction is only supported on CRT1.
 * Why are there 6-bit-RGB values submitted even if bpp is 16 and
 * weight is 565? (Maybe because rgbBits is 6?)
d1853 2
a1854 10
     SISPtr  pSiS = SISPTR(pScrn);
     int     i, j, index;
     unsigned char backup = 0;
     Bool    dogamma1 = pSiS->CRT1gamma;
     Bool    resetxvgamma = FALSE;
#ifdef SISDUALHEAD
     SISEntPtr pSiSEnt = pSiS->entityPrivate;

     if(pSiS->DualHeadMode) dogamma1 = pSiSEnt->CRT1gamma;
#endif
d1856 1
a1856 1
     PDEBUG(ErrorF("SiSLoadPalette(%d)\n", numColors));
d1859 2
a1860 1
     if((!pSiS->DualHeadMode) || (pSiS->SecondHead)) {
a1862 12
        if(pSiS->VGAEngine == SIS_315_VGA) {
	   inSISIDXREG(SISSR, 0x1f, backup);
	   andSISIDXREG(SISSR, 0x1f, 0xe7);
	   if( (pSiS->XvGamma) &&
	       (pSiS->MiscFlags & MISC_CRT1OVERLAYGAMMA) &&
	       ((pSiS->CurrentLayout.depth == 16) ||
	        (pSiS->CurrentLayout.depth == 24)) ) {
	      orSISIDXREG(SISSR, 0x1f, 0x10);
	      resetxvgamma = TRUE;
	   }
        }

d1866 9
a1874 11
	     if(dogamma1) {
	        orSISIDXREG(SISSR, 0x07, 0x04);
	        for(i=0; i<numColors; i++) {
                   index = indices[i];
		   if(index < 32) {   /* Paranoia */
		      for(j=0; j<8; j++) {
		         outSISREG(SISCOLIDX, (index * 8) + j);
                         outSISREG(SISCOLDATA, colors[index].red << (8- pScrn->rgbBits));
                         outSISREG(SISCOLDATA, colors[index].green << (8 - pScrn->rgbBits));
                         outSISREG(SISCOLDATA, colors[index].blue << (8 - pScrn->rgbBits));
		      }
d1876 2
a1877 4
                }
	     } else {
	        andSISIDXREG(SISSR, 0x07, ~0x04);
	     }
d1880 9
a1888 11
	     if(dogamma1) {
                orSISIDXREG(SISSR, 0x07, 0x04);
	        for(i=0; i<numColors; i++) {
                   index = indices[i];
		   if(index < 64) {  /* Paranoia */
		      for(j=0; j<4; j++) {
		         outSISREG(SISCOLIDX, (index * 4) + j);
                         outSISREG(SISCOLDATA, colors[index/2].red << (8 - pScrn->rgbBits));
                         outSISREG(SISCOLDATA, colors[index].green << (8 - pScrn->rgbBits));
                         outSISREG(SISCOLDATA, colors[index/2].blue << (8 - pScrn->rgbBits));
		      }
d1890 2
a1891 4
                }
	     } else {
	        andSISIDXREG(SISSR, 0x07, ~0x04);
	     }
d1894 10
a1903 14
	     if(dogamma1) {
	        orSISIDXREG(SISSR, 0x07, 0x04);
                for(i=0; i<numColors; i++)  {
                   index = indices[i];
		   if(index < 256) {   /* Paranoia */
                      outSISREG(SISCOLIDX, index);
                      outSISREG(SISCOLDATA, colors[index].red);
                      outSISREG(SISCOLDATA, colors[index].green);
                      outSISREG(SISCOLDATA, colors[index].blue);
		   }
                }
	     } else {
	        andSISIDXREG(SISSR, 0x07, ~0x04);
	     }
d1907 1
a1907 1
	     if((pScrn->rgbBits == 8) && (dogamma1))
d1920 12
a1931 28
	if(pSiS->VGAEngine == SIS_315_VGA) {
	   outSISIDXREG(SISSR, 0x1f, backup);
	   inSISIDXREG(SISSR, 0x07, backup);
	   if((backup & 0x04) && (resetxvgamma) && (pSiS->ResetXvGamma)) {
	      (pSiS->ResetXvGamma)(pScrn);
	   }
	}

#ifdef SISDUALHEAD		
    }	

    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead)) {
#endif

       switch(pSiS->VGAEngine) {
       case SIS_300_VGA:
       case SIS_315_VGA:
          if(pSiS->VBFlags & CRT2_ENABLE) {
	     /* Only the SiS bridges support a CRT2 palette */
	     if(pSiS->VBFlags & VB_SISBRIDGE) {
                (*pSiS->LoadCRT2Palette)(pScrn, numColors, indices, colors, pVisual);
	     }
          }
       }
	
#ifdef SISDUALHEAD		
    }
#endif
d1940 1
a1940 7
        int     i, j, index;
	Bool    dogamma2 = pSiS->CRT2gamma;
#ifdef SISDUALHEAD
        SISEntPtr pSiSEnt = pSiS->entityPrivate;

	if(pSiS->DualHeadMode) dogamma2 = pSiSEnt->CRT2gamma;
#endif
d1944 1
a1944 64
	/* 301B-DH does not support a color palette for LCD */
	if((pSiS->VBFlags & VB_30xBDH) && (pSiS->VBFlags & CRT2_LCD)) return;
	
	switch(pSiS->CurrentLayout.depth) {
#ifdef SISGAMMA
          case 15:
	     if(dogamma2) {
	        orSISIDXREG(SISPART4, 0x0d, 0x08);
	        for(i=0; i<numColors; i++) {
                   index = indices[i];
		   if(index < 32) {   /* Paranoia */
		      for(j=0; j<8; j++) {
		         outSISREG(SISCOL2IDX, (index * 8) + j);
                         outSISREG(SISCOL2DATA, colors[index].red << (8- pScrn->rgbBits));
                         outSISREG(SISCOL2DATA, colors[index].green << (8 - pScrn->rgbBits));
                         outSISREG(SISCOL2DATA, colors[index].blue << (8 - pScrn->rgbBits));
		      }
		   }
                }
	     } else {
	        andSISIDXREG(SISPART4, 0x0d, ~0x08);
	     }
	     break;
	  case 16:
	     if(dogamma2) {
                orSISIDXREG(SISPART4, 0x0d, 0x08);
	        for(i=0; i<numColors; i++) {
                   index = indices[i];
		   if(index < 64) {  /* Paranoia */
		      for(j=0; j<4; j++) {
		         outSISREG(SISCOL2IDX, (index * 4) + j);
                         outSISREG(SISCOL2DATA, colors[index/2].red << (8 - pScrn->rgbBits));
                         outSISREG(SISCOL2DATA, colors[index].green << (8 - pScrn->rgbBits));
                         outSISREG(SISCOL2DATA, colors[index/2].blue << (8 - pScrn->rgbBits));
		      }
		   }
                }
	     } else {
	        andSISIDXREG(SISPART4, 0x0d, ~0x08);
	     }
	     break;
          case 24:
	     if(dogamma2) {
	        orSISIDXREG(SISPART4, 0x0d, 0x08);
                for(i=0; i<numColors; i++)  {
                   index = indices[i];
		   if(index < 256) {   /* Paranoia */
                      outSISREG(SISCOL2IDX, index);
                      outSISREG(SISCOL2DATA, colors[index].red);
                      outSISREG(SISCOL2DATA, colors[index].green);
                      outSISREG(SISCOL2DATA, colors[index].blue);
		   }
                }
	     } else {
	        andSISIDXREG(SISPART4, 0x0d, ~0x08);
	     }
	     break;
#endif
	  default:
	     if((pScrn->rgbBits == 8) && (dogamma2))
	        orSISIDXREG(SISPART4, 0x0d, 0x08);
	     else
	        andSISIDXREG(SISPART4, 0x0d, ~0x08);
             for(i=0; i<numColors; i++)  {
d1950 92
a2041 2
             }
	 }
d2043 1
d2057 2
a2058 3
      case PCI_CHIP_SIS660:
        pSiS->MaxClock               = SiSMemBandWidth(pScrn, FALSE);
        pSiS->SiSSave                = SiS315Save;
d2062 1
a2062 1
        pSiS->SiSRestore             = SiS315Restore;
d2067 2
d2073 1
a2073 1
        pSiS->MaxClock               = SiSMemBandWidth(pScrn, FALSE);
d2083 2
d2090 1
a2090 1
        pSiS->MaxClock               = SiSMemBandWidth(pScrn, FALSE);
d2093 2
d2104 2
a2105 2
    for(index = from; index <= to; index++, DataPtr++) {
       outSISIDXREG(port, index, *DataPtr);
d2123 2
a2124 2
    SISPtr  pSiS = SISPTR(pScrn);
    unsigned char data;
d2126 3
a2128 3
    outSISIDXREG(SISCR, 0xE0, index);
    inSISIDXREG(SISCR, 0xE1, data);
    return(data);
d2142 2
a2143 2
    SISPtr  pSiS = SISPTR(pScrn);
    unsigned char data;
d2145 3
a2147 3
    outSISIDXREG(SISCR, 0xE2, index);
    inSISIDXREG(SISCR, 0xE3, data);
    return(data);
@


1.1.1.4
log
@Import OpenBSD X-Window subsystem (based upon XFree86 4.4RC2)
into vendor branch
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_dac.c,v 1.61 2004/02/25 23:22:16 twini Exp $ */
d15 4
a18 1
 * 3) The name of the author may not be used to endorse or promote products
d88 1
a88 1
   };
d760 1
a760 1
    for(i = 0x00; i <= 0x7c; i++)  {
d1282 55
d1341 1
a1341 1
{
d1424 1
a1424 1
  	   if(pSiS->VBLCDFlags & (VB_LCD_320x480 | VB_LCD_800x600 | VB_LCD_640x480)) {
d1426 1
a1426 1
	   } else if(pSiS->VBLCDFlags & (VB_LCD_1024x768 | VB_LCD_1024x600 | VB_LCD_1152x768)) {
d1428 1
a1428 3
	   } else if(pSiS->VBLCDFlags & VB_LCD_1280x720) {
	      return 75000;
	   } else if(pSiS->VBLCDFlags & VB_LCD_1280x768) {
d1430 1
a1430 5
	   } else if(pSiS->VBLCDFlags & VB_LCD_1280x800) {
	      /* Must fake clock; built-in mode shows 83 for VGA, but uses only 70 for LCD */
	      if(IsForMergedFBCRT2) return 83000;
	      else                  return 70000;
	   } else if(pSiS->VBLCDFlags & VB_LCD_1400x1050) {
d1434 1
a1434 1
	   } else if(pSiS->VBLCDFlags & (VB_LCD_1280x1024 | VB_LCD_1280x960)) {
d1436 1
a1436 5
	   } else if(pSiS->VBLCDFlags & VB_LCD_1680x1050) {
	      /* Must fake clock; built-in mode shows 147 for VGA, but uses only 122 for LCD */
	      if(IsForMergedFBCRT2) return 148000;
	      else                  return 122000;
	   } else if(pSiS->VBLCDFlags & VB_LCD_1600x1200) {
d1438 1
a1438 1
	   } else if((pSiS->VBLCDFlags & VB_LCD_CUSTOM) && (pSiS->SiS_Pr->CP_HaveCustomData)) {
d1440 1
a1440 1
	   } else
@


