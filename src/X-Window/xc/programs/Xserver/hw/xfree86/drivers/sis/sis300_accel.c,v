head	1.2;
access;
symbols
	tg-mergetmp-2:1.2
	cvs-200410241530:1.1.1.4
	cvs-200410012000:1.1.1.4
	cvs-200407221130:1.1.1.4
	cvs-200407141120:1.1.1.4
	cvs-200406231010:1.1.1.4
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.4
	XFree86_4_4_0:1.1.9.2
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.03.07.18.37.23;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.20.07.29;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.07.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.36.38;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.19.36;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.27.16.33.00;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.23.52;	author tg;	state Exp;
branches;
next	1.1.9.2;

1.1.9.2
date	2004.03.05.22.30.03;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@semi-automagic merge of these files (ie, I've skipped through the diffs,
and most of that was done by cvs or that weird script of some minutes ago)
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis300_accel.c,v 1.29 2004/02/25 17:45:11 twini Exp $ */
/*
 * 2D Acceleration for SiS 530, 620, 300, 540, 630, 730.
 *
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors:   Thomas Winischhofer <thomas@@winischhofer.net>
 *	      Can-Ru Yeou, SiS Inc.
 *
 */

#if 0
#define DEBUG
#endif

#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86_ansic.h"
#include "xf86PciInfo.h"
#include "xf86Pci.h"
#include "compiler.h"
#include "xaa.h"
#include "xaalocal.h"
#include "xaarop.h"

#include "sis.h"
#include "sis300_accel.h"

#ifdef SISDUALHEAD
/* TW: This is the offset to the memory for each head */
#define HEADOFFSET 	(pSiS->dhmOffset)
#endif

#undef STSCE    	/* TW: Use/Don't use ScreenToScreenColorExpand - does not work */

#undef TRAP     	/* TW: Use/Don't use Trapezoid Fills - does not work - XAA provides
		         * illegal trapezoid data (left and right edges cross each other
			 * sometimes) which causes drawing errors. Further, I have not found
			 * out how to draw polygones with a height greater than 127...
                         */

static void SiSInitializeAccelerator(ScrnInfoPtr pScrn);
static void SiSSync(ScrnInfoPtr pScrn);
static void SiSSetupForScreenToScreenCopy(ScrnInfoPtr pScrn,
                                int xdir, int ydir, int rop,
                                unsigned int planemask, int trans_color);
static void SiSSubsequentScreenToScreenCopy(ScrnInfoPtr pScrn,
                                int x1, int y1, int x2, int y2,
                                int width, int height);
static void SiSSetupForSolidFill(ScrnInfoPtr pScrn, int color,
                                int rop, unsigned int planemask);
static void SiSSubsequentSolidFillRect(ScrnInfoPtr pScrn,
                                int x, int y, int w, int h);
#ifdef TRAP
static void SiSSubsequentSolidFillTrap(ScrnInfoPtr pScrn, int y, int h,
	                        int left, int dxL, int dyL, int eL,
	                        int right, int dxR, int dyR, int eR);
#endif
static void SiSSetupForSolidLine(ScrnInfoPtr pScrn, int color,
                                int rop, unsigned int planemask);
static void SiSSubsequentSolidTwoPointLine(ScrnInfoPtr pScrn, int x1,
                                int y1, int x2, int y2, int flags);
static void SiSSubsequentSolidHorzVertLine(ScrnInfoPtr pScrn,
                                int x, int y, int len, int dir);
static void SiSSetupForDashedLine(ScrnInfoPtr pScrn,
                                int fg, int bg, int rop, unsigned int planemask,
                                int length, unsigned char *pattern);
static void SiSSubsequentDashedTwoPointLine(ScrnInfoPtr pScrn,
                                int x1, int y1, int x2, int y2,
                                int flags, int phase);
static void SiSSetupForMonoPatternFill(ScrnInfoPtr pScrn,
                                int patx, int paty, int fg, int bg,
                                int rop, unsigned int planemask);
static void SiSSubsequentMonoPatternFill(ScrnInfoPtr pScrn,
                                int patx, int paty,
                                int x, int y, int w, int h);
#ifdef TRAP
static void SiSSubsequentMonoPatternFillTrap(ScrnInfoPtr pScrn,
                                int patx, int paty,
                                int y, int h,
                                int left, int dxL, int dyL, int eL,
	                        int right, int dxR, int dyR, int eR );
#endif
#if 0
static void SiSSetupForColorPatternFill(ScrnInfoPtr pScrn,
                                int patx, int paty, int rop,
                                unsigned int planemask,
                                int trans_color);
static void SiSSubsequentColorPatternFill(ScrnInfoPtr pScrn,
                                int patx, int paty,
                                int x, int y, int w, int h);
#endif
#if 0
static void SiSSetupForCPUToScreenColorExpand(ScrnInfoPtr pScrn,
                                int fg, int bg,
                                int rop, unsigned int planemask);
static void SiSSubsequentCPUToScreenColorExpand(ScrnInfoPtr pScrn,
                                int x, int y, int w, int h, int skipleft);
#endif
#ifdef STSCE
static void SiSSetupForScreenToScreenColorExpand(ScrnInfoPtr pScrn,
                                int fg, int bg,
                                int rop, unsigned int planemask);
static void SiSSubsequentScreenToScreenColorExpand(ScrnInfoPtr pScrn,
                                int x, int y, int w, int h,
                                int srcx, int srcy, int skipleft);
#endif
static void SiSSetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
                                int fg, int bg, int rop,
                                unsigned int planemask);
static void SiSSubsequentScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
                                int x, int y, int w, int h,
                                int skipleft);
static void SiSSubsequentColorExpandScanline(ScrnInfoPtr pScrn, int bufno);

#ifdef SISDUALHEAD
static void SiSRestoreAccelState(ScrnInfoPtr pScrn);
#endif

static void
SiSInitializeAccelerator(ScrnInfoPtr pScrn)
{
	SISPtr  pSiS = SISPTR(pScrn);

	pSiS->DoColorExpand = FALSE;
}

Bool
SiS300AccelInit(ScreenPtr pScreen)
{
	XAAInfoRecPtr   infoPtr;
	ScrnInfoPtr     pScrn = xf86Screens[pScreen->myNum];
	SISPtr          pSiS = SISPTR(pScrn);
	int		topFB;
	int             reservedFbSize;
	int             UsableFbSize;
	unsigned char   *AvailBufBase;
	BoxRec          Avail;
	int             i;

	pSiS->AccelInfoPtr = infoPtr = XAACreateInfoRec();
	if (!infoPtr)  return FALSE;

	SiSInitializeAccelerator(pScrn);

	infoPtr->Flags = LINEAR_FRAMEBUFFER |
			 OFFSCREEN_PIXMAPS |
			 PIXMAP_CACHE;

	/* sync */
	infoPtr->Sync = SiSSync;

	/* Acceleration only supported at 8, 16 and 32 bpp */
	if((pScrn->bitsPerPixel != 8) && (pScrn->bitsPerPixel != 16) &&
	         (pScrn->bitsPerPixel != 32))
	    return FALSE;

	/* TW: Although SiS states that the 300 series supports a
	 *     virtual framebuffer of 4096x4096, the 2D accelerator
	 *     does not seem to know that. If the destination bitmap
	 *     pitch is > 8192 (which easily happens in 32bpp mode),
	 *     the accelerator engine collapses.
	 *     TODO: Find out about the 530 and 620
	 */

	if(pSiS->scrnOffset < 8192) {

	   /* screen to screen copy */
	   infoPtr->SetupForScreenToScreenCopy = SiSSetupForScreenToScreenCopy;
	   infoPtr->SubsequentScreenToScreenCopy = SiSSubsequentScreenToScreenCopy;
	   infoPtr->ScreenToScreenCopyFlags = NO_PLANEMASK |
	                                      TRANSPARENCY_GXCOPY_ONLY;

	   /* solid fills */
	   infoPtr->SetupForSolidFill = SiSSetupForSolidFill;
	   infoPtr->SubsequentSolidFillRect = SiSSubsequentSolidFillRect;
#ifdef TRAP
	   infoPtr->SubsequentSolidFillTrap = SiSSubsequentSolidFillTrap;
#endif
	   infoPtr->SolidFillFlags = NO_PLANEMASK;

	   /* solid line */
	   infoPtr->SetupForSolidLine = SiSSetupForSolidLine;
	   infoPtr->SubsequentSolidTwoPointLine = SiSSubsequentSolidTwoPointLine;
	   infoPtr->SubsequentSolidHorVertLine = SiSSubsequentSolidHorzVertLine;
	   infoPtr->SolidLineFlags = NO_PLANEMASK;

	   /* dashed line */
	   infoPtr->SetupForDashedLine = SiSSetupForDashedLine;
	   infoPtr->SubsequentDashedTwoPointLine = SiSSubsequentDashedTwoPointLine;
	   infoPtr->DashPatternMaxLength = 64;
	   infoPtr->DashedLineFlags = NO_PLANEMASK |
	  			      LINE_PATTERN_MSBFIRST_LSBJUSTIFIED;

	   /* 8x8 mono pattern fill */
	   infoPtr->SetupForMono8x8PatternFill = SiSSetupForMonoPatternFill;
	   infoPtr->SubsequentMono8x8PatternFillRect = SiSSubsequentMonoPatternFill;
#ifdef TRAP
	   infoPtr->SubsequentMono8x8PatternFillTrap = SiSSubsequentMonoPatternFillTrap;
#endif
	   infoPtr->Mono8x8PatternFillFlags = NO_PLANEMASK |
					      HARDWARE_PATTERN_SCREEN_ORIGIN |
					      HARDWARE_PATTERN_PROGRAMMED_BITS |
					      /* NO_TRANSPARENCY | */
					      BIT_ORDER_IN_BYTE_MSBFIRST ;

#ifdef STSCE
	   /* Screen To Screen Color Expand */
	   /* TW: The hardware does support this the way we need it */
	   infoPtr->SetupForScreenToScreenColorExpandFill =
	    			SiSSetupForScreenToScreenColorExpand;
	   infoPtr->SubsequentScreenToScreenColorExpandFill =
	    			SiSSubsequentScreenToScreenColorExpand;
	   infoPtr->ScreenToScreenColorExpandFillFlags = NO_PLANEMASK |
	                                              BIT_ORDER_IN_BYTE_MSBFIRST ;
#endif

#if 0
	   /* CPU To Screen Color Expand --- implement another instead of this one! */
	   infoPtr->SetupForCPUToScreenColorExpandFill =
	       SiSSetupForCPUToScreenColorExpand;
	   infoPtr->SubsequentCPUToScreenColorExpandFill =
	       SiSSubsequentCPUToScreenColorExpand;
	   infoPtr->ColorExpandRange = PATREGSIZE;
	   infoPtr->ColorExpandBase = pSiS->IOBase+PBR(0);
	   infoPtr->CPUToScreenColorExpandFillFlags = NO_PLANEMASK |
	   					      BIT_ORDER_IN_BYTE_MSBFIRST |
	    					      NO_TRANSPARENCY |
	    					      SYNC_AFTER_COLOR_EXPAND |
	    					      HARDWARE_PATTERN_SCREEN_ORIGIN |
	    					      HARDWARE_PATTERN_PROGRAMMED_BITS ;
#endif

	   /* per-scanline color expansion (using indirect method) */
	   if(pSiS->VGAEngine == SIS_530_VGA) {
	      pSiS->ColorExpandBufferNumber = 4;
	      pSiS->ColorExpandBufferCountMask = 0x03;
	   } else {
	      pSiS->ColorExpandBufferNumber = 16;
	      pSiS->ColorExpandBufferCountMask = 0x0F;
	   }
	   pSiS->PerColorExpandBufferSize = ((pScrn->virtualX + 31)/32) * 4;
	   infoPtr->NumScanlineColorExpandBuffers = pSiS->ColorExpandBufferNumber;
	   infoPtr->ScanlineColorExpandBuffers = (unsigned char **)&pSiS->ColorExpandBufferAddr[0];

	   infoPtr->SetupForScanlineCPUToScreenColorExpandFill =
	                            SiSSetupForScanlineCPUToScreenColorExpandFill;
	   infoPtr->SubsequentScanlineCPUToScreenColorExpandFill =
	                            SiSSubsequentScanlineCPUToScreenColorExpandFill;
	   infoPtr->SubsequentColorExpandScanline =
	                            SiSSubsequentColorExpandScanline;
	   infoPtr->ScanlineCPUToScreenColorExpandFillFlags = NO_PLANEMASK |
	    						      CPU_TRANSFER_PAD_DWORD |
	    						      SCANLINE_PAD_DWORD |
	    						      BIT_ORDER_IN_BYTE_MSBFIRST |
	    						      LEFT_EDGE_CLIPPING;
        } else {
	   xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	   	"Virtual screen width too large for accelerator engine\n");
           xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	   	"2D acceleration and Xv disabled\n");
           pSiS->NoXvideo = TRUE;
	}

#ifdef SISDUALHEAD
	if(pSiS->DualHeadMode) {
	   infoPtr->RestoreAccelState = SiSRestoreAccelState;
	}
#endif

	/* init Frame Buffer Manager */
	topFB = pSiS->maxxfbmem;

	reservedFbSize = pSiS->ColorExpandBufferNumber * pSiS->PerColorExpandBufferSize;

	UsableFbSize = topFB - reservedFbSize;

	/* Layout: (Sizes do not reflect correct proportions)
	 * |--------------++++++++++++++++++++^************==========~~~~~~~~~~~~|
	 *   UsableFbSize  ColorExpandBuffers | DRI-Heap  |  HWCursor  TurboQueue   300/310/325 series
	 * |--------------++++++++++++++++++++|  ====================~~~~~~~~~~~~|
	 *   UsableFbSize  ColorExpandBuffers |        TurboQueue     HWCursor      530/620
	 *                                  topFB
	 */

	AvailBufBase = pSiS->FbBase + UsableFbSize;
	for(i = 0; i < pSiS->ColorExpandBufferNumber; i++) {
	   pSiS->ColorExpandBufferAddr[i] = AvailBufBase +
	 	    i * pSiS->PerColorExpandBufferSize;
	   pSiS->ColorExpandBufferScreenOffset[i] = UsableFbSize +
		    i * pSiS->PerColorExpandBufferSize;
	}
	Avail.x1 = 0;
	Avail.y1 = 0;
	Avail.x2 = pScrn->displayWidth;
	Avail.y2 = (UsableFbSize / (pScrn->displayWidth * pScrn->bitsPerPixel/8)) - 1;

	if(Avail.y2 < 0)  Avail.y2 = 32767;

	if(Avail.y2 < pScrn->currentMode->VDisplay) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			"Not enough video RAM for accelerator. At least "
			"%dKB needed, %ldKB available\n",
			((((pScrn->displayWidth * pScrn->bitsPerPixel/8)   /* TW: +8 for make it sure */
			     * pScrn->currentMode->VDisplay) + reservedFbSize) / 1024) + 8,
			pSiS->maxxfbmem/1024);
		pSiS->NoAccel = TRUE;
		pSiS->NoXvideo = TRUE;
		XAADestroyInfoRec(pSiS->AccelInfoPtr);
		pSiS->AccelInfoPtr = NULL;
		return FALSE;
	}

	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Frame Buffer From (%d,%d) To (%d,%d)\n",
		   Avail.x1, Avail.y1, Avail.x2, Avail.y2);

	xf86InitFBManager(pScreen, &Avail);

	return(XAAInit(pScreen, infoPtr));
}


static void 
SiSSync(ScrnInfoPtr pScrn)
{
	SISPtr pSiS = SISPTR(pScrn);

	PDEBUG(ErrorF("SiSSync()\n"));

	pSiS->DoColorExpand = FALSE;
	SiSIdle
}

#ifdef SISDUALHEAD
static void
SiSRestoreAccelState(ScrnInfoPtr pScrn)
{
	SISPtr pSiS = SISPTR(pScrn);

	/* TW: We don't need to do anything special here; forcing the
	 *     other head to re-read the CmdQueLen is not necessary:
	 *     After the Sync in RestoreAccelState(), the real queue
	 *     length is always larger than (or at least equal to)
	 *     the amount stored in CmdQueueLen of the other head,
	 *     so the only thing that might happen is one unnecessary
	 *     Sync on the other head. I think we can live with that.
	 */
	pSiS->DoColorExpand = FALSE;
	SiSIdle
}
#endif

static void SiSSetupForScreenToScreenCopy(ScrnInfoPtr pScrn,
                                int xdir, int ydir, int rop,
                                unsigned int planemask, int trans_color)
{
	SISPtr  pSiS = SISPTR(pScrn);

	PDEBUG(ErrorF("Setup ScreenCopy(%d, %d, 0x%x, 0x%x, 0x%x)\n",
					xdir, ydir, rop, planemask, trans_color));

	SiSSetupDSTColorDepth(pSiS->DstColor);
	SiSSetupSRCPitch(pSiS->scrnOffset)
	SiSSetupDSTRect(pSiS->scrnOffset, -1)

	if(trans_color != -1) {
	   SiSSetupROP(0x0A)
	   SiSSetupSRCTrans(trans_color)
	   SiSSetupCMDFlag(TRANSPARENT_BITBLT)
	} else {
	   SiSSetupROP(XAACopyROP[rop])
	}
	if(xdir > 0) {
	   SiSSetupCMDFlag(X_INC)
	}
	if(ydir > 0) {
	   SiSSetupCMDFlag(Y_INC)
	}
}

static void SiSSubsequentScreenToScreenCopy(ScrnInfoPtr pScrn,
                                int src_x, int src_y, int dst_x, int dst_y,
                                int width, int height)
{
	SISPtr  pSiS = SISPTR(pScrn);
	long srcbase, dstbase;

	PDEBUG(ErrorF("Subsequent ScreenCopy(%d,%d, %d,%d, %d,%d)\n",
					src_x, src_y, dst_x, dst_y, width, height));

	srcbase = dstbase = 0;
	if(src_y >= 2048) {
	   srcbase = pSiS->scrnOffset * src_y;
	   src_y = 0;
	}
	if((dst_y >= pScrn->virtualY) || (dst_y >= 2048)) {
	   dstbase = pSiS->scrnOffset * dst_y;
	   dst_y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   srcbase += HEADOFFSET;
	   dstbase += HEADOFFSET;
	}
#endif
	SiSSetupSRCBase(srcbase);
	SiSSetupDSTBase(dstbase);

	if(!(pSiS->CommandReg & X_INC))  {
	   src_x += width-1;
	   dst_x += width-1;
	}
	if(!(pSiS->CommandReg & Y_INC))  {
	   src_y += height-1;
	   dst_y += height-1;
	}
	SiSSetupRect(width, height)
	SiSSetupSRCXY(src_x, src_y)
	SiSSetupDSTXY(dst_x, dst_y)

	SiSDoCMD
}

static void
SiSSetupForSolidFill(ScrnInfoPtr pScrn,
                        int color, int rop, unsigned int planemask)
{
	SISPtr  pSiS = SISPTR(pScrn);

	PDEBUG(ErrorF("Setup SolidFill(0x%x, 0x%x, 0x%x)\n",
					color, rop, planemask));

	if(pSiS->disablecolorkeycurrent) {
	   if((CARD32)color == pSiS->colorKey) {
	      rop = 5;  /* NOOP */
	   }
	}
	SiSSetupPATFG(color)
	SiSSetupDSTRect(pSiS->scrnOffset, -1)
	SiSSetupDSTColorDepth(pSiS->DstColor);
	SiSSetupROP(XAAPatternROP[rop])
	/* SiSSetupCMDFlag(PATFG) - is zero */
}

static void
SiSSubsequentSolidFillRect(ScrnInfoPtr pScrn,
                        int x, int y, int w, int h)
{
	SISPtr  pSiS = SISPTR(pScrn);
	long dstbase;

	PDEBUG(ErrorF("Subsequent SolidFillRect(%d, %d, %d, %d)\n",
					x, y, w, h));
	dstbase = 0;

	if(y >= 2048) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
	}
#ifdef SISDUALHEAD
        if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
        }
#endif
	SiSSetupDSTBase(dstbase)
	SiSSetupDSTXY(x,y)
	SiSSetupRect(w,h)
	/* Clear commandReg because Setup can be used for Rect and Trap */
	pSiS->CommandReg &= ~(T_XISMAJORL | T_XISMAJORR |
	                      T_L_X_INC | T_L_Y_INC |
	                      T_R_X_INC | T_R_Y_INC |
			      TRAPAZOID_FILL);
	SiSSetupCMDFlag(X_INC | Y_INC | BITBLT)

	SiSDoCMD
}

/* TW: Trapezoid */
/* This would work better if XAA would provide us with valid trapezoids.
 * In fact, with small trapezoids the left and the right edge often cross
 * each other or result in a line length of 0 which causes drawing errors
 * (filling over whole scanline).
 * Furthermore, I have not found out how to draw trapezoids with a height
 * greater than 127.
 */
#ifdef TRAP
static void
SiSSubsequentSolidFillTrap(ScrnInfoPtr pScrn, int y, int h,
	       int left,  int dxL, int dyL, int eL,
	       int right, int dxR, int dyR, int eR )
{
	SISPtr  pSiS = SISPTR(pScrn);
	long dstbase;
#if 0
	float kL, kR;
#endif

	dstbase = 0;
	if(y >= 2048) {
	   dstbase=pSiS->scrnOffset*y;
	   y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
	}
#endif
	SiSSetupDSTBase(dstbase)
	/* SiSSetupRect(w,h) */

#if 1
	SiSSetupPATFG(0xff0000) /* FOR TESTING */
#endif

	/* Clear CommandReg because SetUp can be used for Rect and Trap */
	pSiS->CommandReg &= ~(T_L_X_INC | T_L_Y_INC |
	                      T_R_X_INC | T_R_Y_INC |
	                      T_XISMAJORL | T_XISMAJORR |
			      BITBLT);

        xf86DrvMsg(0, X_INFO, "Trap (%d %d %d %d) dxL %d dyL %d eL %d   dxR %d dyR %d eR %d\n",
		left, right, y, h, dxL, dyL, eL, dxR, dyR, eR);

	/* Unfortunately, we must check if the right and the left edge
	 * cross each other...  INCOMPLETE (line equation wrong)
	 */
#if 0
	if (dxL == 0) kL = 0;
	else kL = (float)dyL / (float)dxL;
	if (dxR == 0) kR = 0;
	else kR = (float)dyR / (float)dxR;
	xf86DrvMsg(0, X_INFO, "kL %f kR %f!\n", kL, kR);
	if ( (kR != kL) &&
	     (!(kR == 0 && kL == 0)) &&
	     (!(kR <  0 && kL >  0)) ) {
	   xf86DrvMsg(0, X_INFO, "Inside if (%f - %d)\n", ( kL * ( ( ((float)right - (float)left) / (kL - kR) ) - left) + y), h+y);
           if ( ( ( kL * ( ( ((float)right - (float)left) / (kL - kR) ) - (float)left) + (float)y) < (h + y) ) ) {
	     xf86DrvMsg(0, X_INFO, "Cross detected!\n");
	   }
	}
#endif

	/* Determine egde angles */
	if(dxL < 0) { dxL = -dxL; }
	else { SiSSetupCMDFlag(T_L_X_INC) }
	if(dxR < 0) { dxR = -dxR; }
	else { SiSSetupCMDFlag(T_R_X_INC) }

	/* (Y direction always positive - do this anyway) */
	if(dyL < 0) { dyL = -dyL; }
	else { SiSSetupCMDFlag(T_L_Y_INC) }
	if(dyR < 0) { dyR = -dyR; }
	else { SiSSetupCMDFlag(T_R_Y_INC) }

	/* Determine major axis */
	if(dxL >= dyL) {      /* X is major axis */
	   SiSSetupCMDFlag(T_XISMAJORL)
	}
	if(dxR >= dyR) {      /* X is major axis */
	   SiSSetupCMDFlag(T_XISMAJORR)
	}

	/* Set up deltas */
	SiSSetupdL(dxL, dyL)
	SiSSetupdR(dxR, dyR)

#if 0   /* Could it be that this crappy engine can only draw trapezoids up to 127 pixels high? */
	h &= 0x7F;
	if (h == 0) h = 10;
#endif

	/* Set up y, h, left, right */
	SiSSetupYH(y,h)
	SiSSetupLR(left,right)

	/* Set up initial error term */
	SiSSetupEL(eL)
	SiSSetupER(eR)

	SiSSetupCMDFlag(TRAPAZOID_FILL);

	SiSDoCMD
}
#endif

static void
SiSSetupForSolidLine(ScrnInfoPtr pScrn,
                        int color, int rop, unsigned int planemask)
{
	SISPtr  pSiS = SISPTR(pScrn);

	PDEBUG(ErrorF("Setup SolidLine(0x%x, 0x%x, 0x%x)\n",
					color, rop, planemask));

	SiSSetupLineCount(1)
	SiSSetupPATFG(color)
	SiSSetupDSTRect(pSiS->scrnOffset, -1)
	SiSSetupDSTColorDepth(pSiS->DstColor);
	SiSSetupROP(XAAPatternROP[rop])
	SiSSetupCMDFlag(PATFG | LINE)
}

static void
SiSSubsequentSolidTwoPointLine(ScrnInfoPtr pScrn,
                        int x1, int y1, int x2, int y2, int flags)
{
	SISPtr  pSiS = SISPTR(pScrn);
	long dstbase,miny,maxy;

	PDEBUG(ErrorF("Subsequent SolidLine(%d, %d, %d, %d, 0x%x)\n",
					x1, y1, x2, y2, flags));

	dstbase = 0;
	miny = (y1 > y2) ? y2 : y1;
	maxy = (y1 > y2) ? y1 : y2;
	if(maxy >= 2048) {
	   dstbase = pSiS->scrnOffset * miny;
	   y1 -= miny;
	   y2 -= miny;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
	}
#endif
	SiSSetupDSTBase(dstbase)

	SiSSetupX0Y0(x1,y1)
	SiSSetupX1Y1(x2,y2)
	if(flags & OMIT_LAST) {
	   SiSSetupCMDFlag(NO_LAST_PIXEL)
	} else {
	   pSiS->CommandReg &= ~(NO_LAST_PIXEL);
	}

	SiSDoCMD
}

static void
SiSSubsequentSolidHorzVertLine(ScrnInfoPtr pScrn,
                                int x, int y, int len, int dir)
{
	SISPtr  pSiS = SISPTR(pScrn);
	long dstbase;

	PDEBUG(ErrorF("Subsequent SolidHorzVertLine(%d, %d, %d, %d)\n",
					x, y, len, dir));
	len--; /* starting point is included! */

	dstbase = 0;
	if((y >= 2048) || ((dir != DEGREES_0) && ((y + len) >= 2048))) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
	}
#endif
	SiSSetupDSTBase(dstbase)

	SiSSetupX0Y0(x,y)
	if(dir == DEGREES_0) {
	   SiSSetupX1Y1(x + len, y);
	} else {
	   SiSSetupX1Y1(x, y + len);
	}

	SiSDoCMD
}

static void
SiSSetupForDashedLine(ScrnInfoPtr pScrn,
                                int fg, int bg, int rop, unsigned int planemask,
                                int length, unsigned char *pattern)
{
	SISPtr pSiS = SISPTR(pScrn);

	PDEBUG(ErrorF("Setup DashedLine(0x%x, 0x%x, 0x%x, 0x%x, %d, 0x%x:%x)\n",
			fg, bg, rop, planemask, length, *(pattern+4), *pattern));

	SiSSetupLineCount(1)
	SiSSetupDSTRect(pSiS->scrnOffset, -1)
	SiSSetupDSTColorDepth(pSiS->DstColor);
	SiSSetupStyleLow(*pattern)
	SiSSetupStyleHigh(*(pattern+4))
	SiSSetupStylePeriod(length-1);
	SiSSetupROP(XAAPatternROP[rop])
	SiSSetupPATFG(fg)
	SiSSetupCMDFlag(LINE | LINE_STYLE)
	if(bg != -1) {
	   SiSSetupPATBG(bg)
	} else {
	   SiSSetupCMDFlag(TRANSPARENT);
	}
}

static void
SiSSubsequentDashedTwoPointLine(ScrnInfoPtr pScrn,
                                int x1, int y1, int x2, int y2,
                                int flags, int phase)
{
	SISPtr pSiS = SISPTR(pScrn);
	long dstbase,miny,maxy;

	PDEBUG(ErrorF("Subsequent DashedLine(%d,%d, %d,%d, 0x%x,0x%x)\n",
			x1, y1, x2, y2, flags, phase));

	dstbase = 0;
	miny = (y1 > y2) ? y2 : y1;
	maxy = (y1 > y2) ? y1 : y2;
	if(maxy >= 2048) {
	   dstbase = pSiS->scrnOffset * miny;
	   y1 -= miny;
	   y2 -= miny;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
	}
#endif
	SiSSetupDSTBase(dstbase)

	SiSSetupX0Y0(x1,y1)
	SiSSetupX1Y1(x2,y2)
	if(flags & OMIT_LAST) {
	   SiSSetupCMDFlag(NO_LAST_PIXEL)
	} else {
	   pSiS->CommandReg &= ~(NO_LAST_PIXEL);
	}

	SiSDoCMD
}

static void
SiSSetupForMonoPatternFill(ScrnInfoPtr pScrn,
                                int patx, int paty, int fg, int bg,
                                int rop, unsigned int planemask)
{
	SISPtr pSiS = SISPTR(pScrn);

	PDEBUG(ErrorF("Setup MonoPatFill(0x%x,0x%x, 0x%x,0x%x, 0x%x, 0x%x)\n",
					patx, paty, fg, bg, rop, planemask));
	SiSSetupDSTRect(pSiS->scrnOffset, -1)
	SiSSetupDSTColorDepth(pSiS->DstColor);
	SiSSetupMONOPAT(patx,paty)
	SiSSetupPATFG(fg)
	SiSSetupROP(XAAPatternROP[rop])
	SiSSetupCMDFlag(PATMONO)
	if(bg != -1) {
	   SiSSetupPATBG(bg)
	} else {
	   SiSSetupCMDFlag(TRANSPARENT)
	}
}

static void
SiSSubsequentMonoPatternFill(ScrnInfoPtr pScrn,
                                int patx, int paty,
                                int x, int y, int w, int h)
{
	SISPtr pSiS = SISPTR(pScrn);
	long dstbase;

	PDEBUG(ErrorF("Subsequent MonoPatFill(0x%x,0x%x, %d,%d, %d,%d)\n",
							patx, paty, x, y, w, h));
	dstbase = 0;

	if(y >= 2048) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
	}
#endif
	SiSSetupDSTBase(dstbase)
	SiSSetupDSTXY(x, y)
	SiSSetupRect(w, h)
	/* Clear commandReg because Setup can be used for Rect and Trap */
	pSiS->CommandReg &= ~(T_XISMAJORL | T_XISMAJORR |
	                      T_L_X_INC | T_L_Y_INC |
	                      T_R_X_INC | T_R_Y_INC |
	                      TRAPAZOID_FILL);
	SiSSetupCMDFlag(X_INC | Y_INC)

	SiSDoCMD
}

/* Trapezoid */
#ifdef TRAP
static void
SiSSubsequentMonoPatternFillTrap(ScrnInfoPtr pScrn,
               int patx, int paty,
               int y, int h,
	       int left, int dxL, int dyL, int eL,
	       int right, int dxR, int dyR, int eR )
{
	SISPtr  pSiS = SISPTR(pScrn);
	long dstbase;

	PDEBUG(ErrorF("Subsequent Mono8x8PatternFillTrap(%d, %d, %d - %d %d/%d %d/%d)\n",
					y, h, left, right, dxL, dxR, eL, eR));

	dstbase = 0;
	if(y >= 2048) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
	}
#endif
	SiSSetupDSTBase(dstbase)

	/* Clear CommandReg because SetUp can be used for Rect and Trap */
	pSiS->CommandReg &= ~(T_XISMAJORL | T_XISMAJORR |
	                      T_L_X_INC | T_L_Y_INC |
			      T_R_X_INC | T_R_Y_INC |
			      BITBLT);

	if(dxL < 0) { dxL = -dxL;  }
	else { SiSSetupCMDFlag(T_L_X_INC) }
	if(dxR < 0) { dxR = -dxR; }
	else { SiSSetupCMDFlag(T_R_X_INC) }

	if(dyL < 0) { dyL = -dyL; }
	else { SiSSetupCMDFlag(T_L_Y_INC) }
	if(dyR < 0) { dyR = -dyR; }
	else { SiSSetupCMDFlag(T_R_Y_INC) }

	/* Determine major axis */
	if(dxL >= dyL) {      /* X is major axis */
	   SiSSetupCMDFlag(T_XISMAJORL)
	}
	if(dxR >= dyR) {      /* X is major axis */
	   SiSSetupCMDFlag(T_XISMAJORR)
	}

	SiSSetupYH(y,h)
	SiSSetupLR(left,right)

	SiSSetupdL(dxL, dyL)
	SiSSetupdR(dxR, dyR)

	SiSSetupEL(eL)
	SiSSetupER(eR)

	SiSSetupCMDFlag(TRAPAZOID_FILL);

	SiSDoCMD
}
#endif


#if 0

/* TW: The following (already commented) functions have NOT been adapted for dual-head mode */

/* ----- CPU To Screen Color Expand (single task) ------------------------- */

/* This does not work. Assumingly for the same
 * reason why STSColorExpand does not work either.
 */
static void
SiSSetupForCPUToScreenColorExpand(ScrnInfoPtr pScrn,
                                int fg, int bg,
                                int rop, unsigned int planemask)
{
	SISPtr pSiS = SISPTR(pScrn);

	PDEBUG(ErrorF("Setup CPUToScreen ColorExpand(0x%x,0x%x, 0x%x,0x%x)\n",
					fg, bg, rop, planemask));

/*      SiSSetupDSTRect(pSiS->scrnOffset, pScrn->virtualY)*/
	SiSSetupDSTRect(pSiS->scrnOffset, -1)
	SiSSetupDSTColorDepth(pSiS->DstColor);
	SiSSetupSRCXY(0,0)
	SiSSetupSRCFG(fg)
	SiSSetupROP(XAAPatternROP[rop])
	SiSSetupCMDFlag(X_INC | Y_INC | COLOREXP)
	if(bg == -1) {
	   SiSSetupCMDFlag(TRANSPARENT)
	} else {
	   SiSSetupSRCBG(bg)
	}
}

static void
SiSSubsequentCPUToScreenColorExpand(ScrnInfoPtr pScrn,
                                int x, int y, int w, int h, int skipleft)
{
	SISPtr pSiS = SISPTR(pScrn);
	long dstbase;

	PDEBUG(ErrorF("Subsequent CPUToScreen ColorExpand(%d,%d, %d,%d, %d)\n",
							x, y, w, h, skipleft));

	dstbase = 0;
	if(y >= 2048) {
	   dstbase = pSiS->scrnOffset * y;
	    y = 0;
	}
	SiSSetupDSTBase(dstbase)

/*      SiSSetupSRCPitch(((w+31)&0xFFE0)/8)*/
	SiSSetupSRCPitch((w+7)/8)
	SiSSetupDSTXY(x,y)
	SiSSetupRect(w,h)
/*      SiSDoCMD*/
	pSiS->DoColorExpand = TRUE;
}
#endif

/* ------ Screen To Screen Color Expand ------------------------------- */

/* TW: The hareware does not seem to support this the way we need it */

#ifdef STSCE
static void
SiSSetupForScreenToScreenColorExpand(ScrnInfoPtr pScrn,
                                int fg, int bg,
                                int rop, unsigned int planemask)
{
	SISPtr          pSiS = SISPTR(pScrn);

	PDEBUG(ErrorF("Setup ScreenToScreen ColorExp(0x%x,0x%x, 0x%x)\n",
							fg, bg, rop));

	SiSSetupDSTColorDepth(pSiS->DstColor)
	SiSSetupDSTRect(pSiS->scrnOffset, -1)
	SiSSetupROP(XAACopyROP[rop])
	SiSSetupSRCFG(fg)
	/* SiSSetupSRCXY(0,0) */

	if(bg == -1) {
	   SiSSetupCMDFlag(TRANSPARENT | ENCOLOREXP | X_INC |
				Y_INC | SRCVIDEO);
	} else {
	   SiSSetupSRCBG(bg);
	   SiSSetupCMDFlag(ENCOLOREXP | X_INC | Y_INC |
				SRCVIDEO);
	};
}
#endif

/* TW. This method blits in a single task; this does not seem to work
 * because the hardware does not use the source pitch as scanline
 * offset but only to calculate pattern address from source X and Y.
 * XAA provides the pattern bitmap with scrnOffset (displayWidth * bpp/8)
 * offset, but this does not seem to be supported by the hardware.
 */
#ifdef STSCE

/* For testing, these are the methods: (use only one at a time!) */

#undef npitch 		/* Normal: Use srcx/y as srcx/y, use scrnOffset as source pitch
			 * This would work if the hareware used the source pitch for
			 * incrementing the source address after each scanline - but
			 * it doesn't do this! The first line of the area is correctly
			 * color expanded, but since the source pitch is ignored and
			 * the source address not incremented correctly, the following
			 * lines are color expanded with any bit pattern that is left
			 * in the unused space of the source bitmap (which is organized
			 * with the depth of the screen framebuffer hence with a pitch
			 * of scrnOffset).
			 */

#undef pitchdw    	/* Use source pitch "displayWidth / 8" instead
		   	 * of scrnOffset (=displayWidth * bpp / 8)
			 * This can't work, because the pitch of the source
			 * bitmap is scrnoffset!
		   	 */

#define  nopitch   	/* Calculate srcbase with srcx and srcy, set the
		   	 * pitch to scrnOffset (which IS the correct pitch
		   	 * for the source bitmap) and set srcx and srcy both
		   	 * to 0.
			 * This would work if the hareware used the source pitch for
			 * incrementing the source address after each scanline - but
			 * it doesn't do this! Again: The first line of the area is
			 * correctly color expanded, but since the source pitch is
			 * ignored for scanline address incremention, the following
			 * lines are not correctly color expanded.
			 * WHATEVER I write to source pitch is ignored!
		   	 */

static void
SiSSubsequentScreenToScreenColorExpand(ScrnInfoPtr pScrn,
                                int x, int y, int w, int h,
                                int srcx, int srcy, int skipleft)
{
	SISPtr pSiS = SISPTR(pScrn);
        long srcbase, dstbase;
#if 0
	int _x0, _y0, _x1, _y1;
#endif
#ifdef pitchdw
	int newsrcx, newsrcy;

	/* srcx and srcy are provided based on a scrnOffset pitch ( = displayWidth * bpp / 8 )
	 * We recalulate srcx and srcy based on pitch = displayWidth / 8
	 */
        newsrcy = ((pSiS->scrnOffset * srcy) + (srcx * ((pScrn->bitsPerPixel+7)/8))) /
					  (pScrn->displayWidth/8);
        newsrcx = ((pSiS->scrnOffset * srcy) + (srcx * ((pScrn->bitsPerPixel+7)/8))) %
					  (pScrn->displayWidth/8);
#endif
	xf86DrvMsg(0, X_INFO, "Sub ScreenToScreen ColorExp(%d,%d, %d,%d, %d,%d, %d)\n",
					x, y, w, h, srcx, srcy, skipleft);

	srcbase = dstbase = 0;

#ifdef pitchdw
	if(newsrcy >= 2048) {
	   srcbase = (pScrn->displayWidth / 8) * newsrcy;
	   newsrcy = 0;
	}
#endif
#ifdef nopitch
	srcbase = (pSiS->scrnOffset * srcy) + (srcx * ((pScrn->bitsPerPixel+7)/8));
#endif
#ifdef npitch
	if(srcy >= 2048) {
	   srcbase = pSiS->scrnOffset * srcy;
	   srcy = 0;
	}
#endif
	if(y >= 2048) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   srcbase += HEADOFFSET;
	   dstbase += HEADOFFSET;
	}
#endif
	SiSSetupSRCBase(srcbase)
	SiSSetupDSTBase(dstbase)

#ifdef pitchdw
	SiSSetupSRCPitch(pScrn->displayWidth/8)
#endif
#ifdef nopitch
	SiSSetupSRCPitch(pSiS->scrnOffset)
	/* SiSSetupSRCPitch(100) */ /* For test - has NO effect WHATSOEVER */
#endif
#ifdef npitch
	SiSSetupSRCPitch(pSiS->scrnOffset)
#endif

	SiSSetupRect(w,h)

#if 0   /* How do I implement the offset? Not this way, that's for sure.. */
	if (skipleft > 0) {
		_x0 = x+skipleft;
		_y0 = y;
		_x1 = x+w;
		_y1 = y+h;
		SiSSetupClipLT(_x0, _y0);
		SiSSetupClipRB(_x1, _y1);
		SiSSetupCMDFlag(CLIPENABLE);
	}
#endif
#ifdef pitchdw
	SiSSetupSRCXY(newsrcx, newsrcy)
#endif
#ifdef nopitch
	SiSSetupSRCXY(0,0)
#endif
#ifdef npitch
	SiSSetupSRCXY(srcx, srcy)
#endif

	SiSSetupDSTXY(x,y)

	SiSDoCMD
}
#endif

/* ----- CPU To Screen Color Expand (scanline-wise) ----------------- */

/* We do it using the indirect method */

static void
SiSSetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
		int fg, int bg, int rop, unsigned int planemask)
{
	SISPtr pSiS=SISPTR(pScrn);

        /* TW: Make sure that current CPU-driven BitBlt buffer stage is 0
	 *     This is required!!! (Otherwise -> drawing errors)
	 */
	while((MMIO_IN16(pSiS->IOBase, 0x8242) & 0x1F00) != 0) {} /* WDR: == 0x10 */

	SiSSetupSRCXY(0,0);
	SiSSetupROP(XAACopyROP[rop]);
	SiSSetupSRCFG(fg);
	SiSSetupDSTRect(pSiS->scrnOffset, -1);
	SiSSetupDSTColorDepth(pSiS->DstColor);
	if(bg == -1) {
	   SiSSetupCMDFlag(TRANSPARENT |
	                   ENCOLOREXP |
	   		   X_INC | Y_INC |
			   SRCCPUBLITBUF);
	} else {
	   SiSSetupSRCBG(bg);
	   SiSSetupCMDFlag(ENCOLOREXP |
	                   X_INC | Y_INC |
		   	   SRCCPUBLITBUF);
	}
}


static void
SiSSubsequentScanlineCPUToScreenColorExpandFill(
                        ScrnInfoPtr pScrn, int x, int y, int w,
                        int h, int skipleft)
{
	SISPtr pSiS = SISPTR(pScrn);
	int _x0, _y0, _x1, _y1;
	long dstbase;

	dstbase = 0;
	if((y >= 2048) || ((y + h) >= 2048)) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
	}
#endif

	/* TW: Wait until there is no color expansion command in queue
	 *     (This solves the OpenOffice.org window-move bug)
	 *     Added Idle-check - bit 23 is set sometimes, although
	 *     engine is actually idle!
	 *     Update: Bit 23 is not reliable. After heavy 3D engine
	 *     action, this bit never gets cleared again. So do
	 *     SiSIdle instead.
	 */
	if((MMIO_IN16(pSiS->IOBase, 0x8242) & 0xe000) != 0xe000) {
           /* while ((MMIO_IN16(pSiS->IOBase, 0x8242) & 0x0080) != 0) {} */
	   SiSIdle
	}

	SiSSetupDSTBase(dstbase)

	if(skipleft > 0) {
	   _x0 = x + skipleft;
	   _y0 = y;
	   _x1 = x + w;
	   _y1 = y + h;
	   SiSSetupClipLT(_x0, _y0);
	   SiSSetupClipRB(_x1, _y1);
	   SiSSetupCMDFlag(CLIPENABLE);
	} else {
	   pSiS->CommandReg &= (~CLIPENABLE);
	}

	SiSSetupRect(w, 1);
        SiSSetupSRCPitch(((((w+7)/8)+3) >> 2) * 4);
	pSiS->xcurrent = x;
	pSiS->ycurrent = y;
}

static void
SiSSubsequentColorExpandScanline(ScrnInfoPtr pScrn, int bufno)
{
	SISPtr pSiS=SISPTR(pScrn);
#if 0
	int newhead,bltbufstage,newtail;
#endif
	long cbo;

	cbo = pSiS->ColorExpandBufferScreenOffset[bufno];
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   cbo += HEADOFFSET;
	}
#endif

	/* TW: Wait until there is no color expansion command in queue
	 *     (This solves the GTK-big-font bug)
	 *     Added Idle-check - bit 23 is set sometimes, although
	 *     engine is actually idle!
	 *     Update: Bit 23 is not reliable. After heavy 3D engine
	 *     action, this bit never gets cleared again. So do
	 *     SiSIdle instead.
	 */
	if((MMIO_IN16(pSiS->IOBase, 0x8242) & 0xe000) != 0xe000) {
	   /* while ((MMIO_IN16(pSiS->IOBase, 0x8242) & 0x0080) != 0) {} */
	   SiSIdle
	}

	SiSSetupSRCBase(cbo);

	SiSSetupDSTXY(pSiS->xcurrent, pSiS->ycurrent);

	SiSDoCMD

	pSiS->ycurrent++;

	if(pSiS->VGAEngine == SIS_530_VGA) {
	   while(MMIO_IN8(pSiS->IOBase, 0x8242) & 0x80) {}
	}
}



@


1.1
log
@Initial revision
@
text
@d1 1
a1 2
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis300_accel.c,v 1.11 2002/01/11 15:37:32 dawes Exp $ */

d3 14
d18 10
a27 3
 *      Acceleration for SiS300 SiS630 SiS540.
 *      It is done in a separate file because the register formats are 
 *      very different from the previous chips.
d29 2
a31 2
 *      
 *      Xavier Ducoin <x.ducoin@@lectra.com>
d33 1
d45 2
d51 3
a53 2
#ifdef  DEBUG
static void MMIODump(ScrnInfoPtr pScrn);
d56 8
a63 1
Bool SiS300AccelInit(ScreenPtr pScreen);
d76 5
d99 7
d114 2
d121 2
d130 2
a131 2
static void SiSSetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn, 
                                int fg, int bg, int rop, 
d134 1
a134 1
                                int x, int y, int w, int h, 
d137 3
a139 6
#if 0
static void SiSSetupForImageWrite(ScrnInfoPtr pScrn, int rop, 
                                unsigned int planemask, int trans_color, 
                                int bpp, int depth);
static void SiSSubsequentImageWriteRect(ScrnInfoPtr pScrn, int x, int y, 
                                int w, int h, int skipleft);
d141 1
d164 1
a164 2
	if (!infoPtr)  
		return FALSE;
d169 2
a170 2
			   		 OFFSCREEN_PIXMAPS |
					 PIXMAP_CACHE;
d175 28
a202 2
	if ((pScrn->bitsPerPixel != 8) && (pScrn->bitsPerPixel != 16) &&
		(pScrn->bitsPerPixel != 32))         return FALSE;
d204 35
a238 32
	/* BitBlt */
	infoPtr->SetupForScreenToScreenCopy = SiSSetupForScreenToScreenCopy;
	infoPtr->SubsequentScreenToScreenCopy = SiSSubsequentScreenToScreenCopy;
	infoPtr->ScreenToScreenCopyFlags = NO_PLANEMASK | NO_TRANSPARENCY;

	/* solid fills */
	infoPtr->SetupForSolidFill = SiSSetupForSolidFill;
	infoPtr->SubsequentSolidFillRect = SiSSubsequentSolidFillRect;
	infoPtr->SolidFillFlags = NO_PLANEMASK;

	/* solid line */
	infoPtr->SetupForSolidLine = SiSSetupForSolidLine;
	infoPtr->SubsequentSolidTwoPointLine = SiSSubsequentSolidTwoPointLine;
	infoPtr->SubsequentSolidHorVertLine = SiSSubsequentSolidHorzVertLine;
	infoPtr->SolidFillFlags = NO_PLANEMASK;

	/* dashed line */
	infoPtr->SetupForDashedLine = SiSSetupForDashedLine;
	infoPtr->SubsequentDashedTwoPointLine = SiSSubsequentDashedTwoPointLine;
	infoPtr->DashPatternMaxLength = 64;
	infoPtr->DashedLineFlags = NO_PLANEMASK | 
					LINE_PATTERN_MSBFIRST_LSBJUSTIFIED;

	/* 8x8 mono pattern fill */
	infoPtr->SetupForMono8x8PatternFill = SiSSetupForMonoPatternFill;
	infoPtr->SubsequentMono8x8PatternFillRect =
							SiSSubsequentMonoPatternFill;
	infoPtr->Mono8x8PatternFillFlags = NO_PLANEMASK |
							HARDWARE_PATTERN_SCREEN_ORIGIN |
							HARDWARE_PATTERN_PROGRAMMED_BITS |
							NO_TRANSPARENCY |
							BIT_ORDER_IN_BYTE_MSBFIRST ;
d241 50
a290 58
	/* 8x8 color pattern fill ---seems not useful by xaa */
	infoPtr->SetupForColor8x8PatternFill =
	    SiSSetupForColorPatternFill;
	infoPtr->SubsequentColor8x8PatternFillRect =
	    SiSSubsequentColorPatternFill;
	infoPtr->Color8x8PatternFillFlags = NO_PLANEMASK |
	    HARDWARE_PATTERN_SCREEN_ORIGIN |
	    HARDWARE_PATTERN_PROGRAMMED_BITS ;

	/* Screen To Screen Color Expand */
	infoPtr->SetupForScreenToScreenColorExpandFill =
	    SiSSetupForScreenToScreenColorExpand;
	infoPtr->SubsequentScreenToScreenColorExpandFill =
	    SiSSubsequentScreenToScreenColorExpand;
	
	/* CPU To Screen Color Expand ---implement another instead of this one! */
	infoPtr->SetupForCPUToScreenColorExpandFill =
	    SiSSetupForCPUToScreenColorExpand;
	infoPtr->SubsequentCPUToScreenColorExpandFill =
	    SiSSubsequentCPUToScreenColorExpand;
	infoPtr->ColorExpandRange = PATREGSIZE;
	infoPtr->ColorExpandBase = pSiS->IOBase+PBR(0);
	infoPtr->CPUToScreenColorExpandFillFlags = NO_PLANEMASK |
	    BIT_ORDER_IN_BYTE_MSBFIRST |
	    NO_TRANSPARENCY |
	    SYNC_AFTER_COLOR_EXPAND |
	    HARDWARE_PATTERN_SCREEN_ORIGIN |
	    HARDWARE_PATTERN_PROGRAMMED_BITS ;
#endif

	/* per-scanline color expansion*/
	pSiS->ColorExpandBufferNumber = 16;     
	pSiS->ColorExpandBufferCountMask = 0x0F;
	pSiS->PerColorExpandBufferSize = ((pScrn->virtualX + 31)/32) * 4;       
	infoPtr->NumScanlineColorExpandBuffers = pSiS->ColorExpandBufferNumber;
	infoPtr->ScanlineColorExpandBuffers = (unsigned char **)&pSiS->ColorExpandBufferAddr[0];
	infoPtr->SetupForScanlineCPUToScreenColorExpandFill = SiSSetupForScanlineCPUToScreenColorExpandFill;
	infoPtr->SubsequentScanlineCPUToScreenColorExpandFill = SiSSubsequentScanlineCPUToScreenColorExpandFill;
	infoPtr->SubsequentColorExpandScanline = SiSSubsequentColorExpandScanline;
	infoPtr->ScanlineCPUToScreenColorExpandFillFlags =
	    NO_PLANEMASK |
	    CPU_TRANSFER_PAD_DWORD |
	    SCANLINE_PAD_DWORD |
	    BIT_ORDER_IN_BYTE_MSBFIRST |
	    LEFT_EDGE_CLIPPING;
	
#if 0
	divider = ((pScrn->virtualX*pScrn->bitsPerPixel)/8)+8;
	pSiS->ImageWriteBufferSize = (((12*1024)+divider-1)/divider)*divider;
	infoPtr->SetupForImageWrite = SiSSetupForImageWrite;
	infoPtr->SubsequentImageWriteRect = SiSSubsequentImageWriteRect;
	infoPtr->ImageWriteFlags = CPU_TRANSFER_PAD_DWORD |
	    SCANLINE_PAD_DWORD |
	    LEFT_EDGE_CLIPPING |    
	    NO_PLANEMASK|
	    NO_TRANSPARENCY |
	    NO_GXCOPY |
	    SYNC_AFTER_IMAGE_WRITE;
d294 3
d298 8
a305 20
        /* TW: check if maxxfbmem must contain TurboQueue and HWCursor */
	topFB = pSiS->maxxfbmem;
	if ((topFB)
	    >= (pSiS->FbMapSize)
	    - ((pSiS->TurboQueue) ? (1024*512) : 0)
	       - ((pSiS->HWCursor) ? 4096 : 0))  {
	    topFB = pSiS->FbMapSize;
	    /* TurboQueue len is always 512k */
	    if (pSiS->TurboQueue) topFB -= 1024*512;  
            /* HWCursor len is always 4096 */
	    if (pSiS->HWCursor)  topFB -= 4096;
	}
	reservedFbSize = (pSiS->ColorExpandBufferNumber
			   * pSiS->PerColorExpandBufferSize);
        /* TW: New for MaxXFBmem Option */
	UsableFbSize = topFB - reservedFbSize; 
	/* Layout:
	 * |--------------++++++++++++++++++++^******==========~~~~~~~~~~~~|
	 *   UsableFbSize  ColorExpandBuffers | Heap  HWCursor  TurboQueue
	 *                                 topFB
d307 1
d309 4
a312 4
	for (i = 0; i < pSiS->ColorExpandBufferNumber; i++) {
		pSiS->ColorExpandBufferAddr[i] = AvailBufBase + 
		    i * pSiS->PerColorExpandBufferSize;
		pSiS->ColorExpandBufferScreenOffset[i] = UsableFbSize +
d318 18
a335 5
	Avail.y2 = UsableFbSize
	    / (pScrn->displayWidth * pScrn->bitsPerPixel/8) - 1;
	if (Avail.y2 < 0)
		Avail.y2 = 32767;
	
d339 1
a339 1
	
d341 1
a341 1
	
d357 3
a359 1
static int sisALUConv[] =
d361 14
a374 37
    0x00,       /* dest = 0;            0,      GXclear,        0 */
    0x88,       /* dest &= src;         DSa,    GXand,          0x1 */
    0x44,       /* dest = src & ~dest;  SDna,   GXandReverse,   0x2 */
    0xCC,       /* dest = src;          S,      GXcopy,         0x3 */
    0x22,       /* dest &= ~src;        DSna,   GXandInverted,  0x4 */
    0xAA,       /* dest = dest;         D,      GXnoop,         0x5 */
    0x66,       /* dest = ^src;         DSx,    GXxor,          0x6 */
    0xEE,       /* dest |= src;         DSo,    GXor,           0x7 */
    0x11,       /* dest = ~src & ~dest; DSon,   GXnor,          0x8 */
    0x99,       /* dest ^= ~src ;       DSxn,   GXequiv,        0x9 */
    0x55,       /* dest = ~dest;        Dn,     GXInvert,       0xA */
    0xDD,       /* dest = src|~dest ;   SDno,   GXorReverse,    0xB */
    0x33,       /* dest = ~src;         Sn,     GXcopyInverted, 0xC */
    0xBB,       /* dest |= ~src;        DSno,   GXorInverted,   0xD */
    0x77,       /* dest = ~src|~dest;   DSan,   GXnand,         0xE */
    0xFF,       /* dest = 0xFF;         1,      GXset,          0xF */
};
/* same ROP but with Pattern as Source */
static int sisPatALUConv[] =
{
    0x00,       /* dest = 0;            0,      GXclear,        0 */
    0xA0,       /* dest &= src;         DPa,    GXand,          0x1 */
    0x50,       /* dest = src & ~dest;  PDna,   GXandReverse,   0x2 */
    0xF0,       /* dest = src;          P,      GXcopy,         0x3 */
    0x0A,       /* dest &= ~src;        DPna,   GXandInverted,  0x4 */
    0xAA,       /* dest = dest;         D,      GXnoop,         0x5 */
    0x5A,       /* dest = ^src;         DPx,    GXxor,          0x6 */
    0xFA,       /* dest |= src;         DPo,    GXor,           0x7 */
    0x05,       /* dest = ~src & ~dest; DPon,   GXnor,          0x8 */
    0xA5,       /* dest ^= ~src ;       DPxn,   GXequiv,        0x9 */
    0x55,       /* dest = ~dest;        Dn,     GXInvert,       0xA */
    0xF5,       /* dest = src|~dest ;   PDno,   GXorReverse,    0xB */
    0x0F,       /* dest = ~src;         Pn,     GXcopyInverted, 0xC */
    0xAF,       /* dest |= ~src;        DPno,   GXorInverted,   0xD */
    0x5F,       /* dest = ~src|~dest;   DPan,   GXnand,         0xE */
    0xFF,       /* dest = 0xFF;         1,      GXset,          0xF */
};
a380 1
/*      XAAInfoRecPtr   pXAA = XAAPTR(pScrn);*/
d384 2
a385 41
/*
	ErrorF("XAAInfoPtr->UsingPixmapCache = %s\n"
			"XAAInfoPtr->CanDoMono8x8 = %s\n"
			"XAAInfoPtr->CanDoColor8x8 = %s\n"
			"XAAInfoPtr->CachePixelGranularity = %d\n"
			"XAAInfoPtr->MaxCacheableTileWidth = %d\n"
			"XAAInfoPtr->MaxCacheableTileHeight = %d\n"
			"XAAInfoPtr->MaxCacheableStippleWidth = %d\n"
			"XAAInfoPtr->MaxCacheableStippleHeight = %d\n"
			"XAAInfoPtr->MonoPatternPitch = %d\n"
			"XAAInfoPtr->CacheWidthMono8x8Pattern = %d\n"
			"XAAInfoPtr->CacheHeightMono8x8Pattern = %d\n"
			"XAAInfoPtr->ColorPatternPitch = %d\n"
			"XAAInfoPtr->CacheWidthColor8x8Pattern = %d\n"
			"XAAInfoPtr->CacheHeightColor8x8Pattern = %d\n"
			"XAAInfoPtr->CacheColorExpandDensity = %d\n"
			"XAAInfoPtr->maxOffPixWidth = %d\n"
			"XAAInfoPtr->maxOffPixHeight= %d\n"
			"XAAInfoPtr->NeedToSync = %s\n"
			"\n",
					pXAA->UsingPixmapCache ? "True" : "False",
					pXAA->CanDoMono8x8 ? "True" : "False",
					pXAA->CanDoColor8x8 ? "True" : "False",
					pXAA->CachePixelGranularity,
					pXAA->MaxCacheableTileWidth,
					pXAA->MaxCacheableTileHeight,
					pXAA->MaxCacheableStippleWidth,
					pXAA->MaxCacheableStippleHeight,
					pXAA->MonoPatternPitch,
					pXAA->CacheWidthMono8x8Pattern,
					pXAA->CacheHeightMono8x8Pattern,
					pXAA->ColorPatternPitch,
					pXAA->CacheWidthColor8x8Pattern,
					pXAA->CacheHeightColor8x8Pattern,
					pXAA->CacheColorExpandDensity,
					pXAA->maxOffPixWidth,
					pXAA->maxOffPixHeight,
					pXAA->NeedToSync ? "True" : "False");
*/
					
	SiSSetupDSTColorDepth(SISPTR(pScrn)->DstColor);
d388 7
a394 3
	SiSSetupROP(sisALUConv[rop])
	if (xdir > 0) {
		SiSSetupCMDFlag(X_INC)
d396 5
a400 2
	if (ydir > 0) {
		SiSSetupCMDFlag(Y_INC)
d415 14
a428 8
	if (src_y >= 2048) { 
		srcbase = pSiS->scrnOffset * src_y;
		src_y = 0;
	}       
	if (dst_y >= pScrn->virtualY) {
		dstbase = pSiS->scrnOffset*dst_y;
		dst_y = 0;
	}       
d431 8
a438 7
	if (!(pSiS->CommandReg & X_INC))  {
		src_x += width-1;
		dst_x += width-1;
	}
	if (!(pSiS->CommandReg & Y_INC))  {
		src_y += height-1;
		dst_y += height-1;
d443 1
d456 5
a461 1
/*      SiSSetupDSTRect(pSiS->scrnOffset, pScrn->virtualY)*/
d463 3
a465 3
	SiSSetupDSTColorDepth(SISPTR(pScrn)->DstColor);
	SiSSetupROP(sisPatALUConv[rop])
	SiSSetupCMDFlag(X_INC | Y_INC | PATFG | BITBLT)
d478 10
a487 4
	if (y >= 2048) { 
		dstbase=pSiS->scrnOffset*y;
		y = 0;
	}
d491 114
d607 1
a619 1
/*      SiSSetupDSTRect(pSiS->scrnOffset, pScrn->virtualY)*/
d621 2
a622 2
	SiSSetupDSTColorDepth(SISPTR(pScrn)->DstColor);
	SiSSetupROP(sisPatALUConv[rop])
d639 8
a646 4
	if (maxy >= 2048) {
		dstbase = pSiS->scrnOffset*miny;
		y1 -= miny;
		y2 -= miny;
d648 1
d653 6
a658 2
	if (flags & OMIT_LAST)
		SiSSetupCMDFlag(NO_LAST_PIXEL)
d672 1
d674 7
a680 3
	if ((y >= 2048) || ((y + len) >= 2048)) { 
		dstbase = pSiS->scrnOffset * y;
		y = 0;
d682 1
d686 4
a689 5
	if (dir == DEGREES_0) {
		SiSSetupX1Y1(x + len, y);
	}
	else {
		SiSSetupX1Y1(x, y + len);
d691 1
a705 1
/*      SiSSetupDSTRect(pSiS->scrnOffset, pScrn->virtualY)*/
d707 1
a707 1
	SiSSetupDSTColorDepth(SISPTR(pScrn)->DstColor);
d710 2
a711 1
	SiSSetupROP(sisPatALUConv[rop])
d713 6
a718 2
	if (bg != -1) 
		SiSSetupPATBG(bg)
d733 10
a742 6
	miny=(y1 > y2) ? y2 : y1;
	maxy=(y1 > y2) ? y1 : y2;
	if (maxy >= 2048) {
		dstbase = pSiS->scrnOffset * miny;
		y1 -= miny;
		y2 -= miny;
d744 1
d749 4
a752 2
	if (flags & OMIT_LAST) {
		SiSSetupCMDFlag(NO_LAST_PIXEL)
d754 1
a766 1

d768 1
a768 1
	SiSSetupDSTColorDepth(SISPTR(pScrn)->DstColor);
d771 7
a777 3
	SiSSetupROP(sisPatALUConv[rop])
	SiSSetupCMDFlag(PATMONO | X_INC | Y_INC)
	SiSSetupPATBG(bg)
d791 8
a798 3
	if (y >= 2048) { 
		dstbase = pSiS->scrnOffset * y;
		y = 0;
d800 10
a810 3
	SiSSetupDSTBase(dstbase)
	SiSSetupDSTXY(x,y)
	SiSSetupRect(w,h)
d814 2
a815 1
#if 0
d817 5
a821 4
SiSSetupForColorPatternFill(ScrnInfoPtr pScrn,
                                int patx, int paty, int rop,
                                unsigned int planemask,
                                int trans_color)
d823 5
a827 1
	SISPtr pSiS = SISPTR(pScrn);
d829 11
a839 2
	PDEBUG(ErrorF("Setup ColorPatFill(0x%x,0x%x, 0x%x,0x%x, 0x%x)\n",
					patx, paty, rop, planemask, trans_color));
d841 5
a845 6
/*      SiSSetupDSTRect(pSiS->scrnOffset, pScrn->virtualY)*/
	SiSSetupDSTRect(pSiS->scrnOffset, -1)
	SiSSetupDSTColorDepth(SISPTR(pScrn)->DstColor);
	SiSSetupROP(sisPatALUConv[rop])
	SiSSetupCMDFlag(PATPATREG | X_INC | Y_INC)
}
d847 4
a850 7
static void
SiSSubsequentColorPatternFill(ScrnInfoPtr pScrn,
                                int patx, int paty,
                                int x, int y, int w, int h)
{
	SISPtr pSiS = SISPTR(pScrn);
	long dstbase;
d852 4
a855 2
	PDEBUG(ErrorF("Subsequent ColorPatFill(0x%x,0x%x, %d,%d, %d,%d)\n",
							patx, paty, x, y, w, h));
d857 6
a862 4
	dstbase = 0;
	if (y >= 2048) {
		dstbase = pSiS->scrnOffset * y;
		y = 0;
d864 12
a875 3
	SiSSetupDSTBase(dstbase)
	SiSSetupDSTXY(x,y)
	SiSSetupRect(w,h)
d878 6
d885 5
d902 1
a902 1
	SiSSetupDSTColorDepth(SISPTR(pScrn)->DstColor);
d905 1
a905 1
	SiSSetupROP(sisPatALUConv[rop])
d907 4
a910 5
	if (bg == -1) {
		SiSSetupCMDFlag(TRANSPARENT)
	}
	else {
		SiSSetupSRCBG(bg)
d925 3
a927 3
	if (y >= 2048) {
			dstbase = pSiS->scrnOffset * y;
			y = 0;
d938 3
d942 3
d955 1
a955 2
	SiSSetupDSTBase(0)
/*      SiSSetupDSTRect(pSiS->scrnOffset, pScrn->virtualY)*/
d957 1
a957 1
	SiSSetupDSTColorDepth(SISPTR(pScrn)->DstColor);
d959 10
a968 4
	SiSSetupSRCBG(bg)
	SiSSetupSRCXY(0,0)
	SiSSetupROP(sisALUConv[rop])
	SiSSetupCMDFlag(X_INC | Y_INC | ENCOLOREXP)
d970 42
d1018 61
a1078 1
	SISPtr          pSiS = SISPTR(pScrn);
d1080 20
a1099 2
	PDEBUG(ErrorF("Sub ScreenToScreen ColorExp(%d,%d, %d,%d, %d,%d, %d)\n",
							x, y, w, h, srcx, srcy, skipleft));
a1100 1
	SiSSetupSRCPitch(((w+31)&0xFFE0)/8)
d1102 1
a1102 1
	SiSSetupRect(w,h)
d1107 7
a1113 2
static void 
SiSSetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn, int fg, int bg, int rop, unsigned int planemask)
d1116 6
a1121 4
	
	while ((MMIO_IN16(pSiS->IOBase, 0x8242) & 0x1F00)!=0) {}
	pSiS->ColorExpandRingHead = 0;
	pSiS->ColorExpandRingTail = pSiS->ColorExpandBufferNumber - 1;
d1123 1
a1123 1
	SiSSetupROP(sisALUConv[rop]);
d1127 11
a1137 9
	if (bg == -1) { 
		SiSSetupCMDFlag(TRANSPARENT | ENCOLOREXP | X_INC |
						Y_INC|SRCSYSTEM);  
	}
	else {
		SiSSetupSRCBG(bg);
		SiSSetupCMDFlag(ENCOLOREXP | X_INC | Y_INC |
						SRCSYSTEM);      
	};
d1140 4
a1143 4
static int     srcpitch;
static int     xcurrent, ycurrent;     
static void SiSSubsequentScanlineCPUToScreenColorExpandFill(
                        ScrnInfoPtr pScrn, int x, int y, int w, 
d1151 21
a1171 3
	if (y >= 2048) {
		dstbase = pSiS->scrnOffset*y;
		y = 0;
d1173 1
d1176 12
a1187 9
	if (skipleft > 0) {
		_x0 = x+skipleft;
		_y0 = y;
		_x1 = x+w;
		_y1 = y+h;
		SiSSetupClipLT(_x0, _y0);
		SiSSetupClipRB(_x1, _y1);
		SiSSetupCMDFlag(CLIPENABLE);    
	} 
d1189 3
a1191 4
	srcpitch = ((((w+7)/8)+3) >> 2) * 4;
	SiSSetupSRCPitch(srcpitch);
	ycurrent = y;
	xcurrent = x;
d1194 2
a1195 1
static void SiSSubsequentColorExpandScanline(ScrnInfoPtr pScrn, int bufno)
d1197 2
a1198 1
	SISPtr pSiS=SISPTR(pScrn);              
d1200 9
d1210 11
a1220 12
	SiSSetupSRCBase(pSiS->ColorExpandBufferScreenOffset[bufno]);
	SiSSetupDSTXY(xcurrent, ycurrent);
	ycurrent++;
	SiSDoCMD
	newhead = pSiS->ColorExpandRingHead = (bufno + 1) & 
							pSiS->ColorExpandBufferCountMask;
	while (newhead == pSiS->ColorExpandRingTail) {
		bltbufstage = (int)((MMIO_IN16(pSiS->IOBase,0x8242) & 
							0x1F00)>>8);
		newtail = newhead - (bltbufstage + 1);
		pSiS->ColorExpandRingTail = (newtail >= 0) ? 
							newtail: (pSiS->ColorExpandBufferNumber+newtail);
a1221 1
}
d1223 3
a1225 6
#if 0
static void SiSSetupForImageWrite(ScrnInfoPtr pScrn, int rop, 
            unsigned int planemask, int trans_color, int bpp, int depth)
{
	return;
}
d1227 1
a1227 6
static void SiSSubsequentImageWriteRect(ScrnInfoPtr pScrn, 
            int x, int y, int w, int h, int skipleft)
{
	return;
}
#endif
d1229 1
a1229 6
#ifdef DEBUG
static void
MMIODump(ScrnInfoPtr pScrn)
{
	SISPtr  pSiS = SISPTR(pScrn);
	int     i;
d1231 2
a1232 4
	SiSIdle
	for (i=0x8200; i <= 0x823c; i += 4)  {
		ErrorF("[%x] %0X \n", i,
				MMIO_IN32(pSiS->IOBase,i));
d1235 3
a1237 1
#endif
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 2
a2 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis300_accel.c,v 1.27 2004/01/23 22:29:04 twini Exp $ */
a3 17
 * 2D Acceleration for SiS 530, 620, 300, 540, 630, 730.
 *
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement: "This product includes
 *    software developed by Thomas Winischhofer, Vienna, Austria."
 * 4) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d5 3
a7 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a8 2
 * Authors:   Thomas Winischhofer <thomas@@winischhofer.net>
 *	      Can-Ru Yeou, SiS Inc.
d10 2
a12 1

a23 2
#include "xaalocal.h"
#include "xaarop.h"
d28 2
a29 3
#ifdef SISDUALHEAD
/* TW: This is the offset to the memory for each head */
#define HEADOFFSET 	(pSiS->dhmOffset)
d32 1
a32 8
#undef STSCE    	/* TW: Use/Don't use ScreenToScreenColorExpand - does not work */

#undef TRAP     	/* TW: Use/Don't use Trapezoid Fills - does not work - XAA provides
		         * illegal trapezoid data (left and right edges cross each other
			 * sometimes) which causes drawing errors. Further, I have not found
			 * out how to draw polygones with a height greater than 127...
                         */

a44 5
#ifdef TRAP
static void SiSSubsequentSolidFillTrap(ScrnInfoPtr pScrn, int y, int h,
	                        int left, int dxL, int dyL, int eL,
	                        int right, int dxR, int dyR, int eR);
#endif
a62 7
#ifdef TRAP
static void SiSSubsequentMonoPatternFillTrap(ScrnInfoPtr pScrn,
                                int patx, int paty,
                                int y, int h,
                                int left, int dxL, int dyL, int eL,
	                        int right, int dxR, int dyR, int eR );
#endif
a70 2
#endif
#if 0
a75 2
#endif
#ifdef STSCE
d83 2
a84 2
static void SiSSetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
                                int fg, int bg, int rop,
d87 1
a87 1
                                int x, int y, int w, int h,
d90 6
a95 3

#ifdef SISDUALHEAD
static void SiSRestoreAccelState(ScrnInfoPtr pScrn);
a96 1

d119 2
a120 1
	if (!infoPtr)  return FALSE;
d125 2
a126 2
			 OFFSCREEN_PIXMAPS |
			 PIXMAP_CACHE;
d131 2
a132 12
	/* Acceleration only supported at 8, 16 and 32 bpp */
	if((pScrn->bitsPerPixel != 8) && (pScrn->bitsPerPixel != 16) &&
	         (pScrn->bitsPerPixel != 32))
	    return FALSE;

	/* TW: Although SiS states that the 300 series supports a
	 *     virtual framebuffer of 4096x4096, the 2D accelerator
	 *     does not seem to know that. If the destination bitmap
	 *     pitch is > 8192 (which easily happens in 32bpp mode),
	 *     the accelerator engine collapses.
	 *     TODO: Find out about the 530 and 620
	 */
d134 32
a165 51
	if(pSiS->scrnOffset < 8192) {

	   /* screen to screen copy */
	   infoPtr->SetupForScreenToScreenCopy = SiSSetupForScreenToScreenCopy;
	   infoPtr->SubsequentScreenToScreenCopy = SiSSubsequentScreenToScreenCopy;
	   infoPtr->ScreenToScreenCopyFlags = NO_PLANEMASK |
	                                      TRANSPARENCY_GXCOPY_ONLY;

	   /* solid fills */
	   infoPtr->SetupForSolidFill = SiSSetupForSolidFill;
	   infoPtr->SubsequentSolidFillRect = SiSSubsequentSolidFillRect;
#ifdef TRAP
	   infoPtr->SubsequentSolidFillTrap = SiSSubsequentSolidFillTrap;
#endif
	   infoPtr->SolidFillFlags = NO_PLANEMASK;

	   /* solid line */
	   infoPtr->SetupForSolidLine = SiSSetupForSolidLine;
	   infoPtr->SubsequentSolidTwoPointLine = SiSSubsequentSolidTwoPointLine;
	   infoPtr->SubsequentSolidHorVertLine = SiSSubsequentSolidHorzVertLine;
	   infoPtr->SolidLineFlags = NO_PLANEMASK;

	   /* dashed line */
	   infoPtr->SetupForDashedLine = SiSSetupForDashedLine;
	   infoPtr->SubsequentDashedTwoPointLine = SiSSubsequentDashedTwoPointLine;
	   infoPtr->DashPatternMaxLength = 64;
	   infoPtr->DashedLineFlags = NO_PLANEMASK |
	  			      LINE_PATTERN_MSBFIRST_LSBJUSTIFIED;

	   /* 8x8 mono pattern fill */
	   infoPtr->SetupForMono8x8PatternFill = SiSSetupForMonoPatternFill;
	   infoPtr->SubsequentMono8x8PatternFillRect = SiSSubsequentMonoPatternFill;
#ifdef TRAP
	   infoPtr->SubsequentMono8x8PatternFillTrap = SiSSubsequentMonoPatternFillTrap;
#endif
	   infoPtr->Mono8x8PatternFillFlags = NO_PLANEMASK |
					      HARDWARE_PATTERN_SCREEN_ORIGIN |
					      HARDWARE_PATTERN_PROGRAMMED_BITS |
					      /* NO_TRANSPARENCY | */
					      BIT_ORDER_IN_BYTE_MSBFIRST ;

#ifdef STSCE
	   /* Screen To Screen Color Expand */
	   /* TW: The hardware does support this the way we need it */
	   infoPtr->SetupForScreenToScreenColorExpandFill =
	    			SiSSetupForScreenToScreenColorExpand;
	   infoPtr->SubsequentScreenToScreenColorExpandFill =
	    			SiSSubsequentScreenToScreenColorExpand;
	   infoPtr->ScreenToScreenColorExpandFillFlags = NO_PLANEMASK |
	                                              BIT_ORDER_IN_BYTE_MSBFIRST ;
#endif
d168 58
a225 13
	   /* CPU To Screen Color Expand --- implement another instead of this one! */
	   infoPtr->SetupForCPUToScreenColorExpandFill =
	       SiSSetupForCPUToScreenColorExpand;
	   infoPtr->SubsequentCPUToScreenColorExpandFill =
	       SiSSubsequentCPUToScreenColorExpand;
	   infoPtr->ColorExpandRange = PATREGSIZE;
	   infoPtr->ColorExpandBase = pSiS->IOBase+PBR(0);
	   infoPtr->CPUToScreenColorExpandFillFlags = NO_PLANEMASK |
	   					      BIT_ORDER_IN_BYTE_MSBFIRST |
	    					      NO_TRANSPARENCY |
	    					      SYNC_AFTER_COLOR_EXPAND |
	    					      HARDWARE_PATTERN_SCREEN_ORIGIN |
	    					      HARDWARE_PATTERN_PROGRAMMED_BITS ;
d228 1
a228 36
	   /* per-scanline color expansion (using indirect method) */
	   if(pSiS->VGAEngine == SIS_530_VGA) {
	      pSiS->ColorExpandBufferNumber = 4;
	      pSiS->ColorExpandBufferCountMask = 0x03;
	   } else {
	      pSiS->ColorExpandBufferNumber = 16;
	      pSiS->ColorExpandBufferCountMask = 0x0F;
	   }
	   pSiS->PerColorExpandBufferSize = ((pScrn->virtualX + 31)/32) * 4;
	   infoPtr->NumScanlineColorExpandBuffers = pSiS->ColorExpandBufferNumber;
	   infoPtr->ScanlineColorExpandBuffers = (unsigned char **)&pSiS->ColorExpandBufferAddr[0];

	   infoPtr->SetupForScanlineCPUToScreenColorExpandFill =
	                            SiSSetupForScanlineCPUToScreenColorExpandFill;
	   infoPtr->SubsequentScanlineCPUToScreenColorExpandFill =
	                            SiSSubsequentScanlineCPUToScreenColorExpandFill;
	   infoPtr->SubsequentColorExpandScanline =
	                            SiSSubsequentColorExpandScanline;
	   infoPtr->ScanlineCPUToScreenColorExpandFillFlags = NO_PLANEMASK |
	    						      CPU_TRANSFER_PAD_DWORD |
	    						      SCANLINE_PAD_DWORD |
	    						      BIT_ORDER_IN_BYTE_MSBFIRST |
	    						      LEFT_EDGE_CLIPPING;
        } else {
	   xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	   	"Virtual screen width too large for accelerator engine\n");
           xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	   	"2D acceleration and Xv disabled\n");
           pSiS->NoXvideo = TRUE;
	}

#ifdef SISDUALHEAD
	if(pSiS->DualHeadMode) {
	   infoPtr->RestoreAccelState = SiSRestoreAccelState;
	}
#endif
d230 1
a230 1
	/* init Frame Buffer Manager */
d232 18
a249 11

	reservedFbSize = pSiS->ColorExpandBufferNumber * pSiS->PerColorExpandBufferSize;

	UsableFbSize = topFB - reservedFbSize;

	/* Layout: (Sizes do not reflect correct proportions)
	 * |--------------++++++++++++++++++++^************==========~~~~~~~~~~~~|
	 *   UsableFbSize  ColorExpandBuffers | DRI-Heap  |  HWCursor  TurboQueue   300/310/325 series
	 * |--------------++++++++++++++++++++|  ====================~~~~~~~~~~~~|
	 *   UsableFbSize  ColorExpandBuffers |        TurboQueue     HWCursor      530/620
	 *                                  topFB
a250 1

d252 4
a255 4
	for(i = 0; i < pSiS->ColorExpandBufferNumber; i++) {
	   pSiS->ColorExpandBufferAddr[i] = AvailBufBase +
	 	    i * pSiS->PerColorExpandBufferSize;
	   pSiS->ColorExpandBufferScreenOffset[i] = UsableFbSize +
d261 5
a265 18
	Avail.y2 = (UsableFbSize / (pScrn->displayWidth * pScrn->bitsPerPixel/8)) - 1;

	if(Avail.y2 < 0)  Avail.y2 = 32767;

	if(Avail.y2 < pScrn->currentMode->VDisplay) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			"Not enough video RAM for accelerator. At least "
			"%dKB needed, %ldKB available\n",
			((((pScrn->displayWidth * pScrn->bitsPerPixel/8)   /* TW: +8 for make it sure */
			     * pScrn->currentMode->VDisplay) + reservedFbSize) / 1024) + 8,
			pSiS->maxxfbmem/1024);
		pSiS->NoAccel = TRUE;
		pSiS->NoXvideo = TRUE;
		XAADestroyInfoRec(pSiS->AccelInfoPtr);
		pSiS->AccelInfoPtr = NULL;
		return FALSE;
	}

d269 1
a269 1

d271 1
a271 1

d287 1
a287 3
#ifdef SISDUALHEAD
static void
SiSRestoreAccelState(ScrnInfoPtr pScrn)
d289 37
a325 14
	SISPtr pSiS = SISPTR(pScrn);

	/* TW: We don't need to do anything special here; forcing the
	 *     other head to re-read the CmdQueLen is not necessary:
	 *     After the Sync in RestoreAccelState(), the real queue
	 *     length is always larger than (or at least equal to)
	 *     the amount stored in CmdQueueLen of the other head,
	 *     so the only thing that might happen is one unnecessary
	 *     Sync on the other head. I think we can live with that.
	 */
	pSiS->DoColorExpand = FALSE;
	SiSIdle
}
#endif
d332 1
d336 41
a376 2

	SiSSetupDSTColorDepth(pSiS->DstColor);
d379 3
a381 7

	if(trans_color != -1) {
	   SiSSetupROP(0x0A)
	   SiSSetupSRCTrans(trans_color)
	   SiSSetupCMDFlag(TRANSPARENT_BITBLT)
	} else {
	   SiSSetupROP(XAACopyROP[rop])
d383 2
a384 5
	if(xdir > 0) {
	   SiSSetupCMDFlag(X_INC)
	}
	if(ydir > 0) {
	   SiSSetupCMDFlag(Y_INC)
d399 8
a406 14
	if(src_y >= 2048) {
	   srcbase = pSiS->scrnOffset * src_y;
	   src_y = 0;
	}
	if((dst_y >= pScrn->virtualY) || (dst_y >= 2048)) {
	   dstbase = pSiS->scrnOffset * dst_y;
	   dst_y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   srcbase += HEADOFFSET;
	   dstbase += HEADOFFSET;
	}
#endif
d409 7
a415 8

	if(!(pSiS->CommandReg & X_INC))  {
	   src_x += width-1;
	   dst_x += width-1;
	}
	if(!(pSiS->CommandReg & Y_INC))  {
	   src_y += height-1;
	   dst_y += height-1;
a419 1

a431 5
	if(pSiS->disablecolorkeycurrent) {
	   if((CARD32)color == pSiS->colorKey) {
	      rop = 5;  /* NOOP */
	   }
	}
d433 1
d435 3
a437 3
	SiSSetupDSTColorDepth(pSiS->DstColor);
	SiSSetupROP(XAAPatternROP[rop])
	/* SiSSetupCMDFlag(PATFG) - is zero */
d450 4
a453 10

	if(y >= 2048) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
	}
#ifdef SISDUALHEAD
        if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
        }
#endif
a456 114
	/* Clear commandReg because Setup can be used for Rect and Trap */
	pSiS->CommandReg &= ~(T_XISMAJORL | T_XISMAJORR |
	                      T_L_X_INC | T_L_Y_INC |
	                      T_R_X_INC | T_R_Y_INC |
			      TRAPAZOID_FILL);
	SiSSetupCMDFlag(X_INC | Y_INC | BITBLT)

	SiSDoCMD
}

/* TW: Trapezoid */
/* This would work better if XAA would provide us with valid trapezoids.
 * In fact, with small trapezoids the left and the right edge often cross
 * each other or result in a line length of 0 which causes drawing errors
 * (filling over whole scanline).
 * Furthermore, I have not found out how to draw trapezoids with a height
 * greater than 127.
 */
#ifdef TRAP
static void
SiSSubsequentSolidFillTrap(ScrnInfoPtr pScrn, int y, int h,
	       int left,  int dxL, int dyL, int eL,
	       int right, int dxR, int dyR, int eR )
{
	SISPtr  pSiS = SISPTR(pScrn);
	long dstbase;
#if 0
	float kL, kR;
#endif

	dstbase = 0;
	if(y >= 2048) {
	   dstbase=pSiS->scrnOffset*y;
	   y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
	}
#endif
	SiSSetupDSTBase(dstbase)
	/* SiSSetupRect(w,h) */

#if 1
	SiSSetupPATFG(0xff0000) /* FOR TESTING */
#endif

	/* Clear CommandReg because SetUp can be used for Rect and Trap */
	pSiS->CommandReg &= ~(T_L_X_INC | T_L_Y_INC |
	                      T_R_X_INC | T_R_Y_INC |
	                      T_XISMAJORL | T_XISMAJORR |
			      BITBLT);

        xf86DrvMsg(0, X_INFO, "Trap (%d %d %d %d) dxL %d dyL %d eL %d   dxR %d dyR %d eR %d\n",
		left, right, y, h, dxL, dyL, eL, dxR, dyR, eR);

	/* Unfortunately, we must check if the right and the left edge
	 * cross each other...  INCOMPLETE (line equation wrong)
	 */
#if 0
	if (dxL == 0) kL = 0;
	else kL = (float)dyL / (float)dxL;
	if (dxR == 0) kR = 0;
	else kR = (float)dyR / (float)dxR;
	xf86DrvMsg(0, X_INFO, "kL %f kR %f!\n", kL, kR);
	if ( (kR != kL) &&
	     (!(kR == 0 && kL == 0)) &&
	     (!(kR <  0 && kL >  0)) ) {
	   xf86DrvMsg(0, X_INFO, "Inside if (%f - %d)\n", ( kL * ( ( ((float)right - (float)left) / (kL - kR) ) - left) + y), h+y);
           if ( ( ( kL * ( ( ((float)right - (float)left) / (kL - kR) ) - (float)left) + (float)y) < (h + y) ) ) {
	     xf86DrvMsg(0, X_INFO, "Cross detected!\n");
	   }
	}
#endif

	/* Determine egde angles */
	if(dxL < 0) { dxL = -dxL; }
	else { SiSSetupCMDFlag(T_L_X_INC) }
	if(dxR < 0) { dxR = -dxR; }
	else { SiSSetupCMDFlag(T_R_X_INC) }

	/* (Y direction always positive - do this anyway) */
	if(dyL < 0) { dyL = -dyL; }
	else { SiSSetupCMDFlag(T_L_Y_INC) }
	if(dyR < 0) { dyR = -dyR; }
	else { SiSSetupCMDFlag(T_R_Y_INC) }

	/* Determine major axis */
	if(dxL >= dyL) {      /* X is major axis */
	   SiSSetupCMDFlag(T_XISMAJORL)
	}
	if(dxR >= dyR) {      /* X is major axis */
	   SiSSetupCMDFlag(T_XISMAJORR)
	}

	/* Set up deltas */
	SiSSetupdL(dxL, dyL)
	SiSSetupdR(dxR, dyR)

#if 0   /* Could it be that this crappy engine can only draw trapezoids up to 127 pixels high? */
	h &= 0x7F;
	if (h == 0) h = 10;
#endif

	/* Set up y, h, left, right */
	SiSSetupYH(y,h)
	SiSSetupLR(left,right)

	/* Set up initial error term */
	SiSSetupEL(eL)
	SiSSetupER(eR)

	SiSSetupCMDFlag(TRAPAZOID_FILL);

a458 1
#endif
d471 1
d473 2
a474 2
	SiSSetupDSTColorDepth(pSiS->DstColor);
	SiSSetupROP(XAAPatternROP[rop])
d491 4
a494 8
	if(maxy >= 2048) {
	   dstbase = pSiS->scrnOffset * miny;
	   y1 -= miny;
	   y2 -= miny;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
a495 1
#endif
d500 2
a501 6
	if(flags & OMIT_LAST) {
	   SiSSetupCMDFlag(NO_LAST_PIXEL)
	} else {
	   pSiS->CommandReg &= ~(NO_LAST_PIXEL);
	}

a514 1

d516 3
a518 7
	if((y >= 2048) || ((dir != DEGREES_0) && ((y + len) >= 2048))) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
a519 1
#endif
d523 5
a527 4
	if(dir == DEGREES_0) {
	   SiSSetupX1Y1(x + len, y);
	} else {
	   SiSSetupX1Y1(x, y + len);
a528 1

d543 1
d545 1
a545 1
	SiSSetupDSTColorDepth(pSiS->DstColor);
d548 1
a548 2
	SiSSetupStylePeriod(length-1);
	SiSSetupROP(XAAPatternROP[rop])
d550 2
a551 6
	SiSSetupCMDFlag(LINE | LINE_STYLE)
	if(bg != -1) {
	   SiSSetupPATBG(bg)
	} else {
	   SiSSetupCMDFlag(TRANSPARENT);
	}
d566 6
a571 10
	miny = (y1 > y2) ? y2 : y1;
	maxy = (y1 > y2) ? y1 : y2;
	if(maxy >= 2048) {
	   dstbase = pSiS->scrnOffset * miny;
	   y1 -= miny;
	   y2 -= miny;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
a572 1
#endif
d577 2
a578 4
	if(flags & OMIT_LAST) {
	   SiSSetupCMDFlag(NO_LAST_PIXEL)
	} else {
	   pSiS->CommandReg &= ~(NO_LAST_PIXEL);
a579 1

d592 1
d594 1
a594 1
	SiSSetupDSTColorDepth(pSiS->DstColor);
d597 3
a599 7
	SiSSetupROP(XAAPatternROP[rop])
	SiSSetupCMDFlag(PATMONO)
	if(bg != -1) {
	   SiSSetupPATBG(bg)
	} else {
	   SiSSetupCMDFlag(TRANSPARENT)
	}
d613 4
a617 9
	if(y >= 2048) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
	}
#endif
d619 16
a634 8
	SiSSetupDSTXY(x, y)
	SiSSetupRect(w, h)
	/* Clear commandReg because Setup can be used for Rect and Trap */
	pSiS->CommandReg &= ~(T_XISMAJORL | T_XISMAJORR |
	                      T_L_X_INC | T_L_Y_INC |
	                      T_R_X_INC | T_R_Y_INC |
	                      TRAPAZOID_FILL);
	SiSSetupCMDFlag(X_INC | Y_INC)
d636 5
a640 1
	SiSDoCMD
a642 2
/* Trapezoid */
#ifdef TRAP
d644 3
a646 5
SiSSubsequentMonoPatternFillTrap(ScrnInfoPtr pScrn,
               int patx, int paty,
               int y, int h,
	       int left, int dxL, int dyL, int eL,
	       int right, int dxR, int dyR, int eR )
d648 1
a648 1
	SISPtr  pSiS = SISPTR(pScrn);
d651 2
a652 2
	PDEBUG(ErrorF("Subsequent Mono8x8PatternFillTrap(%d, %d, %d - %d %d/%d %d/%d)\n",
					y, h, left, right, dxL, dxR, eL, eR));
d655 3
a657 7
	if(y >= 2048) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
a658 1
#endif
d660 2
a661 36

	/* Clear CommandReg because SetUp can be used for Rect and Trap */
	pSiS->CommandReg &= ~(T_XISMAJORL | T_XISMAJORR |
	                      T_L_X_INC | T_L_Y_INC |
			      T_R_X_INC | T_R_Y_INC |
			      BITBLT);

	if(dxL < 0) { dxL = -dxL;  }
	else { SiSSetupCMDFlag(T_L_X_INC) }
	if(dxR < 0) { dxR = -dxR; }
	else { SiSSetupCMDFlag(T_R_X_INC) }

	if(dyL < 0) { dyL = -dyL; }
	else { SiSSetupCMDFlag(T_L_Y_INC) }
	if(dyR < 0) { dyR = -dyR; }
	else { SiSSetupCMDFlag(T_R_Y_INC) }

	/* Determine major axis */
	if(dxL >= dyL) {      /* X is major axis */
	   SiSSetupCMDFlag(T_XISMAJORL)
	}
	if(dxR >= dyR) {      /* X is major axis */
	   SiSSetupCMDFlag(T_XISMAJORR)
	}

	SiSSetupYH(y,h)
	SiSSetupLR(left,right)

	SiSSetupdL(dxL, dyL)
	SiSSetupdR(dxR, dyR)

	SiSSetupEL(eL)
	SiSSetupER(eR)

	SiSSetupCMDFlag(TRAPAZOID_FILL);

a663 6
#endif


#if 0

/* TW: The following (already commented) functions have NOT been adapted for dual-head mode */
a664 5
/* ----- CPU To Screen Color Expand (single task) ------------------------- */

/* This does not work. Assumingly for the same
 * reason why STSColorExpand does not work either.
 */
d677 1
a677 1
	SiSSetupDSTColorDepth(pSiS->DstColor);
d680 1
a680 1
	SiSSetupROP(XAAPatternROP[rop])
d682 5
a686 4
	if(bg == -1) {
	   SiSSetupCMDFlag(TRANSPARENT)
	} else {
	   SiSSetupSRCBG(bg)
d701 3
a703 3
	if(y >= 2048) {
	   dstbase = pSiS->scrnOffset * y;
	    y = 0;
a713 3
#endif

/* ------ Screen To Screen Color Expand ------------------------------- */
a714 3
/* TW: The hareware does not seem to support this the way we need it */

#ifdef STSCE
d725 2
a726 1
	SiSSetupDSTColorDepth(pSiS->DstColor)
d728 1
a728 1
	SiSSetupROP(XAACopyROP[rop])
d730 4
a733 10
	/* SiSSetupSRCXY(0,0) */

	if(bg == -1) {
	   SiSSetupCMDFlag(TRANSPARENT | ENCOLOREXP | X_INC |
				Y_INC | SRCVIDEO);
	} else {
	   SiSSetupSRCBG(bg);
	   SiSSetupCMDFlag(ENCOLOREXP | X_INC | Y_INC |
				SRCVIDEO);
	};
a734 42
#endif

/* TW. This method blits in a single task; this does not seem to work
 * because the hardware does not use the source pitch as scanline
 * offset but only to calculate pattern address from source X and Y.
 * XAA provides the pattern bitmap with scrnOffset (displayWidth * bpp/8)
 * offset, but this does not seem to be supported by the hardware.
 */
#ifdef STSCE

/* For testing, these are the methods: (use only one at a time!) */

#undef npitch 		/* Normal: Use srcx/y as srcx/y, use scrnOffset as source pitch
			 * This would work if the hareware used the source pitch for
			 * incrementing the source address after each scanline - but
			 * it doesn't do this! The first line of the area is correctly
			 * color expanded, but since the source pitch is ignored and
			 * the source address not incremented correctly, the following
			 * lines are color expanded with any bit pattern that is left
			 * in the unused space of the source bitmap (which is organized
			 * with the depth of the screen framebuffer hence with a pitch
			 * of scrnOffset).
			 */

#undef pitchdw    	/* Use source pitch "displayWidth / 8" instead
		   	 * of scrnOffset (=displayWidth * bpp / 8)
			 * This can't work, because the pitch of the source
			 * bitmap is scrnoffset!
		   	 */

#define  nopitch   	/* Calculate srcbase with srcx and srcy, set the
		   	 * pitch to scrnOffset (which IS the correct pitch
		   	 * for the source bitmap) and set srcx and srcy both
		   	 * to 0.
			 * This would work if the hareware used the source pitch for
			 * incrementing the source address after each scanline - but
			 * it doesn't do this! Again: The first line of the area is
			 * correctly color expanded, but since the source pitch is
			 * ignored for scanline address incremention, the following
			 * lines are not correctly color expanded.
			 * WHATEVER I write to source pitch is ignored!
		   	 */
d741 1
a741 18
	SISPtr pSiS = SISPTR(pScrn);
        long srcbase, dstbase;
#if 0
	int _x0, _y0, _x1, _y1;
#endif
#ifdef pitchdw
	int newsrcx, newsrcy;

	/* srcx and srcy are provided based on a scrnOffset pitch ( = displayWidth * bpp / 8 )
	 * We recalulate srcx and srcy based on pitch = displayWidth / 8
	 */
        newsrcy = ((pSiS->scrnOffset * srcy) + (srcx * ((pScrn->bitsPerPixel+7)/8))) /
					  (pScrn->displayWidth/8);
        newsrcx = ((pSiS->scrnOffset * srcy) + (srcx * ((pScrn->bitsPerPixel+7)/8))) %
					  (pScrn->displayWidth/8);
#endif
	xf86DrvMsg(0, X_INFO, "Sub ScreenToScreen ColorExp(%d,%d, %d,%d, %d,%d, %d)\n",
					x, y, w, h, srcx, srcy, skipleft);
d743 2
a744 40
	srcbase = dstbase = 0;

#ifdef pitchdw
	if(newsrcy >= 2048) {
	   srcbase = (pScrn->displayWidth / 8) * newsrcy;
	   newsrcy = 0;
	}
#endif
#ifdef nopitch
	srcbase = (pSiS->scrnOffset * srcy) + (srcx * ((pScrn->bitsPerPixel+7)/8));
#endif
#ifdef npitch
	if(srcy >= 2048) {
	   srcbase = pSiS->scrnOffset * srcy;
	   srcy = 0;
	}
#endif
	if(y >= 2048) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   srcbase += HEADOFFSET;
	   dstbase += HEADOFFSET;
	}
#endif
	SiSSetupSRCBase(srcbase)
	SiSSetupDSTBase(dstbase)

#ifdef pitchdw
	SiSSetupSRCPitch(pScrn->displayWidth/8)
#endif
#ifdef nopitch
	SiSSetupSRCPitch(pSiS->scrnOffset)
	/* SiSSetupSRCPitch(100) */ /* For test - has NO effect WHATSOEVER */
#endif
#ifdef npitch
	SiSSetupSRCPitch(pSiS->scrnOffset)
#endif
d746 2
a748 24

#if 0   /* How do I implement the offset? Not this way, that's for sure.. */
	if (skipleft > 0) {
		_x0 = x+skipleft;
		_y0 = y;
		_x1 = x+w;
		_y1 = y+h;
		SiSSetupClipLT(_x0, _y0);
		SiSSetupClipRB(_x1, _y1);
		SiSSetupCMDFlag(CLIPENABLE);
	}
#endif
#ifdef pitchdw
	SiSSetupSRCXY(newsrcx, newsrcy)
#endif
#ifdef nopitch
	SiSSetupSRCXY(0,0)
#endif
#ifdef npitch
	SiSSetupSRCXY(srcx, srcy)
#endif

	SiSSetupDSTXY(x,y)

d753 2
a754 7
/* ----- CPU To Screen Color Expand (scanline-wise) ----------------- */

/* We do it using the indirect method */

static void
SiSSetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
		int fg, int bg, int rop, unsigned int planemask)
d757 4
a760 6

        /* TW: Make sure that current CPU-driven BitBlt buffer stage is 0
	 *     This is required!!! (Otherwise -> drawing errors)
	 */
	while((MMIO_IN16(pSiS->IOBase, 0x8242) & 0x1F00) != 0) {} /* WDR: == 0x10 */

d762 1
a762 1
	SiSSetupROP(XAACopyROP[rop]);
d766 9
a774 11
	if(bg == -1) {
	   SiSSetupCMDFlag(TRANSPARENT |
	                   ENCOLOREXP |
	   		   X_INC | Y_INC |
			   SRCCPUBLITBUF);
	} else {
	   SiSSetupSRCBG(bg);
	   SiSSetupCMDFlag(ENCOLOREXP |
	                   X_INC | Y_INC |
		   	   SRCCPUBLITBUF);
	}
d777 4
a780 4

static void
SiSSubsequentScanlineCPUToScreenColorExpandFill(
                        ScrnInfoPtr pScrn, int x, int y, int w,
d788 3
a790 21
	if((y >= 2048) || ((y + h) >= 2048)) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
	}
#endif

	/* TW: Wait until there is no color expansion command in queue
	 *     (This solves the OpenOffice.org window-move bug)
	 *     Added Idle-check - bit 23 is set sometimes, although
	 *     engine is actually idle!
	 *     Update: Bit 23 is not reliable. After heavy 3D engine
	 *     action, this bit never gets cleared again. So do
	 *     SiSIdle instead.
	 */
	if((MMIO_IN16(pSiS->IOBase, 0x8242) & 0xe000) != 0xe000) {
           /* while ((MMIO_IN16(pSiS->IOBase, 0x8242) & 0x0080) != 0) {} */
	   SiSIdle
a791 1

d794 9
a802 12
	if(skipleft > 0) {
	   _x0 = x + skipleft;
	   _y0 = y;
	   _x1 = x + w;
	   _y1 = y + h;
	   SiSSetupClipLT(_x0, _y0);
	   SiSSetupClipRB(_x1, _y1);
	   SiSSetupCMDFlag(CLIPENABLE);
	} else {
	   pSiS->CommandReg &= (~CLIPENABLE);
	}

d804 4
a807 3
        SiSSetupSRCPitch(((((w+7)/8)+3) >> 2) * 4);
	pSiS->xcurrent = x;
	pSiS->ycurrent = y;
d810 1
a810 2
static void
SiSSubsequentColorExpandScanline(ScrnInfoPtr pScrn, int bufno)
d812 1
a812 2
	SISPtr pSiS=SISPTR(pScrn);
#if 0
a813 2
#endif
	long cbo;
d815 12
a826 4
	cbo = pSiS->ColorExpandBufferScreenOffset[bufno];
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   cbo += HEADOFFSET;
d828 1
a828 1
#endif
d830 6
a835 12
	/* TW: Wait until there is no color expansion command in queue
	 *     (This solves the GTK-big-font bug)
	 *     Added Idle-check - bit 23 is set sometimes, although
	 *     engine is actually idle!
	 *     Update: Bit 23 is not reliable. After heavy 3D engine
	 *     action, this bit never gets cleared again. So do
	 *     SiSIdle instead.
	 */
	if((MMIO_IN16(pSiS->IOBase, 0x8242) & 0xe000) != 0xe000) {
	   /* while ((MMIO_IN16(pSiS->IOBase, 0x8242) & 0x0080) != 0) {} */
	   SiSIdle
	}
d837 6
a842 1
	SiSSetupSRCBase(cbo);
d844 6
a849 1
	SiSSetupDSTXY(pSiS->xcurrent, pSiS->ycurrent);
d851 4
a854 6
	SiSDoCMD

	pSiS->ycurrent++;

	if(pSiS->VGAEngine == SIS_530_VGA) {
	   while(MMIO_IN8(pSiS->IOBase, 0x8242) & 0x80) {}
d857 1
a857 3



@


1.1.9.2
log
@Import XFree86 4.4 from The XFree86(TM) Project, Inc.
(integrity cannot be checked)

got via cvs -qd anoncvs@@anoncvs.xfree86.org:/cvs co -Prxf-4_4_0 xc
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis300_accel.c,v 1.29 2004/02/25 17:45:11 twini Exp $ */
d15 4
a18 1
 * 3) The name of the author may not be used to endorse or promote products
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 2
a2 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis300_accel.c,v 1.14 2003/01/29 15:42:16 eich Exp $ */
a3 14
 * 2D Acceleration for SiS300, SiS540, SiS630, SiS730, SiS530, SiS620
 *
 * Copyright Xavier Ducoin <x.ducoin@@lectra.com>
 * Copyright 2002 by Thomas Winischhofer, Vienna, Austria
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of the copyright holders not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
d5 3
a7 7
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
a8 1
 *      Authors:
d10 1
a11 2
 *      Thomas Winischhofer <thomas@@winischhofer.net>
 *
d28 2
a29 3
#ifdef SISDUALHEAD
/* TW: This is the offset to the memory for each head */
#define HEADOFFSET 	(pSiS->dhmOffset)
d32 1
a32 8
#undef STSCE    	/* TW: Use/Don't use ScreenToScreenColorExpand - does not work */

#undef TRAP     	/* TW: Use/Don't use Trapezoid Fills - does not work - XAA provides
		         * illegal trapezoid data (left and right edges cross each other
			 * sometimes) which causes drawing errors. Further, I have not found
			 * out how to draw polygones with a height greater than 127...
                         */

a44 5
#ifdef TRAP
static void SiSSubsequentSolidFillTrap(ScrnInfoPtr pScrn, int y, int h,
	                        int left, int dxL, int dyL, int eL,
	                        int right, int dxR, int dyR, int eR);
#endif
a62 7
#ifdef TRAP
static void SiSSubsequentMonoPatternFillTrap(ScrnInfoPtr pScrn,
                                int patx, int paty,
                                int y, int h,
                                int left, int dxL, int dyL, int eL,
	                        int right, int dxR, int dyR, int eR );
#endif
a70 2
#endif
#if 0
a75 2
#endif
#ifdef STSCE
d83 2
a84 2
static void SiSSetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
                                int fg, int bg, int rop,
d87 1
a87 1
                                int x, int y, int w, int h,
d90 6
a95 3

#ifdef SISDUALHEAD
static void SiSRestoreAccelState(ScrnInfoPtr pScrn);
a96 1

d119 2
a120 1
	if (!infoPtr)  return FALSE;
d125 2
a126 2
			 OFFSCREEN_PIXMAPS |
			 PIXMAP_CACHE;
d131 2
a132 4
	/* Acceleration only supported at 8, 16 and 32 bpp */
	if((pScrn->bitsPerPixel != 8) && (pScrn->bitsPerPixel != 16) &&
	         (pScrn->bitsPerPixel != 32))
	    return FALSE;
d134 1
a134 1
	/* screen to screen copy - TW: We now support transparent copies */
d137 1
a137 2
	infoPtr->ScreenToScreenCopyFlags = NO_PLANEMASK |
	                                   TRANSPARENCY_GXCOPY_ONLY;
a141 3
#ifdef TRAP
	infoPtr->SubsequentSolidFillTrap = SiSSubsequentSolidFillTrap;
#endif
d148 1
a148 1
	infoPtr->SolidLineFlags = NO_PLANEMASK;
d154 2
a155 2
	infoPtr->DashedLineFlags = NO_PLANEMASK |
				   LINE_PATTERN_MSBFIRST_LSBJUSTIFIED;
d159 2
a160 4
	infoPtr->SubsequentMono8x8PatternFillRect = SiSSubsequentMonoPatternFill;
#ifdef TRAP
	infoPtr->SubsequentMono8x8PatternFillTrap = SiSSubsequentMonoPatternFillTrap;
#endif
d162 14
a175 4
					   HARDWARE_PATTERN_SCREEN_ORIGIN |
					   HARDWARE_PATTERN_PROGRAMMED_BITS |
					   NO_TRANSPARENCY |
					   BIT_ORDER_IN_BYTE_MSBFIRST ;
a176 1
#ifdef STSCE
a177 1
	/* TW: The hardware does support this the way we need it */
d179 1
a179 1
	    			SiSSetupForScreenToScreenColorExpand;
d181 3
a183 7
	    			SiSSubsequentScreenToScreenColorExpand;
	infoPtr->ScreenToScreenColorExpandFillFlags = NO_PLANEMASK |
	                                              BIT_ORDER_IN_BYTE_MSBFIRST ;
#endif

#if 0
	/* CPU To Screen Color Expand --- implement another instead of this one! */
d198 4
a201 9
	/* per-scanline color expansion (using indirect method) */
	if(pSiS->VGAEngine == SIS_530_VGA) {
	   pSiS->ColorExpandBufferNumber = 4;
	   pSiS->ColorExpandBufferCountMask = 0x03;
	} else {
	   pSiS->ColorExpandBufferNumber = 16;
	   pSiS->ColorExpandBufferCountMask = 0x0F;
	}
	pSiS->PerColorExpandBufferSize = ((pScrn->virtualX + 31)/32) * 4;
d204 3
a206 7

	infoPtr->SetupForScanlineCPUToScreenColorExpandFill =
	                            SiSSetupForScanlineCPUToScreenColorExpandFill;
	infoPtr->SubsequentScanlineCPUToScreenColorExpandFill =
	                            SiSSubsequentScanlineCPUToScreenColorExpandFill;
	infoPtr->SubsequentColorExpandScanline =
	                            SiSSubsequentColorExpandScanline;
d213 13
a225 5

#ifdef SISDUALHEAD
	if (pSiS->DualHeadMode) {
		infoPtr->RestoreAccelState = SiSRestoreAccelState;
	}
d229 2
d232 18
a249 11

	reservedFbSize = pSiS->ColorExpandBufferNumber * pSiS->PerColorExpandBufferSize;

	UsableFbSize = topFB - reservedFbSize;

	/* Layout: (Sizes do not reflect correct proportions)
	 * |--------------++++++++++++++++++++^************==========~~~~~~~~~~~~|
	 *   UsableFbSize  ColorExpandBuffers | DRI-Heap  |  HWCursor  TurboQueue   300/310/325 series
	 * |--------------++++++++++++++++++++|  ====================~~~~~~~~~~~~|
	 *   UsableFbSize  ColorExpandBuffers |        TurboQueue     HWCursor      530/620
	 *                                  topFB
a250 1

d253 1
a253 1
		pSiS->ColorExpandBufferAddr[i] = AvailBufBase +
d261 5
a265 18
	Avail.y2 = (UsableFbSize / (pScrn->displayWidth * pScrn->bitsPerPixel/8)) - 1;

	if(Avail.y2 < 0)  Avail.y2 = 32767;

	if(Avail.y2 < pScrn->currentMode->VDisplay) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			"Not enough video RAM for accelerator. At least "
			"%dKB needed, %dKB available\n",
			((((pScrn->displayWidth * pScrn->bitsPerPixel/8)   /* TW: +8 for make it sure */
			     * pScrn->currentMode->VDisplay) + reservedFbSize) / 1024) + 8,
			pSiS->maxxfbmem/1024);
		pSiS->NoAccel = TRUE;
		pSiS->NoXvideo = TRUE;
		XAADestroyInfoRec(pSiS->AccelInfoPtr);
		pSiS->AccelInfoPtr = NULL;
		return FALSE;
	}

d269 1
a269 1

d271 1
a271 1

d287 1
a287 20
#ifdef SISDUALHEAD
static void
SiSRestoreAccelState(ScrnInfoPtr pScrn)
{
	SISPtr pSiS = SISPTR(pScrn);

	/* TW: We don't need to do anything special here; forcing the
	 *     other head to re-read the CmdQueLen is not necessary:
	 *     After the Sync in RestoreAccelState(), the real queue
	 *     length is always larger than (or at least equal to)
	 *     the amount stored in CmdQueueLen of the other head,
	 *     so the only thing that might happen is one unnecessary
	 *     Sync on the other head. I think we can live with that.
	 */
	pSiS->DoColorExpand = FALSE;
	SiSIdle
}
#endif

static const int sisALUConv[] =
d307 1
a307 1
static const int sisPatALUConv[] =
d332 1
d336 41
a376 2

	SiSSetupDSTColorDepth(pSiS->DstColor);
d379 2
a380 9

	if(trans_color != -1) {
		SiSSetupROP(0x0A)
		SiSSetupSRCTrans(trans_color)
		SiSSetupCMDFlag(TRANSPARENT_BITBLT)
	} else {
	        SiSSetupROP(sisALUConv[rop])
	}
	if(xdir > 0) {
d383 1
a383 1
	if(ydir > 0) {
d399 1
a399 1
	if(src_y >= 2048) {
d402 3
a404 3
	}
	if( (dst_y >= pScrn->virtualY) || (dst_y >= 2048) ) {
		dstbase = pSiS->scrnOffset * dst_y;
d406 1
a406 7
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   	srcbase += HEADOFFSET;
	   	dstbase += HEADOFFSET;
	}
#endif
d409 1
a409 2

	if(!(pSiS->CommandReg & X_INC))  {
d413 1
a413 1
	if(!(pSiS->CommandReg & Y_INC))  {
a419 1

d433 1
d435 1
a435 1
	SiSSetupDSTColorDepth(pSiS->DstColor);
d437 1
a437 1
	/* SiSSetupCMDFlag(PATFG) - is zero */
d450 2
a451 3

	if (y >= 2048) {
		dstbase = pSiS->scrnOffset * y;
a453 5
#ifdef SISDUALHEAD
        if(pSiS->VGAEngine != SIS_530_VGA) {
	   	dstbase += HEADOFFSET;
        }
#endif
a456 114
	/* Clear commandReg because Setup can be used for Rect and Trap */
	pSiS->CommandReg &= ~(T_XISMAJORL | T_XISMAJORR |
	                      T_L_X_INC | T_L_Y_INC |
	                      T_R_X_INC | T_R_Y_INC |
			      TRAPAZOID_FILL);
	SiSSetupCMDFlag(X_INC | Y_INC | BITBLT)

	SiSDoCMD
}

/* TW: Trapezoid */
/* This would work better if XAA would provide us with valid trapezoids.
 * In fact, with small trapezoids the left and the right edge often cross
 * each other or result in a line length of 0 which causes drawing errors
 * (filling over whole scanline).
 * Furthermore, I have not found out how to draw trapezoids with a height
 * greater than 127.
 */
#ifdef TRAP
static void
SiSSubsequentSolidFillTrap(ScrnInfoPtr pScrn, int y, int h,
	       int left,  int dxL, int dyL, int eL,
	       int right, int dxR, int dyR, int eR )
{
	SISPtr  pSiS = SISPTR(pScrn);
	long dstbase;
#if 0
	float kL, kR;
#endif

	dstbase = 0;
	if (y >= 2048) {
		dstbase=pSiS->scrnOffset*y;
		y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   	dstbase += HEADOFFSET;
	}
#endif
	SiSSetupDSTBase(dstbase)
	/* SiSSetupRect(w,h) */

#if 1
	SiSSetupPATFG(0xff0000) /* FOR TESTING */
#endif

	/* Clear CommandReg because SetUp can be used for Rect and Trap */
	pSiS->CommandReg &= ~(T_L_X_INC | T_L_Y_INC |
	                      T_R_X_INC | T_R_Y_INC |
	                      T_XISMAJORL | T_XISMAJORR |
			      BITBLT);

        xf86DrvMsg(0, X_INFO, "Trap (%d %d %d %d) dxL %d dyL %d eL %d   dxR %d dyR %d eR %d\n",
		left, right, y, h, dxL, dyL, eL, dxR, dyR, eR);

	/* Unfortunately, we must check if the right and the left edge
	 * cross each other...  INCOMPLETE (line equation wrong)
	 */
#if 0
	if (dxL == 0) kL = 0;
	else kL = (float)dyL / (float)dxL;
	if (dxR == 0) kR = 0;
	else kR = (float)dyR / (float)dxR;
	xf86DrvMsg(0, X_INFO, "kL %f kR %f!\n", kL, kR);
	if ( (kR != kL) &&
	     (!(kR == 0 && kL == 0)) &&
	     (!(kR <  0 && kL >  0)) ) {
	   xf86DrvMsg(0, X_INFO, "Inside if (%f - %d)\n", ( kL * ( ( ((float)right - (float)left) / (kL - kR) ) - left) + y), h+y);
           if ( ( ( kL * ( ( ((float)right - (float)left) / (kL - kR) ) - (float)left) + (float)y) < (h + y) ) ) {
	     xf86DrvMsg(0, X_INFO, "Cross detected!\n");
	   }
	}
#endif

	/* Determine egde angles */
	if (dxL < 0) { dxL = -dxL; }
	else { SiSSetupCMDFlag(T_L_X_INC) }
	if (dxR < 0) { dxR = -dxR; }
	else { SiSSetupCMDFlag(T_R_X_INC) }

	/* (Y direction always positive - do this anyway) */
	if (dyL < 0) { dyL = -dyL; }
	else { SiSSetupCMDFlag(T_L_Y_INC) }
	if (dyR < 0) { dyR = -dyR; }
	else { SiSSetupCMDFlag(T_R_Y_INC) }

	/* Determine major axis */
	if (dxL >= dyL) {      /* X is major axis */
		SiSSetupCMDFlag(T_XISMAJORL)
	}
	if (dxR >= dyR) {      /* X is major axis */
		SiSSetupCMDFlag(T_XISMAJORR)
	}

	/* Set up deltas */
	SiSSetupdL(dxL, dyL)
	SiSSetupdR(dxR, dyR)

#if 0   /* Could it be that this crappy engine can only draw trapezoids up to 127 pixels high? */
	h &= 0x7F;
	if (h == 0) h = 10;
#endif

	/* Set up y, h, left, right */
	SiSSetupYH(y,h)
	SiSSetupLR(left,right)

	/* Set up initial error term */
	SiSSetupEL(eL)
	SiSSetupER(eR)

	SiSSetupCMDFlag(TRAPAZOID_FILL);

a458 1
#endif
d471 1
d473 1
a473 1
	SiSSetupDSTColorDepth(pSiS->DstColor);
d491 2
a492 2
	if(maxy >= 2048) {
		dstbase = pSiS->scrnOffset * miny;
a495 5
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
	}
#endif
d500 1
a500 1
	if (flags & OMIT_LAST) {
a501 4
	} else {
		pSiS->CommandReg &= ~(NO_LAST_PIXEL);
	}

a514 1

d516 1
a516 1
	if((y >= 2048) || ((y + len) >= 2048)) {
a519 5
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   	dstbase += HEADOFFSET;
	}
#endif
d525 2
a526 1
	} else {
a528 1

d543 1
d545 1
a545 1
	SiSSetupDSTColorDepth(pSiS->DstColor);
a547 1
	SiSSetupStylePeriod(length-1);			/* TW: This was missing!!! */
d550 1
a550 2
	SiSSetupCMDFlag(LINE | LINE_STYLE)  		/* TW: This was missing!!! */
	if(bg != -1) {
a551 3
	} else {
	        SiSSetupCMDFlag(TRANSPARENT); 		/* TW: This was missing!!! */
	}
d566 3
a568 3
	miny = (y1 > y2) ? y2 : y1;
	maxy = (y1 > y2) ? y1 : y2;
	if(maxy >= 2048) {
a572 5
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
	}
#endif
d577 1
a577 1
	if(flags & OMIT_LAST) {
a578 2
	} else {
		pSiS->CommandReg &= ~(NO_LAST_PIXEL);
a579 1

d592 1
d594 1
a594 1
	SiSSetupDSTColorDepth(pSiS->DstColor);
d598 1
a598 1
	SiSSetupCMDFlag(PATMONO)
d613 1
a613 2

	if (y >= 2048) {
a616 14
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
	}
#endif
	SiSSetupDSTBase(dstbase)
	SiSSetupDSTXY(x, y)
	SiSSetupRect(w, h)
	/* Clear commandReg because Setup can be used for Rect and Trap */
	pSiS->CommandReg &= ~(T_XISMAJORL | T_XISMAJORR |
	                      T_L_X_INC | T_L_Y_INC |
	                      T_R_X_INC | T_R_Y_INC |
	                      TRAPAZOID_FILL);
	SiSSetupCMDFlag(X_INC | Y_INC)
a617 28
	SiSDoCMD
}

/* Trapezoid */
#ifdef TRAP
static void
SiSSubsequentMonoPatternFillTrap(ScrnInfoPtr pScrn,
               int patx, int paty,
               int y, int h,
	       int left, int dxL, int dyL, int eL,
	       int right, int dxR, int dyR, int eR )
{
	SISPtr  pSiS = SISPTR(pScrn);
	long dstbase;

	PDEBUG(ErrorF("Subsequent Mono8x8PatternFillTrap(%d, %d, %d - %d %d/%d %d/%d)\n",
					y, h, left, right, dxL, dxR, eL, eR));

	dstbase = 0;
	if (y >= 2048) {
		dstbase=pSiS->scrnOffset*y;
		y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   dstbase += HEADOFFSET;
	}
#endif
d619 2
a620 36

	/* Clear CommandReg because SetUp can be used for Rect and Trap */
	pSiS->CommandReg &= ~(T_XISMAJORL | T_XISMAJORR |
	                      T_L_X_INC | T_L_Y_INC |
			      T_R_X_INC | T_R_Y_INC |
			      BITBLT);

	if (dxL < 0) { dxL = -dxL;  }
	else { SiSSetupCMDFlag(T_L_X_INC) }
	if (dxR < 0) { dxR = -dxR; }
	else { SiSSetupCMDFlag(T_R_X_INC) }

	if (dyL < 0) { dyL = -dyL; }
	else { SiSSetupCMDFlag(T_L_Y_INC) }
	if (dyR < 0) { dyR = -dyR; }
	else { SiSSetupCMDFlag(T_R_Y_INC) }

	/* Determine major axis */
	if (dxL >= dyL) {      /* X is major axis */
		SiSSetupCMDFlag(T_XISMAJORL)
	}
	if (dxR >= dyR) {      /* X is major axis */
		SiSSetupCMDFlag(T_XISMAJORR)
	}

	SiSSetupYH(y,h)
	SiSSetupLR(left,right)

	SiSSetupdL(dxL, dyL)
	SiSSetupdR(dxR, dyR)

	SiSSetupEL(eL)
	SiSSetupER(eR)

	SiSSetupCMDFlag(TRAPAZOID_FILL);

a622 2
#endif

a624 6

/* TW: The following (already commented) functions have NOT been adapted for dual-head mode */


/* ------- Color Pattern Fill --- is not useful for XAA -------------- */

d638 1
a638 1
	SiSSetupDSTColorDepth(pSiS->DstColor);
a664 5
/* ----- CPU To Screen Color Expand (single task) ------------------------- */

/* This does not work. Assumingly for the same
 * reason why STSColorExpand does not work either.
 */
d677 1
a677 1
	SiSSetupDSTColorDepth(pSiS->DstColor);
a713 3
#endif

/* ------ Screen To Screen Color Expand ------------------------------- */
a714 3
/* TW: The hareware does not seem to support this the way we need it */

#ifdef STSCE
d725 2
a726 1
	SiSSetupDSTColorDepth(pSiS->DstColor)
d728 4
d733 1
a733 11
	SiSSetupSRCFG(fg)
	/* SiSSetupSRCXY(0,0) */

	if(bg == -1) {
		SiSSetupCMDFlag(TRANSPARENT | ENCOLOREXP | X_INC |
				Y_INC | SRCVIDEO);
	} else {
		SiSSetupSRCBG(bg);
		SiSSetupCMDFlag(ENCOLOREXP | X_INC | Y_INC |
				SRCVIDEO);
	};
a734 42
#endif

/* TW. This method blits in a single task; this does not seem to work
 * because the hardware does not use the source pitch as scanline
 * offset but only to calculate pattern address from source X and Y.
 * XAA provides the pattern bitmap with scrnOffset (displayWidth * bpp/8)
 * offset, but this does not seem to be supported by the hardware.
 */
#ifdef STSCE

/* For testing, these are the methods: (use only one at a time!) */

#undef npitch 		/* Normal: Use srcx/y as srcx/y, use scrnOffset as source pitch
			 * This would work if the hareware used the source pitch for
			 * incrementing the source address after each scanline - but
			 * it doesn't do this! The first line of the area is correctly
			 * color expanded, but since the source pitch is ignored and
			 * the source address not incremented correctly, the following
			 * lines are color expanded with any bit pattern that is left
			 * in the unused space of the source bitmap (which is organized
			 * with the depth of the screen framebuffer hence with a pitch
			 * of scrnOffset).
			 */

#undef pitchdw    	/* Use source pitch "displayWidth / 8" instead
		   	 * of scrnOffset (=displayWidth * bpp / 8)
			 * This can't work, because the pitch of the source
			 * bitmap is scrnoffset!
		   	 */

#define  nopitch   	/* Calculate srcbase with srcx and srcy, set the
		   	 * pitch to scrnOffset (which IS the correct pitch
		   	 * for the source bitmap) and set srcx and srcy both
		   	 * to 0.
			 * This would work if the hareware used the source pitch for
			 * incrementing the source address after each scanline - but
			 * it doesn't do this! Again: The first line of the area is
			 * correctly color expanded, but since the source pitch is
			 * ignored for scanline address incremention, the following
			 * lines are not correctly color expanded.
			 * WHATEVER I write to source pitch is ignored!
		   	 */
d741 1
a741 7
	SISPtr pSiS = SISPTR(pScrn);
        long srcbase, dstbase;
#if 0
	int _x0, _y0, _x1, _y1;
#endif
#ifdef pitchdw
	int newsrcx, newsrcy;
d743 2
a744 51
	/* srcx and srcy are provided based on a scrnOffset pitch ( = displayWidth * bpp / 8 )
	 * We recalulate srcx and srcy based on pitch = displayWidth / 8
	 */
        newsrcy = ((pSiS->scrnOffset * srcy) + (srcx * ((pScrn->bitsPerPixel+7)/8))) /
					  (pScrn->displayWidth/8);
        newsrcx = ((pSiS->scrnOffset * srcy) + (srcx * ((pScrn->bitsPerPixel+7)/8))) %
					  (pScrn->displayWidth/8);
#endif
	xf86DrvMsg(0, X_INFO, "Sub ScreenToScreen ColorExp(%d,%d, %d,%d, %d,%d, %d)\n",
					x, y, w, h, srcx, srcy, skipleft);

	srcbase = dstbase = 0;

#ifdef pitchdw
	if (newsrcy >= 2048) {
		srcbase = (pScrn->displayWidth / 8) * newsrcy;
		newsrcy = 0;
	}
#endif
#ifdef nopitch
	srcbase = (pSiS->scrnOffset * srcy) + (srcx * ((pScrn->bitsPerPixel+7)/8));
#endif
#ifdef npitch
	if (srcy >= 2048) {
		srcbase = pSiS->scrnOffset * srcy;
		srcy = 0;
	}
#endif
	if (y >= 2048) {
		dstbase = pSiS->scrnOffset * y;
		y = 0;
	}
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   srcbase += HEADOFFSET;
	   dstbase += HEADOFFSET;
	}
#endif
	SiSSetupSRCBase(srcbase)
	SiSSetupDSTBase(dstbase)

#ifdef pitchdw
	SiSSetupSRCPitch(pScrn->displayWidth/8)
#endif
#ifdef nopitch
	SiSSetupSRCPitch(pSiS->scrnOffset)
	/* SiSSetupSRCPitch(100) */ /* For test - has NO effect WHATSOEVER */
#endif
#ifdef npitch
	SiSSetupSRCPitch(pSiS->scrnOffset)
#endif
d746 2
a748 24

#if 0   /* How do I implement the offset? Not this way, that's for sure.. */
	if (skipleft > 0) {
		_x0 = x+skipleft;
		_y0 = y;
		_x1 = x+w;
		_y1 = y+h;
		SiSSetupClipLT(_x0, _y0);
		SiSSetupClipRB(_x1, _y1);
		SiSSetupCMDFlag(CLIPENABLE);
	}
#endif
#ifdef pitchdw
	SiSSetupSRCXY(newsrcx, newsrcy)
#endif
#ifdef nopitch
	SiSSetupSRCXY(0,0)
#endif
#ifdef npitch
	SiSSetupSRCXY(srcx, srcy)
#endif

	SiSSetupDSTXY(x,y)

d753 2
a754 98
/* TW: TEST: Do it scanline-wise because the other way does not seem to
 *     be supported by the hardware. (The source pitch seems to be
 *     displayWidth * (bbp/8) as opposed by the XAA HOWTO, where
 *     it is stated that the pitch would be displayWidth pixels;
 *     besides, the hardware seems to ignore the source pitch
 *     for address increments.)
 *     Apart from this (which can be solved by doing the color
 *     expand scanline-wise), I don't know how to implement the
 *     offset argument. The current method (which uses hardware
 *     clipping) does not work.
 *
 *     THIS DOES NOT WORK IN THE CURRENT STATE.
 */
#if 0
static void
SiSSubsequentScreenToScreenColorExpand(ScrnInfoPtr pScrn,
                                int x, int y, int w, int h,
                                int srcx, int srcy, int offset)
{
	SISPtr pSiS = SISPTR(pScrn);
        long srcbase, dstbase;
	int _x0, _y0, _x1, _y1;

	int newsrcx, newsrcy;

        newsrcy = ((pSiS->scrnOffset * srcy) + (srcx * ((pScrn->bitsPerPixel+7)/8))) /
					  (((((w+7)/8)+3) >> 2) * 4);
					  /* (pScrn->displayWidth/8); */
        newsrcx = ((pSiS->scrnOffset * srcy) + (srcx * ((pScrn->bitsPerPixel+7)/8))) %
					  (((((w+7)/8)+3) >> 2) * 4);
					  /* (pScrn->displayWidth/8); */

	xf86DrvMsg(0, X_INFO, "Sub STS CE(%d,%d, %d,%d, %d,%d, %d)\n",
					x, y, w, h, srcx, srcy, skipleft);

	srcbase = dstbase = 0;
	if (newsrcy >= 2048) {
		srcbase = (((((w+7)/8)+3) >> 2) * 4) * newsrcy;
		          /* (pScrn->displayWidth/8) * newsrcy;      */
		          /* pSiS->scrnOffset * srcy;                */
		newsrcy = 0;
	}
	if (y >= 2048) {
		dstbase = pSiS->scrnOffset * y;
		y = 0;
	}
#ifdef SISDUALHEAD
	srcbase += HEADOFFSET;
	dstbase += HEADOFFSET;
#endif
	SiSSetupDSTBase(dstbase)

	SiSSetupRect(w, 1)

	SiSSetupSRCXY(newsrcx, newsrcy)

	/* SiSSetupSRCPitch(pScrn->displayWidth/8) */ /* old: (((w+31)&0xFFE0)/8) */
	SiSSetupSRCPitch(((((w+7)/8)+3) >> 2) * 4)
#if 1
        if (offset > 0) {
	    SiSSetupCMDFlag(CLIPENABLE)
        } else
            pSiS->CommandReg &= ~CLIPENABLE;
#endif

	while (h) {

	   SiSSetupSRCBase(srcbase)
#if 1
	   if (offset > 0) {
		_x0 = x+skipleft;
		_y0 = y;
		_x1 = x+w;
		_y1 = y+h;
		SiSSetupClipLT(_x0, _y0);
		SiSSetupClipRB(_x1, _y1);
	   }
#endif
	   SiSSetupDSTXY(x,y)

	   SiSDoCMD

	   srcbase += ((((w+7)/8)+3) >> 2) * 4 * 8* ((pScrn->bitsPerPixel+7)/8);
	   	      /* pSiS->scrnOffset;  */
	   y++;
	   h--;
	}
}
#endif


/* ----- CPU To Screen Color Expand (scanline-wise) ----------------- */

/* We do it using the indirect method */

static void
SiSSetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrn,
		int fg, int bg, int rop, unsigned int planemask)
d757 2
a758 7

        /* TW: Make sure that current CPU-driven BitBlt buffer stage is 0
	 *     This is required!!! (Otherwise -> drawing errors)
	 */
	while((MMIO_IN16(pSiS->IOBase, 0x8242) & 0x1F00) != 0) {} /* WDR: == 0x10 */

#if 0   /* TW: This is obviously not needed */
a760 2
#endif

d766 5
a770 6
	if(bg == -1) {
		SiSSetupCMDFlag(TRANSPARENT |
		                ENCOLOREXP |
				X_INC | Y_INC |
				SRCCPUBLITBUF);
	} else {
d772 3
a774 4
		SiSSetupCMDFlag(ENCOLOREXP |
		                X_INC | Y_INC |
				SRCCPUBLITBUF);
	}
d777 4
a780 4

static void
SiSSubsequentScanlineCPUToScreenColorExpandFill(
                        ScrnInfoPtr pScrn, int x, int y, int w,
d789 1
a789 1
		dstbase = pSiS->scrnOffset * y;
a791 19
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   	dstbase += HEADOFFSET;
	}
#endif

	/* TW: Wait until there is no color expansion command in queue
	 *     (This solves the OpenOffice.org window-move bug)
	 *     Added Idle-check - bit 23 is set sometimes, although
	 *     engine is actually idle!
	 *     Update: Bit 23 is not reliable. After heavy 3D engine
	 *     action, this bit never gets cleared again. So do
	 *     SiSIdle instead.
	 */
	if((MMIO_IN16(pSiS->IOBase, 0x8242) & 0xe000) != 0xe000) {
           /* while ((MMIO_IN16(pSiS->IOBase, 0x8242) & 0x0080) != 0) {} */
	   SiSIdle
	}

d795 1
a795 1
		_x0 = x + skipleft;
d797 2
a798 2
		_x1 = x + w;
		_y1 = y + h;
d801 2
a802 5
		SiSSetupCMDFlag(CLIPENABLE);
	} else {
		pSiS->CommandReg &= (~CLIPENABLE);
	}

d804 4
a807 3
        SiSSetupSRCPitch(((((w+7)/8)+3) >> 2) * 4);
	pSiS->xcurrent = x;
	pSiS->ycurrent = y;
d810 1
a810 2
static void
SiSSubsequentColorExpandScanline(ScrnInfoPtr pScrn, int bufno)
d812 1
a812 2
	SISPtr pSiS=SISPTR(pScrn);
#if 0
a813 2
#endif
	long cbo;
d815 12
a826 4
	cbo = pSiS->ColorExpandBufferScreenOffset[bufno];
#ifdef SISDUALHEAD
	if(pSiS->VGAEngine != SIS_530_VGA) {
	   cbo += HEADOFFSET;
d828 1
a828 1
#endif
d830 6
a835 12
	/* TW: Wait until there is no color expansion command in queue
	 *     (This solves the GTK-big-font bug)
	 *     Added Idle-check - bit 23 is set sometimes, although
	 *     engine is actually idle!
	 *     Update: Bit 23 is not reliable. After heavy 3D engine
	 *     action, this bit never gets cleared again. So do
	 *     SiSIdle instead.
	 */
	if((MMIO_IN16(pSiS->IOBase, 0x8242) & 0xe000) != 0xe000) {
	  /* while ((MMIO_IN16(pSiS->IOBase, 0x8242) & 0x0080) != 0) {} */
	    SiSIdle
	}
d837 6
a842 1
	SiSSetupSRCBase(cbo);
d844 6
a849 1
	SiSSetupDSTXY(pSiS->xcurrent, pSiS->ycurrent);
d851 4
a854 16
	SiSDoCMD

	pSiS->ycurrent++;

	if(pSiS->VGAEngine == SIS_530_VGA) {
	   while(MMIO_IN8(pSiS->IOBase, 0x8242) & 0x80) {}
	}

#if 0	/* TW: What is this good for? The Head/Tail data is never ever used elsewhere! */
	pSiS->ColorExpandRingHead = newhead =
			(bufno + 1) & pSiS->ColorExpandBufferCountMask;
	while (newhead == pSiS->ColorExpandRingTail) {
		bltbufstage = (int)((MMIO_IN16(pSiS->IOBase,0x8242) & 0x1F00) >> 8);
		newtail = newhead - (bltbufstage + 1);
		pSiS->ColorExpandRingTail = (newtail >= 0) ?
				newtail : (pSiS->ColorExpandBufferNumber + newtail);
d856 1
a857 2
}

@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis300_accel.c,v 1.27 2004/01/23 22:29:04 twini Exp $ */
d3 1
a3 1
 * 2D Acceleration for SiS 530, 620, 300, 540, 630, 730.
d5 2
a6 1
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria
d8 9
a16 13
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement: "This product includes
 *    software developed by Thomas Winischhofer, Vienna, Austria."
 * 4) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d18 7
a24 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d26 4
a29 2
 * Authors:   Thomas Winischhofer <thomas@@winischhofer.net>
 *	      Can-Ru Yeou, SiS Inc.
a31 1

a42 2
#include "xaalocal.h"
#include "xaarop.h"
d176 9
a184 19
	/* TW: Although SiS states that the 300 series supports a
	 *     virtual framebuffer of 4096x4096, the 2D accelerator
	 *     does not seem to know that. If the destination bitmap
	 *     pitch is > 8192 (which easily happens in 32bpp mode),
	 *     the accelerator engine collapses.
	 *     TODO: Find out about the 530 and 620
	 */

	if(pSiS->scrnOffset < 8192) {

	   /* screen to screen copy */
	   infoPtr->SetupForScreenToScreenCopy = SiSSetupForScreenToScreenCopy;
	   infoPtr->SubsequentScreenToScreenCopy = SiSSubsequentScreenToScreenCopy;
	   infoPtr->ScreenToScreenCopyFlags = NO_PLANEMASK |
	                                      TRANSPARENCY_GXCOPY_ONLY;

	   /* solid fills */
	   infoPtr->SetupForSolidFill = SiSSetupForSolidFill;
	   infoPtr->SubsequentSolidFillRect = SiSSubsequentSolidFillRect;
d186 1
a186 1
	   infoPtr->SubsequentSolidFillTrap = SiSSubsequentSolidFillTrap;
d188 1
a188 1
	   infoPtr->SolidFillFlags = NO_PLANEMASK;
d190 16
a205 16
	   /* solid line */
	   infoPtr->SetupForSolidLine = SiSSetupForSolidLine;
	   infoPtr->SubsequentSolidTwoPointLine = SiSSubsequentSolidTwoPointLine;
	   infoPtr->SubsequentSolidHorVertLine = SiSSubsequentSolidHorzVertLine;
	   infoPtr->SolidLineFlags = NO_PLANEMASK;

	   /* dashed line */
	   infoPtr->SetupForDashedLine = SiSSetupForDashedLine;
	   infoPtr->SubsequentDashedTwoPointLine = SiSSubsequentDashedTwoPointLine;
	   infoPtr->DashPatternMaxLength = 64;
	   infoPtr->DashedLineFlags = NO_PLANEMASK |
	  			      LINE_PATTERN_MSBFIRST_LSBJUSTIFIED;

	   /* 8x8 mono pattern fill */
	   infoPtr->SetupForMono8x8PatternFill = SiSSetupForMonoPatternFill;
	   infoPtr->SubsequentMono8x8PatternFillRect = SiSSubsequentMonoPatternFill;
d207 1
a207 1
	   infoPtr->SubsequentMono8x8PatternFillTrap = SiSSubsequentMonoPatternFillTrap;
d209 5
a213 5
	   infoPtr->Mono8x8PatternFillFlags = NO_PLANEMASK |
					      HARDWARE_PATTERN_SCREEN_ORIGIN |
					      HARDWARE_PATTERN_PROGRAMMED_BITS |
					      /* NO_TRANSPARENCY | */
					      BIT_ORDER_IN_BYTE_MSBFIRST ;
d216 3
a218 3
	   /* Screen To Screen Color Expand */
	   /* TW: The hardware does support this the way we need it */
	   infoPtr->SetupForScreenToScreenColorExpandFill =
d220 1
a220 1
	   infoPtr->SubsequentScreenToScreenColorExpandFill =
d222 1
a222 1
	   infoPtr->ScreenToScreenColorExpandFillFlags = NO_PLANEMASK |
d227 26
a252 26
	   /* CPU To Screen Color Expand --- implement another instead of this one! */
	   infoPtr->SetupForCPUToScreenColorExpandFill =
	       SiSSetupForCPUToScreenColorExpand;
	   infoPtr->SubsequentCPUToScreenColorExpandFill =
	       SiSSubsequentCPUToScreenColorExpand;
	   infoPtr->ColorExpandRange = PATREGSIZE;
	   infoPtr->ColorExpandBase = pSiS->IOBase+PBR(0);
	   infoPtr->CPUToScreenColorExpandFillFlags = NO_PLANEMASK |
	   					      BIT_ORDER_IN_BYTE_MSBFIRST |
	    					      NO_TRANSPARENCY |
	    					      SYNC_AFTER_COLOR_EXPAND |
	    					      HARDWARE_PATTERN_SCREEN_ORIGIN |
	    					      HARDWARE_PATTERN_PROGRAMMED_BITS ;
#endif

	   /* per-scanline color expansion (using indirect method) */
	   if(pSiS->VGAEngine == SIS_530_VGA) {
	      pSiS->ColorExpandBufferNumber = 4;
	      pSiS->ColorExpandBufferCountMask = 0x03;
	   } else {
	      pSiS->ColorExpandBufferNumber = 16;
	      pSiS->ColorExpandBufferCountMask = 0x0F;
	   }
	   pSiS->PerColorExpandBufferSize = ((pScrn->virtualX + 31)/32) * 4;
	   infoPtr->NumScanlineColorExpandBuffers = pSiS->ColorExpandBufferNumber;
	   infoPtr->ScanlineColorExpandBuffers = (unsigned char **)&pSiS->ColorExpandBufferAddr[0];
d254 1
a254 1
	   infoPtr->SetupForScanlineCPUToScreenColorExpandFill =
d256 1
a256 1
	   infoPtr->SubsequentScanlineCPUToScreenColorExpandFill =
d258 1
a258 1
	   infoPtr->SubsequentColorExpandScanline =
d260 6
a265 12
	   infoPtr->ScanlineCPUToScreenColorExpandFillFlags = NO_PLANEMASK |
	    						      CPU_TRANSFER_PAD_DWORD |
	    						      SCANLINE_PAD_DWORD |
	    						      BIT_ORDER_IN_BYTE_MSBFIRST |
	    						      LEFT_EDGE_CLIPPING;
        } else {
	   xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	   	"Virtual screen width too large for accelerator engine\n");
           xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	   	"2D acceleration and Xv disabled\n");
           pSiS->NoXvideo = TRUE;
	}
d268 2
a269 2
	if(pSiS->DualHeadMode) {
	   infoPtr->RestoreAccelState = SiSRestoreAccelState;
d289 4
a292 4
	for(i = 0; i < pSiS->ColorExpandBufferNumber; i++) {
	   pSiS->ColorExpandBufferAddr[i] = AvailBufBase +
	 	    i * pSiS->PerColorExpandBufferSize;
	   pSiS->ColorExpandBufferScreenOffset[i] = UsableFbSize +
d305 1
a305 1
			"%dKB needed, %ldKB available\n",
d356 40
d410 3
a412 3
	   SiSSetupROP(0x0A)
	   SiSSetupSRCTrans(trans_color)
	   SiSSetupCMDFlag(TRANSPARENT_BITBLT)
d414 1
a414 1
	   SiSSetupROP(XAACopyROP[rop])
d417 1
a417 1
	   SiSSetupCMDFlag(X_INC)
d420 1
a420 1
	   SiSSetupCMDFlag(Y_INC)
d436 2
a437 2
	   srcbase = pSiS->scrnOffset * src_y;
	   src_y = 0;
d439 3
a441 3
	if((dst_y >= pScrn->virtualY) || (dst_y >= 2048)) {
	   dstbase = pSiS->scrnOffset * dst_y;
	   dst_y = 0;
d445 2
a446 2
	   srcbase += HEADOFFSET;
	   dstbase += HEADOFFSET;
d453 2
a454 2
	   src_x += width-1;
	   dst_x += width-1;
d457 2
a458 2
	   src_y += height-1;
	   dst_y += height-1;
a475 5
	if(pSiS->disablecolorkeycurrent) {
	   if((CARD32)color == pSiS->colorKey) {
	      rop = 5;  /* NOOP */
	   }
	}
d479 1
a479 1
	SiSSetupROP(XAAPatternROP[rop])
d494 3
a496 3
	if(y >= 2048) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
d500 1
a500 1
	   dstbase += HEADOFFSET;
d537 3
a539 3
	if(y >= 2048) {
	   dstbase=pSiS->scrnOffset*y;
	   y = 0;
d543 1
a543 1
	   dstbase += HEADOFFSET;
d582 1
a582 1
	if(dxL < 0) { dxL = -dxL; }
d584 1
a584 1
	if(dxR < 0) { dxR = -dxR; }
d588 1
a588 1
	if(dyL < 0) { dyL = -dyL; }
d590 1
a590 1
	if(dyR < 0) { dyR = -dyR; }
d594 2
a595 2
	if(dxL >= dyL) {      /* X is major axis */
	   SiSSetupCMDFlag(T_XISMAJORL)
d597 2
a598 2
	if(dxR >= dyR) {      /* X is major axis */
	   SiSSetupCMDFlag(T_XISMAJORR)
d637 1
a637 1
	SiSSetupROP(XAAPatternROP[rop])
d655 3
a657 3
	   dstbase = pSiS->scrnOffset * miny;
	   y1 -= miny;
	   y2 -= miny;
d668 2
a669 2
	if(flags & OMIT_LAST) {
	   SiSSetupCMDFlag(NO_LAST_PIXEL)
d671 1
a671 1
	   pSiS->CommandReg &= ~(NO_LAST_PIXEL);
d689 3
a691 3
	if((y >= 2048) || ((dir != DEGREES_0) && ((y + len) >= 2048))) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
d695 1
a695 1
	   dstbase += HEADOFFSET;
d701 2
a702 2
	if(dir == DEGREES_0) {
	   SiSSetupX1Y1(x + len, y);
d704 1
a704 1
	   SiSSetupX1Y1(x, y + len);
d725 2
a726 2
	SiSSetupStylePeriod(length-1);
	SiSSetupROP(XAAPatternROP[rop])
d728 1
a728 1
	SiSSetupCMDFlag(LINE | LINE_STYLE)
d730 1
a730 1
	   SiSSetupPATBG(bg)
d732 1
a732 1
	   SiSSetupCMDFlag(TRANSPARENT);
d751 3
a753 3
	   dstbase = pSiS->scrnOffset * miny;
	   y1 -= miny;
	   y2 -= miny;
d765 1
a765 1
	   SiSSetupCMDFlag(NO_LAST_PIXEL)
d767 1
a767 1
	   pSiS->CommandReg &= ~(NO_LAST_PIXEL);
d786 1
a786 1
	SiSSetupROP(XAAPatternROP[rop])
d788 1
a788 5
	if(bg != -1) {
	   SiSSetupPATBG(bg)
	} else {
	   SiSSetupCMDFlag(TRANSPARENT)
	}
d803 3
a805 3
	if(y >= 2048) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
d841 3
a843 3
	if(y >= 2048) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
d858 1
a858 1
	if(dxL < 0) { dxL = -dxL;  }
d860 1
a860 1
	if(dxR < 0) { dxR = -dxR; }
d863 1
a863 1
	if(dyL < 0) { dyL = -dyL; }
d865 1
a865 1
	if(dyR < 0) { dyR = -dyR; }
d869 2
a870 2
	if(dxL >= dyL) {      /* X is major axis */
	   SiSSetupCMDFlag(T_XISMAJORL)
d872 2
a873 2
	if(dxR >= dyR) {      /* X is major axis */
	   SiSSetupCMDFlag(T_XISMAJORR)
d896 43
d959 1
a959 1
	SiSSetupROP(XAAPatternROP[rop])
d961 5
a965 4
	if(bg == -1) {
	   SiSSetupCMDFlag(TRANSPARENT)
	} else {
	   SiSSetupSRCBG(bg)
d980 3
a982 3
	if(y >= 2048) {
	   dstbase = pSiS->scrnOffset * y;
	    y = 0;
d1012 1
a1012 1
	SiSSetupROP(XAACopyROP[rop])
d1017 1
a1017 1
	   SiSSetupCMDFlag(TRANSPARENT | ENCOLOREXP | X_INC |
d1020 2
a1021 2
	   SiSSetupSRCBG(bg);
	   SiSSetupCMDFlag(ENCOLOREXP | X_INC | Y_INC |
d1095 3
a1097 3
	if(newsrcy >= 2048) {
	   srcbase = (pScrn->displayWidth / 8) * newsrcy;
	   newsrcy = 0;
d1104 3
a1106 3
	if(srcy >= 2048) {
	   srcbase = pSiS->scrnOffset * srcy;
	   srcy = 0;
d1109 3
a1111 3
	if(y >= 2048) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
d1162 91
d1268 5
d1274 1
a1274 1
	SiSSetupROP(XAACopyROP[rop]);
d1279 4
a1282 4
	   SiSSetupCMDFlag(TRANSPARENT |
	                   ENCOLOREXP |
	   		   X_INC | Y_INC |
			   SRCCPUBLITBUF);
d1284 4
a1287 4
	   SiSSetupSRCBG(bg);
	   SiSSetupCMDFlag(ENCOLOREXP |
	                   X_INC | Y_INC |
		   	   SRCCPUBLITBUF);
d1302 3
a1304 3
	if((y >= 2048) || ((y + h) >= 2048)) {
	   dstbase = pSiS->scrnOffset * y;
	   y = 0;
d1308 1
a1308 1
	   dstbase += HEADOFFSET;
d1327 8
a1334 8
	if(skipleft > 0) {
	   _x0 = x + skipleft;
	   _y0 = y;
	   _x1 = x + w;
	   _y1 = y + h;
	   SiSSetupClipLT(_x0, _y0);
	   SiSSetupClipRB(_x1, _y1);
	   SiSSetupCMDFlag(CLIPENABLE);
d1336 1
a1336 1
	   pSiS->CommandReg &= (~CLIPENABLE);
d1370 2
a1371 2
	   /* while ((MMIO_IN16(pSiS->IOBase, 0x8242) & 0x0080) != 0) {} */
	   SiSIdle
d1385 11
a1396 2


@


1.1.1.4
log
@Import OpenBSD X-Window subsystem (based upon XFree86 4.4RC2)
into vendor branch
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis300_accel.c,v 1.29 2004/02/25 17:45:11 twini Exp $ */
d15 4
a18 1
 * 3) The name of the author may not be used to endorse or promote products
@


