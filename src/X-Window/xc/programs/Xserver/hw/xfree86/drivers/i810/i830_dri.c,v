head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407221130:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.07.12;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.07.12;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.36.17;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.17.38;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.23.15;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_dri.c,v 1.3 2002/01/09 00:37:30 dawes Exp $ */
/**************************************************************************

Copyright 2001 VA Linux Systems Inc., Fremont, California.

All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
on the rights to use, copy, modify, merge, publish, distribute, sub
license, and/or sell copies of the Software, and to permit persons to whom
the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
ATI, VA LINUX SYSTEMS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.


**************************************************************************/

/* Author: Jeff Hartmann <jhartmann@@valinux.com> 
 */

#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86_ansic.h"
#include "xf86Priv.h"

#include "xf86PciInfo.h"
#include "xf86Pci.h"

#include "windowstr.h"

#include "GL/glxtokens.h"

#include "i810.h"
#include "i830_dri.h"
#include "i830_3d_reg.h"

static char I830KernelDriverName[] = "i830";
static char I830ClientDriverName[] = "i830";

static Bool I830InitVisualConfigs(ScreenPtr pScreen);
static Bool I830CreateContext(ScreenPtr pScreen, VisualPtr visual, 
			      drmContext hwContext, void *pVisualConfigPriv,
			      DRIContextType contextStore);
static void I830DestroyContext(ScreenPtr pScreen, drmContext hwContext,
			       DRIContextType contextStore);
static void I830DRISwapContext(ScreenPtr pScreen, DRISyncType syncType, 
			       DRIContextType readContextType, 
			       void *readContextStore,
			       DRIContextType writeContextType, 
			       void *writeContextStore);
static void I830DRIInitBuffers(WindowPtr pWin, RegionPtr prgn, CARD32 index);
static void I830DRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg, 
			       RegionPtr prgnSrc, CARD32 index);

extern void GlxSetVisualConfigs(int nconfigs,
				__GLXvisualConfig *configs,
				void **configprivs);

static int i830_pitches[] = {
   512,
   1024,
   2048,
   4096,
   8192,
   0
};

Bool I830CleanupDma(ScrnInfoPtr pScrn)
{
   I810Ptr pI810 = I810PTR(pScrn);
   Bool ret_val;
   
   ret_val = drmI830CleanupDma(pI810->drmSubFD);
   if (ret_val == FALSE)
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "I830 Dma Cleanup Failed\n");
   return ret_val;
}

Bool I830InitDma(ScrnInfoPtr pScrn)
{
   I810Ptr pI810 = I810PTR(pScrn);
   I810RingBuffer *ring = &(pI810->LpRing);
   I830DRIPtr pI830DRI=(I830DRIPtr)pI810->pDRIInfo->devPrivate;
   drmI830Init info;
   Bool ret_val;

   info.start = ring->mem.Start;
   info.end = ring->mem.End; 
   info.size = ring->mem.Size;

   info.mmio_offset = (unsigned int)pI830DRI->regs;
   info.buffers_offset = (unsigned int)pI810->buffer_map;

   info.sarea_off = sizeof(XF86DRISAREARec);

   info.front_offset = 0;
   info.back_offset = pI810->BackBuffer.Start;
   info.depth_offset = pI810->DepthBuffer.Start;
   info.w = pScrn->virtualX;
   info.h = pScrn->virtualY;
   info.pitch = pI810->auxPitch;
   info.pitch_bits = pI810->auxPitchBits;
   info.cpp = pI810->cpp;

   ret_val = drmI830InitDma(pI810->drmSubFD, &info);
   if(ret_val == FALSE) ErrorF("i830 Dma Initialization Failed\n");
   return ret_val;
}

static Bool
I830InitVisualConfigs(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I810Ptr pI810 = I810PTR(pScrn);
   int numConfigs = 0;
   __GLXvisualConfig *pConfigs = 0;
   I810ConfigPrivPtr pI810Configs = 0;
   I810ConfigPrivPtr *pI810ConfigPtrs = 0;
   int accum, stencil, db, depth;
   int i;

   switch (pScrn->bitsPerPixel) {
   case 8:
   case 24:
      break;

   case 16:
      numConfigs = 8;

      pConfigs = (__GLXvisualConfig *) xcalloc(sizeof(__GLXvisualConfig), numConfigs);
      if (!pConfigs)
	 return FALSE;

      pI810Configs = (I810ConfigPrivPtr) xcalloc(sizeof(I810ConfigPrivRec), numConfigs);
      if (!pI810Configs) {
	 xfree(pConfigs);
	 return FALSE;
      }

      pI810ConfigPtrs = (I810ConfigPrivPtr *) xcalloc(sizeof(I810ConfigPrivPtr), numConfigs);
      if (!pI810ConfigPtrs) {
	 xfree(pConfigs);
	 xfree(pI810Configs);
	 return FALSE;
      }

      for (i=0; i<numConfigs; i++) 
	 pI810ConfigPtrs[i] = &pI810Configs[i];

      i = 0;
      depth = 1;
      for (accum = 0; accum <= 1; accum++) {
         for (stencil = 0; stencil <= 1; stencil++) {
            for (db = 1; db >= 0; db--) {
               pConfigs[i].vid = -1;
               pConfigs[i].class = -1;
               pConfigs[i].rgba = TRUE;
               pConfigs[i].redSize = 5;
               pConfigs[i].greenSize = 6;
               pConfigs[i].blueSize = 5;
               pConfigs[i].redMask = 0x0000F800;
               pConfigs[i].greenMask = 0x000007E0;
               pConfigs[i].blueMask = 0x0000001F;
               pConfigs[i].alphaMask = 0;
               if (accum) {
                  pConfigs[i].accumRedSize = 16;
                  pConfigs[i].accumGreenSize = 16;
                  pConfigs[i].accumBlueSize = 16;
                  pConfigs[i].accumAlphaSize = 16;
               }
               else {
                  pConfigs[i].accumRedSize = 0;
                  pConfigs[i].accumGreenSize = 0;
                  pConfigs[i].accumBlueSize = 0;
                  pConfigs[i].accumAlphaSize = 0;
               }
               pConfigs[i].doubleBuffer = db ? TRUE : FALSE;
               pConfigs[i].stereo = FALSE;
               pConfigs[i].bufferSize = 16;
               if (depth)
                  pConfigs[i].depthSize = 16;
               else
                  pConfigs[i].depthSize = 0;
               if (stencil)
                  pConfigs[i].stencilSize = 8;
               else 
                  pConfigs[i].stencilSize = 0;
               pConfigs[i].auxBuffers = 0;
               pConfigs[i].level = 0;
               if (stencil || accum)
                  pConfigs[i].visualRating = GLX_SLOW_VISUAL_EXT;
               else
                  pConfigs[i].visualRating = GLX_NONE_EXT;
               pConfigs[i].transparentPixel = 0;
               pConfigs[i].transparentRed = 0;
               pConfigs[i].transparentGreen = 0;
               pConfigs[i].transparentBlue = 0;
               pConfigs[i].transparentAlpha = 0;
               pConfigs[i].transparentIndex = 0;
               i++;
            }
         }
      }
      assert(i == numConfigs);
      break;

   case 32:
      numConfigs = 8;

      pConfigs = (__GLXvisualConfig*)xcalloc( sizeof(__GLXvisualConfig),
						numConfigs );
      if ( !pConfigs ) {
	 return FALSE;
      }

      pI810Configs = (I810ConfigPrivPtr)xcalloc( sizeof(I810ConfigPrivRec),
						 numConfigs );
      if ( !pI810Configs ) {
	 xfree( pConfigs );
	 return FALSE;
      }

      pI810ConfigPtrs = (I810ConfigPrivPtr*)
				xcalloc(sizeof(I810ConfigPrivPtr),
					  numConfigs);
      if ( !pI810ConfigPtrs ) {
	 xfree( pConfigs );
	 xfree( pI810Configs );
	 return FALSE;
      }

      for ( i = 0 ; i < numConfigs ; i++ ) {
	 pI810ConfigPtrs[i] = &pI810Configs[i];
      }

      i = 0;
      for ( accum = 0 ; accum <= 1 ; accum++ ) {
         for ( depth = 0 ; depth <= 1 ; depth++ ) { /* and stencil */
            for ( db = 1 ; db >= 0 ; db-- ) {
               pConfigs[i].vid			= -1;
               pConfigs[i].class		= -1;
               pConfigs[i].rgba			= TRUE;
               pConfigs[i].redSize		= 8;
               pConfigs[i].greenSize		= 8;
               pConfigs[i].blueSize		= 8;
               pConfigs[i].alphaSize		= 0;
               pConfigs[i].redMask		= 0x00FF0000;
               pConfigs[i].greenMask		= 0x0000FF00;
               pConfigs[i].blueMask		= 0x000000FF;
               pConfigs[i].alphaMask		= 0xff000000;;
               if ( accum ) {
                  pConfigs[i].accumRedSize	= 16;
                  pConfigs[i].accumGreenSize	= 16;
                  pConfigs[i].accumBlueSize	= 16;
                  pConfigs[i].accumAlphaSize	= 0;
               } else {
                  pConfigs[i].accumRedSize	= 0;
                  pConfigs[i].accumGreenSize	= 0;
                  pConfigs[i].accumBlueSize	= 0;
                  pConfigs[i].accumAlphaSize	= 0;
               }
               if ( db ) {
                  pConfigs[i].doubleBuffer	= TRUE;
               } else {
                  pConfigs[i].doubleBuffer	= FALSE;
	       }
               pConfigs[i].stereo		= FALSE;
               pConfigs[i].bufferSize		= 32;
               if ( depth ) {
		     pConfigs[i].depthSize	= 24;
                     pConfigs[i].stencilSize	= 8;
               }
               else {
                     pConfigs[i].depthSize	= 0;
                     pConfigs[i].stencilSize	= 0;
               }
               pConfigs[i].auxBuffers		= 0;
               pConfigs[i].level		= 0;
               if ( accum ) {
                  pConfigs[i].visualRating	= GLX_SLOW_VISUAL_EXT;
               } else {
                  pConfigs[i].visualRating	= GLX_NONE_EXT;
	       }
               pConfigs[i].transparentPixel	= 0;
               pConfigs[i].transparentRed	= 0;
               pConfigs[i].transparentGreen	= 0;
               pConfigs[i].transparentBlue	= 0;
               pConfigs[i].transparentAlpha	= 0;
               pConfigs[i].transparentIndex	= 0;
               i++;
            }
         }
      }
      if ( i != numConfigs ) {
         xf86DrvMsg( pScrn->scrnIndex, X_ERROR,
		     "[drm] Incorrect initialization of visuals\n" );
         return FALSE;
      }
      break;

   }
   pI810->numVisualConfigs = numConfigs;
   pI810->pVisualConfigs = pConfigs;
   pI810->pVisualConfigsPriv = pI810Configs;
   GlxSetVisualConfigs(numConfigs, pConfigs, (void**)pI810ConfigPtrs);
   return TRUE;
}


static unsigned int mylog2(unsigned int n)
{
   unsigned int log2 = 1;
   while (n>1) n >>= 1, log2++;
   return log2;
}


Bool I830DRIScreenInit(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I810Ptr pI810 = I810PTR(pScrn);
   DRIInfoPtr pDRIInfo;
   I830DRIPtr pI830DRI;
   unsigned long tom;
   unsigned long agpHandle;
   int sysmem_size = 0;
   int back_size = 0;
   int bufs;
   int i;

   /* Hardware 3D rendering only implemented for 16bpp and 32 bpp */
   if (((pScrn->bitsPerPixel / 8) != 2 && pScrn->depth != 16) && 
       (pScrn->bitsPerPixel / 8) != 4) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
                 "[drm] Direct rendering only supported in 16 and 32 bpp modes\n");
      return FALSE;
   }

   /* Check that the GLX, DRI, and DRM modules have been loaded by testing
    * for known symbols in each module. */
   if (!xf86LoaderCheckSymbol("GlxSetVisualConfigs")) return FALSE;
   if (!xf86LoaderCheckSymbol("DRIScreenInit"))       return FALSE;
   if (!xf86LoaderCheckSymbol("drmAvailable"))        return FALSE;
   if (!xf86LoaderCheckSymbol("DRIQueryVersion")) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
                 "[dri] %s failed (libdri.a too old)\n","I830DRIScreenInit");
      return FALSE;
   }
   
   /* Check the DRI version */
   {
      int major, minor, patch;
      DRIQueryVersion(&major, &minor, &patch);
      if (major != 4 || minor < 0) {
         xf86DrvMsg(pScreen->myNum, X_ERROR,
                    "[dri] %s failed because of a version mismatch.\n"
					"[dri] libDRI version is %d.%d.%d bug version 4.0.x is needed.\n"
					"[dri] Disabling DRI.\n",
					"I830DRIScreenInit", major, minor, patch);
         return FALSE;
      }
   }

   pDRIInfo = DRICreateInfoRec();
   if (!pDRIInfo) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[dri] DRICreateInfoRec failed. Disabling DRI.\n");
      return FALSE;
   }

   pI810->pDRIInfo = pDRIInfo;
   pI810->LockHeld = 0;

   pDRIInfo->drmDriverName = I830KernelDriverName;
   pDRIInfo->clientDriverName = I830ClientDriverName;
   pDRIInfo->busIdString = xalloc(64);

   sprintf(pDRIInfo->busIdString, "PCI:%d:%d:%d",
	   ((pciConfigPtr)pI810->PciInfo->thisCard)->busnum,
	   ((pciConfigPtr)pI810->PciInfo->thisCard)->devnum,
	   ((pciConfigPtr)pI810->PciInfo->thisCard)->funcnum);
   pDRIInfo->ddxDriverMajorVersion = I830_MAJOR_VERSION;
   pDRIInfo->ddxDriverMinorVersion = I830_MINOR_VERSION;
   pDRIInfo->ddxDriverPatchVersion = I830_PATCHLEVEL;
   pDRIInfo->frameBufferPhysicalAddress = pI810->LinearAddr;
   pDRIInfo->frameBufferSize = (((pScrn->displayWidth * 
				  pScrn->virtualY * pI810->cpp) + 
				 4096 - 1) / 4096) * 4096;

   pDRIInfo->frameBufferStride = pScrn->displayWidth*pI810->cpp;
   pDRIInfo->ddxDrawableTableEntry = I830_MAX_DRAWABLES;

   if (SAREA_MAX_DRAWABLES < I830_MAX_DRAWABLES)
      pDRIInfo->maxDrawableTableEntry = SAREA_MAX_DRAWABLES;
   else
      pDRIInfo->maxDrawableTableEntry = I830_MAX_DRAWABLES;

   if (sizeof(XF86DRISAREARec)+sizeof(I830SAREARec)>SAREA_MAX) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[dri] Data does not fit in SAREA\n");
      return FALSE;
   }
   /* This is a hack for now.  We have to have more than a 4k page here
    * because of the size of the state.  However, the state should be
    * in a per-context mapping.  This will be added in the Mesa 3.5 port
    * of the I830 driver.
    */
   pDRIInfo->SAREASize = SAREA_MAX;

   if (!(pI830DRI = (I830DRIPtr)xcalloc(sizeof(I830DRIRec),1))) {
      DRIDestroyInfoRec(pI810->pDRIInfo);
      pI810->pDRIInfo=0;
      return FALSE;
   }
   pDRIInfo->devPrivate = pI830DRI;
   pDRIInfo->devPrivateSize = sizeof(I830DRIRec);
   pDRIInfo->contextSize = sizeof(I830DRIContextRec);
   
   pDRIInfo->CreateContext = I830CreateContext;
   pDRIInfo->DestroyContext = I830DestroyContext;
   pDRIInfo->SwapContext = I830DRISwapContext;
   pDRIInfo->InitBuffers = I830DRIInitBuffers;
   pDRIInfo->MoveBuffers = I830DRIMoveBuffers;
   pDRIInfo->bufferRequests = DRI_ALL_WINDOWS;

   /* This adds the framebuffer as a drm map *before* we have asked agp
    * to allocate it.  Scary stuff, hold on...
    */
   if (!DRIScreenInit(pScreen, pDRIInfo, &pI810->drmSubFD)) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[dri] DRIScreenInit failed. Disabling DRI.\n");
      xfree(pDRIInfo->devPrivate);
      pDRIInfo->devPrivate=0;
      DRIDestroyInfoRec(pI810->pDRIInfo);
      pI810->pDRIInfo=0;
      return FALSE;
   }
   
   /* Check the i830 DRM version */
   {
      drmVersionPtr version = drmGetVersion(pI810->drmSubFD);
      if (version) {
         if (version->version_major != 1 ||
             version->version_minor < 2) {
            /* incompatible drm version */
            xf86DrvMsg(pScreen->myNum, X_ERROR,
                       "[dri] %s failed because of a version mismatch.\n"
					   "[dri] i830.o kernel module version is %d.%d.%d but version 1.2 or greater is needed.\n"
					   "[dri] Disabling DRI.\n",
					   "I830DRIScreenInit",
                       version->version_major,
                       version->version_minor,
                       version->version_patchlevel);
            I830DRICloseScreen(pScreen);
            drmFreeVersion(version);
            return FALSE;
         }
         drmFreeVersion(version);
      }
   }

   pI830DRI->regsSize=I830_REG_SIZE;
   if (drmAddMap(pI810->drmSubFD, (drmHandle)pI810->MMIOAddr, 
		 pI830DRI->regsSize, DRM_REGISTERS, 0, &pI830DRI->regs)<0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] drmAddMap(regs) failed\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Registers = 0x%08lx\n",
	      pI830DRI->regs);
   
   pI810->backHandle = 0;
   pI810->zHandle = 0;
   pI810->cursorHandle = 0;
   pI810->sysmemHandle = 0;
   pI810->agpAcquired = FALSE;

   /* Agp Support - Need this just to get the framebuffer.
    */
   if(drmAgpAcquire(pI810->drmSubFD) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[agp] drmAgpAquire failed\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }
   pI810->agpAcquired = TRUE;
   
   if (drmAgpEnable(pI810->drmSubFD, 0) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[agp] drmAgpEnable failed\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }

   memset (&pI810->BackBuffer, 0, sizeof(I810MemRange));
   memset (&pI810->DepthBuffer, 0, sizeof(I810MemRange));
   pI810->CursorPhysical = 0;

   back_size = (((pScrn->displayWidth * 
		  pScrn->virtualY * pI810->cpp) + 
		 4096 - 1) / 4096) * 4096;

   sysmem_size = pScrn->videoRam * 1024;

   /* The 1 meg here is for texture space and the ring buffer. */
   if(sysmem_size < (3 * back_size + 0x100000)) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "[dri] Not enough memory to contain front, back, and depth buffers.\n");
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "[dri] You need at least %dK of VideoRam for this configuration.\n",
				 (3 * back_size + 0x100000) / 1024);
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "[dri] Disabling DRI\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }

   sysmem_size = sysmem_size - 2*back_size;

   if(sysmem_size > pI810->FbMapSize) {
      sysmem_size = pI810->FbMapSize;

      xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		 "[dri] User requested more memory then fits in the agp aperture\n"
		 "[dri] Truncating to %d bytes of memory\n",
		 sysmem_size);
   }

   sysmem_size -= 4096;		/* remove 4k for the hw cursor */

   if(sysmem_size < 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
				 "[dri] Not enough memory to contain front, back, and depth buffers.\n"
				 "[dri] Disabling DRI.\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }

   drmAgpAlloc(pI810->drmSubFD, back_size, 0, NULL, &agpHandle);
   pI810->backHandle = agpHandle;

   if (agpHandle != 0) {
      if(drmAgpBind(pI810->drmSubFD, agpHandle, pI810->BackOffset) == 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "[dri] Bound backbuffer memory\n");
	 
	 pI810->BackBuffer.Start = pI810->BackOffset;
	 pI810->BackBuffer.Size = back_size;
	 pI810->BackBuffer.End = (pI810->BackBuffer.Start + 
				  pI810->BackBuffer.Size);
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[dri] Unable to bind backbuffer\n");
	 DRICloseScreen(pScreen);
	 return FALSE;
      }
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "[dri] Unable to allocate backbuffer memory\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }
      
   drmAgpAlloc(pI810->drmSubFD, back_size, 0,
	       NULL, &agpHandle);
   pI810->zHandle = agpHandle;

   if(agpHandle != 0) {
      if(drmAgpBind(pI810->drmSubFD, agpHandle, pI810->DepthOffset) == 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[dri] Bound depthbuffer memory\n");
	 pI810->DepthBuffer.Start = pI810->DepthOffset;
	 pI810->DepthBuffer.Size = back_size;
	 pI810->DepthBuffer.End = (pI810->DepthBuffer.Start + 
				   pI810->DepthBuffer.Size);
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		    "[dri] Unable to bind depthbuffer\n");
	 DRICloseScreen(pScreen);
	 return FALSE;
      }
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "[dri] Unable to allocate depthbuffer memory\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }

   /* Now allocate and bind the agp space.  This memory will include the
    * regular framebuffer as well as texture memory.
    */
   {
      int offset, alloc_size;

      alloc_size = sysmem_size;

      if(alloc_size <= pI810->StolenSize) {
	 /* We are cheating here.  We really should not scale the sysmem_size.
	  * However we always have at least stolen size here. */
	 alloc_size = 0;
	 offset = 0;
	 sysmem_size = pI810->StolenSize;
      } else {
	 alloc_size -= pI810->StolenSize; /* Stolen size is in bytes */
	 offset = pI810->StolenSize;
      }

      if(alloc_size) {
	 drmAgpAlloc(pI810->drmSubFD, alloc_size, 0, NULL, &agpHandle);
	 if (agpHandle == 0) {
	    xf86DrvMsg(pScreen->myNum, X_ERROR, "[agp] drmAgpAlloc failed\n");
	    DRICloseScreen(pScreen);
	    return FALSE;
	 }
	 if (drmAgpBind(pI810->drmSubFD, agpHandle, offset) != 0) {
	    xf86DrvMsg(pScreen->myNum, X_ERROR, "[agp] drmAgpBind failed\n");
	    DRICloseScreen(pScreen);
	    return FALSE;
	 }

	 pI810->sysmemHandle = agpHandle;
      } else {
	 pI810->sysmemHandle = 0;
      }

      pI810->SysMem.Start = 0;
      pI810->SysMem.Size = sysmem_size;
      pI810->SysMem.End = sysmem_size;
      pI810->SavedSysMem = pI810->SysMem;

      if(sysmem_size <= pI810->StolenSize) {
	 tom = pI810->StolenSize;
      } else {
	 tom = pI810->SysMem.End;
      }

   }

   drmAgpAlloc(pI810->drmSubFD, 4096, 2, 
	       (unsigned long *)&pI810->CursorPhysical, &agpHandle); 
   pI810->cursorHandle = agpHandle;

   if (agpHandle != 0) {
      if (drmAgpBind(pI810->drmSubFD, agpHandle, tom) == 0) { 
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		    "[agp] GART: Allocated 4K for mouse cursor image\n");
	 pI810->CursorStart = tom;	 
	 tom += 4096;
      }
      else {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[agp] GART: cursor bind failed\n");
	 pI810->CursorPhysical = 0;    
      } 
   }
   else {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[agp] GART: cursor alloc failed\n");
      pI810->CursorPhysical = 0;
   }

   /* Steal some of the excess cursor space for the overlay regs,
    * then allocate 202*2 pages for the overlay buffers.
    */
   pI810->OverlayPhysical = pI810->CursorPhysical + 1024;
   pI810->OverlayStart = pI810->CursorStart + 1024;

   /* drmAddMap happens later to preserve index order */

   /* The tiled registers always describe 8 meg regions, even if
    * the actually memory used is less than 8 meg (which is the normal
    * case.)
    */

   {
      int can_tile, i;

#define Elements(x) sizeof(x)/sizeof(*x)

      for(i = 0, can_tile = 0; i < Elements(i830_pitches) ; i++) {
	 if((pScrn->displayWidth * pI810->cpp) == i830_pitches[i])
	   can_tile = 1;
      }

      if(can_tile) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[dri] Activating Tiled Memory\n");
	 I810SetTiledMemory(pScrn, 1,
			    pI810->DepthBuffer.Start,
			    pScrn->displayWidth * pI810->cpp,
			    8*1024*1024);

	 I810SetTiledMemory(pScrn, 2,
			    pI810->BackBuffer.Start,
			    pScrn->displayWidth * pI810->cpp,
			    8*1024*1024);
      }
   }

   pI810->auxPitch = pScrn->displayWidth;
   pI810->auxPitchBits = 0;

   pI830DRI->backbufferSize = pI810->BackBuffer.Size;

   if (drmAddMap(pI810->drmSubFD, (drmHandle)pI810->BackBuffer.Start,
		 pI810->BackBuffer.Size, DRM_AGP, 0, 
		 &pI830DRI->backbuffer) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] drmAddMap(backbuffer) failed. Disabling DRI\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }
   
   pI830DRI->depthbufferSize = pI810->DepthBuffer.Size;
   if (drmAddMap(pI810->drmSubFD, (drmHandle)pI810->DepthBuffer.Start,
		 pI810->DepthBuffer.Size, DRM_AGP, 0, 
		 &pI830DRI->depthbuffer) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] drmAddMap(depthbuffer) failed. Disabling DRI\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }
   
   /* Allocate FrontBuffer etc. */
   I810AllocateFront(pScrn);

   /* Allocate memory for the logical context, 32k is fine for right now */
   I810AllocHigh( &(pI810->ContextMem), &(pI810->SysMem),
		 32768 );

   /* Allocate buffer memory */
   I810AllocHigh( &(pI810->BufferMem), &(pI810->SysMem), 
		  I830_DMA_BUF_NR * I830_DMA_BUF_SZ);
   
   xf86DrvMsg(pScreen->myNum, X_INFO, "[dri] Buffer map : %lx\n",
              pI810->BufferMem.Start);
   
   if (pI810->BufferMem.Start == 0 || 
      pI810->BufferMem.End - pI810->BufferMem.Start > 
      I830_DMA_BUF_NR * I830_DMA_BUF_SZ) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
                 "[dri] Not enough memory for dma buffers. Disabling DRI\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }
   if (drmAddMap(pI810->drmSubFD, (drmHandle)pI810->BufferMem.Start,
		pI810->BufferMem.Size, DRM_AGP, 0,
		&pI810->buffer_map) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] drmAddMap(buffer_map) failed. Disabling DRI\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }

   pI830DRI->agp_buffers = pI810->buffer_map;
   pI830DRI->agp_buf_size = pI810->BufferMem.Size;

   if (drmAddMap(pI810->drmSubFD, (drmHandle)pI810->LpRing.mem.Start,
		 pI810->LpRing.mem.Size, DRM_AGP, 0,
		 &pI810->ring_map) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] drmAddMap(ring_map) failed. Disabling DRI\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }
   
   /* Use the rest of memory for textures. */
   pI830DRI->textureSize = pI810->SysMem.Size;

   i = mylog2(pI830DRI->textureSize / I830_NR_TEX_REGIONS);

   if (i < I830_LOG_MIN_TEX_REGION_SIZE)
      i = I830_LOG_MIN_TEX_REGION_SIZE;

   pI830DRI->logTextureGranularity = i;
   pI830DRI->textureSize = (pI830DRI->textureSize >> i) << i; /* truncate */

   if(pI830DRI->textureSize < 512*1024) {
      ErrorF("Less then 512k for textures\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }
   
   I810AllocLow( &(pI810->TexMem), &(pI810->SysMem),
		 pI830DRI->textureSize);
   
   if (drmAddMap(pI810->drmSubFD, (drmHandle)pI810->TexMem.Start,
		 pI810->TexMem.Size, DRM_AGP, 0,
		 &pI830DRI->textures) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] drmAddMap(textures) failed. Disabling DRI\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }
   
   if((bufs = drmAddBufs(pI810->drmSubFD,
			 I830_DMA_BUF_NR,
			 I830_DMA_BUF_SZ,
			 DRM_AGP_BUFFER, pI810->BufferMem.Start)) <= 0) {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "[drm] failure adding %d %d byte DMA buffers\n",
		 I830_DMA_BUF_NR,
		 I830_DMA_BUF_SZ);
      DRICloseScreen(pScreen);
      return FALSE;
   }

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[drm] added %d %d byte DMA buffers\n",
	      bufs, I830_DMA_BUF_SZ);


   xf86EnablePciBusMaster(pI810->PciInfo, TRUE);

   I830InitDma(pScrn);
   
   /* Okay now initialize the dma engine */
#if 1
   if (!pI830DRI->irq) {
      pI830DRI->irq = drmGetInterruptFromBusID(pI810->drmSubFD,
					       ((pciConfigPtr)pI810->PciInfo->thisCard)->busnum,
					       ((pciConfigPtr)pI810->PciInfo->thisCard)->devnum,
					       ((pciConfigPtr)pI810->PciInfo->thisCard)->funcnum);
      if((drmCtlInstHandler(pI810->drmSubFD, pI830DRI->irq)) != 0) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "[drm] failure adding irq handler, there is a device already using that irq\n"
			"[drm] Consider rearranging your PCI cards\n");
	 DRICloseScreen(pScreen);
	 return FALSE;
      }
   }

   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "[drm] dma control initialized, using IRQ %d\n",
	      pI830DRI->irq);
#endif

   pI830DRI=(I830DRIPtr)pI810->pDRIInfo->devPrivate;
   pI830DRI->deviceID=pI810->PciInfo->chipType;
   pI830DRI->width=pScrn->virtualX;
   pI830DRI->height=pScrn->virtualY;
   pI830DRI->mem=pScrn->videoRam*1024;
   pI830DRI->cpp=pI810->cpp;
   
   pI830DRI->fbOffset=pI810->FrontBuffer.Start;
   pI830DRI->fbStride=pI810->auxPitch;
   
   pI830DRI->bitsPerPixel = pScrn->bitsPerPixel;
   
   
   pI830DRI->textureOffset=pI810->TexMem.Start;
   
   pI830DRI->backOffset=pI810->BackBuffer.Start;
   pI830DRI->depthOffset=pI810->DepthBuffer.Start;
   
   pI830DRI->ringOffset=pI810->LpRing.mem.Start;
   pI830DRI->ringSize=pI810->LpRing.mem.Size;
   
   pI830DRI->auxPitch = pI810->auxPitch;
   pI830DRI->auxPitchBits = pI810->auxPitchBits;
   pI830DRI->sarea_priv_offset = sizeof(XF86DRISAREARec);

   if (!(I830InitVisualConfigs(pScreen))) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[dri] I830InitVisualConfigs failed. Disabling DRI\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }

   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[dri] visual configs initialized\n" );
   pI810->pDRIInfo->driverSwapMethod = DRI_HIDE_X_CONTEXT;

   return TRUE;
}

void
I830DRICloseScreen(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I810Ptr pI810 = I810PTR(pScrn);

   I830CleanupDma(pScrn);

   if(pI810->backHandle) drmAgpFree(pI810->drmSubFD, pI810->backHandle);
   if(pI810->zHandle) drmAgpFree(pI810->drmSubFD, pI810->zHandle);
   if(pI810->cursorHandle) drmAgpFree(pI810->drmSubFD, pI810->cursorHandle);
   if(pI810->sysmemHandle) drmAgpFree(pI810->drmSubFD, pI810->sysmemHandle);

   if(pI810->agpAcquired == TRUE) drmAgpRelease(pI810->drmSubFD);
   
   pI810->backHandle = 0;
   pI810->zHandle = 0;
   pI810->cursorHandle = 0;
   pI810->sysmemHandle = 0;
   pI810->agpAcquired = FALSE;

   
   DRICloseScreen(pScreen);

   if (pI810->pDRIInfo) {
      if (pI810->pDRIInfo->devPrivate) {
	 xfree(pI810->pDRIInfo->devPrivate);
	 pI810->pDRIInfo->devPrivate=0;
      }
      DRIDestroyInfoRec(pI810->pDRIInfo);
      pI810->pDRIInfo=0;
   }
   if (pI810->pVisualConfigs) xfree(pI810->pVisualConfigs);
   if (pI810->pVisualConfigsPriv) xfree(pI810->pVisualConfigsPriv);
}

static Bool
I830CreateContext(ScreenPtr pScreen, VisualPtr visual, 
		  drmContext hwContext, void *pVisualConfigPriv,
		  DRIContextType contextStore)
{
   return TRUE;
}

static void
I830DestroyContext(ScreenPtr pScreen, drmContext hwContext, 
		   DRIContextType contextStore)
{
}


Bool
I830DRIFinishScreenInit(ScreenPtr pScreen)
{
   I830SAREARec *sPriv = (I830SAREARec *)DRIGetSAREAPrivate(pScreen);
   memset( sPriv, 0, sizeof(sPriv) );
   return DRIFinishScreenInit(pScreen);
}

void
I830DRISwapContext(ScreenPtr pScreen, DRISyncType syncType, 
		   DRIContextType oldContextType, void *oldContext,
		   DRIContextType newContextType, void *newContext)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I810Ptr pI810 = I810PTR(pScrn);

   if (syncType == DRI_3D_SYNC && 
       oldContextType == DRI_2D_CONTEXT &&
       newContextType == DRI_2D_CONTEXT) 
   { 
      ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];

      if (I810_DEBUG & DEBUG_VERBOSE_DRI)
	 ErrorF("i830DRISwapContext (in)\n");
   
      pI810->LockHeld = 1;
      I810RefreshRing( pScrn );
   }
   else if (syncType == DRI_2D_SYNC && 
	    oldContextType == DRI_NO_CONTEXT &&
	    newContextType == DRI_2D_CONTEXT) 
   { 
      pI810->LockHeld = 0;
      if (I810_DEBUG & DEBUG_VERBOSE_DRI)
	 ErrorF("i830DRISwapContext (out)\n");
   }
   else if (I810_DEBUG & DEBUG_VERBOSE_DRI)
      ErrorF("i830DRISwapContext (other)\n");
}

static void
I830DRIInitBuffers(WindowPtr pWin, RegionPtr prgn, CARD32 index)
{
   ScreenPtr pScreen = pWin->drawable.pScreen;
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I810Ptr pI810 = I810PTR(pScrn);
   BoxPtr pbox = REGION_RECTS(prgn);
   int nbox = REGION_NUM_RECTS(prgn);

   if (I810_DEBUG & DEBUG_VERBOSE_DRI)
      ErrorF( "I830DRIInitBuffers\n");

   I830SetupForSolidFill(pScrn, 0, GXcopy, -1);
   while (nbox--) {
      I810SelectBuffer(pScrn, I810_BACK);
      I830SubsequentSolidFillRect(pScrn, pbox->x1, pbox->y1, 
				  pbox->x2-pbox->x1, pbox->y2-pbox->y1);
      pbox++;
   }

   /* Clear the depth buffer - uses 0xffff rather than 0.
    */
   pbox = REGION_RECTS(prgn);
   nbox = REGION_NUM_RECTS(prgn);

   I810SelectBuffer(pScrn, I810_DEPTH);

   switch (pScrn->bitsPerPixel) {
   case 16: I830SetupForSolidFill(pScrn, 0xffff, GXcopy, -1); break;
   case 32: I830SetupForSolidFill(pScrn, 0xffffff, GXcopy, -1); break;
   }

   while (nbox--) {  
      I830SubsequentSolidFillRect(pScrn, pbox->x1, pbox->y1, 
				  pbox->x2-pbox->x1, pbox->y2-pbox->y1);
      pbox++;
   }

   I810SelectBuffer(pScrn, I810_FRONT);
   pI810->AccelInfoRec->NeedToSync = TRUE;
}

/* This routine is a modified form of XAADoBitBlt with the calls to
 * ScreenToScreenBitBlt built in. My routine has the prgnSrc as source
 * instead of destination. My origin is upside down so the ydir cases
 * are reversed. 
 */
static void
I830DRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg, 
		   RegionPtr prgnSrc, CARD32 index)
{
   ScreenPtr pScreen = pParent->drawable.pScreen;
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I810Ptr pI810 = I810PTR(pScrn);
   BoxPtr pboxTmp, pboxNext, pboxBase;
   DDXPointPtr pptTmp, pptNew2;
   int xdir, ydir;

   int screenwidth = pScrn->virtualX;
   int screenheight = pScrn->virtualY;

   BoxPtr pbox = REGION_RECTS(prgnSrc);
   int nbox = REGION_NUM_RECTS(prgnSrc);

   BoxPtr pboxNew1 = 0;
   BoxPtr pboxNew2 = 0;
   DDXPointPtr pptNew1 = 0;
   DDXPointPtr pptSrc = &ptOldOrg;

   int dx = pParent->drawable.x - ptOldOrg.x;
   int dy = pParent->drawable.y - ptOldOrg.y;

   /* If the copy will overlap in Y, reverse the order */
   if (dy>0) {
      ydir = -1;

      if (nbox>1) {
	 /* Keep ordering in each band, reverse order of bands */
	 pboxNew1 = (BoxPtr)ALLOCATE_LOCAL(sizeof(BoxRec)*nbox);
	 if (!pboxNew1) return;
	 pptNew1 = (DDXPointPtr)ALLOCATE_LOCAL(sizeof(DDXPointRec)*nbox);
	 if (!pptNew1) {
	    DEALLOCATE_LOCAL(pboxNew1);
	    return;
	 }
	 pboxBase = pboxNext = pbox+nbox-1;
	 while (pboxBase >= pbox) {
	    while ((pboxNext >= pbox) && (pboxBase->y1 == pboxNext->y1))
	       pboxNext--;
	    pboxTmp = pboxNext+1;
	    pptTmp = pptSrc + (pboxTmp - pbox);
	    while (pboxTmp <= pboxBase) {
	       *pboxNew1++ = *pboxTmp++;
	       *pptNew1++ = *pptTmp++;
	    }
	    pboxBase = pboxNext;
	 }
	 pboxNew1 -= nbox;
	 pbox = pboxNew1;
	 pptNew1 -= nbox;
	 pptSrc = pptNew1;
      }
   } else {
      /* No changes required */
      ydir = 1;
   }

   /* If the regions will overlap in X, reverse the order */
   if (dx>0) {
      xdir = -1;

      if (nbox > 1) {
	 /*reverse orderof rects in each band */
	 pboxNew2 = (BoxPtr)ALLOCATE_LOCAL(sizeof(BoxRec)*nbox);
	 pptNew2 = (DDXPointPtr)ALLOCATE_LOCAL(sizeof(DDXPointRec)*nbox);
	 if (!pboxNew2 || !pptNew2) {
	    if (pptNew2) DEALLOCATE_LOCAL(pptNew2);
	    if (pboxNew2) DEALLOCATE_LOCAL(pboxNew2);
	    if (pboxNew1) {
	       DEALLOCATE_LOCAL(pptNew1);
	       DEALLOCATE_LOCAL(pboxNew1);
	    }
	    return;
	 }
	 pboxBase = pboxNext = pbox;
	 while (pboxBase < pbox+nbox) {
	    while ((pboxNext < pbox+nbox) && (pboxNext->y1 == pboxBase->y1))
	       pboxNext++;
	    pboxTmp = pboxNext;
	    pptTmp = pptSrc + (pboxTmp - pbox);
	    while (pboxTmp != pboxBase) {
	       *pboxNew2++ = *--pboxTmp;
	       *pptNew2++ = *--pptTmp;
	    }
	    pboxBase = pboxNext;
	 }
	 pboxNew2 -= nbox;
	 pbox = pboxNew2;
	 pptNew2 -= nbox;
	 pptSrc = pptNew2;
      }
   } else {
      /* No changes are needed */
      xdir = 1;
   }

   /* SelectBuffer isn't really a good concept for the i810.
    */
   I810EmitFlush(pScrn);
   I830SetupForScreenToScreenCopy(pScrn, xdir, ydir, GXcopy, -1, -1);
   for ( ; nbox-- ; pbox++ ) {
      
      int x1 = pbox->x1;
      int y1 = pbox->y1;
      int destx = x1 + dx;
      int desty = y1 + dy;
      int w = pbox->x2 - x1 + 1;
      int h = pbox->y2 - y1 + 1;
      
      if ( destx < 0 ) x1 -= destx, w += destx, destx = 0; 
      if ( desty < 0 ) y1 -= desty, h += desty, desty = 0;
      if ( destx + w > screenwidth ) w = screenwidth - destx;
      if ( desty + h > screenheight ) h = screenheight - desty;
      if ( w <= 0 ) continue;
      if ( h <= 0 ) continue;
      

      if (I810_DEBUG & DEBUG_VERBOSE_DRI)
	 ErrorF( "MoveBuffers %d,%d %dx%d dx: %d dy: %d\n",
		 x1, y1, w, h, dx, dy);

      I810SelectBuffer(pScrn, I810_BACK);
      I830SubsequentScreenToScreenCopy(pScrn, x1, y1, destx, desty, w, h);
      I810SelectBuffer(pScrn, I810_DEPTH);
      I830SubsequentScreenToScreenCopy(pScrn, x1, y1, destx, desty, w, h);
   }
   I810SelectBuffer(pScrn, I810_FRONT);
   I810EmitFlush(pScrn);

   if (pboxNew2) {
      DEALLOCATE_LOCAL(pptNew2);
      DEALLOCATE_LOCAL(pboxNew2);
   }
   if (pboxNew1) {
      DEALLOCATE_LOCAL(pptNew1);
      DEALLOCATE_LOCAL(pboxNew1);
   }

   pI810->AccelInfoRec->NeedToSync = TRUE;
}

/* Completely Initialize the first context */
void 
I830EmitInvarientState(ScrnInfoPtr pScrn)
{
   I810Ptr pI810 = I810PTR(pScrn);
   I830DRIPtr pI830DRI = (I830DRIPtr)pI810->pDRIInfo->devPrivate;
   CARD32 ctx_addr, vtx_addr, vtx1_addr, temp;
   BEGIN_LP_RING( 128 );

   ctx_addr = pI810->ContextMem.Start;
   /* Align to a 2k boundry */
   ctx_addr = ((ctx_addr + 2048 - 1) / 2048) * 2048;

   /* Carve out some context memory for the vertex buffers, if we ever
    * use these directly, we will need to change this
    */
   vtx_addr = ctx_addr + 8192;
   vtx1_addr = ctx_addr + 16384;

   OUT_RING(MI_SET_CONTEXT);
   OUT_RING(ctx_addr |
	    CTXT_NO_RESTORE |
	    CTXT_PALETTE_SAVE_DISABLE |
	    CTXT_PALETTE_RESTORE_DISABLE);

   /* Zero pitch and width make the vertex buffer match vertex format */
   OUT_RING(MI_VERTEX_BUFFER |
	    MI_VERTEX_BUFFER_IDX(0) |
	    MI_VERTEX_BUFFER_PITCH(0) |
	    MI_VERTEX_BUFFER_WIDTH(0));
   OUT_RING(vtx_addr);

   /* Setting zero pitch and width is undefined so we have to set these to
    * one, even though we just disable this buffer.
    */

   OUT_RING(MI_VERTEX_BUFFER |
	    MI_VERTEX_BUFFER_IDX(1) |
	    MI_VERTEX_BUFFER_PITCH(1) |
	    MI_VERTEX_BUFFER_WIDTH(1));
   OUT_RING(vtx1_addr |
	    MI_VERTEX_BUFFER_DISABLE);

   OUT_RING(STATE3D_AA_CMD |
	    AA_LINE_ECAAR_WIDTH_ENABLE |
	    AA_LINE_ECAAR_WIDTH_1_0 |
	    AA_LINE_REGION_WIDTH_ENABLE |
	    AA_LINE_REGION_WIDTH_1_0 |
	    AA_LINE_DISABLE);

   OUT_RING(STATE3D_BUF_INFO_CMD);
   OUT_RING(BUF_3D_ID_COLOR_BACK |
	    BUF_3D_USE_FENCE |
	    BUF_3D_PITCH((pI810->cpp * pScrn->displayWidth) / 4));
   OUT_RING(BUF_3D_ADDR(pI830DRI->backOffset));

   OUT_RING(STATE3D_BUF_INFO_CMD);
   OUT_RING(BUF_3D_ID_DEPTH |
	    BUF_3D_USE_FENCE |
	    BUF_3D_PITCH((pI810->cpp * pScrn->displayWidth) / 4));
   OUT_RING(BUF_3D_ADDR(pI830DRI->depthOffset));

   OUT_RING(STATE3D_COLOR_FACTOR);
   OUT_RING(0);

   OUT_RING(STATE3D_COLOR_FACTOR_CMD(0));
   OUT_RING(0);

   OUT_RING(STATE3D_COLOR_FACTOR_CMD(1));
   OUT_RING(0);

   OUT_RING(STATE3D_COLOR_FACTOR_CMD(2));
   OUT_RING(0);

   OUT_RING(STATE3D_COLOR_FACTOR_CMD(3));
   OUT_RING(0);

   OUT_RING(STATE3D_CONST_BLEND_COLOR_CMD);
   OUT_RING(0);

   OUT_RING(STATE3D_DFLT_DIFFUSE_CMD);
   OUT_RING(0);

   OUT_RING(STATE3D_DFLT_SPEC_CMD);
   OUT_RING(0);

   OUT_RING(STATE3D_DFLT_Z_CMD);
   OUT_RING(0);

   switch(pScrn->bitsPerPixel) {
   case 15:
      temp = DEPTH_FRMT_16_FIXED | COLR_BUF_RGB555;
      break;
   case 16:
      temp = DEPTH_FRMT_16_FIXED | COLR_BUF_RGB565;
      break;
   case 32:
      temp = DEPTH_FRMT_24_FIXED_8_OTHER | COLR_BUF_ARGB8888;
      break;
   default:
      temp = DEPTH_FRMT_16_FIXED | COLR_BUF_RGB565;
      break;
   }

   OUT_RING(STATE3D_DST_BUF_VARS_CMD);
   OUT_RING(DSTORG_HORT_BIAS(0x8) |
	    DSTORG_VERT_BIAS(0x8) |
	    DEPTH_IS_Z |
	    temp);

   OUT_RING(STATE3D_DRAW_RECT_CMD);
   OUT_RING(DRAW_RECT_DIS_DEPTH_OFS);
   OUT_RING(0);
   OUT_RING((pI830DRI->height<<16) |
	    pI830DRI->width);
   OUT_RING(0);

   OUT_RING(STATE3D_ENABLES_1_CMD |
	    DISABLE_LOGIC_OP |
	    DISABLE_STENCIL_TEST |
	    DISABLE_DEPTH_BIAS |
	    DISABLE_SPEC_ADD |
	    I830_DISABLE_FOG |
	    DISABLE_ALPHA_TEST |
	    DISABLE_COLOR_BLEND |
	    DISABLE_DEPTH_TEST);

   OUT_RING(STATE3D_ENABLES_2_CMD |
	    DISABLE_STENCIL_WRITE |
	    ENABLE_TEX_CACHE |
	    ENABLE_DITHER |
	    ENABLE_COLOR_MASK |
	    ENABLE_COLOR_WRITE |
	    ENABLE_DEPTH_WRITE);

   OUT_RING(STATE3D_FOG_COLOR_CMD |
	    FOG_COLOR_RED(0) |
	    FOG_COLOR_GREEN(0) |
	    FOG_COLOR_BLUE(0));

   OUT_RING(STATE3D_FOG_MODE);
   OUT_RING(FOG_MODE_VERTEX |
	    ENABLE_FOG_CONST |
	    ENABLE_FOG_SOURCE |
	    ENABLE_FOG_DENSITY);
   OUT_RING(0);
   OUT_RING(0);

   OUT_RING(STATE3D_INDPT_ALPHA_BLEND_CMD |
	    DISABLE_INDPT_ALPHA_BLEND |
	    ENABLE_ALPHA_BLENDFUNC |
	    ABLENDFUNC_ADD |
	    ENABLE_SRC_ABLEND_FACTOR |
	    SRC_ABLEND_FACT(BLENDFACT_ONE) |
	    ENABLE_DST_ABLEND_FACTOR |
	    SRC_ABLEND_FACT(BLENDFACT_ZERO));

   /* I need to come back to texture state */
   OUT_RING(STATE3D_MAP_BLEND_ARG_CMD(0) |
	    TEXPIPE_COLOR |
	    TEXBLEND_ARG1 |
	    TEXBLENDARG_MODIFY_PARMS |
	    TEXBLENDARG_DIFFUSE);
   OUT_RING(STATE3D_MAP_BLEND_ARG_CMD(1) |
	    TEXPIPE_COLOR |
	    TEXBLEND_ARG1 |
	    TEXBLENDARG_MODIFY_PARMS |
	    TEXBLENDARG_DIFFUSE);
   OUT_RING(STATE3D_MAP_BLEND_ARG_CMD(2) |
	    TEXPIPE_COLOR |
	    TEXBLEND_ARG1 |
	    TEXBLENDARG_MODIFY_PARMS |
	    TEXBLENDARG_DIFFUSE);
   OUT_RING(STATE3D_MAP_BLEND_ARG_CMD(3) |
	    TEXPIPE_COLOR |
	    TEXBLEND_ARG1 |
	    TEXBLENDARG_MODIFY_PARMS |
	    TEXBLENDARG_DIFFUSE);

   OUT_RING(STATE3D_MAP_BLEND_ARG_CMD(0) |
	    TEXPIPE_ALPHA |
	    TEXBLEND_ARG1 |
	    TEXBLENDARG_MODIFY_PARMS |
	    TEXBLENDARG_DIFFUSE);
   OUT_RING(STATE3D_MAP_BLEND_ARG_CMD(1) |
	    TEXPIPE_ALPHA |
	    TEXBLEND_ARG1 |
	    TEXBLENDARG_MODIFY_PARMS |
	    TEXBLENDARG_DIFFUSE);
   OUT_RING(STATE3D_MAP_BLEND_ARG_CMD(2) |
	    TEXPIPE_ALPHA |
	    TEXBLEND_ARG1 |
	    TEXBLENDARG_MODIFY_PARMS |
	    TEXBLENDARG_DIFFUSE);
   OUT_RING(STATE3D_MAP_BLEND_ARG_CMD(3) |
	    TEXPIPE_ALPHA |
	    TEXBLEND_ARG1 |
	    TEXBLENDARG_MODIFY_PARMS |
	    TEXBLENDARG_DIFFUSE);

   OUT_RING(STATE3D_MAP_BLEND_OP_CMD(0) |
	    TEXPIPE_COLOR |
	    ENABLE_TEXOUTPUT_WRT_SEL |
	    TEXOP_OUTPUT_CURRENT |
	    DISABLE_TEX_CNTRL_STAGE |
	    TEXOP_SCALE_1X |
	    TEXOP_MODIFY_PARMS |
	    TEXOP_LAST_STAGE |
	    TEXBLENDOP_ARG1);
   OUT_RING(STATE3D_MAP_BLEND_OP_CMD(0) |
	    TEXPIPE_ALPHA |
	    ENABLE_TEXOUTPUT_WRT_SEL |
	    TEXOP_OUTPUT_CURRENT |
	    TEXOP_SCALE_1X |
	    TEXOP_MODIFY_PARMS |
	    TEXBLENDOP_ARG1);

   OUT_RING(STATE3D_MAP_COORD_SETBIND_CMD);
   OUT_RING(TEXBIND_SET3(TEXCOORDSRC_DEFAULT) |
	    TEXBIND_SET2(TEXCOORDSRC_DEFAULT) |
	    TEXBIND_SET1(TEXCOORDSRC_DEFAULT) |
	    TEXBIND_SET0(TEXCOORDSRC_DEFAULT));

   OUT_RING(STATE3D_MAP_COORD_SET_CMD |
	    MAP_UNIT(0) |
	    TEXCOORDS_ARE_IN_TEXELUNITS |
	    TEXCOORDTYPE_CARTESIAN |
	    ENABLE_ADDR_V_CNTL |
	    ENABLE_ADDR_U_CNTL |
	    TEXCOORD_ADDR_V_MODE(TEXCOORDMODE_CLAMP) |
	    TEXCOORD_ADDR_U_MODE(TEXCOORDMODE_CLAMP));
   OUT_RING(STATE3D_MAP_COORD_SET_CMD |
	    MAP_UNIT(1) |
	    TEXCOORDS_ARE_IN_TEXELUNITS |
	    TEXCOORDTYPE_CARTESIAN |
	    ENABLE_ADDR_V_CNTL |
	    ENABLE_ADDR_U_CNTL |
	    TEXCOORD_ADDR_V_MODE(TEXCOORDMODE_CLAMP) |
	    TEXCOORD_ADDR_U_MODE(TEXCOORDMODE_CLAMP));
   OUT_RING(STATE3D_MAP_COORD_SET_CMD |
	    MAP_UNIT(2) |
	    TEXCOORDS_ARE_IN_TEXELUNITS |
	    TEXCOORDTYPE_CARTESIAN |
	    ENABLE_ADDR_V_CNTL |
	    ENABLE_ADDR_U_CNTL |
	    TEXCOORD_ADDR_V_MODE(TEXCOORDMODE_CLAMP) |
	    TEXCOORD_ADDR_U_MODE(TEXCOORDMODE_CLAMP));
   OUT_RING(STATE3D_MAP_COORD_SET_CMD |
	    MAP_UNIT(3) |
	    TEXCOORDS_ARE_IN_TEXELUNITS |
	    TEXCOORDTYPE_CARTESIAN |
	    ENABLE_ADDR_V_CNTL |
	    ENABLE_ADDR_U_CNTL |
	    TEXCOORD_ADDR_V_MODE(TEXCOORDMODE_CLAMP) |
	    TEXCOORD_ADDR_U_MODE(TEXCOORDMODE_CLAMP));

   OUT_RING(STATE3D_MAP_TEX_STREAM_CMD |
	    MAP_UNIT(0) |
	    DISABLE_TEX_STREAM_BUMP |
	    ENABLE_TEX_STREAM_COORD_SET |
	    TEX_STREAM_COORD_SET(0) |
	    ENABLE_TEX_STREAM_MAP_IDX |
	    TEX_STREAM_MAP_IDX(0));
   OUT_RING(STATE3D_MAP_TEX_STREAM_CMD |
	    MAP_UNIT(1) |
	    DISABLE_TEX_STREAM_BUMP |
	    ENABLE_TEX_STREAM_COORD_SET |
	    TEX_STREAM_COORD_SET(1) |
	    ENABLE_TEX_STREAM_MAP_IDX |
	    TEX_STREAM_MAP_IDX(1));
   OUT_RING(STATE3D_MAP_TEX_STREAM_CMD |
	    MAP_UNIT(2) |
	    DISABLE_TEX_STREAM_BUMP |
	    ENABLE_TEX_STREAM_COORD_SET |
	    TEX_STREAM_COORD_SET(2) |
	    ENABLE_TEX_STREAM_MAP_IDX |
	    TEX_STREAM_MAP_IDX(2));
   OUT_RING(STATE3D_MAP_TEX_STREAM_CMD |
	    MAP_UNIT(3) |
	    DISABLE_TEX_STREAM_BUMP |
	    ENABLE_TEX_STREAM_COORD_SET |
	    TEX_STREAM_COORD_SET(3) |
	    ENABLE_TEX_STREAM_MAP_IDX |
	    TEX_STREAM_MAP_IDX(3));

   OUT_RING(STATE3D_MAP_FILTER_CMD |
	    MAP_UNIT(0) |
	    ENABLE_CHROMA_KEY_PARAMS |
	    ENABLE_MIP_MODE_FILTER |
	    MIPFILTER_NEAREST |
	    ENABLE_MAG_MODE_FILTER |
	    ENABLE_MIN_MODE_FILTER |
	    MAG_FILTER(FILTER_NEAREST) |
	    MIN_FILTER(FILTER_NEAREST));
   OUT_RING(STATE3D_MAP_FILTER_CMD |
	    MAP_UNIT(1) |
	    ENABLE_CHROMA_KEY_PARAMS |
	    ENABLE_MIP_MODE_FILTER |
	    MIPFILTER_NEAREST |
	    ENABLE_MAG_MODE_FILTER |
	    ENABLE_MIN_MODE_FILTER |
	    MAG_FILTER(FILTER_NEAREST) |
	    MIN_FILTER(FILTER_NEAREST));
   OUT_RING(STATE3D_MAP_FILTER_CMD |
	    MAP_UNIT(2) |
	    ENABLE_CHROMA_KEY_PARAMS |
	    ENABLE_MIP_MODE_FILTER |
	    MIPFILTER_NEAREST |
	    ENABLE_MAG_MODE_FILTER |
	    ENABLE_MIN_MODE_FILTER |
	    MAG_FILTER(FILTER_NEAREST) |
	    MIN_FILTER(FILTER_NEAREST));
   OUT_RING(STATE3D_MAP_FILTER_CMD |
	    MAP_UNIT(3) |
	    ENABLE_CHROMA_KEY_PARAMS |
	    ENABLE_MIP_MODE_FILTER |
	    MIPFILTER_NEAREST |
	    ENABLE_MAG_MODE_FILTER |
	    ENABLE_MIN_MODE_FILTER |
	    MAG_FILTER(FILTER_NEAREST) |
	    MIN_FILTER(FILTER_NEAREST));

   OUT_RING(STATE3D_MAP_INFO_COLR_CMD);
   OUT_RING(MAP_INFO_TEX(0) |
	    MAPSURF_32BIT |
	    MT_32BIT_ARGB8888 |
	    MAP_INFO_OUTMUX_F0F1F2F3 |
	    MAP_INFO_VERTLINESTRIDEOFS_0 |
	    MAP_INFO_FORMAT_2D |
	    MAP_INFO_USE_FENCE);
   OUT_RING(MAP_INFO_HEIGHT(0) |
	    MAP_INFO_WIDTH(0));
   OUT_RING(MAP_INFO_BASEADDR(pI810->TexMem.Start));
   OUT_RING(MAP_INFO_DWORD_PITCH(31));
   OUT_RING(MAP_INFO_DFLT_COLR(0));

   OUT_RING(STATE3D_MAP_INFO_COLR_CMD);
   OUT_RING(MAP_INFO_TEX(1) |
	    MAPSURF_32BIT |
	    MT_32BIT_ARGB8888 |
	    MAP_INFO_OUTMUX_F0F1F2F3 |
	    MAP_INFO_VERTLINESTRIDEOFS_0 |
	    MAP_INFO_FORMAT_2D |
	    MAP_INFO_USE_FENCE);
   OUT_RING(MAP_INFO_HEIGHT(0) |
	    MAP_INFO_WIDTH(0));
   OUT_RING(MAP_INFO_BASEADDR(pI810->TexMem.Start));
   OUT_RING(MAP_INFO_DWORD_PITCH(31));
   OUT_RING(MAP_INFO_DFLT_COLR(0));

   OUT_RING(STATE3D_MAP_INFO_COLR_CMD);
   OUT_RING(MAP_INFO_TEX(2) |
	    MAPSURF_32BIT |
	    MT_32BIT_ARGB8888 |
	    MAP_INFO_OUTMUX_F0F1F2F3 |
	    MAP_INFO_VERTLINESTRIDEOFS_0 |
	    MAP_INFO_FORMAT_2D |
	    MAP_INFO_USE_FENCE);
   OUT_RING(MAP_INFO_HEIGHT(0) |
	    MAP_INFO_WIDTH(0));
   OUT_RING(MAP_INFO_BASEADDR(pI810->TexMem.Start));
   OUT_RING(MAP_INFO_DWORD_PITCH(31));
   OUT_RING(MAP_INFO_DFLT_COLR(0));

   OUT_RING(STATE3D_MAP_INFO_COLR_CMD);
   OUT_RING(MAP_INFO_TEX(3) |
	    MAPSURF_32BIT |
	    MT_32BIT_ARGB8888 |
	    MAP_INFO_OUTMUX_F0F1F2F3 |
	    MAP_INFO_VERTLINESTRIDEOFS_0 |
	    MAP_INFO_FORMAT_2D |
	    MAP_INFO_USE_FENCE);
   OUT_RING(MAP_INFO_HEIGHT(0) |
	    MAP_INFO_WIDTH(0));
   OUT_RING(MAP_INFO_BASEADDR(pI810->TexMem.Start));
   OUT_RING(MAP_INFO_DWORD_PITCH(31));
   OUT_RING(MAP_INFO_DFLT_COLR(0));

   OUT_RING(STATE3D_MAP_LOD_CNTL_CMD |
	    MAP_UNIT(0) |
	    ENABLE_TEXLOD_BIAS |
	    MAP_LOD_BIAS(0));
   OUT_RING(STATE3D_MAP_LOD_CNTL_CMD |
	    MAP_UNIT(1) |
	    ENABLE_TEXLOD_BIAS |
	    MAP_LOD_BIAS(0));
   OUT_RING(STATE3D_MAP_LOD_CNTL_CMD |
	    MAP_UNIT(2) |
	    ENABLE_TEXLOD_BIAS |
	    MAP_LOD_BIAS(0));
   OUT_RING(STATE3D_MAP_LOD_CNTL_CMD |
	    MAP_UNIT(3) |
	    ENABLE_TEXLOD_BIAS |
	    MAP_LOD_BIAS(0));

   OUT_RING(STATE3D_MAP_LOD_LIMITS_CMD |
	    MAP_UNIT(0) |
	    ENABLE_MAX_MIP_LVL |
	    ENABLE_MIN_MIP_LVL |
	    LOD_MAX(0) |
	    LOD_MIN(0));
   OUT_RING(STATE3D_MAP_LOD_LIMITS_CMD |
	    MAP_UNIT(1) |
	    ENABLE_MAX_MIP_LVL |
	    ENABLE_MIN_MIP_LVL |
	    LOD_MAX(0) |
	    LOD_MIN(0));
   OUT_RING(STATE3D_MAP_LOD_LIMITS_CMD |
	    MAP_UNIT(2) |
	    ENABLE_MAX_MIP_LVL |
	    ENABLE_MIN_MIP_LVL |
	    LOD_MAX(0) |
	    LOD_MIN(0));
   OUT_RING(STATE3D_MAP_LOD_LIMITS_CMD |
	    MAP_UNIT(3) |
	    ENABLE_MAX_MIP_LVL |
	    ENABLE_MIN_MIP_LVL |
	    LOD_MAX(0) |
	    LOD_MIN(0));

   OUT_RING(STATE3D_MAP_COORD_TRANSFORM);
   OUT_RING(DISABLE_TEX_TRANSFORM | TEXTURE_SET(0));
   OUT_RING(STATE3D_MAP_COORD_TRANSFORM);
   OUT_RING(DISABLE_TEX_TRANSFORM | TEXTURE_SET(1));
   OUT_RING(STATE3D_MAP_COORD_TRANSFORM);
   OUT_RING(DISABLE_TEX_TRANSFORM | TEXTURE_SET(2));
   OUT_RING(STATE3D_MAP_COORD_TRANSFORM);
   OUT_RING(DISABLE_TEX_TRANSFORM | TEXTURE_SET(3));

   /* End texture state */

   OUT_RING(STATE3D_MODES_1_CMD |
	    ENABLE_COLR_BLND_FUNC |
	    BLENDFUNC_ADD |
	    ENABLE_SRC_BLND_FACTOR |
	    ENABLE_DST_BLND_FACTOR |
	    SRC_BLND_FACT(BLENDFACT_ONE) |
	    DST_BLND_FACT(BLENDFACT_ZERO));

   OUT_RING(STATE3D_MODES_2_CMD |
	    ENABLE_GLOBAL_DEPTH_BIAS |
	    GLOBAL_DEPTH_BIAS(0) |
	    ENABLE_ALPHA_TEST_FUNC |
	    ALPHA_TEST_FUNC(COMPAREFUNC_ALWAYS) |
	    ALPHA_REF_VALUE(0));

   OUT_RING(STATE3D_MODES_3_CMD |
	    ENABLE_DEPTH_TEST_FUNC |
	    DEPTH_TEST_FUNC(COMPAREFUNC_LESS) |
	    ENABLE_ALPHA_SHADE_MODE |
	    ALPHA_SHADE_MODE(SHADE_MODE_LINEAR) |
	    ENABLE_FOG_SHADE_MODE |
	    FOG_SHADE_MODE(SHADE_MODE_LINEAR) |
	    ENABLE_SPEC_SHADE_MODE |
	    SPEC_SHADE_MODE(SHADE_MODE_LINEAR) |
	    ENABLE_COLOR_SHADE_MODE |
	    COLOR_SHADE_MODE(SHADE_MODE_LINEAR) |
	    ENABLE_CULL_MODE |
	    CULLMODE_NONE);

   OUT_RING(STATE3D_MODES_4_CMD |
	    ENABLE_LOGIC_OP_FUNC |
	    LOGIC_OP_FUNC(LOGICOP_COPY) |
	    ENABLE_STENCIL_TEST_MASK |
	    STENCIL_TEST_MASK(0xff) |
	    ENABLE_STENCIL_WRITE_MASK |
	    STENCIL_WRITE_MASK(0xff));

   OUT_RING(STATE3D_MODES_5_CMD |
	    ENABLE_SPRITE_POINT_TEX |
	    SPRITE_POINT_TEX_OFF |
	    FLUSH_RENDER_CACHE |
	    FLUSH_TEXTURE_CACHE |
	    ENABLE_FIXED_LINE_WIDTH |
	    FIXED_LINE_WIDTH(0x2) |
	    ENABLE_FIXED_POINT_WIDTH |
	    FIXED_POINT_WIDTH(1));

   OUT_RING(STATE3D_RASTER_RULES_CMD |
	    ENABLE_POINT_RASTER_RULE |
	    OGL_POINT_RASTER_RULE |
	    ENABLE_LINE_STRIP_PROVOKE_VRTX |
	    ENABLE_TRI_FAN_PROVOKE_VRTX |
	    ENABLE_TRI_STRIP_PROVOKE_VRTX |
	    LINE_STRIP_PROVOKE_VRTX(1) |
	    TRI_FAN_PROVOKE_VRTX(2) |
	    TRI_STRIP_PROVOKE_VRTX(2));

   OUT_RING(STATE3D_SCISSOR_ENABLE_CMD |
	    DISABLE_SCISSOR_RECT);

   OUT_RING(STATE3D_SCISSOR_RECT_0_CMD);
   OUT_RING(0);
   OUT_RING(0);

   OUT_RING(STATE3D_STENCIL_TEST_CMD |
	    ENABLE_STENCIL_PARMS |
	    STENCIL_FAIL_OP(STENCILOP_KEEP) |
	    STENCIL_PASS_DEPTH_FAIL_OP(STENCILOP_KEEP) |
	    STENCIL_PASS_DEPTH_PASS_OP(STENCILOP_KEEP) |
	    ENABLE_STENCIL_TEST_FUNC |
	    STENCIL_TEST_FUNC(COMPAREFUNC_ALWAYS) |
	    ENABLE_STENCIL_REF_VALUE |
	    STENCIL_REF_VALUE(0));

   OUT_RING(VRTX_FORMAT_NTEX(1));

   OUT_RING(STATE3D_VERTEX_FORMAT_2_CMD |
	    VRTX_TEX_SET_0_FMT(TEXCOORDFMT_2D) |
	    VRTX_TEX_SET_1_FMT(TEXCOORDFMT_2D) |
	    VRTX_TEX_SET_2_FMT(TEXCOORDFMT_2D) |
	    VRTX_TEX_SET_3_FMT(TEXCOORDFMT_2D) |
	    VRTX_TEX_SET_4_FMT(TEXCOORDFMT_2D) |
	    VRTX_TEX_SET_5_FMT(TEXCOORDFMT_2D) |
	    VRTX_TEX_SET_6_FMT(TEXCOORDFMT_2D) |
	    VRTX_TEX_SET_7_FMT(TEXCOORDFMT_2D));

   OUT_RING(STATE3D_VERTEX_TRANSFORM);
   OUT_RING(DISABLE_VIEWPORT_TRANSFORM |
	    DISABLE_PERSPECTIVE_DIVIDE);

   OUT_RING(STATE3D_W_STATE_CMD);
   OUT_RING(MAGIC_W_STATE_DWORD1);
   OUT_RING(0x3f800000 /* 1.0 in IEEE float */);

   ADVANCE_LP_RING();
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_dri.c,v 1.16 2003/09/28 20:15:58 alanh Exp $ */
a4 1
Copyright  2002 by David Dawes
d27 1
d30 1
a30 29
/*
 * Reformatted with GNU indent (2.2.8), using the following options:
 *
 *    -bad -bap -c41 -cd0 -ncdb -ci6 -cli0 -cp0 -ncs -d0 -di3 -i3 -ip3 -l78
 *    -lp -npcs -psl -sob -ss -br -ce -sc -hnl
 *
 * This provides a good match with the original i810 code and preferred
 * XFree86 formatting conventions.
 *
 * When editing this driver, please follow the existing formatting, and edit
 * with <TAB> characters expanded at 8-column intervals.
 */

/*
 * Authors: Jeff Hartmann <jhartmann@@valinux.com>
 *          David Dawes <dawes@@xfree86.org>
 *          Keith Whitwell <keith@@tungstengraphics.com>
 */

/*
 * This driver does AGP memory allocation a little differently from most
 * others.  The 2D and 3D allocations have been unified (see i830_memory.c).
 * The driver does the AGP allocations and binding directly, then passes
 * on the mappings to the DRM module.  The DRM's AGP interfaces are not used.
 * The main difference with this is that the offsets need to include
 * the AGP aperture base address because that won't be known or added on
 * by the DRM module.
 *
 * DHD 07/2002
a41 1
#include "shadow.h"
d45 1
a45 1
#include "i830.h"
d53 1
a53 1
static Bool I830CreateContext(ScreenPtr pScreen, VisualPtr visual,
d58 2
a59 2
static void I830DRISwapContext(ScreenPtr pScreen, DRISyncType syncType,
			       DRIContextType readContextType,
d61 1
a61 1
			       DRIContextType writeContextType,
d64 1
a64 1
static void I830DRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
a66 9
static Bool I830DRICloseFullScreen(ScreenPtr pScreen);
static Bool I830DRIOpenFullScreen(ScreenPtr pScreen);
static void I830DRITransitionTo2d(ScreenPtr pScreen);
static void I830DRITransitionTo3d(ScreenPtr pScreen);
static void I830DRITransitionMultiToSingle3d(ScreenPtr pScreen);
static void I830DRITransitionSingleToMulti3d(ScreenPtr pScreen);

static void I830DRIShadowUpdate (ScreenPtr pScreen, shadowBufPtr pBuf);

d68 1
a68 1
				__GLXvisualConfig * configs,
d71 16
a86 11
static Bool
I830CleanupDma(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   drmI830Init info;

   memset(&info, 0, sizeof(drmI830Init));
   info.func = I830_CLEANUP_DMA;

   if (drmCommandWrite(pI830->drmSubFD, DRM_I830_INIT,
		       &info, sizeof(drmI830Init))) {
d88 1
a88 4
      return FALSE;
   }

   return TRUE;
d91 1
a91 2
static Bool
I830InitDma(ScrnInfoPtr pScrn)
d93 3
a95 3
   I830Ptr pI830 = I830PTR(pScrn);
   I830RingBuffer *ring = &(pI830->LpRing);
   I830DRIPtr pI830DRI = (I830DRIPtr) pI830->pDRIInfo->devPrivate;
d97 1
d99 3
a101 6
   memset(&info, 0, sizeof(drmI830Init));
   info.func = I830_INIT_DMA;

   info.ring_start = ring->mem.Start + pI830->LinearAddr;
   info.ring_end = ring->mem.End + pI830->LinearAddr;
   info.ring_size = ring->mem.Size;
d104 1
a104 1
   info.buffers_offset = (unsigned int)pI830->buffer_map;
d106 1
a106 1
   info.sarea_priv_offset = sizeof(XF86DRISAREARec);
d108 3
a110 3
   info.front_offset = pI830->FrontBuffer.Start;
   info.back_offset = pI830->BackBuffer.Start;
   info.depth_offset = pI830->DepthBuffer.Start;
d113 7
a119 32
   info.pitch = pI830->auxPitch;
   info.pitch_bits = pI830->auxPitchBits;
   info.back_pitch = pI830->auxPitch;
   info.depth_pitch = pI830->auxPitch;
   info.cpp = pI830->cpp;

   if (drmCommandWrite(pI830->drmSubFD, DRM_I830_INIT,
		       &info, sizeof(drmI830Init))) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "I830 Dma Initialization Failed\n");
      return FALSE;
   }

   return TRUE;
}

static Bool
I830SetParam(ScrnInfoPtr pScrn, int param, int value)
{
   I830Ptr pI830 = I830PTR(pScrn);
   drmI830SetParam sp;

   memset(&sp, 0, sizeof(sp));
   sp.param = param;
   sp.value = value;

   if (drmCommandWrite(pI830->drmSubFD, DRM_I830_SETPARAM, &sp, sizeof(sp))) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "I830 SetParam Failed\n");
      return FALSE;
   }

   return TRUE;
a121 1

d126 1
a126 1
   I830Ptr pI830 = I830PTR(pScrn);
d129 2
a130 2
   I830ConfigPrivPtr pI830Configs = 0;
   I830ConfigPrivPtr *pI830ConfigPtrs = 0;
d142 1
a142 3
      pConfigs =
	    (__GLXvisualConfig *) xcalloc(sizeof(__GLXvisualConfig),
					  numConfigs);
d146 2
a147 4
      pI830Configs =
	    (I830ConfigPrivPtr) xcalloc(sizeof(I830ConfigPrivRec),
					numConfigs);
      if (!pI830Configs) {
d152 2
a153 4
      pI830ConfigPtrs =
	    (I830ConfigPrivPtr *) xcalloc(sizeof(I830ConfigPrivPtr),
					  numConfigs);
      if (!pI830ConfigPtrs) {
d155 1
a155 1
	 xfree(pI830Configs);
d159 2
a160 2
      for (i = 0; i < numConfigs; i++)
	 pI830ConfigPtrs[i] = &pI830Configs[i];
d165 50
a214 49
	 for (stencil = 0; stencil <= 1; stencil++) {
	    for (db = 1; db >= 0; db--) {
	       pConfigs[i].vid = -1;
	       pConfigs[i].class = -1;
	       pConfigs[i].rgba = TRUE;
	       pConfigs[i].redSize = 5;
	       pConfigs[i].greenSize = 6;
	       pConfigs[i].blueSize = 5;
	       pConfigs[i].redMask = 0x0000F800;
	       pConfigs[i].greenMask = 0x000007E0;
	       pConfigs[i].blueMask = 0x0000001F;
	       pConfigs[i].alphaMask = 0;
	       if (accum) {
		  pConfigs[i].accumRedSize = 16;
		  pConfigs[i].accumGreenSize = 16;
		  pConfigs[i].accumBlueSize = 16;
		  pConfigs[i].accumAlphaSize = 0;
	       } else {
		  pConfigs[i].accumRedSize = 0;
		  pConfigs[i].accumGreenSize = 0;
		  pConfigs[i].accumBlueSize = 0;
		  pConfigs[i].accumAlphaSize = 0;
	       }
	       pConfigs[i].doubleBuffer = db ? TRUE : FALSE;
	       pConfigs[i].stereo = FALSE;
	       pConfigs[i].bufferSize = 16;
	       if (depth)
		  pConfigs[i].depthSize = 16;
	       else
		  pConfigs[i].depthSize = 0;
	       if (stencil)
		  pConfigs[i].stencilSize = 8;
	       else
		  pConfigs[i].stencilSize = 0;
	       pConfigs[i].auxBuffers = 0;
	       pConfigs[i].level = 0;
	       if (stencil || accum)
		  pConfigs[i].visualRating = GLX_SLOW_CONFIG;
	       else
		  pConfigs[i].visualRating = GLX_NONE;
	       pConfigs[i].transparentPixel = GLX_NONE;
	       pConfigs[i].transparentRed = 0;
	       pConfigs[i].transparentGreen = 0;
	       pConfigs[i].transparentBlue = 0;
	       pConfigs[i].transparentAlpha = 0;
	       pConfigs[i].transparentIndex = 0;
	       i++;
	    }
	 }
d222 3
a224 3
      pConfigs = (__GLXvisualConfig *) xcalloc(sizeof(__GLXvisualConfig),
					       numConfigs);
      if (!pConfigs) {
d228 4
a231 4
      pI830Configs = (I830ConfigPrivPtr) xcalloc(sizeof(I830ConfigPrivRec),
						 numConfigs);
      if (!pI830Configs) {
	 xfree(pConfigs);
d235 6
a240 5
      pI830ConfigPtrs = (I830ConfigPrivPtr *)
	    xcalloc(sizeof(I830ConfigPrivPtr), numConfigs);
      if (!pI830ConfigPtrs) {
	 xfree(pConfigs);
	 xfree(pI830Configs);
d244 2
a245 2
      for (i = 0; i < numConfigs; i++) {
	 pI830ConfigPtrs[i] = &pI830Configs[i];
d249 29
a277 38
      for (accum = 0; accum <= 1; accum++) {
	 for (depth = 0; depth <= 1; depth++) {	/* and stencil */
	    for (db = 1; db >= 0; db--) {
	       pConfigs[i].vid = -1;
	       pConfigs[i].class = -1;
	       pConfigs[i].rgba = TRUE;
	       pConfigs[i].redSize = 8;
	       pConfigs[i].greenSize = 8;
	       pConfigs[i].blueSize = 8;
	       pConfigs[i].alphaSize = 8;
	       pConfigs[i].redMask = 0x00FF0000;
	       pConfigs[i].greenMask = 0x0000FF00;
	       pConfigs[i].blueMask = 0x000000FF;
	       pConfigs[i].alphaMask = 0xFF000000;;
	       if (accum) {
		  pConfigs[i].accumRedSize = 16;
		  pConfigs[i].accumGreenSize = 16;
		  pConfigs[i].accumBlueSize = 16;
		  pConfigs[i].accumAlphaSize = 16;
	       } else {
		  pConfigs[i].accumRedSize = 0;
		  pConfigs[i].accumGreenSize = 0;
		  pConfigs[i].accumBlueSize = 0;
		  pConfigs[i].accumAlphaSize = 0;
	       }
	       if (db) {
		  pConfigs[i].doubleBuffer = TRUE;
	       } else {
		  pConfigs[i].doubleBuffer = FALSE;
	       }
	       pConfigs[i].stereo = FALSE;
	       pConfigs[i].bufferSize = 32;
	       if (depth) {
		  pConfigs[i].depthSize = 24;
		  pConfigs[i].stencilSize = 8;
	       } else {
		  pConfigs[i].depthSize = 0;
		  pConfigs[i].stencilSize = 0;
d279 16
a294 6
	       pConfigs[i].auxBuffers = 0;
	       pConfigs[i].level = 0;
	       if (accum) {
		  pConfigs[i].visualRating = GLX_SLOW_CONFIG;
	       } else {
		  pConfigs[i].visualRating = GLX_NONE;
d296 9
a304 9
	       pConfigs[i].transparentPixel = GLX_NONE;
	       pConfigs[i].transparentRed = 0;
	       pConfigs[i].transparentGreen = 0;
	       pConfigs[i].transparentBlue = 0;
	       pConfigs[i].transparentAlpha = 0;
	       pConfigs[i].transparentIndex = 0;
	       i++;
	    }
	 }
d306 4
a309 4
      if (i != numConfigs) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "[drm] Incorrect initialization of visuals\n");
	 return FALSE;
d314 4
a317 4
   pI830->numVisualConfigs = numConfigs;
   pI830->pVisualConfigs = pConfigs;
   pI830->pVisualConfigsPriv = pI830Configs;
   GlxSetVisualConfigs(numConfigs, pConfigs, (void **)pI830ConfigPtrs);
d321 10
a330 2
Bool
I830DRIScreenInit(ScreenPtr pScreen)
d333 1
a333 1
   I830Ptr pI830 = I830PTR(pScrn);
d336 6
a342 1
   DPRINTF(PFX, "I830DRIScreenInit\n");
d344 1
a344 1
   if (((pScrn->bitsPerPixel / 8) != 2 && pScrn->depth != 16) &&
d347 1
a347 1
		 "[drm] Direct rendering only supported in 16 and 32 bpp modes\n");
d353 3
a355 6
   if (!xf86LoaderCheckSymbol("GlxSetVisualConfigs"))
      return FALSE;
   if (!xf86LoaderCheckSymbol("DRIScreenInit"))
      return FALSE;
   if (!xf86LoaderCheckSymbol("drmAvailable"))
      return FALSE;
d358 1
a358 1
		 "[dri] %s failed (libdri.a too old)\n", "I830DRIScreenInit");
d361 1
a361 1

a364 1

d367 6
a372 6
	 xf86DrvMsg(pScreen->myNum, X_ERROR,
		    "[dri] %s failed because of a version mismatch.\n"
		    "[dri] libDRI version is %d.%d.%d bug version 4.0.x is needed.\n"
		    "[dri] Disabling DRI.\n",
		    "I830DRIScreenInit", major, minor, patch);
	 return FALSE;
d378 1
a378 2
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[dri] DRICreateInfoRec failed. Disabling DRI.\n");
d382 2
a383 2
   pI830->pDRIInfo = pDRIInfo;
   pI830->LockHeld = 0;
d390 3
a392 3
	   ((pciConfigPtr) pI830->PciInfo->thisCard)->busnum,
	   ((pciConfigPtr) pI830->PciInfo->thisCard)->devnum,
	   ((pciConfigPtr) pI830->PciInfo->thisCard)->funcnum);
d396 6
a401 5
   pDRIInfo->frameBufferPhysicalAddress = pI830->LinearAddr +
					  pI830->FrontBuffer.Start;
   pDRIInfo->frameBufferSize = ROUND_TO_PAGE(pScrn->displayWidth *
					     pScrn->virtualY * pI830->cpp);
   pDRIInfo->frameBufferStride = pScrn->displayWidth * pI830->cpp;
d409 2
a410 3
   if (sizeof(XF86DRISAREARec) + sizeof(I830SAREARec) > SAREA_MAX) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[dri] Data does not fit in SAREA\n");
d420 3
a422 3
   if (!(pI830DRI = (I830DRIPtr) xcalloc(sizeof(I830DRIRec), 1))) {
      DRIDestroyInfoRec(pI830->pDRIInfo);
      pI830->pDRIInfo = 0;
d428 1
a428 1

a434 6
   pDRIInfo->OpenFullScreen = I830DRIOpenFullScreen;
   pDRIInfo->CloseFullScreen = I830DRICloseFullScreen;
   pDRIInfo->TransitionTo2d = I830DRITransitionTo2d;
   pDRIInfo->TransitionTo3d = I830DRITransitionTo3d;
   pDRIInfo->TransitionSingleToMulti3D = I830DRITransitionSingleToMulti3d;
   pDRIInfo->TransitionMultiToSingle3D = I830DRITransitionMultiToSingle3d;
d436 5
a440 3
   if (!DRIScreenInit(pScreen, pDRIInfo, &pI830->drmSubFD)) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[dri] DRIScreenInit failed. Disabling DRI.\n");
d442 34
a475 3
      pDRIInfo->devPrivate = 0;
      DRIDestroyInfoRec(pI830->pDRIInfo);
      pI830->pDRIInfo = 0;
d478 8
d487 110
a596 1
   /* Check the i830 DRM versioning */
d598 3
a600 1
      drmVersionPtr version;
d602 9
a610 16
      /* Check the DRM lib version.
       * drmGetLibVersion was not supported in version 1.0, so check for
       * symbol first to avoid possible crash or hang.
       */
      if (xf86LoaderCheckSymbol("drmGetLibVersion")) {
	 version = drmGetLibVersion(pI830->drmSubFD);
      } else
      {
	 /* drmlib version 1.0.0 didn't have the drmGetLibVersion
	  * entry point.  Fake it by allocating a version record
	  * via drmGetVersion and changing it to version 1.0.0
	  */
	 version = drmGetVersion(pI830->drmSubFD);
	 version->version_major = 1;
	 version->version_minor = 0;
	 version->version_patchlevel = 0;
d613 10
a622 15
#define REQ_MAJ 1
#define REQ_MIN 1
      if (version) {
	 if (version->version_major != REQ_MAJ ||
	     version->version_minor < REQ_MIN) {
	    /* incompatible drm library version */
	    xf86DrvMsg(pScreen->myNum, X_ERROR,
		       "[dri] I830DRIScreenInit failed because of a version mismatch.\n"
		       "[dri] libdrm.a module version is %d.%d.%d but version %d.%d.x is needed.\n"
		       "[dri] Disabling DRI.\n",
		       version->version_major,
		       version->version_minor, version->version_patchlevel,
		       REQ_MAJ, REQ_MIN);
	    drmFreeVersion(version);
	    I830DRICloseScreen(pScreen);
d625 15
a639 1
	 drmFreeVersion(version);
d642 12
a653 18
      /* Check the i830 DRM version */
      version = drmGetVersion(pI830->drmSubFD);
      if (version) {
	 if (version->version_major != 1 || version->version_minor < 3) {
	    /* incompatible drm version */
	    xf86DrvMsg(pScreen->myNum, X_ERROR,
		       "[dri] %s failed because of a version mismatch.\n"
		       "[dri] i830.o kernel module version is %d.%d.%d but version 1.3 or greater is needed.\n"
		       "[dri] Disabling DRI.\n",
		       "I830DRIScreenInit",
		       version->version_major,
		       version->version_minor, version->version_patchlevel);
	    I830DRICloseScreen(pScreen);
	    drmFreeVersion(version);
	    return FALSE;
	 }
	 pI830->drmMinor = version->version_minor;
	 drmFreeVersion(version);
d655 8
a663 2
   return TRUE;
}
d665 5
a669 8
Bool
I830DRIDoMappings(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   DRIInfoPtr pDRIInfo = pI830->pDRIInfo;
   I830DRIPtr pI830DRI = pDRIInfo->devPrivate;
   int bufs;
d671 1
a671 10
   DPRINTF(PFX, "I830DRIDoMappings\n");
   pI830DRI->regsSize = I830_REG_SIZE;
   if (drmAddMap(pI830->drmSubFD, (drmHandle)pI830->MMIOAddr,
		 pI830DRI->regsSize, DRM_REGISTERS, 0, &pI830DRI->regs) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] drmAddMap(regs) failed\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Registers = 0x%08lx\n",
	      pI830DRI->regs);
d673 3
a675 2
   /*
    * The tile setup is now initiated from I830BIOSScreenInit().
d678 4
a681 2
   pI830->auxPitch = pScrn->displayWidth;
   pI830->auxPitchBits = 0;
d683 4
a686 1
   pI830DRI->backbufferSize = pI830->BackBuffer.Size;
d688 21
a708 3
   if (drmAddMap(pI830->drmSubFD,
		 (drmHandle)pI830->BackBuffer.Start + pI830->LinearAddr,
		 pI830->BackBuffer.Size, DRM_AGP, 0,
d710 1
a710 2
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[drm] drmAddMap(backbuffer) failed. Disabling DRI\n");
d714 4
a717 7
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Back Buffer = 0x%08lx\n",
	      pI830DRI->backbuffer);

   pI830DRI->depthbufferSize = pI830->DepthBuffer.Size;
   if (drmAddMap(pI830->drmSubFD,
		 (drmHandle)pI830->DepthBuffer.Start + pI830->LinearAddr,
		 pI830->DepthBuffer.Size, DRM_AGP, 0,
d719 22
d742 1
a742 1
		 "[drm] drmAddMap(depthbuffer) failed. Disabling DRI\n");
d746 4
a749 9
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Depth Buffer = 0x%08lx\n",
	      pI830DRI->depthbuffer);

   if (drmAddMap(pI830->drmSubFD,
		 (drmHandle)pI830->BufferMem.Start + pI830->LinearAddr,
		 pI830->BufferMem.Size, DRM_AGP, 0,
		 &pI830->buffer_map) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[drm] drmAddMap(buffer_map) failed. Disabling DRI\n");
a752 2
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] DMA Buffers = 0x%08lx\n",
	      pI830->buffer_map);
d754 2
a755 2
   pI830DRI->agp_buffers = pI830->buffer_map;
   pI830DRI->agp_buf_size = pI830->BufferMem.Size;
d757 4
a760 6
   if (drmAddMap(pI830->drmSubFD,
		 (drmHandle)pI830->LpRing.mem.Start + pI830->LinearAddr,
		 pI830->LpRing.mem.Size, DRM_AGP, 0,
		 &pI830->ring_map) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[drm] drmAddMap(ring_map) failed. Disabling DRI\n");
d764 8
a771 2
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] ring buffer = 0x%08lx\n",
	      pI830->ring_map);
d773 2
a774 2
   pI830DRI->textureSize = pI830->TexMem.Size;
   pI830DRI->logTextureGranularity = pI830->TexGranularity;
d776 11
a786 3
   if (drmAddMap(pI830->drmSubFD,
		 (drmHandle)pI830->TexMem.Start + pI830->LinearAddr,
		 pI830->TexMem.Size, DRM_AGP, 0,
d788 1
a788 2
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[drm] drmAddMap(textures) failed. Disabling DRI\n");
d792 5
a796 7
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] textures = 0x%08lx\n",
	      pI830DRI->textures);

   if ((bufs = drmAddBufs(pI830->drmSubFD,
			  I830_DMA_BUF_NR,
			  I830_DMA_BUF_SZ,
			  DRM_AGP_BUFFER, pI830DRI->agp_buffers)) <= 0) {
d799 2
a800 1
		 I830_DMA_BUF_NR, I830_DMA_BUF_SZ);
d805 2
a806 2
   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "[drm] added %d %d byte DMA buffers\n", bufs, I830_DMA_BUF_SZ);
a807 1
   I830InitDma(pScrn);
d809 1
a809 4
   if (pI830->PciInfo->chipType != PCI_CHIP_845_G &&
       pI830->PciInfo->chipType != PCI_CHIP_I830_M) {
      I830SetParam(pScrn, I830_SETPARAM_USE_MI_BATCHBUFFER_START, 1 );
   }
d811 2
d814 1
d816 5
a820 9
      pI830DRI->irq = drmGetInterruptFromBusID(pI830->drmSubFD,
					       ((pciConfigPtr) pI830->
						PciInfo->thisCard)->busnum,
					       ((pciConfigPtr) pI830->
						PciInfo->thisCard)->devnum,
					       ((pciConfigPtr) pI830->
						PciInfo->thisCard)->funcnum);
#if 1
      if ((drmCtlInstHandler(pI830->drmSubFD, pI830DRI->irq)) != 0) {
d823 1
a823 1
		    "[drm] Consider rearranging your PCI cards\n");
a826 1
#endif
a828 1

d830 3
a832 11
	      "[drm] dma control initialized, using IRQ %d\n", pI830DRI->irq);

   pI830DRI = (I830DRIPtr) pI830->pDRIInfo->devPrivate;
   pI830DRI->deviceID = pI830->PciInfo->chipType;
   pI830DRI->width = pScrn->virtualX;
   pI830DRI->height = pScrn->virtualY;
   pI830DRI->mem = pScrn->videoRam * 1024;
   pI830DRI->cpp = pI830->cpp;

   pI830DRI->fbOffset = pI830->FrontBuffer.Start;
   pI830DRI->fbStride = pI830->auxPitch;
d834 10
d845 12
a856 11

   pI830DRI->textureOffset = pI830->TexMem.Start;

   pI830DRI->backOffset = pI830->BackBuffer.Start;
   pI830DRI->depthOffset = pI830->DepthBuffer.Start;

   pI830DRI->ringOffset = pI830->LpRing.mem.Start;
   pI830DRI->ringSize = pI830->LpRing.mem.Size;

   pI830DRI->auxPitch = pI830->auxPitch;
   pI830DRI->auxPitchBits = pI830->auxPitchBits;
d860 1
a860 2
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[dri] I830InitVisualConfigs failed. Disabling DRI\n");
d865 2
a866 2
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[dri] visual configs initialized\n");
   pI830->pDRIInfo->driverSwapMethod = DRI_HIDE_X_CONTEXT;
d875 1
a875 2
   I830Ptr pI830 = I830PTR(pScrn);
   I830DRIPtr pI830DRI = (I830DRIPtr) pI830->pDRIInfo->devPrivate;
d877 1
a877 1
   DPRINTF(PFX, "I830DRICloseScreen\n");
d879 12
a890 6
   if (pI830DRI->irq) {
       drmCtlUninstHandler(pI830->drmSubFD);
       pI830DRI->irq = 0;
   }

   I830CleanupDma(pScrn);
d892 1
d895 10
a904 12
   if (pI830->pDRIInfo) {
      if (pI830->pDRIInfo->devPrivate) {
	 xfree(pI830->pDRIInfo->devPrivate);
	 pI830->pDRIInfo->devPrivate = 0;
      }
      DRIDestroyInfoRec(pI830->pDRIInfo);
      pI830->pDRIInfo = 0;
   }
   if (pI830->pVisualConfigs)
      xfree(pI830->pVisualConfigs);
   if (pI830->pVisualConfigsPriv)
      xfree(pI830->pVisualConfigsPriv);
d908 1
a908 1
I830CreateContext(ScreenPtr pScreen, VisualPtr visual,
d916 1
a916 1
I830DestroyContext(ScreenPtr pScreen, drmContext hwContext,
d921 1
d925 2
a926 17
   I830SAREARec *sPriv = (I830SAREARec *) DRIGetSAREAPrivate(pScreen);
   ScrnInfoPtr        pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "I830DRIFinishScreenInit\n");

   memset(sPriv, 0, sizeof(sPriv));

   /* Have shadow run only while there is 3d active.
    */
   if (pI830->allowPageFlip && pI830->drmMinor >= 3) {
      shadowSetup(pScreen);
      shadowAdd(pScreen, 0, I830DRIShadowUpdate, 0, 0, 0);
   }
   else
      pI830->allowPageFlip = 0;

d931 1
a931 1
I830DRISwapContext(ScreenPtr pScreen, DRISyncType syncType,
d936 1
a936 1
   I830Ptr pI830 = I830PTR(pScrn);
d938 4
a941 5
   if (!pScrn->vtSema)
      return;

   if (syncType == DRI_3D_SYNC &&
       oldContextType == DRI_2D_CONTEXT && newContextType == DRI_2D_CONTEXT) {
d946 9
a954 7

      pI830->LockHeld = 1;
      I830RefreshRing(pScrn);
   } else if (syncType == DRI_2D_SYNC &&
	      oldContextType == DRI_NO_CONTEXT &&
	      newContextType == DRI_2D_CONTEXT) {
      pI830->LockHeld = 0;
d957 2
a958 1
   } else if (I810_DEBUG & DEBUG_VERBOSE_DRI)
d967 1
a967 1
   I830Ptr pI830 = I830PTR(pScrn);
d972 1
a972 1
      ErrorF("I830DRIInitBuffers\n");
d976 3
a978 3
      I830SelectBuffer(pScrn, I830_SELECT_BACK);
      I830SubsequentSolidFillRect(pScrn, pbox->x1, pbox->y1,
				  pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
d987 1
a987 1
   I830SelectBuffer(pScrn, I830_SELECT_DEPTH);
d990 2
a991 6
   case 16:
      I830SetupForSolidFill(pScrn, 0xffff, GXcopy, -1);
      break;
   case 32:
      I830SetupForSolidFill(pScrn, 0xffffff, GXcopy, -1);
      break;
d994 3
a996 3
   while (nbox--) {
      I830SubsequentSolidFillRect(pScrn, pbox->x1, pbox->y1,
				  pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
d1000 2
a1001 2
   I830SelectBuffer(pScrn, I830_SELECT_FRONT);
   pI830->AccelInfoRec->NeedToSync = TRUE;
d1007 1
a1007 1
 * are reversed.
d1010 1
a1010 1
I830DRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
d1015 1
a1015 1
   I830Ptr pI830 = I830PTR(pScrn);
d1035 1
a1035 1
   if (dy > 0) {
d1038 1
a1038 1
      if (nbox > 1) {
d1040 3
a1042 4
	 pboxNew1 = (BoxPtr) ALLOCATE_LOCAL(sizeof(BoxRec) * nbox);
	 if (!pboxNew1)
	    return;
	 pptNew1 = (DDXPointPtr) ALLOCATE_LOCAL(sizeof(DDXPointRec) * nbox);
d1047 1
a1047 1
	 pboxBase = pboxNext = pbox + nbox - 1;
d1051 1
a1051 1
	    pboxTmp = pboxNext + 1;
d1070 1
a1070 1
   if (dx > 0) {
d1075 2
a1076 2
	 pboxNew2 = (BoxPtr) ALLOCATE_LOCAL(sizeof(BoxRec) * nbox);
	 pptNew2 = (DDXPointPtr) ALLOCATE_LOCAL(sizeof(DDXPointRec) * nbox);
d1078 2
a1079 4
	    if (pptNew2)
	       DEALLOCATE_LOCAL(pptNew2);
	    if (pboxNew2)
	       DEALLOCATE_LOCAL(pboxNew2);
d1087 2
a1088 2
	 while (pboxBase < pbox + nbox) {
	    while ((pboxNext < pbox + nbox) && (pboxNext->y1 == pboxBase->y1))
d1110 1
a1110 1
   I830EmitFlush(pScrn);
d1112 2
a1113 2
   for (; nbox--; pbox++) {

d1120 8
a1127 13

      if (destx < 0)
	 x1 -= destx, w += destx, destx = 0;
      if (desty < 0)
	 y1 -= desty, h += desty, desty = 0;
      if (destx + w > screenwidth)
	 w = screenwidth - destx;
      if (desty + h > screenheight)
	 h = screenheight - desty;
      if (w <= 0)
	 continue;
      if (h <= 0)
	 continue;
d1130 2
a1131 2
	 ErrorF("MoveBuffers %d,%d %dx%d dx: %d dy: %d\n",
		x1, y1, w, h, dx, dy);
d1133 1
a1133 1
      I830SelectBuffer(pScrn, I830_SELECT_BACK);
d1135 1
a1135 1
      I830SelectBuffer(pScrn, I830_SELECT_DEPTH);
d1138 2
a1139 2
   I830SelectBuffer(pScrn, I830_SELECT_FRONT);
   I830EmitFlush(pScrn);
d1150 1
a1150 1
   pI830->AccelInfoRec->NeedToSync = TRUE;
d1154 1
a1154 1
void
d1157 4
a1160 5
   I830Ptr pI830 = I830PTR(pScrn);
   I830DRIPtr pI830DRI = (I830DRIPtr) pI830->pDRIInfo->devPrivate;
   CARD32 ctx_addr, temp;

   BEGIN_LP_RING(128-2);
d1162 1
a1162 1
   ctx_addr = pI830->ContextMem.Start;
d1166 6
d1175 20
a1194 1
	    CTXT_PALETTE_SAVE_DISABLE | CTXT_PALETTE_RESTORE_DISABLE);
d1200 2
a1201 1
	    AA_LINE_REGION_WIDTH_1_0 | AA_LINE_DISABLE);
d1206 1
a1206 1
	    BUF_3D_PITCH((pI830->cpp * pScrn->displayWidth) / 4));
d1212 1
a1212 1
	    BUF_3D_PITCH((pI830->cpp * pScrn->displayWidth) / 4));
d1242 1
a1242 1
   switch (pScrn->bitsPerPixel) {
d1259 3
a1261 1
	    DSTORG_VERT_BIAS(0x8) | DEPTH_IS_Z | temp);
d1266 2
a1267 1
   OUT_RING((pI830DRI->height << 16) | pI830DRI->width);
d1276 3
a1278 1
	    DISABLE_ALPHA_TEST | DISABLE_COLOR_BLEND | DISABLE_DEPTH_TEST);
d1284 3
a1286 1
	    ENABLE_COLOR_MASK | ENABLE_COLOR_WRITE | ENABLE_DEPTH_WRITE);
d1289 3
a1291 1
	    FOG_COLOR_RED(0) | FOG_COLOR_GREEN(0) | FOG_COLOR_BLUE(0));
d1295 3
a1297 1
	    ENABLE_FOG_CONST | ENABLE_FOG_SOURCE | ENABLE_FOG_DENSITY);
d1307 2
a1308 1
	    ENABLE_DST_ABLEND_FACTOR | SRC_ABLEND_FACT(BLENDFACT_ZERO));
d1313 3
a1315 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1318 3
a1320 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1323 3
a1325 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1328 3
a1330 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1334 3
a1336 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1339 3
a1341 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1344 3
a1346 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1349 3
a1351 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1359 3
a1361 1
	    TEXOP_MODIFY_PARMS | TEXOP_LAST_STAGE | TEXBLENDOP_ARG1);
d1366 3
a1368 1
	    TEXOP_SCALE_1X | TEXOP_MODIFY_PARMS | TEXBLENDOP_ARG1);
d1414 2
a1415 1
	    ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(0));
d1421 2
a1422 1
	    ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(1));
d1428 2
a1429 1
	    ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(2));
d1435 2
a1436 1
	    ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(3));
a1437 1
#if 0
d1445 2
a1446 1
	    MAG_FILTER(FILTER_NEAREST) | MIN_FILTER(FILTER_NEAREST));
d1454 2
a1455 1
	    MAG_FILTER(FILTER_NEAREST) | MIN_FILTER(FILTER_NEAREST));
d1463 2
a1464 1
	    MAG_FILTER(FILTER_NEAREST) | MIN_FILTER(FILTER_NEAREST));
d1472 2
a1473 1
	    MAG_FILTER(FILTER_NEAREST) | MIN_FILTER(FILTER_NEAREST));
d1481 5
a1485 3
	    MAP_INFO_FORMAT_2D | MAP_INFO_USE_FENCE);
   OUT_RING(MAP_INFO_HEIGHT(0) | MAP_INFO_WIDTH(0));
   OUT_RING(MAP_INFO_BASEADDR(pI830->TexMem.Start));
d1495 5
a1499 3
	    MAP_INFO_FORMAT_2D | MAP_INFO_USE_FENCE);
   OUT_RING(MAP_INFO_HEIGHT(0) | MAP_INFO_WIDTH(0));
   OUT_RING(MAP_INFO_BASEADDR(pI830->TexMem.Start));
d1509 5
a1513 3
	    MAP_INFO_FORMAT_2D | MAP_INFO_USE_FENCE);
   OUT_RING(MAP_INFO_HEIGHT(0) | MAP_INFO_WIDTH(0));
   OUT_RING(MAP_INFO_BASEADDR(pI830->TexMem.Start));
d1523 5
a1527 3
	    MAP_INFO_FORMAT_2D | MAP_INFO_USE_FENCE);
   OUT_RING(MAP_INFO_HEIGHT(0) | MAP_INFO_WIDTH(0));
   OUT_RING(MAP_INFO_BASEADDR(pI830->TexMem.Start));
d1532 3
a1534 1
	    MAP_UNIT(0) | ENABLE_TEXLOD_BIAS | MAP_LOD_BIAS(0));
d1536 3
a1538 1
	    MAP_UNIT(1) | ENABLE_TEXLOD_BIAS | MAP_LOD_BIAS(0));
d1540 3
a1542 1
	    MAP_UNIT(2) | ENABLE_TEXLOD_BIAS | MAP_LOD_BIAS(0));
d1544 3
a1546 1
	    MAP_UNIT(3) | ENABLE_TEXLOD_BIAS | MAP_LOD_BIAS(0));
d1551 3
a1553 1
	    ENABLE_MIN_MIP_LVL | LOD_MAX(0) | LOD_MIN(0));
d1557 3
a1559 1
	    ENABLE_MIN_MIP_LVL | LOD_MAX(0) | LOD_MIN(0));
d1563 3
a1565 1
	    ENABLE_MIN_MIP_LVL | LOD_MAX(0) | LOD_MIN(0));
d1569 3
a1571 2
	    ENABLE_MIN_MIP_LVL | LOD_MAX(0) | LOD_MIN(0));
#endif 
d1589 2
a1590 1
	    SRC_BLND_FACT(BLENDFACT_ONE) | DST_BLND_FACT(BLENDFACT_ZERO));
d1596 2
a1597 1
	    ALPHA_TEST_FUNC(COMPAREFUNC_ALWAYS) | ALPHA_REF_VALUE(0));
d1610 2
a1611 1
	    ENABLE_CULL_MODE | CULLMODE_NONE);
d1618 2
a1619 1
	    ENABLE_STENCIL_WRITE_MASK | STENCIL_WRITE_MASK(0xff));
d1628 2
a1629 1
	    ENABLE_FIXED_POINT_WIDTH | FIXED_POINT_WIDTH(1));
d1638 2
a1639 1
	    TRI_FAN_PROVOKE_VRTX(2) | TRI_STRIP_PROVOKE_VRTX(2));
d1641 2
a1642 1
   OUT_RING(STATE3D_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);
d1655 2
a1656 1
	    ENABLE_STENCIL_REF_VALUE | STENCIL_REF_VALUE(0));
d1658 1
a1658 5
   OUT_RING(STATE3D_VERTEX_FORMAT_CMD |
	    VRTX_TEX_COORD_COUNT(1) |
	    VRTX_HAS_SPEC |
	    VRTX_HAS_DIFFUSE |
	    VRTX_HAS_XYZW);
d1671 2
a1672 1
   OUT_RING(DISABLE_VIEWPORT_TRANSFORM | DISABLE_PERSPECTIVE_DIVIDE);
d1676 1
a1676 6
   OUT_RING(0x3f800000 /* 1.0 in IEEE float */ );

#define GFX_OP_STIPPLE           ((0x3<<29)|(0x1d<<24)|(0x83<<16))

   OUT_RING(GFX_OP_STIPPLE);
   OUT_RING(0);
a1679 181

/* Fullscreen hooks.  The DRI fullscreen mode can probably be removed
 * as it adds little or nothing above the mechanism below.  (and isn't
 * widely used)
 */
static Bool
I830DRIOpenFullScreen(ScreenPtr pScreen)
{
  return TRUE;
}

static Bool
I830DRICloseFullScreen(ScreenPtr pScreen)
{
  return TRUE;
}



/* Use callbacks from dri.c to support pageflipping mode for a single
 * 3d context without need for any specific full-screen extension.
 *
 * Also see tdfx driver for example of using these callbacks to
 * allocate and free 3d-specific memory on demand.
 */





/* Use the miext/shadow module to maintain a list of dirty rectangles.
 * These are blitted to the back buffer to keep both buffers clean
 * during page-flipping when the 3d application isn't fullscreen.
 *
 * Unlike most use of the shadow code, both buffers are in video
 * memory.
 *
 * An alternative to this would be to organize for all on-screen
 * drawing operations to be duplicated for the two buffers.  That
 * might be faster, but seems like a lot more work...
 */


/* This should be done *before* XAA syncs,
 * Otherwise will have to sync again???
 */
static void
I830DRIShadowUpdate (ScreenPtr pScreen, shadowBufPtr pBuf)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   RegionPtr damage = &pBuf->damage;
   int i, num =  REGION_NUM_RECTS(damage);
   BoxPtr pbox = REGION_RECTS(damage);
   I830SAREARec *pSAREAPriv = DRIGetSAREAPrivate(pScreen);
   int cmd, br13;

   /* Don't want to do this when no 3d is active and pages are
    * right-way-round :
    */
   if (!pSAREAPriv->pf_active && pSAREAPriv->pf_current_page == 0)
      return;

   br13 = (pScrn->displayWidth * pI830->cpp) | (0xcc << 16);

   if (pScrn->bitsPerPixel == 32) {
      cmd = (XY_SRC_COPY_BLT_CMD | XY_SRC_COPY_BLT_WRITE_ALPHA |
	     XY_SRC_COPY_BLT_WRITE_RGB);
      br13 |= 3 << 24;
   } else {
      cmd = (XY_SRC_COPY_BLT_CMD);
      br13 |= 1 << 24;
   }

   for (i = 0 ; i < num ; i++, pbox++) {
      BEGIN_LP_RING(8);
      OUT_RING(cmd);
      OUT_RING(br13);
      OUT_RING((pbox->y1 << 16) | pbox->x1);
      OUT_RING((pbox->y2 << 16) | pbox->x2);
      OUT_RING(pI830->BackBuffer.Start);
      OUT_RING((pbox->y1 << 16) | pbox->x1);
      OUT_RING(br13 & 0xffff);
      OUT_RING(pI830->FrontBuffer.Start);
      ADVANCE_LP_RING();
   }
}


static void
I830EnablePageFlip(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   I830SAREARec *pSAREAPriv = DRIGetSAREAPrivate(pScreen);

   pSAREAPriv->pf_enabled = pI830->allowPageFlip;
   pSAREAPriv->pf_active = 0;

   if (pI830->allowPageFlip) {
      int br13 = (pScrn->displayWidth * pI830->cpp) | (0xcc << 16);

      BEGIN_LP_RING(8);
      if (pScrn->bitsPerPixel == 32) {
	 OUT_RING(XY_SRC_COPY_BLT_CMD | XY_SRC_COPY_BLT_WRITE_ALPHA |
		  XY_SRC_COPY_BLT_WRITE_RGB);
	 br13 |= 3 << 24;
      } else {
	 OUT_RING(XY_SRC_COPY_BLT_CMD);
	 br13 |= 1 << 24;
      }

      OUT_RING(br13);
      OUT_RING(0);
      OUT_RING((pScrn->virtualY << 16) | pScrn->virtualX);
      OUT_RING(pI830->BackBuffer.Start);
      OUT_RING(0);
      OUT_RING(br13 & 0xffff);
      OUT_RING(pI830->FrontBuffer.Start);
      ADVANCE_LP_RING();

      pSAREAPriv->pf_active = 1;
   }
}

static void
I830DisablePageFlip(ScreenPtr pScreen)
{
   I830SAREARec *pSAREAPriv = DRIGetSAREAPrivate(pScreen);

   pSAREAPriv->pf_active = 0;
}


static void
I830DRITransitionSingleToMulti3d(ScreenPtr pScreen)
{
   /* Tell the clients not to pageflip.  How?
    *   -- Field in sarea, plus bumping the window counters.
    *   -- DRM needs to cope with Front-to-Back swapbuffers.
    */
   I830DisablePageFlip(pScreen);
}

static void
I830DRITransitionMultiToSingle3d(ScreenPtr pScreen)
{
   /* Let the remaining 3d app start page flipping again.
    */
   I830EnablePageFlip(pScreen);
}


static void
I830DRITransitionTo3d(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);

   I830EnablePageFlip(pScreen);
   pI830->have3DWindows = 1;
}


static void
I830DRITransitionTo2d(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   I830SAREARec *sPriv = (I830SAREARec *) DRIGetSAREAPrivate(pScreen);

   /* Shut down shadowing if we've made it back to the front page:
    */
   if (sPriv->pf_current_page == 0) {
      I830DisablePageFlip(pScreen);
   }

   pI830->have3DWindows = 0;
}


@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_dri.c,v 1.12 2003/02/08 21:26:57 dawes Exp $ */
a4 1
Copyright  2002 by David Dawes
d27 1
d30 1
a30 29
/*
 * Reformatted with GNU indent (2.2.8), using the following options:
 *
 *    -bad -bap -c41 -cd0 -ncdb -ci6 -cli0 -cp0 -ncs -d0 -di3 -i3 -ip3 -l78
 *    -lp -npcs -psl -sob -ss -br -ce -sc -hnl
 *
 * This provides a good match with the original i810 code and preferred
 * XFree86 formatting conventions.
 *
 * When editing this driver, please follow the existing formatting, and edit
 * with <TAB> characters expanded at 8-column intervals.
 */

/*
 * Authors: Jeff Hartmann <jhartmann@@valinux.com>
 *          David Dawes <dawes@@tungstengraphics.com>
 *          Keith Whitwell <keith@@tungstengraphics.com>
 */

/*
 * This driver does AGP memory allocation a little differently from most
 * others.  The 2D and 3D allocations have been unified (see i830_memory.c).
 * The driver does the AGP allocations and binding directly, then passes
 * on the mappings to the DRM module.  The DRM's AGP interfaces are not used.
 * The main difference with this is that the offsets need to include
 * the AGP aperture base address because that won't be known or added on
 * by the DRM module.
 *
 * DHD 07/2002
a41 1
#include "shadow.h"
d45 1
a45 1
#include "i830.h"
d53 1
a53 1
static Bool I830CreateContext(ScreenPtr pScreen, VisualPtr visual,
d58 2
a59 2
static void I830DRISwapContext(ScreenPtr pScreen, DRISyncType syncType,
			       DRIContextType readContextType,
d61 1
a61 1
			       DRIContextType writeContextType,
d64 1
a64 1
static void I830DRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
a66 9
static Bool I830DRICloseFullScreen(ScreenPtr pScreen);
static Bool I830DRIOpenFullScreen(ScreenPtr pScreen);
static void I830DRITransitionTo2d(ScreenPtr pScreen);
static void I830DRITransitionTo3d(ScreenPtr pScreen);
static void I830DRITransitionMultiToSingle3d(ScreenPtr pScreen);
static void I830DRITransitionSingleToMulti3d(ScreenPtr pScreen);

static void I830DRIShadowUpdate (ScreenPtr pScreen, shadowBufPtr pBuf);

d68 1
a68 1
				__GLXvisualConfig * configs,
d71 16
a86 11
static Bool
I830CleanupDma(ScrnInfoPtr pScrn)
{
   I830Ptr pI830 = I830PTR(pScrn);
   drmI830Init info;

   memset(&info, 0, sizeof(drmI830Init));
   info.func = I830_CLEANUP_DMA;

   if (drmCommandWrite(pI830->drmSubFD, DRM_I830_INIT,
		       &info, sizeof(drmI830Init))) {
d88 1
a88 4
      return FALSE;
   }

   return TRUE;
d91 1
a91 2
static Bool
I830InitDma(ScrnInfoPtr pScrn)
d93 3
a95 3
   I830Ptr pI830 = I830PTR(pScrn);
   I830RingBuffer *ring = &(pI830->LpRing);
   I830DRIPtr pI830DRI = (I830DRIPtr) pI830->pDRIInfo->devPrivate;
d97 1
d99 3
a101 6
   memset(&info, 0, sizeof(drmI830Init));
   info.func = I830_INIT_DMA;

   info.ring_start = ring->mem.Start + pI830->LinearAddr;
   info.ring_end = ring->mem.End + pI830->LinearAddr;
   info.ring_size = ring->mem.Size;
d104 1
a104 1
   info.buffers_offset = (unsigned int)pI830->buffer_map;
d106 1
a106 1
   info.sarea_priv_offset = sizeof(XF86DRISAREARec);
d108 3
a110 3
   info.front_offset = pI830->FrontBuffer.Start;
   info.back_offset = pI830->BackBuffer.Start;
   info.depth_offset = pI830->DepthBuffer.Start;
d113 7
a119 32
   info.pitch = pI830->auxPitch;
   info.pitch_bits = pI830->auxPitchBits;
   info.back_pitch = pI830->auxPitch;
   info.depth_pitch = pI830->auxPitch;
   info.cpp = pI830->cpp;

   if (drmCommandWrite(pI830->drmSubFD, DRM_I830_INIT,
		       &info, sizeof(drmI830Init))) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		 "I830 Dma Initialization Failed\n");
      return FALSE;
   }

   return TRUE;
}

static Bool
I830SetParam(ScrnInfoPtr pScrn, int param, int value)
{
   I830Ptr pI830 = I830PTR(pScrn);
   drmI830SetParam sp;

   memset(&sp, 0, sizeof(sp));
   sp.param = param;
   sp.value = value;

   if (drmCommandWrite(pI830->drmSubFD, DRM_I830_SETPARAM, &sp, sizeof(sp))) {
      xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "I830 SetParam Failed\n");
      return FALSE;
   }

   return TRUE;
a121 1

d126 1
a126 1
   I830Ptr pI830 = I830PTR(pScrn);
d129 2
a130 2
   I830ConfigPrivPtr pI830Configs = 0;
   I830ConfigPrivPtr *pI830ConfigPtrs = 0;
d142 1
a142 3
      pConfigs =
	    (__GLXvisualConfig *) xcalloc(sizeof(__GLXvisualConfig),
					  numConfigs);
d146 2
a147 4
      pI830Configs =
	    (I830ConfigPrivPtr) xcalloc(sizeof(I830ConfigPrivRec),
					numConfigs);
      if (!pI830Configs) {
d152 2
a153 4
      pI830ConfigPtrs =
	    (I830ConfigPrivPtr *) xcalloc(sizeof(I830ConfigPrivPtr),
					  numConfigs);
      if (!pI830ConfigPtrs) {
d155 1
a155 1
	 xfree(pI830Configs);
d159 2
a160 2
      for (i = 0; i < numConfigs; i++)
	 pI830ConfigPtrs[i] = &pI830Configs[i];
d165 50
a214 49
	 for (stencil = 0; stencil <= 1; stencil++) {
	    for (db = 1; db >= 0; db--) {
	       pConfigs[i].vid = -1;
	       pConfigs[i].class = -1;
	       pConfigs[i].rgba = TRUE;
	       pConfigs[i].redSize = 5;
	       pConfigs[i].greenSize = 6;
	       pConfigs[i].blueSize = 5;
	       pConfigs[i].redMask = 0x0000F800;
	       pConfigs[i].greenMask = 0x000007E0;
	       pConfigs[i].blueMask = 0x0000001F;
	       pConfigs[i].alphaMask = 0;
	       if (accum) {
		  pConfigs[i].accumRedSize = 16;
		  pConfigs[i].accumGreenSize = 16;
		  pConfigs[i].accumBlueSize = 16;
		  pConfigs[i].accumAlphaSize = 16;
	       } else {
		  pConfigs[i].accumRedSize = 0;
		  pConfigs[i].accumGreenSize = 0;
		  pConfigs[i].accumBlueSize = 0;
		  pConfigs[i].accumAlphaSize = 0;
	       }
	       pConfigs[i].doubleBuffer = db ? TRUE : FALSE;
	       pConfigs[i].stereo = FALSE;
	       pConfigs[i].bufferSize = 16;
	       if (depth)
		  pConfigs[i].depthSize = 16;
	       else
		  pConfigs[i].depthSize = 0;
	       if (stencil)
		  pConfigs[i].stencilSize = 8;
	       else
		  pConfigs[i].stencilSize = 0;
	       pConfigs[i].auxBuffers = 0;
	       pConfigs[i].level = 0;
	       if (stencil || accum)
		  pConfigs[i].visualRating = GLX_SLOW_VISUAL_EXT;
	       else
		  pConfigs[i].visualRating = GLX_NONE_EXT;
	       pConfigs[i].transparentPixel = 0;
	       pConfigs[i].transparentRed = 0;
	       pConfigs[i].transparentGreen = 0;
	       pConfigs[i].transparentBlue = 0;
	       pConfigs[i].transparentAlpha = 0;
	       pConfigs[i].transparentIndex = 0;
	       i++;
	    }
	 }
d222 3
a224 3
      pConfigs = (__GLXvisualConfig *) xcalloc(sizeof(__GLXvisualConfig),
					       numConfigs);
      if (!pConfigs) {
d228 4
a231 4
      pI830Configs = (I830ConfigPrivPtr) xcalloc(sizeof(I830ConfigPrivRec),
						 numConfigs);
      if (!pI830Configs) {
	 xfree(pConfigs);
d235 6
a240 5
      pI830ConfigPtrs = (I830ConfigPrivPtr *)
	    xcalloc(sizeof(I830ConfigPrivPtr), numConfigs);
      if (!pI830ConfigPtrs) {
	 xfree(pConfigs);
	 xfree(pI830Configs);
d244 2
a245 2
      for (i = 0; i < numConfigs; i++) {
	 pI830ConfigPtrs[i] = &pI830Configs[i];
d249 29
a277 29
      for (accum = 0; accum <= 1; accum++) {
	 for (depth = 0; depth <= 1; depth++) {	/* and stencil */
	    for (db = 1; db >= 0; db--) {
	       pConfigs[i].vid = -1;
	       pConfigs[i].class = -1;
	       pConfigs[i].rgba = TRUE;
	       pConfigs[i].redSize = 8;
	       pConfigs[i].greenSize = 8;
	       pConfigs[i].blueSize = 8;
	       pConfigs[i].alphaSize = 0;
	       pConfigs[i].redMask = 0x00FF0000;
	       pConfigs[i].greenMask = 0x0000FF00;
	       pConfigs[i].blueMask = 0x000000FF;
	       pConfigs[i].alphaMask = 0x00000000;;
	       if (accum) {
		  pConfigs[i].accumRedSize = 16;
		  pConfigs[i].accumGreenSize = 16;
		  pConfigs[i].accumBlueSize = 16;
		  pConfigs[i].accumAlphaSize = 0;
	       } else {
		  pConfigs[i].accumRedSize = 0;
		  pConfigs[i].accumGreenSize = 0;
		  pConfigs[i].accumBlueSize = 0;
		  pConfigs[i].accumAlphaSize = 0;
	       }
	       if (db) {
		  pConfigs[i].doubleBuffer = TRUE;
	       } else {
		  pConfigs[i].doubleBuffer = FALSE;
d279 16
a294 8
	       pConfigs[i].stereo = FALSE;
	       pConfigs[i].bufferSize = 24;
	       if (depth) {
		  pConfigs[i].depthSize = 24;
		  pConfigs[i].stencilSize = 8;
	       } else {
		  pConfigs[i].depthSize = 0;
		  pConfigs[i].stencilSize = 0;
d296 9
a304 16
	       pConfigs[i].auxBuffers = 0;
	       pConfigs[i].level = 0;
	       if (accum) {
		  pConfigs[i].visualRating = GLX_SLOW_VISUAL_EXT;
	       } else {
		  pConfigs[i].visualRating = GLX_NONE_EXT;
	       }
	       pConfigs[i].transparentPixel = 0;
	       pConfigs[i].transparentRed = 0;
	       pConfigs[i].transparentGreen = 0;
	       pConfigs[i].transparentBlue = 0;
	       pConfigs[i].transparentAlpha = 0;
	       pConfigs[i].transparentIndex = 0;
	       i++;
	    }
	 }
d306 4
a309 4
      if (i != numConfigs) {
	 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "[drm] Incorrect initialization of visuals\n");
	 return FALSE;
d314 4
a317 4
   pI830->numVisualConfigs = numConfigs;
   pI830->pVisualConfigs = pConfigs;
   pI830->pVisualConfigsPriv = pI830Configs;
   GlxSetVisualConfigs(numConfigs, pConfigs, (void **)pI830ConfigPtrs);
d321 10
a330 2
Bool
I830DRIScreenInit(ScreenPtr pScreen)
d333 1
a333 1
   I830Ptr pI830 = I830PTR(pScrn);
d336 6
a342 1
   DPRINTF(PFX, "I830DRIScreenInit\n");
d344 1
a344 1
   if (((pScrn->bitsPerPixel / 8) != 2 && pScrn->depth != 16) &&
d347 1
a347 1
		 "[drm] Direct rendering only supported in 16 and 32 bpp modes\n");
d353 3
a355 6
   if (!xf86LoaderCheckSymbol("GlxSetVisualConfigs"))
      return FALSE;
   if (!xf86LoaderCheckSymbol("DRIScreenInit"))
      return FALSE;
   if (!xf86LoaderCheckSymbol("drmAvailable"))
      return FALSE;
d358 1
a358 1
		 "[dri] %s failed (libdri.a too old)\n", "I830DRIScreenInit");
d361 1
a361 1

a364 1

d367 6
a372 6
	 xf86DrvMsg(pScreen->myNum, X_ERROR,
		    "[dri] %s failed because of a version mismatch.\n"
		    "[dri] libDRI version is %d.%d.%d bug version 4.0.x is needed.\n"
		    "[dri] Disabling DRI.\n",
		    "I830DRIScreenInit", major, minor, patch);
	 return FALSE;
d378 1
a378 2
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[dri] DRICreateInfoRec failed. Disabling DRI.\n");
d382 2
a383 2
   pI830->pDRIInfo = pDRIInfo;
   pI830->LockHeld = 0;
d390 3
a392 3
	   ((pciConfigPtr) pI830->PciInfo->thisCard)->busnum,
	   ((pciConfigPtr) pI830->PciInfo->thisCard)->devnum,
	   ((pciConfigPtr) pI830->PciInfo->thisCard)->funcnum);
d396 6
a401 5
   pDRIInfo->frameBufferPhysicalAddress = pI830->LinearAddr +
					  pI830->FrontBuffer.Start;
   pDRIInfo->frameBufferSize = ROUND_TO_PAGE(pScrn->displayWidth *
					     pScrn->virtualY * pI830->cpp);
   pDRIInfo->frameBufferStride = pScrn->displayWidth * pI830->cpp;
d409 2
a410 3
   if (sizeof(XF86DRISAREARec) + sizeof(I830SAREARec) > SAREA_MAX) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[dri] Data does not fit in SAREA\n");
d420 3
a422 3
   if (!(pI830DRI = (I830DRIPtr) xcalloc(sizeof(I830DRIRec), 1))) {
      DRIDestroyInfoRec(pI830->pDRIInfo);
      pI830->pDRIInfo = 0;
d428 1
a428 1

a434 6
   pDRIInfo->OpenFullScreen = I830DRIOpenFullScreen;
   pDRIInfo->CloseFullScreen = I830DRICloseFullScreen;
   pDRIInfo->TransitionTo2d = I830DRITransitionTo2d;
   pDRIInfo->TransitionTo3d = I830DRITransitionTo3d;
   pDRIInfo->TransitionSingleToMulti3D = I830DRITransitionSingleToMulti3d;
   pDRIInfo->TransitionMultiToSingle3D = I830DRITransitionMultiToSingle3d;
d436 5
a440 3
   if (!DRIScreenInit(pScreen, pDRIInfo, &pI830->drmSubFD)) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[dri] DRIScreenInit failed. Disabling DRI.\n");
d442 34
a475 3
      pDRIInfo->devPrivate = 0;
      DRIDestroyInfoRec(pI830->pDRIInfo);
      pI830->pDRIInfo = 0;
d478 8
d487 110
a596 1
   /* Check the i830 DRM versioning */
d598 3
a600 1
      drmVersionPtr version;
d602 9
a610 16
      /* Check the DRM lib version.
       * drmGetLibVersion was not supported in version 1.0, so check for
       * symbol first to avoid possible crash or hang.
       */
      if (xf86LoaderCheckSymbol("drmGetLibVersion")) {
	 version = drmGetLibVersion(pI830->drmSubFD);
      } else
      {
	 /* drmlib version 1.0.0 didn't have the drmGetLibVersion
	  * entry point.  Fake it by allocating a version record
	  * via drmGetVersion and changing it to version 1.0.0
	  */
	 version = drmGetVersion(pI830->drmSubFD);
	 version->version_major = 1;
	 version->version_minor = 0;
	 version->version_patchlevel = 0;
d613 10
a622 15
#define REQ_MAJ 1
#define REQ_MIN 1
      if (version) {
	 if (version->version_major != REQ_MAJ ||
	     version->version_minor < REQ_MIN) {
	    /* incompatible drm library version */
	    xf86DrvMsg(pScreen->myNum, X_ERROR,
		       "[dri] I830DRIScreenInit failed because of a version mismatch.\n"
		       "[dri] libdrm.a module version is %d.%d.%d but version %d.%d.x is needed.\n"
		       "[dri] Disabling DRI.\n",
		       version->version_major,
		       version->version_minor, version->version_patchlevel,
		       REQ_MAJ, REQ_MIN);
	    drmFreeVersion(version);
	    I830DRICloseScreen(pScreen);
d625 15
a639 1
	 drmFreeVersion(version);
d642 12
a653 18
      /* Check the i830 DRM version */
      version = drmGetVersion(pI830->drmSubFD);
      if (version) {
	 if (version->version_major != 1 || version->version_minor < 3) {
	    /* incompatible drm version */
	    xf86DrvMsg(pScreen->myNum, X_ERROR,
		       "[dri] %s failed because of a version mismatch.\n"
		       "[dri] i830.o kernel module version is %d.%d.%d but version 1.3 or greater is needed.\n"
		       "[dri] Disabling DRI.\n",
		       "I830DRIScreenInit",
		       version->version_major,
		       version->version_minor, version->version_patchlevel);
	    I830DRICloseScreen(pScreen);
	    drmFreeVersion(version);
	    return FALSE;
	 }
	 pI830->drmMinor = version->version_minor;
	 drmFreeVersion(version);
d655 8
a663 2
   return TRUE;
}
d665 5
a669 8
Bool
I830DRIDoMappings(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   DRIInfoPtr pDRIInfo = pI830->pDRIInfo;
   I830DRIPtr pI830DRI = pDRIInfo->devPrivate;
   int bufs;
d671 1
a671 10
   DPRINTF(PFX, "I830DRIDoMappings\n");
   pI830DRI->regsSize = I830_REG_SIZE;
   if (drmAddMap(pI830->drmSubFD, (drmHandle)pI830->MMIOAddr,
		 pI830DRI->regsSize, DRM_REGISTERS, 0, &pI830DRI->regs) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR, "[drm] drmAddMap(regs) failed\n");
      DRICloseScreen(pScreen);
      return FALSE;
   }
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Registers = 0x%08lx\n",
	      pI830DRI->regs);
d673 3
a675 2
   /*
    * The tile setup is now initiated from I830BIOSScreenInit().
d678 26
a703 2
   pI830->auxPitch = pScrn->displayWidth;
   pI830->auxPitchBits = 0;
d705 1
a705 1
   pI830DRI->backbufferSize = pI830->BackBuffer.Size;
d707 2
a708 3
   if (drmAddMap(pI830->drmSubFD,
		 (drmHandle)pI830->BackBuffer.Start + pI830->LinearAddr,
		 pI830->BackBuffer.Size, DRM_AGP, 0,
d710 1
a710 2
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[drm] drmAddMap(backbuffer) failed. Disabling DRI\n");
d714 4
a717 7
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Back Buffer = 0x%08lx\n",
	      pI830DRI->backbuffer);

   pI830DRI->depthbufferSize = pI830->DepthBuffer.Size;
   if (drmAddMap(pI830->drmSubFD,
		 (drmHandle)pI830->DepthBuffer.Start + pI830->LinearAddr,
		 pI830->DepthBuffer.Size, DRM_AGP, 0,
d719 22
d742 1
a742 1
		 "[drm] drmAddMap(depthbuffer) failed. Disabling DRI\n");
d746 4
a749 9
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] Depth Buffer = 0x%08lx\n",
	      pI830DRI->depthbuffer);

   if (drmAddMap(pI830->drmSubFD,
		 (drmHandle)pI830->BufferMem.Start + pI830->LinearAddr,
		 pI830->BufferMem.Size, DRM_AGP, 0,
		 &pI830->buffer_map) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[drm] drmAddMap(buffer_map) failed. Disabling DRI\n");
a752 2
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] DMA Buffers = 0x%08lx\n",
	      pI830->buffer_map);
d754 2
a755 2
   pI830DRI->agp_buffers = pI830->buffer_map;
   pI830DRI->agp_buf_size = pI830->BufferMem.Size;
d757 4
a760 6
   if (drmAddMap(pI830->drmSubFD,
		 (drmHandle)pI830->LpRing.mem.Start + pI830->LinearAddr,
		 pI830->LpRing.mem.Size, DRM_AGP, 0,
		 &pI830->ring_map) < 0) {
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[drm] drmAddMap(ring_map) failed. Disabling DRI\n");
d764 8
a771 2
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] ring buffer = 0x%08lx\n",
	      pI830->ring_map);
d773 2
a774 2
   pI830DRI->textureSize = pI830->TexMem.Size;
   pI830DRI->logTextureGranularity = pI830->TexGranularity;
d776 11
a786 3
   if (drmAddMap(pI830->drmSubFD,
		 (drmHandle)pI830->TexMem.Start + pI830->LinearAddr,
		 pI830->TexMem.Size, DRM_AGP, 0,
d788 1
a788 2
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[drm] drmAddMap(textures) failed. Disabling DRI\n");
d792 5
a796 7
   xf86DrvMsg(pScreen->myNum, X_INFO, "[drm] textures = 0x%08lx\n",
	      pI830DRI->textures);

   if ((bufs = drmAddBufs(pI830->drmSubFD,
			  I830_DMA_BUF_NR,
			  I830_DMA_BUF_SZ,
			  DRM_AGP_BUFFER, pI830DRI->agp_buffers)) <= 0) {
d799 2
a800 1
		 I830_DMA_BUF_NR, I830_DMA_BUF_SZ);
d805 2
a806 2
   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "[drm] added %d %d byte DMA buffers\n", bufs, I830_DMA_BUF_SZ);
a807 1
   I830InitDma(pScrn);
d809 1
a809 4
   if (pI830->PciInfo->chipType != PCI_CHIP_845_G &&
       pI830->PciInfo->chipType != PCI_CHIP_I830_M) {
      I830SetParam(pScrn, I830_SETPARAM_USE_MI_BATCHBUFFER_START, 1 );
   }
d811 2
d814 1
d816 5
a820 9
      pI830DRI->irq = drmGetInterruptFromBusID(pI830->drmSubFD,
					       ((pciConfigPtr) pI830->
						PciInfo->thisCard)->busnum,
					       ((pciConfigPtr) pI830->
						PciInfo->thisCard)->devnum,
					       ((pciConfigPtr) pI830->
						PciInfo->thisCard)->funcnum);
#if 1
      if ((drmCtlInstHandler(pI830->drmSubFD, pI830DRI->irq)) != 0) {
d823 1
a823 1
		    "[drm] Consider rearranging your PCI cards\n");
a826 1
#endif
a828 1

d830 3
a832 11
	      "[drm] dma control initialized, using IRQ %d\n", pI830DRI->irq);

   pI830DRI = (I830DRIPtr) pI830->pDRIInfo->devPrivate;
   pI830DRI->deviceID = pI830->PciInfo->chipType;
   pI830DRI->width = pScrn->virtualX;
   pI830DRI->height = pScrn->virtualY;
   pI830DRI->mem = pScrn->videoRam * 1024;
   pI830DRI->cpp = pI830->cpp;

   pI830DRI->fbOffset = pI830->FrontBuffer.Start;
   pI830DRI->fbStride = pI830->auxPitch;
d834 10
d845 12
a856 11

   pI830DRI->textureOffset = pI830->TexMem.Start;

   pI830DRI->backOffset = pI830->BackBuffer.Start;
   pI830DRI->depthOffset = pI830->DepthBuffer.Start;

   pI830DRI->ringOffset = pI830->LpRing.mem.Start;
   pI830DRI->ringSize = pI830->LpRing.mem.Size;

   pI830DRI->auxPitch = pI830->auxPitch;
   pI830DRI->auxPitchBits = pI830->auxPitchBits;
d860 1
a860 2
      xf86DrvMsg(pScreen->myNum, X_ERROR,
		 "[dri] I830InitVisualConfigs failed. Disabling DRI\n");
d865 2
a866 2
   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "[dri] visual configs initialized\n");
   pI830->pDRIInfo->driverSwapMethod = DRI_HIDE_X_CONTEXT;
d875 1
a875 1
   I830Ptr pI830 = I830PTR(pScrn);
d877 1
a877 1
   DPRINTF(PFX, "I830DRICloseScreen\n");
d879 12
a890 1
   I830CleanupDma(pScrn);
d892 1
d895 10
a904 12
   if (pI830->pDRIInfo) {
      if (pI830->pDRIInfo->devPrivate) {
	 xfree(pI830->pDRIInfo->devPrivate);
	 pI830->pDRIInfo->devPrivate = 0;
      }
      DRIDestroyInfoRec(pI830->pDRIInfo);
      pI830->pDRIInfo = 0;
   }
   if (pI830->pVisualConfigs)
      xfree(pI830->pVisualConfigs);
   if (pI830->pVisualConfigsPriv)
      xfree(pI830->pVisualConfigsPriv);
d908 1
a908 1
I830CreateContext(ScreenPtr pScreen, VisualPtr visual,
d916 1
a916 1
I830DestroyContext(ScreenPtr pScreen, drmContext hwContext,
d921 1
d925 2
a926 17
   I830SAREARec *sPriv = (I830SAREARec *) DRIGetSAREAPrivate(pScreen);
   ScrnInfoPtr        pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);

   DPRINTF(PFX, "I830DRIFinishScreenInit\n");

   memset(sPriv, 0, sizeof(sPriv));

   /* Have shadow run only while there is 3d active.
    */
   if (pI830->allowPageFlip && pI830->drmMinor >= 3) {
      shadowSetup(pScreen);
      shadowAdd(pScreen, 0, I830DRIShadowUpdate, 0, 0, 0);
   }
   else
      pI830->allowPageFlip = 0;

d931 1
a931 1
I830DRISwapContext(ScreenPtr pScreen, DRISyncType syncType,
d936 1
a936 1
   I830Ptr pI830 = I830PTR(pScrn);
d938 4
a941 2
   if (syncType == DRI_3D_SYNC &&
       oldContextType == DRI_2D_CONTEXT && newContextType == DRI_2D_CONTEXT) {
d946 9
a954 7

      pI830->LockHeld = 1;
      I830RefreshRing(pScrn);
   } else if (syncType == DRI_2D_SYNC &&
	      oldContextType == DRI_NO_CONTEXT &&
	      newContextType == DRI_2D_CONTEXT) {
      pI830->LockHeld = 0;
d957 2
a958 1
   } else if (I810_DEBUG & DEBUG_VERBOSE_DRI)
d967 1
a967 1
   I830Ptr pI830 = I830PTR(pScrn);
d972 1
a972 1
      ErrorF("I830DRIInitBuffers\n");
d976 3
a978 3
      I830SelectBuffer(pScrn, I830_SELECT_BACK);
      I830SubsequentSolidFillRect(pScrn, pbox->x1, pbox->y1,
				  pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
d987 1
a987 1
   I830SelectBuffer(pScrn, I830_SELECT_DEPTH);
d990 2
a991 6
   case 16:
      I830SetupForSolidFill(pScrn, 0xffff, GXcopy, -1);
      break;
   case 32:
      I830SetupForSolidFill(pScrn, 0xffffff, GXcopy, -1);
      break;
d994 3
a996 3
   while (nbox--) {
      I830SubsequentSolidFillRect(pScrn, pbox->x1, pbox->y1,
				  pbox->x2 - pbox->x1, pbox->y2 - pbox->y1);
d1000 2
a1001 2
   I830SelectBuffer(pScrn, I830_SELECT_FRONT);
   pI830->AccelInfoRec->NeedToSync = TRUE;
d1007 1
a1007 1
 * are reversed.
d1010 1
a1010 1
I830DRIMoveBuffers(WindowPtr pParent, DDXPointRec ptOldOrg,
d1015 1
a1015 1
   I830Ptr pI830 = I830PTR(pScrn);
d1035 1
a1035 1
   if (dy > 0) {
d1038 1
a1038 1
      if (nbox > 1) {
d1040 3
a1042 4
	 pboxNew1 = (BoxPtr) ALLOCATE_LOCAL(sizeof(BoxRec) * nbox);
	 if (!pboxNew1)
	    return;
	 pptNew1 = (DDXPointPtr) ALLOCATE_LOCAL(sizeof(DDXPointRec) * nbox);
d1047 1
a1047 1
	 pboxBase = pboxNext = pbox + nbox - 1;
d1051 1
a1051 1
	    pboxTmp = pboxNext + 1;
d1070 1
a1070 1
   if (dx > 0) {
d1075 2
a1076 2
	 pboxNew2 = (BoxPtr) ALLOCATE_LOCAL(sizeof(BoxRec) * nbox);
	 pptNew2 = (DDXPointPtr) ALLOCATE_LOCAL(sizeof(DDXPointRec) * nbox);
d1078 2
a1079 4
	    if (pptNew2)
	       DEALLOCATE_LOCAL(pptNew2);
	    if (pboxNew2)
	       DEALLOCATE_LOCAL(pboxNew2);
d1087 2
a1088 2
	 while (pboxBase < pbox + nbox) {
	    while ((pboxNext < pbox + nbox) && (pboxNext->y1 == pboxBase->y1))
d1110 1
a1110 1
   I830EmitFlush(pScrn);
d1112 2
a1113 2
   for (; nbox--; pbox++) {

d1120 8
a1127 13

      if (destx < 0)
	 x1 -= destx, w += destx, destx = 0;
      if (desty < 0)
	 y1 -= desty, h += desty, desty = 0;
      if (destx + w > screenwidth)
	 w = screenwidth - destx;
      if (desty + h > screenheight)
	 h = screenheight - desty;
      if (w <= 0)
	 continue;
      if (h <= 0)
	 continue;
d1130 2
a1131 2
	 ErrorF("MoveBuffers %d,%d %dx%d dx: %d dy: %d\n",
		x1, y1, w, h, dx, dy);
d1133 1
a1133 1
      I830SelectBuffer(pScrn, I830_SELECT_BACK);
d1135 1
a1135 1
      I830SelectBuffer(pScrn, I830_SELECT_DEPTH);
d1138 2
a1139 2
   I830SelectBuffer(pScrn, I830_SELECT_FRONT);
   I830EmitFlush(pScrn);
d1150 1
a1150 1
   pI830->AccelInfoRec->NeedToSync = TRUE;
d1154 1
a1154 1
void
d1157 4
a1160 3
   I830Ptr pI830 = I830PTR(pScrn);
   I830DRIPtr pI830DRI = (I830DRIPtr) pI830->pDRIInfo->devPrivate;
   CARD32 ctx_addr, temp;
d1162 1
a1162 3
   BEGIN_LP_RING(128-2);

   ctx_addr = pI830->ContextMem.Start;
d1166 6
d1175 20
a1194 1
	    CTXT_PALETTE_SAVE_DISABLE | CTXT_PALETTE_RESTORE_DISABLE);
d1200 2
a1201 1
	    AA_LINE_REGION_WIDTH_1_0 | AA_LINE_DISABLE);
d1206 1
a1206 1
	    BUF_3D_PITCH((pI830->cpp * pScrn->displayWidth) / 4));
d1212 1
a1212 1
	    BUF_3D_PITCH((pI830->cpp * pScrn->displayWidth) / 4));
d1242 1
a1242 1
   switch (pScrn->bitsPerPixel) {
d1259 3
a1261 1
	    DSTORG_VERT_BIAS(0x8) | DEPTH_IS_Z | temp);
d1266 2
a1267 1
   OUT_RING((pI830DRI->height << 16) | pI830DRI->width);
d1276 3
a1278 1
	    DISABLE_ALPHA_TEST | DISABLE_COLOR_BLEND | DISABLE_DEPTH_TEST);
d1284 3
a1286 1
	    ENABLE_COLOR_MASK | ENABLE_COLOR_WRITE | ENABLE_DEPTH_WRITE);
d1289 3
a1291 1
	    FOG_COLOR_RED(0) | FOG_COLOR_GREEN(0) | FOG_COLOR_BLUE(0));
d1295 3
a1297 1
	    ENABLE_FOG_CONST | ENABLE_FOG_SOURCE | ENABLE_FOG_DENSITY);
d1307 2
a1308 1
	    ENABLE_DST_ABLEND_FACTOR | SRC_ABLEND_FACT(BLENDFACT_ZERO));
d1313 3
a1315 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1318 3
a1320 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1323 3
a1325 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1328 3
a1330 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1334 3
a1336 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1339 3
a1341 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1344 3
a1346 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1349 3
a1351 1
	    TEXBLEND_ARG1 | TEXBLENDARG_MODIFY_PARMS | TEXBLENDARG_DIFFUSE);
d1359 3
a1361 1
	    TEXOP_MODIFY_PARMS | TEXOP_LAST_STAGE | TEXBLENDOP_ARG1);
d1366 3
a1368 1
	    TEXOP_SCALE_1X | TEXOP_MODIFY_PARMS | TEXBLENDOP_ARG1);
d1414 2
a1415 1
	    ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(0));
d1421 2
a1422 1
	    ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(1));
d1428 2
a1429 1
	    ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(2));
d1435 2
a1436 1
	    ENABLE_TEX_STREAM_MAP_IDX | TEX_STREAM_MAP_IDX(3));
a1437 1
#if 0
d1445 2
a1446 1
	    MAG_FILTER(FILTER_NEAREST) | MIN_FILTER(FILTER_NEAREST));
d1454 2
a1455 1
	    MAG_FILTER(FILTER_NEAREST) | MIN_FILTER(FILTER_NEAREST));
d1463 2
a1464 1
	    MAG_FILTER(FILTER_NEAREST) | MIN_FILTER(FILTER_NEAREST));
d1472 2
a1473 1
	    MAG_FILTER(FILTER_NEAREST) | MIN_FILTER(FILTER_NEAREST));
d1481 5
a1485 3
	    MAP_INFO_FORMAT_2D | MAP_INFO_USE_FENCE);
   OUT_RING(MAP_INFO_HEIGHT(0) | MAP_INFO_WIDTH(0));
   OUT_RING(MAP_INFO_BASEADDR(pI830->TexMem.Start));
d1495 5
a1499 3
	    MAP_INFO_FORMAT_2D | MAP_INFO_USE_FENCE);
   OUT_RING(MAP_INFO_HEIGHT(0) | MAP_INFO_WIDTH(0));
   OUT_RING(MAP_INFO_BASEADDR(pI830->TexMem.Start));
d1509 5
a1513 3
	    MAP_INFO_FORMAT_2D | MAP_INFO_USE_FENCE);
   OUT_RING(MAP_INFO_HEIGHT(0) | MAP_INFO_WIDTH(0));
   OUT_RING(MAP_INFO_BASEADDR(pI830->TexMem.Start));
d1523 5
a1527 3
	    MAP_INFO_FORMAT_2D | MAP_INFO_USE_FENCE);
   OUT_RING(MAP_INFO_HEIGHT(0) | MAP_INFO_WIDTH(0));
   OUT_RING(MAP_INFO_BASEADDR(pI830->TexMem.Start));
d1532 3
a1534 1
	    MAP_UNIT(0) | ENABLE_TEXLOD_BIAS | MAP_LOD_BIAS(0));
d1536 3
a1538 1
	    MAP_UNIT(1) | ENABLE_TEXLOD_BIAS | MAP_LOD_BIAS(0));
d1540 3
a1542 1
	    MAP_UNIT(2) | ENABLE_TEXLOD_BIAS | MAP_LOD_BIAS(0));
d1544 3
a1546 1
	    MAP_UNIT(3) | ENABLE_TEXLOD_BIAS | MAP_LOD_BIAS(0));
d1551 3
a1553 1
	    ENABLE_MIN_MIP_LVL | LOD_MAX(0) | LOD_MIN(0));
d1557 3
a1559 1
	    ENABLE_MIN_MIP_LVL | LOD_MAX(0) | LOD_MIN(0));
d1563 3
a1565 1
	    ENABLE_MIN_MIP_LVL | LOD_MAX(0) | LOD_MIN(0));
d1569 3
a1571 2
	    ENABLE_MIN_MIP_LVL | LOD_MAX(0) | LOD_MIN(0));
#endif 
d1589 2
a1590 1
	    SRC_BLND_FACT(BLENDFACT_ONE) | DST_BLND_FACT(BLENDFACT_ZERO));
d1596 2
a1597 1
	    ALPHA_TEST_FUNC(COMPAREFUNC_ALWAYS) | ALPHA_REF_VALUE(0));
d1610 2
a1611 1
	    ENABLE_CULL_MODE | CULLMODE_NONE);
d1618 2
a1619 1
	    ENABLE_STENCIL_WRITE_MASK | STENCIL_WRITE_MASK(0xff));
d1628 2
a1629 1
	    ENABLE_FIXED_POINT_WIDTH | FIXED_POINT_WIDTH(1));
d1638 2
a1639 1
	    TRI_FAN_PROVOKE_VRTX(2) | TRI_STRIP_PROVOKE_VRTX(2));
d1641 2
a1642 1
   OUT_RING(STATE3D_SCISSOR_ENABLE_CMD | DISABLE_SCISSOR_RECT);
d1655 2
a1656 1
	    ENABLE_STENCIL_REF_VALUE | STENCIL_REF_VALUE(0));
d1671 2
a1672 1
   OUT_RING(DISABLE_VIEWPORT_TRANSFORM | DISABLE_PERSPECTIVE_DIVIDE);
d1676 1
a1676 6
   OUT_RING(0x3f800000 /* 1.0 in IEEE float */ );

#define GFX_OP_STIPPLE           ((0x3<<29)|(0x1d<<24)|(0x83<<16))

   OUT_RING(GFX_OP_STIPPLE);
   OUT_RING(0);
a1679 181

/* Fullscreen hooks.  The DRI fullscreen mode can probably be removed
 * as it adds little or nothing above the mechanism below.  (and isn't
 * widely used)
 */
static Bool
I830DRIOpenFullScreen(ScreenPtr pScreen)
{
  return TRUE;
}

static Bool
I830DRICloseFullScreen(ScreenPtr pScreen)
{
  return TRUE;
}



/* Use callbacks from dri.c to support pageflipping mode for a single
 * 3d context without need for any specific full-screen extension.
 *
 * Also see tdfx driver for example of using these callbacks to
 * allocate and free 3d-specific memory on demand.
 */





/* Use the miext/shadow module to maintain a list of dirty rectangles.
 * These are blitted to the back buffer to keep both buffers clean
 * during page-flipping when the 3d application isn't fullscreen.
 *
 * Unlike most use of the shadow code, both buffers are in video
 * memory.
 *
 * An alternative to this would be to organize for all on-screen
 * drawing operations to be duplicated for the two buffers.  That
 * might be faster, but seems like a lot more work...
 */


/* This should be done *before* XAA syncs,
 * Otherwise will have to sync again???
 */
static void
I830DRIShadowUpdate (ScreenPtr pScreen, shadowBufPtr pBuf)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   RegionPtr damage = &pBuf->damage;
   int i, num =  REGION_NUM_RECTS(damage);
   BoxPtr pbox = REGION_RECTS(damage);
   I830SAREARec *pSAREAPriv = DRIGetSAREAPrivate(pScreen);
   int cmd, br13;

   /* Don't want to do this when no 3d is active and pages are
    * right-way-round :
    */
   if (!pSAREAPriv->pf_active && pSAREAPriv->pf_current_page == 0)
      return;

   br13 = (pScrn->displayWidth * pI830->cpp) | (0xcc << 16);

   if (pScrn->bitsPerPixel == 32) {
      cmd = (XY_SRC_COPY_BLT_CMD | XY_SRC_COPY_BLT_WRITE_ALPHA |
	     XY_SRC_COPY_BLT_WRITE_RGB);
      br13 |= 3 << 24;
   } else {
      cmd = (XY_SRC_COPY_BLT_CMD);
      br13 |= 1 << 24;
   }

   for (i = 0 ; i < num ; i++, pbox++) {
      BEGIN_LP_RING(8);
      OUT_RING(cmd);
      OUT_RING(br13);
      OUT_RING((pbox->y1 << 16) | pbox->x1);
      OUT_RING((pbox->y2 << 16) | pbox->x2);
      OUT_RING(pI830->BackBuffer.Start);
      OUT_RING((pbox->y1 << 16) | pbox->x1);
      OUT_RING(br13 & 0xffff);
      OUT_RING(pI830->FrontBuffer.Start);
      ADVANCE_LP_RING();
   }
}


static void
I830EnablePageFlip(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   I830SAREARec *pSAREAPriv = DRIGetSAREAPrivate(pScreen);

   pSAREAPriv->pf_enabled = pI830->allowPageFlip;
   pSAREAPriv->pf_active = 0;

   if (pI830->allowPageFlip) {
      int br13 = (pScrn->displayWidth * pI830->cpp) | (0xcc << 16);

      BEGIN_LP_RING(8);
      if (pScrn->bitsPerPixel == 32) {
	 OUT_RING(XY_SRC_COPY_BLT_CMD | XY_SRC_COPY_BLT_WRITE_ALPHA |
		  XY_SRC_COPY_BLT_WRITE_RGB);
	 br13 |= 3 << 24;
      } else {
	 OUT_RING(XY_SRC_COPY_BLT_CMD);
	 br13 |= 1 << 24;
      }

      OUT_RING(br13);
      OUT_RING(0);
      OUT_RING((pScrn->virtualY << 16) | pScrn->virtualX);
      OUT_RING(pI830->BackBuffer.Start);
      OUT_RING(0);
      OUT_RING(br13 & 0xffff);
      OUT_RING(pI830->FrontBuffer.Start);
      ADVANCE_LP_RING();

      pSAREAPriv->pf_active = 1;
   }
}

static void
I830DisablePageFlip(ScreenPtr pScreen)
{
   I830SAREARec *pSAREAPriv = DRIGetSAREAPrivate(pScreen);

   pSAREAPriv->pf_active = 0;
}


static void
I830DRITransitionSingleToMulti3d(ScreenPtr pScreen)
{
   /* Tell the clients not to pageflip.  How?
    *   -- Field in sarea, plus bumping the window counters.
    *   -- DRM needs to cope with Front-to-Back swapbuffers.
    */
   I830DisablePageFlip(pScreen);
}

static void
I830DRITransitionMultiToSingle3d(ScreenPtr pScreen)
{
   /* Let the remaining 3d app start page flipping again.
    */
   I830EnablePageFlip(pScreen);
}


static void
I830DRITransitionTo3d(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);

   I830EnablePageFlip(pScreen);
   pI830->have3DWindows = 1;
}


static void
I830DRITransitionTo2d(ScreenPtr pScreen)
{
   ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
   I830Ptr pI830 = I830PTR(pScrn);
   I830SAREARec *sPriv = (I830SAREARec *) DRIGetSAREAPrivate(pScreen);

   /* Shut down shadowing if we've made it back to the front page:
    */
   if (sPriv->pf_current_page == 0) {
      I830DisablePageFlip(pScreen);
   }

   pI830->have3DWindows = 0;
}


@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/i810/i830_dri.c,v 1.16 2003/09/28 20:15:58 alanh Exp $ */
d45 1
a45 1
 *          David Dawes <dawes@@xfree86.org>
d252 1
a252 1
		  pConfigs[i].accumAlphaSize = 0;
d273 1
a273 1
		  pConfigs[i].visualRating = GLX_SLOW_CONFIG;
d275 2
a276 2
		  pConfigs[i].visualRating = GLX_NONE;
	       pConfigs[i].transparentPixel = GLX_NONE;
d327 1
a327 1
	       pConfigs[i].alphaSize = 8;
d331 1
a331 1
	       pConfigs[i].alphaMask = 0xFF000000;;
d336 1
a336 1
		  pConfigs[i].accumAlphaSize = 16;
d349 1
a349 1
	       pConfigs[i].bufferSize = 32;
d360 1
a360 1
		  pConfigs[i].visualRating = GLX_SLOW_CONFIG;
d362 1
a362 1
		  pConfigs[i].visualRating = GLX_NONE;
d364 1
a364 1
	       pConfigs[i].transparentPixel = GLX_NONE;
a759 1
   I830DRIPtr pI830DRI = (I830DRIPtr) pI830->pDRIInfo->devPrivate;
a762 5
   if (pI830DRI->irq) {
       drmCtlUninstHandler(pI830->drmSubFD);
       pI830DRI->irq = 0;
   }

a825 3
   if (!pScrn->vtSema)
      return;

d1458 1
a1458 5
   OUT_RING(STATE3D_VERTEX_FORMAT_CMD |
	    VRTX_TEX_COORD_COUNT(1) |
	    VRTX_HAS_SPEC |
	    VRTX_HAS_DIFFUSE |
	    VRTX_HAS_XYZW);
@


