head	1.2;
access;
symbols
	tg-mergetmp-2:1.2
	cvs-200410241530:1.1.1.4
	cvs-200410012000:1.1.1.4
	cvs-200407221130:1.1.1.4
	cvs-200407141120:1.1.1.4
	cvs-200406231010:1.1.1.4
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.4
	XFree86_4_4_0:1.1.9.2
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.03.07.18.37.47;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.20.07.34;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.07.34;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.36.43;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.19.57;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.27.16.33.19;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.23.57;	author tg;	state Exp;
branches;
next	1.1.9.2;

1.1.9.2
date	2004.03.05.22.30.20;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@semi-automagic merge of these files (ie, I've skipped through the diffs,
and most of that was done by cvs or that weird script of some minutes ago)
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_vga.c,v 1.46 2004/02/26 15:07:02 twini Exp $ */
/*
 * Mode setup and basic video bridge detection
 *
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author: 	Thomas Winischhofer <thomas@@winischhofer.net>
 *
 * Init() function for old series (except for TV and FIFO calculation)
 * previously based on code which is Copyright (C) 1998,1999 by Alan
 * Hourihane, Wigan, England
 */

#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86_ansic.h"
#include "xf86Version.h"
#include "xf86PciInfo.h"
#include "xf86Pci.h"

#include "sis.h"
#include "sis_regs.h"
#include "sis_dac.h"

static Bool  SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode);
static Bool  SIS300Init(ScrnInfoPtr pScrn, DisplayModePtr mode);
static int   SISDoSense(ScrnInfoPtr pScrn, unsigned short type, unsigned short test);
static void  SISSense30x(ScrnInfoPtr pScrn);
static int   SIS6326DoSense(ScrnInfoPtr pScrn, int tempbh, int tempbl, int tempch, int tempcl);
static void  SISSense6326(ScrnInfoPtr pScrn);
static void  SiS6326TVDelay(ScrnInfoPtr pScrn, int delay);

const CARD8 SiS6326TVRegs1[14] = {
     0x00,0x01,0x02,0x03,0x04,0x11,0x12,0x13,0x21,0x26,0x27,0x3a,0x3c,0x43
};

const CARD8 SiS6326TVRegs1_NTSC[6][14] = {
    {0x81,0x3f,0x49,0x1b,0xa9,0x03,0x00,0x09,0x08,0x7d,0x00,0x88,0x30,0x60},
    {0x81,0x3f,0x49,0x1d,0xa0,0x03,0x00,0x09,0x08,0x7d,0x00,0x88,0x30,0x60},
    {0x81,0x45,0x24,0x8e,0x26,0x0b,0x00,0x09,0x02,0xfe,0x00,0x09,0x51,0x60},
    {0x81,0x45,0x24,0x8e,0x26,0x07,0x00,0x29,0x04,0x30,0x10,0x3b,0x61,0x60},
    {0x81,0x3f,0x24,0x8e,0x26,0x09,0x00,0x09,0x02,0x30,0x10,0x3b,0x51,0x60},  /* 640x400, 640x480 */
    {0x83,0x5d,0x21,0xbe,0x75,0x03,0x00,0x09,0x08,0x42,0x10,0x4d,0x61,0x79}   /* 640x480u */
};

const CARD8 SiS6326TVRegs2_NTSC[6][54] = {
    {0x11, 0x17, 0x03, 0x09, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
     0x0C, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xFC, 0xDF, 0x94, 0x1F, 0x4A, 0x03, 0x71, 0x07, 0x97, 0x10, 0x40,
     0x48, 0x00, 0x26, 0xB6, 0x10, 0x5C, 0xEC, 0x21, 0x2E, 0xBE, 0x10,
     0x64, 0xF4, 0x21, 0x13, 0x75, 0x08, 0x31, 0x6A, 0x01, 0xA0},
    {0x11, 0x17, 0x03, 0x0A, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
     0x0D, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xFF, 0xDF, 0x94, 0x1F, 0x4A, 0x03, 0x71, 0x07, 0x97, 0x10, 0x40,
     0x48, 0x00, 0x26, 0xB6, 0x10, 0x5C, 0xEC, 0x21, 0x2E, 0xBE, 0x10,
     0x64, 0xF4, 0x21, 0x13, 0x75, 0x08, 0x31, 0x6A, 0x01, 0xA0},
    {0x11, 0x17, 0x03, 0x0A, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
     0x0D, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xFF, 0xDF, 0x94, 0x3F, 0x8C, 0x06, 0xCE, 0x07, 0x27, 0x30, 0x73,
     0x7B, 0x00, 0x48, 0x68, 0x30, 0xB2, 0xD2, 0x52, 0x50, 0x70, 0x30,
     0xBA, 0xDA, 0x52, 0xDC, 0x02, 0xD1, 0x53, 0xF7, 0x02, 0xA0},
    {0x11, 0x17, 0x03, 0x09, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
     0x0C, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xDC, 0xDF, 0x94, 0x3F, 0x8C, 0x06, 0xCE, 0x07, 0x27, 0x30, 0x73,
     0x7B, 0x00, 0x48, 0x68, 0x30, 0xB2, 0xD2, 0x52, 0x50, 0x70, 0x30,
     0xBA, 0xDA, 0x52, 0x00, 0x02, 0xF5, 0x53, 0xF7, 0x02, 0xA0},
    {0x11, 0x17, 0x03, 0x09, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
     0x0C, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xDC, 0xDF, 0x94, 0x3F, 0x8C, 0x06, 0xCE, 0x07, 0x27, 0x30, 0x73,
     0x7B, 0x00, 0x48, 0x68, 0x30, 0xB2, 0xD2, 0x52, 0x50, 0x70, 0x30,
     0xBA, 0xDA, 0x52, 0xDC, 0x02, 0xD1, 0x53, 0xF7, 0x02, 0xA0},
    {0x11, 0x17, 0x03, 0x09, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,  /* 640x480u */
     0x0C, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xDC, 0xDF, 0x94, 0xAF, 0x95, 0x06, 0xDD, 0x07, 0x5F, 0x30, 0x7E,
     0x86, 0x00, 0x4C, 0xA4, 0x30, 0xE3, 0x3B, 0x62, 0x54, 0xAC, 0x30,
     0xEB, 0x43, 0x62, 0x48, 0x34, 0x3D, 0x63, 0x29, 0x03, 0xA0}
};

const CARD8 SiS6326TVRegs1_PAL[6][14] = {
    {0x81,0x2d,0xc8,0x07,0xb2,0x0b,0x00,0x09,0x02,0xed,0x00,0xf8,0x30,0x40},
    {0x80,0x2d,0xa4,0x03,0xd9,0x0b,0x00,0x09,0x02,0xed,0x10,0xf8,0x71,0x40},
    {0x81,0x2d,0xa4,0x03,0xd9,0x0b,0x00,0x09,0x02,0xed,0x10,0xf8,0x71,0x40},  /* 640x480 */
    {0x81,0x2d,0xa4,0x03,0xd9,0x0b,0x00,0x09,0x02,0x8f,0x10,0x9a,0x71,0x40},  /* 800x600 */
    {0x83,0x63,0xa1,0x7a,0xa3,0x0a,0x00,0x09,0x02,0xb5,0x11,0xc0,0x81,0x59},  /* 800x600u */
    {0x81,0x63,0xa4,0x03,0xd9,0x01,0x00,0x09,0x10,0x9f,0x10,0xaa,0x71,0x59}   /* 720x540  */
};

const CARD8 SiS6326TVRegs2_PAL[6][54] = {
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0xEF, 0x5A, 0x03, 0x7F, 0x07, 0xFF, 0x10, 0x4E,
     0x56, 0x00, 0x2B, 0x23, 0x20, 0xB4, 0xAC, 0x31, 0x33, 0x2B, 0x20,
     0xBC, 0xB4, 0x31, 0x83, 0xE1, 0x78, 0x31, 0xD6, 0x01, 0xA0},
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0xDF, 0xB2, 0x07, 0xFB, 0x07, 0xF7, 0x30, 0x90,
     0x98, 0x00, 0x4F, 0x3F, 0x40, 0x62, 0x52, 0x73, 0x57, 0x47, 0x40,
     0x6A, 0x5A, 0x73, 0x03, 0xC1, 0xF8, 0x63, 0xB6, 0x03, 0xA0},
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,  /* 640x480 */
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0xDF, 0xB2, 0x07, 0xFB, 0x07, 0xF7, 0x30, 0x90,
     0x98, 0x00, 0x4F, 0x3F, 0x40, 0x62, 0x52, 0x73, 0x57, 0x47, 0x40,
     0x6A, 0x5A, 0x73, 0x03, 0xC1, 0xF8, 0x63, 0xB6, 0x03, 0xA0},
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,  /* 800x600 */
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0xDF, 0xB2, 0x07, 0xFB, 0x07, 0xF7, 0x30, 0x90,
     0x98, 0x00, 0x4F, 0x3F, 0x40, 0x62, 0x52, 0x73, 0x57, 0x47, 0x40,
     0x6A, 0x5A, 0x73, 0xA0, 0xC1, 0x95, 0x73, 0xB6, 0x03, 0xA0},
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,  /* 800x600u */
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0x7F, 0xBD, 0x08, 0x0E, 0x07, 0x47, 0x40, 0x9D,
     0xA5, 0x00, 0x54, 0x94, 0x40, 0xA4, 0xE4, 0x73, 0x5C, 0x9C, 0x40,
     0xAC, 0xEC, 0x73, 0x0B, 0x0E, 0x00, 0x84, 0x03, 0x04, 0xA0},
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,  /* 720x540  */
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0xDF, 0xB0, 0x07, 0xFB, 0x07, 0xF7, 0x30, 0x9D,
     0xA5, 0x00, 0x4F, 0x3F, 0x40, 0x62, 0x52, 0x73, 0x57, 0x47, 0x40,
     0x6A, 0x5A, 0x73, 0xA0, 0xC1, 0x95, 0x73, 0xB6, 0x03, 0xA0}
};

const CARD8 SiS6326CR[9][15] = {
     {0x79,0x63,0x64,0x1d,0x6a,0x93,0x00,0x6f,0xf0,0x58,0x8a,0x57,0x57,0x70,0x20},  /* PAL 800x600   */
     {0x79,0x4f,0x50,0x95,0x60,0x93,0x00,0x6f,0xba,0x14,0x86,0xdf,0xe0,0x30,0x00},  /* PAL 640x480   */
     {0x5f,0x4f,0x50,0x82,0x53,0x9f,0x00,0x0b,0x3e,0xe9,0x8b,0xdf,0xe7,0x04,0x00},  /* NTSC 640x480  */
     {0x5f,0x4f,0x50,0x82,0x53,0x9f,0x00,0x0b,0x3e,0xcb,0x8d,0x8f,0x96,0xe9,0x00},  /* NTSC 640x400  */
     {0x83,0x63,0x64,0x1f,0x6d,0x9b,0x00,0x6f,0xf0,0x48,0x0a,0x23,0x57,0x70,0x20},  /* PAL 800x600u  */
     {0x79,0x59,0x5b,0x1d,0x66,0x93,0x00,0x6f,0xf0,0x42,0x04,0x1b,0x40,0x70,0x20},  /* PAL 720x540   */
     {0x66,0x4f,0x51,0x0a,0x57,0x89,0x00,0x0b,0x3e,0xd9,0x0b,0xb6,0xe7,0x04,0x00},  /* NTSC 640x480u */
     {0xce,0x9f,0x9f,0x92,0xa4,0x16,0x00,0x28,0x5a,0x00,0x04,0xff,0xff,0x29,0x39},  /* 1280x1024-75  */
     {0x09,0xc7,0xc7,0x0d,0xd2,0x0a,0x01,0xe0,0x10,0xb0,0x04,0xaf,0xaf,0xe1,0x1f}   /* 1600x1200-60  */
};

/* Initialize a display mode on 5597/5598, 6326 and 530/620 */
static Bool
SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    SISPtr         pSiS = SISPTR(pScrn);
    SISRegPtr      pReg = &pSiS->ModeReg;
    vgaRegPtr      vgaReg = &VGAHWPTR(pScrn)->ModeReg;
    unsigned char  temp;
    int            mclk = pSiS->MemClock;
    int            offset;
    int            clock = mode->Clock;
    int            width = mode->HDisplay;
    int            height = mode->VDisplay;
    int            rate = SiSCalcVRate(mode);
    int            buswidth = pSiS->BusWidth;
    unsigned int   vclk[5];
    unsigned short CRT_CPUthresholdLow;
    unsigned short CRT_CPUthresholdHigh;
    unsigned short CRT_ENGthreshold;
    double         a, b, c;
    int            d, factor;
    int            num, denum, div, sbit, scale;
    BOOL	   sis6326tvmode, sis6326himode;

    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3, "SISInit()\n"));

    /* Save the registers for further processing */
    (*pSiS->SiSSave)(pScrn, pReg);

    /* Determine if chosen mode is suitable for TV on the 6326
     * and if the mode is one of our special hi-res modes.
     */
    sis6326tvmode = FALSE;
    sis6326himode = FALSE;
    if(pSiS->Chipset == PCI_CHIP_SIS6326) {
       if(pSiS->SiS6326Flags & SIS6326_HASTV) {
          if((pSiS->SiS6326Flags & SIS6326_TVDETECTED) &&
             ((strcmp(mode->name, "PAL800x600") == 0)   ||	/* Special TV modes */
              (strcmp(mode->name, "PAL800x600U") == 0)  ||
	      (strcmp(mode->name, "PAL720x540") == 0)   ||
              (strcmp(mode->name, "PAL640x480") == 0)   ||
	      (strcmp(mode->name, "NTSC640x480") == 0)  ||
	      (strcmp(mode->name, "NTSC640x480U") == 0) ||
	      (strcmp(mode->name, "NTSC640x400") == 0))) {
	     sis6326tvmode = TRUE;
          } else {
             pReg->sis6326tv[0x00] &= 0xfb;
          }
       }
       if((strcmp(mode->name, "SIS1280x1024-75") == 0) ||	/* Special high-res modes */
          (strcmp(mode->name, "SIS1600x1200-60") == 0)) {
	  sis6326himode = TRUE;
       }
    }

#ifdef UNLOCK_ALWAYS
    outSISIDXREG(SISSR, 0x05, 0x86);
#endif

    if(!pSiS->UseVESA) {
       pReg->sisRegs3C4[0x06] &= 0x01;
    }

    /* set interlace */
    if(!(mode->Flags & V_INTERLACE))  {
       offset = pSiS->CurrentLayout.displayWidth >> 3;
    } else  {
       offset = pSiS->CurrentLayout.displayWidth >> 2;
       if(!pSiS->UseVESA) {
          pReg->sisRegs3C4[0x06] |= 0x20;
       }
    }

    /* Enable Linear and Enhanced Gfx Mode */
    if(!pSiS->UseVESA) {
       pReg->sisRegs3C4[0x06] |= 0x82;
    }

    /* Enable MMIO at PCI Register 14H (D[6:5]: 11) */
    if(pSiS->oldChipset >= OC_SIS5597) {
       pReg->sisRegs3C4[0x0B] |= 0x60;
    } else {
       pReg->sisRegs3C4[0x0B] |= 0x20;
       pReg->sisRegs3C4[0x0B] &= ~0x40;
    }

    if(!pSiS->UseVESA) {

       /* Enable 32bit mem access (D7), read-ahead cache (D5) */
       pReg->sisRegs3C4[0x0C] |= 0x80;
       if(pSiS->oldChipset > OC_SIS6225) {
          pReg->sisRegs3C4[0x0C] |= 0x20;
       }

       /* Some speed-up stuff */
       switch(pSiS->Chipset) {
       case PCI_CHIP_SIS5597:
          /* enable host bus */
	  if(pSiS->NoHostBus) {
	     pReg->sisRegs3C4[0x34] &= ~0x08;
	  } else {
            pReg->sisRegs3C4[0x34] |= 0x08;
	  }
          /* fall through */
       case PCI_CHIP_SIS6326:
       case PCI_CHIP_SIS530:
          /* Enable "dual segment register mode" (D2) and "i/o gating while
           * write buffer is not empty" (D3)
           */
    	  pReg->sisRegs3C4[0x0B] |= 0x0C;
       }

       /* set colordepth */
       if(pSiS->Chipset == PCI_CHIP_SIS530) {
          pReg->sisRegs3C4[0x09] &= 0x7F;
       }
       switch(pSiS->CurrentLayout.bitsPerPixel) {
          case 8:
             break;
          case 16:
	     offset <<= 1;
	     if(pSiS->CurrentLayout.depth == 15)
	        pReg->sisRegs3C4[0x06] |= 0x04;
	     else
                pReg->sisRegs3C4[0x06] |= 0x08;
             break;
          case 24:
             offset += (offset << 1);
             pReg->sisRegs3C4[0x06] |= 0x10;
             pReg->sisRegs3C4[0x0B] |= 0x90;
             break;
          case 32:
             if(pSiS->Chipset == PCI_CHIP_SIS530) {
	        offset <<= 2;
	        if(pSiS->oldChipset != OC_SIS620) {
                   pReg->sisRegs3C4[0x06] |= 0x10;
	        }
                pReg->sisRegs3C4[0x0B] |= 0x90;
                pReg->sisRegs3C4[0x09] |= 0x80;
             } else return FALSE;
             break;
       }
    }

    /* save screen pitch for acceleration functions */
    pSiS->scrnOffset = pSiS->CurrentLayout.displayWidth *
                           ((pSiS->CurrentLayout.bitsPerPixel + 7) / 8);

    if(!pSiS->UseVESA) {

       /* set linear framebuffer addresses */
       switch(pScrn->videoRam)  {
          case 512:  temp = 0x00;  break;
          case 1024: temp = 0x20;  break;
          case 2048: temp = 0x40;  break;
          case 4096: temp = 0x60;  break;
          case 8192: temp = 0x80;  break;
          default:   temp = 0x20;
       }
       pReg->sisRegs3C4[0x20] = (pSiS->FbAddress & 0x07F80000) >> 19;
       pReg->sisRegs3C4[0x21] = ((pSiS->FbAddress & 0xF8000000) >> 27) | temp;

       /* Set screen offset */
       vgaReg->CRTC[0x13] = offset & 0xFF;

       /* Set CR registers for our built-in TV and hi-res modes */
       if((sis6326tvmode) || (sis6326himode)) {

	  int index,i;

	  /* We need our very private data for hi-res and TV modes */
	  if(sis6326himode) {
	     if(strcmp(mode->name, "SIS1280x1024-75") == 0)  index = 7;
	     else index = 8;
	  } else {
	     if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
	        switch(width) {
	        case 800:
	           if((strcmp(mode->name, "PAL800x600U") == 0))
	      	      index = 4;
	           else
	              index = 0;
	           break;
	        case 720:
	           index = 5;
	           break;
	        case 640:
	        default:
	           index = 1;
	        }
	     } else {
	        switch(height) {
	        case 400:
	           index = 3;
	           break;
	        case 480:
	        default:
	           if((strcmp(mode->name, "NTSC640x480U") == 0))
	              index = 6;
	           else
	              index = 2;
	        }
	     }
          }
	  for(i=0; i<=5; i++) {
	     vgaReg->CRTC[i] = SiS6326CR[index][i];
	  }
          pReg->sisRegs3C4[0x12] = SiS6326CR[index][6];
	  vgaReg->CRTC[6] = SiS6326CR[index][7];
	  vgaReg->CRTC[7] = SiS6326CR[index][8];
	  vgaReg->CRTC[0x10] = SiS6326CR[index][9];
	  vgaReg->CRTC[0x11] = SiS6326CR[index][10];
	  vgaReg->CRTC[0x12] = SiS6326CR[index][11];
	  vgaReg->CRTC[0x15] = SiS6326CR[index][12];
	  vgaReg->CRTC[0x16] = SiS6326CR[index][13];
	  vgaReg->CRTC[9] &= ~0x20;
	  vgaReg->CRTC[9] |= (SiS6326CR[index][14] & 0x20);
	  pReg->sisRegs3C4[0x0A] = ((offset & 0xF00) >> 4) | (SiS6326CR[index][14] & 0x0f);

       } else {

          /* Set extended vertical overflow register */
          pReg->sisRegs3C4[0x0A] = ((offset & 0xF00) >> 4) |
                 (((mode->CrtcVTotal-2)     & 0x400) >> 10 ) |
                 (((mode->CrtcVDisplay-1)   & 0x400) >>  9 ) |
/*               (((mode->CrtcVSyncStart-1) & 0x400) >>  8 ) |  */
	         (((mode->CrtcVBlankStart-1)& 0x400) >>  8 ) |
/*               (((mode->CrtcVBlankStart-1)& 0x400) >>  7 );  */
                 (((mode->CrtcVSyncStart)   & 0x400) >>  7 );

          /* Set extended horizontal overflow register */
          pReg->sisRegs3C4[0x12] &= 0xE0;
          pReg->sisRegs3C4[0x12] |= (
              (((mode->CrtcHTotal >> 3) - 5)      & 0x100) >> 8 |
              (((mode->CrtcHDisplay >> 3) - 1)    & 0x100) >> 7 |
/*            (((mode->CrtcHSyncStart >> 3) - 1)  & 0x100) >> 6 |  */
              (((mode->CrtcHBlankStart >> 3) - 1) & 0x100) >> 6 |
              ((mode->CrtcHSyncStart >> 3)        & 0x100) >> 5 |
              (((mode->CrtcHBlankEnd >> 3) - 1)   & 0x40)  >> 2);
       }

#ifdef TWDEBUG
       xf86DrvMsg(0, X_INFO, "HDisplay %d HSyncStart %d HSyncEnd %d HTotal %d\n",
		mode->CrtcHDisplay, mode->CrtcHSyncStart,
		mode->CrtcHSyncEnd, mode->CrtcHTotal);
       xf86DrvMsg(0, X_INFO, "HBlankSt %d  HBlankE %d\n",
    		mode->CrtcHBlankStart, mode->CrtcHBlankEnd);

       xf86DrvMsg(0, X_INFO, "VDisplay %d VSyncStart %d VSyncEnd %d VTotal %d\n",
		mode->CrtcVDisplay, mode->CrtcVSyncStart,
		mode->CrtcVSyncEnd, mode->CrtcVTotal);
       xf86DrvMsg(0, X_INFO, "VBlankSt %d  VBlankE %d\n",
    		mode->CrtcVBlankStart, mode->CrtcVBlankEnd);
#endif

       /* enable (or disable) line compare */
       if(mode->CrtcVDisplay >= 1024)
          pReg->sisRegs3C4[0x38] |= 0x04;
       else
          pReg->sisRegs3C4[0x38] &= 0xFB;

       /* Enable (or disable) high speed DCLK (some 6326 and 530/620 only) */
       if( ( (pSiS->Chipset == PCI_CHIP_SIS6326) &&
             ( (pSiS->ChipRev == 0xd0) || (pSiS->ChipRev == 0xd1) ||
               (pSiS->ChipRev == 0xd2) || (pSiS->ChipRev == 0x92) ||
	       (pSiS->Flags & A6326REVAB) ) ) ||
           (pSiS->oldChipset > OC_SIS6326) ) {
         if( (pSiS->CurrentLayout.bitsPerPixel == 24) ||
             (pSiS->CurrentLayout.bitsPerPixel == 32) ||
             (mode->CrtcHDisplay >= 1280) )
            pReg->sisRegs3C4[0x3E] |= 0x01;
         else
            pReg->sisRegs3C4[0x3E] &= 0xFE;
       }

       /* We use the internal VCLK */
       pReg->sisRegs3C4[0x38] &= 0xFC;

       /* Programmable Clock */
       pReg->sisRegs3C2 = inb(SISMISCR) | 0x0C;

       if(pSiS->oldChipset <= OC_SIS86202) {
          /* TODO: Handle SR07 for clock selection */
	  /* 86C201 does not even have a programmable clock... */
	  /* pReg->sisRegs3C4[0x07] &= 0x??; */
       }

       /* Set VCLK */
       if((sis6326tvmode) || (sis6326himode)) {

          /* For our built-in modes, the calculation is not suitable */
          if(sis6326himode) {
             if((strcmp(mode->name, "SIS1280x1024-75") == 0)) {
	        pReg->sisRegs3C4[0x2A] = 0x5d;	/* 1280x1024-75 */
                pReg->sisRegs3C4[0x2B] = 0xa4;
             } else {
	        pReg->sisRegs3C4[0x2A] = 0x59;	/* 1600x1200-60 */
                pReg->sisRegs3C4[0x2B] = 0xa3;
             }
	     pReg->sisRegs3C4[0x13] &= ~0x40;
          } else {
             if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
	        /* PAL: 31.500 Mhz */
	        if((strcmp(mode->name, "PAL800x600U") == 0)) {
   	           pReg->sisRegs3C4[0x2A] = 0x46;
                   pReg->sisRegs3C4[0x2B] = 0x49;
	        } else {
	           pReg->sisRegs3C4[0x2A] = 0xab;
                   pReg->sisRegs3C4[0x2B] = 0xe9;
	        }
	        pReg->sisRegs3C4[0x13] &= ~0x40;
	     } else {
	        /* NTSC: 27.000 Mhz */
	        if((strcmp(mode->name, "NTSC640x480U") == 0)) {
	           pReg->sisRegs3C4[0x2A] = 0x5a;
                   pReg->sisRegs3C4[0x2B] = 0x65;
	        } else {
	           pReg->sisRegs3C4[0x2A] = 0x29;
                   pReg->sisRegs3C4[0x2B] = 0xe2;
	        }
	        pReg->sisRegs3C4[0x13] |= 0x40;
	     }
          }

       } else if(SiS_compute_vclk(clock, &num, &denum, &div, &sbit, &scale)) {

          pReg->sisRegs3C4[0x2A] = (num - 1) & 0x7f ;
          pReg->sisRegs3C4[0x2A] |= (div == 2) ? 0x80 : 0;
          pReg->sisRegs3C4[0x2B] = ((denum - 1) & 0x1f);
          pReg->sisRegs3C4[0x2B] |= (((scale -1) & 3) << 5);

	  /* When setting VCLK, we should set SR13 first */
          if(sbit)
             pReg->sisRegs3C4[0x13] |= 0x40;
          else
             pReg->sisRegs3C4[0x13] &= 0xBF;

#ifdef TWDEBUG
	  xf86DrvMsg(0, X_INFO, "2a: %x 2b: %x 13: %x clock %d\n",
		pReg->sisRegs3C4[0x2A], pReg->sisRegs3C4[0x2B], pReg->sisRegs3C4[0x13], clock);
#endif

       } else {

          /* if SiS_compute_vclk cannot handle the requested clock, try sisCalcClock */
          SiSCalcClock(pScrn, clock, 2, vclk);

#define Midx    0
#define Nidx    1
#define VLDidx  2
#define Pidx    3
#define PSNidx  4	  

          pReg->sisRegs3C4[0x2A] = (vclk[Midx] - 1) & 0x7f;
          pReg->sisRegs3C4[0x2A] |= ((vclk[VLDidx] == 2) ? 1 : 0) << 7;

	  /* bits [4:0] contain denumerator */
          pReg->sisRegs3C4[0x2B] = (vclk[Nidx] - 1) & 0x1f;

          if(vclk[Pidx] <= 4){
             /* postscale 1,2,3,4 */
             pReg->sisRegs3C4[0x2B] |= (vclk[Pidx] - 1) << 5;
             pReg->sisRegs3C4[0x13] &= 0xBF;
          } else {
             /* postscale 6,8 */
             pReg->sisRegs3C4[0x2B] |= ((vclk[Pidx] / 2) - 1) << 5;
             pReg->sisRegs3C4[0x13] |= 0x40;
          }
          pReg->sisRegs3C4[0x2B] |= 0x80 ;   /* gain for high frequency */

       }

       /* High speed DAC */
       if(clock > 135000)
          pReg->sisRegs3C4[0x07] |= 0x02;

       if(pSiS->oldChipset > OC_SIS6225) {
          /* 1 or 2 cycle DRAM (set by option FastVram) */
          if(pSiS->newFastVram == -1) {
             if(pSiS->oldChipset == OC_SIS620) {
	        /* Use different default on the 620 */
                pReg->sisRegs3C4[0x34] |= 0x40;
	        pReg->sisRegs3C4[0x34] &= ~0x80;
             } else {
                pReg->sisRegs3C4[0x34] |= 0x80;
	        pReg->sisRegs3C4[0x34] &= ~0x40;
             }
          } else if(pSiS->newFastVram == 1)
             pReg->sisRegs3C4[0x34] |= 0xC0;
          else
             pReg->sisRegs3C4[0x34] &= ~0xC0;

          if(pSiS->oldChipset == OC_SIS620) {
             /* Enable SGRAM burst timing (= bit clear) on the 620 */
             if(pSiS->Flags & SYNCDRAM) {
                pReg->sisRegs3C4[0x35] &= ~0x20;
             } else {
                pReg->sisRegs3C4[0x35] |= 0x20;
             }
          }
       }

    } /* VESA */

    /* Logical line length */
    pSiS->ValidWidth = TRUE;
    pReg->sisRegs3C4[0x27] &= 0xCF;
    if(pSiS->CurrentLayout.bitsPerPixel == 24) {
         /* Invalid logical width */
         pReg->sisRegs3C4[0x27] |= 0x30;
         pSiS->ValidWidth = FALSE;
    } else {
	 switch(pScrn->virtualX * (pSiS->CurrentLayout.bitsPerPixel >> 3)) {
         case 1024:
               pReg->sisRegs3C4[0x27] |= 0x00;
               break;
         case 2048:
               pReg->sisRegs3C4[0x27] |= 0x10;
               break;
         case 4096:
               pReg->sisRegs3C4[0x27] |= 0x20;
               break;
         default:
               /* Invalid logical width */
               pReg->sisRegs3C4[0x27] |= 0x30;
               pSiS->ValidWidth = FALSE;
               break;
         }
    }

    /* Acceleration stuff */
    if(!pSiS->NoAccel) {
       pReg->sisRegs3C4[0x27] |= 0x40;   /* Enable engine programming registers */
       if( (pSiS->TurboQueue) &&	 /* Handle TurboQueue */
           (pSiS->oldChipset > OC_SIS6225) &&
 	   ( (pSiS->Chipset != PCI_CHIP_SIS530) ||
	     (pSiS->CurrentLayout.bitsPerPixel != 24) ) ) {
          pReg->sisRegs3C4[0x27] |= 0x80;        /* Enable TQ */
	  if((pSiS->Chipset == PCI_CHIP_SIS530) ||
	     ((pSiS->Chipset == PCI_CHIP_SIS6326 &&
	      (pSiS->ChipRev == 0xd0 || pSiS->ChipRev == 0xd1 ||
	       pSiS->ChipRev == 0xd2 || pSiS->ChipRev == 0x92 ||
	       pSiS->ChipRev == 0x0a || pSiS->ChipRev == 0x1a ||
	       pSiS->ChipRev == 0x2a || pSiS->ChipRev == 0x0b ||
	       pSiS->ChipRev == 0x1b || pSiS->ChipRev == 0x2b) ) ) ) {
	     /* pReg->sisRegs3C4[0x3D] |= 0x80;  */     /* Queue is 62K (530/620 specs) */
	     pReg->sisRegs3C4[0x3D] &= 0x7F;         /* Queue is 30K (530/620 specs) */
	  }
	  /* Locate the TQ at the beginning of the last 64K block of
	   * video RAM. The address is to be specified in 32K steps.
	   */
	  pReg->sisRegs3C4[0x2C] = (pScrn->videoRam - 64) / 32;
	  if(pSiS->Chipset != PCI_CHIP_SIS530) {	/* 530/620: Reserved (don't touch) */
    	     pReg->sisRegs3C4[0x3C] &= 0xFC; 		/* 6326: Queue is all for 2D */
	  }						/* 5597: Must be 0           */
       } else {
	  pReg->sisRegs3C4[0x27] &= 0x7F;
       }
    }


    if(!pSiS->UseVESA) {

       /* TW: No idea what this does. The Windows driver does it, so we do it as well */
       if(pSiS->Chipset == PCI_CHIP_SIS6326) {
          if((pSiS->ChipRev == 0xd0) || (pSiS->ChipRev == 0xd1) ||
             (pSiS->ChipRev == 0xd2) || (pSiS->ChipRev == 0x92) ||
	     (pSiS->Flags & A6326REVAB)) {
	     if((pSiS->Flags & (SYNCDRAM | RAMFLAG)) == (SYNCDRAM | RAMFLAG)) {
	        if(!(pReg->sisRegs3C4[0x0E] & 0x03)) {
	           pReg->sisRegs3C4[0x3E] |= 0x02;
	        }
	     }
          }
       }

       /* Set memclock */
#if 0
       /* We don't need to do this; the SetMClk option was not used since 4.0. */
       if((pSiS->Chipset == PCI_CHIP_SIS5597) || (pSiS->Chipset == PCI_CHIP_SIS6326)) {
          if(pSiS->MemClock > 66000) {
             SiSCalcClock(pScrn, pSiS->MemClock, 1, vclk);

             pReg->sisRegs3C4[0x28] = (vclk[Midx] - 1) & 0x7f ;
             pReg->sisRegs3C4[0x28] |= ((vclk[VLDidx] == 2 ) ? 1 : 0 ) << 7 ;
             pReg->sisRegs3C4[0x29] = (vclk[Nidx] -1) & 0x1f ;   /* bits [4:0] contain denumerator -MC */
             if(vclk[Pidx] <= 4) {
                pReg->sisRegs3C4[0x29] |= (vclk[Pidx] - 1) << 5 ; /* postscale 1,2,3,4 */
                pReg->sisRegs3C4[0x13] &= 0x7F;
             } else {
                pReg->sisRegs3C4[0x29] |= ((vclk[Pidx] / 2) - 1) << 5 ;  /* postscale 6,8 */
                pReg->sisRegs3C4[0x13] |= 0x80;
             }
             /* Check programmed memory clock. Enable only to check the above code */
/*
             mclk = 14318 * ((pReg->sisRegs3C4[0x28] & 0x7f) + 1);
             mclk /= ((pReg->sisRegs3C4[0x29] & 0x0f) + 1);
             if(!(pReg->sisRegs3C4[0x13] & 0x80)) {
                mclk /= (((pReg->sisRegs3C4[0x29] & 0x60) >> 5) + 1);
             } else {
                if((pReg->sisRegs3C4[0x29] & 0x60) == 0x40) mclk /= 6;
                if((pReg->sisRegs3C4[0x29] & 0x60) == 0x60) mclk /= 8;
             }
             xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,2,
                 "Setting memory clock to %.3f MHz\n",
                 mclk/1000.0);
*/
          }
       }
#endif

       /* Set threshold values */
       /*
        * CPU/CRT Threshold:                     FIFO
        *                           MCLK     ___________      VCLK
        * cpu/engine <---o       o--------->|___________| -----------> CRT
        *                ^       ^            ^       ^
        *                 \     /             |       |
        *                  \   /              |< gap >|
        *                   \ /               |       |
        *           selector switch   Thrsh. low     high
        *
        * CRT consumes the data in the FIFO during scanline display. When the
        * amount of data in the FIFO reaches the Threshold low value, the selector
        * switch will switch to the right, and the FIFO will be refilled with data.
        * When the amount of data in the FIFO reaches the Threshold high value, the
        * selector switch will switch to the left and allows the CPU and the chip
        * engines to access the video RAM.
        *
        * The Threshold low values should be increased at higher bpps, simply because
        * there is more data needed for the CRT. When Threshold low and high are very
        * close to each other, the selector switch will be activated more often, which
        * decreases performance.
        *
        */
       switch(pSiS->Chipset) {
       case PCI_CHIP_SIS5597:  factor = 65; break;
       case PCI_CHIP_SIS6326:  factor = 30; break;
       case PCI_CHIP_SIS530:   factor = (pSiS->Flags & UMA) ? 60 : 30; break;
       default:                factor = (pScrn->videoRam > 1024) ? 24 : 12;
       }
       a = width * height * rate * 1.40 * factor * ((pSiS->CurrentLayout.bitsPerPixel + 1) / 8);
       b = (mclk / 1000) * 999488.0 * (buswidth / 8);
       c = ((a / b) + 1.0) / 2;
       d = (int)c + 2;

#ifdef TWDEBUG
       xf86DrvMsg(0, X_INFO,
          "Debug: w %d h %d r %d mclk %d bus %d factor %d bpp %d\n",
          width, height, rate, mclk/1000, buswidth, factor,
          pSiS->CurrentLayout.bitsPerPixel);
       xf86DrvMsg(0, X_INFO, "Debug: a %f b %f c %f d %d (flags %x)\n",
     	  a, b, c, d, pSiS->Flags);
#endif

       CRT_CPUthresholdLow = d;
       if((pSiS->Flags & (RAMFLAG | SYNCDRAM)) == (RAMFLAG | SYNCDRAM)) {
          CRT_CPUthresholdLow += 2;
       }
       CRT_CPUthresholdHigh = CRT_CPUthresholdLow + 3;

       CRT_ENGthreshold = 0x0F;

#ifdef TWDEBUG
       xf86DrvMsg(0, X_INFO, "Debug: Thlow %d thhigh %d\n",
     	  CRT_CPUthresholdLow, CRT_CPUthresholdHigh);
#endif

#if 0  /* See comment in sis_dac.c on why this is commented */
       if(pSiS->Chipset == PCI_CHIP_SIS530) {
          if((pSiS->oldChipset == OC_SIS530A) &&
	     (pSiS->Flags & UMA) &&
	     (mclk == 100000) &&
	     (pSiS->Flags & ESS137xPRESENT)) {
	       if(!(pSiS->Flags & SECRETFLAG)) index = 0;
               if((temp = SiS_CalcSpecial530Threshold(pSiS, mode, index)) {
	    	   CRT_CPUthresholdLow = temp;
	           break;
	       }
          }
       }
#endif

       switch(pSiS->Chipset) {
       case PCI_CHIP_SIS530:
          if(CRT_CPUthresholdLow > 0x1f)  CRT_CPUthresholdLow = 0x1f;
          CRT_CPUthresholdHigh = 0x1f;
          break;
       case PCI_CHIP_SIS5597:
       case PCI_CHIP_SIS6326:
       default:
          if(CRT_CPUthresholdLow > 0x0f)  CRT_CPUthresholdLow  = 0x0f;
          if(CRT_CPUthresholdHigh > 0x0f) CRT_CPUthresholdHigh = 0x0f;
       }

       pReg->sisRegs3C4[0x08] = ((CRT_CPUthresholdLow & 0x0F) << 4) |
	  		        (CRT_ENGthreshold & 0x0F);

       pReg->sisRegs3C4[0x09] &= 0xF0;
       pReg->sisRegs3C4[0x09] |= (CRT_CPUthresholdHigh & 0x0F);

       pReg->sisRegs3C4[0x3F] &= 0xEB;
       pReg->sisRegs3C4[0x3F] |= (CRT_CPUthresholdHigh & 0x10) |
                         	      ((CRT_CPUthresholdLow & 0x10) >> 2);

       if(pSiS->oldChipset >= OC_SIS530A) {
     	  pReg->sisRegs3C4[0x3F] &= 0xDF;
	  pReg->sisRegs3C4[0x3F] |= 0x58;
       }

       /* Set SiS6326 TV registers */
       if((pSiS->Chipset == PCI_CHIP_SIS6326) && (sis6326tvmode)) {
          unsigned char tmp;
          int index=0, i, j, k;
          int fsc;

          if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
             pReg->sisRegs3C4[0x0D] |= 0x04;
             switch(width) {
	     case 800:
	        if((strcmp(mode->name, "PAL800x600U") == 0))  index = 4;
	        else	        			      index = 3;
	        break;
	     case 720: index = 5;  break;
	     case 640:
	     default:  index = 2;
	     }
	     for(i=0; i<14; i++) {
	        pReg->sis6326tv[SiS6326TVRegs1[i]] = SiS6326TVRegs1_PAL[index][i];
	     }
             fsc = (SiS6326TVRegs1_PAL[index][2] << 16) |
	           (SiS6326TVRegs1_PAL[index][3] << 8)  |
	           (SiS6326TVRegs1_PAL[index][4]);
          } else {
	     pReg->sisRegs3C4[0x0D] &= ~0x04;
	     if((strcmp(mode->name, "NTSC640x480U") == 0))  index = 5;
	     else 					    index = 4;
             for(i=0; i<14; i++) {
	        pReg->sis6326tv[SiS6326TVRegs1[i]] = SiS6326TVRegs1_NTSC[index][i];
	     }
             fsc = (SiS6326TVRegs1_NTSC[index][2] << 16) |
	           (SiS6326TVRegs1_NTSC[index][3] << 8)  |
	           (SiS6326TVRegs1_NTSC[index][4]);
          }
          if(pSiS->sis6326fscadjust) {
	     fsc += pSiS->sis6326fscadjust;
	     pReg->sis6326tv[2] = (fsc >> 16) & 0xff;
	     pReg->sis6326tv[3] = (fsc >> 8) & 0xff;
	     pReg->sis6326tv[4] = fsc & 0xff;
          }
          tmp = pReg->sis6326tv[0x43];
          if(pSiS->SiS6326Flags & SIS6326_TVCVBS) tmp |= 0x10;
          tmp |= 0x08;
          pReg->sis6326tv[0x43] = tmp;
          j = 0; k = 0;
          for(i=0; i<=0x44; i++) {
	     if(SiS6326TVRegs1[j] == i) {
	 	j++;
		continue;
	     }
	     if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
		tmp = SiS6326TVRegs2_PAL[index][k];
	     } else {
		tmp = SiS6326TVRegs2_NTSC[index][k];
	     }
	     pReg->sis6326tv[i] = tmp;
	     k++;
          }
          pReg->sis6326tv[0x43] |= 0x08;
          if((pSiS->ChipRev == 0xc1) || (pSiS->ChipRev == 0xc2)) {
             pReg->sis6326tv[0x43] &= ~0x08;
          }

          tmp = pReg->sis6326tv[0];
          tmp |= 0x18;
          if(pSiS->SiS6326Flags & SIS6326_TVCVBS)   tmp &= ~0x10;
          if(pSiS->SiS6326Flags & SIS6326_TVSVIDEO) tmp &= ~0x08;
          tmp |= 0x04;
          pReg->sis6326tv[0] = tmp;
       }

    } /* VESA */

    return(TRUE);
}

/* Init a mode for SiS 300, 315 and 330 series
 * This function is now only used for setting up some
 * variables (eg. scrnOffset).
 */
Bool
SIS300Init(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    SISPtr         pSiS = SISPTR(pScrn);
    SISRegPtr      pReg = &pSiS->ModeReg;
    unsigned short temp;
    DisplayModePtr realmode = mode;

    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4, "SIS300Init()\n"));

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
        "virtualX = %d depth = %d Logical width = %d\n",
	pScrn->virtualX, pSiS->CurrentLayout.bitsPerPixel,
        pScrn->virtualX * pSiS->CurrentLayout.bitsPerPixel/8);

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       realmode = ((SiSMergedDisplayModePtr)mode->Private)->CRT1;
    }
#endif

    /* Copy current register settings to structure */
    (*pSiS->SiSSave)(pScrn, pReg);

    /* Calculate Offset/Display Pitch */
    pSiS->scrnOffset = pSiS->CurrentLayout.displayWidth *
                          ((pSiS->CurrentLayout.bitsPerPixel + 7) / 8);

    pSiS->scrnPitch = pSiS->scrnPitch2 = pSiS->scrnOffset;
    if(!(pSiS->VBFlags & CRT1_LCDA)) {
       if(realmode->Flags & V_INTERLACE) pSiS->scrnPitch <<= 1;
    }
    /* CRT2 mode can never be interlaced */

#ifdef UNLOCK_ALWAYS
    outSISIDXREG(SISSR, 0x05, 0x86);
#endif

    switch(pSiS->CurrentLayout.bitsPerPixel) {
        case 8:
            pSiS->DstColor = 0x0000;
	    pSiS->SiS310_AccelDepth = 0x00000000;
            break;
        case 16:
	    if(pSiS->CurrentLayout.depth == 15)
	        pSiS->DstColor = (short) 0x4000;
	    else
                pSiS->DstColor = (short) 0x8000;
	    pSiS->SiS310_AccelDepth = 0x00010000;
            break;
        case 24:
            break;
        case 32:
            pSiS->DstColor = (short) 0xC000;
	    pSiS->SiS310_AccelDepth = 0x00020000;
            break;
    }

    /* Enable PCI LINEAR ADDRESSING (0x80), MMIO (0x01), PCI_IO (0x20) */
    pReg->sisRegs3C4[0x20] = 0xA1;

    /* Now initialize TurboQueue. TB is always located at the very top of
     * the videoRAM (notably NOT the x framebuffer memory, which can/should
     * be limited by MaxXFbMem when using DRI). Also, enable the accelerators.
     */
    if(!pSiS->NoAccel) {
        pReg->sisRegs3C4[0x1E] |= 0x42;  /* Enable 2D accelerator */
	pReg->sisRegs3C4[0x1E] |= 0x18;  /* Enable 3D accelerator */
	switch(pSiS->VGAEngine) {
	case SIS_300_VGA:
	  if(pSiS->TurboQueue) {    		/* set Turbo Queue as 512k */
	    temp = ((pScrn->videoRam/64)-8);    /* 8=512k, 4=256k, 2=128k, 1=64k */
            pReg->sisRegs3C4[0x26] = temp & 0xFF;
	    pReg->sisRegs3C4[0x27] =
		(pReg->sisRegs3C4[0x27] & 0xfc) | (((temp >> 8) & 3) | 0xF0);
          }	/* line above new for saving D2&3 of status register */
	  break;
	case SIS_315_VGA:
#ifndef SISVRAMQ
	  /* See comments in sis_driver.c */
	  pReg->sisRegs3C4[0x27] = 0x1F;
	  pReg->sisRegs3C4[0x26] = 0x22;
	  pReg->sisMMIO85C0 = (pScrn->videoRam - 512) * 1024;
#endif
	  break;
	}
    }

    return(TRUE);
}

static int
SISDoSense(ScrnInfoPtr pScrn, unsigned short type, unsigned short test)
{
    SISPtr pSiS = SISPTR(pScrn);
    int    temp, mytest, result, i, j;

#ifdef TWDEBUG
    xf86DrvMsg(0, X_INFO, "Sense: %x %x\n", type, test);
#endif

    for(j = 0; j < 10; j++) {
       result = 0;
       for(i = 0; i < 3; i++) {
          mytest = test;
          outSISIDXREG(SISPART4,0x11,(type & 0x00ff));
          temp = (type >> 8) | (mytest & 0x00ff);
          setSISIDXREG(SISPART4,0x10,0xe0,temp);
          SiS_DDC2Delay(pSiS->SiS_Pr, 0x1500);
          mytest >>= 8;
          mytest &= 0x7f;
          inSISIDXREG(SISPART4,0x03,temp);
          temp ^= 0x0e;
          temp &= mytest;
          if(temp == mytest) result++;
#if 1
	  outSISIDXREG(SISPART4,0x11,0x00);
	  andSISIDXREG(SISPART4,0x10,0xe0);
	  SiS_DDC2Delay(pSiS->SiS_Pr, 0x1000);
#endif
       }
       if((result == 0) || (result >= 2)) break;
    }
    return(result);
}

#define GETROMWORD(w) (pSiS->BIOS[w] | (pSiS->BIOS[w+1] << 8))

/* Sense connected devices on 30x */
static void
SISSense30x(ScrnInfoPtr pScrn)
{
    SISPtr  pSiS = SISPTR(pScrn);
    unsigned char backupP4_0d,backupP2_00,backupP2_4d,biosflag=0;
    unsigned short svhs=0, svhs_c=0;
    unsigned short cvbs=0, cvbs_c=0;
    unsigned short vga2=0, vga2_c=0;
    int myflag, result; /* , i; */

    inSISIDXREG(SISPART4,0x0d,backupP4_0d);
    outSISIDXREG(SISPART4,0x0d,(backupP4_0d | 0x04));
    SiS_DDC2Delay(pSiS->SiS_Pr, 0x2000);

    inSISIDXREG(SISPART2,0x00,backupP2_00);
    outSISIDXREG(SISPART2,0x00,((backupP2_00 | 0x1c) & 0xfc));

    inSISIDXREG(SISPART2,0x4d,backupP2_4d);
    if(pSiS->VBFlags & (VB_301C|VB_301LV|VB_302LV|VB_302ELV)) {
       outSISIDXREG(SISPART2,0x4d,(backupP2_4d & ~0x10));
    }

    SISDoSense(pScrn, 0, 0);

    if(pSiS->VBFlags & VB_301) {
       svhs = 0x00b9; cvbs = 0x00b3; vga2 = 0x00d1;
       inSISIDXREG(SISPART4,0x01,myflag);
       if(myflag & 0x04) {
	  svhs = 0x00dd; cvbs = 0x00ee; vga2 = 0x00fd;
       }
    } else if(pSiS->VBFlags & (VB_301B | VB_302B)) {
       svhs = 0x016b; cvbs = 0x0174; vga2 = 0x0190;
    } else if(pSiS->VBFlags & (VB_301LV | VB_302LV)) {
       svhs = 0x0200; cvbs = 0x0100;
    } else if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
       svhs = 0x016b; cvbs = 0x0110; vga2 = 0x0190;
    } else return;

    vga2_c = 0x0e08; svhs_c = 0x0404; cvbs_c = 0x0804;
    if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
       svhs_c = 0x0408; cvbs_c = 0x0808;
    }
    biosflag = 2;

    if(pSiS->Chipset == PCI_CHIP_SIS300) {
       inSISIDXREG(SISSR,0x3b,myflag);
       if(!(myflag & 0x01)) vga2 = vga2_c = 0;
    }

    if(pSiS->sishw_ext.UseROM) {
       if(pSiS->VGAEngine == SIS_300_VGA) {
          if(pSiS->VBFlags & VB_301) {
	     inSISIDXREG(SISPART4,0x01,myflag);
             if(!(myflag & 0x04)) {
                vga2 = GETROMWORD(0xf8); svhs = GETROMWORD(0xfa); cvbs = GETROMWORD(0xfc);
	     }
	  }
	  biosflag = pSiS->BIOS[0xfe];
       } else if(pSiS->Chipset == PCI_CHIP_SIS660) {
          if(pSiS->ROM661New) {
	     biosflag = 2;
	     vga2 = GETROMWORD(0x63); svhs = cvbs = GETROMWORD(0x65);
	     if(pSiS->BIOS[0x5d] & 0x04) biosflag |= 0x01;
	  }
       } else if(!pSiS->ROM661New) {
#if 0	  /* eg. 1.15.23 has wrong values here */
          myflag = 0;
          if(pSiS->VBFlags & VB_301) {
	     if(pSiS->Chipset == PCI_CHIP_SIS330) {
	        myflag = 0xe5; i = 0x11b;
	     } else {
	        myflag = 0xbd; i = 0xf3
	     }
	  } else if(pSiS->VBFlags & (VB_301B|VB_302B|VB_301LV|VB_302LV)) {
	     if(pSiS->Chipset == PCI_CHIP_SIS330) {
	        myflag = 0xeb; i = 0x11b;
	     } else {
	        myflag = 0xc3; i = 0xf3
	     }
	  }
	  if(myflag) {
	     biosflag = pSiS->BIOS[i];    vga2 = GETROMWORD(myflag);
	     svhs = GETROMWORD(myflag+2); cvbs = GETROMWORD(myflag+4);
	  }
#endif
       }
    }

    if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
       vga2 = vga2_c = 0;
    }

    andSISIDXREG(SISCR, 0x32, ~0x14);
    pSiS->postVBCR32 &= ~0x14;
    
    if(vga2_c || vga2) {
       if(SISDoSense(pScrn, vga2, vga2_c)) {
          if(biosflag & 0x01) {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	         "SiS30x: Detected TV connected to SCART output\n");
	     pSiS->VBFlags |= TV_SCART;
	     orSISIDXREG(SISCR, 0x32, 0x04);
	     pSiS->postVBCR32 |= 0x04;
	  } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	         "SiS30x: Detected secondary VGA connection\n");
	     pSiS->VBFlags |= VGA2_CONNECTED;
	     orSISIDXREG(SISCR, 0x32, 0x10);
	     pSiS->postVBCR32 |= 0x10;
	  }
       }
       if(biosflag & 0x01) pSiS->SiS_SD_Flags |= SiS_SD_VBHASSCART;
    }

    andSISIDXREG(SISCR, 0x32, 0x3f);
    pSiS->postVBCR32 &= 0x3f;

    if((pSiS->VGAEngine == SIS_315_VGA) && (pSiS->VBFlags & (VB_301C|VB_301LV|VB_302LV|VB_302ELV))) {
       if(pSiS->SenseYPbPr) {
          outSISIDXREG(SISPART2,0x4d,(backupP2_4d | 0x10));
          SiS_DDC2Delay(pSiS->SiS_Pr, 0x2000);
          if((result = SISDoSense(pScrn, svhs, 0x0604))) {
             if((result = SISDoSense(pScrn, cvbs, 0x0804))) {
	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
     			"SiS30x: Detected TV connected to YPbPr component output\n");
	        orSISIDXREG(SISCR,0x32,0x80);
	        pSiS->VBFlags |= TV_YPBPR;
	        pSiS->postVBCR32 |= 0x80;
	     }
          }
          outSISIDXREG(SISPART2,0x4d,backupP2_4d);
       }
    }

    andSISIDXREG(SISCR, 0x32, ~0x03);
    pSiS->postVBCR32 &= ~0x03;

    if(!(pSiS->VBFlags & TV_YPBPR)) {

       if((result = SISDoSense(pScrn, svhs, svhs_c))) {
          xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
     		"SiS30x: Detected TV connected to SVIDEO output\n");
          pSiS->VBFlags |= TV_SVIDEO;
          orSISIDXREG(SISCR, 0x32, 0x02);
          pSiS->postVBCR32 |= 0x02;
       }

       if((biosflag & 0x02) || (!result)) {
          if(SISDoSense(pScrn, cvbs, cvbs_c)) {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	             "SiS30x: Detected TV connected to COMPOSITE output\n");
	     pSiS->VBFlags |= TV_AVIDEO;
	     orSISIDXREG(SISCR, 0x32, 0x01);
	     pSiS->postVBCR32 |= 0x01;
          }
       }

    }

    SISDoSense(pScrn, 0, 0);

    outSISIDXREG(SISPART2,0x00,backupP2_00);
    outSISIDXREG(SISPART4,0x0d,backupP4_0d);
}

static void
SiS6326TVDelay(ScrnInfoPtr pScrn, int delay)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int i;
    unsigned char temp;

    for(i=0; i<delay; i++) {
    	inSISIDXREG(SISSR, 0x05, temp);
    }
    (void)temp;
}

static int
SIS6326DoSense(ScrnInfoPtr pScrn, int tempbh, int tempbl, int tempch, int tempcl)
{
    unsigned char temp;

    SiS6326SetTVReg(pScrn, 0x42, tempbl);
    temp = SiS6326GetTVReg(pScrn, 0x43);
    temp &= 0xfc;
    temp |= tempbh;
    SiS6326SetTVReg(pScrn, 0x43, temp);
    SiS6326TVDelay(pScrn, 0x1000);
    temp = SiS6326GetTVReg(pScrn, 0x43);
    temp |= 0x04;
    SiS6326SetTVReg(pScrn, 0x43, temp);
    SiS6326TVDelay(pScrn, 0x8000);
    temp = SiS6326GetTVReg(pScrn, 0x44);
    if(!(tempch & temp)) tempcl = 0;
    return(tempcl);
}

static void
SISSense6326(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char temp;
    int result;

    pSiS->SiS6326Flags &= (SIS6326_HASTV | SIS6326_TVPAL);
    temp = SiS6326GetTVReg(pScrn, 0x43);
    temp &= 0xfb;
    SiS6326SetTVReg(pScrn, 0x43, temp);
    result = SIS6326DoSense(pScrn, 0x01, 0xb0, 0x06, SIS6326_TVSVIDEO);  /* 0x02 */
    pSiS->SiS6326Flags |= result;
    result = SIS6326DoSense(pScrn, 0x01, 0xa0, 0x01, SIS6326_TVCVBS);    /* 0x04 */
    pSiS->SiS6326Flags |= result;
    temp = SiS6326GetTVReg(pScrn, 0x43);
    temp &= 0xfb;
    SiS6326SetTVReg(pScrn, 0x43, temp);
    if(pSiS->SiS6326Flags & (SIS6326_TVSVIDEO | SIS6326_TVCVBS)) {
    	pSiS->SiS6326Flags |= SIS6326_TVDETECTED;
	xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		"SiS6326: Detected TV connected to %s output\n",
		(((pSiS->SiS6326Flags & (SIS6326_TVSVIDEO | SIS6326_TVCVBS)) ==
		   (SIS6326_TVSVIDEO | SIS6326_TVCVBS)) ?
		   	"both SVIDEO and COMPOSITE" :
		      	   ((pSiS->SiS6326Flags & SIS6326_TVSVIDEO) ?
			     	"SVIDEO" : "COMPOSITE")));
    } else {
        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		"SiS6326: No TV detected\n");
    }
}

/* Detect video bridge and set VBFlags accordingly */
void SISVGAPreInit(ScrnInfoPtr pScrn)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int     temp,temp1,temp2, i;
    int     upperlimitlvds, lowerlimitlvds;
    int     upperlimitch, lowerlimitch;
    int     chronteltype, chrontelidreg, upperlimitvb;
    unsigned char test[3];
    static const char *detectvb = "Detected %s video bridge (ID %d; Revision 0x%x)\n";
#if 0
    unsigned char sr17=0;
#endif
    static const char  *ChrontelTypeStr[] = {
        "7004",
	"7005",
	"7007",
	"7006",
	"7008",
	"7013",
	"7019",
	"7020",
	"(unknown)"
    };

    switch (pSiS->Chipset) {
        case PCI_CHIP_SIS300:
        case PCI_CHIP_SIS630:
        case PCI_CHIP_SIS540:
	case PCI_CHIP_SIS550:
	case PCI_CHIP_SIS650:
	case PCI_CHIP_SIS315:
	case PCI_CHIP_SIS315H:
	case PCI_CHIP_SIS315PRO:
	case PCI_CHIP_SIS330:
	case PCI_CHIP_SIS660:
            pSiS->ModeInit = SIS300Init;
            break;
        default:
            pSiS->ModeInit = SISInit;
    }

    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
        unsigned char sr0d;
	inSISIDXREG(SISSR, 0x0d, sr0d);
	if(sr0d & 0x04) {
		pSiS->SiS6326Flags |= SIS6326_TVPAL;
	}
	SISSense6326(pScrn);
    }

    pSiS->VBFlags = 0; /* reset VBFlags */
    pSiS->SiS_Pr->SiS_UseLCDA = FALSE;
    pSiS->SiS_Pr->Backup = FALSE;

    /* Videobridges only available for 300/315 series */
    if((pSiS->VGAEngine != SIS_300_VGA) && (pSiS->VGAEngine != SIS_315_VGA))
        return;
	
    inSISIDXREG(SISPART4, 0x00, temp);
    temp &= 0x0F;
    if(temp == 1) {
        inSISIDXREG(SISPART4, 0x01, temp1);
	temp1 &= 0xff;
        if(temp1 >= 0xE0) {
	        inSISIDXREG(SISPART4, 0x39, temp2);
		if(temp2 == 0xff) {
	   	   pSiS->VBFlags |= VB_302LV;
		   pSiS->sishw_ext.ujVBChipID = VB_CHIP_302LV;
    		   xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS302LV", 1, temp1);
		} else {
		   pSiS->VBFlags |= VB_302ELV;
		   pSiS->sishw_ext.ujVBChipID = VB_CHIP_302ELV;
    		   xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS302ELV", 1, temp1);
		}
	} else if(temp1 >= 0xD0) {
	   	pSiS->VBFlags |= VB_301LV;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301LV;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS301LV", 1, temp1);
	} else if(temp1 >= 0xC0) {
	   	pSiS->VBFlags |= VB_301C;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301C;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS301C", 1, temp1);
	} else if(temp1 >= 0xB0) {
	        pSiS->VBFlags |= VB_301B;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301B;
		inSISIDXREG(SISPART4, 0x23, temp2);
		if(!(temp2 & 0x02)) pSiS->VBFlags |= VB_30xBDH;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb,
				(temp2 & 0x02) ? "SiS301B" : "SiS301B-DH", 1, temp1);
	} else {
	        pSiS->VBFlags |= VB_301;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301;
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS301", 1, temp1);
	}

	SISSense30x(pScrn); 

    } else if (temp == 2) {

        inSISIDXREG(SISPART4, 0x01, temp1);
	temp1 &= 0xff;
	if(temp1 >= 0xE0) {
        	pSiS->VBFlags |= VB_302LV;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_302LV;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS302LV", 2, temp1);
	} else if(temp1 >= 0xD0) {
        	pSiS->VBFlags |= VB_301LV;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301LV;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS301LV", 2, temp1);
	} else {
	        pSiS->VBFlags |= VB_302B;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_302B;
		inSISIDXREG(SISPART4, 0x23, temp2);
		if(!(temp & 0x02)) pSiS->VBFlags |= VB_30xBDH;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb,
				(temp2 & 0x02) ? "SiS302B" : "SiS302B-DH", 2, temp1);
	}

	SISSense30x(pScrn);

    } else if (temp == 3) {

    	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "unsupported SiS303", temp, 0);

    } else {

        pSiS->sishw_ext.ujVBChipID = VB_CHIP_UNKNOWN;
	if(pSiS->Chipset == PCI_CHIP_SIS660) {
	   inSISIDXREG(SISCR, 0x38, temp);
           temp = (temp >> 5) & 0x07;
	} else {
	   inSISIDXREG(SISCR, 0x37, temp);
           temp = (temp >> 1) & 0x07;
	}
        if(pSiS->VGAEngine == SIS_300_VGA) {
	   lowerlimitlvds = 2; upperlimitlvds = 4;
	   lowerlimitch   = 4; upperlimitch   = 5;
	   chronteltype = 1;   chrontelidreg  = 0x25;
	   upperlimitvb = upperlimitlvds;
        } else {
	   lowerlimitlvds = 2; upperlimitlvds = 3;
	   lowerlimitch   = 3; upperlimitch   = 3;
	   chronteltype = 2;   chrontelidreg  = 0x4b;
	   upperlimitvb = upperlimitlvds;
	   if(pSiS->Chipset == PCI_CHIP_SIS660) {
	      upperlimitvb = 4;
	   }
	}

	if((temp >= lowerlimitlvds) && (temp <= upperlimitlvds)) {
               pSiS->VBFlags |= VB_LVDS;
    	       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	               "Detected LVDS transmitter (External chip ID %d)\n", temp);
	}
        if((temp >= lowerlimitch) && (temp <= upperlimitch))  {
	    /* Set global for init301.c */
	    pSiS->SiS_Pr->SiS_IF_DEF_CH70xx = chronteltype;

	    if(chronteltype == 1) {
	       /* Set general purpose IO for Chrontel communication */
	       SiS_SetChrontelGPIO(pSiS->SiS_Pr, 0x9c);
	    }

	    /* Read Chrontel version number */
 	    temp1 = SiS_GetCH70xx(pSiS->SiS_Pr, chrontelidreg);
	    if(chronteltype == 1) {
	        /* See Chrontel TB31 for explanation */
		temp2 = SiS_GetCH700x(pSiS->SiS_Pr, 0x0e);
		if(((temp2 & 0x07) == 0x01) || (temp2 & 0x04)) {
		    SiS_SetCH700x(pSiS->SiS_Pr, 0x0b0e);
		    SiS_DDC2Delay(pSiS->SiS_Pr, 300);
		}
	        temp2 = SiS_GetCH70xx(pSiS->SiS_Pr, chrontelidreg);
		if(temp2 != temp1) temp1 = temp2;
	    }
	    if(temp1 == 0xFFFF) {	/* 0xFFFF = error reading DDC port */
	    	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			"Detected Chrontel 70xx, but encountered error reading I2C port\n");
		andSISIDXREG(SISCR, 0x32, ~0x07);
		pSiS->postVBCR32 &= ~0x07;
	    }
	    /* TW: We only support device ids 0x19-200; other values may indicate DDC problems */
	    else if((temp1 >= 0x19) && (temp1 <= 200)) {
	        pSiS->VBFlags |= VB_CHRONTEL;
		switch (temp1) {
		   case 0x32: temp2 = 0; pSiS->ChrontelType = CHRONTEL_700x; break;
		   case 0x3A: temp2 = 1; pSiS->ChrontelType = CHRONTEL_700x; break;
		   case 0x50: temp2 = 2; pSiS->ChrontelType = CHRONTEL_700x; break;
		   case 0x2A: temp2 = 3; pSiS->ChrontelType = CHRONTEL_700x; break;
		   case 0x40: temp2 = 4; pSiS->ChrontelType = CHRONTEL_700x; break;
		   case 0x22: temp2 = 5; pSiS->ChrontelType = CHRONTEL_700x; break;
	           case 0x19: temp2 = 6; pSiS->ChrontelType = CHRONTEL_701x; break;
	           case 0x20: temp2 = 7; pSiS->ChrontelType = CHRONTEL_701x; break;  /* ID for 7020? */
		   default:   temp2 = 8; pSiS->ChrontelType = CHRONTEL_701x; break;
		}
   	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	               "Detected Chrontel %s TV encoder (ID 0x%02x; chip ID %d)\n",
		       			ChrontelTypeStr[temp2], temp1, temp);

		/* Sense connected TV's */

		if(chronteltype == 1) {

		   /* Chrontel 700x */

	    	   /* Read power status */
	    	   temp1 = SiS_GetCH700x(pSiS->SiS_Pr, 0x0e);  /* Power status */
	    	   if((temp1 & 0x03) != 0x03) {
		        /* TW: Power all outputs */
	        	SiS_SetCH700x(pSiS->SiS_Pr, 0x0B0E);
			SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);
	    	   }
		   /* Sense connected TV devices */
		   for(i = 0; i < 3; i++) {
	    	      SiS_SetCH700x(pSiS->SiS_Pr, 0x0110);
		      SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);
	    	      SiS_SetCH700x(pSiS->SiS_Pr, 0x0010);
		      SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);
	    	      temp1 = SiS_GetCH700x(pSiS->SiS_Pr, 0x10);
		      if(!(temp1 & 0x08))       test[i] = 0x02;
		      else if(!(temp1 & 0x02))  test[i] = 0x01;
		      else                      test[i] = 0;
		      SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);
		   }

		   if(test[0] == test[1])      temp1 = test[0];
		   else if(test[0] == test[2]) temp1 = test[0];
		   else if(test[1] == test[2]) temp1 = test[1];
		   else {
		   	xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
				"TV detection unreliable - test results varied\n");
			temp1 = test[2];
		   }

		} else {

		   /* Chrontel 701x */

		   /* Backup Power register */
		   temp1 = SiS_GetCH701x(pSiS->SiS_Pr, 0x49);

		   /* Enable TV path */
		   SiS_SetCH701x(pSiS->SiS_Pr, 0x2049);

		   SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);

		   /* Sense connected TV devices */
		   temp2 = SiS_GetCH701x(pSiS->SiS_Pr, 0x20);
		   temp2 |= 0x01;
		   SiS_SetCH701x(pSiS->SiS_Pr, (temp2 << 8) | 0x20);

		   SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);

		   temp2 ^= 0x01;
		   SiS_SetCH701x(pSiS->SiS_Pr, (temp2 << 8) | 0x20);

		   SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);

		   temp2 = SiS_GetCH701x(pSiS->SiS_Pr, 0x20); 

		   /* Restore Power register */
		   SiS_SetCH701x(pSiS->SiS_Pr, (temp1 << 8) | 0x49);

                   temp1 = 0;
		   if(temp2 & 0x02) temp1 |= 0x01;
		   if(temp2 & 0x10) temp1 |= 0x01;
		   if(temp2 & 0x04) temp1 |= 0x02;

		   if( (temp1 & 0x01) && (temp1 & 0x02) ) temp1 = 0x04;

                }

		switch(temp1) {
		     case 0x01:
		        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		  	   "Chrontel: Detected TV connected to COMPOSITE output\n");
			pSiS->VBFlags |= TV_AVIDEO;
			orSISIDXREG(SISCR, 0x32, 0x01);
			andSISIDXREG(SISCR, 0x32, ~0x06);
			pSiS->postVBCR32 |= 0x01;
			pSiS->postVBCR32 &= ~0x06;
                        break;
                     case 0x02:
			xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			   "Chrontel: Detected TV connected to SVIDEO output\n");
			pSiS->VBFlags |= TV_SVIDEO;
			orSISIDXREG(SISCR, 0x32, 0x02);
			andSISIDXREG(SISCR, 0x32, ~0x05);
			pSiS->postVBCR32 |= 0x02;
			pSiS->postVBCR32 &= ~0x05;
                        break;
		     case 0x04:
			xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			   "Chrontel: Detected TV connected to SCART or YPBPR output\n");
			if(pSiS->chtvtype == -1) {
			   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			      "Chrontel: Use CHTVType option to select either SCART or YPBPR525I\n");
			   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			      "Chrontel: Using SCART by default\n");
			   pSiS->chtvtype = 1;
			}
			if(pSiS->chtvtype)
			    pSiS->VBFlags |= TV_CHSCART;
			else
			    pSiS->VBFlags |= TV_CHYPBPR525I;
                        break;
		     default:
		        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		  	   "Chrontel: No TV detected.\n");
			andSISIDXREG(SISCR, 0x32, ~0x07);
			pSiS->postVBCR32 &= ~0x07;
		}

	    } else if(temp1==0) {
	        /* This indicates a communication problem, but it only occures if there
		 * is no TV attached. So we don't use TV in this case.
		 */
	    	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"Detected Chrontel TV encoder in promiscuous state (DDC/I2C mix-up)\n");
		andSISIDXREG(SISCR, 0x32, ~0x07);
		pSiS->postVBCR32 &= ~0x07;
	    } else {
	    	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			"Chrontel: Unsupported device id (%d) detected\n",temp1);
		andSISIDXREG(SISCR, 0x32, ~0x07);
		pSiS->postVBCR32 &= ~0x07;
	    }
	    if(chronteltype == 1) {
	       /* Set general purpose IO for Chrontel communication */
	       SiS_SetChrontelGPIO(pSiS->SiS_Pr, 0x00);
	    }
	}
	if((pSiS->Chipset == PCI_CHIP_SIS660) && (temp == 4)) {
	   pSiS->VBFlags |= VB_CONEXANT;
	   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	               "Detected Conexant video bridge - UNSUPPORTED\n");
	}
	if((pSiS->VGAEngine == SIS_300_VGA) && (temp == 3)) {
	    pSiS->VBFlags |= VB_TRUMPION;
	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	               "Detected Trumpion Zurac (I/II/III) LVDS scaler\n");
	}
	if(temp > upperlimitvb) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	               "Detected unknown bridge type (%d)\n", temp);
	}
    }

   /* Old BIOSes store the detected CRT2 type in SR17, 16 and 13
    * instead of CR32. However, since our detection routines
    * store their results to CR32, we now copy the
    * remaining bits (for LCD and VGA) to CR32 for unified usage.
    * SR17[0] CRT1     [1] LCD       [2] TV    [3] VGA2
    *     [4] AVIDEO   [5] SVIDEO
    * SR13[0] SCART    [1] HiVision
    * SR16[5] PAL/NTSC [6] LCD-SCALE [7] OVERSCAN
    */

#if 0
    inSISIDXREG(SISSR, 0x17, sr17);
    if( (pSiS->VGAEngine == SIS_300_VGA) &&
        (pSiS->Chipset != PCI_CHIP_SIS300) &&
        (sr17 & 0x0F) ) {
	
	unsigned char cr32;
	inSISIDXREG(SISCR, 0x32, cr32);
	
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		"Converting SR17 (%02x) to CR32 (%02x)\n", sr17, cr32);
	 
	 if(sr17 & 0x01) {  	/* CRT1 */
	 	orSISIDXREG(SISCR, 0x32, 0x20);
		pSiS->postVBCR32 |= 0x20;
	 } else {
	 	andSISIDXREG(SISCR, 0x32, ~0x20);
		pSiS->postVBCR32 &= ~0x20;
	 }
		
	 if(sr17 & 0x02) {	/* LCD */
	 	orSISIDXREG(SISCR, 0x32, 0x08);
		pSiS->postVBCR32 |= 0x08;
	 } else	{	  
	 	andSISIDXREG(SISCR, 0x32, ~0x08);
		pSiS->postVBCR32 &= ~0x08;
	 }
	 
	 /* No Hivision, no DVI here */
	 andSISIDXREG(SISCR,0x32,~0xc0);
	 pSiS->postVBCR32 &= ~0xc0;
    }  
#endif

    /* Try to find out if the bridge uses LCDA for low resolution and
     * text modes. If sisfb saved this for us, use it. Otherwise,
     * check if we are running on a low mode on LCD and read the 
     * relevant registers ourselves.
     */
    if(pSiS->VGAEngine == SIS_315_VGA) {

       if(pSiS->VBFlags & (VB_301C | VB_302B | VB_301LV | VB_302LV | VB_302ELV)) {
          if(pSiS->sisfblcda != 0xff) {
	     if((pSiS->sisfblcda & 0x03) == 0x03) {
	        pSiS->SiS_Pr->SiS_UseLCDA = TRUE;
	        pSiS->ChipFlags |= SiSCF_UseLCDA;
	     }
	  } else {
             inSISIDXREG(SISCR,0x34,temp);
	     if(temp <= 0x13) {
	        inSISIDXREG(SISCR,0x38,temp);
	        if((temp & 0x03) == 0x03) {
	           pSiS->SiS_Pr->SiS_UseLCDA = TRUE;
	           pSiS->ChipFlags |= SiSCF_UseLCDA;
		   pSiS->SiS_Pr->Backup = TRUE;
	        } else {
		   orSISIDXREG(SISPART1,0x2f,0x01);  /* Unlock CRT2 */
		   inSISIDXREG(SISPART1,0x13,temp);
		   if(temp & 0x04) {
		      pSiS->SiS_Pr->SiS_UseLCDA = TRUE;
	              pSiS->ChipFlags |= SiSCF_UseLCDA;
		      pSiS->SiS_Pr->Backup = TRUE;
		   }
	        }
	     }
	  }
	  if(pSiS->ChipFlags & SiSCF_UseLCDA) {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		"BIOS uses LCDA for low resolution and text modes\n");
	     if(pSiS->SiS_Pr->Backup == TRUE) {
	        inSISIDXREG(SISCR,0x34,pSiS->SiS_Pr->Backup_Mode);
                inSISIDXREG(SISPART1,0x14,pSiS->SiS_Pr->Backup_14);
	        inSISIDXREG(SISPART1,0x15,pSiS->SiS_Pr->Backup_15);
	        inSISIDXREG(SISPART1,0x16,pSiS->SiS_Pr->Backup_16);
	        inSISIDXREG(SISPART1,0x17,pSiS->SiS_Pr->Backup_17);
	        inSISIDXREG(SISPART1,0x18,pSiS->SiS_Pr->Backup_18);
	        inSISIDXREG(SISPART1,0x19,pSiS->SiS_Pr->Backup_19);
	        inSISIDXREG(SISPART1,0x1a,pSiS->SiS_Pr->Backup_1a);
	        inSISIDXREG(SISPART1,0x1b,pSiS->SiS_Pr->Backup_1b);
	        inSISIDXREG(SISPART1,0x1c,pSiS->SiS_Pr->Backup_1c);
	        inSISIDXREG(SISPART1,0x1d,pSiS->SiS_Pr->Backup_1d);
	     }
	  }
       }
    }
}


@


1.1
log
@Initial revision
@
text
@d1 1
d3 1
a3 1
 * Copyright 1998,1999 by Alan Hourihane, Wigan, England.
d5 1
a5 9
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Alan Hourihane not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Alan Hourihane makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
d7 10
a16 7
 * ALAN HOURIHANE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL ALAN HOURIHANE BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 16
a33 5
 * Authors:  Alan Hourihane, alanh@@fairlite.demon.co.uk
 *           Mike Chapman <mike@@paranoia.com>, 
 *           Juanjo Santamarta <santamarta@@ctv.es>, 
 *           Mitani Hiroshi <hmitani@@drl.mei.co.jp> 
 *           David Thomas <davtom@@dream.org.uk>. 
a34 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_vga.c,v 1.12 2002/01/17 09:57:30 eich Exp $ */
d47 107
a153 18
#define Midx    0
#define Nidx    1
#define VLDidx  2
#define Pidx    3
#define PSNidx  4
#define Fref 14318180
/* stability constraints for internal VCO -- MAX_VCO also determines
 * the maximum Video pixel clock */
#define MIN_VCO Fref
#define MAX_VCO 135000000
#define MAX_VCO_5597 353000000
#define MAX_PSN 0 /* no pre scaler for this chip */
#define TOLERANCE 0.01  /* search smallest M and N in this tolerance */


void SISVGAPreInit(ScrnInfoPtr pScrn);
static  Bool    SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode);
static  Bool    SIS300Init(ScrnInfoPtr pScrn, DisplayModePtr mode);
d155 1
d159 19
a177 15
    SISPtr pSiS = SISPTR(pScrn);
    SISRegPtr pReg = &pSiS->ModeReg;
    vgaRegPtr   vgaReg = &VGAHWPTR(pScrn)->ModeReg;
    int gap, safetymargin, MemBand;
    int vgaIOBase;
    unsigned char temp;
    int Base,mclk;
    int offset;
    int clock = mode->Clock;
    unsigned int vclk[5];
    unsigned short CRT_CPUthresholdLow ;
    unsigned short CRT_CPUthresholdHigh ;
    unsigned short CRT_ENGthreshold ;

    int num, denum, div, sbit, scale;
a179 2
    vgaHWGetIOBase(VGAHWPTR(pScrn));
    vgaIOBase = VGAHWPTR(pScrn)->IOBase;
d181 1
d184 29
a212 1
    pSiS->scrnOffset = pScrn->displayWidth * pScrn->bitsPerPixel / 8;
d214 3
a216 1
    outw(VGA_SEQ_INDEX, 0x8605);
d218 3
a220 5
    pReg->sisRegs3C4[0x06] &= 0x01;
    
    if ((mode->Flags & V_INTERLACE)==0)  {
        offset = pScrn->displayWidth >> 3;
        pReg->sisRegs3C4[0x06] &= 0xDF;
d222 9
a230 2
        offset = pScrn->displayWidth >> 2;
        pReg->sisRegs3C4[0x06] |= 0x20;
d233 6
a238 11
    /* Enable Linear */
    switch (pSiS->Chipset)  {
    case PCI_CHIP_SIS5597:
    case PCI_CHIP_SIS6326:
    case PCI_CHIP_SIS530:
        pReg->sisRegs3C4[BankReg] |= 0x82;
        pReg->sisRegs3C4[0x0C] |= 0xA0;
        pReg->sisRegs3C4[0x0B] |= 0x60;
        break;
    default:
        pReg->sisRegs3C4[BankReg] |= 0x82;
d241 56
a296 26
    switch (pScrn->bitsPerPixel) {
        case 8:
            break;
        case 15:
            offset <<= 1;
            pReg->sisRegs3C4[BankReg] |= 0x04;
            break;
        case 16:
            offset <<= 1;
            pReg->sisRegs3C4[BankReg] |= 0x08;
            break;
        case 24:
            offset += (offset << 1);
            pReg->sisRegs3C4[BankReg] |= 0x10;
            pReg->sisRegs3C4[MMIOEnable] |= 0x90;
            break;
        case 32:
            offset <<= 2;
            if (pSiS->Chipset == PCI_CHIP_SIS530)  {
                    pReg->sisRegs3C4[BankReg] |= 0x10;
                    pReg->sisRegs3C4[MMIOEnable] |= 0x90;
                    pReg->sisRegs3C4[0x09] |= 0x80;
            } else  {
                    return FALSE;
            }
            break;
d298 285
a582 18
    switch (pScrn->videoRam)  {
        case 512:
            temp = 0x00;
            break;
        case 1024:
            temp = 0x20;
            break;
        case 2048:
            temp = 0x40;
            break;
        case 4096:
            temp = 0x60;
            break;
        case 8192:
            temp = 0x80;
            break;
        default:
            temp = 0x20;
d584 29
a612 13
    switch (pSiS->Chipset)  {
        case PCI_CHIP_SG86C225:
        case PCI_CHIP_SIS5597:
        case PCI_CHIP_SIS6326:
            pReg->sisRegs3C4[LinearAdd0] = (pSiS->FbAddress & 0x07F80000) >> 19;
            pReg->sisRegs3C4[LinearAdd1] =((pSiS->FbAddress & 0xF8000000) >> 27)
                                        | temp; /* Enable linear with max 4M */
            break;
        case PCI_CHIP_SIS530:
            pReg->sisRegs3C4[LinearAdd0] = (pSiS->FbAddress & 0x07F80000) >> 19;
            pReg->sisRegs3C4[LinearAdd1] =((pSiS->FbAddress & 0xF8000000) >> 27)
                                        | temp; /* Enable linear with max 8M */
            break;
a614 90
    /* Screen Offset */
    vgaReg->CRTC[0x13] = offset & 0xFF;
    pReg->sisRegs3C4[CRTCOff] = ((offset & 0xF00) >> 4) | 
                (((mode->CrtcVTotal-2)     & 0x400) >> 10 ) |
                (((mode->CrtcVDisplay-1)   & 0x400) >> 9 ) |
                (((mode->CrtcVSyncStart-1) & 0x400) >> 8 ) |
                (((mode->CrtcVSyncStart)   & 0x400) >> 7 ) ;

    /* Extended Horizontal Overflow Register */
    pReg->sisRegs3C4[0x12] &= 0xE0;
    pReg->sisRegs3C4[0x12] |= (
        (((mode->CrtcHTotal >> 3) - 5)     & 0x100) >> 8 |
        (((mode->CrtcHDisplay >> 3) - 1)   & 0x100) >> 7 |
        (((mode->CrtcHSyncStart >> 3) - 1) & 0x100) >> 6 |
        ((mode->CrtcHSyncStart >> 3)       & 0x100) >> 5 |
        (((mode->CrtcHBlankEnd >> 3) -1)   & 0x40)  >> 2);
/*      ((mode->CrtcHSyncEnd >> 3)         & 0x40)  >> 2); */

    if (mode->CrtcVDisplay > 1024)
        /* disable line compare */
        pReg->sisRegs3C4[0x38] |= 0x04;
    else
        pReg->sisRegs3C4[0x38] &= 0xFB;

    if (( pScrn->depth == 24) || (pScrn->depth == 32) ||
                    (mode->CrtcHDisplay >= 1280))
        /* Enable high speed DCLK */
        pReg->sisRegs3C4[0x3E] |= 1;
    else
        pReg->sisRegs3C4[0x3E] &= 0xFE;


    /* Set vclk */  
    if (SiScompute_vclk(clock, &num, &denum, &div, &sbit, &scale)) {
        switch  (pSiS->Chipset)  {
            case PCI_CHIP_SIS5597:
            case PCI_CHIP_SIS6326:
            case PCI_CHIP_SIS530:
                pReg->sisRegs3C4[XR2A] = (num - 1) & 0x7f ;
                pReg->sisRegs3C4[XR2A] |= (div == 2) ? 0x80 : 0;
                pReg->sisRegs3C4[XR2B] = ((denum -1) & 0x1f);
                pReg->sisRegs3C4[XR2B] |= (((scale -1)&3) << 5);
                /* When set VCLK, you should set SR13 first */
                if (sbit) 
                    pReg->sisRegs3C4[ClockBase] |= 0x40;
                else 
                    pReg->sisRegs3C4[ClockBase] &= 0xBF;
                    
                break;
        }
    }
    else  {
    /* if SiScompute_vclk cannot handle the request clock try sisCalcClock! */
        SiSCalcClock(pScrn, clock, 2, vclk);
        switch (pSiS->Chipset)  {
            case PCI_CHIP_SIS5597:
            case PCI_CHIP_SIS6326:
            case PCI_CHIP_SIS530:
                pReg->sisRegs3C4[XR2A] = (vclk[Midx] - 1) & 0x7f ;
                pReg->sisRegs3C4[XR2A] |= ((vclk[VLDidx] == 2 ) ? 1 : 0 ) << 7 ;

                /* bits [4:0] contain denumerator -MC */
                pReg->sisRegs3C4[XR2B] = (vclk[Nidx] -1) & 0x1f ;

                if (vclk[Pidx] <= 4){
                /* postscale 1,2,3,4 */
                    pReg->sisRegs3C4[XR2B] |= (vclk[Pidx] -1 ) << 5 ;
                    pReg->sisRegs3C4[ClockBase] &= 0xBF;
                } else {
                /* postscale 6,8 */
                    pReg->sisRegs3C4[XR2B] |= ((vclk[Pidx] / 2) -1 ) << 5 ;
                    pReg->sisRegs3C4[ClockBase] |= 0x40;
                }
                pReg->sisRegs3C4[XR2B] |= 0x80 ;   /* gain for high frequency */
                break;
        }
    } /* end of set vclk */

    if (clock > 135000)
        pReg->sisRegs3C4[ClockReg] |= 0x02;

    /* pReg->sisRegs3C2 = inb(0x3CC) | 0x0C;*/ /* Programmable Clock */
    pReg->sisRegs3C2 = inb(pSiS->RelIO+0x4c) | 0x0C; /* Programmable Clock */

    if (pSiS->FastVram && ((pSiS->Chipset == PCI_CHIP_SIS530) ||
        (pSiS->Chipset == PCI_CHIP_SIS6326) ||
        (pSiS->Chipset == PCI_CHIP_SIS5597)))
        pReg->sisRegs3C4[ExtMiscCont5]|= 0xC0;
    else 
        pReg->sisRegs3C4[ExtMiscCont5]&= ~0xC0;
d616 172
a787 66
    pSiS->ValidWidth = TRUE;
    if ((pSiS->Chipset == PCI_CHIP_SIS5597) ||
        (pSiS->Chipset == PCI_CHIP_SIS6326) ||
        (pSiS->Chipset == PCI_CHIP_SIS530))
    {
        pReg->sisRegs3C4[GraphEng] &= 0xCF; /* Clear logical width bits */
        if (pScrn->bitsPerPixel == 24)  {
            pReg->sisRegs3C4[GraphEng] |= 0x30; /* Invalid logical width */
            pSiS->ValidWidth = FALSE;
        }
        else  {
            switch ( pScrn->virtualX * (pScrn->bitsPerPixel >> 3) ) {
                case 1024:
                    pReg->sisRegs3C4[GraphEng] |= 0x00; /* | 00 = No change */
                    break;
                case 2048:
                    pReg->sisRegs3C4[GraphEng] |= 0x10; 
                    break;
                case 4096:
                    pReg->sisRegs3C4[GraphEng] |= 0x20; 
                    break;
                default:
                    /* Invalid logical width */
                    pReg->sisRegs3C4[GraphEng] =  0x30;
                    pSiS->ValidWidth = FALSE;
                    break;
            }
        }
    }
    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
                "virtualX = %d depth = %d Logical width = %d\n",
                pScrn->virtualX, pScrn->bitsPerPixel,
                pScrn->virtualX * pScrn->bitsPerPixel/8));

    if (!pSiS->NoAccel) {
        switch  (pSiS->Chipset)  {
            case PCI_CHIP_SIS5597:
            case PCI_CHIP_SIS6326:
            case PCI_CHIP_SIS530:
                pReg->sisRegs3C4[GraphEng] |= 0x40;
                if (pSiS->TurboQueue) {
                    pReg->sisRegs3C4[GraphEng] |= 0x80;
                                /* All Queue for 2D */
                    pReg->sisRegs3C4[ExtMiscCont9] &= 0xFC;
                    if (pSiS->HWCursor)
                        pReg->sisRegs3C4[TurboQueueBase] = (pScrn->videoRam/32) - 2;
                    else
                        pReg->sisRegs3C4[TurboQueueBase] = (pScrn->videoRam/32) - 1;
                }
                pReg->sisRegs3C4[MMIOEnable] |= 0x60; /* At PCI base */
                pReg->sisRegs3C4[Mode64] |= 0x80;
                break;
        }
    }

   /* Set memclock */
    if ((pSiS->Chipset == PCI_CHIP_SIS5597) || (pSiS->Chipset == PCI_CHIP_SIS6326)) {
      if (pSiS->MemClock > 66000) {
          SiSCalcClock(pScrn, pSiS->MemClock, 1, vclk);
  
          pReg->sisRegs3C4[MemClock0] = (vclk[Midx] - 1) & 0x7f ;
          pReg->sisRegs3C4[MemClock0] |= ((vclk[VLDidx] == 2 ) ? 1 : 0 ) << 7 ;
          pReg->sisRegs3C4[MemClock1]  = (vclk[Nidx] -1) & 0x1f ;   /* bits [4:0] contain denumerator -MC */
          if (vclk[Pidx] <= 4){
            pReg->sisRegs3C4[MemClock1] |= (vclk[Pidx] -1 ) << 5 ; /* postscale 1,2,3,4 */
            pReg->sisRegs3C4[ClockBase] &= 0x7F;
d789 37
a825 2
            pReg->sisRegs3C4[MemClock1] |= ((vclk[Pidx] / 2) -1 ) << 5 ;  /* postscale 6,8 */
            pReg->sisRegs3C4[ClockBase] |= 0x80;
d828 7
a834 42
#if 1  /* Check programmed memory clock. Enable only to check the above code */
          mclk=14318*((pReg->sisRegs3C4[MemClock0] & 0x7f)+1);
          mclk=mclk/((pReg->sisRegs3C4[MemClock1] & 0x0f)+1);
          Base = pReg->sisRegs3C4[ClockBase];
          if ( (Base & 0x80)==0 ) {
            mclk = mclk / (((pReg->sisRegs3C4[MemClock1] & 0x60) >> 5)+1);
          }  else {
            if ((pReg->sisRegs3C4[MemClock1] & 0x60) == 0x40) { mclk=mclk/6;}
            if ((pReg->sisRegs3C4[MemClock1] & 0x60) == 0x60) { mclk=mclk/8;}
          }
          xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,2,
           "Setting memory clock to %.3f MHz\n",
          mclk/1000.0);
#endif
      }
    }

    /* set threshold value */
    switch  (pSiS->Chipset)  {
        case PCI_CHIP_SIS5597:
        case PCI_CHIP_SIS6326:
            MemBand = SiSMemBandWidth(pScrn) / 10 ;
            safetymargin = 1; 
            gap          = 4;

            CRT_ENGthreshold = 0x0F;
            CRT_CPUthresholdLow = ((pScrn->depth*clock) / 
                                    MemBand)+safetymargin;
            CRT_CPUthresholdHigh =((pScrn->depth*clock) / 
                                    MemBand)+gap+safetymargin;

            if ( CRT_CPUthresholdLow > (pScrn->depth < 24 ? 0xe:0x0d) ) { 
                CRT_CPUthresholdLow = (pScrn->depth < 24 ? 0xe:0x0d); 
            }

            if ( CRT_CPUthresholdHigh > (pScrn->depth < 24 ? 0x10:0x0f) ) {
                CRT_CPUthresholdHigh = (pScrn->depth < 24 ? 0x10:0x0f);
            }

            pReg->sisRegs3C4[CPUThreshold] =  (CRT_ENGthreshold & 0x0F) | 
                            (CRT_CPUthresholdLow & 0x0F)<<4 ;
            pReg->sisRegs3C4[CRTThreshold] = CRT_CPUthresholdHigh & 0x0F;
d836 1
a836 13
            break;
        case PCI_CHIP_SIS530:
            (*pSiS->SetThreshold)(pScrn, mode, &CRT_CPUthresholdLow,
                            &CRT_CPUthresholdHigh);
            pReg->sisRegs3C4[8] = (CRT_CPUthresholdLow & 0xf) << 4 | 0xF;
            pReg->sisRegs3C4[9] &= 0xF0;
            pReg->sisRegs3C4[9] |= (CRT_CPUthresholdHigh & 0xF);
            pReg->sisRegs3C4[0x3F] &= 0xE3;
            pReg->sisRegs3C4[0x3F] |= (CRT_CPUthresholdHigh & 0x10) |
                            (CRT_CPUthresholdLow & 0x10) >> 2 |
                            0x08;
            break;
    }
d841 3
a843 6
/* TW: Initialize various regs for mode. This is done to
 *     structure, not hardware. (SiSRestore would write
 *     structure to hardware registers.)
 *     This function is not used on SiS300, 540, 630 (unless
 *     VESA is used for mode switching); on these chips,
 *     the BIOS emulation (sis_bioc.s) does the job.
d848 4
a851 8
    SISPtr  pSiS = SISPTR(pScrn);
    SISRegPtr   pReg = &pSiS->ModeReg;
    vgaRegPtr   vgaReg = &VGAHWPTR(pScrn)->ModeReg;
    int vgaIOBase;
    unsigned short  temp;
    int offset=0;
    int clock = mode->Clock;
    unsigned int    vclk[5];
d853 1
a853 2
    int num, denum, div, sbit, scale;
    unsigned short  Threshold_Low, Threshold_High;
a854 1
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4, "SIS300Init()\n");
d857 2
a858 2
        pScrn->virtualX, pScrn->bitsPerPixel,
        pScrn->virtualX * pScrn->bitsPerPixel/8);
d860 5
a864 2
    vgaHWGetIOBase(VGAHWPTR(pScrn));
    vgaIOBase = VGAHWPTR(pScrn)->IOBase;
d866 1
d869 9
a877 1
    pSiS->scrnOffset = pScrn->displayWidth * ((pScrn->bitsPerPixel+7)/8);
d879 3
a881 4
    outw(VGA_SEQ_INDEX, 0x8605);

    /* TW: The following MUST be done even with VESA */
    pReg->sisRegs3C4[6] &= ~GENMASK(4:2);
d883 1
a883 1
    switch (pScrn->bitsPerPixel) {
d886 1
a886 1
            pReg->sisRegs3C4[6] |= 0x03;
d889 3
a891 4
            if (pScrn->depth==15)  {
                pSiS->DstColor = 0x4000;
                pReg->sisRegs3C4[6] |= ((1 << 2) | 0x03);
            } else {
d893 1
a893 2
                pReg->sisRegs3C4[6] |= ((2 << 2) | 0x03);
            }
a895 1
            pReg->sisRegs3C4[6] |= ((3 << 2) | 0x03);
d899 1
a899 1
            pReg->sisRegs3C4[6] |= ((4 << 2) | 0x03);
d903 2
a904 59
    if (!pSiS->UseVESA) {	/* TW: Don't do the following when using VESA (NEW) */
    	pReg->sisRegs3D4[0x19] = 0;
    	pReg->sisRegs3D4[0x1A] &= 0xFC;

	if (mode->Flags & V_INTERLACE)  {
	        offset = pSiS->scrnOffset >> 2;
	        pReg->sisRegs3C4[0x06] |= 0x20;
	        if (pSiS->Chipset != PCI_CHIP_SIS300)  {
            	temp = (mode->CrtcHSyncStart >> 3) -
	                (mode->CrtcHTotal >> 3)/2;
            	pReg->sisRegs3D4[0x19] = GETVAR8(temp);
            	pReg->sisRegs3D4[0x1A] |= GETBITS(temp, 9:8);
        	}
    	} else  {
	        offset = pSiS->scrnOffset >> 3;
	        pReg->sisRegs3C4[0x06] &= ~0x20;
    	}

    	pReg->sisRegs3C4[0x07] |= 0x10;     	/* enable High Speed DAC */
    	pReg->sisRegs3C4[0x07] &= 0xFC;
    	if (clock < 100000)
        	pReg->sisRegs3C4[0x07] |= 0x03;
    	else if (clock < 200000)
        	pReg->sisRegs3C4[0x07] |= 0x02;
    	else if (clock < 250000)
        	pReg->sisRegs3C4[0x07] |= 0x01;

	pReg->sisRegs3C4[0x0A] = 			/* Extended Vertical Overflow */
            GETBITSTR(mode->CrtcVTotal     -2, 10:10, 0:0) |
            GETBITSTR(mode->CrtcVDisplay   -1, 10:10, 1:1) |
            GETBITSTR(mode->CrtcVBlankStart  , 10:10, 2:2) |
            GETBITSTR(mode->CrtcVSyncStart   , 10:10, 3:3) |
            GETBITSTR(mode->CrtcVBlankEnd    ,   8:8, 4:4) |
            GETBITSTR(mode->CrtcVSyncEnd     ,   4:4, 5:5) ;

    	pReg->sisRegs3C4[0x0B] = 			/* Extended Horizontal Overflow */
            GETBITSTR((mode->CrtcHTotal      >> 3) - 5, 9:8, 1:0) |
            GETBITSTR((mode->CrtcHDisplay    >> 3) - 1, 9:8, 3:2) |
            GETBITSTR((mode->CrtcHBlankStart >> 3)    , 9:8, 5:4) |
            GETBITSTR((mode->CrtcHSyncStart  >> 3)    , 9:8, 7:6) ;

    	pReg->sisRegs3C4[0x0C] &= 0xF8;
    	pReg->sisRegs3C4[0x0C] |=
            GETBITSTR(mode->CrtcHBlankEnd >> 3, 7:6, 1:0) |
            GETBITSTR(mode->CrtcHSyncEnd  >> 3, 5:5, 2:2) ;


    	vgaReg->CRTC[0x13] = GETVAR8(offset);	/* Screen Offset */
    	pReg->sisRegs3C4[0x0E] &= 0xF0;
    	pReg->sisRegs3C4[0x0E] |= GETBITS(offset, 11:8);

    	if (mode->CrtcHDisplay > 0)		/* line compare */
        	pReg->sisRegs3C4[0x0F] |= 0x08;
    	else
        	pReg->sisRegs3C4[0x0F] &= 0xF7;

    	pReg->sisRegs3C4[0x10] =
        ((mode->CrtcHDisplay *((pScrn->bitsPerPixel+7)/8) + 63) >> 6)+1;
    }	/* VESA */
d906 11
a916 59
/* TW: Enable PCI adressing (0x80) & MMIO enable (0x1) & ? (0x20) */
    pReg->sisRegs3C4[0x20] = 0xA1;
/* TW: Enable 3D accelerator & ? */
/* TW: 0x42 enables 2D accellerator (done below), 0x18 enables 3D engine */
/*  pReg->sisRegs3C4[0x1E] = 0x18; */
/* TW: !!! now done according to NoAccel setting !!! */

    if (!pSiS->UseVESA) {	/* TW: clocks have surely been set by VESA, so don't touch them now */
   	if (SiScompute_vclk(clock, &num, &denum, &div, &sbit, &scale)) {  /* Set vclk */
        	pReg->sisRegs3C4[0x2B] = (num -1) & 0x7f;
        	if (div == 2)
            		pReg->sisRegs3C4[0x2B] |= 0x80;
        	pReg->sisRegs3C4[0x2C] = ((denum -1) & 0x1f);
        	pReg->sisRegs3C4[0x2C] |= (((scale-1)&3) << 5);
        	if (sbit)
            		pReg->sisRegs3C4[0x2C] |= 0x80;
        	pReg->sisRegs3C4[0x2D] = 0x80;
    	}
    	else  {
    		/* if SiScompute_vclk cannot handle the request clock try sisCalcClock! */
        	SiSCalcClock(pScrn, clock, 2, vclk);
        	pReg->sisRegs3C4[0x2B] = (vclk[Midx] - 1) & 0x7f ;
        	pReg->sisRegs3C4[0x2B] |= ((vclk[VLDidx] == 2 ) ? 1 : 0 ) << 7 ;

        	/* bits [4:0] contain denumerator -MC */
        	pReg->sisRegs3C4[0x2C] = (vclk[Nidx] -1) & 0x1f ;

        	if (vclk[Pidx] <= 4)  {
        	/* postscale 1,2,3,4 */
            		pReg->sisRegs3C4[0x2C] |= (vclk[Pidx] -1 ) << 5 ;
            		pReg->sisRegs3C4[0x2C] &= 0x7F;
        	} else  {
        	/* postscale 6,8 */
            		pReg->sisRegs3C4[0x2C] |= ((vclk[Pidx] / 2) -1 ) << 5 ;
            		pReg->sisRegs3C4[0x2C] |= 0x80;
        	}
        	pReg->sisRegs3C4[0x2D] = 0x80;
    	} /* end of set vclk */

    	if (clock > 150000)  {  			/* enable two-pixel mode */
        	pReg->sisRegs3C4[0x07] |= 0x80;
        	pReg->sisRegs3C4[0x32] |= 0x08;
    	} else  {
        	pReg->sisRegs3C4[0x07] &= 0x7F;
        	pReg->sisRegs3C4[0x32] &= 0xF7;
    	}

    	pReg->sisRegs3C2 = inb(0x3CC) | 0x0C; 	/* Programmable Clock */
    }  /* VESA */

/* TW: Now initialize TurboQueue. TB is always located at the very top of
       the videoRAM (notably NOT the x framebuffer memory, which can/should
       be limited when using DRI)
*/
    if (!pSiS->NoAccel) {
        pReg->sisRegs3C4[0x1E] |= 0x42;  /* TW: Enable 2D accellerator */
	pReg->sisRegs3C4[0x1E] |= 0x18;  /* TW: Enable 3D accellerator */
        if (pSiS->TurboQueue)  {    		/* set Turbo Queue as 512k */
	    temp = ((pScrn->videoRam/64)-8);    /* TW: 8=512k, 4=256k, 2=128k, 1=64k */
d920 74
a993 1
        }	/* TW: line above new for saving D2&3 of state register */
d996 19
a1014 8
    if (!pSiS->UseVESA) {
	/* set threshold value */
    	(*pSiS->SetThreshold)(pScrn, mode, &Threshold_Low, &Threshold_High);
    	pReg->sisRegs3C4[0x08] = GETBITSTR(Threshold_Low, 3:0, 7:4) | 0xF;
    	pReg->sisRegs3C4[0x0F] &= ~GENMASK(5:5);
    	pReg->sisRegs3C4[0x0F] |= GETBITSTR(Threshold_Low, 4:4, 5:5);
    	pReg->sisRegs3C4[0x09] &= ~GENMASK(3:0);
    	pReg->sisRegs3C4[0x09] |= GETBITS(Threshold_High, 3:0);
d1016 155
d1172 31
a1202 1
    return(TRUE);
d1205 1
a1205 1
/* TW: Detect video bridge and set VBFlags accordingly */
d1209 20
a1228 79
    int     temp;
    char    BIOSversion[]="x.xx.xx\0";
    unsigned short usOffsetHigh, usOffsetLow, vBiosRevision;
    unsigned long   ROMAddr  = (unsigned long) SISPTR(pScrn)->BIOS;

    for (temp = 0; temp < 7; temp++) {
        BIOSversion[temp] = *((unsigned char *)(ROMAddr+temp+0x06));
    }

    xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Video BIOS version %s detected\n", BIOSversion);

    usOffsetHigh = *((unsigned char *)(ROMAddr+0x08)) - 0x30;
    usOffsetLow  = *((unsigned char *)(ROMAddr+0x09)) - 0x30;
    vBiosRevision = usOffsetHigh << 4 | usOffsetLow;
#if 0	/* TW: What's this good for? Check the BIOS revision???? That can't be correct! */
    if (vBiosRevision < 0x02) {
        outSISIDXREG(pSiS->RelIO+CROFFSET, 0x37, 0);
        inSISIDXREG(pSiS->RelIO+CROFFSET, 0x36, temp);
        temp &= 0x07;
        outSISIDXREG(pSiS->RelIO+CROFFSET, 0x36, temp);
    }
#endif
    outb(SISPART4, 0x00);
    temp = inb(SISPART4+1) & 0x0F;
    pSiS->VBFlags = 0; /*reset*/
    if (temp == 1) {
	outb(SISPART4, 0x01);	/* TW: new for 301b; support is yet incomplete */
	temp = inb(SISPART4+1) & 0xff;
	if (temp >= 0xB0) {
	        pSiS->VBFlags|=VB_301B;  /* TW: 301b */
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Detected SiS301B video bridge\n");
	} else {
	        pSiS->VBFlags|=VB_301;   /*301*/
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Detected SiS301 video bridge\n");
	}
	outb(SISPART4, 0x23);	/* TW: new */
	temp = inb(SISPART4+1) & 0xff;
	if (!(temp & 0x02))  {
	        pSiS->VBFlags|=VB_NOLCD; /* TW: flag yet unused */
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "[SiS301: NoLCD flag detected]\n");
	}
    }
    else if (temp == 2) {
        pSiS->VBFlags|=VB_302;  /*302*/
    	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Detected SiS302(B) video bridge\n");
	outb(SISPART4, 0x38);	/* TW: new; LCDA (?) support - yet incomplete */
	temp = inb(SISPART4+1) & 0xff;
	if (temp == 0x03) {
		pSiS->VBFlags|=VB_LCDA; /* TW: flag yet unused */
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		         "[SiS302: LCDA flag detected]\n");
	}
    }
    else if (temp == 3) {
        pSiS->VBFlags|=VB_303;  /*303*/
    	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Detected SiS303 video bridge\n");
    }
    else {
        outb(SISCR, 0x37);
        temp = ((inb(SISCR+1))>>1) & 0x07;
	if ((temp == 2) || (temp == 3) || (temp == 4)) {
            pSiS->VBFlags |= VB_LVDS;
    	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	             "Detected LVDS video bridge (Type %d)\n", temp);
	}
        if ((temp == 4) || (temp == 5))  {
            pSiS->VBFlags |= VB_CHRONTEL;
    	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	             "Detected CHRONTEL 7500 VGA->TV converter (Type %d)\n", temp);
	}
	if (temp == 3) {
            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	             "Detected TRUMPION TV converter. This device is not supported yet.\n");
	}
	if ((temp < 2) || (temp > 5)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	             "Detected unknown bridge type (%d)\n", temp);
	}
    }
d1234 7
d1246 403
d1650 2
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@a0 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_vga.c,v 1.43 2004/01/23 22:29:06 twini Exp $ */
d2 1
a2 1
 * Mode setup and basic video bridge detection
d4 9
a12 1
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria.
d14 7
a20 13
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement: "This product includes
 *    software developed by Thomas Winischhofer, Vienna, Austria."
 * 4) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d22 5
a26 16
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author: 	Thomas Winischhofer <thomas@@winischhofer.net>
 *
 * Init() function for old series (except for TV and FIFO calculation)
 * previously based on code which is Copyright (C) 1998,1999 by Alan
 * Hourihane, Wigan, England
d28 1
d41 13
a53 3
#if 0
#define TV6326TEST
#endif
a54 85
static Bool  SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode);
static Bool  SIS300Init(ScrnInfoPtr pScrn, DisplayModePtr mode);
/* To be used internally only */
static int   SISDoSense(ScrnInfoPtr pScrn, int tempbl, int tempbh, int tempcl, int tempch);
static void  SISSense30x(ScrnInfoPtr pScrn);
static int   SIS6326DoSense(ScrnInfoPtr pScrn, int tempbh, int tempbl, int tempch, int tempcl);
static void  SISSense6326(ScrnInfoPtr pScrn);
static void  SiS6326TVDelay(ScrnInfoPtr pScrn, int delay);

const CARD8 SiS6326TVRegs1[14] = {
     0x00,0x01,0x02,0x03,0x04,0x11,0x12,0x13,0x21,0x26,0x27,0x3a,0x3c,0x43
};

const CARD8 SiS6326TVRegs1_NTSC[6][14] = {
    {0x81,0x3f,0x49,0x1b,0xa9,0x03,0x00,0x09,0x08,0x7d,0x00,0x88,0x30,0x60},
    {0x81,0x3f,0x49,0x1d,0xa0,0x03,0x00,0x09,0x08,0x7d,0x00,0x88,0x30,0x60},
    {0x81,0x45,0x24,0x8e,0x26,0x0b,0x00,0x09,0x02,0xfe,0x00,0x09,0x51,0x60},
    {0x81,0x45,0x24,0x8e,0x26,0x07,0x00,0x29,0x04,0x30,0x10,0x3b,0x61,0x60},
    {0x81,0x3f,0x24,0x8e,0x26,0x09,0x00,0x09,0x02,0x30,0x10,0x3b,0x51,0x60},  /* 640x400, 640x480 */
    {0x83,0x5d,0x21,0xbe,0x75,0x03,0x00,0x09,0x08,0x42,0x10,0x4d,0x61,0x79}   /* 640x480u */
};

#ifdef TV6326TEST
const CARD8 SiS6326TVRegs1_NTSC_2[6][3] = {
    {          0x00,0x00,0x00},
    {          0x00,0x00,0x00},
    {          0x24,0x92,0x49},
    {          0x24,0x92,0x49},  			/* 8a50 */
    {          0x24,0x92,0x49},  /* 640x400, 640x480 */ /* 8afc */
    {          0x21,0xbe,0x75}   /* 640x480u */         /* n/a  */
};
#endif

const CARD8 SiS6326TVRegs2_NTSC[6][54] = {
    {0x11, 0x17, 0x03, 0x09, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
     0x0C, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xFC, 0xDF, 0x94, 0x1F, 0x4A, 0x03, 0x71, 0x07, 0x97, 0x10, 0x40,
     0x48, 0x00, 0x26, 0xB6, 0x10, 0x5C, 0xEC, 0x21, 0x2E, 0xBE, 0x10,
     0x64, 0xF4, 0x21, 0x13, 0x75, 0x08, 0x31, 0x6A, 0x01, 0xA0},
    {0x11, 0x17, 0x03, 0x0A, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
     0x0D, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xFF, 0xDF, 0x94, 0x1F, 0x4A, 0x03, 0x71, 0x07, 0x97, 0x10, 0x40,
     0x48, 0x00, 0x26, 0xB6, 0x10, 0x5C, 0xEC, 0x21, 0x2E, 0xBE, 0x10,
     0x64, 0xF4, 0x21, 0x13, 0x75, 0x08, 0x31, 0x6A, 0x01, 0xA0},
    {0x11, 0x17, 0x03, 0x0A, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
     0x0D, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xFF, 0xDF, 0x94, 0x3F, 0x8C, 0x06, 0xCE, 0x07, 0x27, 0x30, 0x73,
     0x7B, 0x00, 0x48, 0x68, 0x30, 0xB2, 0xD2, 0x52, 0x50, 0x70, 0x30,
     0xBA, 0xDA, 0x52, 0xDC, 0x02, 0xD1, 0x53, 0xF7, 0x02, 0xA0},
    {0x11, 0x17, 0x03, 0x09, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
     0x0C, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xDC, 0xDF, 0x94, 0x3F, 0x8C, 0x06, 0xCE, 0x07, 0x27, 0x30, 0x73,
     0x7B, 0x00, 0x48, 0x68, 0x30, 0xB2, 0xD2, 0x52, 0x50, 0x70, 0x30,
     0xBA, 0xDA, 0x52, 0x00, 0x02, 0xF5, 0x53, 0xF7, 0x02, 0xA0},
    {0x11, 0x17, 0x03, 0x09, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
     0x0C, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xDC, 0xDF, 0x94, 0x3F, 0x8C, 0x06, 0xCE, 0x07, 0x27, 0x30, 0x73,
     0x7B, 0x00, 0x48, 0x68, 0x30, 0xB2, 0xD2, 0x52, 0x50, 0x70, 0x30,
     0xBA, 0xDA, 0x52, 0xDC, 0x02, 0xD1, 0x53, 0xF7, 0x02, 0xA0},
    {0x11, 0x17, 0x03, 0x09, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,  /* 640x480u */
     0x0C, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xDC, 0xDF, 0x94, 0xAF, 0x95, 0x06, 0xDD, 0x07, 0x5F, 0x30, 0x7E,
     0x86, 0x00, 0x4C, 0xA4, 0x30, 0xE3, 0x3B, 0x62, 0x54, 0xAC, 0x30,
     0xEB, 0x43, 0x62, 0x48, 0x34, 0x3D, 0x63, 0x29, 0x03, 0xA0}
};

const CARD8 SiS6326TVRegs1_PAL[6][14] = {
    {0x81,0x2d,0xc8,0x07,0xb2,0x0b,0x00,0x09,0x02,0xed,0x00,0xf8,0x30,0x40},
    {0x80,0x2d,0xa4,0x03,0xd9,0x0b,0x00,0x09,0x02,0xed,0x10,0xf8,0x71,0x40},
    {0x81,0x2d,0xa4,0x03,0xd9,0x0b,0x00,0x09,0x02,0xed,0x10,0xf8,0x71,0x40},  /* 640x480 */
    {0x81,0x2d,0xa4,0x03,0xd9,0x0b,0x00,0x09,0x02,0x8f,0x10,0x9a,0x71,0x40},  /* 800x600 */
    {0x83,0x63,0xa1,0x7a,0xa3,0x0a,0x00,0x09,0x02,0xb5,0x11,0xc0,0x81,0x59},  /* 800x600u */
    {0x81,0x63,0xa4,0x03,0xd9,0x01,0x00,0x09,0x10,0x9f,0x10,0xaa,0x71,0x59}   /* 720x540  */
};

#ifdef TV6326TEST
const CARD8 SiS6326TVRegs1_PAL_2[6][3] = {
    {          0x00,0x00,0x00},
    {          0x00,0x00,0x00},
    {          0xa4,0x07,0xd9},   /* 640x480  */  /* 887e */
    {          0xa4,0x08,0x19},   /* 800x600  */  /* 8828 */
    {          0xa1,0x7e,0xa3},   /* 800x600u */  /* n/a  */
    {          0xa4,0x07,0xd9}    /* 720x540  */  /* n/a  */
};
#endif
d56 3
a58 45
const CARD8 SiS6326TVRegs2_PAL[6][54] = {
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0xEF, 0x5A, 0x03, 0x7F, 0x07, 0xFF, 0x10, 0x4E,
     0x56, 0x00, 0x2B, 0x23, 0x20, 0xB4, 0xAC, 0x31, 0x33, 0x2B, 0x20,
     0xBC, 0xB4, 0x31, 0x83, 0xE1, 0x78, 0x31, 0xD6, 0x01, 0xA0},
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0xDF, 0xB2, 0x07, 0xFB, 0x07, 0xF7, 0x30, 0x90,
     0x98, 0x00, 0x4F, 0x3F, 0x40, 0x62, 0x52, 0x73, 0x57, 0x47, 0x40,
     0x6A, 0x5A, 0x73, 0x03, 0xC1, 0xF8, 0x63, 0xB6, 0x03, 0xA0},
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,  /* 640x480 */
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0xDF, 0xB2, 0x07, 0xFB, 0x07, 0xF7, 0x30, 0x90,
     0x98, 0x00, 0x4F, 0x3F, 0x40, 0x62, 0x52, 0x73, 0x57, 0x47, 0x40,
     0x6A, 0x5A, 0x73, 0x03, 0xC1, 0xF8, 0x63, 0xB6, 0x03, 0xA0},
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,  /* 800x600 */
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0xDF, 0xB2, 0x07, 0xFB, 0x07, 0xF7, 0x30, 0x90,
     0x98, 0x00, 0x4F, 0x3F, 0x40, 0x62, 0x52, 0x73, 0x57, 0x47, 0x40,
     0x6A, 0x5A, 0x73, 0xA0, 0xC1, 0x95, 0x73, 0xB6, 0x03, 0xA0},
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,  /* 800x600u */
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0x7F, 0xBD, 0x08, 0x0E, 0x07, 0x47, 0x40, 0x9D,
     0xA5, 0x00, 0x54, 0x94, 0x40, 0xA4, 0xE4, 0x73, 0x5C, 0x9C, 0x40,
     0xAC, 0xEC, 0x73, 0x0B, 0x0E, 0x00, 0x84, 0x03, 0x04, 0xA0},
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,  /* 720x540  */
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0xDF, 0xB0, 0x07, 0xFB, 0x07, 0xF7, 0x30, 0x9D,
     0xA5, 0x00, 0x4F, 0x3F, 0x40, 0x62, 0x52, 0x73, 0x57, 0x47, 0x40,
     0x6A, 0x5A, 0x73, 0xA0, 0xC1, 0x95, 0x73, 0xB6, 0x03, 0xA0}
};


const CARD8 SiS6326CR[9][15] = {
     {0x79,0x63,0x64,0x1d,0x6a,0x93,0x00,0x6f,0xf0,0x58,0x8a,0x57,0x57,0x70,0x20},  /* PAL 800x600   */
     {0x79,0x4f,0x50,0x95,0x60,0x93,0x00,0x6f,0xba,0x14,0x86,0xdf,0xe0,0x30,0x00},  /* PAL 640x480   */
     {0x5f,0x4f,0x50,0x82,0x53,0x9f,0x00,0x0b,0x3e,0xe9,0x8b,0xdf,0xe7,0x04,0x00},  /* NTSC 640x480  */
     {0x5f,0x4f,0x50,0x82,0x53,0x9f,0x00,0x0b,0x3e,0xcb,0x8d,0x8f,0x96,0xe9,0x00},  /* NTSC 640x400  */
     {0x83,0x63,0x64,0x1f,0x6d,0x9b,0x00,0x6f,0xf0,0x48,0x0a,0x23,0x57,0x70,0x20},  /* PAL 800x600u  */
     {0x79,0x59,0x5b,0x1d,0x66,0x93,0x00,0x6f,0xf0,0x42,0x04,0x1b,0x40,0x70,0x20},  /* PAL 720x540   */
     {0x66,0x4f,0x51,0x0a,0x57,0x89,0x00,0x0b,0x3e,0xd9,0x0b,0xb6,0xe7,0x04,0x00},  /* NTSC 640x480u */
     {0xce,0x9f,0x9f,0x92,0xa4,0x16,0x00,0x28,0x5a,0x00,0x04,0xff,0xff,0x29,0x39},  /* 1280x1024-75  */
     {0x09,0xc7,0xc7,0x0d,0xd2,0x0a,0x01,0xe0,0x10,0xb0,0x04,0xaf,0xaf,0xe1,0x1f}   /* 1600x1200-60  */
};
a59 1
/* Initialize a display mode on 5597/5598, 6326 and 530/620 */
d63 15
a77 19
    SISPtr         pSiS = SISPTR(pScrn);
    SISRegPtr      pReg = &pSiS->ModeReg;
    vgaRegPtr      vgaReg = &VGAHWPTR(pScrn)->ModeReg;
    unsigned char  temp;
    int            mclk = pSiS->MemClock;
    int            offset;
    int            clock = mode->Clock;
    int            width = mode->HDisplay;
    int            height = mode->VDisplay;
    int            rate = SiSCalcVRate(mode);
    int            buswidth = pSiS->BusWidth;
    unsigned int   vclk[5];
    unsigned short CRT_CPUthresholdLow;
    unsigned short CRT_CPUthresholdHigh;
    unsigned short CRT_ENGthreshold;
    double         a, b, c;
    int            d, factor;
    int            num, denum, div, sbit, scale;
    BOOL	   sis6326tvmode, sis6326himode;
d80 2
a82 1
    /* Save the registers for further processing */
d85 1
a85 25
    /* Determine if chosen mode is suitable for TV on the 6326
     * and if the mode is one of our special hi-res modes.
     */
    sis6326tvmode = FALSE;
    sis6326himode = FALSE;
    if(pSiS->Chipset == PCI_CHIP_SIS6326) {
       if(pSiS->SiS6326Flags & SIS6326_HASTV) {
          if((pSiS->SiS6326Flags & SIS6326_TVDETECTED) &&
             ((strcmp(mode->name, "PAL800x600") == 0)   ||	/* Special TV modes */
              (strcmp(mode->name, "PAL800x600U") == 0)  ||
	      (strcmp(mode->name, "PAL720x540") == 0)   ||
              (strcmp(mode->name, "PAL640x480") == 0)   ||
	      (strcmp(mode->name, "NTSC640x480") == 0)  ||
	      (strcmp(mode->name, "NTSC640x480U") == 0) ||
	      (strcmp(mode->name, "NTSC640x400") == 0))) {
	     sis6326tvmode = TRUE;
          } else {
             pReg->sis6326tv[0x00] &= 0xfb;
          }
       }
       if((strcmp(mode->name, "SIS1280x1024-75") == 0) ||	/* Special high-res modes */
          (strcmp(mode->name, "SIS1600x1200-60") == 0)) {
	  sis6326himode = TRUE;
       }
    }
d87 1
a87 3
#ifdef UNLOCK_ALWAYS
    outSISIDXREG(SISSR, 0x05, 0x86);
#endif
d89 8
a96 2
    if(!pSiS->UseVESA) {
       pReg->sisRegs3C4[0x06] &= 0x01;
d99 11
a109 8
    /* set interlace */
    if(!(mode->Flags & V_INTERLACE))  {
       offset = pSiS->CurrentLayout.displayWidth >> 3;
    } else  {
       offset = pSiS->CurrentLayout.displayWidth >> 2;
       if(!pSiS->UseVESA) {
          pReg->sisRegs3C4[0x06] |= 0x20;
       }
d112 26
a137 3
    /* Enable Linear and Enhanced Gfx Mode */
    if(!pSiS->UseVESA) {
       pReg->sisRegs3C4[0x06] |= 0x82;
d139 18
a156 7

    /* Enable MMIO at PCI Register 14H (D[6:5]: 11) */
    if(pSiS->oldChipset >= OC_SIS5597) {
       pReg->sisRegs3C4[0x0B] |= 0x60;
    } else {
       pReg->sisRegs3C4[0x0B] |= 0x20;
       pReg->sisRegs3C4[0x0B] &= ~0x40;
d158 13
a170 57

    if(!pSiS->UseVESA) {

       /* Enable 32bit mem access (D7), read-ahead cache (D5) */
       pReg->sisRegs3C4[0x0C] |= 0x80;
       if(pSiS->oldChipset > OC_SIS6225) {
          pReg->sisRegs3C4[0x0C] |= 0x20;
       }

       /* Some speed-up stuff */
       switch(pSiS->Chipset) {
       case PCI_CHIP_SIS5597:
          /* enable host bus */
	  if(pSiS->NoHostBus) {
	     pReg->sisRegs3C4[0x34] &= ~0x08;
	  } else {
            pReg->sisRegs3C4[0x34] |= 0x08;
	  }
          /* fall through */
       case PCI_CHIP_SIS6326:
       case PCI_CHIP_SIS530:
          /* Enable "dual segment register mode" (D2) and "i/o gating while
           * write buffer is not empty" (D3)
           */
    	  pReg->sisRegs3C4[0x0B] |= 0x0C;
       }

       /* set colordepth */
       if(pSiS->Chipset == PCI_CHIP_SIS530) {
          pReg->sisRegs3C4[0x09] &= 0x7F;
       }
       switch(pSiS->CurrentLayout.bitsPerPixel) {
          case 8:
             break;
          case 16:
	     offset <<= 1;
	     if(pSiS->CurrentLayout.depth == 15)
	        pReg->sisRegs3C4[0x06] |= 0x04;
	     else
                pReg->sisRegs3C4[0x06] |= 0x08;
             break;
          case 24:
             offset += (offset << 1);
             pReg->sisRegs3C4[0x06] |= 0x10;
             pReg->sisRegs3C4[0x0B] |= 0x90;
             break;
          case 32:
             if(pSiS->Chipset == PCI_CHIP_SIS530) {
	        offset <<= 2;
	        if(pSiS->oldChipset != OC_SIS620) {
                   pReg->sisRegs3C4[0x06] |= 0x10;
	        }
                pReg->sisRegs3C4[0x0B] |= 0x90;
                pReg->sisRegs3C4[0x09] |= 0x80;
             } else return FALSE;
             break;
       }
d173 90
a262 110
    /* save screen pitch for acceleration functions */
    pSiS->scrnOffset = pSiS->CurrentLayout.displayWidth *
                           ((pSiS->CurrentLayout.bitsPerPixel + 7) / 8);

    if(!pSiS->UseVESA) {

       /* set linear framebuffer addresses */
       switch(pScrn->videoRam)  {
          case 512:  temp = 0x00;  break;
          case 1024: temp = 0x20;  break;
          case 2048: temp = 0x40;  break;
          case 4096: temp = 0x60;  break;
          case 8192: temp = 0x80;  break;
          default:   temp = 0x20;
       }
       pReg->sisRegs3C4[0x20] = (pSiS->FbAddress & 0x07F80000) >> 19;
       pReg->sisRegs3C4[0x21] = ((pSiS->FbAddress & 0xF8000000) >> 27) | temp;

       /* Set screen offset */
       vgaReg->CRTC[0x13] = offset & 0xFF;

       /* Set CR registers for our built-in TV and hi-res modes */
       if((sis6326tvmode) || (sis6326himode)) {

	  int index,i;

	  /* We need our very private data for hi-res and TV modes */
	  if(sis6326himode) {
	     if(strcmp(mode->name, "SIS1280x1024-75") == 0)  index = 7;
	     else index = 8;
	  } else {
	     if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
	        switch(width) {
	        case 800:
	           if((strcmp(mode->name, "PAL800x600U") == 0))
	      	      index = 4;
	           else
	              index = 0;
	           break;
	        case 720:
	           index = 5;
	           break;
	        case 640:
	        default:
	           index = 1;
	        }
	     } else {
	        switch(height) {
	        case 400:
	           index = 3;
	           break;
	        case 480:
	        default:
	           if((strcmp(mode->name, "NTSC640x480U") == 0))
	              index = 6;
	           else
	              index = 2;
	        }
	     }
          }
	  for(i=0; i<=5; i++) {
	     vgaReg->CRTC[i] = SiS6326CR[index][i];
	  }
          pReg->sisRegs3C4[0x12] = SiS6326CR[index][6];
	  vgaReg->CRTC[6] = SiS6326CR[index][7];
	  vgaReg->CRTC[7] = SiS6326CR[index][8];
	  vgaReg->CRTC[0x10] = SiS6326CR[index][9];
	  vgaReg->CRTC[0x11] = SiS6326CR[index][10];
	  vgaReg->CRTC[0x12] = SiS6326CR[index][11];
	  vgaReg->CRTC[0x15] = SiS6326CR[index][12];
	  vgaReg->CRTC[0x16] = SiS6326CR[index][13];
	  vgaReg->CRTC[9] &= ~0x20;
	  vgaReg->CRTC[9] |= (SiS6326CR[index][14] & 0x20);
	  pReg->sisRegs3C4[0x0A] = ((offset & 0xF00) >> 4) | (SiS6326CR[index][14] & 0x0f);

       } else {

          /* Set extended vertical overflow register */
          pReg->sisRegs3C4[0x0A] = ((offset & 0xF00) >> 4) |
                 (((mode->CrtcVTotal-2)     & 0x400) >> 10 ) |
                 (((mode->CrtcVDisplay-1)   & 0x400) >>  9 ) |
/*               (((mode->CrtcVSyncStart-1) & 0x400) >>  8 ) |  */
	         (((mode->CrtcVBlankStart-1)& 0x400) >>  8 ) |
/*               (((mode->CrtcVBlankStart-1)& 0x400) >>  7 );  */
                 (((mode->CrtcVSyncStart)   & 0x400) >>  7 );

          /* Set extended horizontal overflow register */
          pReg->sisRegs3C4[0x12] &= 0xE0;
          pReg->sisRegs3C4[0x12] |= (
              (((mode->CrtcHTotal >> 3) - 5)      & 0x100) >> 8 |
              (((mode->CrtcHDisplay >> 3) - 1)    & 0x100) >> 7 |
/*            (((mode->CrtcHSyncStart >> 3) - 1)  & 0x100) >> 6 |  */
              (((mode->CrtcHBlankStart >> 3) - 1) & 0x100) >> 6 |
              ((mode->CrtcHSyncStart >> 3)        & 0x100) >> 5 |
              (((mode->CrtcHBlankEnd >> 3) - 1)   & 0x40)  >> 2);
       }

#ifdef TWDEBUG
       xf86DrvMsg(0, X_INFO, "HDisplay %d HSyncStart %d HSyncEnd %d HTotal %d\n",
		mode->CrtcHDisplay, mode->CrtcHSyncStart,
		mode->CrtcHSyncEnd, mode->CrtcHTotal);
       xf86DrvMsg(0, X_INFO, "HBlankSt %d  HBlankE %d\n",
    		mode->CrtcHBlankStart, mode->CrtcHBlankEnd);

       xf86DrvMsg(0, X_INFO, "VDisplay %d VSyncStart %d VSyncEnd %d VTotal %d\n",
		mode->CrtcVDisplay, mode->CrtcVSyncStart,
		mode->CrtcVSyncEnd, mode->CrtcVTotal);
       xf86DrvMsg(0, X_INFO, "VBlankSt %d  VBlankE %d\n",
    		mode->CrtcVBlankStart, mode->CrtcVBlankEnd);
#endif
d264 66
a329 45
       /* enable (or disable) line compare */
       if(mode->CrtcVDisplay >= 1024)
          pReg->sisRegs3C4[0x38] |= 0x04;
       else
          pReg->sisRegs3C4[0x38] &= 0xFB;

       /* Enable (or disable) high speed DCLK (some 6326 and 530/620 only) */
       if( ( (pSiS->Chipset == PCI_CHIP_SIS6326) &&
             ( (pSiS->ChipRev == 0xd0) || (pSiS->ChipRev == 0xd1) ||
               (pSiS->ChipRev == 0xd2) || (pSiS->ChipRev == 0x92) ||
	       (pSiS->Flags & A6326REVAB) ) ) ||
           (pSiS->oldChipset > OC_SIS6326) ) {
         if( (pSiS->CurrentLayout.bitsPerPixel == 24) ||
             (pSiS->CurrentLayout.bitsPerPixel == 32) ||
             (mode->CrtcHDisplay >= 1280) )
            pReg->sisRegs3C4[0x3E] |= 0x01;
         else
            pReg->sisRegs3C4[0x3E] &= 0xFE;
       }

       /* We use the internal VCLK */
       pReg->sisRegs3C4[0x38] &= 0xFC;

       /* Programmable Clock */
       pReg->sisRegs3C2 = inb(SISMISCR) | 0x0C;

       if(pSiS->oldChipset <= OC_SIS86202) {
          /* TODO: Handle SR07 for clock selection */
	  /* 86C201 does not even have a programmable clock... */
	  /* pReg->sisRegs3C4[0x07] &= 0x??; */
       }

       /* Set VCLK */
       if((sis6326tvmode) || (sis6326himode)) {

          /* For our built-in modes, the calculation is not suitable */
          if(sis6326himode) {
             if((strcmp(mode->name, "SIS1280x1024-75") == 0)) {
	        pReg->sisRegs3C4[0x2A] = 0x5d;	/* 1280x1024-75 */
                pReg->sisRegs3C4[0x2B] = 0xa4;
             } else {
	        pReg->sisRegs3C4[0x2A] = 0x59;	/* 1600x1200-60 */
                pReg->sisRegs3C4[0x2B] = 0xa3;
             }
	     pReg->sisRegs3C4[0x13] &= ~0x40;
d331 2
a332 21
             if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
	        /* PAL: 31.500 Mhz */
	        if((strcmp(mode->name, "PAL800x600U") == 0)) {
   	           pReg->sisRegs3C4[0x2A] = 0x46;
                   pReg->sisRegs3C4[0x2B] = 0x49;
	        } else {
	           pReg->sisRegs3C4[0x2A] = 0xab;
                   pReg->sisRegs3C4[0x2B] = 0xe9;
	        }
	        pReg->sisRegs3C4[0x13] &= ~0x40;
	     } else {
	        /* NTSC: 27.000 Mhz */
	        if((strcmp(mode->name, "NTSC640x480U") == 0)) {
	           pReg->sisRegs3C4[0x2A] = 0x5a;
                   pReg->sisRegs3C4[0x2B] = 0x65;
	        } else {
	           pReg->sisRegs3C4[0x2A] = 0x29;
                   pReg->sisRegs3C4[0x2B] = 0xe2;
	        }
	        pReg->sisRegs3C4[0x13] |= 0x40;
	     }
d335 42
a376 1
       } else if(SiS_compute_vclk(clock, &num, &denum, &div, &sbit, &scale)) {
d378 12
a389 102
          pReg->sisRegs3C4[0x2A] = (num - 1) & 0x7f ;
          pReg->sisRegs3C4[0x2A] |= (div == 2) ? 0x80 : 0;
          pReg->sisRegs3C4[0x2B] = ((denum - 1) & 0x1f);
          pReg->sisRegs3C4[0x2B] |= (((scale -1) & 3) << 5);

	  /* When setting VCLK, we should set SR13 first */
          if(sbit)
             pReg->sisRegs3C4[0x13] |= 0x40;
          else
             pReg->sisRegs3C4[0x13] &= 0xBF;

#ifdef TWDEBUG
	  xf86DrvMsg(0, X_INFO, "2a: %x 2b: %x 13: %x clock %d\n",
		pReg->sisRegs3C4[0x2A], pReg->sisRegs3C4[0x2B], pReg->sisRegs3C4[0x13], clock);
#endif

       } else {

          /* if SiS_compute_vclk cannot handle the requested clock, try sisCalcClock */
          SiSCalcClock(pScrn, clock, 2, vclk);

#define Midx    0
#define Nidx    1
#define VLDidx  2
#define Pidx    3
#define PSNidx  4	  

          pReg->sisRegs3C4[0x2A] = (vclk[Midx] - 1) & 0x7f;
          pReg->sisRegs3C4[0x2A] |= ((vclk[VLDidx] == 2) ? 1 : 0) << 7;

	  /* bits [4:0] contain denumerator */
          pReg->sisRegs3C4[0x2B] = (vclk[Nidx] - 1) & 0x1f;

          if(vclk[Pidx] <= 4){
             /* postscale 1,2,3,4 */
             pReg->sisRegs3C4[0x2B] |= (vclk[Pidx] - 1) << 5;
             pReg->sisRegs3C4[0x13] &= 0xBF;
          } else {
             /* postscale 6,8 */
             pReg->sisRegs3C4[0x2B] |= ((vclk[Pidx] / 2) - 1) << 5;
             pReg->sisRegs3C4[0x13] |= 0x40;
          }
          pReg->sisRegs3C4[0x2B] |= 0x80 ;   /* gain for high frequency */

       }

       /* High speed DAC */
       if(clock > 135000)
          pReg->sisRegs3C4[0x07] |= 0x02;

       if(pSiS->oldChipset > OC_SIS6225) {
          /* 1 or 2 cycle DRAM (set by option FastVram) */
          if(pSiS->newFastVram == -1) {
             if(pSiS->oldChipset == OC_SIS620) {
	        /* Use different default on the 620 */
                pReg->sisRegs3C4[0x34] |= 0x40;
	        pReg->sisRegs3C4[0x34] &= ~0x80;
             } else {
                pReg->sisRegs3C4[0x34] |= 0x80;
	        pReg->sisRegs3C4[0x34] &= ~0x40;
             }
          } else if(pSiS->newFastVram == 1)
             pReg->sisRegs3C4[0x34] |= 0xC0;
          else
             pReg->sisRegs3C4[0x34] &= ~0xC0;

          if(pSiS->oldChipset == OC_SIS620) {
             /* Enable SGRAM burst timing (= bit clear) on the 620 */
             if(pSiS->Flags & SYNCDRAM) {
                pReg->sisRegs3C4[0x35] &= ~0x20;
             } else {
                pReg->sisRegs3C4[0x35] |= 0x20;
             }
          }
       }

    } /* VESA */

    /* Logical line length */
    pSiS->ValidWidth = TRUE;
    pReg->sisRegs3C4[0x27] &= 0xCF;
    if(pSiS->CurrentLayout.bitsPerPixel == 24) {
         /* Invalid logical width */
         pReg->sisRegs3C4[0x27] |= 0x30;
         pSiS->ValidWidth = FALSE;
    } else {
	 switch(pScrn->virtualX * (pSiS->CurrentLayout.bitsPerPixel >> 3)) {
         case 1024:
               pReg->sisRegs3C4[0x27] |= 0x00;
               break;
         case 2048:
               pReg->sisRegs3C4[0x27] |= 0x10;
               break;
         case 4096:
               pReg->sisRegs3C4[0x27] |= 0x20;
               break;
         default:
               /* Invalid logical width */
               pReg->sisRegs3C4[0x27] |= 0x30;
               pSiS->ValidWidth = FALSE;
               break;
         }
a391 263
    /* Acceleration stuff */
    if(!pSiS->NoAccel) {
       pReg->sisRegs3C4[0x27] |= 0x40;   /* Enable engine programming registers */
       if( (pSiS->TurboQueue) &&	 /* Handle TurboQueue */
           (pSiS->oldChipset > OC_SIS6225) &&
 	   ( (pSiS->Chipset != PCI_CHIP_SIS530) ||
	     (pSiS->CurrentLayout.bitsPerPixel != 24) ) ) {
          pReg->sisRegs3C4[0x27] |= 0x80;        /* Enable TQ */
	  if((pSiS->Chipset == PCI_CHIP_SIS530) ||
	     ((pSiS->Chipset == PCI_CHIP_SIS6326 &&
	      (pSiS->ChipRev == 0xd0 || pSiS->ChipRev == 0xd1 ||
	       pSiS->ChipRev == 0xd2 || pSiS->ChipRev == 0x92 ||
	       pSiS->ChipRev == 0x0a || pSiS->ChipRev == 0x1a ||
	       pSiS->ChipRev == 0x2a || pSiS->ChipRev == 0x0b ||
	       pSiS->ChipRev == 0x1b || pSiS->ChipRev == 0x2b) ) ) ) {
	     /* pReg->sisRegs3C4[0x3D] |= 0x80;  */     /* Queue is 62K (530/620 specs) */
	     pReg->sisRegs3C4[0x3D] &= 0x7F;         /* Queue is 30K (530/620 specs) */
	  }
	  /* Locate the TQ at the beginning of the last 64K block of
	   * video RAM. The address is to be specified in 32K steps.
	   */
	  pReg->sisRegs3C4[0x2C] = (pScrn->videoRam - 64) / 32;
	  if(pSiS->Chipset != PCI_CHIP_SIS530) {	/* 530/620: Reserved (don't touch) */
    	     pReg->sisRegs3C4[0x3C] &= 0xFC; 		/* 6326: Queue is all for 2D */
	  }						/* 5597: Must be 0           */
       } else {
	  pReg->sisRegs3C4[0x27] &= 0x7F;
       }
    }


    if(!pSiS->UseVESA) {

       /* TW: No idea what this does. The Windows driver does it, so we do it as well */
       if(pSiS->Chipset == PCI_CHIP_SIS6326) {
          if((pSiS->ChipRev == 0xd0) || (pSiS->ChipRev == 0xd1) ||
             (pSiS->ChipRev == 0xd2) || (pSiS->ChipRev == 0x92) ||
	     (pSiS->Flags & A6326REVAB)) {
	     if((pSiS->Flags & (SYNCDRAM | RAMFLAG)) == (SYNCDRAM | RAMFLAG)) {
	        if(!(pReg->sisRegs3C4[0x0E] & 0x03)) {
	           pReg->sisRegs3C4[0x3E] |= 0x02;
	        }
	     }
          }
       }

       /* Set memclock */
#if 0
       /* We don't need to do this; the SetMClk option was not used since 4.0. */
       if((pSiS->Chipset == PCI_CHIP_SIS5597) || (pSiS->Chipset == PCI_CHIP_SIS6326)) {
          if(pSiS->MemClock > 66000) {
             SiSCalcClock(pScrn, pSiS->MemClock, 1, vclk);

             pReg->sisRegs3C4[0x28] = (vclk[Midx] - 1) & 0x7f ;
             pReg->sisRegs3C4[0x28] |= ((vclk[VLDidx] == 2 ) ? 1 : 0 ) << 7 ;
             pReg->sisRegs3C4[0x29] = (vclk[Nidx] -1) & 0x1f ;   /* bits [4:0] contain denumerator -MC */
             if(vclk[Pidx] <= 4) {
                pReg->sisRegs3C4[0x29] |= (vclk[Pidx] - 1) << 5 ; /* postscale 1,2,3,4 */
                pReg->sisRegs3C4[0x13] &= 0x7F;
             } else {
                pReg->sisRegs3C4[0x29] |= ((vclk[Pidx] / 2) - 1) << 5 ;  /* postscale 6,8 */
                pReg->sisRegs3C4[0x13] |= 0x80;
             }
             /* Check programmed memory clock. Enable only to check the above code */
/*
             mclk = 14318 * ((pReg->sisRegs3C4[0x28] & 0x7f) + 1);
             mclk /= ((pReg->sisRegs3C4[0x29] & 0x0f) + 1);
             if(!(pReg->sisRegs3C4[0x13] & 0x80)) {
                mclk /= (((pReg->sisRegs3C4[0x29] & 0x60) >> 5) + 1);
             } else {
                if((pReg->sisRegs3C4[0x29] & 0x60) == 0x40) mclk /= 6;
                if((pReg->sisRegs3C4[0x29] & 0x60) == 0x60) mclk /= 8;
             }
             xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,2,
                 "Setting memory clock to %.3f MHz\n",
                 mclk/1000.0);
*/
          }
       }
#endif

       /* Set threshold values */
       /*
        * CPU/CRT Threshold:                     FIFO
        *                           MCLK     ___________      VCLK
        * cpu/engine <---o       o--------->|___________| -----------> CRT
        *                ^       ^            ^       ^
        *                 \     /             |       |
        *                  \   /              |< gap >|
        *                   \ /               |       |
        *           selector switch   Thrsh. low     high
        *
        * CRT consumes the data in the FIFO during scanline display. When the
        * amount of data in the FIFO reaches the Threshold low value, the selector
        * switch will switch to the right, and the FIFO will be refilled with data.
        * When the amount of data in the FIFO reaches the Threshold high value, the
        * selector switch will switch to the left and allows the CPU and the chip
        * engines to access the video RAM.
        *
        * The Threshold low values should be increased at higher bpps, simply because
        * there is more data needed for the CRT. When Threshold low and high are very
        * close to each other, the selector switch will be activated more often, which
        * decreases performance.
        *
        */
       switch(pSiS->Chipset) {
       case PCI_CHIP_SIS5597:  factor = 65; break;
       case PCI_CHIP_SIS6326:  factor = 30; break;
       case PCI_CHIP_SIS530:   factor = (pSiS->Flags & UMA) ? 60 : 30; break;
       default:                factor = (pScrn->videoRam > 1024) ? 24 : 12;
       }
       a = width * height * rate * 1.40 * factor * ((pSiS->CurrentLayout.bitsPerPixel + 1) / 8);
       b = (mclk / 1000) * 999488.0 * (buswidth / 8);
       c = ((a / b) + 1.0) / 2;
       d = (int)c + 2;

#ifdef TWDEBUG
       xf86DrvMsg(0, X_INFO,
          "Debug: w %d h %d r %d mclk %d bus %d factor %d bpp %d\n",
          width, height, rate, mclk/1000, buswidth, factor,
          pSiS->CurrentLayout.bitsPerPixel);
       xf86DrvMsg(0, X_INFO, "Debug: a %f b %f c %f d %d (flags %x)\n",
     	  a, b, c, d, pSiS->Flags);
#endif

       CRT_CPUthresholdLow = d;
       if((pSiS->Flags & (RAMFLAG | SYNCDRAM)) == (RAMFLAG | SYNCDRAM)) {
          CRT_CPUthresholdLow += 2;
       }
       CRT_CPUthresholdHigh = CRT_CPUthresholdLow + 3;

       CRT_ENGthreshold = 0x0F;

#ifdef TWDEBUG
       xf86DrvMsg(0, X_INFO, "Debug: Thlow %d thhigh %d\n",
     	  CRT_CPUthresholdLow, CRT_CPUthresholdHigh);
#endif

#if 0  /* See comment in sis_dac.c on why this is commented */
       if(pSiS->Chipset == PCI_CHIP_SIS530) {
          if((pSiS->oldChipset == OC_SIS530A) &&
	     (pSiS->Flags & UMA) &&
	     (mclk == 100000) &&
	     (pSiS->Flags & ESS137xPRESENT)) {
	       if(!(pSiS->Flags & SECRETFLAG)) index = 0;
               if((temp = SiS_CalcSpecial530Threshold(pSiS, mode, index)) {
	    	   CRT_CPUthresholdLow = temp;
	           break;
	       }
          }
       }
#endif

       switch(pSiS->Chipset) {
       case PCI_CHIP_SIS530:
          if(CRT_CPUthresholdLow > 0x1f)  CRT_CPUthresholdLow = 0x1f;
          CRT_CPUthresholdHigh = 0x1f;
          break;
       case PCI_CHIP_SIS5597:
       case PCI_CHIP_SIS6326:
       default:
          if(CRT_CPUthresholdLow > 0x0f)  CRT_CPUthresholdLow  = 0x0f;
          if(CRT_CPUthresholdHigh > 0x0f) CRT_CPUthresholdHigh = 0x0f;
       }

       pReg->sisRegs3C4[0x08] = ((CRT_CPUthresholdLow & 0x0F) << 4) |
	  		        (CRT_ENGthreshold & 0x0F);

       pReg->sisRegs3C4[0x09] &= 0xF0;
       pReg->sisRegs3C4[0x09] |= (CRT_CPUthresholdHigh & 0x0F);

       pReg->sisRegs3C4[0x3F] &= 0xEB;
       pReg->sisRegs3C4[0x3F] |= (CRT_CPUthresholdHigh & 0x10) |
                         	      ((CRT_CPUthresholdLow & 0x10) >> 2);

       if(pSiS->oldChipset >= OC_SIS530A) {
     	  pReg->sisRegs3C4[0x3F] &= 0xDF;
	  pReg->sisRegs3C4[0x3F] |= 0x58;
       }

       /* Set SiS6326 TV registers */
       if((pSiS->Chipset == PCI_CHIP_SIS6326) && (sis6326tvmode)) {
          unsigned char tmp;
          int index=0, i, j, k;
          int fsc;

          if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
             pReg->sisRegs3C4[0x0D] |= 0x04;
             switch(width) {
	     case 800:
	        if((strcmp(mode->name, "PAL800x600U") == 0))  index = 4;
	        else	        			      index = 3;
	        break;
	     case 720: index = 5;  break;
	     case 640:
	     default:  index = 2;
	     }
	     for(i=0; i<14; i++) {
	        pReg->sis6326tv[SiS6326TVRegs1[i]] = SiS6326TVRegs1_PAL[index][i];
	     }
#ifdef TV6326TEST
             for(i=0, j=2; i<3; i++, j++) {
	        pReg->sis6326tv[j] = SiS6326TVRegs1_PAL_2[index][i];
	     }
#endif
             fsc = (SiS6326TVRegs1_PAL[index][2] << 16) |
	           (SiS6326TVRegs1_PAL[index][3] << 8)  |
	           (SiS6326TVRegs1_PAL[index][4]);
          } else {
	     pReg->sisRegs3C4[0x0D] &= ~0x04;
	     if((strcmp(mode->name, "NTSC640x480U") == 0))  index = 5;
	     else 					    index = 4;
             for(i=0; i<14; i++) {
	        pReg->sis6326tv[SiS6326TVRegs1[i]] = SiS6326TVRegs1_NTSC[index][i];
	     }
#ifdef TV6326TEST
             for(i=0, j=2; i<3; i++, j++) {
	        pReg->sis6326tv[j] = SiS6326TVRegs1_NTSC_2[index][i];
	     }
#endif
             fsc = (SiS6326TVRegs1_NTSC[index][2] << 16) |
	           (SiS6326TVRegs1_NTSC[index][3] << 8)  |
	           (SiS6326TVRegs1_NTSC[index][4]);
          }
          if(pSiS->sis6326fscadjust) {
	     fsc += pSiS->sis6326fscadjust;
	     pReg->sis6326tv[2] = (fsc >> 16) & 0xff;
	     pReg->sis6326tv[3] = (fsc >> 8) & 0xff;
	     pReg->sis6326tv[4] = fsc & 0xff;
          }
          tmp = pReg->sis6326tv[0x43];
          if(pSiS->SiS6326Flags & SIS6326_TVCVBS) tmp |= 0x10;
          tmp |= 0x08;
          pReg->sis6326tv[0x43] = tmp;
          j = 0; k = 0;
          for(i=0; i<=0x44; i++) {
	     if(SiS6326TVRegs1[j] == i) {
	 	j++;
		continue;
	     }
	     if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
		tmp = SiS6326TVRegs2_PAL[index][k];
	     } else {
		tmp = SiS6326TVRegs2_NTSC[index][k];
	     }
	     pReg->sis6326tv[i] = tmp;
	     k++;
          }
          pReg->sis6326tv[0x43] |= 0x08;
          if((pSiS->ChipRev == 0xc1) || (pSiS->ChipRev == 0xc2)) {
             pReg->sis6326tv[0x43] &= ~0x08;
          }

          tmp = pReg->sis6326tv[0];
          tmp |= 0x18;
          if(pSiS->SiS6326Flags & SIS6326_TVCVBS)   tmp &= ~0x10;
          if(pSiS->SiS6326Flags & SIS6326_TVSVIDEO) tmp &= ~0x08;
          tmp |= 0x04;
          pReg->sis6326tv[0] = tmp;
       }

    } /* VESA */

d395 6
a400 3
/* Init a mode for SiS 300, 315 and 330 series
 * This function is now only used for setting up some
 * variables (eg. scrnOffset).
d405 8
a412 4
    SISPtr         pSiS = SISPTR(pScrn);
    SISRegPtr      pReg = &pSiS->ModeReg;
    unsigned short temp;
    DisplayModePtr realmode = mode;
d414 2
a415 1
    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4, "SIS300Init()\n"));
d417 1
d420 2
a421 2
	pScrn->virtualX, pSiS->CurrentLayout.bitsPerPixel,
        pScrn->virtualX * pSiS->CurrentLayout.bitsPerPixel/8);
d423 2
a424 5
#ifdef SISMERGED
    if(pSiS->MergedFB) {
       realmode = ((SiSMergedDisplayModePtr)mode->Private)->CRT1;
    }
#endif
a425 1
    /* Copy current register settings to structure */
d428 3
a430 9
    /* Calculate Offset/Display Pitch */
    pSiS->scrnOffset = pSiS->CurrentLayout.displayWidth *
                          ((pSiS->CurrentLayout.bitsPerPixel + 7) / 8);

    pSiS->scrnPitch = pSiS->scrnPitch2 = pSiS->scrnOffset;
    if(!(pSiS->VBFlags & CRT1_LCDA)) {
       if(realmode->Flags & V_INTERLACE) pSiS->scrnPitch <<= 1;
    }
    /* CRT2 mode can never be interlaced */
d432 2
a433 3
#ifdef UNLOCK_ALWAYS
    outSISIDXREG(SISSR, 0x05, 0x86);
#endif
d435 1
a435 1
    switch(pSiS->CurrentLayout.bitsPerPixel) {
d438 1
a438 1
	    pSiS->SiS310_AccelDepth = 0x00000000;
d441 4
a444 3
	    if(pSiS->CurrentLayout.depth == 15)
	        pSiS->DstColor = (short) 0x4000;
	    else
d446 2
a447 1
	    pSiS->SiS310_AccelDepth = 0x00010000;
d450 1
d454 1
a454 1
	    pSiS->SiS310_AccelDepth = 0x00020000;
d458 61
a518 1
    /* Enable PCI LINEAR ADDRESSING (0x80), MMIO (0x01), PCI_IO (0x20) */
d520 57
a576 12

    /* Now initialize TurboQueue. TB is always located at the very top of
     * the videoRAM (notably NOT the x framebuffer memory, which can/should
     * be limited by MaxXFbMem when using DRI). Also, enable the accelerators.
     */
    if(!pSiS->NoAccel) {
        pReg->sisRegs3C4[0x1E] |= 0x42;  /* Enable 2D accelerator */
	pReg->sisRegs3C4[0x1E] |= 0x18;  /* Enable 3D accelerator */
	switch(pSiS->VGAEngine) {
	case SIS_300_VGA:
	  if(pSiS->TurboQueue) {    		/* set Turbo Queue as 512k */
	    temp = ((pScrn->videoRam/64)-8);    /* 8=512k, 4=256k, 2=128k, 1=64k */
d580 11
a590 11
          }	/* line above new for saving D2&3 of status register */
	  break;
	case SIS_315_VGA:
#ifndef SISVRAMQ
	  /* See comments in sis_driver.c */
	  pReg->sisRegs3C4[0x27] = 0x1F;
	  pReg->sisRegs3C4[0x26] = 0x22;
	  pReg->sisMMIO85C0 = (pScrn->videoRam - 512) * 1024;
#endif
	  break;
	}
d596 2
a597 20
static int
SISDoSense(ScrnInfoPtr pScrn, int tempbl, int tempbh, int tempcl, int tempch)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int temp;

    outSISIDXREG(SISPART4,0x11,tempbl);
    temp = tempbh | tempcl;
    setSISIDXREG(SISPART4,0x10,0xe0,temp);
    SiS_DDC2Delay(pSiS->SiS_Pr, 0x1500);
    tempch &= 0x7f;
    inSISIDXREG(SISPART4,0x03,temp);
    temp ^= 0x0e;
    temp &= tempch;
    return((temp == tempch));
}

/* Sense connected devices on 30x */
static void
SISSense30x(ScrnInfoPtr pScrn)
d600 31
a630 27
    unsigned char backupP4_0d,backupP2_00,biosflag=0;
    unsigned char svhs_bl=0, svhs_bh=0;
    unsigned char cvbs_bl=0, cvbs_bh=0;
    unsigned char vga2_bl=0, vga2_bh=0;
    unsigned char svhs_cl, svhs_ch;
    unsigned char cvbs_cl, cvbs_ch;
    unsigned char vga2_cl, vga2_ch;
    int myflag, result=0, i, j;
    unsigned short temp;

    inSISIDXREG(SISPART4,0x0d,backupP4_0d);
    if(!(pSiS->VBFlags & (VB_301C | VB_302ELV))) {
       outSISIDXREG(SISPART4,0x0d,(backupP4_0d | 0x04));
    }

    inSISIDXREG(SISPART2,0x00,backupP2_00);
    outSISIDXREG(SISPART2,0x00,(backupP2_00 | 0x1c));

    SISDoSense(pScrn, 0, 0, 0, 0);

    if(pSiS->VGAEngine == SIS_300_VGA) {

        if(pSiS->sishw_ext.UseROM) {
	   vga2_bh = pSiS->BIOS[0xf9]; vga2_bl = pSiS->BIOS[0xf8];
	   svhs_bh = pSiS->BIOS[0xfb]; svhs_bl = pSiS->BIOS[0xfa];
	   cvbs_bh = pSiS->BIOS[0xfd]; cvbs_bl = pSiS->BIOS[0xfc];
	   biosflag = pSiS->BIOS[0xfe];
d632 2
a633 4
	   vga2_bh = 0x00; vga2_bl = 0xd1;
           svhs_bh = 0x00; svhs_bl = 0xb9;
	   cvbs_bh = 0x00; cvbs_bl = 0xb3;
	   biosflag = 2;
d635 38
a672 16

	if(pSiS->VBFlags & (VB_301B|VB_302B|VB_301LV|VB_302LV)) {
	   vga2_bh = 0x01; vga2_bl = 0x90;
	   svhs_bh = 0x01; svhs_bl = 0x6b;
	   cvbs_bh = 0x01; cvbs_bl = 0x74;
	} else if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
	   vga2_bh = 0x01; vga2_bl = 0x90;
	   svhs_bh = 0x01; svhs_bl = 0x6b;
	   cvbs_bh = 0x01; cvbs_bl = 0x10;
	} else {
	   inSISIDXREG(SISPART4,0x01,myflag);
	   if(myflag & 0x04) {
	      vga2_bh = 0x00; vga2_bl = 0xfd;
	      svhs_bh = 0x00; svhs_bl = 0xdd;
	      cvbs_bh = 0x00; cvbs_bl = 0xee;
	   }
d674 3
a676 121

	vga2_ch = 0x0e;	vga2_cl = 0x08;
	svhs_ch = 0x04;	svhs_cl = 0x04;
	cvbs_ch = 0x08; cvbs_cl = 0x04;

	if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	   vga2_bh = 0x00; vga2_bl = 0x00;
	   vga2_ch = 0x00; vga2_cl = 0x00;
	   svhs_ch = 0x04; svhs_cl = 0x08;
	   cvbs_ch = 0x08; cvbs_cl = 0x08;
	}

	if(pSiS->Chipset == PCI_CHIP_SIS300) {
	   inSISIDXREG(SISSR,0x3b,myflag);
	   if(!(myflag & 0x01)) {
	      vga2_bh = 0x00; vga2_bl = 0x00;
	      vga2_ch = 0x00; vga2_cl = 0x00;
	   }
	}

    } else if(pSiS->Chipset == PCI_CHIP_SIS660) {

        if(pSiS->sishw_ext.UseROM) {
	   biosflag = pSiS->BIOS[0x58];
	   temp = pSiS->BIOS[0x254] | (pSiS->BIOS[0x255] << 8);
	   if(pSiS->VBFlags & VB_301)         temp +=  6;
	   else if(pSiS->VBFlags & VB_301B)   temp += 12;
	   else if(pSiS->VBFlags & VB_301C)   temp += 18;
	   else if(pSiS->VBFlags & VB_301LV)  temp += 12;
	   else if(pSiS->VBFlags & VB_302LV)  temp += 12;
	   else if(pSiS->VBFlags & VB_302ELV) temp += 18;
	   vga2_bh = pSiS->BIOS[temp+1]; vga2_bl = pSiS->BIOS[temp];
	   svhs_bh = pSiS->BIOS[temp+3]; svhs_bl = pSiS->BIOS[temp+2];
	   cvbs_bh = pSiS->BIOS[temp+5]; cvbs_bl = pSiS->BIOS[temp+4];
	} else {
	   biosflag = 2;
	   if(pSiS->VBFlags & (VB_301B | VB_301LV | VB_302LV)) {
	      vga2_bh = 0x01; vga2_bl = 0x90;
	      svhs_bh = 0x01; svhs_bl = 0x6b; /* Are these really correct for LV? */
	      cvbs_bh = 0x01; cvbs_bl = 0x74;
	   } else if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
	      vga2_bh = 0x01; vga2_bl = 0x90;
	      svhs_bh = 0x01; svhs_bl = 0x6b;
	      cvbs_bh = 0x01; cvbs_bl = 0x10;
	   } else {
	      vga2_bh = 0x00; vga2_bl = 0xfd;
	      svhs_bh = 0x00; svhs_bl = 0xdd;
	      cvbs_bh = 0x00; cvbs_bl = 0xee;
	   }
	}

	vga2_ch = 0x0e;	vga2_cl = 0x08;
	svhs_ch = 0x04;	svhs_cl = 0x04;
	cvbs_ch = 0x08; cvbs_cl = 0x04;

	if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	   vga2_bh = 0x00; vga2_bl = 0x00;
	   vga2_ch = 0x00; vga2_cl = 0x00;
	   svhs_ch = 0x04; svhs_cl = 0x08;
	   cvbs_ch = 0x08; cvbs_cl = 0x08;
	}

    } else {

	if(pSiS->VBFlags & VB_301) {

	   if(pSiS->sishw_ext.UseROM) {
	      if(pSiS->Chipset == PCI_CHIP_SIS330) {
	         vga2_bh = pSiS->BIOS[0xe6]; vga2_bl = pSiS->BIOS[0xe5];
	         svhs_bh = pSiS->BIOS[0xe8]; svhs_bl = pSiS->BIOS[0xe7];
	         cvbs_bh = pSiS->BIOS[0xea]; cvbs_bl = pSiS->BIOS[0xe9];
	         biosflag = pSiS->BIOS[0x11b];
	      } else {
	         vga2_bh = pSiS->BIOS[0xbe]; vga2_bl = pSiS->BIOS[0xbd];
	         svhs_bh = pSiS->BIOS[0xc0]; svhs_bl = pSiS->BIOS[0xbf];
	         cvbs_bh = pSiS->BIOS[0xc2]; cvbs_bl = pSiS->BIOS[0xc1];
	         biosflag = pSiS->BIOS[0xf3];
	      }
	   } else {
	      vga2_bh = 0x00; vga2_bl = 0xd1;
              svhs_bh = 0x00; svhs_bl = 0xb9;
	      cvbs_bh = 0x00; cvbs_bl = 0xb3;
	      biosflag = 2;
	   }
	   inSISIDXREG(SISPART4,0x01,myflag);
	   if(myflag & 0x04) {
	      vga2_bh = 0x00; vga2_bl = 0xfd;
	      svhs_bh = 0x00; svhs_bl = 0xdd;
	      cvbs_bh = 0x00; cvbs_bl = 0xee;
	   }

	} else if(pSiS->VBFlags & (VB_301B|VB_302B|VB_301LV|VB_302LV)) {

	   if(pSiS->sishw_ext.UseROM) {
	      if(pSiS->Chipset == PCI_CHIP_SIS330) {
	         vga2_bh = pSiS->BIOS[0xec]; vga2_bl = pSiS->BIOS[0xeb];
	         svhs_bh = pSiS->BIOS[0xee]; svhs_bl = pSiS->BIOS[0xed];
	         cvbs_bh = pSiS->BIOS[0xf0]; cvbs_bl = pSiS->BIOS[0xef];
	      } else {
	         vga2_bh = pSiS->BIOS[0xc4]; vga2_bl = pSiS->BIOS[0xc3];
	         svhs_bh = pSiS->BIOS[0xc6]; svhs_bl = pSiS->BIOS[0xc5];
	         cvbs_bh = pSiS->BIOS[0xc8]; cvbs_bl = pSiS->BIOS[0xc7];
	      }
	   } else {
	      if(pSiS->VBFlags & (VB_301B|VB_302B)) {
	         vga2_bh = 0x01; vga2_bl = 0x90;
	         svhs_bh = 0x01; svhs_bl = 0x6b;
	         cvbs_bh = 0x01; cvbs_bl = 0x74;
	      } else {
		 vga2_bh = 0x00; vga2_bl = 0x00;
	         svhs_bh = 0x02; svhs_bl = 0x00;
	         cvbs_bh = 0x01; cvbs_bl = 0x00;
	      }
	   }

	} else if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {

	   vga2_bh = 0x01; vga2_bl = 0x90;
	   svhs_bh = 0x01; svhs_bl = 0x6b;
	   cvbs_bh = 0x01; cvbs_bl = 0x10;

a677 129
	
	if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	   /* No VGA2 or SCART on LV bridges */
	   vga2_bh = 0x00; vga2_bl = 0x00;
	   vga2_ch = 0x00; vga2_cl = 0x00;
	   svhs_ch = 0x04; svhs_cl = 0x08;
	   cvbs_ch = 0x08; cvbs_cl = 0x08;
	} else {
	   vga2_ch = 0x0e; vga2_cl = 0x08;
	   svhs_ch = 0x04; svhs_cl = 0x04;
	   cvbs_ch = 0x08; cvbs_cl = 0x04;
	}

    } 

    andSISIDXREG(SISCR, 0x32, ~0x14);
    pSiS->postVBCR32 &= ~0x14;
    
    if(vga2_ch || vga2_cl || vga2_bh || vga2_bl) {
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                "SiS30x: Scanning for VGA2/SCART (%x %x %x %x)\n",
    		vga2_bh, vga2_bl, vga2_ch, vga2_cl);
#endif

       for(j = 0; j < 10; j++) {
          result = 0;
          for(i = 0; i < 3; i++) {
             if(SISDoSense(pScrn, vga2_bl, vga2_bh, vga2_cl, vga2_ch))
	        result++;
          }
	  if((result == 0) || (result >= 2)) break;
       }
       if(result) {
           if(biosflag & 0x01) {
	      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	         "SiS30x: Detected TV connected to SCART output\n");
	      pSiS->VBFlags |= TV_SCART;
	      orSISIDXREG(SISCR, 0x32, 0x04);
	      pSiS->postVBCR32 |= 0x04;
	   } else {
	      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	         "SiS30x: Detected secondary VGA connection\n");
	      pSiS->VBFlags |= VGA2_CONNECTED;
	      orSISIDXREG(SISCR, 0x32, 0x10);
	      pSiS->postVBCR32 |= 0x10;
	   }
       }
       if(biosflag & 0x01) pSiS->SiS_SD_Flags |= SiS_SD_VBHASSCART;
    }

    if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
       orSISIDXREG(SISPART4,0x0d,0x04);
    }

    andSISIDXREG(SISCR, 0x32, 0x3f);
    pSiS->postVBCR32 &= 0x3f;

    if((pSiS->VGAEngine == SIS_315_VGA) && (pSiS->VBFlags & (VB_301C|VB_301LV|VB_302LV|VB_302ELV))) {
       outSISIDXREG(SISPART4,0x11,svhs_bl);
       setSISIDXREG(SISPART4,0x10,0xE0,(svhs_bh|0x04));
       SiS_DDC2Delay(pSiS->SiS_Pr, 0x1000);
       inSISIDXREG(SISPART4,0x03,temp);
       temp ^= 0x0E;
       temp &= 0x06;
       if(temp == 0x06) {
          outSISIDXREG(SISPART4,0x11,cvbs_bl);
	  setSISIDXREG(SISPART4,0x10,0xE0,(cvbs_bh|0x04));
	  SiS_DDC2Delay(pSiS->SiS_Pr, 0x1000);
	  inSISIDXREG(SISPART4,0x03,temp);
          temp ^= 0x0E;
	  temp &= 0x08;
	  if(temp) {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
     		"SiS30x: Detected TV connected to YPBPR output\n");
	     orSISIDXREG(SISCR,0x32,0x80);
	     pSiS->VBFlags |= TV_YPBPR;
	     pSiS->postVBCR32 |= 0x80;
	  }
       }
    }

#ifdef TWDEBUG
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                "SiS30x: Scanning for TV (%x %x %x %x; %x %x %x %x)\n",
    		svhs_bh, svhs_bl, svhs_ch, svhs_cl,
		cvbs_bh, cvbs_bl, cvbs_ch, cvbs_cl);
#endif

    andSISIDXREG(SISCR, 0x32, ~0x03);
    pSiS->postVBCR32 &= ~0x03;

    if(!(pSiS->VBFlags & TV_YPBPR)) {

       for(j = 0; j < 10; j++) {
          result = 0;
          for(i = 0; i < 3; i++) {
             if(SISDoSense(pScrn, svhs_bl, svhs_bh, svhs_cl, svhs_ch))
	        result++;
          }
          if((result == 0) || (result >= 2)) break;
       }
       if(result) {
          xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
     		"SiS30x: Detected TV connected to SVIDEO output\n");
          pSiS->VBFlags |= TV_SVIDEO;
          orSISIDXREG(SISCR, 0x32, 0x02);
          pSiS->postVBCR32 |= 0x02;
       }

       if((biosflag & 0x02) || (!(result))) {

          for(j = 0; j < 10; j++) {
             result = 0;
             for(i = 0; i < 3; i++) {
                if(SISDoSense(pScrn, cvbs_bl, cvbs_bh, cvbs_cl, cvbs_ch))
	           result++;
             }
             if((result == 0) || (result >= 2)) break;
          }
          if(result) {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	             "SiS30x: Detected TV connected to COMPOSITE output\n");
	     pSiS->VBFlags |= TV_AVIDEO;
	     orSISIDXREG(SISCR, 0x32, 0x01);
	     pSiS->postVBCR32 |= 0x01;
          }
       }

a679 97
    SISDoSense(pScrn, 0, 0, 0, 0);

    outSISIDXREG(SISPART2,0x00,backupP2_00);
    outSISIDXREG(SISPART4,0x0d,backupP4_0d);
}

static void
SiS6326TVDelay(ScrnInfoPtr pScrn, int delay)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int i;
    unsigned char temp;

    for(i=0; i<delay; i++) {
    	inSISIDXREG(SISSR, 0x05, temp);
    }
    (void)temp;
}

static int
SIS6326DoSense(ScrnInfoPtr pScrn, int tempbh, int tempbl, int tempch, int tempcl)
{
    unsigned char temp;

    SiS6326SetTVReg(pScrn, 0x42, tempbl);
    temp = SiS6326GetTVReg(pScrn, 0x43);
    temp &= 0xfc;
    temp |= tempbh;
    SiS6326SetTVReg(pScrn, 0x43, temp);
    SiS6326TVDelay(pScrn, 0x1000);
    temp = SiS6326GetTVReg(pScrn, 0x43);
    temp |= 0x04;
    SiS6326SetTVReg(pScrn, 0x43, temp);
    SiS6326TVDelay(pScrn, 0x8000);
    temp = SiS6326GetTVReg(pScrn, 0x44);
    if(!(tempch & temp)) tempcl = 0;
    return(tempcl);
}

static void
SISSense6326(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char temp;
    int result;

    pSiS->SiS6326Flags &= (SIS6326_HASTV | SIS6326_TVPAL);
    temp = SiS6326GetTVReg(pScrn, 0x43);
    temp &= 0xfb;
    SiS6326SetTVReg(pScrn, 0x43, temp);
    result = SIS6326DoSense(pScrn, 0x01, 0xb0, 0x06, SIS6326_TVSVIDEO);  /* 0x02 */
    pSiS->SiS6326Flags |= result;
    result = SIS6326DoSense(pScrn, 0x01, 0xa0, 0x01, SIS6326_TVCVBS);    /* 0x04 */
    pSiS->SiS6326Flags |= result;
    temp = SiS6326GetTVReg(pScrn, 0x43);
    temp &= 0xfb;
    SiS6326SetTVReg(pScrn, 0x43, temp);
    if(pSiS->SiS6326Flags & (SIS6326_TVSVIDEO | SIS6326_TVCVBS)) {
    	pSiS->SiS6326Flags |= SIS6326_TVDETECTED;
	xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		"SiS6326: Detected TV connected to %s output\n",
		(((pSiS->SiS6326Flags & (SIS6326_TVSVIDEO | SIS6326_TVCVBS)) ==
		   (SIS6326_TVSVIDEO | SIS6326_TVCVBS)) ?
		   	"both SVIDEO and COMPOSITE" :
		      	   ((pSiS->SiS6326Flags & SIS6326_TVSVIDEO) ?
			     	"SVIDEO" : "COMPOSITE")));
    } else {
        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		"SiS6326: No TV detected\n");
    }
}

/* Detect video bridge and set VBFlags accordingly */
void SISVGAPreInit(ScrnInfoPtr pScrn)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int     temp,temp1,temp2, i;
    int     upperlimitlvds, lowerlimitlvds;
    int     upperlimitch, lowerlimitch;
    int     chronteltype, chrontelidreg, upperlimitvb;
    unsigned char test[3];
    static const char *detectvb = "Detected %s video bridge (ID %d; Revision 0x%x)\n";
#if 0
    unsigned char sr17=0;
#endif
    static const char  *ChrontelTypeStr[] = {
        "7004",
	"7005",
	"7007",
	"7006",
	"7008",
	"7013",
	"7019",
	"7020",
	"(unknown)"
    };

a683 7
	case PCI_CHIP_SIS550:
	case PCI_CHIP_SIS650:
	case PCI_CHIP_SIS315:
	case PCI_CHIP_SIS315H:
	case PCI_CHIP_SIS315PRO:
	case PCI_CHIP_SIS330:
	case PCI_CHIP_SIS660:
a688 412

    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
        unsigned char sr0d;
	inSISIDXREG(SISSR, 0x0d, sr0d);
	if(sr0d & 0x04) {
		pSiS->SiS6326Flags |= SIS6326_TVPAL;
	}
	SISSense6326(pScrn);
    }

    pSiS->VBFlags = 0; /* reset VBFlags */
    pSiS->SiS_Pr->SiS_UseLCDA = FALSE;
    pSiS->SiS_Pr->Backup = FALSE;

    /* Videobridges only available for 300/315 series */
    if((pSiS->VGAEngine != SIS_300_VGA) && (pSiS->VGAEngine != SIS_315_VGA))
        return;
	
    inSISIDXREG(SISPART4, 0x00, temp);
    temp &= 0x0F;
    if(temp == 1) {
        inSISIDXREG(SISPART4, 0x01, temp1);
	temp1 &= 0xff;
        if(temp1 >= 0xE0) {
	        inSISIDXREG(SISPART4, 0x39, temp2);
		if(temp2 == 0xff) {
	   	   pSiS->VBFlags |= VB_302LV;
		   pSiS->sishw_ext.ujVBChipID = VB_CHIP_302LV;
    		   xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS302LV", 1, temp1);
		} else {
		   pSiS->VBFlags |= VB_302ELV;
		   pSiS->sishw_ext.ujVBChipID = VB_CHIP_302ELV;
    		   xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS302ELV", 1, temp1);
		}
	} else if(temp1 >= 0xD0) {
	   	pSiS->VBFlags |= VB_301LV;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301LV;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS301LV", 1, temp1);
	} else if(temp1 >= 0xC0) {
	   	pSiS->VBFlags |= VB_301C;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301C;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS301C", 1, temp1);
	} else if(temp1 >= 0xB0) {
	        pSiS->VBFlags |= VB_301B;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301B;
		inSISIDXREG(SISPART4, 0x23, temp2);
		if(!(temp2 & 0x02)) pSiS->VBFlags |= VB_30xBDH;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb,
				(temp2 & 0x02) ? "SiS301B" : "SiS301B-DH", 1, temp1);
	} else {
	        pSiS->VBFlags |= VB_301;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301;
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS301", 1, temp1);
	}

	SISSense30x(pScrn); 

    } else if (temp == 2) {

        inSISIDXREG(SISPART4, 0x01, temp1);
	temp1 &= 0xff;
	if(temp1 >= 0xE0) {
        	pSiS->VBFlags |= VB_302LV;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_302LV;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS302LV", 2, temp1);
	} else if(temp1 >= 0xD0) {
        	pSiS->VBFlags |= VB_301LV;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301LV;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS301LV", 2, temp1);
	} else {
	        pSiS->VBFlags |= VB_302B;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_302B;
		inSISIDXREG(SISPART4, 0x23, temp2);
		if(!(temp & 0x02)) pSiS->VBFlags |= VB_30xBDH;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb,
				(temp2 & 0x02) ? "SiS302B" : "SiS302B-DH", 2, temp1);
	}

	SISSense30x(pScrn);

    } else if (temp == 3) {

    	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "unsupported SiS303", temp, 0);

    } else {

        pSiS->sishw_ext.ujVBChipID = VB_CHIP_UNKNOWN;
	if(pSiS->Chipset == PCI_CHIP_SIS660) {
	   inSISIDXREG(SISCR, 0x38, temp);
           temp = (temp >> 5) & 0x07;
	} else {
	   inSISIDXREG(SISCR, 0x37, temp);
           temp = (temp >> 1) & 0x07;
	}
        if(pSiS->VGAEngine == SIS_300_VGA) {
	   lowerlimitlvds = 2; upperlimitlvds = 4;
	   lowerlimitch   = 4; upperlimitch   = 5;
	   chronteltype = 1;   chrontelidreg  = 0x25;
	   upperlimitvb = upperlimitlvds;
        } else {
	   lowerlimitlvds = 2; upperlimitlvds = 3;
	   lowerlimitch   = 3; upperlimitch   = 3;
	   chronteltype = 2;   chrontelidreg  = 0x4b;
	   upperlimitvb = upperlimitlvds;
	   if(pSiS->Chipset == PCI_CHIP_SIS660) {
	      upperlimitvb = 4;
	   }
	}

	if((temp >= lowerlimitlvds) && (temp <= upperlimitlvds)) {
               pSiS->VBFlags |= VB_LVDS;
    	       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	               "Detected LVDS transmitter (External chip ID %d)\n", temp);
	}
        if((temp >= lowerlimitch) && (temp <= upperlimitch))  {
	    /* Set global for init301.c */
	    pSiS->SiS_Pr->SiS_IF_DEF_CH70xx = chronteltype;

	    if(chronteltype == 1) {
	       /* Set general purpose IO for Chrontel communication */
	       SiS_SetChrontelGPIO(pSiS->SiS_Pr, 0x9c);
	    }

	    /* Read Chrontel version number */
 	    temp1 = SiS_GetCH70xx(pSiS->SiS_Pr, chrontelidreg);
	    if(chronteltype == 1) {
	        /* See Chrontel TB31 for explanation */
		temp2 = SiS_GetCH700x(pSiS->SiS_Pr, 0x0e);
		if(((temp2 & 0x07) == 0x01) || (temp2 & 0x04)) {
		    SiS_SetCH700x(pSiS->SiS_Pr, 0x0b0e);
		    SiS_DDC2Delay(pSiS->SiS_Pr, 300);
		}
	        temp2 = SiS_GetCH70xx(pSiS->SiS_Pr, chrontelidreg);
		if(temp2 != temp1) temp1 = temp2;
	    }
	    if(temp1 == 0xFFFF) {	/* 0xFFFF = error reading DDC port */
	    	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			"Detected Chrontel 70xx, but encountered error reading I2C port\n");
		andSISIDXREG(SISCR, 0x32, ~0x07);
		pSiS->postVBCR32 &= ~0x07;
	    }
	    /* TW: We only support device ids 0x19-200; other values may indicate DDC problems */
	    else if((temp1 >= 0x19) && (temp1 <= 200)) {
	        pSiS->VBFlags |= VB_CHRONTEL;
		switch (temp1) {
		   case 0x32: temp2 = 0; pSiS->ChrontelType = CHRONTEL_700x; break;
		   case 0x3A: temp2 = 1; pSiS->ChrontelType = CHRONTEL_700x; break;
		   case 0x50: temp2 = 2; pSiS->ChrontelType = CHRONTEL_700x; break;
		   case 0x2A: temp2 = 3; pSiS->ChrontelType = CHRONTEL_700x; break;
		   case 0x40: temp2 = 4; pSiS->ChrontelType = CHRONTEL_700x; break;
		   case 0x22: temp2 = 5; pSiS->ChrontelType = CHRONTEL_700x; break;
	           case 0x19: temp2 = 6; pSiS->ChrontelType = CHRONTEL_701x; break;
	           case 0x20: temp2 = 7; pSiS->ChrontelType = CHRONTEL_701x; break;  /* ID for 7020? */
		   default:   temp2 = 8; pSiS->ChrontelType = CHRONTEL_701x; break;
		}
   	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	               "Detected Chrontel %s TV encoder (ID 0x%02x; chip ID %d)\n",
		       			ChrontelTypeStr[temp2], temp1, temp);

		/* Sense connected TV's */

		if(chronteltype == 1) {

		   /* Chrontel 700x */

	    	   /* Read power status */
	    	   temp1 = SiS_GetCH700x(pSiS->SiS_Pr, 0x0e);  /* Power status */
	    	   if((temp1 & 0x03) != 0x03) {
		        /* TW: Power all outputs */
	        	SiS_SetCH700x(pSiS->SiS_Pr, 0x0B0E);
			SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);
	    	   }
		   /* Sense connected TV devices */
		   for(i = 0; i < 3; i++) {
	    	      SiS_SetCH700x(pSiS->SiS_Pr, 0x0110);
		      SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);
	    	      SiS_SetCH700x(pSiS->SiS_Pr, 0x0010);
		      SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);
	    	      temp1 = SiS_GetCH700x(pSiS->SiS_Pr, 0x10);
		      if(!(temp1 & 0x08))       test[i] = 0x02;
		      else if(!(temp1 & 0x02))  test[i] = 0x01;
		      else                      test[i] = 0;
		      SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);
		   }

		   if(test[0] == test[1])      temp1 = test[0];
		   else if(test[0] == test[2]) temp1 = test[0];
		   else if(test[1] == test[2]) temp1 = test[1];
		   else {
		   	xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
				"TV detection unreliable - test results varied\n");
			temp1 = test[2];
		   }

		} else {

		   /* Chrontel 701x */

		   /* Backup Power register */
		   temp1 = SiS_GetCH701x(pSiS->SiS_Pr, 0x49);

		   /* Enable TV path */
		   SiS_SetCH701x(pSiS->SiS_Pr, 0x2049);

		   SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);

		   /* Sense connected TV devices */
		   temp2 = SiS_GetCH701x(pSiS->SiS_Pr, 0x20);
		   temp2 |= 0x01;
		   SiS_SetCH701x(pSiS->SiS_Pr, (temp2 << 8) | 0x20);

		   SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);

		   temp2 ^= 0x01;
		   SiS_SetCH701x(pSiS->SiS_Pr, (temp2 << 8) | 0x20);

		   SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);

		   temp2 = SiS_GetCH701x(pSiS->SiS_Pr, 0x20); 

		   /* Restore Power register */
		   SiS_SetCH701x(pSiS->SiS_Pr, (temp1 << 8) | 0x49);

                   temp1 = 0;
		   if(temp2 & 0x02) temp1 |= 0x01;
		   if(temp2 & 0x10) temp1 |= 0x01;
		   if(temp2 & 0x04) temp1 |= 0x02;

		   if( (temp1 & 0x01) && (temp1 & 0x02) ) temp1 = 0x04;

                }

		switch(temp1) {
		     case 0x01:
		        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		  	   "Chrontel: Detected TV connected to COMPOSITE output\n");
			pSiS->VBFlags |= TV_AVIDEO;
			orSISIDXREG(SISCR, 0x32, 0x01);
			andSISIDXREG(SISCR, 0x32, ~0x06);
			pSiS->postVBCR32 |= 0x01;
			pSiS->postVBCR32 &= ~0x06;
                        break;
                     case 0x02:
			xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			   "Chrontel: Detected TV connected to SVIDEO output\n");
			pSiS->VBFlags |= TV_SVIDEO;
			orSISIDXREG(SISCR, 0x32, 0x02);
			andSISIDXREG(SISCR, 0x32, ~0x05);
			pSiS->postVBCR32 |= 0x02;
			pSiS->postVBCR32 &= ~0x05;
                        break;
		     case 0x04:
			xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			   "Chrontel: Detected TV connected to SCART or YPBPR output\n");
			if(pSiS->chtvtype == -1) {
			   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			      "Chrontel: Use CHTVType option to select either SCART or YPBPR525I\n");
			   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			      "Chrontel: Using SCART by default\n");
			   pSiS->chtvtype = 1;
			}
			if(pSiS->chtvtype)
			    pSiS->VBFlags |= TV_CHSCART;
			else
			    pSiS->VBFlags |= TV_CHYPBPR525I;
                        break;
		     default:
		        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		  	   "Chrontel: No TV detected.\n");
			andSISIDXREG(SISCR, 0x32, ~0x07);
			pSiS->postVBCR32 &= ~0x07;
		}

	    } else if(temp1==0) {
	        /* This indicates a communication problem, but it only occures if there
		 * is no TV attached. So we don't use TV in this case.
		 */
	    	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"Detected Chrontel TV encoder in promiscuous state (DDC/I2C mix-up)\n");
		andSISIDXREG(SISCR, 0x32, ~0x07);
		pSiS->postVBCR32 &= ~0x07;
	    } else {
	    	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			"Chrontel: Unsupported device id (%d) detected\n",temp1);
		andSISIDXREG(SISCR, 0x32, ~0x07);
		pSiS->postVBCR32 &= ~0x07;
	    }
	    if(chronteltype == 1) {
	       /* Set general purpose IO for Chrontel communication */
	       SiS_SetChrontelGPIO(pSiS->SiS_Pr, 0x00);
	    }
	}
	if((pSiS->Chipset == PCI_CHIP_SIS660) && (temp == 4)) {
	   pSiS->VBFlags |= VB_CONEXANT;
	   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	               "Detected Conexant video bridge - UNSUPPORTED\n");
	}
	if((pSiS->VGAEngine == SIS_300_VGA) && (temp == 3)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	               "Detected Trumpion Zurac (I/II/III) LVDS scaler - UNSUPPORTED\n");
	}
	if(temp > upperlimitvb) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	               "Detected unknown bridge type (%d)\n", temp);
	}
    }

   /* Old BIOSes store the detected CRT2 type in SR17, 16 and 13
    * instead of CR32. However, since our detection routines
    * store their results to CR32, we now copy the
    * remaining bits (for LCD and VGA) to CR32 for unified usage.
    * SR17[0] CRT1     [1] LCD       [2] TV    [3] VGA2
    *     [4] AVIDEO   [5] SVIDEO
    * SR13[0] SCART    [1] HiVision
    * SR16[5] PAL/NTSC [6] LCD-SCALE [7] OVERSCAN
    */

#if 0
    inSISIDXREG(SISSR, 0x17, sr17);
    if( (pSiS->VGAEngine == SIS_300_VGA) &&
        (pSiS->Chipset != PCI_CHIP_SIS300) &&
        (sr17 & 0x0F) ) {
	
	unsigned char cr32;
	inSISIDXREG(SISCR, 0x32, cr32);
	
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		"Converting SR17 (%02x) to CR32 (%02x)\n", sr17, cr32);
	 
	 if(sr17 & 0x01) {  	/* CRT1 */
	 	orSISIDXREG(SISCR, 0x32, 0x20);
		pSiS->postVBCR32 |= 0x20;
	 } else {
	 	andSISIDXREG(SISCR, 0x32, ~0x20);
		pSiS->postVBCR32 &= ~0x20;
	 }
		
	 if(sr17 & 0x02) {	/* LCD */
	 	orSISIDXREG(SISCR, 0x32, 0x08);
		pSiS->postVBCR32 |= 0x08;
	 } else	{	  
	 	andSISIDXREG(SISCR, 0x32, ~0x08);
		pSiS->postVBCR32 &= ~0x08;
	 }
	 
	 /* No Hivision, no DVI here */
	 andSISIDXREG(SISCR,0x32,~0xc0);
	 pSiS->postVBCR32 &= ~0xc0;
    }  
#endif

    /* Try to find out if the bridge uses LCDA for low resolution and
     * text modes. If sisfb saved this for us, use it. Otherwise,
     * check if we are running on a low mode on LCD and read the 
     * relevant registers ourselves.
     */
    if(pSiS->VGAEngine == SIS_315_VGA) {

       if(pSiS->VBFlags & (VB_301C | VB_302B | VB_301LV | VB_302LV | VB_302ELV)) {
          if(pSiS->sisfblcda != 0xff) {
	     if((pSiS->sisfblcda & 0x03) == 0x03) {
	        pSiS->SiS_Pr->SiS_UseLCDA = TRUE;
	        pSiS->ChipFlags |= SiSCF_UseLCDA;
	     }
	  } else {
             inSISIDXREG(SISCR,0x34,temp);
	     if(temp <= 0x13) {
	        inSISIDXREG(SISCR,0x38,temp);
	        if((temp & 0x03) == 0x03) {
	           pSiS->SiS_Pr->SiS_UseLCDA = TRUE;
	           pSiS->ChipFlags |= SiSCF_UseLCDA;
		   pSiS->SiS_Pr->Backup = TRUE;
	        } else {
		   inSISIDXREG(SISCR,0x35,temp);
		   if(temp & 0x01) {
		      pSiS->SiS_Pr->SiS_UseLCDA = TRUE;
	              pSiS->ChipFlags |= SiSCF_UseLCDA;
		      pSiS->SiS_Pr->Backup = TRUE;
		   } else {
	              inSISIDXREG(SISCR,0x30,temp);
	 	      if(temp & 0x20) {
		         orSISIDXREG(SISPART1,0x2f,0x01);  /* Unlock CRT2 */
		         inSISIDXREG(SISPART1,0x13,temp);
		         if(temp & 0x04) {
		            pSiS->SiS_Pr->SiS_UseLCDA = TRUE;
	                    pSiS->ChipFlags |= SiSCF_UseLCDA;
			    pSiS->SiS_Pr->Backup = TRUE;
		         }
		      } 
		   }
	        }
	     }
	  }
	  if(pSiS->ChipFlags & SiSCF_UseLCDA) {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		"BIOS uses LCDA for low resolution and text modes\n");
	     if(pSiS->SiS_Pr->Backup == TRUE) {
	        inSISIDXREG(SISCR,0x34,pSiS->SiS_Pr->Backup_Mode);
                inSISIDXREG(SISPART1,0x14,pSiS->SiS_Pr->Backup_14);
	        inSISIDXREG(SISPART1,0x15,pSiS->SiS_Pr->Backup_15);
	        inSISIDXREG(SISPART1,0x16,pSiS->SiS_Pr->Backup_16);
	        inSISIDXREG(SISPART1,0x17,pSiS->SiS_Pr->Backup_17);
	        inSISIDXREG(SISPART1,0x18,pSiS->SiS_Pr->Backup_18);
	        inSISIDXREG(SISPART1,0x19,pSiS->SiS_Pr->Backup_19);
	        inSISIDXREG(SISPART1,0x1a,pSiS->SiS_Pr->Backup_1a);
	        inSISIDXREG(SISPART1,0x1b,pSiS->SiS_Pr->Backup_1b);
	        inSISIDXREG(SISPART1,0x1c,pSiS->SiS_Pr->Backup_1c);
	        inSISIDXREG(SISPART1,0x1d,pSiS->SiS_Pr->Backup_1d);
	     }
	  }
       }
    }
a689 2


@


1.1.9.2
log
@Import XFree86 4.4 from The XFree86(TM) Project, Inc.
(integrity cannot be checked)

got via cvs -qd anoncvs@@anoncvs.xfree86.org:/cvs co -Prxf-4_4_0 xc
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_vga.c,v 1.46 2004/02/26 15:07:02 twini Exp $ */
d15 4
a18 1
 * 3) The name of the author may not be used to endorse or promote products
d50 4
d56 2
a57 1
static int   SISDoSense(ScrnInfoPtr pScrn, unsigned short type, unsigned short test);
d76 11
d129 11
d173 1
d816 5
d831 5
d978 1
a978 1
SISDoSense(ScrnInfoPtr pScrn, unsigned short type, unsigned short test)
d980 2
a981 6
    SISPtr pSiS = SISPTR(pScrn);
    int    temp, mytest, result, i, j;

#ifdef TWDEBUG
    xf86DrvMsg(0, X_INFO, "Sense: %x %x\n", type, test);
#endif
d983 9
a991 23
    for(j = 0; j < 10; j++) {
       result = 0;
       for(i = 0; i < 3; i++) {
          mytest = test;
          outSISIDXREG(SISPART4,0x11,(type & 0x00ff));
          temp = (type >> 8) | (mytest & 0x00ff);
          setSISIDXREG(SISPART4,0x10,0xe0,temp);
          SiS_DDC2Delay(pSiS->SiS_Pr, 0x1500);
          mytest >>= 8;
          mytest &= 0x7f;
          inSISIDXREG(SISPART4,0x03,temp);
          temp ^= 0x0e;
          temp &= mytest;
          if(temp == mytest) result++;
#if 1
	  outSISIDXREG(SISPART4,0x11,0x00);
	  andSISIDXREG(SISPART4,0x10,0xe0);
	  SiS_DDC2Delay(pSiS->SiS_Pr, 0x1000);
#endif
       }
       if((result == 0) || (result >= 2)) break;
    }
    return(result);
a993 2
#define GETROMWORD(w) (pSiS->BIOS[w] | (pSiS->BIOS[w+1] << 8))

d999 9
a1007 5
    unsigned char backupP4_0d,backupP2_00,backupP2_4d,biosflag=0;
    unsigned short svhs=0, svhs_c=0;
    unsigned short cvbs=0, cvbs_c=0;
    unsigned short vga2=0, vga2_c=0;
    int myflag, result; /* , i; */
d1010 3
a1012 2
    outSISIDXREG(SISPART4,0x0d,(backupP4_0d | 0x04));
    SiS_DDC2Delay(pSiS->SiS_Pr, 0x2000);
d1015 99
a1113 1
    outSISIDXREG(SISPART2,0x00,((backupP2_00 | 0x1c) & 0xfc));
d1115 68
a1182 70
    inSISIDXREG(SISPART2,0x4d,backupP2_4d);
    if(pSiS->VBFlags & (VB_301C|VB_301LV|VB_302LV|VB_302ELV)) {
       outSISIDXREG(SISPART2,0x4d,(backupP2_4d & ~0x10));
    }

    SISDoSense(pScrn, 0, 0);

    if(pSiS->VBFlags & VB_301) {
       svhs = 0x00b9; cvbs = 0x00b3; vga2 = 0x00d1;
       inSISIDXREG(SISPART4,0x01,myflag);
       if(myflag & 0x04) {
	  svhs = 0x00dd; cvbs = 0x00ee; vga2 = 0x00fd;
       }
    } else if(pSiS->VBFlags & (VB_301B | VB_302B)) {
       svhs = 0x016b; cvbs = 0x0174; vga2 = 0x0190;
    } else if(pSiS->VBFlags & (VB_301LV | VB_302LV)) {
       svhs = 0x0200; cvbs = 0x0100;
    } else if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
       svhs = 0x016b; cvbs = 0x0110; vga2 = 0x0190;
    } else return;

    vga2_c = 0x0e08; svhs_c = 0x0404; cvbs_c = 0x0804;
    if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
       svhs_c = 0x0408; cvbs_c = 0x0808;
    }
    biosflag = 2;

    if(pSiS->Chipset == PCI_CHIP_SIS300) {
       inSISIDXREG(SISSR,0x3b,myflag);
       if(!(myflag & 0x01)) vga2 = vga2_c = 0;
    }

    if(pSiS->sishw_ext.UseROM) {
       if(pSiS->VGAEngine == SIS_300_VGA) {
          if(pSiS->VBFlags & VB_301) {
	     inSISIDXREG(SISPART4,0x01,myflag);
             if(!(myflag & 0x04)) {
                vga2 = GETROMWORD(0xf8); svhs = GETROMWORD(0xfa); cvbs = GETROMWORD(0xfc);
	     }
	  }
	  biosflag = pSiS->BIOS[0xfe];
       } else if(pSiS->Chipset == PCI_CHIP_SIS660) {
          if(pSiS->ROM661New) {
	     biosflag = 2;
	     vga2 = GETROMWORD(0x63); svhs = cvbs = GETROMWORD(0x65);
	     if(pSiS->BIOS[0x5d] & 0x04) biosflag |= 0x01;
	  }
       } else if(!pSiS->ROM661New) {
#if 0	  /* eg. 1.15.23 has wrong values here */
          myflag = 0;
          if(pSiS->VBFlags & VB_301) {
	     if(pSiS->Chipset == PCI_CHIP_SIS330) {
	        myflag = 0xe5; i = 0x11b;
	     } else {
	        myflag = 0xbd; i = 0xf3
	     }
	  } else if(pSiS->VBFlags & (VB_301B|VB_302B|VB_301LV|VB_302LV)) {
	     if(pSiS->Chipset == PCI_CHIP_SIS330) {
	        myflag = 0xeb; i = 0x11b;
	     } else {
	        myflag = 0xc3; i = 0xf3
	     }
	  }
	  if(myflag) {
	     biosflag = pSiS->BIOS[i];    vga2 = GETROMWORD(myflag);
	     svhs = GETROMWORD(myflag+2); cvbs = GETROMWORD(myflag+4);
	  }
#endif
       }
    }
d1184 1
a1184 3
    if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
       vga2 = vga2_c = 0;
    }
d1189 18
a1206 4
    if(vga2_c || vga2) {
       if(SISDoSense(pScrn, vga2, vga2_c)) {
          if(biosflag & 0x01) {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
d1208 5
a1212 5
	     pSiS->VBFlags |= TV_SCART;
	     orSISIDXREG(SISCR, 0x32, 0x04);
	     pSiS->postVBCR32 |= 0x04;
	  } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
d1214 4
a1217 4
	     pSiS->VBFlags |= VGA2_CONNECTED;
	     orSISIDXREG(SISCR, 0x32, 0x10);
	     pSiS->postVBCR32 |= 0x10;
	  }
d1222 4
d1230 20
a1249 13
       if(pSiS->SenseYPbPr) {
          outSISIDXREG(SISPART2,0x4d,(backupP2_4d | 0x10));
          SiS_DDC2Delay(pSiS->SiS_Pr, 0x2000);
          if((result = SISDoSense(pScrn, svhs, 0x0604))) {
             if((result = SISDoSense(pScrn, cvbs, 0x0804))) {
	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
     			"SiS30x: Detected TV connected to YPbPr component output\n");
	        orSISIDXREG(SISCR,0x32,0x80);
	        pSiS->VBFlags |= TV_YPBPR;
	        pSiS->postVBCR32 |= 0x80;
	     }
          }
          outSISIDXREG(SISPART2,0x4d,backupP2_4d);
d1253 7
d1265 9
a1273 1
       if((result = SISDoSense(pScrn, svhs, svhs_c))) {
d1281 11
a1291 2
       if((biosflag & 0x02) || (!result)) {
          if(SISDoSense(pScrn, cvbs, cvbs_c)) {
d1302 1
a1302 1
    SISDoSense(pScrn, 0, 0);
a1712 1
	    pSiS->VBFlags |= VB_TRUMPION;
d1714 1
a1714 1
	               "Detected Trumpion Zurac (I/II/III) LVDS scaler\n");
d1788 2
a1789 3
		   orSISIDXREG(SISPART1,0x2f,0x01);  /* Unlock CRT2 */
		   inSISIDXREG(SISPART1,0x13,temp);
		   if(temp & 0x04) {
d1793 11
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@a0 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_vga.c,v 1.16 2003/01/29 15:42:17 eich Exp $ */
a1 2
 * Mode setup and video bridge detection
 *
a2 1
 * Parts Copyright 2001, 2002 by Thomas Winischhofer, Vienna, Austria.
d8 1
a8 1
 * documentation, and that the name of the copyright holder not be used in
d10 1
a10 1
 * specific, written prior permission.  The copyright holder makes no representations
d14 1
a14 1
 * THE COPYRIGHT HOLDER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
d16 1
a16 1
 * EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY SPECIAL, INDIRECT OR
d24 1
a24 1
 *           Juanjo Santamarta <santamarta@@ctv.es>,
d26 1
a26 2
 *           David Thomas <davtom@@dream.org.uk>.
 *	     Thomas Winischhofer <thomas@@winischhofer.net>
d28 1
d41 6
a46 6
#define Midx         0
#define Nidx         1
#define VLDidx       2
#define Pidx         3
#define PSNidx       4
#define Fref         14318180
d49 2
a50 2
#define MIN_VCO      Fref
#define MAX_VCO      135000000
d52 2
a53 2
#define MAX_PSN      0         /* no pre scaler for this chip */
#define TOLERANCE    0.01      /* search smallest M and N in this tolerance */
d56 3
a58 108
static Bool  SISInit(ScrnInfoPtr pScrn, DisplayModePtr mode);
static Bool  SIS300Init(ScrnInfoPtr pScrn, DisplayModePtr mode);
/* TW: To be used internally only */
int    SISDoSense(ScrnInfoPtr pScrn, int tempbl, int tempbh, int tempcl, int tempch);
void   SISSense30x(ScrnInfoPtr pScrn);
int    SIS6326DoSense(ScrnInfoPtr pScrn, int tempbh, int tempbl, int tempch, int tempcl);
void   SISSense6326(ScrnInfoPtr pScrn);
static void SiS6326TVDelay(ScrnInfoPtr pScrn, int delay);

const CARD8 SiS6326TVRegs1_NTSC[6][14] = {
    {0x81,0x3f,0x49,0x1b,0xa9,0x03,0x00,0x09,0x08,0x7d,0x00,0x88,0x30,0x60},
    {0x81,0x3f,0x49,0x1d,0xa0,0x03,0x00,0x09,0x08,0x7d,0x00,0x88,0x30,0x60},
    {0x81,0x45,0x24,0x8e,0x26,0x0b,0x00,0x09,0x02,0xfe,0x00,0x09,0x51,0x60},
    {0x81,0x45,0x24,0x8e,0x26,0x07,0x00,0x29,0x04,0x30,0x10,0x3b,0x61,0x60},
    {0x81,0x3f,0x24,0x8e,0x26,0x09,0x00,0x09,0x02,0x30,0x10,0x3b,0x51,0x60},
    {0x83,0x5d,0x21,0xbe,0x75,0x03,0x00,0x09,0x08,0x42,0x10,0x4d,0x61,0x79}   /* 640x480u */
};

const CARD8 SiS6326TVRegs2_NTSC[6][54] = {
    {0x11, 0x17, 0x03, 0x09, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
     0x0C, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xFC, 0xDF, 0x94, 0x1F, 0x4A, 0x03, 0x71, 0x07, 0x97, 0x10, 0x40,
     0x48, 0x00, 0x26, 0xB6, 0x10, 0x5C, 0xEC, 0x21, 0x2E, 0xBE, 0x10,
     0x64, 0xF4, 0x21, 0x13, 0x75, 0x08, 0x31, 0x6A, 0x01, 0xA0},
    {0x11, 0x17, 0x03, 0x0A, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
     0x0D, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xFF, 0xDF, 0x94, 0x1F, 0x4A, 0x03, 0x71, 0x07, 0x97, 0x10, 0x40,
     0x48, 0x00, 0x26, 0xB6, 0x10, 0x5C, 0xEC, 0x21, 0x2E, 0xBE, 0x10,
     0x64, 0xF4, 0x21, 0x13, 0x75, 0x08, 0x31, 0x6A, 0x01, 0xA0},
    {0x11, 0x17, 0x03, 0x0A, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
     0x0D, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xFF, 0xDF, 0x94, 0x3F, 0x8C, 0x06, 0xCE, 0x07, 0x27, 0x30, 0x73,
     0x7B, 0x00, 0x48, 0x68, 0x30, 0xB2, 0xD2, 0x52, 0x50, 0x70, 0x30,
     0xBA, 0xDA, 0x52, 0xDC, 0x02, 0xD1, 0x53, 0xF7, 0x02, 0xA0},
    {0x11, 0x17, 0x03, 0x09, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
     0x0C, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xDC, 0xDF, 0x94, 0x3F, 0x8C, 0x06, 0xCE, 0x07, 0x27, 0x30, 0x73,
     0x7B, 0x00, 0x48, 0x68, 0x30, 0xB2, 0xD2, 0x52, 0x50, 0x70, 0x30,
     0xBA, 0xDA, 0x52, 0x00, 0x02, 0xF5, 0x53, 0xF7, 0x02, 0xA0},
    {0x11, 0x17, 0x03, 0x09, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,
     0x0C, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xDC, 0xDF, 0x94, 0x3F, 0x8C, 0x06, 0xCE, 0x07, 0x27, 0x30, 0x73,
     0x7B, 0x00, 0x48, 0x68, 0x30, 0xB2, 0xD2, 0x52, 0x50, 0x70, 0x30,
     0xBA, 0xDA, 0x52, 0xDC, 0x02, 0xD1, 0x53, 0xF7, 0x02, 0xA0},
    {0x11, 0x17, 0x03, 0x09, 0x94, 0x02, 0x05, 0x06, 0x09, 0x50, 0x0C,  /* 640x480u */
     0x0C, 0x06, 0x0D, 0x04, 0x0A, 0x94, 0x06, 0x0D, 0x04, 0x0A, 0x94,
     0xDC, 0xDF, 0x94, 0xAF, 0x95, 0x06, 0xDD, 0x07, 0x5F, 0x30, 0x7E,
     0x86, 0x00, 0x4C, 0xA4, 0x30, 0xE3, 0x3B, 0x62, 0x54, 0xAC, 0x30,
     0xEB, 0x43, 0x62, 0x48, 0x34, 0x3D, 0x63, 0x29, 0x03, 0xA0}
};

const CARD8 SiS6326TVRegs1_PAL[6][14] = {
    {0x81,0x2d,0xc8,0x07,0xb2,0x0b,0x00,0x09,0x02,0xed,0x00,0xf8,0x30,0x40},
    {0x80,0x2d,0xa4,0x03,0xd9,0x0b,0x00,0x09,0x02,0xed,0x10,0xf8,0x71,0x40},
    {0x81,0x2d,0xa4,0x03,0xd9,0x0b,0x00,0x09,0x02,0xed,0x10,0xf8,0x71,0x40},
    {0x81,0x2d,0xa4,0x03,0xd9,0x0b,0x00,0x09,0x02,0x8f,0x10,0x9a,0x71,0x40},
    {0x83,0x63,0xa1,0x7a,0xa3,0x0a,0x00,0x09,0x02,0xb5,0x11,0xc0,0x81,0x59},  /* 800x600u */
    {0x81,0x63,0xa4,0x03,0xd9,0x01,0x00,0x09,0x10,0x9f,0x10,0xaa,0x71,0x59}   /* 720x540  */
};

const CARD8 SiS6326TVRegs2_PAL[6][54] = {
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0xEF, 0x5A, 0x03, 0x7F, 0x07, 0xFF, 0x10, 0x4E,
     0x56, 0x00, 0x2B, 0x23, 0x20, 0xB4, 0xAC, 0x31, 0x33, 0x2B, 0x20,
     0xBC, 0xB4, 0x31, 0x83, 0xE1, 0x78, 0x31, 0xD6, 0x01, 0xA0},
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0xDF, 0xB2, 0x07, 0xFB, 0x07, 0xF7, 0x30, 0x90,
     0x98, 0x00, 0x4F, 0x3F, 0x40, 0x62, 0x52, 0x73, 0x57, 0x47, 0x40,
     0x6A, 0x5A, 0x73, 0x03, 0xC1, 0xF8, 0x63, 0xB6, 0x03, 0xA0},
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0xDF, 0xB2, 0x07, 0xFB, 0x07, 0xF7, 0x30, 0x90,
     0x98, 0x00, 0x4F, 0x3F, 0x40, 0x62, 0x52, 0x73, 0x57, 0x47, 0x40,
     0x6A, 0x5A, 0x73, 0x03, 0xC1, 0xF8, 0x63, 0xB6, 0x03, 0xA0},
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0xDF, 0xB2, 0x07, 0xFB, 0x07, 0xF7, 0x30, 0x90,
     0x98, 0x00, 0x4F, 0x3F, 0x40, 0x62, 0x52, 0x73, 0x57, 0x47, 0x40,
     0x6A, 0x5A, 0x73, 0xA0, 0xC1, 0x95, 0x73, 0xB6, 0x03, 0xA0},
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,  /* 800x600u */
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0x7F, 0xBD, 0x08, 0x0E, 0x07, 0x47, 0x40, 0x9D,
     0xA5, 0x00, 0x54, 0x94, 0x40, 0xA4, 0xE4, 0x73, 0x5C, 0x9C, 0x40,
     0xAC, 0xEC, 0x73, 0x0B, 0x0E, 0x00, 0x84, 0x03, 0x04, 0xA0},
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,  /* 720x540  */
     0x70, 0x06, 0x3E, 0x35, 0x6D, 0x94, 0x05, 0x3F, 0x36, 0x6E, 0x94,
     0xE5, 0xDF, 0x94, 0xDF, 0xB0, 0x07, 0xFB, 0x07, 0xF7, 0x30, 0x9D,
     0xA5, 0x00, 0x4F, 0x3F, 0x40, 0x62, 0x52, 0x73, 0x57, 0x47, 0x40,
     0x6A, 0x5A, 0x73, 0xA0, 0xC1, 0x95, 0x73, 0xB6, 0x03, 0xA0}
};

const CARD8 SiS6326TVRegs1[14] = {
     0x00,0x01,0x02,0x03,0x04,0x11,0x12,0x13,0x21,0x26,0x27,0x3a,0x3c,0x43
};

const CARD8 SiS6326CR[9][15] = {
     {0x79,0x63,0x64,0x1d,0x6a,0x93,0x00,0x6f,0xf0,0x58,0x8a,0x57,0x57,0x70,0x20},  /* PAL 800x600   */
     {0x79,0x4f,0x50,0x95,0x60,0x93,0x00,0x6f,0xba,0x14,0x86,0xdf,0xe0,0x30,0x00},  /* PAL 640x480   */
     {0x5f,0x4f,0x50,0x82,0x53,0x9f,0x00,0x0b,0x3e,0xe9,0x8b,0xdf,0xe7,0x04,0x00},  /* NTSC 640x480  */
     {0x5f,0x4f,0x50,0x82,0x53,0x9f,0x00,0x0b,0x3e,0xcb,0x8d,0x8f,0x96,0xe9,0x00},  /* NTSC 640x400  */
     {0x83,0x63,0x64,0x1f,0x6d,0x9b,0x00,0x6f,0xf0,0x48,0x0a,0x23,0x57,0x70,0x20},  /* PAL 800x600u  */
     {0x79,0x59,0x5b,0x1d,0x66,0x93,0x00,0x6f,0xf0,0x42,0x04,0x1b,0x40,0x70,0x20},  /* PAL 720x540   */
     {0x66,0x4f,0x51,0x0a,0x57,0x89,0x00,0x0b,0x3e,0xd9,0x0b,0xb6,0xe7,0x04,0x00},  /* NTSC 640x480u */
     {0xce,0x9f,0x9f,0x92,0xa4,0x16,0x00,0x28,0x5a,0x00,0x04,0xff,0xff,0x29,0x39},  /* 1280x1024-75  */
     {0x09,0xc7,0xc7,0x0d,0xd2,0x0a,0x01,0xe0,0x10,0xb0,0x04,0xaf,0xaf,0xe1,0x1f}   /* 1600x1200-60  */
};
a59 1
/* Initialize a display mode on 5597/5598, 6326 and 530/620 */
d63 15
a77 19
    SISPtr         pSiS = SISPTR(pScrn);
    SISRegPtr      pReg = &pSiS->ModeReg;
    vgaRegPtr      vgaReg = &VGAHWPTR(pScrn)->ModeReg;
    unsigned char  temp;
    int            mclk = pSiS->MemClock;
    int            offset;
    int            clock = mode->Clock;
    int            width = mode->HDisplay;
    int            height = mode->VDisplay;
    int            rate = SiSCalcVRate(mode);
    int            buswidth = pSiS->BusWidth;
    unsigned int   vclk[5];
    unsigned short CRT_CPUthresholdLow;
    unsigned short CRT_CPUthresholdHigh;
    unsigned short CRT_ENGthreshold;
    double         a, b, c;
    int            d, factor;
    int            num, denum, div, sbit, scale;
    BOOL	   sis6326tvmode, sis6326himode;
d80 2
a82 1
    /* Save the registers for further processing */
d85 1
a85 25
    /* TW: Determine if chosen mode is suitable for TV on the 6326
           and if the mode is one of our special hi-res modes.
     */
    sis6326tvmode = FALSE;
    sis6326himode = FALSE;
    if(pSiS->Chipset == PCI_CHIP_SIS6326) {
      if(pSiS->SiS6326Flags & SIS6326_HASTV) {
        if((pSiS->SiS6326Flags & SIS6326_TVDETECTED) &&
           ((strcmp(mode->name, "PAL800x600") == 0)   ||	/* TW: Special TV modes */
            (strcmp(mode->name, "PAL800x600U") == 0)  ||
	    (strcmp(mode->name, "PAL720x540") == 0)   ||
            (strcmp(mode->name, "PAL640x480") == 0)   ||
	    (strcmp(mode->name, "NTSC640x480") == 0)  ||
	    (strcmp(mode->name, "NTSC640x480U") == 0) ||
	    (strcmp(mode->name, "NTSC640x400") == 0))) {
		    sis6326tvmode = TRUE;
        } else {
          pReg->sis6326tv[0x00] &= 0xfb;
        }
      }
      if((strcmp(mode->name, "SIS1280x1024-75") == 0) ||	/* TW: Special high-res modes */
         (strcmp(mode->name, "SIS1600x1200-60") == 0)) {
	 sis6326himode = TRUE;
      }
    }
d87 1
a87 3
#ifdef UNLOCK_ALWAYS
    outSISIDXREG(SISSR, 0x05, 0x86);
#endif
d90 4
a93 4

    /* set interlace */
    if(!(mode->Flags & V_INTERLACE))  {
        offset = pSiS->CurrentLayout.displayWidth >> 3;
d95 1
a95 1
        offset = pSiS->CurrentLayout.displayWidth >> 2;
d99 2
a100 11
    /* Enable Linear and Enhanced Gfx Mode */
    pReg->sisRegs3C4[0x06] |= 0x82;

    /* Enable MMIO at PCI Register 14H (D[6:5]: 11) */
    pReg->sisRegs3C4[0x0B] |= 0x60;

    /* Enable 32bit mem access (D7), read-ahead cache (D4) */
    pReg->sisRegs3C4[0x0C] |= 0xA0;

    /* TW: Some speed-up stuff */
    switch(pSiS->Chipset)  {
a101 7
        /* TW: enable host bus */
	if(pSiS->NoHostBus) {
	   pReg->sisRegs3C4[0x34] &= ~0x08;
	} else {
           pReg->sisRegs3C4[0x34] |= 0x08;
	}
        /* TW: fall through */
d103 7
a109 5
    case PCI_CHIP_SIS530: 
        /* TW: Enable "dual segment register mode" (D2) and "i/o gating while
         *     write buffer is not empty" (D3)
         */
    	pReg->sisRegs3C4[0x0B] |= 0x0C;
d112 1
a112 5
    /* set colordepth */
    if(pSiS->Chipset == PCI_CHIP_SIS530) {
        pReg->sisRegs3C4[0x09] &= 0x7F;
    }
    switch(pSiS->CurrentLayout.bitsPerPixel) {
d115 4
d120 2
a121 5
	    offset <<= 1;
	    if(pSiS->CurrentLayout.depth == 15)
	        pReg->sisRegs3C4[0x06] |= 0x04;
	    else
                pReg->sisRegs3C4[0x06] |= 0x08;
d125 2
a126 2
            pReg->sisRegs3C4[0x06] |= 0x10;
            pReg->sisRegs3C4[0x0B] |= 0x90;
d129 8
a136 6
            if(pSiS->Chipset == PCI_CHIP_SIS530) {
	        offset <<= 2;
                pReg->sisRegs3C4[0x06] |= 0x10;
                pReg->sisRegs3C4[0x0B] |= 0x90;
                pReg->sisRegs3C4[0x09] |= 0x80;
            } else return FALSE;
d139 1
a139 7

    /* save screen pitch for acceleration functions */
    pSiS->scrnOffset = pSiS->CurrentLayout.displayWidth *
                           ((pSiS->CurrentLayout.bitsPerPixel + 7) / 8);

    /* set linear framebuffer addresses */
    switch(pScrn->videoRam)  {
d141 2
a142 1
            temp = 0x00;  break;
d144 2
a145 1
            temp = 0x20;  break;
d147 2
a148 1
            temp = 0x40;  break;
d150 2
a151 1
            temp = 0x60;  break;
d153 2
a154 1
            temp = 0x80;  break;
d158 14
a171 2
    pReg->sisRegs3C4[0x20] = (pSiS->FbAddress & 0x07F80000) >> 19;
    pReg->sisRegs3C4[0x21] = ((pSiS->FbAddress & 0xF8000000) >> 27) | temp;
d173 1
a173 1
    /* Set screen offset */
d175 15
d191 2
a192 92
    /* Set CR registers for our built-in TV and hi-res modes */
    if((sis6326tvmode) || (sis6326himode)) {

	int index,i;

	/* TW: We need our very private data for hi-res and TV modes */
	if(sis6326himode) {
	   if(strcmp(mode->name, "SIS1280x1024-75") == 0)  index = 7;
	   else index = 8;
	} else {
	  if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
	    switch(width) {
	    case 800:
	      if((strcmp(mode->name, "PAL800x600U") == 0))
	      	index = 4;
	      else
	        index = 0;
	      break;
	    case 720:
	      index = 5;
	      break;
	    case 640:
	    default:
	      index = 1;
	    }
	  } else {
	    switch(height) {
	    case 400:
	      index = 3;
	      break;
	    case 480:
	    default:
	      if((strcmp(mode->name, "NTSC640x480U") == 0))
	        index = 6;
	      else
	        index = 2;
	    }
	  }
        }
	for(i=0; i<=5; i++) {
	    vgaReg->CRTC[i] = SiS6326CR[index][i];
	}
        pReg->sisRegs3C4[0x12] = SiS6326CR[index][6];
	vgaReg->CRTC[6] = SiS6326CR[index][7];
	vgaReg->CRTC[7] = SiS6326CR[index][8];
	vgaReg->CRTC[0x10] = SiS6326CR[index][9];
	vgaReg->CRTC[0x11] = SiS6326CR[index][10];
	vgaReg->CRTC[0x12] = SiS6326CR[index][11];
	vgaReg->CRTC[0x15] = SiS6326CR[index][12];
	vgaReg->CRTC[0x16] = SiS6326CR[index][13];
	vgaReg->CRTC[9] &= ~0x20;
	vgaReg->CRTC[9] |= (SiS6326CR[index][14] & 0x20);
	pReg->sisRegs3C4[0x0A] = ((offset & 0xF00) >> 4) | (SiS6326CR[index][14] & 0x0f);

    } else {

       /* Set extended vertical overflow register */
       pReg->sisRegs3C4[0x0A] = ((offset & 0xF00) >> 4) |
              (((mode->CrtcVTotal-2)     & 0x400) >> 10 ) |
              (((mode->CrtcVDisplay-1)   & 0x400) >>  9 ) |
/*            (((mode->CrtcVSyncStart-1) & 0x400) >>  8 ) |  */
	      (((mode->CrtcVBlankStart-1)& 0x400) >>  8 ) |
/*            (((mode->CrtcVBlankStart-1)& 0x400) >>  7 );  */
              (((mode->CrtcVSyncStart)   & 0x400) >>  7 );  

       /* Set extended horizontal overflow register */
       pReg->sisRegs3C4[0x12] &= 0xE0;
       pReg->sisRegs3C4[0x12] |= (
           (((mode->CrtcHTotal >> 3) - 5)      & 0x100) >> 8 |
           (((mode->CrtcHDisplay >> 3) - 1)    & 0x100) >> 7 |
/*         (((mode->CrtcHSyncStart >> 3) - 1)  & 0x100) >> 6 |  */
           (((mode->CrtcHBlankStart >> 3) - 1) & 0x100) >> 6 |
           ((mode->CrtcHSyncStart >> 3)        & 0x100) >> 5 |
           (((mode->CrtcHBlankEnd >> 3) - 1)   & 0x40)  >> 2);
    }

#ifdef TWDEBUG
    xf86DrvMsg(0, X_INFO, "HDisplay %d HSyncStart %d HSyncEnd %d HTotal %d\n",
		mode->CrtcHDisplay, mode->CrtcHSyncStart,
		mode->CrtcHSyncEnd, mode->CrtcHTotal);
    xf86DrvMsg(0, X_INFO, "HBlankSt %d  HBlankE %d\n",
    		mode->CrtcHBlankStart, mode->CrtcHBlankEnd);

    xf86DrvMsg(0, X_INFO, "VDisplay %d VSyncStart %d VSyncEnd %d VTotal %d\n",
		mode->CrtcVDisplay, mode->CrtcVSyncStart,
		mode->CrtcVSyncEnd, mode->CrtcVTotal);
    xf86DrvMsg(0, X_INFO, "VBlankSt %d  VBlankE %d\n",
    		mode->CrtcVBlankStart, mode->CrtcVBlankEnd);
#endif

    /* enable (or disable) line compare */
    if(mode->CrtcVDisplay >= 1024)
d197 6
a202 13
    /* Enable (or disable) high speed DCLK (some 6326 and 530/620 only) */
    if( ( (pSiS->Chipset == PCI_CHIP_SIS6326) &&
          ( (pSiS->ChipRev == 0xd0) || (pSiS->ChipRev == 0xd1) ||
            (pSiS->ChipRev == 0xd2) || (pSiS->ChipRev == 0x92) ||
	    (pSiS->Flags & A6326REVAB) ) ) ||
        (pSiS->oldChipset > OC_SIS6326) ) {
      if( (pSiS->CurrentLayout.bitsPerPixel == 24) ||
          (pSiS->CurrentLayout.bitsPerPixel == 32) ||
          (mode->CrtcHDisplay >= 1280) )
         pReg->sisRegs3C4[0x3E] |= 0x01;
      else
         pReg->sisRegs3C4[0x3E] &= 0xFE;
    }
a203 2
    /* We use the internal VCLK */
    pReg->sisRegs3C4[0x38] &= 0xFC;
d205 17
a221 10
    /* Set VCLK */
    if((sis6326tvmode) || (sis6326himode)) {
        /* TW: For our built-in modes, the calculation is not suitable */
      if(sis6326himode) {
        if((strcmp(mode->name, "SIS1280x1024-75") == 0)) {
	   pReg->sisRegs3C4[0x2A] = 0x5d;	/* 1280x1024-75 */
           pReg->sisRegs3C4[0x2B] = 0xa4;
        } else {
	   pReg->sisRegs3C4[0x2A] = 0x59;	/* 1600x1200-60 */
           pReg->sisRegs3C4[0x2B] = 0xa3;
d223 3
a225 43
	pReg->sisRegs3C4[0x13] &= ~0x40;
      } else {
        if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
	   /* PAL: 31.500 Mhz */
	   if((strcmp(mode->name, "PAL800x600U") == 0)) {
   	      pReg->sisRegs3C4[0x2A] = 0x46;
              pReg->sisRegs3C4[0x2B] = 0x49;
	   } else {
	      pReg->sisRegs3C4[0x2A] = 0xab;
              pReg->sisRegs3C4[0x2B] = 0xe9;
	   }
	   pReg->sisRegs3C4[0x13] &= ~0x40;
	} else {
	   /* NTSC: 27.000 Mhz */
	   if((strcmp(mode->name, "NTSC640x480U") == 0)) {
	      pReg->sisRegs3C4[0x2A] = 0x5a;
              pReg->sisRegs3C4[0x2B] = 0x65;
	   } else {
	      pReg->sisRegs3C4[0x2A] = 0x29;
              pReg->sisRegs3C4[0x2B] = 0xe2;
	   }
	   pReg->sisRegs3C4[0x13] |= 0x40;
	}
      }
    } else if(SiS_compute_vclk(clock, &num, &denum, &div, &sbit, &scale)) {
        pReg->sisRegs3C4[0x2A] = (num - 1) & 0x7f ;
        pReg->sisRegs3C4[0x2A] |= (div == 2) ? 0x80 : 0;
        pReg->sisRegs3C4[0x2B] = ((denum - 1) & 0x1f);
        pReg->sisRegs3C4[0x2B] |= (((scale -1) & 3) << 5);

	/* When setting VCLK, we should set SR13 first */
        if(sbit)
              pReg->sisRegs3C4[0x13] |= 0x40;
        else
              pReg->sisRegs3C4[0x13] &= 0xBF;

#ifdef TWDEBUG
	xf86DrvMsg(0, X_INFO, "2a: %x 2b: %x 13: %x clock %d\n",
		pReg->sisRegs3C4[0x2A], pReg->sisRegs3C4[0x2B], pReg->sisRegs3C4[0x13], clock);
#endif

    } else {
        /* if SiS_compute_vclk cannot handle the requested clock, try sisCalcClock */
d227 23
d251 2
a252 5
        pReg->sisRegs3C4[0x2A] = (vclk[Midx] - 1) & 0x7f;
        pReg->sisRegs3C4[0x2A] |= ((vclk[VLDidx] == 2) ? 1 : 0) << 7;

	/* bits [4:0] contain denumerator */
        pReg->sisRegs3C4[0x2B] = (vclk[Nidx] - 1) & 0x1f;
d254 2
a255 11
        if (vclk[Pidx] <= 4){
              /* postscale 1,2,3,4 */
              pReg->sisRegs3C4[0x2B] |= (vclk[Pidx] - 1) << 5;
              pReg->sisRegs3C4[0x13] &= 0xBF;
        } else {
              /* postscale 6,8 */
              pReg->sisRegs3C4[0x2B] |= ((vclk[Pidx] / 2) - 1) << 5;
              pReg->sisRegs3C4[0x13] |= 0x40;
        }
        pReg->sisRegs3C4[0x2B] |= 0x80 ;   /* gain for high frequency */
    }
d257 6
a262 15
    /* High speed DAC */
    if(clock > 135000)
        pReg->sisRegs3C4[0x07] |= 0x02;

    /* Programmable Clock */
    pReg->sisRegs3C2 = inb(SISMISCR) | 0x0C;

    /* 1 or 2 cycle DRAM (set by option FastVram) */
    if(pSiS->newFastVram == -1) {
        pReg->sisRegs3C4[0x34] |= 0x80;
	pReg->sisRegs3C4[0x34] &= ~0x40;
    } else if(pSiS->newFastVram == 1)
        pReg->sisRegs3C4[0x34] |= 0xC0;
    else
        pReg->sisRegs3C4[0x34] &= ~0xC0;
a263 1
    /* Logical line length */
d265 27
a291 22
    pReg->sisRegs3C4[0x27] &= 0xCF;
    if(pSiS->CurrentLayout.bitsPerPixel == 24) {
         /* Invalid logical width */
         pReg->sisRegs3C4[0x27] |= 0x30;
         pSiS->ValidWidth = FALSE;
    } else {
	 switch(pScrn->virtualX * (pSiS->CurrentLayout.bitsPerPixel >> 3)) {
         case 1024:
               pReg->sisRegs3C4[0x27] |= 0x00;
               break;
         case 2048:
               pReg->sisRegs3C4[0x27] |= 0x10;
               break;
         case 4096:
               pReg->sisRegs3C4[0x27] |= 0x20;
               break;
         default:
               /* Invalid logical width */
               pReg->sisRegs3C4[0x27] |= 0x30;
               pSiS->ValidWidth = FALSE;
               break;
         }
d293 4
d298 19
a316 40
    /* Acceleration stuff */
    if(!pSiS->NoAccel) {
         pReg->sisRegs3C4[0x27] |= 0x40;   /* Enable engine programming registers */
         if( (pSiS->TurboQueue) &&	       /* Handle TurboQueue */
 	     ( (pSiS->Chipset != PCI_CHIP_SIS530) ||
	       (pSiS->CurrentLayout.bitsPerPixel != 24) ) ) {
               pReg->sisRegs3C4[0x27] |= 0x80;        /* Enable TQ */
	       if((pSiS->Chipset == PCI_CHIP_SIS530) ||
		  ((pSiS->Chipset == PCI_CHIP_SIS6326 &&
		   (pSiS->ChipRev == 0xd0 || pSiS->ChipRev == 0xd1 ||
		    pSiS->ChipRev == 0xd2 || pSiS->ChipRev == 0x92 ||
		    pSiS->ChipRev == 0x0a || pSiS->ChipRev == 0x1a ||
		    pSiS->ChipRev == 0x2a || pSiS->ChipRev == 0x0b ||
		    pSiS->ChipRev == 0x1b || pSiS->ChipRev == 0x2b) ) ) ) {
		    /* pReg->sisRegs3C4[0x3D] |= 0x80;  */     /* Queue is 62K (530/620 specs) */
		       pReg->sisRegs3C4[0x3D] &= 0x7F;         /* Queue is 30K (530/620 specs) */
		}
		/* TW: Locate the TQ at the beginning of the last 64K block of
		 *     video RAM. The address is to be specified in 32K steps.
		 */
		pReg->sisRegs3C4[0x2C] = (pScrn->videoRam - 64) / 32;
		if(pSiS->Chipset != PCI_CHIP_SIS530) {	/* 530/620: Reserved (don't touch) */
    		        pReg->sisRegs3C4[0x3C] &= 0xFC; /* 6326: Queue is all for 2D */
		}					/* 5597: Must be 0           */
          } else {
	        pReg->sisRegs3C4[0x27] &= 0x7F;
	  }
    }

    /* TW: No idea what this does. The Windows driver does it, so we do it as well */
    if(pSiS->Chipset == PCI_CHIP_SIS6326) {
       if((pSiS->ChipRev == 0xd0) || (pSiS->ChipRev == 0xd1) ||
          (pSiS->ChipRev == 0xd2) || (pSiS->ChipRev == 0x92) ||
	  (pSiS->Flags & A6326REVAB)) {
	  if((pSiS->Flags & (SYNCDRAM | RAMFLAG)) == (SYNCDRAM | RAMFLAG)) {
	     if(!(pReg->sisRegs3C4[0x0E] & 0x03)) {
	         pReg->sisRegs3C4[0x3E] |= 0x02;
	     }
	  }
       }
d319 3
a321 6

    /* Set memclock */
#if 0
    /* TW: We don't need to do this; the SetMClk option was not used since 4.0. */
    if((pSiS->Chipset == PCI_CHIP_SIS5597) || (pSiS->Chipset == PCI_CHIP_SIS6326)) {
      if(pSiS->MemClock > 66000) {
d323 7
a329 7

          pReg->sisRegs3C4[0x28] = (vclk[Midx] - 1) & 0x7f ;
          pReg->sisRegs3C4[0x28] |= ((vclk[VLDidx] == 2 ) ? 1 : 0 ) << 7 ;
          pReg->sisRegs3C4[0x29] = (vclk[Nidx] -1) & 0x1f ;   /* bits [4:0] contain denumerator -MC */
          if(vclk[Pidx] <= 4) {
            pReg->sisRegs3C4[0x29] |= (vclk[Pidx] - 1) << 5 ; /* postscale 1,2,3,4 */
            pReg->sisRegs3C4[0x13] &= 0x7F;
d331 2
a332 2
            pReg->sisRegs3C4[0x29] |= ((vclk[Pidx] / 2) - 1) << 5 ;  /* postscale 6,8 */
            pReg->sisRegs3C4[0x13] |= 0x80;
d334 10
a343 9
          /* Check programmed memory clock. Enable only to check the above code */
/*
          mclk = 14318 * ((pReg->sisRegs3C4[0x28] & 0x7f) + 1);
          mclk /= ((pReg->sisRegs3C4[0x29] & 0x0f) + 1);
          if(!(pReg->sisRegs3C4[0x13] & 0x80)) {
             mclk /= (((pReg->sisRegs3C4[0x29] & 0x60) >> 5) + 1);
          } else {
             if ((pReg->sisRegs3C4[0x29] & 0x60) == 0x40) mclk /= 6;
             if ((pReg->sisRegs3C4[0x29] & 0x60) == 0x60) mclk /= 8;
d346 3
a348 3
                 "Setting memory clock to %.3f MHz\n",
                 mclk/1000.0);
*/
a350 1
#endif
d352 25
a376 43
    /* TW: set threshold values (rewritten) */
    /*
     * CPU/CRT Threshold:                     FIFO
     *                           MCLK     ___________      VCLK
     * cpu/engine <---o       o--------->|___________| -----------> CRT
     *                ^       ^            ^       ^
     *                 \     /             |       |
     *                  \   /              |< gap >|
     *                   \ /               |       |
     *           selector switch   Thrsh. low     high
     *
     * CRT consumes the data in the FIFO during scanline display. When the
     * amount of data in the FIFO reaches the Threshold low value, the selector
     * switch will switch to the right, and the FIFO will be refilled with data.
     * When the amount of data in the FIFO reaches the Threshold high value, the
     * selector switch will switch to the left and allows the CPU and the chip
     * engines to access video RAM.
     *
     * The Threshold low values should be increased at higher bpps, simply because
     * there is more data needed for the CRT. When Threshold low and high are very
     * close to each other, the selector switch will be activated more often, which
     * decreases performance.
     *
     */
    switch(pSiS->Chipset) {
    case PCI_CHIP_SIS5597:  factor = 65; break;
    case PCI_CHIP_SIS6326:  factor = 30; break;
    case PCI_CHIP_SIS530:   factor = (pSiS->Flags & UMA) ? 60 : 30; break;
    default:                factor = (pScrn->videoRam > (1024*1024)) ? 24 : 12;
    }
    a = width * height * rate * 1.40 * factor * ((pSiS->CurrentLayout.bitsPerPixel + 1) / 8);
    b = (mclk / 1000) * 999488.0 * (buswidth / 8);
    c = ((a / b) + 1.0) / 2;
    d = (int)c + 2;

#ifdef TWDEBUG
    xf86DrvMsg(0, X_INFO,
       "Debug: w %d h %d r %d mclk %d bus %d factor %d bpp %d\n",
       width, height, rate, mclk/1000, buswidth, factor,
       pSiS->CurrentLayout.bitsPerPixel);
    xf86DrvMsg(0, X_INFO, "Debug: a %f b %f c %f d %d (flags %x)\n",
     	a, b, c, d, pSiS->Flags);
#endif
d378 12
a389 115
    CRT_CPUthresholdLow = d;
    if((pSiS->Flags & (RAMFLAG | SYNCDRAM)) == (RAMFLAG | SYNCDRAM)) {
     		CRT_CPUthresholdLow += 2;
    }
    CRT_CPUthresholdHigh = CRT_CPUthresholdLow + 3;

    CRT_ENGthreshold = 0x0F;

#ifdef TWDEBUG
    xf86DrvMsg(0, X_INFO, "Debug: Thlow %d thhigh %d\n",
     	CRT_CPUthresholdLow, CRT_CPUthresholdHigh);
#endif

#if 0  /* TW: See comment in sis_dac.c on why this is commented */
    if(pSiS->Chipset == PCI_CHIP_SIS530) {
       if((pSiS->oldChipset == OC_SIS530A) &&
	  (pSiS->Flags & UMA) &&
	  (mclk == 100000) &&
	  (pSiS->Flags & ESS137xPRESENT)) {
	    if(!(pSiS->Flags & SECRETFLAG)) index = 0;
            if((temp = SiS_CalcSpecial530Threshold(pSiS, mode, index)) {
	    	CRT_CPUthresholdLow = temp;
	        break;
	    }
       }
    }
#endif

    switch(pSiS->Chipset) {
    case PCI_CHIP_SIS530:
        if(CRT_CPUthresholdLow > 0x1f)  CRT_CPUthresholdLow = 0x1f;
        CRT_CPUthresholdHigh = 0x1f;
        break;
    case PCI_CHIP_SIS5597:
    case PCI_CHIP_SIS6326:
    default:
        if(CRT_CPUthresholdLow > 0x0f)  CRT_CPUthresholdLow  = 0x0f;
        if(CRT_CPUthresholdHigh > 0x0f) CRT_CPUthresholdHigh = 0x0f;
    }

    pReg->sisRegs3C4[0x08] = ((CRT_CPUthresholdLow & 0x0F) << 4) |
			      (CRT_ENGthreshold & 0x0F);

    pReg->sisRegs3C4[0x09] &= 0xF0;
    pReg->sisRegs3C4[0x09] |= (CRT_CPUthresholdHigh & 0x0F);

    pReg->sisRegs3C4[0x3F] &= 0xEB;
    pReg->sisRegs3C4[0x3F] |= (CRT_CPUthresholdHigh & 0x10) |
                       	      ((CRT_CPUthresholdLow & 0x10) >> 2);

    if(pSiS->oldChipset >= OC_SIS530A) {
     	pReg->sisRegs3C4[0x3F] &= 0xDF;
	pReg->sisRegs3C4[0x3F] |= 0x58;
    }

    /* TW: Set SiS6326 TV registers */
    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (sis6326tvmode)) {
      unsigned char tmp;
      int index=0, i, j, k;

      if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
         pReg->sisRegs3C4[0x0D] |= 0x04;
         switch(width) {
	   case 800:
	      if((strcmp(mode->name, "PAL800x600U") == 0))  index = 4;
	      else	        			    index = 3;
	      break;
	   case 720:
	      index = 5;
	      break;
	   case 640:
	   default:
	      index = 2;
	      break;
	 }
	 for(i=0; i<14; i++) {
	     pReg->sis6326tv[SiS6326TVRegs1[i]] = SiS6326TVRegs1_PAL[index][i];
	 }
      } else {
	pReg->sisRegs3C4[0x0D] &= ~0x04;
	if((strcmp(mode->name, "NTSC640x480U") == 0))  index = 5;
	else 					       index = 4;
        for(i=0; i<14; i++) {
	     pReg->sis6326tv[SiS6326TVRegs1[i]] = SiS6326TVRegs1_NTSC[index][i];
	}
      }
      tmp = pReg->sis6326tv[0x43];
      if(pSiS->SiS6326Flags & SIS6326_TVCVBS) tmp |= 0x10;
      tmp |= 0x08;
      pReg->sis6326tv[0x43] = tmp;
      j = 0; k = 0;
      for(i=0; i<=0x44; i++) {
	 if(SiS6326TVRegs1[j] == i) {
	 	j++;
		continue;
	 }
	 if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
		tmp = SiS6326TVRegs2_PAL[index][k];
	 } else {
		tmp = SiS6326TVRegs2_NTSC[index][k];
	 }
	 pReg->sis6326tv[i] = tmp;
	 k++;
      }
      pReg->sis6326tv[0x43] |= 0x08;
      if((pSiS->ChipRev == 0xc1) || (pSiS->ChipRev == 0xc2)) {
         pReg->sis6326tv[0x43] &= ~0x08;
      }

      tmp = pReg->sis6326tv[0];
      tmp |= 0x18;
      if(pSiS->SiS6326Flags & SIS6326_TVCVBS) tmp &= ~0x10;
      else				      tmp &= ~0x08;
      tmp |= 0x04;
      pReg->sis6326tv[0] = tmp;
d395 6
a400 8
/* TW: Init a mode for SiS 300 and 310/325 series
 *     The original intention of the followling procedure was
 *     to initialize various registers for the selected mode.
 *     This was actually done to a structure, not the hardware.
 *     (SiSRestore would write the structure to the hardware
 *     registers.)
 *     This function is now only used for setting up some
 *     variables (eg. scrnOffset).
d405 11
a415 3
    SISPtr         pSiS = SISPTR(pScrn);
    SISRegPtr      pReg = &pSiS->ModeReg;
    unsigned short temp;
a417 1

d420 5
a424 2
	pScrn->virtualX, pSiS->CurrentLayout.bitsPerPixel,
        pScrn->virtualX * pSiS->CurrentLayout.bitsPerPixel/8);
a425 1
    /* Copy current register settings to structure */
d428 1
a428 5
    /* TW: Calculate Offset/Display Pitch */
    pSiS->scrnOffset = pSiS->CurrentLayout.displayWidth *
                          ((pSiS->CurrentLayout.bitsPerPixel+7)/8);
    pSiS->scrnPitch = pSiS->scrnOffset;
    if (mode->Flags & V_INTERLACE)  pSiS->scrnPitch <<= 1;
d430 4
a433 3
#ifdef UNLOCK_ALWAYS
    outSISIDXREG(SISSR, 0x05, 0x86);
#endif
d435 1
a435 1
    switch(pSiS->CurrentLayout.bitsPerPixel) {
d438 1
a438 1
	    pSiS->SiS310_AccelDepth = 0x00000000;
d441 4
a444 3
	    if(pSiS->CurrentLayout.depth == 15)
	        pSiS->DstColor = (short) 0x4000;
	    else
d446 2
a447 1
	    pSiS->SiS310_AccelDepth = 0x00010000;
d450 1
d454 1
a454 1
	    pSiS->SiS310_AccelDepth = 0x00020000;
d458 61
a518 1
    /* TW: Enable PCI LINEAR ADDRESSING (0x80), MMIO (0x01), PCI_IO (0x20) */
d520 47
d569 3
a571 3
 *     the videoRAM (notably NOT the x framebuffer memory, which can/should
 *     be limited by MaxXFbMem when using DRI). Also, enable the accelerators.
 */
d573 3
a575 5
        pReg->sisRegs3C4[0x1E] |= 0x42;  /* TW: Enable 2D accelerator */
	pReg->sisRegs3C4[0x1E] |= 0x18;  /* TW: Enable 3D accelerator */
	switch (pSiS->VGAEngine) {
	case SIS_300_VGA:
	  if(pSiS->TurboQueue)  {    		/* set Turbo Queue as 512k */
d580 11
a590 9
          }	/* TW: line above new for saving D2&3 of status register */
	  break;
	case SIS_315_VGA:
	  /* See comments in sis_driver.c */
	  pReg->sisRegs3C4[0x27] = 0x1F;
	  pReg->sisRegs3C4[0x26] = 0x22;
	  pReg->sisMMIO85C0 = (pScrn->videoRam - 512) * 1024;
	  break;
	}
d596 2
a597 2
int
SISDoSense(ScrnInfoPtr pScrn, int tempbl, int tempbh, int tempcl, int tempch)
d600 31
a630 51
    int temp;

    outSISIDXREG(SISPART4,0x11,tempbl);
    temp = tempbh | tempcl;
    setSISIDXREG(SISPART4,0x10,0xe0,temp);
    usleep(200000);
    tempch &= 0x7f;
    inSISIDXREG(SISPART4,0x03,temp);
    temp ^= 0x0e;
    temp &= tempch;
    return(temp);
}

/* TW: Sense connected devices on 30x */
void SISSense30x(ScrnInfoPtr pScrn)
{
    SISPtr  pSiS = SISPTR(pScrn);
    unsigned char backupP4_0d,biosflag;
    unsigned char testsvhs_tempbl, testsvhs_tempbh;
    unsigned char testsvhs_tempcl, testsvhs_tempch;
    unsigned char testcvbs_tempbl, testcvbs_tempbh;
    unsigned char testcvbs_tempcl, testcvbs_tempch;
    unsigned char testvga2_tempbl, testvga2_tempbh;
    unsigned char testvga2_tempcl, testvga2_tempch;
    int myflag, result;
    unsigned short temp;

    inSISIDXREG(SISPART4,0x0d,backupP4_0d);
    outSISIDXREG(SISPART4,0x0d,(backupP4_0d | 0x04));

    if(pSiS->VGAEngine == SIS_315_VGA) {
       if(pSiS->sishw_ext.UseROM) {
          temp = 0xf3;
	  if(pSiS->Chipset == PCI_CHIP_SIS330) temp = 0x11b;
          if(pSiS->BIOS[temp] & 0x08) {
	      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	          "SiS30x: Video bridge has (unsupported) DVI combo connector\n");
	      orSISIDXREG(SISCR, 0x32, 0x80);
          } else {
	      andSISIDXREG(SISCR, 0x32, 0x7f);
	  }
       }
    }

    if(pSiS->VGAEngine == SIS_300_VGA) {

        if(pSiS->sishw_ext.UseROM) {
	   testvga2_tempbh = pSiS->BIOS[0xf9]; testvga2_tempbl = pSiS->BIOS[0xf8];
	   testsvhs_tempbh = pSiS->BIOS[0xfb]; testsvhs_tempbl = pSiS->BIOS[0xfa];
	   testcvbs_tempbh = pSiS->BIOS[0xfd]; testcvbs_tempbl = pSiS->BIOS[0xfc];
	   biosflag = pSiS->BIOS[0xfe];
d632 2
a633 4
	   testvga2_tempbh = 0x00; testvga2_tempbl = 0xd1;
           testsvhs_tempbh = 0x00; testsvhs_tempbl = 0xb9;
	   testcvbs_tempbh = 0x00; testcvbs_tempbl = 0xb3;
	   biosflag = 0;
d635 16
a650 4
	if(pSiS->VBFlags & (VB_301B|VB_302B|VB_30xLV|VB_30xLVX)) {
	   testvga2_tempbh = 0x01; testvga2_tempbl = 0x90;
	   testsvhs_tempbh = 0x01; testsvhs_tempbl = 0x6b;
	   testcvbs_tempbh = 0x01; testcvbs_tempbl = 0x74;
d652 21
a672 92
	inSISIDXREG(SISPART4,0x01,myflag);
	if(myflag & 0x04) {
	   testvga2_tempbh = 0x00; testvga2_tempbl = 0xfd;
	   testsvhs_tempbh = 0x00; testsvhs_tempbl = 0xdd;
	   testcvbs_tempbh = 0x00; testcvbs_tempbl = 0xee;
	}
	testvga2_tempch = 0x0e;	testvga2_tempcl = 0x08;
	testsvhs_tempch = 0x06;	testsvhs_tempcl = 0x04;
	testcvbs_tempch = 0x08; testcvbs_tempcl = 0x04;

    } else if((pSiS->Chipset == PCI_CHIP_SIS315) ||
    	      (pSiS->Chipset == PCI_CHIP_SIS315H) ||
	      (pSiS->Chipset == PCI_CHIP_SIS315PRO)) {

	if(pSiS->sishw_ext.UseROM) {
	   testvga2_tempbh = pSiS->BIOS[0xbe]; testvga2_tempbl = pSiS->BIOS[0xbd];
	   testsvhs_tempbh = pSiS->BIOS[0xc0]; testsvhs_tempbl = pSiS->BIOS[0xbf];
	   testcvbs_tempbh = pSiS->BIOS[0xc2]; testcvbs_tempbl = pSiS->BIOS[0xc1];
	   biosflag = pSiS->BIOS[0xf3];
	} else {
	   testvga2_tempbh = 0x00; testvga2_tempbl = 0xd1;
           testsvhs_tempbh = 0x00; testsvhs_tempbl = 0xb9;
	   testcvbs_tempbh = 0x00; testcvbs_tempbl = 0xb3;
	   biosflag = 0;
	}
	if(pSiS->VBFlags & (VB_301B|VB_302B|VB_30xLV|VB_30xLVX)) {
	   if(pSiS->sishw_ext.UseROM) {
	      testvga2_tempbh = pSiS->BIOS[0xc4]; testvga2_tempbl = pSiS->BIOS[0xc3];
	      testsvhs_tempbh = pSiS->BIOS[0xc6]; testsvhs_tempbl = pSiS->BIOS[0xc5];
	      testcvbs_tempbh = pSiS->BIOS[0xc8]; testcvbs_tempbl = pSiS->BIOS[0xc7];
	   } else {
	      testvga2_tempbh = 0x01; testvga2_tempbl = 0x90;
	      testsvhs_tempbh = 0x01; testsvhs_tempbl = 0x6b;
	      testcvbs_tempbh = 0x01; testcvbs_tempbl = 0x74;
	   }
	}
	inSISIDXREG(SISPART4,0x01,myflag);
	if(myflag & 0x04) {
	   testvga2_tempbh = 0x00; testvga2_tempbl = 0xfd;
	   testsvhs_tempbh = 0x00; testsvhs_tempbl = 0xdd;
	   testcvbs_tempbh = 0x00; testcvbs_tempbl = 0xee;
	}
	testvga2_tempch = 0x0e;	testvga2_tempcl = 0x08;
	testsvhs_tempch = 0x06;	testsvhs_tempcl = 0x04;
	testcvbs_tempch = 0x08; testcvbs_tempcl = 0x04;

    } else if(pSiS->Chipset == PCI_CHIP_SIS330) {

	if(pSiS->sishw_ext.UseROM) {
	   testvga2_tempbh = pSiS->BIOS[0xe6]; testvga2_tempbl = pSiS->BIOS[0xe5];
	   testsvhs_tempbh = pSiS->BIOS[0xe8]; testsvhs_tempbl = pSiS->BIOS[0xe7];
	   testcvbs_tempbh = pSiS->BIOS[0xea]; testcvbs_tempbl = pSiS->BIOS[0xe9];
	   biosflag = pSiS->BIOS[0x11b];
	} else {
	   testvga2_tempbh = 0x00; testvga2_tempbl = 0xd1;
           testsvhs_tempbh = 0x00; testsvhs_tempbl = 0xb9;
	   testcvbs_tempbh = 0x00; testcvbs_tempbl = 0xb3;
	   biosflag = 0;
	}
	if(pSiS->VBFlags & (VB_301B|VB_302B|VB_30xLV|VB_30xLVX)) {
	   if(pSiS->sishw_ext.UseROM) {
	      testvga2_tempbh = pSiS->BIOS[0xec]; testvga2_tempbl = pSiS->BIOS[0xeb];
	      testsvhs_tempbh = pSiS->BIOS[0xee]; testsvhs_tempbl = pSiS->BIOS[0xed];
	      testcvbs_tempbh = pSiS->BIOS[0xf0]; testcvbs_tempbl = pSiS->BIOS[0xef];
	   } else {
	      testvga2_tempbh = 0x01; testvga2_tempbl = 0x90;
	      testsvhs_tempbh = 0x01; testsvhs_tempbl = 0x6b;
	      testcvbs_tempbh = 0x01; testcvbs_tempbl = 0x74;
	   }
	}
	inSISIDXREG(SISPART4,0x01,myflag);
	if(myflag & 0x04) {
	   testvga2_tempbh = 0x00; testvga2_tempbl = 0xfd;
	   testsvhs_tempbh = 0x00; testsvhs_tempbl = 0xdd;
	   testcvbs_tempbh = 0x00; testcvbs_tempbl = 0xee;
	}
	testvga2_tempch = 0x0e;	testvga2_tempcl = 0x08;
	testsvhs_tempch = 0x06;	testsvhs_tempcl = 0x04;
	testcvbs_tempch = 0x08; testcvbs_tempcl = 0x04;

    } else {  /* 550?, 650, 740 */

        if(pSiS->sishw_ext.UseROM) {
	   testvga2_tempbh = pSiS->BIOS[0xbe]; testvga2_tempbl = pSiS->BIOS[0xbd];
	   testsvhs_tempbh = pSiS->BIOS[0xc0]; testsvhs_tempbl = pSiS->BIOS[0xbf];
	   testcvbs_tempbh = pSiS->BIOS[0xc2]; testcvbs_tempbl = pSiS->BIOS[0xc1];
	   biosflag = pSiS->BIOS[0xf3];
	} else {
	   testvga2_tempbh = 0x00; testvga2_tempbl = 0xd1;
           testsvhs_tempbh = 0x00; testsvhs_tempbl = 0xb9;
	   testcvbs_tempbh = 0x00; testcvbs_tempbl = 0xb3;
	   biosflag = 0;
d674 1
a674 83
	testvga2_tempch = 0x0e;	testvga2_tempcl = 0x08;
	testsvhs_tempch = 0x06; testsvhs_tempcl = 0x04;
	testcvbs_tempch = 0x08; testcvbs_tempcl = 0x04;

        /* TW: Different BIOS versions use different values for the 301LV.
	       These values are from the newest versions 1.10.6? and 1.10.7?.
	       I have no idea if these values are suitable for the 301B as well.
	 */

	if(pSiS->VBFlags & (VB_301B|VB_302B|VB_30xLV|VB_30xLVX)) {
  	   if(pSiS->sishw_ext.UseROM) {
	      testvga2_tempbh = pSiS->BIOS[0xc4]; testvga2_tempbl = pSiS->BIOS[0xc3];
	      testsvhs_tempbh = pSiS->BIOS[0xc6]; testsvhs_tempbl = pSiS->BIOS[0xc5];
	      testcvbs_tempbh = pSiS->BIOS[0xc8]; testcvbs_tempbl = pSiS->BIOS[0xc7];
	      biosflag = pSiS->BIOS[0xf3];
	   } else {
	      testvga2_tempbh = 0x01; testvga2_tempbl = 0x90;
	      testsvhs_tempbh = 0x02; testsvhs_tempbl = 0x00;
	      testcvbs_tempbh = 0x01; testcvbs_tempbl = 0x00;
	      biosflag = 0;
	   }
	   testvga2_tempch = 0x0e; testvga2_tempcl = 0x08;
	   testsvhs_tempch = 0x04; testsvhs_tempcl = 0x08;
	   testcvbs_tempch = 0x08; testcvbs_tempcl = 0x08;
	}

    }

    /* TW: No VGA2 or SCART on LV bridges */
    if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
	testvga2_tempbh = testvga2_tempbl = 0x00;
	testvga2_tempch = testvga2_tempcl = 0x00;
    }

    if(testvga2_tempch || testvga2_tempcl || testvga2_tempbh || testvga2_tempbl) {
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                "SiS30x: Scanning for VGA2/SCART (%x %x %x %x)\n",
    		testvga2_tempbh, testvga2_tempbl, testvga2_tempch, testvga2_tempcl);
#endif

       result = SISDoSense(pScrn, testvga2_tempbl, testvga2_tempbh,
                               testvga2_tempcl, testvga2_tempch);
       if(result) {
           if(biosflag & 0x01) {
	      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	         "SiS30x: Detected TV connected to SCART output\n");
	      pSiS->VBFlags |= TV_SCART;
	      orSISIDXREG(SISCR, 0x32, 0x04);
	      pSiS->postVBCR32 |= 0x04;
	   } else if(!(pSiS->VBFlags & (VB_30xLV|VB_30xLVX))) {
	      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	         "SiS30x: Detected secondary VGA connection\n");
	      pSiS->VBFlags |= VGA2_CONNECTED;
	      orSISIDXREG(SISCR, 0x32, 0x10);
	      pSiS->postVBCR32 |= 0x10;
	   }
       }
    }

#ifdef TWDEBUG
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                "SiS30x: Scanning for TV (%x %x %x %x; %x %x %x %x)\n",
    		testsvhs_tempbh, testsvhs_tempbl, testsvhs_tempch, testsvhs_tempcl,
		testcvbs_tempbh, testcvbs_tempbl, testcvbs_tempch, testcvbs_tempcl);
#endif

    result = SISDoSense(pScrn, testsvhs_tempbl, testsvhs_tempbh,
                               testsvhs_tempcl, testsvhs_tempch);
    if(result) {
        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      "SiS30x: Detected TV connected to SVIDEO output\n");
        /* TW: So we can be sure that there IS a SVIDEO output */
	pSiS->VBFlags |= TV_SVIDEO;
	orSISIDXREG(SISCR, 0x32, 0x02);
	pSiS->postVBCR32 |= 0x02;
    }

    if((biosflag & 0x02) || (!(result))) {

        result = SISDoSense(pScrn, testcvbs_tempbl, testcvbs_tempbh,
	                           testcvbs_tempcl, testcvbs_tempch);
	if(result) {
d676 1
a676 5
	          "SiS30x: Detected TV connected to COMPOSITE output\n");
	    /* TW: So we can be sure that there IS a CVBS output */
	    pSiS->VBFlags |= TV_AVIDEO;
	    orSISIDXREG(SISCR, 0x32, 0x01);
	    pSiS->postVBCR32 |= 0x01;
a678 86
    SISDoSense(pScrn, 0, 0, 0, 0);

    outSISIDXREG(SISPART4,0x0d,backupP4_0d);
}

static void
SiS6326TVDelay(ScrnInfoPtr pScrn, int delay)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int i;
    unsigned char temp;

    for(i=0; i<delay; i++) {
    	inSISIDXREG(SISSR, 0x05, temp);
    }
}

int
SIS6326DoSense(ScrnInfoPtr pScrn, int tempbh, int tempbl, int tempch, int tempcl)
{
    unsigned char temp;

    SiS6326SetTVReg(pScrn, 0x42, tempbl);
    temp = SiS6326GetTVReg(pScrn, 0x43);
    temp &= 0xfc;
    temp |= tempbh;
    SiS6326SetTVReg(pScrn, 0x43, temp);
    SiS6326TVDelay(pScrn, 0x1000);
    temp = SiS6326GetTVReg(pScrn, 0x43);
    temp |= 0x04;
    SiS6326SetTVReg(pScrn, 0x43, temp);
    SiS6326TVDelay(pScrn, 0x8000);
    temp = SiS6326GetTVReg(pScrn, 0x44);
    if(!(tempch & temp)) tempcl = 0;
    return(tempcl);
}

void
SISSense6326(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char temp;
    int result;

    pSiS->SiS6326Flags &= (SIS6326_HASTV | SIS6326_TVPAL);
    temp = SiS6326GetTVReg(pScrn, 0x43);
    temp &= 0xfb;
    SiS6326SetTVReg(pScrn, 0x43, temp);
    result = SIS6326DoSense(pScrn, 0x01, 0xb0, 0x06, SIS6326_TVSVIDEO);  /* 0x02 */
    pSiS->SiS6326Flags |= result;
    result = SIS6326DoSense(pScrn, 0x01, 0xa0, 0x01, SIS6326_TVCVBS);    /* 0x04 */
    pSiS->SiS6326Flags |= result;
    temp = SiS6326GetTVReg(pScrn, 0x43);
    temp &= 0xfb;
    SiS6326SetTVReg(pScrn, 0x43, temp);
    if(pSiS->SiS6326Flags & (SIS6326_TVSVIDEO | SIS6326_TVCVBS)) {
    	pSiS->SiS6326Flags |= SIS6326_TVDETECTED;
	xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		"SiS6326: Detected TV connected to %s output\n",
		(pSiS->SiS6326Flags & SIS6326_TVSVIDEO) ?
			"SVIDEO" : "COMPOSITE");
    } else {
        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		"SiS6326: No TV detected\n");
    }
}

/* TW: Detect video bridge and set VBFlags accordingly */
void SISVGAPreInit(ScrnInfoPtr pScrn)
{
    SISPtr  pSiS = SISPTR(pScrn);
    int     temp,temp1,temp2;
    int     upperlimitlvds, lowerlimitlvds;
    int     upperlimitch, lowerlimitch;
    int     chronteltype, chrontelidreg;
    static const char  *ChrontelTypeStr[] = {
        "7004",
	"7005",
	"7007",
	"7006",
	"7008",
	"7013",
	"7019",
	"7020",
	"(unknown)"
    };
a683 6
	case PCI_CHIP_SIS550:
	case PCI_CHIP_SIS650:
	case PCI_CHIP_SIS315:
	case PCI_CHIP_SIS315H:
	case PCI_CHIP_SIS315PRO:
	case PCI_CHIP_SIS330:
a688 304

    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
        unsigned char sr0d;
	inSISIDXREG(SISSR, 0x0d, sr0d);
	if(sr0d & 0x04) {
		pSiS->SiS6326Flags |= SIS6326_TVPAL;
	}
	SISSense6326(pScrn);
    }

    pSiS->VBFlags = 0; /* reset VBFlags */

    /* TW: Videobridges only available for 300/310/325 series */
    if((pSiS->VGAEngine != SIS_300_VGA) && (pSiS->VGAEngine != SIS_315_VGA))
        return;

    inSISIDXREG(SISPART4, 0x00, temp);
    temp &= 0x0F;
    if (temp == 1) {
        inSISIDXREG(SISPART4, 0x01, temp1);
	temp1 &= 0xff;
	if (temp1 >= 0xE0) {
	   	pSiS->VBFlags |= VB_30xLVX;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301LVX;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		                "Detected SiS301LVX video bridge (Revision 0x%x)\n",
				temp1);
	} else if (temp1 >= 0xD0) {
	   	pSiS->VBFlags |= VB_30xLV;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301LV;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		                "Detected SiS301LV video bridge (Revision 0x%x)\n",
				temp1);
	} else if (temp1 >= 0xB0) {
	        pSiS->VBFlags |= VB_301B;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301B;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		                "Detected SiS301B video bridge (Revision 0x%x)\n",
				temp1);
	} else {
	        pSiS->VBFlags |= VB_301;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301;
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		                "Detected SiS301 video bridge (Revision 0x%x)\n",
				temp1);
	}
	if (pSiS->VBFlags & (VB_30xLV | VB_30xLVX)) {
	   inSISIDXREG(SISCR, 0x38, temp);
	   if((temp & 0x03) == 0x03) {
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		                "[SiS301LV/LVX: LCD channel A]\n");
	   }
	}

	SISSense30x(pScrn);

    } else if (temp == 2) {

        inSISIDXREG(SISPART4, 0x01, temp1);
	temp1 &= 0xff;
	if (temp1 >= 0xE0) {
        	pSiS->VBFlags |= VB_30xLVX;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_302LVX;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		                "Detected SiS302LVX video bridge (Revision 0x%x)\n",
				temp1);
	} else if (temp1 >= 0xD0) {
        	pSiS->VBFlags |= VB_30xLV;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_302LV;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		                "Detected SiS302LV video bridge (Revision 0x%x)\n",
				temp1);
	} else {
	        pSiS->VBFlags |= VB_302B;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_302B;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		                "Detected SiS302B video bridge (Revision 0x%x)\n",
				temp1);
	}
	if (pSiS->VBFlags & (VB_302B | VB_30xLV | VB_30xLVX)) {
	   inSISIDXREG(SISCR, 0x38, temp);
	   if((temp & 0x03) == 0x03) {
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		                "[SiS302B/LV/LVX: LCD channel A]\n");
	   }
	}

	SISSense30x(pScrn);

    } else if (temp == 3) {

        pSiS->VBFlags |= VB_303;
	pSiS->sishw_ext.ujVBChipID = VB_CHIP_303;
    	xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	           "Detected SiS303 video bridge\n");

    } else {

        pSiS->sishw_ext.ujVBChipID = VB_CHIP_UNKNOWN;
	inSISIDXREG(SISCR, 0x37, temp);
        temp = (temp >> 1) & 0x07;
#if 0   /* TW: This does not seem to be used on any machine */
	if ( (temp == 0) || (temp == 1)) {
	    pSiS->VBFlags|=VB_301;   /* TW: 301 ? */
	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	               "Detected SiS301 video bridge (Irregular bridge type %d)\n", temp);
	}
#endif
        if(pSiS->VGAEngine == SIS_300_VGA) {
	   lowerlimitlvds = 2; upperlimitlvds = 4;
	   lowerlimitch   = 4; upperlimitch   = 5;
	   chronteltype = 1;   chrontelidreg  = 0x25;
        } else {
	   lowerlimitlvds = 2; upperlimitlvds = 3;
	   lowerlimitch   = 3; upperlimitch   = 3;
	   chronteltype = 2;   chrontelidreg  = 0x4b;
	}

	if((temp >= lowerlimitlvds) && (temp <= upperlimitlvds)) {
               pSiS->VBFlags |= VB_LVDS;
    	       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	               "Detected LVDS transmitter (Bridge type %d)\n", temp);
	       if(pSiS->Chipset == PCI_CHIP_SIS650) {
	       	   inSISIDXREG(SISCR, 0x38, temp1);
                   if(temp1 & 0x02) {
		      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		                 "[LVDS: LCD channel A]\n");
		   }
		   if(temp1 & 0x08) {
		      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		                 "[LVDS: HDTV]\n");
		   }
		   if(temp1 & 0x08) {
		      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		                 "[LVDS: SCART]\n");
		   }
	       }
	}
        if((temp >= lowerlimitch) && (temp <= upperlimitch))  {
	    /* TW: Set global for init301.c */
	    pSiS->SiS_Pr->SiS_IF_DEF_CH70xx = chronteltype;

	    if(chronteltype == 1) {
	       /* TW: Do something mysterious (found in Mitac BIOS) */
	       SiS_WhatIsThis(pSiS->SiS_Pr, 0x9c);
	    }

	    /* TW: Read Chrontel version number */
 	    temp1 = SiS_GetCH70xx(pSiS->SiS_Pr, chrontelidreg);
	    if(chronteltype == 1) {
	        /* TW: See Chrontel TB31 for explanation */
		temp2 = SiS_GetCH700x(pSiS->SiS_Pr, 0x0e);
		if(((temp2 & 0x07) == 0x01) || (temp & 0x04)) {
		    SiS_SetCH700x(pSiS->SiS_Pr, 0x0b0e);
		    SiS_DDC2Delay(pSiS->SiS_Pr, 300);
		}
	        temp2 = SiS_GetCH70xx(pSiS->SiS_Pr, chrontelidreg);
		if(temp2 != temp1) temp1 = temp2;
	    }
	    if(temp1 == 0xFFFF) {	/* 0xFFFF = error reading DDC port */
	    	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			"Detected Chrontel 70xx, but encountered error reading I2C port\n");
	    }
	    /* TW: We only support device ids 0x19-200; other values may indicate DDC problems */
	    else if((temp1 >= 0x19) && (temp1 <= 200)) {
	        pSiS->VBFlags |= VB_CHRONTEL;
		switch (temp1) {
		   case 0x32: temp2 = 0; pSiS->ChrontelType = CHRONTEL_700x; break;
		   case 0x3A: temp2 = 1; pSiS->ChrontelType = CHRONTEL_700x; break;
		   case 0x50: temp2 = 2; pSiS->ChrontelType = CHRONTEL_700x; break;
		   case 0x2A: temp2 = 3; pSiS->ChrontelType = CHRONTEL_700x; break;
		   case 0x40: temp2 = 4; pSiS->ChrontelType = CHRONTEL_700x; break;
		   case 0x22: temp2 = 5; pSiS->ChrontelType = CHRONTEL_700x; break;
	           case 0x19: temp2 = 6; pSiS->ChrontelType = CHRONTEL_701x; break;
	           case 0x20: temp2 = 7; pSiS->ChrontelType = CHRONTEL_701x; break;  /* ID for 7020? */
		   default:   temp2 = 8; pSiS->ChrontelType = CHRONTEL_701x; break;
		}
   	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	               "Detected Chrontel %s TV encoder (ID 0x%02x; bridge type %d)\n",
		       			ChrontelTypeStr[temp2], temp1, temp);

		/* TW: Sense connected TV's */

		if(chronteltype == 1) {

		   /* Chrontel 700x */

	    	   /* TW: Read power status */
	    	   temp1 = SiS_GetCH700x(pSiS->SiS_Pr, 0x0e);  /* Power status */
	    	   if((temp1 & 0x03) != 0x03) {
		        /* TW: Power all outputs */
	        	SiS_SetCH700x(pSiS->SiS_Pr, 0x0B0E);
			SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);
	    	   }
		   /* TW: Sense connected TV devices */
	    	   SiS_SetCH700x(pSiS->SiS_Pr, 0x0110);
		   SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);
	    	   SiS_SetCH700x(pSiS->SiS_Pr, 0x0010);
		   SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);
	    	   temp1 = SiS_GetCH700x(pSiS->SiS_Pr, 0x10);
		   if(!(temp1 & 0x08))       temp1 = 0x02;
		   else if(!(temp1 & 0x02))  temp1 = 0x01;
		   else                      temp1 = 0;

		} else {

		   /* Chrontel 701x */

		   /* TW: Backup Power register */
		   temp1 = SiS_GetCH701x(pSiS->SiS_Pr, 0x49);

		   /* TW: Enable TV path */
		   SiS_SetCH701x(pSiS->SiS_Pr, 0x2049);

		   SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);

		   /* TW: Sense connected TV devices */
		   temp2 = SiS_GetCH701x(pSiS->SiS_Pr, 0x20);
		   temp2 |= 0x01;
		   SiS_SetCH701x(pSiS->SiS_Pr, (temp2 << 8) | 0x20);

		   SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);

		   temp2 ^= 0x01;
		   SiS_SetCH701x(pSiS->SiS_Pr, (temp2 << 8) | 0x20);

		   SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);

		   temp2 = SiS_GetCH701x(pSiS->SiS_Pr, 0x20); 

		   /* TW: Restore Power register */
		   SiS_SetCH701x(pSiS->SiS_Pr, (temp1 << 8) | 0x49);

                   temp1 = 0;
		   if(temp2 & 0x02) temp1 |= 0x01;
		   if(temp2 & 0x10) temp1 |= 0x01;
		   if(temp2 & 0x04) temp1 |= 0x02;

		   if( (temp1 & 0x01) && (temp1 & 0x02) ) temp1 = 0x04;

                }

		switch(temp1) {
		     case 0x01:
		        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		  	   "Chrontel: Detected TV connected to COMPOSITE output\n");
		        /* TW: So we can be sure that there IS a CVBS output */
			pSiS->VBFlags |= TV_AVIDEO;
			orSISIDXREG(SISCR, 0x32, 0x01);
			pSiS->postVBCR32 |= 0x01;
                        break;
                     case 0x02:
			xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			   "Chrontel: Detected TV connected to SVIDEO output\n");
			/* TW: So we can be sure that there IS a SVIDEO output */
			pSiS->VBFlags |= TV_SVIDEO;
			orSISIDXREG(SISCR, 0x32, 0x02);
			pSiS->postVBCR32 |= 0x02;
                        break;
		     case 0x04:
			xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			   "Chrontel: Detected TV connected to SCART output or 480i HDTV\n");
			if(pSiS->chtvtype == -1) {
			   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			      "Chrontel: Use CHTVType option to select either SCART or HDTV\n");
			   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			      "Chrontel: Using SCART by default\n");
			   pSiS->chtvtype = 1;
			}
			if(pSiS->chtvtype)
			    pSiS->VBFlags |= TV_CHSCART;
			else
			    pSiS->VBFlags |= TV_CHHDTV;
                        break;
		     default:
		        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		  	   "Chrontel: No TV detected.\n");
		}

	    } else if(temp1==0) {
	        /* TW: This indicates a communication problem, but it only occures if there
		 *     is no TV attached.
		 */
	    	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"Detected Chrontel TV encoder in promiscuous state (DDC/I2C mix-up)\n");
	    } else {
	    	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			"Chrontel: Unsupported device id (%d) detected\n",temp1);
	    }
	    if(chronteltype == 1) {
	       /* TW: Do something mysterious (found in Mitac BIOS) */
	       SiS_WhatIsThis(pSiS->SiS_Pr, 0x00);
	    }
	}
	if ((pSiS->VGAEngine == SIS_300_VGA) && (temp == 3)) {
	    pSiS->VBFlags |= VB_TRUMPION;
	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	               "Detected Trumpion Zurac (I/II/III) LVDS scaler\n");
	}
	if (temp > upperlimitlvds) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	               "Detected unknown bridge type (%d)\n", temp);
	}
    }
a689 2


@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_vga.c,v 1.43 2004/01/23 22:29:06 twini Exp $ */
d3 1
a3 1
 * Mode setup and basic video bridge detection
d5 2
a6 1
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria.
d8 9
a16 13
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement: "This product includes
 *    software developed by Thomas Winischhofer, Vienna, Austria."
 * 4) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d18 7
a24 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d26 6
a31 5
 * Author: 	Thomas Winischhofer <thomas@@winischhofer.net>
 *
 * Init() function for old series (except for TV and FIFO calculation)
 * previously based on code which is Copyright (C) 1998,1999 by Alan
 * Hourihane, Wigan, England
d45 14
a58 3
#if 0
#define TV6326TEST
#endif
d62 6
a67 10
/* To be used internally only */
static int   SISDoSense(ScrnInfoPtr pScrn, int tempbl, int tempbh, int tempcl, int tempch);
static void  SISSense30x(ScrnInfoPtr pScrn);
static int   SIS6326DoSense(ScrnInfoPtr pScrn, int tempbh, int tempbl, int tempch, int tempcl);
static void  SISSense6326(ScrnInfoPtr pScrn);
static void  SiS6326TVDelay(ScrnInfoPtr pScrn, int delay);

const CARD8 SiS6326TVRegs1[14] = {
     0x00,0x01,0x02,0x03,0x04,0x11,0x12,0x13,0x21,0x26,0x27,0x3a,0x3c,0x43
};
d74 1
a74 1
    {0x81,0x3f,0x24,0x8e,0x26,0x09,0x00,0x09,0x02,0x30,0x10,0x3b,0x51,0x60},  /* 640x400, 640x480 */
a77 11
#ifdef TV6326TEST
const CARD8 SiS6326TVRegs1_NTSC_2[6][3] = {
    {          0x00,0x00,0x00},
    {          0x00,0x00,0x00},
    {          0x24,0x92,0x49},
    {          0x24,0x92,0x49},  			/* 8a50 */
    {          0x24,0x92,0x49},  /* 640x400, 640x480 */ /* 8afc */
    {          0x21,0xbe,0x75}   /* 640x480u */         /* n/a  */
};
#endif

d114 2
a115 2
    {0x81,0x2d,0xa4,0x03,0xd9,0x0b,0x00,0x09,0x02,0xed,0x10,0xf8,0x71,0x40},  /* 640x480 */
    {0x81,0x2d,0xa4,0x03,0xd9,0x0b,0x00,0x09,0x02,0x8f,0x10,0x9a,0x71,0x40},  /* 800x600 */
a119 11
#ifdef TV6326TEST
const CARD8 SiS6326TVRegs1_PAL_2[6][3] = {
    {          0x00,0x00,0x00},
    {          0x00,0x00,0x00},
    {          0xa4,0x07,0xd9},   /* 640x480  */  /* 887e */
    {          0xa4,0x08,0x19},   /* 800x600  */  /* 8828 */
    {          0xa1,0x7e,0xa3},   /* 800x600u */  /* n/a  */
    {          0xa4,0x07,0xd9}    /* 720x540  */  /* n/a  */
};
#endif

d131 1
a131 1
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,  /* 640x480 */
d136 1
a136 1
    {0x15, 0x4E, 0x35, 0x6E, 0x94, 0x02, 0x04, 0x38, 0x3A, 0x50, 0x3D,  /* 800x600 */
d153 3
d198 2
a199 2
    /* Determine if chosen mode is suitable for TV on the 6326
     * and if the mode is one of our special hi-res modes.
d204 18
a221 18
       if(pSiS->SiS6326Flags & SIS6326_HASTV) {
          if((pSiS->SiS6326Flags & SIS6326_TVDETECTED) &&
             ((strcmp(mode->name, "PAL800x600") == 0)   ||	/* Special TV modes */
              (strcmp(mode->name, "PAL800x600U") == 0)  ||
	      (strcmp(mode->name, "PAL720x540") == 0)   ||
              (strcmp(mode->name, "PAL640x480") == 0)   ||
	      (strcmp(mode->name, "NTSC640x480") == 0)  ||
	      (strcmp(mode->name, "NTSC640x480U") == 0) ||
	      (strcmp(mode->name, "NTSC640x400") == 0))) {
	     sis6326tvmode = TRUE;
          } else {
             pReg->sis6326tv[0x00] &= 0xfb;
          }
       }
       if((strcmp(mode->name, "SIS1280x1024-75") == 0) ||	/* Special high-res modes */
          (strcmp(mode->name, "SIS1600x1200-60") == 0)) {
	  sis6326himode = TRUE;
       }
d228 1
a228 3
    if(!pSiS->UseVESA) {
       pReg->sisRegs3C4[0x06] &= 0x01;
    }
d232 1
a232 1
       offset = pSiS->CurrentLayout.displayWidth >> 3;
d234 2
a235 4
       offset = pSiS->CurrentLayout.displayWidth >> 2;
       if(!pSiS->UseVESA) {
          pReg->sisRegs3C4[0x06] |= 0x20;
       }
d239 1
a239 3
    if(!pSiS->UseVESA) {
       pReg->sisRegs3C4[0x06] |= 0x82;
    }
d242 1
a242 6
    if(pSiS->oldChipset >= OC_SIS5597) {
       pReg->sisRegs3C4[0x0B] |= 0x60;
    } else {
       pReg->sisRegs3C4[0x0B] |= 0x20;
       pReg->sisRegs3C4[0x0B] &= ~0x40;
    }
d244 2
a245 1
    if(!pSiS->UseVESA) {
d247 17
a263 5
       /* Enable 32bit mem access (D7), read-ahead cache (D5) */
       pReg->sisRegs3C4[0x0C] |= 0x80;
       if(pSiS->oldChipset > OC_SIS6225) {
          pReg->sisRegs3C4[0x0C] |= 0x20;
       }
d265 10
a274 28
       /* Some speed-up stuff */
       switch(pSiS->Chipset) {
       case PCI_CHIP_SIS5597:
          /* enable host bus */
	  if(pSiS->NoHostBus) {
	     pReg->sisRegs3C4[0x34] &= ~0x08;
	  } else {
            pReg->sisRegs3C4[0x34] |= 0x08;
	  }
          /* fall through */
       case PCI_CHIP_SIS6326:
       case PCI_CHIP_SIS530:
          /* Enable "dual segment register mode" (D2) and "i/o gating while
           * write buffer is not empty" (D3)
           */
    	  pReg->sisRegs3C4[0x0B] |= 0x0C;
       }

       /* set colordepth */
       if(pSiS->Chipset == PCI_CHIP_SIS530) {
          pReg->sisRegs3C4[0x09] &= 0x7F;
       }
       switch(pSiS->CurrentLayout.bitsPerPixel) {
          case 8:
             break;
          case 16:
	     offset <<= 1;
	     if(pSiS->CurrentLayout.depth == 15)
d276 1
a276 1
	     else
d278 8
a285 8
             break;
          case 24:
             offset += (offset << 1);
             pReg->sisRegs3C4[0x06] |= 0x10;
             pReg->sisRegs3C4[0x0B] |= 0x90;
             break;
          case 32:
             if(pSiS->Chipset == PCI_CHIP_SIS530) {
d287 1
a287 3
	        if(pSiS->oldChipset != OC_SIS620) {
                   pReg->sisRegs3C4[0x06] |= 0x10;
	        }
d290 2
a291 3
             } else return FALSE;
             break;
       }
d298 17
a314 1
    if(!pSiS->UseVESA) {
d316 2
a317 11
       /* set linear framebuffer addresses */
       switch(pScrn->videoRam)  {
          case 512:  temp = 0x00;  break;
          case 1024: temp = 0x20;  break;
          case 2048: temp = 0x40;  break;
          case 4096: temp = 0x60;  break;
          case 8192: temp = 0x80;  break;
          default:   temp = 0x20;
       }
       pReg->sisRegs3C4[0x20] = (pSiS->FbAddress & 0x07F80000) >> 19;
       pReg->sisRegs3C4[0x21] = ((pSiS->FbAddress & 0xF8000000) >> 27) | temp;
d319 2
a320 2
       /* Set screen offset */
       vgaReg->CRTC[0x13] = offset & 0xFF;
d322 1
a322 2
       /* Set CR registers for our built-in TV and hi-res modes */
       if((sis6326tvmode) || (sis6326himode)) {
d324 20
a343 6
	  int index,i;

	  /* We need our very private data for hi-res and TV modes */
	  if(sis6326himode) {
	     if(strcmp(mode->name, "SIS1280x1024-75") == 0)  index = 7;
	     else index = 8;
d345 11
a355 31
	     if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
	        switch(width) {
	        case 800:
	           if((strcmp(mode->name, "PAL800x600U") == 0))
	      	      index = 4;
	           else
	              index = 0;
	           break;
	        case 720:
	           index = 5;
	           break;
	        case 640:
	        default:
	           index = 1;
	        }
	     } else {
	        switch(height) {
	        case 400:
	           index = 3;
	           break;
	        case 480:
	        default:
	           if((strcmp(mode->name, "NTSC640x480U") == 0))
	              index = 6;
	           else
	              index = 2;
	        }
	     }
          }
	  for(i=0; i<=5; i++) {
	     vgaReg->CRTC[i] = SiS6326CR[index][i];
d357 37
a393 33
          pReg->sisRegs3C4[0x12] = SiS6326CR[index][6];
	  vgaReg->CRTC[6] = SiS6326CR[index][7];
	  vgaReg->CRTC[7] = SiS6326CR[index][8];
	  vgaReg->CRTC[0x10] = SiS6326CR[index][9];
	  vgaReg->CRTC[0x11] = SiS6326CR[index][10];
	  vgaReg->CRTC[0x12] = SiS6326CR[index][11];
	  vgaReg->CRTC[0x15] = SiS6326CR[index][12];
	  vgaReg->CRTC[0x16] = SiS6326CR[index][13];
	  vgaReg->CRTC[9] &= ~0x20;
	  vgaReg->CRTC[9] |= (SiS6326CR[index][14] & 0x20);
	  pReg->sisRegs3C4[0x0A] = ((offset & 0xF00) >> 4) | (SiS6326CR[index][14] & 0x0f);

       } else {

          /* Set extended vertical overflow register */
          pReg->sisRegs3C4[0x0A] = ((offset & 0xF00) >> 4) |
                 (((mode->CrtcVTotal-2)     & 0x400) >> 10 ) |
                 (((mode->CrtcVDisplay-1)   & 0x400) >>  9 ) |
/*               (((mode->CrtcVSyncStart-1) & 0x400) >>  8 ) |  */
	         (((mode->CrtcVBlankStart-1)& 0x400) >>  8 ) |
/*               (((mode->CrtcVBlankStart-1)& 0x400) >>  7 );  */
                 (((mode->CrtcVSyncStart)   & 0x400) >>  7 );

          /* Set extended horizontal overflow register */
          pReg->sisRegs3C4[0x12] &= 0xE0;
          pReg->sisRegs3C4[0x12] |= (
              (((mode->CrtcHTotal >> 3) - 5)      & 0x100) >> 8 |
              (((mode->CrtcHDisplay >> 3) - 1)    & 0x100) >> 7 |
/*            (((mode->CrtcHSyncStart >> 3) - 1)  & 0x100) >> 6 |  */
              (((mode->CrtcHBlankStart >> 3) - 1) & 0x100) >> 6 |
              ((mode->CrtcHSyncStart >> 3)        & 0x100) >> 5 |
              (((mode->CrtcHBlankEnd >> 3) - 1)   & 0x40)  >> 2);
       }
d396 1
a396 1
       xf86DrvMsg(0, X_INFO, "HDisplay %d HSyncStart %d HSyncEnd %d HTotal %d\n",
d399 1
a399 1
       xf86DrvMsg(0, X_INFO, "HBlankSt %d  HBlankE %d\n",
d402 1
a402 1
       xf86DrvMsg(0, X_INFO, "VDisplay %d VSyncStart %d VSyncEnd %d VTotal %d\n",
d405 1
a405 1
       xf86DrvMsg(0, X_INFO, "VBlankSt %d  VBlankE %d\n",
d409 69
a477 81
       /* enable (or disable) line compare */
       if(mode->CrtcVDisplay >= 1024)
          pReg->sisRegs3C4[0x38] |= 0x04;
       else
          pReg->sisRegs3C4[0x38] &= 0xFB;

       /* Enable (or disable) high speed DCLK (some 6326 and 530/620 only) */
       if( ( (pSiS->Chipset == PCI_CHIP_SIS6326) &&
             ( (pSiS->ChipRev == 0xd0) || (pSiS->ChipRev == 0xd1) ||
               (pSiS->ChipRev == 0xd2) || (pSiS->ChipRev == 0x92) ||
	       (pSiS->Flags & A6326REVAB) ) ) ||
           (pSiS->oldChipset > OC_SIS6326) ) {
         if( (pSiS->CurrentLayout.bitsPerPixel == 24) ||
             (pSiS->CurrentLayout.bitsPerPixel == 32) ||
             (mode->CrtcHDisplay >= 1280) )
            pReg->sisRegs3C4[0x3E] |= 0x01;
         else
            pReg->sisRegs3C4[0x3E] &= 0xFE;
       }

       /* We use the internal VCLK */
       pReg->sisRegs3C4[0x38] &= 0xFC;

       /* Programmable Clock */
       pReg->sisRegs3C2 = inb(SISMISCR) | 0x0C;

       if(pSiS->oldChipset <= OC_SIS86202) {
          /* TODO: Handle SR07 for clock selection */
	  /* 86C201 does not even have a programmable clock... */
	  /* pReg->sisRegs3C4[0x07] &= 0x??; */
       }

       /* Set VCLK */
       if((sis6326tvmode) || (sis6326himode)) {

          /* For our built-in modes, the calculation is not suitable */
          if(sis6326himode) {
             if((strcmp(mode->name, "SIS1280x1024-75") == 0)) {
	        pReg->sisRegs3C4[0x2A] = 0x5d;	/* 1280x1024-75 */
                pReg->sisRegs3C4[0x2B] = 0xa4;
             } else {
	        pReg->sisRegs3C4[0x2A] = 0x59;	/* 1600x1200-60 */
                pReg->sisRegs3C4[0x2B] = 0xa3;
             }
	     pReg->sisRegs3C4[0x13] &= ~0x40;
          } else {
             if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
	        /* PAL: 31.500 Mhz */
	        if((strcmp(mode->name, "PAL800x600U") == 0)) {
   	           pReg->sisRegs3C4[0x2A] = 0x46;
                   pReg->sisRegs3C4[0x2B] = 0x49;
	        } else {
	           pReg->sisRegs3C4[0x2A] = 0xab;
                   pReg->sisRegs3C4[0x2B] = 0xe9;
	        }
	        pReg->sisRegs3C4[0x13] &= ~0x40;
	     } else {
	        /* NTSC: 27.000 Mhz */
	        if((strcmp(mode->name, "NTSC640x480U") == 0)) {
	           pReg->sisRegs3C4[0x2A] = 0x5a;
                   pReg->sisRegs3C4[0x2B] = 0x65;
	        } else {
	           pReg->sisRegs3C4[0x2A] = 0x29;
                   pReg->sisRegs3C4[0x2B] = 0xe2;
	        }
	        pReg->sisRegs3C4[0x13] |= 0x40;
	     }
          }

       } else if(SiS_compute_vclk(clock, &num, &denum, &div, &sbit, &scale)) {

          pReg->sisRegs3C4[0x2A] = (num - 1) & 0x7f ;
          pReg->sisRegs3C4[0x2A] |= (div == 2) ? 0x80 : 0;
          pReg->sisRegs3C4[0x2B] = ((denum - 1) & 0x1f);
          pReg->sisRegs3C4[0x2B] |= (((scale -1) & 3) << 5);

	  /* When setting VCLK, we should set SR13 first */
          if(sbit)
             pReg->sisRegs3C4[0x13] |= 0x40;
          else
             pReg->sisRegs3C4[0x13] &= 0xBF;
d480 1
a480 1
	  xf86DrvMsg(0, X_INFO, "2a: %x 2b: %x 13: %x clock %d\n",
d484 3
a486 1
       } else {
d488 2
a489 2
          /* if SiS_compute_vclk cannot handle the requested clock, try sisCalcClock */
          SiSCalcClock(pScrn, clock, 2, vclk);
d491 2
a492 22
#define Midx    0
#define Nidx    1
#define VLDidx  2
#define Pidx    3
#define PSNidx  4	  

          pReg->sisRegs3C4[0x2A] = (vclk[Midx] - 1) & 0x7f;
          pReg->sisRegs3C4[0x2A] |= ((vclk[VLDidx] == 2) ? 1 : 0) << 7;

	  /* bits [4:0] contain denumerator */
          pReg->sisRegs3C4[0x2B] = (vclk[Nidx] - 1) & 0x1f;

          if(vclk[Pidx] <= 4){
             /* postscale 1,2,3,4 */
             pReg->sisRegs3C4[0x2B] |= (vclk[Pidx] - 1) << 5;
             pReg->sisRegs3C4[0x13] &= 0xBF;
          } else {
             /* postscale 6,8 */
             pReg->sisRegs3C4[0x2B] |= ((vclk[Pidx] / 2) - 1) << 5;
             pReg->sisRegs3C4[0x13] |= 0x40;
          }
          pReg->sisRegs3C4[0x2B] |= 0x80 ;   /* gain for high frequency */
d494 27
a520 33
       }

       /* High speed DAC */
       if(clock > 135000)
          pReg->sisRegs3C4[0x07] |= 0x02;

       if(pSiS->oldChipset > OC_SIS6225) {
          /* 1 or 2 cycle DRAM (set by option FastVram) */
          if(pSiS->newFastVram == -1) {
             if(pSiS->oldChipset == OC_SIS620) {
	        /* Use different default on the 620 */
                pReg->sisRegs3C4[0x34] |= 0x40;
	        pReg->sisRegs3C4[0x34] &= ~0x80;
             } else {
                pReg->sisRegs3C4[0x34] |= 0x80;
	        pReg->sisRegs3C4[0x34] &= ~0x40;
             }
          } else if(pSiS->newFastVram == 1)
             pReg->sisRegs3C4[0x34] |= 0xC0;
          else
             pReg->sisRegs3C4[0x34] &= ~0xC0;

          if(pSiS->oldChipset == OC_SIS620) {
             /* Enable SGRAM burst timing (= bit clear) on the 620 */
             if(pSiS->Flags & SYNCDRAM) {
                pReg->sisRegs3C4[0x35] &= ~0x20;
             } else {
                pReg->sisRegs3C4[0x35] |= 0x20;
             }
          }
       }

    } /* VESA */
d550 24
a573 15
       pReg->sisRegs3C4[0x27] |= 0x40;   /* Enable engine programming registers */
       if( (pSiS->TurboQueue) &&	 /* Handle TurboQueue */
           (pSiS->oldChipset > OC_SIS6225) &&
 	   ( (pSiS->Chipset != PCI_CHIP_SIS530) ||
	     (pSiS->CurrentLayout.bitsPerPixel != 24) ) ) {
          pReg->sisRegs3C4[0x27] |= 0x80;        /* Enable TQ */
	  if((pSiS->Chipset == PCI_CHIP_SIS530) ||
	     ((pSiS->Chipset == PCI_CHIP_SIS6326 &&
	      (pSiS->ChipRev == 0xd0 || pSiS->ChipRev == 0xd1 ||
	       pSiS->ChipRev == 0xd2 || pSiS->ChipRev == 0x92 ||
	       pSiS->ChipRev == 0x0a || pSiS->ChipRev == 0x1a ||
	       pSiS->ChipRev == 0x2a || pSiS->ChipRev == 0x0b ||
	       pSiS->ChipRev == 0x1b || pSiS->ChipRev == 0x2b) ) ) ) {
	     /* pReg->sisRegs3C4[0x3D] |= 0x80;  */     /* Queue is 62K (530/620 specs) */
	     pReg->sisRegs3C4[0x3D] &= 0x7F;         /* Queue is 30K (530/620 specs) */
a574 10
	  /* Locate the TQ at the beginning of the last 64K block of
	   * video RAM. The address is to be specified in 32K steps.
	   */
	  pReg->sisRegs3C4[0x2C] = (pScrn->videoRam - 64) / 32;
	  if(pSiS->Chipset != PCI_CHIP_SIS530) {	/* 530/620: Reserved (don't touch) */
    	     pReg->sisRegs3C4[0x3C] &= 0xFC; 		/* 6326: Queue is all for 2D */
	  }						/* 5597: Must be 0           */
       } else {
	  pReg->sisRegs3C4[0x27] &= 0x7F;
       }
d577 8
a584 12

    if(!pSiS->UseVESA) {

       /* TW: No idea what this does. The Windows driver does it, so we do it as well */
       if(pSiS->Chipset == PCI_CHIP_SIS6326) {
          if((pSiS->ChipRev == 0xd0) || (pSiS->ChipRev == 0xd1) ||
             (pSiS->ChipRev == 0xd2) || (pSiS->ChipRev == 0x92) ||
	     (pSiS->Flags & A6326REVAB)) {
	     if((pSiS->Flags & (SYNCDRAM | RAMFLAG)) == (SYNCDRAM | RAMFLAG)) {
	        if(!(pReg->sisRegs3C4[0x0E] & 0x03)) {
	           pReg->sisRegs3C4[0x3E] |= 0x02;
	        }
d586 1
a586 1
          }
d588 2
d591 1
a591 1
       /* Set memclock */
d593 16
a608 16
       /* We don't need to do this; the SetMClk option was not used since 4.0. */
       if((pSiS->Chipset == PCI_CHIP_SIS5597) || (pSiS->Chipset == PCI_CHIP_SIS6326)) {
          if(pSiS->MemClock > 66000) {
             SiSCalcClock(pScrn, pSiS->MemClock, 1, vclk);

             pReg->sisRegs3C4[0x28] = (vclk[Midx] - 1) & 0x7f ;
             pReg->sisRegs3C4[0x28] |= ((vclk[VLDidx] == 2 ) ? 1 : 0 ) << 7 ;
             pReg->sisRegs3C4[0x29] = (vclk[Nidx] -1) & 0x1f ;   /* bits [4:0] contain denumerator -MC */
             if(vclk[Pidx] <= 4) {
                pReg->sisRegs3C4[0x29] |= (vclk[Pidx] - 1) << 5 ; /* postscale 1,2,3,4 */
                pReg->sisRegs3C4[0x13] &= 0x7F;
             } else {
                pReg->sisRegs3C4[0x29] |= ((vclk[Pidx] / 2) - 1) << 5 ;  /* postscale 6,8 */
                pReg->sisRegs3C4[0x13] |= 0x80;
             }
             /* Check programmed memory clock. Enable only to check the above code */
d610 9
a618 9
             mclk = 14318 * ((pReg->sisRegs3C4[0x28] & 0x7f) + 1);
             mclk /= ((pReg->sisRegs3C4[0x29] & 0x0f) + 1);
             if(!(pReg->sisRegs3C4[0x13] & 0x80)) {
                mclk /= (((pReg->sisRegs3C4[0x29] & 0x60) >> 5) + 1);
             } else {
                if((pReg->sisRegs3C4[0x29] & 0x60) == 0x40) mclk /= 6;
                if((pReg->sisRegs3C4[0x29] & 0x60) == 0x60) mclk /= 8;
             }
             xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO,2,
d622 2
a623 2
          }
       }
d626 34
a659 34
       /* Set threshold values */
       /*
        * CPU/CRT Threshold:                     FIFO
        *                           MCLK     ___________      VCLK
        * cpu/engine <---o       o--------->|___________| -----------> CRT
        *                ^       ^            ^       ^
        *                 \     /             |       |
        *                  \   /              |< gap >|
        *                   \ /               |       |
        *           selector switch   Thrsh. low     high
        *
        * CRT consumes the data in the FIFO during scanline display. When the
        * amount of data in the FIFO reaches the Threshold low value, the selector
        * switch will switch to the right, and the FIFO will be refilled with data.
        * When the amount of data in the FIFO reaches the Threshold high value, the
        * selector switch will switch to the left and allows the CPU and the chip
        * engines to access the video RAM.
        *
        * The Threshold low values should be increased at higher bpps, simply because
        * there is more data needed for the CRT. When Threshold low and high are very
        * close to each other, the selector switch will be activated more often, which
        * decreases performance.
        *
        */
       switch(pSiS->Chipset) {
       case PCI_CHIP_SIS5597:  factor = 65; break;
       case PCI_CHIP_SIS6326:  factor = 30; break;
       case PCI_CHIP_SIS530:   factor = (pSiS->Flags & UMA) ? 60 : 30; break;
       default:                factor = (pScrn->videoRam > 1024) ? 24 : 12;
       }
       a = width * height * rate * 1.40 * factor * ((pSiS->CurrentLayout.bitsPerPixel + 1) / 8);
       b = (mclk / 1000) * 999488.0 * (buswidth / 8);
       c = ((a / b) + 1.0) / 2;
       d = (int)c + 2;
d662 6
a667 6
       xf86DrvMsg(0, X_INFO,
          "Debug: w %d h %d r %d mclk %d bus %d factor %d bpp %d\n",
          width, height, rate, mclk/1000, buswidth, factor,
          pSiS->CurrentLayout.bitsPerPixel);
       xf86DrvMsg(0, X_INFO, "Debug: a %f b %f c %f d %d (flags %x)\n",
     	  a, b, c, d, pSiS->Flags);
d670 5
a674 5
       CRT_CPUthresholdLow = d;
       if((pSiS->Flags & (RAMFLAG | SYNCDRAM)) == (RAMFLAG | SYNCDRAM)) {
          CRT_CPUthresholdLow += 2;
       }
       CRT_CPUthresholdHigh = CRT_CPUthresholdLow + 3;
d676 1
a676 1
       CRT_ENGthreshold = 0x0F;
d679 2
a680 2
       xf86DrvMsg(0, X_INFO, "Debug: Thlow %d thhigh %d\n",
     	  CRT_CPUthresholdLow, CRT_CPUthresholdHigh);
d683 11
a693 12
#if 0  /* See comment in sis_dac.c on why this is commented */
       if(pSiS->Chipset == PCI_CHIP_SIS530) {
          if((pSiS->oldChipset == OC_SIS530A) &&
	     (pSiS->Flags & UMA) &&
	     (mclk == 100000) &&
	     (pSiS->Flags & ESS137xPRESENT)) {
	       if(!(pSiS->Flags & SECRETFLAG)) index = 0;
               if((temp = SiS_CalcSpecial530Threshold(pSiS, mode, index)) {
	    	   CRT_CPUthresholdLow = temp;
	           break;
	       }
          }
d695 1
d698 65
a762 84
       switch(pSiS->Chipset) {
       case PCI_CHIP_SIS530:
          if(CRT_CPUthresholdLow > 0x1f)  CRT_CPUthresholdLow = 0x1f;
          CRT_CPUthresholdHigh = 0x1f;
          break;
       case PCI_CHIP_SIS5597:
       case PCI_CHIP_SIS6326:
       default:
          if(CRT_CPUthresholdLow > 0x0f)  CRT_CPUthresholdLow  = 0x0f;
          if(CRT_CPUthresholdHigh > 0x0f) CRT_CPUthresholdHigh = 0x0f;
       }

       pReg->sisRegs3C4[0x08] = ((CRT_CPUthresholdLow & 0x0F) << 4) |
	  		        (CRT_ENGthreshold & 0x0F);

       pReg->sisRegs3C4[0x09] &= 0xF0;
       pReg->sisRegs3C4[0x09] |= (CRT_CPUthresholdHigh & 0x0F);

       pReg->sisRegs3C4[0x3F] &= 0xEB;
       pReg->sisRegs3C4[0x3F] |= (CRT_CPUthresholdHigh & 0x10) |
                         	      ((CRT_CPUthresholdLow & 0x10) >> 2);

       if(pSiS->oldChipset >= OC_SIS530A) {
     	  pReg->sisRegs3C4[0x3F] &= 0xDF;
	  pReg->sisRegs3C4[0x3F] |= 0x58;
       }

       /* Set SiS6326 TV registers */
       if((pSiS->Chipset == PCI_CHIP_SIS6326) && (sis6326tvmode)) {
          unsigned char tmp;
          int index=0, i, j, k;
          int fsc;

          if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
             pReg->sisRegs3C4[0x0D] |= 0x04;
             switch(width) {
	     case 800:
	        if((strcmp(mode->name, "PAL800x600U") == 0))  index = 4;
	        else	        			      index = 3;
	        break;
	     case 720: index = 5;  break;
	     case 640:
	     default:  index = 2;
	     }
	     for(i=0; i<14; i++) {
	        pReg->sis6326tv[SiS6326TVRegs1[i]] = SiS6326TVRegs1_PAL[index][i];
	     }
#ifdef TV6326TEST
             for(i=0, j=2; i<3; i++, j++) {
	        pReg->sis6326tv[j] = SiS6326TVRegs1_PAL_2[index][i];
	     }
#endif
             fsc = (SiS6326TVRegs1_PAL[index][2] << 16) |
	           (SiS6326TVRegs1_PAL[index][3] << 8)  |
	           (SiS6326TVRegs1_PAL[index][4]);
          } else {
	     pReg->sisRegs3C4[0x0D] &= ~0x04;
	     if((strcmp(mode->name, "NTSC640x480U") == 0))  index = 5;
	     else 					    index = 4;
             for(i=0; i<14; i++) {
	        pReg->sis6326tv[SiS6326TVRegs1[i]] = SiS6326TVRegs1_NTSC[index][i];
	     }
#ifdef TV6326TEST
             for(i=0, j=2; i<3; i++, j++) {
	        pReg->sis6326tv[j] = SiS6326TVRegs1_NTSC_2[index][i];
	     }
#endif
             fsc = (SiS6326TVRegs1_NTSC[index][2] << 16) |
	           (SiS6326TVRegs1_NTSC[index][3] << 8)  |
	           (SiS6326TVRegs1_NTSC[index][4]);
          }
          if(pSiS->sis6326fscadjust) {
	     fsc += pSiS->sis6326fscadjust;
	     pReg->sis6326tv[2] = (fsc >> 16) & 0xff;
	     pReg->sis6326tv[3] = (fsc >> 8) & 0xff;
	     pReg->sis6326tv[4] = fsc & 0xff;
          }
          tmp = pReg->sis6326tv[0x43];
          if(pSiS->SiS6326Flags & SIS6326_TVCVBS) tmp |= 0x10;
          tmp |= 0x08;
          pReg->sis6326tv[0x43] = tmp;
          j = 0; k = 0;
          for(i=0; i<=0x44; i++) {
	     if(SiS6326TVRegs1[j] == i) {
d765 2
a766 2
	     }
	     if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
d768 1
a768 1
	     } else {
d770 16
a785 18
	     }
	     pReg->sis6326tv[i] = tmp;
	     k++;
          }
          pReg->sis6326tv[0x43] |= 0x08;
          if((pSiS->ChipRev == 0xc1) || (pSiS->ChipRev == 0xc2)) {
             pReg->sis6326tv[0x43] &= ~0x08;
          }

          tmp = pReg->sis6326tv[0];
          tmp |= 0x18;
          if(pSiS->SiS6326Flags & SIS6326_TVCVBS)   tmp &= ~0x10;
          if(pSiS->SiS6326Flags & SIS6326_TVSVIDEO) tmp &= ~0x08;
          tmp |= 0x04;
          pReg->sis6326tv[0] = tmp;
       }

    } /* VESA */
d790 8
a797 3
/* Init a mode for SiS 300, 315 and 330 series
 * This function is now only used for setting up some
 * variables (eg. scrnOffset).
a804 1
    DisplayModePtr realmode = mode;
d806 1
a806 1
    PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4, "SIS300Init()\n"));
a812 6
#ifdef SISMERGED
    if(pSiS->MergedFB) {
       realmode = ((SiSMergedDisplayModePtr)mode->Private)->CRT1;
    }
#endif

d816 1
a816 1
    /* Calculate Offset/Display Pitch */
d818 3
a820 7
                          ((pSiS->CurrentLayout.bitsPerPixel + 7) / 8);

    pSiS->scrnPitch = pSiS->scrnPitch2 = pSiS->scrnOffset;
    if(!(pSiS->VBFlags & CRT1_LCDA)) {
       if(realmode->Flags & V_INTERLACE) pSiS->scrnPitch <<= 1;
    }
    /* CRT2 mode can never be interlaced */
d846 1
a846 1
    /* Enable PCI LINEAR ADDRESSING (0x80), MMIO (0x01), PCI_IO (0x20) */
d849 8
a856 8
    /* Now initialize TurboQueue. TB is always located at the very top of
     * the videoRAM (notably NOT the x framebuffer memory, which can/should
     * be limited by MaxXFbMem when using DRI). Also, enable the accelerators.
     */
    if(!pSiS->NoAccel) {
        pReg->sisRegs3C4[0x1E] |= 0x42;  /* Enable 2D accelerator */
	pReg->sisRegs3C4[0x1E] |= 0x18;  /* Enable 3D accelerator */
	switch(pSiS->VGAEngine) {
d858 2
a859 2
	  if(pSiS->TurboQueue) {    		/* set Turbo Queue as 512k */
	    temp = ((pScrn->videoRam/64)-8);    /* 8=512k, 4=256k, 2=128k, 1=64k */
d863 1
a863 1
          }	/* line above new for saving D2&3 of status register */
a865 1
#ifndef SISVRAMQ
a869 1
#endif
d877 1
a877 1
static int
d886 1
a886 1
    SiS_DDC2Delay(pSiS->SiS_Pr, 0x1500);
d891 1
a891 1
    return((temp == tempch));
d894 2
a895 3
/* Sense connected devices on 30x */
static void
SISSense30x(ScrnInfoPtr pScrn)
d898 8
a905 8
    unsigned char backupP4_0d,backupP2_00,biosflag=0;
    unsigned char svhs_bl=0, svhs_bh=0;
    unsigned char cvbs_bl=0, cvbs_bh=0;
    unsigned char vga2_bl=0, vga2_bh=0;
    unsigned char svhs_cl, svhs_ch;
    unsigned char cvbs_cl, cvbs_ch;
    unsigned char vga2_cl, vga2_ch;
    int myflag, result=0, i, j;
d909 14
a922 2
    if(!(pSiS->VBFlags & (VB_301C | VB_302ELV))) {
       outSISIDXREG(SISPART4,0x0d,(backupP4_0d | 0x04));
a924 5
    inSISIDXREG(SISPART2,0x00,backupP2_00);
    outSISIDXREG(SISPART2,0x00,(backupP2_00 | 0x1c));

    SISDoSense(pScrn, 0, 0, 0, 0);

d928 3
a930 3
	   vga2_bh = pSiS->BIOS[0xf9]; vga2_bl = pSiS->BIOS[0xf8];
	   svhs_bh = pSiS->BIOS[0xfb]; svhs_bl = pSiS->BIOS[0xfa];
	   cvbs_bh = pSiS->BIOS[0xfd]; cvbs_bl = pSiS->BIOS[0xfc];
d933 4
a936 4
	   vga2_bh = 0x00; vga2_bl = 0xd1;
           svhs_bh = 0x00; svhs_bl = 0xb9;
	   cvbs_bh = 0x00; cvbs_bl = 0xb3;
	   biosflag = 2;
d938 4
a941 16

	if(pSiS->VBFlags & (VB_301B|VB_302B|VB_301LV|VB_302LV)) {
	   vga2_bh = 0x01; vga2_bl = 0x90;
	   svhs_bh = 0x01; svhs_bl = 0x6b;
	   cvbs_bh = 0x01; cvbs_bl = 0x74;
	} else if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
	   vga2_bh = 0x01; vga2_bl = 0x90;
	   svhs_bh = 0x01; svhs_bl = 0x6b;
	   cvbs_bh = 0x01; cvbs_bl = 0x10;
	} else {
	   inSISIDXREG(SISPART4,0x01,myflag);
	   if(myflag & 0x04) {
	      vga2_bh = 0x00; vga2_bl = 0xfd;
	      svhs_bh = 0x00; svhs_bl = 0xdd;
	      cvbs_bh = 0x00; cvbs_bl = 0xee;
	   }
d943 5
a947 18

	vga2_ch = 0x0e;	vga2_cl = 0x08;
	svhs_ch = 0x04;	svhs_cl = 0x04;
	cvbs_ch = 0x08; cvbs_cl = 0x04;

	if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	   vga2_bh = 0x00; vga2_bl = 0x00;
	   vga2_ch = 0x00; vga2_cl = 0x00;
	   svhs_ch = 0x04; svhs_cl = 0x08;
	   cvbs_ch = 0x08; cvbs_cl = 0x08;
	}

	if(pSiS->Chipset == PCI_CHIP_SIS300) {
	   inSISIDXREG(SISSR,0x3b,myflag);
	   if(!(myflag & 0x01)) {
	      vga2_bh = 0x00; vga2_bl = 0x00;
	      vga2_ch = 0x00; vga2_cl = 0x00;
	   }
d949 13
a961 15

    } else if(pSiS->Chipset == PCI_CHIP_SIS660) {

        if(pSiS->sishw_ext.UseROM) {
	   biosflag = pSiS->BIOS[0x58];
	   temp = pSiS->BIOS[0x254] | (pSiS->BIOS[0x255] << 8);
	   if(pSiS->VBFlags & VB_301)         temp +=  6;
	   else if(pSiS->VBFlags & VB_301B)   temp += 12;
	   else if(pSiS->VBFlags & VB_301C)   temp += 18;
	   else if(pSiS->VBFlags & VB_301LV)  temp += 12;
	   else if(pSiS->VBFlags & VB_302LV)  temp += 12;
	   else if(pSiS->VBFlags & VB_302ELV) temp += 18;
	   vga2_bh = pSiS->BIOS[temp+1]; vga2_bl = pSiS->BIOS[temp];
	   svhs_bh = pSiS->BIOS[temp+3]; svhs_bl = pSiS->BIOS[temp+2];
	   cvbs_bh = pSiS->BIOS[temp+5]; cvbs_bl = pSiS->BIOS[temp+4];
d963 10
a972 9
	   biosflag = 2;
	   if(pSiS->VBFlags & (VB_301B | VB_301LV | VB_302LV)) {
	      vga2_bh = 0x01; vga2_bl = 0x90;
	      svhs_bh = 0x01; svhs_bl = 0x6b; /* Are these really correct for LV? */
	      cvbs_bh = 0x01; cvbs_bl = 0x74;
	   } else if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
	      vga2_bh = 0x01; vga2_bl = 0x90;
	      svhs_bh = 0x01; svhs_bl = 0x6b;
	      cvbs_bh = 0x01; cvbs_bl = 0x10;
d974 3
a976 3
	      vga2_bh = 0x00; vga2_bl = 0xfd;
	      svhs_bh = 0x00; svhs_bl = 0xdd;
	      cvbs_bh = 0x00; cvbs_bl = 0xee;
d979 22
a1000 10

	vga2_ch = 0x0e;	vga2_cl = 0x08;
	svhs_ch = 0x04;	svhs_cl = 0x04;
	cvbs_ch = 0x08; cvbs_cl = 0x04;

	if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	   vga2_bh = 0x00; vga2_bl = 0x00;
	   vga2_ch = 0x00; vga2_cl = 0x00;
	   svhs_ch = 0x04; svhs_cl = 0x08;
	   cvbs_ch = 0x08; cvbs_cl = 0x08;
d1002 1
a1002 5

    } else {

	if(pSiS->VBFlags & VB_301) {

d1004 3
a1006 11
	      if(pSiS->Chipset == PCI_CHIP_SIS330) {
	         vga2_bh = pSiS->BIOS[0xe6]; vga2_bl = pSiS->BIOS[0xe5];
	         svhs_bh = pSiS->BIOS[0xe8]; svhs_bl = pSiS->BIOS[0xe7];
	         cvbs_bh = pSiS->BIOS[0xea]; cvbs_bl = pSiS->BIOS[0xe9];
	         biosflag = pSiS->BIOS[0x11b];
	      } else {
	         vga2_bh = pSiS->BIOS[0xbe]; vga2_bl = pSiS->BIOS[0xbd];
	         svhs_bh = pSiS->BIOS[0xc0]; svhs_bl = pSiS->BIOS[0xbf];
	         cvbs_bh = pSiS->BIOS[0xc2]; cvbs_bl = pSiS->BIOS[0xc1];
	         biosflag = pSiS->BIOS[0xf3];
	      }
d1008 3
a1010 10
	      vga2_bh = 0x00; vga2_bl = 0xd1;
              svhs_bh = 0x00; svhs_bl = 0xb9;
	      cvbs_bh = 0x00; cvbs_bl = 0xb3;
	      biosflag = 2;
	   }
	   inSISIDXREG(SISPART4,0x01,myflag);
	   if(myflag & 0x04) {
	      vga2_bh = 0x00; vga2_bl = 0xfd;
	      svhs_bh = 0x00; svhs_bl = 0xdd;
	      cvbs_bh = 0x00; cvbs_bl = 0xee;
d1012 10
d1023 1
a1023 1
	} else if(pSiS->VBFlags & (VB_301B|VB_302B|VB_301LV|VB_302LV)) {
d1025 26
a1050 10
	   if(pSiS->sishw_ext.UseROM) {
	      if(pSiS->Chipset == PCI_CHIP_SIS330) {
	         vga2_bh = pSiS->BIOS[0xec]; vga2_bl = pSiS->BIOS[0xeb];
	         svhs_bh = pSiS->BIOS[0xee]; svhs_bl = pSiS->BIOS[0xed];
	         cvbs_bh = pSiS->BIOS[0xf0]; cvbs_bl = pSiS->BIOS[0xef];
	      } else {
	         vga2_bh = pSiS->BIOS[0xc4]; vga2_bl = pSiS->BIOS[0xc3];
	         svhs_bh = pSiS->BIOS[0xc6]; svhs_bl = pSiS->BIOS[0xc5];
	         cvbs_bh = pSiS->BIOS[0xc8]; cvbs_bl = pSiS->BIOS[0xc7];
	      }
d1052 4
a1055 9
	      if(pSiS->VBFlags & (VB_301B|VB_302B)) {
	         vga2_bh = 0x01; vga2_bl = 0x90;
	         svhs_bh = 0x01; svhs_bl = 0x6b;
	         cvbs_bh = 0x01; cvbs_bl = 0x74;
	      } else {
		 vga2_bh = 0x00; vga2_bl = 0x00;
	         svhs_bh = 0x02; svhs_bl = 0x00;
	         cvbs_bh = 0x01; cvbs_bl = 0x00;
	      }
d1057 4
d1062 1
a1062 1
	} else if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
d1064 5
a1068 3
	   vga2_bh = 0x01; vga2_bl = 0x90;
	   svhs_bh = 0x01; svhs_bl = 0x6b;
	   cvbs_bh = 0x01; cvbs_bl = 0x10;
d1070 1
a1070 20
	}
	
	if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	   /* No VGA2 or SCART on LV bridges */
	   vga2_bh = 0x00; vga2_bl = 0x00;
	   vga2_ch = 0x00; vga2_cl = 0x00;
	   svhs_ch = 0x04; svhs_cl = 0x08;
	   cvbs_ch = 0x08; cvbs_cl = 0x08;
	} else {
	   vga2_ch = 0x0e; vga2_cl = 0x08;
	   svhs_ch = 0x04; svhs_cl = 0x04;
	   cvbs_ch = 0x08; cvbs_cl = 0x04;
	}

    } 

    andSISIDXREG(SISCR, 0x32, ~0x14);
    pSiS->postVBCR32 &= ~0x14;
    
    if(vga2_ch || vga2_cl || vga2_bh || vga2_bl) {
d1074 1
a1074 1
    		vga2_bh, vga2_bl, vga2_ch, vga2_cl);
d1077 2
a1078 8
       for(j = 0; j < 10; j++) {
          result = 0;
          for(i = 0; i < 3; i++) {
             if(SISDoSense(pScrn, vga2_bl, vga2_bh, vga2_cl, vga2_ch))
	        result++;
          }
	  if((result == 0) || (result >= 2)) break;
       }
d1086 1
a1086 1
	   } else {
a1093 32
       if(biosflag & 0x01) pSiS->SiS_SD_Flags |= SiS_SD_VBHASSCART;
    }

    if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
       orSISIDXREG(SISPART4,0x0d,0x04);
    }

    andSISIDXREG(SISCR, 0x32, 0x3f);
    pSiS->postVBCR32 &= 0x3f;

    if((pSiS->VGAEngine == SIS_315_VGA) && (pSiS->VBFlags & (VB_301C|VB_301LV|VB_302LV|VB_302ELV))) {
       outSISIDXREG(SISPART4,0x11,svhs_bl);
       setSISIDXREG(SISPART4,0x10,0xE0,(svhs_bh|0x04));
       SiS_DDC2Delay(pSiS->SiS_Pr, 0x1000);
       inSISIDXREG(SISPART4,0x03,temp);
       temp ^= 0x0E;
       temp &= 0x06;
       if(temp == 0x06) {
          outSISIDXREG(SISPART4,0x11,cvbs_bl);
	  setSISIDXREG(SISPART4,0x10,0xE0,(cvbs_bh|0x04));
	  SiS_DDC2Delay(pSiS->SiS_Pr, 0x1000);
	  inSISIDXREG(SISPART4,0x03,temp);
          temp ^= 0x0E;
	  temp &= 0x08;
	  if(temp) {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
     		"SiS30x: Detected TV connected to YPBPR output\n");
	     orSISIDXREG(SISCR,0x32,0x80);
	     pSiS->VBFlags |= TV_YPBPR;
	     pSiS->postVBCR32 |= 0x80;
	  }
       }
d1099 2
a1100 2
    		svhs_bh, svhs_bl, svhs_ch, svhs_cl,
		cvbs_bh, cvbs_bl, cvbs_ch, cvbs_cl);
d1103 10
a1112 39
    andSISIDXREG(SISCR, 0x32, ~0x03);
    pSiS->postVBCR32 &= ~0x03;

    if(!(pSiS->VBFlags & TV_YPBPR)) {

       for(j = 0; j < 10; j++) {
          result = 0;
          for(i = 0; i < 3; i++) {
             if(SISDoSense(pScrn, svhs_bl, svhs_bh, svhs_cl, svhs_ch))
	        result++;
          }
          if((result == 0) || (result >= 2)) break;
       }
       if(result) {
          xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
     		"SiS30x: Detected TV connected to SVIDEO output\n");
          pSiS->VBFlags |= TV_SVIDEO;
          orSISIDXREG(SISCR, 0x32, 0x02);
          pSiS->postVBCR32 |= 0x02;
       }

       if((biosflag & 0x02) || (!(result))) {

          for(j = 0; j < 10; j++) {
             result = 0;
             for(i = 0; i < 3; i++) {
                if(SISDoSense(pScrn, cvbs_bl, cvbs_bh, cvbs_cl, cvbs_ch))
	           result++;
             }
             if((result == 0) || (result >= 2)) break;
          }
          if(result) {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	             "SiS30x: Detected TV connected to COMPOSITE output\n");
	     pSiS->VBFlags |= TV_AVIDEO;
	     orSISIDXREG(SISCR, 0x32, 0x01);
	     pSiS->postVBCR32 |= 0x01;
          }
       }
d1114 12
a1126 1

a1128 1
    outSISIDXREG(SISPART2,0x00,backupP2_00);
a1141 1
    (void)temp;
d1144 1
a1144 1
static int
d1164 1
a1164 1
static void
d1186 2
a1187 5
		(((pSiS->SiS6326Flags & (SIS6326_TVSVIDEO | SIS6326_TVCVBS)) ==
		   (SIS6326_TVSVIDEO | SIS6326_TVCVBS)) ?
		   	"both SVIDEO and COMPOSITE" :
		      	   ((pSiS->SiS6326Flags & SIS6326_TVSVIDEO) ?
			     	"SVIDEO" : "COMPOSITE")));
d1194 1
a1194 1
/* Detect video bridge and set VBFlags accordingly */
d1198 1
a1198 1
    int     temp,temp1,temp2, i;
d1201 1
a1201 6
    int     chronteltype, chrontelidreg, upperlimitvb;
    unsigned char test[3];
    static const char *detectvb = "Detected %s video bridge (ID %d; Revision 0x%x)\n";
#if 0
    unsigned char sr17=0;
#endif
a1223 1
	case PCI_CHIP_SIS660:
a1239 2
    pSiS->SiS_Pr->SiS_UseLCDA = FALSE;
    pSiS->SiS_Pr->Backup = FALSE;
d1241 1
a1241 1
    /* Videobridges only available for 300/315 series */
d1244 1
a1244 1
	
d1247 1
a1247 1
    if(temp == 1) {
d1250 8
a1257 13
        if(temp1 >= 0xE0) {
	        inSISIDXREG(SISPART4, 0x39, temp2);
		if(temp2 == 0xff) {
	   	   pSiS->VBFlags |= VB_302LV;
		   pSiS->sishw_ext.ujVBChipID = VB_CHIP_302LV;
    		   xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS302LV", 1, temp1);
		} else {
		   pSiS->VBFlags |= VB_302ELV;
		   pSiS->sishw_ext.ujVBChipID = VB_CHIP_302ELV;
    		   xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS302ELV", 1, temp1);
		}
	} else if(temp1 >= 0xD0) {
	   	pSiS->VBFlags |= VB_301LV;
d1259 4
a1262 6
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS301LV", 1, temp1);
	} else if(temp1 >= 0xC0) {
	   	pSiS->VBFlags |= VB_301C;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301C;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS301C", 1, temp1);
	} else if(temp1 >= 0xB0) {
d1265 3
a1267 4
		inSISIDXREG(SISPART4, 0x23, temp2);
		if(!(temp2 & 0x02)) pSiS->VBFlags |= VB_30xBDH;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb,
				(temp2 & 0x02) ? "SiS301B" : "SiS301B-DH", 1, temp1);
d1271 10
a1280 1
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS301", 1, temp1);
d1283 1
a1283 1
	SISSense30x(pScrn); 
d1289 8
a1296 2
	if(temp1 >= 0xE0) {
        	pSiS->VBFlags |= VB_302LV;
d1298 3
a1300 5
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS302LV", 2, temp1);
	} else if(temp1 >= 0xD0) {
        	pSiS->VBFlags |= VB_301LV;
		pSiS->sishw_ext.ujVBChipID = VB_CHIP_301LV;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "SiS301LV", 2, temp1);
d1304 10
a1313 4
		inSISIDXREG(SISPART4, 0x23, temp2);
		if(!(temp & 0x02)) pSiS->VBFlags |= VB_30xBDH;
    		xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb,
				(temp2 & 0x02) ? "SiS302B" : "SiS302B-DH", 2, temp1);
d1320 4
a1323 1
    	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, detectvb, "unsupported SiS303", temp, 0);
d1328 7
a1334 6
	if(pSiS->Chipset == PCI_CHIP_SIS660) {
	   inSISIDXREG(SISCR, 0x38, temp);
           temp = (temp >> 5) & 0x07;
	} else {
	   inSISIDXREG(SISCR, 0x37, temp);
           temp = (temp >> 1) & 0x07;
d1336 1
a1340 1
	   upperlimitvb = upperlimitlvds;
a1344 4
	   upperlimitvb = upperlimitlvds;
	   if(pSiS->Chipset == PCI_CHIP_SIS660) {
	      upperlimitvb = 4;
	   }
d1350 16
a1365 1
	               "Detected LVDS transmitter (External chip ID %d)\n", temp);
d1368 1
a1368 1
	    /* Set global for init301.c */
d1372 2
a1373 2
	       /* Set general purpose IO for Chrontel communication */
	       SiS_SetChrontelGPIO(pSiS->SiS_Pr, 0x9c);
d1376 1
a1376 1
	    /* Read Chrontel version number */
d1379 1
a1379 1
	        /* See Chrontel TB31 for explanation */
d1381 1
a1381 1
		if(((temp2 & 0x07) == 0x01) || (temp2 & 0x04)) {
a1390 2
		andSISIDXREG(SISCR, 0x32, ~0x07);
		pSiS->postVBCR32 &= ~0x07;
d1407 1
a1407 1
	               "Detected Chrontel %s TV encoder (ID 0x%02x; chip ID %d)\n",
d1410 1
a1410 1
		/* Sense connected TV's */
d1416 1
a1416 1
	    	   /* Read power status */
d1423 9
a1431 21
		   /* Sense connected TV devices */
		   for(i = 0; i < 3; i++) {
	    	      SiS_SetCH700x(pSiS->SiS_Pr, 0x0110);
		      SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);
	    	      SiS_SetCH700x(pSiS->SiS_Pr, 0x0010);
		      SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);
	    	      temp1 = SiS_GetCH700x(pSiS->SiS_Pr, 0x10);
		      if(!(temp1 & 0x08))       test[i] = 0x02;
		      else if(!(temp1 & 0x02))  test[i] = 0x01;
		      else                      test[i] = 0;
		      SiS_DDC2Delay(pSiS->SiS_Pr, 0x96);
		   }

		   if(test[0] == test[1])      temp1 = test[0];
		   else if(test[0] == test[2]) temp1 = test[0];
		   else if(test[1] == test[2]) temp1 = test[1];
		   else {
		   	xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
				"TV detection unreliable - test results varied\n");
			temp1 = test[2];
		   }
d1437 1
a1437 1
		   /* Backup Power register */
d1440 1
a1440 1
		   /* Enable TV path */
d1445 1
a1445 1
		   /* Sense connected TV devices */
d1459 1
a1459 1
		   /* Restore Power register */
d1475 1
a1477 1
			andSISIDXREG(SISCR, 0x32, ~0x06);
a1478 1
			pSiS->postVBCR32 &= ~0x06;
d1483 1
a1485 1
			andSISIDXREG(SISCR, 0x32, ~0x05);
a1486 1
			pSiS->postVBCR32 &= ~0x05;
d1490 1
a1490 1
			   "Chrontel: Detected TV connected to SCART or YPBPR output\n");
d1493 1
a1493 1
			      "Chrontel: Use CHTVType option to select either SCART or YPBPR525I\n");
d1501 1
a1501 1
			    pSiS->VBFlags |= TV_CHYPBPR525I;
a1505 2
			andSISIDXREG(SISCR, 0x32, ~0x07);
			pSiS->postVBCR32 &= ~0x07;
d1509 2
a1510 2
	        /* This indicates a communication problem, but it only occures if there
		 * is no TV attached. So we don't use TV in this case.
a1513 2
		andSISIDXREG(SISCR, 0x32, ~0x07);
		pSiS->postVBCR32 &= ~0x07;
a1516 2
		andSISIDXREG(SISCR, 0x32, ~0x07);
		pSiS->postVBCR32 &= ~0x07;
d1519 2
a1520 2
	       /* Set general purpose IO for Chrontel communication */
	       SiS_SetChrontelGPIO(pSiS->SiS_Pr, 0x00);
d1523 2
a1524 6
	if((pSiS->Chipset == PCI_CHIP_SIS660) && (temp == 4)) {
	   pSiS->VBFlags |= VB_CONEXANT;
	   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	               "Detected Conexant video bridge - UNSUPPORTED\n");
	}
	if((pSiS->VGAEngine == SIS_300_VGA) && (temp == 3)) {
d1526 1
a1526 1
	               "Detected Trumpion Zurac (I/II/III) LVDS scaler - UNSUPPORTED\n");
d1528 1
a1528 1
	if(temp > upperlimitvb) {
a1531 106
    }

   /* Old BIOSes store the detected CRT2 type in SR17, 16 and 13
    * instead of CR32. However, since our detection routines
    * store their results to CR32, we now copy the
    * remaining bits (for LCD and VGA) to CR32 for unified usage.
    * SR17[0] CRT1     [1] LCD       [2] TV    [3] VGA2
    *     [4] AVIDEO   [5] SVIDEO
    * SR13[0] SCART    [1] HiVision
    * SR16[5] PAL/NTSC [6] LCD-SCALE [7] OVERSCAN
    */

#if 0
    inSISIDXREG(SISSR, 0x17, sr17);
    if( (pSiS->VGAEngine == SIS_300_VGA) &&
        (pSiS->Chipset != PCI_CHIP_SIS300) &&
        (sr17 & 0x0F) ) {
	
	unsigned char cr32;
	inSISIDXREG(SISCR, 0x32, cr32);
	
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		"Converting SR17 (%02x) to CR32 (%02x)\n", sr17, cr32);
	 
	 if(sr17 & 0x01) {  	/* CRT1 */
	 	orSISIDXREG(SISCR, 0x32, 0x20);
		pSiS->postVBCR32 |= 0x20;
	 } else {
	 	andSISIDXREG(SISCR, 0x32, ~0x20);
		pSiS->postVBCR32 &= ~0x20;
	 }
		
	 if(sr17 & 0x02) {	/* LCD */
	 	orSISIDXREG(SISCR, 0x32, 0x08);
		pSiS->postVBCR32 |= 0x08;
	 } else	{	  
	 	andSISIDXREG(SISCR, 0x32, ~0x08);
		pSiS->postVBCR32 &= ~0x08;
	 }
	 
	 /* No Hivision, no DVI here */
	 andSISIDXREG(SISCR,0x32,~0xc0);
	 pSiS->postVBCR32 &= ~0xc0;
    }  
#endif

    /* Try to find out if the bridge uses LCDA for low resolution and
     * text modes. If sisfb saved this for us, use it. Otherwise,
     * check if we are running on a low mode on LCD and read the 
     * relevant registers ourselves.
     */
    if(pSiS->VGAEngine == SIS_315_VGA) {

       if(pSiS->VBFlags & (VB_301C | VB_302B | VB_301LV | VB_302LV | VB_302ELV)) {
          if(pSiS->sisfblcda != 0xff) {
	     if((pSiS->sisfblcda & 0x03) == 0x03) {
	        pSiS->SiS_Pr->SiS_UseLCDA = TRUE;
	        pSiS->ChipFlags |= SiSCF_UseLCDA;
	     }
	  } else {
             inSISIDXREG(SISCR,0x34,temp);
	     if(temp <= 0x13) {
	        inSISIDXREG(SISCR,0x38,temp);
	        if((temp & 0x03) == 0x03) {
	           pSiS->SiS_Pr->SiS_UseLCDA = TRUE;
	           pSiS->ChipFlags |= SiSCF_UseLCDA;
		   pSiS->SiS_Pr->Backup = TRUE;
	        } else {
		   inSISIDXREG(SISCR,0x35,temp);
		   if(temp & 0x01) {
		      pSiS->SiS_Pr->SiS_UseLCDA = TRUE;
	              pSiS->ChipFlags |= SiSCF_UseLCDA;
		      pSiS->SiS_Pr->Backup = TRUE;
		   } else {
	              inSISIDXREG(SISCR,0x30,temp);
	 	      if(temp & 0x20) {
		         orSISIDXREG(SISPART1,0x2f,0x01);  /* Unlock CRT2 */
		         inSISIDXREG(SISPART1,0x13,temp);
		         if(temp & 0x04) {
		            pSiS->SiS_Pr->SiS_UseLCDA = TRUE;
	                    pSiS->ChipFlags |= SiSCF_UseLCDA;
			    pSiS->SiS_Pr->Backup = TRUE;
		         }
		      } 
		   }
	        }
	     }
	  }
	  if(pSiS->ChipFlags & SiSCF_UseLCDA) {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		"BIOS uses LCDA for low resolution and text modes\n");
	     if(pSiS->SiS_Pr->Backup == TRUE) {
	        inSISIDXREG(SISCR,0x34,pSiS->SiS_Pr->Backup_Mode);
                inSISIDXREG(SISPART1,0x14,pSiS->SiS_Pr->Backup_14);
	        inSISIDXREG(SISPART1,0x15,pSiS->SiS_Pr->Backup_15);
	        inSISIDXREG(SISPART1,0x16,pSiS->SiS_Pr->Backup_16);
	        inSISIDXREG(SISPART1,0x17,pSiS->SiS_Pr->Backup_17);
	        inSISIDXREG(SISPART1,0x18,pSiS->SiS_Pr->Backup_18);
	        inSISIDXREG(SISPART1,0x19,pSiS->SiS_Pr->Backup_19);
	        inSISIDXREG(SISPART1,0x1a,pSiS->SiS_Pr->Backup_1a);
	        inSISIDXREG(SISPART1,0x1b,pSiS->SiS_Pr->Backup_1b);
	        inSISIDXREG(SISPART1,0x1c,pSiS->SiS_Pr->Backup_1c);
	        inSISIDXREG(SISPART1,0x1d,pSiS->SiS_Pr->Backup_1d);
	     }
	  }
       }
@


1.1.1.4
log
@Import OpenBSD X-Window subsystem (based upon XFree86 4.4RC2)
into vendor branch
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_vga.c,v 1.46 2004/02/26 15:07:02 twini Exp $ */
d15 4
a18 1
 * 3) The name of the author may not be used to endorse or promote products
d50 4
d56 2
a57 1
static int   SISDoSense(ScrnInfoPtr pScrn, unsigned short type, unsigned short test);
d76 11
d129 11
d173 1
d816 5
d831 5
d978 1
a978 1
SISDoSense(ScrnInfoPtr pScrn, unsigned short type, unsigned short test)
d980 2
a981 6
    SISPtr pSiS = SISPTR(pScrn);
    int    temp, mytest, result, i, j;

#ifdef TWDEBUG
    xf86DrvMsg(0, X_INFO, "Sense: %x %x\n", type, test);
#endif
d983 9
a991 23
    for(j = 0; j < 10; j++) {
       result = 0;
       for(i = 0; i < 3; i++) {
          mytest = test;
          outSISIDXREG(SISPART4,0x11,(type & 0x00ff));
          temp = (type >> 8) | (mytest & 0x00ff);
          setSISIDXREG(SISPART4,0x10,0xe0,temp);
          SiS_DDC2Delay(pSiS->SiS_Pr, 0x1500);
          mytest >>= 8;
          mytest &= 0x7f;
          inSISIDXREG(SISPART4,0x03,temp);
          temp ^= 0x0e;
          temp &= mytest;
          if(temp == mytest) result++;
#if 1
	  outSISIDXREG(SISPART4,0x11,0x00);
	  andSISIDXREG(SISPART4,0x10,0xe0);
	  SiS_DDC2Delay(pSiS->SiS_Pr, 0x1000);
#endif
       }
       if((result == 0) || (result >= 2)) break;
    }
    return(result);
a993 2
#define GETROMWORD(w) (pSiS->BIOS[w] | (pSiS->BIOS[w+1] << 8))

d999 9
a1007 5
    unsigned char backupP4_0d,backupP2_00,backupP2_4d,biosflag=0;
    unsigned short svhs=0, svhs_c=0;
    unsigned short cvbs=0, cvbs_c=0;
    unsigned short vga2=0, vga2_c=0;
    int myflag, result; /* , i; */
d1010 3
a1012 2
    outSISIDXREG(SISPART4,0x0d,(backupP4_0d | 0x04));
    SiS_DDC2Delay(pSiS->SiS_Pr, 0x2000);
d1015 99
a1113 1
    outSISIDXREG(SISPART2,0x00,((backupP2_00 | 0x1c) & 0xfc));
d1115 68
a1182 70
    inSISIDXREG(SISPART2,0x4d,backupP2_4d);
    if(pSiS->VBFlags & (VB_301C|VB_301LV|VB_302LV|VB_302ELV)) {
       outSISIDXREG(SISPART2,0x4d,(backupP2_4d & ~0x10));
    }

    SISDoSense(pScrn, 0, 0);

    if(pSiS->VBFlags & VB_301) {
       svhs = 0x00b9; cvbs = 0x00b3; vga2 = 0x00d1;
       inSISIDXREG(SISPART4,0x01,myflag);
       if(myflag & 0x04) {
	  svhs = 0x00dd; cvbs = 0x00ee; vga2 = 0x00fd;
       }
    } else if(pSiS->VBFlags & (VB_301B | VB_302B)) {
       svhs = 0x016b; cvbs = 0x0174; vga2 = 0x0190;
    } else if(pSiS->VBFlags & (VB_301LV | VB_302LV)) {
       svhs = 0x0200; cvbs = 0x0100;
    } else if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
       svhs = 0x016b; cvbs = 0x0110; vga2 = 0x0190;
    } else return;

    vga2_c = 0x0e08; svhs_c = 0x0404; cvbs_c = 0x0804;
    if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
       svhs_c = 0x0408; cvbs_c = 0x0808;
    }
    biosflag = 2;

    if(pSiS->Chipset == PCI_CHIP_SIS300) {
       inSISIDXREG(SISSR,0x3b,myflag);
       if(!(myflag & 0x01)) vga2 = vga2_c = 0;
    }

    if(pSiS->sishw_ext.UseROM) {
       if(pSiS->VGAEngine == SIS_300_VGA) {
          if(pSiS->VBFlags & VB_301) {
	     inSISIDXREG(SISPART4,0x01,myflag);
             if(!(myflag & 0x04)) {
                vga2 = GETROMWORD(0xf8); svhs = GETROMWORD(0xfa); cvbs = GETROMWORD(0xfc);
	     }
	  }
	  biosflag = pSiS->BIOS[0xfe];
       } else if(pSiS->Chipset == PCI_CHIP_SIS660) {
          if(pSiS->ROM661New) {
	     biosflag = 2;
	     vga2 = GETROMWORD(0x63); svhs = cvbs = GETROMWORD(0x65);
	     if(pSiS->BIOS[0x5d] & 0x04) biosflag |= 0x01;
	  }
       } else if(!pSiS->ROM661New) {
#if 0	  /* eg. 1.15.23 has wrong values here */
          myflag = 0;
          if(pSiS->VBFlags & VB_301) {
	     if(pSiS->Chipset == PCI_CHIP_SIS330) {
	        myflag = 0xe5; i = 0x11b;
	     } else {
	        myflag = 0xbd; i = 0xf3
	     }
	  } else if(pSiS->VBFlags & (VB_301B|VB_302B|VB_301LV|VB_302LV)) {
	     if(pSiS->Chipset == PCI_CHIP_SIS330) {
	        myflag = 0xeb; i = 0x11b;
	     } else {
	        myflag = 0xc3; i = 0xf3
	     }
	  }
	  if(myflag) {
	     biosflag = pSiS->BIOS[i];    vga2 = GETROMWORD(myflag);
	     svhs = GETROMWORD(myflag+2); cvbs = GETROMWORD(myflag+4);
	  }
#endif
       }
    }
d1184 1
a1184 3
    if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
       vga2 = vga2_c = 0;
    }
d1189 18
a1206 4
    if(vga2_c || vga2) {
       if(SISDoSense(pScrn, vga2, vga2_c)) {
          if(biosflag & 0x01) {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
d1208 5
a1212 5
	     pSiS->VBFlags |= TV_SCART;
	     orSISIDXREG(SISCR, 0x32, 0x04);
	     pSiS->postVBCR32 |= 0x04;
	  } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
d1214 4
a1217 4
	     pSiS->VBFlags |= VGA2_CONNECTED;
	     orSISIDXREG(SISCR, 0x32, 0x10);
	     pSiS->postVBCR32 |= 0x10;
	  }
d1222 4
d1230 20
a1249 13
       if(pSiS->SenseYPbPr) {
          outSISIDXREG(SISPART2,0x4d,(backupP2_4d | 0x10));
          SiS_DDC2Delay(pSiS->SiS_Pr, 0x2000);
          if((result = SISDoSense(pScrn, svhs, 0x0604))) {
             if((result = SISDoSense(pScrn, cvbs, 0x0804))) {
	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
     			"SiS30x: Detected TV connected to YPbPr component output\n");
	        orSISIDXREG(SISCR,0x32,0x80);
	        pSiS->VBFlags |= TV_YPBPR;
	        pSiS->postVBCR32 |= 0x80;
	     }
          }
          outSISIDXREG(SISPART2,0x4d,backupP2_4d);
d1253 7
d1265 9
a1273 1
       if((result = SISDoSense(pScrn, svhs, svhs_c))) {
d1281 11
a1291 2
       if((biosflag & 0x02) || (!result)) {
          if(SISDoSense(pScrn, cvbs, cvbs_c)) {
d1302 1
a1302 1
    SISDoSense(pScrn, 0, 0);
a1712 1
	    pSiS->VBFlags |= VB_TRUMPION;
d1714 1
a1714 1
	               "Detected Trumpion Zurac (I/II/III) LVDS scaler\n");
d1788 2
a1789 3
		   orSISIDXREG(SISPART1,0x2f,0x01);  /* Unlock CRT2 */
		   inSISIDXREG(SISPART1,0x13,temp);
		   if(temp & 0x04) {
d1793 11
@


