head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.4
	cvs-200410241530:1.1.1.4
	cvs-200410012000:1.1.1.4
	cvs-200407221130:1.1.1.4
	cvs-200407141120:1.1.1.4
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.06.58;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.06.58;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.36.03;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.16.36;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.07.14.12.05.58;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.22.56;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h,v 1.24 2001/11/14 16:50:44 alanh Exp $ */
/*
 * Copyright 2000 ATI Technologies Inc., Markham, Ontario, and
 *                VA Linux Systems Inc., Fremont, California.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL ATI, VA LINUX SYSTEMS AND/OR
 * THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*
 * Authors:
 *   Kevin E. Martin <martin@@valinux.com>
 *   Rickard E. Faith <faith@@valinux.com>
 *   Alan Hourihane <ahourihane@@valinux.com>
 *
 */

#ifndef _RADEON_H_
#define _RADEON_H_

#include "xf86str.h"

				/* PCI support */
#include "xf86Pci.h"

				/* XAA and Cursor Support */
#include "xaa.h"
#include "xf86Cursor.h"

				/* DDC support */
#include "xf86DDC.h"

				/* Xv support */
#include "xf86xv.h"

				/* DRI support */
#ifdef XF86DRI
#define _XF86DRI_SERVER_
#include "radeon_dripriv.h"
#include "dri.h"
#include "GL/glxint.h"
#endif

				/* Render support */
#ifdef RENDER
#include "picturestr.h"
#endif

#define RADEON_DEBUG    0       /* Turn off debugging output                */
#define RADEON_TIMEOUT  2000000 /* Fall out of wait loops after this count */
#define RADEON_MMIOSIZE 0x80000

#define RADEON_VBIOS_SIZE 0x00010000

#if RADEON_DEBUG
#define RADEONTRACE(x)                                          \
    do {                                                        \
	ErrorF("(**) %s(%d): ", RADEON_NAME, pScrn->scrnIndex); \
	ErrorF x;                                               \
    } while (0);
#else
#define RADEONTRACE(x)
#endif


/* Other macros */
#define RADEON_ARRAY_SIZE(x)  (sizeof(x)/sizeof(x[0]))
#define RADEON_ALIGN(x,bytes) (((x) + ((bytes) - 1)) & ~((bytes) - 1))
#define RADEONPTR(pScrn) ((RADEONInfoPtr)(pScrn)->driverPrivate)

typedef struct {        /* All values in XCLKS    */
    int  ML;            /* Memory Read Latency    */
    int  MB;            /* Memory Burst Length    */
    int  Trcd;          /* RAS to CAS delay       */
    int  Trp;           /* RAS percentage         */
    int  Twr;           /* Write Recovery         */
    int  CL;            /* CAS Latency            */
    int  Tr2w;          /* Read to Write Delay    */
    int  Rloop;         /* Loop Latency           */
    int  Rloop_fudge;   /* Add to ML to get Rloop */
    char *name;
} RADEONRAMRec, *RADEONRAMPtr;

typedef struct {
				/* Common registers */
    CARD32     ovr_clr;
    CARD32     ovr_wid_left_right;
    CARD32     ovr_wid_top_bottom;
    CARD32     ov0_scale_cntl;
    CARD32     mpp_tb_config;
    CARD32     mpp_gp_config;
    CARD32     subpic_cntl;
    CARD32     viph_control;
    CARD32     i2c_cntl_1;
    CARD32     gen_int_cntl;
    CARD32     cap0_trig_cntl;
    CARD32     cap1_trig_cntl;
    CARD32     bus_cntl;
    CARD32     surface_cntl;

				/* Other registers to save for VT switches */
    CARD32     dp_datatype;
    CARD32     rbbm_soft_reset;
    CARD32     clock_cntl_index;
    CARD32     amcgpio_en_reg;
    CARD32     amcgpio_mask;

				/* CRTC registers */
    CARD32     crtc_gen_cntl;
    CARD32     crtc_ext_cntl;
    CARD32     dac_cntl;
    CARD32     crtc_h_total_disp;
    CARD32     crtc_h_sync_strt_wid;
    CARD32     crtc_v_total_disp;
    CARD32     crtc_v_sync_strt_wid;
    CARD32     crtc_offset;
    CARD32     crtc_offset_cntl;
    CARD32     crtc_pitch;

				/* CRTC2 registers */
    CARD32     crtc2_gen_cntl;

    CARD32     dac2_cntl;
    CARD32     disp_output_cntl;
    CARD32     crtc2_h_total_disp;
    CARD32     crtc2_h_sync_strt_wid;
    CARD32     crtc2_v_total_disp;
    CARD32     crtc2_v_sync_strt_wid;
    CARD32     crtc2_offset;
    CARD32     crtc2_offset_cntl;
    CARD32     crtc2_pitch;
				/* Flat panel registers */
    CARD32     fp_crtc_h_total_disp;
    CARD32     fp_crtc_v_total_disp;
    CARD32     fp_gen_cntl;
    CARD32     fp_h_sync_strt_wid;
    CARD32     fp_horz_stretch;
    CARD32     fp_panel_cntl;
    CARD32     fp_v_sync_strt_wid;
    CARD32     fp_vert_stretch;
    CARD32     lvds_gen_cntl;
    CARD32     lvds_pll_cntl;
    CARD32     tmds_crc;

				/* Computed values for PLL */
    CARD32     dot_clock_freq;
    CARD32     pll_output_freq;
    int        feedback_div;
    int        post_div;

				/* PLL registers */
    CARD32     ppll_ref_div;
    CARD32     ppll_div_3;
    CARD32     htotal_cntl;

				/* Computed values for PLL2 */
    CARD32     dot_clock_freq_2;
    CARD32     pll_output_freq_2;
    int        feedback_div_2;
    int        post_div_2;

				/* PLL2 registers */
    CARD32     p2pll_ref_div;
    CARD32     p2pll_div_0;
    CARD32     htotal_cntl2;

				/* DDA register */
    CARD32     dda_config;
    CARD32     dda_on_off;

				/* Pallet */
    Bool       palette_valid;
    CARD32     palette[256];
    CARD32     palette2[256];
} RADEONSaveRec, *RADEONSavePtr;

typedef struct {
    CARD16        reference_freq;
    CARD16        reference_div;
    CARD32        min_pll_freq;
    CARD32        max_pll_freq;
    CARD16        xclk;
} RADEONPLLRec, *RADEONPLLPtr;

typedef struct {
    int                bitsPerPixel;
    int                depth;
    int                displayWidth;
    int                pixel_code;
    int                pixel_bytes;
    DisplayModePtr     mode;
} RADEONFBLayout;

typedef enum
{
    MT_NONE,
    MT_CRT,
    MT_LCD,
    MT_DFP,
    MT_CTV,
    MT_STV
}RADEONMonitorType;

typedef enum
{
    DDC_NONE_DETECTED,
    DDC_MONID,
    DDC_DVI,
    DDC_VGA,
    DDC_CRT2
}RADEONDDCType;

typedef enum
{
    CONNECTOR_NONE,
    CONNECTOR_PROPRIETARY,
    CONNECTOR_CRT,
    CONNECTOR_DVI_I,
    CONNECTOR_DVI_D
}RADEONConnectorType;

typedef struct {
    EntityInfoPtr     pEnt;
    pciVideoPtr       PciInfo;
    PCITAG            PciTag;
    int               Chipset;
    Bool              Primary;

    Bool              FBDev;

    unsigned long     LinearAddr; /* Frame buffer physical address           */
    unsigned long     MMIOAddr;   /* MMIO region physical address            */
    unsigned long     BIOSAddr;   /* BIOS physical address                   */

    unsigned char     *MMIO;      /* Map of MMIO region                      */
    unsigned char     *FB;        /* Map of frame buffer                     */
    CARD8             *VBIOS;     /* Video BIOS pointer                      */

    CARD32            MemCntl;
    CARD32            BusCntl;
    unsigned long     FbMapSize;  /* Size of frame buffer, in bytes          */
    int               Flags;      /* Saved copy of mode flags                */

    /****** Added for VE/M6 support *******************/
    RADEONMonitorType DisplayType;  /* Monitor connected on*/
    RADEONDDCType     DDCType;
    RADEONConnectorType ConnectorType;
    BOOL              HasCRTC2;     /* VE/M6/M7 */
    BOOL              IsR200;       /* R200 chip */
    BOOL              IsRV200;      /* RV200 chip */
    BOOL              IsSecondary;  /* second Screen */
    BOOL              UseCRT;       /* force use CRT port as primary */
    BOOL              IsM6;         /* M6 card, for some workarounds */
    BOOL              SwitchingMode;
    int               FPBIOSstart;  /* Start of the flat panel info          */

				/* EDID or BIOS values for FPs */
    int               PanelXRes;
    int               PanelYRes;
    int               HOverPlus;
    int               HSyncWidth;
    int               HBlank;
    int               VOverPlus;
    int               VSyncWidth;
    int               VBlank;
    int               PanelPwrDly;
    int               DotClock;
    /****************************************************/

    /*for getting EDID data using DDC interface*/
    BOOL                      ddc_bios;
    BOOL                      ddc1;
    BOOL                      ddc2;
    I2CBusPtr		      pI2CBus;
    CARD32                    DDCReg;
    BOOL                      HasEDID;

    RADEONPLLRec        pll;
    RADEONRAMPtr        ram;

    RADEONSaveRec       SavedReg;         /* Original (text) mode                    */
    RADEONSaveRec       ModeReg;          /* Current mode                            */
    Bool              (*CloseScreen)(int, ScreenPtr);

    void              (*BlockHandler)(int, pointer, pointer, pointer);

    Bool              PaletteSavedOnVT; /* Palette saved on last VT switch   */

    XAAInfoRecPtr     accel;
    Bool              accelOn;
    xf86CursorInfoPtr cursor;
    unsigned long     cursor_start;
    unsigned long     cursor_end;

    /*
     * XAAForceTransBlit is used to change the behavior of the XAA
     * SetupForScreenToScreenCopy function, to make it DGA-friendly.
     */
    Bool              XAAForceTransBlit;

    int               fifo_slots; /* Free slots in the FIFO (64 max)         */
    int               pix24bpp;   /* Depth of pixmap for 24bpp framebuffer   */
    Bool              dac6bits;   /* Use 6 bit DAC?                          */

				/* Computed values for Radeon */
    int               pitch;
    int               datatype;
    CARD32            dp_gui_master_cntl;

				/* Saved values for ScreenToScreenCopy */
    int               xdir;
    int               ydir;

				/* ScanlineScreenToScreenColorExpand support */
    unsigned char     *scratch_buffer[1];
    unsigned char     *scratch_save;
    int               scanline_x;
    int               scanline_y;
    int               scanline_h;
    int               scanline_h_w;
    int               scanline_words;
    int               scanline_direct;
    int               scanline_bpp; /* Only used for ImageWrite */

    DGAModePtr        DGAModes;
    int               numDGAModes;
    Bool              DGAactive;
    int               DGAViewportStatus;
    DGAFunctionRec    DGAFuncs;

    RADEONFBLayout      CurrentLayout;
#ifdef XF86DRI
    Bool              directRenderingEnabled;
    DRIInfoPtr        pDRIInfo;
    int               drmFD;
    int               numVisualConfigs;
    __GLXvisualConfig *pVisualConfigs;
    RADEONConfigPrivPtr pVisualConfigsPriv;

    drmHandle         fbHandle;

    drmSize           registerSize;
    drmHandle         registerHandle;

    Bool              IsPCI;            /* Current card is a PCI card */
    drmSize           pciSize;
    drmHandle         pciMemHandle;
    unsigned char     *PCI;             /* Map */

    Bool              depthMoves;       /* Enable depth moves -- slow! */

    drmSize           agpSize;
    drmHandle         agpMemHandle;     /* Handle from drmAgpAlloc */
    unsigned long     agpOffset;
    unsigned char     *AGP;             /* Map */
    int               agpMode;

    CARD32            pciCommand;

    Bool              CPInUse;          /* CP has been used by X server */
    int               CPMode;           /* CP mode that server/clients use */
    int               CPFifoSize;       /* Size of the CP command FIFO */
    int               CPusecTimeout;    /* CP timeout in usecs */

				/* CP ring buffer data */
    unsigned long     ringStart;        /* Offset into AGP space */
    drmHandle         ringHandle;       /* Handle from drmAddMap */
    drmSize           ringMapSize;      /* Size of map */
    int               ringSize;         /* Size of ring (in MB) */
    unsigned char     *ring;            /* Map */
    int               ringSizeLog2QW;

    unsigned long     ringReadOffset;   /* Offset into AGP space */
    drmHandle         ringReadPtrHandle; /* Handle from drmAddMap */
    drmSize           ringReadMapSize;  /* Size of map */
    unsigned char     *ringReadPtr;     /* Map */

				/* CP vertex/indirect buffer data */
    unsigned long     bufStart;        /* Offset into AGP space */
    drmHandle         bufHandle;       /* Handle from drmAddMap */
    drmSize           bufMapSize;      /* Size of map */
    int               bufSize;         /* Size of buffers (in MB) */
    unsigned char     *buf;            /* Map */
    int               bufNumBufs;      /* Number of buffers */
    drmBufMapPtr      buffers;         /* Buffer map */

				/* CP AGP Texture data */
    unsigned long     agpTexStart;      /* Offset into AGP space */
    drmHandle         agpTexHandle;     /* Handle from drmAddMap */
    drmSize           agpTexMapSize;    /* Size of map */
    int               agpTexSize;       /* Size of AGP tex space (in MB) */
    unsigned char     *agpTex;          /* Map */
    int               log2AGPTexGran;

				/* CP accleration */
    drmBufPtr         indirectBuffer;
    int               indirectStart;

				/* DRI screen private data */
    int               fbX;
    int               fbY;
    int               backX;
    int               backY;
    int               depthX;
    int               depthY;

    int               frontOffset;
    int               frontPitch;
    int               backOffset;
    int               backPitch;
    int               depthOffset;
    int               depthPitch;
    int               textureOffset;
    int               textureSize;
    int               log2TexGran;

    CARD32            frontPitchOffset;
    CARD32            backPitchOffset;
    CARD32            depthPitchOffset;

    CARD32            dst_pitch_offset;

				/* Saved scissor values */
    CARD32            sc_left;
    CARD32            sc_right;
    CARD32            sc_top;
    CARD32            sc_bottom;

    CARD32            re_top_left;
    CARD32            re_width_height;

    CARD32            aux_sc_cntl;

#ifdef PER_CONTEXT_SAREA
    int 	      perctx_sarea_size;
#endif
#endif

    XF86VideoAdaptorPtr adaptor;
    void              (*VideoTimerCallback)(ScrnInfoPtr, Time);
    int               videoKey;
    Bool              showCache;
    OptionInfoPtr     Options;
} RADEONInfoRec, *RADEONInfoPtr;

#define RADEONWaitForFifo(pScrn, entries)                                    \
do {                                                                         \
    if (info->fifo_slots < entries)                                          \
	RADEONWaitForFifoFunction(pScrn, entries);                           \
    info->fifo_slots -= entries;                                             \
} while (0)

extern void        RADEONWaitForFifoFunction(ScrnInfoPtr pScrn, int entries);
extern void        RADEONWaitForIdle(ScrnInfoPtr pScrn);

extern void        RADEONEngineReset(ScrnInfoPtr pScrn);
extern void        RADEONEngineFlush(ScrnInfoPtr pScrn);
extern void        RADEONEngineRestore(ScrnInfoPtr pScrn);

extern unsigned    RADEONINPLL(ScrnInfoPtr pScrn, int addr);
extern void        RADEONWaitForVerticalSync(ScrnInfoPtr pScrn);

extern void        RADEONSelectBuffer(ScrnInfoPtr pScrn, int buffer);

extern Bool        RADEONAccelInit(ScreenPtr pScreen);
extern Bool        RADEONCursorInit(ScreenPtr pScreen);
extern Bool        RADEONDGAInit(ScreenPtr pScreen);

extern int         RADEONMinBits(int val);

extern void        RADEONInitVideo(ScreenPtr);

#ifdef XF86DRI
extern Bool        RADEONDRIScreenInit(ScreenPtr pScreen);
extern void        RADEONDRICloseScreen(ScreenPtr pScreen);
extern Bool        RADEONDRIFinishScreenInit(ScreenPtr pScreen);

extern drmBufPtr   RADEONCPGetBuffer(ScrnInfoPtr pScrn);
extern void        RADEONCPFlushIndirect(ScrnInfoPtr pScrn);
extern void        RADEONCPReleaseIndirect(ScrnInfoPtr pScrn);


#define RADEONCP_START(pScrn, info)					\
do {									\
    int _ret = drmRadeonStartCP(info->drmFD);				\
    if (_ret) {								\
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,				\
		   "%s: CP start %d\n", __FUNCTION__, _ret);		\
    }									\
} while (0)

#define RADEONCP_STOP(pScrn, info)					\
do {									\
    int _ret = drmRadeonStopCP(info->drmFD);				\
    if (_ret) {								\
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,				\
		   "%s: CP stop %d\n", __FUNCTION__, _ret);		\
    }									\
    RADEONEngineRestore(pScrn);						\
} while (0)

#define RADEONCP_RESET(pScrn, info)					\
do {									\
    if (RADEONCP_USE_RING_BUFFER(info->CPMode)) {			\
	int _ret = drmRadeonResetCP(info->drmFD);			\
	if (_ret) {							\
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,			\
		       "%s: CP reset %d\n", __FUNCTION__, _ret);	\
	}								\
    }									\
} while (0)

#define RADEONCP_REFRESH(pScrn, info)					\
do {									\
   if ( !info->CPInUse ) {						\
      RADEON_WAIT_UNTIL_IDLE();						\
      BEGIN_RING( 6 );							\
      OUT_RING_REG( RADEON_RE_TOP_LEFT,     info->re_top_left );	\
      OUT_RING_REG( RADEON_RE_WIDTH_HEIGHT, info->re_width_height );	\
      OUT_RING_REG( RADEON_AUX_SC_CNTL,     info->aux_sc_cntl );	\
      ADVANCE_RING();							\
      info->CPInUse = TRUE;						\
   }									\
} while (0)


#define CP_PACKET0( reg, n )						\
	(RADEON_CP_PACKET0 | ((n) << 16) | ((reg) >> 2))
#define CP_PACKET1( reg0, reg1 )					\
	(RADEON_CP_PACKET1 | (((reg1) >> 2) << 11) | ((reg0) >> 2))
#define CP_PACKET2()							\
	(RADEON_CP_PACKET2)
#define CP_PACKET3( pkt, n )						\
	(RADEON_CP_PACKET3 | (pkt) | ((n) << 16))


#define RADEON_VERBOSE	0

#define RING_LOCALS	CARD32 *__head; int __count;
#define RING_THRESHOLD	256

#define BEGIN_RING( n ) do {						\
   if ( RADEON_VERBOSE ) {						\
      xf86DrvMsg( pScrn->scrnIndex, X_INFO,				\
		  "BEGIN_RING( %d ) in %s\n", n, __FUNCTION__ );	\
   }									\
   if ( !info->indirectBuffer ) {					\
      info->indirectBuffer = RADEONCPGetBuffer( pScrn );		\
      info->indirectStart = 0;						\
   } else if ( info->indirectBuffer->used - info->indirectStart +	\
	       (n) * (int)sizeof(CARD32) > RING_THRESHOLD ) {		\
      RADEONCPFlushIndirect( pScrn );					\
   }									\
   __head = (pointer)((char *)info->indirectBuffer->address +		\
		       info->indirectBuffer->used);			\
   __count = 0;								\
} while (0)

#define ADVANCE_RING() do {						\
   if ( RADEON_VERBOSE ) {						\
      xf86DrvMsg( pScrn->scrnIndex, X_INFO,				\
		  "ADVANCE_RING() used: %d+%d=%d/%d\n",			\
		  info->indirectBuffer->used - info->indirectStart,	\
		  __count * sizeof(CARD32),				\
		  info->indirectBuffer->used - info->indirectStart +	\
		  __count * sizeof(CARD32),				\
		  RING_THRESHOLD );					\
   }									\
   info->indirectBuffer->used += __count * (int)sizeof(CARD32);		\
} while (0)

#define OUT_RING( x ) do {						\
   if ( RADEON_VERBOSE ) {						\
      xf86DrvMsg( pScrn->scrnIndex, X_INFO,				\
		  "   OUT_RING( 0x%08x )\n", (unsigned int)(x) );	\
   }									\
   __head[__count++] = (x);						\
} while (0)

#define OUT_RING_REG( reg, val )					\
do {									\
   OUT_RING( CP_PACKET0( reg, 0 ) );					\
   OUT_RING( val );							\
} while (0)

#define FLUSH_RING()							\
do {									\
   if ( RADEON_VERBOSE )						\
      xf86DrvMsg( pScrn->scrnIndex, X_INFO,				\
		  "FLUSH_RING in %s\n", __FUNCTION__ );			\
   if ( info->indirectBuffer ) {					\
      RADEONCPFlushIndirect( pScrn );					\
   }									\
} while (0)


#define RADEON_WAIT_UNTIL_2D_IDLE()					\
do {									\
   BEGIN_RING( 2 );							\
   OUT_RING( CP_PACKET0( RADEON_WAIT_UNTIL, 0 ) );			\
   OUT_RING( (RADEON_WAIT_2D_IDLECLEAN |				\
	      RADEON_WAIT_HOST_IDLECLEAN) );				\
   ADVANCE_RING();							\
} while (0)

#define RADEON_WAIT_UNTIL_3D_IDLE()					\
do {									\
   BEGIN_RING( 2 );							\
   OUT_RING( CP_PACKET0( RADEON_WAIT_UNTIL, 0 ) );			\
   OUT_RING( (RADEON_WAIT_3D_IDLECLEAN |				\
	      RADEON_WAIT_HOST_IDLECLEAN) );				\
   ADVANCE_RING();							\
} while (0)

#define RADEON_WAIT_UNTIL_IDLE()					\
do {									\
   if ( RADEON_VERBOSE ) {						\
      xf86DrvMsg( pScrn->scrnIndex, X_INFO,				\
		  "WAIT_UNTIL_IDLE() in %s\n", __FUNCTION__ );		\
   }									\
   BEGIN_RING( 2 );							\
   OUT_RING( CP_PACKET0( RADEON_WAIT_UNTIL, 0 ) );			\
   OUT_RING( (RADEON_WAIT_2D_IDLECLEAN |				\
	      RADEON_WAIT_3D_IDLECLEAN |				\
	      RADEON_WAIT_HOST_IDLECLEAN) );				\
   ADVANCE_RING();							\
} while (0)

#define RADEON_FLUSH_CACHE()						\
do {									\
   BEGIN_RING( 2 );							\
   OUT_RING( CP_PACKET0( RADEON_RB2D_DSTCACHE_CTLSTAT, 0 ) );		\
   OUT_RING( RADEON_RB2D_DC_FLUSH );					\
   ADVANCE_RING();							\
} while (0)

#define RADEON_PURGE_CACHE()						\
do {									\
   BEGIN_RING( 2 );							\
   OUT_RING( CP_PACKET0( RADEON_RB2D_DSTCACHE_CTLSTAT, 0 ) );		\
   OUT_RING( RADEON_RB2D_DC_FLUSH_ALL );				\
   ADVANCE_RING();							\
} while (0)

#endif /* XF86DRI */

#endif /* _RADEON_H_ */
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h,v 1.44 2003/11/10 18:41:21 tsi Exp $ */
d32 1
a32 1
 *   Kevin E. Martin <martin@@xfree86.org>
d34 1
a34 1
 *   Alan Hourihane <alanh@@fairlite.demon.co.uk>
d69 3
a71 4
#define RADEON_DEBUG            0 /* Turn off debugging output               */
#define RADEON_IDLE_RETRY      16 /* Fall out of idle loops after this count */
#define RADEON_TIMEOUT    2000000 /* Fall out of wait loops after this count */
#define RADEON_MMIOSIZE   0x80000
a73 4
#define RADEON_USE_RMX 0x80000000 /* mode flag for using RMX
				   * Need to comfirm this is not used
				   * for something else.
				   */
d76 5
a80 5
#define RADEONTRACE(x)							\
do {									\
    ErrorF("(**) %s(%d): ", RADEON_NAME, pScrn->scrnIndex);		\
    ErrorF x;								\
} while (0);
d89 14
a102 1
#define RADEONPTR(pScrn)      ((RADEONInfoPtr)(pScrn)->driverPrivate)
d106 15
a120 15
    CARD32            ovr_clr;
    CARD32            ovr_wid_left_right;
    CARD32            ovr_wid_top_bottom;
    CARD32            ov0_scale_cntl;
    CARD32            mpp_tb_config;
    CARD32            mpp_gp_config;
    CARD32            subpic_cntl;
    CARD32            viph_control;
    CARD32            i2c_cntl_1;
    CARD32            gen_int_cntl;
    CARD32            cap0_trig_cntl;
    CARD32            cap1_trig_cntl;
    CARD32            bus_cntl;
    CARD32            surface_cntl;
    CARD32            bios_5_scratch;
d122 5
a126 5
    CARD32            dp_datatype;
    CARD32            rbbm_soft_reset;
    CARD32            clock_cntl_index;
    CARD32            amcgpio_en_reg;
    CARD32            amcgpio_mask;
d129 10
a138 13
    CARD32            crtc_gen_cntl;
    CARD32            crtc_ext_cntl;
    CARD32            dac_cntl;
    CARD32            crtc_h_total_disp;
    CARD32            crtc_h_sync_strt_wid;
    CARD32            crtc_v_total_disp;
    CARD32            crtc_v_sync_strt_wid;
    CARD32            crtc_offset;
    CARD32            crtc_offset_cntl;
    CARD32            crtc_pitch;
    CARD32            disp_merge_cntl;
    CARD32            grph_buffer_cntl;
    CARD32            crtc_more_cntl;
d141 1
a141 1
    CARD32            crtc2_gen_cntl;
d143 9
a151 12
    CARD32            dac2_cntl;
    CARD32            disp_output_cntl;
    CARD32            disp_hw_debug;
    CARD32            disp2_merge_cntl;
    CARD32            grph2_buffer_cntl;
    CARD32            crtc2_h_total_disp;
    CARD32            crtc2_h_sync_strt_wid;
    CARD32            crtc2_v_total_disp;
    CARD32            crtc2_v_sync_strt_wid;
    CARD32            crtc2_offset;
    CARD32            crtc2_offset_cntl;
    CARD32            crtc2_pitch;
d153 11
a163 15
    CARD32            fp_crtc_h_total_disp;
    CARD32            fp_crtc_v_total_disp;
    CARD32            fp_gen_cntl;
    CARD32            fp2_gen_cntl;
    CARD32            fp_h_sync_strt_wid;
    CARD32            fp2_h_sync_strt_wid;
    CARD32            fp_horz_stretch;
    CARD32            fp_panel_cntl;
    CARD32            fp_v_sync_strt_wid;
    CARD32            fp2_v_sync_strt_wid;
    CARD32            fp_vert_stretch;
    CARD32            lvds_gen_cntl;
    CARD32            lvds_pll_cntl;
    CARD32            tmds_pll_cntl;
    CARD32            tmds_transmitter_cntl;
d166 4
a169 4
    CARD32            dot_clock_freq;
    CARD32            pll_output_freq;
    int               feedback_div;
    int               post_div;
d172 3
a174 3
    unsigned          ppll_ref_div;
    unsigned          ppll_div_3;
    CARD32            htotal_cntl;
d177 4
a180 4
    CARD32            dot_clock_freq_2;
    CARD32            pll_output_freq_2;
    int               feedback_div_2;
    int               post_div_2;
d183 7
a189 3
    CARD32            p2pll_ref_div;
    CARD32            p2pll_div_0;
    CARD32            htotal_cntl2;
d192 3
a194 3
    Bool              palette_valid;
    CARD32            palette[256];
    CARD32            palette2[256];
d198 5
a202 5
    CARD16            reference_freq;
    CARD16            reference_div;
    CARD32            min_pll_freq;
    CARD32            max_pll_freq;
    CARD16            xclk;
d206 6
a211 6
    int               bitsPerPixel;
    int               depth;
    int               displayWidth;
    int               pixel_code;
    int               pixel_bytes;
    DisplayModePtr    mode;
d214 2
a215 1
typedef enum {
d222 1
a222 1
} RADEONMonitorType;
d224 2
a225 1
typedef enum {
d231 1
a231 1
} RADEONDDCType;
d233 2
a234 1
typedef enum {
d240 1
a240 24
} RADEONConnectorType;

typedef enum {
    CHIP_FAMILY_UNKNOW,
    CHIP_FAMILY_LEGACY,
    CHIP_FAMILY_RADEON,
    CHIP_FAMILY_RV100,
    CHIP_FAMILY_RS100,    /* U1 (IGP320M) or A3 (IGP320)*/
    CHIP_FAMILY_RV200,
    CHIP_FAMILY_RS200,    /* U2 (IGP330M/340M/350M) or A4 (IGP330/340/345/350), RS250 (IGP 7000) */
    CHIP_FAMILY_R200,
    CHIP_FAMILY_RV250,
    CHIP_FAMILY_RS300,    /* Radeon 9000 IGP */
    CHIP_FAMILY_RV280,
    CHIP_FAMILY_R300,
    CHIP_FAMILY_R350,
    CHIP_FAMILY_RV350,
    CHIP_FAMILY_LAST
} RADEONChipFamily;

typedef struct {
    CARD32 freq;
    CARD32 value;
}RADEONTMDSPll;
d247 1
a247 1
    RADEONChipFamily  ChipFamily;
d251 7
a257 7
    unsigned long     LinearAddr;       /* Frame buffer physical address     */
    unsigned long     MMIOAddr;         /* MMIO region physical address      */
    unsigned long     BIOSAddr;         /* BIOS physical address             */

    unsigned char     *MMIO;            /* Map of MMIO region                */
    unsigned char     *FB;              /* Map of frame buffer               */
    CARD8             *VBIOS;           /* Video BIOS pointer                */
d261 2
a262 2
    unsigned long     FbMapSize;        /* Size of frame buffer, in bytes    */
    int               Flags;            /* Saved copy of mode flags          */
d264 2
a265 2
				/* VE/M6 support */
    RADEONMonitorType DisplayType;      /* Monitor connected on              */
d268 8
a275 19
    Bool              HasCRTC2;         /* All cards except original Radeon  */
    Bool              IsMobility;       /* Mobile chips for laptops */
    Bool              IsIGP;            /* IGP chips */
    Bool              IsSecondary;      /* Second Screen                     */
    Bool              IsSwitching;      /* Flag for switching mode           */
    Bool              Clone;            /* Force second head to clone primary*/
    RADEONMonitorType CloneType;
    RADEONDDCType     CloneDDCType;
    DisplayModePtr    CloneModes;
    DisplayModePtr    CurCloneMode;
    int               CloneFrameX0;
    int               CloneFrameY0;
    Bool              OverlayOnCRTC2;
    Bool              PanelOff;         /* Force panel (LCD/DFP) off         */
    int               FPBIOSstart;      /* Start of the flat panel info      */
    Bool              ddc_mode;         /* Validate mode by matching exactly
					 * the modes supported in DDC data
					 */
    Bool              R300CGWorkaround;
d288 9
a296 18
    int               RefDivider;
    int               FeedbackDivider;
    int               PostDivider;
    Bool              UseBiosDividers;
				/* EDID data using DDC interface */
    Bool              ddc_bios;
    Bool              ddc1;
    Bool              ddc2;
    I2CBusPtr         pI2CBus;
    CARD32            DDCReg;

    RADEONPLLRec      pll;
    RADEONTMDSPll     tmds_pll[4];
    int               RamWidth;
    float	      sclk;		/* in MHz */
    float	      mclk;		/* in MHz */
    Bool	      IsDDR;
    int               DispPriority;
d298 5
a302 2
    RADEONSaveRec     SavedReg;         /* Original (text) mode              */
    RADEONSaveRec     ModeReg;          /* Current mode                      */
a313 5
#ifdef ARGB_CURSOR
    Bool	      cursor_argb;
#endif
    int               cursor_fg;
    int               cursor_bg;
d321 3
a323 3
    int               fifo_slots;       /* Free slots in the FIFO (64 max)   */
    int               pix24bpp;         /* Depth of pixmap for 24bpp fb      */
    Bool              dac6bits;         /* Use 6 bit DAC?                    */
a328 2
    CARD32            dp_gui_master_cntl_clip;
    CARD32            trans_color;
a338 1
    int               scanline_w;
d343 1
a343 12
    int               scanline_bpp;     /* Only used for ImageWrite */
    int               scanline_fg;
    int               scanline_bg;
    int               scanline_hpass;
    int               scanline_x1clip;
    int               scanline_x2clip;

				/* Saved values for DashedTwoPointLine */
    int               dashLen;
    CARD32            dashPattern;
    int               dash_fg;
    int               dash_bg;
d351 1
a351 1
    RADEONFBLayout    CurrentLayout;
a352 1
    Bool              noBackBuffer;
a370 3
    Bool              allowPageFlip;    /* Enable 3d page flipping */
    Bool              have3DWindows;    /* Are there any 3d clients? */
    int               drmMinor;
d372 1
a372 1
    drmSize           gartSize;
d374 1
a374 1
    unsigned long     gartOffset;
a376 1
    int               agpFastWrite;
a379 1
    Bool              CPRuns;           /* CP is running */
a380 1
    Bool              CPStarted;        /* CP has started */
d386 1
a386 1
    unsigned long     ringStart;        /* Offset into GART space */
d393 1
a393 1
    unsigned long     ringReadOffset;   /* Offset into GART space */
d399 15
a413 15
    unsigned long     bufStart;         /* Offset into GART space */
    drmHandle         bufHandle;        /* Handle from drmAddMap */
    drmSize           bufMapSize;       /* Size of map */
    int               bufSize;          /* Size of buffers (in MB) */
    unsigned char     *buf;             /* Map */
    int               bufNumBufs;       /* Number of buffers */
    drmBufMapPtr      buffers;          /* Buffer map */

				/* CP GART Texture data */
    unsigned long     gartTexStart;      /* Offset into GART space */
    drmHandle         gartTexHandle;     /* Handle from drmAddMap */
    drmSize           gartTexMapSize;    /* Size of map */
    int               gartTexSize;       /* Size of GART tex space (in MB) */
    unsigned char     *gartTex;          /* Map */
    int               log2GARTTexGran;
a442 6
				/* offscreen memory management */
    int               backLines;
    FBAreaPtr         backArea;
    int               depthTexLines;
    FBAreaPtr         depthTexArea;

a453 2
    int               irq;

d455 1
a455 1
    int               perctx_sarea_size;
a458 1
				/* XVideo */
a460 1
    FBLinearPtr       videoLinear;
a461 2

				/* general */
a463 3
#ifdef XFree86LOADER
    XF86ModReqInfo    xaaReq;
#endif
d466 5
a470 5
#define RADEONWaitForFifo(pScrn, entries)				\
do {									\
    if (info->fifo_slots < entries)					\
	RADEONWaitForFifoFunction(pScrn, entries);			\
    info->fifo_slots -= entries;					\
d474 1
a474 7
extern void        RADEONWaitForIdleMMIO(ScrnInfoPtr pScrn);
#ifdef XF86DRI
extern void        RADEONWaitForIdleCP(ScrnInfoPtr pScrn);
#endif

extern void        RADEONDoAdjustFrame(ScrnInfoPtr pScrn, int x, int y,
				       int clone);
a481 1
extern void        RADEONWaitForVerticalSync2(ScrnInfoPtr pScrn);
a485 1
extern void        RADEONEngineInit(ScrnInfoPtr pScrn);
d491 1
a491 3
extern void        RADEONInitVideo(ScreenPtr pScreen);
extern void        RADEONResetVideo(ScrnInfoPtr pScrn);
extern void        R300CGWorkaround(ScrnInfoPtr pScrn);
a495 1
extern void        RADEONDRIResume(ScreenPtr pScreen);
d499 1
a499 1
extern void        RADEONCPFlushIndirect(ScrnInfoPtr pScrn, int discard);
a500 1
extern int         RADEONCPStop(ScrnInfoPtr pScrn,  RADEONInfoPtr info);
d505 1
a505 1
    int _ret = drmCommandNone(info->drmFD, DRM_RADEON_CP_START);	\
a509 1
    info->CPStarted = TRUE;                                             \
d514 3
a516 5
    int _ret;								\
     if (info->CPStarted) {						\
        _ret = RADEONCPStop(pScrn, info);				\
        if (_ret) {							\
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,			\
d518 1
a518 3
        }								\
        info->CPStarted = FALSE;                                        \
   }									\
a519 1
    info->CPRuns = FALSE;						\
d525 1
a525 1
	int _ret = drmCommandNone(info->drmFD, DRM_RADEON_CP_RESET);	\
d535 9
a543 9
    if (!info->CPInUse) {						\
	RADEON_WAIT_UNTIL_IDLE();					\
	BEGIN_RING(6);							\
	OUT_RING_REG(RADEON_RE_TOP_LEFT,     info->re_top_left);	\
	OUT_RING_REG(RADEON_RE_WIDTH_HEIGHT, info->re_width_height);	\
	OUT_RING_REG(RADEON_AUX_SC_CNTL,     info->aux_sc_cntl);	\
	ADVANCE_RING();							\
	info->CPInUse = TRUE;						\
    }									\
d547 1
a547 1
#define CP_PACKET0(reg, n)						\
d549 1
a549 1
#define CP_PACKET1(reg0, reg1)						\
d553 1
a553 1
#define CP_PACKET3(pkt, n)						\
d559 2
a560 1
#define RING_LOCALS	CARD32 *__head = NULL; int __count = 0
d562 13
a574 13
#define BEGIN_RING(n) do {						\
    if (RADEON_VERBOSE) {						\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
		   "BEGIN_RING(%d) in %s\n", n, __FUNCTION__);		\
    }									\
    if (!info->indirectBuffer) {					\
	info->indirectBuffer = RADEONCPGetBuffer(pScrn);		\
	info->indirectStart = 0;					\
    } else if (info->indirectBuffer->used + (n) * (int)sizeof(CARD32) >	\
	       info->indirectBuffer->total) {				\
	RADEONCPFlushIndirect(pScrn, 1);				\
    }									\
    __head = (pointer)((char *)info->indirectBuffer->address +		\
d576 1
a576 1
    __count = 0;							\
d580 10
a589 8
    if (RADEON_VERBOSE) {						\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
		   "ADVANCE_RING() start: %d used: %d count: %d\n",	\
		   info->indirectStart,					\
		   info->indirectBuffer->used,				\
		   __count * (int)sizeof(CARD32));			\
    }									\
    info->indirectBuffer->used += __count * (int)sizeof(CARD32);	\
d592 6
a597 6
#define OUT_RING(x) do {						\
    if (RADEON_VERBOSE) {						\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
		   "   OUT_RING(0x%08x)\n", (unsigned int)(x));		\
    }									\
    __head[__count++] = (x);						\
d600 1
a600 1
#define OUT_RING_REG(reg, val)						\
d602 2
a603 2
    OUT_RING(CP_PACKET0(reg, 0));					\
    OUT_RING(val);							\
d608 6
a613 6
    if (RADEON_VERBOSE)							\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
		   "FLUSH_RING in %s\n", __FUNCTION__);			\
    if (info->indirectBuffer) {						\
	RADEONCPFlushIndirect(pScrn, 0);				\
    }									\
d619 5
a623 5
    BEGIN_RING(2);							\
    OUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));				\
    OUT_RING((RADEON_WAIT_2D_IDLECLEAN |				\
	      RADEON_WAIT_HOST_IDLECLEAN));				\
    ADVANCE_RING();							\
d628 5
a632 5
    BEGIN_RING(2);							\
    OUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));				\
    OUT_RING((RADEON_WAIT_3D_IDLECLEAN |				\
	      RADEON_WAIT_HOST_IDLECLEAN));				\
    ADVANCE_RING();							\
d637 7
a643 7
    if (RADEON_VERBOSE) {						\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
		   "WAIT_UNTIL_IDLE() in %s\n", __FUNCTION__);		\
    }									\
    BEGIN_RING(2);							\
    OUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));				\
    OUT_RING((RADEON_WAIT_2D_IDLECLEAN |				\
d645 2
a646 2
	      RADEON_WAIT_HOST_IDLECLEAN));				\
    ADVANCE_RING();							\
d651 4
a654 4
    BEGIN_RING(2);							\
    OUT_RING(CP_PACKET0(RADEON_RB2D_DSTCACHE_CTLSTAT, 0));		\
    OUT_RING(RADEON_RB2D_DC_FLUSH);					\
    ADVANCE_RING();							\
d659 4
a662 4
    BEGIN_RING(2);							\
    OUT_RING(CP_PACKET0(RADEON_RB2D_DSTCACHE_CTLSTAT, 0));		\
    OUT_RING(RADEON_RB2D_DC_FLUSH_ALL);					\
    ADVANCE_RING();							\
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h,v 1.37 2003/02/23 23:28:48 dawes Exp $ */
d32 1
a32 1
 *   Kevin E. Martin <martin@@xfree86.org>
d34 1
a34 1
 *   Alan Hourihane <alanh@@fairlite.demon.co.uk>
d69 3
a71 4
#define RADEON_DEBUG            0 /* Turn off debugging output               */
#define RADEON_IDLE_RETRY      16 /* Fall out of idle loops after this count */
#define RADEON_TIMEOUT    2000000 /* Fall out of wait loops after this count */
#define RADEON_MMIOSIZE   0x80000
a73 4
#define RADEON_USE_RMX 0x80000000 /* mode flag for using RMX 
				   * Need to comfirm this is not used 
				   * for something else.
				   */
d76 5
a80 5
#define RADEONTRACE(x)							\
do {									\
    ErrorF("(**) %s(%d): ", RADEON_NAME, pScrn->scrnIndex);		\
    ErrorF x;								\
} while (0);
d89 1
a89 1
#define RADEONPTR(pScrn)      ((RADEONInfoPtr)(pScrn)->driverPrivate)
d91 11
a101 12
typedef struct {
				/* All values in XCLKS    */
    int               ML;            /* Memory Read Latency    */
    int               MB;            /* Memory Burst Length    */
    int               Trcd;          /* RAS to CAS delay       */
    int               Trp;           /* RAS percentage         */
    int               Twr;           /* Write Recovery         */
    int               CL;            /* CAS Latency            */
    int               Tr2w;          /* Read to Write Delay    */
    int               Rloop;         /* Loop Latency           */
    int               Rloop_fudge;   /* Add to ML to get Rloop */
    char              *name;
d106 14
a119 14
    CARD32            ovr_clr;
    CARD32            ovr_wid_left_right;
    CARD32            ovr_wid_top_bottom;
    CARD32            ov0_scale_cntl;
    CARD32            mpp_tb_config;
    CARD32            mpp_gp_config;
    CARD32            subpic_cntl;
    CARD32            viph_control;
    CARD32            i2c_cntl_1;
    CARD32            gen_int_cntl;
    CARD32            cap0_trig_cntl;
    CARD32            cap1_trig_cntl;
    CARD32            bus_cntl;
    CARD32            surface_cntl;
d122 5
a126 5
    CARD32            dp_datatype;
    CARD32            rbbm_soft_reset;
    CARD32            clock_cntl_index;
    CARD32            amcgpio_en_reg;
    CARD32            amcgpio_mask;
d129 10
a138 10
    CARD32            crtc_gen_cntl;
    CARD32            crtc_ext_cntl;
    CARD32            dac_cntl;
    CARD32            crtc_h_total_disp;
    CARD32            crtc_h_sync_strt_wid;
    CARD32            crtc_v_total_disp;
    CARD32            crtc_v_sync_strt_wid;
    CARD32            crtc_offset;
    CARD32            crtc_offset_cntl;
    CARD32            crtc_pitch;
d141 1
a141 1
    CARD32            crtc2_gen_cntl;
d143 9
a151 10
    CARD32            dac2_cntl;
    CARD32            disp_output_cntl;
    CARD32            disp_hw_debug;
    CARD32            crtc2_h_total_disp;
    CARD32            crtc2_h_sync_strt_wid;
    CARD32            crtc2_v_total_disp;
    CARD32            crtc2_v_sync_strt_wid;
    CARD32            crtc2_offset;
    CARD32            crtc2_offset_cntl;
    CARD32            crtc2_pitch;
d153 11
a163 14
    CARD32            fp_crtc_h_total_disp;
    CARD32            fp_crtc_v_total_disp;
    CARD32            fp_gen_cntl;
    CARD32            fp2_gen_cntl;
    CARD32            fp_h_sync_strt_wid;
    CARD32            fp2_h_sync_strt_wid;
    CARD32            fp_horz_stretch;
    CARD32            fp_panel_cntl;
    CARD32            fp_v_sync_strt_wid;
    CARD32            fp2_v_sync_strt_wid;
    CARD32            fp_vert_stretch;
    CARD32            lvds_gen_cntl;
    CARD32            lvds_pll_cntl;
    CARD32            tmds_pll_cntl;
d166 4
a169 4
    CARD32            dot_clock_freq;
    CARD32            pll_output_freq;
    int               feedback_div;
    int               post_div;
d172 3
a174 3
    CARD32            ppll_ref_div;
    CARD32            ppll_div_3;
    CARD32            htotal_cntl;
d177 4
a180 4
    CARD32            dot_clock_freq_2;
    CARD32            pll_output_freq_2;
    int               feedback_div_2;
    int               post_div_2;
d183 7
a189 3
    CARD32            p2pll_ref_div;
    CARD32            p2pll_div_0;
    CARD32            htotal_cntl2;
d192 3
a194 3
    Bool              palette_valid;
    CARD32            palette[256];
    CARD32            palette2[256];
d198 5
a202 5
    CARD16            reference_freq;
    CARD16            reference_div;
    CARD32            min_pll_freq;
    CARD32            max_pll_freq;
    CARD16            xclk;
d206 6
a211 6
    int               bitsPerPixel;
    int               depth;
    int               displayWidth;
    int               pixel_code;
    int               pixel_bytes;
    DisplayModePtr    mode;
d214 2
a215 1
typedef enum {
d222 1
a222 1
} RADEONMonitorType;
d224 2
a225 1
typedef enum {
d231 1
a231 1
} RADEONDDCType;
d233 2
a234 1
typedef enum {
d240 1
a240 17
} RADEONConnectorType;

typedef enum {
    CHIP_FAMILY_UNKNOW,
    CHIP_FAMILY_LEGACY,
    CHIP_FAMILY_R128,
    CHIP_FAMILY_M3,
    CHIP_FAMILY_RADEON,
    CHIP_FAMILY_VE,
    CHIP_FAMILY_M6,
    CHIP_FAMILY_RV200,
    CHIP_FAMILY_M7,
    CHIP_FAMILY_R200,
    CHIP_FAMILY_RV250,
    CHIP_FAMILY_M9,
    CHIP_FAMILY_R300
} RADEONChipFamily;
d247 1
a247 1
    RADEONChipFamily  ChipFamily;
d251 7
a257 7
    unsigned long     LinearAddr;       /* Frame buffer physical address     */
    unsigned long     MMIOAddr;         /* MMIO region physical address      */
    unsigned long     BIOSAddr;         /* BIOS physical address             */

    unsigned char     *MMIO;            /* Map of MMIO region                */
    unsigned char     *FB;              /* Map of frame buffer               */
    CARD8             *VBIOS;           /* Video BIOS pointer                */
d261 2
a262 2
    unsigned long     FbMapSize;        /* Size of frame buffer, in bytes    */
    int               Flags;            /* Saved copy of mode flags          */
d264 2
a265 2
				/* VE/M6 support */
    RADEONMonitorType DisplayType;      /* Monitor connected on              */
d268 8
a275 19
    Bool              HasCRTC2;         /* All cards except original Radeon  */
    Bool              IsSecondary;      /* Second Screen                     */
    Bool              IsSwitching;      /* Flag for switching mode           */
    Bool              IsDell;           /* Dell OEM VE card                  */
    int               DellType;
    Bool              Clone;            /* Force second head to clone primary*/
    RADEONMonitorType CloneType;
    RADEONDDCType     CloneDDCType;
    DisplayModePtr    CloneModes;
    DisplayModePtr    CurCloneMode;
    int               CloneFrameX0;
    int               CloneFrameY0;
    Bool              OverlayOnCRTC2;
    Bool              PanelOff;         /* Force panel (LCD/DFP) off         */
    int               FPBIOSstart;      /* Start of the flat panel info      */
    Bool              ddc_mode;         /* Validate mode by matching exactly  
					 * the modes supported in DDC data
					 */
    Bool              R300CGWorkaround;
d288 1
d290 7
a296 6
				/* EDID data using DDC interface */
    Bool              ddc_bios;
    Bool              ddc1;
    Bool              ddc2;
    I2CBusPtr         pI2CBus;
    CARD32            DDCReg;
d298 2
a299 2
    RADEONPLLRec      pll;
    RADEONRAMPtr      ram;
d301 2
a302 2
    RADEONSaveRec     SavedReg;         /* Original (text) mode              */
    RADEONSaveRec     ModeReg;          /* Current mode                      */
a313 5
#ifdef ARGB_CURSOR
    Bool	      cursor_argb;
#endif
    int               cursor_fg;
    int               cursor_bg;
d321 3
a323 3
    int               fifo_slots;       /* Free slots in the FIFO (64 max)   */
    int               pix24bpp;         /* Depth of pixmap for 24bpp fb      */
    Bool              dac6bits;         /* Use 6 bit DAC?                    */
a328 2
    CARD32            dp_gui_master_cntl_clip;
    CARD32            trans_color;
a338 1
    int               scanline_w;
d343 1
a343 12
    int               scanline_bpp;     /* Only used for ImageWrite */
    int               scanline_fg;
    int               scanline_bg;
    int               scanline_hpass;
    int               scanline_x1clip;
    int               scanline_x2clip;

				/* Saved values for DashedTwoPointLine */
    int               dashLen;
    CARD32            dashPattern;
    int               dash_fg;
    int               dash_bg;
d351 1
a351 1
    RADEONFBLayout    CurrentLayout;
a352 1
    Bool              noBackBuffer;
a370 3
    Bool              allowPageFlip;    /* Enable 3d page flipping */
    Bool              have3DWindows;    /* Are there any 3d clients? */
    int               drmMinor;
a376 1
    int               agpFastWrite;
a379 1
    Bool              CPRuns;           /* CP is running */
a380 1
    Bool              CPStarted;        /* CP has started */
d399 7
a405 7
    unsigned long     bufStart;         /* Offset into AGP space */
    drmHandle         bufHandle;        /* Handle from drmAddMap */
    drmSize           bufMapSize;       /* Size of map */
    int               bufSize;          /* Size of buffers (in MB) */
    unsigned char     *buf;             /* Map */
    int               bufNumBufs;       /* Number of buffers */
    drmBufMapPtr      buffers;          /* Buffer map */
a442 6
				/* offscreen memory management */
    int               backLines;
    FBAreaPtr         backArea;
    int               depthTexLines;
    FBAreaPtr         depthTexArea;

a453 2
    int               irq;

d455 1
a455 1
    int               perctx_sarea_size;
a458 1
				/* XVideo */
a460 1
    FBLinearPtr       videoLinear;
a461 2

				/* general */
a463 3
#ifdef XFree86LOADER
    XF86ModReqInfo    xaaReq;
#endif
d466 5
a470 5
#define RADEONWaitForFifo(pScrn, entries)				\
do {									\
    if (info->fifo_slots < entries)					\
	RADEONWaitForFifoFunction(pScrn, entries);			\
    info->fifo_slots -= entries;					\
d474 1
a474 7
extern void        RADEONWaitForIdleMMIO(ScrnInfoPtr pScrn);
#ifdef XF86DRI
extern void        RADEONWaitForIdleCP(ScrnInfoPtr pScrn);
#endif

extern void        RADEONDoAdjustFrame(ScrnInfoPtr pScrn, int x, int y,
				       int clone);
a481 1
extern void        RADEONWaitForVerticalSync2(ScrnInfoPtr pScrn);
a485 1
extern void        RADEONEngineInit(ScrnInfoPtr pScrn);
d491 1
a491 3
extern void        RADEONInitVideo(ScreenPtr pScreen);

extern void        R300CGWorkaround(ScrnInfoPtr pScrn);
d499 1
a499 1
extern void        RADEONCPFlushIndirect(ScrnInfoPtr pScrn, int discard);
a500 1
extern int         RADEONCPStop(ScrnInfoPtr pScrn,  RADEONInfoPtr info);
d505 1
a505 1
    int _ret = drmCommandNone(info->drmFD, DRM_RADEON_CP_START);	\
a509 1
    info->CPStarted = TRUE;                                             \
d514 3
a516 5
    int _ret;								\
     if (info->CPStarted) {						\
        _ret = RADEONCPStop(pScrn, info);				\
        if (_ret) {							\
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,			\
d518 1
a518 3
        }								\
        info->CPStarted = FALSE;                                        \
   }									\
a519 1
    info->CPRuns = FALSE;						\
d525 1
a525 1
	int _ret = drmCommandNone(info->drmFD, DRM_RADEON_CP_RESET);	\
d535 9
a543 9
    if (!info->CPInUse) {						\
	RADEON_WAIT_UNTIL_IDLE();					\
	BEGIN_RING(6);							\
	OUT_RING_REG(RADEON_RE_TOP_LEFT,     info->re_top_left);	\
	OUT_RING_REG(RADEON_RE_WIDTH_HEIGHT, info->re_width_height);	\
	OUT_RING_REG(RADEON_AUX_SC_CNTL,     info->aux_sc_cntl);	\
	ADVANCE_RING();							\
	info->CPInUse = TRUE;						\
    }									\
d547 1
a547 1
#define CP_PACKET0(reg, n)						\
d549 1
a549 1
#define CP_PACKET1(reg0, reg1)						\
d553 1
a553 1
#define CP_PACKET3(pkt, n)						\
d559 2
a560 1
#define RING_LOCALS	CARD32 *__head = NULL; int __count = 0
d562 13
a574 13
#define BEGIN_RING(n) do {						\
    if (RADEON_VERBOSE) {						\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
		   "BEGIN_RING(%d) in %s\n", n, __FUNCTION__);		\
    }									\
    if (!info->indirectBuffer) {					\
	info->indirectBuffer = RADEONCPGetBuffer(pScrn);		\
	info->indirectStart = 0;					\
    } else if (info->indirectBuffer->used + (n) * (int)sizeof(CARD32) >	\
	       info->indirectBuffer->total) {				\
	RADEONCPFlushIndirect(pScrn, 1);				\
    }									\
    __head = (pointer)((char *)info->indirectBuffer->address +		\
d576 1
a576 1
    __count = 0;							\
d580 10
a589 8
    if (RADEON_VERBOSE) {						\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
		   "ADVANCE_RING() start: %d used: %d count: %d\n",	\
		   info->indirectStart,					\
		   info->indirectBuffer->used,				\
		   __count * sizeof(CARD32));				\
    }									\
    info->indirectBuffer->used += __count * (int)sizeof(CARD32);	\
d592 6
a597 6
#define OUT_RING(x) do {						\
    if (RADEON_VERBOSE) {						\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
		   "   OUT_RING(0x%08x)\n", (unsigned int)(x));		\
    }									\
    __head[__count++] = (x);						\
d600 1
a600 1
#define OUT_RING_REG(reg, val)						\
d602 2
a603 2
    OUT_RING(CP_PACKET0(reg, 0));					\
    OUT_RING(val);							\
d608 6
a613 6
    if (RADEON_VERBOSE)							\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
		   "FLUSH_RING in %s\n", __FUNCTION__);			\
    if (info->indirectBuffer) {						\
	RADEONCPFlushIndirect(pScrn, 0);				\
    }									\
d619 5
a623 5
    BEGIN_RING(2);							\
    OUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));				\
    OUT_RING((RADEON_WAIT_2D_IDLECLEAN |				\
	      RADEON_WAIT_HOST_IDLECLEAN));				\
    ADVANCE_RING();							\
d628 5
a632 5
    BEGIN_RING(2);							\
    OUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));				\
    OUT_RING((RADEON_WAIT_3D_IDLECLEAN |				\
	      RADEON_WAIT_HOST_IDLECLEAN));				\
    ADVANCE_RING();							\
d637 7
a643 7
    if (RADEON_VERBOSE) {						\
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,				\
		   "WAIT_UNTIL_IDLE() in %s\n", __FUNCTION__);		\
    }									\
    BEGIN_RING(2);							\
    OUT_RING(CP_PACKET0(RADEON_WAIT_UNTIL, 0));				\
    OUT_RING((RADEON_WAIT_2D_IDLECLEAN |				\
d645 2
a646 2
	      RADEON_WAIT_HOST_IDLECLEAN));				\
    ADVANCE_RING();							\
d651 4
a654 4
    BEGIN_RING(2);							\
    OUT_RING(CP_PACKET0(RADEON_RB2D_DSTCACHE_CTLSTAT, 0));		\
    OUT_RING(RADEON_RB2D_DC_FLUSH);					\
    ADVANCE_RING();							\
d659 4
a662 4
    BEGIN_RING(2);							\
    OUT_RING(CP_PACKET0(RADEON_RB2D_DSTCACHE_CTLSTAT, 0));		\
    OUT_RING(RADEON_RB2D_DC_FLUSH_ALL);					\
    ADVANCE_RING();							\
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon.h,v 1.44 2003/11/10 18:41:21 tsi Exp $ */
d75 2
a76 2
#define RADEON_USE_RMX 0x80000000 /* mode flag for using RMX
				   * Need to comfirm this is not used
d97 14
d126 1
a126 1
    CARD32            bios_5_scratch;
a144 3
    CARD32            disp_merge_cntl;
    CARD32            grph_buffer_cntl;
    CARD32            crtc_more_cntl;
a151 2
    CARD32            disp2_merge_cntl;
    CARD32            grph2_buffer_cntl;
a173 1
    CARD32            tmds_transmitter_cntl;
d182 2
a183 2
    unsigned          ppll_ref_div;
    unsigned          ppll_div_3;
d248 2
d251 2
a252 2
    CHIP_FAMILY_RV100,
    CHIP_FAMILY_RS100,    /* U1 (IGP320M) or A3 (IGP320)*/
d254 1
a254 1
    CHIP_FAMILY_RS200,    /* U2 (IGP330M/340M/350M) or A4 (IGP330/340/345/350), RS250 (IGP 7000) */
d257 2
a258 6
    CHIP_FAMILY_RS300,    /* Radeon 9000 IGP */
    CHIP_FAMILY_RV280,
    CHIP_FAMILY_R300,
    CHIP_FAMILY_R350,
    CHIP_FAMILY_RV350,
    CHIP_FAMILY_LAST
a261 5
    CARD32 freq;
    CARD32 value;
}RADEONTMDSPll;

typedef struct {
a287 2
    Bool              IsMobility;       /* Mobile chips for laptops */
    Bool              IsIGP;            /* IGP chips */
d290 2
d302 1
a302 1
    Bool              ddc_mode;         /* Validate mode by matching exactly
d318 1
a318 4
    int               RefDivider;
    int               FeedbackDivider;
    int               PostDivider;
    Bool              UseBiosDividers;
d327 1
a327 6
    RADEONTMDSPll     tmds_pll[4];
    int               RamWidth;
    float	      sclk;		/* in MHz */
    float	      mclk;		/* in MHz */
    Bool	      IsDDR;
    int               DispPriority;
d423 1
a423 1
    drmSize           gartSize;
d425 1
a425 1
    unsigned long     gartOffset;
d440 1
a440 1
    unsigned long     ringStart;        /* Offset into GART space */
d447 1
a447 1
    unsigned long     ringReadOffset;   /* Offset into GART space */
d453 1
a453 1
    unsigned long     bufStart;         /* Offset into GART space */
d461 7
a467 7
				/* CP GART Texture data */
    unsigned long     gartTexStart;      /* Offset into GART space */
    drmHandle         gartTexHandle;     /* Handle from drmAddMap */
    drmSize           gartTexMapSize;    /* Size of map */
    int               gartTexSize;       /* Size of GART tex space (in MB) */
    unsigned char     *gartTex;          /* Map */
    int               log2GARTTexGran;
d569 1
a569 1
extern void        RADEONResetVideo(ScrnInfoPtr pScrn);
a574 1
extern void        RADEONDRIResume(ScreenPtr pScreen);
d670 1
a670 1
		   __count * (int)sizeof(CARD32));			\
@


1.1.1.4
log
@OpenBSD XF4 tree (minus old and mit) as of today
-> lib and fvwm fixes
@
text
@a287 1
    Bool	      IsIBook;		/* iBook tweaks */
@


