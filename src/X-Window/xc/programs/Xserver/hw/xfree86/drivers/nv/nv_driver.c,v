head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407221130:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	cvs-200311162121:1.1.1.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.07.20;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.07.20;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.36.30;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.18.35;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.23.35;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $XConsortium: nv_driver.c /main/3 1996/10/28 05:13:37 kaleb $ */
/*
 * Copyright 1996-1997  David J. McKay
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * DAVID J. MCKAY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/* Hacked together from mga driver and 3.3.4 NVIDIA driver by Jarno Paananen
   <jpaana@@s2.org> */

/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/nv_driver.c,v 1.81 2002/01/04 21:22:33 tsi Exp $ */

#include "nv_include.h"

/* Little hack to declare all the base pointers */
#define extern
#include "nvreg.h"
#undef extern
#include "nvvga.h"

#include "xf86int10.h"

/*
 * Forward definitions for the functions that make up the driver.
 */
/* Mandatory functions */
static const OptionInfoRec * NVAvailableOptions(int chipid, int busid);
static void    NVIdentify(int flags);
static Bool    NVProbe(DriverPtr drv, int flags);
static Bool    NVPreInit(ScrnInfoPtr pScrn, int flags);
static Bool    NVScreenInit(int Index, ScreenPtr pScreen, int argc,
                            char **argv);
static Bool    NVEnterVT(int scrnIndex, int flags);
static Bool    NVEnterVTFBDev(int scrnIndex, int flags);
static void    NVLeaveVT(int scrnIndex, int flags);
static Bool    NVCloseScreen(int scrnIndex, ScreenPtr pScreen);
static Bool    NVSaveScreen(ScreenPtr pScreen, int mode);

/* Optional functions */
static void    NVFreeScreen(int scrnIndex, int flags);
static int     NVValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose,
                           int flags);

/* Internally used functions */

static Bool	NVMapMem(ScrnInfoPtr pScrn);
static Bool	NVMapMemFBDev(ScrnInfoPtr pScrn);
static Bool	NVUnmapMem(ScrnInfoPtr pScrn);
static void	NVSave(ScrnInfoPtr pScrn);
static void	NVRestore(ScrnInfoPtr pScrn);
static Bool	NVModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode);


/*
 * This contains the functions needed by the server after loading the
 * driver module.  It must be supplied, and gets added the driver list by
 * the Module Setup funtion in the dynamic case.  In the static case a
 * reference to this is compiled in, and this requires that the name of
 * this DriverRec be an upper-case version of the driver name.
 */

DriverRec NV = {
        VERSION,
	NV_DRIVER_NAME,
        NVIdentify,
        NVProbe,
	NVAvailableOptions,
        NULL,
        0
};

/* Supported chipsets */
static SymTabRec NVChipsets[] = {
    { NV_CHIP_RIVA128,    "RIVA128" },
    { NV_CHIP_TNT,        "RIVA TNT" },
    { NV_CHIP_TNT2,       "RIVA TNT2" },
    { NV_CHIP_UTNT2,      "RIVA TNT2 Ultra" },
    { NV_CHIP_VTNT2,      "Vanta" },
    { NV_CHIP_UVTNT2,     "RIVA TNT2 M64" },
    { NV_CHIP_ITNT2,      "Aladdin TNT2" },
    { NV_CHIP_GEFORCE256, "GeForce 256" },
    { NV_CHIP_GEFORCEDDR, "GeForce DDR" },
    { NV_CHIP_QUADRO,     "Quadro" },
    { NV_CHIP_GEFORCE2GTS,  "GeForce2 GTS/Pro"},
    { NV_CHIP_GEFORCE2GTS_1,"GeForce2 Ti"},
    { NV_CHIP_GEFORCE2ULTRA,"GeForce2 Ultra"},
    { NV_CHIP_QUADRO2PRO,   "Quadro2 Pro"},
    { NV_CHIP_GEFORCE2MX,   "GeForce2 MX/MX 400"},
    { NV_CHIP_GEFORCE2MXDDR, "GeForce2 MX 100/200"},
    { NV_CHIP_0x0170,      "0x0170" },
    { NV_CHIP_0x0171,      "0x0171" },
    { NV_CHIP_0x0172,      "0x0172" },
    { NV_CHIP_0x0173,      "0x0173" },
    { NV_CHIP_0x0174,      "0x0174" },
    { NV_CHIP_0x0175,      "0x0175" },
    { NV_CHIP_0x0178,      "0x0178" },
    { NV_CHIP_0x017A,      "0x017A" },
    { NV_CHIP_0x017B,      "0x017B" },
    { NV_CHIP_0x017C,      "0x017C" },
    { NV_CHIP_IGEFORCE2,    "GeForce2 Integrated"},
    { NV_CHIP_QUADRO2MXR,   "Quadro2 MXR"},
    { NV_CHIP_GEFORCE2GO,   "GeForce2 Go"},
    { NV_CHIP_GEFORCE3,     "GeForce3"},
    { NV_CHIP_GEFORCE3_1,   "GeForce3 Ti 200"},
    { NV_CHIP_GEFORCE3_2,   "GeForce3 Ti 500"},
    { NV_CHIP_QUADRO_DDC,   "Quadro DDC"},
    { NV_CHIP_0x0250,       "0x0250"},
    { NV_CHIP_0x0258,       "0x0258"},
    {-1,                        NULL }
};

static PciChipsets NVPciChipsets[] = {
    { NV_CHIP_RIVA128,          NV_CHIP_RIVA128,        RES_SHARED_VGA },
    { NV_CHIP_TNT,              NV_CHIP_TNT,            RES_SHARED_VGA },
    { NV_CHIP_TNT2,             NV_CHIP_TNT2,           RES_SHARED_VGA },
    { NV_CHIP_UTNT2,            NV_CHIP_UTNT2,          RES_SHARED_VGA },
    { NV_CHIP_VTNT2,            NV_CHIP_VTNT2,          RES_SHARED_VGA },
    { NV_CHIP_UVTNT2,           NV_CHIP_UVTNT2,         RES_SHARED_VGA },
    { NV_CHIP_ITNT2,            NV_CHIP_ITNT2,          RES_SHARED_VGA },
    { NV_CHIP_GEFORCE256,       NV_CHIP_GEFORCE256,     RES_SHARED_VGA },
    { NV_CHIP_GEFORCEDDR,       NV_CHIP_GEFORCEDDR,     RES_SHARED_VGA },
    { NV_CHIP_QUADRO,           NV_CHIP_QUADRO,         RES_SHARED_VGA },
    { NV_CHIP_GEFORCE2GTS,      NV_CHIP_GEFORCE2GTS,    RES_SHARED_VGA },
    { NV_CHIP_GEFORCE2GTS_1,    NV_CHIP_GEFORCE2GTS_1,  RES_SHARED_VGA },
    { NV_CHIP_GEFORCE2ULTRA,    NV_CHIP_GEFORCE2ULTRA,  RES_SHARED_VGA },
    { NV_CHIP_QUADRO2PRO,       NV_CHIP_QUADRO2PRO,     RES_SHARED_VGA },
    { NV_CHIP_GEFORCE2MX,       NV_CHIP_GEFORCE2MX,     RES_SHARED_VGA },
    { NV_CHIP_GEFORCE2MXDDR,    NV_CHIP_GEFORCE2MXDDR,  RES_SHARED_VGA },
    { NV_CHIP_0x0170,           NV_CHIP_0x0170,         RES_SHARED_VGA },
    { NV_CHIP_0x0171,           NV_CHIP_0x0171,         RES_SHARED_VGA },
    { NV_CHIP_0x0172,           NV_CHIP_0x0172,         RES_SHARED_VGA },
    { NV_CHIP_0x0173,           NV_CHIP_0x0173,         RES_SHARED_VGA },
    { NV_CHIP_0x0174,           NV_CHIP_0x0174,         RES_SHARED_VGA },
    { NV_CHIP_0x0175,           NV_CHIP_0x0175,         RES_SHARED_VGA },
    { NV_CHIP_0x0178,           NV_CHIP_0x0178,         RES_SHARED_VGA },
    { NV_CHIP_0x017A,           NV_CHIP_0x017A,         RES_SHARED_VGA },
    { NV_CHIP_0x017B,           NV_CHIP_0x017B,         RES_SHARED_VGA },
    { NV_CHIP_0x017C,           NV_CHIP_0x017C,         RES_SHARED_VGA },
    { NV_CHIP_IGEFORCE2,        NV_CHIP_IGEFORCE2,      RES_SHARED_VGA },
    { NV_CHIP_QUADRO2MXR,       NV_CHIP_QUADRO2MXR,     RES_SHARED_VGA },
    { NV_CHIP_GEFORCE2GO,       NV_CHIP_GEFORCE2GO,     RES_SHARED_VGA },
    { NV_CHIP_GEFORCE3,         NV_CHIP_GEFORCE3,       RES_SHARED_VGA },
    { NV_CHIP_GEFORCE3_1,       NV_CHIP_GEFORCE3_1,     RES_SHARED_VGA },
    { NV_CHIP_GEFORCE3_2,       NV_CHIP_GEFORCE3_2,     RES_SHARED_VGA },
    { NV_CHIP_QUADRO_DDC,       NV_CHIP_QUADRO_DDC,     RES_SHARED_VGA },
    { NV_CHIP_0x0250,           NV_CHIP_0x0250,         RES_SHARED_VGA },
    { NV_CHIP_0x0258,           NV_CHIP_0x0258,         RES_SHARED_VGA },
    { -1,                       -1,                     RES_UNDEFINED  }
};

/*
 * List of symbols from other modules that this module references.  This
 * list is used to tell the loader that it is OK for symbols here to be
 * unresolved providing that it hasn't been told that they haven't been
 * told that they are essential via a call to xf86LoaderReqSymbols() or
 * xf86LoaderReqSymLists().  The purpose is this is to avoid warnings about
 * unresolved symbols that are not required.
 */

static const char *vgahwSymbols[] = {
    "vgaHWDPMSSet",
    "vgaHWFreeHWRec",
    "vgaHWGetHWRec",
    "vgaHWGetIndex",
    "vgaHWInit",
    "vgaHWLock",
    "vgaHWMapMem",
    "vgaHWProtect",
    "vgaHWRestore",
    "vgaHWSave",
    "vgaHWSaveScreen",
    "vgaHWUnlock",
    "vgaHWddc1SetSpeed",
    NULL
};

static const char *fbSymbols[] = {
    "fbPictureInit",
    "fbScreenInit",
    NULL
};

static const char *xaaSymbols[] = {
    "XAACopyROP",
    "XAACreateInfoRec",
    "XAADestroyInfoRec",
    "XAAFallbackOps",
    "XAAInit",
    "XAAPatternROP",
    NULL
};

static const char *ramdacSymbols[] = {
    "xf86CreateCursorInfoRec",
    "xf86DestroyCursorInfoRec",
    "xf86InitCursor",
    NULL
};

#define NVuseI2C 1

static const char *ddcSymbols[] = {
    "xf86PrintEDID",
    "xf86DoEDID_DDC1",
#if NVuseI2C
    "xf86DoEDID_DDC2",
#endif
    "xf86SetDDCproperties",
    NULL
};

static const char *vbeSymbols[] = {
    "VBEInit",
    "vbeDoEDID",
    "vbeFree",
    NULL
};

static const char *i2cSymbols[] = {
    "xf86CreateI2CBusRec",
    "xf86I2CBusInit",
    NULL
};

static const char *shadowSymbols[] = {
    "ShadowFBInit",
    NULL
};

static const char *fbdevHWSymbols[] = {
    "fbdevHWInit",
    "fbdevHWUseBuildinMode",

    "fbdevHWGetVidmem",

    /* colormap */
    "fbdevHWLoadPalette",

    /* ScrnInfo hooks */
    "fbdevHWAdjustFrame",
    "fbdevHWEnterVT",
    "fbdevHWLeaveVT",
    "fbdevHWModeInit",
    "fbdevHWSave",
    "fbdevHWSwitchMode",
    "fbdevHWValidMode",

    "fbdevHWMapMMIO",
    "fbdevHWMapVidmem",

    NULL
};

static const char *int10Symbols[] = {
    "xf86FreeInt10",
    "xf86InitInt10",
    NULL
};


#ifdef XFree86LOADER

static MODULESETUPPROTO(nvSetup);

static XF86ModuleVersionInfo nvVersRec =
{
    "nv",
    MODULEVENDORSTRING,
    MODINFOSTRING1,
    MODINFOSTRING2,
    XF86_VERSION_CURRENT,
    NV_MAJOR_VERSION, NV_MINOR_VERSION, NV_PATCHLEVEL,
    ABI_CLASS_VIDEODRV,                     /* This is a video driver */
    ABI_VIDEODRV_VERSION,
    MOD_CLASS_VIDEODRV,
    {0,0,0,0}
};

XF86ModuleData nvModuleData = { &nvVersRec, nvSetup, NULL };
#endif


typedef enum {
    OPTION_SW_CURSOR,
    OPTION_HW_CURSOR,
    OPTION_NOACCEL,
    OPTION_SHOWCACHE,
    OPTION_SHADOW_FB,
    OPTION_FBDEV,
    OPTION_ROTATE,
    OPTION_VIDEO_KEY,
    OPTION_FLAT_PANEL
} NVOpts;


static const OptionInfoRec NVOptions[] = {
    { OPTION_SW_CURSOR,         "SWcursor",     OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_HW_CURSOR,         "HWcursor",     OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_NOACCEL,           "NoAccel",      OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_SHOWCACHE,         "ShowCache",    OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_SHADOW_FB,         "ShadowFB",     OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_FBDEV,             "UseFBDev",     OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_ROTATE,		"Rotate",	OPTV_ANYSTR,	{0}, FALSE },
    { OPTION_VIDEO_KEY,		"VideoKey",	OPTV_INTEGER,	{0}, FALSE },
    { OPTION_FLAT_PANEL,	"FlatPanel",	OPTV_BOOLEAN,	{0}, FALSE },
    { -1,                       NULL,           OPTV_NONE,      {0}, FALSE }
};

/*
 * This is intentionally screen-independent.  It indicates the binding
 * choice made in the first PreInit.
 */
static int pix24bpp = 0;

/* 
 * ramdac info structure initialization
 */
static NVRamdacRec DacInit = {
        FALSE, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL,
        0, NULL, NULL, NULL, NULL, NULL
}; 



static Bool
NVGetRec(ScrnInfoPtr pScrn)
{
    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "NVGetRec\n"));
    /*
     * Allocate an NVRec, and hook it into pScrn->driverPrivate.
     * pScrn->driverPrivate is initialised to NULL, so we can check if
     * the allocation has already been done.
     */
    if (pScrn->driverPrivate != NULL)
        return TRUE;

    pScrn->driverPrivate = xnfcalloc(sizeof(NVRec), 1);
    /* Initialise it */

    NVPTR(pScrn)->Dac = DacInit;
    return TRUE;
}

static void
NVFreeRec(ScrnInfoPtr pScrn)
{
    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "NVFreeRec\n"));
    
    if (pScrn->driverPrivate == NULL)
        return;
    xfree(pScrn->driverPrivate);
    pScrn->driverPrivate = NULL;
}


#ifdef XFree86LOADER

static pointer
nvSetup(pointer module, pointer opts, int *errmaj, int *errmin)
{
    static Bool setupDone = FALSE;

    /* This module should be loaded only once, but check to be sure. */

    if (!setupDone) {
        setupDone = TRUE;
        xf86AddDriver(&NV, module, 0);

        /*
         * Modules that this driver always requires may be loaded here
         * by calling LoadSubModule().
         */

        /*
         * Tell the loader about symbols from other modules that this module
         * might refer to.
         */
        LoaderRefSymLists(vgahwSymbols, xaaSymbols, fbSymbols,
                          ramdacSymbols, shadowSymbols,
                          i2cSymbols, ddcSymbols, vbeSymbols,
                          fbdevHWSymbols, int10Symbols, NULL);

        /*
         * The return value must be non-NULL on success even though there
         * is no TearDownProc.
         */
        return (pointer)1;
    } else {
        if (errmaj) *errmaj = LDR_ONCEONLY;
        return NULL;
    }
}


#endif /* XFree86LOADER */

static const OptionInfoRec *
NVAvailableOptions(int chipid, int busid)
{
    return NVOptions;
}

/* Mandatory */
static void
NVIdentify(int flags)
{
    xf86PrintChipsets(NV_NAME, "driver for NVIDIA chipsets", NVChipsets);
}


/* Mandatory */
static Bool
NVProbe(DriverPtr drv, int flags)
{
    int i;
    GDevPtr *devSections;
    int *usedChips;
    int numDevSections;
    int numUsed;
    Bool foundScreen = FALSE;

    /*
     * The aim here is to find all cards that this driver can handle,
     * and for the ones not already claimed by another driver, claim the
     * slot, and allocate a ScrnInfoRec.
     *
     * This should be a minimal probe, and it should under no circumstances
     * change the state of the hardware.  Because a device is found, don't
     * assume that it will be used.  Don't do any initialisations other than
     * the required ScrnInfoRec initialisations.  Don't allocate any new
     * data structures.
     */

    /*
     * Check if there has been a chipset override in the config file.
     * For this we must find out if there is an active device section which
     * is relevant, i.e., which has no driver specified or has THIS driver
     * specified.
     */

    if ((numDevSections = xf86MatchDevice(NV_DRIVER_NAME,
                                          &devSections)) <= 0) {
        /*
         * There's no matching device section in the config file, so quit
         * now.
         */
        return FALSE;
    }

    /*
     * We need to probe the hardware first.  We then need to see how this
     * fits in with what is given in the config file, and allow the config
     * file info to override any contradictions.
     */

    /*
     * All of the cards this driver supports are PCI, so the "probing" just
     * amounts to checking the PCI data that the server has already collected.
     */
    if (xf86GetPciVideoInfo() == NULL) {
        /*
         * We won't let anything in the config file override finding no
         * PCI video cards at all.  This seems reasonable now, but we'll see.
         */
        return FALSE;
    }

    /* This should match both vendors, PCI_VENDOR_NVIDIA_SGS and
       PCI_VENDOR_NVIDIA, see above */
    numUsed = xf86MatchPciInstances(NV_NAME, 0, NVChipsets, NVPciChipsets,
                                    devSections, numDevSections, drv,
                                    &usedChips);
                        
    /* Free it since we don't need that list after this */
    xfree(devSections);
    if (numUsed <= 0)
        return FALSE;

    if (flags & PROBE_DETECT)
	foundScreen = TRUE;
    else for (i = 0; i < numUsed; i++) {
        ScrnInfoPtr pScrn = NULL;
        
        /* Allocate a ScrnInfoRec and claim the slot */
        if ((pScrn = xf86ConfigPciEntity(pScrn, 0,usedChips[i],
					       NVPciChipsets, NULL, NULL, NULL,
					       NULL, NULL))) {
        
	    /* Fill in what we can of the ScrnInfoRec */
	    pScrn->driverVersion    = VERSION;
	    pScrn->driverName       = NV_DRIVER_NAME;
	    pScrn->name             = NV_NAME;
	    pScrn->Probe            = NVProbe;
	    pScrn->PreInit          = NVPreInit;
	    pScrn->ScreenInit       = NVScreenInit;
	    pScrn->SwitchMode       = NVSwitchMode;
	    pScrn->AdjustFrame      = NVAdjustFrame;
	    pScrn->EnterVT          = NVEnterVT;
	    pScrn->LeaveVT          = NVLeaveVT;
	    pScrn->FreeScreen       = NVFreeScreen;
	    pScrn->ValidMode        = NVValidMode;
	    foundScreen = TRUE;
	}    
    }
    xfree(usedChips);
    return foundScreen;
}

/* Usually mandatory */
Bool
NVSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
{
    DEBUG(xf86DrvMsg(scrnIndex, X_INFO, "NVSwitchMode\n"));
    return NVModeInit(xf86Screens[scrnIndex], mode);
}

/*
 * This function is used to initialize the Start Address - the first
 * displayed location in the video memory.
 */
/* Usually mandatory */
void 
NVAdjustFrame(int scrnIndex, int x, int y, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    int startAddr;
    NVPtr pNv = NVPTR(pScrn);
    NVFBLayout *pLayout = &pNv->CurrentLayout;

    DEBUG(xf86DrvMsg(scrnIndex, X_INFO, "NVAdjustFrame\n"));

    if(pNv->ShowCache && y && pScrn->vtSema) 
	y += pScrn->virtualY - 1;	

    startAddr = (((y*pLayout->displayWidth)+x)*(pLayout->bitsPerPixel/8));
    pNv->riva.SetStartAddress(&pNv->riva, startAddr);
}


/*
 * This is called when VT switching back to the X server.  Its job is
 * to reinitialise the video mode.
 *
 * We may wish to unmap video/MMIO memory too.
 */

/* Mandatory */
static Bool
NVEnterVT(int scrnIndex, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    NVPtr pNv = NVPTR(pScrn);
    vgaHWPtr hwp = VGAHWPTR(pScrn);

    DEBUG(xf86DrvMsg(scrnIndex, X_INFO, "NVEnterVT\n"));

    vgaHWUnlock(hwp);
    pNv->riva.LockUnlock(&pNv->riva, 0);
    if (!NVModeInit(pScrn, pScrn->currentMode))
        return FALSE;
    NVAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
    return TRUE;
}

static Bool
NVEnterVTFBDev(int scrnIndex, int flags)
{
    DEBUG(xf86DrvMsg(scrnIndex, X_INFO, "NVEnterVTFBDev\n"));

    fbdevHWEnterVT(scrnIndex,flags);
    return TRUE;
}

/*
 * This is called when VT switching away from the X server.  Its job is
 * to restore the previous (text) mode.
 *
 * We may wish to remap video/MMIO memory too.
 */

/* Mandatory */
static void
NVLeaveVT(int scrnIndex, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    NVPtr pNv = NVPTR(pScrn);
    vgaHWPtr hwp = VGAHWPTR(pScrn);

    DEBUG(xf86DrvMsg(scrnIndex, X_INFO, "NVLeaveVT\n"));

    NVRestore(pScrn);
    pNv->riva.LockUnlock(&pNv->riva, 1);
    vgaHWLock(hwp);
}



static void 
NVBlockHandler (
    int i, 
    pointer blockData, 
    pointer pTimeout,
    pointer pReadmask
)
{
    ScreenPtr     pScreen = screenInfo.screens[i];
    ScrnInfoPtr   pScrnInfo = xf86Screens[i];
    NVPtr         pNv = NVPTR(pScrnInfo);
    
    pScreen->BlockHandler = pNv->BlockHandler;
    (*pScreen->BlockHandler) (i, blockData, pTimeout, pReadmask);
    pScreen->BlockHandler = NVBlockHandler;

    if (pNv->VideoTimerCallback) 
        (*pNv->VideoTimerCallback)(pScrnInfo, currentTime.milliseconds);

}


/*
 * This is called at the end of each server generation.  It restores the
 * original (text) mode.  It should also unmap the video memory, and free
 * any per-generation data allocated by the driver.  It should finish
 * by unwrapping and calling the saved CloseScreen function.
 */

/* Mandatory */
static Bool
NVCloseScreen(int scrnIndex, ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    vgaHWPtr hwp = VGAHWPTR(pScrn);
    NVPtr pNv = NVPTR(pScrn);

    DEBUG(xf86DrvMsg(scrnIndex, X_INFO, "NVCloseScreen\n"));

    if (pScrn->vtSema) {
        NVRestore(pScrn);
        pNv->riva.LockUnlock(&pNv->riva, 1);
        vgaHWLock(hwp);
    }

    NVUnmapMem(pScrn);
    vgaHWUnmapMem(pScrn);
    if (pNv->AccelInfoRec)
        XAADestroyInfoRec(pNv->AccelInfoRec);
    if (pNv->CursorInfoRec)
        xf86DestroyCursorInfoRec(pNv->CursorInfoRec);
    if (pNv->ShadowPtr)
        xfree(pNv->ShadowPtr);
    if (pNv->DGAModes)
        xfree(pNv->DGAModes);
    if ( pNv->expandBuffer )
        xfree(pNv->expandBuffer);
    if (pNv->overlayAdaptor)
	xfree(pNv->overlayAdaptor);

    pScrn->vtSema = FALSE;
    pScreen->CloseScreen = pNv->CloseScreen;
    pScreen->BlockHandler = pNv->BlockHandler;
    return (*pScreen->CloseScreen)(scrnIndex, pScreen);
}

/* Free up any persistent data structures */

/* Optional */
static void
NVFreeScreen(int scrnIndex, int flags)
{
    DEBUG(xf86DrvMsg(scrnIndex, X_INFO, "NVFreeScreen\n"));
    /*
     * This only gets called when a screen is being deleted.  It does not
     * get called routinely at the end of a server generation.
     */
    if (xf86LoaderCheckSymbol("vgaHWFreeHWRec"))
	vgaHWFreeHWRec(xf86Screens[scrnIndex]);
    NVFreeRec(xf86Screens[scrnIndex]);
}


/* Checks if a mode is suitable for the selected chipset. */

/* Optional */
static int
NVValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
{
    DEBUG(xf86DrvMsg(scrnIndex, X_INFO, "NVValidMode\n"));
    /* HACK HACK HACK */
    return (MODE_OK);
}

static xf86MonPtr
nvDoDDC2(ScrnInfoPtr pScrn)
{
    NVPtr pNv = NVPTR(pScrn);
    xf86MonPtr MonInfo = NULL;

    if (!pNv->i2cInit) return NULL;

    /* - DDC can use I2C bus */
    /* Load I2C if we have the code to use it */
    if ( xf86LoadSubModule(pScrn, "i2c") ) {
        xf86LoaderReqSymLists(i2cSymbols,NULL);
        if (pNv->i2cInit(pScrn)) {
	    DEBUG(ErrorF("I2C initialized on %p\n",pNv->I2C));
	    if ((MonInfo = xf86DoEDID_DDC2(pScrn->scrnIndex,pNv->I2C))) {  
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "DDC Monitor info: %p\n",
			   MonInfo);
		xf86PrintEDID( MonInfo );
		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "end of DDC Monitor "
			   "info\n\n");
		xf86SetDDCproperties(pScrn,MonInfo);
	    }
	}
    }
    return MonInfo;
}

static xf86MonPtr
nvDoDDC1(ScrnInfoPtr pScrn)
{
    NVPtr pNv = NVPTR(pScrn);
    xf86MonPtr MonInfo = NULL;

    if (!pNv->ddc1Read || !pNv->DDC1SetSpeed) return NULL;
    if (!pNv->Primary 
	&& (pNv->DDC1SetSpeed == vgaHWddc1SetSpeed)) return NULL;

    if ((MonInfo = xf86DoEDID_DDC1(pScrn->scrnIndex, pNv->DDC1SetSpeed,
				  pNv->ddc1Read ))) {
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "DDC Monitor info: %p\n",
		   MonInfo);
	xf86PrintEDID( MonInfo );
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "end of DDC Monitor info\n\n");
	xf86SetDDCproperties(pScrn,MonInfo);
    }
    return MonInfo;
}
 
static xf86MonPtr
nvDoDDCVBE(ScrnInfoPtr pScrn)
{
    NVPtr pNv = NVPTR(pScrn);
    xf86MonPtr MonInfo = NULL;
    vbeInfoPtr pVbe;

    if (xf86LoadSubModule(pScrn, "vbe")) {
        xf86LoaderReqSymLists(vbeSymbols,NULL);
	pVbe = VBEInit(pNv->pInt,pNv->pEnt->index);
	if (pVbe) {
	    if ((MonInfo = vbeDoEDID(pVbe,NULL))) {
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "DDC Monitor info: %p\n",
 			   MonInfo);
 		xf86PrintEDID( MonInfo );       
 		xf86DrvMsg(pScrn->scrnIndex, X_INFO, "end of DDC Monitor info\n\n");
 		xf86SetDDCproperties(pScrn,MonInfo);
 	    }
 	    vbeFree(pVbe);
 	}
     }
     return MonInfo;
}
 

/* Internally used */
static xf86MonPtr
NVdoDDC(ScrnInfoPtr pScrn)
{
    vgaHWPtr hwp;
    NVPtr pNv;
    NVRamdacPtr NVdac;
    xf86MonPtr MonInfo = NULL;

    hwp = VGAHWPTR(pScrn);
    pNv = NVPTR(pScrn);
    NVdac = &pNv->Dac;

    /* Load DDC if we have the code to use it */

    if (!xf86LoadSubModule(pScrn, "ddc")) return NULL;
    
    xf86LoaderReqSymLists(ddcSymbols, NULL);

    /*    if ((MonInfo = nvDoDDCVBE(pScrn))) return MonInfo;      */

    /* Enable access to extended registers */
    vgaHWUnlock(hwp);
    pNv->riva.LockUnlock(&pNv->riva, 0);
    /* Save the current state */
    NVSave(pScrn);

    if ((MonInfo = nvDoDDC2(pScrn))) goto done;
#if 0 /* disable for now - causes problems on AXP */
    if ((MonInfo = nvDoDDC1(pScrn))) goto done;
#endif

 done:
    /* Restore previous state */
    NVRestore(pScrn);
    pNv->riva.LockUnlock(&pNv->riva, 1);
    vgaHWLock(hwp);

    return MonInfo;
}

static void
nvProbeDDC(ScrnInfoPtr pScrn, int index)
{
    vbeInfoPtr pVbe;

    if (xf86LoadSubModule(pScrn, "vbe")) {
        pVbe = VBEInit(NULL,index);
        ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
	vbeFree(pVbe);
    }
}

/* Mandatory */
Bool
NVPreInit(ScrnInfoPtr pScrn, int flags)
{
    NVPtr pNv;
    MessageType from;
    int i;
    int bytesPerPixel;
    ClockRangePtr clockRanges;
    const char *s;

    if (flags & PROBE_DETECT) {
        nvProbeDDC( pScrn, xf86GetEntityInfo(pScrn->entityList[0])->index );
	return TRUE;
    }


    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "NVPreInit\n"));
    /*
     * Note: This function is only called once at server startup, and
     * not at the start of each server generation.  This means that
     * only things that are persistent across server generations can
     * be initialised here.  xf86Screens[] is (pScrn is a pointer to one
     * of these).  Privates allocated using xf86AllocateScrnInfoPrivateIndex()  
     * are too, and should be used for data that must persist across
     * server generations.
     *
     * Per-generation data should be allocated with
     * AllocateScreenPrivateIndex() from the ScreenInit() function.
     */

    /* Check the number of entities, and fail if it isn't one. */
    if (pScrn->numEntities != 1)
	return FALSE;

    /* Allocate the NVRec driverPrivate */
    if (!NVGetRec(pScrn)) {
	return FALSE;
    }
    pNv = NVPTR(pScrn);

    /* Get the entity, and make sure it is PCI. */
    pNv->pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
    if (pNv->pEnt->location.type != BUS_PCI)
	return FALSE;
 
    /* Find the PCI info for this screen */
    pNv->PciInfo = xf86GetPciInfoForEntity(pNv->pEnt->index);
    pNv->PciTag = pciTag(pNv->PciInfo->bus, pNv->PciInfo->device,
			  pNv->PciInfo->func);

    pNv->Primary = xf86IsPrimaryPci(pNv->PciInfo);

    /* Initialize the card through int10 interface if needed */
    if (xf86LoadSubModule(pScrn, "int10")){
 	xf86LoaderReqSymLists(int10Symbols, NULL);
#if !defined(__alpha__) && !defined(__powerpc__)
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Initializing int10\n");
        pNv->pInt = xf86InitInt10(pNv->pEnt->index);
#endif
     }
   
    {
        resRange vgaio[] =      { {ResShrIoBlock,0x3B0,0x3BB},
                                  {ResShrIoBlock,0x3C0,0x3DF},
                                  _END };
 	resRange vgamem[] =	{ {ResShrMemBlock,0xA0000,0xAFFFF},
 				  {ResShrMemBlock,0xB8000,0xBFFFF},
                                  {ResShrMemBlock,0xB0000,0xB7FFF},
 				  _END };
        xf86SetOperatingState(vgaio, pNv->pEnt->index, ResUnusedOpr);
 	xf86SetOperatingState(vgamem, pNv->pEnt->index, ResDisableOpr);
    }

    /* Set pScrn->monitor */
    pScrn->monitor = pScrn->confScreen->monitor;

    /*
     * Set the Chipset and ChipRev, allowing config file entries to
     * override.
     */
    if (pNv->pEnt->device->chipset && *pNv->pEnt->device->chipset) {
	pScrn->chipset = pNv->pEnt->device->chipset;
        pNv->Chipset = xf86StringToToken(NVChipsets, pScrn->chipset);
        from = X_CONFIG;
    } else if (pNv->pEnt->device->chipID >= 0) {
	pNv->Chipset = pNv->pEnt->device->chipID;
	pScrn->chipset = (char *)xf86TokenToString(NVChipsets, pNv->Chipset);
	from = X_CONFIG;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
		   pNv->Chipset);
    } else {
	from = X_PROBED;
	pNv->Chipset = (pNv->PciInfo->vendor << 16) |pNv->PciInfo->chipType;
	pScrn->chipset = (char *)xf86TokenToString(NVChipsets, pNv->Chipset);
    }
    if (pNv->pEnt->device->chipRev >= 0) {
	pNv->ChipRev = pNv->pEnt->device->chipRev;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
		   pNv->ChipRev);
    } else {
	pNv->ChipRev = pNv->PciInfo->chipRev;
    }

    /*
     * This shouldn't happen because such problems should be caught in
     * NVProbe(), but check it just in case.
     */
    if (pScrn->chipset == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "ChipID 0x%04X is not recognised\n", pNv->Chipset);
	xf86FreeInt10(pNv->pInt);
	return FALSE;
    }
    if (pNv->Chipset < 0) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Chipset \"%s\" is not recognised\n", pScrn->chipset);
	xf86FreeInt10(pNv->pInt);
	return FALSE;
    }

    xf86DrvMsg(pScrn->scrnIndex, from, "Chipset: \"%s\"\n", pScrn->chipset);


    /*
     * The first thing we should figure out is the depth, bpp, etc.
     * Our default depth is 8, so pass it to the helper function.
     */

    if (!xf86SetDepthBpp(pScrn, 8, 8, 8, Support32bppFb)) {
	xf86FreeInt10(pNv->pInt);
	return FALSE;
    } else {
	/* Check that the returned depth is one we support */
	switch (pScrn->depth) {
            case 8:
            case 15:
            case 24:
                /* OK */
                break;
            case 16:
                if(pNv->Chipset == NV_CHIP_RIVA128) {
                    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                        "The Riva 128 chipset does not support depth 16.  "
			"Using depth 15 instead\n");
                    pScrn->depth = 15;
                }
                break;
            default:
                xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                    "Given depth (%d) is not supported by this driver\n",
                    pScrn->depth);
		xf86FreeInt10(pNv->pInt);
                return FALSE;
	}
    }
    xf86PrintDepthBpp(pScrn);

    /* Get the depth24 pixmap format */
    if (pScrn->depth == 24 && pix24bpp == 0)
	pix24bpp = xf86GetBppFromDepth(pScrn, 24);

    /*
     * This must happen after pScrn->display has been set because
     * xf86SetWeight references it.
     */
    if (pScrn->depth > 8) {
	/* The defaults are OK for us */
	rgb zeros = {0, 0, 0};

	if (!xf86SetWeight(pScrn, zeros, zeros)) {
	    xf86FreeInt10(pNv->pInt);
	    return FALSE;
	}
    }

    if (!xf86SetDefaultVisual(pScrn, -1)) {
	xf86FreeInt10(pNv->pInt);
	return FALSE;
    } else {
	/* We don't currently support DirectColor at > 8bpp */
	if (pScrn->depth > 8 && (pScrn->defaultVisual != TrueColor)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Given default visual"
		       " (%s) is not supported at depth %d\n",
		       xf86GetVisualName(pScrn->defaultVisual), pScrn->depth);
	    xf86FreeInt10(pNv->pInt);
	    return FALSE;
	}
    }

    bytesPerPixel = pScrn->bitsPerPixel / 8;

    /* The vgahw module should be loaded here when needed */
    if (!xf86LoadSubModule(pScrn, "vgahw")) {
	xf86FreeInt10(pNv->pInt);
	return FALSE;
    }
    
    xf86LoaderReqSymLists(vgahwSymbols, NULL);

    /*
     * Allocate a vgaHWRec
     */
    if (!vgaHWGetHWRec(pScrn)) {
	xf86FreeInt10(pNv->pInt);
	return FALSE;
    }
    
    /* We use a programmable clock */
    pScrn->progClock = TRUE;

    /* Collect all of the relevant option flags (fill in pScrn->options) */
    xf86CollectOptions(pScrn, NULL);

    /* Process the options */
    if (!(pNv->Options = xalloc(sizeof(NVOptions))))
	return FALSE;
    memcpy(pNv->Options, NVOptions, sizeof(NVOptions));
    xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pNv->Options);

    /* Set the bits per RGB for 8bpp mode */
    if (pScrn->depth == 8)
	pScrn->rgbBits = 8;

    from = X_DEFAULT;
    pNv->HWCursor = TRUE;
    /*
     * The preferred method is to use the "hw cursor" option as a tri-state
     * option, with the default set above.
     */
    if (xf86GetOptValBool(pNv->Options, OPTION_HW_CURSOR, &pNv->HWCursor)) {
	from = X_CONFIG;
    }
    /* For compatibility, accept this too (as an override) */
    if (xf86ReturnOptValBool(pNv->Options, OPTION_SW_CURSOR, FALSE)) {
	from = X_CONFIG;
	pNv->HWCursor = FALSE;
    }
    xf86DrvMsg(pScrn->scrnIndex, from, "Using %s cursor\n",
		pNv->HWCursor ? "HW" : "SW");
    if (xf86ReturnOptValBool(pNv->Options, OPTION_NOACCEL, FALSE)) {
	pNv->NoAccel = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Acceleration disabled\n");
    }
    if (xf86ReturnOptValBool(pNv->Options, OPTION_SHOWCACHE, FALSE)) {
	pNv->ShowCache = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ShowCache enabled\n");
    }
    if (xf86ReturnOptValBool(pNv->Options, OPTION_SHADOW_FB, FALSE)) {
	pNv->ShadowFB = TRUE;
	pNv->NoAccel = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, 
		"Using \"Shadow Framebuffer\" - acceleration disabled\n");
    }
    if (xf86ReturnOptValBool(pNv->Options, OPTION_FBDEV, FALSE)) {
	pNv->FBDev = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, 
		"Using framebuffer device\n");
    }
    if (pNv->FBDev) {
	/* check for linux framebuffer device */
	if (!xf86LoadSubModule(pScrn, "fbdevhw")) {
	    xf86FreeInt10(pNv->pInt);
	    return FALSE;
	}
	
	xf86LoaderReqSymLists(fbdevHWSymbols, NULL);
	if (!fbdevHWInit(pScrn, pNv->PciInfo, NULL)) {
	    xf86FreeInt10(pNv->pInt);
	    return FALSE;
	}
	pScrn->SwitchMode    = fbdevHWSwitchMode;
	pScrn->AdjustFrame   = fbdevHWAdjustFrame;
	pScrn->EnterVT       = NVEnterVTFBDev;
	pScrn->LeaveVT       = fbdevHWLeaveVT;
	pScrn->ValidMode     = fbdevHWValidMode;
    }
    pNv->Rotate = 0;
    if ((s = xf86GetOptValString(pNv->Options, OPTION_ROTATE))) {
      if(!xf86NameCmp(s, "CW")) {
	pNv->ShadowFB = TRUE;
	pNv->NoAccel = TRUE;
	pNv->HWCursor = FALSE;
	pNv->Rotate = 1;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, 
		"Rotating screen clockwise - acceleration disabled\n");
      } else
      if(!xf86NameCmp(s, "CCW")) {
	pNv->ShadowFB = TRUE;
	pNv->NoAccel = TRUE;
	pNv->HWCursor = FALSE;
	pNv->Rotate = -1;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, 
		"Rotating screen counter clockwise - acceleration disabled\n");
      } else {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, 
		"\"%s\" is not a valid value for Option \"Rotate\"\n", s);
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		"Valid options are \"CW\" or \"CCW\"\n");
      }
    }
    if(xf86GetOptValInteger(pNv->Options, OPTION_VIDEO_KEY, &(pNv->videoKey))) {
        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "video key set to 0x%x\n",
                                pNv->videoKey);
    } else {
        pNv->videoKey =  (1 << pScrn->offset.red) | 
                          (1 << pScrn->offset.green) |
        (((pScrn->mask.blue >> pScrn->offset.blue) - 1) << pScrn->offset.blue); 
    }

    if (xf86ReturnOptValBool(pNv->Options, OPTION_FLAT_PANEL, FALSE)) {
	pNv->FlatPanel = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "using flat panel\n");
    }
    
    if (pNv->pEnt->device->MemBase != 0) {
	/* Require that the config file value matches one of the PCI values. */
	if (!xf86CheckPciMemBase(pNv->PciInfo, pNv->pEnt->device->MemBase)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"MemBase 0x%08lX doesn't match any PCI base register.\n",
		pNv->pEnt->device->MemBase);
	    xf86FreeInt10(pNv->pInt);
	    NVFreeRec(pScrn);
	    return FALSE;
	}
	pNv->FbAddress = pNv->pEnt->device->MemBase;
	from = X_CONFIG;
    } else {
	int i = 1;
	pNv->FbBaseReg = i;
	if (pNv->PciInfo->memBase[i] != 0) {
	    pNv->FbAddress = pNv->PciInfo->memBase[i] & 0xff800000;
	    from = X_PROBED;
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "No valid FB address in PCI config space\n");
	    xf86FreeInt10(pNv->pInt);
	    NVFreeRec(pScrn);
	    return FALSE;
	}
    }
    xf86DrvMsg(pScrn->scrnIndex, from, "Linear framebuffer at 0x%lX\n",
	       (unsigned long)pNv->FbAddress);

    if (pNv->pEnt->device->IOBase != 0) {
	/* Require that the config file value matches one of the PCI values. */
	if (!xf86CheckPciMemBase(pNv->PciInfo, pNv->pEnt->device->IOBase)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"IOBase 0x%08lX doesn't match any PCI base register.\n",
		pNv->pEnt->device->IOBase);
	    xf86FreeInt10(pNv->pInt);
	    NVFreeRec(pScrn);
	    return FALSE;
	}
	pNv->IOAddress = pNv->pEnt->device->IOBase;
	from = X_CONFIG;
    } else {
	int i = 0;
	if (pNv->PciInfo->memBase[i] != 0) {
	    pNv->IOAddress = pNv->PciInfo->memBase[i] & 0xffffc000;
	    from = X_PROBED;
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			"No valid MMIO address in PCI config space\n");
	    xf86FreeInt10(pNv->pInt);
	    NVFreeRec(pScrn);
	    return FALSE;
	}
    }
    xf86DrvMsg(pScrn->scrnIndex, from, "MMIO registers at 0x%lX\n",
	       (unsigned long)pNv->IOAddress);
     
    if (xf86RegisterResources(pNv->pEnt->index, NULL, ResExclusive)) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"xf86RegisterResources() found resource conflicts\n");
	xf86FreeInt10(pNv->pInt);
	NVFreeRec(pScrn);
	return FALSE;
    }

    switch (pNv->Chipset & 0x0ff0) {
        case 0x0010:
            NV3Setup(pScrn);
            break;
        case 0x0020:
        case 0x00A0:
            NV4Setup(pScrn);
            break;
        case 0x0100:
        case 0x0110:
        case 0x0150:
        case 0x0170:
        case 0x01A0:
            NV10Setup(pScrn);
	    break;
	case 0x0200:
	case 0x0250:
            NV20Setup(pScrn);
            break;
    }

    /*
     * fill riva structure etc.
     */
    (*pNv->PreInit)(pScrn);
    

    /*
     * If the user has specified the amount of memory in the XF86Config
     * file, we respect that setting.
     */
    if (pNv->pEnt->device->videoRam != 0) {
	pScrn->videoRam = pNv->pEnt->device->videoRam;
	from = X_CONFIG;
    } else {
	if (pNv->FBDev) {
	    pScrn->videoRam = fbdevHWGetVidmem(pScrn)/1024;
	} else {
            pScrn->videoRam = pNv->riva.RamAmountKBytes;
	}
	from = X_PROBED;
    }
    xf86DrvMsg(pScrn->scrnIndex, from, "VideoRAM: %d kBytes\n",
               pScrn->videoRam);
	
    pNv->FbMapSize = pScrn->videoRam * 1024;

#if !defined(__powerpc__)
    /* Read and print the Monitor DDC info */
    pScrn->monitor->DDC = NVdoDDC(pScrn);
#endif

#if 0
    /*
     * This code was for testing. It will be removed as soon
     * as this is integrated into the common level.
     */
    if ((!pScrn->monitor->nHsync || !pScrn->monitor->nVrefresh)
 	&& pScrn->monitor->DDC) {
 	int i;
 	int h = (!pScrn->monitor->nHsync) ? 0 : -1;
 	int v = (!pScrn->monitor->nVrefresh) ? 0 : -1;
 	xf86MonPtr pMon = (xf86MonPtr)pScrn->monitor->DDC;
 	for (i = 0; i < DET_TIMINGS; i++) {
 	    if (pMon->det_mon[i].type == DS_RANGES) {
 		if (h != -1) {
 		    pScrn->monitor->hsync[h].lo
 			= pMon->det_mon[i].section.ranges.min_h;
 		    pScrn->monitor->hsync[h++].hi
 			= pMon->det_mon[i].section.ranges.max_h;
 		}
 		if (v != -1) {
 		    pScrn->monitor->vrefresh[v].lo
 			= pMon->det_mon[i].section.ranges.min_v;
 		    pScrn->monitor->vrefresh[v++].hi
 			= pMon->det_mon[i].section.ranges.max_v;
 		}
 	    }
 	}
 	if (h != -1) pScrn->monitor->nHsync = h;
 	if (v != -1) pScrn->monitor->nVrefresh = v;
     }     
#endif
    /*
     * If the driver can do gamma correction, it should call xf86SetGamma()
     * here.
     */

    {
	Gamma zeros = {0.0, 0.0, 0.0};

	if (!xf86SetGamma(pScrn, zeros)) {
	    xf86FreeInt10(pNv->pInt);
	    return FALSE;
	}
    }

    pNv->FbUsableSize = pNv->FbMapSize;

    /* Remove reserved memory from end of buffer */
    switch( pNv->riva.Architecture ) {
        case NV_ARCH_03:
            pNv->FbUsableSize -= 32 * 1024;
            break;
        case NV_ARCH_04:
        case NV_ARCH_10:
        case NV_ARCH_20:
            pNv->FbUsableSize -= 128 * 1024;
            break;
    }


    /*
     * Setup the ClockRanges, which describe what clock ranges are available,
     * and what sort of modes they can be used for.
     */

    pNv->MinClock = 12000;
    pNv->MaxClock = pNv->riva.MaxVClockFreqKHz;

    clockRanges = xnfcalloc(sizeof(ClockRange), 1);
    clockRanges->next = NULL;
    clockRanges->minClock = pNv->MinClock;
    clockRanges->maxClock = pNv->MaxClock;
    clockRanges->clockIndex = -1;		/* programmable */
    if(((pNv->Chipset & 0x0ff0) <= 0x0100) ||
       ((pNv->Chipset & 0x0ff0) == 0x0150))
    {
       clockRanges->interlaceAllowed = TRUE;
    } else  /* Chips after NV15 (including NV11) do not support interlaced */
       clockRanges->interlaceAllowed = FALSE;
    clockRanges->doubleScanAllowed = TRUE;

    /*
     * xf86ValidateModes will check that the mode HTotal and VTotal values
     * don't exceed the chipset's limit if pScrn->maxHValue and
     * pScrn->maxVValue are set.  Since our NVValidMode() already takes
     * care of this, we don't worry about setting them here.
     */
    i = xf86ValidateModes(pScrn, pScrn->monitor->Modes,
                          pScrn->display->modes, clockRanges,
                          NULL, 256, 2048,
                          32 * pScrn->bitsPerPixel, 128, 2048,
                          pScrn->display->virtualX,
                          pScrn->display->virtualY,
                          pNv->FbUsableSize,
                          LOOKUP_BEST_REFRESH);

    if (i < 1 && pNv->FBDev) {
	fbdevHWUseBuildinMode(pScrn);
	pScrn->displayWidth = pScrn->virtualX; /* FIXME: might be wrong */
	i = 1;
    }
    if (i == -1) {
	xf86FreeInt10(pNv->pInt);
	NVFreeRec(pScrn);
	return FALSE;
    }

    /* Prune the modes marked as invalid */
    xf86PruneDriverModes(pScrn);

    if (i == 0 || pScrn->modes == NULL) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes found\n");
	xf86FreeInt10(pNv->pInt);
	NVFreeRec(pScrn);
	return FALSE;
    }

    /*
     * Set the CRTC parameters for all of the modes based on the type
     * of mode, and the chipset's interlace requirements.
     *
     * Calling this is required if the mode->Crtc* values are used by the
     * driver and if the driver doesn't provide code to set them.  They
     * are not pre-initialised at all.
     */
    xf86SetCrtcForModes(pScrn, 0);

    /* Set the current mode to the first in the list */
    pScrn->currentMode = pScrn->modes;

    /* Print the list of modes being used */
    xf86PrintModes(pScrn);

    /* Set display resolution */
    xf86SetDpi(pScrn, 0, 0);


    /*
     * XXX This should be taken into account in some way in the mode valdation
     * section.
     */

    if (xf86LoadSubModule(pScrn, "fb") == NULL) {
	xf86FreeInt10(pNv->pInt);
	NVFreeRec(pScrn);
	return FALSE;
    }

    xf86LoaderReqSymLists(fbSymbols, NULL);
    
    /* Load XAA if needed */
    if (!pNv->NoAccel) {
	if (!xf86LoadSubModule(pScrn, "xaa")) {
	    xf86FreeInt10(pNv->pInt);
	    NVFreeRec(pScrn);
	    return FALSE;
	}
	xf86LoaderReqSymLists(xaaSymbols, NULL);
    }

    /* Load ramdac if needed */
    if (pNv->HWCursor) {
	if (!xf86LoadSubModule(pScrn, "ramdac")) {
	    xf86FreeInt10(pNv->pInt);
	    NVFreeRec(pScrn);
	    return FALSE;
	}
	xf86LoaderReqSymLists(ramdacSymbols, NULL);
    }

    /* Load shadowfb if needed */
    if (pNv->ShadowFB) {
	if (!xf86LoadSubModule(pScrn, "shadowfb")) {
	    xf86FreeInt10(pNv->pInt);
	    NVFreeRec(pScrn);
	    return FALSE;
	}
	xf86LoaderReqSymLists(shadowSymbols, NULL);
    }

    pNv->CurrentLayout.bitsPerPixel = pScrn->bitsPerPixel;
    pNv->CurrentLayout.depth = pScrn->depth;
    pNv->CurrentLayout.displayWidth = pScrn->displayWidth;
    pNv->CurrentLayout.weight.red = pScrn->weight.red;
    pNv->CurrentLayout.weight.green = pScrn->weight.green;
    pNv->CurrentLayout.weight.blue = pScrn->weight.blue;
    pNv->CurrentLayout.mode = pScrn->currentMode;

    xf86FreeInt10(pNv->pInt);

    pNv->pInt = NULL;
    return TRUE;
}


/*
 * Map the framebuffer and MMIO memory.
 */

static Bool
NVMapMem(ScrnInfoPtr pScrn)
{
    NVPtr pNv;
        
    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "NVMapMem\n"));
    pNv = NVPTR(pScrn);

    /*
     * Map IO registers to virtual address space
     */ 
    pNv->IOBase = xf86MapPciMem(pScrn->scrnIndex,
                                VIDMEM_MMIO | VIDMEM_READSIDEEFFECT,
                                pNv->PciTag, pNv->IOAddress, 0x1000000);
    if (pNv->IOBase == NULL)
	return FALSE;

    pNv->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
				 pNv->PciTag, pNv->FbAddress,
				 pNv->FbMapSize);
    if (pNv->FbBase == NULL)
	return FALSE;

    pNv->FbStart = pNv->FbBase;

    return TRUE;
}

Bool
NVMapMemFBDev(ScrnInfoPtr pScrn)
{
    NVPtr pNv;

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "NVMamMemFBDev\n"));
    pNv = NVPTR(pScrn);

    pNv->FbBase = fbdevHWMapVidmem(pScrn);
    if (pNv->FbBase == NULL)
        return FALSE;

    pNv->IOBase = fbdevHWMapMMIO(pScrn);
    if (pNv->IOBase == NULL)
        return FALSE;

    pNv->FbStart = pNv->FbBase;

    return TRUE;
}

/*
 * Unmap the framebuffer and MMIO memory.
 */

static Bool
NVUnmapMem(ScrnInfoPtr pScrn)
{
    NVPtr pNv;
    
    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "NVUnmapMem\n"));
    pNv = NVPTR(pScrn);

    /*
     * Unmap IO registers to virtual address space
     */ 
    xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pNv->IOBase, 0x1000000);
    pNv->IOBase = NULL;

    xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pNv->FbBase, pNv->FbMapSize);
    pNv->FbBase = NULL;
    pNv->FbStart = NULL;

    return TRUE;
}


/*
 * Initialise a new mode.  This is currently still using the old
 * "initialise struct, restore/write struct to HW" model.  That could
 * be changed.
 */

static Bool
NVModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    vgaHWPtr hwp = VGAHWPTR(pScrn);
    vgaRegPtr vgaReg;
    NVPtr pNv = NVPTR(pScrn);
    NVRegPtr nvReg;

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "NVModeInit\n"));
    
    /* Initialise the ModeReg values */
    if (!vgaHWInit(pScrn, mode))
	return FALSE;
    pScrn->vtSema = TRUE;

    if ( pNv->ModeInit ) {
        if (!(*pNv->ModeInit)(pScrn, mode))
            return FALSE;
    }

    /* Program the registers */
    vgaHWProtect(pScrn, TRUE);
    vgaReg = &hwp->ModeReg;
    nvReg = &pNv->ModeReg;

    if ( pNv->Restore )
        (*pNv->Restore)(pScrn, vgaReg, nvReg, FALSE);

#if X_BYTE_ORDER == X_BIG_ENDIAN
    /* turn on LFB swapping */
    {
	unsigned char tmp;

	VGA_WR08(pNv->riva.PCIO, 0x3d4, 0x46);
	tmp = VGA_RD08(pNv->riva.PCIO, 0x3d5);
	tmp |= (1 << 7);
	VGA_WR08(pNv->riva.PCIO, 0x3d5, tmp);
    }
#endif

    NVResetGraphics(pScrn);

    vgaHWProtect(pScrn, FALSE);

    pNv->CurrentLayout.mode = mode;

    return TRUE;
}

/*
 * Restore the initial (text) mode.
 */
static void 
NVRestore(ScrnInfoPtr pScrn)
{
    vgaHWPtr hwp = VGAHWPTR(pScrn);
    vgaRegPtr vgaReg = &hwp->SavedReg;
    NVPtr pNv = NVPTR(pScrn);
    NVRegPtr nvReg = &pNv->SavedReg;

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "NVRestore\n"));
    /* Only restore text mode fonts/text for the primary card */
    vgaHWProtect(pScrn, TRUE);
    if (pNv->Primary)
        (*pNv->Restore)(pScrn, vgaReg, nvReg, TRUE);
    else
        vgaHWRestore(pScrn, vgaReg, VGA_SR_MODE | VGA_SR_CMAP);
    vgaHWProtect(pScrn, FALSE);
}


/* Mandatory */

/* This gets called at the start of each server generation */

static Bool
NVScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
{
    ScrnInfoPtr pScrn;
    vgaHWPtr hwp;
    NVPtr pNv;
    NVRamdacPtr NVdac;
    int ret;
    VisualPtr visual;
    unsigned char *FBStart;
    int width, height, displayWidth;
    BoxRec AvailFBArea;

    /* 
     * First get the ScrnInfoRec
     */
    pScrn = xf86Screens[pScreen->myNum];

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "NVScreenInit\n"));

    hwp = VGAHWPTR(pScrn);
    pNv = NVPTR(pScrn);
    NVdac = &pNv->Dac;

    /* Map the NV memory and MMIO areas */
    if (pNv->FBDev) {
	if (!NVMapMemFBDev(pScrn))
	    return FALSE;
    } else {
	if (!NVMapMem(pScrn))
	    return FALSE;
    }
    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "- Mem Mapped\n"));
    
    /* Map the VGA memory when the primary video */
    if (pNv->Primary && !pNv->FBDev) {
	hwp->MapSize = 0x10000;
	if (!vgaHWMapMem(pScrn))
	    return FALSE;
    }
    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "- VGA Mapped\n"));

    if (pNv->FBDev) {
	fbdevHWSave(pScrn);
	if (!fbdevHWModeInit(pScrn, pScrn->currentMode))
	    return FALSE;
    } else {
	/* Save the current state */
        vgaHWUnlock(hwp);
        pNv->riva.LockUnlock(&pNv->riva, 0);
	NVSave(pScrn);
	/* Initialise the first mode */
	if (!NVModeInit(pScrn, pScrn->currentMode))
	    return FALSE;
    }

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "- State saved\n"));

    /* Darken the screen for aesthetic reasons and set the viewport */
    NVSaveScreen(pScreen, SCREEN_SAVER_ON);
    pScrn->AdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "- Blanked\n"));

    /*
     * The next step is to setup the screen's visuals, and initialise the
     * framebuffer code.  In cases where the framebuffer's default
     * choices for things like visual layouts and bits per RGB are OK,
     * this may be as simple as calling the framebuffer's ScreenInit()
     * function.  If not, the visuals will need to be setup before calling
     * a fb ScreenInit() function and fixed up after.
     *
     * For most PC hardware at depths >= 8, the defaults that cfb uses
     * are not appropriate.  In this driver, we fixup the visuals after.
     */

    /*
     * Reset the visual list.
     */
    miClearVisualTypes();

    /* Setup the visuals we support. */

    if ((pScrn->bitsPerPixel > 8) && (pNv->riva.Architecture == NV_ARCH_03)) {
          if (!miSetVisualTypes(pScrn->depth, TrueColorMask, 8,
                                pScrn->defaultVisual))
              return FALSE;
    } else {
          if (!miSetVisualTypes(pScrn->depth, 
                                miGetDefaultVisualMask(pScrn->depth), 8,
                                pScrn->defaultVisual))
	  return FALSE;
     }
    if (!miSetPixmapDepths ()) return FALSE;

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "- Visuals set up\n"));

    /*
     * Call the framebuffer layer's ScreenInit function, and fill in other
     * pScreen fields.
     */

    width = pScrn->virtualX;
    height = pScrn->virtualY;
    displayWidth = pScrn->displayWidth;


    if(pNv->Rotate) {
	height = pScrn->virtualX;
	width = pScrn->virtualY;
    }

    if(pNv->ShadowFB) {
 	pNv->ShadowPitch = BitmapBytePad(pScrn->bitsPerPixel * width);
        pNv->ShadowPtr = xalloc(pNv->ShadowPitch * height);
	displayWidth = pNv->ShadowPitch / (pScrn->bitsPerPixel >> 3);
        FBStart = pNv->ShadowPtr;
    } else {
	pNv->ShadowPtr = NULL;
	FBStart = pNv->FbStart;
    }

    switch (pScrn->bitsPerPixel) {
        case 8:
        case 16:
        case 32:
            ret = fbScreenInit(pScreen, FBStart, width, height,
                               pScrn->xDpi, pScrn->yDpi,
                               displayWidth, pScrn->bitsPerPixel);
            break;
        default:
            xf86DrvMsg(scrnIndex, X_ERROR,
                       "Internal error: invalid bpp (%d) in NVScreenInit\n",
                       pScrn->bitsPerPixel);
            ret = FALSE;
            break;
    }
    if (!ret)
	return FALSE;

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "- cfb set up\n"));

    if (pScrn->bitsPerPixel > 8) {
        /* Fixup RGB ordering */
        visual = pScreen->visuals + pScreen->numVisuals;
        while (--visual >= pScreen->visuals) {
	    if ((visual->class | DynamicClass) == DirectColor) {
		visual->offsetRed = pScrn->offset.red;
		visual->offsetGreen = pScrn->offset.green;
		visual->offsetBlue = pScrn->offset.blue;
		visual->redMask = pScrn->mask.red;
		visual->greenMask = pScrn->mask.green;
		visual->blueMask = pScrn->mask.blue;
	    }
	}
    }

    fbPictureInit (pScreen, 0, 0);
    
    xf86SetBlackWhitePixels(pScreen);

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "- B & W\n"));

    if(!pNv->ShadowFB) /* hardware cursor needs to wrap this layer */
	NVDGAInit(pScreen);

    AvailFBArea.x1 = 0;
    AvailFBArea.y1 = 0;
    AvailFBArea.x2 = pScrn->displayWidth;
    AvailFBArea.y2 = (min(pNv->FbUsableSize, 32*1024*1024)) / 
                     (pScrn->displayWidth * pScrn->bitsPerPixel / 8);
    xf86InitFBManager(pScreen, &AvailFBArea);
    
    if (!pNv->NoAccel)
	NVAccelInit(pScreen);
    
    miInitializeBackingStore(pScreen);
    xf86SetBackingStore(pScreen);
    xf86SetSilkenMouse(pScreen);

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "- Backing store set up\n"));

    /* Initialize software cursor.  
	Must precede creation of the default colormap */
    miDCInitialize(pScreen, xf86GetPointerScreenFuncs());

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "- SW cursor set up\n"));

    /* Initialize HW cursor layer. 
	Must follow software cursor initialization*/
    if (pNv->HWCursor) { 
	if(!NVCursorInit(pScreen))
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, 
		"Hardware cursor initialization failed\n");
    }

    /* Initialise default colourmap */
    if (!miCreateDefColormap(pScreen))
	return FALSE;

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "- Def Color map set up\n"));
    
    /* Initialize colormap layer.  
	Must follow initialization of the default colormap */
    if(!xf86HandleColormaps(pScreen, 256, 8,
	(pNv->FBDev ? fbdevHWLoadPalette : NVdac->LoadPalette), 
	NULL, CMAP_RELOAD_ON_MODE_SWITCH | CMAP_PALETTED_TRUECOLOR))
	return FALSE;

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "- Palette loaded\n"));
    
    if(pNv->ShadowFB) {
	RefreshAreaFuncPtr refreshArea = NVRefreshArea;

	if(pNv->Rotate) {
   	   pNv->PointerMoved = pScrn->PointerMoved;
	   pScrn->PointerMoved = NVPointerMoved;

	   switch(pScrn->bitsPerPixel) {
               case 8:	refreshArea = NVRefreshArea8;	break;
               case 16:	refreshArea = NVRefreshArea16;	break;
               case 32:	refreshArea = NVRefreshArea32;	break;
	   }
	}

	ShadowFBInit(pScreen, refreshArea);
    }

    /* Call the vgaHW DPMS function directly.
       XXX There must be a way to get all the DPMS modes. */
    xf86DPMSInit(pScreen, vgaHWDPMSSet, 0);
    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "- DPMS set up\n"));

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "- Color maps etc. set up\n"));
    
    pScrn->memPhysBase = pNv->FbAddress;
    pScrn->fbOffset = 0;

    NVInitVideo(pScreen);

    pScreen->SaveScreen = NVSaveScreen;

    /* Wrap the current CloseScreen function */
    pNv->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = NVCloseScreen;

    pNv->BlockHandler = pScreen->BlockHandler;
    pScreen->BlockHandler = NVBlockHandler;

    /* Report any unused options (only for the first generation) */
    if (serverGeneration == 1) {
	xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
    }
    /* Done */
    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "- Done\n"));
    return TRUE;
}

/* Free up any persistent data structures */


/* Do screen blanking */

/* Mandatory */
static Bool
NVSaveScreen(ScreenPtr pScreen, int mode)
{
    return vgaHWSaveScreen(pScreen, mode);
}

static void
NVSave(ScrnInfoPtr pScrn)
{
    NVPtr pNv = NVPTR(pScrn);
    NVRegPtr nvReg = &pNv->SavedReg;
    vgaHWPtr pVga = VGAHWPTR(pScrn);
    vgaRegPtr vgaReg = &pVga->SavedReg;

    DEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO, "NVSave\n"));
#if defined(__powerpc__)
    /* The console driver will have to save the fonts, we can't */
    vgaHWSave(pScrn, vgaReg, VGA_SR_CMAP | VGA_SR_MODE);
#else
    vgaHWSave(pScrn, vgaReg, VGA_SR_CMAP | VGA_SR_MODE | VGA_SR_FONTS);
#endif
    pNv->riva.UnloadStateExt(&pNv->riva, nvReg);
}

@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d27 1
a27 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/nv_driver.c,v 1.123 2004/01/13 19:03:28 mvojkovi Exp $ */
d31 6
a38 3
const   OptionInfoRec * RivaAvailableOptions(int chipid, int busid);
Bool    RivaGetScrnInfoRec(PciChipsets *chips, int chip);

d57 2
a58 2
static ModeStatus NVValidMode(int scrnIndex, DisplayModePtr mode,
			      Bool verbose, int flags);
d79 1
a79 1
        NV_VERSION,
d88 38
a125 121
static SymTabRec NVKnownChipsets[] =
{
  { 0x12D20018, "RIVA 128" },
  { 0x10DE0020, "RIVA TNT" },
  { 0x10DE0028, "RIVA TNT2" },
  { 0x10DE002A, "Unknown TNT2" },
  { 0x10DE002C, "Vanta" },
  { 0x10DE0029, "RIVA TNT2 Ultra" },
  { 0x10DE002D, "RIVA TNT2 Model 64" },
  { 0x10DE00A0, "Aladdin TNT2" },
  { 0x10DE0100, "GeForce 256" },
  { 0x10DE0101, "GeForce DDR" },
  { 0x10DE0103, "Quadro" },
  { 0x10DE0110, "GeForce2 MX/MX 400" },
  { 0x10DE0111, "GeForce2 MX 100/200" },
  { 0x10DE0112, "GeForce2 Go" },
  { 0x10DE0113, "Quadro2 MXR/EX/Go" },
  { 0x10DE01A0, "GeForce2 Integrated GPU" },
  { 0x10DE0150, "GeForce2 GTS" },
  { 0x10DE0151, "GeForce2 Ti" },
  { 0x10DE0152, "GeForce2 Ultra" },
  { 0x10DE0153, "Quadro2 Pro" },
  { 0x10DE0170, "GeForce4 MX 460" },
  { 0x10DE0171, "GeForce4 MX 440" },
  { 0x10DE0172, "GeForce4 MX 420" },
  { 0x10DE0173, "GeForce4 MX 440-SE" },
  { 0x10DE0174, "GeForce4 440 Go" },
  { 0x10DE0175, "GeForce4 420 Go" },
  { 0x10DE0176, "GeForce4 420 Go 32M" },
  { 0x10DE0177, "GeForce4 460 Go" },
#if defined(__powerpc__)
  { 0x10DE0179, "GeForce4 MX (Mac)" },
#else
  { 0x10DE0179, "GeForce4 440 Go 64M" },
#endif
  { 0x10DE017D, "GeForce4 410 Go 16M" },
  { 0x10DE017C, "Quadro4 500 GoGL" },
  { 0x10DE0178, "Quadro4 550 XGL" },
  { 0x10DE017A, "Quadro4 NVS" },
  { 0x10DE0181, "GeForce4 MX 440 with AGP8X" },
  { 0x10DE0182, "GeForce4 MX 440SE with AGP8X" },
  { 0x10DE0183, "GeForce4 MX 420 with AGP8X" },
  { 0x10DE0186, "GeForce4 448 Go" },
  { 0x10DE0187, "GeForce4 488 Go" },
  { 0x10DE0188, "Quadro4 580 XGL" },
#if defined(__powerpc__)
  { 0x10DE0189, "GeForce4 MX with AGP8X (Mac)" },
#endif
  { 0x10DE018A, "Quadro4 280 NVS" },
  { 0x10DE018B, "Quadro4 380 XGL" },
  { 0x10DE01F0, "GeForce4 MX Integrated GPU" },
  { 0x10DE0200, "GeForce3" },
  { 0x10DE0201, "GeForce3 Ti 200" },
  { 0x10DE0202, "GeForce3 Ti 500" },
  { 0x10DE0203, "Quadro DCC" },
  { 0x10DE0250, "GeForce4 Ti 4600" },
  { 0x10DE0251, "GeForce4 Ti 4400" },
  { 0x10DE0252, "0x0252" },
  { 0x10DE0253, "GeForce4 Ti 4200" },
  { 0x10DE0258, "Quadro4 900 XGL" },
  { 0x10DE0259, "Quadro4 750 XGL" },
  { 0x10DE025B, "Quadro4 700 XGL" },
  { 0x10DE0280, "GeForce4 Ti 4800" },
  { 0x10DE0281, "GeForce4 Ti 4200 with AGP8X" },
  { 0x10DE0282, "GeForce4 Ti 4800 SE" },
  { 0x10DE0286, "GeForce4 4200 Go" },
  { 0x10DE028C, "Quadro4 700 GoGL" },
  { 0x10DE0288, "Quadro4 980 XGL" },
  { 0x10DE0289, "Quadro4 780 XGL" },
  { 0x10DE0301, "GeForce FX 5800 Ultra" },
  { 0x10DE0302, "GeForce FX 5800" },
  { 0x10DE0308, "Quadro FX 2000" },
  { 0x10DE0309, "Quadro FX 1000" },
  { 0x10DE0311, "GeForce FX 5600 Ultra" },
  { 0x10DE0312, "GeForce FX 5600" },
  { 0x10DE0313, "0x0313"},
  { 0x10DE0314, "GeForce FX 5600SE" },
  { 0x10DE0316, "0x0316" },
  { 0x10DE0317, "0x0317" },
  { 0x10DE031A, "GeForce FX Go5600" },
  { 0x10DE031B, "GeForce FX Go5650" },
  { 0x10DE031C, "Quadro FX Go700" },
  { 0x10DE031D, "0x031D" },
  { 0x10DE031E, "0x031E" },
  { 0x10DE031F, "0x031F" },
  { 0x10DE0320, "GeForce FX 5200" },
  { 0x10DE0321, "GeForce FX 5200 Ultra" },
  { 0x10DE0322, "GeForce FX 5200" },
  { 0x10DE0323, "GeForce FX 5200SE" },
  { 0x10DE0324, "GeForce FX Go5200" },
  { 0x10DE0325, "GeForce FX Go5250" },
  { 0x10DE0328, "GeForce FX Go5200 32M/64M" },
#if defined(__powerpc__)
  { 0x10DE0329, "GeForce FX 5200 (Mac)" },
#else
  { 0x10DE0329, "0x0329" },
#endif
  { 0x10DE032A, "Quadro NVS 280 PCI" },
  { 0x10DE032B, "Quadro FX 500" },
  { 0x10DE032C, "GeForce FX Go5300" },
  { 0x10DE032D, "GeForce FX Go5100" },
  { 0x10DE032F, "0x032F" },
  { 0x10DE0330, "GeForce FX 5900 Ultra" },
  { 0x10DE0331, "GeForce FX 5900" },
  { 0x10DE0332, "GeForce FX 5900XT" },
  { 0x10DE0333, "GeForce FX 5950 Ultra" },
  { 0x10DE0334, "0x0334" },
  { 0x10DE0338, "Quadro FX 3000" },
  { 0x10DE0341, "GeForce FX 5700 Ultra" },
  { 0x10DE0342, "GeForce FX 5700" },
  { 0x10DE0343, "GeForce FX 5700LE" },
  { 0x10DE0344, "GeForce FX 5700VE" },
  { 0x10DE0345, "0x0345" },
  { 0x10DE0347, "GeForce FX Go5700" },
  { 0x10DE0348, "GeForce FX Go5700" },
  { 0x10DE0349, "0x0349" },
  { 0x10DE034B, "0x034B" },
  { 0x10DE034C, "Quadro FX Go1000" },
  { 0x10DE034E, "Quadro FX 1100" },
  { 0x10DE034F, "0x034F" },
  {-1, NULL}
d128 38
a176 1
    "vgaHWUnmapMem",
d182 1
d188 2
d216 2
d220 2
d223 1
a227 1
#ifdef XFree86LOADER
d230 1
a231 1
    "vbeDoEDID",
a233 1
#endif
a275 6
static const char *rivaSymbols[] = {
   "RivaGetScrnInfoRec",
   "RivaAvailableOptions",
    NULL
};

d303 1
d308 1
a308 3
    OPTION_FLAT_PANEL,
    OPTION_FP_DITHER,
    OPTION_CRTC_NUMBER
d316 1
a321 2
    { OPTION_FP_DITHER, 	"FPDither",	OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_CRTC_NUMBER,	"CrtcNumber",	OPTV_INTEGER,	{0}, FALSE },
d331 9
d344 1
d356 1
d363 2
d395 1
a395 1
                          ramdacSymbols, shadowSymbols, rivaSymbols,
a415 7
    if(chipid == 0x12D20018) {
	if (!xf86LoadOneModule("riva128", NULL)) {
	    return NULL;
	} else
	    return RivaAvailableOptions(chipid, busid);
    }
    
d423 1
a423 30
    xf86PrintChipsets(NV_NAME, "driver for NVIDIA chipsets", NVKnownChipsets);
}


static Bool
NVGetScrnInfoRec(PciChipsets *chips, int chip)
{
    ScrnInfoPtr pScrn;

    pScrn = xf86ConfigPciEntity(NULL, 0, chip,
                                chips, NULL, NULL, NULL,
                                NULL, NULL);

    if(!pScrn) return FALSE;

    pScrn->driverVersion    = NV_VERSION;
    pScrn->driverName       = NV_DRIVER_NAME;
    pScrn->name             = NV_NAME;

    pScrn->Probe            = NVProbe;
    pScrn->PreInit          = NVPreInit;
    pScrn->ScreenInit       = NVScreenInit;
    pScrn->SwitchMode       = NVSwitchMode;
    pScrn->AdjustFrame      = NVAdjustFrame;
    pScrn->EnterVT          = NVEnterVT;
    pScrn->LeaveVT          = NVLeaveVT;
    pScrn->FreeScreen       = NVFreeScreen;
    pScrn->ValidMode        = NVValidMode;

    return TRUE;
a425 1
#define MAX_CHIPS MAXSCREENS
a433 3
    SymTabRec NVChipsets[MAX_CHIPS + 1];
    PciChipsets NVPciChipsets[MAX_CHIPS + 1];
    pciVideoPtr *ppPci;
d438 11
d450 6
a455 2
    if ((numDevSections = xf86MatchDevice(NV_DRIVER_NAME, &devSections)) <= 0) 
        return FALSE;  /* no matching device section */
d457 8
a464 2
    if (!(ppPci = xf86GetPciVideoInfo())) 
        return FALSE;  /* no PCI cards found */
d466 5
a470 1
    numUsed = 0;
d472 11
a482 54
    /* Create the NVChipsets and NVPciChipsets from found devices */
    while (*ppPci && (numUsed < MAX_CHIPS)) {
        if(((*ppPci)->vendor == PCI_VENDOR_NVIDIA_SGS) || 
           ((*ppPci)->vendor == PCI_VENDOR_NVIDIA)) 
        {
            SymTabRec *nvchips = NVKnownChipsets;
            int token = ((*ppPci)->vendor << 16) | (*ppPci)->chipType;

            while(nvchips->name) {
               if(token == nvchips->token)
                  break;
               nvchips++;
            }

            if(nvchips->name) { /* found one */
               NVChipsets[numUsed].token = nvchips->token;
               NVChipsets[numUsed].name = nvchips->name;
               NVPciChipsets[numUsed].numChipset = nvchips->token;
               NVPciChipsets[numUsed].PCIid = nvchips->token;
               NVPciChipsets[numUsed].resList = RES_SHARED_VGA;
               numUsed++;
            } else if ((*ppPci)->vendor == PCI_VENDOR_NVIDIA) {
               /* look for a compatible devices which may be newer than 
                  the NVKnownChipsets list above.  */
               switch(token & 0xfff0) {
               case 0x0170:   
               case 0x0180:
               case 0x0250:
               case 0x0280:
               case 0x0300:
               case 0x0310:
               case 0x0320:
               case 0x0330:
               case 0x0340:
                   NVChipsets[numUsed].token = token;
                   NVChipsets[numUsed].name = "Unknown NVIDIA chip";
                   NVPciChipsets[numUsed].numChipset = token;
                   NVPciChipsets[numUsed].PCIid = token;
                   NVPciChipsets[numUsed].resList = RES_SHARED_VGA;
                   numUsed++;
                   break;
               default:  break;  /* we don't recognize it */
               }
            }
        }
        ppPci++;
    }

    /* terminate the list */
    NVChipsets[numUsed].token = -1;
    NVChipsets[numUsed].name = NULL; 
    NVPciChipsets[numUsed].numChipset = -1;
    NVPciChipsets[numUsed].PCIid = -1;
    NVPciChipsets[numUsed].resList = RES_UNDEFINED;
d484 2
d490 3
a492 1
    if (numUsed <= 0) 
d498 21
a518 13
        pciVideoPtr pPci;

        pPci = xf86GetPciInfoForEntity(usedChips[i]);
        if(pPci->vendor == PCI_VENDOR_NVIDIA_SGS) {
            if (!xf86LoadDrvSubModule(drv, "riva128")) {
                  continue;
            }
            xf86LoaderReqSymLists(rivaSymbols, NULL);
            if(RivaGetScrnInfoRec(NVPciChipsets, usedChips[i]))
                foundScreen = TRUE;
        } else {
            if(NVGetScrnInfoRec(NVPciChipsets, usedChips[i])) 
	        foundScreen = TRUE;
a520 2

    xfree(devSections);
a521 1

d529 1
d546 5
d552 1
a552 1
    NVSetStartAddress(pNv, startAddr);
d569 3
d573 2
a577 3

    if(pNv->overlayAdaptor)
        NVResetVideo(pScrn);
d584 2
d603 3
a606 1
    NVSync(pScrn);
d608 2
a609 1
    NVLockUnlock(pNv, 1);
a624 3

    if (pNv->DMAKickoffCallback)
        (*pNv->DMAKickoffCallback)(pScrnInfo);
d648 1
d651 2
a653 1
        NVSync(pScrn);
d655 2
a656 1
        NVLockUnlock(pNv, 1);
d669 2
a672 2
    if (pNv->blitAdaptor)
        xfree(pNv->blitAdaptor);
d686 1
d700 1
a700 1
static ModeStatus
d703 2
d708 50
a757 2
static void
nvProbeDDC(ScrnInfoPtr pScrn, int index)
d759 2
d764 14
a777 4
        pVbe = VBEInit(NULL,index);
        ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
	vbeFree(pVbe);
    }
d779 10
d790 3
d794 18
a811 3
Bool NVI2CInit(ScrnInfoPtr pScrn)
{
    char *mod = "i2c";
d813 5
a817 2
    if (xf86LoadSubModule(pScrn, mod)) {
        xf86LoaderReqSymLists(i2cSymbols,NULL);
d819 2
a820 6
        mod = "ddc";
        if(xf86LoadSubModule(pScrn, mod)) {
            xf86LoaderReqSymLists(ddcSymbols, NULL);
            return NVDACi2cInit(pScrn);
        } 
    }
d822 4
a825 2
    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
              "Couldn't load %s module.  DDC probing can't be done\n", mod);
d827 5
a831 1
    return FALSE;
d840 2
a841 1
    int i, max_width, max_height;
d850 2
d888 1
a888 1
    if (xf86LoadSubModule(pScrn, "int10")) {
d894 12
a906 3
   
    xf86SetOperatingState(resVgaIo, pNv->pEnt->index, ResUnusedOpr);
    xf86SetOperatingState(resVgaMem, pNv->pEnt->index, ResDisableOpr);
d917 1
a917 1
        pNv->Chipset = xf86StringToToken(NVKnownChipsets, pScrn->chipset);
d921 1
a921 2
	pScrn->chipset = (char *)xf86TokenToString(NVKnownChipsets, 
                                                   pNv->Chipset);
d927 2
a928 5
	pNv->Chipset = (pNv->PciInfo->vendor << 16) | pNv->PciInfo->chipType;
	pScrn->chipset = (char *)xf86TokenToString(NVKnownChipsets, 
                                                   pNv->Chipset);
        if(!pScrn->chipset)
          pScrn->chipset = "Unknown NVIDIA chipset";
d960 1
d963 1
a963 1
    if (!xf86SetDepthBpp(pScrn, 0, 0, 0, Support32bppFb)) {
a970 1
            case 16:
d974 8
d1024 2
d1078 4
d1144 3
a1146 21
    if (xf86GetOptValBool(pNv->Options, OPTION_FLAT_PANEL, &(pNv->FlatPanel))) {
        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "forcing %s usage\n",
                   pNv->FlatPanel ? "DFP" : "CRTC");
    } else {
        pNv->FlatPanel = -1;   /* autodetect later */
    }

    pNv->FPDither = FALSE;
    if (xf86GetOptValBool(pNv->Options, OPTION_FP_DITHER, &(pNv->FPDither))) 
        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "enabling flat panel dither\n");

    if (xf86GetOptValInteger(pNv->Options, OPTION_CRTC_NUMBER,
                             &pNv->CRTCnumber)) 
    {
	if((pNv->CRTCnumber < 0) || (pNv->CRTCnumber > 1)) {
           pNv->CRTCnumber = -1;
           xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, 
                      "Invalid CRTC number.  Must be 0 or 1\n");
        }
    } else {
        pNv->CRTCnumber = -1; /* autodetect later */
a1147 1

d1162 4
a1165 2
	if (pNv->PciInfo->memBase[1] != 0) {
	    pNv->FbAddress = pNv->PciInfo->memBase[1] & 0xff800000;
d1191 3
a1193 2
	if (pNv->PciInfo->memBase[0] != 0) {
	    pNv->IOAddress = pNv->PciInfo->memBase[0] & 0xffffc000;
d1214 20
a1233 1
    pNv->alphaCursor = ((pNv->Chipset & 0x0ff0) >= 0x0110);
d1235 5
a1239 1
    pNv->Architecture = (pNv->Chipset & 0x0f00) >> 4;
d1241 7
a1247 7
    if(pNv->Architecture < NV_ARCH_10)
        pNv->Architecture = NV_ARCH_04;

    NVCommonSetup(pScrn);

    if (pNv->FBDev) {
       pScrn->videoRam = fbdevHWGetVidmem(pScrn)/1024;
d1249 6
a1254 1
       pScrn->videoRam = pNv->RamAmountKBytes;
d1256 1
a1256 1
    xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "VideoRAM: %d kBytes\n",
d1261 36
d1311 14
a1324 3
    pNv->FbUsableSize = pNv->FbMapSize - (128 * 1024);
    pNv->ScratchBufferSize = (pNv->Architecture < NV_ARCH_10) ? 8192 : 16384;
    pNv->ScratchBufferStart = pNv->FbUsableSize - pNv->ScratchBufferSize;
d1331 3
d1336 2
a1337 2
    clockRanges->minClock = pNv->MinVClockFreqKHz;
    clockRanges->maxClock = pNv->MaxVClockFreqKHz;
d1340 1
a1340 2
       ((pNv->Chipset & 0x0ff0) == 0x0150) ||
       ((pNv->Chipset & 0x0ff0) >= 0x0300))
d1343 1
a1343 3
    } else {
        /* No NV2x chips support interlaced modes and the only
           NV1x chips that do are NV10 and NV15 */
a1344 1
    }
a1346 13
    if(pNv->FlatPanel == 1) {
       clockRanges->interlaceAllowed = FALSE;
       clockRanges->doubleScanAllowed = FALSE;
    }

    if(pNv->Architecture < NV_ARCH_10) {
       max_width = (pScrn->bitsPerPixel > 16) ? 2032 : 2048;
       max_height = 2048;
    } else {
       max_width = (pScrn->bitsPerPixel > 16) ? 4080 : 4096;
       max_height = 4096;
    }

d1355 2
a1356 2
                          NULL, 256, max_width,
                          512, 128, max_height,
d1359 1
a1359 1
                          pNv->ScratchBufferStart,
d1470 1
d1473 9
d1498 1
d1505 4
d1523 1
d1526 6
d1541 3
a1543 1
 * Initialise a new mode. 
d1554 2
d1561 3
a1563 11
    vgaReg = &hwp->ModeReg;
    nvReg = &pNv->ModeReg;

    if(!NVDACInit(pScrn, mode))
        return FALSE;

    NVLockUnlock(pNv, 0);
    if(pNv->twoHeads) {
        VGA_WR08(pNv->PCIO, 0x03D4, 0x44);
        VGA_WR08(pNv->PCIO, 0x03D5, nvReg->crtcOwner);
        NVLockUnlock(pNv, 0);
d1568 2
d1571 2
a1572 1
    NVDACRestore(pScrn, vgaReg, nvReg, FALSE);
d1579 2
a1580 2
	VGA_WR08(pNv->PCIO, 0x3d4, 0x46);
	tmp = VGA_RD08(pNv->PCIO, 0x3d5);
d1582 1
a1582 1
	VGA_WR08(pNv->PCIO, 0x3d5, tmp);
d1606 1
a1606 8
    if(pNv->twoHeads) {
        VGA_WR08(pNv->PCIO, 0x03D4, 0x44);
        VGA_WR08(pNv->PCIO, 0x03D5, nvReg->crtcOwner);
        NVLockUnlock(pNv, 0);
    }

    NVLockUnlock(pNv, 0);

d1609 4
a1612 1
    NVDACRestore(pScrn, vgaReg, nvReg, pNv->Primary);
a1615 77
static void NVBacklightEnable(NVPtr pNv,  Bool on)
{
    /* This is done differently on each laptop.  Here we
       define the ones we know for sure. */

#if defined(__powerpc__)
    if((pNv->Chipset == 0x10DE0179) || 
       (pNv->Chipset == 0x10DE0189) || 
       (pNv->Chipset == 0x10DE0329))
    {
       /* NV17,18,34 Apple iMac, iBook, PowerBook */
      CARD32 tmp_pmc, tmp_pcrt;
      tmp_pmc = pNv->PMC[0x10F0/4] & 0x7FFFFFFF;
      tmp_pcrt = pNv->PCRTC0[0x081C/4] & 0xFFFFFFFC;
      if(on) {
          tmp_pmc |= (1 << 31);
          tmp_pcrt |= 0x1;
      }
      pNv->PMC[0x10F0/4] = tmp_pmc;
      pNv->PCRTC0[0x081C/4] = tmp_pcrt;
    }
#endif
}

static void
NVDPMSSetLCD(ScrnInfoPtr pScrn, int PowerManagementMode, int flags)
{
  NVPtr pNv = NVPTR(pScrn);

  if (!pScrn->vtSema) return;

  switch (PowerManagementMode) {
  case DPMSModeStandby:  /* HSync: Off, VSync: On */
  case DPMSModeSuspend:  /* HSync: On, VSync: Off */
  case DPMSModeOff:      /* HSync: Off, VSync: Off */
    NVBacklightEnable(pNv, 0);
    break;
  case DPMSModeOn:       /* HSync: On, VSync: On */
    NVBacklightEnable(pNv, 1);
  default:
    break;
  }
  vgaHWDPMSSet(pScrn, PowerManagementMode, flags);
}


static void
NVDPMSSet(ScrnInfoPtr pScrn, int PowerManagementMode, int flags)
{
  unsigned char crtc1A;
  vgaHWPtr hwp = VGAHWPTR(pScrn);

  if (!pScrn->vtSema) return;

  crtc1A = hwp->readCrtc(hwp, 0x1A) & ~0xC0;

  switch (PowerManagementMode) {
  case DPMSModeStandby:  /* HSync: Off, VSync: On */
    crtc1A |= 0x80;
    break;
  case DPMSModeSuspend:  /* HSync: On, VSync: Off */
    crtc1A |= 0x40;
    break;
  case DPMSModeOff:      /* HSync: Off, VSync: Off */
    crtc1A |= 0xC0;
    break;
  case DPMSModeOn:       /* HSync: On, VSync: On */
  default:
    break;
  }

  /* vgaHWDPMSSet will merely cut the dac output */
  vgaHWDPMSSet(pScrn, PowerManagementMode, flags);

  hwp->writeCrtc(hwp, 0x1A, crtc1A);
}

d1627 1
d1631 1
a1631 1
    int width, height, displayWidth, offscreenHeight;
d1639 2
d1643 1
d1647 2
a1648 3
        if (!NVMapMemFBDev(pScrn)) {
            return FALSE;
        }
d1650 2
a1651 3
        if (!NVMapMem(pScrn)) {
            return FALSE;
         }
d1653 2
a1654 1

d1661 1
d1669 2
d1677 2
d1683 2
d1704 8
a1711 3
    if (!miSetVisualTypes(pScrn->depth, 
                          miGetDefaultVisualMask(pScrn->depth), 8,
                          pScrn->defaultVisual))
d1713 1
d1716 2
d1761 2
d1782 2
a1786 5
    offscreenHeight = pNv->ScratchBufferStart /
                     (pScrn->displayWidth * pScrn->bitsPerPixel >> 3);
    if(offscreenHeight > 32767)
        offscreenHeight = 32767;

d1790 2
a1791 1
    AvailFBArea.y2 = offscreenHeight;
d1801 2
d1807 2
d1821 2
d1826 1
a1826 1
	(pNv->FBDev ? fbdevHWLoadPalette : NVDACLoadPalette), 
d1830 2
a1843 3
           xf86DisableRandR();
           xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                      "Driver rotation enabled, RandR disabled\n");
d1849 6
a1854 4
    if(pNv->FlatPanel)
       xf86DPMSInit(pScreen, NVDPMSSetLCD, 0);
    else
       xf86DPMSInit(pScreen, NVDPMSSet, 0);
d1859 1
a1859 2
    if(pNv->Rotate == 0)
       NVInitVideo(pScreen);
d1874 2
d1879 6
d1899 8
a1906 1
    NVDACSave(pScrn, vgaReg, nvReg, pNv->Primary);
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d27 1
a27 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/nv_driver.c,v 1.101 2003/02/10 23:42:51 mvojkovi Exp $ */
d31 6
d88 38
a125 86
static SymTabRec NVKnownChipsets[] =
{
  { 0x12D20018, "RIVA 128" },
  { 0x10DE0020, "RIVA TNT" },
  { 0x10DE0028, "RIVA TNT2" },
  { 0x10DE002C, "Vanta" },
  { 0x10DE0029, "RIVA TNT2 Ultra" },
  { 0x10DE002D, "RIVA TNT2 Model 64" },
  { 0x10DE00A0, "Aladdin TNT2" },
  { 0x10DE0100, "GeForce 256" },
  { 0x10DE0101, "GeForce DDR" },
  { 0x10DE0103, "Quadro" },
  { 0x10DE0110, "GeForce2 MX/MX 400" },
  { 0x10DE0111, "GeForce2 MX 100/200" },
  { 0x10DE0112, "GeForce2 Go" },
  { 0x10DE0113, "Quadro2 MXR/EX/Go" },
  { 0x10DE01A0, "GeForce2 Integrated GPU" },
  { 0x10DE0150, "GeForce2 GTS" },
  { 0x10DE0151, "GeForce2 Ti" },
  { 0x10DE0152, "GeForce2 Ultra" },
  { 0x10DE0153, "Quadro2 Pro" },
  { 0x10DE0170, "GeForce4 MX 460" },
  { 0x10DE0171, "GeForce4 MX 440" },
  { 0x10DE0172, "GeForce4 MX 420" },
  { 0x10DE0173, "GeForce4 MX 440-SE" },
  { 0x10DE0174, "GeForce4 440 Go" },
  { 0x10DE0175, "GeForce4 420 Go" },
  { 0x10DE0176, "GeForce4 420 Go 32M" },
  { 0x10DE0177, "GeForce4 460 Go" },
  { 0x10DE0179, "GeForce4 440 Go 64M" },
  { 0x10DE017D, "GeForce4 410 Go 16M" },
  { 0x10DE017C, "Quadro4 500 GoGL" },
  { 0x10DE0178, "Quadro4 550 XGL" },
  { 0x10DE017A, "Quadro4 NVS" },
  { 0x10DE0181, "GeForce4 MX 440 with AGP8X" },
  { 0x10DE0182, "GeForce4 MX 440SE with AGP8X" },
  { 0x10DE0183, "GeForce4 MX 420 with AGP8X" },
  { 0x10DE0186, "GeForce4 448 Go" },
  { 0x10DE0187, "GeForce4 488 Go" },
  { 0x10DE0188, "Quadro4 580 XGL" },
  { 0x10DE018A, "Quadro4 280 NVS" },
  { 0x10DE018B, "Quadro4 380 XGL" },
  { 0x10DE01F0, "GeForce4 MX Integrated GPU" },
  { 0x10DE0200, "GeForce3" },
  { 0x10DE0201, "GeForce3 Ti 200" },
  { 0x10DE0202, "GeForce3 Ti 500" },
  { 0x10DE0203, "Quadro DCC" },
  { 0x10DE0250, "GeForce4 Ti 4600" },
  { 0x10DE0251, "GeForce4 Ti 4400" },
  { 0x10DE0252, "0x0252" },
  { 0x10DE0253, "GeForce4 Ti 4200" },
  { 0x10DE0258, "Quadro4 900 XGL" },
  { 0x10DE0259, "Quadro4 750 XGL" },
  { 0x10DE025B, "Quadro4 700 XGL" },
  { 0x10DE0280, "GeForce4 Ti 4800" },
  { 0x10DE0281, "GeForce4 Ti 4200 with AGP8X" },
  { 0x10DE0282, "GeForce4 Ti 4800 SE" },
  { 0x10DE0286, "GeForce4 4200 Go" },
  { 0x10DE028C, "Quadro4 700 GoGL" },
  { 0x10DE0288, "Quadro4 980 XGL" },
  { 0x10DE0289, "Quadro4 780 XGL" },
  { 0x10DE0300, "0x0300" },
  { 0x10DE0301, "GeForce FX 5800 Ultra" },
  { 0x10DE0302, "GeForce FX 5800" },
  { 0x10DE0308, "Quadro FX 2000" },
  { 0x10DE0309, "Quadro FX 1000" },
  { 0x10DE0311, "0x0311" },
  { 0x10DE0312, "0x0312" },
  { 0x10DE0316, "0x0316" },
  { 0x10DE0317, "0x0317" },
  { 0x10DE0318, "0x0318" },
  { 0x10DE0319, "0x0319" },
  { 0x10DE031A, "0x031A" },
  { 0x10DE031B, "0x031B" },
  { 0x10DE031C, "0x031C" },
  { 0x10DE031D, "0x031D" },
  { 0x10DE031E, "0x031E" },
  { 0x10DE031F, "0x031F" },
  { 0x10DE0321, "0x0321" },
  { 0x10DE0322, "0x0322" },
  { 0x10DE0323, "0x0323" },
  { 0x10DE0326, "0x0326" },
  { 0x10DE032A, "0x032A" },
  { 0x10DE032B, "0x032B" },
  { 0x10DE032E, "0x032E" },
  {-1, NULL}
d128 38
d182 1
d188 1
d308 1
a308 3
    OPTION_FLAT_PANEL,
    OPTION_FP_DITHER,
    OPTION_CRTC_NUMBER
a321 2
    { OPTION_FP_DITHER, 	"FPDither",	OPTV_BOOLEAN,	{0}, FALSE },
    { OPTION_CRTC_NUMBER,	"CrtcNumber",	OPTV_INTEGER,	{0}, FALSE },
d336 1
a336 1
        0, NULL, NULL, NULL, NULL
d423 1
a423 1
    xf86PrintChipsets(NV_NAME, "driver for NVIDIA chipsets", NVKnownChipsets);
a426 2
#define MAX_CHIPS MAXSCREENS

a433 3
    SymTabRec NVChipsets[MAX_CHIPS + 1];
    PciChipsets NVPciChipsets[MAX_CHIPS + 1];
    pciVideoPtr *ppPci;
d438 11
d450 6
a455 2
    if ((numDevSections = xf86MatchDevice(NV_DRIVER_NAME, &devSections)) <= 0) 
        return FALSE;  /* no matching device section */
d457 8
a464 2
    if (!(ppPci = xf86GetPciVideoInfo())) 
        return FALSE;  /* no PCI cards found */
d466 5
a470 1
    numUsed = 0;
d472 11
a482 54
    /* Create the NVChipsets and NVPciChipsets from found devices */
    while (*ppPci && (numUsed < MAX_CHIPS)) {
        if(((*ppPci)->vendor == PCI_VENDOR_NVIDIA_SGS) || 
           ((*ppPci)->vendor == PCI_VENDOR_NVIDIA)) 
        {
            SymTabRec *nvchips = NVKnownChipsets;
            int token = ((*ppPci)->vendor << 16) | (*ppPci)->chipType;

            while(nvchips->name) {
               if(token == nvchips->token)
                  break;
               nvchips++;
            }

            if(nvchips->name) { /* found one */
               NVChipsets[numUsed].token = nvchips->token;
               NVChipsets[numUsed].name = nvchips->name;
               NVPciChipsets[numUsed].numChipset = nvchips->token;
               NVPciChipsets[numUsed].PCIid = nvchips->token;
               NVPciChipsets[numUsed].resList = RES_SHARED_VGA;
               numUsed++;
            } else if ((*ppPci)->vendor == PCI_VENDOR_NVIDIA) {
               /* look for a compatible devices which may be newer than 
                  the NVKnownChipsets list above.  */
               switch(token & 0xfff0) {
               case 0x0170:   
               case 0x0180:
               case 0x0250:
               case 0x0280:
               case 0x0300:
               case 0x0310:
               case 0x0320:
               case 0x0330:
               case 0x0340:
                   NVChipsets[numUsed].token = token;
                   NVChipsets[numUsed].name = "Unknown NVIDIA chip";
                   NVPciChipsets[numUsed].numChipset = token;
                   NVPciChipsets[numUsed].PCIid = token;
                   NVPciChipsets[numUsed].resList = RES_SHARED_VGA;
                   numUsed++;
                   break;
               default:  break;  /* we don't recognize it */
               }
            }
        }
        ppPci++;
    }

    /* terminate the list */
    NVChipsets[numUsed].token = -1;
    NVChipsets[numUsed].name = NULL; 
    NVPciChipsets[numUsed].numChipset = -1;
    NVPciChipsets[numUsed].PCIid = -1;
    NVPciChipsets[numUsed].resList = RES_UNDEFINED;
d484 2
d490 3
a492 1
    if (numUsed <= 0) 
a520 2

    xfree(devSections);
a521 1

d569 1
d573 2
a577 3

    if(pNv->overlayAdaptor)
        NVResetVideo(pScrn);
d603 1
d609 1
d648 1
d656 1
a734 1
#if 0
a754 1
#endif
a755 1
/*
d779 1
a779 1
*/ 
d782 1
a782 1
xf86MonPtr
d785 1
d790 1
d803 1
d817 1
d888 1
a888 1
    if (xf86LoadSubModule(pScrn, "int10")) {
d894 12
a906 3
   
    xf86SetOperatingState(resVgaIo, pNv->pEnt->index, ResUnusedOpr);
    xf86SetOperatingState(resVgaMem, pNv->pEnt->index, ResDisableOpr);
d917 1
a917 1
        pNv->Chipset = xf86StringToToken(NVKnownChipsets, pScrn->chipset);
d921 1
a921 2
	pScrn->chipset = (char *)xf86TokenToString(NVKnownChipsets, 
                                                   pNv->Chipset);
d927 2
a928 5
	pNv->Chipset = (pNv->PciInfo->vendor << 16) | pNv->PciInfo->chipType;
	pScrn->chipset = (char *)xf86TokenToString(NVKnownChipsets, 
                                                   pNv->Chipset);
        if(!pScrn->chipset)
          pScrn->chipset = "Unknown NVIDIA chipset";
d975 1
a975 1
                if((pNv->Chipset & 0xffff) == 0x0018) {
d1144 3
a1146 5
    if (xf86GetOptValBool(pNv->Options, OPTION_FLAT_PANEL, &(pNv->FlatPanel))) {
        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "forcing %s usage\n",
                   pNv->FlatPanel ? "DFP" : "CRTC");
    } else {
        pNv->FlatPanel = -1;   /* autodetect later */
a1147 15

    pNv->FPDither = FALSE;
    if (xf86GetOptValBool(pNv->Options, OPTION_FP_DITHER, &(pNv->FPDither))) 
        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "enabling flat panel dither\n");

    if (xf86GetOptValInteger(pNv->Options, OPTION_CRTC_NUMBER, 
                                &pNv->forceCRTC)) 
    {
	if((pNv->forceCRTC < 0) || (pNv->forceCRTC > 1)) {
           pNv->forceCRTC = -1;
           xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, 
                      "Invalid CRTC number.  Must be 0 or 1\n");
        }
    } else pNv->forceCRTC = -1;

a1213 2
    pNv->alphaCursor = ((pNv->Chipset & 0x0ff0) >= 0x0110);

a1225 1
        case 0x0180:
a1226 1
        case 0x01F0:
d1229 2
a1230 8
        case 0x0200:
        case 0x0250:
        case 0x0280:
	case 0x0300:
	case 0x0310:
	case 0x0320:
	case 0x0330:
	case 0x0340:
d1236 6
d1261 36
a1320 1
        default:
a1346 5
    if(pNv->FlatPanel == 1) {
       clockRanges->interlaceAllowed = FALSE;
       clockRanges->doubleScanAllowed = FALSE;
    }

d1541 3
a1543 1
 * Initialise a new mode. 
d1561 4
a1564 2
    if(!(*pNv->ModeInit)(pScrn, mode))
        return FALSE;
d1571 2
a1572 1
    (*pNv->Restore)(pScrn, vgaReg, nvReg, FALSE);
d1609 4
a1612 1
    (*pNv->Restore)(pScrn, vgaReg, nvReg, pNv->Primary);
a1615 28
static void
NVDPMSSet(ScrnInfoPtr pScrn, int PowerManagementMode, int flags)
{
  unsigned char crtc1A;
  vgaHWPtr hwp = VGAHWPTR(pScrn);

  if (!pScrn->vtSema) return;

  crtc1A = hwp->readCrtc(hwp, 0x1A) & ~0xC0;

  switch (PowerManagementMode) {
  case DPMSModeStandby:  /* HSync: Off, VSync: On */
    crtc1A |= 0x80;
    break;
  case DPMSModeSuspend:  /* HSync: On, VSync: Off */
    crtc1A |= 0x40;
    break;
  case DPMSModeOff:      /* HSync: Off, VSync: Off */
    crtc1A |= 0xC0;
    break;
  case DPMSModeOn:       /* HSync: On, VSync: On */
  default:
    break;
  }

  hwp->writeCrtc(hwp, 0x1A, crtc1A);
}

d1669 1
a1850 1
#if 0
a1851 3
#else
    xf86DPMSInit(pScreen, NVDPMSSet, 0);
#endif
d1900 7
a1906 1
    (*pNv->Save)(pScrn, vgaReg, nvReg, pNv->Primary);
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d27 1
a27 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/nv/nv_driver.c,v 1.123 2004/01/13 19:03:28 mvojkovi Exp $ */
a32 3
const   OptionInfoRec * RivaAvailableOptions(int chipid, int busid);
Bool    RivaGetScrnInfoRec(PciChipsets *chips, int chip);

d51 2
a52 2
static ModeStatus NVValidMode(int scrnIndex, DisplayModePtr mode,
			      Bool verbose, int flags);
d73 1
a73 1
        NV_VERSION,
a86 1
  { 0x10DE002A, "Unknown TNT2" },
a110 3
#if defined(__powerpc__)
  { 0x10DE0179, "GeForce4 MX (Mac)" },
#else
a111 1
#endif
a121 3
#if defined(__powerpc__)
  { 0x10DE0189, "GeForce4 MX with AGP8X (Mac)" },
#endif
d143 1
d148 2
a149 4
  { 0x10DE0311, "GeForce FX 5600 Ultra" },
  { 0x10DE0312, "GeForce FX 5600" },
  { 0x10DE0313, "0x0313"},
  { 0x10DE0314, "GeForce FX 5600SE" },
d152 5
a156 3
  { 0x10DE031A, "GeForce FX Go5600" },
  { 0x10DE031B, "GeForce FX Go5650" },
  { 0x10DE031C, "Quadro FX Go700" },
d160 7
a166 35
  { 0x10DE0320, "GeForce FX 5200" },
  { 0x10DE0321, "GeForce FX 5200 Ultra" },
  { 0x10DE0322, "GeForce FX 5200" },
  { 0x10DE0323, "GeForce FX 5200SE" },
  { 0x10DE0324, "GeForce FX Go5200" },
  { 0x10DE0325, "GeForce FX Go5250" },
  { 0x10DE0328, "GeForce FX Go5200 32M/64M" },
#if defined(__powerpc__)
  { 0x10DE0329, "GeForce FX 5200 (Mac)" },
#else
  { 0x10DE0329, "0x0329" },
#endif
  { 0x10DE032A, "Quadro NVS 280 PCI" },
  { 0x10DE032B, "Quadro FX 500" },
  { 0x10DE032C, "GeForce FX Go5300" },
  { 0x10DE032D, "GeForce FX Go5100" },
  { 0x10DE032F, "0x032F" },
  { 0x10DE0330, "GeForce FX 5900 Ultra" },
  { 0x10DE0331, "GeForce FX 5900" },
  { 0x10DE0332, "GeForce FX 5900XT" },
  { 0x10DE0333, "GeForce FX 5950 Ultra" },
  { 0x10DE0334, "0x0334" },
  { 0x10DE0338, "Quadro FX 3000" },
  { 0x10DE0341, "GeForce FX 5700 Ultra" },
  { 0x10DE0342, "GeForce FX 5700" },
  { 0x10DE0343, "GeForce FX 5700LE" },
  { 0x10DE0344, "GeForce FX 5700VE" },
  { 0x10DE0345, "0x0345" },
  { 0x10DE0347, "GeForce FX Go5700" },
  { 0x10DE0348, "GeForce FX Go5700" },
  { 0x10DE0349, "0x0349" },
  { 0x10DE034B, "0x034B" },
  { 0x10DE034C, "Quadro FX Go1000" },
  { 0x10DE034E, "Quadro FX 1100" },
  { 0x10DE034F, "0x034F" },
a180 1
    "vgaHWUnmapMem",
d191 1
d218 2
d222 2
d225 1
a229 1
#ifdef XFree86LOADER
d232 1
a233 1
    "vbeDoEDID",
a235 1
#endif
a277 6
static const char *rivaSymbols[] = {
   "RivaGetScrnInfoRec",
   "RivaAvailableOptions",
    NULL
};

d305 1
d320 1
d337 9
d350 1
d362 1
d369 2
d401 1
a401 1
                          ramdacSymbols, shadowSymbols, rivaSymbols,
a421 7
    if(chipid == 0x12D20018) {
	if (!xf86LoadOneModule("riva128", NULL)) {
	    return NULL;
	} else
	    return RivaAvailableOptions(chipid, busid);
    }
    
a432 28
static Bool
NVGetScrnInfoRec(PciChipsets *chips, int chip)
{
    ScrnInfoPtr pScrn;

    pScrn = xf86ConfigPciEntity(NULL, 0, chip,
                                chips, NULL, NULL, NULL,
                                NULL, NULL);

    if(!pScrn) return FALSE;

    pScrn->driverVersion    = NV_VERSION;
    pScrn->driverName       = NV_DRIVER_NAME;
    pScrn->name             = NV_NAME;

    pScrn->Probe            = NVProbe;
    pScrn->PreInit          = NVPreInit;
    pScrn->ScreenInit       = NVScreenInit;
    pScrn->SwitchMode       = NVSwitchMode;
    pScrn->AdjustFrame      = NVAdjustFrame;
    pScrn->EnterVT          = NVEnterVT;
    pScrn->LeaveVT          = NVLeaveVT;
    pScrn->FreeScreen       = NVFreeScreen;
    pScrn->ValidMode        = NVValidMode;

    return TRUE;
}

d523 21
a543 13
        pciVideoPtr pPci;

        pPci = xf86GetPciInfoForEntity(usedChips[i]);
        if(pPci->vendor == PCI_VENDOR_NVIDIA_SGS) {
            if (!xf86LoadDrvSubModule(drv, "riva128")) {
                  continue;
            }
            xf86LoaderReqSymLists(rivaSymbols, NULL);
            if(RivaGetScrnInfoRec(NVPciChipsets, usedChips[i]))
                foundScreen = TRUE;
        } else {
            if(NVGetScrnInfoRec(NVPciChipsets, usedChips[i])) 
	        foundScreen = TRUE;
d557 1
d574 5
d580 1
a580 1
    NVSetStartAddress(pNv, startAddr);
d598 2
d612 2
d632 2
a633 1
    NVSync(pScrn);
d635 1
a635 1
    NVLockUnlock(pNv, 1);
a650 3

    if (pNv->DMAKickoffCallback)
        (*pNv->DMAKickoffCallback)(pScrnInfo);
d676 2
a678 1
        NVSync(pScrn);
d680 1
a680 1
        NVLockUnlock(pNv, 1);
d693 2
a696 2
    if (pNv->blitAdaptor)
        xfree(pNv->blitAdaptor);
d710 1
d724 1
a724 1
static ModeStatus
d727 2
d732 2
a733 2
static void
nvProbeDDC(ScrnInfoPtr pScrn, int index)
d735 4
a738 1
    vbeInfoPtr pVbe;
d740 15
a754 4
    if (xf86LoadSubModule(pScrn, "vbe")) {
        pVbe = VBEInit(NULL,index);
        ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
	vbeFree(pVbe);
d756 1
d759 30
d790 21
a810 1
Bool NVI2CInit(ScrnInfoPtr pScrn)
d812 14
a825 1
    char *mod = "i2c";
d827 14
a840 2
    if (xf86LoadSubModule(pScrn, mod)) {
        xf86LoaderReqSymLists(i2cSymbols,NULL);
d842 2
a843 6
        mod = "ddc";
        if(xf86LoadSubModule(pScrn, mod)) {
            xf86LoaderReqSymLists(ddcSymbols, NULL);
            return NVDACi2cInit(pScrn);
        } 
    }
d845 4
a848 2
    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
              "Couldn't load %s module.  DDC probing can't be done\n", mod);
d850 5
a854 1
    return FALSE;
d863 2
a864 1
    int i, max_width, max_height;
d873 2
d978 1
d981 1
a981 1
    if (!xf86SetDepthBpp(pScrn, 0, 0, 0, Support32bppFb)) {
a988 1
            case 16:
d992 8
d1042 2
d1096 4
d1173 2
a1174 2
    if (xf86GetOptValInteger(pNv->Options, OPTION_CRTC_NUMBER,
                             &pNv->CRTCnumber)) 
d1176 2
a1177 2
	if((pNv->CRTCnumber < 0) || (pNv->CRTCnumber > 1)) {
           pNv->CRTCnumber = -1;
d1181 1
a1181 3
    } else {
        pNv->CRTCnumber = -1; /* autodetect later */
    }
d1197 4
a1200 2
	if (pNv->PciInfo->memBase[1] != 0) {
	    pNv->FbAddress = pNv->PciInfo->memBase[1] & 0xff800000;
d1226 3
a1228 2
	if (pNv->PciInfo->memBase[0] != 0) {
	    pNv->IOAddress = pNv->PciInfo->memBase[0] & 0xffffc000;
d1251 28
a1278 1
    pNv->Architecture = (pNv->Chipset & 0x0f00) >> 4;
d1280 7
a1286 7
    if(pNv->Architecture < NV_ARCH_10)
        pNv->Architecture = NV_ARCH_04;

    NVCommonSetup(pScrn);

    if (pNv->FBDev) {
       pScrn->videoRam = fbdevHWGetVidmem(pScrn)/1024;
d1288 6
a1293 1
       pScrn->videoRam = pNv->RamAmountKBytes;
d1295 1
a1295 1
    xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "VideoRAM: %d kBytes\n",
d1314 15
a1328 3
    pNv->FbUsableSize = pNv->FbMapSize - (128 * 1024);
    pNv->ScratchBufferSize = (pNv->Architecture < NV_ARCH_10) ? 8192 : 16384;
    pNv->ScratchBufferStart = pNv->FbUsableSize - pNv->ScratchBufferSize;
d1335 3
d1340 2
a1341 2
    clockRanges->minClock = pNv->MinVClockFreqKHz;
    clockRanges->maxClock = pNv->MaxVClockFreqKHz;
d1344 1
a1344 2
       ((pNv->Chipset & 0x0ff0) == 0x0150) ||
       ((pNv->Chipset & 0x0ff0) >= 0x0300))
d1347 1
a1347 3
    } else {
        /* No NV2x chips support interlaced modes and the only
           NV1x chips that do are NV10 and NV15 */
a1348 1
    }
a1355 8
    if(pNv->Architecture < NV_ARCH_10) {
       max_width = (pScrn->bitsPerPixel > 16) ? 2032 : 2048;
       max_height = 2048;
    } else {
       max_width = (pScrn->bitsPerPixel > 16) ? 4080 : 4096;
       max_height = 4096;
    }

d1364 2
a1365 2
                          NULL, 256, max_width,
                          512, 128, max_height,
d1368 1
a1368 1
                          pNv->ScratchBufferStart,
d1479 1
d1482 9
d1507 1
d1514 4
d1532 1
d1535 6
d1561 2
d1568 1
a1568 4
    vgaReg = &hwp->ModeReg;
    nvReg = &pNv->ModeReg;

    if(!NVDACInit(pScrn, mode))
a1570 7
    NVLockUnlock(pNv, 0);
    if(pNv->twoHeads) {
        VGA_WR08(pNv->PCIO, 0x03D4, 0x44);
        VGA_WR08(pNv->PCIO, 0x03D5, nvReg->crtcOwner);
        NVLockUnlock(pNv, 0);
    }

d1573 2
d1576 1
a1576 1
    NVDACRestore(pScrn, vgaReg, nvReg, FALSE);
d1583 2
a1584 2
	VGA_WR08(pNv->PCIO, 0x3d4, 0x46);
	tmp = VGA_RD08(pNv->PCIO, 0x3d5);
d1586 1
a1586 1
	VGA_WR08(pNv->PCIO, 0x3d5, tmp);
d1610 1
a1610 8
    if(pNv->twoHeads) {
        VGA_WR08(pNv->PCIO, 0x03D4, 0x44);
        VGA_WR08(pNv->PCIO, 0x03D5, nvReg->crtcOwner);
        NVLockUnlock(pNv, 0);
    }

    NVLockUnlock(pNv, 0);

d1613 1
a1613 1
    NVDACRestore(pScrn, vgaReg, nvReg, pNv->Primary);
a1616 47
static void NVBacklightEnable(NVPtr pNv,  Bool on)
{
    /* This is done differently on each laptop.  Here we
       define the ones we know for sure. */

#if defined(__powerpc__)
    if((pNv->Chipset == 0x10DE0110) || 
       (pNv->Chipset == 0x10DE0179) || 
       (pNv->Chipset == 0x10DE0189) || 
       (pNv->Chipset == 0x10DE0329))
    {
       /* NV17,18,34 Apple iMac, iBook, PowerBook */
      CARD32 tmp_pmc, tmp_pcrt;
      tmp_pmc = pNv->PMC[0x10F0/4] & 0x7FFFFFFF;
      tmp_pcrt = pNv->PCRTC0[0x081C/4] & 0xFFFFFFFC;
      if(on) {
          tmp_pmc |= (1 << 31);
          tmp_pcrt |= 0x1;
      }
      pNv->PMC[0x10F0/4] = tmp_pmc;
      pNv->PCRTC0[0x081C/4] = tmp_pcrt;
    }
#endif
}

static void
NVDPMSSetLCD(ScrnInfoPtr pScrn, int PowerManagementMode, int flags)
{
  NVPtr pNv = NVPTR(pScrn);

  if (!pScrn->vtSema) return;

  switch (PowerManagementMode) {
  case DPMSModeStandby:  /* HSync: Off, VSync: On */
  case DPMSModeSuspend:  /* HSync: On, VSync: Off */
  case DPMSModeOff:      /* HSync: Off, VSync: Off */
    NVBacklightEnable(pNv, 0);
    break;
  case DPMSModeOn:       /* HSync: On, VSync: On */
    NVBacklightEnable(pNv, 1);
  default:
    break;
  }
  vgaHWDPMSSet(pScrn, PowerManagementMode, flags);
}


a1641 3
  /* vgaHWDPMSSet will merely cut the dac output */
  vgaHWDPMSSet(pScrn, PowerManagementMode, flags);

d1656 1
d1660 1
a1660 1
    int width, height, displayWidth, offscreenHeight;
d1668 2
d1672 1
d1676 2
a1677 3
        if (!NVMapMemFBDev(pScrn)) {
            return FALSE;
        }
d1679 2
a1680 3
        if (!NVMapMem(pScrn)) {
            return FALSE;
         }
d1682 2
a1683 1

d1690 1
d1698 1
d1705 2
d1711 2
d1732 8
a1739 3
    if (!miSetVisualTypes(pScrn->depth, 
                          miGetDefaultVisualMask(pScrn->depth), 8,
                          pScrn->defaultVisual))
d1741 1
d1744 2
d1789 2
d1810 2
a1814 5
    offscreenHeight = pNv->ScratchBufferStart /
                     (pScrn->displayWidth * pScrn->bitsPerPixel >> 3);
    if(offscreenHeight > 32767)
        offscreenHeight = 32767;

d1818 2
a1819 1
    AvailFBArea.y2 = offscreenHeight;
d1829 2
d1835 2
d1849 2
d1854 1
a1854 1
	(pNv->FBDev ? fbdevHWLoadPalette : NVDACLoadPalette), 
d1858 2
a1871 3
           xf86DisableRandR();
           xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                      "Driver rotation enabled, RandR disabled\n");
d1877 10
a1886 4
    if(pNv->FlatPanel)
       xf86DPMSInit(pScreen, NVDPMSSetLCD, 0);
    else
       xf86DPMSInit(pScreen, NVDPMSSet, 0);
d1891 1
a1891 2
    if(pNv->Rotate == 0)
       NVInitVideo(pScreen);
d1906 2
d1911 6
d1931 2
a1932 1
    NVDACSave(pScrn, vgaReg, nvReg, pNv->Primary);
@


