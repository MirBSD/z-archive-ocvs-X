head	1.2;
access;
symbols
	tg-mergetmp-2:1.2
	cvs-200410241530:1.1.1.4
	cvs-200410012000:1.1.1.4
	cvs-200407221130:1.1.1.4
	cvs-200407141120:1.1.1.4
	cvs-200406231010:1.1.1.4
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.4
	XFree86_4_4_0:1.1.9.2
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.03.07.18.37.35;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.20.07.33;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.07.33;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.36.42;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.19.48;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.27.16.33.10;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.23.54;	author tg;	state Exp;
branches;
next	1.1.9.2;

1.1.9.2
date	2004.03.05.22.30.12;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@semi-automagic merge of these files (ie, I've skipped through the diffs,
and most of that was done by cvs or that weird script of some minutes ago)
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_driver.c,v 1.185 2004/02/27 17:29:24 twini Exp $ */
/*
 * SiS driver main code
 *
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author: Thomas Winischhofer <thomas@@winischhofer.net>
 *	- driver entirely rewritten since 2001, only basic structure taken from
 *	  old code (except sis_dri.c, sis_shadow.c, sis_accel.c and parts of
 *	  sis_dga.c; these were mostly taken over; sis_dri.c was changed for
 *	  new versions of the DRI layer)
 *
 * This notice covers the entire driver code unless otherwise indicated.
 *
 * Formerly based on code which is
 * 	     Copyright (C) 1998, 1999 by Alan Hourihane, Wigan, England.
 * Written by:
 *           Alan Hourihane <alanh@@fairlite.demon.co.uk>,
 *           Mike Chapman <mike@@paranoia.com>,
 *           Juanjo Santamarta <santamarta@@ctv.es>,
 *           Mitani Hiroshi <hmitani@@drl.mei.co.jp>,
 *           David Thomas <davtom@@dream.org.uk>.
 */

#include "fb.h"
#include "mibank.h"
#include "micmap.h"
#include "xf86.h"
#include "xf86Priv.h"
#include "xf86_OSproc.h"
#include "xf86Resources.h"
#include "xf86_ansic.h"
#include "dixstruct.h"
#include "xf86Version.h"
#include "xf86PciInfo.h"
#include "xf86Pci.h"
#include "xf86cmap.h"
#include "vgaHW.h"
#include "xf86RAC.h"
#include "shadowfb.h"
#include "vbe.h"

#include "sis_shadow.h"

#include "mipointer.h"
#include "mibstore.h"
 
#include "sis.h"
#include "sis_regs.h"
#include "sis_vb.h"
#include "sis_dac.h"

#include "sis_driver.h"

#define _XF86DGA_SERVER_
#include "extensions/xf86dgastr.h"

#include "globals.h"

#define DPMS_SERVER
#include "extensions/dpms.h"

#if (XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,99,0,0)) || (defined(XvExtension))
#include "xf86xv.h"
#include "Xv.h"
#endif

#ifdef XF86DRI
#include "dri.h"
#endif

/* Globals (yes, these ARE really required to be global) */

#ifdef SISDUALHEAD
static int      	SISEntityIndex = -1;
#endif

#ifdef SISMERGED
#ifdef SISXINERAMA
static Bool 		SiSnoPanoramiXExtension = TRUE;
int 			SiSXineramaPixWidth = 0;
int 			SiSXineramaPixHeight = 0;
int 			SiSXineramaNumScreens = 0;
SiSXineramaData		*SiSXineramadataPtr = NULL;
static int 		SiSXineramaGeneration;

int SiSProcXineramaQueryVersion(ClientPtr client);
int SiSProcXineramaGetState(ClientPtr client);
int SiSProcXineramaGetScreenCount(ClientPtr client);
int SiSProcXineramaGetScreenSize(ClientPtr client);
int SiSProcXineramaIsActive(ClientPtr client);
int SiSProcXineramaQueryScreens(ClientPtr client);
int SiSSProcXineramaDispatch(ClientPtr client);
#endif
#endif

/*
 * This is intentionally screen-independent.  It indicates the binding
 * choice made in the first PreInit.
 */
static int pix24bpp = 0;

/* 
 * This contains the functions needed by the server after loading the driver
 * module.  It must be supplied, and gets passed back by the SetupProc
 * function in the dynamic case.  In the static case, a reference to this
 * is compiled in, and this requires that the name of this DriverRec be
 * an upper-case version of the driver name.
 */

DriverRec SIS = {
    SIS_CURRENT_VERSION,
    SIS_DRIVER_NAME,
    SISIdentify,
    SISProbe,
    SISAvailableOptions,
    NULL,
    0
};

static SymTabRec SISChipsets[] = {
    { PCI_CHIP_SIS5597,     "SIS5597/5598" },
    { PCI_CHIP_SIS530,      "SIS530/620" },
    { PCI_CHIP_SIS6326,     "SIS6326/AGP/DVD" },
    { PCI_CHIP_SIS300,      "SIS300/305" },
    { PCI_CHIP_SIS630,      "SIS630/730" },
    { PCI_CHIP_SIS540,      "SIS540" },
    { PCI_CHIP_SIS315,      "SIS315" },
    { PCI_CHIP_SIS315H,     "SIS315H" },
    { PCI_CHIP_SIS315PRO,   "SIS315PRO" },
    { PCI_CHIP_SIS550,	    "SIS550" },
    { PCI_CHIP_SIS650,      "SIS650/M650/651/740" },
    { PCI_CHIP_SIS330,      "SIS330(Xabre)" },
    { PCI_CHIP_SIS660,      "SIS660/661FX/M661FX/M661MX/741/741GX/M741/760/M760" },
    { -1,                   NULL }
};

static PciChipsets SISPciChipsets[] = {
    { PCI_CHIP_SIS5597,     PCI_CHIP_SIS5597,   RES_SHARED_VGA },
    { PCI_CHIP_SIS530,      PCI_CHIP_SIS530,    RES_SHARED_VGA },
    { PCI_CHIP_SIS6326,     PCI_CHIP_SIS6326,   RES_SHARED_VGA },
    { PCI_CHIP_SIS300,      PCI_CHIP_SIS300,    RES_SHARED_VGA },
    { PCI_CHIP_SIS630,      PCI_CHIP_SIS630,    RES_SHARED_VGA },
    { PCI_CHIP_SIS540,      PCI_CHIP_SIS540,    RES_SHARED_VGA },
    { PCI_CHIP_SIS550,      PCI_CHIP_SIS550,    RES_SHARED_VGA },
    { PCI_CHIP_SIS315,      PCI_CHIP_SIS315,    RES_SHARED_VGA },
    { PCI_CHIP_SIS315H,     PCI_CHIP_SIS315H,   RES_SHARED_VGA },
    { PCI_CHIP_SIS315PRO,   PCI_CHIP_SIS315PRO, RES_SHARED_VGA },
    { PCI_CHIP_SIS650,      PCI_CHIP_SIS650,    RES_SHARED_VGA },
    { PCI_CHIP_SIS330,      PCI_CHIP_SIS330,    RES_SHARED_VGA },
    { PCI_CHIP_SIS660,      PCI_CHIP_SIS660,    RES_SHARED_VGA },
    { -1,                   -1,                 RES_UNDEFINED }
};

static const char *xaaSymbols[] = {
    "XAACopyROP",
    "XAACreateInfoRec",
    "XAADestroyInfoRec",
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,0,0)
    "XAAFillSolidRects",
#endif
    "XAAFillMono8x8PatternRects",
    "XAAHelpPatternROP",
    "XAAInit",
    NULL
};

static const char *vgahwSymbols[] = {
    "vgaHWFreeHWRec",
    "vgaHWGetHWRec",
    "vgaHWGetIOBase",
    "vgaHWGetIndex",
    "vgaHWInit",
    "vgaHWLock",
    "vgaHWMapMem",
    "vgaHWUnmapMem",
    "vgaHWProtect",
    "vgaHWRestore",
    "vgaHWSave",
    "vgaHWSaveScreen",
    "vgaHWUnlock",
    NULL
};

static const char *fbSymbols[] = {
    "fbPictureInit",
    "fbScreenInit",
    NULL
};

static const char *shadowSymbols[] = {
    "ShadowFBInit",
    NULL
};

static const char *ramdacSymbols[] = {
    "xf86CreateCursorInfoRec",
    "xf86DestroyCursorInfoRec",
    "xf86InitCursor",
    NULL
};

static const char *ddcSymbols[] = {
    "xf86PrintEDID",
    "xf86SetDDCproperties",
    "xf86InterpretEDID",
    NULL
};

static const char *int10Symbols[] = {
    "xf86FreeInt10",
    "xf86InitInt10",
    NULL
};

static const char *vbeSymbols[] = {
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    "VBEInit",
#else
    "VBEExtendedInit",
#endif
    "vbeDoEDID",
    "vbeFree",
    "VBEGetVBEInfo",
    "VBEFreeVBEInfo",
    "VBEGetModeInfo",
    "VBEFreeModeInfo",
    "VBESaveRestore",
    "VBESetVBEMode",
    "VBEGetVBEMode",
    "VBESetDisplayStart",
    "VBESetGetLogicalScanlineLength",
    NULL
};

#ifdef XF86DRI
static const char *drmSymbols[] = {
    "drmAddMap",
    "drmAgpAcquire",
    "drmAgpAlloc",
    "drmAgpBase",
    "drmAgpBind",
    "drmAgpEnable",
    "drmAgpFree",
    "drmAgpGetMode",
    "drmAgpRelease",
    "drmCtlInstHandler",
    "drmGetInterruptFromBusID",
    "drmSiSAgpInit",
    NULL
};

static const char *driSymbols[] = {
    "DRICloseScreen",
    "DRICreateInfoRec",
    "DRIDestroyInfoRec",
    "DRIFinishScreenInit",
    "DRIGetSAREAPrivate",
    "DRILock",
    "DRIQueryVersion",
    "DRIScreenInit",
    "DRIUnlock",
    "GlxSetVisualConfigs",
#ifdef SISNEWDRI2
    "DRICreatePCIBusID"
#endif        
    NULL
};
#endif

#ifdef XFree86LOADER

static MODULESETUPPROTO(sisSetup);

static XF86ModuleVersionInfo sisVersRec =
{
    SIS_DRIVER_NAME,
    MODULEVENDORSTRING,
    MODINFOSTRING1,
    MODINFOSTRING2,
    XF86_VERSION_CURRENT,
    SIS_MAJOR_VERSION, SIS_MINOR_VERSION, SIS_PATCHLEVEL,
    ABI_CLASS_VIDEODRV,         /* This is a video driver */
    ABI_VIDEODRV_VERSION,
    MOD_CLASS_VIDEODRV,
    {0,0,0,0}
};

XF86ModuleData sisModuleData = { &sisVersRec, sisSetup, NULL };

pointer
sisSetup(pointer module, pointer opts, int *errmaj, int *errmin)
{
    static Bool setupDone = FALSE;

    if(!setupDone) {
       setupDone = TRUE;
       xf86AddDriver(&SIS, module, 0);
       LoaderRefSymLists(vgahwSymbols, fbSymbols, xaaSymbols,
			 shadowSymbols, ramdacSymbols,
			 vbeSymbols, int10Symbols,
#ifdef XF86DRI
			 drmSymbols, driSymbols,
#endif
			 NULL);
       return (pointer)TRUE;
    }

    if(errmaj) *errmaj = LDR_ONCEONLY;
    return NULL;
}

#endif /* XFree86LOADER */

static Bool
SISGetRec(ScrnInfoPtr pScrn)
{
    /*
     * Allocate an SISRec, and hook it into pScrn->driverPrivate.
     * pScrn->driverPrivate is initialised to NULL, so we can check if
     * the allocation has already been done.
     */
    if(pScrn->driverPrivate != NULL) return TRUE;

    pScrn->driverPrivate = xnfcalloc(sizeof(SISRec), 1);
    
    /* Initialise it to 0 */
    memset(pScrn->driverPrivate, 0, sizeof(SISRec));

    return TRUE;
}

static void
SISFreeRec(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif

    /* Just to make sure... */
    if(!pSiS) return;

#ifdef SISDUALHEAD
    pSiSEnt = pSiS->entityPrivate;
#endif

    if(pSiS->pstate) xfree(pSiS->pstate);
    pSiS->pstate = NULL;
    if(pSiS->fonts) xfree(pSiS->fonts);
    pSiS->fonts = NULL;

#ifdef SISDUALHEAD
    if(pSiSEnt) {
       if(!pSiS->SecondHead) {
          /* Free memory only if we are first head; in case of an error
	   * during init of the second head, the server will continue -
	   * and we need the BIOS image and SiS_Private for the first
	   * head.
	   */
	  if(pSiSEnt->BIOS) xfree(pSiSEnt->BIOS);
          pSiSEnt->BIOS = pSiS->BIOS = NULL;
	  if(pSiSEnt->SiS_Pr) xfree(pSiSEnt->SiS_Pr);
          pSiSEnt->SiS_Pr = pSiS->SiS_Pr = NULL;
	  if(pSiSEnt->RenderAccelArray) xfree(pSiSEnt->RenderAccelArray);
	  pSiSEnt->RenderAccelArray = pSiS->RenderAccelArray = NULL;
       } else {
      	  pSiS->BIOS = NULL;
	  pSiS->SiS_Pr = NULL;
	  pSiS->RenderAccelArray = NULL;
       }
    } else {
#endif
       if(pSiS->BIOS) xfree(pSiS->BIOS);
       pSiS->BIOS = NULL;
       if(pSiS->SiS_Pr) xfree(pSiS->SiS_Pr);
       pSiS->SiS_Pr = NULL;
       if(pSiS->RenderAccelArray) xfree(pSiS->RenderAccelArray);
       pSiS->RenderAccelArray = NULL;
#ifdef SISDUALHEAD
    }
#endif
#ifdef SISMERGED
    if(pSiS->CRT2HSync) xfree(pSiS->CRT2HSync);
    pSiS->CRT2HSync = NULL;
    if(pSiS->CRT2VRefresh) xfree(pSiS->CRT2VRefresh);
    pSiS->CRT2VRefresh = NULL;
    if(pSiS->MetaModes) xfree(pSiS->MetaModes);
    pSiS->MetaModes = NULL;
    if(pSiS->CRT2pScrn) {
       if(pSiS->CRT2pScrn->modes) {
          while(pSiS->CRT2pScrn->modes)
             xf86DeleteMode(&pSiS->CRT2pScrn->modes, pSiS->CRT2pScrn->modes);
       }
       if(pSiS->CRT2pScrn->monitor) {
          if(pSiS->CRT2pScrn->monitor->Modes) {
	     while(pSiS->CRT2pScrn->monitor->Modes)
	        xf86DeleteMode(&pSiS->CRT2pScrn->monitor->Modes, pSiS->CRT2pScrn->monitor->Modes);
	  }
	  if(pSiS->CRT2pScrn->monitor->DDC) xfree(pSiS->CRT2pScrn->monitor->DDC);
          xfree(pSiS->CRT2pScrn->monitor);
       }
       xfree(pSiS->CRT2pScrn);
       pSiS->CRT2pScrn = NULL;
    }
    if(pSiS->CRT1Modes) {
       if(pSiS->CRT1Modes != pScrn->modes) {
          if(pScrn->modes) {
             pScrn->currentMode = pScrn->modes;
             do {
                DisplayModePtr p = pScrn->currentMode->next;
                if(pScrn->currentMode->Private)
                   xfree(pScrn->currentMode->Private);
                xfree(pScrn->currentMode);
                pScrn->currentMode = p;
             } while(pScrn->currentMode != pScrn->modes);
          }
          pScrn->currentMode = pSiS->CRT1CurrentMode;
          pScrn->modes = pSiS->CRT1Modes;
          pSiS->CRT1CurrentMode = NULL;
          pSiS->CRT1Modes = NULL;
       }
    }
#endif
    if(pSiS->pVbe) vbeFree(pSiS->pVbe);
    pSiS->pVbe = NULL;
    if(pScrn->driverPrivate == NULL)
        return;
    xfree(pScrn->driverPrivate);
    pScrn->driverPrivate = NULL;
}

static void
SISDisplayPowerManagementSet(ScrnInfoPtr pScrn, int PowerManagementMode, int flags)
{
    SISPtr pSiS = SISPTR(pScrn);
    BOOLEAN docrt1 = TRUE, docrt2 = TRUE;
    unsigned char sr1=0, cr17=0, cr63=0, sr11=0, pmreg=0, sr7=0;
    unsigned char p1_13=0, p2_0=0, oldpmreg=0;
    BOOLEAN backlight = TRUE;

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
          "SISDisplayPowerManagementSet(%d)\n",PowerManagementMode);

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       if(pSiS->SecondHead) docrt2 = FALSE;
       else                 docrt1 = FALSE;
    }
#endif

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    if(docrt2) {
       if(pSiS->VBFlags & CRT2_LCD) {
          if(((pSiS->VGAEngine == SIS_300_VGA) &&
             (pSiS->VBFlags & (VB_301|VB_30xBDH|VB_LVDS))) ||
            ((pSiS->VGAEngine == SIS_315_VGA) &&
             ((pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) == VB_LVDS))) {
#ifdef SISDUALHEAD
             if(pSiS->DualHeadMode) {
	        if(!pSiS->BlankCRT2) {
		   inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		   if(pSiS->sishw_ext.jChipType >= SIS_661) pSiS->LCDon &= 0x0f;
		}
	     } else
#endif
	     if(!pSiS->Blank) {
	        inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		if(pSiS->sishw_ext.jChipType >= SIS_661) pSiS->LCDon &= 0x0f;
	     }
          }
       }
    }

    switch (PowerManagementMode) {

       case DPMSModeOn:      /* HSync: On, VSync: On */
            if(docrt1)  pSiS->Blank = FALSE;
#ifdef SISDUALHEAD
	    else	pSiS->BlankCRT2 = FALSE;
#endif
            sr1   = 0x00;
            cr17  = 0x80;
	    pmreg = 0x00;
	    cr63  = 0x00;
	    sr7   = 0x10;
	    sr11  = (pSiS->LCDon & 0x0C);
	    p2_0  = 0x20;
	    p1_13 = 0x00;
	    backlight = TRUE;
            break;

       case DPMSModeSuspend: /* HSync: On, VSync: Off */
            if(docrt1)  pSiS->Blank = TRUE;
#ifdef SISDUALHEAD
	    else        pSiS->BlankCRT2 = TRUE;
#endif
            sr1   = 0x20;
	    cr17  = 0x80;
	    pmreg = 0x80;
	    cr63  = 0x40;
	    sr7   = 0x00;
	    sr11  = 0x08;
	    p2_0  = 0x40;
	    p1_13 = 0x80;
	    backlight = FALSE;
            break;

       case DPMSModeStandby: /* HSync: Off, VSync: On */
            if(docrt1)  pSiS->Blank = TRUE;
#ifdef SISDUALHEAD
	    else        pSiS->BlankCRT2 = TRUE;
#endif
            sr1   = 0x20;
	    cr17  = 0x80;
	    pmreg = 0x40;
	    cr63  = 0x40;
	    sr7   = 0x00;
	    sr11  = 0x08;
	    p2_0  = 0x80;
	    p1_13 = 0x40;
	    backlight = FALSE;
            break;

       case DPMSModeOff:     /* HSync: Off, VSync: Off */
            if(docrt1)  pSiS->Blank = TRUE;
#ifdef SISDUALHEAD
	    else        pSiS->BlankCRT2 = TRUE;
#endif
            sr1   = 0x20;
	    cr17  = 0x00;
	    pmreg = 0xc0;
	    cr63  = 0x40;
	    sr7   = 0x00;
	    sr11  = 0x08;
	    p2_0  = 0xc0;
	    p1_13 = 0xc0;
	    backlight = FALSE;
	    break;

       default:
	    return;
    }

    if(docrt2) {
       if(pSiS->VGAEngine == SIS_315_VGA) {
          if(pSiS->VBFlags & CRT2_LCD) {
	     if(pSiS->VBFlags & VB_CHRONTEL) {
	        if(backlight) {
	           SiS_Chrontel701xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	        } else {
	           SiS_Chrontel701xBLOff(pSiS->SiS_Pr);
                }
	     }
          }
       }
    }

    if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
       if((docrt2 && (pSiS->VBFlags & CRT2_LCD)) || (docrt1 && (pSiS->VBFlags & CRT1_LCDA))) {
          if(backlight) {
	     SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	  } else {
             SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
	  }
       }
    }

    if(docrt1) {
       setSISIDXREG(SISSR, 0x01, ~0x20, sr1);    /* Set/Clear "Display On" bit */
       switch(pSiS->VGAEngine) {
       case SIS_OLD_VGA:
       case SIS_530_VGA:
            inSISIDXREG(SISSR, 0x11, oldpmreg);
            setSISIDXREG(SISCR, 0x17, 0x7f, cr17);
	    setSISIDXREG(SISSR, 0x11, 0x3f, pmreg);
	    break;
       case SIS_315_VGA:
            if((!pSiS->CRT1off) && ((!(pSiS->VBFlags & CRT1_LCDA)) || (pSiS->VBFlags & VB_301C))) {
               setSISIDXREG(SISCR, pSiS->myCR63, 0xbf, cr63);
	       setSISIDXREG(SISSR, 0x07, 0xef, sr7);
	    }
	    /* fall through */
       default:
            if((!(pSiS->VBFlags & CRT1_LCDA)) || (pSiS->VBFlags & VB_301C)) {
               inSISIDXREG(SISSR, 0x1f, oldpmreg);
               if(!pSiS->CRT1off) {
	          setSISIDXREG(SISSR, 0x1f, 0x3f, pmreg);
	       }
	    }
	    /* TODO: Check if Chrontel TV is active and in slave mode,
	     * don't go into power-saving mode this in this case!
	     */
       }
       oldpmreg &= 0xc0;
    }

    if(docrt2) {
       if(pSiS->VBFlags & CRT2_LCD) {
          if(((pSiS->VGAEngine == SIS_300_VGA) &&
              (pSiS->VBFlags & (VB_301|VB_30xBDH|VB_LVDS))) ||
             ((pSiS->VGAEngine == SIS_315_VGA) &&
              ((pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) == VB_LVDS))) {
	     if(pSiS->sishw_ext.jChipType >= SIS_661) {
	        setSISIDXREG(SISSR, 0x11, ~0xfc, sr11);
	     } else {
                setSISIDXREG(SISSR, 0x11, ~0x0c, sr11);
	     }
          }
          if(pSiS->VGAEngine == SIS_300_VGA) {
             if((pSiS->VBFlags & (VB_301B|VB_301C|VB_302B)) &&
                (!(pSiS->VBFlags & VB_30xBDH))) {
	        setSISIDXREG(SISPART1, 0x13, 0x3f, p1_13);
	     }
          } else if(pSiS->VGAEngine == SIS_315_VGA) {
             if((pSiS->VBFlags & (VB_301B|VB_301C|VB_302B)) &&
                (!(pSiS->VBFlags & VB_30xBDH))) {
	        setSISIDXREG(SISPART2, 0x00, 0x1f, p2_0);
	     }
          }
       } else if(pSiS->VBFlags & CRT2_VGA) {
          if(pSiS->VBFlags & (VB_301B|VB_301C|VB_302B)) {
	     setSISIDXREG(SISPART2, 0x00, 0x1f, p2_0);
          }
       }
    }

    if((docrt1) && (pmreg != oldpmreg) && ((!(pSiS->VBFlags & CRT1_LCDA)) || (pSiS->VBFlags & VB_301C))) {
       outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
       usleep(10000);
       outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */
    }

}

/* Mandatory */
static void
SISIdentify(int flags)
{
    xf86PrintChipsets(SIS_NAME, "driver for SiS chipsets", SISChipsets);
}

#if 0
/* This won't work as long as noone added the symbols to the symlist */
static void
SISCalculateGammaRamp(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   int i, j, nramp;
   unsigned short *ramp[3];
   float gamma_max[3], gamma_prescale[3], framp;

   gamma_max[0] = (float)pSiS->GammaBriR / 1000;
   gamma_max[1] = (float)pSiS->GammaBriG / 1000;
   gamma_max[2] = (float)pSiS->GammaBriB / 1000;
   gamma_prescale[0] = (float)pSiS->GammaPBriR / 1000;
   gamma_prescale[1] = (float)pSiS->GammaPBriG / 1000;
   gamma_prescale[2] = (float)pSiS->GammaPBriB / 1000;

   if(!(nramp = xf86GetGammaRampSize(pScrn->pScreen))) return;

   for(i=0; i<3; i++) {
      ramp[i] = (unsigned short *)xalloc(nramp * sizeof(unsigned short));
      if(!ramp[i]) {
         if(ramp[0]) { xfree(ramp[0]); ramp[0] = NULL; }
	 if(ramp[1]) { xfree(ramp[1]); ramp[1] = NULL; }
         return;
      }
   }

   for(i = 0; i < 3; i++) {
      int fullscale = 65535 * gamma_max[i];
      float dramp = 1. / (nramp - 1);
      float invgamma=0.0, v;

      switch(i) {
      case 0: invgamma = 1. / pScrn->gamma.red; break;
      case 1: invgamma = 1. / pScrn->gamma.green; break;
      case 2: invgamma = 1. / pScrn->gamma.blue; break;
      }

      for(j = 0; j < nramp; j++) {
         framp = pow(gamma_prescale[i] * j * dramp, invgamma);

         v = (fullscale < 0) ? (65535 + fullscale * framp) :
	 		       fullscale * framp;
	 if(v < 0) v = 0;
	 else if(v > 65535) v = 65535;
	 ramp[i][j] = (unsigned short)v;
      }
   }

   xf86ChangeGammaRamp(pScrn->pScreen, nramp, ramp[0], ramp[1], ramp[2]);

   xfree(ramp[0]);
   xfree(ramp[1]);
   xfree(ramp[2]);
   ramp[0] = ramp[1] = ramp[2] = NULL;
}
#endif

static void
SISErrorLog(ScrnInfoPtr pScrn, const char *format, ...)
{
    va_list ap;
    static const char *str = "**************************************************\n";

    va_start(ap, format);
    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, str);
    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
    	"                      ERROR:\n");
    xf86VDrvMsgVerb(pScrn->scrnIndex, X_ERROR, 1, format, ap);
    va_end(ap);
    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
    	"                  END OF MESSAGE\n");
    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, str);
}

/* Mandatory */
static Bool
SISProbe(DriverPtr drv, int flags)
{
    int     i;
    GDevPtr *devSections;
    int     *usedChips;
    int     numDevSections;
    int     numUsed;
    Bool    foundScreen = FALSE;

    /*
     * The aim here is to find all cards that this driver can handle,
     * and for the ones not already claimed by another driver, claim the
     * slot, and allocate a ScrnInfoRec.
     *
     * This should be a minimal probe, and it should under no circumstances
     * change the state of the hardware.  Because a device is found, don't
     * assume that it will be used.  Don't do any initialisations other than
     * the required ScrnInfoRec initialisations.  Don't allocate any new
     * data structures.
     *
     */

    /*
     * Next we check, if there has been a chipset override in the config file.
     * For this we must find out if there is an active device section which
     * is relevant, i.e., which has no driver specified or has THIS driver
     * specified.
     */

    if((numDevSections = xf86MatchDevice(SIS_DRIVER_NAME, &devSections)) <= 0) {
       /*
        * There's no matching device section in the config file, so quit
        * now.
        */
       return FALSE;
    }

    /*
     * We need to probe the hardware first.  We then need to see how this
     * fits in with what is given in the config file, and allow the config
     * file info to override any contradictions.
     */

    /*
     * All of the cards this driver supports are PCI, so the "probing" just
     * amounts to checking the PCI data that the server has already collected.
     */
    if(xf86GetPciVideoInfo() == NULL) {
       /*
        * We won't let anything in the config file override finding no
        * PCI video cards at all.  This seems reasonable now, but we'll see.
        */
       return FALSE;
    }

    numUsed = xf86MatchPciInstances(SIS_NAME, PCI_VENDOR_SIS,
               		SISChipsets, SISPciChipsets, devSections,
               		numDevSections, drv, &usedChips);

    /* Free it since we don't need that list after this */
    xfree(devSections);
    if(numUsed <= 0) return FALSE;

    if(flags & PROBE_DETECT) {
        foundScreen = TRUE;
    } else for(i = 0; i < numUsed; i++) {
        ScrnInfoPtr pScrn;
#ifdef SISDUALHEAD
	EntityInfoPtr pEnt;
#endif

        /* Allocate a ScrnInfoRec and claim the slot */
        pScrn = NULL;

        if((pScrn = xf86ConfigPciEntity(pScrn, 0, usedChips[i],
                                         SISPciChipsets, NULL, NULL,
                                         NULL, NULL, NULL))) {
            /* Fill in what we can of the ScrnInfoRec */
            pScrn->driverVersion    = SIS_CURRENT_VERSION;
            pScrn->driverName       = SIS_DRIVER_NAME;
            pScrn->name             = SIS_NAME;
            pScrn->Probe            = SISProbe;
            pScrn->PreInit          = SISPreInit;
            pScrn->ScreenInit       = SISScreenInit;
            pScrn->SwitchMode       = SISSwitchMode;
            pScrn->AdjustFrame      = SISAdjustFrame;
            pScrn->EnterVT          = SISEnterVT;
            pScrn->LeaveVT          = SISLeaveVT;
            pScrn->FreeScreen       = SISFreeScreen;
            pScrn->ValidMode        = SISValidMode;
            foundScreen = TRUE;
        }
#ifdef SISDUALHEAD
	pEnt = xf86GetEntityInfo(usedChips[i]);

	if(pEnt->chipset == PCI_CHIP_SIS630 || pEnt->chipset == PCI_CHIP_SIS540 ||
	   pEnt->chipset == PCI_CHIP_SIS650 || pEnt->chipset == PCI_CHIP_SIS550 ||
	   pEnt->chipset == PCI_CHIP_SIS315 || pEnt->chipset == PCI_CHIP_SIS315H ||
	   pEnt->chipset == PCI_CHIP_SIS315PRO || pEnt->chipset == PCI_CHIP_SIS330 ||
	   pEnt->chipset == PCI_CHIP_SIS300 || pEnt->chipset == PCI_CHIP_SIS660) {

	    SISEntPtr pSiSEnt = NULL;
	    DevUnion  *pPriv;

	    xf86SetEntitySharable(usedChips[i]);
	    if(SISEntityIndex < 0) {
	       SISEntityIndex = xf86AllocateEntityPrivateIndex();
	    }
	    pPriv = xf86GetEntityPrivate(pScrn->entityList[0], SISEntityIndex);
	    if(!pPriv->ptr) {
	       pPriv->ptr = xnfcalloc(sizeof(SISEntRec), 1);
	       pSiSEnt = pPriv->ptr;
	       pSiSEnt->lastInstance = -1;
	       pSiSEnt->DisableDual = FALSE;
	       pSiSEnt->ErrorAfterFirst = FALSE;
	       pSiSEnt->MapCountIOBase = pSiSEnt->MapCountFbBase = 0;
	       pSiSEnt->FbBase = pSiSEnt->IOBase = NULL;
  	       pSiSEnt->forceUnmapIOBase = FALSE;
	       pSiSEnt->forceUnmapFbBase = FALSE;
	       pSiSEnt->HWCursorCBufNum = pSiSEnt->HWCursorMBufNum = 0;
#ifdef __alpha__
	       pSiSEnt->MapCountIOBaseDense = 0;
	       pSiSEnt->IOBaseDense = NULL;
	       pSiSEnt->forceUnmapIOBaseDense = FALSE;
#endif
	    } else {
	       pSiSEnt = pPriv->ptr;
	    }
	    pSiSEnt->lastInstance++;
	    xf86SetEntityInstanceForScreen(pScrn, pScrn->entityList[0],
	                                   pSiSEnt->lastInstance);
	}
#endif
    }
    xfree(usedChips);
    return foundScreen;
}


/* If monitor section has no HSync/VRefresh data,
 * derive it from DDC data. Done by common layer
 * since 4.3.99.14.
 */
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,14,0)
static void
SiSSetSyncRangeFromEdid(ScrnInfoPtr pScrn, int flag)
{
   MonPtr      mon = pScrn->monitor;
   xf86MonPtr  ddc = mon->DDC;
   int         i,j;
   float       myhhigh, myhlow;
   int         myvhigh, myvlow;
   unsigned char temp;
   const myhddctiming myhtiming[11] = {
       { 1, 0x20, 31.6 }, /* rounded up by .1 */
       { 1, 0x02, 35.3 },
       { 1, 0x04, 37.6 },
       { 1, 0x08, 38.0 },
       { 1, 0x01, 38.0 },
       { 2, 0x40, 47.0 },
       { 2, 0x80, 48.2 },
       { 2, 0x08, 48.5 },
       { 2, 0x04, 56.6 },
       { 2, 0x02, 60.1 },
       { 2, 0x01, 80.1 }
   };
   const myvddctiming myvtiming[10] = {
       { 1, 0x02, 56 },
       { 1, 0x01, 60 },
       { 2, 0x08, 60 },
       { 2, 0x04, 70 },
       { 1, 0x08, 72 },
       { 2, 0x80, 72 },
       { 1, 0x04, 75 },
       { 2, 0x40, 75 },
       { 2, 0x02, 75 },
       { 2, 0x01, 75 }
   };
   /* "Future modes"; we only check the really high ones */
   const myddcstdmodes mystdmodes[8] = {
       { 1280, 1024, 85, 91.1  },
       { 1600, 1200, 60, 75.0  },
       { 1600, 1200, 65, 81.3  },
       { 1600, 1200, 70, 87.5  },
       { 1600, 1200, 75, 93.8  },
       { 1600, 1200, 85, 106.3 },
       { 1920, 1440, 60, 90.0  },
       { 1920, 1440, 75, 112.5 }
   };

   if(flag) { /* HSync */
      for(i = 0; i < 4; i++) {
    	 if(ddc->det_mon[i].type == DS_RANGES) {
            mon->nHsync = 1;
            mon->hsync[0].lo = ddc->det_mon[i].section.ranges.min_h;
            mon->hsync[0].hi = ddc->det_mon[i].section.ranges.max_h;
            return;
         }
      }
      /* If no sync ranges detected in detailed timing table, we
       * derive them from supported VESA modes. */
      myhlow = myhhigh = 0.0;
      for(i=0; i<11; i++) {
         if(myhtiming[i].whichone == 1) temp = ddc->timings1.t1;
	 else                           temp = ddc->timings1.t2;
	 if(temp & myhtiming[i].mask) {
	    if((i==0) || (myhlow > myhtiming[i].rate))
	            myhlow = myhtiming[i].rate;
	 }
	 if(myhtiming[10-i].whichone == 1) temp = ddc->timings1.t1;
	 else                              temp = ddc->timings1.t2;
	 if(temp & myhtiming[10-i].mask) {
	    if((i==0) || (myhhigh < myhtiming[10-i].rate))
	            myhhigh = myhtiming[10-i].rate;
	 }
      }
      for(i=0;i<STD_TIMINGS;i++) {
	 if(ddc->timings2[i].hsize > 256) {
            for(j=0; j<8; j++) {
	       if((ddc->timings2[i].hsize == mystdmodes[j].hsize) &&
	          (ddc->timings2[i].vsize == mystdmodes[j].vsize) &&
		  (ddc->timings2[i].refresh == mystdmodes[j].refresh)) {
		  if(mystdmodes[j].hsync > myhhigh)
		     myhhigh = mystdmodes[j].hsync;
	       }
	    }
	 }
      }
      if((myhhigh) && (myhlow)) {
         mon->nHsync = 1;
	 mon->hsync[0].lo = myhlow - 0.1;
	 mon->hsync[0].hi = myhhigh;
      }


   } else {  /* Vrefresh */

      for(i = 0; i < 4; i++) {
         if(ddc->det_mon[i].type == DS_RANGES) {
            mon->nVrefresh = 1;
            mon->vrefresh[0].lo = ddc->det_mon[i].section.ranges.min_v;
            mon->vrefresh[0].hi = ddc->det_mon[i].section.ranges.max_v;
            return;
         }
      }

      myvlow = myvhigh = 0;
      for(i=0; i<10; i++) {
         if(myvtiming[i].whichone == 1) temp = ddc->timings1.t1;
	 else                           temp = ddc->timings1.t2;
	 if(temp & myvtiming[i].mask) {
	    if((i==0) || (myvlow > myvtiming[i].rate))
	           myvlow = myvtiming[i].rate;
	 }
	 if(myvtiming[9-i].whichone == 1) temp = ddc->timings1.t1;
	 else                             temp = ddc->timings1.t2;
	 if(temp & myvtiming[9-i].mask) {
	    if((i==0) || (myvhigh < myvtiming[9-i].rate))
	           myvhigh = myvtiming[9-i].rate;
	 }
      }
      for(i=0;i<STD_TIMINGS;i++) {
	 if(ddc->timings2[i].hsize > 256) {
            for(j=0; j<8; j++) {
	       if((ddc->timings2[i].hsize == mystdmodes[j].hsize) &&
	          (ddc->timings2[i].vsize == mystdmodes[j].vsize) &&
		  (ddc->timings2[i].refresh == mystdmodes[j].refresh)) {
		  if(mystdmodes[j].refresh > myvhigh)
		     myvhigh = mystdmodes[j].refresh;
	       }
	    }
	 }
      }
      if((myvhigh) && (myvlow)) {
         mon->nVrefresh = 1;
	 mon->vrefresh[0].lo = myvlow;
	 mon->vrefresh[0].hi = myvhigh;
      }

    }
}
#endif

/* Some helper functions for MergedFB mode */

#ifdef SISMERGED

/* Helper function for CRT2 monitor vrefresh/hsync options
 * (Code base from mga driver)
 */
static int
SiSStrToRanges(range *r, char *s, int max)
{
   float num = 0.0;
   int rangenum = 0;
   Bool gotdash = FALSE;
   Bool nextdash = FALSE;
   char* strnum = NULL;
   do {
      switch(*s) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '.':
         if(strnum == NULL) {
            strnum = s;
            gotdash = nextdash;
            nextdash = FALSE;
         }
         break;
      case '-':
      case ' ':
      case 0:
         if(strnum == NULL) break;
         sscanf(strnum, "%f", &num);
	 strnum = NULL;
         if(gotdash) {
            r[rangenum - 1].hi = num;
         } else {
            r[rangenum].lo = num;
            r[rangenum].hi = num;
            rangenum++;
         }
         if(*s == '-') nextdash = (rangenum != 0);
	 else if(rangenum >= max) return rangenum;
         break;
      default:
         return 0;
      }

   } while(*(s++) != 0);

   return rangenum;
}

/* Copy and link two modes form mergedfb mode
 * (Code base taken from mga driver)
 * Copys mode i, links the result to dest, and returns it.
 * Links i and j in Private record.
 * If dest is NULL, return value is copy of i linked to itself.
 * For mergedfb auto-config, we only check the dimension
 * against virtualX/Y, if they were user-provided.
 */
static DisplayModePtr
SiSCopyModeNLink(ScrnInfoPtr pScrn, DisplayModePtr dest,
                 DisplayModePtr i, DisplayModePtr j,
		 SiSScrn2Rel srel)
{
    SISPtr pSiS = SISPTR(pScrn);
    DisplayModePtr mode;
    int dx = 0,dy = 0;

    if(!((mode = xalloc(sizeof(DisplayModeRec))))) return dest;
    memcpy(mode, i, sizeof(DisplayModeRec));
    if(!((mode->Private = xalloc(sizeof(SiSMergedDisplayModeRec))))) {
       xfree(mode);
       return dest;
    }
    ((SiSMergedDisplayModePtr)mode->Private)->CRT1 = i;
    ((SiSMergedDisplayModePtr)mode->Private)->CRT2 = j;
    ((SiSMergedDisplayModePtr)mode->Private)->CRT2Position = srel;
    mode->PrivSize = 0;

    switch(srel) {
    case sisLeftOf:
    case sisRightOf:
       if(!(pScrn->display->virtualX)) {
          dx = i->HDisplay + j->HDisplay;
       } else {
          dx = min(pScrn->virtualX, i->HDisplay + j->HDisplay);
       }
       dx -= mode->HDisplay;
       if(!(pScrn->display->virtualY)) {
          dy = max(i->VDisplay, j->VDisplay);
       } else {
          dy = min(pScrn->virtualY, max(i->VDisplay, j->VDisplay));
       }
       dy -= mode->VDisplay;
       break;
    case sisAbove:
    case sisBelow:
       if(!(pScrn->display->virtualY)) {
          dy = i->VDisplay + j->VDisplay;
       } else {
          dy = min(pScrn->virtualY, i->VDisplay + j->VDisplay);
       }
       dy -= mode->VDisplay;
       if(!(pScrn->display->virtualX)) {
          dx = max(i->HDisplay, j->HDisplay);
       } else {
          dx = min(pScrn->virtualX, max(i->HDisplay, j->HDisplay));
       }
       dx -= mode->HDisplay;
       break;
    case sisClone:
       if(!(pScrn->display->virtualX)) {
          dx = max(i->HDisplay, j->HDisplay);
       } else {
          dx = min(pScrn->virtualX, max(i->HDisplay, j->HDisplay));
       }
       dx -= mode->HDisplay;
       if(!(pScrn->display->virtualY)) {
          dy = max(i->VDisplay, j->VDisplay);
       } else {
	  dy = min(pScrn->virtualY, max(i->VDisplay, j->VDisplay));
       }
       dy -= mode->VDisplay;
       break;
    }
    mode->HDisplay += dx;
    mode->HSyncStart += dx;
    mode->HSyncEnd += dx;
    mode->HTotal += dx;
    mode->VDisplay += dy;
    mode->VSyncStart += dy;
    mode->VSyncEnd += dy;
    mode->VTotal += dy;
    mode->Clock = 0;

    if( ((mode->HDisplay * ((pScrn->bitsPerPixel + 7) / 8) * mode->VDisplay) > pSiS->maxxfbmem) ||
        (mode->HDisplay > 4088) ||
	(mode->VDisplay > 4096) ) {

       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
       		"Skipped %dx%d, not enough video RAM or beyond hardware specs\n",
		mode->HDisplay, mode->VDisplay);
       xfree(mode->Private);
       xfree(mode);

       return dest;
    }

#ifdef SISXINERAMA
    if(srel != sisClone) {
       pSiS->AtLeastOneNonClone = TRUE;
    }
#endif

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
    	"Merged %dx%d and %dx%d to %dx%d%s\n",
	i->HDisplay, i->VDisplay, j->HDisplay, j->VDisplay,
	mode->HDisplay, mode->VDisplay, (srel == sisClone) ? " (Clone)" : "");

    mode->next = mode;
    mode->prev = mode;

    if(dest) {
       mode->next = dest->next; 	/* Insert node after "dest" */
       dest->next->prev = mode;
       mode->prev = dest;
       dest->next = mode;
    }

    return mode;
}

/* Helper function to find a mode from a given name
 * (Code base taken from mga driver)
 */
static DisplayModePtr
SiSGetModeFromName(char* str, DisplayModePtr i)
{
    DisplayModePtr c = i;
    if(!i) return NULL;
    do {
       if(strcmp(str, c->name) == 0) return c;
       c = c->next;
    } while(c != i);
    return NULL;
}

static DisplayModePtr
SiSFindWidestTallestMode(DisplayModePtr i, Bool tallest)
{
    DisplayModePtr c = i, d = NULL;
    int max = 0;
    if(!i) return NULL;
    do {
       if(tallest) {
          if(c->VDisplay > max) {
             max = c->VDisplay;
	     d = c;
          }
       } else {
          if(c->HDisplay > max) {
             max = c->HDisplay;
	     d = c;
          }
       }
       c = c->next;
    } while(c != i);
    return d;
}

static DisplayModePtr
SiSGenerateModeListFromLargestModes(ScrnInfoPtr pScrn,
		    DisplayModePtr i, DisplayModePtr j,
		    SiSScrn2Rel srel)
{
#ifdef SISXINERAMA
    SISPtr pSiS = SISPTR(pScrn);
#endif
    DisplayModePtr mode1 = NULL;
    DisplayModePtr mode2 = NULL;
    DisplayModePtr result = NULL;

#ifdef SISXINERAMA
    pSiS->AtLeastOneNonClone = FALSE;
#endif

    switch(srel) {
    case sisLeftOf:
    case sisRightOf:
       mode1 = SiSFindWidestTallestMode(i, FALSE);
       mode2 = SiSFindWidestTallestMode(j, FALSE);
       break;
    case sisAbove:
    case sisBelow:
       mode1 = SiSFindWidestTallestMode(i, TRUE);
       mode2 = SiSFindWidestTallestMode(j, TRUE);
       break;
    case sisClone:
       mode1 = i;
       mode2 = j;
    }

    if(mode1 && mode2) {
       return(SiSCopyModeNLink(pScrn, result, mode1, mode2, srel));
    } else {
       return NULL;
    }
}

/* Generate the merged-fb mode modelist from metamodes
 * (Code base taken from mga driver)
 */
static DisplayModePtr
SiSGenerateModeListFromMetaModes(ScrnInfoPtr pScrn, char* str,
		    DisplayModePtr i, DisplayModePtr j,
		    SiSScrn2Rel srel)
{
#ifdef SISXINERAMA
    SISPtr pSiS = SISPTR(pScrn);
#endif
    char* strmode = str;
    char modename[256];
    Bool gotdash = FALSE;
    SiSScrn2Rel sr;
    DisplayModePtr mode1 = NULL;
    DisplayModePtr mode2 = NULL;
    DisplayModePtr result = NULL;

#ifdef SISXINERAMA
    pSiS->AtLeastOneNonClone = FALSE;
#endif

    do {
        switch(*str) {
        case 0:
        case '-':
        case ' ':
           if((strmode != str)) {

              strncpy(modename, strmode, str - strmode);
              modename[str - strmode] = 0;

              if(gotdash) {
                 if(mode1 == NULL) return NULL;
                 mode2 = SiSGetModeFromName(modename, j);
                 if(!mode2) {
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "Mode \"%s\" is not a supported mode for CRT2\n", modename);
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "Skipping metamode \"%s-%s\".\n", mode1->name, modename);
                    mode1 = NULL;
                 }
              } else {
                 mode1 = SiSGetModeFromName(modename, i);
                 if(!mode1) {
                    char* tmps = str;
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "Mode \"%s\" is not a supported mode for CRT1\n", modename);
                    gotdash = FALSE;
                    while(*tmps == ' ') tmps++;
                    if(*tmps == '-') { 							/* skip the next mode */
                       tmps++;
                       while((*tmps == ' ') && (*tmps != 0)) tmps++; 			/* skip spaces */
                       while((*tmps != ' ') && (*tmps != '-') && (*tmps != 0)) tmps++; 	/* skip modename */
                       strncpy(modename,strmode,tmps - strmode);
                       modename[tmps - strmode] = 0;
                       str = tmps-1;
                    }
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "Skipping metamode \"%s\".\n", modename);
                    mode1 = NULL;
                 }
              }
              gotdash = FALSE;
           }
           strmode = str + 1;
           gotdash |= (*str == '-');

           if(*str != 0) break;
	   /* Fall through otherwise */

        default:
           if(!gotdash && mode1) {
              sr = srel;
              if(!mode2) {
                 mode2 = SiSGetModeFromName(mode1->name, j);
                 sr = sisClone;
              }
              if(!mode2) {
                 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                     "Mode: \"%s\" is not a supported mode for CRT2\n", mode1->name);
                 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                     "Skipping metamode \"%s\".\n", modename);
                 mode1 = NULL;
              } else {
                 result = SiSCopyModeNLink(pScrn, result, mode1, mode2, sr);
                 mode1 = NULL;
                 mode2 = NULL;
              }
           }
           break;

        }

    } while(*(str++) != 0);

    return result;
}

static DisplayModePtr
SiSGenerateModeList(ScrnInfoPtr pScrn, char* str,
		    DisplayModePtr i, DisplayModePtr j,
		    SiSScrn2Rel srel)
{
   if(str != NULL) {
      return(SiSGenerateModeListFromMetaModes(pScrn, str, i, j, srel));
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
      	"No MetaModes given, linking %s modes by default\n",
	(srel == sisClone) ? "first" :
	   (((srel == sisLeftOf) || (srel == sisRightOf)) ? "widest" :  "tallest"));
      return(SiSGenerateModeListFromLargestModes(pScrn, i, j, srel));
   }
}

static void
SiSRecalcDefaultVirtualSize(ScrnInfoPtr pScrn)
{
    DisplayModePtr mode, bmode;
    int max;
    static const char *str = "MergedFB: Virtual %s %d\n";

    if(!(pScrn->display->virtualX)) {
       mode = bmode = pScrn->modes;
       max = 0;
       do {
          if(mode->HDisplay > max) max = mode->HDisplay;
          mode = mode->next;
       } while(mode != bmode);
       pScrn->virtualX = max;
       pScrn->displayWidth = max;
       xf86DrvMsg(pScrn->scrnIndex, X_PROBED, str, "width", max);
    }
    if(!(pScrn->display->virtualY)) {
       mode = bmode = pScrn->modes;
       max = 0;
       do {
          if(mode->VDisplay > max) max = mode->VDisplay;
          mode = mode->next;
       } while(mode != bmode);
       pScrn->virtualY = max;
       xf86DrvMsg(pScrn->scrnIndex, X_PROBED, str, "height", max);
    }
}

static void
SiSMergedFBSetDpi(ScrnInfoPtr pScrn1, ScrnInfoPtr pScrn2, SiSScrn2Rel srel)
{
   SISPtr pSiS = SISPTR(pScrn1);
   MessageType from = X_DEFAULT;
   xf86MonPtr DDC1 = (xf86MonPtr)(pScrn1->monitor->DDC);
   xf86MonPtr DDC2 = (xf86MonPtr)(pScrn2->monitor->DDC);
   int ddcWidthmm = 0, ddcHeightmm = 0;
   const char *dsstr = "MergedFB: Display dimensions: (%d, %d) mm\n";

   /* This sets the DPI for MergedFB mode. The problem is that
    * this can never be exact, because the output devices may
    * have different dimensions. This function tries to compromise
    * through a few assumptions, and it just calculates an average DPI
    * value for both monitors.
    */

   /* Given DisplaySize should regard BOTH monitors */
   pScrn1->widthmm = pScrn1->monitor->widthmm;
   pScrn1->heightmm = pScrn1->monitor->heightmm;

   /* Get DDC display size; if only either CRT1 or CRT2 provided these,
    * assume equal dimensions for both, otherwise add dimensions
    */
   if( (DDC1 && (DDC1->features.hsize > 0 && DDC1->features.vsize > 0)) &&
       (DDC2 && (DDC2->features.hsize > 0 && DDC2->features.vsize > 0)) ) {
      ddcWidthmm = max(DDC1->features.hsize, DDC2->features.hsize) * 10;
      ddcHeightmm = max(DDC1->features.vsize, DDC2->features.vsize) * 10;
      switch(srel) {
      case sisLeftOf:
      case sisRightOf:
         ddcWidthmm = (DDC1->features.hsize + DDC2->features.hsize) * 10;
	 break;
      case sisAbove:
      case sisBelow:
         ddcHeightmm = (DDC1->features.vsize + DDC2->features.vsize) * 10;
      default:
	 break;
      }
   } else if(DDC1 && (DDC1->features.hsize > 0 && DDC1->features.vsize > 0)) {
      ddcWidthmm = DDC1->features.hsize * 10;
      ddcHeightmm = DDC1->features.vsize * 10;
      switch(srel) {
      case sisLeftOf:
      case sisRightOf:
         ddcWidthmm *= 2;
	 break;
      case sisAbove:
      case sisBelow:
         ddcHeightmm *= 2;
      default:
	 break;
      }
   } else if(DDC2 && (DDC2->features.hsize > 0 && DDC2->features.vsize > 0) ) {
      ddcWidthmm = DDC2->features.hsize * 10;
      ddcHeightmm = DDC2->features.vsize * 10;
      switch(srel) {
      case sisLeftOf:
      case sisRightOf:
         ddcWidthmm *= 2;
	 break;
      case sisAbove:
      case sisBelow:
         ddcHeightmm *= 2;
      default:
	 break;
      }
   }

   if(monitorResolution > 0) {

      /* Set command line given values (overrules given options) */
      pScrn1->xDpi = monitorResolution;
      pScrn1->yDpi = monitorResolution;
      from = X_CMDLINE;

   } else if(pSiS->MergedFBXDPI) {

      /* Set option-wise given values (overrule DisplaySize) */
      pScrn1->xDpi = pSiS->MergedFBXDPI;
      pScrn1->yDpi = pSiS->MergedFBYDPI;
      from = X_CONFIG;

   } else if(pScrn1->widthmm > 0 || pScrn1->heightmm > 0) {

      /* Set values calculated from given DisplaySize */
      from = X_CONFIG;
      if(pScrn1->widthmm > 0) {
	 pScrn1->xDpi = (int)((double)pScrn1->virtualX * 25.4 / pScrn1->widthmm);
      }
      if(pScrn1->heightmm > 0) {
	 pScrn1->yDpi = (int)((double)pScrn1->virtualY * 25.4 / pScrn1->heightmm);
      }
      xf86DrvMsg(pScrn1->scrnIndex, from, dsstr, pScrn1->widthmm, pScrn1->heightmm);

    } else if(ddcWidthmm && ddcHeightmm) {

      /* Set values from DDC-provided display size */
      from = X_PROBED;
      xf86DrvMsg(pScrn1->scrnIndex, from, dsstr, ddcWidthmm, ddcHeightmm );
      pScrn1->widthmm = ddcWidthmm;
      pScrn1->heightmm = ddcHeightmm;
      if(pScrn1->widthmm > 0) {
	 pScrn1->xDpi = (int)((double)pScrn1->virtualX * 25.4 / pScrn1->widthmm);
      }
      if(pScrn1->heightmm > 0) {
	 pScrn1->yDpi = (int)((double)pScrn1->virtualY * 25.4 / pScrn1->heightmm);
      }

    } else {

      pScrn1->xDpi = pScrn1->yDpi = DEFAULT_DPI;

    }

    /* Sanity check */
    if(pScrn1->xDpi > 0 && pScrn1->yDpi <= 0)
       pScrn1->yDpi = pScrn1->xDpi;
    if(pScrn1->yDpi > 0 && pScrn1->xDpi <= 0)
       pScrn1->xDpi = pScrn1->yDpi;

    pScrn2->xDpi = pScrn1->xDpi;
    pScrn2->yDpi = pScrn1->yDpi;

    xf86DrvMsg(pScrn1->scrnIndex, from, "MergedFB: DPI set to (%d, %d)\n",
	       pScrn1->xDpi, pScrn1->yDpi);
}

/* Pseudo-Xinerama extension for MergedFB mode */
#ifdef SISXINERAMA

static void
SiSUpdateXineramaScreenInfo(ScrnInfoPtr pScrn1)
{
    SISPtr pSiS = SISPTR(pScrn1);
    int crt1scrnnum = 0, crt2scrnnum = 1;
    int x1=0, x2=0, y1=0, y2=0, h1=0, h2=0, w1=0, w2=0;
    DisplayModePtr currentMode, firstMode;
    Bool infochanged = FALSE;

    if(!pSiS->MergedFB) return;

    if(SiSnoPanoramiXExtension) return;

    if(!SiSXineramadataPtr) return;

    if(pSiS->CRT2IsScrn0) {
       crt1scrnnum = 1;
       crt2scrnnum = 0;
    }

    /* Attention: Usage of RandR may lead into virtual X and Y values
     * actually smaller than our MetaModes! To avoid this, we calculate
     * the maxCRT fields here (and not somewhere else, like in CopyNLink)
     *
     * *** For now: RandR will be disabled if SiS pseudo-Xinerama is on
     */

    if((pSiS->SiSXineramaVX != pScrn1->virtualX) || (pSiS->SiSXineramaVY != pScrn1->virtualY)) {

       if(!(pScrn1->modes)) return;

       pSiS->maxCRT1_X1 = pSiS->maxCRT1_X2 = 0;
       pSiS->maxCRT1_Y1 = pSiS->maxCRT1_Y2 = 0;
       pSiS->maxCRT2_X1 = pSiS->maxCRT2_X2 = 0;
       pSiS->maxCRT2_Y1 = pSiS->maxCRT2_Y2 = 0;
       pSiS->maxClone_X1 = pSiS->maxClone_X2 = 0;
       pSiS->maxClone_Y1 = pSiS->maxClone_Y2 = 0;

       currentMode = firstMode = pScrn1->modes;

       do {

          DisplayModePtr p = currentMode->next;
          DisplayModePtr i = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT1;
          DisplayModePtr j = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT2;
          SiSScrn2Rel srel = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT2Position;

          if((i->HDisplay <= pScrn1->virtualX) && (j->HDisplay <= pScrn1->virtualX) &&
             (i->VDisplay <= pScrn1->virtualY) && (j->VDisplay <= pScrn1->virtualY)) {

             if(srel != sisClone) {
                if(pSiS->maxCRT1_X1 <= i->HDisplay) {
                   pSiS->maxCRT1_X1 = i->HDisplay;      /* Largest CRT1 mode */
                   if(pSiS->maxCRT1_X2 < j->HDisplay) {
                      pSiS->maxCRT1_X2 = j->HDisplay;   /* Largest X of CRT2 mode displayed with largest CRT1 mode */
                   }
                }
                if(pSiS->maxCRT2_X2 <= j->HDisplay) {
                   pSiS->maxCRT2_X2 = j->HDisplay;      /* Largest CRT2 mode */
                   if(pSiS->maxCRT2_X1 < i->HDisplay) {
                      pSiS->maxCRT2_X1 = i->HDisplay;   /* Largest X of CRT1 mode displayed with largest CRT2 mode */
                   }
                }
                if(pSiS->maxCRT1_Y1 <= i->VDisplay) {
                   pSiS->maxCRT1_Y1 = i->VDisplay;
                   if(pSiS->maxCRT1_Y2 < j->VDisplay) {
                      pSiS->maxCRT1_Y2 = j->VDisplay;
                   }
                }
                if(pSiS->maxCRT2_Y2 <= j->VDisplay) {
                   pSiS->maxCRT2_Y2 = j->VDisplay;
                   if(pSiS->maxCRT2_Y1 < i->VDisplay) {
                      pSiS->maxCRT2_Y1 = i->VDisplay;
                   }
                }
             } else {
                if(pSiS->maxClone_X1 < i->HDisplay) {
                   pSiS->maxClone_X1 = i->HDisplay;
                }
                if(pSiS->maxClone_X2 < j->HDisplay) {
                   pSiS->maxClone_X2 = j->HDisplay;
                }
                if(pSiS->maxClone_Y1 < i->VDisplay) {
                   pSiS->maxClone_Y1 = i->VDisplay;
                }
                if(pSiS->maxClone_Y2 < j->VDisplay) {
                   pSiS->maxClone_Y2 = j->VDisplay;
                }
             }
          }
          currentMode = p;

       } while((currentMode) && (currentMode != firstMode));

       pSiS->SiSXineramaVX = pScrn1->virtualX;
       pSiS->SiSXineramaVY = pScrn1->virtualY;
       infochanged = TRUE;

    }

    switch(pSiS->CRT2Position) {
    case sisLeftOf:
       x1 = min(pSiS->maxCRT1_X2, pScrn1->virtualX - pSiS->maxCRT1_X1);
       if(x1 < 0) x1 = 0;
       y1 = 0;
       w1 = pScrn1->virtualX - x1;
       h1 = pScrn1->virtualY;
       x2 = 0;
       y2 = 0;
       w2 = max(pSiS->maxCRT2_X2, pScrn1->virtualX - pSiS->maxCRT2_X1);
       if(w2 > pScrn1->virtualX) w2 = pScrn1->virtualX;
       h2 = pScrn1->virtualY;
       break;
    case sisRightOf:
       x1 = 0;
       y1 = 0;
       w1 = max(pSiS->maxCRT1_X1, pScrn1->virtualX - pSiS->maxCRT1_X2);
       if(w1 > pScrn1->virtualX) w1 = pScrn1->virtualX;
       h1 = pScrn1->virtualY;
       x2 = min(pSiS->maxCRT2_X1, pScrn1->virtualX - pSiS->maxCRT2_X2);
       if(x2 < 0) x2 = 0;
       y2 = 0;
       w2 = pScrn1->virtualX - x2;
       h2 = pScrn1->virtualY;
       break;
    case sisAbove:
       x1 = 0;
       y1 = min(pSiS->maxCRT1_Y2, pScrn1->virtualY - pSiS->maxCRT1_Y1);
       if(y1 < 0) y1 = 0;
       w1 = pScrn1->virtualX;
       h1 = pScrn1->virtualY - y1;
       x2 = 0;
       y2 = 0;
       w2 = pScrn1->virtualX;
       h2 = max(pSiS->maxCRT2_Y2, pScrn1->virtualY - pSiS->maxCRT2_Y1);
       if(h2 > pScrn1->virtualY) h2 = pScrn1->virtualY;
       break;
    case sisBelow:
       x1 = 0;
       y1 = 0;
       w1 = pScrn1->virtualX;
       h1 = max(pSiS->maxCRT1_Y1, pScrn1->virtualY - pSiS->maxCRT1_Y2);
       if(h1 > pScrn1->virtualY) h1 = pScrn1->virtualY;
       x2 = 0;
       y2 = min(pSiS->maxCRT2_Y1, pScrn1->virtualY - pSiS->maxCRT2_Y2);
       if(y2 < 0) y2 = 0;
       w2 = pScrn1->virtualX;
       h2 = pScrn1->virtualY - y2;
    default:
       break;
    }

    SiSXineramadataPtr[crt1scrnnum].x = x1;
    SiSXineramadataPtr[crt1scrnnum].y = y1;
    SiSXineramadataPtr[crt1scrnnum].width = w1;
    SiSXineramadataPtr[crt1scrnnum].height = h1;
    SiSXineramadataPtr[crt2scrnnum].x = x2;
    SiSXineramadataPtr[crt2scrnnum].y = y2;
    SiSXineramadataPtr[crt2scrnnum].width = w2;
    SiSXineramadataPtr[crt2scrnnum].height = h2;

    if(infochanged) {
       xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
          "Pseudo-Xinerama: CRT1 (Screen %d) (%d,%d)-(%d,%d)\n",
          crt1scrnnum, x1, y1, w1+x1-1, h1+y1-1);
       xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
          "Pseudo-Xinerama: CRT2 (Screen %d) (%d,%d)-(%d,%d)\n",
          crt2scrnnum, x2, y2, w2+x2-1, h2+y2-1);
    }
}

/* Proc */

int
SiSProcXineramaQueryVersion(ClientPtr client)
{
    xPanoramiXQueryVersionReply	  rep;
    register int		  n;

    REQUEST_SIZE_MATCH(xPanoramiXQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SIS_XINERAMA_MAJOR_VERSION;
    rep.minorVersion = SIS_XINERAMA_MINOR_VERSION;
    if(client->swapped) {
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swaps(&rep.majorVersion, n);
        swaps(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xPanoramiXQueryVersionReply), (char *)&rep);
    return (client->noClientException);
}

int
SiSProcXineramaGetState(ClientPtr client)
{
    REQUEST(xPanoramiXGetStateReq);
    WindowPtr			pWin;
    xPanoramiXGetStateReply	rep;
    register int		n;

    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
    pWin = LookupWindow(stuff->window, client);
    if(!pWin) return BadWindow;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.state = !SiSnoPanoramiXExtension;
    if(client->swapped) {
       swaps (&rep.sequenceNumber, n);
       swapl (&rep.length, n);
       swaps (&rep.state, n);
    }
    WriteToClient(client, sizeof(xPanoramiXGetStateReply), (char *)&rep);
    return client->noClientException;
}

int
SiSProcXineramaGetScreenCount(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenCountReq);
    WindowPtr				pWin;
    xPanoramiXGetScreenCountReply	rep;
    register int			n;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
    pWin = LookupWindow(stuff->window, client);
    if(!pWin) return BadWindow;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.ScreenCount = SiSXineramaNumScreens;
    if(client->swapped) {
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swaps(&rep.ScreenCount, n);
    }
    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), (char *)&rep);
    return client->noClientException;
}

int
SiSProcXineramaGetScreenSize(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenSizeReq);
    WindowPtr				pWin;
    xPanoramiXGetScreenSizeReply	rep;
    register int			n;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
    pWin = LookupWindow (stuff->window, client);
    if(!pWin)  return BadWindow;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.width  = SiSXineramadataPtr[stuff->screen].width;
    rep.height = SiSXineramadataPtr[stuff->screen].height;
    if(client->swapped) {
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swaps(&rep.width, n);
       swaps(&rep.height, n);
    }
    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), (char *)&rep);
    return client->noClientException;
}

int
SiSProcXineramaIsActive(ClientPtr client)
{
    xXineramaIsActiveReply	rep;

    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.state = !SiSnoPanoramiXExtension;
    if(client->swapped) {
	register int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.state, n);
    }
    WriteToClient(client, sizeof(xXineramaIsActiveReply), (char *) &rep);
    return client->noClientException;
}

int
SiSProcXineramaQueryScreens(ClientPtr client)
{
    xXineramaQueryScreensReply	rep;

    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.number = (SiSnoPanoramiXExtension) ? 0 : SiSXineramaNumScreens;
    rep.length = rep.number * sz_XineramaScreenInfo >> 2;
    if(client->swapped) {
       register int n;
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swapl(&rep.number, n);
    }
    WriteToClient(client, sizeof(xXineramaQueryScreensReply), (char *)&rep);

    if(!SiSnoPanoramiXExtension) {
       xXineramaScreenInfo scratch;
       int i;

       for(i = 0; i < SiSXineramaNumScreens; i++) {
	  scratch.x_org  = SiSXineramadataPtr[i].x;
	  scratch.y_org  = SiSXineramadataPtr[i].y;
	  scratch.width  = SiSXineramadataPtr[i].width;
	  scratch.height = SiSXineramadataPtr[i].height;
	  if(client->swapped) {
	     register int n;
	     swaps(&scratch.x_org, n);
	     swaps(&scratch.y_org, n);
	     swaps(&scratch.width, n);
    	     swaps(&scratch.height, n);
	  }
	  WriteToClient(client, sz_XineramaScreenInfo, (char *)&scratch);
       }
    }

    return client->noClientException;
}

static int
SiSProcXineramaDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
	case X_PanoramiXQueryVersion:
	     return SiSProcXineramaQueryVersion(client);
	case X_PanoramiXGetState:
	     return SiSProcXineramaGetState(client);
	case X_PanoramiXGetScreenCount:
	     return SiSProcXineramaGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return SiSProcXineramaGetScreenSize(client);
	case X_XineramaIsActive:
	     return SiSProcXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return SiSProcXineramaQueryScreens(client);
    }
    return BadRequest;
}

/* SProc */

static int
SiSSProcXineramaQueryVersion (ClientPtr client)
{
    REQUEST(xPanoramiXQueryVersionReq);
    register int n;
    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
    return SiSProcXineramaQueryVersion(client);
}

static int
SiSSProcXineramaGetState(ClientPtr client)
{
    REQUEST(xPanoramiXGetStateReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
    return SiSProcXineramaGetState(client);
}

static int
SiSSProcXineramaGetScreenCount(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenCountReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
    return SiSProcXineramaGetScreenCount(client);
}

static int
SiSSProcXineramaGetScreenSize(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenSizeReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
    return SiSProcXineramaGetScreenSize(client);
}

static int
SiSSProcXineramaIsActive(ClientPtr client)
{
    REQUEST(xXineramaIsActiveReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
    return SiSProcXineramaIsActive(client);
}

static int
SiSSProcXineramaQueryScreens(ClientPtr client)
{
    REQUEST(xXineramaQueryScreensReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
    return SiSProcXineramaQueryScreens(client);
}

int
SiSSProcXineramaDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
	case X_PanoramiXQueryVersion:
	     return SiSSProcXineramaQueryVersion(client);
	case X_PanoramiXGetState:
	     return SiSSProcXineramaGetState(client);
	case X_PanoramiXGetScreenCount:
	     return SiSSProcXineramaGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return SiSSProcXineramaGetScreenSize(client);
	case X_XineramaIsActive:
	     return SiSSProcXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return SiSSProcXineramaQueryScreens(client);
    }
    return BadRequest;
}

static void
SiSXineramaResetProc(ExtensionEntry* extEntry)
{
    /* Called by CloseDownExtensions() */
    if(SiSXineramadataPtr) {
       Xfree(SiSXineramadataPtr);
       SiSXineramadataPtr = NULL;
    }
}

static void
SiSXineramaExtensionInit(ScrnInfoPtr pScrn)
{
    SISPtr    	pSiS = SISPTR(pScrn);
    Bool	success = FALSE;

    if(!(SiSXineramadataPtr)) {

       if(!pSiS->MergedFB) {
          SiSnoPanoramiXExtension = TRUE;
          return;
       }

#ifdef PANORAMIX
       if(!noPanoramiXExtension) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	     "Xinerama active, not initializing SiS Pseudo-Xinerama\n");
          SiSnoPanoramiXExtension = TRUE;
          return;
       }
#endif

       if(SiSnoPanoramiXExtension) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	      "SiS Pseudo-Xinerama disabled\n");
          return;
       }

       if(pSiS->CRT2Position == sisClone) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	     "Running MergedFB in Clone mode, SiS Pseudo-Xinerama disabled\n");
          SiSnoPanoramiXExtension = TRUE;
          return;
       }

       if(!(pSiS->AtLeastOneNonClone)) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	     "Only Clone modes defined, SiS Pseudo-Xinerama disabled\n");
          SiSnoPanoramiXExtension = TRUE;
          return;
       }

       SiSXineramaNumScreens = 2;

       while(SiSXineramaGeneration != serverGeneration) {

	  pSiS->XineramaExtEntry = AddExtension(PANORAMIX_PROTOCOL_NAME, 0,0,
					SiSProcXineramaDispatch,
					SiSSProcXineramaDispatch,
					SiSXineramaResetProc,
					StandardMinorOpcode);

	  if(!pSiS->XineramaExtEntry) break;

	  if(!(SiSXineramadataPtr = (SiSXineramaData *)
	        xcalloc(SiSXineramaNumScreens, sizeof(SiSXineramaData)))) break;

	  SiSXineramaGeneration = serverGeneration;
	  success = TRUE;
       }

       if(!success) {
          SISErrorLog(pScrn, "Failed to initialize SiS Pseudo-Xinerama extension\n");
          SiSnoPanoramiXExtension = TRUE;
          return;
       }

       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
    	  "SiS Pseudo-Xinerama extension initialized\n");

       pSiS->SiSXineramaVX = 0;
       pSiS->SiSXineramaVY = 0;

    }

    SiSUpdateXineramaScreenInfo(pScrn);

}
#endif  /* End of PseudoXinerama */

static void
SiSFreeCRT2Structs(SISPtr pSiS)
{
    if(pSiS->CRT2pScrn) {
       if(pSiS->CRT2pScrn->modes) {
          while(pSiS->CRT2pScrn->modes)
  	     xf86DeleteMode(&pSiS->CRT2pScrn->modes, pSiS->CRT2pScrn->modes);
       }
       if(pSiS->CRT2pScrn->monitor) {
          if(pSiS->CRT2pScrn->monitor->Modes) {
             while(pSiS->CRT2pScrn->monitor->Modes)
  	        xf86DeleteMode(&pSiS->CRT2pScrn->monitor->Modes, pSiS->CRT2pScrn->monitor->Modes);
	  }
	  if(pSiS->CRT2pScrn->monitor->DDC) xfree(pSiS->CRT2pScrn->monitor->DDC);
	  xfree(pSiS->CRT2pScrn->monitor);
       }
       xfree(pSiS->CRT2pScrn);
       pSiS->CRT2pScrn = NULL;
   }
}

#endif	/* End of MergedFB helpers */

static xf86MonPtr
SiSInternalDDC(ScrnInfoPtr pScrn, int crtno)
{
   SISPtr        pSiS = SISPTR(pScrn);
   USHORT        temp = 0xffff, temp1, i, realcrtno = crtno;
   unsigned char buffer[256];
   xf86MonPtr    pMonitor = NULL;

   /* If CRT1 is off, skip DDC */
   if((pSiS->CRT1off) && (!crtno)) return NULL;

   if(crtno) {
      if(pSiS->VBFlags & CRT2_LCD)      realcrtno = 1;
      else if(pSiS->VBFlags & CRT2_VGA) realcrtno = 2;
      else return NULL;
   } else {
      /* If CRT1 is LCDA, skip DDC (except 301C: DDC allowed, but uses CRT2 port!) */
      if(pSiS->VBFlags & CRT1_LCDA) {
         if(pSiS->VBFlags & VB_301C)    realcrtno = 1;
         else return NULL;
      }
   }

   i = 3; /* Number of retrys */
   do {
      temp1 = SiS_HandleDDC(pSiS->SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine, realcrtno, 0, &buffer[0]);
      if((temp1) && (temp1 != 0xffff)) temp = temp1;
   } while((temp == 0xffff) && i--);
   if(temp != 0xffff) {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "CRT%d DDC supported\n", crtno + 1);
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "CRT%d DDC level: %s%s%s%s\n",
	     crtno + 1,
	     (temp & 0x1a) ? "" : "[none of the supported]",
	     (temp & 0x02) ? "2 " : "",
	     (temp & 0x08) ? "D&P" : "",
             (temp & 0x10) ? "FPDI-2" : "");
      if(temp & 0x02) {
	 i = 5;  /* Number of retrys */
	 do {
	    temp = SiS_HandleDDC(pSiS->SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine, realcrtno, 1, &buffer[0]);
	 } while((temp) && i--);
         if(!temp) {
	    if((pMonitor = xf86InterpretEDID(pScrn->scrnIndex, &buffer[0]))) {
	       return(pMonitor);
	    } else {
	       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	           "CRT%d DDC EDID corrupt\n", crtno + 1);
	       return(NULL);
	    }
	 } else {
            xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    	"CRT%d DDC reading failed\n", crtno + 1);
	    return(NULL);
	 }
      } else if(!crtno) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "DDC for VESA D&P and FPDI-2 not supported for CRT1.\n");
         return(NULL);
      } else if(temp & 0x18) {
         xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "DDC for VESA D&P and FPDI-2 not supported for CRT2 yet.\n");
         return(NULL);
      } 
      return(NULL);
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
                "CRT%d DDC probing failed\n", crtno + 1);
      return(NULL);
   }
}

static xf86MonPtr
SiSDoPrivateDDC(ScrnInfoPtr pScrn, int *crtnum)
{
    SISPtr pSiS = SISPTR(pScrn);

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       if(pSiS->SecondHead) {
          *crtnum = 1;
	  return(SiSInternalDDC(pScrn, 0));
       } else {
          *crtnum = 2;
	  return(SiSInternalDDC(pScrn, 1));
       }
    } else
#endif
    if(pSiS->CRT1off) {
       *crtnum = 2;
       return(SiSInternalDDC(pScrn, 1));
    } else {
       *crtnum = 1;
       return(SiSInternalDDC(pScrn, 0));
    }
}

static BOOLEAN
SiSMakeOwnModeList(ScrnInfoPtr pScrn, BOOLEAN acceptcustommodes, BOOLEAN includelcdmodes,
                   BOOLEAN isfordvi, BOOLEAN *havecustommodes)
{
    DisplayModePtr tempmode, delmode, mymodes;

    if((mymodes = SiSBuildBuiltInModeList(pScrn, includelcdmodes, isfordvi))) {
       if(!acceptcustommodes) {
	  while(pScrn->monitor->Modes)
             xf86DeleteMode(&pScrn->monitor->Modes, pScrn->monitor->Modes);
	  pScrn->monitor->Modes = mymodes;
       } else {
	  delmode = pScrn->monitor->Modes;
	  while(delmode) {
	     if(delmode->type & M_T_DEFAULT) {
	        tempmode = delmode->next;
	        xf86DeleteMode(&pScrn->monitor->Modes, delmode);
	        delmode = tempmode;
	     } else {
	        delmode = delmode->next;
	     }
	  }
	  tempmode = pScrn->monitor->Modes;
	  if(tempmode) *havecustommodes = TRUE;
	  pScrn->monitor->Modes = mymodes;
	  while(mymodes) {
	     if(!mymodes->next) break;
	     else mymodes = mymodes->next;
	  }
	  mymodes->next = tempmode;
	  if(tempmode) {
	     tempmode->prev = mymodes;
	  }
       }
       return TRUE;
    } else
       return FALSE;
}

/* Mandatory */
static Bool
SISPreInit(ScrnInfoPtr pScrn, int flags)
{
    SISPtr pSiS;
    MessageType from;
    unsigned char usScratchCR17, CR5F;
    unsigned char usScratchCR32, usScratchCR63;
    unsigned char usScratchSR1F;
    unsigned long int i;
    int temp;
    ClockRangePtr clockRanges;
    int pix24flags;
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif
#if defined(SISMERGED) || defined(SISDUALHEAD)
    DisplayModePtr first, p, n;
#endif
    unsigned char srlockReg,crlockReg;
    unsigned char tempreg;
    xf86MonPtr pMonitor = NULL;
    Bool didddc2;

    vbeInfoPtr pVbe;
    VbeInfoBlock *vbe;

    static const char *ddcsstr = "CRT%d DDC monitor info: ************************************\n";
    static const char *ddcestr = "End of CRT%d DDC monitor info ******************************\n";
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,14,0)
    static const char *subshstr = "Substituting missing CRT%d monitor HSync data by DDC data\n";
    static const char *subsvstr = "Substituting missing CRT%d monitor VRefresh data by DDC data\n";
#endif
#ifdef SISMERGED
    static const char *mergednocrt1 = "CRT1 not detected or forced off. %s.\n";
    static const char *mergednocrt2 = "No CRT2 output selected or no bridge detected. %s.\n";
    static const char *mergeddisstr = "MergedFB mode disabled";
    static const char *modesforstr = "Modes for CRT%d: *********************************************\n";
    static const char *crtsetupstr = "------------------------ CRT%d setup -------------------------\n";
#endif
#if defined(SISDUALHEAD) || defined(SISMERGED)
    static const char *notsuitablestr = "Not using mode \"%s\" (not suitable for %s mode)\n";
#endif

    if(flags & PROBE_DETECT) {
       if(xf86LoadSubModule(pScrn, "vbe")) {
          int index = xf86GetEntityInfo(pScrn->entityList[0])->index;

#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	  if((pVbe = VBEInit(NULL,index))) {
#else
          if((pVbe = VBEExtendedInit(NULL,index,0))) {
#endif
             ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
             vbeFree(pVbe);
          }
       }
       return TRUE;
    }

    /*
     * Note: This function is only called once at server startup, and
     * not at the start of each server generation.  This means that
     * only things that are persistent across server generations can
     * be initialised here.  xf86Screens[] is the array of all screens,
     * (pScrn is a pointer to one of these).  Privates allocated using
     * xf86AllocateScrnInfoPrivateIndex() are too, and should be used
     * for data that must persist across server generations.
     *
     * Per-generation data should be allocated with
     * AllocateScreenPrivateIndex() from the ScreenInit() function.
     */

    /* Check the number of entities, and fail if it isn't one. */
    if(pScrn->numEntities != 1) {
       SISErrorLog(pScrn, "Number of entities is not 1\n");
       return FALSE;
    }

    /* The vgahw module should be loaded here when needed */
    if(!xf86LoadSubModule(pScrn, "vgahw")) {
       SISErrorLog(pScrn, "Could not load vgahw module\n");
       return FALSE;
    }

    xf86LoaderReqSymLists(vgahwSymbols, NULL);

    /* Due to the liberal license terms this is needed for
     * keeping the copyright notice readable and intact in
     * binary distributions. Removing this is a copyright
     * infringement. Please read the license terms above.
     */

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
        "SiS driver (%d/%02d/%02d-%d)\n",
	SISDRIVERVERSIONYEAR + 2000, SISDRIVERVERSIONMONTH,
	SISDRIVERVERSIONDAY, SISDRIVERREVISION);
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	"Copyright (C) 2001-2004 Thomas Winischhofer <thomas@@winischhofer.net> and others\n");
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
        "Compiled for XFree86 %d.%d.%d.%d\n",
	XF86_VERSION_MAJOR, XF86_VERSION_MINOR,
	XF86_VERSION_PATCH, XF86_VERSION_SNAP);
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
    if(xf86GetVersion() != XF86_VERSION_CURRENT) {
       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
         "This version of the driver is not compiled for this version of XFree86!\n");
    }
#endif
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
        "See http://www.winischhofer.net/linuxsisvga.shtml "
	"for documentation and updates\n");

    /* Allocate a vgaHWRec */
    if(!vgaHWGetHWRec(pScrn)) {
       SISErrorLog(pScrn, "Could not allocate VGA private\n");
       return FALSE;
    }

    /* Allocate the SISRec driverPrivate */
    if(!SISGetRec(pScrn)) {
       SISErrorLog(pScrn, "Could not allocate memory for pSiS private\n");
       return FALSE;
    }
    pSiS = SISPTR(pScrn);
    pSiS->pScrn = pScrn;

#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    pSiS->IODBase = 0;
#else
    pSiS->IODBase = pScrn->domainIOBase;  
#endif

    /* Get the entity, and make sure it is PCI. */
    pSiS->pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
    if(pSiS->pEnt->location.type != BUS_PCI)  {
       SISErrorLog(pScrn, "Entity's bus type is not PCI\n");
       SISFreeRec(pScrn);
       return FALSE;
    }

#ifdef SISDUALHEAD
    /* Allocate an entity private if necessary */
    if(xf86IsEntityShared(pScrn->entityList[0])) {
       pSiSEnt = xf86GetEntityPrivate(pScrn->entityList[0],
					SISEntityIndex)->ptr;
       pSiS->entityPrivate = pSiSEnt;

       /* If something went wrong, quit here */
       if((pSiSEnt->DisableDual) || (pSiSEnt->ErrorAfterFirst)) {
	  SISErrorLog(pScrn, "First head encountered fatal error, can't continue\n");
	  SISFreeRec(pScrn);
	  return FALSE;
       }
    }
#endif

    /* Find the PCI info for this screen */
    pSiS->PciInfo = xf86GetPciInfoForEntity(pSiS->pEnt->index);
    pSiS->PciTag = pSiS->sishw_ext.PciTag = pciTag(pSiS->PciInfo->bus,
                           pSiS->PciInfo->device, pSiS->PciInfo->func);

    pSiS->Primary = xf86IsPrimaryPci(pSiS->PciInfo);
    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
    	"This adapter is %s display adapter\n",
	(pSiS->Primary ? "primary" : "secondary"));

    if(pSiS->Primary) {
       VGAHWPTR(pScrn)->MapSize = 0x10000;     /* Standard 64k VGA window */
       if(!vgaHWMapMem(pScrn)) {
          SISErrorLog(pScrn, "Could not map VGA memory\n");
          SISFreeRec(pScrn);
          return FALSE;
       }
    }
    vgaHWGetIOBase(VGAHWPTR(pScrn));

    /* We "patch" the PIOOffset inside vgaHW in order to force
     * the vgaHW module to use our relocated i/o ports.
     */
    VGAHWPTR(pScrn)->PIOOffset = pSiS->IODBase + (pSiS->PciInfo->ioBase[2] & 0xFFFC) - 0x380;

    pSiS->pInt = NULL;
    if(!pSiS->Primary) {
#if !defined(__alpha__)
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       		"Initializing display adapter through int10\n");
#endif
       if(xf86LoadSubModule(pScrn, "int10")) {
          xf86LoaderReqSymLists(int10Symbols, NULL);
#if !defined(__alpha__)
          pSiS->pInt = xf86InitInt10(pSiS->pEnt->index);
#endif
       } else {
          SISErrorLog(pScrn, "Could not load int10 module\n");
       }
    }

#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    {
        resRange vgamem[] = {   {ResShrMemBlock,0xA0000,0xAFFFF},
                                {ResShrMemBlock,0xB0000,0xB7FFF},
                                {ResShrMemBlock,0xB8000,0xBFFFF},
                            _END };
        xf86SetOperatingState(vgamem, pSiS->pEnt->index, ResUnusedOpr);
    }
#else
    xf86SetOperatingState(resVgaMem, pSiS->pEnt->index, ResUnusedOpr);
#endif

    /* Operations for which memory access is required */
    pScrn->racMemFlags = RAC_FB | RAC_COLORMAP | RAC_CURSOR | RAC_VIEWPORT;
    /* Operations for which I/O access is required */
    pScrn->racIoFlags = RAC_COLORMAP | RAC_CURSOR | RAC_VIEWPORT;

    /* The ramdac module should be loaded here when needed */
    if(!xf86LoadSubModule(pScrn, "ramdac")) {
       SISErrorLog(pScrn, "Could not load ramdac module\n");
#ifdef SISDUALHEAD
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }

    xf86LoaderReqSymLists(ramdacSymbols, NULL);

    /* Set pScrn->monitor */
    pScrn->monitor = pScrn->confScreen->monitor;

    /*
     * Set the Chipset and ChipRev, allowing config file entries to
     * override. DANGEROUS!
     */
    if(pSiS->pEnt->device->chipset && *pSiS->pEnt->device->chipset)  {
       pScrn->chipset = pSiS->pEnt->device->chipset;
       pSiS->Chipset = xf86StringToToken(SISChipsets, pScrn->chipset);
       from = X_CONFIG;
    } else if(pSiS->pEnt->device->chipID >= 0) {
       pSiS->Chipset = pSiS->pEnt->device->chipID;
       pScrn->chipset = (char *)xf86TokenToString(SISChipsets, pSiS->Chipset);

       from = X_CONFIG;
       xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
                                pSiS->Chipset);
    } else {
       from = X_PROBED;
       pSiS->Chipset = pSiS->PciInfo->chipType;
       pScrn->chipset = (char *)xf86TokenToString(SISChipsets, pSiS->Chipset);
    }
    if(pSiS->pEnt->device->chipRev >= 0) {
       pSiS->ChipRev = pSiS->pEnt->device->chipRev;
       xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
                        pSiS->ChipRev);
    } else {
       pSiS->ChipRev = pSiS->PciInfo->chipRev;
    }
    pSiS->sishw_ext.jChipRevision = pSiS->ChipRev;

    /* Determine SiS6326 chiprevision. This is not yet used for
     * anything, but it will as soon as I found out on which revisions
     * the hardware video overlay really works.
     * According to SiS the only differences are:
     * Chip name     Chip type      TV-Out       MPEG II decoder
     * 6326 AGP      Rev. G0/H0     no           no
     * 6326 DVD      Rev. D2        yes          yes
     * 6326          Rev. Cx        yes          yes
     */
    pSiS->SiS6326Flags = 0;
    if(pSiS->Chipset == PCI_CHIP_SIS6326) {
       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		"Chipset is SiS6326 %s (revision 0x%02x)\n",
		(pSiS->ChipRev == 0xaf) ? "(Ax)" :
		   ((pSiS->ChipRev == 0x0a) ? "AGP (G0)" :
		      ((pSiS->ChipRev == 0x0b) ? "AGP (H0)" :
		          (((pSiS->ChipRev & 0xf0) == 0xd0) ? "DVD (Dx/H0)" :
   			      (((pSiS->ChipRev & 0xf0) == 0x90) ? "(9x)" :
			          (((pSiS->ChipRev & 0xf0) == 0xc0) ? "(Cx)" :
				       "(unknown)"))))),
		pSiS->ChipRev);
       if((pSiS->ChipRev != 0x0a) && (pSiS->ChipRev != 0x0b)) {
		pSiS->SiS6326Flags |= SIS6326_HASTV;
       }
    }


    /*
     * This shouldn't happen because such problems should be caught in
     * SISProbe(), but check it just in case.
     */
    if(pScrn->chipset == NULL) {
       SISErrorLog(pScrn, "ChipID 0x%04X is not recognised\n", pSiS->Chipset);
#ifdef SISDUALHEAD
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }
    if(pSiS->Chipset < 0) {
       SISErrorLog(pScrn, "Chipset \"%s\" is not recognised\n", pScrn->chipset);
#ifdef SISDUALHEAD
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }

    /* Determine chipset and VGA engine type */
    pSiS->ChipFlags = 0;
    pSiS->SiS_SD_Flags = 0;
    pSiS->HWCursorMBufNum = pSiS->HWCursorCBufNum = 0;

    switch(pSiS->Chipset) {
	case PCI_CHIP_SIS300:
		pSiS->sishw_ext.jChipType = SIS_300;
		pSiS->VGAEngine = SIS_300_VGA;
		pSiS->SiS_SD_Flags |= SiS_SD_IS300SERIES;
		pSiS->mmioSize = 128;
		break;
	case PCI_CHIP_SIS630: /* 630 + 730 */
		pSiS->sishw_ext.jChipType = SIS_630;
		if(pciReadLong(0x00000000, 0x00) == 0x07301039) {
		   pSiS->sishw_ext.jChipType = SIS_730;
		}
		pSiS->VGAEngine = SIS_300_VGA;
		pSiS->SiS_SD_Flags |= SiS_SD_IS300SERIES;
		pSiS->mmioSize = 128;
		break;
	case PCI_CHIP_SIS540:
		pSiS->sishw_ext.jChipType = SIS_540;
		pSiS->VGAEngine = SIS_300_VGA;
		pSiS->SiS_SD_Flags |= SiS_SD_IS300SERIES;
		pSiS->mmioSize = 128;
		break;
	case PCI_CHIP_SIS315H:
		pSiS->sishw_ext.jChipType = SIS_315H;
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->ChipFlags |= SiSCF_315Core;
		pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
		pSiS->myCR63 = 0x63;
		pSiS->mmioSize = 128;
		break;
	case PCI_CHIP_SIS315:
		/* Override for simplicity */
	        pSiS->Chipset = PCI_CHIP_SIS315H;
		pSiS->sishw_ext.jChipType = SIS_315;
		pSiS->ChipFlags |= SiSCF_315Core;
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
		pSiS->myCR63 = 0x63;
		pSiS->mmioSize = 128;
		break;
	case PCI_CHIP_SIS315PRO:
		/* Override for simplicity */
		pSiS->Chipset = PCI_CHIP_SIS315H;
		pSiS->sishw_ext.jChipType = SIS_315PRO;
		pSiS->ChipFlags |= SiSCF_315Core;
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
		pSiS->myCR63 = 0x63;
		pSiS->mmioSize = 128;
		break;
	case PCI_CHIP_SIS550:
		pSiS->sishw_ext.jChipType = SIS_550;
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->ChipFlags |= SiSCF_Integrated;
		pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
		pSiS->myCR63 = 0x63;
		pSiS->mmioSize = 128;
		break;
	case PCI_CHIP_SIS650: /* 650 + 740 */
		pSiS->sishw_ext.jChipType = SIS_650;
		if(pciReadLong(0x00000000, 0x00) == 0x07401039) {
		   pSiS->sishw_ext.jChipType = SIS_740;
		}
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->ChipFlags |= (SiSCF_Integrated | SiSCF_Real256ECore);
		pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
		pSiS->myCR63 = 0x63;
		pSiS->mmioSize = 128;
		break;
	case PCI_CHIP_SIS330:
		pSiS->sishw_ext.jChipType = SIS_330;
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->ChipFlags |= SiSCF_XabreCore;
		pSiS->SiS_SD_Flags |= SiS_SD_IS330SERIES;
		pSiS->myCR63 = 0x63;
		pSiS->mmioSize = 256;
		break;
	case PCI_CHIP_SIS660: /* 660, 661, 741, 760 */
	        {
		unsigned long hpciid = pciReadLong(0x00000000, 0x00);
		switch(hpciid) {
		case 0x06601039:
		   pSiS->sishw_ext.jChipType = SIS_660;
		   pSiS->ChipFlags |= SiSCF_Ultra256Core;
		   pSiS->mmioSize = 256;
		   break;
		case 0x07601039:
		   pSiS->sishw_ext.jChipType = SIS_760;
		   pSiS->ChipFlags |= SiSCF_Ultra256Core;
		   pSiS->mmioSize = 256;
		   break;
		case 0x07411039:
		   pSiS->sishw_ext.jChipType = SIS_741;
		   pSiS->ChipFlags |= SiSCF_Real256ECore;
		   pSiS->mmioSize = 128;
		   break;
		case 0x06611039:
		default:
		   pSiS->sishw_ext.jChipType = SIS_661;
		   pSiS->ChipFlags |= SiSCF_Real256ECore;
		   pSiS->mmioSize = 128;
		}
		/* Detection could also be done by CR5C & 0xf8:
		   0x10 = 661 (CR5F & 0xc0: 0x00 both A0 and A1)
		   0x80 = 760 (CR5F & 0xc0: 0x00 A0, 0x40 A1)
		   0x90 = 741 (CR5F & 0xc0: 0x00 A0,A1 0x40 A2)
		   other: 660 (CR5F & 0xc0: 0x00 A0 0x40 A1) (DOA?)
		 */
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->ChipFlags |= SiSCF_Integrated;
		pSiS->SiS_SD_Flags |= SiS_SD_IS330SERIES;
		pSiS->myCR63 = 0x53; /* Yes, 0x53 */
		}
		break;
	case PCI_CHIP_SIS530:
		pSiS->sishw_ext.jChipType = SIS_530;
		pSiS->VGAEngine = SIS_530_VGA;
		pSiS->mmioSize = 64;
		break;
	default:
		pSiS->sishw_ext.jChipType = SIS_OLD;
		pSiS->VGAEngine = SIS_OLD_VGA;
		pSiS->mmioSize = 64;
		break;
    }

    /* Now check if sisfb is loaded. Since sisfb only supports
     * the 300 and 315 series, we only do this for these chips.
     * We use this for checking where sisfb starts its memory
     * heap in order to automatically detect the correct MaxXFBMem
     * setting (which normally is given by the option of the same name).
     * Under kernel 2.4.y, that only works if sisfb is completely 
     * running, ie with a video mode because the fbdev will not be
     * installed otherwise. Under 2.5 and later, sisfb will install
     * the framebuffer device in any way and running it with mode=none
     * is no longer supported (or necessary).
     */

    pSiS->donttrustpdc = FALSE;
    pSiS->sisfbpdc = 0xff;
    pSiS->sisfbpdca = 0xff;
    pSiS->sisfblcda = 0xff;
    pSiS->sisfbscalelcd = -1;
    pSiS->sisfbspecialtiming = CUT_NONE;
    pSiS->sisfb_haveemi = FALSE;
    pSiS->OldMode = 0;
    pSiS->sisfbfound = FALSE;

    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {

       int fd, i;
       sisfb_info mysisfbinfo;
       char name[10];
       CARD32 sisfbversion;

       {
          i=0;
          do {
             sprintf(name, "/dev/fb%1d", i);
             if((fd = open(name, 'r')) != -1) {

	        if(!ioctl(fd, SISFB_GET_INFO, &mysisfbinfo)) {

	           if(mysisfbinfo.sisfb_id == SISFB_ID) {

	              sisfbversion = (mysisfbinfo.sisfb_version << 16) |
		                     (mysisfbinfo.sisfb_revision << 8) |
			  	     (mysisfbinfo.sisfb_patchlevel);

	              if(sisfbversion >= 0x010508) {
		        /* Added PCI bus/slot/func into in sisfb Version 1.5.08.
		           Check this to make sure we run on the same card as sisfb
		         */
		        if((mysisfbinfo.sisfb_pcibus == pSiS->PciInfo->bus) &&
		           (mysisfbinfo.sisfb_pcislot == pSiS->PciInfo->device) &&
		           (mysisfbinfo.sisfb_pcifunc == pSiS->PciInfo->func) ) {
	         	    pSiS->sisfbfound = TRUE;
		        }
		      } else pSiS->sisfbfound = TRUE;

		      if(pSiS->sisfbfound) {
		         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      	             "%s: SiS kernel fb driver (sisfb) %d.%d.%d detected (PCI: %02d:%02d.%d)\n",
		             	&name[5],
		             	mysisfbinfo.sisfb_version,
		     		mysisfbinfo.sisfb_revision,
		     		mysisfbinfo.sisfb_patchlevel,
		     		pSiS->PciInfo->bus,
		     		pSiS->PciInfo->device,
		     		pSiS->PciInfo->func);
		         /* Added version/rev/pl in sisfb 1.4.0 */
		         if(mysisfbinfo.sisfb_version == 0) {
		            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		                "Old version of sisfb found. Please update\n");
		         }
		         pSiS->sisfbMem = mysisfbinfo.heapstart;
		         /* Basically, we can't trust the pdc register if sisfb is loaded */
		         pSiS->donttrustpdc = TRUE;
		         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		         	"sisfb: memory heap starts at %dKB\n", (int)pSiS->sisfbMem);
		         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		      		"sisfb: using video mode 0x%02x\n", mysisfbinfo.fbvidmode);
		   	 pSiS->OldMode = mysisfbinfo.fbvidmode;
		         if(sisfbversion >= 0x010506) {
		            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		        	"sisfb: %sreserved hardware cursor, using %s command queue\n",
			        (mysisfbinfo.sisfb_caps & 0x80) ? "" : "not ",
				(mysisfbinfo.sisfb_caps & 0x40) ? "SiS300 Turbo" :
			   	   (mysisfbinfo.sisfb_caps & 0x20) ? "SiS315/330 AGP" :
			              (mysisfbinfo.sisfb_caps & 0x10) ? "SiS315/330 VRAM" :
			                 (mysisfbinfo.sisfb_caps & 0x08) ? "SiS315/330 MMIO" :
				            "no");
		         }
		         if(sisfbversion >= 0x01050A) {
		            /* We can trust the pdc value if sisfb is of recent version */
		            if(pSiS->VGAEngine == SIS_300_VGA) pSiS->donttrustpdc = FALSE;
		            if(sisfbversion >= 0x01050B) {
			       if(pSiS->VGAEngine == SIS_300_VGA) {
		                  /* As of 1.5.11, sisfb saved the register for us (300 series) */
		      	          pSiS->sisfbpdc = mysisfbinfo.sisfb_lcdpdc;
				  if(!pSiS->sisfbpdc) pSiS->sisfbpdc = 0xff;
			       }
		            }
		            if(sisfbversion >= 0x01050E) {
		               if(pSiS->VGAEngine == SIS_315_VGA) {
		                  pSiS->sisfblcda = mysisfbinfo.sisfb_lcda;
			       }
			       if(sisfbversion >= 0x01060D) {
			          pSiS->sisfbscalelcd = mysisfbinfo.sisfb_scalelcd;
				  pSiS->sisfbspecialtiming = mysisfbinfo.sisfb_specialtiming;
			       }
			       if(sisfbversion >= 0x010610) {
			          if(pSiS->VGAEngine == SIS_315_VGA) {
				     pSiS->donttrustpdc = FALSE;
				     pSiS->sisfbpdc = mysisfbinfo.sisfb_lcdpdc;
				     if(sisfbversion >= 0x010618) {
				        pSiS->sisfb_haveemi = mysisfbinfo.sisfb_haveemi ? TRUE : FALSE;
					pSiS->sisfb_haveemilcd = TRUE;  /* will match most cases */
					pSiS->sisfb_emi30 = mysisfbinfo.sisfb_emi30;
					pSiS->sisfb_emi31 = mysisfbinfo.sisfb_emi31;
					pSiS->sisfb_emi32 = mysisfbinfo.sisfb_emi32;
					pSiS->sisfb_emi33 = mysisfbinfo.sisfb_emi33;
				     }
				     if(sisfbversion >= 0x010619) {
				        pSiS->sisfb_haveemilcd = mysisfbinfo.sisfb_haveemilcd ? TRUE : FALSE;
				     }
				     if(sisfbversion >= 0x01061f) {
					pSiS->sisfbpdca = mysisfbinfo.sisfb_lcdpdca;
				     } else {
				        if(pSiS->sisfbpdc) {
				           pSiS->sisfbpdca = (pSiS->sisfbpdc & 0xf0) >> 3;
					   pSiS->sisfbpdc  = (pSiS->sisfbpdc & 0x0f) << 1;
					} else {
					   pSiS->sisfbpdca = pSiS->sisfbpdc = 0xff;
					}
				     }
				  }
			       }
		            }
		         }
		      }
	           }
	        }
	        close (fd);
             }
	     i++;
          } while((i <= 7) && (!pSiS->sisfbfound));
	  if(!pSiS->sisfbfound) xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "sisfb not found\n");
       }
    }

    /*
     * The first thing we should figure out is the depth, bpp, etc.
     * Additionally, determine the size of the HWCursor memory area.
     */
    switch(pSiS->VGAEngine) {
      case SIS_300_VGA:
        pSiS->CursorSize = 4096;
    	pix24flags = Support32bppFb;
	break;
      case SIS_315_VGA:
        pSiS->CursorSize = 16384;
    	pix24flags = Support32bppFb;
	break;
      case SIS_530_VGA:
        pSiS->CursorSize = 2048;
    	pix24flags = Support32bppFb |
	             Support24bppFb;
        break;
      default:
        pSiS->CursorSize = 2048;
        pix24flags = Support24bppFb;
	break;
    }

#ifdef SISDUALHEAD
    /* In case of Dual Head, we need to determine if we are the "master" head or
     * the "slave" head. In order to do that, we set PrimInit to DONE in the
     * shared entity at the end of the first initialization. The second
     * initialization then knows that some things have already been done. THIS
     * ALWAYS ASSUMES THAT THE FIRST DEVICE INITIALIZED IS THE MASTER!
     */

    if(xf86IsEntityShared(pScrn->entityList[0])) {
       if(pSiSEnt->lastInstance > 0) {
     	  if(!xf86IsPrimInitDone(pScrn->entityList[0])) {
	     /* First Head (always CRT2) */
	     pSiS->SecondHead = FALSE;
	     pSiSEnt->pScrn_1 = pScrn;
	     pSiSEnt->CRT1ModeNo = pSiSEnt->CRT2ModeNo = -1;
	     pSiSEnt->CRT2ModeSet = FALSE;
	     pSiS->DualHeadMode = TRUE;
	     pSiSEnt->DisableDual = FALSE;
	     pSiSEnt->BIOS = NULL;
	     pSiSEnt->ROM661New = FALSE;
	     pSiSEnt->SiS_Pr = NULL;
	     pSiSEnt->RenderAccelArray = NULL;
	  } else {
	     /* Second Head (always CRT1) */
	     pSiS->SecondHead = TRUE;
	     pSiSEnt->pScrn_2 = pScrn;
	     pSiS->DualHeadMode = TRUE;
	  }
       } else {
          /* Only one screen in config file - disable dual head mode */
          pSiS->SecondHead = FALSE;
	  pSiS->DualHeadMode = FALSE;
	  pSiSEnt->DisableDual = TRUE;
       }
    } else {
       /* Entity is not shared - disable dual head mode */
       pSiS->SecondHead = FALSE;
       pSiS->DualHeadMode = FALSE;
    }
#endif

    pSiS->ForceCursorOff = FALSE;

    /* Allocate SiS_Private (for mode switching code) and initialize it */
    pSiS->SiS_Pr = NULL;
#ifdef SISDUALHEAD
    if(pSiSEnt) {
       if(pSiSEnt->SiS_Pr) pSiS->SiS_Pr = pSiSEnt->SiS_Pr;
    }
#endif
    if(!pSiS->SiS_Pr) {
       if(!(pSiS->SiS_Pr = xnfcalloc(sizeof(SiS_Private), 1))) {
          SISErrorLog(pScrn, "Could not allocate memory for SiS_Pr private\n");
#ifdef SISDUALHEAD
	  if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	  if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	  SISFreeRec(pScrn);
          return FALSE;
       }
#ifdef SISDUALHEAD
       if(pSiSEnt) pSiSEnt->SiS_Pr = pSiS->SiS_Pr;
#endif
       memset(pSiS->SiS_Pr, 0, sizeof(SiS_Private));
       pSiS->SiS_Pr->SiS_Backup70xx = 0xff;
       pSiS->SiS_Pr->SiS_CHOverScan = -1;
       pSiS->SiS_Pr->SiS_ChSW = FALSE;
       pSiS->SiS_Pr->SiS_CustomT = CUT_NONE;
       pSiS->SiS_Pr->PanelSelfDetected = FALSE;
       pSiS->SiS_Pr->UsePanelScaler = -1;
       pSiS->SiS_Pr->CenterScreen = -1;
       pSiS->SiS_Pr->CRT1UsesCustomMode = FALSE;
       pSiS->SiS_Pr->PDC = pSiS->SiS_Pr->PDCA = -1;
       pSiS->SiS_Pr->LVDSHL = -1;
       pSiS->SiS_Pr->HaveEMI = FALSE;
       pSiS->SiS_Pr->HaveEMILCD = FALSE;
       pSiS->SiS_Pr->OverruleEMI = FALSE;
       pSiS->SiS_Pr->SiS_SensibleSR11 = FALSE;
       if(pSiS->sishw_ext.jChipType >= SIS_661) {
          pSiS->SiS_Pr->SiS_SensibleSR11 = TRUE;
       }
       pSiS->SiS_Pr->SiS_MyCR63 = pSiS->myCR63;
    }

    /* Get our relocated IO registers */
    pSiS->RelIO = (SISIOADDRESS)((pSiS->PciInfo->ioBase[2] & 0xFFFC) + pSiS->IODBase);
    pSiS->sishw_ext.ulIOAddress = (SISIOADDRESS)(pSiS->RelIO + 0x30);
    xf86DrvMsg(pScrn->scrnIndex, from, "Relocated IO registers at 0x%lX\n",
           (unsigned long)pSiS->RelIO);

    /* Initialize SiS Port Reg definitions for externally used
     * init.c/init301.c functions.
     */
    SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO + 0x30);

    /* The following identifies the old chipsets. This is only
     * partly used since the really old chips are not supported,
     * but I keep it here for future use.
     * 205, 215 and 225 are to be treated the same way, 201 and 202
     * are different.
     */
    if(pSiS->VGAEngine == SIS_OLD_VGA || pSiS->VGAEngine == SIS_530_VGA) {
       switch(pSiS->Chipset) {
       case PCI_CHIP_SG86C201:
       	  pSiS->oldChipset = OC_SIS86201; break;
       case PCI_CHIP_SG86C202:
       	  pSiS->oldChipset = OC_SIS86202; break;
       case PCI_CHIP_SG86C205:
          {
	  unsigned char temp;
	  sisSaveUnlockExtRegisterLock(pSiS, &srlockReg, &crlockReg);
	  inSISIDXREG(SISSR, 0x10, temp);
	  if(temp & 0x80) pSiS->oldChipset = OC_SIS6205B;
	  else pSiS->oldChipset = (pSiS->ChipRev == 0x11) ?
	  		OC_SIS6205C : OC_SIS6205A;
          break;
	  }
       case PCI_CHIP_SIS82C204:
       	  pSiS->oldChipset = OC_SIS82204; break;
       case 0x6225:
          pSiS->oldChipset = OC_SIS6225; break;
       case PCI_CHIP_SIS5597:
          pSiS->oldChipset = OC_SIS5597; break;
       case PCI_CHIP_SIS6326:
          pSiS->oldChipset = OC_SIS6326; break;
       case PCI_CHIP_SIS530:
          if(pciReadLong(0x00000000, 0x00) == 0x06201039) {
	     pSiS->oldChipset = OC_SIS620;
	  } else {
             if((pSiS->ChipRev & 0x0f) < 0x0a)
	  	   pSiS->oldChipset = OC_SIS530A;
	     else  pSiS->oldChipset = OC_SIS530B;
	  }
	  break;
       default:
          pSiS->oldChipset = OC_UNKNOWN;
       }
    }

    if(!xf86SetDepthBpp(pScrn, 0, 0, 0, pix24flags)) {
       SISErrorLog(pScrn, "xf86SetDepthBpp() error\n");
#ifdef SISDUALHEAD
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }

    /* Check that the returned depth is one we support */
    temp = 0;
    switch(pScrn->depth) {
       case 8:
       case 16:
       case 24:
          break;
       case 15:
	  if((pSiS->VGAEngine == SIS_300_VGA) ||
	     (pSiS->VGAEngine == SIS_315_VGA)) {
	     temp = 1;
	  }
          break;
       default:
	  temp = 1;
    }

    if(temp) {
       SISErrorLog(pScrn,
               "Given color depth (%d) is not supported by this driver/chipset\n",
               pScrn->depth);
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }

    xf86PrintDepthBpp(pScrn);

    if( (((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) &&
         (pScrn->bitsPerPixel == 24)) ||
	((pSiS->VGAEngine == SIS_OLD_VGA) && (pScrn->bitsPerPixel == 32)) ) {
       SISErrorLog(pScrn,
            "Framebuffer bpp %d not supported for this chipset\n", pScrn->bitsPerPixel);
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }

    /* Get the depth24 pixmap format */
    if(pScrn->depth == 24 && pix24bpp == 0) {
       pix24bpp = xf86GetBppFromDepth(pScrn, 24);
    }

    /*
     * This must happen after pScrn->display has been set because
     * xf86SetWeight references it.
     */
    if(pScrn->depth > 8) {
        /* The defaults are OK for us */
        rgb zeros = {0, 0, 0};

        if(!xf86SetWeight(pScrn, zeros, zeros)) {
	    SISErrorLog(pScrn, "xf86SetWeight() error\n");
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	    SISFreeRec(pScrn);
            return FALSE;
        } else {
           Bool ret = FALSE;
           switch(pScrn->depth) {
	   case 15:
	      if((pScrn->weight.red != 5) ||
	         (pScrn->weight.green != 5) ||
		 (pScrn->weight.blue != 5)) ret = TRUE;
	      break;
	   case 16:
	      if((pScrn->weight.red != 5) ||
	         (pScrn->weight.green != 6) ||
		 (pScrn->weight.blue != 5)) ret = TRUE;
	      break;
	   case 24:
	      if((pScrn->weight.red != 8) ||
	         (pScrn->weight.green != 8) ||
		 (pScrn->weight.blue != 8)) ret = TRUE;
	      break;
           }
	   if(ret) {
	      SISErrorLog(pScrn,
	      	"RGB weight %d%d%d at depth %d not supported by hardware\n",
		(int)pScrn->weight.red, (int)pScrn->weight.green,
		(int)pScrn->weight.blue, pScrn->depth);
#ifdef SISDUALHEAD
	      if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	      if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	      SISFreeRec(pScrn);
              return FALSE;
	   }
        }
    }

    /* Set the current layout parameters */
    pSiS->CurrentLayout.bitsPerPixel = pScrn->bitsPerPixel;
    pSiS->CurrentLayout.depth        = pScrn->depth;
    /* (Inside this function, we can use pScrn's contents anyway) */

    if(!xf86SetDefaultVisual(pScrn, -1)) {
        SISErrorLog(pScrn, "xf86SetDefaultVisual() error\n");
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
        SISFreeRec(pScrn);
        return FALSE;
    } else {
        /* We don't support DirectColor at > 8bpp */
        if(pScrn->depth > 8 && pScrn->defaultVisual != TrueColor) {
            SISErrorLog(pScrn,
	       	"Given default visual (%s) is not supported at depth %d\n",
                xf86GetVisualName(pScrn->defaultVisual), pScrn->depth);
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	    SISFreeRec(pScrn);
            return FALSE;
        }
    }

#ifdef SISDUALHEAD
    /* Due to palette & timing problems we don't support 8bpp in DHM */
    if((pSiS->DualHeadMode) && (pScrn->bitsPerPixel == 8)) {
       SISErrorLog(pScrn, "Color depth 8 not supported in Dual Head mode.\n");
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }
#endif

    /*
     * The cmap layer needs this to be initialised.
     */
    {
        Gamma zeros = {0.0, 0.0, 0.0};

        if(!xf86SetGamma(pScrn, zeros)) {
	    SISErrorLog(pScrn, "xf86SetGamma() error\n");
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	    SISFreeRec(pScrn);
            return FALSE;
        }
    }

    /* We use a programamble clock */
    pScrn->progClock = TRUE;

    /* Set the bits per RGB for 8bpp mode */
    if(pScrn->depth == 8) {
       pScrn->rgbBits = 6;
    }

    from = X_DEFAULT;

    /* Unlock registers */
    sisSaveUnlockExtRegisterLock(pSiS, &srlockReg, &crlockReg);

    /* Read BIOS for 300 and 315/330 series customization */
    pSiS->sishw_ext.pjVirtualRomBase = NULL;
    pSiS->BIOS = NULL;
    pSiS->sishw_ext.UseROM = FALSE;
    pSiS->ROM661New = FALSE;

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
#ifdef SISDUALHEAD
       if(pSiSEnt) {
          if(pSiSEnt->BIOS) {
	     pSiS->BIOS = pSiSEnt->BIOS;
	     pSiS->sishw_ext.pjVirtualRomBase = pSiS->BIOS;
	     pSiS->ROM661New = pSiSEnt->ROM661New;
          }
       }
#endif
       if(!pSiS->BIOS) {
          if(!(pSiS->BIOS = xcalloc(1, BIOS_SIZE))) {
             xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		"Could not allocate memory for video BIOS image\n");
          } else {
	     unsigned long  segstart;
             unsigned short romptr, pciid;
	     BOOLEAN found;

	     found = FALSE;
             for(segstart=BIOS_BASE; segstart<0x000f0000; segstart+=0x00001000) {

#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
                if(xf86ReadBIOS(segstart, 0, pSiS->BIOS, BIOS_SIZE) != BIOS_SIZE) continue;
#else
                if(xf86ReadDomainMemory(pSiS->PciTag, segstart, BIOS_SIZE, pSiS->BIOS) != BIOS_SIZE) continue;
#endif

		if((pSiS->BIOS[0] != 0x55) || (pSiS->BIOS[1] != 0xaa)) continue;

		romptr = pSiS->BIOS[0x18] | (pSiS->BIOS[0x19] << 8);
		if(romptr > (BIOS_SIZE - 8)) continue;
		if((pSiS->BIOS[romptr]   != 'P') || (pSiS->BIOS[romptr+1] != 'C') ||
		   (pSiS->BIOS[romptr+2] != 'I') || (pSiS->BIOS[romptr+3] != 'R')) continue;

		pciid = pSiS->BIOS[romptr+4] | (pSiS->BIOS[romptr+5] << 8);
		if(pciid != 0x1039) continue;

		pciid = pSiS->BIOS[romptr+6] | (pSiS->BIOS[romptr+7] << 8);
		if(pciid != pSiS->Chipset) continue;

		found = TRUE;
		break;
             }

	     if(!found) {
	     	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		         "Could not find/read video BIOS\n");
 	   	xfree(pSiS->BIOS);
	        pSiS->BIOS = NULL;
             } else {
                pSiS->sishw_ext.pjVirtualRomBase = pSiS->BIOS;
		pSiS->ROM661New = SiSDetermineROMLayout661(pSiS->SiS_Pr,&pSiS->sishw_ext);
		romptr = pSiS->BIOS[0x16] | (pSiS->BIOS[0x17] << 8);
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			"Video BIOS version \"%7s\" found at 0x%lx (%s data layout)\n",
			&pSiS->BIOS[romptr], segstart, pSiS->ROM661New ? "new" : "old");
#ifdef SISDUALHEAD
                if(pSiSEnt) {
		   pSiSEnt->BIOS = pSiS->BIOS;
		   pSiSEnt->ROM661New = pSiS->ROM661New;
		}
#endif
             }
          }
       }
       if(pSiS->BIOS) pSiS->sishw_ext.UseROM = TRUE;
       else           pSiS->sishw_ext.UseROM = FALSE;
    }

    /* Evaluate options */
    SiSOptions(pScrn);

#ifdef SISMERGED
    /* Due to palette & timing problems we don't support 8bpp in MFBM */
    if((pSiS->MergedFB) && (pScrn->bitsPerPixel == 8)) {
       SISErrorLog(pScrn, "MergedFB: Color depth 8 not supported, %s\n", mergeddisstr);
       pSiS->MergedFB = pSiS->MergedFBAuto = FALSE;
    }
#endif

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
        if(!pSiS->SecondHead) {
	     /* Copy some option settings to entity private */
             pSiSEnt->HWCursor = pSiS->HWCursor;
	     pSiSEnt->NoAccel = pSiS->NoAccel;
	     pSiSEnt->restorebyset = pSiS->restorebyset;
	     pSiSEnt->OptROMUsage = pSiS->OptROMUsage;
	     pSiSEnt->OptUseOEM = pSiS->OptUseOEM;
	     pSiSEnt->TurboQueue = pSiS->TurboQueue;
	     pSiSEnt->forceCRT1 = pSiS->forceCRT1;
	     pSiSEnt->ForceCRT1Type = pSiS->ForceCRT1Type;
	     pSiSEnt->ForceCRT2Type = pSiS->ForceCRT2Type;
	     pSiSEnt->ForceTVType = pSiS->ForceTVType;
	     pSiSEnt->ForceYPbPrType = pSiS->ForceYPbPrType;
	     pSiSEnt->ForceYPbPrAR = pSiS->ForceYPbPrAR;
	     pSiSEnt->UsePanelScaler = pSiS->UsePanelScaler;
	     pSiSEnt->CenterLCD = pSiS->CenterLCD;
	     pSiSEnt->DSTN = pSiS->DSTN;
	     pSiSEnt->OptTVStand = pSiS->OptTVStand;
	     pSiSEnt->NonDefaultPAL = pSiS->NonDefaultPAL;
	     pSiSEnt->NonDefaultNTSC = pSiS->NonDefaultNTSC;
	     pSiSEnt->chtvtype = pSiS->chtvtype;
	     pSiSEnt->OptTVOver = pSiS->OptTVOver;
	     pSiSEnt->OptTVSOver = pSiS->OptTVSOver;
	     pSiSEnt->chtvlumabandwidthcvbs = pSiS->chtvlumabandwidthcvbs;
	     pSiSEnt->chtvlumabandwidthsvideo = pSiS->chtvlumabandwidthsvideo;
	     pSiSEnt->chtvlumaflickerfilter = pSiS->chtvlumaflickerfilter;
	     pSiSEnt->chtvchromabandwidth = pSiS->chtvchromabandwidth;
	     pSiSEnt->chtvchromaflickerfilter = pSiS->chtvchromaflickerfilter;
	     pSiSEnt->chtvtextenhance = pSiS->chtvtextenhance;
	     pSiSEnt->chtvcontrast = pSiS->chtvcontrast;
	     pSiSEnt->chtvcvbscolor = pSiS->chtvcvbscolor;
	     pSiSEnt->sistvedgeenhance = pSiS->sistvedgeenhance;
	     pSiSEnt->sistvantiflicker = pSiS->sistvantiflicker;
	     pSiSEnt->sistvsaturation = pSiS->sistvsaturation;
	     pSiSEnt->sistvcfilter = pSiS->sistvcfilter;
	     pSiSEnt->sistvyfilter = pSiS->sistvyfilter;
	     pSiSEnt->sistvcolcalibc = pSiS->sistvcolcalibc;
	     pSiSEnt->sistvcolcalibf = pSiS->sistvcolcalibf;
	     pSiSEnt->tvxpos = pSiS->tvxpos;
	     pSiSEnt->tvypos = pSiS->tvypos;
	     pSiSEnt->tvxscale = pSiS->tvxscale;
	     pSiSEnt->tvyscale = pSiS->tvyscale;
	     pSiSEnt->CRT1gamma = pSiS->CRT1gamma;
	     pSiSEnt->CRT1gammaGiven = pSiS->CRT1gammaGiven;
	     pSiSEnt->XvGammaRed = pSiS->XvGammaRed;
	     pSiSEnt->XvGammaGreen = pSiS->XvGammaGreen;
	     pSiSEnt->XvGammaBlue = pSiS->XvGammaBlue;
	     pSiSEnt->XvGamma = pSiS->XvGamma;
	     pSiSEnt->XvGammaGiven = pSiS->XvGammaGiven;
	     pSiSEnt->CRT2gamma = pSiS->CRT2gamma;
	     pSiSEnt->XvOnCRT2 = pSiS->XvOnCRT2;
	     pSiSEnt->AllowHotkey = pSiS->AllowHotkey;
	     pSiSEnt->enablesisctrl = pSiS->enablesisctrl;
	     pSiSEnt->SenseYPbPr = pSiS->SenseYPbPr;
#ifdef SIS_CP
	     SIS_CP_DRIVER_COPYOPTIONSENT
#endif
	} else {
	     /* We always use same cursor type on both screens */
	     if(pSiS->HWCursor != pSiSEnt->HWCursor) {
	          pSiS->HWCursor = pSiSEnt->HWCursor;
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  	"Ignoring inconsistent HWCursor setting\n");
	          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		  	"Master head ruled: HWCursor shall be %s\n",
			pSiS->HWCursor ? "enabled" : "disabled");
	     }

	     /* We need identical NoAccel setting */
	     if(pSiS->NoAccel != pSiSEnt->NoAccel) {
	          pSiS->NoAccel = pSiSEnt->NoAccel;
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  	"Ignoring inconsistent NoAccel setting\n");
	          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		        "Master head ruled: Acceleration shall be %s\n",
			pSiS->NoAccel ? "disabled" : "enabled");
	     }
	     pSiS->TurboQueue = pSiSEnt->TurboQueue;
	     pSiS->restorebyset = pSiSEnt->restorebyset;
	     pSiS->AllowHotkey = pSiS->AllowHotkey;
	     pSiS->OptROMUsage = pSiSEnt->OptROMUsage;
	     pSiS->OptUseOEM = pSiSEnt->OptUseOEM;
	     pSiS->forceCRT1 = pSiSEnt->forceCRT1;
	     pSiS->nocrt2ddcdetection = FALSE;
	     pSiS->forcecrt2redetection = FALSE;
	     pSiS->ForceCRT1Type = pSiSEnt->ForceCRT1Type;
	     pSiS->ForceCRT2Type = pSiSEnt->ForceCRT2Type;
	     pSiS->UsePanelScaler = pSiSEnt->UsePanelScaler;
	     pSiS->CenterLCD = pSiSEnt->CenterLCD;
	     pSiS->DSTN = pSiSEnt->DSTN;
	     pSiS->OptTVStand = pSiSEnt->OptTVStand;
	     pSiS->NonDefaultPAL = pSiSEnt->NonDefaultPAL;
	     pSiS->NonDefaultNTSC = pSiSEnt->NonDefaultNTSC;
	     pSiS->chtvtype = pSiSEnt->chtvtype;
	     pSiS->ForceTVType = pSiSEnt->ForceTVType;
	     pSiS->ForceYPbPrType = pSiSEnt->ForceYPbPrType;
	     pSiS->ForceYPbPrAR = pSiSEnt->ForceYPbPrAR;
	     pSiS->OptTVOver = pSiSEnt->OptTVOver;
	     pSiS->OptTVSOver = pSiSEnt->OptTVSOver;
	     pSiS->chtvlumabandwidthcvbs = pSiSEnt->chtvlumabandwidthcvbs;
	     pSiS->chtvlumabandwidthsvideo = pSiSEnt->chtvlumabandwidthsvideo;
	     pSiS->chtvlumaflickerfilter = pSiSEnt->chtvlumaflickerfilter;
	     pSiS->chtvchromabandwidth = pSiSEnt->chtvchromabandwidth;
	     pSiS->chtvchromaflickerfilter = pSiSEnt->chtvchromaflickerfilter;
	     pSiS->chtvcvbscolor = pSiSEnt->chtvcvbscolor;
	     pSiS->chtvtextenhance = pSiSEnt->chtvtextenhance;
	     pSiS->chtvcontrast = pSiSEnt->chtvcontrast;
	     pSiS->sistvedgeenhance = pSiSEnt->sistvedgeenhance;
	     pSiS->sistvantiflicker = pSiSEnt->sistvantiflicker;
	     pSiS->sistvsaturation = pSiSEnt->sistvsaturation;
	     pSiS->sistvcfilter = pSiSEnt->sistvcfilter;
	     pSiS->sistvyfilter = pSiSEnt->sistvyfilter;
	     pSiS->sistvcolcalibc = pSiSEnt->sistvcolcalibc;
	     pSiS->sistvcolcalibf = pSiSEnt->sistvcolcalibf;
	     pSiS->tvxpos = pSiSEnt->tvxpos;
	     pSiS->tvypos = pSiSEnt->tvypos;
	     pSiS->tvxscale = pSiSEnt->tvxscale;
	     pSiS->tvyscale = pSiSEnt->tvyscale;
	     pSiS->SenseYPbPr = pSiSEnt->SenseYPbPr;
	     if(!pSiS->CRT1gammaGiven) {
	        if(pSiSEnt->CRT1gammaGiven)
	           pSiS->CRT1gamma = pSiSEnt->CRT1gamma;
	     }
	     pSiS->CRT2gamma = pSiSEnt->CRT2gamma;
	     if(!pSiS->XvGammaGiven) {
	        if(pSiSEnt->XvGammaGiven) {
		   pSiS->XvGamma = pSiSEnt->XvGamma;
		   pSiS->XvGammaRed = pSiS->XvGammaRedDef = pSiSEnt->XvGammaRed;
		   pSiS->XvGammaGreen = pSiS->XvGammaGreenDef = pSiSEnt->XvGammaGreen;
		   pSiS->XvGammaBlue = pSiS->XvGammaBlueDef = pSiSEnt->XvGammaBlue;
		}
	     }
	     pSiS->XvOnCRT2 = pSiSEnt->XvOnCRT2;
	     pSiS->enablesisctrl = pSiSEnt->enablesisctrl;
	     /* Copy gamma brightness to Ent for Xinerama */
	     pSiSEnt->GammaBriR = pSiS->GammaBriR;
	     pSiSEnt->GammaBriG = pSiS->GammaBriG;
	     pSiSEnt->GammaBriB = pSiS->GammaBriB;
	     pSiSEnt->GammaPBriR = pSiS->GammaPBriR;
	     pSiSEnt->GammaPBriG = pSiS->GammaPBriG;
	     pSiSEnt->GammaPBriB = pSiS->GammaPBriB;
#ifdef SIS_CP
	     SIS_CP_DRIVER_COPYOPTIONS
#endif
	}
    }
#endif

    /* Handle UseROMData, NoOEM and UsePanelScaler options */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       from = X_PROBED;
       if(pSiS->OptROMUsage == 0)  {
       	  pSiS->sishw_ext.UseROM = FALSE;
	  from = X_CONFIG;
	  xf86DrvMsg(pScrn->scrnIndex, from, "Video ROM data usage is disabled\n");
       }

       if(!pSiS->OptUseOEM)
          xf86DrvMsg(pScrn->scrnIndex, from, "Internal OEM LCD/TV/VGA2 data usage is disabled\n");
	  
       pSiS->SiS_Pr->UsePanelScaler = pSiS->UsePanelScaler;
       pSiS->SiS_Pr->CenterScreen = pSiS->CenterLCD;
    }

    /* Do basic configuration */
    SiSSetup(pScrn);

    from = X_PROBED;
    if(pSiS->pEnt->device->MemBase != 0) {
       /*
        * XXX Should check that the config file value matches one of the
        * PCI base address values.
        */
       pSiS->FbAddress = pSiS->pEnt->device->MemBase;
       from = X_CONFIG;
    } else {
       pSiS->FbAddress = pSiS->PciInfo->memBase[0] & 0xFFFFFFF0;
    }

    pSiS->realFbAddress = pSiS->FbAddress;

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode)
       xf86DrvMsg(pScrn->scrnIndex, from, "Global linear framebuffer at 0x%lX\n",
           (unsigned long)pSiS->FbAddress);
    else 	   
#endif
       xf86DrvMsg(pScrn->scrnIndex, from, "Linear framebuffer at 0x%lX\n",
           (unsigned long)pSiS->FbAddress);

    if(pSiS->pEnt->device->IOBase != 0) {
        /*
         * XXX Should check that the config file value matches one of the
         * PCI base address values.
         */
       pSiS->IOAddress = pSiS->pEnt->device->IOBase;
       from = X_CONFIG;
    } else {
       pSiS->IOAddress = pSiS->PciInfo->memBase[1] & 0xFFFFFFF0;
    }

    xf86DrvMsg(pScrn->scrnIndex, from, "MMIO registers at 0x%lX (size %ldK)\n",
           (unsigned long)pSiS->IOAddress, pSiS->mmioSize);
    pSiS->sishw_ext.bIntegratedMMEnabled = TRUE;

    /* Register the PCI-assigned resources. */
    if(xf86RegisterResources(pSiS->pEnt->index, NULL, ResExclusive)) {
       SISErrorLog(pScrn, "xf86RegisterResources() found resource conflicts\n");
#ifdef SISDUALHEAD
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
       SISFreeRec(pScrn);
       return FALSE;
    }

    from = X_PROBED;
    if(pSiS->pEnt->device->videoRam != 0) {
       if(pSiS->Chipset == PCI_CHIP_SIS6326) {
          pScrn->videoRam = pSiS->pEnt->device->videoRam;
          from = X_CONFIG;
       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	  	"Option \"VideoRAM\" ignored\n");
       }
    }

    pSiS->RealVideoRam = pScrn->videoRam;

    if((pSiS->Chipset == PCI_CHIP_SIS6326)
			&& (pScrn->videoRam > 4096)
			&& (from != X_CONFIG)) {
        pScrn->videoRam = 4096;
        xf86DrvMsg(pScrn->scrnIndex, from,
	       "SiS6326: Detected %d KB VideoRAM, limiting to %d KB\n",
               pSiS->RealVideoRam, pScrn->videoRam);
    } else {
        xf86DrvMsg(pScrn->scrnIndex, from, "VideoRAM: %d KB\n",
               pScrn->videoRam);
    }

    if((pSiS->Chipset == PCI_CHIP_SIS6326) &&
       (pScrn->videoRam > 4096)) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	"SiS6326 engines do not support more than 4096KB RAM, therefore\n");
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
        "TurboQueue, HWCursor, 2D acceleration and XVideo are disabled.\n");
       pSiS->TurboQueue = FALSE;
       pSiS->HWCursor   = FALSE;
       pSiS->NoXvideo   = TRUE;
       pSiS->NoAccel    = TRUE;
    }

    pSiS->FbMapSize = pSiS->availMem = pScrn->videoRam * 1024;
    pSiS->sishw_ext.ulVideoMemorySize = pScrn->videoRam * 1024;
    pSiS->sishw_ext.bSkipDramSizing = TRUE;

    /* Calculate real availMem according to Accel/TurboQueue and
     * HWCursur setting. Also, initialize some variables used
     * in other modules.
     */

    pSiS->cursorOffset = 0;
    pSiS->CurARGBDest = NULL;
    pSiS->CurMonoSrc = NULL;
    pSiS->CurFGCol = pSiS->CurBGCol = 0;

    switch(pSiS->VGAEngine) {

      case SIS_300_VGA:
      	pSiS->TurboQueueLen = 512;
       	if(pSiS->TurboQueue) {
	   pSiS->availMem -= (pSiS->TurboQueueLen*1024);
	   pSiS->cursorOffset = 512;
        }
	if(pSiS->HWCursor) {
	   pSiS->availMem -= pSiS->CursorSize;
	   if(pSiS->OptUseColorCursor) pSiS->availMem -= pSiS->CursorSize;
	}
	pSiS->CmdQueLenMask = 0xFFFF;
	pSiS->CmdQueLenFix  = 0;
	pSiS->cursorBufferNum = 0;
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->cursorBufferNum = 0;
#endif
	break;

      case SIS_315_VGA:
#ifdef SISVRAMQ
	pSiS->cmdQueueSizeMask = pSiS->cmdQueueSize - 1;	/* VRAM Command Queue is variable (in therory) */
	pSiS->cmdQueueOffset = (pScrn->videoRam * 1024) - pSiS->cmdQueueSize;
	pSiS->cmdQueueLen = 0;
        pSiS->cmdQueueLenMin = 0x200;
        pSiS->cmdQueueLenMax = pSiS->cmdQueueSize - pSiS->cmdQueueLenMin;
	pSiS->cmdQueueSize_div2 = pSiS->cmdQueueSize / 2;
	pSiS->cmdQueueSize_div4 = pSiS->cmdQueueSize / 4;
	pSiS->cmdQueueSize_4_3 = (pSiS->cmdQueueSize / 4) * 3;
	pSiS->availMem -= pSiS->cmdQueueSize;
        pSiS->cursorOffset = (pSiS->cmdQueueSize / 1024);
#else
       	if(pSiS->TurboQueue) {
	   pSiS->availMem -= (512*1024);  			/* MMIO Command Queue is 512k (variable in theory) */
	   pSiS->cursorOffset = 512;
	}
#endif
	if(pSiS->HWCursor) {
           pSiS->availMem -= (pSiS->CursorSize * 2);
	   if(pSiS->OptUseColorCursor) pSiS->availMem -= (pSiS->CursorSize * 2);
	}
	pSiS->cursorBufferNum = 0;
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->cursorBufferNum = 0;
#endif	
	break;

      default:
        /* cursorOffset not used in cursor functions for 530 and
	 * older chips, because the cursor is *above* the TQ.
	 * On 5597 and older revisions of the 6326, the TQ is
	 * max 32K, on newer 6326 revisions and the 530 either 30
	 * (or 32?) or 62K (or 64?). However, to make sure, we
	 * use only 30K (or 32?), but reduce the available memory
	 * by 64, and locate the TQ at the beginning of this last
	 * 64K block. (We do this that way even when using the
	 * HWCursor, because the cursor only takes 2K and the
	 * queue does not seem to last that far anyway.)
	 * The TQ must be located at 32KB boundaries.
	 */
	if(pSiS->RealVideoRam < 3072) {
	   if(pSiS->TurboQueue) {
	      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Not enough video RAM for TurboQueue. TurboQueue disabled\n");
	      pSiS->TurboQueue = FALSE;
	   }
	}
	pSiS->CmdQueMaxLen = 32;
     	if(pSiS->TurboQueue) {
	              	      pSiS->availMem -= (64*1024);
			      pSiS->CmdQueMaxLen = 900;   /* To make sure; should be 992 */
	} else if(pSiS->HWCursor) {
	                      pSiS->availMem -= pSiS->CursorSize;
	}
	if(pSiS->Chipset == PCI_CHIP_SIS530) {
		/* Check if Flat Panel is enabled */
		inSISIDXREG(SISSR, 0x0e, tempreg);
		if(!tempreg & 0x04) pSiS->availMem -= pSiS->CursorSize;

		/* Set up mask for MMIO register */
		pSiS->CmdQueLenMask = (pSiS->TurboQueue) ? 0x1FFF : 0x00FF;
	} else {
	        /* TQ is never used on 6326/5597, because the accelerator
		 * always Syncs. So this is just cosmentic work. (And I
		 * am not even sure that 0x7fff is correct. MMIO 0x83a8
		 * holds 0xec0 if (30k) TQ is enabled, 0x20 if TQ disabled.
		 * The datasheet has no real explanation on the queue length
		 * if the TQ is enabled. Not syncing and waiting for a
		 * suitable queue length instead does not work.
		 */
	        pSiS->CmdQueLenMask = (pSiS->TurboQueue) ? 0x7FFF : 0x003F;
	}

	/* This is to be subtracted from MMIO queue length register contents
	 * for getting the real Queue length.
	 */
	pSiS->CmdQueLenFix  = (pSiS->TurboQueue) ? 32 : 0;
    }

#ifdef SISDUALHEAD
    /* In dual head mode, we share availMem equally - so align it
     * to 8KB; this way, the address of the FB of the second
     * head is aligned to 4KB for mapping.
     */
   if(pSiS->DualHeadMode)
      pSiS->availMem &= 0xFFFFE000;
#endif

    /* Check MaxXFBMem setting */
#ifdef SISDUALHEAD
    /* Since DRI is not supported in dual head mode, we
       don't need the MaxXFBMem setting. */
    if(pSiS->DualHeadMode) {
       if(pSiS->maxxfbmem) {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"MaxXFBMem not used in Dual Head mode. Using all VideoRAM.\n");
       }
       pSiS->maxxfbmem = pSiS->availMem;
    } else
#endif
       if(pSiS->maxxfbmem) {
    	  if(pSiS->maxxfbmem > pSiS->availMem) {
	     if(pSiS->sisfbMem) {
	        pSiS->maxxfbmem = pSiS->sisfbMem * 1024;
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
             	   	"Invalid MaxXFBMem setting. Using sisfb heap start information\n");
	     } else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                	"Invalid MaxXFBMem setting. Using all VideoRAM for framebuffer\n");
	        pSiS->maxxfbmem = pSiS->availMem;
	     }
	  } else if(pSiS->sisfbMem) {
	     if(pSiS->maxxfbmem > pSiS->sisfbMem * 1024) {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	       		"MaxXFBMem beyond sisfb heap start. Using sisfb heap start\n");
                pSiS->maxxfbmem = pSiS->sisfbMem * 1024;
	     }
	  }
    } else if(pSiS->sisfbMem) {
       pSiS->maxxfbmem = pSiS->sisfbMem * 1024;
    }
    else pSiS->maxxfbmem = pSiS->availMem;

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using %ldK of framebuffer memory\n",
    				pSiS->maxxfbmem / 1024);

    /* Find out about sub-classes of some chipsets and check
     * if the chipset supports two video overlays
     */
    if(pSiS->VGAEngine == SIS_300_VGA    ||
       pSiS->VGAEngine == SIS_315_VGA    ||
       pSiS->Chipset == PCI_CHIP_SIS530  ||
       pSiS->Chipset == PCI_CHIP_SIS6326 ||
       pSiS->Chipset == PCI_CHIP_SIS5597)  {
       pSiS->hasTwoOverlays = FALSE;
       switch(pSiS->Chipset) {
         case PCI_CHIP_SIS300:
         case PCI_CHIP_SIS630:
         case PCI_CHIP_SIS550:
	   pSiS->hasTwoOverlays = TRUE;
	   pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
	   break;
	 case PCI_CHIP_SIS315PRO:
	   pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
	   break;
         case PCI_CHIP_SIS330:
	   pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
	   pSiS->ChipFlags |= SiSCF_CRT2HWCKaputt;
	   break;
	 case PCI_CHIP_SIS660:
	   {
#if 0
	     static const char *id661str[] = {
	   	"661 ?", "661 ?", "661 ?", "661 ?",
		"661 ?", "661 ?", "661 ?", "661 ?",
		"661 ?", "661 ?", "661 ?", "661 ?",
		"661 ?", "661 ?", "661 ?", "661 ?"
	     };
#endif	     
	     pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
	     pSiS->hasTwoOverlays = TRUE;
	     pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
#if 0
	     if(pSiS->sishw_ext.jChipType == SIS_661) {
		inSISIDXREG(SISCR, 0x5f, CR5F);
	        CR5F &= 0xf0;
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	      "SiS661FX revision ID %x (%s)\n", CR5F, id661str[CR5F >> 4]);
             }
#endif
	     break;
	   }
         case PCI_CHIP_SIS650:
	   {
	     unsigned char tempreg1, tempreg2;
	     static const char *id650str[] = {
	   	"650",       "650",       "650",       "650",
		"650 A0 AA", "650 A2 CA", "650",       "650",
		"M650 A0",   "M650 A1 AA","651 A0 AA", "651 A1 AA",
		"M650",      "65?",       "651",       "65?"
	     };
	     pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
	     if(pSiS->sishw_ext.jChipType == SIS_650) {
		inSISIDXREG(SISCR, 0x5f, CR5F);
	        CR5F &= 0xf0;
	        andSISIDXREG(SISCR, 0x5c, 0x07);
		inSISIDXREG(SISCR, 0x5c, tempreg1);
		tempreg1 &= 0xf8;
		orSISIDXREG(SISCR, 0x5c, 0xf8);
		inSISIDXREG(SISCR, 0x5c, tempreg2);
		tempreg2 &= 0xf8;
		if((!tempreg1) || (tempreg2)) {
	           xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	      "SiS650 revision ID %x (%s)\n", CR5F, id650str[CR5F >> 4]);
	           if(CR5F & 0x80) {
	              pSiS->hasTwoOverlays = TRUE;  /* M650 or 651 */
		      pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
	           }
		   switch(CR5F) {
		      case 0xa0:
		      case 0xb0:
		      case 0xe0:
		         pSiS->ChipFlags |= SiSCF_Is651;
		         break;
		      case 0x80:
		      case 0x90:
		      case 0xc0:
		         pSiS->ChipFlags |= SiSCF_IsM650;
		         break;
		   }
		} else {
		   pSiS->hasTwoOverlays = TRUE;  
		   pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
		   switch(CR5F) {
		      case 0x90:
		         inSISIDXREG(SISCR, 0x5c, tempreg1);
			 tempreg1 &= 0xf8;
			 switch(tempreg1) {
			    case 0x00:
			       pSiS->ChipFlags |= SiSCF_IsM652;
			       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	                   "SiSM652 revision ID %x\n", CR5F);
			       break;
			    case 0x40:
			       pSiS->ChipFlags |= SiSCF_IsM653;
			       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	                   "SiSM653 revision ID %x\n", CR5F);
			       break;
			    default:
			       pSiS->ChipFlags |= SiSCF_IsM650;
			       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	                   "SiSM650 revision ID %x\n", CR5F);
			       break;
			 }
			 break;
		      case 0xb0:
		         pSiS->ChipFlags |= SiSCF_Is652;
			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	             "SiS652 revision ID %x\n", CR5F);
			 break;
		      default:
		         pSiS->ChipFlags |= SiSCF_IsM650;
			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	             "SiSM650 revision ID %x\n", CR5F);
			 break;
		   }
		}
	     }
             break;
	   }
       }
       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		"Hardware supports %s video overlay%s\n",
		pSiS->hasTwoOverlays ? "two" : "one",
		pSiS->hasTwoOverlays ? "s" : "");
    }

    /* Backup VB connection and CRT1 on/off register */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       inSISIDXREG(SISSR, 0x1f, pSiS->oldSR1F);
       inSISIDXREG(SISCR, 0x17, pSiS->oldCR17);
       inSISIDXREG(SISCR, 0x32, pSiS->oldCR32);
       inSISIDXREG(SISCR, 0x36, pSiS->oldCR36);
       inSISIDXREG(SISCR, 0x37, pSiS->oldCR37);
       if(pSiS->VGAEngine == SIS_315_VGA) {
          inSISIDXREG(SISCR, pSiS->myCR63, pSiS->oldCR63);
       }

       pSiS->postVBCR32 = pSiS->oldCR32;
    }

    /* There are some machines out there which require a special
     * setup of the GPIO registers in order to make the Chrontel
     * work. Try to find out if we're running on such a machine.
     * Furthermore, there is some highly customized hardware,
     * which requires some non-standard LVDS timing. Since the
     * vendors don't seem to care about PCI subsystem ID's we
     * need to find out using the BIOS version and date strings.
     */
    pSiS->SiS_Pr->SiS_ChSW = FALSE;
    if(pSiS->Chipset == PCI_CHIP_SIS630) {
       int i = 0;
       do {
	  if(mychswtable[i].subsysVendor == pSiS->PciInfo->subsysVendor &&
	     mychswtable[i].subsysCard == pSiS->PciInfo->subsysCard) {
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	         "PCI subsystem ID found in list for Chrontel/GPIO setup\n");
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		 "Vendor/Card: %s %s (ID %04x)\n",
		  mychswtable[i].vendorName,
		  mychswtable[i].cardName,
		  pSiS->PciInfo->subsysCard);
	     pSiS->SiS_Pr->SiS_ChSW = TRUE;
	     break;
          }
          i++;
       } while(mychswtable[i].subsysVendor != 0);
    }

    if(pSiS->SiS_Pr->SiS_CustomT == CUT_NONE) {
       int i = 0, j;
       unsigned short bversptr = 0;
       BOOLEAN footprint;
       unsigned long chksum = 0;

       if(pSiS->sishw_ext.UseROM) {
          bversptr = pSiS->BIOS[0x16] | (pSiS->BIOS[0x17] << 8);
          for(i=0; i<32768; i++) chksum += pSiS->BIOS[i];
       }

       i = 0;
       do {
	  if( (mycustomttable[i].chipID == pSiS->sishw_ext.jChipType)                 &&
	      ((!strlen(mycustomttable[i].biosversion)) ||
	       (pSiS->sishw_ext.UseROM &&
	       (!strncmp(mycustomttable[i].biosversion, (char *)&pSiS->BIOS[bversptr],
	                strlen(mycustomttable[i].biosversion)))))                     &&
	      ((!strlen(mycustomttable[i].biosdate)) ||
	       (pSiS->sishw_ext.UseROM &&
	       (!strncmp(mycustomttable[i].biosdate, (char *)&pSiS->BIOS[0x2c],
	                strlen(mycustomttable[i].biosdate)))))			      &&
	      ((!mycustomttable[i].bioschksum) ||
	       (pSiS->sishw_ext.UseROM &&
	       (mycustomttable[i].bioschksum == chksum)))			      &&
	      (mycustomttable[i].pcisubsysvendor == pSiS->PciInfo->subsysVendor)      &&
	      (mycustomttable[i].pcisubsyscard == pSiS->PciInfo->subsysCard) ) {
	     footprint = TRUE;
	     for(j=0; j<5; j++) {
	        if(mycustomttable[i].biosFootprintAddr[j]) {
		   if(pSiS->sishw_ext.UseROM) {
	              if(pSiS->BIOS[mycustomttable[i].biosFootprintAddr[j]] !=
		      				mycustomttable[i].biosFootprintData[j])
		         footprint = FALSE;
		   } else footprint = FALSE;
	        }
	     }
	     if(footprint) {
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	           "Identified %s %s, special timing applies\n",
		   mycustomttable[i].vendorName, mycustomttable[i].cardName);
	        pSiS->SiS_Pr->SiS_CustomT = mycustomttable[i].SpecialID;
	        break;
	     }
          }
          i++;
       } while(mycustomttable[i].chipID);
    }

    /* Handle ForceCRT1 option */
    if(pSiS->forceCRT1 != -1) {
       if(pSiS->forceCRT1) pSiS->CRT1off = 0;
       else                pSiS->CRT1off = 1;
    } else                 pSiS->CRT1off = -1;

    /* Detect video bridge and sense TV/VGA2 */
    SISVGAPreInit(pScrn);

    /* Detect CRT1 (via DDC1 and DDC2, hence via VGA port; regardless of LCDA) */
    SISCRT1PreInit(pScrn);

    /* Detect LCD (connected via CRT2, regardless of LCDA) and LCD resolution */
    SISLCDPreInit(pScrn);

    /* LCDA only supported under these conditions: */
    if(pSiS->ForceCRT1Type == CRT1_LCDA) {
       if( ((pSiS->sishw_ext.jChipType != SIS_650) &&
            (pSiS->sishw_ext.jChipType < SIS_661))     ||
	   (!(pSiS->VBFlags & (VB_301C | VB_302B | VB_301LV | VB_302LV))) ) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	  	"Chipset/Video bridge does not support LCD-via-CRT1\n");
	  pSiS->ForceCRT1Type = CRT1_VGA;
       } else if(!(pSiS->VBFlags & CRT2_LCD)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	  	"No digitally connected LCD panel found, LCD-via-CRT1 disabled\n");
	  pSiS->ForceCRT1Type = CRT1_VGA;
       }
    }

    /* Setup SD flags */
    pSiS->SiS_SD_Flags |= SiS_SD_ADDLSUPFLAG;

    if(pSiS->VBFlags & (VB_SISTVBRIDGE | VB_CHRONTEL)) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTTV;
    }

#ifdef ENABLE_YPBPR
    if((pSiS->VGAEngine == SIS_315_VGA) &&
       (pSiS->VBFlags & (VB_301C|VB_301LV|VB_302LV|VB_302ELV))) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTYPBPR;
       if((pSiS->Chipset == PCI_CHIP_SIS660) || (pSiS->VBFlags & VB_301C)) {
          pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTYPBPRAR;
       }
    }
    if(pSiS->VBFlags & (VB_301|VB_301B|VB_302B)) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTHIVISION;
    }
#endif

    if(pSiS->VBFlags & CRT2_LCD) {
       if((pSiS->VGAEngine != SIS_300_VGA) || (!(pSiS->VBFlags & VB_TRUMPION))) {
          pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTSCALE;
          if(pSiS->VBFlags & (VB_301|VB_301B|VB_302B|VB_301C)) {
             pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTCENTER;
          }
       }
    }

#ifdef TWDEBUG	/* @@@@@@ TEST @@@@@@ */
    pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTYPBPRAR;
    xf86DrvMsg(0, X_INFO, "TEST: Support Aspect Ratio\n");
#endif

    /* Detect CRT2-TV and PAL/NTSC mode */
    SISTVPreInit(pScrn);

    /* Detect CRT2-VGA */
    SISCRT2PreInit(pScrn);

    /* Backup detected CRT2 devices */
    pSiS->detectedCRT2Devices = pSiS->VBFlags & (CRT2_LCD|CRT2_TV|CRT2_VGA|TV_AVIDEO|TV_SVIDEO|TV_SCART|TV_HIVISION|TV_YPBPR);

    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPR)) {
       if((pSiS->ForceTVType != -1) && (pSiS->ForceTVType & TV_YPBPR)) {
          pSiS->ForceTVType = -1;
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "YPbPr TV output not supported\n");
       }
    }

    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTHIVISION)) {
       if((pSiS->ForceTVType != -1) && (pSiS->ForceTVType & TV_HIVISION)) {
          pSiS->ForceTVType = -1;
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "HiVision TV output not supported\n");
       }
    }

    if((pSiS->VBFlags & VB_SISTVBRIDGE) ||
       ((pSiS->VBFlags & VB_CHRONTEL) && (pSiS->ChrontelType == CHRONTEL_701x))) {
       pSiS->SiS_SD_Flags |= (SiS_SD_SUPPORTPALMN | SiS_SD_SUPPORTNTSCJ);
    }
    if((pSiS->VBFlags & VB_SISTVBRIDGE) ||
       ((pSiS->VBFlags & VB_CHRONTEL) && (pSiS->ChrontelType == CHRONTEL_700x))) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTTVPOS;
    }
    if(pSiS->VBFlags & (VB_301|VB_301B|VB_301C|VB_302B)) {
       pSiS->SiS_SD_Flags |= (SiS_SD_SUPPORTSCART | SiS_SD_SUPPORTVGA2);
    }
    if(pSiS->VBFlags & VB_CHRONTEL) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTOVERSCAN;
       if(pSiS->ChrontelType == CHRONTEL_700x) {
          pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTSOVER;
       }
    }

    if( ((pSiS->sishw_ext.jChipType == SIS_650) ||
         (pSiS->sishw_ext.jChipType >= SIS_661))                    &&
        (pSiS->VBFlags & (VB_301C | VB_302B | VB_301LV | VB_302LV)) &&
        (pSiS->VBFlags & CRT2_LCD) 			            &&
	(pSiS->VESA != 1) ) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTLCDA;
    } else {
       /* Paranoia */
       pSiS->ForceCRT1Type = CRT1_VGA;
    }

    pSiS->VBFlags |= pSiS->ForceCRT1Type;

#ifdef TWDEBUG
    xf86DrvMsg(0, X_INFO, "SDFlags %lx\n", pSiS->SiS_SD_Flags);
#endif

    /* Eventually overrule detected CRT2 type
     * If no type forced, use the detected devices in the order TV->LCD->VGA2
     * Since the Chrontel 7005 sometimes delivers wrong detection results,
     * we use a different order on such machines (LCD->TV)
     */
    if(pSiS->ForceCRT2Type == CRT2_DEFAULT) {
       if((pSiS->VBFlags & CRT2_TV) && (!((pSiS->VBFlags & VB_CHRONTEL) && (pSiS->VGAEngine == SIS_300_VGA))))
          pSiS->ForceCRT2Type = CRT2_TV;
       else if((pSiS->VBFlags & CRT2_LCD) && (pSiS->ForceCRT1Type == CRT1_VGA))
          pSiS->ForceCRT2Type = CRT2_LCD;
       else if(pSiS->VBFlags & CRT2_TV)
	  pSiS->ForceCRT2Type = CRT2_TV;
       else if(pSiS->VBFlags & CRT2_VGA)
          pSiS->ForceCRT2Type = CRT2_VGA;
    }

    switch(pSiS->ForceCRT2Type) {
       case CRT2_TV:
          pSiS->VBFlags &= ~(CRT2_LCD | CRT2_VGA);
          if(pSiS->VBFlags & (VB_SISTVBRIDGE | VB_CHRONTEL))
             pSiS->VBFlags |= CRT2_TV;
          else {
             pSiS->VBFlags &= ~(CRT2_TV);
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Hardware does not support TV output\n");
          }
          break;
       case CRT2_LCD:
          pSiS->VBFlags &= ~(CRT2_TV | CRT2_VGA);
          if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (pSiS->VBLCDFlags))
             pSiS->VBFlags |= CRT2_LCD;
          else {
             pSiS->VBFlags &= ~(CRT2_LCD);
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Can't force CRT2 to LCD, no LCD detected\n");
	  }
          break;
       case CRT2_VGA:
          pSiS->VBFlags &= ~(CRT2_TV | CRT2_LCD);
          if(pSiS->VBFlags & (VB_301|VB_301B|VB_301C|VB_302B))
	     pSiS->VBFlags |= CRT2_VGA;
	  else {
	     pSiS->VBFlags &= ~(CRT2_VGA);
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	         "Hardware does not support secondary VGA\n");
	  }
          break;
       default:
          pSiS->VBFlags &= ~(CRT2_TV | CRT2_LCD | CRT2_VGA);
    }

#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (pSiS->SecondHead)) {
#endif
       xf86DrvMsg(pScrn->scrnIndex, pSiS->CRT1gammaGiven ? X_CONFIG : X_INFO,
       	     "CRT1 gamma correction is %s\n",
             pSiS->CRT1gamma ? "enabled" : "disabled");

       if((pSiS->VGAEngine == SIS_315_VGA) && (!(pSiS->NoXvideo))) {
          xf86DrvMsg(pScrn->scrnIndex, pSiS->XvGammaGiven ? X_CONFIG : X_INFO,
       		"Separate Xv gamma correction for CRT1 is %s\n",
		pSiS->XvGamma ? "enabled" : "disabled");
	  if(pSiS->XvGamma) {
	     xf86DrvMsg(pScrn->scrnIndex, pSiS->XvGammaGiven ? X_CONFIG : X_INFO,
	        "Xv gamma correction: %.3f %.3f %.3f\n",
		(float)((float)pSiS->XvGammaRed / 1000),
		(float)((float)pSiS->XvGammaGreen / 1000),
		(float)((float)pSiS->XvGammaBlue / 1000));
	     if(!pSiS->CRT1gamma) {
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		      "Separate Xv gamma corr. only effective if CRT1 gamma corr. is enabled\n");
	     }
	  }
       }
#ifdef SISDUALHEAD
    }
#endif

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if( (pSiS->VBFlags & VB_SISBRIDGE) &&
           (!((pSiS->VBFlags & VB_30xBDH) && (pSiS->VBFlags & CRT2_LCD))) ) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CRT2 gamma correction is %s\n",
		pSiS->CRT2gamma ? "enabled" : "disabled");
       }
    }

    /* Eventually overrule TV Type (SVIDEO, COMPOSITE, SCART, HIVISION, YPBPR) */
    if(pSiS->VBFlags & VB_SISTVBRIDGE) {
       if(pSiS->ForceTVType != -1) {
    	  pSiS->VBFlags &= ~(TV_INTERFACE);
	  if(!(pSiS->VBFlags & VB_CHRONTEL)) {
	     pSiS->VBFlags &= ~(TV_CHSCART | TV_CHYPBPR525I);
	  }
	  pSiS->VBFlags |= pSiS->ForceTVType;
	  if(pSiS->VBFlags & TV_YPBPR) {
	     pSiS->VBFlags &= ~(TV_STANDARD);
	     pSiS->VBFlags &= ~(TV_YPBPRAR);
	     pSiS->VBFlags |= pSiS->ForceYPbPrType;
	     pSiS->VBFlags |= pSiS->ForceYPbPrAR;
	  }
       }
    }

    /* Handle ForceCRT1 option (part 2) */
    pSiS->CRT1changed = FALSE;
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       usScratchCR17 = pSiS->oldCR17;
       usScratchCR63 = pSiS->oldCR63;
       usScratchSR1F = pSiS->oldSR1F;
       usScratchCR32 = pSiS->postVBCR32;
       if(pSiS->VESA != 1) {
          /* Copy forceCRT1 option to CRT1off if option is given */
#ifdef SISDUALHEAD
          /* In DHM, handle this option only for master head, not the slave */
          if( (pSiS->forceCRT1 != -1) &&
	       (!(pSiS->DualHeadMode && pSiS->SecondHead)) ) {
#else
          if(pSiS->forceCRT1 != -1) {
#endif
             xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "CRT1 detection overruled by ForceCRT1 option\n");
    	     if(pSiS->forceCRT1) {
		 pSiS->CRT1off = 0;
		 if(pSiS->VGAEngine == SIS_300_VGA) {
		    if(!(usScratchCR17 & 0x80)) pSiS->CRT1changed = TRUE;
		 } else {
		    if(usScratchCR63 & 0x40) pSiS->CRT1changed = TRUE;
		 }
		 usScratchCR17 |= 0x80;
		 usScratchCR32 |= 0x20;
		 usScratchCR63 &= ~0x40;
		 usScratchSR1F &= ~0xc0;
	     } else {
	         if( ! ( (pScrn->bitsPerPixel == 8) &&
		         ( (pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) ||
		           ((pSiS->VBFlags & VB_30xBDH) && (pSiS->VBFlags & CRT2_LCD)) ) ) ) {
		    pSiS->CRT1off = 1;
		    if(pSiS->VGAEngine == SIS_300_VGA) {
		       if(usScratchCR17 & 0x80) pSiS->CRT1changed = TRUE;
		    } else {
		       if(!(usScratchCR63 & 0x40)) pSiS->CRT1changed = TRUE;
		    }
		    usScratchCR32 &= ~0x20;
		    /* We must not actually switch off CRT1 before we changed the mode! */
		 }
	     }
	     /* Here we can write to CR17 even on 315 series as we only ENABLE
	      * the bit here
	      */
	     outSISIDXREG(SISCR, 0x17, usScratchCR17);
	     if(pSiS->VGAEngine == SIS_315_VGA) {
	        outSISIDXREG(SISCR, pSiS->myCR63, usScratchCR63);
	     }
	     outSISIDXREG(SISCR, 0x32, usScratchCR32);
	     if(pSiS->CRT1changed) {
                outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
	        usleep(10000);
                outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	   		"CRT1 status changed by ForceCRT1 option\n");
	     }
	     outSISIDXREG(SISSR, 0x1f, usScratchSR1F);
          }
       }
       /* Store the new VB connection register contents for later mode changes */
       pSiS->newCR32 = usScratchCR32;
    }

    /* Check if CRT1 used (or needed; this eg. if no CRT2 detected) */
    if(pSiS->VBFlags & VB_VIDEOBRIDGE) {

        /* No CRT2 output? Then we NEED CRT1!
	 * We also need CRT1 if depth = 8 and bridge=LVDS|301B-DH
	 */
        if( (!(pSiS->VBFlags & (CRT2_VGA | CRT2_LCD | CRT2_TV))) ||
	    ( (pScrn->bitsPerPixel == 8) &&
	      ( (pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) ||
	        ((pSiS->VBFlags & VB_30xBDH) && (pSiS->VBFlags & CRT2_LCD)) ) ) ) {
	    pSiS->CRT1off = 0;
	}
	/* No CRT2 output? Then we can't use Xv on CRT2 */
	if(!(pSiS->VBFlags & (CRT2_VGA | CRT2_LCD | CRT2_TV)))
	    pSiS->XvOnCRT2 = FALSE;

    } else { /* no video bridge? */

        /* Then we NEED CRT1... */
        pSiS->CRT1off = 0;
	/* ... and can't use CRT2 for Xv output */
	pSiS->XvOnCRT2 = FALSE;
    }

    /* LCDA? Then we don't switch off CRT1 */
    if(pSiS->VBFlags & CRT1_LCDA) pSiS->CRT1off = 0;

    /* Handle TVStandard option */
    if((pSiS->NonDefaultPAL != -1) || (pSiS->NonDefaultNTSC != -1)) {
       if( (!(pSiS->VBFlags & VB_SISTVBRIDGE)) &&
	   (!((pSiS->VBFlags & VB_CHRONTEL)) && (pSiS->ChrontelType == CHRONTEL_701x)) ) {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	   	"PALM, PALN and NTSCJ not supported on this hardware\n");
 	  pSiS->NonDefaultPAL = pSiS->NonDefaultNTSC = -1;
	  pSiS->VBFlags &= ~(TV_PALN | TV_PALM | TV_NTSCJ);
	  pSiS->SiS_SD_Flags &= ~(SiS_SD_SUPPORTPALMN | SiS_SD_SUPPORTNTSCJ);
       }
    }
    if(pSiS->OptTVStand != -1) {
       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	  if( (!((pSiS->VBFlags & VB_CHRONTEL) && (pSiS->VBFlags & (TV_CHSCART | TV_CHYPBPR525I)))) &&
	      (!(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR))) ) {
    	     pSiS->VBFlags &= ~(TV_PAL | TV_NTSC | TV_PALN | TV_PALM | TV_NTSCJ);
    	     if(pSiS->OptTVStand) {
	        pSiS->VBFlags |= TV_PAL;
	        if(pSiS->NonDefaultPAL == 1)  pSiS->VBFlags |= TV_PALM;
	        else if(!pSiS->NonDefaultPAL) pSiS->VBFlags |= TV_PALN;
	     } else {
	        pSiS->VBFlags |= TV_NTSC;
		if(pSiS->NonDefaultNTSC == 1) pSiS->VBFlags |= TV_NTSCJ;
	     }
	  } else {
	     pSiS->OptTVStand = pSiS->NonDefaultPAL = -1;
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	    	 "Option TVStandard ignored for YPbPr, HiVision and Chrontel-SCART\n");
	  }
       } else if(pSiS->Chipset == PCI_CHIP_SIS6326) {
	  pSiS->SiS6326Flags &= ~SIS6326_TVPAL;
	  if(pSiS->OptTVStand) pSiS->SiS6326Flags |= SIS6326_TVPAL;
       }
    }

    /* SCART only supported for PAL */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if((pSiS->VBFlags & VB_SISBRIDGE) && (pSiS->VBFlags & TV_SCART)) {
	  pSiS->VBFlags &= ~(TV_NTSC | TV_PALN | TV_PALM | TV_NTSCJ);
	  pSiS->VBFlags |= TV_PAL;
	  pSiS->OptTVStand = 1;
	  pSiS->NonDefaultPAL = pSiS->NonDefaultNTSC = -1;
       }
    }

#ifdef SIS_CP
    SIS_CP_DRIVER_RECONFIGOPT
#endif

    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
       if(pSiS->sis6326tvplug != -1) {
          pSiS->SiS6326Flags &= ~(SIS6326_TVSVIDEO | SIS6326_TVCVBS);
	  pSiS->SiS6326Flags |= SIS6326_TVDETECTED;
	  if(pSiS->sis6326tvplug == 1) 	pSiS->SiS6326Flags |= SIS6326_TVCVBS;
	  else 				pSiS->SiS6326Flags |= SIS6326_TVSVIDEO;
	  xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	  	"SiS6326 TV plug type detection overruled by %s\n",
		(pSiS->SiS6326Flags & SIS6326_TVCVBS) ? "COMPOSITE" : "SVIDEO");
       }
    }

    /* Do some checks */
    if(pSiS->OptTVOver != -1) {
       if(pSiS->VBFlags & VB_CHRONTEL) {
	  pSiS->UseCHOverScan = pSiS->OptTVOver;
       } else {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	    	"CHTVOverscan only supported on CHRONTEL 70xx\n");
          pSiS->UseCHOverScan = -1;
       }
    } else pSiS->UseCHOverScan = -1;

    if(pSiS->sistvedgeenhance != -1) {
       if(!(pSiS->VBFlags & VB_301)) {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "SISTVEdgeEnhance only supported on SiS301\n");
	  pSiS->sistvedgeenhance = -1;
       }
    }
    if(pSiS->sistvsaturation != -1) {
       if(pSiS->VBFlags & VB_301) {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "SISTVSaturation not supported on SiS301\n");
	  pSiS->sistvsaturation = -1;
       }
    }

    /* Do some MergedFB mode initialisation */
#ifdef SISMERGED
    if(pSiS->MergedFB) {
       pSiS->CRT2pScrn = xalloc(sizeof(ScrnInfoRec));
       if(!pSiS->CRT2pScrn) {
          SISErrorLog(pScrn, "Failed to allocate memory for 2nd pScrn, %s\n", mergeddisstr);
	  pSiS->MergedFB = FALSE;
       } else {
          memcpy(pSiS->CRT2pScrn, pScrn, sizeof(ScrnInfoRec));
       }
    }
#endif


    /* Determine CRT1<>CRT2 mode
     *     Note: When using VESA or if the bridge is in slavemode, display
     *           is ALWAYS in MIRROR_MODE!
     *           This requires extra checks in functions using this flag!
     *           (see sis_video.c for example)
     */
    if(pSiS->VBFlags & DISPTYPE_DISP2) {
        if(pSiS->CRT1off) {	/* CRT2 only ------------------------------- */
#ifdef SISDUALHEAD
	     if(pSiS->DualHeadMode) {
	     	SISErrorLog(pScrn,
		    "CRT1 not detected or forced off. Dual Head mode can't initialize.\n");
	     	if(pSiSEnt) pSiSEnt->DisableDual = TRUE;
	        if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
		if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
		pSiS->pInt = NULL;
		sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
		SISFreeRec(pScrn);
		return FALSE;
	     }
#endif
#ifdef SISMERGED
	     if(pSiS->MergedFB) {
	        if(pSiS->MergedFBAuto) {
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, mergednocrt1, mergeddisstr);
		} else {
	     	   SISErrorLog(pScrn, mergednocrt1, mergeddisstr);
		}
		if(pSiS->CRT2pScrn) xfree(pSiS->CRT2pScrn);
		pSiS->CRT2pScrn = NULL;
		pSiS->MergedFB = FALSE;
	     }
#endif
	     pSiS->VBFlags |= VB_DISPMODE_SINGLE;
	     /* No CRT1? Then we use the video overlay on CRT2 */
	     pSiS->XvOnCRT2 = TRUE;
	} else			/* CRT1 and CRT2 - mirror or dual head ----- */
#ifdef SISDUALHEAD
	     if(pSiS->DualHeadMode) {
		pSiS->VBFlags |= (VB_DISPMODE_DUAL | DISPTYPE_CRT1);
	        if(pSiS->VESA != -1) {
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"VESA option not used in Dual Head mode. VESA disabled.\n");
		}
		if(pSiSEnt) pSiSEnt->DisableDual = FALSE;
		pSiS->VESA = 0;
	     } else
#endif
#ifdef SISMERGED
	            if(pSiS->MergedFB) {
		 pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_CRT1);
		 if(pSiS->VESA != -1) {
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"VESA option not used in MergedFB mode. VESA disabled.\n");
		 }
		 pSiS->VESA = 0;
	     } else
#endif
		 pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_CRT1);
    } else {			/* CRT1 only ------------------------------- */
#ifdef SISDUALHEAD
	     if(pSiS->DualHeadMode) {
	     	SISErrorLog(pScrn,
		   "No CRT2 output selected or no bridge detected. "
		   "Dual Head mode can't initialize.\n");
	        if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
		if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
		pSiS->pInt = NULL;
		sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
		SISFreeRec(pScrn);
		return FALSE;
	     }
#endif
#ifdef SISMERGED
	     if(pSiS->MergedFB) {
	        if(pSiS->MergedFBAuto) {
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, mergednocrt2, mergeddisstr);
		} else {
	     	   SISErrorLog(pScrn, mergednocrt2, mergeddisstr);
		}
		if(pSiS->CRT2pScrn) xfree(pSiS->CRT2pScrn);
		pSiS->CRT2pScrn = NULL;
		pSiS->MergedFB = FALSE;
	     }
#endif
             pSiS->VBFlags |= (VB_DISPMODE_SINGLE | DISPTYPE_CRT1);
    }

    if((pSiS->VGAEngine == SIS_315_VGA) || (pSiS->VGAEngine == SIS_300_VGA)) {
       if((!pSiS->NoXvideo) && (!pSiS->hasTwoOverlays)) {
	  xf86DrvMsg(pScrn->scrnIndex, from,
	      "Using Xv overlay by default on CRT%d\n",
	      pSiS->XvOnCRT2 ? 2 : 1);
       }
    }

    /* Init Ptrs for Save/Restore functions and calc MaxClock */
    SISDACPreInit(pScrn);

    /* ********** end of VBFlags setup ********** */

    /* VBFlags are initialized now. Back them up for SlaveMode modes. */
    pSiS->VBFlags_backup = pSiS->VBFlags;

    /* Backup CR32,36,37 (in order to write them back after a VT switch) */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       inSISIDXREG(SISCR,0x32,pSiS->myCR32);
       inSISIDXREG(SISCR,0x36,pSiS->myCR36);
       inSISIDXREG(SISCR,0x37,pSiS->myCR37);
    }

    /* Find out about paneldelaycompensation and evaluate option */
#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead)) {
#endif
       if(pSiS->VGAEngine == SIS_300_VGA) {

          if(pSiS->VBFlags & (VB_LVDS | VB_30xBDH)) {
	  
	     /* Save the current PDC if the panel is used at the moment.
	      * This seems by far the safest way to find out about it.
	      * If the system is using an old version of sisfb, we can't
	      * trust the pdc register value. If sisfb saved the pdc for
	      * us, use it.
	      */
	     if(pSiS->sisfbpdc != 0xff) {
	        pSiS->SiS_Pr->PDC = pSiS->sisfbpdc;
	     } else {
	        if(!(pSiS->donttrustpdc)) {
	           unsigned char tmp;
	           inSISIDXREG(SISCR, 0x30, tmp);
	           if(tmp & 0x20) {
	              inSISIDXREG(SISPART1, 0x13, pSiS->SiS_Pr->PDC);
                   } else {
	             xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	          "Unable to detect LCD PanelDelayCompensation, LCD is not active\n");
	           }
	        } else {
	           xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	        "Unable to detect LCD PanelDelayCompensation, please update sisfb\n");
	        }
	     }
	     if(pSiS->SiS_Pr->PDC != -1) {
	        pSiS->SiS_Pr->PDC &= 0x3c;
	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	       	     "Detected LCD PanelDelayCompensation 0x%02x\n",
		     pSiS->SiS_Pr->PDC);
	     }

	     /* If we haven't been able to find out, use our other methods */
	     if(pSiS->SiS_Pr->PDC == -1) {
                int i=0;
                do {
	           if(mypdctable[i].subsysVendor == pSiS->PciInfo->subsysVendor &&
	              mypdctable[i].subsysCard == pSiS->PciInfo->subsysCard) {
	                 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	   	            "PCI card/vendor identified for non-default PanelDelayCompensation\n");
		         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		             "Vendor: %s, card: %s (ID %04x), PanelDelayCompensation: 0x%02x\n",
		             mypdctable[i].vendorName, mypdctable[i].cardName,
		             pSiS->PciInfo->subsysCard, mypdctable[i].pdc);
                         if(pSiS->PDC == -1) {
		            pSiS->PDC = mypdctable[i].pdc;
		         } else {
		            xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       	        "PanelDelayCompensation overruled by option\n");
		         }
	                 break;
                   }
	           i++;
                } while(mypdctable[i].subsysVendor != 0);
             }

	     if(pSiS->PDC != -1) {
	        if(pSiS->BIOS) {
	           if(pSiS->VBFlags & VB_LVDS) {
	              if(pSiS->BIOS[0x220] & 0x80) {
                         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		             "BIOS contains custom LCD Panel Delay Compensation 0x%02x\n",
		             pSiS->BIOS[0x220] & 0x3c);
	                 pSiS->BIOS[0x220] &= 0x7f;
		      }
	           }
	           if(pSiS->VBFlags & (VB_301B|VB_302B)) {
	              if(pSiS->BIOS[0x220] & 0x80) {
                         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		             "BIOS contains custom LCD Panel Delay Compensation 0x%02x\n",
		               (  (pSiS->VBLCDFlags & VB_LCD_1280x1024) ?
			                 pSiS->BIOS[0x223] : pSiS->BIOS[0x224]  ) & 0x3c);
	                 pSiS->BIOS[0x220] &= 0x7f;
		      }
		   }
	        }
	        pSiS->SiS_Pr->PDC = (pSiS->PDC & 0x3c);
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	              "Using LCD Panel Delay Compensation 0x%02x\n", pSiS->SiS_Pr->PDC);
	     }
	  }

       }  /* SIS_300_VGA */

       if(pSiS->VGAEngine == SIS_315_VGA) {

          unsigned char tmp, tmp2;
	  inSISIDXREG(SISCR, 0x30, tmp);

	  /* Save the current PDC if the panel is used at the moment. */
	  if(pSiS->VBFlags & (VB_301LV | VB_302LV | VB_302ELV)) {

	     if(pSiS->sisfbpdc != 0xff) {
	        pSiS->SiS_Pr->PDC = pSiS->sisfbpdc;
	     }
	     if(pSiS->sisfbpdca != 0xff) {
	        pSiS->SiS_Pr->PDCA = pSiS->sisfbpdca;
	     }

	     if(!pSiS->donttrustpdc) {
	        if((pSiS->sisfbpdc == 0xff) && (pSiS->sisfbpdca == 0xff)) {
		   CARD16 tempa, tempb;
		   inSISIDXREG(SISPART1,0x2d,tmp2);
		   tempa = (tmp2 & 0xf0) >> 3;
		   tempb = (tmp2 & 0x0f) << 1;
		   inSISIDXREG(SISPART1,0x20,tmp2);
		   tempa |= ((tmp2 & 0x40) >> 6);
		   inSISIDXREG(SISPART1,0x35,tmp2);
		   tempb |= ((tmp2 & 0x80) >> 7);
		   inSISIDXREG(SISPART1,0x13,tmp2);
		   if(!pSiS->ROM661New) {
		      if((tmp2 & 0x04) || (tmp & 0x20)) {
		         pSiS->SiS_Pr->PDCA = tempa;
		         pSiS->SiS_Pr->PDC  = tempb;
		      } else {
		         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	             "Unable to detect PanelDelayCompensation, LCD is not active\n");
		      }
		   } else {
		      if(tmp2 & 0x04) {
		         pSiS->SiS_Pr->PDCA = tempa;
		      } else if(tmp & 0x20) {
		         pSiS->SiS_Pr->PDC  = tempb;
		      } else {
		         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	             "Unable to detect PanelDelayCompensation, LCD is not active\n");
		      }
		   }
		}
	     } else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	    "Unable to detect PanelDelayCompensation, please update sisfb\n");
	     }
	     if(pSiS->SiS_Pr->PDC != -1) {
	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      	     "Detected LCD PanelDelayCompensation 0x%02x (for LCD=CRT2)\n",
		     pSiS->SiS_Pr->PDC);
	     }
	     if(pSiS->SiS_Pr->PDCA != -1) {
	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      	     "Detected LCD PanelDelayCompensation1 0x%02x (for LCD=CRT1)\n",
		     pSiS->SiS_Pr->PDCA);
	     }
	  }

	  /* Let user override (for all bridges) */
	  if(pSiS->VBFlags & (VB_301B | VB_301C | VB_301LV | VB_302LV | VB_302ELV)) {
	     if(pSiS->PDC != -1) {
	        pSiS->SiS_Pr->PDC = pSiS->PDC & 0x1f;
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	      	     "Using LCD PanelDelayCompensation 0x%02x (for LCD=CRT2)\n",
		     pSiS->SiS_Pr->PDC);
	     }
	     if(pSiS->PDCA != -1) {
	        pSiS->SiS_Pr->PDCA = pSiS->PDCA & 0x1f;
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	      	     "Using LCD PanelDelayCompensation1 0x%02x (for LCD=CRT1)\n",
		     pSiS->SiS_Pr->PDCA);
	     }
          }

 	  /* Read the current EMI (if not overruled) */
	  if(pSiS->VBFlags & (VB_302LV | VB_302ELV)) {
	     MessageType from = X_PROBED;
	     if(pSiS->EMI != -1) {
	        pSiS->SiS_Pr->EMI_30 = (pSiS->EMI >> 24) & 0x60;
	        pSiS->SiS_Pr->EMI_31 = (pSiS->EMI >> 16) & 0xff;
	        pSiS->SiS_Pr->EMI_32 = (pSiS->EMI >> 8)  & 0xff;
	        pSiS->SiS_Pr->EMI_33 = pSiS->EMI & 0xff;
		pSiS->SiS_Pr->HaveEMI = pSiS->SiS_Pr->HaveEMILCD = TRUE;
		pSiS->SiS_Pr->OverruleEMI = TRUE;
		from = X_CONFIG;
	     } else if((pSiS->sisfbfound) && (pSiS->sisfb_haveemi)) {
	        pSiS->SiS_Pr->EMI_30 = pSiS->sisfb_emi30;
	        pSiS->SiS_Pr->EMI_31 = pSiS->sisfb_emi31;
	        pSiS->SiS_Pr->EMI_32 = pSiS->sisfb_emi32;
	        pSiS->SiS_Pr->EMI_33 = pSiS->sisfb_emi33;
		pSiS->SiS_Pr->HaveEMI = TRUE;
		if(pSiS->sisfb_haveemilcd) pSiS->SiS_Pr->HaveEMILCD = TRUE;
		pSiS->SiS_Pr->OverruleEMI = FALSE;
	     } else {
	        inSISIDXREG(SISPART4, 0x30, pSiS->SiS_Pr->EMI_30);
		inSISIDXREG(SISPART4, 0x31, pSiS->SiS_Pr->EMI_31);
		inSISIDXREG(SISPART4, 0x32, pSiS->SiS_Pr->EMI_32);
		inSISIDXREG(SISPART4, 0x33, pSiS->SiS_Pr->EMI_33);
		pSiS->SiS_Pr->HaveEMI = TRUE;
		if(tmp & 0x20) pSiS->SiS_Pr->HaveEMILCD = TRUE;
		pSiS->SiS_Pr->OverruleEMI = FALSE;
	     }
	     xf86DrvMsg(pScrn->scrnIndex, from,
	     	   "302LV/302ELV: Using EMI 0x%02x%02x%02x%02x%s\n",
		   pSiS->SiS_Pr->EMI_30,pSiS->SiS_Pr->EMI_31,
		   pSiS->SiS_Pr->EMI_32,pSiS->SiS_Pr->EMI_33,
		   pSiS->SiS_Pr->HaveEMILCD ? " (LCD)" : "");
	  }

       } /* SIS_315_VGA */
#ifdef SISDUALHEAD
    }
#endif

#ifdef SISDUALHEAD
    /* In dual head mode, both heads (currently) share the maxxfbmem equally.
     * If memory sharing is done differently, the following has to be changed;
     * the other modules (eg. accel and Xv) use dhmOffset for hardware
     * pointer settings relative to VideoRAM start and won't need to be changed.
     */
    if(pSiS->DualHeadMode) {
        if(pSiS->SecondHead == FALSE) {
	    /* ===== First head (always CRT2) ===== */
	    /* We use only half of the memory available */
	    pSiS->maxxfbmem /= 2;
	    /* Initialize dhmOffset */
	    pSiS->dhmOffset = 0;
	    /* Copy framebuffer addresses & sizes to entity */
	    pSiSEnt->masterFbAddress = pSiS->FbAddress;
	    pSiSEnt->masterFbSize    = pSiS->maxxfbmem;
	    pSiSEnt->slaveFbAddress  = pSiS->FbAddress + pSiS->maxxfbmem;
	    pSiSEnt->slaveFbSize     = pSiS->maxxfbmem;
	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	    		"%ldKB video RAM at 0x%lx available for master head (CRT2)\n",
	    		pSiS->maxxfbmem/1024, pSiS->FbAddress);
	} else {
	    /* ===== Second head (always CRT1) ===== */
	    /* We use only half of the memory available */
	    pSiS->maxxfbmem /= 2;
	    /* Adapt FBAddress */
	    pSiS->FbAddress += pSiS->maxxfbmem;
	    /* Initialize dhmOffset */
	    pSiS->dhmOffset = pSiS->availMem - pSiS->maxxfbmem;
	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	    		"%ldKB video RAM at 0x%lx available for slave head (CRT1)\n",
	    		pSiS->maxxfbmem/1024,  pSiS->FbAddress);
	}
    } else
        pSiS->dhmOffset = 0;
#endif

    /* Note: Do not use availMem for anything from now. Use
     * maxxfbmem instead. (availMem does not take dual head
     * mode into account.)
     */

    pSiS->DRIheapstart = pSiS->maxxfbmem;
    pSiS->DRIheapend = pSiS->availMem;
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       pSiS->DRIheapstart = pSiS->DRIheapend = 0;
    } else
#endif
    if(pSiS->DRIheapstart == pSiS->DRIheapend) {
#if 0  /* For future use */
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	  "No memory for DRI heap. Please set the option \"MaxXFBMem\" to\n"
	  "\tlimit the memory XFree should use and leave the rest to DRI\n");
#endif
       pSiS->DRIheapstart = pSiS->DRIheapend = 0;
    }

    /* Now for something completely different: DDC.
     * For 300 and 315/330 series, we provide our
     * own functions (in order to probe CRT2 as well)
     * If these fail, use the VBE.
     * All other chipsets will use VBE. No need to re-invent
     * the wheel there.
     */

    pSiS->pVbe = NULL;
    didddc2 = FALSE;

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if(xf86LoadSubModule(pScrn, "ddc")) {
          int crtnum = 0;
          xf86LoaderReqSymLists(ddcSymbols, NULL);
	  if((pMonitor = SiSDoPrivateDDC(pScrn, &crtnum))) {
	     didddc2 = TRUE;
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcsstr, crtnum);
	     xf86PrintEDID(pMonitor);
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcestr, crtnum);
	     xf86SetDDCproperties(pScrn, pMonitor);
	     pScrn->monitor->DDC = pMonitor;
          }
       }
    }

#ifdef SISDUALHEAD
    /* In dual head mode, probe DDC using VBE only for CRT1 (second head) */
    if((pSiS->DualHeadMode) && (!didddc2) && (!pSiS->SecondHead))
         didddc2 = TRUE;
#endif

    if(!didddc2) {
       /* If CRT1 is off or LCDA, skip DDC via VBE */
       if((pSiS->CRT1off) || (pSiS->VBFlags & CRT1_LCDA))
          didddc2 = TRUE;
    }

    /* Now (re-)load and initialize the DDC module */
    if(!didddc2) {

       if(xf86LoadSubModule(pScrn, "ddc")) {

          xf86LoaderReqSymLists(ddcSymbols, NULL);

          /* Now load and initialize VBE module. */
          if(xf86LoadSubModule(pScrn, "vbe")) {
	      xf86LoaderReqSymLists(vbeSymbols, NULL);
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	      pSiS->pVbe = VBEInit(pSiS->pInt,pSiS->pEnt->index);
#else
              pSiS->pVbe = VBEExtendedInit(pSiS->pInt,pSiS->pEnt->index,
	                SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
#endif
              if(!pSiS->pVbe) {
	         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	            "Could not initialize VBE module for DDC\n");
              }
          } else {
              xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	          "Could not load VBE module for DDC\n");
          }

  	  if(pSiS->pVbe) {
	      if((pMonitor = vbeDoEDID(pSiS->pVbe,NULL))) {
	         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	      "VBE CRT1 DDC monitor info:\n");
                 xf86SetDDCproperties(pScrn, xf86PrintEDID(pMonitor));
		 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	      "End of VBE CRT1 DDC monitor info:\n");
		 pScrn->monitor->DDC = pMonitor;
              }
          } else {
	      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"Could not retrieve DDC data\n");
	  }
       }
    }

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       pSiS->CRT2pScrn->monitor = xalloc(sizeof(MonRec));
       if(pSiS->CRT2pScrn->monitor) {
          DisplayModePtr tempm = NULL, currentm = NULL, newm = NULL;
          memcpy(pSiS->CRT2pScrn->monitor, pScrn->monitor, sizeof(MonRec));
          pSiS->CRT2pScrn->monitor->DDC = NULL;
	  pSiS->CRT2pScrn->monitor->Modes = NULL;
	  tempm = pScrn->monitor->Modes;
	  while(tempm) {
	     if(!(newm = xalloc(sizeof(DisplayModeRec)))) break;
	     memcpy(newm, tempm, sizeof(DisplayModeRec));
	     if(!(newm->name = xalloc(strlen(tempm->name) + 1))) {
	        xfree(newm);
		break;
	     }
	     strcpy(newm->name, tempm->name);
	     if(!pSiS->CRT2pScrn->monitor->Modes) pSiS->CRT2pScrn->monitor->Modes = newm;
	     if(currentm) {
	        currentm->next = newm;
		newm->prev = currentm;
	     }
	     currentm = newm;
	     tempm = tempm->next;
	  }
          if(pSiS->CRT2HSync) {
             pSiS->CRT2pScrn->monitor->nHsync =
	    	SiSStrToRanges(pSiS->CRT2pScrn->monitor->hsync, pSiS->CRT2HSync, MAX_HSYNC);
          }
          if(pSiS->CRT2VRefresh) {
             pSiS->CRT2pScrn->monitor->nVrefresh =
	    	SiSStrToRanges(pSiS->CRT2pScrn->monitor->vrefresh, pSiS->CRT2VRefresh, MAX_VREFRESH);
          }
	  if((pMonitor = SiSInternalDDC(pSiS->CRT2pScrn, 1))) {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcsstr, 2);
	     xf86PrintEDID(pMonitor);
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcestr, 2);
	     xf86SetDDCproperties(pSiS->CRT2pScrn, pMonitor);
	     pSiS->CRT2pScrn->monitor->DDC = pMonitor;
	     /* use DDC data if no ranges in config file */
	     if(!pSiS->CRT2HSync) {
	        pSiS->CRT2pScrn->monitor->nHsync = 0;
	     }
	     if(!pSiS->CRT2VRefresh) {
	        pSiS->CRT2pScrn->monitor->nVrefresh = 0;
	     }
          } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	     	"Failed to read DDC data for CRT2\n");
	  }
       } else {
          SISErrorLog(pScrn, "Failed to allocate memory for CRT2 monitor, %s.\n",
	  		mergeddisstr);
	  if(pSiS->CRT2pScrn) xfree(pSiS->CRT2pScrn);
    	  pSiS->CRT2pScrn = NULL;
	  pSiS->MergedFB = FALSE;
       }
    }
#endif

    /* If there is no HSync or VRefresh data for the monitor,
     * derive it from DDC data. Done by common layer since
     * 4.3.99.14.
     */
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,14,0)
    if(pScrn->monitor->DDC) {
       if(pScrn->monitor->nHsync <= 0) {
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, subshstr,
#ifdef SISDUALHEAD
			pSiS->DualHeadMode ? (pSiS->SecondHead ? 1 : 2) :
#endif
		 		pSiS->CRT1off ? 2 : 1);
         SiSSetSyncRangeFromEdid(pScrn, 1);
       }
       if(pScrn->monitor->nVrefresh <= 0) {
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, subsvstr,
#ifdef SISDUALHEAD
			pSiS->DualHeadMode ? (pSiS->SecondHead ? 1 : 2) :
#endif
		  		pSiS->CRT1off ? 2 : 1);
         SiSSetSyncRangeFromEdid(pScrn, 0);
       }
    }
#endif

#ifdef SISMERGED
    if(pSiS->MergedFB) {
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,14,0)
       if(pSiS->CRT2pScrn->monitor->DDC) {
          if(pSiS->CRT2pScrn->monitor->nHsync <= 0) {
             xf86DrvMsg(pScrn->scrnIndex, X_INFO, subshstr, 2);
             SiSSetSyncRangeFromEdid(pSiS->CRT2pScrn, 1);
          }
          if(pSiS->CRT2pScrn->monitor->nVrefresh <= 0) {
             xf86DrvMsg(pScrn->scrnIndex, X_INFO, subsvstr, 2);
             SiSSetSyncRangeFromEdid(pSiS->CRT2pScrn, 0);
          }
       }
#endif

       xf86DrvMsg(pScrn->scrnIndex, X_INFO, crtsetupstr, 1);
    }
#endif
    /* end of DDC */

    /* From here, we mainly deal with clocks and modes */

    /* Set the min pixel clock */
    pSiS->MinClock = 5000;
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       pSiS->MinClock = 12000;
    }
    xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Min pixel clock is %d MHz\n",
                pSiS->MinClock / 1000);

    from = X_PROBED;
    /*
     * If the user has specified ramdac speed in the XF86Config
     * file, we respect that setting.
     */
    if(pSiS->pEnt->device->dacSpeeds[0]) {
        int speed = 0;
        switch(pScrn->bitsPerPixel) {
        case 8:
           speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP8];
           break;
        case 16:
           speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP16];
           break;
        case 24:
           speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP24];
           break;
        case 32:
           speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP32];
           break;
        }
        if(speed == 0)
            pSiS->MaxClock = pSiS->pEnt->device->dacSpeeds[0];
        else
            pSiS->MaxClock = speed;
        from = X_CONFIG;
    }
    xf86DrvMsg(pScrn->scrnIndex, from, "Max pixel clock is %d MHz\n",
                pSiS->MaxClock / 1000);

    /*
     * Setup the ClockRanges, which describe what clock ranges are available,
     * and what sort of modes they can be used for.
     */
    clockRanges = xnfcalloc(sizeof(ClockRange), 1);
    clockRanges->next = NULL;
    clockRanges->minClock = pSiS->MinClock;
    clockRanges->maxClock = pSiS->MaxClock;
    clockRanges->clockIndex = -1;               /* programmable */
    clockRanges->interlaceAllowed = TRUE;
    clockRanges->doubleScanAllowed = TRUE;

    /*
     * Since we have lots of built-in modes for 300/315/330 series
     * with vb support, we replace the given default mode list with our
     * own. In case the video bridge is to be used, we only allow other
     * modes if
     *   -) vbtype is 301, 301B, 301C or 302B, and
     *   -) crt2 device is not TV, and
     *   -) crt1 is not LCDA
     */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if(!(pSiS->noInternalModes)) {
          BOOLEAN acceptcustommodes = TRUE;
	  BOOLEAN includelcdmodes   = TRUE;
	  BOOLEAN isfordvi          = FALSE;
          if(pSiS->UseVESA) {
	     acceptcustommodes = FALSE;
	     includelcdmodes   = FALSE;
	  }
#ifdef SISDUALHEAD
          if(pSiS->DualHeadMode) {
	     if(!pSiS->SecondHead) {
	        if((pSiS->VBFlags & (VB_301|VB_301B|VB_301C|VB_302B)) && (!(pSiS->VBFlags & VB_30xBDH))) {
		   if(!(pSiS->VBFlags & (CRT2_LCD|CRT2_VGA))) includelcdmodes   = FALSE;
		   if(pSiS->VBFlags & CRT2_LCD)               isfordvi          = TRUE;
		   if(pSiS->VBFlags & CRT2_TV)                acceptcustommodes = FALSE;
		} else {
		   acceptcustommodes = FALSE;
		   includelcdmodes   = FALSE;
		}
		clockRanges->interlaceAllowed = FALSE;
	     } else {
	        includelcdmodes = FALSE;
		if(pSiS->VBFlags & CRT1_LCDA) {
		   acceptcustommodes = FALSE;
		   /* Ignore interlace, mode switching code will handle this */
		}
	     }
	  } else
#endif
#ifdef SISMERGED
          if(pSiS->MergedFB) {
	     includelcdmodes = FALSE;
	     if(pSiS->VBFlags & CRT1_LCDA) {
		acceptcustommodes = FALSE;
		/* Ignore interlace, mode switching code will handle this */
	     }
          } else
#endif
          if((pSiS->VBFlags & (VB_301|VB_301B|VB_301C|VB_302B))  && (!(pSiS->VBFlags & VB_30xBDH))) {
	     if(!(pSiS->VBFlags & (CRT2_LCD|CRT2_VGA))) includelcdmodes   = FALSE;
	     if(pSiS->VBFlags & CRT2_LCD)               isfordvi          = TRUE;
	     if(pSiS->VBFlags & (CRT2_TV|CRT1_LCDA))    acceptcustommodes = FALSE;
	  } else if(pSiS->VBFlags & (CRT2_ENABLE | CRT1_LCDA)) {
	     acceptcustommodes = FALSE;
	     includelcdmodes   = FALSE;
	  } else {
	     includelcdmodes   = FALSE;
	  }
	  /* Ignore interlace, mode switching code will handle this */

	  pSiS->HaveCustomModes = FALSE;
          if(SiSMakeOwnModeList(pScrn, acceptcustommodes, includelcdmodes, isfordvi, &pSiS->HaveCustomModes)) {
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	         "Replaced %s mode list with built-in modes\n",
	     pSiS->HaveCustomModes ? "default" : "entire");
#ifdef TWDEBUG
             pScrn->modes = pScrn->monitor->Modes;
	     xf86PrintModes(pScrn);
	     pScrn->modes = NULL;
#endif
          } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	   	"Building list of built-in modes failed, using XFree86 defaults\n");
	  }
       } else {
          pSiS->HaveCustomModes = TRUE;
       }
    }

    /*
     * Add our built-in modes for TV on the 6326
     */
    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
       if(pSiS->SiS6326Flags & SIS6326_TVDETECTED) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	 	"Adding %s TV modes for 6326 to mode list:\n",
		(pSiS->SiS6326Flags & SIS6326_TVPAL) ? "PAL" : "NTSC");
          if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
             SiS6326PAL800x600Mode.next = pScrn->monitor->Modes;
             pScrn->monitor->Modes = &SiS6326PAL640x480Mode;
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	     	"\t\"PAL800x600\" \"PAL800x600U\" \"PAL720x540\" \"PAL640x480\"\n");
	  } else {
	     SiS6326NTSC640x480Mode.next = pScrn->monitor->Modes;
             pScrn->monitor->Modes = &SiS6326NTSC640x400Mode;
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	     	"\t\"NTSC640x480\" \"NTSC640x480U\" \"NTSC640x400\"\n");
	  }
       }
    }

    /*
     * Add our built-in hi-res modes on the 6326
     */
    if(pSiS->Chipset == PCI_CHIP_SIS6326) {
       if(pScrn->bitsPerPixel == 8) {
          SiS6326SIS1600x1200_60Mode.next = pScrn->monitor->Modes;
          pScrn->monitor->Modes = &SiS6326SIS1600x1200_60Mode;
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	  	"Adding mode \"SIS1600x1200-60\" (depth 8 only)\n");
       }
       if(pScrn->bitsPerPixel <= 16) {
          SiS6326SIS1280x1024_75Mode.next = pScrn->monitor->Modes;
          pScrn->monitor->Modes = &SiS6326SIS1280x1024_75Mode;
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	  	"Adding mode \"SIS1280x1024-75\" (depth 8, 15 and 16 only)\n");
       }
    }

    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,	
    	  "\"Unknown reason\" in the following list means that the mode\n");
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,	
    	  "is not supported on the chipset/bridge/current output device.\n");
    }
	
    /*
     * xf86ValidateModes will check that the mode HTotal and VTotal values
     * don't exceed the chipset's limit if pScrn->maxHValue and
     * pScrn->maxVValue are set.  Since our SISValidMode() already takes
     * care of this, we don't worry about setting them here.
     */

    /* Select valid modes from those available */
    /*
     * Assuming min pitch 256, min height 128
     */
    {
       int minpitch, maxpitch, minheight, maxheight;
       minpitch = 256;
       minheight = 128;
       switch(pSiS->VGAEngine) {
       case SIS_OLD_VGA:
       case SIS_530_VGA:
          maxpitch = 2040;
          maxheight = 2048;
          break;
       case SIS_300_VGA:
       case SIS_315_VGA:
          maxpitch = 4088;
          maxheight = 4096;
          break;
       default:
          maxpitch = 2048;
          maxheight = 2048;
          break;
       }
#ifdef SISMERGED
       pSiS->CheckForCRT2 = FALSE;
#endif
       i = xf86ValidateModes(pScrn, pScrn->monitor->Modes,
                      pScrn->display->modes, clockRanges, NULL,
                      minpitch, maxpitch,
                      pScrn->bitsPerPixel * 8,
		      minheight, maxheight,
                      pScrn->display->virtualX,
                      pScrn->display->virtualY,
                      pSiS->maxxfbmem,
                      LOOKUP_BEST_REFRESH);
    }

    if(i == -1) {
        SISErrorLog(pScrn, "xf86ValidateModes() error\n");
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
        SISFreeRec(pScrn);
        return FALSE;
    }

    /* Check the virtual screen against the available memory */
    {
       unsigned long memreq = (pScrn->virtualX * ((pScrn->bitsPerPixel + 7) / 8)) * pScrn->virtualY;

       if(memreq > pSiS->maxxfbmem) {
          SISErrorLog(pScrn,
       		"Virtual screen too big for memory; %ldK needed, %ldK available\n",
		memreq/1024, pSiS->maxxfbmem/1024);
#ifdef SISDUALHEAD
          if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
          if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
          pSiS->pInt = NULL;
          sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
          SISFreeRec(pScrn);
          return FALSE;
       }
    }

    /* Dual Head:
     * -) Go through mode list and mark all those modes as bad,
     *    which are unsuitable for dual head mode.
     * -) Find the highest used pixelclock on the master head.
     */
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {

       if(!pSiS->SecondHead) {

          pSiSEnt->maxUsedClock = 0;

          if((p = first = pScrn->modes)) {
             do {
	        n = p->next;

	        /* Modes that require the bridge to operate in SlaveMode
                 * are not suitable for Dual Head mode.
                 */
	        if( (pSiS->VGAEngine == SIS_300_VGA) &&
		    ( (strcmp(p->name, "320x200") == 0) ||
		      (strcmp(p->name, "320x240") == 0) ||
		      (strcmp(p->name, "400x300") == 0) ||
		      (strcmp(p->name, "512x384") == 0) ||
		      (strcmp(p->name, "640x400") == 0) ) )  {
	    	   p->status = MODE_BAD;
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, notsuitablestr, p->name, "dual head");
		}

		/* Search for the highest clock on first head in order to calculate
	         * max clock for second head (CRT1)
	         */
		if((p->status == MODE_OK) && (p->Clock > pSiSEnt->maxUsedClock)) {
		   pSiSEnt->maxUsedClock = p->Clock;
		}

	        p = n;

             } while (p != NULL && p != first);
	  }
       }
    }
#endif

    /* Prune the modes marked as invalid */
    xf86PruneDriverModes(pScrn);

    if(i == 0 || pScrn->modes == NULL) {
        SISErrorLog(pScrn, "No valid modes found\n");
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
        SISFreeRec(pScrn);
        return FALSE;
    }

    xf86SetCrtcForModes(pScrn, INTERLACE_HALVE_V);

    /* Set the current mode to the first in the list */
    pScrn->currentMode = pScrn->modes;

    /* Copy to CurrentLayout */
    pSiS->CurrentLayout.mode = pScrn->currentMode;
    pSiS->CurrentLayout.displayWidth = pScrn->displayWidth;

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO, modesforstr, 1);
    }
#endif

    /* Print the list of modes being used */
    xf86PrintModes(pScrn);

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       BOOLEAN acceptcustommodes = TRUE;
       BOOLEAN includelcdmodes   = TRUE;
       BOOLEAN isfordvi          = FALSE;

       xf86DrvMsg(pScrn->scrnIndex, X_INFO, crtsetupstr, 2);

       clockRanges->next = NULL;
       clockRanges->minClock = pSiS->MinClock;
       clockRanges->maxClock = SiSMemBandWidth(pSiS->CRT2pScrn, TRUE);
       clockRanges->clockIndex = -1;
       clockRanges->interlaceAllowed = FALSE;
       clockRanges->doubleScanAllowed = FALSE;
       if(pSiS->VGAEngine == SIS_315_VGA) {
          clockRanges->doubleScanAllowed = TRUE;
       }

       xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Min pixel clock for CRT2 is %d MHz\n",
                clockRanges->minClock / 1000);
       xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Max pixel clock for CRT2 is %d MHz\n",
                clockRanges->maxClock / 1000);

       if((pSiS->VBFlags & (VB_301|VB_301B|VB_301C|VB_302B)) && (!(pSiS->VBFlags & VB_30xBDH))) {
          if(!(pSiS->VBFlags & (CRT2_LCD|CRT2_VGA))) includelcdmodes   = FALSE;
	  if(pSiS->VBFlags & CRT2_LCD)               isfordvi          = TRUE;
	  if(pSiS->VBFlags & CRT2_TV)                acceptcustommodes = FALSE;
       } else {
          includelcdmodes   = FALSE;
	  acceptcustommodes = FALSE;
       }

       pSiS->HaveCustomModes2 = FALSE;
       if(!SiSMakeOwnModeList(pSiS->CRT2pScrn, acceptcustommodes, includelcdmodes, isfordvi, &pSiS->HaveCustomModes2)) {

	  SISErrorLog(pScrn, "Building list of built-in modes for CRT2 failed, %s\n",
	  			mergeddisstr);
	  SiSFreeCRT2Structs(pSiS);
	  pSiS->MergedFB = FALSE;

       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	         "Replaced %s mode list for CRT2 with built-in modes\n",
	         pSiS->HaveCustomModes2 ? "default" : "entire");
       }

    }

    if(pSiS->MergedFB) {

       pSiS->CheckForCRT2 = TRUE;
       i = xf86ValidateModes(pSiS->CRT2pScrn, pSiS->CRT2pScrn->monitor->Modes,
                      pSiS->CRT2pScrn->display->modes, clockRanges,
                      NULL, 256, 4088,
                      pSiS->CRT2pScrn->bitsPerPixel * 8, 128, 4096,
                      pScrn->display->virtualX ? pScrn->virtualX : 0,
                      pScrn->display->virtualY ? pScrn->virtualY : 0,
                      pSiS->maxxfbmem,
                      LOOKUP_BEST_REFRESH);
       pSiS->CheckForCRT2 = FALSE;

       if(i == -1) {
          SISErrorLog(pScrn, "xf86ValidateModes() error, %s.\n", mergeddisstr);
	  SiSFreeCRT2Structs(pSiS);
          pSiS->MergedFB = FALSE;
       }

    }

    if(pSiS->MergedFB) {

       if((p = first = pSiS->CRT2pScrn->modes)) {
          do {
	     n = p->next;
	     if( (pSiS->VGAEngine == SIS_300_VGA) &&
		 ( (strcmp(p->name, "320x200") == 0) ||
		   (strcmp(p->name, "320x240") == 0) ||
		   (strcmp(p->name, "400x300") == 0) ||
		   (strcmp(p->name, "512x384") == 0) ||
		   (strcmp(p->name, "640x400") == 0) ) )  {
	    	p->status = MODE_BAD;
		xf86DrvMsg(pScrn->scrnIndex, X_INFO, notsuitablestr, p->name, "MergedFB");
	     }
	     p = n;
	  } while (p != NULL && p != first);
       }

       xf86PruneDriverModes(pSiS->CRT2pScrn);

       if(i == 0 || pSiS->CRT2pScrn->modes == NULL) {
          SISErrorLog(pScrn, "No valid modes found for CRT2; %s\n", mergeddisstr);
	  SiSFreeCRT2Structs(pSiS);
	  pSiS->MergedFB = FALSE;
       }

    }

    if(pSiS->MergedFB) {

       xf86SetCrtcForModes(pSiS->CRT2pScrn, INTERLACE_HALVE_V);

       xf86DrvMsg(pScrn->scrnIndex, X_INFO, modesforstr, 2);

       xf86PrintModes(pSiS->CRT2pScrn);

       pSiS->CRT1Modes = pScrn->modes;
       pSiS->CRT1CurrentMode = pScrn->currentMode;

       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Generating MergedFB mode list\n");

       pScrn->modes = SiSGenerateModeList(pScrn, pSiS->MetaModes,
	            	                  pSiS->CRT1Modes, pSiS->CRT2pScrn->modes,
					  pSiS->CRT2Position);

       if(!pScrn->modes) {

	  SISErrorLog(pScrn, "Failed to parse MetaModes or no modes found. %s.\n",
	  		mergeddisstr);
	  SiSFreeCRT2Structs(pSiS);
	  pScrn->modes = pSiS->CRT1Modes;
	  pSiS->CRT1Modes = NULL;
	  pSiS->MergedFB = FALSE;

       }

    }

    if(pSiS->MergedFB) {

       /* If no virtual dimension was given by the user,
        * calculate a sane one now. Adapts pScrn->virtualX,
	* pScrn->virtualY and pScrn->displayWidth.
	*/
       SiSRecalcDefaultVirtualSize(pScrn);

       pScrn->modes = pScrn->modes->next;  /* We get the last from GenerateModeList(), skip to first */
       pScrn->currentMode = pScrn->modes;

       /* Update CurrentLayout */
       pSiS->CurrentLayout.mode = pScrn->currentMode;
       pSiS->CurrentLayout.displayWidth = pScrn->displayWidth;

    }
#endif

    /* Set display resolution */
#ifdef SISMERGED
    if(pSiS->MergedFB) {
       SiSMergedFBSetDpi(pScrn, pSiS->CRT2pScrn, pSiS->CRT2Position);
    } else
#endif
       xf86SetDpi(pScrn, 0, 0);

    /* Load fb module */
    switch(pScrn->bitsPerPixel) {
      case 8:
      case 16:
      case 24:
      case 32:
	if(!xf86LoadSubModule(pScrn, "fb")) {
           SISErrorLog(pScrn, "Failed to load fb module");
#ifdef SISDUALHEAD
	   if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	   if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	   sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
           SISFreeRec(pScrn);
           return FALSE;
        }
	break;
      default:
        SISErrorLog(pScrn, "Unsupported framebuffer bpp (%d)\n", pScrn->bitsPerPixel);
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
        SISFreeRec(pScrn);
        return FALSE;
    }
    xf86LoaderReqSymLists(fbSymbols, NULL);

    /* Load XAA if needed */
    if(!pSiS->NoAccel) {
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Accel enabled\n");
        if(!xf86LoadSubModule(pScrn, "xaa")) {
	    SISErrorLog(pScrn, "Could not load xaa module\n");
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	    sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
            SISFreeRec(pScrn);
            return FALSE;
        }
        xf86LoaderReqSymLists(xaaSymbols, NULL);
    }

    /* Load shadowfb if needed */
    if(pSiS->ShadowFB) {
        if(!xf86LoadSubModule(pScrn, "shadowfb")) {
	    SISErrorLog(pScrn, "Could not load shadowfb module\n");
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	    sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
	    SISFreeRec(pScrn);
            return FALSE;
        }
        xf86LoaderReqSymLists(shadowSymbols, NULL);
    }

    /* Load the dri module if requested. */
#ifdef XF86DRI
    if(pSiS->loadDRI) {
       if(xf86LoadSubModule(pScrn, "dri")) {
          xf86LoaderReqSymLists(driSymbols, drmSymbols, NULL);
       } else {
#ifdef SISDUALHEAD
          if(!pSiS->DualHeadMode)
#endif
             xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	  	 "Remove >Load \"dri\"< from the Module section of your XF86Config file\n");
       }
    }
#endif    

    /* Now load and initialize VBE module for VESA and mode restoring. */
    pSiS->UseVESA = 0;
    if(pSiS->VESA == 1) {
       if(!pSiS->pVbe) {
          if(xf86LoadSubModule(pScrn, "vbe")) {
	     xf86LoaderReqSymLists(vbeSymbols, NULL);
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	     pSiS->pVbe = VBEInit(pSiS->pInt,pSiS->pEnt->index);
#else
             pSiS->pVbe = VBEExtendedInit(pSiS->pInt,pSiS->pEnt->index,
	    			SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
#endif
          }
       }
       if(pSiS->pVbe) {
          vbe = VBEGetVBEInfo(pSiS->pVbe);
          pSiS->vesamajor = (unsigned)(vbe->VESAVersion >> 8);
          pSiS->vesaminor = vbe->VESAVersion & 0xff;
          pSiS->vbeInfo = vbe;
          if(pSiS->VESA == 1) {
             SiSBuildVesaModeList(pScrn, pSiS->pVbe, vbe);
             VBEFreeVBEInfo(vbe);
             pSiS->UseVESA = 1;
          }
       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    	"Could not load and initialize VBE module.%s\n",
		(pSiS->VESA == 1) ? " VESA disabled." : "");
       }
    }    
  
    if(pSiS->pVbe) {
       vbeFree(pSiS->pVbe);
       pSiS->pVbe = NULL;
    }

#ifdef SISDUALHEAD
    xf86SetPrimInitDone(pScrn->entityList[0]);
#endif

    sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);

    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
    pSiS->pInt = NULL;

    if(pSiS->VGAEngine == SIS_315_VGA) pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTXVGAMMA1;

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
    	pSiS->SiS_SD_Flags |= SiS_SD_ISDUALHEAD;
	if(pSiS->SecondHead)      pSiS->SiS_SD_Flags |= SiS_SD_ISDHSECONDHEAD;
	else			  pSiS->SiS_SD_Flags &= ~(SiS_SD_SUPPORTXVGAMMA1);
#ifdef PANORAMIX
	if(!noPanoramiXExtension) {
	   pSiS->SiS_SD_Flags |= SiS_SD_ISDHXINERAMA;
	   pSiS->SiS_SD_Flags &= ~(SiS_SD_SUPPORTXVGAMMA1);
	}
#endif
    }
#endif

#ifdef SISMERGED
    if(pSiS->MergedFB)      pSiS->SiS_SD_Flags |= SiS_SD_ISMERGEDFB;
#endif

    if(pSiS->enablesisctrl) pSiS->SiS_SD_Flags |= SiS_SD_ENABLED;

    return TRUE;
}


/*
 * Map the framebuffer and MMIO memory.
 */

static Bool
SISMapMem(ScrnInfoPtr pScrn)
{
    SISPtr pSiS;
    int mmioFlags;
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif
    pSiS = SISPTR(pScrn);

#ifdef SISDUALHEAD
    pSiSEnt = pSiS->entityPrivate;
#endif

    /*
     * Map IO registers to virtual address space
     */
#if !defined(__alpha__)
    mmioFlags = VIDMEM_MMIO;
#else
    /*
     * For Alpha, we need to map SPARSE memory, since we need
     * byte/short access.
     */
    mmioFlags = VIDMEM_MMIO | VIDMEM_SPARSE;
#endif

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
        pSiSEnt->MapCountIOBase++;
        if(!(pSiSEnt->IOBase)) {
	     /* Only map if not mapped previously */
    	     pSiSEnt->IOBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
                         pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));
        }
        pSiS->IOBase = pSiSEnt->IOBase;
    } else
#endif
    	pSiS->IOBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
                        pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));

    if(pSiS->IOBase == NULL) {
    	SISErrorLog(pScrn, "Could not map MMIO area\n");
        return FALSE;
    }

#ifdef __alpha__
    /*
     * for Alpha, we need to map DENSE memory as well, for
     * setting CPUToScreenColorExpandBase.
     */
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
        pSiSEnt->MapCountIOBaseDense++;
        if(!(pSiSEnt->IOBaseDense)) {
	     /* Only map if not mapped previously */
	     pSiSEnt->IOBaseDense = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_MMIO,
                    pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));
	}
	pSiS->IOBaseDense = pSiSEnt->IOBaseDense;
    } else
#endif
    	pSiS->IOBaseDense = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_MMIO,
                    pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));

    if(pSiS->IOBaseDense == NULL) {
       SISErrorLog(pScrn, "Could not map MMIO dense area\n");
       return FALSE;
    }

#endif /* __alpha__ */

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
        pSiSEnt->MapCountFbBase++;
        if(!(pSiSEnt->FbBase)) {
	     /* Only map if not mapped previously */
    	     pSiSEnt->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
                         pSiS->PciTag, (unsigned long)pSiS->realFbAddress,
                         pSiS->FbMapSize);
	     pSiS->sishw_ext.pjVideoMemoryAddress = (UCHAR *)pSiSEnt->FbBase;
        }
        pSiS->FbBase = pSiSEnt->FbBase;
     	/* Adapt FbBase (for DHM; dhmOffset is 0 otherwise) */
	pSiS->FbBase += pSiS->dhmOffset;
    } else {
#endif
    	pSiS->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
                         pSiS->PciTag, (unsigned long)pSiS->FbAddress,
                         pSiS->FbMapSize);
	pSiS->sishw_ext.pjVideoMemoryAddress = (UCHAR *)pSiS->FbBase;
#ifdef SISDUALHEAD
    }
#endif

    if(pSiS->FbBase == NULL) {
       SISErrorLog(pScrn, "Could not map framebuffer area\n");
       return FALSE;
    }

    return TRUE;
}


/*
 * Unmap the framebuffer and MMIO memory.
 */

static Bool
SISUnmapMem(ScrnInfoPtr pScrn)
{
    SISPtr pSiS;
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif

    pSiS = SISPTR(pScrn);

#ifdef SISDUALHEAD
    pSiSEnt = pSiS->entityPrivate;
#endif

/* In dual head mode, we must not unmap if the other head still
 * assumes memory as mapped
 */
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
        if(pSiSEnt->MapCountIOBase) {
	    pSiSEnt->MapCountIOBase--;
	    if((pSiSEnt->MapCountIOBase == 0) || (pSiSEnt->forceUnmapIOBase)) {
	    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiSEnt->IOBase, (pSiS->mmioSize * 1024));
	    	pSiSEnt->IOBase = NULL;
		pSiSEnt->MapCountIOBase = 0;
		pSiSEnt->forceUnmapIOBase = FALSE;
	    }
	    pSiS->IOBase = NULL;
	}
#ifdef __alpha__
	if(pSiSEnt->MapCountIOBaseDense) {
	    pSiSEnt->MapCountIOBaseDense--;
	    if((pSiSEnt->MapCountIOBaseDense == 0) || (pSiSEnt->forceUnmapIOBaseDense)) {
	    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiSEnt->IOBaseDense, (pSiS->mmioSize * 1024));
	    	pSiSEnt->IOBaseDense = NULL;
		pSiSEnt->MapCountIOBaseDense = 0;
		pSiSEnt->forceUnmapIOBaseDense = FALSE;
	    }
	    pSiS->IOBaseDense = NULL;
	}
#endif /* __alpha__ */
	if(pSiSEnt->MapCountFbBase) {
	    pSiSEnt->MapCountFbBase--;
	    if((pSiSEnt->MapCountFbBase == 0) || (pSiSEnt->forceUnmapFbBase)) {
	    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiSEnt->FbBase, pSiS->FbMapSize);
	    	pSiSEnt->FbBase = NULL;
		pSiSEnt->MapCountFbBase = 0;
		pSiSEnt->forceUnmapFbBase = FALSE;

	    }
	    pSiS->FbBase = NULL;
	}
    } else {
#endif
    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->IOBase, (pSiS->mmioSize * 1024));
    	pSiS->IOBase = NULL;
#ifdef __alpha__
    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->IOBaseDense, (pSiS->mmioSize * 1024));
    	pSiS->IOBaseDense = NULL;
#endif
    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->FbBase, pSiS->FbMapSize);
    	pSiS->FbBase = NULL;
#ifdef SISDUALHEAD
    }
#endif
    return TRUE;
}

/*
 * This function saves the video state.
 */
static void
SISSave(ScrnInfoPtr pScrn)
{
    SISPtr pSiS;
    vgaRegPtr vgaReg;
    SISRegPtr sisReg;

    pSiS = SISPTR(pScrn);

#ifdef SISDUALHEAD
    /* We always save master & slave */
    if(pSiS->DualHeadMode && pSiS->SecondHead) return;
#endif

    vgaReg = &VGAHWPTR(pScrn)->SavedReg;
    sisReg = &pSiS->SavedReg;

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (SiSBridgeIsInSlaveMode(pScrn))) {
          vgaHWSave(pScrn, vgaReg, VGA_SR_CMAP | VGA_SR_MODE);
	  SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO+0x30);
	  SiSSetLVDSetc(pSiS->SiS_Pr, &pSiS->sishw_ext, 0);
	  SiS_GetVBType(pSiS->SiS_Pr, &pSiS->sishw_ext);
	  SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
	  vgaHWSave(pScrn, vgaReg, VGA_SR_FONTS);
	  SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
       } else {
          vgaHWSave(pScrn, vgaReg, VGA_SR_ALL);
       }
    } else {
       vgaHWSave(pScrn, vgaReg, VGA_SR_ALL);
    }

    sisSaveUnlockExtRegisterLock(pSiS,&sisReg->sisRegs3C4[0x05],&sisReg->sisRegs3D4[0x80]);

    (*pSiS->SiSSave)(pScrn, sisReg);

    if(pSiS->UseVESA) SISVESASaveRestore(pScrn, MODE_SAVE);

    /* "Save" these again as they may have been changed prior to SISSave() call */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       sisReg->sisRegs3C4[0x1f] = pSiS->oldSR1F;
       sisReg->sisRegs3D4[0x17] = pSiS->oldCR17;
       if(vgaReg->numCRTC >= 0x17) vgaReg->CRTC[0x17] = pSiS->oldCR17;
       sisReg->sisRegs3D4[0x32] = pSiS->oldCR32;
       sisReg->sisRegs3D4[0x36] = pSiS->oldCR36;
       sisReg->sisRegs3D4[0x37] = pSiS->oldCR37;
       if(pSiS->VGAEngine == SIS_315_VGA) {
	  sisReg->sisRegs3D4[pSiS->myCR63] = pSiS->oldCR63;
       }
    }
}

static void
SiS_WriteAttr(SISPtr pSiS, int index, int value)
{
    (void) inb(pSiS->IODBase + VGA_IOBASE_COLOR + VGA_IN_STAT_1_OFFSET);
    index |= 0x20;
    outb(pSiS->IODBase + VGA_ATTR_INDEX, index);
    outb(pSiS->IODBase + VGA_ATTR_DATA_W, value);
}

static int
SiS_ReadAttr(SISPtr pSiS, int index)
{
    (void) inb(pSiS->IODBase + VGA_IOBASE_COLOR + VGA_IN_STAT_1_OFFSET);
    index |= 0x20;
    outb(pSiS->IODBase + VGA_ATTR_INDEX, index);
    return(inb(pSiS->IODBase + VGA_ATTR_DATA_R));
}

#define SIS_FONTS_SIZE (8 * 8192)

static void
SiS_SaveFonts(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char miscOut, attr10, gr4, gr5, gr6, seq2, seq4, scrn;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    CARD8 *vgaIOBase = (CARD8 *)VGAHWPTR(pScrn)->IOBase;
#else
    pointer vgaIOBase = VGAHWPTR(pScrn)->Base;
#endif

    if(pSiS->fonts) return;

    /* If in graphics mode, don't save anything */
    attr10 = SiS_ReadAttr(pSiS, 0x10);
    if(attr10 & 0x01) return;

    if(!(pSiS->fonts = xalloc(SIS_FONTS_SIZE * 2))) {
       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
       		"Could not save console fonts, mem allocation failed\n");
       return;
    }

    /* save the registers that are needed here */
    miscOut = inSISREG(SISMISCR);
    inSISIDXREG(SISGR, 0x04, gr4);
    inSISIDXREG(SISGR, 0x05, gr5);
    inSISIDXREG(SISGR, 0x06, gr6);
    inSISIDXREG(SISSR, 0x02, seq2);
    inSISIDXREG(SISSR, 0x04, seq4);

    /* Force into color mode */
    outSISREG(SISMISCW, miscOut | 0x01);

    inSISIDXREG(SISSR, 0x01, scrn);
    outSISIDXREG(SISSR, 0x00, 0x01);
    outSISIDXREG(SISSR, 0x01, scrn | 0x20);
    outSISIDXREG(SISSR, 0x00, 0x03);

    SiS_WriteAttr(pSiS, 0x10, 0x01);  /* graphics mode */

    /*font1 */
    outSISIDXREG(SISSR, 0x02, 0x04);  /* write to plane 2 */
    outSISIDXREG(SISSR, 0x04, 0x06);  /* enable plane graphics */
    outSISIDXREG(SISGR, 0x04, 0x02);  /* read plane 2 */
    outSISIDXREG(SISGR, 0x05, 0x00);  /* write mode 0, read mode 0 */
    outSISIDXREG(SISGR, 0x06, 0x05);  /* set graphics */
    slowbcopy_frombus(vgaIOBase, pSiS->fonts, SIS_FONTS_SIZE);

    /* font2 */
    outSISIDXREG(SISSR, 0x02, 0x08);  /* write to plane 3 */
    outSISIDXREG(SISSR, 0x04, 0x06);  /* enable plane graphics */
    outSISIDXREG(SISGR, 0x04, 0x03);  /* read plane 3 */
    outSISIDXREG(SISGR, 0x05, 0x00);  /* write mode 0, read mode 0 */
    outSISIDXREG(SISGR, 0x06, 0x05);  /* set graphics */
    slowbcopy_frombus(vgaIOBase, pSiS->fonts + SIS_FONTS_SIZE, SIS_FONTS_SIZE);

    inSISIDXREG(SISSR, 0x01, scrn);
    outSISIDXREG(SISSR, 0x00, 0x01);
    outSISIDXREG(SISSR, 0x01, scrn & ~0x20);
    outSISIDXREG(SISSR, 0x00, 0x03);

    /* Restore clobbered registers */
    SiS_WriteAttr(pSiS, 0x10, attr10);
    outSISIDXREG(SISSR, 0x02, seq2);
    outSISIDXREG(SISSR, 0x04, seq4);
    outSISIDXREG(SISGR, 0x04, gr4);
    outSISIDXREG(SISGR, 0x05, gr5);
    outSISIDXREG(SISGR, 0x06, gr6);
    outSISREG(SISMISCW, miscOut);
}

static void
SiS_RestoreFonts(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char miscOut, attr10, gr1, gr3, gr4, gr5, gr6, gr8, seq2, seq4, scrn;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    CARD8 *vgaIOBase = (CARD8 *)VGAHWPTR(pScrn)->IOBase;
#else
    pointer vgaIOBase = VGAHWPTR(pScrn)->Base;
#endif

    if(!pSiS->fonts) return;

    /* save the registers that are needed here */
    miscOut = inSISREG(SISMISCR);
    attr10 = SiS_ReadAttr(pSiS, 0x10);
    inSISIDXREG(SISGR, 0x01, gr1);
    inSISIDXREG(SISGR, 0x03, gr3);
    inSISIDXREG(SISGR, 0x04, gr4);
    inSISIDXREG(SISGR, 0x05, gr5);
    inSISIDXREG(SISGR, 0x06, gr6);
    inSISIDXREG(SISGR, 0x08, gr8);
    inSISIDXREG(SISSR, 0x02, seq2);
    inSISIDXREG(SISSR, 0x04, seq4);

    /* Force into color mode */
    outSISREG(SISMISCW, miscOut | 0x01);
    inSISIDXREG(SISSR, 0x01, scrn);
    outSISIDXREG(SISSR, 0x00, 0x01);
    outSISIDXREG(SISSR, 0x01, scrn | 0x20);
    outSISIDXREG(SISSR, 0x00, 0x03);

    SiS_WriteAttr(pSiS, 0x10, 0x01);	  /* graphics mode */
    if(pScrn->depth == 4) {
       outSISIDXREG(SISGR, 0x03, 0x00);  /* don't rotate, write unmodified */
       outSISIDXREG(SISGR, 0x08, 0xFF);  /* write all bits in a byte */
       outSISIDXREG(SISGR, 0x01, 0x00);  /* all planes come from CPU */
    }

    outSISIDXREG(SISSR, 0x02, 0x04); /* write to plane 2 */
    outSISIDXREG(SISSR, 0x04, 0x06); /* enable plane graphics */
    outSISIDXREG(SISGR, 0x04, 0x02); /* read plane 2 */
    outSISIDXREG(SISGR, 0x05, 0x00); /* write mode 0, read mode 0 */
    outSISIDXREG(SISGR, 0x06, 0x05); /* set graphics */
    slowbcopy_tobus(pSiS->fonts, vgaIOBase, SIS_FONTS_SIZE);

    outSISIDXREG(SISSR, 0x02, 0x08); /* write to plane 3 */
    outSISIDXREG(SISSR, 0x04, 0x06); /* enable plane graphics */
    outSISIDXREG(SISGR, 0x04, 0x03); /* read plane 3 */
    outSISIDXREG(SISGR, 0x05, 0x00); /* write mode 0, read mode 0 */
    outSISIDXREG(SISGR, 0x06, 0x05); /* set graphics */
    slowbcopy_tobus(pSiS->fonts + SIS_FONTS_SIZE, vgaIOBase, SIS_FONTS_SIZE);

    inSISIDXREG(SISSR, 0x01, scrn);
    outSISIDXREG(SISSR, 0x00, 0x01);
    outSISIDXREG(SISSR, 0x01, scrn & ~0x20);
    outSISIDXREG(SISSR, 0x00, 0x03);

    /* restore the registers that were changed */
    outSISREG(SISMISCW, miscOut);
    SiS_WriteAttr(pSiS, 0x10, attr10);
    outSISIDXREG(SISGR, 0x01, gr1);
    outSISIDXREG(SISGR, 0x03, gr3);
    outSISIDXREG(SISGR, 0x04, gr4);
    outSISIDXREG(SISGR, 0x05, gr5);
    outSISIDXREG(SISGR, 0x06, gr6);
    outSISIDXREG(SISGR, 0x08, gr8);
    outSISIDXREG(SISSR, 0x02, seq2);
    outSISIDXREG(SISSR, 0x04, seq4);
}

#undef SIS_FONTS_SIZE

/* VESASaveRestore taken from vesa driver */
static void
SISVESASaveRestore(ScrnInfoPtr pScrn, vbeSaveRestoreFunction function)
{
    SISPtr pSiS = SISPTR(pScrn);

    /* Query amount of memory to save state */
    if((function == MODE_QUERY) ||
       (function == MODE_SAVE && pSiS->state == NULL)) {

       /* Make sure we save at least this information in case of failure */
       (void)VBEGetVBEMode(pSiS->pVbe, &pSiS->stateMode);
       SiS_SaveFonts(pScrn);

       if(pSiS->vesamajor > 1) {
	  if(!VBESaveRestore(pSiS->pVbe, function, (pointer)&pSiS->state,
				&pSiS->stateSize, &pSiS->statePage)) {
	     return;
	  }
       }
    }

    /* Save/Restore Super VGA state */
    if(function != MODE_QUERY) {

       if(pSiS->vesamajor > 1) {
	  if(function == MODE_RESTORE) {
	     memcpy(pSiS->state, pSiS->pstate, pSiS->stateSize);
	  }

	  if(VBESaveRestore(pSiS->pVbe,function,(pointer)&pSiS->state,
			    &pSiS->stateSize,&pSiS->statePage) &&
	     (function == MODE_SAVE)) {
	     /* don't rely on the memory not being touched */
	     if(!pSiS->pstate) {
		pSiS->pstate = xalloc(pSiS->stateSize);
	     }
	     memcpy(pSiS->pstate, pSiS->state, pSiS->stateSize);
	  }
       }

       if(function == MODE_RESTORE) {
	  VBESetVBEMode(pSiS->pVbe, pSiS->stateMode, NULL);
	  SiS_RestoreFonts(pScrn);
       }

    }
}

/*
 * Initialise a new mode.  This is currently done using the
 * "initialise struct, restore/write struct to HW" model for
 * the old chipsets (5597/530/6326). For newer chipsets,
 * we use our own mode switching code (or VESA).
 */

static Bool
SISModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    vgaHWPtr hwp = VGAHWPTR(pScrn);
    vgaRegPtr vgaReg;
    SISPtr pSiS = SISPTR(pScrn);
    SISRegPtr sisReg;
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif

    andSISIDXREG(SISCR,0x11,0x7f);   	/* Unlock CRTC registers */

    SISModifyModeInfo(mode);		/* Quick check of the mode parameters */

    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
       SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO+0x30);
    }

    if(pSiS->UseVESA) {  /* With VESA: */

#ifdef SISDUALHEAD
       /* No dual head mode when using VESA */
       if(pSiS->SecondHead) return TRUE;
#endif

       pScrn->vtSema = TRUE;

       /*
	* This order is required:
	* The video bridge needs to be adjusted before the
	* BIOS is run as the BIOS sets up CRT2 according to
	* these register settings.
	* After the BIOS is run, the bridges and turboqueue
	* registers need to be readjusted as the BIOS may
	* very probably have messed them up.
	*/
       if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
	  SiSPreSetMode(pScrn, mode, SIS_MODE_SIMU);
       }
       if(!SiSSetVESAMode(pScrn, mode)) {
	  SISErrorLog(pScrn, "SiSSetVESAMode() failed\n");
	  return FALSE;
       }
       sisSaveUnlockExtRegisterLock(pSiS,NULL,NULL);
       if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
	  SiSPreSetMode(pScrn, mode, SIS_MODE_SIMU);
	  SiSPostSetMode(pScrn, &pSiS->ModeReg);
       }
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "REAL REGISTER CONTENTS AFTER SETMODE:\n");
#endif
       if(!(*pSiS->ModeInit)(pScrn, mode)) {
	  SISErrorLog(pScrn, "ModeInit() failed\n");
	  return FALSE;
       }

       vgaHWProtect(pScrn, TRUE);
       (*pSiS->SiSRestore)(pScrn, &pSiS->ModeReg);
       vgaHWProtect(pScrn, FALSE);

    } else { /* Without VESA: */

#ifdef SISDUALHEAD
       if(pSiS->DualHeadMode) {

          if(!(*pSiS->ModeInit)(pScrn, mode)) {
	     SISErrorLog(pScrn, "ModeInit() failed\n");
	     return FALSE;
	  }

	  pScrn->vtSema = TRUE;

	  pSiSEnt = pSiS->entityPrivate;

	  if(!(pSiS->SecondHead)) {
	     /* Head 1 (master) is always CRT2 */
	     SiSPreSetMode(pScrn, mode, SIS_MODE_CRT2);
	     if(!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn, mode, pSiS->IsCustom)) {
		SISErrorLog(pScrn, "SiSBIOSSetModeCRT2() failed\n");
		return FALSE;
	     }
	     SiSPostSetMode(pScrn, &pSiS->ModeReg);
	     SISAdjustFrame(pSiSEnt->pScrn_2->scrnIndex,
		            pSiSEnt->pScrn_2->frameX0,
		            pSiSEnt->pScrn_2->frameY0, 0);
	  } else {
	     /* Head 2 (slave) is always CRT1 */
	     SiSPreSetMode(pScrn, mode, SIS_MODE_CRT1);
	     if(!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn, mode, pSiS->IsCustom)) {
		SISErrorLog(pScrn, "SiSBIOSSetModeCRT1() failed\n");
		return FALSE;
	     }
	     SiSPostSetMode(pScrn, &pSiS->ModeReg);
	     SISAdjustFrame(pSiSEnt->pScrn_1->scrnIndex,
		            pSiSEnt->pScrn_1->frameX0,
		            pSiSEnt->pScrn_1->frameY0, 0);
	  }

       } else {
#endif

	  if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {

             if(!(*pSiS->ModeInit)(pScrn, mode)) {
		SISErrorLog(pScrn, "ModeInit() failed\n");
	        return FALSE;
	     }

	     pScrn->vtSema = TRUE;

#ifdef SISMERGED
	     if(pSiS->MergedFB) {

	        xf86DrvMsg(0, X_INFO, "Setting MergedFB mode %dx%d\n",
			   	mode->HDisplay, mode->VDisplay);

		SiSPreSetMode(pScrn, mode, SIS_MODE_CRT1);

		if(!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn,
		                       ((SiSMergedDisplayModePtr)mode->Private)->CRT1,
				       pSiS->IsCustom)) {
 		   SISErrorLog(pScrn, "SiSBIOSSetModeCRT1() failed\n");
	   	   return FALSE;
		}

		SiSPreSetMode(pScrn, mode, SIS_MODE_CRT2);

		if(!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn,
		                       ((SiSMergedDisplayModePtr)mode->Private)->CRT2,
				       pSiS->IsCustomCRT2)) {
	 	   SISErrorLog(pScrn, "SiSBIOSSetModeCRT2() failed\n");
		   return FALSE;
	        }

	     } else {
#endif

		if(pSiS->VBFlags & CRT1_LCDA) {
	           SiSPreSetMode(pScrn, mode, SIS_MODE_CRT1);
	           if(!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn,
		                   mode, pSiS->IsCustom)) {
		      SISErrorLog(pScrn, "SiSBIOSSetModeCRT1() failed\n");
		      return FALSE;
		   }
		   SiSPreSetMode(pScrn, mode, SIS_MODE_CRT2);
	           if(!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn,
		                   mode, pSiS->IsCustom)) {
		      SISErrorLog(pScrn, "SiSBIOSSetModeCRT2() failed\n");
		      return FALSE;
		   }
		} else {
		   SiSPreSetMode(pScrn, mode, SIS_MODE_SIMU);
	           if(!SiSBIOSSetMode(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn,
		                   mode, pSiS->IsCustom)) {
		      SISErrorLog(pScrn, "SiSBIOSSetModeCRT() failed\n");
		      return FALSE;
		   }
		}

#ifdef SISMERGED
	     }
#endif
	     SiSPostSetMode(pScrn, &pSiS->ModeReg);

#ifdef TWDEBUG
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "VBFlags %lx\n", pSiS->VBFlags);
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"REAL REGISTER CONTENTS AFTER SETMODE:\n");
             (*pSiS->ModeInit)(pScrn, mode);
#endif

	  } else {

	     /* For other chipsets, use the old method */

	     /* Initialise the ModeReg values */
    	     if(!vgaHWInit(pScrn, mode)) {
	        SISErrorLog(pScrn, "vgaHWInit() failed\n");
	        return FALSE;
	     }

	     /* Reset our PIOOffset as vgaHWInit might have reset it */
      	     VGAHWPTR(pScrn)->PIOOffset = pSiS->IODBase + (pSiS->PciInfo->ioBase[2] & 0xFFFC) - 0x380;

	     /* Prepare the register contents */
	     if(!(*pSiS->ModeInit)(pScrn, mode)) {
	        SISErrorLog(pScrn, "ModeInit() failed\n");
	        return FALSE;
	     }

	     pScrn->vtSema = TRUE;

	     /* Program the registers */
	     vgaHWProtect(pScrn, TRUE);
	     vgaReg = &hwp->ModeReg;
	     sisReg = &pSiS->ModeReg;

	     vgaReg->Attribute[0x10] = 0x01;
    	     if(pScrn->bitsPerPixel > 8) {
	    	vgaReg->Graphics[0x05] = 0x00;
	     }

    	     vgaHWRestore(pScrn, vgaReg, VGA_SR_MODE);

	     (*pSiS->SiSRestore)(pScrn, sisReg);

	     if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
	        SiS6326PostSetMode(pScrn, &pSiS->ModeReg);
	     }

#ifdef TWDEBUG
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"REAL REGISTER CONTENTS AFTER SETMODE:\n");
             (*pSiS->ModeInit)(pScrn, mode);
#endif

  	     vgaHWProtect(pScrn, FALSE);
	  }
#ifdef SISDUALHEAD
       }
#endif
    }

    /* Update Currentlayout */
    pSiS->CurrentLayout.mode = mode;

    return TRUE;
}

static Bool
SiSSetVESAMode(ScrnInfoPtr pScrn, DisplayModePtr pMode)
{
    SISPtr pSiS;
    int mode;

    pSiS = SISPTR(pScrn);

    if(!(mode = SiSCalcVESAModeIndex(pScrn, pMode))) return FALSE;

    mode |= (1 << 15);	/* Don't clear framebuffer */
    mode |= (1 << 14); 	/* Use linear adressing */

    if(VBESetVBEMode(pSiS->pVbe, mode, NULL) == FALSE) {
       SISErrorLog(pScrn, "Setting VESA mode 0x%x failed\n",
	             	mode & 0x0fff);
       return (FALSE);
    }

    if(pMode->HDisplay != pScrn->virtualX) {
       VBESetLogicalScanline(pSiS->pVbe, pScrn->virtualX);
    }

    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
    	"Setting VESA mode 0x%x succeeded\n",
	mode & 0x0fff);

    return (TRUE);
}

static void
SISSpecialRestore(ScrnInfoPtr pScrn)
{
    SISPtr    pSiS = SISPTR(pScrn);
    SISRegPtr sisReg = &pSiS->SavedReg;
    unsigned char temp;
    int i;

    /* 1.11.04 and later for 651 and 301B(DH) do strange register
     * fiddling after the usual mode change. This happens
     * depending on the result of a call of int 2f (with
     * ax=0x1680) and if modeno <= 0x13. I have no idea if
     * that is specific for the 651 or that very machine.
     * So this perhaps requires some more checks in the beginning
     * (although it should not do any harm on other chipsets/bridges
     * etc.) However, even if I call the VBE to restore mode 0x03,
     * these registers don't get restored correctly, possibly
     * because that int-2f-call for some reason results non-zero. So
     * what I do here is to restore these few registers
     * manually.
     */

    if(!(pSiS->ChipFlags & SiSCF_Is65x)) return;
    inSISIDXREG(SISCR, 0x34, temp);
    temp &= 0x7f;
    if(temp > 0x13) return;

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL,NULL);
#endif

    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);

    outSISIDXREG(SISCAP, 0x3f, sisReg->sisCapt[0x3f]);
    outSISIDXREG(SISCAP, 0x00, sisReg->sisCapt[0x00]);
    for(i = 0; i < 0x4f; i++) {
       outSISIDXREG(SISCAP, i, sisReg->sisCapt[i]);
    }
    outSISIDXREG(SISVID, 0x32, (sisReg->sisVid[0x32] & ~0x05));
    outSISIDXREG(SISVID, 0x30, sisReg->sisVid[0x30]);
    outSISIDXREG(SISVID, 0x32, ((sisReg->sisVid[0x32] & ~0x04) | 0x01));
    outSISIDXREG(SISVID, 0x30, sisReg->sisVid[0x30]);

    if(!(pSiS->ChipFlags & SiSCF_Is651)) return;
    if(!(pSiS->VBFlags & VB_SISBRIDGE)) return;

    inSISIDXREG(SISCR, 0x30, temp);
    if(temp & 0x40) {
       unsigned char myregs[] = {
       			0x2f, 0x08, 0x09, 0x03, 0x0a, 0x0c,
			0x0b, 0x0d, 0x0e, 0x12, 0x0f, 0x10,
			0x11, 0x04, 0x05, 0x06, 0x07, 0x00,
			0x2e
       };
       for(i = 0; i <= 18; i++) {
          outSISIDXREG(SISPART1, myregs[i], sisReg->VBPart1[myregs[i]]);
       }
    } else if((temp & 0x20) || (temp & 0x9c)) {
       unsigned char myregs[] = {
       			0x04, 0x05, 0x06, 0x07, 0x00, 0x2e
       };
       for(i = 0; i <= 5; i++) {
          outSISIDXREG(SISPART1, myregs[i], sisReg->VBPart1[myregs[i]]);
       }
    }
}

/*
 * Restore the initial mode. To be used internally only!
 */
static void
SISRestore(ScrnInfoPtr pScrn)
{
    SISPtr    pSiS = SISPTR(pScrn);
    SISRegPtr sisReg = &pSiS->SavedReg;
    vgaHWPtr  hwp = VGAHWPTR(pScrn);
    vgaRegPtr vgaReg = &hwp->SavedReg;
    Bool      doit = FALSE, doitlater = FALSE;
    Bool      vesasuccess = FALSE;
    
    /* WARNING: Don't ever touch this. It now seems to work on
     * all chipset/bridge combinations - but finding out the
     * correct combination was pure hell.
     */

    /* Wait for the accelerators */
    if(pSiS->AccelInfoPtr) {
       (*pSiS->AccelInfoPtr->Sync)(pScrn);
    }

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {

#ifdef SISDUALHEAD
       /* We always restore master AND slave */
       if(pSiS->DualHeadMode && pSiS->SecondHead) return;
#endif

       /* We must not disable the sequencer if the bridge is in SlaveMode! */
       if(!(SiSBridgeIsInSlaveMode(pScrn))) {
          vgaHWProtect(pScrn, TRUE);
       }

#ifdef UNLOCK_ALWAYS
       sisSaveUnlockExtRegisterLock(pSiS, NULL,NULL);
#endif

       /* First, restore CRT1 on/off and VB connection registers */
       outSISIDXREG(SISCR, 0x32, pSiS->oldCR32);
       if(!(pSiS->oldCR17 & 0x80)) {			/* CRT1 was off */
          if(!(SiSBridgeIsInSlaveMode(pScrn))) {        /* Bridge is NOT in SlaveMode now -> do it */
	     doit = TRUE;
	  } else {
	     doitlater = TRUE;
	  }
       } else {						/* CRT1 was on -> do it now */
          doit = TRUE;
       }
       
       if(doit) {
          outSISIDXREG(SISCR, 0x17, pSiS->oldCR17);
       }
       if(pSiS->VGAEngine == SIS_315_VGA) {
          outSISIDXREG(SISCR, pSiS->myCR63, pSiS->oldCR63);
       }

       outSISIDXREG(SISSR, 0x1f, pSiS->oldSR1F);

       /* For 30xB/LV, restoring the registers does not
        * work. We "manually" set the old mode, instead.
	* The same applies for SiS730 machines with LVDS.
	* Finally, this behavior can be forced by setting
	* the option RestoreBySetMode.
        */
        if( ( (pSiS->restorebyset) ||
	      (pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV)) ||
	      ((pSiS->sishw_ext.jChipType == SIS_730) && (pSiS->VBFlags & VB_LVDS)) ) &&
	    (pSiS->OldMode) ) {

	   Bool changedmode = FALSE;
	   
           xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
	         "Restoring by setting old mode 0x%02x\n", pSiS->OldMode);
		 
           if(((pSiS->OldMode <= 0x13) || (!pSiS->sisfbfound)) && (pSiS->pVbe)) {
	      int vmode = SiSTranslateToVESA(pScrn, pSiS->OldMode);
	      if(vmode > 0) {
	         if(vmode > 0x13) vmode |= ((1 << 15) | (1 << 14));
                 if(VBESetVBEMode(pSiS->pVbe, vmode, NULL) == TRUE) {
	            SISSpecialRestore(pScrn);
		    SiS_GetSetModeID(pScrn,pSiS->OldMode);
	      	    vesasuccess = TRUE;
	         } else {
	            xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
		 	"VBE failed to restore mode 0x%x\n", pSiS->OldMode);
	         }
	      } else {
	         xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
		 	"Can't identify VESA mode number for mode 0x%x\n", pSiS->OldMode);
	      }
           }

	   if(vesasuccess == FALSE) {

	      int backupscaler = pSiS->SiS_Pr->UsePanelScaler;
	      int backupcenter = pSiS->SiS_Pr->CenterScreen;
	      unsigned long backupspecialtiming = pSiS->SiS_Pr->SiS_CustomT;

 	      if((pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV))) {
	        /* !!! REQUIRED for 630+301B-DH, otherwise the text modes
	         *     will not be restored correctly !!!
	         * !!! Do this ONLY for LCD; VGA2 will not be restored
	         *     correctly otherwise.
	         */
	         unsigned char temp;
	         inSISIDXREG(SISCR, 0x30, temp);
	         if(temp & 0x20) {
	            if(pSiS->OldMode == 0x03) {
	      	       pSiS->OldMode = 0x13;
		       changedmode = TRUE;
	            }
	         }
	      }

	      pSiS->SiS_Pr->UseCustomMode = FALSE;
	      pSiS->SiS_Pr->CRT1UsesCustomMode = FALSE;
	      pSiS->SiS_Pr->UsePanelScaler = pSiS->sisfbscalelcd;
	      pSiS->SiS_Pr->CenterScreen = 0;
	      pSiS->SiS_Pr->SiS_CustomT = pSiS->sisfbspecialtiming;
	      SiSSetMode(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn, pSiS->OldMode, FALSE);
	      if(changedmode) {
	   	 pSiS->OldMode = 0x03;
		 outSISIDXREG(SISCR,0x34,0x03);
	      }
	      SISSpecialRestore(pScrn);
	      SiS_GetSetModeID(pScrn,pSiS->OldMode);
	      pSiS->SiS_Pr->UsePanelScaler = backupscaler;
	      pSiS->SiS_Pr->CenterScreen = backupcenter;
	      pSiS->SiS_Pr->SiS_CustomT = backupspecialtiming;

	   }

	   /* Restore CRT1 status */
	   if(pSiS->VGAEngine == SIS_315_VGA) {
              outSISIDXREG(SISCR, pSiS->myCR63, pSiS->oldCR63);
           }
           outSISIDXREG(SISSR, 0x1f, pSiS->oldSR1F);

#ifdef SISVRAMQ
	   /* Restore queue mode registers on 315/330 series */
	   /* (This became necessary due to the switch to VRAM queue) */
	   if(pSiS->VGAEngine == SIS_315_VGA) {
	      unsigned char tempCR55=0;
	      if(pSiS->sishw_ext.jChipType <= SIS_330) {
	         inSISIDXREG(SISCR,0x55,tempCR55);
	         andSISIDXREG(SISCR,0x55,0x33);
	      }
	      outSISIDXREG(SISSR,0x26,0x01);
	      MMIO_OUT32(pSiS->IOBase, 0x85c4, 0);
	      outSISIDXREG(SISSR,0x27,sisReg->sisRegs3C4[0x27]);
	      outSISIDXREG(SISSR,0x26,sisReg->sisRegs3C4[0x26]);
	      MMIO_OUT32(pSiS->IOBase, 0x85C0, sisReg->sisMMIO85C0);
	      if(pSiS->sishw_ext.jChipType <= SIS_330) {
	         outSISIDXREG(SISCR,0x55,tempCR55);
	      }
	   }
#endif

        } else {

	   if(pSiS->VBFlags & VB_VIDEOBRIDGE) {
	      /* If a video bridge is present, we need to restore
	       * non-extended (=standard VGA) SR and CR registers
	       * before restoring the extended ones and the bridge
	       * registers itself.
	       */
	      if(!(SiSBridgeIsInSlaveMode(pScrn))) {
                 vgaHWProtect(pScrn, TRUE);
		 
		 if(pSiS->Primary) {
	            vgaHWRestore(pScrn, vgaReg, VGA_SR_MODE);
	         }
              } 
	   }
	   
           (*pSiS->SiSRestore)(pScrn, sisReg);

        }

	if(doitlater) {
            outSISIDXREG(SISCR, 0x17, pSiS->oldCR17);
	}

	if(pSiS->Primary) {
	   if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (SiSBridgeIsInSlaveMode(pScrn))) {
	      /* IMPORTANT: The 30xLV does not handle well being disabled if in
	       * LCDA mode! In LCDA mode, the bridge is NOT in slave mode,
	       * so this is the only safe way: Disable the bridge ONLY if
	       * in Slave Mode, and don't bother if not.
	       */
              SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO+0x30);
	      SiSSetLVDSetc(pSiS->SiS_Pr, &pSiS->sishw_ext, 0);
	      SiS_GetVBType(pSiS->SiS_Pr, &pSiS->sishw_ext);
	      SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);

	      vgaHWProtect(pScrn, TRUE);

	      /* We now restore ALL to overcome the vga=extended problem */
	      vgaHWRestore(pScrn, vgaReg, VGA_SR_ALL);

	      vgaHWProtect(pScrn, FALSE);

	      SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
	      andSISIDXREG(SISSR, 0x01, ~0x20);  /* Display on */
	   } else {
	      vgaHWProtect(pScrn, TRUE);

	      /* We now restore ALL to overcome the vga=extended problem */
	      vgaHWRestore(pScrn, vgaReg, VGA_SR_ALL);

	      vgaHWProtect(pScrn, FALSE);
	   }
	}

#ifdef TWDEBUG
	{
	  SISRegPtr pReg = &pSiS->ModeReg;
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"REAL REGISTER CONTENTS AFTER RESTORE BY SETMODE:\n");
	  (*pSiS->SiSSave)(pScrn, pReg);
	}
#endif	
	
	sisRestoreExtRegisterLock(pSiS,sisReg->sisRegs3C4[0x05],sisReg->sisRegs3D4[0x80]);
    
    } else {	/* All other chipsets */

        vgaHWProtect(pScrn, TRUE);
	
#ifdef UNLOCK_ALWAYS
        sisSaveUnlockExtRegisterLock(pSiS, NULL,NULL);
#endif

        (*pSiS->SiSRestore)(pScrn, sisReg);

        vgaHWProtect(pScrn, TRUE);
	if(pSiS->Primary) {
           vgaHWRestore(pScrn, vgaReg, VGA_SR_ALL);
	}

	/* Restore TV. This is rather complicated, but if we don't do it,
	 * TV output will flicker terribly
	 */
        if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
	   if(sisReg->sis6326tv[0] & 0x04) {
	      unsigned char tmp;
	      int val;

              orSISIDXREG(SISSR, 0x01, 0x20);
              tmp = SiS6326GetTVReg(pScrn,0x00);
              tmp &= ~0x04;
              while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
              SiS6326SetTVReg(pScrn,0x00,tmp);
              for(val=0; val < 2; val++) {
                 while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
                 while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
              }
              SiS6326SetTVReg(pScrn, 0x00, sisReg->sis6326tv[0]);
              tmp = inSISREG(SISINPSTAT);
              outSISREG(SISAR, 0x20);
              tmp = inSISREG(SISINPSTAT);
              while(inSISREG(SISINPSTAT) & 0x01);
              while(!(inSISREG(SISINPSTAT) & 0x01));
              andSISIDXREG(SISSR, 0x01, ~0x20);
              for(val=0; val < 10; val++) {
                 while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
                 while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
              }
              andSISIDXREG(SISSR, 0x01, ~0x20);
	   }
        }

        sisRestoreExtRegisterLock(pSiS,sisReg->sisRegs3C4[5],sisReg->sisRegs3D4[0x80]);

        vgaHWProtect(pScrn, FALSE);
    }
}

static void
SISVESARestore(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);

   if(pSiS->UseVESA) {
      SISVESASaveRestore(pScrn, MODE_RESTORE);
#ifdef SISVRAMQ
      /* Restore queue mode registers on 315/330 series */
      /* (This became necessary due to the switch to VRAM queue) */
      if(pSiS->VGAEngine == SIS_315_VGA) {
         SISRegPtr sisReg = &pSiS->SavedReg;
	 unsigned char tempCR55=0;
	 if(pSiS->sishw_ext.jChipType <= SIS_330) {
	    inSISIDXREG(SISCR,0x55,tempCR55);
	    andSISIDXREG(SISCR,0x55,0x33);
	 }
	 outSISIDXREG(SISSR,0x26,0x01);
	 MMIO_OUT32(pSiS->IOBase, 0x85c4, 0);
	 outSISIDXREG(SISSR,0x27,sisReg->sisRegs3C4[0x27]);
	 outSISIDXREG(SISSR,0x26,sisReg->sisRegs3C4[0x26]);
	 MMIO_OUT32(pSiS->IOBase, 0x85C0, sisReg->sisMMIO85C0);
	 if(pSiS->sishw_ext.jChipType <= SIS_330) {
	    outSISIDXREG(SISCR,0x55,tempCR55);
	 }
      }
#endif
   }
}

/* Restore bridge config registers - to be called BEFORE VESARestore */
static void
SISBridgeRestore(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);

#ifdef SISDUALHEAD
    /* We only restore for master head */
    if(pSiS->DualHeadMode && pSiS->SecondHead) return;
#endif

    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
	SiSRestoreBridge(pScrn, &pSiS->SavedReg);
    }
}

/* Our generic BlockHandler for Xv */
static void
SISBlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
{
    ScreenPtr pScreen = screenInfo.screens[i];
    ScrnInfoPtr pScrn   = xf86Screens[i];
    SISPtr pSiS = SISPTR(pScrn);

    pScreen->BlockHandler = pSiS->BlockHandler;
    (*pScreen->BlockHandler) (i, blockData, pTimeout, pReadmask);
    pScreen->BlockHandler = SISBlockHandler;

    if(pSiS->VideoTimerCallback) {
       (*pSiS->VideoTimerCallback)(pScrn, currentTime.milliseconds);
    }

    if(pSiS->RenderCallback) {
       (*pSiS->RenderCallback)(pScrn);
    }
}

/* Mandatory
 * This gets called at the start of each server generation
 *
 * We use pScrn and not CurrentLayout here, because the
 * properties we use have not changed (displayWidth,
 * depth, bitsPerPixel)
 */
static Bool
SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
{
    ScrnInfoPtr pScrn;
    vgaHWPtr hwp;
    SISPtr pSiS;
    int ret;
    VisualPtr visual;
    unsigned long OnScreenSize;
    int height, width, displayWidth;
    unsigned char *FBStart;
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif

    pScrn = xf86Screens[pScreen->myNum];

    hwp = VGAHWPTR(pScrn);

    pSiS = SISPTR(pScrn);

#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead)) {
#endif    
       if(xf86LoadSubModule(pScrn, "vbe")) {
	  xf86LoaderReqSymLists(vbeSymbols, NULL);
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
          pSiS->pVbe = VBEInit(NULL, pSiS->pEnt->index);
#else
          pSiS->pVbe = VBEExtendedInit(NULL, pSiS->pEnt->index,
	                   SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
#endif
       } else {
          SISErrorLog(pScrn, "Failed to load VBE submodule\n");
       }
#ifdef SISDUALHEAD
    }
#endif

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       pSiSEnt = pSiS->entityPrivate;
       pSiSEnt->refCount++;
    }
#endif

    /* Map the VGA memory and get the VGA IO base */
    if(pSiS->Primary) {
       hwp->MapSize = 0x10000;  /* Standard 64k VGA window */
       if(!vgaHWMapMem(pScrn)) {
          SISErrorLog(pScrn, "Could not map VGA memory window\n");
          return FALSE;
       }
    }
    vgaHWGetIOBase(hwp);
    
    /* Patch the PIOOffset inside vgaHW to use
     * our relocated IO ports.
     */
    VGAHWPTR(pScrn)->PIOOffset = pSiS->IODBase + (pSiS->PciInfo->ioBase[2] & 0xFFFC) - 0x380;

    /* Map the SIS memory and MMIO areas */
    if(!SISMapMem(pScrn)) {
       SISErrorLog(pScrn, "SiSMapMem() failed\n");
       return FALSE;
    }

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    /* Enable TurboQueue so that SISSave() saves it in enabled
     * state. If we don't do this, X will hang after a restart!
     * (Happens for some unknown reason only when using VESA
     * for mode switching; assumingly a BIOS issue.)
     * This is done on 300 and 315 series only.
     */
    if(pSiS->UseVESA) {
#ifdef SISVRAMQ
       if(pSiS->VGAEngine != SIS_315_VGA)
#endif
          SiSEnableTurboQueue(pScrn);

    }

    /* Save the current state */
    SISSave(pScrn);

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {

       if(!pSiS->OldMode) {

          /* Try to find out current (=old) mode number
	   * (Do this only if not sisfb has told us its mode yet)
	   */

	  /* Read 0:449 which the BIOS sets to the current mode number
	   * Unfortunately, this not reliable since the int10 emulation
	   * does not change this. So if we call the VBE later, this
	   * byte won't be touched (which is why we set this manually
	   * then).
	   */
          unsigned char myoldmode = SiS_GetSetModeID(pScrn,0xFF);
	  unsigned char cr30, cr31;

          /* Read CR34 which the BIOS sets to the current mode number for CRT2
	   * This is - of course - not reliable if the machine has no video
	   * bridge...
	   */
          inSISIDXREG(SISCR, 0x34, pSiS->OldMode);
	  inSISIDXREG(SISCR, 0x30, cr30);
	  inSISIDXREG(SISCR, 0x31, cr31);

	  /* What if CR34 is different from the BIOS byte? */
	  if(pSiS->OldMode != myoldmode) {
	     /* If no bridge output is active, trust the BIOS byte */
	     if(!cr31 && !cr30) pSiS->OldMode = myoldmode;
	     /* ..else trust CR34 */
	  }

	  /* Newer 650 BIOSes set CR34 to 0xff if the mode has been
	   * "patched", for instance for 80x50 text mode. (That mode
	   * has no number of its own, it's 0x03 like 80x25). In this
	   * case, we trust the BIOS byte (provided that any of these
	   * two is valid).
	   */
	  if(pSiS->OldMode > 0x7f) {
	     pSiS->OldMode = myoldmode;
	  }
       }
#ifdef SISDUALHEAD
       if(pSiS->DualHeadMode) {
          if(!pSiS->SecondHead) pSiSEnt->OldMode = pSiS->OldMode;
          else                  pSiS->OldMode = pSiSEnt->OldMode;
       }
#endif
    }

    /* Initialise the first mode */
    if(!SISModeInit(pScrn, pScrn->currentMode)) {
       SISErrorLog(pScrn, "SiSModeInit() failed\n");
       return FALSE;
    }

    /* Darken the screen for aesthetic reasons */
    /* Not using Dual Head variant on purpose; we darken
     * the screen for both displays, and un-darken
     * it when the second head is finished
     */
    SISSaveScreen(pScreen, SCREEN_SAVER_ON);

    /* Set the viewport */
    SISAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);

    /*
     * The next step is to setup the screen's visuals, and initialise the
     * framebuffer code.  In cases where the framebuffer's default
     * choices for things like visual layouts and bits per RGB are OK,
     * this may be as simple as calling the framebuffer's ScreenInit()
     * function.  If not, the visuals will need to be setup before calling
     * a fb ScreenInit() function and fixed up after.
     *
     * For most PC hardware at depths >= 8, the defaults that cfb uses
     * are not appropriate.  In this driver, we fixup the visuals after.
     */

    /*
     * Reset visual list.
     */
    miClearVisualTypes();

    /* Setup the visuals we support. */

    /*
     * For bpp > 8, the default visuals are not acceptable because we only
     * support TrueColor and not DirectColor.
     */
    if(!miSetVisualTypes(pScrn->depth,
    			 (pScrn->bitsPerPixel > 8) ?
			 	TrueColorMask : miGetDefaultVisualMask(pScrn->depth),
			 pScrn->rgbBits, pScrn->defaultVisual)) {
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       SISErrorLog(pScrn, "miSetVisualTypes() failed (bpp %d)\n",
	  		pScrn->bitsPerPixel);
       return FALSE;
    }

    width = pScrn->virtualX;
    height = pScrn->virtualY;
    displayWidth = pScrn->displayWidth;

    if(pSiS->Rotate) {
       height = pScrn->virtualX;
       width = pScrn->virtualY;
    }

    if(pSiS->ShadowFB) {
       pSiS->ShadowPitch = BitmapBytePad(pScrn->bitsPerPixel * width);
       pSiS->ShadowPtr = xalloc(pSiS->ShadowPitch * height);
       displayWidth = pSiS->ShadowPitch / (pScrn->bitsPerPixel >> 3);
       FBStart = pSiS->ShadowPtr;
    } else {
       pSiS->ShadowPtr = NULL;
       FBStart = pSiS->FbBase;
    }

    if(!miSetPixmapDepths()) {
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       SISErrorLog(pScrn, "miSetPixmapDepths() failed\n");
       return FALSE;
    }

    /* Point cmdQueuePtr to pSiSEnt for shared usage
     * (same technique is then eventually used in DRIScreeninit)
     * For 315/330 series, this is done in EnableTurboQueue
     * which has already been called during ModeInit().
     */
#ifdef SISDUALHEAD
    if(pSiS->SecondHead)
       pSiS->cmdQueueLenPtr = &(SISPTR(pSiSEnt->pScrn_1)->cmdQueueLen);
    else
#endif
       pSiS->cmdQueueLenPtr = &(pSiS->cmdQueueLen);

    pSiS->cmdQueueLen = 0; /* Force an EngineIdle() at start */

#ifdef XF86DRI
    if(pSiS->loadDRI) {
#ifdef SISDUALHEAD
       /* No DRI in dual head mode */
       if(pSiS->DualHeadMode) {
          pSiS->directRenderingEnabled = FALSE;
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"DRI not supported in Dual Head mode\n");
       } else
#endif
          /* Force the initialization of the context */
              if(pSiS->VGAEngine != SIS_315_VGA) {
          pSiS->directRenderingEnabled = SISDRIScreenInit(pScreen);
       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_NOT_IMPLEMENTED,
	        "DRI not supported on this chipset\n");
          pSiS->directRenderingEnabled = FALSE;
       }
    }
#endif

    /*
     * Call the framebuffer layer's ScreenInit function, and fill in other
     * pScreen fields.
     */
    switch(pScrn->bitsPerPixel) {
      case 24:
        if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	   ret = FALSE;
	   break;
        }
      case 8:
      case 16:
      case 32:
        ret = fbScreenInit(pScreen, FBStart, width,
                        height, pScrn->xDpi, pScrn->yDpi,
                        displayWidth, pScrn->bitsPerPixel);
        break;
      default:
        ret = FALSE;
        break;
    }
    if(!ret) {
       SISErrorLog(pScrn, "Unsupported bpp (%d) or fbScreenInit() failed\n",
               pScrn->bitsPerPixel);
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       return FALSE;
    }

    if(pScrn->bitsPerPixel > 8) {
       /* Fixup RGB ordering */
       visual = pScreen->visuals + pScreen->numVisuals;
       while (--visual >= pScreen->visuals) {
          if((visual->class | DynamicClass) == DirectColor) {
             visual->offsetRed = pScrn->offset.red;
             visual->offsetGreen = pScrn->offset.green;
             visual->offsetBlue = pScrn->offset.blue;
             visual->redMask = pScrn->mask.red;
             visual->greenMask = pScrn->mask.green;
             visual->blueMask = pScrn->mask.blue;
          }
       }
    }

    /* Initialize RENDER ext; must be after RGB ordering fixed */
    fbPictureInit(pScreen, 0, 0);

    /* hardware cursor needs to wrap this layer    <-- TW: what does that mean? */
    if(!pSiS->ShadowFB) SISDGAInit(pScreen);

    xf86SetBlackWhitePixels(pScreen);

    if(!pSiS->NoAccel) {
       switch(pSiS->VGAEngine) {
	  case SIS_530_VGA:
	  case SIS_300_VGA:
            SiS300AccelInit(pScreen);
	    break;
	  case SIS_315_VGA:
	    SiS315AccelInit(pScreen);
	    break;
          default:
            SiSAccelInit(pScreen);
       }
    }
    miInitializeBackingStore(pScreen);
    xf86SetBackingStore(pScreen);
    xf86SetSilkenMouse(pScreen);

    /* Initialise cursor functions */
    miDCInitialize(pScreen, xf86GetPointerScreenFuncs());

    if(pSiS->HWCursor) {
       SiSHWCursorInit(pScreen);
    }

    /* Initialise default colourmap */
    if(!miCreateDefColormap(pScreen)) {
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       SISErrorLog(pScrn, "miCreateDefColormap() failed\n");
       return FALSE;
    }

    if(!xf86HandleColormaps(pScreen, 256, (pScrn->depth == 8) ? 8 : pScrn->rgbBits,
                    SISLoadPalette, NULL,
                    CMAP_PALETTED_TRUECOLOR | CMAP_RELOAD_ON_MODE_SWITCH)) {
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       SISErrorLog(pScrn, "xf86HandleColormaps() failed\n");
       return FALSE;
    }

#if 0
    if((pSiS->GammaBriR != 1000) || (pSiS->GammaBriG != 1000) ||
       (pSiS->GammaBriB != 1000) || (pSiS->GammaPBriR != 1000) ||
       (pSiS->GammaPBriG != 1000) || (pSiS->GammaPBriB != 1000)) {
       SISCalculateGammaRamp(pScrn);
    }
#endif

    if(pSiS->ShadowFB) {
       RefreshAreaFuncPtr refreshArea = SISRefreshArea;

       if(pSiS->Rotate) {
          if(!pSiS->PointerMoved) {
             pSiS->PointerMoved = pScrn->PointerMoved;
             pScrn->PointerMoved = SISPointerMoved;
          }

          switch(pScrn->bitsPerPixel) {
             case 8:  refreshArea = SISRefreshArea8;  break;
             case 16: refreshArea = SISRefreshArea16; break;
             case 24: refreshArea = SISRefreshArea24; break;
             case 32: refreshArea = SISRefreshArea32; break;
          }
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,0,0,0)
	  xf86DisableRandR();
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	  	"Driver rotation enabled, RandR disabled\n");
#endif
       }

       ShadowFBInit(pScreen, refreshArea);
    }

    xf86DPMSInit(pScreen, (DPMSSetProcPtr)SISDisplayPowerManagementSet, 0);

    /* Init memPhysBase and fbOffset in pScrn */
    pScrn->memPhysBase = pSiS->FbAddress;
    pScrn->fbOffset = 0;
    
    pSiS->ResetXv = pSiS->ResetXvGamma = NULL;

#if (XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,99,0,0)) || (defined(XvExtension))
    if(!pSiS->NoXvideo) {
        if( (pSiS->VGAEngine == SIS_300_VGA) ||
	    (pSiS->VGAEngine == SIS_315_VGA) ) {
#ifdef SISDUALHEAD
              if(pSiS->DualHeadMode) {
		 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		     "Using SiS300/315 series HW Xv on CRT%d\n",
		     (pSiS->SecondHead ? 1 : 2));
		 if(!pSiS->hasTwoOverlays) {
		    if( (pSiS->XvOnCRT2 && pSiS->SecondHead) ||
		        (!pSiS->XvOnCRT2 && !pSiS->SecondHead) ) {
		       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		           "However, overlay will by default only be visible on CRT%d\n",
		           pSiS->XvOnCRT2 ? 2 : 1);
		    }
		 }
                 SISInitVideo(pScreen);
 	      } else {
#endif
	        if(pSiS->hasTwoOverlays)
                   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Using SiS300/315/330 series HW Xv\n" );
                else
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Using SiS300/315/330 series HW Xv by default on CRT%d\n",
		       (pSiS->XvOnCRT2 ? 2 : 1));
	        SISInitVideo(pScreen);
#ifdef SISDUALHEAD
              }
#endif
        } else if( pSiS->Chipset == PCI_CHIP_SIS6326 ||
	           pSiS->Chipset == PCI_CHIP_SIS530  ||
		   pSiS->Chipset == PCI_CHIP_SIS5597 ) {

		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		        "Using SiS5597/5598/6326/530/620 HW Xv\n" );
		SIS6326InitVideo(pScreen);

	} else { /* generic Xv */

            XF86VideoAdaptorPtr *ptr;
            int n;

            n = xf86XVListGenericAdaptors(pScrn, &ptr);
            if(n) {
                xf86XVScreenInit(pScreen, ptr, n);
                xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using generic Xv\n" );
            }

        }
    }
#endif

#ifdef XF86DRI
    if(pSiS->loadDRI) {
       if(pSiS->directRenderingEnabled) {
          /* Now that mi, drm and others have done their thing,
           * complete the DRI setup.
           */
          pSiS->directRenderingEnabled = SISDRIFinishScreenInit(pScreen);
       }
       if(pSiS->directRenderingEnabled) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Direct rendering enabled\n");
          /* TODO */
          /* SISSetLFBConfig(pSiS); */
       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Direct rendering disabled\n");
       }
    }
#endif

    /* Wrap some funcs and setup remaining SD flags */

    pSiS->SiS_SD_Flags &= ~(SiS_SD_PSEUDOXINERAMA);
#ifdef SISMERGED
    if(pSiS->MergedFB) {
       pSiS->PointerMoved = pScrn->PointerMoved;
       pScrn->PointerMoved = SISMergePointerMoved;
       pSiS->Rotate = FALSE;
       pSiS->ShadowFB = FALSE;
#ifdef SISXINERAMA
       if(pSiS->UseSiSXinerama) {
          SiSnoPanoramiXExtension = FALSE;
          SiSXineramaExtensionInit(pScrn);
	  if(!SiSnoPanoramiXExtension) {
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,0,0,0)
             xf86DisableRandR();
             xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	  	 "SiS Pseudo-Xinerama enabled, RandR disabled\n");
#endif
	     pSiS->SiS_SD_Flags |= SiS_SD_PSEUDOXINERAMA;
	  }
       }
#endif
    }
#endif

    pSiS->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = SISCloseScreen;
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode)
       pScreen->SaveScreen = SISSaveScreenDH;
    else
#endif
       pScreen->SaveScreen = SISSaveScreen;

    /* Install BlockHandler */
    pSiS->BlockHandler = pScreen->BlockHandler;
    pScreen->BlockHandler = SISBlockHandler;

    /* Report any unused options (only for the first generation) */
    if(serverGeneration == 1) {
       xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
    }

    /* Clear frame buffer */
    /* For CRT2, we don't do that at this point in dual head
     * mode since the mode isn't switched at this time (it will
     * be reset when setting the CRT1 mode). Hence, we just
     * save the necessary data and clear the screen when
     * going through this for CRT1.
     */
     
    OnScreenSize = pScrn->displayWidth * pScrn->currentMode->VDisplay
                               * (pScrn->bitsPerPixel >> 3);

    /* Turn on the screen now */
    /* We do this in dual head mode after second head is finished */
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       if(pSiS->SecondHead) {
          bzero(pSiS->FbBase, OnScreenSize);
	  bzero(pSiSEnt->FbBase1, pSiSEnt->OnScreenSize1);
    	  SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       } else {
          pSiSEnt->FbBase1 = pSiS->FbBase;
	  pSiSEnt->OnScreenSize1 = OnScreenSize;
       }
    } else {
#endif
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       bzero(pSiS->FbBase, OnScreenSize);
#ifdef SISDUALHEAD
    }
#endif

    pSiS->SiS_SD_Flags &= ~SiS_SD_ISDEPTH8;
    if(pSiS->CurrentLayout.bitsPerPixel == 8) {
    	pSiS->SiS_SD_Flags |= SiS_SD_ISDEPTH8;
	pSiS->SiS_SD_Flags &= ~SiS_SD_SUPPORTXVGAMMA1;
    }

    return TRUE;
}

/* Usually mandatory */
Bool
SISSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    SISPtr pSiS = SISPTR(pScrn);

    if(!pSiS->NoAccel) {
       if(pSiS->AccelInfoPtr) {
          (*pSiS->AccelInfoPtr->Sync)(pScrn);
       }
    }

    if(!(SISModeInit(xf86Screens[scrnIndex], mode))) return FALSE;

    /* Since RandR (indirectly) uses SwitchMode(), we need to
     * update our Xinerama info here, too, in case of resizing
     */
#ifdef SISMERGED
#ifdef SISXINERAMA
    if(pSiS->MergedFB) {
       SiSUpdateXineramaScreenInfo(pScrn);
    }
#endif
#endif
    return TRUE;
}

Bool
SISSwitchCRT2Type(ScrnInfoPtr pScrn, unsigned long newvbflags)
{
    SISPtr pSiS = SISPTR(pScrn);
    BOOLEAN hcm;
    DisplayModePtr mode = pScrn->currentMode;

    /* Do NOT use this to switch from CRT2_LCD to CRT1_LCDA */

    /* Only on 300 and 315/330 series */
    if(pSiS->VGAEngine != SIS_300_VGA &&
       pSiS->VGAEngine != SIS_315_VGA) return FALSE;

    /* Only if there is a video bridge */
    if(!(pSiS->VBFlags & VB_VIDEOBRIDGE)) return FALSE;

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) return FALSE;
#endif

#define SiS_NewVBMask (CRT2_ENABLE|CRT1_LCDA|TV_PAL|TV_NTSC|TV_PALM|TV_PALN|TV_NTSCJ| \
		       TV_AVIDEO|TV_SVIDEO|TV_SCART|TV_HIVISION|TV_YPBPR|TV_YPBPRALL|\
		       TV_YPBPRAR)

    newvbflags &= SiS_NewVBMask;
    newvbflags |= pSiS->VBFlags & ~SiS_NewVBMask;

    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTLCDA)) {
       newvbflags &= ~CRT1_LCDA;
    }
    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTHIVISION)) {
       newvbflags &= ~TV_HIVISION;
    }
    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPR)) {
       newvbflags &= ~TV_YPBPR;
    }

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       if(!(newvbflags & CRT2_ENABLE)) {
	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	   	"CRT2 can't be switched off in MergedFB mode\n");
	  return FALSE;
       }
       hcm = pSiS->HaveCustomModes2;
       if(mode->Private) {
	  mode = ((SiSMergedDisplayModePtr)mode->Private)->CRT2;
       }
    } else
#endif
       hcm = pSiS->HaveCustomModes;

    if((!(newvbflags & CRT2_ENABLE)) && (!newvbflags & DISPTYPE_CRT1)) {
       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
          "CRT2 can't be switched off while CRT1 is off\n");
       return FALSE;
    }

    /* CRT2_LCD overrules LCDA */
    if(newvbflags & CRT2_LCD) {
       newvbflags &= ~CRT1_LCDA;
    }

    /* Check if the current mode is suitable for desired output device (if any) */
    if(newvbflags & CRT2_ENABLE) {
       if(!SiS_CheckCalcModeIndex(pScrn, mode, newvbflags, hcm)) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	     "Current mode not suitable for desired CRT2 output device\n");
          return FALSE;
       }
    }

    /* Remember: Dualhead not supported */
    newvbflags &= ~(SINGLE_MODE | MIRROR_MODE);
    if((newvbflags & DISPTYPE_CRT1) && (newvbflags & CRT2_ENABLE)) {
       newvbflags |= MIRROR_MODE;
    } else {
       newvbflags |= SINGLE_MODE;
    }

    /* Sync the accelerators */
    if(!pSiS->NoAccel) {
       if(pSiS->AccelInfoPtr) {
          (*pSiS->AccelInfoPtr->Sync)(pScrn);
       }
    }

    pSiS->VBFlags = pSiS->VBFlags_backup = newvbflags;

    if(!(pScrn->SwitchMode(pScrn->scrnIndex, pScrn->currentMode, 0))) return FALSE;
    SISAdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
    return TRUE;
}

int
SISCheckModeIndexForCRT2Type(ScrnInfoPtr pScrn, unsigned short cond, unsigned short index, Bool quiet)
{
    SISPtr pSiS = SISPTR(pScrn);
    BOOLEAN hcm = pSiS->HaveCustomModes;
    DisplayModePtr mode = pScrn->modes, mastermode;
    int i, result = 0;
    unsigned long vbflags = pSiS->VBFlags;

    /* Not only CRT2, but also LCDA */

    /* returns 0 if mode ok,
     *         0x01 if mode not ok for CRT2 device,
     *         0x02 if mode too large for current root window
     *         or combinations thereof
     */

    /* No special treatment for NTSC-J here; conditions equal NTSC */
    if(cond) {
       vbflags &= ~(CRT2_ENABLE | CRT1_LCDA | TV_STANDARD | TV_INTERFACE);
       if((cond & SiS_CF2_TYPEMASK) == SiS_CF2_LCD) {
       	  vbflags |= CRT2_LCD;
       } else if((cond & SiS_CF2_TYPEMASK) == SiS_CF2_TV) {
          vbflags |= (CRT2_TV | TV_SVIDEO);
	  if(cond & SiS_CF2_TVPAL)  	  vbflags |= TV_PAL;
	  else if(cond & SiS_CF2_TVPALM)  vbflags |= (TV_PAL | TV_PALM);
	  else if(cond & SiS_CF2_TVPALN)  vbflags |= (TV_PAL | TV_PALN);
	  else if(cond & SiS_CF2_TVNTSC)  vbflags |= TV_NTSC;
       } else if((cond & SiS_CF2_TYPEMASK) == SiS_CF2_TVSPECIAL) {
          vbflags |= CRT2_TV;
	  if((cond & SiS_CF2_TVSPECMASK) == SiS_CF2_TVHIVISION)
	  	vbflags |= TV_HIVISION;
	  else if((cond & SiS_CF2_TVSPECMASK) == SiS_CF2_TVYPBPR525I)
	  	vbflags |= (TV_YPBPR | TV_YPBPR525I);
	  else if((cond & SiS_CF2_TVSPECMASK) == SiS_CF2_TVYPBPR525P)
	  	vbflags |= (TV_YPBPR | TV_YPBPR525P);
	  else if((cond & SiS_CF2_TVSPECMASK) == SiS_CF2_TVYPBPR750P)
	  	vbflags |= (TV_YPBPR | TV_YPBPR750P);
	  else if((cond & SiS_CF2_TVSPECMASK) == SiS_CF2_TVYPBPR1080I)
	  	vbflags |= (TV_YPBPR | TV_YPBPR1080I);
       } else if((cond & SiS_CF2_TYPEMASK) == SiS_CF2_VGA2) {
          vbflags |= CRT2_VGA;
       } else if((cond & SiS_CF2_TYPEMASK) == SiS_CF2_CRT1LCDA) {
          vbflags |= CRT1_LCDA;
       }
    }

    /* Find mode of given index */
    if(index) {
       for(i = 0; i < index; i++) {
          if(!mode) return 0x03;
          mode = mode->next;
       }
    }

    mastermode = mode;

#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead)) {
#endif

       if(vbflags & CRT2_ENABLE) {

#ifdef SISMERGED
          if(pSiS->MergedFB) {
             hcm = pSiS->HaveCustomModes2;
             if(mode->Private) {
	        mode = ((SiSMergedDisplayModePtr)mode->Private)->CRT2;
             }
          }
#endif

          /* For RandR */
          if((mode->HDisplay > pScrn->virtualX) || (mode->VDisplay > pScrn->virtualY)) {
             if(!quiet) {
                xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Desired mode too large for current screen size\n");
             }
             result |= 0x02;
          }

          /* Check if the desired mode is suitable for current CRT2 output device */
          if(!SiS_CheckCalcModeIndex(pScrn, mode, vbflags, hcm)) {
             if((!cond) && (!quiet)) {
                xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Desired mode not suitable for current CRT2 output device\n");
             }
             result |= 0x01;
          }

       }

#ifdef SISDUALHEAD
    }
#endif

    mode = mastermode;

#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (pSiS->SecondHead)) {
#endif

       if(vbflags & CRT1_LCDA) {

#ifdef SISMERGED
          if(pSiS->MergedFB) {
             hcm = pSiS->HaveCustomModes;
             if(mode->Private) {
	        mode = ((SiSMergedDisplayModePtr)mode->Private)->CRT1;
	     }
          }
#endif

 	  /* For RandR */
          if((mode->HDisplay > pScrn->virtualX) || (mode->VDisplay > pScrn->virtualY)) {
             if(!quiet) {
                xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			"Desired mode too large for current screen size\n");
             }
             result |= 0x02;
          }

          /* Check if the desired mode is suitable for current CRT1 output device */
          if(!SiS_CalcModeIndex(pScrn, mode, vbflags, hcm)) {
             if((!cond) && (!quiet)) {
                 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	  	      "Desired mode not suitable for current CRT1 output device\n");
             }
             result |= 0x01;
          }

       }

#ifdef SISDUALHEAD
    }
#endif

    return result;
}

Bool
SISSwitchCRT1Status(ScrnInfoPtr pScrn, int onoff)
{
    SISPtr pSiS = SISPTR(pScrn);
    DisplayModePtr mode = pScrn->currentMode;
    unsigned long vbflags = pSiS->VBFlags;
    int crt1off;

    /* onoff: 0=OFF, 1=ON(VGA), 2=ON(LCDA) */
    /* Switching to LCDA will disable CRT2 if previously LCD */

    /* Do NOT use this to switch from CRT1_LCDA to CRT2_LCD */

    /* Only on 300 and 315/330 series */
    if(pSiS->VGAEngine != SIS_300_VGA &&
       pSiS->VGAEngine != SIS_315_VGA) return FALSE;

    /* Off only if at least one CRT2 device is active */
    if((!onoff) && (!(vbflags & CRT2_ENABLE))) return FALSE;

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) return FALSE;
#endif

    /* Can't switch to LCDA of not supported (duh!) */
    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTLCDA)) {
       if(onoff == 2) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	   	"LCD-via-CRT1 not supported on this hardware\n");
          return FALSE;
       }
    }

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       if(!onoff) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	   	"CRT1 can't be switched off in MergedFB mode\n");
          return FALSE;
       } else if(onoff == 2) {
          if(vbflags & CRT2_LCD) {
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	   	"CRT2 type can't be LCD while CRT1 is LCD-via-CRT1\n");
             return FALSE;
	  }
       }
       if(mode->Private) {
	  mode = ((SiSMergedDisplayModePtr)mode->Private)->CRT1;
       }
    }
#endif

    vbflags &= ~(DISPTYPE_CRT1 | SINGLE_MODE | MIRROR_MODE | CRT1_LCDA);
    crt1off = 1;
    if(onoff > 0) {
       vbflags |= DISPTYPE_CRT1;
       crt1off = 0;
       if(onoff == 2) {
       	  vbflags |= CRT1_LCDA;
	  vbflags &= ~CRT2_LCD;
       }
       /* Remember: Dualhead not supported */
       if(vbflags & CRT2_ENABLE) vbflags |= MIRROR_MODE;
       else vbflags |= SINGLE_MODE;
    } else {
       vbflags |= SINGLE_MODE;
    }

    if(vbflags & CRT1_LCDA) {
       if(!SiS_CalcModeIndex(pScrn, mode, vbflags, pSiS->HaveCustomModes)) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"Current mode not suitable for LCD-via-CRT1\n");
          return FALSE;
       }
    }

    pSiS->CRT1off = crt1off;
    pSiS->VBFlags = pSiS->VBFlags_backup = vbflags;

    /* Sync the accelerators */
    if(!pSiS->NoAccel) {
       if(pSiS->AccelInfoPtr) {
          (*pSiS->AccelInfoPtr->Sync)(pScrn);
       }
    }

    if(!(pScrn->SwitchMode(pScrn->scrnIndex, pScrn->currentMode, 0))) return FALSE;
    SISAdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
    return TRUE;
}

static void
SISSetStartAddressCRT1(SISPtr pSiS, unsigned long base)
{
    unsigned char cr11backup;

    inSISIDXREG(SISCR,  0x11, cr11backup);  /* Unlock CRTC registers */
    andSISIDXREG(SISCR, 0x11, 0x7F);
    outSISIDXREG(SISCR, 0x0D, base & 0xFF);
    outSISIDXREG(SISCR, 0x0C, (base >> 8) & 0xFF);
    outSISIDXREG(SISSR, 0x0D, (base >> 16) & 0xFF);
    if(pSiS->VGAEngine == SIS_315_VGA) {
       setSISIDXREG(SISSR, 0x37, 0xFE, (base >> 24) & 0x01);
    }
    /* Eventually lock CRTC registers */
    setSISIDXREG(SISCR, 0x11, 0x7F,(cr11backup & 0x80));
}

static void
SISSetStartAddressCRT2(SISPtr pSiS, unsigned long base)
{
    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
    outSISIDXREG(SISPART1, 0x06, GETVAR8(base));
    outSISIDXREG(SISPART1, 0x05, GETBITS(base, 15:8));
    outSISIDXREG(SISPART1, 0x04, GETBITS(base, 23:16));
    if(pSiS->VGAEngine == SIS_315_VGA) {
       setSISIDXREG(SISPART1, 0x02, 0x7F, ((base >> 24) & 0x01) << 7);
    }
    SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
}

#ifdef SISMERGED
static Bool
InRegion(int x, int y, region r)
{
    return (r.x0 <= x) && (x <= r.x1) && (r.y0 <= y) && (y <= r.y1);
}

static void
SISAdjustFrameHW_CRT1(ScrnInfoPtr pScrn, int x, int y)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned long base;

    base = y * pSiS->CurrentLayout.displayWidth + x;
    switch(pSiS->CurrentLayout.bitsPerPixel) {
       case 16:  base >>= 1; 	break;
       case 32:  		break;
       default:  base >>= 2;
    }
    SISSetStartAddressCRT1(pSiS, base);
}

static void
SISAdjustFrameHW_CRT2(ScrnInfoPtr pScrn, int x, int y)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned long base;

    base = y * pSiS->CurrentLayout.displayWidth + x;
    switch(pSiS->CurrentLayout.bitsPerPixel) {
       case 16:  base >>= 1; 	break;
       case 32:  		break;
       default:  base >>= 2;
    }
    SISSetStartAddressCRT2(pSiS, base);
}

static void
SISMergePointerMoved(int scrnIndex, int x, int y)
{
  ScrnInfoPtr   pScrn1 = xf86Screens[scrnIndex];
  SISPtr        pSiS = SISPTR(pScrn1);
  ScrnInfoPtr   pScrn2 = pSiS->CRT2pScrn;
  region 	out, in1, in2, f2, f1;
  int 		deltax, deltay;

  f1.x0 = pSiS->CRT1frameX0;
  f1.x1 = pSiS->CRT1frameX1;
  f1.y0 = pSiS->CRT1frameY0;
  f1.y1 = pSiS->CRT1frameY1;
  f2.x0 = pScrn2->frameX0;
  f2.x1 = pScrn2->frameX1;
  f2.y0 = pScrn2->frameY0;
  f2.y1 = pScrn2->frameY1;

  /* Define the outer region. Crossing this causes all frames to move */
  out.x0 = pScrn1->frameX0;
  out.x1 = pScrn1->frameX1;
  out.y0 = pScrn1->frameY0;
  out.y1 = pScrn1->frameY1;

  /*
   * Define the inner sliding window. Being outsize both frames but
   * inside the outer clipping window will slide corresponding frame
   */
  in1 = out;
  in2 = out;
  switch(((SiSMergedDisplayModePtr)pSiS->CurrentLayout.mode->Private)->CRT2Position) {
     case sisLeftOf:
        in1.x0 = f1.x0;
        in2.x1 = f2.x1;
        break;
     case sisRightOf:
        in1.x1 = f1.x1;
        in2.x0 = f2.x0;
        break;
     case sisBelow:
        in1.y1 = f1.y1;
        in2.y0 = f2.y0;
        break;
     case sisAbove:
        in1.y0 = f1.y0;
        in2.y1 = f2.y1;
        break;
     case sisClone:
        break;
  }

  deltay = 0;
  deltax = 0;

  if(InRegion(x, y, out)) {	/* inside outer region */

     if(InRegion(x, y, in1) && !InRegion(x, y, f1)) {
        REBOUND(f1.x0, f1.x1, x);
        REBOUND(f1.y0, f1.y1, y);
        deltax = 1;
     }
     if(InRegion(x, y, in2) && !InRegion(x, y, f2)) {
        REBOUND(f2.x0, f2.x1, x);
        REBOUND(f2.y0, f2.y1, y);
        deltax = 1;
     }

  } else {			/* outside outer region */

     if(out.x0 > x) {
        deltax = x - out.x0;
     }
     if(out.x1 < x) {
        deltax = x - out.x1;
     }
     if(deltax) {
        pScrn1->frameX0 += deltax;
        pScrn1->frameX1 += deltax;
	f1.x0 += deltax;
        f1.x1 += deltax;
        f2.x0 += deltax;
        f2.x1 += deltax;
     }

     if(out.y0 > y) {
        deltay = y - out.y0;
     }
     if(out.y1 < y) {
        deltay = y - out.y1;
     }
     if(deltay) {
        pScrn1->frameY0 += deltay;
        pScrn1->frameY1 += deltay;
	f1.y0 += deltay;
        f1.y1 += deltay;
        f2.y0 += deltay;
        f2.y1 += deltay;
     }

     switch(((SiSMergedDisplayModePtr)pSiS->CurrentLayout.mode->Private)->CRT2Position) {
        case sisLeftOf:
	   if(x >= f1.x0) { REBOUND(f1.y0, f1.y1, y); }
	   if(x <= f2.x1) { REBOUND(f2.y0, f2.y1, y); }
           break;
        case sisRightOf:
	   if(x <= f1.x1) { REBOUND(f1.y0, f1.y1, y); }
	   if(x >= f2.x0) { REBOUND(f2.y0, f2.y1, y); }
           break;
        case sisBelow:
	   if(y <= f1.y1) { REBOUND(f1.x0, f1.x1, x); }
	   if(y >= f2.y0) { REBOUND(f2.x0, f2.x1, x); }
           break;
        case sisAbove:
	   if(y >= f1.y0) { REBOUND(f1.x0, f1.x1, x); }
	   if(y <= f2.y1) { REBOUND(f2.x0, f2.x1, x); }
           break;
        case sisClone:
           break;
     }

  }

  if(deltax || deltay) {
     pSiS->CRT1frameX0 = f1.x0;
     pSiS->CRT1frameY0 = f1.y0;
     pScrn2->frameX0 = f2.x0;
     pScrn2->frameY0 = f2.y0;

     pSiS->CRT1frameX1 = pSiS->CRT1frameX0 + CDMPTR->CRT1->HDisplay - 1;
     pSiS->CRT1frameY1 = pSiS->CRT1frameY0 + CDMPTR->CRT1->VDisplay - 1;
     pScrn2->frameX1   = pScrn2->frameX0   + CDMPTR->CRT2->HDisplay - 1;
     pScrn2->frameY1   = pScrn2->frameY0   + CDMPTR->CRT2->VDisplay - 1;
     pScrn1->frameX1   = pScrn1->frameX0   + pSiS->CurrentLayout.mode->HDisplay  - 1;
     pScrn1->frameY1   = pScrn1->frameY0   + pSiS->CurrentLayout.mode->VDisplay  - 1;

     SISAdjustFrameHW_CRT1(pScrn1, pSiS->CRT1frameX0, pSiS->CRT1frameY0);
     SISAdjustFrameHW_CRT2(pScrn1, pScrn2->frameX0, pScrn2->frameY0);
  }
}

static void
SISAdjustFrameMerged(int scrnIndex, int x, int y, int flags)
{
    ScrnInfoPtr pScrn1 = xf86Screens[scrnIndex];
    SISPtr pSiS = SISPTR(pScrn1);
    ScrnInfoPtr pScrn2 = pSiS->CRT2pScrn;
    int VTotal = pSiS->CurrentLayout.mode->VDisplay;
    int HTotal = pSiS->CurrentLayout.mode->HDisplay;
    int VMax = VTotal;
    int HMax = HTotal;

    BOUND(x, 0, pScrn1->virtualX - HTotal);
    BOUND(y, 0, pScrn1->virtualY - VTotal);

    switch(SDMPTR(pScrn1)->CRT2Position) {
        case sisLeftOf:
            pScrn2->frameX0 = x;
            BOUND(pScrn2->frameY0,   y, y + VMax - CDMPTR->CRT2->VDisplay);
            pSiS->CRT1frameX0 = x + CDMPTR->CRT2->HDisplay;
            BOUND(pSiS->CRT1frameY0, y, y + VMax - CDMPTR->CRT1->VDisplay);
            break;
        case sisRightOf:
            pSiS->CRT1frameX0 = x;
            BOUND(pSiS->CRT1frameY0, y, y + VMax - CDMPTR->CRT1->VDisplay);
            pScrn2->frameX0 = x + CDMPTR->CRT1->HDisplay;
            BOUND(pScrn2->frameY0,   y, y + VMax - CDMPTR->CRT2->VDisplay);
            break;
        case sisAbove:
            BOUND(pScrn2->frameX0,   x, x + HMax - CDMPTR->CRT2->HDisplay);
            pScrn2->frameY0 = y;
            BOUND(pSiS->CRT1frameX0, x, x + HMax - CDMPTR->CRT1->HDisplay);
            pSiS->CRT1frameY0 = y + CDMPTR->CRT2->VDisplay;
            break;
        case sisBelow:
            BOUND(pSiS->CRT1frameX0, x, x + HMax - CDMPTR->CRT1->HDisplay);
            pSiS->CRT1frameY0 = y;
            BOUND(pScrn2->frameX0,   x, x + HMax - CDMPTR->CRT2->HDisplay);
            pScrn2->frameY0 = y + CDMPTR->CRT1->VDisplay;
            break;
        case sisClone:
            BOUND(pSiS->CRT1frameX0, x, x + HMax - CDMPTR->CRT1->HDisplay);
            BOUND(pSiS->CRT1frameY0, y, y + VMax - CDMPTR->CRT1->VDisplay);
            BOUND(pScrn2->frameX0,   x, x + HMax - CDMPTR->CRT2->HDisplay);
            BOUND(pScrn2->frameY0,   y, y + VMax - CDMPTR->CRT2->VDisplay);
            break;
    }

    BOUND(pSiS->CRT1frameX0, 0, pScrn1->virtualX - CDMPTR->CRT1->HDisplay);
    BOUND(pSiS->CRT1frameY0, 0, pScrn1->virtualY - CDMPTR->CRT1->VDisplay);
    BOUND(pScrn2->frameX0,   0, pScrn1->virtualX - CDMPTR->CRT2->HDisplay);
    BOUND(pScrn2->frameY0,   0, pScrn1->virtualY - CDMPTR->CRT2->VDisplay);
    
    pScrn1->frameX0 = x;
    pScrn1->frameY0 = y;

    pSiS->CRT1frameX1 = pSiS->CRT1frameX0 + CDMPTR->CRT1->HDisplay - 1;
    pSiS->CRT1frameY1 = pSiS->CRT1frameY0 + CDMPTR->CRT1->VDisplay - 1;
    pScrn2->frameX1   = pScrn2->frameX0   + CDMPTR->CRT2->HDisplay - 1;
    pScrn2->frameY1   = pScrn2->frameY0   + CDMPTR->CRT2->VDisplay - 1;
    pScrn1->frameX1   = pScrn1->frameX0   + pSiS->CurrentLayout.mode->HDisplay  - 1;
    pScrn1->frameY1   = pScrn1->frameY0   + pSiS->CurrentLayout.mode->VDisplay  - 1;

    SISAdjustFrameHW_CRT1(pScrn1, pSiS->CRT1frameX0, pSiS->CRT1frameY0);
    SISAdjustFrameHW_CRT2(pScrn1, pScrn2->frameX0, pScrn2->frameY0);
}
#endif

/*
 * This function is used to initialize the Start Address - the first
 * displayed location in the video memory.
 *
 * Usually mandatory
 */
void
SISAdjustFrame(int scrnIndex, int x, int y, int flags)
{
    ScrnInfoPtr   pScrn = xf86Screens[scrnIndex];
    SISPtr        pSiS = SISPTR(pScrn);
    unsigned long base;
    unsigned char temp, cr11backup;

#ifdef SISMERGED
    if(pSiS->MergedFB) {
    	SISAdjustFrameMerged(scrnIndex, x, y, flags);
	return;
    }
#endif

    if(pSiS->UseVESA) {
	VBESetDisplayStart(pSiS->pVbe, x, y, TRUE);
	return;
    }

    if(pScrn->bitsPerPixel < 8) {
       base = (y * pSiS->CurrentLayout.displayWidth + x + 3) >> 3;
    } else {
       base  = y * pSiS->CurrentLayout.displayWidth + x;

       /* calculate base bpp dep. */
       switch(pSiS->CurrentLayout.bitsPerPixel) {
          case 16:
     	     base >>= 1;
             break;
          case 24:
             base = ((base * 3)) >> 2;
             base -= base % 6;
             break;
          case 32:
             break;
          default:      /* 8bpp */
             base >>= 2;
             break;
       }
    }

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       if(!pSiS->SecondHead) {
	  /* Head 1 (master) is always CRT2 */
          SISSetStartAddressCRT2(pSiS, base);
       } else {
          /* TW: Head 2 (slave) is always CRT1 */
	  base += (pSiS->dhmOffset/4);
	  SISSetStartAddressCRT1(pSiS, base);
       }
    } else {
#endif
       switch(pSiS->VGAEngine) {
          case SIS_300_VGA:
	  case SIS_315_VGA:
	     SISSetStartAddressCRT1(pSiS, base);
             if(pSiS->VBFlags & CRT2_ENABLE) {
		SISSetStartAddressCRT2(pSiS, base);
	     }
             break;
          default:
	     /* Unlock CRTC registers */
             inSISIDXREG(SISCR,  0x11, cr11backup);
             andSISIDXREG(SISCR, 0x11, 0x7F);
	     outSISIDXREG(SISCR, 0x0D, base & 0xFF);
	     outSISIDXREG(SISCR, 0x0C, (base >> 8) & 0xFF);
	     inSISIDXREG(SISSR,  0x27, temp);
	     temp &= 0xF0;
	     temp |= (base & 0x0F0000) >> 16;
	     outSISIDXREG(SISSR, 0x27, temp);
	     /* Eventually lock CRTC registers */
	     setSISIDXREG(SISCR, 0x11, 0x7F, (cr11backup & 0x80));
       }
#ifdef SISDUALHEAD
    }
#endif

}

/*
 * This is called when VT switching back to the X server.  Its job is
 * to reinitialise the video mode.
 * Mandatory!
 */
static Bool
SISEnterVT(int scrnIndex, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    SISPtr pSiS = SISPTR(pScrn);

    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       outSISIDXREG(SISCR,0x32,pSiS->myCR32);
       outSISIDXREG(SISCR,0x36,pSiS->myCR36);
       outSISIDXREG(SISCR,0x37,pSiS->myCR37);
    }

    if(!SISModeInit(pScrn, pScrn->currentMode)) {
       SISErrorLog(pScrn, "SiSEnterVT: SISModeInit() failed\n");
       return FALSE;
    }

    SISAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);

#ifdef XF86DRI
    if(pSiS->directRenderingEnabled) {
       DRIUnlock(screenInfo.screens[scrnIndex]);
    }
#endif

#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead))
#endif
       if(pSiS->ResetXv) {
          (pSiS->ResetXv)(pScrn);
       }

    return TRUE;
}

/*
 * This is called when VT switching away from the X server.  Its job is
 * to restore the previous (text) mode.
 * Mandatory!
 */
static void
SISLeaveVT(int scrnIndex, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    vgaHWPtr hwp = VGAHWPTR(pScrn);
    SISPtr pSiS = SISPTR(pScrn);
#ifdef XF86DRI
    ScreenPtr pScreen;

    if(pSiS->directRenderingEnabled) {
       pScreen = screenInfo.screens[scrnIndex];
       DRILock(pScreen, 0);
    }
#endif

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode && pSiS->SecondHead) return;
#endif
    
    if(pSiS->CursorInfoPtr) {
#ifdef SISDUALHEAD    
       if(pSiS->DualHeadMode) {
          if(!pSiS->SecondHead) {
	     pSiS->ForceCursorOff = TRUE;
	     pSiS->CursorInfoPtr->HideCursor(pScrn);
	     SISWaitVBRetrace(pScrn);
	     pSiS->ForceCursorOff = FALSE;
	  }
       } else {
#endif
          pSiS->CursorInfoPtr->HideCursor(pScrn);
          SISWaitVBRetrace(pScrn);
#ifdef SISDUALHEAD	  
       }	
#endif       
    }

    SISBridgeRestore(pScrn);

    if(pSiS->UseVESA) {

       /* This is a q&d work-around for a BIOS bug. In case we disabled CRT2,
    	* VBESaveRestore() does not restore CRT1. So we set any mode now,
	* because VBESetVBEMode correctly restores CRT1. Afterwards, we
	* can call VBESaveRestore to restore original mode.
	*/
       if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (!(pSiS->VBFlags & DISPTYPE_DISP2)))
	  VBESetVBEMode(pSiS->pVbe, (pSiS->SISVESAModeList->n) | 0xc000, NULL);

       SISVESARestore(pScrn);

    } else {

       SISRestore(pScrn);

    }

    /* We use (otherwise unused) bit 7 to indicate that we are running
     * to keep sisfb to change the displaymode (this would result in
     * lethal display corruption upon quitting X or changing to a VT
     * until a reboot)
     */
    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
       orSISIDXREG(SISCR,0x34,0x80);
    }

    vgaHWLock(hwp);
}


/*
 * This is called at the end of each server generation.  It restores the
 * original (text) mode.  It should really also unmap the video memory too.
 * Mandatory!
 */
static Bool
SISCloseScreen(int scrnIndex, ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    vgaHWPtr hwp = VGAHWPTR(pScrn);
    SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

#ifdef XF86DRI
    if(pSiS->directRenderingEnabled) {
       SISDRICloseScreen(pScreen);
       pSiS->directRenderingEnabled = FALSE;
    }
#endif

    if(pScrn->vtSema) {

        if(pSiS->CursorInfoPtr) {
#ifdef SISDUALHEAD
           if(pSiS->DualHeadMode) {
              if(!pSiS->SecondHead) {
	         pSiS->ForceCursorOff = TRUE;
	         pSiS->CursorInfoPtr->HideCursor(pScrn);
	         SISWaitVBRetrace(pScrn);
	         pSiS->ForceCursorOff = FALSE;
	      }
           } else {
#endif
             pSiS->CursorInfoPtr->HideCursor(pScrn);
             SISWaitVBRetrace(pScrn);
#ifdef SISDUALHEAD
           }
#endif
	}

        SISBridgeRestore(pScrn);

	if(pSiS->UseVESA) {

	  /* This is a q&d work-around for a BIOS bug. In case we disabled CRT2,
    	   * VBESaveRestore() does not restore CRT1. So we set any mode now,
	   * because VBESetVBEMode correctly restores CRT1. Afterwards, we
	   * can call VBESaveRestore to restore original mode.
	   */
           if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (!(pSiS->VBFlags & DISPTYPE_DISP2)))
	      VBESetVBEMode(pSiS->pVbe, (pSiS->SISVESAModeList->n) | 0xc000, NULL);

	   SISVESARestore(pScrn);

	} else {

	   SISRestore(pScrn);

	}

        vgaHWLock(hwp);

    }

    /* We should restore the mode number in case vtsema = false as well,
     * but since we haven't register access then we can't do it. I think
     * I need to rework the save/restore stuff, like saving the video
     * status when returning to the X server and by that save me the
     * trouble if sisfb was started from a textmode VT while X was on.
     */
    
    SISUnmapMem(pScrn);
    vgaHWUnmapMem(pScrn);

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       pSiSEnt = pSiS->entityPrivate;
       pSiSEnt->refCount--;
    }
#endif

    if(pSiS->pInt) {
       xf86FreeInt10(pSiS->pInt);
       pSiS->pInt = NULL;
    }

    if(pSiS->AccelLinearScratch) {
       xf86FreeOffscreenLinear(pSiS->AccelLinearScratch);
       pSiS->AccelLinearScratch = NULL;
    }

    if(pSiS->AccelInfoPtr) {
       XAADestroyInfoRec(pSiS->AccelInfoPtr);
       pSiS->AccelInfoPtr = NULL;
    }

    if(pSiS->CursorInfoPtr) {
       xf86DestroyCursorInfoRec(pSiS->CursorInfoPtr);
       pSiS->CursorInfoPtr = NULL;
    }

    if(pSiS->ShadowPtr) {
       xfree(pSiS->ShadowPtr);
       pSiS->ShadowPtr = NULL;
    }

    if(pSiS->DGAModes) {
       xfree(pSiS->DGAModes);
       pSiS->DGAModes = NULL;
    }

    if(pSiS->adaptor) {
       xfree(pSiS->adaptor);
       pSiS->adaptor = NULL;
       pSiS->ResetXv = pSiS->ResetXvGamma = NULL;
    }

    pScrn->vtSema = FALSE;

    /* Restore Blockhandler */
    pScreen->BlockHandler = pSiS->BlockHandler;

    pScreen->CloseScreen = pSiS->CloseScreen;

    return(*pScreen->CloseScreen)(scrnIndex, pScreen);
}


/* Free up any per-generation data structures */

/* Optional */
static void
SISFreeScreen(int scrnIndex, int flags)
{
    if(xf86LoaderCheckSymbol("vgaHWFreeHWRec")) {
       vgaHWFreeHWRec(xf86Screens[scrnIndex]);
    }

    SISFreeRec(xf86Screens[scrnIndex]);
}


/* Checks if a mode is suitable for the selected chipset. */

static ModeStatus
SISValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    SISPtr pSiS = SISPTR(pScrn);

    if(pSiS->UseVESA) {
       if(SiSCalcVESAModeIndex(pScrn, mode))
	  return(MODE_OK);
       else
	  return(MODE_BAD);
    }

    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
#ifdef SISDUALHEAD
       if(pSiS->DualHeadMode) {
          if(pSiS->SecondHead) {
	     if(SiS_CalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	        return(MODE_BAD);
	  } else {
	     if(SiS_CheckCalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	        return(MODE_BAD);
	  }
       } else
#endif
#ifdef SISMERGED
       if(pSiS->MergedFB) {
	  if(!mode->Private) {
	     if(!pSiS->CheckForCRT2) {
	        if(SiS_CalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	           return(MODE_BAD);
	     } else {
	        if(SiS_CheckCalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes2) < 0x14)
	           return(MODE_BAD);
	     }
	  } else {
	     if(SiS_CalcModeIndex(pScrn, ((SiSMergedDisplayModePtr)mode->Private)->CRT1,
		                  pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	        return(MODE_BAD);

	     if(SiS_CheckCalcModeIndex(pScrn, ((SiSMergedDisplayModePtr)mode->Private)->CRT2,
		                  pSiS->VBFlags, pSiS->HaveCustomModes2) < 0x14)
	        return(MODE_BAD);
 	  }
       } else
#endif
              {

	  if(pSiS->VBFlags & CRT1_LCDA) {
	     if(SiS_CalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	        return(MODE_BAD);
	  }
	  if(SiS_CheckCalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	     return(MODE_BAD);
       }
    }

    return(MODE_OK);
}

/* Do screen blanking
 *
 * Mandatory
 */
static Bool
SISSaveScreen(ScreenPtr pScreen, int mode)
{
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];

    if((pScrn != NULL) && pScrn->vtSema) {

    	SISPtr pSiS = SISPTR(pScrn);

#ifdef UNLOCK_ALWAYS
        sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

        if(pSiS->VBFlags & (CRT2_LCD | CRT1_LCDA)) {

	   if(pSiS->VGAEngine == SIS_300_VGA) {

	      if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	         if(!xf86IsUnblank(mode)) {
	            pSiS->Blank = TRUE;
	  	    SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
	         } else {
	            pSiS->Blank = FALSE;
	            SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	         }
	      } else if(pSiS->VBFlags & (VB_LVDS | VB_30xBDH)) {
	         if(!pSiS->Blank) {
	            inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
	         }
	         if(!xf86IsUnblank(mode)) {
    		    pSiS->Blank = TRUE;
		    outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
	         } else {
    		    pSiS->Blank = FALSE;
		    outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
	         }
	      }

	   } else if(pSiS->VGAEngine == SIS_315_VGA) {

	      if(!pSiS->Blank) {
		 inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		 if(pSiS->sishw_ext.jChipType >= SIS_661) pSiS->LCDon &= 0x0f;
	      }

	      if(pSiS->VBFlags & VB_CHRONTEL) {
	         if(!xf86IsUnblank(mode)) {
		    pSiS->Blank = TRUE;
		    SiS_Chrontel701xBLOff(pSiS->SiS_Pr);
	         } else {
	            pSiS->Blank = FALSE;
	            SiS_Chrontel701xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	         }
	      } else if(pSiS->VBFlags & VB_LVDS) {
	         if(!xf86IsUnblank(mode)) {
	            pSiS->Blank = TRUE;
	 	    outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
	         } else {
	            pSiS->Blank = FALSE;
	  	    outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
	         }
	      } else if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	         if(!xf86IsUnblank(mode)) {
	            pSiS->Blank = TRUE;
	  	    SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
	         } else {
	            pSiS->Blank = FALSE;
	            SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	         }
	      }

	   }

	}

    }

    return vgaHWSaveScreen(pScreen, mode);
}

#ifdef SISDUALHEAD
/* SaveScreen for dual head mode */
static Bool
SISSaveScreenDH(ScreenPtr pScreen, int mode)
{
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    Bool checkit = FALSE;

    if((pScrn != NULL) && pScrn->vtSema) {

       SISPtr pSiS = SISPTR(pScrn);

       if((pSiS->SecondHead) && ((!(pSiS->VBFlags & CRT1_LCDA)) || (pSiS->VBFlags & VB_301C))) {

	  /* Slave head is always CRT1 */
	  if(pSiS->VBFlags & CRT1_LCDA) pSiS->Blank = xf86IsUnblank(mode) ? FALSE : TRUE;

	  return vgaHWSaveScreen(pScreen, mode);

       } else {

	  /* Master head is always CRT2 */
	  /* But we land here if CRT1 is LCDA, too */

	  /* We can only blank LCD, not other CRT2 devices */
	  if(!(pSiS->VBFlags & (CRT2_LCD|CRT1_LCDA))) return TRUE;

	  /* enable access to extended sequencer registers */
#ifdef UNLOCK_ALWAYS
          sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

 	  if(pSiS->VGAEngine == SIS_300_VGA) {

	     if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	        checkit = TRUE;
	        if(!xf86IsUnblank(mode)) {
		   SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
		} else {
		   SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
		}
	     } else if(pSiS->VBFlags & (VB_LVDS|VB_30xBDH)) {
	        if(!pSiS->BlankCRT2) {
		   inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		}
		checkit = TRUE;
		if(!xf86IsUnblank(mode)) {
		   outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
		} else {
		   outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		}
	     }

          } else if(pSiS->VGAEngine == SIS_315_VGA) {

 	     if(!pSiS->BlankCRT2) {
	 	inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		if(pSiS->sishw_ext.jChipType >= SIS_661) pSiS->LCDon &= 0x0f;
	     }

	     if(pSiS->VBFlags & VB_CHRONTEL) {
	        checkit = TRUE;
		if(!xf86IsUnblank(mode)) {
		   SiS_Chrontel701xBLOff(pSiS->SiS_Pr);
		} else {
		   SiS_Chrontel701xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
		}
	     } else if(pSiS->VBFlags & VB_LVDS) {
	        checkit = TRUE;
		if(!xf86IsUnblank(mode)) {
		   outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
		} else {
		   outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		}
	     } else if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	        checkit = TRUE;
		if(!xf86IsUnblank(mode)) {
		   SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
		} else {
		   SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
		}
	     }

	  }

	  if(checkit) {
	     if(!pSiS->SecondHead) pSiS->BlankCRT2 = xf86IsUnblank(mode) ? FALSE : TRUE;
	     else if(pSiS->VBFlags & CRT1_LCDA) pSiS->Blank = xf86IsUnblank(mode) ? FALSE : TRUE;
	  }

       }
    }
    return TRUE;
}
#endif

#ifdef DEBUG
static void
SiSDumpModeInfo(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Clock : %x\n", mode->Clock);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Display : %x\n", mode->CrtcHDisplay);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Blank Start : %x\n", mode->CrtcHBlankStart);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Sync Start : %x\n", mode->CrtcHSyncStart);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Sync End : %x\n", mode->CrtcHSyncEnd);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Blank End : %x\n", mode->CrtcHBlankEnd);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Total : %x\n", mode->CrtcHTotal);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Skew : %x\n", mode->CrtcHSkew);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz HAdjusted : %x\n", mode->CrtcHAdjusted);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Display : %x\n", mode->CrtcVDisplay);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Blank Start : %x\n", mode->CrtcVBlankStart);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Sync Start : %x\n", mode->CrtcVSyncStart);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Sync End : %x\n", mode->CrtcVSyncEnd);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Blank End : %x\n", mode->CrtcVBlankEnd);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Total : %x\n", mode->CrtcVTotal);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt VAdjusted : %x\n", mode->CrtcVAdjusted);
}
#endif

static void
SISModifyModeInfo(DisplayModePtr mode)
{
    if(mode->CrtcHBlankStart == mode->CrtcHDisplay)
        mode->CrtcHBlankStart++;
    if(mode->CrtcHBlankEnd == mode->CrtcHTotal)
        mode->CrtcHBlankEnd--;
    if(mode->CrtcVBlankStart == mode->CrtcVDisplay)
        mode->CrtcVBlankStart++;
    if(mode->CrtcVBlankEnd == mode->CrtcVTotal)
        mode->CrtcVBlankEnd--;
}

/* Enable the Turboqueue/Commandqueue (For 300 and 315/330 series only) */
void
SiSEnableTurboQueue(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned short SR26, SR27;
    unsigned long  temp;

    switch (pSiS->VGAEngine) {
	case SIS_300_VGA:
	   if((!pSiS->NoAccel) && (pSiS->TurboQueue)) {
	        /* TQ size is always 512k */
           	temp = (pScrn->videoRam/64) - 8;
           	SR26 = temp & 0xFF;
           	inSISIDXREG(SISSR, 0x27, SR27);
		SR27 &= 0xFC;
		SR27 |= (0xF0 | ((temp >> 8) & 3));
           	outSISIDXREG(SISSR, 0x26, SR26);
           	outSISIDXREG(SISSR, 0x27, SR27);
	   }
	   break;

	case SIS_315_VGA:
	   if(!pSiS->NoAccel) {
	      /* On 315/330 series, there are three queue modes available
	       * which are chosen by setting bits 7:5 in SR26:
	       * 1. MMIO queue mode (bit 5, 0x20). The hardware will keep
	       *    track of the queue, the FIFO, command parsing and so
	       *    on. This is the one comparable to the 300 series.
	       * 2. VRAM queue mode (bit 6, 0x40). In this case, one will
	       *    have to do queue management himself. 
	       * 3. AGP queue mode (bit 7, 0x80). Works as 2., but keeps the
	       *    queue in AGP memory space.
	       * We go VRAM or MMIO here.
	       * SR26 bit 4 is called "Bypass H/W queue".
	       * SR26 bit 1 is called "Enable Command Queue Auto Correction"
	       * SR26 bit 0 resets the queue
	       * Size of queue memory is encoded in bits 3:2 like this:
	       *    00  (0x00)  512K
	       *    01  (0x04)  1M
	       *    10  (0x08)  2M
	       *    11  (0x0C)  4M
	       * The queue location is to be written to 0x85C0.
	       */
#ifdef SISVRAMQ
	      /* We use VRAM Cmd Queue, not MMIO or AGP */
	      unsigned char tempCR55 = 0;

#ifdef SISDUALHEAD
	      if(pSiS->DualHeadMode) {
	         SISEntPtr pSiSEnt = pSiS->entityPrivate;
	         pSiS->cmdQ_SharedWritePort = &(pSiSEnt->cmdQ_SharedWritePort_2D);
	      } else
#endif
	         pSiS->cmdQ_SharedWritePort = &(pSiS->cmdQ_SharedWritePort_2D);

	      /* Set Command Queue Threshold to max value 11111b (?) */
	      outSISIDXREG(SISSR, 0x27, 0x1F);
	      /* No idea what this does */
	      if(pSiS->sishw_ext.jChipType <= SIS_330) {
	         inSISIDXREG(SISCR, 0x55, tempCR55) ;
    	         andSISIDXREG(SISCR, 0x55, 0x33) ;
	      }
	      /* Syncronous reset for Command Queue */
	      outSISIDXREG(SISSR, 0x26, 0x01);
	      MMIO_OUT32(pSiS->IOBase, 0x85c4, 0);
	      /* Enable VRAM Command Queue mode */
	      switch(pSiS->cmdQueueSize) {
    		case 1*1024*1024: SR26 = (0x40 | 0x04 | 0x01); break;
    		case 2*1024*1024: SR26 = (0x40 | 0x08 | 0x01); break;
    		case 4*1024*1024: SR26 = (0x40 | 0x0C | 0x01); break;
		default:
		                  pSiS->cmdQueueSize = 512 * 1024;
		case    512*1024: SR26 = (0x40 | 0x00 | 0x01);
	      }
    	      outSISIDXREG(SISSR, 0x26, SR26);
	      SR26 &= 0xfe;
	      outSISIDXREG(SISSR, 0x26, SR26);
	      pSiS->cmdQ_SharedWritePort_2D = (unsigned long)(MMIO_IN32(pSiS->IOBase, 0x85c8));
              *(pSiS->cmdQ_SharedWritePort) = pSiS->cmdQ_SharedWritePort_2D;
              MMIO_OUT32(pSiS->IOBase, 0x85c4, pSiS->cmdQ_SharedWritePort_2D);
	      MMIO_OUT32(pSiS->IOBase, 0x85C0, pSiS->cmdQueueOffset);
	      temp = (unsigned long)pSiS->FbBase;
#ifdef SISDUALHEAD
	      if(pSiS->DualHeadMode) {
	         SISEntPtr pSiSEnt = pSiS->entityPrivate;
	         temp = (unsigned long)pSiSEnt->FbBase;
	      }
#endif
              temp += pSiS->cmdQueueOffset;
              pSiS->cmdQueueBase = (unsigned long *)temp;
	      if(pSiS->sishw_ext.jChipType <= SIS_330) {
    	         outSISIDXREG(SISCR, 0x55, tempCR55);
	      }
#else
	      /* For MMIO */
	      /* Set Command Queue Threshold to max value 11111b */
	      outSISIDXREG(SISSR, 0x27, 0x1F);
	      /* Syncronous reset for Command Queue */
	      outSISIDXREG(SISSR, 0x26, 0x01);
	      /* Do some magic (cp readport to writeport) */
	      temp = MMIO_IN32(pSiS->IOBase, 0x85C8);
	      MMIO_OUT32(pSiS->IOBase, 0x85C4, temp);
	      /* Enable MMIO Command Queue mode (0x20),
	       * Enable_command_queue_auto_correction (0x02)
	       *        (no idea, but sounds good, so use it)
	       * 512k (0x00) (does this apply to MMIO mode?) */
    	      outSISIDXREG(SISSR, 0x26, 0x22);
	      /* Calc Command Queue position (Q is always 512k)*/
	      temp = (pScrn->videoRam - 512) * 1024;
	      /* Set Q position */
	      MMIO_OUT32(pSiS->IOBase, 0x85C0, temp);
#endif
	   }
	   break;
	default:
	   break;
    }
}

/* Things to do before a ModeSwitch. We set up the
 * video bridge configuration and the TurboQueue.
 */
void SiSPreSetMode(ScrnInfoPtr pScrn, DisplayModePtr mode, int viewmode)
{
    SISPtr         pSiS = SISPTR(pScrn);
    unsigned char  CR30, CR31, CR32, CR33;
    unsigned char  CR39 = 0, CR3B = 0;
    unsigned char  CR17, CR38 = 0;
    unsigned char  CR35 = 0, CR79 = 0;
    unsigned long  vbflag;
    int            temp = 0, i;
    int 	   crt1rateindex = 0;
    DisplayModePtr mymode;
#ifdef SISMERGED
    DisplayModePtr mymode2 = NULL;
#endif

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       mymode = ((SiSMergedDisplayModePtr)mode->Private)->CRT1;
       mymode2 = ((SiSMergedDisplayModePtr)mode->Private)->CRT2;
    } else
#endif
    mymode = mode;

    vbflag = pSiS->VBFlags;
    pSiS->IsCustom = FALSE;
#ifdef SISMERGED
    pSiS->IsCustomCRT2 = FALSE;

    if(pSiS->MergedFB) {
       /* CRT2 */
       if(vbflag & CRT2_LCD) {
          if(pSiS->SiS_Pr->CP_HaveCustomData) {
	     for(i=0; i<7; i++) {
	        if(pSiS->SiS_Pr->CP_DataValid[i]) {
	           if((mymode2->HDisplay == pSiS->SiS_Pr->CP_HDisplay[i]) &&
	              (mymode2->VDisplay == pSiS->SiS_Pr->CP_VDisplay[i])) {
	              if(mymode2->type & M_T_BUILTIN) {
	                 pSiS->IsCustomCRT2 = TRUE;
		      }
	           }
		}
	     }
	  }
       }
       if(vbflag & (CRT2_VGA|CRT2_LCD)) {
          if(pSiS->AddedPlasmaModes) {
	     if(mymode2->type & M_T_BUILTIN) {
	        pSiS->IsCustomCRT2 = TRUE;
	     }
	  }
	  if(pSiS->HaveCustomModes2) {
             if(!(mymode2->type & M_T_DEFAULT)) {
	        pSiS->IsCustomCRT2 = TRUE;
             }
          }
       }
       /* CRT1 */
       if(pSiS->HaveCustomModes) {
          if(!(mymode->type & M_T_DEFAULT)) {
	     pSiS->IsCustom = TRUE;
          }
       }
    } else
#endif
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       if(!pSiS->SecondHead) {
          /* CRT2 */
          if(vbflag & CRT2_LCD) {
	     if(pSiS->SiS_Pr->CP_HaveCustomData) {
	        for(i=0; i<7; i++) {
                   if(pSiS->SiS_Pr->CP_DataValid[i]) {
	              if((mymode->HDisplay == pSiS->SiS_Pr->CP_HDisplay[i]) &&
	                 (mymode->VDisplay == pSiS->SiS_Pr->CP_VDisplay[i])) {
	                 if(mymode->type & M_T_BUILTIN) {
	                    pSiS->IsCustom = TRUE;
		         }
		      }
		   }
	        }
	     }
          }
	  if(vbflag & (CRT2_VGA|CRT2_LCD)) {
             if(pSiS->AddedPlasmaModes) {
	        if(mymode->type & M_T_BUILTIN) {
	           pSiS->IsCustom = TRUE;
	        }
	     }
	     if(pSiS->HaveCustomModes) {
                if(!(mymode->type & M_T_DEFAULT)) {
	           pSiS->IsCustom = TRUE;
                }
             }
          }
       } else {
          /* CRT1 */
          if(pSiS->HaveCustomModes) {
             if(!(mymode->type & M_T_DEFAULT)) {
	        pSiS->IsCustom = TRUE;
             }
          }
       }
    } else
#endif
    {
       if(vbflag & CRT2_LCD) {
          if(pSiS->SiS_Pr->CP_HaveCustomData) {
	     for(i=0; i<7; i++) {
	        if(pSiS->SiS_Pr->CP_DataValid[i]) {
                   if((mymode->HDisplay == pSiS->SiS_Pr->CP_HDisplay[i]) &&
	              (mymode->VDisplay == pSiS->SiS_Pr->CP_VDisplay[i])) {
	              if(mymode->type & M_T_BUILTIN) {
	                 pSiS->IsCustom = TRUE;
	              }
		   }
	        }
	     }
          }
       }
       if(vbflag & (CRT2_LCD|CRT2_VGA)) {
          if(pSiS->AddedPlasmaModes) {
             if(mymode->type & M_T_BUILTIN) {
	        pSiS->IsCustom = TRUE;
             }
          }
       }
       if((pSiS->HaveCustomModes) && (!(vbflag & CRT2_TV))) {
          if(!(mymode->type & M_T_DEFAULT)) {
	     pSiS->IsCustom = TRUE;
          }
       }
    }

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);    /* Unlock Registers */
#endif

    inSISIDXREG(SISCR, 0x30, CR30);
    inSISIDXREG(SISCR, 0x31, CR31);
    CR32 = pSiS->newCR32;
    inSISIDXREG(SISCR, 0x33, CR33);

    if(pSiS->Chipset == PCI_CHIP_SIS660) {

       inSISIDXREG(SISCR, 0x35, CR35);
       inSISIDXREG(SISCR, 0x38, CR38);
       inSISIDXREG(SISCR, 0x39, CR39);

       xf86DrvMsgVerb(pScrn->scrnIndex, X_PROBED, 4,
	   "Before: CR30=0x%02x,CR31=0x%02x,CR32=0x%02x,CR33=0x%02x,CR35=0x%02x,CR38=0x%02x\n",
              CR30, CR31, CR32, CR33, CR35, CR38);
       CR38 &= ~0x07;

    } else {

       if(pSiS->Chipset != PCI_CHIP_SIS300) {
          switch(pSiS->VGAEngine) {
             case SIS_300_VGA: temp = 0x35; break;
             case SIS_315_VGA: temp = 0x38; break;
          }
          if(temp) inSISIDXREG(SISCR, temp, CR38);
       }
       if(pSiS->VGAEngine == SIS_315_VGA) {
          inSISIDXREG(SISCR, 0x79, CR79);
          CR38 &= ~0x3b;   			/* Clear LCDA/DualEdge and YPbPr bits */
       }
       inSISIDXREG(SISCR, 0x3b, CR3B);
       xf86DrvMsgVerb(pScrn->scrnIndex, X_PROBED, 4,
	   "Before: CR30=0x%02x, CR31=0x%02x, CR32=0x%02x, CR33=0x%02x, CR%02x=0x%02x\n",
              CR30, CR31, CR32, CR33, temp, CR38);
    }

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4, "VBFlags=0x%lx\n", pSiS->VBFlags);

    CR30 = 0x00;
    CR31 &= ~0x60;  /* Clear VB_Drivermode & VB_OutputDisable */
    CR31 |= 0x04;   /* Set VB_NotSimuMode (not for 30xB/1400x1050?) */
    CR35 = 0x00;

    if(pSiS->Chipset != PCI_CHIP_SIS660) {
       if(!pSiS->AllowHotkey) {
          CR31 |= 0x80;   /* Disable hotkey-switch */
       }
       CR79 &= ~0x10;     /* Enable Backlight control on 315 series */
    }

    SiS_SetEnableDstn(pSiS->SiS_Pr, FALSE);
    SiS_SetEnableFstn(pSiS->SiS_Pr, FALSE);

    if((vbflag & CRT1_LCDA) && (viewmode == SIS_MODE_CRT1)) {

       CR38 |= 0x02;

    } else {

       switch(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {

       case CRT2_TV:

          CR38 &= ~0xC0; 	/* Clear Pal M/N bits */

          if((vbflag & VB_CHRONTEL) && (vbflag & TV_CHSCART)) {			/* Chrontel */
	     CR30 |= 0x10;
	     CR38 |= 0x04;
	     CR38 &= ~0x08;
	     CR31 |= 0x01;
	  } else if((vbflag & VB_CHRONTEL) && (vbflag & TV_CHYPBPR525I)) {	/* Chrontel */
	     CR38 |= 0x08;
	     CR38 &= ~0x04;
	     CR31 &= ~0x01;
          } else if(vbflag & TV_HIVISION) {	/* SiS bridge */
	     if(pSiS->Chipset == PCI_CHIP_SIS660) {
	        CR38 |= 0x04;
	        CR35 |= 0x60;
	     } else {
	        CR30 |= 0x80;
		if(pSiS->VGAEngine == SIS_315_VGA) {
		   if(vbflag & (VB_301LV | VB_302LV | VB_301C)) {
		      CR38 |= (0x08 | 0x30);
		   }
		}
	     }
	     CR31 |= 0x01;
	     CR35 |= 0x01;
	  } else if(vbflag & TV_YPBPR) {					/* SiS bridge */
	     if(pSiS->Chipset == PCI_CHIP_SIS660) {
	        CR38 |= 0x04;
	        if(vbflag & TV_YPBPR525P)       CR35 |= 0x20;
		else if(vbflag & TV_YPBPR750P)  CR35 |= 0x40;
		else if(vbflag & TV_YPBPR1080I) CR35 |= 0x60;
		CR31 &= ~0x01;
		CR35 &= ~0x01;
		CR39 &= ~0x03;
		if((vbflag & TV_YPBPRAR) == TV_YPBPR43LB)     CR39 |= 0x00;
		else if((vbflag & TV_YPBPRAR) == TV_YPBPR43)  CR39 |= 0x01;
		else if((vbflag & TV_YPBPRAR) == TV_YPBPR169) CR39 |= 0x02;
		else					      CR39 |= 0x03;
	     } else if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPR) {
	        CR30 |= 0x80;
		CR38 |= 0x08;
	        if(vbflag & TV_YPBPR525P)       CR38 |= 0x10;
		else if(vbflag & TV_YPBPR750P)  CR38 |= 0x20;
		else if(vbflag & TV_YPBPR1080I) CR38 |= 0x30;
		CR31 &= ~0x01;
		if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPRAR) {
		   CR3B &= ~0x03;
		   if((vbflag & TV_YPBPRAR) == TV_YPBPR43LB)     CR3B |= 0x00;
		   else if((vbflag & TV_YPBPRAR) == TV_YPBPR43)  CR3B |= 0x03;
		   else if((vbflag & TV_YPBPRAR) == TV_YPBPR169) CR3B |= 0x01;
		   else					         CR3B |= 0x03;
		}
	     }
          } else {								/* All */
	     if(vbflag & TV_SCART)  CR30 |= 0x10;
	     if(vbflag & TV_SVIDEO) CR30 |= 0x08;
	     if(vbflag & TV_AVIDEO) CR30 |= 0x04;
	     if(!(CR30 & 0x1C))	    CR30 |= 0x08;    /* default: SVIDEO */

	     if(vbflag & TV_PAL) {
		CR31 |= 0x01;
		CR35 |= 0x01;
		if( (vbflag & VB_SISBRIDGE) ||
		    ((vbflag & VB_CHRONTEL) && (pSiS->ChrontelType == CHRONTEL_701x)) )  {
		   if(vbflag & TV_PALM) {
		      CR38 |= 0x40;
		      CR35 |= 0x04;
		   } else if(vbflag & TV_PALN) {
		      CR38 |= 0x80;
		      CR35 |= 0x08;
	  	   }
	        }
	     } else {
		CR31 &= ~0x01;
		CR35 &= ~0x01;
		if(vbflag & TV_NTSCJ) {
		   CR38 |= 0x40;  /* TW, not BIOS */
		   CR35 |= 0x02;
	 	}
	     }
	     if(vbflag & TV_SCART) {
	        CR31 |= 0x01;
		CR35 |= 0x01;
	     }
	  }

	  CR31 &= ~0x04;   /* Clear NotSimuMode */
	  pSiS->SiS_Pr->SiS_CHOverScan = pSiS->UseCHOverScan;
	  if((pSiS->OptTVSOver == 1) && (pSiS->ChrontelType == CHRONTEL_700x)) {
	     pSiS->SiS_Pr->SiS_CHSOverScan = TRUE;
	  } else {
	     pSiS->SiS_Pr->SiS_CHSOverScan = FALSE;
	  }
#ifdef SIS_CP
	  SIS_CP_DRIVER_CONFIG
#endif
          break;

       case CRT2_LCD:
          CR30 |= 0x20;
	  SiS_SetEnableDstn(pSiS->SiS_Pr, pSiS->DSTN);
	  SiS_SetEnableFstn(pSiS->SiS_Pr, pSiS->FSTN);
          break;

       case CRT2_VGA:
          CR30 |= 0x40;
          break;

       default:
          CR30 |= 0x00;
          CR31 |= 0x20;    /* VB_OUTPUT_DISABLE */
	  if(pSiS->UseVESA) {
	     crt1rateindex = SISSearchCRT1Rate(pScrn, mymode);
	  }
       }

    }

    if(vbflag & CRT1_LCDA) {
       switch(viewmode) {
       case SIS_MODE_CRT1:
          CR38 |= 0x01;
          break;
       case SIS_MODE_CRT2:
          if(vbflag & (CRT2_TV|CRT2_VGA)) {
             CR30 |= 0x02;
	     CR38 |= 0x01;
	  } else {
	     CR38 |= 0x03;
	  }
          break;
       case SIS_MODE_SIMU:
       default:
          if(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {
             CR30 |= 0x01;
	  }
          break;
       }
    } else {
       if(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {
          CR30 |= 0x01;
       }
    }

    /* for VESA: no DRIVERMODE, otherwise
     * -) CRT2 will not be initialized correctly when using mode
     *    where LCD has to scale, and
     * -) CRT1 will have too low rate
     */
     if(pSiS->UseVESA) {
        CR31 &= ~0x40;   /* Clear Drivermode */
	CR31 |= 0x06;    /* Set SlaveMode, Enable SimuMode in Slavemode */
#ifdef TWDEBUG
        CR31 |= 0x40;    /* DEBUG (for non-slave mode VESA) */
	crt1rateindex = SISSearchCRT1Rate(pScrn, mymode);
#endif
     } else {
        CR31 |=  0x40;  /* Set Drivermode */
	CR31 &=  ~0x06; /* Disable SlaveMode, disable SimuMode in SlaveMode */
	if(!pSiS->IsCustom) {
           crt1rateindex = SISSearchCRT1Rate(pScrn, mymode);
	} else {
	   crt1rateindex = CR33;
	}
     }

#ifdef SISDUALHEAD
     if(pSiS->DualHeadMode) {
        if(pSiS->SecondHead) {
	    /* CRT1 */
	    CR33 &= 0xf0;
	    if(!(vbflag & CRT1_LCDA)) {
	       CR33 |= (crt1rateindex & 0x0f);
	    }
	} else {
	    /* CRT2 */
	    CR33 &= 0x0f;
	    if(vbflag & CRT2_VGA) {
	       CR33 |= ((crt1rateindex << 4) & 0xf0);
	    }
	}
     } else
#endif
#ifdef SISMERGED
     if(pSiS->MergedFB) {
        CR33 = 0;
	if(!(vbflag & CRT1_LCDA)) {
	   CR33 |= (crt1rateindex & 0x0f);
	}
        if(vbflag & CRT2_VGA) {
	   if(!pSiS->IsCustomCRT2) {
	      CR33 |= (SISSearchCRT1Rate(pScrn, mymode2) << 4);
	   }
	}
     } else
#endif
     {
        CR33 = 0;
	if(!(vbflag & CRT1_LCDA)) {
	   CR33 |= (crt1rateindex & 0x0f);
	}
        if(vbflag & CRT2_VGA) {
           CR33 |= ((crt1rateindex & 0x0f) << 4);
	}
	if((!(pSiS->UseVESA)) && (vbflag & CRT2_ENABLE)) {
	   if(pSiS->CRT1off) CR33 &= 0xf0;
	}
     }

     if(pSiS->Chipset == PCI_CHIP_SIS660) {

        CR31 &= 0xfe;   /* Clear PAL flag (now in CR35) */
	CR38 &= 0x07;   /* Use only LCDA and HiVision/YPbPr bits */
	outSISIDXREG(SISCR, 0x30, CR30);
	outSISIDXREG(SISCR, 0x31, CR31);
	outSISIDXREG(SISCR, 0x33, CR33);
	outSISIDXREG(SISCR, 0x35, CR35);
	setSISIDXREG(SISCR, 0x38, 0xf8, CR38);
	outSISIDXREG(SISCR, 0x39, CR39);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
		"After:  CR30=0x%02x,CR31=0x%02x,CR33=0x%02x,CR35=0x%02x,CR38=%02x\n",
		    CR30, CR31, CR33, CR35, CR38);

     } else {

        outSISIDXREG(SISCR, 0x30, CR30);
        outSISIDXREG(SISCR, 0x31, CR31);
        outSISIDXREG(SISCR, 0x33, CR33);
        if(temp) {
           outSISIDXREG(SISCR, temp, CR38);
        }
	if(pSiS->VGAEngine == SIS_315_VGA) {
	   outSISIDXREG(SISCR, 0x3b, CR3B);
	   outSISIDXREG(SISCR, 0x79, CR79);
	}
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
		"After:  CR30=0x%02x,CR31=0x%02x,CR33=0x%02x,CR%02x=%02x\n",
		    CR30, CR31, CR33, temp, CR38);
     }

     pSiS->SiS_Pr->SiS_UseOEM = pSiS->OptUseOEM;

     /* Enable TurboQueue */
#ifdef SISVRAMQ
     if(pSiS->VGAEngine != SIS_315_VGA)
#endif     
        SiSEnableTurboQueue(pScrn);

     if((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_ENABLE)) {
        /* Switch on CRT1 for modes that require the bridge in SlaveMode */
	andSISIDXREG(SISSR,0x1f,0x3f);
	inSISIDXREG(SISCR, 0x17, CR17);
	if(!(CR17 & 0x80)) {
           orSISIDXREG(SISCR, 0x17, 0x80);
	   outSISIDXREG(SISSR, 0x00, 0x01);
	   usleep(10000);
           outSISIDXREG(SISSR, 0x00, 0x03);
	}
     }
}

/* Functions for adjusting various TV settings */

/* These are used by the PostSetMode() functions as well as
 * the display properties tool SiSCtrl.
 *
 * There is each a Set and a Get routine. The Set functions
 * take a value of the same range as the corresponding option.
 * The Get routines return a value of the same range (although
 * not necessarily the same value as previously set because
 * of the lower resolution of the respective setting compared
 * to the valid range).
 * The Get routines return -2 on error (eg. hardware does not
 * support this setting).
 * Note: The x and y positioning routines accept a position
 * RELATIVE to the default position. All other routines 
 * take ABSOLUTE values.
 *
 * The Set functions will store the property regardless if TV is
 * currently used or not and if the hardware supports the property
 * or not. The Get routines will return this stored
 * value if TV is not currently used (because the register does
 * not contain the correct value then) or if the hardware supports
 * the respective property. This should make it easier for the 
 * display property tool because it does not have to know the
 * hardware features.
 *
 * All the routines are dual head aware. It does not matter
 * if the function is called from the CRT1 or CRT2 session.
 * The values will be in pSiSEnt anyway, and read from there
 * if we're running dual head.
 */

void SiS_SetCHTVlumabandwidthcvbs(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
   
   pSiS->chtvlumabandwidthcvbs = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvlumabandwidthcvbs = val;
#endif

   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   
   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 8;
           if((val == 0) || (val == 1)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x03),0xFE);
           }
	   break;
       case CHRONTEL_701x:
           val /= 4;
	   if((val >= 0) && (val <= 3)) {
	       SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x02),0xFC);
	   }
           break;
   }   
}

int SiS_GetCHTVlumabandwidthcvbs(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvlumabandwidthcvbs;
      else 
#endif
           return (int)pSiS->chtvlumabandwidthcvbs;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x01) * 8);
      case CHRONTEL_701x:
	   return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x03) * 4);
      default:
           return -2;   
      }
   }
}

void SiS_SetCHTVlumabandwidthsvideo(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvlumabandwidthsvideo = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvlumabandwidthsvideo = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
      
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 6;
           if((val >= 0) && (val <= 2)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 9) | 0x03),0xF9);
           }
	   break;
       case CHRONTEL_701x:
           val /= 4;
	   if((val >= 0) && (val <= 3)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 10) | 0x02),0xF3);
	   }
           break;
   }	   
}

int SiS_GetCHTVlumabandwidthsvideo(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvlumabandwidthsvideo;
      else 
#endif
           return (int)pSiS->chtvlumabandwidthsvideo;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x06) >> 1) * 6);
      case CHRONTEL_701x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x0c) >> 2) * 4);
      default:
           return -2;   
      }
   }      
}

void SiS_SetCHTVlumaflickerfilter(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvlumaflickerfilter = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvlumaflickerfilter = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 6;
           if((val >= 0) && (val <= 2)) {
	      unsigned short reg = 0;
	      reg = SiS_GetCH70xx(pSiS->SiS_Pr, 0x01);
	      reg = (reg & 0xf0) | ((reg & 0x0c) >> 2) | (val << 2);
              SiS_SetCH70xx(pSiS->SiS_Pr, ((reg << 8) | 0x01));
           }
	   break;
       case CHRONTEL_701x:
           val /= 4;
	   if((val >= 0) && (val <= 3)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 10) | 0x01),0xF3);
	   }
           break;
   } 
}

int SiS_GetCHTVlumaflickerfilter(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
  
   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
          return (int)pSiSEnt->chtvlumaflickerfilter;
      else
#endif      
          return (int)pSiS->chtvlumaflickerfilter;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x03) * 6);
      case CHRONTEL_701x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x0c) >> 2) * 4);
      default:
           return -2;   
      }
   }     
}

void SiS_SetCHTVchromabandwidth(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvchromabandwidth = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvchromabandwidth = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 4;
           if((val >= 0) && (val <= 3)) {
              SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 12) | 0x03),0xCF);
           }
	   break;
       case CHRONTEL_701x:
           val /= 8;
	   if((val >= 0) && (val <= 1)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 12) | 0x02),0xEF);
	   }
           break;
   }	   
}

int SiS_GetCHTVchromabandwidth(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvchromabandwidth;
      else
#endif   
           return (int)pSiS->chtvchromabandwidth;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x30) >> 4) * 4);
      case CHRONTEL_701x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x10) >> 4) * 8);
      default:
           return -2;   
      }
   }    
}

void SiS_SetCHTVchromaflickerfilter(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvchromaflickerfilter = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvchromaflickerfilter = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 6;
           if((val >= 0) && (val <= 2)) {
	      unsigned short reg = 0;
	      reg = SiS_GetCH70xx(pSiS->SiS_Pr, 0x01);
	      reg = (reg & 0xc0) | ((reg & 0x0c) >> 2) | ((reg & 0x03) << 2) | (val << 4);
              SiS_SetCH70xx(pSiS->SiS_Pr, ((reg << 8) | 0x01));
           }
	   break;
       case CHRONTEL_701x:
           val /= 4;
	   if((val >= 0) && (val <= 3)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 12) | 0x01),0xCF);
	   }
           break;
   }	   
}

int SiS_GetCHTVchromaflickerfilter(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvchromaflickerfilter;
      else
#endif
           return (int)pSiS->chtvchromaflickerfilter;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x30) >> 4) * 6);
      case CHRONTEL_701x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x30) >> 4) * 4);
      default:
           return -2;   
      }
   }    
}

void SiS_SetCHTVcvbscolor(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvcvbscolor = val ? 1 : 0;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvcvbscolor = pSiS->chtvcvbscolor;
#endif

   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           if(!val)  SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x4003,0x00);
           else      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x0003,~0x40);
	   break;
       case CHRONTEL_701x:
           if(!val)  SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x0002,~0x20);
	   else      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x2002,0x00);
           break;
   }
}

int SiS_GetCHTVcvbscolor(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD
      if(pSiSEnt && pSiS->DualHeadMode)
           return (int)pSiSEnt->chtvcvbscolor;
      else
#endif
           return (int)pSiS->chtvcvbscolor;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x40) >> 6) ^ 0x01);
      case CHRONTEL_701x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x20) >> 5) ^ 0x01);
      default:
           return -2;
      }
   }
}

void SiS_SetCHTVtextenhance(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvtextenhance = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvtextenhance = val;
#endif

   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 6;
           if((val >= 0) && (val <= 2)) {
	      unsigned short reg = 0;
	      reg = SiS_GetCH70xx(pSiS->SiS_Pr, 0x01);
	      reg = (reg & 0xf0) | ((reg & 0x03) << 2) | val;
              SiS_SetCH70xx(pSiS->SiS_Pr, ((reg << 8) | 0x01));
           }
	   break;
       case CHRONTEL_701x:
           val /= 2;
	   if((val >= 0) && (val <= 7)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x03),0xF8);
	   }
           break;
   }
}

int SiS_GetCHTVtextenhance(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvtextenhance;
      else
#endif      
           return (int)pSiS->chtvtextenhance;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x0c) >> 2) * 6);
      case CHRONTEL_701x:
	   return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x07) * 2);
      default:
           return -2;
      }
   }
}

void SiS_SetCHTVcontrast(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvcontrast = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvcontrast = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   val /= 2;
   if((val >= 0) && (val <= 7)) {
       switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
              SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x11),0xF8);
	      break;
       case CHRONTEL_701x:
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x08),0xF8);
              break;
       }
       SiS_DDC2Delay(pSiS->SiS_Pr, 1000);
   }
}

int SiS_GetCHTVcontrast(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvcontrast;
      else
#endif      
           return (int)pSiS->chtvcontrast;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif   
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x11) & 0x07) * 2);
      case CHRONTEL_701x:
	   return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x08) & 0x07) * 2);
      default:
           return -2;   
      }
   }
}

void SiS_SetSISTVedgeenhance(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->sistvedgeenhance = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->sistvedgeenhance = val;
#endif

   if(!(pSiS->VBFlags & VB_301))  return;
   if(!(pSiS->VBFlags & CRT2_TV)) return;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   val /= 2;
   if((val >= 0) && (val <= 7)) {
      setSISIDXREG(SISPART2,0x3A, 0x1F, (val << 5));
   }
}

int SiS_GetSISTVedgeenhance(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   int result = pSiS->sistvedgeenhance;
   unsigned char temp;
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;

   if(pSiSEnt && pSiS->DualHeadMode) result = pSiSEnt->sistvedgeenhance;
#endif

   if(!(pSiS->VBFlags & VB_301))  return result;
   if(!(pSiS->VBFlags & CRT2_TV)) return result;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   inSISIDXREG(SISPART2, 0x3a, temp);
   return(int)(((temp & 0xe0) >> 5) * 2);
}

void SiS_SetSISTVantiflicker(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->sistvantiflicker = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->sistvantiflicker = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV))      return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE)) return;
   if(pSiS->VBFlags & TV_HIVISION)     return;
   if((pSiS->VBFlags & TV_YPBPR) &&
      (pSiS->VBFlags & (TV_YPBPR525P | TV_YPBPR750P | TV_YPBPR1080I))) return;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   /* Valid values: 0=off, 1=low, 2=med, 3=high, 4=adaptive */
   if((val >= 0) && (val <= 4)) {
      setSISIDXREG(SISPART2,0x0A,0x8F, (val << 4));
   }
}

int SiS_GetSISTVantiflicker(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   int result = pSiS->sistvantiflicker;
   unsigned char temp;
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;

   if(pSiSEnt && pSiS->DualHeadMode) result = pSiSEnt->sistvantiflicker;
#endif

   if(!(pSiS->VBFlags & VB_SISBRIDGE)) return result;
   if(!(pSiS->VBFlags & CRT2_TV))      return result;
   if(pSiS->VBFlags & TV_HIVISION)     return result;
   if((pSiS->VBFlags & TV_YPBPR) &&
      (pSiS->VBFlags & (TV_YPBPR525P | TV_YPBPR750P | TV_YPBPR1080I))) return result;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   inSISIDXREG(SISPART2, 0x0a, temp);
   return(int)((temp & 0x70) >> 4);
}

void SiS_SetSISTVsaturation(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->sistvsaturation = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->sistvsaturation = val;
#endif

   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE)) return;
   if(pSiS->VBFlags & VB_301) return;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   val /= 2;
   if((val >= 0) && (val <= 7)) {
      setSISIDXREG(SISPART4,0x21,0xF8, val);
   }
}

int SiS_GetSISTVsaturation(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   int result = pSiS->sistvsaturation;
   unsigned char temp;
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;

   if(pSiSEnt && pSiS->DualHeadMode)  result = pSiSEnt->sistvsaturation;
#endif

   if(!(pSiS->VBFlags & VB_SISBRIDGE)) return result;
   if(pSiS->VBFlags & VB_301)          return result;
   if(!(pSiS->VBFlags & CRT2_TV))      return result;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   inSISIDXREG(SISPART4, 0x21, temp);
   return(int)((temp & 0x07) * 2);
}

void SiS_SetSISTVcolcalib(ScrnInfoPtr pScrn, int val, Bool coarse)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
   int ccoarse, cfine, cbase = pSiS->sistvccbase;
   unsigned char temp;

#ifdef SISDUALHEAD
   if(pSiSEnt && pSiS->DualHeadMode) cbase = pSiSEnt->sistvccbase;
#endif

   if(coarse) {
      pSiS->sistvcolcalibc = ccoarse = val;
      cfine = pSiS->sistvcolcalibf;
#ifdef SISDUALHEAD
      if(pSiSEnt) {
         pSiSEnt->sistvcolcalibc = val;
	 if(pSiS->DualHeadMode) cfine = pSiSEnt->sistvcolcalibf;
      }
#endif
   } else {
      pSiS->sistvcolcalibf = cfine = val;
      ccoarse = pSiS->sistvcolcalibc;
#ifdef SISDUALHEAD
      if(pSiSEnt) {
         pSiSEnt->sistvcolcalibf = val;
         if(pSiS->DualHeadMode) ccoarse = pSiSEnt->sistvcolcalibc;
      }
#endif
   }

   if(!(pSiS->VBFlags & CRT2_TV))               return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE))          return;
   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   if((cfine >= -128) && (cfine <= 127) && (ccoarse >= -120) && (ccoarse <= 120)) {
      long finalcc = cbase + (((ccoarse * 256) + cfine) * 256);

      inSISIDXREG(SISPART4,0x1f,temp);
      if(!(temp & 0x01)) {
#if 0
         if(pSiS->VBFlags & TV_NTSC) finalcc += 0x21ed8620;
	 else if(pSiS->VBFlags & TV_PALM) finalcc += ?;
	 else if(pSiS->VBFlags & TV_PALM) finalcc += ?;
	 else finalcc += 0x2a05d300;
#endif
      }
      setSISIDXREG(SISPART2,0x31,0x80,((finalcc >> 24) & 0x7f));
      outSISIDXREG(SISPART2,0x32,((finalcc >> 16) & 0xff));
      outSISIDXREG(SISPART2,0x33,((finalcc >> 8) & 0xff));
      outSISIDXREG(SISPART2,0x34,(finalcc & 0xff));
   }
}

int SiS_GetSISTVcolcalib(ScrnInfoPtr pScrn, Bool coarse)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;

   if(pSiSEnt && pSiS->DualHeadMode)
      if(coarse)  return (int)pSiSEnt->sistvcolcalibc;
      else        return (int)pSiSEnt->sistvcolcalibf;
   else
#endif
   if(coarse)     return (int)pSiS->sistvcolcalibc;
   else           return (int)pSiS->sistvcolcalibf;
}

void SiS_SetSISTVcfilter(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->sistvcfilter = val ? 1 : 0;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->sistvcfilter = pSiS->sistvcfilter;
#endif

   if(!(pSiS->VBFlags & CRT2_TV))               return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE))          return;
   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   setSISIDXREG(SISPART2,0x30,~0x10,((pSiS->sistvcfilter << 4) & 0x10));
}

int SiS_GetSISTVcfilter(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   int result = pSiS->sistvcfilter;
   unsigned char temp;
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;

   if(pSiSEnt && pSiS->DualHeadMode) result = pSiSEnt->sistvcfilter;
#endif

   if(!(pSiS->VBFlags & VB_SISBRIDGE))          return result;
   if(!(pSiS->VBFlags & CRT2_TV))               return result;
   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return result;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   inSISIDXREG(SISPART2, 0x30, temp);
   return(int)((temp & 0x10) ? 1 : 0);
}

void SiS_SetSISTVyfilter(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
   unsigned char p35,p36,p37,p38,p48,p49,p4a,p30;
   int i,j;

   pSiS->sistvyfilter = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->sistvyfilter = pSiS->sistvyfilter;
#endif

   if(!(pSiS->VBFlags & CRT2_TV))               return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE))          return;
   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return;

   p35 = pSiS->p2_35; p36 = pSiS->p2_36;
   p37 = pSiS->p2_37; p38 = pSiS->p2_38;
   p48 = pSiS->p2_48; p49 = pSiS->p2_49;
   p4a = pSiS->p2_4a; p30 = pSiS->p2_30;
#ifdef SISDUALHEAD
   if(pSiSEnt && pSiS->DualHeadMode) {
      p35 = pSiSEnt->p2_35; p36 = pSiSEnt->p2_36;
      p37 = pSiSEnt->p2_37; p38 = pSiSEnt->p2_38;
      p48 = pSiSEnt->p2_48; p49 = pSiSEnt->p2_49;
      p4a = pSiSEnt->p2_4a; p30 = pSiSEnt->p2_30;
   }
#endif
   p30 &= 0x20;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->sistvyfilter) {
   case 0:
      andSISIDXREG(SISPART2,0x30,0xdf);
      break;
   case 1:
      outSISIDXREG(SISPART2,0x35,p35);
      outSISIDXREG(SISPART2,0x36,p36);
      outSISIDXREG(SISPART2,0x37,p37);
      outSISIDXREG(SISPART2,0x38,p38);
      if(!(pSiS->VBFlags & VB_301)) {
         outSISIDXREG(SISPART2,0x48,p48);
         outSISIDXREG(SISPART2,0x49,p49);
         outSISIDXREG(SISPART2,0x4a,p4a);
      }
      setSISIDXREG(SISPART2,0x30,0xdf,p30);
      break;
   case 2:
   case 3:
   case 4:
   case 5:
   case 6:
   case 7:
   case 8:
      if(!(pSiS->VBFlags & (TV_PALM | TV_PALN | TV_NTSCJ))) {
         int yindex301 = -1, yindex301B = -1;
	 unsigned char p3d4_34;

	 inSISIDXREG(SISCR,0x34,p3d4_34);

	 switch((p3d4_34 & 0x7f)) {
	 case 0x59:  /* 320x200 */
	 case 0x41:
	 case 0x4f:
	 case 0x50:  /* 320x240 */
	 case 0x56:
	 case 0x53:
	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 0 : 4;
	    break;
	 case 0x2f:  /* 640x400 */
	 case 0x5d:
	 case 0x5e:
	 case 0x2e:  /* 640x480 */
	 case 0x44:
	 case 0x62:
	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 1 : 5;
	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 0 : 4;
	    break;
	 case 0x31:   /* 720x480 */
	 case 0x33:
	 case 0x35:
	 case 0x32:   /* 720x576 */
	 case 0x34:
	 case 0x36:
	 case 0x5f:   /* 768x576 */
	 case 0x60:
	 case 0x61:
	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 2 : 6;
	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 1 : 5;
	    break;
	 case 0x51:   /* 400x300 */
	 case 0x57:
	 case 0x54:
	 case 0x30:   /* 800x600 */
	 case 0x47:
	 case 0x63:
	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 3 : 7;
	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 2 : 6;
	    break;
	 case 0x52:   /* 512x384 */
	 case 0x58:
	 case 0x5c:
	 case 0x38:   /* 1024x768 */
	 case 0x4a:
	 case 0x64:
	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 3 : 7;
	    break;
	 }
         if(pSiS->VBFlags & VB_301) {
            if(yindex301 >= 0) {
	       for(i=0, j=0x35; i<=3; i++, j++) {
	          outSISIDXREG(SISPART2,j,(SiSTVFilter301[yindex301].filter[pSiS->sistvyfilter-2][i]));
	       }
	    }
         } else {
            if(yindex301B >= 0) {
	       for(i=0, j=0x35; i<=3; i++, j++) {
	          outSISIDXREG(SISPART2,j,(SiSTVFilter301B[yindex301B].filter[pSiS->sistvyfilter-2][i]));
	       }
	       for(i=4, j=0x48; i<=6; i++, j++) {
	          outSISIDXREG(SISPART2,j,(SiSTVFilter301B[yindex301B].filter[pSiS->sistvyfilter-2][i]));
	       }
	    }
         }
         orSISIDXREG(SISPART2,0x30,0x20);
      }
   }
}

int SiS_GetSISTVyfilter(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;

   if(pSiSEnt && pSiS->DualHeadMode)
      return (int)pSiSEnt->sistvyfilter;
   else
#endif
      return (int)pSiS->sistvyfilter;
}

void SiS_SetSIS6326TVantiflicker(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;

   pSiS->sistvantiflicker = val;

   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
  
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) return;
   
   /* Valid values: 0=off, 1=low, 2=med, 3=high, 4=adaptive */
   if(val >= 0 && val <= 4) {
      tmp &= 0x1f;
      tmp |= (val << 5);
      SiS6326SetTVReg(pScrn,0x00,tmp);
   }
}

int SiS_GetSIS6326TVantiflicker(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;
   
   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
      return (int)pSiS->sistvantiflicker;
   }
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) {
      return (int)pSiS->sistvantiflicker;
   } else {
      return (int)((tmp >> 5) & 0x07);    
   }
}

void SiS_SetSIS6326TVenableyfilter(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;

   if(val) val = 1;   
   pSiS->sis6326enableyfilter = val;

   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
  
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) return;
   
   tmp = SiS6326GetTVReg(pScrn,0x43);
   tmp &= ~0x10;
   tmp |= ((val & 0x01) << 4);
   SiS6326SetTVReg(pScrn,0x43,tmp);
}

int SiS_GetSIS6326TVenableyfilter(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;
   
   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
      return (int)pSiS->sis6326enableyfilter;
   }
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) {
      return (int)pSiS->sis6326enableyfilter;
   } else {
      tmp = SiS6326GetTVReg(pScrn,0x43);
      return (int)((tmp >> 4) & 0x01);
   }
}

void SiS_SetSIS6326TVyfilterstrong(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;
   
   if(val) val = 1;
   pSiS->sis6326yfilterstrong = val;

   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
  
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) return;
   
   tmp = SiS6326GetTVReg(pScrn,0x43);
   if(tmp & 0x10) {
      tmp &= ~0x40;
      tmp |= ((val & 0x01) << 6);
      SiS6326SetTVReg(pScrn,0x43,tmp);
   }
}

int SiS_GetSIS6326TVyfilterstrong(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;
   
   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
      return (int)pSiS->sis6326yfilterstrong;
   }
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) {
      return (int)pSiS->sis6326yfilterstrong;
   } else {
      tmp = SiS6326GetTVReg(pScrn,0x43);
      if(!(tmp & 0x10)) {
         return (int)pSiS->sis6326yfilterstrong;
      } else {
         return (int)((tmp >> 6) & 0x01);
      }
   }
}
   
void SiS_SetTVxposoffset(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   pSiS->tvxpos = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->tvxpos = val;
#endif

   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {

      if(pSiS->VBFlags & CRT2_TV) {

         if(pSiS->VBFlags & VB_CHRONTEL) {

	    int x = pSiS->tvx;
#ifdef SISDUALHEAD
	    if(pSiSEnt && pSiS->DualHeadMode) x = pSiSEnt->tvx;
#endif
	    switch(pSiS->ChrontelType) {
	    case CHRONTEL_700x:
	       if((val >= -32) && (val <= 32)) {
		   x += val;
		   if(x < 0) x = 0;
		   SiS_SetCH700x(pSiS->SiS_Pr, (((x & 0xff) << 8) | 0x0a));
		   SiS_SetCH70xxANDOR(pSiS->SiS_Pr, (((x & 0x0100) << 1) | 0x08),0xFD);
	       }
	       break;
	    case CHRONTEL_701x:
	       /* Not supported by hardware */
	       break;
	    }

	 } else if(pSiS->VBFlags & VB_SISBRIDGE) {

	    if((val >= -32) && (val <= 32)) {

	        unsigned char p2_1f,p2_20,p2_2b,p2_42,p2_43;
		unsigned short temp;

		p2_1f = pSiS->p2_1f;
		p2_20 = pSiS->p2_20;
		p2_2b = pSiS->p2_2b;
		p2_42 = pSiS->p2_42;
		p2_43 = pSiS->p2_43;
#ifdef SISDUALHEAD
	        if(pSiSEnt && pSiS->DualHeadMode) {
		   p2_1f = pSiSEnt->p2_1f;
		   p2_20 = pSiSEnt->p2_20;
		   p2_2b = pSiSEnt->p2_2b;
		   p2_42 = pSiSEnt->p2_42;
		   p2_43 = pSiSEnt->p2_43;
		}
#endif

		temp = p2_1f | ((p2_20 & 0xf0) << 4);
		temp += (val * 2);
		p2_1f = temp & 0xff;
		p2_20 = (temp & 0xf00) >> 4;
		p2_2b = ((p2_2b & 0x0f) + (val * 2)) & 0x0f;
		temp = p2_43 | ((p2_42 & 0xf0) << 4);
		temp += (val * 2);
		p2_43 = temp & 0xff;
		p2_42 = (temp & 0xf00) >> 4;
		SISWaitRetraceCRT2(pScrn);
	        outSISIDXREG(SISPART2,0x1f,p2_1f);
		setSISIDXREG(SISPART2,0x20,0x0F,p2_20);
		setSISIDXREG(SISPART2,0x2b,0xF0,p2_2b);
		setSISIDXREG(SISPART2,0x42,0x0F,p2_42);
		outSISIDXREG(SISPART2,0x43,p2_43);
	     }
	 }
      }

   } else if(pSiS->Chipset == PCI_CHIP_SIS6326) {

      if(pSiS->SiS6326Flags & SIS6326_TVDETECTED) {

         unsigned char tmp;
	 unsigned short temp1, temp2, temp3;

         tmp = SiS6326GetTVReg(pScrn,0x00);
         if(tmp & 0x04) {

	    temp1 = pSiS->tvx1;
            temp2 = pSiS->tvx2;
            temp3 = pSiS->tvx3;
            if((val >= -16) && (val <= 16)) {
	       if(val > 0) {
	          temp1 += (val * 4);
	          temp2 += (val * 4);
	          while((temp1 > 0x0fff) || (temp2 > 0x0fff)) {
	             temp1 -= 4;
		     temp2 -= 4;
	          }
	       } else {
	          val = -val;
	          temp3 += (val * 4);
	          while(temp3 > 0x03ff) {
	     	     temp3 -= 4;
	          }
	       }
            }
            SiS6326SetTVReg(pScrn,0x3a,(temp1 & 0xff));
            tmp = SiS6326GetTVReg(pScrn,0x3c);
            tmp &= 0xf0;
            tmp |= ((temp1 & 0x0f00) >> 8);
            SiS6326SetTVReg(pScrn,0x3c,tmp);
            SiS6326SetTVReg(pScrn,0x26,(temp2 & 0xff));
            tmp = SiS6326GetTVReg(pScrn,0x27);
            tmp &= 0x0f;
            tmp |= ((temp2 & 0x0f00) >> 4);
            SiS6326SetTVReg(pScrn,0x27,tmp);
            SiS6326SetTVReg(pScrn,0x12,(temp3 & 0xff));
            tmp = SiS6326GetTVReg(pScrn,0x13);
            tmp &= ~0xC0;
            tmp |= ((temp3 & 0x0300) >> 2);
            SiS6326SetTVReg(pScrn,0x13,tmp);
	 }
      }
   }
}

int SiS_GetTVxposoffset(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;

   if(pSiSEnt && pSiS->DualHeadMode)
        return (int)pSiSEnt->tvxpos;
   else
#endif
        return (int)pSiS->tvxpos;
}

void SiS_SetTVyposoffset(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   pSiS->tvypos = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->tvypos = val;
#endif

   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {

      if(pSiS->VBFlags & CRT2_TV) {

         if(pSiS->VBFlags & VB_CHRONTEL) {

	    int y = pSiS->tvy;
#ifdef SISDUALHEAD
	    if(pSiSEnt && pSiS->DualHeadMode) y = pSiSEnt->tvy;
#endif
	    switch(pSiS->ChrontelType) {
	    case CHRONTEL_700x:
	       if((val >= -32) && (val <= 32)) {
		   y -= val;
		   if(y < 0) y = 0;
		   SiS_SetCH700x(pSiS->SiS_Pr, (((y & 0xff) << 8) | 0x0b));
		   SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((y & 0x0100) | 0x08),0xFE);
	       }
	       break;
	    case CHRONTEL_701x:
	       /* Not supported by hardware */
	       break;
	    }

	 } else if(pSiS->VBFlags & VB_SISBRIDGE) {

	    if((val >= -32) && (val <= 32)) {
		char p2_01, p2_02;
		val /= 2;  /* 4 */
		p2_01 = pSiS->p2_01;
		p2_02 = pSiS->p2_02;
#ifdef SISDUALHEAD
	        if(pSiSEnt && pSiS->DualHeadMode) {
		   p2_01 = pSiSEnt->p2_01;
		   p2_02 = pSiSEnt->p2_02;
		}
#endif
		p2_01 += val; /* val * 2 */
		p2_02 += val; /* val * 2 */
		while((p2_01 <= 0) || (p2_02 <= 0)) {
		      p2_01 += 2;
		      p2_02 += 2;
		}
		SISWaitRetraceCRT2(pScrn);
		outSISIDXREG(SISPART2,0x01,p2_01);
		outSISIDXREG(SISPART2,0x02,p2_02);
	     }
	 }

      }

   } else if(pSiS->Chipset == PCI_CHIP_SIS6326) {

      if(pSiS->SiS6326Flags & SIS6326_TVDETECTED) {

         unsigned char tmp;
	 int temp1, limit;

         tmp = SiS6326GetTVReg(pScrn,0x00);
         if(tmp & 0x04) {

	    if((val >= -16) && (val <= 16)) {
	      temp1 = (unsigned short)pSiS->tvy1;
	      limit = (pSiS->SiS6326Flags & SIS6326_TVPAL) ? 625 : 525;
	      if(val > 0) {
                temp1 += (val * 4);
	        if(temp1 > limit) temp1 -= limit;
	      } else {
	        val = -val;
	        temp1 -= (val * 2);
	        if(temp1 <= 0) temp1 += (limit -1);
	      }
	      SiS6326SetTVReg(pScrn,0x11,(temp1 & 0xff));
	      tmp = SiS6326GetTVReg(pScrn,0x13);
	      tmp &= ~0x30;
	      tmp |= ((temp1 & 0x300) >> 4);
	      SiS6326SetTVReg(pScrn,0x13,tmp);
	      if(temp1 == 1)                                 tmp = 0x10;
	      else {
	       if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
	         if((temp1 <= 3) || (temp1 >= (limit - 2)))  tmp = 0x08;
	         else if(temp1 < 22)		 	     tmp = 0x02;
	         else 					     tmp = 0x04;
	       } else {
	         if((temp1 <= 5) || (temp1 >= (limit - 4)))  tmp = 0x08;
	         else if(temp1 < 19)			     tmp = 0x02;
	         else 					     tmp = 0x04;
	       }
	     }
	     SiS6326SetTVReg(pScrn,0x21,tmp);
           }
	 }
      }
   }
}

int SiS_GetTVyposoffset(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;

   if(pSiSEnt && pSiS->DualHeadMode)
        return (int)pSiSEnt->tvypos;
   else
#endif
        return (int)pSiS->tvypos;
}

void SiS_SetTVxscale(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   pSiS->tvxscale = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->tvxscale = val;
#endif

   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {

      if((pSiS->VBFlags & CRT2_TV) && (pSiS->VBFlags & VB_SISBRIDGE)) {

	 if((val >= -16) && (val <= 16)) {

	    unsigned char p2_44,p2_45,p2_46;
	    int scalingfactor;

	    p2_44 = pSiS->p2_44;
	    p2_45 = pSiS->p2_45 & 0x3f;
	    p2_46 = pSiS->p2_46 & 0x07;
#ifdef SISDUALHEAD
	    if(pSiSEnt && pSiS->DualHeadMode) {
	       p2_44 = pSiSEnt->p2_44;
	       p2_45 = pSiSEnt->p2_45 & 0x3f;
	       p2_46 = pSiSEnt->p2_46 & 0x07;
	    }
#endif
	    scalingfactor = (p2_46 << 13) | ((p2_45 & 0x1f) << 8) | p2_44;

	    if(val < 0) {
	       p2_45 &= 0xdf;
	       scalingfactor += ((-val) * 64);
	       if(scalingfactor > 0xffff) scalingfactor = 0xffff;
	    } else if(val > 0) {
	       p2_45 &= 0xdf;
	       scalingfactor -= (val * 64);
	       if(scalingfactor < 1) scalingfactor = 1;
	    }

	    p2_44 = scalingfactor & 0xff;
	    p2_45 &= 0xe0;
	    p2_45 |= ((scalingfactor >> 8) & 0x1f);
	    p2_46 = ((scalingfactor >> 13) & 0x07);

	    SISWaitRetraceCRT2(pScrn);
	    outSISIDXREG(SISPART2,0x44,p2_44);
	    setSISIDXREG(SISPART2,0x45,0xC0,p2_45);
	    if(!(pSiS->VBFlags & VB_301)) {
	       setSISIDXREG(SISPART2,0x46,0xF8,p2_46);
	    }
	 }

      }

   }
}

int SiS_GetTVxscale(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;

   if(pSiSEnt && pSiS->DualHeadMode)
        return (int)pSiSEnt->tvxscale;
   else
#endif
        return (int)pSiS->tvxscale;
}

void SiS_SetTVyscale(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
   Bool usentsc = FALSE;
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   if(val < -4) val = -4;
   if(val > 3)  val = 3;

   pSiS->tvyscale = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->tvyscale = val;
#endif

   if(pSiS->VGAEngine == SIS_315_VGA || pSiS->VGAEngine == SIS_315_VGA) {

      if((pSiS->VBFlags & CRT2_TV) && (pSiS->VBFlags & VB_SISBRIDGE)) {

	 int srindex = -1, newvde, i = 0, j, vlimit, temp;
	 unsigned char p3d4_34;

	 if(pSiS->VBFlags & TV_HIVISION) return;
         if((pSiS->VBFlags & TV_YPBPR) &&
            (pSiS->VBFlags & (TV_YPBPR1080I | TV_YPBPR750P | TV_YPBPR525P))) return;

	 if(pSiS->VBFlags & TV_YPBPR)                 usentsc = TRUE;
         else if(pSiS->VBFlags & (TV_NTSC | TV_PALM)) usentsc = TRUE;

	 vlimit = usentsc ? 259 : 309;

	 inSISIDXREG(SISCR,0x34,p3d4_34);

	 switch((p3d4_34 & 0x7f)) {
#if 0
	 case 0x50:   /* 320x240 - hdclk mode */
	 case 0x56:
	 case 0x53:
#endif
	 case 0x2e:   /* 640x480 */
	 case 0x44:
	 case 0x62:
	    srindex  = usentsc ? 0 : 21;
	    break;
	 case 0x31:   /* 720x480 */
	 case 0x33:
	 case 0x35:
	 case 0x32:   /* 720x576 */
	 case 0x34:
	 case 0x36:
	 case 0x5f:   /* 768x576 */
	 case 0x60:
	 case 0x61:
            if(pSiS->VGAEngine == SIS_315_VGA) {
	       srindex  = usentsc ? 7 : 28;
	    }
	    break;
#if 0
	 case 0x51:   /* 400x300 - hdclk mode */
	 case 0x57:
	 case 0x54:
#endif
	 case 0x30:   /* 800x600 */
	 case 0x47:
	 case 0x63:
	    srindex  = usentsc ? 14 : 35;
	 }

	 if(srindex >= 0) {
	    Bool found = FALSE;
	    if(pSiS->tvyscale != 0) {
	       for(j=0; j<=1; j++) {
	          for(i=0; i<=6; i++) {
	             if(SiSTVVScale[srindex+i].sindex == pSiS->tvyscale) {
		        found = TRUE;
		        break;
		     }
	          }
		  if(found) break;
	          if(pSiS->tvyscale > 0) pSiS->tvyscale--;
		  else pSiS->tvyscale++;
	       }
	    }
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->tvyscale = pSiS->tvyscale;
#endif
	    if(pSiS->tvyscale == 0) {
	       unsigned char p2_0a = pSiS->p2_0a;
	       unsigned char p2_2f = pSiS->p2_2f;
	       unsigned char p2_30 = pSiS->p2_30;
	       unsigned char p2_46 = pSiS->p2_46;
	       unsigned char p2_47 = pSiS->p2_47;
	       unsigned char p1scaling[9], p4scaling[9];
	       unsigned char *p2scaling;

	       for(i=0; i<9; i++) {
	          p1scaling[i] = pSiS->scalingp1[i];
	       }
	       for(i=0; i<9; i++) {
	          p4scaling[i] = pSiS->scalingp4[i];
	       }
	       p2scaling = &pSiS->scalingp2[0];
#ifdef SISDUALHEAD
               if(pSiSEnt && pSiS->DualHeadMode) {
	          p2_0a = pSiSEnt->p2_0a;
		  p2_2f = pSiSEnt->p2_2f;
	          p2_30 = pSiSEnt->p2_30;
		  p2_46 = pSiSEnt->p2_46;
		  p2_47 = pSiSEnt->p2_47;
	          for(i=0; i<9; i++) {
	             p1scaling[i] = pSiSEnt->scalingp1[i];
	          }
	          for(i=0; i<9; i++) {
	             p4scaling[i] = pSiSEnt->scalingp4[i];
	          }
		  p2scaling = &pSiSEnt->scalingp2[0];
	       }
#endif
               SISWaitRetraceCRT2(pScrn);
	       if(pSiS->VBFlags & (VB_301C|VB_302ELV)) {
	          for(i=0; i<64; i++) {
	             outSISIDXREG(SISPART2,(0xc0 + i),p2scaling[i]);
	          }
	       }
	       for(i=0; i<9; i++) {
	          outSISIDXREG(SISPART1,SiSScalingP1Regs[i],p1scaling[i]);
	       }
	       for(i=0; i<9; i++) {
	          outSISIDXREG(SISPART4,SiSScalingP4Regs[i],p4scaling[i]);
	       }

	       setSISIDXREG(SISPART2,0x0a,0x7f,(p2_0a & 0x80));
	       outSISIDXREG(SISPART2,0x2f,p2_2f);
	       setSISIDXREG(SISPART2,0x30,0x3f,(p2_30 & 0xc0));
	       if(!(pSiS->VBFlags & VB_301)) {
	          setSISIDXREG(SISPART2,0x46,0x9f,(p2_46 & 0x60));
		  outSISIDXREG(SISPART2,0x47,p2_47);
	       }

	    } else {

	       int so = (pSiS->VGAEngine == SIS_300_VGA) ? 12 : 0;
	       int realvde, j, srindex301c, myypos, watchdog = 32;
	       unsigned long calctemp;

	       srindex += i;
	       srindex301c = srindex * 64;
	       newvde = SiSTVVScale[srindex].ScaleVDE;
	       realvde = SiSTVVScale[srindex].RealVDE;

	       do {
	          inSISIDXREG(SISPART2,0x01,temp);
	          temp = vlimit - (temp & 0x7f);
	          if((temp - (((newvde >> 1) - 2) + 9)) > 0) break;
		  myypos = pSiS->tvypos - 1;
#ifdef SISDUALHEAD
		  if(pSiSEnt && pSiS->DualHeadMode) myypos = pSiSEnt->tvypos - 1;
#endif
		  SiS_SetTVyposoffset(pScrn, myypos);
	       } while(watchdog--);

	       SISWaitRetraceCRT2(pScrn);

	       if(pSiS->VBFlags & (VB_301C|VB_302ELV)) {
#ifdef TWDEBUG
		  xf86DrvMsg(0, X_INFO, "301C scaler: Table index %d\n");
#endif
	          for(j=0; j<64; j++) {
		     outSISIDXREG(SISPART2,(0xc0 + j), SiS301CScaling[srindex301c + j]);
		  }
	       }

	       if(!(pSiS->VBFlags & VB_301)) {
	          temp = (newvde >> 1) - 3;
	          setSISIDXREG(SISPART2,0x46,0x9f,((temp & 0x0300) >> 3));
	          outSISIDXREG(SISPART2,0x47,(temp & 0xff));
	       }
	       outSISIDXREG(SISPART1,0x08,(SiSTVVScale[srindex].reg[so+0] & 0xff));
	       setSISIDXREG(SISPART1,0x09,0x0f,((SiSTVVScale[srindex].reg[so+0] >> 4) & 0xf0));
	       outSISIDXREG(SISPART1,0x0b,(SiSTVVScale[srindex].reg[so+1] & 0xff));
	       setSISIDXREG(SISPART1,0x0c,0xf0,((SiSTVVScale[srindex].reg[so+1] >> 8) & 0x0f));
	       outSISIDXREG(SISPART1,0x0d,(SiSTVVScale[srindex].reg[so+2] & 0xff));
	       outSISIDXREG(SISPART1,0x0e,(SiSTVVScale[srindex].reg[so+3] & 0xff));
	       setSISIDXREG(SISPART1,0x12,0xf8,((SiSTVVScale[srindex].reg[so+3] >> 8 ) & 0x07));
	       outSISIDXREG(SISPART1,0x10,(SiSTVVScale[srindex].reg[so+4] & 0xff));
	       setSISIDXREG(SISPART1,0x11,0x8f,((SiSTVVScale[srindex].reg[so+4] >> 4) & 0x70));
	       setSISIDXREG(SISPART1,0x11,0xf0,(SiSTVVScale[srindex].reg[so+5] & 0x0f));

	       setSISIDXREG(SISPART2,0x0a,0x7f,((SiSTVVScale[srindex].reg[so+6] << 7) & 0x80));
	       outSISIDXREG(SISPART2,0x2f,((newvde / 2) - 2));
	       setSISIDXREG(SISPART2,0x30,0x3f,((((newvde / 2) - 2) >> 2) & 0xc0));

	       outSISIDXREG(SISPART4,0x13,(SiSTVVScale[srindex].reg[so+7] & 0xff));
	       outSISIDXREG(SISPART4,0x14,(SiSTVVScale[srindex].reg[so+8] & 0xff));
	       setSISIDXREG(SISPART4,0x15,0x7f,((SiSTVVScale[srindex].reg[so+8] >> 1) & 0x80));

	       outSISIDXREG(SISPART4,0x16,(SiSTVVScale[srindex].reg[so+9] & 0xff));
	       setSISIDXREG(SISPART4,0x15,0x87,((SiSTVVScale[srindex].reg[so+9] >> 5) & 0x78));

	       outSISIDXREG(SISPART4,0x17,(SiSTVVScale[srindex].reg[so+10] & 0xff));
	       setSISIDXREG(SISPART4,0x15,0xf8,((SiSTVVScale[srindex].reg[so+10] >> 8) & 0x07));

	       outSISIDXREG(SISPART4,0x18,(SiSTVVScale[srindex].reg[so+11] & 0xff));
	       setSISIDXREG(SISPART4,0x19,0xf0,((SiSTVVScale[srindex].reg[so+11] >> 8) & 0x0f));

               temp = 0x40;
	       if(realvde <= newvde) temp = 0;
	       else realvde -= newvde;

	       calctemp = (realvde * 256 * 1024) / newvde;
	       if((realvde * 256 * 1024) % newvde) calctemp++;
	       outSISIDXREG(SISPART4,0x1b,(calctemp & 0xff));
	       outSISIDXREG(SISPART4,0x1a,((calctemp >> 8) & 0xff));
	       setSISIDXREG(SISPART4,0x19,0x8f,(((calctemp >> 12) & 0x30) | temp));
	    }
	 }

      }

   }
}

int SiS_GetTVyscale(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;

   if(pSiSEnt && pSiS->DualHeadMode)
        return (int)pSiSEnt->tvyscale;
   else
#endif
        return (int)pSiS->tvyscale;
}

/* PostSetMode:
 * -) Disable CRT1 for saving bandwidth. This doesn't work with VESA;
 *    VESA uses the bridge in SlaveMode and switching CRT1 off while
 *    the bridge is in SlaveMode not that clever...
 * -) Check if overlay can be used (depending on dotclock)
 * -) Check if Panel Scaler is active on LVDS for overlay re-scaling
 * -) Save TV registers for further processing
 * -) Apply TV settings
 */
static void
SiSPostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
    unsigned char usScratchCR17;
    Bool flag = FALSE;
    Bool doit = TRUE;
    int myclock, temp;
    unsigned char  sr2b, sr2c, tmpreg;
    float          num, denum, postscalar, divider;

#ifdef TWDEBUG
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
    	"CRT1off is %d\n", pSiS->CRT1off);
#endif
    pSiS->CRT1isoff = pSiS->CRT1off;

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    if(pSiS->sishw_ext.jChipType >= SIS_661) {
       inSISIDXREG(SISSR,0x11,tmpreg);
       if(tmpreg & 0x20) {
          inSISIDXREG(SISSR,0x3e,tmpreg);
	  tmpreg = (tmpreg + 1) & 0xff;
	  outSISIDXREG(SISSR,0x3e,tmpreg);
       }
    }

    if((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_ENABLE)) {

	if(pSiS->VBFlags != pSiS->VBFlags_backup) {
	   pSiS->VBFlags = pSiS->VBFlags_backup;
	   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"VBFlags restored to %0lx\n", pSiS->VBFlags);
	}

	/* -) We can't switch off CRT1 if bridge is in SlaveMode.
	 * -) If we change to a SlaveMode-Mode (like 512x384), we
	 *    need to adapt VBFlags for eg. Xv.
	 */
#ifdef SISDUALHEAD
	if(!pSiS->DualHeadMode) {
#endif
	   if(SiSBridgeIsInSlaveMode(pScrn)) {
	      doit = FALSE;
	      temp = pSiS->VBFlags;
	      pSiS->VBFlags &= (~VB_DISPMODE_SINGLE);
	      pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_DISP1);
              if(temp != pSiS->VBFlags) {
		 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 	"VBFlags changed to 0x%0lx\n", pSiS->VBFlags);
	      }
	   }
#ifdef SISDUALHEAD
	}
#endif

	if(pSiS->VGAEngine == SIS_315_VGA) {

	   if((pSiS->CRT1off) && (doit)) {
	      orSISIDXREG(SISCR,pSiS->myCR63,0x40);
	      orSISIDXREG(SISSR,0x1f,0xc0);
	   } else {
	      andSISIDXREG(SISCR,pSiS->myCR63,0xBF);
	      andSISIDXREG(SISSR,0x1f,0x3f);
	   }

	} else {

	   if(doit) {
              inSISIDXREG(SISCR, 0x17, usScratchCR17);
    	      if(pSiS->CRT1off) {
	         if(usScratchCR17 & 0x80) {
		    flag = TRUE;
		    usScratchCR17 &= ~0x80;
		 }
		 orSISIDXREG(SISSR,0x1f,0xc0);
    	      } else {
	         if(!(usScratchCR17 & 0x80)) {
		    flag = TRUE;
        	    usScratchCR17 |= 0x80;
		 }
		 andSISIDXREG(SISSR,0x1f,0x3f);
              }
	      /* Reset only if status changed */
	      if(flag) {
	         outSISIDXREG(SISCR, 0x17, usScratchCR17);
	         outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
	         usleep(10000);
                 outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */
	      }
	   }
	}

    }

    /* Determine if the video overlay can be used */
    if(!pSiS->NoXvideo) {
       inSISIDXREG(SISSR,0x2b,sr2b);
       inSISIDXREG(SISSR,0x2c,sr2c);
       divider = (sr2b & 0x80) ? 2.0 : 1.0;
       postscalar = (sr2c & 0x80) ?
              ( (((sr2c >> 5) & 0x03) == 0x02) ? 6.0 : 8.0 ) :
	      ( ((sr2c >> 5) & 0x03) + 1.0 );
       num = (sr2b & 0x7f) + 1.0;
       denum = (sr2c & 0x1f) + 1.0;
       myclock = (int)((14318 * (divider / postscalar) * (num / denum)) / 1000);

       pSiS->MiscFlags &= ~(MISC_CRT1OVERLAY | MISC_CRT1OVERLAYGAMMA);
       switch(pSiS->sishw_ext.jChipType) {
         case SIS_300:
         case SIS_540:
         case SIS_630:
         case SIS_730:
            if(myclock < 150) {
               pSiS->MiscFlags |= MISC_CRT1OVERLAY;
            }
            break;
         case SIS_550:
         case SIS_650:
         case SIS_740:
	    if(myclock < 175) {
               pSiS->MiscFlags |= MISC_CRT1OVERLAY;
	       if(myclock < 166) {
	          pSiS->MiscFlags |= MISC_CRT1OVERLAYGAMMA;
	       }
            }
            break;
	 case SIS_315H:
         case SIS_315:
         case SIS_315PRO:
         case SIS_330:
	 case SIS_661:
	 case SIS_741:
	 case SIS_660:
	 case SIS_760:
            if(myclock < 180) {
               pSiS->MiscFlags |= MISC_CRT1OVERLAY;
	       if(myclock < 166) {
	          pSiS->MiscFlags |= MISC_CRT1OVERLAYGAMMA;
	       }
            }
            break;
       }
       if(!(pSiS->MiscFlags & MISC_CRT1OVERLAY)) {
#ifdef SISDUALHEAD
          if((!pSiS->DualHeadMode) || (pSiS->SecondHead))
#endif
             xf86DrvMsgVerb(pScrn->scrnIndex, X_WARNING, 3,
	     	"Current dotclock (%dMhz) too high for video overlay on CRT1\n",
		myclock);
       }
    }

    /* Determine if the Panel Link scaler is active */
    pSiS->MiscFlags &= ~MISC_PANELLINKSCALER;
    if(pSiS->VBFlags & (CRT2_LCD | CRT1_LCDA)) {
       if(pSiS->VGAEngine == SIS_300_VGA) {
          if(pSiS->VBFlags & (VB_LVDS | VB_30xBDH)) {
	     inSISIDXREG(SISPART1,0x1e,tmpreg);
	     tmpreg &= 0x3f;
	     if(tmpreg) pSiS->MiscFlags |= MISC_PANELLINKSCALER;
	  }
       } else {
          if(pSiS->VBFlags & (VB_LVDS | VB_30xBDH | CRT1_LCDA)) {
	     inSISIDXREG(SISPART1,0x35,tmpreg);
	     tmpreg &= 0x04;
	     if(!tmpreg) pSiS->MiscFlags |= MISC_PANELLINKSCALER;
	  }
       }
    }

    /* Determine if our very special TV mode is active */
    pSiS->MiscFlags &= ~MISC_TVNTSC1024;
    if((pSiS->VBFlags & VB_SISBRIDGE) && (pSiS->VBFlags & CRT2_TV) && (!(pSiS->VBFlags & TV_HIVISION))) {
       if( ((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR525I)) ||
           ((!(pSiS->VBFlags & TV_YPBPR)) && (pSiS->VBFlags & (TV_NTSC | TV_PALM))) ) {
          inSISIDXREG(SISCR,0x34,tmpreg);
	  tmpreg &= 0x7f;
	  if((tmpreg == 0x64) || (tmpreg == 0x4a) || (tmpreg == 0x38)) {
	     pSiS->MiscFlags |= MISC_TVNTSC1024;
	  }
       }
    }

#ifdef SISVRAMQ
    if(pSiS->VGAEngine == SIS_315_VGA) {
       int i;
       /* Re-Enable command queue */
       SiSEnableTurboQueue(pScrn);
       /* Get HWCursor register contents for backup */
       for(i = 0; i < 16; i++) {
          pSiS->HWCursorBackup[i] = MMIO_IN32(pSiS->IOBase, 0x8500 + (i << 2));
       }
       if(pSiS->sishw_ext.jChipType >= SIS_330) {
          /* Enable HWCursor protection (Y pos as trigger) */
          andSISIDXREG(SISCR, 0x5b, ~0x30);
       }
    }
#endif

    /* Reset XV gamma correction */
    if(pSiS->ResetXvGamma) {
       (pSiS->ResetXvGamma)(pScrn);
    }

    /*  Apply TV settings given by options
           Do this even in DualHeadMode:
	   - if this is called by SetModeCRT1, CRT2 mode has been reset by SetModeCRT1
	   - if this is called by SetModeCRT2, CRT2 mode has changed (duh!)
	   -> Hence, in both cases, the settings must be re-applied.
     */
    if(pSiS->VBFlags & CRT2_TV) {
       int val;
       if(pSiS->VBFlags & VB_CHRONTEL) {
          int mychtvlumabandwidthcvbs = pSiS->chtvlumabandwidthcvbs;
	  int mychtvlumabandwidthsvideo = pSiS->chtvlumabandwidthsvideo;
	  int mychtvlumaflickerfilter = pSiS->chtvlumaflickerfilter;
	  int mychtvchromabandwidth = pSiS->chtvchromabandwidth;
	  int mychtvchromaflickerfilter = pSiS->chtvchromaflickerfilter;
	  int mychtvcvbscolor = pSiS->chtvcvbscolor;
	  int mychtvtextenhance = pSiS->chtvtextenhance;
	  int mychtvcontrast = pSiS->chtvcontrast;
	  int mytvxpos = pSiS->tvxpos;
	  int mytvypos = pSiS->tvypos;
#ifdef SISDUALHEAD
	  if(pSiSEnt && pSiS->DualHeadMode) {
	     mychtvlumabandwidthcvbs = pSiSEnt->chtvlumabandwidthcvbs;
	     mychtvlumabandwidthsvideo = pSiSEnt->chtvlumabandwidthsvideo;
	     mychtvlumaflickerfilter = pSiSEnt->chtvlumaflickerfilter;
	     mychtvchromabandwidth = pSiSEnt->chtvchromabandwidth;
	     mychtvchromaflickerfilter = pSiSEnt->chtvchromaflickerfilter;
	     mychtvcvbscolor = pSiSEnt->chtvcvbscolor;
	     mychtvtextenhance = pSiSEnt->chtvtextenhance;
	     mychtvcontrast = pSiSEnt->chtvcontrast;
	     mytvxpos = pSiSEnt->tvxpos;
	     mytvypos = pSiSEnt->tvypos;
	  }
#endif	  
	  if((val = mychtvlumabandwidthcvbs) != -1) {
	     SiS_SetCHTVlumabandwidthcvbs(pScrn, val);
	  }
	  if((val = mychtvlumabandwidthsvideo) != -1) {
	     SiS_SetCHTVlumabandwidthsvideo(pScrn, val);
	  }
	  if((val = mychtvlumaflickerfilter) != -1) {
	     SiS_SetCHTVlumaflickerfilter(pScrn, val);
	  }
	  if((val = mychtvchromabandwidth) != -1) {
	     SiS_SetCHTVchromabandwidth(pScrn, val);      
	  }
	  if((val = mychtvchromaflickerfilter) != -1) {
	     SiS_SetCHTVchromaflickerfilter(pScrn, val);
	  }
	  if((val = mychtvcvbscolor) != -1) {
	     SiS_SetCHTVcvbscolor(pScrn, val);
	  }
	  if((val = mychtvtextenhance) != -1) {
	     SiS_SetCHTVtextenhance(pScrn, val);
	  }
	  if((val = mychtvcontrast) != -1) {
	     SiS_SetCHTVcontrast(pScrn, val);
	  }
	  /* Backup default TV position registers */
	  switch(pSiS->ChrontelType) {
	  case CHRONTEL_700x:
	     pSiS->tvx = SiS_GetCH700x(pSiS->SiS_Pr, 0x0a);
	     pSiS->tvx |= (((SiS_GetCH700x(pSiS->SiS_Pr, 0x08) & 0x02) >> 1) << 8);
	     pSiS->tvy = SiS_GetCH700x(pSiS->SiS_Pr, 0x0b);
	     pSiS->tvy |= ((SiS_GetCH700x(pSiS->SiS_Pr, 0x08) & 0x01) << 8);
#ifdef SISDUALHEAD
	     if(pSiSEnt) {
	        pSiSEnt->tvx = pSiS->tvx;
		pSiSEnt->tvy = pSiS->tvy;
	     }
#endif
	     break;
	  case CHRONTEL_701x:
	     /* Not supported by hardware */
	     break;
	  }
	  if((val = mytvxpos) != 0) {
	     SiS_SetTVxposoffset(pScrn, val);
	  }
	  if((val = mytvypos) != 0) {
	     SiS_SetTVyposoffset(pScrn, val);
	  }
       }
       if(pSiS->VBFlags & VB_301) {
          int mysistvedgeenhance = pSiS->sistvedgeenhance;
#ifdef SISDUALHEAD
          if(pSiSEnt && pSiS->DualHeadMode) {
	     mysistvedgeenhance = pSiSEnt->sistvedgeenhance;
	  }
#endif
          if((val = mysistvedgeenhance) != -1) {
	     SiS_SetSISTVedgeenhance(pScrn, val);
	  }
       }
       if(pSiS->VBFlags & VB_SISBRIDGE) {
          int mysistvantiflicker = pSiS->sistvantiflicker;
	  int mysistvsaturation = pSiS->sistvsaturation;
	  int mysistvcolcalibf = pSiS->sistvcolcalibf;
	  int mysistvcolcalibc = pSiS->sistvcolcalibc;
	  int mysistvcfilter = pSiS->sistvcfilter;
	  int mysistvyfilter = pSiS->sistvyfilter;
	  int mytvxpos = pSiS->tvxpos;
	  int mytvypos = pSiS->tvypos;
	  int mytvxscale = pSiS->tvxscale;
	  int mytvyscale = pSiS->tvyscale;
	  int i;
	  unsigned long cbase;
	  unsigned char ctemp;
#ifdef SISDUALHEAD
          if(pSiSEnt && pSiS->DualHeadMode) {
	     mysistvantiflicker = pSiSEnt->sistvantiflicker;
	     mysistvsaturation = pSiSEnt->sistvsaturation;
	     mysistvcolcalibf = pSiSEnt->sistvcolcalibf;
	     mysistvcolcalibc = pSiSEnt->sistvcolcalibc;
	     mysistvcfilter = pSiSEnt->sistvcfilter;
	     mysistvyfilter = pSiSEnt->sistvyfilter;
	     mytvxpos = pSiSEnt->tvxpos;
	     mytvypos = pSiSEnt->tvypos;
	     mytvxscale = pSiSEnt->tvxscale;
	     mytvyscale = pSiSEnt->tvyscale;
	  }
#endif
          /* Backup default TV position, scale and colcalib registers */
	  inSISIDXREG(SISPART2,0x1f,pSiS->p2_1f);
	  inSISIDXREG(SISPART2,0x20,pSiS->p2_20);
	  inSISIDXREG(SISPART2,0x2b,pSiS->p2_2b);
	  inSISIDXREG(SISPART2,0x42,pSiS->p2_42);
	  inSISIDXREG(SISPART2,0x43,pSiS->p2_43);
	  inSISIDXREG(SISPART2,0x01,pSiS->p2_01);
	  inSISIDXREG(SISPART2,0x02,pSiS->p2_02);
	  inSISIDXREG(SISPART2,0x44,pSiS->p2_44);
	  inSISIDXREG(SISPART2,0x45,pSiS->p2_45);
	  if(!(pSiS->VBFlags & VB_301)) {
	     inSISIDXREG(SISPART2,0x46,pSiS->p2_46);
	  } else {
	     pSiS->p2_46 = 0;
	  }
	  inSISIDXREG(SISPART2,0x0a,pSiS->p2_0a);
	  inSISIDXREG(SISPART2,0x31,cbase);
	  cbase = (cbase & 0x7f) << 8;
	  inSISIDXREG(SISPART2,0x32,ctemp);
	  cbase = (cbase | ctemp) << 8;
	  inSISIDXREG(SISPART2,0x33,ctemp);
	  cbase = (cbase | ctemp) << 8;
	  inSISIDXREG(SISPART2,0x34,ctemp);
	  pSiS->sistvccbase = (cbase | ctemp);
	  inSISIDXREG(SISPART2,0x35,pSiS->p2_35);
	  inSISIDXREG(SISPART2,0x36,pSiS->p2_36);
	  inSISIDXREG(SISPART2,0x37,pSiS->p2_37);
	  inSISIDXREG(SISPART2,0x38,pSiS->p2_38);
	  if(!(pSiS->VBFlags & VB_301)) {
	     inSISIDXREG(SISPART2,0x47,pSiS->p2_47);
	     inSISIDXREG(SISPART2,0x48,pSiS->p2_48);
	     inSISIDXREG(SISPART2,0x49,pSiS->p2_49);
	     inSISIDXREG(SISPART2,0x4a,pSiS->p2_4a);
	  }
	  inSISIDXREG(SISPART2,0x2f,pSiS->p2_2f);
	  inSISIDXREG(SISPART2,0x30,pSiS->p2_30);
	  for(i=0; i<9; i++) {
	     inSISIDXREG(SISPART1,SiSScalingP1Regs[i],pSiS->scalingp1[i]);
	  }
	  for(i=0; i<9; i++) {
	     inSISIDXREG(SISPART4,SiSScalingP4Regs[i],pSiS->scalingp4[i]);
	  }
	  if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
	     for(i=0; i<64; i++) {
	        inSISIDXREG(SISPART2,(0xc0 + i),pSiS->scalingp2[i]);
  	     }
	  }
#ifdef SISDUALHEAD
	  if(pSiSEnt) {
	     pSiSEnt->p2_1f = pSiS->p2_1f; pSiSEnt->p2_20 = pSiS->p2_20;
	     pSiSEnt->p2_42 = pSiS->p2_42; pSiSEnt->p2_43 = pSiS->p2_43;
	     pSiSEnt->p2_2b = pSiS->p2_2b;
	     pSiSEnt->p2_01 = pSiS->p2_01; pSiSEnt->p2_02 = pSiS->p2_02;
	     pSiSEnt->p2_44 = pSiS->p2_44; pSiSEnt->p2_45 = pSiS->p2_45;
	     pSiSEnt->p2_46 = pSiS->p2_46; pSiSEnt->p2_0a = pSiS->p2_0a;
	     pSiSEnt->sistvccbase = pSiS->sistvccbase;
	     pSiSEnt->p2_35 = pSiS->p2_35; pSiSEnt->p2_36 = pSiS->p2_36;
	     pSiSEnt->p2_37 = pSiS->p2_37; pSiSEnt->p2_38 = pSiS->p2_38;
	     pSiSEnt->p2_48 = pSiS->p2_48; pSiSEnt->p2_49 = pSiS->p2_49;
	     pSiSEnt->p2_4a = pSiS->p2_4a; pSiSEnt->p2_2f = pSiS->p2_2f;
	     pSiSEnt->p2_30 = pSiS->p2_30; pSiSEnt->p2_47 = pSiS->p2_47;
	     for(i=0; i<9; i++) {
	        pSiSEnt->scalingp1[i] = pSiS->scalingp1[i];
	     }
	     for(i=0; i<9; i++) {
	        pSiSEnt->scalingp4[i] = pSiS->scalingp4[i];
	     }
	     if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
	        for(i=0; i<64; i++) {
	           pSiSEnt->scalingp2[i] = pSiS->scalingp2[i];
  	        }
	     }
	  }
#endif
          if((val = mysistvantiflicker) != -1) {
	     SiS_SetSISTVantiflicker(pScrn, val);
	  }
	  if((val = mysistvsaturation) != -1) {
	     SiS_SetSISTVsaturation(pScrn, val);
	  }
	  if((val = mysistvcfilter) != -1) {
	     SiS_SetSISTVcfilter(pScrn, val);
	  }
	  if((val = mysistvyfilter) != 1) {
	     SiS_SetSISTVyfilter(pScrn, val);
	  }
	  if((val = mysistvcolcalibc) != 0) {
	     SiS_SetSISTVcolcalib(pScrn, val, TRUE);
	  }
	  if((val = mysistvcolcalibf) != 0) {
	     SiS_SetSISTVcolcalib(pScrn, val, FALSE);
	  }
	  if((val = mytvxpos) != 0) {
	     SiS_SetTVxposoffset(pScrn, val);
	  }
	  if((val = mytvypos) != 0) {
	     SiS_SetTVyposoffset(pScrn, val);
	  }
	  if((val = mytvxscale) != 0) {
	     SiS_SetTVxscale(pScrn, val);
	  }
	  if((val = mytvyscale) != 0) {
	     SiS_SetTVyscale(pScrn, val);
	  }
       }
    }

}

/* Post-set SiS6326 TV registers */
static void
SiS6326PostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char tmp;
    int val;

    if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    /* Backup default TV position registers */
    pSiS->tvx1 = SiS6326GetTVReg(pScrn,0x3a);
    pSiS->tvx1 |= ((SiS6326GetTVReg(pScrn,0x3c) & 0x0f) << 8);
    pSiS->tvx2 = SiS6326GetTVReg(pScrn,0x26);
    pSiS->tvx2 |= ((SiS6326GetTVReg(pScrn,0x27) & 0xf0) << 4);
    pSiS->tvx3 = SiS6326GetTVReg(pScrn,0x12);
    pSiS->tvx3 |= ((SiS6326GetTVReg(pScrn,0x13) & 0xC0) << 2);
    pSiS->tvy1 = SiS6326GetTVReg(pScrn,0x11);
    pSiS->tvy1 |= ((SiS6326GetTVReg(pScrn,0x13) & 0x30) << 4);
    
    /* Handle TVPosOffset options (BEFORE switching on TV) */
    if((val = pSiS->tvxpos) != 0) {
       SiS_SetTVxposoffset(pScrn, val);
    }
    if((val = pSiS->tvypos) != 0) {
       SiS_SetTVyposoffset(pScrn, val);
    }

    /* Switch on TV output. This is rather complicated, but
     * if we don't do it, TV output will flicker terribly.
     */
    if(pSiS->SiS6326Flags & SIS6326_TVON) {
       orSISIDXREG(SISSR, 0x01, 0x20);
       tmp = SiS6326GetTVReg(pScrn,0x00);
       tmp &= ~0x04;
       while(!(inSISREG(SISINPSTAT) & 0x08));    /* Wait while NOT vb */
       SiS6326SetTVReg(pScrn,0x00,tmp);
       for(val=0; val < 2; val++) {
         while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
         while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
       }
       SiS6326SetTVReg(pScrn, 0x00, sisReg->sis6326tv[0]);
       tmp = inSISREG(SISINPSTAT);
       outSISREG(SISAR, 0x20);
       tmp = inSISREG(SISINPSTAT);
       while(inSISREG(SISINPSTAT) & 0x01);
       while(!(inSISREG(SISINPSTAT) & 0x01));
       andSISIDXREG(SISSR, 0x01, ~0x20);
       for(val=0; val < 10; val++) {
         while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
         while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
       }
       andSISIDXREG(SISSR, 0x01, ~0x20);
    }

    tmp = SiS6326GetTVReg(pScrn,0x00);
    if(!(tmp & 0x04)) return;

    /* Apply TV settings given by options */
    if((val = pSiS->sistvantiflicker) != -1) {
       SiS_SetSIS6326TVantiflicker(pScrn, val);
    }
    if((val = pSiS->sis6326enableyfilter) != -1) {
       SiS_SetSIS6326TVenableyfilter(pScrn, val);
    }
    if((val = pSiS->sis6326yfilterstrong) != -1) {
       SiS_SetSIS6326TVyfilterstrong(pScrn, val);
    }

}

/* Check if video bridge is in slave mode */
BOOLEAN
SiSBridgeIsInSlaveMode(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char usScratchP1_00;

    if(!(pSiS->VBFlags & VB_VIDEOBRIDGE)) return FALSE;

    inSISIDXREG(SISPART1,0x00,usScratchP1_00);
    if( ((pSiS->VGAEngine == SIS_300_VGA) && (usScratchP1_00 & 0xa0) == 0x20) ||
        ((pSiS->VGAEngine == SIS_315_VGA) && (usScratchP1_00 & 0x50) == 0x10) ) {
	   return TRUE;
    } else {
           return FALSE;
    }
}

/* Build a list of the VESA modes the BIOS reports as valid */
static void
SiSBuildVesaModeList(ScrnInfoPtr pScrn, vbeInfoPtr pVbe, VbeInfoBlock *vbe)
{
    SISPtr pSiS = SISPTR(pScrn);
    int i = 0;

    while(vbe->VideoModePtr[i] != 0xffff) {
	sisModeInfoPtr m;
	VbeModeInfoBlock *mode;
	int id = vbe->VideoModePtr[i++];
	int bpp;

	if((mode = VBEGetModeInfo(pVbe, id)) == NULL)
	    continue;

	bpp = mode->BitsPerPixel;

	m = xnfcalloc(sizeof(sisModeInfoRec),1);
	m->width = mode->XResolution;
	m->height = mode->YResolution;
	m->bpp = bpp;
	m->n = id;
	m->next = pSiS->SISVESAModeList;

	xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      "BIOS supports VESA mode 0x%x: x:%i y:%i bpp:%i\n",
	       m->n, m->width, m->height, m->bpp);

	pSiS->SISVESAModeList = m;

	VBEFreeModeInfo(mode);
    }
}

/* Calc VESA mode from given resolution/depth */
static UShort
SiSCalcVESAModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    SISPtr pSiS = SISPTR(pScrn);
    sisModeInfoPtr m = pSiS->SISVESAModeList;
    UShort i = (pScrn->bitsPerPixel+7)/8 - 1;
    UShort ModeIndex = 0;
    
    while(m) {
	if(pScrn->bitsPerPixel == m->bpp &&
	   mode->HDisplay == m->width &&
	   mode->VDisplay == m->height)
	    return m->n;
	m = m->next;
    }

    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
             "No valid BIOS VESA mode found for %dx%dx%d; searching built-in table.\n",
             mode->HDisplay, mode->VDisplay, pScrn->bitsPerPixel);

    switch(mode->HDisplay) {
      case 320:
          if(mode->VDisplay == 200)
             ModeIndex = VESAModeIndex_320x200[i];
	  else if(mode->VDisplay == 240)
             ModeIndex = VESAModeIndex_320x240[i];
          break;
      case 400:
          if(mode->VDisplay == 300)
             ModeIndex = VESAModeIndex_400x300[i];
          break;
      case 512:
          if(mode->VDisplay == 384)
             ModeIndex = VESAModeIndex_512x384[i];
          break;
      case 640:
          if(mode->VDisplay == 480)
             ModeIndex = VESAModeIndex_640x480[i];
	  else if(mode->VDisplay == 400)
             ModeIndex = VESAModeIndex_640x400[i];
          break;
      case 800:
          if(mode->VDisplay == 600)
             ModeIndex = VESAModeIndex_800x600[i];
          break;
      case 1024:
          if(mode->VDisplay == 768)
             ModeIndex = VESAModeIndex_1024x768[i];
          break;
      case 1280:
          if(mode->VDisplay == 1024)
             ModeIndex = VESAModeIndex_1280x1024[i];
          break;
      case 1600:
          if(mode->VDisplay == 1200)
             ModeIndex = VESAModeIndex_1600x1200[i];
          break;
      case 1920:
          if(mode->VDisplay == 1440)
             ModeIndex = VESAModeIndex_1920x1440[i];
          break;
   }

   if(!ModeIndex) xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
        "No valid mode found for %dx%dx%d in built-in table either.\n",
	mode->HDisplay, mode->VDisplay, pScrn->bitsPerPixel);

   return(ModeIndex);
}

USHORT
SiS_CalcModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode, unsigned long VBFlags, BOOLEAN havecustommodes)
{
   SISPtr pSiS = SISPTR(pScrn);
   UShort i = (pSiS->CurrentLayout.bitsPerPixel+7)/8 - 1;

   if(!(VBFlags & CRT1_LCDA)) {
      if((havecustommodes) && (!(mode->type & M_T_DEFAULT))) {
         return 0xfe;
      }
   } else {
      if((mode->HDisplay > pSiS->LCDwidth) ||
         (mode->VDisplay > pSiS->LCDheight)) {
	 return 0;
      }
   }

   return(SiS_GetModeID(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay,
   			i, pSiS->FSTN, pSiS->LCDwidth, pSiS->LCDheight));
}

USHORT
SiS_CheckCalcModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode, unsigned long VBFlags, BOOLEAN havecustommodes)
{
   SISPtr pSiS = SISPTR(pScrn);
   UShort i = (pSiS->CurrentLayout.bitsPerPixel+7)/8 - 1;
   UShort ModeIndex = 0;
   int    j;

#ifdef TWDEBUG
   xf86DrvMsg(0, X_INFO, "Inside CheckCalcModeIndex (VBFlags %x, mode %dx%d)\n",
   	VBFlags,mode->HDisplay, mode->VDisplay);
#endif

   if(VBFlags & CRT2_LCD) {			/* CRT2 is LCD */

      if(pSiS->SiS_Pr->CP_HaveCustomData) {
         for(j=0; j<7; j++) {
            if((pSiS->SiS_Pr->CP_DataValid[j]) &&
               (mode->HDisplay == pSiS->SiS_Pr->CP_HDisplay[j]) &&
               (mode->VDisplay == pSiS->SiS_Pr->CP_VDisplay[j]) &&
               (mode->type & M_T_BUILTIN))
               return 0xfe;
	 }
      }

      if((pSiS->AddedPlasmaModes) && (mode->type & M_T_BUILTIN))
         return 0xfe;

      if((havecustommodes) &&
         (pSiS->LCDwidth) &&		/* = test if LCD present */
         (!(mode->type & M_T_DEFAULT)) &&
	 (!(mode->Flags & V_INTERLACE)))
         return 0xfe;

      if( ((mode->HDisplay <= pSiS->LCDwidth) &&
           (mode->VDisplay <= pSiS->LCDheight)) ||
	  ((pSiS->SiS_Pr->SiS_CustomT == CUT_PANEL848) &&
	   (((mode->HDisplay == 1360) && (mode->HDisplay == 768)) ||
	    ((mode->HDisplay == 1024) && (mode->HDisplay == 768)) ||
	    ((mode->HDisplay ==  800) && (mode->HDisplay == 600)))) ) {

         ModeIndex = SiS_GetModeID_LCD(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i,
	 		       pSiS->FSTN, pSiS->SiS_Pr->SiS_CustomT, pSiS->LCDwidth, pSiS->LCDheight);

      }

   } else if(VBFlags & CRT2_TV) {		/* CRT2 is TV */

      ModeIndex = SiS_GetModeID_TV(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i);

   } else if(VBFlags & CRT2_VGA) {		/* CRT2 is VGA2 */

      if((pSiS->AddedPlasmaModes) && (mode->type & M_T_BUILTIN))
	 return 0xfe;

      if((havecustommodes) &&
	 (!(mode->type & M_T_DEFAULT)) &&
	 (!(mode->Flags & V_INTERLACE)))
         return 0xfe;

      ModeIndex = SiS_GetModeID_VGA2(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i);

   } else {					/* CRT1 only, no CRT2 */

      ModeIndex = SiS_CalcModeIndex(pScrn, mode, VBFlags, havecustommodes);

   }

   return(ModeIndex);
}

/* Calculate the vertical refresh rate from a mode */
int
SiSCalcVRate(DisplayModePtr mode)
{
   float hsync, refresh = 0;

   if(mode->HSync > 0.0)
       	hsync = mode->HSync;
   else if(mode->HTotal > 0)
       	hsync = (float)mode->Clock / (float)mode->HTotal;
   else
       	hsync = 0.0;

   if(mode->VTotal > 0)
       	refresh = hsync * 1000.0 / mode->VTotal;

   if(mode->Flags & V_INTERLACE)
       	refresh *= 2.0;

   if(mode->Flags & V_DBLSCAN)
       	refresh /= 2.0;

   if(mode->VScan > 1)
        refresh /= mode->VScan;

   if(mode->VRefresh > 0.0)
    	refresh = mode->VRefresh;

   if(hsync == 0 || refresh == 0) return(0);

   return((int)(refresh));
}

/* Calculate CR33 (rate index) for CRT1.
 * Calculation is done using currentmode, therefore it is
 * recommended to set VertRefresh and HorizSync to correct
 * values in config file.
 */
unsigned char
SISSearchCRT1Rate(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
   SISPtr         pSiS = SISPTR(pScrn);
   int            i = 0;
   int            irefresh;
   unsigned short xres = mode->HDisplay;
   unsigned short yres = mode->VDisplay;
   unsigned char  index;
   BOOLEAN	  checksis730 = FALSE;

   irefresh = SiSCalcVRate(mode);
   if(!irefresh) {
      if(xres == 800 || xres == 1024 || xres == 1280) return 0x02;
      else return 0x01;
   }
   
   /* SiS730 has troubles on CRT2 if CRT1 is at 32bpp */
   if( (pSiS->sishw_ext.jChipType == SIS_730) && 
       (pSiS->VBFlags & VB_VIDEOBRIDGE) &&
       (pSiS->CurrentLayout.bitsPerPixel == 32) ) {
#ifdef SISDUALHEAD   
      if(pSiS->DualHeadMode) {
         if(pSiS->SecondHead) {
	    checksis730 = TRUE;
	 }
      } else
#endif      
      if((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_ENABLE) && (!pSiS->CRT1off)) {
         checksis730 = TRUE;
      }
   }   
   
#ifdef TWDEBUG
   xf86DrvMsg(0, X_INFO, "Debug: CalcVRate returned %d\n", irefresh);
#endif    

   /* We need the REAL refresh rate here */
   if(mode->Flags & V_INTERLACE)
       	irefresh /= 2;

   /* Do not multiply by 2 when DBLSCAN! */
   
#ifdef TWDEBUG 
   xf86DrvMsg(0, X_INFO, "Debug: Rate after correction = %d\n", irefresh);
#endif

   index = 0;
   while((sisx_vrate[i].idx != 0) && (sisx_vrate[i].xres <= xres)) {
	if((sisx_vrate[i].xres == xres) && (sisx_vrate[i].yres == yres)) {
	    if((checksis730 == FALSE) || (sisx_vrate[i].SiS730valid32bpp == TRUE)) {
	       if(sisx_vrate[i].refresh == irefresh) {
		   index = sisx_vrate[i].idx;
		   break;
	       } else if(sisx_vrate[i].refresh > irefresh) {
		   if((sisx_vrate[i].refresh - irefresh) <= 3) {
		      index = sisx_vrate[i].idx;
		   } else if( ((checksis730 == FALSE) || (sisx_vrate[i - 1].SiS730valid32bpp == TRUE)) && 
		              ((irefresh - sisx_vrate[i - 1].refresh) <=  2) &&
			      (sisx_vrate[i].idx != 1) ) {
		      index = sisx_vrate[i - 1].idx;
		   }
		   break;
	       } else if((irefresh - sisx_vrate[i].refresh) <= 2) {
	           index = sisx_vrate[i].idx;
		   break;
	       }
	    }
	}
	i++;
   }
   if(index > 0)
	return index;
   else {
        /* Default Rate index */
        if(xres == 800 || xres == 1024 || xres == 1280) return 0x02; 
   	else return 0x01;
   }
}

void
SISWaitRetraceCRT1(ScrnInfoPtr pScrn)
{
   SISPtr        pSiS = SISPTR(pScrn);
   int           watchdog;
   unsigned char temp;

   inSISIDXREG(SISCR,0x17,temp);
   if(!(temp & 0x80)) return;

   inSISIDXREG(SISSR,0x1f,temp);
   if(temp & 0xc0) return;

   watchdog = 65536;
   while((inSISREG(SISINPSTAT) & 0x08) && --watchdog);
   watchdog = 65536;
   while((!(inSISREG(SISINPSTAT) & 0x08)) && --watchdog);
}

void
SISWaitRetraceCRT2(ScrnInfoPtr pScrn)
{
   SISPtr        pSiS = SISPTR(pScrn);
   int           watchdog;
   unsigned char temp, reg;

   if(SiSBridgeIsInSlaveMode(pScrn)) {
      SISWaitRetraceCRT1(pScrn);
      return;
   }

   switch(pSiS->VGAEngine) {
   case SIS_300_VGA:
   	reg = 0x25;
	break;
   case SIS_315_VGA:
   	reg = 0x30;
	break;
   default:
        return;
   }

   watchdog = 65536;
   do {
   	inSISIDXREG(SISPART1, reg, temp);
	if(!(temp & 0x02)) break;
   } while(--watchdog);
   watchdog = 65536;
   do {
   	inSISIDXREG(SISPART1, reg, temp);
	if(temp & 0x02) break;
   } while(--watchdog);
}

static void
SISWaitVBRetrace(ScrnInfoPtr pScrn)
{
   SISPtr  pSiS = SISPTR(pScrn);

   if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
#ifdef SISDUALHEAD
      if(pSiS->DualHeadMode) {
   	 if(pSiS->SecondHead)
	    SISWaitRetraceCRT1(pScrn);
         else
	    SISWaitRetraceCRT2(pScrn);
      } else {
#endif
	 if(pSiS->VBFlags & DISPTYPE_DISP1) {
	    SISWaitRetraceCRT1(pScrn);
	 }
	 if(pSiS->VBFlags & DISPTYPE_DISP2) {
	    if(!(SiSBridgeIsInSlaveMode(pScrn))) {
	       SISWaitRetraceCRT2(pScrn);
	    }
	 }
#ifdef SISDUALHEAD
      }
#endif
   } else {
      SISWaitRetraceCRT1(pScrn);
   }
}

#define MODEID_OFF 0x449

unsigned char
SiS_GetSetModeID(ScrnInfoPtr pScrn, unsigned char id)
{
    return(SiS_GetSetBIOSScratch(pScrn, MODEID_OFF, id));
}

unsigned char
SiS_GetSetBIOSScratch(ScrnInfoPtr pScrn, USHORT offset, unsigned char value)
{
    unsigned char ret = 0;
#if (defined(i386) || defined(__i386) || defined(__i386__) || defined(__AMD64__))
    unsigned char *base;

    base = xf86MapVidMem(pScrn->scrnIndex, VIDMEM_MMIO, 0, 0x2000);
    if(!base) {
       SISErrorLog(pScrn, "(Could not map BIOS scratch area)\n");
       return 0;
    }

    ret = *(base + offset);

    /* value != 0xff means: set register */
    if(value != 0xff)
       *(base + offset) = value;

    xf86UnMapVidMem(pScrn->scrnIndex, base, 0x2000);
#endif
    return ret;
}

void
sisSaveUnlockExtRegisterLock(SISPtr pSiS, unsigned char *reg1, unsigned char *reg2)
{
    register unsigned char val;
    unsigned long mylockcalls;

    pSiS->lockcalls++;
    mylockcalls = pSiS->lockcalls;

    /* check if already unlocked */
    inSISIDXREG(SISSR, 0x05, val);
    if(val != 0xa1) {
       /* save State */
       if(reg1) *reg1 = val;
       /* unlock */
       outSISIDXREG(SISSR, 0x05, 0x86);
       inSISIDXREG(SISSR, 0x05, val);
       if(val != 0xA1) {
#ifdef TWDEBUG
	  unsigned char val1, val2;
	  int i;
#endif
          SISErrorLog(pSiS->pScrn,
               "Failed to unlock sr registers (%p, %lx, 0x%02x; %ld)\n",
	       (void *)pSiS, (unsigned long)pSiS->RelIO, val, mylockcalls);
#ifdef TWDEBUG
          for(i = 0; i <= 0x3f; i++) {
	  	inSISIDXREG(SISSR, i, val1);
		inSISIDXREG(0x3c4, i, val2);
		xf86DrvMsg(pSiS->pScrn->scrnIndex, X_INFO,
			"SR%02d: RelIO=0x%02x 0x3c4=0x%02x (%d)\n",
			i, val1, val2, mylockcalls);
	  }
#endif
          if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
	     /* Emergency measure: unlock at 0x3c4, and try to enable Relocated IO ports */
	     outSISIDXREG(0x3c4,0x05,0x86);
	     andSISIDXREG(0x3c4,0x33,~0x20);
	     outSISIDXREG(SISSR, 0x05, 0x86);
          }
       }
    }
    if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
       inSISIDXREG(SISCR, 0x80, val);
       if(val != 0xa1) {
          /* save State */
          if(reg2) *reg2 = val;
          outSISIDXREG(SISCR, 0x80, 0x86);
	  inSISIDXREG(SISCR, 0x80, val);
	  if(val != 0xA1) {
	     SISErrorLog(pSiS->pScrn,
	        "Failed to unlock cr registers (%p, %lx, 0x%02x)\n",
	       (void *)pSiS, (unsigned long)pSiS->RelIO, val);
	  }
       }
    }
}

void
sisRestoreExtRegisterLock(SISPtr pSiS, unsigned char reg1, unsigned char reg2)
{
    /* restore lock */
#ifndef UNLOCK_ALWAYS
    outSISIDXREG(SISSR, 0x05, reg1 == 0xA1 ? 0x86 : 0x00);
    if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
       outSISIDXREG(SISCR, 0x80, reg2 == 0xA1 ? 0x86 : 0x00);
    }
#endif
}

@


1.1
log
@Initial revision
@
text
@d1 1
d3 1
a3 1
 * Copyright 1998,1999 by Alan Hourihane, Wigan, England.
d5 1
a5 9
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Alan Hourihane not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Alan Hourihane makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
d7 10
a16 7
 * ALAN HOURIHANE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL ALAN HOURIHANE BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
d18 10
a27 5
 * Authors:  Alan Hourihane, alanh@@fairlite.demon.co.uk
 *           Mike Chapman <mike@@paranoia.com>, 
 *           Juanjo Santamarta <santamarta@@ctv.es>, 
 *           Mitani Hiroshi <hmitani@@drl.mei.co.jp> 
 *           David Thomas <davtom@@dream.org.uk>. 
d29 16
a44 1
 *  Fixes for 630 chipsets: Thomas Winischhofer.
a45 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_driver.c,v 1.78 2002/01/17 10:49:35 eich Exp $ */
a47 2
#include "xf1bpp.h"
#include "xf4bpp.h"
d51 1
d55 1
d69 1
a69 1

a71 1
#include "sis_bios.h"
d75 2
d81 1
d85 1
a85 1
#ifdef XvExtension
d94 1
d96 3
a98 45
/* mandatory functions */
static void SISIdentify(int flags);
static Bool SISProbe(DriverPtr drv, int flags);
static Bool SISPreInit(ScrnInfoPtr pScrn, int flags);
static Bool SISScreenInit(int Index, ScreenPtr pScreen, int argc,
                  char **argv);
static Bool SISEnterVT(int scrnIndex, int flags);
static void SISLeaveVT(int scrnIndex, int flags);
static Bool SISCloseScreen(int scrnIndex, ScreenPtr pScreen);
static Bool SISSaveScreen(ScreenPtr pScreen, int mode);
static Bool SISSwitchMode(int scrnIndex, DisplayModePtr mode, int flags);
static void SISAdjustFrame(int scrnIndex, int x, int y, int flags);

/* Optional functions */
static void SISFreeScreen(int scrnIndex, int flags);
static int  SISValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose,
                 int flags);

/* Internally used functions */
static Bool SISMapMem(ScrnInfoPtr pScrn);
static Bool SISUnmapMem(ScrnInfoPtr pScrn);
static void SISSave(ScrnInfoPtr pScrn);
static void SISRestore(ScrnInfoPtr pScrn);
static void SISVESARestore(ScrnInfoPtr pScrn);
static Bool SISModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode);
static void SISModifyModeInfo(DisplayModePtr mode);
static void SiSPreSetMode(ScrnInfoPtr pScrn, int LockAfterwards);
static void SiSPostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg, int LockAfterwards);
static Bool SiSSetVESAMode(ScrnInfoPtr pScrn, DisplayModePtr pMode);
static void SiSBuildVesaModeList(ScrnInfoPtr pScrn, vbeInfoPtr pVbe, VbeInfoBlock *vbe);
static UShort CalcVESAModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode);
static void SISBridgeRestore(ScrnInfoPtr pScrn);
unsigned char SISSearchCRT1Rate(DisplayModePtr mode);
static void SISVESASaveRestore(ScrnInfoPtr pScrn, vbeSaveRestoreFunction function);

void SiSOptions(ScrnInfoPtr pScrn);
const OptionInfoRec * SISAvailableOptions(int chipid, int busid);
void SiSSetup(ScrnInfoPtr pScrn);
void SISVGAPreInit(ScrnInfoPtr pScrn);
Bool SiSAccelInit(ScreenPtr pScreen);
Bool SiS300AccelInit(ScreenPtr pScreen);
Bool SiS530AccelInit(ScreenPtr pScreen);
Bool SiSHWCursorInit(ScreenPtr pScreen);
Bool SISDGAInit(ScreenPtr pScreen);
void SISInitVideo(ScreenPtr pScreen);
d100 17
a116 3

#ifdef  DEBUG
static void SiSDumpModeInfo(ScrnInfoPtr pScrn, DisplayModePtr mode);
a123 1
 
d144 5
a148 12
#if 0 
    { PCI_CHIP_SG86C201,    "SIS86c201" },
    { PCI_CHIP_SG86C202,    "SIS86c202" },
    { PCI_CHIP_SG86C205,    "SIS86c205" },
    { PCI_CHIP_SG86C215,    "SIS86c215" },
    { PCI_CHIP_SG86C225,    "SIS86c225" },
#endif
    { PCI_CHIP_SIS5597,     "SIS5597" },
    { PCI_CHIP_SIS530,      "SIS530" },
    { PCI_CHIP_SIS6326,     "SIS6326" },
    { PCI_CHIP_SIS300,      "SIS300" },
    { PCI_CHIP_SIS630,      "SIS630" },
d150 7
a160 6
#if 0
    { PCI_CHIP_SG86C201,    PCI_CHIP_SG86C201,  RES_SHARED_VGA },
    { PCI_CHIP_SG86C202,    PCI_CHIP_SG86C202,  RES_SHARED_VGA },
    { PCI_CHIP_SG86C205,    PCI_CHIP_SG86C205,  RES_SHARED_VGA },
    { PCI_CHIP_SG86C205,    PCI_CHIP_SG86C205,  RES_SHARED_VGA },
#endif
d167 7
a175 46
    

int sisReg32MMIO[]={0x8280,0x8284,0x8288,0x828C,0x8290,0x8294,0x8298,0x829C,
            0x82A0,0x82A4,0x82A8,0x82AC};
/* Engine Register for the 2nd Generation Graphics Engine */
int sis2Reg32MMIO[]={0x8200,0x8204,0x8208,0x820C,0x8210,0x8214,0x8218,0x821C,
            0x8220,0x8224,0x8228,0x822C,0x8230,0x8234,0x8238,0x823C,
             0x8240, 0x8300};

/* TW: The following was re-included because there are BIOSes out there that
 *     report incomplete mode lists. These are BIOS versions <2.01.2x
 *     NOTE: Mode numbers for 1280, 1600 and 1920 are unofficial but they work here!
 *     TW: VBE 3.0 on SiS630 does not support 24 fpp modes (only 32fpp when depth = 24);
 */
				       /*     8      16     24    32   */
static UShort  VESAModeIndex_640x480[]   = {0x100, 0x111, 0x112, 0x13a};
static UShort  VESAModeIndex_720x480[]   = {0x000, 0x000, 0x000, 0x000};
static UShort  VESAModeIndex_720x576[]   = {0x000, 0x000, 0x000, 0x000};
static UShort  VESAModeIndex_800x600[]   = {0x103, 0x114, 0x115, 0x13b};
static UShort  VESAModeIndex_1024x768[]  = {0x105, 0x117, 0x118, 0x13c};
static UShort  VESAModeIndex_1280x1024[] = {0x107, 0x11a, 0x11b, 0x13d};
static UShort  VESAModeIndex_1600x1200[] = {0x13e, 0x13f, 0x000, 0x140};
static UShort  VESAModeIndex_1920x1440[] = {0x141, 0x142, 0x000, 0x143};

static struct _sis_vrate {
    CARD16 idx;
    CARD16 xres;
    CARD16 yres;
    CARD16 refresh;
} sisx_vrate[] = {
    {1, 640, 480, 60},  {2, 640, 480, 72}, {3, 640, 480, 75},  {4, 640, 480, 85},
    {5, 640, 480, 100}, {6, 640, 480, 120}, {7, 640, 480, 160}, {8, 640, 480, 200},
    {1, 720, 480, 60}, {1, 720, 576, 50},
    {1, 800, 600, 56}, {2, 800, 600, 60}, {3, 800, 600, 72}, {4, 800, 600, 75},
    {5, 800, 600, 85}, {6, 800, 600, 100}, {7, 800, 600, 120}, {8, 800, 600, 160},
    {1, 1024, 768, 43}, {2, 1024, 768, 60}, {3, 1024, 768, 70}, {4, 1024, 768, 75},
    {5, 1024, 768, 85}, {6, 1024, 768, 100}, {7, 1024, 768, 120},
    {1, 1280, 1024, 43}, {2, 1280, 1024, 60}, {3, 1280, 1024, 75}, {4, 1280, 1024, 85},
    {1, 1600, 1200, 60}, {2, 1600, 1200, 65}, {3, 1600, 1200, 70}, {4, 1600, 1200, 75},
    {5, 1600, 1200, 85},
    {1, 1920, 1440, 60},
    {0, 0, 0, 0}
};


sisModeInfoPtr SISVesaModeList = NULL;
d181 1
d183 2
d198 1
a206 6
static const char *miscfbSymbols[] = {
    "xf1bppScreenInit",
    "xf4bppScreenInit",
    NULL
};

d228 1
d232 3
a234 3
static const char *i2cSymbols[] = {
    "xf86I2CBusInit",
    "xf86CreateI2CBusRec",
d239 1
d241 3
d246 9
d286 3
a292 1

d318 6
a323 6
    if (!setupDone) {
        setupDone = TRUE;
        xf86AddDriver(&SIS, module, 0);
        LoaderRefSymLists(vgahwSymbols, fbSymbols, i2cSymbols, xaaSymbols,
			  miscfbSymbols, shadowSymbols, ramdacSymbols,
			  vbeSymbols,
d325 1
a325 1
			  drmSymbols, driSymbols,
d327 3
a329 3
			  NULL);
        return (pointer)TRUE;
    } 
d331 1
a331 1
    if (errmaj) *errmaj = LDR_ONCEONLY;
d345 1
a345 2
    if (pScrn->driverPrivate != NULL)
        return TRUE;
d348 3
a350 1
    /* Initialise it */
d359 12
a370 2
    
    if (pSiS->pstate) xfree(pSiS->pstate);
d372 76
a447 1
    if (pSiS->pVbe) vbeFree(pSiS->pVbe);
d449 1
a449 1
    if (pScrn->driverPrivate == NULL)
d455 1
a455 1
static void 
d459 4
a462 4
    unsigned char extDDC_PCR;
    unsigned char crtc17 = 0;
    unsigned char seq1 = 0;
    int vgaIOBase = VGAHWPTR(pScrn)->IOBase;
d465 34
a498 1
                 "SISDisplayPowerManagementSet(%d)\n",PowerManagementMode);
d500 16
a515 21
    outb(vgaIOBase + 4, 0x17);
    crtc17 = inb(vgaIOBase + 5);
    /* enable access to extended sequencer registers */
    outw(VGA_SEQ_INDEX, 0x8605);
    outb(VGA_SEQ_INDEX, 0x11);
    extDDC_PCR = inb(VGA_SEQ_DATA);
    /* if not blanked obtain state of LCD blank flags set by BIOS */
    if (!pSiS->Blank)
	pSiS->LCDon = extDDC_PCR;
    /* erase LCD blank flags */
    extDDC_PCR &= ~0xC;
    
    switch (PowerManagementMode)
    {
        case DPMSModeOn:
            /* HSync: On, VSync: On */
            seq1 = 0x00 ;
	    /* don't just unblanking; use LCD state set by BIOS */
	    extDDC_PCR  |= (pSiS->LCDon & 0x0C);
	    pSiS->Blank = FALSE;
            crtc17 |= 0x80;
d517 15
a531 5
        case DPMSModeStandby:
            /* HSync: Off, VSync: On */
            seq1 = 0x20 ;
            extDDC_PCR |= 0x8;
	    pSiS->Blank = TRUE;
d533 15
a547 14
        case DPMSModeSuspend:
            /* HSync: On, VSync: Off */
            seq1 = 0x20 ;
            extDDC_PCR |= 0x8;
	    pSiS->Blank = TRUE;
            break;
        case DPMSModeOff:
            /* HSync: Off, VSync: Off */
            seq1 = 0x20 ;
            extDDC_PCR |= 0xC;
	    pSiS->Blank = TRUE;
            /* DPMSModeOff is not supported with ModeStandby | ModeSuspend  */
            /* need same as the generic VGA function */
            crtc17 &= ~0x80;
d549 108
d658 1
a658 10
    outw(VGA_SEQ_INDEX, 0x0100);    /* Synchronous Reset */
    outb(VGA_SEQ_INDEX, 0x01);  /* Select SEQ1 */
    seq1 |= inb(VGA_SEQ_DATA) & ~0x20;
    outb(VGA_SEQ_DATA, seq1);
    usleep(10000);
    outb(vgaIOBase + 4, 0x17);
    outb(vgaIOBase + 5, crtc17);
    outb(VGA_SEQ_INDEX, 0x11);
    outb(VGA_SEQ_DATA, extDDC_PCR);
    outw(VGA_SEQ_INDEX, 0x0300);    /* End Reset */
a660 1

d668 2
d671 1
a671 1
SIS1bppColorMap(ScrnInfoPtr pScrn)
d674 45
d720 12
a731 4
   outb(pSiS->RelIO+0x48, 0x00);
   outb(pSiS->RelIO+0x49, 0x00);
   outb(pSiS->RelIO+0x49, 0x00);
   outb(pSiS->RelIO+0x49, 0x00);
d733 9
a741 4
   outb(pSiS->RelIO+0x48, 0x3F);
   outb(pSiS->RelIO+0x49, 0x3F);
   outb(pSiS->RelIO+0x49, 0x3F);
   outb(pSiS->RelIO+0x49, 0x3F);
d748 1
a748 1
    int i;
d750 4
a753 4
    int *usedChips;
    int numDevSections;
    int numUsed;
    Bool foundScreen = FALSE;
a765 2
     * Since this test version still uses vgaHW, we'll only actually claim
     * one for now, and just print a message about the others.
d775 6
a780 7
    if ((numDevSections = xf86MatchDevice(SIS_DRIVER_NAME,
                      &devSections)) <= 0) {
        /*
         * There's no matching device section in the config file, so quit
         * now.
         */
        return FALSE;
a783 5
     * While we're VGA-dependent, can really only have one such instance, but
     * we'll ignore that.
     */

    /*
d793 6
a798 6
    if (xf86GetPciVideoInfo() == NULL) {
        /*
         * We won't let anything in the config file override finding no
         * PCI video cards at all.  This seems reasonable now, but we'll see.
         */
        return FALSE;
d802 2
a803 2
               SISChipsets, SISPciChipsets, devSections,
               numDevSections, drv, &usedChips);
d807 1
a807 2
    if (numUsed <= 0)
        return FALSE;
d809 1
a809 1
    if (flags & PROBE_DETECT)
d811 1
a811 1
    else for (i = 0; i < numUsed; i++) {
d813 3
d820 3
a822 3
        if ((pScrn = xf86ConfigPciEntity(pScrn, 0, usedChips[i],
                                            SISPciChipsets, NULL, NULL,
                                            NULL, NULL, NULL))) {
d838 41
d884 4
a887 6
#if 0 /* xf86ValidateModes() takes care of this */
/*
 * GetAccelPitchValues -
 *
 * This function returns a list of display width (pitch) values that can
 * be used in accelerated mode.
d889 3
a891 2
static int
GetAccelPitchValues(ScrnInfoPtr pScrn)
d893 133
a1025 1
    return ((pScrn->displayWidth + 7) & ~7);
d1029 3
d1033 5
a1037 3
/* Mandatory */
static Bool
SISPreInit(ScrnInfoPtr pScrn, int flags)
d1039 48
a1086 9
    SISPtr pSiS;
    MessageType from;
    int vgaIOBase;
    unsigned char unlock;
    unsigned long int i;
    ClockRangePtr clockRanges;
    char *mod = NULL;
    const char *Sym = NULL;
    int pix24flags;
d1088 16
a1103 2
    vbeInfoPtr pVbe;
    VbeInfoBlock *vbe;
d1105 83
a1187 9
    if (flags & PROBE_DETECT) {
        if (xf86LoadSubModule(pScrn, "vbe")) {
        	int index = xf86GetEntityInfo(pScrn->entityList[0])->index;
        	if ((pVbe = VBEInit(NULL,index))) {
            	ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
        		vbeFree(pVbe);
        	}
    	}
    	return TRUE;
d1189 1
d1191 14
a1204 12
    /*
     * Note: This function is only called once at server startup, and
     * not at the start of each server generation.  This means that
     * only things that are persistent across server generations can
     * be initialised here.  xf86Screens[] is (pScrn is a pointer to one
     * of these).  Privates allocated using xf86AllocateScrnInfoPrivateIndex()  
     * are too, and should be used for data that must persist across
     * server generations.
     *
     * Per-generation data should be allocated with
     * AllocateScreenPrivateIndex() from the ScreenInit() function.
     */
d1206 2
a1207 3
    /* Check the number of entities, and fail if it isn't one. */
    if (pScrn->numEntities != 1)
        return FALSE;
d1209 14
a1222 3
    /* The vgahw module should be loaded here when needed */
    if (!xf86LoadSubModule(pScrn, "vgahw"))
        return FALSE;
d1224 22
a1245 1
    xf86LoaderReqSymLists(vgahwSymbols, NULL);
d1247 11
a1257 5
    /*
     * Allocate a vgaHWRec
     */
    if (!vgaHWGetHWRec(pScrn))
        return FALSE;
d1259 3
a1261 1
    VGAHWPTR(pScrn)->MapSize = 0x10000;     /* Standard 64k VGA window */
d1263 15
a1277 4
    if (!vgaHWMapMem(pScrn))
        return FALSE;
    vgaHWGetIOBase(VGAHWPTR(pScrn));
    vgaIOBase = VGAHWPTR(pScrn)->IOBase;
d1279 4
a1282 3
    /* Allocate the SISRec driverPrivate */
    if (!SISGetRec(pScrn)) {
        return FALSE;
d1284 1
a1284 2
    pSiS = SISPTR(pScrn);
    pSiS->pScrn = pScrn;
d1286 18
a1303 4
    /* Get the entity, and make sure it is PCI. */
    pSiS->pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
    if (pSiS->pEnt->location.type != BUS_PCI)
        return FALSE;
d1305 3
a1307 4
    /* Find the PCI info for this screen */
    pSiS->PciInfo = xf86GetPciInfoForEntity(pSiS->pEnt->index);
    pSiS->PciTag = pciTag(pSiS->PciInfo->bus, pSiS->PciInfo->device,
              pSiS->PciInfo->func);
d1309 45
a1353 11
    /*
     * XXX This could be refined if some VGA memory resources are not
     * decoded in operating mode.
     */
    {
        resRange vgamem[] = {   {ResShrMemBlock,0xA0000,0xAFFFF},
                                {ResShrMemBlock,0xB0000,0xB7FFF},
                                {ResShrMemBlock,0xB8000,0xBFFFF},
                            _END };
        xf86SetOperatingState(vgamem, pSiS->pEnt->index, ResUnusedOpr);
    }
d1355 2
a1356 4
    /* Operations for which memory access is required */
    pScrn->racMemFlags = RAC_FB | RAC_COLORMAP | RAC_CURSOR | RAC_VIEWPORT;
    /* Operations for which I/O access is required (XXX check this) */
    pScrn->racIoFlags = RAC_COLORMAP | RAC_CURSOR | RAC_VIEWPORT;
d1358 20
a1377 3
    /* The ramdac module should be loaded here when needed */
    if (!xf86LoadSubModule(pScrn, "ramdac"))
        return FALSE;
d1379 1
a1379 1
    xf86LoaderReqSymLists(ramdacSymbols, NULL);
d1381 1
a1381 2
    /* Set pScrn->monitor */
    pScrn->monitor = pScrn->confScreen->monitor;
d1383 2
a1384 3
    /* TW: ---EGBERT: Remove this before committing !*/
    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
           "Unofficial driver (16.01.02) by Thomas Winischhofer\n");
d1386 15
a1400 11
    /*
     * Set the Chipset and ChipRev, allowing config file entries to
     * override.
     */
    if (pSiS->pEnt->device->chipset && *pSiS->pEnt->device->chipset)  {
        pScrn->chipset = pSiS->pEnt->device->chipset;
        pSiS->Chipset = xf86StringToToken(SISChipsets, pScrn->chipset);
        from = X_CONFIG;
    } else if (pSiS->pEnt->device->chipID >= 0) {
        pSiS->Chipset = pSiS->pEnt->device->chipID;
        pScrn->chipset = (char *)xf86TokenToString(SISChipsets, pSiS->Chipset);
d1402 27
a1428 14
        from = X_CONFIG;
        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
                                pSiS->Chipset);
    } else {
        from = X_PROBED;
        pSiS->Chipset = pSiS->PciInfo->chipType;
        pScrn->chipset = (char *)xf86TokenToString(SISChipsets, pSiS->Chipset);
    }
    if (pSiS->pEnt->device->chipRev >= 0) {
        pSiS->ChipRev = pSiS->pEnt->device->chipRev;
        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
                        pSiS->ChipRev);
    } else {
        pSiS->ChipRev = pSiS->PciInfo->chipRev;
d1430 72
d1503 39
a1541 14
    /*
     * This shouldn't happen because such problems should be caught in
     * SISProbe(), but check it just in case.
     */
    if (pScrn->chipset == NULL) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                   "ChipID 0x%04X is not recognised\n", pSiS->Chipset);
        return FALSE;
    }
    if (pSiS->Chipset < 0) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                   "Chipset \"%s\" is not recognised\n", pScrn->chipset);
        return FALSE;
    }
d1543 1
a1544 19
    /*
     * The first thing we should figure out is the depth, bpp, etc.
     * Our default depth is 8, so pass it to the helper function.
     * Our preference for depth 24 is 24bpp, so tell it that too.
     */
    switch (pSiS->Chipset) {
    case PCI_CHIP_SIS530:
    	pix24flags = Support32bppFb | Support24bppFb |
                SupportConvert24to32 | SupportConvert32to24;
        break;
    case PCI_CHIP_SIS300:
    case PCI_CHIP_SIS630:
    case PCI_CHIP_SIS540:
    	pix24flags = Support32bppFb | SupportConvert24to32;
	break;
    default:
        pix24flags = Support24bppFb |
		SupportConvert32to24 | PreferConvert32to24;
	break;
d1547 8
a1554 2
    if (!xf86SetDepthBpp(pScrn, 8, 8, 8, pix24flags))
    	return FALSE;
d1556 6
a1561 14
    /* Check that the returned depth is one we support */
    switch (pScrn->depth) {
    case 8:
    case 15:
    case 16:
    case 24:
        /* OK */
        break;
    default:
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
               "Given depth (%d) is not supported by this driver\n",
               pScrn->depth);
        return FALSE;
    }
d1563 8
a1570 1
    xf86PrintDepthBpp(pScrn);
d1572 1
a1572 3
    /* Get the depth24 pixmap format */
    if (pScrn->depth == 24 && pix24bpp == 0)
        pix24bpp = xf86GetBppFromDepth(pScrn, 24);
d1574 1
a1574 7
    /*
     * This must happen after pScrn->display has been set because
     * xf86SetWeight references it.
     */
    if (pScrn->depth > 8) {
        /* The defaults are OK for us */
        rgb zeros = {0, 0, 0};
d1576 1
a1576 7
        if (!xf86SetWeight(pScrn, zeros, zeros)) {
            return FALSE;
        } else {
            /* XXX check that weight returned is supported */
                ;
        }
    }
d1578 3
a1580 10
    if (!xf86SetDefaultVisual(pScrn, -1)) {
        return FALSE;
    } else {
        /* We don't currently support DirectColor at > 8bpp */
        if (pScrn->depth > 8 && pScrn->defaultVisual != TrueColor) {
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Given default visual"
                        " (%s) is not supported at depth %d\n",
                        xf86GetVisualName(pScrn->defaultVisual), pScrn->depth);
            return FALSE;
        }
d1583 5
a1587 2
    /*
     * The new cmap layer needs this to be initialised.
d1590 3
a1592 2
    {
        Gamma zeros = {0.0, 0.0, 0.0};
d1594 119
a1712 3
        if (!xf86SetGamma(pScrn, zeros)) {
            return FALSE;
        }
d1715 16
a1730 6
    /* We use a programmable clock */
    pScrn->progClock = TRUE;

    /* Set the bits per RGB for 8bpp mode */
    if (pScrn->depth == 8) {
        pScrn->rgbBits = 6;
d1732 1
d1734 1
a1734 1
    pSiS->ddc1Read = SiSddc1Read;   /* this cap will be modified */
d1736 5
a1740 1
    from = X_DEFAULT;
d1742 15
a1756 2
    outb(VGA_SEQ_INDEX, 0x05); unlock = inb(VGA_SEQ_DATA);
    outw(VGA_SEQ_INDEX, 0x8605); /* Unlock registers */
d1758 20
a1777 4
    /* get VBIOS image */
    if (!(pSiS->BIOS=xcalloc(1, BIOS_SIZE)))  {
        ErrorF("Allocate memory fail !!\n");
        return FALSE;
d1779 24
a1802 4
    if (xf86ReadBIOS(BIOS_BASE, 0, pSiS->BIOS, BIOS_SIZE) != BIOS_SIZE)  {
        xfree(pSiS->BIOS);
        ErrorF("Read VBIOS image fail !!\n");
        return FALSE;
d1804 3
d1808 26
a1833 2
    SiSOptions(pScrn);
    SiSSetup(pScrn);
d1835 4
a1838 11
    from = X_PROBED;
    if (pSiS->pEnt->device->MemBase != 0) {
        /*
         * XXX Should check that the config file value matches one of the
         * PCI base address values.
         */
        pSiS->FbAddress = pSiS->pEnt->device->MemBase;
        from = X_CONFIG;
    } else {
        pSiS->FbAddress = pSiS->PciInfo->memBase[0] & 0xFFFFFFF0;
    }
d1840 1
a1840 2
    xf86DrvMsg(pScrn->scrnIndex, from, "Linear framebuffer at 0x%lX\n",
           (unsigned long)pSiS->FbAddress);
d1842 9
a1850 9
    if (pSiS->pEnt->device->IOBase != 0) {
        /*
         * XXX Should check that the config file value matches one of the
         * PCI base address values.
         */
        pSiS->IOAddress = pSiS->pEnt->device->IOBase;
        from = X_CONFIG;
    } else {
        pSiS->IOAddress = pSiS->PciInfo->memBase[1] & 0xFFFFFFF0;
d1852 3
d1856 4
a1859 3
    from = X_PROBED;
    xf86DrvMsg(pScrn->scrnIndex, from, "MMIO registers at 0x%lX\n",
           (unsigned long)pSiS->IOAddress);
d1861 1
a1861 3
    pSiS->RelIO = pSiS->PciInfo->ioBase[2] & 0xFFFC;
    xf86DrvMsg(pScrn->scrnIndex, from, "Relocate IO registers at 0x%lX\n",
           (unsigned long)pSiS->RelIO);
d1863 30
a1892 5
    /* Register the PCI-assigned resources. */
    if (xf86RegisterResources(pSiS->pEnt->index, NULL, ResExclusive)) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
               "xf86RegisterResources() found resource conflicts\n");
        return FALSE;
d1895 20
a1914 4
    from = X_PROBED;
    if (pSiS->pEnt->device->videoRam != 0)  {
        pScrn->videoRam = pSiS->pEnt->device->videoRam;
        from = X_CONFIG;
d1916 2
d1919 1
a1919 9
    if ((pSiS->Chipset == PCI_CHIP_SIS6326)
			&& (pScrn->videoRam >= 8192)
			&& (from != X_CONFIG)) {
        pScrn->videoRam = 4096;
        xf86DrvMsg(pScrn->scrnIndex, from, "Limiting VideoRAM to %d KB\n",
               pScrn->videoRam);
    } else
        xf86DrvMsg(pScrn->scrnIndex, from, "VideoRAM: %d KB\n",
               pScrn->videoRam);
d1921 9
a1929 24
    /*
     *  TW: New option: limit size of framebuffer memory for avoiding
     *  clash with DRI:
     *  Kernel framebuffer driver (sisfb) starts its memory heap
     *  at 8MB if it detects more VideoRAM than that(otherwise at 4MB).
     *  Therefore a setting of 8192 is recommended if DRI is
     *  to be used when there's more than 8MB video RAM available.
     *  This option can be left out if DRI is not to be used.
     *  Attention: TurboQueue and HWCursor should use videoRam value,
     *  not FbMapSize; these two are always located at the very top
     *  of the videoRAM. Both are already initialized by framebuffer
     *  driver, so they should not wander around while starting X.
     */

    pSiS->FbMapSize = pScrn->videoRam * 1024;
    /* TW: Touching FbMapSize doesn't work; now use maxxfbmem in accel*.c */

    if (pSiS->maxxfbmem) {
    	if (pSiS->maxxfbmem > pSiS->FbMapSize) {
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
            "Invalid MaxXFBMem setting. Using all VideoRAM for framebuffer\n");
	    pSiS->maxxfbmem = pSiS->FbMapSize;
	}
    } else pSiS->maxxfbmem = pSiS->FbMapSize;
d1931 9
a1939 44
    /* TW: Detect video bridge */
    SISVGAPreInit(pScrn);
    /* TW: Detect CRT2-LCD and LCD size */
    SISLCDPreInit(pScrn);
    /* TW: Detect CRT2-TV and PAL/NTSC mode */
    SISTVPreInit(pScrn);
    /* TW: Detect CRT2-VGA */
    SISCRT2PreInit(pScrn);
    /* TW: Eventually overrule detected CRT2 type */
    if (pSiS->ForceCRT2Type == CRT2_DEFAULT)
    {
        if (pSiS->VBFlags & CRT2_VGA)
           pSiS->ForceCRT2Type = CRT2_VGA;
        else if (pSiS->VBFlags & CRT2_LCD)
           pSiS->ForceCRT2Type = CRT2_LCD;
        else if (pSiS->VBFlags & CRT2_TV)
           pSiS->ForceCRT2Type = CRT2_TV;
    }
    switch (pSiS->ForceCRT2Type)
    {
    case CRT2_TV:
        pSiS->VBFlags = pSiS->VBFlags & ~(CRT2_LCD | CRT2_VGA);
        if (pSiS->VBFlags & VB_VIDEOBRIDGE)
            pSiS->VBFlags = pSiS->VBFlags | CRT2_TV;
        else
            pSiS->VBFlags = pSiS->VBFlags & ~(CRT2_TV);
        break;
     case CRT2_LCD:
        pSiS->VBFlags = pSiS->VBFlags & ~(CRT2_TV | CRT2_VGA);
        if (pSiS->VBFlags & VB_VIDEOBRIDGE)
            pSiS->VBFlags = pSiS->VBFlags | CRT2_LCD;
        else
            pSiS->VBFlags = pSiS->VBFlags & ~(CRT2_LCD);
        break;
     case CRT2_VGA:
        pSiS->VBFlags = pSiS->VBFlags & ~(CRT2_TV | CRT2_LCD);
        if (pSiS->VBFlags & VB_VIDEOBRIDGE)
            pSiS->VBFlags = pSiS->VBFlags | CRT2_VGA;
        else
            pSiS->VBFlags = pSiS->VBFlags & ~(CRT2_VGA);
        break;
      default:
        pSiS->VBFlags &= ~(CRT2_TV | CRT2_LCD | CRT2_VGA);
    }
d1941 9
a1949 7
    /* TW: Check if CRT1 used (or needed; this if no CRT2 detected) */
    if (pSiS->VBFlags & VB_VIDEOBRIDGE) {
        if (!(pSiS->VBFlags & (CRT2_VGA | CRT2_LCD | CRT2_TV)))
	    pSiS->CRT1off = 0;
    }
    else /* TW: no video bridge? Then we NEED CRT1! */
        pSiS->CRT1off = 0;
d1951 9
a1959 8
    /* TW: Determine CRT1<>CRT2 mode */
    if (pSiS->VBFlags & DISPTYPE_DISP2) {
        if (pSiS->CRT1off)	/* TW: CRT2 only */
	     pSiS->VBFlags |= VB_DISPMODE_SINGLE;
	else			/* TW: CRT1 and CRT2 - mirror image */
	     pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_CRT1);
    } else			/* TW: CRT1 only */
             pSiS->VBFlags |= (VB_DISPMODE_SINGLE | DISPTYPE_CRT1);
d1961 9
a1969 1
    SISDACPreInit(pScrn);
d1971 9
a1979 2
    /* Lock extended registers */
    outw(VGA_SEQ_INDEX, (unlock << 8) | 0x05);
d1981 20
a2000 4
    /* Set the min pixel clock */
    pSiS->MinClock = 16250; /* XXX Guess, need to check this */
    xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Min pixel clock is %d MHz\n",
                pSiS->MinClock / 1000);
d2002 7
a2008 27
    from = X_PROBED;
    /*
     * If the user has specified ramdac speed in the XF86Config
     * file, we respect that setting.
     */
    if (pSiS->pEnt->device->dacSpeeds[0]) {
        int speed = 0;

        switch (pScrn->bitsPerPixel) {
        case 8:
           speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP8];
           break;
        case 16:
           speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP16];
           break;
        case 24:
           speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP24];
           break;
        case 32:
           speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP32];
           break;
        }
        if (speed == 0)
            pSiS->MaxClock = pSiS->pEnt->device->dacSpeeds[0];
        else
            pSiS->MaxClock = speed;
        from = X_CONFIG;
d2010 1
a2010 2
    xf86DrvMsg(pScrn->scrnIndex, from, "Max pixel clock is %d MHz\n",
                pSiS->MaxClock / 1000);
d2012 5
a2016 11
    /*
     * Setup the ClockRanges, which describe what clock ranges are available,
     * and what sort of modes they can be used for.
     */
    clockRanges = xnfcalloc(sizeof(ClockRange), 1);
    clockRanges->next = NULL;
    clockRanges->minClock = pSiS->MinClock;
    clockRanges->maxClock = pSiS->MaxClock;
    clockRanges->clockIndex = -1;               /* programmable */
    clockRanges->interlaceAllowed = TRUE;
    clockRanges->doubleScanAllowed = TRUE;      /* XXX check this */
d2018 1
a2018 6
    /*
     * xf86ValidateModes will check that the mode HTotal and VTotal values
     * don't exceed the chipset's limit if pScrn->maxHValue and
     * pScrn->maxVValue are set.  Since our SISValidMode() already takes
     * care of this, we don't worry about setting them here.
     */
d2020 4
a2023 13
    /* Select valid modes from those available */
    /*
     * XXX Assuming min pitch 256, max 4096 ==> 8192
     * XXX Assuming min height 128, max 4096
     */
    i = xf86ValidateModes(pScrn, pScrn->monitor->Modes,
                      pScrn->display->modes, clockRanges,
                      NULL, 256, 8192,
                      pScrn->bitsPerPixel * 8, 128, 4096,
                      pScrn->display->virtualX,
                      pScrn->display->virtualY,
                      pSiS->maxxfbmem,
                      LOOKUP_BEST_REFRESH);
d2025 8
a2032 4
    if (i == -1) {
        SISFreeRec(pScrn);
        return FALSE;
    }
d2034 5
a2038 2
    /* Prune the modes marked as invalid */
    xf86PruneDriverModes(pScrn);
d2040 6
a2045 5
    if (i == 0 || pScrn->modes == NULL) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes found\n");
        SISFreeRec(pScrn);
        return FALSE;
    }
d2047 6
a2052 1
    xf86SetCrtcForModes(pScrn, INTERLACE_HALVE_V);
d2054 1
a2054 2
    /* Set the current mode to the first in the list */
    pScrn->currentMode = pScrn->modes;
d2056 1
a2056 2
    /* Print the list of modes being used */
    xf86PrintModes(pScrn);
d2058 5
a2062 2
    /* Set display resolution */
    xf86SetDpi(pScrn, 0, 0);
d2064 1
a2064 17
    /* Load bpp-specific modules */
    switch (pScrn->bitsPerPixel) {
    case 1:
        mod = "xf1bpp";
        Sym = "xf1bppScreenInit";
        break;
    case 4:
        mod = "xf4bpp";
        Sym = "xf4bppScreenInit";
        break;
    case 8:
    case 16:
    case 24:
    case 32:
        mod = "fb";
	break;
    }
d2066 2
a2067 4
    if (mod && xf86LoadSubModule(pScrn, mod) == NULL) {
        SISFreeRec(pScrn);
        return FALSE;
    }
d2069 3
a2071 7
    if (mod) {
	if (Sym) {
	    xf86LoaderReqSymbols(Sym, NULL);
	} else {
	    xf86LoaderReqSymLists(fbSymbols, NULL);
	}
    }
d2073 5
a2077 4
    if (!xf86LoadSubModule(pScrn, "i2c")) {
        SISFreeRec(pScrn);
        return FALSE;
    }
d2079 2
a2080 1
    xf86LoaderReqSymLists(i2cSymbols, NULL);
d2082 2
a2083 7
    /* Load XAA if needed */
    if (!pSiS->NoAccel) {
        xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Accel Enable\n");
        if (!xf86LoadSubModule(pScrn, "xaa")) {
            SISFreeRec(pScrn);
            return FALSE;
        }
a2084 1
        xf86LoaderReqSymLists(xaaSymbols, NULL);
d2087 1
a2087 8
    /* Load shadowfb if needed */
    if (pSiS->ShadowFB) {
        if (!xf86LoadSubModule(pScrn, "shadowfb")) {
            SISFreeRec(pScrn);
            return FALSE;
        }
        xf86LoaderReqSymLists(shadowSymbols, NULL);
    }
d2089 2
a2090 7
    /* Load DDC if needed */
    /* This gives us DDC1 - we should be able to get DDC2B using i2c */
    if (!xf86LoadSubModule(pScrn, "ddc")) {
        SISFreeRec(pScrn);
        return FALSE;
    }
    xf86LoaderReqSymLists(ddcSymbols, NULL);
d2092 20
a2111 5
/* TW: Now load and initialize VBE module. The default behavior
 *     for SiS630 with SiS301B, SiS302 or LVDS/CHRONTEL bridge
 *     is to use VESA for mode switching. This can be overruled
 *     with the option "VESA".
 */
d2113 6547
d8661 115
a8775 19
	Bool ret;
	pSiS->UseVESA=0;
	if (xf86LoadSubModule(pScrn, "vbe")) {
	    xf86LoaderReqSymLists(vbeSymbols, NULL);
	    if ((pSiS->pVbe = VBEInit(NULL,pSiS->pEnt->index))) {
		ret = xf86SetDDCproperties(pScrn,
				   xf86PrintEDID(vbeDoEDID(pSiS->pVbe,NULL)));
		if ( (pSiS->VESA == 1)
		    || (   (pSiS->VESA != 0)
			&& (pSiS->Chipset == PCI_CHIP_SIS630)
			&& (pSiS->VBFlags & (VB_301B|VB_302|VB_LVDS|VB_CHRONTEL))) ) {
		    vbe = VBEGetVBEInfo(pSiS->pVbe);
		    pSiS->vesamajor = (unsigned)(vbe->VESAVersion >> 8);
		    pSiS->vesaminor = vbe->VESAVersion & 0xff;
		    pSiS->vbeInfo = vbe;
		    SiSBuildVesaModeList(pScrn, pSiS->pVbe, vbe);
		    VBEFreeVBEInfo(vbe);
		    pSiS->UseVESA = 1;
		/* TW: from now, use VESA functions for mode switching */
d8777 157
d8936 582
a9517 8
	vbeFree(pSiS->pVbe);
	pSiS->pVbe = NULL;
    }
    
#if 0
    if (!ret && pSiS->ddc1Read)
        xf86SetDDCProperties(xf86PrintEDID(xf86DoEDID_DDC1(
             pScrn->scrnIndex,vgaHWddc1SetSpeed,pSiS->ddc1Read )));
d9520 12
a9531 1
    return TRUE;
d9534 6
d9541 21
a9561 3
/*
 * Map the framebuffer and MMIO memory.
 */
d9563 1
a9563 2
static Bool
SISMapMem(ScrnInfoPtr pScrn)
d9565 9
a9573 2
    SISPtr pSiS;
    int mmioFlags;
d9575 2
a9576 1
    pSiS = SISPTR(pScrn);
d9578 2
a9579 11
    /*
     * Map IO registers to virtual address space
     */
#if !defined(__alpha__)
    mmioFlags = VIDMEM_MMIO;
#else
    /*
     * For Alpha, we need to map SPARSE memory, since we need
     * byte/short access.
     */
    mmioFlags = VIDMEM_MMIO | VIDMEM_SPARSE;
a9580 4
    pSiS->IOBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags, 
                        pSiS->PciTag, pSiS->IOAddress, 0x10000);
    if (pSiS->IOBase == NULL)
        return FALSE;
d9582 13
a9594 7
#ifdef __alpha__
    /*
     * for Alpha, we need to map DENSE memory as well, for
     * setting CPUToScreenColorExpandBase.
     */
    pSiS->IOBaseDense = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_MMIO,
                    pSiS->PciTag, pSiS->IOAddress, 0x10000);
d9596 2
a9597 3
    if (pSiS->IOBaseDense == NULL)
        return FALSE;
#endif /* __alpha__ */
d9599 2
a9600 6
    pSiS->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
                         pSiS->PciTag,
                         (unsigned long)pSiS->FbAddress,
                         pSiS->FbMapSize);
    if (pSiS->FbBase == NULL)
        return FALSE;
d9602 5
a9606 1
    return TRUE;
d9609 21
d9631 5
a9635 3
/*
 * Unmap the framebuffer and MMIO memory.
 */
d9637 1
a9637 2
static Bool
SISUnmapMem(ScrnInfoPtr pScrn)
d9639 5
a9643 1
    SISPtr pSiS;
d9645 2
a9646 7
    pSiS = SISPTR(pScrn);

    /*
     * Unmap IO registers to virtual address space
     */ 
    xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->IOBase, 0x10000);
    pSiS->IOBase = NULL;
d9648 5
a9652 4
#ifdef __alpha__
    xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->IOBaseDense, 0x10000);
    pSiS->IOBaseDense = NULL;
#endif /* __alpha__ */
d9654 5
a9658 3
    xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->FbBase, pSiS->FbMapSize);
    pSiS->FbBase = NULL;
    return TRUE;
d9661 1
a9661 5
/*
 * This function saves the video state.
 */
static void
SISSave(ScrnInfoPtr pScrn)
d9663 9
a9671 3
    SISPtr pSiS;
    vgaRegPtr vgaReg;
    SISRegPtr sisReg;
d9673 3
a9675 3
    pSiS = SISPTR(pScrn);
    vgaReg = &VGAHWPTR(pScrn)->SavedReg;
    sisReg = &pSiS->SavedReg;
d9677 3
a9679 1
    vgaHWSave(pScrn, vgaReg, VGA_SR_ALL);
d9681 4
a9684 2
    (*pSiS->SiSSave)(pScrn, sisReg);
    if(pSiS->UseVESA) SISVESASaveRestore(pScrn, MODE_SAVE);
d9687 1
a9687 2
static void
SISVESASaveRestore(ScrnInfoPtr pScrn, vbeSaveRestoreFunction function)
d9689 8
a9696 1
    SISPtr pSiS;
d9698 3
a9700 1
    pSiS = SISPTR(pScrn);
d9702 5
a9706 24
    if (pSiS->vesamajor > 1
	&& (function == MODE_SAVE || pSiS->pstate)) {
	if (function == MODE_RESTORE)
	    memcpy(pSiS->state, pSiS->pstate, pSiS->stateSize);
	ErrorF("VBESaveRestore\n");
	if ((VBESaveRestore(pSiS->pVbe,function,
				     (pointer)&pSiS->state,
			    &pSiS->stateSize,&pSiS->statePage))) {
	    if (function == MODE_SAVE) {
		/* don't rely on the memory not being touched */
		if (pSiS->pstate == NULL)
		    pSiS->pstate = xalloc(pSiS->stateSize);
		memcpy(pSiS->pstate, pSiS->state, pSiS->stateSize);
	    }
	    ErrorF("VBESaveRestore done with success\n");
	    return;
	}
	ErrorF("VBESaveRestore done\n");
    } else {
	if (function == MODE_SAVE)
	    (void)VBEGetVBEMode(pSiS->pVbe, &pSiS->stateMode);
	else
	    VBESetVBEMode(pSiS->pVbe, pSiS->stateMode, NULL);
    }
d9709 8
a9716 6
/*
 * Initialise a new mode.  This is currently still using the old
 * "initialise struct, restore/write struct to HW" model.  That could
 * be changed.
 * TW: Why?
 */
d9718 3
a9720 7
static Bool
SISModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    vgaHWPtr hwp = VGAHWPTR(pScrn);
    vgaRegPtr vgaReg;
    SISPtr pSiS = SISPTR(pScrn);
    SISRegPtr sisReg;
d9722 19
a9740 3
    vgaHWUnlock(hwp);
	
    SISModifyModeInfo(mode);
d9742 3
a9744 4
    /* TW: Initialize SiS Port Reg definitions for externally used
     *     sis_bios functions.
     */
    SiSRegInit(pSiS->RelIO+0x30);
d9746 3
a9748 35
    if (pSiS->UseVESA) {  /* With VESA: */
	/*
	 * This order is required:
	 * The video bridge needs to be adjusted before the
	 * BIOS is run as the BIOS sets up CRT2 according to
	 * these register settings.
	 * After the BIOS is run, the bridges and turboqueue
	 * registers need to be readjusted as the BIOS may
	 * very probably have messed them up.
	 */
	SiSPreSetMode(pScrn, 1);
        /* TW: mode was pScrn->currentMode - VidModeExt did not work! */
 	if (!SiSSetVESAMode(pScrn, mode))
	    return FALSE;
	SiSPreSetMode(pScrn, 1);
	SiSPostSetMode(pScrn, &pSiS->ModeReg, 1);

 	/* Prepare the register contents */
	if (!(*pSiS->ModeInit)(pScrn, mode))
	    return FALSE;

	pScrn->vtSema = TRUE;

	/* Program the registers */
	vgaHWProtect(pScrn, TRUE);
	(*pSiS->SiSRestore)(pScrn, &pSiS->ModeReg);
	vgaHWProtect(pScrn, FALSE);
	PDEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
 			  "HDisplay: %d, VDisplay: %d  \n",
 			  mode->HDisplay, mode->VDisplay));
 
    } else { /* Without VESA: */
    	/* Initialise the ModeReg values */
    	if (!vgaHWInit(pScrn, mode))
	        return FALSE;
d9750 2
a9751 2
	if (!(*pSiS->ModeInit)(pScrn, mode))
	    return FALSE;
d9753 15
a9767 1
	pScrn->vtSema = TRUE;
d9769 5
a9773 26
	PDEBUG(xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			  "HDisplay: %d, VDisplay: %d  \n",
			  mode->HDisplay, mode->VDisplay));

	/* Program the registers */
	vgaHWProtect(pScrn, TRUE);
	vgaReg = &hwp->ModeReg;
	sisReg = &pSiS->ModeReg;

    	vgaReg->Attribute[0x10] = 0x01;
    	if (pScrn->bitsPerPixel > 8)
	    vgaReg->Graphics[0x05] = 0x00;

    	vgaHWRestore(pScrn, vgaReg, VGA_SR_MODE); 

	if ( (pSiS->Chipset == PCI_CHIP_SIS300) ||
	     (pSiS->Chipset == PCI_CHIP_SIS630) ||
	     (pSiS->Chipset == PCI_CHIP_SIS540) ) {
	    SiSPreSetMode(pScrn, 0);
	    if (!SiSBIOSSetMode(pScrn, mode))
		return FALSE;
	}
	else (*pSiS->SiSRestore)(pScrn, sisReg);
	
	vgaHWProtect(pScrn, FALSE);
    }
d9775 7
a9781 6
/* Reserved for debug
 *
    SiSDumpModeInfo(pScrn, mode);
 *
 */
    return TRUE;
d9784 1
a9784 2
static Bool
SiSSetVESAMode(ScrnInfoPtr pScrn, DisplayModePtr pMode)
d9786 9
a9794 2
    SISPtr pSiS;
    int mode;
d9796 3
a9798 1
    pSiS = SISPTR(pScrn);
d9800 3
a9802 2
    if (!(mode = CalcVESAModeIndex(pScrn, pMode))) return FALSE;
    ErrorF("mode: %x\n",mode);
d9804 2
a9805 2
    mode |= 1 << 15;			/* TW: Don't clear framebuffer */
    mode |= 1 << 14;   			/* TW: always use linear adressing */
d9807 7
a9813 5
    if (VBESetVBEMode(pSiS->pVbe, mode, NULL) == FALSE) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Setting mode 0x%x failed\n",
	             mode & 0x0fff);
	    return (FALSE);
    }
d9815 2
a9816 2
    if (pMode->HDisplay != pScrn->virtualX)
	VBESetLogicalScanline(pSiS->pVbe, pScrn->virtualX);
d9818 3
a9820 2
    xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "Setting mode 0x%x succeeded\n",
	       mode & 0x0fff);
d9822 5
a9826 1
    return (TRUE);
d9829 1
a9829 6

/*
 * Restore the initial (text) mode.
 */
static void
SISRestore(ScrnInfoPtr pScrn)
d9831 6
a9836 4
    vgaHWPtr hwp;
    vgaRegPtr vgaReg;
    SISPtr pSiS;
    SISRegPtr sisReg;
d9838 4
a9841 4
    hwp = VGAHWPTR(pScrn);
    pSiS = SISPTR(pScrn);
    vgaReg = &hwp->SavedReg;
    sisReg = &pSiS->SavedReg;
d9843 17
a9859 1
    vgaHWProtect(pScrn, TRUE);
d9861 3
a9863 1
    (*pSiS->SiSRestore)(pScrn, sisReg);
d9865 96
a9960 3
    vgaHWRestore(pScrn, vgaReg, VGA_SR_ALL);

    vgaHWProtect(pScrn, FALSE);
d9963 1
a9963 2
static void
SISVESARestore(ScrnInfoPtr pScrn)
d9966 2
d9969 5
a9973 1
   if(pSiS->UseVESA) SISVESASaveRestore(pScrn, MODE_RESTORE);
d9976 1
a9976 3
/* TW: Restore bridge output registers - to be called BEFORE VESARestore */
static void
SISBridgeRestore(ScrnInfoPtr pScrn)
d9978 4
a9981 1
    SISPtr pSiS = SISPTR(pScrn);
d9983 1
a9983 3
    if ( (pSiS->Chipset == PCI_CHIP_SIS300) ||
         (pSiS->Chipset == PCI_CHIP_SIS630) ||
         (pSiS->Chipset == PCI_CHIP_SIS540) ) {
d9985 13
a9997 2
		SiSRestoreBridge(pScrn, &pSiS->SavedReg);
    }
d10000 1
a10000 4
/* Mandatory
 * This gets called at the start of each server generation */
static Bool
SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
d10002 18
a10019 10
    /* The vgaHW references will disappear one day */
    ScrnInfoPtr pScrn;
    vgaHWPtr hwp;
    SISPtr pSiS;
    int ret;
    int init_picture = 0;
    VisualPtr visual;
    unsigned long OnScreenSize;
    int height, width, displayWidth;
    unsigned char *FBStart;
d10021 4
a10024 4
    /*
     * First get the ScrnInfoRec
     */
    pScrn = xf86Screens[pScreen->myNum];
d10026 2
a10027 1
    hwp = VGAHWPTR(pScrn);
d10029 14
a10042 1
    hwp->MapSize = 0x10000;         /* Standard 64k VGA window */
d10044 21
a10064 1
    pSiS = SISPTR(pScrn);
d10066 24
a10089 2
    if (pSiS->UseVESA)
	pSiS->pVbe = VBEInit(NULL,pSiS->pEnt->index);
d10091 32
a10122 11
    /* Map the VGA memory and get the VGA IO base */
    if (!vgaHWMapMem(pScrn))
        return FALSE;
    vgaHWGetIOBase(hwp);

    /* Map the SIS memory and MMIO areas */
    if (!SISMapMem(pScrn))
        return FALSE;

    /* Save the current state */
    SISSave(pScrn);
d10124 3
a10126 3
    /* Initialise the first mode */
    if (!SISModeInit(pScrn, pScrn->currentMode))
        return FALSE;
d10128 4
a10131 7
    /* Clear frame buffer */
    OnScreenSize = pScrn->displayWidth * pScrn->currentMode->VDisplay * (pScrn->bitsPerPixel / 8);
    memset(pSiS->FbBase, 0, OnScreenSize);

    /* Darken the screen for aesthetic reasons and set the viewport */
    SISSaveScreen(pScreen, SCREEN_SAVER_ON);
    SISAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
d10133 1
a10133 11
    /*
     * The next step is to setup the screen's visuals, and initialise the
     * framebuffer code.  In cases where the framebuffer's default
     * choices for things like visual layouts and bits per RGB are OK,
     * this may be as simple as calling the framebuffer's ScreenInit()
     * function.  If not, the visuals will need to be setup before calling
     * a fb ScreenInit() function and fixed up after.
     *
     * For most PC hardware at depths >= 8, the defaults that cfb uses
     * are not appropriate.  In this driver, we fixup the visuals after.
     */
d10135 1
a10135 4
    /*
     * Reset visual list.
     */
    miClearVisualTypes();
d10137 1
d10139 17
a10155 1
    /* Setup the visuals we support. */
d10157 1
a10157 4
    /*
     * For bpp > 8, the default visuals are not acceptable because we only
     * support TrueColor and not DirectColor.
     */
d10159 1
a10159 11
    if (pScrn->bitsPerPixel > 8) {
        if (!miSetVisualTypes(pScrn->depth, TrueColorMask, pScrn->rgbBits,
                              pScrn->defaultVisual))
	    return FALSE;
	
    } else {
        if (!miSetVisualTypes(pScrn->depth, 
                              miGetDefaultVisualMask(pScrn->depth),
                              pScrn->rgbBits, pScrn->defaultVisual))
		return FALSE;
    }
d10161 2
a10162 3
    width = pScrn->virtualX;
    height = pScrn->virtualY;
    displayWidth = pScrn->displayWidth;
d10164 14
a10177 4
    if (pSiS->Rotate) {
        height = pScrn->virtualX;
        width = pScrn->virtualY;
    }
d10179 67
a10245 9
    if (pSiS->ShadowFB) {
        pSiS->ShadowPitch = BitmapBytePad(pScrn->bitsPerPixel * width);
        pSiS->ShadowPtr = xalloc(pSiS->ShadowPitch * height);
        displayWidth = pSiS->ShadowPitch / (pScrn->bitsPerPixel >> 3);
        FBStart = pSiS->ShadowPtr;
    } else {
        pSiS->ShadowPtr = NULL;
        FBStart = pSiS->FbBase;
    }
d10247 5
a10251 5
    if (!miSetPixmapDepths())
	return FALSE;
    
    {
        static int GlobalHWQueueLength = 0;
d10253 6
a10258 2
        pSiS->cmdQueueLenPtr = &(GlobalHWQueueLength);
    }
d10260 5
a10264 3
#ifdef XF86DRI
    pSiS->directRenderingEnabled = SISDRIScreenInit(pScreen);
    /* Force the initialization of the context */
d10267 3
a10269 4
    /*
     * Call the framebuffer layer's ScreenInit function, and fill in other
     * pScreen fields.
     */
d10271 4
a10274 18
    switch (pScrn->bitsPerPixel) {
    case 1:
        ret = xf1bppScreenInit(pScreen, FBStart, width,
                        height, pScrn->xDpi, pScrn->yDpi, 
                        displayWidth);
        break;
    case 4:
        ret = xf4bppScreenInit(pScreen, FBStart, width,
                        height, pScrn->xDpi, pScrn->yDpi, 
                        displayWidth);
        break;
    case 8:
    case 16:
    case 24:
    case 32:
        ret = fbScreenInit(pScreen, FBStart, width,
                        height, pScrn->xDpi, pScrn->yDpi,
                        displayWidth, pScrn->bitsPerPixel);
d10276 1
a10276 14
	init_picture = 1;
        break;
    default:
        xf86DrvMsg(scrnIndex, X_ERROR,
               "Internal error: invalid bpp (%d) in SISScrnInit\n",
               pScrn->bitsPerPixel);
            ret = FALSE;
        break;
    }
    if (!ret)
    {
        ErrorF ("SetMode Error@@!\n");
        return FALSE;
    }
d10278 1
a10278 16
    if (pScrn->bitsPerPixel > 8) {
        /* Fixup RGB ordering */
        visual = pScreen->visuals + pScreen->numVisuals;
        while (--visual >= pScreen->visuals) {
            if ((visual->class | DynamicClass) == DirectColor) {
                visual->offsetRed = pScrn->offset.red;
                visual->offsetGreen = pScrn->offset.green;
                visual->offsetBlue = pScrn->offset.blue;
                visual->redMask = pScrn->mask.red;
                visual->greenMask = pScrn->mask.green;
                visual->blueMask = pScrn->mask.blue;
            }
        }
    } else if (pScrn->depth == 1) {
        SIS1bppColorMap(pScrn);
    }
d10280 1
a10280 6
    /* must be after RGB ordering fixed */
    if (init_picture)
        fbPictureInit(pScreen, 0, 0);
    if (!pSiS->ShadowFB) /* hardware cursor needs to wrap this layer */
        SISDGAInit(pScreen);
    xf86SetBlackWhitePixels(pScreen);
d10282 17
a10298 13
    if (!pSiS->NoAccel) {
        if ( pSiS->Chipset == PCI_CHIP_SIS300 ||
             pSiS->Chipset == PCI_CHIP_SIS630 ||
             pSiS->Chipset == PCI_CHIP_SIS540)
            SiS300AccelInit(pScreen);
        else if (pSiS->Chipset == PCI_CHIP_SIS530)
            SiS530AccelInit(pScreen);
        else
            SiSAccelInit(pScreen);
    }
    miInitializeBackingStore(pScreen);
    xf86SetBackingStore(pScreen);
    xf86SetSilkenMouse(pScreen);
d10300 1
a10300 2
    /* Initialise cursor functions */
    miDCInitialize (pScreen, xf86GetPointerScreenFuncs());
d10302 69
a10370 2
    if (pSiS->HWCursor)
        SiSHWCursorInit(pScreen);
d10372 5
a10376 3
    /* Initialise default colourmap */
    if (!miCreateDefColormap(pScreen))
        return FALSE;
d10378 6
a10383 4
/*  marked by archer for adding VB palette 
     if (!vgaHWHandleColormaps(pScreen))
        return FALSE;
*/
d10385 6
a10390 3
    if (!xf86HandleColormaps(pScreen, 256, 8, SISLoadPalette, NULL,
                    CMAP_RELOAD_ON_MODE_SWITCH))
        return FALSE;
d10392 3
a10394 2
    if(pSiS->ShadowFB) {
    RefreshAreaFuncPtr refreshArea = SISRefreshArea;
d10396 4
a10399 5
    if(pSiS->Rotate) {
        if (!pSiS->PointerMoved) {
        pSiS->PointerMoved = pScrn->PointerMoved;
        pScrn->PointerMoved = SISPointerMoved;
        }
d10401 1
a10401 7
       switch(pScrn->bitsPerPixel) {
       case 8:  refreshArea = SISRefreshArea8;  break;
       case 16: refreshArea = SISRefreshArea16; break;
       case 24: refreshArea = SISRefreshArea24; break;
       case 32: refreshArea = SISRefreshArea32; break;
       }
    }
d10403 1
a10403 4
    ShadowFBInit(pScreen, refreshArea);
    }
    
    xf86DPMSInit(pScreen, (DPMSSetProcPtr)SISDisplayPowerManagementSet, 0);
d10405 1
a10405 8
#ifdef XvExtension
	if (!pSiS->NoXvideo) {
        /* HW Xv for SiS630 */
        if (pSiS->Chipset == PCI_CHIP_SIS630) {
            xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using SiS630 HW Xv\n" );
            SISInitVideo(pScreen);
        } 
        else { /* generic Xv */
d10407 2
a10408 2
            XF86VideoAdaptorPtr *ptr;
            int n;
d10410 9
a10418 7
            n = xf86XVListGenericAdaptors(pScrn, &ptr);
            if (n) {
                xf86XVScreenInit(pScreen, ptr, n);
                xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using generic Xv\n" );
            }
        }
    }
d10420 1
d10422 9
a10430 15
#ifdef XF86DRI
    if (pSiS->directRenderingEnabled) {
        /* Now that mi, drm and others have done their thing,
         * complete the DRI setup.
         */
        pSiS->directRenderingEnabled = SISDRIFinishScreenInit(pScreen);
    }
    if (pSiS->directRenderingEnabled) {
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "direct rendering enabled\n");
        /* TODO */
        /* SISSetLFBConfig(pSiS); */
    } else {
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "direct rendering disabled\n");
    }
#endif
d10432 12
a10443 8
    pSiS->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = SISCloseScreen;
    pScreen->SaveScreen = SISSaveScreen;

    /* Report any unused options (only for the first generation) */
    if (serverGeneration == 1) {
    xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
    }
d10445 1
a10445 2
    /* Turn on the screen now */
    SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
d10447 1
a10447 1
    return TRUE;
d10450 5
d10456 5
a10460 5
/* Usually mandatory */
Bool
SISSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
{
    return SISModeInit(xf86Screens[scrnIndex], mode);
d10463 1
a10463 7
/*
 * This function is used to initialize the Start Address - the first
 * displayed location in the video memory.
 */
/* Usually mandatory */
void
SISAdjustFrame(int scrnIndex, int x, int y, int flags)
d10465 5
a10469 6
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    SISPtr pSiS;
    vgaHWPtr hwp;
    int base = y * pScrn->displayWidth + x;
    int vgaIOBase;
    unsigned char SR5State, temp;
d10471 3
a10473 3
    hwp = VGAHWPTR(pScrn);
    pSiS = SISPTR(pScrn);
    vgaIOBase = VGAHWPTR(pScrn)->IOBase;
d10475 2
a10476 29
    if (pSiS->UseVESA) {
        /* TW: Let BIOS adjust frame if using VESA */
	VBESetDisplayStart(pSiS->pVbe, x, y, TRUE);
    }
    else {
    outb(VGA_SEQ_INDEX, 0x05); /* Unlock Registers */
    SR5State = inb(VGA_SEQ_DATA);
    outw(VGA_SEQ_INDEX, 0x8605);

    if (pScrn->bitsPerPixel < 8) {
        base = (y * pScrn->displayWidth + x + 3) >> 3;
    } else {
        base = y * pScrn->displayWidth + x ;
        /* calculate base bpp dep. */
        switch (pScrn->bitsPerPixel) {
          case 16:
            base >>= 1;
            break;
          case 24:
            base = ((base * 3)) >> 2;
            base -= base % 6;
            break;
          case 32:
            break;
          default:      /* 8bpp */
            base >>= 2;
            break;
        }
    }
d10478 4
a10481 29
    outw(vgaIOBase + 4, (base & 0x00FF00) | 0x0C);
    outw(vgaIOBase + 4, ((base & 0x00FF) << 8) | 0x0D);
    switch (pSiS->Chipset)  {
        case PCI_CHIP_SIS300:
        case PCI_CHIP_SIS630:
        case PCI_CHIP_SIS540:
            outb(VGA_SEQ_INDEX, 0x0D);
            temp = (base & 0xFF0000) >> 16;
            PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
                    "3C5/0Dh set to hex %2X, base 0x%x\n", temp, base));
            outb(VGA_SEQ_DATA, temp);
            if (pSiS->VBFlags)  {
/*              SiSUnLockCRT2(pSiS->RelIO); */
                SiSUnLockCRT2(pSiS->RelIO+0x30);
                outSISIDXREG(pSiS->RelIO+4, 6, GETVAR8(base));
                outSISIDXREG(pSiS->RelIO+4, 5, GETBITS(base, 15:8));
                outSISIDXREG(pSiS->RelIO+4, 4, GETBITS(base, 23:16));
/*              SiSLockCRT2(pSiS->RelIO); */
                SiSLockCRT2(pSiS->RelIO+0x30);
            }
            break;
        default:
            outb(VGA_SEQ_INDEX, 0x27);
            temp = inb(VGA_SEQ_DATA) & 0xF0;
            temp |= (base & 0x0F0000) >> 16;
            PDEBUG(xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
                    "3C5/27h set to hex %2X, base %d\n",  temp, base));
            outb(VGA_SEQ_DATA, temp);
    }
d10483 1
a10483 1
    outw(VGA_SEQ_INDEX, (SR5State << 8) | 0x05); /* Relock Registers */
d10485 1
a10485 1
  } /* if not VESA */
d10487 2
a10488 1
}
d10490 3
a10492 7
/*
 * This is called when VT switching back to the X server.  Its job is
 * to reinitialise the video mode.
 *
 * We may wish to unmap video/MMIO memory too.
 * (TW: This might be dangerous with TQ)
 */
d10494 2
a10495 8
/* Mandatory */
static Bool
SISEnterVT(int scrnIndex, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
#ifdef XF86DRI
    SISPtr pSiS = SISPTR(pScrn);
#endif
d10497 1
a10497 2
    if (!SISModeInit(pScrn, pScrn->currentMode))
	return FALSE;
d10499 1
a10499 1
    SISAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
d10501 28
a10528 3
#ifdef XF86DRI	/* TW: this is to be done AFTER switching the mode */
    if (pSiS->directRenderingEnabled)
        DRIUnlock(screenInfo.screens[scrnIndex]);
d10530 95
a10624 21

    return TRUE;
}

/*
 * This is called when VT switching away from the X server.  Its job is
 * to restore the previous (text) mode.
 *
 * We may wish to remap video/MMIO memory too.
 */

/* Mandatory */
static void
SISLeaveVT(int scrnIndex, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    vgaHWPtr hwp = VGAHWPTR(pScrn);
    SISPtr pSiS;

#ifdef XF86DRI
    ScreenPtr pScreen;
d10626 2
d10629 1
a10629 1
    pSiS = SISPTR(pScrn);
d10631 3
a10633 5
#ifdef XF86DRI		/* TW: to be done before mode change */
    if (pSiS->directRenderingEnabled) {
        pScreen = screenInfo.screens[scrnIndex];
        DRILock(pScreen, 0);
    }
d10635 49
d10685 1
a10685 1
    SISBridgeRestore(pScrn);
d10687 2
a10688 10
    if (pSiS->UseVESA) {
        /* TW: This is a q&d work-around for a BIOS bug. In case we disabled CRT2,
    	 *     VBESaveRestore() does not re-enable CRT1. So we set any mode now,
	 *     because VBESetVBEMode correctly restores CRT1. Afterwards, we
	 *     can call VBESaveRestore to restore original mode.
	 */
        if ( (pSiS->VBFlags & VB_VIDEOBRIDGE) && (!(pSiS->VBFlags & DISPTYPE_DISP2)) )
	           VBESetVBEMode(pSiS->pVbe, (SISVesaModeList->n) | 0xc000, NULL);
        SISVESARestore(pScrn);
    }
d10690 5
a10694 1
    SISRestore(pScrn);
d10696 5
a10700 1
    vgaHWLock(hwp);
d10703 8
a10710 4

/*
 * This is called at the end of each server generation.  It restores the
 * original (text) mode.  It should really also unmap the video memory too.
d10712 2
a10713 4

/* Mandatory */
static Bool
SISCloseScreen(int scrnIndex, ScreenPtr pScreen)
a10714 2
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    vgaHWPtr hwp = VGAHWPTR(pScrn);
d10716 15
a10730 1
    xf86CursorInfoPtr   pCursorInfo = pSiS->CursorInfoPtr;
d10732 2
a10733 5
#ifdef XF86DRI
    if (pSiS->directRenderingEnabled) {
        SISDRICloseScreen(pScreen);
        pSiS->directRenderingEnabled=FALSE;
    }
d10736 7
a10742 17
    if (pScrn->vtSema) {
        if (pCursorInfo)
           pCursorInfo->HideCursor(pScrn);
        SISBridgeRestore(pScrn);
	if (pSiS->UseVESA) {
          /* TW: This is a q&d work-around for a BIOS bug. In case we disabled CRT2,
    	   *     VBESaveRestore() does not re-enable CRT1. So we set any mode now,
	   *     because VBESetVBEMode correctly restores CRT1. Afterwards, we
	   *     can call VBESaveRestore to restore original mode.
	   */
           if ( (pSiS->VBFlags & VB_VIDEOBRIDGE) && (!(pSiS->VBFlags & DISPTYPE_DISP2)))
	           VBESetVBEMode(pSiS->pVbe, (SISVesaModeList->n) | 0xc000, NULL);
	   SISVESARestore(pScrn);
	}
	SISRestore(pScrn);
        vgaHWLock(hwp);
        SISUnmapMem(pScrn);
a10743 9
    if(pSiS->AccelInfoPtr)
        XAADestroyInfoRec(pSiS->AccelInfoPtr);
    if(pCursorInfo)
        xf86DestroyCursorInfoRec(pCursorInfo);
    pScrn->vtSema = FALSE;
    
    pScreen->CloseScreen = pSiS->CloseScreen;
    return (*pScreen->CloseScreen)(scrnIndex, pScreen);
}
d10745 7
d10753 20
a10772 1
/* Free up any per-generation data structures */
d10774 1
a10774 8
/* Optional */
static void
SISFreeScreen(int scrnIndex, int flags)
{
    if (xf86LoaderCheckSymbol("vgaHWFreeHWRec"))
        vgaHWFreeHWRec(xf86Screens[scrnIndex]);
    SISFreeRec(xf86Screens[scrnIndex]);
}
d10776 7
d10784 1
a10784 1
/* Checks if a mode is suitable for the selected chipset. */
d10786 24
a10809 6
/* Optional */
static int
SISValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    SISPtr pSiS = SISPTR(pScrn);
a10810 11
    if (pSiS->UseVESA) {
	if (CalcVESAModeIndex(pScrn, mode))
	    return (MODE_OK);
	else 
	    return (MODE_BAD);
    }
    if ((pSiS->Chipset == PCI_CHIP_SIS300) ||
            (pSiS->Chipset == PCI_CHIP_SIS630) ||
            (pSiS->Chipset == PCI_CHIP_SIS540)) {
	if (SiSCalcModeIndex(pScrn, mode) < 0x14)
	    return (MODE_BAD);
a10811 3
    
    return(MODE_OK);
}
d10813 57
a10869 1
/* Do screen blanking */
d10871 17
a10887 6
/* Mandatory */
static Bool
SISSaveScreen(ScreenPtr pScreen, int mode)
{
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    if ((pScrn != NULL) && pScrn->vtSema) {
d10889 11
a10899 18
    	SISPtr pSiS = SISPTR(pScrn);
	/* enable access to extended sequencer registers */
	outw(VGA_SEQ_INDEX, 0x8605);
	outb(VGA_SEQ_INDEX, 0x11);
	/* if not blanked obtain state of LCD blank flags set by BIOS */
	if (!pSiS->Blank) {
	    unsigned char val;
	    val = inb(VGA_SEQ_DATA);
	    pSiS->LCDon = val;
	}
	if (!xf86IsUnblank(mode)) {
	    pSiS->Blank = TRUE;
	    outb(VGA_SEQ_DATA, (pSiS->LCDon | 0x8));
	} else {
	    pSiS->Blank = FALSE;
	    /* don't just unblanking; use LCD state set by BIOS */
	    outb(VGA_SEQ_DATA, (pSiS->LCDon));
	}
d10902 15
a10916 2
    return vgaHWSaveScreen(pScreen, mode);
}
d10918 4
a10921 21
#ifdef  DEBUG
/* local used for debug */
static void
SiSDumpModeInfo(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Clock : %x\n", mode->Clock);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Display : %x\n", mode->CrtcHDisplay);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Blank Start : %x\n", mode->CrtcHBlankStart);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Sync Start : %x\n", mode->CrtcHSyncStart);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Sync End : %x\n", mode->CrtcHSyncEnd);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Blank End : %x\n", mode->CrtcHBlankEnd);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Total : %x\n", mode->CrtcHTotal);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Skew : %x\n", mode->CrtcHSkew);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz HAdjusted : %x\n", mode->CrtcHAdjusted);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Display : %x\n", mode->CrtcVDisplay);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Blank Start : %x\n", mode->CrtcVBlankStart);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Sync Start : %x\n", mode->CrtcVSyncStart);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Sync End : %x\n", mode->CrtcVSyncEnd);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Blank End : %x\n", mode->CrtcVBlankEnd);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Total : %x\n", mode->CrtcVTotal);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt VAdjusted : %x\n", mode->CrtcVAdjusted);
d10923 194
a11116 13
/*
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Display : %x\n", mode->HDisplay);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Sync Start : %x\n", mode->HSyncStart);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Sync End : %x\n", mode->HSyncEnd);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Total : %x\n", mode->HTotal);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Skew : %x\n", mode->HSkew);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Display : %x\n", mode->VDisplay);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Sync Start : %x\n", mode->VSyncStart);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Sync End : %x\n", mode->VSyncEnd);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Total : %x\n", mode->VTotal);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Scan : %x\n", mode->VScan);
*/
}
d11118 32
a11150 28
/* local used for debug */
static void
SISModifyModeInfo(DisplayModePtr mode)
{
/*
    mode->Clock = 31500;
    mode->CrtcHTotal    = 832;
    mode->CrtcHDisplay  = 640;
    mode->CrtcHBlankStart   = 648;
    mode->CrtcHSyncStart    = 664;
    mode->CrtcHSyncEnd  = 704;
    mode->CrtcHBlankEnd = 824;

    mode->CrtcVTotal    = 520;
    mode->CrtcVDisplay  = 480;
    mode->CrtcVBlankStart   = 488;
    mode->CrtcVSyncStart    = 489;
    mode->CrtcVSyncEnd  = 492;
    mode->CrtcVBlankEnd = 512;
*/
    if (mode->CrtcHBlankStart == mode->CrtcHDisplay)
        mode->CrtcHBlankStart++;
    if (mode->CrtcHBlankEnd == mode->CrtcHTotal)
        mode->CrtcHBlankEnd--;
    if (mode->CrtcVBlankStart == mode->CrtcVDisplay)
        mode->CrtcVBlankStart++;
    if (mode->CrtcVBlankEnd == mode->CrtcVTotal)
        mode->CrtcVBlankEnd--;
d11153 3
a11155 1
void SiSPreSetMode(ScrnInfoPtr pScrn, int LockAfterwards)
d11158 8
a11165 6
    unsigned char  usScratchCR30, usScratchCR31;
    unsigned char  usScratchCR32, usScratchCR33;
    unsigned short SR26, SR27;
    unsigned char SR5State;
    unsigned long  temp;
    int vbflag;
d11167 9
a11175 13
    outb(VGA_SEQ_INDEX, 0x05);           /* Unlock Registers */
    SR5State = inb(VGA_SEQ_DATA);
    outw(VGA_SEQ_INDEX, 0x8605);

    usScratchCR30 = usScratchCR31 = usScratchCR33 = 0;
    outb(SISCR, 0x31);
    usScratchCR31 = inb(SISCR+1);
    outb(SISCR, 0x33);		/* TW: CRT1 refresh rate index */
    usScratchCR33 = inb(SISCR+1);
    outb(SISCR, 0x32);		/* TW: Bridge connection info */
    usScratchCR32 = inb(SISCR+1);
    outb(SISCR, 0x30);
    usScratchCR30 = inb(SISCR+1);
d11177 6
a11182 44
    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	       "Bridge registers were 30=0x%02x, 31=0x%02x, 32=0x%02x, 33=0x%02x (VBFlags = 0x%x)\n",
	       usScratchCR30, usScratchCR31, usScratchCR32, usScratchCR33, pSiS->VBFlags);
    usScratchCR30 = 0;
    usScratchCR31 &= ~0x60;  /* TW: clear VB_Drivermode & VB_OutputDisable */
    
    vbflag=pSiS->VBFlags;
    switch (vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA))
    { case CRT2_TV:
	if (vbflag & TV_HIVISION)
	    usScratchCR30 |= 0x80;
	else if (vbflag & TV_SVIDEO)
	    usScratchCR30 |= 0x08;
	else if (vbflag & TV_AVIDEO)
	    usScratchCR30 |= 0x04;
	else if (vbflag & TV_SCART)
	    usScratchCR30 |= 0x10;
	if (vbflag & TV_PAL)
	    usScratchCR31 |= 0x01;
	else
	    usScratchCR31 &= ~0x01;
#if 0	/* TW: Old code */
	if (vbflag & TV_HIVISION) usScratchCR30 |= 0x80;
	else if (vbflag & TV_PAL) usScratchCR31 |= 0x01;
	
	if (vbflag & TV_AVIDEO) usScratchCR30 |= 0x04;
	else if (vbflag & TV_SVIDEO) usScratchCR30 |= 0x08;
	else if (vbflag & TV_SCART) usScratchCR30 |= 0x10;
#endif
	usScratchCR30 |= 0x01;
	usScratchCR31 &= ~0x04;
	break;
    case CRT2_LCD:
	usScratchCR30 |= 0x21;
	usScratchCR31 |= 0x02;
	break;
    case CRT2_VGA:
	usScratchCR30 |= 0x41;
	break;
    default:  /* TW: When CRT2Type is NONE, we can calculate a proper rate for CRT1 */
	usScratchCR30 |= 0x00;
	usScratchCR31 |= 0x20; /* TW: VB_OUTPUT_DISABLE */
	if (pSiS->UseVESA)
	    usScratchCR33 = SISSearchCRT1Rate(pScrn->currentMode);
d11184 3
a11186 5
    /*
     * TW: for VESA: no DRIVERMODE, otherwise
     * -) CRT2 will not be initialized correctly when using mode
     *    where LCD has to scale
     * -) CRT1 will have too low rate
d11188 36
a11223 24
    if (pSiS->UseVESA) usScratchCR31 &= ~0x40;
    else usScratchCR31 |= 0x40;   /* 0x40=drivermode */
  
   SiSSetReg1(SISCR, 0x30, usScratchCR30);
   SiSSetReg1(SISCR, 0x31, usScratchCR31);
   SiSSetReg1(SISCR, 0x33, usScratchCR33);
  
    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	       "Bridge registers set to 30=0x%02x, 31=0x%02x, 33=0x%02x\n",
	       usScratchCR30, usScratchCR31, usScratchCR33);
  
    /* Set Turbo Queue as 512K */
    /* TW: This is done here _and_ in SiS300Init() because SiS300Init() only
     * sets up structure but structure is not written to hardware (using
     * SiS300Restore) on SiS630, 300, 540 (unless VESA is used).
     */
    if (!pSiS->NoAccel) {
        if (pSiS->TurboQueue) {
	    temp = (pScrn->videoRam/64) - 8;
	    SR26 = temp & 0xFF;
	    SR27 = ((temp >> 8) & 3) | 0xF0;
	    SiSSetReg1(SISSR, 0x26, SR26);
	    SiSSetReg1(SISSR, 0x27, SR27);
	}
d11225 1
a11225 3
    
    if (LockAfterwards)
	outw(VGA_SEQ_INDEX, (SR5State << 8) | 0x05); /* Relock Registers */
d11228 3
a11230 2
/* TW: This doesn't work yet. Switching CRT1 off this way causes a white screen on CRT2 */
void SiSPostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg, int LockAfterwards)
a11231 1
#if 0
d11233 1
a11233 2
    unsigned char usScratchCR17;
    unsigned char SR5State;
d11235 1
a11235 3
    outb(VGA_SEQ_INDEX, 0x05);           /* Unlock Registers */
    SR5State = inb(VGA_SEQ_DATA);
    outw(VGA_SEQ_INDEX, 0x8605);
d11237 7
a11243 21
    if ((pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) &&
	pScrn->bitsPerPixel == 8)
        pSiS->CRT1off = 0;

    xf86DrvMsg(0, X_PROBED, "CRT1off %d\n", pSiS->CRT1off);

    outb(SISCR, 0x17);
    usScratchCR17 = inb(SISCR+1);

    xf86DrvMsg(0, X_PROBED, "CR17 was 0x%2x\n", usScratchCR17);
    if (pSiS->CRT1off)
	usScratchCR17 &= ~0x80;  /* sisReg->sisRegs3D4[0x17] &= ~0x80; */
    else
        usScratchCR17 |= 0x80;   /* sisReg->sisRegs3D4[0x17] |= 0x80; */

    xf86DrvMsg(0, X_PROBED, "CR17 set to 0x%2x\n", usScratchCR17);
    /*SiSSetReg1(SISCR, 0x17, usScratchCR17); */

    if (LockAfterwards)
        outw(VGA_SEQ_INDEX, (SR5State << 8) | 0x05); /* Relock Registers */
#endif
d11246 1
d11250 1
d11252 2
a11253 1
    while (vbe->VideoModePtr[i] != 0xffff) {
d11259 1
a11259 1
	if ((mode = VBEGetModeInfo(pVbe, id)) == NULL)
a11262 3
	/* TW: Doesn't work on SiS630 VBE 3.0: */
	/* mode->GreenMaskSize + mode->BlueMaskSize
	    + mode->RedMaskSize;  */
d11269 1
a11269 1
	m->next = SISVesaModeList;
d11272 1
a11272 1
	      "BIOS reported VESA mode 0x%x: x:%i y:%i bpp:%i\n",
d11275 1
a11275 1
	SISVesaModeList = m;
d11281 3
a11283 1
static UShort CalcVESAModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode)
d11285 3
a11287 2
    sisModeInfoPtr m = SISVesaModeList;
    UShort i = (pScrn->bitsPerPixel+7)/8 - 1;	/* bitsperpixel was depth */
d11290 4
a11293 4
    while (m) {
	if (pScrn->bitsPerPixel == m->bpp 
	    && mode->HDisplay == m->width 
	    && mode->VDisplay == m->height)
d11302 10
a11311 4
    switch(mode->HDisplay)
   {
     case 640:
          ModeIndex = VESAModeIndex_640x480[i];
d11313 5
a11317 1
     case 720:
d11319 3
a11321 3
            ModeIndex = VESAModeIndex_720x480[i];
          else
            ModeIndex = VESAModeIndex_720x576[i];
d11323 3
a11325 2
     case 800:
          ModeIndex = VESAModeIndex_800x600[i];
d11327 3
a11329 2
     case 1024:
          ModeIndex = VESAModeIndex_1024x768[i];
d11331 3
a11333 2
     case 1280:
          ModeIndex = VESAModeIndex_1280x1024[i];
d11335 3
a11337 2
     case 1600:
          ModeIndex = VESAModeIndex_1600x1200[i];
d11339 3
a11341 2
     case 1920:
          ModeIndex = VESAModeIndex_1920x1440[i];
d11345 2
a11346 2
   if (!ModeIndex) xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
        "No valid mode found for %dx%dx%d in built-in table either.",
d11352 95
a11446 6
/* TW: Calculate CR33 (rate index) for CRT1 if CRT2 is disabled.
       Calculation is done using currentmode structure, therefore
       it is recommended to set VertRefresh and HorizSync to correct
       values in Config file.
 */
unsigned char SISSearchCRT1Rate(DisplayModePtr mode)
a11448 4
   int i = 0;
   unsigned short xres=mode->HDisplay;
   unsigned short yres=mode->VDisplay;
   unsigned char index;
d11450 1
a11450 1
   if (mode->HSync > 0.0)
d11452 1
a11452 1
   else if (mode->HTotal > 0)
d11456 2
a11457 1
   if (mode->VTotal > 0)
d11459 2
a11460 1
   if (mode->Flags & V_INTERLACE) {
d11462 2
a11463 2
   }
   if (mode->Flags & V_DBLSCAN) {
d11465 2
a11466 2
   }
   if (mode->VScan > 1) {
d11468 29
d11498 51
a11548 20
   if (mode->VRefresh > 0.0)
    	refresh = mode->VRefresh;
   if (hsync == 0 || refresh == 0)
        return 0x02;  /* TW: Default mode index */
   else {
     index = 0;
     while ((sisx_vrate[i].idx != 0) && (sisx_vrate[i].xres <= xres)) {
	if ((sisx_vrate[i].xres == xres)
		    && (sisx_vrate[i].yres == yres)) {
	    if (sisx_vrate[i].refresh == refresh) {
		index = sisx_vrate[i].idx;
		break;
	    } else if (sisx_vrate[i].refresh > refresh) {
		if ((sisx_vrate[i].refresh - refresh) <= 2) {
		    index = sisx_vrate[i].idx;
		} else if (((refresh - sisx_vrate[i - 1].refresh) <=  2)
				    	&& (sisx_vrate[i].idx != 1)) {
			index = sisx_vrate[i - 1].idx;
		}
		break;
d11552 2
a11553 2
     }
     if (index > 0)
d11555 88
a11642 2
     else
	return 0x02; /* TW: Default Rate index */
d11644 102
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@a0 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_driver.c,v 1.176 2004/01/24 21:29:20 twini Exp $ */
d2 1
a2 1
 * SiS driver main code
d4 9
a12 1
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria.
d14 7
a20 13
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement: "This product includes
 *    software developed by Thomas Winischhofer, Vienna, Austria."
 * 4) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d22 5
a26 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d28 1
a28 16
 * Author: Thomas Winischhofer <thomas@@winischhofer.net>
 *	- driver entirely rewritten since 2001, only basic structure taken from
 *	  old code (except sis_dri.c, sis_shadow.c, sis_accel.c and parts of
 *	  sis_dga.c; these were mostly taken over; sis_dri.c was changed for
 *	  new versions of the DRI layer)
 *
 * This notice covers the entire driver code unless otherwise indicated.
 *
 * Formerly based on code which is
 * 	     Copyright (C) 1998, 1999 by Alan Hourihane, Wigan, England.
 * Written by:
 *           Alan Hourihane <alanh@@fairlite.demon.co.uk>,
 *           Mike Chapman <mike@@paranoia.com>,
 *           Juanjo Santamarta <santamarta@@ctv.es>,
 *           Mitani Hiroshi <hmitani@@drl.mei.co.jp>,
 *           David Thomas <davtom@@dream.org.uk>.
d30 1
d33 2
a37 1
#include "xf86Priv.h"
a40 1
#include "dixstruct.h"
d54 1
a54 1
 
d57 1
a60 2
#include "sis_driver.h"

a64 1

d68 1
a68 1
#if (XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,99,0,0)) || (defined(XvExtension))
a76 1
/* Globals (yes, these ARE really required to be global) */
d78 46
a123 3
#ifdef SISDUALHEAD
static int      	SISEntityIndex = -1;
#endif
d125 2
a126 17
#ifdef SISMERGED
#ifdef SISXINERAMA
static Bool 		SiSnoPanoramiXExtension = TRUE;
int 			SiSXineramaPixWidth = 0;
int 			SiSXineramaPixHeight = 0;
int 			SiSXineramaNumScreens = 0;
SiSXineramaData		*SiSXineramadataPtr = NULL;
static int 		SiSXineramaGeneration;

int SiSProcXineramaQueryVersion(ClientPtr client);
int SiSProcXineramaGetState(ClientPtr client);
int SiSProcXineramaGetScreenCount(ClientPtr client);
int SiSProcXineramaGetScreenSize(ClientPtr client);
int SiSProcXineramaIsActive(ClientPtr client);
int SiSProcXineramaQueryScreens(ClientPtr client);
int SiSSProcXineramaDispatch(ClientPtr client);
#endif
d134 1
d155 12
a166 5
    { PCI_CHIP_SIS5597,     "SIS5597/5598" },
    { PCI_CHIP_SIS530,      "SIS530/620" },
    { PCI_CHIP_SIS6326,     "SIS6326/AGP/DVD" },
    { PCI_CHIP_SIS300,      "SIS300/305" },
    { PCI_CHIP_SIS630,      "SIS630/730" },
a167 7
    { PCI_CHIP_SIS315,      "SIS315" },
    { PCI_CHIP_SIS315H,     "SIS315H" },
    { PCI_CHIP_SIS315PRO,   "SIS315PRO" },
    { PCI_CHIP_SIS550,	    "SIS550" },
    { PCI_CHIP_SIS650,      "SIS650/M650/651/740" },
    { PCI_CHIP_SIS330,      "SIS330(Xabre)" },
    { PCI_CHIP_SIS660,      "SIS660/661FX/M661FX/M661MX/741/M741/760" },
d172 6
a183 7
    { PCI_CHIP_SIS550,      PCI_CHIP_SIS550,    RES_SHARED_VGA },
    { PCI_CHIP_SIS315,      PCI_CHIP_SIS315,    RES_SHARED_VGA },
    { PCI_CHIP_SIS315H,     PCI_CHIP_SIS315H,   RES_SHARED_VGA },
    { PCI_CHIP_SIS315PRO,   PCI_CHIP_SIS315PRO, RES_SHARED_VGA },
    { PCI_CHIP_SIS650,      PCI_CHIP_SIS650,    RES_SHARED_VGA },
    { PCI_CHIP_SIS330,      PCI_CHIP_SIS330,    RES_SHARED_VGA },
    { PCI_CHIP_SIS660,      PCI_CHIP_SIS660,    RES_SHARED_VGA },
d186 46
a236 1
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,0,0)
a237 2
#endif
    "XAAFillMono8x8PatternRects",
a250 1
    "vgaHWUnmapMem",
d259 6
a285 1
    "xf86InterpretEDID",
d289 3
a291 3
static const char *int10Symbols[] = {
    "xf86FreeInt10",
    "xf86InitInt10",
a295 1
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
a296 3
#else
    "VBEExtendedInit",
#endif
a298 9
    "VBEGetVBEInfo",
    "VBEFreeVBEInfo",
    "VBEGetModeInfo",
    "VBEFreeModeInfo",
    "VBESaveRestore",
    "VBESetVBEMode",
    "VBEGetVBEMode",
    "VBESetDisplayStart",
    "VBESetGetLogicalScanlineLength",
a329 3
#ifdef SISNEWDRI2
    "DRICreatePCIBusID"
#endif        
d334 1
d360 6
a365 6
    if(!setupDone) {
       setupDone = TRUE;
       xf86AddDriver(&SIS, module, 0);
       LoaderRefSymLists(vgahwSymbols, fbSymbols, xaaSymbols,
			 shadowSymbols, ramdacSymbols,
			 vbeSymbols, int10Symbols,
d367 1
a367 1
			 drmSymbols, driSymbols,
d369 3
a371 3
			 NULL);
       return (pointer)TRUE;
    }
d373 1
a373 1
    if(errmaj) *errmaj = LDR_ONCEONLY;
d387 2
a388 1
    if(pScrn->driverPrivate != NULL) return TRUE;
d391 1
a391 3
    
    /* Initialise it to 0 */
    memset(pScrn->driverPrivate, 0, sizeof(SISRec));
d400 2
a401 12
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif

    /* Just to make sure... */
    if(!pSiS) return;

#ifdef SISDUALHEAD
    pSiSEnt = pSiS->entityPrivate;
#endif

    if(pSiS->pstate) xfree(pSiS->pstate);
d403 1
a403 76
    if(pSiS->fonts) xfree(pSiS->fonts);
    pSiS->fonts = NULL;

#ifdef SISDUALHEAD
    if(pSiSEnt) {
       if(!pSiS->SecondHead) {
          /* Free memory only if we are first head; in case of an error
	   * during init of the second head, the server will continue -
	   * and we need the BIOS image and SiS_Private for the first
	   * head.
	   */
	  if(pSiSEnt->BIOS) xfree(pSiSEnt->BIOS);
          pSiSEnt->BIOS = pSiS->BIOS = NULL;
	  if(pSiSEnt->SiS_Pr) xfree(pSiSEnt->SiS_Pr);
          pSiSEnt->SiS_Pr = pSiS->SiS_Pr = NULL;
	  if(pSiSEnt->RenderAccelArray) xfree(pSiSEnt->RenderAccelArray);
	  pSiSEnt->RenderAccelArray = pSiS->RenderAccelArray = NULL;
       } else {
      	  pSiS->BIOS = NULL;
	  pSiS->SiS_Pr = NULL;
	  pSiS->RenderAccelArray = NULL;
       }
    } else {
#endif
       if(pSiS->BIOS) xfree(pSiS->BIOS);
       pSiS->BIOS = NULL;
       if(pSiS->SiS_Pr) xfree(pSiS->SiS_Pr);
       pSiS->SiS_Pr = NULL;
       if(pSiS->RenderAccelArray) xfree(pSiS->RenderAccelArray);
       pSiS->RenderAccelArray = NULL;
#ifdef SISDUALHEAD
    }
#endif
#ifdef SISMERGED
    if(pSiS->CRT2HSync) xfree(pSiS->CRT2HSync);
    pSiS->CRT2HSync = NULL;
    if(pSiS->CRT2VRefresh) xfree(pSiS->CRT2VRefresh);
    pSiS->CRT2VRefresh = NULL;
    if(pSiS->MetaModes) xfree(pSiS->MetaModes);
    pSiS->MetaModes = NULL;
    if(pSiS->CRT2pScrn) {
       if(pSiS->CRT2pScrn->modes) {
          while(pSiS->CRT2pScrn->modes)
             xf86DeleteMode(&pSiS->CRT2pScrn->modes, pSiS->CRT2pScrn->modes);
       }
       if(pSiS->CRT2pScrn->monitor) {
          if(pSiS->CRT2pScrn->monitor->Modes) {
	     while(pSiS->CRT2pScrn->monitor->Modes)
	        xf86DeleteMode(&pSiS->CRT2pScrn->monitor->Modes, pSiS->CRT2pScrn->monitor->Modes);
	  }
	  if(pSiS->CRT2pScrn->monitor->DDC) xfree(pSiS->CRT2pScrn->monitor->DDC);
          xfree(pSiS->CRT2pScrn->monitor);
       }
       xfree(pSiS->CRT2pScrn);
       pSiS->CRT2pScrn = NULL;
    }
    if(pSiS->CRT1Modes) {
       if(pSiS->CRT1Modes != pScrn->modes) {
          if(pScrn->modes) {
             pScrn->currentMode = pScrn->modes;
             do {
                DisplayModePtr p = pScrn->currentMode->next;
                if(pScrn->currentMode->Private)
                   xfree(pScrn->currentMode->Private);
                xfree(pScrn->currentMode);
                pScrn->currentMode = p;
             } while(pScrn->currentMode != pScrn->modes);
          }
          pScrn->currentMode = pSiS->CRT1CurrentMode;
          pScrn->modes = pSiS->CRT1Modes;
          pSiS->CRT1CurrentMode = NULL;
          pSiS->CRT1Modes = NULL;
       }
    }
#endif
    if(pSiS->pVbe) vbeFree(pSiS->pVbe);
d405 1
a405 1
    if(pScrn->driverPrivate == NULL)
d411 1
a411 1
static void
d415 4
a418 4
    BOOLEAN docrt1 = TRUE, docrt2 = TRUE;
    unsigned char sr1=0, cr17=0, cr63=0, sr11=0, pmreg=0, sr7=0;
    unsigned char p1_13=0, p2_0=0, oldpmreg=0;
    BOOLEAN backlight = TRUE;
d421 1
a421 1
          "SISDisplayPowerManagementSet(%d)\n",PowerManagementMode);
d423 27
a449 49
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       if(pSiS->SecondHead) docrt2 = FALSE;
       else                 docrt1 = FALSE;
    }
#endif

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    if(docrt2) {
       if(pSiS->VBFlags & CRT2_LCD) {
          if(((pSiS->VGAEngine == SIS_300_VGA) &&
             (pSiS->VBFlags & (VB_301|VB_30xBDH|VB_LVDS))) ||
            ((pSiS->VGAEngine == SIS_315_VGA) &&
             ((pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) == VB_LVDS))) {
#ifdef SISDUALHEAD
             if(pSiS->DualHeadMode) {
	        if(!pSiS->BlankCRT2) {
		   inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		   if(pSiS->sishw_ext.jChipType >= SIS_661) pSiS->LCDon &= 0x0f;
		}
	     } else
#endif
	     if(!pSiS->Blank) {
	        inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		if(pSiS->sishw_ext.jChipType >= SIS_661) pSiS->LCDon &= 0x0f;
	     }
          }
       }
    }

    switch (PowerManagementMode) {

       case DPMSModeOn:      /* HSync: On, VSync: On */
            if(docrt1)  pSiS->Blank = FALSE;
#ifdef SISDUALHEAD
	    else	pSiS->BlankCRT2 = FALSE;
#endif
            sr1   = 0x00;
            cr17  = 0x80;
	    pmreg = 0x00;
	    cr63  = 0x00;
	    sr7   = 0x10;
	    sr11  = (pSiS->LCDon & 0x0C);
	    p2_0  = 0x20;
	    p1_13 = 0x00;
	    backlight = TRUE;
d451 5
a455 15

       case DPMSModeSuspend: /* HSync: On, VSync: Off */
            if(docrt1)  pSiS->Blank = TRUE;
#ifdef SISDUALHEAD
	    else        pSiS->BlankCRT2 = TRUE;
#endif
            sr1   = 0x20;
	    cr17  = 0x80;
	    pmreg = 0x80;
	    cr63  = 0x40;
	    sr7   = 0x00;
	    sr11  = 0x08;
	    p2_0  = 0x40;
	    p1_13 = 0x80;
	    backlight = FALSE;
d457 8
a464 15

       case DPMSModeStandby: /* HSync: Off, VSync: On */
            if(docrt1)  pSiS->Blank = TRUE;
#ifdef SISDUALHEAD
	    else        pSiS->BlankCRT2 = TRUE;
#endif
            sr1   = 0x20;
	    cr17  = 0x80;
	    pmreg = 0x40;
	    cr63  = 0x40;
	    sr7   = 0x00;
	    sr11  = 0x08;
	    p2_0  = 0x80;
	    p1_13 = 0x40;
	    backlight = FALSE;
a465 102

       case DPMSModeOff:     /* HSync: Off, VSync: Off */
            if(docrt1)  pSiS->Blank = TRUE;
#ifdef SISDUALHEAD
	    else        pSiS->BlankCRT2 = TRUE;
#endif
            sr1   = 0x20;
	    cr17  = 0x00;
	    pmreg = 0xc0;
	    cr63  = 0x40;
	    sr7   = 0x00;
	    sr11  = 0x08;
	    p2_0  = 0xc0;
	    p1_13 = 0xc0;
	    backlight = FALSE;
	    break;

       default:
	    return;
    }

    if(docrt2) {
       if(pSiS->VGAEngine == SIS_315_VGA) {
          if(pSiS->VBFlags & CRT2_LCD) {
	     if(pSiS->VBFlags & VB_CHRONTEL) {
	        if(backlight) {
	           SiS_Chrontel701xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	        } else {
	           SiS_Chrontel701xBLOff(pSiS->SiS_Pr);
                }
	     }
          }
       }
    }

    if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
       if((docrt2 && (pSiS->VBFlags & CRT2_LCD)) || (docrt1 && (pSiS->VBFlags & CRT1_LCDA))) {
          if(backlight) {
	     SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	  } else {
             SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
	  }
       }
    }

    if(docrt1) {
       setSISIDXREG(SISSR, 0x01, ~0x20, sr1);    /* Set/Clear "Display On" bit */
       switch(pSiS->VGAEngine) {
       case SIS_OLD_VGA:
       case SIS_530_VGA:
            inSISIDXREG(SISSR, 0x11, oldpmreg);
            setSISIDXREG(SISCR, 0x17, 0x7f, cr17);
	    setSISIDXREG(SISSR, 0x11, 0x3f, pmreg);
	    break;
       case SIS_315_VGA:
            if((!pSiS->CRT1off) && ((!(pSiS->VBFlags & CRT1_LCDA)) || (pSiS->VBFlags & VB_301C))) {
               setSISIDXREG(SISCR, pSiS->myCR63, 0xbf, cr63);
	       setSISIDXREG(SISSR, 0x07, 0xef, sr7);
	    }
	    /* fall through */
       default:
            if((!(pSiS->VBFlags & CRT1_LCDA)) || (pSiS->VBFlags & VB_301C)) {
               inSISIDXREG(SISSR, 0x1f, oldpmreg);
               if(!pSiS->CRT1off) {
	          setSISIDXREG(SISSR, 0x1f, 0x3f, pmreg);
	       }
	    }
	    /* TODO: Check if Chrontel TV is active and in slave mode,
	     * don't go into power-saving mode this in this case!
	     */
       }
       oldpmreg &= 0xc0;
    }

    if(docrt2) {
       if(pSiS->VBFlags & CRT2_LCD) {
          if(((pSiS->VGAEngine == SIS_300_VGA) &&
              (pSiS->VBFlags & (VB_301|VB_30xBDH|VB_LVDS))) ||
             ((pSiS->VGAEngine == SIS_315_VGA) &&
              ((pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) == VB_LVDS))) {
	     if(pSiS->sishw_ext.jChipType >= SIS_661) {
	        setSISIDXREG(SISSR, 0x11, ~0xfc, sr11);
	     } else {
                setSISIDXREG(SISSR, 0x11, ~0x0c, sr11);
	     }
          }
          if(pSiS->VGAEngine == SIS_300_VGA) {
             if((pSiS->VBFlags & (VB_301B|VB_301C|VB_302B)) &&
                (!(pSiS->VBFlags & VB_30xBDH))) {
	        setSISIDXREG(SISPART1, 0x13, 0x3f, p1_13);
	     }
          } else if(pSiS->VGAEngine == SIS_315_VGA) {
             if((pSiS->VBFlags & (VB_301B|VB_301C|VB_302B)) &&
                (!(pSiS->VBFlags & VB_30xBDH))) {
	        setSISIDXREG(SISPART2, 0x00, 0x1f, p2_0);
	     }
          }
       } else if(pSiS->VBFlags & CRT2_VGA) {
          if(pSiS->VBFlags & (VB_301B|VB_301C|VB_302B)) {
	     setSISIDXREG(SISPART2, 0x00, 0x1f, p2_0);
          }
       }
d467 11
a478 7
    if((docrt1) && (pmreg != oldpmreg) && ((!(pSiS->VBFlags & CRT1_LCDA)) || (pSiS->VBFlags & VB_301C))) {
       outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
       usleep(10000);
       outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */
    }

}
a486 2
#if 0
/* This won't work as long as noone added the symbols to the symlist */
d488 1
a488 1
SISCalculateGammaRamp(ScrnInfoPtr pScrn)
a490 45
   int i, j, nramp;
   unsigned short *ramp[3];
   float gamma_max[3], gamma_prescale[3], framp;

   gamma_max[0] = (float)pSiS->GammaBriR / 1000;
   gamma_max[1] = (float)pSiS->GammaBriG / 1000;
   gamma_max[2] = (float)pSiS->GammaBriB / 1000;
   gamma_prescale[0] = (float)pSiS->GammaPBriR / 1000;
   gamma_prescale[1] = (float)pSiS->GammaPBriG / 1000;
   gamma_prescale[2] = (float)pSiS->GammaPBriB / 1000;

   if(!(nramp = xf86GetGammaRampSize(pScrn->pScreen))) return;

   for(i=0; i<3; i++) {
      ramp[i] = (unsigned short *)xalloc(nramp * sizeof(unsigned short));
      if(!ramp[i]) {
         if(ramp[0]) { xfree(ramp[0]); ramp[0] = NULL; }
	 if(ramp[1]) { xfree(ramp[1]); ramp[1] = NULL; }
         return;
      }
   }

   for(i = 0; i < 3; i++) {
      int fullscale = 65535 * gamma_max[i];
      float dramp = 1. / (nramp - 1);
      float invgamma=0.0, v;

      switch(i) {
      case 0: invgamma = 1. / pScrn->gamma.red; break;
      case 1: invgamma = 1. / pScrn->gamma.green; break;
      case 2: invgamma = 1. / pScrn->gamma.blue; break;
      }

      for(j = 0; j < nramp; j++) {
         framp = pow(gamma_prescale[i] * j * dramp, invgamma);

         v = (fullscale < 0) ? (65535 + fullscale * framp) :
	 		       fullscale * framp;
	 if(v < 0) v = 0;
	 else if(v > 65535) v = 65535;
	 ramp[i][j] = (unsigned short)v;
      }
   }

   xf86ChangeGammaRamp(pScrn->pScreen, nramp, ramp[0], ramp[1], ramp[2]);
d492 4
a495 12
   xfree(ramp[0]);
   xfree(ramp[1]);
   xfree(ramp[2]);
   ramp[0] = ramp[1] = ramp[2] = NULL;
}
#endif

static void
SISErrorLog(ScrnInfoPtr pScrn, const char *format, ...)
{
    va_list ap;
    static const char *str = "**************************************************\n";
d497 4
a500 9
    va_start(ap, format);
    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, str);
    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
    	"                      ERROR:\n");
    xf86VDrvMsgVerb(pScrn->scrnIndex, X_ERROR, 1, format, ap);
    va_end(ap);
    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
    	"                  END OF MESSAGE\n");
    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, str);
d507 1
a507 1
    int     i;
d509 4
a512 4
    int     *usedChips;
    int     numDevSections;
    int     numUsed;
    Bool    foundScreen = FALSE;
d525 2
d536 7
a542 6
    if((numDevSections = xf86MatchDevice(SIS_DRIVER_NAME, &devSections)) <= 0) {
       /*
        * There's no matching device section in the config file, so quit
        * now.
        */
       return FALSE;
d546 5
d560 6
a565 6
    if(xf86GetPciVideoInfo() == NULL) {
       /*
        * We won't let anything in the config file override finding no
        * PCI video cards at all.  This seems reasonable now, but we'll see.
        */
       return FALSE;
d569 2
a570 2
               		SISChipsets, SISPciChipsets, devSections,
               		numDevSections, drv, &usedChips);
d574 2
a575 1
    if(numUsed <= 0) return FALSE;
d577 1
a577 1
    if(flags & PROBE_DETECT) {
d579 1
a579 1
    } else for(i = 0; i < numUsed; i++) {
a580 3
#ifdef SISDUALHEAD
	EntityInfoPtr pEnt;
#endif
d585 3
a587 3
        if((pScrn = xf86ConfigPciEntity(pScrn, 0, usedChips[i],
                                         SISPciChipsets, NULL, NULL,
                                         NULL, NULL, NULL))) {
a602 41
#ifdef SISDUALHEAD
	pEnt = xf86GetEntityInfo(usedChips[i]);

	if(pEnt->chipset == PCI_CHIP_SIS630 || pEnt->chipset == PCI_CHIP_SIS540 ||
	   pEnt->chipset == PCI_CHIP_SIS650 || pEnt->chipset == PCI_CHIP_SIS550 ||
	   pEnt->chipset == PCI_CHIP_SIS315 || pEnt->chipset == PCI_CHIP_SIS315H ||
	   pEnt->chipset == PCI_CHIP_SIS315PRO || pEnt->chipset == PCI_CHIP_SIS330 ||
	   pEnt->chipset == PCI_CHIP_SIS300 || pEnt->chipset == PCI_CHIP_SIS660) {

	    SISEntPtr pSiSEnt = NULL;
	    DevUnion  *pPriv;

	    xf86SetEntitySharable(usedChips[i]);
	    if(SISEntityIndex < 0) {
	       SISEntityIndex = xf86AllocateEntityPrivateIndex();
	    }
	    pPriv = xf86GetEntityPrivate(pScrn->entityList[0], SISEntityIndex);
	    if(!pPriv->ptr) {
	       pPriv->ptr = xnfcalloc(sizeof(SISEntRec), 1);
	       pSiSEnt = pPriv->ptr;
	       pSiSEnt->lastInstance = -1;
	       pSiSEnt->DisableDual = FALSE;
	       pSiSEnt->ErrorAfterFirst = FALSE;
	       pSiSEnt->MapCountIOBase = pSiSEnt->MapCountFbBase = 0;
	       pSiSEnt->FbBase = pSiSEnt->IOBase = NULL;
  	       pSiSEnt->forceUnmapIOBase = FALSE;
	       pSiSEnt->forceUnmapFbBase = FALSE;
	       pSiSEnt->HWCursorCBufNum = pSiSEnt->HWCursorMBufNum = 0;
#ifdef __alpha__
	       pSiSEnt->MapCountIOBaseDense = 0;
	       pSiSEnt->IOBaseDense = NULL;
	       pSiSEnt->forceUnmapIOBaseDense = FALSE;
#endif
	    } else {
	       pSiSEnt = pPriv->ptr;
	    }
	    pSiSEnt->lastInstance++;
	    xf86SetEntityInstanceForScreen(pScrn, pScrn->entityList[0],
	                                   pSiSEnt->lastInstance);
	}
#endif
d608 6
a613 4

/* If monitor section has no HSync/VRefresh data,
 * derive it from DDC data. Done by common layer
 * since 4.3.99.14.
d615 2
a616 3
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,14,0)
static void
SiSSetSyncRangeFromEdid(ScrnInfoPtr pScrn, int flag)
d618 1
a618 133
   MonPtr      mon = pScrn->monitor;
   xf86MonPtr  ddc = mon->DDC;
   int         i,j;
   float       myhhigh, myhlow;
   int         myvhigh, myvlow;
   unsigned char temp;
   const myhddctiming myhtiming[11] = {
       { 1, 0x20, 31.6 }, /* rounded up by .1 */
       { 1, 0x02, 35.3 },
       { 1, 0x04, 37.6 },
       { 1, 0x08, 38.0 },
       { 1, 0x01, 38.0 },
       { 2, 0x40, 47.0 },
       { 2, 0x80, 48.2 },
       { 2, 0x08, 48.5 },
       { 2, 0x04, 56.6 },
       { 2, 0x02, 60.1 },
       { 2, 0x01, 80.1 }
   };
   const myvddctiming myvtiming[10] = {
       { 1, 0x02, 56 },
       { 1, 0x01, 60 },
       { 2, 0x08, 60 },
       { 2, 0x04, 70 },
       { 1, 0x08, 72 },
       { 2, 0x80, 72 },
       { 1, 0x04, 75 },
       { 2, 0x40, 75 },
       { 2, 0x02, 75 },
       { 2, 0x01, 75 }
   };
   /* "Future modes"; we only check the really high ones */
   const myddcstdmodes mystdmodes[8] = {
       { 1280, 1024, 85, 91.1  },
       { 1600, 1200, 60, 75.0  },
       { 1600, 1200, 65, 81.3  },
       { 1600, 1200, 70, 87.5  },
       { 1600, 1200, 75, 93.8  },
       { 1600, 1200, 85, 106.3 },
       { 1920, 1440, 60, 90.0  },
       { 1920, 1440, 75, 112.5 }
   };

   if(flag) { /* HSync */
      for(i = 0; i < 4; i++) {
    	 if(ddc->det_mon[i].type == DS_RANGES) {
            mon->nHsync = 1;
            mon->hsync[0].lo = ddc->det_mon[i].section.ranges.min_h;
            mon->hsync[0].hi = ddc->det_mon[i].section.ranges.max_h;
            return;
         }
      }
      /* If no sync ranges detected in detailed timing table, we
       * derive them from supported VESA modes. */
      myhlow = myhhigh = 0.0;
      for(i=0; i<11; i++) {
         if(myhtiming[i].whichone == 1) temp = ddc->timings1.t1;
	 else                           temp = ddc->timings1.t2;
	 if(temp & myhtiming[i].mask) {
	    if((i==0) || (myhlow > myhtiming[i].rate))
	            myhlow = myhtiming[i].rate;
	 }
	 if(myhtiming[10-i].whichone == 1) temp = ddc->timings1.t1;
	 else                              temp = ddc->timings1.t2;
	 if(temp & myhtiming[10-i].mask) {
	    if((i==0) || (myhhigh < myhtiming[10-i].rate))
	            myhhigh = myhtiming[10-i].rate;
	 }
      }
      for(i=0;i<STD_TIMINGS;i++) {
	 if(ddc->timings2[i].hsize > 256) {
            for(j=0; j<8; j++) {
	       if((ddc->timings2[i].hsize == mystdmodes[j].hsize) &&
	          (ddc->timings2[i].vsize == mystdmodes[j].vsize) &&
		  (ddc->timings2[i].refresh == mystdmodes[j].refresh)) {
		  if(mystdmodes[j].hsync > myhhigh)
		     myhhigh = mystdmodes[j].hsync;
	       }
	    }
	 }
      }
      if((myhhigh) && (myhlow)) {
         mon->nHsync = 1;
	 mon->hsync[0].lo = myhlow - 0.1;
	 mon->hsync[0].hi = myhhigh;
      }


   } else {  /* Vrefresh */

      for(i = 0; i < 4; i++) {
         if(ddc->det_mon[i].type == DS_RANGES) {
            mon->nVrefresh = 1;
            mon->vrefresh[0].lo = ddc->det_mon[i].section.ranges.min_v;
            mon->vrefresh[0].hi = ddc->det_mon[i].section.ranges.max_v;
            return;
         }
      }

      myvlow = myvhigh = 0;
      for(i=0; i<10; i++) {
         if(myvtiming[i].whichone == 1) temp = ddc->timings1.t1;
	 else                           temp = ddc->timings1.t2;
	 if(temp & myvtiming[i].mask) {
	    if((i==0) || (myvlow > myvtiming[i].rate))
	           myvlow = myvtiming[i].rate;
	 }
	 if(myvtiming[9-i].whichone == 1) temp = ddc->timings1.t1;
	 else                             temp = ddc->timings1.t2;
	 if(temp & myvtiming[9-i].mask) {
	    if((i==0) || (myvhigh < myvtiming[9-i].rate))
	           myvhigh = myvtiming[9-i].rate;
	 }
      }
      for(i=0;i<STD_TIMINGS;i++) {
	 if(ddc->timings2[i].hsize > 256) {
            for(j=0; j<8; j++) {
	       if((ddc->timings2[i].hsize == mystdmodes[j].hsize) &&
	          (ddc->timings2[i].vsize == mystdmodes[j].vsize) &&
		  (ddc->timings2[i].refresh == mystdmodes[j].refresh)) {
		  if(mystdmodes[j].refresh > myvhigh)
		     myvhigh = mystdmodes[j].refresh;
	       }
	    }
	 }
      }
      if((myvhigh) && (myvlow)) {
         mon->nVrefresh = 1;
	 mon->vrefresh[0].lo = myvlow;
	 mon->vrefresh[0].hi = myvhigh;
      }

    }
a621 1
/* Some helper functions for MergedFB mode */
d623 3
a625 7
#ifdef SISMERGED

/* Helper function for CRT2 monitor vrefresh/hsync options
 * (Code base from mga driver)
 */
static int
SiSStrToRanges(range *r, char *s, int max)
d627 9
a635 43
   float num = 0.0;
   int rangenum = 0;
   Bool gotdash = FALSE;
   Bool nextdash = FALSE;
   char* strnum = NULL;
   do {
      switch(*s) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '.':
         if(strnum == NULL) {
            strnum = s;
            gotdash = nextdash;
            nextdash = FALSE;
         }
         break;
      case '-':
      case ' ':
      case 0:
         if(strnum == NULL) break;
         sscanf(strnum, "%f", &num);
	 strnum = NULL;
         if(gotdash) {
            r[rangenum - 1].hi = num;
         } else {
            r[rangenum].lo = num;
            r[rangenum].hi = num;
            rangenum++;
         }
         if(*s == '-') nextdash = (rangenum != 0);
	 else if(rangenum >= max) return rangenum;
         break;
      default:
         return 0;
      }
d637 2
a638 21
   } while(*(s++) != 0);

   return rangenum;
}

/* Copy and link two modes form mergedfb mode
 * (Code base taken from mga driver)
 * Copys mode i, links the result to dest, and returns it.
 * Links i and j in Private record.
 * If dest is NULL, return value is copy of i linked to itself.
 * For mergedfb auto-config, we only check the dimension
 * against virtualX/Y, if they were user-provided.
 */
static DisplayModePtr
SiSCopyModeNLink(ScrnInfoPtr pScrn, DisplayModePtr dest,
                 DisplayModePtr i, DisplayModePtr j,
		 SiSScrn2Rel srel)
{
    SISPtr pSiS = SISPTR(pScrn);
    DisplayModePtr mode;
    int dx = 0,dy = 0;
d640 9
a648 83
    if(!((mode = xalloc(sizeof(DisplayModeRec))))) return dest;
    memcpy(mode, i, sizeof(DisplayModeRec));
    if(!((mode->Private = xalloc(sizeof(SiSMergedDisplayModeRec))))) {
       xfree(mode);
       return dest;
    }
    ((SiSMergedDisplayModePtr)mode->Private)->CRT1 = i;
    ((SiSMergedDisplayModePtr)mode->Private)->CRT2 = j;
    ((SiSMergedDisplayModePtr)mode->Private)->CRT2Position = srel;
    mode->PrivSize = 0;

    switch(srel) {
    case sisLeftOf:
    case sisRightOf:
       if(!(pScrn->display->virtualX)) {
          dx = i->HDisplay + j->HDisplay;
       } else {
          dx = min(pScrn->virtualX, i->HDisplay + j->HDisplay);
       }
       dx -= mode->HDisplay;
       if(!(pScrn->display->virtualY)) {
          dy = max(i->VDisplay, j->VDisplay);
       } else {
          dy = min(pScrn->virtualY, max(i->VDisplay, j->VDisplay));
       }
       dy -= mode->VDisplay;
       break;
    case sisAbove:
    case sisBelow:
       if(!(pScrn->display->virtualY)) {
          dy = i->VDisplay + j->VDisplay;
       } else {
          dy = min(pScrn->virtualY, i->VDisplay + j->VDisplay);
       }
       dy -= mode->VDisplay;
       if(!(pScrn->display->virtualX)) {
          dx = max(i->HDisplay, j->HDisplay);
       } else {
          dx = min(pScrn->virtualX, max(i->HDisplay, j->HDisplay));
       }
       dx -= mode->HDisplay;
       break;
    case sisClone:
       if(!(pScrn->display->virtualX)) {
          dx = max(i->HDisplay, j->HDisplay);
       } else {
          dx = min(pScrn->virtualX, max(i->HDisplay, j->HDisplay));
       }
       dx -= mode->HDisplay;
       if(!(pScrn->display->virtualY)) {
          dy = max(i->VDisplay, j->VDisplay);
       } else {
	  dy = min(pScrn->virtualY, max(i->VDisplay, j->VDisplay));
       }
       dy -= mode->VDisplay;
       break;
    }
    mode->HDisplay += dx;
    mode->HSyncStart += dx;
    mode->HSyncEnd += dx;
    mode->HTotal += dx;
    mode->VDisplay += dy;
    mode->VSyncStart += dy;
    mode->VSyncEnd += dy;
    mode->VTotal += dy;
    mode->Clock = 0;

    if( ((mode->HDisplay * ((pScrn->bitsPerPixel + 7) / 8) * mode->VDisplay) > pSiS->maxxfbmem) ||
        (mode->HDisplay > 4088) ||
	(mode->VDisplay > 4096) ) {

       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
       		"Skipped %dx%d, not enough video RAM or beyond hardware specs\n",
		mode->HDisplay, mode->VDisplay);
       xfree(mode->Private);
       xfree(mode);

       return dest;
    }

#ifdef SISXINERAMA
    if(srel != sisClone) {
       pSiS->AtLeastOneNonClone = TRUE;
a649 1
#endif
d651 12
a662 14
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
    	"Merged %dx%d and %dx%d to %dx%d%s\n",
	i->HDisplay, i->VDisplay, j->HDisplay, j->VDisplay,
	mode->HDisplay, mode->VDisplay, (srel == sisClone) ? " (Clone)" : "");

    mode->next = mode;
    mode->prev = mode;

    if(dest) {
       mode->next = dest->next; 	/* Insert node after "dest" */
       dest->next->prev = mode;
       mode->prev = dest;
       dest->next = mode;
    }
d664 3
a666 2
    return mode;
}
d668 3
a670 14
/* Helper function to find a mode from a given name
 * (Code base taken from mga driver)
 */
static DisplayModePtr
SiSGetModeFromName(char* str, DisplayModePtr i)
{
    DisplayModePtr c = i;
    if(!i) return NULL;
    do {
       if(strcmp(str, c->name) == 0) return c;
       c = c->next;
    } while(c != i);
    return NULL;
}
d672 1
a672 22
static DisplayModePtr
SiSFindWidestTallestMode(DisplayModePtr i, Bool tallest)
{
    DisplayModePtr c = i, d = NULL;
    int max = 0;
    if(!i) return NULL;
    do {
       if(tallest) {
          if(c->VDisplay > max) {
             max = c->VDisplay;
	     d = c;
          }
       } else {
          if(c->HDisplay > max) {
             max = c->HDisplay;
	     d = c;
          }
       }
       c = c->next;
    } while(c != i);
    return d;
}
d674 5
a678 11
static DisplayModePtr
SiSGenerateModeListFromLargestModes(ScrnInfoPtr pScrn,
		    DisplayModePtr i, DisplayModePtr j,
		    SiSScrn2Rel srel)
{
#ifdef SISXINERAMA
    SISPtr pSiS = SISPTR(pScrn);
#endif
    DisplayModePtr mode1 = NULL;
    DisplayModePtr mode2 = NULL;
    DisplayModePtr result = NULL;
d680 1
a680 3
#ifdef SISXINERAMA
    pSiS->AtLeastOneNonClone = FALSE;
#endif
d682 4
a685 15
    switch(srel) {
    case sisLeftOf:
    case sisRightOf:
       mode1 = SiSFindWidestTallestMode(i, FALSE);
       mode2 = SiSFindWidestTallestMode(j, FALSE);
       break;
    case sisAbove:
    case sisBelow:
       mode1 = SiSFindWidestTallestMode(i, TRUE);
       mode2 = SiSFindWidestTallestMode(j, TRUE);
       break;
    case sisClone:
       mode1 = i;
       mode2 = j;
    }
d687 3
a689 4
    if(mode1 && mode2) {
       return(SiSCopyModeNLink(pScrn, result, mode1, mode2, srel));
    } else {
       return NULL;
d691 2
a692 1
}
d694 4
a697 18
/* Generate the merged-fb mode modelist from metamodes
 * (Code base taken from mga driver)
 */
static DisplayModePtr
SiSGenerateModeListFromMetaModes(ScrnInfoPtr pScrn, char* str,
		    DisplayModePtr i, DisplayModePtr j,
		    SiSScrn2Rel srel)
{
#ifdef SISXINERAMA
    SISPtr pSiS = SISPTR(pScrn);
#endif
    char* strmode = str;
    char modename[256];
    Bool gotdash = FALSE;
    SiSScrn2Rel sr;
    DisplayModePtr mode1 = NULL;
    DisplayModePtr mode2 = NULL;
    DisplayModePtr result = NULL;
d699 4
a702 3
#ifdef SISXINERAMA
    pSiS->AtLeastOneNonClone = FALSE;
#endif
d704 11
a714 45
    do {
        switch(*str) {
        case 0:
        case '-':
        case ' ':
           if((strmode != str)) {

              strncpy(modename, strmode, str - strmode);
              modename[str - strmode] = 0;

              if(gotdash) {
                 if(mode1 == NULL) return NULL;
                 mode2 = SiSGetModeFromName(modename, j);
                 if(!mode2) {
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "Mode \"%s\" is not a supported mode for CRT2\n", modename);
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "Skipping metamode \"%s-%s\".\n", mode1->name, modename);
                    mode1 = NULL;
                 }
              } else {
                 mode1 = SiSGetModeFromName(modename, i);
                 if(!mode1) {
                    char* tmps = str;
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "Mode \"%s\" is not a supported mode for CRT1\n", modename);
                    gotdash = FALSE;
                    while(*tmps == ' ') tmps++;
                    if(*tmps == '-') { 							/* skip the next mode */
                       tmps++;
                       while((*tmps == ' ') && (*tmps != 0)) tmps++; 			/* skip spaces */
                       while((*tmps != ' ') && (*tmps != '-') && (*tmps != 0)) tmps++; 	/* skip modename */
                       strncpy(modename,strmode,tmps - strmode);
                       modename[tmps - strmode] = 0;
                       str = tmps-1;
                    }
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "Skipping metamode \"%s\".\n", modename);
                    mode1 = NULL;
                 }
              }
              gotdash = FALSE;
           }
           strmode = str + 1;
           gotdash |= (*str == '-');
d716 4
a719 2
           if(*str != 0) break;
	   /* Fall through otherwise */
d721 3
a723 20
        default:
           if(!gotdash && mode1) {
              sr = srel;
              if(!mode2) {
                 mode2 = SiSGetModeFromName(mode1->name, j);
                 sr = sisClone;
              }
              if(!mode2) {
                 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                     "Mode: \"%s\" is not a supported mode for CRT2\n", mode1->name);
                 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                     "Skipping metamode \"%s\".\n", modename);
                 mode1 = NULL;
              } else {
                 result = SiSCopyModeNLink(pScrn, result, mode1, mode2, sr);
                 mode1 = NULL;
                 mode2 = NULL;
              }
           }
           break;
d725 1
a725 1
        }
d727 2
a728 1
    } while(*(str++) != 0);
d730 3
a732 2
    return result;
}
d734 11
a744 15
static DisplayModePtr
SiSGenerateModeList(ScrnInfoPtr pScrn, char* str,
		    DisplayModePtr i, DisplayModePtr j,
		    SiSScrn2Rel srel)
{
   if(str != NULL) {
      return(SiSGenerateModeListFromMetaModes(pScrn, str, i, j, srel));
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
      	"No MetaModes given, linking %s modes by default\n",
	(srel == sisClone) ? "first" :
	   (((srel == sisLeftOf) || (srel == sisRightOf)) ? "widest" :  "tallest"));
      return(SiSGenerateModeListFromLargestModes(pScrn, i, j, srel));
   }
}
d746 14
a759 27
static void
SiSRecalcDefaultVirtualSize(ScrnInfoPtr pScrn)
{
    DisplayModePtr mode, bmode;
    int max;
    static const char *str = "MergedFB: Virtual %s %d\n";

    if(!(pScrn->display->virtualX)) {
       mode = bmode = pScrn->modes;
       max = 0;
       do {
          if(mode->HDisplay > max) max = mode->HDisplay;
          mode = mode->next;
       } while(mode != bmode);
       pScrn->virtualX = max;
       pScrn->displayWidth = max;
       xf86DrvMsg(pScrn->scrnIndex, X_PROBED, str, "width", max);
    }
    if(!(pScrn->display->virtualY)) {
       mode = bmode = pScrn->modes;
       max = 0;
       do {
          if(mode->VDisplay > max) max = mode->VDisplay;
          mode = mode->next;
       } while(mode != bmode);
       pScrn->virtualY = max;
       xf86DrvMsg(pScrn->scrnIndex, X_PROBED, str, "height", max);
a760 1
}
d762 14
a775 68
static void
SiSMergedFBSetDpi(ScrnInfoPtr pScrn1, ScrnInfoPtr pScrn2, SiSScrn2Rel srel)
{
   SISPtr pSiS = SISPTR(pScrn1);
   MessageType from = X_DEFAULT;
   xf86MonPtr DDC1 = (xf86MonPtr)(pScrn1->monitor->DDC);
   xf86MonPtr DDC2 = (xf86MonPtr)(pScrn2->monitor->DDC);
   int ddcWidthmm = 0, ddcHeightmm = 0;
   const char *dsstr = "MergedFB: Display dimensions: (%d, %d) mm\n";

   /* This sets the DPI for MergedFB mode. The problem is that
    * this can never be exact, because the output devices may
    * have different dimensions. This function tries to compromise
    * through a few assumptions, and it just calculates an average DPI
    * value for both monitors.
    */

   /* Given DisplaySize should regard BOTH monitors */
   pScrn1->widthmm = pScrn1->monitor->widthmm;
   pScrn1->heightmm = pScrn1->monitor->heightmm;

   /* Get DDC display size; if only either CRT1 or CRT2 provided these,
    * assume equal dimensions for both, otherwise add dimensions
    */
   if( (DDC1 && (DDC1->features.hsize > 0 && DDC1->features.vsize > 0)) &&
       (DDC2 && (DDC2->features.hsize > 0 && DDC2->features.vsize > 0)) ) {
      ddcWidthmm = max(DDC1->features.hsize, DDC2->features.hsize) * 10;
      ddcHeightmm = max(DDC1->features.vsize, DDC2->features.vsize) * 10;
      switch(srel) {
      case sisLeftOf:
      case sisRightOf:
         ddcWidthmm = (DDC1->features.hsize + DDC2->features.hsize) * 10;
	 break;
      case sisAbove:
      case sisBelow:
         ddcHeightmm = (DDC1->features.vsize + DDC2->features.vsize) * 10;
      default:
	 break;
      }
   } else if(DDC1 && (DDC1->features.hsize > 0 && DDC1->features.vsize > 0)) {
      ddcWidthmm = DDC1->features.hsize * 10;
      ddcHeightmm = DDC1->features.vsize * 10;
      switch(srel) {
      case sisLeftOf:
      case sisRightOf:
         ddcWidthmm *= 2;
	 break;
      case sisAbove:
      case sisBelow:
         ddcHeightmm *= 2;
      default:
	 break;
      }
   } else if(DDC2 && (DDC2->features.hsize > 0 && DDC2->features.vsize > 0) ) {
      ddcWidthmm = DDC2->features.hsize * 10;
      ddcHeightmm = DDC2->features.vsize * 10;
      switch(srel) {
      case sisLeftOf:
      case sisRightOf:
         ddcWidthmm *= 2;
	 break;
      case sisAbove:
      case sisBelow:
         ddcHeightmm *= 2;
      default:
	 break;
      }
   }
a776 1
   if(monitorResolution > 0) {
d778 20
a797 37
      /* Set command line given values (overrules given options) */
      pScrn1->xDpi = monitorResolution;
      pScrn1->yDpi = monitorResolution;
      from = X_CMDLINE;

   } else if(pSiS->MergedFBXDPI) {

      /* Set option-wise given values (overrule DisplaySize) */
      pScrn1->xDpi = pSiS->MergedFBXDPI;
      pScrn1->yDpi = pSiS->MergedFBYDPI;
      from = X_CONFIG;

   } else if(pScrn1->widthmm > 0 || pScrn1->heightmm > 0) {

      /* Set values calculated from given DisplaySize */
      from = X_CONFIG;
      if(pScrn1->widthmm > 0) {
	 pScrn1->xDpi = (int)((double)pScrn1->virtualX * 25.4 / pScrn1->widthmm);
      }
      if(pScrn1->heightmm > 0) {
	 pScrn1->yDpi = (int)((double)pScrn1->virtualY * 25.4 / pScrn1->heightmm);
      }
      xf86DrvMsg(pScrn1->scrnIndex, from, dsstr, pScrn1->widthmm, pScrn1->heightmm);

    } else if(ddcWidthmm && ddcHeightmm) {

      /* Set values from DDC-provided display size */
      from = X_PROBED;
      xf86DrvMsg(pScrn1->scrnIndex, from, dsstr, ddcWidthmm, ddcHeightmm );
      pScrn1->widthmm = ddcWidthmm;
      pScrn1->heightmm = ddcHeightmm;
      if(pScrn1->widthmm > 0) {
	 pScrn1->xDpi = (int)((double)pScrn1->virtualX * 25.4 / pScrn1->widthmm);
      }
      if(pScrn1->heightmm > 0) {
	 pScrn1->yDpi = (int)((double)pScrn1->virtualY * 25.4 / pScrn1->heightmm);
      }
d799 2
a800 1
    } else {
d802 14
a815 1
      pScrn1->xDpi = pScrn1->yDpi = DEFAULT_DPI;
d817 1
a817 1
    }
d819 3
a821 5
    /* Sanity check */
    if(pScrn1->xDpi > 0 && pScrn1->yDpi <= 0)
       pScrn1->yDpi = pScrn1->xDpi;
    if(pScrn1->yDpi > 0 && pScrn1->xDpi <= 0)
       pScrn1->xDpi = pScrn1->yDpi;
d823 7
a829 2
    pScrn2->xDpi = pScrn1->xDpi;
    pScrn2->yDpi = pScrn1->yDpi;
d831 7
a837 3
    xf86DrvMsg(pScrn1->scrnIndex, from, "MergedFB: DPI set to (%d, %d)\n",
	       pScrn1->xDpi, pScrn1->yDpi);
}
d839 11
a849 2
/* Pseudo-Xinerama extension for MergedFB mode */
#ifdef SISXINERAMA
d851 3
a853 8
static void
SiSUpdateXineramaScreenInfo(ScrnInfoPtr pScrn1)
{
    SISPtr pSiS = SISPTR(pScrn1);
    int crt1scrnnum = 0, crt2scrnnum = 1;
    int x1=0, x2=0, y1=0, y2=0, h1=0, h2=0, w1=0, w2=0;
    DisplayModePtr currentMode, firstMode;
    Bool infochanged = FALSE;
d855 2
a856 1
    if(!pSiS->MergedFB) return;
d858 4
a861 1
    if(SiSnoPanoramiXExtension) return;
d863 2
a864 1
    if(!SiSXineramadataPtr) return;
d866 3
a868 3
    if(pSiS->CRT2IsScrn0) {
       crt1scrnnum = 1;
       crt2scrnnum = 0;
d871 1
a871 6
    /* Attention: Usage of RandR may lead into virtual X and Y values
     * actually smaller than our MetaModes! To avoid this, we calculate
     * the maxCRT fields here (and not somewhere else, like in CopyNLink)
     *
     * *** For now: RandR will be disabled if SiS pseudo-Xinerama is on
     */
d873 1
a873 1
    if((pSiS->SiSXineramaVX != pScrn1->virtualX) || (pSiS->SiSXineramaVY != pScrn1->virtualY)) {
d875 2
a876 1
       if(!(pScrn1->modes)) return;
d878 4
a881 119
       pSiS->maxCRT1_X1 = pSiS->maxCRT1_X2 = 0;
       pSiS->maxCRT1_Y1 = pSiS->maxCRT1_Y2 = 0;
       pSiS->maxCRT2_X1 = pSiS->maxCRT2_X2 = 0;
       pSiS->maxCRT2_Y1 = pSiS->maxCRT2_Y2 = 0;
       pSiS->maxClone_X1 = pSiS->maxClone_X2 = 0;
       pSiS->maxClone_Y1 = pSiS->maxClone_Y2 = 0;

       currentMode = firstMode = pScrn1->modes;

       do {

          DisplayModePtr p = currentMode->next;
          DisplayModePtr i = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT1;
          DisplayModePtr j = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT2;
          SiSScrn2Rel srel = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT2Position;

          if((i->HDisplay <= pScrn1->virtualX) && (j->HDisplay <= pScrn1->virtualX) &&
             (i->VDisplay <= pScrn1->virtualY) && (j->VDisplay <= pScrn1->virtualY)) {

             if(srel != sisClone) {
                if(pSiS->maxCRT1_X1 <= i->HDisplay) {
                   pSiS->maxCRT1_X1 = i->HDisplay;      /* Largest CRT1 mode */
                   if(pSiS->maxCRT1_X2 < j->HDisplay) {
                      pSiS->maxCRT1_X2 = j->HDisplay;   /* Largest X of CRT2 mode displayed with largest CRT1 mode */
                   }
                }
                if(pSiS->maxCRT2_X2 <= j->HDisplay) {
                   pSiS->maxCRT2_X2 = j->HDisplay;      /* Largest CRT2 mode */
                   if(pSiS->maxCRT2_X1 < i->HDisplay) {
                      pSiS->maxCRT2_X1 = i->HDisplay;   /* Largest X of CRT1 mode displayed with largest CRT2 mode */
                   }
                }
                if(pSiS->maxCRT1_Y1 <= i->VDisplay) {
                   pSiS->maxCRT1_Y1 = i->VDisplay;
                   if(pSiS->maxCRT1_Y2 < j->VDisplay) {
                      pSiS->maxCRT1_Y2 = j->VDisplay;
                   }
                }
                if(pSiS->maxCRT2_Y2 <= j->VDisplay) {
                   pSiS->maxCRT2_Y2 = j->VDisplay;
                   if(pSiS->maxCRT2_Y1 < i->VDisplay) {
                      pSiS->maxCRT2_Y1 = i->VDisplay;
                   }
                }
             } else {
                if(pSiS->maxClone_X1 < i->HDisplay) {
                   pSiS->maxClone_X1 = i->HDisplay;
                }
                if(pSiS->maxClone_X2 < j->HDisplay) {
                   pSiS->maxClone_X2 = j->HDisplay;
                }
                if(pSiS->maxClone_Y1 < i->VDisplay) {
                   pSiS->maxClone_Y1 = i->VDisplay;
                }
                if(pSiS->maxClone_Y2 < j->VDisplay) {
                   pSiS->maxClone_Y2 = j->VDisplay;
                }
             }
          }
          currentMode = p;

       } while((currentMode) && (currentMode != firstMode));

       pSiS->SiSXineramaVX = pScrn1->virtualX;
       pSiS->SiSXineramaVY = pScrn1->virtualY;
       infochanged = TRUE;

    }

    switch(pSiS->CRT2Position) {
    case sisLeftOf:
       x1 = min(pSiS->maxCRT1_X2, pScrn1->virtualX - pSiS->maxCRT1_X1);
       if(x1 < 0) x1 = 0;
       y1 = 0;
       w1 = pScrn1->virtualX - x1;
       h1 = pScrn1->virtualY;
       x2 = 0;
       y2 = 0;
       w2 = max(pSiS->maxCRT2_X2, pScrn1->virtualX - pSiS->maxCRT2_X1);
       if(w2 > pScrn1->virtualX) w2 = pScrn1->virtualX;
       h2 = pScrn1->virtualY;
       break;
    case sisRightOf:
       x1 = 0;
       y1 = 0;
       w1 = max(pSiS->maxCRT1_X1, pScrn1->virtualX - pSiS->maxCRT1_X2);
       if(w1 > pScrn1->virtualX) w1 = pScrn1->virtualX;
       h1 = pScrn1->virtualY;
       x2 = min(pSiS->maxCRT2_X1, pScrn1->virtualX - pSiS->maxCRT2_X2);
       if(x2 < 0) x2 = 0;
       y2 = 0;
       w2 = pScrn1->virtualX - x2;
       h2 = pScrn1->virtualY;
       break;
    case sisAbove:
       x1 = 0;
       y1 = min(pSiS->maxCRT1_Y2, pScrn1->virtualY - pSiS->maxCRT1_Y1);
       if(y1 < 0) y1 = 0;
       w1 = pScrn1->virtualX;
       h1 = pScrn1->virtualY - y1;
       x2 = 0;
       y2 = 0;
       w2 = pScrn1->virtualX;
       h2 = max(pSiS->maxCRT2_Y2, pScrn1->virtualY - pSiS->maxCRT2_Y1);
       if(h2 > pScrn1->virtualY) h2 = pScrn1->virtualY;
       break;
    case sisBelow:
       x1 = 0;
       y1 = 0;
       w1 = pScrn1->virtualX;
       h1 = max(pSiS->maxCRT1_Y1, pScrn1->virtualY - pSiS->maxCRT1_Y2);
       if(h1 > pScrn1->virtualY) h1 = pScrn1->virtualY;
       x2 = 0;
       y2 = min(pSiS->maxCRT2_Y1, pScrn1->virtualY - pSiS->maxCRT2_Y2);
       if(y2 < 0) y2 = 0;
       w2 = pScrn1->virtualX;
       h2 = pScrn1->virtualY - y2;
    default:
       break;
d883 4
a886 17

    SiSXineramadataPtr[crt1scrnnum].x = x1;
    SiSXineramadataPtr[crt1scrnnum].y = y1;
    SiSXineramadataPtr[crt1scrnnum].width = w1;
    SiSXineramadataPtr[crt1scrnnum].height = h1;
    SiSXineramadataPtr[crt2scrnnum].x = x2;
    SiSXineramadataPtr[crt2scrnnum].y = y2;
    SiSXineramadataPtr[crt2scrnnum].width = w2;
    SiSXineramadataPtr[crt2scrnnum].height = h2;

    if(infochanged) {
       xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
          "Pseudo-Xinerama: CRT1 (Screen %d) (%d,%d)-(%d,%d)\n",
          crt1scrnnum, x1, y1, w1+x1-1, h1+y1-1);
       xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
          "Pseudo-Xinerama: CRT2 (Screen %d) (%d,%d)-(%d,%d)\n",
          crt2scrnnum, x2, y2, w2+x2-1, h2+y2-1);
a887 1
}
d889 2
a890 1
/* Proc */
d892 10
a901 17
int
SiSProcXineramaQueryVersion(ClientPtr client)
{
    xPanoramiXQueryVersionReply	  rep;
    register int		  n;

    REQUEST_SIZE_MATCH(xPanoramiXQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SIS_XINERAMA_MAJOR_VERSION;
    rep.minorVersion = SIS_XINERAMA_MINOR_VERSION;
    if(client->swapped) {
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swaps(&rep.majorVersion, n);
        swaps(&rep.minorVersion, n);
a902 3
    WriteToClient(client, sizeof(xPanoramiXQueryVersionReply), (char *)&rep);
    return (client->noClientException);
}
d904 2
a905 24
int
SiSProcXineramaGetState(ClientPtr client)
{
    REQUEST(xPanoramiXGetStateReq);
    WindowPtr			pWin;
    xPanoramiXGetStateReply	rep;
    register int		n;

    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
    pWin = LookupWindow(stuff->window, client);
    if(!pWin) return BadWindow;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.state = !SiSnoPanoramiXExtension;
    if(client->swapped) {
       swaps (&rep.sequenceNumber, n);
       swapl (&rep.length, n);
       swaps (&rep.state, n);
    }
    WriteToClient(client, sizeof(xPanoramiXGetStateReply), (char *)&rep);
    return client->noClientException;
}
d907 9
a915 20
int
SiSProcXineramaGetScreenCount(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenCountReq);
    WindowPtr				pWin;
    xPanoramiXGetScreenCountReply	rep;
    register int			n;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
    pWin = LookupWindow(stuff->window, client);
    if(!pWin) return BadWindow;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.ScreenCount = SiSXineramaNumScreens;
    if(client->swapped) {
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swaps(&rep.ScreenCount, n);
a916 3
    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), (char *)&rep);
    return client->noClientException;
}
d918 3
a920 26
int
SiSProcXineramaGetScreenSize(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenSizeReq);
    WindowPtr				pWin;
    xPanoramiXGetScreenSizeReply	rep;
    register int			n;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
    pWin = LookupWindow (stuff->window, client);
    if(!pWin)  return BadWindow;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.width  = SiSXineramadataPtr[stuff->screen].width;
    rep.height = SiSXineramadataPtr[stuff->screen].height;
    if(client->swapped) {
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swaps(&rep.width, n);
       swaps(&rep.height, n);
    }
    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), (char *)&rep);
    return client->noClientException;
}
d922 3
a924 4
int
SiSProcXineramaIsActive(ClientPtr client)
{
    xXineramaIsActiveReply	rep;
d926 6
a931 1
    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
d933 4
a936 9
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.state = !SiSnoPanoramiXExtension;
    if(client->swapped) {
	register int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.state, n);
a937 3
    WriteToClient(client, sizeof(xXineramaIsActiveReply), (char *) &rep);
    return client->noClientException;
}
d939 9
a947 4
int
SiSProcXineramaQueryScreens(ClientPtr client)
{
    xXineramaQueryScreensReply	rep;
d949 24
a972 1
    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
d974 43
a1016 30
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.number = (SiSnoPanoramiXExtension) ? 0 : SiSXineramaNumScreens;
    rep.length = rep.number * sz_XineramaScreenInfo >> 2;
    if(client->swapped) {
       register int n;
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swapl(&rep.number, n);
    }
    WriteToClient(client, sizeof(xXineramaQueryScreensReply), (char *)&rep);

    if(!SiSnoPanoramiXExtension) {
       xXineramaScreenInfo scratch;
       int i;

       for(i = 0; i < SiSXineramaNumScreens; i++) {
	  scratch.x_org  = SiSXineramadataPtr[i].x;
	  scratch.y_org  = SiSXineramadataPtr[i].y;
	  scratch.width  = SiSXineramadataPtr[i].width;
	  scratch.height = SiSXineramadataPtr[i].height;
	  if(client->swapped) {
	     register int n;
	     swaps(&scratch.x_org, n);
	     swaps(&scratch.y_org, n);
	     swaps(&scratch.width, n);
    	     swaps(&scratch.height, n);
	  }
	  WriteToClient(client, sz_XineramaScreenInfo, (char *)&scratch);
       }
d1019 4
a1022 20
    return client->noClientException;
}

static int
SiSProcXineramaDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
	case X_PanoramiXQueryVersion:
	     return SiSProcXineramaQueryVersion(client);
	case X_PanoramiXGetState:
	     return SiSProcXineramaGetState(client);
	case X_PanoramiXGetScreenCount:
	     return SiSProcXineramaGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return SiSProcXineramaGetScreenSize(client);
	case X_XineramaIsActive:
	     return SiSProcXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return SiSProcXineramaQueryScreens(client);
d1024 2
a1025 2
    return BadRequest;
}
d1027 8
a1034 1
/* SProc */
d1036 1
a1036 9
static int
SiSSProcXineramaQueryVersion (ClientPtr client)
{
    REQUEST(xPanoramiXQueryVersionReq);
    register int n;
    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
    return SiSProcXineramaQueryVersion(client);
}
d1038 2
a1039 9
static int
SiSSProcXineramaGetState(ClientPtr client)
{
    REQUEST(xPanoramiXGetStateReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
    return SiSProcXineramaGetState(client);
}
d1041 4
a1044 9
static int
SiSSProcXineramaGetScreenCount(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenCountReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
    return SiSProcXineramaGetScreenCount(client);
}
d1046 7
a1052 9
static int
SiSSProcXineramaGetScreenSize(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenSizeReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
    return SiSProcXineramaGetScreenSize(client);
}
d1054 19
a1072 37
static int
SiSSProcXineramaIsActive(ClientPtr client)
{
    REQUEST(xXineramaIsActiveReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
    return SiSProcXineramaIsActive(client);
}

static int
SiSSProcXineramaQueryScreens(ClientPtr client)
{
    REQUEST(xXineramaQueryScreensReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
    return SiSProcXineramaQueryScreens(client);
}

int
SiSSProcXineramaDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
	case X_PanoramiXQueryVersion:
	     return SiSSProcXineramaQueryVersion(client);
	case X_PanoramiXGetState:
	     return SiSSProcXineramaGetState(client);
	case X_PanoramiXGetScreenCount:
	     return SiSSProcXineramaGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return SiSSProcXineramaGetScreenSize(client);
	case X_XineramaIsActive:
	     return SiSSProcXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return SiSSProcXineramaQueryScreens(client);
d1074 2
a1075 2
    return BadRequest;
}
d1077 11
a1087 9
static void
SiSXineramaResetProc(ExtensionEntry* extEntry)
{
    /* Called by CloseDownExtensions() */
    if(SiSXineramadataPtr) {
       Xfree(SiSXineramadataPtr);
       SiSXineramadataPtr = NULL;
    }
}
d1089 6
a1094 5
static void
SiSXineramaExtensionInit(ScrnInfoPtr pScrn)
{
    SISPtr    	pSiS = SISPTR(pScrn);
    Bool	success = FALSE;
d1096 13
a1108 1
    if(!(SiSXineramadataPtr)) {
d1110 4
a1113 4
       if(!pSiS->MergedFB) {
          SiSnoPanoramiXExtension = TRUE;
          return;
       }
d1115 2
a1116 8
#ifdef PANORAMIX
       if(!noPanoramiXExtension) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	     "Xinerama active, not initializing SiS Pseudo-Xinerama\n");
          SiSnoPanoramiXExtension = TRUE;
          return;
       }
#endif
d1118 5
a1122 5
       if(SiSnoPanoramiXExtension) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	      "SiS Pseudo-Xinerama disabled\n");
          return;
       }
d1124 1
a1124 6
       if(pSiS->CRT2Position == sisClone) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	     "Running MergedFB in Clone mode, SiS Pseudo-Xinerama disabled\n");
          SiSnoPanoramiXExtension = TRUE;
          return;
       }
d1126 2
a1127 6
       if(!(pSiS->AtLeastOneNonClone)) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	     "Only Clone modes defined, SiS Pseudo-Xinerama disabled\n");
          SiSnoPanoramiXExtension = TRUE;
          return;
       }
d1129 2
a1130 1
       SiSXineramaNumScreens = 2;
d1132 2
a1133 1
       while(SiSXineramaGeneration != serverGeneration) {
d1135 17
a1151 5
	  pSiS->XineramaExtEntry = AddExtension(PANORAMIX_PROTOCOL_NAME, 0,0,
					SiSProcXineramaDispatch,
					SiSSProcXineramaDispatch,
					SiSXineramaResetProc,
					StandardMinorOpcode);
d1153 4
a1156 1
	  if(!pSiS->XineramaExtEntry) break;
d1158 7
a1164 2
	  if(!(SiSXineramadataPtr = (SiSXineramaData *)
	        xcalloc(SiSXineramaNumScreens, sizeof(SiSXineramaData)))) break;
d1166 4
a1169 3
	  SiSXineramaGeneration = serverGeneration;
	  success = TRUE;
       }
d1171 1
a1171 5
       if(!success) {
          SISErrorLog(pScrn, "Failed to initialize SiS Pseudo-Xinerama extension\n");
          SiSnoPanoramiXExtension = TRUE;
          return;
       }
d1173 7
a1179 2
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
    	  "SiS Pseudo-Xinerama extension initialized\n");
d1181 2
a1182 2
       pSiS->SiSXineramaVX = 0;
       pSiS->SiSXineramaVY = 0;
d1184 7
d1193 7
a1199 1
    SiSUpdateXineramaScreenInfo(pScrn);
d1201 5
a1205 2
}
#endif  /* End of PseudoXinerama */
d1207 32
a1238 20
static void
SiSFreeCRT2Structs(SISPtr pSiS)
{
    if(pSiS->CRT2pScrn) {
       if(pSiS->CRT2pScrn->modes) {
          while(pSiS->CRT2pScrn->modes)
  	     xf86DeleteMode(&pSiS->CRT2pScrn->modes, pSiS->CRT2pScrn->modes);
       }
       if(pSiS->CRT2pScrn->monitor) {
          if(pSiS->CRT2pScrn->monitor->Modes) {
             while(pSiS->CRT2pScrn->monitor->Modes)
  	        xf86DeleteMode(&pSiS->CRT2pScrn->monitor->Modes, pSiS->CRT2pScrn->monitor->Modes);
	  }
	  if(pSiS->CRT2pScrn->monitor->DDC) xfree(pSiS->CRT2pScrn->monitor->DDC);
	  xfree(pSiS->CRT2pScrn->monitor);
       }
       xfree(pSiS->CRT2pScrn);
       pSiS->CRT2pScrn = NULL;
   }
}
d1240 1
a1240 71
#endif	/* End of MergedFB helpers */

static xf86MonPtr
SiSInternalDDC(ScrnInfoPtr pScrn, int crtno)
{
   SISPtr        pSiS = SISPTR(pScrn);
   USHORT        temp = 0xffff, temp1, i, realcrtno = crtno;
   unsigned char buffer[256];
   xf86MonPtr    pMonitor = NULL;

   /* If CRT1 is off, skip DDC */
   if((pSiS->CRT1off) && (!crtno)) return NULL;

   if(crtno) {
      if(pSiS->VBFlags & CRT2_LCD)      realcrtno = 1;
      else if(pSiS->VBFlags & CRT2_VGA) realcrtno = 2;
      else return NULL;
   } else {
      /* If CRT1 is LCDA, skip DDC (except 301C: DDC allowed, but uses CRT2 port!) */
      if(pSiS->VBFlags & CRT1_LCDA) {
         if(pSiS->VBFlags & VB_301C)    realcrtno = 1;
         else return NULL;
      }
   }

   i = 3; /* Number of retrys */
   do {
      temp1 = SiS_HandleDDC(pSiS->SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine, realcrtno, 0, &buffer[0]);
      if((temp1) && (temp1 != 0xffff)) temp = temp1;
   } while((temp == 0xffff) && i--);
   if(temp != 0xffff) {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "CRT%d DDC supported\n", crtno + 1);
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "CRT%d DDC level: %s%s%s%s\n",
	     crtno + 1,
	     (temp & 0x1a) ? "" : "[none of the supported]",
	     (temp & 0x02) ? "2 " : "",
	     (temp & 0x08) ? "D&P" : "",
             (temp & 0x10) ? "FPDI-2" : "");
      if(temp & 0x02) {
	 i = 5;  /* Number of retrys */
	 do {
	    temp = SiS_HandleDDC(pSiS->SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine, realcrtno, 1, &buffer[0]);
	 } while((temp) && i--);
         if(!temp) {
	    if((pMonitor = xf86InterpretEDID(pScrn->scrnIndex, &buffer[0]))) {
	       return(pMonitor);
	    } else {
	       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	           "CRT%d DDC EDID corrupt\n", crtno + 1);
	       return(NULL);
	    }
	 } else {
            xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    	"CRT%d DDC reading failed\n", crtno + 1);
	    return(NULL);
	 }
      } else if(!crtno) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "DDC for VESA D&P and FPDI-2 not supported for CRT1.\n");
         return(NULL);
      } else if(temp & 0x18) {
         xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "DDC for VESA D&P and FPDI-2 not supported for CRT2 yet.\n");
         return(NULL);
      } 
      return(NULL);
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
                "CRT%d DDC probing failed\n", crtno + 1);
      return(NULL);
   }
a1242 4
static xf86MonPtr
SiSDoPrivateDDC(ScrnInfoPtr pScrn, int *crtnum)
{
    SISPtr pSiS = SISPTR(pScrn);
d1244 3
a1246 58
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       if(pSiS->SecondHead) {
          *crtnum = 1;
	  return(SiSInternalDDC(pScrn, 0));
       } else {
          *crtnum = 2;
	  return(SiSInternalDDC(pScrn, 1));
       }
    } else
#endif
    if(pSiS->CRT1off) {
       *crtnum = 2;
       return(SiSInternalDDC(pScrn, 1));
    } else {
       *crtnum = 1;
       return(SiSInternalDDC(pScrn, 0));
    }
}

static BOOLEAN
SiSMakeOwnModeList(ScrnInfoPtr pScrn, BOOLEAN acceptcustommodes, BOOLEAN includelcdmodes,
                   BOOLEAN isfordvi, BOOLEAN *havecustommodes)
{
    DisplayModePtr tempmode, delmode, mymodes;

    if((mymodes = SiSBuildBuiltInModeList(pScrn, includelcdmodes, isfordvi))) {
       if(!acceptcustommodes) {
	  while(pScrn->monitor->Modes)
             xf86DeleteMode(&pScrn->monitor->Modes, pScrn->monitor->Modes);
	  pScrn->monitor->Modes = mymodes;
       } else {
	  delmode = pScrn->monitor->Modes;
	  while(delmode) {
	     if(delmode->type & M_T_DEFAULT) {
	        tempmode = delmode->next;
	        xf86DeleteMode(&pScrn->monitor->Modes, delmode);
	        delmode = tempmode;
	     } else {
	        delmode = delmode->next;
	     }
	  }
	  tempmode = pScrn->monitor->Modes;
	  if(tempmode) *havecustommodes = TRUE;
	  pScrn->monitor->Modes = mymodes;
	  while(mymodes) {
	     if(!mymodes->next) break;
	     else mymodes = mymodes->next;
	  }
	  mymodes->next = tempmode;
	  if(tempmode) {
	     tempmode->prev = mymodes;
	  }
       }
       return TRUE;
    } else
       return FALSE;
}
a1247 1
/* Mandatory */
d1249 1
a1249 1
SISPreInit(ScrnInfoPtr pScrn, int flags)
d1252 1
a1252 18
    MessageType from;
    unsigned char usScratchCR17, CR5F;
    unsigned char usScratchCR32, usScratchCR63;
    unsigned char usScratchSR1F;
    unsigned long int i;
    int temp;
    ClockRangePtr clockRanges;
    int pix24flags;
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif
#if defined(SISMERGED) || defined(SISDUALHEAD)
    DisplayModePtr first, p, n;
#endif
    unsigned char srlockReg,crlockReg;
    unsigned char tempreg;
    xf86MonPtr pMonitor = NULL;
    Bool didddc2;
d1254 1
a1254 35
    vbeInfoPtr pVbe;
    VbeInfoBlock *vbe;

    static const char *ddcsstr = "CRT%d DDC monitor info: ************************************\n";
    static const char *ddcestr = "End of CRT%d DDC monitor info ******************************\n";
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,14,0)
    static const char *subshstr = "Substituting missing CRT%d monitor HSync data by DDC data\n";
    static const char *subsvstr = "Substituting missing CRT%d monitor VRefresh data by DDC data\n";
#endif
#ifdef SISMERGED
    static const char *mergednocrt1 = "CRT1 not detected or forced off. %s.\n";
    static const char *mergednocrt2 = "No CRT2 output selected or no bridge detected. %s.\n";
    static const char *mergeddisstr = "MergedFB mode disabled";
    static const char *modesforstr = "Modes for CRT%d: *********************************************\n";
    static const char *crtsetupstr = "------------------------ CRT%d setup -------------------------\n";
#endif
#if defined(SISDUALHEAD) || defined(SISMERGED)
    static const char *notsuitablestr = "Not using mode \"%s\" (not suitable for %s mode)\n";
#endif

    if(flags & PROBE_DETECT) {
       if(xf86LoadSubModule(pScrn, "vbe")) {
          int index = xf86GetEntityInfo(pScrn->entityList[0])->index;

#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	  if((pVbe = VBEInit(NULL,index))) {
#else
          if((pVbe = VBEExtendedInit(NULL,index,0))) {
#endif
             ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
             vbeFree(pVbe);
          }
       }
       return TRUE;
    }
d1257 1
a1257 118
     * Note: This function is only called once at server startup, and
     * not at the start of each server generation.  This means that
     * only things that are persistent across server generations can
     * be initialised here.  xf86Screens[] is the array of all screens,
     * (pScrn is a pointer to one of these).  Privates allocated using
     * xf86AllocateScrnInfoPrivateIndex() are too, and should be used
     * for data that must persist across server generations.
     *
     * Per-generation data should be allocated with
     * AllocateScreenPrivateIndex() from the ScreenInit() function.
     */

    /* Check the number of entities, and fail if it isn't one. */
    if(pScrn->numEntities != 1) {
       SISErrorLog(pScrn, "Number of entities is not 1\n");
       return FALSE;
    }

    /* The vgahw module should be loaded here when needed */
    if(!xf86LoadSubModule(pScrn, "vgahw")) {
       SISErrorLog(pScrn, "Could not load vgahw module\n");
       return FALSE;
    }

    xf86LoaderReqSymLists(vgahwSymbols, NULL);

    /* Due to the liberal license terms this is needed for
     * keeping the copyright notice readable and intact in
     * binary distributions. Removing this is a copyright
     * infringement. Please read the license terms above.
     */

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
        "SiS driver (%d/%02d/%02d-%d)\n",
	SISDRIVERVERSIONYEAR + 2000, SISDRIVERVERSIONMONTH,
	SISDRIVERVERSIONDAY, SISDRIVERREVISION);
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	"Copyright (C) 2001-2004 Thomas Winischhofer <thomas@@winischhofer.net> and others\n");
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
        "Compiled for XFree86 %d.%d.%d.%d\n",
	XF86_VERSION_MAJOR, XF86_VERSION_MINOR,
	XF86_VERSION_PATCH, XF86_VERSION_SNAP);
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
    if(xf86GetVersion() != XF86_VERSION_CURRENT) {
       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
         "This version of the driver is not compiled for this version of XFree86!\n");
    }
#endif
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
        "See http://www.winischhofer.net/linuxsisvga.shtml "
	"for documentation and updates\n");

    /* Allocate a vgaHWRec */
    if(!vgaHWGetHWRec(pScrn)) {
       SISErrorLog(pScrn, "Could not allocate VGA private\n");
       return FALSE;
    }

    /* Allocate the SISRec driverPrivate */
    if(!SISGetRec(pScrn)) {
       SISErrorLog(pScrn, "Could not allocate memory for pSiS private\n");
       return FALSE;
    }
    pSiS = SISPTR(pScrn);
    pSiS->pScrn = pScrn;

#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    pSiS->IODBase = 0;
#else
    pSiS->IODBase = pScrn->domainIOBase;  
#endif

    /* Get the entity, and make sure it is PCI. */
    pSiS->pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
    if(pSiS->pEnt->location.type != BUS_PCI)  {
       SISErrorLog(pScrn, "Entity's bus type is not PCI\n");
       SISFreeRec(pScrn);
       return FALSE;
    }

#ifdef SISDUALHEAD
    /* Allocate an entity private if necessary */
    if(xf86IsEntityShared(pScrn->entityList[0])) {
       pSiSEnt = xf86GetEntityPrivate(pScrn->entityList[0],
					SISEntityIndex)->ptr;
       pSiS->entityPrivate = pSiSEnt;

       /* If something went wrong, quit here */
       if((pSiSEnt->DisableDual) || (pSiSEnt->ErrorAfterFirst)) {
	  SISErrorLog(pScrn, "First head encountered fatal error, can't continue\n");
	  SISFreeRec(pScrn);
	  return FALSE;
       }
    }
#endif

    /* Find the PCI info for this screen */
    pSiS->PciInfo = xf86GetPciInfoForEntity(pSiS->pEnt->index);
    pSiS->PciTag = pSiS->sishw_ext.PciTag = pciTag(pSiS->PciInfo->bus,
                           pSiS->PciInfo->device, pSiS->PciInfo->func);

    pSiS->Primary = xf86IsPrimaryPci(pSiS->PciInfo);
    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
    	"This adapter is %s display adapter\n",
	(pSiS->Primary ? "primary" : "secondary"));

    if(pSiS->Primary) {
       VGAHWPTR(pScrn)->MapSize = 0x10000;     /* Standard 64k VGA window */
       if(!vgaHWMapMem(pScrn)) {
          SISErrorLog(pScrn, "Could not map VGA memory\n");
          SISFreeRec(pScrn);
          return FALSE;
       }
    }
    vgaHWGetIOBase(VGAHWPTR(pScrn));

    /* We "patch" the PIOOffset inside vgaHW in order to force
     * the vgaHW module to use our relocated i/o ports.
a1258 4
    VGAHWPTR(pScrn)->PIOOffset = pSiS->IODBase + (pSiS->PciInfo->ioBase[2] & 0xFFFC) - 0x380;

    pSiS->pInt = NULL;
    if(!pSiS->Primary) {
d1260 1
a1260 21
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       		"Initializing display adapter through int10\n");
#endif
       if(xf86LoadSubModule(pScrn, "int10")) {
          xf86LoaderReqSymLists(int10Symbols, NULL);
#if !defined(__alpha__)
          pSiS->pInt = xf86InitInt10(pSiS->pEnt->index);
#endif
       } else {
          SISErrorLog(pScrn, "Could not load int10 module\n");
       }
    }

#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    {
        resRange vgamem[] = {   {ResShrMemBlock,0xA0000,0xAFFFF},
                                {ResShrMemBlock,0xB0000,0xB7FFF},
                                {ResShrMemBlock,0xB8000,0xBFFFF},
                            _END };
        xf86SetOperatingState(vgamem, pSiS->pEnt->index, ResUnusedOpr);
    }
a1261 24
    xf86SetOperatingState(resVgaMem, pSiS->pEnt->index, ResUnusedOpr);
#endif

    /* Operations for which memory access is required */
    pScrn->racMemFlags = RAC_FB | RAC_COLORMAP | RAC_CURSOR | RAC_VIEWPORT;
    /* Operations for which I/O access is required */
    pScrn->racIoFlags = RAC_COLORMAP | RAC_CURSOR | RAC_VIEWPORT;

    /* The ramdac module should be loaded here when needed */
    if(!xf86LoadSubModule(pScrn, "ramdac")) {
       SISErrorLog(pScrn, "Could not load ramdac module\n");
#ifdef SISDUALHEAD
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }

    xf86LoaderReqSymLists(ramdacSymbols, NULL);

    /* Set pScrn->monitor */
    pScrn->monitor = pScrn->confScreen->monitor;

d1263 2
a1264 2
     * Set the Chipset and ChipRev, allowing config file entries to
     * override. DANGEROUS!
d1266 1
a1266 6843
    if(pSiS->pEnt->device->chipset && *pSiS->pEnt->device->chipset)  {
       pScrn->chipset = pSiS->pEnt->device->chipset;
       pSiS->Chipset = xf86StringToToken(SISChipsets, pScrn->chipset);
       from = X_CONFIG;
    } else if(pSiS->pEnt->device->chipID >= 0) {
       pSiS->Chipset = pSiS->pEnt->device->chipID;
       pScrn->chipset = (char *)xf86TokenToString(SISChipsets, pSiS->Chipset);

       from = X_CONFIG;
       xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
                                pSiS->Chipset);
    } else {
       from = X_PROBED;
       pSiS->Chipset = pSiS->PciInfo->chipType;
       pScrn->chipset = (char *)xf86TokenToString(SISChipsets, pSiS->Chipset);
    }
    if(pSiS->pEnt->device->chipRev >= 0) {
       pSiS->ChipRev = pSiS->pEnt->device->chipRev;
       xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
                        pSiS->ChipRev);
    } else {
       pSiS->ChipRev = pSiS->PciInfo->chipRev;
    }
    pSiS->sishw_ext.jChipRevision = pSiS->ChipRev;

    /* Determine SiS6326 chiprevision. This is not yet used for
     * anything, but it will as soon as I found out on which revisions
     * the hardware video overlay really works.
     * According to SiS the only differences are:
     * Chip name     Chip type      TV-Out       MPEG II decoder
     * 6326 AGP      Rev. G0/H0     no           no
     * 6326 DVD      Rev. D2        yes          yes
     * 6326          Rev. Cx        yes          yes
     */
    pSiS->SiS6326Flags = 0;
    if(pSiS->Chipset == PCI_CHIP_SIS6326) {
       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		"Chipset is SiS6326 %s (revision 0x%02x)\n",
		(pSiS->ChipRev == 0xaf) ? "(Ax)" :
		   ((pSiS->ChipRev == 0x0a) ? "AGP (G0)" :
		      ((pSiS->ChipRev == 0x0b) ? "AGP (H0)" :
		          (((pSiS->ChipRev & 0xf0) == 0xd0) ? "DVD (Dx/H0)" :
   			      (((pSiS->ChipRev & 0xf0) == 0x90) ? "(9x)" :
			          (((pSiS->ChipRev & 0xf0) == 0xc0) ? "(Cx)" :
				       "(unknown)"))))),
		pSiS->ChipRev);
       if((pSiS->ChipRev != 0x0a) && (pSiS->ChipRev != 0x0b)) {
		pSiS->SiS6326Flags |= SIS6326_HASTV;
       }
    }


    /*
     * This shouldn't happen because such problems should be caught in
     * SISProbe(), but check it just in case.
     */
    if(pScrn->chipset == NULL) {
       SISErrorLog(pScrn, "ChipID 0x%04X is not recognised\n", pSiS->Chipset);
#ifdef SISDUALHEAD
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }
    if(pSiS->Chipset < 0) {
       SISErrorLog(pScrn, "Chipset \"%s\" is not recognised\n", pScrn->chipset);
#ifdef SISDUALHEAD
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }

    /* Determine chipset and VGA engine type */
    pSiS->ChipFlags = 0;
    pSiS->SiS_SD_Flags = 0;
    pSiS->HWCursorMBufNum = pSiS->HWCursorCBufNum = 0;

    switch(pSiS->Chipset) {
	case PCI_CHIP_SIS300:
		pSiS->sishw_ext.jChipType = SIS_300;
		pSiS->VGAEngine = SIS_300_VGA;
		pSiS->SiS_SD_Flags |= SiS_SD_IS300SERIES;
		break;
	case PCI_CHIP_SIS630: /* 630 + 730 */
		pSiS->sishw_ext.jChipType = SIS_630;
		if(pciReadLong(0x00000000, 0x00) == 0x07301039) {
		   pSiS->sishw_ext.jChipType = SIS_730;
		}
		pSiS->VGAEngine = SIS_300_VGA;
		pSiS->SiS_SD_Flags |= SiS_SD_IS300SERIES;
		break;
	case PCI_CHIP_SIS540:
		pSiS->sishw_ext.jChipType = SIS_540;
		pSiS->VGAEngine = SIS_300_VGA;
		pSiS->SiS_SD_Flags |= SiS_SD_IS300SERIES;
		break;
	case PCI_CHIP_SIS315H:
		pSiS->sishw_ext.jChipType = SIS_315H;
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->ChipFlags |= SiSCF_315Core;
		pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
		pSiS->myCR63 = 0x63;
		break;
	case PCI_CHIP_SIS315:
		/* Override for simplicity */
	        pSiS->Chipset = PCI_CHIP_SIS315H;
		pSiS->sishw_ext.jChipType = SIS_315;
		pSiS->ChipFlags |= SiSCF_315Core;
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
		pSiS->myCR63 = 0x63;
		break;
	case PCI_CHIP_SIS315PRO:
		/* Override for simplicity */
		pSiS->Chipset = PCI_CHIP_SIS315H;
		pSiS->sishw_ext.jChipType = SIS_315PRO;
		pSiS->ChipFlags |= SiSCF_315Core;
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
		pSiS->myCR63 = 0x63;
		break;
	case PCI_CHIP_SIS550:
		pSiS->sishw_ext.jChipType = SIS_550;
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->ChipFlags |= SiSCF_Integrated;
		pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
		pSiS->myCR63 = 0x63;
		break;
	case PCI_CHIP_SIS650: /* 650 + 740 */
		pSiS->sishw_ext.jChipType = SIS_650;
		if(pciReadLong(0x00000000, 0x00) == 0x07401039) {
		   pSiS->sishw_ext.jChipType = SIS_740;
		}
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->ChipFlags |= (SiSCF_Integrated | SiSCF_Real256ECore);
		pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
		pSiS->myCR63 = 0x63;
		break;
	case PCI_CHIP_SIS330:
		pSiS->sishw_ext.jChipType = SIS_330;
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->ChipFlags |= SiSCF_XabreCore;
		pSiS->SiS_SD_Flags |= SiS_SD_IS330SERIES;
		pSiS->myCR63 = 0x63;
		break;
	case PCI_CHIP_SIS660: /* 660, 661, 741, 760 */
	        {
		unsigned long hpciid = pciReadLong(0x00000000, 0x00);
		switch(hpciid) {
		case 0x06601039:
		   pSiS->sishw_ext.jChipType = SIS_660;
		   pSiS->ChipFlags |= SiSCF_Ultra256Core;
		   break;
		case 0x07601039:
		   pSiS->sishw_ext.jChipType = SIS_760;
		   pSiS->ChipFlags |= SiSCF_Ultra256Core;
		   break;
		case 0x07411039:
		   pSiS->sishw_ext.jChipType = SIS_741;
		   pSiS->ChipFlags |= SiSCF_Real256ECore;
		   break;
		case 0x06611039:
		default:
		   pSiS->sishw_ext.jChipType = SIS_661;
		   pSiS->ChipFlags |= SiSCF_Real256ECore;
		}
		/* Detection could also be done by CR5C & 0xf8:
		   0x10 = 661 (CR5F & 0xc0: 0x00 both A0 and A1)
		   0x80 = 760 (CR5F & 0xc0: 0x00 A0, 0x40 A1)
		   0x90 = 741 (CR5F & 0xc0: 0x00 A0,A1 0x40 A2)
		   other: 660 (CR5F & 0xc0: 0x00 A0 0x40 A1) (DOA?)
		 */
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->ChipFlags |= SiSCF_Integrated;
		pSiS->SiS_SD_Flags |= SiS_SD_IS330SERIES;
		pSiS->myCR63 = 0x53; /* Yes, 0x53 */
		}
		break;
	case PCI_CHIP_SIS530:
		pSiS->sishw_ext.jChipType = SIS_530;
		pSiS->VGAEngine = SIS_530_VGA;
		break;
	default:
		pSiS->sishw_ext.jChipType = SIS_OLD;
		pSiS->VGAEngine = SIS_OLD_VGA;
		break;
    }

    /* Now check if sisfb is loaded. Since sisfb only supports
     * the 300 and 315 series, we only do this for these chips.
     * We use this for checking where sisfb starts its memory
     * heap in order to automatically detect the correct MaxXFBMem
     * setting (which normally is given by the option of the same name).
     * Under kernel 2.4.y, that only works if sisfb is completely 
     * running, ie with a video mode because the fbdev will not be
     * installed otherwise. Under 2.5 and later, sisfb will install
     * the framebuffer device in any way and running it with mode=none
     * is no longer supported (or necessary).
     */

    pSiS->donttrustpdc = FALSE;
    pSiS->sisfbpdc = 0;
    pSiS->sisfblcda = 0xff;
    pSiS->sisfbscalelcd = -1;
    pSiS->sisfbspecialtiming = CUT_NONE;
    pSiS->sisfb_haveemi = FALSE;
    pSiS->OldMode = 0;
    pSiS->sisfbfound = FALSE;

    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {

       int fd, i;
       sisfb_info mysisfbinfo;
       char name[10];
       CARD32 sisfbversion;

       {
          i=0;
          do {
             sprintf(name, "/dev/fb%1d", i);
             if((fd = open(name, 'r')) != -1) {

	        if(!ioctl(fd, SISFB_GET_INFO, &mysisfbinfo)) {

	           if(mysisfbinfo.sisfb_id == SISFB_ID) {

	              sisfbversion = (mysisfbinfo.sisfb_version << 16) |
		                     (mysisfbinfo.sisfb_revision << 8) |
			  	     (mysisfbinfo.sisfb_patchlevel);

	              if(sisfbversion >= 0x010508) {
		        /* Added PCI bus/slot/func into in sisfb Version 1.5.08.
		           Check this to make sure we run on the same card as sisfb
		         */
		        if((mysisfbinfo.sisfb_pcibus == pSiS->PciInfo->bus) &&
		           (mysisfbinfo.sisfb_pcislot == pSiS->PciInfo->device) &&
		           (mysisfbinfo.sisfb_pcifunc == pSiS->PciInfo->func) ) {
	         	    pSiS->sisfbfound = TRUE;
		        }
		      } else pSiS->sisfbfound = TRUE;

		      if(pSiS->sisfbfound) {
		         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      	             "%s: SiS kernel fb driver (sisfb) %d.%d.%d detected (PCI: %02d:%02d.%d)\n",
		             	&name[5],
		             	mysisfbinfo.sisfb_version,
		     		mysisfbinfo.sisfb_revision,
		     		mysisfbinfo.sisfb_patchlevel,
		     		pSiS->PciInfo->bus,
		     		pSiS->PciInfo->device,
		     		pSiS->PciInfo->func);
		         /* Added version/rev/pl in sisfb 1.4.0 */
		         if(mysisfbinfo.sisfb_version == 0) {
		            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		                "Old version of sisfb found. Please update\n");
		         }
		         pSiS->sisfbMem = mysisfbinfo.heapstart;
		         /* Basically, we can't trust the pdc register if sisfb is loaded */
		         pSiS->donttrustpdc = TRUE;
		         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		         	"sisfb: memory heap starts at %dKB\n", (int)pSiS->sisfbMem);
		         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		      		"sisfb: using video mode 0x%02x\n", mysisfbinfo.fbvidmode);
		   	 pSiS->OldMode = mysisfbinfo.fbvidmode;
		         if(sisfbversion >= 0x010506) {
		            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		        	"sisfb: %sreserved hardware cursor, using %s command queue\n",
			        (mysisfbinfo.sisfb_caps & 0x80) ? "" : "not ",
				(mysisfbinfo.sisfb_caps & 0x40) ? "SiS300 Turbo" :
			   	   (mysisfbinfo.sisfb_caps & 0x20) ? "SiS315/330 AGP" :
			              (mysisfbinfo.sisfb_caps & 0x10) ? "SiS315/330 VRAM" :
			                 (mysisfbinfo.sisfb_caps & 0x08) ? "SiS315/330 MMIO" :
				            "no");
		         }
		         if(sisfbversion >= 0x01050A) {
		            /* We can trust the pdc value if sisfb is of recent version */
		            if(pSiS->VGAEngine == SIS_300_VGA) pSiS->donttrustpdc = FALSE;
		            if(sisfbversion >= 0x01050B) {
			       if(pSiS->VGAEngine == SIS_300_VGA) {
		                  /* As of 1.5.11, sisfb saved the register for us (300 series) */
		      	          pSiS->sisfbpdc = mysisfbinfo.sisfb_lcdpdc;
			       }
		            }
		            if(sisfbversion >= 0x01050E) {
		               if(pSiS->VGAEngine == SIS_315_VGA) {
		                  pSiS->sisfblcda = mysisfbinfo.sisfb_lcda;
			       }
			       if(sisfbversion >= 0x01060D) {
			          pSiS->sisfbscalelcd = mysisfbinfo.sisfb_scalelcd;
				  pSiS->sisfbspecialtiming = mysisfbinfo.sisfb_specialtiming;
			       }
			       if(sisfbversion >= 0x010610) {
			          if(pSiS->VGAEngine == SIS_315_VGA) {
				     pSiS->donttrustpdc = FALSE;
				     pSiS->sisfbpdc = mysisfbinfo.sisfb_lcdpdc;
				     if(sisfbversion >= 0x010618) {
				        pSiS->sisfb_haveemi = mysisfbinfo.sisfb_haveemi ? TRUE : FALSE;
					pSiS->sisfb_haveemilcd = TRUE;  /* will match most cases */
					pSiS->sisfb_emi30 = mysisfbinfo.sisfb_emi30;
					pSiS->sisfb_emi31 = mysisfbinfo.sisfb_emi31;
					pSiS->sisfb_emi32 = mysisfbinfo.sisfb_emi32;
					pSiS->sisfb_emi33 = mysisfbinfo.sisfb_emi33;
					if(sisfbversion >= 0x010619) {
					   pSiS->sisfb_haveemilcd = mysisfbinfo.sisfb_haveemilcd ? TRUE : FALSE;
					}
				     }
				  }
			       }
		            }
		         }
		      }
	           }
	        }
	        close (fd);
             }
	     i++;
          } while((i <= 7) && (!pSiS->sisfbfound));
	  if(!pSiS->sisfbfound) xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "sisfb not found\n");
       }
    }

    /*
     * The first thing we should figure out is the depth, bpp, etc.
     * Additionally, determine the size of the HWCursor memory area.
     */
    switch(pSiS->VGAEngine) {
      case SIS_300_VGA:
        pSiS->CursorSize = 4096;
    	pix24flags = Support32bppFb;
	break;
      case SIS_315_VGA:
        pSiS->CursorSize = 16384;
    	pix24flags = Support32bppFb;
	break;
      case SIS_530_VGA:
        pSiS->CursorSize = 2048;
    	pix24flags = Support32bppFb |
	             Support24bppFb;
        break;
      default:
        pSiS->CursorSize = 2048;
        pix24flags = Support24bppFb;
	break;
    }

#ifdef SISDUALHEAD
    /* In case of Dual Head, we need to determine if we are the "master" head or
     * the "slave" head. In order to do that, we set PrimInit to DONE in the
     * shared entity at the end of the first initialization. The second
     * initialization then knows that some things have already been done. THIS
     * ALWAYS ASSUMES THAT THE FIRST DEVICE INITIALIZED IS THE MASTER!
     */

    if(xf86IsEntityShared(pScrn->entityList[0])) {
       if(pSiSEnt->lastInstance > 0) {
     	  if(!xf86IsPrimInitDone(pScrn->entityList[0])) {
	     /* First Head (always CRT2) */
	     pSiS->SecondHead = FALSE;
	     pSiSEnt->pScrn_1 = pScrn;
	     pSiSEnt->CRT1ModeNo = pSiSEnt->CRT2ModeNo = -1;
	     pSiSEnt->CRT2ModeSet = FALSE;
	     pSiS->DualHeadMode = TRUE;
	     pSiSEnt->DisableDual = FALSE;
	     pSiSEnt->BIOS = NULL;
	     pSiSEnt->SiS_Pr = NULL;
	     pSiSEnt->RenderAccelArray = NULL;
	  } else {
	     /* Second Head (always CRT1) */
	     pSiS->SecondHead = TRUE;
	     pSiSEnt->pScrn_2 = pScrn;
	     pSiS->DualHeadMode = TRUE;
	  }
       } else {
          /* Only one screen in config file - disable dual head mode */
          pSiS->SecondHead = FALSE;
	  pSiS->DualHeadMode = FALSE;
	  pSiSEnt->DisableDual = TRUE;
       }
    } else {
       /* Entity is not shared - disable dual head mode */
       pSiS->SecondHead = FALSE;
       pSiS->DualHeadMode = FALSE;
    }
#endif

    pSiS->ForceCursorOff = FALSE;

    /* Allocate SiS_Private (for mode switching code) and initialize it */
    pSiS->SiS_Pr = NULL;
#ifdef SISDUALHEAD
    if(pSiSEnt) {
       if(pSiSEnt->SiS_Pr) pSiS->SiS_Pr = pSiSEnt->SiS_Pr;
    }
#endif
    if(!pSiS->SiS_Pr) {
       if(!(pSiS->SiS_Pr = xnfcalloc(sizeof(SiS_Private), 1))) {
          SISErrorLog(pScrn, "Could not allocate memory for SiS_Pr private\n");
#ifdef SISDUALHEAD
	  if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	  if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	  SISFreeRec(pScrn);
          return FALSE;
       }
#ifdef SISDUALHEAD
       if(pSiSEnt) pSiSEnt->SiS_Pr = pSiS->SiS_Pr;
#endif
       memset(pSiS->SiS_Pr, 0, sizeof(SiS_Private));
       pSiS->SiS_Pr->SiS_Backup70xx = 0xff;
       pSiS->SiS_Pr->SiS_CHOverScan = -1;
       pSiS->SiS_Pr->SiS_ChSW = FALSE;
       pSiS->SiS_Pr->SiS_CustomT = CUT_NONE;
       pSiS->SiS_Pr->CRT1UsesCustomMode = FALSE;
       pSiS->SiS_Pr->PDC = -1;
       pSiS->SiS_Pr->LVDSHL = -1;
       pSiS->SiS_Pr->HaveEMI = FALSE;
       pSiS->SiS_Pr->HaveEMILCD = FALSE;
       pSiS->SiS_Pr->OverruleEMI = FALSE;
       pSiS->SiS_Pr->SiS_SensibleSR11 = FALSE;
       if(pSiS->sishw_ext.jChipType >= SIS_661) {
          pSiS->SiS_Pr->SiS_SensibleSR11 = TRUE;
       }
       pSiS->SiS_Pr->SiS_MyCR63 = pSiS->myCR63;
    }

    /* Get our relocated IO registers */
    pSiS->RelIO = (SISIOADDRESS)((pSiS->PciInfo->ioBase[2] & 0xFFFC) + pSiS->IODBase);
    pSiS->sishw_ext.ulIOAddress = (SISIOADDRESS)(pSiS->RelIO + 0x30);
    xf86DrvMsg(pScrn->scrnIndex, from, "Relocated IO registers at 0x%lX\n",
           (unsigned long)pSiS->RelIO);

    /* Initialize SiS Port Reg definitions for externally used
     * init.c/init301.c functions.
     */
    SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO + 0x30);

    /* The following identifies the old chipsets. This is only
     * partly used since the really old chips are not supported,
     * but I keep it here for future use.
     * 205, 215 and 225 are to be treated the same way, 201 and 202
     * are different.
     */
    if(pSiS->VGAEngine == SIS_OLD_VGA || pSiS->VGAEngine == SIS_530_VGA) {
       switch(pSiS->Chipset) {
       case PCI_CHIP_SG86C201:
       	  pSiS->oldChipset = OC_SIS86201; break;
       case PCI_CHIP_SG86C202:
       	  pSiS->oldChipset = OC_SIS86202; break;
       case PCI_CHIP_SG86C205:
          {
	  unsigned char temp;
	  sisSaveUnlockExtRegisterLock(pSiS, &srlockReg, &crlockReg);
	  inSISIDXREG(SISSR, 0x10, temp);
	  if(temp & 0x80) pSiS->oldChipset = OC_SIS6205B;
	  else pSiS->oldChipset = (pSiS->ChipRev == 0x11) ?
	  		OC_SIS6205C : OC_SIS6205A;
          break;
	  }
       case PCI_CHIP_SIS82C204:
       	  pSiS->oldChipset = OC_SIS82204; break;
       case 0x6225:
          pSiS->oldChipset = OC_SIS6225; break;
       case PCI_CHIP_SIS5597:
          pSiS->oldChipset = OC_SIS5597; break;
       case PCI_CHIP_SIS6326:
          pSiS->oldChipset = OC_SIS6326; break;
       case PCI_CHIP_SIS530:
          if(pciReadLong(0x00000000, 0x00) == 0x06201039) {
	     pSiS->oldChipset = OC_SIS620;
	  } else {
             if((pSiS->ChipRev & 0x0f) < 0x0a)
	  	   pSiS->oldChipset = OC_SIS530A;
	     else  pSiS->oldChipset = OC_SIS530B;
	  }
	  break;
       default:
          pSiS->oldChipset = OC_UNKNOWN;
       }
    }

    if(!xf86SetDepthBpp(pScrn, 0, 0, 0, pix24flags)) {
       SISErrorLog(pScrn, "xf86SetDepthBpp() error\n");
#ifdef SISDUALHEAD
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }

    /* Check that the returned depth is one we support */
    temp = 0;
    switch(pScrn->depth) {
       case 8:
       case 16:
       case 24:
          break;
       case 15:
	  if((pSiS->VGAEngine == SIS_300_VGA) ||
	     (pSiS->VGAEngine == SIS_315_VGA)) {
	     temp = 1;
	  }
          break;
       default:
	  temp = 1;
    }

    if(temp) {
       SISErrorLog(pScrn,
               "Given color depth (%d) is not supported by this driver/chipset\n",
               pScrn->depth);
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }

    xf86PrintDepthBpp(pScrn);

    if( (((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) &&
         (pScrn->bitsPerPixel == 24)) ||
	((pSiS->VGAEngine == SIS_OLD_VGA) && (pScrn->bitsPerPixel == 32)) ) {
       SISErrorLog(pScrn,
            "Framebuffer bpp %d not supported for this chipset\n", pScrn->bitsPerPixel);
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }

    /* Get the depth24 pixmap format */
    if(pScrn->depth == 24 && pix24bpp == 0) {
       pix24bpp = xf86GetBppFromDepth(pScrn, 24);
    }

    /*
     * This must happen after pScrn->display has been set because
     * xf86SetWeight references it.
     */
    if(pScrn->depth > 8) {
        /* The defaults are OK for us */
        rgb zeros = {0, 0, 0};

        if(!xf86SetWeight(pScrn, zeros, zeros)) {
	    SISErrorLog(pScrn, "xf86SetWeight() error\n");
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	    SISFreeRec(pScrn);
            return FALSE;
        } else {
           Bool ret = FALSE;
           switch(pScrn->depth) {
	   case 15:
	      if((pScrn->weight.red != 5) ||
	         (pScrn->weight.green != 5) ||
		 (pScrn->weight.blue != 5)) ret = TRUE;
	      break;
	   case 16:
	      if((pScrn->weight.red != 5) ||
	         (pScrn->weight.green != 6) ||
		 (pScrn->weight.blue != 5)) ret = TRUE;
	      break;
	   case 24:
	      if((pScrn->weight.red != 8) ||
	         (pScrn->weight.green != 8) ||
		 (pScrn->weight.blue != 8)) ret = TRUE;
	      break;
           }
	   if(ret) {
	      SISErrorLog(pScrn,
	      	"RGB weight %d%d%d at depth %d not supported by hardware\n",
		(int)pScrn->weight.red, (int)pScrn->weight.green,
		(int)pScrn->weight.blue, pScrn->depth);
#ifdef SISDUALHEAD
	      if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	      if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	      SISFreeRec(pScrn);
              return FALSE;
	   }
        }
    }

    /* Set the current layout parameters */
    pSiS->CurrentLayout.bitsPerPixel = pScrn->bitsPerPixel;
    pSiS->CurrentLayout.depth        = pScrn->depth;
    /* (Inside this function, we can use pScrn's contents anyway) */

    if(!xf86SetDefaultVisual(pScrn, -1)) {
        SISErrorLog(pScrn, "xf86SetDefaultVisual() error\n");
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
        SISFreeRec(pScrn);
        return FALSE;
    } else {
        /* We don't support DirectColor at > 8bpp */
        if(pScrn->depth > 8 && pScrn->defaultVisual != TrueColor) {
            SISErrorLog(pScrn,
	       	"Given default visual (%s) is not supported at depth %d\n",
                xf86GetVisualName(pScrn->defaultVisual), pScrn->depth);
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	    SISFreeRec(pScrn);
            return FALSE;
        }
    }

#ifdef SISDUALHEAD
    /* Due to palette & timing problems we don't support 8bpp in DHM */
    if((pSiS->DualHeadMode) && (pScrn->bitsPerPixel == 8)) {
       SISErrorLog(pScrn, "Color depth 8 not supported in Dual Head mode.\n");
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }
#endif

    /*
     * The cmap layer needs this to be initialised.
     */
    {
        Gamma zeros = {0.0, 0.0, 0.0};

        if(!xf86SetGamma(pScrn, zeros)) {
	    SISErrorLog(pScrn, "xf86SetGamma() error\n");
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	    SISFreeRec(pScrn);
            return FALSE;
        }
    }

    /* We use a programamble clock */
    pScrn->progClock = TRUE;

    /* Set the bits per RGB for 8bpp mode */
    if(pScrn->depth == 8) {
       pScrn->rgbBits = 6;
    }

    from = X_DEFAULT;

    /* Unlock registers */
    sisSaveUnlockExtRegisterLock(pSiS, &srlockReg, &crlockReg);

    /* Read BIOS for 300 and 315/330 series customization */
    pSiS->sishw_ext.pjVirtualRomBase = NULL;
    pSiS->BIOS = NULL;
    pSiS->sishw_ext.UseROM = FALSE;

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
#ifdef SISDUALHEAD
       if(pSiSEnt) {
          if(pSiSEnt->BIOS)  {
	     pSiS->BIOS = pSiSEnt->BIOS;
	     pSiS->sishw_ext.pjVirtualRomBase = pSiS->BIOS;
          }
       }
#endif
       if(!pSiS->BIOS) {
          if(!(pSiS->BIOS = xcalloc(1, BIOS_SIZE))) {
             xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		"Could not allocate memory for video BIOS image\n");
          } else {
	     unsigned long  segstart;
             unsigned short romptr, pciid;
	     BOOLEAN found;

	     found = FALSE;
             for(segstart=BIOS_BASE; segstart<0x000f0000; segstart+=0x00001000) {

#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
                if(xf86ReadBIOS(segstart, 0, pSiS->BIOS, BIOS_SIZE) != BIOS_SIZE) continue;
#else
                if(xf86ReadDomainMemory(pSiS->PciTag, segstart, BIOS_SIZE, pSiS->BIOS) != BIOS_SIZE) continue;
#endif

		if((pSiS->BIOS[0] != 0x55) || (pSiS->BIOS[1] != 0xaa)) continue;

		romptr = pSiS->BIOS[0x18] | (pSiS->BIOS[0x19] << 8);
		if(romptr > (BIOS_SIZE - 8)) continue;
		if((pSiS->BIOS[romptr]   != 'P') || (pSiS->BIOS[romptr+1] != 'C') ||
		   (pSiS->BIOS[romptr+2] != 'I') || (pSiS->BIOS[romptr+3] != 'R')) continue;

		pciid = pSiS->BIOS[romptr+4] | (pSiS->BIOS[romptr+5] << 8);
		if(pciid != 0x1039) continue;

		pciid = pSiS->BIOS[romptr+6] | (pSiS->BIOS[romptr+7] << 8);
		if(pciid != pSiS->Chipset) continue;

		found = TRUE;
		break;
             }

	     if(!found) {
	     	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		         "Could not find/read video BIOS\n");
 	   	xfree(pSiS->BIOS);
	        pSiS->BIOS = NULL;
             } else {
#ifdef SISDUALHEAD
                if(pSiSEnt)  pSiSEnt->BIOS = pSiS->BIOS;
#endif
                pSiS->sishw_ext.pjVirtualRomBase = pSiS->BIOS;
		romptr = pSiS->BIOS[0x16] | (pSiS->BIOS[0x17] << 8);
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			"Video BIOS version \"%7s\" found at 0x%lx\n",
			&pSiS->BIOS[romptr], segstart);
             }
          }
       }
       if(pSiS->BIOS) pSiS->sishw_ext.UseROM = TRUE;
       else           pSiS->sishw_ext.UseROM = FALSE;
    }

    /* Evaluate options */
    SiSOptions(pScrn);

#ifdef SISMERGED
    /* Due to palette & timing problems we don't support 8bpp in MFBM */
    if((pSiS->MergedFB) && (pScrn->bitsPerPixel == 8)) {
       SISErrorLog(pScrn, "MergedFB: Color depth 8 not supported, %s\n", mergeddisstr);
       pSiS->MergedFB = pSiS->MergedFBAuto = FALSE;
    }
#endif

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
        if(!pSiS->SecondHead) {
	     /* Copy some option settings to entity private */
             pSiSEnt->HWCursor = pSiS->HWCursor;
	     pSiSEnt->NoAccel = pSiS->NoAccel;
	     pSiSEnt->restorebyset = pSiS->restorebyset;
	     pSiSEnt->OptROMUsage = pSiS->OptROMUsage;
	     pSiSEnt->OptUseOEM = pSiS->OptUseOEM;
	     pSiSEnt->TurboQueue = pSiS->TurboQueue;
	     pSiSEnt->forceCRT1 = pSiS->forceCRT1;
	     pSiSEnt->ForceCRT1Type = pSiS->ForceCRT1Type;
	     pSiSEnt->ForceCRT2Type = pSiS->ForceCRT2Type;
	     pSiSEnt->ForceTVType = pSiS->ForceTVType;
	     pSiSEnt->ForceYPbPrType = pSiS->ForceYPbPrType;
	     pSiSEnt->ForceYPbPrAR = pSiS->ForceYPbPrAR;
	     pSiSEnt->UsePanelScaler = pSiS->UsePanelScaler;
	     pSiSEnt->DSTN = pSiS->DSTN;
	     pSiSEnt->OptTVStand = pSiS->OptTVStand;
	     pSiSEnt->NonDefaultPAL = pSiS->NonDefaultPAL;
	     pSiSEnt->NonDefaultNTSC = pSiS->NonDefaultNTSC;
	     pSiSEnt->chtvtype = pSiS->chtvtype;
	     pSiSEnt->OptTVOver = pSiS->OptTVOver;
	     pSiSEnt->OptTVSOver = pSiS->OptTVSOver;
	     pSiSEnt->chtvlumabandwidthcvbs = pSiS->chtvlumabandwidthcvbs;
	     pSiSEnt->chtvlumabandwidthsvideo = pSiS->chtvlumabandwidthsvideo;
	     pSiSEnt->chtvlumaflickerfilter = pSiS->chtvlumaflickerfilter;
	     pSiSEnt->chtvchromabandwidth = pSiS->chtvchromabandwidth;
	     pSiSEnt->chtvchromaflickerfilter = pSiS->chtvchromaflickerfilter;
	     pSiSEnt->chtvtextenhance = pSiS->chtvtextenhance;
	     pSiSEnt->chtvcontrast = pSiS->chtvcontrast;
	     pSiSEnt->chtvcvbscolor = pSiS->chtvcvbscolor;
	     pSiSEnt->sistvedgeenhance = pSiS->sistvedgeenhance;
	     pSiSEnt->sistvantiflicker = pSiS->sistvantiflicker;
	     pSiSEnt->sistvsaturation = pSiS->sistvsaturation;
	     pSiSEnt->sistvcfilter = pSiS->sistvcfilter;
	     pSiSEnt->sistvyfilter = pSiS->sistvyfilter;
	     pSiSEnt->sistvcolcalibc = pSiS->sistvcolcalibc;
	     pSiSEnt->sistvcolcalibf = pSiS->sistvcolcalibf;
	     pSiSEnt->tvxpos = pSiS->tvxpos;
	     pSiSEnt->tvypos = pSiS->tvypos;
	     pSiSEnt->tvxscale = pSiS->tvxscale;
	     pSiSEnt->tvyscale = pSiS->tvyscale;
	     pSiSEnt->CRT1gamma = pSiS->CRT1gamma;
	     pSiSEnt->CRT1gammaGiven = pSiS->CRT1gammaGiven;
	     pSiSEnt->XvGammaRed = pSiS->XvGammaRed;
	     pSiSEnt->XvGammaGreen = pSiS->XvGammaGreen;
	     pSiSEnt->XvGammaBlue = pSiS->XvGammaBlue;
	     pSiSEnt->XvGamma = pSiS->XvGamma;
	     pSiSEnt->XvGammaGiven = pSiS->XvGammaGiven;
	     pSiSEnt->CRT2gamma = pSiS->CRT2gamma;
	     pSiSEnt->XvOnCRT2 = pSiS->XvOnCRT2;
	     pSiSEnt->AllowHotkey = pSiS->AllowHotkey;
	     pSiSEnt->enablesisctrl = pSiS->enablesisctrl;
#ifdef SIS_CP
	     SIS_CP_DRIVER_COPYOPTIONSENT
#endif
	} else {
	     /* We always use same cursor type on both screens */
	     if(pSiS->HWCursor != pSiSEnt->HWCursor) {
	          pSiS->HWCursor = pSiSEnt->HWCursor;
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  	"Ignoring inconsistent HWCursor setting\n");
	          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		  	"Master head ruled: HWCursor shall be %s\n",
			pSiS->HWCursor ? "enabled" : "disabled");
	     }

	     /* We need identical NoAccel setting */
	     if(pSiS->NoAccel != pSiSEnt->NoAccel) {
	          pSiS->NoAccel = pSiSEnt->NoAccel;
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  	"Ignoring inconsistent NoAccel setting\n");
	          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		        "Master head ruled: Acceleration shall be %s\n",
			pSiS->NoAccel ? "disabled" : "enabled");
	     }

	     pSiS->TurboQueue = pSiSEnt->TurboQueue;
	     pSiS->restorebyset = pSiSEnt->restorebyset;
	     pSiS->AllowHotkey = pSiS->AllowHotkey;
	     pSiS->OptROMUsage = pSiSEnt->OptROMUsage;
	     pSiS->OptUseOEM = pSiSEnt->OptUseOEM;
	     pSiS->forceCRT1 = pSiSEnt->forceCRT1;
	     pSiS->nocrt2ddcdetection = FALSE;
	     pSiS->forcecrt2redetection = FALSE;
	     pSiS->ForceCRT1Type = pSiSEnt->ForceCRT1Type;
	     pSiS->ForceCRT2Type = pSiSEnt->ForceCRT2Type;
	     pSiS->UsePanelScaler = pSiSEnt->UsePanelScaler;
	     pSiS->DSTN = pSiSEnt->DSTN;
	     pSiS->OptTVStand = pSiSEnt->OptTVStand;
	     pSiS->NonDefaultPAL = pSiSEnt->NonDefaultPAL;
	     pSiS->NonDefaultNTSC = pSiSEnt->NonDefaultNTSC;
	     pSiS->chtvtype = pSiSEnt->chtvtype;
	     pSiS->ForceTVType = pSiSEnt->ForceTVType;
	     pSiS->ForceYPbPrType = pSiSEnt->ForceYPbPrType;
	     pSiS->ForceYPbPrAR = pSiSEnt->ForceYPbPrAR;
	     pSiS->OptTVOver = pSiSEnt->OptTVOver;
	     pSiS->OptTVSOver = pSiSEnt->OptTVSOver;
	     pSiS->chtvlumabandwidthcvbs = pSiSEnt->chtvlumabandwidthcvbs;
	     pSiS->chtvlumabandwidthsvideo = pSiSEnt->chtvlumabandwidthsvideo;
	     pSiS->chtvlumaflickerfilter = pSiSEnt->chtvlumaflickerfilter;
	     pSiS->chtvchromabandwidth = pSiSEnt->chtvchromabandwidth;
	     pSiS->chtvchromaflickerfilter = pSiSEnt->chtvchromaflickerfilter;
	     pSiS->chtvcvbscolor = pSiSEnt->chtvcvbscolor;
	     pSiS->chtvtextenhance = pSiSEnt->chtvtextenhance;
	     pSiS->chtvcontrast = pSiSEnt->chtvcontrast;
	     pSiS->sistvedgeenhance = pSiSEnt->sistvedgeenhance;
	     pSiS->sistvantiflicker = pSiSEnt->sistvantiflicker;
	     pSiS->sistvsaturation = pSiSEnt->sistvsaturation;
	     pSiS->sistvcfilter = pSiSEnt->sistvcfilter;
	     pSiS->sistvyfilter = pSiSEnt->sistvyfilter;
	     pSiS->sistvcolcalibc = pSiSEnt->sistvcolcalibc;
	     pSiS->sistvcolcalibf = pSiSEnt->sistvcolcalibf;
	     pSiS->tvxpos = pSiSEnt->tvxpos;
	     pSiS->tvypos = pSiSEnt->tvypos;
	     pSiS->tvxscale = pSiSEnt->tvxscale;
	     pSiS->tvyscale = pSiSEnt->tvyscale;
	     if(!pSiS->CRT1gammaGiven) {
	        if(pSiSEnt->CRT1gammaGiven)
	           pSiS->CRT1gamma = pSiSEnt->CRT1gamma;
	     }
	     pSiS->CRT2gamma = pSiSEnt->CRT2gamma;
	     if(!pSiS->XvGammaGiven) {
	        if(pSiSEnt->XvGammaGiven) {
		   pSiS->XvGamma = pSiSEnt->XvGamma;
		   pSiS->XvGammaRed = pSiS->XvGammaRedDef = pSiSEnt->XvGammaRed;
		   pSiS->XvGammaGreen = pSiS->XvGammaGreenDef = pSiSEnt->XvGammaGreen;
		   pSiS->XvGammaBlue = pSiS->XvGammaBlueDef = pSiSEnt->XvGammaBlue;
		}
	     }
	     pSiS->XvOnCRT2 = pSiSEnt->XvOnCRT2;
	     pSiS->enablesisctrl = pSiSEnt->enablesisctrl;
	     /* Copy gamma brightness to Ent for Xinerama */
	     pSiSEnt->GammaBriR = pSiS->GammaBriR;
	     pSiSEnt->GammaBriG = pSiS->GammaBriG;
	     pSiSEnt->GammaBriB = pSiS->GammaBriB;
	     pSiSEnt->GammaPBriR = pSiS->GammaPBriR;
	     pSiSEnt->GammaPBriG = pSiS->GammaPBriG;
	     pSiSEnt->GammaPBriB = pSiS->GammaPBriB;
#ifdef SIS_CP
	     SIS_CP_DRIVER_COPYOPTIONS
#endif
	}
    }
#endif

    /* Handle UseROMData, NoOEM and UsePanelScaler options */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       from = X_PROBED;
       if(pSiS->OptROMUsage == 0)  {
       	  pSiS->sishw_ext.UseROM = FALSE;
	  from = X_CONFIG;
	  xf86DrvMsg(pScrn->scrnIndex, from, "Video ROM data usage is disabled\n");
       }

       if(!pSiS->OptUseOEM)
          xf86DrvMsg(pScrn->scrnIndex, from, "Internal OEM LCD/TV/VGA2 data usage is disabled\n");
	  
       pSiS->SiS_Pr->UsePanelScaler = pSiS->UsePanelScaler;
    }

    /* Do basic configuration */
    SiSSetup(pScrn);

    from = X_PROBED;
    if(pSiS->pEnt->device->MemBase != 0) {
       /*
        * XXX Should check that the config file value matches one of the
        * PCI base address values.
        */
       pSiS->FbAddress = pSiS->pEnt->device->MemBase;
       from = X_CONFIG;
    } else {
       pSiS->FbAddress = pSiS->PciInfo->memBase[0] & 0xFFFFFFF0;
    }

    pSiS->realFbAddress = pSiS->FbAddress;

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode)
       xf86DrvMsg(pScrn->scrnIndex, from, "Global linear framebuffer at 0x%lX\n",
           (unsigned long)pSiS->FbAddress);
    else 	   
#endif
       xf86DrvMsg(pScrn->scrnIndex, from, "Linear framebuffer at 0x%lX\n",
           (unsigned long)pSiS->FbAddress);

    if(pSiS->pEnt->device->IOBase != 0) {
        /*
         * XXX Should check that the config file value matches one of the
         * PCI base address values.
         */
       pSiS->IOAddress = pSiS->pEnt->device->IOBase;
       from = X_CONFIG;
    } else {
       pSiS->IOAddress = pSiS->PciInfo->memBase[1] & 0xFFFFFFF0;
    }

    xf86DrvMsg(pScrn->scrnIndex, from, "MMIO registers at 0x%lX\n",
           (unsigned long)pSiS->IOAddress);
    pSiS->sishw_ext.bIntegratedMMEnabled = TRUE;

    /* Register the PCI-assigned resources. */
    if(xf86RegisterResources(pSiS->pEnt->index, NULL, ResExclusive)) {
       SISErrorLog(pScrn, "xf86RegisterResources() found resource conflicts\n");
#ifdef SISDUALHEAD
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
       SISFreeRec(pScrn);
       return FALSE;
    }

    from = X_PROBED;
    if(pSiS->pEnt->device->videoRam != 0) {
       if(pSiS->Chipset == PCI_CHIP_SIS6326) {
          pScrn->videoRam = pSiS->pEnt->device->videoRam;
          from = X_CONFIG;
       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	  	"Option \"VideoRAM\" ignored\n");
       }
    }

    pSiS->RealVideoRam = pScrn->videoRam;

    if((pSiS->Chipset == PCI_CHIP_SIS6326)
			&& (pScrn->videoRam > 4096)
			&& (from != X_CONFIG)) {
        pScrn->videoRam = 4096;
        xf86DrvMsg(pScrn->scrnIndex, from,
	       "SiS6326: Detected %d KB VideoRAM, limiting to %d KB\n",
               pSiS->RealVideoRam, pScrn->videoRam);
    } else {
        xf86DrvMsg(pScrn->scrnIndex, from, "VideoRAM: %d KB\n",
               pScrn->videoRam);
    }

    if((pSiS->Chipset == PCI_CHIP_SIS6326) &&
       (pScrn->videoRam > 4096)) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	"SiS6326 engines do not support more than 4096KB RAM, therefore\n");
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
        "TurboQueue, HWCursor, 2D acceleration and XVideo are disabled.\n");
       pSiS->TurboQueue = FALSE;
       pSiS->HWCursor   = FALSE;
       pSiS->NoXvideo   = TRUE;
       pSiS->NoAccel    = TRUE;
    }

    pSiS->FbMapSize = pSiS->availMem = pScrn->videoRam * 1024;
    pSiS->sishw_ext.ulVideoMemorySize = pScrn->videoRam * 1024;
    pSiS->sishw_ext.bSkipDramSizing = TRUE;

    /* Calculate real availMem according to Accel/TurboQueue and
     * HWCursur setting. Also, initialize some variables used
     * in other modules.
     */

    pSiS->cursorOffset = 0;
    pSiS->CurARGBDest = NULL;
    pSiS->CurMonoSrc = NULL;
    pSiS->CurFGCol = pSiS->CurBGCol = 0;

    switch(pSiS->VGAEngine) {

      case SIS_300_VGA:
      	pSiS->TurboQueueLen = 512;
       	if(pSiS->TurboQueue) {
	   pSiS->availMem -= (pSiS->TurboQueueLen*1024);
	   pSiS->cursorOffset = 512;
        }
	if(pSiS->HWCursor) {
	   pSiS->availMem -= pSiS->CursorSize;
	   if(pSiS->OptUseColorCursor) pSiS->availMem -= pSiS->CursorSize;
	}
	pSiS->CmdQueLenMask = 0xFFFF;
	pSiS->CmdQueLenFix  = 0;
	pSiS->cursorBufferNum = 0;
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->cursorBufferNum = 0;
#endif	
	break;

      case SIS_315_VGA:
#ifdef SISVRAMQ
	pSiS->cmdQueueSizeMask = pSiS->cmdQueueSize - 1;	/* VRAM Command Queue is variable (in therory) */
	pSiS->cmdQueueOffset = (pScrn->videoRam * 1024) - pSiS->cmdQueueSize;
	pSiS->cmdQueueLen = 0;
        pSiS->cmdQueueLenMin = 0x200;
        pSiS->cmdQueueLenMax = pSiS->cmdQueueSize - pSiS->cmdQueueLenMin;
	pSiS->cmdQueueSize_div2 = pSiS->cmdQueueSize / 2;
	pSiS->cmdQueueSize_div4 = pSiS->cmdQueueSize / 4;
	pSiS->cmdQueueSize_4_3 = (pSiS->cmdQueueSize / 4) * 3;
	pSiS->availMem -= pSiS->cmdQueueSize;
        pSiS->cursorOffset = (pSiS->cmdQueueSize / 1024);
#else
       	if(pSiS->TurboQueue) {
	   pSiS->availMem -= (512*1024);  			/* MMIO Command Queue is 512k (variable in theory) */
	   pSiS->cursorOffset = 512;
	}
#endif
	if(pSiS->HWCursor) {
           pSiS->availMem -= (pSiS->CursorSize * 2);
	   if(pSiS->OptUseColorCursor) pSiS->availMem -= (pSiS->CursorSize * 2);
	}
	pSiS->cursorBufferNum = 0;
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->cursorBufferNum = 0;
#endif	
	break;

      default:
        /* cursorOffset not used in cursor functions for 530 and
	 * older chips, because the cursor is *above* the TQ.
	 * On 5597 and older revisions of the 6326, the TQ is
	 * max 32K, on newer 6326 revisions and the 530 either 30
	 * (or 32?) or 62K (or 64?). However, to make sure, we
	 * use only 30K (or 32?), but reduce the available memory
	 * by 64, and locate the TQ at the beginning of this last
	 * 64K block. (We do this that way even when using the
	 * HWCursor, because the cursor only takes 2K and the
	 * queue does not seem to last that far anyway.)
	 * The TQ must be located at 32KB boundaries.
	 */
	if(pSiS->RealVideoRam < 3072) {
	   if(pSiS->TurboQueue) {
	      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Not enough video RAM for TurboQueue. TurboQueue disabled\n");
	      pSiS->TurboQueue = FALSE;
	   }
	}
	pSiS->CmdQueMaxLen = 32;
     	if(pSiS->TurboQueue) {
	              	      pSiS->availMem -= (64*1024);
			      pSiS->CmdQueMaxLen = 900;   /* To make sure; should be 992 */
	} else if(pSiS->HWCursor) {
	                      pSiS->availMem -= pSiS->CursorSize;
	}
	if(pSiS->Chipset == PCI_CHIP_SIS530) {
		/* Check if Flat Panel is enabled */
		inSISIDXREG(SISSR, 0x0e, tempreg);
		if(!tempreg & 0x04) pSiS->availMem -= pSiS->CursorSize;

		/* Set up mask for MMIO register */
		pSiS->CmdQueLenMask = (pSiS->TurboQueue) ? 0x1FFF : 0x00FF;
	} else {
	        /* TQ is never used on 6326/5597, because the accelerator
		 * always Syncs. So this is just cosmentic work. (And I
		 * am not even sure that 0x7fff is correct. MMIO 0x83a8
		 * holds 0xec0 if (30k) TQ is enabled, 0x20 if TQ disabled.
		 * The datasheet has no real explanation on the queue length
		 * if the TQ is enabled. Not syncing and waiting for a
		 * suitable queue length instead does not work.
		 */
	        pSiS->CmdQueLenMask = (pSiS->TurboQueue) ? 0x7FFF : 0x003F;
	}

	/* This is to be subtracted from MMIO queue length register contents
	 * for getting the real Queue length.
	 */
	pSiS->CmdQueLenFix  = (pSiS->TurboQueue) ? 32 : 0;
    }

#ifdef SISDUALHEAD
    /* In dual head mode, we share availMem equally - so align it
     * to 8KB; this way, the address of the FB of the second
     * head is aligned to 4KB for mapping.
     */
   if(pSiS->DualHeadMode)
      pSiS->availMem &= 0xFFFFE000;
#endif

    /* Check MaxXFBMem setting */
#ifdef SISDUALHEAD
    /* Since DRI is not supported in dual head mode, we
       don't need the MaxXFBMem setting. */
    if(pSiS->DualHeadMode) {
       if(pSiS->maxxfbmem) {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"MaxXFBMem not used in Dual Head mode. Using all VideoRAM.\n");
       }
       pSiS->maxxfbmem = pSiS->availMem;
    } else
#endif
       if(pSiS->maxxfbmem) {
    	  if(pSiS->maxxfbmem > pSiS->availMem) {
	     if(pSiS->sisfbMem) {
	        pSiS->maxxfbmem = pSiS->sisfbMem * 1024;
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
             	   	"Invalid MaxXFBMem setting. Using sisfb heap start information\n");
	     } else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                	"Invalid MaxXFBMem setting. Using all VideoRAM for framebuffer\n");
	        pSiS->maxxfbmem = pSiS->availMem;
	     }
	  } else if(pSiS->sisfbMem) {
	     if(pSiS->maxxfbmem > pSiS->sisfbMem * 1024) {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	       		"MaxXFBMem beyond sisfb heap start. Using sisfb heap start\n");
                pSiS->maxxfbmem = pSiS->sisfbMem * 1024;
	     }
	  }
    } else if(pSiS->sisfbMem) {
       pSiS->maxxfbmem = pSiS->sisfbMem * 1024;
    }
    else pSiS->maxxfbmem = pSiS->availMem;

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using %ldK of framebuffer memory\n",
    				pSiS->maxxfbmem / 1024);

    /* Find out about sub-classes of some chipsets and check
     * if the chipset supports two video overlays
     */
    if(pSiS->VGAEngine == SIS_300_VGA    ||
       pSiS->VGAEngine == SIS_315_VGA    ||
       pSiS->Chipset == PCI_CHIP_SIS530  ||
       pSiS->Chipset == PCI_CHIP_SIS6326 ||
       pSiS->Chipset == PCI_CHIP_SIS5597)  {
       pSiS->hasTwoOverlays = FALSE;
       switch(pSiS->Chipset) {
         case PCI_CHIP_SIS300:
         case PCI_CHIP_SIS630:
         case PCI_CHIP_SIS550:
	   pSiS->hasTwoOverlays = TRUE;
	   pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
	   break;
	 case PCI_CHIP_SIS315PRO:
	   pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
	   break;
         case PCI_CHIP_SIS330:
	   pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
	   pSiS->ChipFlags |= SiSCF_CRT2HWCKaputt;
	   break;
	 case PCI_CHIP_SIS660:
	   {
#if 0
	     static const char *id661str[] = {
	   	"661 ?", "661 ?", "661 ?", "661 ?",
		"661 ?", "661 ?", "661 ?", "661 ?",
		"661 ?", "661 ?", "661 ?", "661 ?",
		"661 ?", "661 ?", "661 ?", "661 ?"
	     };
#endif	     
	     pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
	     pSiS->hasTwoOverlays = TRUE;
	     pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
#if 0
	     if(pSiS->sishw_ext.jChipType == SIS_661) {
		inSISIDXREG(SISCR, 0x5f, CR5F);
	        CR5F &= 0xf0;
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	      "SiS661FX revision ID %x (%s)\n", CR5F, id661str[CR5F >> 4]);
             }
#endif
	     break;
	   }
         case PCI_CHIP_SIS650:
	   {
	     unsigned char tempreg1, tempreg2;
	     static const char *id650str[] = {
	   	"650",       "650",       "650",       "650",
		"650 A0 AA", "650 A2 CA", "650",       "650",
		"M650 A0",   "M650 A1 AA","651 A0 AA", "651 A1 AA",
		"M650",      "65?",       "651",       "65?"
	     };
	     pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
	     if(pSiS->sishw_ext.jChipType == SIS_650) {
		inSISIDXREG(SISCR, 0x5f, CR5F);
	        CR5F &= 0xf0;
	        andSISIDXREG(SISCR, 0x5c, 0x07);
		inSISIDXREG(SISCR, 0x5c, tempreg1);
		tempreg1 &= 0xf8;
		orSISIDXREG(SISCR, 0x5c, 0xf8);
		inSISIDXREG(SISCR, 0x5c, tempreg2);
		tempreg2 &= 0xf8;
		if((!tempreg1) || (tempreg2)) {
	           xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	      "SiS650 revision ID %x (%s)\n", CR5F, id650str[CR5F >> 4]);
	           if(CR5F & 0x80) {
	              pSiS->hasTwoOverlays = TRUE;  /* M650 or 651 */
		      pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
	           }
		   switch(CR5F) {
		      case 0xa0:
		      case 0xb0:
		      case 0xe0:
		         pSiS->ChipFlags |= SiSCF_Is651;
		         break;
		      case 0x80:
		      case 0x90:
		      case 0xc0:
		         pSiS->ChipFlags |= SiSCF_IsM650;
		         break;
		   }
		} else {
		   pSiS->hasTwoOverlays = TRUE;  
		   pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
		   switch(CR5F) {
		      case 0x90:
		         inSISIDXREG(SISCR, 0x5c, tempreg1);
			 tempreg1 &= 0xf8;
			 switch(tempreg1) {
			    case 0x00:
			       pSiS->ChipFlags |= SiSCF_IsM652;
			       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	                   "SiSM652 revision ID %x\n", CR5F);
			       break;
			    case 0x40:
			       pSiS->ChipFlags |= SiSCF_IsM653;
			       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	                   "SiSM653 revision ID %x\n", CR5F);
			       break;
			    default:
			       pSiS->ChipFlags |= SiSCF_IsM650;
			       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	                   "SiSM650 revision ID %x\n", CR5F);
			       break;
			 }
			 break;
		      case 0xb0:
		         pSiS->ChipFlags |= SiSCF_Is652;
			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	             "SiS652 revision ID %x\n", CR5F);
			 break;
		      default:
		         pSiS->ChipFlags |= SiSCF_IsM650;
			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	             "SiSM650 revision ID %x\n", CR5F);
			 break;
		   }
		}
	     }
             break;
	   }
       }
       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		"Hardware supports %s video overlay%s\n",
		pSiS->hasTwoOverlays ? "two" : "one",
		pSiS->hasTwoOverlays ? "s" : "");
    }

    /* Backup VB connection and CRT1 on/off register */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       inSISIDXREG(SISSR, 0x1f, pSiS->oldSR1F);
       inSISIDXREG(SISCR, 0x17, pSiS->oldCR17);
       inSISIDXREG(SISCR, 0x32, pSiS->oldCR32);
       inSISIDXREG(SISCR, 0x36, pSiS->oldCR36);
       inSISIDXREG(SISCR, 0x37, pSiS->oldCR37);
       if(pSiS->VGAEngine == SIS_315_VGA) {
          inSISIDXREG(SISCR, pSiS->myCR63, pSiS->oldCR63);
       }

       pSiS->postVBCR32 = pSiS->oldCR32;
    }

    /* There are some machines out there which require a special
     * setup of the GPIO registers in order to make the Chrontel
     * work. Try to find out if we're running on such a machine.
     * Furthermore, there is some highly customized hardware,
     * which requires some non-standard LVDS timing. Since the
     * vendors don't seem to care about PCI subsystem ID's we
     * need to find out using the BIOS version and date strings.
     */
    pSiS->SiS_Pr->SiS_ChSW = FALSE;
    if(pSiS->Chipset == PCI_CHIP_SIS630) {
       int i = 0;
       do {
	  if(mychswtable[i].subsysVendor == pSiS->PciInfo->subsysVendor &&
	     mychswtable[i].subsysCard == pSiS->PciInfo->subsysCard) {
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	         "PCI subsystem ID found in list for Chrontel/GPIO setup\n");
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		 "Vendor/Card: %s %s (ID %04x)\n",
		  mychswtable[i].vendorName,
		  mychswtable[i].cardName,
		  pSiS->PciInfo->subsysCard);
	     pSiS->SiS_Pr->SiS_ChSW = TRUE;
	     break;
          }
          i++;
       } while(mychswtable[i].subsysVendor != 0);
    }

    if(pSiS->SiS_Pr->SiS_CustomT == CUT_NONE) {
       int i = 0, j;
       unsigned short bversptr = 0;
       BOOLEAN footprint;
       unsigned long chksum = 0;

       if(pSiS->sishw_ext.UseROM) {
          bversptr = pSiS->BIOS[0x16] | (pSiS->BIOS[0x17] << 8);
          for(i=0; i<32768; i++) chksum += pSiS->BIOS[i];
       }

       i = 0;
       do {
	  if( (mycustomttable[i].chipID == pSiS->sishw_ext.jChipType)                 &&
	      ((!strlen(mycustomttable[i].biosversion)) ||
	       (pSiS->sishw_ext.UseROM &&
	       (!strncmp(mycustomttable[i].biosversion, (char *)&pSiS->BIOS[bversptr],
	                strlen(mycustomttable[i].biosversion)))))                     &&
	      ((!strlen(mycustomttable[i].biosdate)) ||
	       (pSiS->sishw_ext.UseROM &&
	       (!strncmp(mycustomttable[i].biosdate, (char *)&pSiS->BIOS[0x2c],
	                strlen(mycustomttable[i].biosdate)))))			      &&
	      ((!mycustomttable[i].bioschksum) ||
	       (pSiS->sishw_ext.UseROM &&
	       (mycustomttable[i].bioschksum == chksum)))			      &&
	      (mycustomttable[i].pcisubsysvendor == pSiS->PciInfo->subsysVendor)      &&
	      (mycustomttable[i].pcisubsyscard == pSiS->PciInfo->subsysCard) ) {
	     footprint = TRUE;
	     for(j=0; j<5; j++) {
	        if(mycustomttable[i].biosFootprintAddr[j]) {
		   if(pSiS->sishw_ext.UseROM) {
	              if(pSiS->BIOS[mycustomttable[i].biosFootprintAddr[j]] !=
		      				mycustomttable[i].biosFootprintData[j])
		         footprint = FALSE;
		   } else footprint = FALSE;
	        }
	     }
	     if(footprint) {
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	           "Identified %s %s, special timing applies\n",
		   mycustomttable[i].vendorName, mycustomttable[i].cardName);
	        pSiS->SiS_Pr->SiS_CustomT = mycustomttable[i].SpecialID;
	        break;
	     }
          }
          i++;
       } while(mycustomttable[i].chipID);
    }

    /* Handle ForceCRT1 option */
    if(pSiS->forceCRT1 != -1) {
       if(pSiS->forceCRT1) pSiS->CRT1off = 0;
       else                pSiS->CRT1off = 1;
    } else                 pSiS->CRT1off = -1;

    /* Detect video bridge and sense TV/VGA2 */
    SISVGAPreInit(pScrn);

    /* Detect CRT1 (via DDC1 and DDC2, hence via VGA port; regardless of LCDA) */
    SISCRT1PreInit(pScrn);

    /* Detect LCD (connected via CRT2, regardless of LCDA) and LCD resolution */
    SISLCDPreInit(pScrn);

    /* LCDA only supported under these conditions: */
    if(pSiS->ForceCRT1Type == CRT1_LCDA) {
       if( ((pSiS->sishw_ext.jChipType != SIS_650) &&
            (pSiS->sishw_ext.jChipType < SIS_661))     ||
	   (!(pSiS->VBFlags & (VB_301C | VB_302B | VB_301LV | VB_302LV))) ) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	  	"Chipset/Video bridge does not support LCD-via-CRT1\n");
	  pSiS->ForceCRT1Type = CRT1_VGA;
       } else if(!(pSiS->VBFlags & CRT2_LCD)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	  	"No digitally connected LCD panel found, LCD-via-CRT1 disabled\n");
	  pSiS->ForceCRT1Type = CRT1_VGA;
       } else if(!(pSiS->VBLCDFlags & (VB_LCD_1024x768|VB_LCD_1280x1024|VB_LCD_1400x1050|VB_LCD_1600x1200))) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	  	"LCD-via-CRT1 not supported for this LCD resolution\n");
          pSiS->ForceCRT1Type = CRT1_VGA;
       }
    }

    /* Setup SD flags */
    pSiS->SiS_SD_Flags |= SiS_SD_ADDLSUPFLAG;

    if(pSiS->VBFlags & (VB_SISTVBRIDGE | VB_CHRONTEL)) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTTV;
    }

#ifdef ENABLE_YPBPR
    if((pSiS->VGAEngine == SIS_315_VGA) &&
       (pSiS->VBFlags & (VB_301C|VB_301LV|VB_302LV|VB_302ELV))) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTYPBPR;
       if((pSiS->Chipset == PCI_CHIP_SIS660) || (pSiS->VBFlags & VB_301C)) {
          pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTYPBPRAR;
       }
    }
    if(pSiS->VBFlags & (VB_301|VB_301B|VB_302B)) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTHIVISION;
    }
#endif

#ifdef TWDEBUG	/* @@@@@@ TEST @@@@@@ */
    pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTYPBPRAR;
    xf86DrvMsg(0, X_INFO, "TEST: Support Aspect Ratio\n");
#endif

    /* Detect CRT2-TV and PAL/NTSC mode */
    SISTVPreInit(pScrn);

    /* Detect CRT2-VGA */
    SISCRT2PreInit(pScrn);

    /* Backup detected CRT2 devices */
    pSiS->detectedCRT2Devices = pSiS->VBFlags & (CRT2_LCD|CRT2_TV|CRT2_VGA|TV_AVIDEO|TV_SVIDEO|TV_SCART|TV_HIVISION|TV_YPBPR);

    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPR)) {
       if((pSiS->ForceTVType != -1) && (pSiS->ForceTVType & TV_YPBPR)) {
          pSiS->ForceTVType = -1;
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "YPbPr TV output not supported\n");
       }
    }

    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTHIVISION)) {
       if((pSiS->ForceTVType != -1) && (pSiS->ForceTVType & TV_HIVISION)) {
          pSiS->ForceTVType = -1;
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "HiVision TV output not supported\n");
       }
    }

    if((pSiS->VBFlags & VB_SISTVBRIDGE) ||
       ((pSiS->VBFlags & VB_CHRONTEL) && (pSiS->ChrontelType == CHRONTEL_701x))) {
       pSiS->SiS_SD_Flags |= (SiS_SD_SUPPORTPALMN | SiS_SD_SUPPORTNTSCJ);
    }
    if((pSiS->VBFlags & VB_SISTVBRIDGE) ||
       ((pSiS->VBFlags & VB_CHRONTEL) && (pSiS->ChrontelType == CHRONTEL_700x))) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTTVPOS;
    }
    if(pSiS->VBFlags & (VB_301|VB_301B|VB_301C|VB_302B)) {
       pSiS->SiS_SD_Flags |= (SiS_SD_SUPPORTSCART | SiS_SD_SUPPORTVGA2);
    }
    if(pSiS->VBFlags & VB_CHRONTEL) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTOVERSCAN;
       if(pSiS->ChrontelType == CHRONTEL_700x) {
          pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTSOVER;
       }
    }

    if( ((pSiS->sishw_ext.jChipType == SIS_650) ||
         (pSiS->sishw_ext.jChipType >= SIS_661))                    &&
        (pSiS->VBFlags & (VB_301C | VB_302B | VB_301LV | VB_302LV)) &&
        (pSiS->VBFlags & CRT2_LCD) 			            &&
	(pSiS->VBLCDFlags & (VB_LCD_1024x768|VB_LCD_1280x1024|VB_LCD_1400x1050|VB_LCD_1600x1200)) &&
	(pSiS->VESA != 1) ) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTLCDA;
    } else {
       /* Paranoia */
       pSiS->ForceCRT1Type = CRT1_VGA;
    }

    pSiS->VBFlags |= pSiS->ForceCRT1Type;

#ifdef TWDEBUG
    xf86DrvMsg(0, X_INFO, "SDFlags %lx\n", pSiS->SiS_SD_Flags);
#endif

    /* Eventually overrule detected CRT2 type
     * If no type forced, use the detected devices in the order VGA2->TV->LCD
     * Since the Chrontel 7005 sometimes delivers wrong detection results,
     * we use a different order on such machines (LCD->TV)
     */
    if(pSiS->ForceCRT2Type == CRT2_DEFAULT) {
       if(pSiS->VBFlags & CRT2_VGA)
          pSiS->ForceCRT2Type = CRT2_VGA;
       else if((pSiS->VBFlags & CRT2_TV) && (!((pSiS->VBFlags & VB_CHRONTEL) && (pSiS->VGAEngine == SIS_300_VGA))))
          pSiS->ForceCRT2Type = CRT2_TV;
       else if((pSiS->VBFlags & CRT2_LCD) && (pSiS->ForceCRT1Type == CRT1_VGA))
          pSiS->ForceCRT2Type = CRT2_LCD;
       else if(pSiS->VBFlags & CRT2_TV)
	  pSiS->ForceCRT2Type = CRT2_TV;
    }

    switch(pSiS->ForceCRT2Type) {
       case CRT2_TV:
          pSiS->VBFlags &= ~(CRT2_LCD | CRT2_VGA);
          if(pSiS->VBFlags & (VB_SISTVBRIDGE | VB_CHRONTEL))
             pSiS->VBFlags |= CRT2_TV;
          else {
             pSiS->VBFlags &= ~(CRT2_TV);
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Hardware does not support TV output\n");
          }
          break;
       case CRT2_LCD:
          pSiS->VBFlags &= ~(CRT2_TV | CRT2_VGA);
          if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (pSiS->VBLCDFlags))
             pSiS->VBFlags |= CRT2_LCD;
          else {
             pSiS->VBFlags &= ~(CRT2_LCD);
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Can't force CRT2 to LCD, no LCD detected\n");
	  }
          break;
       case CRT2_VGA:
          pSiS->VBFlags &= ~(CRT2_TV | CRT2_LCD);
          if(pSiS->VBFlags & (VB_301|VB_301B|VB_301C|VB_302B))
	     pSiS->VBFlags |= CRT2_VGA;
	  else {
	     pSiS->VBFlags &= ~(CRT2_VGA);
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	         "Hardware does not support secondary VGA\n");
	  }
          break;
       default:
          pSiS->VBFlags &= ~(CRT2_TV | CRT2_LCD | CRT2_VGA);
    }

#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (pSiS->SecondHead)) {
#endif
       xf86DrvMsg(pScrn->scrnIndex, pSiS->CRT1gammaGiven ? X_CONFIG : X_INFO,
       	     "CRT1 gamma correction is %s\n",
             pSiS->CRT1gamma ? "enabled" : "disabled");

       if((pSiS->VGAEngine == SIS_315_VGA) && (!(pSiS->NoXvideo))) {
          xf86DrvMsg(pScrn->scrnIndex, pSiS->XvGammaGiven ? X_CONFIG : X_INFO,
       		"Separate Xv gamma correction for CRT1 is %s\n",
		pSiS->XvGamma ? "enabled" : "disabled");
	  if(pSiS->XvGamma) {
	     xf86DrvMsg(pScrn->scrnIndex, pSiS->XvGammaGiven ? X_CONFIG : X_INFO,
	        "Xv gamma correction: %.3f %.3f %.3f\n",
		(float)((float)pSiS->XvGammaRed / 1000),
		(float)((float)pSiS->XvGammaGreen / 1000),
		(float)((float)pSiS->XvGammaBlue / 1000));
	     if(!pSiS->CRT1gamma) {
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		      "Separate Xv gamma corr. only effective if CRT1 gamma corr. is enabled\n");
	     }
	  }
       }
#ifdef SISDUALHEAD
    }
#endif

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if( (pSiS->VBFlags & VB_SISBRIDGE) &&
           (!((pSiS->VBFlags & VB_30xBDH) && (pSiS->VBFlags & CRT2_LCD))) ) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CRT2 gamma correction is %s\n",
		pSiS->CRT2gamma ? "enabled" : "disabled");
       }
    }

    /* Eventually overrule TV Type (SVIDEO, COMPOSITE, SCART, HIVISION, YPBPR) */
    if(pSiS->VBFlags & VB_SISTVBRIDGE) {
       if(pSiS->ForceTVType != -1) {
    	  pSiS->VBFlags &= ~(TV_INTERFACE);
	  if(!(pSiS->VBFlags & VB_CHRONTEL)) {
	     pSiS->VBFlags &= ~(TV_CHSCART | TV_CHYPBPR525I);
	  }
	  pSiS->VBFlags |= pSiS->ForceTVType;
	  if(pSiS->VBFlags & TV_YPBPR) {
	     pSiS->VBFlags &= ~(TV_STANDARD);
	     pSiS->VBFlags &= ~(TV_YPBPRAR);
	     pSiS->VBFlags |= pSiS->ForceYPbPrType;
	     pSiS->VBFlags |= pSiS->ForceYPbPrAR;
	  }
       }
    }

    /* Handle ForceCRT1 option (part 2) */
    pSiS->CRT1changed = FALSE;
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       usScratchCR17 = pSiS->oldCR17;
       usScratchCR63 = pSiS->oldCR63;
       usScratchSR1F = pSiS->oldSR1F;
       usScratchCR32 = pSiS->postVBCR32;
       if(pSiS->VESA != 1) {
          /* Copy forceCRT1 option to CRT1off if option is given */
#ifdef SISDUALHEAD
          /* In DHM, handle this option only for master head, not the slave */
          if( (pSiS->forceCRT1 != -1) &&
	       (!(pSiS->DualHeadMode && pSiS->SecondHead)) ) {
#else
          if(pSiS->forceCRT1 != -1) {
#endif
             xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "CRT1 detection overruled by ForceCRT1 option\n");
    	     if(pSiS->forceCRT1) {
		 pSiS->CRT1off = 0;
		 if(pSiS->VGAEngine == SIS_300_VGA) {
		    if(!(usScratchCR17 & 0x80)) pSiS->CRT1changed = TRUE;
		 } else {
		    if(usScratchCR63 & 0x40) pSiS->CRT1changed = TRUE;
		 }
		 usScratchCR17 |= 0x80;
		 usScratchCR32 |= 0x20;
		 usScratchCR63 &= ~0x40;
		 usScratchSR1F &= ~0xc0;
	     } else {
	         if( ! ( (pScrn->bitsPerPixel == 8) &&
		         ( (pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) ||
		           ((pSiS->VBFlags & VB_30xBDH) && (pSiS->VBFlags & CRT2_LCD)) ) ) ) {
		    pSiS->CRT1off = 1;
		    if(pSiS->VGAEngine == SIS_300_VGA) {
		       if(usScratchCR17 & 0x80) pSiS->CRT1changed = TRUE;
		    } else {
		       if(!(usScratchCR63 & 0x40)) pSiS->CRT1changed = TRUE;
		    }
		    usScratchCR32 &= ~0x20;
		    /* We must not actually switch off CRT1 before we changed the mode! */
		 }
	     }
	     /* Here we can write to CR17 even on 315 series as we only ENABLE
	      * the bit here
	      */
	     outSISIDXREG(SISCR, 0x17, usScratchCR17);
	     if(pSiS->VGAEngine == SIS_315_VGA) {
	        outSISIDXREG(SISCR, pSiS->myCR63, usScratchCR63);
	     }
	     outSISIDXREG(SISCR, 0x32, usScratchCR32);
	     if(pSiS->CRT1changed) {
                outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
	        usleep(10000);
                outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	   		"CRT1 status changed by ForceCRT1 option\n");
	     }
	     outSISIDXREG(SISSR, 0x1f, usScratchSR1F);
          }
       }
       /* Store the new VB connection register contents for later mode changes */
       pSiS->newCR32 = usScratchCR32;
    }

    /* Check if CRT1 used (or needed; this eg. if no CRT2 detected) */
    if(pSiS->VBFlags & VB_VIDEOBRIDGE) {

        /* No CRT2 output? Then we NEED CRT1!
	 * We also need CRT1 if depth = 8 and bridge=LVDS|301B-DH
	 */
        if( (!(pSiS->VBFlags & (CRT2_VGA | CRT2_LCD | CRT2_TV))) ||
	    ( (pScrn->bitsPerPixel == 8) &&
	      ( (pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) ||
	        ((pSiS->VBFlags & VB_30xBDH) && (pSiS->VBFlags & CRT2_LCD)) ) ) ) {
	    pSiS->CRT1off = 0;
	}
	/* No CRT2 output? Then we can't use Xv on CRT2 */
	if(!(pSiS->VBFlags & (CRT2_VGA | CRT2_LCD | CRT2_TV)))
	    pSiS->XvOnCRT2 = FALSE;

    } else { /* no video bridge? */

        /* Then we NEED CRT1... */
        pSiS->CRT1off = 0;
	/* ... and can't use CRT2 for Xv output */
	pSiS->XvOnCRT2 = FALSE;
    }

    /* LCDA? Then we don't switch off CRT1 */
    if(pSiS->VBFlags & CRT1_LCDA) pSiS->CRT1off = 0;

    /* Handle TVStandard option */
    if((pSiS->NonDefaultPAL != -1) || (pSiS->NonDefaultNTSC != -1)) {
       if( (!(pSiS->VBFlags & VB_SISTVBRIDGE)) &&
	   (!((pSiS->VBFlags & VB_CHRONTEL)) && (pSiS->ChrontelType == CHRONTEL_701x)) ) {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	   	"PALM, PALN and NTSCJ not supported on this hardware\n");
 	  pSiS->NonDefaultPAL = pSiS->NonDefaultNTSC = -1;
	  pSiS->VBFlags &= ~(TV_PALN | TV_PALM | TV_NTSCJ);
	  pSiS->SiS_SD_Flags &= ~(SiS_SD_SUPPORTPALMN | SiS_SD_SUPPORTNTSCJ);
       }
    }
    if(pSiS->OptTVStand != -1) {
       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	  if( (!((pSiS->VBFlags & VB_CHRONTEL) && (pSiS->VBFlags & (TV_CHSCART | TV_CHYPBPR525I)))) &&
	      (!(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR))) ) {
    	     pSiS->VBFlags &= ~(TV_PAL | TV_NTSC | TV_PALN | TV_PALM | TV_NTSCJ);
    	     if(pSiS->OptTVStand) {
	        pSiS->VBFlags |= TV_PAL;
	        if(pSiS->NonDefaultPAL == 1)  pSiS->VBFlags |= TV_PALM;
	        else if(!pSiS->NonDefaultPAL) pSiS->VBFlags |= TV_PALN;
	     } else {
	        pSiS->VBFlags |= TV_NTSC;
		if(pSiS->NonDefaultNTSC == 1) pSiS->VBFlags |= TV_NTSCJ;
	     }
	  } else {
	     pSiS->OptTVStand = pSiS->NonDefaultPAL = -1;
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	    	 "Option TVStandard ignored for YPbPr, HiVision and Chrontel-SCART\n");
	  }
       } else if(pSiS->Chipset == PCI_CHIP_SIS6326) {
	  pSiS->SiS6326Flags &= ~SIS6326_TVPAL;
	  if(pSiS->OptTVStand) pSiS->SiS6326Flags |= SIS6326_TVPAL;
       }
    }

    /* SCART only supported for PAL */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if((pSiS->VBFlags & VB_SISBRIDGE) && (pSiS->VBFlags & TV_SCART)) {
	  pSiS->VBFlags &= ~(TV_NTSC | TV_PALN | TV_PALM | TV_NTSCJ);
	  pSiS->VBFlags |= TV_PAL;
	  pSiS->OptTVStand = 1;
	  pSiS->NonDefaultPAL = pSiS->NonDefaultNTSC = -1;
       }
    }

#ifdef SIS_CP
    SIS_CP_DRIVER_RECONFIGOPT
#endif

    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
       if(pSiS->sis6326tvplug != -1) {
          pSiS->SiS6326Flags &= ~(SIS6326_TVSVIDEO | SIS6326_TVCVBS);
	  pSiS->SiS6326Flags |= SIS6326_TVDETECTED;
	  if(pSiS->sis6326tvplug == 1) 	pSiS->SiS6326Flags |= SIS6326_TVCVBS;
	  else 				pSiS->SiS6326Flags |= SIS6326_TVSVIDEO;
	  xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	  	"SiS6326 TV plug type detection overruled by %s\n",
		(pSiS->SiS6326Flags & SIS6326_TVCVBS) ? "COMPOSITE" : "SVIDEO");
       }
    }

    /* Do some checks */
    if(pSiS->OptTVOver != -1) {
       if(pSiS->VBFlags & VB_CHRONTEL) {
	  pSiS->UseCHOverScan = pSiS->OptTVOver;
       } else {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	    	"CHTVOverscan only supported on CHRONTEL 70xx\n");
          pSiS->UseCHOverScan = -1;
       }
    } else pSiS->UseCHOverScan = -1;

    if(pSiS->sistvedgeenhance != -1) {
       if(!(pSiS->VBFlags & VB_301)) {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "SISTVEdgeEnhance only supported on SiS301\n");
	  pSiS->sistvedgeenhance = -1;
       }
    }
    if(pSiS->sistvsaturation != -1) {
       if(pSiS->VBFlags & VB_301) {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "SISTVSaturation not supported on SiS301\n");
	  pSiS->sistvsaturation = -1;
       }
    }

    /* Do some MergedFB mode initialisation */
#ifdef SISMERGED
    if(pSiS->MergedFB) {
       pSiS->CRT2pScrn = xalloc(sizeof(ScrnInfoRec));
       if(!pSiS->CRT2pScrn) {
          SISErrorLog(pScrn, "Failed to allocate memory for 2nd pScrn, %s\n", mergeddisstr);
	  pSiS->MergedFB = FALSE;
       } else {
          memcpy(pSiS->CRT2pScrn, pScrn, sizeof(ScrnInfoRec));
       }
    }
#endif


    /* Determine CRT1<>CRT2 mode
     *     Note: When using VESA or if the bridge is in slavemode, display
     *           is ALWAYS in MIRROR_MODE!
     *           This requires extra checks in functions using this flag!
     *           (see sis_video.c for example)
     */
    if(pSiS->VBFlags & DISPTYPE_DISP2) {
        if(pSiS->CRT1off) {	/* CRT2 only ------------------------------- */
#ifdef SISDUALHEAD
	     if(pSiS->DualHeadMode) {
	     	SISErrorLog(pScrn,
		    "CRT1 not detected or forced off. Dual Head mode can't initialize.\n");
	     	if(pSiSEnt) pSiSEnt->DisableDual = TRUE;
	        if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
		if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
		pSiS->pInt = NULL;
		sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
		SISFreeRec(pScrn);
		return FALSE;
	     }
#endif
#ifdef SISMERGED
	     if(pSiS->MergedFB) {
	        if(pSiS->MergedFBAuto) {
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, mergednocrt1, mergeddisstr);
		} else {
	     	   SISErrorLog(pScrn, mergednocrt1, mergeddisstr);
		}
		if(pSiS->CRT2pScrn) xfree(pSiS->CRT2pScrn);
		pSiS->CRT2pScrn = NULL;
		pSiS->MergedFB = FALSE;
	     }
#endif
	     pSiS->VBFlags |= VB_DISPMODE_SINGLE;
	     /* No CRT1? Then we use the video overlay on CRT2 */
	     pSiS->XvOnCRT2 = TRUE;
	} else			/* CRT1 and CRT2 - mirror or dual head ----- */
#ifdef SISDUALHEAD
	     if(pSiS->DualHeadMode) {
		pSiS->VBFlags |= (VB_DISPMODE_DUAL | DISPTYPE_CRT1);
	        if(pSiS->VESA != -1) {
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"VESA option not used in Dual Head mode. VESA disabled.\n");
		}
		if(pSiSEnt) pSiSEnt->DisableDual = FALSE;
		pSiS->VESA = 0;
	     } else
#endif
#ifdef SISMERGED
	            if(pSiS->MergedFB) {
		 pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_CRT1);
		 if(pSiS->VESA != -1) {
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"VESA option not used in MergedFB mode. VESA disabled.\n");
		 }
		 pSiS->VESA = 0;
	     } else
#endif
		 pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_CRT1);
    } else {			/* CRT1 only ------------------------------- */
#ifdef SISDUALHEAD
	     if(pSiS->DualHeadMode) {
	     	SISErrorLog(pScrn,
		   "No CRT2 output selected or no bridge detected. "
		   "Dual Head mode can't initialize.\n");
	        if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
		if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
		pSiS->pInt = NULL;
		sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
		SISFreeRec(pScrn);
		return FALSE;
	     }
#endif
#ifdef SISMERGED
	     if(pSiS->MergedFB) {
	        if(pSiS->MergedFBAuto) {
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, mergednocrt2, mergeddisstr);
		} else {
	     	   SISErrorLog(pScrn, mergednocrt2, mergeddisstr);
		}
		if(pSiS->CRT2pScrn) xfree(pSiS->CRT2pScrn);
		pSiS->CRT2pScrn = NULL;
		pSiS->MergedFB = FALSE;
	     }
#endif
             pSiS->VBFlags |= (VB_DISPMODE_SINGLE | DISPTYPE_CRT1);
    }

    if((pSiS->VGAEngine == SIS_315_VGA) || (pSiS->VGAEngine == SIS_300_VGA)) {
       if((!pSiS->NoXvideo) && (!pSiS->hasTwoOverlays)) {
	  xf86DrvMsg(pScrn->scrnIndex, from,
	      "Using Xv overlay by default on CRT%d\n",
	      pSiS->XvOnCRT2 ? 2 : 1);
       }
    }

    /* Init Ptrs for Save/Restore functions and calc MaxClock */
    SISDACPreInit(pScrn);

    /* ********** end of VBFlags setup ********** */

    /* VBFlags are initialized now. Back them up for SlaveMode modes. */
    pSiS->VBFlags_backup = pSiS->VBFlags;

    /* Backup CR32,36,37 (in order to write them back after a VT switch) */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       inSISIDXREG(SISCR,0x32,pSiS->myCR32);
       inSISIDXREG(SISCR,0x36,pSiS->myCR36);
       inSISIDXREG(SISCR,0x37,pSiS->myCR37);
    }

    /* Find out about paneldelaycompensation and evaluate option */
#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead)) {
#endif
       if(pSiS->VGAEngine == SIS_300_VGA) {

          if(pSiS->VBFlags & (VB_LVDS | VB_30xBDH)) {
	  
	     /* Save the current PDC if the panel is used at the moment.
	      * This seems by far the safest way to find out about it.
	      * If the system is using an old version of sisfb, we can't
	      * trust the pdc register value. If sisfb saved the pdc for
	      * us, use it.
	      */
	     if(pSiS->sisfbpdc) {
	        pSiS->SiS_Pr->PDC = pSiS->sisfbpdc;
	     } else {
	        if(!(pSiS->donttrustpdc)) {
	           unsigned char tmp;
	           inSISIDXREG(SISCR, 0x30, tmp);
	           if(tmp & 0x20) {
	              inSISIDXREG(SISPART1, 0x13, pSiS->SiS_Pr->PDC);
                   } else {
	             xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	          "Unable to detect LCD PanelDelayCompensation, LCD is not active\n");
	           }
	        } else {
	           xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	        "Unable to detect LCD PanelDelayCompensation, please update sisfb\n");
	        }
	     }
	     if(pSiS->SiS_Pr->PDC != -1) {
	        pSiS->SiS_Pr->PDC &= 0x3c;
	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	       	     "Detected LCD PanelDelayCompensation 0x%02x\n",
		     pSiS->SiS_Pr->PDC);
	     }

	     /* If we haven't been able to find out, use our other methods */
	     if(pSiS->SiS_Pr->PDC == -1) {
                int i=0;
                do {
	           if(mypdctable[i].subsysVendor == pSiS->PciInfo->subsysVendor &&
	              mypdctable[i].subsysCard == pSiS->PciInfo->subsysCard) {
	                 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	   	            "PCI card/vendor identified for non-default PanelDelayCompensation\n");
		         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		             "Vendor: %s, card: %s (ID %04x), PanelDelayCompensation: 0x%02x\n",
		             mypdctable[i].vendorName, mypdctable[i].cardName,
		             pSiS->PciInfo->subsysCard, mypdctable[i].pdc);
                         if(pSiS->PDC == -1) {
		            pSiS->PDC = mypdctable[i].pdc;
		         } else {
		            xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       	        "PanelDelayCompensation overruled by option\n");
		         }
	                 break;
                   }
	           i++;
                } while(mypdctable[i].subsysVendor != 0);
             }

	     if(pSiS->PDC != -1) {
	        if(pSiS->BIOS) {
	           if(pSiS->VBFlags & VB_LVDS) {
	              if(pSiS->BIOS[0x220] & 0x80) {
                         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		             "BIOS contains custom LCD Panel Delay Compensation 0x%02x\n",
		             pSiS->BIOS[0x220] & 0x3c);
	                 pSiS->BIOS[0x220] &= 0x7f;
		      }
	           }
	           if(pSiS->VBFlags & (VB_301B|VB_302B)) {
	              if(pSiS->BIOS[0x220] & 0x80) {
                         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		             "BIOS contains custom LCD Panel Delay Compensation 0x%02x\n",
		               (  (pSiS->VBLCDFlags & VB_LCD_1280x1024) ?
			                 pSiS->BIOS[0x223] : pSiS->BIOS[0x224]  ) & 0x3c);
	                 pSiS->BIOS[0x220] &= 0x7f;
		      }
		   }
	        }
	        pSiS->SiS_Pr->PDC = (pSiS->PDC & 0x3c);
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	              "Using LCD Panel Delay Compensation 0x%02x\n", pSiS->SiS_Pr->PDC);
	     }
	  }

       }  /* SIS_300_VGA */

       if(pSiS->VGAEngine == SIS_315_VGA) {

          unsigned char tmp;
	  inSISIDXREG(SISCR, 0x30, tmp);

          if(pSiS->VBFlags & (VB_301LV | VB_302LV | VB_302ELV)) {
	     /* Save the current PDC if the panel is used at the moment.
	      * This seems by far the safest way to find out about it.
	      */
	     if(pSiS->sisfbpdc) {
	        pSiS->SiS_Pr->PDC = pSiS->sisfbpdc;
	     } else {
	        if(!(pSiS->donttrustpdc)) {
	           if(tmp & 0x20) {
	              inSISIDXREG(SISPART1, 0x2D, pSiS->SiS_Pr->PDC);
                   } else {
	              xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	          "Unable to detect LCD PanelDelayCompensation, LCD is not active\n");
	           }
	        } else {
	           xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	       "Unable to detect LCD PanelDelayCompensation, please update sisfb\n");
	        }
	     }
	     if(pSiS->SiS_Pr->PDC != -1) {
	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      	     "Detected LCD PanelDelayCompensation 0x%02x\n",
		     pSiS->SiS_Pr->PDC);
	     }
	     if(pSiS->PDC != -1) {
	        pSiS->SiS_Pr->PDC = pSiS->PDC & 0xff;
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	      	     "Using LCD PanelDelayCompensation 0x%02x\n",
		     pSiS->SiS_Pr->PDC);
	     }
          }

 	  /* Read the current EMI (if not overruled) */
	  if(pSiS->VBFlags & (VB_302LV | VB_302ELV)) {
	     MessageType from = X_PROBED;
	     if(pSiS->EMI != -1) {
	        pSiS->SiS_Pr->EMI_30 = (pSiS->EMI >> 24) & 0x60;
	        pSiS->SiS_Pr->EMI_31 = (pSiS->EMI >> 16) & 0xff;
	        pSiS->SiS_Pr->EMI_32 = (pSiS->EMI >> 8)  & 0xff;
	        pSiS->SiS_Pr->EMI_33 = pSiS->EMI & 0xff;
		pSiS->SiS_Pr->HaveEMI = pSiS->SiS_Pr->HaveEMILCD = TRUE;
		pSiS->SiS_Pr->OverruleEMI = TRUE;
		from = X_CONFIG;
	     } else if((pSiS->sisfbfound) && (pSiS->sisfb_haveemi)) {
	        pSiS->SiS_Pr->EMI_30 = pSiS->sisfb_emi30;
	        pSiS->SiS_Pr->EMI_31 = pSiS->sisfb_emi31;
	        pSiS->SiS_Pr->EMI_32 = pSiS->sisfb_emi32;
	        pSiS->SiS_Pr->EMI_33 = pSiS->sisfb_emi33;
		pSiS->SiS_Pr->HaveEMI = TRUE;
		if(pSiS->sisfb_haveemilcd) pSiS->SiS_Pr->HaveEMILCD = TRUE;
		pSiS->SiS_Pr->OverruleEMI = FALSE;
	     } else {
	        inSISIDXREG(SISPART4, 0x30, pSiS->SiS_Pr->EMI_30);
		inSISIDXREG(SISPART4, 0x31, pSiS->SiS_Pr->EMI_31);
		inSISIDXREG(SISPART4, 0x32, pSiS->SiS_Pr->EMI_32);
		inSISIDXREG(SISPART4, 0x33, pSiS->SiS_Pr->EMI_33);
		pSiS->SiS_Pr->HaveEMI = TRUE;
		if(tmp & 0x20) pSiS->SiS_Pr->HaveEMILCD = TRUE;
		pSiS->SiS_Pr->OverruleEMI = FALSE;
	     }
	     xf86DrvMsg(pScrn->scrnIndex, from,
	     	   "302LV/302ELV: Using EMI 0x%02x%02x%02x%02x%s\n",
		   pSiS->SiS_Pr->EMI_30,pSiS->SiS_Pr->EMI_31,
		   pSiS->SiS_Pr->EMI_32,pSiS->SiS_Pr->EMI_33,
		   pSiS->SiS_Pr->HaveEMILCD ? " (LCD)" : "");
	  }

       } /* SIS_315_VGA */
#ifdef SISDUALHEAD
    }
#endif

#ifdef SISDUALHEAD
    /* In dual head mode, both heads (currently) share the maxxfbmem equally.
     * If memory sharing is done differently, the following has to be changed;
     * the other modules (eg. accel and Xv) use dhmOffset for hardware
     * pointer settings relative to VideoRAM start and won't need to be changed.
     */
    if(pSiS->DualHeadMode) {
        if(pSiS->SecondHead == FALSE) {
	    /* ===== First head (always CRT2) ===== */
	    /* We use only half of the memory available */
	    pSiS->maxxfbmem /= 2;
	    /* Initialize dhmOffset */
	    pSiS->dhmOffset = 0;
	    /* Copy framebuffer addresses & sizes to entity */
	    pSiSEnt->masterFbAddress = pSiS->FbAddress;
	    pSiSEnt->masterFbSize    = pSiS->maxxfbmem;
	    pSiSEnt->slaveFbAddress  = pSiS->FbAddress + pSiS->maxxfbmem;
	    pSiSEnt->slaveFbSize     = pSiS->maxxfbmem;
	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	    		"%ldKB video RAM at 0x%lx available for master head (CRT2)\n",
	    		pSiS->maxxfbmem/1024, pSiS->FbAddress);
	} else {
	    /* ===== Second head (always CRT1) ===== */
	    /* We use only half of the memory available */
	    pSiS->maxxfbmem /= 2;
	    /* Adapt FBAddress */
	    pSiS->FbAddress += pSiS->maxxfbmem;
	    /* Initialize dhmOffset */
	    pSiS->dhmOffset = pSiS->availMem - pSiS->maxxfbmem;
	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	    		"%ldKB video RAM at 0x%lx available for slave head (CRT1)\n",
	    		pSiS->maxxfbmem/1024,  pSiS->FbAddress);
	}
    } else
        pSiS->dhmOffset = 0;
#endif

    /* Note: Do not use availMem for anything from now. Use
     * maxxfbmem instead. (availMem does not take dual head
     * mode into account.)
     */

    pSiS->DRIheapstart = pSiS->maxxfbmem;
    pSiS->DRIheapend = pSiS->availMem;
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       pSiS->DRIheapstart = pSiS->DRIheapend = 0;
    } else
#endif
    if(pSiS->DRIheapstart == pSiS->DRIheapend) {
#if 0  /* For future use */
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	  "No memory for DRI heap. Please set the option \"MaxXFBMem\" to\n"
	  "\tlimit the memory XFree should use and leave the rest to DRI\n");
#endif
       pSiS->DRIheapstart = pSiS->DRIheapend = 0;
    }

    /* Now for something completely different: DDC.
     * For 300 and 315/330 series, we provide our
     * own functions (in order to probe CRT2 as well)
     * If these fail, use the VBE.
     * All other chipsets will use VBE. No need to re-invent
     * the wheel there.
     */

    pSiS->pVbe = NULL;
    didddc2 = FALSE;

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if(xf86LoadSubModule(pScrn, "ddc")) {
          int crtnum = 0;
          xf86LoaderReqSymLists(ddcSymbols, NULL);
	  if((pMonitor = SiSDoPrivateDDC(pScrn, &crtnum))) {
	     didddc2 = TRUE;
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcsstr, crtnum);
	     xf86PrintEDID(pMonitor);
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcestr, crtnum);
	     xf86SetDDCproperties(pScrn, pMonitor);
	     pScrn->monitor->DDC = pMonitor;
          }
       }
    }

#ifdef SISDUALHEAD
    /* In dual head mode, probe DDC using VBE only for CRT1 (second head) */
    if((pSiS->DualHeadMode) && (!didddc2) && (!pSiS->SecondHead))
         didddc2 = TRUE;
#endif

    if(!didddc2) {
       /* If CRT1 is off or LCDA, skip DDC via VBE */
       if((pSiS->CRT1off) || (pSiS->VBFlags & CRT1_LCDA))
          didddc2 = TRUE;
    }

    /* Now (re-)load and initialize the DDC module */
    if(!didddc2) {

       if(xf86LoadSubModule(pScrn, "ddc")) {

          xf86LoaderReqSymLists(ddcSymbols, NULL);

          /* Now load and initialize VBE module. */
          if(xf86LoadSubModule(pScrn, "vbe")) {
	      xf86LoaderReqSymLists(vbeSymbols, NULL);
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	      pSiS->pVbe = VBEInit(pSiS->pInt,pSiS->pEnt->index);
#else
              pSiS->pVbe = VBEExtendedInit(pSiS->pInt,pSiS->pEnt->index,
	                SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
#endif
              if(!pSiS->pVbe) {
	         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	            "Could not initialize VBE module for DDC\n");
              }
          } else {
              xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	          "Could not load VBE module for DDC\n");
          }

  	  if(pSiS->pVbe) {
	      if((pMonitor = vbeDoEDID(pSiS->pVbe,NULL))) {
	         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	      "VBE CRT1 DDC monitor info:\n");
                 xf86SetDDCproperties(pScrn, xf86PrintEDID(pMonitor));
		 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	      "End of VBE CRT1 DDC monitor info:\n");
		 pScrn->monitor->DDC = pMonitor;
              }
          } else {
	      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"Could not retrieve DDC data\n");
	  }
       }
    }

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       pSiS->CRT2pScrn->monitor = xalloc(sizeof(MonRec));
       if(pSiS->CRT2pScrn->monitor) {
          DisplayModePtr tempm = NULL, currentm = NULL, newm = NULL;
          memcpy(pSiS->CRT2pScrn->monitor, pScrn->monitor, sizeof(MonRec));
          pSiS->CRT2pScrn->monitor->DDC = NULL;
	  pSiS->CRT2pScrn->monitor->Modes = NULL;
	  tempm = pScrn->monitor->Modes;
	  while(tempm) {
	     if(!(newm = xalloc(sizeof(DisplayModeRec)))) break;
	     memcpy(newm, tempm, sizeof(DisplayModeRec));
	     if(!(newm->name = xalloc(strlen(tempm->name) + 1))) {
	        xfree(newm);
		break;
	     }
	     strcpy(newm->name, tempm->name);
	     if(!pSiS->CRT2pScrn->monitor->Modes) pSiS->CRT2pScrn->monitor->Modes = newm;
	     if(currentm) {
	        currentm->next = newm;
		newm->prev = currentm;
	     }
	     currentm = newm;
	     tempm = tempm->next;
	  }
          if(pSiS->CRT2HSync) {
             pSiS->CRT2pScrn->monitor->nHsync =
	    	SiSStrToRanges(pSiS->CRT2pScrn->monitor->hsync, pSiS->CRT2HSync, MAX_HSYNC);
          }
          if(pSiS->CRT2VRefresh) {
             pSiS->CRT2pScrn->monitor->nVrefresh =
	    	SiSStrToRanges(pSiS->CRT2pScrn->monitor->vrefresh, pSiS->CRT2VRefresh, MAX_VREFRESH);
          }
	  if((pMonitor = SiSInternalDDC(pSiS->CRT2pScrn, 1))) {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcsstr, 2);
	     xf86PrintEDID(pMonitor);
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcestr, 2);
	     xf86SetDDCproperties(pSiS->CRT2pScrn, pMonitor);
	     pSiS->CRT2pScrn->monitor->DDC = pMonitor;
	     /* use DDC data if no ranges in config file */
	     if(!pSiS->CRT2HSync) {
	        pSiS->CRT2pScrn->monitor->nHsync = 0;
	     }
	     if(!pSiS->CRT2VRefresh) {
	        pSiS->CRT2pScrn->monitor->nVrefresh = 0;
	     }
          } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	     	"Failed to read DDC data for CRT2\n");
	  }
       } else {
          SISErrorLog(pScrn, "Failed to allocate memory for CRT2 monitor, %s.\n",
	  		mergeddisstr);
	  if(pSiS->CRT2pScrn) xfree(pSiS->CRT2pScrn);
    	  pSiS->CRT2pScrn = NULL;
	  pSiS->MergedFB = FALSE;
       }
    }
#endif

    /* If there is no HSync or VRefresh data for the monitor,
     * derive it from DDC data. Done by common layer since
     * 4.3.99.14.
     */
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,14,0)
    if(pScrn->monitor->DDC) {
       if(pScrn->monitor->nHsync <= 0) {
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, subshstr,
#ifdef SISDUALHEAD
			pSiS->DualHeadMode ? (pSiS->SecondHead ? 1 : 2) :
#endif
		 		pSiS->CRT1off ? 2 : 1);
         SiSSetSyncRangeFromEdid(pScrn, 1);
       }
       if(pScrn->monitor->nVrefresh <= 0) {
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, subsvstr,
#ifdef SISDUALHEAD
			pSiS->DualHeadMode ? (pSiS->SecondHead ? 1 : 2) :
#endif
		  		pSiS->CRT1off ? 2 : 1);
         SiSSetSyncRangeFromEdid(pScrn, 0);
       }
    }
#endif

#ifdef SISMERGED
    if(pSiS->MergedFB) {
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,14,0)
       if(pSiS->CRT2pScrn->monitor->DDC) {
          if(pSiS->CRT2pScrn->monitor->nHsync <= 0) {
             xf86DrvMsg(pScrn->scrnIndex, X_INFO, subshstr, 2);
             SiSSetSyncRangeFromEdid(pSiS->CRT2pScrn, 1);
          }
          if(pSiS->CRT2pScrn->monitor->nVrefresh <= 0) {
             xf86DrvMsg(pScrn->scrnIndex, X_INFO, subsvstr, 2);
             SiSSetSyncRangeFromEdid(pSiS->CRT2pScrn, 0);
          }
       }
#endif

       xf86DrvMsg(pScrn->scrnIndex, X_INFO, crtsetupstr, 1);
    }
#endif
    /* end of DDC */

    /* From here, we mainly deal with clocks and modes */

    /* Set the min pixel clock */
    pSiS->MinClock = 5000;
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       pSiS->MinClock = 12000;
    }
    xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Min pixel clock is %d MHz\n",
                pSiS->MinClock / 1000);

    from = X_PROBED;
    /*
     * If the user has specified ramdac speed in the XF86Config
     * file, we respect that setting.
     */
    if(pSiS->pEnt->device->dacSpeeds[0]) {
        int speed = 0;
        switch(pScrn->bitsPerPixel) {
        case 8:
           speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP8];
           break;
        case 16:
           speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP16];
           break;
        case 24:
           speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP24];
           break;
        case 32:
           speed = pSiS->pEnt->device->dacSpeeds[DAC_BPP32];
           break;
        }
        if(speed == 0)
            pSiS->MaxClock = pSiS->pEnt->device->dacSpeeds[0];
        else
            pSiS->MaxClock = speed;
        from = X_CONFIG;
    }
    xf86DrvMsg(pScrn->scrnIndex, from, "Max pixel clock is %d MHz\n",
                pSiS->MaxClock / 1000);

    /*
     * Setup the ClockRanges, which describe what clock ranges are available,
     * and what sort of modes they can be used for.
     */
    clockRanges = xnfcalloc(sizeof(ClockRange), 1);
    clockRanges->next = NULL;
    clockRanges->minClock = pSiS->MinClock;
    clockRanges->maxClock = pSiS->MaxClock;
    clockRanges->clockIndex = -1;               /* programmable */
    clockRanges->interlaceAllowed = TRUE;
    clockRanges->doubleScanAllowed = TRUE;

    /*
     * Since we have lots of built-in modes for 300/315/330 series
     * with vb support, we replace the given default mode list with our
     * own. In case the video bridge is to be used, we only allow other
     * modes if
     *   -) vbtype is 301, 301B, 301C or 302B, and
     *   -) crt2 device is not TV, and
     *   -) crt1 is not LCDA
     */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if(!(pSiS->noInternalModes)) {
          BOOLEAN acceptcustommodes = TRUE;
	  BOOLEAN includelcdmodes   = TRUE;
	  BOOLEAN isfordvi          = FALSE;
          if(pSiS->UseVESA) {
	     acceptcustommodes = FALSE;
	     includelcdmodes   = FALSE;
	  }
#ifdef SISDUALHEAD
          if(pSiS->DualHeadMode) {
	     if(!pSiS->SecondHead) {
	        if((pSiS->VBFlags & (VB_301|VB_301B|VB_301C|VB_302B)) && (!(pSiS->VBFlags & VB_30xBDH))) {
		   if(!(pSiS->VBFlags & (CRT2_LCD|CRT2_VGA))) includelcdmodes   = FALSE;
		   if(pSiS->VBFlags & CRT2_LCD)               isfordvi          = TRUE;
		   if(pSiS->VBFlags & CRT2_TV)                acceptcustommodes = FALSE;
		} else {
		   acceptcustommodes = FALSE;
		   includelcdmodes   = FALSE;
		}
		clockRanges->interlaceAllowed = FALSE;
	     } else {
	        includelcdmodes = FALSE;
		if(pSiS->VBFlags & CRT1_LCDA) {
		   acceptcustommodes = FALSE;
		   /* Ignore interlace, mode switching code will handle this */
		}
	     }
	  } else
#endif
#ifdef SISMERGED
          if(pSiS->MergedFB) {
	     includelcdmodes = FALSE;
	     if(pSiS->VBFlags & CRT1_LCDA) {
		acceptcustommodes = FALSE;
		/* Ignore interlace, mode switching code will handle this */
	     }
          } else
#endif
          if((pSiS->VBFlags & (VB_301|VB_301B|VB_301C|VB_302B))  && (!(pSiS->VBFlags & VB_30xBDH))) {
	     if(!(pSiS->VBFlags & (CRT2_LCD|CRT2_VGA))) includelcdmodes   = FALSE;
	     if(pSiS->VBFlags & CRT2_LCD)               isfordvi          = TRUE;
	     if(pSiS->VBFlags & (CRT2_TV|CRT1_LCDA))    acceptcustommodes = FALSE;
	  } else if(pSiS->VBFlags & (CRT2_ENABLE | CRT1_LCDA)) {
	     acceptcustommodes = FALSE;
	     includelcdmodes   = FALSE;
	  } else {
	     includelcdmodes   = FALSE;
	  }
	  /* Ignore interlace, mode switching code will handle this */

	  pSiS->HaveCustomModes = FALSE;
          if(SiSMakeOwnModeList(pScrn, acceptcustommodes, includelcdmodes, isfordvi, &pSiS->HaveCustomModes)) {
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	         "Replaced %s mode list with built-in modes\n",
	     pSiS->HaveCustomModes ? "default" : "entire");
#ifdef TWDEBUG
             pScrn->modes = pScrn->monitor->Modes;
	     xf86PrintModes(pScrn);
	     pScrn->modes = NULL;
#endif
          } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	   	"Building list of built-in modes failed, using XFree86 defaults\n");
	  }
       } else {
          pSiS->HaveCustomModes = TRUE;
       }
    }

    /*
     * Add our built-in modes for TV on the 6326
     */
    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
       if(pSiS->SiS6326Flags & SIS6326_TVDETECTED) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	 	"Adding %s TV modes for 6326 to mode list:\n",
		(pSiS->SiS6326Flags & SIS6326_TVPAL) ? "PAL" : "NTSC");
          if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
             SiS6326PAL800x600Mode.next = pScrn->monitor->Modes;
             pScrn->monitor->Modes = &SiS6326PAL640x480Mode;
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	     	"\t\"PAL800x600\" \"PAL800x600U\" \"PAL720x540\" \"PAL640x480\"\n");
	  } else {
	     SiS6326NTSC640x480Mode.next = pScrn->monitor->Modes;
             pScrn->monitor->Modes = &SiS6326NTSC640x400Mode;
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	     	"\t\"NTSC640x480\" \"NTSC640x480U\" \"NTSC640x400\"\n");
	  }
       }
    }

    /*
     * Add our built-in hi-res modes on the 6326
     */
    if(pSiS->Chipset == PCI_CHIP_SIS6326) {
       if(pScrn->bitsPerPixel == 8) {
          SiS6326SIS1600x1200_60Mode.next = pScrn->monitor->Modes;
          pScrn->monitor->Modes = &SiS6326SIS1600x1200_60Mode;
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	  	"Adding mode \"SIS1600x1200-60\" (depth 8 only)\n");
       }
       if(pScrn->bitsPerPixel <= 16) {
          SiS6326SIS1280x1024_75Mode.next = pScrn->monitor->Modes;
          pScrn->monitor->Modes = &SiS6326SIS1280x1024_75Mode;
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	  	"Adding mode \"SIS1280x1024-75\" (depth 8, 15 and 16 only)\n");
       }
    }

    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,	
    	  "\"Unknown reason\" in the following list means that the mode\n");
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,	
    	  "is not supported on the chipset/bridge/current output device.\n");
    }
	
    /*
     * xf86ValidateModes will check that the mode HTotal and VTotal values
     * don't exceed the chipset's limit if pScrn->maxHValue and
     * pScrn->maxVValue are set.  Since our SISValidMode() already takes
     * care of this, we don't worry about setting them here.
     */

    /* Select valid modes from those available */
    /*
     * Assuming min pitch 256, min height 128
     */
    {
       int minpitch, maxpitch, minheight, maxheight;
       minpitch = 256;
       minheight = 128;
       switch(pSiS->VGAEngine) {
       case SIS_OLD_VGA:
       case SIS_530_VGA:
          maxpitch = 2040;
          maxheight = 2048;
          break;
       case SIS_300_VGA:
       case SIS_315_VGA:
          maxpitch = 4088;
          maxheight = 4096;
          break;
       default:
          maxpitch = 2048;
          maxheight = 2048;
          break;
       }
#ifdef SISMERGED
       pSiS->CheckForCRT2 = FALSE;
#endif
       i = xf86ValidateModes(pScrn, pScrn->monitor->Modes,
                      pScrn->display->modes, clockRanges, NULL,
                      minpitch, maxpitch,
                      pScrn->bitsPerPixel * 8,
		      minheight, maxheight,
                      pScrn->display->virtualX,
                      pScrn->display->virtualY,
                      pSiS->maxxfbmem,
                      LOOKUP_BEST_REFRESH);
    }

    if(i == -1) {
        SISErrorLog(pScrn, "xf86ValidateModes() error\n");
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
        SISFreeRec(pScrn);
        return FALSE;
    }

    /* Check the virtual screen against the available memory */
    {
       unsigned long memreq = (pScrn->virtualX * ((pScrn->bitsPerPixel + 7) / 8)) * pScrn->virtualY;

       if(memreq > pSiS->maxxfbmem) {
          SISErrorLog(pScrn,
       		"Virtual screen too big for memory; %ldK needed, %ldK available\n",
		memreq/1024, pSiS->maxxfbmem/1024);
#ifdef SISDUALHEAD
          if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
          if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
          pSiS->pInt = NULL;
          sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
          SISFreeRec(pScrn);
          return FALSE;
       }
    }

    /* Dual Head:
     * -) Go through mode list and mark all those modes as bad,
     *    which are unsuitable for dual head mode.
     * -) Find the highest used pixelclock on the master head.
     */
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {

       if(!pSiS->SecondHead) {

          pSiSEnt->maxUsedClock = 0;

          if((p = first = pScrn->modes)) {
             do {
	        n = p->next;

	        /* Modes that require the bridge to operate in SlaveMode
                 * are not suitable for Dual Head mode.
                 */
	        if( (pSiS->VGAEngine == SIS_300_VGA) &&
		    ( (strcmp(p->name, "320x200") == 0) ||
		      (strcmp(p->name, "320x240") == 0) ||
		      (strcmp(p->name, "400x300") == 0) ||
		      (strcmp(p->name, "512x384") == 0) ||
		      (strcmp(p->name, "640x400") == 0) ) )  {
	    	   p->status = MODE_BAD;
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, notsuitablestr, p->name, "dual head");
		}

		/* Search for the highest clock on first head in order to calculate
	         * max clock for second head (CRT1)
	         */
		if((p->status == MODE_OK) && (p->Clock > pSiSEnt->maxUsedClock)) {
		   pSiSEnt->maxUsedClock = p->Clock;
		}

	        p = n;

             } while (p != NULL && p != first);
	  }
       }
    }
#endif

    /* Prune the modes marked as invalid */
    xf86PruneDriverModes(pScrn);

    if(i == 0 || pScrn->modes == NULL) {
        SISErrorLog(pScrn, "No valid modes found\n");
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
        SISFreeRec(pScrn);
        return FALSE;
    }

    xf86SetCrtcForModes(pScrn, INTERLACE_HALVE_V);

    /* Set the current mode to the first in the list */
    pScrn->currentMode = pScrn->modes;

    /* Copy to CurrentLayout */
    pSiS->CurrentLayout.mode = pScrn->currentMode;
    pSiS->CurrentLayout.displayWidth = pScrn->displayWidth;

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO, modesforstr, 1);
    }
#endif

    /* Print the list of modes being used */
    xf86PrintModes(pScrn);

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       BOOLEAN acceptcustommodes = TRUE;
       BOOLEAN includelcdmodes   = TRUE;
       BOOLEAN isfordvi          = FALSE;

       xf86DrvMsg(pScrn->scrnIndex, X_INFO, crtsetupstr, 2);

       clockRanges->next = NULL;
       clockRanges->minClock = pSiS->MinClock;
       clockRanges->maxClock = SiSMemBandWidth(pSiS->CRT2pScrn, TRUE);
       clockRanges->clockIndex = -1;
       clockRanges->interlaceAllowed = FALSE;
       clockRanges->doubleScanAllowed = FALSE;
       if(pSiS->VGAEngine == SIS_315_VGA) {
          clockRanges->doubleScanAllowed = TRUE;
       }

       xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Min pixel clock for CRT2 is %d MHz\n",
                clockRanges->minClock / 1000);
       xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Max pixel clock for CRT2 is %d MHz\n",
                clockRanges->maxClock / 1000);

       if((pSiS->VBFlags & (VB_301|VB_301B|VB_301C|VB_302B)) && (!(pSiS->VBFlags & VB_30xBDH))) {
          if(!(pSiS->VBFlags & (CRT2_LCD|CRT2_VGA))) includelcdmodes   = FALSE;
	  if(pSiS->VBFlags & CRT2_LCD)               isfordvi          = TRUE;
	  if(pSiS->VBFlags & CRT2_TV)                acceptcustommodes = FALSE;
       } else {
          includelcdmodes   = FALSE;
	  acceptcustommodes = FALSE;
       }

       pSiS->HaveCustomModes2 = FALSE;
       if(!SiSMakeOwnModeList(pSiS->CRT2pScrn, acceptcustommodes, includelcdmodes, isfordvi, &pSiS->HaveCustomModes2)) {

	  SISErrorLog(pScrn, "Building list of built-in modes for CRT2 failed, %s\n",
	  			mergeddisstr);
	  SiSFreeCRT2Structs(pSiS);
	  pSiS->MergedFB = FALSE;

       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	         "Replaced %s mode list for CRT2 with built-in modes\n",
	         pSiS->HaveCustomModes2 ? "default" : "entire");
       }

    }

    if(pSiS->MergedFB) {

       pSiS->CheckForCRT2 = TRUE;
       i = xf86ValidateModes(pSiS->CRT2pScrn, pSiS->CRT2pScrn->monitor->Modes,
                      pSiS->CRT2pScrn->display->modes, clockRanges,
                      NULL, 256, 4088,
                      pSiS->CRT2pScrn->bitsPerPixel * 8, 128, 4096,
                      pScrn->display->virtualX ? pScrn->virtualX : 0,
                      pScrn->display->virtualY ? pScrn->virtualY : 0,
                      pSiS->maxxfbmem,
                      LOOKUP_BEST_REFRESH);
       pSiS->CheckForCRT2 = FALSE;

       if(i == -1) {
          SISErrorLog(pScrn, "xf86ValidateModes() error, %s.\n", mergeddisstr);
	  SiSFreeCRT2Structs(pSiS);
          pSiS->MergedFB = FALSE;
       }

    }

    if(pSiS->MergedFB) {

       if((p = first = pSiS->CRT2pScrn->modes)) {
          do {
	     n = p->next;
	     if( (pSiS->VGAEngine == SIS_300_VGA) &&
		 ( (strcmp(p->name, "320x200") == 0) ||
		   (strcmp(p->name, "320x240") == 0) ||
		   (strcmp(p->name, "400x300") == 0) ||
		   (strcmp(p->name, "512x384") == 0) ||
		   (strcmp(p->name, "640x400") == 0) ) )  {
	    	p->status = MODE_BAD;
		xf86DrvMsg(pScrn->scrnIndex, X_INFO, notsuitablestr, p->name, "MergedFB");
	     }
	     p = n;
	  } while (p != NULL && p != first);
       }

       xf86PruneDriverModes(pSiS->CRT2pScrn);

       if(i == 0 || pSiS->CRT2pScrn->modes == NULL) {
          SISErrorLog(pScrn, "No valid modes found for CRT2; %s\n", mergeddisstr);
	  SiSFreeCRT2Structs(pSiS);
	  pSiS->MergedFB = FALSE;
       }

    }

    if(pSiS->MergedFB) {

       xf86SetCrtcForModes(pSiS->CRT2pScrn, INTERLACE_HALVE_V);

       xf86DrvMsg(pScrn->scrnIndex, X_INFO, modesforstr, 2);

       xf86PrintModes(pSiS->CRT2pScrn);

       pSiS->CRT1Modes = pScrn->modes;
       pSiS->CRT1CurrentMode = pScrn->currentMode;

       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Generating MergedFB mode list\n");

       pScrn->modes = SiSGenerateModeList(pScrn, pSiS->MetaModes,
	            	                  pSiS->CRT1Modes, pSiS->CRT2pScrn->modes,
					  pSiS->CRT2Position);

       if(!pScrn->modes) {

	  SISErrorLog(pScrn, "Failed to parse MetaModes or no modes found. %s.\n",
	  		mergeddisstr);
	  SiSFreeCRT2Structs(pSiS);
	  pScrn->modes = pSiS->CRT1Modes;
	  pSiS->CRT1Modes = NULL;
	  pSiS->MergedFB = FALSE;

       }

    }

    if(pSiS->MergedFB) {

       /* If no virtual dimension was given by the user,
        * calculate a sane one now. Adapts pScrn->virtualX,
	* pScrn->virtualY and pScrn->displayWidth.
	*/
       SiSRecalcDefaultVirtualSize(pScrn);

       pScrn->modes = pScrn->modes->next;  /* We get the last from GenerateModeList(), skip to first */
       pScrn->currentMode = pScrn->modes;

       /* Update CurrentLayout */
       pSiS->CurrentLayout.mode = pScrn->currentMode;
       pSiS->CurrentLayout.displayWidth = pScrn->displayWidth;

    }
#endif

    /* Set display resolution */
#ifdef SISMERGED
    if(pSiS->MergedFB) {
       SiSMergedFBSetDpi(pScrn, pSiS->CRT2pScrn, pSiS->CRT2Position);
    } else
#endif
       xf86SetDpi(pScrn, 0, 0);

    /* Load fb module */
    switch(pScrn->bitsPerPixel) {
      case 8:
      case 16:
      case 24:
      case 32:
	if(!xf86LoadSubModule(pScrn, "fb")) {
           SISErrorLog(pScrn, "Failed to load fb module");
#ifdef SISDUALHEAD
	   if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	   if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	   sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
           SISFreeRec(pScrn);
           return FALSE;
        }
	break;
      default:
        SISErrorLog(pScrn, "Unsupported framebuffer bpp (%d)\n", pScrn->bitsPerPixel);
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
        SISFreeRec(pScrn);
        return FALSE;
    }
    xf86LoaderReqSymLists(fbSymbols, NULL);

    /* Load XAA if needed */
    if(!pSiS->NoAccel) {
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Accel enabled\n");
        if(!xf86LoadSubModule(pScrn, "xaa")) {
	    SISErrorLog(pScrn, "Could not load xaa module\n");
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	    sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
            SISFreeRec(pScrn);
            return FALSE;
        }
        xf86LoaderReqSymLists(xaaSymbols, NULL);
    }

    /* Load shadowfb if needed */
    if(pSiS->ShadowFB) {
        if(!xf86LoadSubModule(pScrn, "shadowfb")) {
	    SISErrorLog(pScrn, "Could not load shadowfb module\n");
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	    sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
	    SISFreeRec(pScrn);
            return FALSE;
        }
        xf86LoaderReqSymLists(shadowSymbols, NULL);
    }

    /* Load the dri module if requested. */
#ifdef XF86DRI
    if(pSiS->loadDRI) {
       if(xf86LoadSubModule(pScrn, "dri")) {
          xf86LoaderReqSymLists(driSymbols, drmSymbols, NULL);
       } else {
#ifdef SISDUALHEAD
          if(!pSiS->DualHeadMode)
#endif
             xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	  	 "Remove >Load \"dri\"< from the Module section of your XF86Config file\n");
       }
    }
#endif    

    /* Now load and initialize VBE module for VESA and mode restoring. */
    pSiS->UseVESA = 0;
    if(pSiS->VESA == 1) {
       if(!pSiS->pVbe) {
          if(xf86LoadSubModule(pScrn, "vbe")) {
	     xf86LoaderReqSymLists(vbeSymbols, NULL);
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	     pSiS->pVbe = VBEInit(pSiS->pInt,pSiS->pEnt->index);
#else
             pSiS->pVbe = VBEExtendedInit(pSiS->pInt,pSiS->pEnt->index,
	    			SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
#endif
          }
       }
       if(pSiS->pVbe) {
          vbe = VBEGetVBEInfo(pSiS->pVbe);
          pSiS->vesamajor = (unsigned)(vbe->VESAVersion >> 8);
          pSiS->vesaminor = vbe->VESAVersion & 0xff;
          pSiS->vbeInfo = vbe;
          if(pSiS->VESA == 1) {
             SiSBuildVesaModeList(pScrn, pSiS->pVbe, vbe);
             VBEFreeVBEInfo(vbe);
             pSiS->UseVESA = 1;
          }
       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    	"Could not load and initialize VBE module.%s\n",
		(pSiS->VESA == 1) ? " VESA disabled." : "");
       }
    }    
  
    if(pSiS->pVbe) {
       vbeFree(pSiS->pVbe);
       pSiS->pVbe = NULL;
    }

#ifdef SISDUALHEAD
    xf86SetPrimInitDone(pScrn->entityList[0]);
#endif

    sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);

    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
    pSiS->pInt = NULL;

    if(pSiS->VGAEngine == SIS_315_VGA) pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTXVGAMMA1;

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
    	pSiS->SiS_SD_Flags |= SiS_SD_ISDUALHEAD;
	if(pSiS->SecondHead)      pSiS->SiS_SD_Flags |= SiS_SD_ISDHSECONDHEAD;
	else			  pSiS->SiS_SD_Flags &= ~(SiS_SD_SUPPORTXVGAMMA1);
#ifdef PANORAMIX
	if(!noPanoramiXExtension) {
	   pSiS->SiS_SD_Flags |= SiS_SD_ISDHXINERAMA;
	   pSiS->SiS_SD_Flags &= ~(SiS_SD_SUPPORTXVGAMMA1);
	}
#endif
    }
#endif

#ifdef SISMERGED
    if(pSiS->MergedFB)      pSiS->SiS_SD_Flags |= SiS_SD_ISMERGEDFB;
#endif

    if(pSiS->enablesisctrl) pSiS->SiS_SD_Flags |= SiS_SD_ENABLED;

    return TRUE;
}


/*
 * Map the framebuffer and MMIO memory.
 */

static Bool
SISMapMem(ScrnInfoPtr pScrn)
{
    SISPtr pSiS;
    int mmioFlags;
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif
    pSiS = SISPTR(pScrn);

#ifdef SISDUALHEAD
    pSiSEnt = pSiS->entityPrivate;
#endif

    /*
     * Map IO registers to virtual address space
     */
#if !defined(__alpha__)
    mmioFlags = VIDMEM_MMIO;
#else
    /*
     * For Alpha, we need to map SPARSE memory, since we need
     * byte/short access.
     */
    mmioFlags = VIDMEM_MMIO | VIDMEM_SPARSE;
#endif

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
        pSiSEnt->MapCountIOBase++;
        if(!(pSiSEnt->IOBase)) {
	     /* Only map if not mapped previously */
    	     pSiSEnt->IOBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
                         pSiS->PciTag, pSiS->IOAddress, 0x10000);
        }
        pSiS->IOBase = pSiSEnt->IOBase;
    } else
#endif
    	pSiS->IOBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
                        pSiS->PciTag, pSiS->IOAddress, 0x10000);

    if(pSiS->IOBase == NULL) {
    	SISErrorLog(pScrn, "Could not map MMIO area\n");
        return FALSE;
    }

#ifdef __alpha__
    /*
     * for Alpha, we need to map DENSE memory as well, for
     * setting CPUToScreenColorExpandBase.
     */
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
        pSiSEnt->MapCountIOBaseDense++;
        if(!(pSiSEnt->IOBaseDense)) {
	     /* Only map if not mapped previously */
	     pSiSEnt->IOBaseDense = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_MMIO,
                    pSiS->PciTag, pSiS->IOAddress, 0x10000);
	}
	pSiS->IOBaseDense = pSiSEnt->IOBaseDense;
    } else
#endif
    	pSiS->IOBaseDense = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_MMIO,
                    pSiS->PciTag, pSiS->IOAddress, 0x10000);

    if(pSiS->IOBaseDense == NULL) {
       SISErrorLog(pScrn, "Could not map MMIO dense area\n");
       return FALSE;
    }

#endif /* __alpha__ */

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
        pSiSEnt->MapCountFbBase++;
        if(!(pSiSEnt->FbBase)) {
	     /* Only map if not mapped previously */
    	     pSiSEnt->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
                         pSiS->PciTag, (unsigned long)pSiS->realFbAddress,
                         pSiS->FbMapSize);
	     pSiS->sishw_ext.pjVideoMemoryAddress = (UCHAR *)pSiSEnt->FbBase;
        }
        pSiS->FbBase = pSiSEnt->FbBase;
     	/* Adapt FbBase (for DHM; dhmOffset is 0 otherwise) */
	pSiS->FbBase += pSiS->dhmOffset;
    } else {
#endif
    	pSiS->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
                         pSiS->PciTag, (unsigned long)pSiS->FbAddress,
                         pSiS->FbMapSize);
	pSiS->sishw_ext.pjVideoMemoryAddress = (UCHAR *)pSiS->FbBase;
#ifdef SISDUALHEAD
    }
#endif

    if(pSiS->FbBase == NULL) {
       SISErrorLog(pScrn, "Could not map framebuffer area\n");
       return FALSE;
    }

    return TRUE;
}


/*
 * Unmap the framebuffer and MMIO memory.
 */

static Bool
SISUnmapMem(ScrnInfoPtr pScrn)
{
    SISPtr pSiS;
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif

    pSiS = SISPTR(pScrn);

#ifdef SISDUALHEAD
    pSiSEnt = pSiS->entityPrivate;
#endif

/* In dual head mode, we must not unmap if the other head still
 * assumes memory as mapped
 */
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
        if(pSiSEnt->MapCountIOBase) {
	    pSiSEnt->MapCountIOBase--;
	    if((pSiSEnt->MapCountIOBase == 0) || (pSiSEnt->forceUnmapIOBase)) {
	    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiSEnt->IOBase, 0x10000);
	    	pSiSEnt->IOBase = NULL;
		pSiSEnt->MapCountIOBase = 0;
		pSiSEnt->forceUnmapIOBase = FALSE;
	    }
	    pSiS->IOBase = NULL;
	}
#ifdef __alpha__
	if(pSiSEnt->MapCountIOBaseDense) {
	    pSiSEnt->MapCountIOBaseDense--;
	    if((pSiSEnt->MapCountIOBaseDense == 0) || (pSiSEnt->forceUnmapIOBaseDense)) {
	    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiSEnt->IOBaseDense, 0x10000);
	    	pSiSEnt->IOBaseDense = NULL;
		pSiSEnt->MapCountIOBaseDense = 0;
		pSiSEnt->forceUnmapIOBaseDense = FALSE;
	    }
	    pSiS->IOBaseDense = NULL;
	}
#endif /* __alpha__ */
	if(pSiSEnt->MapCountFbBase) {
	    pSiSEnt->MapCountFbBase--;
	    if((pSiSEnt->MapCountFbBase == 0) || (pSiSEnt->forceUnmapFbBase)) {
	    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiSEnt->FbBase, pSiS->FbMapSize);
	    	pSiSEnt->FbBase = NULL;
		pSiSEnt->MapCountFbBase = 0;
		pSiSEnt->forceUnmapFbBase = FALSE;

	    }
	    pSiS->FbBase = NULL;
	}
    } else {
#endif
    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->IOBase, 0x10000);
    	pSiS->IOBase = NULL;
#ifdef __alpha__
    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->IOBaseDense, 0x10000);
    	pSiS->IOBaseDense = NULL;
#endif
    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->FbBase, pSiS->FbMapSize);
    	pSiS->FbBase = NULL;
#ifdef SISDUALHEAD
    }
#endif
    return TRUE;
}

/*
 * This function saves the video state.
 */
static void
SISSave(ScrnInfoPtr pScrn)
{
    SISPtr pSiS;
    vgaRegPtr vgaReg;
    SISRegPtr sisReg;

    pSiS = SISPTR(pScrn);

#ifdef SISDUALHEAD
    /* We always save master & slave */
    if(pSiS->DualHeadMode && pSiS->SecondHead) return;
#endif

    vgaReg = &VGAHWPTR(pScrn)->SavedReg;
    sisReg = &pSiS->SavedReg;

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (SiSBridgeIsInSlaveMode(pScrn))) {
          vgaHWSave(pScrn, vgaReg, VGA_SR_CMAP | VGA_SR_MODE);
	  SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO+0x30);
	  SiSSetLVDSetc(pSiS->SiS_Pr, &pSiS->sishw_ext, 0);
	  SiS_GetVBType(pSiS->SiS_Pr, &pSiS->sishw_ext);
	  SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
	  vgaHWSave(pScrn, vgaReg, VGA_SR_FONTS);
	  SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
       } else {
          vgaHWSave(pScrn, vgaReg, VGA_SR_ALL);
       }
    } else {
       vgaHWSave(pScrn, vgaReg, VGA_SR_ALL);
    }

    sisSaveUnlockExtRegisterLock(pSiS,&sisReg->sisRegs3C4[0x05],&sisReg->sisRegs3D4[0x80]);

    (*pSiS->SiSSave)(pScrn, sisReg);

    if(pSiS->UseVESA) SISVESASaveRestore(pScrn, MODE_SAVE);

    /* "Save" these again as they may have been changed prior to SISSave() call */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       sisReg->sisRegs3C4[0x1f] = pSiS->oldSR1F;
       sisReg->sisRegs3D4[0x17] = pSiS->oldCR17;
       if(vgaReg->numCRTC >= 0x17) vgaReg->CRTC[0x17] = pSiS->oldCR17;
       sisReg->sisRegs3D4[0x32] = pSiS->oldCR32;
       sisReg->sisRegs3D4[0x36] = pSiS->oldCR36;
       sisReg->sisRegs3D4[0x37] = pSiS->oldCR37;
       if(pSiS->VGAEngine == SIS_315_VGA) {
	  sisReg->sisRegs3D4[pSiS->myCR63] = pSiS->oldCR63;
       }
    }
}

static void
SiS_WriteAttr(SISPtr pSiS, int index, int value)
{
    (void) inb(pSiS->IODBase + VGA_IOBASE_COLOR + VGA_IN_STAT_1_OFFSET);
    index |= 0x20;
    outb(pSiS->IODBase + VGA_ATTR_INDEX, index);
    outb(pSiS->IODBase + VGA_ATTR_DATA_W, value);
}

static int
SiS_ReadAttr(SISPtr pSiS, int index)
{
    (void) inb(pSiS->IODBase + VGA_IOBASE_COLOR + VGA_IN_STAT_1_OFFSET);
    index |= 0x20;
    outb(pSiS->IODBase + VGA_ATTR_INDEX, index);
    return(inb(pSiS->IODBase + VGA_ATTR_DATA_R));
}

#define SIS_FONTS_SIZE (8 * 8192)

static void
SiS_SaveFonts(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char miscOut, attr10, gr4, gr5, gr6, seq2, seq4, scrn;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    CARD8 *vgaIOBase = (CARD8 *)VGAHWPTR(pScrn)->IOBase;
#else
    pointer vgaIOBase = VGAHWPTR(pScrn)->Base;
#endif

    if(pSiS->fonts) return;

    /* If in graphics mode, don't save anything */
    attr10 = SiS_ReadAttr(pSiS, 0x10);
    if(attr10 & 0x01) return;

    if(!(pSiS->fonts = xalloc(SIS_FONTS_SIZE * 2))) {
       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
       		"Could not save console fonts, mem allocation failed\n");
       return;
    }

    /* save the registers that are needed here */
    miscOut = inSISREG(SISMISCR);
    inSISIDXREG(SISGR, 0x04, gr4);
    inSISIDXREG(SISGR, 0x05, gr5);
    inSISIDXREG(SISGR, 0x06, gr6);
    inSISIDXREG(SISSR, 0x02, seq2);
    inSISIDXREG(SISSR, 0x04, seq4);

    /* Force into color mode */
    outSISREG(SISMISCW, miscOut | 0x01);

    inSISIDXREG(SISSR, 0x01, scrn);
    outSISIDXREG(SISSR, 0x00, 0x01);
    outSISIDXREG(SISSR, 0x01, scrn | 0x20);
    outSISIDXREG(SISSR, 0x00, 0x03);

    SiS_WriteAttr(pSiS, 0x10, 0x01);  /* graphics mode */

    /*font1 */
    outSISIDXREG(SISSR, 0x02, 0x04);  /* write to plane 2 */
    outSISIDXREG(SISSR, 0x04, 0x06);  /* enable plane graphics */
    outSISIDXREG(SISGR, 0x04, 0x02);  /* read plane 2 */
    outSISIDXREG(SISGR, 0x05, 0x00);  /* write mode 0, read mode 0 */
    outSISIDXREG(SISGR, 0x06, 0x05);  /* set graphics */
    slowbcopy_frombus(vgaIOBase, pSiS->fonts, SIS_FONTS_SIZE);

    /* font2 */
    outSISIDXREG(SISSR, 0x02, 0x08);  /* write to plane 3 */
    outSISIDXREG(SISSR, 0x04, 0x06);  /* enable plane graphics */
    outSISIDXREG(SISGR, 0x04, 0x03);  /* read plane 3 */
    outSISIDXREG(SISGR, 0x05, 0x00);  /* write mode 0, read mode 0 */
    outSISIDXREG(SISGR, 0x06, 0x05);  /* set graphics */
    slowbcopy_frombus(vgaIOBase, pSiS->fonts + SIS_FONTS_SIZE, SIS_FONTS_SIZE);

    inSISIDXREG(SISSR, 0x01, scrn);
    outSISIDXREG(SISSR, 0x00, 0x01);
    outSISIDXREG(SISSR, 0x01, scrn & ~0x20);
    outSISIDXREG(SISSR, 0x00, 0x03);

    /* Restore clobbered registers */
    SiS_WriteAttr(pSiS, 0x10, attr10);
    outSISIDXREG(SISSR, 0x02, seq2);
    outSISIDXREG(SISSR, 0x04, seq4);
    outSISIDXREG(SISGR, 0x04, gr4);
    outSISIDXREG(SISGR, 0x05, gr5);
    outSISIDXREG(SISGR, 0x06, gr6);
    outSISREG(SISMISCW, miscOut);
}

static void
SiS_RestoreFonts(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char miscOut, attr10, gr1, gr3, gr4, gr5, gr6, gr8, seq2, seq4, scrn;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    CARD8 *vgaIOBase = (CARD8 *)VGAHWPTR(pScrn)->IOBase;
#else
    pointer vgaIOBase = VGAHWPTR(pScrn)->Base;
#endif

    if(!pSiS->fonts) return;

    /* save the registers that are needed here */
    miscOut = inSISREG(SISMISCR);
    attr10 = SiS_ReadAttr(pSiS, 0x10);
    inSISIDXREG(SISGR, 0x01, gr1);
    inSISIDXREG(SISGR, 0x03, gr3);
    inSISIDXREG(SISGR, 0x04, gr4);
    inSISIDXREG(SISGR, 0x05, gr5);
    inSISIDXREG(SISGR, 0x06, gr6);
    inSISIDXREG(SISGR, 0x08, gr8);
    inSISIDXREG(SISSR, 0x02, seq2);
    inSISIDXREG(SISSR, 0x04, seq4);

    /* Force into color mode */
    outSISREG(SISMISCW, miscOut | 0x01);
    inSISIDXREG(SISSR, 0x01, scrn);
    outSISIDXREG(SISSR, 0x00, 0x01);
    outSISIDXREG(SISSR, 0x01, scrn | 0x20);
    outSISIDXREG(SISSR, 0x00, 0x03);

    SiS_WriteAttr(pSiS, 0x10, 0x01);	  /* graphics mode */
    if(pScrn->depth == 4) {
       outSISIDXREG(SISGR, 0x03, 0x00);  /* don't rotate, write unmodified */
       outSISIDXREG(SISGR, 0x08, 0xFF);  /* write all bits in a byte */
       outSISIDXREG(SISGR, 0x01, 0x00);  /* all planes come from CPU */
    }

    outSISIDXREG(SISSR, 0x02, 0x04); /* write to plane 2 */
    outSISIDXREG(SISSR, 0x04, 0x06); /* enable plane graphics */
    outSISIDXREG(SISGR, 0x04, 0x02); /* read plane 2 */
    outSISIDXREG(SISGR, 0x05, 0x00); /* write mode 0, read mode 0 */
    outSISIDXREG(SISGR, 0x06, 0x05); /* set graphics */
    slowbcopy_tobus(pSiS->fonts, vgaIOBase, SIS_FONTS_SIZE);

    outSISIDXREG(SISSR, 0x02, 0x08); /* write to plane 3 */
    outSISIDXREG(SISSR, 0x04, 0x06); /* enable plane graphics */
    outSISIDXREG(SISGR, 0x04, 0x03); /* read plane 3 */
    outSISIDXREG(SISGR, 0x05, 0x00); /* write mode 0, read mode 0 */
    outSISIDXREG(SISGR, 0x06, 0x05); /* set graphics */
    slowbcopy_tobus(pSiS->fonts + SIS_FONTS_SIZE, vgaIOBase, SIS_FONTS_SIZE);

    inSISIDXREG(SISSR, 0x01, scrn);
    outSISIDXREG(SISSR, 0x00, 0x01);
    outSISIDXREG(SISSR, 0x01, scrn & ~0x20);
    outSISIDXREG(SISSR, 0x00, 0x03);

    /* restore the registers that were changed */
    outSISREG(SISMISCW, miscOut);
    SiS_WriteAttr(pSiS, 0x10, attr10);
    outSISIDXREG(SISGR, 0x01, gr1);
    outSISIDXREG(SISGR, 0x03, gr3);
    outSISIDXREG(SISGR, 0x04, gr4);
    outSISIDXREG(SISGR, 0x05, gr5);
    outSISIDXREG(SISGR, 0x06, gr6);
    outSISIDXREG(SISGR, 0x08, gr8);
    outSISIDXREG(SISSR, 0x02, seq2);
    outSISIDXREG(SISSR, 0x04, seq4);
}

#undef SIS_FONTS_SIZE

/* VESASaveRestore taken from vesa driver */
static void
SISVESASaveRestore(ScrnInfoPtr pScrn, vbeSaveRestoreFunction function)
{
    SISPtr pSiS = SISPTR(pScrn);

    /* Query amount of memory to save state */
    if((function == MODE_QUERY) ||
       (function == MODE_SAVE && pSiS->state == NULL)) {

       /* Make sure we save at least this information in case of failure */
       (void)VBEGetVBEMode(pSiS->pVbe, &pSiS->stateMode);
       SiS_SaveFonts(pScrn);

       if(pSiS->vesamajor > 1) {
	  if(!VBESaveRestore(pSiS->pVbe, function, (pointer)&pSiS->state,
				&pSiS->stateSize, &pSiS->statePage)) {
	     return;
	  }
       }
    }

    /* Save/Restore Super VGA state */
    if(function != MODE_QUERY) {

       if(pSiS->vesamajor > 1) {
	  if(function == MODE_RESTORE) {
	     memcpy(pSiS->state, pSiS->pstate, pSiS->stateSize);
	  }

	  if(VBESaveRestore(pSiS->pVbe,function,(pointer)&pSiS->state,
			    &pSiS->stateSize,&pSiS->statePage) &&
	     (function == MODE_SAVE)) {
	     /* don't rely on the memory not being touched */
	     if(!pSiS->pstate) {
		pSiS->pstate = xalloc(pSiS->stateSize);
	     }
	     memcpy(pSiS->pstate, pSiS->state, pSiS->stateSize);
	  }
       }

       if(function == MODE_RESTORE) {
	  VBESetVBEMode(pSiS->pVbe, pSiS->stateMode, NULL);
	  SiS_RestoreFonts(pScrn);
       }

    }
}

/*
 * Initialise a new mode.  This is currently done using the
 * "initialise struct, restore/write struct to HW" model for
 * the old chipsets (5597/530/6326). For newer chipsets,
 * we use our own mode switching code (or VESA).
 */

static Bool
SISModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    vgaHWPtr hwp = VGAHWPTR(pScrn);
    vgaRegPtr vgaReg;
    SISPtr pSiS = SISPTR(pScrn);
    SISRegPtr sisReg;
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif

    andSISIDXREG(SISCR,0x11,0x7f);   	/* Unlock CRTC registers */

    SISModifyModeInfo(mode);		/* Quick check of the mode parameters */

    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
       SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO+0x30);
    }

    if(pSiS->UseVESA) {  /* With VESA: */

#ifdef SISDUALHEAD
       /* No dual head mode when using VESA */
       if(pSiS->SecondHead) return TRUE;
#endif

       pScrn->vtSema = TRUE;

       /*
	* This order is required:
	* The video bridge needs to be adjusted before the
	* BIOS is run as the BIOS sets up CRT2 according to
	* these register settings.
	* After the BIOS is run, the bridges and turboqueue
	* registers need to be readjusted as the BIOS may
	* very probably have messed them up.
	*/
       if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
	  SiSPreSetMode(pScrn, mode, SIS_MODE_SIMU);
       }
       if(!SiSSetVESAMode(pScrn, mode)) {
	  SISErrorLog(pScrn, "SiSSetVESAMode() failed\n");
	  return FALSE;
       }
       sisSaveUnlockExtRegisterLock(pSiS,NULL,NULL);
       if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
	  SiSPreSetMode(pScrn, mode, SIS_MODE_SIMU);
	  SiSPostSetMode(pScrn, &pSiS->ModeReg);
       }
#ifdef TWDEBUG
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "REAL REGISTER CONTENTS AFTER SETMODE:\n");
#endif
       if(!(*pSiS->ModeInit)(pScrn, mode)) {
	  SISErrorLog(pScrn, "ModeInit() failed\n");
	  return FALSE;
       }

       vgaHWProtect(pScrn, TRUE);
       (*pSiS->SiSRestore)(pScrn, &pSiS->ModeReg);
       vgaHWProtect(pScrn, FALSE);

    } else { /* Without VESA: */

#ifdef SISDUALHEAD
       if(pSiS->DualHeadMode) {

          if(!(*pSiS->ModeInit)(pScrn, mode)) {
	     SISErrorLog(pScrn, "ModeInit() failed\n");
	     return FALSE;
	  }

	  pScrn->vtSema = TRUE;

	  pSiSEnt = pSiS->entityPrivate;

	  if(!(pSiS->SecondHead)) {
	     /* Head 1 (master) is always CRT2 */
	     SiSPreSetMode(pScrn, mode, SIS_MODE_CRT2);
	     if(!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn, mode, pSiS->IsCustom)) {
		SISErrorLog(pScrn, "SiSBIOSSetModeCRT2() failed\n");
		return FALSE;
	     }
	     SiSPostSetMode(pScrn, &pSiS->ModeReg);
	     SISAdjustFrame(pSiSEnt->pScrn_2->scrnIndex,
		            pSiSEnt->pScrn_2->frameX0,
		            pSiSEnt->pScrn_2->frameY0, 0);
	  } else {
	     /* Head 2 (slave) is always CRT1 */
	     SiSPreSetMode(pScrn, mode, SIS_MODE_CRT1);
	     if(!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn, mode, pSiS->IsCustom)) {
		SISErrorLog(pScrn, "SiSBIOSSetModeCRT1() failed\n");
		return FALSE;
	     }
	     SiSPostSetMode(pScrn, &pSiS->ModeReg);
	     SISAdjustFrame(pSiSEnt->pScrn_1->scrnIndex,
		            pSiSEnt->pScrn_1->frameX0,
		            pSiSEnt->pScrn_1->frameY0, 0);
	  }

       } else {
#endif

	  if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {

             if(!(*pSiS->ModeInit)(pScrn, mode)) {
		SISErrorLog(pScrn, "ModeInit() failed\n");
	        return FALSE;
	     }

	     pScrn->vtSema = TRUE;

#ifdef SISMERGED
	     if(pSiS->MergedFB) {

	        xf86DrvMsg(0, X_INFO, "Setting MergedFB mode %dx%d\n",
			   	mode->HDisplay, mode->VDisplay);

		SiSPreSetMode(pScrn, mode, SIS_MODE_CRT1);

		if(!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn,
		                       ((SiSMergedDisplayModePtr)mode->Private)->CRT1,
				       pSiS->IsCustom)) {
 		   SISErrorLog(pScrn, "SiSBIOSSetModeCRT1() failed\n");
	   	   return FALSE;
		}

		SiSPreSetMode(pScrn, mode, SIS_MODE_CRT2);

		if(!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn,
		                       ((SiSMergedDisplayModePtr)mode->Private)->CRT2,
				       pSiS->IsCustomCRT2)) {
	 	   SISErrorLog(pScrn, "SiSBIOSSetModeCRT2() failed\n");
		   return FALSE;
	        }

	     } else {
#endif

		if(pSiS->VBFlags & CRT1_LCDA) {
	           SiSPreSetMode(pScrn, mode, SIS_MODE_CRT1);
	           if(!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn,
		                   mode, pSiS->IsCustom)) {
		      SISErrorLog(pScrn, "SiSBIOSSetModeCRT1() failed\n");
		      return FALSE;
		   }
		   SiSPreSetMode(pScrn, mode, SIS_MODE_CRT2);
	           if(!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn,
		                   mode, pSiS->IsCustom)) {
		      SISErrorLog(pScrn, "SiSBIOSSetModeCRT2() failed\n");
		      return FALSE;
		   }
		} else {
		   SiSPreSetMode(pScrn, mode, SIS_MODE_SIMU);
	           if(!SiSBIOSSetMode(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn,
		                   mode, pSiS->IsCustom)) {
		      SISErrorLog(pScrn, "SiSBIOSSetModeCRT() failed\n");
		      return FALSE;
		   }
		}

#ifdef SISMERGED
	     }
#endif
	     SiSPostSetMode(pScrn, &pSiS->ModeReg);

#ifdef TWDEBUG
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "VBFlags %lx\n", pSiS->VBFlags);
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"REAL REGISTER CONTENTS AFTER SETMODE:\n");
             (*pSiS->ModeInit)(pScrn, mode);
#endif

	  } else {

	     /* For other chipsets, use the old method */

	     /* Initialise the ModeReg values */
    	     if(!vgaHWInit(pScrn, mode)) {
	        SISErrorLog(pScrn, "vgaHWInit() failed\n");
	        return FALSE;
	     }

	     /* Reset our PIOOffset as vgaHWInit might have reset it */
      	     VGAHWPTR(pScrn)->PIOOffset = pSiS->IODBase + (pSiS->PciInfo->ioBase[2] & 0xFFFC) - 0x380;

	     /* Prepare the register contents */
	     if(!(*pSiS->ModeInit)(pScrn, mode)) {
	        SISErrorLog(pScrn, "ModeInit() failed\n");
	        return FALSE;
	     }

	     pScrn->vtSema = TRUE;

	     /* Program the registers */
	     vgaHWProtect(pScrn, TRUE);
	     vgaReg = &hwp->ModeReg;
	     sisReg = &pSiS->ModeReg;

	     vgaReg->Attribute[0x10] = 0x01;
    	     if(pScrn->bitsPerPixel > 8) {
	    	vgaReg->Graphics[0x05] = 0x00;
	     }

    	     vgaHWRestore(pScrn, vgaReg, VGA_SR_MODE);

	     (*pSiS->SiSRestore)(pScrn, sisReg);

	     if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
	        SiS6326PostSetMode(pScrn, &pSiS->ModeReg);
	     }

#ifdef TWDEBUG
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"REAL REGISTER CONTENTS AFTER SETMODE:\n");
             (*pSiS->ModeInit)(pScrn, mode);
#endif

  	     vgaHWProtect(pScrn, FALSE);
	  }
#ifdef SISDUALHEAD
       }
#endif
    }

    /* Update Currentlayout */
    pSiS->CurrentLayout.mode = mode;

    return TRUE;
}

static Bool
SiSSetVESAMode(ScrnInfoPtr pScrn, DisplayModePtr pMode)
{
    SISPtr pSiS;
    int mode;

    pSiS = SISPTR(pScrn);

    if(!(mode = SiSCalcVESAModeIndex(pScrn, pMode))) return FALSE;

    mode |= (1 << 15);	/* Don't clear framebuffer */
    mode |= (1 << 14);   	/* Use linear adressing */

    if(VBESetVBEMode(pSiS->pVbe, mode, NULL) == FALSE) {
       SISErrorLog(pScrn, "Setting VESA mode 0x%x failed\n",
	             	mode & 0x0fff);
       return (FALSE);
    }

    if(pMode->HDisplay != pScrn->virtualX) {
       VBESetLogicalScanline(pSiS->pVbe, pScrn->virtualX);
    }

    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
    	"Setting VESA mode 0x%x succeeded\n",
	mode & 0x0fff);

    return (TRUE);
}

static void
SISSpecialRestore(ScrnInfoPtr pScrn)
{
    SISPtr    pSiS = SISPTR(pScrn);
    SISRegPtr sisReg = &pSiS->SavedReg;
    unsigned char temp;
    int i;

    /* 1.11.04 and later for 651 and 301B(DH) do strange register
     * fiddling after the usual mode change. This happens
     * depending on the result of a call of int 2f (with
     * ax=0x1680) and if modeno <= 0x13. I have no idea if
     * that is specific for the 651 or that very machine.
     * So this perhaps requires some more checks in the beginning
     * (although it should not do any harm on other chipsets/bridges
     * etc.) However, even if I call the VBE to restore mode 0x03,
     * these registers don't get restored correctly, possibly
     * because that int-2f-call for some reason results non-zero. So
     * what I do here is to restore these few registers
     * manually.
     */

    if(!(pSiS->ChipFlags & SiSCF_Is65x)) return;
    inSISIDXREG(SISCR, 0x34, temp);
    temp &= 0x7f;
    if(temp > 0x13) return;

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL,NULL);
#endif

    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);

    outSISIDXREG(SISCAP, 0x3f, sisReg->sisCapt[0x3f]);
    outSISIDXREG(SISCAP, 0x00, sisReg->sisCapt[0x00]);
    for(i = 0; i < 0x4f; i++) {
       outSISIDXREG(SISCAP, i, sisReg->sisCapt[i]);
    }
    outSISIDXREG(SISVID, 0x32, (sisReg->sisVid[0x32] & ~0x05));
    outSISIDXREG(SISVID, 0x30, sisReg->sisVid[0x30]);
    outSISIDXREG(SISVID, 0x32, ((sisReg->sisVid[0x32] & ~0x04) | 0x01));
    outSISIDXREG(SISVID, 0x30, sisReg->sisVid[0x30]);

    if(!(pSiS->ChipFlags & SiSCF_Is651)) return;
    if(!(pSiS->VBFlags & VB_SISBRIDGE)) return;

    inSISIDXREG(SISCR, 0x30, temp);
    if(temp & 0x40) {
       unsigned char myregs[] = {
       			0x2f, 0x08, 0x09, 0x03, 0x0a, 0x0c,
			0x0b, 0x0d, 0x0e, 0x12, 0x0f, 0x10,
			0x11, 0x04, 0x05, 0x06, 0x07, 0x00,
			0x2e
       };
       for(i = 0; i <= 18; i++) {
          outSISIDXREG(SISPART1, myregs[i], sisReg->VBPart1[myregs[i]]);
       }
    } else if((temp & 0x20) || (temp & 0x9c)) {
       unsigned char myregs[] = {
       			0x04, 0x05, 0x06, 0x07, 0x00, 0x2e
       };
       for(i = 0; i <= 5; i++) {
          outSISIDXREG(SISPART1, myregs[i], sisReg->VBPart1[myregs[i]]);
       }
    }
}

/*
 * Restore the initial mode. To be used internally only!
 */
static void
SISRestore(ScrnInfoPtr pScrn)
{
    SISPtr    pSiS = SISPTR(pScrn);
    SISRegPtr sisReg = &pSiS->SavedReg;
    vgaHWPtr  hwp = VGAHWPTR(pScrn);
    vgaRegPtr vgaReg = &hwp->SavedReg;
    Bool      doit = FALSE, doitlater = FALSE;
    Bool      vesasuccess = FALSE;
    
    /* WARNING: Don't ever touch this. It now seems to work on
     * all chipset/bridge combinations - but finding out the
     * correct combination was pure hell.
     */

    /* Wait for the accelerators */
    if(pSiS->AccelInfoPtr) {
       (*pSiS->AccelInfoPtr->Sync)(pScrn);
    }

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {

#ifdef SISDUALHEAD
       /* We always restore master AND slave */
       if(pSiS->DualHeadMode && pSiS->SecondHead) return;
#endif

       /* We must not disable the sequencer if the bridge is in SlaveMode! */
       if(!(SiSBridgeIsInSlaveMode(pScrn))) {
          vgaHWProtect(pScrn, TRUE);
       }

#ifdef UNLOCK_ALWAYS
       sisSaveUnlockExtRegisterLock(pSiS, NULL,NULL);
#endif

       /* First, restore CRT1 on/off and VB connection registers */
       outSISIDXREG(SISCR, 0x32, pSiS->oldCR32);
       if(!(pSiS->oldCR17 & 0x80)) {			/* CRT1 was off */
          if(!(SiSBridgeIsInSlaveMode(pScrn))) {        /* Bridge is NOT in SlaveMode now -> do it */
	     doit = TRUE;
	  } else {
	     doitlater = TRUE;
	  }
       } else {						/* CRT1 was on -> do it now */
          doit = TRUE;
       }
       
       if(doit) {
          outSISIDXREG(SISCR, 0x17, pSiS->oldCR17);
       }
       if(pSiS->VGAEngine == SIS_315_VGA) {
          outSISIDXREG(SISCR, pSiS->myCR63, pSiS->oldCR63);
       }

       outSISIDXREG(SISSR, 0x1f, pSiS->oldSR1F);

       /* For 30xB/LV, restoring the registers does not
        * work. We "manually" set the old mode, instead.
	* The same applies for SiS730 machines with LVDS.
	* Finally, this behavior can be forced by setting
	* the option RestoreBySetMode.
        */
        if( ( (pSiS->restorebyset) ||
	      (pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV)) ||
	      ((pSiS->sishw_ext.jChipType == SIS_730) && (pSiS->VBFlags & VB_LVDS)) ) &&
	    (pSiS->OldMode) ) {

	   Bool changedmode = FALSE;
	   
           xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
	         "Restoring by setting old mode 0x%02x\n", pSiS->OldMode);
		 
           if(((pSiS->OldMode <= 0x13) || (!pSiS->sisfbfound)) && (pSiS->pVbe)) {
	      int vmode = SiSTranslateToVESA(pScrn, pSiS->OldMode);
	      if(vmode > 0) {
	         if(vmode > 0x13) vmode |= ((1 << 15) | (1 << 14));
                 if(VBESetVBEMode(pSiS->pVbe, vmode, NULL) == TRUE) {
	            SISSpecialRestore(pScrn);
		    SiS_GetSetModeID(pScrn,pSiS->OldMode);
	      	    vesasuccess = TRUE;
	         } else {
	            xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
		 	"VBE failed to restore mode 0x%x\n", pSiS->OldMode);
	         }
	      } else {
	         xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
		 	"Can't identify VESA mode number for mode 0x%x\n", pSiS->OldMode);
	      }
           }

	   if(vesasuccess == FALSE) {

	      int backupscaler = pSiS->SiS_Pr->UsePanelScaler;
	      unsigned long backupspecialtiming = pSiS->SiS_Pr->SiS_CustomT;

 	      if((pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV))) {
	        /* !!! REQUIRED for 630+301B-DH, otherwise the text modes
	         *     will not be restored correctly !!!
	         * !!! Do this ONLY for LCD; VGA2 will not be restored
	         *     correctly otherwise.
	         */
	         unsigned char temp;
	         inSISIDXREG(SISCR, 0x30, temp);
	         if(temp & 0x20) {
	            if(pSiS->OldMode == 0x03) {
	      	       pSiS->OldMode = 0x13;
		       changedmode = TRUE;
	            }
	         }
	      }

	      pSiS->SiS_Pr->UseCustomMode = FALSE;
	      pSiS->SiS_Pr->CRT1UsesCustomMode = FALSE;
	      pSiS->SiS_Pr->UsePanelScaler = pSiS->sisfbscalelcd;
	      pSiS->SiS_Pr->SiS_CustomT = pSiS->sisfbspecialtiming;
	      SiSSetMode(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn, pSiS->OldMode, FALSE);
	      if(changedmode) {
	   	 pSiS->OldMode = 0x03;
		 outSISIDXREG(SISCR,0x34,0x03);
	      }
	      SISSpecialRestore(pScrn);
	      SiS_GetSetModeID(pScrn,pSiS->OldMode);
	      pSiS->SiS_Pr->UsePanelScaler = backupscaler;
	      pSiS->SiS_Pr->SiS_CustomT = backupspecialtiming;

	   }

	   /* Restore CRT1 status */
	   if(pSiS->VGAEngine == SIS_315_VGA) {
              outSISIDXREG(SISCR, pSiS->myCR63, pSiS->oldCR63);
           }
           outSISIDXREG(SISSR, 0x1f, pSiS->oldSR1F);

#ifdef SISVRAMQ
	   /* Restore queue mode registers on 315/330 series */
	   /* (This became necessary due to the switch to VRAM queue) */
	   if(pSiS->VGAEngine == SIS_315_VGA) {
	      unsigned char tempCR55=0;
	      if(pSiS->sishw_ext.jChipType <= SIS_330) {
	         inSISIDXREG(SISCR,0x55,tempCR55);
	         andSISIDXREG(SISCR,0x55,0x33);
	      }
	      outSISIDXREG(SISSR,0x26,0x01);
	      MMIO_OUT32(pSiS->IOBase, 0x85c4, 0);
	      outSISIDXREG(SISSR,0x27,sisReg->sisRegs3C4[0x27]);
	      outSISIDXREG(SISSR,0x26,sisReg->sisRegs3C4[0x26]);
	      MMIO_OUT32(pSiS->IOBase, 0x85C0, sisReg->sisMMIO85C0);
	      if(pSiS->sishw_ext.jChipType <= SIS_330) {
	         outSISIDXREG(SISCR,0x55,tempCR55);
	      }
	   }
#endif

        } else {

	   if(pSiS->VBFlags & VB_VIDEOBRIDGE) {
	      /* If a video bridge is present, we need to restore
	       * non-extended (=standard VGA) SR and CR registers
	       * before restoring the extended ones and the bridge
	       * registers itself.
	       */
	      if(!(SiSBridgeIsInSlaveMode(pScrn))) {
                 vgaHWProtect(pScrn, TRUE);
		 
		 if(pSiS->Primary) {
	            vgaHWRestore(pScrn, vgaReg, VGA_SR_MODE);
	         }
              } 
	   }
	   
           (*pSiS->SiSRestore)(pScrn, sisReg);

        }

	if(doitlater) {
            outSISIDXREG(SISCR, 0x17, pSiS->oldCR17);
	}

	if(pSiS->Primary) {
	   if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (SiSBridgeIsInSlaveMode(pScrn))) {
	      /* IMPORTANT: The 30xLV does not handle well being disabled if in
	       * LCDA mode! In LCDA mode, the bridge is NOT in slave mode,
	       * so this is the only safe way: Disable the bridge ONLY if
	       * in Slave Mode, and don't bother if not.
	       */
              SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO+0x30);
	      SiSSetLVDSetc(pSiS->SiS_Pr, &pSiS->sishw_ext, 0);
	      SiS_GetVBType(pSiS->SiS_Pr, &pSiS->sishw_ext);
	      SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);

	      vgaHWProtect(pScrn, TRUE);

	      /* We now restore ALL to overcome the vga=extended problem */
	      vgaHWRestore(pScrn, vgaReg, VGA_SR_ALL);

	      vgaHWProtect(pScrn, FALSE);

	      SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
	      andSISIDXREG(SISSR, 0x01, ~0x20);  /* Display on */
	   } else {
	      vgaHWProtect(pScrn, TRUE);

	      /* We now restore ALL to overcome the vga=extended problem */
	      vgaHWRestore(pScrn, vgaReg, VGA_SR_ALL);

	      vgaHWProtect(pScrn, FALSE);
	   }
	}

#ifdef TWDEBUG
	{
	  SISRegPtr pReg = &pSiS->ModeReg;
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"REAL REGISTER CONTENTS AFTER RESTORE BY SETMODE:\n");
	  (*pSiS->SiSSave)(pScrn, pReg);
	}
#endif	
	
	sisRestoreExtRegisterLock(pSiS,sisReg->sisRegs3C4[0x05],sisReg->sisRegs3D4[0x80]);
    
    } else {	/* All other chipsets */

        vgaHWProtect(pScrn, TRUE);
	
#ifdef UNLOCK_ALWAYS
        sisSaveUnlockExtRegisterLock(pSiS, NULL,NULL);
#endif

        (*pSiS->SiSRestore)(pScrn, sisReg);

        vgaHWProtect(pScrn, TRUE);
	if(pSiS->Primary) {
           vgaHWRestore(pScrn, vgaReg, VGA_SR_ALL);
	}

	/* Restore TV. This is rather complicated, but if we don't do it,
	 * TV output will flicker terribly
	 */
        if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
	   if(sisReg->sis6326tv[0] & 0x04) {
	      unsigned char tmp;
	      int val;

              orSISIDXREG(SISSR, 0x01, 0x20);
              tmp = SiS6326GetTVReg(pScrn,0x00);
              tmp &= ~0x04;
              while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
              SiS6326SetTVReg(pScrn,0x00,tmp);
              for(val=0; val < 2; val++) {
                 while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
                 while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
              }
              SiS6326SetTVReg(pScrn, 0x00, sisReg->sis6326tv[0]);
              tmp = inSISREG(SISINPSTAT);
              outSISREG(SISAR, 0x20);
              tmp = inSISREG(SISINPSTAT);
              while(inSISREG(SISINPSTAT) & 0x01);
              while(!(inSISREG(SISINPSTAT) & 0x01));
              andSISIDXREG(SISSR, 0x01, ~0x20);
              for(val=0; val < 10; val++) {
                 while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
                 while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
              }
              andSISIDXREG(SISSR, 0x01, ~0x20);
	   }
        }

        sisRestoreExtRegisterLock(pSiS,sisReg->sisRegs3C4[5],sisReg->sisRegs3D4[0x80]);

        vgaHWProtect(pScrn, FALSE);
    }
}

static void
SISVESARestore(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);

   if(pSiS->UseVESA) {
      SISVESASaveRestore(pScrn, MODE_RESTORE);
#ifdef SISVRAMQ
      /* Restore queue mode registers on 315/330 series */
      /* (This became necessary due to the switch to VRAM queue) */
      if(pSiS->VGAEngine == SIS_315_VGA) {
         SISRegPtr sisReg = &pSiS->SavedReg;
	 unsigned char tempCR55=0;
	 if(pSiS->sishw_ext.jChipType <= SIS_330) {
	    inSISIDXREG(SISCR,0x55,tempCR55);
	    andSISIDXREG(SISCR,0x55,0x33);
	 }
	 outSISIDXREG(SISSR,0x26,0x01);
	 MMIO_OUT32(pSiS->IOBase, 0x85c4, 0);
	 outSISIDXREG(SISSR,0x27,sisReg->sisRegs3C4[0x27]);
	 outSISIDXREG(SISSR,0x26,sisReg->sisRegs3C4[0x26]);
	 MMIO_OUT32(pSiS->IOBase, 0x85C0, sisReg->sisMMIO85C0);
	 if(pSiS->sishw_ext.jChipType <= SIS_330) {
	    outSISIDXREG(SISCR,0x55,tempCR55);
	 }
      }
#endif
   }
}

/* Restore bridge config registers - to be called BEFORE VESARestore */
static void
SISBridgeRestore(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);

#ifdef SISDUALHEAD
    /* We only restore for master head */
    if(pSiS->DualHeadMode && pSiS->SecondHead) return;
#endif

    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
	SiSRestoreBridge(pScrn, &pSiS->SavedReg);
    }
}

/* Our generic BlockHandler for Xv */
static void
SISBlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
{
    ScreenPtr pScreen = screenInfo.screens[i];
    ScrnInfoPtr pScrn   = xf86Screens[i];
    SISPtr pSiS = SISPTR(pScrn);

    pScreen->BlockHandler = pSiS->BlockHandler;
    (*pScreen->BlockHandler) (i, blockData, pTimeout, pReadmask);
    pScreen->BlockHandler = SISBlockHandler;

    if(pSiS->VideoTimerCallback) {
       (*pSiS->VideoTimerCallback)(pScrn, currentTime.milliseconds);
    }

    if(pSiS->RenderCallback) {
       (*pSiS->RenderCallback)(pScrn);
    }
}

/* Mandatory
 * This gets called at the start of each server generation
 *
 * We use pScrn and not CurrentLayout here, because the
 * properties we use have not changed (displayWidth,
 * depth, bitsPerPixel)
 */
static Bool
SISScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
{
    ScrnInfoPtr pScrn;
    vgaHWPtr hwp;
    SISPtr pSiS;
    int ret;
    VisualPtr visual;
    unsigned long OnScreenSize;
    int height, width, displayWidth;
    unsigned char *FBStart;
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif

    pScrn = xf86Screens[pScreen->myNum];

    hwp = VGAHWPTR(pScrn);

    pSiS = SISPTR(pScrn);

#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead)) {
#endif    
       if(xf86LoadSubModule(pScrn, "vbe")) {
	  xf86LoaderReqSymLists(vbeSymbols, NULL);
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
          pSiS->pVbe = VBEInit(NULL, pSiS->pEnt->index);
#else
          pSiS->pVbe = VBEExtendedInit(NULL, pSiS->pEnt->index,
	                   SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
#endif
       } else {
          SISErrorLog(pScrn, "Failed to load VBE submodule\n");
       }
#ifdef SISDUALHEAD
    }
#endif

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       pSiSEnt = pSiS->entityPrivate;
       pSiSEnt->refCount++;
    }
#endif

    /* Map the VGA memory and get the VGA IO base */
    if(pSiS->Primary) {
       hwp->MapSize = 0x10000;  /* Standard 64k VGA window */
       if(!vgaHWMapMem(pScrn)) {
          SISErrorLog(pScrn, "Could not map VGA memory window\n");
          return FALSE;
       }
    }
    vgaHWGetIOBase(hwp);
    
    /* Patch the PIOOffset inside vgaHW to use
     * our relocated IO ports.
     */
    VGAHWPTR(pScrn)->PIOOffset = pSiS->IODBase + (pSiS->PciInfo->ioBase[2] & 0xFFFC) - 0x380;

    /* Map the SIS memory and MMIO areas */
    if(!SISMapMem(pScrn)) {
       SISErrorLog(pScrn, "SiSMapMem() failed\n");
       return FALSE;
    }

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    /* Enable TurboQueue so that SISSave() saves it in enabled
     * state. If we don't do this, X will hang after a restart!
     * (Happens for some unknown reason only when using VESA
     * for mode switching; assumingly a BIOS issue.)
     * This is done on 300 and 315 series only.
     */
    if(pSiS->UseVESA) {
#ifdef SISVRAMQ
       if(pSiS->VGAEngine != SIS_315_VGA)
#endif
          SiSEnableTurboQueue(pScrn);

    }

    /* Save the current state */
    SISSave(pScrn);

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {

       if(!pSiS->OldMode) {

          /* Try to find out current (=old) mode number
	   * (Do this only if not sisfb has told us its mode yet)
	   */

	  /* Read 0:449 which the BIOS sets to the current mode number
	   * Unfortunately, this not reliable since the int10 emulation
	   * does not change this. So if we call the VBE later, this
	   * byte won't be touched (which is why we set this manually
	   * then).
	   */
          unsigned char myoldmode = SiS_GetSetModeID(pScrn,0xFF);
	  unsigned char cr30, cr31;

          /* Read CR34 which the BIOS sets to the current mode number for CRT2
	   * This is - of course - not reliable if the machine has no video
	   * bridge...
	   */
          inSISIDXREG(SISCR, 0x34, pSiS->OldMode);
	  inSISIDXREG(SISCR, 0x30, cr30);
	  inSISIDXREG(SISCR, 0x31, cr31);

	  /* What if CR34 is different from the BIOS byte? */
	  if(pSiS->OldMode != myoldmode) {
	     /* If no bridge output is active, trust the BIOS byte */
	     if(!cr31 && !cr30) pSiS->OldMode = myoldmode;
	     /* ..else trust CR34 */
	  }

	  /* Newer 650 BIOSes set CR34 to 0xff if the mode has been
	   * "patched", for instance for 80x50 text mode. (That mode
	   * has no number of its own, it's 0x03 like 80x25). In this
	   * case, we trust the BIOS byte (provided that any of these
	   * two is valid).
	   */
	  if(pSiS->OldMode > 0x7f) {
	     pSiS->OldMode = myoldmode;
	  }
       }
#ifdef SISDUALHEAD
       if(pSiS->DualHeadMode) {
          if(!pSiS->SecondHead) pSiSEnt->OldMode = pSiS->OldMode;
          else                  pSiS->OldMode = pSiSEnt->OldMode;
       }
#endif
    }

    /* Initialise the first mode */
    if(!SISModeInit(pScrn, pScrn->currentMode)) {
       SISErrorLog(pScrn, "SiSModeInit() failed\n");
       return FALSE;
    }

    /* Darken the screen for aesthetic reasons */
    /* Not using Dual Head variant on purpose; we darken
     * the screen for both displays, and un-darken
     * it when the second head is finished
     */
    SISSaveScreen(pScreen, SCREEN_SAVER_ON);

    /* Set the viewport */
    SISAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);

    /*
     * The next step is to setup the screen's visuals, and initialise the
     * framebuffer code.  In cases where the framebuffer's default
     * choices for things like visual layouts and bits per RGB are OK,
     * this may be as simple as calling the framebuffer's ScreenInit()
     * function.  If not, the visuals will need to be setup before calling
     * a fb ScreenInit() function and fixed up after.
     *
     * For most PC hardware at depths >= 8, the defaults that cfb uses
     * are not appropriate.  In this driver, we fixup the visuals after.
     */

    /*
     * Reset visual list.
     */
    miClearVisualTypes();

    /* Setup the visuals we support. */

    /*
     * For bpp > 8, the default visuals are not acceptable because we only
     * support TrueColor and not DirectColor.
     */
    if(!miSetVisualTypes(pScrn->depth,
    			 (pScrn->bitsPerPixel > 8) ?
			 	TrueColorMask : miGetDefaultVisualMask(pScrn->depth),
			 pScrn->rgbBits, pScrn->defaultVisual)) {
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       SISErrorLog(pScrn, "miSetVisualTypes() failed (bpp %d)\n",
	  		pScrn->bitsPerPixel);
       return FALSE;
    }

    width = pScrn->virtualX;
    height = pScrn->virtualY;
    displayWidth = pScrn->displayWidth;

    if(pSiS->Rotate) {
       height = pScrn->virtualX;
       width = pScrn->virtualY;
    }

    if(pSiS->ShadowFB) {
       pSiS->ShadowPitch = BitmapBytePad(pScrn->bitsPerPixel * width);
       pSiS->ShadowPtr = xalloc(pSiS->ShadowPitch * height);
       displayWidth = pSiS->ShadowPitch / (pScrn->bitsPerPixel >> 3);
       FBStart = pSiS->ShadowPtr;
    } else {
       pSiS->ShadowPtr = NULL;
       FBStart = pSiS->FbBase;
    }

    if(!miSetPixmapDepths()) {
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       SISErrorLog(pScrn, "miSetPixmapDepths() failed\n");
       return FALSE;
    }

    /* Point cmdQueuePtr to pSiSEnt for shared usage
     * (same technique is then eventually used in DRIScreeninit)
     * For 315/330 series, this is done in EnableTurboQueue
     * which has already been called during ModeInit().
     */
#ifdef SISDUALHEAD
    if(pSiS->SecondHead)
       pSiS->cmdQueueLenPtr = &(SISPTR(pSiSEnt->pScrn_1)->cmdQueueLen);
    else
#endif
       pSiS->cmdQueueLenPtr = &(pSiS->cmdQueueLen);

    pSiS->cmdQueueLen = 0; /* Force an EngineIdle() at start */

#ifdef XF86DRI
    if(pSiS->loadDRI) {
#ifdef SISDUALHEAD
       /* No DRI in dual head mode */
       if(pSiS->DualHeadMode) {
          pSiS->directRenderingEnabled = FALSE;
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"DRI not supported in Dual Head mode\n");
       } else
#endif
          /* Force the initialization of the context */
              if(pSiS->VGAEngine != SIS_315_VGA) {
          pSiS->directRenderingEnabled = SISDRIScreenInit(pScreen);
       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_NOT_IMPLEMENTED,
	        "DRI not supported on this chipset\n");
          pSiS->directRenderingEnabled = FALSE;
       }
    }
#endif

    /*
     * Call the framebuffer layer's ScreenInit function, and fill in other
     * pScreen fields.
     */
    switch(pScrn->bitsPerPixel) {
      case 24:
        if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	   ret = FALSE;
	   break;
        }
      case 8:
      case 16:
      case 32:
        ret = fbScreenInit(pScreen, FBStart, width,
                        height, pScrn->xDpi, pScrn->yDpi,
                        displayWidth, pScrn->bitsPerPixel);
        break;
      default:
        ret = FALSE;
        break;
    }
    if(!ret) {
       SISErrorLog(pScrn, "Unsupported bpp (%d) or fbScreenInit() failed\n",
               pScrn->bitsPerPixel);
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       return FALSE;
    }

    if(pScrn->bitsPerPixel > 8) {
       /* Fixup RGB ordering */
       visual = pScreen->visuals + pScreen->numVisuals;
       while (--visual >= pScreen->visuals) {
          if((visual->class | DynamicClass) == DirectColor) {
             visual->offsetRed = pScrn->offset.red;
             visual->offsetGreen = pScrn->offset.green;
             visual->offsetBlue = pScrn->offset.blue;
             visual->redMask = pScrn->mask.red;
             visual->greenMask = pScrn->mask.green;
             visual->blueMask = pScrn->mask.blue;
          }
       }
    }

    /* Initialize RENDER ext; must be after RGB ordering fixed */
    fbPictureInit(pScreen, 0, 0);

    /* hardware cursor needs to wrap this layer    <-- TW: what does that mean? */
    if(!pSiS->ShadowFB) SISDGAInit(pScreen);

    xf86SetBlackWhitePixels(pScreen);

    if(!pSiS->NoAccel) {
       switch(pSiS->VGAEngine) {
	  case SIS_530_VGA:
	  case SIS_300_VGA:
            SiS300AccelInit(pScreen);
	    break;
	  case SIS_315_VGA:
	    SiS315AccelInit(pScreen);
	    break;
          default:
            SiSAccelInit(pScreen);
       }
    }
    miInitializeBackingStore(pScreen);
    xf86SetBackingStore(pScreen);
    xf86SetSilkenMouse(pScreen);

    /* Initialise cursor functions */
    miDCInitialize(pScreen, xf86GetPointerScreenFuncs());

    if(pSiS->HWCursor) {
       SiSHWCursorInit(pScreen);
    }

    /* Initialise default colourmap */
    if(!miCreateDefColormap(pScreen)) {
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       SISErrorLog(pScrn, "miCreateDefColormap() failed\n");
       return FALSE;
    }

    if(!xf86HandleColormaps(pScreen, 256, (pScrn->depth == 8) ? 8 : pScrn->rgbBits,
                    SISLoadPalette, NULL,
                    CMAP_PALETTED_TRUECOLOR | CMAP_RELOAD_ON_MODE_SWITCH)) {
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       SISErrorLog(pScrn, "xf86HandleColormaps() failed\n");
       return FALSE;
    }

#if 0
    if((pSiS->GammaBriR != 1000) || (pSiS->GammaBriG != 1000) ||
       (pSiS->GammaBriB != 1000) || (pSiS->GammaPBriR != 1000) ||
       (pSiS->GammaPBriG != 1000) || (pSiS->GammaPBriB != 1000)) {
       SISCalculateGammaRamp(pScrn);
    }
#endif

    if(pSiS->ShadowFB) {
       RefreshAreaFuncPtr refreshArea = SISRefreshArea;

       if(pSiS->Rotate) {
          if(!pSiS->PointerMoved) {
             pSiS->PointerMoved = pScrn->PointerMoved;
             pScrn->PointerMoved = SISPointerMoved;
          }

          switch(pScrn->bitsPerPixel) {
             case 8:  refreshArea = SISRefreshArea8;  break;
             case 16: refreshArea = SISRefreshArea16; break;
             case 24: refreshArea = SISRefreshArea24; break;
             case 32: refreshArea = SISRefreshArea32; break;
          }
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,0,0,0)
	  xf86DisableRandR();
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	  	"Driver rotation enabled, RandR disabled\n");
#endif
       }

       ShadowFBInit(pScreen, refreshArea);
    }

    xf86DPMSInit(pScreen, (DPMSSetProcPtr)SISDisplayPowerManagementSet, 0);

    /* Init memPhysBase and fbOffset in pScrn */
    pScrn->memPhysBase = pSiS->FbAddress;
    pScrn->fbOffset = 0;
    
    pSiS->ResetXv = pSiS->ResetXvGamma = NULL;

#if (XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,99,0,0)) || (defined(XvExtension))
    if(!pSiS->NoXvideo) {
        if( (pSiS->VGAEngine == SIS_300_VGA) ||
	    (pSiS->VGAEngine == SIS_315_VGA) ) {
#ifdef SISDUALHEAD
              if(pSiS->DualHeadMode) {
		 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		     "Using SiS300/315 series HW Xv on CRT%d\n",
		     (pSiS->SecondHead ? 1 : 2));
		 if(!pSiS->hasTwoOverlays) {
		    if( (pSiS->XvOnCRT2 && pSiS->SecondHead) ||
		        (!pSiS->XvOnCRT2 && !pSiS->SecondHead) ) {
		       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		           "However, overlay will by default only be visible on CRT%d\n",
		           pSiS->XvOnCRT2 ? 2 : 1);
		    }
		 }
                 SISInitVideo(pScreen);
 	      } else {
#endif
	        if(pSiS->hasTwoOverlays)
                   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Using SiS300/315/330 series HW Xv\n" );
                else
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Using SiS300/315/330 series HW Xv by default on CRT%d\n",
		       (pSiS->XvOnCRT2 ? 2 : 1));
	        SISInitVideo(pScreen);
#ifdef SISDUALHEAD
              }
#endif
        } else if( pSiS->Chipset == PCI_CHIP_SIS6326 ||
	           pSiS->Chipset == PCI_CHIP_SIS530  ||
		   pSiS->Chipset == PCI_CHIP_SIS5597 ) {

		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		        "Using SiS5597/5598/6326/530/620 HW Xv\n" );
		SIS6326InitVideo(pScreen);

	} else { /* generic Xv */

            XF86VideoAdaptorPtr *ptr;
            int n;

            n = xf86XVListGenericAdaptors(pScrn, &ptr);
            if(n) {
                xf86XVScreenInit(pScreen, ptr, n);
                xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using generic Xv\n" );
            }

        }
    }
#endif

#ifdef XF86DRI
    if(pSiS->loadDRI) {
       if(pSiS->directRenderingEnabled) {
          /* Now that mi, drm and others have done their thing,
           * complete the DRI setup.
           */
          pSiS->directRenderingEnabled = SISDRIFinishScreenInit(pScreen);
       }
       if(pSiS->directRenderingEnabled) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Direct rendering enabled\n");
          /* TODO */
          /* SISSetLFBConfig(pSiS); */
       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Direct rendering disabled\n");
       }
    }
#endif

    /* Wrap some funcs and setup remaining SD flags */

    pSiS->SiS_SD_Flags &= ~(SiS_SD_PSEUDOXINERAMA);
#ifdef SISMERGED
    if(pSiS->MergedFB) {
       pSiS->PointerMoved = pScrn->PointerMoved;
       pScrn->PointerMoved = SISMergePointerMoved;
       pSiS->Rotate = FALSE;
       pSiS->ShadowFB = FALSE;
#ifdef SISXINERAMA
       if(pSiS->UseSiSXinerama) {
          SiSnoPanoramiXExtension = FALSE;
          SiSXineramaExtensionInit(pScrn);
	  if(!SiSnoPanoramiXExtension) {
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,0,0,0)
             xf86DisableRandR();
             xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	  	 "SiS Pseudo-Xinerama enabled, RandR disabled\n");
#endif
	     pSiS->SiS_SD_Flags |= SiS_SD_PSEUDOXINERAMA;
	  }
       }
#endif
    }
#endif

    pSiS->CloseScreen = pScreen->CloseScreen;
    pScreen->CloseScreen = SISCloseScreen;
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode)
       pScreen->SaveScreen = SISSaveScreenDH;
    else
#endif
       pScreen->SaveScreen = SISSaveScreen;

    /* Install BlockHandler */
    pSiS->BlockHandler = pScreen->BlockHandler;
    pScreen->BlockHandler = SISBlockHandler;

    /* Report any unused options (only for the first generation) */
    if(serverGeneration == 1) {
       xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
    }

    /* Clear frame buffer */
    /* For CRT2, we don't do that at this point in dual head
     * mode since the mode isn't switched at this time (it will
     * be reset when setting the CRT1 mode). Hence, we just
     * save the necessary data and clear the screen when
     * going through this for CRT1.
     */
     
    OnScreenSize = pScrn->displayWidth * pScrn->currentMode->VDisplay
                               * (pScrn->bitsPerPixel >> 3);

    /* Turn on the screen now */
    /* We do this in dual head mode after second head is finished */
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       if(pSiS->SecondHead) {
          bzero(pSiS->FbBase, OnScreenSize);
	  bzero(pSiSEnt->FbBase1, pSiSEnt->OnScreenSize1);
    	  SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       } else {
          pSiSEnt->FbBase1 = pSiS->FbBase;
	  pSiSEnt->OnScreenSize1 = OnScreenSize;
       }
    } else {
#endif
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       bzero(pSiS->FbBase, OnScreenSize);
#ifdef SISDUALHEAD
    }
#endif

    pSiS->SiS_SD_Flags &= ~SiS_SD_ISDEPTH8;
    if(pSiS->CurrentLayout.bitsPerPixel == 8) {
    	pSiS->SiS_SD_Flags |= SiS_SD_ISDEPTH8;
	pSiS->SiS_SD_Flags &= ~SiS_SD_SUPPORTXVGAMMA1;
    }

    return TRUE;
}

/* Usually mandatory */
Bool
SISSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    SISPtr pSiS = SISPTR(pScrn);

    if(!pSiS->NoAccel) {
       if(pSiS->AccelInfoPtr) {
          (*pSiS->AccelInfoPtr->Sync)(pScrn);
       }
    }

    if(!(SISModeInit(xf86Screens[scrnIndex], mode))) return FALSE;

    /* Since RandR (indirectly) uses SwitchMode(), we need to
     * update our Xinerama info here, too, in case of resizing
     */
#ifdef SISMERGED
#ifdef SISXINERAMA
    if(pSiS->MergedFB) {
       SiSUpdateXineramaScreenInfo(pScrn);
    }
#endif
#endif
    return TRUE;
}

Bool
SISSwitchCRT2Type(ScrnInfoPtr pScrn, unsigned long newvbflags)
{
    SISPtr pSiS = SISPTR(pScrn);
    BOOLEAN hcm;
    DisplayModePtr mode = pScrn->currentMode;

    /* Do NOT use this to switch from CRT2_LCD to CRT1_LCDA */

    /* Only on 300 and 315/330 series */
    if(pSiS->VGAEngine != SIS_300_VGA &&
       pSiS->VGAEngine != SIS_315_VGA) return FALSE;

    /* Only if there is a video bridge */
    if(!(pSiS->VBFlags & VB_VIDEOBRIDGE)) return FALSE;

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) return FALSE;
#endif

#define SiS_NewVBMask (CRT2_ENABLE|CRT1_LCDA|TV_PAL|TV_NTSC|TV_PALM|TV_PALN|TV_NTSCJ| \
		       TV_AVIDEO|TV_SVIDEO|TV_SCART|TV_HIVISION|TV_YPBPR|TV_YPBPRALL|\
		       TV_YPBPRAR)

    newvbflags &= SiS_NewVBMask;
    newvbflags |= pSiS->VBFlags & ~SiS_NewVBMask;

    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTLCDA)) {
       newvbflags &= ~CRT1_LCDA;
    }
    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTHIVISION)) {
       newvbflags &= ~TV_HIVISION;
    }
    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPR)) {
       newvbflags &= ~TV_YPBPR;
    }

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       if(!(newvbflags & CRT2_ENABLE)) {
	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	   	"CRT2 can't be switched off in MergedFB mode\n");
	  return FALSE;
       }
       hcm = pSiS->HaveCustomModes2;
       if(mode->Private) {
	  mode = ((SiSMergedDisplayModePtr)mode->Private)->CRT2;
       }
    } else
#endif
       hcm = pSiS->HaveCustomModes;

    if((!(newvbflags & CRT2_ENABLE)) && (!newvbflags & DISPTYPE_CRT1)) {
       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
          "CRT2 can't be switched off while CRT1 is off\n");
       return FALSE;
    }

    /* CRT2_LCD overrules LCDA */
    if(newvbflags & CRT2_LCD) {
       newvbflags &= ~CRT1_LCDA;
    }

    /* Check if the current mode is suitable for desired output device (if any) */
    if(newvbflags & CRT2_ENABLE) {
       if(!SiS_CheckCalcModeIndex(pScrn, mode, newvbflags, hcm)) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	     "Current mode not suitable for desired CRT2 output device\n");
          return FALSE;
       }
    }

    /* Remember: Dualhead not supported */
    newvbflags &= ~(SINGLE_MODE | MIRROR_MODE);
    if((newvbflags & DISPTYPE_CRT1) && (newvbflags & CRT2_ENABLE)) {
       newvbflags |= MIRROR_MODE;
    } else {
       newvbflags |= SINGLE_MODE;
    }

    /* Sync the accelerators */
    if(!pSiS->NoAccel) {
       if(pSiS->AccelInfoPtr) {
          (*pSiS->AccelInfoPtr->Sync)(pScrn);
       }
    }

    pSiS->VBFlags = pSiS->VBFlags_backup = newvbflags;

    if(!(pScrn->SwitchMode(pScrn->scrnIndex, pScrn->currentMode, 0))) return FALSE;
    SISAdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
    return TRUE;
}

int
SISCheckModeIndexForCRT2Type(ScrnInfoPtr pScrn, unsigned short cond, unsigned short index, Bool quiet)
{
    SISPtr pSiS = SISPTR(pScrn);
    BOOLEAN hcm = pSiS->HaveCustomModes;
    DisplayModePtr mode = pScrn->modes, mastermode;
    int i, result = 0;
    unsigned long vbflags = pSiS->VBFlags;

    /* Not only CRT2, but also LCDA */

    /* returns 0 if mode ok,
     *         0x01 if mode not ok for CRT2 device,
     *         0x02 if mode too large for current root window
     *         or combinations thereof
     */

    /* No special treatment for NTSC-J here; conditions equal NTSC */
    if(cond) {
       vbflags &= ~(CRT2_ENABLE | CRT1_LCDA | TV_STANDARD | TV_INTERFACE);
       if((cond & SiS_CF2_TYPEMASK) == SiS_CF2_LCD) {
       	  vbflags |= CRT2_LCD;
       } else if((cond & SiS_CF2_TYPEMASK) == SiS_CF2_TV) {
          vbflags |= (CRT2_TV | TV_SVIDEO);
	  if(cond & SiS_CF2_TVPAL)  	  vbflags |= TV_PAL;
	  else if(cond & SiS_CF2_TVPALM)  vbflags |= (TV_PAL | TV_PALM);
	  else if(cond & SiS_CF2_TVPALN)  vbflags |= (TV_PAL | TV_PALN);
	  else if(cond & SiS_CF2_TVNTSC)  vbflags |= TV_NTSC;
       } else if((cond & SiS_CF2_TYPEMASK) == SiS_CF2_TVSPECIAL) {
          vbflags |= CRT2_TV;
	  if((cond & SiS_CF2_TVSPECMASK) == SiS_CF2_TVHIVISION)
	  	vbflags |= TV_HIVISION;
	  else if((cond & SiS_CF2_TVSPECMASK) == SiS_CF2_TVYPBPR525I)
	  	vbflags |= (TV_YPBPR | TV_YPBPR525I);
	  else if((cond & SiS_CF2_TVSPECMASK) == SiS_CF2_TVYPBPR525P)
	  	vbflags |= (TV_YPBPR | TV_YPBPR525P);
	  else if((cond & SiS_CF2_TVSPECMASK) == SiS_CF2_TVYPBPR750P)
	  	vbflags |= (TV_YPBPR | TV_YPBPR750P);
	  else if((cond & SiS_CF2_TVSPECMASK) == SiS_CF2_TVYPBPR1080I)
	  	vbflags |= (TV_YPBPR | TV_YPBPR1080I);
       } else if((cond & SiS_CF2_TYPEMASK) == SiS_CF2_VGA2) {
          vbflags |= CRT2_VGA;
       } else if((cond & SiS_CF2_TYPEMASK) == SiS_CF2_CRT1LCDA) {
          vbflags |= CRT1_LCDA;
       }
    }

    /* Find mode of given index */
    if(index) {
       for(i = 0; i < index; i++) {
          if(!mode) return 0x03;
          mode = mode->next;
       }
    }

    mastermode = mode;

#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead)) {
#endif

       if(vbflags & CRT2_ENABLE) {

#ifdef SISMERGED
          if(pSiS->MergedFB) {
             hcm = pSiS->HaveCustomModes2;
             if(mode->Private) {
	        mode = ((SiSMergedDisplayModePtr)mode->Private)->CRT2;
             }
          }
#endif

          /* For RandR */
          if((mode->HDisplay > pScrn->virtualX) || (mode->VDisplay > pScrn->virtualY)) {
             if(!quiet) {
                xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Desired mode too large for current screen size\n");
             }
             result |= 0x02;
          }

          /* Check if the desired mode is suitable for current CRT2 output device */
          if(!SiS_CheckCalcModeIndex(pScrn, mode, vbflags, hcm)) {
             if((!cond) && (!quiet)) {
                xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Desired mode not suitable for current CRT2 output device\n");
             }
             result |= 0x01;
          }

       }

#ifdef SISDUALHEAD
    }
#endif

    mode = mastermode;

#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (pSiS->SecondHead)) {
#endif

       if(vbflags & CRT1_LCDA) {

#ifdef SISMERGED
          if(pSiS->MergedFB) {
             hcm = pSiS->HaveCustomModes;
             if(mode->Private) {
	        mode = ((SiSMergedDisplayModePtr)mode->Private)->CRT1;
	     }
          }
#endif

 	  /* For RandR */
          if((mode->HDisplay > pScrn->virtualX) || (mode->VDisplay > pScrn->virtualY)) {
             if(!quiet) {
                xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			"Desired mode too large for current screen size\n");
             }
             result |= 0x02;
          }

          /* Check if the desired mode is suitable for current CRT1 output device */
          if(!SiS_CalcModeIndex(pScrn, mode, vbflags, hcm)) {
             if((!cond) && (!quiet)) {
                 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	  	      "Desired mode not suitable for current CRT1 output device\n");
             }
             result |= 0x01;
          }

       }

#ifdef SISDUALHEAD
    }
#endif

    return result;
}

Bool
SISSwitchCRT1Status(ScrnInfoPtr pScrn, int onoff)
{
    SISPtr pSiS = SISPTR(pScrn);
    DisplayModePtr mode = pScrn->currentMode;
    unsigned long vbflags = pSiS->VBFlags;
    int crt1off;

    /* onoff: 0=OFF, 1=ON(VGA), 2=ON(LCDA) */
    /* Switching to LCDA will disable CRT2 if previously LCD */

    /* Do NOT use this to switch from CRT1_LCDA to CRT2_LCD */

    /* Only on 300 and 315/330 series */
    if(pSiS->VGAEngine != SIS_300_VGA &&
       pSiS->VGAEngine != SIS_315_VGA) return FALSE;

    /* Off only if at least one CRT2 device is active */
    if((!onoff) && (!(vbflags & CRT2_ENABLE))) return FALSE;

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) return FALSE;
#endif

    /* Can't switch to LCDA of not supported (duh!) */
    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTLCDA)) {
       if(onoff == 2) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	   	"LCD-via-CRT1 not supported on this hardware\n");
          return FALSE;
       }
    }

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       if(!onoff) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	   	"CRT1 can't be switched off in MergedFB mode\n");
          return FALSE;
       } else if(onoff == 2) {
          if(vbflags & CRT2_LCD) {
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	   	"CRT2 type can't be LCD while CRT1 is LCD-via-CRT1\n");
             return FALSE;
	  }
       }
       if(mode->Private) {
	  mode = ((SiSMergedDisplayModePtr)mode->Private)->CRT1;
       }
    }
#endif

    vbflags &= ~(DISPTYPE_CRT1 | SINGLE_MODE | MIRROR_MODE | CRT1_LCDA);
    crt1off = 1;
    if(onoff > 0) {
       vbflags |= DISPTYPE_CRT1;
       crt1off = 0;
       if(onoff == 2) {
       	  vbflags |= CRT1_LCDA;
	  vbflags &= ~CRT2_LCD;
       }
       /* Remember: Dualhead not supported */
       if(vbflags & CRT2_ENABLE) vbflags |= MIRROR_MODE;
       else vbflags |= SINGLE_MODE;
    } else {
       vbflags |= SINGLE_MODE;
    }

    if(vbflags & CRT1_LCDA) {
       if(!SiS_CalcModeIndex(pScrn, mode, vbflags, pSiS->HaveCustomModes)) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"Current mode not suitable for LCD-via-CRT1\n");
          return FALSE;
       }
    }

    pSiS->CRT1off = crt1off;
    pSiS->VBFlags = pSiS->VBFlags_backup = vbflags;

    /* Sync the accelerators */
    if(!pSiS->NoAccel) {
       if(pSiS->AccelInfoPtr) {
          (*pSiS->AccelInfoPtr->Sync)(pScrn);
       }
    }

    if(!(pScrn->SwitchMode(pScrn->scrnIndex, pScrn->currentMode, 0))) return FALSE;
    SISAdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
    return TRUE;
}

static void
SISSetStartAddressCRT1(SISPtr pSiS, unsigned long base)
{
    unsigned char cr11backup;

    inSISIDXREG(SISCR,  0x11, cr11backup);  /* Unlock CRTC registers */
    andSISIDXREG(SISCR, 0x11, 0x7F);
    outSISIDXREG(SISCR, 0x0D, base & 0xFF);
    outSISIDXREG(SISCR, 0x0C, (base >> 8) & 0xFF);
    outSISIDXREG(SISSR, 0x0D, (base >> 16) & 0xFF);
    if(pSiS->VGAEngine == SIS_315_VGA) {
       setSISIDXREG(SISSR, 0x37, 0xFE, (base >> 24) & 0x01);
    }
    /* Eventually lock CRTC registers */
    setSISIDXREG(SISCR, 0x11, 0x7F,(cr11backup & 0x80));
}

static void
SISSetStartAddressCRT2(SISPtr pSiS, unsigned long base)
{
    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
    outSISIDXREG(SISPART1, 0x06, GETVAR8(base));
    outSISIDXREG(SISPART1, 0x05, GETBITS(base, 15:8));
    outSISIDXREG(SISPART1, 0x04, GETBITS(base, 23:16));
    if(pSiS->VGAEngine == SIS_315_VGA) {
       setSISIDXREG(SISPART1, 0x02, 0x7F, ((base >> 24) & 0x01) << 7);
    }
    SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
}

#ifdef SISMERGED
static Bool
InRegion(int x, int y, region r)
{
    return (r.x0 <= x) && (x <= r.x1) && (r.y0 <= y) && (y <= r.y1);
}

static void
SISAdjustFrameHW_CRT1(ScrnInfoPtr pScrn, int x, int y)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned long base;

    base = y * pSiS->CurrentLayout.displayWidth + x;
    switch(pSiS->CurrentLayout.bitsPerPixel) {
       case 16:  base >>= 1; 	break;
       case 32:  		break;
       default:  base >>= 2;
    }
    SISSetStartAddressCRT1(pSiS, base);
}

static void
SISAdjustFrameHW_CRT2(ScrnInfoPtr pScrn, int x, int y)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned long base;

    base = y * pSiS->CurrentLayout.displayWidth + x;
    switch(pSiS->CurrentLayout.bitsPerPixel) {
       case 16:  base >>= 1; 	break;
       case 32:  		break;
       default:  base >>= 2;
    }
    SISSetStartAddressCRT2(pSiS, base);
}

static void
SISMergePointerMoved(int scrnIndex, int x, int y)
{
  ScrnInfoPtr   pScrn1 = xf86Screens[scrnIndex];
  SISPtr        pSiS = SISPTR(pScrn1);
  ScrnInfoPtr   pScrn2 = pSiS->CRT2pScrn;
  region 	out, in1, in2, f2, f1;
  int 		deltax, deltay;

  f1.x0 = pSiS->CRT1frameX0;
  f1.x1 = pSiS->CRT1frameX1;
  f1.y0 = pSiS->CRT1frameY0;
  f1.y1 = pSiS->CRT1frameY1;
  f2.x0 = pScrn2->frameX0;
  f2.x1 = pScrn2->frameX1;
  f2.y0 = pScrn2->frameY0;
  f2.y1 = pScrn2->frameY1;

  /* Define the outer region. Crossing this causes all frames to move */
  out.x0 = pScrn1->frameX0;
  out.x1 = pScrn1->frameX1;
  out.y0 = pScrn1->frameY0;
  out.y1 = pScrn1->frameY1;

  /*
   * Define the inner sliding window. Being outsize both frames but
   * inside the outer clipping window will slide corresponding frame
   */
  in1 = out;
  in2 = out;
  switch(((SiSMergedDisplayModePtr)pSiS->CurrentLayout.mode->Private)->CRT2Position) {
     case sisLeftOf:
        in1.x0 = f1.x0;
        in2.x1 = f2.x1;
        break;
     case sisRightOf:
        in1.x1 = f1.x1;
        in2.x0 = f2.x0;
        break;
     case sisBelow:
        in1.y1 = f1.y1;
        in2.y0 = f2.y0;
        break;
     case sisAbove:
        in1.y0 = f1.y0;
        in2.y1 = f2.y1;
        break;
     case sisClone:
        break;
  }

  deltay = 0;
  deltax = 0;

  if(InRegion(x, y, out)) {	/* inside outer region */

     if(InRegion(x, y, in1) && !InRegion(x, y, f1)) {
        REBOUND(f1.x0, f1.x1, x);
        REBOUND(f1.y0, f1.y1, y);
        deltax = 1;
     }
     if(InRegion(x, y, in2) && !InRegion(x, y, f2)) {
        REBOUND(f2.x0, f2.x1, x);
        REBOUND(f2.y0, f2.y1, y);
        deltax = 1;
     }

  } else {			/* outside outer region */

     if(out.x0 > x) {
        deltax = x - out.x0;
     }
     if(out.x1 < x) {
        deltax = x - out.x1;
     }
     if(deltax) {
        pScrn1->frameX0 += deltax;
        pScrn1->frameX1 += deltax;
	f1.x0 += deltax;
        f1.x1 += deltax;
        f2.x0 += deltax;
        f2.x1 += deltax;
     }

     if(out.y0 > y) {
        deltay = y - out.y0;
     }
     if(out.y1 < y) {
        deltay = y - out.y1;
     }
     if(deltay) {
        pScrn1->frameY0 += deltay;
        pScrn1->frameY1 += deltay;
	f1.y0 += deltay;
        f1.y1 += deltay;
        f2.y0 += deltay;
        f2.y1 += deltay;
     }

     switch(((SiSMergedDisplayModePtr)pSiS->CurrentLayout.mode->Private)->CRT2Position) {
        case sisLeftOf:
	   if(x >= f1.x0) { REBOUND(f1.y0, f1.y1, y); }
	   if(x <= f2.x1) { REBOUND(f2.y0, f2.y1, y); }
           break;
        case sisRightOf:
	   if(x <= f1.x1) { REBOUND(f1.y0, f1.y1, y); }
	   if(x >= f2.x0) { REBOUND(f2.y0, f2.y1, y); }
           break;
        case sisBelow:
	   if(y <= f1.y1) { REBOUND(f1.x0, f1.x1, x); }
	   if(y >= f2.y0) { REBOUND(f2.x0, f2.x1, x); }
           break;
        case sisAbove:
	   if(y >= f1.y0) { REBOUND(f1.x0, f1.x1, x); }
	   if(y <= f2.y1) { REBOUND(f2.x0, f2.x1, x); }
           break;
        case sisClone:
           break;
     }

  }

  if(deltax || deltay) {
     pSiS->CRT1frameX0 = f1.x0;
     pSiS->CRT1frameY0 = f1.y0;
     pScrn2->frameX0 = f2.x0;
     pScrn2->frameY0 = f2.y0;

     pSiS->CRT1frameX1 = pSiS->CRT1frameX0 + CDMPTR->CRT1->HDisplay - 1;
     pSiS->CRT1frameY1 = pSiS->CRT1frameY0 + CDMPTR->CRT1->VDisplay - 1;
     pScrn2->frameX1   = pScrn2->frameX0   + CDMPTR->CRT2->HDisplay - 1;
     pScrn2->frameY1   = pScrn2->frameY0   + CDMPTR->CRT2->VDisplay - 1;
     pScrn1->frameX1   = pScrn1->frameX0   + pSiS->CurrentLayout.mode->HDisplay  - 1;
     pScrn1->frameY1   = pScrn1->frameY0   + pSiS->CurrentLayout.mode->VDisplay  - 1;

     SISAdjustFrameHW_CRT1(pScrn1, pSiS->CRT1frameX0, pSiS->CRT1frameY0);
     SISAdjustFrameHW_CRT2(pScrn1, pScrn2->frameX0, pScrn2->frameY0);
  }
}

static void
SISAdjustFrameMerged(int scrnIndex, int x, int y, int flags)
{
    ScrnInfoPtr pScrn1 = xf86Screens[scrnIndex];
    SISPtr pSiS = SISPTR(pScrn1);
    ScrnInfoPtr pScrn2 = pSiS->CRT2pScrn;
    int VTotal = pSiS->CurrentLayout.mode->VDisplay;
    int HTotal = pSiS->CurrentLayout.mode->HDisplay;
    int VMax = VTotal;
    int HMax = HTotal;

    BOUND(x, 0, pScrn1->virtualX - HTotal);
    BOUND(y, 0, pScrn1->virtualY - VTotal);

    switch(SDMPTR(pScrn1)->CRT2Position) {
        case sisLeftOf:
            pScrn2->frameX0 = x;
            BOUND(pScrn2->frameY0,   y, y + VMax - CDMPTR->CRT2->VDisplay);
            pSiS->CRT1frameX0 = x + CDMPTR->CRT2->HDisplay;
            BOUND(pSiS->CRT1frameY0, y, y + VMax - CDMPTR->CRT1->VDisplay);
            break;
        case sisRightOf:
            pSiS->CRT1frameX0 = x;
            BOUND(pSiS->CRT1frameY0, y, y + VMax - CDMPTR->CRT1->VDisplay);
            pScrn2->frameX0 = x + CDMPTR->CRT1->HDisplay;
            BOUND(pScrn2->frameY0,   y, y + VMax - CDMPTR->CRT2->VDisplay);
            break;
        case sisAbove:
            BOUND(pScrn2->frameX0,   x, x + HMax - CDMPTR->CRT2->HDisplay);
            pScrn2->frameY0 = y;
            BOUND(pSiS->CRT1frameX0, x, x + HMax - CDMPTR->CRT1->HDisplay);
            pSiS->CRT1frameY0 = y + CDMPTR->CRT2->VDisplay;
            break;
        case sisBelow:
            BOUND(pSiS->CRT1frameX0, x, x + HMax - CDMPTR->CRT1->HDisplay);
            pSiS->CRT1frameY0 = y;
            BOUND(pScrn2->frameX0,   x, x + HMax - CDMPTR->CRT2->HDisplay);
            pScrn2->frameY0 = y + CDMPTR->CRT1->VDisplay;
            break;
        case sisClone:
            BOUND(pSiS->CRT1frameX0, x, x + HMax - CDMPTR->CRT1->HDisplay);
            BOUND(pSiS->CRT1frameY0, y, y + VMax - CDMPTR->CRT1->VDisplay);
            BOUND(pScrn2->frameX0,   x, x + HMax - CDMPTR->CRT2->HDisplay);
            BOUND(pScrn2->frameY0,   y, y + VMax - CDMPTR->CRT2->VDisplay);
            break;
    }

    BOUND(pSiS->CRT1frameX0, 0, pScrn1->virtualX - CDMPTR->CRT1->HDisplay);
    BOUND(pSiS->CRT1frameY0, 0, pScrn1->virtualY - CDMPTR->CRT1->VDisplay);
    BOUND(pScrn2->frameX0,   0, pScrn1->virtualX - CDMPTR->CRT2->HDisplay);
    BOUND(pScrn2->frameY0,   0, pScrn1->virtualY - CDMPTR->CRT2->VDisplay);
    
    pScrn1->frameX0 = x;
    pScrn1->frameY0 = y;

    pSiS->CRT1frameX1 = pSiS->CRT1frameX0 + CDMPTR->CRT1->HDisplay - 1;
    pSiS->CRT1frameY1 = pSiS->CRT1frameY0 + CDMPTR->CRT1->VDisplay - 1;
    pScrn2->frameX1   = pScrn2->frameX0   + CDMPTR->CRT2->HDisplay - 1;
    pScrn2->frameY1   = pScrn2->frameY0   + CDMPTR->CRT2->VDisplay - 1;
    pScrn1->frameX1   = pScrn1->frameX0   + pSiS->CurrentLayout.mode->HDisplay  - 1;
    pScrn1->frameY1   = pScrn1->frameY0   + pSiS->CurrentLayout.mode->VDisplay  - 1;

    SISAdjustFrameHW_CRT1(pScrn1, pSiS->CRT1frameX0, pSiS->CRT1frameY0);
    SISAdjustFrameHW_CRT2(pScrn1, pScrn2->frameX0, pScrn2->frameY0);
}
#endif

/*
 * This function is used to initialize the Start Address - the first
 * displayed location in the video memory.
 *
 * Usually mandatory
 */
void
SISAdjustFrame(int scrnIndex, int x, int y, int flags)
{
    ScrnInfoPtr   pScrn = xf86Screens[scrnIndex];
    SISPtr        pSiS = SISPTR(pScrn);
    unsigned long base;
    unsigned char temp, cr11backup;

#ifdef SISMERGED
    if(pSiS->MergedFB) {
    	SISAdjustFrameMerged(scrnIndex, x, y, flags);
	return;
    }
#endif

    if(pSiS->UseVESA) {
	VBESetDisplayStart(pSiS->pVbe, x, y, TRUE);
	return;
    }

    if(pScrn->bitsPerPixel < 8) {
       base = (y * pSiS->CurrentLayout.displayWidth + x + 3) >> 3;
    } else {
       base  = y * pSiS->CurrentLayout.displayWidth + x;

       /* calculate base bpp dep. */
       switch(pSiS->CurrentLayout.bitsPerPixel) {
          case 16:
     	     base >>= 1;
             break;
          case 24:
             base = ((base * 3)) >> 2;
             base -= base % 6;
             break;
          case 32:
             break;
          default:      /* 8bpp */
             base >>= 2;
             break;
       }
    }

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       if(!pSiS->SecondHead) {
	  /* Head 1 (master) is always CRT2 */
          SISSetStartAddressCRT2(pSiS, base);
       } else {
          /* TW: Head 2 (slave) is always CRT1 */
	  base += (pSiS->dhmOffset/4);
	  SISSetStartAddressCRT1(pSiS, base);
       }
    } else {
#endif
       switch(pSiS->VGAEngine) {
          case SIS_300_VGA:
	  case SIS_315_VGA:
	     SISSetStartAddressCRT1(pSiS, base);
             if(pSiS->VBFlags & CRT2_ENABLE) {
		SISSetStartAddressCRT2(pSiS, base);
	     }
             break;
          default:
	     /* Unlock CRTC registers */
             inSISIDXREG(SISCR,  0x11, cr11backup);
             andSISIDXREG(SISCR, 0x11, 0x7F);
	     outSISIDXREG(SISCR, 0x0D, base & 0xFF);
	     outSISIDXREG(SISCR, 0x0C, (base >> 8) & 0xFF);
	     inSISIDXREG(SISSR,  0x27, temp);
	     temp &= 0xF0;
	     temp |= (base & 0x0F0000) >> 16;
	     outSISIDXREG(SISSR, 0x27, temp);
	     /* Eventually lock CRTC registers */
	     setSISIDXREG(SISCR, 0x11, 0x7F, (cr11backup & 0x80));
       }
#ifdef SISDUALHEAD
    }
#endif

}

/*
 * This is called when VT switching back to the X server.  Its job is
 * to reinitialise the video mode.
 * Mandatory!
 */
static Bool
SISEnterVT(int scrnIndex, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    SISPtr pSiS = SISPTR(pScrn);

    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       outSISIDXREG(SISCR,0x32,pSiS->myCR32);
       outSISIDXREG(SISCR,0x36,pSiS->myCR36);
       outSISIDXREG(SISCR,0x37,pSiS->myCR37);
    }

    if(!SISModeInit(pScrn, pScrn->currentMode)) {
       SISErrorLog(pScrn, "SiSEnterVT: SISModeInit() failed\n");
       return FALSE;
    }

    SISAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);

#ifdef XF86DRI
    if(pSiS->directRenderingEnabled) {
       DRIUnlock(screenInfo.screens[scrnIndex]);
    }
#endif

#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead))
#endif
       if(pSiS->ResetXv) {
          (pSiS->ResetXv)(pScrn);
       }

    return TRUE;
}

/*
 * This is called when VT switching away from the X server.  Its job is
 * to restore the previous (text) mode.
 * Mandatory!
 */
static void
SISLeaveVT(int scrnIndex, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    vgaHWPtr hwp = VGAHWPTR(pScrn);
    SISPtr pSiS = SISPTR(pScrn);
#ifdef XF86DRI
    ScreenPtr pScreen;

    if(pSiS->directRenderingEnabled) {
       pScreen = screenInfo.screens[scrnIndex];
       DRILock(pScreen, 0);
    }
#endif

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode && pSiS->SecondHead) return;
#endif
    
    if(pSiS->CursorInfoPtr) {
#ifdef SISDUALHEAD    
       if(pSiS->DualHeadMode) {
          if(!pSiS->SecondHead) {
	     pSiS->ForceCursorOff = TRUE;
	     pSiS->CursorInfoPtr->HideCursor(pScrn);
	     SISWaitVBRetrace(pScrn);
	     pSiS->ForceCursorOff = FALSE;
	  }
       } else {
#endif
          pSiS->CursorInfoPtr->HideCursor(pScrn);
          SISWaitVBRetrace(pScrn);
#ifdef SISDUALHEAD	  
       }	
#endif       
    }

    SISBridgeRestore(pScrn);

    if(pSiS->UseVESA) {

       /* This is a q&d work-around for a BIOS bug. In case we disabled CRT2,
    	* VBESaveRestore() does not restore CRT1. So we set any mode now,
	* because VBESetVBEMode correctly restores CRT1. Afterwards, we
	* can call VBESaveRestore to restore original mode.
	*/
       if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (!(pSiS->VBFlags & DISPTYPE_DISP2)))
	  VBESetVBEMode(pSiS->pVbe, (pSiS->SISVESAModeList->n) | 0xc000, NULL);

       SISVESARestore(pScrn);

    } else {

       SISRestore(pScrn);

    }

    /* We use (otherwise unused) bit 7 to indicate that we are running
     * to keep sisfb to change the displaymode (this would result in
     * lethal display corruption upon quitting X or changing to a VT
     * until a reboot)
     */
    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
       orSISIDXREG(SISCR,0x34,0x80);
    }

    vgaHWLock(hwp);
}


/*
 * This is called at the end of each server generation.  It restores the
 * original (text) mode.  It should really also unmap the video memory too.
 * Mandatory!
 */
static Bool
SISCloseScreen(int scrnIndex, ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    vgaHWPtr hwp = VGAHWPTR(pScrn);
    SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

#ifdef XF86DRI
    if(pSiS->directRenderingEnabled) {
       SISDRICloseScreen(pScreen);
       pSiS->directRenderingEnabled = FALSE;
    }
#endif

    if(pScrn->vtSema) {

        if(pSiS->CursorInfoPtr) {
#ifdef SISDUALHEAD
           if(pSiS->DualHeadMode) {
              if(!pSiS->SecondHead) {
	         pSiS->ForceCursorOff = TRUE;
	         pSiS->CursorInfoPtr->HideCursor(pScrn);
	         SISWaitVBRetrace(pScrn);
	         pSiS->ForceCursorOff = FALSE;
	      }
           } else {
#endif
             pSiS->CursorInfoPtr->HideCursor(pScrn);
             SISWaitVBRetrace(pScrn);
#ifdef SISDUALHEAD
           }
#endif
	}

        SISBridgeRestore(pScrn);

	if(pSiS->UseVESA) {

	  /* This is a q&d work-around for a BIOS bug. In case we disabled CRT2,
    	   * VBESaveRestore() does not restore CRT1. So we set any mode now,
	   * because VBESetVBEMode correctly restores CRT1. Afterwards, we
	   * can call VBESaveRestore to restore original mode.
	   */
           if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (!(pSiS->VBFlags & DISPTYPE_DISP2)))
	      VBESetVBEMode(pSiS->pVbe, (pSiS->SISVESAModeList->n) | 0xc000, NULL);

	   SISVESARestore(pScrn);

	} else {

	   SISRestore(pScrn);

	}

        vgaHWLock(hwp);

    }

    /* We should restore the mode number in case vtsema = false as well,
     * but since we haven't register access then we can't do it. I think
     * I need to rework the save/restore stuff, like saving the video
     * status when returning to the X server and by that save me the
     * trouble if sisfb was started from a textmode VT while X was on.
     */
    
    SISUnmapMem(pScrn);
    vgaHWUnmapMem(pScrn);

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       pSiSEnt = pSiS->entityPrivate;
       pSiSEnt->refCount--;
    }
#endif

    if(pSiS->pInt) {
       xf86FreeInt10(pSiS->pInt);
       pSiS->pInt = NULL;
    }

    if(pSiS->AccelLinearScratch) {
       xf86FreeOffscreenLinear(pSiS->AccelLinearScratch);
       pSiS->AccelLinearScratch = NULL;
    }

    if(pSiS->AccelInfoPtr) {
       XAADestroyInfoRec(pSiS->AccelInfoPtr);
       pSiS->AccelInfoPtr = NULL;
    }

    if(pSiS->CursorInfoPtr) {
       xf86DestroyCursorInfoRec(pSiS->CursorInfoPtr);
       pSiS->CursorInfoPtr = NULL;
    }

    if(pSiS->ShadowPtr) {
       xfree(pSiS->ShadowPtr);
       pSiS->ShadowPtr = NULL;
    }

    if(pSiS->DGAModes) {
       xfree(pSiS->DGAModes);
       pSiS->DGAModes = NULL;
    }

    if(pSiS->adaptor) {
       xfree(pSiS->adaptor);
       pSiS->adaptor = NULL;
    }

    pScrn->vtSema = FALSE;

    /* Restore Blockhandler */
    pScreen->BlockHandler = pSiS->BlockHandler;

    pScreen->CloseScreen = pSiS->CloseScreen;

    return(*pScreen->CloseScreen)(scrnIndex, pScreen);
}


/* Free up any per-generation data structures */

/* Optional */
static void
SISFreeScreen(int scrnIndex, int flags)
{
    if(xf86LoaderCheckSymbol("vgaHWFreeHWRec")) {
       vgaHWFreeHWRec(xf86Screens[scrnIndex]);
    }

    SISFreeRec(xf86Screens[scrnIndex]);
}


/* Checks if a mode is suitable for the selected chipset. */

static ModeStatus
SISValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    SISPtr pSiS = SISPTR(pScrn);

    if(pSiS->UseVESA) {
       if(SiSCalcVESAModeIndex(pScrn, mode))
	  return(MODE_OK);
       else
	  return(MODE_BAD);
    }

    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
#ifdef SISDUALHEAD
       if(pSiS->DualHeadMode) {
          if(pSiS->SecondHead) {
	     if(SiS_CalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	        return(MODE_BAD);
	  } else {
	     if(SiS_CheckCalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	        return(MODE_BAD);
	  }
       } else
#endif
#ifdef SISMERGED
       if(pSiS->MergedFB) {
	  if(!mode->Private) {
	     if(!pSiS->CheckForCRT2) {
	        if(SiS_CalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	           return(MODE_BAD);
	     } else {
	        if(SiS_CheckCalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes2) < 0x14)
	           return(MODE_BAD);
	     }
	  } else {
	     if(SiS_CalcModeIndex(pScrn, ((SiSMergedDisplayModePtr)mode->Private)->CRT1,
		                  pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	        return(MODE_BAD);

	     if(SiS_CheckCalcModeIndex(pScrn, ((SiSMergedDisplayModePtr)mode->Private)->CRT2,
		                  pSiS->VBFlags, pSiS->HaveCustomModes2) < 0x14)
	        return(MODE_BAD);
 	  }
       } else
#endif
              {

	  if(pSiS->VBFlags & CRT1_LCDA) {
	     if(SiS_CalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	        return(MODE_BAD);
	  }
	  if(SiS_CheckCalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	     return(MODE_BAD);
       }
    }

    return(MODE_OK);
}

/* Do screen blanking
 *
 * Mandatory
 */
static Bool
SISSaveScreen(ScreenPtr pScreen, int mode)
{
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];

    if((pScrn != NULL) && pScrn->vtSema) {

    	SISPtr pSiS = SISPTR(pScrn);

#ifdef UNLOCK_ALWAYS
        sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

        if(pSiS->VBFlags & (CRT2_LCD | CRT1_LCDA)) {

	   if(pSiS->VGAEngine == SIS_300_VGA) {

	      if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	         if(!xf86IsUnblank(mode)) {
	            pSiS->Blank = TRUE;
	  	    SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
	         } else {
	            pSiS->Blank = FALSE;
	            SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	         }
	      } else if(pSiS->VBFlags & (VB_LVDS | VB_30xBDH)) {
	         if(!pSiS->Blank) {
	            inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
	         }
	         if(!xf86IsUnblank(mode)) {
    		    pSiS->Blank = TRUE;
		    outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
	         } else {
    		    pSiS->Blank = FALSE;
		    outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
	         }
	      }

	   } else if(pSiS->VGAEngine == SIS_315_VGA) {

	      if(!pSiS->Blank) {
		 inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		 if(pSiS->sishw_ext.jChipType >= SIS_661) pSiS->LCDon &= 0x0f;
	      }

	      if(pSiS->VBFlags & VB_CHRONTEL) {
	         if(!xf86IsUnblank(mode)) {
		    pSiS->Blank = TRUE;
		    SiS_Chrontel701xBLOff(pSiS->SiS_Pr);
	         } else {
	            pSiS->Blank = FALSE;
	            SiS_Chrontel701xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	         }
	      } else if(pSiS->VBFlags & VB_LVDS) {
	         if(!xf86IsUnblank(mode)) {
	            pSiS->Blank = TRUE;
	 	    outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
	         } else {
	            pSiS->Blank = FALSE;
	  	    outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
	         }
	      } else if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	         if(!xf86IsUnblank(mode)) {
	            pSiS->Blank = TRUE;
	  	    SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
	         } else {
	            pSiS->Blank = FALSE;
	            SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	         }
	      }

	   }

	}

    }

    return vgaHWSaveScreen(pScreen, mode);
}

#ifdef SISDUALHEAD
/* SaveScreen for dual head mode */
static Bool
SISSaveScreenDH(ScreenPtr pScreen, int mode)
{
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    Bool checkit = FALSE;

    if((pScrn != NULL) && pScrn->vtSema) {

       SISPtr pSiS = SISPTR(pScrn);

       if((pSiS->SecondHead) && ((!(pSiS->VBFlags & CRT1_LCDA)) || (pSiS->VBFlags & VB_301C))) {

	  /* Slave head is always CRT1 */
	  if(pSiS->VBFlags & CRT1_LCDA) pSiS->Blank = xf86IsUnblank(mode) ? FALSE : TRUE;

	  return vgaHWSaveScreen(pScreen, mode);

       } else {

	  /* Master head is always CRT2 */
	  /* But we land here if CRT1 is LCDA, too */

	  /* We can only blank LCD, not other CRT2 devices */
	  if(!(pSiS->VBFlags & (CRT2_LCD|CRT1_LCDA))) return TRUE;

	  /* enable access to extended sequencer registers */
#ifdef UNLOCK_ALWAYS
          sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

 	  if(pSiS->VGAEngine == SIS_300_VGA) {

	     if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	        checkit = TRUE;
	        if(!xf86IsUnblank(mode)) {
		   SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
		} else {
		   SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
		}
	     } else if(pSiS->VBFlags & (VB_LVDS|VB_30xBDH)) {
	        if(!pSiS->BlankCRT2) {
		   inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		}
		checkit = TRUE;
		if(!xf86IsUnblank(mode)) {
		   outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
		} else {
		   outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		}
	     }

          } else if(pSiS->VGAEngine == SIS_315_VGA) {

 	     if(!pSiS->BlankCRT2) {
	 	inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		if(pSiS->sishw_ext.jChipType >= SIS_661) pSiS->LCDon &= 0x0f;
	     }

	     if(pSiS->VBFlags & VB_CHRONTEL) {
	        checkit = TRUE;
		if(!xf86IsUnblank(mode)) {
		   SiS_Chrontel701xBLOff(pSiS->SiS_Pr);
		} else {
		   SiS_Chrontel701xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
		}
	     } else if(pSiS->VBFlags & VB_LVDS) {
	        checkit = TRUE;
		if(!xf86IsUnblank(mode)) {
		   outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
		} else {
		   outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		}
	     } else if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	        checkit = TRUE;
		if(!xf86IsUnblank(mode)) {
		   SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
		} else {
		   SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
		}
	     }

	  }

	  if(checkit) {
	     if(!pSiS->SecondHead) pSiS->BlankCRT2 = xf86IsUnblank(mode) ? FALSE : TRUE;
	     else if(pSiS->VBFlags & CRT1_LCDA) pSiS->Blank = xf86IsUnblank(mode) ? FALSE : TRUE;
	  }

       }
    }
    return TRUE;
}
#endif

#ifdef DEBUG
static void
SiSDumpModeInfo(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Clock : %x\n", mode->Clock);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Display : %x\n", mode->CrtcHDisplay);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Blank Start : %x\n", mode->CrtcHBlankStart);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Sync Start : %x\n", mode->CrtcHSyncStart);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Sync End : %x\n", mode->CrtcHSyncEnd);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Blank End : %x\n", mode->CrtcHBlankEnd);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Total : %x\n", mode->CrtcHTotal);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz Skew : %x\n", mode->CrtcHSkew);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Hz HAdjusted : %x\n", mode->CrtcHAdjusted);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Display : %x\n", mode->CrtcVDisplay);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Blank Start : %x\n", mode->CrtcVBlankStart);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Sync Start : %x\n", mode->CrtcVSyncStart);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Sync End : %x\n", mode->CrtcVSyncEnd);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Blank End : %x\n", mode->CrtcVBlankEnd);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt Total : %x\n", mode->CrtcVTotal);
    xf86DrvMsg(pScrn->scrnIndex,X_INFO, "Vt VAdjusted : %x\n", mode->CrtcVAdjusted);
}
#endif

static void
SISModifyModeInfo(DisplayModePtr mode)
{
    if(mode->CrtcHBlankStart == mode->CrtcHDisplay)
        mode->CrtcHBlankStart++;
    if(mode->CrtcHBlankEnd == mode->CrtcHTotal)
        mode->CrtcHBlankEnd--;
    if(mode->CrtcVBlankStart == mode->CrtcVDisplay)
        mode->CrtcVBlankStart++;
    if(mode->CrtcVBlankEnd == mode->CrtcVTotal)
        mode->CrtcVBlankEnd--;
}

/* Enable the Turboqueue/Commandqueue (For 300 and 315/330 series only) */
void
SiSEnableTurboQueue(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned short SR26, SR27;
    unsigned long  temp;

    switch (pSiS->VGAEngine) {
	case SIS_300_VGA:
	   if((!pSiS->NoAccel) && (pSiS->TurboQueue)) {
	        /* TQ size is always 512k */
           	temp = (pScrn->videoRam/64) - 8;
           	SR26 = temp & 0xFF;
           	inSISIDXREG(SISSR, 0x27, SR27);
		SR27 &= 0xFC;
		SR27 |= (0xF0 | ((temp >> 8) & 3));
           	outSISIDXREG(SISSR, 0x26, SR26);
           	outSISIDXREG(SISSR, 0x27, SR27);
	   }
	   break;

	case SIS_315_VGA:
	   if(!pSiS->NoAccel) {
	      /* On 315/330 series, there are three queue modes available
	       * which are chosen by setting bits 7:5 in SR26:
	       * 1. MMIO queue mode (bit 5, 0x20). The hardware will keep
	       *    track of the queue, the FIFO, command parsing and so
	       *    on. This is the one comparable to the 300 series.
	       * 2. VRAM queue mode (bit 6, 0x40). In this case, one will
	       *    have to do queue management himself. 
	       * 3. AGP queue mode (bit 7, 0x80). Works as 2., but keeps the
	       *    queue in AGP memory space.
	       * We go VRAM or MMIO here.
	       * SR26 bit 4 is called "Bypass H/W queue".
	       * SR26 bit 1 is called "Enable Command Queue Auto Correction"
	       * SR26 bit 0 resets the queue
	       * Size of queue memory is encoded in bits 3:2 like this:
	       *    00  (0x00)  512K
	       *    01  (0x04)  1M
	       *    10  (0x08)  2M
	       *    11  (0x0C)  4M
	       * The queue location is to be written to 0x85C0.
	       */
#ifdef SISVRAMQ
	      /* We use VRAM Cmd Queue, not MMIO or AGP */
	      unsigned char tempCR55 = 0;

#ifdef SISDUALHEAD
	      if(pSiS->DualHeadMode) {
	         SISEntPtr pSiSEnt = pSiS->entityPrivate;
	         pSiS->cmdQ_SharedWritePort = &(pSiSEnt->cmdQ_SharedWritePort_2D);
	      } else
#endif
	         pSiS->cmdQ_SharedWritePort = &(pSiS->cmdQ_SharedWritePort_2D);

	      /* Set Command Queue Threshold to max value 11111b (?) */
	      outSISIDXREG(SISSR, 0x27, 0x1F);
	      /* No idea what this does */
	      if(pSiS->sishw_ext.jChipType <= SIS_330) {
	         inSISIDXREG(SISCR, 0x55, tempCR55) ;
    	         andSISIDXREG(SISCR, 0x55, 0x33) ;
	      }
	      /* Syncronous reset for Command Queue */
	      outSISIDXREG(SISSR, 0x26, 0x01);
	      MMIO_OUT32(pSiS->IOBase, 0x85c4, 0);
	      /* Enable VRAM Command Queue mode */
	      switch(pSiS->cmdQueueSize) {
    		case 1*1024*1024: SR26 = (0x40 | 0x04 | 0x01); break;
    		case 2*1024*1024: SR26 = (0x40 | 0x08 | 0x01); break;
    		case 4*1024*1024: SR26 = (0x40 | 0x0C | 0x01); break;
		default:
		                  pSiS->cmdQueueSize = 512 * 1024;
		case    512*1024: SR26 = (0x40 | 0x00 | 0x01);
	      }
    	      outSISIDXREG(SISSR, 0x26, SR26);
	      SR26 &= 0xfe;
	      outSISIDXREG(SISSR, 0x26, SR26);
	      pSiS->cmdQ_SharedWritePort_2D = (unsigned long)(MMIO_IN32(pSiS->IOBase, 0x85c8));
              *(pSiS->cmdQ_SharedWritePort) = pSiS->cmdQ_SharedWritePort_2D;
              MMIO_OUT32(pSiS->IOBase, 0x85c4, pSiS->cmdQ_SharedWritePort_2D);
	      MMIO_OUT32(pSiS->IOBase, 0x85C0, pSiS->cmdQueueOffset);
	      temp = (unsigned long)pSiS->FbBase;
#ifdef SISDUALHEAD
	      if(pSiS->DualHeadMode) {
	         SISEntPtr pSiSEnt = pSiS->entityPrivate;
	         temp = (unsigned long)pSiSEnt->FbBase;
	      }
#endif
              temp += pSiS->cmdQueueOffset;
              pSiS->cmdQueueBase = (unsigned long *)temp;
	      if(pSiS->sishw_ext.jChipType <= SIS_330) {
    	         outSISIDXREG(SISCR, 0x55, tempCR55);
	      }
#else
	      /* For MMIO */
	      /* Set Command Queue Threshold to max value 11111b */
	      outSISIDXREG(SISSR, 0x27, 0x1F);
	      /* Syncronous reset for Command Queue */
	      outSISIDXREG(SISSR, 0x26, 0x01);
	      /* Do some magic (cp readport to writeport) */
	      temp = MMIO_IN32(pSiS->IOBase, 0x85C8);
	      MMIO_OUT32(pSiS->IOBase, 0x85C4, temp);
	      /* Enable MMIO Command Queue mode (0x20),
	       * Enable_command_queue_auto_correction (0x02)
	       *        (no idea, but sounds good, so use it)
	       * 512k (0x00) (does this apply to MMIO mode?) */
    	      outSISIDXREG(SISSR, 0x26, 0x22);
	      /* Calc Command Queue position (Q is always 512k)*/
	      temp = (pScrn->videoRam - 512) * 1024;
	      /* Set Q position */
	      MMIO_OUT32(pSiS->IOBase, 0x85C0, temp);
#endif
	   }
	   break;
	default:
	   break;
    }
}

/* Things to do before a ModeSwitch. We set up the
 * video bridge configuration and the TurboQueue.
 */
void SiSPreSetMode(ScrnInfoPtr pScrn, DisplayModePtr mode, int viewmode)
{
    SISPtr         pSiS = SISPTR(pScrn);
    unsigned char  CR30, CR31, CR32, CR33;
    unsigned char  CR39 = 0, CR3B = 0;
    unsigned char  CR17, CR38 = 0;
    unsigned char  CR35 = 0, CR79 = 0;
    unsigned long  vbflag;
    int            temp = 0, i;
    int 	   crt1rateindex = 0;
    DisplayModePtr mymode;
#ifdef SISMERGED
    DisplayModePtr mymode2 = NULL;
#endif

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       mymode = ((SiSMergedDisplayModePtr)mode->Private)->CRT1;
       mymode2 = ((SiSMergedDisplayModePtr)mode->Private)->CRT2;
    } else
#endif
    mymode = mode;

    vbflag = pSiS->VBFlags;
    pSiS->IsCustom = FALSE;
#ifdef SISMERGED
    pSiS->IsCustomCRT2 = FALSE;

    if(pSiS->MergedFB) {
       /* CRT2 */
       if(vbflag & CRT2_LCD) {
          if(pSiS->SiS_Pr->CP_HaveCustomData) {
	     for(i=0; i<7; i++) {
	        if(pSiS->SiS_Pr->CP_DataValid[i]) {
	           if((mymode2->HDisplay == pSiS->SiS_Pr->CP_HDisplay[i]) &&
	              (mymode2->VDisplay == pSiS->SiS_Pr->CP_VDisplay[i])) {
	              if(mymode2->type & M_T_BUILTIN) {
	                 pSiS->IsCustomCRT2 = TRUE;
		      }
	           }
		}
	     }
	  }
       }
       if(vbflag & (CRT2_VGA|CRT2_LCD)) {
          if(pSiS->AddedPlasmaModes) {
	     if(mymode2->type & M_T_BUILTIN) {
	        pSiS->IsCustomCRT2 = TRUE;
	     }
	  }
	  if(pSiS->HaveCustomModes2) {
             if(!(mymode2->type & M_T_DEFAULT)) {
	        pSiS->IsCustomCRT2 = TRUE;
             }
          }
       }
       /* CRT1 */
       if(pSiS->HaveCustomModes) {
          if(!(mymode->type & M_T_DEFAULT)) {
	     pSiS->IsCustom = TRUE;
          }
       }
    } else
#endif
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       if(!pSiS->SecondHead) {
          /* CRT2 */
          if(vbflag & CRT2_LCD) {
	     if(pSiS->SiS_Pr->CP_HaveCustomData) {
	        for(i=0; i<7; i++) {
                   if(pSiS->SiS_Pr->CP_DataValid[i]) {
	              if((mymode->HDisplay == pSiS->SiS_Pr->CP_HDisplay[i]) &&
	                 (mymode->VDisplay == pSiS->SiS_Pr->CP_VDisplay[i])) {
	                 if(mymode->type & M_T_BUILTIN) {
	                    pSiS->IsCustom = TRUE;
		         }
		      }
		   }
	        }
	     }
          }
	  if(vbflag & (CRT2_VGA|CRT2_LCD)) {
             if(pSiS->AddedPlasmaModes) {
	        if(mymode->type & M_T_BUILTIN) {
	           pSiS->IsCustom = TRUE;
	        }
	     }
	     if(pSiS->HaveCustomModes) {
                if(!(mymode->type & M_T_DEFAULT)) {
	           pSiS->IsCustom = TRUE;
                }
             }
          }
       } else {
          /* CRT1 */
          if(pSiS->HaveCustomModes) {
             if(!(mymode->type & M_T_DEFAULT)) {
	        pSiS->IsCustom = TRUE;
             }
          }
       }
    } else
#endif
    {
       if(vbflag & CRT2_LCD) {
          if(pSiS->SiS_Pr->CP_HaveCustomData) {
	     for(i=0; i<7; i++) {
	        if(pSiS->SiS_Pr->CP_DataValid[i]) {
                   if((mymode->HDisplay == pSiS->SiS_Pr->CP_HDisplay[i]) &&
	              (mymode->VDisplay == pSiS->SiS_Pr->CP_VDisplay[i])) {
	              if(mymode->type & M_T_BUILTIN) {
	                 pSiS->IsCustom = TRUE;
	              }
		   }
	        }
	     }
          }
       }
       if(vbflag & (CRT2_LCD|CRT2_VGA)) {
          if(pSiS->AddedPlasmaModes) {
             if(mymode->type & M_T_BUILTIN) {
	        pSiS->IsCustom = TRUE;
             }
          }
       }
       if((pSiS->HaveCustomModes) && (!(vbflag & CRT2_TV))) {
          if(!(mymode->type & M_T_DEFAULT)) {
	     pSiS->IsCustom = TRUE;
          }
       }
    }

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);    /* Unlock Registers */
#endif

    inSISIDXREG(SISCR, 0x30, CR30);
    inSISIDXREG(SISCR, 0x31, CR31);
    CR32 = pSiS->newCR32;
    inSISIDXREG(SISCR, 0x33, CR33);

    if(pSiS->Chipset == PCI_CHIP_SIS660) {

       inSISIDXREG(SISCR, 0x35, CR35);
       inSISIDXREG(SISCR, 0x38, CR38);
       inSISIDXREG(SISCR, 0x39, CR39);

       xf86DrvMsgVerb(pScrn->scrnIndex, X_PROBED, 4,
	   "Before: CR30=0x%02x,CR31=0x%02x,CR32=0x%02x,CR33=0x%02x,CR35=0x%02x,CR38=0x%02x\n",
              CR30, CR31, CR32, CR33, CR35, CR38);
       CR38 &= ~0x07;

    } else {

       if(pSiS->Chipset != PCI_CHIP_SIS300) {
          switch(pSiS->VGAEngine) {
             case SIS_300_VGA: temp = 0x35; break;
             case SIS_315_VGA: temp = 0x38; break;
          }
          if(temp) inSISIDXREG(SISCR, temp, CR38);
       }
       if(pSiS->VGAEngine == SIS_315_VGA) {
          inSISIDXREG(SISCR, 0x79, CR79);
          CR38 &= ~0x3b;   			/* Clear LCDA/DualEdge and YPbPr bits */
       }
       inSISIDXREG(SISCR, 0x3b, CR3B);
       xf86DrvMsgVerb(pScrn->scrnIndex, X_PROBED, 4,
	   "Before: CR30=0x%02x, CR31=0x%02x, CR32=0x%02x, CR33=0x%02x, CR%02x=0x%02x\n",
              CR30, CR31, CR32, CR33, temp, CR38);
    }

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4, "VBFlags=0x%lx\n", pSiS->VBFlags);

    CR30 = 0x00;
    CR31 &= ~0x60;  /* Clear VB_Drivermode & VB_OutputDisable */
    CR31 |= 0x04;   /* Set VB_NotSimuMode (not for 30xB/1400x1050?) */
    CR35 = 0x00;

    if(pSiS->Chipset != PCI_CHIP_SIS660) {
       if(!pSiS->AllowHotkey) {
          CR31 |= 0x80;   /* Disable hotkey-switch */
       }
       CR79 &= ~0x10;     /* Enable Backlight control on 315 series */
    }

    SiS_SetEnableDstn(pSiS->SiS_Pr, FALSE);
    SiS_SetEnableFstn(pSiS->SiS_Pr, FALSE);

    if((vbflag & CRT1_LCDA) && (viewmode == SIS_MODE_CRT1)) {

       CR38 |= 0x02;

    } else {

       switch(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {

       case CRT2_TV:

          CR38 &= ~0xC0; 	/* Clear Pal M/N bits */

          if((vbflag & VB_CHRONTEL) && (vbflag & TV_CHSCART)) {			/* Chrontel */
	     CR30 |= 0x10;
	     CR38 |= 0x04;
	     CR38 &= ~0x08;
	     CR31 |= 0x01;
	  } else if((vbflag & VB_CHRONTEL) && (vbflag & TV_CHYPBPR525I)) {	/* Chrontel */
	     CR38 |= 0x08;
	     CR38 &= ~0x04;
	     CR31 &= ~0x01;
          } else if(vbflag & TV_HIVISION) {	/* SiS bridge */
	     if(pSiS->Chipset == PCI_CHIP_SIS660) {
	        CR38 |= 0x04;
	        CR35 |= 0x60;
	     } else {
	        CR30 |= 0x80;
		if(pSiS->VGAEngine == SIS_315_VGA) {
		   if(vbflag & (VB_301LV | VB_302LV | VB_301C)) {
		      CR38 |= (0x08 | 0x30);
		   }
		}
	     }
	     CR31 |= 0x01;
	     CR35 |= 0x01;
	  } else if(vbflag & TV_YPBPR) {					/* SiS bridge */
	     if(pSiS->Chipset == PCI_CHIP_SIS660) {
	        CR38 |= 0x04;
	        if(vbflag & TV_YPBPR525P)       CR35 |= 0x20;
		else if(vbflag & TV_YPBPR750P)  CR35 |= 0x40;
		else if(vbflag & TV_YPBPR1080I) CR35 |= 0x60;
		CR31 &= ~0x01;
		CR35 &= ~0x01;
		CR39 &= ~0x03;
		if((vbflag & TV_YPBPRAR) == TV_YPBPR43LB)     CR39 |= 0x00;
		else if((vbflag & TV_YPBPRAR) == TV_YPBPR43)  CR39 |= 0x01;
		else if((vbflag & TV_YPBPRAR) == TV_YPBPR169) CR39 |= 0x02;
		else					      CR39 |= 0x03;
	     } else if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPR) {
	        CR30 |= 0x80;
		CR38 |= 0x08;
	        if(vbflag & TV_YPBPR525P)       CR38 |= 0x10;
		else if(vbflag & TV_YPBPR750P)  CR38 |= 0x20;
		else if(vbflag & TV_YPBPR1080I) CR38 |= 0x30;
		CR31 &= ~0x01;
		if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPRAR) {
		   CR3B &= ~0x03;
		   if((vbflag & TV_YPBPRAR) == TV_YPBPR43LB)     CR3B |= 0x00;
		   else if((vbflag & TV_YPBPRAR) == TV_YPBPR43)  CR3B |= 0x03;
		   else if((vbflag & TV_YPBPRAR) == TV_YPBPR169) CR3B |= 0x01;
		   else					         CR3B |= 0x03;
		}
	     }
          } else {								/* All */
	     if(vbflag & TV_SCART)  CR30 |= 0x10;
	     if(vbflag & TV_SVIDEO) CR30 |= 0x08;
	     if(vbflag & TV_AVIDEO) CR30 |= 0x04;
	     if(!(CR30 & 0x1C))	    CR30 |= 0x08;    /* default: SVIDEO */

	     if(vbflag & TV_PAL) {
		CR31 |= 0x01;
		CR35 |= 0x01;
		if( (vbflag & VB_SISBRIDGE) ||
		    ((vbflag & VB_CHRONTEL) && (pSiS->ChrontelType == CHRONTEL_701x)) )  {
		   if(vbflag & TV_PALM) {
		      CR38 |= 0x40;
		      CR35 |= 0x04;
		   } else if(vbflag & TV_PALN) {
		      CR38 |= 0x80;
		      CR35 |= 0x08;
	  	   }
	        }
	     } else {
		CR31 &= ~0x01;
		CR35 &= ~0x01;
		if(vbflag & TV_NTSCJ) {
		   CR38 |= 0x40;  /* TW, not BIOS */
		   CR35 |= 0x02;
	 	}
	     }
	     if(vbflag & TV_SCART) {
	        CR31 |= 0x01;
		CR35 |= 0x01;
	     }
	  }

	  CR31 &= ~0x04;   /* Clear NotSimuMode */
	  pSiS->SiS_Pr->SiS_CHOverScan = pSiS->UseCHOverScan;
	  if((pSiS->OptTVSOver == 1) && (pSiS->ChrontelType == CHRONTEL_700x)) {
	     pSiS->SiS_Pr->SiS_CHSOverScan = TRUE;
	  } else {
	     pSiS->SiS_Pr->SiS_CHSOverScan = FALSE;
	  }
#ifdef SIS_CP
	  SIS_CP_DRIVER_CONFIG
#endif
          break;

       case CRT2_LCD:
          CR30 |= 0x20;
	  SiS_SetEnableDstn(pSiS->SiS_Pr, pSiS->DSTN);
	  SiS_SetEnableFstn(pSiS->SiS_Pr, pSiS->FSTN);
          break;

       case CRT2_VGA:
          CR30 |= 0x40;
          break;

       default:
          CR30 |= 0x00;
          CR31 |= 0x20;    /* VB_OUTPUT_DISABLE */
	  if(pSiS->UseVESA) {
	     crt1rateindex = SISSearchCRT1Rate(pScrn, mymode);
	  }
       }

    }

    if(vbflag & CRT1_LCDA) {
       switch(viewmode) {
       case SIS_MODE_CRT1:
          CR38 |= 0x01;
          break;
       case SIS_MODE_CRT2:
          if(vbflag & (CRT2_TV|CRT2_VGA)) {
             CR30 |= 0x02;
	     CR38 |= 0x01;
	  } else {
	     CR38 |= 0x03;
	  }
          break;
       case SIS_MODE_SIMU:
       default:
          if(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {
             CR30 |= 0x01;
	  }
          break;
       }
    } else {
       if(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {
          CR30 |= 0x01;
       }
    }

    /* for VESA: no DRIVERMODE, otherwise
     * -) CRT2 will not be initialized correctly when using mode
     *    where LCD has to scale, and
     * -) CRT1 will have too low rate
     */
     if(pSiS->UseVESA) {
        CR31 &= ~0x40;   /* Clear Drivermode */
	CR31 |= 0x06;    /* Set SlaveMode, Enable SimuMode in Slavemode */
#ifdef TWDEBUG
        CR31 |= 0x40;    /* DEBUG (for non-slave mode VESA) */
	crt1rateindex = SISSearchCRT1Rate(pScrn, mymode);
#endif
     } else {
        CR31 |=  0x40;  /* Set Drivermode */
	CR31 &=  ~0x06; /* Disable SlaveMode, disable SimuMode in SlaveMode */
	if(!pSiS->IsCustom) {
           crt1rateindex = SISSearchCRT1Rate(pScrn, mymode);
	} else {
	   crt1rateindex = CR33;
	}
     }

#ifdef SISDUALHEAD
     if(pSiS->DualHeadMode) {
        if(pSiS->SecondHead) {
	    /* CRT1 */
	    CR33 &= 0xf0;
	    if(!(vbflag & CRT1_LCDA)) {
	       CR33 |= (crt1rateindex & 0x0f);
	    }
	} else {
	    /* CRT2 */
	    CR33 &= 0x0f;
	    if(vbflag & CRT2_VGA) {
	       CR33 |= ((crt1rateindex << 4) & 0xf0);
	    }
	}
     } else
#endif
#ifdef SISMERGED
     if(pSiS->MergedFB) {
        CR33 = 0;
	if(!(vbflag & CRT1_LCDA)) {
	   CR33 |= (crt1rateindex & 0x0f);
	}
        if(vbflag & CRT2_VGA) {
	   if(!pSiS->IsCustomCRT2) {
	      CR33 |= (SISSearchCRT1Rate(pScrn, mymode2) << 4);
	   }
	}
     } else
#endif
     {
        CR33 = 0;
	if(!(vbflag & CRT1_LCDA)) {
	   CR33 |= (crt1rateindex & 0x0f);
	}
        if(vbflag & CRT2_VGA) {
           CR33 |= ((crt1rateindex & 0x0f) << 4);
	}
	if((!(pSiS->UseVESA)) && (vbflag & CRT2_ENABLE)) {
	   if(pSiS->CRT1off) CR33 &= 0xf0;
	}
     }

     if(pSiS->Chipset == PCI_CHIP_SIS660) {

        CR31 &= 0xfe;   /* Clear PAL flag (now in CR35) */
	CR38 &= 0x07;   /* Use only LCDA and HiVision/YPbPr bits */
	outSISIDXREG(SISCR, 0x30, CR30);
	outSISIDXREG(SISCR, 0x31, CR31);
	outSISIDXREG(SISCR, 0x33, CR33);
	outSISIDXREG(SISCR, 0x35, CR35);
	setSISIDXREG(SISCR, 0x38, 0xf8, CR38);
	outSISIDXREG(SISCR, 0x39, CR39);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
		"After:  CR30=0x%02x,CR31=0x%02x,CR33=0x%02x,CR35=0x%02x,CR38=%02x\n",
		    CR30, CR31, CR33, CR35, CR38);

     } else {

        outSISIDXREG(SISCR, 0x30, CR30);
        outSISIDXREG(SISCR, 0x31, CR31);
        outSISIDXREG(SISCR, 0x33, CR33);
        if(temp) {
           outSISIDXREG(SISCR, temp, CR38);
        }
	if(pSiS->VGAEngine == SIS_315_VGA) {
	   outSISIDXREG(SISCR, 0x3b, CR3B);
	   outSISIDXREG(SISCR, 0x79, CR79);
	}
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
		"After:  CR30=0x%02x,CR31=0x%02x,CR33=0x%02x,CR%02x=%02x\n",
		    CR30, CR31, CR33, temp, CR38);
     }

     pSiS->SiS_Pr->SiS_UseOEM = pSiS->OptUseOEM;

     /* Enable TurboQueue */
#ifdef SISVRAMQ
     if(pSiS->VGAEngine != SIS_315_VGA)
#endif     
        SiSEnableTurboQueue(pScrn);

     if((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_ENABLE)) {
        /* Switch on CRT1 for modes that require the bridge in SlaveMode */
	andSISIDXREG(SISSR,0x1f,0x3f);
	inSISIDXREG(SISCR, 0x17, CR17);
	if(!(CR17 & 0x80)) {
           orSISIDXREG(SISCR, 0x17, 0x80);
	   outSISIDXREG(SISSR, 0x00, 0x01);
	   usleep(10000);
           outSISIDXREG(SISSR, 0x00, 0x03);
	}
     }
}

/* Functions for adjusting various TV settings */

/* These are used by the PostSetMode() functions as well as
 * the display properties tool SiSCtrl.
 *
 * There is each a Set and a Get routine. The Set functions
 * take a value of the same range as the corresponding option.
 * The Get routines return a value of the same range (although
 * not necessarily the same value as previously set because
 * of the lower resolution of the respective setting compared
 * to the valid range).
 * The Get routines return -2 on error (eg. hardware does not
 * support this setting).
 * Note: The x and y positioning routines accept a position
 * RELATIVE to the default position. All other routines 
 * take ABSOLUTE values.
 *
 * The Set functions will store the property regardless if TV is
 * currently used or not and if the hardware supports the property
 * or not. The Get routines will return this stored
 * value if TV is not currently used (because the register does
 * not contain the correct value then) or if the hardware supports
 * the respective property. This should make it easier for the 
 * display property tool because it does not have to know the
 * hardware features.
 *
 * All the routines are dual head aware. It does not matter
 * if the function is called from the CRT1 or CRT2 session.
 * The values will be in pSiSEnt anyway, and read from there
 * if we're running dual head.
 */

void SiS_SetCHTVlumabandwidthcvbs(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
   
   pSiS->chtvlumabandwidthcvbs = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvlumabandwidthcvbs = val;
#endif

   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   
   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 8;
           if((val == 0) || (val == 1)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x03),0xFE);
           }
	   break;
       case CHRONTEL_701x:
           val /= 4;
	   if((val >= 0) && (val <= 3)) {
	       SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x02),0xFC);
	   }
           break;
   }   
}

int SiS_GetCHTVlumabandwidthcvbs(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvlumabandwidthcvbs;
      else 
#endif
           return (int)pSiS->chtvlumabandwidthcvbs;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x01) * 8);
      case CHRONTEL_701x:
	   return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x03) * 4);
      default:
           return -2;   
      }
   }
}

void SiS_SetCHTVlumabandwidthsvideo(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvlumabandwidthsvideo = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvlumabandwidthsvideo = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
      
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 6;
           if((val >= 0) && (val <= 2)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 9) | 0x03),0xF9);
           }
	   break;
       case CHRONTEL_701x:
           val /= 4;
	   if((val >= 0) && (val <= 3)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 10) | 0x02),0xF3);
	   }
           break;
   }	   
}

int SiS_GetCHTVlumabandwidthsvideo(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvlumabandwidthsvideo;
      else 
#endif
           return (int)pSiS->chtvlumabandwidthsvideo;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x06) >> 1) * 6);
      case CHRONTEL_701x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x0c) >> 2) * 4);
      default:
           return -2;   
      }
   }      
}

void SiS_SetCHTVlumaflickerfilter(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvlumaflickerfilter = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvlumaflickerfilter = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 6;
           if((val >= 0) && (val <= 2)) {
	      unsigned short reg = 0;
	      reg = SiS_GetCH70xx(pSiS->SiS_Pr, 0x01);
	      reg = (reg & 0xf0) | ((reg & 0x0c) >> 2) | (val << 2);
              SiS_SetCH70xx(pSiS->SiS_Pr, ((reg << 8) | 0x01));
           }
	   break;
       case CHRONTEL_701x:
           val /= 4;
	   if((val >= 0) && (val <= 3)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 10) | 0x01),0xF3);
	   }
           break;
   } 
}

int SiS_GetCHTVlumaflickerfilter(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
  
   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
          return (int)pSiSEnt->chtvlumaflickerfilter;
      else
#endif      
          return (int)pSiS->chtvlumaflickerfilter;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x03) * 6);
      case CHRONTEL_701x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x0c) >> 2) * 4);
      default:
           return -2;   
      }
   }     
}

void SiS_SetCHTVchromabandwidth(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvchromabandwidth = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvchromabandwidth = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 4;
           if((val >= 0) && (val <= 3)) {
              SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 12) | 0x03),0xCF);
           }
	   break;
       case CHRONTEL_701x:
           val /= 8;
	   if((val >= 0) && (val <= 1)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 12) | 0x02),0xEF);
	   }
           break;
   }	   
}

int SiS_GetCHTVchromabandwidth(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvchromabandwidth;
      else
#endif   
           return (int)pSiS->chtvchromabandwidth;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x30) >> 4) * 4);
      case CHRONTEL_701x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x10) >> 4) * 8);
      default:
           return -2;   
      }
   }    
}

void SiS_SetCHTVchromaflickerfilter(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvchromaflickerfilter = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvchromaflickerfilter = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 6;
           if((val >= 0) && (val <= 2)) {
	      unsigned short reg = 0;
	      reg = SiS_GetCH70xx(pSiS->SiS_Pr, 0x01);
	      reg = (reg & 0xc0) | ((reg & 0x0c) >> 2) | ((reg & 0x03) << 2) | (val << 4);
              SiS_SetCH70xx(pSiS->SiS_Pr, ((reg << 8) | 0x01));
           }
	   break;
       case CHRONTEL_701x:
           val /= 4;
	   if((val >= 0) && (val <= 3)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 12) | 0x01),0xCF);
	   }
           break;
   }	   
}

int SiS_GetCHTVchromaflickerfilter(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvchromaflickerfilter;
      else
#endif
           return (int)pSiS->chtvchromaflickerfilter;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x30) >> 4) * 6);
      case CHRONTEL_701x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x30) >> 4) * 4);
      default:
           return -2;   
      }
   }    
}

void SiS_SetCHTVcvbscolor(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvcvbscolor = val ? 1 : 0;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvcvbscolor = pSiS->chtvcvbscolor;
#endif

   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           if(!val)  SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x4003,0x00);
           else      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x0003,~0x40);
	   break;
       case CHRONTEL_701x:
           if(!val)  SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x0002,~0x20);
	   else      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x2002,0x00);
           break;
   }
}

int SiS_GetCHTVcvbscolor(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD
      if(pSiSEnt && pSiS->DualHeadMode)
           return (int)pSiSEnt->chtvcvbscolor;
      else
d1268 4
a1271 15
           return (int)pSiS->chtvcvbscolor;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x40) >> 6) ^ 0x01);
      case CHRONTEL_701x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x20) >> 5) ^ 0x01);
      default:
           return -2;
      }
   }
}
d1273 7
a1279 6
void SiS_SetCHTVtextenhance(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
d1281 3
a1283 4
   pSiS->chtvtextenhance = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvtextenhance = val;
#endif
d1285 6
a1290 2
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
d1292 1
a1292 21
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 6;
           if((val >= 0) && (val <= 2)) {
	      unsigned short reg = 0;
	      reg = SiS_GetCH70xx(pSiS->SiS_Pr, 0x01);
	      reg = (reg & 0xf0) | ((reg & 0x03) << 2) | val;
              SiS_SetCH70xx(pSiS->SiS_Pr, ((reg << 8) | 0x01));
           }
	   break;
       case CHRONTEL_701x:
           val /= 2;
	   if((val >= 0) && (val <= 7)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x03),0xF8);
	   }
           break;
   }
a1294 6
int SiS_GetCHTVtextenhance(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
d1296 3
a1298 21
   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvtextenhance;
      else
#endif      
           return (int)pSiS->chtvtextenhance;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x0c) >> 2) * 6);
      case CHRONTEL_701x:
	   return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x07) * 2);
      default:
           return -2;
      }
   }
}
d1300 2
a1301 1
void SiS_SetCHTVcontrast(ScrnInfoPtr pScrn, int val)
d1303 1
a1303 4
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
d1305 1
a1305 11
   pSiS->chtvcontrast = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvcontrast = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d1307 5
a1311 13
   val /= 2;
   if((val >= 0) && (val <= 7)) {
       switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
              SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x11),0xF8);
	      break;
       case CHRONTEL_701x:
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x08),0xF8);
              break;
       }
       SiS_DDC2Delay(pSiS->SiS_Pr, 1000);
   }
}
d1313 4
a1316 6
int SiS_GetCHTVcontrast(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
d1318 3
a1320 20
   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvcontrast;
      else
#endif      
           return (int)pSiS->chtvcontrast;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif   
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x11) & 0x07) * 2);
      case CHRONTEL_701x:
	   return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x08) & 0x07) * 2);
      default:
           return -2;   
      }
   }
d1323 5
a1327 1
void SiS_SetSISTVedgeenhance(ScrnInfoPtr pScrn, int val)
d1329 3
a1331 4
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
d1333 3
a1335 4
   pSiS->sistvedgeenhance = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->sistvedgeenhance = val;
#endif
d1337 1
a1337 2
   if(!(pSiS->VBFlags & VB_301))  return;
   if(!(pSiS->VBFlags & CRT2_TV)) return;
d1339 2
a1340 8
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   val /= 2;
   if((val >= 0) && (val <= 7)) {
      setSISIDXREG(SISPART2,0x3A, 0x1F, (val << 5));
   }
d1343 2
a1344 1
int SiS_GetSISTVedgeenhance(ScrnInfoPtr pScrn)
d1346 1
a1346 5
   SISPtr pSiS = SISPTR(pScrn);
   int result = pSiS->sistvedgeenhance;
   unsigned char temp;
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
d1348 1
a1348 2
   if(pSiSEnt && pSiS->DualHeadMode) result = pSiSEnt->sistvedgeenhance;
#endif
d1350 25
a1374 2
   if(!(pSiS->VBFlags & VB_301))  return result;
   if(!(pSiS->VBFlags & CRT2_TV)) return result;
d1376 6
a1381 6
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   inSISIDXREG(SISPART2, 0x3a, temp);
   return(int)(((temp & 0xe0) >> 5) * 2);
}
d1383 2
a1384 1
void SiS_SetSISTVantiflicker(ScrnInfoPtr pScrn, int val)
d1386 4
a1389 4
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
d1391 3
a1393 10
   pSiS->sistvantiflicker = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->sistvantiflicker = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV))      return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE)) return;
   if(pSiS->VBFlags & TV_HIVISION)     return;
   if((pSiS->VBFlags & TV_YPBPR) &&
      (pSiS->VBFlags & (TV_YPBPR525P | TV_YPBPR750P | TV_YPBPR1080I))) return;
d1395 4
a1398 3
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d1400 35
a1434 5
   /* Valid values: 0=off, 1=low, 2=med, 3=high, 4=adaptive */
   if((val >= 0) && (val <= 4)) {
      setSISIDXREG(SISPART2,0x0A,0x8F, (val << 4));
   }
}
d1436 2
a1437 7
int SiS_GetSISTVantiflicker(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   int result = pSiS->sistvantiflicker;
   unsigned char temp;
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
d1439 1
a1439 2
   if(pSiSEnt && pSiS->DualHeadMode) result = pSiSEnt->sistvantiflicker;
#endif
d1441 26
a1466 5
   if(!(pSiS->VBFlags & VB_SISBRIDGE)) return result;
   if(!(pSiS->VBFlags & CRT2_TV))      return result;
   if(pSiS->VBFlags & TV_HIVISION)     return result;
   if((pSiS->VBFlags & TV_YPBPR) &&
      (pSiS->VBFlags & (TV_YPBPR525P | TV_YPBPR750P | TV_YPBPR1080I))) return result;
d1468 6
a1473 5
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   inSISIDXREG(SISPART2, 0x0a, temp);
   return(int)((temp & 0x70) >> 4);
d1476 2
a1477 1
void SiS_SetSISTVsaturation(ScrnInfoPtr pScrn, int val)
d1479 2
a1480 4
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
d1482 1
a1482 4
   pSiS->sistvsaturation = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->sistvsaturation = val;
#endif
d1484 2
a1485 3
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE)) return;
   if(pSiS->VBFlags & VB_301) return;
d1487 2
a1488 3
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d1490 5
a1494 5
   val /= 2;
   if((val >= 0) && (val <= 7)) {
      setSISIDXREG(SISPART4,0x21,0xF8, val);
   }
}
d1496 2
a1497 7
int SiS_GetSISTVsaturation(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   int result = pSiS->sistvsaturation;
   unsigned char temp;
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
d1499 2
a1500 2
   if(pSiSEnt && pSiS->DualHeadMode)  result = pSiSEnt->sistvsaturation;
#endif
d1502 2
a1503 3
   if(!(pSiS->VBFlags & VB_SISBRIDGE)) return result;
   if(pSiS->VBFlags & VB_301)          return result;
   if(!(pSiS->VBFlags & CRT2_TV))      return result;
a1504 6
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   inSISIDXREG(SISPART4, 0x21, temp);
   return(int)((temp & 0x07) * 2);
}
d1506 5
a1510 1
void SiS_SetSISTVcolcalib(ScrnInfoPtr pScrn, int val, Bool coarse)
d1512 4
a1515 6
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
   int ccoarse, cfine, cbase = pSiS->sistvccbase;
   unsigned char temp;
d1517 4
a1520 23
#ifdef SISDUALHEAD
   if(pSiSEnt && pSiS->DualHeadMode) cbase = pSiSEnt->sistvccbase;
#endif

   if(coarse) {
      pSiS->sistvcolcalibc = ccoarse = val;
      cfine = pSiS->sistvcolcalibf;
#ifdef SISDUALHEAD
      if(pSiSEnt) {
         pSiSEnt->sistvcolcalibc = val;
	 if(pSiS->DualHeadMode) cfine = pSiSEnt->sistvcolcalibf;
      }
#endif
   } else {
      pSiS->sistvcolcalibf = cfine = val;
      ccoarse = pSiS->sistvcolcalibc;
#ifdef SISDUALHEAD
      if(pSiSEnt) {
         pSiSEnt->sistvcolcalibf = val;
         if(pSiS->DualHeadMode) ccoarse = pSiSEnt->sistvcolcalibc;
      }
#endif
   }
d1522 1
a1522 3
   if(!(pSiS->VBFlags & CRT2_TV))               return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE))          return;
   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return;
d1524 1
a1524 3
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d1526 1
a1526 2
   if((cfine >= -128) && (cfine <= 127) && (ccoarse >= -120) && (ccoarse <= 120)) {
      long finalcc = cbase + (((ccoarse * 256) + cfine) * 256);
d1528 1
a1528 14
      inSISIDXREG(SISPART4,0x1f,temp);
      if(!(temp & 0x01)) {
#if 0
         if(pSiS->VBFlags & TV_NTSC) finalcc += 0x21ed8620;
	 else if(pSiS->VBFlags & TV_PALM) finalcc += ?;
	 else if(pSiS->VBFlags & TV_PALM) finalcc += ?;
	 else finalcc += 0x2a05d300;
#endif
      }
      setSISIDXREG(SISPART2,0x31,0x80,((finalcc >> 24) & 0x7f));
      outSISIDXREG(SISPART2,0x32,((finalcc >> 16) & 0xff));
      outSISIDXREG(SISPART2,0x33,((finalcc >> 8) & 0xff));
      outSISIDXREG(SISPART2,0x34,(finalcc & 0xff));
   }
d1531 2
a1532 1
int SiS_GetSISTVcolcalib(ScrnInfoPtr pScrn, Bool coarse)
a1534 2
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
d1536 1
a1536 7
   if(pSiSEnt && pSiS->DualHeadMode)
      if(coarse)  return (int)pSiSEnt->sistvcolcalibc;
      else        return (int)pSiSEnt->sistvcolcalibf;
   else
#endif
   if(coarse)     return (int)pSiS->sistvcolcalibc;
   else           return (int)pSiS->sistvcolcalibf;
d1539 3
a1541 1
void SiS_SetSISTVcfilter(ScrnInfoPtr pScrn, int val)
d1543 1
a1543 4
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
d1545 3
a1547 4
   pSiS->sistvcfilter = val ? 1 : 0;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->sistvcfilter = pSiS->sistvcfilter;
#endif
d1549 3
a1551 3
   if(!(pSiS->VBFlags & CRT2_TV))               return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE))          return;
   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return;
d1553 15
a1567 3
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d1569 4
a1572 2
   setSISIDXREG(SISPART2,0x30,~0x10,((pSiS->sistvcfilter << 4) & 0x10));
}
d1574 1
a1574 7
int SiS_GetSISTVcfilter(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   int result = pSiS->sistvcfilter;
   unsigned char temp;
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
d1576 1
a1576 2
   if(pSiSEnt && pSiS->DualHeadMode) result = pSiSEnt->sistvcfilter;
#endif
d1578 1
a1578 3
   if(!(pSiS->VBFlags & VB_SISBRIDGE))          return result;
   if(!(pSiS->VBFlags & CRT2_TV))               return result;
   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return result;
d1580 2
a1581 6
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   inSISIDXREG(SISPART2, 0x30, temp);
   return(int)((temp & 0x10) ? 1 : 0);
}
d1583 4
a1586 8
void SiS_SetSISTVyfilter(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
   unsigned char p35,p36,p37,p38,p48,p49,p4a,p30;
   int i,j;
d1588 3
a1590 4
   pSiS->sistvyfilter = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->sistvyfilter = pSiS->sistvyfilter;
#endif
d1592 2
a1593 17
   if(!(pSiS->VBFlags & CRT2_TV))               return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE))          return;
   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return;

   p35 = pSiS->p2_35; p36 = pSiS->p2_36;
   p37 = pSiS->p2_37; p38 = pSiS->p2_38;
   p48 = pSiS->p2_48; p49 = pSiS->p2_49;
   p4a = pSiS->p2_4a; p30 = pSiS->p2_30;
#ifdef SISDUALHEAD
   if(pSiSEnt && pSiS->DualHeadMode) {
      p35 = pSiSEnt->p2_35; p36 = pSiSEnt->p2_36;
      p37 = pSiSEnt->p2_37; p38 = pSiSEnt->p2_38;
      p48 = pSiSEnt->p2_48; p49 = pSiSEnt->p2_49;
      p4a = pSiSEnt->p2_4a; p30 = pSiSEnt->p2_30;
   }
#endif
   p30 &= 0x20;
d1595 3
a1597 3
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d1599 3
a1601 97
   switch(pSiS->sistvyfilter) {
   case 0:
      andSISIDXREG(SISPART2,0x30,0xdf);
      break;
   case 1:
      outSISIDXREG(SISPART2,0x35,p35);
      outSISIDXREG(SISPART2,0x36,p36);
      outSISIDXREG(SISPART2,0x37,p37);
      outSISIDXREG(SISPART2,0x38,p38);
      if(!(pSiS->VBFlags & VB_301)) {
         outSISIDXREG(SISPART2,0x48,p48);
         outSISIDXREG(SISPART2,0x49,p49);
         outSISIDXREG(SISPART2,0x4a,p4a);
      }
      setSISIDXREG(SISPART2,0x30,0xdf,p30);
      break;
   case 2:
   case 3:
   case 4:
   case 5:
   case 6:
   case 7:
   case 8:
      if(!(pSiS->VBFlags & (TV_PALM | TV_PALN | TV_NTSCJ))) {
         int yindex301 = -1, yindex301B = -1;
	 unsigned char p3d4_34;

	 inSISIDXREG(SISCR,0x34,p3d4_34);

	 switch((p3d4_34 & 0x7f)) {
	 case 0x59:  /* 320x200 */
	 case 0x41:
	 case 0x4f:
	 case 0x50:  /* 320x240 */
	 case 0x56:
	 case 0x53:
	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 0 : 4;
	    break;
	 case 0x2f:  /* 640x400 */
	 case 0x5d:
	 case 0x5e:
	 case 0x2e:  /* 640x480 */
	 case 0x44:
	 case 0x62:
	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 1 : 5;
	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 0 : 4;
	    break;
	 case 0x31:   /* 720x480 */
	 case 0x33:
	 case 0x35:
	 case 0x32:   /* 720x576 */
	 case 0x34:
	 case 0x36:
	 case 0x5f:   /* 768x576 */
	 case 0x60:
	 case 0x61:
	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 2 : 6;
	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 1 : 5;
	    break;
	 case 0x51:   /* 400x300 */
	 case 0x57:
	 case 0x54:
	 case 0x30:   /* 800x600 */
	 case 0x47:
	 case 0x63:
	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 3 : 7;
	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 2 : 6;
	    break;
	 case 0x52:   /* 512x384 */
	 case 0x58:
	 case 0x5c:
	 case 0x38:   /* 1024x768 */
	 case 0x4a:
	 case 0x64:
	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 3 : 7;
	    break;
	 }
         if(pSiS->VBFlags & VB_301) {
            if(yindex301 >= 0) {
	       for(i=0, j=0x35; i<=3; i++, j++) {
	          outSISIDXREG(SISPART2,j,(SiSTVFilter301[yindex301].filter[pSiS->sistvyfilter-2][i]));
	       }
	    }
         } else {
            if(yindex301B >= 0) {
	       for(i=0, j=0x35; i<=3; i++, j++) {
	          outSISIDXREG(SISPART2,j,(SiSTVFilter301B[yindex301B].filter[pSiS->sistvyfilter-2][i]));
	       }
	       for(i=4, j=0x48; i<=6; i++, j++) {
	          outSISIDXREG(SISPART2,j,(SiSTVFilter301B[yindex301B].filter[pSiS->sistvyfilter-2][i]));
	       }
	    }
         }
         orSISIDXREG(SISPART2,0x30,0x20);
      }
   }
}
d1603 3
a1605 5
int SiS_GetSISTVyfilter(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
d1607 11
a1617 6
   if(pSiSEnt && pSiS->DualHeadMode)
      return (int)pSiSEnt->sistvyfilter;
   else
#endif
      return (int)pSiS->sistvyfilter;
}
d1619 4
a1622 4
void SiS_SetSIS6326TVantiflicker(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;
a1623 1
   pSiS->sistvantiflicker = val;
d1625 1
a1625 1
   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
d1627 4
a1630 14
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
  
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) return;
   
   /* Valid values: 0=off, 1=low, 2=med, 3=high, 4=adaptive */
   if(val >= 0 && val <= 4) {
      tmp &= 0x1f;
      tmp |= (val << 5);
      SiS6326SetTVReg(pScrn,0x00,tmp);
   }
}
d1632 11
a1642 20
int SiS_GetSIS6326TVantiflicker(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;
   
   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
      return (int)pSiS->sistvantiflicker;
   }
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) {
      return (int)pSiS->sistvantiflicker;
   } else {
      return (int)((tmp >> 5) & 0x07);    
   }
}
d1644 3
a1646 4
void SiS_SetSIS6326TVenableyfilter(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;
d1648 4
a1651 2
   if(val) val = 1;   
   pSiS->sis6326enableyfilter = val;
d1653 9
a1661 14
   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
  
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) return;
   
   tmp = SiS6326GetTVReg(pScrn,0x43);
   tmp &= ~0x10;
   tmp |= ((val & 0x01) << 4);
   SiS6326SetTVReg(pScrn,0x43,tmp);
}
d1663 5
a1667 21
int SiS_GetSIS6326TVenableyfilter(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;
   
   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
      return (int)pSiS->sis6326enableyfilter;
   }
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) {
      return (int)pSiS->sis6326enableyfilter;
   } else {
      tmp = SiS6326GetTVReg(pScrn,0x43);
      return (int)((tmp >> 4) & 0x01);
   }
}
d1669 2
a1670 24
void SiS_SetSIS6326TVyfilterstrong(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;
   
   if(val) val = 1;
   pSiS->sis6326yfilterstrong = val;

   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
  
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) return;
   
   tmp = SiS6326GetTVReg(pScrn,0x43);
   if(tmp & 0x10) {
      tmp &= ~0x40;
      tmp |= ((val & 0x01) << 6);
      SiS6326SetTVReg(pScrn,0x43,tmp);
   }
}
d1672 3
a1674 31
int SiS_GetSIS6326TVyfilterstrong(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;
   
   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
      return (int)pSiS->sis6326yfilterstrong;
   }
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) {
      return (int)pSiS->sis6326yfilterstrong;
   } else {
      tmp = SiS6326GetTVReg(pScrn,0x43);
      if(!(tmp & 0x10)) {
         return (int)pSiS->sis6326yfilterstrong;
      } else {
         return (int)((tmp >> 6) & 0x01);
      }
   }
}
   
void SiS_SetTVxposoffset(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
d1677 4
a1680 3
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d1682 18
a1699 4
   pSiS->tvxpos = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->tvxpos = val;
#endif
d1701 14
a1714 1
   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
d1716 16
a1731 1
      if(pSiS->VBFlags & CRT2_TV) {
d1733 6
a1738 1
         if(pSiS->VBFlags & VB_CHRONTEL) {
d1740 13
a1752 17
	    int x = pSiS->tvx;
#ifdef SISDUALHEAD
	    if(pSiSEnt && pSiS->DualHeadMode) x = pSiSEnt->tvx;
#endif
	    switch(pSiS->ChrontelType) {
	    case CHRONTEL_700x:
	       if((val >= -32) && (val <= 32)) {
		   x += val;
		   if(x < 0) x = 0;
		   SiS_SetCH700x(pSiS->SiS_Pr, (((x & 0xff) << 8) | 0x0a));
		   SiS_SetCH70xxANDOR(pSiS->SiS_Pr, (((x & 0x0100) << 1) | 0x08),0xFD);
	       }
	       break;
	    case CHRONTEL_701x:
	       /* Not supported by hardware */
	       break;
	    }
d1754 2
a1755 1
	 } else if(pSiS->VBFlags & VB_SISBRIDGE) {
d1757 2
a1758 1
	    if((val >= -32) && (val <= 32)) {
d1760 3
a1762 12
	        unsigned char p2_1f,p2_20,p2_2b,p2_43;
		unsigned short temp;
		int myadd2, mysub;

		p2_1f = pSiS->p2_1f;
		p2_20 = pSiS->p2_20;
#ifdef SISDUALHEAD
	        if(pSiSEnt && pSiS->DualHeadMode) {
		   p2_1f = pSiSEnt->p2_1f;
		   p2_20 = pSiSEnt->p2_20;
		}
#endif
d1764 4
a1767 2
		temp = p2_1f | ((p2_20 & 0xf0) << 4);
		temp += (val * 2);
d1769 3
a1771 2
		p2_1f = temp & 0xff;
		p2_20 = (temp & 0xf00) >> 4;
d1773 2
a1774 20
		if(pSiS->MiscFlags & MISC_TVNTSC1024) {
		   temp += 1514; myadd2 = 4; mysub = 4;
		} else if((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & (TV_YPBPR525P | TV_YPBPR750P))) {
		   myadd2 = -7;
		   if(pSiS->VBFlags & TV_YPBPR525P) {
		      temp += 1274; mysub = 15;
		   } else {
		      temp += 1284; mysub = 12;
		   }
		} else if((pSiS->VBFlags & TV_HIVISION) ||
		          ((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR1080I))) {
		   temp += 1737; myadd2 = -4;
		   if(pSiS->VBFlags & VB_301) myadd2 += 3;
		   mysub = 12;
		} else {
		   temp += 1363; myadd2 = 3;
		   if(pSiS->VBFlags & VB_301) myadd2 += 3;
		   if((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR525I)) myadd2 += 3;
		   mysub = 5;
		}
d1776 5
a1780 2
		p2_2b = ((temp & 0xf00) >> 4) | ((p2_1f - mysub) & 0x0f);
		p2_43 = p2_1f + myadd2;
d1782 7
a1788 57
		SISWaitRetraceCRT2(pScrn);
	        outSISIDXREG(SISPART2,0x1f,p2_1f);
		setSISIDXREG(SISPART2,0x20,0x0F,p2_20);
		outSISIDXREG(SISPART2,0x2b,p2_2b);
		outSISIDXREG(SISPART2,0x43,p2_43);
	     }
	 }
      }

   } else if(pSiS->Chipset == PCI_CHIP_SIS6326) {

      if(pSiS->SiS6326Flags & SIS6326_TVDETECTED) {

         unsigned char tmp;
	 unsigned short temp1, temp2, temp3;

         tmp = SiS6326GetTVReg(pScrn,0x00);
         if(tmp & 0x04) {

	    temp1 = pSiS->tvx1;
            temp2 = pSiS->tvx2;
            temp3 = pSiS->tvx3;
            if((val >= -16) && (val <= 16)) {
	       if(val > 0) {
	          temp1 += (val * 4);
	          temp2 += (val * 4);
	          while((temp1 > 0x0fff) || (temp2 > 0x0fff)) {
	             temp1 -= 4;
		     temp2 -= 4;
	          }
	       } else {
	          val = -val;
	          temp3 += (val * 4);
	          while(temp3 > 0x03ff) {
	     	     temp3 -= 4;
	          } 
	       }
            }
            SiS6326SetTVReg(pScrn,0x3a,(temp1 & 0xff));
            tmp = SiS6326GetTVReg(pScrn,0x3c);
            tmp &= 0xf0;
            tmp |= ((temp1 & 0x0f00) >> 8);
            SiS6326SetTVReg(pScrn,0x3c,tmp);
            SiS6326SetTVReg(pScrn,0x26,(temp2 & 0xff));
            tmp = SiS6326GetTVReg(pScrn,0x27);
            tmp &= 0x0f;
            tmp |= ((temp2 & 0x0f00) >> 4);
            SiS6326SetTVReg(pScrn,0x27,tmp);
            SiS6326SetTVReg(pScrn,0x12,(temp3 & 0xff));
            tmp = SiS6326GetTVReg(pScrn,0x13);
            tmp &= ~0xC0;
            tmp |= ((temp3 & 0x0300) >> 2);
            SiS6326SetTVReg(pScrn,0x13,tmp);
	 }
      }
   }
}
d1790 4
a1793 5
int SiS_GetTVxposoffset(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
d1795 8
a1802 6
   if(pSiSEnt && pSiS->DualHeadMode)
        return (int)pSiSEnt->tvxpos;
   else
#endif
        return (int)pSiS->tvxpos;
}
d1804 2
a1805 6
void SiS_SetTVyposoffset(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
d1807 7
a1813 2
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
d1816 14
a1829 3
   pSiS->tvypos = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->tvypos = val;
d1832 3
a1834 1
   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
d1836 4
a1839 1
      if(pSiS->VBFlags & CRT2_TV) {
d1841 2
a1842 1
         if(pSiS->VBFlags & VB_CHRONTEL) {
d1844 2
a1845 17
	    int y = pSiS->tvy;
#ifdef SISDUALHEAD
	    if(pSiSEnt && pSiS->DualHeadMode) y = pSiSEnt->tvy;
#endif
	    switch(pSiS->ChrontelType) {
	    case CHRONTEL_700x:
	       if((val >= -32) && (val <= 32)) {
		   y -= val;
		   if(y < 0) y = 0;
		   SiS_SetCH700x(pSiS->SiS_Pr, (((y & 0xff) << 8) | 0x0b));
		   SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((y & 0x0100) | 0x08),0xFE);
	       }
	       break;
	    case CHRONTEL_701x:
	       /* Not supported by hardware */
	       break;
	    }
a1846 1
	 } else if(pSiS->VBFlags & VB_SISBRIDGE) {
d1848 5
a1852 68
	    if((val >= -32) && (val <= 32)) {
		char p2_01, p2_02;
		val /= 2;  /* 4 */
		p2_01 = pSiS->p2_01;
		p2_02 = pSiS->p2_02;
#ifdef SISDUALHEAD
	        if(pSiSEnt && pSiS->DualHeadMode) {
		   p2_01 = pSiSEnt->p2_01;
		   p2_02 = pSiSEnt->p2_02;
		}
#endif
		p2_01 += val; /* val * 2 */
		p2_02 += val; /* val * 2 */
		while((p2_01 <= 0) || (p2_02 <= 0)) {
		      p2_01 += 2;
		      p2_02 += 2;
		}
		SISWaitRetraceCRT2(pScrn);
		outSISIDXREG(SISPART2,0x01,p2_01);
		outSISIDXREG(SISPART2,0x02,p2_02);
	     }
	 }

      }

   } else if(pSiS->Chipset == PCI_CHIP_SIS6326) {

      if(pSiS->SiS6326Flags & SIS6326_TVDETECTED) {

         unsigned char tmp;
	 int temp1, limit;

         tmp = SiS6326GetTVReg(pScrn,0x00);
         if(tmp & 0x04) {

	    if((val >= -16) && (val <= 16)) {
	      temp1 = (unsigned short)pSiS->tvy1;
	      limit = (pSiS->SiS6326Flags & SIS6326_TVPAL) ? 625 : 525;
	      if(val > 0) {
                temp1 += (val * 4);
	        if(temp1 > limit) temp1 -= limit;
	      } else {
	        val = -val;
	        temp1 -= (val * 2);
	        if(temp1 <= 0) temp1 += (limit -1);
	      }
	      SiS6326SetTVReg(pScrn,0x11,(temp1 & 0xff));
	      tmp = SiS6326GetTVReg(pScrn,0x13);
	      tmp &= ~0x30;
	      tmp |= ((temp1 & 0x300) >> 4);
	      SiS6326SetTVReg(pScrn,0x13,tmp);
	      if(temp1 == 1)                                 tmp = 0x10;
	      else {
	       if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
	         if((temp1 <= 3) || (temp1 >= (limit - 2)))  tmp = 0x08;
	         else if(temp1 < 22)		 	     tmp = 0x02;
	         else 					     tmp = 0x04;
	       } else {
	         if((temp1 <= 5) || (temp1 >= (limit - 4)))  tmp = 0x08;
	         else if(temp1 < 19)			     tmp = 0x02;
	         else 					     tmp = 0x04;
	       }
	     }
	     SiS6326SetTVReg(pScrn,0x21,tmp);
           }
	 }
      }
   }
d1855 7
a1861 1
int SiS_GetTVyposoffset(ScrnInfoPtr pScrn)
d1863 6
a1868 3
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
d1870 3
a1872 6
   if(pSiSEnt && pSiS->DualHeadMode)
        return (int)pSiSEnt->tvypos;
   else
#endif
        return (int)pSiS->tvypos;
}
d1874 29
a1902 6
void SiS_SetTVxscale(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
d1904 29
a1932 3
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d1934 1
a1934 4
   pSiS->tvxscale = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->tvxscale = val;
#endif
d1936 1
a1936 1
   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
d1938 1
a1938 1
      if((pSiS->VBFlags & CRT2_TV) && (pSiS->VBFlags & VB_SISBRIDGE)) {
d1940 7
a1946 1
	 if((val >= -16) && (val <= 16)) {
d1948 7
a1954 12
	    unsigned char p2_44,p2_45,p2_46;
	    int scalingfactor;

	    p2_44 = pSiS->p2_44;
	    p2_45 = pSiS->p2_45 & 0x3f;
	    p2_46 = pSiS->p2_46 & 0x07;
#ifdef SISDUALHEAD
	    if(pSiSEnt && pSiS->DualHeadMode) {
	       p2_44 = pSiSEnt->p2_44;
	       p2_45 = pSiSEnt->p2_45 & 0x3f;
	       p2_46 = pSiSEnt->p2_46 & 0x07;
	    }
a1955 1
	    scalingfactor = (p2_46 << 13) | ((p2_45 & 0x1f) << 8) | p2_44;
d1957 2
a1958 9
	    if(val < 0) {
	       p2_45 &= 0xdf;
	       scalingfactor += ((-val) * 64);
	       if(scalingfactor > 0xffff) scalingfactor = 0xffff;
	    } else if(val > 0) {
	       p2_45 &= 0xdf;
	       scalingfactor -= (val * 64);
	       if(scalingfactor < 1) scalingfactor = 1;
	    }
d1960 1
a1960 12
	    p2_44 = scalingfactor & 0xff;
	    p2_45 &= 0xe0;
	    p2_45 |= ((scalingfactor >> 8) & 0x1f);
	    p2_46 = ((scalingfactor >> 13) & 0x07);

	    SISWaitRetraceCRT2(pScrn);
	    outSISIDXREG(SISPART2,0x44,p2_44);
	    setSISIDXREG(SISPART2,0x45,0xC0,p2_45);
	    if(!(pSiS->VBFlags & VB_301)) {
	       setSISIDXREG(SISPART2,0x46,0xF8,p2_46);
	    }
	 }
d1962 4
a1965 1
      }
d1967 1
a1967 1
   }
d1970 6
a1975 5
int SiS_GetTVxscale(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
d1977 3
a1979 8
   if(pSiSEnt && pSiS->DualHeadMode)
        return (int)pSiSEnt->tvxscale;
   else
#endif
        return (int)pSiS->tvxscale;
}

void SiS_SetTVyscale(ScrnInfoPtr pScrn, int val)
d1981 3
a1983 5
   SISPtr pSiS = SISPTR(pScrn);
   Bool usentsc = FALSE;
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
d1985 2
a1986 2
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
d1989 1
a1989 2
   if(val < -4) val = -4;
   if(val > 3)  val = 3;
d1991 5
a1995 3
   pSiS->tvyscale = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->tvyscale = val;
d1998 1
a1998 1
   if(pSiS->VGAEngine == SIS_315_VGA || pSiS->VGAEngine == SIS_315_VGA) {
d2000 10
a2009 1
      if((pSiS->VBFlags & CRT2_TV) && (pSiS->VBFlags & VB_SISBRIDGE)) {
d2011 1
a2011 2
	 int srindex = -1, newvde, i = 0, j, vlimit, temp;
	 unsigned char p3d4_34;
d2013 2
a2014 3
	 if(pSiS->VBFlags & TV_HIVISION) return;
         if((pSiS->VBFlags & TV_YPBPR) &&
            (pSiS->VBFlags & (TV_YPBPR1080I | TV_YPBPR750P | TV_YPBPR525P))) return;
a2015 2
	 if(pSiS->VBFlags & TV_YPBPR)                 usentsc = TRUE;
         else if(pSiS->VBFlags & (TV_NTSC | TV_PALM)) usentsc = TRUE;
d2017 4
a2020 1
	 vlimit = usentsc ? 259 : 309;
d2022 8
a2029 1
	 inSISIDXREG(SISCR,0x34,p3d4_34);
d2031 5
a2035 28
	 switch((p3d4_34 & 0x7f)) {
#if 0
	 case 0x50:   /* 320x240 - hdclk mode */
	 case 0x56:
	 case 0x53:
#endif
	 case 0x2e:   /* 640x480 */
	 case 0x44:
	 case 0x62:
	    srindex  = usentsc ? 0 : 21;
	    break;
	 case 0x31:   /* 720x480 */
	 case 0x33:
	 case 0x35:
	 case 0x32:   /* 720x576 */
	 case 0x34:
	 case 0x36:
	 case 0x5f:   /* 768x576 */
	 case 0x60:
	 case 0x61:
            if(pSiS->VGAEngine == SIS_315_VGA) {
	       srindex  = usentsc ? 7 : 28;
	    }
	    break;
#if 0
	 case 0x51:   /* 400x300 - hdclk mode */
	 case 0x57:
	 case 0x54:
a2036 98
	 case 0x30:   /* 800x600 */
	 case 0x47:
	 case 0x63:
	    srindex  = usentsc ? 14 : 35;
	 }

	 if(srindex >= 0) {
	    Bool found = FALSE;
	    if(pSiS->tvyscale != 0) {
	       for(j=0; j<=1; j++) {
	          for(i=0; i<=6; i++) {
	             if(SiSTVVScale[srindex+i].sindex == pSiS->tvyscale) {
		        found = TRUE;
		        break;
		     }
	          }
		  if(found) break;
	          if(pSiS->tvyscale > 0) pSiS->tvyscale--;
		  else pSiS->tvyscale++;
	       }
	    }
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->tvyscale = pSiS->tvyscale;
#endif
	    if(pSiS->tvyscale == 0) {
	       unsigned char p2_0a = pSiS->p2_0a;
	       unsigned char p2_2f = pSiS->p2_2f;
	       unsigned char p2_30 = pSiS->p2_30;
	       unsigned char p2_46 = pSiS->p2_46;
	       unsigned char p2_47 = pSiS->p2_47;
	       unsigned char p1scaling[9], p4scaling[9];
	       unsigned char *p2scaling;

	       for(i=0; i<9; i++) {
	          p1scaling[i] = pSiS->scalingp1[i];
	       }
	       for(i=0; i<9; i++) {
	          p4scaling[i] = pSiS->scalingp4[i];
	       }
	       p2scaling = &pSiS->scalingp2[0];
#ifdef SISDUALHEAD
               if(pSiSEnt && pSiS->DualHeadMode) {
	          p2_0a = pSiSEnt->p2_0a;
		  p2_2f = pSiSEnt->p2_2f;
	          p2_30 = pSiSEnt->p2_30;
		  p2_46 = pSiSEnt->p2_46;
		  p2_47 = pSiSEnt->p2_47;
	          for(i=0; i<9; i++) {
	             p1scaling[i] = pSiSEnt->scalingp1[i];
	          }
	          for(i=0; i<9; i++) {
	             p4scaling[i] = pSiSEnt->scalingp4[i];
	          }
		  p2scaling = &pSiSEnt->scalingp2[0];
	       }
#endif
               SISWaitRetraceCRT2(pScrn);
	       if(pSiS->VBFlags & (VB_301C|VB_302ELV)) {
	          for(i=0; i<64; i++) {
	             outSISIDXREG(SISPART2,(0xc0 + i),p2scaling[i]);
	          }
	       }
	       for(i=0; i<9; i++) {
	          outSISIDXREG(SISPART1,SiSScalingP1Regs[i],p1scaling[i]);
	       }
	       for(i=0; i<9; i++) {
	          outSISIDXREG(SISPART4,SiSScalingP4Regs[i],p4scaling[i]);
	       }

	       setSISIDXREG(SISPART2,0x0a,0x7f,(p2_0a & 0x80));
	       outSISIDXREG(SISPART2,0x2f,p2_2f);
	       setSISIDXREG(SISPART2,0x30,0x3f,(p2_30 & 0xc0));
	       if(!(pSiS->VBFlags & VB_301)) {
	          setSISIDXREG(SISPART2,0x46,0x9f,(p2_46 & 0x60));
		  outSISIDXREG(SISPART2,0x47,p2_47);
	       }

	    } else {

	       int so = (pSiS->VGAEngine == SIS_300_VGA) ? 12 : 0;
	       int realvde, j, srindex301c, myypos, watchdog = 32;
	       unsigned long calctemp;

	       srindex += i;
	       srindex301c = srindex * 64;
	       newvde = SiSTVVScale[srindex].ScaleVDE;
	       realvde = SiSTVVScale[srindex].RealVDE;

	       do {
	          inSISIDXREG(SISPART2,0x01,temp);
	          temp = vlimit - (temp & 0x7f);
	          if((temp - (((newvde >> 1) - 2) + 9)) > 0) break;
		  myypos = pSiS->tvypos - 1;
#ifdef SISDUALHEAD
		  if(pSiSEnt && pSiS->DualHeadMode) myypos = pSiSEnt->tvypos - 1;
#endif
		  SiS_SetTVyposoffset(pScrn, myypos);
	       } while(watchdog--);
d2038 26
a2063 59
	       SISWaitRetraceCRT2(pScrn);

	       if(pSiS->VBFlags & (VB_301C|VB_302ELV)) {
#ifdef TWDEBUG
		  xf86DrvMsg(0, X_INFO, "301C scaler: Table index %d\n");
#endif
	          for(j=0; j<64; j++) {
		     outSISIDXREG(SISPART2,(0xc0 + j), SiS301CScaling[srindex301c + j]);
		  }
	       }

	       if(!(pSiS->VBFlags & VB_301)) {
	          temp = (newvde >> 1) - 3;
	          setSISIDXREG(SISPART2,0x46,0x9f,((temp & 0x0300) >> 3));
	          outSISIDXREG(SISPART2,0x47,(temp & 0xff));
	       }
	       outSISIDXREG(SISPART1,0x08,(SiSTVVScale[srindex].reg[so+0] & 0xff));
	       setSISIDXREG(SISPART1,0x09,0x0f,((SiSTVVScale[srindex].reg[so+0] >> 4) & 0xf0));
	       outSISIDXREG(SISPART1,0x0b,(SiSTVVScale[srindex].reg[so+1] & 0xff));
	       setSISIDXREG(SISPART1,0x0c,0xf0,((SiSTVVScale[srindex].reg[so+1] >> 8) & 0x0f));
	       outSISIDXREG(SISPART1,0x0d,(SiSTVVScale[srindex].reg[so+2] & 0xff));
	       outSISIDXREG(SISPART1,0x0e,(SiSTVVScale[srindex].reg[so+3] & 0xff));
	       setSISIDXREG(SISPART1,0x12,0xf8,((SiSTVVScale[srindex].reg[so+3] >> 8 ) & 0x07));
	       outSISIDXREG(SISPART1,0x10,(SiSTVVScale[srindex].reg[so+4] & 0xff));
	       setSISIDXREG(SISPART1,0x11,0x8f,((SiSTVVScale[srindex].reg[so+4] >> 4) & 0x70));
	       setSISIDXREG(SISPART1,0x11,0xf0,(SiSTVVScale[srindex].reg[so+5] & 0x0f));

	       setSISIDXREG(SISPART2,0x0a,0x7f,((SiSTVVScale[srindex].reg[so+6] << 7) & 0x80));
	       outSISIDXREG(SISPART2,0x2f,((newvde / 2) - 2));
	       setSISIDXREG(SISPART2,0x30,0x3f,((((newvde / 2) - 2) >> 2) & 0xc0));

	       outSISIDXREG(SISPART4,0x13,(SiSTVVScale[srindex].reg[so+7] & 0xff));
	       outSISIDXREG(SISPART4,0x14,(SiSTVVScale[srindex].reg[so+8] & 0xff));
	       setSISIDXREG(SISPART4,0x15,0x7f,((SiSTVVScale[srindex].reg[so+8] >> 1) & 0x80));

	       outSISIDXREG(SISPART4,0x16,(SiSTVVScale[srindex].reg[so+9] & 0xff));
	       setSISIDXREG(SISPART4,0x15,0x87,((SiSTVVScale[srindex].reg[so+9] >> 5) & 0x78));

	       outSISIDXREG(SISPART4,0x17,(SiSTVVScale[srindex].reg[so+10] & 0xff));
	       setSISIDXREG(SISPART4,0x15,0xf8,((SiSTVVScale[srindex].reg[so+10] >> 8) & 0x07));

	       outSISIDXREG(SISPART4,0x18,(SiSTVVScale[srindex].reg[so+11] & 0xff));
	       setSISIDXREG(SISPART4,0x19,0xf0,((SiSTVVScale[srindex].reg[so+11] >> 8) & 0x0f));

               temp = 0x40;
	       if(realvde <= newvde) temp = 0;
	       else realvde -= newvde;

	       calctemp = (realvde * 256 * 1024) / newvde;
	       if((realvde * 256 * 1024) % newvde) calctemp++;
	       outSISIDXREG(SISPART4,0x1b,(calctemp & 0xff));
	       outSISIDXREG(SISPART4,0x1a,((calctemp >> 8) & 0xff));
	       setSISIDXREG(SISPART4,0x19,0x8f,(((calctemp >> 12) & 0x30) | temp));
	    }
	 }

      }

   }
a2065 5
int SiS_GetTVyscale(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
d2067 1
a2067 6
   if(pSiSEnt && pSiS->DualHeadMode)
        return (int)pSiSEnt->tvyscale;
   else
#endif
        return (int)pSiS->tvyscale;
}
d2069 1
a2069 9
/* PostSetMode:
 * -) Disable CRT1 for saving bandwidth. This doesn't work with VESA;
 *    VESA uses the bridge in SlaveMode and switching CRT1 off while
 *    the bridge is in SlaveMode not that clever...
 * -) Check if overlay can be used (depending on dotclock)
 * -) Check if Panel Scaler is active on LVDS for overlay re-scaling
 * -) Save TV registers for further processing
 * -) Apply TV settings
 */
d2071 1
a2071 1
SiSPostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d2073 4
a2076 16
    SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
    unsigned char usScratchCR17;
    Bool flag = FALSE;
    Bool doit = TRUE;
    int myclock, temp;
    unsigned char  sr2b, sr2c, tmpreg;
    float          num, denum, postscalar, divider;

#ifdef TWDEBUG
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
    	"CRT1off is %d\n", pSiS->CRT1off);
#endif
    pSiS->CRT1isoff = pSiS->CRT1off;
a2077 3
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d2079 1
a2079 1
    if((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_ENABLE)) {
d2081 6
a2086 5
	if(pSiS->VBFlags != pSiS->VBFlags_backup) {
	   pSiS->VBFlags = pSiS->VBFlags_backup;
	   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"VBFlags restored to %0lx\n", pSiS->VBFlags);
	}
d2088 15
a2102 20
	/* -) We can't switch off CRT1 if bridge is in SlaveMode.
	 * -) If we change to a SlaveMode-Mode (like 512x384), we
	 *    need to adapt VBFlags for eg. Xv.
	 */
#ifdef SISDUALHEAD
	if(!pSiS->DualHeadMode) {
#endif
	   if(SiSBridgeIsInSlaveMode(pScrn)) {
	      doit = FALSE;
	      temp = pSiS->VBFlags;
	      pSiS->VBFlags &= (~VB_DISPMODE_SINGLE);
	      pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_DISP1);
              if(temp != pSiS->VBFlags) {
		 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 	"VBFlags changed to 0x%0lx\n", pSiS->VBFlags);
	      }
	   }
#ifdef SISDUALHEAD
	}
#endif
d2104 1
a2104 1
	if(pSiS->VGAEngine == SIS_315_VGA) {
d2106 6
a2111 7
	   if((pSiS->CRT1off) && (doit)) {
	      orSISIDXREG(SISCR,pSiS->myCR63,0x40);
	      orSISIDXREG(SISSR,0x1f,0xc0);
	   } else {
	      andSISIDXREG(SISCR,pSiS->myCR63,0xBF);
	      andSISIDXREG(SISSR,0x1f,0x3f);
	   }
d2113 13
d2127 5
d2133 2
a2134 24
	   if(doit) {
              inSISIDXREG(SISCR, 0x17, usScratchCR17);
    	      if(pSiS->CRT1off) {
	         if(usScratchCR17 & 0x80) {
		    flag = TRUE;
		    usScratchCR17 &= ~0x80;
		 }
		 orSISIDXREG(SISSR,0x1f,0xc0);
    	      } else {
	         if(!(usScratchCR17 & 0x80)) {
		    flag = TRUE;
        	    usScratchCR17 |= 0x80;
		 }
		 andSISIDXREG(SISSR,0x1f,0x3f);
              }
	      /* Reset only if status changed */
	      if(flag) {
	         outSISIDXREG(SISCR, 0x17, usScratchCR17);
	         outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
	         usleep(10000);
                 outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */
	      }
	   }
	}
d2136 21
a2156 1
    }
d2158 13
a2170 51
    /* Determine if the video overlay can be used */
    if(!pSiS->NoXvideo) {
       inSISIDXREG(SISSR,0x2b,sr2b);
       inSISIDXREG(SISSR,0x2c,sr2c);
       divider = (sr2b & 0x80) ? 2.0 : 1.0;
       postscalar = (sr2c & 0x80) ?
              ( (((sr2c >> 5) & 0x03) == 0x02) ? 6.0 : 8.0 ) :
	      ( ((sr2c >> 5) & 0x03) + 1.0 );
       num = (sr2b & 0x7f) + 1.0;
       denum = (sr2c & 0x1f) + 1.0;
       myclock = (int)((14318 * (divider / postscalar) * (num / denum)) / 1000);

       pSiS->MiscFlags &= ~(MISC_CRT1OVERLAY | MISC_CRT1OVERLAYGAMMA);
       switch(pSiS->sishw_ext.jChipType) {
         case SIS_300:
         case SIS_540:
         case SIS_630:
         case SIS_730:
            if(myclock < 150) {
               pSiS->MiscFlags |= MISC_CRT1OVERLAY;
            }
            break;
         case SIS_550:
         case SIS_650:
         case SIS_740:
	    if(myclock < 175) {
               pSiS->MiscFlags |= MISC_CRT1OVERLAY;
	       if(myclock < 166) {
	          pSiS->MiscFlags |= MISC_CRT1OVERLAYGAMMA;
	       }
            }
            break;
	 case SIS_315H:
         case SIS_315:
         case SIS_315PRO:
         case SIS_330:
	 case SIS_661:
	 case SIS_741:
	 case SIS_660:
	 case SIS_760:
            if(myclock < 180) {
               pSiS->MiscFlags |= MISC_CRT1OVERLAY;
	       if(myclock < 166) {
	          pSiS->MiscFlags |= MISC_CRT1OVERLAYGAMMA;
	       }
            }
            break;
       }
       if(!(pSiS->MiscFlags & MISC_CRT1OVERLAY)) {
#ifdef SISDUALHEAD
          if((!pSiS->DualHeadMode) || (pSiS->SecondHead))
a2171 5
             xf86DrvMsgVerb(pScrn->scrnIndex, X_WARNING, 3,
	     	"Current dotclock (%dMhz) too high for video overlay on CRT1\n",
		myclock);
       }
    }
d2173 29
a2201 17
    /* Determine if the Panel Link scaler is active */
    pSiS->MiscFlags &= ~MISC_PANELLINKSCALER;
    if(pSiS->VBFlags & (CRT2_LCD | CRT1_LCDA)) {
       if(pSiS->VGAEngine == SIS_300_VGA) {
          if(pSiS->VBFlags & (VB_LVDS | VB_30xBDH)) {
	     inSISIDXREG(SISPART1,0x1e,tmpreg);
	     tmpreg &= 0x3f;
	     if(tmpreg) pSiS->MiscFlags |= MISC_PANELLINKSCALER;
	  }
       } else {
          if(pSiS->VBFlags & (VB_LVDS | VB_30xBDH | CRT1_LCDA)) {
	     inSISIDXREG(SISPART1,0x35,tmpreg);
	     tmpreg &= 0x04;
	     if(!tmpreg) pSiS->MiscFlags |= MISC_PANELLINKSCALER;
	  }
       }
    }
d2203 9
a2211 12
    /* Determine if our very special TV mode is active */
    pSiS->MiscFlags &= ~MISC_TVNTSC1024;
    if((pSiS->VBFlags & VB_SISBRIDGE) && (pSiS->VBFlags & CRT2_TV) && (!(pSiS->VBFlags & TV_HIVISION))) {
       if( ((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR525I)) ||
           ((!(pSiS->VBFlags & TV_YPBPR)) && (pSiS->VBFlags & (TV_NTSC | TV_PALM))) ) {
          inSISIDXREG(SISCR,0x34,tmpreg);
	  tmpreg &= 0x7f;
	  if((tmpreg == 0x64) || (tmpreg == 0x4a) || (tmpreg == 0x38)) {
	     pSiS->MiscFlags |= MISC_TVNTSC1024;
	  }
       }
    }
d2213 42
a2254 14
#ifdef SISVRAMQ
    if(pSiS->VGAEngine == SIS_315_VGA) {
       int i;
       /* Re-Enable command queue */
       SiSEnableTurboQueue(pScrn);
       /* Get HWCursor register contents for backup */
       for(i = 0; i < 16; i++) {
          pSiS->HWCursorBackup[i] = MMIO_IN32(pSiS->IOBase, 0x8500 + (i << 2));
       }
       if(pSiS->sishw_ext.jChipType >= SIS_330) {
          /* Enable HWCursor protection (Y pos as trigger) */
          andSISIDXREG(SISCR, 0x5b, ~0x30);
       }
    }
d2256 15
a2270 4

    /* Reset XV gamma correction */
    if(pSiS->ResetXvGamma) {
       (pSiS->ResetXvGamma)(pScrn);
d2272 5
a2276 6

    /*  Apply TV settings given by options
           Do this even in DualHeadMode:
	   - if this is called by SetModeCRT1, CRT2 mode has been reset by SetModeCRT1
	   - if this is called by SetModeCRT2, CRT2 mode has changed (duh!)
	   -> Hence, in both cases, the settings must be re-applied.
d2278 24
a2301 215
    if(pSiS->VBFlags & CRT2_TV) {
       int val;
       if(pSiS->VBFlags & VB_CHRONTEL) {
          int mychtvlumabandwidthcvbs = pSiS->chtvlumabandwidthcvbs;
	  int mychtvlumabandwidthsvideo = pSiS->chtvlumabandwidthsvideo;
	  int mychtvlumaflickerfilter = pSiS->chtvlumaflickerfilter;
	  int mychtvchromabandwidth = pSiS->chtvchromabandwidth;
	  int mychtvchromaflickerfilter = pSiS->chtvchromaflickerfilter;
	  int mychtvcvbscolor = pSiS->chtvcvbscolor;
	  int mychtvtextenhance = pSiS->chtvtextenhance;
	  int mychtvcontrast = pSiS->chtvcontrast;
	  int mytvxpos = pSiS->tvxpos;
	  int mytvypos = pSiS->tvypos;
#ifdef SISDUALHEAD
	  if(pSiSEnt && pSiS->DualHeadMode) {
	     mychtvlumabandwidthcvbs = pSiSEnt->chtvlumabandwidthcvbs;
	     mychtvlumabandwidthsvideo = pSiSEnt->chtvlumabandwidthsvideo;
	     mychtvlumaflickerfilter = pSiSEnt->chtvlumaflickerfilter;
	     mychtvchromabandwidth = pSiSEnt->chtvchromabandwidth;
	     mychtvchromaflickerfilter = pSiSEnt->chtvchromaflickerfilter;
	     mychtvcvbscolor = pSiSEnt->chtvcvbscolor;
	     mychtvtextenhance = pSiSEnt->chtvtextenhance;
	     mychtvcontrast = pSiSEnt->chtvcontrast;
	     mytvxpos = pSiSEnt->tvxpos;
	     mytvypos = pSiSEnt->tvypos;
	  }
#endif	  
	  if((val = mychtvlumabandwidthcvbs) != -1) {
	     SiS_SetCHTVlumabandwidthcvbs(pScrn, val);
	  }
	  if((val = mychtvlumabandwidthsvideo) != -1) {
	     SiS_SetCHTVlumabandwidthsvideo(pScrn, val);
	  }
	  if((val = mychtvlumaflickerfilter) != -1) {
	     SiS_SetCHTVlumaflickerfilter(pScrn, val);
	  }
	  if((val = mychtvchromabandwidth) != -1) {
	     SiS_SetCHTVchromabandwidth(pScrn, val);      
	  }
	  if((val = mychtvchromaflickerfilter) != -1) {
	     SiS_SetCHTVchromaflickerfilter(pScrn, val);
	  }
	  if((val = mychtvcvbscolor) != -1) {
	     SiS_SetCHTVcvbscolor(pScrn, val);
	  }
	  if((val = mychtvtextenhance) != -1) {
	     SiS_SetCHTVtextenhance(pScrn, val);
	  }
	  if((val = mychtvcontrast) != -1) {
	     SiS_SetCHTVcontrast(pScrn, val);
	  }
	  /* Backup default TV position registers */
	  switch(pSiS->ChrontelType) {
	  case CHRONTEL_700x:
	     pSiS->tvx = SiS_GetCH700x(pSiS->SiS_Pr, 0x0a);
	     pSiS->tvx |= (((SiS_GetCH700x(pSiS->SiS_Pr, 0x08) & 0x02) >> 1) << 8);
	     pSiS->tvy = SiS_GetCH700x(pSiS->SiS_Pr, 0x0b);
	     pSiS->tvy |= ((SiS_GetCH700x(pSiS->SiS_Pr, 0x08) & 0x01) << 8);
#ifdef SISDUALHEAD
	     if(pSiSEnt) {
	        pSiSEnt->tvx = pSiS->tvx;
		pSiSEnt->tvy = pSiS->tvy;
	     }
#endif
	     break;
	  case CHRONTEL_701x:
	     /* Not supported by hardware */
	     break;
	  }
	  if((val = mytvxpos) != 0) {
	     SiS_SetTVxposoffset(pScrn, val);
	  }
	  if((val = mytvypos) != 0) {
	     SiS_SetTVyposoffset(pScrn, val);
	  }
       }
       if(pSiS->VBFlags & VB_301) {
          int mysistvedgeenhance = pSiS->sistvedgeenhance;
#ifdef SISDUALHEAD
          if(pSiSEnt && pSiS->DualHeadMode) {
	     mysistvedgeenhance = pSiSEnt->sistvedgeenhance;
	  }
#endif
          if((val = mysistvedgeenhance) != -1) {
	     SiS_SetSISTVedgeenhance(pScrn, val);
	  }
       }
       if(pSiS->VBFlags & VB_SISBRIDGE) {
          int mysistvantiflicker = pSiS->sistvantiflicker;
	  int mysistvsaturation = pSiS->sistvsaturation;
	  int mysistvcolcalibf = pSiS->sistvcolcalibf;
	  int mysistvcolcalibc = pSiS->sistvcolcalibc;
	  int mysistvcfilter = pSiS->sistvcfilter;
	  int mysistvyfilter = pSiS->sistvyfilter;
	  int mytvxpos = pSiS->tvxpos;
	  int mytvypos = pSiS->tvypos;
	  int mytvxscale = pSiS->tvxscale;
	  int mytvyscale = pSiS->tvyscale;
	  int i;
	  unsigned long cbase;
	  unsigned char ctemp;
#ifdef SISDUALHEAD
          if(pSiSEnt && pSiS->DualHeadMode) {
	     mysistvantiflicker = pSiSEnt->sistvantiflicker;
	     mysistvsaturation = pSiSEnt->sistvsaturation;
	     mysistvcolcalibf = pSiSEnt->sistvcolcalibf;
	     mysistvcolcalibc = pSiSEnt->sistvcolcalibc;
	     mysistvcfilter = pSiSEnt->sistvcfilter;
	     mysistvyfilter = pSiSEnt->sistvyfilter;
	     mytvxpos = pSiSEnt->tvxpos;
	     mytvypos = pSiSEnt->tvypos;
	     mytvxscale = pSiSEnt->tvxscale;
	     mytvyscale = pSiSEnt->tvyscale;
	  }
#endif
          /* Backup default TV position, scale and colcalib registers */
	  inSISIDXREG(SISPART2,0x1f,pSiS->p2_1f);
	  inSISIDXREG(SISPART2,0x20,pSiS->p2_20);
	  inSISIDXREG(SISPART2,0x01,pSiS->p2_01);
	  inSISIDXREG(SISPART2,0x02,pSiS->p2_02);
	  inSISIDXREG(SISPART2,0x44,pSiS->p2_44);
	  inSISIDXREG(SISPART2,0x45,pSiS->p2_45);
	  if(!(pSiS->VBFlags & VB_301)) {
	     inSISIDXREG(SISPART2,0x46,pSiS->p2_46);
	  } else {
	     pSiS->p2_46 = 0;
	  }
	  inSISIDXREG(SISPART2,0x0a,pSiS->p2_0a);
	  inSISIDXREG(SISPART2,0x31,cbase);
	  cbase = (cbase & 0x7f) << 8;
	  inSISIDXREG(SISPART2,0x32,ctemp);
	  cbase = (cbase | ctemp) << 8;
	  inSISIDXREG(SISPART2,0x33,ctemp);
	  cbase = (cbase | ctemp) << 8;
	  inSISIDXREG(SISPART2,0x34,ctemp);
	  pSiS->sistvccbase = (cbase | ctemp);
	  inSISIDXREG(SISPART2,0x35,pSiS->p2_35);
	  inSISIDXREG(SISPART2,0x36,pSiS->p2_36);
	  inSISIDXREG(SISPART2,0x37,pSiS->p2_37);
	  inSISIDXREG(SISPART2,0x38,pSiS->p2_38);
	  if(!(pSiS->VBFlags & VB_301)) {
	     inSISIDXREG(SISPART2,0x47,pSiS->p2_47);
	     inSISIDXREG(SISPART2,0x48,pSiS->p2_48);
	     inSISIDXREG(SISPART2,0x49,pSiS->p2_49);
	     inSISIDXREG(SISPART2,0x4a,pSiS->p2_4a);
	  }
	  inSISIDXREG(SISPART2,0x2f,pSiS->p2_2f);
	  inSISIDXREG(SISPART2,0x30,pSiS->p2_30);
	  for(i=0; i<9; i++) {
	     inSISIDXREG(SISPART1,SiSScalingP1Regs[i],pSiS->scalingp1[i]);
	  }
	  for(i=0; i<9; i++) {
	     inSISIDXREG(SISPART4,SiSScalingP4Regs[i],pSiS->scalingp4[i]);
	  }
	  if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
	     for(i=0; i<64; i++) {
	        inSISIDXREG(SISPART2,(0xc0 + i),pSiS->scalingp2[i]);
  	     }
	  }
#ifdef SISDUALHEAD
	  if(pSiSEnt) {
	     pSiSEnt->p2_1f = pSiS->p2_1f; pSiSEnt->p2_20 = pSiS->p2_20;
	     pSiSEnt->p2_01 = pSiS->p2_01; pSiSEnt->p2_02 = pSiS->p2_02;
	     pSiSEnt->p2_44 = pSiS->p2_44; pSiSEnt->p2_45 = pSiS->p2_45;
	     pSiSEnt->p2_46 = pSiS->p2_46; pSiSEnt->p2_0a = pSiS->p2_0a;
	     pSiSEnt->sistvccbase = pSiS->sistvccbase;
	     pSiSEnt->p2_35 = pSiS->p2_35; pSiSEnt->p2_36 = pSiS->p2_36;
	     pSiSEnt->p2_37 = pSiS->p2_37; pSiSEnt->p2_38 = pSiS->p2_38;
	     pSiSEnt->p2_48 = pSiS->p2_48; pSiSEnt->p2_49 = pSiS->p2_49;
	     pSiSEnt->p2_4a = pSiS->p2_4a; pSiSEnt->p2_2f = pSiS->p2_2f;
	     pSiSEnt->p2_30 = pSiS->p2_30; pSiSEnt->p2_47 = pSiS->p2_47;
	     for(i=0; i<9; i++) {
	        pSiSEnt->scalingp1[i] = pSiS->scalingp1[i];
	     }
	     for(i=0; i<9; i++) {
	        pSiSEnt->scalingp4[i] = pSiS->scalingp4[i];
	     }
	     if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
	        for(i=0; i<64; i++) {
	           pSiSEnt->scalingp2[i] = pSiS->scalingp2[i];
  	        }
	     }
	  }
#endif
          if((val = mysistvantiflicker) != -1) {
	     SiS_SetSISTVantiflicker(pScrn, val);
	  }
	  if((val = mysistvsaturation) != -1) {
	     SiS_SetSISTVsaturation(pScrn, val);
	  }
	  if((val = mysistvcfilter) != -1) {
	     SiS_SetSISTVcfilter(pScrn, val);
	  }
	  if((val = mysistvyfilter) != 1) {
	     SiS_SetSISTVyfilter(pScrn, val);
	  }
	  if((val = mysistvcolcalibc) != 0) {
	     SiS_SetSISTVcolcalib(pScrn, val, TRUE);
	  }
	  if((val = mysistvcolcalibf) != 0) {
	     SiS_SetSISTVcolcalib(pScrn, val, FALSE);
	  }
	  if((val = mytvxpos) != 0) {
	     SiS_SetTVxposoffset(pScrn, val);
	  }
	  if((val = mytvypos) != 0) {
	     SiS_SetTVyposoffset(pScrn, val);
	  }
	  if((val = mytvxscale) != 0) {
	     SiS_SetTVxscale(pScrn, val);
	  }
	  if((val = mytvyscale) != 0) {
	     SiS_SetTVyscale(pScrn, val);
	  }
       }
d2303 3
a2305 1

d2308 2
a2309 3
/* Post-set SiS6326 TV registers */
static void
SiS6326PostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d2311 1
d2313 2
a2314 2
    unsigned char tmp;
    int val;
d2316 3
a2318 1
    if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
d2320 3
a2322 3
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d2324 1
a2324 17
    /* Backup default TV position registers */
    pSiS->tvx1 = SiS6326GetTVReg(pScrn,0x3a);
    pSiS->tvx1 |= ((SiS6326GetTVReg(pScrn,0x3c) & 0x0f) << 8);
    pSiS->tvx2 = SiS6326GetTVReg(pScrn,0x26);
    pSiS->tvx2 |= ((SiS6326GetTVReg(pScrn,0x27) & 0xf0) << 4);
    pSiS->tvx3 = SiS6326GetTVReg(pScrn,0x12);
    pSiS->tvx3 |= ((SiS6326GetTVReg(pScrn,0x13) & 0xC0) << 2);
    pSiS->tvy1 = SiS6326GetTVReg(pScrn,0x11);
    pSiS->tvy1 |= ((SiS6326GetTVReg(pScrn,0x13) & 0x30) << 4);
    
    /* Handle TVPosOffset options (BEFORE switching on TV) */
    if((val = pSiS->tvxpos) != 0) {
       SiS_SetTVxposoffset(pScrn, val);
    }
    if((val = pSiS->tvypos) != 0) {
       SiS_SetTVyposoffset(pScrn, val);
    }
d2326 2
a2327 26
    /* Switch on TV output. This is rather complicated, but
     * if we don't do it, TV output will flicker terribly.
     */
    if(pSiS->SiS6326Flags & SIS6326_TVON) {
       orSISIDXREG(SISSR, 0x01, 0x20);
       tmp = SiS6326GetTVReg(pScrn,0x00);
       tmp &= ~0x04;
       while(!(inSISREG(SISINPSTAT) & 0x08));    /* Wait while NOT vb */
       SiS6326SetTVReg(pScrn,0x00,tmp);
       for(val=0; val < 2; val++) {
         while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
         while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
       }
       SiS6326SetTVReg(pScrn, 0x00, sisReg->sis6326tv[0]);
       tmp = inSISREG(SISINPSTAT);
       outSISREG(SISAR, 0x20);
       tmp = inSISREG(SISINPSTAT);
       while(inSISREG(SISINPSTAT) & 0x01);
       while(!(inSISREG(SISINPSTAT) & 0x01));
       andSISIDXREG(SISSR, 0x01, ~0x20);
       for(val=0; val < 10; val++) {
         while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
         while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
       }
       andSISIDXREG(SISSR, 0x01, ~0x20);
    }
d2329 5
a2333 2
    tmp = SiS6326GetTVReg(pScrn,0x00);
    if(!(tmp & 0x04)) return;
d2335 2
a2336 10
    /* Apply TV settings given by options */
    if((val = pSiS->sistvantiflicker) != -1) {
       SiS_SetSIS6326TVantiflicker(pScrn, val);
    }
    if((val = pSiS->sis6326enableyfilter) != -1) {
       SiS_SetSIS6326TVenableyfilter(pScrn, val);
    }
    if((val = pSiS->sis6326yfilterstrong) != -1) {
       SiS_SetSIS6326TVyfilterstrong(pScrn, val);
    }
d2338 3
a2342 19
/* Check if video bridge is in slave mode */
BOOLEAN
SiSBridgeIsInSlaveMode(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char usScratchP1_00;

    if(!(pSiS->VBFlags & VB_VIDEOBRIDGE)) return FALSE;

    inSISIDXREG(SISPART1,0x00,usScratchP1_00);
    if( ((pSiS->VGAEngine == SIS_300_VGA) && (usScratchP1_00 & 0xa0) == 0x20) ||
        ((pSiS->VGAEngine == SIS_315_VGA) && (usScratchP1_00 & 0x50) == 0x10) ) {
	   return TRUE;
    } else {
           return FALSE;
    }
}

/* Build a list of the VESA modes the BIOS reports as valid */
a2345 1
    SISPtr pSiS = SISPTR(pScrn);
d2347 1
a2347 2

    while(vbe->VideoModePtr[i] != 0xffff) {
d2353 1
a2353 1
	if((mode = VBEGetModeInfo(pVbe, id)) == NULL)
d2357 3
d2366 1
a2366 1
	m->next = pSiS->SISVESAModeList;
d2369 1
a2369 1
	      "BIOS supports VESA mode 0x%x: x:%i y:%i bpp:%i\n",
d2372 1
a2372 1
	pSiS->SISVESAModeList = m;
d2378 1
a2378 3
/* Calc VESA mode from given resolution/depth */
static UShort
SiSCalcVESAModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode)
d2380 2
a2381 3
    SISPtr pSiS = SISPTR(pScrn);
    sisModeInfoPtr m = pSiS->SISVESAModeList;
    UShort i = (pScrn->bitsPerPixel+7)/8 - 1;
d2384 4
a2387 4
    while(m) {
	if(pScrn->bitsPerPixel == m->bpp &&
	   mode->HDisplay == m->width &&
	   mode->VDisplay == m->height)
d2396 4
a2399 10
    switch(mode->HDisplay) {
      case 320:
          if(mode->VDisplay == 200)
             ModeIndex = VESAModeIndex_320x200[i];
	  else if(mode->VDisplay == 240)
             ModeIndex = VESAModeIndex_320x240[i];
          break;
      case 400:
          if(mode->VDisplay == 300)
             ModeIndex = VESAModeIndex_400x300[i];
d2401 1
a2401 5
      case 512:
          if(mode->VDisplay == 384)
             ModeIndex = VESAModeIndex_512x384[i];
          break;
      case 640:
d2403 3
a2405 3
             ModeIndex = VESAModeIndex_640x480[i];
	  else if(mode->VDisplay == 400)
             ModeIndex = VESAModeIndex_640x400[i];
d2407 2
a2408 3
      case 800:
          if(mode->VDisplay == 600)
             ModeIndex = VESAModeIndex_800x600[i];
d2410 2
a2411 3
      case 1024:
          if(mode->VDisplay == 768)
             ModeIndex = VESAModeIndex_1024x768[i];
d2413 2
a2414 3
      case 1280:
          if(mode->VDisplay == 1024)
             ModeIndex = VESAModeIndex_1280x1024[i];
d2416 2
a2417 3
      case 1600:
          if(mode->VDisplay == 1200)
             ModeIndex = VESAModeIndex_1600x1200[i];
d2419 2
a2420 3
      case 1920:
          if(mode->VDisplay == 1440)
             ModeIndex = VESAModeIndex_1920x1440[i];
d2424 2
a2425 2
   if(!ModeIndex) xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
        "No valid mode found for %dx%dx%d in built-in table either.\n",
d2431 6
a2436 94
USHORT
SiS_CalcModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode, unsigned long VBFlags, BOOLEAN havecustommodes)
{
   SISPtr pSiS = SISPTR(pScrn);
   UShort i = (pSiS->CurrentLayout.bitsPerPixel+7)/8 - 1;

   if(!(VBFlags & CRT1_LCDA)) {
      if((havecustommodes) && (!(mode->type & M_T_DEFAULT))) {
         return 0xfe;
      }
   } else {
      if((mode->HDisplay > pSiS->LCDwidth) ||
         (mode->VDisplay > pSiS->LCDheight)) {
	 return 0;
      }
   }

   return(SiS_GetModeID(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i, pSiS->FSTN));
}

USHORT
SiS_CheckCalcModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode, unsigned long VBFlags, BOOLEAN havecustommodes)
{
   SISPtr pSiS = SISPTR(pScrn);
   UShort i = (pSiS->CurrentLayout.bitsPerPixel+7)/8 - 1;
   UShort ModeIndex = 0;
   int    j;

#ifdef TWDEBUG
   xf86DrvMsg(0, X_INFO, "Inside CheckCalcModeIndex (VBFlags %x, mode %dx%d)\n",
   	VBFlags,mode->HDisplay, mode->VDisplay);
#endif

   if(VBFlags & CRT2_LCD) {			/* CRT2 is LCD */

      if(pSiS->SiS_Pr->CP_HaveCustomData) {
         for(j=0; j<7; j++) {
            if((pSiS->SiS_Pr->CP_DataValid[j]) &&
               (mode->HDisplay == pSiS->SiS_Pr->CP_HDisplay[j]) &&
               (mode->VDisplay == pSiS->SiS_Pr->CP_VDisplay[j]) &&
               (mode->type & M_T_BUILTIN))
               return 0xfe;
	 }
      }

      if((pSiS->AddedPlasmaModes) && (mode->type & M_T_BUILTIN))
         return 0xfe;

      if((havecustommodes) &&
         (pSiS->LCDwidth) &&		/* = test if LCD present */
         (!(mode->type & M_T_DEFAULT)) &&
	 (!(mode->Flags & V_INTERLACE)))
         return 0xfe;

      if( ((mode->HDisplay <= pSiS->LCDwidth) &&
           (mode->VDisplay <= pSiS->LCDheight)) ||
	  ((pSiS->SiS_Pr->SiS_CustomT == CUT_PANEL848) &&
	   (((mode->HDisplay == 1360) && (mode->HDisplay == 768)) ||
	    ((mode->HDisplay == 1024) && (mode->HDisplay == 768)) ||
	    ((mode->HDisplay ==  800) && (mode->HDisplay == 600)))) ) {

         ModeIndex = SiS_GetModeID_LCD(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i,
	 			       pSiS->FSTN, pSiS->SiS_Pr->SiS_CustomT, pSiS->LCDwidth, pSiS->LCDheight);

      }

   } else if(VBFlags & CRT2_TV) {		/* CRT2 is TV */

      ModeIndex = SiS_GetModeID_TV(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i);

   } else if(VBFlags & CRT2_VGA) {		/* CRT2 is VGA2 */

      if((pSiS->AddedPlasmaModes) && (mode->type & M_T_BUILTIN))
	 return 0xfe;

      if((havecustommodes) &&
	 (!(mode->type & M_T_DEFAULT)) &&
	 (!(mode->Flags & V_INTERLACE)))
         return 0xfe;

      ModeIndex = SiS_GetModeID_VGA2(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i);

   } else {					/* CRT1 only, no CRT2 */

      ModeIndex = SiS_CalcModeIndex(pScrn, mode, VBFlags, havecustommodes);

   }

   return(ModeIndex);
}

/* Calculate the vertical refresh rate from a mode */
int
SiSCalcVRate(DisplayModePtr mode)
d2439 4
d2444 1
a2444 1
   if(mode->HSync > 0.0)
d2446 1
a2446 1
   else if(mode->HTotal > 0)
d2450 1
a2450 2

   if(mode->VTotal > 0)
d2452 1
a2452 2

   if(mode->Flags & V_INTERLACE)
d2454 2
a2455 2

   if(mode->Flags & V_DBLSCAN)
d2457 2
a2458 2

   if(mode->VScan > 1)
d2460 2
a2461 2

   if(mode->VRefresh > 0.0)
d2463 18
a2480 78

   if(hsync == 0 || refresh == 0) return(0);

   return((int)(refresh));
}

/* Calculate CR33 (rate index) for CRT1.
 * Calculation is done using currentmode, therefore it is
 * recommended to set VertRefresh and HorizSync to correct
 * values in config file.
 */
unsigned char
SISSearchCRT1Rate(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
   SISPtr         pSiS = SISPTR(pScrn);
   int            i = 0;
   int            irefresh;
   unsigned short xres = mode->HDisplay;
   unsigned short yres = mode->VDisplay;
   unsigned char  index;
   BOOLEAN	  checksis730 = FALSE;

   irefresh = SiSCalcVRate(mode);
   if(!irefresh) {
      if(xres == 800 || xres == 1024 || xres == 1280) return 0x02;
      else return 0x01;
   }
   
   /* SiS730 has troubles on CRT2 if CRT1 is at 32bpp */
   if( (pSiS->sishw_ext.jChipType == SIS_730) && 
       (pSiS->VBFlags & VB_VIDEOBRIDGE) &&
       (pSiS->CurrentLayout.bitsPerPixel == 32) ) {
#ifdef SISDUALHEAD   
      if(pSiS->DualHeadMode) {
         if(pSiS->SecondHead) {
	    checksis730 = TRUE;
	 }
      } else
#endif      
      if((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_ENABLE) && (!pSiS->CRT1off)) {
         checksis730 = TRUE;
      }
   }   
   
#ifdef TWDEBUG
   xf86DrvMsg(0, X_INFO, "Debug: CalcVRate returned %d\n", irefresh);
#endif    

   /* We need the REAL refresh rate here */
   if(mode->Flags & V_INTERLACE)
       	irefresh /= 2;

   /* Do not multiply by 2 when DBLSCAN! */
   
#ifdef TWDEBUG 
   xf86DrvMsg(0, X_INFO, "Debug: Rate after correction = %d\n", irefresh);
#endif

   index = 0;
   while((sisx_vrate[i].idx != 0) && (sisx_vrate[i].xres <= xres)) {
	if((sisx_vrate[i].xres == xres) && (sisx_vrate[i].yres == yres)) {
	    if((checksis730 == FALSE) || (sisx_vrate[i].SiS730valid32bpp == TRUE)) {
	       if(sisx_vrate[i].refresh == irefresh) {
		   index = sisx_vrate[i].idx;
		   break;
	       } else if(sisx_vrate[i].refresh > irefresh) {
		   if((sisx_vrate[i].refresh - irefresh) <= 3) {
		      index = sisx_vrate[i].idx;
		   } else if( ((checksis730 == FALSE) || (sisx_vrate[i - 1].SiS730valid32bpp == TRUE)) && 
		              ((irefresh - sisx_vrate[i - 1].refresh) <=  2) &&
			      (sisx_vrate[i].idx != 1) ) {
		      index = sisx_vrate[i - 1].idx;
		   }
		   break;
	       } else if((irefresh - sisx_vrate[i].refresh) <= 2) {
	           index = sisx_vrate[i].idx;
		   break;
	       }
d2484 2
a2485 2
   }
   if(index > 0)
d2487 2
a2488 88
   else {
        /* Default Rate index */
        if(xres == 800 || xres == 1024 || xres == 1280) return 0x02; 
   	else return 0x01;
   }
}

void
SISWaitRetraceCRT1(ScrnInfoPtr pScrn)
{
   SISPtr        pSiS = SISPTR(pScrn);
   int           watchdog;
   unsigned char temp;

   inSISIDXREG(SISCR,0x17,temp);
   if(!(temp & 0x80)) return;

   inSISIDXREG(SISSR,0x1f,temp);
   if(temp & 0xc0) return;

   watchdog = 65536;
   while((inSISREG(SISINPSTAT) & 0x08) && --watchdog);
   watchdog = 65536;
   while((!(inSISREG(SISINPSTAT) & 0x08)) && --watchdog);
}

void
SISWaitRetraceCRT2(ScrnInfoPtr pScrn)
{
   SISPtr        pSiS = SISPTR(pScrn);
   int           watchdog;
   unsigned char temp, reg;

   if(SiSBridgeIsInSlaveMode(pScrn)) {
      SISWaitRetraceCRT1(pScrn);
      return;
   }

   switch(pSiS->VGAEngine) {
   case SIS_300_VGA:
   	reg = 0x25;
	break;
   case SIS_315_VGA:
   	reg = 0x30;
	break;
   default:
        return;
   }

   watchdog = 65536;
   do {
   	inSISIDXREG(SISPART1, reg, temp);
	if(!(temp & 0x02)) break;
   } while(--watchdog);
   watchdog = 65536;
   do {
   	inSISIDXREG(SISPART1, reg, temp);
	if(temp & 0x02) break;
   } while(--watchdog);
}

static void
SISWaitVBRetrace(ScrnInfoPtr pScrn)
{
   SISPtr  pSiS = SISPTR(pScrn);

   if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
#ifdef SISDUALHEAD
      if(pSiS->DualHeadMode) {
   	 if(pSiS->SecondHead)
	    SISWaitRetraceCRT1(pScrn);
         else
	    SISWaitRetraceCRT2(pScrn);
      } else {
#endif
	 if(pSiS->VBFlags & DISPTYPE_DISP1) {
	    SISWaitRetraceCRT1(pScrn);
	 }
	 if(pSiS->VBFlags & DISPTYPE_DISP2) {
	    if(!(SiSBridgeIsInSlaveMode(pScrn))) {
	       SISWaitRetraceCRT2(pScrn);
	    }
	 }
#ifdef SISDUALHEAD
      }
#endif
   } else {
      SISWaitRetraceCRT1(pScrn);
a2489 101
}

#define MODEID_OFF 0x449

unsigned char
SiS_GetSetModeID(ScrnInfoPtr pScrn, unsigned char id)
{
    return(SiS_GetSetBIOSScratch(pScrn, MODEID_OFF, id));
}

unsigned char
SiS_GetSetBIOSScratch(ScrnInfoPtr pScrn, USHORT offset, unsigned char value)
{
    unsigned char ret;
    unsigned char *base;

    base = xf86MapVidMem(pScrn->scrnIndex, VIDMEM_MMIO, 0, 0x2000);
    if(!base) {
       SISErrorLog(pScrn, "(Could not map BIOS scratch area)\n");
       return 0;
    }

    ret = *(base + offset);

    /* value != 0xff means: set register */
    if(value != 0xff)
       *(base + offset) = value;

    xf86UnMapVidMem(pScrn->scrnIndex, base, 0x2000);

    return ret;
}

void
sisSaveUnlockExtRegisterLock(SISPtr pSiS, unsigned char *reg1, unsigned char *reg2)
{
    register unsigned char val;
    unsigned long mylockcalls;

    pSiS->lockcalls++;
    mylockcalls = pSiS->lockcalls;

    /* check if already unlocked */
    inSISIDXREG(SISSR, 0x05, val);
    if(val != 0xa1) {
       /* save State */
       if(reg1) *reg1 = val;
       /* unlock */
       outSISIDXREG(SISSR, 0x05, 0x86);
       inSISIDXREG(SISSR, 0x05, val);
       if(val != 0xA1) {
#ifdef TWDEBUG
	  unsigned char val1, val2;
	  int i;
#endif
          SISErrorLog(pSiS->pScrn,
               "Failed to unlock sr registers (%p, %lx, 0x%02x; %ld)\n",
	       (void *)pSiS, (unsigned long)pSiS->RelIO, val, mylockcalls);
#ifdef TWDEBUG
          for(i = 0; i <= 0x3f; i++) {
	  	inSISIDXREG(SISSR, i, val1);
		inSISIDXREG(0x3c4, i, val2);
		xf86DrvMsg(pSiS->pScrn->scrnIndex, X_INFO,
			"SR%02d: RelIO=0x%02x 0x3c4=0x%02x (%d)\n",
			i, val1, val2, mylockcalls);
	  }
#endif
          if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
	     /* Emergency measure: unlock at 0x3c4, and try to enable Relocated IO ports */
	     outSISIDXREG(0x3c4,0x05,0x86);
	     andSISIDXREG(0x3c4,0x33,~0x20);
	     outSISIDXREG(SISSR, 0x05, 0x86);
          }
       }
    }
    if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
       inSISIDXREG(SISCR, 0x80, val);
       if(val != 0xa1) {
          /* save State */
          if(reg2) *reg2 = val;
          outSISIDXREG(SISCR, 0x80, 0x86);
	  inSISIDXREG(SISCR, 0x80, val);
	  if(val != 0xA1) {
	     SISErrorLog(pSiS->pScrn,
	        "Failed to unlock cr registers (%p, %lx, 0x%02x)\n",
	       (void *)pSiS, (unsigned long)pSiS->RelIO, val);
	  }
       }
    }
}

void
sisRestoreExtRegisterLock(SISPtr pSiS, unsigned char reg1, unsigned char reg2)
{
    /* restore lock */
#ifndef UNLOCK_ALWAYS
    outSISIDXREG(SISSR, 0x05, reg1 == 0xA1 ? 0x86 : 0x00);
    if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
       outSISIDXREG(SISCR, 0x80, reg2 == 0xA1 ? 0x86 : 0x00);
    }
#endif
@


1.1.9.2
log
@Import XFree86 4.4 from The XFree86(TM) Project, Inc.
(integrity cannot be checked)

got via cvs -qd anoncvs@@anoncvs.xfree86.org:/cvs co -Prxf-4_4_0 xc
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_driver.c,v 1.185 2004/02/27 17:29:24 twini Exp $ */
d15 4
a18 1
 * 3) The name of the author may not be used to endorse or promote products
d159 1
a159 1
    { PCI_CHIP_SIS660,      "SIS660/661FX/M661FX/M661MX/741/741GX/M741/760/M760" },
a2572 1
		pSiS->mmioSize = 128;
a2580 1
		pSiS->mmioSize = 128;
a2585 1
		pSiS->mmioSize = 128;
a2592 1
		pSiS->mmioSize = 128;
a2601 1
		pSiS->mmioSize = 128;
a2610 1
		pSiS->mmioSize = 128;
a2617 1
		pSiS->mmioSize = 128;
a2627 1
		pSiS->mmioSize = 128;
a2634 1
		pSiS->mmioSize = 256;
a2642 1
		   pSiS->mmioSize = 256;
a2646 1
		   pSiS->mmioSize = 256;
a2650 1
		   pSiS->mmioSize = 128;
a2655 1
		   pSiS->mmioSize = 128;
a2671 1
		pSiS->mmioSize = 64;
a2675 1
		pSiS->mmioSize = 64;
d2692 1
a2692 2
    pSiS->sisfbpdc = 0xff;
    pSiS->sisfbpdca = 0xff;
a2771 1
				  if(!pSiS->sisfbpdc) pSiS->sisfbpdc = 0xff;
d2793 2
a2794 12
				     }
				     if(sisfbversion >= 0x010619) {
				        pSiS->sisfb_haveemilcd = mysisfbinfo.sisfb_haveemilcd ? TRUE : FALSE;
				     }
				     if(sisfbversion >= 0x01061f) {
					pSiS->sisfbpdca = mysisfbinfo.sisfb_lcdpdca;
				     } else {
				        if(pSiS->sisfbpdc) {
				           pSiS->sisfbpdca = (pSiS->sisfbpdc & 0xf0) >> 3;
					   pSiS->sisfbpdc  = (pSiS->sisfbpdc & 0x0f) << 1;
					} else {
					   pSiS->sisfbpdca = pSiS->sisfbpdc = 0xff;
a2854 1
	     pSiSEnt->ROM661New = FALSE;
a2902 3
       pSiS->SiS_Pr->PanelSelfDetected = FALSE;
       pSiS->SiS_Pr->UsePanelScaler = -1;
       pSiS->SiS_Pr->CenterScreen = -1;
d2904 1
a2904 1
       pSiS->SiS_Pr->PDC = pSiS->SiS_Pr->PDCA = -1;
a3146 1
    pSiS->ROM661New = FALSE;
d3151 1
a3151 1
          if(pSiSEnt->BIOS) {
a3153 1
	     pSiS->ROM661New = pSiSEnt->ROM661New;
d3198 3
a3201 1
		pSiS->ROM661New = SiSDetermineROMLayout661(pSiS->SiS_Pr,&pSiS->sishw_ext);
d3204 2
a3205 8
			"Video BIOS version \"%7s\" found at 0x%lx (%s data layout)\n",
			&pSiS->BIOS[romptr], segstart, pSiS->ROM661New ? "new" : "old");
#ifdef SISDUALHEAD
                if(pSiSEnt) {
		   pSiSEnt->BIOS = pSiS->BIOS;
		   pSiSEnt->ROM661New = pSiS->ROM661New;
		}
#endif
a3240 1
	     pSiSEnt->CenterLCD = pSiS->CenterLCD;
a3277 1
	     pSiSEnt->SenseYPbPr = pSiS->SenseYPbPr;
d3301 1
a3312 1
	     pSiS->CenterLCD = pSiSEnt->CenterLCD;
a3341 1
	     pSiS->SenseYPbPr = pSiSEnt->SenseYPbPr;
a3383 1
       pSiS->SiS_Pr->CenterScreen = pSiS->CenterLCD;
d3423 2
a3424 2
    xf86DrvMsg(pScrn->scrnIndex, from, "MMIO registers at 0x%lX (size %ldK)\n",
           (unsigned long)pSiS->IOAddress, pSiS->mmioSize);
d3507 1
a3507 1
#endif
d3886 4
a3912 9
    if(pSiS->VBFlags & CRT2_LCD) {
       if((pSiS->VGAEngine != SIS_300_VGA) || (!(pSiS->VBFlags & VB_TRUMPION))) {
          pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTSCALE;
          if(pSiS->VBFlags & (VB_301|VB_301B|VB_302B|VB_301C)) {
             pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTCENTER;
          }
       }
    }

d3963 1
d3978 1
a3978 1
     * If no type forced, use the detected devices in the order TV->LCD->VGA2
d3983 3
a3985 1
       if((pSiS->VBFlags & CRT2_TV) && (!((pSiS->VBFlags & VB_CHRONTEL) && (pSiS->VGAEngine == SIS_300_VGA))))
a3990 2
       else if(pSiS->VBFlags & CRT2_VGA)
          pSiS->ForceCRT2Type = CRT2_VGA;
d4398 1
a4398 1
	     if(pSiS->sisfbpdc != 0xff) {
d4476 1
a4476 1
          unsigned char tmp, tmp2;
d4479 5
a4483 4
	  /* Save the current PDC if the panel is used at the moment. */
	  if(pSiS->VBFlags & (VB_301LV | VB_302LV | VB_302ELV)) {

	     if(pSiS->sisfbpdc != 0xff) {
a4484 35
	     }
	     if(pSiS->sisfbpdca != 0xff) {
	        pSiS->SiS_Pr->PDCA = pSiS->sisfbpdca;
	     }

	     if(!pSiS->donttrustpdc) {
	        if((pSiS->sisfbpdc == 0xff) && (pSiS->sisfbpdca == 0xff)) {
		   CARD16 tempa, tempb;
		   inSISIDXREG(SISPART1,0x2d,tmp2);
		   tempa = (tmp2 & 0xf0) >> 3;
		   tempb = (tmp2 & 0x0f) << 1;
		   inSISIDXREG(SISPART1,0x20,tmp2);
		   tempa |= ((tmp2 & 0x40) >> 6);
		   inSISIDXREG(SISPART1,0x35,tmp2);
		   tempb |= ((tmp2 & 0x80) >> 7);
		   inSISIDXREG(SISPART1,0x13,tmp2);
		   if(!pSiS->ROM661New) {
		      if((tmp2 & 0x04) || (tmp & 0x20)) {
		         pSiS->SiS_Pr->PDCA = tempa;
		         pSiS->SiS_Pr->PDC  = tempb;
		      } else {
		         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	             "Unable to detect PanelDelayCompensation, LCD is not active\n");
		      }
		   } else {
		      if(tmp2 & 0x04) {
		         pSiS->SiS_Pr->PDCA = tempa;
		      } else if(tmp & 0x20) {
		         pSiS->SiS_Pr->PDC  = tempb;
		      } else {
		         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	             "Unable to detect PanelDelayCompensation, LCD is not active\n");
		      }
		   }
		}
d4486 11
a4496 2
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	    "Unable to detect PanelDelayCompensation, please update sisfb\n");
d4500 1
a4500 1
	      	     "Detected LCD PanelDelayCompensation 0x%02x (for LCD=CRT2)\n",
a4502 9
	     if(pSiS->SiS_Pr->PDCA != -1) {
	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      	     "Detected LCD PanelDelayCompensation1 0x%02x (for LCD=CRT1)\n",
		     pSiS->SiS_Pr->PDCA);
	     }
	  }

	  /* Let user override (for all bridges) */
	  if(pSiS->VBFlags & (VB_301B | VB_301C | VB_301LV | VB_302LV | VB_302ELV)) {
d4504 1
a4504 1
	        pSiS->SiS_Pr->PDC = pSiS->PDC & 0x1f;
d4506 1
a4506 1
	      	     "Using LCD PanelDelayCompensation 0x%02x (for LCD=CRT2)\n",
a4508 6
	     if(pSiS->PDCA != -1) {
	        pSiS->SiS_Pr->PDCA = pSiS->PDCA & 0x1f;
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	      	     "Using LCD PanelDelayCompensation1 0x%02x (for LCD=CRT1)\n",
		     pSiS->SiS_Pr->PDCA);
	     }
d5458 1
a5458 1
                         pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));
d5464 1
a5464 1
                        pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));
d5482 1
a5482 1
                    pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));
d5488 1
a5488 1
                    pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));
d5555 1
a5555 1
	    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiSEnt->IOBase, (pSiS->mmioSize * 1024));
d5566 1
a5566 1
	    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiSEnt->IOBaseDense, (pSiS->mmioSize * 1024));
d5587 1
a5587 1
    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->IOBase, (pSiS->mmioSize * 1024));
d5590 1
a5590 1
    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->IOBaseDense, (pSiS->mmioSize * 1024));
d6120 1
a6120 1
    mode |= (1 << 14); 	/* Use linear adressing */
a6302 1
	      int backupcenter = pSiS->SiS_Pr->CenterScreen;
a6323 1
	      pSiS->SiS_Pr->CenterScreen = 0;
a6332 1
	      pSiS->SiS_Pr->CenterScreen = backupcenter;
a8041 1
       pSiS->ResetXv = pSiS->ResetXvGamma = NULL;
d10075 1
a10075 1
	        unsigned char p2_1f,p2_20,p2_2b,p2_42,p2_43;
d10077 1
a10080 3
		p2_2b = pSiS->p2_2b;
		p2_42 = pSiS->p2_42;
		p2_43 = pSiS->p2_43;
a10084 3
		   p2_2b = pSiSEnt->p2_2b;
		   p2_42 = pSiSEnt->p2_42;
		   p2_43 = pSiSEnt->p2_43;
d10090 1
d10093 25
a10117 5
		p2_2b = ((p2_2b & 0x0f) + (val * 2)) & 0x0f;
		temp = p2_43 | ((p2_42 & 0xf0) << 4);
		temp += (val * 2);
		p2_43 = temp & 0xff;
		p2_42 = (temp & 0xf00) >> 4;
d10121 1
a10121 2
		setSISIDXREG(SISPART2,0x2b,0xF0,p2_2b);
		setSISIDXREG(SISPART2,0x42,0x0F,p2_42);
d10153 1
a10153 1
	          }
a10664 9
    if(pSiS->sishw_ext.jChipType >= SIS_661) {
       inSISIDXREG(SISSR,0x11,tmpreg);
       if(tmpreg & 0x20) {
          inSISIDXREG(SISSR,0x3e,tmpreg);
	  tmpreg = (tmpreg + 1) & 0xff;
	  outSISIDXREG(SISSR,0x3e,tmpreg);
       }
    }

a10966 3
	  inSISIDXREG(SISPART2,0x2b,pSiS->p2_2b);
	  inSISIDXREG(SISPART2,0x42,pSiS->p2_42);
	  inSISIDXREG(SISPART2,0x43,pSiS->p2_43);
a11010 2
	     pSiSEnt->p2_42 = pSiS->p2_42; pSiSEnt->p2_43 = pSiS->p2_43;
	     pSiSEnt->p2_2b = pSiS->p2_2b;
d11284 1
a11284 2
   return(SiS_GetModeID(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay,
   			i, pSiS->FSTN, pSiS->LCDwidth, pSiS->LCDheight));
d11329 1
a11329 1
	 		       pSiS->FSTN, pSiS->SiS_Pr->SiS_CustomT, pSiS->LCDwidth, pSiS->LCDheight);
d11571 1
a11571 2
    unsigned char ret = 0;
#if (defined(i386) || defined(__i386) || defined(__i386__) || defined(__AMD64__))
d11587 1
a11587 1
#endif
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@a0 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_driver.c,v 1.86 2003/02/04 02:44:29 dawes Exp $ */
a2 1
 * Parts Copyright 2001, 2002, 2003 by Thomas Winischhofer, Vienna, Austria.
d8 1
a8 1
 * documentation, and that the name of the copyright holder not be used in
d10 1
a10 1
 * specific, written prior permission.  The copyright holder makes no representations
d14 1
a14 1
 * THE COPYRIGHT HOLDER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
d16 1
a16 1
 * EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY SPECIAL, INDIRECT OR
d23 4
a26 4
 *           Mike Chapman <mike@@paranoia.com>,
 *           Juanjo Santamarta <santamarta@@ctv.es>,
 *           Mitani Hiroshi <hmitani@@drl.mei.co.jp>
 *           David Thomas <davtom@@dream.org.uk>.
d28 1
a28 16
 *	     Thomas Winischhofer <thomas@@winischhofer.net>:
 *              - 310/325 series (315/550/650/651/740/M650) support
 *		- (possibly incomplete) Xabre (SiS330) support
 *              - new mode switching code for 300, 310/325 and 330 series
 *              - many fixes for 300/540/630/730 chipsets,
 *              - many fixes for 5597/5598, 6326 and 530/620 chipsets,
 *              - VESA mode switching (deprecated),
 *              - extended CRT2/video bridge handling support,
 *              - dual head support on 300, 310/325 and 330 series
 *              - 650/LVDS (up to 1400x1050), 650/Chrontel 701x support
 *              - 30xB/30xLV/30xLVX video bridge support (300, 310/325, 330 series)
 *              - Xv support for 5597/5598, 6326, 530/620 and 310/325 series
 *              - video overlay enhancements for 300 series
 *              - TV and hi-res support for the 6326
 *		- Color HW cursor support for 300(emulated), 310/325 and 330 series
 *              - etc.
d30 1
a40 1
#include "dixstruct.h"
d57 1
a60 2
#include "sis_driver.h"

d77 2
a78 1
/* Mandatory functions */
d82 2
a83 1
static Bool SISScreenInit(int Index, ScreenPtr pScreen, int argc, char **argv);
a89 3
#ifdef SISDUALHEAD
static Bool SISSaveScreenDH(ScreenPtr pScreen, int mode);
#endif
d97 27
a123 26
static Bool    SISMapMem(ScrnInfoPtr pScrn);
static Bool    SISUnmapMem(ScrnInfoPtr pScrn);
static void    SISSave(ScrnInfoPtr pScrn);
static void    SISRestore(ScrnInfoPtr pScrn);
static void    SISVESARestore(ScrnInfoPtr pScrn);
static Bool    SISModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode);
static void    SISModifyModeInfo(DisplayModePtr mode);
static void    SiSPreSetMode(ScrnInfoPtr pScrn, DisplayModePtr mode);
static void    SiSPostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg);
static void    SiS6326PostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg);
static Bool    SiSSetVESAMode(ScrnInfoPtr pScrn, DisplayModePtr pMode);
static void    SiSBuildVesaModeList(ScrnInfoPtr pScrn, vbeInfoPtr pVbe, VbeInfoBlock *vbe);
static UShort  SiSCalcVESAModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode);
static void    SISVESASaveRestore(ScrnInfoPtr pScrn, vbeSaveRestoreFunction function);
static void    SISBridgeRestore(ScrnInfoPtr pScrn);
static void    SiSEnableTurboQueue(ScrnInfoPtr pScrn);
unsigned char  SISSearchCRT1Rate(ScrnInfoPtr pScrn, DisplayModePtr mode);
static void    SISWaitVBRetrace(ScrnInfoPtr pScrn);

void           SISWaitRetraceCRT1(ScrnInfoPtr pScrn);
void           SISWaitRetraceCRT2(ScrnInfoPtr pScrn);

BOOLEAN        SiSBridgeIsInSlaveMode(ScrnInfoPtr pScrn);
#ifdef CYCLECRT2
Bool           SISCycleCRT2Type(int scrnIndex, DisplayModePtr mode);
#endif
d125 1
a125 1
#ifdef DEBUG
a128 26
/* TW: New mode switching functions */
extern BOOLEAN 	SiSBIOSSetMode(SiS_Private *SiS_Pr, PSIS_HW_DEVICE_INFO HwDeviceExtension,
                               ScrnInfoPtr pScrn, DisplayModePtr mode, BOOLEAN IsCustom);
extern BOOLEAN  SiSSetMode(SiS_Private *SiS_Pr, PSIS_HW_DEVICE_INFO HwDeviceExtension,
                           ScrnInfoPtr pScrn,USHORT ModeNo, BOOLEAN dosetpitch);
extern USHORT 	SiS_CalcModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode);
extern USHORT   SiS_CheckCalcModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode, int VBFlags);
extern void	SiSRegInit(SiS_Private *SiS_Pr, USHORT BaseAddr);
extern DisplayModePtr  SiSBuildBuiltInModeList(ScrnInfoPtr pScrn);
#ifdef SISDUALHEAD
extern BOOLEAN 	SiSBIOSSetModeCRT1(SiS_Private *SiS_Pr, PSIS_HW_DEVICE_INFO HwDeviceExtension,
				   ScrnInfoPtr pScrn, DisplayModePtr mode, BOOLEAN IsCustom);
extern BOOLEAN 	SiSBIOSSetModeCRT2(SiS_Private *SiS_Pr, PSIS_HW_DEVICE_INFO HwDeviceExtension,
				   ScrnInfoPtr pScrn, DisplayModePtr mode);
#endif

/* TW: For power management for 310/325 series */
extern void SiS_Chrontel701xBLOn(SiS_Private *SiS_Pr);
extern void SiS_Chrontel701xBLOff(SiS_Private *SiS_Pr);
extern void SiS_SiS30xBLOn(SiS_Private *SiS_Pr, PSIS_HW_DEVICE_INFO HwDeviceExtension);
extern void SiS_SiS30xBLOff(SiS_Private *SiS_Pr, PSIS_HW_DEVICE_INFO HwDeviceExtension);

#ifdef SISDUALHEAD
static int      SISEntityIndex = -1;
#endif

d134 1
d155 12
a166 5
    { PCI_CHIP_SIS5597,     "SIS5597/5598" },
    { PCI_CHIP_SIS530,      "SIS530/620" },
    { PCI_CHIP_SIS6326,     "SIS6326/AGP/DVD" },
    { PCI_CHIP_SIS300,      "SIS300/305" },
    { PCI_CHIP_SIS630,      "SIS630/730" },
a167 8
    { PCI_CHIP_SIS315,      "SIS315" },
    { PCI_CHIP_SIS315H,     "SIS315H" },
    { PCI_CHIP_SIS315PRO,   "SIS315PRO" },
    { PCI_CHIP_SIS550,	    "SIS550" },
    { PCI_CHIP_SIS650,      "SIS650/M650/651/740" },
#ifdef INCL_SIS330 /* TW: New for SiS330 (untested) */
    { PCI_CHIP_SIS330,      "SIS330(Xabre)" },
#endif
d172 6
a183 8
    { PCI_CHIP_SIS550,      PCI_CHIP_SIS550,    RES_SHARED_VGA },
    { PCI_CHIP_SIS315,      PCI_CHIP_SIS315,    RES_SHARED_VGA },
    { PCI_CHIP_SIS315H,     PCI_CHIP_SIS315H,   RES_SHARED_VGA },
    { PCI_CHIP_SIS315PRO,   PCI_CHIP_SIS315PRO, RES_SHARED_VGA },
    { PCI_CHIP_SIS650,      PCI_CHIP_SIS650,    RES_SHARED_VGA },
#ifdef INCL_SIS330 /* TW: New for SiS330 */
    { PCI_CHIP_SIS330,      PCI_CHIP_SIS330,    RES_SHARED_VGA },
#endif
d186 46
a285 5
    "xf86InterpretEDID",
    "xf86DoEDID_DDC1",
#ifdef SISI2C
    "xf86DoEDID_DDC2",
#endif
a294 6
static const char *int10Symbols[] = {
    "xf86FreeInt10",
    "xf86InitInt10",
    NULL
};

a295 1
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
a296 3
#else
    "VBEExtendedInit",
#endif
a298 9
    "VBEGetVBEInfo",
    "VBEFreeVBEInfo",
    "VBEGetModeInfo",
    "VBEFreeModeInfo",
    "VBESaveRestore",
    "VBESetVBEMode",
    "VBEGetVBEMode",
    "VBESetDisplayStart",
    "VBESetGetLogicalScanlineLength",
d334 1
d365 1
a365 1
			  vbeSymbols, int10Symbols,
d391 1
a391 3
    
    /* Initialise it to 0 */
    memset(pScrn->driverPrivate, 0, sizeof(SISRec));
d400 2
a401 10
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif

    /* TW: Just to make sure... */
    if(!pSiS) return;

    pSiSEnt = pSiS->entityPrivate;

    if(pSiS->pstate) xfree(pSiS->pstate);
a402 27
    if(pSiS->fonts) xfree(pSiS->fonts);
    pSiS->fonts = NULL;
#ifdef SISDUALHEAD
    if(pSiSEnt) {
      if(!pSiS->SecondHead) {
          /* TW: Free memory only if we are first head; in case of an error
	   *     during init of the second head, the server will continue -
	   *     and we need the BIOS image and SiS_Private for the first
	   *     head.
	   */
	  if(pSiSEnt->BIOS) xfree(pSiSEnt->BIOS);
          pSiSEnt->BIOS = pSiS->BIOS = NULL;
	  if(pSiSEnt->SiS_Pr) xfree(pSiSEnt->SiS_Pr);
          pSiSEnt->SiS_Pr = pSiS->SiS_Pr = NULL;
      } else {
      	  pSiS->BIOS = NULL;
	  pSiS->SiS_Pr = NULL;
      }
    } else {
#endif
      if(pSiS->BIOS) xfree(pSiS->BIOS);
      pSiS->BIOS = NULL;
      if(pSiS->SiS_Pr) xfree(pSiS->SiS_Pr);
      pSiS->SiS_Pr = NULL;
#ifdef SISDUALHEAD
    }
#endif
d411 1
a411 1
static void
d415 4
a418 2
    unsigned char extDDC_PCR=0;
    unsigned char crtc17, seq1;
d421 1
a421 32
          "SISDisplayPowerManagementSet(%d)\n",PowerManagementMode);

    /* unlock registers */
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    /* Read CR17 */
    inSISIDXREG(SISCR, 0x17, crtc17);

    /* Read SR1 */
    inSISIDXREG(SISSR, 0x01, seq1);

    if(pSiS->VBFlags & CRT2_LCD) {
      if(((pSiS->VGAEngine == SIS_300_VGA) &&
    	  (!(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)))) ||
         ((pSiS->VGAEngine == SIS_315_VGA) &&
          ((pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) == VB_LVDS))) {
         /* Read Power Control Register (SR11) */
         inSISIDXREG(SISSR, 0x11, extDDC_PCR);
         /* if not blanked, obtain state of LCD blank flags set by BIOS */
         if(!pSiS->Blank) {
	    pSiS->LCDon = extDDC_PCR;
         }
         /* erase LCD blank flags */
         extDDC_PCR &= ~0x0C;
      }
    }

    switch (PowerManagementMode) {

       case DPMSModeOn:      /* HSync: On, VSync: On */
d423 19
a442 1
            seq1 &= ~0x20;
a443 41
	    if(pSiS->VBFlags & CRT2_LCD) {
	       if(pSiS->VGAEngine == SIS_315_VGA) {
	          if(pSiS->VBFlags & VB_CHRONTEL) {
		      SiS_Chrontel701xBLOn(pSiS->SiS_Pr);
		  } else if(pSiS->VBFlags & VB_LVDS) {
		      extDDC_PCR |= (pSiS->LCDon & 0x0C);
		  } else if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
		      SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
		  }
	       } else if(pSiS->VGAEngine == SIS_300_VGA) {
	           if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
		      SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
		   } else {
	              extDDC_PCR |= (pSiS->LCDon & 0x0C);
		   }
	       }
	    }
            break;

       case DPMSModeStandby: /* HSync: Off, VSync: On */
       case DPMSModeSuspend: /* HSync: On, VSync: Off */

       	    pSiS->Blank = TRUE;
            seq1 |= 0x20 ;
	    if(pSiS->VBFlags & CRT2_LCD) {
		if(pSiS->VGAEngine == SIS_315_VGA) {
		   if(pSiS->VBFlags & VB_CHRONTEL) {
		      SiS_Chrontel701xBLOff(pSiS->SiS_Pr);
		   } else if(pSiS->VBFlags & VB_LVDS) {
		      extDDC_PCR |= 0x08;
		   } else if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
		      SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
		   }
		} else if(pSiS->VGAEngine == SIS_300_VGA) {
		   if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
		      SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
		   } else {
		      extDDC_PCR |= 0x08;
		   }
		}
	    }
d445 5
a449 86

       case DPMSModeOff:     /* HSync: Off, VSync: Off */

            pSiS->Blank = TRUE;
            seq1 |= 0x20;
	    if(pSiS->VGAEngine == SIS_300_VGA ||
	       pSiS->VGAEngine == SIS_315_VGA) {
	       /* TW: We can't switch off CRT1 if bridge is in slavemode */
	       if(pSiS->VBFlags & CRT2_ENABLE) {
	          if(!(SiSBridgeIsInSlaveMode(pScrn))) crtc17 &= ~0x80;
	       } else crtc17 &= ~0x80;
	    } else {
	       crtc17 &= ~0x80;
	    }
	    if(pSiS->VBFlags & CRT2_LCD) {
		if(pSiS->VGAEngine == SIS_315_VGA) {
		   if(pSiS->VBFlags & VB_CHRONTEL) {
		      SiS_Chrontel701xBLOff(pSiS->SiS_Pr);
		   } else if(pSiS->VBFlags & VB_LVDS) {
		      extDDC_PCR |= 0x0C;
		   } else if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
		      SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
		   }
		} else if(pSiS->VGAEngine == SIS_300_VGA) {
		   if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
		      SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
		   } else {
		      extDDC_PCR |= 0x0C;
		   }
		}
            }
	    break;

    }

    outSISIDXREG(SISSR, 0x01, seq1);    /* Set/Clear "Display On" bit */

    outSISIDXREG(SISCR, 0x17, crtc17);

    if(pSiS->VBFlags & CRT2_LCD) {
      if(((pSiS->VGAEngine == SIS_300_VGA) &&
          (!(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)))) ||
         ((pSiS->VGAEngine == SIS_315_VGA) &&
          ((pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) == VB_LVDS))) {
            outSISIDXREG(SISSR, 0x11, extDDC_PCR);
      }
    }

    outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
    usleep(10000);
    outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */

}

#ifdef SISDUALHEAD
/* TW: DPMS for dual head mode */
static void
SISDisplayPowerManagementSetDH(ScrnInfoPtr pScrn, int PowerManagementMode, int flags)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char crtc17 = 0;
    unsigned char extDDC_PCR=0;
    unsigned char seq1 = 0;

    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
           "SISDisplayPowerManagementSetDH(%d)\n",PowerManagementMode);

    /* unlock registers */
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    if (pSiS->SecondHead) {

	/* TW: Second (slave) head is always CRT1 */

	/* Read CR17 and SR01 */
        inSISIDXREG(SISCR, 0x17, crtc17);
        inSISIDXREG(SISSR, 0x01, seq1);

    	switch (PowerManagementMode)
    	{
          case DPMSModeOn:       /* HSync: On, VSync: On */
            seq1 &= ~0x20 ;
            crtc17 |= 0x80;
	    pSiS->BlankCRT1 = FALSE;
d451 5
a455 5

          case DPMSModeStandby:  /* HSync: Off, VSync: On */
          case DPMSModeSuspend:  /* HSync: On, VSync: Off */
	    seq1 |= 0x20;
	    pSiS->BlankCRT1 = TRUE;
d457 7
a463 4

          case DPMSModeOff:      /* HSync: Off, VSync: Off */
            seq1 |= 0x20 ;
	    pSiS->BlankCRT1 = TRUE;
a465 100
    	}
	outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */

	outSISIDXREG(SISSR, 0x01, seq1);    /* Set/Clear "Display On" bit */

    	usleep(10000);

	outSISIDXREG(SISCR, 0x17, crtc17);

	outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */

    } else {

    	/* TW: Master head is always CRT2 */

	/* TV can not be managed */
	if(!(pSiS->VBFlags & CRT2_LCD)) return;

        if(((pSiS->VGAEngine == SIS_300_VGA) &&
	    (!(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)))) ||
	   ((pSiS->VGAEngine == SIS_315_VGA) &&
	    ((pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) == VB_LVDS))) {
	   /* Read Power Control Register (SR11) */
           inSISIDXREG(SISSR, 0x11, extDDC_PCR);
      	   /* if not blanked obtain state of LCD blank flags set by BIOS */
    	   if(!pSiS->BlankCRT2) {
		pSiS->LCDon = extDDC_PCR;
	   }
       	   /* erase LCD blank flags */
    	   extDDC_PCR &= ~0xC;
	}

    	switch (PowerManagementMode) {

          case DPMSModeOn:
	    pSiS->BlankCRT2 = FALSE;
	    if(pSiS->VGAEngine == SIS_315_VGA) {
		if(pSiS->VBFlags & VB_CHRONTEL) {
		   SiS_Chrontel701xBLOn(pSiS->SiS_Pr);
		} else if(pSiS->VBFlags & VB_LVDS) {
		   extDDC_PCR |= (pSiS->LCDon & 0x0C);
		} else if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
		   SiS_SiS30xBLOn(pSiS->SiS_Pr, &pSiS->sishw_ext);
		}
	    } else if(pSiS->VGAEngine == SIS_300_VGA) {
	        if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
		   SiS_SiS30xBLOn(pSiS->SiS_Pr, &pSiS->sishw_ext);
	        } else {
		   extDDC_PCR |= (pSiS->LCDon & 0x0C);
		}
            }
            break;

          case DPMSModeStandby:
	  case DPMSModeSuspend:
	    pSiS->BlankCRT2 = TRUE;
	    if(pSiS->VGAEngine == SIS_315_VGA) {
	    	if(pSiS->VBFlags & VB_CHRONTEL) {
		   SiS_Chrontel701xBLOff(pSiS->SiS_Pr);
		} else if(pSiS->VBFlags & VB_LVDS) {
		   extDDC_PCR |= 0x08;
		} else if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
		   SiS_SiS30xBLOff(pSiS->SiS_Pr, &pSiS->sishw_ext);
		}
	    } else if(pSiS->VGAEngine == SIS_300_VGA) {
	        if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
		   SiS_SiS30xBLOff(pSiS->SiS_Pr, &pSiS->sishw_ext);
	        } else {
	    	   extDDC_PCR |= 0x08;
		}
	    }
            break;

          case DPMSModeOff:
	    pSiS->BlankCRT2 = TRUE;
	    if(pSiS->VGAEngine == SIS_315_VGA) {
		if(pSiS->VBFlags & VB_CHRONTEL) {
		   SiS_Chrontel701xBLOff(pSiS->SiS_Pr);
		} else if(pSiS->VBFlags & VB_LVDS) {
		   extDDC_PCR |= 0x0C;
		} else if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
		   SiS_SiS30xBLOff(pSiS->SiS_Pr, &pSiS->sishw_ext);
		}
	    } else if(pSiS->VGAEngine == SIS_300_VGA) {
	        if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
		   SiS_SiS30xBLOff(pSiS->SiS_Pr, &pSiS->sishw_ext);
	        } else {
                   extDDC_PCR |= 0x0C;
		}
            }
            break;
	}

	if(((pSiS->VGAEngine == SIS_300_VGA) &&
	    (!(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)))) ||
	   ((pSiS->VGAEngine == SIS_315_VGA) &&
	    ((pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) == VB_LVDS))) {
	   outSISIDXREG(SISSR, 0x11, extDDC_PCR);
	}

d467 10
d478 1
a478 1
#endif
d492 9
a500 9
   outSISREG(SISCOLIDX, 0x00);
   outSISREG(SISCOLDATA, 0x00);
   outSISREG(SISCOLDATA, 0x00);
   outSISREG(SISCOLDATA, 0x00);

   outSISREG(SISCOLIDX, 0x3f);
   outSISREG(SISCOLDATA, 0x3f);
   outSISREG(SISCOLDATA, 0x3f);
   outSISREG(SISCOLDATA, 0x3f);
d507 1
a507 1
    int     i;
d509 4
a512 4
    int     *usedChips;
    int     numDevSections;
    int     numUsed;
    Bool    foundScreen = FALSE;
d525 2
d546 5
a580 3
#ifdef SISDUALHEAD
	EntityInfoPtr pEnt;
#endif
d586 2
a587 2
                                         SISPciChipsets, NULL, NULL,
                                         NULL, NULL, NULL))) {
a602 40
#ifdef SISDUALHEAD
	pEnt = xf86GetEntityInfo(usedChips[i]);

	/* TW: I assume these chipsets as - basically - dual head capable. */
	if (pEnt->chipset == PCI_CHIP_SIS630 || pEnt->chipset == PCI_CHIP_SIS540 ||
	    pEnt->chipset == PCI_CHIP_SIS650 || pEnt->chipset == PCI_CHIP_SIS550 ||
	    pEnt->chipset == PCI_CHIP_SIS315 || pEnt->chipset == PCI_CHIP_SIS315H ||
	    pEnt->chipset == PCI_CHIP_SIS315PRO || pEnt->chipset == PCI_CHIP_SIS330 ||
	    pEnt->chipset == PCI_CHIP_SIS300) {

	    SISEntPtr pSiSEnt = NULL;
	    DevUnion  *pPriv;

	    xf86SetEntitySharable(usedChips[i]);
	    if (SISEntityIndex < 0)
	        SISEntityIndex = xf86AllocateEntityPrivateIndex();
	    pPriv = xf86GetEntityPrivate(pScrn->entityList[0], SISEntityIndex);
	    if (!pPriv->ptr) {
	        pPriv->ptr = xnfcalloc(sizeof(SISEntRec), 1);
		pSiSEnt = pPriv->ptr;
		pSiSEnt->lastInstance = -1;
		pSiSEnt->DisableDual = FALSE;
		pSiSEnt->ErrorAfterFirst = FALSE;
		pSiSEnt->MapCountIOBase = pSiSEnt->MapCountFbBase = 0;
		pSiSEnt->FbBase = pSiSEnt->IOBase = NULL;
  		pSiSEnt->forceUnmapIOBase = FALSE;
		pSiSEnt->forceUnmapFbBase = FALSE;
#ifdef __alpha__
		pSiSEnt->MapCountIOBaseDense = 0;
		pSiSEnt->IOBaseDense = NULL;
		pSiSEnt->forceUnmapIOBaseDense = FALSE;
#endif
	    } else {
	        pSiSEnt = pPriv->ptr;
	    }
	    pSiSEnt->lastInstance++;
	    xf86SetEntityInstanceForScreen(pScrn, pScrn->entityList[0],
	                                   pSiSEnt->lastInstance);
	}
#endif
d608 6
a613 3

/* TW: If monitor section has no HSync/VRefresh data,
 *     derive it from DDC data.
d615 2
a616 2
static void
SiSSetSyncRangeFromEdid(ScrnInfoPtr pScrn, int flag)
d618 1
a618 133
   MonPtr      mon = pScrn->monitor;
   xf86MonPtr  ddc = mon->DDC;
   int         i,j;
   float       myhhigh, myhlow;
   int         myvhigh, myvlow;
   unsigned char temp;
   const myhddctiming myhtiming[11] = {
       { 1, 0x20, 31.6 }, /* rounded up by .1 */
       { 1, 0x02, 35.3 },
       { 1, 0x04, 37.6 },
       { 1, 0x08, 38.0 },
       { 1, 0x01, 38.0 },
       { 2, 0x40, 47.0 },
       { 2, 0x80, 48.2 },
       { 2, 0x08, 48.5 },
       { 2, 0x04, 56.6 },
       { 2, 0x02, 60.1 },
       { 2, 0x01, 80.1 }
   };
   const myvddctiming myvtiming[10] = {
       { 1, 0x02, 56 },
       { 1, 0x01, 60 },
       { 2, 0x08, 60 },
       { 2, 0x04, 70 },
       { 1, 0x08, 72 },
       { 2, 0x80, 72 },
       { 1, 0x04, 75 },
       { 2, 0x40, 75 },
       { 2, 0x02, 75 },
       { 2, 0x01, 75 }
   };
   /* "Future modes"; we only check the really high ones */
   const myddcstdmodes mystdmodes[8] = {
       { 1280, 1024, 85, 91.1 },
       { 1600, 1200, 60, 75.0 },
       { 1600, 1200, 65, 81.3 },
       { 1600, 1200, 70, 87.5 },
       { 1600, 1200, 75, 93.8 },
       { 1600, 1200, 85, 106.3 },
       { 1920, 1440, 60, 90.0 },
       { 1920, 1440, 75, 112.5 }
   };

   if(flag) { /* HSync */
      for (i = 0; i < 4; i++) {
    	 if (ddc->det_mon[i].type == DS_RANGES) {
            mon->nHsync = 1;
            mon->hsync[0].lo = ddc->det_mon[i].section.ranges.min_h;
            mon->hsync[0].hi = ddc->det_mon[i].section.ranges.max_h;
            return;
         }
      }
      /* If no sync ranges detected in detailed timing table, we
       * derive them from supported VESA modes. */
      myhlow = myhhigh = 0.0;
      for(i=0; i<11; i++) {
         if(myhtiming[i].whichone == 1) temp = ddc->timings1.t1;
	 else                           temp = ddc->timings1.t2;
	 if(temp & myhtiming[i].mask) {
	     if((i==0) || (myhlow > myhtiming[i].rate))
	            myhlow = myhtiming[i].rate;
	 }
	 if(myhtiming[10-i].whichone == 1) temp = ddc->timings1.t1;
	 else                              temp = ddc->timings1.t2;
	 if(temp & myhtiming[10-i].mask) {
	     if((i==0) || (myhhigh < myhtiming[10-i].rate))
	            myhhigh = myhtiming[10-i].rate;
	 }
      }
      for(i=0;i<STD_TIMINGS;i++) {
	 if(ddc->timings2[i].hsize > 256) {
            for(j=0; j<8; j++) {
	       if((ddc->timings2[i].hsize == mystdmodes[j].hsize) &&
	          (ddc->timings2[i].vsize == mystdmodes[j].vsize) &&
		  (ddc->timings2[i].refresh == mystdmodes[j].refresh)) {
		  if(mystdmodes[j].hsync > myhhigh)
		     myhhigh = mystdmodes[j].hsync;
	       }
	    }
	 }
      }
      if((myhhigh) && (myhlow)) {
         mon->nHsync = 1;
	 mon->hsync[0].lo = myhlow - 0.1;
	 mon->hsync[0].hi = myhhigh;
      }


   } else {  /* Vrefresh */

      for (i = 0; i < 4; i++) {
         if (ddc->det_mon[i].type == DS_RANGES) {
            mon->nVrefresh = 1;
            mon->vrefresh[0].lo = ddc->det_mon[i].section.ranges.min_v;
            mon->vrefresh[0].hi = ddc->det_mon[i].section.ranges.max_v;
            return;
         }
      }

      myvlow = myvhigh = 0;
      for(i=0; i<10; i++) {
         if(myvtiming[i].whichone == 1) temp = ddc->timings1.t1;
	 else                           temp = ddc->timings1.t2;
	 if(temp & myvtiming[i].mask) {
	     if((i==0) || (myvlow > myvtiming[i].rate))
	           myvlow = myvtiming[i].rate;
	 }
	 if(myvtiming[9-i].whichone == 1) temp = ddc->timings1.t1;
	 else                             temp = ddc->timings1.t2;
	 if(temp & myvtiming[9-i].mask) {
	     if((i==0) || (myvhigh < myvtiming[9-i].rate))
	           myvhigh = myvtiming[9-i].rate;
	 }
      }
      for(i=0;i<STD_TIMINGS;i++) {
	 if(ddc->timings2[i].hsize > 256) {
            for(j=0; j<8; j++) {
	       if((ddc->timings2[i].hsize == mystdmodes[j].hsize) &&
	          (ddc->timings2[i].vsize == mystdmodes[j].vsize) &&
		  (ddc->timings2[i].refresh == mystdmodes[j].refresh)) {
		  if(mystdmodes[j].refresh > myvhigh)
		     myvhigh = mystdmodes[j].refresh;
	       }
	    }
	 }
      }
      if((myvhigh) && (myvlow)) {
         mon->nVrefresh = 1;
	 mon->vrefresh[0].lo = myvlow;
	 mon->vrefresh[0].hi = myvhigh;
      }

    }
d620 1
a621 62
static xf86MonPtr
SiSInternalDDC(ScrnInfoPtr pScrn, int crtno)
{
   SISPtr        pSiS = SISPTR(pScrn);
   USHORT        temp, i;
   unsigned char buffer[256];
   xf86MonPtr    pMonitor = NULL;

   /* TW: If CRT1 is off, skip DDC */
   if((pSiS->CRT1off) && (!crtno)) return NULL;

   temp = SiS_HandleDDC(pSiS->SiS_Pr, pSiS, crtno, 0, &buffer[0]);
   if((!temp) || (temp == 0xffff)) {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
                "CRT%d DDC probing failed, now trying via VBE\n", crtno + 1);
      return(NULL);
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "CRT%d DDC supported\n", crtno + 1);
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "CRT%d DDC level: %s%s%s%s\n",
	     crtno + 1,
	     (temp & 0x1a) ? "" : "[none of the supported]",
	     (temp & 0x02) ? "2 " : "",
	     (temp & 0x08) ? "3 " : "",
             (temp & 0x10) ? "4" : "");
      if(temp & 0x02) {
	 i = 3;  /* Number of retrys */
	 do {
	    temp = SiS_HandleDDC(pSiS->SiS_Pr, pSiS, crtno, 1, &buffer[0]);
	 } while((temp) && i--);
         if(!temp) {
	    if((pMonitor = xf86InterpretEDID(pScrn->scrnIndex, &buffer[0]))) {
	       return(pMonitor);
	    } else {
	       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	           "CRT%d DDC EDID corrupt\n", crtno + 1);
	       return(NULL);
	    }
	 } else {
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"CRT%d DDC reading failed\n", crtno + 1);
	    return(NULL);
	 }
      } else {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "DDC levels 3 and 4 not supported by this driver yet.\n");
         return(NULL);
      }
   }
}

static xf86MonPtr
SiSDoPrivateDDC(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);

#ifdef SISDUALHEAD
    if((pSiS->DualHeadMode) && (!pSiS->SecondHead))
	return(SiSInternalDDC(pScrn, 1));
    else
#endif
        return(SiSInternalDDC(pScrn, 0)); 
}
d629 2
a630 2
    unsigned char usScratchCR17, CR5F;
    unsigned char usScratchCR32;
a631 1
    int temp;
a635 9
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif
    DisplayModePtr first, p, n;
    DisplayModePtr tempmode, delmode, mymodes;
    unsigned char srlockReg,crlockReg;
    unsigned char tempreg;
    xf86MonPtr pMonitor = NULL;
    Bool didddc2;
d643 2
a644 7
		
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	      	if((pVbe = VBEInit(NULL,index))) {
#else
              	if((pVbe = VBEExtendedInit(NULL,index,0))) {
#endif
            		ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
d655 4
a658 4
     * be initialised here.  xf86Screens[] is the array of all screens,
     * (pScrn is a pointer to one of these).  Privates allocated using
     * xf86AllocateScrnInfoPrivateIndex() are too, and should be used
     * for data that must persist across server generations.
d665 1
a665 3
    if(pScrn->numEntities != 1) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Number of entities is not 1\n");
a666 1
    }
d669 1
a669 3
    if(!xf86LoadSubModule(pScrn, "vgahw")) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Could not load vgahw module\n");
a670 1
    }
d674 7
a680 6
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
           "SiS driver (31/01/03-1) by "
	   "Thomas Winischhofer <thomas@@winischhofer.net>\n");
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
           "See http://www.winischhofer.net/linuxsisvga.shtml "
	   "for documentation and updates\n");	   
d682 1
a682 4
    /* Allocate a vgaHWRec */
    if(!vgaHWGetHWRec(pScrn)) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Could not allocate VGA private\n");
d684 2
a685 1
    }
d688 1
a688 3
    if(!SISGetRec(pScrn)) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Could not allocate memory for pSiS private\n");
a693 6
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    pSiS->IODBase = 0;
#else
    pSiS->IODBase = pScrn->domainIOBase;  
#endif

d696 1
a696 4
    if(pSiS->pEnt->location.type != BUS_PCI)  {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Entity's bus type is not PCI\n");
    	SISFreeRec(pScrn);
a697 18
    }

#ifdef SISDUALHEAD
    /* TW: Allocate an entity private if necessary */
    if(xf86IsEntityShared(pScrn->entityList[0])) {
        pSiSEnt = xf86GetEntityPrivate(pScrn->entityList[0],
					SISEntityIndex)->ptr;
        pSiS->entityPrivate = pSiSEnt;

	/* TW: If something went wrong, quit here */
    	if ((pSiSEnt->DisableDual) || (pSiSEnt->ErrorAfterFirst)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	   "First head encountered fatal error, can't continue\n");
		SISFreeRec(pScrn);
		return FALSE;
	}
    }
#endif
d701 2
a702 2
    pSiS->PciTag = pSiS->sishw_ext.PciTag = pciTag(pSiS->PciInfo->bus,
                           pSiS->PciInfo->device, pSiS->PciInfo->func);
d704 3
a706 18
    pSiS->Primary = xf86IsPrimaryPci(pSiS->PciInfo);
    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
    	"This adapter is %s display adapter\n",
	(pSiS->Primary ? "primary" : "secondary"));

    if(pSiS->Primary) {
       VGAHWPTR(pScrn)->MapSize = 0x10000;     /* Standard 64k VGA window */
       if(!vgaHWMapMem(pScrn)) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Could not map VGA memory\n");
          SISFreeRec(pScrn);
          return FALSE;
       }
    }
    vgaHWGetIOBase(VGAHWPTR(pScrn));

    /* TW: We "patch" the PIOOffset inside vgaHW in order to force
     *     the vgaHW module to use our relocated i/o ports.
a707 20
    VGAHWPTR(pScrn)->PIOOffset = pSiS->IODBase + (pSiS->PciInfo->ioBase[2] & 0xFFFC) - 0x380;

    pSiS->pInt = NULL;
    if(!pSiS->Primary) {
#if !defined(__alpha__)
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       		"Initializing display adapter through int10\n");
#endif
       if(xf86LoadSubModule(pScrn, "int10")) {
          xf86LoaderReqSymLists(int10Symbols, NULL);
#if !defined(__alpha__)
          pSiS->pInt = xf86InitInt10(pSiS->pEnt->index);
#endif
       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Could not load int10 module\n");
       }
    }

#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
a714 3
#else
    xf86SetOperatingState(resVgaMem, pSiS->pEnt->index, ResUnusedOpr);
#endif
d718 1
a718 1
    /* Operations for which I/O access is required */
d722 1
a722 8
    if(!xf86LoadSubModule(pScrn, "ramdac")) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Could not load ramdac module\n");
#ifdef SISDUALHEAD
        if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
        SISFreeRec(pScrn);
a723 1
    }
d730 4
d736 1
a736 1
     * override. DANGEROUS!
a760 28
    pSiS->sishw_ext.jChipRevision = pSiS->ChipRev;

    /* TW: Determine SiS6326 chiprevision. This is not yet used for
     * anything, but it will as soon as I found out on which revisions
     * the hardware video overlay really works.
     * According to SiS the only differences are:
     * Chip name     Chip type      TV-Out       MPEG II decoder
     * 6326 AGP      Rev. G0/H0     no           no
     * 6326 DVD      Rev. D2        yes          yes
     * 6326          Rev. Cx        yes          yes
     */
    pSiS->SiS6326Flags = 0;
    if(pSiS->Chipset == PCI_CHIP_SIS6326) {
        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		"Chipset is SiS6326 %s (revision 0x%02x)\n",
		(pSiS->ChipRev == 0xaf) ? "(Ax)" :
		   ((pSiS->ChipRev == 0x0a) ? "AGP (G0)" :
		      ((pSiS->ChipRev == 0x0b) ? "AGP (H0)" :
		          (((pSiS->ChipRev & 0xf0) == 0xd0) ? "DVD (Dx)" :
   			      (((pSiS->ChipRev & 0xf0) == 0x90) ? "(9x)" :
			          (((pSiS->ChipRev & 0xf0) == 0xc0) ? "(Cx)" :
				       "(unknown)"))))),
		pSiS->ChipRev);
	if((pSiS->ChipRev != 0x0a) && (pSiS->ChipRev != 0x0b)) {
		pSiS->SiS6326Flags |= SIS6326_HASTV;
	}
    }

a768 5
#ifdef SISDUALHEAD
        if (pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
        SISFreeRec(pScrn);
a773 5
#ifdef SISDUALHEAD
        if (pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
        SISFreeRec(pScrn);
a776 148
    /* TW: Determine chipset and VGA engine type for new mode switching code */
    switch(pSiS->Chipset) {
	case PCI_CHIP_SIS300:
		pSiS->sishw_ext.jChipType = SIS_300;
		pSiS->VGAEngine = SIS_300_VGA;
		break;
	case PCI_CHIP_SIS630: /* 630 + 730 */
		pSiS->sishw_ext.jChipType = SIS_630;
		if(pciReadLong(0x00000000, 0x00) == 0x07301039) {
			pSiS->sishw_ext.jChipType = SIS_730;
		}
		pSiS->VGAEngine = SIS_300_VGA;
		break;
	case PCI_CHIP_SIS540:
		pSiS->sishw_ext.jChipType = SIS_540;
		pSiS->VGAEngine = SIS_300_VGA;
		break;
	case PCI_CHIP_SIS315H:
		pSiS->sishw_ext.jChipType = SIS_315H;
		pSiS->VGAEngine = SIS_315_VGA;
		break;
	case PCI_CHIP_SIS315:
		/* TW: Override for simplicity */
	        pSiS->Chipset = PCI_CHIP_SIS315H;
		pSiS->sishw_ext.jChipType = SIS_315;
		pSiS->VGAEngine = SIS_315_VGA;
		break;
	case PCI_CHIP_SIS315PRO:
		/* TW: Override for simplicity */
		pSiS->Chipset = PCI_CHIP_SIS315H;
		pSiS->sishw_ext.jChipType = SIS_315PRO;
		pSiS->VGAEngine = SIS_315_VGA;
		break;
	case PCI_CHIP_SIS550:
		pSiS->sishw_ext.jChipType = SIS_550;
		pSiS->VGAEngine = SIS_315_VGA;
		break;
	case PCI_CHIP_SIS650: /* 650 + 740 */
		pSiS->sishw_ext.jChipType = SIS_650;
		pSiS->VGAEngine = SIS_315_VGA;
		break;
	case PCI_CHIP_SIS330:
		pSiS->sishw_ext.jChipType = SIS_330;
		pSiS->VGAEngine = SIS_315_VGA;  
		break;
	case PCI_CHIP_SIS530:
		pSiS->sishw_ext.jChipType = SIS_530;
		pSiS->VGAEngine = SIS_530_VGA;
		break;
	default:
		pSiS->sishw_ext.jChipType = SIS_OLD;
		pSiS->VGAEngine = SIS_OLD_VGA;
		break;
    }

    /* TW: Now check if sisfb is loaded. Since sisfb only supports
     * the 300 and 310/325 series, we only do this for these chips.
     * We use this for checking where sisfb starts its memory
     * heap in order to automatically detect the correct MaxXFBMem
     * setting (which normally is given by the option of the same name).
     * That only works if sisfb is completely running, ie with
     * a video mode (because the fbdev will not be installed otherwise.)
     */

    pSiS->donttrustpdc = FALSE;
    pSiS->sisfbpdc = 0;

    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {

       int fd, i;
       sisfb_info mysisfbinfo;
       BOOL found = FALSE;
       char name[10];

       i=0;
       do {
         sprintf(name, "/dev/fb%1d", i);
         if((fd = open(name, 'r'))) {

	   if(!ioctl(fd, SISFB_GET_INFO, &mysisfbinfo)) {

	      if(mysisfbinfo.sisfb_id == SISFB_ID) {

	         if((mysisfbinfo.sisfb_version >= 1) &&
		    (mysisfbinfo.sisfb_revision >=5) &&
  		    (mysisfbinfo.sisfb_patchlevel >= 8)) {
		    /* TW: Added PCI bus/slot/func into in sisfb Version 1.5.08.
		           Check this to make sure we run on the same card as sisfb
		     */
		    if((mysisfbinfo.sisfb_pcibus == pSiS->PciInfo->bus) &&
		       (mysisfbinfo.sisfb_pcislot == pSiS->PciInfo->device) &&
		       (mysisfbinfo.sisfb_pcifunc == pSiS->PciInfo->func) ) {
	         	found = TRUE;
		    }
		 } else found = TRUE;

		 if(found) {
		   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      	     "%s: SiS kernel fb driver (sisfb) %d.%d.%d detected (PCI: %02d:%02d.%d)\n",
		     &name[5],
		     mysisfbinfo.sisfb_version,
		     mysisfbinfo.sisfb_revision,
		     mysisfbinfo.sisfb_patchlevel,
		     pSiS->PciInfo->bus,
		     pSiS->PciInfo->device,
		     pSiS->PciInfo->func);
		   /* TW: Added version/rev/pl in sisfb 1.4.0 */
		   if(mysisfbinfo.sisfb_version == 0) {
		     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		        "Old version of sisfb found. Please update\n");
		   }
		   pSiS->sisfbMem = mysisfbinfo.heapstart;
		   /* TW: Basically, we can't trust the pdc register if sisfb is loaded */
		   pSiS->donttrustpdc = TRUE;
		   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		      "sisfb: memory heap starts at %dKB\n", pSiS->sisfbMem);
		   xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		      "sisfb: using video mode 0x%02x\n", mysisfbinfo.fbvidmode);
		   if((mysisfbinfo.sisfb_version >= 1) &&
		      (mysisfbinfo.sisfb_revision >=5) &&
  		      (mysisfbinfo.sisfb_patchlevel >= 6)) {
		     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		        "sisfb: %sreserved hardware cursor, using %s command queue\n",
			(mysisfbinfo.sisfb_caps & 0x80) ? "" : "not ",
			(mysisfbinfo.sisfb_caps & 0x40) ? "SiS300 series Turbo" :
			   (mysisfbinfo.sisfb_caps & 0x20) ? "SiS310/325 series AGP" :
			      (mysisfbinfo.sisfb_caps & 0x10) ? "SiS310/325 series VRAM" :
			         (mysisfbinfo.sisfb_caps & 0x08) ? "SiS310/325 series MMIO" :
				    "no");
		   }
		   if((mysisfbinfo.sisfb_version >= 1) &&
		      (mysisfbinfo.sisfb_revision >=5) &&
  		      (mysisfbinfo.sisfb_patchlevel >= 10)) {
		      /* TW: We can trust the pdc value if sisfb is of recent version */
		      pSiS->donttrustpdc = FALSE;
		      if(mysisfbinfo.sisfb_patchlevel >= 11) {
		      	 pSiS->sisfbpdc = mysisfbinfo.sisfb_lcdpdc;
		      }
		   }
		 }
	      }
	   }
	   close (fd);
         }
	 i++;

       } while((i <= 7) && (!found));
    }
d780 2
a781 2
     * TW: Additionally, determine the size of the HWCursor memory
     * area.
d783 9
a791 10
    switch (pSiS->VGAEngine) {
      case SIS_300_VGA:
        pSiS->CursorSize = 4096;
    	pix24flags = Support32bppFb |
	             SupportConvert24to32;
	break;
      case SIS_315_VGA:
        pSiS->CursorSize = 16384;
    	pix24flags = Support32bppFb |
	             SupportConvert24to32;
d793 1
a793 9
      case SIS_530_VGA:
        pSiS->CursorSize = 2048;
    	pix24flags = Support32bppFb |
	             Support24bppFb |
                     SupportConvert24to32 |
		     SupportConvert32to24;
        break;
      default:
        pSiS->CursorSize = 2048;
d795 1
a795 2
	             SupportConvert32to24 |
	             PreferConvert32to24;
d799 2
a800 7
#ifdef SISDUALHEAD
    /* TW: In case of Dual Head, we need to determine if we are the "master" head or
     *     the "slave" head. In order to do that, we set PrimInit to DONE in the
     *     shared entity at the end of the first initialization. The second
     *     initialization then knows that some things have already been done. THIS
     *     ALWAYS ASSUMES THAT THE FIRST DEVICE INITIALIZED IS THE MASTER!
     */
d802 13
a814 27
    if(xf86IsEntityShared(pScrn->entityList[0])) {
      if(pSiSEnt->lastInstance > 0) {
     	if(!xf86IsPrimInitDone(pScrn->entityList[0])) {
		/* First Head (always CRT2) */
		pSiS->SecondHead = FALSE;
		pSiSEnt->pScrn_1 = pScrn;
		pSiSEnt->CRT1ModeNo = pSiSEnt->CRT2ModeNo = -1;
		pSiS->DualHeadMode = TRUE;
		pSiSEnt->DisableDual = FALSE;
		pSiSEnt->BIOS = NULL;
		pSiSEnt->SiS_Pr = NULL;
	} else {
		/* Second Head (always CRT1) */
		pSiS->SecondHead = TRUE;
		pSiSEnt->pScrn_2 = pScrn;
		pSiS->DualHeadMode = TRUE;
	}
      } else {
        /* TW: Only one screen in config file - disable dual head mode */
        pSiS->SecondHead = FALSE;
	pSiS->DualHeadMode = FALSE;
	pSiSEnt->DisableDual = TRUE;
      }
    } else {
        /* TW: Entity is not shared - disable dual head mode */
        pSiS->SecondHead = FALSE;
	pSiS->DualHeadMode = FALSE;
a815 1
#endif
d817 1
a817 1
    pSiS->ForceCursorOff = FALSE;
d819 3
a821 33
    /* TW: Allocate SiS_Private (for mode switching code) and initialize it */
    pSiS->SiS_Pr = NULL;
#ifdef SISDUALHEAD
    if(pSiSEnt) {
       if(pSiSEnt->SiS_Pr) pSiS->SiS_Pr = pSiSEnt->SiS_Pr;
    }
#endif
    if(!pSiS->SiS_Pr) {
       if(!(pSiS->SiS_Pr = xnfcalloc(sizeof(SiS_Private), 1))) {
           xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Could not allocate memory for SiS_Pr private\n");
#ifdef SISDUALHEAD
	   if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	   if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	   SISFreeRec(pScrn);
           return FALSE;
       }
#ifdef SISDUALHEAD
       if(pSiSEnt) pSiSEnt->SiS_Pr = pSiS->SiS_Pr;
#endif
       memset(pSiS->SiS_Pr, 0, sizeof(SiS_Private));
    }
    pSiS->SiS_Pr->SiS_Backup70xx = 0xff;
    pSiS->SiS_Pr->SiS_CHOverScan = -1;
    pSiS->SiS_Pr->SiS_ChSW = FALSE;
    pSiS->SiS_Pr->CRT1UsesCustomMode = FALSE;

    /* TW: Get our relocated IO registers */
    pSiS->RelIO = (pSiS->PciInfo->ioBase[2] & 0xFFFC) + pSiS->IODBase;
    pSiS->sishw_ext.ulIOAddress = pSiS->RelIO + 0x30;
    xf86DrvMsg(pScrn->scrnIndex, from, "Relocated IO registers at 0x%lX\n",
           (unsigned long)pSiS->RelIO);
d823 1
a823 82
    /* TW: Initialize SiS Port Reg definitions for externally used
     *     BIOS emulation (init.c/init301.c) functions.
     */
    SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO + 0x30);

    /* TW: The following identifies the old chipsets. This is only
     *     partly used since the really old chips are not supported,
     *     but I keep it here for future use.
     */
    if(pSiS->VGAEngine == SIS_OLD_VGA || pSiS->VGAEngine == SIS_530_VGA) {
       switch(pSiS->Chipset) {
       case PCI_CHIP_SG86C205:    /* Just for making it complete */
          {
	  unsigned char temp;
	  sisSaveUnlockExtRegisterLock(pSiS, &srlockReg, &crlockReg);
	  inSISIDXREG(SISSR, 0x10, temp);
	  if(temp & 0x80) pSiS->oldChipset = OC_SIS6205B;
	  else pSiS->oldChipset = (pSiS->ChipRev == 0x11) ?
	  		OC_SIS6205C : OC_SIS6205A;
          break;
	  }
       case PCI_CHIP_SIS82C204:   /* Just for making it complete */
       	  pSiS->oldChipset = OC_SIS82204; break;
       case 0x6225:		  /* Just for making it complete */
          pSiS->oldChipset = OC_SIS6225; break;
       case PCI_CHIP_SIS5597:
          pSiS->oldChipset = OC_SIS5597; break;
       case PCI_CHIP_SIS6326:
          pSiS->oldChipset = OC_SIS6326; break;
       case PCI_CHIP_SIS530:
          if((pSiS->ChipRev & 0x0f) < 0x0a)
	  	pSiS->oldChipset = OC_SIS530A;
	  else  pSiS->oldChipset = OC_SIS530B;
	  break;
       default:
          pSiS->oldChipset = OC_UNKNOWN;
       }
    }

    if(!xf86SetDepthBpp(pScrn, 8, 8, 8, pix24flags)) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"xf86SetDepthBpp() error\n");
#ifdef SISDUALHEAD
        if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
        SISFreeRec(pScrn);
    	return FALSE;
    }

    /* Check that the returned depth is one we support */
    temp = 0;
    switch(pScrn->depth) {
      case 8:
      case 16:
      case 24:
        break;
      case 15:
	 if((pSiS->VGAEngine == SIS_300_VGA) ||
	    (pSiS->VGAEngine == SIS_315_VGA))
		temp = 1;
         break;
      default:
	 temp = 1;
    }

    if(temp) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
               "Given depth (%d) is not supported by this driver/chipset\n",
               pScrn->depth);
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	SISFreeRec(pScrn);
        return FALSE;
    }

    xf86PrintDepthBpp(pScrn);

    /* Get the depth24 pixmap format */
    if(pScrn->depth == 24 && pix24bpp == 0)
        pix24bpp = xf86GetBppFromDepth(pScrn, 24);

    /*
d827 1
a827 1
    if(pScrn->depth > 8) {
d831 1
a831 8
        if(!xf86SetWeight(pScrn, zeros, zeros)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"xf86SetWeight() error\n");
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	    SISFreeRec(pScrn);
d834 2
a835 30
           Bool ret = FALSE;
           switch(pScrn->depth) {
	   case 15:
	      if((pScrn->weight.red != 5) ||
	         (pScrn->weight.green != 5) ||
		 (pScrn->weight.blue != 5)) ret = TRUE;
	      break;
	   case 16:
	      if((pScrn->weight.red != 5) ||
	         (pScrn->weight.green != 6) ||
		 (pScrn->weight.blue != 5)) ret = TRUE;
	      break;
	   case 24:
	      if((pScrn->weight.red != 8) ||
	         (pScrn->weight.green != 8) ||
		 (pScrn->weight.blue != 8)) ret = TRUE;
	      break;
           }
	   if(ret) {
	      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	      	"RGB Weight %d%d%d at depth %d not supported by hardware\n",
		pScrn->weight.red, pScrn->weight.green,
		pScrn->weight.blue, pScrn->depth);
#ifdef SISDUALHEAD
	      if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	      if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	      SISFreeRec(pScrn);
              return FALSE;
	   }
d839 1
a839 13
    /* TW: Set the current layout parameters */
    pSiS->CurrentLayout.bitsPerPixel = pScrn->bitsPerPixel;
    pSiS->CurrentLayout.depth        = pScrn->depth;
    /* (Inside this function, we can use pScrn's contents anyway) */

    if(!xf86SetDefaultVisual(pScrn, -1)) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"xf86SetDefaultVisual() error\n");
#ifdef SISDUALHEAD
	if (pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
        SISFreeRec(pScrn);
d842 1
a842 1
        /* We don't support DirectColor at > 8bpp */
d844 2
a845 2
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Given default visual "
                        "(%s) is not supported at depth %d\n",
a846 5
#ifdef SISDUALHEAD
	    if (pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	    SISFreeRec(pScrn);
d852 1
a852 1
     * The cmap layer needs this to be initialised.
d854 1
d858 1
a858 8
        if(!xf86SetGamma(pScrn, zeros)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"xf86SetGamma() error\n");
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	    SISFreeRec(pScrn);
d863 1
a863 1
    /* We use a programamble clock */
d867 1
a867 1
    if(pScrn->depth == 8) {
d871 1
a871 1
    pSiS->ddc1Read = SiSddc1Read;
d875 2
a876 2
    /* Unlock registers */
    sisSaveUnlockExtRegisterLock(pSiS, &srlockReg, &crlockReg);
d878 9
a886 90
    /* TW: We need no backup area (300/310/325 new mode switching code) */
    pSiS->sishw_ext.pSR = NULL;
    pSiS->sishw_ext.pCR = NULL;

    /* TW: Read BIOS for 300 and 310/325 series customization */
    pSiS->sishw_ext.pjVirtualRomBase = NULL;
    pSiS->BIOS = NULL;
    pSiS->sishw_ext.UseROM = FALSE;

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
#ifdef SISDUALHEAD
      if(pSiSEnt) {
          if(pSiSEnt->BIOS)  {
	  	pSiS->BIOS = pSiSEnt->BIOS;
		pSiS->sishw_ext.pjVirtualRomBase = pSiS->BIOS;
          }
      }
#endif
      if(!pSiS->BIOS) {
          if(!(pSiS->BIOS = xcalloc(1, BIOS_SIZE))) {
             xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		"Could not allocate memory for video BIOS image\n");
          } else {
	     unsigned long  segstart;
             unsigned short romptr;
	     BOOLEAN found;
             int  i;
             static const char sis_rom_sig[] = "Silicon Integrated Systems";
             static const char *sis_sig[10] = {
                  "300", "540", "630", "730",
		  "315", "315", "315", "5315", "6325",
		  "Xabre"
             };
	     static const unsigned short sis_nums[10] = {
	          SIS_300, SIS_540, SIS_630, SIS_730,
		  SIS_315PRO, SIS_315H, SIS_315, SIS_550, SIS_650,
		  SIS_330
	     };

	     found = FALSE;
             for(segstart=BIOS_BASE; segstart<0x000f0000; segstart+=0x00001000) {

#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
                if(xf86ReadBIOS(segstart, 0, pSiS->BIOS, BIOS_SIZE) != BIOS_SIZE) continue;
#else
                if(xf86ReadDomainMemory(pSiS->PciTag, segstart, BIOS_SIZE, pSiS->BIOS) != BIOS_SIZE) continue;
#endif

		if((pSiS->BIOS[0] != 0x55) || (pSiS->BIOS[1] != 0xaa)) continue;

		romptr = pSiS->BIOS[0x12] | (pSiS->BIOS[0x13] << 8);
		if(romptr > (BIOS_SIZE - strlen(sis_rom_sig))) continue;
                if(strncmp(sis_rom_sig, (char *)&pSiS->BIOS[romptr], strlen(sis_rom_sig)) != 0) continue;

		romptr = pSiS->BIOS[0x14] | (pSiS->BIOS[0x15] << 8);
		if(romptr > (BIOS_SIZE - 5)) continue;
		for(i = 0; (i < 10) && (!found); i++) {
                    if(strncmp(sis_sig[i], (char *)&pSiS->BIOS[romptr], strlen(sis_sig[i])) == 0) {
                        if(sis_nums[i] == pSiS->sishw_ext.jChipType) {
			   found = TRUE;
                           break;
			} else {
			   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   	"Ignoring BIOS for SiS %s at %p\n", sis_sig[i], segstart);
			}
                    }
                }
		if(found) break;
             }

	     if(!found) {
	     	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		         "Could not find/read video BIOS\n");
 	   	xfree(pSiS->BIOS);
	        pSiS->BIOS = NULL;
             } else {
#ifdef SISDUALHEAD
                if(pSiSEnt)  pSiSEnt->BIOS = pSiS->BIOS;
#endif
                pSiS->sishw_ext.pjVirtualRomBase = pSiS->BIOS;
		romptr = pSiS->BIOS[0x16] | (pSiS->BIOS[0x17] << 8);
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
			"Video BIOS version \"%7s\" found at %p\n",
			&pSiS->BIOS[romptr], segstart);
             }
	     
          }
      }
      if(pSiS->BIOS) pSiS->sishw_ext.UseROM = TRUE;
      else           pSiS->sishw_ext.UseROM = FALSE;
a888 1
    /* Evaluate options */
a889 311

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
        if(!pSiS->SecondHead) {
	     /* TW: Copy some option settings to entity private */
             pSiSEnt->HWCursor = pSiS->HWCursor;
	     pSiSEnt->ForceCRT2Type = pSiS->ForceCRT2Type;
	     pSiSEnt->ForceTVType = pSiS->ForceTVType;
	     pSiSEnt->TurboQueue = pSiS->TurboQueue;
	     pSiSEnt->PDC = pSiS->PDC;
	     pSiSEnt->OptTVStand = pSiS->OptTVStand;
	     pSiSEnt->NonDefaultPAL = pSiS->NonDefaultPAL;
	     pSiSEnt->OptTVOver = pSiS->OptTVOver;
	     pSiSEnt->OptTVSOver = pSiS->OptTVSOver;
	     pSiSEnt->OptROMUsage = pSiS->OptROMUsage;
	     pSiSEnt->DSTN = pSiS->DSTN;
	     pSiSEnt->XvOnCRT2 = pSiS->XvOnCRT2;
	     pSiSEnt->NoAccel = pSiS->NoAccel;
	     pSiSEnt->NoXvideo = pSiS->NoXvideo;
	     pSiSEnt->forceCRT1 = pSiS->forceCRT1;
	     pSiSEnt->chtvlumabandwidthcvbs = pSiS->chtvlumabandwidthcvbs;
	     pSiSEnt->chtvlumabandwidthsvideo = pSiS->chtvlumabandwidthsvideo;
	     pSiSEnt->chtvlumaflickerfilter = pSiS->chtvlumaflickerfilter;
	     pSiSEnt->chtvchromabandwidth = pSiS->chtvchromabandwidth;
	     pSiSEnt->chtvchromaflickerfilter = pSiS->chtvchromaflickerfilter;
	     pSiSEnt->chtvtextenhance = pSiS->chtvtextenhance;
	     pSiSEnt->chtvcontrast = pSiS->chtvcontrast;
	     pSiSEnt->chtvcvbscolor = pSiS->chtvcvbscolor;
	     pSiSEnt->sistvedgeenhance = pSiS->sistvedgeenhance;
	     pSiSEnt->sistvantiflicker = pSiS->sistvantiflicker;
	     pSiSEnt->sistvsaturation = pSiS->sistvsaturation;
	     pSiSEnt->tvxpos = pSiS->tvxpos;
	     pSiSEnt->tvypos = pSiS->tvypos;
	     pSiSEnt->restorebyset = pSiS->restorebyset;
	} else {
	     /* We always use same cursor type on both screens */
	     if(pSiS->HWCursor != pSiSEnt->HWCursor) {
	          pSiS->HWCursor = pSiSEnt->HWCursor;
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  	"Ignoring inconsistent HWCursor setting\n");
	          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		  	"Master head ruled: HWCursor shall be %s\n",
			pSiS->HWCursor ? "enabled" : "disabled");
	     }
	     /* We need to use identical CRT2 Type setting */
	     if(pSiS->ForceCRT2Type != pSiSEnt->ForceCRT2Type) {
                  if(pSiS->ForceCRT2Type != CRT2_DEFAULT) {
		     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		  	"Ignoring inconsistent ForceCRT2Type setting. Master head rules\n");
	          }
	          pSiS->ForceCRT2Type = pSiSEnt->ForceCRT2Type;
	     }
	     if(pSiS->ForceTVType != pSiSEnt->ForceTVType) {
                  if(pSiS->ForceTVType != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		  	"Ignoring inconsistent ForceTVType setting. Master head rules\n");
	          }
	          pSiS->ForceTVType = pSiSEnt->ForceTVType;
	     }
	     /* We need identical TurboQueue setting */
	     if(pSiS->TurboQueue != pSiSEnt->TurboQueue) {
	          pSiS->TurboQueue = pSiSEnt->TurboQueue;
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  	"Ignoring inconsistent TurboQueue setting\n");
	          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		        "Master head ruled: Turboqueue shall be %s\n",
			pSiS->TurboQueue ? "enabled" : "disabled");
	     }
	     /* We need identical PDC setting */
	     if(pSiS->PDC != pSiSEnt->PDC) {
	          pSiS->PDC = pSiSEnt->PDC;
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  	"Ignoring inconsistent PanelDelayCompensation setting\n");
	          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		        "Master head ruled: PanelDelayCompensation shall be %d%s\n",
			pSiS->PDC,
			(pSiS->PDC == -1) ? " (autodetected)" : "");
	     }
	     /* We need identical TVStandard setting */
	     if( (pSiS->OptTVStand != pSiSEnt->OptTVStand) || 
	         (pSiS->NonDefaultPAL != pSiSEnt->NonDefaultPAL) ) {
                  if(pSiS->OptTVStand != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  	"Ignoring inconsistent TVStandard setting\n");
	             xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		        "Master head ruled: TVStandard shall be %s\n",
			(pSiSEnt->OptTVStand ? 
		          ( (pSiSEnt->NonDefaultPAL == -1) ? "PAL" : 
			      ((pSiSEnt->NonDefaultPAL) ? "PALM" : "PALN") )
				           : "NTSC"));
	          }
	          pSiS->OptTVStand = pSiSEnt->OptTVStand;
		  pSiS->NonDefaultPAL = pSiSEnt->NonDefaultPAL;
	     }
	     /* We need identical UseROMData setting */
	     if(pSiS->OptROMUsage != pSiSEnt->OptROMUsage) {
                  if(pSiS->OptROMUsage != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  	"Ignoring inconsistent UseROMData setting\n");
	             xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		        "Master head ruled: Video ROM data usage shall be %s\n",
			pSiSEnt->OptROMUsage ? "enabled" : "disabled");
	          }
	          pSiS->OptROMUsage = pSiSEnt->OptROMUsage;
	     }
	     /* We need identical DSTN setting */
	     if(pSiS->DSTN != pSiSEnt->DSTN) {
	          pSiS->DSTN = pSiSEnt->DSTN;
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  	"Ignoring inconsistent DSTN setting\n");
	          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		        "Master head ruled: DSTN shall be %s\n",
			pSiS->DSTN ? "enabled" : "disabled");
	     }
	     /* We need identical XvOnCRT2 setting */
	     if(pSiS->XvOnCRT2 != pSiSEnt->XvOnCRT2) {
	          pSiS->XvOnCRT2 = pSiSEnt->XvOnCRT2;
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  	"Ignoring inconsistent XvOnCRT2 setting\n");
	          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		        "Master head ruled: Xv shall be used on CRT%d\n",
			pSiS->XvOnCRT2 ? 2 : 1);
	     }
	     /* We need identical NoAccel setting */
	     if(pSiS->NoAccel != pSiSEnt->NoAccel) {
	          pSiS->NoAccel = pSiSEnt->NoAccel;
		  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  	"Ignoring inconsistent NoAccel setting\n");
	          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		        "Master head ruled: Acceleration shall be %s\n",
			pSiS->NoAccel ? "disabled" : "enabled");
	     }
	     /* We need identical ForceCRT1 setting */
	     if(pSiS->forceCRT1 != pSiSEnt->forceCRT1) {
	          if(pSiS->forceCRT1 != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  	"Ignoring inconsistent ForceCRT1 setting\n");
	             xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		        "Master head ruled: CRT1 shall be %s\n",
			pSiSEnt->forceCRT1 ? "enabled" : "disabled");
	          }
	          pSiS->forceCRT1 = pSiSEnt->forceCRT1;
	     }
	     /* We need identical TVOverscan setting */
	     if(pSiS->OptTVOver != pSiSEnt->OptTVOver) {
                  if(pSiS->OptTVOver != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		  	"Ignoring inconsistent CHTVOverscan setting\n");
	             xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		        "Master head ruled: CHTVOverscan shall be %s\n",
			pSiSEnt->OptTVOver ? "true (=overscan)" : "false (=underscan)");
	          }
	          pSiS->OptTVOver = pSiSEnt->OptTVOver;
	     }
	     /* We need identical TVSOverscan setting */
	     if(pSiS->OptTVSOver != pSiSEnt->OptTVSOver) {
	          if(pSiS->OptTVSOver != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     	"Ignoring inconsistent CHTVSuperOverscan setting\n");
	 	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		        "Master head ruled: CHTVSuperOverscan shall be %s\n",
			pSiSEnt->OptTVSOver ? "true" : "false");
		  }
	          pSiS->OptTVSOver = pSiSEnt->OptTVSOver;
	     }
	     /* We need identical TV settings */
	     if(pSiS->chtvtype != pSiSEnt->chtvtype) {
	        if(pSiS->chtvtype != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     	"Ignoring inconsistent CHTVType setting; set to %s\n",
			(pSiSEnt->chtvtype) ? "SCART" : "HDTV");
		}
		pSiS->chtvtype = pSiSEnt->chtvtype;
	     }
             if(pSiS->chtvlumabandwidthcvbs != pSiSEnt->chtvlumabandwidthcvbs) {
	        if(pSiS->chtvlumabandwidthcvbs != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     	"Ignoring inconsistent CHTVLumaBandWidthCVBS setting; set to %d\n",
			pSiSEnt->chtvlumabandwidthcvbs);
		}
		pSiS->chtvlumabandwidthcvbs = pSiSEnt->chtvlumabandwidthcvbs;
	     }
	     if(pSiS->chtvlumabandwidthsvideo != pSiSEnt->chtvlumabandwidthsvideo) {
	        if(pSiS->chtvlumabandwidthsvideo != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     	"Ignoring inconsistent CHTVLumaBandWidthSVIDEO setting; set to %d\n",
			pSiSEnt->chtvlumabandwidthsvideo);
		}
		pSiS->chtvlumabandwidthsvideo = pSiSEnt->chtvlumabandwidthsvideo;
	     }
	     if(pSiS->chtvlumaflickerfilter != pSiSEnt->chtvlumaflickerfilter) {
	        if(pSiS->chtvlumaflickerfilter != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     	"Ignoring inconsistent CHTVLumaFlickerFilter setting; set to %d\n",
			pSiSEnt->chtvlumaflickerfilter);
		}
		pSiS->chtvlumaflickerfilter = pSiSEnt->chtvlumaflickerfilter;
	     }
	     if(pSiS->chtvchromabandwidth != pSiSEnt->chtvchromabandwidth) {
	        if(pSiS->chtvchromabandwidth != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     	"Ignoring inconsistent CHTVChromaBandWidth setting; set to %d\n",
			pSiSEnt->chtvchromabandwidth);
		}
		pSiS->chtvchromabandwidth = pSiSEnt->chtvchromabandwidth;
	     }
	     if(pSiS->chtvchromaflickerfilter != pSiSEnt->chtvchromaflickerfilter) {
	        if(pSiS->chtvchromaflickerfilter != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     	"Ignoring inconsistent CHTVChromaFlickerFilter setting; set to %d\n",
			pSiSEnt->chtvchromaflickerfilter);
		}
		pSiS->chtvchromaflickerfilter = pSiSEnt->chtvchromaflickerfilter;
	     }
	     if(pSiS->chtvcvbscolor != pSiSEnt->chtvcvbscolor) {
	        if(pSiS->chtvcvbscolor != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     	"Ignoring inconsistent CHTVCVBSColor setting; set to %s\n",
			pSiSEnt->chtvcvbscolor ? "true" : "false");
		}
		pSiS->chtvcvbscolor = pSiSEnt->chtvcvbscolor;
	     }
	     if(pSiS->chtvtextenhance != pSiSEnt->chtvtextenhance) {
	        if(pSiS->chtvtextenhance != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     	"Ignoring inconsistent CHTVTextEnhance setting; set to %d\n",
			pSiSEnt->chtvtextenhance);
		}
		pSiS->chtvtextenhance = pSiSEnt->chtvtextenhance;
	     }
	     if(pSiS->chtvcontrast != pSiSEnt->chtvcontrast) {
	        if(pSiS->chtvcontrast != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     	"Ignoring inconsistent CHTVContrast setting; set to %d\n",
			pSiSEnt->chtvcontrast);
		}
		pSiS->chtvcontrast = pSiSEnt->chtvcontrast;
	     }
	     if(pSiS->sistvedgeenhance != pSiSEnt->sistvedgeenhance) {
	        if(pSiS->sistvedgeenhance != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     	"Ignoring inconsistent SISTVEdgeEnhance setting; set to %d\n",
			pSiSEnt->sistvedgeenhance);
		}
		pSiS->sistvedgeenhance = pSiSEnt->sistvedgeenhance;
	     }
	     if(pSiS->sistvantiflicker != pSiSEnt->sistvantiflicker) {
	        if(pSiS->sistvantiflicker != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     	"Ignoring inconsistent SISTVAntiFlicker setting; set to %d\n",
			pSiSEnt->sistvantiflicker);
		}
		pSiS->sistvantiflicker = pSiSEnt->sistvantiflicker;
	     }
	     if(pSiS->sistvsaturation != pSiSEnt->sistvsaturation) {
	        if(pSiS->sistvsaturation != -1) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     	"Ignoring inconsistent SISTVSaturation setting; set to %d\n",
			pSiSEnt->sistvsaturation);
		}
		pSiS->sistvsaturation = pSiSEnt->sistvsaturation;
	     }
	     if(pSiS->tvxpos != pSiSEnt->tvxpos) {
	        if(pSiS->tvxpos != 0) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     	"Ignoring inconsistent TVXPosOffset setting; set to %d\n",
			pSiSEnt->tvxpos);
		}
		pSiS->tvxpos = pSiSEnt->tvxpos;
	     }
	     if(pSiS->tvypos != pSiSEnt->tvypos) {
	        if(pSiS->tvypos != 0) {
		     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		     	"Ignoring inconsistent TVYPosOffset setting; set to %d\n",
			pSiSEnt->tvypos);
		}
		pSiS->tvypos = pSiSEnt->tvypos;
	     }
	     if(pSiS->restorebyset != pSiSEnt->restorebyset) {
		pSiS->restorebyset = pSiSEnt->restorebyset;
	     }
	}
    }
#endif
    /* TW: Handle UseROMData and NoOEM options */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       from = X_PROBED;
       if(pSiS->OptROMUsage == 0)  {
       		pSiS->sishw_ext.UseROM = FALSE;
		from = X_CONFIG;
       }
       xf86DrvMsg(pScrn->scrnIndex, from, "Video ROM data usage is %s\n",
    	   pSiS->sishw_ext.UseROM ? "enabled" : "disabled");

       if(!pSiS->OptUseOEM)
          xf86DrvMsg(pScrn->scrnIndex, from, "Internal OEM LCD/TV data usage is disabled\n");

       if(pSiS->sbiosn) {
         if(pSiS->BIOS) {
           FILE *fd = NULL;
	   int i;
           if((fd = fopen(pSiS->sbiosn, "w" ))) {
	     i = fwrite(pSiS->BIOS, 65536, 1, fd);
	     fclose(fd);
	   }
         }
         xfree(pSiS->sbiosn);
       }
    }

    /* Do basic configuration */
d904 1
a904 9
    pSiS->realFbAddress = pSiS->FbAddress;

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode)
       xf86DrvMsg(pScrn->scrnIndex, from, "Global linear framebuffer at 0x%lX\n",
           (unsigned long)pSiS->FbAddress);
    else 	   
#endif
       xf86DrvMsg(pScrn->scrnIndex, from, "Linear framebuffer at 0x%lX\n",
d918 1
d921 4
a924 1
    pSiS->sishw_ext.bIntegratedMMEnabled = TRUE;
d927 1
a927 1
    if(xf86RegisterResources(pSiS->pEnt->index, NULL, ResExclusive)) {
a929 6
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
	SISFreeRec(pScrn);
d939 2
a940 3
    pSiS->RealVideoRam = pScrn->videoRam;
    if((pSiS->Chipset == PCI_CHIP_SIS6326)
			&& (pScrn->videoRam > 4096)
d943 2
a944 3
        xf86DrvMsg(pScrn->scrnIndex, from,
	       "SiS6326: Detected %d KB VideoRAM, limiting to %d KB\n",
               pSiS->RealVideoRam, pScrn->videoRam);
d949 22
a970 143
    if((pSiS->Chipset == PCI_CHIP_SIS6326) &&
       (pScrn->videoRam > 4096)) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	"SiS6326 engines do not support more than 4096KB RAM, therefore\n");
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
        "TurboQueue, HWCursor, 2D acceleration and XVideo are disabled.\n");
       pSiS->TurboQueue = FALSE;
       pSiS->HWCursor   = FALSE;
       pSiS->NoXvideo   = TRUE;
       pSiS->NoAccel    = TRUE;
    }

    pSiS->FbMapSize = pSiS->availMem = pScrn->videoRam * 1024;
    pSiS->sishw_ext.ulVideoMemorySize = pScrn->videoRam * 1024;
    pSiS->sishw_ext.bSkipDramSizing = TRUE;

    /* TW: Calculate real availMem according to Accel/TurboQueue and
     *     HWCursur setting. Also, initialize some variables used
     *     in other modules.
     */
    pSiS->cursorOffset = 0;
    switch (pSiS->VGAEngine) {
      case SIS_300_VGA:
      	pSiS->TurboQueueLen = 512;
       	if(pSiS->TurboQueue) {
			      pSiS->availMem -= (pSiS->TurboQueueLen*1024);
			      pSiS->cursorOffset = 512;
        }
	if(pSiS->HWCursor)   {
			      pSiS->availMem -= pSiS->CursorSize;
			      if(pSiS->OptUseColorCursor) pSiS->availMem -= pSiS->CursorSize;
	}
	pSiS->CmdQueLenMask = 0xFFFF;
	pSiS->CmdQueLenFix  = 0;
	pSiS->cursorBufferNum = 0;
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->cursorBufferNum = 0;
#endif	
	break;
      case SIS_315_VGA:
       	if(pSiS->TurboQueue) {
			      pSiS->availMem -= (512*1024);  		/* Command Queue is 512k */
			      pSiS->cursorOffset = 512;
	}
	if(pSiS->HWCursor)   {
			      pSiS->availMem -= pSiS->CursorSize;
			      if(pSiS->OptUseColorCursor) pSiS->availMem -= pSiS->CursorSize;
	}
	pSiS->cursorBufferNum = 0;
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->cursorBufferNum = 0;
#endif	
	break;
      default:
        /* TW: cursorOffset not used in cursor functions for 530 and
	 *     older chips, because the cursor is *above* the TQ.
	 *     On 5597 and older revisions of the 6326, the TQ is
	 *     max 32K, on newer 6326 revisions and the 530 either 30
	 *     (or 32?) or 62K (or 64?). However, to make sure, we
	 *     use only 30K (or 32?), but reduce the available memory
	 *     by 64, and locate the TQ at the beginning of this last
	 *     64K block. (We do this that way even when using the
	 *     HWCursor, because the cursor only takes 2K, and the queue
	 *     does not seem to last that far anyway.)
	 *     The TQ must be located at 32KB boundaries.
	 */
	if(pSiS->RealVideoRam < 3072) {
	        if(pSiS->TurboQueue) {
			xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			    "Not enough video RAM for TurboQueue. TurboQueue disabled\n");
		}
		pSiS->TurboQueue = FALSE;
	}
	pSiS->CmdQueMaxLen = 32;
     	if(pSiS->TurboQueue) {
	              	      pSiS->availMem -= (64*1024);
			      pSiS->CmdQueMaxLen = 900;   /* TW: To make sure; should be 992 */
	} else if (pSiS->HWCursor) {
	                      pSiS->availMem -= pSiS->CursorSize;
	}
	if(pSiS->Chipset == PCI_CHIP_SIS530) {
		/* TW: Check if Flat Panel is enabled */
		inSISIDXREG(SISSR, 0x0e, tempreg);
		if(!tempreg & 0x04) pSiS->availMem -= pSiS->CursorSize;

		/* TW: Set up mask for MMIO register */
		pSiS->CmdQueLenMask = (pSiS->TurboQueue) ? 0x1FFF : 0x00FF;
	} else {
	        /* TW: TQ is never used on 6326/5597, because the accelerator
		 *     always Syncs. So this is just cosmentic work. (And I
		 *     am not even sure that 0x7fff is correct. MMIO 0x83a8
		 *     holds 0xec0 if (30k) TQ is enabled, 0x20 if TQ disabled.
		 *     The datasheet has no real explanation on the queue length
		 *     if the TQ is enabled. Not syncing and waiting for a
		 *     suitable queue length instead does not work.
		 */
	        pSiS->CmdQueLenMask = (pSiS->TurboQueue) ? 0x7FFF : 0x003F;
	}

	/* TW: This is to be subtracted from MMIO queue length register contents
	 *     for getting the real Queue length.
	 */
	pSiS->CmdQueLenFix  = (pSiS->TurboQueue) ? 32 : 0;
    }

#ifdef SISDUALHEAD
    /* TW: In dual head mode, we share availMem equally - so align it
     *     to 8KB; this way, the address of the FB of the second
     *     head is aligned to 4KB for mapping.
     */
   if (pSiS->DualHeadMode)
	pSiS->availMem &= 0xFFFFE000;
#endif

    /* TW: Check MaxXFBMem setting */
#ifdef SISDUALHEAD
    /* TW: Since DRI is not supported in dual head mode, we
           don't need MaxXFBMem setting. */
    if (pSiS->DualHeadMode) {
        if(pSiS->maxxfbmem) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"MaxXFBMem not used in Dual Head mode. Using all VideoRAM.\n");
        }
	pSiS->maxxfbmem = pSiS->availMem;
    } else
#endif
      if (pSiS->maxxfbmem) {
    	if (pSiS->maxxfbmem > pSiS->availMem) {
	    if (pSiS->sisfbMem) {
	       pSiS->maxxfbmem = pSiS->sisfbMem * 1024;
	       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                "Invalid MaxXFBMem setting. Using sisfb heap start information\n");
	    } else {
	       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                "Invalid MaxXFBMem setting. Using all VideoRAM for framebuffer\n");
	       pSiS->maxxfbmem = pSiS->availMem;
	    }
	} else if (pSiS->sisfbMem) {
	   if (pSiS->maxxfbmem > pSiS->sisfbMem * 1024) {
	       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "MaxXFBMem beyond sisfb heap start. Using sisfb heap start information\n");
               pSiS->maxxfbmem = pSiS->sisfbMem * 1024;
	   }
d972 1
a972 7
    } else if (pSiS->sisfbMem) {
         pSiS->maxxfbmem = pSiS->sisfbMem * 1024;
    }
    else pSiS->maxxfbmem = pSiS->availMem;

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using %dK of framebuffer memory\n",
    	pSiS->maxxfbmem / 1024);
d974 1
a974 75
    /* TW: Check if the chipset supports two video overlays */
    pSiS->Flags650 = 0;
    if ( (!pSiS->NoXvideo) &&
            ( pSiS->VGAEngine == SIS_300_VGA ||
              pSiS->VGAEngine == SIS_315_VGA ||
	      pSiS->Chipset == PCI_CHIP_SIS530 ||
	      pSiS->Chipset == PCI_CHIP_SIS6326 ||
	      pSiS->Chipset == PCI_CHIP_SIS5597 ) ) {
       pSiS->hasTwoOverlays = FALSE;
       switch (pSiS->Chipset) {
         case PCI_CHIP_SIS300:
         case PCI_CHIP_SIS630:
         case PCI_CHIP_SIS550: 
         case PCI_CHIP_SIS330:  /* ? */
           pSiS->hasTwoOverlays = TRUE;
	   break;
         case PCI_CHIP_SIS650:
	   {
	     static const char *id650str[] = {
	   	"0",       "0",        "0",       "0",
		"0 A0 AA", "0 A2 CA",  "0",       "0",
		"0M A0",   "0M A1 AA", "1 A0 AA", "1 A1 AA"
		"0",       "0",        "0",       "0"
	     };
             inSISIDXREG(SISCR, 0x5F, CR5F);
	     CR5F &= 0xf0;
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	"SiS650 revision ID %x (SiS65%s)\n", CR5F, id650str[CR5F >> 4]);
	     if((CR5F == 0x80) || (CR5F == 0x90) || (CR5F == 0xa0) || (CR5F == 0xb0)) {
	        pSiS->hasTwoOverlays = TRUE;  /* TW: This is an M650 or 651 */
		pSiS->Flags650 |= SiS650_LARGEOVERLAY;
	     }
             break;
	   }
       }
       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		"Hardware supports %s video overlay%s\n",
		pSiS->hasTwoOverlays ? "two" : "one",
		pSiS->hasTwoOverlays ? "s" : "");
    }

    /* TW: Backup VB connection and CRT1 on/off register */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
    	inSISIDXREG(SISCR, 0x32, pSiS->oldCR32);
	inSISIDXREG(SISCR, 0x17, pSiS->oldCR17);
	pSiS->postVBCR32 = pSiS->oldCR32;
    }

    if(pSiS->forceCRT1 != -1) {
        if(pSiS->forceCRT1) pSiS->CRT1off = 0;
	else                pSiS->CRT1off = 1;
    } else                  pSiS->CRT1off = -1;

    /* TW: There are some strange machines out there which require a special
     *     manupulation of ISA bridge registers in order to make the Chrontel
     *     work. Try to find out if we're running on such a machine.
     */
    pSiS->SiS_Pr->SiS_ChSW = FALSE;
    if(pSiS->Chipset == PCI_CHIP_SIS630) {
        int i=0;
        do {
	    if(mychswtable[i].subsysVendor == pSiS->PciInfo->subsysVendor &&
	       mychswtable[i].subsysCard == pSiS->PciInfo->subsysCard) {
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	           "PCI card/vendor found in list for Chrontel/ISA bridge poking\n");
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		   "Vendor: %s (ID %04x)\n",
		   mychswtable[i].vendorName, pSiS->PciInfo->subsysCard);
		pSiS->SiS_Pr->SiS_ChSW = TRUE;
            }
            i++;
        } while(mychswtable[i].subsysVendor != 0);
    }

    /* TW: Detect video bridge and sense connected devices */
a975 2
    /* TW: Detect CRT1  */
    SISCRT1PreInit(pScrn);
a981 4

    /* TW: Backup detected CRT2 devices */
    pSiS->detectedCRT2Devices = pSiS->VBFlags & (CRT2_LCD | CRT2_TV | CRT2_VGA);

d983 3
a985 2
    if(pSiS->ForceCRT2Type == CRT2_DEFAULT) {
        if(pSiS->VBFlags & CRT2_VGA)
d987 1
a987 1
        else if(pSiS->VBFlags & CRT2_LCD)
d989 1
a989 1
        else if(pSiS->VBFlags & CRT2_TV)
d992 3
a994 3

    switch(pSiS->ForceCRT2Type) {
      case CRT2_TV:
d996 1
a996 1
        if(pSiS->VBFlags & VB_VIDEOBRIDGE)
d1001 1
a1001 1
      case CRT2_LCD:
d1003 1
a1003 1
        if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (pSiS->VBLCDFlags))
d1005 1
a1005 1
        else {
a1006 3
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Can't force CRT2 to LCD, no panel detected\n");
	}
d1008 1
a1008 11
      case CRT2_VGA:
        if(pSiS->VBFlags & VB_LVDS) {
	   xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	      "LVDS does not support secondary VGA\n");
	   break;
	}
	if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
	   xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	      "SiS30xLV bridge does not support secondary VGA\n");
	   break;
	}
d1010 1
a1010 1
        if(pSiS->VBFlags & VB_VIDEOBRIDGE)
d1019 1
a1019 55
    /* TW: Eventually overrule TV Type (SVIDEO, COMPOSITE, SCART) */
    if(pSiS->ForceTVType != -1) {
        if(pSiS->VBFlags & VB_SISBRIDGE) {
    	   pSiS->VBFlags &= ~(TV_INTERFACE);
	   pSiS->VBFlags |= pSiS->ForceTVType;
	}
    }

    /* TW: Handle ForceCRT1 option */
    pSiS->CRT1changed = FALSE;
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       usScratchCR17 = pSiS->oldCR17;
       usScratchCR32 = pSiS->postVBCR32;
       if(pSiS->VESA != 1) {
          /* TW: Copy forceCRT1 option to CRT1off if option is given */
#ifdef SISDUALHEAD
          /* TW: In DHM, handle this option only for master head, not the slave */
          if( (pSiS->forceCRT1 != -1) &&
	       (!(pSiS->DualHeadMode && pSiS->SecondHead)) ) {
#else
          if(pSiS->forceCRT1 != -1) {
#endif
             xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "CRT1 detection overruled by ForceCRT1 option\n");
    	     if(pSiS->forceCRT1) {
		 pSiS->CRT1off = 0;
		 if (!(usScratchCR17 & 0x80)) pSiS->CRT1changed = TRUE;
		 usScratchCR17 |= 0x80;
		 usScratchCR32 |= 0x20;
	     } else {
	         if( ! ( (pScrn->bitsPerPixel == 8) &&
		         ( (pSiS->VBFlags & VB_LVDS) ||
		           ((pSiS->VGAEngine == SIS_300_VGA) && (pSiS->VBFlags & VB_301B)) ) ) ) {
		    pSiS->CRT1off = 1;
		    if (usScratchCR17 & 0x80) pSiS->CRT1changed = TRUE;
		    usScratchCR32 &= ~0x20;
		    /* TW: We must not actually switch off CRT1 before we changed the mode! */
		 }
	     }
	     outSISIDXREG(SISCR, 0x17, usScratchCR17);
	     outSISIDXREG(SISCR, 0x32, usScratchCR32);
	     if(pSiS->CRT1changed) {
                outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
	        usleep(10000);
                outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	   		"CRT1 status changed by ForceCRT1 option\n");
	     }
          }
       }
       /* TW: Store the new VB connection register contents for later mode changes */
       pSiS->newCR32 = usScratchCR32;
    }

    /* TW: Check if CRT1 used (or needed; this eg. if no CRT2 detected) */
d1021 1
a1021 8
    
        /* TW: No CRT2 output? Then we NEED CRT1!
	 *     We also need CRT1 if depth = 8 and bridge=LVDS|630+301B
	 */
        if ( (!(pSiS->VBFlags & (CRT2_VGA | CRT2_LCD | CRT2_TV))) ||
	     ( (pScrn->bitsPerPixel == 8) &&
	       ( (pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) ||
	         ((pSiS->VGAEngine == SIS_300_VGA) && (pSiS->VBFlags & VB_301B)) ) ) ) {
d1023 2
a1024 8
	}
	/* TW: No CRT2 output? Then we can't use Xv on CRT2 */
	if (!(pSiS->VBFlags & (CRT2_VGA | CRT2_LCD | CRT2_TV)))
	    pSiS->XvOnCRT2 = FALSE;

    } else { /* TW: no video bridge? */

        /* Then we NEED CRT1... */
a1025 59
	/* ... and can't use CRT2 for Xv output */
	pSiS->XvOnCRT2 = FALSE;
    }

    /* TW: Handle TVStandard option */
    if(pSiS->NonDefaultPAL != -1) {
        if( (!(pSiS->VBFlags & VB_SISBRIDGE)) &&
	    (!((pSiS->VBFlags & VB_CHRONTEL)) && (pSiS->ChrontelType == CHRONTEL_701x)) ) {
	   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	   	"PALM and PALN only supported on Chrontel 701x and SiS30x/B/LV\n");
 	   pSiS->NonDefaultPAL = -1; 
	   pSiS->VBFlags &= ~(TV_PALN | TV_PALM);
	}
    }
    if(pSiS->NonDefaultPAL != -1) {
        if((pSiS->Chipset == PCI_CHIP_SIS300) || (pSiS->Chipset == PCI_CHIP_SIS540)) {
	   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	   	"PALM and PALN not supported on SiS300 and SiS540\n");
	   pSiS->NonDefaultPAL = -1; 
	   pSiS->VBFlags &= ~(TV_PALN | TV_PALM);
	}
    }
    if(pSiS->OptTVStand != -1) {
        if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	   if(!(pSiS->Flags & (TV_CHSCART | TV_CHHDTV))) {
    	      pSiS->VBFlags &= ~(TV_PAL | TV_NTSC | TV_PALN | TV_PALM);
    	      if(pSiS->OptTVStand) pSiS->VBFlags |= TV_PAL;
	      else                 pSiS->VBFlags |= TV_NTSC;
              if(pSiS->NonDefaultPAL == 1)  pSiS->VBFlags |= TV_PALM;
	      else if(!pSiS->NonDefaultPAL) pSiS->VBFlags |= TV_PALN;
	   } else {
	      pSiS->OptTVStand = pSiS->NonDefaultPAL = -1;
	      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	   	"Option TVStandard ignored for SCART and 480i HDTV\n");
	   }
	} else if(pSiS->Chipset == PCI_CHIP_SIS6326) {
	   pSiS->SiS6326Flags &= ~SIS6326_TVPAL;
	   if(pSiS->OptTVStand) pSiS->SiS6326Flags |= SIS6326_TVPAL;
	}
    }

    /* TW: Do some checks */
    if(pSiS->OptTVOver != -1) {
        if(pSiS->VBFlags & VB_CHRONTEL) {
	   pSiS->UseCHOverScan = pSiS->OptTVOver;
	} else {
	   xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
	    	"CHTVOverscan option only supported on CHRONTEL 70xx\n");
           pSiS->UseCHOverScan = -1;
	}
    } else pSiS->UseCHOverScan = -1;
    
    if(pSiS->sistvedgeenhance != -1) {
        if(!(pSiS->VBFlags & VB_301)) {
	   xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
	       "SISTVEdgeEnhance option only supported on SiS301\n");
	   pSiS->sistvedgeenhance = -1;
	}
    }
d1027 3
a1029 20
    /* TW: Determine CRT1<>CRT2 mode
     *     Note: When using VESA or if the bridge is in slavemode, display
     *           is ALWAYS in MIRROR_MODE!
     *           This requires extra checks in functions using this flag!
     *           (see sis_video.c for example)
     */
    if(pSiS->VBFlags & DISPTYPE_DISP2) {
        if(pSiS->CRT1off) {	/* TW: CRT2 only ------------------------------- */
#ifdef SISDUALHEAD
	     if(pSiS->DualHeadMode) {
	     	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "CRT1 not detected or forced off. Dual Head mode can't initialize.\n");
	     	if(pSiSEnt) pSiSEnt->DisableDual = TRUE;
	        if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
		if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
		sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
		SISFreeRec(pScrn);
		return FALSE;
	     }
#endif
d1031 3
a1033 28
	     /* TW: No CRT1? Then we use the video overlay on CRT2 */
	     pSiS->XvOnCRT2 = TRUE;
	} else			/* TW: CRT1 and CRT2 - mirror or dual head ----- */
#ifdef SISDUALHEAD
	     if(pSiS->DualHeadMode) {
		pSiS->VBFlags |= (VB_DISPMODE_DUAL | DISPTYPE_CRT1);
	        if(pSiS->VESA != -1) {
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"VESA option not used in Dual Head mode. VESA disabled.\n");
		}
		if (pSiSEnt) pSiSEnt->DisableDual = FALSE;
		pSiS->VESA = 0;
	     } else
#endif
		 pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_CRT1);
    } else {			/* TW: CRT1 only ------------------------------- */
#ifdef SISDUALHEAD
	     if(pSiS->DualHeadMode) {
	     	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "No CRT2 output selected or no bridge detected. "
		   "Dual Head mode can't initialize.\n");
	        if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
		if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
		sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
		SISFreeRec(pScrn);
		return FALSE;
	     }
#endif
a1034 11
    }

    if( (pSiS->VGAEngine == SIS_315_VGA) ||
        (pSiS->VGAEngine == SIS_300_VGA) ) {
       if ( (!pSiS->NoXvideo) &&
         (!pSiS->hasTwoOverlays) ) {
	       xf86DrvMsg(pScrn->scrnIndex, from,
	  		"Using Xv overlay on CRT%d\n",
			pSiS->XvOnCRT2 ? 2 : 1);
       }
    }
a1035 1
    /* TW: Init Ptrs for Save/Restore functions and calc MaxClock */
d1038 2
a1039 220
    /* ********** end of VBFlags setup ********** */

    /* TW: VBFlags are initialized now. Back them up for SlaveMode modes. */
    pSiS->VBFlags_backup = pSiS->VBFlags;

    /* TW: Find out about paneldelaycompensation and evaluate option */
    pSiS->sishw_ext.pdc = 0;

    if(pSiS->VGAEngine == SIS_300_VGA) {

        if(pSiS->VBFlags & (VB_LVDS | VB_301B | VB_302B)) {
	   /* TW: Save the current PDC if the panel is used at the moment.
	    *     This seems by far the safest way to find out about it.
	    *     If the system is using an old version of sisfb, we can't
	    *     trust the pdc register value. If sisfb saved the pdc for
	    *     us, use it.
	    */
	   if(pSiS->sisfbpdc) {
	      pSiS->sishw_ext.pdc = pSiS->sisfbpdc;
	   } else {
	     if(!(pSiS->donttrustpdc)) {
	       unsigned char tmp;
	       inSISIDXREG(SISCR, 0x30, tmp);
	       if(tmp & 0x20) {
	         inSISIDXREG(SISPART1, 0x13, pSiS->sishw_ext.pdc);
               } else {
	         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	       	     "Unable to detect LCD PanelDelayCompensation, LCD is not active\n");
	       }
	     } else {
	       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	       	  "Unable to detect LCD PanelDelayCompensation, please update sisfb\n");
	     }
	   }
	   pSiS->sishw_ext.pdc &= 0x3c;
	   if(pSiS->sishw_ext.pdc) {
	      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	       	  "Detected LCD PanelDelayCompensation %d\n",
		  pSiS->sishw_ext.pdc);
	   }

	   /* If we haven't been able to find out, use our other methods */
	   if(pSiS->sishw_ext.pdc == 0) {

                 int i=0;
                 do {
	            if(mypdctable[i].subsysVendor == pSiS->PciInfo->subsysVendor &&
	               mypdctable[i].subsysCard == pSiS->PciInfo->subsysCard) {
	                  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	   	            "PCI card/vendor found in list for non-default PanelDelayCompensation\n");
		          xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		             "Vendor: %s, card: %s (ID %04x), PanelDelayCompensation: %d\n",
		             mypdctable[i].vendorName, mypdctable[i].cardName,
		             pSiS->PciInfo->subsysCard, mypdctable[i].pdc);
                          if(pSiS->PDC == -1) {
		             pSiS->PDC = mypdctable[i].pdc;
		          } else {
		             xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       	        "PanelDelayCompensation overruled by option\n");
		          }
	                  break;
                    }
	            i++;
                 } while(mypdctable[i].subsysVendor != 0);

            }

	    if(pSiS->PDC != -1) {
	       if(pSiS->BIOS) {
	          if(pSiS->VBFlags & VB_LVDS) {
	             if(pSiS->BIOS[0x220] & 0x80) {
                        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		             "BIOS contains custom LCD Panel Delay Compensation %d\n",
		             pSiS->BIOS[0x220] & 0x3c);
	                pSiS->BIOS[0x220] &= 0x7f;
		     }
	          }
	          if(pSiS->VBFlags & (VB_301B|VB_302B)) {
	             if(pSiS->BIOS[0x220] & 0x80) {
                        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		             "BIOS contains custom LCD Panel Delay Compensation %d\n",
		               (  (pSiS->VBLCDFlags & VB_LCD_1280x1024) ?
			                 pSiS->BIOS[0x223] : pSiS->BIOS[0x224]  ) & 0x3c);
	                pSiS->BIOS[0x220] &= 0x7f;
		     }
		  }
	       }
	       pSiS->sishw_ext.pdc = (pSiS->PDC & 0x3c);
	       xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	            "Using LCD Panel Delay Compensation %d\n", pSiS->PDC);
	    }
	}
    }

#ifdef SISDUALHEAD
    /* TW: In dual head mode, both heads (currently) share the maxxfbmem equally.
     *     If memory sharing is done differently, the following has to be changed;
     *     the other modules (eg. accel and Xv) use dhmOffset for hardware
     *     pointer settings relative to VideoRAM start and won't need to be changed.
     */
    if (pSiS->DualHeadMode) {
        if (pSiS->SecondHead == FALSE) {
	    /* ===== First head (always CRT2) ===== */
	    /* We use only half of the memory available */
	    pSiS->maxxfbmem /= 2;
	    /* Initialize dhmOffset */
	    pSiS->dhmOffset = 0;
	    /* Copy framebuffer addresses & sizes to entity */
	    pSiSEnt->masterFbAddress = pSiS->FbAddress;
	    pSiSEnt->masterFbSize    = pSiS->maxxfbmem;
	    pSiSEnt->slaveFbAddress  = pSiS->FbAddress + pSiS->maxxfbmem;
	    pSiSEnt->slaveFbSize     = pSiS->maxxfbmem;
	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	    		"%dKB video RAM at 0x%lx available for master head (CRT2)\n",
	    		pSiS->maxxfbmem/1024, pSiS->FbAddress);
	} else {
	    /* ===== Second head (always CRT1) ===== */
	    /* We use only half of the memory available */
	    pSiS->maxxfbmem /= 2;
	    /* Adapt FBAddress */
	    pSiS->FbAddress += pSiS->maxxfbmem;
	    /* Initialize dhmOffset */
	    pSiS->dhmOffset = pSiS->availMem - pSiS->maxxfbmem;
	    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	    		"%dKB video RAM at 0x%lx available for slave head (CRT1)\n",
	    		pSiS->maxxfbmem/1024,  pSiS->FbAddress);
	}
    } else
        pSiS->dhmOffset = 0;
#endif

    /* TW: Note: Do not use availMem for anything from now. Use
     *     maxxfbmem instead. (availMem does not take dual head
     *     mode into account.)
     */

    /* TW: Now for something completely different: DDC.
           For 300 and 310/325 series, we provide our
	   own functions (in order to probe CRT2 as well)
	   If these fail, use the VBE.
	   All other chipsets will use VBE. No need to re-invent
	   the wheel there.
     */

    pSiS->pVbe = NULL;
    didddc2 = FALSE;

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	if(xf86LoadSubModule(pScrn, "ddc")) {
          xf86LoaderReqSymLists(ddcSymbols, NULL);
	  if((pMonitor = SiSDoPrivateDDC(pScrn))) {
	     didddc2 = TRUE;
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	"DDC monitor info:\n");
	     xf86PrintEDID(pMonitor);
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	"End of DDC monitor info\n");
	     xf86SetDDCproperties(pScrn, pMonitor);
	     pScrn->monitor->DDC = pMonitor;
          }
	}
    }

#ifdef SISDUALHEAD
    /* TW: In dual head mode, probe DDC using VBE only for CRT1 (second head) */
    if((pSiS->DualHeadMode) && (!didddc2) && (!pSiS->SecondHead))
         didddc2 = TRUE;
#endif

    /* TW: If CRT1 is off (eventually forced), skip DDC */
    if((!didddc2) && (pSiS->CRT1off)) didddc2 = TRUE;

    /* TW: Now (re-)load and initialize the DDC module */
    if(!didddc2) {

       if(xf86LoadSubModule(pScrn, "ddc")) {

          xf86LoaderReqSymLists(ddcSymbols, NULL);

          /* TW: Now load and initialize VBE module. */
          if(xf86LoadSubModule(pScrn, "vbe")) {
	      xf86LoaderReqSymLists(vbeSymbols, NULL);
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	      pSiS->pVbe = VBEInit(pSiS->pInt,pSiS->pEnt->index);
#else
              pSiS->pVbe = VBEExtendedInit(pSiS->pInt,pSiS->pEnt->index,
	                SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
#endif
              if(!pSiS->pVbe) {
	         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	            "Could not initialize VBE module for DDC\n");
              }
          } else {
              xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	          "Could not load VBE module for DDC\n");
          }

  	  if(pSiS->pVbe) {
	      if((pMonitor = vbeDoEDID(pSiS->pVbe,NULL))) {
	         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	      "VBE DDC monitor info:\n");
                 xf86SetDDCproperties(pScrn, xf86PrintEDID(pMonitor));
		 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	      "End of VBE DDC monitor info:\n");
		 pScrn->monitor->DDC = pMonitor;
              }
          } else {
	      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"Could not retrieve DDC data\n");
	  }
       }
    }

#if 0	/* TW: DDC1 obviously no longer supported by SiS chipsets */
    if (!ret && pSiS->ddc1Read)
        xf86SetDDCproperties(pScrn, xf86PrintEDID(xf86DoEDID_DDC1(
             pScrn->scrnIndex,vgaHWddc1SetSpeed,pSiS->ddc1Read )));
#endif

    /* end of DDC */
d1042 1
a1042 1
    pSiS->MinClock = 12000;  /* XXX Guess, need to check this (TW: good for even 50Hz interlace) */
d1051 1
a1051 1
    if(pSiS->pEnt->device->dacSpeeds[0]) {
d1053 2
a1054 1
        switch(pScrn->bitsPerPixel) {
d1068 1
a1068 1
        if(speed == 0)
d1087 1
a1087 117
    clockRanges->doubleScanAllowed = TRUE;

    /* TW: If there is no HSync or VRefresh data for the monitor,
           derive it from DDC data. (Idea taken from radeon driver)
     */
    if(pScrn->monitor->DDC) {
       if(pScrn->monitor->nHsync <= 0) {
         xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	 	"Substituting missing monitor HSync data by DDC data\n");
         SiSSetSyncRangeFromEdid(pScrn, 1);
       }
       if(pScrn->monitor->nVrefresh <= 0) {
         xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	 	"Substituting missing monitor VRefresh data by DDC data\n");
         SiSSetSyncRangeFromEdid(pScrn, 0);
       }
    }

    /*
     * TW: Since we have lots of built-in modes for 300/310/325/330 series
     *     with vb support, we replace the given default mode list with our 
     *     own. In case the video bridge is to be used, no other than our 
     *     built-in modes are supported; therefore, delete the entire modelist
     *     given.
     */
     
    pSiS->HaveCustomModes = FALSE;
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
      if(!(pSiS->noInternalModes)) {
        if((mymodes = SiSBuildBuiltInModeList(pScrn))) {
#ifdef SISDUALHEAD
    	   if( (pSiS->UseVESA) || 
	       ((pSiS->DualHeadMode) && (!pSiS->SecondHead)) ||
	       ((!pSiS->DualHeadMode) && (pSiS->VBFlags & DISPTYPE_DISP2)) ) {
#else	
	   if((pSiS->UseVESA) || (pSiS->VBFlags & DISPTYPE_DISP2)) {
#endif	   
	      while(pScrn->monitor->Modes)
                 xf86DeleteMode(&pScrn->monitor->Modes, pScrn->monitor->Modes);
	      pScrn->monitor->Modes = mymodes;
	   } else {
	      delmode = pScrn->monitor->Modes;
	      while(delmode) {
	         if(delmode->type & M_T_DEFAULT) {
	            tempmode = delmode->next;
	            xf86DeleteMode(&pScrn->monitor->Modes, delmode);
	            delmode = tempmode;
	         } else {
	            delmode = delmode->next;
	         }
	      }
	      tempmode = pScrn->monitor->Modes;
	      if(tempmode) pSiS->HaveCustomModes = TRUE;
	      pScrn->monitor->Modes = mymodes;
	      while(mymodes) {
	         if(!mymodes->next) break;
		 else mymodes = mymodes->next;
	      }
	      mymodes->next = tempmode;
	      if(tempmode) {
	         tempmode->prev = mymodes;
	      }
	   }	   
	   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	        "Replaced %s mode list with built-in modes\n", 
		pSiS->HaveCustomModes ? "default" : "entire");
#ifdef TWDEBUG
           pScrn->modes = pScrn->monitor->Modes;
	   xf86PrintModes(pScrn);
	   pScrn->modes = NULL;
#endif		
        } else {
	   xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	   	"Building list of built-in modes failed, using XFree86 defaults\n");
	}
      }
    }

    /*
     * TW: Add our built-in modes for TV on the 6326
     */
    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
      if(pSiS->SiS6326Flags & SIS6326_TVDETECTED) {
         xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	 	"Adding %s TV modes for 6326 to mode list:\n",
		(pSiS->SiS6326Flags & SIS6326_TVPAL) ? "PAL" : "NTSC");
         if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
            SiS6326PAL800x600Mode.next = pScrn->monitor->Modes;
            pScrn->monitor->Modes = &SiS6326PAL640x480Mode;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	     	"\"PAL800x600\" \"PAL800x600U\" \"PAL720x540\" \"PAL640x480\"\n");
	 } else {
	    SiS6326NTSC640x480Mode.next = pScrn->monitor->Modes;
            pScrn->monitor->Modes = &SiS6326NTSC640x400Mode;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	     	"\"NTSC640x480\" \"NTSC640x480U\" \"NTSC640x400\"\n");
	 }
      }
    }

    /*
     * TW: Add our built-in hi-res modes on the 6326
     */
    if(pSiS->Chipset == PCI_CHIP_SIS6326) {
       if(pScrn->bitsPerPixel == 8) {
          SiS6326SIS1600x1200_60Mode.next = pScrn->monitor->Modes;
          pScrn->monitor->Modes = &SiS6326SIS1600x1200_60Mode;
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	  	"Adding mode \"SIS1600x1200-60\" (depth 8 only)\n");
       }
       if(pScrn->bitsPerPixel <= 16) {
          SiS6326SIS1280x1024_75Mode.next = pScrn->monitor->Modes;
          pScrn->monitor->Modes = &SiS6326SIS1280x1024_75Mode;
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	  	"Adding mode \"SIS1280x1024-75\" (depth 8, 15 and 16 only)\n");
       }
    }
a1088 7
    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,	
    	  "\"Unknown reason\" in the following list means that the mode\n");
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,	
    	  "is not supported on the chipset/bridge/current output device.\n");
    }
	
d1098 2
a1099 2
     * Assuming min pitch 256, max 4096 ==> 8192
     * Assuming min height 128, max 4096
d1110 1
a1110 8
    if(i == -1) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"xf86ValidateModes() error\n");
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
a1114 118
    /* TW: Go through mode list and mark all those modes as bad,
     *     - which are unsuitable for dual head mode (if running dhm),
     *     - which exceed the LCD panels specs (if running on LCD)
     *     - TODO: which exceed TV capabilities (if running on TV)
     *     Also, find the highest used pixelclock on the master head.
     */
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       if(!pSiS->SecondHead) pSiSEnt->maxUsedClock = 0;
    }
#endif
    if((p = first = pScrn->modes)) {
         do {
	       n = p->next;

               /* TW: Check the modes if they comply with our built-in tables.
	        *     This is of practical use only if the user disabled the
	        *     usage of the internal (built-in) modes.
		*/
               if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	         if(p->type & M_T_DEFAULT) {  
	           if( ( (strcmp(p->name, "320x200") != 0) &&
		         (strcmp(p->name, "320x240") != 0) &&
		         (strcmp(p->name, "400x300") != 0) &&
		         (strcmp(p->name, "512x384") != 0) )  &&
                       (p->Flags & V_DBLSCAN) ) {
		           p->status = MODE_NO_DBLESCAN;
		           xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			        "Not using mode \"%s\" (mode not supported as doublescan)\n", p->name);
                   }
		   if( ( (strcmp(p->name, "1024x768")  != 0) &&
		         (strcmp(p->name, "1280x1024") != 0) &&
			 (strcmp(p->name, "848x480")   != 0) &&
			 (strcmp(p->name, "856x480")   != 0))  &&
                       (p->Flags & V_INTERLACE) ) {
		           p->status = MODE_NO_INTERLACE;
		           xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			        "Not using mode \"%s\" (mode not supported as interlaced)\n", p->name);
                   }
		   if( ( (strcmp(p->name, "320x200") == 0) ||
		         (strcmp(p->name, "320x240") == 0) ||
		         (strcmp(p->name, "400x300") == 0) ||
		         (strcmp(p->name, "512x384") == 0) )  &&
		       (!(p->Flags & V_DBLSCAN)) ) {
		       	   p->status = MODE_CLOCK_RANGE;
			   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			        "Not using mode \"%s\" (only supported as doublescan)\n", p->name);
		   }
		 }
	       }
#ifdef SISDUALHEAD
	       /* TW: Modes that require the bridge to operate in SlaveMode
                *     are not suitable for Dual Head mode. Also check for
		*     modes that exceed panel dimension.
                */
               if(pSiS->DualHeadMode) {
	          if(pSiS->SecondHead == FALSE) {
	             if( (strcmp(p->name, "320x200") == 0) ||
		         (strcmp(p->name, "320x240") == 0) ||
		         (strcmp(p->name, "400x300") == 0) ||
		         (strcmp(p->name, "512x384") == 0) ||
		         (strcmp(p->name, "640x400") == 0) )  {
	    	        p->status = MODE_BAD;
		        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "Not using mode \"%s\" (not suitable for dual head mode)\n",
			   p->name);
		     }
                  }
                  if(pSiS->VBFlags & DISPTYPE_DISP2) {
	            if(pSiS->VBFlags & CRT2_LCD) {
		      if(pSiS->SecondHead == FALSE) {
		        if((p->HDisplay > pSiS->LCDwidth) || (p->VDisplay > pSiS->LCDheight)) {
		            p->status = MODE_PANEL;
		            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			      "Not using mode \"%s\" (exceeds LCD panel dimension)\n", p->name);
	                }
			if(p->Flags & V_INTERLACE) {
			    p->status = MODE_BAD;
			    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			        "Not using mode \"%s\" (interlace on LCD not supported)\n",
				p->name);
			}
		      }
		    }
		    /* TO DO: TV */
	          }
		  /* TW: Search for the highest clock on first head in order to calculate
		   *     max clock for second head (CRT1)
		   */
		  if(!pSiS->SecondHead) {
		     if((p->status == MODE_OK) && (p->Clock > pSiSEnt->maxUsedClock)) {
		  		pSiSEnt->maxUsedClock = p->Clock;
		     }
		  }
	       } else {
#endif
	          if(pSiS->VBFlags & DISPTYPE_DISP2) {
	              if(pSiS->VBFlags & CRT2_LCD) {
		          if((p->HDisplay > pSiS->LCDwidth) || (p->VDisplay > pSiS->LCDheight)) {
		            p->status = MODE_PANEL;
		            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			        "Not using mode \"%s\" (exceeds LCD panel dimension)\n", p->name);
	                  }
			  if(p->Flags & V_INTERLACE) {
			    p->status = MODE_BAD;
			    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			        "Not using mode \"%s\" (interlace on LCD not supported)\n",
				p->name);
			  }
		      }
	          }
#ifdef SISDUALHEAD
               }
#endif
	       p = n;
         } while (p != NULL && p != first);
    }

d1118 1
a1118 1
    if(i == 0 || pScrn->modes == NULL) {
a1119 5
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
a1128 4
    /* TW: Copy to CurrentLayout */
    pSiS->CurrentLayout.mode = pScrn->currentMode;
    pSiS->CurrentLayout.displayWidth = pScrn->displayWidth;

a1131 13
#ifdef SISDUALHEAD
    /* TW: Due to palette & timing problems we don't support 8bpp in DHM */
    if((pSiS->DualHeadMode) && (pScrn->bitsPerPixel == 8)) {
    	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"Colordepth 8 not supported in Dual Head mode.\n");
	if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
        SISFreeRec(pScrn);
        return FALSE;
    }
#endif

d1136 2
a1137 2
    switch(pScrn->bitsPerPixel) {
      case 1:
d1141 1
a1141 1
      case 4:
d1145 4
a1148 4
      case 8:
      case 16:
      case 24:
      case 32:
d1153 1
a1153 8
    if(mod && xf86LoadSubModule(pScrn, mod) == NULL) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Could not load %s module", mod);
#ifdef SISDUALHEAD
	if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
d1158 2
a1159 2
    if(mod) {
	if(Sym) {
d1166 7
d1174 3
a1176 10
    if(!pSiS->NoAccel) {
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Accel enabled\n");
        if(!xf86LoadSubModule(pScrn, "xaa")) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Could not load xaa module\n");
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	    sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
d1180 1
d1185 4
a1188 11
    if(pSiS->ShadowFB) {
        if(!xf86LoadSubModule(pScrn, "shadowfb")) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Could not load shadowfb module\n");
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	    sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
	    SISFreeRec(pScrn);
            return FALSE;
d1193 7
d1201 5
a1205 27
    /* TW: Now load and initialize VBE module for VESA. */
    pSiS->UseVESA = 0;
    if(pSiS->VESA == 1) {
       if(!pSiS->pVbe) {
          if(xf86LoadSubModule(pScrn, "vbe")) {
	     xf86LoaderReqSymLists(vbeSymbols, NULL);
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	     pSiS->pVbe = VBEInit(pSiS->pInt,pSiS->pEnt->index);
#else
             pSiS->pVbe = VBEExtendedInit(pSiS->pInt,pSiS->pEnt->index,
	     			SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
#endif
          }
       }
       if(pSiS->pVbe) {
	     vbe = VBEGetVBEInfo(pSiS->pVbe);
	     pSiS->vesamajor = (unsigned)(vbe->VESAVersion >> 8);
	     pSiS->vesaminor = vbe->VESAVersion & 0xff;
	     pSiS->vbeInfo = vbe;
	     SiSBuildVesaModeList(pScrn, pSiS->pVbe, vbe);
	     VBEFreeVBEInfo(vbe);
	     pSiS->UseVESA = 1;
       } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"Could not load and initialize VBE module. VESA disabled.\n");
       }
    }
d1207 25
a1231 3
    if(pSiS->pVbe) {
       vbeFree(pSiS->pVbe);
       pSiS->pVbe = NULL;
d1233 5
a1237 3

#ifdef SISDUALHEAD
    xf86SetPrimInitDone(pScrn->entityList[0]);
a1239 5
    sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);

    if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
    pSiS->pInt = NULL;

d1253 1
a1253 3
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif
a1255 4
#ifdef SISDUALHEAD
    pSiSEnt = pSiS->entityPrivate;
#endif

d1268 1
a1268 13

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
        pSiSEnt->MapCountIOBase++;
        if(!(pSiSEnt->IOBase)) {
	     /* TW: Only map if not mapped previously */
    	     pSiSEnt->IOBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
                         pSiS->PciTag, pSiS->IOAddress, 0x10000);
        }
        pSiS->IOBase = pSiSEnt->IOBase;
    } else
#endif
    	pSiS->IOBase = xf86MapPciMem(pScrn->scrnIndex, mmioFlags,
d1270 1
a1270 4

    if(pSiS->IOBase == NULL) {
    	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Could not map MMIO area\n");
a1271 1
    }
d1278 1
a1278 12
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
        pSiSEnt->MapCountIOBaseDense++;
        if(!(pSiSEnt->IOBaseDense)) {
	     /* TW: Only map if not mapped previously */
	     pSiSEnt->IOBaseDense = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_MMIO,
                    pSiS->PciTag, pSiS->IOAddress, 0x10000);
	}
	pSiS->IOBaseDense = pSiSEnt->IOBaseDense;
    } else
#endif
    	pSiS->IOBaseDense = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_MMIO,
d1281 1
a1281 3
    if(pSiS->IOBaseDense == NULL) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Could not map MMIO dense area\n");
a1282 2
    }

d1285 3
a1287 7
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
        pSiSEnt->MapCountFbBase++;
        if(!(pSiSEnt->FbBase)) {
	     /* TW: Only map if not mapped previously */
    	     pSiSEnt->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
                         pSiS->PciTag, (unsigned long)pSiS->realFbAddress,
d1289 2
a1290 20
	     pSiS->sishw_ext.pjVideoMemoryAddress = (UCHAR *)pSiSEnt->FbBase;
        }
        pSiS->FbBase = pSiSEnt->FbBase;
     	/* TW: Adapt FbBase (for DHM; dhmOffset is 0 otherwise) */
	pSiS->FbBase += pSiS->dhmOffset;
    } else {
#endif
    	pSiS->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
                         pSiS->PciTag, (unsigned long)pSiS->FbAddress,
                         pSiS->FbMapSize);
	pSiS->sishw_ext.pjVideoMemoryAddress = (UCHAR *)pSiS->FbBase;
#ifdef SISDUALHEAD
    }
#endif

    if(pSiS->FbBase == NULL) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Could not map framebuffer area\n");
       	return FALSE;
    }
a1303 3
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif
d1307 5
a1311 3
#ifdef SISDUALHEAD
    pSiSEnt = pSiS->entityPrivate;
#endif
a1312 15
/* TW: In dual head mode, we must not unmap if the other head still
 *     assumes memory as mapped
*/
#ifdef SISDUALHEAD
    if (pSiS->DualHeadMode) {
        if (pSiSEnt->MapCountIOBase) {
	    pSiSEnt->MapCountIOBase--;
	    if ((pSiSEnt->MapCountIOBase == 0) || (pSiSEnt->forceUnmapIOBase)) {
	    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiSEnt->IOBase, 0x10000);
	    	pSiSEnt->IOBase = NULL;
		pSiSEnt->MapCountIOBase = 0;
		pSiSEnt->forceUnmapIOBase = FALSE;
	    }
	    pSiS->IOBase = NULL;
	}
d1314 2
a1315 10
	if (pSiSEnt->MapCountIOBaseDense) {
	    pSiSEnt->MapCountIOBaseDense--;
	    if ((pSiSEnt->MapCountIOBaseDense == 0) || (pSiSEnt->forceUnmapIOBaseDense)) {
	    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiSEnt->IOBaseDense, 0x10000);
	    	pSiSEnt->IOBaseDense = NULL;
		pSiSEnt->MapCountIOBaseDense = 0;
		pSiSEnt->forceUnmapIOBaseDense = FALSE;
	    }
	    pSiS->IOBaseDense = NULL;
	}
a1316 7
	if (pSiSEnt->MapCountFbBase) {
	    pSiSEnt->MapCountFbBase--;
	    if ((pSiSEnt->MapCountFbBase == 0) || (pSiSEnt->forceUnmapFbBase)) {
	    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiSEnt->FbBase, pSiS->FbMapSize);
	    	pSiSEnt->FbBase = NULL;
		pSiSEnt->MapCountFbBase = 0;
		pSiSEnt->forceUnmapFbBase = FALSE;
d1318 2
a1319 16
	    }
	    pSiS->FbBase = NULL;
	}
    } else {
#endif
    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->IOBase, 0x10000);
    	pSiS->IOBase = NULL;
#ifdef __alpha__
    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->IOBaseDense, 0x10000);
    	pSiS->IOBaseDense = NULL;
#endif
    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->FbBase, pSiS->FbMapSize);
    	pSiS->FbBase = NULL;
#ifdef SISDUALHEAD
    }
#endif
a1333 6

#ifdef SISDUALHEAD
    /* TW: We always save master & slave */
    if(pSiS->DualHeadMode && pSiS->SecondHead) return;
#endif

a1338 2
    sisSaveUnlockExtRegisterLock(pSiS,&sisReg->sisRegs3C4[0x05],&sisReg->sisRegs3D4[0x80]);

a1339 1
    
a1340 182
    
    /* TW: Save these as they may have been changed prior to SISSave() call */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
    	sisReg->sisRegs3D4[0x17] = pSiS->oldCR17;
	if(vgaReg->numCRTC >= 0x17) vgaReg->CRTC[0x17] = pSiS->oldCR17;
	sisReg->sisRegs3D4[0x32] = pSiS->oldCR32;
    }
}

/*
 * TW: Just adapted from the std* functions in vgaHW.c
 */
static void
SiS_WriteAttr(SISPtr pSiS, int index, int value)
{
    CARD8 tmp;

    tmp = inb(pSiS->IODBase + VGA_IOBASE_COLOR + VGA_IN_STAT_1_OFFSET);

    index |= 0x20;
    outb(pSiS->IODBase + VGA_ATTR_INDEX, index);
    outb(pSiS->IODBase + VGA_ATTR_DATA_W, value);
}

static int
SiS_ReadAttr(SISPtr pSiS, int index)
{
    CARD8 tmp;

    tmp = inb(pSiS->IODBase + VGA_IOBASE_COLOR + VGA_IN_STAT_1_OFFSET);

    index |= 0x20;
    outb(pSiS->IODBase + VGA_ATTR_INDEX, index);
    return (inb(pSiS->IODBase + VGA_ATTR_DATA_R));
}


static void
SiS_SaveFonts(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char miscOut, attr10, gr4, gr5, gr6, seq2, seq4, scrn;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    CARD8 *vgaIOBase = (CARD8 *)VGAHWPTR(pScrn)->IOBase;
#else
    pointer vgaIOBase = VGAHWPTR(pScrn)->Base;
#endif

    if (pSiS->fonts != NULL)
	return;

    /* If in graphics mode, don't save anything */
    attr10 = SiS_ReadAttr(pSiS, 0x10);
    if (attr10 & 0x01)
	return;

    pSiS->fonts = xalloc(16384);

    /* save the registers that are needed here */
    miscOut = inSISREG(SISMISCR);
    inSISIDXREG(SISGR, 0x04, gr4);
    inSISIDXREG(SISGR, 0x05, gr5);
    inSISIDXREG(SISGR, 0x06, gr6);
    inSISIDXREG(SISSR, 0x02, seq2);
    inSISIDXREG(SISSR, 0x04, seq4);

    /* Force into color mode */
    outSISREG(SISMISCW, miscOut | 0x01);

    inSISIDXREG(SISSR, 0x01, scrn);
    outSISIDXREG(SISSR, 0x00, 0x01);
    outSISIDXREG(SISSR, 0x01, scrn | 0x20);
    outSISIDXREG(SISSR, 0x00, 0x03);

    SiS_WriteAttr(pSiS, 0x10, 0x01);  /* graphics mode */

    /*font1 */
    outSISIDXREG(SISSR, 0x02, 0x04);  /* write to plane 2 */
    outSISIDXREG(SISSR, 0x04, 0x06);  /* enable plane graphics */
    outSISIDXREG(SISGR, 0x04, 0x02);  /* read plane 2 */
    outSISIDXREG(SISGR, 0x05, 0x00);  /* write mode 0, read mode 0 */
    outSISIDXREG(SISGR, 0x06, 0x05);  /* set graphics */
    slowbcopy_frombus(vgaIOBase, pSiS->fonts, 8192);

    /* font2 */
    outSISIDXREG(SISSR, 0x02, 0x08);  /* write to plane 3 */
    outSISIDXREG(SISSR, 0x04, 0x06);  /* enable plane graphics */
    outSISIDXREG(SISGR, 0x04, 0x03);  /* read plane 3 */
    outSISIDXREG(SISGR, 0x05, 0x00);  /* write mode 0, read mode 0 */
    outSISIDXREG(SISGR, 0x06, 0x05);  /* set graphics */
    slowbcopy_frombus(vgaIOBase, pSiS->fonts + 8192, 8192);

    inSISIDXREG(SISSR, 0x01, scrn);
    outSISIDXREG(SISSR, 0x00, 0x01);
    outSISIDXREG(SISSR, 0x01, scrn & ~0x20);
    outSISIDXREG(SISSR, 0x00, 0x03);

    /* Restore clobbered registers */
    SiS_WriteAttr(pSiS, 0x10, attr10);
    outSISIDXREG(SISSR, 0x02, seq2);
    outSISIDXREG(SISSR, 0x04, seq4);
    outSISIDXREG(SISGR, 0x04, gr4);
    outSISIDXREG(SISGR, 0x05, gr5);
    outSISIDXREG(SISGR, 0x06, gr6);
    outSISREG(SISMISCW, miscOut);
}

static void
SiS_RestoreFonts(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char miscOut, attr10, gr1, gr3, gr4, gr5, gr6, gr8, seq2, seq4, scrn;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    CARD8 *vgaIOBase = (CARD8 *)VGAHWPTR(pScrn)->IOBase;
#else
    pointer vgaIOBase = VGAHWPTR(pScrn)->Base;
#endif

    if (pSiS->fonts == NULL)
	return;

#if 0
    if (pVesa->mapPhys == 0xa0000 && pVesa->curBank != 0)
	VESABankSwitch(pScrn->pScreen, 0);
#endif

    /* save the registers that are needed here */
    miscOut = inSISREG(SISMISCR);
    attr10 = SiS_ReadAttr(pSiS, 0x10);
    inSISIDXREG(SISGR, 0x01, gr1);
    inSISIDXREG(SISGR, 0x03, gr3);
    inSISIDXREG(SISGR, 0x04, gr4);
    inSISIDXREG(SISGR, 0x05, gr5);
    inSISIDXREG(SISGR, 0x06, gr6);
    inSISIDXREG(SISGR, 0x08, gr8);
    inSISIDXREG(SISSR, 0x02, seq2);
    inSISIDXREG(SISSR, 0x04, seq4);

    /* Force into color mode */
    outSISREG(SISMISCW, miscOut | 0x01);
    inSISIDXREG(SISSR, 0x01, scrn);
    outSISIDXREG(SISSR, 0x00, 0x01);
    outSISIDXREG(SISSR, 0x01, scrn | 0x20);
    outSISIDXREG(SISSR, 0x00, 0x03);

    SiS_WriteAttr(pSiS, 0x10, 0x01);	  /* graphics mode */
    if (pScrn->depth == 4) {
        outSISIDXREG(SISGR, 0x03, 0x00);  /* don't rotate, write unmodified */
	outSISIDXREG(SISGR, 0x08, 0xFF);  /* write all bits in a byte */
	outSISIDXREG(SISGR, 0x01, 0x00);  /* all planes come from CPU */
    }

    outSISIDXREG(SISSR, 0x02, 0x04); /* write to plane 2 */
    outSISIDXREG(SISSR, 0x04, 0x06); /* enable plane graphics */
    outSISIDXREG(SISGR, 0x04, 0x02); /* read plane 2 */
    outSISIDXREG(SISGR, 0x05, 0x00); /* write mode 0, read mode 0 */
    outSISIDXREG(SISGR, 0x06, 0x05); /* set graphics */
    slowbcopy_tobus(pSiS->fonts, vgaIOBase, 8192);

    outSISIDXREG(SISSR, 0x02, 0x08); /* write to plane 3 */
    outSISIDXREG(SISSR, 0x04, 0x06); /* enable plane graphics */
    outSISIDXREG(SISGR, 0x04, 0x03); /* read plane 3 */
    outSISIDXREG(SISGR, 0x05, 0x00); /* write mode 0, read mode 0 */
    outSISIDXREG(SISGR, 0x06, 0x05); /* set graphics */
    slowbcopy_tobus(pSiS->fonts + 8192, vgaIOBase, 8192);

    inSISIDXREG(SISSR, 0x01, scrn);
    outSISIDXREG(SISSR, 0x00, 0x01);
    outSISIDXREG(SISSR, 0x01, scrn & ~0x20);
    outSISIDXREG(SISSR, 0x00, 0x03);

    /* restore the registers that were changed */
    outSISREG(SISMISCW, miscOut);
    SiS_WriteAttr(pSiS, 0x10, attr10);
    outSISIDXREG(SISGR, 0x01, gr1);
    outSISIDXREG(SISGR, 0x03, gr3);
    outSISIDXREG(SISGR, 0x04, gr4);
    outSISIDXREG(SISGR, 0x05, gr5);
    outSISIDXREG(SISGR, 0x06, gr6);
    outSISIDXREG(SISGR, 0x08, gr8);
    outSISIDXREG(SISSR, 0x02, seq2);
    outSISIDXREG(SISSR, 0x04, seq4);
a1342 1
/* TW: VESASaveRestore taken from vesa driver */
d1350 2
a1351 48
    /* Query amount of memory to save state */
    if (function == MODE_QUERY ||
	(function == MODE_SAVE && pSiS->state == NULL)) {

	/* Make sure we save at least this information in case of failure */
	(void)VBEGetVBEMode(pSiS->pVbe, &pSiS->stateMode);
	SiS_SaveFonts(pScrn);

        if (pSiS->vesamajor > 1) {
	    if (!VBESaveRestore(pSiS->pVbe,function,(pointer)&pSiS->state,
				&pSiS->stateSize,&pSiS->statePage))
	        return;

	}
    }

    /* Save/Restore Super VGA state */
    if (function != MODE_QUERY) {
        Bool retval = TRUE;

	if (pSiS->vesamajor > 1) {
	    if (function == MODE_RESTORE)
		memcpy(pSiS->state, pSiS->pstate, pSiS->stateSize);

	    if ((retval = VBESaveRestore(pSiS->pVbe,function,
					 (pointer)&pSiS->state,
					 &pSiS->stateSize,&pSiS->statePage))
		&& function == MODE_SAVE) {
	        /* don't rely on the memory not being touched */
	        if (pSiS->pstate == NULL)
		    pSiS->pstate = xalloc(pSiS->stateSize);
		memcpy(pSiS->pstate, pSiS->state, pSiS->stateSize);
	    }
	}

	if (function == MODE_RESTORE) {
	    VBESetVBEMode(pSiS->pVbe, pSiS->stateMode, NULL);
	    SiS_RestoreFonts(pScrn);
	}
#if 0
	if (!retval)
	    return (FALSE);
#endif

    }
#if 0
    if ( (pSiS->vesamajor > 1) &&
	 (function == MODE_SAVE || pSiS->pstate) ) {
d1354 1
d1364 1
a1364 2
	    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
	    		"VBESaveRestore done with success\n");
d1367 1
a1367 2
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
			"VBESaveRestore done\n");
a1373 1
#endif
d1377 4
a1380 4
 * Initialise a new mode.  This is currently done using the
 * "initialise struct, restore/write struct to HW" model for
 * the old chipsets (5597/530/6326). For newer chipsets,
 * we use either VESA or our own mode switching code.
d1392 1
a1392 1

d1395 2
a1396 2
    /* TW: Initialize SiS Port Register definitions for externally used
     *     BIOS emulation (native code switching) functions.
d1398 1
a1398 4
    if( pSiS->VGAEngine == SIS_300_VGA ||
		        pSiS->VGAEngine == SIS_315_VGA ) {
       SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO+0x30);
    }
a1400 5

#ifdef SISDUALHEAD
	/* TW: No dual head mode when using VESA */
	if (pSiS->SecondHead) return TRUE;
#endif
d1402 1
a1402 1
	 * TW: This order is required:
d1410 3
a1412 7
	if( pSiS->VGAEngine == SIS_300_VGA ||
		        pSiS->VGAEngine == SIS_315_VGA ) {
		SiSPreSetMode(pScrn, mode);
	}
 	if(!SiSSetVESAMode(pScrn, mode)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"SiSSetVESAMode() failed\n");
d1414 5
a1418 17
	}
	sisSaveUnlockExtRegisterLock(pSiS,NULL,NULL);
	if( pSiS->VGAEngine == SIS_300_VGA ||
		        pSiS->VGAEngine == SIS_315_VGA ) {
		SiSPreSetMode(pScrn, mode);
		SiSPostSetMode(pScrn, &pSiS->ModeReg);
	}
	/* TW: Prepare some register contents and set
	 *     up some mode dependent variables.
	 */
#ifdef TWDEBUG
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"REAL REGISTER CONTENTS AFTER SETMODE:\n");
#endif
	if (!(*pSiS->ModeInit)(pScrn, mode)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"ModeInit() failed\n");
a1419 1
	}
d1428 7
a1434 2
			  "HDisplay: %d, VDisplay: %d  \n",
			  mode->HDisplay, mode->VDisplay));
d1436 2
a1437 34
    } else { /* Without VESA: */
#ifdef SISDUALHEAD
	if(pSiS->DualHeadMode) {
                if(!(*pSiS->ModeInit)(pScrn, mode)) {
		    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	       "ModeInit() failed\n");
	            return FALSE;
	        }

	        pScrn->vtSema = TRUE;

		if(!(pSiS->SecondHead)) {
			/* TW: Head 1 (master) is always CRT2 */
			SiSPreSetMode(pScrn, mode);
			if (!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn, mode)) {
				xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    				"SiSBIOSSetModeCRT2() failed\n");
				return FALSE;
			}
			SiSPostSetMode(pScrn, &pSiS->ModeReg);
		} else {
			/* TW: Head 2 (slave) is always CRT1 */
			SiSPreSetMode(pScrn, mode);
			if (!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn, mode, pSiS->IsCustom)) {
				xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    				"SiSBIOSSetModeCRT1() failed\n");
				return FALSE;
			}
			SiSPostSetMode(pScrn, &pSiS->ModeReg);
		}
	} else {
#endif
		if(pSiS->VGAEngine == SIS_300_VGA ||
		                       pSiS->VGAEngine == SIS_315_VGA) {
d1439 1
a1439 31
	                /* TW: Prepare the register contents; On 300/310/325,
	                 *     we actually "abuse" this only for setting
	                 *     up some variables; the registers are NOT
	                 *     being written to the hardware as the BIOS
	                 *     emulation (native mode switching code)
	                 *     takes care of this.
	                 */
                        if(!(*pSiS->ModeInit)(pScrn, mode)) {
			    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    			"ModeInit() failed\n");
	                    return FALSE;
		        }

	                pScrn->vtSema = TRUE;

		        /* 300/310/325 series: Use our own code for mode switching */
	    		SiSPreSetMode(pScrn, mode);

	    		if(!SiSBIOSSetMode(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn, mode, pSiS->IsCustom)) {
			  	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    				"SiSBIOSSetMode() failed\n");
				return FALSE;
		        }

	    		SiSPostSetMode(pScrn, &pSiS->ModeReg);
#ifdef TWDEBUG
			xf86DrvMsg(pScrn->scrnIndex, X_INFO,
				"REAL REGISTER CONTENTS AFTER SETMODE:\n");
                        (*pSiS->ModeInit)(pScrn, mode);
#endif
		} else {
d1441 3
a1443 1
		   /* For other chipsets, use the old method */
d1445 4
a1448 42
		   /* Initialise the ModeReg values */
    	           if(!vgaHWInit(pScrn, mode)) {
		       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    		   "vgaHWInit() failed\n");
	               return FALSE;
		   }

		   /* Reset our PIOOffset as vgaHWInit might have reset it */
      		   VGAHWPTR(pScrn)->PIOOffset = pSiS->IODBase + (pSiS->PciInfo->ioBase[2] & 0xFFFC) - 0x380;

		   /* Prepare the register contents */
	           if(!(*pSiS->ModeInit)(pScrn, mode)) {
		       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    		   "ModeInit() failed\n");
	               return FALSE;
		   }

		   pScrn->vtSema = TRUE;

	           /* Program the registers */
	           vgaHWProtect(pScrn, TRUE);
	           vgaReg = &hwp->ModeReg;
	           sisReg = &pSiS->ModeReg;

		   vgaReg->Attribute[0x10] = 0x01;
    		   if(pScrn->bitsPerPixel > 8) {
	    		vgaReg->Graphics[0x05] = 0x00;
		   }

    		   vgaHWRestore(pScrn, vgaReg, VGA_SR_MODE);

		   (*pSiS->SiSRestore)(pScrn, sisReg);

		   if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
		       SiS6326PostSetMode(pScrn, &pSiS->ModeReg);
		   }

#ifdef TWDEBUG
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"REAL REGISTER CONTENTS AFTER SETMODE:\n");
                        (*pSiS->ModeInit)(pScrn, mode);
#endif
d1450 16
a1465 5
		   vgaHWProtect(pScrn, FALSE);
		}
#ifdef SISDUALHEAD
        }
#endif
d1468 5
a1472 6
    /* TW: Update Currentlayout */
    pSiS->CurrentLayout.mode = mode;

    /* Debug */
/*  SiSDumpModeInfo(pScrn, mode);  */

d1484 2
a1485 1
    if (!(mode = SiSCalcVESAModeIndex(pScrn, pMode))) return FALSE;
d1487 2
a1488 2
    mode |= 1 << 15;	/* TW: Don't clear framebuffer */
    mode |= 1 << 14;   	/* TW: Use linear adressing */
d1490 3
a1492 4
    if(VBESetVBEMode(pSiS->pVbe, mode, NULL) == FALSE) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    		"Setting VESA mode 0x%x failed\n",
	             	mode & 0x0fff);
d1496 1
a1496 1
    if(pMode->HDisplay != pScrn->virtualX)
d1499 2
a1500 3
    xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
    		"Setting VESA mode 0x%x succeeded\n",
	       	mode & 0x0fff);
d1505 1
d1507 1
a1507 1
 * Restore the initial mode. To be used internally only!
d1512 4
a1515 12
    SISPtr    pSiS = SISPTR(pScrn);
    SISRegPtr sisReg = &pSiS->SavedReg;
    vgaHWPtr  hwp = VGAHWPTR(pScrn);
    vgaRegPtr vgaReg = &hwp->SavedReg;
    Bool      doit = FALSE, doitlater = FALSE;

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {

#ifdef SISDUALHEAD
       /* TW: We always restore master AND slave */
       if(pSiS->DualHeadMode && pSiS->SecondHead) return;
#endif
d1517 4
a1520 82
       /* TW: We must not disable the sequencer if the bridge is in SlaveMode! */
       if(!(SiSBridgeIsInSlaveMode(pScrn))) {
          vgaHWProtect(pScrn, TRUE);
       }

#ifdef UNLOCK_ALWAYS
       sisSaveUnlockExtRegisterLock(pSiS, NULL,NULL);
#endif

       /* TW: First, restore CRT1 on/off and VB connection registers */
       outSISIDXREG(SISCR, 0x32, pSiS->oldCR32);
       if(!(pSiS->oldCR17 & 0x80)) {			/* TW: CRT1 was off */
           if(!(SiSBridgeIsInSlaveMode(pScrn))) {       /* TW: Bridge is NOT in SlaveMode now -> do it */
	      doit = TRUE;
	   } else {
	      doitlater = TRUE;
	   }
       } else {						/* TW: CRT1 was on -> do it now */
           doit = TRUE;
       }
       
       if(doit) {
           outSISIDXREG(SISCR, 0x17, pSiS->oldCR17);
       }

       /* TW: For 30xB/LV, restoring the registers does not
        *     work. We "manually" set the old mode, instead.
	*     The same applies for SiS730 machines with LVDS.
	*     Finally, this behavior can be forced by setting
	*     the option RestoreBySetMode.
        */
        if( ( (pSiS->restorebyset) ||
	      (pSiS->VBFlags & (VB_301B|VB_302B|VB_30xLV|VB_30xLVX)) ||
	      ((pSiS->sishw_ext.jChipType == SIS_730) && (pSiS->VBFlags & VB_LVDS)) ) &&
	    (pSiS->OldMode) ) {

           if(pSiS->AccelInfoPtr) {
             (*pSiS->AccelInfoPtr->Sync)(pScrn);
           }

           xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
	         "Restoring by setting old mode 0x%02x\n", pSiS->OldMode);

  	   if( (pSiS->VBFlags & (VB_301B|VB_302B|VB_30xLV|VB_30xLVX)) &&
	       (!pSiS->restorebyset) ) {		 
	      if(pSiS->OldMode == 0x03) pSiS->OldMode = 0x13;	 
	   }
		 
	   pSiS->SiS_Pr->UseCustomMode = FALSE;
	   pSiS->SiS_Pr->CRT1UsesCustomMode = FALSE;
	   SiSSetMode(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn, pSiS->OldMode, FALSE);
#ifdef TWDEBUG
		{
		   SISRegPtr      pReg = &pSiS->ModeReg;
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"REAL REGISTER CONTENTS AFTER RESTORE BY SETMODE:\n");
		   (*pSiS->SiSSave)(pScrn, pReg);
		}
#endif

        } else {

	   if(pSiS->VBFlags & VB_VIDEOBRIDGE) {
	      /* TW: If a video bridge is present, we need to restore
	       *     non-extended (=standard VGA) SR and CR registers
	       *     before restoring the extended ones and the bridge
	       *     registers itself. Unfortunately, the vgaHWRestore
	       *     routine clears CR17[7] - which must not be done if
	       *     the bridge is in slave mode.
	       */
	      if(!(SiSBridgeIsInSlaveMode(pScrn))) {
                 vgaHWProtect(pScrn, TRUE);
		 
		 if(pSiS->Primary) {
	            vgaHWRestore(pScrn, vgaReg, VGA_SR_MODE);
	         }
              } 
	   }
	   
           (*pSiS->SiSRestore)(pScrn, sisReg);

        }
d1522 1
a1522 40
	if(doitlater) {
            outSISIDXREG(SISCR, 0x17, pSiS->oldCR17);
	}

	sisRestoreExtRegisterLock(pSiS,sisReg->sisRegs3C4[0x05],sisReg->sisRegs3D4[0x80]);
	
	if( ( (pSiS->sishw_ext.jChipType == SIS_730) && (pSiS->VBFlags & VB_LVDS)) ||
	    (pSiS->restorebyset) ) {
	   
	   /* TW: SiS730/LVDS has extreme problems restoring the text display due
	    *     to over-sensible LCD panels
	    */
   
	   vgaHWProtect(pScrn, TRUE);  
	    
	   if(pSiS->Primary) {
	      vgaHWRestore(pScrn, vgaReg, (VGA_SR_FONTS | VGA_SR_CMAP));
	   }
	   
	   vgaHWProtect(pScrn, FALSE); 
	
	} else {
	
	   vgaHWProtect(pScrn, TRUE);
	
	   if(pSiS->Primary) {
	      vgaHWRestore(pScrn, vgaReg, VGA_SR_ALL);
	   }
       
	   vgaHWProtect(pScrn, FALSE);
	
	}
    
    } else {	/* All other chipsets */

        vgaHWProtect(pScrn, TRUE);
#ifdef UNLOCK_ALWAYS
        sisSaveUnlockExtRegisterLock(pSiS, NULL,NULL);
#endif
        (*pSiS->SiSRestore)(pScrn, sisReg);
d1524 1
a1524 36
        vgaHWProtect(pScrn, TRUE);
	if(pSiS->Primary) {
           vgaHWRestore(pScrn, vgaReg, VGA_SR_ALL);
	}

	/* TW: Restore TV. This is rather complicated, but if we don't do it,
	 *     TV output will flicker terribly
	 */
        if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
	  if(sisReg->sis6326tv[0] & 0x04) {
	    unsigned char tmp;
	    int val;

            orSISIDXREG(SISSR, 0x01, 0x20);
            tmp = SiS6326GetTVReg(pScrn,0x00);
            tmp &= ~0x04;
            while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
            SiS6326SetTVReg(pScrn,0x00,tmp);
            for(val=0; val < 2; val++) {
              while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
              while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
            }
            SiS6326SetTVReg(pScrn, 0x00, sisReg->sis6326tv[0]);
            tmp = inSISREG(SISINPSTAT);
            outSISREG(SISAR, 0x20);
            tmp = inSISREG(SISINPSTAT);
            while(inSISREG(SISINPSTAT) & 0x01);
            while(!(inSISREG(SISINPSTAT) & 0x01));
            andSISIDXREG(SISSR, 0x01, ~0x20);
            for(val=0; val < 10; val++) {
              while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
              while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
            }
            andSISIDXREG(SISSR, 0x01, ~0x20);
	  }
        }
d1526 1
a1526 1
        sisRestoreExtRegisterLock(pSiS,sisReg->sisRegs3C4[5],sisReg->sisRegs3D4[0x80]);
d1528 1
a1528 2
        vgaHWProtect(pScrn, FALSE);
    }
d1539 1
a1539 1
/* TW: Restore bridge registers - to be called BEFORE VESARestore */
d1545 3
a1547 21
#ifdef SISDUALHEAD
    /* We only restore for master head */
    if(pSiS->DualHeadMode && pSiS->SecondHead) return;
#endif

    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
	SiSRestoreBridge(pScrn, &pSiS->SavedReg);
    }
}

/* TW: Our generic BlockHandler for Xv */
static void
SISBlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
{
    ScreenPtr pScreen = screenInfo.screens[i];
    ScrnInfoPtr pScrn   = xf86Screens[i];
    SISPtr pSiS = SISPTR(pScrn);

    pScreen->BlockHandler = pSiS->BlockHandler;
    (*pScreen->BlockHandler) (i, blockData, pTimeout, pReadmask);
    pScreen->BlockHandler = SISBlockHandler;
d1549 1
a1549 2
    if(pSiS->VideoTimerCallback) {
        (*pSiS->VideoTimerCallback)(pScrn, currentTime.milliseconds);
d1554 1
a1554 6
 * This gets called at the start of each server generation
 *
 * TW: We use pScrn and not CurrentLayout here, because the
 *     properties we use have not changed (displayWidth,
 *     depth, bitsPerPixel)
 */
d1558 1
a1567 3
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif
d1569 3
d1576 2
d1580 2
a1581 15
    if(pSiS->UseVESA) {
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	pSiS->pVbe = VBEInit(NULL, pSiS->pEnt->index);
#else
        pSiS->pVbe = VBEExtendedInit(NULL, pSiS->pEnt->index,
	                   SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
#endif
    }

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
    	pSiSEnt = pSiS->entityPrivate;
    	pSiSEnt->refCount++;
    }
#endif
d1584 2
a1585 8
    if(pSiS->Primary) {
       hwp->MapSize = 0x10000;  /* Standard 64k VGA window */
       if(!vgaHWMapMem(pScrn)) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Could not map VGA window\n");
          return FALSE;
       }
    }
a1587 5
    /* TW: Patch the PIOOffset inside vgaHW to use
     *     our relocated IO ports.
     */
    VGAHWPTR(pScrn)->PIOOffset = pSiS->IODBase + (pSiS->PciInfo->ioBase[2] & 0xFFFC) - 0x380;

d1589 1
a1589 3
    if(!SISMapMem(pScrn)) {
    	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"SiSMapMem() failed\n");
a1590 15
    }

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    /* TW: Enable TurboQueue so that SISSave() saves it in enabled
     *     state. If we don't do this, X will hang after a restart!
     *     (Happens for some unknown reason only when using VESA
     *     for mode switching; assumingly a BIOS issue.)
     *     This is done on 300 and 310/325 series only.
     */
    if(pSiS->UseVESA) {
	SiSEnableTurboQueue(pScrn);
    }
a1594 5
    /* TW: Save the current mode number */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
        inSISIDXREG(SISCR, 0x34, pSiS->OldMode);
    }

d1596 1
a1596 3
    if(!SISModeInit(pScrn, pScrn->currentMode)) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"SiSModeInit() failed\n");
a1597 1
    }
d1599 5
a1603 5
    /* Darken the screen for aesthetic reasons */
    /* TW: Not using Dual Head variant on purpose; we darken
     *     the screen for both displays, and un-darken
     *     it when the second head is finished
     */
a1604 2

    /* Set the viewport */
a1606 5
    /* Clear frame buffer */
    OnScreenSize = pScrn->displayWidth * pScrn->currentMode->VDisplay
                               * (pScrn->bitsPerPixel / 8);
    bzero(pSiS->FbBase, OnScreenSize);

d1624 1
d1631 6
a1636 8
    if(pScrn->bitsPerPixel > 8) {
        if(!miSetVisualTypes(pScrn->depth, TrueColorMask, pScrn->rgbBits,
                              pScrn->defaultVisual)) {
	 	SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    		"miSetVisualTypes() failed (bpp %d)\n", pScrn->bitsPerPixel);
	    	return FALSE;
	}
d1638 1
a1638 1
        if(!miSetVisualTypes(pScrn->depth,
d1640 1
a1640 4
                              pScrn->rgbBits, pScrn->defaultVisual)) {
		SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    		"miSetVisualTypes() failed (bpp %d)\n", pScrn->bitsPerPixel);
a1641 1
	}
d1648 1
a1648 1
    if(pSiS->Rotate) {
d1653 1
a1653 1
    if(pSiS->ShadowFB) {
d1663 1
a1663 4
    if(!miSetPixmapDepths()) {
        SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"miSetPixmapDepths() failed\n");
d1665 5
a1671 9
#ifdef SISDUALHEAD
    if(pSiS->SecondHead)
	   pSiS->cmdQueueLenPtr = &(SISPTR(pSiSEnt->pScrn_1)->cmdQueueLen);
    else
#endif
           pSiS->cmdQueueLenPtr = &(pSiS->cmdQueueLen);

    pSiS->cmdQueueLen = 0; /* TW: Force an EngineIdle() at start */

d1673 2
a1674 16
#ifdef SISDUALHEAD
    /* TW: No DRI in dual head mode */
    if(pSiS->DualHeadMode) {
        pSiS->directRenderingEnabled = FALSE;
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"DRI not supported in Dual Head mode\n");
    } else
#endif
       /* Force the initialization of the context */
       if(pSiS->VGAEngine != SIS_315_VGA) {
           pSiS->directRenderingEnabled = SISDRIScreenInit(pScreen);
       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_NOT_IMPLEMENTED,
	  	"DRI not supported on this chipset\n");
          pSiS->directRenderingEnabled = FALSE;
       }
d1682 2
a1683 2
    switch(pScrn->bitsPerPixel) {
      case 1:
d1685 1
a1685 1
                        height, pScrn->xDpi, pScrn->yDpi,
d1688 1
a1688 1
      case 4:
d1690 1
a1690 1
                        height, pScrn->xDpi, pScrn->yDpi,
d1693 4
a1696 4
      case 8:
      case 16:
      case 24:
      case 32:
d1703 1
a1703 1
      default:
d1710 3
a1712 4
    if (!ret) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"xf1bpp/xf4bpp/fbScreenInit() failed\n");
  	SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
d1716 1
a1716 1
    if(pScrn->bitsPerPixel > 8) {
d1729 1
a1729 1
    } else if(pScrn->depth == 1) {
d1733 5
a1737 6
    /* Initialize RENDER ext; must be after RGB ordering fixed */
    if(init_picture)  fbPictureInit(pScreen, 0, 0);

    /* hardware cursor needs to wrap this layer    <-- TW: what does that mean? */
    if(!pSiS->ShadowFB)  SISDGAInit(pScreen);

d1740 4
a1743 4
    if(!pSiS->NoAccel) {
        switch(pSiS->VGAEngine) {
	  case SIS_530_VGA:
	  case SIS_300_VGA:
d1745 3
a1747 5
	    break;
	  case SIS_315_VGA:
	    SiS310AccelInit(pScreen);
	    break;
          default:
a1748 1
	}
d1755 1
a1755 1
    miDCInitialize(pScreen, xf86GetPointerScreenFuncs());
d1757 1
a1757 1
    if(pSiS->HWCursor)
d1761 1
a1761 4
    if(!miCreateDefColormap(pScreen)) {
        SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"miCreateDefColormap() failed\n");
d1763 8
a1770 8
    }
    
    if(!xf86HandleColormaps(pScreen, 256, (pScrn->depth == 8) ? 8 : pScrn->rgbBits,
                    SISLoadPalette, NULL,
                    CMAP_PALETTED_TRUECOLOR | CMAP_RELOAD_ON_MODE_SWITCH)) {
        SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"xf86HandleColormaps() failed\n");
a1771 1
    }
d1774 7
a1780 1
       RefreshAreaFuncPtr refreshArea = SISRefreshArea;
d1782 5
a1786 12
       if(pSiS->Rotate) {
          if(!pSiS->PointerMoved) {
             pSiS->PointerMoved = pScrn->PointerMoved;
             pScrn->PointerMoved = SISPointerMoved;
          }

          switch(pScrn->bitsPerPixel) {
             case 8:  refreshArea = SISRefreshArea8;  break;
             case 16: refreshArea = SISRefreshArea16; break;
             case 24: refreshArea = SISRefreshArea24; break;
             case 32: refreshArea = SISRefreshArea32; break;
          }
d1788 1
d1790 1
a1790 1
       ShadowFBInit(pScreen, refreshArea);
d1792 2
a1793 12

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode)
    	/* TW: DPMS for dual head mode */
        xf86DPMSInit(pScreen, (DPMSSetProcPtr)SISDisplayPowerManagementSetDH, 0);
    else
#endif
        xf86DPMSInit(pScreen, (DPMSSetProcPtr)SISDisplayPowerManagementSet, 0);

    /* Init memPhysBase and fbOffset in pScrn */
    pScrn->memPhysBase = pSiS->FbAddress;
    pScrn->fbOffset = 0;
d1796 7
a1802 51
    if(!pSiS->NoXvideo) {
#ifdef SISDUALHEAD
        /* TW: On chipsets with only one overlay, we support
	 *     Xv only in "real" dual head mode, not Xinerama
	 */
	if ( ((pSiS->VGAEngine == SIS_300_VGA) ||
	      (pSiS->VGAEngine == SIS_315_VGA) )
	     &&
	     ((pSiS->hasTwoOverlays)  ||
	      (!pSiS->DualHeadMode)   ||
	      (noPanoramiXExtension) ) ) {
#else
        if (  (pSiS->VGAEngine == SIS_300_VGA) ||
	      (pSiS->VGAEngine == SIS_315_VGA) ) {
#endif
#ifdef SISDUALHEAD
              if (pSiS->DualHeadMode) {
	         if ( pSiS->hasTwoOverlays ||
		     (pSiS->XvOnCRT2 && (!pSiS->SecondHead)) ||
		     ((!pSiS->XvOnCRT2 && pSiS->SecondHead)) ) {
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		        "Using SiS300/310/325 series HW Xv on CRT%d\n",
			(pSiS->SecondHead ? 1 : 2));
                    SISInitVideo(pScreen);
                 } else {
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		        "Not using SiS300/310/325 series HW Xv on CRT%d\n",
			(pSiS->SecondHead ? 1 : 2));
		 }
 	      } else {
#endif
	        if (pSiS->hasTwoOverlays)
                    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		        "Using SiS300/310/325 series HW Xv\n" );
                else
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		        "Using SiS300/310/325 series HW Xv on CRT%d\n",
			(pSiS->XvOnCRT2 ? 2 : 1));
	        SISInitVideo(pScreen);
#ifdef SISDUALHEAD
              }
#endif
#ifdef USE6326VIDEO
        } else if( pSiS->Chipset == PCI_CHIP_SIS6326 ||
	           pSiS->Chipset == PCI_CHIP_SIS530  ||
		   pSiS->Chipset == PCI_CHIP_SIS5597 ) {
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		        "Using SiS5597/5598/6326/530/620 HW Xv\n" );
		SIS6326InitVideo(pScreen);
#endif
	} else { /* generic Xv */
a1811 3
	    if (!noPanoramiXExtension)
	    	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"HW Xv not supported in Xinerama mode\n");
d1817 1
a1817 1
    if(pSiS->directRenderingEnabled) {
d1823 2
a1824 2
    if(pSiS->directRenderingEnabled) {
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Direct rendering enabled\n");
d1828 1
a1828 1
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Direct rendering disabled\n");
d1834 1
a1834 10
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode)
    	pScreen->SaveScreen = SISSaveScreenDH;
    else
#endif
    	pScreen->SaveScreen = SISSaveScreen;

    /* Install BlockHandler */
    pSiS->BlockHandler = pScreen->BlockHandler;
    pScreen->BlockHandler = SISBlockHandler;
d1837 2
a1838 2
    if(serverGeneration == 1) {
    	xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
d1842 1
a1842 8
    /* TW: We do this in dual head mode after second head is finished */
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
        if(pSiS->SecondHead)
    	     SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
    } else
#endif
        SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
d1847 1
a1851 59
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    SISPtr pSiS = SISPTR(pScrn);

    if(!pSiS->NoAccel) {
       if(pSiS->AccelInfoPtr) {
            (*pSiS->AccelInfoPtr->Sync)(pScrn);
       }
    }

    return SISModeInit(xf86Screens[scrnIndex], mode);
}

#ifdef CYCLECRT2
/* TW: Cycle CRT2 output devices */
Bool
SISCycleCRT2Type(int scrnIndex, DisplayModePtr mode)
{
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    SISPtr pSiS = SISPTR(pScrn);
    int i = 0;

    /* TW: Only on 300 and 310/325 series */
    if(pSiS->VGAEngine != SIS_300_VGA &&
       pSiS->VGAEngine != SIS_315_VGA) return FALSE;

    /* TW: Only if there is a video bridge */
    if(pSiS->VBFlags & VB_VIDEOBRIDGE) return FALSE;

    /* TW: Only if there were more than 1 CRT2 devices detected */
    if(pSiS->detectedCRT2Devices & CRT2_VGA) i++;
    if(pSiS->detectedCRT2Devices & CRT2_LCD) i++;
    if(pSiS->detectedCRT2Devices & CRT2_TV)  i++;
    if(i <= 1) return FALSE;

    /* TW: Cycle CRT2 type */
    i = (pSiS->VBFlags & DISPTYPE_DISP2) << 1;
    while(!(i & pSiS->detectedCRT2Devices)) {
      i <<= 1;
      if(i > CRT2_VGA) i = CRT2_LCD;
    }

    /* TW: Check if mode is suitable for desired output device */
    if(!SiS_CheckCalcModeIndex(pScrn, pScrn->currentMode,
    			       ((pSiS->VBFlags & ~(DISPTYPE_DISP2)) | i))) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"Current mode not suitable for desired CRT2 output device\n");
    	return FALSE;
    }

    /* TW: Sync the accelerators */
    if(!pSiS->NoAccel) {
         if(pSiS->AccelInfoPtr) {
            (*pSiS->AccelInfoPtr->Sync)(pScrn);
	 }
    }

    pSiS->VBFlags &= ~(DISPTYPE_DISP2);
    pSiS->VBFlags |= i;

a1853 1
#endif
d1866 3
a1868 2
    int base;
    unsigned char temp;
d1872 1
d1874 1
a1874 4
    base = y * pSiS->CurrentLayout.displayWidth + x;

    if(pSiS->UseVESA) {

d1877 5
d1883 2
d1886 17
d1904 29
a1932 3
#ifdef UNLOCK_ALWAYS
        sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
d1934 1
a1934 21
   	if(pScrn->bitsPerPixel < 8) {
	        base = (y * pSiS->CurrentLayout.displayWidth + x + 3) >> 3;
    	} else {
	        base  = y * pSiS->CurrentLayout.displayWidth + x;

        	/* calculate base bpp dep. */
		switch(pSiS->CurrentLayout.bitsPerPixel) {
          	   case 16:
            		base >>= 1;
            		break;
          	   case 24:
            		base = ((base * 3)) >> 2;
            		base -= base % 6;
            		break;
          	   case 32:
            		break;
          	   default:      /* 8bpp */
            		base >>= 2;
            		break;
        	 }
    	}
d1936 1
a1936 67
#ifdef SISDUALHEAD
        if (pSiS->DualHeadMode) {
		/* TW: We assume that DualHeadMode only can be true for
		 *     dual head capable chipsets (and thus save the check
		 *     for chipset here)
		 */
		if (!pSiS->SecondHead) {
			/* TW: Head 1 (master) is always CRT2 */
   			SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
                	outSISIDXREG(SISPART1, 0x06, GETVAR8(base));
                	outSISIDXREG(SISPART1, 0x05, GETBITS(base, 15:8));
                	outSISIDXREG(SISPART1, 0x04, GETBITS(base, 23:16));
			if (pSiS->VGAEngine == SIS_315_VGA) {
			   setSISIDXREG(SISPART1, 0x02, 0x7F, ((base >> 24) & 0x01) << 7);
			}
                	SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
		} else {
			/* TW: Head 2 (slave) is always CRT1 */
			base += (pSiS->dhmOffset/4);
			outSISIDXREG(SISCR, 0x0D, base & 0xFF);
			outSISIDXREG(SISCR, 0x0C, (base >> 8) & 0xFF);
			outSISIDXREG(SISSR, 0x0D, (base >> 16) & 0xFF);
			if (pSiS->VGAEngine == SIS_315_VGA) {
			    setSISIDXREG(SISSR, 0x37, 0xFE, (base >> 24) & 0x01);
			}
		}
	} else {
#endif
    	   switch (pSiS->VGAEngine)  {
           	case SIS_300_VGA:
			outSISIDXREG(SISCR, 0x0D, base & 0xFF);
			outSISIDXREG(SISCR, 0x0C, (base >> 8) & 0xFF);
			outSISIDXREG(SISSR, 0x0D, (base >> 16) & 0xFF);
            		if (pSiS->VBFlags & CRT2_ENABLE) {
                		SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
                		outSISIDXREG(SISPART1, 0x06, GETVAR8(base));
                		outSISIDXREG(SISPART1, 0x05, GETBITS(base, 15:8));
                		outSISIDXREG(SISPART1, 0x04, GETBITS(base, 23:16));
                		SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
            		}
            		break;
	   	case SIS_315_VGA:
			outSISIDXREG(SISCR, 0x0D, base & 0xFF);
			outSISIDXREG(SISCR, 0x0C, (base >> 8) & 0xFF);
			outSISIDXREG(SISSR, 0x0D, (base >> 16) & 0xFF);
			setSISIDXREG(SISSR, 0x37, 0xFE, (base >> 24) & 0x01);
            		if (pSiS->VBFlags & CRT2_ENABLE) {
                		SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
                		outSISIDXREG(SISPART1, 0x06, GETVAR8(base));
                		outSISIDXREG(SISPART1, 0x05, GETBITS(base, 15:8));
                		outSISIDXREG(SISPART1, 0x04, GETBITS(base, 23:16));
				setSISIDXREG(SISPART1, 0x02, 0x7F, ((base >> 24) & 0x01) << 7);
                		SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pSiS->RelIO+0x30);
            		}
            		break;
        	default:
		        outSISIDXREG(SISCR, 0x0D, base & 0xFF);
			outSISIDXREG(SISCR, 0x0C, (base >> 8) & 0xFF);
			inSISIDXREG(SISSR, 0x27, temp);
			temp &= 0xF0;
			temp |= (base & 0x0F0000) >> 16;
			outSISIDXREG(SISSR, 0x27, temp);
    		}
#ifdef SISDUALHEAD
	}
#endif
    } /* if not VESA */
a1939 1

d1943 3
a1945 1
 * Mandatory!
d1947 2
d1953 1
d1955 1
d1957 1
a1957 5
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);

    if(!SISModeInit(pScrn, pScrn->currentMode)) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"SiSEnterVT: SISModeInit() failed\n");
a1958 1
    }
d1962 2
a1963 3
#ifdef XF86DRI
    /* TW: this is to be done AFTER switching the mode */
    if(pSiS->directRenderingEnabled)
d1973 2
a1974 1
 * Mandatory!
d1976 2
d1983 2
a1984 1
    SISPtr pSiS = SISPTR(pScrn);
d1987 3
d1991 2
a1992 2
    /* TW: to be done before mode change */
    if(pSiS->directRenderingEnabled) {
a1997 22
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode && pSiS->SecondHead) return;
#endif
    
    if(pSiS->CursorInfoPtr) {
#ifdef SISDUALHEAD    
       if(pSiS->DualHeadMode) {
          if(!pSiS->SecondHead) {
	      pSiS->ForceCursorOff = TRUE;
	      pSiS->CursorInfoPtr->HideCursor(pScrn);
	      SISWaitVBRetrace(pScrn);
	      pSiS->ForceCursorOff = FALSE;
	  }
       } else {   
#endif
          pSiS->CursorInfoPtr->HideCursor(pScrn);
          SISWaitVBRetrace(pScrn);
#ifdef SISDUALHEAD	  
       }	
#endif       
    }

d2000 1
a2000 2
    if(pSiS->UseVESA) {

d2002 1
a2002 1
    	 *     VBESaveRestore() does not restore CRT1. So we set any mode now,
d2007 1
a2007 2
	           VBESetVBEMode(pSiS->pVbe, (pSiS->SISVESAModeList->n) | 0xc000, NULL);

d2009 1
d2011 1
a2011 5
    } else {
       
       SISRestore(pScrn);
       
    }
a2019 1
 * Mandatory!
d2021 2
d2029 1
a2029 3
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
d2032 1
a2032 1
    if(pSiS->directRenderingEnabled) {
d2034 1
a2034 1
        pSiS->directRenderingEnabled = FALSE;
d2038 3
a2040 20
    if(pScrn->vtSema) {

        if(pSiS->CursorInfoPtr) {
#ifdef SISDUALHEAD    
           if(pSiS->DualHeadMode) {
              if(!pSiS->SecondHead) {
	         pSiS->ForceCursorOff = TRUE;
	         pSiS->CursorInfoPtr->HideCursor(pScrn);
	         SISWaitVBRetrace(pScrn);
	         pSiS->ForceCursorOff = FALSE;
	      }
           } else {   
#endif
             pSiS->CursorInfoPtr->HideCursor(pScrn);
             SISWaitVBRetrace(pScrn);
#ifdef SISDUALHEAD	  
           }	
#endif      	
	}

d2042 3
a2044 5

	if(pSiS->UseVESA) {

	  /* TW: This is a q&d work-around for a BIOS bug. In case we disabled CRT2,
    	   *     VBESaveRestore() does not restore CRT1. So we set any mode now,
d2048 2
a2049 3
           if( (pSiS->VBFlags & VB_VIDEOBRIDGE) && (!(pSiS->VBFlags & DISPTYPE_DISP2)))
	           VBESetVBEMode(pSiS->pVbe, (pSiS->SISVESAModeList->n) | 0xc000, NULL);

a2050 5

	} else {

	   SISRestore(pScrn);

d2052 1
a2052 1

d2054 1
d2056 1
a2056 17

    SISUnmapMem(pScrn);
    vgaHWUnmapMem(pScrn);
    
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
    	pSiSEnt = pSiS->entityPrivate;
    	pSiSEnt->refCount--;
    }
#endif    

    if(pSiS->pInt) {
	xf86FreeInt10(pSiS->pInt);
	pSiS->pInt = NULL;
    }

    if(pSiS->AccelInfoPtr) {
d2058 2
a2059 23
	pSiS->AccelInfoPtr = NULL;
    }

    if(pSiS->CursorInfoPtr) {
        xf86DestroyCursorInfoRec(pSiS->CursorInfoPtr);
	pSiS->CursorInfoPtr = NULL;
    }

    if(pSiS->ShadowPtr) {
        xfree(pSiS->ShadowPtr);
	pSiS->ShadowPtr = NULL;
    }

    if(pSiS->DGAModes) {
        xfree(pSiS->DGAModes);
	pSiS->DGAModes = NULL;
    }

    if(pSiS->adaptor) {
    	xfree(pSiS->adaptor);
	pSiS->adaptor = NULL;
    }

d2061 1
a2061 4

    /* Restore Blockhandler */
    pScreen->BlockHandler = pSiS->BlockHandler;

d2088 11
a2098 17
    if(pSiS->UseVESA) {
	if(SiSCalcVESAModeIndex(pScrn, mode))
	    return(MODE_OK);
	else
	    return(MODE_BAD);
    }
    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
#ifdef SISDUALHEAD
        if((pSiS->DualHeadMode) && (pSiS->SecondHead)) {
	    /* DHM: Only check modes for CRT1 */
	    if(SiS_CalcModeIndex(pScrn, mode) < 0x14)
	      	return(MODE_BAD);
	} else
#endif
	    if(SiS_CheckCalcModeIndex(pScrn, mode, pSiS->VBFlags) < 0x14)
	        return(MODE_BAD);

a2110 1

a2113 1

d2115 15
a2129 62
#ifdef UNLOCK_ALWAYS
        sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

	if(pSiS->VGAEngine == SIS_300_VGA) {

	   if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
	       if(!xf86IsUnblank(mode)) {
	          pSiS->Blank = TRUE;
	  	  SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
	       } else {
	          pSiS->Blank = FALSE;
	          SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	       }
	   } else {
	      /* if not blanked obtain state of LCD blank flags set by BIOS */
	      if(!pSiS->Blank) {
	         inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
	      }

	      if(!xf86IsUnblank(mode)) {
    		 pSiS->Blank = TRUE;
		 outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
	      } else {
    		 pSiS->Blank = FALSE;
    		 /* don't just unblanking; use LCD state set by BIOS */
		 outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
	      }
	  }

	} else if(pSiS->VGAEngine == SIS_315_VGA) {

	   if(!pSiS->Blank) {
		inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
	   }

	   if(pSiS->VBFlags & VB_CHRONTEL) {
	       if(!xf86IsUnblank(mode)) {
		  pSiS->Blank = TRUE;
		  SiS_Chrontel701xBLOff(pSiS->SiS_Pr);
	       } else {
	          pSiS->Blank = FALSE;
	          SiS_Chrontel701xBLOn(pSiS->SiS_Pr);
	       }
	   } else if(pSiS->VBFlags & VB_LVDS) {
	       if(!xf86IsUnblank(mode)) {
	          pSiS->Blank = TRUE;
	 	  outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
	       } else {
	          pSiS->Blank = FALSE;
	  	  outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
	       }
	   } else if(pSiS->VBFlags & (VB_301B|VB_302B|VB_30xLV|VB_30xLVX)) {
	       if(!xf86IsUnblank(mode)) {
	          pSiS->Blank = TRUE;
	  	  SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
	       } else {
	          pSiS->Blank = FALSE;
	          SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	       }
	   }

a2130 1

d2136 2
a2137 94
#ifdef SISDUALHEAD
/* TW: SaveScreen for dual head mode */
static Bool
SISSaveScreenDH(ScreenPtr pScreen, int mode)
{
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];

    if ((pScrn != NULL) && pScrn->vtSema) {

    	SISPtr pSiS = SISPTR(pScrn);
	if (pSiS->SecondHead) {

	    /* Slave head is always CRT1 */
	    return vgaHWSaveScreen(pScreen, mode);

	} else {

	    /* Master head is always CRT2 */

	    /* We can only blank LCD, not other CRT2 devices */
	    if(!(pSiS->VBFlags & CRT2_LCD)) return TRUE;

	    /* enable access to extended sequencer registers */
#ifdef UNLOCK_ALWAYS
            sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

 	    if(pSiS->VGAEngine == SIS_300_VGA) {

	        if(pSiS->VBFlags & (VB_30xLV|VB_30xLVX)) {
		   if(!xf86IsUnblank(mode)) {
		         pSiS->BlankCRT2 = TRUE;
			 SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
		   } else {
		         pSiS->BlankCRT2 = FALSE;
		         SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
		   }
		} else {
		   /* if not blanked obtain state of LCD blank flags set by BIOS */
		   if(!pSiS->BlankCRT2) {
		        inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		   }

		   if (!xf86IsUnblank(mode)) {
    			pSiS->BlankCRT2 = TRUE;
			outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
		   } else {
    			pSiS->BlankCRT2 = FALSE;
    			/* don't just unblank; use LCD state set by BIOS */
			outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		   }
		}

            } else if(pSiS->VGAEngine == SIS_315_VGA) {

 		if(!pSiS->BlankCRT2) {
			inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		}

	        if(pSiS->VBFlags & VB_CHRONTEL) {
		      if(!xf86IsUnblank(mode)) {
			  pSiS->BlankCRT2 = TRUE;
			  SiS_Chrontel701xBLOff(pSiS->SiS_Pr);
		      } else {
		          pSiS->BlankCRT2 = FALSE;
		          SiS_Chrontel701xBLOn(pSiS->SiS_Pr);
		      }
		} else if(pSiS->VBFlags & VB_LVDS) {
		      if(!xf86IsUnblank(mode)) {
		         pSiS->BlankCRT2 = TRUE;
			 outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
		      } else {
		         pSiS->BlankCRT2 = FALSE;
			 outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		      }
		} else if(pSiS->VBFlags & (VB_301B|VB_302B|VB_30xLV|VB_30xLVX)) {
		      if(!xf86IsUnblank(mode)) {
		         pSiS->BlankCRT2 = TRUE;
			 SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
		      } else {
		         pSiS->BlankCRT2 = FALSE;
		         SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
		      }
		}

	    }
	}
    }
    return TRUE;
}
#endif

#ifdef DEBUG
/* locally used for debug */
d2157 13
d2177 17
a2193 2
#if 1
    if(mode->CrtcHBlankStart == mode->CrtcHDisplay)
d2195 1
a2195 1
    if(mode->CrtcHBlankEnd == mode->CrtcHTotal)
d2197 1
a2197 1
    if(mode->CrtcVBlankStart == mode->CrtcVDisplay)
d2199 1
a2199 1
    if(mode->CrtcVBlankEnd == mode->CrtcVTotal)
a2200 1
#endif
d2203 1
a2203 3
/* TW: Enable the TurboQueue (For 300 and 310/325 series only) */
void
SiSEnableTurboQueue(ScrnInfoPtr pScrn)
d2206 2
d2209 1
d2211 1
d2213 42
a2254 46
    switch (pSiS->VGAEngine) {
	case SIS_300_VGA:
	   if ((!pSiS->NoAccel) && (pSiS->TurboQueue)) {
	        /* TQ size is always 512k */
           	temp = (pScrn->videoRam/64) - 8;
           	SR26 = temp & 0xFF;
           	inSISIDXREG(SISSR, 0x27, SR27);
		SR27 &= 0xFC;
		SR27 |= (0xF0 | ((temp >> 8) & 3));
           	outSISIDXREG(SISSR, 0x26, SR26);
           	outSISIDXREG(SISSR, 0x27, SR27);
	   }
	   break;
	case SIS_315_VGA:
	   if (!pSiS->NoAccel) {
	      /* TW: On 310/325 series, there are three queue modes available
	       *     which are chosen by setting bits 7:5 in SR26:
	       * 1. MMIO queue mode (bit 5, 0x20). The hardware will keep
	       *    track of the queue, the FIFO, command parsing and so
	       *    on. This is the one comparable to the 300 series.
	       * 2. VRAM queue mode (bit 6, 0x40). In this case, one will
	       *    have to do queue management himself. Register 0x85c4 will
	       *    hold the location of the next free queue slot, 0x85c8
	       *    is the "queue read pointer" whose way of working is
	       *    unknown to me. Anyway, this mode would require a
	       *    translation of the MMIO commands to some kind of
	       *    accelerator assembly and writing these commands
	       *    to the memory location pointed to by 0x85c4.
	       *    We will not use this, as nobody knows how this
	       *    "assembly" works, and as it would require a complete
	       *    re-write of the accelerator code.
	       * 3. AGP queue mode (bit 7, 0x80). Works as 2., but keeps the
	       *    queue in AGP memory space.
	       * We go MMIO here.
	       * SR26 bit 4 is called "Bypass H/W queue".
	       * SR26 bit 1 is called "Enable Command Queue Auto Correction"
	       * SR26 bit 0 resets the queue
	       * Size of queue memory is encoded in bits 3:2 like this:
	       *    00  (0x00)  512K
	       *    01  (0x04)  1M
	       *    10  (0x08)  2M
	       *    11  (0x0C)  4M
	       * The queue location is to be written to 0x85C0.
	       */
#if 0
	      if (pSiS->TurboQueue) {
d2256 46
a2301 26
	   	/* TW: We only use MMIO Cmd Queue, not VRAM or AGP */
	   	/* TW: Set Command Queue Threshold to max value 11111b */
	   	outSISIDXREG(SISSR, 0x27, 0x1F);
	   	/* TW: Syncronous reset for Command Queue */
	   	outSISIDXREG(SISSR, 0x26, 0x01);
	   	/* TW: Do some magic (cp readport to writeport) */
	   	temp = MMIO_IN32(pSiS->IOBase, 0x85C8);
	   	MMIO_OUT32(pSiS->IOBase, 0x85C4, temp);
	   	/* TW: Enable MMIO Command Queue mode (0x20),
		 *     Enable_command_queue_auto_correction (0x02)   
		 *             (no idea, but sounds good, so use it)
		 *     512k (0x00) (does this apply to MMIO mode?) */
    	   	outSISIDXREG(SISSR, 0x26, 0x22);
	   	/* TW: Calc Command Queue position (Q is always 512k)*/
	   	temp = (pScrn->videoRam - 512) * 1024;
	   	/* TW: Set Q position */
	   	MMIO_OUT32(pSiS->IOBase, 0x85C0, temp);
#if 0
              } else {
	      	/* TW: Is there a non-TurboQueue mode within MMIO mode? */
	      }
#endif
	   }
	   break;
	default:
	   break;
d2303 3
d2308 2
a2309 4
/* TW: Things to do before a ModeSwitch. We set up the
 *     video bridge configuration and the TurboQueue.
 */
void SiSPreSetMode(ScrnInfoPtr pScrn, DisplayModePtr mode)
d2311 8
a2318 6
    SISPtr         pSiS = SISPTR(pScrn);
    unsigned char  usScratchCR30, usScratchCR31;
    unsigned char  usScratchCR32, usScratchCR33;
    unsigned char  usScratchCR17, usScratchCR38 = 0;
    int            vbflag, temp = 0;
    int 	   crt1rateindex = 0;
d2320 3
a2322 3
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);    /* Unlock Registers */
#endif
d2324 1
a2324 8
    vbflag = pSiS->VBFlags;
    pSiS->IsCustom = FALSE;
    
    if(pSiS->HaveCustomModes) {
       if(!(mode->type & M_T_DEFAULT)) {
	 pSiS->IsCustom = TRUE;
       }
    }
d2326 2
a2327 14
    /* TW: The CR3x registers are for communicating with our BIOS emulation
     * code (native code in init.c/init301.c) or the BIOS (via VESA)
     */
    inSISIDXREG(SISCR, 0x30, usScratchCR30);  /* Bridge config */
    inSISIDXREG(SISCR, 0x31, usScratchCR31);  /* Bridge config */
    usScratchCR32 = pSiS->newCR32;            /* Bridge connection info (use our new value) */
    inSISIDXREG(SISCR, 0x33, usScratchCR33);  /* CRT1 refresh rate index */
    if(pSiS->Chipset != PCI_CHIP_SIS300) {
       switch(pSiS->VGAEngine) {
       case SIS_300_VGA: temp = 0x35; break;
       case SIS_315_VGA: temp = 0x38; break;
       }
    }
    if(temp) inSISIDXREG(SISCR, temp, usScratchCR38); /* PAL-M, PAL-N selection */
d2329 5
a2333 1
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3, "VBFlags=0x%x\n", pSiS->VBFlags);
d2335 2
a2336 3
    xf86DrvMsgVerb(pScrn->scrnIndex, X_PROBED, 3, 
	   "Before: CR30=0x%02x, CR31=0x%02x, CR32=0x%02x, CR33=0x%02x, CR%02x=0x%02x\n",
              usScratchCR30, usScratchCR31, usScratchCR32, usScratchCR33, temp, usScratchCR38);
d2338 2
a2339 11
    usScratchCR30 = 0;
    usScratchCR31 &= ~0x60;  /* TW: Clear VB_Drivermode & VB_OutputDisable */
#if 0  /* TW: For future use */
    if( (pSiS->VBFlags & VB_LVDS) ||
        (pSiS->VBFlags & VB_301)  ||
        ( (pSiS->VBFlags & (VB_301B | VB_302B |VB_30xLV | VB_30xLVX)) &&
	  (!(pSiS->VBLCDFlags & VB_LCD_1400x1050)) ) ) {
#endif
       usScratchCR31 |= 0x04;   /* TW: Set VB_NotSimuMode (not for 30xB/1400x1050?) */
#if 0
    }
d2341 1
d2343 2
a2344 1276
    switch(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {
      case CRT2_TV:
          	if(vbflag & TV_CHSCART) {
				usScratchCR38 |= 0x04;
				usScratchCR31 |= 0x01;
		} else if(vbflag & TV_CHHDTV) {
				usScratchCR38 |= 0x08;
				usScratchCR31 &= ~0x01;
        	} else if(vbflag & TV_HIVISION)
		          	usScratchCR30 |= 0x80;
		else if(vbflag & TV_SVIDEO)
				usScratchCR30 |= 0x08;
		else if(vbflag & TV_AVIDEO)
				usScratchCR30 |= 0x04;
		else if(vbflag & TV_SCART)
				usScratchCR30 |= 0x10;
		else 
			        usScratchCR30 |= 0x08;    /* default: SVIDEO */

		if(!(vbflag & (TV_CHSCART | TV_CHHDTV))) {
		    if(vbflag & TV_PAL) {
				usScratchCR31 |= 0x01;
				usScratchCR38 &= ~0xC0;
		                if( (vbflag & VB_SISBRIDGE) ||
		                    ((vbflag & VB_CHRONTEL) && (pSiS->ChrontelType == CHRONTEL_701x)) )  {
					if(vbflag & TV_PALM)      usScratchCR38 |= 0x40;
					else if(vbflag & TV_PALN) usScratchCR38 |= 0x80;
		    		}
		    } else
				usScratchCR31 &= ~0x01;
		}

		usScratchCR30 |= 0x01;    /* Set SimuScanMode  */

		usScratchCR31 &= ~0x04;   /* Clear NotSimuMode */
		pSiS->SiS_Pr->SiS_CHOverScan = pSiS->UseCHOverScan;
		if(pSiS->OptTVSOver == 1) {
			pSiS->SiS_Pr->SiS_CHSOverScan = TRUE;
		} else {
		        pSiS->SiS_Pr->SiS_CHSOverScan = FALSE;
		}
                break;
      case CRT2_LCD:
                usScratchCR30 |= 0x21;    /* LCD + SimuScanMode */
                break;
      case CRT2_VGA:
                usScratchCR30 |= 0x41;    /* VGA2 + SimuScanMode */
                break;
      default:
            	usScratchCR30 |= 0x00;
            	usScratchCR31 |= 0x20;    /* VB_OUTPUT_DISABLE */
		if(pSiS->UseVESA) {
		   crt1rateindex = SISSearchCRT1Rate(pScrn, mode);
		}
    }
    /* TW: for VESA: no DRIVERMODE, otherwise
     * -) CRT2 will not be initialized correctly when using mode
     *    where LCD has to scale, and
     * -) CRT1 will have too low rate
     */
     if (pSiS->UseVESA) {
        usScratchCR31 &= 0x40;  /* TW: Clear Drivermode */
#ifdef TWDEBUG
        usScratchCR31 |= 0x40;  /* DEBUG (for non-slave mode VESA) */
	crt1rateindex = SISSearchCRT1Rate(pScrn, mode);
#endif
     } else {
        usScratchCR31 |=  0x40;                 /* TW: Set Drivermode */
	if(!pSiS->IsCustom) {
           crt1rateindex = SISSearchCRT1Rate(pScrn, mode);
	} else {
	   crt1rateindex = usScratchCR33;
	}
     }
     outSISIDXREG(SISCR, 0x30, usScratchCR30);
     outSISIDXREG(SISCR, 0x31, usScratchCR31);
     if(temp) {
        usScratchCR38 &= ~0x03;   /* Clear LCDA/DualEdge bits */
     	outSISIDXREG(SISCR, temp, usScratchCR38);
     }

     pSiS->SiS_Pr->SiS_UseOEM = pSiS->OptUseOEM;

#ifdef SISDUALHEAD
     if(pSiS->DualHeadMode) {
        if(pSiS->SecondHead) {
	    /* CRT1 */
	    usScratchCR33 &= 0xf0;
	    usScratchCR33 |= (crt1rateindex & 0x0f);
	} else {
	    /* CRT2 */
	    usScratchCR33 &= 0x0f;
	    if(vbflag & CRT2_VGA) usScratchCR33 |= ((crt1rateindex << 4) & 0xf0);
	}
     } else {
#endif
        if(vbflag & CRT2_VGA) {
           usScratchCR33 = (crt1rateindex & 0x0f) | ((crt1rateindex & 0x0f) << 4);
	} else {
	   usScratchCR33 = crt1rateindex & 0x0f;
	}
	if((!(pSiS->UseVESA)) && (vbflag & CRT2_ENABLE)) {
#ifndef TWDEBUG	
	   if(pSiS->CRT1off) usScratchCR33 &= 0xf0;
#endif	   
	}
#ifdef SISDUALHEAD
     }
#endif
     outSISIDXREG(SISCR, 0x33, usScratchCR33);

     xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
		"After:  CR30=0x%02x, CR31=0x%02x, CR33=0x%02x\n",
		    usScratchCR30, usScratchCR31, usScratchCR33);

     /* Enable TurboQueue */
     SiSEnableTurboQueue(pScrn);

     if((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_ENABLE)) {
        /* Switch on CRT1 for modes that require the bridge in SlaveMode */
	inSISIDXREG(SISCR, 0x17, usScratchCR17);
	if(!(usScratchCR17 & 0x80)) {
          orSISIDXREG(SISCR, 0x17, 0x80);
	  outSISIDXREG(SISSR, 0x00, 0x01);
	  usleep(10000);
          outSISIDXREG(SISSR, 0x00, 0x03);
	}
     }

}

/* Functions for adjusting various TV settings */

/* These are used by the PostSetMode() functions as well as
 * the (hopefully) upcoming display properties extension/tool.
 *
 * There is each a Set and a Get routine. The Set functions
 * take a value of the same range as the corresponding option.
 * The Get routines return a value of the same range (although
 * not necessarily the same value as previously set because
 * of the lower resolution of the respective setting compared
 * to the valid range).
 * The Get routines return -2 on error (eg. hardware does not
 * support this setting).
 * Note: The x and y positioning routines accept a position
 * RELATIVE to the default position. All other routines 
 * take ABSOLUTE values.
 *
 * The Set functions will store the property regardless if TV is
 * currently used or not and if the hardware supports the property
 * or not. The Get routines will return this stored
 * value if TV is not currently used (because the register does
 * not contain the correct value then) or if the hardware supports
 * the respective property. This should make it easier for the 
 * display property tool because it does not have to know the
 * hardware features.
 *
 * All the routines are dual head aware. It does not matter
 * if the function is called from the CRT1 or CRT2 session.
 * The values will be stored in pSiSEnt if we're running dual.
 */

void SiS_SetCHTVlumabandwidthcvbs(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
   
   pSiS->chtvlumabandwidthcvbs = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvlumabandwidthcvbs = val;
#endif

   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   
   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 8;
           if((val == 0) || (val == 1)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x03),0xFE);
           }
	   break;
       case CHRONTEL_701x:
           val /= 4;
	   if((val >= 0) && (val <= 3)) {
	       SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x02),0xFC);
	   }
           break;
   }   
}

int SiS_GetCHTVlumabandwidthcvbs(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvlumabandwidthcvbs;
      else 
#endif
           return (int)pSiS->chtvlumabandwidthcvbs;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x01) * 8);
      case CHRONTEL_701x:
	   return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x03) * 4);
      default:
           return -2;   
      }
   }
}

void SiS_SetCHTVlumabandwidthsvideo(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvlumabandwidthsvideo = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvlumabandwidthsvideo = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
      
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 6;
           if((val >= 0) && (val <= 2)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 9) | 0x03),0xF9);
           }
	   break;
       case CHRONTEL_701x:
           val /= 4;
	   if((val >= 0) && (val <= 3)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 10) | 0x02),0xF3);
	   }
           break;
   }	   
}

int SiS_GetCHTVlumabandwidthsvideo(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvlumabandwidthsvideo;
      else 
#endif
           return (int)pSiS->chtvlumabandwidthsvideo;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x06) >> 1) * 6);
      case CHRONTEL_701x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x0c) >> 2) * 4);
      default:
           return -2;   
      }
   }      
}

void SiS_SetCHTVlumaflickerfilter(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvlumaflickerfilter = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvlumaflickerfilter = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 6;
           if((val >= 0) && (val <= 2)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 10) | 0x01),0xF3);
           }
	   break;
       case CHRONTEL_701x:
           val /= 4;
	   if((val >= 0) && (val <= 3)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 10) | 0x01),0xF3);
	   }
           break;
   } 
}

int SiS_GetCHTVlumaflickerfilter(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
  
   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
          return (int)pSiSEnt->chtvlumaflickerfilter;
      else
#endif      
          return (int)pSiS->chtvlumaflickerfilter;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x0c) >> 2) * 6);
      case CHRONTEL_701x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x0c) >> 2) * 4);
      default:
           return -2;   
      }
   }     
}

void SiS_SetCHTVchromabandwidth(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvchromabandwidth = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvchromabandwidth = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 4;
           if((val >= 0) && (val <= 3)) {
              SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 12) | 0x03),0xCF);
           }
	   break;
       case CHRONTEL_701x:
           val /= 8;
	   if((val >= 0) && (val <= 1)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 12) | 0x02),0xEF);
	   }
           break;
   }	   
}

int SiS_GetCHTVchromabandwidth(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvchromabandwidth;
      else
#endif   
           return (int)pSiS->chtvchromabandwidth;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x30) >> 4) * 4);
      case CHRONTEL_701x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x10) >> 4) * 8);
      default:
           return -2;   
      }
   }    
}

void SiS_SetCHTVchromaflickerfilter(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvchromaflickerfilter = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvchromaflickerfilter = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 6;
           if((val >= 0) && (val <= 2)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 12) | 0x01),0xCF);
           }
	   break;
       case CHRONTEL_701x:
           val /= 4;
	   if((val >= 0) && (val <= 3)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 12) | 0x01),0xCF);
	   }
           break;
   }	   
}

int SiS_GetCHTVchromaflickerfilter(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvchromaflickerfilter;
      else
#endif
           return (int)pSiS->chtvchromaflickerfilter;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x30) >> 4) * 6);
      case CHRONTEL_701x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x30) >> 4) * 4);
      default:
           return -2;   
      }
   }    
}

void SiS_SetCHTVcvbscolor(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvcvbscolor = val ? 1 : 0;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvcvbscolor = pSiS->chtvcvbscolor;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   
   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           if(!val)  SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x4003,0x00);
           else      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x0003,~0x40);
	   break;
       case CHRONTEL_701x:
           if(!val)  SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x0002,~0x20);
	   else      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, 0x2002,0x00);
           break;
   }	   
}

int SiS_GetCHTVcvbscolor(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvcvbscolor;
      else
#endif
           return (int)pSiS->chtvcvbscolor;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x40) >> 6) ^ 0x01);
      case CHRONTEL_701x:
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x02) & 0x20) >> 5) ^ 0x01);
      default:
           return -2;   
      }
   }    
}

void SiS_SetCHTVtextenhance(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvtextenhance = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvtextenhance = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
           val /= 6;
           if((val >= 0) && (val <= 2)) {
              SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x01),0xFC);
           }
	   break;
       case CHRONTEL_701x:
           val /= 2;
	   if((val >= 0) && (val <= 7)) {
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x03),0xF8);
	   }
           break;
   }	   
}

int SiS_GetCHTVtextenhance(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvtextenhance;
      else
#endif      
           return (int)pSiS->chtvtextenhance;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
	   return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x03) * 6);
      case CHRONTEL_701x:
	   return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x03) & 0x07) * 2);
      default:
           return -2;   
      }
   }
}

void SiS_SetCHTVcontrast(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->chtvcontrast = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->chtvcontrast = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_CHRONTEL)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   val /= 2;
   if((val >= 0) && (val <= 7)) {
       switch(pSiS->ChrontelType) {
       case CHRONTEL_700x:
              SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x11),0xF8);
	      break;
       case CHRONTEL_701x:
	      SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((val << 8) | 0x08),0xF8);
              break;
       } 
   } 	  
}

int SiS_GetCHTVcontrast(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_CHRONTEL && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->chtvcontrast;
      else
#endif      
           return (int)pSiS->chtvcontrast;
   } else {
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif   
      switch(pSiS->ChrontelType) {
      case CHRONTEL_700x:
           return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x11) & 0x07) * 2);
      case CHRONTEL_701x:
	   return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x08) & 0x07) * 2);
      default:
           return -2;   
      }
   }
}

void SiS_SetSISTVedgeenhance(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->sistvedgeenhance = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->sistvedgeenhance = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_301)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   val /= 2;
   if((val >= 0) && (val <= 7)) {
       setSISIDXREG(SISPART2,0x3A, 0x1F, (val << 5));
   }
}

int SiS_GetSISTVedgeenhance(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_301 && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->sistvedgeenhance;
      else 
#endif      
           return (int)pSiS->sistvedgeenhance;
   } else {
      unsigned char temp;
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif      
      inSISIDXREG(SISPART2, 0x3a, temp);
      return(int)(((temp & 0xe0) >> 5) * 2);
   }
}

void SiS_SetSISTVantiflicker(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->sistvantiflicker = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->sistvantiflicker = val;
#endif
   
   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   val /= 2;
   if((val >= 0) && (val <= 7)) {
      setSISIDXREG(SISPART2,0x0A,0x8F, (val << 4));
   }
}

int SiS_GetSISTVantiflicker(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   if(!(pSiS->VBFlags & VB_SISBRIDGE && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->sistvantiflicker;
      else
#endif      
           return (int)pSiS->sistvantiflicker;  
   } else {
      unsigned char temp;
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif      
      inSISIDXREG(SISPART2, 0x0a, temp);
      return(int)(((temp & 0x70) >> 4) * 2);
   }
}

void SiS_SetSISTVsaturation(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->sistvsaturation = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->sistvsaturation = val;
#endif

   if(!(pSiS->VBFlags & CRT2_TV)) return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   val /= 2;
   if((val >= 0) && (val <= 7)) {
      setSISIDXREG(SISPART4,0x21,0xF8, val);
   }
}

int SiS_GetSISTVsaturation(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
   
   if(!(pSiS->VBFlags & VB_SISBRIDGE && pSiS->VBFlags & CRT2_TV)) {
#ifdef SISDUALHEAD   
      if(pSiSEnt && pSiS->DualHeadMode) 
           return (int)pSiSEnt->sistvsaturation;
      else
#endif      
           return (int)pSiS->sistvsaturation;
   } else {
      unsigned char temp;
#ifdef UNLOCK_ALWAYS
      sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif      
      inSISIDXREG(SISPART4, 0x21, temp);
      return(int)((temp & 0x07) * 2);
   }
}

void SiS_SetSIS6326TVantiflicker(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;
   
   pSiS->sis6326antiflicker = val;

   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
  
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) return;
   
   /* Valid values: 0=off, 1=low, 2=med, 3=high, 4=adaptive */
   if(val >= 0 && val <= 4) {
      tmp &= 0x1f;
      tmp |= (val << 5);
      SiS6326SetTVReg(pScrn,0x00,tmp);
   }
}

int SiS_GetSIS6326TVantiflicker(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;
   
   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
      return (int)pSiS->sis6326antiflicker;
   }
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) {
      return (int)pSiS->sis6326antiflicker;
   } else {
      return (int)((tmp >> 5) & 0x07);    
   }
}

void SiS_SetSIS6326TVenableyfilter(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;

   if(val) val = 1;   
   pSiS->sis6326enableyfilter = val;

   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
  
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) return;
   
   tmp = SiS6326GetTVReg(pScrn,0x43);
   tmp &= ~0x10;
   tmp |= ((val & 0x01) << 4);
   SiS6326SetTVReg(pScrn,0x43,tmp);
}

int SiS_GetSIS6326TVenableyfilter(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;
   
   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
      return (int)pSiS->sis6326enableyfilter;
   }
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) {
      return (int)pSiS->sis6326enableyfilter;
   } else {
      tmp = SiS6326GetTVReg(pScrn,0x43);
      return (int)((tmp >> 4) & 0x01);
   }
}

void SiS_SetSIS6326TVyfilterstrong(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;
   
   if(val) val = 1;
   pSiS->sis6326yfilterstrong = val;

   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
  
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) return;
   
   tmp = SiS6326GetTVReg(pScrn,0x43);
   if(tmp & 0x10) {
      tmp &= ~0x40;
      tmp |= ((val & 0x01) << 6);
      SiS6326SetTVReg(pScrn,0x43,tmp);
   }
}

int SiS_GetSIS6326TVyfilterstrong(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   unsigned char tmp;
   
   if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) {
      return (int)pSiS->sis6326yfilterstrong;
   }
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   
   tmp = SiS6326GetTVReg(pScrn,0x00);
   if(!(tmp & 0x04)) {
      return (int)pSiS->sis6326yfilterstrong;
   } else {
      tmp = SiS6326GetTVReg(pScrn,0x43);
      if(!(tmp & 0x10)) {
         return (int)pSiS->sis6326yfilterstrong;
      } else {
         return (int)((tmp >> 6) & 0x01);
      }
   }
}
   
void SiS_SetTVxposoffset(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   pSiS->tvxpos = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->tvxpos = val;
#endif

   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
   
      if(pSiS->VBFlags & CRT2_TV) {
      
         if(pSiS->VBFlags & VB_CHRONTEL) {
	 
	    int x = pSiS->tvx;
#ifdef SISDUALHEAD
	    if(pSiSEnt && pSiS->DualHeadMode) x = pSiSEnt->tvx;
#endif
	    switch(pSiS->ChrontelType) {
	    case CHRONTEL_700x:
	       if((val >= -32) && (val <= 32)) {
		   x += val;
		   if(x < 0) x = 0;
		   SiS_SetCH700x(pSiS->SiS_Pr, (((x & 0xff) << 8) | 0x0a));
		   SiS_SetCH70xxANDOR(pSiS->SiS_Pr, (((x & 0x0100) << 1) | 0x08),0xFD);
	       }
	       break;
	    case CHRONTEL_701x:
	       /* TO DO */
	       break;
	    }
	    
	 } else if(pSiS->VBFlags & VB_SISBRIDGE) {
	 
	    if((val >= -32) && (val <= 32)) {
		unsigned char p2_1f,p2_2b,p2_2c,p2_2d,p2_43;
		const unsigned char p2_left_ntsc[8][4] = {
			{ 0x48, 0x63, 0x49, 0xf4 },
			{ 0x45, 0x60, 0x46, 0xf1 },
			{ 0x43, 0x6e, 0x44, 0xff },
			{ 0x40, 0x6b, 0x41, 0xfc },
			{ 0x3e, 0x69, 0x3f, 0xfa },
			{ 0x3c, 0x67, 0x3d, 0xf8 },
			{ 0x39, 0x64, 0x3a, 0xf5 },
			{ 0x37, 0x62, 0x38, 0xf3 }
		};
		const unsigned char p2_right_ntsc[8][4] = {
			{ 0x4b, 0x66, 0x4c, 0xf7 },
			{ 0x4c, 0x67, 0x4d, 0xf8 },
			{ 0x4e, 0x69, 0x4f, 0xfa },
			{ 0x4f, 0x6a, 0x50, 0xfb },
			{ 0x51, 0x6c, 0x52, 0xfd },
			{ 0x53, 0x6e, 0x54, 0xff },
			{ 0x55, 0x60, 0x56, 0xf1 },
			{ 0x56, 0x61, 0x57, 0xf2 }
		};
		const unsigned char p2_left_pal[8][4] = {
			{ 0x5b, 0x66, 0x5c, 0x87 },
			{ 0x59, 0x64, 0x5a, 0x85 },
			{ 0x56, 0x61, 0x57, 0x82 },
			{ 0x53, 0x6e, 0x54, 0x8f },
			{ 0x50, 0x6b, 0x51, 0x8c },
			{ 0x4d, 0x68, 0x4e, 0x89 },
			{ 0x4a, 0x65, 0x4b, 0x86 },
			{ 0x49, 0x64, 0x4a, 0x85 }
		};
		const unsigned char p2_right_pal[8][4] = {
			{ 0x5f, 0x6a, 0x60, 0x8b },
			{ 0x61, 0x6c, 0x62, 0x8d },
			{ 0x63, 0x6e, 0x64, 0x8f },
			{ 0x65, 0x60, 0x66, 0x81 },
			{ 0x66, 0x61, 0x67, 0x82 },
			{ 0x68, 0x63, 0x69, 0x84 },
			{ 0x69, 0x64, 0x6a, 0x85 },
			{ 0x6b, 0x66, 0x6c, 0x87 }
		};
		val /= 4;
		p2_2d = pSiS->p2_2d;
#ifdef SISDUALHEAD
	        if(pSiSEnt && pSiS->DualHeadMode) p2_2d = pSiSEnt->p2_2d;
#endif		
		p2_2d &= 0xf0;
		if(val < 0) {
		      val = -val;
		      if(val == 8) val = 7;
		      if(pSiS->VBFlags & TV_PAL) {
		         p2_1f = p2_left_pal[val][0];
		         p2_2b = p2_left_pal[val][1];
		         p2_2c = p2_left_pal[val][2];
		         p2_2d |= (p2_left_pal[val][3] & 0x0f);
		      } else {
		         p2_1f = p2_left_ntsc[val][0];
		         p2_2b = p2_left_ntsc[val][1];
		         p2_2c = p2_left_ntsc[val][2];
		         p2_2d |= (p2_left_ntsc[val][3] & 0x0f);
		      }
		} else {
		      if(val == 8) val = 7;
		      if(pSiS->VBFlags & TV_PAL) {
		         p2_1f = p2_right_pal[val][0];
		         p2_2b = p2_right_pal[val][1];
		         p2_2c = p2_right_pal[val][2];
		         p2_2d |= (p2_right_pal[val][3] & 0x0f);
		      } else {
		         p2_1f = p2_right_ntsc[val][0];
		         p2_2b = p2_right_ntsc[val][1];
		         p2_2c = p2_right_ntsc[val][2];
		         p2_2d |= (p2_right_ntsc[val][3] & 0x0f);
		      }
		}
		p2_43 = p2_1f + 3;
		SISWaitRetraceCRT2(pScrn);
	        outSISIDXREG(SISPART2,0x1f,p2_1f);
		outSISIDXREG(SISPART2,0x2b,p2_2b);
		outSISIDXREG(SISPART2,0x2c,p2_2c);
		outSISIDXREG(SISPART2,0x2d,p2_2d);
		outSISIDXREG(SISPART2,0x43,p2_43);
	     }
	 }
      }
   
   } else if(pSiS->Chipset == PCI_CHIP_SIS6326) {
   
      if(pSiS->SiS6326Flags & SIS6326_TVDETECTED) {
      
         unsigned char tmp;
	 unsigned short temp1, temp2, temp3;
	 
         tmp = SiS6326GetTVReg(pScrn,0x00);
         if(tmp & 0x04) {
	    
	    temp1 = pSiS->tvx1;
            temp2 = pSiS->tvx2;
            temp3 = pSiS->tvx3;
            if((val >= -16) && (val <= 16)) {
	       if(val > 0) {   
	          temp1 += (val * 4);
	          temp2 += (val * 4);
	          while((temp1 > 0x0fff) || (temp2 > 0x0fff)) {
	             temp1 -= 4;
		     temp2 -= 4;
	          }
	       } else {
	          val = -val;
	          temp3 += (val * 4);
	          while(temp3 > 0x03ff) {
	     	     temp3 -= 4;
	          } 
	       }
            }
            SiS6326SetTVReg(pScrn,0x3a,(temp1 & 0xff));
            tmp = SiS6326GetTVReg(pScrn,0x3c);
            tmp &= 0xf0;
            tmp |= ((temp1 & 0x0f00) >> 8);
            SiS6326SetTVReg(pScrn,0x3c,tmp);
            SiS6326SetTVReg(pScrn,0x26,(temp2 & 0xff));
            tmp = SiS6326GetTVReg(pScrn,0x27);
            tmp &= 0x0f;
            tmp |= ((temp2 & 0x0f00) >> 4);
            SiS6326SetTVReg(pScrn,0x27,tmp);
            SiS6326SetTVReg(pScrn,0x12,(temp3 & 0xff));
            tmp = SiS6326GetTVReg(pScrn,0x13);
            tmp &= ~0xC0;
            tmp |= ((temp3 & 0x0300) >> 2);
            SiS6326SetTVReg(pScrn,0x13,tmp);
	 }
      }
   }
}

int SiS_GetTVxposoffset(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
   
   if(pSiSEnt && pSiS->DualHeadMode) 
        return (int)pSiSEnt->tvxpos;
   else
#endif   
        return (int)pSiS->tvxpos;
}

void SiS_SetTVyposoffset(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
   
#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   pSiS->tvypos = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->tvypos = val;
#endif

   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
   
      if(pSiS->VBFlags & CRT2_TV) {
      
         if(pSiS->VBFlags & VB_CHRONTEL) {
	 
	    int y = pSiS->tvy;
#ifdef SISDUALHEAD
	    if(pSiSEnt && pSiS->DualHeadMode) y = pSiSEnt->tvy;
#endif
	    switch(pSiS->ChrontelType) {
	    case CHRONTEL_700x:
	       if((val >= -32) && (val <= 32)) {
		   y -= val;
		   if(y < 0) y = 0;
		   SiS_SetCH700x(pSiS->SiS_Pr, (((y & 0xff) << 8) | 0x0b));
		   SiS_SetCH70xxANDOR(pSiS->SiS_Pr, ((y & 0x0100) | 0x08),0xFE);
	       }
	       break;
	    case CHRONTEL_701x:
	       /* TO DO */
	       break;
	    }
	    
	 } else if(pSiS->VBFlags & VB_SISBRIDGE) {
	 
	    if((val >= -32) && (val <= 32)) {
		char p2_01, p2_02;
		val /= 4;
		p2_01 = pSiS->p2_01;
		p2_02 = pSiS->p2_02;
#ifdef SISDUALHEAD
	        if(pSiSEnt && pSiS->DualHeadMode) {
		   p2_01 = pSiSEnt->p2_01;
		   p2_02 = pSiSEnt->p2_02;
		}
#endif
		p2_01 += (val * 2);
		p2_02 += (val * 2);
		while((p2_01 <= 0) || (p2_02 <= 0)) {
		      p2_01 += 2;   
		      p2_02 += 2;   
		}
		SISWaitRetraceCRT2(pScrn);
		outSISIDXREG(SISPART2,0x01,p2_01);
		outSISIDXREG(SISPART2,0x02,p2_02);
	     }
	 }
	 
      } 
      
   } else if(pSiS->Chipset == PCI_CHIP_SIS6326) {
   
      if(pSiS->SiS6326Flags & SIS6326_TVDETECTED) {
      
         unsigned char tmp;
	 int temp1, limit;
	 
         tmp = SiS6326GetTVReg(pScrn,0x00);
         if(tmp & 0x04) {
	 
	    if((val >= -16) && (val <= 16)) {
	      temp1 = (unsigned short)pSiS->tvy1;
	      limit = (pSiS->SiS6326Flags & SIS6326_TVPAL) ? 625 : 525;
	      if(val > 0) {
                temp1 += (val * 4);
	        if(temp1 > limit) temp1 -= limit;
	      } else {
	        val = -val;
	        temp1 -= (val * 2);
	        if(temp1 <= 0) temp1 += (limit -1);
	      }
	      SiS6326SetTVReg(pScrn,0x11,(temp1 & 0xff));
	      tmp = SiS6326GetTVReg(pScrn,0x13);
	      tmp &= ~0x30;
	      tmp |= ((temp1 & 0x300) >> 4);
	      SiS6326SetTVReg(pScrn,0x13,tmp);
	      if(temp1 == 1)                                 tmp = 0x10;
	      else {
	       if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
	         if((temp1 <= 3) || (temp1 >= (limit - 2)))  tmp = 0x08;
	         else if(temp1 < 22)		 	     tmp = 0x02;
	         else 					     tmp = 0x04;
	       } else {
	         if((temp1 <= 5) || (temp1 >= (limit - 4)))  tmp = 0x08;
	         else if(temp1 < 19)			     tmp = 0x02;
	         else 					     tmp = 0x04;
	       }
	     }
	     SiS6326SetTVReg(pScrn,0x21,tmp);
           }
	 }
      }
   }
}

int SiS_GetTVyposoffset(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
   
   if(pSiSEnt && pSiS->DualHeadMode) 
        return (int)pSiSEnt->tvypos;
   else 
#endif   
        return (int)pSiS->tvypos;
}

/* TW: Disable CRT1 for saving bandwidth. This doesn't work with VESA;
 *     VESA uses the bridge in SlaveMode and switching CRT1 off while the
 *     bridge is in SlaveMode not that clever...
 */
void SiSPostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg)
a2345 296
    SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
    unsigned char usScratchCR17;
    Bool flag = FALSE;
    Bool doit = TRUE;
    int temp;

#ifdef TWDEBUG
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
    	"CRT1off is %d\n", pSiS->CRT1off);
#endif

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    if((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_ENABLE)) {

	if(pSiS->VBFlags != pSiS->VBFlags_backup) {
		pSiS->VBFlags = pSiS->VBFlags_backup;
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"VBFlags restored to %0lx\n", pSiS->VBFlags);
	}

	/* TW: -) We can't switch off CRT1 if bridge is in SlaveMode.
	 *     -) If we change to a SlaveMode-Mode (like 512x384), we
	 *        need to adapt VBFlags for eg. Xv.
	 */
#ifdef SISDUALHEAD
	if(!pSiS->DualHeadMode) {
#endif
	   if(SiSBridgeIsInSlaveMode(pScrn))  {
		doit = FALSE;
		temp = pSiS->VBFlags;
		pSiS->VBFlags &= (~VB_DISPMODE_SINGLE);
		pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_DISP1);
                if(temp != pSiS->VBFlags) {
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"VBFlags changed to 0x%0lx\n", pSiS->VBFlags);
		}
	   }
#ifdef SISDUALHEAD
	}
#endif
	if(doit) {
           inSISIDXREG(SISCR, 0x17, usScratchCR17);
    	   if(pSiS->CRT1off) {
	        if(usScratchCR17 & 0x80) flag = TRUE;
		usScratchCR17 &= ~0x80;
    	   } else {
	        if(!(usScratchCR17 & 0x80)) flag = TRUE;
        	usScratchCR17 |= 0x80;
           }
	   outSISIDXREG(SISCR, 0x17, usScratchCR17);
	   /* TW: Reset only if status changed */
	   if(flag) {
	      outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
	      usleep(10000);
              outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */
	   }
	}
    }

    /* TW: Apply TV settings given by options
           Do this even in DualHeadMode:
	   - if this is called by SetModeCRT1, CRT2 mode has been reset by SetModeCRT1
	   - if this is called by SetModeCRT2, CRT2 mode has changed (duh!)
	   -> In both cases, the settings must be re-applied.
     */
    if(pSiS->VBFlags & CRT2_TV) {
       int val;
       if(pSiS->VBFlags & VB_CHRONTEL) {
          int mychtvlumabandwidthcvbs = pSiS->chtvlumabandwidthcvbs;
	  int mychtvlumabandwidthsvideo = pSiS->chtvlumabandwidthsvideo;
	  int mychtvlumaflickerfilter = pSiS->chtvlumaflickerfilter;
	  int mychtvchromabandwidth = pSiS->chtvchromabandwidth;
	  int mychtvchromaflickerfilter = pSiS->chtvchromaflickerfilter;
	  int mychtvcvbscolor = pSiS->chtvcvbscolor;
	  int mychtvtextenhance = pSiS->chtvtextenhance;
	  int mychtvcontrast = pSiS->chtvcontrast;
	  int mytvxpos = pSiS->tvxpos;
	  int mytvypos = pSiS->tvypos;
#ifdef SISDUALHEAD	  
	  if(pSiSEnt && pSiS->DualHeadMode) {
	     mychtvlumabandwidthcvbs = pSiSEnt->chtvlumabandwidthcvbs;
	     mychtvlumabandwidthsvideo = pSiSEnt->chtvlumabandwidthsvideo;
	     mychtvlumaflickerfilter = pSiSEnt->chtvlumaflickerfilter;
	     mychtvchromabandwidth = pSiSEnt->chtvchromabandwidth;
	     mychtvchromaflickerfilter = pSiSEnt->chtvchromaflickerfilter;
	     mychtvcvbscolor = pSiSEnt->chtvcvbscolor;
	     mychtvtextenhance = pSiSEnt->chtvtextenhance;
	     mychtvcontrast = pSiSEnt->chtvcontrast;
	     mytvxpos = pSiSEnt->tvxpos;
	     mytvypos = pSiSEnt->tvypos;
	  }
#endif	  
	  if((val = mychtvlumabandwidthcvbs) != -1) {
	     SiS_SetCHTVlumabandwidthcvbs(pScrn, val);
	  }
	  if((val = mychtvlumabandwidthsvideo) != -1) {
	     SiS_SetCHTVlumabandwidthsvideo(pScrn, val);
	  }
	  if((val = mychtvlumaflickerfilter) != -1) {
	     SiS_SetCHTVlumaflickerfilter(pScrn, val);
	  }
	  if((val = mychtvchromabandwidth) != -1) {
	     SiS_SetCHTVchromabandwidth(pScrn, val);      
	  }
	  if((val = mychtvchromaflickerfilter) != -1) {
	     SiS_SetCHTVchromaflickerfilter(pScrn, val);
	  }
	  if((val = mychtvcvbscolor) != -1) {
	     SiS_SetCHTVcvbscolor(pScrn, val);
	  }
	  if((val = mychtvtextenhance) != -1) {
	     SiS_SetCHTVtextenhance(pScrn, val);
	  }
	  if((val = mychtvcontrast) != -1) {
	     SiS_SetCHTVcontrast(pScrn, val);
	  }
	  /* Backup default TV position registers */
	  switch(pSiS->ChrontelType) {
	  case CHRONTEL_700x:
	     pSiS->tvx = SiS_GetCH700x(pSiS->SiS_Pr, 0x0a);
	     pSiS->tvx |= (((SiS_GetCH700x(pSiS->SiS_Pr, 0x08) & 0x02) >> 1) << 8);
	     pSiS->tvy = SiS_GetCH700x(pSiS->SiS_Pr, 0x0b);
	     pSiS->tvy |= ((SiS_GetCH700x(pSiS->SiS_Pr, 0x08) & 0x01) << 8);
#ifdef SISDUALHEAD
	     if(pSiSEnt && pSiS->DualHeadMode) {
	        pSiSEnt->tvx = pSiS->tvx;
		pSiSEnt->tvy = pSiS->tvy;
	     }
#endif	
	     break;
	  case CHRONTEL_701x:
	     /* TO DO */
	     break;
	  }
	  if((val = mytvxpos) != 0) {
	     SiS_SetTVxposoffset(pScrn, val);
	  }
	  if((val = mytvypos) != 0) {
	     SiS_SetTVyposoffset(pScrn, val);
	  }
       }
       if(pSiS->VBFlags & VB_301) {
          int mysistvedgeenhance = pSiS->sistvedgeenhance;
#ifdef SISDUALHEAD
          if(pSiSEnt && pSiS->DualHeadMode) {
	     mysistvedgeenhance = pSiSEnt->sistvedgeenhance;
	  }
#endif	  
          if((val = mysistvedgeenhance) != -1) {
	     SiS_SetSISTVedgeenhance(pScrn, val);
	  }
       }
       if(pSiS->VBFlags & VB_SISBRIDGE) {
          int mysistvantiflicker = pSiS->sistvantiflicker;
	  int mysistvsaturation = pSiS->sistvsaturation;
	  int mytvxpos = pSiS->tvxpos;
	  int mytvypos = pSiS->tvypos;
#ifdef SISDUALHEAD
          if(pSiSEnt && pSiS->DualHeadMode) {
	     mysistvantiflicker = pSiSEnt->sistvantiflicker;
	     mysistvsaturation = pSiSEnt->sistvsaturation;
	     mytvxpos = pSiSEnt->tvxpos;
	     mytvypos = pSiSEnt->tvypos;
	  }
#endif	  
          /* Backup default TV position registers */
	  inSISIDXREG(SISPART2,0x2d,pSiS->p2_2d);
	  inSISIDXREG(SISPART2,0x01,pSiS->p2_01);
	  inSISIDXREG(SISPART2,0x02,pSiS->p2_02);
#ifdef SISDUALHEAD
	  if(pSiSEnt && pSiS->DualHeadMode) {
	        pSiSEnt->p2_2d = pSiS->p2_2d;
		pSiSEnt->p2_01 = pSiS->p2_01;
		pSiSEnt->p2_02 = pSiS->p2_02;
	  }
#endif	
          if((val = mysistvantiflicker) != -1) {
	     SiS_SetSISTVantiflicker(pScrn, val);
	  }
	  if((val = mysistvsaturation) != -1) {
	     SiS_SetSISTVsaturation(pScrn, val);
	  }
	  if((val = mytvxpos) != 0) {
	     SiS_SetTVxposoffset(pScrn, val);
	  }
	  if((val = mytvypos) != 0) {
	     SiS_SetTVyposoffset(pScrn, val); 
	 }
       }
    }

}

/* Post-set SiS6326 TV registers */
void SiS6326PostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char tmp;
    int val;

    if(!(pSiS->SiS6326Flags & SIS6326_TVDETECTED)) return;
    
#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

    /* Backup default TV position registers */
    pSiS->tvx1 = SiS6326GetTVReg(pScrn,0x3a);
    pSiS->tvx1 |= ((SiS6326GetTVReg(pScrn,0x3c) & 0x0f) << 8);
    pSiS->tvx2 = SiS6326GetTVReg(pScrn,0x26);
    pSiS->tvx2 |= ((SiS6326GetTVReg(pScrn,0x27) & 0xf0) << 4);
    pSiS->tvx3 = SiS6326GetTVReg(pScrn,0x12);
    pSiS->tvx3 |= ((SiS6326GetTVReg(pScrn,0x13) & 0xC0) << 2);
    pSiS->tvy1 = SiS6326GetTVReg(pScrn,0x11);
    pSiS->tvy1 |= ((SiS6326GetTVReg(pScrn,0x13) & 0x30) << 4);
    
    /* TW: Handle TVPosOffset options (BEFORE switching on TV) */
    if((val = pSiS->tvxpos) != 0) {
       SiS_SetTVxposoffset(pScrn, val);
    }
    if((val = pSiS->tvypos) != 0) {
       SiS_SetTVyposoffset(pScrn, val);
    }

    /* TW: Switch on TV output. This is rather complicated, but
     *     if we don't do it, TV output will flicker terribly.
     */
    if(pSiS->SiS6326Flags & SIS6326_TVON) {
       orSISIDXREG(SISSR, 0x01, 0x20);
       tmp = SiS6326GetTVReg(pScrn,0x00);
       tmp &= ~0x04;
       while(!(inSISREG(SISINPSTAT) & 0x08));    /* Wait while NOT vb */
       SiS6326SetTVReg(pScrn,0x00,tmp);
       for(val=0; val < 2; val++) {
         while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
         while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
       }
       SiS6326SetTVReg(pScrn, 0x00, sisReg->sis6326tv[0]);
       tmp = inSISREG(SISINPSTAT);
       outSISREG(SISAR, 0x20);
       tmp = inSISREG(SISINPSTAT);
       while(inSISREG(SISINPSTAT) & 0x01);
       while(!(inSISREG(SISINPSTAT) & 0x01));
       andSISIDXREG(SISSR, 0x01, ~0x20);
       for(val=0; val < 10; val++) {
         while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
         while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
       }
       andSISIDXREG(SISSR, 0x01, ~0x20);
    }

    tmp = SiS6326GetTVReg(pScrn,0x00);
    if(!(tmp & 0x04)) return;

    /* TW: Apply TV settings given by options */
    if((val = pSiS->sis6326antiflicker) != -1) {
       SiS_SetSIS6326TVantiflicker(pScrn, val);
    }
    if((val = pSiS->sis6326enableyfilter) != -1) {
       SiS_SetSIS6326TVenableyfilter(pScrn, val);
    }
    if((val = pSiS->sis6326yfilterstrong) != -1) {
       SiS_SetSIS6326TVyfilterstrong(pScrn, val);
    }

}

/* Check if video bridge is in slave mode */
BOOLEAN
SiSBridgeIsInSlaveMode(ScrnInfoPtr pScrn)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned char usScratchP1_00;

    if(!(pSiS->VBFlags & VB_VIDEOBRIDGE)) return FALSE;

    inSISIDXREG(SISPART1,0x00,usScratchP1_00);
    if( ((pSiS->VGAEngine == SIS_300_VGA) && (usScratchP1_00 & 0xa0) == 0x20) ||
        ((pSiS->VGAEngine == SIS_315_VGA) && (usScratchP1_00 & 0x50) == 0x10) ) {
	   return TRUE;
    } else {
           return FALSE;
    }
}

/* TW: Build a list of the VESA modes the BIOS reports as valid */
static void
SiSBuildVesaModeList(ScrnInfoPtr pScrn, vbeInfoPtr pVbe, VbeInfoBlock *vbe)
{
    SISPtr pSiS = SISPTR(pScrn);
d2347 1
a2347 2

    while(vbe->VideoModePtr[i] != 0xffff) {
d2357 3
d2366 1
a2366 1
	m->next = pSiS->SISVESAModeList;
d2372 1
a2372 1
	pSiS->SISVESAModeList = m;
d2378 1
a2378 3
/* TW: Calc VESA mode from given resolution/depth */
static UShort
SiSCalcVESAModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode)
d2380 2
a2381 3
    SISPtr pSiS = SISPTR(pScrn);
    sisModeInfoPtr m = pSiS->SISVESAModeList;
    UShort i = (pScrn->bitsPerPixel+7)/8 - 1;
d2384 4
a2387 4
    while(m) {
	if(pScrn->bitsPerPixel == m->bpp &&
	   mode->HDisplay == m->width &&
	   mode->VDisplay == m->height)
d2396 4
a2399 4
    switch(mode->HDisplay) {
      case 512:
          if(mode->VDisplay == 384)
             ModeIndex = VESAModeIndex_512x384[i];
d2401 1
a2401 1
      case 640:
d2403 3
a2405 1
             ModeIndex = VESAModeIndex_640x480[i];
d2407 2
a2408 3
      case 800:
          if(mode->VDisplay == 600)
             ModeIndex = VESAModeIndex_800x600[i];
d2410 2
a2411 3
      case 1024:
          if(mode->VDisplay == 768)
             ModeIndex = VESAModeIndex_1024x768[i];
d2413 2
a2414 3
      case 1280:
          if(mode->VDisplay == 1024)
             ModeIndex = VESAModeIndex_1280x1024[i];
d2416 2
a2417 3
      case 1600:
          if(mode->VDisplay == 1200)
             ModeIndex = VESAModeIndex_1600x1200[i];
d2419 2
a2420 3
      case 1920:
          if(mode->VDisplay == 1440)
             ModeIndex = VESAModeIndex_1920x1440[i];
d2424 2
a2425 2
   if(!ModeIndex) xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
        "No valid mode found for %dx%dx%d in built-in table either.\n",
d2431 6
a2436 3
/* TW: Calculate the vertical refresh rate from a mode */
int
SiSCalcVRate(DisplayModePtr mode)
d2439 4
d2444 1
a2444 1
   if(mode->HSync > 0.0)
d2446 1
a2446 1
   else if(mode->HTotal > 0)
d2450 1
a2450 2

   if(mode->VTotal > 0)
d2452 1
a2452 2

   if(mode->Flags & V_INTERLACE)
d2454 2
a2455 2

   if(mode->Flags & V_DBLSCAN)
d2457 2
a2458 2

   if(mode->VScan > 1)
d2460 2
a2461 2

   if(mode->VRefresh > 0.0)
d2463 18
a2480 75

   if(hsync == 0 || refresh == 0) return(0);

   return((int)(refresh));
}

/* TW: Calculate CR33 (rate index) for CRT1.
 *     Calculation is done using currentmode, therefore it is
 *     recommended to set VertRefresh and HorizSync to correct
 *     values in config file.
 */
unsigned char
SISSearchCRT1Rate(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
   SISPtr         pSiS = SISPTR(pScrn);
   int            i = 0;
   int            irefresh;
   unsigned short xres = mode->HDisplay;
   unsigned short yres = mode->VDisplay;
   unsigned char  index;
   BOOLEAN	  checksis730 = FALSE;

   irefresh = SiSCalcVRate(mode);
   if(!irefresh) {
        if(xres == 800 || xres == 1024 || xres == 1280) return 0x02;
   	else return 0x01;
   }
   
   /* SiS730 has troubles on CRT2 if CRT1 is at 32bpp */
   if( (pSiS->sishw_ext.jChipType == SIS_730) && 
       (pSiS->VBFlags & VB_VIDEOBRIDGE) &&
       (pSiS->CurrentLayout.bitsPerPixel == 32) ) {
#ifdef SISDUALHEAD   
      if(pSiS->DualHeadMode) {
         if(pSiS->SecondHead) {
	    checksis730 = TRUE;
	 }
      } else
#endif      
      if((!pSiS->UseVESA) && (pSiS->VBFlags & CRT2_ENABLE) && (!pSiS->CRT1off)) {
         checksis730 = TRUE;
      }
   }   
   
#ifdef TWDEBUG
   xf86DrvMsg(0, X_INFO, "Debug: CalcVRate returned %d\n", irefresh);   
#endif   

   /* We need the REAL refresh rate here */
   if(mode->Flags & V_INTERLACE)
       	irefresh /= 2;

   /* Do not multiply by 2 when DBLSCAN! */
   
#ifdef TWDEBUG
   xf86DrvMsg(0, X_INFO, "Debug: Rate after correction = %d\n", irefresh);   
#endif

   index = 0;
   while((sisx_vrate[i].idx != 0) && (sisx_vrate[i].xres <= xres)) {
	if((sisx_vrate[i].xres == xres) && (sisx_vrate[i].yres == yres)) {
	    if((checksis730 == FALSE) || (sisx_vrate[i].SiS730valid32bpp == TRUE)) {
	       if(sisx_vrate[i].refresh == irefresh) {
		   index = sisx_vrate[i].idx;
		   break;
	       } else if(sisx_vrate[i].refresh > irefresh) {
		   if((sisx_vrate[i].refresh - irefresh) <= 3) {
		      index = sisx_vrate[i].idx;
		   } else if( ((checksis730 == FALSE) || (sisx_vrate[i - 1].SiS730valid32bpp == TRUE)) && 
		              ((irefresh - sisx_vrate[i - 1].refresh) <=  2) &&
			      (sisx_vrate[i].idx != 1) ) {
		      index = sisx_vrate[i - 1].idx;
		   }
		   break;
	       }
d2484 2
a2485 2
   }
   if(index > 0)
d2487 2
a2488 39
   else {
        /* TW: Default Rate index */
        if(xres == 800 || xres == 1024 || xres == 1280) return 0x02; 
   	else return 0x01;
   }
}

void
SISWaitRetraceCRT1(ScrnInfoPtr pScrn)
{
   SISPtr        pSiS = SISPTR(pScrn);
   int           watchdog;
   unsigned char temp;

   inSISIDXREG(SISCR,0x17,temp);
   if(!(temp & 0x80)) return;

   watchdog = 65536;
   while((!(inSISREG(SISINPSTAT) & 0x08)) && --watchdog);
   watchdog = 65536;
   while((inSISREG(SISINPSTAT) & 0x08) && --watchdog);
}

void
SISWaitRetraceCRT2(ScrnInfoPtr pScrn)
{
   SISPtr        pSiS = SISPTR(pScrn);
   int           watchdog;
   unsigned char temp, reg;

   switch(pSiS->VGAEngine) {
   case SIS_300_VGA:
   	reg = 0x28;
	break;
   case SIS_315_VGA:
   	reg = 0x33;
	break;
   default:
        return;
a2489 106

   watchdog = 65536;
   do {
   	inSISIDXREG(SISPART1, reg, temp);
	if(temp & 0x80) break;
   } while(--watchdog);
   watchdog = 65536;
   do {
   	inSISIDXREG(SISPART1, reg, temp);
	if(!(temp & 0x80)) break;
   } while(--watchdog);
}

static void
SISWaitVBRetrace(ScrnInfoPtr pScrn)
{
   SISPtr  pSiS = SISPTR(pScrn);

#ifdef SISDUALHEAD
   if(pSiS->DualHeadMode) {
   	if(pSiS->SecondHead)
		SISWaitRetraceCRT1(pScrn);
        else
		SISWaitRetraceCRT2(pScrn);
   } else {
#endif
	if(pSiS->VBFlags & DISPTYPE_DISP1) {
		SISWaitRetraceCRT1(pScrn);
	}
	if(pSiS->VBFlags & DISPTYPE_DISP2) {
		if(!(SiSBridgeIsInSlaveMode(pScrn))) {
		  	SISWaitRetraceCRT2(pScrn);
		}
	}
#ifdef SISDUALHEAD
   }
#endif
}

void
sisSaveUnlockExtRegisterLock(SISPtr pSiS, unsigned char *reg1, unsigned char *reg2)
{
    register unsigned char val;
    unsigned long mylockcalls;

    pSiS->lockcalls++;
    mylockcalls = pSiS->lockcalls;

    /* check if already unlocked */
    inSISIDXREG(SISSR, 0x05, val);
    if(val != 0xa1) {
       /* save State */
       if(reg1) *reg1 = val;
       /* unlock */
       outSISIDXREG(SISSR, 0x05, 0x86);
       inSISIDXREG(SISSR, 0x05, val);
       if(val != 0xA1) {
#ifdef TWDEBUG
	  unsigned char val1, val2;
	  int i;
#endif
          xf86DrvMsg(pSiS->pScrn->scrnIndex, X_ERROR,
               "Failed to unlock sr registers (%p, %x, 0x%02x; %d)\n",
	       pSiS, pSiS->RelIO, val, mylockcalls);
#ifdef TWDEBUG
          for(i = 0; i <= 0x3f; i++) {
	  	inSISIDXREG(SISSR, i, val1);
		inSISIDXREG(0x3c4, i, val2);
		xf86DrvMsg(pSiS->pScrn->scrnIndex, X_INFO,
			"SR%02d: RelIO=0x%02x 0x3c4=0x%02x (%d)\n", i, val1, val2, mylockcalls);
	  }
#endif
          if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
	     /* Emergency measure: unlock at 0x3c4, and try to enable Relocated IO ports */
	     outSISIDXREG(0x3c4,0x05,0x86);
	     andSISIDXREG(0x3c4,0x33,~0x20);
	     outSISIDXREG(SISSR, 0x05, 0x86);
          }
       }
    }
    if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
       inSISIDXREG(SISCR, 0x80, val);
       if(val != 0xa1) {
          /* save State */
          if(reg2) *reg2 = val;
          outSISIDXREG(SISCR, 0x80, 0x86);
	  inSISIDXREG(SISCR, 0x80, val);
	  if(val != 0xA1) {
	     xf86DrvMsg(pSiS->pScrn->scrnIndex, X_ERROR,
	        "Failed to unlock cr registers (%p, %x, 0x%02x)\n",
	       pSiS, pSiS->RelIO, val);
	  }
       }
    }
}

void
sisRestoreExtRegisterLock(SISPtr pSiS, unsigned char reg1, unsigned char reg2)
{
    /* restore lock */
#ifndef UNLOCK_ALWAYS
    outSISIDXREG(SISSR, 0x05, reg1 == 0xA1 ? 0x86 : 0x00);
    if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
       outSISIDXREG(SISCR, 0x80, reg2 == 0xA1 ? 0x86 : 0x00);
    }
#endif
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_driver.c,v 1.176 2004/01/24 21:29:20 twini Exp $ */
d3 2
a4 1
 * SiS driver main code
d6 9
a14 1
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria.
d16 7
a22 13
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement: "This product includes
 *    software developed by Thomas Winischhofer, Vienna, Austria."
 * 4) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d24 1
a24 23
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author: Thomas Winischhofer <thomas@@winischhofer.net>
 *	- driver entirely rewritten since 2001, only basic structure taken from
 *	  old code (except sis_dri.c, sis_shadow.c, sis_accel.c and parts of
 *	  sis_dga.c; these were mostly taken over; sis_dri.c was changed for
 *	  new versions of the DRI layer)
 *
 * This notice covers the entire driver code unless otherwise indicated.
 *
 * Formerly based on code which is
 * 	     Copyright (C) 1998, 1999 by Alan Hourihane, Wigan, England.
 * Written by:
 *           Alan Hourihane <alanh@@fairlite.demon.co.uk>,
d27 1
a27 1
 *           Mitani Hiroshi <hmitani@@drl.mei.co.jp>,
d29 17
d49 2
a53 1
#include "xf86Priv.h"
d71 1
a71 1
 
a82 1

d86 1
a86 1
#if (XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,99,0,0)) || (defined(XvExtension))
d95 51
a145 1
/* Globals (yes, these ARE really required to be global) */
d147 9
d157 4
a160 1
static int      	SISEntityIndex = -1;
d163 8
a170 17
#ifdef SISMERGED
#ifdef SISXINERAMA
static Bool 		SiSnoPanoramiXExtension = TRUE;
int 			SiSXineramaPixWidth = 0;
int 			SiSXineramaPixHeight = 0;
int 			SiSXineramaNumScreens = 0;
SiSXineramaData		*SiSXineramadataPtr = NULL;
static int 		SiSXineramaGeneration;

int SiSProcXineramaQueryVersion(ClientPtr client);
int SiSProcXineramaGetState(ClientPtr client);
int SiSProcXineramaGetScreenCount(ClientPtr client);
int SiSProcXineramaGetScreenSize(ClientPtr client);
int SiSProcXineramaIsActive(ClientPtr client);
int SiSProcXineramaQueryScreens(ClientPtr client);
int SiSSProcXineramaDispatch(ClientPtr client);
#endif
d209 1
d211 1
a211 1
    { PCI_CHIP_SIS660,      "SIS660/661FX/M661FX/M661MX/741/M741/760" },
d227 1
d229 1
a229 1
    { PCI_CHIP_SIS660,      PCI_CHIP_SIS660,    RES_SHARED_VGA },
a236 1
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,0,0)
a237 2
#endif
    "XAAFillMono8x8PatternRects",
a250 1
    "vgaHWUnmapMem",
d259 6
d287 10
a353 3
#ifdef SISNEWDRI2
    "DRICreatePCIBusID"
#endif        
d383 6
a388 6
    if(!setupDone) {
       setupDone = TRUE;
       xf86AddDriver(&SIS, module, 0);
       LoaderRefSymLists(vgahwSymbols, fbSymbols, xaaSymbols,
			 shadowSymbols, ramdacSymbols,
			 vbeSymbols, int10Symbols,
d390 1
a390 1
			 drmSymbols, driSymbols,
d392 3
a394 3
			 NULL);
       return (pointer)TRUE;
    }
d396 1
a396 1
    if(errmaj) *errmaj = LDR_ONCEONLY;
d410 2
a411 1
    if(pScrn->driverPrivate != NULL) return TRUE;
d429 1
a429 1
    /* Just to make sure... */
a431 1
#ifdef SISDUALHEAD
a432 1
#endif
a437 1

d440 5
a444 5
       if(!pSiS->SecondHead) {
          /* Free memory only if we are first head; in case of an error
	   * during init of the second head, the server will continue -
	   * and we need the BIOS image and SiS_Private for the first
	   * head.
d450 1
a450 3
	  if(pSiSEnt->RenderAccelArray) xfree(pSiSEnt->RenderAccelArray);
	  pSiSEnt->RenderAccelArray = pSiS->RenderAccelArray = NULL;
       } else {
d453 1
a453 2
	  pSiS->RenderAccelArray = NULL;
       }
d456 4
a459 6
       if(pSiS->BIOS) xfree(pSiS->BIOS);
       pSiS->BIOS = NULL;
       if(pSiS->SiS_Pr) xfree(pSiS->SiS_Pr);
       pSiS->SiS_Pr = NULL;
       if(pSiS->RenderAccelArray) xfree(pSiS->RenderAccelArray);
       pSiS->RenderAccelArray = NULL;
d463 1
a463 43
#ifdef SISMERGED
    if(pSiS->CRT2HSync) xfree(pSiS->CRT2HSync);
    pSiS->CRT2HSync = NULL;
    if(pSiS->CRT2VRefresh) xfree(pSiS->CRT2VRefresh);
    pSiS->CRT2VRefresh = NULL;
    if(pSiS->MetaModes) xfree(pSiS->MetaModes);
    pSiS->MetaModes = NULL;
    if(pSiS->CRT2pScrn) {
       if(pSiS->CRT2pScrn->modes) {
          while(pSiS->CRT2pScrn->modes)
             xf86DeleteMode(&pSiS->CRT2pScrn->modes, pSiS->CRT2pScrn->modes);
       }
       if(pSiS->CRT2pScrn->monitor) {
          if(pSiS->CRT2pScrn->monitor->Modes) {
	     while(pSiS->CRT2pScrn->monitor->Modes)
	        xf86DeleteMode(&pSiS->CRT2pScrn->monitor->Modes, pSiS->CRT2pScrn->monitor->Modes);
	  }
	  if(pSiS->CRT2pScrn->monitor->DDC) xfree(pSiS->CRT2pScrn->monitor->DDC);
          xfree(pSiS->CRT2pScrn->monitor);
       }
       xfree(pSiS->CRT2pScrn);
       pSiS->CRT2pScrn = NULL;
    }
    if(pSiS->CRT1Modes) {
       if(pSiS->CRT1Modes != pScrn->modes) {
          if(pScrn->modes) {
             pScrn->currentMode = pScrn->modes;
             do {
                DisplayModePtr p = pScrn->currentMode->next;
                if(pScrn->currentMode->Private)
                   xfree(pScrn->currentMode->Private);
                xfree(pScrn->currentMode);
                pScrn->currentMode = p;
             } while(pScrn->currentMode != pScrn->modes);
          }
          pScrn->currentMode = pSiS->CRT1CurrentMode;
          pScrn->modes = pSiS->CRT1Modes;
          pSiS->CRT1CurrentMode = NULL;
          pSiS->CRT1Modes = NULL;
       }
    }
#endif
    if(pSiS->pVbe) vbeFree(pSiS->pVbe);
d465 1
a465 1
    if(pScrn->driverPrivate == NULL)
d475 2
a476 4
    BOOLEAN docrt1 = TRUE, docrt2 = TRUE;
    unsigned char sr1=0, cr17=0, cr63=0, sr11=0, pmreg=0, sr7=0;
    unsigned char p1_13=0, p2_0=0, oldpmreg=0;
    BOOLEAN backlight = TRUE;
d481 1
a481 7
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       if(pSiS->SecondHead) docrt2 = FALSE;
       else                 docrt1 = FALSE;
    }
#endif

d486 20
a505 20
    if(docrt2) {
       if(pSiS->VBFlags & CRT2_LCD) {
          if(((pSiS->VGAEngine == SIS_300_VGA) &&
             (pSiS->VBFlags & (VB_301|VB_30xBDH|VB_LVDS))) ||
            ((pSiS->VGAEngine == SIS_315_VGA) &&
             ((pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) == VB_LVDS))) {
#ifdef SISDUALHEAD
             if(pSiS->DualHeadMode) {
	        if(!pSiS->BlankCRT2) {
		   inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		   if(pSiS->sishw_ext.jChipType >= SIS_661) pSiS->LCDon &= 0x0f;
		}
	     } else
#endif
	     if(!pSiS->Blank) {
	        inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		if(pSiS->sishw_ext.jChipType >= SIS_661) pSiS->LCDon &= 0x0f;
	     }
          }
       }
d511 21
a531 13
            if(docrt1)  pSiS->Blank = FALSE;
#ifdef SISDUALHEAD
	    else	pSiS->BlankCRT2 = FALSE;
#endif
            sr1   = 0x00;
            cr17  = 0x80;
	    pmreg = 0x00;
	    cr63  = 0x00;
	    sr7   = 0x10;
	    sr11  = (pSiS->LCDon & 0x0C);
	    p2_0  = 0x20;
	    p1_13 = 0x00;
	    backlight = TRUE;
d534 1
a535 14
            if(docrt1)  pSiS->Blank = TRUE;
#ifdef SISDUALHEAD
	    else        pSiS->BlankCRT2 = TRUE;
#endif
            sr1   = 0x20;
	    cr17  = 0x80;
	    pmreg = 0x80;
	    cr63  = 0x40;
	    sr7   = 0x00;
	    sr11  = 0x08;
	    p2_0  = 0x40;
	    p1_13 = 0x80;
	    backlight = FALSE;
            break;
d537 19
a555 14
       case DPMSModeStandby: /* HSync: Off, VSync: On */
            if(docrt1)  pSiS->Blank = TRUE;
#ifdef SISDUALHEAD
	    else        pSiS->BlankCRT2 = TRUE;
#endif
            sr1   = 0x20;
	    cr17  = 0x80;
	    pmreg = 0x40;
	    cr63  = 0x40;
	    sr7   = 0x00;
	    sr11  = 0x08;
	    p2_0  = 0x80;
	    p1_13 = 0x40;
	    backlight = FALSE;
d559 29
a587 13
            if(docrt1)  pSiS->Blank = TRUE;
#ifdef SISDUALHEAD
	    else        pSiS->BlankCRT2 = TRUE;
#endif
            sr1   = 0x20;
	    cr17  = 0x00;
	    pmreg = 0xc0;
	    cr63  = 0x40;
	    sr7   = 0x00;
	    sr11  = 0x08;
	    p2_0  = 0xc0;
	    p1_13 = 0xc0;
	    backlight = FALSE;
a589 2
       default:
	    return;
d592 11
a602 12
    if(docrt2) {
       if(pSiS->VGAEngine == SIS_315_VGA) {
          if(pSiS->VBFlags & CRT2_LCD) {
	     if(pSiS->VBFlags & VB_CHRONTEL) {
	        if(backlight) {
	           SiS_Chrontel701xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	        } else {
	           SiS_Chrontel701xBLOff(pSiS->SiS_Pr);
                }
	     }
          }
       }
d605 103
a707 9
    if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
       if((docrt2 && (pSiS->VBFlags & CRT2_LCD)) || (docrt1 && (pSiS->VBFlags & CRT1_LCDA))) {
          if(backlight) {
	     SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	  } else {
             SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
	  }
       }
    }
d709 17
a725 13
    if(docrt1) {
       setSISIDXREG(SISSR, 0x01, ~0x20, sr1);    /* Set/Clear "Display On" bit */
       switch(pSiS->VGAEngine) {
       case SIS_OLD_VGA:
       case SIS_530_VGA:
            inSISIDXREG(SISSR, 0x11, oldpmreg);
            setSISIDXREG(SISCR, 0x17, 0x7f, cr17);
	    setSISIDXREG(SISSR, 0x11, 0x3f, pmreg);
	    break;
       case SIS_315_VGA:
            if((!pSiS->CRT1off) && ((!(pSiS->VBFlags & CRT1_LCDA)) || (pSiS->VBFlags & VB_301C))) {
               setSISIDXREG(SISCR, pSiS->myCR63, 0xbf, cr63);
	       setSISIDXREG(SISSR, 0x07, 0xef, sr7);
d727 21
a747 14
	    /* fall through */
       default:
            if((!(pSiS->VBFlags & CRT1_LCDA)) || (pSiS->VBFlags & VB_301C)) {
               inSISIDXREG(SISSR, 0x1f, oldpmreg);
               if(!pSiS->CRT1off) {
	          setSISIDXREG(SISSR, 0x1f, 0x3f, pmreg);
	       }
	    }
	    /* TODO: Check if Chrontel TV is active and in slave mode,
	     * don't go into power-saving mode this in this case!
	     */
       }
       oldpmreg &= 0xc0;
    }
d749 6
a754 29
    if(docrt2) {
       if(pSiS->VBFlags & CRT2_LCD) {
          if(((pSiS->VGAEngine == SIS_300_VGA) &&
              (pSiS->VBFlags & (VB_301|VB_30xBDH|VB_LVDS))) ||
             ((pSiS->VGAEngine == SIS_315_VGA) &&
              ((pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) == VB_LVDS))) {
	     if(pSiS->sishw_ext.jChipType >= SIS_661) {
	        setSISIDXREG(SISSR, 0x11, ~0xfc, sr11);
	     } else {
                setSISIDXREG(SISSR, 0x11, ~0x0c, sr11);
	     }
          }
          if(pSiS->VGAEngine == SIS_300_VGA) {
             if((pSiS->VBFlags & (VB_301B|VB_301C|VB_302B)) &&
                (!(pSiS->VBFlags & VB_30xBDH))) {
	        setSISIDXREG(SISPART1, 0x13, 0x3f, p1_13);
	     }
          } else if(pSiS->VGAEngine == SIS_315_VGA) {
             if((pSiS->VBFlags & (VB_301B|VB_301C|VB_302B)) &&
                (!(pSiS->VBFlags & VB_30xBDH))) {
	        setSISIDXREG(SISPART2, 0x00, 0x1f, p2_0);
	     }
          }
       } else if(pSiS->VBFlags & CRT2_VGA) {
          if(pSiS->VBFlags & (VB_301B|VB_301C|VB_302B)) {
	     setSISIDXREG(SISPART2, 0x00, 0x1f, p2_0);
          }
       }
    }
a755 4
    if((docrt1) && (pmreg != oldpmreg) && ((!(pSiS->VBFlags & CRT1_LCDA)) || (pSiS->VBFlags & VB_301C))) {
       outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
       usleep(10000);
       outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */
a756 1

d758 1
a766 2
#if 0
/* This won't work as long as noone added the symbols to the symlist */
d768 1
a768 1
SISCalculateGammaRamp(ScrnInfoPtr pScrn)
a770 35
   int i, j, nramp;
   unsigned short *ramp[3];
   float gamma_max[3], gamma_prescale[3], framp;

   gamma_max[0] = (float)pSiS->GammaBriR / 1000;
   gamma_max[1] = (float)pSiS->GammaBriG / 1000;
   gamma_max[2] = (float)pSiS->GammaBriB / 1000;
   gamma_prescale[0] = (float)pSiS->GammaPBriR / 1000;
   gamma_prescale[1] = (float)pSiS->GammaPBriG / 1000;
   gamma_prescale[2] = (float)pSiS->GammaPBriB / 1000;

   if(!(nramp = xf86GetGammaRampSize(pScrn->pScreen))) return;

   for(i=0; i<3; i++) {
      ramp[i] = (unsigned short *)xalloc(nramp * sizeof(unsigned short));
      if(!ramp[i]) {
         if(ramp[0]) { xfree(ramp[0]); ramp[0] = NULL; }
	 if(ramp[1]) { xfree(ramp[1]); ramp[1] = NULL; }
         return;
      }
   }

   for(i = 0; i < 3; i++) {
      int fullscale = 65535 * gamma_max[i];
      float dramp = 1. / (nramp - 1);
      float invgamma=0.0, v;

      switch(i) {
      case 0: invgamma = 1. / pScrn->gamma.red; break;
      case 1: invgamma = 1. / pScrn->gamma.green; break;
      case 2: invgamma = 1. / pScrn->gamma.blue; break;
      }

      for(j = 0; j < nramp; j++) {
         framp = pow(gamma_prescale[i] * j * dramp, invgamma);
d772 4
a775 22
         v = (fullscale < 0) ? (65535 + fullscale * framp) :
	 		       fullscale * framp;
	 if(v < 0) v = 0;
	 else if(v > 65535) v = 65535;
	 ramp[i][j] = (unsigned short)v;
      }
   }

   xf86ChangeGammaRamp(pScrn->pScreen, nramp, ramp[0], ramp[1], ramp[2]);

   xfree(ramp[0]);
   xfree(ramp[1]);
   xfree(ramp[2]);
   ramp[0] = ramp[1] = ramp[2] = NULL;
}
#endif

static void
SISErrorLog(ScrnInfoPtr pScrn, const char *format, ...)
{
    va_list ap;
    static const char *str = "**************************************************\n";
d777 4
a780 9
    va_start(ap, format);
    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, str);
    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
    	"                      ERROR:\n");
    xf86VDrvMsgVerb(pScrn->scrnIndex, X_ERROR, 1, format, ap);
    va_end(ap);
    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
    	"                  END OF MESSAGE\n");
    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, str);
d814 7
a820 6
    if((numDevSections = xf86MatchDevice(SIS_DRIVER_NAME, &devSections)) <= 0) {
       /*
        * There's no matching device section in the config file, so quit
        * now.
        */
       return FALSE;
d833 6
a838 6
    if(xf86GetPciVideoInfo() == NULL) {
       /*
        * We won't let anything in the config file override finding no
        * PCI video cards at all.  This seems reasonable now, but we'll see.
        */
       return FALSE;
d842 2
a843 2
               		SISChipsets, SISPciChipsets, devSections,
               		numDevSections, drv, &usedChips);
d847 2
a848 1
    if(numUsed <= 0) return FALSE;
d850 1
a850 1
    if(flags & PROBE_DETECT) {
d852 1
a852 1
    } else for(i = 0; i < numUsed; i++) {
d861 1
a861 1
        if((pScrn = xf86ConfigPciEntity(pScrn, 0, usedChips[i],
d882 6
a887 5
	if(pEnt->chipset == PCI_CHIP_SIS630 || pEnt->chipset == PCI_CHIP_SIS540 ||
	   pEnt->chipset == PCI_CHIP_SIS650 || pEnt->chipset == PCI_CHIP_SIS550 ||
	   pEnt->chipset == PCI_CHIP_SIS315 || pEnt->chipset == PCI_CHIP_SIS315H ||
	   pEnt->chipset == PCI_CHIP_SIS315PRO || pEnt->chipset == PCI_CHIP_SIS330 ||
	   pEnt->chipset == PCI_CHIP_SIS300 || pEnt->chipset == PCI_CHIP_SIS660) {
d893 2
a894 3
	    if(SISEntityIndex < 0) {
	       SISEntityIndex = xf86AllocateEntityPrivateIndex();
	    }
d896 10
a905 11
	    if(!pPriv->ptr) {
	       pPriv->ptr = xnfcalloc(sizeof(SISEntRec), 1);
	       pSiSEnt = pPriv->ptr;
	       pSiSEnt->lastInstance = -1;
	       pSiSEnt->DisableDual = FALSE;
	       pSiSEnt->ErrorAfterFirst = FALSE;
	       pSiSEnt->MapCountIOBase = pSiSEnt->MapCountFbBase = 0;
	       pSiSEnt->FbBase = pSiSEnt->IOBase = NULL;
  	       pSiSEnt->forceUnmapIOBase = FALSE;
	       pSiSEnt->forceUnmapFbBase = FALSE;
	       pSiSEnt->HWCursorCBufNum = pSiSEnt->HWCursorMBufNum = 0;
d907 3
a909 3
	       pSiSEnt->MapCountIOBaseDense = 0;
	       pSiSEnt->IOBaseDense = NULL;
	       pSiSEnt->forceUnmapIOBaseDense = FALSE;
d912 1
a912 1
	       pSiSEnt = pPriv->ptr;
d925 2
a926 3
/* If monitor section has no HSync/VRefresh data,
 * derive it from DDC data. Done by common layer
 * since 4.3.99.14.
a927 1
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,14,0)
d964 5
a968 5
       { 1280, 1024, 85, 91.1  },
       { 1600, 1200, 60, 75.0  },
       { 1600, 1200, 65, 81.3  },
       { 1600, 1200, 70, 87.5  },
       { 1600, 1200, 75, 93.8  },
d970 1
a970 1
       { 1920, 1440, 60, 90.0  },
d975 2
a976 2
      for(i = 0; i < 4; i++) {
    	 if(ddc->det_mon[i].type == DS_RANGES) {
d990 1
a990 1
	    if((i==0) || (myhlow > myhtiming[i].rate))
d996 1
a996 1
	    if((i==0) || (myhhigh < myhtiming[10-i].rate))
d1021 2
a1022 2
      for(i = 0; i < 4; i++) {
         if(ddc->det_mon[i].type == DS_RANGES) {
d1035 1
a1035 1
	    if((i==0) || (myvlow > myvtiming[i].rate))
d1041 1
a1041 1
	    if((i==0) || (myvhigh < myvtiming[9-i].rate))
a1064 1
#endif
d1066 7
a1072 1
/* Some helper functions for MergedFB mode */
d1074 2
a1075 1
#ifdef SISMERGED
d1077 35
a1111 48
/* Helper function for CRT2 monitor vrefresh/hsync options
 * (Code base from mga driver)
 */
static int
SiSStrToRanges(range *r, char *s, int max)
{
   float num = 0.0;
   int rangenum = 0;
   Bool gotdash = FALSE;
   Bool nextdash = FALSE;
   char* strnum = NULL;
   do {
      switch(*s) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '.':
         if(strnum == NULL) {
            strnum = s;
            gotdash = nextdash;
            nextdash = FALSE;
         }
         break;
      case '-':
      case ' ':
      case 0:
         if(strnum == NULL) break;
         sscanf(strnum, "%f", &num);
	 strnum = NULL;
         if(gotdash) {
            r[rangenum - 1].hi = num;
         } else {
            r[rangenum].lo = num;
            r[rangenum].hi = num;
            rangenum++;
         }
         if(*s == '-') nextdash = (rangenum != 0);
	 else if(rangenum >= max) return rangenum;
         break;
      default:
         return 0;
d1113 2
d1116 4
a1119 1
   } while(*(s++) != 0);
d1121 6
a1126 1
   return rangenum;
d1129 3
a1131 12
/* Copy and link two modes form mergedfb mode
 * (Code base taken from mga driver)
 * Copys mode i, links the result to dest, and returns it.
 * Links i and j in Private record.
 * If dest is NULL, return value is copy of i linked to itself.
 * For mergedfb auto-config, we only check the dimension
 * against virtualX/Y, if they were user-provided.
 */
static DisplayModePtr
SiSCopyModeNLink(ScrnInfoPtr pScrn, DisplayModePtr dest,
                 DisplayModePtr i, DisplayModePtr j,
		 SiSScrn2Rel srel)
d1133 5
a1137 1159
    SISPtr pSiS = SISPTR(pScrn);
    DisplayModePtr mode;
    int dx = 0,dy = 0;

    if(!((mode = xalloc(sizeof(DisplayModeRec))))) return dest;
    memcpy(mode, i, sizeof(DisplayModeRec));
    if(!((mode->Private = xalloc(sizeof(SiSMergedDisplayModeRec))))) {
       xfree(mode);
       return dest;
    }
    ((SiSMergedDisplayModePtr)mode->Private)->CRT1 = i;
    ((SiSMergedDisplayModePtr)mode->Private)->CRT2 = j;
    ((SiSMergedDisplayModePtr)mode->Private)->CRT2Position = srel;
    mode->PrivSize = 0;

    switch(srel) {
    case sisLeftOf:
    case sisRightOf:
       if(!(pScrn->display->virtualX)) {
          dx = i->HDisplay + j->HDisplay;
       } else {
          dx = min(pScrn->virtualX, i->HDisplay + j->HDisplay);
       }
       dx -= mode->HDisplay;
       if(!(pScrn->display->virtualY)) {
          dy = max(i->VDisplay, j->VDisplay);
       } else {
          dy = min(pScrn->virtualY, max(i->VDisplay, j->VDisplay));
       }
       dy -= mode->VDisplay;
       break;
    case sisAbove:
    case sisBelow:
       if(!(pScrn->display->virtualY)) {
          dy = i->VDisplay + j->VDisplay;
       } else {
          dy = min(pScrn->virtualY, i->VDisplay + j->VDisplay);
       }
       dy -= mode->VDisplay;
       if(!(pScrn->display->virtualX)) {
          dx = max(i->HDisplay, j->HDisplay);
       } else {
          dx = min(pScrn->virtualX, max(i->HDisplay, j->HDisplay));
       }
       dx -= mode->HDisplay;
       break;
    case sisClone:
       if(!(pScrn->display->virtualX)) {
          dx = max(i->HDisplay, j->HDisplay);
       } else {
          dx = min(pScrn->virtualX, max(i->HDisplay, j->HDisplay));
       }
       dx -= mode->HDisplay;
       if(!(pScrn->display->virtualY)) {
          dy = max(i->VDisplay, j->VDisplay);
       } else {
	  dy = min(pScrn->virtualY, max(i->VDisplay, j->VDisplay));
       }
       dy -= mode->VDisplay;
       break;
    }
    mode->HDisplay += dx;
    mode->HSyncStart += dx;
    mode->HSyncEnd += dx;
    mode->HTotal += dx;
    mode->VDisplay += dy;
    mode->VSyncStart += dy;
    mode->VSyncEnd += dy;
    mode->VTotal += dy;
    mode->Clock = 0;

    if( ((mode->HDisplay * ((pScrn->bitsPerPixel + 7) / 8) * mode->VDisplay) > pSiS->maxxfbmem) ||
        (mode->HDisplay > 4088) ||
	(mode->VDisplay > 4096) ) {

       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
       		"Skipped %dx%d, not enough video RAM or beyond hardware specs\n",
		mode->HDisplay, mode->VDisplay);
       xfree(mode->Private);
       xfree(mode);

       return dest;
    }

#ifdef SISXINERAMA
    if(srel != sisClone) {
       pSiS->AtLeastOneNonClone = TRUE;
    }
#endif

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
    	"Merged %dx%d and %dx%d to %dx%d%s\n",
	i->HDisplay, i->VDisplay, j->HDisplay, j->VDisplay,
	mode->HDisplay, mode->VDisplay, (srel == sisClone) ? " (Clone)" : "");

    mode->next = mode;
    mode->prev = mode;

    if(dest) {
       mode->next = dest->next; 	/* Insert node after "dest" */
       dest->next->prev = mode;
       mode->prev = dest;
       dest->next = mode;
    }

    return mode;
}

/* Helper function to find a mode from a given name
 * (Code base taken from mga driver)
 */
static DisplayModePtr
SiSGetModeFromName(char* str, DisplayModePtr i)
{
    DisplayModePtr c = i;
    if(!i) return NULL;
    do {
       if(strcmp(str, c->name) == 0) return c;
       c = c->next;
    } while(c != i);
    return NULL;
}

static DisplayModePtr
SiSFindWidestTallestMode(DisplayModePtr i, Bool tallest)
{
    DisplayModePtr c = i, d = NULL;
    int max = 0;
    if(!i) return NULL;
    do {
       if(tallest) {
          if(c->VDisplay > max) {
             max = c->VDisplay;
	     d = c;
          }
       } else {
          if(c->HDisplay > max) {
             max = c->HDisplay;
	     d = c;
          }
       }
       c = c->next;
    } while(c != i);
    return d;
}

static DisplayModePtr
SiSGenerateModeListFromLargestModes(ScrnInfoPtr pScrn,
		    DisplayModePtr i, DisplayModePtr j,
		    SiSScrn2Rel srel)
{
#ifdef SISXINERAMA
    SISPtr pSiS = SISPTR(pScrn);
#endif
    DisplayModePtr mode1 = NULL;
    DisplayModePtr mode2 = NULL;
    DisplayModePtr result = NULL;

#ifdef SISXINERAMA
    pSiS->AtLeastOneNonClone = FALSE;
#endif

    switch(srel) {
    case sisLeftOf:
    case sisRightOf:
       mode1 = SiSFindWidestTallestMode(i, FALSE);
       mode2 = SiSFindWidestTallestMode(j, FALSE);
       break;
    case sisAbove:
    case sisBelow:
       mode1 = SiSFindWidestTallestMode(i, TRUE);
       mode2 = SiSFindWidestTallestMode(j, TRUE);
       break;
    case sisClone:
       mode1 = i;
       mode2 = j;
    }

    if(mode1 && mode2) {
       return(SiSCopyModeNLink(pScrn, result, mode1, mode2, srel));
    } else {
       return NULL;
    }
}

/* Generate the merged-fb mode modelist from metamodes
 * (Code base taken from mga driver)
 */
static DisplayModePtr
SiSGenerateModeListFromMetaModes(ScrnInfoPtr pScrn, char* str,
		    DisplayModePtr i, DisplayModePtr j,
		    SiSScrn2Rel srel)
{
#ifdef SISXINERAMA
    SISPtr pSiS = SISPTR(pScrn);
#endif
    char* strmode = str;
    char modename[256];
    Bool gotdash = FALSE;
    SiSScrn2Rel sr;
    DisplayModePtr mode1 = NULL;
    DisplayModePtr mode2 = NULL;
    DisplayModePtr result = NULL;

#ifdef SISXINERAMA
    pSiS->AtLeastOneNonClone = FALSE;
#endif

    do {
        switch(*str) {
        case 0:
        case '-':
        case ' ':
           if((strmode != str)) {

              strncpy(modename, strmode, str - strmode);
              modename[str - strmode] = 0;

              if(gotdash) {
                 if(mode1 == NULL) return NULL;
                 mode2 = SiSGetModeFromName(modename, j);
                 if(!mode2) {
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "Mode \"%s\" is not a supported mode for CRT2\n", modename);
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "Skipping metamode \"%s-%s\".\n", mode1->name, modename);
                    mode1 = NULL;
                 }
              } else {
                 mode1 = SiSGetModeFromName(modename, i);
                 if(!mode1) {
                    char* tmps = str;
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "Mode \"%s\" is not a supported mode for CRT1\n", modename);
                    gotdash = FALSE;
                    while(*tmps == ' ') tmps++;
                    if(*tmps == '-') { 							/* skip the next mode */
                       tmps++;
                       while((*tmps == ' ') && (*tmps != 0)) tmps++; 			/* skip spaces */
                       while((*tmps != ' ') && (*tmps != '-') && (*tmps != 0)) tmps++; 	/* skip modename */
                       strncpy(modename,strmode,tmps - strmode);
                       modename[tmps - strmode] = 0;
                       str = tmps-1;
                    }
                    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                        "Skipping metamode \"%s\".\n", modename);
                    mode1 = NULL;
                 }
              }
              gotdash = FALSE;
           }
           strmode = str + 1;
           gotdash |= (*str == '-');

           if(*str != 0) break;
	   /* Fall through otherwise */

        default:
           if(!gotdash && mode1) {
              sr = srel;
              if(!mode2) {
                 mode2 = SiSGetModeFromName(mode1->name, j);
                 sr = sisClone;
              }
              if(!mode2) {
                 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                     "Mode: \"%s\" is not a supported mode for CRT2\n", mode1->name);
                 xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                     "Skipping metamode \"%s\".\n", modename);
                 mode1 = NULL;
              } else {
                 result = SiSCopyModeNLink(pScrn, result, mode1, mode2, sr);
                 mode1 = NULL;
                 mode2 = NULL;
              }
           }
           break;

        }

    } while(*(str++) != 0);

    return result;
}

static DisplayModePtr
SiSGenerateModeList(ScrnInfoPtr pScrn, char* str,
		    DisplayModePtr i, DisplayModePtr j,
		    SiSScrn2Rel srel)
{
   if(str != NULL) {
      return(SiSGenerateModeListFromMetaModes(pScrn, str, i, j, srel));
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
      	"No MetaModes given, linking %s modes by default\n",
	(srel == sisClone) ? "first" :
	   (((srel == sisLeftOf) || (srel == sisRightOf)) ? "widest" :  "tallest"));
      return(SiSGenerateModeListFromLargestModes(pScrn, i, j, srel));
   }
}

static void
SiSRecalcDefaultVirtualSize(ScrnInfoPtr pScrn)
{
    DisplayModePtr mode, bmode;
    int max;
    static const char *str = "MergedFB: Virtual %s %d\n";

    if(!(pScrn->display->virtualX)) {
       mode = bmode = pScrn->modes;
       max = 0;
       do {
          if(mode->HDisplay > max) max = mode->HDisplay;
          mode = mode->next;
       } while(mode != bmode);
       pScrn->virtualX = max;
       pScrn->displayWidth = max;
       xf86DrvMsg(pScrn->scrnIndex, X_PROBED, str, "width", max);
    }
    if(!(pScrn->display->virtualY)) {
       mode = bmode = pScrn->modes;
       max = 0;
       do {
          if(mode->VDisplay > max) max = mode->VDisplay;
          mode = mode->next;
       } while(mode != bmode);
       pScrn->virtualY = max;
       xf86DrvMsg(pScrn->scrnIndex, X_PROBED, str, "height", max);
    }
}

static void
SiSMergedFBSetDpi(ScrnInfoPtr pScrn1, ScrnInfoPtr pScrn2, SiSScrn2Rel srel)
{
   SISPtr pSiS = SISPTR(pScrn1);
   MessageType from = X_DEFAULT;
   xf86MonPtr DDC1 = (xf86MonPtr)(pScrn1->monitor->DDC);
   xf86MonPtr DDC2 = (xf86MonPtr)(pScrn2->monitor->DDC);
   int ddcWidthmm = 0, ddcHeightmm = 0;
   const char *dsstr = "MergedFB: Display dimensions: (%d, %d) mm\n";

   /* This sets the DPI for MergedFB mode. The problem is that
    * this can never be exact, because the output devices may
    * have different dimensions. This function tries to compromise
    * through a few assumptions, and it just calculates an average DPI
    * value for both monitors.
    */

   /* Given DisplaySize should regard BOTH monitors */
   pScrn1->widthmm = pScrn1->monitor->widthmm;
   pScrn1->heightmm = pScrn1->monitor->heightmm;

   /* Get DDC display size; if only either CRT1 or CRT2 provided these,
    * assume equal dimensions for both, otherwise add dimensions
    */
   if( (DDC1 && (DDC1->features.hsize > 0 && DDC1->features.vsize > 0)) &&
       (DDC2 && (DDC2->features.hsize > 0 && DDC2->features.vsize > 0)) ) {
      ddcWidthmm = max(DDC1->features.hsize, DDC2->features.hsize) * 10;
      ddcHeightmm = max(DDC1->features.vsize, DDC2->features.vsize) * 10;
      switch(srel) {
      case sisLeftOf:
      case sisRightOf:
         ddcWidthmm = (DDC1->features.hsize + DDC2->features.hsize) * 10;
	 break;
      case sisAbove:
      case sisBelow:
         ddcHeightmm = (DDC1->features.vsize + DDC2->features.vsize) * 10;
      default:
	 break;
      }
   } else if(DDC1 && (DDC1->features.hsize > 0 && DDC1->features.vsize > 0)) {
      ddcWidthmm = DDC1->features.hsize * 10;
      ddcHeightmm = DDC1->features.vsize * 10;
      switch(srel) {
      case sisLeftOf:
      case sisRightOf:
         ddcWidthmm *= 2;
	 break;
      case sisAbove:
      case sisBelow:
         ddcHeightmm *= 2;
      default:
	 break;
      }
   } else if(DDC2 && (DDC2->features.hsize > 0 && DDC2->features.vsize > 0) ) {
      ddcWidthmm = DDC2->features.hsize * 10;
      ddcHeightmm = DDC2->features.vsize * 10;
      switch(srel) {
      case sisLeftOf:
      case sisRightOf:
         ddcWidthmm *= 2;
	 break;
      case sisAbove:
      case sisBelow:
         ddcHeightmm *= 2;
      default:
	 break;
      }
   }

   if(monitorResolution > 0) {

      /* Set command line given values (overrules given options) */
      pScrn1->xDpi = monitorResolution;
      pScrn1->yDpi = monitorResolution;
      from = X_CMDLINE;

   } else if(pSiS->MergedFBXDPI) {

      /* Set option-wise given values (overrule DisplaySize) */
      pScrn1->xDpi = pSiS->MergedFBXDPI;
      pScrn1->yDpi = pSiS->MergedFBYDPI;
      from = X_CONFIG;

   } else if(pScrn1->widthmm > 0 || pScrn1->heightmm > 0) {

      /* Set values calculated from given DisplaySize */
      from = X_CONFIG;
      if(pScrn1->widthmm > 0) {
	 pScrn1->xDpi = (int)((double)pScrn1->virtualX * 25.4 / pScrn1->widthmm);
      }
      if(pScrn1->heightmm > 0) {
	 pScrn1->yDpi = (int)((double)pScrn1->virtualY * 25.4 / pScrn1->heightmm);
      }
      xf86DrvMsg(pScrn1->scrnIndex, from, dsstr, pScrn1->widthmm, pScrn1->heightmm);

    } else if(ddcWidthmm && ddcHeightmm) {

      /* Set values from DDC-provided display size */
      from = X_PROBED;
      xf86DrvMsg(pScrn1->scrnIndex, from, dsstr, ddcWidthmm, ddcHeightmm );
      pScrn1->widthmm = ddcWidthmm;
      pScrn1->heightmm = ddcHeightmm;
      if(pScrn1->widthmm > 0) {
	 pScrn1->xDpi = (int)((double)pScrn1->virtualX * 25.4 / pScrn1->widthmm);
      }
      if(pScrn1->heightmm > 0) {
	 pScrn1->yDpi = (int)((double)pScrn1->virtualY * 25.4 / pScrn1->heightmm);
      }

    } else {

      pScrn1->xDpi = pScrn1->yDpi = DEFAULT_DPI;

    }

    /* Sanity check */
    if(pScrn1->xDpi > 0 && pScrn1->yDpi <= 0)
       pScrn1->yDpi = pScrn1->xDpi;
    if(pScrn1->yDpi > 0 && pScrn1->xDpi <= 0)
       pScrn1->xDpi = pScrn1->yDpi;

    pScrn2->xDpi = pScrn1->xDpi;
    pScrn2->yDpi = pScrn1->yDpi;

    xf86DrvMsg(pScrn1->scrnIndex, from, "MergedFB: DPI set to (%d, %d)\n",
	       pScrn1->xDpi, pScrn1->yDpi);
}

/* Pseudo-Xinerama extension for MergedFB mode */
#ifdef SISXINERAMA

static void
SiSUpdateXineramaScreenInfo(ScrnInfoPtr pScrn1)
{
    SISPtr pSiS = SISPTR(pScrn1);
    int crt1scrnnum = 0, crt2scrnnum = 1;
    int x1=0, x2=0, y1=0, y2=0, h1=0, h2=0, w1=0, w2=0;
    DisplayModePtr currentMode, firstMode;
    Bool infochanged = FALSE;

    if(!pSiS->MergedFB) return;

    if(SiSnoPanoramiXExtension) return;

    if(!SiSXineramadataPtr) return;

    if(pSiS->CRT2IsScrn0) {
       crt1scrnnum = 1;
       crt2scrnnum = 0;
    }

    /* Attention: Usage of RandR may lead into virtual X and Y values
     * actually smaller than our MetaModes! To avoid this, we calculate
     * the maxCRT fields here (and not somewhere else, like in CopyNLink)
     *
     * *** For now: RandR will be disabled if SiS pseudo-Xinerama is on
     */

    if((pSiS->SiSXineramaVX != pScrn1->virtualX) || (pSiS->SiSXineramaVY != pScrn1->virtualY)) {

       if(!(pScrn1->modes)) return;

       pSiS->maxCRT1_X1 = pSiS->maxCRT1_X2 = 0;
       pSiS->maxCRT1_Y1 = pSiS->maxCRT1_Y2 = 0;
       pSiS->maxCRT2_X1 = pSiS->maxCRT2_X2 = 0;
       pSiS->maxCRT2_Y1 = pSiS->maxCRT2_Y2 = 0;
       pSiS->maxClone_X1 = pSiS->maxClone_X2 = 0;
       pSiS->maxClone_Y1 = pSiS->maxClone_Y2 = 0;

       currentMode = firstMode = pScrn1->modes;

       do {

          DisplayModePtr p = currentMode->next;
          DisplayModePtr i = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT1;
          DisplayModePtr j = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT2;
          SiSScrn2Rel srel = ((SiSMergedDisplayModePtr)currentMode->Private)->CRT2Position;

          if((i->HDisplay <= pScrn1->virtualX) && (j->HDisplay <= pScrn1->virtualX) &&
             (i->VDisplay <= pScrn1->virtualY) && (j->VDisplay <= pScrn1->virtualY)) {

             if(srel != sisClone) {
                if(pSiS->maxCRT1_X1 <= i->HDisplay) {
                   pSiS->maxCRT1_X1 = i->HDisplay;      /* Largest CRT1 mode */
                   if(pSiS->maxCRT1_X2 < j->HDisplay) {
                      pSiS->maxCRT1_X2 = j->HDisplay;   /* Largest X of CRT2 mode displayed with largest CRT1 mode */
                   }
                }
                if(pSiS->maxCRT2_X2 <= j->HDisplay) {
                   pSiS->maxCRT2_X2 = j->HDisplay;      /* Largest CRT2 mode */
                   if(pSiS->maxCRT2_X1 < i->HDisplay) {
                      pSiS->maxCRT2_X1 = i->HDisplay;   /* Largest X of CRT1 mode displayed with largest CRT2 mode */
                   }
                }
                if(pSiS->maxCRT1_Y1 <= i->VDisplay) {
                   pSiS->maxCRT1_Y1 = i->VDisplay;
                   if(pSiS->maxCRT1_Y2 < j->VDisplay) {
                      pSiS->maxCRT1_Y2 = j->VDisplay;
                   }
                }
                if(pSiS->maxCRT2_Y2 <= j->VDisplay) {
                   pSiS->maxCRT2_Y2 = j->VDisplay;
                   if(pSiS->maxCRT2_Y1 < i->VDisplay) {
                      pSiS->maxCRT2_Y1 = i->VDisplay;
                   }
                }
             } else {
                if(pSiS->maxClone_X1 < i->HDisplay) {
                   pSiS->maxClone_X1 = i->HDisplay;
                }
                if(pSiS->maxClone_X2 < j->HDisplay) {
                   pSiS->maxClone_X2 = j->HDisplay;
                }
                if(pSiS->maxClone_Y1 < i->VDisplay) {
                   pSiS->maxClone_Y1 = i->VDisplay;
                }
                if(pSiS->maxClone_Y2 < j->VDisplay) {
                   pSiS->maxClone_Y2 = j->VDisplay;
                }
             }
          }
          currentMode = p;

       } while((currentMode) && (currentMode != firstMode));

       pSiS->SiSXineramaVX = pScrn1->virtualX;
       pSiS->SiSXineramaVY = pScrn1->virtualY;
       infochanged = TRUE;

    }

    switch(pSiS->CRT2Position) {
    case sisLeftOf:
       x1 = min(pSiS->maxCRT1_X2, pScrn1->virtualX - pSiS->maxCRT1_X1);
       if(x1 < 0) x1 = 0;
       y1 = 0;
       w1 = pScrn1->virtualX - x1;
       h1 = pScrn1->virtualY;
       x2 = 0;
       y2 = 0;
       w2 = max(pSiS->maxCRT2_X2, pScrn1->virtualX - pSiS->maxCRT2_X1);
       if(w2 > pScrn1->virtualX) w2 = pScrn1->virtualX;
       h2 = pScrn1->virtualY;
       break;
    case sisRightOf:
       x1 = 0;
       y1 = 0;
       w1 = max(pSiS->maxCRT1_X1, pScrn1->virtualX - pSiS->maxCRT1_X2);
       if(w1 > pScrn1->virtualX) w1 = pScrn1->virtualX;
       h1 = pScrn1->virtualY;
       x2 = min(pSiS->maxCRT2_X1, pScrn1->virtualX - pSiS->maxCRT2_X2);
       if(x2 < 0) x2 = 0;
       y2 = 0;
       w2 = pScrn1->virtualX - x2;
       h2 = pScrn1->virtualY;
       break;
    case sisAbove:
       x1 = 0;
       y1 = min(pSiS->maxCRT1_Y2, pScrn1->virtualY - pSiS->maxCRT1_Y1);
       if(y1 < 0) y1 = 0;
       w1 = pScrn1->virtualX;
       h1 = pScrn1->virtualY - y1;
       x2 = 0;
       y2 = 0;
       w2 = pScrn1->virtualX;
       h2 = max(pSiS->maxCRT2_Y2, pScrn1->virtualY - pSiS->maxCRT2_Y1);
       if(h2 > pScrn1->virtualY) h2 = pScrn1->virtualY;
       break;
    case sisBelow:
       x1 = 0;
       y1 = 0;
       w1 = pScrn1->virtualX;
       h1 = max(pSiS->maxCRT1_Y1, pScrn1->virtualY - pSiS->maxCRT1_Y2);
       if(h1 > pScrn1->virtualY) h1 = pScrn1->virtualY;
       x2 = 0;
       y2 = min(pSiS->maxCRT2_Y1, pScrn1->virtualY - pSiS->maxCRT2_Y2);
       if(y2 < 0) y2 = 0;
       w2 = pScrn1->virtualX;
       h2 = pScrn1->virtualY - y2;
    default:
       break;
    }

    SiSXineramadataPtr[crt1scrnnum].x = x1;
    SiSXineramadataPtr[crt1scrnnum].y = y1;
    SiSXineramadataPtr[crt1scrnnum].width = w1;
    SiSXineramadataPtr[crt1scrnnum].height = h1;
    SiSXineramadataPtr[crt2scrnnum].x = x2;
    SiSXineramadataPtr[crt2scrnnum].y = y2;
    SiSXineramadataPtr[crt2scrnnum].width = w2;
    SiSXineramadataPtr[crt2scrnnum].height = h2;

    if(infochanged) {
       xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
          "Pseudo-Xinerama: CRT1 (Screen %d) (%d,%d)-(%d,%d)\n",
          crt1scrnnum, x1, y1, w1+x1-1, h1+y1-1);
       xf86DrvMsg(pScrn1->scrnIndex, X_INFO,
          "Pseudo-Xinerama: CRT2 (Screen %d) (%d,%d)-(%d,%d)\n",
          crt2scrnnum, x2, y2, w2+x2-1, h2+y2-1);
    }
}

/* Proc */

int
SiSProcXineramaQueryVersion(ClientPtr client)
{
    xPanoramiXQueryVersionReply	  rep;
    register int		  n;

    REQUEST_SIZE_MATCH(xPanoramiXQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = SIS_XINERAMA_MAJOR_VERSION;
    rep.minorVersion = SIS_XINERAMA_MINOR_VERSION;
    if(client->swapped) {
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);
        swaps(&rep.majorVersion, n);
        swaps(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xPanoramiXQueryVersionReply), (char *)&rep);
    return (client->noClientException);
}

int
SiSProcXineramaGetState(ClientPtr client)
{
    REQUEST(xPanoramiXGetStateReq);
    WindowPtr			pWin;
    xPanoramiXGetStateReply	rep;
    register int		n;

    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
    pWin = LookupWindow(stuff->window, client);
    if(!pWin) return BadWindow;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.state = !SiSnoPanoramiXExtension;
    if(client->swapped) {
       swaps (&rep.sequenceNumber, n);
       swapl (&rep.length, n);
       swaps (&rep.state, n);
    }
    WriteToClient(client, sizeof(xPanoramiXGetStateReply), (char *)&rep);
    return client->noClientException;
}

int
SiSProcXineramaGetScreenCount(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenCountReq);
    WindowPtr				pWin;
    xPanoramiXGetScreenCountReply	rep;
    register int			n;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
    pWin = LookupWindow(stuff->window, client);
    if(!pWin) return BadWindow;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.ScreenCount = SiSXineramaNumScreens;
    if(client->swapped) {
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swaps(&rep.ScreenCount, n);
    }
    WriteToClient(client, sizeof(xPanoramiXGetScreenCountReply), (char *)&rep);
    return client->noClientException;
}

int
SiSProcXineramaGetScreenSize(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenSizeReq);
    WindowPtr				pWin;
    xPanoramiXGetScreenSizeReply	rep;
    register int			n;

    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
    pWin = LookupWindow (stuff->window, client);
    if(!pWin)  return BadWindow;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.width  = SiSXineramadataPtr[stuff->screen].width;
    rep.height = SiSXineramadataPtr[stuff->screen].height;
    if(client->swapped) {
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swaps(&rep.width, n);
       swaps(&rep.height, n);
    }
    WriteToClient(client, sizeof(xPanoramiXGetScreenSizeReply), (char *)&rep);
    return client->noClientException;
}

int
SiSProcXineramaIsActive(ClientPtr client)
{
    xXineramaIsActiveReply	rep;

    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.state = !SiSnoPanoramiXExtension;
    if(client->swapped) {
	register int n;
	swaps(&rep.sequenceNumber, n);
	swapl(&rep.length, n);
	swapl(&rep.state, n);
    }
    WriteToClient(client, sizeof(xXineramaIsActiveReply), (char *) &rep);
    return client->noClientException;
}

int
SiSProcXineramaQueryScreens(ClientPtr client)
{
    xXineramaQueryScreensReply	rep;

    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.number = (SiSnoPanoramiXExtension) ? 0 : SiSXineramaNumScreens;
    rep.length = rep.number * sz_XineramaScreenInfo >> 2;
    if(client->swapped) {
       register int n;
       swaps(&rep.sequenceNumber, n);
       swapl(&rep.length, n);
       swapl(&rep.number, n);
    }
    WriteToClient(client, sizeof(xXineramaQueryScreensReply), (char *)&rep);

    if(!SiSnoPanoramiXExtension) {
       xXineramaScreenInfo scratch;
       int i;

       for(i = 0; i < SiSXineramaNumScreens; i++) {
	  scratch.x_org  = SiSXineramadataPtr[i].x;
	  scratch.y_org  = SiSXineramadataPtr[i].y;
	  scratch.width  = SiSXineramadataPtr[i].width;
	  scratch.height = SiSXineramadataPtr[i].height;
	  if(client->swapped) {
	     register int n;
	     swaps(&scratch.x_org, n);
	     swaps(&scratch.y_org, n);
	     swaps(&scratch.width, n);
    	     swaps(&scratch.height, n);
	  }
	  WriteToClient(client, sz_XineramaScreenInfo, (char *)&scratch);
       }
    }

    return client->noClientException;
}

static int
SiSProcXineramaDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
	case X_PanoramiXQueryVersion:
	     return SiSProcXineramaQueryVersion(client);
	case X_PanoramiXGetState:
	     return SiSProcXineramaGetState(client);
	case X_PanoramiXGetScreenCount:
	     return SiSProcXineramaGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return SiSProcXineramaGetScreenSize(client);
	case X_XineramaIsActive:
	     return SiSProcXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return SiSProcXineramaQueryScreens(client);
    }
    return BadRequest;
}

/* SProc */

static int
SiSSProcXineramaQueryVersion (ClientPtr client)
{
    REQUEST(xPanoramiXQueryVersionReq);
    register int n;
    swaps(&stuff->length,n);
    REQUEST_SIZE_MATCH (xPanoramiXQueryVersionReq);
    return SiSProcXineramaQueryVersion(client);
}

static int
SiSSProcXineramaGetState(ClientPtr client)
{
    REQUEST(xPanoramiXGetStateReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xPanoramiXGetStateReq);
    return SiSProcXineramaGetState(client);
}

static int
SiSSProcXineramaGetScreenCount(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenCountReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenCountReq);
    return SiSProcXineramaGetScreenCount(client);
}

static int
SiSSProcXineramaGetScreenSize(ClientPtr client)
{
    REQUEST(xPanoramiXGetScreenSizeReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);
    return SiSProcXineramaGetScreenSize(client);
}

static int
SiSSProcXineramaIsActive(ClientPtr client)
{
    REQUEST(xXineramaIsActiveReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXineramaIsActiveReq);
    return SiSProcXineramaIsActive(client);
}

static int
SiSSProcXineramaQueryScreens(ClientPtr client)
{
    REQUEST(xXineramaQueryScreensReq);
    register int n;
    swaps (&stuff->length, n);
    REQUEST_SIZE_MATCH(xXineramaQueryScreensReq);
    return SiSProcXineramaQueryScreens(client);
}

int
SiSSProcXineramaDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
	case X_PanoramiXQueryVersion:
	     return SiSSProcXineramaQueryVersion(client);
	case X_PanoramiXGetState:
	     return SiSSProcXineramaGetState(client);
	case X_PanoramiXGetScreenCount:
	     return SiSSProcXineramaGetScreenCount(client);
	case X_PanoramiXGetScreenSize:
	     return SiSSProcXineramaGetScreenSize(client);
	case X_XineramaIsActive:
	     return SiSSProcXineramaIsActive(client);
	case X_XineramaQueryScreens:
	     return SiSSProcXineramaQueryScreens(client);
    }
    return BadRequest;
}

static void
SiSXineramaResetProc(ExtensionEntry* extEntry)
{
    /* Called by CloseDownExtensions() */
    if(SiSXineramadataPtr) {
       Xfree(SiSXineramadataPtr);
       SiSXineramadataPtr = NULL;
    }
}

static void
SiSXineramaExtensionInit(ScrnInfoPtr pScrn)
{
    SISPtr    	pSiS = SISPTR(pScrn);
    Bool	success = FALSE;

    if(!(SiSXineramadataPtr)) {

       if(!pSiS->MergedFB) {
          SiSnoPanoramiXExtension = TRUE;
          return;
       }

#ifdef PANORAMIX
       if(!noPanoramiXExtension) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	     "Xinerama active, not initializing SiS Pseudo-Xinerama\n");
          SiSnoPanoramiXExtension = TRUE;
          return;
       }
#endif

       if(SiSnoPanoramiXExtension) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	      "SiS Pseudo-Xinerama disabled\n");
          return;
       }

       if(pSiS->CRT2Position == sisClone) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	     "Running MergedFB in Clone mode, SiS Pseudo-Xinerama disabled\n");
          SiSnoPanoramiXExtension = TRUE;
          return;
       }

       if(!(pSiS->AtLeastOneNonClone)) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	     "Only Clone modes defined, SiS Pseudo-Xinerama disabled\n");
          SiSnoPanoramiXExtension = TRUE;
          return;
       }

       SiSXineramaNumScreens = 2;

       while(SiSXineramaGeneration != serverGeneration) {

	  pSiS->XineramaExtEntry = AddExtension(PANORAMIX_PROTOCOL_NAME, 0,0,
					SiSProcXineramaDispatch,
					SiSSProcXineramaDispatch,
					SiSXineramaResetProc,
					StandardMinorOpcode);

	  if(!pSiS->XineramaExtEntry) break;

	  if(!(SiSXineramadataPtr = (SiSXineramaData *)
	        xcalloc(SiSXineramaNumScreens, sizeof(SiSXineramaData)))) break;

	  SiSXineramaGeneration = serverGeneration;
	  success = TRUE;
       }

       if(!success) {
          SISErrorLog(pScrn, "Failed to initialize SiS Pseudo-Xinerama extension\n");
          SiSnoPanoramiXExtension = TRUE;
          return;
       }

       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
    	  "SiS Pseudo-Xinerama extension initialized\n");

       pSiS->SiSXineramaVX = 0;
       pSiS->SiSXineramaVY = 0;

    }

    SiSUpdateXineramaScreenInfo(pScrn);

}
#endif  /* End of PseudoXinerama */

static void
SiSFreeCRT2Structs(SISPtr pSiS)
{
    if(pSiS->CRT2pScrn) {
       if(pSiS->CRT2pScrn->modes) {
          while(pSiS->CRT2pScrn->modes)
  	     xf86DeleteMode(&pSiS->CRT2pScrn->modes, pSiS->CRT2pScrn->modes);
       }
       if(pSiS->CRT2pScrn->monitor) {
          if(pSiS->CRT2pScrn->monitor->Modes) {
             while(pSiS->CRT2pScrn->monitor->Modes)
  	        xf86DeleteMode(&pSiS->CRT2pScrn->monitor->Modes, pSiS->CRT2pScrn->monitor->Modes);
	  }
	  if(pSiS->CRT2pScrn->monitor->DDC) xfree(pSiS->CRT2pScrn->monitor->DDC);
	  xfree(pSiS->CRT2pScrn->monitor);
       }
       xfree(pSiS->CRT2pScrn);
       pSiS->CRT2pScrn = NULL;
   }
}

#endif	/* End of MergedFB helpers */

static xf86MonPtr
SiSInternalDDC(ScrnInfoPtr pScrn, int crtno)
{
   SISPtr        pSiS = SISPTR(pScrn);
   USHORT        temp = 0xffff, temp1, i, realcrtno = crtno;
   unsigned char buffer[256];
   xf86MonPtr    pMonitor = NULL;

   /* If CRT1 is off, skip DDC */
   if((pSiS->CRT1off) && (!crtno)) return NULL;

   if(crtno) {
      if(pSiS->VBFlags & CRT2_LCD)      realcrtno = 1;
      else if(pSiS->VBFlags & CRT2_VGA) realcrtno = 2;
      else return NULL;
   } else {
      /* If CRT1 is LCDA, skip DDC (except 301C: DDC allowed, but uses CRT2 port!) */
      if(pSiS->VBFlags & CRT1_LCDA) {
         if(pSiS->VBFlags & VB_301C)    realcrtno = 1;
         else return NULL;
      }
   }

   i = 3; /* Number of retrys */
   do {
      temp1 = SiS_HandleDDC(pSiS->SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine, realcrtno, 0, &buffer[0]);
      if((temp1) && (temp1 != 0xffff)) temp = temp1;
   } while((temp == 0xffff) && i--);
   if(temp != 0xffff) {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "CRT%d DDC supported\n", crtno + 1);
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "CRT%d DDC level: %s%s%s%s\n",
	     crtno + 1,
	     (temp & 0x1a) ? "" : "[none of the supported]",
	     (temp & 0x02) ? "2 " : "",
	     (temp & 0x08) ? "D&P" : "",
             (temp & 0x10) ? "FPDI-2" : "");
      if(temp & 0x02) {
	 i = 5;  /* Number of retrys */
	 do {
	    temp = SiS_HandleDDC(pSiS->SiS_Pr, pSiS->VBFlags, pSiS->VGAEngine, realcrtno, 1, &buffer[0]);
	 } while((temp) && i--);
         if(!temp) {
	    if((pMonitor = xf86InterpretEDID(pScrn->scrnIndex, &buffer[0]))) {
	       return(pMonitor);
	    } else {
	       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	           "CRT%d DDC EDID corrupt\n", crtno + 1);
	       return(NULL);
	    }
	 } else {
            xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    	"CRT%d DDC reading failed\n", crtno + 1);
	    return(NULL);
	 }
      } else if(!crtno) {
	 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "DDC for VESA D&P and FPDI-2 not supported for CRT1.\n");
         return(NULL);
      } else if(temp & 0x18) {
         xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	      "DDC for VESA D&P and FPDI-2 not supported for CRT2 yet.\n");
         return(NULL);
      } 
      return(NULL);
   } else {
      xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
                "CRT%d DDC probing failed\n", crtno + 1);
      return(NULL);
   }
}

static xf86MonPtr
SiSDoPrivateDDC(ScrnInfoPtr pScrn, int *crtnum)
{
    SISPtr pSiS = SISPTR(pScrn);

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       if(pSiS->SecondHead) {
          *crtnum = 1;
	  return(SiSInternalDDC(pScrn, 0));
       } else {
          *crtnum = 2;
	  return(SiSInternalDDC(pScrn, 1));
       }
    } else
#endif
    if(pSiS->CRT1off) {
       *crtnum = 2;
       return(SiSInternalDDC(pScrn, 1));
    } else {
       *crtnum = 1;
       return(SiSInternalDDC(pScrn, 0));
    }
}

static BOOLEAN
SiSMakeOwnModeList(ScrnInfoPtr pScrn, BOOLEAN acceptcustommodes, BOOLEAN includelcdmodes,
                   BOOLEAN isfordvi, BOOLEAN *havecustommodes)
{
    DisplayModePtr tempmode, delmode, mymodes;

    if((mymodes = SiSBuildBuiltInModeList(pScrn, includelcdmodes, isfordvi))) {
       if(!acceptcustommodes) {
	  while(pScrn->monitor->Modes)
             xf86DeleteMode(&pScrn->monitor->Modes, pScrn->monitor->Modes);
	  pScrn->monitor->Modes = mymodes;
       } else {
	  delmode = pScrn->monitor->Modes;
	  while(delmode) {
	     if(delmode->type & M_T_DEFAULT) {
	        tempmode = delmode->next;
	        xf86DeleteMode(&pScrn->monitor->Modes, delmode);
	        delmode = tempmode;
	     } else {
	        delmode = delmode->next;
	     }
	  }
	  tempmode = pScrn->monitor->Modes;
	  if(tempmode) *havecustommodes = TRUE;
	  pScrn->monitor->Modes = mymodes;
	  while(mymodes) {
	     if(!mymodes->next) break;
	     else mymodes = mymodes->next;
	  }
	  mymodes->next = tempmode;
	  if(tempmode) {
	     tempmode->prev = mymodes;
	  }
       }
       return TRUE;
    } else
       return FALSE;
}

/* Mandatory */
static Bool
SISPreInit(ScrnInfoPtr pScrn, int flags)
{
    SISPtr pSiS;
    MessageType from;
    unsigned char usScratchCR17, CR5F;
    unsigned char usScratchCR32, usScratchCR63;
    unsigned char usScratchSR1F;
    unsigned long int i;
d1140 2
a1145 1
#if defined(SISMERGED) || defined(SISDUALHEAD)
d1147 1
a1147 1
#endif
d1156 4
a1159 21
    static const char *ddcsstr = "CRT%d DDC monitor info: ************************************\n";
    static const char *ddcestr = "End of CRT%d DDC monitor info ******************************\n";
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,14,0)
    static const char *subshstr = "Substituting missing CRT%d monitor HSync data by DDC data\n";
    static const char *subsvstr = "Substituting missing CRT%d monitor VRefresh data by DDC data\n";
#endif
#ifdef SISMERGED
    static const char *mergednocrt1 = "CRT1 not detected or forced off. %s.\n";
    static const char *mergednocrt2 = "No CRT2 output selected or no bridge detected. %s.\n";
    static const char *mergeddisstr = "MergedFB mode disabled";
    static const char *modesforstr = "Modes for CRT%d: *********************************************\n";
    static const char *crtsetupstr = "------------------------ CRT%d setup -------------------------\n";
#endif
#if defined(SISDUALHEAD) || defined(SISMERGED)
    static const char *notsuitablestr = "Not using mode \"%s\" (not suitable for %s mode)\n";
#endif

    if(flags & PROBE_DETECT) {
       if(xf86LoadSubModule(pScrn, "vbe")) {
          int index = xf86GetEntityInfo(pScrn->entityList[0])->index;

d1161 1
a1161 1
	  if((pVbe = VBEInit(NULL,index))) {
d1163 1
a1163 1
          if((pVbe = VBEExtendedInit(NULL,index,0))) {
d1165 5
a1169 5
             ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
             vbeFree(pVbe);
          }
       }
       return TRUE;
d1187 3
a1189 2
       SISErrorLog(pScrn, "Number of entities is not 1\n");
       return FALSE;
d1194 3
a1196 2
       SISErrorLog(pScrn, "Could not load vgahw module\n");
       return FALSE;
a1200 6
    /* Due to the liberal license terms this is needed for
     * keeping the copyright notice readable and intact in
     * binary distributions. Removing this is a copyright
     * infringement. Please read the license terms above.
     */

d1202 2
a1203 3
        "SiS driver (%d/%02d/%02d-%d)\n",
	SISDRIVERVERSIONYEAR + 2000, SISDRIVERVERSIONMONTH,
	SISDRIVERVERSIONDAY, SISDRIVERREVISION);
d1205 2
a1206 14
	"Copyright (C) 2001-2004 Thomas Winischhofer <thomas@@winischhofer.net> and others\n");
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
        "Compiled for XFree86 %d.%d.%d.%d\n",
	XF86_VERSION_MAJOR, XF86_VERSION_MINOR,
	XF86_VERSION_PATCH, XF86_VERSION_SNAP);
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
    if(xf86GetVersion() != XF86_VERSION_CURRENT) {
       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
         "This version of the driver is not compiled for this version of XFree86!\n");
    }
#endif
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
        "See http://www.winischhofer.net/linuxsisvga.shtml "
	"for documentation and updates\n");
d1210 3
a1212 2
       SISErrorLog(pScrn, "Could not allocate VGA private\n");
       return FALSE;
d1217 3
a1219 2
       SISErrorLog(pScrn, "Could not allocate memory for pSiS private\n");
       return FALSE;
d1233 4
a1236 3
       SISErrorLog(pScrn, "Entity's bus type is not PCI\n");
       SISFreeRec(pScrn);
       return FALSE;
d1240 1
a1240 1
    /* Allocate an entity private if necessary */
d1242 1
a1242 1
       pSiSEnt = xf86GetEntityPrivate(pScrn->entityList[0],
d1244 1
a1244 1
       pSiS->entityPrivate = pSiSEnt;
d1246 7
a1252 6
       /* If something went wrong, quit here */
       if((pSiSEnt->DisableDual) || (pSiSEnt->ErrorAfterFirst)) {
	  SISErrorLog(pScrn, "First head encountered fatal error, can't continue\n");
	  SISFreeRec(pScrn);
	  return FALSE;
       }
d1269 2
a1270 1
          SISErrorLog(pScrn, "Could not map VGA memory\n");
d1277 2
a1278 2
    /* We "patch" the PIOOffset inside vgaHW in order to force
     * the vgaHW module to use our relocated i/o ports.
d1294 2
a1295 1
          SISErrorLog(pScrn, "Could not load int10 module\n");
d1318 2
a1319 1
       SISErrorLog(pScrn, "Could not load ramdac module\n");
d1321 1
a1321 1
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
d1323 3
a1325 3
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
d1337 7
a1343 7
    if(pSiS->pEnt->device->chipset && *pSiS->pEnt->device->chipset)  {
       pScrn->chipset = pSiS->pEnt->device->chipset;
       pSiS->Chipset = xf86StringToToken(SISChipsets, pScrn->chipset);
       from = X_CONFIG;
    } else if(pSiS->pEnt->device->chipID >= 0) {
       pSiS->Chipset = pSiS->pEnt->device->chipID;
       pScrn->chipset = (char *)xf86TokenToString(SISChipsets, pSiS->Chipset);
d1345 2
a1346 2
       from = X_CONFIG;
       xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipID override: 0x%04X\n",
d1349 7
a1355 7
       from = X_PROBED;
       pSiS->Chipset = pSiS->PciInfo->chipType;
       pScrn->chipset = (char *)xf86TokenToString(SISChipsets, pSiS->Chipset);
    }
    if(pSiS->pEnt->device->chipRev >= 0) {
       pSiS->ChipRev = pSiS->pEnt->device->chipRev;
       xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "ChipRev override: %d\n",
d1358 1
a1358 1
       pSiS->ChipRev = pSiS->PciInfo->chipRev;
d1362 1
a1362 1
    /* Determine SiS6326 chiprevision. This is not yet used for
d1373 1
a1373 1
       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
d1378 1
a1378 1
		          (((pSiS->ChipRev & 0xf0) == 0xd0) ? "DVD (Dx/H0)" :
d1383 1
a1383 1
       if((pSiS->ChipRev != 0x0a) && (pSiS->ChipRev != 0x0b)) {
d1385 1
a1385 1
       }
d1393 3
a1395 2
    if(pScrn->chipset == NULL) {
       SISErrorLog(pScrn, "ChipID 0x%04X is not recognised\n", pSiS->Chipset);
d1397 1
a1397 1
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
d1399 3
a1401 3
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
d1403 3
a1405 2
    if(pSiS->Chipset < 0) {
       SISErrorLog(pScrn, "Chipset \"%s\" is not recognised\n", pScrn->chipset);
d1407 1
a1407 1
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
d1409 3
a1411 3
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
d1414 1
a1414 5
    /* Determine chipset and VGA engine type */
    pSiS->ChipFlags = 0;
    pSiS->SiS_SD_Flags = 0;
    pSiS->HWCursorMBufNum = pSiS->HWCursorCBufNum = 0;

a1418 1
		pSiS->SiS_SD_Flags |= SiS_SD_IS300SERIES;
d1423 1
a1423 1
		   pSiS->sishw_ext.jChipType = SIS_730;
a1425 1
		pSiS->SiS_SD_Flags |= SiS_SD_IS300SERIES;
a1429 1
		pSiS->SiS_SD_Flags |= SiS_SD_IS300SERIES;
a1433 3
		pSiS->ChipFlags |= SiSCF_315Core;
		pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
		pSiS->myCR63 = 0x63;
d1436 1
a1436 1
		/* Override for simplicity */
a1438 1
		pSiS->ChipFlags |= SiSCF_315Core;
a1439 2
		pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
		pSiS->myCR63 = 0x63;
d1442 1
a1442 1
		/* Override for simplicity */
a1444 1
		pSiS->ChipFlags |= SiSCF_315Core;
a1445 2
		pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
		pSiS->myCR63 = 0x63;
a1449 3
		pSiS->ChipFlags |= SiSCF_Integrated;
		pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
		pSiS->myCR63 = 0x63;
a1452 3
		if(pciReadLong(0x00000000, 0x00) == 0x07401039) {
		   pSiS->sishw_ext.jChipType = SIS_740;
		}
a1453 3
		pSiS->ChipFlags |= (SiSCF_Integrated | SiSCF_Real256ECore);
		pSiS->SiS_SD_Flags |= SiS_SD_IS315SERIES;
		pSiS->myCR63 = 0x63;
d1457 1
a1457 37
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->ChipFlags |= SiSCF_XabreCore;
		pSiS->SiS_SD_Flags |= SiS_SD_IS330SERIES;
		pSiS->myCR63 = 0x63;
		break;
	case PCI_CHIP_SIS660: /* 660, 661, 741, 760 */
	        {
		unsigned long hpciid = pciReadLong(0x00000000, 0x00);
		switch(hpciid) {
		case 0x06601039:
		   pSiS->sishw_ext.jChipType = SIS_660;
		   pSiS->ChipFlags |= SiSCF_Ultra256Core;
		   break;
		case 0x07601039:
		   pSiS->sishw_ext.jChipType = SIS_760;
		   pSiS->ChipFlags |= SiSCF_Ultra256Core;
		   break;
		case 0x07411039:
		   pSiS->sishw_ext.jChipType = SIS_741;
		   pSiS->ChipFlags |= SiSCF_Real256ECore;
		   break;
		case 0x06611039:
		default:
		   pSiS->sishw_ext.jChipType = SIS_661;
		   pSiS->ChipFlags |= SiSCF_Real256ECore;
		}
		/* Detection could also be done by CR5C & 0xf8:
		   0x10 = 661 (CR5F & 0xc0: 0x00 both A0 and A1)
		   0x80 = 760 (CR5F & 0xc0: 0x00 A0, 0x40 A1)
		   0x90 = 741 (CR5F & 0xc0: 0x00 A0,A1 0x40 A2)
		   other: 660 (CR5F & 0xc0: 0x00 A0 0x40 A1) (DOA?)
		 */
		pSiS->VGAEngine = SIS_315_VGA;
		pSiS->ChipFlags |= SiSCF_Integrated;
		pSiS->SiS_SD_Flags |= SiS_SD_IS330SERIES;
		pSiS->myCR63 = 0x53; /* Yes, 0x53 */
		}
d1469 2
a1470 2
    /* Now check if sisfb is loaded. Since sisfb only supports
     * the 300 and 315 series, we only do this for these chips.
d1474 2
a1475 5
     * Under kernel 2.4.y, that only works if sisfb is completely 
     * running, ie with a video mode because the fbdev will not be
     * installed otherwise. Under 2.5 and later, sisfb will install
     * the framebuffer device in any way and running it with mode=none
     * is no longer supported (or necessary).
a1479 6
    pSiS->sisfblcda = 0xff;
    pSiS->sisfbscalelcd = -1;
    pSiS->sisfbspecialtiming = CUT_NONE;
    pSiS->sisfb_haveemi = FALSE;
    pSiS->OldMode = 0;
    pSiS->sisfbfound = FALSE;
d1485 1
a1486 1
       CARD32 sisfbversion;
d1488 4
a1491 7
       {
          i=0;
          do {
             sprintf(name, "/dev/fb%1d", i);
             if((fd = open(name, 'r')) != -1) {

	        if(!ioctl(fd, SISFB_GET_INFO, &mysisfbinfo)) {
d1493 1
a1493 1
	           if(mysisfbinfo.sisfb_id == SISFB_ID) {
d1495 1
a1495 3
	              sisfbversion = (mysisfbinfo.sisfb_version << 16) |
		                     (mysisfbinfo.sisfb_revision << 8) |
			  	     (mysisfbinfo.sisfb_patchlevel);
d1497 4
a1500 2
	              if(sisfbversion >= 0x010508) {
		        /* Added PCI bus/slot/func into in sisfb Version 1.5.08.
d1502 7
a1508 7
		         */
		        if((mysisfbinfo.sisfb_pcibus == pSiS->PciInfo->bus) &&
		           (mysisfbinfo.sisfb_pcislot == pSiS->PciInfo->device) &&
		           (mysisfbinfo.sisfb_pcifunc == pSiS->PciInfo->func) ) {
	         	    pSiS->sisfbfound = TRUE;
		        }
		      } else pSiS->sisfbfound = TRUE;
d1510 41
a1550 69
		      if(pSiS->sisfbfound) {
		         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      	             "%s: SiS kernel fb driver (sisfb) %d.%d.%d detected (PCI: %02d:%02d.%d)\n",
		             	&name[5],
		             	mysisfbinfo.sisfb_version,
		     		mysisfbinfo.sisfb_revision,
		     		mysisfbinfo.sisfb_patchlevel,
		     		pSiS->PciInfo->bus,
		     		pSiS->PciInfo->device,
		     		pSiS->PciInfo->func);
		         /* Added version/rev/pl in sisfb 1.4.0 */
		         if(mysisfbinfo.sisfb_version == 0) {
		            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		                "Old version of sisfb found. Please update\n");
		         }
		         pSiS->sisfbMem = mysisfbinfo.heapstart;
		         /* Basically, we can't trust the pdc register if sisfb is loaded */
		         pSiS->donttrustpdc = TRUE;
		         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		         	"sisfb: memory heap starts at %dKB\n", (int)pSiS->sisfbMem);
		         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		      		"sisfb: using video mode 0x%02x\n", mysisfbinfo.fbvidmode);
		   	 pSiS->OldMode = mysisfbinfo.fbvidmode;
		         if(sisfbversion >= 0x010506) {
		            xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		        	"sisfb: %sreserved hardware cursor, using %s command queue\n",
			        (mysisfbinfo.sisfb_caps & 0x80) ? "" : "not ",
				(mysisfbinfo.sisfb_caps & 0x40) ? "SiS300 Turbo" :
			   	   (mysisfbinfo.sisfb_caps & 0x20) ? "SiS315/330 AGP" :
			              (mysisfbinfo.sisfb_caps & 0x10) ? "SiS315/330 VRAM" :
			                 (mysisfbinfo.sisfb_caps & 0x08) ? "SiS315/330 MMIO" :
				            "no");
		         }
		         if(sisfbversion >= 0x01050A) {
		            /* We can trust the pdc value if sisfb is of recent version */
		            if(pSiS->VGAEngine == SIS_300_VGA) pSiS->donttrustpdc = FALSE;
		            if(sisfbversion >= 0x01050B) {
			       if(pSiS->VGAEngine == SIS_300_VGA) {
		                  /* As of 1.5.11, sisfb saved the register for us (300 series) */
		      	          pSiS->sisfbpdc = mysisfbinfo.sisfb_lcdpdc;
			       }
		            }
		            if(sisfbversion >= 0x01050E) {
		               if(pSiS->VGAEngine == SIS_315_VGA) {
		                  pSiS->sisfblcda = mysisfbinfo.sisfb_lcda;
			       }
			       if(sisfbversion >= 0x01060D) {
			          pSiS->sisfbscalelcd = mysisfbinfo.sisfb_scalelcd;
				  pSiS->sisfbspecialtiming = mysisfbinfo.sisfb_specialtiming;
			       }
			       if(sisfbversion >= 0x010610) {
			          if(pSiS->VGAEngine == SIS_315_VGA) {
				     pSiS->donttrustpdc = FALSE;
				     pSiS->sisfbpdc = mysisfbinfo.sisfb_lcdpdc;
				     if(sisfbversion >= 0x010618) {
				        pSiS->sisfb_haveemi = mysisfbinfo.sisfb_haveemi ? TRUE : FALSE;
					pSiS->sisfb_haveemilcd = TRUE;  /* will match most cases */
					pSiS->sisfb_emi30 = mysisfbinfo.sisfb_emi30;
					pSiS->sisfb_emi31 = mysisfbinfo.sisfb_emi31;
					pSiS->sisfb_emi32 = mysisfbinfo.sisfb_emi32;
					pSiS->sisfb_emi33 = mysisfbinfo.sisfb_emi33;
					if(sisfbversion >= 0x010619) {
					   pSiS->sisfb_haveemilcd = mysisfbinfo.sisfb_haveemilcd ? TRUE : FALSE;
					}
				     }
				  }
			       }
		            }
		         }
d1552 9
a1560 8
	           }
	        }
	        close (fd);
             }
	     i++;
          } while((i <= 7) && (!pSiS->sisfbfound));
	  if(!pSiS->sisfbfound) xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "sisfb not found\n");
       }
d1565 2
a1566 1
     * Additionally, determine the size of the HWCursor memory area.
d1568 1
a1568 1
    switch(pSiS->VGAEngine) {
d1571 2
a1572 1
    	pix24flags = Support32bppFb;
d1576 2
a1577 1
    	pix24flags = Support32bppFb;
d1582 3
a1584 1
	             Support24bppFb;
d1588 3
a1590 1
        pix24flags = Support24bppFb;
d1595 5
a1599 5
    /* In case of Dual Head, we need to determine if we are the "master" head or
     * the "slave" head. In order to do that, we set PrimInit to DONE in the
     * shared entity at the end of the first initialization. The second
     * initialization then knows that some things have already been done. THIS
     * ALWAYS ASSUMES THAT THE FIRST DEVICE INITIALIZED IS THE MASTER!
d1603 22
a1624 24
       if(pSiSEnt->lastInstance > 0) {
     	  if(!xf86IsPrimInitDone(pScrn->entityList[0])) {
	     /* First Head (always CRT2) */
	     pSiS->SecondHead = FALSE;
	     pSiSEnt->pScrn_1 = pScrn;
	     pSiSEnt->CRT1ModeNo = pSiSEnt->CRT2ModeNo = -1;
	     pSiSEnt->CRT2ModeSet = FALSE;
	     pSiS->DualHeadMode = TRUE;
	     pSiSEnt->DisableDual = FALSE;
	     pSiSEnt->BIOS = NULL;
	     pSiSEnt->SiS_Pr = NULL;
	     pSiSEnt->RenderAccelArray = NULL;
	  } else {
	     /* Second Head (always CRT1) */
	     pSiS->SecondHead = TRUE;
	     pSiSEnt->pScrn_2 = pScrn;
	     pSiS->DualHeadMode = TRUE;
	  }
       } else {
          /* Only one screen in config file - disable dual head mode */
          pSiS->SecondHead = FALSE;
	  pSiS->DualHeadMode = FALSE;
	  pSiSEnt->DisableDual = TRUE;
       }
d1626 3
a1628 3
       /* Entity is not shared - disable dual head mode */
       pSiS->SecondHead = FALSE;
       pSiS->DualHeadMode = FALSE;
d1634 1
a1634 1
    /* Allocate SiS_Private (for mode switching code) and initialize it */
d1643 2
a1644 1
          SISErrorLog(pScrn, "Could not allocate memory for SiS_Pr private\n");
d1646 1
a1646 1
	  if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
d1648 3
a1650 3
	  if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	  SISFreeRec(pScrn);
          return FALSE;
a1655 15
       pSiS->SiS_Pr->SiS_Backup70xx = 0xff;
       pSiS->SiS_Pr->SiS_CHOverScan = -1;
       pSiS->SiS_Pr->SiS_ChSW = FALSE;
       pSiS->SiS_Pr->SiS_CustomT = CUT_NONE;
       pSiS->SiS_Pr->CRT1UsesCustomMode = FALSE;
       pSiS->SiS_Pr->PDC = -1;
       pSiS->SiS_Pr->LVDSHL = -1;
       pSiS->SiS_Pr->HaveEMI = FALSE;
       pSiS->SiS_Pr->HaveEMILCD = FALSE;
       pSiS->SiS_Pr->OverruleEMI = FALSE;
       pSiS->SiS_Pr->SiS_SensibleSR11 = FALSE;
       if(pSiS->sishw_ext.jChipType >= SIS_661) {
          pSiS->SiS_Pr->SiS_SensibleSR11 = TRUE;
       }
       pSiS->SiS_Pr->SiS_MyCR63 = pSiS->myCR63;
d1657 4
d1662 3
a1664 3
    /* Get our relocated IO registers */
    pSiS->RelIO = (SISIOADDRESS)((pSiS->PciInfo->ioBase[2] & 0xFFFC) + pSiS->IODBase);
    pSiS->sishw_ext.ulIOAddress = (SISIOADDRESS)(pSiS->RelIO + 0x30);
d1668 2
a1669 2
    /* Initialize SiS Port Reg definitions for externally used
     * init.c/init301.c functions.
d1673 3
a1675 5
    /* The following identifies the old chipsets. This is only
     * partly used since the really old chips are not supported,
     * but I keep it here for future use.
     * 205, 215 and 225 are to be treated the same way, 201 and 202
     * are different.
d1679 1
a1679 5
       case PCI_CHIP_SG86C201:
       	  pSiS->oldChipset = OC_SIS86201; break;
       case PCI_CHIP_SG86C202:
       	  pSiS->oldChipset = OC_SIS86202; break;
       case PCI_CHIP_SG86C205:
d1689 1
a1689 1
       case PCI_CHIP_SIS82C204:
d1691 1
a1691 1
       case 0x6225:
d1698 3
a1700 7
          if(pciReadLong(0x00000000, 0x00) == 0x06201039) {
	     pSiS->oldChipset = OC_SIS620;
	  } else {
             if((pSiS->ChipRev & 0x0f) < 0x0a)
	  	   pSiS->oldChipset = OC_SIS530A;
	     else  pSiS->oldChipset = OC_SIS530B;
	  }
d1707 3
a1709 2
    if(!xf86SetDepthBpp(pScrn, 0, 0, 0, pix24flags)) {
       SISErrorLog(pScrn, "xf86SetDepthBpp() error\n");
d1711 1
a1711 1
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
d1713 3
a1715 3
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
d1721 11
a1731 12
       case 8:
       case 16:
       case 24:
          break;
       case 15:
	  if((pSiS->VGAEngine == SIS_300_VGA) ||
	     (pSiS->VGAEngine == SIS_315_VGA)) {
	     temp = 1;
	  }
          break;
       default:
	  temp = 1;
d1735 2
a1736 2
       SISErrorLog(pScrn,
               "Given color depth (%d) is not supported by this driver/chipset\n",
d1738 3
a1740 3
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
a1744 10
    if( (((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) &&
         (pScrn->bitsPerPixel == 24)) ||
	((pSiS->VGAEngine == SIS_OLD_VGA) && (pScrn->bitsPerPixel == 32)) ) {
       SISErrorLog(pScrn,
            "Framebuffer bpp %d not supported for this chipset\n", pScrn->bitsPerPixel);
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }

d1746 2
a1747 3
    if(pScrn->depth == 24 && pix24bpp == 0) {
       pix24bpp = xf86GetBppFromDepth(pScrn, 24);
    }
d1758 2
a1759 1
	    SISErrorLog(pScrn, "xf86SetWeight() error\n");
d1786 4
a1789 4
	      SISErrorLog(pScrn,
	      	"RGB weight %d%d%d at depth %d not supported by hardware\n",
		(int)pScrn->weight.red, (int)pScrn->weight.green,
		(int)pScrn->weight.blue, pScrn->depth);
d1800 1
a1800 1
    /* Set the current layout parameters */
d1806 2
a1807 1
        SISErrorLog(pScrn, "xf86SetDefaultVisual() error\n");
d1809 1
a1809 1
	if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
d1816 4
a1819 4
        if(pScrn->depth > 8 && pScrn->defaultVisual != TrueColor) {
            SISErrorLog(pScrn,
	       	"Given default visual (%s) is not supported at depth %d\n",
                xf86GetVisualName(pScrn->defaultVisual), pScrn->depth);
d1821 1
a1821 1
	    if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
a1828 11
#ifdef SISDUALHEAD
    /* Due to palette & timing problems we don't support 8bpp in DHM */
    if((pSiS->DualHeadMode) && (pScrn->bitsPerPixel == 8)) {
       SISErrorLog(pScrn, "Color depth 8 not supported in Dual Head mode.\n");
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       SISFreeRec(pScrn);
       return FALSE;
    }
#endif

d1836 2
a1837 1
	    SISErrorLog(pScrn, "xf86SetGamma() error\n");
d1852 1
a1852 1
       pScrn->rgbBits = 6;
d1855 2
d1862 5
a1866 1
    /* Read BIOS for 300 and 315/330 series customization */
d1873 1
a1873 1
       if(pSiSEnt) {
d1875 2
a1876 2
	     pSiS->BIOS = pSiSEnt->BIOS;
	     pSiS->sishw_ext.pjVirtualRomBase = pSiS->BIOS;
d1878 1
a1878 1
       }
d1880 1
a1880 1
       if(!pSiS->BIOS) {
d1886 1
a1886 1
             unsigned short romptr, pciid;
d1888 12
d1912 18
a1929 13
		romptr = pSiS->BIOS[0x18] | (pSiS->BIOS[0x19] << 8);
		if(romptr > (BIOS_SIZE - 8)) continue;
		if((pSiS->BIOS[romptr]   != 'P') || (pSiS->BIOS[romptr+1] != 'C') ||
		   (pSiS->BIOS[romptr+2] != 'I') || (pSiS->BIOS[romptr+3] != 'R')) continue;

		pciid = pSiS->BIOS[romptr+4] | (pSiS->BIOS[romptr+5] << 8);
		if(pciid != 0x1039) continue;

		pciid = pSiS->BIOS[romptr+6] | (pSiS->BIOS[romptr+7] << 8);
		if(pciid != pSiS->Chipset) continue;

		found = TRUE;
		break;
d1944 1
a1944 1
			"Video BIOS version \"%7s\" found at 0x%lx\n",
d1947 1
d1949 3
a1951 3
       }
       if(pSiS->BIOS) pSiS->sishw_ext.UseROM = TRUE;
       else           pSiS->sishw_ext.UseROM = FALSE;
a1956 8
#ifdef SISMERGED
    /* Due to palette & timing problems we don't support 8bpp in MFBM */
    if((pSiS->MergedFB) && (pScrn->bitsPerPixel == 8)) {
       SISErrorLog(pScrn, "MergedFB: Color depth 8 not supported, %s\n", mergeddisstr);
       pSiS->MergedFB = pSiS->MergedFBAuto = FALSE;
    }
#endif

d1960 1
a1960 1
	     /* Copy some option settings to entity private */
a1961 7
	     pSiSEnt->NoAccel = pSiS->NoAccel;
	     pSiSEnt->restorebyset = pSiS->restorebyset;
	     pSiSEnt->OptROMUsage = pSiS->OptROMUsage;
	     pSiSEnt->OptUseOEM = pSiS->OptUseOEM;
	     pSiSEnt->TurboQueue = pSiS->TurboQueue;
	     pSiSEnt->forceCRT1 = pSiS->forceCRT1;
	     pSiSEnt->ForceCRT1Type = pSiS->ForceCRT1Type;
d1964 2
a1965 4
	     pSiSEnt->ForceYPbPrType = pSiS->ForceYPbPrType;
	     pSiSEnt->ForceYPbPrAR = pSiS->ForceYPbPrAR;
	     pSiSEnt->UsePanelScaler = pSiS->UsePanelScaler;
	     pSiSEnt->DSTN = pSiS->DSTN;
a1967 2
	     pSiSEnt->NonDefaultNTSC = pSiS->NonDefaultNTSC;
	     pSiSEnt->chtvtype = pSiS->chtvtype;
d1970 6
a1986 4
	     pSiSEnt->sistvcfilter = pSiS->sistvcfilter;
	     pSiSEnt->sistvyfilter = pSiS->sistvyfilter;
	     pSiSEnt->sistvcolcalibc = pSiS->sistvcolcalibc;
	     pSiSEnt->sistvcolcalibf = pSiS->sistvcolcalibf;
d1989 1
a1989 16
	     pSiSEnt->tvxscale = pSiS->tvxscale;
	     pSiSEnt->tvyscale = pSiS->tvyscale;
	     pSiSEnt->CRT1gamma = pSiS->CRT1gamma;
	     pSiSEnt->CRT1gammaGiven = pSiS->CRT1gammaGiven;
	     pSiSEnt->XvGammaRed = pSiS->XvGammaRed;
	     pSiSEnt->XvGammaGreen = pSiS->XvGammaGreen;
	     pSiSEnt->XvGammaBlue = pSiS->XvGammaBlue;
	     pSiSEnt->XvGamma = pSiS->XvGamma;
	     pSiSEnt->XvGammaGiven = pSiS->XvGammaGiven;
	     pSiSEnt->CRT2gamma = pSiS->CRT2gamma;
	     pSiSEnt->XvOnCRT2 = pSiS->XvOnCRT2;
	     pSiSEnt->AllowHotkey = pSiS->AllowHotkey;
	     pSiSEnt->enablesisctrl = pSiS->enablesisctrl;
#ifdef SIS_CP
	     SIS_CP_DRIVER_COPYOPTIONSENT
#endif
d2000 79
a2078 1

d2088 137
a2224 44

	     pSiS->TurboQueue = pSiSEnt->TurboQueue;
	     pSiS->restorebyset = pSiSEnt->restorebyset;
	     pSiS->AllowHotkey = pSiS->AllowHotkey;
	     pSiS->OptROMUsage = pSiSEnt->OptROMUsage;
	     pSiS->OptUseOEM = pSiSEnt->OptUseOEM;
	     pSiS->forceCRT1 = pSiSEnt->forceCRT1;
	     pSiS->nocrt2ddcdetection = FALSE;
	     pSiS->forcecrt2redetection = FALSE;
	     pSiS->ForceCRT1Type = pSiSEnt->ForceCRT1Type;
	     pSiS->ForceCRT2Type = pSiSEnt->ForceCRT2Type;
	     pSiS->UsePanelScaler = pSiSEnt->UsePanelScaler;
	     pSiS->DSTN = pSiSEnt->DSTN;
	     pSiS->OptTVStand = pSiSEnt->OptTVStand;
	     pSiS->NonDefaultPAL = pSiSEnt->NonDefaultPAL;
	     pSiS->NonDefaultNTSC = pSiSEnt->NonDefaultNTSC;
	     pSiS->chtvtype = pSiSEnt->chtvtype;
	     pSiS->ForceTVType = pSiSEnt->ForceTVType;
	     pSiS->ForceYPbPrType = pSiSEnt->ForceYPbPrType;
	     pSiS->ForceYPbPrAR = pSiSEnt->ForceYPbPrAR;
	     pSiS->OptTVOver = pSiSEnt->OptTVOver;
	     pSiS->OptTVSOver = pSiSEnt->OptTVSOver;
	     pSiS->chtvlumabandwidthcvbs = pSiSEnt->chtvlumabandwidthcvbs;
	     pSiS->chtvlumabandwidthsvideo = pSiSEnt->chtvlumabandwidthsvideo;
	     pSiS->chtvlumaflickerfilter = pSiSEnt->chtvlumaflickerfilter;
	     pSiS->chtvchromabandwidth = pSiSEnt->chtvchromabandwidth;
	     pSiS->chtvchromaflickerfilter = pSiSEnt->chtvchromaflickerfilter;
	     pSiS->chtvcvbscolor = pSiSEnt->chtvcvbscolor;
	     pSiS->chtvtextenhance = pSiSEnt->chtvtextenhance;
	     pSiS->chtvcontrast = pSiSEnt->chtvcontrast;
	     pSiS->sistvedgeenhance = pSiSEnt->sistvedgeenhance;
	     pSiS->sistvantiflicker = pSiSEnt->sistvantiflicker;
	     pSiS->sistvsaturation = pSiSEnt->sistvsaturation;
	     pSiS->sistvcfilter = pSiSEnt->sistvcfilter;
	     pSiS->sistvyfilter = pSiSEnt->sistvyfilter;
	     pSiS->sistvcolcalibc = pSiSEnt->sistvcolcalibc;
	     pSiS->sistvcolcalibf = pSiSEnt->sistvcolcalibf;
	     pSiS->tvxpos = pSiSEnt->tvxpos;
	     pSiS->tvypos = pSiSEnt->tvypos;
	     pSiS->tvxscale = pSiSEnt->tvxscale;
	     pSiS->tvyscale = pSiSEnt->tvyscale;
	     if(!pSiS->CRT1gammaGiven) {
	        if(pSiSEnt->CRT1gammaGiven)
	           pSiS->CRT1gamma = pSiSEnt->CRT1gamma;
d2226 5
a2230 7
	     pSiS->CRT2gamma = pSiSEnt->CRT2gamma;
	     if(!pSiS->XvGammaGiven) {
	        if(pSiSEnt->XvGammaGiven) {
		   pSiS->XvGamma = pSiSEnt->XvGamma;
		   pSiS->XvGammaRed = pSiS->XvGammaRedDef = pSiSEnt->XvGammaRed;
		   pSiS->XvGammaGreen = pSiS->XvGammaGreenDef = pSiSEnt->XvGammaGreen;
		   pSiS->XvGammaBlue = pSiS->XvGammaBlueDef = pSiSEnt->XvGammaBlue;
d2232 4
a2236 12
	     pSiS->XvOnCRT2 = pSiSEnt->XvOnCRT2;
	     pSiS->enablesisctrl = pSiSEnt->enablesisctrl;
	     /* Copy gamma brightness to Ent for Xinerama */
	     pSiSEnt->GammaBriR = pSiS->GammaBriR;
	     pSiSEnt->GammaBriG = pSiS->GammaBriG;
	     pSiSEnt->GammaBriB = pSiS->GammaBriB;
	     pSiSEnt->GammaPBriR = pSiS->GammaPBriR;
	     pSiSEnt->GammaPBriG = pSiS->GammaPBriG;
	     pSiSEnt->GammaPBriB = pSiS->GammaPBriB;
#ifdef SIS_CP
	     SIS_CP_DRIVER_COPYOPTIONS
#endif
d2240 1
a2240 2

    /* Handle UseROMData, NoOEM and UsePanelScaler options */
d2244 2
a2245 3
       	  pSiS->sishw_ext.UseROM = FALSE;
	  from = X_CONFIG;
	  xf86DrvMsg(pScrn->scrnIndex, from, "Video ROM data usage is disabled\n");
d2247 2
d2251 13
a2263 3
          xf86DrvMsg(pScrn->scrnIndex, from, "Internal OEM LCD/TV/VGA2 data usage is disabled\n");
	  
       pSiS->SiS_Pr->UsePanelScaler = pSiS->UsePanelScaler;
d2270 7
a2276 7
    if(pSiS->pEnt->device->MemBase != 0) {
       /*
        * XXX Should check that the config file value matches one of the
        * PCI base address values.
        */
       pSiS->FbAddress = pSiS->pEnt->device->MemBase;
       from = X_CONFIG;
d2278 1
a2278 1
       pSiS->FbAddress = pSiS->PciInfo->memBase[0] & 0xFFFFFFF0;
d2292 1
a2292 1
    if(pSiS->pEnt->device->IOBase != 0) {
d2297 2
a2298 2
       pSiS->IOAddress = pSiS->pEnt->device->IOBase;
       from = X_CONFIG;
d2300 1
a2300 1
       pSiS->IOAddress = pSiS->PciInfo->memBase[1] & 0xFFFFFFF0;
d2309 2
a2310 1
       SISErrorLog(pScrn, "xf86RegisterResources() found resource conflicts\n");
d2312 1
a2312 1
       if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
d2314 4
a2317 4
       if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
       sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
       SISFreeRec(pScrn);
       return FALSE;
d2321 3
a2323 8
    if(pSiS->pEnt->device->videoRam != 0) {
       if(pSiS->Chipset == PCI_CHIP_SIS6326) {
          pScrn->videoRam = pSiS->pEnt->device->videoRam;
          from = X_CONFIG;
       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	  	"Option \"VideoRAM\" ignored\n");
       }
a2326 1

d2334 1
a2334 1
    } else {
a2336 1
    }
d2354 3
a2356 3
    /* Calculate real availMem according to Accel/TurboQueue and
     * HWCursur setting. Also, initialize some variables used
     * in other modules.
a2357 1

d2359 1
a2359 6
    pSiS->CurARGBDest = NULL;
    pSiS->CurMonoSrc = NULL;
    pSiS->CurFGCol = pSiS->CurBGCol = 0;

    switch(pSiS->VGAEngine) {

d2363 2
a2364 2
	   pSiS->availMem -= (pSiS->TurboQueueLen*1024);
	   pSiS->cursorOffset = 512;
d2366 3
a2368 3
	if(pSiS->HWCursor) {
	   pSiS->availMem -= pSiS->CursorSize;
	   if(pSiS->OptUseColorCursor) pSiS->availMem -= pSiS->CursorSize;
a2376 1

a2377 12
#ifdef SISVRAMQ
	pSiS->cmdQueueSizeMask = pSiS->cmdQueueSize - 1;	/* VRAM Command Queue is variable (in therory) */
	pSiS->cmdQueueOffset = (pScrn->videoRam * 1024) - pSiS->cmdQueueSize;
	pSiS->cmdQueueLen = 0;
        pSiS->cmdQueueLenMin = 0x200;
        pSiS->cmdQueueLenMax = pSiS->cmdQueueSize - pSiS->cmdQueueLenMin;
	pSiS->cmdQueueSize_div2 = pSiS->cmdQueueSize / 2;
	pSiS->cmdQueueSize_div4 = pSiS->cmdQueueSize / 4;
	pSiS->cmdQueueSize_4_3 = (pSiS->cmdQueueSize / 4) * 3;
	pSiS->availMem -= pSiS->cmdQueueSize;
        pSiS->cursorOffset = (pSiS->cmdQueueSize / 1024);
#else
d2379 2
a2380 2
	   pSiS->availMem -= (512*1024);  			/* MMIO Command Queue is 512k (variable in theory) */
	   pSiS->cursorOffset = 512;
d2382 3
a2384 4
#endif
	if(pSiS->HWCursor) {
           pSiS->availMem -= (pSiS->CursorSize * 2);
	   if(pSiS->OptUseColorCursor) pSiS->availMem -= (pSiS->CursorSize * 2);
a2390 1

d2392 11
a2402 11
        /* cursorOffset not used in cursor functions for 530 and
	 * older chips, because the cursor is *above* the TQ.
	 * On 5597 and older revisions of the 6326, the TQ is
	 * max 32K, on newer 6326 revisions and the 530 either 30
	 * (or 32?) or 62K (or 64?). However, to make sure, we
	 * use only 30K (or 32?), but reduce the available memory
	 * by 64, and locate the TQ at the beginning of this last
	 * 64K block. (We do this that way even when using the
	 * HWCursor, because the cursor only takes 2K and the
	 * queue does not seem to last that far anyway.)
	 * The TQ must be located at 32KB boundaries.
d2405 5
a2409 5
	   if(pSiS->TurboQueue) {
	      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		    "Not enough video RAM for TurboQueue. TurboQueue disabled\n");
	      pSiS->TurboQueue = FALSE;
	   }
d2414 2
a2415 2
			      pSiS->CmdQueMaxLen = 900;   /* To make sure; should be 992 */
	} else if(pSiS->HWCursor) {
d2419 1
a2419 1
		/* Check if Flat Panel is enabled */
d2423 1
a2423 1
		/* Set up mask for MMIO register */
d2426 7
a2432 7
	        /* TQ is never used on 6326/5597, because the accelerator
		 * always Syncs. So this is just cosmentic work. (And I
		 * am not even sure that 0x7fff is correct. MMIO 0x83a8
		 * holds 0xec0 if (30k) TQ is enabled, 0x20 if TQ disabled.
		 * The datasheet has no real explanation on the queue length
		 * if the TQ is enabled. Not syncing and waiting for a
		 * suitable queue length instead does not work.
d2437 2
a2438 2
	/* This is to be subtracted from MMIO queue length register contents
	 * for getting the real Queue length.
d2444 3
a2446 3
    /* In dual head mode, we share availMem equally - so align it
     * to 8KB; this way, the address of the FB of the second
     * head is aligned to 4KB for mapping.
d2448 2
a2449 2
   if(pSiS->DualHeadMode)
      pSiS->availMem &= 0xFFFFE000;
d2452 1
a2452 1
    /* Check MaxXFBMem setting */
d2454 5
a2458 5
    /* Since DRI is not supported in dual head mode, we
       don't need the MaxXFBMem setting. */
    if(pSiS->DualHeadMode) {
       if(pSiS->maxxfbmem) {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d2460 2
a2461 2
       }
       pSiS->maxxfbmem = pSiS->availMem;
d2464 20
a2483 20
       if(pSiS->maxxfbmem) {
    	  if(pSiS->maxxfbmem > pSiS->availMem) {
	     if(pSiS->sisfbMem) {
	        pSiS->maxxfbmem = pSiS->sisfbMem * 1024;
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
             	   	"Invalid MaxXFBMem setting. Using sisfb heap start information\n");
	     } else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                	"Invalid MaxXFBMem setting. Using all VideoRAM for framebuffer\n");
	        pSiS->maxxfbmem = pSiS->availMem;
	     }
	  } else if(pSiS->sisfbMem) {
	     if(pSiS->maxxfbmem > pSiS->sisfbMem * 1024) {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	       		"MaxXFBMem beyond sisfb heap start. Using sisfb heap start\n");
                pSiS->maxxfbmem = pSiS->sisfbMem * 1024;
	     }
	  }
    } else if(pSiS->sisfbMem) {
       pSiS->maxxfbmem = pSiS->sisfbMem * 1024;
d2487 2
a2488 2
    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using %ldK of framebuffer memory\n",
    				pSiS->maxxfbmem / 1024);
d2490 8
a2497 8
    /* Find out about sub-classes of some chipsets and check
     * if the chipset supports two video overlays
     */
    if(pSiS->VGAEngine == SIS_300_VGA    ||
       pSiS->VGAEngine == SIS_315_VGA    ||
       pSiS->Chipset == PCI_CHIP_SIS530  ||
       pSiS->Chipset == PCI_CHIP_SIS6326 ||
       pSiS->Chipset == PCI_CHIP_SIS5597)  {
d2499 1
a2499 1
       switch(pSiS->Chipset) {
d2502 3
a2504 3
         case PCI_CHIP_SIS550:
	   pSiS->hasTwoOverlays = TRUE;
	   pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
a2505 30
	 case PCI_CHIP_SIS315PRO:
	   pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
	   break;
         case PCI_CHIP_SIS330:
	   pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
	   pSiS->ChipFlags |= SiSCF_CRT2HWCKaputt;
	   break;
	 case PCI_CHIP_SIS660:
	   {
#if 0
	     static const char *id661str[] = {
	   	"661 ?", "661 ?", "661 ?", "661 ?",
		"661 ?", "661 ?", "661 ?", "661 ?",
		"661 ?", "661 ?", "661 ?", "661 ?",
		"661 ?", "661 ?", "661 ?", "661 ?"
	     };
#endif	     
	     pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
	     pSiS->hasTwoOverlays = TRUE;
	     pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
#if 0
	     if(pSiS->sishw_ext.jChipType == SIS_661) {
		inSISIDXREG(SISCR, 0x5f, CR5F);
	        CR5F &= 0xf0;
		xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	      "SiS661FX revision ID %x (%s)\n", CR5F, id661str[CR5F >> 4]);
             }
#endif
	     break;
	   }
a2507 1
	     unsigned char tempreg1, tempreg2;
d2509 4
a2512 4
	   	"650",       "650",       "650",       "650",
		"650 A0 AA", "650 A2 CA", "650",       "650",
		"M650 A0",   "M650 A1 AA","651 A0 AA", "651 A1 AA",
		"M650",      "65?",       "651",       "65?"
d2514 7
a2520 66
	     pSiS->ChipFlags |= SiSCF_LARGEOVERLAY;
	     if(pSiS->sishw_ext.jChipType == SIS_650) {
		inSISIDXREG(SISCR, 0x5f, CR5F);
	        CR5F &= 0xf0;
	        andSISIDXREG(SISCR, 0x5c, 0x07);
		inSISIDXREG(SISCR, 0x5c, tempreg1);
		tempreg1 &= 0xf8;
		orSISIDXREG(SISCR, 0x5c, 0xf8);
		inSISIDXREG(SISCR, 0x5c, tempreg2);
		tempreg2 &= 0xf8;
		if((!tempreg1) || (tempreg2)) {
	           xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	      "SiS650 revision ID %x (%s)\n", CR5F, id650str[CR5F >> 4]);
	           if(CR5F & 0x80) {
	              pSiS->hasTwoOverlays = TRUE;  /* M650 or 651 */
		      pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
	           }
		   switch(CR5F) {
		      case 0xa0:
		      case 0xb0:
		      case 0xe0:
		         pSiS->ChipFlags |= SiSCF_Is651;
		         break;
		      case 0x80:
		      case 0x90:
		      case 0xc0:
		         pSiS->ChipFlags |= SiSCF_IsM650;
		         break;
		   }
		} else {
		   pSiS->hasTwoOverlays = TRUE;  
		   pSiS->SiS_SD_Flags |= SiS_SD_SUPPORT2OVL;
		   switch(CR5F) {
		      case 0x90:
		         inSISIDXREG(SISCR, 0x5c, tempreg1);
			 tempreg1 &= 0xf8;
			 switch(tempreg1) {
			    case 0x00:
			       pSiS->ChipFlags |= SiSCF_IsM652;
			       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	                   "SiSM652 revision ID %x\n", CR5F);
			       break;
			    case 0x40:
			       pSiS->ChipFlags |= SiSCF_IsM653;
			       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	                   "SiSM653 revision ID %x\n", CR5F);
			       break;
			    default:
			       pSiS->ChipFlags |= SiSCF_IsM650;
			       xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	                   "SiSM650 revision ID %x\n", CR5F);
			       break;
			 }
			 break;
		      case 0xb0:
		         pSiS->ChipFlags |= SiSCF_Is652;
			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	             "SiS652 revision ID %x\n", CR5F);
			 break;
		      default:
		         pSiS->ChipFlags |= SiSCF_IsM650;
			 xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	   	             "SiSM650 revision ID %x\n", CR5F);
			 break;
		   }
		}
d2531 1
a2531 1
    /* Backup VB connection and CRT1 on/off register */
d2533 3
a2535 10
       inSISIDXREG(SISSR, 0x1f, pSiS->oldSR1F);
       inSISIDXREG(SISCR, 0x17, pSiS->oldCR17);
       inSISIDXREG(SISCR, 0x32, pSiS->oldCR32);
       inSISIDXREG(SISCR, 0x36, pSiS->oldCR36);
       inSISIDXREG(SISCR, 0x37, pSiS->oldCR37);
       if(pSiS->VGAEngine == SIS_315_VGA) {
          inSISIDXREG(SISCR, pSiS->myCR63, pSiS->oldCR63);
       }

       pSiS->postVBCR32 = pSiS->oldCR32;
d2538 8
a2545 7
    /* There are some machines out there which require a special
     * setup of the GPIO registers in order to make the Chrontel
     * work. Try to find out if we're running on such a machine.
     * Furthermore, there is some highly customized hardware,
     * which requires some non-standard LVDS timing. Since the
     * vendors don't seem to care about PCI subsystem ID's we
     * need to find out using the BIOS version and date strings.
d2549 4
a2552 56
       int i = 0;
       do {
	  if(mychswtable[i].subsysVendor == pSiS->PciInfo->subsysVendor &&
	     mychswtable[i].subsysCard == pSiS->PciInfo->subsysCard) {
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	         "PCI subsystem ID found in list for Chrontel/GPIO setup\n");
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		 "Vendor/Card: %s %s (ID %04x)\n",
		  mychswtable[i].vendorName,
		  mychswtable[i].cardName,
		  pSiS->PciInfo->subsysCard);
	     pSiS->SiS_Pr->SiS_ChSW = TRUE;
	     break;
          }
          i++;
       } while(mychswtable[i].subsysVendor != 0);
    }

    if(pSiS->SiS_Pr->SiS_CustomT == CUT_NONE) {
       int i = 0, j;
       unsigned short bversptr = 0;
       BOOLEAN footprint;
       unsigned long chksum = 0;

       if(pSiS->sishw_ext.UseROM) {
          bversptr = pSiS->BIOS[0x16] | (pSiS->BIOS[0x17] << 8);
          for(i=0; i<32768; i++) chksum += pSiS->BIOS[i];
       }

       i = 0;
       do {
	  if( (mycustomttable[i].chipID == pSiS->sishw_ext.jChipType)                 &&
	      ((!strlen(mycustomttable[i].biosversion)) ||
	       (pSiS->sishw_ext.UseROM &&
	       (!strncmp(mycustomttable[i].biosversion, (char *)&pSiS->BIOS[bversptr],
	                strlen(mycustomttable[i].biosversion)))))                     &&
	      ((!strlen(mycustomttable[i].biosdate)) ||
	       (pSiS->sishw_ext.UseROM &&
	       (!strncmp(mycustomttable[i].biosdate, (char *)&pSiS->BIOS[0x2c],
	                strlen(mycustomttable[i].biosdate)))))			      &&
	      ((!mycustomttable[i].bioschksum) ||
	       (pSiS->sishw_ext.UseROM &&
	       (mycustomttable[i].bioschksum == chksum)))			      &&
	      (mycustomttable[i].pcisubsysvendor == pSiS->PciInfo->subsysVendor)      &&
	      (mycustomttable[i].pcisubsyscard == pSiS->PciInfo->subsysCard) ) {
	     footprint = TRUE;
	     for(j=0; j<5; j++) {
	        if(mycustomttable[i].biosFootprintAddr[j]) {
		   if(pSiS->sishw_ext.UseROM) {
	              if(pSiS->BIOS[mycustomttable[i].biosFootprintAddr[j]] !=
		      				mycustomttable[i].biosFootprintData[j])
		         footprint = FALSE;
		   } else footprint = FALSE;
	        }
	     }
	     if(footprint) {
d2554 8
a2561 8
	           "Identified %s %s, special timing applies\n",
		   mycustomttable[i].vendorName, mycustomttable[i].cardName);
	        pSiS->SiS_Pr->SiS_CustomT = mycustomttable[i].SpecialID;
	        break;
	     }
          }
          i++;
       } while(mycustomttable[i].chipID);
d2564 1
a2564 7
    /* Handle ForceCRT1 option */
    if(pSiS->forceCRT1 != -1) {
       if(pSiS->forceCRT1) pSiS->CRT1off = 0;
       else                pSiS->CRT1off = 1;
    } else                 pSiS->CRT1off = -1;

    /* Detect video bridge and sense TV/VGA2 */
d2566 1
a2566 2

    /* Detect CRT1 (via DDC1 and DDC2, hence via VGA port; regardless of LCDA) */
d2568 1
a2568 2

    /* Detect LCD (connected via CRT2, regardless of LCDA) and LCD resolution */
d2570 1
a2570 46

    /* LCDA only supported under these conditions: */
    if(pSiS->ForceCRT1Type == CRT1_LCDA) {
       if( ((pSiS->sishw_ext.jChipType != SIS_650) &&
            (pSiS->sishw_ext.jChipType < SIS_661))     ||
	   (!(pSiS->VBFlags & (VB_301C | VB_302B | VB_301LV | VB_302LV))) ) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	  	"Chipset/Video bridge does not support LCD-via-CRT1\n");
	  pSiS->ForceCRT1Type = CRT1_VGA;
       } else if(!(pSiS->VBFlags & CRT2_LCD)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	  	"No digitally connected LCD panel found, LCD-via-CRT1 disabled\n");
	  pSiS->ForceCRT1Type = CRT1_VGA;
       } else if(!(pSiS->VBLCDFlags & (VB_LCD_1024x768|VB_LCD_1280x1024|VB_LCD_1400x1050|VB_LCD_1600x1200))) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	  	"LCD-via-CRT1 not supported for this LCD resolution\n");
          pSiS->ForceCRT1Type = CRT1_VGA;
       }
    }

    /* Setup SD flags */
    pSiS->SiS_SD_Flags |= SiS_SD_ADDLSUPFLAG;

    if(pSiS->VBFlags & (VB_SISTVBRIDGE | VB_CHRONTEL)) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTTV;
    }

#ifdef ENABLE_YPBPR
    if((pSiS->VGAEngine == SIS_315_VGA) &&
       (pSiS->VBFlags & (VB_301C|VB_301LV|VB_302LV|VB_302ELV))) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTYPBPR;
       if((pSiS->Chipset == PCI_CHIP_SIS660) || (pSiS->VBFlags & VB_301C)) {
          pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTYPBPRAR;
       }
    }
    if(pSiS->VBFlags & (VB_301|VB_301B|VB_302B)) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTHIVISION;
    }
#endif

#ifdef TWDEBUG	/* @@@@@@ TEST @@@@@@ */
    pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTYPBPRAR;
    xf86DrvMsg(0, X_INFO, "TEST: Support Aspect Ratio\n");
#endif

    /* Detect CRT2-TV and PAL/NTSC mode */
d2572 1
a2572 2

    /* Detect CRT2-VGA */
d2575 2
a2576 52
    /* Backup detected CRT2 devices */
    pSiS->detectedCRT2Devices = pSiS->VBFlags & (CRT2_LCD|CRT2_TV|CRT2_VGA|TV_AVIDEO|TV_SVIDEO|TV_SCART|TV_HIVISION|TV_YPBPR);

    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPR)) {
       if((pSiS->ForceTVType != -1) && (pSiS->ForceTVType & TV_YPBPR)) {
          pSiS->ForceTVType = -1;
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "YPbPr TV output not supported\n");
       }
    }

    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTHIVISION)) {
       if((pSiS->ForceTVType != -1) && (pSiS->ForceTVType & TV_HIVISION)) {
          pSiS->ForceTVType = -1;
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "HiVision TV output not supported\n");
       }
    }

    if((pSiS->VBFlags & VB_SISTVBRIDGE) ||
       ((pSiS->VBFlags & VB_CHRONTEL) && (pSiS->ChrontelType == CHRONTEL_701x))) {
       pSiS->SiS_SD_Flags |= (SiS_SD_SUPPORTPALMN | SiS_SD_SUPPORTNTSCJ);
    }
    if((pSiS->VBFlags & VB_SISTVBRIDGE) ||
       ((pSiS->VBFlags & VB_CHRONTEL) && (pSiS->ChrontelType == CHRONTEL_700x))) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTTVPOS;
    }
    if(pSiS->VBFlags & (VB_301|VB_301B|VB_301C|VB_302B)) {
       pSiS->SiS_SD_Flags |= (SiS_SD_SUPPORTSCART | SiS_SD_SUPPORTVGA2);
    }
    if(pSiS->VBFlags & VB_CHRONTEL) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTOVERSCAN;
       if(pSiS->ChrontelType == CHRONTEL_700x) {
          pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTSOVER;
       }
    }

    if( ((pSiS->sishw_ext.jChipType == SIS_650) ||
         (pSiS->sishw_ext.jChipType >= SIS_661))                    &&
        (pSiS->VBFlags & (VB_301C | VB_302B | VB_301LV | VB_302LV)) &&
        (pSiS->VBFlags & CRT2_LCD) 			            &&
	(pSiS->VBLCDFlags & (VB_LCD_1024x768|VB_LCD_1280x1024|VB_LCD_1400x1050|VB_LCD_1600x1200)) &&
	(pSiS->VESA != 1) ) {
       pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTLCDA;
    } else {
       /* Paranoia */
       pSiS->ForceCRT1Type = CRT1_VGA;
    }

    pSiS->VBFlags |= pSiS->ForceCRT1Type;

#ifdef TWDEBUG
    xf86DrvMsg(0, X_INFO, "SDFlags %lx\n", pSiS->SiS_SD_Flags);
#endif
d2578 1
a2578 5
    /* Eventually overrule detected CRT2 type
     * If no type forced, use the detected devices in the order VGA2->TV->LCD
     * Since the Chrontel 7005 sometimes delivers wrong detection results,
     * we use a different order on such machines (LCD->TV)
     */
d2580 6
a2585 8
       if(pSiS->VBFlags & CRT2_VGA)
          pSiS->ForceCRT2Type = CRT2_VGA;
       else if((pSiS->VBFlags & CRT2_TV) && (!((pSiS->VBFlags & VB_CHRONTEL) && (pSiS->VGAEngine == SIS_300_VGA))))
          pSiS->ForceCRT2Type = CRT2_TV;
       else if((pSiS->VBFlags & CRT2_LCD) && (pSiS->ForceCRT1Type == CRT1_VGA))
          pSiS->ForceCRT2Type = CRT2_LCD;
       else if(pSiS->VBFlags & CRT2_TV)
	  pSiS->ForceCRT2Type = CRT2_TV;
d2589 36
a2624 32
       case CRT2_TV:
          pSiS->VBFlags &= ~(CRT2_LCD | CRT2_VGA);
          if(pSiS->VBFlags & (VB_SISTVBRIDGE | VB_CHRONTEL))
             pSiS->VBFlags |= CRT2_TV;
          else {
             pSiS->VBFlags &= ~(CRT2_TV);
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Hardware does not support TV output\n");
          }
          break;
       case CRT2_LCD:
          pSiS->VBFlags &= ~(CRT2_TV | CRT2_VGA);
          if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (pSiS->VBLCDFlags))
             pSiS->VBFlags |= CRT2_LCD;
          else {
             pSiS->VBFlags &= ~(CRT2_LCD);
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	    	"Can't force CRT2 to LCD, no LCD detected\n");
	  }
          break;
       case CRT2_VGA:
          pSiS->VBFlags &= ~(CRT2_TV | CRT2_LCD);
          if(pSiS->VBFlags & (VB_301|VB_301B|VB_301C|VB_302B))
	     pSiS->VBFlags |= CRT2_VGA;
	  else {
	     pSiS->VBFlags &= ~(CRT2_VGA);
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	         "Hardware does not support secondary VGA\n");
	  }
          break;
       default:
          pSiS->VBFlags &= ~(CRT2_TV | CRT2_LCD | CRT2_VGA);
d2627 6
a2632 50
#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (pSiS->SecondHead)) {
#endif
       xf86DrvMsg(pScrn->scrnIndex, pSiS->CRT1gammaGiven ? X_CONFIG : X_INFO,
       	     "CRT1 gamma correction is %s\n",
             pSiS->CRT1gamma ? "enabled" : "disabled");

       if((pSiS->VGAEngine == SIS_315_VGA) && (!(pSiS->NoXvideo))) {
          xf86DrvMsg(pScrn->scrnIndex, pSiS->XvGammaGiven ? X_CONFIG : X_INFO,
       		"Separate Xv gamma correction for CRT1 is %s\n",
		pSiS->XvGamma ? "enabled" : "disabled");
	  if(pSiS->XvGamma) {
	     xf86DrvMsg(pScrn->scrnIndex, pSiS->XvGammaGiven ? X_CONFIG : X_INFO,
	        "Xv gamma correction: %.3f %.3f %.3f\n",
		(float)((float)pSiS->XvGammaRed / 1000),
		(float)((float)pSiS->XvGammaGreen / 1000),
		(float)((float)pSiS->XvGammaBlue / 1000));
	     if(!pSiS->CRT1gamma) {
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		      "Separate Xv gamma corr. only effective if CRT1 gamma corr. is enabled\n");
	     }
	  }
       }
#ifdef SISDUALHEAD
    }
#endif

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if( (pSiS->VBFlags & VB_SISBRIDGE) &&
           (!((pSiS->VBFlags & VB_30xBDH) && (pSiS->VBFlags & CRT2_LCD))) ) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CRT2 gamma correction is %s\n",
		pSiS->CRT2gamma ? "enabled" : "disabled");
       }
    }

    /* Eventually overrule TV Type (SVIDEO, COMPOSITE, SCART, HIVISION, YPBPR) */
    if(pSiS->VBFlags & VB_SISTVBRIDGE) {
       if(pSiS->ForceTVType != -1) {
    	  pSiS->VBFlags &= ~(TV_INTERFACE);
	  if(!(pSiS->VBFlags & VB_CHRONTEL)) {
	     pSiS->VBFlags &= ~(TV_CHSCART | TV_CHYPBPR525I);
	  }
	  pSiS->VBFlags |= pSiS->ForceTVType;
	  if(pSiS->VBFlags & TV_YPBPR) {
	     pSiS->VBFlags &= ~(TV_STANDARD);
	     pSiS->VBFlags &= ~(TV_YPBPRAR);
	     pSiS->VBFlags |= pSiS->ForceYPbPrType;
	     pSiS->VBFlags |= pSiS->ForceYPbPrAR;
	  }
       }
d2635 1
a2635 1
    /* Handle ForceCRT1 option (part 2) */
a2638 2
       usScratchCR63 = pSiS->oldCR63;
       usScratchSR1F = pSiS->oldSR1F;
d2641 1
a2641 1
          /* Copy forceCRT1 option to CRT1off if option is given */
d2643 1
a2643 1
          /* In DHM, handle this option only for master head, not the slave */
d2653 1
a2653 5
		 if(pSiS->VGAEngine == SIS_300_VGA) {
		    if(!(usScratchCR17 & 0x80)) pSiS->CRT1changed = TRUE;
		 } else {
		    if(usScratchCR63 & 0x40) pSiS->CRT1changed = TRUE;
		 }
a2655 2
		 usScratchCR63 &= ~0x40;
		 usScratchSR1F &= ~0xc0;
d2658 2
a2659 2
		         ( (pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) ||
		           ((pSiS->VBFlags & VB_30xBDH) && (pSiS->VBFlags & CRT2_LCD)) ) ) ) {
d2661 1
a2661 5
		    if(pSiS->VGAEngine == SIS_300_VGA) {
		       if(usScratchCR17 & 0x80) pSiS->CRT1changed = TRUE;
		    } else {
		       if(!(usScratchCR63 & 0x40)) pSiS->CRT1changed = TRUE;
		    }
d2663 1
a2663 1
		    /* We must not actually switch off CRT1 before we changed the mode! */
a2665 3
	     /* Here we can write to CR17 even on 315 series as we only ENABLE
	      * the bit here
	      */
a2666 3
	     if(pSiS->VGAEngine == SIS_315_VGA) {
	        outSISIDXREG(SISCR, pSiS->myCR63, usScratchCR63);
	     }
a2674 1
	     outSISIDXREG(SISSR, 0x1f, usScratchSR1F);
d2677 1
a2677 1
       /* Store the new VB connection register contents for later mode changes */
d2681 5
a2685 5
    /* Check if CRT1 used (or needed; this eg. if no CRT2 detected) */
    if(pSiS->VBFlags & VB_VIDEOBRIDGE) {

        /* No CRT2 output? Then we NEED CRT1!
	 * We also need CRT1 if depth = 8 and bridge=LVDS|301B-DH
d2687 4
a2690 4
        if( (!(pSiS->VBFlags & (CRT2_VGA | CRT2_LCD | CRT2_TV))) ||
	    ( (pScrn->bitsPerPixel == 8) &&
	      ( (pSiS->VBFlags & (VB_LVDS | VB_CHRONTEL)) ||
	        ((pSiS->VBFlags & VB_30xBDH) && (pSiS->VBFlags & CRT2_LCD)) ) ) ) {
d2693 2
a2694 2
	/* No CRT2 output? Then we can't use Xv on CRT2 */
	if(!(pSiS->VBFlags & (CRT2_VGA | CRT2_LCD | CRT2_TV)))
d2697 1
a2697 1
    } else { /* no video bridge? */
d2705 17
a2721 13
    /* LCDA? Then we don't switch off CRT1 */
    if(pSiS->VBFlags & CRT1_LCDA) pSiS->CRT1off = 0;

    /* Handle TVStandard option */
    if((pSiS->NonDefaultPAL != -1) || (pSiS->NonDefaultNTSC != -1)) {
       if( (!(pSiS->VBFlags & VB_SISTVBRIDGE)) &&
	   (!((pSiS->VBFlags & VB_CHRONTEL)) && (pSiS->ChrontelType == CHRONTEL_701x)) ) {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	   	"PALM, PALN and NTSCJ not supported on this hardware\n");
 	  pSiS->NonDefaultPAL = pSiS->NonDefaultNTSC = -1;
	  pSiS->VBFlags &= ~(TV_PALN | TV_PALM | TV_NTSCJ);
	  pSiS->SiS_SD_Flags &= ~(SiS_SD_SUPPORTPALMN | SiS_SD_SUPPORTNTSCJ);
       }
d2724 16
a2739 21
       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	  if( (!((pSiS->VBFlags & VB_CHRONTEL) && (pSiS->VBFlags & (TV_CHSCART | TV_CHYPBPR525I)))) &&
	      (!(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR))) ) {
    	     pSiS->VBFlags &= ~(TV_PAL | TV_NTSC | TV_PALN | TV_PALM | TV_NTSCJ);
    	     if(pSiS->OptTVStand) {
	        pSiS->VBFlags |= TV_PAL;
	        if(pSiS->NonDefaultPAL == 1)  pSiS->VBFlags |= TV_PALM;
	        else if(!pSiS->NonDefaultPAL) pSiS->VBFlags |= TV_PALN;
	     } else {
	        pSiS->VBFlags |= TV_NTSC;
		if(pSiS->NonDefaultNTSC == 1) pSiS->VBFlags |= TV_NTSCJ;
	     }
	  } else {
	     pSiS->OptTVStand = pSiS->NonDefaultPAL = -1;
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	    	 "Option TVStandard ignored for YPbPr, HiVision and Chrontel-SCART\n");
	  }
       } else if(pSiS->Chipset == PCI_CHIP_SIS6326) {
	  pSiS->SiS6326Flags &= ~SIS6326_TVPAL;
	  if(pSiS->OptTVStand) pSiS->SiS6326Flags |= SIS6326_TVPAL;
       }
d2742 1
a2742 27
    /* SCART only supported for PAL */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if((pSiS->VBFlags & VB_SISBRIDGE) && (pSiS->VBFlags & TV_SCART)) {
	  pSiS->VBFlags &= ~(TV_NTSC | TV_PALN | TV_PALM | TV_NTSCJ);
	  pSiS->VBFlags |= TV_PAL;
	  pSiS->OptTVStand = 1;
	  pSiS->NonDefaultPAL = pSiS->NonDefaultNTSC = -1;
       }
    }

#ifdef SIS_CP
    SIS_CP_DRIVER_RECONFIGOPT
#endif

    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
       if(pSiS->sis6326tvplug != -1) {
          pSiS->SiS6326Flags &= ~(SIS6326_TVSVIDEO | SIS6326_TVCVBS);
	  pSiS->SiS6326Flags |= SIS6326_TVDETECTED;
	  if(pSiS->sis6326tvplug == 1) 	pSiS->SiS6326Flags |= SIS6326_TVCVBS;
	  else 				pSiS->SiS6326Flags |= SIS6326_TVSVIDEO;
	  xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	  	"SiS6326 TV plug type detection overruled by %s\n",
		(pSiS->SiS6326Flags & SIS6326_TVCVBS) ? "COMPOSITE" : "SVIDEO");
       }
    }

    /* Do some checks */
d2744 7
a2750 7
       if(pSiS->VBFlags & VB_CHRONTEL) {
	  pSiS->UseCHOverScan = pSiS->OptTVOver;
       } else {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	    	"CHTVOverscan only supported on CHRONTEL 70xx\n");
          pSiS->UseCHOverScan = -1;
       }
d2752 1
a2752 1

d2754 5
a2758 24
       if(!(pSiS->VBFlags & VB_301)) {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "SISTVEdgeEnhance only supported on SiS301\n");
	  pSiS->sistvedgeenhance = -1;
       }
    }
    if(pSiS->sistvsaturation != -1) {
       if(pSiS->VBFlags & VB_301) {
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "SISTVSaturation not supported on SiS301\n");
	  pSiS->sistvsaturation = -1;
       }
    }

    /* Do some MergedFB mode initialisation */
#ifdef SISMERGED
    if(pSiS->MergedFB) {
       pSiS->CRT2pScrn = xalloc(sizeof(ScrnInfoRec));
       if(!pSiS->CRT2pScrn) {
          SISErrorLog(pScrn, "Failed to allocate memory for 2nd pScrn, %s\n", mergeddisstr);
	  pSiS->MergedFB = FALSE;
       } else {
          memcpy(pSiS->CRT2pScrn, pScrn, sizeof(ScrnInfoRec));
       }
a2759 1
#endif
d2761 1
a2761 2

    /* Determine CRT1<>CRT2 mode
d2768 1
a2768 1
        if(pSiS->CRT1off) {	/* CRT2 only ------------------------------- */
d2771 1
a2771 1
	     	SISErrorLog(pScrn,
a2775 1
		pSiS->pInt = NULL;
a2780 12
#ifdef SISMERGED
	     if(pSiS->MergedFB) {
	        if(pSiS->MergedFBAuto) {
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, mergednocrt1, mergeddisstr);
		} else {
	     	   SISErrorLog(pScrn, mergednocrt1, mergeddisstr);
		}
		if(pSiS->CRT2pScrn) xfree(pSiS->CRT2pScrn);
		pSiS->CRT2pScrn = NULL;
		pSiS->MergedFB = FALSE;
	     }
#endif
d2782 1
a2782 1
	     /* No CRT1? Then we use the video overlay on CRT2 */
d2784 1
a2784 1
	} else			/* CRT1 and CRT2 - mirror or dual head ----- */
d2792 1
a2792 1
		if(pSiSEnt) pSiSEnt->DisableDual = FALSE;
a2795 10
#ifdef SISMERGED
	            if(pSiS->MergedFB) {
		 pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_CRT1);
		 if(pSiS->VESA != -1) {
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"VESA option not used in MergedFB mode. VESA disabled.\n");
		 }
		 pSiS->VESA = 0;
	     } else
#endif
d2797 1
a2797 1
    } else {			/* CRT1 only ------------------------------- */
d2800 1
a2800 1
	     	SISErrorLog(pScrn,
a2804 1
		pSiS->pInt = NULL;
a2809 12
#ifdef SISMERGED
	     if(pSiS->MergedFB) {
	        if(pSiS->MergedFBAuto) {
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, mergednocrt2, mergeddisstr);
		} else {
	     	   SISErrorLog(pScrn, mergednocrt2, mergeddisstr);
		}
		if(pSiS->CRT2pScrn) xfree(pSiS->CRT2pScrn);
		pSiS->CRT2pScrn = NULL;
		pSiS->MergedFB = FALSE;
	     }
#endif
d2813 7
a2819 5
    if((pSiS->VGAEngine == SIS_315_VGA) || (pSiS->VGAEngine == SIS_300_VGA)) {
       if((!pSiS->NoXvideo) && (!pSiS->hasTwoOverlays)) {
	  xf86DrvMsg(pScrn->scrnIndex, from,
	      "Using Xv overlay by default on CRT%d\n",
	      pSiS->XvOnCRT2 ? 2 : 1);
d2823 1
a2823 1
    /* Init Ptrs for Save/Restore functions and calc MaxClock */
d2828 1
a2828 1
    /* VBFlags are initialized now. Back them up for SlaveMode modes. */
d2831 24
a2854 23
    /* Backup CR32,36,37 (in order to write them back after a VT switch) */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       inSISIDXREG(SISCR,0x32,pSiS->myCR32);
       inSISIDXREG(SISCR,0x36,pSiS->myCR36);
       inSISIDXREG(SISCR,0x37,pSiS->myCR37);
    }

    /* Find out about paneldelaycompensation and evaluate option */
#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead)) {
#endif
       if(pSiS->VGAEngine == SIS_300_VGA) {

          if(pSiS->VBFlags & (VB_LVDS | VB_30xBDH)) {
	  
	     /* Save the current PDC if the panel is used at the moment.
	      * This seems by far the safest way to find out about it.
	      * If the system is using an old version of sisfb, we can't
	      * trust the pdc register value. If sisfb saved the pdc for
	      * us, use it.
	      */
	     if(pSiS->sisfbpdc) {
	        pSiS->SiS_Pr->PDC = pSiS->sisfbpdc;
d2856 2
a2857 19
	        if(!(pSiS->donttrustpdc)) {
	           unsigned char tmp;
	           inSISIDXREG(SISCR, 0x30, tmp);
	           if(tmp & 0x20) {
	              inSISIDXREG(SISPART1, 0x13, pSiS->SiS_Pr->PDC);
                   } else {
	             xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	          "Unable to detect LCD PanelDelayCompensation, LCD is not active\n");
	           }
	        } else {
	           xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	        "Unable to detect LCD PanelDelayCompensation, please update sisfb\n");
	        }
	     }
	     if(pSiS->SiS_Pr->PDC != -1) {
	        pSiS->SiS_Pr->PDC &= 0x3c;
	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	       	     "Detected LCD PanelDelayCompensation 0x%02x\n",
		     pSiS->SiS_Pr->PDC);
d2859 10
d2870 8
a2877 10
	     /* If we haven't been able to find out, use our other methods */
	     if(pSiS->SiS_Pr->PDC == -1) {
                int i=0;
                do {
	           if(mypdctable[i].subsysVendor == pSiS->PciInfo->subsysVendor &&
	              mypdctable[i].subsysCard == pSiS->PciInfo->subsysCard) {
	                 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	   	            "PCI card/vendor identified for non-default PanelDelayCompensation\n");
		         xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
		             "Vendor: %s, card: %s (ID %04x), PanelDelayCompensation: 0x%02x\n",
d2880 4
a2883 4
                         if(pSiS->PDC == -1) {
		            pSiS->PDC = mypdctable[i].pdc;
		         } else {
		            xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
d2885 7
a2891 6
		         }
	                 break;
                   }
	           i++;
                } while(mypdctable[i].subsysVendor != 0);
             }
d2893 6
a2898 6
	     if(pSiS->PDC != -1) {
	        if(pSiS->BIOS) {
	           if(pSiS->VBFlags & VB_LVDS) {
	              if(pSiS->BIOS[0x220] & 0x80) {
                         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		             "BIOS contains custom LCD Panel Delay Compensation 0x%02x\n",
d2900 7
a2906 7
	                 pSiS->BIOS[0x220] &= 0x7f;
		      }
	           }
	           if(pSiS->VBFlags & (VB_301B|VB_302B)) {
	              if(pSiS->BIOS[0x220] & 0x80) {
                         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		             "BIOS contains custom LCD Panel Delay Compensation 0x%02x\n",
d2909 9
a2917 86
	                 pSiS->BIOS[0x220] &= 0x7f;
		      }
		   }
	        }
	        pSiS->SiS_Pr->PDC = (pSiS->PDC & 0x3c);
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	              "Using LCD Panel Delay Compensation 0x%02x\n", pSiS->SiS_Pr->PDC);
	     }
	  }

       }  /* SIS_300_VGA */

       if(pSiS->VGAEngine == SIS_315_VGA) {

          unsigned char tmp;
	  inSISIDXREG(SISCR, 0x30, tmp);

          if(pSiS->VBFlags & (VB_301LV | VB_302LV | VB_302ELV)) {
	     /* Save the current PDC if the panel is used at the moment.
	      * This seems by far the safest way to find out about it.
	      */
	     if(pSiS->sisfbpdc) {
	        pSiS->SiS_Pr->PDC = pSiS->sisfbpdc;
	     } else {
	        if(!(pSiS->donttrustpdc)) {
	           if(tmp & 0x20) {
	              inSISIDXREG(SISPART1, 0x2D, pSiS->SiS_Pr->PDC);
                   } else {
	              xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	          "Unable to detect LCD PanelDelayCompensation, LCD is not active\n");
	           }
	        } else {
	           xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	       "Unable to detect LCD PanelDelayCompensation, please update sisfb\n");
	        }
	     }
	     if(pSiS->SiS_Pr->PDC != -1) {
	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      	     "Detected LCD PanelDelayCompensation 0x%02x\n",
		     pSiS->SiS_Pr->PDC);
	     }
	     if(pSiS->PDC != -1) {
	        pSiS->SiS_Pr->PDC = pSiS->PDC & 0xff;
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	      	     "Using LCD PanelDelayCompensation 0x%02x\n",
		     pSiS->SiS_Pr->PDC);
	     }
          }

 	  /* Read the current EMI (if not overruled) */
	  if(pSiS->VBFlags & (VB_302LV | VB_302ELV)) {
	     MessageType from = X_PROBED;
	     if(pSiS->EMI != -1) {
	        pSiS->SiS_Pr->EMI_30 = (pSiS->EMI >> 24) & 0x60;
	        pSiS->SiS_Pr->EMI_31 = (pSiS->EMI >> 16) & 0xff;
	        pSiS->SiS_Pr->EMI_32 = (pSiS->EMI >> 8)  & 0xff;
	        pSiS->SiS_Pr->EMI_33 = pSiS->EMI & 0xff;
		pSiS->SiS_Pr->HaveEMI = pSiS->SiS_Pr->HaveEMILCD = TRUE;
		pSiS->SiS_Pr->OverruleEMI = TRUE;
		from = X_CONFIG;
	     } else if((pSiS->sisfbfound) && (pSiS->sisfb_haveemi)) {
	        pSiS->SiS_Pr->EMI_30 = pSiS->sisfb_emi30;
	        pSiS->SiS_Pr->EMI_31 = pSiS->sisfb_emi31;
	        pSiS->SiS_Pr->EMI_32 = pSiS->sisfb_emi32;
	        pSiS->SiS_Pr->EMI_33 = pSiS->sisfb_emi33;
		pSiS->SiS_Pr->HaveEMI = TRUE;
		if(pSiS->sisfb_haveemilcd) pSiS->SiS_Pr->HaveEMILCD = TRUE;
		pSiS->SiS_Pr->OverruleEMI = FALSE;
	     } else {
	        inSISIDXREG(SISPART4, 0x30, pSiS->SiS_Pr->EMI_30);
		inSISIDXREG(SISPART4, 0x31, pSiS->SiS_Pr->EMI_31);
		inSISIDXREG(SISPART4, 0x32, pSiS->SiS_Pr->EMI_32);
		inSISIDXREG(SISPART4, 0x33, pSiS->SiS_Pr->EMI_33);
		pSiS->SiS_Pr->HaveEMI = TRUE;
		if(tmp & 0x20) pSiS->SiS_Pr->HaveEMILCD = TRUE;
		pSiS->SiS_Pr->OverruleEMI = FALSE;
	     }
	     xf86DrvMsg(pScrn->scrnIndex, from,
	     	   "302LV/302ELV: Using EMI 0x%02x%02x%02x%02x%s\n",
		   pSiS->SiS_Pr->EMI_30,pSiS->SiS_Pr->EMI_31,
		   pSiS->SiS_Pr->EMI_32,pSiS->SiS_Pr->EMI_33,
		   pSiS->SiS_Pr->HaveEMILCD ? " (LCD)" : "");
	  }

       } /* SIS_315_VGA */
#ifdef SISDUALHEAD
a2918 1
#endif
d2921 4
a2924 4
    /* In dual head mode, both heads (currently) share the maxxfbmem equally.
     * If memory sharing is done differently, the following has to be changed;
     * the other modules (eg. accel and Xv) use dhmOffset for hardware
     * pointer settings relative to VideoRAM start and won't need to be changed.
d2926 2
a2927 2
    if(pSiS->DualHeadMode) {
        if(pSiS->SecondHead == FALSE) {
d2939 1
a2939 1
	    		"%ldKB video RAM at 0x%lx available for master head (CRT2)\n",
d2950 1
a2950 1
	    		"%ldKB video RAM at 0x%lx available for slave head (CRT1)\n",
d2957 3
a2959 3
    /* Note: Do not use availMem for anything from now. Use
     * maxxfbmem instead. (availMem does not take dual head
     * mode into account.)
d2962 6
a2967 22
    pSiS->DRIheapstart = pSiS->maxxfbmem;
    pSiS->DRIheapend = pSiS->availMem;
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       pSiS->DRIheapstart = pSiS->DRIheapend = 0;
    } else
#endif
    if(pSiS->DRIheapstart == pSiS->DRIheapend) {
#if 0  /* For future use */
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
       	  "No memory for DRI heap. Please set the option \"MaxXFBMem\" to\n"
	  "\tlimit the memory XFree should use and leave the rest to DRI\n");
#endif
       pSiS->DRIheapstart = pSiS->DRIheapend = 0;
    }

    /* Now for something completely different: DDC.
     * For 300 and 315/330 series, we provide our
     * own functions (in order to probe CRT2 as well)
     * If these fail, use the VBE.
     * All other chipsets will use VBE. No need to re-invent
     * the wheel there.
d2974 1
a2974 2
       if(xf86LoadSubModule(pScrn, "ddc")) {
          int crtnum = 0;
d2976 1
a2976 1
	  if((pMonitor = SiSDoPrivateDDC(pScrn, &crtnum))) {
d2978 2
a2979 1
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcsstr, crtnum);
d2981 2
a2982 1
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcestr, crtnum);
d2986 1
a2986 1
       }
d2990 1
a2990 1
    /* In dual head mode, probe DDC using VBE only for CRT1 (second head) */
d2995 2
a2996 5
    if(!didddc2) {
       /* If CRT1 is off or LCDA, skip DDC via VBE */
       if((pSiS->CRT1off) || (pSiS->VBFlags & CRT1_LCDA))
          didddc2 = TRUE;
    }
d2998 1
a2998 1
    /* Now (re-)load and initialize the DDC module */
d3005 1
a3005 1
          /* Now load and initialize VBE module. */
d3026 1
a3026 1
	   	      "VBE CRT1 DDC monitor info:\n");
d3029 1
a3029 1
	   	      "End of VBE CRT1 DDC monitor info:\n");
d3039 4
a3042 98
#ifdef SISMERGED
    if(pSiS->MergedFB) {
       pSiS->CRT2pScrn->monitor = xalloc(sizeof(MonRec));
       if(pSiS->CRT2pScrn->monitor) {
          DisplayModePtr tempm = NULL, currentm = NULL, newm = NULL;
          memcpy(pSiS->CRT2pScrn->monitor, pScrn->monitor, sizeof(MonRec));
          pSiS->CRT2pScrn->monitor->DDC = NULL;
	  pSiS->CRT2pScrn->monitor->Modes = NULL;
	  tempm = pScrn->monitor->Modes;
	  while(tempm) {
	     if(!(newm = xalloc(sizeof(DisplayModeRec)))) break;
	     memcpy(newm, tempm, sizeof(DisplayModeRec));
	     if(!(newm->name = xalloc(strlen(tempm->name) + 1))) {
	        xfree(newm);
		break;
	     }
	     strcpy(newm->name, tempm->name);
	     if(!pSiS->CRT2pScrn->monitor->Modes) pSiS->CRT2pScrn->monitor->Modes = newm;
	     if(currentm) {
	        currentm->next = newm;
		newm->prev = currentm;
	     }
	     currentm = newm;
	     tempm = tempm->next;
	  }
          if(pSiS->CRT2HSync) {
             pSiS->CRT2pScrn->monitor->nHsync =
	    	SiSStrToRanges(pSiS->CRT2pScrn->monitor->hsync, pSiS->CRT2HSync, MAX_HSYNC);
          }
          if(pSiS->CRT2VRefresh) {
             pSiS->CRT2pScrn->monitor->nVrefresh =
	    	SiSStrToRanges(pSiS->CRT2pScrn->monitor->vrefresh, pSiS->CRT2VRefresh, MAX_VREFRESH);
          }
	  if((pMonitor = SiSInternalDDC(pSiS->CRT2pScrn, 1))) {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcsstr, 2);
	     xf86PrintEDID(pMonitor);
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED, ddcestr, 2);
	     xf86SetDDCproperties(pSiS->CRT2pScrn, pMonitor);
	     pSiS->CRT2pScrn->monitor->DDC = pMonitor;
	     /* use DDC data if no ranges in config file */
	     if(!pSiS->CRT2HSync) {
	        pSiS->CRT2pScrn->monitor->nHsync = 0;
	     }
	     if(!pSiS->CRT2VRefresh) {
	        pSiS->CRT2pScrn->monitor->nVrefresh = 0;
	     }
          } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	     	"Failed to read DDC data for CRT2\n");
	  }
       } else {
          SISErrorLog(pScrn, "Failed to allocate memory for CRT2 monitor, %s.\n",
	  		mergeddisstr);
	  if(pSiS->CRT2pScrn) xfree(pSiS->CRT2pScrn);
    	  pSiS->CRT2pScrn = NULL;
	  pSiS->MergedFB = FALSE;
       }
    }
#endif

    /* If there is no HSync or VRefresh data for the monitor,
     * derive it from DDC data. Done by common layer since
     * 4.3.99.14.
     */
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,14,0)
    if(pScrn->monitor->DDC) {
       if(pScrn->monitor->nHsync <= 0) {
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, subshstr,
#ifdef SISDUALHEAD
			pSiS->DualHeadMode ? (pSiS->SecondHead ? 1 : 2) :
#endif
		 		pSiS->CRT1off ? 2 : 1);
         SiSSetSyncRangeFromEdid(pScrn, 1);
       }
       if(pScrn->monitor->nVrefresh <= 0) {
         xf86DrvMsg(pScrn->scrnIndex, X_INFO, subsvstr,
#ifdef SISDUALHEAD
			pSiS->DualHeadMode ? (pSiS->SecondHead ? 1 : 2) :
#endif
		  		pSiS->CRT1off ? 2 : 1);
         SiSSetSyncRangeFromEdid(pScrn, 0);
       }
    }
#endif

#ifdef SISMERGED
    if(pSiS->MergedFB) {
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,3,99,14,0)
       if(pSiS->CRT2pScrn->monitor->DDC) {
          if(pSiS->CRT2pScrn->monitor->nHsync <= 0) {
             xf86DrvMsg(pScrn->scrnIndex, X_INFO, subshstr, 2);
             SiSSetSyncRangeFromEdid(pSiS->CRT2pScrn, 1);
          }
          if(pSiS->CRT2pScrn->monitor->nVrefresh <= 0) {
             xf86DrvMsg(pScrn->scrnIndex, X_INFO, subsvstr, 2);
             SiSSetSyncRangeFromEdid(pSiS->CRT2pScrn, 0);
          }
       }
a3044 3
       xf86DrvMsg(pScrn->scrnIndex, X_INFO, crtsetupstr, 1);
    }
#endif
a3046 2
    /* From here, we mainly deal with clocks and modes */

d3048 1
a3048 4
    pSiS->MinClock = 5000;
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       pSiS->MinClock = 12000;
    }
d3094 16
d3111 5
a3115 7
     * Since we have lots of built-in modes for 300/315/330 series
     * with vb support, we replace the given default mode list with our
     * own. In case the video bridge is to be used, we only allow other
     * modes if
     *   -) vbtype is 301, 301B, 301C or 302B, and
     *   -) crt2 device is not TV, and
     *   -) crt1 is not LCDA
d3117 2
d3120 2
a3121 8
       if(!(pSiS->noInternalModes)) {
          BOOLEAN acceptcustommodes = TRUE;
	  BOOLEAN includelcdmodes   = TRUE;
	  BOOLEAN isfordvi          = FALSE;
          if(pSiS->UseVESA) {
	     acceptcustommodes = FALSE;
	     includelcdmodes   = FALSE;
	  }
d3123 35
a3157 46
          if(pSiS->DualHeadMode) {
	     if(!pSiS->SecondHead) {
	        if((pSiS->VBFlags & (VB_301|VB_301B|VB_301C|VB_302B)) && (!(pSiS->VBFlags & VB_30xBDH))) {
		   if(!(pSiS->VBFlags & (CRT2_LCD|CRT2_VGA))) includelcdmodes   = FALSE;
		   if(pSiS->VBFlags & CRT2_LCD)               isfordvi          = TRUE;
		   if(pSiS->VBFlags & CRT2_TV)                acceptcustommodes = FALSE;
		} else {
		   acceptcustommodes = FALSE;
		   includelcdmodes   = FALSE;
		}
		clockRanges->interlaceAllowed = FALSE;
	     } else {
	        includelcdmodes = FALSE;
		if(pSiS->VBFlags & CRT1_LCDA) {
		   acceptcustommodes = FALSE;
		   /* Ignore interlace, mode switching code will handle this */
		}
	     }
	  } else
#endif
#ifdef SISMERGED
          if(pSiS->MergedFB) {
	     includelcdmodes = FALSE;
	     if(pSiS->VBFlags & CRT1_LCDA) {
		acceptcustommodes = FALSE;
		/* Ignore interlace, mode switching code will handle this */
	     }
          } else
#endif
          if((pSiS->VBFlags & (VB_301|VB_301B|VB_301C|VB_302B))  && (!(pSiS->VBFlags & VB_30xBDH))) {
	     if(!(pSiS->VBFlags & (CRT2_LCD|CRT2_VGA))) includelcdmodes   = FALSE;
	     if(pSiS->VBFlags & CRT2_LCD)               isfordvi          = TRUE;
	     if(pSiS->VBFlags & (CRT2_TV|CRT1_LCDA))    acceptcustommodes = FALSE;
	  } else if(pSiS->VBFlags & (CRT2_ENABLE | CRT1_LCDA)) {
	     acceptcustommodes = FALSE;
	     includelcdmodes   = FALSE;
	  } else {
	     includelcdmodes   = FALSE;
	  }
	  /* Ignore interlace, mode switching code will handle this */

	  pSiS->HaveCustomModes = FALSE;
          if(SiSMakeOwnModeList(pScrn, acceptcustommodes, includelcdmodes, isfordvi, &pSiS->HaveCustomModes)) {
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	         "Replaced %s mode list with built-in modes\n",
	     pSiS->HaveCustomModes ? "default" : "entire");
d3159 6
a3164 6
             pScrn->modes = pScrn->monitor->Modes;
	     xf86PrintModes(pScrn);
	     pScrn->modes = NULL;
#endif
          } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
d3166 2
a3167 4
	  }
       } else {
          pSiS->HaveCustomModes = TRUE;
       }
d3171 1
a3171 1
     * Add our built-in modes for TV on the 6326
d3174 2
a3175 2
       if(pSiS->SiS6326Flags & SIS6326_TVDETECTED) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d3178 12
a3189 12
          if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
             SiS6326PAL800x600Mode.next = pScrn->monitor->Modes;
             pScrn->monitor->Modes = &SiS6326PAL640x480Mode;
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	     	"\t\"PAL800x600\" \"PAL800x600U\" \"PAL720x540\" \"PAL640x480\"\n");
	  } else {
	     SiS6326NTSC640x480Mode.next = pScrn->monitor->Modes;
             pScrn->monitor->Modes = &SiS6326NTSC640x400Mode;
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	     	"\t\"NTSC640x480\" \"NTSC640x480U\" \"NTSC640x400\"\n");
	  }
       }
d3193 1
a3193 1
     * Add our built-in hi-res modes on the 6326
d3226 2
a3227 1
     * Assuming min pitch 256, min height 128
d3229 4
a3232 28
    {
       int minpitch, maxpitch, minheight, maxheight;
       minpitch = 256;
       minheight = 128;
       switch(pSiS->VGAEngine) {
       case SIS_OLD_VGA:
       case SIS_530_VGA:
          maxpitch = 2040;
          maxheight = 2048;
          break;
       case SIS_300_VGA:
       case SIS_315_VGA:
          maxpitch = 4088;
          maxheight = 4096;
          break;
       default:
          maxpitch = 2048;
          maxheight = 2048;
          break;
       }
#ifdef SISMERGED
       pSiS->CheckForCRT2 = FALSE;
#endif
       i = xf86ValidateModes(pScrn, pScrn->monitor->Modes,
                      pScrn->display->modes, clockRanges, NULL,
                      minpitch, maxpitch,
                      pScrn->bitsPerPixel * 8,
		      minheight, maxheight,
a3236 1
    }
d3239 2
a3240 1
        SISErrorLog(pScrn, "xf86ValidateModes() error\n");
d3250 5
a3254 23
    /* Check the virtual screen against the available memory */
    {
       unsigned long memreq = (pScrn->virtualX * ((pScrn->bitsPerPixel + 7) / 8)) * pScrn->virtualY;

       if(memreq > pSiS->maxxfbmem) {
          SISErrorLog(pScrn,
       		"Virtual screen too big for memory; %ldK needed, %ldK available\n",
		memreq/1024, pSiS->maxxfbmem/1024);
#ifdef SISDUALHEAD
          if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
          if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
          pSiS->pInt = NULL;
          sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
          SISFreeRec(pScrn);
          return FALSE;
       }
    }

    /* Dual Head:
     * -) Go through mode list and mark all those modes as bad,
     *    which are unsuitable for dual head mode.
     * -) Find the highest used pixelclock on the master head.
d3258 1
a3258 34

       if(!pSiS->SecondHead) {

          pSiSEnt->maxUsedClock = 0;

          if((p = first = pScrn->modes)) {
             do {
	        n = p->next;

	        /* Modes that require the bridge to operate in SlaveMode
                 * are not suitable for Dual Head mode.
                 */
	        if( (pSiS->VGAEngine == SIS_300_VGA) &&
		    ( (strcmp(p->name, "320x200") == 0) ||
		      (strcmp(p->name, "320x240") == 0) ||
		      (strcmp(p->name, "400x300") == 0) ||
		      (strcmp(p->name, "512x384") == 0) ||
		      (strcmp(p->name, "640x400") == 0) ) )  {
	    	   p->status = MODE_BAD;
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, notsuitablestr, p->name, "dual head");
		}

		/* Search for the highest clock on first head in order to calculate
	         * max clock for second head (CRT1)
	         */
		if((p->status == MODE_OK) && (p->Clock > pSiSEnt->maxUsedClock)) {
		   pSiSEnt->maxUsedClock = p->Clock;
		}

	        p = n;

             } while (p != NULL && p != first);
	  }
       }
d3261 106
d3372 1
a3372 1
        SISErrorLog(pScrn, "No valid modes found\n");
d3387 1
a3387 1
    /* Copy to CurrentLayout */
a3390 6
#ifdef SISMERGED
    if(pSiS->MergedFB) {
       xf86DrvMsg(pScrn->scrnIndex, X_INFO, modesforstr, 1);
    }
#endif

d3394 10
a3403 142
#ifdef SISMERGED
    if(pSiS->MergedFB) {
       BOOLEAN acceptcustommodes = TRUE;
       BOOLEAN includelcdmodes   = TRUE;
       BOOLEAN isfordvi          = FALSE;

       xf86DrvMsg(pScrn->scrnIndex, X_INFO, crtsetupstr, 2);

       clockRanges->next = NULL;
       clockRanges->minClock = pSiS->MinClock;
       clockRanges->maxClock = SiSMemBandWidth(pSiS->CRT2pScrn, TRUE);
       clockRanges->clockIndex = -1;
       clockRanges->interlaceAllowed = FALSE;
       clockRanges->doubleScanAllowed = FALSE;
       if(pSiS->VGAEngine == SIS_315_VGA) {
          clockRanges->doubleScanAllowed = TRUE;
       }

       xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Min pixel clock for CRT2 is %d MHz\n",
                clockRanges->minClock / 1000);
       xf86DrvMsg(pScrn->scrnIndex, X_DEFAULT, "Max pixel clock for CRT2 is %d MHz\n",
                clockRanges->maxClock / 1000);

       if((pSiS->VBFlags & (VB_301|VB_301B|VB_301C|VB_302B)) && (!(pSiS->VBFlags & VB_30xBDH))) {
          if(!(pSiS->VBFlags & (CRT2_LCD|CRT2_VGA))) includelcdmodes   = FALSE;
	  if(pSiS->VBFlags & CRT2_LCD)               isfordvi          = TRUE;
	  if(pSiS->VBFlags & CRT2_TV)                acceptcustommodes = FALSE;
       } else {
          includelcdmodes   = FALSE;
	  acceptcustommodes = FALSE;
       }

       pSiS->HaveCustomModes2 = FALSE;
       if(!SiSMakeOwnModeList(pSiS->CRT2pScrn, acceptcustommodes, includelcdmodes, isfordvi, &pSiS->HaveCustomModes2)) {

	  SISErrorLog(pScrn, "Building list of built-in modes for CRT2 failed, %s\n",
	  			mergeddisstr);
	  SiSFreeCRT2Structs(pSiS);
	  pSiS->MergedFB = FALSE;

       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	         "Replaced %s mode list for CRT2 with built-in modes\n",
	         pSiS->HaveCustomModes2 ? "default" : "entire");
       }

    }

    if(pSiS->MergedFB) {

       pSiS->CheckForCRT2 = TRUE;
       i = xf86ValidateModes(pSiS->CRT2pScrn, pSiS->CRT2pScrn->monitor->Modes,
                      pSiS->CRT2pScrn->display->modes, clockRanges,
                      NULL, 256, 4088,
                      pSiS->CRT2pScrn->bitsPerPixel * 8, 128, 4096,
                      pScrn->display->virtualX ? pScrn->virtualX : 0,
                      pScrn->display->virtualY ? pScrn->virtualY : 0,
                      pSiS->maxxfbmem,
                      LOOKUP_BEST_REFRESH);
       pSiS->CheckForCRT2 = FALSE;

       if(i == -1) {
          SISErrorLog(pScrn, "xf86ValidateModes() error, %s.\n", mergeddisstr);
	  SiSFreeCRT2Structs(pSiS);
          pSiS->MergedFB = FALSE;
       }

    }

    if(pSiS->MergedFB) {

       if((p = first = pSiS->CRT2pScrn->modes)) {
          do {
	     n = p->next;
	     if( (pSiS->VGAEngine == SIS_300_VGA) &&
		 ( (strcmp(p->name, "320x200") == 0) ||
		   (strcmp(p->name, "320x240") == 0) ||
		   (strcmp(p->name, "400x300") == 0) ||
		   (strcmp(p->name, "512x384") == 0) ||
		   (strcmp(p->name, "640x400") == 0) ) )  {
	    	p->status = MODE_BAD;
		xf86DrvMsg(pScrn->scrnIndex, X_INFO, notsuitablestr, p->name, "MergedFB");
	     }
	     p = n;
	  } while (p != NULL && p != first);
       }

       xf86PruneDriverModes(pSiS->CRT2pScrn);

       if(i == 0 || pSiS->CRT2pScrn->modes == NULL) {
          SISErrorLog(pScrn, "No valid modes found for CRT2; %s\n", mergeddisstr);
	  SiSFreeCRT2Structs(pSiS);
	  pSiS->MergedFB = FALSE;
       }

    }

    if(pSiS->MergedFB) {

       xf86SetCrtcForModes(pSiS->CRT2pScrn, INTERLACE_HALVE_V);

       xf86DrvMsg(pScrn->scrnIndex, X_INFO, modesforstr, 2);

       xf86PrintModes(pSiS->CRT2pScrn);

       pSiS->CRT1Modes = pScrn->modes;
       pSiS->CRT1CurrentMode = pScrn->currentMode;

       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Generating MergedFB mode list\n");

       pScrn->modes = SiSGenerateModeList(pScrn, pSiS->MetaModes,
	            	                  pSiS->CRT1Modes, pSiS->CRT2pScrn->modes,
					  pSiS->CRT2Position);

       if(!pScrn->modes) {

	  SISErrorLog(pScrn, "Failed to parse MetaModes or no modes found. %s.\n",
	  		mergeddisstr);
	  SiSFreeCRT2Structs(pSiS);
	  pScrn->modes = pSiS->CRT1Modes;
	  pSiS->CRT1Modes = NULL;
	  pSiS->MergedFB = FALSE;

       }

    }

    if(pSiS->MergedFB) {

       /* If no virtual dimension was given by the user,
        * calculate a sane one now. Adapts pScrn->virtualX,
	* pScrn->virtualY and pScrn->displayWidth.
	*/
       SiSRecalcDefaultVirtualSize(pScrn);

       pScrn->modes = pScrn->modes->next;  /* We get the last from GenerateModeList(), skip to first */
       pScrn->currentMode = pScrn->modes;

       /* Update CurrentLayout */
       pSiS->CurrentLayout.mode = pScrn->currentMode;
       pSiS->CurrentLayout.displayWidth = pScrn->displayWidth;

d3408 1
a3408 6
#ifdef SISMERGED
    if(pSiS->MergedFB) {
       SiSMergedFBSetDpi(pScrn, pSiS->CRT2pScrn, pSiS->CRT2Position);
    } else
#endif
       xf86SetDpi(pScrn, 0, 0);
d3410 1
a3410 1
    /* Load fb module */
d3412 8
d3424 1
a3424 10
	if(!xf86LoadSubModule(pScrn, "fb")) {
           SISErrorLog(pScrn, "Failed to load fb module");
#ifdef SISDUALHEAD
	   if(pSiSEnt) pSiSEnt->ErrorAfterFirst = TRUE;
#endif
	   if(pSiS->pInt) xf86FreeInt10(pSiS->pInt);
	   sisRestoreExtRegisterLock(pSiS,srlockReg,crlockReg);
           SISFreeRec(pScrn);
           return FALSE;
        }
d3426 5
a3430 2
      default:
        SISErrorLog(pScrn, "Unsupported framebuffer bpp (%d)\n", pScrn->bitsPerPixel);
d3439 8
a3446 1
    xf86LoaderReqSymLists(fbSymbols, NULL);
d3452 2
a3453 1
	    SISErrorLog(pScrn, "Could not load xaa module\n");
d3468 2
a3469 1
	    SISErrorLog(pScrn, "Could not load shadowfb module\n");
a3480 14
    /* Load the dri module if requested. */
#ifdef XF86DRI
    if(pSiS->loadDRI) {
       if(xf86LoadSubModule(pScrn, "dri")) {
          xf86LoaderReqSymLists(driSymbols, drmSymbols, NULL);
       } else {
#ifdef SISDUALHEAD
          if(!pSiS->DualHeadMode)
#endif
             xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	  	 "Remove >Load \"dri\"< from the Module section of your XF86Config file\n");
       }
    }
#endif    
d3482 1
a3482 1
    /* Now load and initialize VBE module for VESA and mode restoring. */
d3492 1
a3492 1
	    			SET_BIOS_SCRATCH | RESTORE_BIOS_SCRATCH);
d3497 7
a3503 9
          vbe = VBEGetVBEInfo(pSiS->pVbe);
          pSiS->vesamajor = (unsigned)(vbe->VESAVersion >> 8);
          pSiS->vesaminor = vbe->VESAVersion & 0xff;
          pSiS->vbeInfo = vbe;
          if(pSiS->VESA == 1) {
             SiSBuildVesaModeList(pScrn, pSiS->pVbe, vbe);
             VBEFreeVBEInfo(vbe);
             pSiS->UseVESA = 1;
          }
d3505 2
a3506 3
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    	"Could not load and initialize VBE module.%s\n",
		(pSiS->VESA == 1) ? " VESA disabled." : "");
d3508 2
a3509 2
    }    
  
a3523 22
    if(pSiS->VGAEngine == SIS_315_VGA) pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTXVGAMMA1;

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
    	pSiS->SiS_SD_Flags |= SiS_SD_ISDUALHEAD;
	if(pSiS->SecondHead)      pSiS->SiS_SD_Flags |= SiS_SD_ISDHSECONDHEAD;
	else			  pSiS->SiS_SD_Flags &= ~(SiS_SD_SUPPORTXVGAMMA1);
#ifdef PANORAMIX
	if(!noPanoramiXExtension) {
	   pSiS->SiS_SD_Flags |= SiS_SD_ISDHXINERAMA;
	   pSiS->SiS_SD_Flags &= ~(SiS_SD_SUPPORTXVGAMMA1);
	}
#endif
    }
#endif

#ifdef SISMERGED
    if(pSiS->MergedFB)      pSiS->SiS_SD_Flags |= SiS_SD_ISMERGEDFB;
#endif

    if(pSiS->enablesisctrl) pSiS->SiS_SD_Flags |= SiS_SD_ENABLED;

d3563 1
a3563 1
	     /* Only map if not mapped previously */
d3574 2
a3575 1
    	SISErrorLog(pScrn, "Could not map MMIO area\n");
d3588 1
a3588 1
	     /* Only map if not mapped previously */
d3599 3
a3601 2
       SISErrorLog(pScrn, "Could not map MMIO dense area\n");
       return FALSE;
d3610 1
a3610 1
	     /* Only map if not mapped previously */
d3617 1
a3617 1
     	/* Adapt FbBase (for DHM; dhmOffset is 0 otherwise) */
d3630 3
a3632 2
       SISErrorLog(pScrn, "Could not map framebuffer area\n");
       return FALSE;
d3657 3
a3659 3
/* In dual head mode, we must not unmap if the other head still
 * assumes memory as mapped
 */
d3661 2
a3662 2
    if(pSiS->DualHeadMode) {
        if(pSiSEnt->MapCountIOBase) {
d3664 1
a3664 1
	    if((pSiSEnt->MapCountIOBase == 0) || (pSiSEnt->forceUnmapIOBase)) {
d3673 1
a3673 1
	if(pSiSEnt->MapCountIOBaseDense) {
d3675 1
a3675 1
	    if((pSiSEnt->MapCountIOBaseDense == 0) || (pSiSEnt->forceUnmapIOBaseDense)) {
d3684 1
a3684 1
	if(pSiSEnt->MapCountFbBase) {
d3686 1
a3686 1
	    if((pSiSEnt->MapCountFbBase == 0) || (pSiSEnt->forceUnmapFbBase)) {
d3724 1
a3724 1
    /* We always save master & slave */
d3731 1
a3731 15
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (SiSBridgeIsInSlaveMode(pScrn))) {
          vgaHWSave(pScrn, vgaReg, VGA_SR_CMAP | VGA_SR_MODE);
	  SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO+0x30);
	  SiSSetLVDSetc(pSiS->SiS_Pr, &pSiS->sishw_ext, 0);
	  SiS_GetVBType(pSiS->SiS_Pr, &pSiS->sishw_ext);
	  SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
	  vgaHWSave(pScrn, vgaReg, VGA_SR_FONTS);
	  SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
       } else {
          vgaHWSave(pScrn, vgaReg, VGA_SR_ALL);
       }
    } else {
       vgaHWSave(pScrn, vgaReg, VGA_SR_ALL);
    }
d3736 1
a3736 1

d3738 2
a3739 2

    /* "Save" these again as they may have been changed prior to SISSave() call */
d3741 3
a3743 9
       sisReg->sisRegs3C4[0x1f] = pSiS->oldSR1F;
       sisReg->sisRegs3D4[0x17] = pSiS->oldCR17;
       if(vgaReg->numCRTC >= 0x17) vgaReg->CRTC[0x17] = pSiS->oldCR17;
       sisReg->sisRegs3D4[0x32] = pSiS->oldCR32;
       sisReg->sisRegs3D4[0x36] = pSiS->oldCR36;
       sisReg->sisRegs3D4[0x37] = pSiS->oldCR37;
       if(pSiS->VGAEngine == SIS_315_VGA) {
	  sisReg->sisRegs3D4[pSiS->myCR63] = pSiS->oldCR63;
       }
d3747 3
d3753 4
a3756 1
    (void) inb(pSiS->IODBase + VGA_IOBASE_COLOR + VGA_IN_STAT_1_OFFSET);
d3765 4
a3768 1
    (void) inb(pSiS->IODBase + VGA_IOBASE_COLOR + VGA_IN_STAT_1_OFFSET);
d3771 1
a3771 1
    return(inb(pSiS->IODBase + VGA_ATTR_DATA_R));
a3773 1
#define SIS_FONTS_SIZE (8 * 8192)
d3786 2
a3787 1
    if(pSiS->fonts) return;
d3791 2
a3792 1
    if(attr10 & 0x01) return;
d3794 1
a3794 5
    if(!(pSiS->fonts = xalloc(SIS_FONTS_SIZE * 2))) {
       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
       		"Could not save console fonts, mem allocation failed\n");
       return;
    }
d3820 1
a3820 1
    slowbcopy_frombus(vgaIOBase, pSiS->fonts, SIS_FONTS_SIZE);
d3828 1
a3828 1
    slowbcopy_frombus(vgaIOBase, pSiS->fonts + SIS_FONTS_SIZE, SIS_FONTS_SIZE);
d3856 7
a3862 1
    if(!pSiS->fonts) return;
d3884 4
a3887 4
    if(pScrn->depth == 4) {
       outSISIDXREG(SISGR, 0x03, 0x00);  /* don't rotate, write unmodified */
       outSISIDXREG(SISGR, 0x08, 0xFF);  /* write all bits in a byte */
       outSISIDXREG(SISGR, 0x01, 0x00);  /* all planes come from CPU */
d3895 1
a3895 1
    slowbcopy_tobus(pSiS->fonts, vgaIOBase, SIS_FONTS_SIZE);
d3902 1
a3902 1
    slowbcopy_tobus(pSiS->fonts + SIS_FONTS_SIZE, vgaIOBase, SIS_FONTS_SIZE);
d3922 1
a3922 3
#undef SIS_FONTS_SIZE

/* VESASaveRestore taken from vesa driver */
d3926 3
a3928 1
    SISPtr pSiS = SISPTR(pScrn);
d3931 11
a3941 2
    if((function == MODE_QUERY) ||
       (function == MODE_SAVE && pSiS->state == NULL)) {
d3943 1
a3943 10
       /* Make sure we save at least this information in case of failure */
       (void)VBEGetVBEMode(pSiS->pVbe, &pSiS->stateMode);
       SiS_SaveFonts(pScrn);

       if(pSiS->vesamajor > 1) {
	  if(!VBESaveRestore(pSiS->pVbe, function, (pointer)&pSiS->state,
				&pSiS->stateSize, &pSiS->statePage)) {
	     return;
	  }
       }
d3947 2
a3948 1
    if(function != MODE_QUERY) {
d3950 14
a3963 4
       if(pSiS->vesamajor > 1) {
	  if(function == MODE_RESTORE) {
	     memcpy(pSiS->state, pSiS->pstate, pSiS->stateSize);
	  }
d3965 8
a3972 15
	  if(VBESaveRestore(pSiS->pVbe,function,(pointer)&pSiS->state,
			    &pSiS->stateSize,&pSiS->statePage) &&
	     (function == MODE_SAVE)) {
	     /* don't rely on the memory not being touched */
	     if(!pSiS->pstate) {
		pSiS->pstate = xalloc(pSiS->stateSize);
	     }
	     memcpy(pSiS->pstate, pSiS->state, pSiS->stateSize);
	  }
       }

       if(function == MODE_RESTORE) {
	  VBESetVBEMode(pSiS->pVbe, pSiS->stateMode, NULL);
	  SiS_RestoreFonts(pScrn);
       }
d3975 27
d4008 1
a4008 1
 * we use our own mode switching code (or VESA).
a4017 3
#ifdef SISDUALHEAD
    SISEntPtr pSiSEnt = NULL;
#endif
d4019 1
a4019 1
    andSISIDXREG(SISCR,0x11,0x7f);   	/* Unlock CRTC registers */
d4021 1
a4021 1
    SISModifyModeInfo(mode);		/* Quick check of the mode parameters */
d4023 5
a4027 1
    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
d4031 1
a4031 1
    if(pSiS->UseVESA) {  /* With VESA: */
d4034 2
a4035 2
       /* No dual head mode when using VESA */
       if(pSiS->SecondHead) return TRUE;
d4037 27
a4063 24

       pScrn->vtSema = TRUE;

       /*
	* This order is required:
	* The video bridge needs to be adjusted before the
	* BIOS is run as the BIOS sets up CRT2 according to
	* these register settings.
	* After the BIOS is run, the bridges and turboqueue
	* registers need to be readjusted as the BIOS may
	* very probably have messed them up.
	*/
       if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
	  SiSPreSetMode(pScrn, mode, SIS_MODE_SIMU);
       }
       if(!SiSSetVESAMode(pScrn, mode)) {
	  SISErrorLog(pScrn, "SiSSetVESAMode() failed\n");
	  return FALSE;
       }
       sisSaveUnlockExtRegisterLock(pSiS,NULL,NULL);
       if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
	  SiSPreSetMode(pScrn, mode, SIS_MODE_SIMU);
	  SiSPostSetMode(pScrn, &pSiS->ModeReg);
       }
d4065 2
a4066 2
       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "REAL REGISTER CONTENTS AFTER SETMODE:\n");
d4068 7
a4074 4
       if(!(*pSiS->ModeInit)(pScrn, mode)) {
	  SISErrorLog(pScrn, "ModeInit() failed\n");
	  return FALSE;
       }
d4076 7
a4082 3
       vgaHWProtect(pScrn, TRUE);
       (*pSiS->SiSRestore)(pScrn, &pSiS->ModeReg);
       vgaHWProtect(pScrn, FALSE);
a4084 1

d4086 6
a4091 1
       if(pSiS->DualHeadMode) {
d4093 1
a4093 4
          if(!(*pSiS->ModeInit)(pScrn, mode)) {
	     SISErrorLog(pScrn, "ModeInit() failed\n");
	     return FALSE;
	  }
d4095 20
a4114 29
	  pScrn->vtSema = TRUE;

	  pSiSEnt = pSiS->entityPrivate;

	  if(!(pSiS->SecondHead)) {
	     /* Head 1 (master) is always CRT2 */
	     SiSPreSetMode(pScrn, mode, SIS_MODE_CRT2);
	     if(!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn, mode, pSiS->IsCustom)) {
		SISErrorLog(pScrn, "SiSBIOSSetModeCRT2() failed\n");
		return FALSE;
	     }
	     SiSPostSetMode(pScrn, &pSiS->ModeReg);
	     SISAdjustFrame(pSiSEnt->pScrn_2->scrnIndex,
		            pSiSEnt->pScrn_2->frameX0,
		            pSiSEnt->pScrn_2->frameY0, 0);
	  } else {
	     /* Head 2 (slave) is always CRT1 */
	     SiSPreSetMode(pScrn, mode, SIS_MODE_CRT1);
	     if(!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn, mode, pSiS->IsCustom)) {
		SISErrorLog(pScrn, "SiSBIOSSetModeCRT1() failed\n");
		return FALSE;
	     }
	     SiSPostSetMode(pScrn, &pSiS->ModeReg);
	     SISAdjustFrame(pSiSEnt->pScrn_1->scrnIndex,
		            pSiSEnt->pScrn_1->frameX0,
		            pSiSEnt->pScrn_1->frameY0, 0);
	  }

       } else {
d4116 2
d4119 12
a4130 6
	  if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {

             if(!(*pSiS->ModeInit)(pScrn, mode)) {
		SISErrorLog(pScrn, "ModeInit() failed\n");
	        return FALSE;
	     }
d4132 1
a4132 1
	     pScrn->vtSema = TRUE;
d4134 2
a4135 2
#ifdef SISMERGED
	     if(pSiS->MergedFB) {
d4137 5
a4141 2
	        xf86DrvMsg(0, X_INFO, "Setting MergedFB mode %dx%d\n",
			   	mode->HDisplay, mode->VDisplay);
d4143 5
a4147 19
		SiSPreSetMode(pScrn, mode, SIS_MODE_CRT1);

		if(!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn,
		                       ((SiSMergedDisplayModePtr)mode->Private)->CRT1,
				       pSiS->IsCustom)) {
 		   SISErrorLog(pScrn, "SiSBIOSSetModeCRT1() failed\n");
	   	   return FALSE;
		}

		SiSPreSetMode(pScrn, mode, SIS_MODE_CRT2);

		if(!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn,
		                       ((SiSMergedDisplayModePtr)mode->Private)->CRT2,
				       pSiS->IsCustomCRT2)) {
	 	   SISErrorLog(pScrn, "SiSBIOSSetModeCRT2() failed\n");
		   return FALSE;
	        }

	     } else {
a4148 14

		if(pSiS->VBFlags & CRT1_LCDA) {
	           SiSPreSetMode(pScrn, mode, SIS_MODE_CRT1);
	           if(!SiSBIOSSetModeCRT1(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn,
		                   mode, pSiS->IsCustom)) {
		      SISErrorLog(pScrn, "SiSBIOSSetModeCRT1() failed\n");
		      return FALSE;
		   }
		   SiSPreSetMode(pScrn, mode, SIS_MODE_CRT2);
	           if(!SiSBIOSSetModeCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn,
		                   mode, pSiS->IsCustom)) {
		      SISErrorLog(pScrn, "SiSBIOSSetModeCRT2() failed\n");
		      return FALSE;
		   }
a4149 7
		   SiSPreSetMode(pScrn, mode, SIS_MODE_SIMU);
	           if(!SiSBIOSSetMode(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn,
		                   mode, pSiS->IsCustom)) {
		      SISErrorLog(pScrn, "SiSBIOSSetModeCRT() failed\n");
		      return FALSE;
		   }
		}
d4151 1
a4151 4
#ifdef SISMERGED
	     }
#endif
	     SiSPostSetMode(pScrn, &pSiS->ModeReg);
d4153 6
a4158 6
#ifdef TWDEBUG
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "VBFlags %lx\n", pSiS->VBFlags);
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			"REAL REGISTER CONTENTS AFTER SETMODE:\n");
             (*pSiS->ModeInit)(pScrn, mode);
#endif
d4160 2
a4161 1
	  } else {
d4163 6
a4168 1
	     /* For other chipsets, use the old method */
d4170 1
a4170 5
	     /* Initialise the ModeReg values */
    	     if(!vgaHWInit(pScrn, mode)) {
	        SISErrorLog(pScrn, "vgaHWInit() failed\n");
	        return FALSE;
	     }
d4172 9
a4180 2
	     /* Reset our PIOOffset as vgaHWInit might have reset it */
      	     VGAHWPTR(pScrn)->PIOOffset = pSiS->IODBase + (pSiS->PciInfo->ioBase[2] & 0xFFFC) - 0x380;
d4182 1
a4182 5
	     /* Prepare the register contents */
	     if(!(*pSiS->ModeInit)(pScrn, mode)) {
	        SISErrorLog(pScrn, "ModeInit() failed\n");
	        return FALSE;
	     }
d4184 1
a4184 1
	     pScrn->vtSema = TRUE;
d4186 3
a4188 17
	     /* Program the registers */
	     vgaHWProtect(pScrn, TRUE);
	     vgaReg = &hwp->ModeReg;
	     sisReg = &pSiS->ModeReg;

	     vgaReg->Attribute[0x10] = 0x01;
    	     if(pScrn->bitsPerPixel > 8) {
	    	vgaReg->Graphics[0x05] = 0x00;
	     }

    	     vgaHWRestore(pScrn, vgaReg, VGA_SR_MODE);

	     (*pSiS->SiSRestore)(pScrn, sisReg);

	     if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
	        SiS6326PostSetMode(pScrn, &pSiS->ModeReg);
	     }
d4191 1
a4191 1
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d4193 1
a4193 1
             (*pSiS->ModeInit)(pScrn, mode);
d4196 2
a4197 2
  	     vgaHWProtect(pScrn, FALSE);
	  }
d4199 1
a4199 1
       }
d4203 1
a4203 1
    /* Update Currentlayout */
d4206 3
d4220 1
a4220 1
    if(!(mode = SiSCalcVESAModeIndex(pScrn, pMode))) return FALSE;
d4222 2
a4223 2
    mode |= (1 << 15);	/* Don't clear framebuffer */
    mode |= (1 << 14);   	/* Use linear adressing */
d4226 2
a4227 1
       SISErrorLog(pScrn, "Setting VESA mode 0x%x failed\n",
d4229 1
a4229 1
       return (FALSE);
d4232 2
a4233 3
    if(pMode->HDisplay != pScrn->virtualX) {
       VBESetLogicalScanline(pSiS->pVbe, pScrn->virtualX);
    }
d4236 2
a4237 2
    	"Setting VESA mode 0x%x succeeded\n",
	mode & 0x0fff);
a4241 67
static void
SISSpecialRestore(ScrnInfoPtr pScrn)
{
    SISPtr    pSiS = SISPTR(pScrn);
    SISRegPtr sisReg = &pSiS->SavedReg;
    unsigned char temp;
    int i;

    /* 1.11.04 and later for 651 and 301B(DH) do strange register
     * fiddling after the usual mode change. This happens
     * depending on the result of a call of int 2f (with
     * ax=0x1680) and if modeno <= 0x13. I have no idea if
     * that is specific for the 651 or that very machine.
     * So this perhaps requires some more checks in the beginning
     * (although it should not do any harm on other chipsets/bridges
     * etc.) However, even if I call the VBE to restore mode 0x03,
     * these registers don't get restored correctly, possibly
     * because that int-2f-call for some reason results non-zero. So
     * what I do here is to restore these few registers
     * manually.
     */

    if(!(pSiS->ChipFlags & SiSCF_Is65x)) return;
    inSISIDXREG(SISCR, 0x34, temp);
    temp &= 0x7f;
    if(temp > 0x13) return;

#ifdef UNLOCK_ALWAYS
    sisSaveUnlockExtRegisterLock(pSiS, NULL,NULL);
#endif

    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);

    outSISIDXREG(SISCAP, 0x3f, sisReg->sisCapt[0x3f]);
    outSISIDXREG(SISCAP, 0x00, sisReg->sisCapt[0x00]);
    for(i = 0; i < 0x4f; i++) {
       outSISIDXREG(SISCAP, i, sisReg->sisCapt[i]);
    }
    outSISIDXREG(SISVID, 0x32, (sisReg->sisVid[0x32] & ~0x05));
    outSISIDXREG(SISVID, 0x30, sisReg->sisVid[0x30]);
    outSISIDXREG(SISVID, 0x32, ((sisReg->sisVid[0x32] & ~0x04) | 0x01));
    outSISIDXREG(SISVID, 0x30, sisReg->sisVid[0x30]);

    if(!(pSiS->ChipFlags & SiSCF_Is651)) return;
    if(!(pSiS->VBFlags & VB_SISBRIDGE)) return;

    inSISIDXREG(SISCR, 0x30, temp);
    if(temp & 0x40) {
       unsigned char myregs[] = {
       			0x2f, 0x08, 0x09, 0x03, 0x0a, 0x0c,
			0x0b, 0x0d, 0x0e, 0x12, 0x0f, 0x10,
			0x11, 0x04, 0x05, 0x06, 0x07, 0x00,
			0x2e
       };
       for(i = 0; i <= 18; i++) {
          outSISIDXREG(SISPART1, myregs[i], sisReg->VBPart1[myregs[i]]);
       }
    } else if((temp & 0x20) || (temp & 0x9c)) {
       unsigned char myregs[] = {
       			0x04, 0x05, 0x06, 0x07, 0x00, 0x2e
       };
       for(i = 0; i <= 5; i++) {
          outSISIDXREG(SISPART1, myregs[i], sisReg->VBPart1[myregs[i]]);
       }
    }
}

a4252 11
    Bool      vesasuccess = FALSE;
    
    /* WARNING: Don't ever touch this. It now seems to work on
     * all chipset/bridge combinations - but finding out the
     * correct combination was pure hell.
     */

    /* Wait for the accelerators */
    if(pSiS->AccelInfoPtr) {
       (*pSiS->AccelInfoPtr->Sync)(pScrn);
    }
d4257 1
a4257 1
       /* We always restore master AND slave */
d4261 1
a4261 1
       /* We must not disable the sequencer if the bridge is in SlaveMode! */
d4270 1
a4270 1
       /* First, restore CRT1 on/off and VB connection registers */
d4272 8
a4279 8
       if(!(pSiS->oldCR17 & 0x80)) {			/* CRT1 was off */
          if(!(SiSBridgeIsInSlaveMode(pScrn))) {        /* Bridge is NOT in SlaveMode now -> do it */
	     doit = TRUE;
	  } else {
	     doitlater = TRUE;
	  }
       } else {						/* CRT1 was on -> do it now */
          doit = TRUE;
d4283 1
a4283 4
          outSISIDXREG(SISCR, 0x17, pSiS->oldCR17);
       }
       if(pSiS->VGAEngine == SIS_315_VGA) {
          outSISIDXREG(SISCR, pSiS->myCR63, pSiS->oldCR63);
d4286 5
a4290 7
       outSISIDXREG(SISSR, 0x1f, pSiS->oldSR1F);

       /* For 30xB/LV, restoring the registers does not
        * work. We "manually" set the old mode, instead.
	* The same applies for SiS730 machines with LVDS.
	* Finally, this behavior can be forced by setting
	* the option RestoreBySetMode.
d4293 1
a4293 1
	      (pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV)) ||
d4297 4
a4300 2
	   Bool changedmode = FALSE;
	   
a4302 53
		 
           if(((pSiS->OldMode <= 0x13) || (!pSiS->sisfbfound)) && (pSiS->pVbe)) {
	      int vmode = SiSTranslateToVESA(pScrn, pSiS->OldMode);
	      if(vmode > 0) {
	         if(vmode > 0x13) vmode |= ((1 << 15) | (1 << 14));
                 if(VBESetVBEMode(pSiS->pVbe, vmode, NULL) == TRUE) {
	            SISSpecialRestore(pScrn);
		    SiS_GetSetModeID(pScrn,pSiS->OldMode);
	      	    vesasuccess = TRUE;
	         } else {
	            xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
		 	"VBE failed to restore mode 0x%x\n", pSiS->OldMode);
	         }
	      } else {
	         xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 3,
		 	"Can't identify VESA mode number for mode 0x%x\n", pSiS->OldMode);
	      }
           }

	   if(vesasuccess == FALSE) {

	      int backupscaler = pSiS->SiS_Pr->UsePanelScaler;
	      unsigned long backupspecialtiming = pSiS->SiS_Pr->SiS_CustomT;

 	      if((pSiS->VBFlags & (VB_301B|VB_301C|VB_302B|VB_301LV|VB_302LV|VB_302ELV))) {
	        /* !!! REQUIRED for 630+301B-DH, otherwise the text modes
	         *     will not be restored correctly !!!
	         * !!! Do this ONLY for LCD; VGA2 will not be restored
	         *     correctly otherwise.
	         */
	         unsigned char temp;
	         inSISIDXREG(SISCR, 0x30, temp);
	         if(temp & 0x20) {
	            if(pSiS->OldMode == 0x03) {
	      	       pSiS->OldMode = 0x13;
		       changedmode = TRUE;
	            }
	         }
	      }

	      pSiS->SiS_Pr->UseCustomMode = FALSE;
	      pSiS->SiS_Pr->CRT1UsesCustomMode = FALSE;
	      pSiS->SiS_Pr->UsePanelScaler = pSiS->sisfbscalelcd;
	      pSiS->SiS_Pr->SiS_CustomT = pSiS->sisfbspecialtiming;
	      SiSSetMode(pSiS->SiS_Pr, &pSiS->sishw_ext, pScrn, pSiS->OldMode, FALSE);
	      if(changedmode) {
	   	 pSiS->OldMode = 0x03;
		 outSISIDXREG(SISCR,0x34,0x03);
	      }
	      SISSpecialRestore(pScrn);
	      SiS_GetSetModeID(pScrn,pSiS->OldMode);
	      pSiS->SiS_Pr->UsePanelScaler = backupscaler;
	      pSiS->SiS_Pr->SiS_CustomT = backupspecialtiming;
d4304 3
d4308 11
a4318 25

	   /* Restore CRT1 status */
	   if(pSiS->VGAEngine == SIS_315_VGA) {
              outSISIDXREG(SISCR, pSiS->myCR63, pSiS->oldCR63);
           }
           outSISIDXREG(SISSR, 0x1f, pSiS->oldSR1F);

#ifdef SISVRAMQ
	   /* Restore queue mode registers on 315/330 series */
	   /* (This became necessary due to the switch to VRAM queue) */
	   if(pSiS->VGAEngine == SIS_315_VGA) {
	      unsigned char tempCR55=0;
	      if(pSiS->sishw_ext.jChipType <= SIS_330) {
	         inSISIDXREG(SISCR,0x55,tempCR55);
	         andSISIDXREG(SISCR,0x55,0x33);
	      }
	      outSISIDXREG(SISSR,0x26,0x01);
	      MMIO_OUT32(pSiS->IOBase, 0x85c4, 0);
	      outSISIDXREG(SISSR,0x27,sisReg->sisRegs3C4[0x27]);
	      outSISIDXREG(SISSR,0x26,sisReg->sisRegs3C4[0x26]);
	      MMIO_OUT32(pSiS->IOBase, 0x85C0, sisReg->sisMMIO85C0);
	      if(pSiS->sishw_ext.jChipType <= SIS_330) {
	         outSISIDXREG(SISCR,0x55,tempCR55);
	      }
	   }
d4324 6
a4329 4
	      /* If a video bridge is present, we need to restore
	       * non-extended (=standard VGA) SR and CR registers
	       * before restoring the extended ones and the bridge
	       * registers itself.
d4348 22
a4369 25
	if(pSiS->Primary) {
	   if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (SiSBridgeIsInSlaveMode(pScrn))) {
	      /* IMPORTANT: The 30xLV does not handle well being disabled if in
	       * LCDA mode! In LCDA mode, the bridge is NOT in slave mode,
	       * so this is the only safe way: Disable the bridge ONLY if
	       * in Slave Mode, and don't bother if not.
	       */
              SiSRegInit(pSiS->SiS_Pr, pSiS->RelIO+0x30);
	      SiSSetLVDSetc(pSiS->SiS_Pr, &pSiS->sishw_ext, 0);
	      SiS_GetVBType(pSiS->SiS_Pr, &pSiS->sishw_ext);
	      SiS_DisableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);

	      vgaHWProtect(pScrn, TRUE);

	      /* We now restore ALL to overcome the vga=extended problem */
	      vgaHWRestore(pScrn, vgaReg, VGA_SR_ALL);

	      vgaHWProtect(pScrn, FALSE);

	      SiS_EnableBridge(pSiS->SiS_Pr, &pSiS->sishw_ext);
	      andSISIDXREG(SISSR, 0x01, ~0x20);  /* Display on */
	   } else {
	      vgaHWProtect(pScrn, TRUE);

	      /* We now restore ALL to overcome the vga=extended problem */
a4370 2

	      vgaHWProtect(pScrn, FALSE);
d4372 3
a4375 11

#ifdef TWDEBUG
	{
	  SISRegPtr pReg = &pSiS->ModeReg;
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		"REAL REGISTER CONTENTS AFTER RESTORE BY SETMODE:\n");
	  (*pSiS->SiSSave)(pScrn, pReg);
	}
#endif	
	
	sisRestoreExtRegisterLock(pSiS,sisReg->sisRegs3C4[0x05],sisReg->sisRegs3D4[0x80]);
a4379 1
	
a4382 1

d4390 2
a4391 2
	/* Restore TV. This is rather complicated, but if we don't do it,
	 * TV output will flicker terribly
d4394 10
a4403 7
	   if(sisReg->sis6326tv[0] & 0x04) {
	      unsigned char tmp;
	      int val;

              orSISIDXREG(SISSR, 0x01, 0x20);
              tmp = SiS6326GetTVReg(pScrn,0x00);
              tmp &= ~0x04;
d4405 15
a4419 18
              SiS6326SetTVReg(pScrn,0x00,tmp);
              for(val=0; val < 2; val++) {
                 while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
                 while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
              }
              SiS6326SetTVReg(pScrn, 0x00, sisReg->sis6326tv[0]);
              tmp = inSISREG(SISINPSTAT);
              outSISREG(SISAR, 0x20);
              tmp = inSISREG(SISINPSTAT);
              while(inSISREG(SISINPSTAT) & 0x01);
              while(!(inSISREG(SISINPSTAT) & 0x01));
              andSISIDXREG(SISSR, 0x01, ~0x20);
              for(val=0; val < 10; val++) {
                 while(!(inSISREG(SISINPSTAT) & 0x08));  /* Wait while NOT vb */
                 while(inSISREG(SISINPSTAT) & 0x08);     /* wait while vb     */
              }
              andSISIDXREG(SISSR, 0x01, ~0x20);
	   }
d4433 1
a4433 23
   if(pSiS->UseVESA) {
      SISVESASaveRestore(pScrn, MODE_RESTORE);
#ifdef SISVRAMQ
      /* Restore queue mode registers on 315/330 series */
      /* (This became necessary due to the switch to VRAM queue) */
      if(pSiS->VGAEngine == SIS_315_VGA) {
         SISRegPtr sisReg = &pSiS->SavedReg;
	 unsigned char tempCR55=0;
	 if(pSiS->sishw_ext.jChipType <= SIS_330) {
	    inSISIDXREG(SISCR,0x55,tempCR55);
	    andSISIDXREG(SISCR,0x55,0x33);
	 }
	 outSISIDXREG(SISSR,0x26,0x01);
	 MMIO_OUT32(pSiS->IOBase, 0x85c4, 0);
	 outSISIDXREG(SISSR,0x27,sisReg->sisRegs3C4[0x27]);
	 outSISIDXREG(SISSR,0x26,sisReg->sisRegs3C4[0x26]);
	 MMIO_OUT32(pSiS->IOBase, 0x85C0, sisReg->sisMMIO85C0);
	 if(pSiS->sishw_ext.jChipType <= SIS_330) {
	    outSISIDXREG(SISCR,0x55,tempCR55);
	 }
      }
#endif
   }
d4436 1
a4436 1
/* Restore bridge config registers - to be called BEFORE VESARestore */
d4452 1
a4452 1
/* Our generic BlockHandler for Xv */
d4465 1
a4465 5
       (*pSiS->VideoTimerCallback)(pScrn, currentTime.milliseconds);
    }

    if(pSiS->RenderCallback) {
       (*pSiS->RenderCallback)(pScrn);
d4472 3
a4474 3
 * We use pScrn and not CurrentLayout here, because the
 * properties we use have not changed (displayWidth,
 * depth, bitsPerPixel)
d4483 1
d4498 1
a4498 5
#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead)) {
#endif    
       if(xf86LoadSubModule(pScrn, "vbe")) {
	  xf86LoaderReqSymLists(vbeSymbols, NULL);
d4500 1
a4500 1
          pSiS->pVbe = VBEInit(NULL, pSiS->pEnt->index);
d4502 1
a4502 1
          pSiS->pVbe = VBEExtendedInit(NULL, pSiS->pEnt->index,
a4504 4
       } else {
          SISErrorLog(pScrn, "Failed to load VBE submodule\n");
       }
#ifdef SISDUALHEAD
a4505 1
#endif
d4509 2
a4510 2
       pSiSEnt = pSiS->entityPrivate;
       pSiSEnt->refCount++;
d4518 2
a4519 1
          SISErrorLog(pScrn, "Could not map VGA memory window\n");
d4524 3
a4526 3
    
    /* Patch the PIOOffset inside vgaHW to use
     * our relocated IO ports.
d4532 3
a4534 2
       SISErrorLog(pScrn, "SiSMapMem() failed\n");
       return FALSE;
d4541 5
a4545 5
    /* Enable TurboQueue so that SISSave() saves it in enabled
     * state. If we don't do this, X will hang after a restart!
     * (Happens for some unknown reason only when using VESA
     * for mode switching; assumingly a BIOS issue.)
     * This is done on 300 and 315 series only.
d4548 1
a4548 5
#ifdef SISVRAMQ
       if(pSiS->VGAEngine != SIS_315_VGA)
#endif
          SiSEnableTurboQueue(pScrn);

d4554 1
d4556 1
a4556 47

       if(!pSiS->OldMode) {

          /* Try to find out current (=old) mode number
	   * (Do this only if not sisfb has told us its mode yet)
	   */

	  /* Read 0:449 which the BIOS sets to the current mode number
	   * Unfortunately, this not reliable since the int10 emulation
	   * does not change this. So if we call the VBE later, this
	   * byte won't be touched (which is why we set this manually
	   * then).
	   */
          unsigned char myoldmode = SiS_GetSetModeID(pScrn,0xFF);
	  unsigned char cr30, cr31;

          /* Read CR34 which the BIOS sets to the current mode number for CRT2
	   * This is - of course - not reliable if the machine has no video
	   * bridge...
	   */
          inSISIDXREG(SISCR, 0x34, pSiS->OldMode);
	  inSISIDXREG(SISCR, 0x30, cr30);
	  inSISIDXREG(SISCR, 0x31, cr31);

	  /* What if CR34 is different from the BIOS byte? */
	  if(pSiS->OldMode != myoldmode) {
	     /* If no bridge output is active, trust the BIOS byte */
	     if(!cr31 && !cr30) pSiS->OldMode = myoldmode;
	     /* ..else trust CR34 */
	  }

	  /* Newer 650 BIOSes set CR34 to 0xff if the mode has been
	   * "patched", for instance for 80x50 text mode. (That mode
	   * has no number of its own, it's 0x03 like 80x25). In this
	   * case, we trust the BIOS byte (provided that any of these
	   * two is valid).
	   */
	  if(pSiS->OldMode > 0x7f) {
	     pSiS->OldMode = myoldmode;
	  }
       }
#ifdef SISDUALHEAD
       if(pSiS->DualHeadMode) {
          if(!pSiS->SecondHead) pSiSEnt->OldMode = pSiS->OldMode;
          else                  pSiS->OldMode = pSiSEnt->OldMode;
       }
#endif
d4561 3
a4563 2
       SISErrorLog(pScrn, "SiSModeInit() failed\n");
       return FALSE;
d4567 3
a4569 3
    /* Not using Dual Head variant on purpose; we darken
     * the screen for both displays, and un-darken
     * it when the second head is finished
d4576 5
d4604 17
a4620 8
    if(!miSetVisualTypes(pScrn->depth,
    			 (pScrn->bitsPerPixel > 8) ?
			 	TrueColorMask : miGetDefaultVisualMask(pScrn->depth),
			 pScrn->rgbBits, pScrn->defaultVisual)) {
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       SISErrorLog(pScrn, "miSetVisualTypes() failed (bpp %d)\n",
	  		pScrn->bitsPerPixel);
       return FALSE;
d4628 2
a4629 2
       height = pScrn->virtualX;
       width = pScrn->virtualY;
d4633 4
a4636 4
       pSiS->ShadowPitch = BitmapBytePad(pScrn->bitsPerPixel * width);
       pSiS->ShadowPtr = xalloc(pSiS->ShadowPitch * height);
       displayWidth = pSiS->ShadowPitch / (pScrn->bitsPerPixel >> 3);
       FBStart = pSiS->ShadowPtr;
d4638 2
a4639 2
       pSiS->ShadowPtr = NULL;
       FBStart = pSiS->FbBase;
d4643 4
a4646 3
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       SISErrorLog(pScrn, "miSetPixmapDepths() failed\n");
       return FALSE;
a4648 5
    /* Point cmdQueuePtr to pSiSEnt for shared usage
     * (same technique is then eventually used in DRIScreeninit)
     * For 315/330 series, this is done in EnableTurboQueue
     * which has already been called during ModeInit().
     */
d4651 1
a4651 1
       pSiS->cmdQueueLenPtr = &(SISPTR(pSiSEnt->pScrn_1)->cmdQueueLen);
d4654 1
a4654 1
       pSiS->cmdQueueLenPtr = &(pSiS->cmdQueueLen);
d4656 1
a4656 1
    pSiS->cmdQueueLen = 0; /* Force an EngineIdle() at start */
a4658 1
    if(pSiS->loadDRI) {
d4660 4
a4663 4
       /* No DRI in dual head mode */
       if(pSiS->DualHeadMode) {
          pSiS->directRenderingEnabled = FALSE;
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d4665 1
a4665 1
       } else
d4667 3
a4669 3
          /* Force the initialization of the context */
              if(pSiS->VGAEngine != SIS_315_VGA) {
          pSiS->directRenderingEnabled = SISDRIScreenInit(pScreen);
d4672 1
a4672 1
	        "DRI not supported on this chipset\n");
a4674 1
    }
d4681 1
d4683 10
a4692 5
      case 24:
        if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	   ret = FALSE;
	   break;
        }
d4695 1
d4700 2
d4704 4
a4707 1
        ret = FALSE;
d4710 5
a4714 5
    if(!ret) {
       SISErrorLog(pScrn, "Unsupported bpp (%d) or fbScreenInit() failed\n",
               pScrn->bitsPerPixel);
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       return FALSE;
d4718 14
a4731 12
       /* Fixup RGB ordering */
       visual = pScreen->visuals + pScreen->numVisuals;
       while (--visual >= pScreen->visuals) {
          if((visual->class | DynamicClass) == DirectColor) {
             visual->offsetRed = pScrn->offset.red;
             visual->offsetGreen = pScrn->offset.green;
             visual->offsetBlue = pScrn->offset.blue;
             visual->redMask = pScrn->mask.red;
             visual->greenMask = pScrn->mask.green;
             visual->blueMask = pScrn->mask.blue;
          }
       }
d4735 1
a4735 1
    fbPictureInit(pScreen, 0, 0);
d4738 1
a4738 1
    if(!pSiS->ShadowFB) SISDGAInit(pScreen);
d4743 1
a4743 1
       switch(pSiS->VGAEngine) {
d4749 1
a4749 1
	    SiS315AccelInit(pScreen);
d4753 1
a4753 1
       }
d4762 2
a4763 3
    if(pSiS->HWCursor) {
       SiSHWCursorInit(pScreen);
    }
d4767 4
a4770 3
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       SISErrorLog(pScrn, "miCreateDefColormap() failed\n");
       return FALSE;
d4772 1
a4772 1

d4776 4
a4779 3
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       SISErrorLog(pScrn, "xf86HandleColormaps() failed\n");
       return FALSE;
a4781 8
#if 0
    if((pSiS->GammaBriR != 1000) || (pSiS->GammaBriG != 1000) ||
       (pSiS->GammaBriB != 1000) || (pSiS->GammaPBriR != 1000) ||
       (pSiS->GammaPBriG != 1000) || (pSiS->GammaPBriB != 1000)) {
       SISCalculateGammaRamp(pScrn);
    }
#endif

a4796 5
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,0,0,0)
	  xf86DisableRandR();
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	  	"Driver rotation enabled, RandR disabled\n");
#endif
d4800 9
a4808 3
    }

    xf86DPMSInit(pScreen, (DPMSSetProcPtr)SISDisplayPowerManagementSet, 0);
a4812 2
    
    pSiS->ResetXv = pSiS->ResetXvGamma = NULL;
d4814 1
a4814 1
#if (XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,99,0,0)) || (defined(XvExtension))
a4815 2
        if( (pSiS->VGAEngine == SIS_300_VGA) ||
	    (pSiS->VGAEngine == SIS_315_VGA) ) {
d4817 26
a4842 11
              if(pSiS->DualHeadMode) {
		 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		     "Using SiS300/315 series HW Xv on CRT%d\n",
		     (pSiS->SecondHead ? 1 : 2));
		 if(!pSiS->hasTwoOverlays) {
		    if( (pSiS->XvOnCRT2 && pSiS->SecondHead) ||
		        (!pSiS->XvOnCRT2 && !pSiS->SecondHead) ) {
		       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		           "However, overlay will by default only be visible on CRT%d\n",
		           pSiS->XvOnCRT2 ? 2 : 1);
		    }
a4843 1
                 SISInitVideo(pScreen);
d4846 3
a4848 3
	        if(pSiS->hasTwoOverlays)
                   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Using SiS300/315/330 series HW Xv\n" );
d4850 3
a4852 3
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Using SiS300/315/330 series HW Xv by default on CRT%d\n",
		       (pSiS->XvOnCRT2 ? 2 : 1));
d4857 1
a4860 1

d4864 1
a4864 1

d4871 1
a4871 1
            if(n) {
d4875 3
a4877 1

d4883 5
a4887 14
    if(pSiS->loadDRI) {
       if(pSiS->directRenderingEnabled) {
          /* Now that mi, drm and others have done their thing,
           * complete the DRI setup.
           */
          pSiS->directRenderingEnabled = SISDRIFinishScreenInit(pScreen);
       }
       if(pSiS->directRenderingEnabled) {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Direct rendering enabled\n");
          /* TODO */
          /* SISSetLFBConfig(pSiS); */
       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Direct rendering disabled\n");
       }
d4889 6
a4894 25
#endif

    /* Wrap some funcs and setup remaining SD flags */

    pSiS->SiS_SD_Flags &= ~(SiS_SD_PSEUDOXINERAMA);
#ifdef SISMERGED
    if(pSiS->MergedFB) {
       pSiS->PointerMoved = pScrn->PointerMoved;
       pScrn->PointerMoved = SISMergePointerMoved;
       pSiS->Rotate = FALSE;
       pSiS->ShadowFB = FALSE;
#ifdef SISXINERAMA
       if(pSiS->UseSiSXinerama) {
          SiSnoPanoramiXExtension = FALSE;
          SiSXineramaExtensionInit(pScrn);
	  if(!SiSnoPanoramiXExtension) {
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,0,0,0)
             xf86DisableRandR();
             xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	  	 "SiS Pseudo-Xinerama enabled, RandR disabled\n");
#endif
	     pSiS->SiS_SD_Flags |= SiS_SD_PSEUDOXINERAMA;
	  }
       }
#endif
d4902 1
a4902 1
       pScreen->SaveScreen = SISSaveScreenDH;
d4905 1
a4905 1
       pScreen->SaveScreen = SISSaveScreen;
d4913 1
a4913 1
       xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
a4915 11
    /* Clear frame buffer */
    /* For CRT2, we don't do that at this point in dual head
     * mode since the mode isn't switched at this time (it will
     * be reset when setting the CRT1 mode). Hence, we just
     * save the necessary data and clear the screen when
     * going through this for CRT1.
     */
     
    OnScreenSize = pScrn->displayWidth * pScrn->currentMode->VDisplay
                               * (pScrn->bitsPerPixel >> 3);

d4917 1
a4917 1
    /* We do this in dual head mode after second head is finished */
d4920 3
a4922 14
       if(pSiS->SecondHead) {
          bzero(pSiS->FbBase, OnScreenSize);
	  bzero(pSiSEnt->FbBase1, pSiSEnt->OnScreenSize1);
    	  SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       } else {
          pSiSEnt->FbBase1 = pSiS->FbBase;
	  pSiSEnt->OnScreenSize1 = OnScreenSize;
       }
    } else {
#endif
       SISSaveScreen(pScreen, SCREEN_SAVER_OFF);
       bzero(pSiS->FbBase, OnScreenSize);
#ifdef SISDUALHEAD
    }
d4924 1
a4924 6

    pSiS->SiS_SD_Flags &= ~SiS_SD_ISDEPTH8;
    if(pSiS->CurrentLayout.bitsPerPixel == 8) {
    	pSiS->SiS_SD_Flags |= SiS_SD_ISDEPTH8;
	pSiS->SiS_SD_Flags &= ~SiS_SD_SUPPORTXVGAMMA1;
    }
d4936 5
a4940 534
    if(!pSiS->NoAccel) {
       if(pSiS->AccelInfoPtr) {
          (*pSiS->AccelInfoPtr->Sync)(pScrn);
       }
    }

    if(!(SISModeInit(xf86Screens[scrnIndex], mode))) return FALSE;

    /* Since RandR (indirectly) uses SwitchMode(), we need to
     * update our Xinerama info here, too, in case of resizing
     */
#ifdef SISMERGED
#ifdef SISXINERAMA
    if(pSiS->MergedFB) {
       SiSUpdateXineramaScreenInfo(pScrn);
    }
#endif
#endif
    return TRUE;
}

Bool
SISSwitchCRT2Type(ScrnInfoPtr pScrn, unsigned long newvbflags)
{
    SISPtr pSiS = SISPTR(pScrn);
    BOOLEAN hcm;
    DisplayModePtr mode = pScrn->currentMode;

    /* Do NOT use this to switch from CRT2_LCD to CRT1_LCDA */

    /* Only on 300 and 315/330 series */
    if(pSiS->VGAEngine != SIS_300_VGA &&
       pSiS->VGAEngine != SIS_315_VGA) return FALSE;

    /* Only if there is a video bridge */
    if(!(pSiS->VBFlags & VB_VIDEOBRIDGE)) return FALSE;

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) return FALSE;
#endif

#define SiS_NewVBMask (CRT2_ENABLE|CRT1_LCDA|TV_PAL|TV_NTSC|TV_PALM|TV_PALN|TV_NTSCJ| \
		       TV_AVIDEO|TV_SVIDEO|TV_SCART|TV_HIVISION|TV_YPBPR|TV_YPBPRALL|\
		       TV_YPBPRAR)

    newvbflags &= SiS_NewVBMask;
    newvbflags |= pSiS->VBFlags & ~SiS_NewVBMask;

    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTLCDA)) {
       newvbflags &= ~CRT1_LCDA;
    }
    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTHIVISION)) {
       newvbflags &= ~TV_HIVISION;
    }
    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPR)) {
       newvbflags &= ~TV_YPBPR;
    }

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       if(!(newvbflags & CRT2_ENABLE)) {
	  xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	   	"CRT2 can't be switched off in MergedFB mode\n");
	  return FALSE;
       }
       hcm = pSiS->HaveCustomModes2;
       if(mode->Private) {
	  mode = ((SiSMergedDisplayModePtr)mode->Private)->CRT2;
       }
    } else
#endif
       hcm = pSiS->HaveCustomModes;

    if((!(newvbflags & CRT2_ENABLE)) && (!newvbflags & DISPTYPE_CRT1)) {
       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
          "CRT2 can't be switched off while CRT1 is off\n");
       return FALSE;
    }

    /* CRT2_LCD overrules LCDA */
    if(newvbflags & CRT2_LCD) {
       newvbflags &= ~CRT1_LCDA;
    }

    /* Check if the current mode is suitable for desired output device (if any) */
    if(newvbflags & CRT2_ENABLE) {
       if(!SiS_CheckCalcModeIndex(pScrn, mode, newvbflags, hcm)) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	     "Current mode not suitable for desired CRT2 output device\n");
          return FALSE;
       }
    }

    /* Remember: Dualhead not supported */
    newvbflags &= ~(SINGLE_MODE | MIRROR_MODE);
    if((newvbflags & DISPTYPE_CRT1) && (newvbflags & CRT2_ENABLE)) {
       newvbflags |= MIRROR_MODE;
    } else {
       newvbflags |= SINGLE_MODE;
    }

    /* Sync the accelerators */
    if(!pSiS->NoAccel) {
       if(pSiS->AccelInfoPtr) {
          (*pSiS->AccelInfoPtr->Sync)(pScrn);
       }
    }

    pSiS->VBFlags = pSiS->VBFlags_backup = newvbflags;

    if(!(pScrn->SwitchMode(pScrn->scrnIndex, pScrn->currentMode, 0))) return FALSE;
    SISAdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
    return TRUE;
}

int
SISCheckModeIndexForCRT2Type(ScrnInfoPtr pScrn, unsigned short cond, unsigned short index, Bool quiet)
{
    SISPtr pSiS = SISPTR(pScrn);
    BOOLEAN hcm = pSiS->HaveCustomModes;
    DisplayModePtr mode = pScrn->modes, mastermode;
    int i, result = 0;
    unsigned long vbflags = pSiS->VBFlags;

    /* Not only CRT2, but also LCDA */

    /* returns 0 if mode ok,
     *         0x01 if mode not ok for CRT2 device,
     *         0x02 if mode too large for current root window
     *         or combinations thereof
     */

    /* No special treatment for NTSC-J here; conditions equal NTSC */
    if(cond) {
       vbflags &= ~(CRT2_ENABLE | CRT1_LCDA | TV_STANDARD | TV_INTERFACE);
       if((cond & SiS_CF2_TYPEMASK) == SiS_CF2_LCD) {
       	  vbflags |= CRT2_LCD;
       } else if((cond & SiS_CF2_TYPEMASK) == SiS_CF2_TV) {
          vbflags |= (CRT2_TV | TV_SVIDEO);
	  if(cond & SiS_CF2_TVPAL)  	  vbflags |= TV_PAL;
	  else if(cond & SiS_CF2_TVPALM)  vbflags |= (TV_PAL | TV_PALM);
	  else if(cond & SiS_CF2_TVPALN)  vbflags |= (TV_PAL | TV_PALN);
	  else if(cond & SiS_CF2_TVNTSC)  vbflags |= TV_NTSC;
       } else if((cond & SiS_CF2_TYPEMASK) == SiS_CF2_TVSPECIAL) {
          vbflags |= CRT2_TV;
	  if((cond & SiS_CF2_TVSPECMASK) == SiS_CF2_TVHIVISION)
	  	vbflags |= TV_HIVISION;
	  else if((cond & SiS_CF2_TVSPECMASK) == SiS_CF2_TVYPBPR525I)
	  	vbflags |= (TV_YPBPR | TV_YPBPR525I);
	  else if((cond & SiS_CF2_TVSPECMASK) == SiS_CF2_TVYPBPR525P)
	  	vbflags |= (TV_YPBPR | TV_YPBPR525P);
	  else if((cond & SiS_CF2_TVSPECMASK) == SiS_CF2_TVYPBPR750P)
	  	vbflags |= (TV_YPBPR | TV_YPBPR750P);
	  else if((cond & SiS_CF2_TVSPECMASK) == SiS_CF2_TVYPBPR1080I)
	  	vbflags |= (TV_YPBPR | TV_YPBPR1080I);
       } else if((cond & SiS_CF2_TYPEMASK) == SiS_CF2_VGA2) {
          vbflags |= CRT2_VGA;
       } else if((cond & SiS_CF2_TYPEMASK) == SiS_CF2_CRT1LCDA) {
          vbflags |= CRT1_LCDA;
       }
    }

    /* Find mode of given index */
    if(index) {
       for(i = 0; i < index; i++) {
          if(!mode) return 0x03;
          mode = mode->next;
       }
    }

    mastermode = mode;

#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead)) {
#endif

       if(vbflags & CRT2_ENABLE) {

#ifdef SISMERGED
          if(pSiS->MergedFB) {
             hcm = pSiS->HaveCustomModes2;
             if(mode->Private) {
	        mode = ((SiSMergedDisplayModePtr)mode->Private)->CRT2;
             }
          }
#endif

          /* For RandR */
          if((mode->HDisplay > pScrn->virtualX) || (mode->VDisplay > pScrn->virtualY)) {
             if(!quiet) {
                xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Desired mode too large for current screen size\n");
             }
             result |= 0x02;
          }

          /* Check if the desired mode is suitable for current CRT2 output device */
          if(!SiS_CheckCalcModeIndex(pScrn, mode, vbflags, hcm)) {
             if((!cond) && (!quiet)) {
                xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		    "Desired mode not suitable for current CRT2 output device\n");
             }
             result |= 0x01;
          }

       }

#ifdef SISDUALHEAD
    }
#endif

    mode = mastermode;

#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (pSiS->SecondHead)) {
#endif

       if(vbflags & CRT1_LCDA) {

#ifdef SISMERGED
          if(pSiS->MergedFB) {
             hcm = pSiS->HaveCustomModes;
             if(mode->Private) {
	        mode = ((SiSMergedDisplayModePtr)mode->Private)->CRT1;
	     }
          }
#endif

 	  /* For RandR */
          if((mode->HDisplay > pScrn->virtualX) || (mode->VDisplay > pScrn->virtualY)) {
             if(!quiet) {
                xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			"Desired mode too large for current screen size\n");
             }
             result |= 0x02;
          }

          /* Check if the desired mode is suitable for current CRT1 output device */
          if(!SiS_CalcModeIndex(pScrn, mode, vbflags, hcm)) {
             if((!cond) && (!quiet)) {
                 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	  	      "Desired mode not suitable for current CRT1 output device\n");
             }
             result |= 0x01;
          }

       }

#ifdef SISDUALHEAD
    }
#endif

    return result;
}

Bool
SISSwitchCRT1Status(ScrnInfoPtr pScrn, int onoff)
{
    SISPtr pSiS = SISPTR(pScrn);
    DisplayModePtr mode = pScrn->currentMode;
    unsigned long vbflags = pSiS->VBFlags;
    int crt1off;

    /* onoff: 0=OFF, 1=ON(VGA), 2=ON(LCDA) */
    /* Switching to LCDA will disable CRT2 if previously LCD */

    /* Do NOT use this to switch from CRT1_LCDA to CRT2_LCD */

    /* Only on 300 and 315/330 series */
    if(pSiS->VGAEngine != SIS_300_VGA &&
       pSiS->VGAEngine != SIS_315_VGA) return FALSE;

    /* Off only if at least one CRT2 device is active */
    if((!onoff) && (!(vbflags & CRT2_ENABLE))) return FALSE;

#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) return FALSE;
#endif

    /* Can't switch to LCDA of not supported (duh!) */
    if(!(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTLCDA)) {
       if(onoff == 2) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	   	"LCD-via-CRT1 not supported on this hardware\n");
          return FALSE;
       }
    }

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       if(!onoff) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	   	"CRT1 can't be switched off in MergedFB mode\n");
          return FALSE;
       } else if(onoff == 2) {
          if(vbflags & CRT2_LCD) {
	     xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	   	"CRT2 type can't be LCD while CRT1 is LCD-via-CRT1\n");
             return FALSE;
	  }
       }
       if(mode->Private) {
	  mode = ((SiSMergedDisplayModePtr)mode->Private)->CRT1;
       }
    }
#endif

    vbflags &= ~(DISPTYPE_CRT1 | SINGLE_MODE | MIRROR_MODE | CRT1_LCDA);
    crt1off = 1;
    if(onoff > 0) {
       vbflags |= DISPTYPE_CRT1;
       crt1off = 0;
       if(onoff == 2) {
       	  vbflags |= CRT1_LCDA;
	  vbflags &= ~CRT2_LCD;
       }
       /* Remember: Dualhead not supported */
       if(vbflags & CRT2_ENABLE) vbflags |= MIRROR_MODE;
       else vbflags |= SINGLE_MODE;
    } else {
       vbflags |= SINGLE_MODE;
    }

    if(vbflags & CRT1_LCDA) {
       if(!SiS_CalcModeIndex(pScrn, mode, vbflags, pSiS->HaveCustomModes)) {
          xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		"Current mode not suitable for LCD-via-CRT1\n");
          return FALSE;
       }
    }

    pSiS->CRT1off = crt1off;
    pSiS->VBFlags = pSiS->VBFlags_backup = vbflags;

    /* Sync the accelerators */
    if(!pSiS->NoAccel) {
       if(pSiS->AccelInfoPtr) {
          (*pSiS->AccelInfoPtr->Sync)(pScrn);
       }
    }

    if(!(pScrn->SwitchMode(pScrn->scrnIndex, pScrn->currentMode, 0))) return FALSE;
    SISAdjustFrame(pScrn->scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
    return TRUE;
}

static void
SISSetStartAddressCRT1(SISPtr pSiS, unsigned long base)
{
    unsigned char cr11backup;

    inSISIDXREG(SISCR,  0x11, cr11backup);  /* Unlock CRTC registers */
    andSISIDXREG(SISCR, 0x11, 0x7F);
    outSISIDXREG(SISCR, 0x0D, base & 0xFF);
    outSISIDXREG(SISCR, 0x0C, (base >> 8) & 0xFF);
    outSISIDXREG(SISSR, 0x0D, (base >> 16) & 0xFF);
    if(pSiS->VGAEngine == SIS_315_VGA) {
       setSISIDXREG(SISSR, 0x37, 0xFE, (base >> 24) & 0x01);
    }
    /* Eventually lock CRTC registers */
    setSISIDXREG(SISCR, 0x11, 0x7F,(cr11backup & 0x80));
}

static void
SISSetStartAddressCRT2(SISPtr pSiS, unsigned long base)
{
    SiS_UnLockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
    outSISIDXREG(SISPART1, 0x06, GETVAR8(base));
    outSISIDXREG(SISPART1, 0x05, GETBITS(base, 15:8));
    outSISIDXREG(SISPART1, 0x04, GETBITS(base, 23:16));
    if(pSiS->VGAEngine == SIS_315_VGA) {
       setSISIDXREG(SISPART1, 0x02, 0x7F, ((base >> 24) & 0x01) << 7);
    }
    SiS_LockCRT2(pSiS->SiS_Pr, &pSiS->sishw_ext);
}

#ifdef SISMERGED
static Bool
InRegion(int x, int y, region r)
{
    return (r.x0 <= x) && (x <= r.x1) && (r.y0 <= y) && (y <= r.y1);
}

static void
SISAdjustFrameHW_CRT1(ScrnInfoPtr pScrn, int x, int y)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned long base;

    base = y * pSiS->CurrentLayout.displayWidth + x;
    switch(pSiS->CurrentLayout.bitsPerPixel) {
       case 16:  base >>= 1; 	break;
       case 32:  		break;
       default:  base >>= 2;
    }
    SISSetStartAddressCRT1(pSiS, base);
}

static void
SISAdjustFrameHW_CRT2(ScrnInfoPtr pScrn, int x, int y)
{
    SISPtr pSiS = SISPTR(pScrn);
    unsigned long base;

    base = y * pSiS->CurrentLayout.displayWidth + x;
    switch(pSiS->CurrentLayout.bitsPerPixel) {
       case 16:  base >>= 1; 	break;
       case 32:  		break;
       default:  base >>= 2;
    }
    SISSetStartAddressCRT2(pSiS, base);
}

static void
SISMergePointerMoved(int scrnIndex, int x, int y)
{
  ScrnInfoPtr   pScrn1 = xf86Screens[scrnIndex];
  SISPtr        pSiS = SISPTR(pScrn1);
  ScrnInfoPtr   pScrn2 = pSiS->CRT2pScrn;
  region 	out, in1, in2, f2, f1;
  int 		deltax, deltay;

  f1.x0 = pSiS->CRT1frameX0;
  f1.x1 = pSiS->CRT1frameX1;
  f1.y0 = pSiS->CRT1frameY0;
  f1.y1 = pSiS->CRT1frameY1;
  f2.x0 = pScrn2->frameX0;
  f2.x1 = pScrn2->frameX1;
  f2.y0 = pScrn2->frameY0;
  f2.y1 = pScrn2->frameY1;

  /* Define the outer region. Crossing this causes all frames to move */
  out.x0 = pScrn1->frameX0;
  out.x1 = pScrn1->frameX1;
  out.y0 = pScrn1->frameY0;
  out.y1 = pScrn1->frameY1;

  /*
   * Define the inner sliding window. Being outsize both frames but
   * inside the outer clipping window will slide corresponding frame
   */
  in1 = out;
  in2 = out;
  switch(((SiSMergedDisplayModePtr)pSiS->CurrentLayout.mode->Private)->CRT2Position) {
     case sisLeftOf:
        in1.x0 = f1.x0;
        in2.x1 = f2.x1;
        break;
     case sisRightOf:
        in1.x1 = f1.x1;
        in2.x0 = f2.x0;
        break;
     case sisBelow:
        in1.y1 = f1.y1;
        in2.y0 = f2.y0;
        break;
     case sisAbove:
        in1.y0 = f1.y0;
        in2.y1 = f2.y1;
        break;
     case sisClone:
        break;
  }

  deltay = 0;
  deltax = 0;

  if(InRegion(x, y, out)) {	/* inside outer region */

     if(InRegion(x, y, in1) && !InRegion(x, y, f1)) {
        REBOUND(f1.x0, f1.x1, x);
        REBOUND(f1.y0, f1.y1, y);
        deltax = 1;
     }
     if(InRegion(x, y, in2) && !InRegion(x, y, f2)) {
        REBOUND(f2.x0, f2.x1, x);
        REBOUND(f2.y0, f2.y1, y);
        deltax = 1;
     }

  } else {			/* outside outer region */

     if(out.x0 > x) {
        deltax = x - out.x0;
     }
     if(out.x1 < x) {
        deltax = x - out.x1;
     }
     if(deltax) {
        pScrn1->frameX0 += deltax;
        pScrn1->frameX1 += deltax;
	f1.x0 += deltax;
        f1.x1 += deltax;
        f2.x0 += deltax;
        f2.x1 += deltax;
     }

     if(out.y0 > y) {
        deltay = y - out.y0;
     }
     if(out.y1 < y) {
        deltay = y - out.y1;
     }
     if(deltay) {
        pScrn1->frameY0 += deltay;
        pScrn1->frameY1 += deltay;
	f1.y0 += deltay;
        f1.y1 += deltay;
        f2.y0 += deltay;
        f2.y1 += deltay;
     }

     switch(((SiSMergedDisplayModePtr)pSiS->CurrentLayout.mode->Private)->CRT2Position) {
        case sisLeftOf:
	   if(x >= f1.x0) { REBOUND(f1.y0, f1.y1, y); }
	   if(x <= f2.x1) { REBOUND(f2.y0, f2.y1, y); }
           break;
        case sisRightOf:
	   if(x <= f1.x1) { REBOUND(f1.y0, f1.y1, y); }
	   if(x >= f2.x0) { REBOUND(f2.y0, f2.y1, y); }
           break;
        case sisBelow:
	   if(y <= f1.y1) { REBOUND(f1.x0, f1.x1, x); }
	   if(y >= f2.y0) { REBOUND(f2.x0, f2.x1, x); }
           break;
        case sisAbove:
	   if(y >= f1.y0) { REBOUND(f1.x0, f1.x1, x); }
	   if(y <= f2.y1) { REBOUND(f2.x0, f2.x1, x); }
           break;
        case sisClone:
           break;
     }

  }
d4942 1
a4942 16
  if(deltax || deltay) {
     pSiS->CRT1frameX0 = f1.x0;
     pSiS->CRT1frameY0 = f1.y0;
     pScrn2->frameX0 = f2.x0;
     pScrn2->frameY0 = f2.y0;

     pSiS->CRT1frameX1 = pSiS->CRT1frameX0 + CDMPTR->CRT1->HDisplay - 1;
     pSiS->CRT1frameY1 = pSiS->CRT1frameY0 + CDMPTR->CRT1->VDisplay - 1;
     pScrn2->frameX1   = pScrn2->frameX0   + CDMPTR->CRT2->HDisplay - 1;
     pScrn2->frameY1   = pScrn2->frameY0   + CDMPTR->CRT2->VDisplay - 1;
     pScrn1->frameX1   = pScrn1->frameX0   + pSiS->CurrentLayout.mode->HDisplay  - 1;
     pScrn1->frameY1   = pScrn1->frameY0   + pSiS->CurrentLayout.mode->VDisplay  - 1;

     SISAdjustFrameHW_CRT1(pScrn1, pSiS->CRT1frameX0, pSiS->CRT1frameY0);
     SISAdjustFrameHW_CRT2(pScrn1, pScrn2->frameX0, pScrn2->frameY0);
  }
d4945 4
a4948 2
static void
SISAdjustFrameMerged(int scrnIndex, int x, int y, int flags)
d4950 30
a4979 42
    ScrnInfoPtr pScrn1 = xf86Screens[scrnIndex];
    SISPtr pSiS = SISPTR(pScrn1);
    ScrnInfoPtr pScrn2 = pSiS->CRT2pScrn;
    int VTotal = pSiS->CurrentLayout.mode->VDisplay;
    int HTotal = pSiS->CurrentLayout.mode->HDisplay;
    int VMax = VTotal;
    int HMax = HTotal;

    BOUND(x, 0, pScrn1->virtualX - HTotal);
    BOUND(y, 0, pScrn1->virtualY - VTotal);

    switch(SDMPTR(pScrn1)->CRT2Position) {
        case sisLeftOf:
            pScrn2->frameX0 = x;
            BOUND(pScrn2->frameY0,   y, y + VMax - CDMPTR->CRT2->VDisplay);
            pSiS->CRT1frameX0 = x + CDMPTR->CRT2->HDisplay;
            BOUND(pSiS->CRT1frameY0, y, y + VMax - CDMPTR->CRT1->VDisplay);
            break;
        case sisRightOf:
            pSiS->CRT1frameX0 = x;
            BOUND(pSiS->CRT1frameY0, y, y + VMax - CDMPTR->CRT1->VDisplay);
            pScrn2->frameX0 = x + CDMPTR->CRT1->HDisplay;
            BOUND(pScrn2->frameY0,   y, y + VMax - CDMPTR->CRT2->VDisplay);
            break;
        case sisAbove:
            BOUND(pScrn2->frameX0,   x, x + HMax - CDMPTR->CRT2->HDisplay);
            pScrn2->frameY0 = y;
            BOUND(pSiS->CRT1frameX0, x, x + HMax - CDMPTR->CRT1->HDisplay);
            pSiS->CRT1frameY0 = y + CDMPTR->CRT2->VDisplay;
            break;
        case sisBelow:
            BOUND(pSiS->CRT1frameX0, x, x + HMax - CDMPTR->CRT1->HDisplay);
            pSiS->CRT1frameY0 = y;
            BOUND(pScrn2->frameX0,   x, x + HMax - CDMPTR->CRT2->HDisplay);
            pScrn2->frameY0 = y + CDMPTR->CRT1->VDisplay;
            break;
        case sisClone:
            BOUND(pSiS->CRT1frameX0, x, x + HMax - CDMPTR->CRT1->HDisplay);
            BOUND(pSiS->CRT1frameY0, y, y + VMax - CDMPTR->CRT1->VDisplay);
            BOUND(pScrn2->frameX0,   x, x + HMax - CDMPTR->CRT2->HDisplay);
            BOUND(pScrn2->frameY0,   y, y + VMax - CDMPTR->CRT2->VDisplay);
            break;
d4982 6
a4987 7
    BOUND(pSiS->CRT1frameX0, 0, pScrn1->virtualX - CDMPTR->CRT1->HDisplay);
    BOUND(pSiS->CRT1frameY0, 0, pScrn1->virtualY - CDMPTR->CRT1->VDisplay);
    BOUND(pScrn2->frameX0,   0, pScrn1->virtualX - CDMPTR->CRT2->HDisplay);
    BOUND(pScrn2->frameY0,   0, pScrn1->virtualY - CDMPTR->CRT2->VDisplay);
    
    pScrn1->frameX0 = x;
    pScrn1->frameY0 = y;
d4989 2
a4990 6
    pSiS->CRT1frameX1 = pSiS->CRT1frameX0 + CDMPTR->CRT1->HDisplay - 1;
    pSiS->CRT1frameY1 = pSiS->CRT1frameY0 + CDMPTR->CRT1->VDisplay - 1;
    pScrn2->frameX1   = pScrn2->frameX0   + CDMPTR->CRT2->HDisplay - 1;
    pScrn2->frameY1   = pScrn2->frameY0   + CDMPTR->CRT2->VDisplay - 1;
    pScrn1->frameX1   = pScrn1->frameX0   + pSiS->CurrentLayout.mode->HDisplay  - 1;
    pScrn1->frameY1   = pScrn1->frameY0   + pSiS->CurrentLayout.mode->VDisplay  - 1;
d4992 1
a4992 2
    SISAdjustFrameHW_CRT1(pScrn1, pSiS->CRT1frameX0, pSiS->CRT1frameY0);
    SISAdjustFrameHW_CRT2(pScrn1, pScrn2->frameX0, pScrn2->frameY0);
a4998 2
 *
 * Usually mandatory
d5000 1
d5004 10
a5013 11
    ScrnInfoPtr   pScrn = xf86Screens[scrnIndex];
    SISPtr        pSiS = SISPTR(pScrn);
    unsigned long base;
    unsigned char temp, cr11backup;

#ifdef SISMERGED
    if(pSiS->MergedFB) {
    	SISAdjustFrameMerged(scrnIndex, x, y, flags);
	return;
    }
#endif
d5016 2
a5018 2
	return;
    }
a5019 2
    if(pScrn->bitsPerPixel < 8) {
       base = (y * pSiS->CurrentLayout.displayWidth + x + 3) >> 3;
a5020 18
       base  = y * pSiS->CurrentLayout.displayWidth + x;

       /* calculate base bpp dep. */
       switch(pSiS->CurrentLayout.bitsPerPixel) {
          case 16:
     	     base >>= 1;
             break;
          case 24:
             base = ((base * 3)) >> 2;
             base -= base % 6;
             break;
          case 32:
             break;
          default:      /* 8bpp */
             base >>= 2;
             break;
       }
    }
d5023 1
a5023 1
    sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
d5026 49
a5074 11
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       if(!pSiS->SecondHead) {
	  /* Head 1 (master) is always CRT2 */
          SISSetStartAddressCRT2(pSiS, base);
       } else {
          /* TW: Head 2 (slave) is always CRT1 */
	  base += (pSiS->dhmOffset/4);
	  SISSetStartAddressCRT1(pSiS, base);
       }
    } else {
d5076 35
a5110 21
       switch(pSiS->VGAEngine) {
          case SIS_300_VGA:
	  case SIS_315_VGA:
	     SISSetStartAddressCRT1(pSiS, base);
             if(pSiS->VBFlags & CRT2_ENABLE) {
		SISSetStartAddressCRT2(pSiS, base);
	     }
             break;
          default:
	     /* Unlock CRTC registers */
             inSISIDXREG(SISCR,  0x11, cr11backup);
             andSISIDXREG(SISCR, 0x11, 0x7F);
	     outSISIDXREG(SISCR, 0x0D, base & 0xFF);
	     outSISIDXREG(SISCR, 0x0C, (base >> 8) & 0xFF);
	     inSISIDXREG(SISSR,  0x27, temp);
	     temp &= 0xF0;
	     temp |= (base & 0x0F0000) >> 16;
	     outSISIDXREG(SISSR, 0x27, temp);
	     /* Eventually lock CRTC registers */
	     setSISIDXREG(SISCR, 0x11, 0x7F, (cr11backup & 0x80));
       }
d5112 1
a5112 1
    }
d5114 1
d5118 1
a5131 6
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       outSISIDXREG(SISCR,0x32,pSiS->myCR32);
       outSISIDXREG(SISCR,0x36,pSiS->myCR36);
       outSISIDXREG(SISCR,0x37,pSiS->myCR37);
    }

d5133 3
a5135 2
       SISErrorLog(pScrn, "SiSEnterVT: SISModeInit() failed\n");
       return FALSE;
d5141 3
a5143 7
    if(pSiS->directRenderingEnabled) {
       DRIUnlock(screenInfo.screens[scrnIndex]);
    }
#endif

#ifdef SISDUALHEAD
    if((!pSiS->DualHeadMode) || (!pSiS->SecondHead))
a5144 3
       if(pSiS->ResetXv) {
          (pSiS->ResetXv)(pScrn);
       }
d5163 1
d5165 2
a5166 2
       pScreen = screenInfo.screens[scrnIndex];
       DRILock(pScreen, 0);
d5178 4
a5181 4
	     pSiS->ForceCursorOff = TRUE;
	     pSiS->CursorInfoPtr->HideCursor(pScrn);
	     SISWaitVBRetrace(pScrn);
	     pSiS->ForceCursorOff = FALSE;
d5183 1
a5183 1
       } else {
d5196 7
a5202 7
       /* This is a q&d work-around for a BIOS bug. In case we disabled CRT2,
    	* VBESaveRestore() does not restore CRT1. So we set any mode now,
	* because VBESetVBEMode correctly restores CRT1. Afterwards, we
	* can call VBESaveRestore to restore original mode.
	*/
       if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (!(pSiS->VBFlags & DISPTYPE_DISP2)))
	  VBESetVBEMode(pSiS->pVbe, (pSiS->SISVESAModeList->n) | 0xc000, NULL);
d5204 1
a5204 1
       SISVESARestore(pScrn);
d5207 1
a5207 1

d5209 1
a5209 10

    }

    /* We use (otherwise unused) bit 7 to indicate that we are running
     * to keep sisfb to change the displaymode (this would result in
     * lethal display corruption upon quitting X or changing to a VT
     * until a reboot)
     */
    if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {
       orSISIDXREG(SISCR,0x34,0x80);
d5233 2
a5234 2
       SISDRICloseScreen(pScreen);
       pSiS->directRenderingEnabled = FALSE;
d5241 1
a5241 1
#ifdef SISDUALHEAD
d5249 1
a5249 1
           } else {
d5253 3
a5255 3
#ifdef SISDUALHEAD
           }
#endif
d5262 4
a5265 4
	  /* This is a q&d work-around for a BIOS bug. In case we disabled CRT2,
    	   * VBESaveRestore() does not restore CRT1. So we set any mode now,
	   * because VBESetVBEMode correctly restores CRT1. Afterwards, we
	   * can call VBESaveRestore to restore original mode.
d5267 2
a5268 2
           if((pSiS->VBFlags & VB_VIDEOBRIDGE) && (!(pSiS->VBFlags & DISPTYPE_DISP2)))
	      VBESetVBEMode(pSiS->pVbe, (pSiS->SISVESAModeList->n) | 0xc000, NULL);
a5278 1

a5280 7
    /* We should restore the mode number in case vtsema = false as well,
     * but since we haven't register access then we can't do it. I think
     * I need to rework the save/restore stuff, like saving the video
     * status when returning to the X server and by that save me the
     * trouble if sisfb was started from a textmode VT while X was on.
     */
    
d5283 1
a5283 1

d5286 2
a5287 2
       pSiSEnt = pSiS->entityPrivate;
       pSiSEnt->refCount--;
d5289 1
a5289 1
#endif
d5292 2
a5293 7
       xf86FreeInt10(pSiS->pInt);
       pSiS->pInt = NULL;
    }

    if(pSiS->AccelLinearScratch) {
       xf86FreeOffscreenLinear(pSiS->AccelLinearScratch);
       pSiS->AccelLinearScratch = NULL;
d5297 2
a5298 2
       XAADestroyInfoRec(pSiS->AccelInfoPtr);
       pSiS->AccelInfoPtr = NULL;
d5302 2
a5303 2
       xf86DestroyCursorInfoRec(pSiS->CursorInfoPtr);
       pSiS->CursorInfoPtr = NULL;
d5307 2
a5308 2
       xfree(pSiS->ShadowPtr);
       pSiS->ShadowPtr = NULL;
d5312 2
a5313 2
       xfree(pSiS->DGAModes);
       pSiS->DGAModes = NULL;
d5317 2
a5318 2
       xfree(pSiS->adaptor);
       pSiS->adaptor = NULL;
d5327 1
a5327 2

    return(*pScreen->CloseScreen)(scrnIndex, pScreen);
d5337 2
a5338 4
    if(xf86LoaderCheckSymbol("vgaHWFreeHWRec")) {
       vgaHWFreeHWRec(xf86Screens[scrnIndex]);
    }

d5345 2
a5346 1
static ModeStatus
d5353 4
a5356 4
       if(SiSCalcVESAModeIndex(pScrn, mode))
	  return(MODE_OK);
       else
	  return(MODE_BAD);
a5357 1

d5360 5
a5364 9
       if(pSiS->DualHeadMode) {
          if(pSiS->SecondHead) {
	     if(SiS_CalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	        return(MODE_BAD);
	  } else {
	     if(SiS_CheckCalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	        return(MODE_BAD);
	  }
       } else
d5366 1
a5366 13
#ifdef SISMERGED
       if(pSiS->MergedFB) {
	  if(!mode->Private) {
	     if(!pSiS->CheckForCRT2) {
	        if(SiS_CalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	           return(MODE_BAD);
	     } else {
	        if(SiS_CheckCalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes2) < 0x14)
	           return(MODE_BAD);
	     }
	  } else {
	     if(SiS_CalcModeIndex(pScrn, ((SiSMergedDisplayModePtr)mode->Private)->CRT1,
		                  pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
a5368 15
	     if(SiS_CheckCalcModeIndex(pScrn, ((SiSMergedDisplayModePtr)mode->Private)->CRT2,
		                  pSiS->VBFlags, pSiS->HaveCustomModes2) < 0x14)
	        return(MODE_BAD);
 	  }
       } else
#endif
              {

	  if(pSiS->VBFlags & CRT1_LCDA) {
	     if(SiS_CalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	        return(MODE_BAD);
	  }
	  if(SiS_CheckCalcModeIndex(pScrn, mode, pSiS->VBFlags, pSiS->HaveCustomModes) < 0x14)
	     return(MODE_BAD);
       }
d5370 1
a5370 1

d5374 3
a5376 4
/* Do screen blanking
 *
 * Mandatory
 */
d5382 1
a5382 1
    if((pScrn != NULL) && pScrn->vtSema) {
d5386 1
d5391 1
a5391 1
        if(pSiS->VBFlags & (CRT2_LCD | CRT1_LCDA)) {
d5393 13
a5405 1
	   if(pSiS->VGAEngine == SIS_300_VGA) {
d5407 7
a5413 19
	      if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	         if(!xf86IsUnblank(mode)) {
	            pSiS->Blank = TRUE;
	  	    SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
	         } else {
	            pSiS->Blank = FALSE;
	            SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	         }
	      } else if(pSiS->VBFlags & (VB_LVDS | VB_30xBDH)) {
	         if(!pSiS->Blank) {
	            inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
	         }
	         if(!xf86IsUnblank(mode)) {
    		    pSiS->Blank = TRUE;
		    outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
	         } else {
    		    pSiS->Blank = FALSE;
		    outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
	         }
d5415 1
d5417 1
a5417 1
	   } else if(pSiS->VGAEngine == SIS_315_VGA) {
d5419 3
a5421 30
	      if(!pSiS->Blank) {
		 inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		 if(pSiS->sishw_ext.jChipType >= SIS_661) pSiS->LCDon &= 0x0f;
	      }

	      if(pSiS->VBFlags & VB_CHRONTEL) {
	         if(!xf86IsUnblank(mode)) {
		    pSiS->Blank = TRUE;
		    SiS_Chrontel701xBLOff(pSiS->SiS_Pr);
	         } else {
	            pSiS->Blank = FALSE;
	            SiS_Chrontel701xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	         }
	      } else if(pSiS->VBFlags & VB_LVDS) {
	         if(!xf86IsUnblank(mode)) {
	            pSiS->Blank = TRUE;
	 	    outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
	         } else {
	            pSiS->Blank = FALSE;
	  	    outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
	         }
	      } else if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	         if(!xf86IsUnblank(mode)) {
	            pSiS->Blank = TRUE;
	  	    SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
	         } else {
	            pSiS->Blank = FALSE;
	            SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
	         }
	      }
d5423 24
d5457 1
a5457 1
/* SaveScreen for dual head mode */
a5461 1
    Bool checkit = FALSE;
d5463 1
a5463 1
    if((pScrn != NULL) && pScrn->vtSema) {
d5465 2
a5466 1
       SISPtr pSiS = SISPTR(pScrn);
d5468 2
a5469 1
       if((pSiS->SecondHead) && ((!(pSiS->VBFlags & CRT1_LCDA)) || (pSiS->VBFlags & VB_301C))) {
d5471 1
a5471 4
	  /* Slave head is always CRT1 */
	  if(pSiS->VBFlags & CRT1_LCDA) pSiS->Blank = xf86IsUnblank(mode) ? FALSE : TRUE;

	  return vgaHWSaveScreen(pScreen, mode);
d5473 1
a5473 4
       } else {

	  /* Master head is always CRT2 */
	  /* But we land here if CRT1 is LCDA, too */
d5475 2
a5476 2
	  /* We can only blank LCD, not other CRT2 devices */
	  if(!(pSiS->VBFlags & (CRT2_LCD|CRT1_LCDA))) return TRUE;
d5478 1
a5478 1
	  /* enable access to extended sequencer registers */
d5480 1
a5480 1
          sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
d5483 1
a5483 1
 	  if(pSiS->VGAEngine == SIS_300_VGA) {
d5485 8
a5492 4
	     if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	        checkit = TRUE;
	        if(!xf86IsUnblank(mode)) {
		   SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
d5494 13
a5506 1
		   SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
a5507 11
	     } else if(pSiS->VBFlags & (VB_LVDS|VB_30xBDH)) {
	        if(!pSiS->BlankCRT2) {
		   inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		}
		checkit = TRUE;
		if(!xf86IsUnblank(mode)) {
		   outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
		} else {
		   outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		}
	     }
d5509 1
a5509 1
          } else if(pSiS->VGAEngine == SIS_315_VGA) {
d5511 3
a5513 4
 	     if(!pSiS->BlankCRT2) {
	 	inSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		if(pSiS->sishw_ext.jChipType >= SIS_661) pSiS->LCDon &= 0x0f;
	     }
d5515 24
a5538 20
	     if(pSiS->VBFlags & VB_CHRONTEL) {
	        checkit = TRUE;
		if(!xf86IsUnblank(mode)) {
		   SiS_Chrontel701xBLOff(pSiS->SiS_Pr);
		} else {
		   SiS_Chrontel701xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
		}
	     } else if(pSiS->VBFlags & VB_LVDS) {
	        checkit = TRUE;
		if(!xf86IsUnblank(mode)) {
		   outSISIDXREG(SISSR, 0x11, pSiS->LCDon | 0x08);
		} else {
		   outSISIDXREG(SISSR, 0x11, pSiS->LCDon);
		}
	     } else if(pSiS->VBFlags & (VB_301LV|VB_302LV|VB_302ELV)) {
	        checkit = TRUE;
		if(!xf86IsUnblank(mode)) {
		   SiS_SiS30xBLOff(pSiS->SiS_Pr,&pSiS->sishw_ext);
		} else {
		   SiS_SiS30xBLOn(pSiS->SiS_Pr,&pSiS->sishw_ext);
a5539 1
	     }
d5541 2
a5542 8
	  }

	  if(checkit) {
	     if(!pSiS->SecondHead) pSiS->BlankCRT2 = xf86IsUnblank(mode) ? FALSE : TRUE;
	     else if(pSiS->VBFlags & CRT1_LCDA) pSiS->Blank = xf86IsUnblank(mode) ? FALSE : TRUE;
	  }

       }
d5549 1
d5572 1
d5576 1
d5585 1
d5588 1
a5588 1
/* Enable the Turboqueue/Commandqueue (For 300 and 315/330 series only) */
d5598 1
a5598 1
	   if((!pSiS->NoAccel) && (pSiS->TurboQueue)) {
a5608 1

d5610 3
a5612 3
	   if(!pSiS->NoAccel) {
	      /* On 315/330 series, there are three queue modes available
	       * which are chosen by setting bits 7:5 in SR26:
d5617 10
a5626 1
	       *    have to do queue management himself. 
d5629 1
a5629 1
	       * We go VRAM or MMIO here.
d5640 2
a5641 44
#ifdef SISVRAMQ
	      /* We use VRAM Cmd Queue, not MMIO or AGP */
	      unsigned char tempCR55 = 0;

#ifdef SISDUALHEAD
	      if(pSiS->DualHeadMode) {
	         SISEntPtr pSiSEnt = pSiS->entityPrivate;
	         pSiS->cmdQ_SharedWritePort = &(pSiSEnt->cmdQ_SharedWritePort_2D);
	      } else
#endif
	         pSiS->cmdQ_SharedWritePort = &(pSiS->cmdQ_SharedWritePort_2D);

	      /* Set Command Queue Threshold to max value 11111b (?) */
	      outSISIDXREG(SISSR, 0x27, 0x1F);
	      /* No idea what this does */
	      if(pSiS->sishw_ext.jChipType <= SIS_330) {
	         inSISIDXREG(SISCR, 0x55, tempCR55) ;
    	         andSISIDXREG(SISCR, 0x55, 0x33) ;
	      }
	      /* Syncronous reset for Command Queue */
	      outSISIDXREG(SISSR, 0x26, 0x01);
	      MMIO_OUT32(pSiS->IOBase, 0x85c4, 0);
	      /* Enable VRAM Command Queue mode */
	      switch(pSiS->cmdQueueSize) {
    		case 1*1024*1024: SR26 = (0x40 | 0x04 | 0x01); break;
    		case 2*1024*1024: SR26 = (0x40 | 0x08 | 0x01); break;
    		case 4*1024*1024: SR26 = (0x40 | 0x0C | 0x01); break;
		default:
		                  pSiS->cmdQueueSize = 512 * 1024;
		case    512*1024: SR26 = (0x40 | 0x00 | 0x01);
	      }
    	      outSISIDXREG(SISSR, 0x26, SR26);
	      SR26 &= 0xfe;
	      outSISIDXREG(SISSR, 0x26, SR26);
	      pSiS->cmdQ_SharedWritePort_2D = (unsigned long)(MMIO_IN32(pSiS->IOBase, 0x85c8));
              *(pSiS->cmdQ_SharedWritePort) = pSiS->cmdQ_SharedWritePort_2D;
              MMIO_OUT32(pSiS->IOBase, 0x85c4, pSiS->cmdQ_SharedWritePort_2D);
	      MMIO_OUT32(pSiS->IOBase, 0x85C0, pSiS->cmdQueueOffset);
	      temp = (unsigned long)pSiS->FbBase;
#ifdef SISDUALHEAD
	      if(pSiS->DualHeadMode) {
	         SISEntPtr pSiSEnt = pSiS->entityPrivate;
	         temp = (unsigned long)pSiSEnt->FbBase;
	      }
d5643 20
a5662 4
              temp += pSiS->cmdQueueOffset;
              pSiS->cmdQueueBase = (unsigned long *)temp;
	      if(pSiS->sishw_ext.jChipType <= SIS_330) {
    	         outSISIDXREG(SISCR, 0x55, tempCR55);
a5663 18
#else
	      /* For MMIO */
	      /* Set Command Queue Threshold to max value 11111b */
	      outSISIDXREG(SISSR, 0x27, 0x1F);
	      /* Syncronous reset for Command Queue */
	      outSISIDXREG(SISSR, 0x26, 0x01);
	      /* Do some magic (cp readport to writeport) */
	      temp = MMIO_IN32(pSiS->IOBase, 0x85C8);
	      MMIO_OUT32(pSiS->IOBase, 0x85C4, temp);
	      /* Enable MMIO Command Queue mode (0x20),
	       * Enable_command_queue_auto_correction (0x02)
	       *        (no idea, but sounds good, so use it)
	       * 512k (0x00) (does this apply to MMIO mode?) */
    	      outSISIDXREG(SISSR, 0x26, 0x22);
	      /* Calc Command Queue position (Q is always 512k)*/
	      temp = (pScrn->videoRam - 512) * 1024;
	      /* Set Q position */
	      MMIO_OUT32(pSiS->IOBase, 0x85C0, temp);
d5670 13
a5682 137
}

/* Things to do before a ModeSwitch. We set up the
 * video bridge configuration and the TurboQueue.
 */
void SiSPreSetMode(ScrnInfoPtr pScrn, DisplayModePtr mode, int viewmode)
{
    SISPtr         pSiS = SISPTR(pScrn);
    unsigned char  CR30, CR31, CR32, CR33;
    unsigned char  CR39 = 0, CR3B = 0;
    unsigned char  CR17, CR38 = 0;
    unsigned char  CR35 = 0, CR79 = 0;
    unsigned long  vbflag;
    int            temp = 0, i;
    int 	   crt1rateindex = 0;
    DisplayModePtr mymode;
#ifdef SISMERGED
    DisplayModePtr mymode2 = NULL;
#endif

#ifdef SISMERGED
    if(pSiS->MergedFB) {
       mymode = ((SiSMergedDisplayModePtr)mode->Private)->CRT1;
       mymode2 = ((SiSMergedDisplayModePtr)mode->Private)->CRT2;
    } else
#endif
    mymode = mode;

    vbflag = pSiS->VBFlags;
    pSiS->IsCustom = FALSE;
#ifdef SISMERGED
    pSiS->IsCustomCRT2 = FALSE;

    if(pSiS->MergedFB) {
       /* CRT2 */
       if(vbflag & CRT2_LCD) {
          if(pSiS->SiS_Pr->CP_HaveCustomData) {
	     for(i=0; i<7; i++) {
	        if(pSiS->SiS_Pr->CP_DataValid[i]) {
	           if((mymode2->HDisplay == pSiS->SiS_Pr->CP_HDisplay[i]) &&
	              (mymode2->VDisplay == pSiS->SiS_Pr->CP_VDisplay[i])) {
	              if(mymode2->type & M_T_BUILTIN) {
	                 pSiS->IsCustomCRT2 = TRUE;
		      }
	           }
		}
	     }
	  }
       }
       if(vbflag & (CRT2_VGA|CRT2_LCD)) {
          if(pSiS->AddedPlasmaModes) {
	     if(mymode2->type & M_T_BUILTIN) {
	        pSiS->IsCustomCRT2 = TRUE;
	     }
	  }
	  if(pSiS->HaveCustomModes2) {
             if(!(mymode2->type & M_T_DEFAULT)) {
	        pSiS->IsCustomCRT2 = TRUE;
             }
          }
       }
       /* CRT1 */
       if(pSiS->HaveCustomModes) {
          if(!(mymode->type & M_T_DEFAULT)) {
	     pSiS->IsCustom = TRUE;
          }
       }
    } else
#endif
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       if(!pSiS->SecondHead) {
          /* CRT2 */
          if(vbflag & CRT2_LCD) {
	     if(pSiS->SiS_Pr->CP_HaveCustomData) {
	        for(i=0; i<7; i++) {
                   if(pSiS->SiS_Pr->CP_DataValid[i]) {
	              if((mymode->HDisplay == pSiS->SiS_Pr->CP_HDisplay[i]) &&
	                 (mymode->VDisplay == pSiS->SiS_Pr->CP_VDisplay[i])) {
	                 if(mymode->type & M_T_BUILTIN) {
	                    pSiS->IsCustom = TRUE;
		         }
		      }
		   }
	        }
	     }
          }
	  if(vbflag & (CRT2_VGA|CRT2_LCD)) {
             if(pSiS->AddedPlasmaModes) {
	        if(mymode->type & M_T_BUILTIN) {
	           pSiS->IsCustom = TRUE;
	        }
	     }
	     if(pSiS->HaveCustomModes) {
                if(!(mymode->type & M_T_DEFAULT)) {
	           pSiS->IsCustom = TRUE;
                }
             }
          }
       } else {
          /* CRT1 */
          if(pSiS->HaveCustomModes) {
             if(!(mymode->type & M_T_DEFAULT)) {
	        pSiS->IsCustom = TRUE;
             }
          }
       }
    } else
#endif
    {
       if(vbflag & CRT2_LCD) {
          if(pSiS->SiS_Pr->CP_HaveCustomData) {
	     for(i=0; i<7; i++) {
	        if(pSiS->SiS_Pr->CP_DataValid[i]) {
                   if((mymode->HDisplay == pSiS->SiS_Pr->CP_HDisplay[i]) &&
	              (mymode->VDisplay == pSiS->SiS_Pr->CP_VDisplay[i])) {
	              if(mymode->type & M_T_BUILTIN) {
	                 pSiS->IsCustom = TRUE;
	              }
		   }
	        }
	     }
          }
       }
       if(vbflag & (CRT2_LCD|CRT2_VGA)) {
          if(pSiS->AddedPlasmaModes) {
             if(mymode->type & M_T_BUILTIN) {
	        pSiS->IsCustom = TRUE;
             }
          }
       }
       if((pSiS->HaveCustomModes) && (!(vbflag & CRT2_TV))) {
          if(!(mymode->type & M_T_DEFAULT)) {
	     pSiS->IsCustom = TRUE;
          }
       }
    }
d5688 6
a5693 28
    inSISIDXREG(SISCR, 0x30, CR30);
    inSISIDXREG(SISCR, 0x31, CR31);
    CR32 = pSiS->newCR32;
    inSISIDXREG(SISCR, 0x33, CR33);

    if(pSiS->Chipset == PCI_CHIP_SIS660) {

       inSISIDXREG(SISCR, 0x35, CR35);
       inSISIDXREG(SISCR, 0x38, CR38);
       inSISIDXREG(SISCR, 0x39, CR39);

       xf86DrvMsgVerb(pScrn->scrnIndex, X_PROBED, 4,
	   "Before: CR30=0x%02x,CR31=0x%02x,CR32=0x%02x,CR33=0x%02x,CR35=0x%02x,CR38=0x%02x\n",
              CR30, CR31, CR32, CR33, CR35, CR38);
       CR38 &= ~0x07;

    } else {

       if(pSiS->Chipset != PCI_CHIP_SIS300) {
          switch(pSiS->VGAEngine) {
             case SIS_300_VGA: temp = 0x35; break;
             case SIS_315_VGA: temp = 0x38; break;
          }
          if(temp) inSISIDXREG(SISCR, temp, CR38);
       }
       if(pSiS->VGAEngine == SIS_315_VGA) {
          inSISIDXREG(SISCR, 0x79, CR79);
          CR38 &= ~0x3b;   			/* Clear LCDA/DualEdge and YPbPr bits */
a5694 4
       inSISIDXREG(SISCR, 0x3b, CR3B);
       xf86DrvMsgVerb(pScrn->scrnIndex, X_PROBED, 4,
	   "Before: CR30=0x%02x, CR31=0x%02x, CR32=0x%02x, CR33=0x%02x, CR%02x=0x%02x\n",
              CR30, CR31, CR32, CR33, temp, CR38);
d5697 11
a5707 10
    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4, "VBFlags=0x%lx\n", pSiS->VBFlags);

    CR30 = 0x00;
    CR31 &= ~0x60;  /* Clear VB_Drivermode & VB_OutputDisable */
    CR31 |= 0x04;   /* Set VB_NotSimuMode (not for 30xB/1400x1050?) */
    CR35 = 0x00;

    if(pSiS->Chipset != PCI_CHIP_SIS660) {
       if(!pSiS->AllowHotkey) {
          CR31 |= 0x80;   /* Disable hotkey-switch */
a5708 1
       CR79 &= ~0x10;     /* Enable Backlight control on 315 series */
d5710 1
d5712 1
a5712 2
    SiS_SetEnableDstn(pSiS->SiS_Pr, FALSE);
    SiS_SetEnableFstn(pSiS->SiS_Pr, FALSE);
d5714 3
a5716 1
    if((vbflag & CRT1_LCDA) && (viewmode == SIS_MODE_CRT1)) {
d5718 12
a5729 1
       CR38 |= 0x02;
d5731 31
a5761 1
    } else {
d5763 1
a5763 1
       switch(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {
d5765 6
a5770 23
       case CRT2_TV:

          CR38 &= ~0xC0; 	/* Clear Pal M/N bits */

          if((vbflag & VB_CHRONTEL) && (vbflag & TV_CHSCART)) {			/* Chrontel */
	     CR30 |= 0x10;
	     CR38 |= 0x04;
	     CR38 &= ~0x08;
	     CR31 |= 0x01;
	  } else if((vbflag & VB_CHRONTEL) && (vbflag & TV_CHYPBPR525I)) {	/* Chrontel */
	     CR38 |= 0x08;
	     CR38 &= ~0x04;
	     CR31 &= ~0x01;
          } else if(vbflag & TV_HIVISION) {	/* SiS bridge */
	     if(pSiS->Chipset == PCI_CHIP_SIS660) {
	        CR38 |= 0x04;
	        CR35 |= 0x60;
	     } else {
	        CR30 |= 0x80;
		if(pSiS->VGAEngine == SIS_315_VGA) {
		   if(vbflag & (VB_301LV | VB_302LV | VB_301C)) {
		      CR38 |= (0x08 | 0x30);
		   }
d5772 12
a5783 29
	     }
	     CR31 |= 0x01;
	     CR35 |= 0x01;
	  } else if(vbflag & TV_YPBPR) {					/* SiS bridge */
	     if(pSiS->Chipset == PCI_CHIP_SIS660) {
	        CR38 |= 0x04;
	        if(vbflag & TV_YPBPR525P)       CR35 |= 0x20;
		else if(vbflag & TV_YPBPR750P)  CR35 |= 0x40;
		else if(vbflag & TV_YPBPR1080I) CR35 |= 0x60;
		CR31 &= ~0x01;
		CR35 &= ~0x01;
		CR39 &= ~0x03;
		if((vbflag & TV_YPBPRAR) == TV_YPBPR43LB)     CR39 |= 0x00;
		else if((vbflag & TV_YPBPRAR) == TV_YPBPR43)  CR39 |= 0x01;
		else if((vbflag & TV_YPBPRAR) == TV_YPBPR169) CR39 |= 0x02;
		else					      CR39 |= 0x03;
	     } else if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPR) {
	        CR30 |= 0x80;
		CR38 |= 0x08;
	        if(vbflag & TV_YPBPR525P)       CR38 |= 0x10;
		else if(vbflag & TV_YPBPR750P)  CR38 |= 0x20;
		else if(vbflag & TV_YPBPR1080I) CR38 |= 0x30;
		CR31 &= ~0x01;
		if(pSiS->SiS_SD_Flags & SiS_SD_SUPPORTYPBPRAR) {
		   CR3B &= ~0x03;
		   if((vbflag & TV_YPBPRAR) == TV_YPBPR43LB)     CR3B |= 0x00;
		   else if((vbflag & TV_YPBPRAR) == TV_YPBPR43)  CR3B |= 0x03;
		   else if((vbflag & TV_YPBPRAR) == TV_YPBPR169) CR3B |= 0x01;
		   else					         CR3B |= 0x03;
a5784 90
	     }
          } else {								/* All */
	     if(vbflag & TV_SCART)  CR30 |= 0x10;
	     if(vbflag & TV_SVIDEO) CR30 |= 0x08;
	     if(vbflag & TV_AVIDEO) CR30 |= 0x04;
	     if(!(CR30 & 0x1C))	    CR30 |= 0x08;    /* default: SVIDEO */

	     if(vbflag & TV_PAL) {
		CR31 |= 0x01;
		CR35 |= 0x01;
		if( (vbflag & VB_SISBRIDGE) ||
		    ((vbflag & VB_CHRONTEL) && (pSiS->ChrontelType == CHRONTEL_701x)) )  {
		   if(vbflag & TV_PALM) {
		      CR38 |= 0x40;
		      CR35 |= 0x04;
		   } else if(vbflag & TV_PALN) {
		      CR38 |= 0x80;
		      CR35 |= 0x08;
	  	   }
	        }
	     } else {
		CR31 &= ~0x01;
		CR35 &= ~0x01;
		if(vbflag & TV_NTSCJ) {
		   CR38 |= 0x40;  /* TW, not BIOS */
		   CR35 |= 0x02;
	 	}
	     }
	     if(vbflag & TV_SCART) {
	        CR31 |= 0x01;
		CR35 |= 0x01;
	     }
	  }

	  CR31 &= ~0x04;   /* Clear NotSimuMode */
	  pSiS->SiS_Pr->SiS_CHOverScan = pSiS->UseCHOverScan;
	  if((pSiS->OptTVSOver == 1) && (pSiS->ChrontelType == CHRONTEL_700x)) {
	     pSiS->SiS_Pr->SiS_CHSOverScan = TRUE;
	  } else {
	     pSiS->SiS_Pr->SiS_CHSOverScan = FALSE;
	  }
#ifdef SIS_CP
	  SIS_CP_DRIVER_CONFIG
#endif
          break;

       case CRT2_LCD:
          CR30 |= 0x20;
	  SiS_SetEnableDstn(pSiS->SiS_Pr, pSiS->DSTN);
	  SiS_SetEnableFstn(pSiS->SiS_Pr, pSiS->FSTN);
          break;

       case CRT2_VGA:
          CR30 |= 0x40;
          break;

       default:
          CR30 |= 0x00;
          CR31 |= 0x20;    /* VB_OUTPUT_DISABLE */
	  if(pSiS->UseVESA) {
	     crt1rateindex = SISSearchCRT1Rate(pScrn, mymode);
	  }
       }

    }

    if(vbflag & CRT1_LCDA) {
       switch(viewmode) {
       case SIS_MODE_CRT1:
          CR38 |= 0x01;
          break;
       case SIS_MODE_CRT2:
          if(vbflag & (CRT2_TV|CRT2_VGA)) {
             CR30 |= 0x02;
	     CR38 |= 0x01;
	  } else {
	     CR38 |= 0x03;
	  }
          break;
       case SIS_MODE_SIMU:
       default:
          if(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {
             CR30 |= 0x01;
	  }
          break;
       }
    } else {
       if(vbflag & (CRT2_TV|CRT2_LCD|CRT2_VGA)) {
          CR30 |= 0x01;
       }
d5786 1
a5786 2

    /* for VESA: no DRIVERMODE, otherwise
d5791 2
a5792 3
     if(pSiS->UseVESA) {
        CR31 &= ~0x40;   /* Clear Drivermode */
	CR31 |= 0x06;    /* Set SlaveMode, Enable SimuMode in Slavemode */
d5794 2
a5795 2
        CR31 |= 0x40;    /* DEBUG (for non-slave mode VESA) */
	crt1rateindex = SISSearchCRT1Rate(pScrn, mymode);
d5798 1
a5798 2
        CR31 |=  0x40;  /* Set Drivermode */
	CR31 &=  ~0x06; /* Disable SlaveMode, disable SimuMode in SlaveMode */
d5800 1
a5800 1
           crt1rateindex = SISSearchCRT1Rate(pScrn, mymode);
d5802 1
a5802 1
	   crt1rateindex = CR33;
d5805 8
d5818 2
a5819 4
	    CR33 &= 0xf0;
	    if(!(vbflag & CRT1_LCDA)) {
	       CR33 |= (crt1rateindex & 0x0f);
	    }
d5822 2
a5823 4
	    CR33 &= 0x0f;
	    if(vbflag & CRT2_VGA) {
	       CR33 |= ((crt1rateindex << 4) & 0xf0);
	    }
d5825 1
a5825 1
     } else
a5826 6
#ifdef SISMERGED
     if(pSiS->MergedFB) {
        CR33 = 0;
	if(!(vbflag & CRT1_LCDA)) {
	   CR33 |= (crt1rateindex & 0x0f);
	}
d5828 3
a5830 13
	   if(!pSiS->IsCustomCRT2) {
	      CR33 |= (SISSearchCRT1Rate(pScrn, mymode2) << 4);
	   }
	}
     } else
#endif
     {
        CR33 = 0;
	if(!(vbflag & CRT1_LCDA)) {
	   CR33 |= (crt1rateindex & 0x0f);
	}
        if(vbflag & CRT2_VGA) {
           CR33 |= ((crt1rateindex & 0x0f) << 4);
d5833 3
a5835 1
	   if(pSiS->CRT1off) CR33 &= 0xf0;
d5837 1
d5839 2
d5842 3
a5844 32
     if(pSiS->Chipset == PCI_CHIP_SIS660) {

        CR31 &= 0xfe;   /* Clear PAL flag (now in CR35) */
	CR38 &= 0x07;   /* Use only LCDA and HiVision/YPbPr bits */
	outSISIDXREG(SISCR, 0x30, CR30);
	outSISIDXREG(SISCR, 0x31, CR31);
	outSISIDXREG(SISCR, 0x33, CR33);
	outSISIDXREG(SISCR, 0x35, CR35);
	setSISIDXREG(SISCR, 0x38, 0xf8, CR38);
	outSISIDXREG(SISCR, 0x39, CR39);
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
		"After:  CR30=0x%02x,CR31=0x%02x,CR33=0x%02x,CR35=0x%02x,CR38=%02x\n",
		    CR30, CR31, CR33, CR35, CR38);

     } else {

        outSISIDXREG(SISCR, 0x30, CR30);
        outSISIDXREG(SISCR, 0x31, CR31);
        outSISIDXREG(SISCR, 0x33, CR33);
        if(temp) {
           outSISIDXREG(SISCR, temp, CR38);
        }
	if(pSiS->VGAEngine == SIS_315_VGA) {
	   outSISIDXREG(SISCR, 0x3b, CR3B);
	   outSISIDXREG(SISCR, 0x79, CR79);
	}
	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 4,
		"After:  CR30=0x%02x,CR31=0x%02x,CR33=0x%02x,CR%02x=%02x\n",
		    CR30, CR31, CR33, temp, CR38);
     }

     pSiS->SiS_Pr->SiS_UseOEM = pSiS->OptUseOEM;
d5847 1
a5847 4
#ifdef SISVRAMQ
     if(pSiS->VGAEngine != SIS_315_VGA)
#endif     
        SiSEnableTurboQueue(pScrn);
d5851 6
a5856 7
	andSISIDXREG(SISSR,0x1f,0x3f);
	inSISIDXREG(SISCR, 0x17, CR17);
	if(!(CR17 & 0x80)) {
           orSISIDXREG(SISCR, 0x17, 0x80);
	   outSISIDXREG(SISSR, 0x00, 0x01);
	   usleep(10000);
           outSISIDXREG(SISSR, 0x00, 0x03);
d5859 1
d5865 1
a5865 1
 * the display properties tool SiSCtrl.
d5890 1
a5890 2
 * The values will be in pSiSEnt anyway, and read from there
 * if we're running dual head.
d6044 1
a6044 4
	      unsigned short reg = 0;
	      reg = SiS_GetCH70xx(pSiS->SiS_Pr, 0x01);
	      reg = (reg & 0xf0) | ((reg & 0x0c) >> 2) | (val << 2);
              SiS_SetCH70xx(pSiS->SiS_Pr, ((reg << 8) | 0x01));
d6076 1
a6076 1
           return(int)((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x03) * 6);
d6172 1
a6172 4
	      unsigned short reg = 0;
	      reg = SiS_GetCH70xx(pSiS->SiS_Pr, 0x01);
	      reg = (reg & 0xc0) | ((reg & 0x0c) >> 2) | ((reg & 0x03) << 2) | (val << 4);
              SiS_SetCH70xx(pSiS->SiS_Pr, ((reg << 8) | 0x01));
d6224 1
a6224 1

d6227 1
a6227 1

d6231 1
a6231 1

d6241 1
a6241 1
   }
d6252 2
a6253 2
#ifdef SISDUALHEAD
      if(pSiSEnt && pSiS->DualHeadMode)
d6268 1
a6268 1
           return -2;
d6270 1
a6270 1
   }
d6284 1
a6284 1

d6287 1
a6287 1

d6296 1
a6296 4
	      unsigned short reg = 0;
	      reg = SiS_GetCH70xx(pSiS->SiS_Pr, 0x01);
	      reg = (reg & 0xf0) | ((reg & 0x03) << 2) | val;
              SiS_SetCH70xx(pSiS->SiS_Pr, ((reg << 8) | 0x01));
d6305 1
a6305 1
   }
d6328 1
a6328 1
	   return(int)(((SiS_GetCH70xx(pSiS->SiS_Pr, 0x01) & 0x0c) >> 2) * 6);
d6332 1
a6332 1
           return -2;
d6365 2
a6366 3
       }
       SiS_DDC2Delay(pSiS->SiS_Pr, 1000);
   }
d6409 1
a6409 2

   if(!(pSiS->VBFlags & VB_301))  return;
d6411 2
a6412 1

d6419 1
a6419 1
      setSISIDXREG(SISPART2,0x3A, 0x1F, (val << 5));
a6425 2
   int result = pSiS->sistvedgeenhance;
   unsigned char temp;
a6427 2

   if(pSiSEnt && pSiS->DualHeadMode) result = pSiSEnt->sistvedgeenhance;
d6430 9
a6438 3
   if(!(pSiS->VBFlags & VB_301))  return result;
   if(!(pSiS->VBFlags & CRT2_TV)) return result;

d6440 5
a6444 4
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   inSISIDXREG(SISPART2, 0x3a, temp);
   return(int)(((temp & 0xe0) >> 5) * 2);
a6458 52
   if(!(pSiS->VBFlags & CRT2_TV))      return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE)) return;
   if(pSiS->VBFlags & TV_HIVISION)     return;
   if((pSiS->VBFlags & TV_YPBPR) &&
      (pSiS->VBFlags & (TV_YPBPR525P | TV_YPBPR750P | TV_YPBPR1080I))) return;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   /* Valid values: 0=off, 1=low, 2=med, 3=high, 4=adaptive */
   if((val >= 0) && (val <= 4)) {
      setSISIDXREG(SISPART2,0x0A,0x8F, (val << 4));
   }
}

int SiS_GetSISTVantiflicker(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   int result = pSiS->sistvantiflicker;
   unsigned char temp;
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;

   if(pSiSEnt && pSiS->DualHeadMode) result = pSiSEnt->sistvantiflicker;
#endif

   if(!(pSiS->VBFlags & VB_SISBRIDGE)) return result;
   if(!(pSiS->VBFlags & CRT2_TV))      return result;
   if(pSiS->VBFlags & TV_HIVISION)     return result;
   if((pSiS->VBFlags & TV_YPBPR) &&
      (pSiS->VBFlags & (TV_YPBPR525P | TV_YPBPR750P | TV_YPBPR1080I))) return result;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   inSISIDXREG(SISPART2, 0x0a, temp);
   return(int)((temp & 0x70) >> 4);
}

void SiS_SetSISTVsaturation(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->sistvsaturation = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->sistvsaturation = val;
#endif

d6461 1
a6461 2
   if(pSiS->VBFlags & VB_301) return;

d6468 1
a6468 1
      setSISIDXREG(SISPART4,0x21,0xF8, val);
d6472 1
a6472 1
int SiS_GetSISTVsaturation(ScrnInfoPtr pScrn)
a6474 2
   int result = pSiS->sistvsaturation;
   unsigned char temp;
a6476 2

   if(pSiSEnt && pSiS->DualHeadMode)  result = pSiSEnt->sistvsaturation;
d6479 7
a6485 33
   if(!(pSiS->VBFlags & VB_SISBRIDGE)) return result;
   if(pSiS->VBFlags & VB_301)          return result;
   if(!(pSiS->VBFlags & CRT2_TV))      return result;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   inSISIDXREG(SISPART4, 0x21, temp);
   return(int)((temp & 0x07) * 2);
}

void SiS_SetSISTVcolcalib(ScrnInfoPtr pScrn, int val, Bool coarse)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif
   int ccoarse, cfine, cbase = pSiS->sistvccbase;
   unsigned char temp;

#ifdef SISDUALHEAD
   if(pSiSEnt && pSiS->DualHeadMode) cbase = pSiSEnt->sistvccbase;
#endif

   if(coarse) {
      pSiS->sistvcolcalibc = ccoarse = val;
      cfine = pSiS->sistvcolcalibf;
#ifdef SISDUALHEAD
      if(pSiSEnt) {
         pSiSEnt->sistvcolcalibc = val;
	 if(pSiS->DualHeadMode) cfine = pSiSEnt->sistvcolcalibf;
      }
#endif
d6487 1
a6487 14
      pSiS->sistvcolcalibf = cfine = val;
      ccoarse = pSiS->sistvcolcalibc;
#ifdef SISDUALHEAD
      if(pSiSEnt) {
         pSiSEnt->sistvcolcalibf = val;
         if(pSiS->DualHeadMode) ccoarse = pSiSEnt->sistvcolcalibc;
      }
#endif
   }

   if(!(pSiS->VBFlags & CRT2_TV))               return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE))          return;
   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return;

d6489 4
a6492 19
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   if((cfine >= -128) && (cfine <= 127) && (ccoarse >= -120) && (ccoarse <= 120)) {
      long finalcc = cbase + (((ccoarse * 256) + cfine) * 256);

      inSISIDXREG(SISPART4,0x1f,temp);
      if(!(temp & 0x01)) {
#if 0
         if(pSiS->VBFlags & TV_NTSC) finalcc += 0x21ed8620;
	 else if(pSiS->VBFlags & TV_PALM) finalcc += ?;
	 else if(pSiS->VBFlags & TV_PALM) finalcc += ?;
	 else finalcc += 0x2a05d300;
#endif
      }
      setSISIDXREG(SISPART2,0x31,0x80,((finalcc >> 24) & 0x7f));
      outSISIDXREG(SISPART2,0x32,((finalcc >> 16) & 0xff));
      outSISIDXREG(SISPART2,0x33,((finalcc >> 8) & 0xff));
      outSISIDXREG(SISPART2,0x34,(finalcc & 0xff));
d6496 1
a6496 61
int SiS_GetSISTVcolcalib(ScrnInfoPtr pScrn, Bool coarse)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;

   if(pSiSEnt && pSiS->DualHeadMode)
      if(coarse)  return (int)pSiSEnt->sistvcolcalibc;
      else        return (int)pSiSEnt->sistvcolcalibf;
   else
#endif
   if(coarse)     return (int)pSiS->sistvcolcalibc;
   else           return (int)pSiS->sistvcolcalibf;
}

void SiS_SetSISTVcfilter(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

   pSiS->sistvcfilter = val ? 1 : 0;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->sistvcfilter = pSiS->sistvcfilter;
#endif

   if(!(pSiS->VBFlags & CRT2_TV))               return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE))          return;
   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   setSISIDXREG(SISPART2,0x30,~0x10,((pSiS->sistvcfilter << 4) & 0x10));
}

int SiS_GetSISTVcfilter(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
   int result = pSiS->sistvcfilter;
   unsigned char temp;
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;

   if(pSiSEnt && pSiS->DualHeadMode) result = pSiSEnt->sistvcfilter;
#endif

   if(!(pSiS->VBFlags & VB_SISBRIDGE))          return result;
   if(!(pSiS->VBFlags & CRT2_TV))               return result;
   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return result;

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif
   inSISIDXREG(SISPART2, 0x30, temp);
   return(int)((temp & 0x10) ? 1 : 0);
}

void SiS_SetSISTVyfilter(ScrnInfoPtr pScrn, int val)
a6501 2
   unsigned char p35,p36,p37,p38,p48,p49,p4a,p30;
   int i,j;
d6503 1
a6503 1
   pSiS->sistvyfilter = val;
d6505 1
a6505 1
   if(pSiSEnt) pSiSEnt->sistvyfilter = pSiS->sistvyfilter;
d6508 3
a6510 18
   if(!(pSiS->VBFlags & CRT2_TV))               return;
   if(!(pSiS->VBFlags & VB_SISBRIDGE))          return;
   if(pSiS->VBFlags & (TV_HIVISION | TV_YPBPR)) return;

   p35 = pSiS->p2_35; p36 = pSiS->p2_36;
   p37 = pSiS->p2_37; p38 = pSiS->p2_38;
   p48 = pSiS->p2_48; p49 = pSiS->p2_49;
   p4a = pSiS->p2_4a; p30 = pSiS->p2_30;
#ifdef SISDUALHEAD
   if(pSiSEnt && pSiS->DualHeadMode) {
      p35 = pSiSEnt->p2_35; p36 = pSiSEnt->p2_36;
      p37 = pSiSEnt->p2_37; p38 = pSiSEnt->p2_38;
      p48 = pSiSEnt->p2_48; p49 = pSiSEnt->p2_49;
      p4a = pSiSEnt->p2_4a; p30 = pSiSEnt->p2_30;
   }
#endif
   p30 &= 0x20;

d6515 3
a6517 95
   switch(pSiS->sistvyfilter) {
   case 0:
      andSISIDXREG(SISPART2,0x30,0xdf);
      break;
   case 1:
      outSISIDXREG(SISPART2,0x35,p35);
      outSISIDXREG(SISPART2,0x36,p36);
      outSISIDXREG(SISPART2,0x37,p37);
      outSISIDXREG(SISPART2,0x38,p38);
      if(!(pSiS->VBFlags & VB_301)) {
         outSISIDXREG(SISPART2,0x48,p48);
         outSISIDXREG(SISPART2,0x49,p49);
         outSISIDXREG(SISPART2,0x4a,p4a);
      }
      setSISIDXREG(SISPART2,0x30,0xdf,p30);
      break;
   case 2:
   case 3:
   case 4:
   case 5:
   case 6:
   case 7:
   case 8:
      if(!(pSiS->VBFlags & (TV_PALM | TV_PALN | TV_NTSCJ))) {
         int yindex301 = -1, yindex301B = -1;
	 unsigned char p3d4_34;

	 inSISIDXREG(SISCR,0x34,p3d4_34);

	 switch((p3d4_34 & 0x7f)) {
	 case 0x59:  /* 320x200 */
	 case 0x41:
	 case 0x4f:
	 case 0x50:  /* 320x240 */
	 case 0x56:
	 case 0x53:
	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 0 : 4;
	    break;
	 case 0x2f:  /* 640x400 */
	 case 0x5d:
	 case 0x5e:
	 case 0x2e:  /* 640x480 */
	 case 0x44:
	 case 0x62:
	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 1 : 5;
	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 0 : 4;
	    break;
	 case 0x31:   /* 720x480 */
	 case 0x33:
	 case 0x35:
	 case 0x32:   /* 720x576 */
	 case 0x34:
	 case 0x36:
	 case 0x5f:   /* 768x576 */
	 case 0x60:
	 case 0x61:
	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 2 : 6;
	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 1 : 5;
	    break;
	 case 0x51:   /* 400x300 */
	 case 0x57:
	 case 0x54:
	 case 0x30:   /* 800x600 */
	 case 0x47:
	 case 0x63:
	    yindex301  = (pSiS->VBFlags & TV_NTSC) ? 3 : 7;
	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 2 : 6;
	    break;
	 case 0x52:   /* 512x384 */
	 case 0x58:
	 case 0x5c:
	 case 0x38:   /* 1024x768 */
	 case 0x4a:
	 case 0x64:
	    yindex301B = (pSiS->VBFlags & TV_NTSC) ? 3 : 7;
	    break;
	 }
         if(pSiS->VBFlags & VB_301) {
            if(yindex301 >= 0) {
	       for(i=0, j=0x35; i<=3; i++, j++) {
	          outSISIDXREG(SISPART2,j,(SiSTVFilter301[yindex301].filter[pSiS->sistvyfilter-2][i]));
	       }
	    }
         } else {
            if(yindex301B >= 0) {
	       for(i=0, j=0x35; i<=3; i++, j++) {
	          outSISIDXREG(SISPART2,j,(SiSTVFilter301B[yindex301B].filter[pSiS->sistvyfilter-2][i]));
	       }
	       for(i=4, j=0x48; i<=6; i++, j++) {
	          outSISIDXREG(SISPART2,j,(SiSTVFilter301B[yindex301B].filter[pSiS->sistvyfilter-2][i]));
	       }
	    }
         }
         orSISIDXREG(SISPART2,0x30,0x20);
      }
d6521 1
a6521 1
int SiS_GetSISTVyfilter(ScrnInfoPtr pScrn)
a6525 4

   if(pSiSEnt && pSiS->DualHeadMode)
      return (int)pSiSEnt->sistvyfilter;
   else
d6527 16
a6542 1
      return (int)pSiS->sistvyfilter;
d6549 2
a6550 2

   pSiS->sistvantiflicker = val;
d6553 1
a6553 1

d6575 1
a6575 1
      return (int)pSiS->sistvantiflicker;
d6584 1
a6584 1
      return (int)pSiS->sistvantiflicker;
d6692 1
a6692 1

d6703 1
a6703 1

d6705 1
a6705 1

d6707 1
a6707 1

d6722 1
a6722 1
	       /* Not supported by hardware */
d6725 1
a6725 1

d6727 1
a6727 1

d6729 61
a6789 34

	        unsigned char p2_1f,p2_20,p2_2b,p2_43;
		unsigned short temp;
		int myadd2, mysub;

		p2_1f = pSiS->p2_1f;
		p2_20 = pSiS->p2_20;
#ifdef SISDUALHEAD
	        if(pSiSEnt && pSiS->DualHeadMode) {
		   p2_1f = pSiSEnt->p2_1f;
		   p2_20 = pSiSEnt->p2_20;
		}
#endif

		temp = p2_1f | ((p2_20 & 0xf0) << 4);
		temp += (val * 2);

		p2_1f = temp & 0xff;
		p2_20 = (temp & 0xf00) >> 4;

		if(pSiS->MiscFlags & MISC_TVNTSC1024) {
		   temp += 1514; myadd2 = 4; mysub = 4;
		} else if((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & (TV_YPBPR525P | TV_YPBPR750P))) {
		   myadd2 = -7;
		   if(pSiS->VBFlags & TV_YPBPR525P) {
		      temp += 1274; mysub = 15;
		   } else {
		      temp += 1284; mysub = 12;
		   }
		} else if((pSiS->VBFlags & TV_HIVISION) ||
		          ((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR1080I))) {
		   temp += 1737; myadd2 = -4;
		   if(pSiS->VBFlags & VB_301) myadd2 += 3;
		   mysub = 12;
d6791 12
a6802 4
		   temp += 1363; myadd2 = 3;
		   if(pSiS->VBFlags & VB_301) myadd2 += 3;
		   if((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR525I)) myadd2 += 3;
		   mysub = 5;
d6804 1
a6804 4

		p2_2b = ((temp & 0xf00) >> 4) | ((p2_1f - mysub) & 0x0f);
		p2_43 = p2_1f + myadd2;

a6806 1
		setSISIDXREG(SISPART2,0x20,0x0F,p2_20);
d6808 2
d6814 1
a6814 1

d6816 1
a6816 1

d6818 1
a6818 1

d6821 1
a6821 1

d6824 1
a6824 1

d6829 1
a6829 1
	       if(val > 0) {
d6869 2
a6870 2

   if(pSiSEnt && pSiS->DualHeadMode)
d6873 1
a6873 1
#endif
d6883 1
a6883 1

d6894 1
a6894 1

d6896 1
a6896 1

d6898 1
a6898 1

d6911 13
a6923 329
	       break;
	    case CHRONTEL_701x:
	       /* Not supported by hardware */
	       break;
	    }

	 } else if(pSiS->VBFlags & VB_SISBRIDGE) {

	    if((val >= -32) && (val <= 32)) {
		char p2_01, p2_02;
		val /= 2;  /* 4 */
		p2_01 = pSiS->p2_01;
		p2_02 = pSiS->p2_02;
#ifdef SISDUALHEAD
	        if(pSiSEnt && pSiS->DualHeadMode) {
		   p2_01 = pSiSEnt->p2_01;
		   p2_02 = pSiSEnt->p2_02;
		}
#endif
		p2_01 += val; /* val * 2 */
		p2_02 += val; /* val * 2 */
		while((p2_01 <= 0) || (p2_02 <= 0)) {
		      p2_01 += 2;
		      p2_02 += 2;
		}
		SISWaitRetraceCRT2(pScrn);
		outSISIDXREG(SISPART2,0x01,p2_01);
		outSISIDXREG(SISPART2,0x02,p2_02);
	     }
	 }

      }

   } else if(pSiS->Chipset == PCI_CHIP_SIS6326) {

      if(pSiS->SiS6326Flags & SIS6326_TVDETECTED) {

         unsigned char tmp;
	 int temp1, limit;

         tmp = SiS6326GetTVReg(pScrn,0x00);
         if(tmp & 0x04) {

	    if((val >= -16) && (val <= 16)) {
	      temp1 = (unsigned short)pSiS->tvy1;
	      limit = (pSiS->SiS6326Flags & SIS6326_TVPAL) ? 625 : 525;
	      if(val > 0) {
                temp1 += (val * 4);
	        if(temp1 > limit) temp1 -= limit;
	      } else {
	        val = -val;
	        temp1 -= (val * 2);
	        if(temp1 <= 0) temp1 += (limit -1);
	      }
	      SiS6326SetTVReg(pScrn,0x11,(temp1 & 0xff));
	      tmp = SiS6326GetTVReg(pScrn,0x13);
	      tmp &= ~0x30;
	      tmp |= ((temp1 & 0x300) >> 4);
	      SiS6326SetTVReg(pScrn,0x13,tmp);
	      if(temp1 == 1)                                 tmp = 0x10;
	      else {
	       if(pSiS->SiS6326Flags & SIS6326_TVPAL) {
	         if((temp1 <= 3) || (temp1 >= (limit - 2)))  tmp = 0x08;
	         else if(temp1 < 22)		 	     tmp = 0x02;
	         else 					     tmp = 0x04;
	       } else {
	         if((temp1 <= 5) || (temp1 >= (limit - 4)))  tmp = 0x08;
	         else if(temp1 < 19)			     tmp = 0x02;
	         else 					     tmp = 0x04;
	       }
	     }
	     SiS6326SetTVReg(pScrn,0x21,tmp);
           }
	 }
      }
   }
}

int SiS_GetTVyposoffset(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;

   if(pSiSEnt && pSiS->DualHeadMode)
        return (int)pSiSEnt->tvypos;
   else
#endif
        return (int)pSiS->tvypos;
}

void SiS_SetTVxscale(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   pSiS->tvxscale = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->tvxscale = val;
#endif

   if(pSiS->VGAEngine == SIS_300_VGA || pSiS->VGAEngine == SIS_315_VGA) {

      if((pSiS->VBFlags & CRT2_TV) && (pSiS->VBFlags & VB_SISBRIDGE)) {

	 if((val >= -16) && (val <= 16)) {

	    unsigned char p2_44,p2_45,p2_46;
	    int scalingfactor;

	    p2_44 = pSiS->p2_44;
	    p2_45 = pSiS->p2_45 & 0x3f;
	    p2_46 = pSiS->p2_46 & 0x07;
#ifdef SISDUALHEAD
	    if(pSiSEnt && pSiS->DualHeadMode) {
	       p2_44 = pSiSEnt->p2_44;
	       p2_45 = pSiSEnt->p2_45 & 0x3f;
	       p2_46 = pSiSEnt->p2_46 & 0x07;
	    }
#endif
	    scalingfactor = (p2_46 << 13) | ((p2_45 & 0x1f) << 8) | p2_44;

	    if(val < 0) {
	       p2_45 &= 0xdf;
	       scalingfactor += ((-val) * 64);
	       if(scalingfactor > 0xffff) scalingfactor = 0xffff;
	    } else if(val > 0) {
	       p2_45 &= 0xdf;
	       scalingfactor -= (val * 64);
	       if(scalingfactor < 1) scalingfactor = 1;
	    }

	    p2_44 = scalingfactor & 0xff;
	    p2_45 &= 0xe0;
	    p2_45 |= ((scalingfactor >> 8) & 0x1f);
	    p2_46 = ((scalingfactor >> 13) & 0x07);

	    SISWaitRetraceCRT2(pScrn);
	    outSISIDXREG(SISPART2,0x44,p2_44);
	    setSISIDXREG(SISPART2,0x45,0xC0,p2_45);
	    if(!(pSiS->VBFlags & VB_301)) {
	       setSISIDXREG(SISPART2,0x46,0xF8,p2_46);
	    }
	 }

      }

   }
}

int SiS_GetTVxscale(ScrnInfoPtr pScrn)
{
   SISPtr pSiS = SISPTR(pScrn);
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;

   if(pSiSEnt && pSiS->DualHeadMode)
        return (int)pSiSEnt->tvxscale;
   else
#endif
        return (int)pSiS->tvxscale;
}

void SiS_SetTVyscale(ScrnInfoPtr pScrn, int val)
{
   SISPtr pSiS = SISPTR(pScrn);
   Bool usentsc = FALSE;
#ifdef SISDUALHEAD
   SISEntPtr pSiSEnt = pSiS->entityPrivate;
#endif

#ifdef UNLOCK_ALWAYS
   sisSaveUnlockExtRegisterLock(pSiS, NULL, NULL);
#endif

   if(val < -4) val = -4;
   if(val > 3)  val = 3;

   pSiS->tvyscale = val;
#ifdef SISDUALHEAD
   if(pSiSEnt) pSiSEnt->tvyscale = val;
#endif

   if(pSiS->VGAEngine == SIS_315_VGA || pSiS->VGAEngine == SIS_315_VGA) {

      if((pSiS->VBFlags & CRT2_TV) && (pSiS->VBFlags & VB_SISBRIDGE)) {

	 int srindex = -1, newvde, i = 0, j, vlimit, temp;
	 unsigned char p3d4_34;

	 if(pSiS->VBFlags & TV_HIVISION) return;
         if((pSiS->VBFlags & TV_YPBPR) &&
            (pSiS->VBFlags & (TV_YPBPR1080I | TV_YPBPR750P | TV_YPBPR525P))) return;

	 if(pSiS->VBFlags & TV_YPBPR)                 usentsc = TRUE;
         else if(pSiS->VBFlags & (TV_NTSC | TV_PALM)) usentsc = TRUE;

	 vlimit = usentsc ? 259 : 309;

	 inSISIDXREG(SISCR,0x34,p3d4_34);

	 switch((p3d4_34 & 0x7f)) {
#if 0
	 case 0x50:   /* 320x240 - hdclk mode */
	 case 0x56:
	 case 0x53:
#endif
	 case 0x2e:   /* 640x480 */
	 case 0x44:
	 case 0x62:
	    srindex  = usentsc ? 0 : 21;
	    break;
	 case 0x31:   /* 720x480 */
	 case 0x33:
	 case 0x35:
	 case 0x32:   /* 720x576 */
	 case 0x34:
	 case 0x36:
	 case 0x5f:   /* 768x576 */
	 case 0x60:
	 case 0x61:
            if(pSiS->VGAEngine == SIS_315_VGA) {
	       srindex  = usentsc ? 7 : 28;
	    }
	    break;
#if 0
	 case 0x51:   /* 400x300 - hdclk mode */
	 case 0x57:
	 case 0x54:
#endif
	 case 0x30:   /* 800x600 */
	 case 0x47:
	 case 0x63:
	    srindex  = usentsc ? 14 : 35;
	 }

	 if(srindex >= 0) {
	    Bool found = FALSE;
	    if(pSiS->tvyscale != 0) {
	       for(j=0; j<=1; j++) {
	          for(i=0; i<=6; i++) {
	             if(SiSTVVScale[srindex+i].sindex == pSiS->tvyscale) {
		        found = TRUE;
		        break;
		     }
	          }
		  if(found) break;
	          if(pSiS->tvyscale > 0) pSiS->tvyscale--;
		  else pSiS->tvyscale++;
	       }
	    }
#ifdef SISDUALHEAD
	    if(pSiSEnt) pSiSEnt->tvyscale = pSiS->tvyscale;
#endif
	    if(pSiS->tvyscale == 0) {
	       unsigned char p2_0a = pSiS->p2_0a;
	       unsigned char p2_2f = pSiS->p2_2f;
	       unsigned char p2_30 = pSiS->p2_30;
	       unsigned char p2_46 = pSiS->p2_46;
	       unsigned char p2_47 = pSiS->p2_47;
	       unsigned char p1scaling[9], p4scaling[9];
	       unsigned char *p2scaling;

	       for(i=0; i<9; i++) {
	          p1scaling[i] = pSiS->scalingp1[i];
	       }
	       for(i=0; i<9; i++) {
	          p4scaling[i] = pSiS->scalingp4[i];
	       }
	       p2scaling = &pSiS->scalingp2[0];
#ifdef SISDUALHEAD
               if(pSiSEnt && pSiS->DualHeadMode) {
	          p2_0a = pSiSEnt->p2_0a;
		  p2_2f = pSiSEnt->p2_2f;
	          p2_30 = pSiSEnt->p2_30;
		  p2_46 = pSiSEnt->p2_46;
		  p2_47 = pSiSEnt->p2_47;
	          for(i=0; i<9; i++) {
	             p1scaling[i] = pSiSEnt->scalingp1[i];
	          }
	          for(i=0; i<9; i++) {
	             p4scaling[i] = pSiSEnt->scalingp4[i];
	          }
		  p2scaling = &pSiSEnt->scalingp2[0];
	       }
#endif
               SISWaitRetraceCRT2(pScrn);
	       if(pSiS->VBFlags & (VB_301C|VB_302ELV)) {
	          for(i=0; i<64; i++) {
	             outSISIDXREG(SISPART2,(0xc0 + i),p2scaling[i]);
	          }
	       }
	       for(i=0; i<9; i++) {
	          outSISIDXREG(SISPART1,SiSScalingP1Regs[i],p1scaling[i]);
	       }
	       for(i=0; i<9; i++) {
	          outSISIDXREG(SISPART4,SiSScalingP4Regs[i],p4scaling[i]);
	       }

	       setSISIDXREG(SISPART2,0x0a,0x7f,(p2_0a & 0x80));
	       outSISIDXREG(SISPART2,0x2f,p2_2f);
	       setSISIDXREG(SISPART2,0x30,0x3f,(p2_30 & 0xc0));
	       if(!(pSiS->VBFlags & VB_301)) {
	          setSISIDXREG(SISPART2,0x46,0x9f,(p2_46 & 0x60));
		  outSISIDXREG(SISPART2,0x47,p2_47);
	       }

	    } else {

	       int so = (pSiS->VGAEngine == SIS_300_VGA) ? 12 : 0;
	       int realvde, j, srindex301c, myypos, watchdog = 32;
	       unsigned long calctemp;

	       srindex += i;
	       srindex301c = srindex * 64;
	       newvde = SiSTVVScale[srindex].ScaleVDE;
	       realvde = SiSTVVScale[srindex].RealVDE;

	       do {
	          inSISIDXREG(SISPART2,0x01,temp);
	          temp = vlimit - (temp & 0x7f);
	          if((temp - (((newvde >> 1) - 2) + 9)) > 0) break;
		  myypos = pSiS->tvypos - 1;
d6925 4
a6928 1
		  if(pSiSEnt && pSiS->DualHeadMode) myypos = pSiSEnt->tvypos - 1;
d6930 50
a6979 12
		  SiS_SetTVyposoffset(pScrn, myypos);
	       } while(watchdog--);

	       SISWaitRetraceCRT2(pScrn);

	       if(pSiS->VBFlags & (VB_301C|VB_302ELV)) {
#ifdef TWDEBUG
		  xf86DrvMsg(0, X_INFO, "301C scaler: Table index %d\n");
#endif
	          for(j=0; j<64; j++) {
		     outSISIDXREG(SISPART2,(0xc0 + j), SiS301CScaling[srindex301c + j]);
		  }
d6981 3
a6983 44

	       if(!(pSiS->VBFlags & VB_301)) {
	          temp = (newvde >> 1) - 3;
	          setSISIDXREG(SISPART2,0x46,0x9f,((temp & 0x0300) >> 3));
	          outSISIDXREG(SISPART2,0x47,(temp & 0xff));
	       }
	       outSISIDXREG(SISPART1,0x08,(SiSTVVScale[srindex].reg[so+0] & 0xff));
	       setSISIDXREG(SISPART1,0x09,0x0f,((SiSTVVScale[srindex].reg[so+0] >> 4) & 0xf0));
	       outSISIDXREG(SISPART1,0x0b,(SiSTVVScale[srindex].reg[so+1] & 0xff));
	       setSISIDXREG(SISPART1,0x0c,0xf0,((SiSTVVScale[srindex].reg[so+1] >> 8) & 0x0f));
	       outSISIDXREG(SISPART1,0x0d,(SiSTVVScale[srindex].reg[so+2] & 0xff));
	       outSISIDXREG(SISPART1,0x0e,(SiSTVVScale[srindex].reg[so+3] & 0xff));
	       setSISIDXREG(SISPART1,0x12,0xf8,((SiSTVVScale[srindex].reg[so+3] >> 8 ) & 0x07));
	       outSISIDXREG(SISPART1,0x10,(SiSTVVScale[srindex].reg[so+4] & 0xff));
	       setSISIDXREG(SISPART1,0x11,0x8f,((SiSTVVScale[srindex].reg[so+4] >> 4) & 0x70));
	       setSISIDXREG(SISPART1,0x11,0xf0,(SiSTVVScale[srindex].reg[so+5] & 0x0f));

	       setSISIDXREG(SISPART2,0x0a,0x7f,((SiSTVVScale[srindex].reg[so+6] << 7) & 0x80));
	       outSISIDXREG(SISPART2,0x2f,((newvde / 2) - 2));
	       setSISIDXREG(SISPART2,0x30,0x3f,((((newvde / 2) - 2) >> 2) & 0xc0));

	       outSISIDXREG(SISPART4,0x13,(SiSTVVScale[srindex].reg[so+7] & 0xff));
	       outSISIDXREG(SISPART4,0x14,(SiSTVVScale[srindex].reg[so+8] & 0xff));
	       setSISIDXREG(SISPART4,0x15,0x7f,((SiSTVVScale[srindex].reg[so+8] >> 1) & 0x80));

	       outSISIDXREG(SISPART4,0x16,(SiSTVVScale[srindex].reg[so+9] & 0xff));
	       setSISIDXREG(SISPART4,0x15,0x87,((SiSTVVScale[srindex].reg[so+9] >> 5) & 0x78));

	       outSISIDXREG(SISPART4,0x17,(SiSTVVScale[srindex].reg[so+10] & 0xff));
	       setSISIDXREG(SISPART4,0x15,0xf8,((SiSTVVScale[srindex].reg[so+10] >> 8) & 0x07));

	       outSISIDXREG(SISPART4,0x18,(SiSTVVScale[srindex].reg[so+11] & 0xff));
	       setSISIDXREG(SISPART4,0x19,0xf0,((SiSTVVScale[srindex].reg[so+11] >> 8) & 0x0f));

               temp = 0x40;
	       if(realvde <= newvde) temp = 0;
	       else realvde -= newvde;

	       calctemp = (realvde * 256 * 1024) / newvde;
	       if((realvde * 256 * 1024) % newvde) calctemp++;
	       outSISIDXREG(SISPART4,0x1b,(calctemp & 0xff));
	       outSISIDXREG(SISPART4,0x1a,((calctemp >> 8) & 0xff));
	       setSISIDXREG(SISPART4,0x19,0x8f,(((calctemp >> 12) & 0x30) | temp));
	    }
a6984 1

a6985 1

d6989 1
a6989 1
int SiS_GetTVyscale(ScrnInfoPtr pScrn)
d6994 6
a6999 6

   if(pSiSEnt && pSiS->DualHeadMode)
        return (int)pSiSEnt->tvyscale;
   else
#endif
        return (int)pSiS->tvyscale;
d7002 3
a7004 8
/* PostSetMode:
 * -) Disable CRT1 for saving bandwidth. This doesn't work with VESA;
 *    VESA uses the bridge in SlaveMode and switching CRT1 off while
 *    the bridge is in SlaveMode not that clever...
 * -) Check if overlay can be used (depending on dotclock)
 * -) Check if Panel Scaler is active on LVDS for overlay re-scaling
 * -) Save TV registers for further processing
 * -) Apply TV settings
d7006 1
a7006 2
static void
SiSPostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d7015 1
a7015 3
    int myclock, temp;
    unsigned char  sr2b, sr2c, tmpreg;
    float          num, denum, postscalar, divider;
a7020 1
    pSiS->CRT1isoff = pSiS->CRT1off;
d7029 2
a7030 2
	   pSiS->VBFlags = pSiS->VBFlags_backup;
	   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
d7034 3
a7036 3
	/* -) We can't switch off CRT1 if bridge is in SlaveMode.
	 * -) If we change to a SlaveMode-Mode (like 512x384), we
	 *    need to adapt VBFlags for eg. Xv.
d7041 9
a7049 9
	   if(SiSBridgeIsInSlaveMode(pScrn)) {
	      doit = FALSE;
	      temp = pSiS->VBFlags;
	      pSiS->VBFlags &= (~VB_DISPMODE_SINGLE);
	      pSiS->VBFlags |= (VB_DISPMODE_MIRROR | DISPTYPE_DISP1);
              if(temp != pSiS->VBFlags) {
		 xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 	"VBFlags changed to 0x%0lx\n", pSiS->VBFlags);
	      }
d7054 15
a7068 35

	if(pSiS->VGAEngine == SIS_315_VGA) {

	   if((pSiS->CRT1off) && (doit)) {
	      orSISIDXREG(SISCR,pSiS->myCR63,0x40);
	      orSISIDXREG(SISSR,0x1f,0xc0);
	   } else {
	      andSISIDXREG(SISCR,pSiS->myCR63,0xBF);
	      andSISIDXREG(SISSR,0x1f,0x3f);
	   }

	} else {

	   if(doit) {
              inSISIDXREG(SISCR, 0x17, usScratchCR17);
    	      if(pSiS->CRT1off) {
	         if(usScratchCR17 & 0x80) {
		    flag = TRUE;
		    usScratchCR17 &= ~0x80;
		 }
		 orSISIDXREG(SISSR,0x1f,0xc0);
    	      } else {
	         if(!(usScratchCR17 & 0x80)) {
		    flag = TRUE;
        	    usScratchCR17 |= 0x80;
		 }
		 andSISIDXREG(SISSR,0x1f,0x3f);
              }
	      /* Reset only if status changed */
	      if(flag) {
	         outSISIDXREG(SISCR, 0x17, usScratchCR17);
	         outSISIDXREG(SISSR, 0x00, 0x01);    /* Synchronous Reset */
	         usleep(10000);
                 outSISIDXREG(SISSR, 0x00, 0x03);    /* End Reset */
	      }
a7070 111

    }

    /* Determine if the video overlay can be used */
    if(!pSiS->NoXvideo) {
       inSISIDXREG(SISSR,0x2b,sr2b);
       inSISIDXREG(SISSR,0x2c,sr2c);
       divider = (sr2b & 0x80) ? 2.0 : 1.0;
       postscalar = (sr2c & 0x80) ?
              ( (((sr2c >> 5) & 0x03) == 0x02) ? 6.0 : 8.0 ) :
	      ( ((sr2c >> 5) & 0x03) + 1.0 );
       num = (sr2b & 0x7f) + 1.0;
       denum = (sr2c & 0x1f) + 1.0;
       myclock = (int)((14318 * (divider / postscalar) * (num / denum)) / 1000);

       pSiS->MiscFlags &= ~(MISC_CRT1OVERLAY | MISC_CRT1OVERLAYGAMMA);
       switch(pSiS->sishw_ext.jChipType) {
         case SIS_300:
         case SIS_540:
         case SIS_630:
         case SIS_730:
            if(myclock < 150) {
               pSiS->MiscFlags |= MISC_CRT1OVERLAY;
            }
            break;
         case SIS_550:
         case SIS_650:
         case SIS_740:
	    if(myclock < 175) {
               pSiS->MiscFlags |= MISC_CRT1OVERLAY;
	       if(myclock < 166) {
	          pSiS->MiscFlags |= MISC_CRT1OVERLAYGAMMA;
	       }
            }
            break;
	 case SIS_315H:
         case SIS_315:
         case SIS_315PRO:
         case SIS_330:
	 case SIS_661:
	 case SIS_741:
	 case SIS_660:
	 case SIS_760:
            if(myclock < 180) {
               pSiS->MiscFlags |= MISC_CRT1OVERLAY;
	       if(myclock < 166) {
	          pSiS->MiscFlags |= MISC_CRT1OVERLAYGAMMA;
	       }
            }
            break;
       }
       if(!(pSiS->MiscFlags & MISC_CRT1OVERLAY)) {
#ifdef SISDUALHEAD
          if((!pSiS->DualHeadMode) || (pSiS->SecondHead))
#endif
             xf86DrvMsgVerb(pScrn->scrnIndex, X_WARNING, 3,
	     	"Current dotclock (%dMhz) too high for video overlay on CRT1\n",
		myclock);
       }
    }

    /* Determine if the Panel Link scaler is active */
    pSiS->MiscFlags &= ~MISC_PANELLINKSCALER;
    if(pSiS->VBFlags & (CRT2_LCD | CRT1_LCDA)) {
       if(pSiS->VGAEngine == SIS_300_VGA) {
          if(pSiS->VBFlags & (VB_LVDS | VB_30xBDH)) {
	     inSISIDXREG(SISPART1,0x1e,tmpreg);
	     tmpreg &= 0x3f;
	     if(tmpreg) pSiS->MiscFlags |= MISC_PANELLINKSCALER;
	  }
       } else {
          if(pSiS->VBFlags & (VB_LVDS | VB_30xBDH | CRT1_LCDA)) {
	     inSISIDXREG(SISPART1,0x35,tmpreg);
	     tmpreg &= 0x04;
	     if(!tmpreg) pSiS->MiscFlags |= MISC_PANELLINKSCALER;
	  }
       }
    }

    /* Determine if our very special TV mode is active */
    pSiS->MiscFlags &= ~MISC_TVNTSC1024;
    if((pSiS->VBFlags & VB_SISBRIDGE) && (pSiS->VBFlags & CRT2_TV) && (!(pSiS->VBFlags & TV_HIVISION))) {
       if( ((pSiS->VBFlags & TV_YPBPR) && (pSiS->VBFlags & TV_YPBPR525I)) ||
           ((!(pSiS->VBFlags & TV_YPBPR)) && (pSiS->VBFlags & (TV_NTSC | TV_PALM))) ) {
          inSISIDXREG(SISCR,0x34,tmpreg);
	  tmpreg &= 0x7f;
	  if((tmpreg == 0x64) || (tmpreg == 0x4a) || (tmpreg == 0x38)) {
	     pSiS->MiscFlags |= MISC_TVNTSC1024;
	  }
       }
    }

#ifdef SISVRAMQ
    if(pSiS->VGAEngine == SIS_315_VGA) {
       int i;
       /* Re-Enable command queue */
       SiSEnableTurboQueue(pScrn);
       /* Get HWCursor register contents for backup */
       for(i = 0; i < 16; i++) {
          pSiS->HWCursorBackup[i] = MMIO_IN32(pSiS->IOBase, 0x8500 + (i << 2));
       }
       if(pSiS->sishw_ext.jChipType >= SIS_330) {
          /* Enable HWCursor protection (Y pos as trigger) */
          andSISIDXREG(SISCR, 0x5b, ~0x30);
       }
    }
#endif

    /* Reset XV gamma correction */
    if(pSiS->ResetXvGamma) {
       (pSiS->ResetXvGamma)(pScrn);
d7073 1
a7073 1
    /*  Apply TV settings given by options
d7077 1
a7077 1
	   -> Hence, in both cases, the settings must be re-applied.
d7092 1
a7092 1
#ifdef SISDUALHEAD
d7138 1
a7138 1
	     if(pSiSEnt) {
d7142 1
a7142 1
#endif
d7145 1
a7145 1
	     /* Not supported by hardware */
d7161 1
a7161 1
#endif
a7168 4
	  int mysistvcolcalibf = pSiS->sistvcolcalibf;
	  int mysistvcolcalibc = pSiS->sistvcolcalibc;
	  int mysistvcfilter = pSiS->sistvcfilter;
	  int mysistvyfilter = pSiS->sistvyfilter;
a7170 5
	  int mytvxscale = pSiS->tvxscale;
	  int mytvyscale = pSiS->tvyscale;
	  int i;
	  unsigned long cbase;
	  unsigned char ctemp;
a7174 4
	     mysistvcolcalibf = pSiSEnt->sistvcolcalibf;
	     mysistvcolcalibc = pSiSEnt->sistvcolcalibc;
	     mysistvcfilter = pSiSEnt->sistvcfilter;
	     mysistvyfilter = pSiSEnt->sistvyfilter;
a7176 2
	     mytvxscale = pSiSEnt->tvxscale;
	     mytvyscale = pSiSEnt->tvyscale;
d7178 3
a7180 4
#endif
          /* Backup default TV position, scale and colcalib registers */
	  inSISIDXREG(SISPART2,0x1f,pSiS->p2_1f);
	  inSISIDXREG(SISPART2,0x20,pSiS->p2_20);
a7182 39
	  inSISIDXREG(SISPART2,0x44,pSiS->p2_44);
	  inSISIDXREG(SISPART2,0x45,pSiS->p2_45);
	  if(!(pSiS->VBFlags & VB_301)) {
	     inSISIDXREG(SISPART2,0x46,pSiS->p2_46);
	  } else {
	     pSiS->p2_46 = 0;
	  }
	  inSISIDXREG(SISPART2,0x0a,pSiS->p2_0a);
	  inSISIDXREG(SISPART2,0x31,cbase);
	  cbase = (cbase & 0x7f) << 8;
	  inSISIDXREG(SISPART2,0x32,ctemp);
	  cbase = (cbase | ctemp) << 8;
	  inSISIDXREG(SISPART2,0x33,ctemp);
	  cbase = (cbase | ctemp) << 8;
	  inSISIDXREG(SISPART2,0x34,ctemp);
	  pSiS->sistvccbase = (cbase | ctemp);
	  inSISIDXREG(SISPART2,0x35,pSiS->p2_35);
	  inSISIDXREG(SISPART2,0x36,pSiS->p2_36);
	  inSISIDXREG(SISPART2,0x37,pSiS->p2_37);
	  inSISIDXREG(SISPART2,0x38,pSiS->p2_38);
	  if(!(pSiS->VBFlags & VB_301)) {
	     inSISIDXREG(SISPART2,0x47,pSiS->p2_47);
	     inSISIDXREG(SISPART2,0x48,pSiS->p2_48);
	     inSISIDXREG(SISPART2,0x49,pSiS->p2_49);
	     inSISIDXREG(SISPART2,0x4a,pSiS->p2_4a);
	  }
	  inSISIDXREG(SISPART2,0x2f,pSiS->p2_2f);
	  inSISIDXREG(SISPART2,0x30,pSiS->p2_30);
	  for(i=0; i<9; i++) {
	     inSISIDXREG(SISPART1,SiSScalingP1Regs[i],pSiS->scalingp1[i]);
	  }
	  for(i=0; i<9; i++) {
	     inSISIDXREG(SISPART4,SiSScalingP4Regs[i],pSiS->scalingp4[i]);
	  }
	  if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
	     for(i=0; i<64; i++) {
	        inSISIDXREG(SISPART2,(0xc0 + i),pSiS->scalingp2[i]);
  	     }
	  }
d7184 4
a7187 22
	  if(pSiSEnt) {
	     pSiSEnt->p2_1f = pSiS->p2_1f; pSiSEnt->p2_20 = pSiS->p2_20;
	     pSiSEnt->p2_01 = pSiS->p2_01; pSiSEnt->p2_02 = pSiS->p2_02;
	     pSiSEnt->p2_44 = pSiS->p2_44; pSiSEnt->p2_45 = pSiS->p2_45;
	     pSiSEnt->p2_46 = pSiS->p2_46; pSiSEnt->p2_0a = pSiS->p2_0a;
	     pSiSEnt->sistvccbase = pSiS->sistvccbase;
	     pSiSEnt->p2_35 = pSiS->p2_35; pSiSEnt->p2_36 = pSiS->p2_36;
	     pSiSEnt->p2_37 = pSiS->p2_37; pSiSEnt->p2_38 = pSiS->p2_38;
	     pSiSEnt->p2_48 = pSiS->p2_48; pSiSEnt->p2_49 = pSiS->p2_49;
	     pSiSEnt->p2_4a = pSiS->p2_4a; pSiSEnt->p2_2f = pSiS->p2_2f;
	     pSiSEnt->p2_30 = pSiS->p2_30; pSiSEnt->p2_47 = pSiS->p2_47;
	     for(i=0; i<9; i++) {
	        pSiSEnt->scalingp1[i] = pSiS->scalingp1[i];
	     }
	     for(i=0; i<9; i++) {
	        pSiSEnt->scalingp4[i] = pSiS->scalingp4[i];
	     }
	     if(pSiS->VBFlags & (VB_301C | VB_302ELV)) {
	        for(i=0; i<64; i++) {
	           pSiSEnt->scalingp2[i] = pSiS->scalingp2[i];
  	        }
	     }
d7189 1
a7189 1
#endif
a7195 12
	  if((val = mysistvcfilter) != -1) {
	     SiS_SetSISTVcfilter(pScrn, val);
	  }
	  if((val = mysistvyfilter) != 1) {
	     SiS_SetSISTVyfilter(pScrn, val);
	  }
	  if((val = mysistvcolcalibc) != 0) {
	     SiS_SetSISTVcolcalib(pScrn, val, TRUE);
	  }
	  if((val = mysistvcolcalibf) != 0) {
	     SiS_SetSISTVcolcalib(pScrn, val, FALSE);
	  }
d7200 2
a7201 8
	     SiS_SetTVyposoffset(pScrn, val);
	  }
	  if((val = mytvxscale) != 0) {
	     SiS_SetTVxscale(pScrn, val);
	  }
	  if((val = mytvyscale) != 0) {
	     SiS_SetTVyscale(pScrn, val);
	  }
d7208 1
a7208 2
static void
SiS6326PostSetMode(ScrnInfoPtr pScrn, SISRegPtr sisReg)
d7215 1
a7215 1

d7230 1
a7230 1
    /* Handle TVPosOffset options (BEFORE switching on TV) */
d7238 2
a7239 2
    /* Switch on TV output. This is rather complicated, but
     * if we don't do it, TV output will flicker terribly.
d7268 2
a7269 2
    /* Apply TV settings given by options */
    if((val = pSiS->sistvantiflicker) != -1) {
d7299 1
a7299 1
/* Build a list of the VESA modes the BIOS reports as valid */
d7312 1
a7312 1
	if((mode = VBEGetModeInfo(pVbe, id)) == NULL)
d7325 1
a7325 1
	      "BIOS supports VESA mode 0x%x: x:%i y:%i bpp:%i\n",
d7334 1
a7334 1
/* Calc VESA mode from given resolution/depth */
a7355 10
      case 320:
          if(mode->VDisplay == 200)
             ModeIndex = VESAModeIndex_320x200[i];
	  else if(mode->VDisplay == 240)
             ModeIndex = VESAModeIndex_320x240[i];
          break;
      case 400:
          if(mode->VDisplay == 300)
             ModeIndex = VESAModeIndex_400x300[i];
          break;
a7362 2
	  else if(mode->VDisplay == 400)
             ModeIndex = VESAModeIndex_640x400[i];
d7393 1
a7393 92
USHORT
SiS_CalcModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode, unsigned long VBFlags, BOOLEAN havecustommodes)
{
   SISPtr pSiS = SISPTR(pScrn);
   UShort i = (pSiS->CurrentLayout.bitsPerPixel+7)/8 - 1;

   if(!(VBFlags & CRT1_LCDA)) {
      if((havecustommodes) && (!(mode->type & M_T_DEFAULT))) {
         return 0xfe;
      }
   } else {
      if((mode->HDisplay > pSiS->LCDwidth) ||
         (mode->VDisplay > pSiS->LCDheight)) {
	 return 0;
      }
   }

   return(SiS_GetModeID(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i, pSiS->FSTN));
}

USHORT
SiS_CheckCalcModeIndex(ScrnInfoPtr pScrn, DisplayModePtr mode, unsigned long VBFlags, BOOLEAN havecustommodes)
{
   SISPtr pSiS = SISPTR(pScrn);
   UShort i = (pSiS->CurrentLayout.bitsPerPixel+7)/8 - 1;
   UShort ModeIndex = 0;
   int    j;

#ifdef TWDEBUG
   xf86DrvMsg(0, X_INFO, "Inside CheckCalcModeIndex (VBFlags %x, mode %dx%d)\n",
   	VBFlags,mode->HDisplay, mode->VDisplay);
#endif

   if(VBFlags & CRT2_LCD) {			/* CRT2 is LCD */

      if(pSiS->SiS_Pr->CP_HaveCustomData) {
         for(j=0; j<7; j++) {
            if((pSiS->SiS_Pr->CP_DataValid[j]) &&
               (mode->HDisplay == pSiS->SiS_Pr->CP_HDisplay[j]) &&
               (mode->VDisplay == pSiS->SiS_Pr->CP_VDisplay[j]) &&
               (mode->type & M_T_BUILTIN))
               return 0xfe;
	 }
      }

      if((pSiS->AddedPlasmaModes) && (mode->type & M_T_BUILTIN))
         return 0xfe;

      if((havecustommodes) &&
         (pSiS->LCDwidth) &&		/* = test if LCD present */
         (!(mode->type & M_T_DEFAULT)) &&
	 (!(mode->Flags & V_INTERLACE)))
         return 0xfe;

      if( ((mode->HDisplay <= pSiS->LCDwidth) &&
           (mode->VDisplay <= pSiS->LCDheight)) ||
	  ((pSiS->SiS_Pr->SiS_CustomT == CUT_PANEL848) &&
	   (((mode->HDisplay == 1360) && (mode->HDisplay == 768)) ||
	    ((mode->HDisplay == 1024) && (mode->HDisplay == 768)) ||
	    ((mode->HDisplay ==  800) && (mode->HDisplay == 600)))) ) {

         ModeIndex = SiS_GetModeID_LCD(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i,
	 			       pSiS->FSTN, pSiS->SiS_Pr->SiS_CustomT, pSiS->LCDwidth, pSiS->LCDheight);

      }

   } else if(VBFlags & CRT2_TV) {		/* CRT2 is TV */

      ModeIndex = SiS_GetModeID_TV(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i);

   } else if(VBFlags & CRT2_VGA) {		/* CRT2 is VGA2 */

      if((pSiS->AddedPlasmaModes) && (mode->type & M_T_BUILTIN))
	 return 0xfe;

      if((havecustommodes) &&
	 (!(mode->type & M_T_DEFAULT)) &&
	 (!(mode->Flags & V_INTERLACE)))
         return 0xfe;

      ModeIndex = SiS_GetModeID_VGA2(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay, i);

   } else {					/* CRT1 only, no CRT2 */

      ModeIndex = SiS_CalcModeIndex(pScrn, mode, VBFlags, havecustommodes);

   }

   return(ModeIndex);
}

/* Calculate the vertical refresh rate from a mode */
d7426 4
a7429 4
/* Calculate CR33 (rate index) for CRT1.
 * Calculation is done using currentmode, therefore it is
 * recommended to set VertRefresh and HorizSync to correct
 * values in config file.
d7444 2
a7445 2
      if(xres == 800 || xres == 1024 || xres == 1280) return 0x02;
      else return 0x01;
d7465 2
a7466 2
   xf86DrvMsg(0, X_INFO, "Debug: CalcVRate returned %d\n", irefresh);
#endif    
d7474 2
a7475 2
#ifdef TWDEBUG 
   xf86DrvMsg(0, X_INFO, "Debug: Rate after correction = %d\n", irefresh);
a7493 3
	       } else if((irefresh - sisx_vrate[i].refresh) <= 2) {
	           index = sisx_vrate[i].idx;
		   break;
d7502 1
a7502 1
        /* Default Rate index */
d7518 2
a7519 3
   inSISIDXREG(SISSR,0x1f,temp);
   if(temp & 0xc0) return;

a7521 2
   watchdog = 65536;
   while((!(inSISREG(SISINPSTAT) & 0x08)) && --watchdog);
a7530 5
   if(SiSBridgeIsInSlaveMode(pScrn)) {
      SISWaitRetraceCRT1(pScrn);
      return;
   }

d7533 1
a7533 1
   	reg = 0x25;
d7536 1
a7536 1
   	reg = 0x30;
d7545 1
a7545 1
	if(!(temp & 0x02)) break;
d7550 1
a7550 1
	if(temp & 0x02) break;
a7558 1
   if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
d7560 6
a7565 6
      if(pSiS->DualHeadMode) {
   	 if(pSiS->SecondHead)
	    SISWaitRetraceCRT1(pScrn);
         else
	    SISWaitRetraceCRT2(pScrn);
      } else {
d7567 8
a7574 8
	 if(pSiS->VBFlags & DISPTYPE_DISP1) {
	    SISWaitRetraceCRT1(pScrn);
	 }
	 if(pSiS->VBFlags & DISPTYPE_DISP2) {
	    if(!(SiSBridgeIsInSlaveMode(pScrn))) {
	       SISWaitRetraceCRT2(pScrn);
	    }
	 }
d7576 1
a7576 1
      }
a7577 34
   } else {
      SISWaitRetraceCRT1(pScrn);
   }
}

#define MODEID_OFF 0x449

unsigned char
SiS_GetSetModeID(ScrnInfoPtr pScrn, unsigned char id)
{
    return(SiS_GetSetBIOSScratch(pScrn, MODEID_OFF, id));
}

unsigned char
SiS_GetSetBIOSScratch(ScrnInfoPtr pScrn, USHORT offset, unsigned char value)
{
    unsigned char ret;
    unsigned char *base;

    base = xf86MapVidMem(pScrn->scrnIndex, VIDMEM_MMIO, 0, 0x2000);
    if(!base) {
       SISErrorLog(pScrn, "(Could not map BIOS scratch area)\n");
       return 0;
    }

    ret = *(base + offset);

    /* value != 0xff means: set register */
    if(value != 0xff)
       *(base + offset) = value;

    xf86UnMapVidMem(pScrn->scrnIndex, base, 0x2000);

    return ret;
d7602 3
a7604 3
          SISErrorLog(pSiS->pScrn,
               "Failed to unlock sr registers (%p, %lx, 0x%02x; %ld)\n",
	       (void *)pSiS, (unsigned long)pSiS->RelIO, val, mylockcalls);
d7610 1
a7610 2
			"SR%02d: RelIO=0x%02x 0x3c4=0x%02x (%d)\n",
			i, val1, val2, mylockcalls);
d7629 3
a7631 3
	     SISErrorLog(pSiS->pScrn,
	        "Failed to unlock cr registers (%p, %lx, 0x%02x)\n",
	       (void *)pSiS, (unsigned long)pSiS->RelIO, val);
@


1.1.1.4
log
@Import OpenBSD X-Window subsystem (based upon XFree86 4.4RC2)
into vendor branch
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_driver.c,v 1.185 2004/02/27 17:29:24 twini Exp $ */
d15 4
a18 1
 * 3) The name of the author may not be used to endorse or promote products
d159 1
a159 1
    { PCI_CHIP_SIS660,      "SIS660/661FX/M661FX/M661MX/741/741GX/M741/760/M760" },
a2572 1
		pSiS->mmioSize = 128;
a2580 1
		pSiS->mmioSize = 128;
a2585 1
		pSiS->mmioSize = 128;
a2592 1
		pSiS->mmioSize = 128;
a2601 1
		pSiS->mmioSize = 128;
a2610 1
		pSiS->mmioSize = 128;
a2617 1
		pSiS->mmioSize = 128;
a2627 1
		pSiS->mmioSize = 128;
a2634 1
		pSiS->mmioSize = 256;
a2642 1
		   pSiS->mmioSize = 256;
a2646 1
		   pSiS->mmioSize = 256;
a2650 1
		   pSiS->mmioSize = 128;
a2655 1
		   pSiS->mmioSize = 128;
a2671 1
		pSiS->mmioSize = 64;
a2675 1
		pSiS->mmioSize = 64;
d2692 1
a2692 2
    pSiS->sisfbpdc = 0xff;
    pSiS->sisfbpdca = 0xff;
a2771 1
				  if(!pSiS->sisfbpdc) pSiS->sisfbpdc = 0xff;
d2793 2
a2794 12
				     }
				     if(sisfbversion >= 0x010619) {
				        pSiS->sisfb_haveemilcd = mysisfbinfo.sisfb_haveemilcd ? TRUE : FALSE;
				     }
				     if(sisfbversion >= 0x01061f) {
					pSiS->sisfbpdca = mysisfbinfo.sisfb_lcdpdca;
				     } else {
				        if(pSiS->sisfbpdc) {
				           pSiS->sisfbpdca = (pSiS->sisfbpdc & 0xf0) >> 3;
					   pSiS->sisfbpdc  = (pSiS->sisfbpdc & 0x0f) << 1;
					} else {
					   pSiS->sisfbpdca = pSiS->sisfbpdc = 0xff;
a2854 1
	     pSiSEnt->ROM661New = FALSE;
a2902 3
       pSiS->SiS_Pr->PanelSelfDetected = FALSE;
       pSiS->SiS_Pr->UsePanelScaler = -1;
       pSiS->SiS_Pr->CenterScreen = -1;
d2904 1
a2904 1
       pSiS->SiS_Pr->PDC = pSiS->SiS_Pr->PDCA = -1;
a3146 1
    pSiS->ROM661New = FALSE;
d3151 1
a3151 1
          if(pSiSEnt->BIOS) {
a3153 1
	     pSiS->ROM661New = pSiSEnt->ROM661New;
d3198 3
a3201 1
		pSiS->ROM661New = SiSDetermineROMLayout661(pSiS->SiS_Pr,&pSiS->sishw_ext);
d3204 2
a3205 8
			"Video BIOS version \"%7s\" found at 0x%lx (%s data layout)\n",
			&pSiS->BIOS[romptr], segstart, pSiS->ROM661New ? "new" : "old");
#ifdef SISDUALHEAD
                if(pSiSEnt) {
		   pSiSEnt->BIOS = pSiS->BIOS;
		   pSiSEnt->ROM661New = pSiS->ROM661New;
		}
#endif
a3240 1
	     pSiSEnt->CenterLCD = pSiS->CenterLCD;
a3277 1
	     pSiSEnt->SenseYPbPr = pSiS->SenseYPbPr;
d3301 1
a3312 1
	     pSiS->CenterLCD = pSiSEnt->CenterLCD;
a3341 1
	     pSiS->SenseYPbPr = pSiSEnt->SenseYPbPr;
a3383 1
       pSiS->SiS_Pr->CenterScreen = pSiS->CenterLCD;
d3423 2
a3424 2
    xf86DrvMsg(pScrn->scrnIndex, from, "MMIO registers at 0x%lX (size %ldK)\n",
           (unsigned long)pSiS->IOAddress, pSiS->mmioSize);
d3507 1
a3507 1
#endif
d3886 4
a3912 9
    if(pSiS->VBFlags & CRT2_LCD) {
       if((pSiS->VGAEngine != SIS_300_VGA) || (!(pSiS->VBFlags & VB_TRUMPION))) {
          pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTSCALE;
          if(pSiS->VBFlags & (VB_301|VB_301B|VB_302B|VB_301C)) {
             pSiS->SiS_SD_Flags |= SiS_SD_SUPPORTCENTER;
          }
       }
    }

d3963 1
d3978 1
a3978 1
     * If no type forced, use the detected devices in the order TV->LCD->VGA2
d3983 3
a3985 1
       if((pSiS->VBFlags & CRT2_TV) && (!((pSiS->VBFlags & VB_CHRONTEL) && (pSiS->VGAEngine == SIS_300_VGA))))
a3990 2
       else if(pSiS->VBFlags & CRT2_VGA)
          pSiS->ForceCRT2Type = CRT2_VGA;
d4398 1
a4398 1
	     if(pSiS->sisfbpdc != 0xff) {
d4476 1
a4476 1
          unsigned char tmp, tmp2;
d4479 5
a4483 4
	  /* Save the current PDC if the panel is used at the moment. */
	  if(pSiS->VBFlags & (VB_301LV | VB_302LV | VB_302ELV)) {

	     if(pSiS->sisfbpdc != 0xff) {
a4484 35
	     }
	     if(pSiS->sisfbpdca != 0xff) {
	        pSiS->SiS_Pr->PDCA = pSiS->sisfbpdca;
	     }

	     if(!pSiS->donttrustpdc) {
	        if((pSiS->sisfbpdc == 0xff) && (pSiS->sisfbpdca == 0xff)) {
		   CARD16 tempa, tempb;
		   inSISIDXREG(SISPART1,0x2d,tmp2);
		   tempa = (tmp2 & 0xf0) >> 3;
		   tempb = (tmp2 & 0x0f) << 1;
		   inSISIDXREG(SISPART1,0x20,tmp2);
		   tempa |= ((tmp2 & 0x40) >> 6);
		   inSISIDXREG(SISPART1,0x35,tmp2);
		   tempb |= ((tmp2 & 0x80) >> 7);
		   inSISIDXREG(SISPART1,0x13,tmp2);
		   if(!pSiS->ROM661New) {
		      if((tmp2 & 0x04) || (tmp & 0x20)) {
		         pSiS->SiS_Pr->PDCA = tempa;
		         pSiS->SiS_Pr->PDC  = tempb;
		      } else {
		         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	             "Unable to detect PanelDelayCompensation, LCD is not active\n");
		      }
		   } else {
		      if(tmp2 & 0x04) {
		         pSiS->SiS_Pr->PDCA = tempa;
		      } else if(tmp & 0x20) {
		         pSiS->SiS_Pr->PDC  = tempb;
		      } else {
		         xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	             "Unable to detect PanelDelayCompensation, LCD is not active\n");
		      }
		   }
		}
d4486 11
a4496 2
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      	    "Unable to detect PanelDelayCompensation, please update sisfb\n");
d4500 1
a4500 1
	      	     "Detected LCD PanelDelayCompensation 0x%02x (for LCD=CRT2)\n",
a4502 9
	     if(pSiS->SiS_Pr->PDCA != -1) {
	        xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
	      	     "Detected LCD PanelDelayCompensation1 0x%02x (for LCD=CRT1)\n",
		     pSiS->SiS_Pr->PDCA);
	     }
	  }

	  /* Let user override (for all bridges) */
	  if(pSiS->VBFlags & (VB_301B | VB_301C | VB_301LV | VB_302LV | VB_302ELV)) {
d4504 1
a4504 1
	        pSiS->SiS_Pr->PDC = pSiS->PDC & 0x1f;
d4506 1
a4506 1
	      	     "Using LCD PanelDelayCompensation 0x%02x (for LCD=CRT2)\n",
a4508 6
	     if(pSiS->PDCA != -1) {
	        pSiS->SiS_Pr->PDCA = pSiS->PDCA & 0x1f;
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	      	     "Using LCD PanelDelayCompensation1 0x%02x (for LCD=CRT1)\n",
		     pSiS->SiS_Pr->PDCA);
	     }
d5458 1
a5458 1
                         pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));
d5464 1
a5464 1
                        pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));
d5482 1
a5482 1
                    pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));
d5488 1
a5488 1
                    pSiS->PciTag, pSiS->IOAddress, (pSiS->mmioSize * 1024));
d5555 1
a5555 1
	    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiSEnt->IOBase, (pSiS->mmioSize * 1024));
d5566 1
a5566 1
	    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiSEnt->IOBaseDense, (pSiS->mmioSize * 1024));
d5587 1
a5587 1
    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->IOBase, (pSiS->mmioSize * 1024));
d5590 1
a5590 1
    	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pSiS->IOBaseDense, (pSiS->mmioSize * 1024));
d6120 1
a6120 1
    mode |= (1 << 14); 	/* Use linear adressing */
a6302 1
	      int backupcenter = pSiS->SiS_Pr->CenterScreen;
a6323 1
	      pSiS->SiS_Pr->CenterScreen = 0;
a6332 1
	      pSiS->SiS_Pr->CenterScreen = backupcenter;
a8041 1
       pSiS->ResetXv = pSiS->ResetXvGamma = NULL;
d10075 1
a10075 1
	        unsigned char p2_1f,p2_20,p2_2b,p2_42,p2_43;
d10077 1
a10080 3
		p2_2b = pSiS->p2_2b;
		p2_42 = pSiS->p2_42;
		p2_43 = pSiS->p2_43;
a10084 3
		   p2_2b = pSiSEnt->p2_2b;
		   p2_42 = pSiSEnt->p2_42;
		   p2_43 = pSiSEnt->p2_43;
d10090 1
d10093 25
a10117 5
		p2_2b = ((p2_2b & 0x0f) + (val * 2)) & 0x0f;
		temp = p2_43 | ((p2_42 & 0xf0) << 4);
		temp += (val * 2);
		p2_43 = temp & 0xff;
		p2_42 = (temp & 0xf00) >> 4;
d10121 1
a10121 2
		setSISIDXREG(SISPART2,0x2b,0xF0,p2_2b);
		setSISIDXREG(SISPART2,0x42,0x0F,p2_42);
d10153 1
a10153 1
	          }
a10664 9
    if(pSiS->sishw_ext.jChipType >= SIS_661) {
       inSISIDXREG(SISSR,0x11,tmpreg);
       if(tmpreg & 0x20) {
          inSISIDXREG(SISSR,0x3e,tmpreg);
	  tmpreg = (tmpreg + 1) & 0xff;
	  outSISIDXREG(SISSR,0x3e,tmpreg);
       }
    }

a10966 3
	  inSISIDXREG(SISPART2,0x2b,pSiS->p2_2b);
	  inSISIDXREG(SISPART2,0x42,pSiS->p2_42);
	  inSISIDXREG(SISPART2,0x43,pSiS->p2_43);
a11010 2
	     pSiSEnt->p2_42 = pSiS->p2_42; pSiSEnt->p2_43 = pSiS->p2_43;
	     pSiSEnt->p2_2b = pSiS->p2_2b;
d11284 1
a11284 2
   return(SiS_GetModeID(pSiS->VGAEngine, VBFlags, mode->HDisplay, mode->VDisplay,
   			i, pSiS->FSTN, pSiS->LCDwidth, pSiS->LCDheight));
d11329 1
a11329 1
	 		       pSiS->FSTN, pSiS->SiS_Pr->SiS_CustomT, pSiS->LCDwidth, pSiS->LCDheight);
d11571 1
a11571 2
    unsigned char ret = 0;
#if (defined(i386) || defined(__i386) || defined(__i386__) || defined(__AMD64__))
d11587 1
a11587 1
#endif
@


