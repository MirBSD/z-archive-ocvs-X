head	1.2;
access;
symbols
	tg-mergetmp-2:1.2
	cvs-200410241530:1.1.1.4
	cvs-200410012000:1.1.1.4
	cvs-200407221130:1.1.1.4
	cvs-200407141120:1.1.1.4
	cvs-200406231010:1.1.1.4
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.4
	XFree86_4_4_0:1.1.9.2
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.03.07.18.37.42;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.20.07.33;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.07.33;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.36.43;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.19.53;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.27.16.33.16;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.23.56;	author tg;	state Exp;
branches;
next	1.1.9.2;

1.1.9.2
date	2004.03.05.22.30.16;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@semi-automagic merge of these files (ie, I've skipped through the diffs,
and most of that was done by cvs or that weird script of some minutes ago)
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_opt.c,v 1.57 2004/02/25 17:45:13 twini Exp $ */
/*
 * SiS driver option evaluation
 *
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * "NoAccel", "NoXVideo", "SWCursor", "HWCursor" and "Rotate" option portions
 * Copyright (C) 1999-2004 The XFree86 Project, Inc. Licensed under the terms
 * of the XFree86 license (http://www.xfree86.org/current/LICENSE1.html).
 *
 * Authors:  	Thomas Winischhofer <thomas@@winischhofer.net>
 *              ?
 */

#include "xf86.h"
#include "xf86PciInfo.h"
#include "xf86str.h"
#include "xf86Cursor.h"

#include "sis.h"

extern const customttable mycustomttable[];

typedef enum {
    OPTION_SW_CURSOR,
    OPTION_HW_CURSOR,
    OPTION_NOACCEL,
    OPTION_TURBOQUEUE,
    OPTION_FAST_VRAM,
    OPTION_NOHOSTBUS,
    OPTION_RENDER,
    OPTION_FORCE_CRT1TYPE,
    OPTION_FORCE_CRT2TYPE,
    OPTION_YPBPRAR,
    OPTION_SHADOW_FB,
    OPTION_DRI,
    OPTION_AGP_SIZE,
    OPTION_AGP_SIZE2,
    OPTION_ROTATE,
    OPTION_NOXVIDEO,
    OPTION_VESA,
    OPTION_MAXXFBMEM,
    OPTION_FORCECRT1,
    OPTION_XVONCRT2,
    OPTION_PDC,
    OPTION_PDCA,
    OPTION_PDCS,
    OPTION_PDCAS,
    OPTION_EMI,
    OPTION_TVSTANDARD,
    OPTION_USEROMDATA,
    OPTION_NOINTERNALMODES,
    OPTION_USEOEM,
    OPTION_NOYV12,
    OPTION_CHTVOVERSCAN,
    OPTION_CHTVSOVERSCAN,
    OPTION_CHTVLUMABANDWIDTHCVBS,
    OPTION_CHTVLUMABANDWIDTHSVIDEO,
    OPTION_CHTVLUMAFLICKERFILTER,
    OPTION_CHTVCHROMABANDWIDTH,
    OPTION_CHTVCHROMAFLICKERFILTER,
    OPTION_CHTVCVBSCOLOR,
    OPTION_CHTVTEXTENHANCE,
    OPTION_CHTVCONTRAST,
    OPTION_SISTVEDGEENHANCE,
    OPTION_SISTVANTIFLICKER,
    OPTION_SISTVSATURATION,
    OPTION_SISTVCHROMAFILTER,
    OPTION_SISTVLUMAFILTER,
    OPTION_SISTVCOLCALIBFINE,
    OPTION_SISTVCOLCALIBCOARSE,
    OPTION_TVXPOSOFFSET,
    OPTION_TVYPOSOFFSET,
    OPTION_TVXSCALE,
    OPTION_TVYSCALE,
    OPTION_SIS6326ANTIFLICKER,
    OPTION_SIS6326ENABLEYFILTER,
    OPTION_SIS6326YFILTERSTRONG,
    OPTION_SIS6326FORCETVPPLUG,
    OPTION_SIS6326FSCADJUST,
    OPTION_CHTVTYPE,
    OPTION_USERGBCURSOR,
    OPTION_USERGBCURSORBLEND,
    OPTION_USERGBCURSORBLENDTH,
    OPTION_RESTOREBYSET,
    OPTION_NODDCFORCRT2,
    OPTION_FORCECRT2REDETECTION,
    OPTION_SENSEYPBPR,
    OPTION_CRT1GAMMA,
    OPTION_CRT2GAMMA,
    OPTION_XVGAMMA,
    OPTION_XVDEFCONTRAST,
    OPTION_XVDEFBRIGHTNESS,
    OPTION_XVDEFHUE,
    OPTION_XVDEFSATURATION,
    OPTION_XVDEFDISABLEGFX,
    OPTION_XVDEFDISABLEGFXLR,
    OPTION_XVMEMCPY,
    OPTION_XVUSECHROMAKEY,
    OPTION_XVCHROMAMIN,
    OPTION_XVCHROMAMAX,
    OPTION_XVDISABLECOLORKEY,
    OPTION_XVINSIDECHROMAKEY,
    OPTION_XVYUVCHROMAKEY,
    OPTION_SCALELCD,
    OPTION_CENTERLCD,
    OPTION_SPECIALTIMING,
    OPTION_LVDSHL,
    OPTION_ENABLEHOTKEY,
    OPTION_MERGEDFB,
    OPTION_MERGEDFBAUTO,
    OPTION_CRT2HSYNC,
    OPTION_CRT2VREFRESH,
    OPTION_CRT2POS,
    OPTION_METAMODES,
    OPTION_MERGEDFB2,
    OPTION_CRT2HSYNC2,
    OPTION_CRT2VREFRESH2,
    OPTION_CRT2POS2,
    OPTION_NOSISXINERAMA,
    OPTION_NOSISXINERAMA2,
    OPTION_CRT2ISSCRN0,
    OPTION_MERGEDDPI,
    OPTION_ENABLESISCTRL,
    OPTION_STOREDBRI,
    OPTION_STOREDPBRI,
#ifdef SIS_CP
    SIS_CP_OPT_OPTIONS
#endif
    OPTION_PSEUDO
} SISOpts;

static const OptionInfoRec SISOptions[] = {
    { OPTION_SW_CURSOR,         	"SWcursor",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_HW_CURSOR,         	"HWcursor",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_NOACCEL,           	"NoAccel",                OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_TURBOQUEUE,        	"TurboQueue",             OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_FAST_VRAM,         	"FastVram",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_NOHOSTBUS,         	"NoHostBus",              OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_RENDER,        		"RenderAcceleration",     OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_FORCE_CRT1TYPE,    	"ForceCRT1Type",          OPTV_STRING,    {0}, FALSE },
    { OPTION_FORCE_CRT2TYPE,    	"ForceCRT2Type",          OPTV_STRING,    {0}, FALSE },
    { OPTION_YPBPRAR,  		  	"YPbPrAspectRatio",       OPTV_STRING,    {0}, FALSE },
    { OPTION_SHADOW_FB,         	"ShadowFB",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_DRI,         		"DRI",               	  OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_AGP_SIZE,			"AGPSize",      	  OPTV_INTEGER,   {0}, FALSE },
    { OPTION_AGP_SIZE2,			"GARTSize",      	  OPTV_INTEGER,   {0}, FALSE },
    { OPTION_ROTATE,            	"Rotate",                 OPTV_STRING,    {0}, FALSE },
    { OPTION_NOXVIDEO,          	"NoXvideo",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_VESA,			"Vesa",		          OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_MAXXFBMEM,         	"MaxXFBMem",              OPTV_INTEGER,   {0}, -1    },
    { OPTION_FORCECRT1,         	"ForceCRT1",              OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_XVONCRT2,          	"XvOnCRT2",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_PDC,               	"PanelDelayCompensation", OPTV_INTEGER,   {0}, -1    },
    { OPTION_PDCA,               	"PanelDelayCompensation1",OPTV_INTEGER,   {0}, -1    },
    { OPTION_PDCS,               	"PDC", 			  OPTV_INTEGER,   {0}, -1    },
    { OPTION_PDCAS,               	"PDC1",			  OPTV_INTEGER,   {0}, -1    },
    { OPTION_EMI,               	"EMI", 			  OPTV_INTEGER,   {0}, -1    },
    { OPTION_LVDSHL,			"LVDSHL", 	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SPECIALTIMING,        	"SpecialTiming",          OPTV_STRING,    {0}, -1    },
    { OPTION_TVSTANDARD,        	"TVStandard",             OPTV_STRING,    {0}, -1    },
    { OPTION_USEROMDATA,		"UseROMData",	          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_NOINTERNALMODES,   	"NoInternalModes",        OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_USEOEM, 			"UseOEMData",		  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_NOYV12, 			"NoYV12",		  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVTYPE,			"CHTVType",	          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVOVERSCAN,		"CHTVOverscan",	          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVSOVERSCAN,		"CHTVSuperOverscan",      OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVLUMABANDWIDTHCVBS,	"CHTVLumaBandwidthCVBS",  OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVLUMABANDWIDTHSVIDEO,	"CHTVLumaBandwidthSVIDEO",OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVLUMAFLICKERFILTER,	"CHTVLumaFlickerFilter",  OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVCHROMABANDWIDTH,	"CHTVChromaBandwidth",    OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVCHROMAFLICKERFILTER,	"CHTVChromaFlickerFilter",OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVCVBSCOLOR,		"CHTVCVBSColor",          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVTEXTENHANCE,		"CHTVTextEnhance",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVCONTRAST,		"CHTVContrast",		  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVEDGEENHANCE,		"SISTVEdgeEnhance",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVANTIFLICKER,		"SISTVAntiFlicker",	  OPTV_STRING,    {0}, FALSE },
    { OPTION_SISTVSATURATION,		"SISTVSaturation",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVCHROMAFILTER,		"SISTVCFilter",      	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_SISTVLUMAFILTER,		"SISTVYFilter",	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVCOLCALIBFINE,		"SISTVColorCalibFine",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVCOLCALIBCOARSE,	"SISTVColorCalibCoarse",  OPTV_INTEGER,   {0}, -1    },
    { OPTION_TVXSCALE,			"SISTVXScale", 	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_TVYSCALE,			"SISTVYScale", 	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_TVXPOSOFFSET,		"TVXPosOffset", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_TVYPOSOFFSET,		"TVYPosOffset", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SIS6326ANTIFLICKER,	"SIS6326TVAntiFlicker",   OPTV_STRING,    {0}, FALSE  },
    { OPTION_SIS6326ENABLEYFILTER,	"SIS6326TVEnableYFilter", OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_SIS6326YFILTERSTRONG,	"SIS6326TVYFilterStrong", OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_SIS6326FORCETVPPLUG,	"SIS6326TVForcePlug",     OPTV_STRING,    {0}, -1    },
    { OPTION_SIS6326FSCADJUST,		"SIS6326FSCAdjust", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_USERGBCURSOR, 		"UseColorHWCursor",	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_USERGBCURSORBLEND,		"ColorHWCursorBlending",  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_USERGBCURSORBLENDTH,	"ColorHWCursorBlendThreshold", OPTV_INTEGER,{0},-1   },
    { OPTION_RESTOREBYSET,		"RestoreBySetMode", 	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_NODDCFORCRT2,		"NoCRT2Detection", 	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_FORCECRT2REDETECTION,	"ForceCRT2ReDetection",   OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_SENSEYPBPR,		"SenseYPbPr",   	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CRT1GAMMA,			"CRT1Gamma", 	  	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CRT2GAMMA,			"CRT2Gamma", 	  	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_STOREDBRI,			"StoredGammaBrightness",  OPTV_STRING,    {0}, -1    },
    { OPTION_STOREDPBRI,		"StoredGammaPreBrightness",OPTV_STRING,   {0}, -1    },
    { OPTION_XVGAMMA,			"XvGamma", 	  	  OPTV_STRING,    {0}, -1    },
    { OPTION_XVDEFCONTRAST,		"XvDefaultContrast", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVDEFBRIGHTNESS,		"XvDefaultBrightness", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVDEFHUE,			"XvDefaultHue", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVDEFSATURATION,		"XvDefaultSaturation", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVDEFDISABLEGFX,		"XvDefaultDisableGfx", 	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVDEFDISABLEGFXLR,		"XvDefaultDisableGfxLR",  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVCHROMAMIN,		"XvChromaMin", 	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVCHROMAMAX,		"XvChromaMax", 	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVUSECHROMAKEY,		"XvUseChromaKey",         OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVINSIDECHROMAKEY,		"XvInsideChromaKey",      OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVYUVCHROMAKEY,		"XvYUVChromaKey",         OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVDISABLECOLORKEY,		"XvDisableColorKey",      OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVMEMCPY,			"XvUseMemcpy",  	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_SCALELCD,			"ScaleLCD",	   	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CENTERLCD,			"CenterLCD",	   	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_ENABLEHOTKEY,		"EnableHotkey",	   	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_ENABLESISCTRL,		"EnableSiSCtrl",   	  OPTV_BOOLEAN,   {0}, -1    },
#ifdef SISMERGED
    { OPTION_MERGEDFB,			"MergedFB",		  OPTV_BOOLEAN,	  {0}, FALSE },
    { OPTION_MERGEDFB2,			"TwinView",		  OPTV_BOOLEAN,	  {0}, FALSE },	  /* alias */
    { OPTION_MERGEDFBAUTO,		"MergedFBAuto",		  OPTV_BOOLEAN,	  {0}, FALSE },
    { OPTION_CRT2HSYNC,			"CRT2HSync",		  OPTV_STRING,	  {0}, FALSE },
    { OPTION_CRT2HSYNC2,		"SecondMonitorHorizSync", OPTV_STRING,	  {0}, FALSE },   /* alias */
    { OPTION_CRT2VREFRESH,		"CRT2VRefresh",		  OPTV_STRING,    {0}, FALSE },
    { OPTION_CRT2VREFRESH2,		"SecondMonitorVertRefresh", OPTV_STRING,  {0}, FALSE },   /* alias */
    { OPTION_CRT2POS,   		"CRT2Position",		  OPTV_STRING,	  {0}, FALSE },
    { OPTION_CRT2POS2,   		"TwinViewOrientation",	  OPTV_STRING,	  {0}, FALSE },   /* alias */
    { OPTION_METAMODES,   		"MetaModes",  		  OPTV_STRING,	  {0}, FALSE },
    { OPTION_MERGEDDPI,			"MergedDPI", 		  OPTV_STRING,	  {0}, FALSE },
#ifdef SISXINERAMA
    { OPTION_NOSISXINERAMA,		"NoMergedXinerama",	  OPTV_BOOLEAN,	  {0}, FALSE },
    { OPTION_NOSISXINERAMA2,		"NoTwinviewXineramaInfo", OPTV_BOOLEAN,   {0}, FALSE },   /* alias */
    { OPTION_CRT2ISSCRN0,		"MergedXineramaCRT2IsScreen0",OPTV_BOOLEAN,{0},FALSE },
#endif
#endif
#ifdef SIS_CP
    SIS_CP_OPTION_DETAIL
#endif
    { -1,                       	NULL,                     OPTV_NONE,      {0}, FALSE }
};

void
SiSOptions(ScrnInfoPtr pScrn)
{
    SISPtr      pSiS = SISPTR(pScrn);
    MessageType from;
    char        *strptr;
    static const char *mybadparm = "\"%s\" is is not a valid parameter for option \"%s\"\n";
    static const char *disabledstr = "disabled";
    static const char *enabledstr = "enabled";
    static const char *ilrangestr = "Illegal %s parameter. Valid range is %d through %d\n";

    /* Collect all of the relevant option flags (fill in pScrn->options) */
    xf86CollectOptions(pScrn, NULL);

    /* Process the options */
    if(!(pSiS->Options = xalloc(sizeof(SISOptions)))) return;

    memcpy(pSiS->Options, SISOptions, sizeof(SISOptions));

    xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pSiS->Options);

    /* Set defaults */
    
    pSiS->newFastVram = -1;
    pSiS->NoHostBus = FALSE;
    pSiS->TurboQueue = TRUE;
#ifdef SISVRAMQ
    /* TODO: Option (315 series VRAM command queue) */
    /* But beware: sisfb does not know about this!!! */
    pSiS->cmdQueueSize = 512*1024;
#endif
    pSiS->doRender = TRUE;
    pSiS->HWCursor = TRUE;
    pSiS->Rotate = FALSE;
    pSiS->ShadowFB = FALSE;
    pSiS->loadDRI = FALSE;
    pSiS->agpWantedPages = AGP_PAGES;
    pSiS->VESA = -1;
    pSiS->NoXvideo = FALSE;
    pSiS->maxxfbmem = 0;
    pSiS->forceCRT1 = -1;
    pSiS->DSTN = FALSE;
    pSiS->FSTN = FALSE;
    pSiS->XvOnCRT2 = FALSE;
    pSiS->NoYV12 = -1;
    pSiS->PDC = -1;
    pSiS->PDCA = -1;
    pSiS->EMI = -1;
    pSiS->OptTVStand = -1;
    pSiS->OptROMUsage = -1;
    pSiS->noInternalModes = FALSE;
    pSiS->OptUseOEM = -1;
    pSiS->OptTVOver = -1;
    pSiS->OptTVSOver = -1;
    pSiS->chtvlumabandwidthcvbs = -1;
    pSiS->chtvlumabandwidthsvideo = -1;
    pSiS->chtvlumaflickerfilter = -1;
    pSiS->chtvchromabandwidth = -1;
    pSiS->chtvchromaflickerfilter = -1;
    pSiS->chtvcvbscolor = -1;
    pSiS->chtvtextenhance = -1;
    pSiS->chtvcontrast = -1;
    pSiS->sistvedgeenhance = -1;
    pSiS->sistvantiflicker = -1;
    pSiS->sistvsaturation = -1;
    pSiS->sistvcfilter = -1;
    pSiS->sistvyfilter = 1; /* 0 = off, 1 = default, 2-8 = filter no */
    pSiS->sistvcolcalibc = 0;
    pSiS->sistvcolcalibf = 0;
    pSiS->sis6326enableyfilter = -1;
    pSiS->sis6326yfilterstrong = -1;
    pSiS->sis6326tvplug = -1;
    pSiS->sis6326fscadjust = 0;
    pSiS->tvxpos = 0;
    pSiS->tvypos = 0;
    pSiS->tvxscale = 0;
    pSiS->tvyscale = 0;
    pSiS->NonDefaultPAL = pSiS->NonDefaultNTSC = -1;
    pSiS->chtvtype = -1;
    pSiS->restorebyset = TRUE;
    pSiS->nocrt2ddcdetection = FALSE;
    pSiS->forcecrt2redetection = TRUE;   /* default changed since 13/09/2003 */
    pSiS->SenseYPbPr = TRUE;
    pSiS->ForceCRT1Type = CRT1_VGA;
    pSiS->ForceCRT2Type = CRT2_DEFAULT;
    pSiS->ForceYPbPrAR = TV_YPBPR169;
    pSiS->ForceTVType = -1;
    pSiS->CRT1gamma = TRUE;
    pSiS->CRT1gammaGiven = FALSE;
    pSiS->CRT2gamma = TRUE;
    pSiS->XvGamma = FALSE;
    pSiS->XvGammaGiven = FALSE;
    pSiS->enablesisctrl = FALSE;
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       pSiS->XvDefBri = 10;
       pSiS->XvDefCon = 2;
    } else {
       pSiS->XvDefBri = 0;
       pSiS->XvDefCon = 4;
    }
    pSiS->XvDefHue = 0; 
    pSiS->XvDefSat = 0;
    pSiS->XvDefDisableGfx = FALSE;
    pSiS->XvDefDisableGfxLR = FALSE;
    pSiS->UsePanelScaler = -1;
    pSiS->CenterLCD = -1;
    pSiS->XvUseMemcpy = TRUE;
    pSiS->XvUseChromaKey = FALSE;
    pSiS->XvDisableColorKey = FALSE;
    pSiS->XvInsideChromaKey = FALSE;
    pSiS->XvYUVChromaKey = FALSE;
    pSiS->XvChromaMin = 0x000101fe;
    pSiS->XvChromaMax = 0x000101ff;
    pSiS->XvGammaRed = pSiS->XvGammaGreen = pSiS->XvGammaBlue =
       pSiS->XvGammaRedDef = pSiS->XvGammaGreenDef = pSiS->XvGammaBlueDef = 1000;
    pSiS->GammaBriR = pSiS->GammaBriG = pSiS->GammaBriB = 1000;
    pSiS->GammaPBriR = pSiS->GammaPBriG = pSiS->GammaPBriB = 1000;
    pSiS->HideHWCursor = FALSE;
    pSiS->HWCursorIsVisible = FALSE;
#ifdef SISMERGED
    pSiS->MergedFB = pSiS->MergedFBAuto = FALSE;
    pSiS->CRT2Position = sisRightOf;
    pSiS->CRT2HSync = NULL;
    pSiS->CRT2VRefresh = NULL;
    pSiS->MetaModes = NULL;
    pSiS->MergedFBXDPI = pSiS->MergedFBYDPI = 0;
#ifdef SISXINERAMA
    pSiS->UseSiSXinerama = TRUE;
    pSiS->CRT2IsScrn0 = FALSE;
#endif
#endif
#ifdef SIS_CP
    SIS_CP_OPT_DEFAULT
#endif

    /* Chipset dependent defaults */

    if(pSiS->Chipset == PCI_CHIP_SIS530) {
    	 /* TW: TQ still broken on 530/620? */
	 pSiS->TurboQueue = FALSE;
    }

    if(pSiS->Chipset == PCI_CHIP_SIS6326) {
         pSiS->newFastVram = 1;
    }

    if(pSiS->sishw_ext.jChipType == SIS_315H ||
       pSiS->sishw_ext.jChipType == SIS_315) {
         /* Cursor engine seriously broken */
         pSiS->HWCursor = FALSE;
    }

    /* DRI only supported on 300 series,
     * so don't load DRI by default on
     * others.
     */
    if(pSiS->VGAEngine == SIS_300_VGA) {
       pSiS->loadDRI = TRUE;
    }

#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    pSiS->OptUseColorCursor = 0;
#else
    if(pSiS->VGAEngine == SIS_300_VGA) {
    	pSiS->OptUseColorCursor = 0;
	pSiS->OptUseColorCursorBlend = 1;
	pSiS->OptColorCursorBlendThreshold = 0x37000000;
    } else if(pSiS->VGAEngine == SIS_315_VGA) {
    	pSiS->OptUseColorCursor = 1;
    }
#endif

    if(pSiS->VGAEngine == SIS_300_VGA) {
       pSiS->AllowHotkey = 0;
    } else if(pSiS->VGAEngine == SIS_315_VGA) {
       pSiS->AllowHotkey = 1;
    }

    /* Collect the options */

    /* FastVRAM (5597/5598, 6326 and 530/620 only)
     */
    if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
       from = X_DEFAULT;
       if(xf86GetOptValBool(pSiS->Options, OPTION_FAST_VRAM, &pSiS->newFastVram)) {
          from = X_CONFIG;
       }
       xf86DrvMsg(pScrn->scrnIndex, from, "Fast VRAM %s\n",
                   (pSiS->newFastVram == -1) ?
		         ((pSiS->oldChipset == OC_SIS620) ? "enabled (for read only)" :
			                                    "enabled (for write only)") :
		   	 (pSiS->newFastVram ? "enabled (for read and write)" : disabledstr));
    }

    /* NoHostBus (5597/5598 only)
     */
    if((pSiS->Chipset == PCI_CHIP_SIS5597)) {
       from = X_DEFAULT;
       if(xf86GetOptValBool(pSiS->Options, OPTION_NOHOSTBUS, &pSiS->NoHostBus)) {
          from = X_CONFIG;
       }
       xf86DrvMsg(pScrn->scrnIndex, from, "SiS5597/5598 VGA-to-CPU host bus %s\n",
                   pSiS->NoHostBus ? disabledstr : enabledstr);
    }

    /* MaxXFBMem
     * This options limits the amount of video memory X uses for screen
     * and off-screen buffers. This option should be used if using DRI
     * is intended. The kernel framebuffer driver required for DRM will
     * start its memory heap at 12MB if it detects more than 16MB, at 8MB if
     * between 8 and 16MB are available, otherwise at 4MB. So, if the amount
     * of memory X uses, a clash between the framebuffer's memory heap
     * and X is avoided. The amount is to be specified in KB.
     */
    if(xf86GetOptValULong(pSiS->Options, OPTION_MAXXFBMEM,
                                &pSiS->maxxfbmem)) {
            xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "MaxXFBMem: Framebuffer memory shall be limited to %ld KB\n",
		    pSiS->maxxfbmem);
	    pSiS->maxxfbmem *= 1024;
    }

    /* NoAccel
     * Turns off 2D acceleration
     */
    if(xf86ReturnOptValBool(pSiS->Options, OPTION_NOACCEL, FALSE)) {
        pSiS->NoAccel = TRUE;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	pSiS->NoXvideo = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "2D Acceleration and Xv disabled\n");
#else
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "2D Acceleration disabled\n");
#endif

    }

    /* RenderAcceleration
     * En/Disables RENDER acceleration (315/330 series only)
     */
    if((pSiS->VGAEngine == SIS_315_VGA) && (!pSiS->NoAccel)) {
       if(xf86GetOptValBool(pSiS->Options, OPTION_RENDER, &pSiS->doRender)) {
          if(!pSiS->doRender) {
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "RENDER Acceleration disabled\n");
	  }
       }
    }

    /* SWCursor
     * HWCursor
     * Chooses whether to use the hardware or software cursor
     */
    from = X_DEFAULT;
    if(xf86GetOptValBool(pSiS->Options, OPTION_HW_CURSOR, &pSiS->HWCursor)) {
        from = X_CONFIG;
    }
    if(xf86ReturnOptValBool(pSiS->Options, OPTION_SW_CURSOR, FALSE)) {
        from = X_CONFIG;
        pSiS->HWCursor = FALSE;
	pSiS->OptUseColorCursor = 0;
    }
    xf86DrvMsg(pScrn->scrnIndex, from, "Using %s cursor\n",
                                pSiS->HWCursor ? "HW" : "SW");

    /*
     * UseColorHWCursor
     * ColorHWCursorBlending
     * ColorHWCursorBlendThreshold
     *
     * Enable/disable color hardware cursors;
     * enable/disable color hw cursor emulation for 300 series
     * select emultation transparency threshold for 300 series
     *
     */
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
#ifdef ARGB_CURSOR
#ifdef SIS_ARGB_CURSOR
    if((pSiS->HWCursor) && ((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA))) {
       from = X_DEFAULT;
       if(xf86GetOptValBool(pSiS->Options, OPTION_USERGBCURSOR, &pSiS->OptUseColorCursor)) {
    	   from = X_CONFIG;
       }
       xf86DrvMsg(pScrn->scrnIndex, from, "Color HW cursor is %s\n",
                    pSiS->OptUseColorCursor ? enabledstr : disabledstr);

       if(pSiS->VGAEngine == SIS_300_VGA) {
          from = X_DEFAULT;
          if(xf86GetOptValBool(pSiS->Options, OPTION_USERGBCURSORBLEND, &pSiS->OptUseColorCursorBlend)) {
    	     from = X_CONFIG;
          }
          if(pSiS->OptUseColorCursor) {
             xf86DrvMsg(pScrn->scrnIndex, from,
	   	"HW cursor color blending emulation is %s\n",
		(pSiS->OptUseColorCursorBlend) ? enabledstr : disabledstr);
	  }
	  {
	  int temp;
	  from = X_DEFAULT;
	  if(xf86GetOptValInteger(pSiS->Options, OPTION_USERGBCURSORBLENDTH, &temp)) {
	     if((temp >= 0) && (temp <= 255)) {
	        from = X_CONFIG;
		pSiS->OptColorCursorBlendThreshold = (temp << 24);
	     } else {
	        temp = pSiS->OptColorCursorBlendThreshold >> 24;
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Illegal color HW cursor blending threshold, valid range 0-255\n");
	     }
	  } else {
	        temp = pSiS->OptColorCursorBlendThreshold >> 24;
          }
	  if(pSiS->OptUseColorCursor) {
	     if(pSiS->OptUseColorCursorBlend) {
	        xf86DrvMsg(pScrn->scrnIndex, from,
	          "HW cursor color blending emulation threshold is %d\n", temp);
 	     }
	  }
	  }
       }
    }
#endif
#endif
#endif

    /*
     * MergedFB
     *
     * Enable/disable and configure merged framebuffer mode
     *
     */
#ifdef SISMERGED
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       Bool val;
       if(xf86GetOptValBool(pSiS->Options, OPTION_MERGEDFB, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     "Option \"MergedFB\" cannot be used in Dual Head mode\n");
       }
    } else
#endif
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       Bool val;
       if(xf86GetOptValBool(pSiS->Options, OPTION_MERGEDFB, &val)) {
	  if(val) {
	     pSiS->MergedFB = TRUE;
	     pSiS->MergedFBAuto = FALSE;
	  }
       } else if(xf86GetOptValBool(pSiS->Options, OPTION_MERGEDFB2, &val)) {
          if(val) {
	     pSiS->MergedFB = TRUE;
	     pSiS->MergedFBAuto = FALSE;
	  }
       }

       if(xf86GetOptValBool(pSiS->Options, OPTION_MERGEDFBAUTO, &val)) {
          if(!pSiS->MergedFB) {
	     if(val) {
	        pSiS->MergedFB = pSiS->MergedFBAuto = TRUE;
	     }
	  } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"Option \"MergedFB\" overrules option \"MergedFBAuto\"\n");
	  }
       }

       if(pSiS->MergedFB) {
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2POS);
	  if(!strptr) {
	     strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2POS2);
	  }
      	  if(strptr) {
       	     if(!xf86NameCmp(strptr,"LeftOf")) {
                pSiS->CRT2Position = sisLeftOf;
#ifdef SISXINERAMA
		pSiS->CRT2IsScrn0 = TRUE;
#endif
 	     } else if(!xf86NameCmp(strptr,"RightOf")) {
                pSiS->CRT2Position = sisRightOf;
#ifdef SISXINERAMA
		pSiS->CRT2IsScrn0 = FALSE;
#endif
	     } else if(!xf86NameCmp(strptr,"Above")) {
                pSiS->CRT2Position = sisAbove;
#ifdef SISXINERAMA
		pSiS->CRT2IsScrn0 = FALSE;
#endif
	     } else if(!xf86NameCmp(strptr,"Below")) {
                pSiS->CRT2Position = sisBelow;
#ifdef SISXINERAMA
		pSiS->CRT2IsScrn0 = TRUE;
#endif
	     } else if(!xf86NameCmp(strptr,"Clone")) {
                pSiS->CRT2Position = sisClone;
#ifdef SISXINERAMA
		pSiS->CRT2IsScrn0 = TRUE;
#endif
	     } else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "CRT2Position");
	    	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	            "Valid parameters are \"RightOf\", \"LeftOf\", \"Above\", \"Below\", or \"Clone\"\n");
	     }
	  }
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_METAMODES);
	  if(strptr) {
	     pSiS->MetaModes = xalloc(strlen(strptr) + 1);
	     if(pSiS->MetaModes) memcpy(pSiS->MetaModes, strptr, strlen(strptr) + 1);
	  }
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2HSYNC);
	  if(!strptr) {
	     strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2HSYNC2);
	  }
	  if(strptr) {
	     pSiS->CRT2HSync = xalloc(strlen(strptr) + 1);
	     if(pSiS->CRT2HSync) memcpy(pSiS->CRT2HSync, strptr, strlen(strptr) + 1);
	  }
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2VREFRESH);
	  if(!strptr) {
	     strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2VREFRESH2);
	  }
	  if(strptr) {
	     pSiS->CRT2VRefresh = xalloc(strlen(strptr) + 1);
	     if(pSiS->CRT2VRefresh) memcpy(pSiS->CRT2VRefresh, strptr, strlen(strptr) + 1);
	  }
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_MERGEDDPI);
	  if(strptr) {
	     int val1 = 0, val2 = 0;
	     sscanf(strptr, "%d %d", &val1, &val2);
	     if(val1 && val2) {
	        pSiS->MergedFBXDPI = val1;
		pSiS->MergedFBYDPI = val2;
	     } else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "MergedDPI");
	     }
	  }
#ifdef SISXINERAMA
	  if(pSiS->MergedFB) {
	     if(xf86GetOptValBool(pSiS->Options, OPTION_NOSISXINERAMA, &val)) {
	        if(val) pSiS->UseSiSXinerama = FALSE;
	     } else if(xf86GetOptValBool(pSiS->Options, OPTION_NOSISXINERAMA2, &val)) {
	        if(val) pSiS->UseSiSXinerama = FALSE;
	     }
	     if(pSiS->UseSiSXinerama) {
	        if(xf86GetOptValBool(pSiS->Options, OPTION_CRT2ISSCRN0, &val)) {
		   pSiS->CRT2IsScrn0 = val ? TRUE : FALSE;
		}
	     }
	  }
#endif
       }
    }
#endif

    /* Some options can only be specified in the Master Head's Device
     * section. Here we give the user a hint in the log.
     */
#ifdef SISDUALHEAD
    if((pSiS->DualHeadMode) && (pSiS->SecondHead)) {
       static const char *mystring = "Option \"%s\" is only accepted in Master Head's device section\n";
       Bool val;
       int vali;
       if(pSiS->VGAEngine != SIS_315_VGA) {
          if(xf86GetOptValBool(pSiS->Options, OPTION_TURBOQUEUE, &val)) {
             xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "TurboQueue");
          }
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_RESTOREBYSET, &val)) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "RestoreBySetMode");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_ENABLEHOTKEY, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "EnableHotKey");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_ENABLESISCTRL, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "EnableSiSCtrl");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_USEROMDATA, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "UseROMData");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_USEOEM, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "UseOEMData");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_FORCECRT1, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "ForceCRT1");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_NODDCFORCRT2, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "NoCRT2Detection");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_FORCECRT2REDETECTION, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "ForceCRT2ReDetection");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_SENSEYPBPR, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "SenseYPbPr");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT1TYPE)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "ForceCRT1Type");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT2TYPE)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "ForceCRT2Type");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_YPBPRAR)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "YPbPrAspectRatio");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_SCALELCD, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "ScaleLCD");
       }
        if(xf86GetOptValBool(pSiS->Options, OPTION_CENTERLCD, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "CenterLCD");
       }
       if((xf86GetOptValInteger(pSiS->Options, OPTION_PDC, &vali)) ||
          (xf86GetOptValInteger(pSiS->Options, OPTION_PDCS, &vali))) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "PanelDelayCompensation (PDC)");
       }
       if((xf86GetOptValInteger(pSiS->Options, OPTION_PDCA, &vali)) ||
          (xf86GetOptValInteger(pSiS->Options, OPTION_PDCAS, &vali))) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "PanelDelayCompensation1 (PDC1)");
       }
       if(xf86GetOptValInteger(pSiS->Options, OPTION_EMI, &vali)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "EMI");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_SPECIALTIMING)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "SpecialTiming");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_LVDSHL)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "LVDSHL");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_TVSTANDARD)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "TVStandard");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_CHTVTYPE)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "CHTVType");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_CHTVOVERSCAN, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "CHTVOverscan");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_CHTVSOVERSCAN, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "CHTVSuperOverscan");
       }
       if((xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMABANDWIDTHCVBS, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMABANDWIDTHSVIDEO, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMAFLICKERFILTER, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCHROMABANDWIDTH, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCHROMAFLICKERFILTER, &vali)) ||
          (xf86GetOptValBool(pSiS->Options, OPTION_CHTVCVBSCOLOR, &val)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVTEXTENHANCE, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCONTRAST, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_SISTVEDGEENHANCE, &vali)) ||
	  (xf86GetOptValString(pSiS->Options, OPTION_SISTVANTIFLICKER)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_SISTVSATURATION, &vali)) ||
	  (xf86GetOptValBool(pSiS->Options, OPTION_SISTVCHROMAFILTER, &val)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_SISTVLUMAFILTER, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_SISTVCOLCALIBCOARSE, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_SISTVCOLCALIBFINE, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_TVXPOSOFFSET, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_TVYPOSOFFSET, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_TVXSCALE, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_TVYSCALE, &vali))) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      "TV related options are only accepted in Master Head's device section");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_CRT2GAMMA, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "CRT2Gamma");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_XVONCRT2, &val)) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "XvOnCRT2");
       }
#ifdef SIS_CP
       SIS_CP_OPT_DH_WARN
#endif
    } else
#endif    
    {
       if(pSiS->VGAEngine == SIS_315_VGA) {

#ifdef SISVRAMQ
          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using VRAM command queue, size %dk\n",
	  	pSiS->cmdQueueSize / 1024);
#else
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using MMIO command queue, size 512k\n");
#endif

       } else {

	  /* TurboQueue */

          from = X_DEFAULT;
          if(xf86GetOptValBool(pSiS->Options, OPTION_TURBOQUEUE, &pSiS->TurboQueue)) {
    	     from = X_CONFIG;
          }
          xf86DrvMsg(pScrn->scrnIndex, from, "TurboQueue %s\n",
                    pSiS->TurboQueue ? enabledstr : disabledstr);
       }

       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {

          Bool val;

	  /* RestoreBySetMode (300/315/330 series only)
           * Set this to force the driver to set the old mode instead of restoring
           * the register contents. This can be used to overcome problems with
           * LCD panels and video bridges.
           */
          if(xf86GetOptValBool(pSiS->Options, OPTION_RESTOREBYSET, &val)) {
             pSiS->restorebyset = val ? TRUE : FALSE;
          }

	  /* EnableHotkey (300/315/330 series only)
	   * Enables or disables the BIOS hotkey switch for
	   * switching the output device on laptops.
	   * This key causes a total machine hang on many 300 series
	   * machines, it is therefore by default disabled on such.
	   * In dual head mode, using the hotkey is lethal, so we
	   * forbid it then in any case.
	   * However, although the driver disables the hotkey as
	   * BIOS developers intented to do that, some buggy BIOSes
	   * still cause the machine to freeze. Hence the warning.
	   */
          {
	  int flag = 0;
#ifdef SISDUALHEAD
          if(pSiS->DualHeadMode) {
	     pSiS->AllowHotkey = 0;
	     flag = 1;
	  } else
#endif
	  if(xf86GetOptValBool(pSiS->Options, OPTION_ENABLEHOTKEY, &val)) {
	     pSiS->AllowHotkey = val ? 1 : 0;
          }
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Hotkey display switching is %s%s\n",
	        pSiS->AllowHotkey ? enabledstr : disabledstr,
	        flag ? " in dual head mode" : "");
	  if(pSiS->Chipset == PCI_CHIP_SIS630 ||
	     pSiS->Chipset == PCI_CHIP_SIS650 ||
	     pSiS->Chipset == PCI_CHIP_SIS660) {
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	         "WARNING: Using the Hotkey might freeze your machine, regardless\n");
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "\twhether enabled or disabled. This is no driver bug.\n");
	  }
	  }

          /* UseROMData (300/315/330 series only)
           * This option is enabling/disabling usage of some machine
           * specific data from the BIOS ROM. This option can - and
           * should - be used in case the driver makes problems
           * because SiS changed the location of this data.
           */
	  if(xf86GetOptValBool(pSiS->Options, OPTION_USEROMDATA, &val)) {
	     pSiS->OptROMUsage = val ? 1 : 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "Video ROM data usage shall be %s\n",
	          val ? enabledstr : disabledstr);
	  }

          /* UseOEMData (300/315/330 series only)
           * The driver contains quite a lot data for OEM LCD panels
           * and TV connector specifics which override the defaults.
           * If this data is incorrect, the TV may lose color and
           * the LCD panel might show some strange effects. Use this
           * option to disable the usage of this data.
           */
	  if(xf86GetOptValBool(pSiS->Options, OPTION_USEOEM, &val)) {
	     pSiS->OptUseOEM = val ? 1 : 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "Internal LCD/TV/VGA2 OEM data usage shall be %s\n",
	         val ? enabledstr : disabledstr);
	  }

	  /* NoCRT2DDCDetection (315/330 series only)
           * If set to true, this disables CRT2 detection using DDC. This is
           * to avoid problems with not entirely DDC compiant LCD panels or
           * VGA monitors connected to the secondary VGA plug. Since LCD and
           * VGA share the same DDC channel, it might in some cases be impossible
           * to determine if the device is a CRT monitor or a flat panel.
           */
          if(xf86GetOptValBool(pSiS->Options, OPTION_NODDCFORCRT2, &val)) {
             pSiS->nocrt2ddcdetection = val ? TRUE : FALSE;
          }

	  /* ForceCRT2ReDetection (315/330 series only)
           * If set to true, it forces re-detection of the LCD panel and
	   * a secondary VGA connection even if the BIOS already had found
	   * about it. This is meant for custom panels (ie such with
	   * non-standard resolutions) which the BIOS will "detect" according
	   * to the established timings, resulting in only a very vague idea
	   * about the panels real resolution. As for secondary VGA, this
	   * enables us to include a Plasma panel's proprietary modes.
           */
          if(xf86GetOptValBool(pSiS->Options, OPTION_FORCECRT2REDETECTION, &val)) {
             if(val) {
	             pSiS->forcecrt2redetection = TRUE;
		     pSiS->nocrt2ddcdetection = FALSE;
	     } else  pSiS->forcecrt2redetection = FALSE;
          }

	  /* SenseYPbPr (315/330 series only)
           * If set to true, the driver will sense for YPbPr TV. This is
	   * inconvenient for folks connecting SVideo and CVBS at the same
	   * time, because this condition will be detected as YPbPr (since
	   * the TV output pins are shared). "False" will not sense for
	   * YPbPr and detect SVideo or CVBS only.
           */
          if(xf86GetOptValBool(pSiS->Options, OPTION_SENSEYPBPR, &val)) {
             if(val) pSiS->SenseYPbPr = TRUE;
	     else    pSiS->SenseYPbPr = FALSE;
          }


	  /* ForceCRT1Type (315/330 series only)
	   * Used for forcing the driver to initialize CRT1 as
	   * VGA (analog) or LCDA (for simultanious LCD and TV
           * display) - on M650/651 and 661 or later with 301C/30xLV only!
           */
	  if(pSiS->VGAEngine == SIS_315_VGA) {
             strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT1TYPE);
             if(strptr != NULL) {
                if(!xf86NameCmp(strptr,"VGA")) {
                   pSiS->ForceCRT1Type = CRT1_VGA;
		} else if( (!xf86NameCmp(strptr,"LCD")) ||
		         (!xf86NameCmp(strptr,"LCDA")) ||
			 (!xf86NameCmp(strptr,"LCD-A")) ) {
		   pSiS->ForceCRT1Type = CRT1_LCDA;
		} else {
		   xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "ForceCRT1Type");
	           xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	               "Valid parameters are \"VGA\" or \"LCD\"\n");
		}
	     }
	  }

	  /* ForceCRT1 (300/315/330 series only)
           * This option can be used to force CRT1 to be switched on/off. Its
           * intention is mainly for old monitors that can't be detected
           * automatically. This is only useful on machines with a video bridge.
           * In normal cases, this option won't be necessary.
           */
	  if(xf86GetOptValBool(pSiS->Options, OPTION_FORCECRT1, &val)) {
	     pSiS->forceCRT1 = val ? 1 : 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "CRT1 shall be forced to %s\n",
	         val ? "ON" : "OFF");
	     if(!pSiS->forceCRT1) pSiS->ForceCRT1Type = CRT1_VGA;
	  }

	  /* ForceCRT2Type (300/315/330 series only)
	   * Used for forcing the driver to initialize a given
	   * CRT2 device type.
           * (SVIDEO, COMPOSITE and SCART for overriding detection)
           */
          strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT2TYPE);
          if(strptr != NULL) {
             if(!xf86NameCmp(strptr,"TV"))
                pSiS->ForceCRT2Type = CRT2_TV;
 	     else if( (!xf86NameCmp(strptr,"SVIDEO")) ||
	     	      (!xf86NameCmp(strptr,"SVHS")) ) {
                pSiS->ForceCRT2Type = CRT2_TV;
	        pSiS->ForceTVType = TV_SVIDEO;
             } else if( (!xf86NameCmp(strptr,"COMPOSITE")) ||
	     		(!xf86NameCmp(strptr,"CVBS")) ) {
                pSiS->ForceCRT2Type = CRT2_TV;
	        pSiS->ForceTVType = TV_AVIDEO;
	     } else if( (!xf86NameCmp(strptr,"COMPOSITE SVIDEO")) || /* Ugly, but shorter than a parsing function */
	                (!xf86NameCmp(strptr,"COMPOSITE+SVIDEO")) ||
			(!xf86NameCmp(strptr,"SVIDEO+COMPOSITE")) ||
			(!xf86NameCmp(strptr,"SVIDEO COMPOSITE")) ) {
	        pSiS->ForceCRT2Type = CRT2_TV;
		pSiS->ForceTVType = (TV_SVIDEO | TV_AVIDEO);
             } else if(!xf86NameCmp(strptr,"SCART")) {
                pSiS->ForceCRT2Type = CRT2_TV;
	        pSiS->ForceTVType = TV_SCART;
             } else if((!xf86NameCmp(strptr,"LCD")) || (!xf86NameCmp(strptr,"DVI-D"))) {
	        if(pSiS->ForceCRT1Type == CRT1_VGA) {
                   pSiS->ForceCRT2Type = CRT2_LCD;
		} else {
		   pSiS->ForceCRT2Type = 0;
		   xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   		"Can't set both CRT1 and CRT2 type to LCD; CRT2 disabled\n");
		}
             } else if((!xf86NameCmp(strptr,"VGA")) || (!xf86NameCmp(strptr,"DVI-A")))
                pSiS->ForceCRT2Type = CRT2_VGA;
             else if(!xf86NameCmp(strptr,"NONE"))
                pSiS->ForceCRT2Type = 0;
	     else if((!xf86NameCmp(strptr,"DSTN")) && (pSiS->Chipset == PCI_CHIP_SIS550)) {
		if(pSiS->ForceCRT1Type == CRT1_VGA) {
		   pSiS->ForceCRT2Type = CRT2_LCD;
		   pSiS->DSTN = TRUE;
		}
	     } else if((!xf86NameCmp(strptr,"FSTN")) && (pSiS->Chipset == PCI_CHIP_SIS550)) {
		if(pSiS->ForceCRT1Type == CRT1_VGA) {
		   pSiS->ForceCRT2Type = CRT2_LCD;
		   pSiS->FSTN = TRUE;
		}
#ifdef ENABLE_YPBPR
	     } else if(!xf86NameCmp(strptr,"HIVISION")) {
		pSiS->ForceCRT2Type = CRT2_TV;
	        pSiS->ForceTVType = TV_HIVISION;
	     } else if((!xf86NameCmp(strptr,"YPBPR1080I")) && (pSiS->VGAEngine == SIS_315_VGA)) {
	        pSiS->ForceCRT2Type = CRT2_TV;
		pSiS->ForceTVType = TV_YPBPR;
		pSiS->ForceYPbPrType = TV_YPBPR1080I;
	     } else if(((!xf86NameCmp(strptr,"YPBPR525I")) || (!xf86NameCmp(strptr,"YPBPR480I"))) &&
	               (pSiS->VGAEngine == SIS_315_VGA)) {
		pSiS->ForceCRT2Type = CRT2_TV;
		pSiS->ForceTVType = TV_YPBPR;
		pSiS->ForceYPbPrType = TV_YPBPR525I;
	     } else if(((!xf86NameCmp(strptr,"YPBPR525P")) || (!xf86NameCmp(strptr,"YPBPR480P"))) &&
	               (pSiS->VGAEngine == SIS_315_VGA)) {
		pSiS->ForceCRT2Type = CRT2_TV;
		pSiS->ForceTVType = TV_YPBPR;
		pSiS->ForceYPbPrType = TV_YPBPR525P;
	     } else if(((!xf86NameCmp(strptr,"YPBPR750P")) || (!xf86NameCmp(strptr,"YPBPR720P"))) &&
	               (pSiS->VGAEngine == SIS_315_VGA)) {
		pSiS->ForceCRT2Type = CRT2_TV;
		pSiS->ForceTVType = TV_YPBPR;
		pSiS->ForceYPbPrType = TV_YPBPR750P;
#endif
	     } else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "ForceCRT2Type");
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	            "Valid parameters are \"LCD\" (=\"DVI-D\"), \"TV\", \"SVIDEO\", \"COMPOSITE\",\n"
		    "\t\"SVIDEO+COMPOSITE\", \"SCART\", \"VGA\" (=\"DVI-A\") or \"NONE\"; on the SiS550\n"
		    "\talso \"DSTN\" and \"FSTN\""
#ifdef ENABLE_YPBPR
		    				"; on SiS 301/301B bridges also \"HIVISION\", and on\n"
		    "\tSiS315/330 series with 301C/30xLV bridge also \"YPBPR480I\", \"YPBPR480P\",\n"
		    "\t\"YPBPR720P\" and \"YPBPR1080I\""
#endif
		    "\n");
	     }

             if(pSiS->ForceCRT2Type != CRT2_DEFAULT)
                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "CRT2 type shall be %s\n", strptr);
          }

	  if(pSiS->ForceTVType == TV_YPBPR) {
	     strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_YPBPRAR);
             if(strptr != NULL) {
	        if(!xf86NameCmp(strptr,"4:3LB"))
                   pSiS->ForceYPbPrAR = TV_YPBPR43LB;
		else if(!xf86NameCmp(strptr,"4:3"))
                   pSiS->ForceYPbPrAR = TV_YPBPR43;
		else if(!xf86NameCmp(strptr,"16:9"))
                   pSiS->ForceYPbPrAR = TV_YPBPR169;
		else {
		   xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "YPbPrAspectRatio");
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	            	"Valid parameters are \"4:3LB\", \"4:3\" and \"16:9\"\n");
		}
	     }
	  }

	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SPECIALTIMING);
          if(strptr != NULL) {
	     int i = 0;
	     BOOLEAN found = FALSE;
	     if(!xf86NameCmp(strptr,"NONE")) {
	        pSiS->SiS_Pr->SiS_CustomT = CUT_FORCENONE;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			"Special timing disabled\n");
	     } else {
	        while(mycustomttable[i].chipID != 0) {
	           if(!xf86NameCmp(strptr,mycustomttable[i].optionName)) {
		      pSiS->SiS_Pr->SiS_CustomT = mycustomttable[i].SpecialID;
		      found = TRUE;
		      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		   	  "Special timing for %s %s forced\n",
			  mycustomttable[i].vendorName, mycustomttable[i].cardName);
		      break;
		   }
		   i++;
	        }
		if(!found) {
		   xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "SpecialTiming");
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Valid parameters are:\n");
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "\t\"NONE\" (to disable special timings)\n");
		   i = 0;
		   while(mycustomttable[i].chipID != 0) {
		      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		        	"\t\"%s\" (for %s %s)\n",
				mycustomttable[i].optionName,
				mycustomttable[i].vendorName,
				mycustomttable[i].cardName);
		      i++;
		   }
                }
 	     }
	  }

	  /* EnableSiSCtrl */
	  /* Allow sisctrl tool to change driver settings */
	  from = X_DEFAULT;
	  if(xf86GetOptValBool(pSiS->Options, OPTION_ENABLESISCTRL, &val)) {
             if(val) pSiS->enablesisctrl = TRUE;
	     from = X_CONFIG;
          }
	  xf86DrvMsg(pScrn->scrnIndex, from, "SiSCtrl utility interface is %s\n",
	  	pSiS->enablesisctrl ? enabledstr : disabledstr);

         /* ScaleLCD (300/315/330 series only)
          * Can be used to force the bridge/panel link to [do|not do] the
	  * scaling of modes lower than the panel's native resolution.
          * Setting this to TRUE will force the bridge/panel link
	  * to scale; FALSE will rely on the panel's capabilities.
	  * Not supported on all machines.
          */
	  if(xf86GetOptValBool(pSiS->Options, OPTION_SCALELCD, &val)) {
	     pSiS->UsePanelScaler = val ? 0 : 1;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "LCD scaling is %s\n",
	         pSiS->UsePanelScaler ? disabledstr : enabledstr);
	  }

	 /* CenterLCD (300/315/330 + SiS video bridge only)
          * If LCD shall not be scaled, this selects whether 1:1 data
	  * will be sent to the output, or the image shall be centered
	  * on the LCD. For LVDS panels, screen will always be centered,
	  * since these have no built-in scaler. For TMDS, this is
	  * selectable. Non-centered means that the driver will pass
	  * 1:1 data to the output and that the panel will have to
	  * scale by itself (if supported by the panel).
          */
	  if(xf86GetOptValBool(pSiS->Options, OPTION_CENTERLCD, &val)) {
	     pSiS->CenterLCD = val ? 1 : 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Non-scaled LCD output will %sbe centered\n",
	         pSiS->CenterLCD ? "not " : "");
	  }

         /* PanelDelayCompensation (300/315/330 series only)
          * This might be required if the LCD panel shows "small waves"
	  * or wrong colors.
          * The parameter is an integer, (on 300 series usually either
	  * 4, 32 or 24; on 315 series + LV bridge usually 3 or 51)
          * Why this option? Simply because SiS did poor BIOS design.
          * The PDC value depends on the very LCD panel used in a
          * particular machine. For most panels, the driver is able
          * to detect the correct value. However, some panels require
          * a different setting. For 300 series, the value given must
	  * be within the mask 0x3c. For 661 and later, if must be
	  * within the range of 0 to 31.
          */
	  {
	  int val = -1;
          xf86GetOptValInteger(pSiS->Options, OPTION_PDC, &val);
	  xf86GetOptValInteger(pSiS->Options, OPTION_PDCS, &val);
	  if(val != -1) {
	     pSiS->PDC = val;
	     if((pSiS->VGAEngine == SIS_300_VGA) && (pSiS->PDC & ~0x3c)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	            "Illegal PanelDelayCompensation parameter\n");
	        pSiS->PDC = -1;
	     } else {
	        if(pSiS->VGAEngine == SIS_315_VGA) pSiS->PDC &= 0x1f;
                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "Panel delay compensation shall be %d (for LCD=CRT2)\n",
	             pSiS->PDC);
	     }
          }

	 /* PanelDelayCompensation1 (315 series only)
          * Same as above, but for LCD-via-CRT1 ("LCDA")
          */
	  if(pSiS->VGAEngine == SIS_315_VGA) {
	     val = -1;
             xf86GetOptValInteger(pSiS->Options, OPTION_PDCA, &val);
	     xf86GetOptValInteger(pSiS->Options, OPTION_PDCAS, &val);
	     if(val != -1) {
	        pSiS->PDCA = val;
	        if(pSiS->PDCA > 0x1f) {
	           xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	                "Illegal PanelDelayCompensation1 (PDC1) parameter (0 <= PDC1 <= 31\n");
	           pSiS->PDCA = -1;
	        } else {
                   xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                       	"Panel delay compensation shall be %d (for LCD=CRT1)\n",
	                pSiS->PDCA);
	        }
	     }
	  }
	  }

	 /* LVDSHL (300/315/330 series + 30xLV bridge only)
          * This might be required if the LCD panel is too dark.
          * The parameter is an integer from 0 to 3.
          */
          if(xf86GetOptValInteger(pSiS->Options, OPTION_LVDSHL, &pSiS->SiS_Pr->LVDSHL)) {
	     if((pSiS->SiS_Pr->LVDSHL < 0) || (pSiS->SiS_Pr->LVDSHL > 3)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	            "Illegal LVDSHL parameter, valid is 0 through 3\n");
	        pSiS->SiS_Pr->LVDSHL = -1;
	     } else {
                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "LVDSHL will be %d\n",
	             pSiS->SiS_Pr->LVDSHL);
	     }
          }

	 /* EMI (315/330 series + 302LV/302ELV bridge only)
          * This might be required if the LCD panel loses sync on
	  * mode switches. So far, this problem should not show up
	  * due to the auto-detection (from reading the values set
	  * by the BIOS; however, the BIOS values are wrong sometimes
	  * such as in the case of some Compal machines with a
	  * 1400x1050, or some Inventec(Compaq) machines with a
	  * 1280x1024 panel.
          * The parameter is an integer from 0 to 0x60ffffff.
          */
          if(xf86GetOptValInteger(pSiS->Options, OPTION_EMI, &pSiS->EMI)) {
	     if((pSiS->EMI < 0) || (pSiS->EMI > 0x60ffffff)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	            "Illegal EMI parameter, valid is 0 through 0x60ffffff\n");
	        pSiS->EMI = -1;
	     } else {
	        pSiS->EMI &= 0x60ffffff;
                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "EMI will be 0x%04x\n", pSiS->EMI);
	     }
          }

       }


      /* TVStandard (300/315/330 series and 6326 w/ TV only)
       * This option is for overriding the autodetection of
       * the BIOS/Jumper option for PAL / NTSC
       */
       if((pSiS->VGAEngine == SIS_300_VGA) ||
          (pSiS->VGAEngine == SIS_315_VGA) ||
          ((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV))) {
          strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_TVSTANDARD);
          if(strptr != NULL) {
             if(!xf86NameCmp(strptr,"PAL"))
	        pSiS->OptTVStand = 1;
	     else if((!xf86NameCmp(strptr,"PALM")) ||
	             (!xf86NameCmp(strptr,"PAL-M"))) {
	        pSiS->OptTVStand = 1;
	        pSiS->NonDefaultPAL = 1;
  	     } else if((!xf86NameCmp(strptr,"PALN")) ||
	               (!xf86NameCmp(strptr,"PAL-N"))) {
	        pSiS->OptTVStand = 1;
	        pSiS->NonDefaultPAL = 0;
	     } else if((!xf86NameCmp(strptr,"NTSCJ")) ||
	               (!xf86NameCmp(strptr,"NTSC-J"))) {
	        pSiS->OptTVStand = 0;
	        pSiS->NonDefaultNTSC = 1;
  	     } else if(!xf86NameCmp(strptr,"NTSC"))
	        pSiS->OptTVStand = 0;
	     else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "TVStandard");
                xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	            "Valid parameters are \"PAL\", \"PALM\", \"PALN\", \"NTSC\", \"NTSCJ\"\n");
	     }

	     if(pSiS->OptTVStand != -1) {
	        static const char *tvstdstr = "TV standard shall be %s\n";
	        if(pSiS->Chipset == PCI_CHIP_SIS6326) {
	           pSiS->NonDefaultPAL = -1;
		   pSiS->NonDefaultNTSC = -1;
	           xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, tvstdstr,
	               pSiS->OptTVStand ? "PAL" : "NTSC");
	        } else {
	           xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, tvstdstr,
		       (pSiS->OptTVStand ?
		           ( (pSiS->NonDefaultPAL == -1) ? "PAL" :
			      ((pSiS->NonDefaultPAL) ? "PALM" : "PALN") ) :
				(pSiS->NonDefaultNTSC == -1) ? "NTSC" : "NTSCJ"));
	        }
	     }
          }
       }

      /* CHTVType  (315/330 series + Chrontel only)
       * Used for telling the driver if the TV output shall
       * be 525i YPbPr or SCART.
       */
       if(pSiS->VGAEngine == SIS_315_VGA) {
          strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CHTVTYPE);
          if(strptr != NULL) {
             if(!xf86NameCmp(strptr,"SCART"))
                pSiS->chtvtype = 1;
 	     else if(!xf86NameCmp(strptr,"YPBPR525I"))
	        pSiS->chtvtype = 0;
	     else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "CHTVType");
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	          "Valid parameters are \"SCART\" or \"YPBPR525I\"\n");
	     }
             if(pSiS->chtvtype != -1)
                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                  "Chrontel: TV type shall be %s\n", strptr);
          }
       }

       /* CHTVOverscan (300/315/330 series only)
        * CHTVSuperOverscan (300/315/330 series only)
        * These options are for overriding the BIOS option for
        * TV Overscan. Some BIOS don't even have such an option.
        * SuperOverscan is only supported with PAL.
        * Both options are only effective on machines with a
        * CHRONTEL TV encoder. SuperOverscan is only available
        * on the 700x.
        */
       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	  Bool val;
	  if(xf86GetOptValBool(pSiS->Options, OPTION_CHTVOVERSCAN, &val)) {
	     pSiS->OptTVOver = val ? 1 : 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "Chrontel: TV overscan shall be %s\n",
	         val ? enabledstr : disabledstr);
	  }
          if(xf86GetOptValBool(pSiS->Options, OPTION_CHTVSOVERSCAN, &pSiS->OptTVSOver)) {
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "Chrontel: TV super overscan shall be %s\n",
	         pSiS->OptTVSOver ? enabledstr : disabledstr);
	  }
       }

       /* Various parameters for TV output via SiS bridge, Chrontel or SiS6326
        */
       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
          int tmp = 0;
          xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMABANDWIDTHCVBS,
                                &pSiS->chtvlumabandwidthcvbs);
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMABANDWIDTHSVIDEO,
                                &pSiS->chtvlumabandwidthsvideo);
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMAFLICKERFILTER,
                                &pSiS->chtvlumaflickerfilter);
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCHROMABANDWIDTH,
                                &pSiS->chtvchromabandwidth);
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCHROMAFLICKERFILTER,
                                &pSiS->chtvchromaflickerfilter);
	  xf86GetOptValBool(pSiS->Options, OPTION_CHTVCVBSCOLOR,
				&pSiS->chtvcvbscolor);
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVTEXTENHANCE,
                                &pSiS->chtvtextenhance);
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCONTRAST,
                                &pSiS->chtvcontrast);
	  xf86GetOptValInteger(pSiS->Options, OPTION_SISTVEDGEENHANCE,
                                &pSiS->sistvedgeenhance);
	  xf86GetOptValInteger(pSiS->Options, OPTION_SISTVSATURATION,
                                &pSiS->sistvsaturation);
	  xf86GetOptValInteger(pSiS->Options, OPTION_SISTVLUMAFILTER,
                                &pSiS->sistvyfilter);
          if((pSiS->sistvyfilter < 0) || (pSiS->sistvyfilter > 8)) {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"Illegal Y Filter number; valid is 0 (off), 1 (default), 2-8 (filter number 1-7)\n");
	     pSiS->sistvyfilter = 1;
	  }
 	  xf86GetOptValBool(pSiS->Options, OPTION_SISTVCHROMAFILTER,
				&pSiS->sistvcfilter);
	  xf86GetOptValInteger(pSiS->Options, OPTION_SISTVCOLCALIBCOARSE,
                                &pSiS->sistvcolcalibc);
          xf86GetOptValInteger(pSiS->Options, OPTION_SISTVCOLCALIBFINE,
                                &pSiS->sistvcolcalibf);
	  if((pSiS->sistvcolcalibf > 127) || (pSiS->sistvcolcalibf < -128) ||
	     (pSiS->sistvcolcalibc > 120) || (pSiS->sistvcolcalibc < -120)) {
	     pSiS->sistvcolcalibf = pSiS->sistvcolcalibc = 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"Illegal Color Calibration. Range is -128 to 127 (fine), -120 to 120 (coarse)\n");
	  }
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVXPOSOFFSET,
                                &pSiS->tvxpos);
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVYPOSOFFSET,
                                &pSiS->tvypos);
	  if(pSiS->tvxpos > 32)  { pSiS->tvxpos = 32;  tmp = 1; }
	  if(pSiS->tvxpos < -32) { pSiS->tvxpos = -32; tmp = 1; }
	  if(pSiS->tvypos > 32)  { pSiS->tvypos = 32;  tmp = 1; }
	  if(pSiS->tvypos < -32) { pSiS->tvypos = -32;  tmp = 1; }
	  if(tmp) xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		      "Illegal TV x or y offset. Range is from -32 to 32\n");
          tmp = 0;
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVXSCALE,
                                &pSiS->tvxscale);
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVYSCALE,
                                &pSiS->tvyscale);
	  if(pSiS->tvxscale > 16)  { pSiS->tvxscale = 16;  tmp = 1; }
	  if(pSiS->tvxscale < -16) { pSiS->tvxscale = -16; tmp = 1; }
	  if(pSiS->tvyscale > 3)  { pSiS->tvyscale = 3;  tmp = 1; }
	  if(pSiS->tvyscale < -4) { pSiS->tvyscale = -4; tmp = 1; }
	  if(tmp) xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		      "Illegal TV x or y scaling parameter. Range is from -16 to 16 (X), -4 to 3 (Y)\n");
       }

       if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
          int tmp = 0;
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SIS6326FORCETVPPLUG);
          if(strptr) {
             if(!xf86NameCmp(strptr,"COMPOSITE"))
	        pSiS->sis6326tvplug = 1;
  	     else if(!xf86NameCmp(strptr,"SVIDEO"))
	        pSiS->sis6326tvplug = 0;
	     else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "SIS6326TVForcePlug");
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	           "Valid parameters are \"COMPOSITE\" or \"SVIDEO\"\n");
	     }
	  }
	  xf86GetOptValBool(pSiS->Options, OPTION_SIS6326ENABLEYFILTER,
                                &pSiS->sis6326enableyfilter);
	  xf86GetOptValBool(pSiS->Options, OPTION_SIS6326YFILTERSTRONG,
                                &pSiS->sis6326yfilterstrong);
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVXPOSOFFSET,
                                &pSiS->tvxpos);
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVYPOSOFFSET,
                                &pSiS->tvypos);
	  if(pSiS->tvxpos > 16)  { pSiS->tvxpos = 16;  tmp = 1; }
	  if(pSiS->tvxpos < -16) { pSiS->tvxpos = -16; tmp = 1; }
	  if(pSiS->tvypos > 16)  { pSiS->tvypos = 16;  tmp = 1; }
	  if(pSiS->tvypos < -16) { pSiS->tvypos = -16;  tmp = 1; }
	  if(tmp) xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		      "Illegal TV x or y offset. Range is from -16 to 16\n");
          xf86GetOptValInteger(pSiS->Options, OPTION_SIS6326FSCADJUST,
                                &pSiS->sis6326fscadjust);
	  if(pSiS->sis6326fscadjust) {
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	"Adjusting the default FSC by %d\n",
		pSiS->sis6326fscadjust);
	  }
       }

       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA) ||
          ((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV))) {
          strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SISTVANTIFLICKER);
          if(!strptr) {
             strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SIS6326ANTIFLICKER);
          }
          if(strptr) {
             if(!xf86NameCmp(strptr,"OFF"))
	        pSiS->sistvantiflicker = 0;
  	     else if(!xf86NameCmp(strptr,"LOW"))
	        pSiS->sistvantiflicker = 1;
	     else if(!xf86NameCmp(strptr,"MED"))
	        pSiS->sistvantiflicker = 2;
	     else if(!xf86NameCmp(strptr,"HIGH"))
	        pSiS->sistvantiflicker = 3;
	     else if(!xf86NameCmp(strptr,"ADAPTIVE"))
	        pSiS->sistvantiflicker = 4;
	     else {
	        pSiS->sistvantiflicker = -1;
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "SISTVAntiFlicker");
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	            "Valid parameters are \"OFF\", \"LOW\", \"MED\", \"HIGH\" or \"ADAPTIVE\"\n");
	     }
	  }
       }

       /* CRT2Gamma - enable/disable gamma correction for CRT2
        */
       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
          Bool val;
          if(xf86GetOptValBool(pSiS->Options, OPTION_CRT2GAMMA, &val)) {
	     pSiS->CRT2gamma = val;
          }
       }

#ifdef SIS_CP
       SIS_CP_OPT_DOOPT
#endif

    }  /* DualHead */

    /* CRT1Gamma - enable/disable gamma correction for CRT1
     */
    {
       Bool val;
       if(xf86GetOptValBool(pSiS->Options, OPTION_CRT1GAMMA, &val)) {
	  pSiS->CRT1gamma = val;
	  pSiS->CRT1gammaGiven = TRUE;
       }
    }

    /* VESA - DEPRECATED
     * This option is for forcing the driver to use
     * the VESA BIOS extension for mode switching.
     */
    {
	Bool val;
	if(xf86GetOptValBool(pSiS->Options, OPTION_VESA, &val)) {
	    pSiS->VESA = val ? 1 : 0;
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	        "VESA: VESA usage shall be %s\n",
		val ? enabledstr : disabledstr);
 	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    	"*** Option \"VESA\" is deprecated. *** \n");
	    if(pSiS->VESA) pSiS->ForceCRT1Type = CRT1_VGA;
	}
    }

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {

       /* NoInternalModes (300/315/330 series only)
        * Since the mode switching code for these chipsets is a
        * Asm-to-C translation of BIOS code, we only have timings
        * for a pre-defined number of modes. The default behavior
        * is to replace XFree's default modes with a mode list
        * generated out of the known and supported modes. Use
        * this option to disable this. NOT RECOMMENDED.
        */
       from = X_DEFAULT;
       if(xf86GetOptValBool(pSiS->Options, OPTION_NOINTERNALMODES, &pSiS->noInternalModes))
		from = X_CONFIG;
       xf86DrvMsg(pScrn->scrnIndex, from, "Usage of built-in modes is %s\n",
		       pSiS->noInternalModes ? disabledstr : enabledstr);
    }

    /* ShadowFB */
    from = X_DEFAULT;
    if(xf86GetOptValBool(pSiS->Options, OPTION_SHADOW_FB, &pSiS->ShadowFB)) {
#ifdef SISMERGED
       if(pSiS->MergedFB) {
          pSiS->ShadowFB = FALSE;
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      "Shadow Frame Buffer not supported in MergedFB mode\n");
       } else
#endif
          from = X_CONFIG;
    }
    if(pSiS->ShadowFB) {
	pSiS->NoAccel = TRUE;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	pSiS->NoXvideo = TRUE;
    	xf86DrvMsg(pScrn->scrnIndex, from,
	   "Using \"Shadow Frame Buffer\" - 2D acceleration and Xv disabled\n");
#else
    	xf86DrvMsg(pScrn->scrnIndex, from,
	   "Using \"Shadow Frame Buffer\" - 2D acceleration disabled\n");
#endif
    }

    /* Rotate */
    if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_ROTATE))) {
#ifdef SISMERGED
       if(pSiS->MergedFB) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      "Screen rotation not supported in MergedFB mode\n");
       } else
#endif
       if(!xf86NameCmp(strptr, "CW")) {
          pSiS->Rotate = 1;
       } else if(!xf86NameCmp(strptr, "CCW")) {
          pSiS->Rotate = -1;
       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "Rotate");
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
              "Valid parameters are \"CW\" or \"CCW\"\n");
       }

       if(pSiS->Rotate) {
          pSiS->ShadowFB = TRUE;
          pSiS->NoAccel  = TRUE;
          pSiS->HWCursor = FALSE;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	  pSiS->NoXvideo = TRUE;
          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
              "Rotating screen %sclockwise; (2D acceleration and Xv disabled)\n",
	      (pSiS->Rotate == -1) ? "counter " : "");
#else
	  xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
              "Rotating screen %sclockwise (2D acceleration %sdisabled)\n",
	      (pSiS->Rotate == -1) ? "counter " : "",
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,0,0,0)
              "and RandR extension "
#else
	      ""
#endif
	      );

#endif

       }
    }

#ifdef XF86DRI
    /* DRI */
    from = X_DEFAULT;
    if(xf86GetOptValBool(pSiS->Options, OPTION_DRI, &pSiS->loadDRI)) {
       from = X_CONFIG;
    }
    xf86DrvMsg(pScrn->scrnIndex, from, "DRI %s\n",
       pSiS->loadDRI ? enabledstr : disabledstr);

    /* AGPSize */
    {
       int vali;
       Bool gotit = FALSE;
       if(xf86GetOptValInteger(pSiS->Options, OPTION_AGP_SIZE, &vali)) {
          gotit = TRUE;
       } else if(xf86GetOptValInteger(pSiS->Options, OPTION_AGP_SIZE2, &vali)) {
          gotit = TRUE;
       }
       if(gotit) {
	  if((vali >= 8) && (vali <= 512)) {
	     pSiS->agpWantedPages = (vali * 1024 * 1024) / AGP_PAGE_SIZE;
	  } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr, "AGPSize (alias GARTSize)", 8, 512);
	  }
       }
    }
#endif

    /* NoXVideo
     * Set this to TRUE to disable Xv hardware video acceleration
     */
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    if((!pSiS->NoAccel) && (!pSiS->NoXvideo)) {
#else
    if(!pSiS->NoXvideo) {
#endif
       if(xf86ReturnOptValBool(pSiS->Options, OPTION_NOXVIDEO, FALSE)) {
          pSiS->NoXvideo = TRUE;
          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "XVideo extension disabled\n");
       }

       if(!pSiS->NoXvideo) {
          Bool val;
	  int tmp;

	  if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
      	     /* XvOnCRT2
	      * On chipsets with only one overlay (315, 650, 740, 330), the user can
	      * choose to display the overlay on CRT1 or CRT2. By setting this
	      * option to TRUE, the overlay will be displayed on CRT2. The
	      * default is: CRT1 if only CRT1 available, CRT2 if only CRT2
	      * available, and CRT1 if both is available and detected.
	      * Since implementation of the XV_SWITCHCRT Xv property this only
	      * selects the default CRT.
	      */
             if(xf86GetOptValBool(pSiS->Options, OPTION_XVONCRT2, &val)) {
	        pSiS->XvOnCRT2 = val ? TRUE : FALSE;
	     }
	  }

	  if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
	     /* NoYV12 (for 5597/5598, 6326 and 530/620 only)
	      * YV12 has problems with videos larger than 384x288. So
	      * allow the user to disable YV12 support to force the
	      * application to use YUV2 instead.
	      */
             if(xf86GetOptValBool(pSiS->Options, OPTION_NOYV12, &val)) {
	        pSiS->NoYV12 = val ? 1 : 0;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			"Xv YV12/I420 support is %s\n",
			pSiS->NoYV12 ? disabledstr : enabledstr);
	     }
	  }

	  /* Some Xv properties' defaults can be set by options */
          if(xf86GetOptValInteger(pSiS->Options, OPTION_XVDEFCONTRAST, &tmp)) {
             if((tmp >= 0) && (tmp <= 7)) pSiS->XvDefCon = tmp;
             else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       		      "XvDefaultContrast" ,0, 7);
          }
          if(xf86GetOptValInteger(pSiS->Options, OPTION_XVDEFBRIGHTNESS, &tmp)) {
             if((tmp >= -128) && (tmp <= 127)) pSiS->XvDefBri = tmp;
             else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       		      "XvDefaultBrightness", -128, 127);
          }
          if(pSiS->VGAEngine == SIS_315_VGA) {
             if(xf86GetOptValInteger(pSiS->Options, OPTION_XVDEFHUE, &tmp)) {
                if((tmp >= -8) && (tmp <= 7)) pSiS->XvDefHue = tmp;
                else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       	              "XvDefaultHue", -8, 7);
             }
             if(xf86GetOptValInteger(pSiS->Options, OPTION_XVDEFSATURATION, &tmp)) {
                if((tmp >= -7) && (tmp <= 7)) pSiS->XvDefSat = tmp;
                else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       	              "XvDefaultSaturation", -7, 7);
             }
          }
	  if(xf86GetOptValBool(pSiS->Options, OPTION_XVDEFDISABLEGFX, &val)) {
	     if(val)  pSiS->XvDefDisableGfx = TRUE;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	        "Graphics display will be %s during Xv usage\n",
	     	val ? disabledstr : enabledstr);
          }
	  if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	     if(xf86GetOptValBool(pSiS->Options, OPTION_XVDEFDISABLEGFXLR, &val)) {
	        if(val)  pSiS->XvDefDisableGfxLR = TRUE;
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	   "Graphics display left/right of overlay will be %s during Xv usage\n",
		   val ? disabledstr : enabledstr);
             }
	     if(xf86GetOptValBool(pSiS->Options, OPTION_XVDISABLECOLORKEY, &val)) {
	        if(val) pSiS->XvDisableColorKey = TRUE;
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	   "Xv Color key is %s\n",
		   val ? disabledstr : enabledstr);
             }
	     if(xf86GetOptValBool(pSiS->Options, OPTION_XVUSECHROMAKEY, &val)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	   "Xv Chroma-keying is %s\n",
		   val ? enabledstr : disabledstr);
		if(val) pSiS->XvUseChromaKey = TRUE;
             }
	     if(xf86GetOptValBool(pSiS->Options, OPTION_XVINSIDECHROMAKEY, &val)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	   "Xv: Video is transparent if %s chroma key range\n",
		   val ? "inside" : "outside");
		if(val) pSiS->XvInsideChromaKey = TRUE;
             }
	     if(pSiS->VGAEngine == SIS_300_VGA) {
	        if(xf86GetOptValBool(pSiS->Options, OPTION_XVYUVCHROMAKEY, &val)) {
	           xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	      "Xv: Chroma key is in %s format\n",
		      val ? "YUV" : "RGB");
		   if(val) pSiS->XvYUVChromaKey = TRUE;
		}
             } else {
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Xv: Chroma key is of same format as video source\n");
	     }
	     if(xf86GetOptValInteger(pSiS->Options, OPTION_XVCHROMAMIN, &tmp)) {
                if((tmp >= 0) && (tmp <= 0xffffff)) pSiS->XvChromaMin = tmp;
                else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       	                       "XvChromaMin", 0, 0xffffff);
             }
	     if(xf86GetOptValInteger(pSiS->Options, OPTION_XVCHROMAMAX, &tmp)) {
                if((tmp >= 0) && (tmp <= 0xffffff)) pSiS->XvChromaMax = tmp;
                else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       	                   "XvChromaMax", 0, 0xffffff);
             }
          }
	  if(xf86GetOptValBool(pSiS->Options, OPTION_XVMEMCPY, &val)) {
	     pSiS->XvUseMemcpy = val ? TRUE : FALSE;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Xv will %suse memcpy()\n",
	     	val ? "" : "not ");
          }
	  /* XvGamma - enable/disable gamma correction for Xv
	   * Supported for CRT1 only
           */
          if(pSiS->VGAEngine == SIS_315_VGA) {
	     if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_XVGAMMA))) {
                if( (!xf86NameCmp(strptr,"off"))   ||
	            (!xf86NameCmp(strptr,"false")) ||
		    (!xf86NameCmp(strptr,"no"))    ||
		    (!xf86NameCmp(strptr,"0")) ) {
		   pSiS->XvGamma = FALSE;
		   pSiS->XvGammaGiven = TRUE;
	        } else if( (!xf86NameCmp(strptr,"on"))   ||
	                   (!xf86NameCmp(strptr,"true")) ||
		           (!xf86NameCmp(strptr,"yes"))  ||
		           (!xf86NameCmp(strptr,"1")) ) {
		   pSiS->XvGamma = pSiS->XvGammaGiven = TRUE;
                } else {
	           float val1 = 0.0, val2 = 0.0, val3 = 0.0;
		   Bool valid = FALSE;
	           int result = sscanf(strptr, "%f %f %f", &val1, &val2, &val3);
		   if(result == 1) {
		      if((val1 >= 0.1) && (val1 <= 10.0)) {
		         pSiS->XvGammaGreen = pSiS->XvGammaBlue = pSiS->XvGammaRed =
			    pSiS->XvGammaGreenDef = pSiS->XvGammaBlueDef = pSiS->XvGammaRedDef = (int)(val1 * 1000);
		         valid = TRUE;
		      }
		   } else if(result == 3) {
		      if((val1 >= 0.1) && (val1 <= 10.0) &&
		         (val2 >= 0.1) && (val2 <= 10.0) &&
		         (val3 >= 0.1) && (val3 <= 10.0)) {
		         pSiS->XvGammaRed = pSiS->XvGammaRedDef = (int)(val1 * 1000);
		         pSiS->XvGammaGreen = pSiS->XvGammaGreenDef = (int)(val2 * 1000);
		         pSiS->XvGammaBlue = pSiS->XvGammaBlueDef = (int)(val3 * 1000);
			 valid = TRUE;
		      }
		   }
		   if(valid) {
		      pSiS->XvGamma = pSiS->XvGammaGiven = TRUE;
		   } else {
		      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		         "XvGamma expects either a boolean, or 1 or 3 real numbers (0.1 - 10.0)\n");
		   }
	        }
             }
          }
       }
    }

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_STOREDBRI))) {
          float val1 = 0.0, val2 = 0.0, val3 = 0.0;
	  Bool valid = FALSE;
	  int result = sscanf(strptr, "%f %f %f", &val1, &val2, &val3);
	  if(result == 1) {
	     if((val1 >= 0.1) && (val1 <= 10.0)) {
	        valid = TRUE;
		pSiS->GammaBriR = pSiS->GammaBriG = pSiS->GammaBriB = (int)(val1 * 1000);
	     }
	  } else if(result == 3) {
	     if((val1 >= 0.1) && (val1 <= 10.0) &&
	        (val2 >= 0.1) && (val2 <= 10.0) &&
		(val3 >= 0.1) && (val3 <= 10.0)) {
		valid = TRUE;
		pSiS->GammaBriR = (int)(val1 * 1000);
		pSiS->GammaBriG = (int)(val2 * 1000);
		pSiS->GammaBriB = (int)(val3 * 1000);
	     }
	  }
	  if(!valid) {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"StoredGammaBrightness expects 1 or 3 real numbers (0.1 - 10.0)\n");
	  }
       }
       if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_STOREDPBRI))) {
          float val1 = 0.0, val2 = 0.0, val3 = 0.0;
	  Bool valid = FALSE;
	  int result = sscanf(strptr, "%f %f %f", &val1, &val2, &val3);
	  if(result == 1) {
	     if((val1 >= 0.1) && (val1 <= 10.0)) {
	        valid = TRUE;
		pSiS->GammaPBriR = pSiS->GammaPBriG = pSiS->GammaPBriB = (int)(val1 * 1000);
	     }
	  } else if(result == 3) {
	     if((val1 >= 0.1) && (val1 <= 10.0) &&
	        (val2 >= 0.1) && (val2 <= 10.0) &&
		(val3 >= 0.1) && (val3 <= 10.0)) {
		valid = TRUE;
		pSiS->GammaPBriR = (int)(val1 * 1000);
		pSiS->GammaPBriG = (int)(val2 * 1000);
		pSiS->GammaPBriB = (int)(val3 * 1000);
	     }
	  }
	  if(!valid) {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"\"StoredGammaPreBrightness\" expects 1 or 3 real numbers (0.1 - 10.0)\n");
	  }
       }
    }

}

const OptionInfoRec *
SISAvailableOptions(int chipid, int busid)
{
    return SISOptions;
}
@


1.1
log
@Initial revision
@
text
@d1 35
a35 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_opt.c,v 1.10 2002/01/17 09:57:30 eich Exp $ */
d39 2
d44 2
a48 2
    OPTION_PCI_RETRY,
    OPTION_RGB_BITS,
d52 3
a54 1
    OPTION_SET_MEMCLOCK,
d56 5
a60 1
	OPTION_SHADOW_FB,
d62 1
a62 1
	OPTION_NOXVIDEO,
d64 89
a152 1
    OPTION_MAXXFBMEM
d156 110
a265 15
    { OPTION_SW_CURSOR,         "SWcursor",     OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_HW_CURSOR,         "HWcursor",     OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_PCI_RETRY,         "PciRetry",     OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_RGB_BITS,          "rgbbits",      OPTV_INTEGER,   {0}, -1    },
    { OPTION_NOACCEL,           "NoAccel",      OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_TURBOQUEUE,        "TurboQueue",   OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_SET_MEMCLOCK,      "SetMClk",      OPTV_FREQ,      {0}, -1    },
    { OPTION_FAST_VRAM,         "FastVram",     OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_FORCE_CRT2TYPE,    "ForceCRT2Type",OPTV_ANYSTR,    {0}, FALSE },
    { OPTION_SHADOW_FB,         "ShadowFB",     OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_ROTATE,            "Rotate",       OPTV_ANYSTR,    {0}, FALSE },
    { OPTION_NOXVIDEO,          "NoXvideo",     OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_VESA,		"Vesa",		OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_MAXXFBMEM,         "MaxXFBMem",    OPTV_INTEGER,   {0}, -1 },
    { -1,                       NULL,           OPTV_NONE,      {0}, FALSE }
a267 3
void SiSOptions(ScrnInfoPtr pScrn);
const OptionInfoRec * SISAvailableOptions(int chipid, int busid);

d271 7
a277 4
    SISPtr  pSiS = SISPTR(pScrn);
    MessageType     from;
    double          temp;
    char *strptr;
d283 2
a284 2
    if (!(pSiS->Options = xalloc(sizeof(SISOptions))))
	return;
d286 1
d289 4
a292 3
    /* initalize some defaults */
    pSiS->FastVram = TRUE;
    pSiS->UsePCIRetry = TRUE;
d294 6
d303 2
d308 94
d403 57
a459 6
    switch(pSiS->Chipset) {
        case PCI_CHIP_SIS530:
            pSiS->TurboQueue = FALSE; /* FIXME ? */
            break;
        default:
            break;
d462 22
a483 5
#if 0 /* we only work with a depth greater or equal to 8 */
    if (pScrn->depth <= 8)  {
        if (xf86GetOptValInteger(pSiS->Options, OPTION_RGB_BITS,
                                &pScrn->rgbBits))
        {
d485 3
a487 2
                    "Bits per RGB set to %d\n", pScrn->rgbBits);
        }
d489 11
d502 17
a518 1
    /* sw/hw cursor */
d520 1
a520 1
    if (xf86GetOptValBool(pSiS->Options, OPTION_HW_CURSOR, &pSiS->HWCursor)) {
d523 1
a523 1
    if (xf86ReturnOptValBool(pSiS->Options, OPTION_SW_CURSOR, FALSE)) {
d526 1
d528 1
a528 1
    xf86DrvMsg(pScrn->scrnIndex, from, "Using %s cursor\n", 
d531 54
a584 4
    /* Accel */
    if (xf86ReturnOptValBool(pSiS->Options, OPTION_NOACCEL, FALSE)) {
        pSiS->NoAccel = TRUE;
        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Acceleration disabled\n");
d586 3
d590 942
a1531 4
    /* PCI retry */
    from = X_DEFAULT;
    if (xf86GetOptValBool(pSiS->Options, OPTION_PCI_RETRY, &pSiS->UsePCIRetry)) {
        from = X_CONFIG;
a1532 2
    xf86DrvMsg(pScrn->scrnIndex, from, "PCI retry %s\n",
                         pSiS->UsePCIRetry ? "enabled" : "disabled");
d1534 15
a1548 6
    /* Mem clock */
    if (xf86GetOptValFreq(pSiS->Options, OPTION_SET_MEMCLOCK, OPTUNITS_MHZ,
                                                            &temp)) {
        pSiS->MemClock = (int)(temp * 1000.0);
        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, 
                    "Memory clock set to %.3f MHz\n", pSiS->MemClock/1000.0);
d1551 15
a1565 4
    /* fast VRAM */
    from = X_DEFAULT;
    if (xf86GetOptValBool(pSiS->Options, OPTION_FAST_VRAM, &pSiS->FastVram)) {
        from = X_CONFIG;
a1566 2
    xf86DrvMsg(pScrn->scrnIndex, from, "Fast VRAM %s\n",
                         pSiS->FastVram ? "enabled" : "disabled");
d1568 1
a1568 1
    /* Turbo QUEUE */
d1570 20
a1589 2
    if (xf86GetOptValBool(pSiS->Options, OPTION_TURBOQUEUE, &pSiS->TurboQueue)) {
        from = X_CONFIG;
a1590 2
    xf86DrvMsg(pScrn->scrnIndex, from, "TurboQueue %s\n", 
                        pSiS->TurboQueue ? "enabled" : "disabled");
d1592 39
a1630 13
    /* CRT2 type */
    pSiS->ForceCRT2Type = CRT2_DEFAULT;
    strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT2TYPE);
    if (strptr != NULL)
    {
        if (!strcmp(strptr,"TV"))
            pSiS->ForceCRT2Type = CRT2_TV;
        if (!strcmp(strptr,"LCD"))
            pSiS->ForceCRT2Type = CRT2_LCD;
        if (!strcmp(strptr,"VGA"))
            pSiS->ForceCRT2Type = CRT2_VGA;
        if (!strcmp(strptr,"NONE"))
            pSiS->ForceCRT2Type = 0;
d1632 1
a1632 3
        if (pSiS->ForceCRT2Type != CRT2_DEFAULT)
            xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "CRT2 Type set to: %s\n", strptr);
d1635 2
a1636 1
    /* ShadowFB */
d1638 2
a1639 2
    if (xf86GetOptValBool(pSiS->Options, OPTION_SHADOW_FB, &pSiS->ShadowFB)) {
        from = X_CONFIG;
d1641 2
a1642 5
	if (pSiS->ShadowFB) {
		pSiS->NoAccel = TRUE;
    	xf86DrvMsg(pScrn->scrnIndex, from, 
				"Using \"Shadow Frame Buffer\" - acceleration disabled\n");
	}
d1644 1
a1644 40
    /* Rotate */
    if ((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_ROTATE))) {
        if(!xf86NameCmp(strptr, "CW")) {
            pSiS->ShadowFB = TRUE;
            pSiS->NoAccel = TRUE;
            pSiS->HWCursor = FALSE;
            pSiS->Rotate = 1;
            xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                "Rotating screen clockwise - acceleration disabled\n");
        } else
        if (!xf86NameCmp(strptr, "CCW")) {
            pSiS->ShadowFB = TRUE;
            pSiS->NoAccel = TRUE;
            pSiS->HWCursor = FALSE;
            pSiS->Rotate = -1;
            xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                "Rotating screen counter clockwise - acceleration disabled\n");
        } else {
            xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "\"%s\" is not a valid value for Option \"Rotate\"\n", strptr);
            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                    "Valid options are \"CW\" or \"CCW\"\n");
        }
    }

    /* NOXvideo */
    if (xf86ReturnOptValBool(pSiS->Options, OPTION_NOXVIDEO, FALSE)) {
        pSiS->NoXvideo = TRUE;
        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "XVideo Extension Disabled\n");
    }

    /* VESA */
    /* 
     * This option is for overriding the default behavior.
     * By default it depends on the chipset/video bridge
     * combination if the VESA BIOS code is used to prevent
     * the "melting" screen effect due to lack of nowledge
     * about programming details.
     * You will normally not need this option.
     */
d1646 16
a1661 7
	Bool val;
	
	if (xf86GetOptValBool(pSiS->Options, OPTION_VESA, &val)) {
	    if (val)
		pSiS->VESA = 1;
	    else
		pSiS->VESA = 0;
d1663 173
a1835 3
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "VESA usage %s\n",
		       val ? "enabled":"disabled");
	}
d1837 50
a1886 13
   /* With the option "MaxXFBMem" you can limit the amount of video memory X
    * uses for screen and off-screen buffers. This option should be used if
    * you intend to use DRI/DRM. The framebuffer driver required for DRM will
    * start its memory heap at 8MB if it detects more than that. So, if you
    * limit the amount of memory X uses, you avoid a clash between the framebuffer
    * driver and X as regards overwriting memory portions of each other.
    * The amount is to be specified in KB.
    */
    if (xf86GetOptValULong(pSiS->Options, OPTION_MAXXFBMEM,
                                &pSiS->maxxfbmem)) {
            xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "Framebuffer memory limited to %d KB\n", pSiS->maxxfbmem);
	    pSiS->maxxfbmem *= 1024;
d1888 1
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 38
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_opt.c,v 1.55 2004/01/23 22:29:05 twini Exp $ */
/*
 * SiS driver option evaluation
 *
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement: "This product includes
 *    software developed by Thomas Winischhofer, Vienna, Austria."
 * 4) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * "NoAccel", "NoXVideo", "SWCursor", "HWCursor" and "Rotate" option portions
 * Copyright (C) 1999-2004 The XFree86 Project, Inc. Licensed under the terms
 * of the XFree86 license (http://www.xfree86.org/current/LICENSE1.html).
 *
 * Authors:  	Thomas Winischhofer <thomas@@winischhofer.net>
 *              ?
 */
a4 2
#include "xf86str.h"
#include "xf86Cursor.h"
a7 2
extern const customttable mycustomttable[];

d11 2
d16 1
a16 3
    OPTION_NOHOSTBUS,
    OPTION_RENDER,
    OPTION_FORCE_CRT1TYPE,
d18 1
a18 5
    OPTION_YPBPRAR,
    OPTION_SHADOW_FB,
    OPTION_DRI,
    OPTION_AGP_SIZE,
    OPTION_AGP_SIZE2,
d20 1
a20 1
    OPTION_NOXVIDEO,
d22 1
a22 84
    OPTION_MAXXFBMEM,
    OPTION_FORCECRT1,
    OPTION_XVONCRT2,
    OPTION_PDC,
    OPTION_EMI,
    OPTION_TVSTANDARD,
    OPTION_USEROMDATA,
    OPTION_NOINTERNALMODES,
    OPTION_USEOEM,
    OPTION_NOYV12,
    OPTION_CHTVOVERSCAN,
    OPTION_CHTVSOVERSCAN,
    OPTION_CHTVLUMABANDWIDTHCVBS,
    OPTION_CHTVLUMABANDWIDTHSVIDEO,
    OPTION_CHTVLUMAFLICKERFILTER,
    OPTION_CHTVCHROMABANDWIDTH,
    OPTION_CHTVCHROMAFLICKERFILTER,
    OPTION_CHTVCVBSCOLOR,
    OPTION_CHTVTEXTENHANCE,
    OPTION_CHTVCONTRAST,
    OPTION_SISTVEDGEENHANCE,
    OPTION_SISTVANTIFLICKER,
    OPTION_SISTVSATURATION,
    OPTION_SISTVCHROMAFILTER,
    OPTION_SISTVLUMAFILTER,
    OPTION_SISTVCOLCALIBFINE,
    OPTION_SISTVCOLCALIBCOARSE,
    OPTION_TVXPOSOFFSET,
    OPTION_TVYPOSOFFSET,
    OPTION_TVXSCALE,
    OPTION_TVYSCALE,
    OPTION_SIS6326ANTIFLICKER,
    OPTION_SIS6326ENABLEYFILTER,
    OPTION_SIS6326YFILTERSTRONG,
    OPTION_SIS6326FORCETVPPLUG,
    OPTION_SIS6326FSCADJUST,
    OPTION_CHTVTYPE,
    OPTION_USERGBCURSOR,
    OPTION_USERGBCURSORBLEND,
    OPTION_USERGBCURSORBLENDTH,
    OPTION_RESTOREBYSET,
    OPTION_NODDCFORCRT2,
    OPTION_FORCECRT2REDETECTION,
    OPTION_CRT1GAMMA,
    OPTION_CRT2GAMMA,
    OPTION_XVGAMMA,
    OPTION_XVDEFCONTRAST,
    OPTION_XVDEFBRIGHTNESS,
    OPTION_XVDEFHUE,
    OPTION_XVDEFSATURATION,
    OPTION_XVDEFDISABLEGFX,
    OPTION_XVDEFDISABLEGFXLR,
    OPTION_XVMEMCPY,
    OPTION_XVUSECHROMAKEY,
    OPTION_XVCHROMAMIN,
    OPTION_XVCHROMAMAX,
    OPTION_XVDISABLECOLORKEY,
    OPTION_XVINSIDECHROMAKEY,
    OPTION_XVYUVCHROMAKEY,
    OPTION_SCALELCD,
    OPTION_SPECIALTIMING,
    OPTION_LVDSHL,
    OPTION_ENABLEHOTKEY,
    OPTION_MERGEDFB,
    OPTION_MERGEDFBAUTO,
    OPTION_CRT2HSYNC,
    OPTION_CRT2VREFRESH,
    OPTION_CRT2POS,
    OPTION_METAMODES,
    OPTION_MERGEDFB2,
    OPTION_CRT2HSYNC2,
    OPTION_CRT2VREFRESH2,
    OPTION_CRT2POS2,
    OPTION_NOSISXINERAMA,
    OPTION_NOSISXINERAMA2,
    OPTION_CRT2ISSCRN0,
    OPTION_MERGEDDPI,
    OPTION_ENABLESISCTRL,
    OPTION_STOREDBRI,
    OPTION_STOREDPBRI,
#ifdef SIS_CP
    SIS_CP_OPT_OPTIONS
#endif
    OPTION_PSEUDO
d26 15
a40 105
    { OPTION_SW_CURSOR,         	"SWcursor",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_HW_CURSOR,         	"HWcursor",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_NOACCEL,           	"NoAccel",                OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_TURBOQUEUE,        	"TurboQueue",             OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_FAST_VRAM,         	"FastVram",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_NOHOSTBUS,         	"NoHostBus",              OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_RENDER,        		"RenderAcceleration",     OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_FORCE_CRT1TYPE,    	"ForceCRT1Type",          OPTV_STRING,    {0}, FALSE },
    { OPTION_FORCE_CRT2TYPE,    	"ForceCRT2Type",          OPTV_STRING,    {0}, FALSE },
    { OPTION_YPBPRAR,  		  	"YPbPrAspectRatio",       OPTV_STRING,    {0}, FALSE },
    { OPTION_SHADOW_FB,         	"ShadowFB",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_DRI,         		"DRI",               	  OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_AGP_SIZE,			"AGPSize",      	  OPTV_INTEGER,   {0}, FALSE },
    { OPTION_AGP_SIZE2,			"GARTSize",      	  OPTV_INTEGER,   {0}, FALSE },
    { OPTION_ROTATE,            	"Rotate",                 OPTV_STRING,    {0}, FALSE },
    { OPTION_NOXVIDEO,          	"NoXvideo",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_VESA,			"Vesa",		          OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_MAXXFBMEM,         	"MaxXFBMem",              OPTV_INTEGER,   {0}, -1    },
    { OPTION_FORCECRT1,         	"ForceCRT1",              OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_XVONCRT2,          	"XvOnCRT2",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_PDC,               	"PanelDelayCompensation", OPTV_INTEGER,   {0}, -1    },
    { OPTION_EMI,               	"EMI", 			  OPTV_INTEGER,   {0}, -1    },
    { OPTION_LVDSHL,			"LVDSHL", 	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SPECIALTIMING,        	"SpecialTiming",          OPTV_STRING,    {0}, -1    },
    { OPTION_TVSTANDARD,        	"TVStandard",             OPTV_STRING,    {0}, -1    },
    { OPTION_USEROMDATA,		"UseROMData",	          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_NOINTERNALMODES,   	"NoInternalModes",        OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_USEOEM, 			"UseOEMData",		  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_NOYV12, 			"NoYV12",		  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVTYPE,			"CHTVType",	          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVOVERSCAN,		"CHTVOverscan",	          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVSOVERSCAN,		"CHTVSuperOverscan",      OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVLUMABANDWIDTHCVBS,	"CHTVLumaBandwidthCVBS",  OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVLUMABANDWIDTHSVIDEO,	"CHTVLumaBandwidthSVIDEO",OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVLUMAFLICKERFILTER,	"CHTVLumaFlickerFilter",  OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVCHROMABANDWIDTH,	"CHTVChromaBandwidth",    OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVCHROMAFLICKERFILTER,	"CHTVChromaFlickerFilter",OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVCVBSCOLOR,		"CHTVCVBSColor",          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVTEXTENHANCE,		"CHTVTextEnhance",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVCONTRAST,		"CHTVContrast",		  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVEDGEENHANCE,		"SISTVEdgeEnhance",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVANTIFLICKER,		"SISTVAntiFlicker",	  OPTV_STRING,    {0}, FALSE },
    { OPTION_SISTVSATURATION,		"SISTVSaturation",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVCHROMAFILTER,		"SISTVCFilter",      	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_SISTVLUMAFILTER,		"SISTVYFilter",	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVCOLCALIBFINE,		"SISTVColorCalibFine",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVCOLCALIBCOARSE,	"SISTVColorCalibCoarse",  OPTV_INTEGER,   {0}, -1    },
    { OPTION_TVXSCALE,			"SISTVXScale", 	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_TVYSCALE,			"SISTVYScale", 	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_TVXPOSOFFSET,		"TVXPosOffset", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_TVYPOSOFFSET,		"TVYPosOffset", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SIS6326ANTIFLICKER,	"SIS6326TVAntiFlicker",   OPTV_STRING,    {0}, FALSE  },
    { OPTION_SIS6326ENABLEYFILTER,	"SIS6326TVEnableYFilter", OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_SIS6326YFILTERSTRONG,	"SIS6326TVYFilterStrong", OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_SIS6326FORCETVPPLUG,	"SIS6326TVForcePlug",     OPTV_STRING,    {0}, -1    },
    { OPTION_SIS6326FSCADJUST,		"SIS6326FSCAdjust", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_USERGBCURSOR, 		"UseColorHWCursor",	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_USERGBCURSORBLEND,		"ColorHWCursorBlending",  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_USERGBCURSORBLENDTH,	"ColorHWCursorBlendThreshold", OPTV_INTEGER,{0},-1   },
    { OPTION_RESTOREBYSET,		"RestoreBySetMode", 	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_NODDCFORCRT2,		"NoCRT2Detection", 	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_FORCECRT2REDETECTION,	"ForceCRT2ReDetection",   OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CRT1GAMMA,			"CRT1Gamma", 	  	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CRT2GAMMA,			"CRT2Gamma", 	  	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_STOREDBRI,			"StoredGammaBrightness",  OPTV_STRING,    {0}, -1    },
    { OPTION_STOREDPBRI,		"StoredGammaPreBrightness",OPTV_STRING,   {0}, -1    },
    { OPTION_XVGAMMA,			"XvGamma", 	  	  OPTV_STRING,    {0}, -1    },
    { OPTION_XVDEFCONTRAST,		"XvDefaultContrast", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVDEFBRIGHTNESS,		"XvDefaultBrightness", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVDEFHUE,			"XvDefaultHue", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVDEFSATURATION,		"XvDefaultSaturation", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVDEFDISABLEGFX,		"XvDefaultDisableGfx", 	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVDEFDISABLEGFXLR,		"XvDefaultDisableGfxLR",  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVCHROMAMIN,		"XvChromaMin", 	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVCHROMAMAX,		"XvChromaMax", 	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVUSECHROMAKEY,		"XvUseChromaKey",         OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVINSIDECHROMAKEY,		"XvInsideChromaKey",      OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVYUVCHROMAKEY,		"XvYUVChromaKey",         OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVDISABLECOLORKEY,		"XvDisableColorKey",      OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVMEMCPY,			"XvUseMemcpy",  	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_SCALELCD,			"ScaleLCD",	   	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_ENABLEHOTKEY,		"EnableHotkey",	   	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_ENABLESISCTRL,		"EnableSiSCtrl",   	  OPTV_BOOLEAN,   {0}, -1    },
#ifdef SISMERGED
    { OPTION_MERGEDFB,			"MergedFB",		  OPTV_BOOLEAN,	  {0}, FALSE },
    { OPTION_MERGEDFB2,			"TwinView",		  OPTV_BOOLEAN,	  {0}, FALSE },	  /* alias */
    { OPTION_MERGEDFBAUTO,		"MergedFBAuto",		  OPTV_BOOLEAN,	  {0}, FALSE },
    { OPTION_CRT2HSYNC,			"CRT2HSync",		  OPTV_STRING,	  {0}, FALSE },
    { OPTION_CRT2HSYNC2,		"SecondMonitorHorizSync", OPTV_STRING,	  {0}, FALSE },   /* alias */
    { OPTION_CRT2VREFRESH,		"CRT2VRefresh",		  OPTV_STRING,    {0}, FALSE },
    { OPTION_CRT2VREFRESH2,		"SecondMonitorVertRefresh", OPTV_STRING,  {0}, FALSE },   /* alias */
    { OPTION_CRT2POS,   		"CRT2Position",		  OPTV_STRING,	  {0}, FALSE },
    { OPTION_CRT2POS2,   		"TwinViewOrientation",	  OPTV_STRING,	  {0}, FALSE },   /* alias */
    { OPTION_METAMODES,   		"MetaModes",  		  OPTV_STRING,	  {0}, FALSE },
    { OPTION_MERGEDDPI,			"MergedDPI", 		  OPTV_STRING,	  {0}, FALSE },
#ifdef SISXINERAMA
    { OPTION_NOSISXINERAMA,		"NoMergedXinerama",	  OPTV_BOOLEAN,	  {0}, FALSE },
    { OPTION_NOSISXINERAMA2,		"NoTwinviewXineramaInfo", OPTV_BOOLEAN,   {0}, FALSE },   /* alias */
    { OPTION_CRT2ISSCRN0,		"MergedXineramaCRT2IsScreen0",OPTV_BOOLEAN,{0},FALSE },
#endif
#endif
#ifdef SIS_CP
    SIS_CP_OPTION_DETAIL
#endif
    { -1,                       	NULL,                     OPTV_NONE,      {0}, FALSE }
d43 3
d49 4
a52 7
    SISPtr      pSiS = SISPTR(pScrn);
    MessageType from;
    char        *strptr;
    static const char *mybadparm = "\"%s\" is is not a valid parameter for option \"%s\"\n";
    static const char *disabledstr = "disabled";
    static const char *enabledstr = "enabled";
    static const char *ilrangestr = "Illegal %s parameter. Valid range is %d through %d\n";
d58 2
a59 2
    if(!(pSiS->Options = xalloc(sizeof(SISOptions)))) return;

a60 1

d63 3
a65 4
    /* Set defaults */
    
    pSiS->newFastVram = -1;
    pSiS->NoHostBus = FALSE;
a66 6
#ifdef SISVRAMQ
    /* TODO: Option (315 series VRAM command queue) */
    /* But beware: sisfb does not know about this!!! */
    pSiS->cmdQueueSize = 512*1024;
#endif
    pSiS->doRender = TRUE;
a69 2
    pSiS->loadDRI = FALSE;
    pSiS->agpWantedPages = AGP_PAGES;
a72 91
    pSiS->forceCRT1 = -1;
    pSiS->DSTN = FALSE;
    pSiS->FSTN = FALSE;
    pSiS->XvOnCRT2 = FALSE;
    pSiS->NoYV12 = -1;
    pSiS->PDC = -1;
    pSiS->EMI = -1;
    pSiS->OptTVStand = -1;
    pSiS->OptROMUsage = -1;
    pSiS->noInternalModes = FALSE;
    pSiS->OptUseOEM = -1;
    pSiS->OptTVOver = -1;
    pSiS->OptTVSOver = -1;
    pSiS->chtvlumabandwidthcvbs = -1;
    pSiS->chtvlumabandwidthsvideo = -1;
    pSiS->chtvlumaflickerfilter = -1;
    pSiS->chtvchromabandwidth = -1;
    pSiS->chtvchromaflickerfilter = -1;
    pSiS->chtvcvbscolor = -1;
    pSiS->chtvtextenhance = -1;
    pSiS->chtvcontrast = -1;
    pSiS->sistvedgeenhance = -1;
    pSiS->sistvantiflicker = -1;
    pSiS->sistvsaturation = -1;
    pSiS->sistvcfilter = -1;
    pSiS->sistvyfilter = 1; /* 0 = off, 1 = default, 2-8 = filter no */
    pSiS->sistvcolcalibc = 0;
    pSiS->sistvcolcalibf = 0;
    pSiS->sis6326enableyfilter = -1;
    pSiS->sis6326yfilterstrong = -1;
    pSiS->sis6326tvplug = -1;
    pSiS->sis6326fscadjust = 0;
    pSiS->tvxpos = 0;
    pSiS->tvypos = 0;
    pSiS->tvxscale = 0;
    pSiS->tvyscale = 0;
    pSiS->NonDefaultPAL = pSiS->NonDefaultNTSC = -1;
    pSiS->chtvtype = -1;
    pSiS->restorebyset = TRUE;
    pSiS->nocrt2ddcdetection = FALSE;
    pSiS->forcecrt2redetection = TRUE;   /* default changed since 13/09/2003 */
    pSiS->ForceCRT1Type = CRT1_VGA;
    pSiS->ForceCRT2Type = CRT2_DEFAULT;
    pSiS->ForceYPbPrAR = TV_YPBPR169;
    pSiS->ForceTVType = -1;
    pSiS->CRT1gamma = TRUE;
    pSiS->CRT1gammaGiven = FALSE;
    pSiS->CRT2gamma = TRUE;
    pSiS->XvGamma = FALSE;
    pSiS->XvGammaGiven = FALSE;
    pSiS->enablesisctrl = FALSE;
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       pSiS->XvDefBri = 10;
       pSiS->XvDefCon = 2;
    } else {
       pSiS->XvDefBri = 0;
       pSiS->XvDefCon = 4;
    }
    pSiS->XvDefHue = 0; 
    pSiS->XvDefSat = 0;
    pSiS->XvDefDisableGfx = FALSE;
    pSiS->XvDefDisableGfxLR = FALSE;
    pSiS->UsePanelScaler = -1;
    pSiS->XvUseMemcpy = TRUE;
    pSiS->XvUseChromaKey = FALSE;
    pSiS->XvDisableColorKey = FALSE;
    pSiS->XvInsideChromaKey = FALSE;
    pSiS->XvYUVChromaKey = FALSE;
    pSiS->XvChromaMin = 0x000101fe;
    pSiS->XvChromaMax = 0x000101ff;
    pSiS->XvGammaRed = pSiS->XvGammaGreen = pSiS->XvGammaBlue =
       pSiS->XvGammaRedDef = pSiS->XvGammaGreenDef = pSiS->XvGammaBlueDef = 1000;
    pSiS->GammaBriR = pSiS->GammaBriG = pSiS->GammaBriB = 1000;
    pSiS->GammaPBriR = pSiS->GammaPBriG = pSiS->GammaPBriB = 1000;
    pSiS->HideHWCursor = FALSE;
    pSiS->HWCursorIsVisible = FALSE;
#ifdef SISMERGED
    pSiS->MergedFB = pSiS->MergedFBAuto = FALSE;
    pSiS->CRT2Position = sisRightOf;
    pSiS->CRT2HSync = NULL;
    pSiS->CRT2VRefresh = NULL;
    pSiS->MetaModes = NULL;
    pSiS->MergedFBXDPI = pSiS->MergedFBYDPI = 0;
#ifdef SISXINERAMA
    pSiS->UseSiSXinerama = TRUE;
    pSiS->CRT2IsScrn0 = FALSE;
#endif
#endif
#ifdef SIS_CP
    SIS_CP_OPT_DEFAULT
#endif
d74 6
a79 57
    /* Chipset dependent defaults */

    if(pSiS->Chipset == PCI_CHIP_SIS530) {
    	 /* TW: TQ still broken on 530/620? */
	 pSiS->TurboQueue = FALSE;
    }

    if(pSiS->Chipset == PCI_CHIP_SIS6326) {
         pSiS->newFastVram = 1;
    }

    if(pSiS->sishw_ext.jChipType == SIS_315H ||
       pSiS->sishw_ext.jChipType == SIS_315) {
         /* Cursor engine seriously broken */
         pSiS->HWCursor = FALSE;
    }

    /* DRI only supported on 300 series,
     * so don't load DRI by default on
     * others.
     */
    if(pSiS->VGAEngine == SIS_300_VGA) {
       pSiS->loadDRI = TRUE;
    }

#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    pSiS->OptUseColorCursor = 0;
#else
    if(pSiS->VGAEngine == SIS_300_VGA) {
    	pSiS->OptUseColorCursor = 0;
	pSiS->OptUseColorCursorBlend = 1;
	pSiS->OptColorCursorBlendThreshold = 0x37000000;
    } else if(pSiS->VGAEngine == SIS_315_VGA) {
    	pSiS->OptUseColorCursor = 1;
    }
#endif

    if(pSiS->VGAEngine == SIS_300_VGA) {
       pSiS->AllowHotkey = 0;
    } else if(pSiS->VGAEngine == SIS_315_VGA) {
       pSiS->AllowHotkey = 1;
    }

    /* Collect the options */

    /* FastVRAM (5597/5598, 6326 and 530/620 only)
     */
    if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
       from = X_DEFAULT;
       if(xf86GetOptValBool(pSiS->Options, OPTION_FAST_VRAM, &pSiS->newFastVram)) {
          from = X_CONFIG;
       }
       xf86DrvMsg(pScrn->scrnIndex, from, "Fast VRAM %s\n",
                   (pSiS->newFastVram == -1) ?
		         ((pSiS->oldChipset == OC_SIS620) ? "enabled (for read only)" :
			                                    "enabled (for write only)") :
		   	 (pSiS->newFastVram ? "enabled (for read and write)" : disabledstr));
d82 5
a86 22
    /* NoHostBus (5597/5598 only)
     */
    if((pSiS->Chipset == PCI_CHIP_SIS5597)) {
       from = X_DEFAULT;
       if(xf86GetOptValBool(pSiS->Options, OPTION_NOHOSTBUS, &pSiS->NoHostBus)) {
          from = X_CONFIG;
       }
       xf86DrvMsg(pScrn->scrnIndex, from, "SiS5597/5598 VGA-to-CPU host bus %s\n",
                   pSiS->NoHostBus ? disabledstr : enabledstr);
    }

    /* MaxXFBMem
     * This options limits the amount of video memory X uses for screen
     * and off-screen buffers. This option should be used if using DRI
     * is intended. The kernel framebuffer driver required for DRM will
     * start its memory heap at 12MB if it detects more than 16MB, at 8MB if
     * between 8 and 16MB are available, otherwise at 4MB. So, if the amount
     * of memory X uses, a clash between the framebuffer's memory heap
     * and X is avoided. The amount is to be specified in KB.
     */
    if(xf86GetOptValULong(pSiS->Options, OPTION_MAXXFBMEM,
                                &pSiS->maxxfbmem)) {
d88 2
a89 3
                    "MaxXFBMem: Framebuffer memory shall be limited to %ld KB\n",
		    pSiS->maxxfbmem);
	    pSiS->maxxfbmem *= 1024;
a90 11

    /* NoAccel
     * Turns off 2D acceleration
     */
    if(xf86ReturnOptValBool(pSiS->Options, OPTION_NOACCEL, FALSE)) {
        pSiS->NoAccel = TRUE;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	pSiS->NoXvideo = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "2D Acceleration and Xv disabled\n");
#else
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "2D Acceleration disabled\n");
d93 1
a93 17
    }

    /* RenderAcceleration
     * En/Disables RENDER acceleration (315/330 series only)
     */
    if((pSiS->VGAEngine == SIS_315_VGA) && (!pSiS->NoAccel)) {
       if(xf86GetOptValBool(pSiS->Options, OPTION_RENDER, &pSiS->doRender)) {
          if(!pSiS->doRender) {
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "RENDER Acceleration disabled\n");
	  }
       }
    }

    /* SWCursor
     * HWCursor
     * Chooses whether to use the hardware or software cursor
     */
d95 1
a95 1
    if(xf86GetOptValBool(pSiS->Options, OPTION_HW_CURSOR, &pSiS->HWCursor)) {
d98 1
a98 1
    if(xf86ReturnOptValBool(pSiS->Options, OPTION_SW_CURSOR, FALSE)) {
a100 1
	pSiS->OptUseColorCursor = 0;
d102 1
a102 1
    xf86DrvMsg(pScrn->scrnIndex, from, "Using %s cursor\n",
d105 4
a108 54
    /*
     * UseColorHWCursor
     * ColorHWCursorBlending
     * ColorHWCursorBlendThreshold
     *
     * Enable/disable color hardware cursors;
     * enable/disable color hw cursor emulation for 300 series
     * select emultation transparency threshold for 300 series
     *
     */
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
#ifdef ARGB_CURSOR
#ifdef SIS_ARGB_CURSOR
    if((pSiS->HWCursor) && ((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA))) {
       from = X_DEFAULT;
       if(xf86GetOptValBool(pSiS->Options, OPTION_USERGBCURSOR, &pSiS->OptUseColorCursor)) {
    	   from = X_CONFIG;
       }
       xf86DrvMsg(pScrn->scrnIndex, from, "Color HW cursor is %s\n",
                    pSiS->OptUseColorCursor ? enabledstr : disabledstr);

       if(pSiS->VGAEngine == SIS_300_VGA) {
          from = X_DEFAULT;
          if(xf86GetOptValBool(pSiS->Options, OPTION_USERGBCURSORBLEND, &pSiS->OptUseColorCursorBlend)) {
    	     from = X_CONFIG;
          }
          if(pSiS->OptUseColorCursor) {
             xf86DrvMsg(pScrn->scrnIndex, from,
	   	"HW cursor color blending emulation is %s\n",
		(pSiS->OptUseColorCursorBlend) ? enabledstr : disabledstr);
	  }
	  {
	  int temp;
	  from = X_DEFAULT;
	  if(xf86GetOptValInteger(pSiS->Options, OPTION_USERGBCURSORBLENDTH, &temp)) {
	     if((temp >= 0) && (temp <= 255)) {
	        from = X_CONFIG;
		pSiS->OptColorCursorBlendThreshold = (temp << 24);
	     } else {
	        temp = pSiS->OptColorCursorBlendThreshold >> 24;
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Illegal color HW cursor blending threshold, valid range 0-255\n");
	     }
	  } else {
	        temp = pSiS->OptColorCursorBlendThreshold >> 24;
          }
	  if(pSiS->OptUseColorCursor) {
	     if(pSiS->OptUseColorCursorBlend) {
	        xf86DrvMsg(pScrn->scrnIndex, from,
	          "HW cursor color blending emulation threshold is %d\n", temp);
 	     }
	  }
	  }
       }
a109 3
#endif
#endif
#endif
d111 4
a114 125
    /*
     * MergedFB
     *
     * Enable/disable and configure merged framebuffer mode
     *
     */
#ifdef SISMERGED
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       Bool val;
       if(xf86GetOptValBool(pSiS->Options, OPTION_MERGEDFB, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     "Option \"MergedFB\" cannot be used in Dual Head mode\n");
       }
    } else
#endif
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       Bool val;
       if(xf86GetOptValBool(pSiS->Options, OPTION_MERGEDFB, &val)) {
	  if(val) {
	     pSiS->MergedFB = TRUE;
	     pSiS->MergedFBAuto = FALSE;
	  }
       } else if(xf86GetOptValBool(pSiS->Options, OPTION_MERGEDFB2, &val)) {
          if(val) {
	     pSiS->MergedFB = TRUE;
	     pSiS->MergedFBAuto = FALSE;
	  }
       }

       if(xf86GetOptValBool(pSiS->Options, OPTION_MERGEDFBAUTO, &val)) {
          if(!pSiS->MergedFB) {
	     if(val) {
	        pSiS->MergedFB = pSiS->MergedFBAuto = TRUE;
	     }
	  } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"Option \"MergedFB\" overrules option \"MergedFBAuto\"\n");
	  }
       }

       if(pSiS->MergedFB) {
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2POS);
	  if(!strptr) {
	     strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2POS2);
	  }
      	  if(strptr) {
       	     if(!xf86NameCmp(strptr,"LeftOf")) {
                pSiS->CRT2Position = sisLeftOf;
#ifdef SISXINERAMA
		pSiS->CRT2IsScrn0 = TRUE;
#endif
 	     } else if(!xf86NameCmp(strptr,"RightOf")) {
                pSiS->CRT2Position = sisRightOf;
#ifdef SISXINERAMA
		pSiS->CRT2IsScrn0 = FALSE;
#endif
	     } else if(!xf86NameCmp(strptr,"Above")) {
                pSiS->CRT2Position = sisAbove;
#ifdef SISXINERAMA
		pSiS->CRT2IsScrn0 = FALSE;
#endif
	     } else if(!xf86NameCmp(strptr,"Below")) {
                pSiS->CRT2Position = sisBelow;
#ifdef SISXINERAMA
		pSiS->CRT2IsScrn0 = TRUE;
#endif
	     } else if(!xf86NameCmp(strptr,"Clone")) {
                pSiS->CRT2Position = sisClone;
#ifdef SISXINERAMA
		pSiS->CRT2IsScrn0 = TRUE;
#endif
	     } else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "CRT2Position");
	    	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	            "Valid parameters are \"RightOf\", \"LeftOf\", \"Above\", \"Below\", or \"Clone\"\n");
	     }
	  }
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_METAMODES);
	  if(strptr) {
	     pSiS->MetaModes = xalloc(strlen(strptr) + 1);
	     if(pSiS->MetaModes) memcpy(pSiS->MetaModes, strptr, strlen(strptr) + 1);
	  }
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2HSYNC);
	  if(!strptr) {
	     strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2HSYNC2);
	  }
	  if(strptr) {
	     pSiS->CRT2HSync = xalloc(strlen(strptr) + 1);
	     if(pSiS->CRT2HSync) memcpy(pSiS->CRT2HSync, strptr, strlen(strptr) + 1);
	  }
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2VREFRESH);
	  if(!strptr) {
	     strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2VREFRESH2);
	  }
	  if(strptr) {
	     pSiS->CRT2VRefresh = xalloc(strlen(strptr) + 1);
	     if(pSiS->CRT2VRefresh) memcpy(pSiS->CRT2VRefresh, strptr, strlen(strptr) + 1);
	  }
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_MERGEDDPI);
	  if(strptr) {
	     int val1 = 0, val2 = 0;
	     sscanf(strptr, "%d %d", &val1, &val2);
	     if(val1 && val2) {
	        pSiS->MergedFBXDPI = val1;
		pSiS->MergedFBYDPI = val2;
	     } else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "MergedDPI");
	     }
	  }
#ifdef SISXINERAMA
	  if(pSiS->MergedFB) {
	     if(xf86GetOptValBool(pSiS->Options, OPTION_NOSISXINERAMA, &val)) {
	        if(val) pSiS->UseSiSXinerama = FALSE;
	     } else if(xf86GetOptValBool(pSiS->Options, OPTION_NOSISXINERAMA2, &val)) {
	        if(val) pSiS->UseSiSXinerama = FALSE;
	     }
	     if(pSiS->UseSiSXinerama) {
	        if(xf86GetOptValBool(pSiS->Options, OPTION_CRT2ISSCRN0, &val)) {
		   pSiS->CRT2IsScrn0 = val ? TRUE : FALSE;
		}
	     }
	  }
#endif
       }
d116 2
a117 1
#endif
d119 7
a125 108
    /* Some options can only be specified in the Master Head's Device
     * section. Here we give the user a hint in the log.
     */
#ifdef SISDUALHEAD
    if((pSiS->DualHeadMode) && (pSiS->SecondHead)) {
       static const char *mystring = "Option \"%s\" is only accepted in Master Head's device section\n";
       Bool val;
       int vali;
       if(pSiS->VGAEngine != SIS_315_VGA) {
          if(xf86GetOptValBool(pSiS->Options, OPTION_TURBOQUEUE, &val)) {
             xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "TurboQueue");
          }
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_RESTOREBYSET, &val)) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "RestoreBySetMode");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_ENABLEHOTKEY, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "EnableHotKey");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_ENABLESISCTRL, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "EnableSiSCtrl");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_USEROMDATA, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "UseROMData");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_USEOEM, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "UseOEMData");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_FORCECRT1, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "ForceCRT1");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_NODDCFORCRT2, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "NoCRT2Detection");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_FORCECRT2REDETECTION, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "ForceCRT2ReDetection");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT1TYPE)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "ForceCRT1Type");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT2TYPE)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "ForceCRT2Type");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_YPBPRAR)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "YPbPrAspectRatio");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_SCALELCD, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "ScaleLCD");
       }
       if(xf86GetOptValInteger(pSiS->Options, OPTION_PDC, &vali)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "PanelDelayCompensation");
       }
       if(xf86GetOptValInteger(pSiS->Options, OPTION_EMI, &vali)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "EMI");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_SPECIALTIMING)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "SpecialTiming");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_LVDSHL)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "LVDSHL");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_TVSTANDARD)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "TVStandard");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_CHTVTYPE)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "CHTVType");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_CHTVOVERSCAN, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "CHTVOverscan");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_CHTVSOVERSCAN, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "CHTVSuperOverscan");
       }
       if((xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMABANDWIDTHCVBS, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMABANDWIDTHSVIDEO, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMAFLICKERFILTER, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCHROMABANDWIDTH, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCHROMAFLICKERFILTER, &vali)) ||
          (xf86GetOptValBool(pSiS->Options, OPTION_CHTVCVBSCOLOR, &val)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVTEXTENHANCE, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCONTRAST, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_SISTVEDGEENHANCE, &vali)) ||
	  (xf86GetOptValString(pSiS->Options, OPTION_SISTVANTIFLICKER)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_SISTVSATURATION, &vali)) ||
	  (xf86GetOptValBool(pSiS->Options, OPTION_SISTVCHROMAFILTER, &val)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_SISTVLUMAFILTER, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_SISTVCOLCALIBCOARSE, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_SISTVCOLCALIBFINE, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_TVXPOSOFFSET, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_TVYPOSOFFSET, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_TVXSCALE, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_TVYSCALE, &vali))) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      "TV related options are only accepted in Master Head's device section");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_CRT2GAMMA, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "CRT2Gamma");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_XVONCRT2, &val)) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "XvOnCRT2");
       }
#ifdef SIS_CP
       SIS_CP_OPT_DH_WARN
#endif
    } else
#endif    
    {
       if(pSiS->VGAEngine == SIS_315_VGA) {
d127 7
a133 6
#ifdef SISVRAMQ
          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using VRAM command queue, size %dk\n",
	  	pSiS->cmdQueueSize / 1024);
#else
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using MMIO command queue, size 512k\n");
#endif
d135 4
a138 628
       } else {

	  /* TurboQueue */

          from = X_DEFAULT;
          if(xf86GetOptValBool(pSiS->Options, OPTION_TURBOQUEUE, &pSiS->TurboQueue)) {
    	     from = X_CONFIG;
          }
          xf86DrvMsg(pScrn->scrnIndex, from, "TurboQueue %s\n",
                    pSiS->TurboQueue ? enabledstr : disabledstr);
       }

       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {

          Bool val;

	  /* RestoreBySetMode (300/315/330 series only)
           * Set this to force the driver to set the old mode instead of restoring
           * the register contents. This can be used to overcome problems with
           * LCD panels and video bridges.
           */
          if(xf86GetOptValBool(pSiS->Options, OPTION_RESTOREBYSET, &val)) {
             pSiS->restorebyset = val ? TRUE : FALSE;
          }

	  /* EnableHotkey (300/315/330 series only)
	   * Enables or disables the BIOS hotkey switch for
	   * switching the output device on laptops.
	   * This key causes a total machine hang on many 300 series
	   * machines, it is therefore by default disabled on such.
	   * In dual head mode, using the hotkey is lethal, so we
	   * forbid it then in any case.
	   * However, although the driver disables the hotkey as
	   * BIOS developers intented to do that, some buggy BIOSes
	   * still cause the machine to freeze. Hence the warning.
	   */
          {
	  int flag = 0;
#ifdef SISDUALHEAD
          if(pSiS->DualHeadMode) {
	     pSiS->AllowHotkey = 0;
	     flag = 1;
	  } else
#endif
	  if(xf86GetOptValBool(pSiS->Options, OPTION_ENABLEHOTKEY, &val)) {
	     pSiS->AllowHotkey = val ? 1 : 0;
          }
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Hotkey display switching is %s%s\n",
	        pSiS->AllowHotkey ? enabledstr : disabledstr,
	        flag ? " in dual head mode" : "");
	  if(pSiS->Chipset == PCI_CHIP_SIS630 ||
	     pSiS->Chipset == PCI_CHIP_SIS650 ||
	     pSiS->Chipset == PCI_CHIP_SIS660) {
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	         "WARNING: Using the Hotkey might freeze your machine, regardless\n");
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "\twhether enabled or disabled. This is no driver bug.\n");
	  }
	  }

          /* UseROMData (300/315/330 series only)
           * This option is enabling/disabling usage of some machine
           * specific data from the BIOS ROM. This option can - and
           * should - be used in case the driver makes problems
           * because SiS changed the location of this data.
           */
	  if(xf86GetOptValBool(pSiS->Options, OPTION_USEROMDATA, &val)) {
	     pSiS->OptROMUsage = val ? 1 : 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "Video ROM data usage shall be %s\n",
	          val ? enabledstr : disabledstr);
	  }

          /* UseOEMData (300/315/330 series only)
           * The driver contains quite a lot data for OEM LCD panels
           * and TV connector specifics which override the defaults.
           * If this data is incorrect, the TV may lose color and
           * the LCD panel might show some strange effects. Use this
           * option to disable the usage of this data.
           */
	  if(xf86GetOptValBool(pSiS->Options, OPTION_USEOEM, &val)) {
	     pSiS->OptUseOEM = val ? 1 : 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "Internal LCD/TV/VGA2 OEM data usage shall be %s\n",
	         val ? enabledstr : disabledstr);
	  }

	  /* NoCRT2DDCDetection (315/330 series only)
           * If set to true, this disables CRT2 detection using DDC. This is
           * to avoid problems with not entirely DDC compiant LCD panels or
           * VGA monitors connected to the secondary VGA plug. Since LCD and
           * VGA share the same DDC channel, it might in some cases be impossible
           * to determine if the device is a CRT monitor or a flat panel.
           */
          if(xf86GetOptValBool(pSiS->Options, OPTION_NODDCFORCRT2, &val)) {
             pSiS->nocrt2ddcdetection = val ? TRUE : FALSE;
          }

	  /* ForceCRT2ReDetection (315/330 series only)
           * If set to true, it forces re-detection of the LCD panel and
	   * a secondary VGA connection even if the BIOS already had found
	   * about it. This is meant for custom panels (ie such with
	   * non-standard resolutions) which the BIOS will "detect" according
	   * to the established timings, resulting in only a very vague idea
	   * about the panels real resolution. As for secondary VGA, this
	   * enables us to include a Plasma panel's proprietary modes.
           */
          if(xf86GetOptValBool(pSiS->Options, OPTION_FORCECRT2REDETECTION, &val)) {
             if(val) {
	             pSiS->forcecrt2redetection = TRUE;
		     pSiS->nocrt2ddcdetection = FALSE;
	     } else  pSiS->forcecrt2redetection = FALSE;
          }


	  /* ForceCRT1Type (315/330 series only)
	   * Used for forcing the driver to initialize CRT1 as
	   * VGA (analog) or LCDA (for simultanious LCD and TV
           * display) - on M650/651 and 661 or later with 301C/30xLV only!
           */
	  if(pSiS->VGAEngine == SIS_315_VGA) {
             strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT1TYPE);
             if(strptr != NULL) {
                if(!xf86NameCmp(strptr,"VGA")) {
                   pSiS->ForceCRT1Type = CRT1_VGA;
		} else if( (!xf86NameCmp(strptr,"LCD")) ||
		         (!xf86NameCmp(strptr,"LCDA")) ||
			 (!xf86NameCmp(strptr,"LCD-A")) ) {
		   pSiS->ForceCRT1Type = CRT1_LCDA;
		} else {
		   xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "ForceCRT1Type");
	           xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	               "Valid parameters are \"VGA\" or \"LCD\"\n");
		}
	     }
	  }

	  /* ForceCRT1 (300/315/330 series only)
           * This option can be used to force CRT1 to be switched on/off. Its
           * intention is mainly for old monitors that can't be detected
           * automatically. This is only useful on machines with a video bridge.
           * In normal cases, this option won't be necessary.
           */
	  if(xf86GetOptValBool(pSiS->Options, OPTION_FORCECRT1, &val)) {
	     pSiS->forceCRT1 = val ? 1 : 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "CRT1 shall be forced to %s\n",
	         val ? "ON" : "OFF");
	     if(!pSiS->forceCRT1) pSiS->ForceCRT1Type = CRT1_VGA;
	  }

	  /* ForceCRT2Type (300/315/330 series only)
	   * Used for forcing the driver to initialize a given
	   * CRT2 device type.
           * (SVIDEO, COMPOSITE and SCART for overriding detection)
           */
          strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT2TYPE);
          if(strptr != NULL) {
             if(!xf86NameCmp(strptr,"TV"))
                pSiS->ForceCRT2Type = CRT2_TV;
 	     else if(!xf86NameCmp(strptr,"SVIDEO")) {
                pSiS->ForceCRT2Type = CRT2_TV;
	        pSiS->ForceTVType = TV_SVIDEO;
             } else if(!xf86NameCmp(strptr,"COMPOSITE")) {
                pSiS->ForceCRT2Type = CRT2_TV;
	        pSiS->ForceTVType = TV_AVIDEO;
	     } else if( (!xf86NameCmp(strptr,"COMPOSITE SVIDEO")) || /* Ugly, but shorter than a parsing function */
	                (!xf86NameCmp(strptr,"COMPOSITE+SVIDEO")) ||
			(!xf86NameCmp(strptr,"SVIDEO+COMPOSITE")) ||
			(!xf86NameCmp(strptr,"SVIDEO COMPOSITE")) ) {
	        pSiS->ForceCRT2Type = CRT2_TV;
		pSiS->ForceTVType = (TV_SVIDEO | TV_AVIDEO);
             } else if(!xf86NameCmp(strptr,"SCART")) {
                pSiS->ForceCRT2Type = CRT2_TV;
	        pSiS->ForceTVType = TV_SCART;
             } else if((!xf86NameCmp(strptr,"LCD")) || (!xf86NameCmp(strptr,"DVI-D"))) {
	        if(pSiS->ForceCRT1Type == CRT1_VGA) {
                   pSiS->ForceCRT2Type = CRT2_LCD;
		} else {
		   pSiS->ForceCRT2Type = 0;
		   xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   		"Can't set both CRT1 and CRT2 type to LCD; CRT2 disabled\n");
		}
             } else if((!xf86NameCmp(strptr,"VGA")) || (!xf86NameCmp(strptr,"DVI-A")))
                pSiS->ForceCRT2Type = CRT2_VGA;
             else if(!xf86NameCmp(strptr,"NONE"))
                pSiS->ForceCRT2Type = 0;
	     else if((!xf86NameCmp(strptr,"DSTN")) && (pSiS->Chipset == PCI_CHIP_SIS550)) {
		if(pSiS->ForceCRT1Type == CRT1_VGA) {
		   pSiS->ForceCRT2Type = CRT2_LCD;
		   pSiS->DSTN = TRUE;
		}
	     } else if((!xf86NameCmp(strptr,"FSTN")) && (pSiS->Chipset == PCI_CHIP_SIS550)) {
		if(pSiS->ForceCRT1Type == CRT1_VGA) {
		   pSiS->ForceCRT2Type = CRT2_LCD;
		   pSiS->FSTN = TRUE;
		}
#ifdef ENABLE_YPBPR
	     } else if(!xf86NameCmp(strptr,"HIVISION")) {
		pSiS->ForceCRT2Type = CRT2_TV;
	        pSiS->ForceTVType = TV_HIVISION;
	     } else if((!xf86NameCmp(strptr,"YPBPR1080I")) && (pSiS->VGAEngine == SIS_315_VGA)) {
	        pSiS->ForceCRT2Type = CRT2_TV;
		pSiS->ForceTVType = TV_YPBPR;
		pSiS->ForceYPbPrType = TV_YPBPR1080I;
	     } else if(((!xf86NameCmp(strptr,"YPBPR525I")) || (!xf86NameCmp(strptr,"YPBPR480I"))) &&
	               (pSiS->VGAEngine == SIS_315_VGA)) {
		pSiS->ForceCRT2Type = CRT2_TV;
		pSiS->ForceTVType = TV_YPBPR;
		pSiS->ForceYPbPrType = TV_YPBPR525I;
	     } else if(((!xf86NameCmp(strptr,"YPBPR525P")) || (!xf86NameCmp(strptr,"YPBPR480P"))) &&
	               (pSiS->VGAEngine == SIS_315_VGA)) {
		pSiS->ForceCRT2Type = CRT2_TV;
		pSiS->ForceTVType = TV_YPBPR;
		pSiS->ForceYPbPrType = TV_YPBPR525P;
	     } else if(((!xf86NameCmp(strptr,"YPBPR750P")) || (!xf86NameCmp(strptr,"YPBPR720P"))) &&
	               (pSiS->VGAEngine == SIS_315_VGA)) {
		pSiS->ForceCRT2Type = CRT2_TV;
		pSiS->ForceTVType = TV_YPBPR;
		pSiS->ForceYPbPrType = TV_YPBPR750P;
#endif
	     } else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "ForceCRT2Type");
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	            "Valid parameters are \"LCD\" (=\"DVI-D\"), \"TV\", \"SVIDEO\", \"COMPOSITE\",\n"
		    "\t\"SVIDEO+COMPOSITE\", \"SCART\", \"VGA\" (=\"DVI-A\") or \"NONE\"; on the SiS550\n"
		    "\talso \"DSTN\" and \"FSTN\""
#ifdef ENABLE_YPBPR
		    				"; on SiS 301/301B bridges also \"HIVISION\", and on\n"
		    "\tSiS315/330 series with 301C/30xLV bridge also \"YPBPR480I\", \"YPBPR480P\",\n"
		    "\t\"YPBPR720P\" and \"YPBPR1080I\""
#endif
		    "\n");
	     }

             if(pSiS->ForceCRT2Type != CRT2_DEFAULT)
                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "CRT2 type shall be %s\n", strptr);
          }

	  if(pSiS->ForceTVType == TV_YPBPR) {
	     strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_YPBPRAR);
             if(strptr != NULL) {
	        if(!xf86NameCmp(strptr,"4:3LB"))
                   pSiS->ForceYPbPrAR = TV_YPBPR43LB;
		else if(!xf86NameCmp(strptr,"4:3"))
                   pSiS->ForceYPbPrAR = TV_YPBPR43;
		else if(!xf86NameCmp(strptr,"16:9"))
                   pSiS->ForceYPbPrAR = TV_YPBPR169;
		else {
		   xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "YPbPrAspectRatio");
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	            	"Valid parameters are \"4:3LB\", \"4:3\" and \"16:9\"\n");
		}
	     }
	  }

	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SPECIALTIMING);
          if(strptr != NULL) {
	     int i = 0;
	     BOOLEAN found = FALSE;
	     if(!xf86NameCmp(strptr,"NONE")) {
	        pSiS->SiS_Pr->SiS_CustomT = CUT_FORCENONE;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			"Special timing disabled\n");
	     } else {
	        while(mycustomttable[i].chipID != 0) {
	           if(!xf86NameCmp(strptr,mycustomttable[i].optionName)) {
		      pSiS->SiS_Pr->SiS_CustomT = mycustomttable[i].SpecialID;
		      found = TRUE;
		      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		   	  "Special timing for %s %s forced\n",
			  mycustomttable[i].vendorName, mycustomttable[i].cardName);
		      break;
		   }
		   i++;
	        }
		if(!found) {
		   xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "SpecialTiming");
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Valid parameters are:\n");
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "\t\"NONE\" (to disable special timings)\n");
		   i = 0;
		   while(mycustomttable[i].chipID != 0) {
		      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		        	"\t\"%s\" (for %s %s)\n",
				mycustomttable[i].optionName,
				mycustomttable[i].vendorName,
				mycustomttable[i].cardName);
		      i++;
		   }
                }
 	     }
	  }

	  /* EnableSiSCtrl */
	  /* Allow sisctrl tool to change driver settings */
	  from = X_DEFAULT;
	  if(xf86GetOptValBool(pSiS->Options, OPTION_ENABLESISCTRL, &val)) {
             if(val) pSiS->enablesisctrl = TRUE;
	     from = X_CONFIG;
          }
	  xf86DrvMsg(pScrn->scrnIndex, from, "SiSCtrl utility interface is %s\n",
	  	pSiS->enablesisctrl ? enabledstr : disabledstr);

         /* ScaleLCD (300/315/330 series only)
          * Can be used to force the bridge/panel link to [do|not do] the
	  * scaling of modes lower than the panel's native resolution.
          * Setting this to TRUE will force the bridge/panel link
	  * to scale; FALSE will rely on the panel's capabilities.
	  * Not supported on all machines.
          */
	  if(xf86GetOptValBool(pSiS->Options, OPTION_SCALELCD, &val)) {
	     pSiS->UsePanelScaler = val ? 0 : 1;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "LCD scaling is %s\n",
	         pSiS->UsePanelScaler ? disabledstr : enabledstr);
	  }

         /* PanelDelayCompensation (300/315/330 series only)
          * This might be required if the LCD panel shows "small waves".
          * The parameter is an integer, (on 300 series usually either
	  * 4, 32 or 24; on 315 series + LV bridge usually 3 or 51)
          * Why this option? Simply because SiS did poor BIOS design.
          * The PDC value depends on the very LCD panel used in a
          * particular machine. For most panels, the driver is able
          * to detect the correct value. However, some panels require
          * a different setting. For 300 series, the value given must
	  * be within the mask 0x3c.
          */
          if(xf86GetOptValInteger(pSiS->Options, OPTION_PDC, &pSiS->PDC)) {
	     if((pSiS->VGAEngine == SIS_300_VGA) && (pSiS->PDC & ~0x3c)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	            "Illegal PanelDelayCompensation parameter\n");
	        pSiS->PDC = -1;
	     } else {
                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "Panel delay compensation shall be %d\n",
	             pSiS->PDC);
	     }
          }

	 /* LVDSHL (300/315/330 series + 30xLV bridge only)
          * This might be required if the LCD panel is too dark.
          * The parameter is an integer from 0 to 3.
          */
          if(xf86GetOptValInteger(pSiS->Options, OPTION_LVDSHL, &pSiS->SiS_Pr->LVDSHL)) {
	     if((pSiS->SiS_Pr->LVDSHL < 0) || (pSiS->SiS_Pr->LVDSHL > 3)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	            "Illegal LVDSHL parameter, valid is 0 through 3\n");
	        pSiS->SiS_Pr->LVDSHL = -1;
	     } else {
                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "LVDSHL will be %d\n",
	             pSiS->SiS_Pr->LVDSHL);
	     }
          }

	 /* EMI (315/330 series + 302LV/302ELV bridge only)
          * This might be required if the LCD panel loses sync on
	  * mode switches. So far, this problem should not show up
	  * due to the auto-detection (from reading the values set
	  * by the BIOS; however, the BIOS values are wrong sometimes
	  * such as in the case of some Compal machines with a
	  * 1400x1050, or some Inventec(Compaq) machines with a
	  * 1280x1024 panel.
          * The parameter is an integer from 0 to 0x60ffffff.
          */
          if(xf86GetOptValInteger(pSiS->Options, OPTION_EMI, &pSiS->EMI)) {
	     if((pSiS->EMI < 0) || (pSiS->EMI > 0x60ffffff)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	            "Illegal EMI parameter, valid is 0 through 0x60ffffff\n");
	        pSiS->EMI = -1;
	     } else {
	        pSiS->EMI &= 0x60ffffff;
                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "EMI will be 0x%04x\n", pSiS->EMI);
	     }
          }

       }


      /* TVStandard (300/315/330 series and 6326 w/ TV only)
       * This option is for overriding the autodetection of
       * the BIOS/Jumper option for PAL / NTSC
       */
       if((pSiS->VGAEngine == SIS_300_VGA) ||
          (pSiS->VGAEngine == SIS_315_VGA) ||
          ((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV))) {
          strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_TVSTANDARD);
          if(strptr != NULL) {
             if(!xf86NameCmp(strptr,"PAL"))
	        pSiS->OptTVStand = 1;
	     else if((!xf86NameCmp(strptr,"PALM")) ||
	             (!xf86NameCmp(strptr,"PAL-M"))) {
	        pSiS->OptTVStand = 1;
	        pSiS->NonDefaultPAL = 1;
  	     } else if((!xf86NameCmp(strptr,"PALN")) ||
	               (!xf86NameCmp(strptr,"PAL-N"))) {
	        pSiS->OptTVStand = 1;
	        pSiS->NonDefaultPAL = 0;
	     } else if((!xf86NameCmp(strptr,"NTSCJ")) ||
	               (!xf86NameCmp(strptr,"NTSC-J"))) {
	        pSiS->OptTVStand = 0;
	        pSiS->NonDefaultNTSC = 1;
  	     } else if(!xf86NameCmp(strptr,"NTSC"))
	        pSiS->OptTVStand = 0;
	     else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "TVStandard");
                xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	            "Valid parameters are \"PAL\", \"PALM\", \"PALN\", \"NTSC\", \"NTSCJ\"\n");
	     }

	     if(pSiS->OptTVStand != -1) {
	        static const char *tvstdstr = "TV standard shall be %s\n";
	        if(pSiS->Chipset == PCI_CHIP_SIS6326) {
	           pSiS->NonDefaultPAL = -1;
		   pSiS->NonDefaultNTSC = -1;
	           xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, tvstdstr,
	               pSiS->OptTVStand ? "PAL" : "NTSC");
	        } else {
	           xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, tvstdstr,
		       (pSiS->OptTVStand ?
		           ( (pSiS->NonDefaultPAL == -1) ? "PAL" :
			      ((pSiS->NonDefaultPAL) ? "PALM" : "PALN") ) :
				(pSiS->NonDefaultNTSC == -1) ? "NTSC" : "NTSCJ"));
	        }
	     }
          }
       }

      /* CHTVType  (315/330 series + Chrontel only)
       * Used for telling the driver if the TV output shall
       * be 525i YPbPr or SCART.
       */
       if(pSiS->VGAEngine == SIS_315_VGA) {
          strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CHTVTYPE);
          if(strptr != NULL) {
             if(!xf86NameCmp(strptr,"SCART"))
                pSiS->chtvtype = 1;
 	     else if(!xf86NameCmp(strptr,"YPBPR525I"))
	        pSiS->chtvtype = 0;
	     else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "CHTVType");
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	          "Valid parameters are \"SCART\" or \"YPBPR525I\"\n");
	     }
             if(pSiS->chtvtype != -1)
                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                  "Chrontel: TV type shall be %s\n", strptr);
          }
       }

       /* CHTVOverscan (300/315/330 series only)
        * CHTVSuperOverscan (300/315/330 series only)
        * These options are for overriding the BIOS option for
        * TV Overscan. Some BIOS don't even have such an option.
        * SuperOverscan is only supported with PAL.
        * Both options are only effective on machines with a
        * CHRONTEL TV encoder. SuperOverscan is only available
        * on the 700x.
        */
       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	  Bool val;
	  if(xf86GetOptValBool(pSiS->Options, OPTION_CHTVOVERSCAN, &val)) {
	     pSiS->OptTVOver = val ? 1 : 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "Chrontel: TV overscan shall be %s\n",
	         val ? enabledstr : disabledstr);
	  }
          if(xf86GetOptValBool(pSiS->Options, OPTION_CHTVSOVERSCAN, &pSiS->OptTVSOver)) {
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "Chrontel: TV super overscan shall be %s\n",
	         pSiS->OptTVSOver ? enabledstr : disabledstr);
	  }
       }

       /* Various parameters for TV output via SiS bridge, Chrontel or SiS6326
        */
       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
          int tmp = 0;
          xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMABANDWIDTHCVBS,
                                &pSiS->chtvlumabandwidthcvbs);
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMABANDWIDTHSVIDEO,
                                &pSiS->chtvlumabandwidthsvideo);
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMAFLICKERFILTER,
                                &pSiS->chtvlumaflickerfilter);
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCHROMABANDWIDTH,
                                &pSiS->chtvchromabandwidth);
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCHROMAFLICKERFILTER,
                                &pSiS->chtvchromaflickerfilter);
	  xf86GetOptValBool(pSiS->Options, OPTION_CHTVCVBSCOLOR,
				&pSiS->chtvcvbscolor);
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVTEXTENHANCE,
                                &pSiS->chtvtextenhance);
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCONTRAST,
                                &pSiS->chtvcontrast);
	  xf86GetOptValInteger(pSiS->Options, OPTION_SISTVEDGEENHANCE,
                                &pSiS->sistvedgeenhance);
	  xf86GetOptValInteger(pSiS->Options, OPTION_SISTVSATURATION,
                                &pSiS->sistvsaturation);
	  xf86GetOptValInteger(pSiS->Options, OPTION_SISTVLUMAFILTER,
                                &pSiS->sistvyfilter);
          if((pSiS->sistvyfilter < 0) || (pSiS->sistvyfilter > 8)) {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"Illegal Y Filter number; valid is 0 (off), 1 (default), 2-8 (filter number 1-7)\n");
	     pSiS->sistvyfilter = 1;
	  }
 	  xf86GetOptValBool(pSiS->Options, OPTION_SISTVCHROMAFILTER,
				&pSiS->sistvcfilter);
	  xf86GetOptValInteger(pSiS->Options, OPTION_SISTVCOLCALIBCOARSE,
                                &pSiS->sistvcolcalibc);
          xf86GetOptValInteger(pSiS->Options, OPTION_SISTVCOLCALIBFINE,
                                &pSiS->sistvcolcalibf);
	  if((pSiS->sistvcolcalibf > 127) || (pSiS->sistvcolcalibf < -128) ||
	     (pSiS->sistvcolcalibc > 120) || (pSiS->sistvcolcalibc < -120)) {
	     pSiS->sistvcolcalibf = pSiS->sistvcolcalibc = 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"Illegal Color Calibration. Range is -128 to 127 (fine), -120 to 120 (coarse)\n");
	  }
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVXPOSOFFSET,
                                &pSiS->tvxpos);
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVYPOSOFFSET,
                                &pSiS->tvypos);
	  if(pSiS->tvxpos > 32)  { pSiS->tvxpos = 32;  tmp = 1; }
	  if(pSiS->tvxpos < -32) { pSiS->tvxpos = -32; tmp = 1; }
	  if(pSiS->tvypos > 32)  { pSiS->tvypos = 32;  tmp = 1; }
	  if(pSiS->tvypos < -32) { pSiS->tvypos = -32;  tmp = 1; }
	  if(tmp) xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		      "Illegal TV x or y offset. Range is from -32 to 32\n");
          tmp = 0;
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVXSCALE,
                                &pSiS->tvxscale);
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVYSCALE,
                                &pSiS->tvyscale);
	  if(pSiS->tvxscale > 16)  { pSiS->tvxscale = 16;  tmp = 1; }
	  if(pSiS->tvxscale < -16) { pSiS->tvxscale = -16; tmp = 1; }
	  if(pSiS->tvyscale > 3)  { pSiS->tvyscale = 3;  tmp = 1; }
	  if(pSiS->tvyscale < -4) { pSiS->tvyscale = -4; tmp = 1; }
	  if(tmp) xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		      "Illegal TV x or y scaling parameter. Range is from -16 to 16 (X), -4 to 3 (Y)\n");
       }

       if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
          int tmp = 0;
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SIS6326FORCETVPPLUG);
          if(strptr) {
             if(!xf86NameCmp(strptr,"COMPOSITE"))
	        pSiS->sis6326tvplug = 1;
  	     else if(!xf86NameCmp(strptr,"SVIDEO"))
	        pSiS->sis6326tvplug = 0;
	     else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "SIS6326TVForcePlug");
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	           "Valid parameters are \"COMPOSITE\" or \"SVIDEO\"\n");
	     }
	  }
	  xf86GetOptValBool(pSiS->Options, OPTION_SIS6326ENABLEYFILTER,
                                &pSiS->sis6326enableyfilter);
	  xf86GetOptValBool(pSiS->Options, OPTION_SIS6326YFILTERSTRONG,
                                &pSiS->sis6326yfilterstrong);
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVXPOSOFFSET,
                                &pSiS->tvxpos);
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVYPOSOFFSET,
                                &pSiS->tvypos);
	  if(pSiS->tvxpos > 16)  { pSiS->tvxpos = 16;  tmp = 1; }
	  if(pSiS->tvxpos < -16) { pSiS->tvxpos = -16; tmp = 1; }
	  if(pSiS->tvypos > 16)  { pSiS->tvypos = 16;  tmp = 1; }
	  if(pSiS->tvypos < -16) { pSiS->tvypos = -16;  tmp = 1; }
	  if(tmp) xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		      "Illegal TV x or y offset. Range is from -16 to 16\n");
          xf86GetOptValInteger(pSiS->Options, OPTION_SIS6326FSCADJUST,
                                &pSiS->sis6326fscadjust);
	  if(pSiS->sis6326fscadjust) {
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	"Adjusting the default FSC by %d\n",
		pSiS->sis6326fscadjust);
	  }
       }

       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA) ||
          ((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV))) {
          strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SISTVANTIFLICKER);
          if(!strptr) {
             strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SIS6326ANTIFLICKER);
          }
          if(strptr) {
             if(!xf86NameCmp(strptr,"OFF"))
	        pSiS->sistvantiflicker = 0;
  	     else if(!xf86NameCmp(strptr,"LOW"))
	        pSiS->sistvantiflicker = 1;
	     else if(!xf86NameCmp(strptr,"MED"))
	        pSiS->sistvantiflicker = 2;
	     else if(!xf86NameCmp(strptr,"HIGH"))
	        pSiS->sistvantiflicker = 3;
	     else if(!xf86NameCmp(strptr,"ADAPTIVE"))
	        pSiS->sistvantiflicker = 4;
	     else {
	        pSiS->sistvantiflicker = -1;
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "SISTVAntiFlicker");
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	            "Valid parameters are \"OFF\", \"LOW\", \"MED\", \"HIGH\" or \"ADAPTIVE\"\n");
	     }
	  }
       }

       /* CRT2Gamma - enable/disable gamma correction for CRT2
        */
       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
          Bool val;
          if(xf86GetOptValBool(pSiS->Options, OPTION_CRT2GAMMA, &val)) {
	     pSiS->CRT2gamma = val;
          }
       }

#ifdef SIS_CP
       SIS_CP_OPT_DOOPT
#endif

    }  /* DualHead */

    /* CRT1Gamma - enable/disable gamma correction for CRT1
     */
    {
       Bool val;
       if(xf86GetOptValBool(pSiS->Options, OPTION_CRT1GAMMA, &val)) {
	  pSiS->CRT1gamma = val;
	  pSiS->CRT1gammaGiven = TRUE;
       }
d140 2
d143 4
a146 4
    /* VESA - DEPRECATED
     * This option is for forcing the driver to use
     * the VESA BIOS extension for mode switching.
     */
d148 8
a155 11
	Bool val;
	if(xf86GetOptValBool(pSiS->Options, OPTION_VESA, &val)) {
	    pSiS->VESA = val ? 1 : 0;
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	        "VESA: VESA usage shall be %s\n",
		val ? enabledstr : disabledstr);
 	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    	"*** Option \"VESA\" is deprecated. *** \n");
	    if(pSiS->VESA) pSiS->ForceCRT1Type = CRT1_VGA;
	}
    }
d157 3
a159 15
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {

       /* NoInternalModes (300/315/330 series only)
        * Since the mode switching code for these chipsets is a
        * Asm-to-C translation of BIOS code, we only have timings
        * for a pre-defined number of modes. The default behavior
        * is to replace XFree's default modes with a mode list
        * generated out of the known and supported modes. Use
        * this option to disable this. NOT RECOMMENDED.
        */
       from = X_DEFAULT;
       if(xf86GetOptValBool(pSiS->Options, OPTION_NOINTERNALMODES, &pSiS->noInternalModes))
		from = X_CONFIG;
       xf86DrvMsg(pScrn->scrnIndex, from, "Usage of built-in modes is %s\n",
		       pSiS->noInternalModes ? disabledstr : enabledstr);
d164 2
a165 20
    if(xf86GetOptValBool(pSiS->Options, OPTION_SHADOW_FB, &pSiS->ShadowFB)) {
#ifdef SISMERGED
       if(pSiS->MergedFB) {
          pSiS->ShadowFB = FALSE;
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      "Shadow Frame Buffer not supported in MergedFB mode\n");
       } else
#endif
          from = X_CONFIG;
    }
    if(pSiS->ShadowFB) {
	pSiS->NoAccel = TRUE;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	pSiS->NoXvideo = TRUE;
    	xf86DrvMsg(pScrn->scrnIndex, from,
	   "Using \"Shadow Frame Buffer\" - 2D acceleration and Xv disabled\n");
#else
    	xf86DrvMsg(pScrn->scrnIndex, from,
	   "Using \"Shadow Frame Buffer\" - 2D acceleration disabled\n");
#endif
d167 5
d174 39
a212 52
    if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_ROTATE))) {
#ifdef SISMERGED
       if(pSiS->MergedFB) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      "Screen rotation not supported in MergedFB mode\n");
       } else
#endif
       if(!xf86NameCmp(strptr, "CW")) {
          pSiS->Rotate = 1;
       } else if(!xf86NameCmp(strptr, "CCW")) {
          pSiS->Rotate = -1;
       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "Rotate");
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
              "Valid parameters are \"CW\" or \"CCW\"\n");
       }

       if(pSiS->Rotate) {
          pSiS->ShadowFB = TRUE;
          pSiS->NoAccel  = TRUE;
          pSiS->HWCursor = FALSE;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	  pSiS->NoXvideo = TRUE;
          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
              "Rotating screen %sclockwise; (2D acceleration and Xv disabled)\n",
	      (pSiS->Rotate == -1) ? "counter " : "");
#else
	  xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
              "Rotating screen %sclockwise (2D acceleration %sdisabled)\n",
	      (pSiS->Rotate == -1) ? "counter " : "",
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,0,0,0)
              "and RandR extension "
#else
	      ""
#endif
	      );

#endif

       }
    }

#ifdef XF86DRI
    /* DRI */
    from = X_DEFAULT;
    if(xf86GetOptValBool(pSiS->Options, OPTION_DRI, &pSiS->loadDRI)) {
       from = X_CONFIG;
    }
    xf86DrvMsg(pScrn->scrnIndex, from, "DRI %s\n",
       pSiS->loadDRI ? enabledstr : disabledstr);

    /* AGPSize */
d214 7
a220 16
       int vali;
       Bool gotit = FALSE;
       if(xf86GetOptValInteger(pSiS->Options, OPTION_AGP_SIZE, &vali)) {
          gotit = TRUE;
       } else if(xf86GetOptValInteger(pSiS->Options, OPTION_AGP_SIZE2, &vali)) {
          gotit = TRUE;
       }
       if(gotit) {
	  if((vali >= 8) && (vali <= 512)) {
	     pSiS->agpWantedPages = (vali * 1024 * 1024) / AGP_PAGE_SIZE;
	  } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr, "AGPSize (alias GARTSize)", 8, 512);
	  }
       }
    }
#endif
d222 3
a224 173
    /* NoXVideo
     * Set this to TRUE to disable Xv hardware video acceleration
     */
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    if((!pSiS->NoAccel) && (!pSiS->NoXvideo)) {
#else
    if(!pSiS->NoXvideo) {
#endif
       if(xf86ReturnOptValBool(pSiS->Options, OPTION_NOXVIDEO, FALSE)) {
          pSiS->NoXvideo = TRUE;
          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "XVideo extension disabled\n");
       }

       if(!pSiS->NoXvideo) {
          Bool val;
	  int tmp;

	  if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
      	     /* XvOnCRT2
	      * On chipsets with only one overlay (315, 650, 740, 330), the user can
	      * choose to display the overlay on CRT1 or CRT2. By setting this
	      * option to TRUE, the overlay will be displayed on CRT2. The
	      * default is: CRT1 if only CRT1 available, CRT2 if only CRT2
	      * available, and CRT1 if both is available and detected.
	      * Since implementation of the XV_SWITCHCRT Xv property this only
	      * selects the default CRT.
	      */
             if(xf86GetOptValBool(pSiS->Options, OPTION_XVONCRT2, &val)) {
	        pSiS->XvOnCRT2 = val ? TRUE : FALSE;
	     }
	  }

	  if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
	     /* NoYV12 (for 5597/5598, 6326 and 530/620 only)
	      * YV12 has problems with videos larger than 384x288. So
	      * allow the user to disable YV12 support to force the
	      * application to use YUV2 instead.
	      */
             if(xf86GetOptValBool(pSiS->Options, OPTION_NOYV12, &val)) {
	        pSiS->NoYV12 = val ? 1 : 0;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			"Xv YV12/I420 support is %s\n",
			pSiS->NoYV12 ? disabledstr : enabledstr);
	     }
	  }

	  /* Some Xv properties' defaults can be set by options */
          if(xf86GetOptValInteger(pSiS->Options, OPTION_XVDEFCONTRAST, &tmp)) {
             if((tmp >= 0) && (tmp <= 7)) pSiS->XvDefCon = tmp;
             else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       		      "XvDefaultContrast" ,0, 7);
          }
          if(xf86GetOptValInteger(pSiS->Options, OPTION_XVDEFBRIGHTNESS, &tmp)) {
             if((tmp >= -128) && (tmp <= 127)) pSiS->XvDefBri = tmp;
             else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       		      "XvDefaultBrightness", -128, 127);
          }
          if(pSiS->VGAEngine == SIS_315_VGA) {
             if(xf86GetOptValInteger(pSiS->Options, OPTION_XVDEFHUE, &tmp)) {
                if((tmp >= -8) && (tmp <= 7)) pSiS->XvDefHue = tmp;
                else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       	              "XvDefaultHue", -8, 7);
             }
             if(xf86GetOptValInteger(pSiS->Options, OPTION_XVDEFSATURATION, &tmp)) {
                if((tmp >= -7) && (tmp <= 7)) pSiS->XvDefSat = tmp;
                else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       	              "XvDefaultSaturation", -7, 7);
             }
          }
	  if(xf86GetOptValBool(pSiS->Options, OPTION_XVDEFDISABLEGFX, &val)) {
	     if(val)  pSiS->XvDefDisableGfx = TRUE;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	        "Graphics display will be %s during Xv usage\n",
	     	val ? disabledstr : enabledstr);
          }
	  if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	     if(xf86GetOptValBool(pSiS->Options, OPTION_XVDEFDISABLEGFXLR, &val)) {
	        if(val)  pSiS->XvDefDisableGfxLR = TRUE;
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	   "Graphics display left/right of overlay will be %s during Xv usage\n",
		   val ? disabledstr : enabledstr);
             }
	     if(xf86GetOptValBool(pSiS->Options, OPTION_XVDISABLECOLORKEY, &val)) {
	        if(val) pSiS->XvDisableColorKey = TRUE;
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	   "Xv Color key is %s\n",
		   val ? disabledstr : enabledstr);
             }
	     if(xf86GetOptValBool(pSiS->Options, OPTION_XVUSECHROMAKEY, &val)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	   "Xv Chroma-keying is %s\n",
		   val ? enabledstr : disabledstr);
		if(val) pSiS->XvUseChromaKey = TRUE;
             }
	     if(xf86GetOptValBool(pSiS->Options, OPTION_XVINSIDECHROMAKEY, &val)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	   "Xv: Video is transparent if %s chroma key range\n",
		   val ? "inside" : "outside");
		if(val) pSiS->XvInsideChromaKey = TRUE;
             }
	     if(pSiS->VGAEngine == SIS_300_VGA) {
	        if(xf86GetOptValBool(pSiS->Options, OPTION_XVYUVCHROMAKEY, &val)) {
	           xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	      "Xv: Chroma key is in %s format\n",
		      val ? "YUV" : "RGB");
		   if(val) pSiS->XvYUVChromaKey = TRUE;
		}
             } else {
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Xv: Chroma key is of same format as video source\n");
	     }
	     if(xf86GetOptValInteger(pSiS->Options, OPTION_XVCHROMAMIN, &tmp)) {
                if((tmp >= 0) && (tmp <= 0xffffff)) pSiS->XvChromaMin = tmp;
                else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       	                       "XvChromaMin", 0, 0xffffff);
             }
	     if(xf86GetOptValInteger(pSiS->Options, OPTION_XVCHROMAMAX, &tmp)) {
                if((tmp >= 0) && (tmp <= 0xffffff)) pSiS->XvChromaMax = tmp;
                else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       	                   "XvChromaMax", 0, 0xffffff);
             }
          }
	  if(xf86GetOptValBool(pSiS->Options, OPTION_XVMEMCPY, &val)) {
	     pSiS->XvUseMemcpy = val ? TRUE : FALSE;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Xv will %suse memcpy()\n",
	     	val ? "" : "not ");
          }
	  /* XvGamma - enable/disable gamma correction for Xv
	   * Supported for CRT1 only
           */
          if(pSiS->VGAEngine == SIS_315_VGA) {
	     if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_XVGAMMA))) {
                if( (!xf86NameCmp(strptr,"off"))   ||
	            (!xf86NameCmp(strptr,"false")) ||
		    (!xf86NameCmp(strptr,"no"))    ||
		    (!xf86NameCmp(strptr,"0")) ) {
		   pSiS->XvGamma = FALSE;
		   pSiS->XvGammaGiven = TRUE;
	        } else if( (!xf86NameCmp(strptr,"on"))   ||
	                   (!xf86NameCmp(strptr,"true")) ||
		           (!xf86NameCmp(strptr,"yes"))  ||
		           (!xf86NameCmp(strptr,"1")) ) {
		   pSiS->XvGamma = pSiS->XvGammaGiven = TRUE;
                } else {
	           float val1 = 0.0, val2 = 0.0, val3 = 0.0;
		   Bool valid = FALSE;
	           int result = sscanf(strptr, "%f %f %f", &val1, &val2, &val3);
		   if(result == 1) {
		      if((val1 >= 0.1) && (val1 <= 10.0)) {
		         pSiS->XvGammaGreen = pSiS->XvGammaBlue = pSiS->XvGammaRed =
			    pSiS->XvGammaGreenDef = pSiS->XvGammaBlueDef = pSiS->XvGammaRedDef = (int)(val1 * 1000);
		         valid = TRUE;
		      }
		   } else if(result == 3) {
		      if((val1 >= 0.1) && (val1 <= 10.0) &&
		         (val2 >= 0.1) && (val2 <= 10.0) &&
		         (val3 >= 0.1) && (val3 <= 10.0)) {
		         pSiS->XvGammaRed = pSiS->XvGammaRedDef = (int)(val1 * 1000);
		         pSiS->XvGammaGreen = pSiS->XvGammaGreenDef = (int)(val2 * 1000);
		         pSiS->XvGammaBlue = pSiS->XvGammaBlueDef = (int)(val3 * 1000);
			 valid = TRUE;
		      }
		   }
		   if(valid) {
		      pSiS->XvGamma = pSiS->XvGammaGiven = TRUE;
		   } else {
		      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		         "XvGamma expects either a boolean, or 1 or 3 real numbers (0.1 - 10.0)\n");
		   }
	        }
             }
          }
       }
d226 13
a238 50

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_STOREDBRI))) {
          float val1 = 0.0, val2 = 0.0, val3 = 0.0;
	  Bool valid = FALSE;
	  int result = sscanf(strptr, "%f %f %f", &val1, &val2, &val3);
	  if(result == 1) {
	     if((val1 >= 0.1) && (val1 <= 10.0)) {
	        valid = TRUE;
		pSiS->GammaBriR = pSiS->GammaBriG = pSiS->GammaBriB = (int)(val1 * 1000);
	     }
	  } else if(result == 3) {
	     if((val1 >= 0.1) && (val1 <= 10.0) &&
	        (val2 >= 0.1) && (val2 <= 10.0) &&
		(val3 >= 0.1) && (val3 <= 10.0)) {
		valid = TRUE;
		pSiS->GammaBriR = (int)(val1 * 1000);
		pSiS->GammaBriG = (int)(val2 * 1000);
		pSiS->GammaBriB = (int)(val3 * 1000);
	     }
	  }
	  if(!valid) {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"StoredGammaBrightness expects 1 or 3 real numbers (0.1 - 10.0)\n");
	  }
       }
       if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_STOREDPBRI))) {
          float val1 = 0.0, val2 = 0.0, val3 = 0.0;
	  Bool valid = FALSE;
	  int result = sscanf(strptr, "%f %f %f", &val1, &val2, &val3);
	  if(result == 1) {
	     if((val1 >= 0.1) && (val1 <= 10.0)) {
	        valid = TRUE;
		pSiS->GammaPBriR = pSiS->GammaPBriG = pSiS->GammaPBriB = (int)(val1 * 1000);
	     }
	  } else if(result == 3) {
	     if((val1 >= 0.1) && (val1 <= 10.0) &&
	        (val2 >= 0.1) && (val2 <= 10.0) &&
		(val3 >= 0.1) && (val3 <= 10.0)) {
		valid = TRUE;
		pSiS->GammaPBriR = (int)(val1 * 1000);
		pSiS->GammaPBriG = (int)(val2 * 1000);
		pSiS->GammaPBriB = (int)(val3 * 1000);
	     }
	  }
	  if(!valid) {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"\"StoredGammaPreBrightness\" expects 1 or 3 real numbers (0.1 - 10.0)\n");
	  }
       }
a239 1

@


1.1.9.2
log
@Import XFree86 4.4 from The XFree86(TM) Project, Inc.
(integrity cannot be checked)

got via cvs -qd anoncvs@@anoncvs.xfree86.org:/cvs co -Prxf-4_4_0 xc
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_opt.c,v 1.57 2004/02/25 17:45:13 twini Exp $ */
d15 4
a18 1
 * 3) The name of the author may not be used to endorse or promote products
a70 3
    OPTION_PDCA,
    OPTION_PDCS,
    OPTION_PDCAS,
a109 1
    OPTION_SENSEYPBPR,
a126 1
    OPTION_CENTERLCD,
a174 3
    { OPTION_PDCA,               	"PanelDelayCompensation1",OPTV_INTEGER,   {0}, -1    },
    { OPTION_PDCS,               	"PDC", 			  OPTV_INTEGER,   {0}, -1    },
    { OPTION_PDCAS,               	"PDC1",			  OPTV_INTEGER,   {0}, -1    },
a215 1
    { OPTION_SENSEYPBPR,		"SenseYPbPr",   	  OPTV_BOOLEAN,   {0}, -1    },
a234 1
    { OPTION_CENTERLCD,			"CenterLCD",	   	  OPTV_BOOLEAN,   {0}, -1    },
a306 1
    pSiS->PDCA = -1;
a341 1
    pSiS->SenseYPbPr = TRUE;
a363 1
    pSiS->CenterLCD = -1;
a744 3
       if(xf86GetOptValBool(pSiS->Options, OPTION_SENSEYPBPR, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "SenseYPbPr");
       }
d757 2
a758 10
        if(xf86GetOptValBool(pSiS->Options, OPTION_CENTERLCD, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "CenterLCD");
       }
       if((xf86GetOptValInteger(pSiS->Options, OPTION_PDC, &vali)) ||
          (xf86GetOptValInteger(pSiS->Options, OPTION_PDCS, &vali))) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "PanelDelayCompensation (PDC)");
       }
       if((xf86GetOptValInteger(pSiS->Options, OPTION_PDCA, &vali)) ||
          (xf86GetOptValInteger(pSiS->Options, OPTION_PDCAS, &vali))) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "PanelDelayCompensation1 (PDC1)");
a937 12
	  /* SenseYPbPr (315/330 series only)
           * If set to true, the driver will sense for YPbPr TV. This is
	   * inconvenient for folks connecting SVideo and CVBS at the same
	   * time, because this condition will be detected as YPbPr (since
	   * the TV output pins are shared). "False" will not sense for
	   * YPbPr and detect SVideo or CVBS only.
           */
          if(xf86GetOptValBool(pSiS->Options, OPTION_SENSEYPBPR, &val)) {
             if(val) pSiS->SenseYPbPr = TRUE;
	     else    pSiS->SenseYPbPr = FALSE;
          }

d984 1
a984 2
 	     else if( (!xf86NameCmp(strptr,"SVIDEO")) ||
	     	      (!xf86NameCmp(strptr,"SVHS")) ) {
d987 1
a987 2
             } else if( (!xf86NameCmp(strptr,"COMPOSITE")) ||
	     		(!xf86NameCmp(strptr,"CVBS")) ) {
a1140 15
	 /* CenterLCD (300/315/330 + SiS video bridge only)
          * If LCD shall not be scaled, this selects whether 1:1 data
	  * will be sent to the output, or the image shall be centered
	  * on the LCD. For LVDS panels, screen will always be centered,
	  * since these have no built-in scaler. For TMDS, this is
	  * selectable. Non-centered means that the driver will pass
	  * 1:1 data to the output and that the panel will have to
	  * scale by itself (if supported by the panel).
          */
	  if(xf86GetOptValBool(pSiS->Options, OPTION_CENTERLCD, &val)) {
	     pSiS->CenterLCD = val ? 1 : 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Non-scaled LCD output will %sbe centered\n",
	         pSiS->CenterLCD ? "not " : "");
	  }

d1142 1
a1142 2
          * This might be required if the LCD panel shows "small waves"
	  * or wrong colors.
d1150 1
a1150 2
	  * be within the mask 0x3c. For 661 and later, if must be
	  * within the range of 0 to 31.
d1152 1
a1152 6
	  {
	  int val = -1;
          xf86GetOptValInteger(pSiS->Options, OPTION_PDC, &val);
	  xf86GetOptValInteger(pSiS->Options, OPTION_PDCS, &val);
	  if(val != -1) {
	     pSiS->PDC = val;
a1157 1
	        if(pSiS->VGAEngine == SIS_315_VGA) pSiS->PDC &= 0x1f;
d1159 1
a1159 1
                    "Panel delay compensation shall be %d (for LCD=CRT2)\n",
a1162 22

	 /* PanelDelayCompensation1 (315 series only)
          * Same as above, but for LCD-via-CRT1 ("LCDA")
          */
	  if(pSiS->VGAEngine == SIS_315_VGA) {
	     val = -1;
             xf86GetOptValInteger(pSiS->Options, OPTION_PDCA, &val);
	     xf86GetOptValInteger(pSiS->Options, OPTION_PDCAS, &val);
	     if(val != -1) {
	        pSiS->PDCA = val;
	        if(pSiS->PDCA > 0x1f) {
	           xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	                "Illegal PanelDelayCompensation1 (PDC1) parameter (0 <= PDC1 <= 31\n");
	           pSiS->PDCA = -1;
	        } else {
                   xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                       	"Panel delay compensation shall be %d (for LCD=CRT1)\n",
	                pSiS->PDCA);
	        }
	     }
	  }
	  }
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 28
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_opt.c,v 1.15 2003/02/04 02:44:29 dawes Exp $ */
/*
 *
 * SiS driver option evaluation
 *
 * Parts Copyright 2001, 2002 by Thomas Winischhofer, Vienna, Austria
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of the supplier not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  The supplier makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
 *
 * THE SUPPLIER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Authors:  	?
 *		Thomas Winischhofer <thomas@@winischhofer.net>
 */
a4 2
#include "xf86str.h"
#include "xf86Cursor.h"
d11 2
a12 1
/*  OPTION_PCI_RETRY,  */
d16 1
a16 2
    OPTION_NOHOSTBUS,
/*  OPTION_SET_MEMCLOCK,   */
d18 1
a18 1
    OPTION_SHADOW_FB,
d20 1
a20 1
    OPTION_NOXVIDEO,
d22 1
a22 34
    OPTION_MAXXFBMEM,
    OPTION_FORCECRT1,
    OPTION_DSTN,
    OPTION_XVONCRT2,
    OPTION_PDC,
    OPTION_TVSTANDARD,
    OPTION_USEROMDATA,
    OPTION_NOINTERNALMODES,
    OPTION_USEOEM,
    OPTION_SBIOSN,
    OPTION_NOYV12,
    OPTION_CHTVOVERSCAN,
    OPTION_CHTVSOVERSCAN,
    OPTION_CHTVLUMABANDWIDTHCVBS,
    OPTION_CHTVLUMABANDWIDTHSVIDEO,
    OPTION_CHTVLUMAFLICKERFILTER,
    OPTION_CHTVCHROMABANDWIDTH,
    OPTION_CHTVCHROMAFLICKERFILTER,
    OPTION_CHTVCVBSCOLOR,
    OPTION_CHTVTEXTENHANCE,
    OPTION_CHTVCONTRAST,
    OPTION_SISTVEDGEENHANCE,
    OPTION_SISTVANTIFLICKER,
    OPTION_SISTVSATURATION,
    OPTION_TVXPOSOFFSET,
    OPTION_TVYPOSOFFSET,
    OPTION_SIS6326ANTIFLICKER,
    OPTION_SIS6326ENABLEYFILTER,
    OPTION_SIS6326YFILTERSTRONG,
    OPTION_CHTVTYPE,
    OPTION_USERGBCURSOR,
    OPTION_USERGBCURSORBLEND,
    OPTION_USERGBCURSORBLENDTH,
    OPTION_RESTOREBYSET
d26 15
a40 48
    { OPTION_SW_CURSOR,         "SWcursor",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_HW_CURSOR,         "HWcursor",               OPTV_BOOLEAN,   {0}, FALSE },
/*  { OPTION_PCI_RETRY,         "PciRetry",               OPTV_BOOLEAN,   {0}, FALSE },  */
    { OPTION_NOACCEL,           "NoAccel",                OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_TURBOQUEUE,        "TurboQueue",             OPTV_BOOLEAN,   {0}, FALSE },
/*  { OPTION_SET_MEMCLOCK,      "SetMClk",                OPTV_FREQ,      {0}, -1    },  */
    { OPTION_FAST_VRAM,         "FastVram",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_NOHOSTBUS,         "NoHostBus",              OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_FORCE_CRT2TYPE,    "ForceCRT2Type",          OPTV_ANYSTR,    {0}, FALSE },
    { OPTION_SHADOW_FB,         "ShadowFB",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_ROTATE,            "Rotate",                 OPTV_ANYSTR,    {0}, FALSE },
    { OPTION_NOXVIDEO,          "NoXvideo",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_VESA,		"Vesa",		          OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_MAXXFBMEM,         "MaxXFBMem",              OPTV_INTEGER,   {0}, -1    },
    { OPTION_FORCECRT1,         "ForceCRT1",              OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_DSTN,              "DSTN",                   OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_XVONCRT2,          "XvOnCRT2",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_PDC,               "PanelDelayCompensation", OPTV_INTEGER,   {0}, -1    },
    { OPTION_TVSTANDARD,        "TVStandard",             OPTV_STRING,    {0}, -1    },
    { OPTION_USEROMDATA,	"UseROMData",	          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_NOINTERNALMODES,   "NoInternalModes",        OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_USEOEM, 		"UseOEMData",		  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_SBIOSN,            "BIOSFile",               OPTV_STRING,    {0}, FALSE },
    { OPTION_NOYV12, 		"NoYV12",		  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVTYPE,		"CHTVType",	          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVOVERSCAN,	"CHTVOverscan",	          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVSOVERSCAN,	"CHTVSuperOverscan",      OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVLUMABANDWIDTHCVBS,	"CHTVLumaBandwidthCVBS",  OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVLUMABANDWIDTHSVIDEO,	"CHTVLumaBandwidthSVIDEO",OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVLUMAFLICKERFILTER,	"CHTVLumaFlickerFilter",  OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVCHROMABANDWIDTH,	"CHTVChromaBandwidth",    OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVCHROMAFLICKERFILTER,	"CHTVChromaFlickerFilter",OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVCVBSCOLOR,	"CHTVCVBSColor",          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVTEXTENHANCE,	"CHTVTextEnhance",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVCONTRAST,	"CHTVContrast",		  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVEDGEENHANCE,	"SISTVEdgeEnhance",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVANTIFLICKER,	"SISTVAntiFlicker",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVSATURATION,	"SISTVSaturation",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_TVXPOSOFFSET,	"TVXPosOffset", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_TVYPOSOFFSET,	"TVYPosOffset", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SIS6326ANTIFLICKER,	"SIS6326TVAntiFlicker",   OPTV_STRING,    {0}, FALSE  },
    { OPTION_SIS6326ENABLEYFILTER,	"SIS6326TVEnableYFilter", OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_SIS6326YFILTERSTRONG,	"SIS6326TVYFilterStrong", OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_USERGBCURSOR, 	"UseColorHWCursor",	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_USERGBCURSORBLEND,	"ColorHWCursorBlending",  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_USERGBCURSORBLENDTH,	"ColorHWCursorBlendThreshold", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_RESTOREBYSET,	"RestoreBySetMode", 	  OPTV_BOOLEAN,   {0}, -1    },
    { -1,                       NULL,                     OPTV_NONE,      {0}, FALSE }
d43 3
d49 4
a52 4
    SISPtr      pSiS = SISPTR(pScrn);
    MessageType from;
/*  double      temp;  */
    char        *strptr;
a59 1

a60 1

d64 2
a65 3
    pSiS->newFastVram = -1;	/* TW: Default: write only; if set, read + write */
    pSiS->NoHostBus = FALSE;
/*  pSiS->UsePCIRetry = TRUE; */
d73 17
a89 45
    pSiS->forceCRT1 = -1;
    pSiS->DSTN = FALSE;      /* TW: For using 550 FSTN/DSTN registers */
    pSiS->XvOnCRT2 = FALSE;  /* TW: For chipsets with only one overlay */
    pSiS->NoYV12 = -1;
    pSiS->PDC = -1;          /* TW: Panel Delay Compensation for 300 (and 310/325) series */
    pSiS->OptTVStand = -1;
    pSiS->OptROMUsage = -1;
    pSiS->noInternalModes = FALSE;
    pSiS->OptUseOEM = -1;
    pSiS->OptTVOver = -1;
    pSiS->OptTVSOver = -1;
    pSiS->chtvlumabandwidthcvbs = -1;	/* TW: Chrontel TV settings */
    pSiS->chtvlumabandwidthsvideo = -1;
    pSiS->chtvlumaflickerfilter = -1;
    pSiS->chtvchromabandwidth = -1;
    pSiS->chtvchromaflickerfilter = -1;
    pSiS->chtvcvbscolor = -1;
    pSiS->chtvtextenhance = -1;
    pSiS->chtvcontrast = -1;
    pSiS->sistvedgeenhance = -1;	/* TW: SiS30x TV settings */
    pSiS->sistvantiflicker = -1;
    pSiS->sistvsaturation = -1;
    pSiS->sis6326antiflicker = -1;	/* TW: SiS6326 TV settings */
    pSiS->sis6326enableyfilter = -1;
    pSiS->sis6326yfilterstrong = -1;
    pSiS->tvxpos = 0;			/* TW: Some day hopefully general TV settings */
    pSiS->tvypos = 0;
    pSiS->NonDefaultPAL = -1;
    pSiS->chtvtype = -1;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)    
    pSiS->OptUseColorCursor = 0;
#else
    if(pSiS->VGAEngine == SIS_300_VGA) {
    	pSiS->OptUseColorCursor = 0;
	pSiS->OptUseColorCursorBlend = 1;
	pSiS->OptColorCursorBlendThreshold = 0x37000000;
    } else if(pSiS->VGAEngine == SIS_315_VGA) {
    	pSiS->OptUseColorCursor = 1;
    }
#endif    
    pSiS->restorebyset = 0;

    if(pSiS->Chipset == PCI_CHIP_SIS530) {
    	 /* TW: TQ still broken on 530/620? */
	 pSiS->TurboQueue = FALSE;
d91 1
d95 1
a95 1
    if(xf86GetOptValBool(pSiS->Options, OPTION_HW_CURSOR, &pSiS->HWCursor)) {
d98 1
a98 1
    if(xf86ReturnOptValBool(pSiS->Options, OPTION_SW_CURSOR, FALSE)) {
a100 1
	pSiS->OptUseColorCursor = 0;
d102 1
a102 1
    xf86DrvMsg(pScrn->scrnIndex, from, "Using %s cursor\n",
a103 47
				
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,2,99,0,0)
#ifdef ARGB_CURSOR
#ifdef SIS_ARGB_CURSOR		
    if((pSiS->HWCursor) && ((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA))) {
       from = X_DEFAULT;
       if(xf86GetOptValBool(pSiS->Options, OPTION_USERGBCURSOR, &pSiS->OptUseColorCursor)) {
    	   from = X_CONFIG;
       }
       xf86DrvMsg(pScrn->scrnIndex, from, "Color HW cursor is %s\n",
                    pSiS->OptUseColorCursor ? "enabled" : "disabled");
		    
       if(pSiS->VGAEngine == SIS_300_VGA) {
          from = X_DEFAULT;
          if(xf86GetOptValBool(pSiS->Options, OPTION_USERGBCURSORBLEND, &pSiS->OptUseColorCursorBlend)) {
    	     from = X_CONFIG;
          }
          if(pSiS->OptUseColorCursor) {
             xf86DrvMsg(pScrn->scrnIndex, from,
	   	"HW cursor color blending emulation is %s\n",
		(pSiS->OptUseColorCursorBlend) ? "enabled" : "disabled");
	  }
	  { 
	  int temp;
	  from = X_DEFAULT;
	  if(xf86GetOptValInteger(pSiS->Options, OPTION_USERGBCURSORBLENDTH, &temp)) {
	     if((temp >= 0) && (temp <= 255)) {
	        from = X_CONFIG;
		pSiS->OptColorCursorBlendThreshold = (temp << 24);
	     } else {
	        temp = pSiS->OptColorCursorBlendThreshold >> 24;
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Illegal color HW cursor blending threshold, valid range 0-255\n");
	     }
	  }
	  if(pSiS->OptUseColorCursor) {
	     if(pSiS->OptUseColorCursorBlend) {
	        xf86DrvMsg(pScrn->scrnIndex, from,
	          "HW cursor color blending emulation threshold is %d\n", temp);
 	     }
	  }
	  }
       }
    }
#endif
#endif
#endif
d106 1
a106 1
    if(xf86ReturnOptValBool(pSiS->Options, OPTION_NOACCEL, FALSE)) {
d108 1
a108 2
	pSiS->NoXvideo = TRUE;
        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Acceleration and Xv disabled\n");
d111 1
a111 2
#if 0
    /* PCI retry - TW: What the heck is/was this for? */
d113 1
a113 1
    if(xf86GetOptValBool(pSiS->Options, OPTION_PCI_RETRY, &pSiS->UsePCIRetry)) {
a117 1
#endif
d120 1
a120 2
#if 0  /* TW: This is not used */
    if(xf86GetOptValFreq(pSiS->Options, OPTION_SET_MEMCLOCK, OPTUNITS_MHZ,
d123 1
a123 1
        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
a125 1
#endif
d127 12
a138 30
    /* Fast VRAM (not for 300/310/325 series) */
    if((pSiS->VGAEngine != SIS_300_VGA) && (pSiS->VGAEngine != SIS_315_VGA)) {
       from = X_DEFAULT;
       if(xf86GetOptValBool(pSiS->Options, OPTION_FAST_VRAM, &pSiS->newFastVram)) {
          from = X_CONFIG;
       }
       xf86DrvMsg(pScrn->scrnIndex, from, "Fast VRAM %s\n",
                   (pSiS->newFastVram == -1) ? "enabled (for write only)" :
		   	(pSiS->newFastVram ? "enabled (for read and write)" : "disabled"));
    }

    /* NoHostBus (5597/5598 only) */
    if((pSiS->Chipset == PCI_CHIP_SIS5597)) {
       from = X_DEFAULT;
       if(xf86GetOptValBool(pSiS->Options, OPTION_NOHOSTBUS, &pSiS->NoHostBus)) {
          from = X_CONFIG;
       }
       xf86DrvMsg(pScrn->scrnIndex, from, "SiS5597/5598 VGA-to-CPU host bus %s\n",
                   pSiS->NoHostBus ? "disabled" : "enabled");
    }

    if(pSiS->VGAEngine != SIS_315_VGA) {
       /* Turbo QUEUE */
       /* (TW: We always use this on 310/325 series) */
       from = X_DEFAULT;
       if(xf86GetOptValBool(pSiS->Options, OPTION_TURBOQUEUE, &pSiS->TurboQueue)) {
    	   from = X_CONFIG;
       }
       xf86DrvMsg(pScrn->scrnIndex, from, "TurboQueue %s\n",
                    pSiS->TurboQueue ? "enabled" : "disabled");
d140 2
d143 1
a143 3
    /* Force CRT2 type (300/310/325 series only)
       TW: SVIDEO, COMPOSITE and SCART for overriding detection
     */
d145 4
a148 7
    pSiS->ForceTVType = -1;
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
      strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT2TYPE);
      if(strptr != NULL) {
        if((!strcmp(strptr,"TV")) || (!strcmp(strptr,"tv")))
            pSiS->ForceCRT2Type = CRT2_TV;
 	else if((!strcmp(strptr,"SVIDEO")) || (!strcmp(strptr,"svideo"))) {
d150 1
a150 8
	    pSiS->ForceTVType = TV_SVIDEO;
        } else if((!strcmp(strptr,"COMPOSITE")) || (!strcmp(strptr,"composite"))) {
            pSiS->ForceCRT2Type = CRT2_TV;
	    pSiS->ForceTVType = TV_AVIDEO;
        } else if((!strcmp(strptr,"SCART")) || (!strcmp(strptr,"scart"))) {
            pSiS->ForceCRT2Type = CRT2_TV;
	    pSiS->ForceTVType = TV_SCART;
        } else if((!strcmp(strptr,"LCD")) || (!strcmp(strptr,"lcd")))
d152 1
a152 3
        else if((!strcmp(strptr,"DVI")) || (!strcmp(strptr,"dvi")))
            pSiS->ForceCRT2Type = CRT2_LCD;	    
        else if((!strcmp(strptr,"VGA")) || (!strcmp(strptr,"vga")))
d154 1
a154 1
        else if((!strcmp(strptr,"NONE")) || (!strcmp(strptr,"none")))
a155 6
	else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    	"\"%s\" is not a valid parameter for Option \"ForceCRT2Type\"\n", strptr);
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	        "Valid parameters are \"LCD\" (alias \"DVI\"), \"TV\", \"SVIDEO\", \"COMPOSITE\", \"SCART\", \"VGA\" or \"NONE\"\n");
	}
d157 1
a157 17
        if(pSiS->ForceCRT2Type != CRT2_DEFAULT)
            xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "CRT2 type shall be %s\n", strptr);
      }
      strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CHTVTYPE);
      if(strptr != NULL) {
        if((!strcmp(strptr,"SCART")) || (!strcmp(strptr,"scart")))
            pSiS->chtvtype = 1;
 	else if((!strcmp(strptr,"HDTV")) || (!strcmp(strptr,"hdtv")))
	    pSiS->chtvtype = 0;
	else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    	"\"%s\" is not a valid parameter for Option \"CHTVType\"\n", strptr);
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	        "Valid parameters are \"SCART\" or \"HDTV\"\n");
	}
        if(pSiS->chtvtype != -1)
d159 1
a159 2
                    "Chrontel TV type shall be %s\n", strptr);
      }
d164 1
a164 1
    if(xf86GetOptValBool(pSiS->Options, OPTION_SHADOW_FB, &pSiS->ShadowFB)) {
d167 5
a171 6
    if(pSiS->ShadowFB) {
	pSiS->NoAccel = TRUE;
	pSiS->NoXvideo = TRUE;
    	xf86DrvMsg(pScrn->scrnIndex, from,
	   "Using \"Shadow Frame Buffer\" - acceleration and Xv disabled\n");
    }
d174 1
a174 1
    if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_ROTATE))) {
a177 1
	    pSiS->NoXvideo = TRUE;
d181 1
a181 1
                    "Rotating screen clockwise (acceleration and Xv disabled)\n");
d183 1
a183 1
        if(!xf86NameCmp(strptr, "CCW")) {
a185 1
            pSiS->NoXvideo = TRUE;
d189 1
a189 1
                    "Rotating screen counter clockwise (acceleration and Xv disabled)\n");
d191 2
a192 2
            xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                    "\"%s\" is not a valid parameter for Option \"Rotate\"\n", strptr);
d194 1
a194 1
                    "Valid parameters are \"CW\" or \"CCW\"\n");
d197 3
a199 19
    
    /* RestoreBySetMode */
    /* TW: Set this to force the driver to set the old mode instead of restoring
     *     the register contents. This can be used to overcome problems with
     *     LCD panels and video bridges.
     */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       Bool val;
       if(xf86GetOptValBool(pSiS->Options, OPTION_RESTOREBYSET, &val)) {
          if(val) pSiS->restorebyset = TRUE;
	  else    pSiS->restorebyset = FALSE;
       }
    }
    
    /* NOXvideo:
     * Set this to TRUE to disable Xv hardware video acceleration
     */
    if(!pSiS->NoAccel) {
      if(xf86ReturnOptValBool(pSiS->Options, OPTION_NOXVIDEO, FALSE)) {
d201 1
a201 33
        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "XVideo extension disabled\n");
      }

      if(!pSiS->NoXvideo) {
        Bool val;
        if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
      	  /* TW: XvOnCRT2:
	   * On chipsets with only one overlay (315, 650), the user should
	   * choose to display the overlay on CRT1 or CRT2. By setting this
	   * option to TRUE, the overlay will be displayed on CRT2. The
	   * default is: CRT1 if only CRT1 available, CRT2 if only CRT2
	   * available, and CRT1 if both is available and detected.
	   */
          if(xf86GetOptValBool(pSiS->Options, OPTION_XVONCRT2, &val)) {
	        if(val) pSiS->XvOnCRT2 = TRUE;
	        else    pSiS->XvOnCRT2 = FALSE;
	  }
	}
	if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
	  /* TW: NoYV12 (for 5597/5598, 6326 and 530/620 only)
	   *     YV12 has problems with videos larger than 384x288. So
	   *     allow the user to disable YV12 support to force the
	   *     application to use YUV2 instead.
	   */
          if(xf86GetOptValBool(pSiS->Options, OPTION_NOYV12, &val)) {
	        if(val)  pSiS->NoYV12 = 1;
	        else     pSiS->NoYV12 = 0;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			"Xv YV12/I420 support is %s\n",
			pSiS->NoYV12 ? "disabled" : "enabled");
	  }
	}
      }
d204 8
a211 3
    /* TW: VESA - DEPRECATED
     * This option is for forcing the driver to use
     * the VESA BIOS extension for mode switching.
d215 6
d222 1
a222 5
	if(xf86GetOptValBool(pSiS->Options, OPTION_VESA, &val)) {
	    if(val)  pSiS->VESA = 1;
	    else     pSiS->VESA = 0;

	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "VESA: VESA usage shall be %s\n",
d226 1
a226 3

   /* TW: MaxXFBMem
    * With the option "MaxXFBMem" you can limit the amount of video memory X
d229 2
a230 3
    * start its memory heap at 12MB if it detects more than 16MB, at 8MB if
    * between 8 and 16MB are available, otherwise at 4MB. So, if you limit
    * the amount of memory X uses, you avoid a clash between the framebuffer
d234 1
a234 1
    if(xf86GetOptValULong(pSiS->Options, OPTION_MAXXFBMEM,
d237 1
a237 2
                    "MaxXFBMem: Framebuffer memory shall be limited to %d KB\n",
		    pSiS->maxxfbmem);
a238 252
    }

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       /* TW: ForceCRT1 (300/310/325 series only)
        * This option can be used to force CRT1 to be switched on/off. Its
        * intention is mainly for old monitors that can't be detected
        * automatically. This is only useful on machines with a video bridge.
        * In normal cases, this option won't be necessary.
        */
	Bool val;
	if(xf86GetOptValBool(pSiS->Options, OPTION_FORCECRT1, &val)) {
	    if(val)  pSiS->forceCRT1 = 1;
	    else     pSiS->forceCRT1 = 0;

	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "CRT1 shall be forced to %s\n",
		       val ? "ON" : "OFF");
	}
    }

    if(pSiS->Chipset == PCI_CHIP_SIS550) {
      /* TW: SiS 550 DSTN/FSTN
       *     This is for notifying the driver to use the DSTN registers on 550.
       *     DSTN/FSTN is a special LCD port of the SiS550 (notably not the 551
       *     and 552, which I don't know how to detect) that uses an extended
       *     register range. The only effect of this option is that the driver
       *     saves and restores these registers. DSTN display modes are chosen
       *     by using resultion 320x480x8 or 320x480x16.
       */
      if(xf86ReturnOptValBool(pSiS->Options, OPTION_DSTN, FALSE)) {
        pSiS->DSTN = TRUE;
        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "SiS 550 DSTN/FSTN enabled\n");
      } else {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "SiS 550 DSTN/FSTN disabled\n");
      }
    }

    /* TW: PanelDelayCompensation (300/310/325 series only)
     *     This might be required if the LCD panel shows "small waves".
     *     The parameter is an integer, usually either 4, 32 or 24.
     *     Why this option? Simply because SiS did poor BIOS design.
     *     The PDC value depends on the very LCD panel used in a
     *     particular machine. For most panels, the driver is able
     *     to detect the correct value. However, some panels require
     *     a different setting. The value given must be within the mask 0x3c.
     */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
        if(xf86GetOptValInteger(pSiS->Options, OPTION_PDC, &pSiS->PDC)) {
	    if(pSiS->PDC & ~0x3c) {
	       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	           "Illegal PanelDelayCompensation value\n");
	       pSiS->PDC = -1;
	    } else {
               xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "Panel delay compensation shall be %d\n",
		    pSiS->PDC);
	    }
        }
    }

    /* TW: TVStandard (300/310/325 series and 6326 w/ TV only)
     * This option is for overriding the autodetection of
     * the BIOS option for PAL / NTSC
     */
    if((pSiS->VGAEngine == SIS_300_VGA) ||
       (pSiS->VGAEngine == SIS_315_VGA) ||
       ((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV))) {
       strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_TVSTANDARD);
       if(strptr != NULL) {
          if((!strcmp(strptr,"PAL")) || (!strcmp(strptr,"pal")))
	     pSiS->OptTVStand = 1;
	  else if((!strcmp(strptr,"PALM")) || (!strcmp(strptr,"palm"))) {
	     pSiS->OptTVStand = 1;
	     pSiS->NonDefaultPAL = 1;
  	  } else if((!strcmp(strptr,"PALN")) || (!strcmp(strptr,"paln"))) {
	     pSiS->OptTVStand = 1;
	     pSiS->NonDefaultPAL = 0;
  	  } else if((!strcmp(strptr,"NTSC")) || (!strcmp(strptr,"ntsc")))
	     pSiS->OptTVStand = 0;
	  else {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"\"%s\" is not a valid parameter for Option \"TVStandard\"\n", strptr);
             xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	        "Valid options are \"PAL\", \"PALM\", \"PALN\" or \"NTSC\"\n");
	  }

	  if(pSiS->OptTVStand != -1) {
	     if(pSiS->Chipset == PCI_CHIP_SIS6326) {
	         pSiS->NonDefaultPAL = -1;
	         xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "TV Standard shall be %s\n",
		       pSiS->OptTVStand ? "PAL" : "NTSC");
	     } else {
	         xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "TV Standard shall be %s\n",
		       (pSiS->OptTVStand ? 
		          ( (pSiS->NonDefaultPAL == -1) ? "PAL" : 
			      ((pSiS->NonDefaultPAL) ? "PALM" : "PALN") )
				           : "NTSC"));
	     }
	  }
        }
    }

    /* TW: TVOverscan (300/310/325 series only)
     * This option is for overriding the BIOS option for
     * TV Overscan. Some BIOS don't even have such an option.
     * This is only effective on LVDS+CHRONTEL 70xx systems.
     */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	Bool val;
	if(xf86GetOptValBool(pSiS->Options, OPTION_CHTVOVERSCAN, &val)) {
	    if(val) pSiS->OptTVOver = 1;
	    else    pSiS->OptTVOver = 0;

	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	               "Chrontel: TV overscan shall be %s\n",
		       val ? "enabled":"disabled");
	}
        if(xf86GetOptValBool(pSiS->Options, OPTION_CHTVSOVERSCAN, &pSiS->OptTVSOver)) {
	      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	               "Chrontel: TV super overscan shall be %s\n",
		       pSiS->OptTVSOver ? "enabled":"disabled");
	}
    }

    /* TW: UseROMData (300/310/325 series only)
     * This option is enabling/disabling usage of some machine
     * specific data from the BIOS ROM. This option can - and
     * should - be used in case the driver makes problems
     * because SiS changed the location of this data.
     * TW: NoOEM (300/310/325 series only)
     * The driver contains quite a lot data for OEM LCD panels
     * and TV connector specifics which override the defaults.
     * If this data is incorrect, the TV may lose color and
     * the LCD panel might show some strange effects. Use this
     * option to disable the usage of this data.
     */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	Bool val;
	if(xf86GetOptValBool(pSiS->Options, OPTION_USEROMDATA, &val)) {
	    if(val)  pSiS->OptROMUsage = 1;
	    else     pSiS->OptROMUsage = 0;

	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	               "Video ROM data usage shall be %s\n",
		       val ? "enabled":"disabled");
	}
	if(xf86GetOptValBool(pSiS->Options, OPTION_USEOEM, &val)) {
	    if(val)  pSiS->OptUseOEM = 1;
	    else     pSiS->OptUseOEM = 0;

	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	               "Internal LCD/TV OEM data usage shall be %s\n",
		       val ? "enabled":"disabled");
	}
	pSiS->sbiosn = NULL;
        strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SBIOSN);
        if(strptr != NULL) {
	   pSiS->sbiosn = xalloc(strlen(strptr)+1);
           if(pSiS->sbiosn) strcpy(pSiS->sbiosn, strptr);
        }
    }

    /* TW: NoInternalModes (300/310/325 series only)
     *     Since the mode switching code for these chipsets is a
     *     Asm-to-C translation of BIOS code, we only have timings
     *     for a pre-defined number of modes. The default behavior
     *     is to replace XFree's default modes with a mode list
     *     generated out of the known and supported modes. Use
     *     this option to disable this. However, even if using
     *     out built-in mode list will NOT make it possible to
     *     use modelines.
     */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
        from = X_DEFAULT;
	if(xf86GetOptValBool(pSiS->Options, OPTION_NOINTERNALMODES, &pSiS->noInternalModes))
		from = X_CONFIG;

	xf86DrvMsg(pScrn->scrnIndex, from, "Usage of built-in modes is %s\n",
		       pSiS->noInternalModes ? "disabled":"enabled");
    }

    /* TW: Various parameters for TV output via SiS bridge, Chrontel or SiS6326 */
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
        int tmp = 0;
        xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMABANDWIDTHCVBS,
                                &pSiS->chtvlumabandwidthcvbs);
	xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMABANDWIDTHSVIDEO,
                                &pSiS->chtvlumabandwidthsvideo);
	xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMAFLICKERFILTER,
                                &pSiS->chtvlumaflickerfilter);
	xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCHROMABANDWIDTH,
                                &pSiS->chtvchromabandwidth);
	xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCHROMAFLICKERFILTER,
                                &pSiS->chtvchromaflickerfilter);
	xf86GetOptValBool(pSiS->Options, OPTION_CHTVCVBSCOLOR,
				&pSiS->chtvcvbscolor);
	xf86GetOptValInteger(pSiS->Options, OPTION_CHTVTEXTENHANCE,
                                &pSiS->chtvtextenhance);
	xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCONTRAST,
                                &pSiS->chtvcontrast);
	xf86GetOptValInteger(pSiS->Options, OPTION_SISTVEDGEENHANCE,
                                &pSiS->sistvedgeenhance);
	xf86GetOptValInteger(pSiS->Options, OPTION_SISTVANTIFLICKER,
                                &pSiS->sistvantiflicker);
	xf86GetOptValInteger(pSiS->Options, OPTION_SISTVSATURATION,
                                &pSiS->sistvsaturation);
	xf86GetOptValInteger(pSiS->Options, OPTION_TVXPOSOFFSET,
                                &pSiS->tvxpos);
	xf86GetOptValInteger(pSiS->Options, OPTION_TVYPOSOFFSET,
                                &pSiS->tvypos);
	if(pSiS->tvxpos > 32)  { pSiS->tvxpos = 32;  tmp = 1; }
	if(pSiS->tvxpos < -32) { pSiS->tvxpos = -32; tmp = 1; }
	if(pSiS->tvypos > 32)  { pSiS->tvypos = 32;  tmp = 1; }
	if(pSiS->tvypos < -32) { pSiS->tvypos = -32;  tmp = 1; }
	if(tmp) xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		      "Illegal TV x or y offset. Range is from -32 to 32\n");
    }
    if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
        int tmp = 0;
        strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SIS6326ANTIFLICKER);
        if (strptr != NULL) {
          if((!strcmp(strptr,"OFF")) || (!strcmp(strptr,"off")))
	     pSiS->sis6326antiflicker = 0;
  	  else if((!strcmp(strptr,"LOW")) || (!strcmp(strptr,"low")))
	     pSiS->sis6326antiflicker = 1;
	  else if((!strcmp(strptr,"MED")) || (!strcmp(strptr,"med")))
	     pSiS->sis6326antiflicker = 2;
	  else if((!strcmp(strptr,"HIGH")) || (!strcmp(strptr,"high")))
	     pSiS->sis6326antiflicker = 3;
	  else if((!strcmp(strptr,"ADAPTIVE")) || (!strcmp(strptr,"adaptive")))
	     pSiS->sis6326antiflicker = 4;
	  else {
	     pSiS->sis6326antiflicker = -1;
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"\"%s\" is not a valid parameter for Option \"SIS6326TVAntiFlicker\"\n", strptr);
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	        "Valid parameters are \"OFF\", \"LOW\", \"MED\", \"HIGH\" or \"ADAPTIVE\"\n");
	  }
	}
	xf86GetOptValBool(pSiS->Options, OPTION_SIS6326ENABLEYFILTER,
                                &pSiS->sis6326enableyfilter);
	xf86GetOptValBool(pSiS->Options, OPTION_SIS6326YFILTERSTRONG,
                                &pSiS->sis6326yfilterstrong);
	xf86GetOptValInteger(pSiS->Options, OPTION_TVXPOSOFFSET,
                                &pSiS->tvxpos);
	xf86GetOptValInteger(pSiS->Options, OPTION_TVYPOSOFFSET,
                                &pSiS->tvypos);
	if(pSiS->tvxpos > 16)  { pSiS->tvxpos = 16;  tmp = 1; }
	if(pSiS->tvxpos < -16) { pSiS->tvxpos = -16; tmp = 1; }
	if(pSiS->tvypos > 16)  { pSiS->tvypos = 16;  tmp = 1; }
	if(pSiS->tvypos < -16) { pSiS->tvypos = -16;  tmp = 1; }
	if(tmp) xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		      "Illegal TV x or y offset. Range is from -16 to 16\n");
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_opt.c,v 1.55 2004/01/23 22:29:05 twini Exp $ */
d3 1
d6 1
a6 15
 * Copyright (C) 2001-2004 by Thomas Winischhofer, Vienna, Austria
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1) Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2) Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3) All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement: "This product includes
 *    software developed by Thomas Winischhofer, Vienna, Austria."
 * 4) The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d8 9
a16 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d18 7
a24 3
 * "NoAccel", "NoXVideo", "SWCursor", "HWCursor" and "Rotate" option portions
 * Copyright (C) 1999-2004 The XFree86 Project, Inc. Licensed under the terms
 * of the XFree86 license (http://www.xfree86.org/current/LICENSE1.html).
d26 2
a27 2
 * Authors:  	Thomas Winischhofer <thomas@@winischhofer.net>
 *              ?
a36 2
extern const customttable mycustomttable[];

d40 1
d45 1
a45 2
    OPTION_RENDER,
    OPTION_FORCE_CRT1TYPE,
a46 1
    OPTION_YPBPRAR,
a47 3
    OPTION_DRI,
    OPTION_AGP_SIZE,
    OPTION_AGP_SIZE2,
d53 1
a55 1
    OPTION_EMI,
d60 1
a74 4
    OPTION_SISTVCHROMAFILTER,
    OPTION_SISTVLUMAFILTER,
    OPTION_SISTVCOLCALIBFINE,
    OPTION_SISTVCOLCALIBCOARSE,
a76 2
    OPTION_TVXSCALE,
    OPTION_TVYSCALE,
a79 2
    OPTION_SIS6326FORCETVPPLUG,
    OPTION_SIS6326FSCADJUST,
d84 1
a84 44
    OPTION_RESTOREBYSET,
    OPTION_NODDCFORCRT2,
    OPTION_FORCECRT2REDETECTION,
    OPTION_CRT1GAMMA,
    OPTION_CRT2GAMMA,
    OPTION_XVGAMMA,
    OPTION_XVDEFCONTRAST,
    OPTION_XVDEFBRIGHTNESS,
    OPTION_XVDEFHUE,
    OPTION_XVDEFSATURATION,
    OPTION_XVDEFDISABLEGFX,
    OPTION_XVDEFDISABLEGFXLR,
    OPTION_XVMEMCPY,
    OPTION_XVUSECHROMAKEY,
    OPTION_XVCHROMAMIN,
    OPTION_XVCHROMAMAX,
    OPTION_XVDISABLECOLORKEY,
    OPTION_XVINSIDECHROMAKEY,
    OPTION_XVYUVCHROMAKEY,
    OPTION_SCALELCD,
    OPTION_SPECIALTIMING,
    OPTION_LVDSHL,
    OPTION_ENABLEHOTKEY,
    OPTION_MERGEDFB,
    OPTION_MERGEDFBAUTO,
    OPTION_CRT2HSYNC,
    OPTION_CRT2VREFRESH,
    OPTION_CRT2POS,
    OPTION_METAMODES,
    OPTION_MERGEDFB2,
    OPTION_CRT2HSYNC2,
    OPTION_CRT2VREFRESH2,
    OPTION_CRT2POS2,
    OPTION_NOSISXINERAMA,
    OPTION_NOSISXINERAMA2,
    OPTION_CRT2ISSCRN0,
    OPTION_MERGEDDPI,
    OPTION_ENABLESISCTRL,
    OPTION_STOREDBRI,
    OPTION_STOREDPBRI,
#ifdef SIS_CP
    SIS_CP_OPT_OPTIONS
#endif
    OPTION_PSEUDO
d88 27
a114 32
    { OPTION_SW_CURSOR,         	"SWcursor",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_HW_CURSOR,         	"HWcursor",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_NOACCEL,           	"NoAccel",                OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_TURBOQUEUE,        	"TurboQueue",             OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_FAST_VRAM,         	"FastVram",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_NOHOSTBUS,         	"NoHostBus",              OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_RENDER,        		"RenderAcceleration",     OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_FORCE_CRT1TYPE,    	"ForceCRT1Type",          OPTV_STRING,    {0}, FALSE },
    { OPTION_FORCE_CRT2TYPE,    	"ForceCRT2Type",          OPTV_STRING,    {0}, FALSE },
    { OPTION_YPBPRAR,  		  	"YPbPrAspectRatio",       OPTV_STRING,    {0}, FALSE },
    { OPTION_SHADOW_FB,         	"ShadowFB",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_DRI,         		"DRI",               	  OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_AGP_SIZE,			"AGPSize",      	  OPTV_INTEGER,   {0}, FALSE },
    { OPTION_AGP_SIZE2,			"GARTSize",      	  OPTV_INTEGER,   {0}, FALSE },
    { OPTION_ROTATE,            	"Rotate",                 OPTV_STRING,    {0}, FALSE },
    { OPTION_NOXVIDEO,          	"NoXvideo",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_VESA,			"Vesa",		          OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_MAXXFBMEM,         	"MaxXFBMem",              OPTV_INTEGER,   {0}, -1    },
    { OPTION_FORCECRT1,         	"ForceCRT1",              OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_XVONCRT2,          	"XvOnCRT2",               OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_PDC,               	"PanelDelayCompensation", OPTV_INTEGER,   {0}, -1    },
    { OPTION_EMI,               	"EMI", 			  OPTV_INTEGER,   {0}, -1    },
    { OPTION_LVDSHL,			"LVDSHL", 	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SPECIALTIMING,        	"SpecialTiming",          OPTV_STRING,    {0}, -1    },
    { OPTION_TVSTANDARD,        	"TVStandard",             OPTV_STRING,    {0}, -1    },
    { OPTION_USEROMDATA,		"UseROMData",	          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_NOINTERNALMODES,   	"NoInternalModes",        OPTV_BOOLEAN,   {0}, FALSE },
    { OPTION_USEOEM, 			"UseOEMData",		  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_NOYV12, 			"NoYV12",		  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVTYPE,			"CHTVType",	          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVOVERSCAN,		"CHTVOverscan",	          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVSOVERSCAN,		"CHTVSuperOverscan",      OPTV_BOOLEAN,   {0}, -1    },
d120 8
a127 14
    { OPTION_CHTVCVBSCOLOR,		"CHTVCVBSColor",          OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CHTVTEXTENHANCE,		"CHTVTextEnhance",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_CHTVCONTRAST,		"CHTVContrast",		  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVEDGEENHANCE,		"SISTVEdgeEnhance",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVANTIFLICKER,		"SISTVAntiFlicker",	  OPTV_STRING,    {0}, FALSE },
    { OPTION_SISTVSATURATION,		"SISTVSaturation",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVCHROMAFILTER,		"SISTVCFilter",      	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_SISTVLUMAFILTER,		"SISTVYFilter",	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVCOLCALIBFINE,		"SISTVColorCalibFine",	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_SISTVCOLCALIBCOARSE,	"SISTVColorCalibCoarse",  OPTV_INTEGER,   {0}, -1    },
    { OPTION_TVXSCALE,			"SISTVXScale", 	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_TVYSCALE,			"SISTVYScale", 	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_TVXPOSOFFSET,		"TVXPosOffset", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_TVYPOSOFFSET,		"TVYPosOffset", 	  OPTV_INTEGER,   {0}, -1    },
d131 5
a135 51
    { OPTION_SIS6326FORCETVPPLUG,	"SIS6326TVForcePlug",     OPTV_STRING,    {0}, -1    },
    { OPTION_SIS6326FSCADJUST,		"SIS6326FSCAdjust", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_USERGBCURSOR, 		"UseColorHWCursor",	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_USERGBCURSORBLEND,		"ColorHWCursorBlending",  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_USERGBCURSORBLENDTH,	"ColorHWCursorBlendThreshold", OPTV_INTEGER,{0},-1   },
    { OPTION_RESTOREBYSET,		"RestoreBySetMode", 	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_NODDCFORCRT2,		"NoCRT2Detection", 	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_FORCECRT2REDETECTION,	"ForceCRT2ReDetection",   OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CRT1GAMMA,			"CRT1Gamma", 	  	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_CRT2GAMMA,			"CRT2Gamma", 	  	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_STOREDBRI,			"StoredGammaBrightness",  OPTV_STRING,    {0}, -1    },
    { OPTION_STOREDPBRI,		"StoredGammaPreBrightness",OPTV_STRING,   {0}, -1    },
    { OPTION_XVGAMMA,			"XvGamma", 	  	  OPTV_STRING,    {0}, -1    },
    { OPTION_XVDEFCONTRAST,		"XvDefaultContrast", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVDEFBRIGHTNESS,		"XvDefaultBrightness", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVDEFHUE,			"XvDefaultHue", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVDEFSATURATION,		"XvDefaultSaturation", 	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVDEFDISABLEGFX,		"XvDefaultDisableGfx", 	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVDEFDISABLEGFXLR,		"XvDefaultDisableGfxLR",  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVCHROMAMIN,		"XvChromaMin", 	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVCHROMAMAX,		"XvChromaMax", 	  	  OPTV_INTEGER,   {0}, -1    },
    { OPTION_XVUSECHROMAKEY,		"XvUseChromaKey",         OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVINSIDECHROMAKEY,		"XvInsideChromaKey",      OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVYUVCHROMAKEY,		"XvYUVChromaKey",         OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVDISABLECOLORKEY,		"XvDisableColorKey",      OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_XVMEMCPY,			"XvUseMemcpy",  	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_SCALELCD,			"ScaleLCD",	   	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_ENABLEHOTKEY,		"EnableHotkey",	   	  OPTV_BOOLEAN,   {0}, -1    },
    { OPTION_ENABLESISCTRL,		"EnableSiSCtrl",   	  OPTV_BOOLEAN,   {0}, -1    },
#ifdef SISMERGED
    { OPTION_MERGEDFB,			"MergedFB",		  OPTV_BOOLEAN,	  {0}, FALSE },
    { OPTION_MERGEDFB2,			"TwinView",		  OPTV_BOOLEAN,	  {0}, FALSE },	  /* alias */
    { OPTION_MERGEDFBAUTO,		"MergedFBAuto",		  OPTV_BOOLEAN,	  {0}, FALSE },
    { OPTION_CRT2HSYNC,			"CRT2HSync",		  OPTV_STRING,	  {0}, FALSE },
    { OPTION_CRT2HSYNC2,		"SecondMonitorHorizSync", OPTV_STRING,	  {0}, FALSE },   /* alias */
    { OPTION_CRT2VREFRESH,		"CRT2VRefresh",		  OPTV_STRING,    {0}, FALSE },
    { OPTION_CRT2VREFRESH2,		"SecondMonitorVertRefresh", OPTV_STRING,  {0}, FALSE },   /* alias */
    { OPTION_CRT2POS,   		"CRT2Position",		  OPTV_STRING,	  {0}, FALSE },
    { OPTION_CRT2POS2,   		"TwinViewOrientation",	  OPTV_STRING,	  {0}, FALSE },   /* alias */
    { OPTION_METAMODES,   		"MetaModes",  		  OPTV_STRING,	  {0}, FALSE },
    { OPTION_MERGEDDPI,			"MergedDPI", 		  OPTV_STRING,	  {0}, FALSE },
#ifdef SISXINERAMA
    { OPTION_NOSISXINERAMA,		"NoMergedXinerama",	  OPTV_BOOLEAN,	  {0}, FALSE },
    { OPTION_NOSISXINERAMA2,		"NoTwinviewXineramaInfo", OPTV_BOOLEAN,   {0}, FALSE },   /* alias */
    { OPTION_CRT2ISSCRN0,		"MergedXineramaCRT2IsScreen0",OPTV_BOOLEAN,{0},FALSE },
#endif
#endif
#ifdef SIS_CP
    SIS_CP_OPTION_DETAIL
#endif
    { -1,                       	NULL,                     OPTV_NONE,      {0}, FALSE }
d143 1
a144 4
    static const char *mybadparm = "\"%s\" is is not a valid parameter for option \"%s\"\n";
    static const char *disabledstr = "disabled";
    static const char *enabledstr = "enabled";
    static const char *ilrangestr = "Illegal %s parameter. Valid range is %d through %d\n";
d150 2
a151 1
    if(!(pSiS->Options = xalloc(sizeof(SISOptions)))) return;
d157 2
a158 3
    /* Set defaults */
    
    pSiS->newFastVram = -1;
d160 1
a161 6
#ifdef SISVRAMQ
    /* TODO: Option (315 series VRAM command queue) */
    /* But beware: sisfb does not know about this!!! */
    pSiS->cmdQueueSize = 512*1024;
#endif
    pSiS->doRender = TRUE;
a164 2
    pSiS->loadDRI = FALSE;
    pSiS->agpWantedPages = AGP_PAGES;
d169 2
a170 3
    pSiS->DSTN = FALSE;
    pSiS->FSTN = FALSE;
    pSiS->XvOnCRT2 = FALSE;
d172 1
a172 2
    pSiS->PDC = -1;
    pSiS->EMI = -1;
d179 1
a179 1
    pSiS->chtvlumabandwidthcvbs = -1;
d187 1
a187 1
    pSiS->sistvedgeenhance = -1;
d190 1
a190 4
    pSiS->sistvcfilter = -1;
    pSiS->sistvyfilter = 1; /* 0 = off, 1 = default, 2-8 = filter no */
    pSiS->sistvcolcalibc = 0;
    pSiS->sistvcolcalibf = 0;
d193 1
a193 3
    pSiS->sis6326tvplug = -1;
    pSiS->sis6326fscadjust = 0;
    pSiS->tvxpos = 0;
d195 1
a195 3
    pSiS->tvxscale = 0;
    pSiS->tvyscale = 0;
    pSiS->NonDefaultPAL = pSiS->NonDefaultNTSC = -1;
d197 1
a197 80
    pSiS->restorebyset = TRUE;
    pSiS->nocrt2ddcdetection = FALSE;
    pSiS->forcecrt2redetection = TRUE;   /* default changed since 13/09/2003 */
    pSiS->ForceCRT1Type = CRT1_VGA;
    pSiS->ForceCRT2Type = CRT2_DEFAULT;
    pSiS->ForceYPbPrAR = TV_YPBPR169;
    pSiS->ForceTVType = -1;
    pSiS->CRT1gamma = TRUE;
    pSiS->CRT1gammaGiven = FALSE;
    pSiS->CRT2gamma = TRUE;
    pSiS->XvGamma = FALSE;
    pSiS->XvGammaGiven = FALSE;
    pSiS->enablesisctrl = FALSE;
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       pSiS->XvDefBri = 10;
       pSiS->XvDefCon = 2;
    } else {
       pSiS->XvDefBri = 0;
       pSiS->XvDefCon = 4;
    }
    pSiS->XvDefHue = 0; 
    pSiS->XvDefSat = 0;
    pSiS->XvDefDisableGfx = FALSE;
    pSiS->XvDefDisableGfxLR = FALSE;
    pSiS->UsePanelScaler = -1;
    pSiS->XvUseMemcpy = TRUE;
    pSiS->XvUseChromaKey = FALSE;
    pSiS->XvDisableColorKey = FALSE;
    pSiS->XvInsideChromaKey = FALSE;
    pSiS->XvYUVChromaKey = FALSE;
    pSiS->XvChromaMin = 0x000101fe;
    pSiS->XvChromaMax = 0x000101ff;
    pSiS->XvGammaRed = pSiS->XvGammaGreen = pSiS->XvGammaBlue =
       pSiS->XvGammaRedDef = pSiS->XvGammaGreenDef = pSiS->XvGammaBlueDef = 1000;
    pSiS->GammaBriR = pSiS->GammaBriG = pSiS->GammaBriB = 1000;
    pSiS->GammaPBriR = pSiS->GammaPBriG = pSiS->GammaPBriB = 1000;
    pSiS->HideHWCursor = FALSE;
    pSiS->HWCursorIsVisible = FALSE;
#ifdef SISMERGED
    pSiS->MergedFB = pSiS->MergedFBAuto = FALSE;
    pSiS->CRT2Position = sisRightOf;
    pSiS->CRT2HSync = NULL;
    pSiS->CRT2VRefresh = NULL;
    pSiS->MetaModes = NULL;
    pSiS->MergedFBXDPI = pSiS->MergedFBYDPI = 0;
#ifdef SISXINERAMA
    pSiS->UseSiSXinerama = TRUE;
    pSiS->CRT2IsScrn0 = FALSE;
#endif
#endif
#ifdef SIS_CP
    SIS_CP_OPT_DEFAULT
#endif

    /* Chipset dependent defaults */

    if(pSiS->Chipset == PCI_CHIP_SIS530) {
    	 /* TW: TQ still broken on 530/620? */
	 pSiS->TurboQueue = FALSE;
    }

    if(pSiS->Chipset == PCI_CHIP_SIS6326) {
         pSiS->newFastVram = 1;
    }

    if(pSiS->sishw_ext.jChipType == SIS_315H ||
       pSiS->sishw_ext.jChipType == SIS_315) {
         /* Cursor engine seriously broken */
         pSiS->HWCursor = FALSE;
    }

    /* DRI only supported on 300 series,
     * so don't load DRI by default on
     * others.
     */
    if(pSiS->VGAEngine == SIS_300_VGA) {
       pSiS->loadDRI = TRUE;
    }

#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
d207 2
a208 1
#endif
d210 3
a212 73
    if(pSiS->VGAEngine == SIS_300_VGA) {
       pSiS->AllowHotkey = 0;
    } else if(pSiS->VGAEngine == SIS_315_VGA) {
       pSiS->AllowHotkey = 1;
    }

    /* Collect the options */

    /* FastVRAM (5597/5598, 6326 and 530/620 only)
     */
    if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
       from = X_DEFAULT;
       if(xf86GetOptValBool(pSiS->Options, OPTION_FAST_VRAM, &pSiS->newFastVram)) {
          from = X_CONFIG;
       }
       xf86DrvMsg(pScrn->scrnIndex, from, "Fast VRAM %s\n",
                   (pSiS->newFastVram == -1) ?
		         ((pSiS->oldChipset == OC_SIS620) ? "enabled (for read only)" :
			                                    "enabled (for write only)") :
		   	 (pSiS->newFastVram ? "enabled (for read and write)" : disabledstr));
    }

    /* NoHostBus (5597/5598 only)
     */
    if((pSiS->Chipset == PCI_CHIP_SIS5597)) {
       from = X_DEFAULT;
       if(xf86GetOptValBool(pSiS->Options, OPTION_NOHOSTBUS, &pSiS->NoHostBus)) {
          from = X_CONFIG;
       }
       xf86DrvMsg(pScrn->scrnIndex, from, "SiS5597/5598 VGA-to-CPU host bus %s\n",
                   pSiS->NoHostBus ? disabledstr : enabledstr);
    }

    /* MaxXFBMem
     * This options limits the amount of video memory X uses for screen
     * and off-screen buffers. This option should be used if using DRI
     * is intended. The kernel framebuffer driver required for DRM will
     * start its memory heap at 12MB if it detects more than 16MB, at 8MB if
     * between 8 and 16MB are available, otherwise at 4MB. So, if the amount
     * of memory X uses, a clash between the framebuffer's memory heap
     * and X is avoided. The amount is to be specified in KB.
     */
    if(xf86GetOptValULong(pSiS->Options, OPTION_MAXXFBMEM,
                                &pSiS->maxxfbmem)) {
            xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "MaxXFBMem: Framebuffer memory shall be limited to %ld KB\n",
		    pSiS->maxxfbmem);
	    pSiS->maxxfbmem *= 1024;
    }

    /* NoAccel
     * Turns off 2D acceleration
     */
    if(xf86ReturnOptValBool(pSiS->Options, OPTION_NOACCEL, FALSE)) {
        pSiS->NoAccel = TRUE;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	pSiS->NoXvideo = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "2D Acceleration and Xv disabled\n");
#else
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "2D Acceleration disabled\n");
#endif

    }

    /* RenderAcceleration
     * En/Disables RENDER acceleration (315/330 series only)
     */
    if((pSiS->VGAEngine == SIS_315_VGA) && (!pSiS->NoAccel)) {
       if(xf86GetOptValBool(pSiS->Options, OPTION_RENDER, &pSiS->doRender)) {
          if(!pSiS->doRender) {
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "RENDER Acceleration disabled\n");
	  }
       }
d215 1
a215 4
    /* SWCursor
     * HWCursor
     * Chooses whether to use the hardware or software cursor
     */
d227 1
a227 11

    /*
     * UseColorHWCursor
     * ColorHWCursorBlending
     * ColorHWCursorBlendThreshold
     *
     * Enable/disable color hardware cursors;
     * enable/disable color hw cursor emulation for 300 series
     * select emultation transparency threshold for 300 series
     *
     */
d230 1
a230 1
#ifdef SIS_ARGB_CURSOR
d237 2
a238 2
                    pSiS->OptUseColorCursor ? enabledstr : disabledstr);

d247 1
a247 1
		(pSiS->OptUseColorCursorBlend) ? enabledstr : disabledstr);
d249 1
a249 1
	  {
d261 1
a261 3
	  } else {
	        temp = pSiS->OptColorCursorBlendThreshold >> 24;
          }
d275 25
a299 15
    /*
     * MergedFB
     *
     * Enable/disable and configure merged framebuffer mode
     *
     */
#ifdef SISMERGED
#ifdef SISDUALHEAD
    if(pSiS->DualHeadMode) {
       Bool val;
       if(xf86GetOptValBool(pSiS->Options, OPTION_MERGEDFB, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     "Option \"MergedFB\" cannot be used in Dual Head mode\n");
       }
    } else
d301 6
a306 12
    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       Bool val;
       if(xf86GetOptValBool(pSiS->Options, OPTION_MERGEDFB, &val)) {
	  if(val) {
	     pSiS->MergedFB = TRUE;
	     pSiS->MergedFBAuto = FALSE;
	  }
       } else if(xf86GetOptValBool(pSiS->Options, OPTION_MERGEDFB2, &val)) {
          if(val) {
	     pSiS->MergedFB = TRUE;
	     pSiS->MergedFBAuto = FALSE;
	  }
d308 4
d313 5
a317 9
       if(xf86GetOptValBool(pSiS->Options, OPTION_MERGEDFBAUTO, &val)) {
          if(!pSiS->MergedFB) {
	     if(val) {
	        pSiS->MergedFB = pSiS->MergedFBAuto = TRUE;
	     }
	  } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"Option \"MergedFB\" overrules option \"MergedFBAuto\"\n");
	  }
d319 3
d323 6
a328 83
       if(pSiS->MergedFB) {
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2POS);
	  if(!strptr) {
	     strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2POS2);
	  }
      	  if(strptr) {
       	     if(!xf86NameCmp(strptr,"LeftOf")) {
                pSiS->CRT2Position = sisLeftOf;
#ifdef SISXINERAMA
		pSiS->CRT2IsScrn0 = TRUE;
#endif
 	     } else if(!xf86NameCmp(strptr,"RightOf")) {
                pSiS->CRT2Position = sisRightOf;
#ifdef SISXINERAMA
		pSiS->CRT2IsScrn0 = FALSE;
#endif
	     } else if(!xf86NameCmp(strptr,"Above")) {
                pSiS->CRT2Position = sisAbove;
#ifdef SISXINERAMA
		pSiS->CRT2IsScrn0 = FALSE;
#endif
	     } else if(!xf86NameCmp(strptr,"Below")) {
                pSiS->CRT2Position = sisBelow;
#ifdef SISXINERAMA
		pSiS->CRT2IsScrn0 = TRUE;
#endif
	     } else if(!xf86NameCmp(strptr,"Clone")) {
                pSiS->CRT2Position = sisClone;
#ifdef SISXINERAMA
		pSiS->CRT2IsScrn0 = TRUE;
#endif
	     } else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "CRT2Position");
	    	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	            "Valid parameters are \"RightOf\", \"LeftOf\", \"Above\", \"Below\", or \"Clone\"\n");
	     }
	  }
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_METAMODES);
	  if(strptr) {
	     pSiS->MetaModes = xalloc(strlen(strptr) + 1);
	     if(pSiS->MetaModes) memcpy(pSiS->MetaModes, strptr, strlen(strptr) + 1);
	  }
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2HSYNC);
	  if(!strptr) {
	     strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2HSYNC2);
	  }
	  if(strptr) {
	     pSiS->CRT2HSync = xalloc(strlen(strptr) + 1);
	     if(pSiS->CRT2HSync) memcpy(pSiS->CRT2HSync, strptr, strlen(strptr) + 1);
	  }
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2VREFRESH);
	  if(!strptr) {
	     strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CRT2VREFRESH2);
	  }
	  if(strptr) {
	     pSiS->CRT2VRefresh = xalloc(strlen(strptr) + 1);
	     if(pSiS->CRT2VRefresh) memcpy(pSiS->CRT2VRefresh, strptr, strlen(strptr) + 1);
	  }
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_MERGEDDPI);
	  if(strptr) {
	     int val1 = 0, val2 = 0;
	     sscanf(strptr, "%d %d", &val1, &val2);
	     if(val1 && val2) {
	        pSiS->MergedFBXDPI = val1;
		pSiS->MergedFBYDPI = val2;
	     } else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "MergedDPI");
	     }
	  }
#ifdef SISXINERAMA
	  if(pSiS->MergedFB) {
	     if(xf86GetOptValBool(pSiS->Options, OPTION_NOSISXINERAMA, &val)) {
	        if(val) pSiS->UseSiSXinerama = FALSE;
	     } else if(xf86GetOptValBool(pSiS->Options, OPTION_NOSISXINERAMA2, &val)) {
	        if(val) pSiS->UseSiSXinerama = FALSE;
	     }
	     if(pSiS->UseSiSXinerama) {
	        if(xf86GetOptValBool(pSiS->Options, OPTION_CRT2ISSCRN0, &val)) {
		   pSiS->CRT2IsScrn0 = val ? TRUE : FALSE;
		}
	     }
	  }
#endif
d330 2
a332 1
#endif
d334 2
a335 2
    /* Some options can only be specified in the Master Head's Device
     * section. Here we give the user a hint in the log.
d337 30
a366 105
#ifdef SISDUALHEAD
    if((pSiS->DualHeadMode) && (pSiS->SecondHead)) {
       static const char *mystring = "Option \"%s\" is only accepted in Master Head's device section\n";
       Bool val;
       int vali;
       if(pSiS->VGAEngine != SIS_315_VGA) {
          if(xf86GetOptValBool(pSiS->Options, OPTION_TURBOQUEUE, &val)) {
             xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "TurboQueue");
          }
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_RESTOREBYSET, &val)) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "RestoreBySetMode");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_ENABLEHOTKEY, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "EnableHotKey");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_ENABLESISCTRL, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "EnableSiSCtrl");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_USEROMDATA, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "UseROMData");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_USEOEM, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "UseOEMData");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_FORCECRT1, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "ForceCRT1");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_NODDCFORCRT2, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "NoCRT2Detection");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_FORCECRT2REDETECTION, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "ForceCRT2ReDetection");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT1TYPE)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "ForceCRT1Type");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT2TYPE)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "ForceCRT2Type");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_YPBPRAR)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "YPbPrAspectRatio");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_SCALELCD, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "ScaleLCD");
       }
       if(xf86GetOptValInteger(pSiS->Options, OPTION_PDC, &vali)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "PanelDelayCompensation");
       }
       if(xf86GetOptValInteger(pSiS->Options, OPTION_EMI, &vali)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "EMI");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_SPECIALTIMING)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "SpecialTiming");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_LVDSHL)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "LVDSHL");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_TVSTANDARD)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "TVStandard");
       }
       if(xf86GetOptValString(pSiS->Options, OPTION_CHTVTYPE)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "CHTVType");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_CHTVOVERSCAN, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "CHTVOverscan");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_CHTVSOVERSCAN, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "CHTVSuperOverscan");
       }
       if((xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMABANDWIDTHCVBS, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMABANDWIDTHSVIDEO, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMAFLICKERFILTER, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCHROMABANDWIDTH, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCHROMAFLICKERFILTER, &vali)) ||
          (xf86GetOptValBool(pSiS->Options, OPTION_CHTVCVBSCOLOR, &val)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVTEXTENHANCE, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCONTRAST, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_SISTVEDGEENHANCE, &vali)) ||
	  (xf86GetOptValString(pSiS->Options, OPTION_SISTVANTIFLICKER)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_SISTVSATURATION, &vali)) ||
	  (xf86GetOptValBool(pSiS->Options, OPTION_SISTVCHROMAFILTER, &val)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_SISTVLUMAFILTER, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_SISTVCOLCALIBCOARSE, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_SISTVCOLCALIBFINE, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_TVXPOSOFFSET, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_TVYPOSOFFSET, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_TVXSCALE, &vali)) ||
	  (xf86GetOptValInteger(pSiS->Options, OPTION_TVYSCALE, &vali))) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      "TV related options are only accepted in Master Head's device section");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_CRT2GAMMA, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "CRT2Gamma");
       }
       if(xf86GetOptValBool(pSiS->Options, OPTION_XVONCRT2, &val)) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "XvOnCRT2");
       }
#ifdef SIS_CP
       SIS_CP_OPT_DH_WARN
#endif
    } else
#endif    
    {
       if(pSiS->VGAEngine == SIS_315_VGA) {
d368 21
a388 6
#ifdef SISVRAMQ
          xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using VRAM command queue, size %dk\n",
	  	pSiS->cmdQueueSize / 1024);
#else
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using MMIO command queue, size 512k\n");
#endif
d390 11
a400 1
       } else {
d402 37
a438 8
	  /* TurboQueue */

          from = X_DEFAULT;
          if(xf86GetOptValBool(pSiS->Options, OPTION_TURBOQUEUE, &pSiS->TurboQueue)) {
    	     from = X_CONFIG;
          }
          xf86DrvMsg(pScrn->scrnIndex, from, "TurboQueue %s\n",
                    pSiS->TurboQueue ? enabledstr : disabledstr);
d440 20
a459 24

       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {

          Bool val;

	  /* RestoreBySetMode (300/315/330 series only)
           * Set this to force the driver to set the old mode instead of restoring
           * the register contents. This can be used to overcome problems with
           * LCD panels and video bridges.
           */
          if(xf86GetOptValBool(pSiS->Options, OPTION_RESTOREBYSET, &val)) {
             pSiS->restorebyset = val ? TRUE : FALSE;
          }

	  /* EnableHotkey (300/315/330 series only)
	   * Enables or disables the BIOS hotkey switch for
	   * switching the output device on laptops.
	   * This key causes a total machine hang on many 300 series
	   * machines, it is therefore by default disabled on such.
	   * In dual head mode, using the hotkey is lethal, so we
	   * forbid it then in any case.
	   * However, although the driver disables the hotkey as
	   * BIOS developers intented to do that, some buggy BIOSes
	   * still cause the machine to freeze. Hence the warning.
d461 3
a463 21
          {
	  int flag = 0;
#ifdef SISDUALHEAD
          if(pSiS->DualHeadMode) {
	     pSiS->AllowHotkey = 0;
	     flag = 1;
	  } else
#endif
	  if(xf86GetOptValBool(pSiS->Options, OPTION_ENABLEHOTKEY, &val)) {
	     pSiS->AllowHotkey = val ? 1 : 0;
          }
	  xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Hotkey display switching is %s%s\n",
	        pSiS->AllowHotkey ? enabledstr : disabledstr,
	        flag ? " in dual head mode" : "");
	  if(pSiS->Chipset == PCI_CHIP_SIS630 ||
	     pSiS->Chipset == PCI_CHIP_SIS650 ||
	     pSiS->Chipset == PCI_CHIP_SIS660) {
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	         "WARNING: Using the Hotkey might freeze your machine, regardless\n");
	     xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		 "\twhether enabled or disabled. This is no driver bug.\n");
d465 13
d479 3
d483 6
a488 12
          /* UseROMData (300/315/330 series only)
           * This option is enabling/disabling usage of some machine
           * specific data from the BIOS ROM. This option can - and
           * should - be used in case the driver makes problems
           * because SiS changed the location of this data.
           */
	  if(xf86GetOptValBool(pSiS->Options, OPTION_USEROMDATA, &val)) {
	     pSiS->OptROMUsage = val ? 1 : 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "Video ROM data usage shall be %s\n",
	          val ? enabledstr : disabledstr);
	  }
d490 3
a492 13
          /* UseOEMData (300/315/330 series only)
           * The driver contains quite a lot data for OEM LCD panels
           * and TV connector specifics which override the defaults.
           * If this data is incorrect, the TV may lose color and
           * the LCD panel might show some strange effects. Use this
           * option to disable the usage of this data.
           */
	  if(xf86GetOptValBool(pSiS->Options, OPTION_USEOEM, &val)) {
	     pSiS->OptUseOEM = val ? 1 : 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "Internal LCD/TV/VGA2 OEM data usage shall be %s\n",
	         val ? enabledstr : disabledstr);
	  }
d494 4
a497 10
	  /* NoCRT2DDCDetection (315/330 series only)
           * If set to true, this disables CRT2 detection using DDC. This is
           * to avoid problems with not entirely DDC compiant LCD panels or
           * VGA monitors connected to the secondary VGA plug. Since LCD and
           * VGA share the same DDC channel, it might in some cases be impossible
           * to determine if the device is a CRT monitor or a flat panel.
           */
          if(xf86GetOptValBool(pSiS->Options, OPTION_NODDCFORCRT2, &val)) {
             pSiS->nocrt2ddcdetection = val ? TRUE : FALSE;
          }
d499 17
a515 15
	  /* ForceCRT2ReDetection (315/330 series only)
           * If set to true, it forces re-detection of the LCD panel and
	   * a secondary VGA connection even if the BIOS already had found
	   * about it. This is meant for custom panels (ie such with
	   * non-standard resolutions) which the BIOS will "detect" according
	   * to the established timings, resulting in only a very vague idea
	   * about the panels real resolution. As for secondary VGA, this
	   * enables us to include a Plasma panel's proprietary modes.
           */
          if(xf86GetOptValBool(pSiS->Options, OPTION_FORCECRT2REDETECTION, &val)) {
             if(val) {
	             pSiS->forcecrt2redetection = TRUE;
		     pSiS->nocrt2ddcdetection = FALSE;
	     } else  pSiS->forcecrt2redetection = FALSE;
          }
d517 11
d529 4
a532 21
	  /* ForceCRT1Type (315/330 series only)
	   * Used for forcing the driver to initialize CRT1 as
	   * VGA (analog) or LCDA (for simultanious LCD and TV
           * display) - on M650/651 and 661 or later with 301C/30xLV only!
           */
	  if(pSiS->VGAEngine == SIS_315_VGA) {
             strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT1TYPE);
             if(strptr != NULL) {
                if(!xf86NameCmp(strptr,"VGA")) {
                   pSiS->ForceCRT1Type = CRT1_VGA;
		} else if( (!xf86NameCmp(strptr,"LCD")) ||
		         (!xf86NameCmp(strptr,"LCDA")) ||
			 (!xf86NameCmp(strptr,"LCD-A")) ) {
		   pSiS->ForceCRT1Type = CRT1_LCDA;
		} else {
		   xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "ForceCRT1Type");
	           xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	               "Valid parameters are \"VGA\" or \"LCD\"\n");
		}
	     }
	  }
d534 64
a597 12
	  /* ForceCRT1 (300/315/330 series only)
           * This option can be used to force CRT1 to be switched on/off. Its
           * intention is mainly for old monitors that can't be detected
           * automatically. This is only useful on machines with a video bridge.
           * In normal cases, this option won't be necessary.
           */
	  if(xf86GetOptValBool(pSiS->Options, OPTION_FORCECRT1, &val)) {
	     pSiS->forceCRT1 = val ? 1 : 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "CRT1 shall be forced to %s\n",
	         val ? "ON" : "OFF");
	     if(!pSiS->forceCRT1) pSiS->ForceCRT1Type = CRT1_VGA;
d600 5
a604 70
	  /* ForceCRT2Type (300/315/330 series only)
	   * Used for forcing the driver to initialize a given
	   * CRT2 device type.
           * (SVIDEO, COMPOSITE and SCART for overriding detection)
           */
          strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_FORCE_CRT2TYPE);
          if(strptr != NULL) {
             if(!xf86NameCmp(strptr,"TV"))
                pSiS->ForceCRT2Type = CRT2_TV;
 	     else if(!xf86NameCmp(strptr,"SVIDEO")) {
                pSiS->ForceCRT2Type = CRT2_TV;
	        pSiS->ForceTVType = TV_SVIDEO;
             } else if(!xf86NameCmp(strptr,"COMPOSITE")) {
                pSiS->ForceCRT2Type = CRT2_TV;
	        pSiS->ForceTVType = TV_AVIDEO;
	     } else if( (!xf86NameCmp(strptr,"COMPOSITE SVIDEO")) || /* Ugly, but shorter than a parsing function */
	                (!xf86NameCmp(strptr,"COMPOSITE+SVIDEO")) ||
			(!xf86NameCmp(strptr,"SVIDEO+COMPOSITE")) ||
			(!xf86NameCmp(strptr,"SVIDEO COMPOSITE")) ) {
	        pSiS->ForceCRT2Type = CRT2_TV;
		pSiS->ForceTVType = (TV_SVIDEO | TV_AVIDEO);
             } else if(!xf86NameCmp(strptr,"SCART")) {
                pSiS->ForceCRT2Type = CRT2_TV;
	        pSiS->ForceTVType = TV_SCART;
             } else if((!xf86NameCmp(strptr,"LCD")) || (!xf86NameCmp(strptr,"DVI-D"))) {
	        if(pSiS->ForceCRT1Type == CRT1_VGA) {
                   pSiS->ForceCRT2Type = CRT2_LCD;
		} else {
		   pSiS->ForceCRT2Type = 0;
		   xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   		"Can't set both CRT1 and CRT2 type to LCD; CRT2 disabled\n");
		}
             } else if((!xf86NameCmp(strptr,"VGA")) || (!xf86NameCmp(strptr,"DVI-A")))
                pSiS->ForceCRT2Type = CRT2_VGA;
             else if(!xf86NameCmp(strptr,"NONE"))
                pSiS->ForceCRT2Type = 0;
	     else if((!xf86NameCmp(strptr,"DSTN")) && (pSiS->Chipset == PCI_CHIP_SIS550)) {
		if(pSiS->ForceCRT1Type == CRT1_VGA) {
		   pSiS->ForceCRT2Type = CRT2_LCD;
		   pSiS->DSTN = TRUE;
		}
	     } else if((!xf86NameCmp(strptr,"FSTN")) && (pSiS->Chipset == PCI_CHIP_SIS550)) {
		if(pSiS->ForceCRT1Type == CRT1_VGA) {
		   pSiS->ForceCRT2Type = CRT2_LCD;
		   pSiS->FSTN = TRUE;
		}
#ifdef ENABLE_YPBPR
	     } else if(!xf86NameCmp(strptr,"HIVISION")) {
		pSiS->ForceCRT2Type = CRT2_TV;
	        pSiS->ForceTVType = TV_HIVISION;
	     } else if((!xf86NameCmp(strptr,"YPBPR1080I")) && (pSiS->VGAEngine == SIS_315_VGA)) {
	        pSiS->ForceCRT2Type = CRT2_TV;
		pSiS->ForceTVType = TV_YPBPR;
		pSiS->ForceYPbPrType = TV_YPBPR1080I;
	     } else if(((!xf86NameCmp(strptr,"YPBPR525I")) || (!xf86NameCmp(strptr,"YPBPR480I"))) &&
	               (pSiS->VGAEngine == SIS_315_VGA)) {
		pSiS->ForceCRT2Type = CRT2_TV;
		pSiS->ForceTVType = TV_YPBPR;
		pSiS->ForceYPbPrType = TV_YPBPR525I;
	     } else if(((!xf86NameCmp(strptr,"YPBPR525P")) || (!xf86NameCmp(strptr,"YPBPR480P"))) &&
	               (pSiS->VGAEngine == SIS_315_VGA)) {
		pSiS->ForceCRT2Type = CRT2_TV;
		pSiS->ForceTVType = TV_YPBPR;
		pSiS->ForceYPbPrType = TV_YPBPR525P;
	     } else if(((!xf86NameCmp(strptr,"YPBPR750P")) || (!xf86NameCmp(strptr,"YPBPR720P"))) &&
	               (pSiS->VGAEngine == SIS_315_VGA)) {
		pSiS->ForceCRT2Type = CRT2_TV;
		pSiS->ForceTVType = TV_YPBPR;
		pSiS->ForceYPbPrType = TV_YPBPR750P;
#endif
d606 5
a610 32
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "ForceCRT2Type");
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	            "Valid parameters are \"LCD\" (=\"DVI-D\"), \"TV\", \"SVIDEO\", \"COMPOSITE\",\n"
		    "\t\"SVIDEO+COMPOSITE\", \"SCART\", \"VGA\" (=\"DVI-A\") or \"NONE\"; on the SiS550\n"
		    "\talso \"DSTN\" and \"FSTN\""
#ifdef ENABLE_YPBPR
		    				"; on SiS 301/301B bridges also \"HIVISION\", and on\n"
		    "\tSiS315/330 series with 301C/30xLV bridge also \"YPBPR480I\", \"YPBPR480P\",\n"
		    "\t\"YPBPR720P\" and \"YPBPR1080I\""
#endif
		    "\n");
	     }

             if(pSiS->ForceCRT2Type != CRT2_DEFAULT)
                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "CRT2 type shall be %s\n", strptr);
          }

	  if(pSiS->ForceTVType == TV_YPBPR) {
	     strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_YPBPRAR);
             if(strptr != NULL) {
	        if(!xf86NameCmp(strptr,"4:3LB"))
                   pSiS->ForceYPbPrAR = TV_YPBPR43LB;
		else if(!xf86NameCmp(strptr,"4:3"))
                   pSiS->ForceYPbPrAR = TV_YPBPR43;
		else if(!xf86NameCmp(strptr,"16:9"))
                   pSiS->ForceYPbPrAR = TV_YPBPR169;
		else {
		   xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "YPbPrAspectRatio");
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	            	"Valid parameters are \"4:3LB\", \"4:3\" and \"16:9\"\n");
		}
d613 2
d616 10
a625 36
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SPECIALTIMING);
          if(strptr != NULL) {
	     int i = 0;
	     BOOLEAN found = FALSE;
	     if(!xf86NameCmp(strptr,"NONE")) {
	        pSiS->SiS_Pr->SiS_CustomT = CUT_FORCENONE;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			"Special timing disabled\n");
	     } else {
	        while(mycustomttable[i].chipID != 0) {
	           if(!xf86NameCmp(strptr,mycustomttable[i].optionName)) {
		      pSiS->SiS_Pr->SiS_CustomT = mycustomttable[i].SpecialID;
		      found = TRUE;
		      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		   	  "Special timing for %s %s forced\n",
			  mycustomttable[i].vendorName, mycustomttable[i].cardName);
		      break;
		   }
		   i++;
	        }
		if(!found) {
		   xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "SpecialTiming");
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Valid parameters are:\n");
		   xf86DrvMsg(pScrn->scrnIndex, X_INFO, "\t\"NONE\" (to disable special timings)\n");
		   i = 0;
		   while(mycustomttable[i].chipID != 0) {
		      xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		        	"\t\"%s\" (for %s %s)\n",
				mycustomttable[i].optionName,
				mycustomttable[i].vendorName,
				mycustomttable[i].cardName);
		      i++;
		   }
                }
 	     }
	  }
d627 10
a636 9
	  /* EnableSiSCtrl */
	  /* Allow sisctrl tool to change driver settings */
	  from = X_DEFAULT;
	  if(xf86GetOptValBool(pSiS->Options, OPTION_ENABLESISCTRL, &val)) {
             if(val) pSiS->enablesisctrl = TRUE;
	     from = X_CONFIG;
          }
	  xf86DrvMsg(pScrn->scrnIndex, from, "SiSCtrl utility interface is %s\n",
	  	pSiS->enablesisctrl ? enabledstr : disabledstr);
d638 17
a654 12
         /* ScaleLCD (300/315/330 series only)
          * Can be used to force the bridge/panel link to [do|not do] the
	  * scaling of modes lower than the panel's native resolution.
          * Setting this to TRUE will force the bridge/panel link
	  * to scale; FALSE will rely on the panel's capabilities.
	  * Not supported on all machines.
          */
	  if(xf86GetOptValBool(pSiS->Options, OPTION_SCALELCD, &val)) {
	     pSiS->UsePanelScaler = val ? 0 : 1;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "LCD scaling is %s\n",
	         pSiS->UsePanelScaler ? disabledstr : enabledstr);
	  }
d656 7
a662 22
         /* PanelDelayCompensation (300/315/330 series only)
          * This might be required if the LCD panel shows "small waves".
          * The parameter is an integer, (on 300 series usually either
	  * 4, 32 or 24; on 315 series + LV bridge usually 3 or 51)
          * Why this option? Simply because SiS did poor BIOS design.
          * The PDC value depends on the very LCD panel used in a
          * particular machine. For most panels, the driver is able
          * to detect the correct value. However, some panels require
          * a different setting. For 300 series, the value given must
	  * be within the mask 0x3c.
          */
          if(xf86GetOptValInteger(pSiS->Options, OPTION_PDC, &pSiS->PDC)) {
	     if((pSiS->VGAEngine == SIS_300_VGA) && (pSiS->PDC & ~0x3c)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	            "Illegal PanelDelayCompensation parameter\n");
	        pSiS->PDC = -1;
	     } else {
                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "Panel delay compensation shall be %d\n",
	             pSiS->PDC);
	     }
          }
d664 26
a689 15
	 /* LVDSHL (300/315/330 series + 30xLV bridge only)
          * This might be required if the LCD panel is too dark.
          * The parameter is an integer from 0 to 3.
          */
          if(xf86GetOptValInteger(pSiS->Options, OPTION_LVDSHL, &pSiS->SiS_Pr->LVDSHL)) {
	     if((pSiS->SiS_Pr->LVDSHL < 0) || (pSiS->SiS_Pr->LVDSHL > 3)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	            "Illegal LVDSHL parameter, valid is 0 through 3\n");
	        pSiS->SiS_Pr->LVDSHL = -1;
	     } else {
                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "LVDSHL will be %d\n",
	             pSiS->SiS_Pr->LVDSHL);
	     }
          }
d691 3
a693 21
	 /* EMI (315/330 series + 302LV/302ELV bridge only)
          * This might be required if the LCD panel loses sync on
	  * mode switches. So far, this problem should not show up
	  * due to the auto-detection (from reading the values set
	  * by the BIOS; however, the BIOS values are wrong sometimes
	  * such as in the case of some Compal machines with a
	  * 1400x1050, or some Inventec(Compaq) machines with a
	  * 1280x1024 panel.
          * The parameter is an integer from 0 to 0x60ffffff.
          */
          if(xf86GetOptValInteger(pSiS->Options, OPTION_EMI, &pSiS->EMI)) {
	     if((pSiS->EMI < 0) || (pSiS->EMI > 0x60ffffff)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	            "Illegal EMI parameter, valid is 0 through 0x60ffffff\n");
	        pSiS->EMI = -1;
	     } else {
	        pSiS->EMI &= 0x60ffffff;
                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                    "EMI will be 0x%04x\n", pSiS->EMI);
	     }
          }
d695 4
a698 103
       }


      /* TVStandard (300/315/330 series and 6326 w/ TV only)
       * This option is for overriding the autodetection of
       * the BIOS/Jumper option for PAL / NTSC
       */
       if((pSiS->VGAEngine == SIS_300_VGA) ||
          (pSiS->VGAEngine == SIS_315_VGA) ||
          ((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV))) {
          strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_TVSTANDARD);
          if(strptr != NULL) {
             if(!xf86NameCmp(strptr,"PAL"))
	        pSiS->OptTVStand = 1;
	     else if((!xf86NameCmp(strptr,"PALM")) ||
	             (!xf86NameCmp(strptr,"PAL-M"))) {
	        pSiS->OptTVStand = 1;
	        pSiS->NonDefaultPAL = 1;
  	     } else if((!xf86NameCmp(strptr,"PALN")) ||
	               (!xf86NameCmp(strptr,"PAL-N"))) {
	        pSiS->OptTVStand = 1;
	        pSiS->NonDefaultPAL = 0;
	     } else if((!xf86NameCmp(strptr,"NTSCJ")) ||
	               (!xf86NameCmp(strptr,"NTSC-J"))) {
	        pSiS->OptTVStand = 0;
	        pSiS->NonDefaultNTSC = 1;
  	     } else if(!xf86NameCmp(strptr,"NTSC"))
	        pSiS->OptTVStand = 0;
	     else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "TVStandard");
                xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	            "Valid parameters are \"PAL\", \"PALM\", \"PALN\", \"NTSC\", \"NTSCJ\"\n");
	     }

	     if(pSiS->OptTVStand != -1) {
	        static const char *tvstdstr = "TV standard shall be %s\n";
	        if(pSiS->Chipset == PCI_CHIP_SIS6326) {
	           pSiS->NonDefaultPAL = -1;
		   pSiS->NonDefaultNTSC = -1;
	           xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, tvstdstr,
	               pSiS->OptTVStand ? "PAL" : "NTSC");
	        } else {
	           xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, tvstdstr,
		       (pSiS->OptTVStand ?
		           ( (pSiS->NonDefaultPAL == -1) ? "PAL" :
			      ((pSiS->NonDefaultPAL) ? "PALM" : "PALN") ) :
				(pSiS->NonDefaultNTSC == -1) ? "NTSC" : "NTSCJ"));
	        }
	     }
          }
       }

      /* CHTVType  (315/330 series + Chrontel only)
       * Used for telling the driver if the TV output shall
       * be 525i YPbPr or SCART.
       */
       if(pSiS->VGAEngine == SIS_315_VGA) {
          strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_CHTVTYPE);
          if(strptr != NULL) {
             if(!xf86NameCmp(strptr,"SCART"))
                pSiS->chtvtype = 1;
 	     else if(!xf86NameCmp(strptr,"YPBPR525I"))
	        pSiS->chtvtype = 0;
	     else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "CHTVType");
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	          "Valid parameters are \"SCART\" or \"YPBPR525I\"\n");
	     }
             if(pSiS->chtvtype != -1)
                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                  "Chrontel: TV type shall be %s\n", strptr);
          }
       }

       /* CHTVOverscan (300/315/330 series only)
        * CHTVSuperOverscan (300/315/330 series only)
        * These options are for overriding the BIOS option for
        * TV Overscan. Some BIOS don't even have such an option.
        * SuperOverscan is only supported with PAL.
        * Both options are only effective on machines with a
        * CHRONTEL TV encoder. SuperOverscan is only available
        * on the 700x.
        */
       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	  Bool val;
	  if(xf86GetOptValBool(pSiS->Options, OPTION_CHTVOVERSCAN, &val)) {
	     pSiS->OptTVOver = val ? 1 : 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "Chrontel: TV overscan shall be %s\n",
	         val ? enabledstr : disabledstr);
	  }
          if(xf86GetOptValBool(pSiS->Options, OPTION_CHTVSOVERSCAN, &pSiS->OptTVSOver)) {
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	         "Chrontel: TV super overscan shall be %s\n",
	         pSiS->OptTVSOver ? enabledstr : disabledstr);
	  }
       }

       /* Various parameters for TV output via SiS bridge, Chrontel or SiS6326
        */
       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
          int tmp = 0;
          xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMABANDWIDTHCVBS,
d700 1
a700 1
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMABANDWIDTHSVIDEO,
d702 1
a702 1
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVLUMAFLICKERFILTER,
d704 1
a704 1
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCHROMABANDWIDTH,
d706 1
a706 1
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCHROMAFLICKERFILTER,
d708 1
a708 1
	  xf86GetOptValBool(pSiS->Options, OPTION_CHTVCVBSCOLOR,
d710 1
a710 1
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVTEXTENHANCE,
d712 1
a712 1
	  xf86GetOptValInteger(pSiS->Options, OPTION_CHTVCONTRAST,
d714 1
a714 1
	  xf86GetOptValInteger(pSiS->Options, OPTION_SISTVEDGEENHANCE,
d716 3
a718 1
	  xf86GetOptValInteger(pSiS->Options, OPTION_SISTVSATURATION,
d720 1
a720 20
	  xf86GetOptValInteger(pSiS->Options, OPTION_SISTVLUMAFILTER,
                                &pSiS->sistvyfilter);
          if((pSiS->sistvyfilter < 0) || (pSiS->sistvyfilter > 8)) {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"Illegal Y Filter number; valid is 0 (off), 1 (default), 2-8 (filter number 1-7)\n");
	     pSiS->sistvyfilter = 1;
	  }
 	  xf86GetOptValBool(pSiS->Options, OPTION_SISTVCHROMAFILTER,
				&pSiS->sistvcfilter);
	  xf86GetOptValInteger(pSiS->Options, OPTION_SISTVCOLCALIBCOARSE,
                                &pSiS->sistvcolcalibc);
          xf86GetOptValInteger(pSiS->Options, OPTION_SISTVCOLCALIBFINE,
                                &pSiS->sistvcolcalibf);
	  if((pSiS->sistvcolcalibf > 127) || (pSiS->sistvcolcalibf < -128) ||
	     (pSiS->sistvcolcalibc > 120) || (pSiS->sistvcolcalibc < -120)) {
	     pSiS->sistvcolcalibf = pSiS->sistvcolcalibc = 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"Illegal Color Calibration. Range is -128 to 127 (fine), -120 to 120 (coarse)\n");
	  }
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVXPOSOFFSET,
d722 1
a722 1
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVYPOSOFFSET,
d724 5
a728 5
	  if(pSiS->tvxpos > 32)  { pSiS->tvxpos = 32;  tmp = 1; }
	  if(pSiS->tvxpos < -32) { pSiS->tvxpos = -32; tmp = 1; }
	  if(pSiS->tvypos > 32)  { pSiS->tvypos = 32;  tmp = 1; }
	  if(pSiS->tvypos < -32) { pSiS->tvypos = -32;  tmp = 1; }
	  if(tmp) xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
d730 21
a750 26
          tmp = 0;
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVXSCALE,
                                &pSiS->tvxscale);
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVYSCALE,
                                &pSiS->tvyscale);
	  if(pSiS->tvxscale > 16)  { pSiS->tvxscale = 16;  tmp = 1; }
	  if(pSiS->tvxscale < -16) { pSiS->tvxscale = -16; tmp = 1; }
	  if(pSiS->tvyscale > 3)  { pSiS->tvyscale = 3;  tmp = 1; }
	  if(pSiS->tvyscale < -4) { pSiS->tvyscale = -4; tmp = 1; }
	  if(tmp) xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		      "Illegal TV x or y scaling parameter. Range is from -16 to 16 (X), -4 to 3 (Y)\n");
       }

       if((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV)) {
          int tmp = 0;
	  strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SIS6326FORCETVPPLUG);
          if(strptr) {
             if(!xf86NameCmp(strptr,"COMPOSITE"))
	        pSiS->sis6326tvplug = 1;
  	     else if(!xf86NameCmp(strptr,"SVIDEO"))
	        pSiS->sis6326tvplug = 0;
	     else {
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "SIS6326TVForcePlug");
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	           "Valid parameters are \"COMPOSITE\" or \"SVIDEO\"\n");
	     }
d752 2
a753 1
	  xf86GetOptValBool(pSiS->Options, OPTION_SIS6326ENABLEYFILTER,
d755 1
a755 1
	  xf86GetOptValBool(pSiS->Options, OPTION_SIS6326YFILTERSTRONG,
d757 1
a757 1
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVXPOSOFFSET,
d759 1
a759 1
	  xf86GetOptValInteger(pSiS->Options, OPTION_TVYPOSOFFSET,
d761 5
a765 5
	  if(pSiS->tvxpos > 16)  { pSiS->tvxpos = 16;  tmp = 1; }
	  if(pSiS->tvxpos < -16) { pSiS->tvxpos = -16; tmp = 1; }
	  if(pSiS->tvypos > 16)  { pSiS->tvypos = 16;  tmp = 1; }
	  if(pSiS->tvypos < -16) { pSiS->tvypos = -16;  tmp = 1; }
	  if(tmp) xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
a766 116
          xf86GetOptValInteger(pSiS->Options, OPTION_SIS6326FSCADJUST,
                                &pSiS->sis6326fscadjust);
	  if(pSiS->sis6326fscadjust) {
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	"Adjusting the default FSC by %d\n",
		pSiS->sis6326fscadjust);
	  }
       }

       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA) ||
          ((pSiS->Chipset == PCI_CHIP_SIS6326) && (pSiS->SiS6326Flags & SIS6326_HASTV))) {
          strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SISTVANTIFLICKER);
          if(!strptr) {
             strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_SIS6326ANTIFLICKER);
          }
          if(strptr) {
             if(!xf86NameCmp(strptr,"OFF"))
	        pSiS->sistvantiflicker = 0;
  	     else if(!xf86NameCmp(strptr,"LOW"))
	        pSiS->sistvantiflicker = 1;
	     else if(!xf86NameCmp(strptr,"MED"))
	        pSiS->sistvantiflicker = 2;
	     else if(!xf86NameCmp(strptr,"HIGH"))
	        pSiS->sistvantiflicker = 3;
	     else if(!xf86NameCmp(strptr,"ADAPTIVE"))
	        pSiS->sistvantiflicker = 4;
	     else {
	        pSiS->sistvantiflicker = -1;
	        xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "SISTVAntiFlicker");
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	            "Valid parameters are \"OFF\", \"LOW\", \"MED\", \"HIGH\" or \"ADAPTIVE\"\n");
	     }
	  }
       }

       /* CRT2Gamma - enable/disable gamma correction for CRT2
        */
       if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
          Bool val;
          if(xf86GetOptValBool(pSiS->Options, OPTION_CRT2GAMMA, &val)) {
	     pSiS->CRT2gamma = val;
          }
       }

#ifdef SIS_CP
       SIS_CP_OPT_DOOPT
#endif

    }  /* DualHead */

    /* CRT1Gamma - enable/disable gamma correction for CRT1
     */
    {
       Bool val;
       if(xf86GetOptValBool(pSiS->Options, OPTION_CRT1GAMMA, &val)) {
	  pSiS->CRT1gamma = val;
	  pSiS->CRT1gammaGiven = TRUE;
       }
    }

    /* VESA - DEPRECATED
     * This option is for forcing the driver to use
     * the VESA BIOS extension for mode switching.
     */
    {
	Bool val;
	if(xf86GetOptValBool(pSiS->Options, OPTION_VESA, &val)) {
	    pSiS->VESA = val ? 1 : 0;
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	        "VESA: VESA usage shall be %s\n",
		val ? enabledstr : disabledstr);
 	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	    	"*** Option \"VESA\" is deprecated. *** \n");
	    if(pSiS->VESA) pSiS->ForceCRT1Type = CRT1_VGA;
	}
    }

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {

       /* NoInternalModes (300/315/330 series only)
        * Since the mode switching code for these chipsets is a
        * Asm-to-C translation of BIOS code, we only have timings
        * for a pre-defined number of modes. The default behavior
        * is to replace XFree's default modes with a mode list
        * generated out of the known and supported modes. Use
        * this option to disable this. NOT RECOMMENDED.
        */
       from = X_DEFAULT;
       if(xf86GetOptValBool(pSiS->Options, OPTION_NOINTERNALMODES, &pSiS->noInternalModes))
		from = X_CONFIG;
       xf86DrvMsg(pScrn->scrnIndex, from, "Usage of built-in modes is %s\n",
		       pSiS->noInternalModes ? disabledstr : enabledstr);
    }

    /* ShadowFB */
    from = X_DEFAULT;
    if(xf86GetOptValBool(pSiS->Options, OPTION_SHADOW_FB, &pSiS->ShadowFB)) {
#ifdef SISMERGED
       if(pSiS->MergedFB) {
          pSiS->ShadowFB = FALSE;
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      "Shadow Frame Buffer not supported in MergedFB mode\n");
       } else
#endif
          from = X_CONFIG;
    }
    if(pSiS->ShadowFB) {
	pSiS->NoAccel = TRUE;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	pSiS->NoXvideo = TRUE;
    	xf86DrvMsg(pScrn->scrnIndex, from,
	   "Using \"Shadow Frame Buffer\" - 2D acceleration and Xv disabled\n");
#else
    	xf86DrvMsg(pScrn->scrnIndex, from,
	   "Using \"Shadow Frame Buffer\" - 2D acceleration disabled\n");
#endif
a767 298

    /* Rotate */
    if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_ROTATE))) {
#ifdef SISMERGED
       if(pSiS->MergedFB) {
	  xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	      "Screen rotation not supported in MergedFB mode\n");
       } else
#endif
       if(!xf86NameCmp(strptr, "CW")) {
          pSiS->Rotate = 1;
       } else if(!xf86NameCmp(strptr, "CCW")) {
          pSiS->Rotate = -1;
       } else {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mybadparm, strptr, "Rotate");
          xf86DrvMsg(pScrn->scrnIndex, X_INFO,
              "Valid parameters are \"CW\" or \"CCW\"\n");
       }

       if(pSiS->Rotate) {
          pSiS->ShadowFB = TRUE;
          pSiS->NoAccel  = TRUE;
          pSiS->HWCursor = FALSE;
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
	  pSiS->NoXvideo = TRUE;
          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
              "Rotating screen %sclockwise; (2D acceleration and Xv disabled)\n",
	      (pSiS->Rotate == -1) ? "counter " : "");
#else
	  xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
              "Rotating screen %sclockwise (2D acceleration %sdisabled)\n",
	      (pSiS->Rotate == -1) ? "counter " : "",
#if XF86_VERSION_CURRENT >= XF86_VERSION_NUMERIC(4,3,0,0,0)
              "and RandR extension "
#else
	      ""
#endif
	      );

#endif

       }
    }

#ifdef XF86DRI
    /* DRI */
    from = X_DEFAULT;
    if(xf86GetOptValBool(pSiS->Options, OPTION_DRI, &pSiS->loadDRI)) {
       from = X_CONFIG;
    }
    xf86DrvMsg(pScrn->scrnIndex, from, "DRI %s\n",
       pSiS->loadDRI ? enabledstr : disabledstr);

    /* AGPSize */
    {
       int vali;
       Bool gotit = FALSE;
       if(xf86GetOptValInteger(pSiS->Options, OPTION_AGP_SIZE, &vali)) {
          gotit = TRUE;
       } else if(xf86GetOptValInteger(pSiS->Options, OPTION_AGP_SIZE2, &vali)) {
          gotit = TRUE;
       }
       if(gotit) {
	  if((vali >= 8) && (vali <= 512)) {
	     pSiS->agpWantedPages = (vali * 1024 * 1024) / AGP_PAGE_SIZE;
	  } else {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr, "AGPSize (alias GARTSize)", 8, 512);
	  }
       }
    }
#endif

    /* NoXVideo
     * Set this to TRUE to disable Xv hardware video acceleration
     */
#if XF86_VERSION_CURRENT < XF86_VERSION_NUMERIC(4,2,99,0,0)
    if((!pSiS->NoAccel) && (!pSiS->NoXvideo)) {
#else
    if(!pSiS->NoXvideo) {
#endif
       if(xf86ReturnOptValBool(pSiS->Options, OPTION_NOXVIDEO, FALSE)) {
          pSiS->NoXvideo = TRUE;
          xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "XVideo extension disabled\n");
       }

       if(!pSiS->NoXvideo) {
          Bool val;
	  int tmp;

	  if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
      	     /* XvOnCRT2
	      * On chipsets with only one overlay (315, 650, 740, 330), the user can
	      * choose to display the overlay on CRT1 or CRT2. By setting this
	      * option to TRUE, the overlay will be displayed on CRT2. The
	      * default is: CRT1 if only CRT1 available, CRT2 if only CRT2
	      * available, and CRT1 if both is available and detected.
	      * Since implementation of the XV_SWITCHCRT Xv property this only
	      * selects the default CRT.
	      */
             if(xf86GetOptValBool(pSiS->Options, OPTION_XVONCRT2, &val)) {
	        pSiS->XvOnCRT2 = val ? TRUE : FALSE;
	     }
	  }

	  if((pSiS->VGAEngine == SIS_OLD_VGA) || (pSiS->VGAEngine == SIS_530_VGA)) {
	     /* NoYV12 (for 5597/5598, 6326 and 530/620 only)
	      * YV12 has problems with videos larger than 384x288. So
	      * allow the user to disable YV12 support to force the
	      * application to use YUV2 instead.
	      */
             if(xf86GetOptValBool(pSiS->Options, OPTION_NOYV12, &val)) {
	        pSiS->NoYV12 = val ? 1 : 0;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			"Xv YV12/I420 support is %s\n",
			pSiS->NoYV12 ? disabledstr : enabledstr);
	     }
	  }

	  /* Some Xv properties' defaults can be set by options */
          if(xf86GetOptValInteger(pSiS->Options, OPTION_XVDEFCONTRAST, &tmp)) {
             if((tmp >= 0) && (tmp <= 7)) pSiS->XvDefCon = tmp;
             else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       		      "XvDefaultContrast" ,0, 7);
          }
          if(xf86GetOptValInteger(pSiS->Options, OPTION_XVDEFBRIGHTNESS, &tmp)) {
             if((tmp >= -128) && (tmp <= 127)) pSiS->XvDefBri = tmp;
             else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       		      "XvDefaultBrightness", -128, 127);
          }
          if(pSiS->VGAEngine == SIS_315_VGA) {
             if(xf86GetOptValInteger(pSiS->Options, OPTION_XVDEFHUE, &tmp)) {
                if((tmp >= -8) && (tmp <= 7)) pSiS->XvDefHue = tmp;
                else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       	              "XvDefaultHue", -8, 7);
             }
             if(xf86GetOptValInteger(pSiS->Options, OPTION_XVDEFSATURATION, &tmp)) {
                if((tmp >= -7) && (tmp <= 7)) pSiS->XvDefSat = tmp;
                else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       	              "XvDefaultSaturation", -7, 7);
             }
          }
	  if(xf86GetOptValBool(pSiS->Options, OPTION_XVDEFDISABLEGFX, &val)) {
	     if(val)  pSiS->XvDefDisableGfx = TRUE;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	        "Graphics display will be %s during Xv usage\n",
	     	val ? disabledstr : enabledstr);
          }
	  if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
	     if(xf86GetOptValBool(pSiS->Options, OPTION_XVDEFDISABLEGFXLR, &val)) {
	        if(val)  pSiS->XvDefDisableGfxLR = TRUE;
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	   "Graphics display left/right of overlay will be %s during Xv usage\n",
		   val ? disabledstr : enabledstr);
             }
	     if(xf86GetOptValBool(pSiS->Options, OPTION_XVDISABLECOLORKEY, &val)) {
	        if(val) pSiS->XvDisableColorKey = TRUE;
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	   "Xv Color key is %s\n",
		   val ? disabledstr : enabledstr);
             }
	     if(xf86GetOptValBool(pSiS->Options, OPTION_XVUSECHROMAKEY, &val)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	   "Xv Chroma-keying is %s\n",
		   val ? enabledstr : disabledstr);
		if(val) pSiS->XvUseChromaKey = TRUE;
             }
	     if(xf86GetOptValBool(pSiS->Options, OPTION_XVINSIDECHROMAKEY, &val)) {
	        xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	   "Xv: Video is transparent if %s chroma key range\n",
		   val ? "inside" : "outside");
		if(val) pSiS->XvInsideChromaKey = TRUE;
             }
	     if(pSiS->VGAEngine == SIS_300_VGA) {
	        if(xf86GetOptValBool(pSiS->Options, OPTION_XVYUVCHROMAKEY, &val)) {
	           xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
	     	      "Xv: Chroma key is in %s format\n",
		      val ? "YUV" : "RGB");
		   if(val) pSiS->XvYUVChromaKey = TRUE;
		}
             } else {
	        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Xv: Chroma key is of same format as video source\n");
	     }
	     if(xf86GetOptValInteger(pSiS->Options, OPTION_XVCHROMAMIN, &tmp)) {
                if((tmp >= 0) && (tmp <= 0xffffff)) pSiS->XvChromaMin = tmp;
                else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       	                       "XvChromaMin", 0, 0xffffff);
             }
	     if(xf86GetOptValInteger(pSiS->Options, OPTION_XVCHROMAMAX, &tmp)) {
                if((tmp >= 0) && (tmp <= 0xffffff)) pSiS->XvChromaMax = tmp;
                else xf86DrvMsg(pScrn->scrnIndex, X_WARNING, ilrangestr,
       	                   "XvChromaMax", 0, 0xffffff);
             }
          }
	  if(xf86GetOptValBool(pSiS->Options, OPTION_XVMEMCPY, &val)) {
	     pSiS->XvUseMemcpy = val ? TRUE : FALSE;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Xv will %suse memcpy()\n",
	     	val ? "" : "not ");
          }
	  /* XvGamma - enable/disable gamma correction for Xv
	   * Supported for CRT1 only
           */
          if(pSiS->VGAEngine == SIS_315_VGA) {
	     if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_XVGAMMA))) {
                if( (!xf86NameCmp(strptr,"off"))   ||
	            (!xf86NameCmp(strptr,"false")) ||
		    (!xf86NameCmp(strptr,"no"))    ||
		    (!xf86NameCmp(strptr,"0")) ) {
		   pSiS->XvGamma = FALSE;
		   pSiS->XvGammaGiven = TRUE;
	        } else if( (!xf86NameCmp(strptr,"on"))   ||
	                   (!xf86NameCmp(strptr,"true")) ||
		           (!xf86NameCmp(strptr,"yes"))  ||
		           (!xf86NameCmp(strptr,"1")) ) {
		   pSiS->XvGamma = pSiS->XvGammaGiven = TRUE;
                } else {
	           float val1 = 0.0, val2 = 0.0, val3 = 0.0;
		   Bool valid = FALSE;
	           int result = sscanf(strptr, "%f %f %f", &val1, &val2, &val3);
		   if(result == 1) {
		      if((val1 >= 0.1) && (val1 <= 10.0)) {
		         pSiS->XvGammaGreen = pSiS->XvGammaBlue = pSiS->XvGammaRed =
			    pSiS->XvGammaGreenDef = pSiS->XvGammaBlueDef = pSiS->XvGammaRedDef = (int)(val1 * 1000);
		         valid = TRUE;
		      }
		   } else if(result == 3) {
		      if((val1 >= 0.1) && (val1 <= 10.0) &&
		         (val2 >= 0.1) && (val2 <= 10.0) &&
		         (val3 >= 0.1) && (val3 <= 10.0)) {
		         pSiS->XvGammaRed = pSiS->XvGammaRedDef = (int)(val1 * 1000);
		         pSiS->XvGammaGreen = pSiS->XvGammaGreenDef = (int)(val2 * 1000);
		         pSiS->XvGammaBlue = pSiS->XvGammaBlueDef = (int)(val3 * 1000);
			 valid = TRUE;
		      }
		   }
		   if(valid) {
		      pSiS->XvGamma = pSiS->XvGammaGiven = TRUE;
		   } else {
		      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		         "XvGamma expects either a boolean, or 1 or 3 real numbers (0.1 - 10.0)\n");
		   }
	        }
             }
          }
       }
    }

    if((pSiS->VGAEngine == SIS_300_VGA) || (pSiS->VGAEngine == SIS_315_VGA)) {
       if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_STOREDBRI))) {
          float val1 = 0.0, val2 = 0.0, val3 = 0.0;
	  Bool valid = FALSE;
	  int result = sscanf(strptr, "%f %f %f", &val1, &val2, &val3);
	  if(result == 1) {
	     if((val1 >= 0.1) && (val1 <= 10.0)) {
	        valid = TRUE;
		pSiS->GammaBriR = pSiS->GammaBriG = pSiS->GammaBriB = (int)(val1 * 1000);
	     }
	  } else if(result == 3) {
	     if((val1 >= 0.1) && (val1 <= 10.0) &&
	        (val2 >= 0.1) && (val2 <= 10.0) &&
		(val3 >= 0.1) && (val3 <= 10.0)) {
		valid = TRUE;
		pSiS->GammaBriR = (int)(val1 * 1000);
		pSiS->GammaBriG = (int)(val2 * 1000);
		pSiS->GammaBriB = (int)(val3 * 1000);
	     }
	  }
	  if(!valid) {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"StoredGammaBrightness expects 1 or 3 real numbers (0.1 - 10.0)\n");
	  }
       }
       if((strptr = (char *)xf86GetOptValString(pSiS->Options, OPTION_STOREDPBRI))) {
          float val1 = 0.0, val2 = 0.0, val3 = 0.0;
	  Bool valid = FALSE;
	  int result = sscanf(strptr, "%f %f %f", &val1, &val2, &val3);
	  if(result == 1) {
	     if((val1 >= 0.1) && (val1 <= 10.0)) {
	        valid = TRUE;
		pSiS->GammaPBriR = pSiS->GammaPBriG = pSiS->GammaPBriB = (int)(val1 * 1000);
	     }
	  } else if(result == 3) {
	     if((val1 >= 0.1) && (val1 <= 10.0) &&
	        (val2 >= 0.1) && (val2 <= 10.0) &&
		(val3 >= 0.1) && (val3 <= 10.0)) {
		valid = TRUE;
		pSiS->GammaPBriR = (int)(val1 * 1000);
		pSiS->GammaPBriG = (int)(val2 * 1000);
		pSiS->GammaPBriB = (int)(val3 * 1000);
	     }
	  }
	  if(!valid) {
	     xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	     	"\"StoredGammaPreBrightness\" expects 1 or 3 real numbers (0.1 - 10.0)\n");
	  }
       }
    }

@


1.1.1.4
log
@Import OpenBSD X-Window subsystem (based upon XFree86 4.4RC2)
into vendor branch
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/sis/sis_opt.c,v 1.57 2004/02/25 17:45:13 twini Exp $ */
d15 4
a18 1
 * 3) The name of the author may not be used to endorse or promote products
a70 3
    OPTION_PDCA,
    OPTION_PDCS,
    OPTION_PDCAS,
a109 1
    OPTION_SENSEYPBPR,
a126 1
    OPTION_CENTERLCD,
a174 3
    { OPTION_PDCA,               	"PanelDelayCompensation1",OPTV_INTEGER,   {0}, -1    },
    { OPTION_PDCS,               	"PDC", 			  OPTV_INTEGER,   {0}, -1    },
    { OPTION_PDCAS,               	"PDC1",			  OPTV_INTEGER,   {0}, -1    },
a215 1
    { OPTION_SENSEYPBPR,		"SenseYPbPr",   	  OPTV_BOOLEAN,   {0}, -1    },
a234 1
    { OPTION_CENTERLCD,			"CenterLCD",	   	  OPTV_BOOLEAN,   {0}, -1    },
a306 1
    pSiS->PDCA = -1;
a341 1
    pSiS->SenseYPbPr = TRUE;
a363 1
    pSiS->CenterLCD = -1;
a744 3
       if(xf86GetOptValBool(pSiS->Options, OPTION_SENSEYPBPR, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "SenseYPbPr");
       }
d757 2
a758 10
        if(xf86GetOptValBool(pSiS->Options, OPTION_CENTERLCD, &val)) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "CenterLCD");
       }
       if((xf86GetOptValInteger(pSiS->Options, OPTION_PDC, &vali)) ||
          (xf86GetOptValInteger(pSiS->Options, OPTION_PDCS, &vali))) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "PanelDelayCompensation (PDC)");
       }
       if((xf86GetOptValInteger(pSiS->Options, OPTION_PDCA, &vali)) ||
          (xf86GetOptValInteger(pSiS->Options, OPTION_PDCAS, &vali))) {
          xf86DrvMsg(pScrn->scrnIndex, X_WARNING, mystring, "PanelDelayCompensation1 (PDC1)");
a937 12
	  /* SenseYPbPr (315/330 series only)
           * If set to true, the driver will sense for YPbPr TV. This is
	   * inconvenient for folks connecting SVideo and CVBS at the same
	   * time, because this condition will be detected as YPbPr (since
	   * the TV output pins are shared). "False" will not sense for
	   * YPbPr and detect SVideo or CVBS only.
           */
          if(xf86GetOptValBool(pSiS->Options, OPTION_SENSEYPBPR, &val)) {
             if(val) pSiS->SenseYPbPr = TRUE;
	     else    pSiS->SenseYPbPr = FALSE;
          }

d984 1
a984 2
 	     else if( (!xf86NameCmp(strptr,"SVIDEO")) ||
	     	      (!xf86NameCmp(strptr,"SVHS")) ) {
d987 1
a987 2
             } else if( (!xf86NameCmp(strptr,"COMPOSITE")) ||
	     		(!xf86NameCmp(strptr,"CVBS")) ) {
a1140 15
	 /* CenterLCD (300/315/330 + SiS video bridge only)
          * If LCD shall not be scaled, this selects whether 1:1 data
	  * will be sent to the output, or the image shall be centered
	  * on the LCD. For LVDS panels, screen will always be centered,
	  * since these have no built-in scaler. For TMDS, this is
	  * selectable. Non-centered means that the driver will pass
	  * 1:1 data to the output and that the panel will have to
	  * scale by itself (if supported by the panel).
          */
	  if(xf86GetOptValBool(pSiS->Options, OPTION_CENTERLCD, &val)) {
	     pSiS->CenterLCD = val ? 1 : 0;
	     xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Non-scaled LCD output will %sbe centered\n",
	         pSiS->CenterLCD ? "not " : "");
	  }

d1142 1
a1142 2
          * This might be required if the LCD panel shows "small waves"
	  * or wrong colors.
d1150 1
a1150 2
	  * be within the mask 0x3c. For 661 and later, if must be
	  * within the range of 0 to 31.
d1152 1
a1152 6
	  {
	  int val = -1;
          xf86GetOptValInteger(pSiS->Options, OPTION_PDC, &val);
	  xf86GetOptValInteger(pSiS->Options, OPTION_PDCS, &val);
	  if(val != -1) {
	     pSiS->PDC = val;
a1157 1
	        if(pSiS->VGAEngine == SIS_315_VGA) pSiS->PDC &= 0x1f;
d1159 1
a1159 1
                    "Panel delay compensation shall be %d (for LCD=CRT2)\n",
a1162 22

	 /* PanelDelayCompensation1 (315 series only)
          * Same as above, but for LCD-via-CRT1 ("LCDA")
          */
	  if(pSiS->VGAEngine == SIS_315_VGA) {
	     val = -1;
             xf86GetOptValInteger(pSiS->Options, OPTION_PDCA, &val);
	     xf86GetOptValInteger(pSiS->Options, OPTION_PDCAS, &val);
	     if(val != -1) {
	        pSiS->PDCA = val;
	        if(pSiS->PDCA > 0x1f) {
	           xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
	                "Illegal PanelDelayCompensation1 (PDC1) parameter (0 <= PDC1 <= 31\n");
	           pSiS->PDCA = -1;
	        } else {
                   xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
                       	"Panel delay compensation shall be %d (for LCD=CRT1)\n",
	                pSiS->PDCA);
	        }
	     }
	  }
	  }
@


