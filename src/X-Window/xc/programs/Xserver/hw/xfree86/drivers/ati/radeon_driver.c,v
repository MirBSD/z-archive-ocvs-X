head	1.4;
access;
symbols
	tg-mergetmp-2:1.4
	cvs-200410241530:1.1.1.6
	cvs-200410012000:1.1.1.6
	cvs-200407221130:1.1.1.6
	cvs-200407141120:1.1.1.6
	cvs-200406231010:1.1.1.5
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.4
	XFree86_4_4_0:1.1.9.2
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.07.14.14.15.10;	author tg;	state Stab;
branches;
next	1.3;

1.3
date	2004.06.23.12.36.26;	author tg;	state Exp;
branches;
next	1.2;

1.2
date	2004.03.07.18.36.09;	author tg;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.22.20.07.01;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.07.01;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.36.04;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.16.42;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.27.16.31.32;	author tg;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.06.23.11.37.10;	author tg;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.07.14.12.06.04;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.22.58;	author tg;	state Exp;
branches;
next	1.1.9.2;

1.1.9.2
date	2004.03.05.22.27.02;	author tg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@merge OpenBSD; adapt MirOS BSD; fix french spelling to english
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c,v 1.118 2004/02/26 04:25:29 martin Exp $ */
/*
 * Copyright 2000 ATI Technologies Inc., Markham, Ontario, and
 *                VA Linux Systems Inc., Fremont, California.
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation on the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL ATI, VA LINUX SYSTEMS AND/OR
 * THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*
 * Authors:
 *   Kevin E. Martin <martin@@xfree86.org>
 *   Rickard E. Faith <faith@@valinux.com>
 *   Alan Hourihane <alanh@@fairlite.demon.co.uk>
 *
 * Credits:
 *
 *   Thanks to Ani Joshi <ajoshi@@shell.unixbox.com> for providing source
 *   code to his Radeon driver.  Portions of this file are based on the
 *   initialization code for that driver.
 *
 * References:
 *
 * !!!! FIXME !!!!
 *   RAGE 128 VR/ RAGE 128 GL Register Reference Manual (Technical
 *   Reference Manual P/N RRG-G04100-C Rev. 0.04), ATI Technologies: April
 *   1999.
 *
 *   RAGE 128 Software Development Manual (Technical Reference Manual P/N
 *   SDK-G04000 Rev. 0.01), ATI Technologies: June 1999.
 *
 * This server does not yet support these XFree86 4.0 features:
 * !!!! FIXME !!!!
 *   DDC1 & DDC2
 *   shadowfb (Note: dri uses shadowfb for another purpose in radeon_dri.c)
 *   overlay planes
 *
 * Modified by Marc Aurele La France (tsi@@xfree86.org) for ATI driver merge.
 */

				/* Driver data structures */
#include "radeon.h"
#include "radeon_macros.h"
#include "radeon_probe.h"
#include "radeon_reg.h"
#include "radeon_version.h"

#ifdef XF86DRI
#define _XF86DRI_SERVER_
#include "radeon_dri.h"
#include "radeon_sarea.h"
#endif

#include "fb.h"

				/* colormap initialization */
#include "micmap.h"
#include "dixstruct.h"

				/* X and server generic header files */
#include "xf86.h"
#include "xf86_OSproc.h"
#include "xf86PciInfo.h"
#include "xf86RAC.h"
#include "xf86Resources.h"
#include "xf86cmap.h"
#include "vbe.h"

				/* fbdevhw * vgaHW definitions */
#include "fbdevhw.h"
#include "vgaHW.h"

#ifndef MAX
#define MAX(a,b) ((a)>(b)?(a):(b))
#endif
#ifndef MIN
#define MIN(a,b) ((a)>(b)?(b):(a))
#endif

				/* Forward definitions for driver functions */
static Bool RADEONCloseScreen(int scrnIndex, ScreenPtr pScreen);
static Bool RADEONSaveScreen(ScreenPtr pScreen, int mode);
static void RADEONSave(ScrnInfoPtr pScrn);
static void RADEONRestore(ScrnInfoPtr pScrn);
static Bool RADEONModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode);
static void RADEONDisplayPowerManagementSet(ScrnInfoPtr pScrn,
					    int PowerManagementMode,
					    int flags);
static void RADEONInitDispBandwidth(ScrnInfoPtr pScrn);

typedef enum {
    OPTION_NOACCEL,
    OPTION_SW_CURSOR,
    OPTION_DAC_6BIT,
    OPTION_DAC_8BIT,
#ifdef XF86DRI
    OPTION_IS_PCI,
    OPTION_BUS_TYPE,
    OPTION_CP_PIO,
    OPTION_USEC_TIMEOUT,
    OPTION_AGP_MODE,
    OPTION_AGP_FW,
    OPTION_GART_SIZE,
    OPTION_RING_SIZE,
    OPTION_BUFFER_SIZE,
    OPTION_DEPTH_MOVE,
    OPTION_PAGE_FLIP,
    OPTION_NO_BACKBUFFER,
#endif
    OPTION_PANEL_OFF,
    OPTION_DDC_MODE,
    OPTION_MONITOR_LAYOUT,
    OPTION_IGNORE_EDID,
    OPTION_CRTC2_OVERLAY,
    OPTION_CLONE_MODE,
    OPTION_CLONE_HSYNC,
    OPTION_CLONE_VREFRESH,
    OPTION_FBDEV,
    OPTION_VIDEO_KEY,
    OPTION_DISP_PRIORITY,
    OPTION_PANEL_SIZE,
    OPTION_MIN_DOTCLOCK,
#ifdef __powerpc__
    OPTION_IBOOKHACKS
#endif
} RADEONOpts;

const OptionInfoRec RADEONOptions[] = {
    { OPTION_NOACCEL,        "NoAccel",          OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_SW_CURSOR,      "SWcursor",         OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_DAC_6BIT,       "Dac6Bit",          OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_DAC_8BIT,       "Dac8Bit",          OPTV_BOOLEAN, {0}, TRUE  },
#ifdef XF86DRI
    { OPTION_IS_PCI,         "ForcePCIMode",     OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_BUS_TYPE,       "BusType",          OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_CP_PIO,         "CPPIOMode",        OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_USEC_TIMEOUT,   "CPusecTimeout",    OPTV_INTEGER, {0}, FALSE },
    { OPTION_AGP_MODE,       "AGPMode",          OPTV_INTEGER, {0}, FALSE },
    { OPTION_AGP_FW,         "AGPFastWrite",     OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_GART_SIZE,      "AGPSize",          OPTV_INTEGER, {0}, FALSE },
    { OPTION_GART_SIZE,      "GARTSize",         OPTV_INTEGER, {0}, FALSE },
    { OPTION_RING_SIZE,      "RingSize",         OPTV_INTEGER, {0}, FALSE },
    { OPTION_BUFFER_SIZE,    "BufferSize",       OPTV_INTEGER, {0}, FALSE },
    { OPTION_DEPTH_MOVE,     "EnableDepthMoves", OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_PAGE_FLIP,      "EnablePageFlip",   OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_NO_BACKBUFFER,  "NoBackBuffer",     OPTV_BOOLEAN, {0}, FALSE },
#endif
    { OPTION_PANEL_OFF,      "PanelOff",         OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_DDC_MODE,       "DDCMode",          OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_MONITOR_LAYOUT, "MonitorLayout",    OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_IGNORE_EDID,    "IgnoreEDID",       OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_CRTC2_OVERLAY , "OverlayOnCRTC2",   OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_CLONE_MODE,     "CloneMode",        OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_CLONE_HSYNC,    "CloneHSync",       OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_CLONE_VREFRESH, "CloneVRefresh",    OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_FBDEV,          "UseFBDev",         OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_VIDEO_KEY,      "VideoKey",         OPTV_INTEGER, {0}, FALSE },
    { OPTION_DISP_PRIORITY,  "DisplayPriority",  OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_PANEL_SIZE,     "PanelSize",        OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_MIN_DOTCLOCK,   "ForceMinDotClock", OPTV_FREQ,    {0}, FALSE },
#ifdef __powerpc__
    { OPTION_IBOOKHACKS,     "iBookHacks",       OPTV_BOOLEAN, {0}, FALSE },
#endif
    { -1,                    NULL,               OPTV_NONE,    {0}, FALSE }
};

static const char *vgahwSymbols[] = {
    "vgaHWFreeHWRec",
    "vgaHWGetHWRec",
    "vgaHWGetIndex",
    "vgaHWLock",
    "vgaHWRestore",
    "vgaHWSave",
    "vgaHWUnlock",
    "vgaHWGetIOBase",
    NULL
};

static const char *fbdevHWSymbols[] = {
    "fbdevHWInit",
    "fbdevHWUseBuildinMode",

    "fbdevHWGetVidmem",

    "fbdevHWDPMSSet",

    /* colormap */
    "fbdevHWLoadPalette",
    /* ScrnInfo hooks */
    "fbdevHWAdjustFrame",
    "fbdevHWEnterVT",
    "fbdevHWLeaveVT",
    "fbdevHWModeInit",
    "fbdevHWRestore",
    "fbdevHWSave",
    "fbdevHWSwitchMode",
    "fbdevHWValidMode",

    "fbdevHWMapMMIO",
    "fbdevHWMapVidmem",
    "fbdevHWUnmapMMIO",
    "fbdevHWUnmapVidmem",

    NULL
};

static const char *ddcSymbols[] = {
    "xf86PrintEDID",
    "xf86DoEDID_DDC1",
    "xf86DoEDID_DDC2",
    NULL
};

static const char *fbSymbols[] = {
    "fbScreenInit",
    "fbPictureInit",
    NULL
};

static const char *xaaSymbols[] = {
    "XAACreateInfoRec",
    "XAADestroyInfoRec",
    "XAAInit",
    NULL
};

#if 0
static const char *xf8_32bppSymbols[] = {
    "xf86Overlay8Plus32Init",
    NULL
};
#endif

static const char *ramdacSymbols[] = {
    "xf86CreateCursorInfoRec",
    "xf86DestroyCursorInfoRec",
    "xf86ForceHWCursor",
    "xf86InitCursor",
    NULL
};

#ifdef XF86DRI
static const char *drmSymbols[] = {
    "drmGetInterruptFromBusID",
    "drmCtlInstHandler",
    "drmCtlUninstHandler",
    "drmAddBufs",
    "drmAddMap",
    "drmAgpAcquire",
    "drmAgpAlloc",
    "drmAgpBase",
    "drmAgpBind",
    "drmAgpDeviceId",
    "drmAgpEnable",
    "drmAgpFree",
    "drmAgpGetMode",
    "drmAgpRelease",
    "drmAgpUnbind",
    "drmAgpVendorId",
    "drmCommandNone",
    "drmCommandRead",
    "drmCommandWrite",
    "drmCommandWriteRead",
    "drmDMA",
    "drmFreeVersion",
    "drmGetLibVersion",
    "drmGetVersion",
    "drmMap",
    "drmMapBufs",
    "drmRadeonCleanupCP",
    "drmRadeonClear",
    "drmRadeonFlushIndirectBuffer",
    "drmRadeonInitCP",
    "drmRadeonResetCP",
    "drmRadeonStartCP",
    "drmRadeonStopCP",
    "drmRadeonWaitForIdleCP",
    "drmScatterGatherAlloc",
    "drmScatterGatherFree",
    "drmUnmap",
    "drmUnmapBufs",
    NULL
};

static const char *driSymbols[] = {
    "DRICloseScreen",
    "DRICreateInfoRec",
    "DRIDestroyInfoRec",
    "DRIFinishScreenInit",
    "DRIGetContext",
    "DRIGetDeviceInfo",
    "DRIGetSAREAPrivate",
    "DRILock",
    "DRIQueryVersion",
    "DRIScreenInit",
    "DRIUnlock",
    "GlxSetVisualConfigs",
    NULL
};

static const char *driShadowFBSymbols[] = {
    "ShadowFBInit",
    NULL
};
#endif

static const char *vbeSymbols[] = {
    "VBEInit",
    "vbeDoEDID",
    NULL
};

static const char *int10Symbols[] = {
    "xf86InitInt10",
    "xf86FreeInt10",
    "xf86int10Addr",
    NULL
};

static const char *i2cSymbols[] = {
    "xf86CreateI2CBusRec",
    "xf86I2CBusInit",
    NULL
};

void RADEONLoaderRefSymLists(void)
{
    /*
     * Tell the loader about symbols from other modules that this module might
     * refer to.
     */
    xf86LoaderRefSymLists(vgahwSymbols,
			  fbSymbols,
			  xaaSymbols,
#if 0
			  xf8_32bppSymbols,
#endif
			  ramdacSymbols,
#ifdef XF86DRI
			  drmSymbols,
			  driSymbols,
			  driShadowFBSymbols,
#endif
			  fbdevHWSymbols,
			  vbeSymbols,
			  int10Symbols,
			  i2cSymbols,
			  ddcSymbols,
			  NULL);
}

/* Established timings from EDID standard */
static struct
{
    int hsize;
    int vsize;
    int refresh;
} est_timings[] = {
    {1280, 1024, 75},
    {1024, 768, 75},
    {1024, 768, 70},
    {1024, 768, 60},
    {1024, 768, 87},
    {832, 624, 75},
    {800, 600, 75},
    {800, 600, 72},
    {800, 600, 60},
    {800, 600, 56},
    {640, 480, 75},
    {640, 480, 72},
    {640, 480, 67},
    {640, 480, 60},
    {720, 400, 88},
    {720, 400, 70},
};

static const RADEONTMDSPll default_tmds_pll[CHIP_FAMILY_LAST][4] =
{
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_UNKNOW*/
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_LEGACY*/
    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RADEON*/
    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV100*/
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_RS100*/
    {{15000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV200*/
    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RS200*/
    {{15000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_R200*/
    {{15500, 0x81b}, {0xffffffff, 0x83f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV250*/
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_RS300*/
    {{13000, 0x400f4}, {15000, 0x400f7}, {0xffffffff, 0x400f7/*0x40111*/}, {0, 0}},	/*CHIP_FAMILY_RV280*/
    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},		/*CHIP_FAMILY_R300*/
    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},		/*CHIP_FAMILY_R350*/
    {{15000, 0xb0155}, {0xffffffff, 0xb01cb}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV350*/
};

extern int gRADEONEntityIndex;

struct RADEONInt10Save {
	CARD32 MEM_CNTL;
	CARD32 MEMSIZE;
	CARD32 MPP_TB_CONFIG;
};

static Bool RADEONMapMMIO(ScrnInfoPtr pScrn);
static Bool RADEONUnmapMMIO(ScrnInfoPtr pScrn);

static RADEONEntPtr RADEONEntPriv(ScrnInfoPtr pScrn)
{
    DevUnion     *pPriv;
    RADEONInfoPtr  info   = RADEONPTR(pScrn);
    pPriv = xf86GetEntityPrivate(info->pEnt->index,
                                 gRADEONEntityIndex);
    return pPriv->ptr;
}

static void
RADEONPreInt10Save(ScrnInfoPtr pScrn, void **pPtr)
{
    RADEONInfoPtr  info   = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    CARD32 CardTmp;
    static struct RADEONInt10Save SaveStruct = { 0, 0, 0 };

    /* Save the values and zap MEM_CNTL */
    SaveStruct.MEM_CNTL = INREG(RADEON_MEM_CNTL);
    SaveStruct.MEMSIZE = INREG(RADEON_CONFIG_MEMSIZE);
    SaveStruct.MPP_TB_CONFIG = INREG(RADEON_MPP_TB_CONFIG);

    /*
     * Zap MEM_CNTL and set MPP_TB_CONFIG<31:24> to 4
     */
    OUTREG(RADEON_MEM_CNTL, 0);
    CardTmp = SaveStruct.MPP_TB_CONFIG & 0x00ffffffu;
    CardTmp |= 0x04 << 24;
    OUTREG(RADEON_MPP_TB_CONFIG, CardTmp);

    *pPtr = (void *)&SaveStruct;
}

static void
RADEONPostInt10Check(ScrnInfoPtr pScrn, void *ptr)
{
    RADEONInfoPtr  info   = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    struct RADEONInt10Save *pSave = ptr;
    CARD32 CardTmp;

    /* If we don't have a valid (non-zero) saved MEM_CNTL, get out now */
    if (!pSave || !pSave->MEM_CNTL)
	return;

    /*
     * If either MEM_CNTL is currently zero or inconistent (configured for
     * two channels with the two channels configured differently), restore
     * the saved registers.
     */
    CardTmp = INREG(RADEON_MEM_CNTL);
    if (!CardTmp ||
	((CardTmp & 1) &&
	 (((CardTmp >> 8) & 0xff) != ((CardTmp >> 24) & 0xff)))) {
	/* Restore the saved registers */
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Restoring MEM_CNTL (%08lx), setting to %08lx\n",
		   (unsigned long)CardTmp, (unsigned long)pSave->MEM_CNTL);
	OUTREG(RADEON_MEM_CNTL, pSave->MEM_CNTL);

	CardTmp = INREG(RADEON_CONFIG_MEMSIZE);
	if (CardTmp != pSave->MEMSIZE) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Restoring CONFIG_MEMSIZE (%08lx), setting to %08lx\n",
		       (unsigned long)CardTmp, (unsigned long)pSave->MEMSIZE);
	    OUTREG(RADEON_CONFIG_MEMSIZE, pSave->MEMSIZE);
	}
    }

    CardTmp = INREG(RADEON_MPP_TB_CONFIG);
    if ((CardTmp & 0xff000000u) != (pSave->MPP_TB_CONFIG & 0xff000000u)) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Restoring MPP_TB_CONFIG<31:24> (%02lx), setting to %02lx\n",
		   (unsigned long)CardTmp >> 24,
		   (unsigned long)pSave->MPP_TB_CONFIG >> 24);
	CardTmp &= 0x00ffffffu;
	CardTmp |= (pSave->MPP_TB_CONFIG & 0xff000000u);
	OUTREG(RADEON_MPP_TB_CONFIG, CardTmp);
    }
}

/* Allocate our private RADEONInfoRec */
static Bool RADEONGetRec(ScrnInfoPtr pScrn)
{
    if (pScrn->driverPrivate) return TRUE;

    pScrn->driverPrivate = xnfcalloc(sizeof(RADEONInfoRec), 1);
    return TRUE;
}

/* Free our private RADEONInfoRec */
static void RADEONFreeRec(ScrnInfoPtr pScrn)
{
    if (!pScrn || !pScrn->driverPrivate) return;
    xfree(pScrn->driverPrivate);
    pScrn->driverPrivate = NULL;
}

/* Memory map the MMIO region.  Used during pre-init and by RADEONMapMem,
 * below
 */
static Bool RADEONMapMMIO(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);

    if (info->FBDev) {
	info->MMIO = fbdevHWMapMMIO(pScrn);
    } else {
	info->MMIO = xf86MapPciMem(pScrn->scrnIndex,
				   VIDMEM_MMIO | VIDMEM_READSIDEEFFECT,
				   info->PciTag,
				   info->MMIOAddr,
				   RADEON_MMIOSIZE);
    }

    if (!info->MMIO) return FALSE;
    return TRUE;
}

/* Unmap the MMIO region.  Used during pre-init and by RADEONUnmapMem,
 * below
 */
static Bool RADEONUnmapMMIO(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);

    if (info->FBDev)
	fbdevHWUnmapMMIO(pScrn);
    else {
	xf86UnMapVidMem(pScrn->scrnIndex, info->MMIO, RADEON_MMIOSIZE);
    }
    info->MMIO = NULL;
    return TRUE;
}

/* Memory map the frame buffer.  Used by RADEONMapMem, below. */
static Bool RADEONMapFB(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);

    if (info->FBDev) {
	info->FB = fbdevHWMapVidmem(pScrn);
    } else {
	info->FB = xf86MapPciMem(pScrn->scrnIndex,
				 VIDMEM_FRAMEBUFFER,
				 info->PciTag,
				 info->LinearAddr,
				 info->FbMapSize);
    }

    if (!info->FB) return FALSE;
    return TRUE;
}

/* Unmap the frame buffer.  Used by RADEONUnmapMem, below. */
static Bool RADEONUnmapFB(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);

    if (info->FBDev)
	fbdevHWUnmapVidmem(pScrn);
    else
	xf86UnMapVidMem(pScrn->scrnIndex, info->FB, info->FbMapSize);
    info->FB = NULL;
    return TRUE;
}

/* Memory map the MMIO region and the frame buffer */
static Bool RADEONMapMem(ScrnInfoPtr pScrn)
{
    if (!RADEONMapMMIO(pScrn)) return FALSE;
    if (!RADEONMapFB(pScrn)) {
	RADEONUnmapMMIO(pScrn);
	return FALSE;
    }
    return TRUE;
}

/* Unmap the MMIO region and the frame buffer */
static Bool RADEONUnmapMem(ScrnInfoPtr pScrn)
{
    if (!RADEONUnmapMMIO(pScrn) || !RADEONUnmapFB(pScrn)) return FALSE;
    return TRUE;
}

/* This function is required to workaround a hardware bug in some (all?)
 * revisions of the R300.  This workaround should be called after every
 * CLOCK_CNTL_INDEX register access.  If not, register reads afterward
 * may not be correct.
 */
void R300CGWorkaround(ScrnInfoPtr pScrn) {
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    CARD32         save, tmp;

    save = INREG(RADEON_CLOCK_CNTL_INDEX);
    tmp = save & ~(0x3f | RADEON_PLL_WR_EN);
    OUTREG(RADEON_CLOCK_CNTL_INDEX, tmp);
    tmp = INREG(RADEON_CLOCK_CNTL_DATA);
    OUTREG(RADEON_CLOCK_CNTL_INDEX, save);
}

/* Read PLL information */
unsigned RADEONINPLL(ScrnInfoPtr pScrn, int addr)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    CARD32         data;

    OUTREG8(RADEON_CLOCK_CNTL_INDEX, addr & 0x3f);
    data = INREG(RADEON_CLOCK_CNTL_DATA);
    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);

    return data;
}

#if 0
/* Read PAL information (only used for debugging) */
static int RADEONINPAL(int idx)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    OUTREG(RADEON_PALETTE_INDEX, idx << 16);
    return INREG(RADEON_PALETTE_DATA);
}
#endif

/* Wait for vertical sync on primary CRTC */
void RADEONWaitForVerticalSync(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int            i;

    /* Clear the CRTC_VBLANK_SAVE bit */
    OUTREG(RADEON_CRTC_STATUS, RADEON_CRTC_VBLANK_SAVE_CLEAR);

    /* Wait for it to go back up */
    for (i = 0; i < RADEON_TIMEOUT/1000; i++) {
	if (INREG(RADEON_CRTC_STATUS) & RADEON_CRTC_VBLANK_SAVE) break;
	usleep(1);
    }
}

/* Wait for vertical sync on secondary CRTC */
void RADEONWaitForVerticalSync2(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int            i;

    /* Clear the CRTC2_VBLANK_SAVE bit */
    OUTREG(RADEON_CRTC2_STATUS, RADEON_CRTC2_VBLANK_SAVE_CLEAR);

    /* Wait for it to go back up */
    for (i = 0; i < RADEON_TIMEOUT/1000; i++) {
	if (INREG(RADEON_CRTC2_STATUS) & RADEON_CRTC2_VBLANK_SAVE) break;
	usleep(1);
    }
}

/* Blank screen */
static void RADEONBlank(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    if (!info->IsSecondary) {
	switch(info->DisplayType) {
	case MT_LCD:
	case MT_CRT:
	case MT_DFP:
	    OUTREGP(RADEON_CRTC_EXT_CNTL,
		    RADEON_CRTC_DISPLAY_DIS,
		    ~(RADEON_CRTC_DISPLAY_DIS));
	    break;

	case MT_NONE:
	default:
	    break;
	}
	if (info->Clone)
	    OUTREGP(RADEON_CRTC2_GEN_CNTL,
		    RADEON_CRTC2_DISP_DIS,
		    ~(RADEON_CRTC2_DISP_DIS));
    } else {
	OUTREGP(RADEON_CRTC2_GEN_CNTL,
		RADEON_CRTC2_DISP_DIS,
		~(RADEON_CRTC2_DISP_DIS));
    }
}

/* Unblank screen */
static void RADEONUnblank(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    if (!info->IsSecondary) {
	switch (info->DisplayType) {
	case MT_LCD:
	case MT_CRT:
	case MT_DFP:
	    OUTREGP(RADEON_CRTC_EXT_CNTL,
		    RADEON_CRTC_CRT_ON,
		    ~(RADEON_CRTC_DISPLAY_DIS));
	    break;

	case MT_NONE:
	default:
	    break;
	}
	if (info->Clone)
	    OUTREGP(RADEON_CRTC2_GEN_CNTL,
		    0,
		    ~(RADEON_CRTC2_DISP_DIS));
    } else {
	switch (info->DisplayType) {
	case MT_LCD:
	case MT_DFP:
	case MT_CRT:
	    OUTREGP(RADEON_CRTC2_GEN_CNTL,
		    0,
		    ~(RADEON_CRTC2_DISP_DIS));
	    break;

	case MT_NONE:
	default:
	    break;
	}
    }
}

/* Compute log base 2 of val */
int RADEONMinBits(int val)
{
    int  bits;

    if (!val) return 1;
    for (bits = 0; val; val >>= 1, ++bits);
    return bits;
}

/* Compute n/d with rounding */
static int RADEONDiv(int n, int d)
{
    return (n + (d / 2)) / d;
}

static RADEONMonitorType RADEONDisplayDDCConnected(ScrnInfoPtr pScrn, RADEONDDCType DDCType, xf86MonPtr* MonInfo)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    unsigned long DDCReg;
    RADEONMonitorType MonType = MT_NONE;
    int i, j;

    DDCReg = info->DDCReg;
    switch(DDCType)
    {
    case DDC_MONID:
	info->DDCReg = RADEON_GPIO_MONID;
	break;
    case DDC_DVI:
	info->DDCReg = RADEON_GPIO_DVI_DDC;
	break;
    case DDC_VGA:
	info->DDCReg = RADEON_GPIO_VGA_DDC;
	break;
    case DDC_CRT2:
	info->DDCReg = RADEON_GPIO_CRT2_DDC;
	break;
    default:
	info->DDCReg = DDCReg;
	return MT_NONE;
    }

    /* Read and output monitor info using DDC2 over I2C bus */
    if (info->pI2CBus && info->ddc2) {
	OUTREG(info->DDCReg, INREG(info->DDCReg) &
	       (CARD32)~(RADEON_GPIO_A_0 | RADEON_GPIO_A_1));

	/* For some old monitors (like Compaq Presario FP500), we need
	 * following process to initialize/stop DDC
	 */
	OUTREG(info->DDCReg, INREG(info->DDCReg) & ~(RADEON_GPIO_EN_1));
	for (j = 0; j < 3; j++) {
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_0));
	    usleep(13000);

	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_1));
	    for (i = 0; i < 10; i++) {
		usleep(15000);
		if (INREG(info->DDCReg) & RADEON_GPIO_Y_1)
		    break;
	    }
	    if (i == 10) continue;

	    usleep(15000);

	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_0);
	    usleep(15000);

	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_1);
	    usleep(15000);
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_0));
	    usleep(15000);
	    *MonInfo = xf86DoEDID_DDC2(pScrn->scrnIndex, info->pI2CBus);

	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_1);
	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_0);
	    usleep(15000);
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_1));
	    for (i = 0; i < 5; i++) {
		usleep(15000);
		if (INREG(info->DDCReg) & RADEON_GPIO_Y_1)
		    break;
	    }
	    usleep(15000);
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_0));
	    usleep(15000);

	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_1);
	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_0);
	    usleep(15000);
	    if(*MonInfo) break;
	}
    } else {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "DDC2/I2C is not properly initialized\n");
	MonType = MT_NONE;
    }

    if (*MonInfo) {
	if ((*MonInfo)->rawData[0x14] & 0x80) {
	    if (INREG(RADEON_LVDS_GEN_CNTL) & RADEON_LVDS_ON) MonType = MT_LCD;
	    else MonType = MT_DFP;
	} else MonType = MT_CRT;
    } else MonType = MT_NONE;

    info->DDCReg = DDCReg;

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "DDC Type: %d, Detected Type: %d\n", DDCType, MonType);

    return MonType;
}

static RADEONMonitorType
RADEONCrtIsPhysicallyConnected(ScrnInfoPtr pScrn, int IsCrtDac)
{
    RADEONInfoPtr info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int		  bConnected = 0;

    /* the monitor either wasn't connected or it is a non-DDC CRT.
     * try to probe it
     */
    if(IsCrtDac) {
	unsigned long ulOrigVCLK_ECP_CNTL;
	unsigned long ulOrigDAC_CNTL;
	unsigned long ulOrigDAC_EXT_CNTL;
	unsigned long ulOrigCRTC_EXT_CNTL;
	unsigned long ulData;
	unsigned long ulMask;

	ulOrigVCLK_ECP_CNTL = INPLL(pScrn, RADEON_VCLK_ECP_CNTL);

	ulData              = ulOrigVCLK_ECP_CNTL;
	ulData             &= ~(RADEON_PIXCLK_ALWAYS_ONb
				| RADEON_PIXCLK_DAC_ALWAYS_ONb);
	ulMask              = ~(RADEON_PIXCLK_ALWAYS_ONb
				|RADEON_PIXCLK_DAC_ALWAYS_ONb);
	OUTPLLP(pScrn, RADEON_VCLK_ECP_CNTL, ulData, ulMask);

	ulOrigCRTC_EXT_CNTL = INREG(RADEON_CRTC_EXT_CNTL);
	ulData              = ulOrigCRTC_EXT_CNTL;
	ulData             |= RADEON_CRTC_CRT_ON;
	OUTREG(RADEON_CRTC_EXT_CNTL, ulData);

	ulOrigDAC_EXT_CNTL = INREG(RADEON_DAC_EXT_CNTL);
	ulData             = ulOrigDAC_EXT_CNTL;
	ulData            &= ~RADEON_DAC_FORCE_DATA_MASK;
	ulData            |=  (RADEON_DAC_FORCE_BLANK_OFF_EN
			       |RADEON_DAC_FORCE_DATA_EN
			       |RADEON_DAC_FORCE_DATA_SEL_MASK);
	if ((info->ChipFamily == CHIP_FAMILY_RV250) ||
	    (info->ChipFamily == CHIP_FAMILY_RV280))
	    ulData |= (0x01b6 << RADEON_DAC_FORCE_DATA_SHIFT);
	else
	    ulData |= (0x01ac << RADEON_DAC_FORCE_DATA_SHIFT);

	OUTREG(RADEON_DAC_EXT_CNTL, ulData);

	ulOrigDAC_CNTL     = INREG(RADEON_DAC_CNTL);
	ulData             = ulOrigDAC_CNTL;
	ulData            |= RADEON_DAC_CMP_EN;
	ulData            &= ~(RADEON_DAC_RANGE_CNTL_MASK
			       | RADEON_DAC_PDWN);
	ulData            |= 0x2;
	OUTREG(RADEON_DAC_CNTL, ulData);

	usleep(1000);

	ulData     = INREG(RADEON_DAC_CNTL);
	bConnected =  (RADEON_DAC_CMP_OUTPUT & ulData)?1:0;

	ulData    = ulOrigVCLK_ECP_CNTL;
	ulMask    = 0xFFFFFFFFL;
	OUTPLLP(pScrn, RADEON_VCLK_ECP_CNTL, ulData, ulMask);

	OUTREG(RADEON_DAC_CNTL,      ulOrigDAC_CNTL     );
	OUTREG(RADEON_DAC_EXT_CNTL,  ulOrigDAC_EXT_CNTL );
	OUTREG(RADEON_CRTC_EXT_CNTL, ulOrigCRTC_EXT_CNTL);
    } else { /* TV DAC */

        /* This doesn't seem to work reliably (maybe worse on some OEM cards),
           for now we always return false. If one wants to connected a
           non-DDC monitor on the DVI port when CRT port is also connected,
           he will need to explicitly tell the driver in the config file
           with Option MonitorLayout.
        */
        bConnected = FALSE;

#if 0
	if (info->ChipFamily == CHIP_FAMILY_R200) {

	    unsigned long ulOrigGPIO_MONID;
	    unsigned long ulOrigFP2_GEN_CNTL;
	    unsigned long ulOrigDISP_OUTPUT_CNTL;
	    unsigned long ulOrigCRTC2_GEN_CNTL;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_A;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_B;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_C;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_D;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_E;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_F;
	    unsigned long ulOrigCRTC2_H_TOTAL_DISP;
	    unsigned long ulOrigCRTC2_V_TOTAL_DISP;
	    unsigned long ulOrigCRTC2_H_SYNC_STRT_WID;
	    unsigned long ulOrigCRTC2_V_SYNC_STRT_WID;
	    unsigned long ulData, i;

	    ulOrigGPIO_MONID = INREG(RADEON_GPIO_MONID);
	    ulOrigFP2_GEN_CNTL = INREG(RADEON_FP2_GEN_CNTL);
	    ulOrigDISP_OUTPUT_CNTL = INREG(RADEON_DISP_OUTPUT_CNTL);
	    ulOrigCRTC2_GEN_CNTL = INREG(RADEON_CRTC2_GEN_CNTL);
	    ulOrigDISP_LIN_TRANS_GRPH_A = INREG(RADEON_DISP_LIN_TRANS_GRPH_A);
	    ulOrigDISP_LIN_TRANS_GRPH_B = INREG(RADEON_DISP_LIN_TRANS_GRPH_B);
	    ulOrigDISP_LIN_TRANS_GRPH_C = INREG(RADEON_DISP_LIN_TRANS_GRPH_C);
	    ulOrigDISP_LIN_TRANS_GRPH_D = INREG(RADEON_DISP_LIN_TRANS_GRPH_D);
	    ulOrigDISP_LIN_TRANS_GRPH_E = INREG(RADEON_DISP_LIN_TRANS_GRPH_E);
	    ulOrigDISP_LIN_TRANS_GRPH_F = INREG(RADEON_DISP_LIN_TRANS_GRPH_F);

	    ulOrigCRTC2_H_TOTAL_DISP = INREG(RADEON_CRTC2_H_TOTAL_DISP);
	    ulOrigCRTC2_V_TOTAL_DISP = INREG(RADEON_CRTC2_V_TOTAL_DISP);
	    ulOrigCRTC2_H_SYNC_STRT_WID = INREG(RADEON_CRTC2_H_SYNC_STRT_WID);
	    ulOrigCRTC2_V_SYNC_STRT_WID = INREG(RADEON_CRTC2_V_SYNC_STRT_WID);

	    ulData     = INREG(RADEON_GPIO_MONID);
	    ulData    &= ~RADEON_GPIO_A_0;
	    OUTREG(RADEON_GPIO_MONID, ulData);

	    OUTREG(RADEON_FP2_GEN_CNTL, 0x0a000c0c);

	    OUTREG(RADEON_DISP_OUTPUT_CNTL, 0x00000012);

	    OUTREG(RADEON_CRTC2_GEN_CNTL, 0x06000000);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_A, 0x00000000);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_B, 0x000003f0);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_C, 0x00000000);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_D, 0x000003f0);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_E, 0x00000000);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_F, 0x000003f0);
	    OUTREG(RADEON_CRTC2_H_TOTAL_DISP, 0x01000008);
	    OUTREG(RADEON_CRTC2_H_SYNC_STRT_WID, 0x00000800);
	    OUTREG(RADEON_CRTC2_V_TOTAL_DISP, 0x00080001);
	    OUTREG(RADEON_CRTC2_V_SYNC_STRT_WID, 0x00000080);

	    for (i = 0; i < 200; i++) {
		ulData     = INREG(RADEON_GPIO_MONID);
		bConnected = (ulData & RADEON_GPIO_Y_0)?1:0;
		if (!bConnected) break;

		usleep(1000);
	    }

	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_A, ulOrigDISP_LIN_TRANS_GRPH_A);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_B, ulOrigDISP_LIN_TRANS_GRPH_B);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_C, ulOrigDISP_LIN_TRANS_GRPH_C);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_D, ulOrigDISP_LIN_TRANS_GRPH_D);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_E, ulOrigDISP_LIN_TRANS_GRPH_E);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_F, ulOrigDISP_LIN_TRANS_GRPH_F);
	    OUTREG(RADEON_CRTC2_H_TOTAL_DISP, ulOrigCRTC2_H_TOTAL_DISP);
	    OUTREG(RADEON_CRTC2_V_TOTAL_DISP, ulOrigCRTC2_V_TOTAL_DISP);
	    OUTREG(RADEON_CRTC2_H_SYNC_STRT_WID, ulOrigCRTC2_H_SYNC_STRT_WID);
	    OUTREG(RADEON_CRTC2_V_SYNC_STRT_WID, ulOrigCRTC2_V_SYNC_STRT_WID);
	    OUTREG(RADEON_CRTC2_GEN_CNTL, ulOrigCRTC2_GEN_CNTL);
	    OUTREG(RADEON_DISP_OUTPUT_CNTL, ulOrigDISP_OUTPUT_CNTL);
	    OUTREG(RADEON_FP2_GEN_CNTL, ulOrigFP2_GEN_CNTL);
	    OUTREG(RADEON_GPIO_MONID, ulOrigGPIO_MONID);
        } else {
	    unsigned long ulOrigPIXCLKSDATA;
	    unsigned long ulOrigTV_MASTER_CNTL;
	    unsigned long ulOrigTV_DAC_CNTL;
	    unsigned long ulOrigTV_PRE_DAC_MUX_CNTL;
	    unsigned long ulOrigDAC_CNTL2;
	    unsigned long ulData;
	    unsigned long ulMask;

	    ulOrigPIXCLKSDATA = INPLL(pScrn, RADEON_PIXCLKS_CNTL);

	    ulData            = ulOrigPIXCLKSDATA;
	    ulData           &= ~(RADEON_PIX2CLK_ALWAYS_ONb
				  | RADEON_PIX2CLK_DAC_ALWAYS_ONb);
	    ulMask            = ~(RADEON_PIX2CLK_ALWAYS_ONb
			  | RADEON_PIX2CLK_DAC_ALWAYS_ONb);
	    OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL, ulData, ulMask);

	    ulOrigTV_MASTER_CNTL = INREG(RADEON_TV_MASTER_CNTL);
	    ulData               = ulOrigTV_MASTER_CNTL;
	    ulData              &= ~RADEON_TVCLK_ALWAYS_ONb;
	    OUTREG(RADEON_TV_MASTER_CNTL, ulData);

	    ulOrigDAC_CNTL2 = INREG(RADEON_DAC_CNTL2);
	    ulData          = ulOrigDAC_CNTL2;
	    ulData          &= ~RADEON_DAC2_DAC2_CLK_SEL;
	    OUTREG(RADEON_DAC_CNTL2, ulData);

	    ulOrigTV_DAC_CNTL = INREG(RADEON_TV_DAC_CNTL);

	    ulData  = 0x00880213;
	    OUTREG(RADEON_TV_DAC_CNTL, ulData);

	    ulOrigTV_PRE_DAC_MUX_CNTL = INREG(RADEON_TV_PRE_DAC_MUX_CNTL);

	    ulData  =  (RADEON_Y_RED_EN
			| RADEON_C_GRN_EN
			| RADEON_CMP_BLU_EN
			| RADEON_RED_MX_FORCE_DAC_DATA
			| RADEON_GRN_MX_FORCE_DAC_DATA
			| RADEON_BLU_MX_FORCE_DAC_DATA);
            if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		(info->ChipFamily == CHIP_FAMILY_R350) ||
		(info->ChipFamily == CHIP_FAMILY_RV350))
		ulData |= 0x180 << RADEON_TV_FORCE_DAC_DATA_SHIFT;
	    else
		ulData |= 0x1f5 << RADEON_TV_FORCE_DAC_DATA_SHIFT;
	    OUTREG(RADEON_TV_PRE_DAC_MUX_CNTL, ulData);

	    usleep(1000);

	    ulData     = INREG(RADEON_TV_DAC_CNTL);
	    bConnected = (ulData & RADEON_TV_DAC_CMPOUT)?1:0;

	    ulData    = ulOrigPIXCLKSDATA;
	    ulMask    = 0xFFFFFFFFL;
	    OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL, ulData, ulMask);

	    OUTREG(RADEON_TV_MASTER_CNTL, ulOrigTV_MASTER_CNTL);
	    OUTREG(RADEON_DAC_CNTL2, ulOrigDAC_CNTL2);
	    OUTREG(RADEON_TV_DAC_CNTL, ulOrigTV_DAC_CNTL);
	    OUTREG(RADEON_TV_PRE_DAC_MUX_CNTL, ulOrigTV_PRE_DAC_MUX_CNTL);
	}
#endif
    }

    return(bConnected ? MT_CRT : MT_NONE);
}

static void RADEONQueryConnectedDisplays(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    const char *s;
    Bool ignore_edid = FALSE, ddc_crt2_used = FALSE;

#define RADEON_BIOS8(v)  (info->VBIOS[v])
#define RADEON_BIOS16(v) (info->VBIOS[v] | \
			  (info->VBIOS[(v) + 1] << 8))
#define RADEON_BIOS32(v) (info->VBIOS[v] | \
			  (info->VBIOS[(v) + 1] << 8) | \
			  (info->VBIOS[(v) + 2] << 16) | \
			  (info->VBIOS[(v) + 3] << 24))

    pRADEONEnt->MonType1 = MT_NONE;
    pRADEONEnt->MonType2 = MT_NONE;
    pRADEONEnt->MonInfo1 = NULL;
    pRADEONEnt->MonInfo2 = NULL;
    pRADEONEnt->ReversedDAC = FALSE;
    pRADEONEnt->ReversedTMDS = FALSE;

    /* IgnoreEDID option is different from NoDDC options used by DDC module
     * When IgnoreEDID is used, monitor detection will still use DDC
     * detection, but all EDID data will not be used in mode validation.
     */
    if (xf86GetOptValBool(info->Options, OPTION_IGNORE_EDID, &ignore_edid)) {
	if (ignore_edid)
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       "IgnoreEDID is specified, EDID data will be ignored\n");
    }

    /*
     * MonitorLayout option takes a string for two monitors connected in following format:
     * Option "MonitorLayout" "primary-port-display, secondary-port-display"
     * primary and secondary port displays can have one of following:
     *    NONE, CRT, LVDS, TMDS
     * With this option, driver will bring up monitors as specified,
     * not using auto-detection routines to probe monitors.
     */

    /* current monitor mapping scheme:
     *  Two displays connected:
     *     Primary Port:
     *     CRTC1 -> FP/TMDS  -> DVI port -> TMDS panel  --> Primary or
     *     CRTC1 -> FP/LVDS  -> Int. LCD -> LVDS panel  --> Primary or
     *     CRTC1 -> TV DAC   -> DVI port -> CRT monitor --> Primary
     *
     *     Secondary Port
     *     CRTC2 -> CRT DAC  -> VGA port -> CRT monitor --> Secondary or
     *     CRTC2 -> FP2/Ext. -> DVI port -> TMDS panel  --> Secondary
     *
     *  Only DVI (or Int. LDC) conneced:
     *     CRTC1 -> FP/TMDS  -> DVI port -> TMDS panel  --> Primary or
     *     CRTC1 -> FP/LVDS  -> Int. LCD -> LVDS panel  --> Primary or
     *     CRTC1 -> TV DAC   -> DVI port -> CRT monitor --> Primary
     *
     *  Only VGA (can be DVI on some dual-DVI boards) connected:
     *     CRTC1 -> CRT DAC  -> VGA port -> CRT monitor --> Primary or
     *     CRTC1 -> FP2/Ext. -> DVI port -> TMDS panel  --> Primary (not supported)
     *
     * Note, this is different from Windows scheme where
     *   if a digital panel is connected to DVI port, DVI will be the 1st port
     *   otherwise, VGA port will be treated as 1st port
     *
     *   Here we always treat DVI port as primary if both ports are connected.
     *   When only one port is connected, it will be treated as
     *   primary regardless which port or what type of display is involved.
     */

    if ((s = xf86GetOptValString(info->Options, OPTION_MONITOR_LAYOUT))) {
	char s1[5], s2[5];
	int i = 0, second = 0;

	/* When using user specified monitor types, we will not do DDC detection
	 *
	 */
	do {
	    switch(*s)
            {
            case ',':
		s1[i] = '\0';
		i = 0;
		second = 1;
		break;
	    case ' ':
	    case '\t':
	    case '\n':
	    case '\r':
		break;
	    default:
		if (second)
		    s2[i] = *s;
		else
		    s1[i] = *s;
		i++;
		if (i == 4) break;
	    }
	} while(*s++);
	s2[i] = '\0';

	if (strcmp(s1, "NONE") == 0)
	    pRADEONEnt->MonType1 = MT_NONE;
	else if (strcmp(s1, "CRT") == 0)
	    pRADEONEnt->MonType1 = MT_CRT;
	else if (strcmp(s1, "TMDS") == 0)
	    pRADEONEnt->MonType1 = MT_DFP;
	else if (strcmp(s1, "LVDS") == 0)
	    pRADEONEnt->MonType1 = MT_LCD;
	else
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Invalid Monitor type specified for 1st port \n");
	if (strcmp(s2, "NONE") == 0)
	    pRADEONEnt->MonType2 = MT_NONE;
	else if (strcmp(s2, "CRT") == 0)
	    pRADEONEnt->MonType2 = MT_CRT;
	else if (strcmp(s2, "TMDS") == 0)
	    pRADEONEnt->MonType2 = MT_DFP;
	else if (strcmp(s2, "LVDS") == 0)
	    pRADEONEnt->MonType2 = MT_LCD;
	else
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Invalid Monitor type specified for 2nd port \n");

	if (!ignore_edid) {
	    if (pRADEONEnt->MonType1)  /* assuming the first port using DDC_DVI */
		if(!RADEONDisplayDDCConnected(pScrn, DDC_DVI, &pRADEONEnt->MonInfo1)) {
		    RADEONDisplayDDCConnected(pScrn, DDC_CRT2, &pRADEONEnt->MonInfo1);
		    ddc_crt2_used = TRUE;
		}
	    if (pRADEONEnt->MonType2) {  /* assuming the second port using DDC_VGA/DDC_CRT2 */
		if(!RADEONDisplayDDCConnected(pScrn, DDC_VGA, &pRADEONEnt->MonInfo2))
		    if (!ddc_crt2_used)
			RADEONDisplayDDCConnected(pScrn, DDC_CRT2, &pRADEONEnt->MonInfo2);
	    }
	}

	if (!pRADEONEnt->MonType1) {
	    if (pRADEONEnt->MonType2) {
		pRADEONEnt->MonType1 = pRADEONEnt->MonType2;
		pRADEONEnt->MonInfo1 = pRADEONEnt->MonInfo2;
	    } else {
		pRADEONEnt->MonType1 = MT_CRT;
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                       "No valid monitor specified, force to CRT on 1st port\n");
	    }
	    pRADEONEnt->MonType2 = MT_NONE;
	    pRADEONEnt->MonInfo2 = NULL;
	}
    } else {
	/* Auto detection */
	int i;
	CARD32 tmp;

	/* Old single head radeon cards */
        if(!info->HasCRTC2) {
	    if((pRADEONEnt->MonType1 = RADEONDisplayDDCConnected(pScrn, DDC_DVI, &pRADEONEnt->MonInfo1)));
	    else if((pRADEONEnt->MonType1 = RADEONDisplayDDCConnected(pScrn, DDC_VGA, &pRADEONEnt->MonInfo1)));
	    else if((pRADEONEnt->MonType1 = RADEONDisplayDDCConnected(pScrn, DDC_CRT2, &pRADEONEnt->MonInfo1)));
	    else if (pInt10) {
		if (xf86LoadSubModule(pScrn, "vbe")) {
		    vbeInfoPtr  pVbe;
		    pVbe = VBEInit(pInt10, info->pEnt->index);
		    if (pVbe) {
			for (i = 0; i < 5; i++) {
			    pRADEONEnt->MonInfo1 = vbeDoEDID(pVbe, NULL);
			}
			if (pRADEONEnt->MonInfo1->rawData[0x14] & 0x80)
			    pRADEONEnt->MonType1 = MT_DFP;
			else pRADEONEnt->MonType1 = MT_CRT;
		    }
		}
	    } else
		pRADEONEnt->MonType1 = MT_CRT;

	    pRADEONEnt->HasSecondary = FALSE;
	    if (!ignore_edid) {
		if (pRADEONEnt->MonInfo1) {
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitor1 EDID data ---------------------------\n");
		    xf86PrintEDID( pRADEONEnt->MonInfo1 );
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "End of Monitor1 EDID data --------------------\n");
		}
	    }
	    return;
	}

	/* Normally the port uses DDC_DVI connected with TVDAC,
	 * But this is not true for OEM cards which have TVDAC and CRT DAC reversed.
	 * If that's the case, we need also reverse the port arrangement.
	 * BIOS settings are supposed report this correctly, work fine for all cards tested.
	 * But there may be some exceptions, in that case, user can reverse their monitor
	 * definition in config file to correct the problem.
	 */
	if (info->VBIOS && (tmp = RADEON_BIOS16(info->FPBIOSstart + 0x50))) {
	    for (i = 1; i < 4; i++) {
		unsigned int tmp0;
		if (!RADEON_BIOS8(tmp + i*2) && i > 1) break;
		tmp0 = RADEON_BIOS16(tmp + i*2);
		if ((!(tmp0 & 0x01)) && (((tmp0 >> 8) & 0xf) == DDC_DVI)) {
		    pRADEONEnt->ReversedDAC = TRUE;
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Reversed DACs detected\n");
		}
		if ((((tmp0 >> 8) & 0x0f) == DDC_DVI ) && ((tmp0 >> 4) & 0x1)) {
		    pRADEONEnt->ReversedTMDS = TRUE;
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Reversed TMDS detected\n");
		}
	    }
	}

	/* Primary Head (DVI or Laptop Int. panel)*/
	/* A ddc capable display connected on DVI port */
	if((pRADEONEnt->MonType1 = RADEONDisplayDDCConnected(pScrn, DDC_DVI, &pRADEONEnt->MonInfo1)));
	else if((pRADEONEnt->MonType1 =
		 RADEONDisplayDDCConnected(pScrn, DDC_CRT2, &pRADEONEnt->MonInfo1))) {
	  ddc_crt2_used = TRUE;
	} else if ((info->IsMobility) &&
		   (info->VBIOS && (INREG(RADEON_BIOS_4_SCRATCH) & 4))) {
	    /* non-DDC laptop panel connected on primary */
	    pRADEONEnt->MonType1 = MT_LCD;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Non-DDC laptop panel detected\n");
	} else {
	    /* CRT on DVI, TODO: not reliable, make it always return false for now*/
	    pRADEONEnt->MonType1 = RADEONCrtIsPhysicallyConnected(pScrn, pRADEONEnt->ReversedDAC);
	}

	/* Secondary Head (mostly VGA, can be DVI on some OEM boards)*/
	if((pRADEONEnt->MonType2 =
	    RADEONDisplayDDCConnected(pScrn, DDC_VGA, &pRADEONEnt->MonInfo2)));
	else if(!ddc_crt2_used)
	  pRADEONEnt->MonType2 =
		 RADEONDisplayDDCConnected(pScrn, DDC_CRT2, &pRADEONEnt->MonInfo2);
	if (!pRADEONEnt->MonType2)
	    pRADEONEnt->MonType2 = RADEONCrtIsPhysicallyConnected(pScrn, !pRADEONEnt->ReversedDAC);

	if(pRADEONEnt->ReversedTMDS) {
	    /* always keep internal TMDS as primary head */
	    if (pRADEONEnt->MonType1 == MT_DFP ||
		pRADEONEnt->MonType2 == MT_DFP) {
		int tmp1 = pRADEONEnt->MonType1;
		xf86MonPtr MonInfo = pRADEONEnt->MonInfo1;
		pRADEONEnt->MonInfo1 = pRADEONEnt->MonInfo2;
		pRADEONEnt->MonInfo2 = MonInfo;
		pRADEONEnt->MonType1 = pRADEONEnt->MonType2;
		pRADEONEnt->MonType2 = tmp1;
		if ((pRADEONEnt->MonType1 == MT_CRT) ||
		    (pRADEONEnt->MonType2 == MT_CRT)) {
		    pRADEONEnt->ReversedDAC ^= 1;
		}
	    }
	}

	/* no display detected on DVI port*/
	if (pRADEONEnt->MonType1 == MT_NONE) {
	    if (pRADEONEnt->MonType2 != MT_NONE) {
		/* Only one detected on VGA, let it to be primary */
		pRADEONEnt->MonType1 = pRADEONEnt->MonType2;
		pRADEONEnt->MonInfo1 = pRADEONEnt->MonInfo2;
		pRADEONEnt->MonType2 = MT_NONE;
		pRADEONEnt->MonInfo2 = NULL;
	    } else {
		/* Non detected, Default to a CRT connected */
		pRADEONEnt->MonType1 = MT_CRT;
	    }
	}
    }

    if(s) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Displays Configured by MonitorLayout: \n\tMonitor1--Type %d, Monitor2--Type %d\n\n",
		   pRADEONEnt->MonType1, pRADEONEnt->MonType2);
    } else {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Displays Detected: Monitor1--Type %d, Monitor2--Type %d\n\n",
		   pRADEONEnt->MonType1, pRADEONEnt->MonType2);
    }

    if(ignore_edid) {
	pRADEONEnt->MonInfo1 = NULL;
	pRADEONEnt->MonInfo2 = NULL;
    }

    if (!ignore_edid) {
	if (pRADEONEnt->MonInfo1) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitor1 EDID data ---------------------------\n");
	    xf86PrintEDID( pRADEONEnt->MonInfo1 );
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "End of Monitor1 EDID data --------------------\n");
	}
	if (pRADEONEnt->MonInfo2) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitor2 EDID data ---------------------------\n");
	    xf86PrintEDID( pRADEONEnt->MonInfo2 );
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "End of Monitor2 EDID data --------------------\n");
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "\n");

    info->OverlayOnCRTC2 = FALSE;
   if (xf86ReturnOptValBool(info->Options, OPTION_CRTC2_OVERLAY, FALSE)) {
	info->OverlayOnCRTC2 = TRUE;
    }

    if (pRADEONEnt->MonType2 == MT_NONE)
	pRADEONEnt->HasSecondary = FALSE;
}


/* Read the Video BIOS block and the FP registers (if applicable). */
static Bool RADEONGetBIOSParameters(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
{
    RADEONInfoPtr  info            = RADEONPTR(pScrn);
    unsigned long  tmp, i;

    if (!(info->VBIOS = xalloc(RADEON_VBIOS_SIZE))) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Cannot allocate space for hold Video BIOS!\n");
	return FALSE;
    }

    if (pInt10) {
	info->BIOSAddr = pInt10->BIOSseg << 4;
	(void)memcpy(info->VBIOS, xf86int10Addr(pInt10, info->BIOSAddr),
		     RADEON_VBIOS_SIZE);
    } else {
	xf86ReadPciBIOS(0, info->PciTag, 0, info->VBIOS, RADEON_VBIOS_SIZE);
	if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Video BIOS not detected in PCI space!\n");
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Attempting to read Video BIOS from "
		       "legacy ISA space!\n");
	    info->BIOSAddr = 0x000c0000;
	    xf86ReadDomainMemory(info->PciTag, info->BIOSAddr,
				 RADEON_VBIOS_SIZE, info->VBIOS);
	}
    }

    if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
	xfree(info->VBIOS);
	info->FPBIOSstart = 0;
	info->VBIOS = NULL;
	info->BIOSAddr = 0x00000000;
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Video BIOS not found!\n");
    } else
	info->FPBIOSstart = RADEON_BIOS16(0x48);
    info->OverlayOnCRTC2 = FALSE;

    if (!info->IsSecondary)
	RADEONQueryConnectedDisplays(pScrn, pInt10);

    {
	RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);

	info->Clone = FALSE;
	info->CloneType = MT_NONE;

	if(info->HasCRTC2) {
	    if(info->IsSecondary) {
		info->DisplayType = (RADEONMonitorType)pRADEONEnt->MonType2;
		if(info->DisplayType == MT_NONE) return FALSE;
	    } else {
		info->DisplayType = (RADEONMonitorType)pRADEONEnt->MonType1;

		if(!pRADEONEnt->HasSecondary) {
		    info->CloneType = (RADEONMonitorType)pRADEONEnt->MonType2;
		    if (info->CloneType != MT_NONE)
			info->Clone = TRUE;
		}
	    }
	} else {
	    info->DisplayType = (RADEONMonitorType)pRADEONEnt->MonType1;
	}

	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%s Display == Type %d\n",
		   (info->IsSecondary ? "Secondary" : "Primary"),
		   info->DisplayType);

	if (info->Clone)
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Clone Display == Type %d\n",
		       info->CloneType);

	info->HBlank     = 0;
	info->HOverPlus  = 0;
	info->HSyncWidth = 0;
	info->VBlank     = 0;
	info->VOverPlus  = 0;
	info->VSyncWidth = 0;
	info->DotClock   = 0;
	info->UseBiosDividers = FALSE;

	if (info->DisplayType == MT_LCD && info->VBIOS &&
	    !(xf86GetOptValString(info->Options, OPTION_PANEL_SIZE))) {
	    tmp = RADEON_BIOS16(info->FPBIOSstart + 0x40);
            if (!tmp) {
		info->PanelPwrDly = 200;
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                           "No Panel Info Table found in BIOS!\n");
            } else {
		char  stmp[30];
		int   tmp0;

		for (i = 0; i < 24; i++)
		    stmp[i] = RADEON_BIOS8(tmp+i+1);
		stmp[24] = 0;

		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                           "Panel ID string: %s\n", stmp);

		info->PanelXRes = RADEON_BIOS16(tmp+25);
		info->PanelYRes = RADEON_BIOS16(tmp+27);
		xf86DrvMsg(0, X_INFO, "Panel Size from BIOS: %dx%d\n",
			   info->PanelXRes, info->PanelYRes);

		info->PanelPwrDly = RADEON_BIOS16(tmp+44);
		if (info->PanelPwrDly > 2000 || info->PanelPwrDly < 0)
		    info->PanelPwrDly = 2000;

		/* some panels only work well with certain divider combinations.
		 */
		info->RefDivider = RADEON_BIOS16(tmp+46);
		info->PostDivider = RADEON_BIOS8(tmp+48);
		info->FeedbackDivider = RADEON_BIOS16(tmp+49);
		if ((info->RefDivider != 0) &&
		    (info->FeedbackDivider > 3)) {
		  info->UseBiosDividers = TRUE;
		  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			     "BIOS provided dividers will be used.\n");
		}

		/* We don't use a while loop here just in case we have a corrupted BIOS image.
		   The max number of table entries is 23 at present, but may grow in future.
		   To ensure it works with future revisions we loop it to 32.
		*/
		for (i = 0; i < 32; i++) {
		    tmp0 = RADEON_BIOS16(tmp+64+i*2);
		    if (tmp0 == 0) break;
		    if ((RADEON_BIOS16(tmp0) == info->PanelXRes) &&
			(RADEON_BIOS16(tmp0+2) == info->PanelYRes)) {
			info->HBlank     = (RADEON_BIOS16(tmp0+17) -
					    RADEON_BIOS16(tmp0+19)) * 8;
			info->HOverPlus  = (RADEON_BIOS16(tmp0+21) -
					    RADEON_BIOS16(tmp0+19) - 1) * 8;
			info->HSyncWidth = RADEON_BIOS8(tmp0+23) * 8;
			info->VBlank     = (RADEON_BIOS16(tmp0+24) -
					    RADEON_BIOS16(tmp0+26));
			info->VOverPlus  = ((RADEON_BIOS16(tmp0+28) & 0x7ff) -
					    RADEON_BIOS16(tmp0+26));
			info->VSyncWidth = ((RADEON_BIOS16(tmp0+28) & 0xf800) >> 11);
			info->DotClock   = RADEON_BIOS16(tmp0+9) * 10;
			info->Flags = 0;
		    }
		}

		if (info->DotClock == 0) {
		    DisplayModePtr  tmp_mode = NULL;
		    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			       "No valid timing info from BIOS.\n");
		    /* No timing information for the native mode,
		       use whatever specified in the Modeline.
		       If no Modeline specified, we'll just pick
		       the VESA mode at 60Hz refresh rate which
		       is likely to be the best for a flat panel.
		    */
		    tmp_mode = pScrn->monitor->Modes;
		    while(tmp_mode) {
			if ((tmp_mode->HDisplay == info->PanelXRes) &&
			    (tmp_mode->VDisplay == info->PanelYRes)) {

			    float  refresh =
				(float)tmp_mode->Clock * 1000.0 / tmp_mode->HTotal / tmp_mode->VTotal;
			    if ((abs(60.0 - refresh) < 1.0) ||
				(tmp_mode->type == 0)) {
				info->HBlank     = tmp_mode->HTotal - tmp_mode->HDisplay;
				info->HOverPlus  = tmp_mode->HSyncStart - tmp_mode->HDisplay;
				info->HSyncWidth = tmp_mode->HSyncEnd - tmp_mode->HSyncStart;
				info->VBlank     = tmp_mode->VTotal - tmp_mode->VDisplay;
				info->VOverPlus  = tmp_mode->VSyncStart - tmp_mode->VDisplay;
				info->VSyncWidth = tmp_mode->VSyncEnd - tmp_mode->VSyncStart;
				info->DotClock   = tmp_mode->Clock;
				info->Flags = 0;
				break;
			    }
			    tmp_mode = tmp_mode->next;
			}
		    }
		    if ((info->DotClock == 0) && !pRADEONEnt->MonInfo1) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				   "Panel size is not correctly detected.\n"
				   "Please try to use PanelSize option for correct settings.\n");
			return FALSE;
		    }
		}
	    }
	}
    }

    if (info->VBIOS) {
	tmp = RADEON_BIOS16(info->FPBIOSstart + 0x30);
	info->sclk = RADEON_BIOS16(tmp + 8) / 100.0;
	info->mclk = RADEON_BIOS16(tmp + 10) / 100.0;
    } else {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "No valid info for SCLK/MCLK for display bandwidth calculation.\n");
	info->sclk = 200.00;
	info->mclk = 200.00;
    }

    return TRUE;
}

static Bool RADEONProbePLLParameters(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONPLLPtr  pll  = &info->pll;
    unsigned char *RADEONMMIO = info->MMIO;
    unsigned char ppll_div_sel;
    unsigned Nx, M;
    unsigned xclk, tmp, ref_div;
    int hTotal, vTotal, num, denom, m, n;
    float hz, vclk, xtal;
    long start_secs, start_usecs, stop_secs, stop_usecs, total_usecs;
    int i;

    for(i=0; i<1000000; i++)
	if (((INREG(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) == 0)
	    break;

    xf86getsecs(&start_secs, &start_usecs);

    for(i=0; i<1000000; i++)
	if (((INREG(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) != 0)
	    break;

    for(i=0; i<1000000; i++)
	if (((INREG(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) == 0)
	    break;

    xf86getsecs(&stop_secs, &stop_usecs);

    total_usecs = abs(stop_usecs - start_usecs);
    hz = 1000000/total_usecs;

    hTotal = ((INREG(RADEON_CRTC_H_TOTAL_DISP) & 0x1ff) + 1) * 8;
    vTotal = ((INREG(RADEON_CRTC_V_TOTAL_DISP) & 0x3ff) + 1);
    vclk = (float)(hTotal * (float)(vTotal * hz));

    switch((INPLL(pScrn, RADEON_PPLL_REF_DIV) & 0x30000) >> 16) {
    case 0:
    default:
        num = 1;
        denom = 1;
        break;
    case 1:
        n = ((INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV) >> 16) & 0xff);
        m = (INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV) & 0xff);
        num = 2*n;
        denom = 2*m;
        break;
    case 2:
        n = ((INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV) >> 8) & 0xff);
        m = (INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV) & 0xff);
        num = 2*n;
        denom = 2*m;
        break;
     }

    OUTREG(RADEON_CLOCK_CNTL_INDEX, 1);
    ppll_div_sel = INREG8(RADEON_CLOCK_CNTL_DATA + 1) & 0x3;

    n = (INPLL(pScrn, RADEON_PPLL_DIV_0 + ppll_div_sel) & 0x7ff);
    m = (INPLL(pScrn, RADEON_PPLL_REF_DIV) & 0x3ff);

    num *= n;
    denom *= m;

    switch ((INPLL(pScrn, RADEON_PPLL_DIV_0 + ppll_div_sel) >> 16) & 0x7) {
    case 1:
        denom *= 2;
        break;
    case 2:
        denom *= 4;
        break;
    case 3:
        denom *= 8;
        break;
    case 4:
        denom *= 3;
        break;
    case 6:
        denom *= 6;
        break;
    case 7:
        denom *= 12;
        break;
    }

    xtal = (int)(vclk *(float)denom/(float)num);

    if ((xtal > 26900000) && (xtal < 27100000))
        xtal = 2700;
    else if ((xtal > 14200000) && (xtal < 14400000))
        xtal = 1432;
    else if ((xtal > 29400000) && (xtal < 29600000))
        xtal = 2950;
    else
	return FALSE;

    tmp = INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV);
    ref_div = INPLL(pScrn, RADEON_PPLL_REF_DIV) & 0x3ff;

    Nx = (tmp & 0xff00) >> 8;
    M = (tmp & 0xff);
    xclk = RADEONDiv((2 * Nx * xtal), (2 * M));

    /* we're done, hopefully these are sane values */
    pll->reference_div = ref_div;
    pll->xclk = xclk;
    pll->reference_freq = xtal;

    return TRUE;
}

static void RADEONGetTMDSInfo(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    CARD32 tmp;
    int i, n;

    for (i=0; i<4; i++) {
	info->tmds_pll[i].value = 0;
	info->tmds_pll[i].freq = 0;
    }

    if (info->VBIOS) {
	tmp = RADEON_BIOS16(info->FPBIOSstart + 0x34);
	if (tmp) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "DFP table revision: %d\n", RADEON_BIOS8(tmp));
	    if (RADEON_BIOS8(tmp) == 3) {
		n = RADEON_BIOS8(tmp + 5) + 1;
		if (n > 4) n = 4;
		for (i=0; i<n; i++) {
		    info->tmds_pll[i].value = RADEON_BIOS32(tmp+i*10+0x08);
		    info->tmds_pll[i].freq = RADEON_BIOS16(tmp+i*10+0x10);
		}
		return;
	    }

	    /* revision 4 has some problem as it appears in RV280,
	       comment it off for new, use default instead */
            /*
	    else if (RADEON_BIOS8(tmp) == 4) {
		int stride = 0;
		n = RADEON_BIOS8(tmp + 5) + 1;
		if (n > 4) n = 4;
		for (i=0; i<n; i++) {
		    info->tmds_pll[i].value = RADEON_BIOS32(tmp+stride+0x08);
		    info->tmds_pll[i].freq = RADEON_BIOS16(tmp+stride+0x10);
		    if (i == 0) stride += 10;
		    else stride += 6;
		}
		return;
	    }
	    */
	}
    }

    for (i=0; i<4; i++) {
	info->tmds_pll[i].value = default_tmds_pll[info->ChipFamily][i].value;
	info->tmds_pll[i].freq = default_tmds_pll[info->ChipFamily][i].freq;
    }
}

/* Read PLL parameters from BIOS block.  Default to typical values if
 * there is no BIOS.
 */
static Bool RADEONGetPLLParameters(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    RADEONPLLPtr   pll  = &info->pll;
    CARD16         bios_header;
    CARD16         pll_info_block;
    double         min_dotclock;

    if (!info->VBIOS) {

	pll->min_pll_freq   = 12500;
	pll->max_pll_freq   = 35000;


	if (!RADEONProbePLLParameters(pScrn)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Video BIOS not detected, using default PLL parameters!\n");

	    switch (info->Chipset) {
		case PCI_CHIP_R200_QL:
		case PCI_CHIP_R200_QN:
		case PCI_CHIP_R200_QO:
		case PCI_CHIP_R200_BB:
		    pll->reference_freq = 2700;
		    pll->reference_div  = 12;
		    pll->xclk           = 27500;
		    break;
		case PCI_CHIP_RV250_Id:
		case PCI_CHIP_RV250_Ie:
		case PCI_CHIP_RV250_If:
		case PCI_CHIP_RV250_Ig:
		    pll->reference_freq = 2700;
		    pll->reference_div  = 12;
		    pll->xclk           = 24975;
		    break;
		case PCI_CHIP_RV200_QW:
		    pll->reference_freq = 2700;
		    pll->reference_div  = 12;
		    pll->xclk           = 23000;
		    break;
		case PCI_CHIP_RADEON_LW: /* Guess based on iBook OpenFirmware */
		    pll->reference_freq = 2700;
		    pll->reference_div  = 12;
		    pll->xclk           = 36000;
		    break;
		default:
		    pll->reference_freq = 2700;
		    pll->reference_div  = 67;
		    pll->xclk           = 16615;
		    break;
	    }
        }
    } else {
	bios_header    = RADEON_BIOS16(0x48);
	pll_info_block = RADEON_BIOS16(bios_header + 0x30);
	RADEONTRACE(("Header at 0x%04x; PLL Information at 0x%04x\n",
		     bios_header, pll_info_block));

	pll->reference_freq = RADEON_BIOS16(pll_info_block + 0x0e);
	pll->reference_div  = RADEON_BIOS16(pll_info_block + 0x10);
	pll->min_pll_freq   = RADEON_BIOS32(pll_info_block + 0x12);
	pll->max_pll_freq   = RADEON_BIOS32(pll_info_block + 0x16);
	pll->xclk           = RADEON_BIOS16(pll_info_block + 0x08);
    }

    /* (Some?) Radeon BIOSes seem too lie about their minimum dot
     * clocks.  Allow users to override the detected minimum dot clock
     * value (e.g., and allow it to be suitable for TV sets).
     */
    if (xf86GetOptValFreq(info->Options, OPTION_MIN_DOTCLOCK,
			  OPTUNITS_MHZ, &min_dotclock)) {
	if (min_dotclock < 12 || min_dotclock*100 >= pll->max_pll_freq) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Illegal minimum dotclock specified %.2f MHz "
		       "(option ignored)\n",
		       min_dotclock);
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Forced minimum dotclock to %.2f MHz "
		       "(instead of detected %.2f MHz)\n",
		       min_dotclock, ((double)pll->min_pll_freq/1000));
	    pll->min_pll_freq = min_dotclock * 1000;
	}
    }

    return TRUE;
}

/* This is called by RADEONPreInit to set up the default visual */
static Bool RADEONPreInitVisual(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);

    if (!xf86SetDepthBpp(pScrn, 0, 0, 0, Support32bppFb))
	return FALSE;

    switch (pScrn->depth) {
    case 8:
    case 15:
    case 16:
    case 24:
	break;

    default:
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Given depth (%d) is not supported by %s driver\n",
		   pScrn->depth, RADEON_DRIVER_NAME);
	return FALSE;
    }

    xf86PrintDepthBpp(pScrn);

    info->fifo_slots                 = 0;
    info->pix24bpp                   = xf86GetBppFromDepth(pScrn,
							   pScrn->depth);
    info->CurrentLayout.bitsPerPixel = pScrn->bitsPerPixel;
    info->CurrentLayout.depth        = pScrn->depth;
    info->CurrentLayout.pixel_bytes  = pScrn->bitsPerPixel / 8;
    info->CurrentLayout.pixel_code   = (pScrn->bitsPerPixel != 16
				       ? pScrn->bitsPerPixel
				       : pScrn->depth);

    if (info->pix24bpp == 24) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Radeon does NOT support 24bpp\n");
	return FALSE;
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Pixel depth = %d bits stored in %d byte%s (%d bpp pixmaps)\n",
	       pScrn->depth,
	       info->CurrentLayout.pixel_bytes,
	       info->CurrentLayout.pixel_bytes > 1 ? "s" : "",
	       info->pix24bpp);

    if (!xf86SetDefaultVisual(pScrn, -1)) return FALSE;

    if (pScrn->depth > 8 && pScrn->defaultVisual != TrueColor) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Default visual (%s) is not supported at depth %d\n",
		   xf86GetVisualName(pScrn->defaultVisual), pScrn->depth);
	return FALSE;
    }
    return TRUE;
}

/* This is called by RADEONPreInit to handle all color weight issues */
static Bool RADEONPreInitWeight(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);

				/* Save flag for 6 bit DAC to use for
				   setting CRTC registers.  Otherwise use
				   an 8 bit DAC, even if xf86SetWeight sets
				   pScrn->rgbBits to some value other than
				   8. */
    info->dac6bits = FALSE;

    if (pScrn->depth > 8) {
	rgb  defaultWeight = { 0, 0, 0 };

	if (!xf86SetWeight(pScrn, defaultWeight, defaultWeight)) return FALSE;
    } else {
	pScrn->rgbBits = 8;
	if (xf86ReturnOptValBool(info->Options, OPTION_DAC_6BIT, FALSE)) {
	    pScrn->rgbBits = 6;
	    info->dac6bits = TRUE;
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Using %d bits per RGB (%d bit DAC)\n",
	       pScrn->rgbBits, info->dac6bits ? 6 : 8);

    return TRUE;
}

static void RADEONGetVRamType(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info   = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    CARD32 tmp;

    if (info->IsIGP || (info->ChipFamily >= CHIP_FAMILY_R300) ||
	(INREG(RADEON_MEM_SDRAM_MODE_REG) & (1<<30)))
	info->IsDDR = TRUE;
    else
	info->IsDDR = FALSE;

    tmp = INREG(RADEON_MEM_CNTL);
    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {
	tmp &=  R300_MEM_NUM_CHANNELS_MASK;
	switch (tmp) {
	case 0: info->RamWidth = 64; break;
	case 1: info->RamWidth = 128; break;
	case 2: info->RamWidth = 256; break;
	default: info->RamWidth = 128; break;
	}
    } else if ((info->ChipFamily == CHIP_FAMILY_RV100) ||
	       (info->ChipFamily == CHIP_FAMILY_RS100) ||
	       (info->ChipFamily == CHIP_FAMILY_RS200)){
	if (tmp & RV100_HALF_MODE) info->RamWidth = 32;
	else info->RamWidth = 64;
    } else {
	if (tmp & RADEON_MEM_NUM_CHANNELS_MASK) info->RamWidth = 128;
	else info->RamWidth = 64;
    }

    /* This may not be correct, as some cards can have half of channel disabled
     * ToDo: identify these cases
     */
}

/* This is called by RADEONPreInit to handle config file overrides for
 * things like chipset and memory regions.  Also determine memory size
 * and type.  If memory type ever needs an override, put it in this
 * routine.
 */
static Bool RADEONPreInitConfig(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info   = RADEONPTR(pScrn);
    EntityInfoPtr  pEnt   = info->pEnt;
    GDevPtr        dev    = pEnt->device;
    MessageType    from;
    unsigned char *RADEONMMIO = info->MMIO;
#ifdef XF86DRI
    const char    *s;
    CARD32         agpCommand;
#endif

				/* Chipset */
    from = X_PROBED;
    if (dev->chipset && *dev->chipset) {
	info->Chipset  = xf86StringToToken(RADEONChipsets, dev->chipset);
	from           = X_CONFIG;
    } else if (dev->chipID >= 0) {
	info->Chipset  = dev->chipID;
	from           = X_CONFIG;
    } else {
	info->Chipset = info->PciInfo->chipType;
    }

    pScrn->chipset = (char *)xf86TokenToString(RADEONChipsets, info->Chipset);
    if (!pScrn->chipset) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "ChipID 0x%04x is not recognized\n", info->Chipset);
	return FALSE;
    }
    if (info->Chipset < 0) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Chipset \"%s\" is not recognized\n", pScrn->chipset);
	return FALSE;
    }
    xf86DrvMsg(pScrn->scrnIndex, from,
	       "Chipset: \"%s\" (ChipID = 0x%04x)\n",
	       pScrn->chipset,
	       info->Chipset);

    info->HasCRTC2 = TRUE;
    info->IsMobility = FALSE;
    info->IsIGP = FALSE;
    switch (info->Chipset) {
    case PCI_CHIP_RADEON_LY:
    case PCI_CHIP_RADEON_LZ:
	info->IsMobility = TRUE;
	info->ChipFamily = CHIP_FAMILY_RV100;
	break;

    case PCI_CHIP_RV100_QY:
    case PCI_CHIP_RV100_QZ:
	info->ChipFamily = CHIP_FAMILY_RV100;
	break;

    case PCI_CHIP_RS100_4336:
	info->IsMobility = TRUE;
    case PCI_CHIP_RS100_4136:
	info->ChipFamily = CHIP_FAMILY_RS100;
	info->IsIGP = TRUE;
	break;

    case PCI_CHIP_RS200_4337:
	info->IsMobility = TRUE;
    case PCI_CHIP_RS200_4137:
	info->ChipFamily = CHIP_FAMILY_RS200;
	info->IsIGP = TRUE;
	break;

    case PCI_CHIP_RS250_4437:
	info->IsMobility = TRUE;
    case PCI_CHIP_RS250_4237:
	info->ChipFamily = CHIP_FAMILY_RS200;
	info->IsIGP = TRUE;
	break;

    case PCI_CHIP_R200_BB:
    case PCI_CHIP_R200_BC:
    case PCI_CHIP_R200_QH:
    case PCI_CHIP_R200_QL:
    case PCI_CHIP_R200_QM:
	info->ChipFamily = CHIP_FAMILY_R200;
	break;

    case PCI_CHIP_RADEON_LW:
    case PCI_CHIP_RADEON_LX:
	info->IsMobility = TRUE;
    case PCI_CHIP_RV200_QW: /* RV200 desktop */
    case PCI_CHIP_RV200_QX:
	info->ChipFamily = CHIP_FAMILY_RV200;
	break;

    case PCI_CHIP_RV250_Ld:
    case PCI_CHIP_RV250_Lf:
    case PCI_CHIP_RV250_Lg:
	info->IsMobility = TRUE;
    case PCI_CHIP_RV250_If:
    case PCI_CHIP_RV250_Ig:
	info->ChipFamily = CHIP_FAMILY_RV250;
	break;

    case PCI_CHIP_RS300_5835:
	info->IsMobility = TRUE;
    case PCI_CHIP_RS300_5834:
	info->ChipFamily = CHIP_FAMILY_RS300;
	info->IsIGP = TRUE;
	break;

    case PCI_CHIP_RV280_5C61:
    case PCI_CHIP_RV280_5C63:
	info->IsMobility = TRUE;
    case PCI_CHIP_RV280_5960:
    case PCI_CHIP_RV280_5961:
    case PCI_CHIP_RV280_5962:
    case PCI_CHIP_RV280_5964:
	info->ChipFamily = CHIP_FAMILY_RV280;
	break;

    case PCI_CHIP_R300_AD:
    case PCI_CHIP_R300_AE:
    case PCI_CHIP_R300_AF:
    case PCI_CHIP_R300_AG:
    case PCI_CHIP_R300_ND:
    case PCI_CHIP_R300_NE:
    case PCI_CHIP_R300_NF:
    case PCI_CHIP_R300_NG:
	info->ChipFamily = CHIP_FAMILY_R300;
        break;

    case PCI_CHIP_RV350_NP:
    case PCI_CHIP_RV350_NQ:
    case PCI_CHIP_RV350_NR:
    case PCI_CHIP_RV350_NS:
    case PCI_CHIP_RV350_NT:
    case PCI_CHIP_RV350_NV:
	info->IsMobility = TRUE;
    case PCI_CHIP_RV350_AP:
    case PCI_CHIP_RV350_AQ:
    case PCI_CHIP_RV360_AR:
    case PCI_CHIP_RV350_AS:
    case PCI_CHIP_RV350_AT:
    case PCI_CHIP_RV350_AV:
	info->ChipFamily = CHIP_FAMILY_RV350;
        break;

    case PCI_CHIP_R350_AH:
    case PCI_CHIP_R350_AI:
    case PCI_CHIP_R350_AJ:
    case PCI_CHIP_R350_AK:
    case PCI_CHIP_R350_NH:
    case PCI_CHIP_R350_NI:
    case PCI_CHIP_R350_NK:
    case PCI_CHIP_R360_NJ:
	info->ChipFamily = CHIP_FAMILY_R350;
        break;

    default:
	/* Original Radeon/7200 */
	info->ChipFamily = CHIP_FAMILY_RADEON;
	info->HasCRTC2 = FALSE;
    }
				/* Framebuffer */

    from               = X_PROBED;
    info->LinearAddr   = info->PciInfo->memBase[0] & 0xfe000000;
    pScrn->memPhysBase = info->LinearAddr;
    if (dev->MemBase) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Linear address override, using 0x%08lx instead of 0x%08lx\n",
		   dev->MemBase,
		   info->LinearAddr);
	info->LinearAddr = dev->MemBase;
	from             = X_CONFIG;
    } else if (!info->LinearAddr) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "No valid linear framebuffer address\n");
	return FALSE;
    }
    xf86DrvMsg(pScrn->scrnIndex, from,
	       "Linear framebuffer at 0x%08lx\n", info->LinearAddr);

				/* BIOS */
    from              = X_PROBED;
    info->BIOSAddr    = info->PciInfo->biosBase & 0xfffe0000;
    if (dev->BiosBase) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "BIOS address override, using 0x%08lx instead of 0x%08lx\n",
		   dev->BiosBase,
		   info->BIOSAddr);
	info->BIOSAddr = dev->BiosBase;
	from           = X_CONFIG;
    }
    if (info->BIOSAddr) {
	xf86DrvMsg(pScrn->scrnIndex, from,
		   "BIOS at 0x%08lx\n", info->BIOSAddr);
    }

				/* Read registers used to determine options */
    from                     = X_PROBED;
    if (info->FBDev)
	pScrn->videoRam      = fbdevHWGetVidmem(pScrn) / 1024;
    else if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
	     (info->ChipFamily == CHIP_FAMILY_RS200) ||
	     (info->ChipFamily == CHIP_FAMILY_RS300)) {
        CARD32 tom = INREG(RADEON_NB_TOM);
        pScrn->videoRam = (((tom >> 16) -
			    (tom & 0xffff) + 1) << 6);
	OUTREG(RADEON_MC_FB_LOCATION, tom);
	OUTREG(RADEON_DISPLAY_BASE_ADDR, (tom & 0xffff) << 16);
	OUTREG(RADEON_DISPLAY2_BASE_ADDR, (tom & 0xffff) << 16);
	OUTREG(RADEON_OV0_BASE_ADDR, (tom & 0xffff) << 16);

	/* This is supposed to fix the crtc2 noise problem.
	*/
	OUTREG(RADEON_GRPH2_BUFFER_CNTL,
	       INREG(RADEON_GRPH2_BUFFER_CNTL) & ~0x7f0000);

	if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
	    (info->ChipFamily == CHIP_FAMILY_RS200)) {
	    /* This is to workaround the asic bug for RMX, some versions
	       of BIOS dosen't have this register initialized correctly.
	    */
	    OUTREGP(RADEON_CRTC_MORE_CNTL, RADEON_CRTC_H_CUTOFF_ACTIVE_EN,
		    ~RADEON_CRTC_H_CUTOFF_ACTIVE_EN);
	}

    }
    else
	pScrn->videoRam      = INREG(RADEON_CONFIG_MEMSIZE) / 1024;

    /* Some production boards of m6 will return 0 if it's 8 MB */
    if (pScrn->videoRam == 0) pScrn->videoRam = 8192;

    if (info->IsSecondary) {
	/* FIXME: For now, split FB into two equal sections. This should
	 * be able to be adjusted by user with a config option. */
        RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
	RADEONInfoPtr  info1;

	pScrn->videoRam /= 2;
	pRADEONEnt->pPrimaryScrn->videoRam = pScrn->videoRam;

	info1 = RADEONPTR(pRADEONEnt->pPrimaryScrn);
	info1->FbMapSize  = pScrn->videoRam * 1024;
	info->LinearAddr += pScrn->videoRam * 1024;
	info1->Clone = FALSE;
	info1->CurCloneMode = NULL;
    }

    info->R300CGWorkaround =
	(info->ChipFamily == CHIP_FAMILY_R300 &&
	 (INREG(RADEON_CONFIG_CNTL) & RADEON_CFG_ATI_REV_ID_MASK)
	 == RADEON_CFG_ATI_REV_A11);

    info->MemCntl            = INREG(RADEON_SDRAM_MODE_REG);
    info->BusCntl            = INREG(RADEON_BUS_CNTL);

    RADEONGetVRamType(pScrn);

    if (dev->videoRam) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Video RAM override, using %d kB instead of %d kB\n",
		   dev->videoRam,
		   pScrn->videoRam);
	from             = X_CONFIG;
	pScrn->videoRam  = dev->videoRam;
    }
    pScrn->videoRam  &= ~1023;
    info->FbMapSize  = pScrn->videoRam * 1024;
    xf86DrvMsg(pScrn->scrnIndex, from,
	       "VideoRAM: %d kByte (%d bit %s SDRAM)\n", pScrn->videoRam, info->RamWidth, info->IsDDR?"DDR":"SDR");

#ifdef XF86DRI
				/* AGP/PCI */

    /* There are signatures in BIOS and PCI-SSID for a PCI card, but
     * they are not very reliable.  Following detection method works for
     * all cards tested so far.  Note, checking AGP_ENABLE bit after
     * drmAgpEnable call can also give the correct result.  However,
     * calling drmAgpEnable on a PCI card can cause some strange lockup
     * when the server restarts next time.
     */

    agpCommand = pciReadLong(info->PciTag, RADEON_AGP_COMMAND_PCI_CONFIG);
    pciWriteLong(info->PciTag, RADEON_AGP_COMMAND_PCI_CONFIG,
		 agpCommand | RADEON_AGP_ENABLE);
    if (pciReadLong(info->PciTag, RADEON_AGP_COMMAND_PCI_CONFIG)
	& RADEON_AGP_ENABLE) {
	info->IsPCI = FALSE; 
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "AGP card detected\n");
    } else {
	info->IsPCI = TRUE; 
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PCI card detected\n");
    }
    pciWriteLong(info->PciTag, RADEON_AGP_COMMAND_PCI_CONFIG, agpCommand);

    if ((s = xf86GetOptValString(info->Options, OPTION_BUS_TYPE))) {
	if (strcmp(s, "AGP") == 0) {
	    info->IsPCI = FALSE;
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Forced into AGP mode\n");
	} else if (strcmp(s, "PCI") == 0) {
	    info->IsPCI = TRUE;
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Forced into PCI mode\n");
	} else if (strcmp(s, "PCIE") == 0) {
	    info->IsPCI = TRUE;
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       "PCI Express not supported yet, using PCI mode\n");
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       "Invalid BusType option, using detected type\n");
	}
    } else if (xf86ReturnOptValBool(info->Options, OPTION_IS_PCI, FALSE)) {
	info->IsPCI = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Forced into PCI mode\n");
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "ForcePCIMode is deprecated -- "
		   "use BusType option instead\n");
    }
#endif

    return TRUE;
}

static void RADEONI2CGetBits(I2CBusPtr b, int *Clock, int *data)
{
    ScrnInfoPtr    pScrn      = xf86Screens[b->scrnIndex];
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned long  val;
    unsigned char *RADEONMMIO = info->MMIO;

    /* Get the result */
    val = INREG(info->DDCReg);

    *Clock = (val & RADEON_GPIO_Y_1) != 0;
    *data  = (val & RADEON_GPIO_Y_0) != 0;
}

static void RADEONI2CPutBits(I2CBusPtr b, int Clock, int data)
{
    ScrnInfoPtr    pScrn      = xf86Screens[b->scrnIndex];
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned long  val;
    unsigned char *RADEONMMIO = info->MMIO;

    val = INREG(info->DDCReg) & (CARD32)~(RADEON_GPIO_EN_0 | RADEON_GPIO_EN_1);
    val |= (Clock ? 0:RADEON_GPIO_EN_1);
    val |= (data ? 0:RADEON_GPIO_EN_0);
    OUTREG(info->DDCReg, val);

    /* read back to improve reliability on some cards. */
    val = INREG(info->DDCReg);
}

static Bool RADEONI2cInit(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);

    info->pI2CBus = xf86CreateI2CBusRec();
    if (!info->pI2CBus) return FALSE;

    info->pI2CBus->BusName    = "DDC";
    info->pI2CBus->scrnIndex  = pScrn->scrnIndex;
    info->pI2CBus->I2CPutBits = RADEONI2CPutBits;
    info->pI2CBus->I2CGetBits = RADEONI2CGetBits;
    info->pI2CBus->AcknTimeout = 5;

    if (!xf86I2CBusInit(info->pI2CBus)) return FALSE;
    return TRUE;
}

static void RADEONPreInitDDC(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);
 /* vbeInfoPtr     pVbe; */

    info->ddc1     = FALSE;
    info->ddc_bios = FALSE;
    if (!xf86LoadSubModule(pScrn, "ddc")) {
	info->ddc2 = FALSE;
    } else {
	xf86LoaderReqSymLists(ddcSymbols, NULL);
	info->ddc2 = TRUE;
    }

    /* DDC can use I2C bus */
    /* Load I2C if we have the code to use it */
    if (info->ddc2) {
	if (xf86LoadSubModule(pScrn, "i2c")) {
	    xf86LoaderReqSymLists(i2cSymbols,NULL);
	    info->ddc2 = RADEONI2cInit(pScrn);
	}
	else info->ddc2 = FALSE;
    }
}


/* BIOS may not have right panel size, we search through all supported
 * DDC modes looking for the maximum panel size.
 */
static void RADEONUpdatePanelSize(ScrnInfoPtr pScrn)
{
    int             j;
    RADEONInfoPtr   info = RADEONPTR (pScrn);
    xf86MonPtr      ddc  = pScrn->monitor->DDC;
    DisplayModePtr  p;

    /* Go thru detailed timing table first */
    for (j = 0; j < 4; j++) {
	if (ddc->det_mon[j].type == 0) {
	    struct detailed_timings *d_timings =
		&ddc->det_mon[j].section.d_timings;
	    if (info->PanelXRes < d_timings->h_active &&
		info->PanelYRes < d_timings->v_active) {

		info->PanelXRes  = d_timings->h_active;
		info->PanelYRes  = d_timings->v_active;
		info->DotClock   = d_timings->clock / 1000;
		info->HOverPlus  = d_timings->h_sync_off;
		info->HSyncWidth = d_timings->h_sync_width;
		info->HBlank     = d_timings->h_blanking;
		info->VOverPlus  = d_timings->v_sync_off;
		info->VSyncWidth = d_timings->v_sync_width;
		info->VBlank     = d_timings->v_blanking;
	    }
	}
    }

    /* Search thru standard VESA modes from EDID */
    for (j = 0; j < 8; j++) {
	if ((info->PanelXRes < ddc->timings2[j].hsize) &&
	    (info->PanelYRes < ddc->timings2[j].vsize)) {
	    for (p = pScrn->monitor->Modes; p && p->next; p = p->next->next) {
		if ((ddc->timings2[j].hsize == p->HDisplay) &&
		    (ddc->timings2[j].vsize == p->VDisplay)) {
		    float  refresh =
			(float)p->Clock * 1000.0 / p->HTotal / p->VTotal;

		    if (abs((float)ddc->timings2[j].refresh - refresh) < 1.0) {
			/* Is this good enough? */
			info->PanelXRes  = ddc->timings2[j].hsize;
			info->PanelYRes  = ddc->timings2[j].vsize;
			info->HBlank     = p->HTotal - p->HDisplay;
			info->HOverPlus  = p->HSyncStart - p->HDisplay;
			info->HSyncWidth = p->HSyncEnd - p->HSyncStart;
			info->VBlank     = p->VTotal - p->VDisplay;
			info->VOverPlus  = p->VSyncStart - p->VDisplay;
			info->VSyncWidth = p->VSyncEnd - p->VSyncStart;
			info->DotClock   = p->Clock;
			info->Flags      =
			    (ddc->det_mon[j].section.d_timings.interlaced
			     ? V_INTERLACE
			     : 0);
			if (ddc->det_mon[j].section.d_timings.sync == 3) {
			    switch (ddc->det_mon[j].section.d_timings.misc) {
			    case 0: info->Flags |= V_NHSYNC | V_NVSYNC; break;
			    case 1: info->Flags |= V_PHSYNC | V_NVSYNC; break;
			    case 2: info->Flags |= V_NHSYNC | V_PVSYNC; break;
			    case 3: info->Flags |= V_PHSYNC | V_PVSYNC; break;
			    }
			}
		    }
		}
	    }
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Panel size found from DDC: %dx%d\n",
	       info->PanelXRes, info->PanelYRes);
}

/* This function will sort all modes according to their resolution.
 * Highest resolution first.
 */
static void RADEONSortModes(DisplayModePtr *new, DisplayModePtr *first,
			    DisplayModePtr *last)
{
    DisplayModePtr  p;

    p = *last;
    while (p) {
	if ((((*new)->HDisplay < p->HDisplay) &&
	     ((*new)->VDisplay < p->VDisplay)) ||
	    (((*new)->HDisplay == p->HDisplay) &&
	     ((*new)->VDisplay == p->VDisplay) &&
	     ((*new)->Clock < p->Clock))) {

	    if (p->next) p->next->prev = *new;
	    (*new)->prev = p;
	    (*new)->next = p->next;
	    p->next = *new;
	    if (!((*new)->next)) *last = *new;
	    break;
	}
	if (!p->prev) {
	    (*new)->prev = NULL;
	    (*new)->next = p;
	    p->prev = *new;
	    *first = *new;
	    break;
	}
	p = p->prev;
    }

    if (!*first) {
	*first = *new;
	(*new)->prev = NULL;
	(*new)->next = NULL;
	*last = *new;
    }
}

static void RADEONSetPitch (ScrnInfoPtr pScrn)
{
    int  dummy = pScrn->virtualX;

    /* FIXME: May need to validate line pitch here */
    switch (pScrn->depth / 8) {
    case 1: dummy = (pScrn->virtualX + 127) & ~127; break;
    case 2: dummy = (pScrn->virtualX +  31) &  ~31; break;
    case 3:
    case 4: dummy = (pScrn->virtualX +  15) &  ~15; break;
    }
    pScrn->displayWidth = dummy;
}

/* When no mode provided in config file, this will add all modes supported in
 * DDC date the pScrn->modes list
 */
static DisplayModePtr RADEONDDCModes(ScrnInfoPtr pScrn)
{
    DisplayModePtr  p;
    DisplayModePtr  last  = NULL;
    DisplayModePtr  new   = NULL;
    DisplayModePtr  first = NULL;
    int             count = 0;
    int             j, tmp;
    char            stmp[32];
    xf86MonPtr      ddc   = pScrn->monitor->DDC;

    /* Go thru detailed timing table first */
    for (j = 0; j < 4; j++) {
	if (ddc->det_mon[j].type == 0) {
	    struct detailed_timings *d_timings =
		&ddc->det_mon[j].section.d_timings;

	    if (d_timings->h_active == 0 || d_timings->v_active == 0) break;

	    new = xnfcalloc(1, sizeof (DisplayModeRec));
	    memset(new, 0, sizeof (DisplayModeRec));

	    new->HDisplay   = d_timings->h_active;
	    new->VDisplay   = d_timings->v_active;

	    sprintf(stmp, "%dx%d", new->HDisplay, new->VDisplay);
	    new->name       = xnfalloc(strlen(stmp) + 1);
	    strcpy(new->name, stmp);

	    new->HTotal     = new->HDisplay + d_timings->h_blanking;
	    new->HSyncStart = new->HDisplay + d_timings->h_sync_off;
	    new->HSyncEnd   = new->HSyncStart + d_timings->h_sync_width;
	    new->VTotal     = new->VDisplay + d_timings->v_blanking;
	    new->VSyncStart = new->VDisplay + d_timings->v_sync_off;
	    new->VSyncEnd   = new->VSyncStart + d_timings->v_sync_width;
	    new->Clock      = d_timings->clock / 1000;
	    new->Flags      = (d_timings->interlaced ? V_INTERLACE : 0);
	    new->status     = MODE_OK;
	    new->type       = M_T_DEFAULT;

	    if (d_timings->sync == 3) {
		switch (d_timings->misc) {
		case 0: new->Flags |= V_NHSYNC | V_NVSYNC; break;
		case 1: new->Flags |= V_PHSYNC | V_NVSYNC; break;
		case 2: new->Flags |= V_NHSYNC | V_PVSYNC; break;
		case 3: new->Flags |= V_PHSYNC | V_PVSYNC; break;
		}
	    }
	    count++;

	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Valid Mode from Detailed timing table: %s\n",
		       new->name);

	    RADEONSortModes(&new, &first, &last);
	}
    }

    /* Search thru standard VESA modes from EDID */
    for (j = 0; j < 8; j++) {
	for (p = pScrn->monitor->Modes; p && p->next; p = p->next->next) {
	    /* Ignore all double scan modes */
	    if ((ddc->timings2[j].hsize == p->HDisplay) &&
		(ddc->timings2[j].vsize == p->VDisplay)) {
		float  refresh =
		    (float)p->Clock * 1000.0 / p->HTotal / p->VTotal;

		if (abs((float)ddc->timings2[j].refresh - refresh) < 1.0) {
		    /* Is this good enough? */
		    new = xnfcalloc(1, sizeof (DisplayModeRec));
		    memcpy(new, p, sizeof(DisplayModeRec));
		    new->name = xnfalloc(strlen(p->name) + 1);
		    strcpy(new->name, p->name);
		    new->status = MODE_OK;
		    new->type   = M_T_DEFAULT;

		    count++;

		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			       "Valid Mode from standard timing table: %s\n",
			       new->name);

		    RADEONSortModes(&new, &first, &last);
		    break;
		}
	    }
	}
    }

    /* Search thru established modes from EDID */
    tmp = (ddc->timings1.t1 << 8) | ddc->timings1.t2;
    for (j = 0; j < 16; j++) {
	if (tmp & (1 << j)) {
	    for (p = pScrn->monitor->Modes; p && p->next; p = p->next->next) {
		if ((est_timings[j].hsize == p->HDisplay) &&
		    (est_timings[j].vsize == p->VDisplay)) {
		    float  refresh =
			(float)p->Clock * 1000.0 / p->HTotal / p->VTotal;

		    if (abs((float)est_timings[j].refresh - refresh) < 1.0) {
			/* Is this good enough? */
			new = xnfcalloc(1, sizeof (DisplayModeRec));
			memcpy(new, p, sizeof(DisplayModeRec));
			new->name = xnfalloc(strlen(p->name) + 1);
			strcpy(new->name, p->name);
			new->status = MODE_OK;
			new->type   = M_T_DEFAULT;

			count++;

			xf86DrvMsg(pScrn->scrnIndex, X_INFO,
				   "Valid Mode from established timing "
				   "table: %s\n", new->name);

			RADEONSortModes(&new, &first, &last);
			break;
		    }
		}
	    }
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Total of %d mode(s) found.\n", count);

    return first;
}

/* XFree86's xf86ValidateModes routine doesn't work well with DDC modes,
 * so here is our own validation routine.
 */
static int RADEONValidateDDCModes(ScrnInfoPtr pScrn, char **ppModeName,
				  RADEONMonitorType DisplayType)
{
    RADEONInfoPtr   info       = RADEONPTR(pScrn);
    DisplayModePtr  p;
    DisplayModePtr  last       = NULL;
    DisplayModePtr  first      = NULL;
    DisplayModePtr  ddcModes   = NULL;
    int             count      = 0;
    int             i, width, height;

    pScrn->virtualX = pScrn->display->virtualX;
    pScrn->virtualY = pScrn->display->virtualY;

    if (pScrn->monitor->DDC && !info->UseBiosDividers) {
	int  maxVirtX = pScrn->virtualX;
	int  maxVirtY = pScrn->virtualY;

	if ((DisplayType != MT_CRT) && !info->IsSecondary) {
	    /* The panel size we collected from BIOS may not be the
	     * maximum size supported by the panel.  If not, we update
	     * it now.  These will be used if no matching mode can be
	     * found from EDID data.
	     */
	    RADEONUpdatePanelSize(pScrn);
	}

	/* Collect all of the DDC modes */
	first = last = ddcModes = RADEONDDCModes(pScrn);

	for (p = ddcModes; p; p = p->next) {

	    /* If primary head is a flat panel, use RMX by default */
	    if ((!info->IsSecondary && DisplayType != MT_CRT) &&
		!info->ddc_mode) {
		/* These values are effective values after expansion.
		 * They are not really used to set CRTC registers.
		 */
		p->HTotal     = info->PanelXRes + info->HBlank;
		p->HSyncStart = info->PanelXRes + info->HOverPlus;
		p->HSyncEnd   = p->HSyncStart + info->HSyncWidth;
		p->VTotal     = info->PanelYRes + info->VBlank;
		p->VSyncStart = info->PanelYRes + info->VOverPlus;
		p->VSyncEnd   = p->VSyncStart + info->VSyncWidth;
		p->Clock      = info->DotClock;

		p->Flags     |= RADEON_USE_RMX;
	    }

	    maxVirtX = MAX(maxVirtX, p->HDisplay);
	    maxVirtY = MAX(maxVirtY, p->VDisplay);
	    count++;

	    last = p;
	}

	/* Match up modes that are specified in the XF86Config file */
	if (ppModeName[0]) {
	    DisplayModePtr  next;

	    /* Reset the max virtual dimensions */
	    maxVirtX = pScrn->virtualX;
	    maxVirtY = pScrn->virtualY;

	    /* Reset list */
	    first = last = NULL;

	    for (i = 0; ppModeName[i]; i++) {
		/* FIXME: Use HDisplay and VDisplay instead of mode string */
		if (sscanf(ppModeName[i], "%dx%d", &width, &height) == 2) {
		    for (p = ddcModes; p; p = next) {
			next = p->next;

			if (p->HDisplay == width && p->VDisplay == height) {
			    /* We found a DDC mode that matches the one
                               requested in the XF86Config file */
			    p->type |= M_T_USERDEF;

			    /* Update  the max virtual setttings */
			    maxVirtX = MAX(maxVirtX, width);
			    maxVirtY = MAX(maxVirtY, height);

			    /* Unhook from DDC modes */
			    if (p->prev) p->prev->next = p->next;
			    if (p->next) p->next->prev = p->prev;
			    if (p == ddcModes) ddcModes = p->next;

			    /* Add to used modes */
			    if (last) {
				last->next = p;
				p->prev = last;
			    } else {
				first = p;
				p->prev = NULL;
			    }
			    p->next = NULL;
			    last = p;

			    break;
			}
		    }
		}
	    }

	    /*
	     * Add remaining DDC modes if they're smaller than the user
	     * specified modes
	     */
	    for (p = ddcModes; p; p = next) {
		next = p->next;
		if (p->HDisplay <= maxVirtX && p->VDisplay <= maxVirtY) {
		    /* Unhook from DDC modes */
		    if (p->prev) p->prev->next = p->next;
		    if (p->next) p->next->prev = p->prev;
		    if (p == ddcModes) ddcModes = p->next;

		    /* Add to used modes */
		    if (last) {
			last->next = p;
			p->prev = last;
		    } else {
			first = p;
			p->prev = NULL;
		    }
		    p->next = NULL;
		    last = p;
		}
	    }

	    /* Delete unused modes */
	    while (ddcModes)
		xf86DeleteMode(&ddcModes, ddcModes);
	} else {
	    /*
	     * No modes were configured, so we make the DDC modes
	     * available for the user to cycle through.
	     */
	    for (p = ddcModes; p; p = p->next)
		p->type |= M_T_USERDEF;
	}

	pScrn->virtualX = pScrn->display->virtualX = maxVirtX;
	pScrn->virtualY = pScrn->display->virtualY = maxVirtY;
    }

    /* Close the doubly-linked mode list, if we found any usable modes */
    if (last) {
	last->next   = first;
	first->prev  = last;
	pScrn->modes = first;
	RADEONSetPitch(pScrn);
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Total number of valid DDC mode(s) found: %d\n", count);

    return count;
}

/* This is used only when no mode is specified for FP and no ddc is
 * available.  We force it to native mode, if possible.
 */
static DisplayModePtr RADEONFPNativeMode(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr   info  = RADEONPTR(pScrn);
    DisplayModePtr  new   = NULL;
    char            stmp[32];

    if (info->PanelXRes != 0 &&
	info->PanelYRes != 0 &&
	info->DotClock != 0) {

	/* Add native panel size */
	new             = xnfcalloc(1, sizeof (DisplayModeRec));
	sprintf(stmp, "%dx%d", info->PanelXRes, info->PanelYRes);
	new->name       = xnfalloc(strlen(stmp) + 1);
	strcpy(new->name, stmp);
	new->HDisplay   = info->PanelXRes;
	new->VDisplay   = info->PanelYRes;

	new->HTotal     = new->HDisplay + info->HBlank;
	new->HSyncStart = new->HDisplay + info->HOverPlus;
	new->HSyncEnd   = new->HSyncStart + info->HSyncWidth;
	new->VTotal     = new->VDisplay + info->VBlank;
	new->VSyncStart = new->VDisplay + info->VOverPlus;
	new->VSyncEnd   = new->VSyncStart + info->VSyncWidth;

	new->Clock      = info->DotClock;
	new->Flags      = 0;
	new->type       = M_T_USERDEF;

	new->next       = NULL;
	new->prev       = NULL;

	pScrn->display->virtualX =
	    pScrn->virtualX = MAX(pScrn->virtualX, info->PanelXRes);
	pScrn->display->virtualY =
	    pScrn->virtualY = MAX(pScrn->virtualY, info->PanelYRes);

	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "No valid mode specified, force to native mdoe\n");
    }

    return new;
}

/* FP mode initialization routine for using on-chip RMX to scale
 */
static int RADEONValidateFPModes(ScrnInfoPtr pScrn, char **ppModeName)
{
    RADEONInfoPtr   info       = RADEONPTR(pScrn);
    DisplayModePtr  last       = NULL;
    DisplayModePtr  new        = NULL;
    DisplayModePtr  first      = NULL;
    DisplayModePtr  p, tmp;
    int             count      = 0;
    int             i, width, height;

    pScrn->virtualX = pScrn->display->virtualX;
    pScrn->virtualY = pScrn->display->virtualY;

    /* We have a flat panel connected to the primary display, and we
     * don't have any DDC info.
     */
    for (i = 0; ppModeName[i] != NULL; i++) {

	if (sscanf(ppModeName[i], "%dx%d", &width, &height) != 2) continue;

	/* Note: We allow all non-standard modes as long as they do not
	 * exceed the native resolution of the panel.  Since these modes
	 * need the internal RMX unit in the video chips (and there is
	 * only one per card), this will only apply to the primary head.
	 */
	if (width < 320 || width > info->PanelXRes ||
	    height < 200 || height > info->PanelYRes) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Mode %s is out of range.\n", ppModeName[i]);
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Valid modes must be between 320x200-%dx%d\n",
		       info->PanelXRes, info->PanelYRes);
	    continue;
	}

	new             = xnfcalloc(1, sizeof(DisplayModeRec));
	new->name       = xnfalloc(strlen(ppModeName[i]) + 1);
	strcpy(new->name, ppModeName[i]);
	new->HDisplay   = width;
	new->VDisplay   = height;

	/* These values are effective values after expansion They are
	 * not really used to set CRTC registers.
	 */
	new->HTotal     = info->PanelXRes + info->HBlank;
	new->HSyncStart = info->PanelXRes + info->HOverPlus;
	new->HSyncEnd   = new->HSyncStart + info->HSyncWidth;
	new->VTotal     = info->PanelYRes + info->VBlank;
	new->VSyncStart = info->PanelYRes + info->VOverPlus;
	new->VSyncEnd   = new->VSyncStart + info->VSyncWidth;
	new->Clock      = info->DotClock;
	new->Flags     |= RADEON_USE_RMX;

	new->type      |= M_T_USERDEF;

	new->next       = NULL;
	new->prev       = last;

	if (last) last->next = new;
	last = new;
	if (!first) first = new;

	pScrn->display->virtualX =
	    pScrn->virtualX = MAX(pScrn->virtualX, width);
	pScrn->display->virtualY =
	    pScrn->virtualY = MAX(pScrn->virtualY, height);
	count++;
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Valid mode using on-chip RMX: %s\n", new->name);
    }

    /* If all else fails, add the native mode */
    if (!count) {
	first = last = RADEONFPNativeMode(pScrn);
	if (first) count = 1;
    }

    /* add in all default vesa modes smaller than panel size, used for randr*/
    for (p = pScrn->monitor->Modes; p && p->next; p = p->next->next) {
	if ((p->HDisplay <= info->PanelXRes) && (p->VDisplay <= info->PanelYRes)) {
	    tmp = first;
	    while (tmp) {
		if ((p->HDisplay == tmp->HDisplay) && (p->VDisplay == tmp->VDisplay)) break;
		tmp = tmp->next;
	    }
	    if (!tmp) {
		new             = xnfcalloc(1, sizeof(DisplayModeRec));
		new->name       = xnfalloc(strlen(p->name) + 1);
		strcpy(new->name, p->name);
		new->HDisplay   = p->HDisplay;
		new->VDisplay   = p->VDisplay;

		/* These values are effective values after expansion They are
		 * not really used to set CRTC registers.
		 */
		new->HTotal     = info->PanelXRes + info->HBlank;
		new->HSyncStart = info->PanelXRes + info->HOverPlus;
		new->HSyncEnd   = new->HSyncStart + info->HSyncWidth;
		new->VTotal     = info->PanelYRes + info->VBlank;
		new->VSyncStart = info->PanelYRes + info->VOverPlus;
		new->VSyncEnd   = new->VSyncStart + info->VSyncWidth;
		new->Clock      = info->DotClock;
		new->Flags     |= RADEON_USE_RMX;

		new->type      |= M_T_DEFAULT;

		new->next       = NULL;
		new->prev       = last;

		last->next = new;
		last = new;
	    }
	}
    }

    /* Close the doubly-linked mode list, if we found any usable modes */
    if (last) {
	last->next   = first;
	first->prev  = last;
	pScrn->modes = first;
	RADEONSetPitch(pScrn);
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Total number of valid FP mode(s) found: %d\n", count);

    return count;
}

/* This is called by RADEONPreInit to initialize gamma correction */
static Bool RADEONPreInitGamma(ScrnInfoPtr pScrn)
{
    Gamma  zeros = { 0.0, 0.0, 0.0 };

    if (!xf86SetGamma(pScrn, zeros)) return FALSE;
    return TRUE;
}

static void RADEONSetSyncRangeFromEdid(ScrnInfoPtr pScrn, int flag)
{
    MonPtr      mon = pScrn->monitor;
    xf86MonPtr  ddc = mon->DDC;
    int         i;

    if (flag) { /* HSync */
	for (i = 0; i < 4; i++) {
	    if (ddc->det_mon[i].type == DS_RANGES) {
		mon->nHsync = 1;
		mon->hsync[0].lo = ddc->det_mon[i].section.ranges.min_h;
		mon->hsync[0].hi = ddc->det_mon[i].section.ranges.max_h;
		return;
	    }
	}
	/* If no sync ranges detected in detailed timing table, let's
	 * try to derive them from supported VESA modes.  Are we doing
	 * too much here!!!?  */
	i = 0;
	if (ddc->timings1.t1 & 0x02) { /* 800x600@@56 */
	    mon->hsync[i].lo = mon->hsync[i].hi = 35.2;
	    i++;
	}
	if (ddc->timings1.t1 & 0x04) { /* 640x480@@75 */
	    mon->hsync[i].lo = mon->hsync[i].hi = 37.5;
	    i++;
	}
	if ((ddc->timings1.t1 & 0x08) || (ddc->timings1.t1 & 0x01)) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 37.9;
	    i++;
	}
	if (ddc->timings1.t2 & 0x40) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 46.9;
	    i++;
	}
	if ((ddc->timings1.t2 & 0x80) || (ddc->timings1.t2 & 0x08)) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 48.1;
	    i++;
	}
	if (ddc->timings1.t2 & 0x04) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 56.5;
	    i++;
	}
	if (ddc->timings1.t2 & 0x02) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 60.0;
	    i++;
	}
	if (ddc->timings1.t2 & 0x01) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 64.0;
	    i++;
	}
	mon->nHsync = i;
    } else {  /* Vrefresh */
	for (i = 0; i < 4; i++) {
	    if (ddc->det_mon[i].type == DS_RANGES) {
		mon->nVrefresh = 1;
		mon->vrefresh[0].lo = ddc->det_mon[i].section.ranges.min_v;
		mon->vrefresh[0].hi = ddc->det_mon[i].section.ranges.max_v;
		return;
	    }
	}

	i = 0;
	if (ddc->timings1.t1 & 0x02) { /* 800x600@@56 */
	    mon->vrefresh[i].lo = mon->vrefresh[i].hi = 56;
	    i++;
	}
	if ((ddc->timings1.t1 & 0x01) || (ddc->timings1.t2 & 0x08)) {
	    mon->vrefresh[i].lo = mon->vrefresh[i].hi = 60;
	    i++;
	}
	if (ddc->timings1.t2 & 0x04) {
	    mon->vrefresh[i].lo = mon->vrefresh[i].hi = 70;
	    i++;
	}
	if ((ddc->timings1.t1 & 0x08) || (ddc->timings1.t2 & 0x80)) {
	    mon->vrefresh[i].lo = mon->vrefresh[i].hi = 72;
	    i++;
	}
	if ((ddc->timings1.t1 & 0x04) || (ddc->timings1.t2 & 0x40) ||
	    (ddc->timings1.t2 & 0x02) || (ddc->timings1.t2 & 0x01)) {
	    mon->vrefresh[i].lo = mon->vrefresh[i].hi = 75;
	    i++;
	}
	mon->nVrefresh = i;
    }
}

static int RADEONValidateCloneModes(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr   info             = RADEONPTR(pScrn);
    ClockRangePtr   clockRanges;
    DisplayModePtr  tmp_mode         = NULL;
    DisplayModePtr  clone_mode, save_mode;
    int             modesFound       = 0;
    int             count            = 0;
    int             tmp_hdisplay     = 0;
    int             tmp_vdisplay     = 0;
    int             i, save_n_hsync, save_n_vrefresh;
    range           save_hsync, save_vrefresh;
    char            *s;
    char            **clone_mode_names = NULL;
    Bool            ddc_mode         = info->ddc_mode;
    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);

    /* Save all infomations that will be changed by clone mode validateion */
    save_mode = pScrn->modes;
    pScrn->modes = NULL;

    /* Clone display mode names, duplicate all mode names for primary
     * head.  Allocate one more, in case pScrn->display->modes[0] ==
     * NULL */
    while (pScrn->display->modes[count]) count++;
    clone_mode_names = xnfalloc((count+2) * sizeof(char*));
    for (i = 0; i < count; i++) {
	clone_mode_names[i] = xnfalloc(strlen(pScrn->display->modes[i]) + 1);
	strcpy(clone_mode_names[i], pScrn->display->modes[i]);
    }
    clone_mode_names[count]   = NULL;
    clone_mode_names[count+1] = NULL;

    pScrn->progClock = TRUE;

    clockRanges                    = xnfcalloc(sizeof(*clockRanges), 1);
    clockRanges->next              = NULL;
    clockRanges->minClock          = info->pll.min_pll_freq;
    clockRanges->maxClock          = info->pll.max_pll_freq * 10;
    clockRanges->clockIndex        = -1;
    clockRanges->interlaceAllowed  = (info->CloneType == MT_CRT);
    clockRanges->doubleScanAllowed = (info->CloneType == MT_CRT);

    /* Only take one clone mode from config file for now, rest of clone
     * modes will copy from primary head.
     */
    if ((s = xf86GetOptValString(info->Options, OPTION_CLONE_MODE))) {
	if (sscanf(s, "%dx%d", &tmp_hdisplay, &tmp_vdisplay) == 2) {
	    if(count > 0) free(clone_mode_names[0]);
	    else count++;
	    clone_mode_names[0] = xnfalloc(strlen(s)+1);
	    sprintf(clone_mode_names[0], "%dx%d", tmp_hdisplay, tmp_vdisplay);
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Clone mode %s in config file is used\n", clone_mode_names[0]);
	}
    }

    for (i = 0; i < count; i++) {
	if (sscanf(clone_mode_names[i], "%dx%d",
		   &tmp_hdisplay, &tmp_vdisplay) == 2) {
	    if (pScrn->display->virtualX < tmp_hdisplay)
		pScrn->display->virtualX = tmp_hdisplay;
	    if (pScrn->display->virtualY < tmp_vdisplay)
		pScrn->display->virtualY = tmp_vdisplay;
	}
    }

    save_hsync      = pScrn->monitor->hsync[0];
    save_vrefresh   = pScrn->monitor->vrefresh[0];
    save_n_hsync    = pScrn->monitor->nHsync;
    save_n_vrefresh = pScrn->monitor->nVrefresh;

    pScrn->monitor->DDC       = NULL;
    pScrn->monitor->nHsync    = 0;
    pScrn->monitor->nVrefresh = 0;

    if ((s = xf86GetOptValString(info->Options, OPTION_CLONE_HSYNC))) {
	if (sscanf(s, "%f-%f", &pScrn->monitor->hsync[0].lo,
		   &pScrn->monitor->hsync[0].hi) == 2) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "HSync for CloneMode from config file: %s\n", s);
	    pScrn->monitor->nHsync = 1;
	} else {
	    pScrn->monitor->nHsync = 0;
	}
    }

    if ((s = xf86GetOptValString(info->Options, OPTION_CLONE_VREFRESH))) {
	if (sscanf(s, "%f-%f", &pScrn->monitor->vrefresh[0].lo,
		   &pScrn->monitor->vrefresh[0].hi) == 2) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "VRefresh for CloneMode from config file: %s\n", s);
	    pScrn->monitor->nVrefresh = 1;
	} else {
	    pScrn->monitor->nVrefresh = 0;
	}
    }

    pScrn->monitor->DDC = pRADEONEnt->MonInfo2;
    if (pScrn->monitor->DDC) {
        if ((pScrn->monitor->nVrefresh == 0) || (pScrn->monitor->nHsync == 0)) {
            if (pScrn->monitor->nHsync == 0)
                RADEONSetSyncRangeFromEdid(pScrn, 1);
            if (pScrn->monitor->nVrefresh == 0)
                RADEONSetSyncRangeFromEdid(pScrn, 0);
        }
    } else if (info->ddc_mode) {
        ddc_mode = FALSE;
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                   "No DDC data available for clone mode, "
                   "DDCMode option is dismissed\n");
    }

    if (info->CloneType == MT_CRT && !ddc_mode) {
	modesFound =
	    xf86ValidateModes(pScrn, pScrn->monitor->Modes,
			      clone_mode_names,
			      clockRanges,
			      NULL,                     /* linePitches */
			      8 * 64,                   /* minPitch */
			      8 * 1024,                 /* maxPitch */
			      64 * pScrn->bitsPerPixel, /* pitchInc */
			      128,                      /* minHeight */
			      2048,                     /* maxHeight */
			      pScrn->display->virtualX,
			      pScrn->display->virtualY,
			      info->FbMapSize,
			      LOOKUP_BEST_REFRESH);
    } else {
	/* Try to add DDC modes */
	info->IsSecondary = TRUE; /*fake secondary head*/
	modesFound = RADEONValidateDDCModes(pScrn, clone_mode_names,
					    info->CloneType);
	info->IsSecondary = FALSE;

	/* If that fails and we're connect to a flat panel, then try to
         * add the flat panel modes
	 */
	if (modesFound < 1 && info->CloneType != MT_CRT) {
	    modesFound =
		xf86ValidateModes(pScrn, pScrn->monitor->Modes,
				  clone_mode_names,
				  clockRanges,
				  NULL,                     /* linePitches */
				  8 * 64,                   /* minPitch */
				  8 * 1024,                 /* maxPitch */
				  64 * pScrn->bitsPerPixel, /* pitchInc */
				  128,                      /* minHeight */
				  2048,                     /* maxHeight */
				  pScrn->display->virtualX,
				  pScrn->display->virtualY,
				  info->FbMapSize,
				  LOOKUP_BEST_REFRESH);
        }
    }

    if (modesFound > 0) {
        int valid = 0;
        save_mode = pScrn->modes;
	xf86SetCrtcForModes(pScrn, 0);
	xf86PrintModes(pScrn);
	for (i = 0; i < modesFound; i++) {

	    while (pScrn->modes->status != MODE_OK) {
		pScrn->modes = pScrn->modes->next;
	    }
	    if (!pScrn->modes) break;

	    if (pScrn->modes->Clock != 0.0) {

		clone_mode = xnfcalloc (1, sizeof (DisplayModeRec));
		if (!clone_mode) break;
		memcpy(clone_mode, pScrn->modes, sizeof(DisplayModeRec));
		clone_mode->name = xnfalloc(strlen(pScrn->modes->name) + 1);
		strcpy(clone_mode->name, pScrn->modes->name);

		if (!info->CurCloneMode) {
		    info->CloneModes = clone_mode;
		    info->CurCloneMode = clone_mode;
		    clone_mode->prev = NULL;
		} else {
		    clone_mode->prev = tmp_mode;
		    clone_mode->prev->next = clone_mode;
		}
		valid++;

		tmp_mode = clone_mode;
		clone_mode->next = NULL;
	    }
	    pScrn->modes = pScrn->modes->next;
	}

	/* no longer needed, free it */
	pScrn->modes = save_mode;
	while (pScrn->modes)
	  xf86DeleteMode(&pScrn->modes, pScrn->modes);
	pScrn->modes = NULL;

	/* modepool is no longer needed, free it */
	while (pScrn->modePool)
	  xf86DeleteMode(&pScrn->modePool, pScrn->modePool);
	pScrn->modePool = NULL;

	modesFound = valid;
    }

    /* Clone_mode_names list is no longer needed, free it. */
    if (clone_mode_names) {
	for (i = 0; clone_mode_names[i]; i++) {
	    free(clone_mode_names[i]);
	    clone_mode_names[i] = NULL;
	}

	free(clone_mode_names);
	clone_mode_names = NULL;
    }

    /* We need to restore all changed info for the primary head */

    pScrn->monitor->hsync[0]    = save_hsync;
    pScrn->monitor->vrefresh[0] = save_vrefresh;
    pScrn->monitor->nHsync      = save_n_hsync;
    pScrn->monitor->nVrefresh   = save_n_vrefresh;

    /*
     * Also delete the clockRanges (if it was setup) since it will be
     * set up during the primary head initialization.
     */
    while (pScrn->clockRanges) {
	ClockRangesPtr CRtmp = pScrn->clockRanges;
	pScrn->clockRanges = pScrn->clockRanges->next;
	xfree(CRtmp);
    }


    return modesFound;
}

/* This is called by RADEONPreInit to validate modes and compute
 * parameters for all of the valid modes.
 */
static Bool RADEONPreInitModes(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    ClockRangePtr  clockRanges;
    int            modesFound;
    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
    char           *s;

    /* This option has two purposes:
     *
     * 1. For CRT, if this option is on, xf86ValidateModes (to
     *    LOOKUP_BEST_REFRESH) is not going to be used for mode
     *    validation.  Instead, we'll validate modes by matching exactly
     *    the modes supported from the DDC data.  This option can be
     *    used (a) to enable non-standard modes listed in the Detailed
     *    Timings block of EDID, like 2048x1536 (not included in
     *    xf86DefModes), (b) to avoid unstable modes for some flat
     *    panels working in analog mode (some modes validated by
     *    xf86ValidateModes don't really work with these panels).
     *
     * 2. For DFP on primary head, with this option on, the validation
     *    routine will try to use supported modes from DDC data first
     *    before trying on-chip RMX streching.  By default, native mode
     *    + RMX streching is used for all non-native modes, it appears
     *    more reliable. Some non-native modes listed in the DDC data
     *    may not work properly if they are used directly. This seems to
     *    only happen to a few panels (haven't nailed this down yet, it
     *    may related to the incorrect setting in TMDS_PLL_CNTL when
     *    pixel clock is changed).  Use this option may give you better
     *    refresh rate for some non-native modes.  The 2nd DVI port will
     *    always use DDC modes directly (only have one on-chip RMX
     *    unit).
     *
     * Note: This option will be dismissed if no DDC data is available.
     */
    info->ddc_mode =
	xf86ReturnOptValBool(info->Options, OPTION_DDC_MODE, FALSE);

    /* don't use RMX if we have a dual-tdms panels */
   if (pRADEONEnt->MonType2 == MT_DFP)
	info->ddc_mode = TRUE;

    /* Here is a hack for cloning first display on the second head.  If
     * we don't do this, when both heads are connected, the same CRTC
     * will be used to drive them according to the capability of the
     * primary head.  This can cause an unstable or blank screen, or
     * even worse it can damage a monitor.  This feature is also
     * important for laptops (using M6, M7), where the panel can't be
     * disconnect when one wants to use the CRT port.  Although 2
     * Screens can be set up in the config file for displaying same
     * content on two monitors, it has problems with cursor, overlay,
     * DRI.
     */
    if (info->HasCRTC2) {
	if (info->Clone) {

	    /* If we have 2 screens from the config file, we don't need
	     * to do clone thing, let each screen handles one head.
	     */
	    if (!pRADEONEnt->HasSecondary) {
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "Clone modes validation ------------ \n");

		modesFound = RADEONValidateCloneModes(pScrn);
		if (modesFound < 1) {
		    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			       "No valid mode found for CRTC2 clone\n");
		    info->Clone = FALSE;
		    info->CurCloneMode = NULL;
		}
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "Total of %d clone modes found ------------ \n\n",
			   modesFound);
	    }
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Validating modes on %s head ---------\n",
	       info->IsSecondary ? "Secondary" : "Primary");

    if (info->IsSecondary)
        pScrn->monitor->DDC = pRADEONEnt->MonInfo2;
    else
        pScrn->monitor->DDC = pRADEONEnt->MonInfo1;

    if (!pScrn->monitor->DDC && info->ddc_mode) {
	info->ddc_mode = FALSE;
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "No DDC data available, DDCMode option is dismissed\n");
    }

    if ((info->DisplayType == MT_DFP) ||
	(info->DisplayType == MT_LCD)) {
	if ((s = xf86GetOptValString(info->Options, OPTION_PANEL_SIZE))) {
	    int PanelX, PanelY;
	    DisplayModePtr  tmp_mode         = NULL;
	    if (sscanf(s, "%dx%d", &PanelX, &PanelY) == 2) {
		info->PanelXRes = PanelX;
		info->PanelYRes = PanelY;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			   "Panel size is forced to: %s\n", s);

		/* We can't trust BIOS or DDC timings anymore,
		   Use whatever specified in the Modeline.
		   If no Modeline specified, we'll just pick the VESA mode at
		   60Hz refresh rate which is likely to be the best for a flat panel.
		*/
		info->ddc_mode = FALSE;
		pScrn->monitor->DDC = NULL;
		tmp_mode = pScrn->monitor->Modes;
		while(tmp_mode) {
		    if ((tmp_mode->HDisplay == PanelX) &&
			(tmp_mode->VDisplay == PanelY)) {

			float  refresh =
			    (float)tmp_mode->Clock * 1000.0 / tmp_mode->HTotal / tmp_mode->VTotal;
			if ((abs(60.0 - refresh) < 1.0) ||
			    (tmp_mode->type == 0)) {
			    info->HBlank     = tmp_mode->HTotal - tmp_mode->HDisplay;
			    info->HOverPlus  = tmp_mode->HSyncStart - tmp_mode->HDisplay;
			    info->HSyncWidth = tmp_mode->HSyncEnd - tmp_mode->HSyncStart;
			    info->VBlank     = tmp_mode->VTotal - tmp_mode->VDisplay;
			    info->VOverPlus  = tmp_mode->VSyncStart - tmp_mode->VDisplay;
			    info->VSyncWidth = tmp_mode->VSyncEnd - tmp_mode->VSyncStart;
			    info->DotClock   = tmp_mode->Clock;
			    info->Flags = 0;
			    break;
			}
		    }
		    tmp_mode = tmp_mode->next;
		}
		if (info->DotClock == 0) {
		    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			       "No valid timing info for specified panel size.\n"
			       "Please specify the Modeline for this panel\n");
		    return FALSE;
		}
	    } else {
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			   "Invalid PanelSize value: %s\n", s);
	    }
	}
    }

    if (pScrn->monitor->DDC) {
        /* If we still don't know sync range yet, let's try EDID.
         *
         * Note that, since we can have dual heads, Xconfigurator
         * may not be able to probe both monitors correctly through
         * vbe probe function (RADEONProbeDDC). Here we provide an
         * additional way to auto-detect sync ranges if they haven't
         * been added to XF86Config manually.
         */
        if (pScrn->monitor->nHsync <= 0)
            RADEONSetSyncRangeFromEdid(pScrn, 1);
        if (pScrn->monitor->nVrefresh <= 0)
            RADEONSetSyncRangeFromEdid(pScrn, 0);
    }

    /* Get mode information */
    pScrn->progClock               = TRUE;
    clockRanges                    = xnfcalloc(sizeof(*clockRanges), 1);
    clockRanges->next              = NULL;
    clockRanges->minClock          = info->pll.min_pll_freq;
    clockRanges->maxClock          = info->pll.max_pll_freq * 10;
    clockRanges->clockIndex        = -1;
    clockRanges->interlaceAllowed  = (info->DisplayType == MT_CRT);
    clockRanges->doubleScanAllowed = (info->DisplayType == MT_CRT);

    /* We'll use our own mode validation routine for DFP/LCD, since
     * xf86ValidateModes does not work correctly with the DFP/LCD modes
     * 'stretched' from their native mode.
     */
    if (info->DisplayType == MT_CRT && !info->ddc_mode) {

	modesFound =
	    xf86ValidateModes(pScrn,
			      pScrn->monitor->Modes,
			      pScrn->display->modes,
			      clockRanges,
			      NULL,                  /* linePitches */
			      8 * 64,                /* minPitch */
			      8 * 1024,              /* maxPitch */
			      64 * pScrn->bitsPerPixel, /* pitchInc */
			      128,                   /* minHeight */
			      2048,                  /* maxHeight */
			      pScrn->display->virtualX,
			      pScrn->display->virtualY,
			      info->FbMapSize,
			      LOOKUP_BEST_REFRESH);

	if (modesFound < 1 && info->FBDev) {
	    fbdevHWUseBuildinMode(pScrn);
	    pScrn->displayWidth = pScrn->virtualX; /* FIXME: might be wrong */
	    modesFound = 1;
	}

	if (modesFound == -1) return FALSE;

	xf86PruneDriverModes(pScrn);
	if (!modesFound || !pScrn->modes) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes found\n");
	    return FALSE;
	}

    } else {
	/* First, free any allocated modes during configuration, since
	 * we don't need them
	 */
	while (pScrn->modes)
	    xf86DeleteMode(&pScrn->modes, pScrn->modes);
	while (pScrn->modePool)
	    xf86DeleteMode(&pScrn->modePool, pScrn->modePool);

	/* Next try to add DDC modes */
	modesFound = RADEONValidateDDCModes(pScrn, pScrn->display->modes,
					    info->DisplayType);

	/* If that fails and we're connect to a flat panel, then try to
         * add the flat panel modes
	 */
	if (info->DisplayType != MT_CRT) {

	    /* some panels have DDC, but don't have internal scaler.
	     * in this case, we need to validate additional modes
	     * by using on-chip RMX.
	     */
	    int user_modes_asked = 0, user_modes_found = 0, i;
	    DisplayModePtr  tmp_mode = pScrn->modes;
	    while (pScrn->display->modes[user_modes_asked]) user_modes_asked++;
	    if (tmp_mode) {
		for (i = 0; i < modesFound; i++) {
		    if (tmp_mode->type & M_T_USERDEF) user_modes_found++;
		    tmp_mode = tmp_mode->next;
		}
	    }

	    if ((modesFound <= 1) || (user_modes_found < user_modes_asked)) {
		/* when panel size is not valid, try to validate
		 * mode using xf86ValidateModes routine
		 * This can happen when DDC is disabled.
		 */
		if (info->PanelXRes < 320 || info->PanelYRes < 200)
		    modesFound =
			xf86ValidateModes(pScrn,
					  pScrn->monitor->Modes,
					  pScrn->display->modes,
					  clockRanges,
					  NULL,                  /* linePitches */
					  8 * 64,                /* minPitch */
					  8 * 1024,              /* maxPitch */
					  64 * pScrn->bitsPerPixel, /* pitchInc */
					  128,                   /* minHeight */
					  2048,                  /* maxHeight */
					  pScrn->display->virtualX,
					  pScrn->display->virtualY,
					  info->FbMapSize,
					  LOOKUP_BEST_REFRESH);
		else if (!info->IsSecondary)
		    modesFound = RADEONValidateFPModes(pScrn, pScrn->display->modes);
	    }
        }

	/* Setup the screen's clockRanges for the VidMode extension */
	if (!pScrn->clockRanges) {
	    pScrn->clockRanges = xnfcalloc(sizeof(*(pScrn->clockRanges)), 1);
	    memcpy(pScrn->clockRanges, clockRanges, sizeof(*clockRanges));
	    pScrn->clockRanges->strategy = LOOKUP_BEST_REFRESH;
	}

	/* Fail if we still don't have any valid modes */
	if (modesFound < 1) {
	    if (info->DisplayType == MT_CRT) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "No valid DDC modes found for this CRT\n");
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Try turning off the \"DDCMode\" option\n");
	    } else {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "No valid mode found for this DFP/LCD\n");
	    }
	    return FALSE;
	}
    }

    xf86SetCrtcForModes(pScrn, 0);

    /* We need to adjust virtual size if the clone modes have larger
     * display size.
     */
    if (info->Clone && info->CloneModes) {
	DisplayModePtr  clone_mode = info->CloneModes;
	while (1) {
	    if ((clone_mode->HDisplay > pScrn->virtualX) ||
		(clone_mode->VDisplay > pScrn->virtualY)) {
		pScrn->virtualX =
		    pScrn->display->virtualX = clone_mode->HDisplay;
		pScrn->virtualY =
		    pScrn->display->virtualY = clone_mode->VDisplay;
		RADEONSetPitch(pScrn);
	    }
	    if (!clone_mode->next) break;
	    clone_mode = clone_mode->next;
	}
    }

    pScrn->currentMode = pScrn->modes;
    xf86PrintModes(pScrn);

				/* Set DPI */
    xf86SetDpi(pScrn, 0, 0);

				/* Get ScreenInit function */
    if (!xf86LoadSubModule(pScrn, "fb")) return FALSE;

    xf86LoaderReqSymLists(fbSymbols, NULL);

    info->CurrentLayout.displayWidth = pScrn->displayWidth;
    info->CurrentLayout.mode = pScrn->currentMode;

    return TRUE;
}

/* This is called by RADEONPreInit to initialize the hardware cursor */
static Bool RADEONPreInitCursor(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);

    if (!xf86ReturnOptValBool(info->Options, OPTION_SW_CURSOR, FALSE)) {
	if (!xf86LoadSubModule(pScrn, "ramdac")) return FALSE;
	xf86LoaderReqSymLists(ramdacSymbols, NULL);
    }
    return TRUE;
}

/* This is called by RADEONPreInit to initialize hardware acceleration */
static Bool RADEONPreInitAccel(ScrnInfoPtr pScrn)
{
#ifdef XFree86LOADER
    RADEONInfoPtr  info = RADEONPTR(pScrn);

    if (!xf86ReturnOptValBool(info->Options, OPTION_NOACCEL, FALSE)) {
	int errmaj = 0, errmin = 0;

	info->xaaReq.majorversion = 1;
	info->xaaReq.minorversion = 1;

	if (!LoadSubModule(pScrn->module, "xaa", NULL, NULL, NULL,
			   &info->xaaReq, &errmaj, &errmin)) {
	    info->xaaReq.minorversion = 0;

	    if (!LoadSubModule(pScrn->module, "xaa", NULL, NULL, NULL,
			       &info->xaaReq, &errmaj, &errmin)) {
		LoaderErrorMsg(NULL, "xaa", errmaj, errmin);
		return FALSE;
	    }
	}
	xf86LoaderReqSymLists(xaaSymbols, NULL);
    }
#endif

    return TRUE;
}

static Bool RADEONPreInitInt10(ScrnInfoPtr pScrn, xf86Int10InfoPtr *ppInt10)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);

#if !defined(__powerpc__)
    if (xf86LoadSubModule(pScrn, "int10")) {
	xf86LoaderReqSymLists(int10Symbols, NULL);
	xf86DrvMsg(pScrn->scrnIndex,X_INFO,"initializing int10\n");
	*ppInt10 = xf86InitInt10(info->pEnt->index);
    }
#endif
    return TRUE;
}

#ifdef XF86DRI
static Bool RADEONPreInitDRI(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);

    if (xf86ReturnOptValBool(info->Options, OPTION_CP_PIO, FALSE)) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Forcing CP into PIO mode\n");
	info->CPMode = RADEON_DEFAULT_CP_PIO_MODE;
    } else {
	info->CPMode = RADEON_DEFAULT_CP_BM_MODE;
    }

    info->agpMode       = RADEON_DEFAULT_AGP_MODE;
    info->gartSize      = RADEON_DEFAULT_GART_SIZE;
    info->ringSize      = RADEON_DEFAULT_RING_SIZE;
    info->bufSize       = RADEON_DEFAULT_BUFFER_SIZE;
    info->gartTexSize   = RADEON_DEFAULT_GART_TEX_SIZE;
    info->agpFastWrite  = RADEON_DEFAULT_AGP_FAST_WRITE;

    info->CPusecTimeout = RADEON_DEFAULT_CP_TIMEOUT;

    if (!info->IsPCI) {
	if (xf86GetOptValInteger(info->Options,
				 OPTION_AGP_MODE, &(info->agpMode))) {
	    if (info->agpMode < 1 || info->agpMode > RADEON_AGP_MAX_MODE) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Illegal AGP Mode: %d\n", info->agpMode);
		return FALSE;
	    }
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       "Using AGP %dx mode\n", info->agpMode);
	}

	if ((info->agpFastWrite = xf86ReturnOptValBool(info->Options,
						       OPTION_AGP_FW,
						       FALSE))) {
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       "Enabling AGP Fast Write\n");
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "AGP Fast Write disabled by default\n");
	}
    }

    if (xf86GetOptValInteger(info->Options,
			     OPTION_GART_SIZE, (int *)&(info->gartSize))) {
	switch (info->gartSize) {
	case 4:
	case 8:
	case 16:
	case 32:
	case 64:
	case 128:
	case 256:
	    break;

	default:
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Illegal GART size: %d MB\n", info->gartSize);
	    return FALSE;
	}
    }

    if (xf86GetOptValInteger(info->Options,
			     OPTION_RING_SIZE, &(info->ringSize))) {
	if (info->ringSize < 1 || info->ringSize >= (int)info->gartSize) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Illegal ring buffer size: %d MB\n",
		       info->ringSize);
	    return FALSE;
	}
    }

    if (xf86GetOptValInteger(info->Options,
			     OPTION_BUFFER_SIZE, &(info->bufSize))) {
	if (info->bufSize < 1 || info->bufSize >= (int)info->gartSize) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Illegal vertex/indirect buffers size: %d MB\n",
		       info->bufSize);
	    return FALSE;
	}
	if (info->bufSize > 2) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Illegal vertex/indirect buffers size: %d MB\n",
		       info->bufSize);
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Clamping vertex/indirect buffers size to 2 MB\n");
	    info->bufSize = 2;
	}
    }

    if (info->ringSize + info->bufSize + info->gartTexSize >
	(int)info->gartSize) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Buffers are too big for requested GART space\n");
	return FALSE;
    }

    info->gartTexSize = info->gartSize - (info->ringSize + info->bufSize);

    if (xf86GetOptValInteger(info->Options, OPTION_USEC_TIMEOUT,
			     &(info->CPusecTimeout))) {
	/* This option checked by the RADEON DRM kernel module */
    }

    /* Depth moves are disabled by default since they are extremely slow */
    if ((info->depthMoves = xf86ReturnOptValBool(info->Options,
						 OPTION_DEPTH_MOVE, FALSE))) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Enabling depth moves\n");
    } else {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Depth moves disabled by default\n");
    }

    /* Two options to try and squeeze as much texture memory as possible
     * for dedicated 3d rendering boxes
     */
    info->noBackBuffer = xf86ReturnOptValBool(info->Options,
					      OPTION_NO_BACKBUFFER,
					      FALSE);

    if (info->noBackBuffer) {
	info->allowPageFlip = 0;
    } else if (!xf86LoadSubModule(pScrn, "shadowfb")) {
	info->allowPageFlip = 0;
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Couldn't load shadowfb module:\n");
    } else {
	xf86LoaderReqSymLists(driShadowFBSymbols, NULL);

	info->allowPageFlip = xf86ReturnOptValBool(info->Options,
						   OPTION_PAGE_FLIP,
						   FALSE);
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Page flipping %sabled\n",
	       info->allowPageFlip ? "en" : "dis");

    return TRUE;
}
#endif

static void
RADEONProbeDDC(ScrnInfoPtr pScrn, int indx)
{
    vbeInfoPtr  pVbe;

    if (xf86LoadSubModule(pScrn, "vbe")) {
	pVbe = VBEInit(NULL,indx);
	ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
    }
}

/* RADEONPreInit is called once at server startup */
Bool RADEONPreInit(ScrnInfoPtr pScrn, int flags)
{
    RADEONInfoPtr     info;
    xf86Int10InfoPtr  pInt10 = NULL;
    void *int10_save = NULL;
    const char *s;

    RADEONTRACE(("RADEONPreInit\n"));
    if (pScrn->numEntities != 1) return FALSE;

    if (!RADEONGetRec(pScrn)) return FALSE;

    info               = RADEONPTR(pScrn);
    info->IsSecondary  = FALSE;
    info->Clone        = FALSE;
    info->CurCloneMode = NULL;
    info->CloneModes   = NULL;
    info->IsSwitching  = FALSE;
    info->MMIO         = NULL;

    info->pEnt         = xf86GetEntityInfo(pScrn->entityList[pScrn->numEntities - 1]);
    if (info->pEnt->location.type != BUS_PCI) goto fail;

    info->PciInfo = xf86GetPciInfoForEntity(info->pEnt->index);
    info->PciTag  = pciTag(info->PciInfo->bus,
			   info->PciInfo->device,
			   info->PciInfo->func);
    info->MMIOAddr   = info->PciInfo->memBase[2] & 0xffffff00;
    if (info->pEnt->device->IOBase) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		   "MMIO address override, using 0x%08lx instead of 0x%08lx\n",
		   info->pEnt->device->IOBase,
		   info->MMIOAddr);
	info->MMIOAddr = info->pEnt->device->IOBase;
    } else if (!info->MMIOAddr) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid MMIO address\n");
	goto fail1;
    }
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "MMIO registers at 0x%08lx\n", info->MMIOAddr);

    if(!RADEONMapMMIO(pScrn)) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Memory map the MMIO region failed\n");
	goto fail1;
    }

#if !defined(__alpha__)
    if (xf86GetPciDomain(info->PciTag) ||
	!xf86IsPrimaryPci(info->PciInfo))
	RADEONPreInt10Save(pScrn, &int10_save);
#else
    /* [Alpha] On the primary, the console already ran the BIOS and we're
     *         going to run it again - so make sure to "fix up" the card
     *         so that (1) we can read the BIOS ROM and (2) the BIOS will
     *         get the memory config right.
     */
    RADEONPreInt10Save(pScrn, &int10_save);
#endif

    if (xf86IsEntityShared(info->pEnt->index)) {
	if (xf86IsPrimInitDone(info->pEnt->index)) {

	    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);

	    info->IsSecondary = TRUE;
	    if (!pRADEONEnt->HasSecondary) {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "Only one monitor detected, Second screen "
			   "will NOT be created\n");
		goto fail2;
	    }
	    pRADEONEnt->pSecondaryScrn = pScrn;
	} else {
	    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);

	    xf86SetPrimInitDone(info->pEnt->index);

	    pRADEONEnt->pPrimaryScrn        = pScrn;
	    pRADEONEnt->RestorePrimary      = FALSE;
	    pRADEONEnt->IsSecondaryRestored = FALSE;
	}
    }

    if (flags & PROBE_DETECT) {
	RADEONProbeDDC(pScrn, info->pEnt->index);
	RADEONPostInt10Check(pScrn, int10_save);
	if(info->MMIO) RADEONUnmapMMIO(pScrn);
	return TRUE;
    }

    if (!xf86LoadSubModule(pScrn, "vgahw")) return FALSE;
    xf86LoaderReqSymLists(vgahwSymbols, NULL);
    if (!vgaHWGetHWRec(pScrn)) {
	RADEONFreeRec(pScrn);
	goto fail2;
    }

    vgaHWGetIOBase(VGAHWPTR(pScrn));

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "PCI bus %d card %d func %d\n",
	       info->PciInfo->bus,
	       info->PciInfo->device,
	       info->PciInfo->func);

    if (xf86RegisterResources(info->pEnt->index, 0, ResExclusive))
	goto fail;

    if (xf86SetOperatingState(resVga, info->pEnt->index, ResUnusedOpr))
	goto fail;

    pScrn->racMemFlags = RAC_FB | RAC_COLORMAP | RAC_VIEWPORT | RAC_CURSOR;
    pScrn->monitor     = pScrn->confScreen->monitor;

    if (!RADEONPreInitVisual(pScrn))
	goto fail;

				/* We can't do this until we have a
				   pScrn->display. */
    xf86CollectOptions(pScrn, NULL);
    if (!(info->Options = xalloc(sizeof(RADEONOptions))))
	goto fail;

    memcpy(info->Options, RADEONOptions, sizeof(RADEONOptions));
    xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, info->Options);

    if (!RADEONPreInitWeight(pScrn))
	goto fail;

    if (xf86GetOptValInteger(info->Options, OPTION_VIDEO_KEY,
			     &(info->videoKey))) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "video key set to 0x%x\n",
		   info->videoKey);
    } else {
	info->videoKey = 0x1E;
    }

    info->DispPriority = 1;
    if ((s = xf86GetOptValString(info->Options, OPTION_DISP_PRIORITY))) {
	if (strcmp(s, "AUTO") == 0) {
	    info->DispPriority = 1;
	} else if (strcmp(s, "BIOS") == 0) {
	    info->DispPriority = 0;
	} else if (strcmp(s, "HIGH") == 0) {
	    info->DispPriority = 2;
	} else
	    info->DispPriority = 1;
    }

    if (xf86ReturnOptValBool(info->Options, OPTION_FBDEV, FALSE)) {
	/* check for Linux framebuffer device */

	if (xf86LoadSubModule(pScrn, "fbdevhw")) {
	    xf86LoaderReqSymLists(fbdevHWSymbols, NULL);

	    if (fbdevHWInit(pScrn, info->PciInfo, NULL)) {
		pScrn->ValidMode     = fbdevHWValidMode;
		info->FBDev = TRUE;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			   "Using framebuffer device\n");
	    } else {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "fbdevHWInit failed, not using framebuffer device\n");
	    }
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Couldn't load fbdevhw module, not using framebuffer device\n");
	}
    }

    if (!info->FBDev)
	if (!RADEONPreInitInt10(pScrn, &pInt10))
	    goto fail;

    RADEONPostInt10Check(pScrn, int10_save);

    if (!RADEONPreInitConfig(pScrn))
	goto fail;

    RADEONPreInitDDC(pScrn);

    if (!RADEONGetBIOSParameters(pScrn, pInt10))
	goto fail;

    if (info->DisplayType == MT_DFP)
	RADEONGetTMDSInfo(pScrn);

    if (!RADEONGetPLLParameters(pScrn))          goto fail;

    if (!RADEONPreInitGamma(pScrn))              goto fail;

    if (!RADEONPreInitModes(pScrn, pInt10))      goto fail;

    if (!RADEONPreInitCursor(pScrn))             goto fail;

    if (!RADEONPreInitAccel(pScrn))              goto fail;

#ifdef XF86DRI
    if (!RADEONPreInitDRI(pScrn))                goto fail;
#endif

				/* Free the video bios (if applicable) */
    if (info->VBIOS) {
	xfree(info->VBIOS);
	info->VBIOS = NULL;
    }

				/* Free int10 info */
    if (pInt10)
	xf86FreeInt10(pInt10);

    if(info->MMIO) RADEONUnmapMMIO(pScrn);
    info->MMIO = NULL;

    xf86DrvMsg(pScrn->scrnIndex, X_NOTICE,
	       "For information on using the multimedia capabilities\n of this"
	       " adapter, please see http://gatos.sf.net.\n");

    return TRUE;

fail:
				/* Pre-init failed. */
    if (info->IsSecondary) {
        RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
	pRADEONEnt->HasSecondary = FALSE;
    }
				/* Free the video bios (if applicable) */
    if (info->VBIOS) {
	xfree(info->VBIOS);
	info->VBIOS = NULL;
    }

				/* Free int10 info */
    if (pInt10)
	xf86FreeInt10(pInt10);

    vgaHWFreeHWRec(pScrn);

 fail2:
    if(info->MMIO) RADEONUnmapMMIO(pScrn);
    info->MMIO = NULL;
 fail1:
    RADEONFreeRec(pScrn);

    return FALSE;
}

/* Load a palette */
static void RADEONLoadPalette(ScrnInfoPtr pScrn, int numColors,
			      int *indices, LOCO *colors, VisualPtr pVisual)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int            i;
    int            idx, j;
    unsigned char  r, g, b;

#ifdef XF86DRI
    if (info->CPStarted) DRILock(pScrn->pScreen, 0);
#endif

    if (info->accelOn) info->accel->Sync(pScrn);

    if (info->FBDev) {
	fbdevHWLoadPalette(pScrn, numColors, indices, colors, pVisual);
    } else {
	/* If the second monitor is connected, we also need to deal with
	 * the secondary palette
	 */
	if (info->IsSecondary) j = 1;
	else j = 0;

	PAL_SELECT(j);

	if (info->CurrentLayout.depth == 15) {
	    /* 15bpp mode.  This sends 32 values. */
	    for (i = 0; i < numColors; i++) {
		idx = indices[i];
		r   = colors[idx].red;
		g   = colors[idx].green;
		b   = colors[idx].blue;
		OUTPAL(idx * 8, r, g, b);
	    }
	} else if (info->CurrentLayout.depth == 16) {
	    /* 16bpp mode.  This sends 64 values.
	     *
	     * There are twice as many green values as there are values
	     * for red and blue.  So, we take each red and blue pair,
	     * and combine it with each of the two green values.
	     */
	    for (i = 0; i < numColors; i++) {
		idx = indices[i];
		r   = colors[idx / 2].red;
		g   = colors[idx].green;
		b   = colors[idx / 2].blue;
		RADEONWaitForFifo(pScrn, 32); /* delay */
		OUTPAL(idx * 4, r, g, b);

		/* AH - Added to write extra green data - How come this isn't
		 * needed on R128?  We didn't load the extra green data in the
		 * other routine
		 */
		if (idx <= 31) {
		    r   = colors[idx].red;
		    g   = colors[(idx * 2) + 1].green;
		    b   = colors[idx].blue;
		    RADEONWaitForFifo(pScrn, 32); /* delay */
		    OUTPAL(idx * 8, r, g, b);
		}
	    }
	} else {
	    /* 8bpp mode.  This sends 256 values. */
	    for (i = 0; i < numColors; i++) {
		idx = indices[i];
		r   = colors[idx].red;
		b   = colors[idx].blue;
		g   = colors[idx].green;
		RADEONWaitForFifo(pScrn, 32); /* delay */
		OUTPAL(idx, r, g, b);
	    }
	}

	if (info->Clone) {
	    PAL_SELECT(1);
	    if (info->CurrentLayout.depth == 15) {
		/* 15bpp mode.  This sends 32 values. */
		for (i = 0; i < numColors; i++) {
		    idx = indices[i];
		    r   = colors[idx].red;
		    g   = colors[idx].green;
		    b   = colors[idx].blue;
		    OUTPAL(idx * 8, r, g, b);
		}
	    } else if (info->CurrentLayout.depth == 16) {
		/* 16bpp mode.  This sends 64 values.
		 *
		 * There are twice as many green values as there are values
		 * for red and blue.  So, we take each red and blue pair,
		 * and combine it with each of the two green values.
		 */
		for (i = 0; i < numColors; i++) {
		    idx = indices[i];
		    r   = colors[idx / 2].red;
		    g   = colors[idx].green;
		    b   = colors[idx / 2].blue;
		    OUTPAL(idx * 4, r, g, b);

		    /* AH - Added to write extra green data - How come
		     * this isn't needed on R128?  We didn't load the
		     * extra green data in the other routine.
		     */
		    if (idx <= 31) {
			r   = colors[idx].red;
			g   = colors[(idx * 2) + 1].green;
			b   = colors[idx].blue;
			OUTPAL(idx * 8, r, g, b);
		    }
		}
	    } else {
		/* 8bpp mode.  This sends 256 values. */
		for (i = 0; i < numColors; i++) {
		    idx = indices[i];
		    r   = colors[idx].red;
		    b   = colors[idx].blue;
		    g   = colors[idx].green;
		    OUTPAL(idx, r, g, b);
		}
	    }
	}
    }

#ifdef XF86DRI
    if (info->CPStarted) DRIUnlock(pScrn->pScreen);
#endif
}

static void RADEONBlockHandler(int i, pointer blockData,
			       pointer pTimeout, pointer pReadmask)
{
    ScreenPtr      pScreen = screenInfo.screens[i];
    ScrnInfoPtr    pScrn   = xf86Screens[i];
    RADEONInfoPtr  info    = RADEONPTR(pScrn);

#ifdef XF86DRI
    if (info->directRenderingEnabled)
	FLUSH_RING();
#endif

    pScreen->BlockHandler = info->BlockHandler;
    (*pScreen->BlockHandler) (i, blockData, pTimeout, pReadmask);
    pScreen->BlockHandler = RADEONBlockHandler;

    if (info->VideoTimerCallback)
	(*info->VideoTimerCallback)(pScrn, currentTime.milliseconds);
}

/* Called at the start of each server generation. */
Bool RADEONScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
{
    ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
    RADEONInfoPtr  info  = RADEONPTR(pScrn);
    BoxRec         MemBox;
    int            y2;

    RADEONTRACE(("RADEONScreenInit %x %d\n",
		 pScrn->memPhysBase, pScrn->fbOffset));

#ifdef XF86DRI
				/* Turn off the CP for now. */
    info->CPInUse      = FALSE;
    info->CPStarted    = FALSE;
    info->directRenderingEnabled = FALSE;
#endif
    info->accelOn      = FALSE;
    pScrn->fbOffset    = 0;
    if (info->IsSecondary) pScrn->fbOffset = pScrn->videoRam * 1024;
    if (!RADEONMapMem(pScrn)) return FALSE;

#ifdef XF86DRI
    info->fbX = 0;
    info->fbY = 0;
#endif

    info->PaletteSavedOnVT = FALSE;

    RADEONSave(pScrn);
    if (info->FBDev) {
	unsigned char *RADEONMMIO = info->MMIO;

	if (!fbdevHWModeInit(pScrn, pScrn->currentMode)) return FALSE;
	info->ModeReg.surface_cntl = INREG(RADEON_SURFACE_CNTL);
    } else {
	if (!RADEONModeInit(pScrn, pScrn->currentMode)) return FALSE;
    }

    RADEONSaveScreen(pScreen, SCREEN_SAVER_ON);

    pScrn->AdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);

    if (info->CurCloneMode) {
	info->CloneFrameX0 =
	    (pScrn->virtualX - info->CurCloneMode->HDisplay) / 2;
	info->CloneFrameY0 =
	    (pScrn->virtualY - info->CurCloneMode->VDisplay) / 2;
	RADEONDoAdjustFrame(pScrn, info->CloneFrameX0, info->CloneFrameY0, TRUE);
    }

				/* Visual setup */
    miClearVisualTypes();
    if (!miSetVisualTypes(pScrn->depth,
			  miGetDefaultVisualMask(pScrn->depth),
			  pScrn->rgbBits,
			  pScrn->defaultVisual)) return FALSE;
    miSetPixmapDepths ();

#ifdef XF86DRI
				/* Setup DRI after visuals have been
				   established, but before fbScreenInit is
				   called.  fbScreenInit will eventually
				   call the driver's InitGLXVisuals call
				   back. */
    {
	/* FIXME: When we move to dynamic allocation of back and depth
	 * buffers, we will want to revisit the following check for 3
	 * times the virtual size of the screen below.
	 */
	int  width_bytes = (pScrn->displayWidth *
			    info->CurrentLayout.pixel_bytes);
	int  maxy        = info->FbMapSize / width_bytes;

	if (xf86ReturnOptValBool(info->Options, OPTION_NOACCEL, FALSE)) {
	    xf86DrvMsg(scrnIndex, X_WARNING,
		       "Acceleration disabled, not initializing the DRI\n");
	    info->directRenderingEnabled = FALSE;
	} else if (maxy <= pScrn->virtualY * 3) {
	    xf86DrvMsg(scrnIndex, X_WARNING,
		       "Static buffer allocation failed -- "
		       "need at least %d kB video memory\n",
		       (pScrn->displayWidth * pScrn->virtualY *
			info->CurrentLayout.pixel_bytes * 3 + 1023) / 1024);
	    info->directRenderingEnabled = FALSE;
	} else if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
		   (info->ChipFamily == CHIP_FAMILY_RS200) ||
		   (info->ChipFamily == CHIP_FAMILY_RS300)) {
	    info->directRenderingEnabled = FALSE;
	    xf86DrvMsg(scrnIndex, X_WARNING,
		       "Direct rendering not yet supported on "
		       "IGP320/330/340/350, 7000, 9000 integrated chips\n");
	} else if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		   (info->ChipFamily == CHIP_FAMILY_R350) ||
		   (info->ChipFamily == CHIP_FAMILY_RV350)) {
	    info->directRenderingEnabled = FALSE;
	    xf86DrvMsg(scrnIndex, X_WARNING,
		       "Direct rendering not yet supported on "
		       "Radeon 9500/9700 and newer cards\n");
	} else {
	    if (info->IsSecondary)
		info->directRenderingEnabled = FALSE;
	    else {
		/* Xinerama has sync problem with DRI, disable it for now */
		if (xf86IsEntityShared(info->pEnt->index)) {
		    info->directRenderingEnabled = FALSE;
		    xf86DrvMsg(scrnIndex, X_WARNING,
			       "Direct Rendering Disabled -- "
			       "Dual-head configuration is not working with "
			       "DRI at present.\n"
			       "Please use only one Device/Screen "
			       "section in your XFConfig file.\n");
		} else {
		    info->directRenderingEnabled =
			RADEONDRIScreenInit(pScreen);
		}
	    }
	}
    }
#endif

    if (!fbScreenInit(pScreen, info->FB,
		      pScrn->virtualX, pScrn->virtualY,
		      pScrn->xDpi, pScrn->yDpi, pScrn->displayWidth,
		      pScrn->bitsPerPixel))
	return FALSE;

    xf86SetBlackWhitePixels(pScreen);

    if (pScrn->bitsPerPixel > 8) {
	VisualPtr  visual;

	visual = pScreen->visuals + pScreen->numVisuals;
	while (--visual >= pScreen->visuals) {
	    if ((visual->class | DynamicClass) == DirectColor) {
		visual->offsetRed   = pScrn->offset.red;
		visual->offsetGreen = pScrn->offset.green;
		visual->offsetBlue  = pScrn->offset.blue;
		visual->redMask     = pScrn->mask.red;
		visual->greenMask   = pScrn->mask.green;
		visual->blueMask    = pScrn->mask.blue;
	    }
	}
    }

    /* Must be after RGB order fixed */
    fbPictureInit (pScreen, 0, 0);

#ifdef RENDER
    if (PictureGetSubpixelOrder (pScreen) == SubPixelUnknown)
    {
	int subPixelOrder;

	switch (info->DisplayType) {
	case MT_NONE:	subPixelOrder = SubPixelUnknown; break;
	case MT_LCD:	subPixelOrder = SubPixelHorizontalRGB; break;
	case MT_DFP:	subPixelOrder = SubPixelHorizontalRGB; break;
	default:	subPixelOrder = SubPixelNone; break;
	}
	PictureSetSubpixelOrder (pScreen, subPixelOrder);
    }
#endif
				/* Memory manager setup */
#ifdef XF86DRI
    if (info->directRenderingEnabled) {
	FBAreaPtr  fbarea;
	int        width_bytes = (pScrn->displayWidth *
				  info->CurrentLayout.pixel_bytes);
	int        cpp         = info->CurrentLayout.pixel_bytes;
	int        bufferSize  = ((pScrn->virtualY * width_bytes
				   + RADEON_BUFFER_ALIGN)
				  & ~RADEON_BUFFER_ALIGN);
	int        depthSize   = ((((pScrn->virtualY+15) & ~15) * width_bytes
				   + RADEON_BUFFER_ALIGN)
				  & ~RADEON_BUFFER_ALIGN);
	int        l;
	int        scanlines;

	info->frontOffset = 0;
	info->frontPitch = pScrn->displayWidth;

	switch (info->CPMode) {
	case RADEON_DEFAULT_CP_PIO_MODE:
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CP in PIO mode\n");
	    break;
	case RADEON_DEFAULT_CP_BM_MODE:
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CP in BM mode\n");
	    break;
	default:
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "CP in UNKNOWN mode\n");
	    break;
	}

	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Using %d MB GART aperture\n", info->gartSize);
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Using %d MB for the ring buffer\n", info->ringSize);
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Using %d MB for vertex/indirect buffers\n", info->bufSize);
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Using %d MB for GART textures\n", info->gartTexSize);

	/* Try for front, back, depth, and three framebuffers worth of
	 * pixmap cache.  Should be enough for a fullscreen background
	 * image plus some leftovers.
	 */
	info->textureSize = info->FbMapSize - 5 * bufferSize - depthSize;

	/* If that gives us less than half the available memory, let's
	 * be greedy and grab some more.  Sorry, I care more about 3D
	 * performance than playing nicely, and you'll get around a full
	 * framebuffer's worth of pixmap cache anyway.
	 */
	if (info->textureSize < (int)info->FbMapSize / 2) {
	    info->textureSize = info->FbMapSize - 4 * bufferSize - depthSize;
	}
	if (info->textureSize < (int)info->FbMapSize / 2) {
	    info->textureSize = info->FbMapSize - 3 * bufferSize - depthSize;
	}
	/* If there's still no space for textures, try without pixmap cache */
	if (info->textureSize < 0) {
	    info->textureSize = info->FbMapSize - 2 * bufferSize - depthSize
				- 64/4*64;
	}

	/* Check to see if there is more room available after the 8192nd
	   scanline for textures */
	if ((int)info->FbMapSize - 8192*width_bytes - bufferSize - depthSize
	    > info->textureSize) {
	    info->textureSize =
		info->FbMapSize - 8192*width_bytes - bufferSize - depthSize;
	}

	/* If backbuffer is disabled, don't allocate memory for it */
	if (info->noBackBuffer) {
	   info->textureSize += bufferSize;
	}

	if (info->textureSize > 0) {
	    l = RADEONMinBits((info->textureSize-1) / RADEON_NR_TEX_REGIONS);
	    if (l < RADEON_LOG_TEX_GRANULARITY) l = RADEON_LOG_TEX_GRANULARITY;

	    /* Round the texture size up to the nearest whole number of
	     * texture regions.  Again, be greedy about this, don't
	     * round down.
	     */
	    info->log2TexGran = l;
	    info->textureSize = (info->textureSize >> l) << l;
	} else {
	    info->textureSize = 0;
	}

	/* Set a minimum usable local texture heap size.  This will fit
	 * two 256x256x32bpp textures.
	 */
	if (info->textureSize < 512 * 1024) {
	    info->textureOffset = 0;
	    info->textureSize = 0;
	}

				/* Reserve space for textures */
	info->textureOffset = ((info->FbMapSize - info->textureSize +
				RADEON_BUFFER_ALIGN) &
			       ~(CARD32)RADEON_BUFFER_ALIGN);

				/* Reserve space for the shared depth
                                 * buffer.
				 */
	info->depthOffset = ((info->textureOffset - depthSize +
			      RADEON_BUFFER_ALIGN) &
			     ~(CARD32)RADEON_BUFFER_ALIGN);
	info->depthPitch = pScrn->displayWidth;

				/* Reserve space for the shared back buffer */
	if (info->noBackBuffer) {
	   info->backOffset = info->depthOffset;
	   info->backPitch = pScrn->displayWidth;
	} else {
	   info->backOffset = ((info->depthOffset - bufferSize +
				RADEON_BUFFER_ALIGN) &
			       ~(CARD32)RADEON_BUFFER_ALIGN);
	   info->backPitch = pScrn->displayWidth;
	}

	info->backY = info->backOffset / width_bytes;
	info->backX = (info->backOffset - (info->backY * width_bytes)) / cpp;

	scanlines = info->FbMapSize / width_bytes;
	if (scanlines > 8191) scanlines = 8191;

	MemBox.x1 = 0;
	MemBox.y1 = 0;
	MemBox.x2 = pScrn->displayWidth;
	MemBox.y2 = scanlines;

	if (!xf86InitFBManager(pScreen, &MemBox)) {
	    xf86DrvMsg(scrnIndex, X_ERROR,
		       "Memory manager initialization to "
		       "(%d,%d) (%d,%d) failed\n",
		       MemBox.x1, MemBox.y1, MemBox.x2, MemBox.y2);
	    return FALSE;
	} else {
	    int  width, height;

	    xf86DrvMsg(scrnIndex, X_INFO,
		       "Memory manager initialized to (%d,%d) (%d,%d)\n",
		       MemBox.x1, MemBox.y1, MemBox.x2, MemBox.y2);
	    if ((fbarea = xf86AllocateOffscreenArea(pScreen,
						    pScrn->displayWidth,
						    2, 0, NULL, NULL,
						    NULL))) {
		xf86DrvMsg(scrnIndex, X_INFO,
			   "Reserved area from (%d,%d) to (%d,%d)\n",
			   fbarea->box.x1, fbarea->box.y1,
			   fbarea->box.x2, fbarea->box.y2);
	    } else {
		xf86DrvMsg(scrnIndex, X_ERROR, "Unable to reserve area\n");
	    }
	    if (xf86QueryLargestOffscreenArea(pScreen, &width,
					      &height, 0, 0, 0)) {
		xf86DrvMsg(scrnIndex, X_INFO,
			   "Largest offscreen area available: %d x %d\n",
			   width, height);

		/* Lines in offscreen area needed for depth buffer and
		 * textures
		 */
		info->depthTexLines = (scanlines
				       - info->depthOffset / width_bytes);
		info->backLines	    = (scanlines
				       - info->backOffset / width_bytes
				       - info->depthTexLines);
		info->backArea	    = NULL;
	    } else {
		xf86DrvMsg(scrnIndex, X_ERROR,
			   "Unable to determine largest offscreen area "
			   "available\n");
		return FALSE;
	    }
	}

	xf86DrvMsg(scrnIndex, X_INFO,
		   "Will use back buffer at offset 0x%x\n",
		   info->backOffset);
	xf86DrvMsg(scrnIndex, X_INFO,
		   "Will use depth buffer at offset 0x%x\n",
		   info->depthOffset);
	xf86DrvMsg(scrnIndex, X_INFO,
		   "Will use %d kb for textures at offset 0x%x\n",
		   info->textureSize/1024, info->textureOffset);

	info->frontPitchOffset = (((info->frontPitch * cpp / 64) << 22) |
				  (info->frontOffset >> 10));

	info->backPitchOffset = (((info->backPitch * cpp / 64) << 22) |
				 (info->backOffset >> 10));

	info->depthPitchOffset = (((info->depthPitch * cpp / 64) << 22) |
				  (info->depthOffset >> 10));
    } else
#endif
    {
	MemBox.x1 = 0;
	MemBox.y1 = 0;
	MemBox.x2 = pScrn->displayWidth;
	y2        = (info->FbMapSize
		     / (pScrn->displayWidth *
			info->CurrentLayout.pixel_bytes));
	if (y2 >= 32768) y2 = 32767; /* because MemBox.y2 is signed short */
	MemBox.y2 = y2;

				/* The acceleration engine uses 14 bit
				   signed coordinates, so we can't have any
				   drawable caches beyond this region. */
	if (MemBox.y2 > 8191) MemBox.y2 = 8191;

	if (!xf86InitFBManager(pScreen, &MemBox)) {
	    xf86DrvMsg(scrnIndex, X_ERROR,
		       "Memory manager initialization to "
		       "(%d,%d) (%d,%d) failed\n",
		       MemBox.x1, MemBox.y1, MemBox.x2, MemBox.y2);
	    return FALSE;
	} else {
	    int       width, height;
	    FBAreaPtr fbarea;

	    xf86DrvMsg(scrnIndex, X_INFO,
		       "Memory manager initialized to (%d,%d) (%d,%d)\n",
		       MemBox.x1, MemBox.y1, MemBox.x2, MemBox.y2);
	    if ((fbarea = xf86AllocateOffscreenArea(pScreen,
						    pScrn->displayWidth,
						    2, 0, NULL, NULL,
						    NULL))) {
		xf86DrvMsg(scrnIndex, X_INFO,
			   "Reserved area from (%d,%d) to (%d,%d)\n",
			   fbarea->box.x1, fbarea->box.y1,
			   fbarea->box.x2, fbarea->box.y2);
	    } else {
		xf86DrvMsg(scrnIndex, X_ERROR, "Unable to reserve area\n");
	    }
	    if (xf86QueryLargestOffscreenArea(pScreen, &width, &height,
					      0, 0, 0)) {
		xf86DrvMsg(scrnIndex, X_INFO,
			   "Largest offscreen area available: %d x %d\n",
			   width, height);
	    }
	}
    }

				/* Acceleration setup */
    if (!xf86ReturnOptValBool(info->Options, OPTION_NOACCEL, FALSE)) {
	if (RADEONAccelInit(pScreen)) {
	    xf86DrvMsg(scrnIndex, X_INFO, "Acceleration enabled\n");
	    info->accelOn = TRUE;

	    /* FIXME: Figure out why this was added because it shouldn't be! */
	    /* This is needed by the DRI and XAA code for shared entities */
	    pScrn->pScreen = pScreen;
	} else {
	    xf86DrvMsg(scrnIndex, X_ERROR,
		       "Acceleration initialization failed\n");
	    xf86DrvMsg(scrnIndex, X_INFO, "Acceleration disabled\n");
	    info->accelOn = FALSE;
	}
    } else {
	xf86DrvMsg(scrnIndex, X_INFO, "Acceleration disabled\n");
	info->accelOn = FALSE;
    }

				/* DGA setup */
    RADEONDGAInit(pScreen);

				/* Backing store setup */
    miInitializeBackingStore(pScreen);
    xf86SetBackingStore(pScreen);

				/* Set Silken Mouse */
    xf86SetSilkenMouse(pScreen);

				/* Cursor setup */
    miDCInitialize(pScreen, xf86GetPointerScreenFuncs());

				/* Hardware cursor setup */
    if (!xf86ReturnOptValBool(info->Options, OPTION_SW_CURSOR, FALSE)) {
	if (RADEONCursorInit(pScreen)) {
	    int  width, height;

	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Using hardware cursor (scanline %ld)\n",
		       info->cursor_start / pScrn->displayWidth
		       / info->CurrentLayout.pixel_bytes);
	    if (xf86QueryLargestOffscreenArea(pScreen, &width, &height,
					      0, 0, 0)) {
		xf86DrvMsg(scrnIndex, X_INFO,
			   "Largest offscreen area available: %d x %d\n",
			   width, height);
	    }
	} else {
	    xf86DrvMsg(scrnIndex, X_ERROR,
		       "Hardware cursor initialization failed\n");
	    xf86DrvMsg(scrnIndex, X_INFO, "Using software cursor\n");
	}
    } else {
	info->cursor_start = 0;
	xf86DrvMsg(scrnIndex, X_INFO, "Using software cursor\n");
    }

				/* Colormap setup */
    if (!miCreateDefColormap(pScreen)) return FALSE;
    if (!xf86HandleColormaps(pScreen, 256, info->dac6bits ? 6 : 8,
			     RADEONLoadPalette, NULL,
			     CMAP_PALETTED_TRUECOLOR
#if 0 /* This option messes up text mode! (eich@@suse.de) */
			     | CMAP_LOAD_EVEN_IF_OFFSCREEN
#endif
			     | CMAP_RELOAD_ON_MODE_SWITCH)) return FALSE;

				/* DPMS setup */
    xf86DPMSInit(pScreen, RADEONDisplayPowerManagementSet, 0);

    RADEONInitVideo(pScreen);

				/* Provide SaveScreen */
    pScreen->SaveScreen  = RADEONSaveScreen;

				/* Wrap CloseScreen */
    info->CloseScreen    = pScreen->CloseScreen;
    pScreen->CloseScreen = RADEONCloseScreen;

				/* Note unused options */
    if (serverGeneration == 1)
	xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);

#ifdef XF86DRI
				/* DRI finalization */
    if (info->directRenderingEnabled) {
				/* Now that mi, fb, drm and others have
				   done their thing, complete the DRI
				   setup. */
	info->directRenderingEnabled = RADEONDRIFinishScreenInit(pScreen);
    }
    if (info->directRenderingEnabled) {
	if ((info->DispPriority == 1) && (!info->IsPCI)) {
	    /* we need to re-calculate bandwidth because of AGPMode difference. */
	    RADEONInitDispBandwidth(pScrn);
	}
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Direct rendering enabled\n");
    } else {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Direct rendering disabled\n");
    }
#endif

    info->BlockHandler = pScreen->BlockHandler;
    pScreen->BlockHandler = RADEONBlockHandler;

    return TRUE;
}

/* Write common registers (initialized to 0) */
static void RADEONRestoreCommonRegisters(ScrnInfoPtr pScrn,
					 RADEONSavePtr restore)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    OUTREG(RADEON_OVR_CLR,            restore->ovr_clr);
    OUTREG(RADEON_OVR_WID_LEFT_RIGHT, restore->ovr_wid_left_right);
    OUTREG(RADEON_OVR_WID_TOP_BOTTOM, restore->ovr_wid_top_bottom);
    OUTREG(RADEON_OV0_SCALE_CNTL,     restore->ov0_scale_cntl);
    OUTREG(RADEON_SUBPIC_CNTL,        restore->subpic_cntl);
    OUTREG(RADEON_VIPH_CONTROL,       restore->viph_control);
    OUTREG(RADEON_I2C_CNTL_1,         restore->i2c_cntl_1);
    OUTREG(RADEON_GEN_INT_CNTL,       restore->gen_int_cntl);
    OUTREG(RADEON_CAP0_TRIG_CNTL,     restore->cap0_trig_cntl);
    OUTREG(RADEON_CAP1_TRIG_CNTL,     restore->cap1_trig_cntl);
    OUTREG(RADEON_BUS_CNTL,           restore->bus_cntl);
    OUTREG(RADEON_SURFACE_CNTL,       restore->surface_cntl);

    /* Workaround for the VT switching problem in dual-head mode.  This
     * problem only occurs on RV style chips, typically when a FP and
     * CRT are connected.
     */
    if (info->HasCRTC2 &&
	!info->IsSwitching &&
	info->ChipFamily != CHIP_FAMILY_R200 &&
	info->ChipFamily != CHIP_FAMILY_R300 &&
	info->ChipFamily != CHIP_FAMILY_R350 &&
	info->ChipFamily != CHIP_FAMILY_RV350) {
	CARD32        tmp;
        RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);

	if (pRADEONEnt->HasSecondary || info->Clone) {
	    tmp = INREG(RADEON_DAC_CNTL2);
	    OUTREG(RADEON_DAC_CNTL2, tmp & ~RADEON_DAC2_DAC_CLK_SEL);
	    usleep(100000);
	}
    }
}

/* Write miscellaneous registers which might have been destroyed by an fbdevHW
 * call
 */
static void RADEONRestoreFBDevRegisters(ScrnInfoPtr pScrn,
					 RADEONSavePtr restore)
{
#ifdef XF86DRI
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    /* Restore register for vertical blank interrupts */
    if (info->irq) {
	OUTREG(RADEON_GEN_INT_CNTL, restore->gen_int_cntl);
    }

    /* Restore registers for page flipping */
    if (info->allowPageFlip) {
	OUTREG(RADEON_CRTC_OFFSET_CNTL, restore->crtc_offset_cntl);
	if (info->HasCRTC2) {
	    OUTREG(RADEON_CRTC2_OFFSET_CNTL, restore->crtc2_offset_cntl);
	}
    }
#endif
}

/* Write CRTC registers */
static void RADEONRestoreCrtcRegisters(ScrnInfoPtr pScrn,
				       RADEONSavePtr restore)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    OUTREG(RADEON_CRTC_GEN_CNTL, restore->crtc_gen_cntl);

    OUTREGP(RADEON_CRTC_EXT_CNTL,
	    restore->crtc_ext_cntl,
	    RADEON_CRTC_VSYNC_DIS |
	    RADEON_CRTC_HSYNC_DIS |
	    RADEON_CRTC_DISPLAY_DIS);

    OUTREGP(RADEON_DAC_CNTL,
	    restore->dac_cntl,
	    RADEON_DAC_RANGE_CNTL |
	    RADEON_DAC_BLANKING);

    OUTREG(RADEON_CRTC_H_TOTAL_DISP,    restore->crtc_h_total_disp);
    OUTREG(RADEON_CRTC_H_SYNC_STRT_WID, restore->crtc_h_sync_strt_wid);
    OUTREG(RADEON_CRTC_V_TOTAL_DISP,    restore->crtc_v_total_disp);
    OUTREG(RADEON_CRTC_V_SYNC_STRT_WID, restore->crtc_v_sync_strt_wid);
    OUTREG(RADEON_CRTC_OFFSET,          restore->crtc_offset);
    OUTREG(RADEON_CRTC_OFFSET_CNTL,     restore->crtc_offset_cntl);
    OUTREG(RADEON_CRTC_PITCH,           restore->crtc_pitch);
    OUTREG(RADEON_DISP_MERGE_CNTL,      restore->disp_merge_cntl);
    OUTREG(RADEON_CRTC_MORE_CNTL,       restore->crtc_more_cntl);
}

/* Write CRTC2 registers */
static void RADEONRestoreCrtc2Registers(ScrnInfoPtr pScrn,
					RADEONSavePtr restore)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    OUTREGP(RADEON_CRTC2_GEN_CNTL,
	    restore->crtc2_gen_cntl,
	    RADEON_CRTC2_VSYNC_DIS |
	    RADEON_CRTC2_HSYNC_DIS |
	    RADEON_CRTC2_DISP_DIS);

    OUTREG(RADEON_DAC_CNTL2, restore->dac2_cntl);

    OUTREG(RADEON_TV_DAC_CNTL, 0x00280203);
    if ((info->ChipFamily == CHIP_FAMILY_R200) ||
	(info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {
	OUTREG(RADEON_DISP_OUTPUT_CNTL, restore->disp_output_cntl);
    } else {
	OUTREG(RADEON_DISP_HW_DEBUG, restore->disp_hw_debug);
    }

    OUTREG(RADEON_CRTC2_H_TOTAL_DISP,    restore->crtc2_h_total_disp);
    OUTREG(RADEON_CRTC2_H_SYNC_STRT_WID, restore->crtc2_h_sync_strt_wid);
    OUTREG(RADEON_CRTC2_V_TOTAL_DISP,    restore->crtc2_v_total_disp);
    OUTREG(RADEON_CRTC2_V_SYNC_STRT_WID, restore->crtc2_v_sync_strt_wid);
    OUTREG(RADEON_CRTC2_OFFSET,          restore->crtc2_offset);
    OUTREG(RADEON_CRTC2_OFFSET_CNTL,     restore->crtc2_offset_cntl);
    OUTREG(RADEON_CRTC2_PITCH,           restore->crtc2_pitch);
    OUTREG(RADEON_DISP2_MERGE_CNTL,      restore->disp2_merge_cntl);

    if ((info->DisplayType == MT_DFP && info->IsSecondary) ||
	info->CloneType == MT_DFP) {
	OUTREG(RADEON_FP_H2_SYNC_STRT_WID, restore->fp2_h_sync_strt_wid);
	OUTREG(RADEON_FP_V2_SYNC_STRT_WID, restore->fp2_v_sync_strt_wid);
	OUTREG(RADEON_FP2_GEN_CNTL,        restore->fp2_gen_cntl);
    }
#if 0
    /* Hack for restoring text mode -- fixed elsewhere */
    usleep(100000);
#endif
}

/* Write flat panel registers */
static void RADEONRestoreFPRegisters(ScrnInfoPtr pScrn, RADEONSavePtr restore)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    unsigned long  tmp;

    OUTREG(RADEON_FP_CRTC_H_TOTAL_DISP, restore->fp_crtc_h_total_disp);
    OUTREG(RADEON_FP_CRTC_V_TOTAL_DISP, restore->fp_crtc_v_total_disp);
    OUTREG(RADEON_FP_H_SYNC_STRT_WID,   restore->fp_h_sync_strt_wid);
    OUTREG(RADEON_FP_V_SYNC_STRT_WID,   restore->fp_v_sync_strt_wid);
    OUTREG(RADEON_TMDS_PLL_CNTL,        restore->tmds_pll_cntl);
    OUTREG(RADEON_TMDS_TRANSMITTER_CNTL,restore->tmds_transmitter_cntl);
    OUTREG(RADEON_FP_HORZ_STRETCH,      restore->fp_horz_stretch);
    OUTREG(RADEON_FP_VERT_STRETCH,      restore->fp_vert_stretch);
    OUTREG(RADEON_FP_GEN_CNTL,          restore->fp_gen_cntl);

    /* old AIW Radeon has some BIOS initialization problem
     * with display buffer underflow, only occurs to DFP
     */
    if (!info->HasCRTC2)
	OUTREG(RADEON_GRPH_BUFFER_CNTL,
	       INREG(RADEON_GRPH_BUFFER_CNTL) & ~0x7f0000);

    if (info->DisplayType != MT_DFP) {
	unsigned long tmpPixclksCntl = INPLL(pScrn, RADEON_PIXCLKS_CNTL);
        OUTREG(RADEON_BIOS_5_SCRATCH, restore->bios_5_scratch);

	if (info->IsMobility || info->IsIGP) {
	    /* Asic bug, when turning off LVDS_ON, we have to make sure
	       RADEON_PIXCLK_LVDS_ALWAYS_ON bit is off
	    */
	    if (!(restore->lvds_gen_cntl & RADEON_LVDS_ON)) {
		OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL, 0, ~RADEON_PIXCLK_LVDS_ALWAYS_ONb);
	    }
	}

	tmp = INREG(RADEON_LVDS_GEN_CNTL);
	if ((tmp & (RADEON_LVDS_ON | RADEON_LVDS_BLON)) ==
	    (restore->lvds_gen_cntl & (RADEON_LVDS_ON | RADEON_LVDS_BLON))) {
	    OUTREG(RADEON_LVDS_GEN_CNTL, restore->lvds_gen_cntl);
	} else {
	    if (restore->lvds_gen_cntl & (RADEON_LVDS_ON | RADEON_LVDS_BLON)) {
		usleep(RADEONPTR(pScrn)->PanelPwrDly * 1000);
		OUTREG(RADEON_LVDS_GEN_CNTL, restore->lvds_gen_cntl);
	    } else {
		OUTREG(RADEON_LVDS_GEN_CNTL,
		       restore->lvds_gen_cntl | RADEON_LVDS_BLON);
		usleep(RADEONPTR(pScrn)->PanelPwrDly * 1000);
		OUTREG(RADEON_LVDS_GEN_CNTL, restore->lvds_gen_cntl);
	    }
	}

	if (info->IsMobility || info->IsIGP) {
	    if (!(restore->lvds_gen_cntl & RADEON_LVDS_ON)) {
		OUTPLL(RADEON_PIXCLKS_CNTL, tmpPixclksCntl);
	    }
	}
    }
}

static void RADEONPLLWaitForReadUpdateComplete(ScrnInfoPtr pScrn)
{
    int i = 0;

    /* FIXME: Certain revisions of R300 can't recover here.  Not sure of
       the cause yet, but this workaround will mask the problem for now.
       Other chips usually will pass at the very first test, so the
       workaround shouldn't have any effect on them. */
    for (i = 0;
	 (i < 10000 &&
	  INPLL(pScrn, RADEON_PPLL_REF_DIV) & RADEON_PPLL_ATOMIC_UPDATE_R);
	 i++);
}

static void RADEONPLLWriteUpdate(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    while (INPLL(pScrn, RADEON_PPLL_REF_DIV) & RADEON_PPLL_ATOMIC_UPDATE_R);

    OUTPLLP(pScrn, RADEON_PPLL_REF_DIV,
	    RADEON_PPLL_ATOMIC_UPDATE_W,
	    ~(RADEON_PPLL_ATOMIC_UPDATE_W));
}

static void RADEONPLL2WaitForReadUpdateComplete(ScrnInfoPtr pScrn)
{
    int i = 0;

    /* FIXME: Certain revisions of R300 can't recover here.  Not sure of
       the cause yet, but this workaround will mask the problem for now.
       Other chips usually will pass at the very first test, so the
       workaround shouldn't have any effect on them. */
    for (i = 0;
	 (i < 10000 &&
	  INPLL(pScrn, RADEON_P2PLL_REF_DIV) & RADEON_P2PLL_ATOMIC_UPDATE_R);
	 i++);
}

static void RADEONPLL2WriteUpdate(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    while (INPLL(pScrn, RADEON_P2PLL_REF_DIV) & RADEON_P2PLL_ATOMIC_UPDATE_R);

    OUTPLLP(pScrn, RADEON_P2PLL_REF_DIV,
	    RADEON_P2PLL_ATOMIC_UPDATE_W,
	    ~(RADEON_P2PLL_ATOMIC_UPDATE_W));
}

/* Write PLL registers */
static void RADEONRestorePLLRegisters(ScrnInfoPtr pScrn,
				      RADEONSavePtr restore)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    /* 
     * Never do it on Apple iBook to avoid a blank screen.
     */
#ifdef __powerpc__
    if (xf86ReturnOptValBool(info->Options, OPTION_IBOOKHACKS, FALSE))
        return;
#endif

    if (info->IsMobility) {
        /* A temporal workaround for the occational blanking on certain laptop panels.
           This appears to related to the PLL divider registers (fail to lock?).
	   It occurs even when all dividers are the same with their old settings.
           In this case we really don't need to fiddle with PLL registers.
           By doing this we can avoid the blanking problem with some panels.
        */
        if ((restore->ppll_ref_div == (INPLL(pScrn, RADEON_PPLL_REF_DIV) & RADEON_PPLL_REF_DIV_MASK)) &&
	    (restore->ppll_div_3 == (INPLL(pScrn, RADEON_PPLL_DIV_3) & (RADEON_PPLL_POST3_DIV_MASK | RADEON_PPLL_FB3_DIV_MASK))))
            return;
    }

    OUTPLLP(pScrn, RADEON_VCLK_ECP_CNTL,
	    RADEON_VCLK_SRC_SEL_CPUCLK,
	    ~(RADEON_VCLK_SRC_SEL_MASK));

    OUTPLLP(pScrn,
	    RADEON_PPLL_CNTL,
	    RADEON_PPLL_RESET
	    | RADEON_PPLL_ATOMIC_UPDATE_EN
	    | RADEON_PPLL_VGA_ATOMIC_UPDATE_EN,
	    ~(RADEON_PPLL_RESET
	      | RADEON_PPLL_ATOMIC_UPDATE_EN
	      | RADEON_PPLL_VGA_ATOMIC_UPDATE_EN));

    OUTREGP(RADEON_CLOCK_CNTL_INDEX,
	    RADEON_PLL_DIV_SEL,
	    ~(RADEON_PLL_DIV_SEL));

    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_RS300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {
	if (restore->ppll_ref_div & R300_PPLL_REF_DIV_ACC_MASK) {
	    /* When restoring console mode, use saved PPLL_REF_DIV
	     * setting.
	     */
	    OUTPLLP(pScrn, RADEON_PPLL_REF_DIV,
		    restore->ppll_ref_div,
		    0);
	} else {
	    /* R300 uses ref_div_acc field as real ref divider */
	    OUTPLLP(pScrn, RADEON_PPLL_REF_DIV,
		    (restore->ppll_ref_div << R300_PPLL_REF_DIV_ACC_SHIFT),
		    ~R300_PPLL_REF_DIV_ACC_MASK);
	}
    } else {
	OUTPLLP(pScrn, RADEON_PPLL_REF_DIV,
		restore->ppll_ref_div,
		~RADEON_PPLL_REF_DIV_MASK);
    }

    OUTPLLP(pScrn, RADEON_PPLL_DIV_3,
	    restore->ppll_div_3,
	    ~RADEON_PPLL_FB3_DIV_MASK);

    OUTPLLP(pScrn, RADEON_PPLL_DIV_3,
	    restore->ppll_div_3,
	    ~RADEON_PPLL_POST3_DIV_MASK);

    RADEONPLLWriteUpdate(pScrn);
    RADEONPLLWaitForReadUpdateComplete(pScrn);

    OUTPLL(RADEON_HTOTAL_CNTL, restore->htotal_cntl);

    OUTPLLP(pScrn, RADEON_PPLL_CNTL,
	    0,
	    ~(RADEON_PPLL_RESET
	      | RADEON_PPLL_SLEEP
	      | RADEON_PPLL_ATOMIC_UPDATE_EN
	      | RADEON_PPLL_VGA_ATOMIC_UPDATE_EN));

    xf86DrvMsg(0, X_INFO, "Wrote: rd=%d, fd=%d, pd=%d\n",
	       restore->ppll_ref_div & RADEON_PPLL_REF_DIV_MASK,
	       restore->ppll_div_3 & RADEON_PPLL_FB3_DIV_MASK,
	       (restore->ppll_div_3 & RADEON_PPLL_POST3_DIV_MASK) >> 16);

    RADEONTRACE(("Wrote: 0x%08x 0x%08x 0x%08x (0x%08x)\n",
	       restore->ppll_ref_div,
	       restore->ppll_div_3,
	       restore->htotal_cntl,
	       INPLL(pScrn, RADEON_PPLL_CNTL)));
    RADEONTRACE(("Wrote: rd=%d, fd=%d, pd=%d\n",
	       restore->ppll_ref_div & RADEON_PPLL_REF_DIV_MASK,
	       restore->ppll_div_3 & RADEON_PPLL_FB3_DIV_MASK,
	       (restore->ppll_div_3 & RADEON_PPLL_POST3_DIV_MASK) >> 16));

    usleep(5000); /* Let the clock to lock */

    OUTPLLP(pScrn, RADEON_VCLK_ECP_CNTL,
	    RADEON_VCLK_SRC_SEL_PPLLCLK,
	    ~(RADEON_VCLK_SRC_SEL_MASK));
}


/* Write PLL2 registers */
static void RADEONRestorePLL2Registers(ScrnInfoPtr pScrn,
				       RADEONSavePtr restore)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL,
	    RADEON_PIX2CLK_SRC_SEL_CPUCLK,
	    ~(RADEON_PIX2CLK_SRC_SEL_MASK));

    OUTPLLP(pScrn,
	    RADEON_P2PLL_CNTL,
	    RADEON_P2PLL_RESET
	    | RADEON_P2PLL_ATOMIC_UPDATE_EN
	    | RADEON_P2PLL_VGA_ATOMIC_UPDATE_EN,
	    ~(RADEON_P2PLL_RESET
	      | RADEON_P2PLL_ATOMIC_UPDATE_EN
	      | RADEON_P2PLL_VGA_ATOMIC_UPDATE_EN));

    OUTPLLP(pScrn, RADEON_P2PLL_REF_DIV,
	    restore->p2pll_ref_div,
	    ~RADEON_P2PLL_REF_DIV_MASK);

    OUTPLLP(pScrn, RADEON_P2PLL_DIV_0,
	    restore->p2pll_div_0,
	    ~RADEON_P2PLL_FB0_DIV_MASK);

    OUTPLLP(pScrn, RADEON_P2PLL_DIV_0,
	    restore->p2pll_div_0,
	    ~RADEON_P2PLL_POST0_DIV_MASK);

    RADEONPLL2WriteUpdate(pScrn);
    RADEONPLL2WaitForReadUpdateComplete(pScrn);

    OUTPLL(RADEON_HTOTAL2_CNTL, restore->htotal_cntl2);

    OUTPLLP(pScrn, RADEON_P2PLL_CNTL,
	    0,
	    ~(RADEON_P2PLL_RESET
	      | RADEON_P2PLL_SLEEP
	      | RADEON_P2PLL_ATOMIC_UPDATE_EN
	      | RADEON_P2PLL_VGA_ATOMIC_UPDATE_EN));

    RADEONTRACE(("Wrote: 0x%08x 0x%08x 0x%08x (0x%08x)\n",
	       restore->p2pll_ref_div,
	       restore->p2pll_div_0,
	       restore->htotal_cntl2,
	       INPLL(pScrn, RADEON_P2PLL_CNTL)));
    RADEONTRACE(("Wrote: rd=%d, fd=%d, pd=%d\n",
	       restore->p2pll_ref_div & RADEON_P2PLL_REF_DIV_MASK,
	       restore->p2pll_div_0 & RADEON_P2PLL_FB0_DIV_MASK,
	       (restore->p2pll_div_0 & RADEON_P2PLL_POST0_DIV_MASK) >>16));

    usleep(5000); /* Let the clock to lock */

    OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL,
	    RADEON_PIX2CLK_SRC_SEL_P2PLLCLK,
	    ~(RADEON_PIX2CLK_SRC_SEL_MASK));
}

#if 0
/* Write palette data */
static void RADEONRestorePalette(ScrnInfoPtr pScrn, RADEONSavePtr restore)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int            i;

    if (!restore->palette_valid) return;

    PAL_SELECT(1);
    OUTPAL_START(0);
    for (i = 0; i < 256; i++) {
	RADEONWaitForFifo(pScrn, 32); /* delay */
	OUTPAL_NEXT_CARD32(restore->palette2[i]);
    }

    PAL_SELECT(0);
    OUTPAL_START(0);
    for (i = 0; i < 256; i++) {
	RADEONWaitForFifo(pScrn, 32); /* delay */
	OUTPAL_NEXT_CARD32(restore->palette[i]);
    }
}
#endif

/* Write out state to define a new video mode */
static void RADEONRestoreMode(ScrnInfoPtr pScrn, RADEONSavePtr restore)
{
    RADEONInfoPtr      info = RADEONPTR(pScrn);
    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
    static RADEONSaveRec  restore0;

    /* For Non-dual head card, we don't have private field in the Entity */
    if (!info->HasCRTC2) {
	RADEONRestoreCommonRegisters(pScrn, restore);
	RADEONRestoreCrtcRegisters(pScrn, restore);
	RADEONRestoreFPRegisters(pScrn, restore);
	RADEONRestorePLLRegisters(pScrn, restore);
	return;
    }

    RADEONTRACE(("RADEONRestoreMode(%p)\n", restore));

    /* When changing mode with Dual-head card, care must be taken for
     * the special order in setting registers. CRTC2 has to be set
     * before changing CRTC_EXT register.  In the dual-head setup, X
     * server calls this routine twice with primary and secondary pScrn
     * pointers respectively. The calls can come with different
     * order. Regardless the order of X server issuing the calls, we
     * have to ensure we set registers in the right order!!!  Otherwise
     * we may get a blank screen.
     */
    if (info->IsSecondary) {
	if (!pRADEONEnt->RestorePrimary  && !info->IsSwitching)
	    RADEONRestoreCommonRegisters(pScrn, restore);
	RADEONRestoreCrtc2Registers(pScrn, restore);
	RADEONRestorePLL2Registers(pScrn, restore);

	if(info->IsSwitching) return;

	pRADEONEnt->IsSecondaryRestored = TRUE;

	if (pRADEONEnt->RestorePrimary) {
	    pRADEONEnt->RestorePrimary = FALSE;

	    RADEONRestoreCrtcRegisters(pScrn, &restore0);
	    RADEONRestoreFPRegisters(pScrn, &restore0);
	    RADEONRestorePLLRegisters(pScrn, &restore0);
	    pRADEONEnt->IsSecondaryRestored = FALSE;
	}
    } else {
	if (!pRADEONEnt->IsSecondaryRestored)
	    RADEONRestoreCommonRegisters(pScrn, restore);

	if (info->Clone) {
	    RADEONRestoreCrtc2Registers(pScrn, restore);
	    RADEONRestorePLL2Registers(pScrn, restore);
	}

	if (!pRADEONEnt->HasSecondary || pRADEONEnt->IsSecondaryRestored ||
	    info->IsSwitching) {
	    pRADEONEnt->IsSecondaryRestored = FALSE;

	    RADEONRestoreCrtcRegisters(pScrn, restore);
	    RADEONRestoreFPRegisters(pScrn, restore);
	    RADEONRestorePLLRegisters(pScrn, restore);
	} else {
	    memcpy(&restore0, restore, sizeof(restore0));
	    pRADEONEnt->RestorePrimary = TRUE;
	}
    }

#if 0
    RADEONRestorePalette(pScrn, &info->SavedReg);
#endif
}

/* Read common registers */
static void RADEONSaveCommonRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    save->ovr_clr            = INREG(RADEON_OVR_CLR);
    save->ovr_wid_left_right = INREG(RADEON_OVR_WID_LEFT_RIGHT);
    save->ovr_wid_top_bottom = INREG(RADEON_OVR_WID_TOP_BOTTOM);
    save->ov0_scale_cntl     = INREG(RADEON_OV0_SCALE_CNTL);
    save->subpic_cntl        = INREG(RADEON_SUBPIC_CNTL);
    save->viph_control       = INREG(RADEON_VIPH_CONTROL);
    save->i2c_cntl_1         = INREG(RADEON_I2C_CNTL_1);
    save->gen_int_cntl       = INREG(RADEON_GEN_INT_CNTL);
    save->cap0_trig_cntl     = INREG(RADEON_CAP0_TRIG_CNTL);
    save->cap1_trig_cntl     = INREG(RADEON_CAP1_TRIG_CNTL);
    save->bus_cntl           = INREG(RADEON_BUS_CNTL);
    save->surface_cntl	     = INREG(RADEON_SURFACE_CNTL);
    save->grph_buffer_cntl   = INREG(RADEON_GRPH_BUFFER_CNTL);
    save->grph2_buffer_cntl  = INREG(RADEON_GRPH2_BUFFER_CNTL);
}

/* Read miscellaneous registers which might be destroyed by an fbdevHW call */
static void RADEONSaveFBDevRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save)
{
#ifdef XF86DRI
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    /* Save register for vertical blank interrupts */
    if (info->irq) {
	save->gen_int_cntl = INREG(RADEON_GEN_INT_CNTL);
    }

    /* Save registers for page flipping */
    if (info->allowPageFlip) {
	save->crtc_offset_cntl = INREG(RADEON_CRTC_OFFSET_CNTL);
	if (info->HasCRTC2) {
	    save->crtc2_offset_cntl = INREG(RADEON_CRTC2_OFFSET_CNTL);
	}
    }
#endif
}

/* Read CRTC registers */
static void RADEONSaveCrtcRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    save->crtc_gen_cntl        = INREG(RADEON_CRTC_GEN_CNTL);
    save->crtc_ext_cntl        = INREG(RADEON_CRTC_EXT_CNTL);
    save->dac_cntl             = INREG(RADEON_DAC_CNTL);
    save->crtc_h_total_disp    = INREG(RADEON_CRTC_H_TOTAL_DISP);
    save->crtc_h_sync_strt_wid = INREG(RADEON_CRTC_H_SYNC_STRT_WID);
    save->crtc_v_total_disp    = INREG(RADEON_CRTC_V_TOTAL_DISP);
    save->crtc_v_sync_strt_wid = INREG(RADEON_CRTC_V_SYNC_STRT_WID);
    save->crtc_offset          = INREG(RADEON_CRTC_OFFSET);
    save->crtc_offset_cntl     = INREG(RADEON_CRTC_OFFSET_CNTL);
    save->crtc_pitch           = INREG(RADEON_CRTC_PITCH);
    save->disp_merge_cntl      = INREG(RADEON_DISP_MERGE_CNTL);
    save->crtc_more_cntl       = INREG(RADEON_CRTC_MORE_CNTL);
}

/* Read flat panel registers */
static void RADEONSaveFPRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    save->fp_crtc_h_total_disp = INREG(RADEON_FP_CRTC_H_TOTAL_DISP);
    save->fp_crtc_v_total_disp = INREG(RADEON_FP_CRTC_V_TOTAL_DISP);
    save->fp_gen_cntl          = INREG(RADEON_FP_GEN_CNTL);
    save->fp_h_sync_strt_wid   = INREG(RADEON_FP_H_SYNC_STRT_WID);
    save->fp_horz_stretch      = INREG(RADEON_FP_HORZ_STRETCH);
    save->fp_v_sync_strt_wid   = INREG(RADEON_FP_V_SYNC_STRT_WID);
    save->fp_vert_stretch      = INREG(RADEON_FP_VERT_STRETCH);
    save->lvds_gen_cntl        = INREG(RADEON_LVDS_GEN_CNTL);
    save->lvds_pll_cntl        = INREG(RADEON_LVDS_PLL_CNTL);
    save->tmds_pll_cntl        = INREG(RADEON_TMDS_PLL_CNTL);
    save->tmds_transmitter_cntl= INREG(RADEON_TMDS_TRANSMITTER_CNTL);
    save->bios_5_scratch       = INREG(RADEON_BIOS_5_SCRATCH);

    if (info->ChipFamily == CHIP_FAMILY_RV280) {
	/* bit 22 of TMDS_PLL_CNTL is read-back inverted */
	save->tmds_pll_cntl ^= (1 << 22);
    }
}

/* Read CRTC2 registers */
static void RADEONSaveCrtc2Registers(ScrnInfoPtr pScrn, RADEONSavePtr save)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    save->dac2_cntl             = INREG(RADEON_DAC_CNTL2);
    save->disp_output_cntl      = INREG(RADEON_DISP_OUTPUT_CNTL);
    save->disp_hw_debug         = INREG (RADEON_DISP_HW_DEBUG);

    save->crtc2_gen_cntl        = INREG(RADEON_CRTC2_GEN_CNTL);
    save->crtc2_h_total_disp    = INREG(RADEON_CRTC2_H_TOTAL_DISP);
    save->crtc2_h_sync_strt_wid = INREG(RADEON_CRTC2_H_SYNC_STRT_WID);
    save->crtc2_v_total_disp    = INREG(RADEON_CRTC2_V_TOTAL_DISP);
    save->crtc2_v_sync_strt_wid = INREG(RADEON_CRTC2_V_SYNC_STRT_WID);
    save->crtc2_offset          = INREG(RADEON_CRTC2_OFFSET);
    save->crtc2_offset_cntl     = INREG(RADEON_CRTC2_OFFSET_CNTL);
    save->crtc2_pitch           = INREG(RADEON_CRTC2_PITCH);

    save->fp2_h_sync_strt_wid   = INREG (RADEON_FP_H2_SYNC_STRT_WID);
    save->fp2_v_sync_strt_wid   = INREG (RADEON_FP_V2_SYNC_STRT_WID);
    save->fp2_gen_cntl          = INREG (RADEON_FP2_GEN_CNTL);
    save->disp2_merge_cntl      = INREG(RADEON_DISP2_MERGE_CNTL);
}

/* Read PLL registers */
static void RADEONSavePLLRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save)
{
    save->ppll_ref_div = INPLL(pScrn, RADEON_PPLL_REF_DIV);
    save->ppll_div_3   = INPLL(pScrn, RADEON_PPLL_DIV_3);
    save->htotal_cntl  = INPLL(pScrn, RADEON_HTOTAL_CNTL);

    RADEONTRACE(("Read: 0x%08x 0x%08x 0x%08x\n",
		 save->ppll_ref_div,
		 save->ppll_div_3,
		 save->htotal_cntl));
    RADEONTRACE(("Read: rd=%d, fd=%d, pd=%d\n",
		 save->ppll_ref_div & RADEON_PPLL_REF_DIV_MASK,
		 save->ppll_div_3 & RADEON_PPLL_FB3_DIV_MASK,
		 (save->ppll_div_3 & RADEON_PPLL_POST3_DIV_MASK) >> 16));
}

/* Read PLL registers */
static void RADEONSavePLL2Registers(ScrnInfoPtr pScrn, RADEONSavePtr save)
{
    save->p2pll_ref_div = INPLL(pScrn, RADEON_P2PLL_REF_DIV);
    save->p2pll_div_0   = INPLL(pScrn, RADEON_P2PLL_DIV_0);
    save->htotal_cntl2  = INPLL(pScrn, RADEON_HTOTAL2_CNTL);

    RADEONTRACE(("Read: 0x%08x 0x%08x 0x%08x\n",
		 save->p2pll_ref_div,
		 save->p2pll_div_0,
		 save->htotal_cntl2));
    RADEONTRACE(("Read: rd=%d, fd=%d, pd=%d\n",
		 save->p2pll_ref_div & RADEON_P2PLL_REF_DIV_MASK,
		 save->p2pll_div_0 & RADEON_P2PLL_FB0_DIV_MASK,
		 (save->p2pll_div_0 & RADEON_P2PLL_POST0_DIV_MASK) >> 16));
}

/* Read palette data */
static void RADEONSavePalette(ScrnInfoPtr pScrn, RADEONSavePtr save)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int            i;

#ifdef ENABLE_FLAT_PANEL
    /* Select palette 0 (main CRTC) if using FP-enabled chip */
 /* if (info->Port1 == MT_DFP) PAL_SELECT(1); */
#endif
    PAL_SELECT(1);
    INPAL_START(0);
    for (i = 0; i < 256; i++) save->palette2[i] = INPAL_NEXT();
    PAL_SELECT(0);
    INPAL_START(0);
    for (i = 0; i < 256; i++) save->palette[i] = INPAL_NEXT();
    save->palette_valid = TRUE;
}

/* Save state that defines current video mode */
static void RADEONSaveMode(ScrnInfoPtr pScrn, RADEONSavePtr save)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);

    RADEONTRACE(("RADEONSaveMode(%p)\n", save));
    RADEONSaveCommonRegisters(pScrn, save);
    if (info->IsSecondary) {
	RADEONSaveCrtc2Registers(pScrn, save);
	RADEONSavePLL2Registers(pScrn, save);
    } else {
	RADEONSavePLLRegisters(pScrn, save);
	RADEONSaveCrtcRegisters(pScrn, save);
	RADEONSaveFPRegisters(pScrn, save);

	if (info->Clone) {
	    RADEONSaveCrtc2Registers(pScrn, save);
	    RADEONSavePLL2Registers(pScrn, save);
	}
     /* RADEONSavePalette(pScrn, save); */
    }

    RADEONTRACE(("RADEONSaveMode returns %p\n", save));
}

/* Save everything needed to restore the original VC state */
static void RADEONSave(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    RADEONSavePtr  save       = &info->SavedReg;
    vgaHWPtr       hwp        = VGAHWPTR(pScrn);

    RADEONTRACE(("RADEONSave\n"));
    if (info->FBDev) {
	fbdevHWSave(pScrn);
	return;
    }

    if (!info->IsSecondary) {
	vgaHWUnlock(hwp);
#if defined(__powerpc__)
	/* temporary hack to prevent crashing on PowerMacs when trying to
	 * read VGA fonts and colormap, will find a better solution
	 * in the future
	 */
	vgaHWSave(pScrn, &hwp->SavedReg, VGA_SR_MODE); /* Save mode only */
#else
	vgaHWSave(pScrn, &hwp->SavedReg, VGA_SR_ALL); /* Save mode
						       * & fonts & cmap
						       */
#endif
	vgaHWLock(hwp);
	save->dp_datatype      = INREG(RADEON_DP_DATATYPE);
	save->rbbm_soft_reset  = INREG(RADEON_RBBM_SOFT_RESET);
	save->clock_cntl_index = INREG(RADEON_CLOCK_CNTL_INDEX);
	if (info->R300CGWorkaround) R300CGWorkaround(pScrn);
    }

    RADEONSaveMode(pScrn, save);
}

/* Restore the original (text) mode */
static void RADEONRestore(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    RADEONSavePtr  restore    = &info->SavedReg;
    vgaHWPtr       hwp        = VGAHWPTR(pScrn);

    RADEONTRACE(("RADEONRestore\n"));

#if X_BYTE_ORDER == X_BIG_ENDIAN
    RADEONWaitForFifo(pScrn, 1);
    OUTREG(RADEON_RBBM_GUICNTL, RADEON_HOST_DATA_SWAP_NONE);
#endif

    if (info->FBDev) {
	fbdevHWRestore(pScrn);
	return;
    }
    RADEONBlank(pScrn);

    OUTREG(RADEON_CLOCK_CNTL_INDEX, restore->clock_cntl_index);
    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);
    OUTREG(RADEON_RBBM_SOFT_RESET,  restore->rbbm_soft_reset);
    OUTREG(RADEON_DP_DATATYPE,      restore->dp_datatype);
    OUTREG(RADEON_GRPH_BUFFER_CNTL, restore->grph_buffer_cntl);
    OUTREG(RADEON_GRPH2_BUFFER_CNTL, restore->grph2_buffer_cntl);

#if 0
    /* M6 card has trouble restoring text mode for its CRT.
     * This is fixed elsewhere and will be removed in the future.
     */
    if ((xf86IsEntityShared(info->pEnt->index) || info->Clone)
	&& info->IsM6)
	OUTREG(RADEON_DAC_CNTL2, restore->dac2_cntl);
#endif

    RADEONRestoreMode(pScrn, restore);

#if 0
    /* Temp fix to "solve" VT switch problems.  When switching VTs on
     * some systems, the console can either hang or the fonts can be
     * corrupted.  This hack solves the problem 99% of the time.  A
     * correct fix is being worked on.
     */
    usleep(100000);
#endif

    if (!info->IsSecondary) {
	vgaHWUnlock(hwp);
#if defined(__powerpc__)
	/* Temporary hack to prevent crashing on PowerMacs when trying to
	 * write VGA fonts, will find a better solution in the future
	 */
	vgaHWRestore(pScrn, &hwp->SavedReg, VGA_SR_MODE );
#else
	vgaHWRestore(pScrn, &hwp->SavedReg, VGA_SR_ALL );
#endif
	vgaHWLock(hwp);
    } else {
        RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
	ScrnInfoPtr   pScrn0;
	vgaHWPtr      hwp0;

	pScrn0 = pRADEONEnt->pPrimaryScrn;
	hwp0   = VGAHWPTR(pScrn0);
	vgaHWUnlock(hwp0);
	vgaHWRestore(pScrn0, &hwp0->SavedReg, VGA_SR_MODE | VGA_SR_FONTS );
	vgaHWLock(hwp0);
    }
    RADEONUnblank(pScrn);

#if 0
    RADEONWaitForVerticalSync(pScrn);
#endif
}

/* Define common registers for requested video mode */
static void RADEONInitCommonRegisters(RADEONSavePtr save, RADEONInfoPtr info)
{
    save->ovr_clr            = 0;
    save->ovr_wid_left_right = 0;
    save->ovr_wid_top_bottom = 0;
    save->ov0_scale_cntl     = 0;
    save->subpic_cntl        = 0;
    save->viph_control       = 0;
    save->i2c_cntl_1         = 0;
    save->rbbm_soft_reset    = 0;
    save->cap0_trig_cntl     = 0;
    save->cap1_trig_cntl     = 0;
    save->bus_cntl           = info->BusCntl;
    /*
     * If bursts are enabled, turn on discards
     * Radeon doesn't have write bursts
     */
    if (save->bus_cntl & (RADEON_BUS_READ_BURST))
	save->bus_cntl |= RADEON_BUS_RD_DISCARD_EN;
}

/* Calculate display buffer watermark to prevent buffer underflow */
static void RADEONInitDispBandwidth(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    RADEONInfoPtr  info2 = NULL;

    DisplayModePtr mode1, mode2;

    CARD32 temp, data, mem_trcd, mem_trp, mem_tras, mem_trbs=0;
    float mem_tcas;
    int k1, c;
    CARD32 MemTrcdExtMemCntl[4]     = {1, 2, 3, 4};
    CARD32 MemTrpExtMemCntl[4]      = {1, 2, 3, 4};
    CARD32 MemTrasExtMemCntl[8]     = {1, 2, 3, 4, 5, 6, 7, 8};

    CARD32 MemTrcdMemTimingCntl[8]     = {1, 2, 3, 4, 5, 6, 7, 8};
    CARD32 MemTrpMemTimingCntl[8]      = {1, 2, 3, 4, 5, 6, 7, 8};
    CARD32 MemTrasMemTimingCntl[16]    = {4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19};

    float MemTcas[8]  = {0, 1, 2, 3, 0, 1.5, 2.5, 0};
    float MemTcas2[8] = {0, 1, 2, 3, 4, 5, 6, 7};
    float MemTrbs[8]  = {1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5};

    float mem_bw, peak_disp_bw;
    float min_mem_eff = 0.8;
    float sclk_eff, sclk_delay;
    float mc_latency_mclk, mc_latency_sclk, cur_latency_mclk, cur_latency_sclk;
    float disp_latency, disp_latency_overhead, disp_drain_rate, disp_drain_rate2;
    float pix_clk, pix_clk2; /* in MHz */
    int cur_size = 16;       /* in octawords */
    int critical_point, critical_point2;
    int stop_req, max_stop_req;
    float read_return_rate, time_disp1_drop_priority;

    if (pRADEONEnt->pSecondaryScrn) {
	if (info->IsSecondary) return;
	info2 = RADEONPTR(pRADEONEnt->pSecondaryScrn);
    }  else if (info->Clone) info2 = info;

    /*
     * Determine if there is enough bandwidth for current display mode
     */
    mem_bw = info->mclk * (info->RamWidth / 8) * (info->IsDDR ? 2 : 1);

    mode1 = info->CurrentLayout.mode;
    if (info->Clone)
	mode2 = info->CurCloneMode;
    else if ((pRADEONEnt->HasSecondary) && info2)
	mode2 = info2->CurrentLayout.mode;
    else
	mode2 = NULL;

    pix_clk = mode1->Clock/1000.0;
    if (mode2)
	pix_clk2 = mode2->Clock/1000.0;
    else
	pix_clk2 = 0;

    peak_disp_bw = (pix_clk * info->CurrentLayout.pixel_bytes);
    if (info2)
	peak_disp_bw +=	(pix_clk2 * info2->CurrentLayout.pixel_bytes);

    if (peak_disp_bw >= mem_bw * min_mem_eff) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "You may not have enough display bandwidth for current mode\n"
		   "If you have flickering problem, try to lower resolution, refresh rate, or color depth\n");
    }

    /*  CRTC1
        Set GRPH_BUFFER_CNTL register using h/w defined optimal values.
	GRPH_STOP_REQ <= MIN[ 0x7C, (CRTC_H_DISP + 1) * (bit depth) / 0x10 ]
    */
    stop_req = mode1->HDisplay * info->CurrentLayout.pixel_bytes / 16;

    /* setup Max GRPH_STOP_REQ default value */
    if ((info->ChipFamily == CHIP_FAMILY_RV100) ||
	(info->ChipFamily == CHIP_FAMILY_RV200) ||
	(info->ChipFamily == CHIP_FAMILY_RV250) ||
	(info->ChipFamily == CHIP_FAMILY_RV280) ||
	(info->ChipFamily == CHIP_FAMILY_RS100) ||
	(info->ChipFamily == CHIP_FAMILY_RS200) ||
	(info->ChipFamily == CHIP_FAMILY_RS300))
	max_stop_req = 0x5c;
    else
	max_stop_req  = 0x7c;
    if (stop_req > max_stop_req)
	stop_req = max_stop_req;

    /*  Get values from the EXT_MEM_CNTL register...converting its contents. */
    temp = INREG(RADEON_MEM_TIMING_CNTL);
    if ((info->ChipFamily == CHIP_FAMILY_RV100) || info->IsIGP) { /* RV100, M6, IGPs */
	mem_trcd      = MemTrcdExtMemCntl[(temp & 0x0c) >> 2];
	mem_trp       = MemTrpExtMemCntl[ (temp & 0x03) >> 0];
	mem_tras      = MemTrasExtMemCntl[(temp & 0x70) >> 4];
    } else { /* RV200 and later */
	mem_trcd      = MemTrcdMemTimingCntl[(temp & 0x07) >> 0];
	mem_trp       = MemTrpMemTimingCntl[ (temp & 0x700) >> 8];
	mem_tras      = MemTrasMemTimingCntl[(temp & 0xf000) >> 12];
    }

    /* Get values from the MEM_SDRAM_MODE_REG register...converting its */
    temp = INREG(RADEON_MEM_SDRAM_MODE_REG);
    data = (temp & (7<<20)) >> 20;
    if ((info->ChipFamily == CHIP_FAMILY_RV100) || info->IsIGP) { /* RV100, M6, IGPs */
	mem_tcas = MemTcas [data];
    } else {
	mem_tcas = MemTcas2 [data];
    }

    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {

	/* on the R300, Tcas is included in Trbs.
	*/
	temp = INREG(RADEON_MEM_CNTL);
	data = (R300_MEM_NUM_CHANNELS_MASK & temp);
	if (data == 2) {
	    if (R300_MEM_USE_CD_CH_ONLY & temp) {
		temp  = INREG(R300_MC_IND_INDEX);
		temp &= ~R300_MC_IND_ADDR_MASK;
		temp |= R300_MC_READ_CNTL_CD_mcind;
		OUTREG(R300_MC_IND_INDEX, temp);
		temp  = INREG(R300_MC_IND_DATA);
		data = (R300_MEM_RBS_POSITION_C_MASK & temp);
	    } else {
		temp = INREG(R300_MC_READ_CNTL_AB);
		data = (R300_MEM_RBS_POSITION_A_MASK & temp);
	    }
	} else {
	    temp = INREG(R300_MC_READ_CNTL_AB);
	    data = (R300_MEM_RBS_POSITION_A_MASK & temp);
	}

	mem_trbs = MemTrbs[data];
	mem_tcas += mem_trbs;
    }

    if ((info->ChipFamily == CHIP_FAMILY_RV100) || info->IsIGP) { /* RV100, M6, IGPs */
	/* DDR64 SCLK_EFF = SCLK for analysis */
	sclk_eff = info->sclk;
    } else {
#ifdef XF86DRI
	if (info->directRenderingEnabled)
	    sclk_eff = info->sclk - (info->agpMode * 50.0 / 3.0);
	else
#endif
	    sclk_eff = info->sclk;
    }

    /* Find the memory controller latency for the display client.
    */
    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {
	/*not enough for R350 ???*/
	/*
	if (!mode2) sclk_delay = 150;
	else {
	    if (info->RamWidth == 256) sclk_delay = 87;
	    else sclk_delay = 97;
	}
	*/
	sclk_delay = 250;
    } else {
	if ((info->ChipFamily == CHIP_FAMILY_RV100) ||
	    info->IsIGP) {
	    if (info->IsDDR) sclk_delay = 41;
	    else sclk_delay = 33;
	} else {
	    if (info->RamWidth == 128) sclk_delay = 57;
	    else sclk_delay = 41;
	}
    }

    mc_latency_sclk = sclk_delay / sclk_eff;

    if (info->IsDDR) {
	if (info->RamWidth == 32) {
	    k1 = 40;
	    c  = 3;
	} else {
	    k1 = 20;
	    c  = 1;
	}
    } else {
	k1 = 40;
	c  = 3;
    }
    mc_latency_mclk = ((2.0*mem_trcd + mem_tcas*c + 4.0*mem_tras + 4.0*mem_trp + k1) /
		       info->mclk) + (4.0 / sclk_eff);

    /*
      HW cursor time assuming worst case of full size colour cursor.
    */
    cur_latency_mclk = (mem_trp + MAX(mem_tras, (mem_trcd + 2*(cur_size - (info->IsDDR+1))))) / info->mclk;
    cur_latency_sclk = cur_size / sclk_eff;

    /*
      Find the total latency for the display data.
    */
    disp_latency_overhead = 8.0 / info->sclk;
    mc_latency_mclk = mc_latency_mclk + disp_latency_overhead + cur_latency_mclk;
    mc_latency_sclk = mc_latency_sclk + disp_latency_overhead + cur_latency_sclk;
    disp_latency = MAX(mc_latency_mclk, mc_latency_sclk);

    /*
      Find the drain rate of the display buffer.
    */
    disp_drain_rate = pix_clk / (16.0/info->CurrentLayout.pixel_bytes);
    if (info2)
	disp_drain_rate2 = pix_clk2 / (16.0/info2->CurrentLayout.pixel_bytes);
    else
	disp_drain_rate2 = 0;

    /*
      Find the critical point of the display buffer.
    */
    critical_point= (CARD32)(disp_drain_rate * disp_latency + 0.5);

    /* ???? */
    /*
    temp = (info->SavedReg.grph_buffer_cntl & RADEON_GRPH_CRITICAL_POINT_MASK) >> RADEON_GRPH_CRITICAL_POINT_SHIFT;
    if (critical_point < temp) critical_point = temp;
    */
    if (info->DispPriority == 2) {
	if (mode2) {
	    /*??some R300 cards have problem with this set to 0, when CRTC2 is enabled.*/
	    if (info->ChipFamily == CHIP_FAMILY_R300)
		critical_point += 0x10;
	    else
		critical_point = 0;
	}
	else
	    critical_point = 0;
    }

    /*
      The critical point should never be above max_stop_req-4.  Setting
      GRPH_CRITICAL_CNTL = 0 will thus force high priority all the time.
    */
    if (max_stop_req - critical_point < 4) critical_point = 0;

    temp = info->SavedReg.grph_buffer_cntl;
    temp &= ~(RADEON_GRPH_STOP_REQ_MASK);
    temp |= (stop_req << RADEON_GRPH_STOP_REQ_SHIFT);
    temp &= ~(RADEON_GRPH_START_REQ_MASK);
    if ((info->ChipFamily == CHIP_FAMILY_R350) &&
	(stop_req > 0x15)) {
	stop_req -= 0x10;
    }
    temp |= (stop_req << RADEON_GRPH_START_REQ_SHIFT);

    temp |= RADEON_GRPH_BUFFER_SIZE;
    temp &= ~(RADEON_GRPH_CRITICAL_CNTL   |
	      RADEON_GRPH_CRITICAL_AT_SOF |
	      RADEON_GRPH_STOP_CNTL);
    /*
      Write the result into the register.
    */
    OUTREG(RADEON_GRPH_BUFFER_CNTL, ((temp & ~RADEON_GRPH_CRITICAL_POINT_MASK) |
				     (critical_point << RADEON_GRPH_CRITICAL_POINT_SHIFT)));

    RADEONTRACE(("GRPH_BUFFER_CNTL from %x to %x\n",
	       info->SavedReg.grph_buffer_cntl, INREG(RADEON_GRPH_BUFFER_CNTL)));

    if (mode2) {
	stop_req = mode2->HDisplay * info2->CurrentLayout.pixel_bytes / 16;

	if (stop_req > max_stop_req) stop_req = max_stop_req;

	temp = info->SavedReg.grph2_buffer_cntl;
	temp &= ~(RADEON_GRPH_STOP_REQ_MASK);
	temp |= (stop_req << RADEON_GRPH_STOP_REQ_SHIFT);
	temp &= ~(RADEON_GRPH_START_REQ_MASK);
	if ((info->ChipFamily == CHIP_FAMILY_R350) &&
	    (stop_req > 0x15)) {
	    stop_req -= 0x10;
	}
	temp |= (stop_req << RADEON_GRPH_START_REQ_SHIFT);
	temp |= RADEON_GRPH_BUFFER_SIZE;
	temp &= ~(RADEON_GRPH_CRITICAL_CNTL   |
		  RADEON_GRPH_CRITICAL_AT_SOF |
		  RADEON_GRPH_STOP_CNTL);

	if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
	    (info->ChipFamily == CHIP_FAMILY_RS200))
	    critical_point2 = 0;
	else {
	    read_return_rate = MIN(info->sclk, info->mclk*(info->RamWidth*(info->IsDDR+1)/128));
	    time_disp1_drop_priority = critical_point / (read_return_rate - disp_drain_rate);

	    critical_point2 = (CARD32)((disp_latency + time_disp1_drop_priority +
					disp_latency) * disp_drain_rate2 + 0.5);

	    if (info->DispPriority == 2) {
		if (info->ChipFamily == CHIP_FAMILY_R300)
		    critical_point2 += 0x10;
		else
		    critical_point2 = 0;
	    }

	    if (max_stop_req - critical_point2 < 4) critical_point2 = 0;

	}

	OUTREG(RADEON_GRPH2_BUFFER_CNTL, ((temp & ~RADEON_GRPH_CRITICAL_POINT_MASK) |
					  (critical_point2 << RADEON_GRPH_CRITICAL_POINT_SHIFT)));

	RADEONTRACE(("GRPH2_BUFFER_CNTL from %x to %x\n",
		     info->SavedReg.grph2_buffer_cntl, INREG(RADEON_GRPH2_BUFFER_CNTL)));
    }
}

/* Define CRTC registers for requested video mode */
static Bool RADEONInitCrtcRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save,
				  DisplayModePtr mode, RADEONInfoPtr info)
{
    unsigned char *RADEONMMIO = info->MMIO;

    int  format;
    int  hsync_start;
    int  hsync_wid;
    int  hsync_fudge;
    int  vsync_wid;
    int  hsync_fudge_default[] = { 0x00, 0x12, 0x09, 0x09, 0x06, 0x05 };
    int  hsync_fudge_fp[]      = { 0x02, 0x02, 0x00, 0x00, 0x05, 0x05 };

    switch (info->CurrentLayout.pixel_code) {
    case 4:  format = 1; break;
    case 8:  format = 2; break;
    case 15: format = 3; break;      /*  555 */
    case 16: format = 4; break;      /*  565 */
    case 24: format = 5; break;      /*  RGB */
    case 32: format = 6; break;      /* xRGB */
    default:
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Unsupported pixel depth (%d)\n",
		   info->CurrentLayout.bitsPerPixel);
	return FALSE;
    }

    if ((info->DisplayType == MT_DFP) ||
	(info->DisplayType == MT_LCD)) {
	hsync_fudge = hsync_fudge_fp[format-1];
	if (mode->Flags & RADEON_USE_RMX) {
#if 0
	    mode->CrtcHDisplay   = info->PanelXRes;
	    mode->CrtcVDisplay   = info->PanelYRes;
#endif
	    mode->CrtcHTotal     = mode->CrtcHDisplay + info->HBlank;
	    mode->CrtcHSyncStart = mode->CrtcHDisplay + info->HOverPlus;
	    mode->CrtcHSyncEnd   = mode->CrtcHSyncStart + info->HSyncWidth;
	    mode->CrtcVTotal     = mode->CrtcVDisplay + info->VBlank;
	    mode->CrtcVSyncStart = mode->CrtcVDisplay + info->VOverPlus;
	    mode->CrtcVSyncEnd   = mode->CrtcVSyncStart + info->VSyncWidth;
	    mode->Clock          = info->DotClock;
	    mode->Flags          = info->Flags | RADEON_USE_RMX;
	}
    } else {
	hsync_fudge = hsync_fudge_default[format-1];
    }

    save->crtc_gen_cntl = (RADEON_CRTC_EXT_DISP_EN
			   | RADEON_CRTC_EN
			   | (format << 8)
			   | ((mode->Flags & V_DBLSCAN)
			      ? RADEON_CRTC_DBL_SCAN_EN
			      : 0)
			   | ((mode->Flags & V_CSYNC)
			      ? RADEON_CRTC_CSYNC_EN
			      : 0)
			   | ((mode->Flags & V_INTERLACE)
			      ? RADEON_CRTC_INTERLACE_EN
			      : 0));

    if ((info->DisplayType == MT_DFP) ||
	(info->DisplayType == MT_LCD)) {
	save->crtc_ext_cntl = RADEON_VGA_ATI_LINEAR | RADEON_XCRT_CNT_EN;
	save->crtc_gen_cntl &= ~(RADEON_CRTC_DBL_SCAN_EN |
				 RADEON_CRTC_CSYNC_EN |
				 RADEON_CRTC_INTERLACE_EN);
    } else {
	save->crtc_ext_cntl = (RADEON_VGA_ATI_LINEAR |
			       RADEON_XCRT_CNT_EN |
			       RADEON_CRTC_CRT_ON);
    }

    save->dac_cntl = (RADEON_DAC_MASK_ALL
		      | RADEON_DAC_VGA_ADR_EN
		      | (info->dac6bits ? 0 : RADEON_DAC_8BIT_EN));

    save->crtc_h_total_disp = ((((mode->CrtcHTotal / 8) - 1) & 0x3ff)
			       | ((((mode->CrtcHDisplay / 8) - 1) & 0x1ff)
				  << 16));

    hsync_wid = (mode->CrtcHSyncEnd - mode->CrtcHSyncStart) / 8;
    if (!hsync_wid) hsync_wid = 1;
    hsync_start = mode->CrtcHSyncStart - 8 + hsync_fudge;

    save->crtc_h_sync_strt_wid = ((hsync_start & 0x1fff)
				  | ((hsync_wid & 0x3f) << 16)
				  | ((mode->Flags & V_NHSYNC)
				     ? RADEON_CRTC_H_SYNC_POL
				     : 0));

#if 1
				/* This works for double scan mode. */
    save->crtc_v_total_disp = (((mode->CrtcVTotal - 1) & 0xffff)
			       | ((mode->CrtcVDisplay - 1) << 16));
#else
				/* This is what cce/nbmode.c example code
				 * does -- is this correct?
				 */
    save->crtc_v_total_disp = (((mode->CrtcVTotal - 1) & 0xffff)
			       | ((mode->CrtcVDisplay
				   * ((mode->Flags & V_DBLSCAN) ? 2 : 1) - 1)
				  << 16));
#endif

    vsync_wid = mode->CrtcVSyncEnd - mode->CrtcVSyncStart;
    if (!vsync_wid) vsync_wid = 1;

    save->crtc_v_sync_strt_wid = (((mode->CrtcVSyncStart - 1) & 0xfff)
				  | ((vsync_wid & 0x1f) << 16)
				  | ((mode->Flags & V_NVSYNC)
				     ? RADEON_CRTC_V_SYNC_POL
				     : 0));

    save->crtc_offset      = 0;
    save->crtc_offset_cntl = INREG(RADEON_CRTC_OFFSET_CNTL);

    save->crtc_pitch  = (((pScrn->displayWidth * pScrn->bitsPerPixel) +
			  ((pScrn->bitsPerPixel * 8) -1)) /
			 (pScrn->bitsPerPixel * 8));
    save->crtc_pitch |= save->crtc_pitch << 16;

    /* Some versions of BIOS setup CRTC_MORE_CNTL for a DFP, if we
       have a CRT here, it should be cleared to avoild a blank screen.
    */
    if (info->DisplayType == MT_CRT)
	save->crtc_more_cntl = (info->SavedReg.crtc_more_cntl &
				~(RADEON_CRTC_H_CUTOFF_ACTIVE_EN |
				  RADEON_CRTC_V_CUTOFF_ACTIVE_EN));
    else
	save->crtc_more_cntl = info->SavedReg.crtc_more_cntl;

    save->surface_cntl = 0;
    save->disp_merge_cntl = info->SavedReg.disp_merge_cntl;
    save->disp_merge_cntl &= ~RADEON_DISP_RGB_OFFSET_EN;

#if X_BYTE_ORDER == X_BIG_ENDIAN
    /* Alhought we current onlu use aperture 0, also setting aperture 1 should not harm -ReneR */
    switch (pScrn->bitsPerPixel) {
    case 16:
	save->surface_cntl |= RADEON_NONSURF_AP0_SWP_16BPP;
	save->surface_cntl |= RADEON_NONSURF_AP1_SWP_16BPP;
	break;

    case 32:
	save->surface_cntl |= RADEON_NONSURF_AP0_SWP_32BPP;
	save->surface_cntl |= RADEON_NONSURF_AP1_SWP_32BPP;
	break;
    }
#endif

    RADEONTRACE(("Pitch = %d bytes (virtualX = %d, displayWidth = %d)\n",
		 save->crtc_pitch, pScrn->virtualX,
		 info->CurrentLayout.displayWidth));
    return TRUE;
}

/* Define CRTC2 registers for requested video mode */
static Bool RADEONInitCrtc2Registers(ScrnInfoPtr pScrn, RADEONSavePtr save,
				     DisplayModePtr mode, RADEONInfoPtr info)
{
    unsigned char *RADEONMMIO = info->MMIO;
    RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);

    int  format;
    int  hsync_start;
    int  hsync_wid;
    int  hsync_fudge;
    int  vsync_wid;
    int  hsync_fudge_default[] = { 0x00, 0x12, 0x09, 0x09, 0x06, 0x05 };

    switch (info->CurrentLayout.pixel_code) {
    case 4:  format = 1; break;
    case 8:  format = 2; break;
    case 15: format = 3; break;      /*  555 */
    case 16: format = 4; break;      /*  565 */
    case 24: format = 5; break;      /*  RGB */
    case 32: format = 6; break;      /* xRGB */
    default:
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Unsupported pixel depth (%d)\n",
		   info->CurrentLayout.bitsPerPixel);
	return FALSE;
    }

    hsync_fudge = hsync_fudge_default[format-1];

    save->crtc2_gen_cntl = (RADEON_CRTC2_EN
			    | RADEON_CRTC2_CRT2_ON
			    | (format << 8)
			    | ((mode->Flags & V_DBLSCAN)
			       ? RADEON_CRTC2_DBL_SCAN_EN
			       : 0)
			    | ((mode->Flags & V_CSYNC)
			       ? RADEON_CRTC2_CSYNC_EN
			       : 0)
			    | ((mode->Flags & V_INTERLACE)
			       ? RADEON_CRTC2_INTERLACE_EN
			       : 0));

    /* Turn CRT on in case the first head is a DFP */
    save->crtc_ext_cntl |= RADEON_CRTC_CRT_ON;
    save->dac2_cntl = info->SavedReg.dac2_cntl;
    /* always let TVDAC drive CRT2, we don't support tvout yet */
    save->dac2_cntl |= RADEON_DAC2_DAC2_CLK_SEL;
    save->disp_output_cntl = info->SavedReg.disp_output_cntl;
    if (info->ChipFamily == CHIP_FAMILY_R200 ||
	info->ChipFamily == CHIP_FAMILY_R300 ||
	info->ChipFamily == CHIP_FAMILY_R350 ||
	info->ChipFamily == CHIP_FAMILY_RV350) {
	save->disp_output_cntl &= ~(RADEON_DISP_DAC_SOURCE_MASK |
				    RADEON_DISP_DAC2_SOURCE_MASK);
	if (pRADEONEnt->MonType1 != MT_CRT) {
	    save->disp_output_cntl |= (RADEON_DISP_DAC_SOURCE_CRTC2 |
				       RADEON_DISP_DAC2_SOURCE_CRTC2);
	} else {
	    if (pRADEONEnt->ReversedDAC) {
		save->disp_output_cntl |= RADEON_DISP_DAC2_SOURCE_CRTC2;
	    } else {
		save->disp_output_cntl |= RADEON_DISP_DAC_SOURCE_CRTC2;
	    }
	}
    } else {
	save->disp_hw_debug = info->SavedReg.disp_hw_debug;
	/* Turn on 2nd CRT */
	if (pRADEONEnt->MonType1 != MT_CRT) {
	    /* This is for some sample boards with the VGA port
	       connected to the TVDAC, but BIOS doesn't reflect this.
	       Here we configure both DACs to use CRTC2.
	       Not sure if this happens in any retail board.
	    */
	    save->disp_hw_debug &= ~RADEON_CRT2_DISP1_SEL;
	    save->dac2_cntl |= RADEON_DAC2_DAC_CLK_SEL;
	} else {
	    if (pRADEONEnt->ReversedDAC) {
		save->disp_hw_debug &= ~RADEON_CRT2_DISP1_SEL;
		save->dac2_cntl &= ~RADEON_DAC2_DAC_CLK_SEL;
	    } else {
		save->disp_hw_debug |= RADEON_CRT2_DISP1_SEL;
		save->dac2_cntl |= RADEON_DAC2_DAC_CLK_SEL;
	    }
	}
    }

    save->crtc2_h_total_disp =
	((((mode->CrtcHTotal / 8) - 1) & 0x3ff)
	 | ((((mode->CrtcHDisplay / 8) - 1) & 0x1ff) << 16));

    hsync_wid = (mode->CrtcHSyncEnd - mode->CrtcHSyncStart) / 8;
    if (!hsync_wid) hsync_wid = 1;
    hsync_start = mode->CrtcHSyncStart - 8 + hsync_fudge;

    save->crtc2_h_sync_strt_wid = ((hsync_start & 0x1fff)
				   | ((hsync_wid & 0x3f) << 16)
				   | ((mode->Flags & V_NHSYNC)
				      ? RADEON_CRTC_H_SYNC_POL
				      : 0));

#if 1
				/* This works for double scan mode. */
    save->crtc2_v_total_disp = (((mode->CrtcVTotal - 1) & 0xffff)
				| ((mode->CrtcVDisplay - 1) << 16));
#else
				/* This is what cce/nbmode.c example code
				 * does -- is this correct?
				 */
    save->crtc2_v_total_disp = (((mode->CrtcVTotal - 1) & 0xffff)
				| ((mode->CrtcVDisplay
				    * ((mode->Flags & V_DBLSCAN) ? 2 : 1) - 1)
				   << 16));
#endif

    vsync_wid = mode->CrtcVSyncEnd - mode->CrtcVSyncStart;
    if (!vsync_wid) vsync_wid = 1;

    save->crtc2_v_sync_strt_wid = (((mode->CrtcVSyncStart - 1) & 0xfff)
				   | ((vsync_wid & 0x1f) << 16)
				   | ((mode->Flags & V_NVSYNC)
				      ? RADEON_CRTC2_V_SYNC_POL
				      : 0));

    save->crtc2_offset      = 0;
    save->crtc2_offset_cntl = INREG(RADEON_CRTC2_OFFSET_CNTL);

    save->crtc2_pitch  = (((pScrn->displayWidth * pScrn->bitsPerPixel) +
			   ((pScrn->bitsPerPixel * 8) -1)) /
			  (pScrn->bitsPerPixel * 8));
    save->crtc2_pitch |= save->crtc2_pitch << 16;
    save->disp2_merge_cntl = info->SavedReg.disp2_merge_cntl;
    save->disp2_merge_cntl &= ~(RADEON_DISP2_RGB_OFFSET_EN);

    if ((info->DisplayType == MT_DFP && info->IsSecondary) ||
	info->CloneType == MT_DFP) {
	save->crtc2_gen_cntl      = (RADEON_CRTC2_EN | (format << 8));
	save->fp2_h_sync_strt_wid = save->crtc2_h_sync_strt_wid;
	save->fp2_v_sync_strt_wid = save->crtc2_v_sync_strt_wid;
	save->fp2_gen_cntl        = (RADEON_FP2_PANEL_FORMAT |
				     RADEON_FP2_ON);
	if (info->ChipFamily >= CHIP_FAMILY_R200) {
	    save->fp2_gen_cntl |= RADEON_FP2_DV0_EN;
	}

	if (info->ChipFamily == CHIP_FAMILY_R200 ||
	    info->ChipFamily == CHIP_FAMILY_R300 ||
	    info->ChipFamily == CHIP_FAMILY_R350 ||
	    info->ChipFamily == CHIP_FAMILY_RV350) {
	    save->fp2_gen_cntl &= ~RADEON_FP2_SOURCE_SEL_MASK;
	    save->fp2_gen_cntl |= RADEON_FP2_SOURCE_SEL_CRTC2;
	} else {
	    save->fp2_gen_cntl &= ~RADEON_FP2_SRC_SEL_MASK;
	    save->fp2_gen_cntl |= RADEON_FP2_SRC_SEL_CRTC2;
	}

	if (pScrn->rgbBits == 8)
	    save->fp2_gen_cntl |= RADEON_FP2_PANEL_FORMAT; /* 24 bit format */
	else
	    save->fp2_gen_cntl &= ~RADEON_FP2_PANEL_FORMAT;/* 18 bit format */

	/* FIXME: When there are two DFPs, the 2nd DFP is driven by the
	 *        external TMDS transmitter.  It may have a problem at
	 *        high dot clock for certain panels.
	 */

	/* If BIOS has not turned it on, we'll keep it on so that we'll
	 * have a valid VGA screen even after X quits or VT is switched
	 * to the console mode.
	 */
	info->SavedReg.fp2_gen_cntl = RADEON_FP2_ON;
    }

    RADEONTRACE(("Pitch = %d bytes (virtualX = %d, displayWidth = %d)\n",
		 save->crtc2_pitch, pScrn->virtualX,
		 info->CurrentLayout.displayWidth));

    return TRUE;
}

/* Define CRTC registers for requested video mode */
static void RADEONInitFPRegisters(ScrnInfoPtr pScrn, RADEONSavePtr orig,
				  RADEONSavePtr save, DisplayModePtr mode,
				  RADEONInfoPtr info)
{
    int    xres = mode->HDisplay;
    int    yres = mode->VDisplay;
    float  Hratio, Vratio;

    /* If the FP registers have been initialized before for a panel,
     * but the primary port is a CRT, we need to reinitialize
     * FP registers in order for CRT to work properly
     */

    if ((info->DisplayType != MT_DFP) && (info->DisplayType != MT_LCD)) {
        save->fp_crtc_h_total_disp = orig->fp_crtc_h_total_disp;
        save->fp_crtc_v_total_disp = orig->fp_crtc_v_total_disp;
        save->fp_gen_cntl          = 0;
        save->fp_h_sync_strt_wid   = orig->fp_h_sync_strt_wid;
        save->fp_horz_stretch      = 0;
        save->fp_v_sync_strt_wid   = orig->fp_v_sync_strt_wid;
        save->fp_vert_stretch      = 0;
        save->lvds_gen_cntl        = orig->lvds_gen_cntl;
        save->lvds_pll_cntl        = orig->lvds_pll_cntl;
        save->tmds_pll_cntl        = orig->tmds_pll_cntl;
        save->tmds_transmitter_cntl= orig->tmds_transmitter_cntl;

        save->lvds_gen_cntl |= ( RADEON_LVDS_DISPLAY_DIS | (1 << 23));
        save->lvds_gen_cntl &= ~(RADEON_LVDS_BLON | RADEON_LVDS_ON);
        save->fp_gen_cntl &= ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN);

        return;
    }

    if (info->PanelXRes == 0 || info->PanelYRes == 0) {
	Hratio = 1.0;
	Vratio = 1.0;
    } else {
	if (xres > info->PanelXRes) xres = info->PanelXRes;
	if (yres > info->PanelYRes) yres = info->PanelYRes;

	Hratio = (float)xres/(float)info->PanelXRes;
	Vratio = (float)yres/(float)info->PanelYRes;
    }

    if (Hratio == 1.0 || !(mode->Flags & RADEON_USE_RMX)) {
	save->fp_horz_stretch = orig->fp_horz_stretch;
	save->fp_horz_stretch &= ~(RADEON_HORZ_STRETCH_BLEND |
				   RADEON_HORZ_STRETCH_ENABLE);
	save->fp_horz_stretch &= ~(RADEON_HORZ_AUTO_RATIO |
				   RADEON_HORZ_PANEL_SIZE);
	save->fp_horz_stretch |= ((xres/8-1)<<16);

    } else {
	save->fp_horz_stretch =
	    ((((unsigned long)(Hratio * RADEON_HORZ_STRETCH_RATIO_MAX +
			       0.5)) & RADEON_HORZ_STRETCH_RATIO_MASK)) |
	    (orig->fp_horz_stretch & (RADEON_HORZ_PANEL_SIZE |
				      RADEON_HORZ_FP_LOOP_STRETCH |
				      RADEON_HORZ_AUTO_RATIO_INC));
	save->fp_horz_stretch |= (RADEON_HORZ_STRETCH_BLEND |
				  RADEON_HORZ_STRETCH_ENABLE);

	save->fp_horz_stretch &= ~(RADEON_HORZ_AUTO_RATIO |
				   RADEON_HORZ_PANEL_SIZE);
	save->fp_horz_stretch |= ((info->PanelXRes / 8 - 1) << 16);

    }

    if (Vratio == 1.0 || !(mode->Flags & RADEON_USE_RMX)) {
	save->fp_vert_stretch = orig->fp_vert_stretch;
	save->fp_vert_stretch &= ~(RADEON_VERT_STRETCH_ENABLE|
				   RADEON_VERT_STRETCH_BLEND);
	save->fp_vert_stretch &= ~(RADEON_VERT_AUTO_RATIO_EN |
				   RADEON_VERT_PANEL_SIZE);
	save->fp_vert_stretch |= ((yres-1) << 12);
    } else {
	save->fp_vert_stretch =
	    (((((unsigned long)(Vratio * RADEON_VERT_STRETCH_RATIO_MAX +
				0.5)) & RADEON_VERT_STRETCH_RATIO_MASK)) |
	     (orig->fp_vert_stretch & (RADEON_VERT_PANEL_SIZE |
				       RADEON_VERT_STRETCH_RESERVED)));
	save->fp_vert_stretch |= (RADEON_VERT_STRETCH_ENABLE |
				  RADEON_VERT_STRETCH_BLEND);

	save->fp_vert_stretch &= ~(RADEON_VERT_AUTO_RATIO_EN |
				   RADEON_VERT_PANEL_SIZE);
	save->fp_vert_stretch |= ((info->PanelYRes-1) << 12);

    }

    save->fp_gen_cntl = (orig->fp_gen_cntl & (CARD32)
			 ~(RADEON_FP_SEL_CRTC2 |
			   RADEON_FP_RMX_HVSYNC_CONTROL_EN |
			   RADEON_FP_DFP_SYNC_SEL |
			   RADEON_FP_CRT_SYNC_SEL |
			   RADEON_FP_CRTC_LOCK_8DOT |
			   RADEON_FP_USE_SHADOW_EN |
			   RADEON_FP_CRTC_USE_SHADOW_VEND |
			   RADEON_FP_CRT_SYNC_ALT));
    save->fp_gen_cntl |= (RADEON_FP_CRTC_DONT_SHADOW_VPAR |
			  RADEON_FP_CRTC_DONT_SHADOW_HEND );

    if (pScrn->rgbBits == 8)
        save->fp_gen_cntl |= RADEON_FP_PANEL_FORMAT;  /* 24 bit format */
    else
        save->fp_gen_cntl &= ~RADEON_FP_PANEL_FORMAT;/* 18 bit format */

    save->lvds_gen_cntl = orig->lvds_gen_cntl;
    save->lvds_pll_cntl = orig->lvds_pll_cntl;

    info->PanelOff = FALSE;
    /* This option is used to force the ONLY DEVICE in XFConfig to use
     * CRT port, instead of default DVI port.
     */
    if (xf86ReturnOptValBool(info->Options, OPTION_PANEL_OFF, FALSE)) {
	info->PanelOff = TRUE;
    }

    save->tmds_pll_cntl = orig->tmds_pll_cntl;
    save->tmds_transmitter_cntl= orig->tmds_transmitter_cntl;
    if (info->PanelOff && info->Clone) {
	info->OverlayOnCRTC2 = TRUE;
	if (info->DisplayType == MT_LCD) {
	    /* Turning off LVDS_ON seems to make panel white blooming.
	     * For now we just turn off display data ???
	     */
	    save->lvds_gen_cntl |= (RADEON_LVDS_DISPLAY_DIS);
	    save->lvds_gen_cntl &= ~(RADEON_LVDS_BLON | RADEON_LVDS_ON);

	} else if (info->DisplayType == MT_DFP)
	    save->fp_gen_cntl &= ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN);
    } else {
	if (info->DisplayType == MT_LCD) {
	    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);

	    /* BIOS will use this setting to reset displays upon lid close/open.
	     * Here we let BIOS controls LCD, but the driver will control the external CRT.
	     */
	    if (info->Clone || pRADEONEnt->HasSecondary)
		save->bios_5_scratch = 0x01020201;
	    else
		save->bios_5_scratch = orig->bios_5_scratch;

	    save->lvds_gen_cntl |= (RADEON_LVDS_ON | RADEON_LVDS_BLON);
	    save->fp_gen_cntl   &= ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN);

	} else if (info->DisplayType == MT_DFP) {
	    int i;
	    CARD32 tmp = orig->tmds_pll_cntl & 0xfffff;
	    for (i=0; i<4; i++) {
		if (info->tmds_pll[i].freq == 0) break;
		if (save->dot_clock_freq < info->tmds_pll[i].freq) {
		    tmp = info->tmds_pll[i].value ;
		    break;
		}
	    }
	    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		(info->ChipFamily == CHIP_FAMILY_R350) ||
		(info->ChipFamily == CHIP_FAMILY_RV350) ||
		(info->ChipFamily == CHIP_FAMILY_RV280)) {
		if (tmp & 0xfff00000)
		    save->tmds_pll_cntl = tmp;
		else
		    save->tmds_pll_cntl = (orig->tmds_pll_cntl & 0xfff00000) | tmp;
	    } else save->tmds_pll_cntl = tmp;

	    RADEONTRACE(("TMDS_PLL from %x to %x\n",
			 orig->tmds_pll_cntl,
			 save->tmds_pll_cntl));

            save->tmds_transmitter_cntl &= ~(RADEON_TMDS_TRANSMITTER_PLLRST);
            if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		(info->ChipFamily == CHIP_FAMILY_R350) ||
		(info->ChipFamily == CHIP_FAMILY_RV350) ||
		(info->ChipFamily == CHIP_FAMILY_R200) || !info->HasCRTC2)
		save->tmds_transmitter_cntl &= ~(RADEON_TMDS_TRANSMITTER_PLLEN);
            else /* weird, RV chips got this bit reversed? */
                save->tmds_transmitter_cntl |= (RADEON_TMDS_TRANSMITTER_PLLEN);

	    save->fp_gen_cntl   |= (RADEON_FP_FPON | RADEON_FP_TMDS_EN);
        }
    }

    save->fp_crtc_h_total_disp = save->crtc_h_total_disp;
    save->fp_crtc_v_total_disp = save->crtc_v_total_disp;
    save->fp_h_sync_strt_wid   = save->crtc_h_sync_strt_wid;
    save->fp_v_sync_strt_wid   = save->crtc_v_sync_strt_wid;
}

/* Define PLL registers for requested video mode */
static void RADEONInitPLLRegisters(RADEONSavePtr save, RADEONInfoPtr info,
				   double dot_clock)
{
    unsigned long  freq = dot_clock * 100;
    RADEONPLLPtr pll = &info->pll;

    struct {
	int divider;
	int bitvalue;
    } *post_div, post_divs[]   = {
				/* From RAGE 128 VR/RAGE 128 GL Register
				 * Reference Manual (Technical Reference
				 * Manual P/N RRG-G04100-C Rev. 0.04), page
				 * 3-17 (PLL_DIV_[3:0]).
				 */
	{  1, 0 },              /* VCLK_SRC                 */
	{  2, 1 },              /* VCLK_SRC/2               */
	{  4, 2 },              /* VCLK_SRC/4               */
	{  8, 3 },              /* VCLK_SRC/8               */
	{  3, 4 },              /* VCLK_SRC/3               */
	{ 16, 5 },              /* VCLK_SRC/16              */
	{  6, 6 },              /* VCLK_SRC/6               */
	{ 12, 7 },              /* VCLK_SRC/12              */
	{  0, 0 }
    };

    if (freq > pll->max_pll_freq)      freq = pll->max_pll_freq;
    if (freq * 12 < pll->min_pll_freq) freq = pll->min_pll_freq / 12;

    for (post_div = &post_divs[0]; post_div->divider; ++post_div) {
	save->pll_output_freq = post_div->divider * freq;

	if (save->pll_output_freq >= pll->min_pll_freq
	    && save->pll_output_freq <= pll->max_pll_freq) break;
    }

    if (!post_div->divider) {
	save->pll_output_freq = freq;
	post_div = &post_divs[0];
    }

    save->dot_clock_freq = freq;
    save->feedback_div   = RADEONDiv(pll->reference_div
				     * save->pll_output_freq,
				     pll->reference_freq);
    save->post_div       = post_div->divider;

    RADEONTRACE(("dc=%d, of=%d, fd=%d, pd=%d\n",
	       save->dot_clock_freq,
	       save->pll_output_freq,
	       save->feedback_div,
	       save->post_div));

    save->ppll_ref_div   = pll->reference_div;

    /* 
     * on iBooks the LCD pannel needs tweaked PLL timings 
     */
#ifdef __powerpc__
    if (xf86ReturnOptValBool(info->Options, OPTION_IBOOKHACKS, FALSE))
        save->ppll_div_3 = 0x000600ad;
    else
#endif
        save->ppll_div_3 = (save->feedback_div | (post_div->bitvalue << 16));

    save->htotal_cntl    = 0;
}

/* Define PLL2 registers for requested video mode */
static void RADEONInitPLL2Registers(RADEONSavePtr save, RADEONPLLPtr pll,
				    double dot_clock)
{
    unsigned long  freq = dot_clock * 100;

    struct {
	int divider;
	int bitvalue;
    } *post_div, post_divs[]   = {
				/* From RAGE 128 VR/RAGE 128 GL Register
				 * Reference Manual (Technical Reference
				 * Manual P/N RRG-G04100-C Rev. 0.04), page
				 * 3-17 (PLL_DIV_[3:0]).
				 */
	{  1, 0 },              /* VCLK_SRC                 */
	{  2, 1 },              /* VCLK_SRC/2               */
	{  4, 2 },              /* VCLK_SRC/4               */
	{  8, 3 },              /* VCLK_SRC/8               */
	{  3, 4 },              /* VCLK_SRC/3               */
	{  6, 6 },              /* VCLK_SRC/6               */
	{ 12, 7 },              /* VCLK_SRC/12              */
	{  0, 0 }
    };

    if (freq > pll->max_pll_freq)      freq = pll->max_pll_freq;
    if (freq * 12 < pll->min_pll_freq) freq = pll->min_pll_freq / 12;

    for (post_div = &post_divs[0]; post_div->divider; ++post_div) {
	save->pll_output_freq_2 = post_div->divider * freq;
	if (save->pll_output_freq_2 >= pll->min_pll_freq
	    && save->pll_output_freq_2 <= pll->max_pll_freq) break;
    }

    if (!post_div->divider) {
	save->pll_output_freq_2 = freq;
	post_div = &post_divs[0];
    }

    save->dot_clock_freq_2 = freq;
    save->feedback_div_2   = RADEONDiv(pll->reference_div
				       * save->pll_output_freq_2,
				       pll->reference_freq);
    save->post_div_2       = post_div->divider;

    RADEONTRACE(("dc=%d, of=%d, fd=%d, pd=%d\n",
	       save->dot_clock_freq_2,
	       save->pll_output_freq_2,
	       save->feedback_div_2,
	       save->post_div_2));

    save->p2pll_ref_div    = pll->reference_div;
    save->p2pll_div_0      = (save->feedback_div_2 |
			      (post_div->bitvalue << 16));
    save->htotal_cntl2     = 0;
}

#if 0
/* Define initial palette for requested video mode.  This doesn't do
 * anything for XFree86 4.0.
 */
static void RADEONInitPalette(RADEONSavePtr save)
{
    save->palette_valid = FALSE;
}
#endif

/* Define registers for a requested video mode */
static Bool RADEONInit(ScrnInfoPtr pScrn, DisplayModePtr mode,
		       RADEONSavePtr save)
{
    RADEONInfoPtr  info      = RADEONPTR(pScrn);
    double         dot_clock = mode->Clock/1000.0;

#if RADEON_DEBUG
    ErrorF("%-12.12s %7.2f  %4d %4d %4d %4d  %4d %4d %4d %4d (%d,%d)",
	   mode->name,
	   dot_clock,

	   mode->HDisplay,
	   mode->HSyncStart,
	   mode->HSyncEnd,
	   mode->HTotal,

	   mode->VDisplay,
	   mode->VSyncStart,
	   mode->VSyncEnd,
	   mode->VTotal,
	   pScrn->depth,
	   pScrn->bitsPerPixel);
    if (mode->Flags & V_DBLSCAN)   ErrorF(" D");
    if (mode->Flags & V_CSYNC)     ErrorF(" C");
    if (mode->Flags & V_INTERLACE) ErrorF(" I");
    if (mode->Flags & V_PHSYNC)    ErrorF(" +H");
    if (mode->Flags & V_NHSYNC)    ErrorF(" -H");
    if (mode->Flags & V_PVSYNC)    ErrorF(" +V");
    if (mode->Flags & V_NVSYNC)    ErrorF(" -V");
    ErrorF("\n");
    ErrorF("%-12.12s %7.2f  %4d %4d %4d %4d  %4d %4d %4d %4d (%d,%d)",
	   mode->name,
	   dot_clock,

	   mode->CrtcHDisplay,
	   mode->CrtcHSyncStart,
	   mode->CrtcHSyncEnd,
	   mode->CrtcHTotal,

	   mode->CrtcVDisplay,
	   mode->CrtcVSyncStart,
	   mode->CrtcVSyncEnd,
	   mode->CrtcVTotal,
	   pScrn->depth,
	   pScrn->bitsPerPixel);
    if (mode->Flags & V_DBLSCAN)   ErrorF(" D");
    if (mode->Flags & V_CSYNC)     ErrorF(" C");
    if (mode->Flags & V_INTERLACE) ErrorF(" I");
    if (mode->Flags & V_PHSYNC)    ErrorF(" +H");
    if (mode->Flags & V_NHSYNC)    ErrorF(" -H");
    if (mode->Flags & V_PVSYNC)    ErrorF(" +V");
    if (mode->Flags & V_NVSYNC)    ErrorF(" -V");
    ErrorF("\n");
#endif

    info->Flags = mode->Flags;

    RADEONInitCommonRegisters(save, info);
    if (info->IsSecondary) {
	if (!RADEONInitCrtc2Registers(pScrn, save, mode, info))
	    return FALSE;
	RADEONInitPLL2Registers(save, &info->pll, dot_clock);
    } else {
	if (!RADEONInitCrtcRegisters(pScrn, save, mode, info))
	    return FALSE;
	dot_clock = mode->Clock/1000.0;
	if (dot_clock) {
            if (info->UseBiosDividers) {
                save->ppll_ref_div = info->RefDivider;
                save->ppll_div_3   = info->FeedbackDivider | (info->PostDivider << 16);
                save->htotal_cntl  = 0;
            }
            else
		RADEONInitPLLRegisters(save, info, dot_clock);
	} else {
	    save->ppll_ref_div = info->SavedReg.ppll_ref_div;
	    save->ppll_div_3   = info->SavedReg.ppll_div_3;
	    save->htotal_cntl  = info->SavedReg.htotal_cntl;
	}

	if (info->Clone && info->CurCloneMode) {
	    RADEONInitCrtc2Registers(pScrn, save, info->CurCloneMode, info);
	    dot_clock = info->CurCloneMode->Clock / 1000.0;
	    RADEONInitPLL2Registers(save, &info->pll, dot_clock);
	}
	/* Not used for now: */
     /* if (!info->PaletteSavedOnVT) RADEONInitPalette(save); */
    }

    RADEONInitFPRegisters(pScrn, &info->SavedReg, save, mode, info);

    RADEONTRACE(("RADEONInit returns %p\n", save));
    return TRUE;
}

/* Initialize a new mode */
static Bool RADEONModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);

    if (!RADEONInit(pScrn, mode, &info->ModeReg)) return FALSE;

    pScrn->vtSema = TRUE;
    RADEONBlank(pScrn);
    RADEONRestoreMode(pScrn, &info->ModeReg);
    RADEONUnblank(pScrn);

    info->CurrentLayout.mode = mode;

    if (info->DispPriority)
	RADEONInitDispBandwidth(pScrn);

    return TRUE;
}

static Bool RADEONSaveScreen(ScreenPtr pScreen, int mode)
{
    ScrnInfoPtr  pScrn = xf86Screens[pScreen->myNum];
    Bool         unblank;

    unblank = xf86IsUnblank(mode);
    if (unblank) SetTimeSinceLastInputEvent();

    if ((pScrn != NULL) && pScrn->vtSema) {
	if (unblank)  RADEONUnblank(pScrn);
	else          RADEONBlank(pScrn);
    }
    return TRUE;
}

Bool RADEONSwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
{
    ScrnInfoPtr    pScrn       = xf86Screens[scrnIndex];
    RADEONInfoPtr  info        = RADEONPTR(pScrn);
    Bool           ret;
#ifdef XF86DRI
    Bool           CPStarted   = info->CPStarted;

    if (CPStarted) {
	DRILock(pScrn->pScreen, 0);
	RADEONCP_STOP(pScrn, info);
    }
#endif

    if (info->accelOn) info->accel->Sync(pScrn);

    if (info->FBDev) {
	RADEONSaveFBDevRegisters(pScrn, &info->ModeReg);

	ret = fbdevHWSwitchMode(scrnIndex, mode, flags);

	RADEONRestoreFBDevRegisters(pScrn, &info->ModeReg);
    } else {
	info->IsSwitching = TRUE;
	if (info->Clone && info->CloneModes) {
	    DisplayModePtr  clone_mode = info->CloneModes;

	    /* Try to match a mode on primary head
	     * FIXME: This may not be good if both heads don't have
	     *        exactly the same list of mode.
	     */
	    while (1) {
		if ((clone_mode->HDisplay == mode->HDisplay) &&
		    (clone_mode->VDisplay == mode->VDisplay) &&
		    (!info->PanelOff)) {
		    info->CloneFrameX0 = (info->CurCloneMode->HDisplay +
					  info->CloneFrameX0 -
					  clone_mode->HDisplay - 1) / 2;
		    info->CloneFrameY0 =
			(info->CurCloneMode->VDisplay + info->CloneFrameY0 -
			 clone_mode->VDisplay - 1) / 2;
		    info->CurCloneMode = clone_mode;
		    break;
		}

		if (!clone_mode->next) {
		    info->CurCloneMode = info->CloneModes;
		    break;
		}

		clone_mode = clone_mode->next;
	    }
	}
	ret = RADEONModeInit(xf86Screens[scrnIndex], mode);

	if (info->CurCloneMode) {
	    if (info->CloneFrameX0 + info->CurCloneMode->HDisplay >=
		pScrn->virtualX)
		info->CloneFrameX0 =
		    pScrn->virtualX - info->CurCloneMode->HDisplay;
	    else if (info->CloneFrameX0 < 0)
		info->CloneFrameX0 = 0;

	    if (info->CloneFrameY0 + info->CurCloneMode->VDisplay >=
		pScrn->virtualY)
		info->CloneFrameY0 =
		    pScrn->virtualY - info->CurCloneMode->VDisplay;
	    else if (info->CloneFrameY0 < 0)
		info->CloneFrameY0 = 0;

	    RADEONDoAdjustFrame(pScrn, info->CloneFrameX0, info->CloneFrameY0,
				TRUE);
	}

	info->IsSwitching = FALSE;
    }

    if (info->accelOn) {
	info->accel->Sync(pScrn);
	RADEONEngineRestore(pScrn);
    }

#ifdef XF86DRI
    if (CPStarted) {
	RADEONCP_START(pScrn, info);
	DRIUnlock(pScrn->pScreen);
    }
#endif

    return ret;
}

#ifdef X_XF86MiscPassMessage
Bool RADEONHandleMessage(int scrnIndex, const char* msgtype,
			 const char* msgval, char** retmsg)
{
    ErrorF("RADEONHandleMessage(%d, \"%s\", \"%s\", retmsg)\n", scrnIndex,
		    msgtype, msgval);
    *retmsg = "";
    return 0;
}
#endif

/* Used to disallow modes that are not supported by the hardware */
ModeStatus RADEONValidMode(int scrnIndex, DisplayModePtr mode,
			   Bool verbose, int flag)
{
    /* There are problems with double scan mode at high clocks
     * They're likely related PLL and display buffer settings.
     * Disable these modes for now.
     */
    if (mode->Flags & V_DBLSCAN) {
	if ((mode->CrtcHDisplay >= 1024) || (mode->CrtcVDisplay >= 768))
	    return MODE_CLOCK_RANGE;
    }
    return MODE_OK;
}

/* Adjust viewport into virtual desktop such that (0,0) in viewport
 * space is (x,y) in virtual space.
 */
void RADEONDoAdjustFrame(ScrnInfoPtr pScrn, int x, int y, int clone)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int            reg, Base = y * info->CurrentLayout.displayWidth + x;
#ifdef XF86DRI
    RADEONSAREAPrivPtr pSAREAPriv;
#endif

    switch (info->CurrentLayout.pixel_code) {
    case 15:
    case 16: Base *= 2; break;
    case 24: Base *= 3; break;
    case 32: Base *= 4; break;
    }

    Base &= ~7;                 /* 3 lower bits are always 0 */

    if (clone || info->IsSecondary) {
	Base += pScrn->fbOffset;
	reg = RADEON_CRTC2_OFFSET;
    } else {
	reg = RADEON_CRTC_OFFSET;
    }

#ifdef XF86DRI
    if (info->directRenderingEnabled) {

	pSAREAPriv = DRIGetSAREAPrivate(pScrn->pScreen);

	if (clone || info->IsSecondary) {
	    pSAREAPriv->crtc2_base = Base;
	}

	if (pSAREAPriv->pfCurrentPage == 1) {
	    Base += info->backOffset;
	}
    }
#endif

    OUTREG(reg, Base);
}

void RADEONAdjustFrame(int scrnIndex, int x, int y, int flags)
{
    ScrnInfoPtr    pScrn      = xf86Screens[scrnIndex];
    RADEONInfoPtr  info       = RADEONPTR(pScrn);

#ifdef XF86DRI
    if (info->CPStarted) DRILock(pScrn->pScreen, 0);
#endif

    if (info->accelOn) info->accel->Sync(pScrn);

    if (info->FBDev) {
	fbdevHWAdjustFrame(scrnIndex, x, y, flags);
    } else {
	RADEONDoAdjustFrame(pScrn, x, y, FALSE);
    }

#ifdef XF86DRI
	if (info->CPStarted) DRIUnlock(pScrn->pScreen);
#endif
}

/* Called when VT switching back to the X server.  Reinitialize the
 * video mode.
 */
Bool RADEONEnterVT(int scrnIndex, int flags)
{
    ScrnInfoPtr    pScrn = xf86Screens[scrnIndex];
    RADEONInfoPtr  info  = RADEONPTR(pScrn);

    RADEONTRACE(("RADEONEnterVT\n"));

    if (info->FBDev) {
	unsigned char *RADEONMMIO = info->MMIO;
	if (!fbdevHWEnterVT(scrnIndex,flags)) return FALSE;
	info->PaletteSavedOnVT = FALSE;
	info->ModeReg.surface_cntl = INREG(RADEON_SURFACE_CNTL);

	RADEONRestoreFBDevRegisters(pScrn, &info->ModeReg);
    } else
	if (!RADEONModeInit(pScrn, pScrn->currentMode)) return FALSE;

#ifdef XF86DRI
    if (info->directRenderingEnabled) {
	/* get the Radeon back into shape after resume */
	RADEONDRIResume(pScrn->pScreen);
    }
#endif
    /* this will get XVideo going again, but only if XVideo was initialised
       during server startup (hence the info->adaptor if). */
    if (info->adaptor)
	RADEONResetVideo(pScrn);

    if (info->accelOn)
	RADEONEngineRestore(pScrn);

#ifdef XF86DRI
    if (info->directRenderingEnabled) {
	RADEONCP_START(pScrn, info);
	DRIUnlock(pScrn->pScreen);
    }
#endif

    pScrn->AdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
    if (info->CurCloneMode) {
	RADEONDoAdjustFrame(pScrn, info->CloneFrameX0, info->CloneFrameY0, TRUE);
    }

    return TRUE;
}

/* Called when VT switching away from the X server.  Restore the
 * original text mode.
 */
void RADEONLeaveVT(int scrnIndex, int flags)
{
    ScrnInfoPtr    pScrn = xf86Screens[scrnIndex];
    RADEONInfoPtr  info  = RADEONPTR(pScrn);
    RADEONSavePtr  save  = &info->ModeReg;

    RADEONTRACE(("RADEONLeaveVT\n"));
#ifdef XF86DRI
    if (RADEONPTR(pScrn)->directRenderingEnabled) {
	DRILock(pScrn->pScreen, 0);
	RADEONCP_STOP(pScrn, info);
    }
#endif

    if (info->FBDev) {
	RADEONSavePalette(pScrn, save);
	info->PaletteSavedOnVT = TRUE;

	RADEONSaveFBDevRegisters(pScrn, &info->ModeReg);

	fbdevHWLeaveVT(scrnIndex,flags);
    }

    RADEONRestore(pScrn);
}

/* Called at the end of each server generation.  Restore the original
 * text mode, unmap video memory, and unwrap and call the saved
 * CloseScreen function.
 */
static Bool RADEONCloseScreen(int scrnIndex, ScreenPtr pScreen)
{
    ScrnInfoPtr    pScrn = xf86Screens[scrnIndex];
    RADEONInfoPtr  info  = RADEONPTR(pScrn);

    RADEONTRACE(("RADEONCloseScreen\n"));

#ifdef XF86DRI
				/* Disable direct rendering */
    if (info->directRenderingEnabled) {
	RADEONDRICloseScreen(pScreen);
	info->directRenderingEnabled = FALSE;
    }
#endif

    if (pScrn->vtSema) {
	RADEONRestore(pScrn);
    }
    RADEONUnmapMem(pScrn);

    if (info->accel) XAADestroyInfoRec(info->accel);
    info->accel = NULL;

    if (info->scratch_save) xfree(info->scratch_save);
    info->scratch_save = NULL;

    if (info->cursor) xf86DestroyCursorInfoRec(info->cursor);
    info->cursor = NULL;

    if (info->DGAModes) xfree(info->DGAModes);
    info->DGAModes = NULL;

    pScrn->vtSema = FALSE;

    xf86ClearPrimInitDone(info->pEnt->index);

    pScreen->BlockHandler = info->BlockHandler;
    pScreen->CloseScreen = info->CloseScreen;
    return (*pScreen->CloseScreen)(scrnIndex, pScreen);
}

void RADEONFreeScreen(int scrnIndex, int flags)
{
    ScrnInfoPtr  pScrn = xf86Screens[scrnIndex];

    RADEONTRACE(("RADEONFreeScreen\n"));

    if (xf86LoaderCheckSymbol("vgaHWFreeHWRec"))
	vgaHWFreeHWRec(pScrn);
    RADEONFreeRec(pScrn);
}

/* Sets VESA Display Power Management Signaling (DPMS) Mode */
static void RADEONDisplayPowerManagementSet(ScrnInfoPtr pScrn,
					    int PowerManagementMode,
					    int flags)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

#ifdef XF86DRI
    if (info->CPStarted) DRILock(pScrn->pScreen, 0);
#endif

    if (info->accelOn) info->accel->Sync(pScrn);

    if (info->FBDev) {
	fbdevHWDPMSSet(pScrn, PowerManagementMode, flags);
    } else {
	int             mask1     = (RADEON_CRTC_DISPLAY_DIS |
				     RADEON_CRTC_HSYNC_DIS |
				     RADEON_CRTC_VSYNC_DIS);
	int             mask2     = (RADEON_CRTC2_DISP_DIS |
				     RADEON_CRTC2_VSYNC_DIS |
				     RADEON_CRTC2_HSYNC_DIS);

	/* TODO: additional handling for LCD ? */

	switch (PowerManagementMode) {
	case DPMSModeOn:
	    /* Screen: On; HSync: On, VSync: On */
	    if (info->IsSecondary)
		OUTREGP(RADEON_CRTC2_GEN_CNTL, 0, ~mask2);
	    else {
		if (info->Clone)
		    OUTREGP(RADEON_CRTC2_GEN_CNTL, 0, ~mask2);
		OUTREGP(RADEON_CRTC_EXT_CNTL, 0, ~mask1);
	    }
	    break;

	case DPMSModeStandby:
	    /* Screen: Off; HSync: Off, VSync: On */
	    if (info->IsSecondary)
		OUTREGP(RADEON_CRTC2_GEN_CNTL,
			RADEON_CRTC2_DISP_DIS | RADEON_CRTC2_HSYNC_DIS,
			~mask2);
	    else {
		if (info->Clone)
		    OUTREGP(RADEON_CRTC2_GEN_CNTL,
			    RADEON_CRTC2_DISP_DIS | RADEON_CRTC2_HSYNC_DIS,
			    ~mask2);
		OUTREGP(RADEON_CRTC_EXT_CNTL,
			RADEON_CRTC_DISPLAY_DIS | RADEON_CRTC_HSYNC_DIS,
			~mask1);
	    }
	    break;

	case DPMSModeSuspend:
	    /* Screen: Off; HSync: On, VSync: Off */
	    if (info->IsSecondary)
		OUTREGP(RADEON_CRTC2_GEN_CNTL,
			RADEON_CRTC2_DISP_DIS | RADEON_CRTC2_VSYNC_DIS,
			~mask2);
	    else {
		if (info->Clone)
		    OUTREGP(RADEON_CRTC2_GEN_CNTL,
			    RADEON_CRTC2_DISP_DIS | RADEON_CRTC2_VSYNC_DIS,
			    ~mask2);
		OUTREGP(RADEON_CRTC_EXT_CNTL,
			RADEON_CRTC_DISPLAY_DIS | RADEON_CRTC_VSYNC_DIS,
			~mask1);
	    }
	    break;

	case DPMSModeOff:
	    /* Screen: Off; HSync: Off, VSync: Off */
	    if (info->IsSecondary)
		OUTREGP(RADEON_CRTC2_GEN_CNTL, mask2, ~mask2);
	    else {
		if (info->Clone)
		    OUTREGP(RADEON_CRTC2_GEN_CNTL, mask2, ~mask2);
		OUTREGP(RADEON_CRTC_EXT_CNTL, mask1, ~mask1);
	    }
	    break;
	}

	if (PowerManagementMode == DPMSModeOn) {
	    if (info->IsSecondary) {
		if (info->DisplayType == MT_DFP) {
		    OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_BLANK_EN);
		    OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_ON, ~RADEON_FP2_ON);
		    if (info->ChipFamily >= CHIP_FAMILY_R200) {
			OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_DV0_EN, ~RADEON_FP2_DV0_EN);
		    }
		}
	    } else {
		if ((info->Clone) && (info->CloneType == MT_DFP)) {
		    OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_BLANK_EN);
		    OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_ON, ~RADEON_FP2_ON);
		    if (info->ChipFamily >= CHIP_FAMILY_R200) {
			OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_DV0_EN, ~RADEON_FP2_DV0_EN);
		    }
		}
		if (info->DisplayType == MT_DFP) {
		    OUTREGP (RADEON_FP_GEN_CNTL, (RADEON_FP_FPON | RADEON_FP_TMDS_EN),
			     ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN));
		} else if (info->DisplayType == MT_LCD) {

		    OUTREGP (RADEON_LVDS_GEN_CNTL, RADEON_LVDS_BLON, ~RADEON_LVDS_BLON);
		    usleep (info->PanelPwrDly * 1000);
		    OUTREGP (RADEON_LVDS_GEN_CNTL, RADEON_LVDS_ON, ~RADEON_LVDS_ON);
		}
	    }
	} else if ((PowerManagementMode == DPMSModeOff) ||
		   (PowerManagementMode == DPMSModeSuspend) ||
		   (PowerManagementMode == DPMSModeStandby)) {
	    if (info->IsSecondary) {
		if (info->DisplayType == MT_DFP) {
		    OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_BLANK_EN, ~RADEON_FP2_BLANK_EN);
		    OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_ON);
		    if (info->ChipFamily >= CHIP_FAMILY_R200) {
			OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_DV0_EN);
		    }
		}
	    } else {
		if ((info->Clone) && (info->CloneType == MT_DFP)) {
		    OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_BLANK_EN, ~RADEON_FP2_BLANK_EN);
		    OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_ON);
		    if (info->ChipFamily >= CHIP_FAMILY_R200) {
			OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_DV0_EN);
		    }
		}
		if (info->DisplayType == MT_DFP) {
		    OUTREGP (RADEON_FP_GEN_CNTL, 0, ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN));
		} else if (info->DisplayType == MT_LCD) {
		    unsigned long tmpPixclksCntl = INPLL(pScrn, RADEON_PIXCLKS_CNTL);

		    if (info->IsMobility || info->IsIGP) {
			/* Asic bug, when turning off LVDS_ON, we have to make sure
			   RADEON_PIXCLK_LVDS_ALWAYS_ON bit is off
			*/
			OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL, 0, ~RADEON_PIXCLK_LVDS_ALWAYS_ONb);
		    }

		    OUTREGP (RADEON_LVDS_GEN_CNTL, 0,
			     ~(RADEON_LVDS_BLON | RADEON_LVDS_ON));

		    if (info->IsMobility || info->IsIGP) {
			OUTPLL(RADEON_PIXCLKS_CNTL, tmpPixclksCntl);
		    }
		}
	    }
	}
    }

#ifdef XF86DRI
    if (info->CPStarted) DRIUnlock(pScrn->pScreen);
#endif
}
@


1.3
log
@merge
@
text
@d142 4
a145 1
    OPTION_MIN_DOTCLOCK
d181 3
d1817 1
a1817 1
		case PCI_CHIP_RADEON_LW: /* Guessed based on iBook Open Firmware data -ReneR */
a2157 1

a3696 1
#if !defined(__powerpc__)
d3699 1
d5041 8
d6477 1
a6477 1
static void RADEONInitPLLRegisters(RADEONSavePtr save, RADEONPLLPtr pll,
d6481 1
d6531 8
a6538 3
    save->ppll_div_3     = (save->feedback_div | (post_div->bitvalue << 16));
#if defined(__powerpc__) /* on iBooks the LCD pannel needs tweaked PLL timings -ReneR */
    save->ppll_div_3     = 0x000600ad; /* -ReneR */
d6540 2
d6686 1
a6686 1
		RADEONInitPLLRegisters(save, &info->pll, dot_clock);
@


1.2
log
@semi-automagic merge of these files (ie, I've skipped through the diffs,
and most of that was done by cvs or that weird script of some minutes ago)
@
text
@d1811 5
d3692 1
a3694 1
#if !defined(__powerpc__)
d6518 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c,v 1.50 2002/01/16 02:00:43 martin Exp $ */
d32 1
a32 1
 *   Kevin E. Martin <martin@@valinux.com>
d34 1
a34 1
 *   Alan Hourihane <ahourihane@@valinux.com>
d55 1
a55 1
 *   shadowfb
d63 1
a73 2
#define USE_FB                  /* not until overlays */
#ifdef USE_FB
a74 11
#else

				/* CFB support */
#define PSZ 8
#include "cfb.h"
#undef PSZ
#include "cfb16.h"
#include "cfb24.h"
#include "cfb32.h"
#include "cfb24_32.h"
#endif
d85 1
d96 3
d109 1
d118 1
a119 1
    OPTION_NO_SECURITY,
d122 2
a123 1
    OPTION_AGP_SIZE,
d127 2
d130 11
a140 1
    OPTION_CRT_SCREEN,
d142 1
a142 1
    OPTION_FBDEV
d146 4
a149 4
    { OPTION_NOACCEL,      "NoAccel",          OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_SW_CURSOR,    "SWcursor",         OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_DAC_6BIT,     "Dac6Bit",          OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_DAC_8BIT,     "Dac8Bit",          OPTV_BOOLEAN, {0}, TRUE  },
d151 28
a178 19
    { OPTION_IS_PCI,       "ForcePCIMode",     OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_CP_PIO,       "CPPIOMode",        OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_USEC_TIMEOUT, "CPusecTimeout",    OPTV_INTEGER, {0}, FALSE },
    { OPTION_AGP_MODE,     "AGPMode",          OPTV_INTEGER, {0}, FALSE },
    { OPTION_AGP_SIZE,     "AGPSize",          OPTV_INTEGER, {0}, FALSE },
    { OPTION_RING_SIZE,    "RingSize",         OPTV_INTEGER, {0}, FALSE },
    { OPTION_BUFFER_SIZE,  "BufferSize",       OPTV_INTEGER, {0}, FALSE },
    { OPTION_DEPTH_MOVE,   "EnableDepthMoves", OPTV_BOOLEAN, {0}, FALSE },
#endif
    { OPTION_CRT_SCREEN,   "CrtScreen",        OPTV_BOOLEAN, {0}, FALSE},
    { OPTION_PANEL_SIZE,   "PanelSize",        OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_FBDEV,        "UseFBDev",         OPTV_BOOLEAN, {0}, FALSE },
    { -1,                  NULL,               OPTV_NONE,    {0}, FALSE }
};

RADEONRAMRec RADEONRAM[] = {    /* Memory Specifications
				   From Radeon Manual */
    { 4, 4, 1, 2, 1, 2, 1, 16, 12, "64-bit SDR SDRAM" },
    { 4, 4, 3, 3, 2, 3, 1, 16, 12, "64-bit DDR SDRAM" },
d199 2
a227 1
#ifdef USE_FB
a232 10
#else
static const char *cfbSymbols[] = {
    "cfbScreenInit",
    "cfb16ScreenInit",
    "cfb24ScreenInit",
    "cfb32ScreenInit",
    "cfb24_32ScreenInit",
    NULL
};
#endif
d251 1
d258 3
d265 1
d274 4
d280 1
d292 2
a293 1
    "drmScatterGatherFree"
d305 1
d314 5
d340 69
d411 18
a428 4
#if !defined(__alpha__)
# define RADEONPreInt10Save(s, r1, r2)
# define RADEONPostInt10Check(s, r1, r2)
#else /* __alpha__ */
d430 1
a430 1
RADEONSaveRegsZapMemCntl(ScrnInfoPtr pScrn, CARD32 *MEM_CNTL, CARD32 *MEMSIZE)
d432 4
a435 3
    RADEONInfoPtr info = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO;
    int mapped = 0;
d437 4
a440 15
    /*
     * First make sure we have the pci and mmio info and that mmio is mapped
     */
    if (!info->PciInfo)
	info->PciInfo = xf86GetPciInfoForEntity(info->pEnt->index);
    if (!info->PciTag)
	info->PciTag = pciTag(info->PciInfo->bus, info->PciInfo->device,
			      info->PciInfo->func);
    if (!info->MMIOAddr) 
	info->MMIOAddr = info->PciInfo->memBase[2] & 0xffffff00;
    if (!info->MMIO) {
	RADEONMapMMIO(pScrn);
	mapped = 1;
    }
    RADEONMMIO = info->MMIO;
d443 1
a443 1
     * Save the values and zap MEM_CNTL
a444 2
    *MEM_CNTL = INREG(RADEON_MEM_CNTL);
    *MEMSIZE = INREG(RADEON_CONFIG_MEMSIZE);
d446 3
d450 1
a450 5
    /*
     * Unmap mmio space if we mapped it
     */
    if (mapped) 
	RADEONUnmapMMIO(pScrn);
d454 1
a454 1
RADEONCheckRegs(ScrnInfoPtr pScrn, CARD32 Saved_MEM_CNTL, CARD32 Saved_MEMSIZE)
d456 4
a459 4
    RADEONInfoPtr info = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO;
    CARD32 MEM_CNTL;
    int mapped = 0;
d461 2
a462 4
    /*
     * If we don't have a valid (non-zero) saved MEM_CNTL, get out now
     */
    if (!Saved_MEM_CNTL)
d466 1
a466 10
     * First make sure that mmio is mapped
     */
    if (!info->MMIO) {
	RADEONMapMMIO(pScrn);
	mapped = 1;
    }
    RADEONMMIO = info->MMIO;

    /*
     * If either MEM_CNTL is currently zero or inconistent (configured for 
d470 5
a474 7
    MEM_CNTL = INREG(RADEON_MEM_CNTL);
    if (!MEM_CNTL || 
	((MEM_CNTL & 1) && 
	 (((MEM_CNTL >> 8) & 0xff) != ((MEM_CNTL >> 24) & 0xff)))) {
	/*
	 * Restore the saved registers
	 */
d476 12
a487 3
		   "Restoring MEM_CNTL (%08x), setting to %08x\n",
		   MEM_CNTL, Saved_MEM_CNTL);
	OUTREG(RADEON_MEM_CNTL, Saved_MEM_CNTL);
d489 2
d492 6
a497 3
		   "Restoring CONFIG_MEMSIZE (%08x), setting to %08x\n",
		   INREG(RADEON_CONFIG_MEMSIZE), Saved_MEMSIZE);
	OUTREG(RADEON_CONFIG_MEMSIZE, Saved_MEMSIZE);
a498 6

    /*
     * Unmap mmio space if we mapped it
     */
    if (mapped) 
	RADEONUnmapMMIO(pScrn);
d501 1
a501 7
# define RADEONPreInt10Save(s, r1, r2) 		\
    RADEONSaveRegsZapMemCntl((s), (r1), (r2))
# define RADEONPostInt10Check(s, r1, r2)	\
    RADEONCheckRegs((s), (r1), (r2))
#endif /* __alpha__ */

/* Allocate our private RADEONInfoRec. */
d510 1
a510 1
/* Free our private RADEONInfoRec. */
d519 2
a520 1
   below. */
d523 1
a523 1
    RADEONInfoPtr info          = RADEONPTR(pScrn);
d540 2
a541 1
   below. */
d544 1
a544 1
    RADEONInfoPtr info          = RADEONPTR(pScrn);
d558 1
a558 1
    RADEONInfoPtr info          = RADEONPTR(pScrn);
d577 1
a577 1
    RADEONInfoPtr info          = RADEONPTR(pScrn);
d587 1
a587 1
/* Memory map the MMIO region and the frame buffer. */
d598 1
a598 1
/* Unmap the MMIO region and the frame buffer. */
d605 17
d625 1
a625 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d627 1
d629 5
a633 8
#if !RADEON_ATOMIC_UPDATE
    while ( (INREG8(RADEON_CLOCK_CNTL_INDEX) & 0xbf) != addr) {
#endif
	OUTREG8(RADEON_CLOCK_CNTL_INDEX, addr & 0x3f);
#if !RADEON_ATOMIC_UPDATE
    }
#endif
    return INREG(RADEON_CLOCK_CNTL_DATA);
d637 1
a637 1
/* Read PAL information (only used for debugging). */
d640 1
a640 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d648 1
a648 1
/* Wait for vertical sync. */
d651 1
a651 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d653 1
a653 1
    int           i;
d655 7
a661 3
    OUTREG(RADEON_GEN_INT_STATUS, RADEON_VSYNC_INT_AK);
    for (i = 0; i < RADEON_TIMEOUT; i++) {
	if (INREG(RADEON_GEN_INT_STATUS) & RADEON_VSYNC_INT) break;
d665 2
a666 2
/* Blank screen. */
static void RADEONBlank(ScrnInfoPtr pScrn)
d668 1
a668 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d670 4
d675 4
a678 31
    if(!info->IsSecondary)
    {
        switch(info->DisplayType)
        {
        case MT_LCD:
            OUTREGP(RADEON_LVDS_GEN_CNTL, RADEON_LVDS_DISPLAY_DIS,
                 ~RADEON_LVDS_DISPLAY_DIS);
        case MT_CRT:
        case MT_DFP:
    OUTREGP(RADEON_CRTC_EXT_CNTL,
	    RADEON_CRTC_DISPLAY_DIS |
	    RADEON_CRTC_VSYNC_DIS |
	    RADEON_CRTC_HSYNC_DIS,
	  ~(RADEON_CRTC_DISPLAY_DIS |
	    RADEON_CRTC_VSYNC_DIS |
	    RADEON_CRTC_HSYNC_DIS));
            break;
        case MT_NONE:
        default:
           break;
        }
    }
    else
    {
            OUTREGP(RADEON_CRTC2_GEN_CNTL, 
                 RADEON_CRTC2_DISP_DIS |
	         RADEON_CRTC2_VSYNC_DIS |
	         RADEON_CRTC2_HSYNC_DIS,
	       ~(RADEON_CRTC2_DISP_DIS |
	         RADEON_CRTC2_VSYNC_DIS |
	         RADEON_CRTC2_HSYNC_DIS));
d682 2
a683 2
/* Unblank screen. */
static void RADEONUnblank(ScrnInfoPtr pScrn)
d685 1
a685 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d687 23
a709 37
    if(!info->IsSecondary)
    {
        switch(info->DisplayType)
        {
        case MT_LCD:
            OUTREGP(RADEON_LVDS_GEN_CNTL, 0,
                 ~RADEON_LVDS_DISPLAY_DIS);
        case MT_CRT:
        case MT_DFP:
            OUTREGP(RADEON_CRTC_EXT_CNTL, 
               RADEON_CRTC_CRT_ON,
	  ~(RADEON_CRTC_DISPLAY_DIS |
	    RADEON_CRTC_VSYNC_DIS |
	    RADEON_CRTC_HSYNC_DIS));
            break;
        case MT_NONE:
        default:
            break;
        }
    }
    else
    {
        switch(info->DisplayType)
        {
        case MT_LCD:
        case MT_DFP:
        case MT_CRT:
            OUTREGP(RADEON_CRTC2_GEN_CNTL,
                0,
	       ~(RADEON_CRTC2_DISP_DIS |
	         RADEON_CRTC2_VSYNC_DIS |
	         RADEON_CRTC2_HSYNC_DIS));
            break;
        case MT_NONE:
        default:
            break;
        }
d713 2
a714 4
/***Used to turn particular crtc or dac off 
    Not tested, comment out for now*/
#if 0
static void RADEONSetDisplayOff(ScrnInfoPtr pScrn, int crtc, int dac)
d716 1
a716 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
a717 1
    CARD32 tmp;
d719 32
a750 33
    if(crtc == 0)   /* primary crtc*/
    {
        tmp = INREG(RADEON_CRTC_EXT_CNTL);
        tmp |= RADEON_CRTC_DISPLAY_DIS | RADEON_CRTC_SYNC_TRISTAT;
        OUTREG(RADEON_CRTC_EXT_CNTL, tmp);
        tmp &= ~(RADEON_CRTC_DISPLAY_DIS | RADEON_CRTC_CRT_ON);
        OUTREG(RADEON_CRTC_EXT_CNTL, tmp);
        /*TODO update BIOS scratch register*/   
    }
    else            /* secondary crtc*/
    { 
        tmp = INREG(RADEON_CRTC2_GEN_CNTL);
        tmp |= RADEON_CRTC2_SYNC_TRISTAT | RADEON_CRTC2_DISP_DIS;
        OUTREG(RADEON_CRTC2_GEN_CNTL, tmp);
        tmp &= ~(RADEON_CRTC2_DISP_DIS | RADEON_CRTC2_CRT2_ON);
        OUTREG(RADEON_CRTC2_GEN_CNTL, tmp);
        /*TODO update BIOS scratch register*/   
    }
    if(dac == 0)
    {
        tmp = INREG(RADEON_DAC_CNTL);          
        tmp |= RADEON_DAC_PDWN;
        OUTREG(RADEON_DAC_CNTL, tmp);
    }
    else
    {
        tmp = INREG(RADEON_TV_DAC_CNTL);
        if(RADEON_TV_DAC_STD_MASK & tmp)
        {
            tmp |= RADEON_TV_DAC_RDACPD | RADEON_TV_DAC_GDACPD
                | RADEON_TV_DAC_BDACPD;    
            OUTREG(RADEON_TV_DAC_CNTL, tmp);
        }
a752 1
#endif
d754 1
a754 1
/* Compute log base 2 of val. */
d757 1
a757 1
    int bits;
d764 1
a764 1
/* Compute n/d with rounding. */
d770 1
a770 2
/* Read the Video BIOS block and the FP registers (if applicable). */
static Bool RADEONGetBIOSParameters(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
d772 5
a776 11
    RADEONInfoPtr info     = RADEONPTR(pScrn);
    unsigned long tmp, i;
    unsigned char   *RADEONMMIO;

#define RADEON_BIOS8(v)  (info->VBIOS[v])
#define RADEON_BIOS16(v) (info->VBIOS[v] | \
			  (info->VBIOS[(v) + 1] << 8))
#define RADEON_BIOS32(v) (info->VBIOS[v] | \
			  (info->VBIOS[(v) + 1] << 8) | \
			  (info->VBIOS[(v) + 2] << 16) | \
			  (info->VBIOS[(v) + 3] << 24))
d778 2
a779 1
    if (!(info->VBIOS = xalloc(RADEON_VBIOS_SIZE)))
d781 15
a795 3
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Cannot allocate space for hold Video BIOS!\n");
	return FALSE;
d798 22
d821 1
a821 28
    if (pInt10)
    {
	info->BIOSAddr = pInt10->BIOSseg << 4;
	(void)memcpy(info->VBIOS, xf86int10Addr(pInt10, info->BIOSAddr),
		     RADEON_VBIOS_SIZE);
    }
    else
    {
	xf86ReadPciBIOS(0, info->PciTag, 0, info->VBIOS, RADEON_VBIOS_SIZE);
	      if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa)
	      {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Video BIOS not detected in PCI space!\n");
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Attempting to read Video BIOS from legacy ISA space!\n");
	    info->BIOSAddr = 0x000c0000;
	    xf86ReadBIOS(info->BIOSAddr, 0, info->VBIOS, RADEON_VBIOS_SIZE);
	}
    }
    if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa)
    {
	xfree(info->VBIOS);
	info->VBIOS = NULL;
	info->BIOSAddr = 0x00000000;
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Video BIOS not found!\n");
	return TRUE;
    }
d823 2
a824 1
    info->FPBIOSstart = RADEON_BIOS16(0x48);
d826 30
a855 177
    {
        BOOL BypassSecondary = FALSE;
        RADEONMapMMIO(pScrn);
        RADEONMMIO               = info->MMIO;
        /*FIXME: using BIOS scratch registers to detect connected monitors 
             may not be a reliable way.... should use EDID data. 
             Also it only works with for VE/M6, no
             such registers in regular RADEON!!!*/
        /*****
          VE and M6 have both DVI and CRT ports (for M6 DVI port can be switch to
          DFP port). The DVI port can also be conneted to a CRT with an adapter.
          Here is the definition of ports for this driver---
          (1) If both port are connected, DVI port will be treated as the Primary 
              port (first screen in XF86Config, uses CRTC1) and CRT port will be 
              treated as the Secondary port (second screen in XF86Config, uses CRTC2)
          (2) If only one screen specified in XF86Config, it will be used for DVI port
              if a monitor is connected to DVI port, otherwise (only one monitor is 
              connected the CRT port) it will be used for CRT port.
        *****/
        if(info->HasCRTC2)
        {                    
             /*FIXME: this may not be reliable*/
             tmp = INREG(RADEON_BIOS_4_SCRATCH);
             if(info->IsSecondary)
             {  
                 /*check Port2 (CRT port, for the existing boards 
                   (VE & M6),this port can only be connected to a CRT*/
                 if(tmp & 0x02) info->DisplayType = MT_CRT;
                 else if(tmp & 0x800) info->DisplayType = MT_DFP;
                 else if(tmp & 0x400) info->DisplayType = MT_LCD;
                 else if(tmp & 0x1000) info->DisplayType = MT_CTV;
                 else if(tmp & 0x2000) info->DisplayType = MT_STV;
                 else info->DisplayType = MT_CRT;

                 if(info->DisplayType > MT_NONE)
                 {
                     DevUnion* pPriv;
                     RADEONEntPtr pRADEONEnt;
                     pPriv = xf86GetEntityPrivate(pScrn->entityList[0], 
                         gRADEONEntityIndex);
                     pRADEONEnt = pPriv->ptr;
                     pRADEONEnt->HasSecondary = TRUE;

                 }
                 else return FALSE;
                     
             }
             else
             {
                 /*check Primary (DVI/DFP port)*/
                 if(tmp & 0x08) info->DisplayType = MT_DFP;
                 else if(tmp & 0x04) info->DisplayType = MT_LCD;
                 else if(tmp & 0x0200) info->DisplayType = MT_CRT;
                 else if(tmp & 0x10) info->DisplayType = MT_CTV;
                 else if(tmp & 0x20) info->DisplayType = MT_STV;
                 else 
                 {
                     /*DVI port has no monitor connected, try CRT port.
                     If something on CRT port, treat it as primary*/
                     if(xf86IsEntityShared(pScrn->entityList[0]))
                     {
                         DevUnion* pPriv;
                         RADEONEntPtr pRADEONEnt;
                         pPriv = xf86GetEntityPrivate(pScrn->entityList[0], 
                             gRADEONEntityIndex);
                         pRADEONEnt = pPriv->ptr;
                         pRADEONEnt->BypassSecondary = TRUE;
                     }

                     if(tmp & 0x02) info->DisplayType = MT_CRT;
                     else if(tmp & 0x800) info->DisplayType = MT_DFP;
                     else if(tmp & 0x400) info->DisplayType = MT_LCD;
                     else if(tmp & 0x1000) info->DisplayType = MT_CTV;
                     else if(tmp & 0x2000) info->DisplayType = MT_STV;
                     else
                     {
                         xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                             "No monitor detected!!!\n");
                         return FALSE;
                     }
                     BypassSecondary = TRUE;
                 }
             }
         }
         else
         {
             /*Regular Radeon ASIC, only one CRTC, but it could be
               used for DFP with a DVI output, like AIW board*/
             tmp = INREG(RADEON_FP_GEN_CNTL);
             if(tmp & RADEON_FP_EN_TMDS) info->DisplayType = MT_DFP;
             else info->DisplayType = MT_CRT;
         }

         xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%s Display == Type %d\n",
              (info->IsSecondary ? "Secondary" : "Primary"), 
               info->DisplayType);
        
        RADEONMMIO               = NULL;
        RADEONUnmapMMIO(pScrn);

        info->HBlank = 0;
        info->HOverPlus = 0;
        info->HSyncWidth = 0;
        info->VBlank = 0;
        info->VOverPlus = 0;
        info->VSyncWidth = 0;          
        info->DotClock = 0;

		 if(info->DisplayType == MT_LCD) {
             tmp = RADEON_BIOS16(info->FPBIOSstart + 0x40);
             if(!tmp) {
                 info->PanelPwrDly = 200;
                 xf86DrvMsg(pScrn->scrnIndex, X_INFO, "No Panel Info Table found in BIOS!\n");
             } else {
                 char stmp[30];
                 int tmp0;
                 for(i=0; i<24; i++)
					 stmp[i] = RADEON_BIOS8(tmp+i+1);
				 stmp[24] = 0; 
                 xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
                     "Panel ID string: %s\n", stmp);
                 info->PanelXRes = RADEON_BIOS16(tmp+25);
                 info->PanelYRes = RADEON_BIOS16(tmp+27);
                 xf86DrvMsg(0, X_INFO, "Panel Size from BIOS: %dx%d\n", 
							info->PanelXRes, info->PanelYRes);
                 info->PanelPwrDly = RADEON_BIOS16(tmp+44);
                 if(info->PanelPwrDly > 2000 || info->PanelPwrDly < 0)
                      info->PanelPwrDly = 2000;
                 for(i=0; i<20; i++) {
                     tmp0 = RADEON_BIOS16(tmp+64+i*2);
                     if(tmp0 == 0) break;
                     if((RADEON_BIOS16(tmp0) == info->PanelXRes) &&
						(RADEON_BIOS16(tmp0+2) == info->PanelYRes)) {

                         info->HBlank = (RADEON_BIOS16(tmp0+17) - RADEON_BIOS16(tmp0+19)) * 8;
                         info->HOverPlus = (RADEON_BIOS16(tmp0+21) - RADEON_BIOS16(tmp0+19) - 1) * 8;
                         info->HSyncWidth = RADEON_BIOS8(tmp0+23) * 8;
                         info->VBlank = RADEON_BIOS16(tmp0+24) - RADEON_BIOS16(tmp0+26);
                         info->VOverPlus = (RADEON_BIOS16(tmp0+28) & 0x7ff) - RADEON_BIOS16(tmp0+26);
                         info->VSyncWidth = (RADEON_BIOS16(tmp0+28) & 0xf800) >> 11;          
                         info->DotClock = RADEON_BIOS16(tmp0+9) * 10;
                     }
                 }
             } 
         }

        /* Detect connector type from BIOS, used for
           I2C/DDC qeurying EDID, Only available for VE or newer cards*/
        tmp = RADEON_BIOS16(info->FPBIOSstart + 0x50);
        if(tmp)
	    {
            for(i=1; i<4; i++) {
                if(!RADEON_BIOS8(tmp + i*2) && i>1) break;
           
                /*Note: our Secondary port (CRT port) 
                  actually uses primary DAC*/
                if(RADEON_BIOS16(tmp + i*2) & 0x01) {
                    if(!info->IsSecondary) {
                        info->DDCType = 
                            (RADEON_BIOS16(tmp + i*2) & 0x0f00) >> 8;
                        break;
                    }
                } else {/*Primary DAC*/
            
                    if(info->IsSecondary || BypassSecondary || !info->HasCRTC2) {
                        info->DDCType = 
                            (RADEON_BIOS16(tmp + i*2) & 0x0f00) >> 8;
                        break;
                    }
                }
            }
        } else {
            /* orignal radeon cards, set it to DDC_VGA, 
               this will not work with AIW, it should be DDC_DVI,
               let it fall back to VBE calls for AIW */
            info->DDCType = DDC_VGA;
        }
d858 6
a863 33
    return TRUE;
}

/* Read PLL parameters from BIOS block.  Default to typical values if there
   is no BIOS. */
static Bool RADEONGetPLLParameters(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr   info = RADEONPTR(pScrn);
    RADEONPLLPtr    pll  = &info->pll;
    CARD16          bios_header;
    CARD16          pll_info_block;

    if (!info->VBIOS) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Video BIOS not detected, using default PLL parameters!\n");
				/* These probably aren't going to work for
				   the card you are using.  Specifically,
				   reference freq can be 29.50MHz,
				   28.63MHz, or 14.32MHz.  YMMV. */
 	/*
	 * these are somewhat sane defaults for Mac boards, we will
	 * need to find a good way of getting these from OpenFirmware
	 */
	pll->reference_freq = 2700;
	pll->reference_div  = 67;
	pll->min_pll_freq   = 12500;
	pll->max_pll_freq   = 35000;
	pll->xclk           = 16615;
    } else {
	bios_header    = RADEON_BIOS16(0x48);
	pll_info_block = RADEON_BIOS16(bios_header + 0x30);
	RADEONTRACE(("Header at 0x%04x; PLL Information at 0x%04x\n",
		     bios_header, pll_info_block));
d865 1
a865 6
	pll->reference_freq = RADEON_BIOS16(pll_info_block + 0x0e);
	pll->reference_div  = RADEON_BIOS16(pll_info_block + 0x10);
	pll->min_pll_freq   = RADEON_BIOS32(pll_info_block + 0x12);
	pll->max_pll_freq   = RADEON_BIOS32(pll_info_block + 0x16);
	pll->xclk           = RADEON_BIOS16(pll_info_block + 0x08);
    }
d868 1
a868 6
	       "PLL parameters: rf=%d rd=%d min=%d max=%d; xclk=%d\n",
	       pll->reference_freq,
	       pll->reference_div,
	       pll->min_pll_freq,
	       pll->max_pll_freq,
	       pll->xclk);
d870 1
a870 1
    return TRUE;
d873 2
a874 2
/* This is called by RADEONPreInit to set up the default visual. */
static Bool RADEONPreInitVisual(ScrnInfoPtr pScrn)
d876 3
a878 1
    RADEONInfoPtr info          = RADEONPTR(pScrn);
d880 36
a915 2
    if(!xf86SetDepthBpp(pScrn, 8, 8, 8, Support32bppFb))
	return FALSE;
d917 1
a917 12
    switch (pScrn->depth) {
    case 8:
    case 15:
    case 16:
    case 24:
	break;
    default:
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Given depth (%d) is not supported by %s driver\n",
		   pScrn->depth, RADEON_DRIVER_NAME);
	return FALSE;
    }
d919 29
a947 1
    xf86PrintDepthBpp(pScrn);
d949 2
a950 8
    info->fifo_slots  = 0;
    info->pix24bpp    = xf86GetBppFromDepth(pScrn, pScrn->depth);
    info->CurrentLayout.bitsPerPixel = pScrn->bitsPerPixel;
    info->CurrentLayout.depth        = pScrn->depth;
    info->CurrentLayout.pixel_bytes  = pScrn->bitsPerPixel / 8;
    info->CurrentLayout.pixel_code   = (pScrn->bitsPerPixel != 16
				       ? pScrn->bitsPerPixel
				       : pScrn->depth);
d952 56
a1007 5
    if (info->pix24bpp == 24) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
	       "Radeon does NOT support 24bpp\n");
	return FALSE;
    }
d1009 2
a1010 6
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Pixel depth = %d bits stored in %d byte%s (%d bpp pixmaps)\n",
	       pScrn->depth,
	       info->CurrentLayout.pixel_bytes,
	       info->CurrentLayout.pixel_bytes > 1 ? "s" : "",
	       info->pix24bpp);
d1012 78
a1089 8

    if (!xf86SetDefaultVisual(pScrn, -1)) return FALSE;

    if (pScrn->depth > 8 && pScrn->defaultVisual != TrueColor) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Default visual (%s) is not supported at depth %d\n",
		   xf86GetVisualName(pScrn->defaultVisual), pScrn->depth);
	return FALSE;
a1090 1
    return TRUE;
d1092 1
d1095 1
a1095 2
/* This is called by RADEONPreInit to handle all color weight issues. */
static Bool RADEONPreInitWeight(ScrnInfoPtr pScrn)
d1097 819
a1915 1
    RADEONInfoPtr info          = RADEONPTR(pScrn);
d1923 1
d1925 2
a1926 1
	rgb defaultWeight = { 0, 0, 0 };
d1935 1
d1941 34
d1976 3
d1981 5
a1985 3
/* This is called by RADEONPreInit to handle config file overrides for things
   like chipset and memory regions.  Also determine memory size and type.
   If memory type ever needs an override, put it in this routine. */
d1988 9
a1996 6
    RADEONInfoPtr   info   = RADEONPTR(pScrn);
    EntityInfoPtr   pEnt   = info->pEnt;
    GDevPtr         dev    = pEnt->device;
    int             offset = 0; /* RAM Type */
    MessageType     from;
    unsigned char   *RADEONMMIO;
d2009 1
a2010 1

a2015 1

d2019 74
a2092 2
	return FALSE;
    }
d2094 9
a2102 4
    xf86DrvMsg(pScrn->scrnIndex, from,
	       "Chipset: \"%s\" (ChipID = 0x%04x)\n",
	       pScrn->chipset,
	       info->Chipset);
d2104 37
d2142 4
a2145 27
    info->IsM6 = FALSE;
    switch (info->Chipset) 
    {
   	case PCI_CHIP_RADEON_LY:
   	case PCI_CHIP_RADEON_LZ:
            info->IsM6 = TRUE;
	case PCI_CHIP_RADEON_QY:
   	case PCI_CHIP_RADEON_QZ:
            /*VE or M6 has secondary CRTC*/
            info->HasCRTC2 = TRUE;  
            break;
   	case PCI_CHIP_R200_QL:
   	case PCI_CHIP_R200_QN:
   	case PCI_CHIP_R200_QO:
   	case PCI_CHIP_R200_Ql:
	case PCI_CHIP_R200_BB:
            /*R200 has secondary CRTC*/
            info->HasCRTC2 = TRUE;  
            info->IsR200 = TRUE;
            break;
   	case PCI_CHIP_RV200_QW:   /* RV200 desktop */
   	case PCI_CHIP_RADEON_LW:  /* M7 */
            info->HasCRTC2 = TRUE;  
            info->IsRV200 = TRUE;
            break;
        default: 
            info->HasCRTC2 = FALSE;  
d2150 2
a2151 2
    from             = X_PROBED;
    info->LinearAddr = info->PciInfo->memBase[0] & 0xfc000000;
d2155 1
a2155 1
		   "Linear address override, using 0x%08x instead of 0x%08x\n",
a2167 17
				/* MMIO registers */
    from             = X_PROBED;
    info->MMIOAddr   = info->PciInfo->memBase[2] & 0xffffff00;
    if (dev->IOBase) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "MMIO address override, using 0x%08x instead of 0x%08x\n",
		   dev->IOBase,
		   info->MMIOAddr);
	info->MMIOAddr = dev->IOBase;
	from           = X_CONFIG;
    } else if (!info->MMIOAddr) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid MMIO address\n");
	return FALSE;
    }
    xf86DrvMsg(pScrn->scrnIndex, from,
	       "MMIO registers at 0x%08lx\n", info->MMIOAddr);

d2173 1
a2173 1
		   "BIOS address override, using 0x%08x instead of 0x%08x\n",
a2183 3
    RADEONMapMMIO(pScrn);
    RADEONMMIO               = info->MMIO;

d2188 26
d2216 24
a2239 20
    
    /* some production boards of m6 will return 0 if it's 8 MB */
    if(pScrn->videoRam == 0) pScrn->videoRam = 8192;
        
    if(info->IsSecondary)
    {  
	/*FIXME: For now, split FB into two equal sections. This should
          be able to be adjusted by user with a config option*/
        DevUnion* pPriv;
        RADEONEntPtr pRADEONEnt;
        RADEONInfoPtr   info1;
        pPriv = xf86GetEntityPrivate(pScrn->entityList[0], 
              gRADEONEntityIndex);
        pRADEONEnt = pPriv->ptr;
        pScrn->videoRam /= 2;
        pRADEONEnt->pPrimaryScrn->videoRam = pScrn->videoRam;
        info1 = RADEONPTR(pRADEONEnt->pPrimaryScrn);
        info1->FbMapSize  = pScrn->videoRam * 1024;
        info->LinearAddr += pScrn->videoRam * 1024;
    }
a2242 2
    RADEONMMIO               = NULL;
    RADEONUnmapMMIO(pScrn);
d2244 1
a2244 7
				/* RAM */
    switch (info->MemCntl >> 30) {
    case 0:            offset = 0; break; /*  64-bit SDR SDRAM */
    case 1:            offset = 1; break; /*  64-bit DDR SDRAM */
    default:           offset = 0;
    }
    info->ram = &RADEONRAM[offset];
d2246 1
a2246 2
    if (dev->videoRam)
    {
d2257 1
a2257 1
	       "VideoRAM: %d kByte (%s)\n", pScrn->videoRam, info->ram->name);
d2261 38
a2298 1
    if (xf86ReturnOptValBool(info->Options, OPTION_IS_PCI, FALSE)) {
d2300 66
a2365 1
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Forced into PCI-only mode\n");
d2367 776
a3142 20
	switch (info->Chipset) {
#if 0
	case PCI_CHIP_RADEON_XX: info->IsPCI = TRUE;  break;
#endif
	case PCI_CHIP_RADEON_QY:
	case PCI_CHIP_RADEON_QZ:
	case PCI_CHIP_RADEON_LW:
	case PCI_CHIP_RADEON_LY:
	case PCI_CHIP_RADEON_LZ:
	case PCI_CHIP_RADEON_QD:
	case PCI_CHIP_RADEON_QE:
	case PCI_CHIP_RADEON_QF:
	case PCI_CHIP_RADEON_QG:
	case PCI_CHIP_R200_QL:
	case PCI_CHIP_R200_QN:
	case PCI_CHIP_R200_QO:
	case PCI_CHIP_R200_Ql:
	case PCI_CHIP_R200_BB:
	case PCI_CHIP_RV200_QW:
	default:                 info->IsPCI = FALSE; break;
a3144 1
#endif
d3146 19
a3164 2
    return TRUE;
}
d3166 10
a3175 7
static void
RADEONI2CGetBits(I2CBusPtr b, int *Clock, int *data)
{
    ScrnInfoPtr   pScrn       = xf86Screens[b->scrnIndex];
    RADEONInfoPtr info = RADEONPTR(pScrn);
    unsigned long val;
    unsigned char *RADEONMMIO = info->MMIO;
d3177 36
a3212 2
    /* Get the result. */
    val = INREG(info->DDCReg);
d3214 20
a3233 4
    *Clock = (val & RADEON_GPIO_Y_1) != 0;
    *data  = (val & RADEON_GPIO_Y_0) != 0;

}
d3235 6
a3240 7
static void
RADEONI2CPutBits(I2CBusPtr b, int Clock, int data)
{
    ScrnInfoPtr   pScrn       = xf86Screens[b->scrnIndex];
    RADEONInfoPtr info = RADEONPTR(pScrn);
    unsigned long val;
    unsigned char *RADEONMMIO = info->MMIO;
d3242 4
a3245 6
    val = INREG(info->DDCReg) & 
              (CARD32)~(RADEON_GPIO_EN_0 | RADEON_GPIO_EN_1);
    val |= (Clock ? 0:RADEON_GPIO_EN_1);
    val |= (data ? 0:RADEON_GPIO_EN_0);
    OUTREG(info->DDCReg, val);
}
d3247 1
d3249 15
a3263 4
static Bool
RADEONI2cInit(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
d3265 5
a3269 2
    info->pI2CBus = xf86CreateI2CBusRec();
    if(!info->pI2CBus) return FALSE;
d3271 20
a3290 5
    info->pI2CBus->BusName    = "DDC";
    info->pI2CBus->scrnIndex  = pScrn->scrnIndex;
    info->pI2CBus->I2CPutBits = RADEONI2CPutBits;
    info->pI2CBus->I2CGetBits = RADEONI2CGetBits;
    info->pI2CBus->AcknTimeout = 5;
d3292 2
a3293 16
    switch(info->DDCType)
    {
        case DDC_MONID:
           info->DDCReg = RADEON_GPIO_MONID;
           break;
        case DDC_DVI:
           info->DDCReg = RADEON_GPIO_DVI_DDC;
           break;
        case DDC_VGA:
           info->DDCReg = RADEON_GPIO_VGA_DDC;
           break;
        case DDC_CRT2:
           info->DDCReg = RADEON_GPIO_CRT2_DDC;
           break;
        default:
           return FALSE;
d3296 1
a3296 3
    if (!xf86I2CBusInit(info->pI2CBus)) return FALSE;
    return TRUE;
}
d3298 4
a3301 4
static void RADEONPreInitDDC(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    /*vbeInfoPtr pVbe;*/
d3303 8
a3310 10
    info->ddc1 = FALSE;
    info->ddc_bios = FALSE;
    if (!xf86LoadSubModule(pScrn, "ddc"))
    {
        info->ddc2 = FALSE;
    }
    else
    {
    xf86LoaderReqSymLists(ddcSymbols, NULL);
        info->ddc2 = TRUE;
a3312 1
    /*info->ddc1 = TRUE;*/
d3314 1
a3314 11
    /* - DDC can use I2C bus */
    /* Load I2C if we have the code to use it */
    if(info->ddc2)
    {
        if ( xf86LoadSubModule(pScrn, "i2c") )
        {
            xf86LoaderReqSymLists(i2cSymbols,NULL);
            info->ddc2 = RADEONI2cInit(pScrn);
        }
        else info->ddc2 = FALSE;
    }
d3317 4
a3320 2
static xf86MonPtr
RADEONDoDDC(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
d3322 35
a3356 3
    RADEONInfoPtr info = RADEONPTR(pScrn);
    xf86MonPtr MonInfo = NULL;
    unsigned char *RADEONMMIO;
d3358 17
d3376 19
a3394 20
    /**
       We'll use DDC2, BIOS EDID can only detect the monitor 
       connected to one port. For VE, BIOS EDID detects the
       monitor connected to DVI port by default. If no monitor 
       their, it will try CRT port   
    */
 
    /* Read and output monitor info using DDC2 over I2C bus */
    if (info->pI2CBus && info->ddc2)
    {
        if (!RADEONMapMMIO(pScrn)) return NULL;
        RADEONMMIO = info->MMIO;
        /*OUTREG(RADEON_I2C_CNTL_1, 0);
        OUTREG(RADEON_DVI_I2C_CNTL_1, 0);*/
        OUTREG(info->DDCReg, INREG(info->DDCReg) &
                 (CARD32)~(RADEON_GPIO_A_0 | RADEON_GPIO_A_1));

        MonInfo = xf86DoEDID_DDC2(pScrn->scrnIndex, info->pI2CBus);
        if(!MonInfo) info->ddc2 = FALSE;
        RADEONUnmapMMIO(pScrn);
d3397 3
a3399 30
    if(!MonInfo)
    {
        if (xf86LoadSubModule(pScrn, "vbe"))
        {
            vbeInfoPtr pVbe;
  	pVbe = VBEInit(pInt10, info->pEnt->index);
            if (pVbe)
            { 
                MonInfo = vbeDoEDID(pVbe,NULL);
                info->ddc_bios = TRUE;
            }
            else
                info->ddc_bios = FALSE;
        }
    }
  
/***Not used for now
    if(!MonInfo && info->ddc1)
    {
        if (info->ddc1Read && info->DDC1SetSpeed)
        {
            MonInfo = xf86DoEDID_DDC1(pScrn->scrnIndex,
	                              info->DDC1SetSpeed,
				      info->ddc1Read);
        }
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "DDC Monitor info: %p\n", MonInfo);
        xf86PrintEDID( MonInfo );
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "end of DDC Monitor info\n\n");
    }
***/
d3401 4
a3404 7
    if(MonInfo)
    {
	if(info->ddc2)
            xf86DrvMsg(pScrn->scrnIndex, X_INFO, "I2C EDID Info:\n");
        else if(info->ddc_bios)
            xf86DrvMsg(pScrn->scrnIndex, X_INFO, "BIOS  EDID Info:\n");
        else return NULL;
d3406 4
a3409 5
        xf86PrintEDID(MonInfo);
        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "End of DDC Monitor info\n\n");

        xf86SetDDCproperties(pScrn, MonInfo);
        return MonInfo;
a3410 2
    else return NULL;
}
d3412 51
a3462 19
/*********** 
   xfree's xf86ValidateModes routine deosn't work well with DFPs
   here is our own validation routine. All modes between 
   640<=XRes<=MaxRes and 480<=YRes<=MaxYRes will be permitted. 
************/ 
static int RADEONValidateFPModes(ScrnInfoPtr pScrn)
{
    int i, j, count=0, width, height;
    RADEONInfoPtr info = RADEONPTR(pScrn);
    DisplayModePtr last = NULL, new = NULL, first = NULL;

    /* Free any allocated modes during configuration. We don't need them*/
    while (pScrn->modes)
    {
	    xf86DeleteMode(&pScrn->modes, pScrn->modes);
    }
    while (pScrn->modePool)
    {
	    xf86DeleteMode(&pScrn->modePool, pScrn->modePool);
d3465 30
a3494 2
    pScrn->virtualX = pScrn->display->virtualX;
    pScrn->virtualY = pScrn->display->virtualY;
d3496 21
a3516 7
    /* If no mode specified in config, we use native resolution*/
    if(!pScrn->display->modes[0])
    {
        pScrn->display->modes[0] = xnfalloc(16);
        sprintf(pScrn->display->modes[0], "%dx%d",
               info->PanelXRes, info->PanelYRes);
    }
d3518 1
a3518 4
    for(i=0; pScrn->display->modes[i] != NULL; i++)
    {
        if (sscanf(pScrn->display->modes[i], "%dx%d", &width, &height) == 2)
        {
d3520 5
a3524 16
            if(width < 640 || width > info->PanelXRes || 
               height < 480 || height > info->PanelYRes)
            {
                xf86DrvMsg(pScrn->scrnIndex, X_WARNING, 
                    "Mode %s is out of range.\n"
                    "Valid mode should be between 640x480-%dx%d\n",
                    pScrn->display->modes[i], info->PanelXRes, info->PanelYRes);
                continue;
            }           

            new = xnfcalloc(1, sizeof(DisplayModeRec));
            new->prev = last;
            new->name = xnfalloc(strlen(pScrn->display->modes[i]) + 1);
            strcpy(new->name, pScrn->display->modes[i]);
            new->HDisplay = new->CrtcHDisplay = width;
            new->VDisplay = new->CrtcVDisplay = height;
d3526 8
a3533 28
            if(info->HasEDID)
            {
                xf86MonPtr ddc = pScrn->monitor->DDC;
                for(j=0; j<DET_TIMINGS; j++)
                {
                    /*We use native mode clock only*/
                    if(ddc->det_mon[j].type == 0)
                        new->Clock = ddc->det_mon[j].section.d_timings.clock / 1000;
                }
            } else
                new->Clock = info->DotClock;

            if(new->prev) new->prev->next = new;
            last = new;
            if(!first) first = new;
            pScrn->display->virtualX =
            pScrn->virtualX = MAX(pScrn->virtualX, width);
            pScrn->display->virtualY =
            pScrn->virtualY = MAX(pScrn->virtualY, height);
            count++;
        }
        else
        {
            xf86DrvMsg(pScrn->scrnIndex, X_WARNING, 
                "Mode name %s is invalid\n", pScrn->display->modes[i]); 
            continue;
        }
   }
d3535 3
a3537 23
   if(last)
   {
       last->next = first;
       first->prev = last;
       pScrn->modes = first;

       /*FIXME: May need to validate line pitch here*/
       {
           int dummy = 0;
           switch(pScrn->depth / 8)
           {
              case 1:
                  dummy = 128 - pScrn->virtualX % 128;
                  break;
              case 2:
                  dummy = 32 - pScrn->virtualX % 32;
                  break;
              case 3:
              case 4:
                  dummy = 16 - pScrn->virtualX % 16;
           }
           pScrn->displayWidth = pScrn->virtualX + dummy;
       }
d3539 4
a3542 1
   }
d3544 13
a3556 2
    return count;
}
d3558 24
a3581 114
/* This is called by RADEONPreInit to initialize gamma correction. */
static Bool RADEONPreInitGamma(ScrnInfoPtr pScrn)
{
    Gamma zeros = { 0.0, 0.0, 0.0 };

    if (!xf86SetGamma(pScrn, zeros)) return FALSE;
    return TRUE;
}

static void RADEONSetSyncRangeFromEdid(ScrnInfoPtr pScrn, int flag)
{
    int i;
    xf86MonPtr ddc = pScrn->monitor->DDC;
    if(flag)  /*HSync*/
    {
        for(i=0; i<4; i++)
        {
            if(ddc->det_mon[i].type == DS_RANGES)
            {
                pScrn->monitor->nHsync = 1;
                pScrn->monitor->hsync[0].lo = 
                    ddc->det_mon[i].section.ranges.min_h;
                pScrn->monitor->hsync[0].hi = 
                    ddc->det_mon[i].section.ranges.max_h;
                return;
            }
        }
        /*if no sync ranges detected in detailed timing table,
          let's try to derive them from supported VESA modes
          Are we doing too much here!!!? 
        **/
        i = 0;
        if(ddc->timings1.t1 & 0x02) /*800x600@@56*/
        {
            pScrn->monitor->hsync[i].lo = 
                pScrn->monitor->hsync[i].hi = 35.2;
            i++;
        }       
        if(ddc->timings1.t1 & 0x04) /*640x480@@75*/
        {
            pScrn->monitor->hsync[i].lo = 
                pScrn->monitor->hsync[i].hi = 37.5;
            i++;
        }       
        if((ddc->timings1.t1 & 0x08) || (ddc->timings1.t1 & 0x01))
        {
            pScrn->monitor->hsync[i].lo = 
                pScrn->monitor->hsync[i].hi = 37.9;
            i++;
        }       
        if(ddc->timings1.t2 & 0x40)
        {
            pScrn->monitor->hsync[i].lo = 
                pScrn->monitor->hsync[i].hi = 46.9;
            i++;
        }
        if((ddc->timings1.t2 & 0x80) || (ddc->timings1.t2 & 0x08))
        {
            pScrn->monitor->hsync[i].lo = 
                pScrn->monitor->hsync[i].hi = 48.1;
            i++;
        }       
        if(ddc->timings1.t2 & 0x04)
        {
            pScrn->monitor->hsync[i].lo = 
                pScrn->monitor->hsync[i].hi = 56.5;
            i++;
        }       
        if(ddc->timings1.t2 & 0x02)
        {
            pScrn->monitor->hsync[i].lo = 
                pScrn->monitor->hsync[i].hi = 60.0;
            i++;
        }       
        if(ddc->timings1.t2 & 0x01)
        {
            pScrn->monitor->hsync[i].lo = 
                pScrn->monitor->hsync[i].hi = 64.0;
            i++;
        }
        pScrn->monitor->nHsync = i;
    }
    else      /*Vrefresh*/
    {
        for(i=0; i<4; i++)
        {
            if(ddc->det_mon[i].type == DS_RANGES)
            {
                pScrn->monitor->nVrefresh = 1;
                pScrn->monitor->vrefresh[0].lo = 
                    ddc->det_mon[i].section.ranges.min_v;
                pScrn->monitor->vrefresh[0].hi = 
                    ddc->det_mon[i].section.ranges.max_v;
                return;
            }
        }
        i = 0;
        if(ddc->timings1.t1 & 0x02) /*800x600@@56*/
        {        
            pScrn->monitor->vrefresh[i].lo = 
                pScrn->monitor->vrefresh[i].hi = 56;
            i++;
        }
        if((ddc->timings1.t1 & 0x01) || (ddc->timings1.t2 & 0x08))
        {        
            pScrn->monitor->vrefresh[i].lo = 
                pScrn->monitor->vrefresh[i].hi = 60;
            i++;
        }
        if(ddc->timings1.t2 & 0x04)
        {        
            pScrn->monitor->vrefresh[i].lo = 
                pScrn->monitor->vrefresh[i].hi = 70;
            i++;
a3582 16
        if((ddc->timings1.t1 & 0x08) || (ddc->timings1.t2 & 0x80))
        {        
            pScrn->monitor->vrefresh[i].lo = 
                pScrn->monitor->vrefresh[i].hi = 72;
            i++;
        }
        if((ddc->timings1.t1 & 0x04) || (ddc->timings1.t2 & 0x40)
           || (ddc->timings1.t2 & 0x02) || (ddc->timings1.t2 & 0x01))
        {        
            pScrn->monitor->vrefresh[i].lo = 
                pScrn->monitor->vrefresh[i].hi = 75;
            i++;
        }
        pScrn->monitor->nVrefresh = i;
    }
}
d3584 6
a3589 11
/* This is called by RADEONPreInit to validate modes and compute parameters
   for all of the valid modes. */
static Bool RADEONPreInitModes(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    ClockRangePtr clockRanges;
    int           modesFound;
    char          *mod = NULL;
#ifndef USE_FB
    const char    *Sym = NULL;
#endif
d3591 13
a3603 29
    /*We'll use our own mode validation routine for DFP/LCD, since
      xf86ValidateModes is not working well with the DFP/LCD modes 
      'stretched' from their native mode.*/
    if(info->DisplayType == MT_CRT || info->UseCRT)
    {
				/* Get mode information */
    pScrn->progClock                   = TRUE;
    clockRanges                        = xnfcalloc(sizeof(*clockRanges), 1);
    clockRanges->next                  = NULL;
    clockRanges->minClock              = info->pll.min_pll_freq;
    clockRanges->maxClock              = info->pll.max_pll_freq * 10;
    clockRanges->clockIndex            = -1;
       
	clockRanges->interlaceAllowed  = TRUE;
	clockRanges->doubleScanAllowed = TRUE;
        
        if(info->HasEDID)
        {
            /*if we still don't know sync range yet, let's try EDID.
              Note that, since we can have dual heads, the Xconfigurator
              may not be able to probe both monitors correctly through
              vbe probe function (RADEONProbeDDC). Here we provide an
              additional way to auto-detect sync ranges if they haven't
              been added to XF86Config manually.
            **/
            if(pScrn->monitor->nHsync <= 0)
                 RADEONSetSyncRangeFromEdid(pScrn, 1);
            if(pScrn->monitor->nVrefresh <= 0)
                 RADEONSetSyncRangeFromEdid(pScrn, 0);
a3605 31

    modesFound = xf86ValidateModes(pScrn,
				   pScrn->monitor->Modes,
				   pScrn->display->modes,
				   clockRanges,
				   NULL,        /* linePitches */
				   8 * 64,      /* minPitch */
				   8 * 1024,    /* maxPitch */
				   64 * pScrn->bitsPerPixel, /* pitchInc */
				   128,         /* minHeight */
				   2048,        /* maxHeight */
				   pScrn->display->virtualX,
				   pScrn->display->virtualY,
				   info->FbMapSize,
				   LOOKUP_BEST_REFRESH);

        if(modesFound < 1 && info->FBDev)
        {
	fbdevHWUseBuildinMode(pScrn);
	pScrn->displayWidth = pScrn->virtualX; /* FIXME: might be wrong */
	modesFound = 1;
    }

       if(modesFound == -1) return FALSE;

    xf86PruneDriverModes(pScrn);
       if(!modesFound || !pScrn->modes) 
       {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes found\n");
	return FALSE;
    }
a3606 3
    }
    else
    {
d3608 17
a3624 12
        /*DFP/LCD mode validation routine*/
        modesFound = RADEONValidateFPModes(pScrn);
        if(modesFound < 1) 
        {
            xf86DrvMsg(pScrn->scrnIndex, X_ERROR, 
                 "No valid mode found for this DFP/LCD\n");
            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                 "If you have an analog monitor attached but no DFP/LCD try"
                 "specifying\n\t'Option \"CrtScreen\"' in your X server"
                 "config file.\n");
            return FALSE;
        }
d3634 1
a3634 9
#ifdef USE_FB
    mod = "fb";
#else
    switch (pScrn->bitsPerPixel) {
    case  8: mod = "cfb";   Sym = "cfbScreenInit";   break;
    case 16: mod = "cfb16"; Sym = "cfb16ScreenInit"; break;
    case 32: mod = "cfb32"; Sym = "cfb32ScreenInit"; break;
    }
#endif
a3635 3
    if (mod && !xf86LoadSubModule(pScrn, mod)) return FALSE;

#ifdef USE_FB
a3636 3
#else
    xf86LoaderReqSymbols(Sym, NULL);
#endif
d3644 1
a3644 1
/* This is called by RADEONPreInit to initialize the hardware cursor. */
d3647 1
a3647 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
d3656 1
a3656 1
/* This is called by RADEONPreInit to initialize hardware acceleration. */
d3659 2
a3660 1
    RADEONInfoPtr info = RADEONPTR(pScrn);
d3663 15
a3677 1
	if (!xf86LoadSubModule(pScrn, "xaa")) return FALSE;
d3680 2
d3687 1
a3687 1
    RADEONInfoPtr   info = RADEONPTR(pScrn);
a3698 1

d3702 1
a3702 1
    RADEONInfoPtr   info = RADEONPTR(pScrn);
d3712 1
a3712 1
    info->agpSize       = RADEON_DEFAULT_AGP_SIZE;
d3715 2
a3716 1
    info->agpTexSize    = RADEON_DEFAULT_AGP_TEX_SIZE;
d3732 8
a3739 16
	if (xf86GetOptValInteger(info->Options,
				 OPTION_AGP_SIZE, (int *)&(info->agpSize))) {
	    switch (info->agpSize) {
	    case 4:
	    case 8:
	    case 16:
	    case 32:
	    case 64:
	    case 128:
	    case 256:
		break;
	    default:
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Illegal AGP size: %d MB\n", info->agpSize);
		return FALSE;
	    }
d3741 13
d3755 4
a3758 8
	if (xf86GetOptValInteger(info->Options,
				 OPTION_RING_SIZE, &(info->ringSize))) {
	    if (info->ringSize < 1 || info->ringSize >= (int)info->agpSize) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Illegal ring buffer size: %d MB\n",
			   info->ringSize);
		return FALSE;
	    }
d3760 1
d3762 7
a3768 16
	if (xf86GetOptValInteger(info->Options,
				 OPTION_BUFFER_SIZE, &(info->bufSize))) {
	    if (info->bufSize < 1 || info->bufSize >= (int)info->agpSize) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Illegal vertex/indirect buffers size: %d MB\n",
			   info->bufSize);
		return FALSE;
	    }
	    if (info->bufSize > 2) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Illegal vertex/indirect buffers size: %d MB\n",
			   info->bufSize);
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Clamping vertex/indirect buffers size to 2 MB\n");
		info->bufSize = 2;
	    }
d3770 1
d3772 3
a3774 2
	if (info->ringSize + info->bufSize + info->agpTexSize >
	    (int)info->agpSize) {
d3776 2
a3777 1
		       "Buffers are too big for requested AGP space\n");
d3780 9
d3790 5
a3794 1
	info->agpTexSize = info->agpSize - (info->ringSize + info->bufSize);
d3797 2
d3813 13
a3825 86
    return TRUE;
}
#endif

static void
RADEONProbeDDC(ScrnInfoPtr pScrn, int indx)
{
    vbeInfoPtr pVbe;
    if (xf86LoadSubModule(pScrn, "vbe"))
    {
	pVbe = VBEInit(NULL,indx);
	ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
    }
}

/*This funtion is used to reverse calculate 
  panel information from register settings in VGA mode.
  More graceful way is to use EDID information... if it can be detected.
  This way may be better than directly probing BIOS image. Because
  BIOS image could change from version to version, while the 
  registers should always(?) contain right information, otherwise
  the VGA mode display will not be correct. Well, if someone  
  messes up these registers before our driver is loaded, we'll be in 
  trouble...*/
static Bool RadeonGetDFPInfo(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info  = RADEONPTR(pScrn);

    char *s;
    unsigned long r;
    unsigned short a, b;	
    unsigned char* RADEONMMIO;
    unsigned long mapped;

    if(info->HasEDID)
    {
        int i;
        xf86MonPtr ddc = pScrn->monitor->DDC;
        for(i=0; i<4; i++)
        {
            if(ddc->det_mon[i].type == 0)
            {
                info->PanelXRes =
                    ddc->det_mon[i].section.d_timings.h_active;
                info->PanelYRes =
                    ddc->det_mon[i].section.d_timings.v_active;

                info->HOverPlus =
                    ddc->det_mon[i].section.d_timings.h_sync_off;
                info->HSyncWidth = 
                    ddc->det_mon[i].section.d_timings.h_sync_width;
                info->HBlank =
                    ddc->det_mon[i].section.d_timings.h_blanking;
                info->VOverPlus =
                    ddc->det_mon[i].section.d_timings.v_sync_off;
                info->VSyncWidth = 
                    ddc->det_mon[i].section.d_timings.v_sync_width;
                info->VBlank =
                    ddc->det_mon[i].section.d_timings.v_blanking;

                return TRUE;    
            }  
        }
    }

    /* in case both EDID and BIOS probings failed, we'll try to get
       panel information from the registers. This will depends on
       how the registers are set up by bios, not very reliable*/
    mapped = RADEONMapMem(pScrn);
    RADEONMMIO = info->MMIO;

    if(info->PanelXRes==0 || info->PanelYRes==0) { 
    r = INREG(RADEON_FP_VERT_STRETCH);
    if(r & 0x08000000) {
        r &= 0x00fff000;
        info->PanelYRes = (unsigned short)(r >> 0x0c) + 1;
    } else {
        info->PanelYRes = (unsigned short)(((float)(INREG(RADEON_FP_CRTC_V_TOTAL_DISP >> 16) + 1.0) 
                           * 4096.0 / (float) (r & 0x00000fff)) + 0.5);
    }

    r = INREG(RADEON_FP_HORZ_STRETCH);
    if(r & 0x08000000) {
        r &= 0x01ff0000;
        info->PanelXRes = (unsigned short)(r >> 0x10) + 1;
		info->PanelXRes *= 8;
d3827 1
a3827 21
        info->PanelXRes = (unsigned short)(((float)(INREG(RADEON_FP_CRTC_H_TOTAL_DISP >> 16) + 1.0) * 8.0
                           * 4096.0 / (float) (r & 0x0000ffff)) + 0.5);
    }
    
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
        "Detected panel size from registers: %dx%d\n", info->PanelXRes, info->PanelYRes);

    if ((s = xf86GetOptValString(info->Options, OPTION_PANEL_SIZE))) {
        if (sscanf(s, "%dx%d", &info->PanelXRes, &info->PanelYRes) == 2) {
            xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                "Panel size: %dx%d defined in config file is used\n", 
                info->PanelXRes, info->PanelYRes);
        }
	}
    }

    if (info->PanelXRes == 0 || info->PanelYRes == 0) {
        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                "Failed to detect the panel size.\n");
		return FALSE;
    }
d3829 3
a3831 25
    if(info->HBlank == 0 || info->VBlank == 0) {
    r = INREG(RADEON_FP_CRTC_H_TOTAL_DISP);
    a = (r & RADEON_FP_CRTC_H_TOTAL_MASK) + 4;
    b = (r & 0x01FF0000) >> RADEON_FP_CRTC_H_DISP_SHIFT;
    info->HBlank = (a - b + 1) * 8;

    r = INREG(RADEON_FP_H_SYNC_STRT_WID);
    info->HOverPlus = 
        (unsigned short)((r & RADEON_FP_H_SYNC_STRT_CHAR_MASK)
        >> RADEON_FP_H_SYNC_STRT_CHAR_SHIFT) - b - 1;
    info->HOverPlus *= 8;
    info->HSyncWidth =    
        (unsigned short)((r & RADEON_FP_H_SYNC_WID_MASK)
        >> RADEON_FP_H_SYNC_WID_SHIFT);
    info->HSyncWidth *= 8;
    r = INREG(RADEON_FP_CRTC_V_TOTAL_DISP);
    a = (r & RADEON_FP_CRTC_V_TOTAL_MASK) + 1;
    b = (r & RADEON_FP_CRTC_V_DISP_MASK) >> RADEON_FP_CRTC_V_DISP_SHIFT;
    info->VBlank = a - b /*+ 24*/;
    
    r = INREG(RADEON_FP_V_SYNC_STRT_WID);
    info->VOverPlus = (unsigned short)(r & RADEON_FP_V_SYNC_STRT_MASK)
                 - b + 1;
    info->VSyncWidth = (unsigned short)((r & RADEON_FP_V_SYNC_WID_MASK)
                 >> RADEON_FP_V_SYNC_WID_SHIFT);
d3834 2
a3835 1
    if(mapped) RADEONUnmapMem(pScrn);
d3839 6
d3846 5
d3852 1
a3852 1
/* RADEONPreInit is called once at server startup. */
d3855 4
a3858 32
    RADEONInfoPtr    info;
    xf86Int10InfoPtr pInt10 = NULL;
#ifdef __alpha__
    CARD32 save1, save2;
#endif

    /*
     * Tell the loader about symbols from other modules that this module might
     * refer to.
     */
    xf86LoaderRefSymLists(vgahwSymbols,
#ifdef USE_FB
		      fbSymbols,
#else
		      cfbSymbols,
#endif
		      xaaSymbols,
#if 0
		      xf8_32bppSymbols,
#endif
		      ramdacSymbols,
#ifdef XF86DRI
		      drmSymbols,
		      driSymbols,
#endif
		      fbdevHWSymbols,
		      vbeSymbols,
		      int10Symbols,
		      ddcSymbols,
		      /* i2csymbols, */
		      /* shadowSymbols, */
		      NULL);
d3867 7
a3873 1
    info->pEnt         = xf86GetEntityInfo(pScrn->entityList[0]);
d3876 52
a3927 1
    RADEONPreInt10Save(pScrn, &save1, &save2);
d3929 6
a3934 28
    if(xf86IsEntityShared(pScrn->entityList[0]))
    {
        if(xf86IsPrimInitDone(pScrn->entityList[0]))
        {
            DevUnion* pPriv;
            RADEONEntPtr pRADEONEnt;
            info->IsSecondary = TRUE;
            pPriv = xf86GetEntityPrivate(pScrn->entityList[0], 
                    gRADEONEntityIndex);
            pRADEONEnt = pPriv->ptr;
            if(pRADEONEnt->BypassSecondary) return FALSE;
            pRADEONEnt->pSecondaryScrn = pScrn;
        }
        else
        {
            DevUnion* pPriv;
            RADEONEntPtr pRADEONEnt;
            xf86SetPrimInitDone(pScrn->entityList[0]);
            pPriv = xf86GetEntityPrivate(pScrn->entityList[0], 
                    gRADEONEntityIndex);
            pRADEONEnt = pPriv->ptr;
            pRADEONEnt->pPrimaryScrn = pScrn;
            pRADEONEnt->IsDRIEnabled = FALSE;
            pRADEONEnt->BypassSecondary = FALSE;
            pRADEONEnt->HasSecondary = FALSE;
            pRADEONEnt->RestorePrimary = FALSE;
            pRADEONEnt->IsSecondaryRestored = FALSE;
        }
d3937 1
a3937 2
    if (flags & PROBE_DETECT) 
    {
d3939 2
a3940 1
	RADEONPostInt10Check(pScrn, save1, save2);
d3946 1
a3946 2
    if (!vgaHWGetHWRec(pScrn))
    {
d3948 1
a3948 1
	return FALSE;
a3952 5
    info->PciInfo      = xf86GetPciInfoForEntity(info->pEnt->index);
    info->PciTag       = pciTag(info->PciInfo->bus,
				info->PciInfo->device,
				info->PciInfo->func);

d3959 2
a3960 2
    if (xf86RegisterResources(info->pEnt->index, 0, ResExclusive)) 
        goto fail;
d3962 4
a3965 1
    pScrn->racMemFlags = RAC_FB | RAC_COLORMAP | RAC_CURSOR;
d3968 2
a3969 1
    if (!RADEONPreInitVisual(pScrn))    goto fail;
d3974 3
a3976 1
    if (!(info->Options = xalloc(sizeof(RADEONOptions))))     goto fail;
d3980 2
a3981 1
    if (!RADEONPreInitWeight(pScrn))    goto fail;
d3983 6
a3988 4
    if (xf86ReturnOptValBool(info->Options, OPTION_FBDEV, FALSE)) {
	info->FBDev = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		   "Using framebuffer device\n");
d3991 10
a4000 8
    info->UseCRT = FALSE;
    
    /*This option is used to force the ONLY DEVICE in XFConfig to
      use CRT port, instead of default DVI port*/
    if (xf86ReturnOptValBool(info->Options, OPTION_CRT_SCREEN, FALSE)) 
    {
        if(!xf86IsEntityShared(pScrn->entityList[0]))
	    info->UseCRT = TRUE;
d4003 19
a4021 9
    if (info->FBDev) 
    {
	/* check for linux framebuffer device */
	if (!xf86LoadSubModule(pScrn, "fbdevhw")) return FALSE;
	xf86LoaderReqSymLists(fbdevHWSymbols, NULL);
	if (!fbdevHWInit(pScrn, info->PciInfo, NULL)) return FALSE;
	pScrn->SwitchMode    = fbdevHWSwitchMode;
	pScrn->AdjustFrame   = fbdevHWAdjustFrame;
	pScrn->ValidMode     = fbdevHWValidMode;
d4025 2
a4026 1
	if (!RADEONPreInitInt10(pScrn, &pInt10)) goto fail;
d4028 1
a4028 1
    RADEONPostInt10Check(pScrn, save1, save2);
d4030 2
a4031 1
    if (!RADEONPreInitConfig(pScrn))             goto fail;
d4033 1
a4033 9
#if !defined(__powerpc__)
    if (!RADEONGetBIOSParameters(pScrn, pInt10)) goto fail;
#else
    /*
     * force type to CRT since we currently can't read BIOS to
     * tell us what kind of heads we have
     */
    info->DisplayType = MT_CRT;
#endif
d4035 2
a4036 3
    RADEONPreInitDDC(pScrn);
    info->HasEDID =
        ((pScrn->monitor->DDC = RADEONDoDDC(pScrn, pInt10)) ? TRUE:FALSE);
d4038 2
a4039 3
    if((info->DisplayType == MT_DFP) || 
       (info->DisplayType == MT_LCD))
        if(!RadeonGetDFPInfo(pScrn)) goto fail;
d4041 1
a4041 1
    if (!RADEONGetPLLParameters(pScrn))  goto fail;
d4045 1
a4045 1
    if (!RADEONPreInitModes(pScrn))              goto fail;
d4054 1
d4056 1
a4056 2
    if (info->VBIOS)
    {
d4065 3
d4069 2
a4070 2
	"For information on using the multimedia capabilities\n of this"
	" adapter, please see http://gatos.sf.net.\n");
d4076 4
a4079 1

d4081 1
a4081 2
    if (info->VBIOS)
    {
d4091 5
d4097 1
d4101 1
a4101 1
/* Load a palette. */
d4105 1
a4105 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d4107 61
a4167 41
    int           i;
    int           idx, j;
    unsigned char r, g, b;

    /* If the second monitor is connected, we also 
       need to deal with the secondary palette*/
    if (info->IsSecondary) j = 1;
    else j = 0;
    
    PAL_SELECT(j);

    if (info->CurrentLayout.depth == 15) {
	/* 15bpp mode.  This sends 32 values. */
	for (i = 0; i < numColors; i++) {
	    idx = indices[i];
	    r   = colors[idx].red;
	    g   = colors[idx].green;
	    b   = colors[idx].blue;
	    RADEONWaitForFifo(pScrn, 32); /* delay */
	    OUTPAL(idx * 8, r, g, b);
	}
    }
    else if (info->CurrentLayout.depth == 16) {
	/* 16bpp mode.  This sends 64 values. */
				/* There are twice as many green values as
				   there are values for red and blue.  So,
				   we take each red and blue pair, and
				   combine it with each of the two green
				   values. */
	for (i = 0; i < numColors; i++) {
	    idx = indices[i];
	    r   = colors[idx / 2].red;
	    g   = colors[idx].green;
	    b   = colors[idx / 2].blue;
	    RADEONWaitForFifo(pScrn, 32); /* delay */
	    OUTPAL(idx * 4, r, g, b);

	    /* AH - Added to write extra green data - How come this isn't
	     * needed on R128 ? We didn't load the extra green data in the
	     * other routine */
	    if (idx <= 31) {
a4168 1
		g   = colors[(idx * 2) + 1].green;
d4170 1
d4172 1
a4172 1
		OUTPAL(idx * 8, r, g, b);
d4175 47
a4221 10
    }
    else {
	/* 8bpp mode.  This sends 256 values. */
	for (i = 0; i < numColors; i++) {
	    idx = indices[i];
	    r   = colors[idx].red;
	    b   = colors[idx].blue;
	    g   = colors[idx].green;
	    RADEONWaitForFifo(pScrn, 32); /* delay */
	    OUTPAL(idx, r, g, b);
d4224 4
d4230 2
a4231 2
static void
RADEONBlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
d4233 3
a4235 3
    ScreenPtr     pScreen = screenInfo.screens[i];
    ScrnInfoPtr   pScrn   = xf86Screens[i];
    RADEONInfoPtr info    = RADEONPTR(pScrn);
d4239 1
a4239 1
        FLUSH_RING();
d4246 2
a4247 3
    if(info->VideoTimerCallback) {
        (*info->VideoTimerCallback)(pScrn, currentTime.milliseconds);
    }
d4253 4
a4256 4
    ScrnInfoPtr   pScrn = xf86Screens[pScreen->myNum];
    RADEONInfoPtr info  = RADEONPTR(pScrn);
    BoxRec        MemBox;
    int           y2;
d4264 2
d4267 1
d4269 1
a4269 1
    if(info->IsSecondary) pScrn->fbOffset = pScrn->videoRam * 1024;
d4273 2
a4274 2
    info->fbX          = 0;
    info->fbY          = 0;
a4277 1
    info->SwitchingMode = FALSE;
d4282 1
d4292 9
d4311 2
a4312 2
				   established, but before cfbScreenInit is
				   called.  cfbScreenInit will eventually
d4317 6
a4322 5
	   buffers, we will want to revisit the following check for 3
	   times the virtual size of the screen below. */
	int width_bytes = (pScrn->displayWidth *
			   info->CurrentLayout.pixel_bytes);
	int maxy        = info->FbMapSize / width_bytes;
d4335 3
a4337 1
	} else if (info->IsR200) {
d4340 9
a4348 1
		       "Direct rendering not yet supported on Radeon 8500\n");
d4350 17
a4366 27
            if(info->IsSecondary)
                info->directRenderingEnabled = FALSE;
            else 
            {
                /* Xinerama has sync problem with DRI, disable it for now */
                if(xf86IsEntityShared(pScrn->entityList[0]))
                {
                    info->directRenderingEnabled = FALSE;
 	            xf86DrvMsg(scrnIndex, X_WARNING,
                        "Direct Rendering Disabled -- "
                        "Dual-head configuration is not working with DRI "
                        "at present.\nPlease use only one Device/Screen "
                        "section in your XFConfig file.\n");
                }
                else
                info->directRenderingEnabled =
                    RADEONDRIScreenInit(pScreen);
                if(xf86IsEntityShared(pScrn->entityList[0]))
                {
                    DevUnion* pPriv;
                    RADEONEntPtr pRADEONEnt;
                    pPriv = xf86GetEntityPrivate(pScrn->entityList[0], 
                        gRADEONEntityIndex);
                    pRADEONEnt = pPriv->ptr;
                    pRADEONEnt->IsDRIEnabled = info->directRenderingEnabled;
                }
            }
d4371 4
a4374 5
#ifdef USE_FB
    if (!fbScreenInit (pScreen, info->FB,
		       pScrn->virtualX, pScrn->virtualY,
		       pScrn->xDpi, pScrn->yDpi, pScrn->displayWidth,
		       pScrn->bitsPerPixel))
d4376 1
a4376 26
#else
    switch (pScrn->bitsPerPixel) {
    case 8:
	if (!cfbScreenInit(pScreen, info->FB,
			   pScrn->virtualX, pScrn->virtualY,
			   pScrn->xDpi, pScrn->yDpi, pScrn->displayWidth))
	    return FALSE;
	break;
    case 16:
	if (!cfb16ScreenInit(pScreen, info->FB,
			     pScrn->virtualX, pScrn->virtualY,
			     pScrn->xDpi, pScrn->yDpi, pScrn->displayWidth))
	    return FALSE;
	break;
    case 32:
	if (!cfb32ScreenInit(pScreen, info->FB,
			     pScrn->virtualX, pScrn->virtualY,
			     pScrn->xDpi, pScrn->yDpi, pScrn->displayWidth))
	    return FALSE;
	break;
    default:
	xf86DrvMsg(scrnIndex, X_ERROR,
		   "Invalid bpp (%d)\n", pScrn->bitsPerPixel);
	return FALSE;
    }
#endif
d4380 1
a4380 1
	VisualPtr visual;
d4394 2
a4395 2
#ifdef USE_FB
    /* must be after RGB order fixed */
d4397 14
a4411 1

d4415 12
a4426 8
	FBAreaPtr fbarea;
	int width_bytes = (pScrn->displayWidth *
			   info->CurrentLayout.pixel_bytes);
	int cpp = info->CurrentLayout.pixel_bytes;
	int bufferSize = ((pScrn->virtualY * width_bytes + RADEON_BUFFER_ALIGN)
			  & ~RADEON_BUFFER_ALIGN);
	int l;
	int scanlines;
d4444 1
a4444 1
		   "Using %d MB AGP aperture\n", info->agpSize);
d4450 1
a4450 1
		   "Using %d MB for AGP textures\n", info->agpTexSize);
d4456 1
a4456 1
	info->textureSize = info->FbMapSize - 6 * bufferSize;
d4464 1
a4464 1
	    info->textureSize = info->FbMapSize - 5 * bufferSize;
d4467 6
a4472 1
	    info->textureSize = info->FbMapSize - 4 * bufferSize;
d4477 1
a4477 1
	if ((int)info->FbMapSize - 8192*width_bytes - bufferSize*2
d4480 6
a4485 1
		info->FbMapSize - 8192*width_bytes - bufferSize*2;
d4511 10
a4520 8
	info->textureOffset = (info->FbMapSize - info->textureSize +
			       RADEON_BUFFER_ALIGN) &
			      ~(CARD32)RADEON_BUFFER_ALIGN;

				/* Reserve space for the shared depth buffer */
	info->depthOffset = (info->textureOffset - bufferSize +
			     RADEON_BUFFER_ALIGN) &
			    ~(CARD32)RADEON_BUFFER_ALIGN;
d4524 12
a4535 4
	info->backOffset = (info->depthOffset - bufferSize +
			    RADEON_BUFFER_ALIGN) &
			   ~(CARD32)RADEON_BUFFER_ALIGN;
	info->backPitch = pScrn->displayWidth;
d4537 1
a4537 1
	scanlines = info->backOffset / width_bytes - 1;
d4547 2
a4548 1
		       "Memory manager initialization to (%d,%d) (%d,%d) failed\n",
d4552 1
a4552 1
	    int width, height;
d4559 2
a4560 1
						    2, 0, NULL, NULL, NULL))) {
d4573 15
d4592 1
a4592 1
		   "Reserved back buffer at offset 0x%x\n",
d4595 1
a4595 1
		   "Reserved depth buffer at offset 0x%x\n",
d4598 1
a4598 1
		   "Reserved %d kb for textures at offset 0x%x\n",
d4609 1
a4609 2
    }
    else
d4628 2
a4629 1
		       "Memory manager initialization to (%d,%d) (%d,%d) failed\n",
d4639 4
a4642 2
	    if ((fbarea = xf86AllocateOffscreenArea(pScreen, pScrn->displayWidth,
						    2, 0, NULL, NULL, NULL))) {
a4657 6
				/* Backing store setup */
    miInitializeBackingStore(pScreen);
    xf86SetBackingStore(pScreen);

				/* Set Silken Mouse */
    xf86SetSilkenMouse(pScreen);
d4664 4
d4682 7
d4695 1
a4695 1
	    int width, height;
d4698 3
a4700 2
		       "Using hardware cursor (scanline %d)\n",
		       info->cursor_start / pScrn->displayWidth);
d4713 1
d4720 1
a4720 2
			     (info->FBDev ? fbdevHWLoadPalette :
			     RADEONLoadPalette), NULL,
a4721 1
			     | CMAP_RELOAD_ON_MODE_SWITCH
d4725 1
a4725 1
			     )) return FALSE;
d4728 1
a4728 4
#ifdef DPMSExtension
    if (info->DisplayType == MT_CRT)
	xf86DPMSInit(pScreen, RADEONDisplayPowerManagementSet, 0);
#endif
d4731 1
d4746 1
a4746 1
				/* Now that mi, cfb, drm and others have
d4752 4
d4768 1
a4768 1
/* Write common registers (initialized to 0). */
d4772 45
a4816 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d4819 13
a4831 14
    OUTREG(RADEON_OVR_CLR,              restore->ovr_clr);
    OUTREG(RADEON_OVR_WID_LEFT_RIGHT,   restore->ovr_wid_left_right);
    OUTREG(RADEON_OVR_WID_TOP_BOTTOM,   restore->ovr_wid_top_bottom);
    OUTREG(RADEON_OV0_SCALE_CNTL,       restore->ov0_scale_cntl);
    OUTREG(RADEON_MPP_TB_CONFIG,        restore->mpp_tb_config );
    OUTREG(RADEON_MPP_GP_CONFIG,        restore->mpp_gp_config );
    OUTREG(RADEON_SUBPIC_CNTL,          restore->subpic_cntl);
    OUTREG(RADEON_VIPH_CONTROL,         restore->viph_control);
    OUTREG(RADEON_I2C_CNTL_1,           restore->i2c_cntl_1);
    OUTREG(RADEON_GEN_INT_CNTL,         restore->gen_int_cntl);
    OUTREG(RADEON_CAP0_TRIG_CNTL,       restore->cap0_trig_cntl);
    OUTREG(RADEON_CAP1_TRIG_CNTL,       restore->cap1_trig_cntl);
    OUTREG(RADEON_BUS_CNTL,             restore->bus_cntl);
    OUTREG(RADEON_SURFACE_CNTL,		restore->surface_cntl);
d4834 1
a4834 1
/* Write CRTC registers. */
d4838 1
a4838 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d4841 1
a4841 1
    OUTREG(RADEON_CRTC_GEN_CNTL,        restore->crtc_gen_cntl);
d4843 2
a4844 1
    OUTREGP(RADEON_CRTC_EXT_CNTL, restore->crtc_ext_cntl,
d4849 2
a4850 1
    OUTREGP(RADEON_DAC_CNTL, restore->dac_cntl,
d4861 2
d4865 1
a4865 1
/* Write CRTC2 registers. */
d4867 1
a4867 1
				       RADEONSavePtr restore)
d4869 1
a4869 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d4872 2
a4873 2
/*    OUTREG(RADEON_CRTC2_GEN_CNTL,  restore->crtc2_gen_cntl);*/
    OUTREGP(RADEON_CRTC2_GEN_CNTL, restore->crtc2_gen_cntl,
d4879 10
a4888 1
    OUTREG(RADEON_DISP_OUTPUT_CNTL, restore->disp_output_cntl);
d4897 1
d4899 10
a4910 1
/* Note: Radeon flat panel support has been disabled for now */
d4914 1
a4914 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d4916 1
a4916 1
    unsigned long tmp;
d4922 2
a4923 1
    OUTREG(RADEON_TMDS_CRC,             restore->tmds_crc);
d4928 23
a4950 21
    if(info->DisplayType == MT_LCD)
    {
    tmp = INREG(RADEON_LVDS_GEN_CNTL);
    if ((tmp & (RADEON_LVDS_ON | RADEON_LVDS_BLON)) ==
	    (restore->lvds_gen_cntl & (RADEON_LVDS_ON | RADEON_LVDS_BLON))) 
        {
	OUTREG(RADEON_LVDS_GEN_CNTL, restore->lvds_gen_cntl);
        } 
        else 
        {
	   if (restore->lvds_gen_cntl & 
               (RADEON_LVDS_ON | RADEON_LVDS_BLON)) 
           {
	    usleep(RADEONPTR(pScrn)->PanelPwrDly * 1000);
	    OUTREG(RADEON_LVDS_GEN_CNTL, restore->lvds_gen_cntl);
            } 
            else 
            {
	    OUTREG(RADEON_LVDS_GEN_CNTL,
		   restore->lvds_gen_cntl | RADEON_LVDS_BLON);
	    usleep(RADEONPTR(pScrn)->PanelPwrDly * 1000);
d4952 16
a4969 1
    }
a4971 1
#if RADEON_ATOMIC_UPDATE
d4974 10
a4983 1
    while (INPLL(pScrn, RADEON_PPLL_REF_DIV) & RADEON_PPLL_ATOMIC_UPDATE_R);
d4988 1
a4988 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d4991 19
a5009 1
    OUTPLLP(pScrn, RADEON_PPLL_REF_DIV, RADEON_PPLL_ATOMIC_UPDATE_W, 0xffff);
a5010 1
#endif
d5012 1
a5012 2
/* Write PLL registers. */
static void RADEONRestorePLLRegisters(ScrnInfoPtr pScrn, RADEONSavePtr restore)
d5014 1
a5014 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d5017 13
a5029 1
    OUTPLLP(pScrn, 0x08, 0x00, ~(0x03));
d5031 10
a5040 6
#if !RADEON_ATOMIC_UPDATE
    while ( (INREG(RADEON_CLOCK_CNTL_INDEX) & RADEON_PLL_DIV_SEL) !=
						RADEON_PLL_DIV_SEL) {
#endif
	OUTREGP(RADEON_CLOCK_CNTL_INDEX, RADEON_PLL_DIV_SEL, 0xffff);
#if !RADEON_ATOMIC_UPDATE
a5041 1
#endif
d5043 4
a5046 1
#if RADEON_ATOMIC_UPDATE
d5052 26
a5077 13
	    0xffff);
#else
    OUTPLLP(pScrn,
	    RADEON_PPLL_CNTL,
	    RADEON_PPLL_RESET,
	    0xffff);
#endif

#if RADEON_ATOMIC_UPDATE
    RADEONPLLWaitForReadUpdateComplete(pScrn);
#endif
    while ( (INPLL(pScrn, RADEON_PPLL_REF_DIV) & RADEON_PPLL_REF_DIV_MASK) !=
			(restore->ppll_ref_div & RADEON_PPLL_REF_DIV_MASK)) {
d5079 2
a5080 1
			restore->ppll_ref_div, ~RADEON_PPLL_REF_DIV_MASK);
a5081 3
#if RADEON_ATOMIC_UPDATE
    RADEONPLLWriteUpdate(pScrn);
#endif
d5083 8
a5090 9
#if RADEON_ATOMIC_UPDATE
    RADEONPLLWaitForReadUpdateComplete(pScrn);
#endif
    while ( (INPLL(pScrn, RADEON_PPLL_DIV_3) & RADEON_PPLL_FB3_DIV_MASK) !=
			(restore->ppll_div_3 & RADEON_PPLL_FB3_DIV_MASK)) {
	OUTPLLP(pScrn, RADEON_PPLL_DIV_3,
			restore->ppll_div_3, ~RADEON_PPLL_FB3_DIV_MASK);
    }
#if RADEON_ATOMIC_UPDATE
a5091 3
#endif

#if RADEON_ATOMIC_UPDATE
a5092 9
#endif
    while ( (INPLL(pScrn, RADEON_PPLL_DIV_3) & RADEON_PPLL_POST3_DIV_MASK) !=
			(restore->ppll_div_3 & RADEON_PPLL_POST3_DIV_MASK)) {
	OUTPLLP(pScrn, RADEON_PPLL_DIV_3,
			restore->ppll_div_3, ~RADEON_PPLL_POST3_DIV_MASK);
    }
#if RADEON_ATOMIC_UPDATE
    RADEONPLLWriteUpdate(pScrn);
#endif
a5093 3
#if RADEON_ATOMIC_UPDATE
    RADEONPLLWaitForReadUpdateComplete(pScrn);
#endif
a5094 3
#if RADEON_ATOMIC_UPDATE
    RADEONPLLWriteUpdate(pScrn);
#endif
d5096 11
a5106 1
    OUTPLLP(pScrn, RADEON_PPLL_CNTL, 0, ~RADEON_PPLL_RESET);
d5118 1
a5118 1
    OUTPLLP(pScrn, 0x08, 0x03, ~(0x03));
d5120 3
d5126 3
a5128 2
/* Write PLL2 registers. */
static void RADEONRestorePLL2Registers(ScrnInfoPtr pScrn, RADEONSavePtr restore)
d5130 1
a5130 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d5133 3
a5135 2
    OUTPLLP(pScrn, 0x2d, 0x00, ~(0x03));

a5136 10
#if !RADEON_ATOMIC_UPDATE
    while (INREG(RADEON_CLOCK_CNTL_INDEX) & ~(RADEON_PLL2_DIV_SEL_MASK)) {
#endif
	OUTREGP(RADEON_CLOCK_CNTL_INDEX, 0, RADEON_PLL2_DIV_SEL_MASK);
#if !RADEON_ATOMIC_UPDATE
    }
#endif


#if RADEON_ATOMIC_UPDATE
d5142 15
a5156 31
	    0xffff);
#else
    OUTPLLP(pScrn,
	    RADEON_P2PLL_CNTL,
	    RADEON_P2PLL_RESET,
	    0xffff);
#endif

#if RADEON_ATOMIC_UPDATE
    RADEONPLLWaitForReadUpdateComplete(pScrn);
#endif
    while ( (INPLL(pScrn, RADEON_P2PLL_REF_DIV) & RADEON_P2PLL_REF_DIV_MASK) !=
			(restore->p2pll_ref_div & RADEON_P2PLL_REF_DIV_MASK)) {
	OUTPLLP(pScrn, RADEON_P2PLL_REF_DIV, restore->p2pll_ref_div, ~RADEON_P2PLL_REF_DIV_MASK);
    }
#if RADEON_ATOMIC_UPDATE
    RADEONPLLWriteUpdate(pScrn);
#endif

#if RADEON_ATOMIC_UPDATE
    RADEONPLLWaitForReadUpdateComplete(pScrn);
#endif
    while ( (INPLL(pScrn, RADEON_P2PLL_DIV_0) & RADEON_P2PLL_FB0_DIV_MASK) !=
			(restore->p2pll_div_0 & 
RADEON_P2PLL_FB0_DIV_MASK)) {
	OUTPLLP(pScrn, RADEON_P2PLL_DIV_0,
			restore->p2pll_div_0, ~RADEON_P2PLL_FB0_DIV_MASK);
    }
#if RADEON_ATOMIC_UPDATE
    RADEONPLLWriteUpdate(pScrn);
#endif
d5158 2
a5159 11
#if RADEON_ATOMIC_UPDATE
    RADEONPLLWaitForReadUpdateComplete(pScrn);
#endif
    while ( (INPLL(pScrn, RADEON_P2PLL_DIV_0) & RADEON_P2PLL_POST0_DIV_MASK) !=
			(restore->p2pll_div_0 & RADEON_P2PLL_POST0_DIV_MASK)) {
	OUTPLLP(pScrn, RADEON_P2PLL_DIV_0,
			restore->p2pll_div_0, ~RADEON_P2PLL_POST0_DIV_MASK);
    }
#if RADEON_ATOMIC_UPDATE
    RADEONPLLWriteUpdate(pScrn);
#endif
a5160 3
#if RADEON_ATOMIC_UPDATE
    RADEONPLLWaitForReadUpdateComplete(pScrn);
#endif
a5161 3
#if RADEON_ATOMIC_UPDATE
    RADEONPLLWriteUpdate(pScrn);
#endif
d5163 6
a5168 2
    OUTPLLP(pScrn, RADEON_P2PLL_CNTL, 0, 
           ~(RADEON_P2PLL_RESET | RADEON_P2PLL_SLEEP));
d5177 2
a5178 5
	       restore->p2pll_div_0 & RADEON_P2PLL_FB3_DIV_MASK,
	       (restore->p2pll_div_0 & RADEON_P2PLL_POST3_DIV_MASK) >>16));

    OUTPLLP(pScrn, 0x2d, 0x03, ~(0x03));

d5180 1
a5180 7
}

/* Write DDA registers. */
static void RADEONRestoreDDARegisters(ScrnInfoPtr pScrn, RADEONSavePtr restore)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
d5182 3
a5184 2
    OUTREG(RADEON_DDA_CONFIG, restore->dda_config);
    OUTREG(RADEON_DDA_ON_OFF, restore->dda_on_off);
d5188 1
a5188 1
/* Write palette data. */
d5191 1
a5191 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d5193 1
a5193 1
    int           i;
d5213 2
a5214 3
/* Write out state to define a new video mode.  */
static void
RADEONRestoreMode(ScrnInfoPtr pScrn, RADEONSavePtr restore) 
d5216 8
a5223 14
    RADEONInfoPtr info = RADEONPTR(pScrn);
    DevUnion* pPriv;
    RADEONEntPtr pRADEONEnt;
    static RADEONSaveRec restore0;

    /* for Non-dual head card, we don't have private field in the Entity*/
    if(!info->HasCRTC2)
    {
    RADEONRestoreCommonRegisters(pScrn, restore);
        RADEONRestoreDDARegisters(pScrn, restore);
    RADEONRestoreCrtcRegisters(pScrn, restore);
        if((info->DisplayType == MT_DFP) || 
           (info->DisplayType == MT_LCD))
        {
d5225 3
a5227 4
        }
    RADEONRestorePLLRegisters(pScrn, restore);
        return;
    }       
a5228 4
    pPriv = xf86GetEntityPrivate(pScrn->entityList[0], 
                   gRADEONEntityIndex);
    pRADEONEnt = pPriv->ptr;
   
d5231 35
a5265 32
    /*****
      When changing mode with Dual-head card (VE/M6), care must
      be taken for the special order in setting registers. CRTC2 has
      to be set before changing CRTC_EXT register.
      In the dual-head setup, X server calls this routine twice with
      primary and secondary pScrn pointers respectively. The calls
      can come with different order. Regardless the order of X server issuing 
      the calls, we have to ensure we set registers in the right order!!! 
      Otherwise we may get a blank screen.
    *****/
    if(info->IsSecondary)
    {
        RADEONRestoreCrtc2Registers(pScrn, restore);        
        RADEONRestorePLL2Registers(pScrn, restore);
        
        if(!info->SwitchingMode)
        pRADEONEnt->IsSecondaryRestored = TRUE;

        if(pRADEONEnt->RestorePrimary)
        {
            RADEONInfoPtr info0 = RADEONPTR(pRADEONEnt->pPrimaryScrn); 
            pRADEONEnt->RestorePrimary = FALSE;

            RADEONRestoreCrtcRegisters(pScrn, &restore0);
            if((info0->DisplayType == MT_DFP) || 
               (info0->DisplayType == MT_LCD))
            {
                RADEONRestoreFPRegisters(pScrn, &restore0);
            }
            
            RADEONRestorePLLRegisters(pScrn, &restore0);   
            pRADEONEnt->IsSecondaryRestored = FALSE;
d5267 2
a5268 9
        }
    }
    else
    {
        RADEONRestoreCommonRegisters(pScrn, restore);
        RADEONRestoreDDARegisters(pScrn, restore);
        if(!pRADEONEnt->HasSecondary || pRADEONEnt->IsSecondaryRestored
            || info->SwitchingMode)
        {
a5269 14
            RADEONRestoreCrtcRegisters(pScrn, restore);
            if((info->DisplayType == MT_DFP) || 
               (info->DisplayType == MT_LCD))
            {
               RADEONRestoreFPRegisters(pScrn, restore);
            }
            RADEONRestorePLLRegisters(pScrn, restore);   
        }
        else
        {
            memcpy(&restore0, restore, sizeof(restore0));
            pRADEONEnt->RestorePrimary = TRUE;
        }
    }
d5271 7
a5277 6
    /* if only one screen is used, we should turn off
       the unused screen, not working for now */
    /*
    if(!xf86IsEntityShared(pScrn->entityList[0]))
    {
        RADEONSetDisplayOff(pScrn, 1, 1);
a5278 1
    */
d5285 1
a5285 1
/* Read common registers. */
d5288 1
a5288 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
a5294 2
    save->mpp_tb_config      = INREG(RADEON_MPP_TB_CONFIG);
    save->mpp_gp_config      = INREG(RADEON_MPP_GP_CONFIG);
d5303 24
d5329 1
a5329 1
/* Read CRTC registers. */
d5332 1
a5332 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d5345 2
a5346 1

a5348 1
/* Note: Radeon flat panel support has been disabled for now */
d5352 1
a5352 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d5364 8
a5371 1
    save->tmds_crc             = INREG(RADEON_TMDS_CRC);
d5374 2
a5375 3
/* Read CRTC2 registers. */
static void RADEONSaveCrtc2Registers(ScrnInfoPtr pScrn, RADEONSavePtr
save)
d5377 1
a5377 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d5382 1
d5392 5
d5399 1
a5399 1
/* Read PLL registers. */
d5402 3
a5404 3
    save->ppll_ref_div         = INPLL(pScrn, RADEON_PPLL_REF_DIV);
    save->ppll_div_3           = INPLL(pScrn, RADEON_PPLL_DIV_3);
    save->htotal_cntl          = INPLL(pScrn, RADEON_HTOTAL_CNTL);
d5407 3
a5409 3
	       save->ppll_ref_div,
	       save->ppll_div_3,
	       save->htotal_cntl));
d5411 3
a5413 3
	       save->ppll_ref_div & RADEON_PPLL_REF_DIV_MASK,
	       save->ppll_div_3 & RADEON_PPLL_FB3_DIV_MASK,
	       (save->ppll_div_3 & RADEON_PPLL_POST3_DIV_MASK) >> 16));
d5416 1
a5416 1
/* Read PLL registers. */
d5419 3
a5421 3
    save->p2pll_ref_div        = INPLL(pScrn, RADEON_P2PLL_REF_DIV);
    save->p2pll_div_0          = INPLL(pScrn, RADEON_P2PLL_DIV_0);
    save->htotal_cntl2         = INPLL(pScrn, RADEON_HTOTAL2_CNTL);
d5424 3
a5426 3
	       save->p2pll_ref_div,
	       save->p2pll_div_0,
	       save->htotal_cntl2));
d5428 3
a5430 3
	       save->p2pll_ref_div & RADEON_P2PLL_REF_DIV_MASK,
	       save->p2pll_div_0 & RADEON_P2PLL_FB0_DIV_MASK,
	       (save->p2pll_div_0 & RADEON_P2PLL_POST0_DIV_MASK) >> 16));
d5433 1
a5433 11
/* Read DDA registers. */
static void RADEONSaveDDARegisters(ScrnInfoPtr pScrn, RADEONSavePtr save)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    save->dda_config           = INREG(RADEON_DDA_CONFIG);
    save->dda_on_off           = INREG(RADEON_DDA_ON_OFF);
}

/* Read palette data. */
d5436 1
a5436 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d5438 1
a5438 1
    int           i;
d5442 1
a5442 1
    /*if (info->Port1 == MT_DFP) PAL_SELECT(1);*/
d5453 1
a5453 1
/* Save state that defines current video mode. */
d5456 1
a5456 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
a5458 7
    if(info->IsSecondary)
    {
        RADEONSaveCrtc2Registers(pScrn, save);
        RADEONSavePLL2Registers(pScrn, save);
    }
    else
    {
d5460 6
a5465 4
    RADEONSaveCrtcRegisters(pScrn, save);
        if((info->DisplayType == MT_DFP) || 
           (info->DisplayType == MT_LCD))
        {
d5467 6
a5472 4
        }
    RADEONSavePLLRegisters(pScrn, save);
    RADEONSaveDDARegisters(pScrn, save);
        /*RADEONSavePalette(pScrn, save);*/
d5474 1
d5478 1
a5478 1
/* Save everything needed to restore the original VC state. */
d5481 1
a5481 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d5483 2
a5484 2
    RADEONSavePtr save        = &info->SavedReg;
    vgaHWPtr      hwp         = VGAHWPTR(pScrn);
d5492 2
a5493 3
    if(!info->IsSecondary)
    {
    vgaHWUnlock(hwp);
d5495 5
a5499 5
    /* temporary hack to prevent crashing on PowerMacs when trying to
     * read VGA fonts and colormap, will find a better solution
     * in the future
     */
    vgaHWSave(pScrn, &hwp->SavedReg, VGA_SR_MODE); /* save mode only */
d5501 9
a5509 8
    vgaHWSave(pScrn, &hwp->SavedReg, VGA_SR_ALL); /* save mode, fonts,cmap */
#endif
    vgaHWLock(hwp);
    save->dp_datatype      = INREG(RADEON_DP_DATATYPE);
    save->rbbm_soft_reset  = INREG(RADEON_RBBM_SOFT_RESET);
    save->clock_cntl_index = INREG(RADEON_CLOCK_CNTL_INDEX);
    save->amcgpio_en_reg   = INREG(RADEON_AMCGPIO_EN_REG);
    save->amcgpio_mask     = INREG(RADEON_AMCGPIO_MASK);
d5511 1
a5511 1
        
d5515 1
a5515 1
/* Restore the original (text) mode. */
d5518 1
a5518 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d5520 2
a5521 2
    RADEONSavePtr restore     = &info->SavedReg;
    vgaHWPtr      hwp         = VGAHWPTR(pScrn);
d5524 6
a5535 2
    OUTREG(RADEON_AMCGPIO_MASK,     restore->amcgpio_mask);
    OUTREG(RADEON_AMCGPIO_EN_REG,   restore->amcgpio_en_reg);
d5537 1
d5540 2
d5543 1
d5545 6
a5550 3
       Needs this workaround.*/
    if(xf86IsEntityShared(pScrn->entityList[0]) && info->IsM6)
        OUTREG(RADEON_DAC_CNTL2, restore->dac2_cntl);
d5554 1
d5556 4
a5559 3
       some systems, the console can either hang or the fonts can be
       corrupted.  This hack solves the problem 99% of the time.  A
       correct fix is being worked on. */
d5561 1
d5563 2
a5564 3
    if(!info->IsSecondary)
    {
    vgaHWUnlock(hwp);
d5566 4
a5569 4
    /* temporary hack to prevent crashing on PowerMacs when trying to
     * write VGA fonts, will find a better solution in the future
     */
    vgaHWRestore(pScrn, &hwp->SavedReg, VGA_SR_MODE );
d5571 1
a5571 1
    vgaHWRestore(pScrn, &hwp->SavedReg, VGA_SR_ALL );
d5573 11
a5583 18
    vgaHWLock(hwp);

    }
    else
    {
        DevUnion* pPriv;
        RADEONEntPtr pRADEONEnt;
        pPriv = xf86GetEntityPrivate(pScrn->entityList[0], 
            gRADEONEntityIndex);
        pRADEONEnt = pPriv->ptr;
        {
            ScrnInfoPtr pScrn0 = pRADEONEnt->pPrimaryScrn;
            vgaHWPtr      hwp0         = VGAHWPTR(pScrn0);
            vgaHWUnlock(hwp0);
            vgaHWRestore(pScrn0, &hwp0->SavedReg, 
                    VGA_SR_MODE | VGA_SR_FONTS );
            vgaHWLock(hwp0);
        }
d5592 1
a5592 2

/* Define common registers for requested video mode. */
a5598 2
    save->mpp_tb_config      = 0;
    save->mpp_gp_config      = 0;
d5614 317
a5930 1
/* Define CRTC registers for requested video mode. */
d5934 9
a5942 8
    int    format;
    int    hsync_start;
    int    hsync_wid;
    int    hsync_fudge;
    int    vsync_wid;
    int    bytpp;
    int    hsync_fudge_default[] = { 0x00, 0x12, 0x09, 0x09, 0x06, 0x05 };
    int    hsync_fudge_fp[]      = { 0x02, 0x02, 0x00, 0x00, 0x05, 0x05 };
d5945 6
a5950 6
    case 4:  format = 1; bytpp = 0; break;
    case 8:  format = 2; bytpp = 1; break;
    case 15: format = 3; bytpp = 2; break;      /*  555 */
    case 16: format = 4; bytpp = 2; break;      /*  565 */
    case 24: format = 5; bytpp = 3; break;      /*  RGB */
    case 32: format = 6; bytpp = 4; break;      /* xRGB */
d5953 49
a6001 2
		   "Unsupported pixel depth (%d)\n", info->CurrentLayout.bitsPerPixel);
	return FALSE;
a6002 7
    RADEONTRACE(("Format = %d (%d bytes per pixel)\n", format, bytpp));

    if ((info->DisplayType == MT_DFP) || 
        (info->DisplayType == MT_LCD))
	hsync_fudge = hsync_fudge_fp[format-1];
    else               
    hsync_fudge = hsync_fudge_default[format-1];
d6004 3
a6006 9
    save->crtc_gen_cntl = (RADEON_CRTC_EXT_DISP_EN
			  | RADEON_CRTC_EN
			  | (format << 8)
			  | ((mode->Flags & V_DBLSCAN)
			     ? RADEON_CRTC_DBL_SCAN_EN
			     : 0)
			  | ((mode->Flags & V_INTERLACE)
			     ? RADEON_CRTC_INTERLACE_EN
			     : 0));
a6007 31
    if((info->DisplayType == MT_DFP) || 
       (info->DisplayType == MT_LCD))
    {
        save->crtc_ext_cntl = RADEON_VGA_ATI_LINEAR | 
        			  RADEON_XCRT_CNT_EN;
        save->crtc_gen_cntl &= ~(RADEON_CRTC_DBL_SCAN_EN | 
                                  RADEON_CRTC_INTERLACE_EN);
    }
    else
    save->crtc_ext_cntl = RADEON_VGA_ATI_LINEAR | 
			  RADEON_XCRT_CNT_EN |
			  RADEON_CRTC_CRT_ON;

    save->dac_cntl      = (RADEON_DAC_MASK_ALL
			   | RADEON_DAC_VGA_ADR_EN
			   | (info->dac6bits ? 0 : RADEON_DAC_8BIT_EN));
  
    if(((info->DisplayType == MT_DFP) || 
       (info->DisplayType == MT_LCD)) && !info->UseCRT)
    {
        if(info->PanelXRes < mode->CrtcHDisplay)
            mode->HDisplay = mode->CrtcHDisplay = info->PanelXRes;
        if(info->PanelYRes < mode->CrtcVDisplay)
            mode->VDisplay = mode->CrtcVDisplay = info->PanelYRes;
        mode->CrtcHTotal = mode->CrtcHDisplay + info->HBlank;
        mode->CrtcHSyncStart = mode->CrtcHDisplay + info->HOverPlus;
        mode->CrtcHSyncEnd = mode->CrtcHSyncStart + info->HSyncWidth;
        mode->CrtcVTotal = mode->CrtcVDisplay + info->VBlank;
        mode->CrtcVSyncStart = mode->CrtcVDisplay + info->VOverPlus;
        mode->CrtcVSyncEnd = mode->CrtcVSyncStart + info->VSyncWidth;
    }
d6009 2
a6010 1
	   | ((((mode->CrtcHDisplay / 8) - 1) & 0x1ff) << 16));
d6013 1
a6013 2
    if (!hsync_wid)       hsync_wid = 1;
    if (hsync_wid > 0x3f) hsync_wid = 0x3f;
d6017 5
a6021 5
 				 | (hsync_wid << 16)
				 | ((mode->Flags & V_NHSYNC)
				    ? RADEON_CRTC_H_SYNC_POL
				    : 0));
  
d6025 1
a6025 1
			      | ((mode->CrtcVDisplay - 1) << 16));
d6028 2
a6029 1
				   does -- is this correct? */
d6031 3
a6033 3
			      | ((mode->CrtcVDisplay
				  * ((mode->Flags & V_DBLSCAN) ? 2 : 1) - 1)
				 << 16));
d6037 1
a6037 2
    if (!vsync_wid)       vsync_wid = 1;
    if (vsync_wid > 0x1f) vsync_wid = 0x1f;
d6040 4
a6043 4
				 | (vsync_wid << 16)
				 | ((mode->Flags & V_NVSYNC)
				    ? RADEON_CRTC_V_SYNC_POL
				    : 0));
d6046 1
a6046 1
    save->crtc_offset_cntl = 0;
d6048 3
a6050 3
    save->crtc_pitch  = ((pScrn->displayWidth * pScrn->bitsPerPixel) +
			 ((pScrn->bitsPerPixel * 8) -1)) /
			 (pScrn->bitsPerPixel * 8);
d6053 14
a6066 1
    save->surface_cntl = RADEON_SURF_TRANSLATION_DIS;
d6068 1
d6070 9
a6078 6
	case 16:
		save->surface_cntl |= RADEON_NONSURF_AP0_SWP_16BPP;
		break;
	case 32:
		save->surface_cntl |= RADEON_NONSURF_AP0_SWP_32BPP;
		break;
d6088 1
a6088 1
/* Define CRTC2 registers for requested video mode. */
d6090 1
a6090 1
				  DisplayModePtr mode, RADEONInfoPtr info)
d6092 9
a6100 7
    int    format;
    int    hsync_start;
    int    hsync_wid;
    int    hsync_fudge;
    int    vsync_wid;
    int    bytpp;
    int    hsync_fudge_default[] = { 0x00, 0x12, 0x09, 0x09, 0x06, 0x05 };
d6103 6
a6108 6
    case 4:  format = 1; bytpp = 0; break;
    case 8:  format = 2; bytpp = 1; break;
    case 15: format = 3; bytpp = 2; break;      /*  555 */
    case 16: format = 4; bytpp = 2; break;      /*  565 */
    case 24: format = 5; bytpp = 3; break;      /*  RGB */
    case 32: format = 6; bytpp = 4; break;      /* xRGB */
d6111 2
a6112 1
		   "Unsupported pixel depth (%d)\n", info->CurrentLayout.bitsPerPixel);
a6114 1
    RADEONTRACE(("Format = %d (%d bytes per pixel)\n", format, bytpp));
d6119 55
a6173 17
                          | RADEON_CRTC2_CRT2_ON
			  | (format << 8)
			  | ((mode->Flags & V_DBLSCAN)
			     ? RADEON_CRTC2_DBL_SCAN_EN
			     : 0)
			  | ((mode->Flags & V_INTERLACE)
			     ? RADEON_CRTC2_INTERLACE_EN
			     : 0));

    if(info->IsR200)
        save->disp_output_cntl = 
            ((info->SavedReg.disp_output_cntl & ~(CARD32)RADEON_DISP_DAC_SOURCE_MASK)
            | RADEON_DISP_DAC_SOURCE_CRTC2);
    else
        save->dac2_cntl = info->SavedReg.dac2_cntl 
                      /*| RADEON_DAC2_DAC2_CLK_SEL*/
                      | RADEON_DAC2_DAC_CLK_SEL;
d6175 3
a6177 2
    save->crtc2_h_total_disp = ((((mode->CrtcHTotal / 8) - 1) & 0x3ff)
	   | ((((mode->CrtcHDisplay / 8) - 1) & 0x1ff) << 16));
d6180 1
a6180 2
    if (!hsync_wid)       hsync_wid = 1;
    if (hsync_wid > 0x3f) hsync_wid = 0x3f;
d6184 4
a6187 4
				 | (hsync_wid << 16)
				 | ((mode->Flags & V_NHSYNC)
				    ? RADEON_CRTC_H_SYNC_POL
				    : RADEON_CRTC_H_SYNC_POL));
d6192 1
a6192 1
			      | ((mode->CrtcVDisplay - 1) << 16));
d6195 2
a6196 1
				   does -- is this correct? */
d6198 3
a6200 3
			      | ((mode->CrtcVDisplay
				  * ((mode->Flags & V_DBLSCAN) ? 2 : 1) - 1)
				 << 16));
d6204 1
a6204 2
    if (!vsync_wid)       vsync_wid = 1;
    if (vsync_wid > 0x1f) vsync_wid = 0x1f;
d6207 4
a6210 4
				 | (vsync_wid << 16)
				 | ((mode->Flags & V_NVSYNC)
				    ? RADEON_CRTC2_V_SYNC_POL
				    : RADEON_CRTC2_V_SYNC_POL));
d6213 1
a6213 1
    save->crtc2_offset_cntl = 0;
d6215 3
a6217 3
    save->crtc2_pitch  = ((pScrn->displayWidth * pScrn->bitsPerPixel) +
			 ((pScrn->bitsPerPixel * 8) -1)) /
			 (pScrn->bitsPerPixel * 8);
d6219 42
a6260 1
	
d6264 1
d6268 1
a6268 2
/* Note: Radeon flat panel support has been disabled for now */
/* Define CRTC registers for requested video mode. */
d6273 8
a6280 3
    int   xres = mode->CrtcHDisplay;
    int   yres = mode->CrtcVDisplay;
    float Hratio, Vratio;
d6282 18
a6299 4
    if(info->PanelXRes == 0 || info->PanelYRes == 0)
    {
        Hratio = 1;
        Vratio = 1;
a6300 4
    else
    {
    if (xres > info->PanelXRes) xres = info->PanelXRes;
    if (yres > info->PanelYRes) yres = info->PanelYRes;
d6302 9
a6310 2
    Hratio = (float)xres/(float)info->PanelXRes;
    Vratio = (float)yres/(float)info->PanelYRes;
d6313 22
a6334 16
    if (Hratio == 1.0)
    {
        save->fp_horz_stretch = orig->fp_horz_stretch;
        save->fp_horz_stretch &= ~(RADEON_HORZ_STRETCH_BLEND |
	                           RADEON_HORZ_STRETCH_ENABLE);
    }
    else
    {               
    save->fp_horz_stretch =
            ((((unsigned long)(Hratio * RADEON_HORZ_STRETCH_RATIO_MAX +
            0.5)) & RADEON_HORZ_STRETCH_RATIO_MASK)) |
	 (orig->fp_horz_stretch & (RADEON_HORZ_PANEL_SIZE |
				   RADEON_HORZ_FP_LOOP_STRETCH |
                                  RADEON_HORZ_AUTO_RATIO_INC));
        save->fp_horz_stretch |=  (RADEON_HORZ_STRETCH_BLEND |
						  RADEON_HORZ_STRETCH_ENABLE);
a6335 1
    save->fp_horz_stretch &= ~RADEON_HORZ_AUTO_RATIO;
d6337 9
a6345 9
    if (Vratio == 1.0) 
    {
        save->fp_vert_stretch = orig->fp_vert_stretch;
        save->fp_vert_stretch &= ~(RADEON_VERT_STRETCH_ENABLE|
                                   RADEON_VERT_STRETCH_BLEND);
    }   
    else
    {               
    save->fp_vert_stretch =
d6347 10
a6356 5
            0.5)) & RADEON_VERT_STRETCH_RATIO_MASK)) |
	 (orig->fp_vert_stretch & (RADEON_VERT_PANEL_SIZE |
				   RADEON_VERT_STRETCH_RESERVED)));
        save->fp_vert_stretch |=  (RADEON_VERT_STRETCH_ENABLE |
						  RADEON_VERT_STRETCH_BLEND);
a6357 1
    save->fp_vert_stretch &= ~RADEON_VERT_AUTO_RATIO_EN;
d6360 10
a6369 14
					~(RADEON_FP_SEL_CRTC2 |
			                  RADEON_FP_RMX_HVSYNC_CONTROL_EN |
					  RADEON_FP_DFP_SYNC_SEL |	
                                          RADEON_FP_CRT_SYNC_SEL | 
					  RADEON_FP_CRTC_LOCK_8DOT |	
					  RADEON_FP_USE_SHADOW_EN |
					  RADEON_FP_CRTC_USE_SHADOW_VEND |
					  RADEON_FP_CRT_SYNC_ALT));
	save->fp_gen_cntl |= (RADEON_FP_CRTC_DONT_SHADOW_VPAR |
                          RADEON_FP_CRTC_DONT_SHADOW_HEND );

    save->lvds_gen_cntl        = orig->lvds_gen_cntl;
    save->lvds_pll_cntl        = orig->lvds_pll_cntl;
    save->tmds_crc             = orig->tmds_crc;
d6371 7
a6377 2
    /* Disable CRT output by disabling CRT output for DFP*/
    save->crtc_ext_cntl  &= ~RADEON_CRTC_CRT_ON;
d6379 6
a6384 4
    if(info->DisplayType == MT_LCD)
    {
    save->lvds_gen_cntl  |= (RADEON_LVDS_ON | RADEON_LVDS_BLON);
        save->fp_gen_cntl    &= ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN);
a6385 2
    else if(info->DisplayType == MT_DFP)
        save->fp_gen_cntl    |= (RADEON_FP_FPON | RADEON_FP_TMDS_EN);
d6387 64
a6450 4
    save->fp_crtc_h_total_disp = orig->fp_crtc_h_total_disp;
    save->fp_crtc_v_total_disp = orig->fp_crtc_v_total_disp;
    save->fp_h_sync_strt_wid   = orig->fp_h_sync_strt_wid;
    save->fp_v_sync_strt_wid   = orig->fp_v_sync_strt_wid;
d6452 4
d6458 1
a6458 1
/* Define PLL registers for requested video mode. */
d6462 2
a6463 1
    unsigned long freq = dot_clock * 100;
d6467 1
a6467 2
    } *post_div,
      post_divs[]   = {
d6469 4
a6472 3
				   Reference Manual (Technical Reference
				   Manual P/N RRG-G04100-C Rev. 0.04), page
				   3-17 (PLL_DIV_[3:0]).  */
d6489 1
d6494 5
d6516 1
a6516 1
/* Define PLL2 registers for requested video mode. */
d6518 1
a6518 1
				   double dot_clock)
d6520 2
a6521 1
    unsigned long freq = dot_clock * 100;
d6525 1
a6525 2
    } *post_div,
      post_divs[]   = {
d6527 4
a6530 3
				   Reference Manual (Technical Reference
				   Manual P/N RRG-G04100-C Rev. 0.04), page
				   3-17 (PLL_DIV_[3:0]).  */
a6535 1
	{ 16, 5 },              /* VCLK_SRC/16              */
d6550 5
d6557 2
a6558 2
				     * save->pll_output_freq_2,
				     pll->reference_freq);
d6567 4
a6570 68
    save->p2pll_ref_div   = pll->reference_div;
    save->p2pll_div_0    = (save->feedback_div_2 | (post_div->bitvalue<<16));
    save->htotal_cntl2    = 0;
}

/* Define DDA registers for requested video mode. */
static Bool RADEONInitDDARegisters(ScrnInfoPtr pScrn, RADEONSavePtr save,
				   RADEONPLLPtr pll, RADEONInfoPtr info)
{
    int         DisplayFifoWidth = 128;
    int         DisplayFifoDepth = 32;
    int         XclkFreq;
    int         VclkFreq;
    int         XclksPerTransfer;
    int         XclksPerTransferPrecise;
    int         UseablePrecision;
    int         Roff;
    int         Ron;

    XclkFreq = pll->xclk;

    VclkFreq = RADEONDiv(pll->reference_freq * save->feedback_div,
			 pll->reference_div * save->post_div);

    XclksPerTransfer = RADEONDiv(XclkFreq * DisplayFifoWidth,
				 VclkFreq *
				 (info->CurrentLayout.pixel_bytes * 8));

    UseablePrecision = RADEONMinBits(XclksPerTransfer) + 1;

    XclksPerTransferPrecise = RADEONDiv((XclkFreq * DisplayFifoWidth)
					<< (11 - UseablePrecision),
					VclkFreq *
					(info->CurrentLayout.pixel_bytes * 8));

    Roff  = XclksPerTransferPrecise * (DisplayFifoDepth - 4);

    Ron   = (4 * info->ram->MB
	     + 3 * MAX(info->ram->Trcd - 2, 0)
	     + 2 * info->ram->Trp
	     + info->ram->Twr
	     + info->ram->CL
	     + info->ram->Tr2w
	     + XclksPerTransfer) << (11 - UseablePrecision);

    if (Ron + info->ram->Rloop >= Roff) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "(Ron = %d) + (Rloop = %d) >= (Roff = %d)\n",
		   Ron, info->ram->Rloop, Roff);
	return FALSE;
    }

    save->dda_config = (XclksPerTransferPrecise
			| (UseablePrecision << 16)
			| (info->ram->Rloop << 20));

    save->dda_on_off = (Ron << 16) | Roff;

    RADEONTRACE(("XclkFreq = %d; VclkFreq = %d; per = %d, %d (useable = %d)\n",
		 XclkFreq,
		 VclkFreq,
		 XclksPerTransfer,
		 XclksPerTransferPrecise,
		 UseablePrecision));
    RADEONTRACE(("Roff = %d, Ron = %d, Rloop = %d\n",
		 Roff, Ron, info->ram->Rloop));

    return TRUE;
d6573 1
a6573 1

d6575 2
a6576 2
   anything for XFree86 4.0. */
/*
d6581 1
a6581 1
*/
d6583 1
a6583 1
/* Define registers for a requested video mode. */
d6587 2
a6588 2
    RADEONInfoPtr info      = RADEONPTR(pScrn);
    double        dot_clock = mode->Clock/1000.0;
d6607 1
d6630 1
a6640 9
    if(info->IsSecondary)
    {
        if (!RADEONInitCrtc2Registers(pScrn, save, 
             pScrn->currentMode,info)) 
            return FALSE;
        RADEONInitPLL2Registers(save, &info->pll, dot_clock);
    }
    else
    {
d6642 21
a6662 15
        if(!RADEONInitCrtcRegisters(pScrn, save, mode, info)) 
            return FALSE;
        if(dot_clock) 
        {
    RADEONInitPLLRegisters(save, &info->pll, dot_clock);
    if (!RADEONInitDDARegisters(pScrn, save, &info->pll, info))
	return FALSE;
        }
        else
        {
            save->ppll_ref_div         = info->SavedReg.ppll_ref_div;
            save->ppll_div_3           = info->SavedReg.ppll_div_3;
            save->htotal_cntl          = info->SavedReg.htotal_cntl;
            save->dda_config           = info->SavedReg.dda_config;
            save->dda_on_off           = info->SavedReg.dda_on_off;
d6664 7
a6670 3
        }
        /* not used for now */
        /*if (!info->PaletteSavedOnVT) RADEONInitPalette(save);*/
d6673 1
a6673 6

    if (((info->DisplayType == MT_DFP) || 
        (info->DisplayType == MT_LCD)))
    {
        RADEONInitFPRegisters(pScrn, &info->SavedReg, save, mode, info);
    }
d6679 1
a6679 1
/* Initialize a new mode. */
d6682 1
a6682 1
    RADEONInfoPtr info      = RADEONPTR(pScrn);
a6684 1
				/* FIXME?  DRILock/DRIUnlock here? */
d6692 4
d6701 2
a6702 2
    ScrnInfoPtr   pScrn = xf86Screens[pScreen->myNum];
    Bool unblank;
d6705 1
a6705 2
    if (unblank)
	SetTimeSinceLastInputEvent();
d6708 2
a6709 4
	if (unblank)
	    RADEONUnblank(pScrn);
	else
	    RADEONBlank(pScrn);
d6716 18
a6733 2
    ScrnInfoPtr   pScrn       = xf86Screens[scrnIndex];
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d6735 28
a6762 26
    /* when switch mode in dual-head setup, this function will be called
       separately for each screen (depending on which screen the cursor is
       in when user press ctrl-alt-+). Since this function is always
       called when screen already in extensive mode, the sequence of
       setting CRTC2 and CRT_EXT regesters doesn't matter any more, 
       So we set the flag for RADEONRestoreMode here. */
    info->SwitchingMode = TRUE;
    return RADEONModeInit(xf86Screens[scrnIndex], mode);
    info->SwitchingMode = FALSE;
}

/* Used to disallow modes that are not supported by the hardware. */
int RADEONValidMode(int scrnIndex, DisplayModePtr mode,
		    Bool verbose, int flag)
{
    
    /* Searching for native mode timing table embedded in BIOS image.
	   Not working yet. Currently we calculate from FP registers*/
    /******
    ScrnInfoPtr   pScrn = xf86Screens[scrnIndex];
    RADEONInfoPtr info  = RADEONPTR(pScrn);
    if (info->DisplayType == MT_LCD && info->VBIOS) 
    {
	int i;
	for (i = info->FPBIOSstart+0x40; RADEON_BIOS16(i) != 0; i += 2) {
	    int j = RADEON_BIOS16(i);
d6764 1
a6764 25
	    if (mode->CrtcHDisplay == RADEON_BIOS16(j) &&
		mode->CrtcVDisplay == RADEON_BIOS16(j+2)) {
		if (RADEON_BIOS16(j+5)) j  = RADEON_BIOS16(j+5);
		else                    j += 9;

		mode->Clock = (CARD32)RADEON_BIOS16(j) * 10;

		mode->HDisplay   = mode->CrtcHDisplay   =
		    ((RADEON_BIOS16(j+10) & 0x01ff)+1)*8;
		mode->HSyncStart = mode->CrtcHSyncStart =
		    ((RADEON_BIOS16(j+12) & 0x01ff)+1)*8;
		mode->HSyncEnd   = mode->CrtcHSyncEnd   =
		    mode->CrtcHSyncStart + (RADEON_BIOS8(j+14) & 0x1f);
		mode->HTotal     = mode->CrtcHTotal     =
		    ((RADEON_BIOS16(j+8)  & 0x01ff)+1)*8;

		mode->VDisplay   = mode->CrtcVDisplay   =
		    (RADEON_BIOS16(j+17) & 0x07ff)+1;
		mode->VSyncStart = mode->CrtcVSyncStart =
		    (RADEON_BIOS16(j+19) & 0x07ff)+1;
		mode->VSyncEnd   = mode->CrtcVSyncEnd   =
		    mode->CrtcVSyncStart + ((RADEON_BIOS16(j+19) >> 11)&0x1f);
		mode->VTotal     = mode->CrtcVTotal     =
		    (RADEON_BIOS16(j+15) & 0x07ff)+1;
		return MODE_OK;
d6767 49
a6815 2
	return MODE_NOMODE;
    }*****/
d6817 12
d6832 4
a6835 3
/* Adjust viewport into virtual desktop such that (0,0) in viewport space
   is (x,y) in virtual space. */
void RADEONAdjustFrame(int scrnIndex, int x, int y, int flags)
d6837 1
a6837 2
    ScrnInfoPtr   pScrn       = xf86Screens[scrnIndex];
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d6839 4
a6842 3
    int           Base;

    Base = y * info->CurrentLayout.displayWidth + x;
d6853 40
a6892 4
    if(info->IsSecondary)    
    {
        Base += pScrn->fbOffset; 
        OUTREG(RADEON_CRTC2_OFFSET, Base);
d6894 4
a6897 3
    else
    OUTREG(RADEON_CRTC_OFFSET, Base);
      
d6900 3
a6902 2
/* Called when VT switching back to the X server.  Reinitialize the video
   mode. */
d6905 2
a6906 2
    ScrnInfoPtr   pScrn = xf86Screens[scrnIndex];
    RADEONInfoPtr info  = RADEONPTR(pScrn);
d6912 5
a6916 3
        if (!fbdevHWEnterVT(scrnIndex,flags)) return FALSE;
        info->PaletteSavedOnVT = FALSE;
        info->ModeReg.surface_cntl = INREG(RADEON_SURFACE_CNTL);
d6918 12
a6929 1
        if (!RADEONModeInit(pScrn, pScrn->currentMode)) return FALSE;
d6935 1
a6935 1
    if (RADEONPTR(pScrn)->directRenderingEnabled) {
d6941 5
a6945 1
    RADEONAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
d6949 3
a6951 2
/* Called when VT switching away from the X server.  Restore the original
   text mode. */
d6954 3
a6956 3
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    RADEONInfoPtr info  = RADEONPTR(pScrn);
    RADEONSavePtr save  = &info->ModeReg;
d6967 9
a6975 5
        RADEONSavePalette(pScrn, save);
        info->PaletteSavedOnVT = TRUE;
        fbdevHWLeaveVT(scrnIndex,flags);
    } else
        RADEONRestore(pScrn);
d6978 4
a6981 3
/* Called at the end of each server generation.  Restore the original text
   mode, unmap video memory, and unwrap and call the saved CloseScreen
   function.  */
d6984 2
a6985 2
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
    RADEONInfoPtr info  = RADEONPTR(pScrn);
d6997 1
a6997 2
    if (pScrn->vtSema) 
    {	
a6998 1
	RADEONUnmapMem(pScrn);
d7000 1
d7002 2
a7003 2
    if (info->accel)             XAADestroyInfoRec(info->accel);
    info->accel                  = NULL;
d7005 2
a7006 2
    if (info->scratch_save)      xfree(info->scratch_save);
    info->scratch_save           = NULL;
d7008 2
a7009 2
    if (info->cursor)            xf86DestroyCursorInfoRec(info->cursor);
    info->cursor                 = NULL;
d7011 2
a7012 2
    if (info->DGAModes)          xfree(info->DGAModes);
    info->DGAModes               = NULL;
d7016 1
a7016 1
    xf86ClearPrimInitDone(pScrn->entityList[0]);
d7025 1
a7025 1
    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
d7034 1
a7034 1
/* Sets VESA Display Power Management Signaling (DPMS) Mode.  */
d7036 2
a7037 1
					  int PowerManagementMode, int flags)
d7039 1
a7039 1
    RADEONInfoPtr info        = RADEONPTR(pScrn);
d7041 144
a7184 23
    int           mask        = (RADEON_CRTC_DISPLAY_DIS
				 | RADEON_CRTC_HSYNC_DIS
				 | RADEON_CRTC_VSYNC_DIS);

    switch (PowerManagementMode) {
    case DPMSModeOn:
	/* Screen: On; HSync: On, VSync: On */
	OUTREGP(RADEON_CRTC_EXT_CNTL, 0, ~mask);
	break;
    case DPMSModeStandby:
	/* Screen: Off; HSync: Off, VSync: On */
	OUTREGP(RADEON_CRTC_EXT_CNTL,
		RADEON_CRTC_DISPLAY_DIS | RADEON_CRTC_HSYNC_DIS, ~mask);
	break;
    case DPMSModeSuspend:
	/* Screen: Off; HSync: On, VSync: Off */
	OUTREGP(RADEON_CRTC_EXT_CNTL,
		RADEON_CRTC_DISPLAY_DIS | RADEON_CRTC_VSYNC_DIS, ~mask);
	break;
    case DPMSModeOff:
	/* Screen: Off; HSync: Off, VSync: Off */
	OUTREGP(RADEON_CRTC_EXT_CNTL, mask, ~mask);
	break;
d7186 4
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c,v 1.116 2003/11/19 02:08:15 martin Exp $ */
d32 1
a32 1
 *   Kevin E. Martin <martin@@xfree86.org>
d34 1
a34 1
 *   Alan Hourihane <alanh@@fairlite.demon.co.uk>
d55 1
a55 1
 *   shadowfb (Note: dri uses shadowfb for another purpose in radeon_dri.c)
a62 1
#include "radeon_macros.h"
d73 2
d76 11
a96 1
#include "xf86Resources.h"
a106 3
#ifndef MIN
#define MIN(a,b) ((a)>(b)?(b):(a))
#endif
a116 1
static void RADEONInitDispBandwidth(ScrnInfoPtr pScrn);
a124 1
    OPTION_BUS_TYPE,
d126 1
d129 1
a129 2
    OPTION_AGP_FW,
    OPTION_GART_SIZE,
a132 2
    OPTION_PAGE_FLIP,
    OPTION_NO_BACKBUFFER,
d134 1
a134 11
    OPTION_PANEL_OFF,
    OPTION_DDC_MODE,
    OPTION_MONITOR_LAYOUT,
    OPTION_IGNORE_EDID,
    OPTION_CRTC2_OVERLAY,
    OPTION_CLONE_MODE,
    OPTION_CLONE_HSYNC,
    OPTION_CLONE_VREFRESH,
    OPTION_FBDEV,
    OPTION_VIDEO_KEY,
    OPTION_DISP_PRIORITY,
d136 1
a136 1
    OPTION_MIN_DOTCLOCK
d140 4
a143 4
    { OPTION_NOACCEL,        "NoAccel",          OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_SW_CURSOR,      "SWcursor",         OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_DAC_6BIT,       "Dac6Bit",          OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_DAC_8BIT,       "Dac8Bit",          OPTV_BOOLEAN, {0}, TRUE  },
d145 19
a163 28
    { OPTION_IS_PCI,         "ForcePCIMode",     OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_BUS_TYPE,       "BusType",          OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_CP_PIO,         "CPPIOMode",        OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_USEC_TIMEOUT,   "CPusecTimeout",    OPTV_INTEGER, {0}, FALSE },
    { OPTION_AGP_MODE,       "AGPMode",          OPTV_INTEGER, {0}, FALSE },
    { OPTION_AGP_FW,         "AGPFastWrite",     OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_GART_SIZE,      "AGPSize",          OPTV_INTEGER, {0}, FALSE },
    { OPTION_GART_SIZE,      "GARTSize",         OPTV_INTEGER, {0}, FALSE },
    { OPTION_RING_SIZE,      "RingSize",         OPTV_INTEGER, {0}, FALSE },
    { OPTION_BUFFER_SIZE,    "BufferSize",       OPTV_INTEGER, {0}, FALSE },
    { OPTION_DEPTH_MOVE,     "EnableDepthMoves", OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_PAGE_FLIP,      "EnablePageFlip",   OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_NO_BACKBUFFER,  "NoBackBuffer",     OPTV_BOOLEAN, {0}, FALSE },
#endif
    { OPTION_PANEL_OFF,      "PanelOff",         OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_DDC_MODE,       "DDCMode",          OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_MONITOR_LAYOUT, "MonitorLayout",    OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_IGNORE_EDID,    "IgnoreEDID",       OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_CRTC2_OVERLAY , "OverlayOnCRTC2",   OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_CLONE_MODE,     "CloneMode",        OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_CLONE_HSYNC,    "CloneHSync",       OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_CLONE_VREFRESH, "CloneVRefresh",    OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_FBDEV,          "UseFBDev",         OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_VIDEO_KEY,      "VideoKey",         OPTV_INTEGER, {0}, FALSE },
    { OPTION_DISP_PRIORITY,  "DisplayPriority",  OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_PANEL_SIZE,     "PanelSize",        OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_MIN_DOTCLOCK,   "ForceMinDotClock", OPTV_FREQ,    {0}, FALSE },
    { -1,                    NULL,               OPTV_NONE,    {0}, FALSE }
a183 2
    "fbdevHWDPMSSet",

d211 1
d217 10
a244 1
    "xf86ForceHWCursor",
a250 3
    "drmGetInterruptFromBusID",
    "drmCtlInstHandler",
    "drmCtlUninstHandler",
a254 1
    "drmAgpBase",
a262 4
    "drmCommandNone",
    "drmCommandRead",
    "drmCommandWrite",
    "drmCommandWriteRead",
a264 1
    "drmGetLibVersion",
d276 1
a276 2
    "drmScatterGatherAlloc",
    "drmScatterGatherFree",
a287 1
    "DRIGetDeviceInfo",
a295 5

static const char *driShadowFBSymbols[] = {
    "ShadowFBInit",
    NULL
};
a316 69
void RADEONLoaderRefSymLists(void)
{
    /*
     * Tell the loader about symbols from other modules that this module might
     * refer to.
     */
    xf86LoaderRefSymLists(vgahwSymbols,
			  fbSymbols,
			  xaaSymbols,
#if 0
			  xf8_32bppSymbols,
#endif
			  ramdacSymbols,
#ifdef XF86DRI
			  drmSymbols,
			  driSymbols,
			  driShadowFBSymbols,
#endif
			  fbdevHWSymbols,
			  vbeSymbols,
			  int10Symbols,
			  i2cSymbols,
			  ddcSymbols,
			  NULL);
}

/* Established timings from EDID standard */
static struct
{
    int hsize;
    int vsize;
    int refresh;
} est_timings[] = {
    {1280, 1024, 75},
    {1024, 768, 75},
    {1024, 768, 70},
    {1024, 768, 60},
    {1024, 768, 87},
    {832, 624, 75},
    {800, 600, 75},
    {800, 600, 72},
    {800, 600, 60},
    {800, 600, 56},
    {640, 480, 75},
    {640, 480, 72},
    {640, 480, 67},
    {640, 480, 60},
    {720, 400, 88},
    {720, 400, 70},
};

static const RADEONTMDSPll default_tmds_pll[CHIP_FAMILY_LAST][4] =
{
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_UNKNOW*/
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_LEGACY*/
    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RADEON*/
    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV100*/
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_RS100*/
    {{15000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV200*/
    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RS200*/
    {{15000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_R200*/
    {{15500, 0x81b}, {0xffffffff, 0x83f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV250*/
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_RS300*/
    {{13000, 0x400f4}, {15000, 0x400f7}, {0xffffffff, 0x400f7/*0x40111*/}, {0, 0}},	/*CHIP_FAMILY_RV280*/
    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},		/*CHIP_FAMILY_R300*/
    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},		/*CHIP_FAMILY_R350*/
    {{15000, 0xb0155}, {0xffffffff, 0xb01cb}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV350*/
};

d319 4
a322 18
struct RADEONInt10Save {
	CARD32 MEM_CNTL;
	CARD32 MEMSIZE;
	CARD32 MPP_TB_CONFIG;
};

static Bool RADEONMapMMIO(ScrnInfoPtr pScrn);
static Bool RADEONUnmapMMIO(ScrnInfoPtr pScrn);

static RADEONEntPtr RADEONEntPriv(ScrnInfoPtr pScrn)
{
    DevUnion     *pPriv;
    RADEONInfoPtr  info   = RADEONPTR(pScrn);
    pPriv = xf86GetEntityPrivate(info->pEnt->index,
                                 gRADEONEntityIndex);
    return pPriv->ptr;
}

d324 1
a324 1
RADEONPreInt10Save(ScrnInfoPtr pScrn, void **pPtr)
d326 3
a328 4
    RADEONInfoPtr  info   = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    CARD32 CardTmp;
    static struct RADEONInt10Save SaveStruct = { 0, 0, 0 };
d330 15
a344 4
    /* Save the values and zap MEM_CNTL */
    SaveStruct.MEM_CNTL = INREG(RADEON_MEM_CNTL);
    SaveStruct.MEMSIZE = INREG(RADEON_CONFIG_MEMSIZE);
    SaveStruct.MPP_TB_CONFIG = INREG(RADEON_MPP_TB_CONFIG);
d347 1
a347 1
     * Zap MEM_CNTL and set MPP_TB_CONFIG<31:24> to 4
d349 2
a351 3
    CardTmp = SaveStruct.MPP_TB_CONFIG & 0x00ffffffu;
    CardTmp |= 0x04 << 24;
    OUTREG(RADEON_MPP_TB_CONFIG, CardTmp);
d353 5
a357 1
    *pPtr = (void *)&SaveStruct;
d361 1
a361 1
RADEONPostInt10Check(ScrnInfoPtr pScrn, void *ptr)
d363 4
a366 4
    RADEONInfoPtr  info   = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    struct RADEONInt10Save *pSave = ptr;
    CARD32 CardTmp;
d368 4
a371 2
    /* If we don't have a valid (non-zero) saved MEM_CNTL, get out now */
    if (!pSave || !pSave->MEM_CNTL)
d375 10
a384 1
     * If either MEM_CNTL is currently zero or inconistent (configured for
d388 7
a394 5
    CardTmp = INREG(RADEON_MEM_CNTL);
    if (!CardTmp ||
	((CardTmp & 1) &&
	 (((CardTmp >> 8) & 0xff) != ((CardTmp >> 24) & 0xff)))) {
	/* Restore the saved registers */
d396 3
a398 3
		   "Restoring MEM_CNTL (%08lx), setting to %08lx\n",
		   (unsigned long)CardTmp, (unsigned long)pSave->MEM_CNTL);
	OUTREG(RADEON_MEM_CNTL, pSave->MEM_CNTL);
d400 4
a403 7
	CardTmp = INREG(RADEON_CONFIG_MEMSIZE);
	if (CardTmp != pSave->MEMSIZE) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Restoring CONFIG_MEMSIZE (%08lx), setting to %08lx\n",
		       (unsigned long)CardTmp, (unsigned long)pSave->MEMSIZE);
	    OUTREG(RADEON_CONFIG_MEMSIZE, pSave->MEMSIZE);
	}
d406 5
a410 10
    CardTmp = INREG(RADEON_MPP_TB_CONFIG);
    if ((CardTmp & 0xff000000u) != (pSave->MPP_TB_CONFIG & 0xff000000u)) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Restoring MPP_TB_CONFIG<31:24> (%02lx), setting to %02lx\n",
		   (unsigned long)CardTmp >> 24,
		   (unsigned long)pSave->MPP_TB_CONFIG >> 24);
	CardTmp &= 0x00ffffffu;
	CardTmp |= (pSave->MPP_TB_CONFIG & 0xff000000u);
	OUTREG(RADEON_MPP_TB_CONFIG, CardTmp);
    }
d413 7
a419 1
/* Allocate our private RADEONInfoRec */
d428 1
a428 1
/* Free our private RADEONInfoRec */
d437 1
a437 2
 * below
 */
d440 1
a440 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d457 1
a457 2
 * below
 */
d460 1
a460 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d474 1
a474 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d493 1
a493 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d503 1
a503 1
/* Memory map the MMIO region and the frame buffer */
d514 1
a514 1
/* Unmap the MMIO region and the frame buffer */
a520 17
/* This function is required to workaround a hardware bug in some (all?)
 * revisions of the R300.  This workaround should be called after every
 * CLOCK_CNTL_INDEX register access.  If not, register reads afterward
 * may not be correct.
 */
void R300CGWorkaround(ScrnInfoPtr pScrn) {
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    CARD32         save, tmp;

    save = INREG(RADEON_CLOCK_CNTL_INDEX);
    tmp = save & ~(0x3f | RADEON_PLL_WR_EN);
    OUTREG(RADEON_CLOCK_CNTL_INDEX, tmp);
    tmp = INREG(RADEON_CLOCK_CNTL_DATA);
    OUTREG(RADEON_CLOCK_CNTL_INDEX, save);
}

d524 1
a524 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
a525 1
    CARD32         data;
d527 8
a534 5
    OUTREG8(RADEON_CLOCK_CNTL_INDEX, addr & 0x3f);
    data = INREG(RADEON_CLOCK_CNTL_DATA);
    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);

    return data;
d538 1
a538 1
/* Read PAL information (only used for debugging) */
d541 1
a541 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d549 1
a549 1
/* Wait for vertical sync on primary CRTC */
d552 1
a552 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d554 1
a554 1
    int            i;
d556 3
a558 7
    /* Clear the CRTC_VBLANK_SAVE bit */
    OUTREG(RADEON_CRTC_STATUS, RADEON_CRTC_VBLANK_SAVE_CLEAR);

    /* Wait for it to go back up */
    for (i = 0; i < RADEON_TIMEOUT/1000; i++) {
	if (INREG(RADEON_CRTC_STATUS) & RADEON_CRTC_VBLANK_SAVE) break;
	usleep(1);
d562 2
a563 2
/* Wait for vertical sync on secondary CRTC */
void RADEONWaitForVerticalSync2(ScrnInfoPtr pScrn)
d565 1
a565 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
a566 1
    int            i;
d568 31
a598 7
    /* Clear the CRTC2_VBLANK_SAVE bit */
    OUTREG(RADEON_CRTC2_STATUS, RADEON_CRTC2_VBLANK_SAVE_CLEAR);

    /* Wait for it to go back up */
    for (i = 0; i < RADEON_TIMEOUT/1000; i++) {
	if (INREG(RADEON_CRTC2_STATUS) & RADEON_CRTC2_VBLANK_SAVE) break;
	usleep(1);
d602 2
a603 2
/* Blank screen */
static void RADEONBlank(ScrnInfoPtr pScrn)
d605 1
a605 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d607 37
a643 23

    if (!info->IsSecondary) {
	switch(info->DisplayType) {
	case MT_LCD:
	case MT_CRT:
	case MT_DFP:
	    OUTREGP(RADEON_CRTC_EXT_CNTL,
		    RADEON_CRTC_DISPLAY_DIS,
		    ~(RADEON_CRTC_DISPLAY_DIS));
	    break;

	case MT_NONE:
	default:
	    break;
	}
	if (info->Clone)
	    OUTREGP(RADEON_CRTC2_GEN_CNTL,
		    RADEON_CRTC2_DISP_DIS,
		    ~(RADEON_CRTC2_DISP_DIS));
    } else {
	OUTREGP(RADEON_CRTC2_GEN_CNTL,
		RADEON_CRTC2_DISP_DIS,
		~(RADEON_CRTC2_DISP_DIS));
d647 4
a650 2
/* Unblank screen */
static void RADEONUnblank(ScrnInfoPtr pScrn)
d652 1
a652 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d654 1
d656 33
a688 32
    if (!info->IsSecondary) {
	switch (info->DisplayType) {
	case MT_LCD:
	case MT_CRT:
	case MT_DFP:
	    OUTREGP(RADEON_CRTC_EXT_CNTL,
		    RADEON_CRTC_CRT_ON,
		    ~(RADEON_CRTC_DISPLAY_DIS));
	    break;

	case MT_NONE:
	default:
	    break;
	}
	if (info->Clone)
	    OUTREGP(RADEON_CRTC2_GEN_CNTL,
		    0,
		    ~(RADEON_CRTC2_DISP_DIS));
    } else {
	switch (info->DisplayType) {
	case MT_LCD:
	case MT_DFP:
	case MT_CRT:
	    OUTREGP(RADEON_CRTC2_GEN_CNTL,
		    0,
		    ~(RADEON_CRTC2_DISP_DIS));
	    break;

	case MT_NONE:
	default:
	    break;
	}
d691 1
d693 1
a693 1
/* Compute log base 2 of val */
d696 1
a696 1
    int  bits;
d703 1
a703 1
/* Compute n/d with rounding */
d709 2
a710 1
static RADEONMonitorType RADEONDisplayDDCConnected(ScrnInfoPtr pScrn, RADEONDDCType DDCType, xf86MonPtr* MonInfo)
d712 19
a730 5
    RADEONInfoPtr info = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    unsigned long DDCReg;
    RADEONMonitorType MonType = MT_NONE;
    int i, j;
d732 20
a751 2
    DDCReg = info->DDCReg;
    switch(DDCType)
d753 6
a758 15
    case DDC_MONID:
	info->DDCReg = RADEON_GPIO_MONID;
	break;
    case DDC_DVI:
	info->DDCReg = RADEON_GPIO_DVI_DDC;
	break;
    case DDC_VGA:
	info->DDCReg = RADEON_GPIO_VGA_DDC;
	break;
    case DDC_CRT2:
	info->DDCReg = RADEON_GPIO_CRT2_DDC;
	break;
    default:
	info->DDCReg = DDCReg;
	return MT_NONE;
d761 1
a761 4
    /* Read and output monitor info using DDC2 over I2C bus */
    if (info->pI2CBus && info->ddc2) {
	OUTREG(info->DDCReg, INREG(info->DDCReg) &
	       (CARD32)~(RADEON_GPIO_A_0 | RADEON_GPIO_A_1));
d763 178
a940 17
	/* For some old monitors (like Compaq Presario FP500), we need
	 * following process to initialize/stop DDC
	 */
	OUTREG(info->DDCReg, INREG(info->DDCReg) & ~(RADEON_GPIO_EN_1));
	for (j = 0; j < 3; j++) {
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_0));
	    usleep(13000);

	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_1));
	    for (i = 0; i < 10; i++) {
		usleep(15000);
		if (INREG(info->DDCReg) & RADEON_GPIO_Y_1)
		    break;
	    }
	    if (i == 10) continue;
d942 2
a943 1
	    usleep(15000);
d945 8
a952 2
	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_0);
	    usleep(15000);
d954 16
a969 27
	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_1);
	    usleep(15000);
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_0));
	    usleep(15000);
	    *MonInfo = xf86DoEDID_DDC2(pScrn->scrnIndex, info->pI2CBus);

	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_1);
	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_0);
	    usleep(15000);
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_1));
	    for (i = 0; i < 5; i++) {
		usleep(15000);
		if (INREG(info->DDCReg) & RADEON_GPIO_Y_1)
		    break;
	    }
	    usleep(15000);
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_0));
	    usleep(15000);

	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_1);
	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_0);
	    usleep(15000);
	    if(*MonInfo) break;
	}
d971 10
a980 2
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "DDC2/I2C is not properly initialized\n");
	MonType = MT_NONE;
a982 9
    if (*MonInfo) {
	if ((*MonInfo)->rawData[0x14] & 0x80) {
	    if (INREG(RADEON_LVDS_GEN_CNTL) & RADEON_LVDS_ON) MonType = MT_LCD;
	    else MonType = MT_DFP;
	} else MonType = MT_CRT;
    } else MonType = MT_NONE;

    info->DDCReg = DDCReg;

d984 6
a989 1
	       "DDC Type: %d, Detected Type: %d\n", DDCType, MonType);
d991 1
a991 1
    return MonType;
d994 2
a995 2
static RADEONMonitorType
RADEONCrtIsPhysicallyConnected(ScrnInfoPtr pScrn, int IsCrtDac)
d997 17
a1013 3
    RADEONInfoPtr info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int		  bConnected = 0;
d1015 1
a1015 36
    /* the monitor either wasn't connected or it is a non-DDC CRT.
     * try to probe it
     */
    if(IsCrtDac) {
	unsigned long ulOrigVCLK_ECP_CNTL;
	unsigned long ulOrigDAC_CNTL;
	unsigned long ulOrigDAC_EXT_CNTL;
	unsigned long ulOrigCRTC_EXT_CNTL;
	unsigned long ulData;
	unsigned long ulMask;

	ulOrigVCLK_ECP_CNTL = INPLL(pScrn, RADEON_VCLK_ECP_CNTL);

	ulData              = ulOrigVCLK_ECP_CNTL;
	ulData             &= ~(RADEON_PIXCLK_ALWAYS_ONb
				| RADEON_PIXCLK_DAC_ALWAYS_ONb);
	ulMask              = ~(RADEON_PIXCLK_ALWAYS_ONb
				|RADEON_PIXCLK_DAC_ALWAYS_ONb);
	OUTPLLP(pScrn, RADEON_VCLK_ECP_CNTL, ulData, ulMask);

	ulOrigCRTC_EXT_CNTL = INREG(RADEON_CRTC_EXT_CNTL);
	ulData              = ulOrigCRTC_EXT_CNTL;
	ulData             |= RADEON_CRTC_CRT_ON;
	OUTREG(RADEON_CRTC_EXT_CNTL, ulData);

	ulOrigDAC_EXT_CNTL = INREG(RADEON_DAC_EXT_CNTL);
	ulData             = ulOrigDAC_EXT_CNTL;
	ulData            &= ~RADEON_DAC_FORCE_DATA_MASK;
	ulData            |=  (RADEON_DAC_FORCE_BLANK_OFF_EN
			       |RADEON_DAC_FORCE_DATA_EN
			       |RADEON_DAC_FORCE_DATA_SEL_MASK);
	if ((info->ChipFamily == CHIP_FAMILY_RV250) ||
	    (info->ChipFamily == CHIP_FAMILY_RV280))
	    ulData |= (0x01b6 << RADEON_DAC_FORCE_DATA_SHIFT);
	else
	    ulData |= (0x01ac << RADEON_DAC_FORCE_DATA_SHIFT);
d1017 8
a1024 1
	OUTREG(RADEON_DAC_EXT_CNTL, ulData);
d1026 5
a1030 29
	ulOrigDAC_CNTL     = INREG(RADEON_DAC_CNTL);
	ulData             = ulOrigDAC_CNTL;
	ulData            |= RADEON_DAC_CMP_EN;
	ulData            &= ~(RADEON_DAC_RANGE_CNTL_MASK
			       | RADEON_DAC_PDWN);
	ulData            |= 0x2;
	OUTREG(RADEON_DAC_CNTL, ulData);

	usleep(1000);

	ulData     = INREG(RADEON_DAC_CNTL);
	bConnected =  (RADEON_DAC_CMP_OUTPUT & ulData)?1:0;

	ulData    = ulOrigVCLK_ECP_CNTL;
	ulMask    = 0xFFFFFFFFL;
	OUTPLLP(pScrn, RADEON_VCLK_ECP_CNTL, ulData, ulMask);

	OUTREG(RADEON_DAC_CNTL,      ulOrigDAC_CNTL     );
	OUTREG(RADEON_DAC_EXT_CNTL,  ulOrigDAC_EXT_CNTL );
	OUTREG(RADEON_CRTC_EXT_CNTL, ulOrigCRTC_EXT_CNTL);
    } else { /* TV DAC */

        /* This doesn't seem to work reliably (maybe worse on some OEM cards),
           for now we always return false. If one wants to connected a
           non-DDC monitor on the DVI port when CRT port is also connected,
           he will need to explicitly tell the driver in the config file
           with Option MonitorLayout.
        */
        bConnected = FALSE;
d1032 6
a1037 2
#if 0
	if (info->ChipFamily == CHIP_FAMILY_R200) {
a1038 56
	    unsigned long ulOrigGPIO_MONID;
	    unsigned long ulOrigFP2_GEN_CNTL;
	    unsigned long ulOrigDISP_OUTPUT_CNTL;
	    unsigned long ulOrigCRTC2_GEN_CNTL;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_A;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_B;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_C;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_D;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_E;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_F;
	    unsigned long ulOrigCRTC2_H_TOTAL_DISP;
	    unsigned long ulOrigCRTC2_V_TOTAL_DISP;
	    unsigned long ulOrigCRTC2_H_SYNC_STRT_WID;
	    unsigned long ulOrigCRTC2_V_SYNC_STRT_WID;
	    unsigned long ulData, i;

	    ulOrigGPIO_MONID = INREG(RADEON_GPIO_MONID);
	    ulOrigFP2_GEN_CNTL = INREG(RADEON_FP2_GEN_CNTL);
	    ulOrigDISP_OUTPUT_CNTL = INREG(RADEON_DISP_OUTPUT_CNTL);
	    ulOrigCRTC2_GEN_CNTL = INREG(RADEON_CRTC2_GEN_CNTL);
	    ulOrigDISP_LIN_TRANS_GRPH_A = INREG(RADEON_DISP_LIN_TRANS_GRPH_A);
	    ulOrigDISP_LIN_TRANS_GRPH_B = INREG(RADEON_DISP_LIN_TRANS_GRPH_B);
	    ulOrigDISP_LIN_TRANS_GRPH_C = INREG(RADEON_DISP_LIN_TRANS_GRPH_C);
	    ulOrigDISP_LIN_TRANS_GRPH_D = INREG(RADEON_DISP_LIN_TRANS_GRPH_D);
	    ulOrigDISP_LIN_TRANS_GRPH_E = INREG(RADEON_DISP_LIN_TRANS_GRPH_E);
	    ulOrigDISP_LIN_TRANS_GRPH_F = INREG(RADEON_DISP_LIN_TRANS_GRPH_F);

	    ulOrigCRTC2_H_TOTAL_DISP = INREG(RADEON_CRTC2_H_TOTAL_DISP);
	    ulOrigCRTC2_V_TOTAL_DISP = INREG(RADEON_CRTC2_V_TOTAL_DISP);
	    ulOrigCRTC2_H_SYNC_STRT_WID = INREG(RADEON_CRTC2_H_SYNC_STRT_WID);
	    ulOrigCRTC2_V_SYNC_STRT_WID = INREG(RADEON_CRTC2_V_SYNC_STRT_WID);

	    ulData     = INREG(RADEON_GPIO_MONID);
	    ulData    &= ~RADEON_GPIO_A_0;
	    OUTREG(RADEON_GPIO_MONID, ulData);

	    OUTREG(RADEON_FP2_GEN_CNTL, 0x0a000c0c);

	    OUTREG(RADEON_DISP_OUTPUT_CNTL, 0x00000012);

	    OUTREG(RADEON_CRTC2_GEN_CNTL, 0x06000000);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_A, 0x00000000);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_B, 0x000003f0);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_C, 0x00000000);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_D, 0x000003f0);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_E, 0x00000000);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_F, 0x000003f0);
	    OUTREG(RADEON_CRTC2_H_TOTAL_DISP, 0x01000008);
	    OUTREG(RADEON_CRTC2_H_SYNC_STRT_WID, 0x00000800);
	    OUTREG(RADEON_CRTC2_V_TOTAL_DISP, 0x00080001);
	    OUTREG(RADEON_CRTC2_V_SYNC_STRT_WID, 0x00000080);

	    for (i = 0; i < 200; i++) {
		ulData     = INREG(RADEON_GPIO_MONID);
		bConnected = (ulData & RADEON_GPIO_Y_0)?1:0;
		if (!bConnected) break;
d1040 1
a1040 2
		usleep(1000);
	    }
d1042 5
a1046 78
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_A, ulOrigDISP_LIN_TRANS_GRPH_A);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_B, ulOrigDISP_LIN_TRANS_GRPH_B);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_C, ulOrigDISP_LIN_TRANS_GRPH_C);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_D, ulOrigDISP_LIN_TRANS_GRPH_D);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_E, ulOrigDISP_LIN_TRANS_GRPH_E);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_F, ulOrigDISP_LIN_TRANS_GRPH_F);
	    OUTREG(RADEON_CRTC2_H_TOTAL_DISP, ulOrigCRTC2_H_TOTAL_DISP);
	    OUTREG(RADEON_CRTC2_V_TOTAL_DISP, ulOrigCRTC2_V_TOTAL_DISP);
	    OUTREG(RADEON_CRTC2_H_SYNC_STRT_WID, ulOrigCRTC2_H_SYNC_STRT_WID);
	    OUTREG(RADEON_CRTC2_V_SYNC_STRT_WID, ulOrigCRTC2_V_SYNC_STRT_WID);
	    OUTREG(RADEON_CRTC2_GEN_CNTL, ulOrigCRTC2_GEN_CNTL);
	    OUTREG(RADEON_DISP_OUTPUT_CNTL, ulOrigDISP_OUTPUT_CNTL);
	    OUTREG(RADEON_FP2_GEN_CNTL, ulOrigFP2_GEN_CNTL);
	    OUTREG(RADEON_GPIO_MONID, ulOrigGPIO_MONID);
        } else {
	    unsigned long ulOrigPIXCLKSDATA;
	    unsigned long ulOrigTV_MASTER_CNTL;
	    unsigned long ulOrigTV_DAC_CNTL;
	    unsigned long ulOrigTV_PRE_DAC_MUX_CNTL;
	    unsigned long ulOrigDAC_CNTL2;
	    unsigned long ulData;
	    unsigned long ulMask;

	    ulOrigPIXCLKSDATA = INPLL(pScrn, RADEON_PIXCLKS_CNTL);

	    ulData            = ulOrigPIXCLKSDATA;
	    ulData           &= ~(RADEON_PIX2CLK_ALWAYS_ONb
				  | RADEON_PIX2CLK_DAC_ALWAYS_ONb);
	    ulMask            = ~(RADEON_PIX2CLK_ALWAYS_ONb
			  | RADEON_PIX2CLK_DAC_ALWAYS_ONb);
	    OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL, ulData, ulMask);

	    ulOrigTV_MASTER_CNTL = INREG(RADEON_TV_MASTER_CNTL);
	    ulData               = ulOrigTV_MASTER_CNTL;
	    ulData              &= ~RADEON_TVCLK_ALWAYS_ONb;
	    OUTREG(RADEON_TV_MASTER_CNTL, ulData);

	    ulOrigDAC_CNTL2 = INREG(RADEON_DAC_CNTL2);
	    ulData          = ulOrigDAC_CNTL2;
	    ulData          &= ~RADEON_DAC2_DAC2_CLK_SEL;
	    OUTREG(RADEON_DAC_CNTL2, ulData);

	    ulOrigTV_DAC_CNTL = INREG(RADEON_TV_DAC_CNTL);

	    ulData  = 0x00880213;
	    OUTREG(RADEON_TV_DAC_CNTL, ulData);

	    ulOrigTV_PRE_DAC_MUX_CNTL = INREG(RADEON_TV_PRE_DAC_MUX_CNTL);

	    ulData  =  (RADEON_Y_RED_EN
			| RADEON_C_GRN_EN
			| RADEON_CMP_BLU_EN
			| RADEON_RED_MX_FORCE_DAC_DATA
			| RADEON_GRN_MX_FORCE_DAC_DATA
			| RADEON_BLU_MX_FORCE_DAC_DATA);
            if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		(info->ChipFamily == CHIP_FAMILY_R350) ||
		(info->ChipFamily == CHIP_FAMILY_RV350))
		ulData |= 0x180 << RADEON_TV_FORCE_DAC_DATA_SHIFT;
	    else
		ulData |= 0x1f5 << RADEON_TV_FORCE_DAC_DATA_SHIFT;
	    OUTREG(RADEON_TV_PRE_DAC_MUX_CNTL, ulData);

	    usleep(1000);

	    ulData     = INREG(RADEON_TV_DAC_CNTL);
	    bConnected = (ulData & RADEON_TV_DAC_CMPOUT)?1:0;

	    ulData    = ulOrigPIXCLKSDATA;
	    ulMask    = 0xFFFFFFFFL;
	    OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL, ulData, ulMask);

	    OUTREG(RADEON_TV_MASTER_CNTL, ulOrigTV_MASTER_CNTL);
	    OUTREG(RADEON_DAC_CNTL2, ulOrigDAC_CNTL2);
	    OUTREG(RADEON_TV_DAC_CNTL, ulOrigTV_DAC_CNTL);
	    OUTREG(RADEON_TV_PRE_DAC_MUX_CNTL, ulOrigTV_PRE_DAC_MUX_CNTL);
	}
#endif
d1048 1
a1049 1
    return(bConnected ? MT_CRT : MT_NONE);
d1052 2
a1053 1
static void RADEONQueryConnectedDisplays(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
d1055 1
a1055 819
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    const char *s;
    Bool ignore_edid = FALSE, ddc_crt2_used = FALSE;

#define RADEON_BIOS8(v)  (info->VBIOS[v])
#define RADEON_BIOS16(v) (info->VBIOS[v] | \
			  (info->VBIOS[(v) + 1] << 8))
#define RADEON_BIOS32(v) (info->VBIOS[v] | \
			  (info->VBIOS[(v) + 1] << 8) | \
			  (info->VBIOS[(v) + 2] << 16) | \
			  (info->VBIOS[(v) + 3] << 24))

    pRADEONEnt->MonType1 = MT_NONE;
    pRADEONEnt->MonType2 = MT_NONE;
    pRADEONEnt->MonInfo1 = NULL;
    pRADEONEnt->MonInfo2 = NULL;
    pRADEONEnt->ReversedDAC = FALSE;
    pRADEONEnt->ReversedTMDS = FALSE;

    /* IgnoreEDID option is different from NoDDC options used by DDC module
     * When IgnoreEDID is used, monitor detection will still use DDC
     * detection, but all EDID data will not be used in mode validation.
     */
    if (xf86GetOptValBool(info->Options, OPTION_IGNORE_EDID, &ignore_edid)) {
	if (ignore_edid)
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       "IgnoreEDID is specified, EDID data will be ignored\n");
    }

    /*
     * MonitorLayout option takes a string for two monitors connected in following format:
     * Option "MonitorLayout" "primary-port-display, secondary-port-display"
     * primary and secondary port displays can have one of following:
     *    NONE, CRT, LVDS, TMDS
     * With this option, driver will bring up monitors as specified,
     * not using auto-detection routines to probe monitors.
     */

    /* current monitor mapping scheme:
     *  Two displays connected:
     *     Primary Port:
     *     CRTC1 -> FP/TMDS  -> DVI port -> TMDS panel  --> Primary or
     *     CRTC1 -> FP/LVDS  -> Int. LCD -> LVDS panel  --> Primary or
     *     CRTC1 -> TV DAC   -> DVI port -> CRT monitor --> Primary
     *
     *     Secondary Port
     *     CRTC2 -> CRT DAC  -> VGA port -> CRT monitor --> Secondary or
     *     CRTC2 -> FP2/Ext. -> DVI port -> TMDS panel  --> Secondary
     *
     *  Only DVI (or Int. LDC) conneced:
     *     CRTC1 -> FP/TMDS  -> DVI port -> TMDS panel  --> Primary or
     *     CRTC1 -> FP/LVDS  -> Int. LCD -> LVDS panel  --> Primary or
     *     CRTC1 -> TV DAC   -> DVI port -> CRT monitor --> Primary
     *
     *  Only VGA (can be DVI on some dual-DVI boards) connected:
     *     CRTC1 -> CRT DAC  -> VGA port -> CRT monitor --> Primary or
     *     CRTC1 -> FP2/Ext. -> DVI port -> TMDS panel  --> Primary (not supported)
     *
     * Note, this is different from Windows scheme where
     *   if a digital panel is connected to DVI port, DVI will be the 1st port
     *   otherwise, VGA port will be treated as 1st port
     *
     *   Here we always treat DVI port as primary if both ports are connected.
     *   When only one port is connected, it will be treated as
     *   primary regardless which port or what type of display is involved.
     */

    if ((s = xf86GetOptValString(info->Options, OPTION_MONITOR_LAYOUT))) {
	char s1[5], s2[5];
	int i = 0, second = 0;

	/* When using user specified monitor types, we will not do DDC detection
	 *
	 */
	do {
	    switch(*s)
            {
            case ',':
		s1[i] = '\0';
		i = 0;
		second = 1;
		break;
	    case ' ':
	    case '\t':
	    case '\n':
	    case '\r':
		break;
	    default:
		if (second)
		    s2[i] = *s;
		else
		    s1[i] = *s;
		i++;
		if (i == 4) break;
	    }
	} while(*s++);
	s2[i] = '\0';

	if (strcmp(s1, "NONE") == 0)
	    pRADEONEnt->MonType1 = MT_NONE;
	else if (strcmp(s1, "CRT") == 0)
	    pRADEONEnt->MonType1 = MT_CRT;
	else if (strcmp(s1, "TMDS") == 0)
	    pRADEONEnt->MonType1 = MT_DFP;
	else if (strcmp(s1, "LVDS") == 0)
	    pRADEONEnt->MonType1 = MT_LCD;
	else
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Invalid Monitor type specified for 1st port \n");
	if (strcmp(s2, "NONE") == 0)
	    pRADEONEnt->MonType2 = MT_NONE;
	else if (strcmp(s2, "CRT") == 0)
	    pRADEONEnt->MonType2 = MT_CRT;
	else if (strcmp(s2, "TMDS") == 0)
	    pRADEONEnt->MonType2 = MT_DFP;
	else if (strcmp(s2, "LVDS") == 0)
	    pRADEONEnt->MonType2 = MT_LCD;
	else
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Invalid Monitor type specified for 2nd port \n");

	if (!ignore_edid) {
	    if (pRADEONEnt->MonType1)  /* assuming the first port using DDC_DVI */
		if(!RADEONDisplayDDCConnected(pScrn, DDC_DVI, &pRADEONEnt->MonInfo1)) {
		    RADEONDisplayDDCConnected(pScrn, DDC_CRT2, &pRADEONEnt->MonInfo1);
		    ddc_crt2_used = TRUE;
		}
	    if (pRADEONEnt->MonType2) {  /* assuming the second port using DDC_VGA/DDC_CRT2 */
		if(!RADEONDisplayDDCConnected(pScrn, DDC_VGA, &pRADEONEnt->MonInfo2))
		    if (!ddc_crt2_used)
			RADEONDisplayDDCConnected(pScrn, DDC_CRT2, &pRADEONEnt->MonInfo2);
	    }
	}

	if (!pRADEONEnt->MonType1) {
	    if (pRADEONEnt->MonType2) {
		pRADEONEnt->MonType1 = pRADEONEnt->MonType2;
		pRADEONEnt->MonInfo1 = pRADEONEnt->MonInfo2;
	    } else {
		pRADEONEnt->MonType1 = MT_CRT;
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                       "No valid monitor specified, force to CRT on 1st port\n");
	    }
	    pRADEONEnt->MonType2 = MT_NONE;
	    pRADEONEnt->MonInfo2 = NULL;
	}
    } else {
	/* Auto detection */
	int i;
	CARD32 tmp;

	/* Old single head radeon cards */
        if(!info->HasCRTC2) {
	    if((pRADEONEnt->MonType1 = RADEONDisplayDDCConnected(pScrn, DDC_DVI, &pRADEONEnt->MonInfo1)));
	    else if((pRADEONEnt->MonType1 = RADEONDisplayDDCConnected(pScrn, DDC_VGA, &pRADEONEnt->MonInfo1)));
	    else if((pRADEONEnt->MonType1 = RADEONDisplayDDCConnected(pScrn, DDC_CRT2, &pRADEONEnt->MonInfo1)));
	    else if (pInt10) {
		if (xf86LoadSubModule(pScrn, "vbe")) {
		    vbeInfoPtr  pVbe;
		    pVbe = VBEInit(pInt10, info->pEnt->index);
		    if (pVbe) {
			for (i = 0; i < 5; i++) {
			    pRADEONEnt->MonInfo1 = vbeDoEDID(pVbe, NULL);
			}
			if (pRADEONEnt->MonInfo1->rawData[0x14] & 0x80)
			    pRADEONEnt->MonType1 = MT_DFP;
			else pRADEONEnt->MonType1 = MT_CRT;
		    }
		}
	    } else
		pRADEONEnt->MonType1 = MT_CRT;

	    pRADEONEnt->HasSecondary = FALSE;
	    if (!ignore_edid) {
		if (pRADEONEnt->MonInfo1) {
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitor1 EDID data ---------------------------\n");
		    xf86PrintEDID( pRADEONEnt->MonInfo1 );
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "End of Monitor1 EDID data --------------------\n");
		}
	    }
	    return;
	}

	/* Normally the port uses DDC_DVI connected with TVDAC,
	 * But this is not true for OEM cards which have TVDAC and CRT DAC reversed.
	 * If that's the case, we need also reverse the port arrangement.
	 * BIOS settings are supposed report this correctly, work fine for all cards tested.
	 * But there may be some exceptions, in that case, user can reverse their monitor
	 * definition in config file to correct the problem.
	 */
	if (info->VBIOS && (tmp = RADEON_BIOS16(info->FPBIOSstart + 0x50))) {
	    for (i = 1; i < 4; i++) {
		unsigned int tmp0;
		if (!RADEON_BIOS8(tmp + i*2) && i > 1) break;
		tmp0 = RADEON_BIOS16(tmp + i*2);
		if ((!(tmp0 & 0x01)) && (((tmp0 >> 8) & 0xf) == DDC_DVI)) {
		    pRADEONEnt->ReversedDAC = TRUE;
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Reversed DACs detected\n");
		}
		if ((((tmp0 >> 8) & 0x0f) == DDC_DVI ) && ((tmp0 >> 4) & 0x1)) {
		    pRADEONEnt->ReversedTMDS = TRUE;
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Reversed TMDS detected\n");
		}
	    }
	}

	/* Primary Head (DVI or Laptop Int. panel)*/
	/* A ddc capable display connected on DVI port */
	if((pRADEONEnt->MonType1 = RADEONDisplayDDCConnected(pScrn, DDC_DVI, &pRADEONEnt->MonInfo1)));
	else if((pRADEONEnt->MonType1 =
		 RADEONDisplayDDCConnected(pScrn, DDC_CRT2, &pRADEONEnt->MonInfo1))) {
	  ddc_crt2_used = TRUE;
	} else if ((info->IsMobility) &&
		   (info->VBIOS && (INREG(RADEON_BIOS_4_SCRATCH) & 4))) {
	    /* non-DDC laptop panel connected on primary */
	    pRADEONEnt->MonType1 = MT_LCD;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Non-DDC laptop panel detected\n");
	} else {
	    /* CRT on DVI, TODO: not reliable, make it always return false for now*/
	    pRADEONEnt->MonType1 = RADEONCrtIsPhysicallyConnected(pScrn, pRADEONEnt->ReversedDAC);
	}

	/* Secondary Head (mostly VGA, can be DVI on some OEM boards)*/
	if((pRADEONEnt->MonType2 =
	    RADEONDisplayDDCConnected(pScrn, DDC_VGA, &pRADEONEnt->MonInfo2)));
	else if(!ddc_crt2_used)
	  pRADEONEnt->MonType2 =
		 RADEONDisplayDDCConnected(pScrn, DDC_CRT2, &pRADEONEnt->MonInfo2);
	if (!pRADEONEnt->MonType2)
	    pRADEONEnt->MonType2 = RADEONCrtIsPhysicallyConnected(pScrn, !pRADEONEnt->ReversedDAC);

	if(pRADEONEnt->ReversedTMDS) {
	    /* always keep internal TMDS as primary head */
	    if (pRADEONEnt->MonType1 == MT_DFP ||
		pRADEONEnt->MonType2 == MT_DFP) {
		int tmp1 = pRADEONEnt->MonType1;
		xf86MonPtr MonInfo = pRADEONEnt->MonInfo1;
		pRADEONEnt->MonInfo1 = pRADEONEnt->MonInfo2;
		pRADEONEnt->MonInfo2 = MonInfo;
		pRADEONEnt->MonType1 = pRADEONEnt->MonType2;
		pRADEONEnt->MonType2 = tmp1;
		if ((pRADEONEnt->MonType1 == MT_CRT) ||
		    (pRADEONEnt->MonType2 == MT_CRT)) {
		    pRADEONEnt->ReversedDAC ^= 1;
		}
	    }
	}

	/* no display detected on DVI port*/
	if (pRADEONEnt->MonType1 == MT_NONE) {
	    if (pRADEONEnt->MonType2 != MT_NONE) {
		/* Only one detected on VGA, let it to be primary */
		pRADEONEnt->MonType1 = pRADEONEnt->MonType2;
		pRADEONEnt->MonInfo1 = pRADEONEnt->MonInfo2;
		pRADEONEnt->MonType2 = MT_NONE;
		pRADEONEnt->MonInfo2 = NULL;
	    } else {
		/* Non detected, Default to a CRT connected */
		pRADEONEnt->MonType1 = MT_CRT;
	    }
	}
    }

    if(s) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Displays Configured by MonitorLayout: \n\tMonitor1--Type %d, Monitor2--Type %d\n\n",
		   pRADEONEnt->MonType1, pRADEONEnt->MonType2);
    } else {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Displays Detected: Monitor1--Type %d, Monitor2--Type %d\n\n",
		   pRADEONEnt->MonType1, pRADEONEnt->MonType2);
    }

    if(ignore_edid) {
	pRADEONEnt->MonInfo1 = NULL;
	pRADEONEnt->MonInfo2 = NULL;
    }

    if (!ignore_edid) {
	if (pRADEONEnt->MonInfo1) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitor1 EDID data ---------------------------\n");
	    xf86PrintEDID( pRADEONEnt->MonInfo1 );
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "End of Monitor1 EDID data --------------------\n");
	}
	if (pRADEONEnt->MonInfo2) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitor2 EDID data ---------------------------\n");
	    xf86PrintEDID( pRADEONEnt->MonInfo2 );
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "End of Monitor2 EDID data --------------------\n");
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "\n");

    info->OverlayOnCRTC2 = FALSE;
   if (xf86ReturnOptValBool(info->Options, OPTION_CRTC2_OVERLAY, FALSE)) {
	info->OverlayOnCRTC2 = TRUE;
    }

    if (pRADEONEnt->MonType2 == MT_NONE)
	pRADEONEnt->HasSecondary = FALSE;
}


/* Read the Video BIOS block and the FP registers (if applicable). */
static Bool RADEONGetBIOSParameters(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
{
    RADEONInfoPtr  info            = RADEONPTR(pScrn);
    unsigned long  tmp, i;

    if (!(info->VBIOS = xalloc(RADEON_VBIOS_SIZE))) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Cannot allocate space for hold Video BIOS!\n");
	return FALSE;
    }

    if (pInt10) {
	info->BIOSAddr = pInt10->BIOSseg << 4;
	(void)memcpy(info->VBIOS, xf86int10Addr(pInt10, info->BIOSAddr),
		     RADEON_VBIOS_SIZE);
    } else {
	xf86ReadPciBIOS(0, info->PciTag, 0, info->VBIOS, RADEON_VBIOS_SIZE);
	if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Video BIOS not detected in PCI space!\n");
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Attempting to read Video BIOS from "
		       "legacy ISA space!\n");
	    info->BIOSAddr = 0x000c0000;
	    xf86ReadDomainMemory(info->PciTag, info->BIOSAddr,
				 RADEON_VBIOS_SIZE, info->VBIOS);
	}
    }

    if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
	xfree(info->VBIOS);
	info->FPBIOSstart = 0;
	info->VBIOS = NULL;
	info->BIOSAddr = 0x00000000;
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "Video BIOS not found!\n");
    } else
	info->FPBIOSstart = RADEON_BIOS16(0x48);
    info->OverlayOnCRTC2 = FALSE;

    if (!info->IsSecondary)
	RADEONQueryConnectedDisplays(pScrn, pInt10);

    {
	RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);

	info->Clone = FALSE;
	info->CloneType = MT_NONE;

	if(info->HasCRTC2) {
	    if(info->IsSecondary) {
		info->DisplayType = (RADEONMonitorType)pRADEONEnt->MonType2;
		if(info->DisplayType == MT_NONE) return FALSE;
	    } else {
		info->DisplayType = (RADEONMonitorType)pRADEONEnt->MonType1;

		if(!pRADEONEnt->HasSecondary) {
		    info->CloneType = (RADEONMonitorType)pRADEONEnt->MonType2;
		    if (info->CloneType != MT_NONE)
			info->Clone = TRUE;
		}
	    }
	} else {
	    info->DisplayType = (RADEONMonitorType)pRADEONEnt->MonType1;
	}

	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%s Display == Type %d\n",
		   (info->IsSecondary ? "Secondary" : "Primary"),
		   info->DisplayType);

	if (info->Clone)
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Clone Display == Type %d\n",
		       info->CloneType);

	info->HBlank     = 0;
	info->HOverPlus  = 0;
	info->HSyncWidth = 0;
	info->VBlank     = 0;
	info->VOverPlus  = 0;
	info->VSyncWidth = 0;
	info->DotClock   = 0;
	info->UseBiosDividers = FALSE;

	if (info->DisplayType == MT_LCD && info->VBIOS &&
	    !(xf86GetOptValString(info->Options, OPTION_PANEL_SIZE))) {
	    tmp = RADEON_BIOS16(info->FPBIOSstart + 0x40);
            if (!tmp) {
		info->PanelPwrDly = 200;
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                           "No Panel Info Table found in BIOS!\n");
            } else {
		char  stmp[30];
		int   tmp0;

		for (i = 0; i < 24; i++)
		    stmp[i] = RADEON_BIOS8(tmp+i+1);
		stmp[24] = 0;

		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                           "Panel ID string: %s\n", stmp);

		info->PanelXRes = RADEON_BIOS16(tmp+25);
		info->PanelYRes = RADEON_BIOS16(tmp+27);
		xf86DrvMsg(0, X_INFO, "Panel Size from BIOS: %dx%d\n",
			   info->PanelXRes, info->PanelYRes);

		info->PanelPwrDly = RADEON_BIOS16(tmp+44);
		if (info->PanelPwrDly > 2000 || info->PanelPwrDly < 0)
		    info->PanelPwrDly = 2000;

		/* some panels only work well with certain divider combinations.
		 */
		info->RefDivider = RADEON_BIOS16(tmp+46);
		info->PostDivider = RADEON_BIOS8(tmp+48);
		info->FeedbackDivider = RADEON_BIOS16(tmp+49);
		if ((info->RefDivider != 0) &&
		    (info->FeedbackDivider > 3)) {
		  info->UseBiosDividers = TRUE;
		  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			     "BIOS provided dividers will be used.\n");
		}

		/* We don't use a while loop here just in case we have a corrupted BIOS image.
		   The max number of table entries is 23 at present, but may grow in future.
		   To ensure it works with future revisions we loop it to 32.
		*/
		for (i = 0; i < 32; i++) {
		    tmp0 = RADEON_BIOS16(tmp+64+i*2);
		    if (tmp0 == 0) break;
		    if ((RADEON_BIOS16(tmp0) == info->PanelXRes) &&
			(RADEON_BIOS16(tmp0+2) == info->PanelYRes)) {
			info->HBlank     = (RADEON_BIOS16(tmp0+17) -
					    RADEON_BIOS16(tmp0+19)) * 8;
			info->HOverPlus  = (RADEON_BIOS16(tmp0+21) -
					    RADEON_BIOS16(tmp0+19) - 1) * 8;
			info->HSyncWidth = RADEON_BIOS8(tmp0+23) * 8;
			info->VBlank     = (RADEON_BIOS16(tmp0+24) -
					    RADEON_BIOS16(tmp0+26));
			info->VOverPlus  = ((RADEON_BIOS16(tmp0+28) & 0x7ff) -
					    RADEON_BIOS16(tmp0+26));
			info->VSyncWidth = ((RADEON_BIOS16(tmp0+28) & 0xf800) >> 11);
			info->DotClock   = RADEON_BIOS16(tmp0+9) * 10;
			info->Flags = 0;
		    }
		}

		if (info->DotClock == 0) {
		    DisplayModePtr  tmp_mode = NULL;
		    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			       "No valid timing info from BIOS.\n");
		    /* No timing information for the native mode,
		       use whatever specified in the Modeline.
		       If no Modeline specified, we'll just pick
		       the VESA mode at 60Hz refresh rate which
		       is likely to be the best for a flat panel.
		    */
		    tmp_mode = pScrn->monitor->Modes;
		    while(tmp_mode) {
			if ((tmp_mode->HDisplay == info->PanelXRes) &&
			    (tmp_mode->VDisplay == info->PanelYRes)) {

			    float  refresh =
				(float)tmp_mode->Clock * 1000.0 / tmp_mode->HTotal / tmp_mode->VTotal;
			    if ((abs(60.0 - refresh) < 1.0) ||
				(tmp_mode->type == 0)) {
				info->HBlank     = tmp_mode->HTotal - tmp_mode->HDisplay;
				info->HOverPlus  = tmp_mode->HSyncStart - tmp_mode->HDisplay;
				info->HSyncWidth = tmp_mode->HSyncEnd - tmp_mode->HSyncStart;
				info->VBlank     = tmp_mode->VTotal - tmp_mode->VDisplay;
				info->VOverPlus  = tmp_mode->VSyncStart - tmp_mode->VDisplay;
				info->VSyncWidth = tmp_mode->VSyncEnd - tmp_mode->VSyncStart;
				info->DotClock   = tmp_mode->Clock;
				info->Flags = 0;
				break;
			    }
			    tmp_mode = tmp_mode->next;
			}
		    }
		    if ((info->DotClock == 0) && !pRADEONEnt->MonInfo1) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				   "Panel size is not correctly detected.\n"
				   "Please try to use PanelSize option for correct settings.\n");
			return FALSE;
		    }
		}
	    }
	}
    }

    if (info->VBIOS) {
	tmp = RADEON_BIOS16(info->FPBIOSstart + 0x30);
	info->sclk = RADEON_BIOS16(tmp + 8) / 100.0;
	info->mclk = RADEON_BIOS16(tmp + 10) / 100.0;
    } else {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "No valid info for SCLK/MCLK for display bandwidth calculation.\n");
	info->sclk = 200.00;
	info->mclk = 200.00;
    }

    return TRUE;
}

static Bool RADEONProbePLLParameters(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONPLLPtr  pll  = &info->pll;
    unsigned char *RADEONMMIO = info->MMIO;
    unsigned char ppll_div_sel;
    unsigned Nx, M;
    unsigned xclk, tmp, ref_div;
    int hTotal, vTotal, num, denom, m, n;
    float hz, vclk, xtal;
    long start_secs, start_usecs, stop_secs, stop_usecs, total_usecs;
    int i;

    for(i=0; i<1000000; i++)
	if (((INREG(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) == 0)
	    break;

    xf86getsecs(&start_secs, &start_usecs);

    for(i=0; i<1000000; i++)
	if (((INREG(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) != 0)
	    break;

    for(i=0; i<1000000; i++)
	if (((INREG(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) == 0)
	    break;

    xf86getsecs(&stop_secs, &stop_usecs);

    total_usecs = abs(stop_usecs - start_usecs);
    hz = 1000000/total_usecs;

    hTotal = ((INREG(RADEON_CRTC_H_TOTAL_DISP) & 0x1ff) + 1) * 8;
    vTotal = ((INREG(RADEON_CRTC_V_TOTAL_DISP) & 0x3ff) + 1);
    vclk = (float)(hTotal * (float)(vTotal * hz));

    switch((INPLL(pScrn, RADEON_PPLL_REF_DIV) & 0x30000) >> 16) {
    case 0:
    default:
        num = 1;
        denom = 1;
        break;
    case 1:
        n = ((INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV) >> 16) & 0xff);
        m = (INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV) & 0xff);
        num = 2*n;
        denom = 2*m;
        break;
    case 2:
        n = ((INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV) >> 8) & 0xff);
        m = (INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV) & 0xff);
        num = 2*n;
        denom = 2*m;
        break;
     }

    OUTREG(RADEON_CLOCK_CNTL_INDEX, 1);
    ppll_div_sel = INREG8(RADEON_CLOCK_CNTL_DATA + 1) & 0x3;

    n = (INPLL(pScrn, RADEON_PPLL_DIV_0 + ppll_div_sel) & 0x7ff);
    m = (INPLL(pScrn, RADEON_PPLL_REF_DIV) & 0x3ff);

    num *= n;
    denom *= m;

    switch ((INPLL(pScrn, RADEON_PPLL_DIV_0 + ppll_div_sel) >> 16) & 0x7) {
    case 1:
        denom *= 2;
        break;
    case 2:
        denom *= 4;
        break;
    case 3:
        denom *= 8;
        break;
    case 4:
        denom *= 3;
        break;
    case 6:
        denom *= 6;
        break;
    case 7:
        denom *= 12;
        break;
    }

    xtal = (int)(vclk *(float)denom/(float)num);

    if ((xtal > 26900000) && (xtal < 27100000))
        xtal = 2700;
    else if ((xtal > 14200000) && (xtal < 14400000))
        xtal = 1432;
    else if ((xtal > 29400000) && (xtal < 29600000))
        xtal = 2950;
    else
	return FALSE;

    tmp = INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV);
    ref_div = INPLL(pScrn, RADEON_PPLL_REF_DIV) & 0x3ff;

    Nx = (tmp & 0xff00) >> 8;
    M = (tmp & 0xff);
    xclk = RADEONDiv((2 * Nx * xtal), (2 * M));

    /* we're done, hopefully these are sane values */
    pll->reference_div = ref_div;
    pll->xclk = xclk;
    pll->reference_freq = xtal;

    return TRUE;
}

static void RADEONGetTMDSInfo(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    CARD32 tmp;
    int i, n;

    for (i=0; i<4; i++) {
	info->tmds_pll[i].value = 0;
	info->tmds_pll[i].freq = 0;
    }

    if (info->VBIOS) {
	tmp = RADEON_BIOS16(info->FPBIOSstart + 0x34);
	if (tmp) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "DFP table revision: %d\n", RADEON_BIOS8(tmp));
	    if (RADEON_BIOS8(tmp) == 3) {
		n = RADEON_BIOS8(tmp + 5) + 1;
		if (n > 4) n = 4;
		for (i=0; i<n; i++) {
		    info->tmds_pll[i].value = RADEON_BIOS32(tmp+i*10+0x08);
		    info->tmds_pll[i].freq = RADEON_BIOS16(tmp+i*10+0x10);
		}
		return;
	    }

	    /* revision 4 has some problem as it appears in RV280,
	       comment it off for new, use default instead */
            /*
	    else if (RADEON_BIOS8(tmp) == 4) {
		int stride = 0;
		n = RADEON_BIOS8(tmp + 5) + 1;
		if (n > 4) n = 4;
		for (i=0; i<n; i++) {
		    info->tmds_pll[i].value = RADEON_BIOS32(tmp+stride+0x08);
		    info->tmds_pll[i].freq = RADEON_BIOS16(tmp+stride+0x10);
		    if (i == 0) stride += 10;
		    else stride += 6;
		}
		return;
	    }
	    */
	}
    }

    for (i=0; i<4; i++) {
	info->tmds_pll[i].value = default_tmds_pll[info->ChipFamily][i].value;
	info->tmds_pll[i].freq = default_tmds_pll[info->ChipFamily][i].freq;
    }
}

/* Read PLL parameters from BIOS block.  Default to typical values if
 * there is no BIOS.
 */
static Bool RADEONGetPLLParameters(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    RADEONPLLPtr   pll  = &info->pll;
    CARD16         bios_header;
    CARD16         pll_info_block;
    double         min_dotclock;

    if (!info->VBIOS) {

	pll->min_pll_freq   = 12500;
	pll->max_pll_freq   = 35000;


	if (!RADEONProbePLLParameters(pScrn)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Video BIOS not detected, using default PLL parameters!\n");

	    switch (info->Chipset) {
		case PCI_CHIP_R200_QL:
		case PCI_CHIP_R200_QN:
		case PCI_CHIP_R200_QO:
		case PCI_CHIP_R200_BB:
		    pll->reference_freq = 2700;
		    pll->reference_div  = 12;
		    pll->xclk           = 27500;
		    break;
		case PCI_CHIP_RV250_Id:
		case PCI_CHIP_RV250_Ie:
		case PCI_CHIP_RV250_If:
		case PCI_CHIP_RV250_Ig:
		    pll->reference_freq = 2700;
		    pll->reference_div  = 12;
		    pll->xclk           = 24975;
		    break;
		case PCI_CHIP_RV200_QW:
		    pll->reference_freq = 2700;
		    pll->reference_div  = 12;
		    pll->xclk           = 23000;
		    break;
		default:
		    pll->reference_freq = 2700;
		    pll->reference_div  = 67;
		    pll->xclk           = 16615;
		    break;
	    }
        }
    } else {
	bios_header    = RADEON_BIOS16(0x48);
	pll_info_block = RADEON_BIOS16(bios_header + 0x30);
	RADEONTRACE(("Header at 0x%04x; PLL Information at 0x%04x\n",
		     bios_header, pll_info_block));

	pll->reference_freq = RADEON_BIOS16(pll_info_block + 0x0e);
	pll->reference_div  = RADEON_BIOS16(pll_info_block + 0x10);
	pll->min_pll_freq   = RADEON_BIOS32(pll_info_block + 0x12);
	pll->max_pll_freq   = RADEON_BIOS32(pll_info_block + 0x16);
	pll->xclk           = RADEON_BIOS16(pll_info_block + 0x08);
    }

    /* (Some?) Radeon BIOSes seem too lie about their minimum dot
     * clocks.  Allow users to override the detected minimum dot clock
     * value (e.g., and allow it to be suitable for TV sets).
     */
    if (xf86GetOptValFreq(info->Options, OPTION_MIN_DOTCLOCK,
			  OPTUNITS_MHZ, &min_dotclock)) {
	if (min_dotclock < 12 || min_dotclock*100 >= pll->max_pll_freq) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Illegal minimum dotclock specified %.2f MHz "
		       "(option ignored)\n",
		       min_dotclock);
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Forced minimum dotclock to %.2f MHz "
		       "(instead of detected %.2f MHz)\n",
		       min_dotclock, ((double)pll->min_pll_freq/1000));
	    pll->min_pll_freq = min_dotclock * 1000;
	}
    }

    return TRUE;
}

/* This is called by RADEONPreInit to set up the default visual */
static Bool RADEONPreInitVisual(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);

    if (!xf86SetDepthBpp(pScrn, 0, 0, 0, Support32bppFb))
	return FALSE;

    switch (pScrn->depth) {
    case 8:
    case 15:
    case 16:
    case 24:
	break;

    default:
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Given depth (%d) is not supported by %s driver\n",
		   pScrn->depth, RADEON_DRIVER_NAME);
	return FALSE;
    }

    xf86PrintDepthBpp(pScrn);

    info->fifo_slots                 = 0;
    info->pix24bpp                   = xf86GetBppFromDepth(pScrn,
							   pScrn->depth);
    info->CurrentLayout.bitsPerPixel = pScrn->bitsPerPixel;
    info->CurrentLayout.depth        = pScrn->depth;
    info->CurrentLayout.pixel_bytes  = pScrn->bitsPerPixel / 8;
    info->CurrentLayout.pixel_code   = (pScrn->bitsPerPixel != 16
				       ? pScrn->bitsPerPixel
				       : pScrn->depth);

    if (info->pix24bpp == 24) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Radeon does NOT support 24bpp\n");
	return FALSE;
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Pixel depth = %d bits stored in %d byte%s (%d bpp pixmaps)\n",
	       pScrn->depth,
	       info->CurrentLayout.pixel_bytes,
	       info->CurrentLayout.pixel_bytes > 1 ? "s" : "",
	       info->pix24bpp);

    if (!xf86SetDefaultVisual(pScrn, -1)) return FALSE;

    if (pScrn->depth > 8 && pScrn->defaultVisual != TrueColor) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Default visual (%s) is not supported at depth %d\n",
		   xf86GetVisualName(pScrn->defaultVisual), pScrn->depth);
	return FALSE;
    }
    return TRUE;
}

/* This is called by RADEONPreInit to handle all color weight issues */
static Bool RADEONPreInitWeight(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);
a1062 1

d1064 1
a1064 2
	rgb  defaultWeight = { 0, 0, 0 };

d1073 5
a1078 43
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Using %d bits per RGB (%d bit DAC)\n",
	       pScrn->rgbBits, info->dac6bits ? 6 : 8);

    return TRUE;
}

static void RADEONGetVRamType(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info   = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    CARD32 tmp;

    if (info->IsIGP || (info->ChipFamily >= CHIP_FAMILY_R300) ||
	(INREG(RADEON_MEM_SDRAM_MODE_REG) & (1<<30)))
	info->IsDDR = TRUE;
    else
	info->IsDDR = FALSE;

    tmp = INREG(RADEON_MEM_CNTL);
    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {
	tmp &=  R300_MEM_NUM_CHANNELS_MASK;
	switch (tmp) {
	case 0: info->RamWidth = 64; break;
	case 1: info->RamWidth = 128; break;
	case 2: info->RamWidth = 256; break;
	default: info->RamWidth = 128; break;
	}
    } else if ((info->ChipFamily == CHIP_FAMILY_RV100) ||
	       (info->ChipFamily == CHIP_FAMILY_RS100) ||
	       (info->ChipFamily == CHIP_FAMILY_RS200)){
	if (tmp & RV100_HALF_MODE) info->RamWidth = 32;
	else info->RamWidth = 64;
    } else {
	if (tmp & RADEON_MEM_NUM_CHANNELS_MASK) info->RamWidth = 128;
	else info->RamWidth = 64;
    }

    /* This may not be correct, as some cards can have half of channel disabled
     * ToDo: identify these cases
     */
d1081 3
a1083 5
/* This is called by RADEONPreInit to handle config file overrides for
 * things like chipset and memory regions.  Also determine memory size
 * and type.  If memory type ever needs an override, put it in this
 * routine.
 */
d1086 6
a1091 9
    RADEONInfoPtr  info   = RADEONPTR(pScrn);
    EntityInfoPtr  pEnt   = info->pEnt;
    GDevPtr        dev    = pEnt->device;
    MessageType    from;
    unsigned char *RADEONMMIO = info->MMIO;
#ifdef XF86DRI
    const char    *s;
    CARD32         agpCommand;
#endif
d1104 1
a1105 1
    pScrn->chipset = (char *)xf86TokenToString(RADEONChipsets, info->Chipset);
d1111 1
d1117 1
a1122 9
    info->HasCRTC2 = TRUE;
    info->IsMobility = FALSE;
    info->IsIGP = FALSE;
    switch (info->Chipset) {
    case PCI_CHIP_RADEON_LY:
    case PCI_CHIP_RADEON_LZ:
	info->IsMobility = TRUE;
	info->ChipFamily = CHIP_FAMILY_RV100;
	break;
d1124 27
a1150 110
    case PCI_CHIP_RV100_QY:
    case PCI_CHIP_RV100_QZ:
	info->ChipFamily = CHIP_FAMILY_RV100;
	break;

    case PCI_CHIP_RS100_4336:
	info->IsMobility = TRUE;
    case PCI_CHIP_RS100_4136:
	info->ChipFamily = CHIP_FAMILY_RS100;
	info->IsIGP = TRUE;
	break;

    case PCI_CHIP_RS200_4337:
	info->IsMobility = TRUE;
    case PCI_CHIP_RS200_4137:
	info->ChipFamily = CHIP_FAMILY_RS200;
	info->IsIGP = TRUE;
	break;

    case PCI_CHIP_RS250_4437:
	info->IsMobility = TRUE;
    case PCI_CHIP_RS250_4237:
	info->ChipFamily = CHIP_FAMILY_RS200;
	info->IsIGP = TRUE;
	break;

    case PCI_CHIP_R200_BB:
    case PCI_CHIP_R200_BC:
    case PCI_CHIP_R200_QH:
    case PCI_CHIP_R200_QL:
    case PCI_CHIP_R200_QM:
	info->ChipFamily = CHIP_FAMILY_R200;
	break;

    case PCI_CHIP_RADEON_LW:
    case PCI_CHIP_RADEON_LX:
	info->IsMobility = TRUE;
    case PCI_CHIP_RV200_QW: /* RV200 desktop */
    case PCI_CHIP_RV200_QX:
	info->ChipFamily = CHIP_FAMILY_RV200;
	break;

    case PCI_CHIP_RV250_Ld:
    case PCI_CHIP_RV250_Lf:
    case PCI_CHIP_RV250_Lg:
	info->IsMobility = TRUE;
    case PCI_CHIP_RV250_If:
    case PCI_CHIP_RV250_Ig:
	info->ChipFamily = CHIP_FAMILY_RV250;
	break;

    case PCI_CHIP_RS300_5835:
	info->IsMobility = TRUE;
    case PCI_CHIP_RS300_5834:
	info->ChipFamily = CHIP_FAMILY_RS300;
	info->IsIGP = TRUE;
	break;

    case PCI_CHIP_RV280_5C61:
    case PCI_CHIP_RV280_5C63:
	info->IsMobility = TRUE;
    case PCI_CHIP_RV280_5960:
    case PCI_CHIP_RV280_5961:
    case PCI_CHIP_RV280_5962:
    case PCI_CHIP_RV280_5964:
	info->ChipFamily = CHIP_FAMILY_RV280;
	break;

    case PCI_CHIP_R300_AD:
    case PCI_CHIP_R300_AE:
    case PCI_CHIP_R300_AF:
    case PCI_CHIP_R300_AG:
    case PCI_CHIP_R300_ND:
    case PCI_CHIP_R300_NE:
    case PCI_CHIP_R300_NF:
    case PCI_CHIP_R300_NG:
	info->ChipFamily = CHIP_FAMILY_R300;
        break;

    case PCI_CHIP_RV350_NP:
    case PCI_CHIP_RV350_NQ:
    case PCI_CHIP_RV350_NR:
    case PCI_CHIP_RV350_NS:
    case PCI_CHIP_RV350_NT:
    case PCI_CHIP_RV350_NV:
	info->IsMobility = TRUE;
    case PCI_CHIP_RV350_AP:
    case PCI_CHIP_RV350_AQ:
    case PCI_CHIP_RV360_AR:
    case PCI_CHIP_RV350_AS:
    case PCI_CHIP_RV350_AT:
    case PCI_CHIP_RV350_AV:
	info->ChipFamily = CHIP_FAMILY_RV350;
        break;

    case PCI_CHIP_R350_AH:
    case PCI_CHIP_R350_AI:
    case PCI_CHIP_R350_AJ:
    case PCI_CHIP_R350_AK:
    case PCI_CHIP_R350_NH:
    case PCI_CHIP_R350_NI:
    case PCI_CHIP_R350_NK:
    case PCI_CHIP_R360_NJ:
	info->ChipFamily = CHIP_FAMILY_R350;
        break;

    default:
	/* Original Radeon/7200 */
	info->ChipFamily = CHIP_FAMILY_RADEON;
	info->HasCRTC2 = FALSE;
d1155 2
a1156 2
    from               = X_PROBED;
    info->LinearAddr   = info->PciInfo->memBase[0] & 0xfe000000;
d1160 1
a1160 1
		   "Linear address override, using 0x%08lx instead of 0x%08lx\n",
d1173 17
d1195 1
a1195 1
		   "BIOS address override, using 0x%08lx instead of 0x%08lx\n",
d1206 3
a1212 26
    else if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
	     (info->ChipFamily == CHIP_FAMILY_RS200) ||
	     (info->ChipFamily == CHIP_FAMILY_RS300)) {
        CARD32 tom = INREG(RADEON_NB_TOM);
        pScrn->videoRam = (((tom >> 16) -
			    (tom & 0xffff) + 1) << 6);
	OUTREG(RADEON_MC_FB_LOCATION, tom);
	OUTREG(RADEON_DISPLAY_BASE_ADDR, (tom & 0xffff) << 16);
	OUTREG(RADEON_DISPLAY2_BASE_ADDR, (tom & 0xffff) << 16);
	OUTREG(RADEON_OV0_BASE_ADDR, (tom & 0xffff) << 16);

	/* This is supposed to fix the crtc2 noise problem.
	*/
	OUTREG(RADEON_GRPH2_BUFFER_CNTL,
	       INREG(RADEON_GRPH2_BUFFER_CNTL) & ~0x7f0000);

	if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
	    (info->ChipFamily == CHIP_FAMILY_RS200)) {
	    /* This is to workaround the asic bug for RMX, some versions
	       of BIOS dosen't have this register initialized correctly.
	    */
	    OUTREGP(RADEON_CRTC_MORE_CNTL, RADEON_CRTC_H_CUTOFF_ACTIVE_EN,
		    ~RADEON_CRTC_H_CUTOFF_ACTIVE_EN);
	}

    }
d1215 20
a1234 24

    /* Some production boards of m6 will return 0 if it's 8 MB */
    if (pScrn->videoRam == 0) pScrn->videoRam = 8192;

    if (info->IsSecondary) {
	/* FIXME: For now, split FB into two equal sections. This should
	 * be able to be adjusted by user with a config option. */
        RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
	RADEONInfoPtr  info1;

	pScrn->videoRam /= 2;
	pRADEONEnt->pPrimaryScrn->videoRam = pScrn->videoRam;

	info1 = RADEONPTR(pRADEONEnt->pPrimaryScrn);
	info1->FbMapSize  = pScrn->videoRam * 1024;
	info->LinearAddr += pScrn->videoRam * 1024;
	info1->Clone = FALSE;
	info1->CurCloneMode = NULL;
    }

    info->R300CGWorkaround =
	(info->ChipFamily == CHIP_FAMILY_R300 &&
	 (INREG(RADEON_CONFIG_CNTL) & RADEON_CFG_ATI_REV_ID_MASK)
	 == RADEON_CFG_ATI_REV_A11);
d1238 2
d1241 7
a1247 1
    RADEONGetVRamType(pScrn);
d1249 2
a1250 1
    if (dev->videoRam) {
d1261 1
a1261 1
	       "VideoRAM: %d kByte (%d bit %s SDRAM)\n", pScrn->videoRam, info->RamWidth, info->IsDDR?"DDR":"SDR");
d1265 3
a1267 16

    /* There are signatures in BIOS and PCI-SSID for a PCI card, but
     * they are not very reliable.  Following detection method works for
     * all cards tested so far.  Note, checking AGP_ENABLE bit after
     * drmAgpEnable call can also give the correct result.  However,
     * calling drmAgpEnable on a PCI card can cause some strange lockup
     * when the server restarts next time.
     */

    agpCommand = pciReadLong(info->PciTag, RADEON_AGP_COMMAND_PCI_CONFIG);
    pciWriteLong(info->PciTag, RADEON_AGP_COMMAND_PCI_CONFIG,
		 agpCommand | RADEON_AGP_ENABLE);
    if (pciReadLong(info->PciTag, RADEON_AGP_COMMAND_PCI_CONFIG)
	& RADEON_AGP_ENABLE) {
	info->IsPCI = FALSE; 
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "AGP card detected\n");
d1269 20
a1288 19
	info->IsPCI = TRUE; 
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PCI card detected\n");
    }
    pciWriteLong(info->PciTag, RADEON_AGP_COMMAND_PCI_CONFIG, agpCommand);

    if ((s = xf86GetOptValString(info->Options, OPTION_BUS_TYPE))) {
	if (strcmp(s, "AGP") == 0) {
	    info->IsPCI = FALSE;
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Forced into AGP mode\n");
	} else if (strcmp(s, "PCI") == 0) {
	    info->IsPCI = TRUE;
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Forced into PCI mode\n");
	} else if (strcmp(s, "PCIE") == 0) {
	    info->IsPCI = TRUE;
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       "PCI Express not supported yet, using PCI mode\n");
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       "Invalid BusType option, using detected type\n");
a1289 6
    } else if (xf86ReturnOptValBool(info->Options, OPTION_IS_PCI, FALSE)) {
	info->IsPCI = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Forced into PCI mode\n");
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "ForcePCIMode is deprecated -- "
		   "use BusType option instead\n");
d1296 2
a1297 1
static void RADEONI2CGetBits(I2CBusPtr b, int *Clock, int *data)
d1299 3
a1301 3
    ScrnInfoPtr    pScrn      = xf86Screens[b->scrnIndex];
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned long  val;
d1304 1
a1304 1
    /* Get the result */
d1309 1
d1312 2
a1313 1
static void RADEONI2CPutBits(I2CBusPtr b, int Clock, int data)
d1315 3
a1317 3
    ScrnInfoPtr    pScrn      = xf86Screens[b->scrnIndex];
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned long  val;
d1320 5
a1324 747
    val = INREG(info->DDCReg) & (CARD32)~(RADEON_GPIO_EN_0 | RADEON_GPIO_EN_1);
    val |= (Clock ? 0:RADEON_GPIO_EN_1);
    val |= (data ? 0:RADEON_GPIO_EN_0);
    OUTREG(info->DDCReg, val);

    /* read back to improve reliability on some cards. */
    val = INREG(info->DDCReg);
}

static Bool RADEONI2cInit(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);

    info->pI2CBus = xf86CreateI2CBusRec();
    if (!info->pI2CBus) return FALSE;

    info->pI2CBus->BusName    = "DDC";
    info->pI2CBus->scrnIndex  = pScrn->scrnIndex;
    info->pI2CBus->I2CPutBits = RADEONI2CPutBits;
    info->pI2CBus->I2CGetBits = RADEONI2CGetBits;
    info->pI2CBus->AcknTimeout = 5;

    if (!xf86I2CBusInit(info->pI2CBus)) return FALSE;
    return TRUE;
}

static void RADEONPreInitDDC(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);
 /* vbeInfoPtr     pVbe; */

    info->ddc1     = FALSE;
    info->ddc_bios = FALSE;
    if (!xf86LoadSubModule(pScrn, "ddc")) {
	info->ddc2 = FALSE;
    } else {
	xf86LoaderReqSymLists(ddcSymbols, NULL);
	info->ddc2 = TRUE;
    }

    /* DDC can use I2C bus */
    /* Load I2C if we have the code to use it */
    if (info->ddc2) {
	if (xf86LoadSubModule(pScrn, "i2c")) {
	    xf86LoaderReqSymLists(i2cSymbols,NULL);
	    info->ddc2 = RADEONI2cInit(pScrn);
	}
	else info->ddc2 = FALSE;
    }
}


/* BIOS may not have right panel size, we search through all supported
 * DDC modes looking for the maximum panel size.
 */
static void RADEONUpdatePanelSize(ScrnInfoPtr pScrn)
{
    int             j;
    RADEONInfoPtr   info = RADEONPTR (pScrn);
    xf86MonPtr      ddc  = pScrn->monitor->DDC;
    DisplayModePtr  p;

    /* Go thru detailed timing table first */
    for (j = 0; j < 4; j++) {
	if (ddc->det_mon[j].type == 0) {
	    struct detailed_timings *d_timings =
		&ddc->det_mon[j].section.d_timings;
	    if (info->PanelXRes < d_timings->h_active &&
		info->PanelYRes < d_timings->v_active) {

		info->PanelXRes  = d_timings->h_active;
		info->PanelYRes  = d_timings->v_active;
		info->DotClock   = d_timings->clock / 1000;
		info->HOverPlus  = d_timings->h_sync_off;
		info->HSyncWidth = d_timings->h_sync_width;
		info->HBlank     = d_timings->h_blanking;
		info->VOverPlus  = d_timings->v_sync_off;
		info->VSyncWidth = d_timings->v_sync_width;
		info->VBlank     = d_timings->v_blanking;
	    }
	}
    }

    /* Search thru standard VESA modes from EDID */
    for (j = 0; j < 8; j++) {
	if ((info->PanelXRes < ddc->timings2[j].hsize) &&
	    (info->PanelYRes < ddc->timings2[j].vsize)) {
	    for (p = pScrn->monitor->Modes; p && p->next; p = p->next->next) {
		if ((ddc->timings2[j].hsize == p->HDisplay) &&
		    (ddc->timings2[j].vsize == p->VDisplay)) {
		    float  refresh =
			(float)p->Clock * 1000.0 / p->HTotal / p->VTotal;

		    if (abs((float)ddc->timings2[j].refresh - refresh) < 1.0) {
			/* Is this good enough? */
			info->PanelXRes  = ddc->timings2[j].hsize;
			info->PanelYRes  = ddc->timings2[j].vsize;
			info->HBlank     = p->HTotal - p->HDisplay;
			info->HOverPlus  = p->HSyncStart - p->HDisplay;
			info->HSyncWidth = p->HSyncEnd - p->HSyncStart;
			info->VBlank     = p->VTotal - p->VDisplay;
			info->VOverPlus  = p->VSyncStart - p->VDisplay;
			info->VSyncWidth = p->VSyncEnd - p->VSyncStart;
			info->DotClock   = p->Clock;
			info->Flags      =
			    (ddc->det_mon[j].section.d_timings.interlaced
			     ? V_INTERLACE
			     : 0);
			if (ddc->det_mon[j].section.d_timings.sync == 3) {
			    switch (ddc->det_mon[j].section.d_timings.misc) {
			    case 0: info->Flags |= V_NHSYNC | V_NVSYNC; break;
			    case 1: info->Flags |= V_PHSYNC | V_NVSYNC; break;
			    case 2: info->Flags |= V_NHSYNC | V_PVSYNC; break;
			    case 3: info->Flags |= V_PHSYNC | V_PVSYNC; break;
			    }
			}
		    }
		}
	    }
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Panel size found from DDC: %dx%d\n",
	       info->PanelXRes, info->PanelYRes);
}

/* This function will sort all modes according to their resolution.
 * Highest resolution first.
 */
static void RADEONSortModes(DisplayModePtr *new, DisplayModePtr *first,
			    DisplayModePtr *last)
{
    DisplayModePtr  p;

    p = *last;
    while (p) {
	if ((((*new)->HDisplay < p->HDisplay) &&
	     ((*new)->VDisplay < p->VDisplay)) ||
	    (((*new)->HDisplay == p->HDisplay) &&
	     ((*new)->VDisplay == p->VDisplay) &&
	     ((*new)->Clock < p->Clock))) {

	    if (p->next) p->next->prev = *new;
	    (*new)->prev = p;
	    (*new)->next = p->next;
	    p->next = *new;
	    if (!((*new)->next)) *last = *new;
	    break;
	}
	if (!p->prev) {
	    (*new)->prev = NULL;
	    (*new)->next = p;
	    p->prev = *new;
	    *first = *new;
	    break;
	}
	p = p->prev;
    }

    if (!*first) {
	*first = *new;
	(*new)->prev = NULL;
	(*new)->next = NULL;
	*last = *new;
    }
}

static void RADEONSetPitch (ScrnInfoPtr pScrn)
{
    int  dummy = pScrn->virtualX;

    /* FIXME: May need to validate line pitch here */
    switch (pScrn->depth / 8) {
    case 1: dummy = (pScrn->virtualX + 127) & ~127; break;
    case 2: dummy = (pScrn->virtualX +  31) &  ~31; break;
    case 3:
    case 4: dummy = (pScrn->virtualX +  15) &  ~15; break;
    }
    pScrn->displayWidth = dummy;
}

/* When no mode provided in config file, this will add all modes supported in
 * DDC date the pScrn->modes list
 */
static DisplayModePtr RADEONDDCModes(ScrnInfoPtr pScrn)
{
    DisplayModePtr  p;
    DisplayModePtr  last  = NULL;
    DisplayModePtr  new   = NULL;
    DisplayModePtr  first = NULL;
    int             count = 0;
    int             j, tmp;
    char            stmp[32];
    xf86MonPtr      ddc   = pScrn->monitor->DDC;

    /* Go thru detailed timing table first */
    for (j = 0; j < 4; j++) {
	if (ddc->det_mon[j].type == 0) {
	    struct detailed_timings *d_timings =
		&ddc->det_mon[j].section.d_timings;

	    if (d_timings->h_active == 0 || d_timings->v_active == 0) break;

	    new = xnfcalloc(1, sizeof (DisplayModeRec));
	    memset(new, 0, sizeof (DisplayModeRec));

	    new->HDisplay   = d_timings->h_active;
	    new->VDisplay   = d_timings->v_active;

	    sprintf(stmp, "%dx%d", new->HDisplay, new->VDisplay);
	    new->name       = xnfalloc(strlen(stmp) + 1);
	    strcpy(new->name, stmp);

	    new->HTotal     = new->HDisplay + d_timings->h_blanking;
	    new->HSyncStart = new->HDisplay + d_timings->h_sync_off;
	    new->HSyncEnd   = new->HSyncStart + d_timings->h_sync_width;
	    new->VTotal     = new->VDisplay + d_timings->v_blanking;
	    new->VSyncStart = new->VDisplay + d_timings->v_sync_off;
	    new->VSyncEnd   = new->VSyncStart + d_timings->v_sync_width;
	    new->Clock      = d_timings->clock / 1000;
	    new->Flags      = (d_timings->interlaced ? V_INTERLACE : 0);
	    new->status     = MODE_OK;
	    new->type       = M_T_DEFAULT;

	    if (d_timings->sync == 3) {
		switch (d_timings->misc) {
		case 0: new->Flags |= V_NHSYNC | V_NVSYNC; break;
		case 1: new->Flags |= V_PHSYNC | V_NVSYNC; break;
		case 2: new->Flags |= V_NHSYNC | V_PVSYNC; break;
		case 3: new->Flags |= V_PHSYNC | V_PVSYNC; break;
		}
	    }
	    count++;

	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Valid Mode from Detailed timing table: %s\n",
		       new->name);

	    RADEONSortModes(&new, &first, &last);
	}
    }

    /* Search thru standard VESA modes from EDID */
    for (j = 0; j < 8; j++) {
	for (p = pScrn->monitor->Modes; p && p->next; p = p->next->next) {
	    /* Ignore all double scan modes */
	    if ((ddc->timings2[j].hsize == p->HDisplay) &&
		(ddc->timings2[j].vsize == p->VDisplay)) {
		float  refresh =
		    (float)p->Clock * 1000.0 / p->HTotal / p->VTotal;

		if (abs((float)ddc->timings2[j].refresh - refresh) < 1.0) {
		    /* Is this good enough? */
		    new = xnfcalloc(1, sizeof (DisplayModeRec));
		    memcpy(new, p, sizeof(DisplayModeRec));
		    new->name = xnfalloc(strlen(p->name) + 1);
		    strcpy(new->name, p->name);
		    new->status = MODE_OK;
		    new->type   = M_T_DEFAULT;

		    count++;

		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			       "Valid Mode from standard timing table: %s\n",
			       new->name);

		    RADEONSortModes(&new, &first, &last);
		    break;
		}
	    }
	}
    }

    /* Search thru established modes from EDID */
    tmp = (ddc->timings1.t1 << 8) | ddc->timings1.t2;
    for (j = 0; j < 16; j++) {
	if (tmp & (1 << j)) {
	    for (p = pScrn->monitor->Modes; p && p->next; p = p->next->next) {
		if ((est_timings[j].hsize == p->HDisplay) &&
		    (est_timings[j].vsize == p->VDisplay)) {
		    float  refresh =
			(float)p->Clock * 1000.0 / p->HTotal / p->VTotal;

		    if (abs((float)est_timings[j].refresh - refresh) < 1.0) {
			/* Is this good enough? */
			new = xnfcalloc(1, sizeof (DisplayModeRec));
			memcpy(new, p, sizeof(DisplayModeRec));
			new->name = xnfalloc(strlen(p->name) + 1);
			strcpy(new->name, p->name);
			new->status = MODE_OK;
			new->type   = M_T_DEFAULT;

			count++;

			xf86DrvMsg(pScrn->scrnIndex, X_INFO,
				   "Valid Mode from established timing "
				   "table: %s\n", new->name);

			RADEONSortModes(&new, &first, &last);
			break;
		    }
		}
	    }
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Total of %d mode(s) found.\n", count);

    return first;
}

/* XFree86's xf86ValidateModes routine doesn't work well with DDC modes,
 * so here is our own validation routine.
 */
static int RADEONValidateDDCModes(ScrnInfoPtr pScrn, char **ppModeName,
				  RADEONMonitorType DisplayType)
{
    RADEONInfoPtr   info       = RADEONPTR(pScrn);
    DisplayModePtr  p;
    DisplayModePtr  last       = NULL;
    DisplayModePtr  first      = NULL;
    DisplayModePtr  ddcModes   = NULL;
    int             count      = 0;
    int             i, width, height;

    pScrn->virtualX = pScrn->display->virtualX;
    pScrn->virtualY = pScrn->display->virtualY;

    if (pScrn->monitor->DDC && !info->UseBiosDividers) {
	int  maxVirtX = pScrn->virtualX;
	int  maxVirtY = pScrn->virtualY;

	if ((DisplayType != MT_CRT) && !info->IsSecondary) {
	    /* The panel size we collected from BIOS may not be the
	     * maximum size supported by the panel.  If not, we update
	     * it now.  These will be used if no matching mode can be
	     * found from EDID data.
	     */
	    RADEONUpdatePanelSize(pScrn);
	}

	/* Collect all of the DDC modes */
	first = last = ddcModes = RADEONDDCModes(pScrn);

	for (p = ddcModes; p; p = p->next) {

	    /* If primary head is a flat panel, use RMX by default */
	    if ((!info->IsSecondary && DisplayType != MT_CRT) &&
		!info->ddc_mode) {
		/* These values are effective values after expansion.
		 * They are not really used to set CRTC registers.
		 */
		p->HTotal     = info->PanelXRes + info->HBlank;
		p->HSyncStart = info->PanelXRes + info->HOverPlus;
		p->HSyncEnd   = p->HSyncStart + info->HSyncWidth;
		p->VTotal     = info->PanelYRes + info->VBlank;
		p->VSyncStart = info->PanelYRes + info->VOverPlus;
		p->VSyncEnd   = p->VSyncStart + info->VSyncWidth;
		p->Clock      = info->DotClock;

		p->Flags     |= RADEON_USE_RMX;
	    }

	    maxVirtX = MAX(maxVirtX, p->HDisplay);
	    maxVirtY = MAX(maxVirtY, p->VDisplay);
	    count++;

	    last = p;
	}

	/* Match up modes that are specified in the XF86Config file */
	if (ppModeName[0]) {
	    DisplayModePtr  next;

	    /* Reset the max virtual dimensions */
	    maxVirtX = pScrn->virtualX;
	    maxVirtY = pScrn->virtualY;

	    /* Reset list */
	    first = last = NULL;

	    for (i = 0; ppModeName[i]; i++) {
		/* FIXME: Use HDisplay and VDisplay instead of mode string */
		if (sscanf(ppModeName[i], "%dx%d", &width, &height) == 2) {
		    for (p = ddcModes; p; p = next) {
			next = p->next;

			if (p->HDisplay == width && p->VDisplay == height) {
			    /* We found a DDC mode that matches the one
                               requested in the XF86Config file */
			    p->type |= M_T_USERDEF;

			    /* Update  the max virtual setttings */
			    maxVirtX = MAX(maxVirtX, width);
			    maxVirtY = MAX(maxVirtY, height);

			    /* Unhook from DDC modes */
			    if (p->prev) p->prev->next = p->next;
			    if (p->next) p->next->prev = p->prev;
			    if (p == ddcModes) ddcModes = p->next;

			    /* Add to used modes */
			    if (last) {
				last->next = p;
				p->prev = last;
			    } else {
				first = p;
				p->prev = NULL;
			    }
			    p->next = NULL;
			    last = p;

			    break;
			}
		    }
		}
	    }

	    /*
	     * Add remaining DDC modes if they're smaller than the user
	     * specified modes
	     */
	    for (p = ddcModes; p; p = next) {
		next = p->next;
		if (p->HDisplay <= maxVirtX && p->VDisplay <= maxVirtY) {
		    /* Unhook from DDC modes */
		    if (p->prev) p->prev->next = p->next;
		    if (p->next) p->next->prev = p->prev;
		    if (p == ddcModes) ddcModes = p->next;

		    /* Add to used modes */
		    if (last) {
			last->next = p;
			p->prev = last;
		    } else {
			first = p;
			p->prev = NULL;
		    }
		    p->next = NULL;
		    last = p;
		}
	    }

	    /* Delete unused modes */
	    while (ddcModes)
		xf86DeleteMode(&ddcModes, ddcModes);
	} else {
	    /*
	     * No modes were configured, so we make the DDC modes
	     * available for the user to cycle through.
	     */
	    for (p = ddcModes; p; p = p->next)
		p->type |= M_T_USERDEF;
	}

	pScrn->virtualX = pScrn->display->virtualX = maxVirtX;
	pScrn->virtualY = pScrn->display->virtualY = maxVirtY;
    }

    /* Close the doubly-linked mode list, if we found any usable modes */
    if (last) {
	last->next   = first;
	first->prev  = last;
	pScrn->modes = first;
	RADEONSetPitch(pScrn);
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Total number of valid DDC mode(s) found: %d\n", count);

    return count;
}

/* This is used only when no mode is specified for FP and no ddc is
 * available.  We force it to native mode, if possible.
 */
static DisplayModePtr RADEONFPNativeMode(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr   info  = RADEONPTR(pScrn);
    DisplayModePtr  new   = NULL;
    char            stmp[32];

    if (info->PanelXRes != 0 &&
	info->PanelYRes != 0 &&
	info->DotClock != 0) {

	/* Add native panel size */
	new             = xnfcalloc(1, sizeof (DisplayModeRec));
	sprintf(stmp, "%dx%d", info->PanelXRes, info->PanelYRes);
	new->name       = xnfalloc(strlen(stmp) + 1);
	strcpy(new->name, stmp);
	new->HDisplay   = info->PanelXRes;
	new->VDisplay   = info->PanelYRes;

	new->HTotal     = new->HDisplay + info->HBlank;
	new->HSyncStart = new->HDisplay + info->HOverPlus;
	new->HSyncEnd   = new->HSyncStart + info->HSyncWidth;
	new->VTotal     = new->VDisplay + info->VBlank;
	new->VSyncStart = new->VDisplay + info->VOverPlus;
	new->VSyncEnd   = new->VSyncStart + info->VSyncWidth;

	new->Clock      = info->DotClock;
	new->Flags      = 0;
	new->type       = M_T_USERDEF;

	new->next       = NULL;
	new->prev       = NULL;

	pScrn->display->virtualX =
	    pScrn->virtualX = MAX(pScrn->virtualX, info->PanelXRes);
	pScrn->display->virtualY =
	    pScrn->virtualY = MAX(pScrn->virtualY, info->PanelYRes);

	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "No valid mode specified, force to native mdoe\n");
    }

    return new;
}

/* FP mode initialization routine for using on-chip RMX to scale
 */
static int RADEONValidateFPModes(ScrnInfoPtr pScrn, char **ppModeName)
{
    RADEONInfoPtr   info       = RADEONPTR(pScrn);
    DisplayModePtr  last       = NULL;
    DisplayModePtr  new        = NULL;
    DisplayModePtr  first      = NULL;
    DisplayModePtr  p, tmp;
    int             count      = 0;
    int             i, width, height;

    pScrn->virtualX = pScrn->display->virtualX;
    pScrn->virtualY = pScrn->display->virtualY;

    /* We have a flat panel connected to the primary display, and we
     * don't have any DDC info.
     */
    for (i = 0; ppModeName[i] != NULL; i++) {

	if (sscanf(ppModeName[i], "%dx%d", &width, &height) != 2) continue;

	/* Note: We allow all non-standard modes as long as they do not
	 * exceed the native resolution of the panel.  Since these modes
	 * need the internal RMX unit in the video chips (and there is
	 * only one per card), this will only apply to the primary head.
	 */
	if (width < 320 || width > info->PanelXRes ||
	    height < 200 || height > info->PanelYRes) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Mode %s is out of range.\n", ppModeName[i]);
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Valid modes must be between 320x200-%dx%d\n",
		       info->PanelXRes, info->PanelYRes);
	    continue;
	}

	new             = xnfcalloc(1, sizeof(DisplayModeRec));
	new->name       = xnfalloc(strlen(ppModeName[i]) + 1);
	strcpy(new->name, ppModeName[i]);
	new->HDisplay   = width;
	new->VDisplay   = height;

	/* These values are effective values after expansion They are
	 * not really used to set CRTC registers.
	 */
	new->HTotal     = info->PanelXRes + info->HBlank;
	new->HSyncStart = info->PanelXRes + info->HOverPlus;
	new->HSyncEnd   = new->HSyncStart + info->HSyncWidth;
	new->VTotal     = info->PanelYRes + info->VBlank;
	new->VSyncStart = info->PanelYRes + info->VOverPlus;
	new->VSyncEnd   = new->VSyncStart + info->VSyncWidth;
	new->Clock      = info->DotClock;
	new->Flags     |= RADEON_USE_RMX;

	new->type      |= M_T_USERDEF;

	new->next       = NULL;
	new->prev       = last;

	if (last) last->next = new;
	last = new;
	if (!first) first = new;

	pScrn->display->virtualX =
	    pScrn->virtualX = MAX(pScrn->virtualX, width);
	pScrn->display->virtualY =
	    pScrn->virtualY = MAX(pScrn->virtualY, height);
	count++;
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Valid mode using on-chip RMX: %s\n", new->name);
    }

    /* If all else fails, add the native mode */
    if (!count) {
	first = last = RADEONFPNativeMode(pScrn);
	if (first) count = 1;
    }

    /* add in all default vesa modes smaller than panel size, used for randr*/
    for (p = pScrn->monitor->Modes; p && p->next; p = p->next->next) {
	if ((p->HDisplay <= info->PanelXRes) && (p->VDisplay <= info->PanelYRes)) {
	    tmp = first;
	    while (tmp) {
		if ((p->HDisplay == tmp->HDisplay) && (p->VDisplay == tmp->VDisplay)) break;
		tmp = tmp->next;
	    }
	    if (!tmp) {
		new             = xnfcalloc(1, sizeof(DisplayModeRec));
		new->name       = xnfalloc(strlen(p->name) + 1);
		strcpy(new->name, p->name);
		new->HDisplay   = p->HDisplay;
		new->VDisplay   = p->VDisplay;

		/* These values are effective values after expansion They are
		 * not really used to set CRTC registers.
		 */
		new->HTotal     = info->PanelXRes + info->HBlank;
		new->HSyncStart = info->PanelXRes + info->HOverPlus;
		new->HSyncEnd   = new->HSyncStart + info->HSyncWidth;
		new->VTotal     = info->PanelYRes + info->VBlank;
		new->VSyncStart = info->PanelYRes + info->VOverPlus;
		new->VSyncEnd   = new->VSyncStart + info->VSyncWidth;
		new->Clock      = info->DotClock;
		new->Flags     |= RADEON_USE_RMX;

		new->type      |= M_T_DEFAULT;

		new->next       = NULL;
		new->prev       = last;

		last->next = new;
		last = new;
	    }
	}
    }

    /* Close the doubly-linked mode list, if we found any usable modes */
    if (last) {
	last->next   = first;
	first->prev  = last;
	pScrn->modes = first;
	RADEONSetPitch(pScrn);
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Total number of valid FP mode(s) found: %d\n", count);

    return count;
}

/* This is called by RADEONPreInit to initialize gamma correction */
static Bool RADEONPreInitGamma(ScrnInfoPtr pScrn)
{
    Gamma  zeros = { 0.0, 0.0, 0.0 };

    if (!xf86SetGamma(pScrn, zeros)) return FALSE;
    return TRUE;
}

static void RADEONSetSyncRangeFromEdid(ScrnInfoPtr pScrn, int flag)
{
    MonPtr      mon = pScrn->monitor;
    xf86MonPtr  ddc = mon->DDC;
    int         i;

    if (flag) { /* HSync */
	for (i = 0; i < 4; i++) {
	    if (ddc->det_mon[i].type == DS_RANGES) {
		mon->nHsync = 1;
		mon->hsync[0].lo = ddc->det_mon[i].section.ranges.min_h;
		mon->hsync[0].hi = ddc->det_mon[i].section.ranges.max_h;
		return;
	    }
	}
	/* If no sync ranges detected in detailed timing table, let's
	 * try to derive them from supported VESA modes.  Are we doing
	 * too much here!!!?  */
	i = 0;
	if (ddc->timings1.t1 & 0x02) { /* 800x600@@56 */
	    mon->hsync[i].lo = mon->hsync[i].hi = 35.2;
	    i++;
	}
	if (ddc->timings1.t1 & 0x04) { /* 640x480@@75 */
	    mon->hsync[i].lo = mon->hsync[i].hi = 37.5;
	    i++;
	}
	if ((ddc->timings1.t1 & 0x08) || (ddc->timings1.t1 & 0x01)) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 37.9;
	    i++;
	}
	if (ddc->timings1.t2 & 0x40) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 46.9;
	    i++;
	}
	if ((ddc->timings1.t2 & 0x80) || (ddc->timings1.t2 & 0x08)) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 48.1;
	    i++;
	}
	if (ddc->timings1.t2 & 0x04) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 56.5;
	    i++;
	}
	if (ddc->timings1.t2 & 0x02) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 60.0;
	    i++;
	}
	if (ddc->timings1.t2 & 0x01) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 64.0;
	    i++;
	}
	mon->nHsync = i;
    } else {  /* Vrefresh */
	for (i = 0; i < 4; i++) {
	    if (ddc->det_mon[i].type == DS_RANGES) {
		mon->nVrefresh = 1;
		mon->vrefresh[0].lo = ddc->det_mon[i].section.ranges.min_v;
		mon->vrefresh[0].hi = ddc->det_mon[i].section.ranges.max_v;
		return;
	    }
	}

	i = 0;
	if (ddc->timings1.t1 & 0x02) { /* 800x600@@56 */
	    mon->vrefresh[i].lo = mon->vrefresh[i].hi = 56;
	    i++;
	}
	if ((ddc->timings1.t1 & 0x01) || (ddc->timings1.t2 & 0x08)) {
	    mon->vrefresh[i].lo = mon->vrefresh[i].hi = 60;
	    i++;
	}
	if (ddc->timings1.t2 & 0x04) {
	    mon->vrefresh[i].lo = mon->vrefresh[i].hi = 70;
	    i++;
	}
	if ((ddc->timings1.t1 & 0x08) || (ddc->timings1.t2 & 0x80)) {
	    mon->vrefresh[i].lo = mon->vrefresh[i].hi = 72;
	    i++;
	}
	if ((ddc->timings1.t1 & 0x04) || (ddc->timings1.t2 & 0x40) ||
	    (ddc->timings1.t2 & 0x02) || (ddc->timings1.t2 & 0x01)) {
	    mon->vrefresh[i].lo = mon->vrefresh[i].hi = 75;
	    i++;
	}
	mon->nVrefresh = i;
    }
d1327 3
a1329 1
static int RADEONValidateCloneModes(ScrnInfoPtr pScrn)
d1331 10
a1340 40
    RADEONInfoPtr   info             = RADEONPTR(pScrn);
    ClockRangePtr   clockRanges;
    DisplayModePtr  tmp_mode         = NULL;
    DisplayModePtr  clone_mode, save_mode;
    int             modesFound       = 0;
    int             count            = 0;
    int             tmp_hdisplay     = 0;
    int             tmp_vdisplay     = 0;
    int             i, save_n_hsync, save_n_vrefresh;
    range           save_hsync, save_vrefresh;
    char            *s;
    char            **clone_mode_names = NULL;
    Bool            ddc_mode         = info->ddc_mode;
    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);

    /* Save all infomations that will be changed by clone mode validateion */
    save_mode = pScrn->modes;
    pScrn->modes = NULL;

    /* Clone display mode names, duplicate all mode names for primary
     * head.  Allocate one more, in case pScrn->display->modes[0] ==
     * NULL */
    while (pScrn->display->modes[count]) count++;
    clone_mode_names = xnfalloc((count+2) * sizeof(char*));
    for (i = 0; i < count; i++) {
	clone_mode_names[i] = xnfalloc(strlen(pScrn->display->modes[i]) + 1);
	strcpy(clone_mode_names[i], pScrn->display->modes[i]);
    }
    clone_mode_names[count]   = NULL;
    clone_mode_names[count+1] = NULL;

    pScrn->progClock = TRUE;

    clockRanges                    = xnfcalloc(sizeof(*clockRanges), 1);
    clockRanges->next              = NULL;
    clockRanges->minClock          = info->pll.min_pll_freq;
    clockRanges->maxClock          = info->pll.max_pll_freq * 10;
    clockRanges->clockIndex        = -1;
    clockRanges->interlaceAllowed  = (info->CloneType == MT_CRT);
    clockRanges->doubleScanAllowed = (info->CloneType == MT_CRT);
d1342 16
a1357 11
    /* Only take one clone mode from config file for now, rest of clone
     * modes will copy from primary head.
     */
    if ((s = xf86GetOptValString(info->Options, OPTION_CLONE_MODE))) {
	if (sscanf(s, "%dx%d", &tmp_hdisplay, &tmp_vdisplay) == 2) {
	    if(count > 0) free(clone_mode_names[0]);
	    else count++;
	    clone_mode_names[0] = xnfalloc(strlen(s)+1);
	    sprintf(clone_mode_names[0], "%dx%d", tmp_hdisplay, tmp_vdisplay);
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Clone mode %s in config file is used\n", clone_mode_names[0]);
	}
d1360 8
a1367 9
    for (i = 0; i < count; i++) {
	if (sscanf(clone_mode_names[i], "%dx%d",
		   &tmp_hdisplay, &tmp_vdisplay) == 2) {
	    if (pScrn->display->virtualX < tmp_hdisplay)
		pScrn->display->virtualX = tmp_hdisplay;
	    if (pScrn->display->virtualY < tmp_vdisplay)
		pScrn->display->virtualY = tmp_vdisplay;
	}
    }
d1369 5
a1373 18
    save_hsync      = pScrn->monitor->hsync[0];
    save_vrefresh   = pScrn->monitor->vrefresh[0];
    save_n_hsync    = pScrn->monitor->nHsync;
    save_n_vrefresh = pScrn->monitor->nVrefresh;

    pScrn->monitor->DDC       = NULL;
    pScrn->monitor->nHsync    = 0;
    pScrn->monitor->nVrefresh = 0;

    if ((s = xf86GetOptValString(info->Options, OPTION_CLONE_HSYNC))) {
	if (sscanf(s, "%f-%f", &pScrn->monitor->hsync[0].lo,
		   &pScrn->monitor->hsync[0].hi) == 2) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "HSync for CloneMode from config file: %s\n", s);
	    pScrn->monitor->nHsync = 1;
	} else {
	    pScrn->monitor->nHsync = 0;
	}
d1375 4
a1378 10

    if ((s = xf86GetOptValString(info->Options, OPTION_CLONE_VREFRESH))) {
	if (sscanf(s, "%f-%f", &pScrn->monitor->vrefresh[0].lo,
		   &pScrn->monitor->vrefresh[0].hi) == 2) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "VRefresh for CloneMode from config file: %s\n", s);
	    pScrn->monitor->nVrefresh = 1;
	} else {
	    pScrn->monitor->nVrefresh = 0;
	}
d1381 1
a1381 36
    pScrn->monitor->DDC = pRADEONEnt->MonInfo2;
    if (pScrn->monitor->DDC) {
        if ((pScrn->monitor->nVrefresh == 0) || (pScrn->monitor->nHsync == 0)) {
            if (pScrn->monitor->nHsync == 0)
                RADEONSetSyncRangeFromEdid(pScrn, 1);
            if (pScrn->monitor->nVrefresh == 0)
                RADEONSetSyncRangeFromEdid(pScrn, 0);
        }
    } else if (info->ddc_mode) {
        ddc_mode = FALSE;
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                   "No DDC data available for clone mode, "
                   "DDCMode option is dismissed\n");
    }

    if (info->CloneType == MT_CRT && !ddc_mode) {
	modesFound =
	    xf86ValidateModes(pScrn, pScrn->monitor->Modes,
			      clone_mode_names,
			      clockRanges,
			      NULL,                     /* linePitches */
			      8 * 64,                   /* minPitch */
			      8 * 1024,                 /* maxPitch */
			      64 * pScrn->bitsPerPixel, /* pitchInc */
			      128,                      /* minHeight */
			      2048,                     /* maxHeight */
			      pScrn->display->virtualX,
			      pScrn->display->virtualY,
			      info->FbMapSize,
			      LOOKUP_BEST_REFRESH);
    } else {
	/* Try to add DDC modes */
	info->IsSecondary = TRUE; /*fake secondary head*/
	modesFound = RADEONValidateDDCModes(pScrn, clone_mode_names,
					    info->CloneType);
	info->IsSecondary = FALSE;
d1383 8
a1390 18
	/* If that fails and we're connect to a flat panel, then try to
         * add the flat panel modes
	 */
	if (modesFound < 1 && info->CloneType != MT_CRT) {
	    modesFound =
		xf86ValidateModes(pScrn, pScrn->monitor->Modes,
				  clone_mode_names,
				  clockRanges,
				  NULL,                     /* linePitches */
				  8 * 64,                   /* minPitch */
				  8 * 1024,                 /* maxPitch */
				  64 * pScrn->bitsPerPixel, /* pitchInc */
				  128,                      /* minHeight */
				  2048,                     /* maxHeight */
				  pScrn->display->virtualX,
				  pScrn->display->virtualY,
				  info->FbMapSize,
				  LOOKUP_BEST_REFRESH);
d1392 1
d1394 1
d1396 6
a1401 6
    if (modesFound > 0) {
        int valid = 0;
        save_mode = pScrn->modes;
	xf86SetCrtcForModes(pScrn, 0);
	xf86PrintModes(pScrn);
	for (i = 0; i < modesFound; i++) {
a1402 4
	    while (pScrn->modes->status != MODE_OK) {
		pScrn->modes = pScrn->modes->next;
	    }
	    if (!pScrn->modes) break;
d1404 21
a1424 1
	    if (pScrn->modes->Clock != 0.0) {
d1426 28
a1453 45
		clone_mode = xnfcalloc (1, sizeof (DisplayModeRec));
		if (!clone_mode) break;
		memcpy(clone_mode, pScrn->modes, sizeof(DisplayModeRec));
		clone_mode->name = xnfalloc(strlen(pScrn->modes->name) + 1);
		strcpy(clone_mode->name, pScrn->modes->name);

		if (!info->CurCloneMode) {
		    info->CloneModes = clone_mode;
		    info->CurCloneMode = clone_mode;
		    clone_mode->prev = NULL;
		} else {
		    clone_mode->prev = tmp_mode;
		    clone_mode->prev->next = clone_mode;
		}
		valid++;

		tmp_mode = clone_mode;
		clone_mode->next = NULL;
	    }
	    pScrn->modes = pScrn->modes->next;
	}

	/* no longer needed, free it */
	pScrn->modes = save_mode;
	while (pScrn->modes)
	  xf86DeleteMode(&pScrn->modes, pScrn->modes);
	pScrn->modes = NULL;

	/* modepool is no longer needed, free it */
	while (pScrn->modePool)
	  xf86DeleteMode(&pScrn->modePool, pScrn->modePool);
	pScrn->modePool = NULL;

	modesFound = valid;
    }

    /* Clone_mode_names list is no longer needed, free it. */
    if (clone_mode_names) {
	for (i = 0; clone_mode_names[i]; i++) {
	    free(clone_mode_names[i]);
	    clone_mode_names[i] = NULL;
	}

	free(clone_mode_names);
	clone_mode_names = NULL;
d1455 1
d1457 7
a1463 1
    /* We need to restore all changed info for the primary head */
d1465 2
a1466 4
    pScrn->monitor->hsync[0]    = save_hsync;
    pScrn->monitor->vrefresh[0] = save_vrefresh;
    pScrn->monitor->nHsync      = save_n_hsync;
    pScrn->monitor->nVrefresh   = save_n_vrefresh;
d1468 2
a1469 8
    /*
     * Also delete the clockRanges (if it was setup) since it will be
     * set up during the primary head initialization.
     */
    while (pScrn->clockRanges) {
	ClockRangesPtr CRtmp = pScrn->clockRanges;
	pScrn->clockRanges = pScrn->clockRanges->next;
	xfree(CRtmp);
d1471 1
a1471 3


    return modesFound;
d1474 6
a1479 4
/* This is called by RADEONPreInit to validate modes and compute
 * parameters for all of the valid modes.
 */
static Bool RADEONPreInitModes(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
d1481 3
a1483 35
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    ClockRangePtr  clockRanges;
    int            modesFound;
    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
    char           *s;

    /* This option has two purposes:
     *
     * 1. For CRT, if this option is on, xf86ValidateModes (to
     *    LOOKUP_BEST_REFRESH) is not going to be used for mode
     *    validation.  Instead, we'll validate modes by matching exactly
     *    the modes supported from the DDC data.  This option can be
     *    used (a) to enable non-standard modes listed in the Detailed
     *    Timings block of EDID, like 2048x1536 (not included in
     *    xf86DefModes), (b) to avoid unstable modes for some flat
     *    panels working in analog mode (some modes validated by
     *    xf86ValidateModes don't really work with these panels).
     *
     * 2. For DFP on primary head, with this option on, the validation
     *    routine will try to use supported modes from DDC data first
     *    before trying on-chip RMX streching.  By default, native mode
     *    + RMX streching is used for all non-native modes, it appears
     *    more reliable. Some non-native modes listed in the DDC data
     *    may not work properly if they are used directly. This seems to
     *    only happen to a few panels (haven't nailed this down yet, it
     *    may related to the incorrect setting in TMDS_PLL_CNTL when
     *    pixel clock is changed).  Use this option may give you better
     *    refresh rate for some non-native modes.  The 2nd DVI port will
     *    always use DDC modes directly (only have one on-chip RMX
     *    unit).
     *
     * Note: This option will be dismissed if no DDC data is available.
     */
    info->ddc_mode =
	xf86ReturnOptValBool(info->Options, OPTION_DDC_MODE, FALSE);
d1485 8
a1492 37
    /* don't use RMX if we have a dual-tdms panels */
   if (pRADEONEnt->MonType2 == MT_DFP)
	info->ddc_mode = TRUE;

    /* Here is a hack for cloning first display on the second head.  If
     * we don't do this, when both heads are connected, the same CRTC
     * will be used to drive them according to the capability of the
     * primary head.  This can cause an unstable or blank screen, or
     * even worse it can damage a monitor.  This feature is also
     * important for laptops (using M6, M7), where the panel can't be
     * disconnect when one wants to use the CRT port.  Although 2
     * Screens can be set up in the config file for displaying same
     * content on two monitors, it has problems with cursor, overlay,
     * DRI.
     */
    if (info->HasCRTC2) {
	if (info->Clone) {

	    /* If we have 2 screens from the config file, we don't need
	     * to do clone thing, let each screen handles one head.
	     */
	    if (!pRADEONEnt->HasSecondary) {
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "Clone modes validation ------------ \n");

		modesFound = RADEONValidateCloneModes(pScrn);
		if (modesFound < 1) {
		    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			       "No valid mode found for CRTC2 clone\n");
		    info->Clone = FALSE;
		    info->CurCloneMode = NULL;
		}
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "Total of %d clone modes found ------------ \n\n",
			   modesFound);
	    }
	}
d1495 2
a1496 3
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Validating modes on %s head ---------\n",
	       info->IsSecondary ? "Secondary" : "Primary");
d1498 6
a1503 9
    if (info->IsSecondary)
        pScrn->monitor->DDC = pRADEONEnt->MonInfo2;
    else
        pScrn->monitor->DDC = pRADEONEnt->MonInfo1;

    if (!pScrn->monitor->DDC && info->ddc_mode) {
	info->ddc_mode = FALSE;
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "No DDC data available, DDCMode option is dismissed\n");
d1506 4
a1509 52
    if ((info->DisplayType == MT_DFP) ||
	(info->DisplayType == MT_LCD)) {
	if ((s = xf86GetOptValString(info->Options, OPTION_PANEL_SIZE))) {
	    int PanelX, PanelY;
	    DisplayModePtr  tmp_mode         = NULL;
	    if (sscanf(s, "%dx%d", &PanelX, &PanelY) == 2) {
		info->PanelXRes = PanelX;
		info->PanelYRes = PanelY;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			   "Panel size is forced to: %s\n", s);

		/* We can't trust BIOS or DDC timings anymore,
		   Use whatever specified in the Modeline.
		   If no Modeline specified, we'll just pick the VESA mode at
		   60Hz refresh rate which is likely to be the best for a flat panel.
		*/
		info->ddc_mode = FALSE;
		pScrn->monitor->DDC = NULL;
		tmp_mode = pScrn->monitor->Modes;
		while(tmp_mode) {
		    if ((tmp_mode->HDisplay == PanelX) &&
			(tmp_mode->VDisplay == PanelY)) {

			float  refresh =
			    (float)tmp_mode->Clock * 1000.0 / tmp_mode->HTotal / tmp_mode->VTotal;
			if ((abs(60.0 - refresh) < 1.0) ||
			    (tmp_mode->type == 0)) {
			    info->HBlank     = tmp_mode->HTotal - tmp_mode->HDisplay;
			    info->HOverPlus  = tmp_mode->HSyncStart - tmp_mode->HDisplay;
			    info->HSyncWidth = tmp_mode->HSyncEnd - tmp_mode->HSyncStart;
			    info->VBlank     = tmp_mode->VTotal - tmp_mode->VDisplay;
			    info->VOverPlus  = tmp_mode->VSyncStart - tmp_mode->VDisplay;
			    info->VSyncWidth = tmp_mode->VSyncEnd - tmp_mode->VSyncStart;
			    info->DotClock   = tmp_mode->Clock;
			    info->Flags = 0;
			    break;
			}
		    }
		    tmp_mode = tmp_mode->next;
		}
		if (info->DotClock == 0) {
		    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			       "No valid timing info for specified panel size.\n"
			       "Please specify the Modeline for this panel\n");
		    return FALSE;
		}
	    } else {
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			   "Invalid PanelSize value: %s\n", s);
	    }
	}
    }
d1511 16
a1526 30
    if (pScrn->monitor->DDC) {
        /* If we still don't know sync range yet, let's try EDID.
         *
         * Note that, since we can have dual heads, Xconfigurator
         * may not be able to probe both monitors correctly through
         * vbe probe function (RADEONProbeDDC). Here we provide an
         * additional way to auto-detect sync ranges if they haven't
         * been added to XF86Config manually.
         */
        if (pScrn->monitor->nHsync <= 0)
            RADEONSetSyncRangeFromEdid(pScrn, 1);
        if (pScrn->monitor->nVrefresh <= 0)
            RADEONSetSyncRangeFromEdid(pScrn, 0);
    }

    /* Get mode information */
    pScrn->progClock               = TRUE;
    clockRanges                    = xnfcalloc(sizeof(*clockRanges), 1);
    clockRanges->next              = NULL;
    clockRanges->minClock          = info->pll.min_pll_freq;
    clockRanges->maxClock          = info->pll.max_pll_freq * 10;
    clockRanges->clockIndex        = -1;
    clockRanges->interlaceAllowed  = (info->DisplayType == MT_CRT);
    clockRanges->doubleScanAllowed = (info->DisplayType == MT_CRT);

    /* We'll use our own mode validation routine for DFP/LCD, since
     * xf86ValidateModes does not work correctly with the DFP/LCD modes
     * 'stretched' from their native mode.
     */
    if (info->DisplayType == MT_CRT && !info->ddc_mode) {
d1528 28
a1555 21
	modesFound =
	    xf86ValidateModes(pScrn,
			      pScrn->monitor->Modes,
			      pScrn->display->modes,
			      clockRanges,
			      NULL,                  /* linePitches */
			      8 * 64,                /* minPitch */
			      8 * 1024,              /* maxPitch */
			      64 * pScrn->bitsPerPixel, /* pitchInc */
			      128,                   /* minHeight */
			      2048,                  /* maxHeight */
			      pScrn->display->virtualX,
			      pScrn->display->virtualY,
			      info->FbMapSize,
			      LOOKUP_BEST_REFRESH);

	if (modesFound < 1 && info->FBDev) {
	    fbdevHWUseBuildinMode(pScrn);
	    pScrn->displayWidth = pScrn->virtualX; /* FIXME: might be wrong */
	    modesFound = 1;
	}
d1557 23
a1579 1
	if (modesFound == -1) return FALSE;
d1581 1
a1581 5
	xf86PruneDriverModes(pScrn);
	if (!modesFound || !pScrn->modes) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes found\n");
	    return FALSE;
	}
d1583 2
a1584 8
    } else {
	/* First, free any allocated modes during configuration, since
	 * we don't need them
	 */
	while (pScrn->modes)
	    xf86DeleteMode(&pScrn->modes, pScrn->modes);
	while (pScrn->modePool)
	    xf86DeleteMode(&pScrn->modePool, pScrn->modePool);
d1586 4
a1589 3
	/* Next try to add DDC modes */
	modesFound = RADEONValidateDDCModes(pScrn, pScrn->display->modes,
					    info->DisplayType);
d1591 3
a1593 4
	/* If that fails and we're connect to a flat panel, then try to
         * add the flat panel modes
	 */
	if (info->DisplayType != MT_CRT) {
d1595 118
a1712 38
	    /* some panels have DDC, but don't have internal scaler.
	     * in this case, we need to validate additional modes
	     * by using on-chip RMX.
	     */
	    int user_modes_asked = 0, user_modes_found = 0, i;
	    DisplayModePtr  tmp_mode = pScrn->modes;
	    while (pScrn->display->modes[user_modes_asked]) user_modes_asked++;
	    if (tmp_mode) {
		for (i = 0; i < modesFound; i++) {
		    if (tmp_mode->type & M_T_USERDEF) user_modes_found++;
		    tmp_mode = tmp_mode->next;
		}
	    }

	    if ((modesFound <= 1) || (user_modes_found < user_modes_asked)) {
		/* when panel size is not valid, try to validate
		 * mode using xf86ValidateModes routine
		 * This can happen when DDC is disabled.
		 */
		if (info->PanelXRes < 320 || info->PanelYRes < 200)
		    modesFound =
			xf86ValidateModes(pScrn,
					  pScrn->monitor->Modes,
					  pScrn->display->modes,
					  clockRanges,
					  NULL,                  /* linePitches */
					  8 * 64,                /* minPitch */
					  8 * 1024,              /* maxPitch */
					  64 * pScrn->bitsPerPixel, /* pitchInc */
					  128,                   /* minHeight */
					  2048,                  /* maxHeight */
					  pScrn->display->virtualX,
					  pScrn->display->virtualY,
					  info->FbMapSize,
					  LOOKUP_BEST_REFRESH);
		else if (!info->IsSecondary)
		    modesFound = RADEONValidateFPModes(pScrn, pScrn->display->modes);
	    }
d1714 3
d1718 11
a1728 6
	/* Setup the screen's clockRanges for the VidMode extension */
	if (!pScrn->clockRanges) {
	    pScrn->clockRanges = xnfcalloc(sizeof(*(pScrn->clockRanges)), 1);
	    memcpy(pScrn->clockRanges, clockRanges, sizeof(*clockRanges));
	    pScrn->clockRanges->strategy = LOOKUP_BEST_REFRESH;
	}
d1730 29
a1758 13
	/* Fail if we still don't have any valid modes */
	if (modesFound < 1) {
	    if (info->DisplayType == MT_CRT) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "No valid DDC modes found for this CRT\n");
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Try turning off the \"DDCMode\" option\n");
	    } else {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "No valid mode found for this DFP/LCD\n");
	    }
	    return FALSE;
	}
d1761 31
d1793 3
d1797 12
a1808 17
    /* We need to adjust virtual size if the clone modes have larger
     * display size.
     */
    if (info->Clone && info->CloneModes) {
	DisplayModePtr  clone_mode = info->CloneModes;
	while (1) {
	    if ((clone_mode->HDisplay > pScrn->virtualX) ||
		(clone_mode->VDisplay > pScrn->virtualY)) {
		pScrn->virtualX =
		    pScrn->display->virtualX = clone_mode->HDisplay;
		pScrn->virtualY =
		    pScrn->display->virtualY = clone_mode->VDisplay;
		RADEONSetPitch(pScrn);
	    }
	    if (!clone_mode->next) break;
	    clone_mode = clone_mode->next;
	}
d1818 9
a1826 1
    if (!xf86LoadSubModule(pScrn, "fb")) return FALSE;
d1828 3
d1832 3
d1842 1
a1842 1
/* This is called by RADEONPreInit to initialize the hardware cursor */
d1845 1
a1845 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d1854 1
a1854 1
/* This is called by RADEONPreInit to initialize hardware acceleration */
d1857 1
a1857 2
#ifdef XFree86LOADER
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d1860 1
a1860 15
	int errmaj = 0, errmin = 0;

	info->xaaReq.majorversion = 1;
	info->xaaReq.minorversion = 1;

	if (!LoadSubModule(pScrn->module, "xaa", NULL, NULL, NULL,
			   &info->xaaReq, &errmaj, &errmin)) {
	    info->xaaReq.minorversion = 0;

	    if (!LoadSubModule(pScrn->module, "xaa", NULL, NULL, NULL,
			       &info->xaaReq, &errmaj, &errmin)) {
		LoaderErrorMsg(NULL, "xaa", errmaj, errmin);
		return FALSE;
	    }
	}
a1862 2
#endif

d1868 1
a1868 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d1880 1
d1884 1
a1884 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d1894 1
a1894 1
    info->gartSize      = RADEON_DEFAULT_GART_SIZE;
d1897 1
a1897 2
    info->gartTexSize   = RADEON_DEFAULT_GART_TEX_SIZE;
    info->agpFastWrite  = RADEON_DEFAULT_AGP_FAST_WRITE;
d1913 16
a1928 8
	if ((info->agpFastWrite = xf86ReturnOptValBool(info->Options,
						       OPTION_AGP_FW,
						       FALSE))) {
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       "Enabling AGP Fast Write\n");
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "AGP Fast Write disabled by default\n");
a1929 1
    }
d1931 8
a1938 16
    if (xf86GetOptValInteger(info->Options,
			     OPTION_GART_SIZE, (int *)&(info->gartSize))) {
	switch (info->gartSize) {
	case 4:
	case 8:
	case 16:
	case 32:
	case 64:
	case 128:
	case 256:
	    break;

	default:
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Illegal GART size: %d MB\n", info->gartSize);
	    return FALSE;
a1939 1
    }
d1941 16
a1956 7
    if (xf86GetOptValInteger(info->Options,
			     OPTION_RING_SIZE, &(info->ringSize))) {
	if (info->ringSize < 1 || info->ringSize >= (int)info->gartSize) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Illegal ring buffer size: %d MB\n",
		       info->ringSize);
	    return FALSE;
a1957 1
    }
d1959 2
a1960 3
    if (xf86GetOptValInteger(info->Options,
			     OPTION_BUFFER_SIZE, &(info->bufSize))) {
	if (info->bufSize < 1 || info->bufSize >= (int)info->gartSize) {
d1962 1
a1962 2
		       "Illegal vertex/indirect buffers size: %d MB\n",
		       info->bufSize);
a1964 9
	if (info->bufSize > 2) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Illegal vertex/indirect buffers size: %d MB\n",
		       info->bufSize);
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Clamping vertex/indirect buffers size to 2 MB\n");
	    info->bufSize = 2;
	}
    }
d1966 1
a1966 5
    if (info->ringSize + info->bufSize + info->gartTexSize >
	(int)info->gartSize) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Buffers are too big for requested GART space\n");
	return FALSE;
a1968 2
    info->gartTexSize = info->gartSize - (info->ringSize + info->bufSize);

a1982 24
    /* Two options to try and squeeze as much texture memory as possible
     * for dedicated 3d rendering boxes
     */
    info->noBackBuffer = xf86ReturnOptValBool(info->Options,
					      OPTION_NO_BACKBUFFER,
					      FALSE);

    if (info->noBackBuffer) {
	info->allowPageFlip = 0;
    } else if (!xf86LoadSubModule(pScrn, "shadowfb")) {
	info->allowPageFlip = 0;
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Couldn't load shadowfb module:\n");
    } else {
	xf86LoaderReqSymLists(driShadowFBSymbols, NULL);

	info->allowPageFlip = xf86ReturnOptValBool(info->Options,
						   OPTION_PAGE_FLIP,
						   FALSE);
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Page flipping %sabled\n",
	       info->allowPageFlip ? "en" : "dis");

d1989 102
a2090 2
{
    vbeInfoPtr  pVbe;
d2092 25
a2116 3
    if (xf86LoadSubModule(pScrn, "vbe")) {
	pVbe = VBEInit(NULL,indx);
	ConfiguredMonitor = vbeDoEDID(pVbe, NULL);
d2118 4
d2124 2
a2125 1
/* RADEONPreInit is called once at server startup */
d2128 32
a2159 4
    RADEONInfoPtr     info;
    xf86Int10InfoPtr  pInt10 = NULL;
    void *int10_save = NULL;
    const char *s;
d2168 1
a2168 7
    info->Clone        = FALSE;
    info->CurCloneMode = NULL;
    info->CloneModes   = NULL;
    info->IsSwitching  = FALSE;
    info->MMIO         = NULL;

    info->pEnt         = xf86GetEntityInfo(pScrn->entityList[pScrn->numEntities - 1]);
d2171 1
a2171 17
    info->PciInfo = xf86GetPciInfoForEntity(info->pEnt->index);
    info->PciTag  = pciTag(info->PciInfo->bus,
			   info->PciInfo->device,
			   info->PciInfo->func);
    info->MMIOAddr   = info->PciInfo->memBase[2] & 0xffffff00;
    if (info->pEnt->device->IOBase) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		   "MMIO address override, using 0x%08lx instead of 0x%08lx\n",
		   info->pEnt->device->IOBase,
		   info->MMIOAddr);
	info->MMIOAddr = info->pEnt->device->IOBase;
    } else if (!info->MMIOAddr) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid MMIO address\n");
	goto fail1;
    }
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "MMIO registers at 0x%08lx\n", info->MMIOAddr);
d2173 28
a2200 4
    if(!RADEONMapMMIO(pScrn)) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Memory map the MMIO region failed\n");
	goto fail1;
d2203 2
a2204 38
#if !defined(__alpha__)
    if (xf86GetPciDomain(info->PciTag) ||
	!xf86IsPrimaryPci(info->PciInfo))
	RADEONPreInt10Save(pScrn, &int10_save);
#else
    /* [Alpha] On the primary, the console already ran the BIOS and we're
     *         going to run it again - so make sure to "fix up" the card
     *         so that (1) we can read the BIOS ROM and (2) the BIOS will
     *         get the memory config right.
     */
    RADEONPreInt10Save(pScrn, &int10_save);
#endif

    if (xf86IsEntityShared(info->pEnt->index)) {
	if (xf86IsPrimInitDone(info->pEnt->index)) {

	    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);

	    info->IsSecondary = TRUE;
	    if (!pRADEONEnt->HasSecondary) {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "Only one monitor detected, Second screen "
			   "will NOT be created\n");
		goto fail2;
	    }
	    pRADEONEnt->pSecondaryScrn = pScrn;
	} else {
	    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);

	    xf86SetPrimInitDone(info->pEnt->index);

	    pRADEONEnt->pPrimaryScrn        = pScrn;
	    pRADEONEnt->RestorePrimary      = FALSE;
	    pRADEONEnt->IsSecondaryRestored = FALSE;
	}
    }

    if (flags & PROBE_DETECT) {
d2206 1
a2206 2
	RADEONPostInt10Check(pScrn, int10_save);
	if(info->MMIO) RADEONUnmapMMIO(pScrn);
d2212 2
a2213 1
    if (!vgaHWGetHWRec(pScrn)) {
d2215 1
a2215 1
	goto fail2;
d2220 5
d2231 2
a2232 2
    if (xf86RegisterResources(info->pEnt->index, 0, ResExclusive))
	goto fail;
d2234 1
a2234 4
    if (xf86SetOperatingState(resVga, info->pEnt->index, ResUnusedOpr))
	goto fail;

    pScrn->racMemFlags = RAC_FB | RAC_COLORMAP | RAC_VIEWPORT | RAC_CURSOR;
d2237 1
a2237 2
    if (!RADEONPreInitVisual(pScrn))
	goto fail;
d2242 1
a2242 3
    if (!(info->Options = xalloc(sizeof(RADEONOptions))))
	goto fail;

d2246 1
a2246 2
    if (!RADEONPreInitWeight(pScrn))
	goto fail;
d2248 4
a2251 6
    if (xf86GetOptValInteger(info->Options, OPTION_VIDEO_KEY,
			     &(info->videoKey))) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "video key set to 0x%x\n",
		   info->videoKey);
    } else {
	info->videoKey = 0x1E;
d2254 8
a2261 10
    info->DispPriority = 1;
    if ((s = xf86GetOptValString(info->Options, OPTION_DISP_PRIORITY))) {
	if (strcmp(s, "AUTO") == 0) {
	    info->DispPriority = 1;
	} else if (strcmp(s, "BIOS") == 0) {
	    info->DispPriority = 0;
	} else if (strcmp(s, "HIGH") == 0) {
	    info->DispPriority = 2;
	} else
	    info->DispPriority = 1;
d2264 9
a2272 19
    if (xf86ReturnOptValBool(info->Options, OPTION_FBDEV, FALSE)) {
	/* check for Linux framebuffer device */

	if (xf86LoadSubModule(pScrn, "fbdevhw")) {
	    xf86LoaderReqSymLists(fbdevHWSymbols, NULL);

	    if (fbdevHWInit(pScrn, info->PciInfo, NULL)) {
		pScrn->ValidMode     = fbdevHWValidMode;
		info->FBDev = TRUE;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			   "Using framebuffer device\n");
	    } else {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "fbdevHWInit failed, not using framebuffer device\n");
	    }
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Couldn't load fbdevhw module, not using framebuffer device\n");
	}
d2276 3
a2278 2
	if (!RADEONPreInitInt10(pScrn, &pInt10))
	    goto fail;
d2280 1
a2280 1
    RADEONPostInt10Check(pScrn, int10_save);
d2282 9
a2290 2
    if (!RADEONPreInitConfig(pScrn))
	goto fail;
d2293 2
d2296 3
a2298 5
    if (!RADEONGetBIOSParameters(pScrn, pInt10))
	goto fail;

    if (info->DisplayType == MT_DFP)
	RADEONGetTMDSInfo(pScrn);
d2300 1
a2300 1
    if (!RADEONGetPLLParameters(pScrn))          goto fail;
d2304 1
a2304 1
    if (!RADEONPreInitModes(pScrn, pInt10))      goto fail;
a2312 1

d2314 2
a2315 1
    if (info->VBIOS) {
a2323 3
    if(info->MMIO) RADEONUnmapMMIO(pScrn);
    info->MMIO = NULL;

d2325 2
a2326 2
	       "For information on using the multimedia capabilities\n of this"
	       " adapter, please see http://gatos.sf.net.\n");
d2332 1
a2332 4
    if (info->IsSecondary) {
        RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
	pRADEONEnt->HasSecondary = FALSE;
    }
d2334 2
a2335 1
    if (info->VBIOS) {
a2344 5

 fail2:
    if(info->MMIO) RADEONUnmapMMIO(pScrn);
    info->MMIO = NULL;
 fail1:
a2345 1

d2349 1
a2349 1
/* Load a palette */
d2353 1
a2353 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d2355 41
a2395 25
    int            i;
    int            idx, j;
    unsigned char  r, g, b;

#ifdef XF86DRI
    if (info->CPStarted) DRILock(pScrn->pScreen, 0);
#endif

    if (info->accelOn) info->accel->Sync(pScrn);

    if (info->FBDev) {
	fbdevHWLoadPalette(pScrn, numColors, indices, colors, pVisual);
    } else {
	/* If the second monitor is connected, we also need to deal with
	 * the secondary palette
	 */
	if (info->IsSecondary) j = 1;
	else j = 0;

	PAL_SELECT(j);

	if (info->CurrentLayout.depth == 15) {
	    /* 15bpp mode.  This sends 32 values. */
	    for (i = 0; i < numColors; i++) {
		idx = indices[i];
d2397 1
a2397 1
		g   = colors[idx].green;
d2399 1
a2401 37
	} else if (info->CurrentLayout.depth == 16) {
	    /* 16bpp mode.  This sends 64 values.
	     *
	     * There are twice as many green values as there are values
	     * for red and blue.  So, we take each red and blue pair,
	     * and combine it with each of the two green values.
	     */
	    for (i = 0; i < numColors; i++) {
		idx = indices[i];
		r   = colors[idx / 2].red;
		g   = colors[idx].green;
		b   = colors[idx / 2].blue;
		RADEONWaitForFifo(pScrn, 32); /* delay */
		OUTPAL(idx * 4, r, g, b);

		/* AH - Added to write extra green data - How come this isn't
		 * needed on R128?  We didn't load the extra green data in the
		 * other routine
		 */
		if (idx <= 31) {
		    r   = colors[idx].red;
		    g   = colors[(idx * 2) + 1].green;
		    b   = colors[idx].blue;
		    RADEONWaitForFifo(pScrn, 32); /* delay */
		    OUTPAL(idx * 8, r, g, b);
		}
	    }
	} else {
	    /* 8bpp mode.  This sends 256 values. */
	    for (i = 0; i < numColors; i++) {
		idx = indices[i];
		r   = colors[idx].red;
		b   = colors[idx].blue;
		g   = colors[idx].green;
		RADEONWaitForFifo(pScrn, 32); /* delay */
		OUTPAL(idx, r, g, b);
	    }
d2403 10
a2412 47

	if (info->Clone) {
	    PAL_SELECT(1);
	    if (info->CurrentLayout.depth == 15) {
		/* 15bpp mode.  This sends 32 values. */
		for (i = 0; i < numColors; i++) {
		    idx = indices[i];
		    r   = colors[idx].red;
		    g   = colors[idx].green;
		    b   = colors[idx].blue;
		    OUTPAL(idx * 8, r, g, b);
		}
	    } else if (info->CurrentLayout.depth == 16) {
		/* 16bpp mode.  This sends 64 values.
		 *
		 * There are twice as many green values as there are values
		 * for red and blue.  So, we take each red and blue pair,
		 * and combine it with each of the two green values.
		 */
		for (i = 0; i < numColors; i++) {
		    idx = indices[i];
		    r   = colors[idx / 2].red;
		    g   = colors[idx].green;
		    b   = colors[idx / 2].blue;
		    OUTPAL(idx * 4, r, g, b);

		    /* AH - Added to write extra green data - How come
		     * this isn't needed on R128?  We didn't load the
		     * extra green data in the other routine.
		     */
		    if (idx <= 31) {
			r   = colors[idx].red;
			g   = colors[(idx * 2) + 1].green;
			b   = colors[idx].blue;
			OUTPAL(idx * 8, r, g, b);
		    }
		}
	    } else {
		/* 8bpp mode.  This sends 256 values. */
		for (i = 0; i < numColors; i++) {
		    idx = indices[i];
		    r   = colors[idx].red;
		    b   = colors[idx].blue;
		    g   = colors[idx].green;
		    OUTPAL(idx, r, g, b);
		}
	    }
a2414 4

#ifdef XF86DRI
    if (info->CPStarted) DRIUnlock(pScrn->pScreen);
#endif
d2417 2
a2418 2
static void RADEONBlockHandler(int i, pointer blockData,
			       pointer pTimeout, pointer pReadmask)
d2420 3
a2422 3
    ScreenPtr      pScreen = screenInfo.screens[i];
    ScrnInfoPtr    pScrn   = xf86Screens[i];
    RADEONInfoPtr  info    = RADEONPTR(pScrn);
d2426 1
a2426 1
	FLUSH_RING();
d2433 3
a2435 2
    if (info->VideoTimerCallback)
	(*info->VideoTimerCallback)(pScrn, currentTime.milliseconds);
d2441 4
a2444 4
    ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
    RADEONInfoPtr  info  = RADEONPTR(pScrn);
    BoxRec         MemBox;
    int            y2;
a2451 2
    info->CPStarted    = FALSE;
    info->directRenderingEnabled = FALSE;
a2452 1
    info->accelOn      = FALSE;
d2454 1
a2454 1
    if (info->IsSecondary) pScrn->fbOffset = pScrn->videoRam * 1024;
d2458 2
a2459 2
    info->fbX = 0;
    info->fbY = 0;
d2463 1
a2467 1

a2476 9

    if (info->CurCloneMode) {
	info->CloneFrameX0 =
	    (pScrn->virtualX - info->CurCloneMode->HDisplay) / 2;
	info->CloneFrameY0 =
	    (pScrn->virtualY - info->CurCloneMode->VDisplay) / 2;
	RADEONDoAdjustFrame(pScrn, info->CloneFrameX0, info->CloneFrameY0, TRUE);
    }

d2487 2
a2488 2
				   established, but before fbScreenInit is
				   called.  fbScreenInit will eventually
d2493 5
a2497 6
	 * buffers, we will want to revisit the following check for 3
	 * times the virtual size of the screen below.
	 */
	int  width_bytes = (pScrn->displayWidth *
			    info->CurrentLayout.pixel_bytes);
	int  maxy        = info->FbMapSize / width_bytes;
d2510 1
a2510 3
	} else if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
		   (info->ChipFamily == CHIP_FAMILY_RS200) ||
		   (info->ChipFamily == CHIP_FAMILY_RS300)) {
d2513 1
a2513 9
		       "Direct rendering not yet supported on "
		       "IGP320/330/340/350, 7000, 9000 integrated chips\n");
	} else if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		   (info->ChipFamily == CHIP_FAMILY_R350) ||
		   (info->ChipFamily == CHIP_FAMILY_RV350)) {
	    info->directRenderingEnabled = FALSE;
	    xf86DrvMsg(scrnIndex, X_WARNING,
		       "Direct rendering not yet supported on "
		       "Radeon 9500/9700 and newer cards\n");
d2515 27
a2541 17
	    if (info->IsSecondary)
		info->directRenderingEnabled = FALSE;
	    else {
		/* Xinerama has sync problem with DRI, disable it for now */
		if (xf86IsEntityShared(info->pEnt->index)) {
		    info->directRenderingEnabled = FALSE;
		    xf86DrvMsg(scrnIndex, X_WARNING,
			       "Direct Rendering Disabled -- "
			       "Dual-head configuration is not working with "
			       "DRI at present.\n"
			       "Please use only one Device/Screen "
			       "section in your XFConfig file.\n");
		} else {
		    info->directRenderingEnabled =
			RADEONDRIScreenInit(pScreen);
		}
	    }
d2546 29
a2574 4
    if (!fbScreenInit(pScreen, info->FB,
		      pScrn->virtualX, pScrn->virtualY,
		      pScrn->xDpi, pScrn->yDpi, pScrn->displayWidth,
		      pScrn->bitsPerPixel))
d2576 2
a2577 1

d2581 1
a2581 1
	VisualPtr  visual;
d2595 2
a2596 2

    /* Must be after RGB order fixed */
d2598 1
a2599 14
#ifdef RENDER
    if (PictureGetSubpixelOrder (pScreen) == SubPixelUnknown)
    {
	int subPixelOrder;

	switch (info->DisplayType) {
	case MT_NONE:	subPixelOrder = SubPixelUnknown; break;
	case MT_LCD:	subPixelOrder = SubPixelHorizontalRGB; break;
	case MT_DFP:	subPixelOrder = SubPixelHorizontalRGB; break;
	default:	subPixelOrder = SubPixelNone; break;
	}
	PictureSetSubpixelOrder (pScreen, subPixelOrder);
    }
#endif
d2603 8
a2610 12
	FBAreaPtr  fbarea;
	int        width_bytes = (pScrn->displayWidth *
				  info->CurrentLayout.pixel_bytes);
	int        cpp         = info->CurrentLayout.pixel_bytes;
	int        bufferSize  = ((pScrn->virtualY * width_bytes
				   + RADEON_BUFFER_ALIGN)
				  & ~RADEON_BUFFER_ALIGN);
	int        depthSize   = ((((pScrn->virtualY+15) & ~15) * width_bytes
				   + RADEON_BUFFER_ALIGN)
				  & ~RADEON_BUFFER_ALIGN);
	int        l;
	int        scanlines;
d2628 1
a2628 1
		   "Using %d MB GART aperture\n", info->gartSize);
d2634 1
a2634 1
		   "Using %d MB for GART textures\n", info->gartTexSize);
d2640 1
a2640 1
	info->textureSize = info->FbMapSize - 5 * bufferSize - depthSize;
d2648 1
a2648 1
	    info->textureSize = info->FbMapSize - 4 * bufferSize - depthSize;
d2651 1
a2651 6
	    info->textureSize = info->FbMapSize - 3 * bufferSize - depthSize;
	}
	/* If there's still no space for textures, try without pixmap cache */
	if (info->textureSize < 0) {
	    info->textureSize = info->FbMapSize - 2 * bufferSize - depthSize
				- 64/4*64;
d2656 1
a2656 1
	if ((int)info->FbMapSize - 8192*width_bytes - bufferSize - depthSize
d2659 1
a2659 6
		info->FbMapSize - 8192*width_bytes - bufferSize - depthSize;
	}

	/* If backbuffer is disabled, don't allocate memory for it */
	if (info->noBackBuffer) {
	   info->textureSize += bufferSize;
d2685 8
a2692 10
	info->textureOffset = ((info->FbMapSize - info->textureSize +
				RADEON_BUFFER_ALIGN) &
			       ~(CARD32)RADEON_BUFFER_ALIGN);

				/* Reserve space for the shared depth
                                 * buffer.
				 */
	info->depthOffset = ((info->textureOffset - depthSize +
			      RADEON_BUFFER_ALIGN) &
			     ~(CARD32)RADEON_BUFFER_ALIGN);
d2696 4
a2699 12
	if (info->noBackBuffer) {
	   info->backOffset = info->depthOffset;
	   info->backPitch = pScrn->displayWidth;
	} else {
	   info->backOffset = ((info->depthOffset - bufferSize +
				RADEON_BUFFER_ALIGN) &
			       ~(CARD32)RADEON_BUFFER_ALIGN);
	   info->backPitch = pScrn->displayWidth;
	}

	info->backY = info->backOffset / width_bytes;
	info->backX = (info->backOffset - (info->backY * width_bytes)) / cpp;
d2701 1
a2701 1
	scanlines = info->FbMapSize / width_bytes;
d2711 1
a2711 2
		       "Memory manager initialization to "
		       "(%d,%d) (%d,%d) failed\n",
d2715 1
a2715 1
	    int  width, height;
d2722 1
a2722 2
						    2, 0, NULL, NULL,
						    NULL))) {
a2734 15

		/* Lines in offscreen area needed for depth buffer and
		 * textures
		 */
		info->depthTexLines = (scanlines
				       - info->depthOffset / width_bytes);
		info->backLines	    = (scanlines
				       - info->backOffset / width_bytes
				       - info->depthTexLines);
		info->backArea	    = NULL;
	    } else {
		xf86DrvMsg(scrnIndex, X_ERROR,
			   "Unable to determine largest offscreen area "
			   "available\n");
		return FALSE;
d2739 1
a2739 1
		   "Will use back buffer at offset 0x%x\n",
d2742 1
a2742 1
		   "Will use depth buffer at offset 0x%x\n",
d2745 1
a2745 1
		   "Will use %d kb for textures at offset 0x%x\n",
d2756 2
a2757 1
    } else
d2776 1
a2776 2
		       "Memory manager initialization to "
		       "(%d,%d) (%d,%d) failed\n",
d2786 2
a2787 4
	    if ((fbarea = xf86AllocateOffscreenArea(pScreen,
						    pScrn->displayWidth,
						    2, 0, NULL, NULL,
						    NULL))) {
d2803 6
a2814 4

	    /* FIXME: Figure out why this was added because it shouldn't be! */
	    /* This is needed by the DRI and XAA code for shared entities */
	    pScrn->pScreen = pScreen;
a2828 7
				/* Backing store setup */
    miInitializeBackingStore(pScreen);
    xf86SetBackingStore(pScreen);

				/* Set Silken Mouse */
    xf86SetSilkenMouse(pScreen);

d2835 1
a2835 1
	    int  width, height;
d2838 2
a2839 3
		       "Using hardware cursor (scanline %ld)\n",
		       info->cursor_start / pScrn->displayWidth
		       / info->CurrentLayout.pixel_bytes);
a2851 1
	info->cursor_start = 0;
d2858 2
a2859 1
			     RADEONLoadPalette, NULL,
d2861 1
d2865 1
a2865 1
			     | CMAP_RELOAD_ON_MODE_SWITCH)) return FALSE;
d2868 4
a2871 1
    xf86DPMSInit(pScreen, RADEONDisplayPowerManagementSet, 0);
a2873 1

d2888 1
a2888 1
				/* Now that mi, fb, drm and others have
a2893 4
	if ((info->DispPriority == 1) && (!info->IsPCI)) {
	    /* we need to re-calculate bandwidth because of AGPMode difference. */
	    RADEONInitDispBandwidth(pScrn);
	}
d2906 1
a2906 1
/* Write common registers (initialized to 0) */
d2910 1
a2910 45
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    OUTREG(RADEON_OVR_CLR,            restore->ovr_clr);
    OUTREG(RADEON_OVR_WID_LEFT_RIGHT, restore->ovr_wid_left_right);
    OUTREG(RADEON_OVR_WID_TOP_BOTTOM, restore->ovr_wid_top_bottom);
    OUTREG(RADEON_OV0_SCALE_CNTL,     restore->ov0_scale_cntl);
    OUTREG(RADEON_SUBPIC_CNTL,        restore->subpic_cntl);
    OUTREG(RADEON_VIPH_CONTROL,       restore->viph_control);
    OUTREG(RADEON_I2C_CNTL_1,         restore->i2c_cntl_1);
    OUTREG(RADEON_GEN_INT_CNTL,       restore->gen_int_cntl);
    OUTREG(RADEON_CAP0_TRIG_CNTL,     restore->cap0_trig_cntl);
    OUTREG(RADEON_CAP1_TRIG_CNTL,     restore->cap1_trig_cntl);
    OUTREG(RADEON_BUS_CNTL,           restore->bus_cntl);
    OUTREG(RADEON_SURFACE_CNTL,       restore->surface_cntl);

    /* Workaround for the VT switching problem in dual-head mode.  This
     * problem only occurs on RV style chips, typically when a FP and
     * CRT are connected.
     */
    if (info->HasCRTC2 &&
	!info->IsSwitching &&
	info->ChipFamily != CHIP_FAMILY_R200 &&
	info->ChipFamily != CHIP_FAMILY_R300 &&
	info->ChipFamily != CHIP_FAMILY_R350 &&
	info->ChipFamily != CHIP_FAMILY_RV350) {
	CARD32        tmp;
        RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);

	if (pRADEONEnt->HasSecondary || info->Clone) {
	    tmp = INREG(RADEON_DAC_CNTL2);
	    OUTREG(RADEON_DAC_CNTL2, tmp & ~RADEON_DAC2_DAC_CLK_SEL);
	    usleep(100000);
	}
    }
}

/* Write miscellaneous registers which might have been destroyed by an fbdevHW
 * call
 */
static void RADEONRestoreFBDevRegisters(ScrnInfoPtr pScrn,
					 RADEONSavePtr restore)
{
#ifdef XF86DRI
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d2913 14
a2926 13
    /* Restore register for vertical blank interrupts */
    if (info->irq) {
	OUTREG(RADEON_GEN_INT_CNTL, restore->gen_int_cntl);
    }

    /* Restore registers for page flipping */
    if (info->allowPageFlip) {
	OUTREG(RADEON_CRTC_OFFSET_CNTL, restore->crtc_offset_cntl);
	if (info->HasCRTC2) {
	    OUTREG(RADEON_CRTC2_OFFSET_CNTL, restore->crtc2_offset_cntl);
	}
    }
#endif
d2929 1
a2929 1
/* Write CRTC registers */
d2933 1
a2933 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d2936 1
a2936 1
    OUTREG(RADEON_CRTC_GEN_CNTL, restore->crtc_gen_cntl);
d2938 1
a2938 2
    OUTREGP(RADEON_CRTC_EXT_CNTL,
	    restore->crtc_ext_cntl,
d2943 1
a2943 2
    OUTREGP(RADEON_DAC_CNTL,
	    restore->dac_cntl,
a2953 2
    OUTREG(RADEON_DISP_MERGE_CNTL,      restore->disp_merge_cntl);
    OUTREG(RADEON_CRTC_MORE_CNTL,       restore->crtc_more_cntl);
d2956 1
a2956 1
/* Write CRTC2 registers */
d2958 1
a2958 1
					RADEONSavePtr restore)
d2960 1
a2960 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d2963 2
a2964 2
    OUTREGP(RADEON_CRTC2_GEN_CNTL,
	    restore->crtc2_gen_cntl,
d2970 1
a2970 10

    OUTREG(RADEON_TV_DAC_CNTL, 0x00280203);
    if ((info->ChipFamily == CHIP_FAMILY_R200) ||
	(info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {
	OUTREG(RADEON_DISP_OUTPUT_CNTL, restore->disp_output_cntl);
    } else {
	OUTREG(RADEON_DISP_HW_DEBUG, restore->disp_hw_debug);
    }
a2978 1
    OUTREG(RADEON_DISP2_MERGE_CNTL,      restore->disp2_merge_cntl);
a2979 10
    if ((info->DisplayType == MT_DFP && info->IsSecondary) ||
	info->CloneType == MT_DFP) {
	OUTREG(RADEON_FP_H2_SYNC_STRT_WID, restore->fp2_h_sync_strt_wid);
	OUTREG(RADEON_FP_V2_SYNC_STRT_WID, restore->fp2_v_sync_strt_wid);
	OUTREG(RADEON_FP2_GEN_CNTL,        restore->fp2_gen_cntl);
    }
#if 0
    /* Hack for restoring text mode -- fixed elsewhere */
    usleep(100000);
#endif
d2982 1
d2986 1
a2986 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d2988 1
a2988 1
    unsigned long  tmp;
d2994 1
a2994 2
    OUTREG(RADEON_TMDS_PLL_CNTL,        restore->tmds_pll_cntl);
    OUTREG(RADEON_TMDS_TRANSMITTER_CNTL,restore->tmds_transmitter_cntl);
d2999 21
a3019 23
    /* old AIW Radeon has some BIOS initialization problem
     * with display buffer underflow, only occurs to DFP
     */
    if (!info->HasCRTC2)
	OUTREG(RADEON_GRPH_BUFFER_CNTL,
	       INREG(RADEON_GRPH_BUFFER_CNTL) & ~0x7f0000);

    if (info->DisplayType != MT_DFP) {
	unsigned long tmpPixclksCntl = INPLL(pScrn, RADEON_PIXCLKS_CNTL);
        OUTREG(RADEON_BIOS_5_SCRATCH, restore->bios_5_scratch);

	if (info->IsMobility || info->IsIGP) {
	    /* Asic bug, when turning off LVDS_ON, we have to make sure
	       RADEON_PIXCLK_LVDS_ALWAYS_ON bit is off
	    */
	    if (!(restore->lvds_gen_cntl & RADEON_LVDS_ON)) {
		OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL, 0, ~RADEON_PIXCLK_LVDS_ALWAYS_ONb);
	    }
	}

	tmp = INREG(RADEON_LVDS_GEN_CNTL);
	if ((tmp & (RADEON_LVDS_ON | RADEON_LVDS_BLON)) ==
	    (restore->lvds_gen_cntl & (RADEON_LVDS_ON | RADEON_LVDS_BLON))) {
a3020 16
	} else {
	    if (restore->lvds_gen_cntl & (RADEON_LVDS_ON | RADEON_LVDS_BLON)) {
		usleep(RADEONPTR(pScrn)->PanelPwrDly * 1000);
		OUTREG(RADEON_LVDS_GEN_CNTL, restore->lvds_gen_cntl);
	    } else {
		OUTREG(RADEON_LVDS_GEN_CNTL,
		       restore->lvds_gen_cntl | RADEON_LVDS_BLON);
		usleep(RADEONPTR(pScrn)->PanelPwrDly * 1000);
		OUTREG(RADEON_LVDS_GEN_CNTL, restore->lvds_gen_cntl);
	    }
	}

	if (info->IsMobility || info->IsIGP) {
	    if (!(restore->lvds_gen_cntl & RADEON_LVDS_ON)) {
		OUTPLL(RADEON_PIXCLKS_CNTL, tmpPixclksCntl);
	    }
d3022 1
d3026 1
d3029 1
a3029 10
    int i = 0;

    /* FIXME: Certain revisions of R300 can't recover here.  Not sure of
       the cause yet, but this workaround will mask the problem for now.
       Other chips usually will pass at the very first test, so the
       workaround shouldn't have any effect on them. */
    for (i = 0;
	 (i < 10000 &&
	  INPLL(pScrn, RADEON_PPLL_REF_DIV) & RADEON_PPLL_ATOMIC_UPDATE_R);
	 i++);
d3034 1
a3034 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3037 1
a3037 5
    while (INPLL(pScrn, RADEON_PPLL_REF_DIV) & RADEON_PPLL_ATOMIC_UPDATE_R);

    OUTPLLP(pScrn, RADEON_PPLL_REF_DIV,
	    RADEON_PPLL_ATOMIC_UPDATE_W,
	    ~(RADEON_PPLL_ATOMIC_UPDATE_W));
d3039 1
d3041 2
a3042 1
static void RADEONPLL2WaitForReadUpdateComplete(ScrnInfoPtr pScrn)
d3044 2
a3045 1
    int i = 0;
d3047 1
a3047 9
    /* FIXME: Certain revisions of R300 can't recover here.  Not sure of
       the cause yet, but this workaround will mask the problem for now.
       Other chips usually will pass at the very first test, so the
       workaround shouldn't have any effect on them. */
    for (i = 0;
	 (i < 10000 &&
	  INPLL(pScrn, RADEON_P2PLL_REF_DIV) & RADEON_P2PLL_ATOMIC_UPDATE_R);
	 i++);
}
d3049 8
a3056 4
static void RADEONPLL2WriteUpdate(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
d3058 13
a3070 1
    while (INPLL(pScrn, RADEON_P2PLL_REF_DIV) & RADEON_P2PLL_ATOMIC_UPDATE_R);
d3072 11
a3082 11
    OUTPLLP(pScrn, RADEON_P2PLL_REF_DIV,
	    RADEON_P2PLL_ATOMIC_UPDATE_W,
	    ~(RADEON_P2PLL_ATOMIC_UPDATE_W));
}

/* Write PLL registers */
static void RADEONRestorePLLRegisters(ScrnInfoPtr pScrn,
				      RADEONSavePtr restore)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
d3084 7
a3090 10
    if (info->IsMobility) {
        /* A temporal workaround for the occational blanking on certain laptop panels.
           This appears to related to the PLL divider registers (fail to lock?).
	   It occurs even when all dividers are the same with their old settings.
           In this case we really don't need to fiddle with PLL registers.
           By doing this we can avoid the blanking problem with some panels.
        */
        if ((restore->ppll_ref_div == (INPLL(pScrn, RADEON_PPLL_REF_DIV) & RADEON_PPLL_REF_DIV_MASK)) &&
	    (restore->ppll_div_3 == (INPLL(pScrn, RADEON_PPLL_DIV_3) & (RADEON_PPLL_POST3_DIV_MASK | RADEON_PPLL_FB3_DIV_MASK))))
            return;
d3092 3
d3096 7
a3102 37
    OUTPLLP(pScrn, RADEON_VCLK_ECP_CNTL,
	    RADEON_VCLK_SRC_SEL_CPUCLK,
	    ~(RADEON_VCLK_SRC_SEL_MASK));

    OUTPLLP(pScrn,
	    RADEON_PPLL_CNTL,
	    RADEON_PPLL_RESET
	    | RADEON_PPLL_ATOMIC_UPDATE_EN
	    | RADEON_PPLL_VGA_ATOMIC_UPDATE_EN,
	    ~(RADEON_PPLL_RESET
	      | RADEON_PPLL_ATOMIC_UPDATE_EN
	      | RADEON_PPLL_VGA_ATOMIC_UPDATE_EN));

    OUTREGP(RADEON_CLOCK_CNTL_INDEX,
	    RADEON_PLL_DIV_SEL,
	    ~(RADEON_PLL_DIV_SEL));

    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {
	if (restore->ppll_ref_div & R300_PPLL_REF_DIV_ACC_MASK) {
	    /* When restoring console mode, use saved PPLL_REF_DIV
	     * setting.
	     */
	    OUTPLLP(pScrn, RADEON_PPLL_REF_DIV,
		    restore->ppll_ref_div,
		    0);
	} else {
	    /* R300 uses ref_div_acc field as real ref divider */
	    OUTPLLP(pScrn, RADEON_PPLL_REF_DIV,
		    (restore->ppll_ref_div << R300_PPLL_REF_DIV_ACC_SHIFT),
		    ~R300_PPLL_REF_DIV_ACC_MASK);
	}
    } else {
	OUTPLLP(pScrn, RADEON_PPLL_REF_DIV,
		restore->ppll_ref_div,
		~RADEON_PPLL_REF_DIV_MASK);
d3104 3
d3108 1
a3108 9
    OUTPLLP(pScrn, RADEON_PPLL_DIV_3,
	    restore->ppll_div_3,
	    ~RADEON_PPLL_FB3_DIV_MASK);

    OUTPLLP(pScrn, RADEON_PPLL_DIV_3,
	    restore->ppll_div_3,
	    ~RADEON_PPLL_POST3_DIV_MASK);

    RADEONPLLWriteUpdate(pScrn);
d3110 1
a3110 1

d3112 3
d3116 1
a3116 11
    OUTPLLP(pScrn, RADEON_PPLL_CNTL,
	    0,
	    ~(RADEON_PPLL_RESET
	      | RADEON_PPLL_SLEEP
	      | RADEON_PPLL_ATOMIC_UPDATE_EN
	      | RADEON_PPLL_VGA_ATOMIC_UPDATE_EN));

    xf86DrvMsg(0, X_INFO, "Wrote: rd=%d, fd=%d, pd=%d\n",
	       restore->ppll_ref_div & RADEON_PPLL_REF_DIV_MASK,
	       restore->ppll_div_3 & RADEON_PPLL_FB3_DIV_MASK,
	       (restore->ppll_div_3 & RADEON_PPLL_POST3_DIV_MASK) >> 16);
d3128 1
a3128 1
    usleep(5000); /* Let the clock to lock */
a3129 3
    OUTPLLP(pScrn, RADEON_VCLK_ECP_CNTL,
	    RADEON_VCLK_SRC_SEL_PPLLCLK,
	    ~(RADEON_VCLK_SRC_SEL_MASK));
d3133 2
a3134 3
/* Write PLL2 registers */
static void RADEONRestorePLL2Registers(ScrnInfoPtr pScrn,
				       RADEONSavePtr restore)
d3136 1
a3136 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3139 2
a3140 3
    OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL,
	    RADEON_PIX2CLK_SRC_SEL_CPUCLK,
	    ~(RADEON_PIX2CLK_SRC_SEL_MASK));
d3142 10
d3157 31
a3187 15
	    ~(RADEON_P2PLL_RESET
	      | RADEON_P2PLL_ATOMIC_UPDATE_EN
	      | RADEON_P2PLL_VGA_ATOMIC_UPDATE_EN));

    OUTPLLP(pScrn, RADEON_P2PLL_REF_DIV,
	    restore->p2pll_ref_div,
	    ~RADEON_P2PLL_REF_DIV_MASK);

    OUTPLLP(pScrn, RADEON_P2PLL_DIV_0,
	    restore->p2pll_div_0,
	    ~RADEON_P2PLL_FB0_DIV_MASK);

    OUTPLLP(pScrn, RADEON_P2PLL_DIV_0,
	    restore->p2pll_div_0,
	    ~RADEON_P2PLL_POST0_DIV_MASK);
d3189 11
a3199 2
    RADEONPLL2WriteUpdate(pScrn);
    RADEONPLL2WaitForReadUpdateComplete(pScrn);
d3201 3
d3205 3
d3209 2
a3210 6
    OUTPLLP(pScrn, RADEON_P2PLL_CNTL,
	    0,
	    ~(RADEON_P2PLL_RESET
	      | RADEON_P2PLL_SLEEP
	      | RADEON_P2PLL_ATOMIC_UPDATE_EN
	      | RADEON_P2PLL_VGA_ATOMIC_UPDATE_EN));
d3219 5
a3223 2
	       restore->p2pll_div_0 & RADEON_P2PLL_FB0_DIV_MASK,
	       (restore->p2pll_div_0 & RADEON_P2PLL_POST0_DIV_MASK) >>16));
d3225 7
a3231 1
    usleep(5000); /* Let the clock to lock */
d3233 2
a3234 3
    OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL,
	    RADEON_PIX2CLK_SRC_SEL_P2PLLCLK,
	    ~(RADEON_PIX2CLK_SRC_SEL_MASK));
d3238 1
a3238 1
/* Write palette data */
d3241 1
a3241 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3243 1
a3243 1
    int            i;
d3263 3
a3265 2
/* Write out state to define a new video mode */
static void RADEONRestoreMode(ScrnInfoPtr pScrn, RADEONSavePtr restore)
d3267 14
a3280 8
    RADEONInfoPtr      info = RADEONPTR(pScrn);
    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
    static RADEONSaveRec  restore0;

    /* For Non-dual head card, we don't have private field in the Entity */
    if (!info->HasCRTC2) {
	RADEONRestoreCommonRegisters(pScrn, restore);
	RADEONRestoreCrtcRegisters(pScrn, restore);
d3282 4
a3285 3
	RADEONRestorePLLRegisters(pScrn, restore);
	return;
    }
d3287 4
d3293 32
a3324 30
    /* When changing mode with Dual-head card, care must be taken for
     * the special order in setting registers. CRTC2 has to be set
     * before changing CRTC_EXT register.  In the dual-head setup, X
     * server calls this routine twice with primary and secondary pScrn
     * pointers respectively. The calls can come with different
     * order. Regardless the order of X server issuing the calls, we
     * have to ensure we set registers in the right order!!!  Otherwise
     * we may get a blank screen.
     */
    if (info->IsSecondary) {
	if (!pRADEONEnt->RestorePrimary  && !info->IsSwitching)
	    RADEONRestoreCommonRegisters(pScrn, restore);
	RADEONRestoreCrtc2Registers(pScrn, restore);
	RADEONRestorePLL2Registers(pScrn, restore);

	if(info->IsSwitching) return;

	pRADEONEnt->IsSecondaryRestored = TRUE;

	if (pRADEONEnt->RestorePrimary) {
	    pRADEONEnt->RestorePrimary = FALSE;

	    RADEONRestoreCrtcRegisters(pScrn, &restore0);
	    RADEONRestoreFPRegisters(pScrn, &restore0);
	    RADEONRestorePLLRegisters(pScrn, &restore0);
	    pRADEONEnt->IsSecondaryRestored = FALSE;
	}
    } else {
	if (!pRADEONEnt->IsSecondaryRestored)
	    RADEONRestoreCommonRegisters(pScrn, restore);
d3326 9
a3334 7
	if (info->Clone) {
	    RADEONRestoreCrtc2Registers(pScrn, restore);
	    RADEONRestorePLL2Registers(pScrn, restore);
	}

	if (!pRADEONEnt->HasSecondary || pRADEONEnt->IsSecondaryRestored ||
	    info->IsSwitching) {
d3336 14
d3351 6
a3356 7
	    RADEONRestoreCrtcRegisters(pScrn, restore);
	    RADEONRestoreFPRegisters(pScrn, restore);
	    RADEONRestorePLLRegisters(pScrn, restore);
	} else {
	    memcpy(&restore0, restore, sizeof(restore0));
	    pRADEONEnt->RestorePrimary = TRUE;
	}
d3358 1
d3365 1
a3365 1
/* Read common registers */
d3368 1
a3368 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3375 2
a3384 24
    save->grph_buffer_cntl   = INREG(RADEON_GRPH_BUFFER_CNTL);
    save->grph2_buffer_cntl  = INREG(RADEON_GRPH2_BUFFER_CNTL);
}

/* Read miscellaneous registers which might be destroyed by an fbdevHW call */
static void RADEONSaveFBDevRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save)
{
#ifdef XF86DRI
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    /* Save register for vertical blank interrupts */
    if (info->irq) {
	save->gen_int_cntl = INREG(RADEON_GEN_INT_CNTL);
    }

    /* Save registers for page flipping */
    if (info->allowPageFlip) {
	save->crtc_offset_cntl = INREG(RADEON_CRTC_OFFSET_CNTL);
	if (info->HasCRTC2) {
	    save->crtc2_offset_cntl = INREG(RADEON_CRTC2_OFFSET_CNTL);
	}
    }
#endif
d3387 1
a3387 1
/* Read CRTC registers */
d3390 1
a3390 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3403 1
a3403 2
    save->disp_merge_cntl      = INREG(RADEON_DISP_MERGE_CNTL);
    save->crtc_more_cntl       = INREG(RADEON_CRTC_MORE_CNTL);
d3406 1
d3410 1
a3410 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3422 1
a3422 8
    save->tmds_pll_cntl        = INREG(RADEON_TMDS_PLL_CNTL);
    save->tmds_transmitter_cntl= INREG(RADEON_TMDS_TRANSMITTER_CNTL);
    save->bios_5_scratch       = INREG(RADEON_BIOS_5_SCRATCH);

    if (info->ChipFamily == CHIP_FAMILY_RV280) {
	/* bit 22 of TMDS_PLL_CNTL is read-back inverted */
	save->tmds_pll_cntl ^= (1 << 22);
    }
d3425 3
a3427 2
/* Read CRTC2 registers */
static void RADEONSaveCrtc2Registers(ScrnInfoPtr pScrn, RADEONSavePtr save)
d3429 1
a3429 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
a3433 1
    save->disp_hw_debug         = INREG (RADEON_DISP_HW_DEBUG);
a3442 5

    save->fp2_h_sync_strt_wid   = INREG (RADEON_FP_H2_SYNC_STRT_WID);
    save->fp2_v_sync_strt_wid   = INREG (RADEON_FP_V2_SYNC_STRT_WID);
    save->fp2_gen_cntl          = INREG (RADEON_FP2_GEN_CNTL);
    save->disp2_merge_cntl      = INREG(RADEON_DISP2_MERGE_CNTL);
d3445 1
a3445 1
/* Read PLL registers */
d3448 3
a3450 3
    save->ppll_ref_div = INPLL(pScrn, RADEON_PPLL_REF_DIV);
    save->ppll_div_3   = INPLL(pScrn, RADEON_PPLL_DIV_3);
    save->htotal_cntl  = INPLL(pScrn, RADEON_HTOTAL_CNTL);
d3453 3
a3455 3
		 save->ppll_ref_div,
		 save->ppll_div_3,
		 save->htotal_cntl));
d3457 3
a3459 3
		 save->ppll_ref_div & RADEON_PPLL_REF_DIV_MASK,
		 save->ppll_div_3 & RADEON_PPLL_FB3_DIV_MASK,
		 (save->ppll_div_3 & RADEON_PPLL_POST3_DIV_MASK) >> 16));
d3462 1
a3462 1
/* Read PLL registers */
d3465 3
a3467 3
    save->p2pll_ref_div = INPLL(pScrn, RADEON_P2PLL_REF_DIV);
    save->p2pll_div_0   = INPLL(pScrn, RADEON_P2PLL_DIV_0);
    save->htotal_cntl2  = INPLL(pScrn, RADEON_HTOTAL2_CNTL);
d3470 3
a3472 3
		 save->p2pll_ref_div,
		 save->p2pll_div_0,
		 save->htotal_cntl2));
d3474 3
a3476 3
		 save->p2pll_ref_div & RADEON_P2PLL_REF_DIV_MASK,
		 save->p2pll_div_0 & RADEON_P2PLL_FB0_DIV_MASK,
		 (save->p2pll_div_0 & RADEON_P2PLL_POST0_DIV_MASK) >> 16));
d3479 11
a3489 1
/* Read palette data */
d3492 1
a3492 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3494 1
a3494 1
    int            i;
d3498 1
a3498 1
 /* if (info->Port1 == MT_DFP) PAL_SELECT(1); */
d3509 1
a3509 1
/* Save state that defines current video mode */
d3512 1
a3512 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d3515 12
a3526 7
    if (info->IsSecondary) {
	RADEONSaveCrtc2Registers(pScrn, save);
	RADEONSavePLL2Registers(pScrn, save);
    } else {
	RADEONSavePLLRegisters(pScrn, save);
	RADEONSaveCommonRegisters(pScrn, save);
	RADEONSaveCrtcRegisters(pScrn, save);
d3528 4
a3531 6

	if (info->Clone) {
	    RADEONSaveCrtc2Registers(pScrn, save);
	    RADEONSavePLL2Registers(pScrn, save);
	}
     /* RADEONSavePalette(pScrn, save); */
a3532 1

d3536 1
a3536 1
/* Save everything needed to restore the original VC state */
d3539 1
a3539 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3541 2
a3542 2
    RADEONSavePtr  save       = &info->SavedReg;
    vgaHWPtr       hwp        = VGAHWPTR(pScrn);
d3550 3
a3552 2
    if (!info->IsSecondary) {
	vgaHWUnlock(hwp);
d3554 5
a3558 5
	/* temporary hack to prevent crashing on PowerMacs when trying to
	 * read VGA fonts and colormap, will find a better solution
	 * in the future
	 */
	vgaHWSave(pScrn, &hwp->SavedReg, VGA_SR_MODE); /* Save mode only */
d3560 8
a3567 9
	vgaHWSave(pScrn, &hwp->SavedReg, VGA_SR_MODE | VGA_SR_FONTS); /* Save mode
						       * & fonts & cmap
						       */
#endif
	vgaHWLock(hwp);
	save->dp_datatype      = INREG(RADEON_DP_DATATYPE);
	save->rbbm_soft_reset  = INREG(RADEON_RBBM_SOFT_RESET);
	save->clock_cntl_index = INREG(RADEON_CLOCK_CNTL_INDEX);
	if (info->R300CGWorkaround) R300CGWorkaround(pScrn);
d3569 1
a3569 1

d3573 1
a3573 1
/* Restore the original (text) mode */
d3576 1
a3576 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3578 2
a3579 2
    RADEONSavePtr  restore    = &info->SavedReg;
    vgaHWPtr       hwp        = VGAHWPTR(pScrn);
a3581 6

#if X_BYTE_ORDER == X_BIG_ENDIAN
    RADEONWaitForFifo(pScrn, 1);
    OUTREG(RADEON_RBBM_GUICNTL, RADEON_HOST_DATA_SWAP_NONE);
#endif

d3588 2
a3590 1
    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);
a3592 2
    OUTREG(RADEON_GRPH_BUFFER_CNTL, restore->grph_buffer_cntl);
    OUTREG(RADEON_GRPH2_BUFFER_CNTL, restore->grph2_buffer_cntl);
a3593 1
#if 0
d3595 3
a3597 6
     * This is fixed elsewhere and will be removed in the future.
     */
    if ((xf86IsEntityShared(info->pEnt->index) || info->Clone)
	&& info->IsM6)
	OUTREG(RADEON_DAC_CNTL2, restore->dac2_cntl);
#endif
a3600 1
#if 0
d3602 3
a3604 4
     * some systems, the console can either hang or the fonts can be
     * corrupted.  This hack solves the problem 99% of the time.  A
     * correct fix is being worked on.
     */
a3605 1
#endif
d3607 3
a3609 2
    if (!info->IsSecondary) {
	vgaHWUnlock(hwp);
d3611 4
a3614 4
	/* Temporary hack to prevent crashing on PowerMacs when trying to
	 * write VGA fonts, will find a better solution in the future
	 */
	vgaHWRestore(pScrn, &hwp->SavedReg, VGA_SR_MODE );
d3616 1
a3616 1
	vgaHWRestore(pScrn, &hwp->SavedReg, VGA_SR_MODE | VGA_SR_FONTS );
d3618 18
a3635 11
	vgaHWLock(hwp);
    } else {
        RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
	ScrnInfoPtr   pScrn0;
	vgaHWPtr      hwp0;

	pScrn0 = pRADEONEnt->pPrimaryScrn;
	hwp0   = VGAHWPTR(pScrn0);
	vgaHWUnlock(hwp0);
	vgaHWRestore(pScrn0, &hwp0->SavedReg, VGA_SR_MODE | VGA_SR_FONTS );
	vgaHWLock(hwp0);
d3644 2
a3645 1
/* Define common registers for requested video mode */
d3652 2
d3669 1
a3669 317
/* Calculate display buffer watermark to prevent buffer underflow */
static void RADEONInitDispBandwidth(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    RADEONInfoPtr  info2 = NULL;

    DisplayModePtr mode1, mode2;

    CARD32 temp, data, mem_trcd, mem_trp, mem_tras, mem_trbs=0;
    float mem_tcas;
    int k1, c;
    CARD32 MemTrcdExtMemCntl[4]     = {1, 2, 3, 4};
    CARD32 MemTrpExtMemCntl[4]      = {1, 2, 3, 4};
    CARD32 MemTrasExtMemCntl[8]     = {1, 2, 3, 4, 5, 6, 7, 8};

    CARD32 MemTrcdMemTimingCntl[8]     = {1, 2, 3, 4, 5, 6, 7, 8};
    CARD32 MemTrpMemTimingCntl[8]      = {1, 2, 3, 4, 5, 6, 7, 8};
    CARD32 MemTrasMemTimingCntl[16]    = {4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19};

    float MemTcas[8]  = {0, 1, 2, 3, 0, 1.5, 2.5, 0};
    float MemTcas2[8] = {0, 1, 2, 3, 4, 5, 6, 7};
    float MemTrbs[8]  = {1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5};

    float mem_bw, peak_disp_bw;
    float min_mem_eff = 0.8;
    float sclk_eff, sclk_delay;
    float mc_latency_mclk, mc_latency_sclk, cur_latency_mclk, cur_latency_sclk;
    float disp_latency, disp_latency_overhead, disp_drain_rate, disp_drain_rate2;
    float pix_clk, pix_clk2; /* in MHz */
    int cur_size = 16;       /* in octawords */
    int critical_point, critical_point2;
    int stop_req, max_stop_req;
    float read_return_rate, time_disp1_drop_priority;

    if (pRADEONEnt->pSecondaryScrn) {
	if (info->IsSecondary) return;
	info2 = RADEONPTR(pRADEONEnt->pSecondaryScrn);
    }  else if (info->Clone) info2 = info;

    /*
     * Determine if there is enough bandwidth for current display mode
     */
    mem_bw = info->mclk * (info->RamWidth / 8) * (info->IsDDR ? 2 : 1);

    mode1 = info->CurrentLayout.mode;
    if (info->Clone)
	mode2 = info->CurCloneMode;
    else if ((pRADEONEnt->HasSecondary) && info2)
	mode2 = info2->CurrentLayout.mode;
    else
	mode2 = NULL;

    pix_clk = mode1->Clock/1000.0;
    if (mode2)
	pix_clk2 = mode2->Clock/1000.0;
    else
	pix_clk2 = 0;

    peak_disp_bw = (pix_clk * info->CurrentLayout.pixel_bytes);
    if (info2)
	peak_disp_bw +=	(pix_clk2 * info2->CurrentLayout.pixel_bytes);

    if (peak_disp_bw >= mem_bw * min_mem_eff) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "You may not have enough display bandwidth for current mode\n"
		   "If you have flickering problem, try to lower resolution, refresh rate, or color depth\n");
    }

    /*  CRTC1
        Set GRPH_BUFFER_CNTL register using h/w defined optimal values.
	GRPH_STOP_REQ <= MIN[ 0x7C, (CRTC_H_DISP + 1) * (bit depth) / 0x10 ]
    */
    stop_req = mode1->HDisplay * info->CurrentLayout.pixel_bytes / 16;

    /* setup Max GRPH_STOP_REQ default value */
    if ((info->ChipFamily == CHIP_FAMILY_RV100) ||
	(info->ChipFamily == CHIP_FAMILY_RV200) ||
	(info->ChipFamily == CHIP_FAMILY_RV250) ||
	(info->ChipFamily == CHIP_FAMILY_RV280) ||
	(info->ChipFamily == CHIP_FAMILY_RS100) ||
	(info->ChipFamily == CHIP_FAMILY_RS200) ||
	(info->ChipFamily == CHIP_FAMILY_RS300))
	max_stop_req = 0x5c;
    else
	max_stop_req  = 0x7c;
    if (stop_req > max_stop_req)
	stop_req = max_stop_req;

    /*  Get values from the EXT_MEM_CNTL register...converting its contents. */
    temp = INREG(RADEON_MEM_TIMING_CNTL);
    if ((info->ChipFamily == CHIP_FAMILY_RV100) || info->IsIGP) { /* RV100, M6, IGPs */
	mem_trcd      = MemTrcdExtMemCntl[(temp & 0x0c) >> 2];
	mem_trp       = MemTrpExtMemCntl[ (temp & 0x03) >> 0];
	mem_tras      = MemTrasExtMemCntl[(temp & 0x70) >> 4];
    } else { /* RV200 and later */
	mem_trcd      = MemTrcdMemTimingCntl[(temp & 0x07) >> 0];
	mem_trp       = MemTrpMemTimingCntl[ (temp & 0x700) >> 8];
	mem_tras      = MemTrasMemTimingCntl[(temp & 0xf000) >> 12];
    }

    /* Get values from the MEM_SDRAM_MODE_REG register...converting its */
    temp = INREG(RADEON_MEM_SDRAM_MODE_REG);
    data = (temp & (7<<20)) >> 20;
    if ((info->ChipFamily == CHIP_FAMILY_RV100) || info->IsIGP) { /* RV100, M6, IGPs */
	mem_tcas = MemTcas [data];
    } else {
	mem_tcas = MemTcas2 [data];
    }

    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {

	/* on the R300, Tcas is included in Trbs.
	*/
	temp = INREG(RADEON_MEM_CNTL);
	data = (R300_MEM_NUM_CHANNELS_MASK & temp);
	if (data == 2) {
	    if (R300_MEM_USE_CD_CH_ONLY & temp) {
		temp  = INREG(R300_MC_IND_INDEX);
		temp &= ~R300_MC_IND_ADDR_MASK;
		temp |= R300_MC_READ_CNTL_CD_mcind;
		OUTREG(R300_MC_IND_INDEX, temp);
		temp  = INREG(R300_MC_IND_DATA);
		data = (R300_MEM_RBS_POSITION_C_MASK & temp);
	    } else {
		temp = INREG(R300_MC_READ_CNTL_AB);
		data = (R300_MEM_RBS_POSITION_A_MASK & temp);
	    }
	} else {
	    temp = INREG(R300_MC_READ_CNTL_AB);
	    data = (R300_MEM_RBS_POSITION_A_MASK & temp);
	}

	mem_trbs = MemTrbs[data];
	mem_tcas += mem_trbs;
    }

    if ((info->ChipFamily == CHIP_FAMILY_RV100) || info->IsIGP) { /* RV100, M6, IGPs */
	/* DDR64 SCLK_EFF = SCLK for analysis */
	sclk_eff = info->sclk;
    } else {
#ifdef XF86DRI
	if (info->directRenderingEnabled)
	    sclk_eff = info->sclk - (info->agpMode * 50.0 / 3.0);
	else
#endif
	    sclk_eff = info->sclk;
    }

    /* Find the memory controller latency for the display client.
    */
    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {
	/*not enough for R350 ???*/
	/*
	if (!mode2) sclk_delay = 150;
	else {
	    if (info->RamWidth == 256) sclk_delay = 87;
	    else sclk_delay = 97;
	}
	*/
	sclk_delay = 250;
    } else {
	if ((info->ChipFamily == CHIP_FAMILY_RV100) ||
	    info->IsIGP) {
	    if (info->IsDDR) sclk_delay = 41;
	    else sclk_delay = 33;
	} else {
	    if (info->RamWidth == 128) sclk_delay = 57;
	    else sclk_delay = 41;
	}
    }

    mc_latency_sclk = sclk_delay / sclk_eff;

    if (info->IsDDR) {
	if (info->RamWidth == 32) {
	    k1 = 40;
	    c  = 3;
	} else {
	    k1 = 20;
	    c  = 1;
	}
    } else {
	k1 = 40;
	c  = 3;
    }
    mc_latency_mclk = ((2.0*mem_trcd + mem_tcas*c + 4.0*mem_tras + 4.0*mem_trp + k1) /
		       info->mclk) + (4.0 / sclk_eff);

    /*
      HW cursor time assuming worst case of full size colour cursor.
    */
    cur_latency_mclk = (mem_trp + MAX(mem_tras, (mem_trcd + 2*(cur_size - (info->IsDDR+1))))) / info->mclk;
    cur_latency_sclk = cur_size / sclk_eff;

    /*
      Find the total latency for the display data.
    */
    disp_latency_overhead = 8.0 / info->sclk;
    mc_latency_mclk = mc_latency_mclk + disp_latency_overhead + cur_latency_mclk;
    mc_latency_sclk = mc_latency_sclk + disp_latency_overhead + cur_latency_sclk;
    disp_latency = MAX(mc_latency_mclk, mc_latency_sclk);

    /*
      Find the drain rate of the display buffer.
    */
    disp_drain_rate = pix_clk / (16.0/info->CurrentLayout.pixel_bytes);
    if (info2)
	disp_drain_rate2 = pix_clk2 / (16.0/info2->CurrentLayout.pixel_bytes);
    else
	disp_drain_rate2 = 0;

    /*
      Find the critical point of the display buffer.
    */
    critical_point= (CARD32)(disp_drain_rate * disp_latency + 0.5);

    /* ???? */
    /*
    temp = (info->SavedReg.grph_buffer_cntl & RADEON_GRPH_CRITICAL_POINT_MASK) >> RADEON_GRPH_CRITICAL_POINT_SHIFT;
    if (critical_point < temp) critical_point = temp;
    */
    if (info->DispPriority == 2) {
	if (mode2) {
	    /*??some R300 cards have problem with this set to 0, when CRTC2 is enabled.*/
	    if (info->ChipFamily == CHIP_FAMILY_R300)
		critical_point += 0x10;
	    else
		critical_point = 0;
	}
	else
	    critical_point = 0;
    }

    /*
      The critical point should never be above max_stop_req-4.  Setting
      GRPH_CRITICAL_CNTL = 0 will thus force high priority all the time.
    */
    if (max_stop_req - critical_point < 4) critical_point = 0;

    temp = info->SavedReg.grph_buffer_cntl;
    temp &= ~(RADEON_GRPH_STOP_REQ_MASK);
    temp |= (stop_req << RADEON_GRPH_STOP_REQ_SHIFT);
    temp &= ~(RADEON_GRPH_START_REQ_MASK);
    if ((info->ChipFamily == CHIP_FAMILY_R350) &&
	(stop_req > 0x15)) {
	stop_req -= 0x10;
    }
    temp |= (stop_req << RADEON_GRPH_START_REQ_SHIFT);

    temp |= RADEON_GRPH_BUFFER_SIZE;
    temp &= ~(RADEON_GRPH_CRITICAL_CNTL   |
	      RADEON_GRPH_CRITICAL_AT_SOF |
	      RADEON_GRPH_STOP_CNTL);
    /*
      Write the result into the register.
    */
    OUTREG(RADEON_GRPH_BUFFER_CNTL, ((temp & ~RADEON_GRPH_CRITICAL_POINT_MASK) |
				     (critical_point << RADEON_GRPH_CRITICAL_POINT_SHIFT)));

    RADEONTRACE(("GRPH_BUFFER_CNTL from %x to %x\n",
	       info->SavedReg.grph_buffer_cntl, INREG(RADEON_GRPH_BUFFER_CNTL)));

    if (mode2) {
	stop_req = mode2->HDisplay * info2->CurrentLayout.pixel_bytes / 16;

	if (stop_req > max_stop_req) stop_req = max_stop_req;

	temp = info->SavedReg.grph2_buffer_cntl;
	temp &= ~(RADEON_GRPH_STOP_REQ_MASK);
	temp |= (stop_req << RADEON_GRPH_STOP_REQ_SHIFT);
	temp &= ~(RADEON_GRPH_START_REQ_MASK);
	if ((info->ChipFamily == CHIP_FAMILY_R350) &&
	    (stop_req > 0x15)) {
	    stop_req -= 0x10;
	}
	temp |= (stop_req << RADEON_GRPH_START_REQ_SHIFT);
	temp |= RADEON_GRPH_BUFFER_SIZE;
	temp &= ~(RADEON_GRPH_CRITICAL_CNTL   |
		  RADEON_GRPH_CRITICAL_AT_SOF |
		  RADEON_GRPH_STOP_CNTL);

	if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
	    (info->ChipFamily == CHIP_FAMILY_RS200))
	    critical_point2 = 0;
	else {
	    read_return_rate = MIN(info->sclk, info->mclk*(info->RamWidth*(info->IsDDR+1)/128));
	    time_disp1_drop_priority = critical_point / (read_return_rate - disp_drain_rate);

	    critical_point2 = (CARD32)((disp_latency + time_disp1_drop_priority +
					disp_latency) * disp_drain_rate2 + 0.5);

	    if (info->DispPriority == 2) {
		if (info->ChipFamily == CHIP_FAMILY_R300)
		    critical_point2 += 0x10;
		else
		    critical_point2 = 0;
	    }

	    if (max_stop_req - critical_point2 < 4) critical_point2 = 0;

	}

	OUTREG(RADEON_GRPH2_BUFFER_CNTL, ((temp & ~RADEON_GRPH_CRITICAL_POINT_MASK) |
					  (critical_point2 << RADEON_GRPH_CRITICAL_POINT_SHIFT)));

	RADEONTRACE(("GRPH2_BUFFER_CNTL from %x to %x\n",
		     info->SavedReg.grph2_buffer_cntl, INREG(RADEON_GRPH2_BUFFER_CNTL)));
    }
}

/* Define CRTC registers for requested video mode */
d3673 8
a3680 9
    unsigned char *RADEONMMIO = info->MMIO;

    int  format;
    int  hsync_start;
    int  hsync_wid;
    int  hsync_fudge;
    int  vsync_wid;
    int  hsync_fudge_default[] = { 0x00, 0x12, 0x09, 0x09, 0x06, 0x05 };
    int  hsync_fudge_fp[]      = { 0x02, 0x02, 0x00, 0x00, 0x05, 0x05 };
d3683 6
a3688 6
    case 4:  format = 1; break;
    case 8:  format = 2; break;
    case 15: format = 3; break;      /*  555 */
    case 16: format = 4; break;      /*  565 */
    case 24: format = 5; break;      /*  RGB */
    case 32: format = 6; break;      /* xRGB */
d3691 1
a3691 2
		   "Unsupported pixel depth (%d)\n",
		   info->CurrentLayout.bitsPerPixel);
d3694 1
d3696 2
a3697 2
    if ((info->DisplayType == MT_DFP) ||
	(info->DisplayType == MT_LCD)) {
d3699 2
a3700 17
	if (mode->Flags & RADEON_USE_RMX) {
#if 0
	    mode->CrtcHDisplay   = info->PanelXRes;
	    mode->CrtcVDisplay   = info->PanelYRes;
#endif
	    mode->CrtcHTotal     = mode->CrtcHDisplay + info->HBlank;
	    mode->CrtcHSyncStart = mode->CrtcHDisplay + info->HOverPlus;
	    mode->CrtcHSyncEnd   = mode->CrtcHSyncStart + info->HSyncWidth;
	    mode->CrtcVTotal     = mode->CrtcVDisplay + info->VBlank;
	    mode->CrtcVSyncStart = mode->CrtcVDisplay + info->VOverPlus;
	    mode->CrtcVSyncEnd   = mode->CrtcVSyncStart + info->VSyncWidth;
	    mode->Clock          = info->DotClock;
	    mode->Flags          = info->Flags | RADEON_USE_RMX;
	}
    } else {
	hsync_fudge = hsync_fudge_default[format-1];
    }
d3703 39
a3741 22
			   | RADEON_CRTC_EN
			   | (format << 8)
			   | ((mode->Flags & V_DBLSCAN)
			      ? RADEON_CRTC_DBL_SCAN_EN
			      : 0)
			   | ((mode->Flags & V_CSYNC)
			      ? RADEON_CRTC_CSYNC_EN
			      : 0)
			   | ((mode->Flags & V_INTERLACE)
			      ? RADEON_CRTC_INTERLACE_EN
			      : 0));

    if ((info->DisplayType == MT_DFP) ||
	(info->DisplayType == MT_LCD)) {
	save->crtc_ext_cntl = RADEON_VGA_ATI_LINEAR | RADEON_XCRT_CNT_EN;
	save->crtc_gen_cntl &= ~(RADEON_CRTC_DBL_SCAN_EN |
				 RADEON_CRTC_CSYNC_EN |
				 RADEON_CRTC_INTERLACE_EN);
    } else {
	save->crtc_ext_cntl = (RADEON_VGA_ATI_LINEAR |
			       RADEON_XCRT_CNT_EN |
			       RADEON_CRTC_CRT_ON);
a3742 5

    save->dac_cntl = (RADEON_DAC_MASK_ALL
		      | RADEON_DAC_VGA_ADR_EN
		      | (info->dac6bits ? 0 : RADEON_DAC_8BIT_EN));

d3744 1
a3744 2
			       | ((((mode->CrtcHDisplay / 8) - 1) & 0x1ff)
				  << 16));
d3747 2
a3748 1
    if (!hsync_wid) hsync_wid = 1;
d3752 5
a3756 5
				  | ((hsync_wid & 0x3f) << 16)
				  | ((mode->Flags & V_NHSYNC)
				     ? RADEON_CRTC_H_SYNC_POL
				     : 0));

d3760 1
a3760 1
			       | ((mode->CrtcVDisplay - 1) << 16));
d3763 1
a3763 2
				 * does -- is this correct?
				 */
d3765 3
a3767 3
			       | ((mode->CrtcVDisplay
				   * ((mode->Flags & V_DBLSCAN) ? 2 : 1) - 1)
				  << 16));
d3771 2
a3772 1
    if (!vsync_wid) vsync_wid = 1;
d3775 4
a3778 4
				  | ((vsync_wid & 0x1f) << 16)
				  | ((mode->Flags & V_NVSYNC)
				     ? RADEON_CRTC_V_SYNC_POL
				     : 0));
d3781 1
a3781 1
    save->crtc_offset_cntl = INREG(RADEON_CRTC_OFFSET_CNTL);
d3783 3
a3785 3
    save->crtc_pitch  = (((pScrn->displayWidth * pScrn->bitsPerPixel) +
			  ((pScrn->bitsPerPixel * 8) -1)) /
			 (pScrn->bitsPerPixel * 8));
d3788 1
a3788 14
    /* Some versions of BIOS setup CRTC_MORE_CNTL for a DFP, if we
       have a CRT here, it should be cleared to avoild a blank screen.
    */
    if (info->DisplayType == MT_CRT)
	save->crtc_more_cntl = (info->SavedReg.crtc_more_cntl &
				~(RADEON_CRTC_H_CUTOFF_ACTIVE_EN |
				  RADEON_CRTC_V_CUTOFF_ACTIVE_EN));
    else
	save->crtc_more_cntl = info->SavedReg.crtc_more_cntl;

    save->surface_cntl = 0;
    save->disp_merge_cntl = info->SavedReg.disp_merge_cntl;
    save->disp_merge_cntl &= ~RADEON_DISP_RGB_OFFSET_EN;

d3791 6
a3796 7
    case 16:
	save->surface_cntl |= RADEON_NONSURF_AP0_SWP_16BPP;
	break;

    case 32:
	save->surface_cntl |= RADEON_NONSURF_AP0_SWP_32BPP;
	break;
d3806 1
a3806 1
/* Define CRTC2 registers for requested video mode */
d3808 1
a3808 1
				     DisplayModePtr mode, RADEONInfoPtr info)
d3810 7
a3816 9
    unsigned char *RADEONMMIO = info->MMIO;
    RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);

    int  format;
    int  hsync_start;
    int  hsync_wid;
    int  hsync_fudge;
    int  vsync_wid;
    int  hsync_fudge_default[] = { 0x00, 0x12, 0x09, 0x09, 0x06, 0x05 };
d3819 6
a3824 6
    case 4:  format = 1; break;
    case 8:  format = 2; break;
    case 15: format = 3; break;      /*  555 */
    case 16: format = 4; break;      /*  565 */
    case 24: format = 5; break;      /*  RGB */
    case 32: format = 6; break;      /* xRGB */
d3827 1
a3827 2
		   "Unsupported pixel depth (%d)\n",
		   info->CurrentLayout.bitsPerPixel);
d3830 1
d3835 17
a3851 55
			    | RADEON_CRTC2_CRT2_ON
			    | (format << 8)
			    | ((mode->Flags & V_DBLSCAN)
			       ? RADEON_CRTC2_DBL_SCAN_EN
			       : 0)
			    | ((mode->Flags & V_CSYNC)
			       ? RADEON_CRTC2_CSYNC_EN
			       : 0)
			    | ((mode->Flags & V_INTERLACE)
			       ? RADEON_CRTC2_INTERLACE_EN
			       : 0));

    /* Turn CRT on in case the first head is a DFP */
    save->crtc_ext_cntl |= RADEON_CRTC_CRT_ON;
    save->dac2_cntl = info->SavedReg.dac2_cntl;
    /* always let TVDAC drive CRT2, we don't support tvout yet */
    save->dac2_cntl |= RADEON_DAC2_DAC2_CLK_SEL;
    save->disp_output_cntl = info->SavedReg.disp_output_cntl;
    if (info->ChipFamily == CHIP_FAMILY_R200 ||
	info->ChipFamily == CHIP_FAMILY_R300 ||
	info->ChipFamily == CHIP_FAMILY_R350 ||
	info->ChipFamily == CHIP_FAMILY_RV350) {
	save->disp_output_cntl &= ~(RADEON_DISP_DAC_SOURCE_MASK |
				    RADEON_DISP_DAC2_SOURCE_MASK);
	if (pRADEONEnt->MonType1 != MT_CRT) {
	    save->disp_output_cntl |= (RADEON_DISP_DAC_SOURCE_CRTC2 |
				       RADEON_DISP_DAC2_SOURCE_CRTC2);
	} else {
	    if (pRADEONEnt->ReversedDAC) {
		save->disp_output_cntl |= RADEON_DISP_DAC2_SOURCE_CRTC2;
	    } else {
		save->disp_output_cntl |= RADEON_DISP_DAC_SOURCE_CRTC2;
	    }
	}
    } else {
	save->disp_hw_debug = info->SavedReg.disp_hw_debug;
	/* Turn on 2nd CRT */
	if (pRADEONEnt->MonType1 != MT_CRT) {
	    /* This is for some sample boards with the VGA port
	       connected to the TVDAC, but BIOS doesn't reflect this.
	       Here we configure both DACs to use CRTC2.
	       Not sure if this happens in any retail board.
	    */
	    save->disp_hw_debug &= ~RADEON_CRT2_DISP1_SEL;
	    save->dac2_cntl |= RADEON_DAC2_DAC_CLK_SEL;
	} else {
	    if (pRADEONEnt->ReversedDAC) {
		save->disp_hw_debug &= ~RADEON_CRT2_DISP1_SEL;
		save->dac2_cntl &= ~RADEON_DAC2_DAC_CLK_SEL;
	    } else {
		save->disp_hw_debug |= RADEON_CRT2_DISP1_SEL;
		save->dac2_cntl |= RADEON_DAC2_DAC_CLK_SEL;
	    }
	}
    }
d3853 2
a3854 3
    save->crtc2_h_total_disp =
	((((mode->CrtcHTotal / 8) - 1) & 0x3ff)
	 | ((((mode->CrtcHDisplay / 8) - 1) & 0x1ff) << 16));
d3857 2
a3858 1
    if (!hsync_wid) hsync_wid = 1;
d3862 4
a3865 4
				   | ((hsync_wid & 0x3f) << 16)
				   | ((mode->Flags & V_NHSYNC)
				      ? RADEON_CRTC_H_SYNC_POL
				      : 0));
d3870 1
a3870 1
				| ((mode->CrtcVDisplay - 1) << 16));
d3873 1
a3873 2
				 * does -- is this correct?
				 */
d3875 3
a3877 3
				| ((mode->CrtcVDisplay
				    * ((mode->Flags & V_DBLSCAN) ? 2 : 1) - 1)
				   << 16));
d3881 2
a3882 1
    if (!vsync_wid) vsync_wid = 1;
d3885 4
a3888 4
				   | ((vsync_wid & 0x1f) << 16)
				   | ((mode->Flags & V_NVSYNC)
				      ? RADEON_CRTC2_V_SYNC_POL
				      : 0));
d3891 1
a3891 1
    save->crtc2_offset_cntl = INREG(RADEON_CRTC2_OFFSET_CNTL);
d3893 3
a3895 3
    save->crtc2_pitch  = (((pScrn->displayWidth * pScrn->bitsPerPixel) +
			   ((pScrn->bitsPerPixel * 8) -1)) /
			  (pScrn->bitsPerPixel * 8));
d3897 1
a3897 42
    save->disp2_merge_cntl = info->SavedReg.disp2_merge_cntl;
    save->disp2_merge_cntl &= ~(RADEON_DISP2_RGB_OFFSET_EN);

    if ((info->DisplayType == MT_DFP && info->IsSecondary) ||
	info->CloneType == MT_DFP) {
	save->crtc2_gen_cntl      = (RADEON_CRTC2_EN | (format << 8));
	save->fp2_h_sync_strt_wid = save->crtc2_h_sync_strt_wid;
	save->fp2_v_sync_strt_wid = save->crtc2_v_sync_strt_wid;
	save->fp2_gen_cntl        = (RADEON_FP2_PANEL_FORMAT |
				     RADEON_FP2_ON);
	if (info->ChipFamily >= CHIP_FAMILY_R200) {
	    save->fp2_gen_cntl |= RADEON_FP2_DV0_EN;
	}

	if (info->ChipFamily == CHIP_FAMILY_R200 ||
	    info->ChipFamily == CHIP_FAMILY_R300 ||
	    info->ChipFamily == CHIP_FAMILY_R350 ||
	    info->ChipFamily == CHIP_FAMILY_RV350) {
	    save->fp2_gen_cntl &= ~RADEON_FP2_SOURCE_SEL_MASK;
	    save->fp2_gen_cntl |= RADEON_FP2_SOURCE_SEL_CRTC2;
	} else {
	    save->fp2_gen_cntl &= ~RADEON_FP2_SRC_SEL_MASK;
	    save->fp2_gen_cntl |= RADEON_FP2_SRC_SEL_CRTC2;
	}

	if (pScrn->rgbBits == 8)
	    save->fp2_gen_cntl |= RADEON_FP2_PANEL_FORMAT; /* 24 bit format */
	else
	    save->fp2_gen_cntl &= ~RADEON_FP2_PANEL_FORMAT;/* 18 bit format */

	/* FIXME: When there are two DFPs, the 2nd DFP is driven by the
	 *        external TMDS transmitter.  It may have a problem at
	 *        high dot clock for certain panels.
	 */

	/* If BIOS has not turned it on, we'll keep it on so that we'll
	 * have a valid VGA screen even after X quits or VT is switched
	 * to the console mode.
	 */
	info->SavedReg.fp2_gen_cntl = RADEON_FP2_ON;
    }

a3900 1

d3904 2
a3905 1
/* Define CRTC registers for requested video mode */
d3910 3
a3912 8
    int    xres = mode->HDisplay;
    int    yres = mode->VDisplay;
    float  Hratio, Vratio;

    /* If the FP registers have been initialized before for a panel,
     * but the primary port is a CRT, we need to reinitialize
     * FP registers in order for CRT to work properly
     */
d3914 9
a3922 16
    if ((info->DisplayType != MT_DFP) && (info->DisplayType != MT_LCD)) {
        save->fp_crtc_h_total_disp = orig->fp_crtc_h_total_disp;
        save->fp_crtc_v_total_disp = orig->fp_crtc_v_total_disp;
        save->fp_gen_cntl          = 0;
        save->fp_h_sync_strt_wid   = orig->fp_h_sync_strt_wid;
        save->fp_horz_stretch      = 0;
        save->fp_v_sync_strt_wid   = orig->fp_v_sync_strt_wid;
        save->fp_vert_stretch      = 0;
        save->lvds_gen_cntl        = orig->lvds_gen_cntl;
        save->lvds_pll_cntl        = orig->lvds_pll_cntl;
        save->tmds_pll_cntl        = orig->tmds_pll_cntl;
        save->tmds_transmitter_cntl= orig->tmds_transmitter_cntl;

        save->lvds_gen_cntl |= ( RADEON_LVDS_DISPLAY_DIS | (1 << 23));
        save->lvds_gen_cntl &= ~(RADEON_LVDS_BLON | RADEON_LVDS_ON);
        save->fp_gen_cntl &= ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN);
d3924 2
a3925 1
        return;
d3928 5
a3932 9
    if (info->PanelXRes == 0 || info->PanelYRes == 0) {
	Hratio = 1.0;
	Vratio = 1.0;
    } else {
	if (xres > info->PanelXRes) xres = info->PanelXRes;
	if (yres > info->PanelYRes) yres = info->PanelYRes;

	Hratio = (float)xres/(float)info->PanelXRes;
	Vratio = (float)yres/(float)info->PanelYRes;
d3934 10
a3943 23

    if (Hratio == 1.0 || !(mode->Flags & RADEON_USE_RMX)) {
	save->fp_horz_stretch = orig->fp_horz_stretch;
	save->fp_horz_stretch &= ~(RADEON_HORZ_STRETCH_BLEND |
				   RADEON_HORZ_STRETCH_ENABLE);
	save->fp_horz_stretch &= ~(RADEON_HORZ_AUTO_RATIO |
				   RADEON_HORZ_PANEL_SIZE);
	save->fp_horz_stretch |= ((xres/8-1)<<16);

    } else {
	save->fp_horz_stretch =
	    ((((unsigned long)(Hratio * RADEON_HORZ_STRETCH_RATIO_MAX +
			       0.5)) & RADEON_HORZ_STRETCH_RATIO_MASK)) |
	    (orig->fp_horz_stretch & (RADEON_HORZ_PANEL_SIZE |
				      RADEON_HORZ_FP_LOOP_STRETCH |
				      RADEON_HORZ_AUTO_RATIO_INC));
	save->fp_horz_stretch |= (RADEON_HORZ_STRETCH_BLEND |
				  RADEON_HORZ_STRETCH_ENABLE);

	save->fp_horz_stretch &= ~(RADEON_HORZ_AUTO_RATIO |
				   RADEON_HORZ_PANEL_SIZE);
	save->fp_horz_stretch |= ((info->PanelXRes / 8 - 1) << 16);

d3945 1
d3947 9
a3955 9
    if (Vratio == 1.0 || !(mode->Flags & RADEON_USE_RMX)) {
	save->fp_vert_stretch = orig->fp_vert_stretch;
	save->fp_vert_stretch &= ~(RADEON_VERT_STRETCH_ENABLE|
				   RADEON_VERT_STRETCH_BLEND);
	save->fp_vert_stretch &= ~(RADEON_VERT_AUTO_RATIO_EN |
				   RADEON_VERT_PANEL_SIZE);
	save->fp_vert_stretch |= ((yres-1) << 12);
    } else {
	save->fp_vert_stretch =
d3957 5
a3961 10
				0.5)) & RADEON_VERT_STRETCH_RATIO_MASK)) |
	     (orig->fp_vert_stretch & (RADEON_VERT_PANEL_SIZE |
				       RADEON_VERT_STRETCH_RESERVED)));
	save->fp_vert_stretch |= (RADEON_VERT_STRETCH_ENABLE |
				  RADEON_VERT_STRETCH_BLEND);

	save->fp_vert_stretch &= ~(RADEON_VERT_AUTO_RATIO_EN |
				   RADEON_VERT_PANEL_SIZE);
	save->fp_vert_stretch |= ((info->PanelYRes-1) << 12);

d3963 1
d3966 14
a3979 10
			 ~(RADEON_FP_SEL_CRTC2 |
			   RADEON_FP_RMX_HVSYNC_CONTROL_EN |
			   RADEON_FP_DFP_SYNC_SEL |
			   RADEON_FP_CRT_SYNC_SEL |
			   RADEON_FP_CRTC_LOCK_8DOT |
			   RADEON_FP_USE_SHADOW_EN |
			   RADEON_FP_CRTC_USE_SHADOW_VEND |
			   RADEON_FP_CRT_SYNC_ALT));
    save->fp_gen_cntl |= (RADEON_FP_CRTC_DONT_SHADOW_VPAR |
			  RADEON_FP_CRTC_DONT_SHADOW_HEND );
d3981 2
a3982 4
    if (pScrn->rgbBits == 8)
        save->fp_gen_cntl |= RADEON_FP_PANEL_FORMAT;  /* 24 bit format */
    else
        save->fp_gen_cntl &= ~RADEON_FP_PANEL_FORMAT;/* 18 bit format */
d3984 4
a3987 9
    save->lvds_gen_cntl = orig->lvds_gen_cntl;
    save->lvds_pll_cntl = orig->lvds_pll_cntl;

    info->PanelOff = FALSE;
    /* This option is used to force the ONLY DEVICE in XFConfig to use
     * CRT port, instead of default DVI port.
     */
    if (xf86ReturnOptValBool(info->Options, OPTION_PANEL_OFF, FALSE)) {
	info->PanelOff = TRUE;
d3989 2
d3992 4
a3995 64
    save->tmds_pll_cntl = orig->tmds_pll_cntl;
    save->tmds_transmitter_cntl= orig->tmds_transmitter_cntl;
    if (info->PanelOff && info->Clone) {
	info->OverlayOnCRTC2 = TRUE;
	if (info->DisplayType == MT_LCD) {
	    /* Turning off LVDS_ON seems to make panel white blooming.
	     * For now we just turn off display data ???
	     */
	    save->lvds_gen_cntl |= (RADEON_LVDS_DISPLAY_DIS);
	    save->lvds_gen_cntl &= ~(RADEON_LVDS_BLON | RADEON_LVDS_ON);

	} else if (info->DisplayType == MT_DFP)
	    save->fp_gen_cntl &= ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN);
    } else {
	if (info->DisplayType == MT_LCD) {
	    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);

	    /* BIOS will use this setting to reset displays upon lid close/open.
	     * Here we let BIOS controls LCD, but the driver will control the external CRT.
	     */
	    if (info->Clone || pRADEONEnt->HasSecondary)
		save->bios_5_scratch = 0x01020201;
	    else
		save->bios_5_scratch = orig->bios_5_scratch;

	    save->lvds_gen_cntl |= (RADEON_LVDS_ON | RADEON_LVDS_BLON);
	    save->fp_gen_cntl   &= ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN);

	} else if (info->DisplayType == MT_DFP) {
	    int i;
	    CARD32 tmp = orig->tmds_pll_cntl & 0xfffff;
	    for (i=0; i<4; i++) {
		if (info->tmds_pll[i].freq == 0) break;
		if (save->dot_clock_freq < info->tmds_pll[i].freq) {
		    tmp = info->tmds_pll[i].value ;
		    break;
		}
	    }
	    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		(info->ChipFamily == CHIP_FAMILY_R350) ||
		(info->ChipFamily == CHIP_FAMILY_RV350) ||
		(info->ChipFamily == CHIP_FAMILY_RV280)) {
		if (tmp & 0xfff00000)
		    save->tmds_pll_cntl = tmp;
		else
		    save->tmds_pll_cntl = (orig->tmds_pll_cntl & 0xfff00000) | tmp;
	    } else save->tmds_pll_cntl = tmp;

	    RADEONTRACE(("TMDS_PLL from %x to %x\n",
			 orig->tmds_pll_cntl,
			 save->tmds_pll_cntl));

            save->tmds_transmitter_cntl &= ~(RADEON_TMDS_TRANSMITTER_PLLRST);
            if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		(info->ChipFamily == CHIP_FAMILY_R350) ||
		(info->ChipFamily == CHIP_FAMILY_RV350) ||
		(info->ChipFamily == CHIP_FAMILY_R200) || !info->HasCRTC2)
		save->tmds_transmitter_cntl &= ~(RADEON_TMDS_TRANSMITTER_PLLEN);
            else /* weird, RV chips got this bit reversed? */
                save->tmds_transmitter_cntl |= (RADEON_TMDS_TRANSMITTER_PLLEN);

	    save->fp_gen_cntl   |= (RADEON_FP_FPON | RADEON_FP_TMDS_EN);
        }
    }
a3996 4
    save->fp_crtc_h_total_disp = save->crtc_h_total_disp;
    save->fp_crtc_v_total_disp = save->crtc_v_total_disp;
    save->fp_h_sync_strt_wid   = save->crtc_h_sync_strt_wid;
    save->fp_v_sync_strt_wid   = save->crtc_v_sync_strt_wid;
d3999 1
a3999 1
/* Define PLL registers for requested video mode */
d4003 1
a4003 2
    unsigned long  freq = dot_clock * 100;

d4007 2
a4008 1
    } *post_div, post_divs[]   = {
d4010 3
a4012 4
				 * Reference Manual (Technical Reference
				 * Manual P/N RRG-G04100-C Rev. 0.04), page
				 * 3-17 (PLL_DIV_[3:0]).
				 */
a4028 1

a4032 5
    if (!post_div->divider) {
	save->pll_output_freq = freq;
	post_div = &post_divs[0];
    }

d4050 1
a4050 1
/* Define PLL2 registers for requested video mode */
d4052 1
a4052 1
				    double dot_clock)
d4054 1
a4054 2
    unsigned long  freq = dot_clock * 100;

d4058 2
a4059 1
    } *post_div, post_divs[]   = {
d4061 3
a4063 4
				 * Reference Manual (Technical Reference
				 * Manual P/N RRG-G04100-C Rev. 0.04), page
				 * 3-17 (PLL_DIV_[3:0]).
				 */
d4069 1
a4083 5
    if (!post_div->divider) {
	save->pll_output_freq_2 = freq;
	post_div = &post_divs[0];
    }

d4086 2
a4087 2
				       * save->pll_output_freq_2,
				       pll->reference_freq);
d4096 68
a4163 4
    save->p2pll_ref_div    = pll->reference_div;
    save->p2pll_div_0      = (save->feedback_div_2 |
			      (post_div->bitvalue << 16));
    save->htotal_cntl2     = 0;
d4166 1
a4166 1
#if 0
d4168 2
a4169 2
 * anything for XFree86 4.0.
 */
d4174 1
a4174 1
#endif
d4176 1
a4176 1
/* Define registers for a requested video mode */
d4180 2
a4181 2
    RADEONInfoPtr  info      = RADEONPTR(pScrn);
    double         dot_clock = mode->Clock/1000.0;
a4199 1
    if (mode->Flags & V_CSYNC)     ErrorF(" C");
a4221 1
    if (mode->Flags & V_CSYNC)     ErrorF(" C");
d4232 25
a4256 22
    if (info->IsSecondary) {
	if (!RADEONInitCrtc2Registers(pScrn, save, mode, info))
	    return FALSE;
	RADEONInitPLL2Registers(save, &info->pll, dot_clock);
    } else {
	RADEONInitCommonRegisters(save, info);
	if (!RADEONInitCrtcRegisters(pScrn, save, mode, info))
	    return FALSE;
	dot_clock = mode->Clock/1000.0;
	if (dot_clock) {
            if (info->UseBiosDividers) {
                save->ppll_ref_div = info->RefDivider;
                save->ppll_div_3   = info->FeedbackDivider | (info->PostDivider << 16);
                save->htotal_cntl  = 0;
            }
            else
		RADEONInitPLLRegisters(save, &info->pll, dot_clock);
	} else {
	    save->ppll_ref_div = info->SavedReg.ppll_ref_div;
	    save->ppll_div_3   = info->SavedReg.ppll_div_3;
	    save->htotal_cntl  = info->SavedReg.htotal_cntl;
	}
d4258 3
a4260 7
	if (info->Clone && info->CurCloneMode) {
	    RADEONInitCrtc2Registers(pScrn, save, info->CurCloneMode, info);
	    dot_clock = info->CurCloneMode->Clock / 1000.0;
	    RADEONInitPLL2Registers(save, &info->pll, dot_clock);
	}
	/* Not used for now: */
     /* if (!info->PaletteSavedOnVT) RADEONInitPalette(save); */
d4263 6
a4268 1
    RADEONInitFPRegisters(pScrn, &info->SavedReg, save, mode, info);
d4274 1
a4274 1
/* Initialize a new mode */
d4277 1
a4277 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d4280 1
a4287 4

    if (info->DispPriority)
	RADEONInitDispBandwidth(pScrn);

d4293 2
a4294 2
    ScrnInfoPtr  pScrn = xf86Screens[pScreen->myNum];
    Bool         unblank;
d4297 2
a4298 1
    if (unblank) SetTimeSinceLastInputEvent();
d4301 4
a4304 2
	if (unblank)  RADEONUnblank(pScrn);
	else          RADEONBlank(pScrn);
d4311 2
a4312 5
    ScrnInfoPtr    pScrn       = xf86Screens[scrnIndex];
    RADEONInfoPtr  info        = RADEONPTR(pScrn);
    Bool           ret;
#ifdef XF86DRI
    Bool           CPStarted   = info->CPStarted;
d4314 26
a4339 5
    if (CPStarted) {
	DRILock(pScrn->pScreen, 0);
	RADEONCP_STOP(pScrn, info);
    }
#endif
d4341 25
a4365 37
    if (info->accelOn) info->accel->Sync(pScrn);

    if (info->FBDev) {
	RADEONSaveFBDevRegisters(pScrn, &info->ModeReg);

	ret = fbdevHWSwitchMode(scrnIndex, mode, flags);

	RADEONRestoreFBDevRegisters(pScrn, &info->ModeReg);
    } else {
	info->IsSwitching = TRUE;
	if (info->Clone && info->CloneModes) {
	    DisplayModePtr  clone_mode = info->CloneModes;

	    /* Try to match a mode on primary head
	     * FIXME: This may not be good if both heads don't have
	     *        exactly the same list of mode.
	     */
	    while (1) {
		if ((clone_mode->HDisplay == mode->HDisplay) &&
		    (clone_mode->VDisplay == mode->VDisplay) &&
		    (!info->PanelOff)) {
		    info->CloneFrameX0 = (info->CurCloneMode->HDisplay +
					  info->CloneFrameX0 -
					  clone_mode->HDisplay - 1) / 2;
		    info->CloneFrameY0 =
			(info->CurCloneMode->VDisplay + info->CloneFrameY0 -
			 clone_mode->VDisplay - 1) / 2;
		    info->CurCloneMode = clone_mode;
		    break;
		}

		if (!clone_mode->next) {
		    info->CurCloneMode = info->CloneModes;
		    break;
		}

		clone_mode = clone_mode->next;
d4368 2
a4369 49
	ret = RADEONModeInit(xf86Screens[scrnIndex], mode);

	if (info->CurCloneMode) {
	    if (info->CloneFrameX0 + info->CurCloneMode->HDisplay >=
		pScrn->virtualX)
		info->CloneFrameX0 =
		    pScrn->virtualX - info->CurCloneMode->HDisplay;
	    else if (info->CloneFrameX0 < 0)
		info->CloneFrameX0 = 0;

	    if (info->CloneFrameY0 + info->CurCloneMode->VDisplay >=
		pScrn->virtualY)
		info->CloneFrameY0 =
		    pScrn->virtualY - info->CurCloneMode->VDisplay;
	    else if (info->CloneFrameY0 < 0)
		info->CloneFrameY0 = 0;

	    RADEONDoAdjustFrame(pScrn, info->CloneFrameX0, info->CloneFrameY0,
				TRUE);
	}

	info->IsSwitching = FALSE;
    }

    if (info->accelOn) {
	info->accel->Sync(pScrn);
	RADEONEngineRestore(pScrn);
    }

#ifdef XF86DRI
    if (CPStarted) {
	RADEONCP_START(pScrn, info);
	DRIUnlock(pScrn->pScreen);
    }
#endif

    return ret;
}

#ifdef X_XF86MiscPassMessage
Bool RADEONHandleMessage(int scrnIndex, const char* msgtype,
			 const char* msgval, char** retmsg)
{
    ErrorF("RADEONHandleMessage(%d, \"%s\", \"%s\", retmsg)\n", scrnIndex,
		    msgtype, msgval);
    *retmsg = "";
    return 0;
}
#endif
a4370 12
/* Used to disallow modes that are not supported by the hardware */
ModeStatus RADEONValidMode(int scrnIndex, DisplayModePtr mode,
			   Bool verbose, int flag)
{
    /* There are problems with double scan mode at high clocks
     * They're likely related PLL and display buffer settings.
     * Disable these modes for now.
     */
    if (mode->Flags & V_DBLSCAN) {
	if ((mode->CrtcHDisplay >= 1024) || (mode->CrtcVDisplay >= 768))
	    return MODE_CLOCK_RANGE;
    }
d4374 3
a4376 4
/* Adjust viewport into virtual desktop such that (0,0) in viewport
 * space is (x,y) in virtual space.
 */
void RADEONDoAdjustFrame(ScrnInfoPtr pScrn, int x, int y, int clone)
d4378 2
a4379 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d4381 3
a4383 4
    int            reg, Base = y * info->CurrentLayout.displayWidth + x;
#ifdef XF86DRI
    RADEONSAREAPrivPtr pSAREAPriv;
#endif
d4394 4
a4397 5
    if (clone || info->IsSecondary) {
	Base += pScrn->fbOffset;
	reg = RADEON_CRTC2_OFFSET;
    } else {
	reg = RADEON_CRTC_OFFSET;
d4399 3
a4401 39

#ifdef XF86DRI
    if (info->directRenderingEnabled) {

	pSAREAPriv = DRIGetSAREAPrivate(pScrn->pScreen);

	if (clone || info->IsSecondary) {
	    pSAREAPriv->crtc2_base = Base;
	}

	if (pSAREAPriv->pfCurrentPage == 1) {
	    Base += info->backOffset;
	}
    }
#endif

    OUTREG(reg, Base);
}

void RADEONAdjustFrame(int scrnIndex, int x, int y, int flags)
{
    ScrnInfoPtr    pScrn      = xf86Screens[scrnIndex];
    RADEONInfoPtr  info       = RADEONPTR(pScrn);

#ifdef XF86DRI
    if (info->CPStarted) DRILock(pScrn->pScreen, 0);
#endif

    if (info->accelOn) info->accel->Sync(pScrn);

    if (info->FBDev) {
	fbdevHWAdjustFrame(scrnIndex, x, y, flags);
    } else {
	RADEONDoAdjustFrame(pScrn, x, y, FALSE);
    }

#ifdef XF86DRI
	if (info->CPStarted) DRIUnlock(pScrn->pScreen);
#endif
d4404 2
a4405 3
/* Called when VT switching back to the X server.  Reinitialize the
 * video mode.
 */
d4408 2
a4409 2
    ScrnInfoPtr    pScrn = xf86Screens[scrnIndex];
    RADEONInfoPtr  info  = RADEONPTR(pScrn);
d4415 3
a4417 5
	if (!fbdevHWEnterVT(scrnIndex,flags)) return FALSE;
	info->PaletteSavedOnVT = FALSE;
	info->ModeReg.surface_cntl = INREG(RADEON_SURFACE_CNTL);

	RADEONRestoreFBDevRegisters(pScrn, &info->ModeReg);
d4419 1
a4419 12
	if (!RADEONModeInit(pScrn, pScrn->currentMode)) return FALSE;

#ifdef XF86DRI
    if (info->directRenderingEnabled) {
	/* get the Radeon back into shape after resume */
	RADEONDRIResume(pScrn->pScreen);
    }
#endif
    /* this will get XVideo going again, but only if XVideo was initialised
       during server startup (hence the info->adaptor if). */
    if (info->adaptor)
	RADEONResetVideo(pScrn);
d4425 1
a4425 1
    if (info->directRenderingEnabled) {
d4431 1
a4431 5
    pScrn->AdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
    if (info->CurCloneMode) {
	RADEONDoAdjustFrame(pScrn, info->CloneFrameX0, info->CloneFrameY0, TRUE);
    }

d4435 2
a4436 3
/* Called when VT switching away from the X server.  Restore the
 * original text mode.
 */
d4439 3
a4441 3
    ScrnInfoPtr    pScrn = xf86Screens[scrnIndex];
    RADEONInfoPtr  info  = RADEONPTR(pScrn);
    RADEONSavePtr  save  = &info->ModeReg;
d4452 5
a4456 9
	RADEONSavePalette(pScrn, save);
	info->PaletteSavedOnVT = TRUE;

	RADEONSaveFBDevRegisters(pScrn, &info->ModeReg);

	fbdevHWLeaveVT(scrnIndex,flags);
    }

    RADEONRestore(pScrn);
d4459 3
a4461 4
/* Called at the end of each server generation.  Restore the original
 * text mode, unmap video memory, and unwrap and call the saved
 * CloseScreen function.
 */
d4464 2
a4465 2
    ScrnInfoPtr    pScrn = xf86Screens[scrnIndex];
    RADEONInfoPtr  info  = RADEONPTR(pScrn);
d4477 2
a4478 1
    if (pScrn->vtSema) {
d4480 1
a4481 1
    RADEONUnmapMem(pScrn);
d4483 2
a4484 2
    if (info->accel) XAADestroyInfoRec(info->accel);
    info->accel = NULL;
d4486 2
a4487 2
    if (info->scratch_save) xfree(info->scratch_save);
    info->scratch_save = NULL;
d4489 2
a4490 2
    if (info->cursor) xf86DestroyCursorInfoRec(info->cursor);
    info->cursor = NULL;
d4492 2
a4493 2
    if (info->DGAModes) xfree(info->DGAModes);
    info->DGAModes = NULL;
d4497 1
a4497 1
    xf86ClearPrimInitDone(info->pEnt->index);
d4506 1
a4506 1
    ScrnInfoPtr  pScrn = xf86Screens[scrnIndex];
d4515 1
a4515 1
/* Sets VESA Display Power Management Signaling (DPMS) Mode */
d4517 1
a4517 2
					    int PowerManagementMode,
					    int flags)
d4519 1
a4519 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d4521 23
a4543 144

#ifdef XF86DRI
    if (info->CPStarted) DRILock(pScrn->pScreen, 0);
#endif

    if (info->accelOn) info->accel->Sync(pScrn);

    if (info->FBDev) {
	fbdevHWDPMSSet(pScrn, PowerManagementMode, flags);
    } else {
	int             mask1     = (RADEON_CRTC_DISPLAY_DIS |
				     RADEON_CRTC_HSYNC_DIS |
				     RADEON_CRTC_VSYNC_DIS);
	int             mask2     = (RADEON_CRTC2_DISP_DIS |
				     RADEON_CRTC2_VSYNC_DIS |
				     RADEON_CRTC2_HSYNC_DIS);

	/* TODO: additional handling for LCD ? */

	switch (PowerManagementMode) {
	case DPMSModeOn:
	    /* Screen: On; HSync: On, VSync: On */
	    if (info->IsSecondary)
		OUTREGP(RADEON_CRTC2_GEN_CNTL, 0, ~mask2);
	    else {
		if (info->Clone)
		    OUTREGP(RADEON_CRTC2_GEN_CNTL, 0, ~mask2);
		OUTREGP(RADEON_CRTC_EXT_CNTL, 0, ~mask1);
	    }
	    break;

	case DPMSModeStandby:
	    /* Screen: Off; HSync: Off, VSync: On */
	    if (info->IsSecondary)
		OUTREGP(RADEON_CRTC2_GEN_CNTL,
			RADEON_CRTC2_DISP_DIS | RADEON_CRTC2_HSYNC_DIS,
			~mask2);
	    else {
		if (info->Clone)
		    OUTREGP(RADEON_CRTC2_GEN_CNTL,
			    RADEON_CRTC2_DISP_DIS | RADEON_CRTC2_HSYNC_DIS,
			    ~mask2);
		OUTREGP(RADEON_CRTC_EXT_CNTL,
			RADEON_CRTC_DISPLAY_DIS | RADEON_CRTC_HSYNC_DIS,
			~mask1);
	    }
	    break;

	case DPMSModeSuspend:
	    /* Screen: Off; HSync: On, VSync: Off */
	    if (info->IsSecondary)
		OUTREGP(RADEON_CRTC2_GEN_CNTL,
			RADEON_CRTC2_DISP_DIS | RADEON_CRTC2_VSYNC_DIS,
			~mask2);
	    else {
		if (info->Clone)
		    OUTREGP(RADEON_CRTC2_GEN_CNTL,
			    RADEON_CRTC2_DISP_DIS | RADEON_CRTC2_VSYNC_DIS,
			    ~mask2);
		OUTREGP(RADEON_CRTC_EXT_CNTL,
			RADEON_CRTC_DISPLAY_DIS | RADEON_CRTC_VSYNC_DIS,
			~mask1);
	    }
	    break;

	case DPMSModeOff:
	    /* Screen: Off; HSync: Off, VSync: Off */
	    if (info->IsSecondary)
		OUTREGP(RADEON_CRTC2_GEN_CNTL, mask2, ~mask2);
	    else {
		if (info->Clone)
		    OUTREGP(RADEON_CRTC2_GEN_CNTL, mask2, ~mask2);
		OUTREGP(RADEON_CRTC_EXT_CNTL, mask1, ~mask1);
	    }
	    break;
	}

	if (PowerManagementMode == DPMSModeOn) {
	    if (info->IsSecondary) {
		if (info->DisplayType == MT_DFP) {
		    OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_BLANK_EN);
		    OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_ON, ~RADEON_FP2_ON);
		    if (info->ChipFamily >= CHIP_FAMILY_R200) {
			OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_DV0_EN, ~RADEON_FP2_DV0_EN);
		    }
		}
	    } else {
		if ((info->Clone) && (info->CloneType == MT_DFP)) {
		    OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_BLANK_EN);
		    OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_ON, ~RADEON_FP2_ON);
		    if (info->ChipFamily >= CHIP_FAMILY_R200) {
			OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_DV0_EN, ~RADEON_FP2_DV0_EN);
		    }
		}
		if (info->DisplayType == MT_DFP) {
		    OUTREGP (RADEON_FP_GEN_CNTL, (RADEON_FP_FPON | RADEON_FP_TMDS_EN),
			     ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN));
		} else if (info->DisplayType == MT_LCD) {

		    OUTREGP (RADEON_LVDS_GEN_CNTL, RADEON_LVDS_BLON, ~RADEON_LVDS_BLON);
		    usleep (info->PanelPwrDly * 1000);
		    OUTREGP (RADEON_LVDS_GEN_CNTL, RADEON_LVDS_ON, ~RADEON_LVDS_ON);
		}
	    }
	} else if ((PowerManagementMode == DPMSModeOff) ||
		   (PowerManagementMode == DPMSModeSuspend) ||
		   (PowerManagementMode == DPMSModeStandby)) {
	    if (info->IsSecondary) {
		if (info->DisplayType == MT_DFP) {
		    OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_BLANK_EN, ~RADEON_FP2_BLANK_EN);
		    OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_ON);
		    if (info->ChipFamily >= CHIP_FAMILY_R200) {
			OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_DV0_EN);
		    }
		}
	    } else {
		if ((info->Clone) && (info->CloneType == MT_DFP)) {
		    OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_BLANK_EN, ~RADEON_FP2_BLANK_EN);
		    OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_ON);
		    if (info->ChipFamily >= CHIP_FAMILY_R200) {
			OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_DV0_EN);
		    }
		}
		if (info->DisplayType == MT_DFP) {
		    OUTREGP (RADEON_FP_GEN_CNTL, 0, ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN));
		} else if (info->DisplayType == MT_LCD) {
		    unsigned long tmpPixclksCntl = INPLL(pScrn, RADEON_PIXCLKS_CNTL);

		    if (info->IsMobility || info->IsIGP) {
			/* Asic bug, when turning off LVDS_ON, we have to make sure
			   RADEON_PIXCLK_LVDS_ALWAYS_ON bit is off
			*/
			OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL, 0, ~RADEON_PIXCLK_LVDS_ALWAYS_ONb);
		    }

		    OUTREGP (RADEON_LVDS_GEN_CNTL, 0,
			     ~(RADEON_LVDS_BLON | RADEON_LVDS_ON));

		    if (info->IsMobility || info->IsIGP) {
			OUTPLL(RADEON_PIXCLKS_CNTL, tmpPixclksCntl);
		    }
		}
	    }
	}
a4544 4

#ifdef XF86DRI
    if (info->CPStarted) DRIUnlock(pScrn->pScreen);
#endif
@


1.1.9.2
log
@Import XFree86 4.4 from The XFree86(TM) Project, Inc.
(integrity cannot be checked)

got via cvs -qd anoncvs@@anoncvs.xfree86.org:/cvs co -Prxf-4_4_0 xc
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c,v 1.118 2004/02/26 04:25:29 martin Exp $ */
a5060 1
	(info->ChipFamily == CHIP_FAMILY_RS300) ||
a5457 1
    RADEONSaveCommonRegisters(pScrn, save);
d5463 1
a6066 1
    /* Alhought we current onlu use aperture 0, also setting aperture 1 should not harm -ReneR */
a6069 1
	save->surface_cntl |= RADEON_NONSURF_AP1_SWP_16BPP;
a6073 1
	save->surface_cntl |= RADEON_NONSURF_AP1_SWP_32BPP;
a6636 1
    RADEONInitCommonRegisters(save, info);
d6642 1
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c,v 1.91 2003/02/25 03:50:15 dawes Exp $ */
d32 1
a32 1
 *   Kevin E. Martin <martin@@xfree86.org>
d34 1
a34 1
 *   Alan Hourihane <alanh@@fairlite.demon.co.uk>
d55 1
a55 1
 *   shadowfb (Note: dri uses shadowfb for another purpose in radeon_dri.c)
a62 1
#include "radeon_macros.h"
d85 1
a96 1
#include "xf86Resources.h"
d126 1
a128 1
    OPTION_AGP_FW,
a132 2
    OPTION_PAGE_FLIP,
    OPTION_NO_BACKBUFFER,
d134 3
a136 8
    OPTION_PANEL_OFF,
    OPTION_DDC_MODE,
    OPTION_CLONE_DISPLAY,
    OPTION_CLONE_MODE,
    OPTION_CLONE_HSYNC,
    OPTION_CLONE_VREFRESH,
    OPTION_FBDEV,
    OPTION_VIDEO_KEY
d140 4
a143 4
    { OPTION_NOACCEL,        "NoAccel",          OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_SW_CURSOR,      "SWcursor",         OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_DAC_6BIT,       "Dac6Bit",          OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_DAC_8BIT,       "Dac8Bit",          OPTV_BOOLEAN, {0}, TRUE  },
d145 13
a157 21
    { OPTION_IS_PCI,         "ForcePCIMode",     OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_CP_PIO,         "CPPIOMode",        OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_USEC_TIMEOUT,   "CPusecTimeout",    OPTV_INTEGER, {0}, FALSE },
    { OPTION_AGP_MODE,       "AGPMode",          OPTV_INTEGER, {0}, FALSE },
    { OPTION_AGP_FW,         "AGPFastWrite",     OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_AGP_SIZE,       "AGPSize",          OPTV_INTEGER, {0}, FALSE },
    { OPTION_RING_SIZE,      "RingSize",         OPTV_INTEGER, {0}, FALSE },
    { OPTION_BUFFER_SIZE,    "BufferSize",       OPTV_INTEGER, {0}, FALSE },
    { OPTION_DEPTH_MOVE,     "EnableDepthMoves", OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_PAGE_FLIP,      "EnablePageFlip",   OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_NO_BACKBUFFER,  "NoBackBuffer",     OPTV_BOOLEAN, {0}, FALSE },
#endif
    { OPTION_PANEL_OFF,      "PanelOff",         OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_DDC_MODE,       "DDCMode",          OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_CLONE_DISPLAY,  "CloneDisplay",     OPTV_INTEGER, {0}, FALSE },
    { OPTION_CLONE_MODE,     "CloneMode",        OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_CLONE_HSYNC,    "CloneHSync",       OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_CLONE_VREFRESH, "CloneVRefresh",    OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_FBDEV,          "UseFBDev",         OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_VIDEO_KEY,      "VideoKey",         OPTV_INTEGER, {0}, FALSE },
    { -1,                    NULL,               OPTV_NONE,    {0}, FALSE }
a183 2
    "fbdevHWDPMSSet",

d223 1
a244 1
    "xf86ForceHWCursor",
a250 3
    "drmGetInterruptFromBusID",
    "drmCtlInstHandler",
    "drmCtlUninstHandler",
a254 1
    "drmAgpBase",
a262 4
    "drmCommandNone",
    "drmCommandRead",
    "drmCommandWrite",
    "drmCommandWriteRead",
a264 1
    "drmGetLibVersion",
d276 1
a276 2
    "drmScatterGatherAlloc",
    "drmScatterGatherFree",
a287 1
    "DRIGetDeviceInfo",
a295 5

static const char *driShadowFBSymbols[] = {
    "ShadowFBInit",
    NULL
};
a316 55
void RADEONLoaderRefSymLists(void)
{
    /*
     * Tell the loader about symbols from other modules that this module might
     * refer to.
     */
    xf86LoaderRefSymLists(vgahwSymbols,
#ifdef USE_FB
			  fbSymbols,
#else
			  cfbSymbols,
#endif
			  xaaSymbols,
#if 0
			  xf8_32bppSymbols,
#endif
			  ramdacSymbols,
#ifdef XF86DRI
			  drmSymbols,
			  driSymbols,
			  driShadowFBSymbols,
#endif
			  fbdevHWSymbols,
			  vbeSymbols,
			  int10Symbols,
			  i2cSymbols,
			  ddcSymbols,
			  NULL);
}

/* Established timings from EDID standard */
static struct
{
    int hsize;
    int vsize;
    int refresh;
} est_timings[] = {
    {1280, 1024, 75},
    {1024, 768, 75},
    {1024, 768, 70},
    {1024, 768, 60},
    {1024, 768, 87},
    {832, 624, 75},
    {800, 600, 75},
    {800, 600, 72},	
    {800, 600, 60},
    {800, 600, 56},
    {640, 480, 75},
    {640, 480, 72},
    {640, 480, 67},
    {640, 480, 60},
    {720, 400, 88},
    {720, 400, 70},
};

d319 4
a322 9
struct RADEONInt10Save {
	CARD32 MEM_CNTL;
	CARD32 MEMSIZE;
	CARD32 MPP_TB_CONFIG;
};

static Bool RADEONMapMMIO(ScrnInfoPtr pScrn);
static Bool RADEONUnmapMMIO(ScrnInfoPtr pScrn);

d324 1
a324 1
RADEONPreInt10Save(ScrnInfoPtr pScrn, void **pPtr)
d326 1
a326 1
    RADEONInfoPtr  info   = RADEONPTR(pScrn);
d328 1
a328 3
    int            mapped = 0;
    CARD32 CardTmp;
    static struct RADEONInt10Save SaveStruct = { 0, 0, 0 };
d338 1
a338 1
    if (!info->MMIOAddr)
d346 2
a347 7
    /* Save the values and zap MEM_CNTL */
    SaveStruct.MEM_CNTL = INREG(RADEON_MEM_CNTL);
    SaveStruct.MEMSIZE = INREG(RADEON_CONFIG_MEMSIZE);
    SaveStruct.MPP_TB_CONFIG = INREG(RADEON_MPP_TB_CONFIG);

    /* 
     * Zap MEM_CNTL and set MPP_TB_CONFIG<31:24> to 4
d349 2
a351 3
    CardTmp = SaveStruct.MPP_TB_CONFIG & 0x00ffffffu;
    CardTmp |= 0x04 << 24;
    OUTREG(RADEON_MPP_TB_CONFIG, CardTmp);
d353 4
a356 4
    *pPtr = (void *)&SaveStruct;

    /* Unmap mmio space if we mapped it */
    if (mapped)
d361 1
a361 1
RADEONPostInt10Check(ScrnInfoPtr pScrn, void *ptr)
d363 1
a363 1
    RADEONInfoPtr  info   = RADEONPTR(pScrn);
d365 2
a366 3
    struct RADEONInt10Save *pSave = ptr;
    CARD32 CardTmp;
    int            mapped = 0;
d368 4
a371 2
    /* If we don't have a valid (non-zero) saved MEM_CNTL, get out now */
    if (!pSave || !pSave->MEM_CNTL)
d374 3
a376 1
    /* First make sure that mmio is mapped */
d384 1
a384 1
     * If either MEM_CNTL is currently zero or inconistent (configured for
d388 7
a394 5
    CardTmp = INREG(RADEON_MEM_CNTL);
    if (!CardTmp || 
	((CardTmp & 1) && 
	 (((CardTmp >> 8) & 0xff) != ((CardTmp >> 24) & 0xff)))) {
	/* Restore the saved registers */
d397 2
a398 2
		   CardTmp, pSave->MEM_CNTL);
	OUTREG(RADEON_MEM_CNTL, pSave->MEM_CNTL);
a399 11
	CardTmp = INREG(RADEON_CONFIG_MEMSIZE);
	if (CardTmp != pSave->MEMSIZE) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Restoring CONFIG_MEMSIZE (%08x), setting to %08x\n",
		       CardTmp, pSave->MEMSIZE);
	    OUTREG(RADEON_CONFIG_MEMSIZE, pSave->MEMSIZE);
	}
    }

    CardTmp = INREG(RADEON_MPP_TB_CONFIG);
    if ((CardTmp & 0xff000000u) != (pSave->MPP_TB_CONFIG & 0xff000000u)) {
d401 3
a403 5
	           "Restoring MPP_TB_CONFIG<31:24> (%02x), setting to %02x\n",
	 	   CardTmp >> 24, pSave->MPP_TB_CONFIG >> 24);
	CardTmp &= 0x00ffffffu;
	CardTmp |= (pSave->MPP_TB_CONFIG & 0xff000000u);
	OUTREG(RADEON_MPP_TB_CONFIG, CardTmp);
d406 4
a409 2
    /* Unmap mmio space if we mapped it */
    if (mapped)
d413 7
a419 1
/* Allocate our private RADEONInfoRec */
d428 1
a428 1
/* Free our private RADEONInfoRec */
d437 1
a437 2
 * below
 */
d440 1
a440 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d457 1
a457 2
 * below
 */
d460 1
a460 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d474 1
a474 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d493 1
a493 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d503 1
a503 1
/* Memory map the MMIO region and the frame buffer */
d514 1
a514 1
/* Unmap the MMIO region and the frame buffer */
a520 17
/* This function is required to workaround a hardware bug in some (all?)
 * revisions of the R300.  This workaround should be called after every
 * CLOCK_CNTL_INDEX register access.  If not, register reads afterward
 * may not be correct.
 */
void R300CGWorkaround(ScrnInfoPtr pScrn) {
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    CARD32         save, tmp;

    save = INREG(RADEON_CLOCK_CNTL_INDEX);
    tmp = save & ~(0x3f | RADEON_PLL_WR_EN);
    OUTREG(RADEON_CLOCK_CNTL_INDEX, tmp);
    tmp = INREG(RADEON_CLOCK_CNTL_DATA);
    OUTREG(RADEON_CLOCK_CNTL_INDEX, save);
}

d524 1
a524 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
a525 1
    CARD32         data;
d527 8
a534 5
    OUTREG8(RADEON_CLOCK_CNTL_INDEX, addr & 0x3f);
    data = INREG(RADEON_CLOCK_CNTL_DATA);
    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);

    return data;
d538 1
a538 1
/* Read PAL information (only used for debugging) */
d541 1
a541 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d549 1
a549 1
/* Wait for vertical sync on primary CRTC */
d552 1
a552 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d554 1
a554 1
    int            i;
d556 3
a558 7
    /* Clear the CRTC_VBLANK_SAVE bit */
    OUTREG(RADEON_CRTC_STATUS, RADEON_CRTC_VBLANK_SAVE_CLEAR);

    /* Wait for it to go back up */
    for (i = 0; i < RADEON_TIMEOUT/1000; i++) {
	if (INREG(RADEON_CRTC_STATUS) & RADEON_CRTC_VBLANK_SAVE) break;
	usleep(1);
d562 2
a563 2
/* Wait for vertical sync on secondary CRTC */
void RADEONWaitForVerticalSync2(ScrnInfoPtr pScrn)
d565 1
a565 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
a566 1
    int            i;
d568 31
a598 7
    /* Clear the CRTC2_VBLANK_SAVE bit */
    OUTREG(RADEON_CRTC2_STATUS, RADEON_CRTC2_VBLANK_SAVE_CLEAR);

    /* Wait for it to go back up */
    for (i = 0; i < RADEON_TIMEOUT/1000; i++) {
	if (INREG(RADEON_CRTC2_STATUS) & RADEON_CRTC2_VBLANK_SAVE) break;
	usleep(1);
d602 2
a603 2
/* Blank screen */
static void RADEONBlank(ScrnInfoPtr pScrn)
d605 1
a605 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d607 37
a643 35

    if (!info->IsSecondary) {
	switch(info->DisplayType) {
	case MT_LCD:
	case MT_CRT:
	case MT_DFP:
	    OUTREGP(RADEON_CRTC_EXT_CNTL,
		    RADEON_CRTC_DISPLAY_DIS |
		    RADEON_CRTC_VSYNC_DIS |
		    RADEON_CRTC_HSYNC_DIS,
		    ~(RADEON_CRTC_DISPLAY_DIS |
		      RADEON_CRTC_VSYNC_DIS |
		      RADEON_CRTC_HSYNC_DIS));
	    break;

	case MT_NONE:
	default:
	    break;
	}
	if (info->Clone)
	    OUTREGP(RADEON_CRTC2_GEN_CNTL,
		    RADEON_CRTC2_DISP_DIS |
		    RADEON_CRTC2_VSYNC_DIS |
		    RADEON_CRTC2_HSYNC_DIS,
		    ~(RADEON_CRTC2_DISP_DIS |
		      RADEON_CRTC2_VSYNC_DIS |
		      RADEON_CRTC2_HSYNC_DIS));
    } else {
	OUTREGP(RADEON_CRTC2_GEN_CNTL,
		RADEON_CRTC2_DISP_DIS |
		RADEON_CRTC2_VSYNC_DIS |
		RADEON_CRTC2_HSYNC_DIS,
		~(RADEON_CRTC2_DISP_DIS |
		  RADEON_CRTC2_VSYNC_DIS |
		  RADEON_CRTC2_HSYNC_DIS));
d647 4
a650 2
/* Unblank screen */
static void RADEONUnblank(ScrnInfoPtr pScrn)
d652 1
a652 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d654 1
d656 33
a688 38
    if (!info->IsSecondary) {
	switch (info->DisplayType) {
	case MT_LCD:
	case MT_CRT:
	case MT_DFP:
	    OUTREGP(RADEON_CRTC_EXT_CNTL,
		    RADEON_CRTC_CRT_ON,
		    ~(RADEON_CRTC_DISPLAY_DIS |
		      RADEON_CRTC_VSYNC_DIS |
		      RADEON_CRTC_HSYNC_DIS));
	    break;

	case MT_NONE:
	default:
	    break;
	}
	if (info->Clone)
	    OUTREGP(RADEON_CRTC2_GEN_CNTL,
		    0,
		    ~(RADEON_CRTC2_DISP_DIS |
		      RADEON_CRTC2_VSYNC_DIS |
		      RADEON_CRTC2_HSYNC_DIS));
    } else {
	switch (info->DisplayType) {
	case MT_LCD:
	case MT_DFP:
	case MT_CRT:
	    OUTREGP(RADEON_CRTC2_GEN_CNTL,
		    0,
		    ~(RADEON_CRTC2_DISP_DIS |
		      RADEON_CRTC2_VSYNC_DIS |
		      RADEON_CRTC2_HSYNC_DIS));
	    break;

	case MT_NONE:
	default:
	    break;
	}
d691 1
d693 1
a693 1
/* Compute log base 2 of val */
d696 1
a696 1
    int  bits;
d703 1
a703 1
/* Compute n/d with rounding */
d709 1
a709 1
/* Read the Video BIOS block and the FP registers (if applicable) */
d712 3
a714 5
    RADEONInfoPtr  info            = RADEONPTR(pScrn);
    unsigned long  tmp, i;
    unsigned char *RADEONMMIO;
    Bool           BypassSecondary = FALSE;
    int            CloneDispOption;
d724 2
a725 1
    if (!(info->VBIOS = xalloc(RADEON_VBIOS_SIZE))) {
d731 3
a733 1
    if (pInt10) {
d737 3
a739 1
    } else {
d741 2
a742 1
	if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
d746 1
a746 2
		       "Attempting to read Video BIOS from "
		       "legacy ISA space!\n");
d748 1
a748 2
	    xf86ReadDomainMemory(info->PciTag, info->BIOSAddr,
				 RADEON_VBIOS_SIZE, info->VBIOS);
d751 2
a752 2

    if (info->VBIOS[0] != 0x55 || info->VBIOS[1] != 0xaa) {
a761 1
    info->OverlayOnCRTC2 = FALSE;
d763 177
a939 315
    RADEONMapMMIO(pScrn);
    RADEONMMIO = info->MMIO;

    /* FIXME: using BIOS scratch registers to detect connected monitors
     * may not be a reliable way.... should use EDID data.  Also it only
     * works with for VE/M6, no such registers in regular RADEON!!!
     */

    /* VE and M6 have both DVI and CRT ports (for M6 DVI port can be
     * switch to DFP port). The DVI port can also be conneted to a CRT
     * with an adapter.  Here is the definition of ports for this
     * driver:
     *
     * (1) If both port are connected, DVI port will be treated as the
     * Primary port (first screen in XF86Config, uses CRTC1) and CRT
     * port will be treated as the Secondary port (second screen in
     * XF86Config, uses CRTC2)
     *
     * (2) If only one screen specified in XF86Config, it will be used
     * for DVI port if a monitor is connected to DVI port, otherwise
     * (only one monitor is connected the CRT port) it will be used for
     * CRT port.
     */

    if (info->HasCRTC2) {
	/* FIXME: this may not be reliable */
	tmp = INREG(RADEON_BIOS_4_SCRATCH);

	if (info->IsSecondary) {
	    /* Check Port2 (CRT port) -- for the existing boards (VE &
	     * M6), this port can only be connected to a CRT
	     */
	    if (tmp & 0x02)        info->DisplayType = MT_CRT;
	    else if (tmp & 0x800)  info->DisplayType = MT_DFP;
	    else if (tmp & 0x400)  info->DisplayType = MT_LCD;
	    else if (tmp & 0x1000) info->DisplayType = MT_CTV;
	    else if (tmp & 0x2000) info->DisplayType = MT_STV;
	    else                   info->DisplayType = MT_CRT;

	} else {
	    info->Clone = FALSE;
	    info->CloneType = MT_NONE;

	    /* Check Primary (DVI/DFP port) */
	    if (tmp & 0x08)        info->DisplayType = MT_DFP;
	    else if (tmp & 0x04)   info->DisplayType = MT_LCD;
	    else if (tmp & 0x0200) info->DisplayType = MT_CRT;
	    else if (tmp & 0x10)   info->DisplayType = MT_CTV;
	    else if (tmp & 0x20)   info->DisplayType = MT_STV;
	    else                   info->DisplayType = MT_NONE;

	    if (info->DisplayType == MT_NONE) {
		/* DVI port has no monitor connected, try CRT port.
		 * If something on CRT port, treat it as primary
		 */
		if (xf86IsEntityShared(pScrn->entityList[0])) {
		    DevUnion     *pPriv;
		    RADEONEntPtr  pRADEONEnt;

		    pPriv = xf86GetEntityPrivate(pScrn->entityList[0],
						 gRADEONEntityIndex);
		    pRADEONEnt = pPriv->ptr;
		    pRADEONEnt->BypassSecondary = TRUE;
		}

		if (tmp & 0x02)        info->DisplayType = MT_CRT;
		else if (tmp & 0x800)  info->DisplayType = MT_DFP;
		else if (tmp & 0x400)  info->DisplayType = MT_LCD;
		else if (tmp & 0x1000) info->DisplayType = MT_CTV;
		else if (tmp & 0x2000) info->DisplayType = MT_STV;
		else {
		    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			       "No monitor detected!!!\n");
		    return FALSE;
		}
		BypassSecondary = TRUE;
	    } else {
		if (tmp & 0x02) {
		    info->CloneType = MT_CRT;
		    info->Clone = TRUE;
		} else if (tmp & 0x800) {
		    info->CloneType = MT_DFP;
		    info->Clone = TRUE;
		}
	    }

	    /* FIXME: This option is too complicated.  We need to
	     *        find a better way to handle all cases.
	     *
	     * CloneDisplay options:
	     *  0      -- disable
	     *  1      -- auto-detect (default)
	     *  2      -- force on
	     *  3      -- auto-detect + 2nd head overlay.
	     *  4      -- force on + 2nd head overlay.
	     *  others -- auto-detect
	     *
	     * Force on: it will force the clone mode on even no display
	     * is detected. With this option together with the proper
	     * CloneHSync and CloneVRefresh options, we can turn on the
	     * CRT ouput on the 2nd head regardless if a monitor is
	     * connected there.  This way, we can plug in a CRT to the
	     * second head later after X server has started.
	     *
	     * 2nd head overlay: it will force the hardware overlay on
	     * CRTC2 (used by 2nd head). Since we only have one overlay,
	     * we have to decide which head to use it (the overlay space
	     * on the other head will be blank). 2nd head overlay is on
	     * automatically when PanelOff option is effective.
	     */
	    if (xf86GetOptValInteger(info->Options, OPTION_CLONE_DISPLAY,
				     &(CloneDispOption))) {
		char *s = NULL;

		if (CloneDispOption < 0 || CloneDispOption > 4) {
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			       "Illegal CloneDisplay Option set, "
			       "using default\n");
		    CloneDispOption = 1;
		}

		switch (CloneDispOption) {
		case 0: s = "Disable"; break;
		case 1: s = "Auto-detect"; break;
		case 2: s = "Force On"; break;
		case 3: s = "Auto-detect -- use 2nd head overlay"; break;
		case 4: s = "Force On -- use 2nd head overlay"; break;
		}
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "CloneDisplay option: %s (%d)\n",
			   s, CloneDispOption);
	    } else {
		/* Default to auto-detect */
		CloneDispOption = 1;
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "CloneDisplay option not set -- "
			   "defaulting to auto-detect\n");
	    }

	    if (CloneDispOption == 0) {
		info->Clone = FALSE;
	    } else if ((CloneDispOption == 2 || CloneDispOption == 4)
		       && !info->Clone) {
		info->CloneType = MT_CRT;
		info->Clone = TRUE;
	    }

	    /* This will be used to set OV0_SCALAR_CNTL */
	    if (info->Clone && (CloneDispOption == 3 || CloneDispOption == 4))
		info->OverlayOnCRTC2 = TRUE; 
	}
    } else {
	/* Regular Radeon ASIC, only one CRTC, but it could be used for
	 * DFP with a DVI output, like AIW board
	 */
	tmp = INREG(RADEON_FP_GEN_CNTL);
	if (tmp & RADEON_FP_EN_TMDS) info->DisplayType = MT_DFP;
	else                         info->DisplayType = MT_CRT;
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%s Display == Type %d\n",
	       (info->IsSecondary ? "Secondary" : "Primary"),
	       info->DisplayType);

    RADEONMMIO = NULL;
    RADEONUnmapMMIO(pScrn);

    info->HBlank     = 0;
    info->HOverPlus  = 0;
    info->HSyncWidth = 0;
    info->VBlank     = 0;
    info->VOverPlus  = 0;
    info->VSyncWidth = 0;
    info->DotClock   = 0;

    if (info->DisplayType == MT_LCD) {
	tmp = RADEON_BIOS16(info->FPBIOSstart + 0x40);
	if (!tmp) {
	    info->PanelPwrDly = 200;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "No Panel Info Table found in BIOS!\n");
	} else {
	    char  stmp[30];
	    int   tmp0;

	    for (i = 0; i < 24; i++)
		stmp[i] = RADEON_BIOS8(tmp+i+1);
	    stmp[24] = 0;

	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Panel ID string: %s\n", stmp);

	    info->PanelXRes = RADEON_BIOS16(tmp+25);
	    info->PanelYRes = RADEON_BIOS16(tmp+27);
	    xf86DrvMsg(0, X_INFO, "Panel Size from BIOS: %dx%d\n",
		       info->PanelXRes, info->PanelYRes);

	    info->PanelPwrDly = RADEON_BIOS16(tmp+44);
	    if (info->PanelPwrDly > 2000 || info->PanelPwrDly < 0)
		info->PanelPwrDly = 2000;
	    for (i = 0; i < 20; i++) {
		tmp0 = RADEON_BIOS16(tmp+64+i*2);
		if (tmp0 == 0) break;
		if ((RADEON_BIOS16(tmp0) == info->PanelXRes) &&
		    (RADEON_BIOS16(tmp0+2) == info->PanelYRes)) {
		    info->HBlank     = (RADEON_BIOS16(tmp0+17) -
					RADEON_BIOS16(tmp0+19)) * 8;
		    info->HOverPlus  = (RADEON_BIOS16(tmp0+21) -
					RADEON_BIOS16(tmp0+19) - 1) * 8;
		    info->HSyncWidth = RADEON_BIOS8(tmp0+23) * 8;
		    info->VBlank     = (RADEON_BIOS16(tmp0+24) -
					RADEON_BIOS16(tmp0+26));
		    info->VOverPlus  = ((RADEON_BIOS16(tmp0+28) & 0x7ff) -
					RADEON_BIOS16(tmp0+26));
		    info->VSyncWidth = ((RADEON_BIOS16(tmp0+28) & 0xf800)
					>> 11);
		    info->DotClock   = RADEON_BIOS16(tmp0+9) * 10;
		    info->Flags      = 0;
		}
	    }
	}
    } else if ((info->DisplayType == MT_DFP) && info->HasCRTC2) {
	tmp = RADEON_BIOS16(info->FPBIOSstart + 0x34);
	if (tmp != 0) {
	    tmp = RADEON_BIOS16(tmp + 2);
	    if (tmp != 0) {
		/* 18 bytes of EDID data should be here */
		info->DotClock = RADEON_BIOS16(tmp) * 10;
		info->PanelXRes =
		    ((RADEON_BIOS8(tmp + 4) & 0xf0) << 4) +
		    RADEON_BIOS8(tmp + 2);
		info->HBlank =
		    ((RADEON_BIOS8(tmp + 4) & 0x0f) << 8) +
		    RADEON_BIOS8(tmp + 3);
		info->PanelYRes =
		    ((RADEON_BIOS8(tmp + 7) & 0xf0) << 4) +
		    RADEON_BIOS8(tmp + 5);
		info->VBlank =
		    ((RADEON_BIOS8(tmp + 7) & 0x0f) << 8) +
		    RADEON_BIOS8(tmp + 6);
		info->HOverPlus =
		    ((RADEON_BIOS8(tmp + 11) & 0xc0) << 2) +
		    RADEON_BIOS8(tmp + 8);
		info->HSyncWidth =
		    ((RADEON_BIOS8(tmp + 11) & 0x30) << 4) +
		    RADEON_BIOS8(tmp + 9);
		info->VOverPlus =
		    ((RADEON_BIOS8(tmp + 11) & 0x0c) << 2) +
		    ((RADEON_BIOS8(tmp + 10) & 0xf0) >> 4);
		info->VSyncWidth =
		    ((RADEON_BIOS8(tmp + 11) & 0x03) << 4) +
		    (RADEON_BIOS8(tmp + 10) & 0x0f);
		info->Flags = 0;
	    } else {
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "No DFP timing table detected\n");
	    }
	}

	RADEONTRACE(("DFP Info: ----------------------\n"
		     "pixel clock: %d KHz\n"
		     "panel size: %dx%d\n"
		     "H. Blanking: %d\n"
		     "H. Sync. Offset: %d\n"
		     "H. Sync. Width: %d\n"
		     "V. Blanking: %d\n"
		     "V. Sync. Offset: %d\n"
		     "V. Sync. Width: %d\n",
		     info->DotClock,
		     info->PanelXRes, info->PanelYRes,
		     info->HBlank,
		     info->HOverPlus,
		     info->HSyncWidth,
		     info->VBlank, info->VOverPlus, info->VSyncWidth));
    }

    /* Detect connector type from BIOS, used for I2C/DDC qeurying EDID,
     * Only available for VE or newer cards */

    /* DELL OEM card doesn't seem to follow the conviention for BIOS's
     * DDC type, we have to make a special case.  Following hard coded
     * type works with both CRT+CRT and DVI+DVI cases
     */
    if (info->IsDell && info->DellType == 2) {
	if (info->IsSecondary)
	    info->DDCType = DDC_CRT2;
	else
	    info->DDCType = DDC_DVI;
	info->CloneDDCType = DDC_CRT2;
    } else if ((tmp = RADEON_BIOS16(info->FPBIOSstart + 0x50))) {
	for (i = 1; i < 4; i++) {
	    unsigned int tmp0;
	    if (!RADEON_BIOS8(tmp + i*2) && i > 1) break;

	    /* Note: Secondary port (CRT port) actually uses primary DAC */
	    tmp0 = RADEON_BIOS16(tmp + i*2);
	    if (tmp0 & 0x01) {
		if (!info->IsSecondary && !BypassSecondary)
		    info->DDCType = (tmp0 & 0x0f00) >> 8;
	    } else { /* Primary DAC */
		if (info->Clone)
		    info->CloneDDCType = (tmp0 & 0x0f00) >> 8;
		else if (info->IsSecondary ||
			 BypassSecondary ||
			 !info->HasCRTC2) {
		    info->DDCType = (tmp0 & 0x0f00) >> 8;
		}
	    }
	}
    } else {
	/* Orignal radeon cards, set it to DDC_VGA, this will not work
	 * with AIW, it should be DDC_DVI, let it fall back to VBE calls
	 * for AIW
	 */
	info->DDCType = DDC_VGA;
d945 2
a946 3
/* Read PLL parameters from BIOS block.  Default to typical values if
 * there is no BIOS.
 */
d949 4
a952 4
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    RADEONPLLPtr   pll  = &info->pll;
    CARD16         bios_header;
    CARD16         pll_info_block;
d961 3
a963 3

	/* These are somewhat sane defaults for Mac boards, we will need
	 * to find a good way of getting these from OpenFirmware
d994 1
a994 1
/* This is called by RADEONPreInit to set up the default visual */
d997 1
a997 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d999 1
a999 1
    if (!xf86SetDepthBpp(pScrn, 8, 8, 8, Support32bppFb))
a1007 1

d1017 2
a1018 3
    info->fifo_slots                 = 0;
    info->pix24bpp                   = xf86GetBppFromDepth(pScrn,
							   pScrn->depth);
d1028 1
a1028 1
		   "Radeon does NOT support 24bpp\n");
d1039 1
d1049 1
d1052 1
a1052 1
/* This is called by RADEONPreInit to handle all color weight issues */
d1055 1
a1055 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
a1062 1

d1064 1
a1064 2
	rgb  defaultWeight = { 0, 0, 0 };

a1072 1

d1078 1
d1081 3
a1083 5
/* This is called by RADEONPreInit to handle config file overrides for
 * things like chipset and memory regions.  Also determine memory size
 * and type.  If memory type ever needs an override, put it in this
 * routine.
 */
d1086 6
a1091 6
    RADEONInfoPtr  info   = RADEONPTR(pScrn);
    EntityInfoPtr  pEnt   = info->pEnt;
    GDevPtr        dev    = pEnt->device;
    int            offset = 0; /* RAM Type */
    MessageType    from;
    unsigned char *RADEONMMIO;
d1104 1
a1105 1
    pScrn->chipset = (char *)xf86TokenToString(RADEONChipsets, info->Chipset);
d1111 1
d1117 1
a1122 11
    info->HasCRTC2 = TRUE;
    switch (info->Chipset) {
    case PCI_CHIP_RADEON_LY:
    case PCI_CHIP_RADEON_LZ:
	info->ChipFamily = CHIP_FAMILY_M6;
	break;

    case PCI_CHIP_RV100_QY:
    case PCI_CHIP_RV100_QZ:
	info->ChipFamily = CHIP_FAMILY_VE;
	break;
d1124 27
a1150 83
    case PCI_CHIP_R200_BB:
    case PCI_CHIP_R200_QH:
    case PCI_CHIP_R200_QI:
    case PCI_CHIP_R200_QJ:
    case PCI_CHIP_R200_QK:
    case PCI_CHIP_R200_QL:
    case PCI_CHIP_R200_QM:
    case PCI_CHIP_R200_QN:
    case PCI_CHIP_R200_QO:
    case PCI_CHIP_R200_Qh:
    case PCI_CHIP_R200_Qi:
    case PCI_CHIP_R200_Qj:
    case PCI_CHIP_R200_Qk:
    case PCI_CHIP_R200_Ql:
	info->ChipFamily = CHIP_FAMILY_R200;
	break;

    case PCI_CHIP_RV200_QW: /* RV200 desktop */
    case PCI_CHIP_RV200_QX:
	info->ChipFamily = CHIP_FAMILY_RV200;
	break;

    case PCI_CHIP_RADEON_LW:
    case PCI_CHIP_RADEON_LX:
	info->ChipFamily = CHIP_FAMILY_M7;
	break;

    case PCI_CHIP_RV250_Id:
    case PCI_CHIP_RV250_Ie:
    case PCI_CHIP_RV250_If:
    case PCI_CHIP_RV250_Ig:
	info->ChipFamily = CHIP_FAMILY_RV250;
	break;

    case PCI_CHIP_RV250_Ld:
    case PCI_CHIP_RV250_Le:
    case PCI_CHIP_RV250_Lf:
    case PCI_CHIP_RV250_Lg:
	info->ChipFamily = CHIP_FAMILY_M9;
	break;

    case PCI_CHIP_R300_AD:
    case PCI_CHIP_R300_AE:
    case PCI_CHIP_R300_AF:
    case PCI_CHIP_R300_AG:
    case PCI_CHIP_R300_ND:
    case PCI_CHIP_R300_NE:
    case PCI_CHIP_R300_NF:
    case PCI_CHIP_R300_NG:
	info->ChipFamily = CHIP_FAMILY_R300;
        break;

    default:
	/* Original Radeon/7200 */
	info->ChipFamily = CHIP_FAMILY_RADEON;
	info->HasCRTC2 = FALSE;
    }

    /* Here is the special case for DELL's VE card.
     * It needs some special handlings for it's 2nd head to work.
     */
    info->IsDell = FALSE;
    if (info->ChipFamily == CHIP_FAMILY_VE &&
	info->PciInfo->subsysVendor == PCI_VENDOR_ATI && 
	info->PciInfo->subsysCard & (1 << 12)) { /* DELL's signature */
	if (info->PciInfo->subsysCard & 0xb00) {
	    info->IsDell = TRUE;
	    info->DellType = 2;	/* DVI+DVI config, this seems to be the
				 * only known type for now, can be
				 * connected to both DVI+DVI and VGA+VGA
				 * dongles.
				 */
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "DELL OEM Card detected with %s (type %d)\n",
		       (info->DellType == 2) ? "DVI+DVI / VGA+VGA" : "VGA+VGA",
		       info->DellType);
	} else {
	    info->DellType = 0;	/* Unknown */
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Unknown type of DELL's Card (SSCID %x), "
		       "treated as normal type\n",
		       info->PciInfo->subsysCard);
	}
d1155 2
a1156 2
    from               = X_PROBED;
    info->LinearAddr   = info->PciInfo->memBase[0] & 0xfc000000;
d1215 20
a1234 27

    /* Some production boards of m6 will return 0 if it's 8 MB */
    if (pScrn->videoRam == 0) pScrn->videoRam = 8192;

    if (info->IsSecondary) {
	/* FIXME: For now, split FB into two equal sections. This should
	 * be able to be adjusted by user with a config option. */
	DevUnion      *pPriv;
	RADEONEntPtr   pRADEONEnt;
	RADEONInfoPtr  info1;

	pPriv = xf86GetEntityPrivate(pScrn->entityList[0], gRADEONEntityIndex);
	pRADEONEnt = pPriv->ptr;
	pScrn->videoRam /= 2;
	pRADEONEnt->pPrimaryScrn->videoRam = pScrn->videoRam;

	info1 = RADEONPTR(pRADEONEnt->pPrimaryScrn);
	info1->FbMapSize  = pScrn->videoRam * 1024;
	info->LinearAddr += pScrn->videoRam * 1024;
	info1->Clone = FALSE;
	info1->CurCloneMode = NULL;
    }

    info->R300CGWorkaround =
	(info->ChipFamily == CHIP_FAMILY_R300 &&
	 (INREG(RADEON_CONFIG_CNTL) & RADEON_CFG_ATI_REV_ID_MASK)
	 == RADEON_CFG_ATI_REV_A11);
d1243 3
a1245 3
    case 0:  offset = 0; break; /*  64-bit SDR SDRAM */
    case 1:  offset = 1; break; /*  64-bit DDR SDRAM */
    default: offset = 0;
d1249 2
a1250 1
    if (dev->videoRam) {
d1273 2
a1274 2
	case PCI_CHIP_RV100_QY:
	case PCI_CHIP_RV100_QZ:
a1275 1
	case PCI_CHIP_RADEON_LX:
a1281 5
	case PCI_CHIP_R200_BB:
	case PCI_CHIP_R200_QH:
	case PCI_CHIP_R200_QI:
	case PCI_CHIP_R200_QJ:
	case PCI_CHIP_R200_QK:
a1282 1
	case PCI_CHIP_R200_QM:
a1284 4
	case PCI_CHIP_R200_Qh:
	case PCI_CHIP_R200_Qi:
	case PCI_CHIP_R200_Qj:
	case PCI_CHIP_R200_Qk:
d1286 1
a1287 17
	case PCI_CHIP_RV200_QX:
	case PCI_CHIP_RV250_Id:
	case PCI_CHIP_RV250_Ie:
	case PCI_CHIP_RV250_If:
	case PCI_CHIP_RV250_Ig:
	case PCI_CHIP_RV250_Ld:
	case PCI_CHIP_RV250_Le:
	case PCI_CHIP_RV250_Lf:
	case PCI_CHIP_RV250_Lg:
	case PCI_CHIP_R300_AD:
	case PCI_CHIP_R300_AE:
	case PCI_CHIP_R300_AF:
	case PCI_CHIP_R300_AG:
	case PCI_CHIP_R300_ND:
	case PCI_CHIP_R300_NE:
	case PCI_CHIP_R300_NF:
	case PCI_CHIP_R300_NG:
d1296 2
a1297 1
static void RADEONI2CGetBits(I2CBusPtr b, int *Clock, int *data)
d1299 3
a1301 3
    ScrnInfoPtr    pScrn      = xf86Screens[b->scrnIndex];
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned long  val;
d1304 1
a1304 1
    /* Get the result */
d1309 1
d1312 2
a1313 1
static void RADEONI2CPutBits(I2CBusPtr b, int Clock, int data)
d1315 3
a1317 3
    ScrnInfoPtr    pScrn      = xf86Screens[b->scrnIndex];
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned long  val;
d1320 2
a1321 1
    val = INREG(info->DDCReg) & (CARD32)~(RADEON_GPIO_EN_0 | RADEON_GPIO_EN_1);
d1327 3
a1329 1
static Bool RADEONI2cInit(ScrnInfoPtr pScrn)
d1331 1
a1331 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d1334 1
a1334 1
    if (!info->pI2CBus) return FALSE;
d1342 16
a1357 15
    switch (info->DDCType) {
    case DDC_MONID:
	info->DDCReg = RADEON_GPIO_MONID;
	break;
    case DDC_DVI:
	info->DDCReg = RADEON_GPIO_DVI_DDC;
	break;
    case DDC_VGA:
	info->DDCReg = RADEON_GPIO_VGA_DDC;
	break;
    case DDC_CRT2:
	info->DDCReg = RADEON_GPIO_CRT2_DDC;
	break;
    default:
	return FALSE;
d1366 2
a1367 2
    RADEONInfoPtr  info = RADEONPTR(pScrn);
 /* vbeInfoPtr     pVbe; */
d1369 1
a1369 1
    info->ddc1     = FALSE;
d1371 8
a1378 5
    if (!xf86LoadSubModule(pScrn, "ddc")) {
	info->ddc2 = FALSE;
    } else {
	xf86LoaderReqSymLists(ddcSymbols, NULL);
	info->ddc2 = TRUE;
d1381 3
a1383 1
    /* DDC can use I2C bus */
d1385 8
a1392 6
    if (info->ddc2) {
	if (xf86LoadSubModule(pScrn, "i2c")) {
	    xf86LoaderReqSymLists(i2cSymbols,NULL);
	    info->ddc2 = RADEONI2cInit(pScrn);
	}
	else info->ddc2 = FALSE;
d1396 2
a1397 1
static xf86MonPtr RADEONDoDDC(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
d1399 2
a1400 2
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    xf86MonPtr     MonInfo = NULL;
a1401 1
    int            i;
a1402 4
    /* We'll use DDC2, BIOS EDID can only detect the monitor connected
     * to one port. For VE, BIOS EDID detects the monitor connected to
     * DVI port by default. If no monitor their, it will try CRT port
     */
d1404 7
d1412 13
a1424 2
    if (info->pI2CBus && info->ddc2) {
	int  j;
d1426 30
a1455 4
	if (!RADEONMapMMIO(pScrn)) return NULL;
	RADEONMMIO = info->MMIO;
	OUTREG(info->DDCReg, INREG(info->DDCReg) &
	       (CARD32)~(RADEON_GPIO_A_0 | RADEON_GPIO_A_1));
d1457 7
a1463 17
	/* For some old monitors (like Compaq Presario FP500), we need
	 * following process to initialize/stop DDC
	 */
	OUTREG(info->DDCReg, INREG(info->DDCReg) & ~(RADEON_GPIO_EN_1));
	for (j = 0; j < 3; j++) {
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_0));
	    usleep(13000);

	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_1));
	    for (i = 0; i < 10; i++) {
		usleep(15000);
		if (INREG(info->DDCReg) & RADEON_GPIO_Y_1)
		    break;
	    }
	    if (i == 10) continue;
d1465 2
a1466 1
	    usleep(15000);
d1468 5
a1472 2
	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_0);
	    usleep(15000);
d1474 10
a1483 28
	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_1);
	    usleep(15000);
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_0));
	    usleep(15000);
	    MonInfo = xf86DoEDID_DDC2(pScrn->scrnIndex, info->pI2CBus);

	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_1);
	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_0);
	    usleep(15000);
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_1));
	    for (i = 0; i < 50; i++) {
		usleep(15000);
		if (INREG(info->DDCReg) & RADEON_GPIO_Y_1)
		    break;
	    }
	    usleep(15000);
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_0));
	    usleep(15000);

	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_1);
	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_0);
	    usleep(15000);
	    if (MonInfo)
		break;
	}
d1485 8
a1492 1
	RADEONUnmapMMIO(pScrn);
d1495 9
a1503 14
    if (!MonInfo && pInt10 && (info->DDCReg == RADEON_GPIO_VGA_DDC)) {
	if (xf86LoadSubModule(pScrn, "vbe")) {
	    vbeInfoPtr  pVbe;
	    pVbe = VBEInit(pInt10, info->pEnt->index);
	    if (pVbe) {
		for (i = 0; i < 5; i++) {
		    MonInfo = vbeDoEDID(pVbe, NULL);
		    info->ddc_bios = TRUE;
		    if (MonInfo)
			break;
		}
	    } else
		info->ddc_bios = FALSE;
	}
d1506 74
a1579 6
    if (MonInfo) {
	if (info->ddc2)
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "I2C EDID Info:\n");
	else if (info->ddc_bios)
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "BIOS  EDID Info:\n");
	else return NULL;
d1581 1
a1581 2
	xf86PrintEDID(MonInfo);
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "End of DDC Monitor info\n\n");
d1583 1
a1583 4
	xf86SetDDCproperties(pScrn, MonInfo);
	return MonInfo;
    }
    else return NULL;
d1586 2
a1587 4
/* BIOS may not have right panel size, we search through all supported
 * DDC modes looking for the maximum panel size.
 */
static void RADEONUpdatePanelSize(ScrnInfoPtr pScrn)
d1589 1
a1589 25
    int             j;
    RADEONInfoPtr   info = RADEONPTR (pScrn);
    xf86MonPtr      ddc  = pScrn->monitor->DDC;
    DisplayModePtr  p;

    /* Go thru detailed timing table first */
    for (j = 0; j < 4; j++) {
	if (ddc->det_mon[j].type == 0) {
	    struct detailed_timings *d_timings =
		&ddc->det_mon[j].section.d_timings;
	    if (info->PanelXRes < d_timings->h_active &&
		info->PanelYRes < d_timings->v_active) {

		info->PanelXRes  = d_timings->h_active;
		info->PanelYRes  = d_timings->v_active;
		info->DotClock   = d_timings->clock / 1000;
		info->HOverPlus  = d_timings->h_sync_off;
		info->HSyncWidth = d_timings->h_sync_width;
		info->HBlank     = d_timings->h_blanking;
		info->VOverPlus  = d_timings->v_sync_off;
		info->VSyncWidth = d_timings->v_sync_width;
		info->VBlank     = d_timings->v_blanking;
	    }
	}
    }
d1591 1
a1591 537
    /* Search thru standard VESA modes from EDID */
    for (j = 0; j < 8; j++) {
	if ((info->PanelXRes < ddc->timings2[j].hsize) &&
	    (info->PanelYRes < ddc->timings2[j].vsize)) {
	    for (p = pScrn->monitor->Modes; p && p->next; p = p->next->next) {
		if ((ddc->timings2[j].hsize == p->HDisplay) &&
		    (ddc->timings2[j].vsize == p->VDisplay)) {
		    float  refresh =
			(float)p->Clock * 1000.0 / p->HTotal / p->VTotal;

		    if (abs((float)ddc->timings2[j].refresh - refresh) < 1.0) {
			/* Is this good enough? */
			info->PanelXRes  = ddc->timings2[j].hsize;
			info->PanelYRes  = ddc->timings2[j].vsize;
			info->HBlank     = p->HTotal - p->HDisplay;
			info->HOverPlus  = p->HSyncStart - p->HDisplay;
			info->HSyncWidth = p->HSyncEnd - p->HSyncStart;
			info->VBlank     = p->VTotal - p->VDisplay;
			info->VOverPlus  = p->VSyncStart - p->VDisplay;
			info->VSyncWidth = p->VSyncEnd - p->VSyncStart;
			info->DotClock   = p->Clock;
			info->Flags      =
			    (ddc->det_mon[j].section.d_timings.interlaced
			     ? V_INTERLACE
			     : 0);
			if (ddc->det_mon[j].section.d_timings.sync == 3) {
			    switch (ddc->det_mon[j].section.d_timings.misc) {
			    case 0: info->Flags |= V_NHSYNC | V_NVSYNC; break;
			    case 1: info->Flags |= V_PHSYNC | V_NVSYNC; break;
			    case 2: info->Flags |= V_NHSYNC | V_PVSYNC; break;
			    case 3: info->Flags |= V_PHSYNC | V_PVSYNC; break;
			    }
			}
		    }
		}
	    }
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Panel size found from DDC: %dx%d\n",
	       info->PanelXRes, info->PanelYRes);
}

/* This function will sort all modes according to their resolution.
 * Highest resolution first.
 */
static void RADEONSortModes(DisplayModePtr *new, DisplayModePtr *first,
			    DisplayModePtr *last)
{
    DisplayModePtr  p;

    p = *last;
    while (p) {
	if ((((*new)->HDisplay < p->HDisplay) && 
	     ((*new)->VDisplay < p->VDisplay)) ||
	    (((*new)->HDisplay == p->HDisplay) &&
	     ((*new)->VDisplay == p->VDisplay) &&
	     ((*new)->Clock < p->Clock))) {

	    if (p->next) p->next->prev = *new;
	    (*new)->prev = p;
	    (*new)->next = p->next;
	    p->next = *new;
	    if (!((*new)->next)) *last = *new;
	    break;
	}
	if (!p->prev) {
	    (*new)->prev = NULL;
	    (*new)->next = p;
	    p->prev = *new;
	    *first = *new;
	    break;
	} 
	p = p->prev;
    }

    if (!*first) {
	*first = *new;
	(*new)->prev = NULL;
	(*new)->next = NULL;
	*last = *new;
    }
}

static void RADEONSetPitch (ScrnInfoPtr pScrn)
{
    int  dummy = pScrn->virtualX;

    /* FIXME: May need to validate line pitch here */
    switch (pScrn->depth / 8) {
    case 1: dummy = (pScrn->virtualX + 127) & ~127; break;
    case 2: dummy = (pScrn->virtualX +  31) &  ~31; break;
    case 3:
    case 4: dummy = (pScrn->virtualX +  15) &  ~15; break;
    }
    pScrn->displayWidth = dummy;
}

/* When no mode provided in config file, this will add all modes supported in 
 * DDC date the pScrn->modes list
 */
static DisplayModePtr RADEONDDCModes(ScrnInfoPtr pScrn)
{
    DisplayModePtr  p;
    DisplayModePtr  last  = NULL;
    DisplayModePtr  new   = NULL;
    DisplayModePtr  first = NULL;
    int             count = 0;
    int             j, tmp;
    char            stmp[32];
    xf86MonPtr      ddc   = pScrn->monitor->DDC;

    /* Go thru detailed timing table first */
    for (j = 0; j < 4; j++) {
	if (ddc->det_mon[j].type == 0) {
	    struct detailed_timings *d_timings =
		&ddc->det_mon[j].section.d_timings;

	    if (d_timings->h_active == 0 || d_timings->v_active == 0) break;

	    new = xnfcalloc(1, sizeof (DisplayModeRec));
	    memset(new, 0, sizeof (DisplayModeRec));

	    new->HDisplay   = d_timings->h_active;
	    new->VDisplay   = d_timings->v_active;

	    sprintf(stmp, "%dx%d", new->HDisplay, new->VDisplay);
	    new->name       = xnfalloc(strlen(stmp) + 1);
	    strcpy(new->name, stmp);

	    new->HTotal     = new->HDisplay + d_timings->h_blanking;
	    new->HSyncStart = new->HDisplay + d_timings->h_sync_off;
	    new->HSyncEnd   = new->HSyncStart + d_timings->h_sync_width;
	    new->VTotal     = new->VDisplay + d_timings->v_blanking;
	    new->VSyncStart = new->VDisplay + d_timings->v_sync_off;
	    new->VSyncEnd   = new->VSyncStart + d_timings->v_sync_width;
	    new->Clock      = d_timings->clock / 1000;
	    new->Flags      = (d_timings->interlaced ? V_INTERLACE : 0);
	    new->status     = MODE_OK;
	    new->type       = M_T_DEFAULT;

	    if (d_timings->sync == 3) {
		switch (d_timings->misc) {
		case 0: new->Flags |= V_NHSYNC | V_NVSYNC; break;
		case 1: new->Flags |= V_PHSYNC | V_NVSYNC; break;
		case 2: new->Flags |= V_NHSYNC | V_PVSYNC; break;
		case 3: new->Flags |= V_PHSYNC | V_PVSYNC; break;
		}
	    }
	    count++;

	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Valid Mode from Detailed timing table: %s\n",
		       new->name);

	    RADEONSortModes(&new, &first, &last);
	}
    }

    /* Search thru standard VESA modes from EDID */
    for (j = 0; j < 8; j++) {
	for (p = pScrn->monitor->Modes; p && p->next; p = p->next->next) {
	    /* Ignore all double scan modes */
	    if ((ddc->timings2[j].hsize == p->HDisplay) &&
		(ddc->timings2[j].vsize == p->VDisplay)) {
		float  refresh =
		    (float)p->Clock * 1000.0 / p->HTotal / p->VTotal;

		if (abs((float)ddc->timings2[j].refresh - refresh) < 1.0) {
		    /* Is this good enough? */
		    new = xnfcalloc(1, sizeof (DisplayModeRec));
		    memcpy(new, p, sizeof(DisplayModeRec));
		    new->name = xnfalloc(strlen(p->name) + 1);
		    strcpy(new->name, p->name);
		    new->status = MODE_OK;
		    new->type   = M_T_DEFAULT;

		    count++;

		    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			       "Valid Mode from standard timing table: %s\n",
			       new->name);

		    RADEONSortModes(&new, &first, &last);
		    break;
		}
	    }
	}
    }

    /* Search thru established modes from EDID */
    tmp = (ddc->timings1.t1 << 8) | ddc->timings1.t2;
    for (j = 0; j < 16; j++) {
	if (tmp & (1 << j)) {
	    for (p = pScrn->monitor->Modes; p && p->next; p = p->next->next) {
		if ((est_timings[j].hsize == p->HDisplay) &&
		    (est_timings[j].vsize == p->VDisplay)) {
		    float  refresh =
			(float)p->Clock * 1000.0 / p->HTotal / p->VTotal;

		    if (abs((float)est_timings[j].refresh - refresh) < 1.0) {
			/* Is this good enough? */
			new = xnfcalloc(1, sizeof (DisplayModeRec));
			memcpy(new, p, sizeof(DisplayModeRec));
			new->name = xnfalloc(strlen(p->name) + 1);
			strcpy(new->name, p->name);
			new->status = MODE_OK;
			new->type   = M_T_DEFAULT;
		    
			count++;

			xf86DrvMsg(pScrn->scrnIndex, X_INFO,
				   "Valid Mode from established timing "
				   "table: %s\n", new->name);

			RADEONSortModes(&new, &first, &last);
			break;
		    }
		}
	    }
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Total of %d mode(s) found.\n", count);

    return first;
}

/* XFree86's xf86ValidateModes routine doesn't work well with DDC modes,
 * so here is our own validation routine.
 */
static int RADEONValidateDDCModes(ScrnInfoPtr pScrn, char **ppModeName,
				  RADEONMonitorType DisplayType)
{
    RADEONInfoPtr   info       = RADEONPTR(pScrn);
    DisplayModePtr  p;
    DisplayModePtr  last       = NULL;
    DisplayModePtr  first      = NULL;
    DisplayModePtr  ddcModes   = NULL;
    int             count      = 0;
    int             i, width, height;

    pScrn->virtualX = pScrn->display->virtualX;
    pScrn->virtualY = pScrn->display->virtualY;

    if (pScrn->monitor->DDC) {
	int  maxVirtX = pScrn->virtualX;
	int  maxVirtY = pScrn->virtualY;

	if (DisplayType != MT_CRT) {
	    /* The panel size we collected from BIOS may not be the
	     * maximum size supported by the panel.  If not, we update
	     * it now.  These will be used if no matching mode can be
	     * found from EDID data.
	     */
	    RADEONUpdatePanelSize(pScrn);
	}

	/* Collect all of the DDC modes */
	first = last = ddcModes = RADEONDDCModes(pScrn);

	for (p = ddcModes; p; p = p->next) {

	    /* If primary head is a flat panel, use RMX by default */
	    if ((!info->IsSecondary && DisplayType != MT_CRT) &&
		!info->ddc_mode) {
		/* These values are effective values after expansion.
		 * They are not really used to set CRTC registers.
		 */
		p->HTotal     = info->PanelXRes + info->HBlank;
		p->HSyncStart = info->PanelXRes + info->HOverPlus;
		p->HSyncEnd   = p->HSyncStart + info->HSyncWidth;
		p->VTotal     = info->PanelYRes + info->VBlank;
		p->VSyncStart = info->PanelYRes + info->VOverPlus;
		p->VSyncEnd   = p->VSyncStart + info->VSyncWidth;
		p->Clock      = info->DotClock;

		p->Flags     |= RADEON_USE_RMX;
	    }

	    maxVirtX = MAX(maxVirtX, p->HDisplay);
	    maxVirtY = MAX(maxVirtY, p->VDisplay);
	    count++;

	    last = p;
	}

	/* Match up modes that are specified in the XF86Config file */
	if (ppModeName[0]) {
	    DisplayModePtr  next;

	    /* Reset the max virtual dimensions */
	    maxVirtX = pScrn->virtualX;
	    maxVirtY = pScrn->virtualY;

	    /* Reset list */
	    first = last = NULL;

	    for (i = 0; ppModeName[i]; i++) {
		/* FIXME: Use HDisplay and VDisplay instead of mode string */
		if (sscanf(ppModeName[i], "%dx%d", &width, &height) == 2) {
		    for (p = ddcModes; p; p = next) {
			next = p->next;

			if (p->HDisplay == width && p->VDisplay == height) {
			    /* We found a DDC mode that matches the one
                               requested in the XF86Config file */
			    p->type |= M_T_USERDEF;

			    /* Update  the max virtual setttings */
			    maxVirtX = MAX(maxVirtX, width);
			    maxVirtY = MAX(maxVirtY, height);

			    /* Unhook from DDC modes */
			    if (p->prev) p->prev->next = p->next;
			    if (p->next) p->next->prev = p->prev;
			    if (p == ddcModes) ddcModes = p->next;

			    /* Add to used modes */
			    if (last) {
				last->next = p;
				p->prev = last;
			    } else {
				first = p;
				p->prev = NULL;
			    }
			    p->next = NULL;
			    last = p;

			    break;
			}
		    }
		}
	    }

	    /* 
	     * Add remaining DDC modes if they're smaller than the user
	     * specified modes
	     */
	    for (p = ddcModes; p; p = next) {
		next = p->next;
		if (p->HDisplay <= maxVirtX && p->VDisplay <= maxVirtY) {
		    /* Unhook from DDC modes */
		    if (p->prev) p->prev->next = p->next;
		    if (p->next) p->next->prev = p->prev;
		    if (p == ddcModes) ddcModes = p->next;

		    /* Add to used modes */
		    if (last) {
			last->next = p;
			p->prev = last;
		    } else {
			first = p;
			p->prev = NULL;
		    }
		    p->next = NULL;
		    last = p;
		}
	    }

	    /* Delete unused modes */
	    while (ddcModes)
		xf86DeleteMode(&ddcModes, ddcModes);
	} else {
	    /*
	     * No modes were configured, so we make the DDC modes
	     * available for the user to cycle through.
	     */
	    for (p = ddcModes; p; p = p->next)
		p->type |= M_T_USERDEF;
	}

	pScrn->virtualX = pScrn->display->virtualX = maxVirtX;
	pScrn->virtualY = pScrn->display->virtualY = maxVirtY;
    }

    /* Close the doubly-linked mode list, if we found any usable modes */
    if (last) {
	last->next   = first;
	first->prev  = last;
	pScrn->modes = first;
	RADEONSetPitch(pScrn);
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Total number of valid DDC mode(s) found: %d\n", count);

    return count;
}

/* This is used only when no mode is specified for FP and no ddc is
 * available.  We force it to native mode, if possible.
 */
static DisplayModePtr RADEONFPNativeMode(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr   info  = RADEONPTR(pScrn);
    DisplayModePtr  new   = NULL;
    char            stmp[32];

    if (info->PanelXRes != 0 &&
	info->PanelYRes != 0 &&
	info->DotClock != 0) {

	/* Add native panel size */
	new             = xnfcalloc(1, sizeof (DisplayModeRec));
	sprintf(stmp, "%dx%d", info->PanelXRes, info->PanelYRes);
	new->name       = xnfalloc(strlen(stmp) + 1);
	strcpy(new->name, stmp);
	new->HDisplay   = info->PanelXRes;
	new->VDisplay   = info->PanelYRes;

	new->HTotal     = new->HDisplay + info->HBlank;
	new->HSyncStart = new->HDisplay + info->HOverPlus;
	new->HSyncEnd   = new->HSyncStart + info->HSyncWidth;
	new->VTotal     = new->VDisplay + info->VBlank;
	new->VSyncStart = new->VDisplay + info->VOverPlus;
	new->VSyncEnd   = new->VSyncStart + info->VSyncWidth;

	new->Clock      = info->DotClock;
	new->Flags      = 0;
	new->type       = M_T_USERDEF;

	new->next       = NULL;
	new->prev       = NULL;

	pScrn->display->virtualX =
	    pScrn->virtualX = MAX(pScrn->virtualX, info->PanelXRes);
	pScrn->display->virtualY =
	    pScrn->virtualY = MAX(pScrn->virtualY, info->PanelYRes);

	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "No valid mode specified, force to native mdoe\n");
    }

    return new;
}

/* XFree86's xf86ValidateModes routine doesn't work well with DFPs, so
 * here is our own validation routine.
 */
static int RADEONValidateFPModes(ScrnInfoPtr pScrn, char **ppModeName)
{
    RADEONInfoPtr   info       = RADEONPTR(pScrn);
    DisplayModePtr  last       = NULL;
    DisplayModePtr  new        = NULL;
    DisplayModePtr  first      = NULL;
    int             count      = 0;
    int             i, width, height;

    pScrn->virtualX = pScrn->display->virtualX;
    pScrn->virtualY = pScrn->display->virtualY;

    /* We have a flat panel connected to the primary display, and we
     * don't have any DDC info.
     */
    for (i = 0; ppModeName[i] != NULL; i++) {
	/* FIXME: Use HDisplay and VDisplay instead of mode string */
	if (sscanf(ppModeName[i], "%dx%d", &width, &height) != 2) continue;

	/* Note: We allow all non-standard modes as long as they do not
	 * exceed the native resolution of the panel.  Since these modes
	 * need the internal RMX unit in the video chips (and there is
	 * only one per card), this will only apply to the primary head.
	 */
	if (width < 320 || width > info->PanelXRes ||
	    height < 200 || height > info->PanelYRes) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Mode %s is out of range.\n", ppModeName[i]);
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Valid modes must be between 320x200-%dx%d\n",
		       info->PanelXRes, info->PanelYRes);
	    continue;
	}

	new             = xnfcalloc(1, sizeof(DisplayModeRec));
	new->name       = xnfalloc(strlen(ppModeName[i]) + 1);
	strcpy(new->name, ppModeName[i]);
	new->HDisplay   = width;
	new->VDisplay   = height;

	/* These values are effective values after expansion They are
	 * not really used to set CRTC registers.
	 */
	new->HTotal     = info->PanelXRes + info->HBlank;
	new->HSyncStart = info->PanelXRes + info->HOverPlus;
	new->HSyncEnd   = new->HSyncStart + info->HSyncWidth;
	new->VTotal     = info->PanelYRes + info->VBlank;
	new->VSyncStart = info->PanelYRes + info->VOverPlus;
	new->VSyncEnd   = new->VSyncStart + info->VSyncWidth;	
	new->Clock      = info->DotClock;
	new->Flags     |= RADEON_USE_RMX;

	new->type      |= M_T_USERDEF;

	new->next       = NULL;
	new->prev       = last;

	if (last) last->next = new;
	last = new;
	if (!first) first = new;

	pScrn->display->virtualX =
	    pScrn->virtualX = MAX(pScrn->virtualX, width);
	pScrn->display->virtualY =
	    pScrn->virtualY = MAX(pScrn->virtualY, height);
	count++;
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Valid mode using on-chip RMX: %s\n", new->name);
    }

    /* If all else fails, add the native mode */
    if (!count) {
	first = last = RADEONFPNativeMode(pScrn);
	if (first) count = 1;
    }

    /* Close the doubly-linked mode list, if we found any usable modes */
    if (last) {
	last->next   = first;
	first->prev  = last;
	pScrn->modes = first;
	RADEONSetPitch(pScrn);
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Total number of valid FP mode(s) found: %d\n", count);

    return count;
}

/* This is called by RADEONPreInit to initialize gamma correction */
static Bool RADEONPreInitGamma(ScrnInfoPtr pScrn)
{
    Gamma  zeros = { 0.0, 0.0, 0.0 };

    if (!xf86SetGamma(pScrn, zeros)) return FALSE;
d1597 70
a1666 83
    MonPtr      mon = pScrn->monitor;
    xf86MonPtr  ddc = mon->DDC;
    int         i;

    if (flag) { /* HSync */
	for (i = 0; i < 4; i++) {
	    if (ddc->det_mon[i].type == DS_RANGES) {
		mon->nHsync = 1;
		mon->hsync[0].lo = ddc->det_mon[i].section.ranges.min_h;
		mon->hsync[0].hi = ddc->det_mon[i].section.ranges.max_h;
		return;
	    }
	}
	/* If no sync ranges detected in detailed timing table, let's
	 * try to derive them from supported VESA modes.  Are we doing
	 * too much here!!!?  */
	i = 0;
	if (ddc->timings1.t1 & 0x02) { /* 800x600@@56 */
	    mon->hsync[i].lo = mon->hsync[i].hi = 35.2;
	    i++;
	}
	if (ddc->timings1.t1 & 0x04) { /* 640x480@@75 */
	    mon->hsync[i].lo = mon->hsync[i].hi = 37.5;
	    i++;
	}
	if ((ddc->timings1.t1 & 0x08) || (ddc->timings1.t1 & 0x01)) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 37.9;
	    i++;
	}
	if (ddc->timings1.t2 & 0x40) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 46.9;
	    i++;
	}
	if ((ddc->timings1.t2 & 0x80) || (ddc->timings1.t2 & 0x08)) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 48.1;
	    i++;
	}
	if (ddc->timings1.t2 & 0x04) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 56.5;
	    i++;
	}
	if (ddc->timings1.t2 & 0x02) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 60.0;
	    i++;
	}
	if (ddc->timings1.t2 & 0x01) {
	    mon->hsync[i].lo = mon->hsync[i].hi = 64.0;
	    i++;
	}
	mon->nHsync = i;
    } else {  /* Vrefresh */
	for (i = 0; i < 4; i++) {
	    if (ddc->det_mon[i].type == DS_RANGES) {
		mon->nVrefresh = 1;
		mon->vrefresh[0].lo = ddc->det_mon[i].section.ranges.min_v;
		mon->vrefresh[0].hi = ddc->det_mon[i].section.ranges.max_v;
		return;
	    }
	}

	i = 0;
	if (ddc->timings1.t1 & 0x02) { /* 800x600@@56 */
	    mon->vrefresh[i].lo = mon->vrefresh[i].hi = 56;
	    i++;
	}
	if ((ddc->timings1.t1 & 0x01) || (ddc->timings1.t2 & 0x08)) {
	    mon->vrefresh[i].lo = mon->vrefresh[i].hi = 60;
	    i++;
	}
	if (ddc->timings1.t2 & 0x04) {
	    mon->vrefresh[i].lo = mon->vrefresh[i].hi = 70;
	    i++;
	}
	if ((ddc->timings1.t1 & 0x08) || (ddc->timings1.t2 & 0x80)) {
	    mon->vrefresh[i].lo = mon->vrefresh[i].hi = 72;
	    i++;
	}
	if ((ddc->timings1.t1 & 0x04) || (ddc->timings1.t2 & 0x40) ||
	    (ddc->timings1.t2 & 0x02) || (ddc->timings1.t2 & 0x01)) {
	    mon->vrefresh[i].lo = mon->vrefresh[i].hi = 75;
	    i++;
	}
	mon->nVrefresh = i;
d1668 47
a1714 91
}

static int RADEONValidateCloneModes(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr   info             = RADEONPTR(pScrn);
    ClockRangePtr   clockRanges;
    DisplayModePtr  tmp_mode         = NULL;
    DisplayModePtr  clone_mode, save_mode;
    int             modesFound       = 0;
    int             count            = 0;
    int             tmp_hdisplay     = 0;
    int             tmp_vdisplay     = 0;
    int             i, save_n_hsync, save_n_vrefresh;
    range           save_hsync, save_vrefresh;
    char           *s;
    char          **clone_mode_names = NULL;
    Bool            ddc_mode         = info->ddc_mode;

    /* Save all infomations that will be changed by clone mode validateion */
    save_mode = pScrn->modes;
    pScrn->modes = NULL;

    /* Clone display mode names, duplicate all mode names for primary
     * head.  Allocate one more, in case pScrn->display->modes[0] ==
     * NULL */
    while (pScrn->display->modes[count]) count++;
    clone_mode_names = xnfalloc((count+2) * sizeof(char*));
    for (i = 0; i < count; i++) {
	clone_mode_names[i] = xnfalloc(strlen(pScrn->display->modes[i]) + 1);
	strcpy(clone_mode_names[i], pScrn->display->modes[i]);
    }
    clone_mode_names[count]   = NULL;
    clone_mode_names[count+1] = NULL;

    pScrn->progClock = TRUE;

    clockRanges                    = xnfcalloc(sizeof(*clockRanges), 1);
    clockRanges->next              = NULL;
    clockRanges->minClock          = info->pll.min_pll_freq;
    clockRanges->maxClock          = info->pll.max_pll_freq * 10;
    clockRanges->clockIndex        = -1;
    clockRanges->interlaceAllowed  = FALSE;
    clockRanges->doubleScanAllowed = FALSE;

    /* Only take one clone mode from config file for now, rest of clone
     * modes will copy from primary head.
     */
    if ((s = xf86GetOptValString(info->Options, OPTION_CLONE_MODE))) {
	if (sscanf(s, "%dx%d", &tmp_hdisplay, &tmp_vdisplay) == 2) {
	    if(count > 0) free(clone_mode_names[0]);
	    else count++;
	    clone_mode_names[0] = xnfalloc(strlen(s)+1);
	    sprintf(clone_mode_names[0], "%dx%d", tmp_hdisplay, tmp_vdisplay);
	    xf86DrvMsg(0, X_INFO, "Clone mode %s in config file is used\n");
	}
    }

    if (pScrn->display->virtualX < tmp_hdisplay)
	pScrn->display->virtualX = tmp_hdisplay;
    if (pScrn->display->virtualY < tmp_vdisplay)
	pScrn->display->virtualY = tmp_vdisplay;

    save_hsync      = pScrn->monitor->hsync[0];
    save_vrefresh   = pScrn->monitor->vrefresh[0];
    save_n_hsync    = pScrn->monitor->nHsync;
    save_n_vrefresh = pScrn->monitor->nVrefresh;

    pScrn->monitor->DDC       = NULL;
    pScrn->monitor->nHsync    = 0;
    pScrn->monitor->nVrefresh = 0;

    if ((s = xf86GetOptValString(info->Options, OPTION_CLONE_HSYNC))) {
	if (sscanf(s, "%f-%f", &pScrn->monitor->hsync[0].lo,
		   &pScrn->monitor->hsync[0].hi) == 2) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "HSync for CloneMode from config file: %s\n", s);
	    pScrn->monitor->nHsync = 1;
	} else {
	    pScrn->monitor->nHsync = 0;
	}
    }

    if ((s = xf86GetOptValString(info->Options, OPTION_CLONE_VREFRESH))) {
	if (sscanf(s, "%f-%f", &pScrn->monitor->vrefresh[0].lo,
		   &pScrn->monitor->vrefresh[0].hi) == 2) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "VRefresh for CloneMode from config file: %s\n", s);
	    pScrn->monitor->nVrefresh = 1;
	} else {
	    pScrn->monitor->nVrefresh = 0;
	}
a1715 134

    if ((pScrn->monitor->nVrefresh == 0) || (pScrn->monitor->nHsync == 0) ||
	(info->CloneType != MT_CRT) || info->ddc_mode) {
	unsigned int  save_ddc_reg;
	save_ddc_reg = info->DDCReg;
	switch (info->CloneDDCType) {
	case DDC_MONID: info->DDCReg = RADEON_GPIO_MONID;    break;
	case DDC_DVI:   info->DDCReg = RADEON_GPIO_DVI_DDC;  break;
	case DDC_VGA:   info->DDCReg = RADEON_GPIO_VGA_DDC;  break;
	case DDC_CRT2:  info->DDCReg = RADEON_GPIO_CRT2_DDC; break;
	default:        info->DDCReg = 0;                    break;
	}
	
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "DDC detection (type %d) for clone modes\n",
		   info->CloneDDCType);

	/* When primary head has an invalid DDC type, I2C is not
         * initialized, so we do it here.
	 */
	if (!info->ddc2) info->ddc2 = xf86I2CBusInit(info->pI2CBus);

	pScrn->monitor->DDC = RADEONDoDDC(pScrn, NULL);
	if (pScrn->monitor->DDC) {
	    if (info->CloneType == MT_CRT) {
		if (pScrn->monitor->nHsync == 0)
		    RADEONSetSyncRangeFromEdid(pScrn, 1);
		if (pScrn->monitor->nVrefresh == 0)
		    RADEONSetSyncRangeFromEdid(pScrn, 0);
	    }
	} else if (info->ddc_mode) {
	    ddc_mode = FALSE;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "No DDC data available for clone mode, "
		       "DDCMode option is dismissed\n");
	}
	info->DDCReg = save_ddc_reg;
    }

    if (info->CloneType == MT_CRT && !ddc_mode) {
	modesFound =
	    xf86ValidateModes(pScrn, pScrn->monitor->Modes, 
			      clone_mode_names, 
			      clockRanges,
			      NULL,                     /* linePitches */
			      8 * 64,                   /* minPitch */
			      8 * 1024,                 /* maxPitch */
			      64 * pScrn->bitsPerPixel, /* pitchInc */
			      128,                      /* minHeight */
			      2048,                     /* maxHeight */
			      pScrn->display->virtualX,
			      pScrn->display->virtualY,
			      info->FbMapSize, 
			      LOOKUP_BEST_REFRESH);
    } else {
	/* Try to add DDC modes */
	info->IsSecondary = TRUE; /* Fake it */
	modesFound = RADEONValidateDDCModes(pScrn, clone_mode_names,
					    info->CloneType);
	info->IsSecondary = FALSE; /* Restore it!!! */

	/* If that fails and we're connect to a flat panel, then try to
         * add the flat panel modes
	 */
	if (modesFound < 1 && info->DisplayType != MT_CRT)
	    modesFound = RADEONValidateFPModes(pScrn, clone_mode_names);
    }

    if (modesFound > 0) {
	xf86SetCrtcForModes(pScrn, 0);
	xf86PrintModes(pScrn);
	for (i = 0; i < modesFound; i++) {
	    while (pScrn->modes->status != MODE_OK) {
		pScrn->modes = pScrn->modes->next;
	    }
	    if (!pScrn->modes) break;

	    clone_mode = xnfcalloc (1, sizeof (DisplayModeRec));
	    if (!clone_mode || !pScrn->modes) break;
	    memcpy(clone_mode, pScrn->modes, sizeof(DisplayModeRec));
	    clone_mode->name = xnfalloc(strlen(pScrn->modes->name) + 1);
	    strcpy(clone_mode->name, pScrn->modes->name);

	    if (i == 0) {
		info->CloneModes = clone_mode;
		info->CurCloneMode = clone_mode;
	    } else {
		clone_mode->prev = tmp_mode;
		clone_mode->prev->next = clone_mode;
	    }

	    tmp_mode = clone_mode;
	    clone_mode->next = NULL;
	    pScrn->modes = pScrn->modes->next;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Valid Clone Mode: %s\n", clone_mode->name);
	}
    }

    /* Clone_mode_names list is no longer needed, free it. */
    if (clone_mode_names) {
	for (i = 0; clone_mode_names[i]; i++) {
	    free(clone_mode_names[i]);
	    clone_mode_names[i] = NULL;
	}

	free(clone_mode_names);
	clone_mode_names = NULL;
    }

    /* We need to restore all changed info for the primary head */
    pScrn->modes = save_mode;

    pScrn->monitor->hsync[0]    = save_hsync;
    pScrn->monitor->vrefresh[0] = save_vrefresh;
    pScrn->monitor->nHsync      = save_n_hsync;
    pScrn->monitor->nVrefresh   = save_n_vrefresh;

    /*
     * Also delete the clockRanges (if it was setup) since it will be
     * set up during the primary head initialization.
     */
    while (pScrn->clockRanges) {
	ClockRangesPtr CRtmp = pScrn->clockRanges;
	pScrn->clockRanges = pScrn->clockRanges->next;
	xfree(CRtmp);
    }

    /* modePool is no longer needed, free it */
    while (pScrn->modePool)
	xf86DeleteMode(&pScrn->modePool, pScrn->modePool);
    pScrn->modePool = NULL;

    return modesFound;
d1718 7
a1724 8
/* This is called by RADEONPreInit to validate modes and compute
 * parameters for all of the valid modes.
 */
static Bool RADEONPreInitModes(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    ClockRangePtr  clockRanges;
    int            modesFound;
d1730 29
a1758 68
    /* This option has two purposes:
     *
     * 1. For CRT, if this option is on, xf86ValidateModes (to
     *    LOOKUP_BEST_REFRESH) is not going to be used for mode
     *    validation.  Instead, we'll validate modes by matching exactly
     *    the modes supported from the DDC data.  This option can be
     *    used (a) to enable non-standard modes listed in the Detailed
     *    Timings block of EDID, like 2048x1536 (not included in
     *    xf86DefModes), (b) to avoid unstable modes for some flat
     *    panels working in analog mode (some modes validated by
     *    xf86ValidateModes don't really work with these panels).
     *
     * 2. For DFP on primary head, with this option on, the validation
     *    routine will try to use supported modes from DDC data first
     *    before trying on-chip RMX streching.  By default, native mode
     *    + RMX streching is used for all non-native modes, it appears
     *    more reliable. Some non-native modes listed in the DDC data
     *    may not work properly if they are used directly. This seems to
     *    only happen to a few panels (haven't nailed this down yet, it
     *    may related to the incorrect setting in TMDS_PLL_CNTL when
     *    pixel clock is changed).  Use this option may give you better
     *    refresh rate for some non-native modes.  The 2nd DVI port will
     *    always use DDC modes directly (only have one on-chip RMX
     *    unit).
     *
     * Note: This option will be dismissed if no DDC data is available.
     */
    info->ddc_mode =
	xf86ReturnOptValBool(info->Options, OPTION_DDC_MODE, FALSE);

    /* Here is a hack for cloning first display on the second head.  If
     * we don't do this, when both heads are connected, the same CRTC
     * will be used to drive them according to the capability of the
     * primary head.  This can cause an unstable or blank screen, or
     * even worse it can damage a monitor.  This feature is also
     * important for laptops (using M6, M7), where the panel can't be
     * disconnect when one wants to use the CRT port.  Although 2
     * Screens can be set up in the config file for displaying same
     * content on two monitors, it has problems with cursor, overlay,
     * DRI.
     */
    if (info->HasCRTC2) {
	if (info->Clone) {
	    DevUnion     *pPriv;
	    RADEONEntPtr  pRADEONEnt;
	    pPriv = xf86GetEntityPrivate(pScrn->entityList[0],
					 gRADEONEntityIndex);
	    pRADEONEnt = pPriv->ptr;

	    /* If we have 2 screens from the config file, we don't need
	     * to do clone thing, let each screen handles one head.
	     */
	    if (!pRADEONEnt->HasSecondary) {
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "Clone modes validation ------------ \n");

		modesFound = RADEONValidateCloneModes(pScrn);
		if (modesFound < 1) {
		    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			       "No valid mode found for CRTC2 clone\n");
		    info->Clone = FALSE;
		    info->CurCloneMode = NULL;
		}
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			   "Total of %d clone modes found ------------ \n\n",
			   modesFound);
	    }
	}
a1760 11
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "Validating modes on %s head (DDCType: %d) ---------\n", 
	       info->IsSecondary ? "Secondary" : "Primary",
	       info->DDCType);

    pScrn->monitor->DDC = RADEONDoDDC(pScrn, pInt10);
    if (!pScrn->monitor->DDC && info->ddc_mode) {
	info->ddc_mode = FALSE;
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "No DDC data available, DDCMode option is dismissed\n");
    }
d1762 29
a1790 96
    if (pScrn->monitor->DDC) {
	/* If we still don't know sync range yet, let's try EDID.
	 *
	 * Note that, since we can have dual heads, Xconfigurator
	 * may not be able to probe both monitors correctly through
	 * vbe probe function (RADEONProbeDDC). Here we provide an
	 * additional way to auto-detect sync ranges if they haven't
	 * been added to XF86Config manually.
	 */
	if (pScrn->monitor->nHsync <= 0)
	    RADEONSetSyncRangeFromEdid(pScrn, 1);
	if (pScrn->monitor->nVrefresh <= 0)
	    RADEONSetSyncRangeFromEdid(pScrn, 0);
    }

    pScrn->progClock               = TRUE;

    clockRanges                    = xnfcalloc(sizeof(*clockRanges), 1);
    clockRanges->next              = NULL;
    clockRanges->minClock          = info->pll.min_pll_freq;
    clockRanges->maxClock          = info->pll.max_pll_freq * 10;
    clockRanges->clockIndex        = -1;
    clockRanges->interlaceAllowed  = (info->DisplayType == MT_CRT);
    clockRanges->doubleScanAllowed = (info->DisplayType == MT_CRT);

    /* We'll use our own mode validation routine for DFP/LCD, since
     * xf86ValidateModes does not work correctly with the DFP/LCD modes
     * 'stretched' from their native mode.
     */
    if (info->DisplayType == MT_CRT && !info->ddc_mode) {
	modesFound =
	    xf86ValidateModes(pScrn,
			      pScrn->monitor->Modes,
			      pScrn->display->modes,
			      clockRanges,
			      NULL,                  /* linePitches */
			      8 * 64,                /* minPitch */
			      8 * 1024,              /* maxPitch */
			      64 * pScrn->bitsPerPixel, /* pitchInc */
			      128,                   /* minHeight */
			      2048,                  /* maxHeight */
			      pScrn->display->virtualX,
			      pScrn->display->virtualY,
			      info->FbMapSize,
			      LOOKUP_BEST_REFRESH);

	if (modesFound < 1 && info->FBDev) {
	    fbdevHWUseBuildinMode(pScrn);
	    pScrn->displayWidth = pScrn->virtualX; /* FIXME: might be wrong */
	    modesFound = 1;
	}

	if (modesFound == -1) return FALSE;

	xf86PruneDriverModes(pScrn);
	if (!modesFound || !pScrn->modes) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes found\n");
	    return FALSE;
	}
    } else {
	/* First, free any allocated modes during configuration, since
	 * we don't need them
	 */
	while (pScrn->modes)
	    xf86DeleteMode(&pScrn->modes, pScrn->modes);
	while (pScrn->modePool)
	    xf86DeleteMode(&pScrn->modePool, pScrn->modePool);

	/* Next try to add DDC modes */
	modesFound = RADEONValidateDDCModes(pScrn, pScrn->display->modes,
					    info->DisplayType);

	/* If that fails and we're connect to a flat panel, then try to
         * add the flat panel modes
	 */
	if (modesFound < 1 && info->DisplayType != MT_CRT)
	    modesFound = RADEONValidateFPModes(pScrn, pScrn->display->modes);

	/* Fail if we still don't have any valid modes */
	if (modesFound < 1) {
	    if (info->DisplayType == MT_CRT) {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "No valid DDC modes found for this CRT\n");
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "Try turning off the \"DDCMode\" option\n");
	    } else {
		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			   "No valid mode found for this DFP/LCD\n");
	    }
	    return FALSE;
	}

	/* Setup the screen's clockRanges for the VidMode extension */
	pScrn->clockRanges = xnfcalloc(sizeof(*(pScrn->clockRanges)), 1);
	memcpy(pScrn->clockRanges, clockRanges, sizeof(*clockRanges));
	pScrn->clockRanges->strategy = LOOKUP_BEST_REFRESH;
a1791 1

d1793 3
d1797 12
a1808 17
    /* We need to adjust virtual size if the clone modes have larger
     * display size.
     */
    if (info->Clone && info->CloneModes) {
	DisplayModePtr  clone_mode = info->CloneModes;
	while (1) {
	    if ((clone_mode->HDisplay > pScrn->virtualX) ||
		(clone_mode->VDisplay > pScrn->virtualY)) {
		pScrn->virtualX =
		    pScrn->display->virtualX = clone_mode->HDisplay; 
		pScrn->virtualY =
		    pScrn->display->virtualY = clone_mode->VDisplay; 
		RADEONSetPitch(pScrn);
	    }
	    if (!clone_mode->next) break;
	    clone_mode = clone_mode->next;
	}
d1842 1
a1842 1
/* This is called by RADEONPreInit to initialize the hardware cursor */
d1845 1
a1845 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d1854 1
a1854 1
/* This is called by RADEONPreInit to initialize hardware acceleration */
d1857 1
a1857 2
#ifdef XFree86LOADER
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d1860 1
a1860 15
	int errmaj = 0, errmin = 0;

	info->xaaReq.majorversion = 1;
	info->xaaReq.minorversion = 1;

	if (!LoadSubModule(pScrn->module, "xaa", NULL, NULL, NULL,
			   &info->xaaReq, &errmaj, &errmin)) {
	    info->xaaReq.minorversion = 0;

	    if (!LoadSubModule(pScrn->module, "xaa", NULL, NULL, NULL,
			       &info->xaaReq, &errmaj, &errmin)) {
		LoaderErrorMsg(NULL, "xaa", errmaj, errmin);
		return FALSE;
	    }
	}
a1862 2
#endif

d1868 1
a1868 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d1880 1
d1884 1
a1884 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
a1897 1
    info->agpFastWrite  = RADEON_DEFAULT_AGP_FAST_WRITE;
a1912 10
	if ((info->agpFastWrite = xf86ReturnOptValBool(info->Options,
						       OPTION_AGP_FW,
						       FALSE))) {
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       "Enabling AGP Fast Write\n");
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, 
		       "AGP Fast Write disabled by default\n");
	}

a1923 1

a1982 24
    /* Two options to try and squeeze as much texture memory as possible
     * for dedicated 3d rendering boxes
     */
    info->noBackBuffer = xf86ReturnOptValBool(info->Options,
					      OPTION_NO_BACKBUFFER, 
					      FALSE);

    if (info->noBackBuffer) {
	info->allowPageFlip = 0;
    } else if (!xf86LoadSubModule(pScrn, "shadowfb")) {
	info->allowPageFlip = 0;
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Couldn't load shadowfb module:\n");
    } else {
	xf86LoaderReqSymLists(driShadowFBSymbols, NULL);

	info->allowPageFlip = xf86ReturnOptValBool(info->Options,
						   OPTION_PAGE_FLIP,
						   FALSE);
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Page flipping %sabled\n",
	       info->allowPageFlip ? "en" : "dis");

d1990 3
a1992 3
    vbeInfoPtr  pVbe;

    if (xf86LoadSubModule(pScrn, "vbe")) {
d1998 128
a2125 1
/* RADEONPreInit is called once at server startup */
d2128 33
a2160 4
    RADEONInfoPtr     info;
    xf86Int10InfoPtr  pInt10 = NULL;
    void *int10_save = NULL;
    
a2167 5
    info->Clone        = FALSE;
    info->CurCloneMode = NULL;
    info->CloneModes   = NULL;
    info->IsSwitching  = FALSE;

d2171 1
a2171 38
    info->PciInfo = xf86GetPciInfoForEntity(info->pEnt->index);
    info->PciTag  = pciTag(info->PciInfo->bus,
			   info->PciInfo->device,
			   info->PciInfo->func);

#if !defined(__alpha__)
    if (xf86GetPciDomain(info->PciTag) ||
	!xf86IsPrimaryPci(info->PciInfo))
	RADEONPreInt10Save(pScrn, &int10_save);
#else
    /* [Alpha] On the primary, the console already ran the BIOS and we're
     *         going to run it again - so make sure to "fix up" the card
     *         so that (1) we can read the BIOS ROM and (2) the BIOS will
     *         get the memory config right.
     */         
    RADEONPreInt10Save(pScrn, &int10_save);
#endif

    if (xf86IsEntityShared(pScrn->entityList[0])) {
	if (xf86IsPrimInitDone(pScrn->entityList[0])) {
	    DevUnion     *pPriv;
	    RADEONEntPtr  pRADEONEnt;

	    info->IsSecondary = TRUE;
	    pPriv = xf86GetEntityPrivate(pScrn->entityList[0],
					 gRADEONEntityIndex);
	    pRADEONEnt = pPriv->ptr;
	    if (pRADEONEnt->BypassSecondary) {
		pRADEONEnt->HasSecondary = FALSE;
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "Only one monitor detected, Second screen "
			   "will NOT be created\n");
		return FALSE;
	    }
	    pRADEONEnt->pSecondaryScrn = pScrn;
	} else {
	    DevUnion     *pPriv;
	    RADEONEntPtr  pRADEONEnt;
d2173 28
a2200 11
	    xf86SetPrimInitDone(pScrn->entityList[0]);
	    pPriv = xf86GetEntityPrivate(pScrn->entityList[0],
					 gRADEONEntityIndex);

	    pRADEONEnt = pPriv->ptr;
	    pRADEONEnt->pPrimaryScrn        = pScrn;
	    pRADEONEnt->IsDRIEnabled        = FALSE;
	    pRADEONEnt->BypassSecondary     = FALSE;
	    pRADEONEnt->RestorePrimary      = FALSE;
	    pRADEONEnt->IsSecondaryRestored = FALSE;
	}
d2203 2
a2204 1
    if (flags & PROBE_DETECT) {
d2206 1
a2206 1
	RADEONPostInt10Check(pScrn, int10_save);
d2212 2
a2213 1
    if (!vgaHWGetHWRec(pScrn)) {
d2220 5
d2231 2
a2232 5
    if (xf86RegisterResources(info->pEnt->index, 0, ResExclusive))
	goto fail;

    if (xf86SetOperatingState(resVga, info->pEnt->index, ResUnusedOpr))
	goto fail;
d2234 1
a2234 1
    pScrn->racMemFlags = RAC_FB | RAC_COLORMAP | RAC_VIEWPORT | RAC_CURSOR;
d2237 1
a2237 2
    if (!RADEONPreInitVisual(pScrn))
	goto fail;
d2242 1
a2242 3
    if (!(info->Options = xalloc(sizeof(RADEONOptions))))
	goto fail;

d2246 1
a2246 2
    if (!RADEONPreInitWeight(pScrn))
	goto fail;
d2248 4
a2251 6
    if (xf86GetOptValInteger(info->Options, OPTION_VIDEO_KEY,
			     &(info->videoKey))) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "video key set to 0x%x\n",
		   info->videoKey);
    } else {
	info->videoKey = 0x1E;
d2254 9
a2262 2
    if (xf86ReturnOptValBool(info->Options, OPTION_FBDEV, FALSE)) {
	/* check for Linux framebuffer device */
d2264 9
a2272 16
	if (xf86LoadSubModule(pScrn, "fbdevhw")) {
	    xf86LoaderReqSymLists(fbdevHWSymbols, NULL);

	    if (fbdevHWInit(pScrn, info->PciInfo, NULL)) {
		pScrn->ValidMode     = fbdevHWValidMode;
		info->FBDev = TRUE;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			   "Using framebuffer device\n");
	    } else {
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			   "fbdevHWInit failed, not using framebuffer device\n");
	    }
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Couldn't load fbdevhw module, not using framebuffer device\n");
	}
d2276 1
a2276 2
	if (!RADEONPreInitInt10(pScrn, &pInt10))
	    goto fail;
d2278 1
a2278 1
    RADEONPostInt10Check(pScrn, int10_save);
d2280 1
a2280 2
    if (!RADEONPreInitConfig(pScrn))
	goto fail;
d2283 1
a2283 2
    if (!RADEONGetBIOSParameters(pScrn, pInt10))
	goto fail;
d2285 3
a2287 2
    /* Force type to CRT since we currently can't read BIOS to tell us
     * what kind of heads we have.
d2293 6
d2300 1
a2300 1
    if (!RADEONGetPLLParameters(pScrn))          goto fail;
d2304 1
a2304 1
    if (!RADEONPreInitModes(pScrn, pInt10))      goto fail;
a2312 1

d2314 2
a2315 1
    if (info->VBIOS) {
d2325 2
a2326 2
	       "For information on using the multimedia capabilities\n of this"
	       " adapter, please see http://gatos.sf.net.\n");
d2334 2
a2335 1
    if (info->VBIOS) {
d2349 1
a2349 1
/* Load a palette */
d2353 1
a2353 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d2355 10
a2364 18
    int            i;
    int            idx, j;
    unsigned char  r, g, b;

#ifdef XF86DRI
    if (info->CPStarted) DRILock(pScrn->pScreen, 0);
#endif

    if (info->accelOn) info->accel->Sync(pScrn);

    if (info->FBDev) {
	fbdevHWLoadPalette(pScrn, numColors, indices, colors, pVisual);
    } else {
	/* If the second monitor is connected, we also need to deal with
	 * the secondary palette
	 */
	if (info->IsSecondary) j = 1;
	else j = 0;
d2366 30
a2395 6
	PAL_SELECT(j);

	if (info->CurrentLayout.depth == 15) {
	    /* 15bpp mode.  This sends 32 values. */
	    for (i = 0; i < numColors; i++) {
		idx = indices[i];
d2397 1
a2397 1
		g   = colors[idx].green;
d2399 1
a2401 37
	} else if (info->CurrentLayout.depth == 16) {
	    /* 16bpp mode.  This sends 64 values.
	     *
	     * There are twice as many green values as there are values
	     * for red and blue.  So, we take each red and blue pair,
	     * and combine it with each of the two green values.
	     */
	    for (i = 0; i < numColors; i++) {
		idx = indices[i];
		r   = colors[idx / 2].red;
		g   = colors[idx].green;
		b   = colors[idx / 2].blue;
		RADEONWaitForFifo(pScrn, 32); /* delay */
		OUTPAL(idx * 4, r, g, b);

		/* AH - Added to write extra green data - How come this isn't
		 * needed on R128?  We didn't load the extra green data in the
		 * other routine
		 */
		if (idx <= 31) {
		    r   = colors[idx].red;
		    g   = colors[(idx * 2) + 1].green;
		    b   = colors[idx].blue;
		    RADEONWaitForFifo(pScrn, 32); /* delay */
		    OUTPAL(idx * 8, r, g, b);
		}
	    }
	} else {
	    /* 8bpp mode.  This sends 256 values. */
	    for (i = 0; i < numColors; i++) {
		idx = indices[i];
		r   = colors[idx].red;
		b   = colors[idx].blue;
		g   = colors[idx].green;
		RADEONWaitForFifo(pScrn, 32); /* delay */
		OUTPAL(idx, r, g, b);
	    }
d2403 10
a2412 47

	if (info->Clone) {
	    PAL_SELECT(1);
	    if (info->CurrentLayout.depth == 15) {
		/* 15bpp mode.  This sends 32 values. */
		for (i = 0; i < numColors; i++) {
		    idx = indices[i];
		    r   = colors[idx].red;
		    g   = colors[idx].green;
		    b   = colors[idx].blue;
		    OUTPAL(idx * 8, r, g, b);
		}
	    } else if (info->CurrentLayout.depth == 16) {
		/* 16bpp mode.  This sends 64 values.
		 *
		 * There are twice as many green values as there are values
		 * for red and blue.  So, we take each red and blue pair,
		 * and combine it with each of the two green values.
		 */
		for (i = 0; i < numColors; i++) {
		    idx = indices[i];
		    r   = colors[idx / 2].red;
		    g   = colors[idx].green;
		    b   = colors[idx / 2].blue;
		    OUTPAL(idx * 4, r, g, b);
		    
		    /* AH - Added to write extra green data - How come
		     * this isn't needed on R128?  We didn't load the
		     * extra green data in the other routine.
		     */
		    if (idx <= 31) {
			r   = colors[idx].red;
			g   = colors[(idx * 2) + 1].green;
			b   = colors[idx].blue;
			OUTPAL(idx * 8, r, g, b);
		    }
		}
	    } else {
		/* 8bpp mode.  This sends 256 values. */
		for (i = 0; i < numColors; i++) {
		    idx = indices[i];
		    r   = colors[idx].red;
		    b   = colors[idx].blue;
		    g   = colors[idx].green;
		    OUTPAL(idx, r, g, b);
		}
	    }
a2414 4

#ifdef XF86DRI
    if (info->CPStarted) DRIUnlock(pScrn->pScreen);
#endif
d2417 2
a2418 2
static void RADEONBlockHandler(int i, pointer blockData,
			       pointer pTimeout, pointer pReadmask)
d2420 3
a2422 3
    ScreenPtr      pScreen = screenInfo.screens[i];
    ScrnInfoPtr    pScrn   = xf86Screens[i];
    RADEONInfoPtr  info    = RADEONPTR(pScrn);
d2426 1
a2426 1
	FLUSH_RING();
d2433 3
a2435 2
    if (info->VideoTimerCallback)
	(*info->VideoTimerCallback)(pScrn, currentTime.milliseconds);
d2441 4
a2444 4
    ScrnInfoPtr    pScrn = xf86Screens[pScreen->myNum];
    RADEONInfoPtr  info  = RADEONPTR(pScrn);
    BoxRec         MemBox;
    int            y2;
a2451 2
    info->CPStarted    = FALSE;
    info->directRenderingEnabled = FALSE;
a2452 1
    info->accelOn      = FALSE;
d2454 1
a2454 1
    if (info->IsSecondary) pScrn->fbOffset = pScrn->videoRam * 1024;
d2458 2
a2459 2
    info->fbX = 0;
    info->fbY = 0;
d2463 1
a2467 1

a2476 9

    if (info->CurCloneMode) {
	info->CloneFrameX0 =
	    (pScrn->virtualX - info->CurCloneMode->HDisplay) / 2;
	info->CloneFrameY0 =
	    (pScrn->virtualY - info->CurCloneMode->VDisplay) / 2;
	RADEONDoAdjustFrame(pScrn, info->CloneFrameX0, info->CloneFrameY0, TRUE);
    }

d2493 5
a2497 6
	 * buffers, we will want to revisit the following check for 3
	 * times the virtual size of the screen below.
	 */
	int  width_bytes = (pScrn->displayWidth *
			    info->CurrentLayout.pixel_bytes);
	int  maxy        = info->FbMapSize / width_bytes;
d2510 1
a2510 1
	} else if (info->ChipFamily >= CHIP_FAMILY_R300) {
d2513 1
a2513 2
		       "Direct rendering not yet supported on "
		       "Radeon 9500/9700 and newer cards\n");
d2515 27
a2541 27
	    if (info->IsSecondary)
		info->directRenderingEnabled = FALSE;
	    else {
		/* Xinerama has sync problem with DRI, disable it for now */
		if (xf86IsEntityShared(pScrn->entityList[0])) {
		    info->directRenderingEnabled = FALSE;
	            xf86DrvMsg(scrnIndex, X_WARNING,
			       "Direct Rendering Disabled -- "
			       "Dual-head configuration is not working with "
			       "DRI at present.\n"
			       "Please use only one Device/Screen "
			       "section in your XFConfig file.\n");
		} else {
		    info->directRenderingEnabled =
			RADEONDRIScreenInit(pScreen);
		}

		if (xf86IsEntityShared(pScrn->entityList[0])) {
		    DevUnion     *pPriv;
		    RADEONEntPtr  pRADEONEnt;

		    pPriv = xf86GetEntityPrivate(pScrn->entityList[0],
						 gRADEONEntityIndex);
		    pRADEONEnt = pPriv->ptr;
		    pRADEONEnt->IsDRIEnabled = info->directRenderingEnabled;
		}
	    }
d2547 4
a2550 4
    if (!fbScreenInit(pScreen, info->FB,
		      pScrn->virtualX, pScrn->virtualY,
		      pScrn->xDpi, pScrn->yDpi, pScrn->displayWidth,
		      pScrn->bitsPerPixel))
a2577 1

d2581 1
a2581 1
	VisualPtr  visual;
a2594 1

d2596 1
a2596 1
    /* Must be after RGB order fixed */
a2599 14
#ifdef RENDER
    if (PictureGetSubpixelOrder (pScreen) == SubPixelUnknown)
    {
	int subPixelOrder;

	switch (info->DisplayType) {
	case MT_NONE:	subPixelOrder = SubPixelUnknown; break;
	case MT_LCD:	subPixelOrder = SubPixelHorizontalRGB; break;
	case MT_DFP:	subPixelOrder = SubPixelHorizontalRGB; break;
	default:	subPixelOrder = SubPixelNone; break;
	}
	PictureSetSubpixelOrder (pScreen, subPixelOrder);
    }
#endif
d2603 8
a2610 12
	FBAreaPtr  fbarea;
	int        width_bytes = (pScrn->displayWidth *
				  info->CurrentLayout.pixel_bytes);
	int        cpp         = info->CurrentLayout.pixel_bytes;
	int        bufferSize  = ((pScrn->virtualY * width_bytes
				   + RADEON_BUFFER_ALIGN)
				  & ~RADEON_BUFFER_ALIGN);
	int        depthSize   = ((((pScrn->virtualY+15) & ~15) * width_bytes
				   + RADEON_BUFFER_ALIGN)
				  & ~RADEON_BUFFER_ALIGN);
	int        l;
	int        scanlines;
d2640 1
a2640 1
	info->textureSize = info->FbMapSize - 5 * bufferSize - depthSize;
d2648 1
a2648 1
	    info->textureSize = info->FbMapSize - 4 * bufferSize - depthSize;
d2651 1
a2651 6
 	    info->textureSize = info->FbMapSize - 3 * bufferSize - depthSize;
	}
	/* If there's still no space for textures, try without pixmap cache */
	if (info->textureSize < 0) {
	    info->textureSize = info->FbMapSize - 2 * bufferSize - depthSize
				- 64/4*64;
d2656 1
a2656 1
	if ((int)info->FbMapSize - 8192*width_bytes - bufferSize - depthSize
d2659 1
a2659 6
		info->FbMapSize - 8192*width_bytes - bufferSize - depthSize;
	}

	/* If backbuffer is disabled, don't allocate memory for it */
	if (info->noBackBuffer) {
	   info->textureSize += bufferSize;
d2685 8
a2692 10
	info->textureOffset = ((info->FbMapSize - info->textureSize +
				RADEON_BUFFER_ALIGN) &
			       ~(CARD32)RADEON_BUFFER_ALIGN);

				/* Reserve space for the shared depth
                                 * buffer.
				 */
	info->depthOffset = ((info->textureOffset - depthSize +
			      RADEON_BUFFER_ALIGN) &
			     ~(CARD32)RADEON_BUFFER_ALIGN);
d2696 4
a2699 12
	if (info->noBackBuffer) {
	   info->backOffset = info->depthOffset;
	   info->backPitch = pScrn->displayWidth;
	} else {
	   info->backOffset = ((info->depthOffset - bufferSize +
				RADEON_BUFFER_ALIGN) &
			       ~(CARD32)RADEON_BUFFER_ALIGN);
	   info->backPitch = pScrn->displayWidth;
	}

	info->backY = info->backOffset / width_bytes;
	info->backX = (info->backOffset - (info->backY * width_bytes)) / cpp;
d2701 1
a2701 1
	scanlines = info->FbMapSize / width_bytes;
d2711 1
a2711 2
		       "Memory manager initialization to "
		       "(%d,%d) (%d,%d) failed\n",
d2715 1
a2715 1
	    int  width, height;
d2722 1
a2722 2
						    2, 0, NULL, NULL,
						    NULL))) {
a2734 15

		/* Lines in offscreen area needed for depth buffer and
		 * textures
		 */
		info->depthTexLines = (scanlines
				       - info->depthOffset / width_bytes);
		info->backLines	    = (scanlines
				       - info->backOffset / width_bytes
				       - info->depthTexLines);
		info->backArea	    = NULL;
	    } else {
		xf86DrvMsg(scrnIndex, X_ERROR,
			   "Unable to determine largest offscreen area "
			   "available\n");
		return FALSE;
d2739 1
a2739 1
		   "Will use back buffer at offset 0x%x\n",
d2742 1
a2742 1
		   "Will use depth buffer at offset 0x%x\n",
d2745 1
a2745 1
		   "Will use %d kb for textures at offset 0x%x\n",
d2756 2
a2757 1
    } else
d2776 1
a2776 2
		       "Memory manager initialization to "
		       "(%d,%d) (%d,%d) failed\n",
d2786 2
a2787 4
	    if ((fbarea = xf86AllocateOffscreenArea(pScreen,
						    pScrn->displayWidth,
						    2, 0, NULL, NULL,
						    NULL))) {
d2803 6
a2814 4

	    /* FIXME: Figure out why this was added because it shouldn't be! */
	    /* This is needed by the DRI and XAA code for shared entities */
	    pScrn->pScreen = pScreen;
a2828 7
				/* Backing store setup */
    miInitializeBackingStore(pScreen);
    xf86SetBackingStore(pScreen);

				/* Set Silken Mouse */
    xf86SetSilkenMouse(pScreen);

d2835 1
a2835 1
	    int  width, height;
d2839 1
a2839 2
		       info->cursor_start / pScrn->displayWidth
		       / info->CurrentLayout.pixel_bytes);
a2851 1
	info->cursor_start = 0;
d2858 2
a2859 1
			     RADEONLoadPalette, NULL,
d2861 1
d2865 1
a2865 1
			     | CMAP_RELOAD_ON_MODE_SWITCH)) return FALSE;
d2869 2
a2870 1
    xf86DPMSInit(pScreen, RADEONDisplayPowerManagementSet, 0);
a2873 1

d2906 1
a2906 1
/* Write common registers (initialized to 0) */
d2910 1
a2910 47
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    OUTREG(RADEON_OVR_CLR,            restore->ovr_clr);
    OUTREG(RADEON_OVR_WID_LEFT_RIGHT, restore->ovr_wid_left_right);
    OUTREG(RADEON_OVR_WID_TOP_BOTTOM, restore->ovr_wid_top_bottom);
    OUTREG(RADEON_OV0_SCALE_CNTL,     restore->ov0_scale_cntl);
    OUTREG(RADEON_SUBPIC_CNTL,        restore->subpic_cntl);
    OUTREG(RADEON_VIPH_CONTROL,       restore->viph_control);
    OUTREG(RADEON_I2C_CNTL_1,         restore->i2c_cntl_1);
    OUTREG(RADEON_GEN_INT_CNTL,       restore->gen_int_cntl);
    OUTREG(RADEON_CAP0_TRIG_CNTL,     restore->cap0_trig_cntl);
    OUTREG(RADEON_CAP1_TRIG_CNTL,     restore->cap1_trig_cntl);
    OUTREG(RADEON_BUS_CNTL,           restore->bus_cntl);
    OUTREG(RADEON_SURFACE_CNTL,       restore->surface_cntl);

    /* Workaround for the VT switching problem in dual-head mode.  This
     * problem only occurs on RV style chips, typically when a FP and
     * CRT are connected.
     */
    if (info->HasCRTC2 &&
	!info->IsSwitching &&
	info->ChipFamily != CHIP_FAMILY_R200 &&
	info->ChipFamily != CHIP_FAMILY_R300) {
	DevUnion     *pPriv;
	RADEONEntPtr  pRADEONEnt;
	CARD32        tmp;

	pPriv = xf86GetEntityPrivate(pScrn->entityList[0], gRADEONEntityIndex);
	pRADEONEnt = pPriv->ptr;

	if (pRADEONEnt->HasSecondary || info->Clone) {
	    tmp = INREG(RADEON_DAC_CNTL2);
	    OUTREG(RADEON_DAC_CNTL2, tmp & ~RADEON_DAC2_DAC_CLK_SEL);
	    usleep(100000);
	}
    }
}

/* Write miscellaneous registers which might have been destroyed by an fbdevHW
 * call
 */
static void RADEONRestoreFBDevRegisters(ScrnInfoPtr pScrn,
					 RADEONSavePtr restore)
{
#ifdef XF86DRI
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d2913 14
a2926 13
    /* Restore register for vertical blank interrupts */
    if (info->irq) {
	OUTREG(RADEON_GEN_INT_CNTL, restore->gen_int_cntl);
    }

    /* Restore registers for page flipping */
    if (info->allowPageFlip) {
	OUTREG(RADEON_CRTC_OFFSET_CNTL, restore->crtc_offset_cntl);
	if (info->HasCRTC2) {
	    OUTREG(RADEON_CRTC2_OFFSET_CNTL, restore->crtc2_offset_cntl);
	}
    }
#endif
d2929 1
a2929 1
/* Write CRTC registers */
d2933 1
a2933 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d2936 1
a2936 1
    OUTREG(RADEON_CRTC_GEN_CNTL, restore->crtc_gen_cntl);
d2938 1
a2938 2
    OUTREGP(RADEON_CRTC_EXT_CNTL,
	    restore->crtc_ext_cntl,
d2943 1
a2943 2
    OUTREGP(RADEON_DAC_CNTL,
	    restore->dac_cntl,
d2956 1
a2956 1
/* Write CRTC2 registers */
d2958 1
a2958 1
					RADEONSavePtr restore)
d2960 1
a2960 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d2963 2
a2964 2
    OUTREGP(RADEON_CRTC2_GEN_CNTL,
	    restore->crtc2_gen_cntl,
d2970 1
a2970 14

    if (info->ChipFamily == CHIP_FAMILY_R200 ||
	info->ChipFamily == CHIP_FAMILY_R300) {
	OUTREG(RADEON_DISP_OUTPUT_CNTL, restore->disp_output_cntl);
    } else {
	OUTREG(RADEON_DISP_HW_DEBUG, restore->disp_hw_debug);
	if (info->IsDell) {
	    /* Workaround for DELL card. BIOS doesn't initialize
	     * TV_DAC_CNTL to a correct value which causes too high
	     * contrast for the second CRT (using TV_DAC).
	     */
	    OUTREG(RADEON_TV_DAC_CNTL, 0x00280203);
	}
    }
a2979 10
    if (info->DisplayType == MT_DFP || info->CloneType == MT_DFP) {	
	OUTREG(RADEON_FP_H2_SYNC_STRT_WID, restore->fp2_h_sync_strt_wid);
	OUTREG(RADEON_FP_V2_SYNC_STRT_WID, restore->fp2_v_sync_strt_wid);
	OUTREG(RADEON_FP2_GEN_CNTL,        restore->fp2_gen_cntl);
    }

#if 0
    /* Hack for restoring text mode -- fixed elsewhere */
    usleep(100000);
#endif
d2982 1
d2986 1
a2986 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d2988 1
a2988 1
    unsigned long  tmp;
d2994 1
a2994 1
    OUTREG(RADEON_TMDS_PLL_CNTL,        restore->tmds_pll_cntl);
d2999 21
a3019 4
    if (info->DisplayType == MT_LCD) {
	tmp = INREG(RADEON_LVDS_GEN_CNTL);
	if ((tmp & (RADEON_LVDS_ON | RADEON_LVDS_BLON)) ==
	    (restore->lvds_gen_cntl & (RADEON_LVDS_ON | RADEON_LVDS_BLON))) {
a3020 10
	} else {
	    if (restore->lvds_gen_cntl & (RADEON_LVDS_ON | RADEON_LVDS_BLON)) {
		usleep(RADEONPTR(pScrn)->PanelPwrDly * 1000);
		OUTREG(RADEON_LVDS_GEN_CNTL, restore->lvds_gen_cntl);
	    } else {
		OUTREG(RADEON_LVDS_GEN_CNTL,
		       restore->lvds_gen_cntl | RADEON_LVDS_BLON);
		usleep(RADEONPTR(pScrn)->PanelPwrDly * 1000);
		OUTREG(RADEON_LVDS_GEN_CNTL, restore->lvds_gen_cntl);
	    }
d3023 1
d3026 1
d3029 1
a3029 10
    int i = 0;

    /* FIXME: Certain revisions of R300 can't recover here.  Not sure of
       the cause yet, but this workaround will mask the problem for now.
       Other chips usually will pass at the very first test, so the
       workaround shouldn't have any effect on them. */
    for (i = 0;
	 (i < 10000 &&
	  INPLL(pScrn, RADEON_PPLL_REF_DIV) & RADEON_PPLL_ATOMIC_UPDATE_R);
	 i++);
d3034 1
a3034 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3037 1
a3037 19
    while (INPLL(pScrn, RADEON_PPLL_REF_DIV) & RADEON_PPLL_ATOMIC_UPDATE_R);

    OUTPLLP(pScrn, RADEON_PPLL_REF_DIV,
	    RADEON_PPLL_ATOMIC_UPDATE_W,
	    ~(RADEON_PPLL_ATOMIC_UPDATE_W));
}

static void RADEONPLL2WaitForReadUpdateComplete(ScrnInfoPtr pScrn)
{
    int i = 0;

    /* FIXME: Certain revisions of R300 can't recover here.  Not sure of
       the cause yet, but this workaround will mask the problem for now.
       Other chips usually will pass at the very first test, so the
       workaround shouldn't have any effect on them. */
    for (i = 0;
	 (i < 10000 &&
	  INPLL(pScrn, RADEON_P2PLL_REF_DIV) & RADEON_P2PLL_ATOMIC_UPDATE_R);
	 i++);
d3039 1
d3041 2
a3042 1
static void RADEONPLL2WriteUpdate(ScrnInfoPtr pScrn)
d3044 1
a3044 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3047 1
a3047 1
    while (INPLL(pScrn, RADEON_P2PLL_REF_DIV) & RADEON_P2PLL_ATOMIC_UPDATE_R);
d3049 8
a3056 15
    OUTPLLP(pScrn, RADEON_P2PLL_REF_DIV,
	    RADEON_P2PLL_ATOMIC_UPDATE_W,
	    ~(RADEON_P2PLL_ATOMIC_UPDATE_W));
}

/* Write PLL registers */
static void RADEONRestorePLLRegisters(ScrnInfoPtr pScrn,
				      RADEONSavePtr restore)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    OUTPLLP(pScrn, RADEON_VCLK_ECP_CNTL,
	    RADEON_VCLK_SRC_SEL_CPUCLK,
	    ~(RADEON_VCLK_SRC_SEL_MASK));
d3058 1
d3064 13
a3076 23
	    ~(RADEON_PPLL_RESET
	      | RADEON_PPLL_ATOMIC_UPDATE_EN
	      | RADEON_PPLL_VGA_ATOMIC_UPDATE_EN));

    OUTREGP(RADEON_CLOCK_CNTL_INDEX,
	    RADEON_PLL_DIV_SEL,
	    ~(RADEON_PLL_DIV_SEL));

    if (info->ChipFamily == CHIP_FAMILY_R300) {
	if (restore->ppll_ref_div & R300_PPLL_REF_DIV_ACC_MASK) {
	    /* When restoring console mode, use saved PPLL_REF_DIV
	     * setting.
	     */
	    OUTPLLP(pScrn, RADEON_PPLL_REF_DIV,
		    restore->ppll_ref_div,
		    0);
	} else {
	    /* R300 uses ref_div_acc field as real ref divider */
	    OUTPLLP(pScrn, RADEON_PPLL_REF_DIV,
		    (restore->ppll_ref_div << R300_PPLL_REF_DIV_ACC_SHIFT), 
		    ~R300_PPLL_REF_DIV_ACC_MASK);
	}
    } else {
d3078 1
a3078 2
		restore->ppll_ref_div,
		~RADEON_PPLL_REF_DIV_MASK);
d3080 3
d3084 11
a3094 3
    OUTPLLP(pScrn, RADEON_PPLL_DIV_3,
	    restore->ppll_div_3,
	    ~RADEON_PPLL_FB3_DIV_MASK);
d3096 11
a3106 3
    OUTPLLP(pScrn, RADEON_PPLL_DIV_3,
	    restore->ppll_div_3,
	    ~RADEON_PPLL_POST3_DIV_MASK);
d3108 1
a3108 1
    RADEONPLLWriteUpdate(pScrn);
d3110 1
a3110 1

d3112 3
d3116 1
a3116 6
    OUTPLLP(pScrn, RADEON_PPLL_CNTL,
	    0,
	    ~(RADEON_PPLL_RESET
	      | RADEON_PPLL_SLEEP
	      | RADEON_PPLL_ATOMIC_UPDATE_EN
	      | RADEON_PPLL_VGA_ATOMIC_UPDATE_EN));
d3128 1
a3128 1
    usleep(5000); /* Let the clock to lock */
a3129 3
    OUTPLLP(pScrn, RADEON_VCLK_ECP_CNTL,
	    RADEON_VCLK_SRC_SEL_PPLLCLK,
	    ~(RADEON_VCLK_SRC_SEL_MASK));
d3133 2
a3134 3
/* Write PLL2 registers */
static void RADEONRestorePLL2Registers(ScrnInfoPtr pScrn,
				       RADEONSavePtr restore)
d3136 1
a3136 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3139 11
a3149 3
    OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL,
	    RADEON_PIX2CLK_SRC_SEL_CPUCLK,
	    ~(RADEON_PIX2CLK_SRC_SEL_MASK));
d3151 1
d3157 31
a3187 15
	    ~(RADEON_P2PLL_RESET
	      | RADEON_P2PLL_ATOMIC_UPDATE_EN
	      | RADEON_P2PLL_VGA_ATOMIC_UPDATE_EN));

    OUTPLLP(pScrn, RADEON_P2PLL_REF_DIV,
	    restore->p2pll_ref_div,
	    ~RADEON_P2PLL_REF_DIV_MASK);

    OUTPLLP(pScrn, RADEON_P2PLL_DIV_0,
	    restore->p2pll_div_0,
	    ~RADEON_P2PLL_FB0_DIV_MASK);

    OUTPLLP(pScrn, RADEON_P2PLL_DIV_0,
	    restore->p2pll_div_0,
	    ~RADEON_P2PLL_POST0_DIV_MASK);
d3189 11
a3199 2
    RADEONPLL2WriteUpdate(pScrn);
    RADEONPLL2WaitForReadUpdateComplete(pScrn);
d3201 3
d3205 3
d3209 2
a3210 6
    OUTPLLP(pScrn, RADEON_P2PLL_CNTL,
	    0,
	    ~(RADEON_P2PLL_RESET
	      | RADEON_P2PLL_SLEEP
	      | RADEON_P2PLL_ATOMIC_UPDATE_EN
	      | RADEON_P2PLL_VGA_ATOMIC_UPDATE_EN));
d3219 7
a3225 2
	       restore->p2pll_div_0 & RADEON_P2PLL_FB0_DIV_MASK,
	       (restore->p2pll_div_0 & RADEON_P2PLL_POST0_DIV_MASK) >>16));
d3227 5
a3231 1
    usleep(5000); /* Let the clock to lock */
d3233 2
a3234 3
    OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL,
	    RADEON_PIX2CLK_SRC_SEL_P2PLLCLK,
	    ~(RADEON_PIX2CLK_SRC_SEL_MASK));
d3238 1
a3238 1
/* Write palette data */
d3241 1
a3241 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3243 1
a3243 1
    int            i;
d3263 3
a3265 2
/* Write out state to define a new video mode */
static void RADEONRestoreMode(ScrnInfoPtr pScrn, RADEONSavePtr restore)
d3267 19
a3285 16
    RADEONInfoPtr         info = RADEONPTR(pScrn);
    DevUnion             *pPriv;
    RADEONEntPtr          pRADEONEnt;
    static RADEONSaveRec  restore0;

    /* For Non-dual head card, we don't have private field in the Entity */
    if (!info->HasCRTC2) {
	RADEONRestoreCommonRegisters(pScrn, restore);
	RADEONRestoreCrtcRegisters(pScrn, restore);
	if ((info->DisplayType == MT_DFP) ||
	    (info->DisplayType == MT_LCD)) {
	    RADEONRestoreFPRegisters(pScrn, restore);
	}
	RADEONRestorePLLRegisters(pScrn, restore);
	return;
    }
d3287 2
a3288 1
    pPriv = xf86GetEntityPrivate(pScrn->entityList[0], gRADEONEntityIndex);
d3290 1
a3290 1

d3293 32
a3324 28
    /* When changing mode with Dual-head card, care must be taken for
     * the special order in setting registers. CRTC2 has to be set
     * before changing CRTC_EXT register.  In the dual-head setup, X
     * server calls this routine twice with primary and secondary pScrn
     * pointers respectively. The calls can come with different
     * order. Regardless the order of X server issuing the calls, we
     * have to ensure we set registers in the right order!!!  Otherwise
     * we may get a blank screen.
     */
    if (info->IsSecondary) {
	if (!pRADEONEnt->RestorePrimary)
	    RADEONRestoreCommonRegisters(pScrn, restore);
	RADEONRestoreCrtc2Registers(pScrn, restore);
	RADEONRestorePLL2Registers(pScrn, restore);

	if(info->IsSwitching) return;

	pRADEONEnt->IsSecondaryRestored = TRUE;

	if (pRADEONEnt->RestorePrimary) {
	    RADEONInfoPtr info0 = RADEONPTR(pRADEONEnt->pPrimaryScrn);
	    pRADEONEnt->RestorePrimary = FALSE;

	    RADEONRestoreCrtcRegisters(pScrn, &restore0);
	    if ((info0->DisplayType == MT_DFP) ||
		(info0->DisplayType == MT_LCD)) {
		RADEONRestoreFPRegisters(pScrn, &restore0);
	    }
d3326 9
a3334 1
	    RADEONRestorePLLRegisters(pScrn, &restore0);
d3336 14
a3349 4
	}
    } else {
	if (!pRADEONEnt->IsSecondaryRestored)
	    RADEONRestoreCommonRegisters(pScrn, restore);
d3351 6
a3356 19
	if (info->Clone) {
	    RADEONRestoreCrtc2Registers(pScrn, restore);
	    RADEONRestorePLL2Registers(pScrn, restore);
	}

	if (!pRADEONEnt->HasSecondary || pRADEONEnt->IsSecondaryRestored ||
	    info->IsSwitching) {
	    pRADEONEnt->IsSecondaryRestored = FALSE;

	    RADEONRestoreCrtcRegisters(pScrn, restore);
	    if ((info->DisplayType == MT_DFP) ||
		(info->DisplayType == MT_LCD)) {
		RADEONRestoreFPRegisters(pScrn, restore);
	    }
	    RADEONRestorePLLRegisters(pScrn, restore);
	} else {
	    memcpy(&restore0, restore, sizeof(restore0));
	    pRADEONEnt->RestorePrimary = TRUE;
	}
d3358 1
d3365 1
a3365 1
/* Read common registers */
d3368 1
a3368 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3375 2
d3387 1
a3387 23
/* Read miscellaneous registers which might be destroyed by an fbdevHW call */
static void RADEONSaveFBDevRegisters(ScrnInfoPtr pScrn, RADEONSavePtr save)
{
#ifdef XF86DRI
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;

    /* Save register for vertical blank interrupts */
    if (info->irq) {
	save->gen_int_cntl = INREG(RADEON_GEN_INT_CNTL);
    }

    /* Save registers for page flipping */
    if (info->allowPageFlip) {
	save->crtc_offset_cntl = INREG(RADEON_CRTC_OFFSET_CNTL);
	if (info->HasCRTC2) {
	    save->crtc2_offset_cntl = INREG(RADEON_CRTC2_OFFSET_CNTL);
	}
    }
#endif
}

/* Read CRTC registers */
d3390 1
a3390 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3403 1
d3406 1
d3410 1
a3410 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3422 1
a3422 1
    save->tmds_pll_cntl        = INREG(RADEON_TMDS_PLL_CNTL);
d3425 3
a3427 2
/* Read CRTC2 registers */
static void RADEONSaveCrtc2Registers(ScrnInfoPtr pScrn, RADEONSavePtr save)
d3429 1
a3429 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
a3433 1
    save->disp_hw_debug         = INREG (RADEON_DISP_HW_DEBUG);
a3442 5

    save->fp2_h_sync_strt_wid   = INREG (RADEON_FP_H2_SYNC_STRT_WID);
    save->fp2_v_sync_strt_wid   = INREG (RADEON_FP_V2_SYNC_STRT_WID);
    save->fp2_gen_cntl          = INREG (RADEON_FP2_GEN_CNTL);

d3445 1
a3445 1
/* Read PLL registers */
d3448 3
a3450 3
    save->ppll_ref_div = INPLL(pScrn, RADEON_PPLL_REF_DIV);
    save->ppll_div_3   = INPLL(pScrn, RADEON_PPLL_DIV_3);
    save->htotal_cntl  = INPLL(pScrn, RADEON_HTOTAL_CNTL);
d3453 3
a3455 3
		 save->ppll_ref_div,
		 save->ppll_div_3,
		 save->htotal_cntl));
d3457 3
a3459 3
		 save->ppll_ref_div & RADEON_PPLL_REF_DIV_MASK,
		 save->ppll_div_3 & RADEON_PPLL_FB3_DIV_MASK,
		 (save->ppll_div_3 & RADEON_PPLL_POST3_DIV_MASK) >> 16));
d3462 1
a3462 1
/* Read PLL registers */
d3465 3
a3467 3
    save->p2pll_ref_div = INPLL(pScrn, RADEON_P2PLL_REF_DIV);
    save->p2pll_div_0   = INPLL(pScrn, RADEON_P2PLL_DIV_0);
    save->htotal_cntl2  = INPLL(pScrn, RADEON_HTOTAL2_CNTL);
d3470 3
a3472 3
		 save->p2pll_ref_div,
		 save->p2pll_div_0,
		 save->htotal_cntl2));
d3474 13
a3486 3
		 save->p2pll_ref_div & RADEON_P2PLL_REF_DIV_MASK,
		 save->p2pll_div_0 & RADEON_P2PLL_FB0_DIV_MASK,
		 (save->p2pll_div_0 & RADEON_P2PLL_POST0_DIV_MASK) >> 16));
d3489 1
a3489 1
/* Read palette data */
d3492 1
a3492 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3494 1
a3494 1
    int            i;
d3498 1
a3498 1
 /* if (info->Port1 == MT_DFP) PAL_SELECT(1); */
d3509 1
a3509 1
/* Save state that defines current video mode */
d3512 1
a3512 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d3515 17
a3531 18
    if (info->IsSecondary) {
	RADEONSaveCrtc2Registers(pScrn, save);
	RADEONSavePLL2Registers(pScrn, save);
    } else {
	RADEONSavePLLRegisters(pScrn, save);
	RADEONSaveCommonRegisters(pScrn, save);
	RADEONSaveCrtcRegisters(pScrn, save);

	if ((info->DisplayType == MT_DFP) ||
	    (info->DisplayType == MT_LCD)) {
	    RADEONSaveFPRegisters(pScrn, save);
	}

	if (info->Clone) {
	    RADEONSaveCrtc2Registers(pScrn, save);
	    RADEONSavePLL2Registers(pScrn, save);
	}
     /* RADEONSavePalette(pScrn, save); */
a3532 1

d3536 1
a3536 1
/* Save everything needed to restore the original VC state */
d3539 1
a3539 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3541 2
a3542 2
    RADEONSavePtr  save       = &info->SavedReg;
    vgaHWPtr       hwp        = VGAHWPTR(pScrn);
d3550 3
a3552 2
    if (!info->IsSecondary) {
	vgaHWUnlock(hwp);
d3554 5
a3558 5
	/* temporary hack to prevent crashing on PowerMacs when trying to
	 * read VGA fonts and colormap, will find a better solution
	 * in the future
	 */
	vgaHWSave(pScrn, &hwp->SavedReg, VGA_SR_MODE); /* Save mode only */
d3560 8
a3567 9
	vgaHWSave(pScrn, &hwp->SavedReg, VGA_SR_ALL); /* Save mode
						       * & fonts & cmap
						       */
#endif
	vgaHWLock(hwp);
	save->dp_datatype      = INREG(RADEON_DP_DATATYPE);
	save->rbbm_soft_reset  = INREG(RADEON_RBBM_SOFT_RESET);
	save->clock_cntl_index = INREG(RADEON_CLOCK_CNTL_INDEX);
	if (info->R300CGWorkaround) R300CGWorkaround(pScrn);
d3569 1
a3569 1

d3573 1
a3573 1
/* Restore the original (text) mode */
d3576 1
a3576 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d3578 2
a3579 2
    RADEONSavePtr  restore    = &info->SavedReg;
    vgaHWPtr       hwp        = VGAHWPTR(pScrn);
a3581 6

#if X_BYTE_ORDER == X_BIG_ENDIAN
    RADEONWaitForFifo(pScrn, 1);
    OUTREG(RADEON_RBBM_GUICNTL, RADEON_HOST_DATA_SWAP_NONE);
#endif

d3588 2
a3590 1
    if (info->R300CGWorkaround) R300CGWorkaround(pScrn);
a3593 1
#if 0
d3595 3
a3597 6
     * This is fixed elsewhere and will be removed in the future.
     */
    if ((xf86IsEntityShared(pScrn->entityList[0]) || info->Clone)
	&& info->IsM6)
	OUTREG(RADEON_DAC_CNTL2, restore->dac2_cntl);
#endif
a3600 1
#if 0
d3602 3
a3604 4
     * some systems, the console can either hang or the fonts can be
     * corrupted.  This hack solves the problem 99% of the time.  A
     * correct fix is being worked on.
     */
a3605 1
#endif
d3607 3
a3609 2
    if (!info->IsSecondary) {
	vgaHWUnlock(hwp);
d3611 4
a3614 4
	/* Temporary hack to prevent crashing on PowerMacs when trying to
	 * write VGA fonts, will find a better solution in the future
	 */
	vgaHWRestore(pScrn, &hwp->SavedReg, VGA_SR_MODE );
d3616 1
a3616 1
	vgaHWRestore(pScrn, &hwp->SavedReg, VGA_SR_ALL );
d3618 18
a3635 16
	vgaHWLock(hwp);
    } else {
	DevUnion     *pPriv;
	RADEONEntPtr  pRADEONEnt;
	ScrnInfoPtr   pScrn0;
	vgaHWPtr      hwp0;

	pPriv = xf86GetEntityPrivate(pScrn->entityList[0],
				     gRADEONEntityIndex);
	pRADEONEnt = pPriv->ptr;

	pScrn0 = pRADEONEnt->pPrimaryScrn;
	hwp0   = VGAHWPTR(pScrn0);
	vgaHWUnlock(hwp0);
	vgaHWRestore(pScrn0, &hwp0->SavedReg, VGA_SR_MODE | VGA_SR_FONTS );
	vgaHWLock(hwp0);
d3644 2
a3645 1
/* Define common registers for requested video mode */
d3652 2
d3669 1
a3669 1
/* Define CRTC registers for requested video mode */
d3673 8
a3680 10
    unsigned char *RADEONMMIO = info->MMIO;

    int  format;
    int  hsync_start;
    int  hsync_wid;
    int  hsync_fudge;
    int  vsync_wid;
    int  bytpp;
    int  hsync_fudge_default[] = { 0x00, 0x12, 0x09, 0x09, 0x06, 0x05 };
    int  hsync_fudge_fp[]      = { 0x02, 0x02, 0x00, 0x00, 0x05, 0x05 };
d3691 1
a3691 2
		   "Unsupported pixel depth (%d)\n",
		   info->CurrentLayout.bitsPerPixel);
d3696 2
a3697 2
    if ((info->DisplayType == MT_DFP) ||
	(info->DisplayType == MT_LCD)) {
d3699 2
a3700 17
	if (mode->Flags & RADEON_USE_RMX) {
#if 0
	    mode->CrtcHDisplay   = info->PanelXRes;
	    mode->CrtcVDisplay   = info->PanelYRes;
#endif
	    mode->CrtcHTotal     = mode->CrtcHDisplay + info->HBlank;
	    mode->CrtcHSyncStart = mode->CrtcHDisplay + info->HOverPlus;
	    mode->CrtcHSyncEnd   = mode->CrtcHSyncStart + info->HSyncWidth;
	    mode->CrtcVTotal     = mode->CrtcVDisplay + info->VBlank;
	    mode->CrtcVSyncStart = mode->CrtcVDisplay + info->VOverPlus;
	    mode->CrtcVSyncEnd   = mode->CrtcVSyncStart + info->VSyncWidth;
	    mode->Clock          = info->DotClock;
	    mode->Flags          = info->Flags | RADEON_USE_RMX;
	}
    } else {
	hsync_fudge = hsync_fudge_default[format-1];
    }
d3703 39
a3741 22
			   | RADEON_CRTC_EN
			   | (format << 8)
			   | ((mode->Flags & V_DBLSCAN)
			      ? RADEON_CRTC_DBL_SCAN_EN
			      : 0)
			   | ((mode->Flags & V_CSYNC)
			      ? RADEON_CRTC_CSYNC_EN
			      : 0)
			   | ((mode->Flags & V_INTERLACE)
			      ? RADEON_CRTC_INTERLACE_EN
			      : 0));

    if ((info->DisplayType == MT_DFP) ||
	(info->DisplayType == MT_LCD)) {
	save->crtc_ext_cntl = RADEON_VGA_ATI_LINEAR | RADEON_XCRT_CNT_EN;
	save->crtc_gen_cntl &= ~(RADEON_CRTC_DBL_SCAN_EN |
				 RADEON_CRTC_CSYNC_EN |
				 RADEON_CRTC_INTERLACE_EN);
    } else {
	save->crtc_ext_cntl = (RADEON_VGA_ATI_LINEAR |
			       RADEON_XCRT_CNT_EN |
			       RADEON_CRTC_CRT_ON);
a3742 5

    save->dac_cntl = (RADEON_DAC_MASK_ALL
		      | RADEON_DAC_VGA_ADR_EN
		      | (info->dac6bits ? 0 : RADEON_DAC_8BIT_EN));

d3744 1
a3744 2
			       | ((((mode->CrtcHDisplay / 8) - 1) & 0x1ff)
				  << 16));
d3747 2
a3748 1
    if (!hsync_wid) hsync_wid = 1;
d3752 5
a3756 5
				  | ((hsync_wid & 0x3f) << 16)
				  | ((mode->Flags & V_NHSYNC)
				     ? RADEON_CRTC_H_SYNC_POL
				     : 0));

d3760 1
a3760 1
			       | ((mode->CrtcVDisplay - 1) << 16));
d3763 1
a3763 2
				 * does -- is this correct?
				 */
d3765 3
a3767 3
			       | ((mode->CrtcVDisplay
				   * ((mode->Flags & V_DBLSCAN) ? 2 : 1) - 1)
				  << 16));
d3771 2
a3772 1
    if (!vsync_wid) vsync_wid = 1;
d3775 4
a3778 4
				  | ((vsync_wid & 0x1f) << 16)
				  | ((mode->Flags & V_NVSYNC)
				     ? RADEON_CRTC_V_SYNC_POL
				     : 0));
d3781 1
a3781 1
    save->crtc_offset_cntl = INREG(RADEON_CRTC_OFFSET_CNTL);
d3783 3
a3785 3
    save->crtc_pitch  = (((pScrn->displayWidth * pScrn->bitsPerPixel) +
			  ((pScrn->bitsPerPixel * 8) -1)) /
			 (pScrn->bitsPerPixel * 8));
d3788 1
a3788 2
    save->surface_cntl = 0;

d3791 6
a3796 7
    case 16:
	save->surface_cntl |= RADEON_NONSURF_AP0_SWP_16BPP;
	break;

    case 32:
	save->surface_cntl |= RADEON_NONSURF_AP0_SWP_32BPP;
	break;
d3806 1
a3806 1
/* Define CRTC2 registers for requested video mode */
d3808 1
a3808 1
				     DisplayModePtr mode, RADEONInfoPtr info)
d3810 7
a3816 9
    unsigned char *RADEONMMIO = info->MMIO;

    int  format;
    int  hsync_start;
    int  hsync_wid;
    int  hsync_fudge;
    int  vsync_wid;
    int  bytpp;
    int  hsync_fudge_default[] = { 0x00, 0x12, 0x09, 0x09, 0x06, 0x05 };
d3827 1
a3827 2
		   "Unsupported pixel depth (%d)\n",
		   info->CurrentLayout.bitsPerPixel);
d3835 17
a3851 37
			    | RADEON_CRTC2_CRT2_ON
			    | (format << 8)
			    | ((mode->Flags & V_DBLSCAN)
			       ? RADEON_CRTC2_DBL_SCAN_EN
			       : 0)
			    | ((mode->Flags & V_CSYNC)
			       ? RADEON_CRTC2_CSYNC_EN
			       : 0)
			    | ((mode->Flags & V_INTERLACE)
			       ? RADEON_CRTC2_INTERLACE_EN
			       : 0));

    /* Turn CRT on in case the first head is a DFP */
    save->crtc_ext_cntl |= RADEON_CRTC_CRT_ON;
    save->dac2_cntl = info->SavedReg.dac2_cntl;
    if (info->ChipFamily == CHIP_FAMILY_R200 ||
	info->ChipFamily == CHIP_FAMILY_R300) {
	save->disp_output_cntl =
	    ((info->SavedReg.disp_output_cntl
	      & ~(CARD32)RADEON_DISP_DAC_SOURCE_MASK)
	     | RADEON_DISP_DAC_SOURCE_CRTC2);
    } else {
	save->disp_hw_debug = info->SavedReg.disp_hw_debug;
	if (info->IsDell && info->DellType == 2) {
	    if (info->DisplayType == MT_CRT || info->CloneType == MT_CRT) {
		/* Turn on 2nd CRT */
		save->dac2_cntl &= ~RADEON_DAC2_DAC_CLK_SEL;
		save->dac2_cntl |= RADEON_DAC2_DAC2_CLK_SEL;
		save->disp_hw_debug &= ~RADEON_CRT2_DISP1_SEL; 

		/* This will make 2nd CRT stay on in console */
		info->SavedReg.dac2_cntl = save->dac2_cntl;
		info->SavedReg.disp_hw_debug |= RADEON_CRT2_DISP1_SEL;
		info->SavedReg.crtc2_gen_cntl |= RADEON_CRTC2_CRT2_ON;
	    }
	} else save->dac2_cntl |= RADEON_DAC2_DAC_CLK_SEL;
    }
d3853 2
a3854 3
    save->crtc2_h_total_disp =
	((((mode->CrtcHTotal / 8) - 1) & 0x3ff)
	 | ((((mode->CrtcHDisplay / 8) - 1) & 0x1ff) << 16));
d3857 2
a3858 1
    if (!hsync_wid) hsync_wid = 1;
d3862 4
a3865 4
				   | ((hsync_wid & 0x3f) << 16)
				   | ((mode->Flags & V_NHSYNC)
				      ? RADEON_CRTC_H_SYNC_POL
				      : 0));
d3870 1
a3870 1
				| ((mode->CrtcVDisplay - 1) << 16));
d3873 1
a3873 2
				 * does -- is this correct?
				 */
d3875 3
a3877 3
				| ((mode->CrtcVDisplay
				    * ((mode->Flags & V_DBLSCAN) ? 2 : 1) - 1)
				   << 16));
d3881 2
a3882 1
    if (!vsync_wid) vsync_wid = 1;
d3885 4
a3888 4
				   | ((vsync_wid & 0x1f) << 16)
				   | ((mode->Flags & V_NVSYNC)
				      ? RADEON_CRTC2_V_SYNC_POL
				      : 0));
d3891 1
a3891 1
    save->crtc2_offset_cntl = INREG(RADEON_CRTC2_OFFSET_CNTL);
d3893 3
a3895 3
    save->crtc2_pitch  = (((pScrn->displayWidth * pScrn->bitsPerPixel) +
			   ((pScrn->bitsPerPixel * 8) -1)) /
			  (pScrn->bitsPerPixel * 8));
d3897 1
a3897 34

    if (info->DisplayType == MT_DFP || info->CloneType == MT_DFP) {
	save->crtc2_gen_cntl      = (RADEON_CRTC2_EN | (format << 8));
	save->fp2_h_sync_strt_wid = save->crtc2_h_sync_strt_wid;
	save->fp2_v_sync_strt_wid = save->crtc2_v_sync_strt_wid;
	save->fp2_gen_cntl        = (RADEON_FP2_SEL_CRTC2 |
				     RADEON_FP2_PANEL_FORMAT |
				     RADEON_FP2_ON);

	if (pScrn->rgbBits == 8) 
	    save->fp2_gen_cntl |= RADEON_FP2_PANEL_FORMAT; /* 24 bit format */
	else
	    save->fp2_gen_cntl &= ~RADEON_FP2_PANEL_FORMAT;/* 18 bit format */

	/* FIXME: When there are two DFPs, the 2nd DFP is driven by the
	 *        external TMDS transmitter.  It may have a problem at
	 *        high dot clock for certain panels.  Since we don't
	 *        know how to control the external TMDS transmitter, not
	 *        much we can do here.
	 */
#if 0
	if (save->dot_clock_freq > 15000)
	    save->tmds_pll_cntl = 0xA3F;
	else if(save->tmds_pll_cntl != 0xA3F)
	    save->tmds_pll_cntl = info->SavedReg.tmds_pll_cntl;
#endif

	/* If BIOS has not turned it on, we'll keep it on so that we'll
	 * have a valid VGA screen even after X quits or VT is switched
	 * to the console mode.
	 */
	info->SavedReg.fp2_gen_cntl = RADEON_FP2_ON;
    }

a3900 1

d3904 2
a3905 1
/* Define CRTC registers for requested video mode */
d3910 3
a3912 3
    int    xres = mode->HDisplay;
    int    yres = mode->VDisplay;
    float  Hratio, Vratio;
d3914 9
a3922 6
    if (info->PanelXRes == 0 || info->PanelYRes == 0) {
	Hratio = 1.0;
	Vratio = 1.0;
    } else {
	if (xres > info->PanelXRes) xres = info->PanelXRes;
	if (yres > info->PanelYRes) yres = info->PanelYRes;
d3924 2
a3925 2
	Hratio = (float)xres/(float)info->PanelXRes;
	Vratio = (float)yres/(float)info->PanelYRes;
d3928 4
a3931 3
    if (Hratio == 1.0 || !(mode->Flags & RADEON_USE_RMX)) {
	save->fp_horz_stretch = orig->fp_horz_stretch;
	save->fp_horz_stretch &= ~(RADEON_HORZ_STRETCH_BLEND |
a3932 18
	save->fp_horz_stretch &= ~(RADEON_HORZ_AUTO_RATIO |
				   RADEON_HORZ_PANEL_SIZE);
	save->fp_horz_stretch |= ((xres/8-1)<<16);

    } else {
	save->fp_horz_stretch =
	    ((((unsigned long)(Hratio * RADEON_HORZ_STRETCH_RATIO_MAX +
			       0.5)) & RADEON_HORZ_STRETCH_RATIO_MASK)) |
	    (orig->fp_horz_stretch & (RADEON_HORZ_PANEL_SIZE |
				      RADEON_HORZ_FP_LOOP_STRETCH |
				      RADEON_HORZ_AUTO_RATIO_INC));
	save->fp_horz_stretch |= (RADEON_HORZ_STRETCH_BLEND |
				  RADEON_HORZ_STRETCH_ENABLE);

	save->fp_horz_stretch &= ~(RADEON_HORZ_AUTO_RATIO |
				   RADEON_HORZ_PANEL_SIZE);
	save->fp_horz_stretch |= ((info->PanelXRes / 8 - 1) << 16);

d3934 12
d3947 9
a3955 9
    if (Vratio == 1.0 || !(mode->Flags & RADEON_USE_RMX)) {
	save->fp_vert_stretch = orig->fp_vert_stretch;
	save->fp_vert_stretch &= ~(RADEON_VERT_STRETCH_ENABLE|
				   RADEON_VERT_STRETCH_BLEND);
	save->fp_vert_stretch &= ~(RADEON_VERT_AUTO_RATIO_EN |
				   RADEON_VERT_PANEL_SIZE);
	save->fp_vert_stretch |= ((yres-1) << 12);
    } else {
	save->fp_vert_stretch =
d3957 5
a3961 10
				0.5)) & RADEON_VERT_STRETCH_RATIO_MASK)) |
	     (orig->fp_vert_stretch & (RADEON_VERT_PANEL_SIZE |
				       RADEON_VERT_STRETCH_RESERVED)));
	save->fp_vert_stretch |= (RADEON_VERT_STRETCH_ENABLE |
				  RADEON_VERT_STRETCH_BLEND);

	save->fp_vert_stretch &= ~(RADEON_VERT_AUTO_RATIO_EN |
				   RADEON_VERT_PANEL_SIZE);
	save->fp_vert_stretch |= ((info->PanelYRes-1) << 12);

d3963 1
d3966 14
a3979 10
			 ~(RADEON_FP_SEL_CRTC2 |
			   RADEON_FP_RMX_HVSYNC_CONTROL_EN |
			   RADEON_FP_DFP_SYNC_SEL |
			   RADEON_FP_CRT_SYNC_SEL |
			   RADEON_FP_CRTC_LOCK_8DOT |
			   RADEON_FP_USE_SHADOW_EN |
			   RADEON_FP_CRTC_USE_SHADOW_VEND |
			   RADEON_FP_CRT_SYNC_ALT));
    save->fp_gen_cntl |= (RADEON_FP_CRTC_DONT_SHADOW_VPAR |
			  RADEON_FP_CRTC_DONT_SHADOW_HEND );
d3981 2
a3982 4
    if (pScrn->rgbBits == 8) 
        save->fp_gen_cntl |= RADEON_FP_PANEL_FORMAT;  /* 24 bit format */
    else
        save->fp_gen_cntl &= ~RADEON_FP_PANEL_FORMAT;/* 18 bit format */
d3984 4
a3987 17
    save->lvds_gen_cntl = orig->lvds_gen_cntl;
    save->lvds_pll_cntl = orig->lvds_pll_cntl;

    /* This is needed for some panel at high resolution (>=1600x1200) 
     */
    if ((save->dot_clock_freq > 15000) &&
	(info->ChipFamily != CHIP_FAMILY_R300))
	save->tmds_pll_cntl = 0xA3F;
    else
	save->tmds_pll_cntl = orig->tmds_pll_cntl;

    info->PanelOff = FALSE;
    /* This option is used to force the ONLY DEVICE in XFConfig to use
     * CRT port, instead of default DVI port.
     */
    if (xf86ReturnOptValBool(info->Options, OPTION_PANEL_OFF, FALSE)) {
	info->PanelOff = TRUE;
d3989 2
d3992 4
a3995 18
    if (info->PanelOff && info->Clone) {
	info->OverlayOnCRTC2 = TRUE;
	if (info->DisplayType == MT_LCD) {
	    /* Turning off LVDS_ON seems to make panel white blooming.
	     * For now we just turn off display data ???
	     */
	    save->lvds_gen_cntl |= (RADEON_LVDS_ON | RADEON_LVDS_DISPLAY_DIS);
	    save->lvds_gen_cntl &= ~(RADEON_LVDS_BLON);

	} else if (info->DisplayType == MT_DFP)
	    save->fp_gen_cntl &= ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN);
    } else {
	if (info->DisplayType == MT_LCD) {
	    save->lvds_gen_cntl |= (RADEON_LVDS_ON | RADEON_LVDS_BLON);
	    save->fp_gen_cntl   &= ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN);
	} else if (info->DisplayType == MT_DFP)
	    save->fp_gen_cntl   |= (RADEON_FP_FPON | RADEON_FP_TMDS_EN);
    }
a3996 4
    save->fp_crtc_h_total_disp = save->crtc_h_total_disp;
    save->fp_crtc_v_total_disp = save->crtc_v_total_disp;
    save->fp_h_sync_strt_wid   = save->crtc_h_sync_strt_wid;
    save->fp_v_sync_strt_wid   = save->crtc_v_sync_strt_wid;
d3999 1
a3999 1
/* Define PLL registers for requested video mode */
d4003 1
a4003 2
    unsigned long  freq = dot_clock * 100;

d4007 2
a4008 1
    } *post_div, post_divs[]   = {
d4010 3
a4012 4
				 * Reference Manual (Technical Reference
				 * Manual P/N RRG-G04100-C Rev. 0.04), page
				 * 3-17 (PLL_DIV_[3:0]).
				 */
d4050 1
a4050 1
/* Define PLL2 registers for requested video mode */
d4052 1
a4052 1
				    double dot_clock)
d4054 1
a4054 2
    unsigned long  freq = dot_clock * 100;

d4058 2
a4059 1
    } *post_div, post_divs[]   = {
d4061 3
a4063 4
				 * Reference Manual (Technical Reference
				 * Manual P/N RRG-G04100-C Rev. 0.04), page
				 * 3-17 (PLL_DIV_[3:0]).
				 */
d4069 1
d4086 2
a4087 2
				       * save->pll_output_freq_2,
				       pll->reference_freq);
d4096 68
a4163 4
    save->p2pll_ref_div    = pll->reference_div;
    save->p2pll_div_0      = (save->feedback_div_2 |
			      (post_div->bitvalue << 16));
    save->htotal_cntl2     = 0;
d4166 1
a4166 1
#if 0
d4168 2
a4169 2
 * anything for XFree86 4.0.
 */
d4174 1
a4174 1
#endif
d4176 1
a4176 1
/* Define registers for a requested video mode */
d4180 2
a4181 2
    RADEONInfoPtr  info      = RADEONPTR(pScrn);
    double         dot_clock = mode->Clock/1000.0;
a4199 1
    if (mode->Flags & V_CSYNC)     ErrorF(" C");
a4221 1
    if (mode->Flags & V_CSYNC)     ErrorF(" C");
d4232 30
a4261 16
    if (info->IsSecondary) {
	if (!RADEONInitCrtc2Registers(pScrn, save, mode, info))
	    return FALSE;
	RADEONInitPLL2Registers(save, &info->pll, dot_clock);
    } else {
	RADEONInitCommonRegisters(save, info);
	if (!RADEONInitCrtcRegisters(pScrn, save, mode, info))
	    return FALSE;
	dot_clock = mode->Clock/1000.0;
	if (dot_clock) {
	    RADEONInitPLLRegisters(save, &info->pll, dot_clock);
	} else {
	    save->ppll_ref_div = info->SavedReg.ppll_ref_div;
	    save->ppll_div_3   = info->SavedReg.ppll_div_3;
	    save->htotal_cntl  = info->SavedReg.htotal_cntl;
	}
a4262 8
	if (info->Clone && info->CurCloneMode) {
	    RADEONInitCrtc2Registers(pScrn, save, info->CurCloneMode, info);
	    dot_clock = info->CurCloneMode->Clock / 1000.0;
	    RADEONInitPLL2Registers(save, &info->pll, dot_clock);
	}
	/* Not used for now: */
     /* if (!info->PaletteSavedOnVT) RADEONInitPalette(save); */
    }
d4264 4
a4267 3
    if (((info->DisplayType == MT_DFP) ||
	 (info->DisplayType == MT_LCD))) {
	RADEONInitFPRegisters(pScrn, &info->SavedReg, save, mode, info);
d4274 1
a4274 1
/* Initialize a new mode */
d4277 1
a4277 1
    RADEONInfoPtr  info = RADEONPTR(pScrn);
d4280 1
d4293 2
a4294 2
    ScrnInfoPtr  pScrn = xf86Screens[pScreen->myNum];
    Bool         unblank;
d4297 2
a4298 1
    if (unblank) SetTimeSinceLastInputEvent();
d4301 4
a4304 2
	if (unblank)  RADEONUnblank(pScrn);
	else          RADEONBlank(pScrn);
d4311 2
a4312 67
    ScrnInfoPtr    pScrn       = xf86Screens[scrnIndex];
    RADEONInfoPtr  info        = RADEONPTR(pScrn);
    Bool           ret;
#ifdef XF86DRI
    Bool           CPStarted   = info->CPStarted;

    if (CPStarted) {
	DRILock(pScrn->pScreen, 0);
	RADEONCP_STOP(pScrn, info);
    }
#endif

    if (info->accelOn) info->accel->Sync(pScrn);

    if (info->FBDev) {
	RADEONSaveFBDevRegisters(pScrn, &info->ModeReg);

	ret = fbdevHWSwitchMode(scrnIndex, mode, flags);

	RADEONRestoreFBDevRegisters(pScrn, &info->ModeReg);
    } else {
	info->IsSwitching = TRUE;
	if (info->Clone && info->CloneModes) {
	    DisplayModePtr  clone_mode = info->CloneModes;

	    /* Try to match a mode on primary head 
	     * FIXME: This may not be good if both heads don't have
	     *        exactly the same list of mode.
	     */
	    while (1) {
		if ((clone_mode->HDisplay == mode->HDisplay) &&
		    (clone_mode->VDisplay == mode->VDisplay) &&
		    (!info->PanelOff)) {
		    info->CloneFrameX0 = (info->CurCloneMode->HDisplay +
					  info->CloneFrameX0 -
					  clone_mode->HDisplay - 1) / 2;
		    info->CloneFrameY0 =
			(info->CurCloneMode->VDisplay + info->CloneFrameY0 -
			 clone_mode->VDisplay - 1) / 2;
		    info->CurCloneMode = clone_mode;
		    break;
		}

		if (!clone_mode->next) {
		    info->CurCloneMode = info->CloneModes;
		    break;
		}

		clone_mode = clone_mode->next;
	    }
	}
	ret = RADEONModeInit(xf86Screens[scrnIndex], mode);

	if (info->CurCloneMode) {
	    if (info->CloneFrameX0 + info->CurCloneMode->HDisplay >=
		pScrn->virtualX)
		info->CloneFrameX0 =
		    pScrn->virtualX - info->CurCloneMode->HDisplay;
	    else if (info->CloneFrameX0 < 0)
		info->CloneFrameX0 = 0;

	    if (info->CloneFrameY0 + info->CurCloneMode->VDisplay >=
		pScrn->virtualY)
		info->CloneFrameY0 =
		    pScrn->virtualY - info->CurCloneMode->VDisplay;
	    else if (info->CloneFrameY0 < 0)
		info->CloneFrameY0 = 0;
d4314 9
a4322 20
	    RADEONDoAdjustFrame(pScrn, info->CloneFrameX0, info->CloneFrameY0,
				TRUE);
	}

	info->IsSwitching = FALSE;
    }

    if (info->accelOn) {
	info->accel->Sync(pScrn);
	RADEONEngineRestore(pScrn);
    }

#ifdef XF86DRI
    if (CPStarted) {
	RADEONCP_START(pScrn, info);
	DRIUnlock(pScrn->pScreen);
    }
#endif

    return ret;
d4325 1
a4325 1
/* Used to disallow modes that are not supported by the hardware */
d4329 1
d4331 39
a4369 2
     * Not working yet. Currently we calculate from FP registers
     */
d4374 3
a4376 4
/* Adjust viewport into virtual desktop such that (0,0) in viewport
 * space is (x,y) in virtual space.
 */
void RADEONDoAdjustFrame(ScrnInfoPtr pScrn, int x, int y, int clone)
d4378 2
a4379 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d4381 3
a4383 4
    int            reg, Base = y * info->CurrentLayout.displayWidth + x;
#ifdef XF86DRI
    RADEONSAREAPrivPtr pSAREAPriv;
#endif
d4394 4
a4397 5
    if (clone || info->IsSecondary) {
	Base += pScrn->fbOffset;
	reg = RADEON_CRTC2_OFFSET;
    } else {
	reg = RADEON_CRTC_OFFSET;
d4399 3
a4401 39

#ifdef XF86DRI
    if (info->directRenderingEnabled) {

    	pSAREAPriv = DRIGetSAREAPrivate(pScrn->pScreen);

	if (pSAREAPriv->pfCurrentPage == 1) {
	    Base += info->backOffset;
	}

	if (clone || info->IsSecondary) {
	    pSAREAPriv->crtc2_base = Base;
	}
    }
#endif

    OUTREG(reg, Base);
}

void RADEONAdjustFrame(int scrnIndex, int x, int y, int flags)
{
    ScrnInfoPtr    pScrn      = xf86Screens[scrnIndex];
    RADEONInfoPtr  info       = RADEONPTR(pScrn);

#ifdef XF86DRI
    if (info->CPStarted) DRILock(pScrn->pScreen, 0);
#endif

    if (info->accelOn) info->accel->Sync(pScrn);

    if (info->FBDev) {
	fbdevHWAdjustFrame(scrnIndex, x, y, flags);
    } else {
	RADEONDoAdjustFrame(pScrn, x, y, FALSE);
    }

#ifdef XF86DRI
	if (info->CPStarted) DRIUnlock(pScrn->pScreen);
#endif
d4404 2
a4405 3
/* Called when VT switching back to the X server.  Reinitialize the
 * video mode.
 */
d4408 2
a4409 2
    ScrnInfoPtr    pScrn = xf86Screens[scrnIndex];
    RADEONInfoPtr  info  = RADEONPTR(pScrn);
d4415 3
a4417 5
	if (!fbdevHWEnterVT(scrnIndex,flags)) return FALSE;
	info->PaletteSavedOnVT = FALSE;
	info->ModeReg.surface_cntl = INREG(RADEON_SURFACE_CNTL);

	RADEONRestoreFBDevRegisters(pScrn, &info->ModeReg);
d4419 1
a4419 1
	if (!RADEONModeInit(pScrn, pScrn->currentMode)) return FALSE;
d4425 1
a4425 1
    if (info->directRenderingEnabled) {
d4431 1
a4431 5
    pScrn->AdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
    if (info->CurCloneMode) {
	RADEONDoAdjustFrame(pScrn, info->CloneFrameX0, info->CloneFrameY0, TRUE);
    }

d4435 2
a4436 3
/* Called when VT switching away from the X server.  Restore the
 * original text mode.
 */
d4439 3
a4441 3
    ScrnInfoPtr    pScrn = xf86Screens[scrnIndex];
    RADEONInfoPtr  info  = RADEONPTR(pScrn);
    RADEONSavePtr  save  = &info->ModeReg;
d4452 5
a4456 9
	RADEONSavePalette(pScrn, save);
	info->PaletteSavedOnVT = TRUE;

	RADEONSaveFBDevRegisters(pScrn, &info->ModeReg);

	fbdevHWLeaveVT(scrnIndex,flags);
    }

    RADEONRestore(pScrn);
d4459 3
a4461 4
/* Called at the end of each server generation.  Restore the original
 * text mode, unmap video memory, and unwrap and call the saved
 * CloseScreen function.
 */
d4464 2
a4465 2
    ScrnInfoPtr    pScrn = xf86Screens[scrnIndex];
    RADEONInfoPtr  info  = RADEONPTR(pScrn);
d4477 2
a4478 1
    if (pScrn->vtSema) {
d4483 2
a4484 2
    if (info->accel) XAADestroyInfoRec(info->accel);
    info->accel = NULL;
d4486 2
a4487 2
    if (info->scratch_save) xfree(info->scratch_save);
    info->scratch_save = NULL;
d4489 2
a4490 2
    if (info->cursor) xf86DestroyCursorInfoRec(info->cursor);
    info->cursor = NULL;
d4492 2
a4493 6
    if (info->DGAModes) xfree(info->DGAModes);
    info->DGAModes = NULL;

    if (info->CloneModes)
	while (info->CloneModes)
	    xf86DeleteMode(&info->CloneModes, info->CloneModes);
d4506 1
a4506 1
    ScrnInfoPtr  pScrn = xf86Screens[scrnIndex];
d4515 1
a4515 1
/* Sets VESA Display Power Management Signaling (DPMS) Mode */
d4517 1
a4517 2
					    int PowerManagementMode,
					    int flags)
d4519 1
a4519 1
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
d4521 23
a4543 76

#ifdef XF86DRI
    if (info->CPStarted) DRILock(pScrn->pScreen, 0);
#endif

    if (info->accelOn) info->accel->Sync(pScrn);

    if (info->FBDev) {
	fbdevHWDPMSSet(pScrn, PowerManagementMode, flags);
    } else {
	int             mask1     = (RADEON_CRTC_DISPLAY_DIS |
				     RADEON_CRTC_HSYNC_DIS |
				     RADEON_CRTC_VSYNC_DIS);
	int             mask2     = (RADEON_CRTC2_DISP_DIS |
				     RADEON_CRTC2_VSYNC_DIS |
				     RADEON_CRTC2_HSYNC_DIS);

	/* TODO: additional handling for LCD ? */

	switch (PowerManagementMode) {
	case DPMSModeOn:
	    /* Screen: On; HSync: On, VSync: On */
	    if (info->IsSecondary)
		OUTREGP(RADEON_CRTC2_GEN_CNTL, 0, ~mask2);
	    else {
		if (info->Clone)
		    OUTREGP(RADEON_CRTC2_GEN_CNTL, 0, ~mask2);
		OUTREGP(RADEON_CRTC_EXT_CNTL, 0, ~mask1);
	    }
	    break;

	case DPMSModeStandby:
	    /* Screen: Off; HSync: Off, VSync: On */
	    if (info->IsSecondary)
		OUTREGP(RADEON_CRTC2_GEN_CNTL,
			RADEON_CRTC2_DISP_DIS | RADEON_CRTC2_HSYNC_DIS,
			~mask2);
	    else {
		if (info->Clone)
		    OUTREGP(RADEON_CRTC2_GEN_CNTL,
			    RADEON_CRTC2_DISP_DIS | RADEON_CRTC2_HSYNC_DIS,
			    ~mask2);
		OUTREGP(RADEON_CRTC_EXT_CNTL,
			RADEON_CRTC_DISPLAY_DIS | RADEON_CRTC_HSYNC_DIS,
			~mask1);
	    }
	    break;

	case DPMSModeSuspend:
	    /* Screen: Off; HSync: On, VSync: Off */
	    if (info->IsSecondary)
		OUTREGP(RADEON_CRTC2_GEN_CNTL,
			RADEON_CRTC2_DISP_DIS | RADEON_CRTC2_VSYNC_DIS,
			~mask2);
	    else {
		if (info->Clone)
		    OUTREGP(RADEON_CRTC2_GEN_CNTL,
			    RADEON_CRTC2_DISP_DIS | RADEON_CRTC2_VSYNC_DIS,
			    ~mask2);
		OUTREGP(RADEON_CRTC_EXT_CNTL,
			RADEON_CRTC_DISPLAY_DIS | RADEON_CRTC_VSYNC_DIS,
			~mask1);
	    }
	    break;

	case DPMSModeOff:
	    /* Screen: Off; HSync: Off, VSync: Off */
	    if (info->IsSecondary)
		OUTREGP(RADEON_CRTC2_GEN_CNTL, mask2, ~mask2);
	    else {
		if (info->Clone)
		    OUTREGP(RADEON_CRTC2_GEN_CNTL, mask2, ~mask2);
		OUTREGP(RADEON_CRTC_EXT_CNTL, mask1, ~mask1);
	    }
	    break;
	}
a4544 4

#ifdef XF86DRI
    if (info->CPStarted) DRIUnlock(pScrn->pScreen);
#endif
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c,v 1.116 2003/11/19 02:08:15 martin Exp $ */
d74 2
d77 10
a107 3
#ifndef MIN
#define MIN(a,b) ((a)>(b)?(b):(a))
#endif
a117 1
static void RADEONInitDispBandwidth(ScrnInfoPtr pScrn);
a125 1
    OPTION_BUS_TYPE,
d130 1
a130 1
    OPTION_GART_SIZE,
d139 1
a139 3
    OPTION_MONITOR_LAYOUT,
    OPTION_IGNORE_EDID,
    OPTION_CRTC2_OVERLAY,
d144 1
a144 4
    OPTION_VIDEO_KEY,
    OPTION_DISP_PRIORITY,
    OPTION_PANEL_SIZE,
    OPTION_MIN_DOTCLOCK
a153 1
    { OPTION_BUS_TYPE,       "BusType",          OPTV_ANYSTR,  {0}, FALSE },
d158 1
a158 2
    { OPTION_GART_SIZE,      "AGPSize",          OPTV_INTEGER, {0}, FALSE },
    { OPTION_GART_SIZE,      "GARTSize",         OPTV_INTEGER, {0}, FALSE },
d167 1
a167 3
    { OPTION_MONITOR_LAYOUT, "MonitorLayout",    OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_IGNORE_EDID,    "IgnoreEDID",       OPTV_BOOLEAN, {0}, FALSE },
    { OPTION_CRTC2_OVERLAY , "OverlayOnCRTC2",   OPTV_BOOLEAN, {0}, FALSE },
a172 3
    { OPTION_DISP_PRIORITY,  "DisplayPriority",  OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_PANEL_SIZE,     "PanelSize",        OPTV_ANYSTR,  {0}, FALSE },
    { OPTION_MIN_DOTCLOCK,   "ForceMinDotClock", OPTV_FREQ,    {0}, FALSE },
d176 6
d229 1
d235 9
d358 1
d360 3
d395 1
a395 1
    {800, 600, 72},
a405 18
static const RADEONTMDSPll default_tmds_pll[CHIP_FAMILY_LAST][4] =
{
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_UNKNOW*/
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_LEGACY*/
    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RADEON*/
    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV100*/
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_RS100*/
    {{15000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV200*/
    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RS200*/
    {{15000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_R200*/
    {{15500, 0x81b}, {0xffffffff, 0x83f}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV250*/
    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},				/*CHIP_FAMILY_RS300*/
    {{13000, 0x400f4}, {15000, 0x400f7}, {0xffffffff, 0x400f7/*0x40111*/}, {0, 0}},	/*CHIP_FAMILY_RV280*/
    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},		/*CHIP_FAMILY_R300*/
    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},		/*CHIP_FAMILY_R350*/
    {{15000, 0xb0155}, {0xffffffff, 0xb01cb}, {0, 0}, {0, 0}},	/*CHIP_FAMILY_RV350*/
};

a416 9
static RADEONEntPtr RADEONEntPriv(ScrnInfoPtr pScrn)
{
    DevUnion     *pPriv;
    RADEONInfoPtr  info   = RADEONPTR(pScrn);
    pPriv = xf86GetEntityPrivate(info->pEnt->index,
                                 gRADEONEntityIndex);
    return pPriv->ptr;
}

d421 2
a422 1
    unsigned char *RADEONMMIO = info->MMIO;
d426 16
d447 1
a447 1
    /*
d456 4
d466 1
a466 1
    unsigned char *RADEONMMIO = info->MMIO;
d469 1
d475 7
d488 2
a489 2
    if (!CardTmp ||
	((CardTmp & 1) &&
d493 2
a494 2
		   "Restoring MEM_CNTL (%08lx), setting to %08lx\n",
		   (unsigned long)CardTmp, (unsigned long)pSave->MEM_CNTL);
d500 2
a501 2
		       "Restoring CONFIG_MEMSIZE (%08lx), setting to %08lx\n",
		       (unsigned long)CardTmp, (unsigned long)pSave->MEMSIZE);
d509 2
a510 3
		   "Restoring MPP_TB_CONFIG<31:24> (%02lx), setting to %02lx\n",
		   (unsigned long)CardTmp >> 24,
		   (unsigned long)pSave->MPP_TB_CONFIG >> 24);
d515 4
d714 6
a719 2
		    RADEON_CRTC_DISPLAY_DIS,
		    ~(RADEON_CRTC_DISPLAY_DIS));
d728 6
a733 2
		    RADEON_CRTC2_DISP_DIS,
		    ~(RADEON_CRTC2_DISP_DIS));
d736 6
a741 2
		RADEON_CRTC2_DISP_DIS,
		~(RADEON_CRTC2_DISP_DIS));
d758 3
a760 1
		    ~(RADEON_CRTC_DISPLAY_DIS));
d770 3
a772 1
		    ~(RADEON_CRTC2_DISP_DIS));
d780 3
a782 1
		    ~(RADEON_CRTC2_DISP_DIS));
d808 2
a809 1
static RADEONMonitorType RADEONDisplayDDCConnected(ScrnInfoPtr pScrn, RADEONDDCType DDCType, xf86MonPtr* MonInfo)
d811 5
a815 330
    RADEONInfoPtr info = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    unsigned long DDCReg;
    RADEONMonitorType MonType = MT_NONE;
    int i, j;

    DDCReg = info->DDCReg;
    switch(DDCType)
    {
    case DDC_MONID:
	info->DDCReg = RADEON_GPIO_MONID;
	break;
    case DDC_DVI:
	info->DDCReg = RADEON_GPIO_DVI_DDC;
	break;
    case DDC_VGA:
	info->DDCReg = RADEON_GPIO_VGA_DDC;
	break;
    case DDC_CRT2:
	info->DDCReg = RADEON_GPIO_CRT2_DDC;
	break;
    default:
	info->DDCReg = DDCReg;
	return MT_NONE;
    }

    /* Read and output monitor info using DDC2 over I2C bus */
    if (info->pI2CBus && info->ddc2) {
	OUTREG(info->DDCReg, INREG(info->DDCReg) &
	       (CARD32)~(RADEON_GPIO_A_0 | RADEON_GPIO_A_1));

	/* For some old monitors (like Compaq Presario FP500), we need
	 * following process to initialize/stop DDC
	 */
	OUTREG(info->DDCReg, INREG(info->DDCReg) & ~(RADEON_GPIO_EN_1));
	for (j = 0; j < 3; j++) {
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_0));
	    usleep(13000);

	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_1));
	    for (i = 0; i < 10; i++) {
		usleep(15000);
		if (INREG(info->DDCReg) & RADEON_GPIO_Y_1)
		    break;
	    }
	    if (i == 10) continue;

	    usleep(15000);

	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_0);
	    usleep(15000);

	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_1);
	    usleep(15000);
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_0));
	    usleep(15000);
	    *MonInfo = xf86DoEDID_DDC2(pScrn->scrnIndex, info->pI2CBus);

	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_1);
	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_0);
	    usleep(15000);
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_1));
	    for (i = 0; i < 5; i++) {
		usleep(15000);
		if (INREG(info->DDCReg) & RADEON_GPIO_Y_1)
		    break;
	    }
	    usleep(15000);
	    OUTREG(info->DDCReg,
		   INREG(info->DDCReg) & ~(RADEON_GPIO_EN_0));
	    usleep(15000);

	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_1);
	    OUTREG(info->DDCReg, INREG(info->DDCReg) | RADEON_GPIO_EN_0);
	    usleep(15000);
	    if(*MonInfo) break;
	}
    } else {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "DDC2/I2C is not properly initialized\n");
	MonType = MT_NONE;
    }

    if (*MonInfo) {
	if ((*MonInfo)->rawData[0x14] & 0x80) {
	    if (INREG(RADEON_LVDS_GEN_CNTL) & RADEON_LVDS_ON) MonType = MT_LCD;
	    else MonType = MT_DFP;
	} else MonType = MT_CRT;
    } else MonType = MT_NONE;

    info->DDCReg = DDCReg;

    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "DDC Type: %d, Detected Type: %d\n", DDCType, MonType);

    return MonType;
}

static RADEONMonitorType
RADEONCrtIsPhysicallyConnected(ScrnInfoPtr pScrn, int IsCrtDac)
{
    RADEONInfoPtr info       = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    int		  bConnected = 0;

    /* the monitor either wasn't connected or it is a non-DDC CRT.
     * try to probe it
     */
    if(IsCrtDac) {
	unsigned long ulOrigVCLK_ECP_CNTL;
	unsigned long ulOrigDAC_CNTL;
	unsigned long ulOrigDAC_EXT_CNTL;
	unsigned long ulOrigCRTC_EXT_CNTL;
	unsigned long ulData;
	unsigned long ulMask;

	ulOrigVCLK_ECP_CNTL = INPLL(pScrn, RADEON_VCLK_ECP_CNTL);

	ulData              = ulOrigVCLK_ECP_CNTL;
	ulData             &= ~(RADEON_PIXCLK_ALWAYS_ONb
				| RADEON_PIXCLK_DAC_ALWAYS_ONb);
	ulMask              = ~(RADEON_PIXCLK_ALWAYS_ONb
				|RADEON_PIXCLK_DAC_ALWAYS_ONb);
	OUTPLLP(pScrn, RADEON_VCLK_ECP_CNTL, ulData, ulMask);

	ulOrigCRTC_EXT_CNTL = INREG(RADEON_CRTC_EXT_CNTL);
	ulData              = ulOrigCRTC_EXT_CNTL;
	ulData             |= RADEON_CRTC_CRT_ON;
	OUTREG(RADEON_CRTC_EXT_CNTL, ulData);

	ulOrigDAC_EXT_CNTL = INREG(RADEON_DAC_EXT_CNTL);
	ulData             = ulOrigDAC_EXT_CNTL;
	ulData            &= ~RADEON_DAC_FORCE_DATA_MASK;
	ulData            |=  (RADEON_DAC_FORCE_BLANK_OFF_EN
			       |RADEON_DAC_FORCE_DATA_EN
			       |RADEON_DAC_FORCE_DATA_SEL_MASK);
	if ((info->ChipFamily == CHIP_FAMILY_RV250) ||
	    (info->ChipFamily == CHIP_FAMILY_RV280))
	    ulData |= (0x01b6 << RADEON_DAC_FORCE_DATA_SHIFT);
	else
	    ulData |= (0x01ac << RADEON_DAC_FORCE_DATA_SHIFT);

	OUTREG(RADEON_DAC_EXT_CNTL, ulData);

	ulOrigDAC_CNTL     = INREG(RADEON_DAC_CNTL);
	ulData             = ulOrigDAC_CNTL;
	ulData            |= RADEON_DAC_CMP_EN;
	ulData            &= ~(RADEON_DAC_RANGE_CNTL_MASK
			       | RADEON_DAC_PDWN);
	ulData            |= 0x2;
	OUTREG(RADEON_DAC_CNTL, ulData);

	usleep(1000);

	ulData     = INREG(RADEON_DAC_CNTL);
	bConnected =  (RADEON_DAC_CMP_OUTPUT & ulData)?1:0;

	ulData    = ulOrigVCLK_ECP_CNTL;
	ulMask    = 0xFFFFFFFFL;
	OUTPLLP(pScrn, RADEON_VCLK_ECP_CNTL, ulData, ulMask);

	OUTREG(RADEON_DAC_CNTL,      ulOrigDAC_CNTL     );
	OUTREG(RADEON_DAC_EXT_CNTL,  ulOrigDAC_EXT_CNTL );
	OUTREG(RADEON_CRTC_EXT_CNTL, ulOrigCRTC_EXT_CNTL);
    } else { /* TV DAC */

        /* This doesn't seem to work reliably (maybe worse on some OEM cards),
           for now we always return false. If one wants to connected a
           non-DDC monitor on the DVI port when CRT port is also connected,
           he will need to explicitly tell the driver in the config file
           with Option MonitorLayout.
        */
        bConnected = FALSE;

#if 0
	if (info->ChipFamily == CHIP_FAMILY_R200) {

	    unsigned long ulOrigGPIO_MONID;
	    unsigned long ulOrigFP2_GEN_CNTL;
	    unsigned long ulOrigDISP_OUTPUT_CNTL;
	    unsigned long ulOrigCRTC2_GEN_CNTL;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_A;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_B;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_C;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_D;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_E;
	    unsigned long ulOrigDISP_LIN_TRANS_GRPH_F;
	    unsigned long ulOrigCRTC2_H_TOTAL_DISP;
	    unsigned long ulOrigCRTC2_V_TOTAL_DISP;
	    unsigned long ulOrigCRTC2_H_SYNC_STRT_WID;
	    unsigned long ulOrigCRTC2_V_SYNC_STRT_WID;
	    unsigned long ulData, i;

	    ulOrigGPIO_MONID = INREG(RADEON_GPIO_MONID);
	    ulOrigFP2_GEN_CNTL = INREG(RADEON_FP2_GEN_CNTL);
	    ulOrigDISP_OUTPUT_CNTL = INREG(RADEON_DISP_OUTPUT_CNTL);
	    ulOrigCRTC2_GEN_CNTL = INREG(RADEON_CRTC2_GEN_CNTL);
	    ulOrigDISP_LIN_TRANS_GRPH_A = INREG(RADEON_DISP_LIN_TRANS_GRPH_A);
	    ulOrigDISP_LIN_TRANS_GRPH_B = INREG(RADEON_DISP_LIN_TRANS_GRPH_B);
	    ulOrigDISP_LIN_TRANS_GRPH_C = INREG(RADEON_DISP_LIN_TRANS_GRPH_C);
	    ulOrigDISP_LIN_TRANS_GRPH_D = INREG(RADEON_DISP_LIN_TRANS_GRPH_D);
	    ulOrigDISP_LIN_TRANS_GRPH_E = INREG(RADEON_DISP_LIN_TRANS_GRPH_E);
	    ulOrigDISP_LIN_TRANS_GRPH_F = INREG(RADEON_DISP_LIN_TRANS_GRPH_F);

	    ulOrigCRTC2_H_TOTAL_DISP = INREG(RADEON_CRTC2_H_TOTAL_DISP);
	    ulOrigCRTC2_V_TOTAL_DISP = INREG(RADEON_CRTC2_V_TOTAL_DISP);
	    ulOrigCRTC2_H_SYNC_STRT_WID = INREG(RADEON_CRTC2_H_SYNC_STRT_WID);
	    ulOrigCRTC2_V_SYNC_STRT_WID = INREG(RADEON_CRTC2_V_SYNC_STRT_WID);

	    ulData     = INREG(RADEON_GPIO_MONID);
	    ulData    &= ~RADEON_GPIO_A_0;
	    OUTREG(RADEON_GPIO_MONID, ulData);

	    OUTREG(RADEON_FP2_GEN_CNTL, 0x0a000c0c);

	    OUTREG(RADEON_DISP_OUTPUT_CNTL, 0x00000012);

	    OUTREG(RADEON_CRTC2_GEN_CNTL, 0x06000000);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_A, 0x00000000);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_B, 0x000003f0);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_C, 0x00000000);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_D, 0x000003f0);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_E, 0x00000000);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_F, 0x000003f0);
	    OUTREG(RADEON_CRTC2_H_TOTAL_DISP, 0x01000008);
	    OUTREG(RADEON_CRTC2_H_SYNC_STRT_WID, 0x00000800);
	    OUTREG(RADEON_CRTC2_V_TOTAL_DISP, 0x00080001);
	    OUTREG(RADEON_CRTC2_V_SYNC_STRT_WID, 0x00000080);

	    for (i = 0; i < 200; i++) {
		ulData     = INREG(RADEON_GPIO_MONID);
		bConnected = (ulData & RADEON_GPIO_Y_0)?1:0;
		if (!bConnected) break;

		usleep(1000);
	    }

	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_A, ulOrigDISP_LIN_TRANS_GRPH_A);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_B, ulOrigDISP_LIN_TRANS_GRPH_B);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_C, ulOrigDISP_LIN_TRANS_GRPH_C);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_D, ulOrigDISP_LIN_TRANS_GRPH_D);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_E, ulOrigDISP_LIN_TRANS_GRPH_E);
	    OUTREG(RADEON_DISP_LIN_TRANS_GRPH_F, ulOrigDISP_LIN_TRANS_GRPH_F);
	    OUTREG(RADEON_CRTC2_H_TOTAL_DISP, ulOrigCRTC2_H_TOTAL_DISP);
	    OUTREG(RADEON_CRTC2_V_TOTAL_DISP, ulOrigCRTC2_V_TOTAL_DISP);
	    OUTREG(RADEON_CRTC2_H_SYNC_STRT_WID, ulOrigCRTC2_H_SYNC_STRT_WID);
	    OUTREG(RADEON_CRTC2_V_SYNC_STRT_WID, ulOrigCRTC2_V_SYNC_STRT_WID);
	    OUTREG(RADEON_CRTC2_GEN_CNTL, ulOrigCRTC2_GEN_CNTL);
	    OUTREG(RADEON_DISP_OUTPUT_CNTL, ulOrigDISP_OUTPUT_CNTL);
	    OUTREG(RADEON_FP2_GEN_CNTL, ulOrigFP2_GEN_CNTL);
	    OUTREG(RADEON_GPIO_MONID, ulOrigGPIO_MONID);
        } else {
	    unsigned long ulOrigPIXCLKSDATA;
	    unsigned long ulOrigTV_MASTER_CNTL;
	    unsigned long ulOrigTV_DAC_CNTL;
	    unsigned long ulOrigTV_PRE_DAC_MUX_CNTL;
	    unsigned long ulOrigDAC_CNTL2;
	    unsigned long ulData;
	    unsigned long ulMask;

	    ulOrigPIXCLKSDATA = INPLL(pScrn, RADEON_PIXCLKS_CNTL);

	    ulData            = ulOrigPIXCLKSDATA;
	    ulData           &= ~(RADEON_PIX2CLK_ALWAYS_ONb
				  | RADEON_PIX2CLK_DAC_ALWAYS_ONb);
	    ulMask            = ~(RADEON_PIX2CLK_ALWAYS_ONb
			  | RADEON_PIX2CLK_DAC_ALWAYS_ONb);
	    OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL, ulData, ulMask);

	    ulOrigTV_MASTER_CNTL = INREG(RADEON_TV_MASTER_CNTL);
	    ulData               = ulOrigTV_MASTER_CNTL;
	    ulData              &= ~RADEON_TVCLK_ALWAYS_ONb;
	    OUTREG(RADEON_TV_MASTER_CNTL, ulData);

	    ulOrigDAC_CNTL2 = INREG(RADEON_DAC_CNTL2);
	    ulData          = ulOrigDAC_CNTL2;
	    ulData          &= ~RADEON_DAC2_DAC2_CLK_SEL;
	    OUTREG(RADEON_DAC_CNTL2, ulData);

	    ulOrigTV_DAC_CNTL = INREG(RADEON_TV_DAC_CNTL);

	    ulData  = 0x00880213;
	    OUTREG(RADEON_TV_DAC_CNTL, ulData);

	    ulOrigTV_PRE_DAC_MUX_CNTL = INREG(RADEON_TV_PRE_DAC_MUX_CNTL);

	    ulData  =  (RADEON_Y_RED_EN
			| RADEON_C_GRN_EN
			| RADEON_CMP_BLU_EN
			| RADEON_RED_MX_FORCE_DAC_DATA
			| RADEON_GRN_MX_FORCE_DAC_DATA
			| RADEON_BLU_MX_FORCE_DAC_DATA);
            if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		(info->ChipFamily == CHIP_FAMILY_R350) ||
		(info->ChipFamily == CHIP_FAMILY_RV350))
		ulData |= 0x180 << RADEON_TV_FORCE_DAC_DATA_SHIFT;
	    else
		ulData |= 0x1f5 << RADEON_TV_FORCE_DAC_DATA_SHIFT;
	    OUTREG(RADEON_TV_PRE_DAC_MUX_CNTL, ulData);

	    usleep(1000);

	    ulData     = INREG(RADEON_TV_DAC_CNTL);
	    bConnected = (ulData & RADEON_TV_DAC_CMPOUT)?1:0;

	    ulData    = ulOrigPIXCLKSDATA;
	    ulMask    = 0xFFFFFFFFL;
	    OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL, ulData, ulMask);

	    OUTREG(RADEON_TV_MASTER_CNTL, ulOrigTV_MASTER_CNTL);
	    OUTREG(RADEON_DAC_CNTL2, ulOrigDAC_CNTL2);
	    OUTREG(RADEON_TV_DAC_CNTL, ulOrigTV_DAC_CNTL);
	    OUTREG(RADEON_TV_PRE_DAC_MUX_CNTL, ulOrigTV_PRE_DAC_MUX_CNTL);
	}
#endif
    }

    return(bConnected ? MT_CRT : MT_NONE);
}

static void RADEONQueryConnectedDisplays(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
{
    RADEONInfoPtr info        = RADEONPTR(pScrn);
    RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    const char *s;
    Bool ignore_edid = FALSE, ddc_crt2_used = FALSE;
a824 297
    pRADEONEnt->MonType1 = MT_NONE;
    pRADEONEnt->MonType2 = MT_NONE;
    pRADEONEnt->MonInfo1 = NULL;
    pRADEONEnt->MonInfo2 = NULL;
    pRADEONEnt->ReversedDAC = FALSE;
    pRADEONEnt->ReversedTMDS = FALSE;

    /* IgnoreEDID option is different from NoDDC options used by DDC module
     * When IgnoreEDID is used, monitor detection will still use DDC
     * detection, but all EDID data will not be used in mode validation.
     */
    if (xf86GetOptValBool(info->Options, OPTION_IGNORE_EDID, &ignore_edid)) {
	if (ignore_edid)
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       "IgnoreEDID is specified, EDID data will be ignored\n");
    }

    /*
     * MonitorLayout option takes a string for two monitors connected in following format:
     * Option "MonitorLayout" "primary-port-display, secondary-port-display"
     * primary and secondary port displays can have one of following:
     *    NONE, CRT, LVDS, TMDS
     * With this option, driver will bring up monitors as specified,
     * not using auto-detection routines to probe monitors.
     */

    /* current monitor mapping scheme:
     *  Two displays connected:
     *     Primary Port:
     *     CRTC1 -> FP/TMDS  -> DVI port -> TMDS panel  --> Primary or
     *     CRTC1 -> FP/LVDS  -> Int. LCD -> LVDS panel  --> Primary or
     *     CRTC1 -> TV DAC   -> DVI port -> CRT monitor --> Primary
     *
     *     Secondary Port
     *     CRTC2 -> CRT DAC  -> VGA port -> CRT monitor --> Secondary or
     *     CRTC2 -> FP2/Ext. -> DVI port -> TMDS panel  --> Secondary
     *
     *  Only DVI (or Int. LDC) conneced:
     *     CRTC1 -> FP/TMDS  -> DVI port -> TMDS panel  --> Primary or
     *     CRTC1 -> FP/LVDS  -> Int. LCD -> LVDS panel  --> Primary or
     *     CRTC1 -> TV DAC   -> DVI port -> CRT monitor --> Primary
     *
     *  Only VGA (can be DVI on some dual-DVI boards) connected:
     *     CRTC1 -> CRT DAC  -> VGA port -> CRT monitor --> Primary or
     *     CRTC1 -> FP2/Ext. -> DVI port -> TMDS panel  --> Primary (not supported)
     *
     * Note, this is different from Windows scheme where
     *   if a digital panel is connected to DVI port, DVI will be the 1st port
     *   otherwise, VGA port will be treated as 1st port
     *
     *   Here we always treat DVI port as primary if both ports are connected.
     *   When only one port is connected, it will be treated as
     *   primary regardless which port or what type of display is involved.
     */

    if ((s = xf86GetOptValString(info->Options, OPTION_MONITOR_LAYOUT))) {
	char s1[5], s2[5];
	int i = 0, second = 0;

	/* When using user specified monitor types, we will not do DDC detection
	 *
	 */
	do {
	    switch(*s)
            {
            case ',':
		s1[i] = '\0';
		i = 0;
		second = 1;
		break;
	    case ' ':
	    case '\t':
	    case '\n':
	    case '\r':
		break;
	    default:
		if (second)
		    s2[i] = *s;
		else
		    s1[i] = *s;
		i++;
		if (i == 4) break;
	    }
	} while(*s++);
	s2[i] = '\0';

	if (strcmp(s1, "NONE") == 0)
	    pRADEONEnt->MonType1 = MT_NONE;
	else if (strcmp(s1, "CRT") == 0)
	    pRADEONEnt->MonType1 = MT_CRT;
	else if (strcmp(s1, "TMDS") == 0)
	    pRADEONEnt->MonType1 = MT_DFP;
	else if (strcmp(s1, "LVDS") == 0)
	    pRADEONEnt->MonType1 = MT_LCD;
	else
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Invalid Monitor type specified for 1st port \n");
	if (strcmp(s2, "NONE") == 0)
	    pRADEONEnt->MonType2 = MT_NONE;
	else if (strcmp(s2, "CRT") == 0)
	    pRADEONEnt->MonType2 = MT_CRT;
	else if (strcmp(s2, "TMDS") == 0)
	    pRADEONEnt->MonType2 = MT_DFP;
	else if (strcmp(s2, "LVDS") == 0)
	    pRADEONEnt->MonType2 = MT_LCD;
	else
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Invalid Monitor type specified for 2nd port \n");

	if (!ignore_edid) {
	    if (pRADEONEnt->MonType1)  /* assuming the first port using DDC_DVI */
		if(!RADEONDisplayDDCConnected(pScrn, DDC_DVI, &pRADEONEnt->MonInfo1)) {
		    RADEONDisplayDDCConnected(pScrn, DDC_CRT2, &pRADEONEnt->MonInfo1);
		    ddc_crt2_used = TRUE;
		}
	    if (pRADEONEnt->MonType2) {  /* assuming the second port using DDC_VGA/DDC_CRT2 */
		if(!RADEONDisplayDDCConnected(pScrn, DDC_VGA, &pRADEONEnt->MonInfo2))
		    if (!ddc_crt2_used)
			RADEONDisplayDDCConnected(pScrn, DDC_CRT2, &pRADEONEnt->MonInfo2);
	    }
	}

	if (!pRADEONEnt->MonType1) {
	    if (pRADEONEnt->MonType2) {
		pRADEONEnt->MonType1 = pRADEONEnt->MonType2;
		pRADEONEnt->MonInfo1 = pRADEONEnt->MonInfo2;
	    } else {
		pRADEONEnt->MonType1 = MT_CRT;
		xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
                       "No valid monitor specified, force to CRT on 1st port\n");
	    }
	    pRADEONEnt->MonType2 = MT_NONE;
	    pRADEONEnt->MonInfo2 = NULL;
	}
    } else {
	/* Auto detection */
	int i;
	CARD32 tmp;

	/* Old single head radeon cards */
        if(!info->HasCRTC2) {
	    if((pRADEONEnt->MonType1 = RADEONDisplayDDCConnected(pScrn, DDC_DVI, &pRADEONEnt->MonInfo1)));
	    else if((pRADEONEnt->MonType1 = RADEONDisplayDDCConnected(pScrn, DDC_VGA, &pRADEONEnt->MonInfo1)));
	    else if((pRADEONEnt->MonType1 = RADEONDisplayDDCConnected(pScrn, DDC_CRT2, &pRADEONEnt->MonInfo1)));
	    else if (pInt10) {
		if (xf86LoadSubModule(pScrn, "vbe")) {
		    vbeInfoPtr  pVbe;
		    pVbe = VBEInit(pInt10, info->pEnt->index);
		    if (pVbe) {
			for (i = 0; i < 5; i++) {
			    pRADEONEnt->MonInfo1 = vbeDoEDID(pVbe, NULL);
			}
			if (pRADEONEnt->MonInfo1->rawData[0x14] & 0x80)
			    pRADEONEnt->MonType1 = MT_DFP;
			else pRADEONEnt->MonType1 = MT_CRT;
		    }
		}
	    } else
		pRADEONEnt->MonType1 = MT_CRT;

	    pRADEONEnt->HasSecondary = FALSE;
	    if (!ignore_edid) {
		if (pRADEONEnt->MonInfo1) {
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitor1 EDID data ---------------------------\n");
		    xf86PrintEDID( pRADEONEnt->MonInfo1 );
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "End of Monitor1 EDID data --------------------\n");
		}
	    }
	    return;
	}

	/* Normally the port uses DDC_DVI connected with TVDAC,
	 * But this is not true for OEM cards which have TVDAC and CRT DAC reversed.
	 * If that's the case, we need also reverse the port arrangement.
	 * BIOS settings are supposed report this correctly, work fine for all cards tested.
	 * But there may be some exceptions, in that case, user can reverse their monitor
	 * definition in config file to correct the problem.
	 */
	if (info->VBIOS && (tmp = RADEON_BIOS16(info->FPBIOSstart + 0x50))) {
	    for (i = 1; i < 4; i++) {
		unsigned int tmp0;
		if (!RADEON_BIOS8(tmp + i*2) && i > 1) break;
		tmp0 = RADEON_BIOS16(tmp + i*2);
		if ((!(tmp0 & 0x01)) && (((tmp0 >> 8) & 0xf) == DDC_DVI)) {
		    pRADEONEnt->ReversedDAC = TRUE;
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Reversed DACs detected\n");
		}
		if ((((tmp0 >> 8) & 0x0f) == DDC_DVI ) && ((tmp0 >> 4) & 0x1)) {
		    pRADEONEnt->ReversedTMDS = TRUE;
		    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Reversed TMDS detected\n");
		}
	    }
	}

	/* Primary Head (DVI or Laptop Int. panel)*/
	/* A ddc capable display connected on DVI port */
	if((pRADEONEnt->MonType1 = RADEONDisplayDDCConnected(pScrn, DDC_DVI, &pRADEONEnt->MonInfo1)));
	else if((pRADEONEnt->MonType1 =
		 RADEONDisplayDDCConnected(pScrn, DDC_CRT2, &pRADEONEnt->MonInfo1))) {
	  ddc_crt2_used = TRUE;
	} else if ((info->IsMobility) &&
		   (info->VBIOS && (INREG(RADEON_BIOS_4_SCRATCH) & 4))) {
	    /* non-DDC laptop panel connected on primary */
	    pRADEONEnt->MonType1 = MT_LCD;
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Non-DDC laptop panel detected\n");
	} else {
	    /* CRT on DVI, TODO: not reliable, make it always return false for now*/
	    pRADEONEnt->MonType1 = RADEONCrtIsPhysicallyConnected(pScrn, pRADEONEnt->ReversedDAC);
	}

	/* Secondary Head (mostly VGA, can be DVI on some OEM boards)*/
	if((pRADEONEnt->MonType2 =
	    RADEONDisplayDDCConnected(pScrn, DDC_VGA, &pRADEONEnt->MonInfo2)));
	else if(!ddc_crt2_used)
	  pRADEONEnt->MonType2 =
		 RADEONDisplayDDCConnected(pScrn, DDC_CRT2, &pRADEONEnt->MonInfo2);
	if (!pRADEONEnt->MonType2)
	    pRADEONEnt->MonType2 = RADEONCrtIsPhysicallyConnected(pScrn, !pRADEONEnt->ReversedDAC);

	if(pRADEONEnt->ReversedTMDS) {
	    /* always keep internal TMDS as primary head */
	    if (pRADEONEnt->MonType1 == MT_DFP ||
		pRADEONEnt->MonType2 == MT_DFP) {
		int tmp1 = pRADEONEnt->MonType1;
		xf86MonPtr MonInfo = pRADEONEnt->MonInfo1;
		pRADEONEnt->MonInfo1 = pRADEONEnt->MonInfo2;
		pRADEONEnt->MonInfo2 = MonInfo;
		pRADEONEnt->MonType1 = pRADEONEnt->MonType2;
		pRADEONEnt->MonType2 = tmp1;
		if ((pRADEONEnt->MonType1 == MT_CRT) ||
		    (pRADEONEnt->MonType2 == MT_CRT)) {
		    pRADEONEnt->ReversedDAC ^= 1;
		}
	    }
	}

	/* no display detected on DVI port*/
	if (pRADEONEnt->MonType1 == MT_NONE) {
	    if (pRADEONEnt->MonType2 != MT_NONE) {
		/* Only one detected on VGA, let it to be primary */
		pRADEONEnt->MonType1 = pRADEONEnt->MonType2;
		pRADEONEnt->MonInfo1 = pRADEONEnt->MonInfo2;
		pRADEONEnt->MonType2 = MT_NONE;
		pRADEONEnt->MonInfo2 = NULL;
	    } else {
		/* Non detected, Default to a CRT connected */
		pRADEONEnt->MonType1 = MT_CRT;
	    }
	}
    }

    if(s) {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Displays Configured by MonitorLayout: \n\tMonitor1--Type %d, Monitor2--Type %d\n\n",
		   pRADEONEnt->MonType1, pRADEONEnt->MonType2);
    } else {
	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		   "Displays Detected: Monitor1--Type %d, Monitor2--Type %d\n\n",
		   pRADEONEnt->MonType1, pRADEONEnt->MonType2);
    }

    if(ignore_edid) {
	pRADEONEnt->MonInfo1 = NULL;
	pRADEONEnt->MonInfo2 = NULL;
    }

    if (!ignore_edid) {
	if (pRADEONEnt->MonInfo1) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitor1 EDID data ---------------------------\n");
	    xf86PrintEDID( pRADEONEnt->MonInfo1 );
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "End of Monitor1 EDID data --------------------\n");
	}
	if (pRADEONEnt->MonInfo2) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Monitor2 EDID data ---------------------------\n");
	    xf86PrintEDID( pRADEONEnt->MonInfo2 );
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "End of Monitor2 EDID data --------------------\n");
	}
    }

    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "\n");

    info->OverlayOnCRTC2 = FALSE;
   if (xf86ReturnOptValBool(info->Options, OPTION_CRTC2_OVERLAY, FALSE)) {
	info->OverlayOnCRTC2 = TRUE;
    }

    if (pRADEONEnt->MonType2 == MT_NONE)
	pRADEONEnt->HasSecondary = FALSE;
}


/* Read the Video BIOS block and the FP registers (if applicable). */
static Bool RADEONGetBIOSParameters(ScrnInfoPtr pScrn, xf86Int10InfoPtr pInt10)
{
    RADEONInfoPtr  info            = RADEONPTR(pScrn);
    unsigned long  tmp, i;

a850 1
	info->FPBIOSstart = 0;
d855 4
a858 2
    } else
	info->FPBIOSstart = RADEON_BIOS16(0x48);
d861 2
a862 2
    if (!info->IsSecondary)
	RADEONQueryConnectedDisplays(pScrn, pInt10);
d864 20
a883 2
    {
	RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
d885 3
a887 2
	info->Clone = FALSE;
	info->CloneType = MT_NONE;
d889 10
a898 6
	if(info->HasCRTC2) {
	    if(info->IsSecondary) {
		info->DisplayType = (RADEONMonitorType)pRADEONEnt->MonType2;
		if(info->DisplayType == MT_NONE) return FALSE;
	    } else {
		info->DisplayType = (RADEONMonitorType)pRADEONEnt->MonType1;
a899 6
		if(!pRADEONEnt->HasSecondary) {
		    info->CloneType = (RADEONMonitorType)pRADEONEnt->MonType2;
		    if (info->CloneType != MT_NONE)
			info->Clone = TRUE;
		}
	    }
d901 2
a902 46
	    info->DisplayType = (RADEONMonitorType)pRADEONEnt->MonType1;
	}

	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "%s Display == Type %d\n",
		   (info->IsSecondary ? "Secondary" : "Primary"),
		   info->DisplayType);

	if (info->Clone)
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Clone Display == Type %d\n",
		       info->CloneType);

	info->HBlank     = 0;
	info->HOverPlus  = 0;
	info->HSyncWidth = 0;
	info->VBlank     = 0;
	info->VOverPlus  = 0;
	info->VSyncWidth = 0;
	info->DotClock   = 0;
	info->UseBiosDividers = FALSE;

	if (info->DisplayType == MT_LCD && info->VBIOS &&
	    !(xf86GetOptValString(info->Options, OPTION_PANEL_SIZE))) {
	    tmp = RADEON_BIOS16(info->FPBIOSstart + 0x40);
            if (!tmp) {
		info->PanelPwrDly = 200;
		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                           "No Panel Info Table found in BIOS!\n");
            } else {
		char  stmp[30];
		int   tmp0;

		for (i = 0; i < 24; i++)
		    stmp[i] = RADEON_BIOS8(tmp+i+1);
		stmp[24] = 0;

		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                           "Panel ID string: %s\n", stmp);

		info->PanelXRes = RADEON_BIOS16(tmp+25);
		info->PanelYRes = RADEON_BIOS16(tmp+27);
		xf86DrvMsg(0, X_INFO, "Panel Size from BIOS: %dx%d\n",
			   info->PanelXRes, info->PanelYRes);

		info->PanelPwrDly = RADEON_BIOS16(tmp+44);
		if (info->PanelPwrDly > 2000 || info->PanelPwrDly < 0)
		    info->PanelPwrDly = 2000;
d904 11
a914 1
		/* some panels only work well with certain divider combinations.
d916 8
a923 8
		info->RefDivider = RADEON_BIOS16(tmp+46);
		info->PostDivider = RADEON_BIOS8(tmp+48);
		info->FeedbackDivider = RADEON_BIOS16(tmp+49);
		if ((info->RefDivider != 0) &&
		    (info->FeedbackDivider > 3)) {
		  info->UseBiosDividers = TRUE;
		  xf86DrvMsg(pScrn->scrnIndex, X_INFO,
			     "BIOS provided dividers will be used.\n");
d926 9
a934 22
		/* We don't use a while loop here just in case we have a corrupted BIOS image.
		   The max number of table entries is 23 at present, but may grow in future.
		   To ensure it works with future revisions we loop it to 32.
		*/
		for (i = 0; i < 32; i++) {
		    tmp0 = RADEON_BIOS16(tmp+64+i*2);
		    if (tmp0 == 0) break;
		    if ((RADEON_BIOS16(tmp0) == info->PanelXRes) &&
			(RADEON_BIOS16(tmp0+2) == info->PanelYRes)) {
			info->HBlank     = (RADEON_BIOS16(tmp0+17) -
					    RADEON_BIOS16(tmp0+19)) * 8;
			info->HOverPlus  = (RADEON_BIOS16(tmp0+21) -
					    RADEON_BIOS16(tmp0+19) - 1) * 8;
			info->HSyncWidth = RADEON_BIOS8(tmp0+23) * 8;
			info->VBlank     = (RADEON_BIOS16(tmp0+24) -
					    RADEON_BIOS16(tmp0+26));
			info->VOverPlus  = ((RADEON_BIOS16(tmp0+28) & 0x7ff) -
					    RADEON_BIOS16(tmp0+26));
			info->VSyncWidth = ((RADEON_BIOS16(tmp0+28) & 0xf800) >> 11);
			info->DotClock   = RADEON_BIOS16(tmp0+9) * 10;
			info->Flags = 0;
		    }
d936 8
a943 39

		if (info->DotClock == 0) {
		    DisplayModePtr  tmp_mode = NULL;
		    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
			       "No valid timing info from BIOS.\n");
		    /* No timing information for the native mode,
		       use whatever specified in the Modeline.
		       If no Modeline specified, we'll just pick
		       the VESA mode at 60Hz refresh rate which
		       is likely to be the best for a flat panel.
		    */
		    tmp_mode = pScrn->monitor->Modes;
		    while(tmp_mode) {
			if ((tmp_mode->HDisplay == info->PanelXRes) &&
			    (tmp_mode->VDisplay == info->PanelYRes)) {

			    float  refresh =
				(float)tmp_mode->Clock * 1000.0 / tmp_mode->HTotal / tmp_mode->VTotal;
			    if ((abs(60.0 - refresh) < 1.0) ||
				(tmp_mode->type == 0)) {
				info->HBlank     = tmp_mode->HTotal - tmp_mode->HDisplay;
				info->HOverPlus  = tmp_mode->HSyncStart - tmp_mode->HDisplay;
				info->HSyncWidth = tmp_mode->HSyncEnd - tmp_mode->HSyncStart;
				info->VBlank     = tmp_mode->VTotal - tmp_mode->VDisplay;
				info->VOverPlus  = tmp_mode->VSyncStart - tmp_mode->VDisplay;
				info->VSyncWidth = tmp_mode->VSyncEnd - tmp_mode->VSyncStart;
				info->DotClock   = tmp_mode->Clock;
				info->Flags = 0;
				break;
			    }
			    tmp_mode = tmp_mode->next;
			}
		    }
		    if ((info->DotClock == 0) && !pRADEONEnt->MonInfo1) {
			xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
				   "Panel size is not correctly detected.\n"
				   "Please try to use PanelSize option for correct settings.\n");
			return FALSE;
		    }
a945 2
	}
    }
d947 27
a973 9
    if (info->VBIOS) {
	tmp = RADEON_BIOS16(info->FPBIOSstart + 0x30);
	info->sclk = RADEON_BIOS16(tmp + 8) / 100.0;
	info->mclk = RADEON_BIOS16(tmp + 10) / 100.0;
    } else {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "No valid info for SCLK/MCLK for display bandwidth calculation.\n");
	info->sclk = 200.00;
	info->mclk = 200.00;
    }
d975 6
a980 2
    return TRUE;
}
d982 17
a998 12
static Bool RADEONProbePLLParameters(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr info = RADEONPTR(pScrn);
    RADEONPLLPtr  pll  = &info->pll;
    unsigned char *RADEONMMIO = info->MMIO;
    unsigned char ppll_div_sel;
    unsigned Nx, M;
    unsigned xclk, tmp, ref_div;
    int hTotal, vTotal, num, denom, m, n;
    float hz, vclk, xtal;
    long start_secs, start_usecs, stop_secs, stop_usecs, total_usecs;
    int i;
d1000 7
a1006 3
    for(i=0; i<1000000; i++)
	if (((INREG(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) == 0)
	    break;
d1008 37
a1044 1
    xf86getsecs(&start_secs, &start_usecs);
d1046 3
a1048 3
    for(i=0; i<1000000; i++)
	if (((INREG(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) != 0)
	    break;
d1050 2
a1051 3
    for(i=0; i<1000000; i++)
	if (((INREG(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & 0x3ff) == 0)
	    break;
d1053 4
a1056 1
    xf86getsecs(&stop_secs, &stop_usecs);
d1058 25
a1082 95
    total_usecs = abs(stop_usecs - start_usecs);
    hz = 1000000/total_usecs;

    hTotal = ((INREG(RADEON_CRTC_H_TOTAL_DISP) & 0x1ff) + 1) * 8;
    vTotal = ((INREG(RADEON_CRTC_V_TOTAL_DISP) & 0x3ff) + 1);
    vclk = (float)(hTotal * (float)(vTotal * hz));

    switch((INPLL(pScrn, RADEON_PPLL_REF_DIV) & 0x30000) >> 16) {
    case 0:
    default:
        num = 1;
        denom = 1;
        break;
    case 1:
        n = ((INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV) >> 16) & 0xff);
        m = (INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV) & 0xff);
        num = 2*n;
        denom = 2*m;
        break;
    case 2:
        n = ((INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV) >> 8) & 0xff);
        m = (INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV) & 0xff);
        num = 2*n;
        denom = 2*m;
        break;
     }

    OUTREG(RADEON_CLOCK_CNTL_INDEX, 1);
    ppll_div_sel = INREG8(RADEON_CLOCK_CNTL_DATA + 1) & 0x3;

    n = (INPLL(pScrn, RADEON_PPLL_DIV_0 + ppll_div_sel) & 0x7ff);
    m = (INPLL(pScrn, RADEON_PPLL_REF_DIV) & 0x3ff);

    num *= n;
    denom *= m;

    switch ((INPLL(pScrn, RADEON_PPLL_DIV_0 + ppll_div_sel) >> 16) & 0x7) {
    case 1:
        denom *= 2;
        break;
    case 2:
        denom *= 4;
        break;
    case 3:
        denom *= 8;
        break;
    case 4:
        denom *= 3;
        break;
    case 6:
        denom *= 6;
        break;
    case 7:
        denom *= 12;
        break;
    }

    xtal = (int)(vclk *(float)denom/(float)num);

    if ((xtal > 26900000) && (xtal < 27100000))
        xtal = 2700;
    else if ((xtal > 14200000) && (xtal < 14400000))
        xtal = 1432;
    else if ((xtal > 29400000) && (xtal < 29600000))
        xtal = 2950;
    else
	return FALSE;

    tmp = INPLL(pScrn, RADEON_X_MPLL_REF_FB_DIV);
    ref_div = INPLL(pScrn, RADEON_PPLL_REF_DIV) & 0x3ff;

    Nx = (tmp & 0xff00) >> 8;
    M = (tmp & 0xff);
    xclk = RADEONDiv((2 * Nx * xtal), (2 * M));

    /* we're done, hopefully these are sane values */
    pll->reference_div = ref_div;
    pll->xclk = xclk;
    pll->reference_freq = xtal;

    return TRUE;
}

static void RADEONGetTMDSInfo(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info = RADEONPTR(pScrn);
    CARD32 tmp;
    int i, n;

    for (i=0; i<4; i++) {
	info->tmds_pll[i].value = 0;
	info->tmds_pll[i].freq = 0;
    }

    if (info->VBIOS) {
d1084 33
a1116 11
	if (tmp) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "DFP table revision: %d\n", RADEON_BIOS8(tmp));
	    if (RADEON_BIOS8(tmp) == 3) {
		n = RADEON_BIOS8(tmp + 5) + 1;
		if (n > 4) n = 4;
		for (i=0; i<n; i++) {
		    info->tmds_pll[i].value = RADEON_BIOS32(tmp+i*10+0x08);
		    info->tmds_pll[i].freq = RADEON_BIOS16(tmp+i*10+0x10);
		}
		return;
d1118 1
d1120 47
a1166 12
	    /* revision 4 has some problem as it appears in RV280,
	       comment it off for new, use default instead */
            /*
	    else if (RADEON_BIOS8(tmp) == 4) {
		int stride = 0;
		n = RADEON_BIOS8(tmp + 5) + 1;
		if (n > 4) n = 4;
		for (i=0; i<n; i++) {
		    info->tmds_pll[i].value = RADEON_BIOS32(tmp+stride+0x08);
		    info->tmds_pll[i].freq = RADEON_BIOS16(tmp+stride+0x10);
		    if (i == 0) stride += 10;
		    else stride += 6;
a1167 1
		return;
a1168 1
	    */
d1170 6
d1178 1
a1178 4
    for (i=0; i<4; i++) {
	info->tmds_pll[i].value = default_tmds_pll[info->ChipFamily][i].value;
	info->tmds_pll[i].freq = default_tmds_pll[info->ChipFamily][i].freq;
    }
a1189 1
    double         min_dotclock;
d1192 6
d1199 5
d1206 1
a1206 35


	if (!RADEONProbePLLParameters(pScrn)) {
	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		       "Video BIOS not detected, using default PLL parameters!\n");

	    switch (info->Chipset) {
		case PCI_CHIP_R200_QL:
		case PCI_CHIP_R200_QN:
		case PCI_CHIP_R200_QO:
		case PCI_CHIP_R200_BB:
		    pll->reference_freq = 2700;
		    pll->reference_div  = 12;
		    pll->xclk           = 27500;
		    break;
		case PCI_CHIP_RV250_Id:
		case PCI_CHIP_RV250_Ie:
		case PCI_CHIP_RV250_If:
		case PCI_CHIP_RV250_Ig:
		    pll->reference_freq = 2700;
		    pll->reference_div  = 12;
		    pll->xclk           = 24975;
		    break;
		case PCI_CHIP_RV200_QW:
		    pll->reference_freq = 2700;
		    pll->reference_div  = 12;
		    pll->xclk           = 23000;
		    break;
		default:
		    pll->reference_freq = 2700;
		    pll->reference_div  = 67;
		    pll->xclk           = 16615;
		    break;
	    }
        }
d1220 7
a1226 19
    /* (Some?) Radeon BIOSes seem too lie about their minimum dot
     * clocks.  Allow users to override the detected minimum dot clock
     * value (e.g., and allow it to be suitable for TV sets).
     */
    if (xf86GetOptValFreq(info->Options, OPTION_MIN_DOTCLOCK,
			  OPTUNITS_MHZ, &min_dotclock)) {
	if (min_dotclock < 12 || min_dotclock*100 >= pll->max_pll_freq) {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Illegal minimum dotclock specified %.2f MHz "
		       "(option ignored)\n",
		       min_dotclock);
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
		       "Forced minimum dotclock to %.2f MHz "
		       "(instead of detected %.2f MHz)\n",
		       min_dotclock, ((double)pll->min_pll_freq/1000));
	    pll->min_pll_freq = min_dotclock * 1000;
	}
    }
d1236 1
a1236 1
    if (!xf86SetDepthBpp(pScrn, 0, 0, 0, Support32bppFb))
a1319 38
static void RADEONGetVRamType(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info   = RADEONPTR(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    CARD32 tmp;

    if (info->IsIGP || (info->ChipFamily >= CHIP_FAMILY_R300) ||
	(INREG(RADEON_MEM_SDRAM_MODE_REG) & (1<<30)))
	info->IsDDR = TRUE;
    else
	info->IsDDR = FALSE;

    tmp = INREG(RADEON_MEM_CNTL);
    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {
	tmp &=  R300_MEM_NUM_CHANNELS_MASK;
	switch (tmp) {
	case 0: info->RamWidth = 64; break;
	case 1: info->RamWidth = 128; break;
	case 2: info->RamWidth = 256; break;
	default: info->RamWidth = 128; break;
	}
    } else if ((info->ChipFamily == CHIP_FAMILY_RV100) ||
	       (info->ChipFamily == CHIP_FAMILY_RS100) ||
	       (info->ChipFamily == CHIP_FAMILY_RS200)){
	if (tmp & RV100_HALF_MODE) info->RamWidth = 32;
	else info->RamWidth = 64;
    } else {
	if (tmp & RADEON_MEM_NUM_CHANNELS_MASK) info->RamWidth = 128;
	else info->RamWidth = 64;
    }

    /* This may not be correct, as some cards can have half of channel disabled
     * ToDo: identify these cases
     */
}

d1330 1
d1332 1
a1332 5
    unsigned char *RADEONMMIO = info->MMIO;
#ifdef XF86DRI
    const char    *s;
    CARD32         agpCommand;
#endif
a1362 2
    info->IsMobility = FALSE;
    info->IsIGP = FALSE;
d1366 1
a1366 2
	info->IsMobility = TRUE;
	info->ChipFamily = CHIP_FAMILY_RV100;
d1371 1
a1371 22
	info->ChipFamily = CHIP_FAMILY_RV100;
	break;

    case PCI_CHIP_RS100_4336:
	info->IsMobility = TRUE;
    case PCI_CHIP_RS100_4136:
	info->ChipFamily = CHIP_FAMILY_RS100;
	info->IsIGP = TRUE;
	break;

    case PCI_CHIP_RS200_4337:
	info->IsMobility = TRUE;
    case PCI_CHIP_RS200_4137:
	info->ChipFamily = CHIP_FAMILY_RS200;
	info->IsIGP = TRUE;
	break;

    case PCI_CHIP_RS250_4437:
	info->IsMobility = TRUE;
    case PCI_CHIP_RS250_4237:
	info->ChipFamily = CHIP_FAMILY_RS200;
	info->IsIGP = TRUE;
a1374 1
    case PCI_CHIP_R200_BC:
d1376 3
d1381 7
a1390 3
    case PCI_CHIP_RADEON_LW:
    case PCI_CHIP_RADEON_LX:
	info->IsMobility = TRUE;
d1396 12
d1409 1
d1412 1
a1412 21
	info->IsMobility = TRUE;
    case PCI_CHIP_RV250_If:
    case PCI_CHIP_RV250_Ig:
	info->ChipFamily = CHIP_FAMILY_RV250;
	break;

    case PCI_CHIP_RS300_5835:
	info->IsMobility = TRUE;
    case PCI_CHIP_RS300_5834:
	info->ChipFamily = CHIP_FAMILY_RS300;
	info->IsIGP = TRUE;
	break;

    case PCI_CHIP_RV280_5C61:
    case PCI_CHIP_RV280_5C63:
	info->IsMobility = TRUE;
    case PCI_CHIP_RV280_5960:
    case PCI_CHIP_RV280_5961:
    case PCI_CHIP_RV280_5962:
    case PCI_CHIP_RV280_5964:
	info->ChipFamily = CHIP_FAMILY_RV280;
a1425 27
    case PCI_CHIP_RV350_NP:
    case PCI_CHIP_RV350_NQ:
    case PCI_CHIP_RV350_NR:
    case PCI_CHIP_RV350_NS:
    case PCI_CHIP_RV350_NT:
    case PCI_CHIP_RV350_NV:
	info->IsMobility = TRUE;
    case PCI_CHIP_RV350_AP:
    case PCI_CHIP_RV350_AQ:
    case PCI_CHIP_RV360_AR:
    case PCI_CHIP_RV350_AS:
    case PCI_CHIP_RV350_AT:
    case PCI_CHIP_RV350_AV:
	info->ChipFamily = CHIP_FAMILY_RV350;
        break;

    case PCI_CHIP_R350_AH:
    case PCI_CHIP_R350_AI:
    case PCI_CHIP_R350_AJ:
    case PCI_CHIP_R350_AK:
    case PCI_CHIP_R350_NH:
    case PCI_CHIP_R350_NI:
    case PCI_CHIP_R350_NK:
    case PCI_CHIP_R360_NJ:
	info->ChipFamily = CHIP_FAMILY_R350;
        break;

d1432 27
d1462 1
a1462 1
    info->LinearAddr   = info->PciInfo->memBase[0] & 0xfe000000;
d1466 1
a1466 1
		   "Linear address override, using 0x%08lx instead of 0x%08lx\n",
d1479 17
d1501 1
a1501 1
		   "BIOS address override, using 0x%08lx instead of 0x%08lx\n",
d1512 3
a1518 26
    else if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
	     (info->ChipFamily == CHIP_FAMILY_RS200) ||
	     (info->ChipFamily == CHIP_FAMILY_RS300)) {
        CARD32 tom = INREG(RADEON_NB_TOM);
        pScrn->videoRam = (((tom >> 16) -
			    (tom & 0xffff) + 1) << 6);
	OUTREG(RADEON_MC_FB_LOCATION, tom);
	OUTREG(RADEON_DISPLAY_BASE_ADDR, (tom & 0xffff) << 16);
	OUTREG(RADEON_DISPLAY2_BASE_ADDR, (tom & 0xffff) << 16);
	OUTREG(RADEON_OV0_BASE_ADDR, (tom & 0xffff) << 16);

	/* This is supposed to fix the crtc2 noise problem.
	*/
	OUTREG(RADEON_GRPH2_BUFFER_CNTL,
	       INREG(RADEON_GRPH2_BUFFER_CNTL) & ~0x7f0000);

	if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
	    (info->ChipFamily == CHIP_FAMILY_RS200)) {
	    /* This is to workaround the asic bug for RMX, some versions
	       of BIOS dosen't have this register initialized correctly.
	    */
	    OUTREGP(RADEON_CRTC_MORE_CNTL, RADEON_CRTC_H_CUTOFF_ACTIVE_EN,
		    ~RADEON_CRTC_H_CUTOFF_ACTIVE_EN);
	}

    }
d1528 2
a1529 1
        RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
d1532 2
d1551 2
d1554 7
a1560 1
    RADEONGetVRamType(pScrn);
d1573 1
a1573 1
	       "VideoRAM: %d kByte (%d bit %s SDRAM)\n", pScrn->videoRam, info->RamWidth, info->IsDDR?"DDR":"SDR");
d1577 3
a1579 16

    /* There are signatures in BIOS and PCI-SSID for a PCI card, but
     * they are not very reliable.  Following detection method works for
     * all cards tested so far.  Note, checking AGP_ENABLE bit after
     * drmAgpEnable call can also give the correct result.  However,
     * calling drmAgpEnable on a PCI card can cause some strange lockup
     * when the server restarts next time.
     */

    agpCommand = pciReadLong(info->PciTag, RADEON_AGP_COMMAND_PCI_CONFIG);
    pciWriteLong(info->PciTag, RADEON_AGP_COMMAND_PCI_CONFIG,
		 agpCommand | RADEON_AGP_ENABLE);
    if (pciReadLong(info->PciTag, RADEON_AGP_COMMAND_PCI_CONFIG)
	& RADEON_AGP_ENABLE) {
	info->IsPCI = FALSE; 
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "AGP card detected\n");
d1581 47
a1627 19
	info->IsPCI = TRUE; 
	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "PCI card detected\n");
    }
    pciWriteLong(info->PciTag, RADEON_AGP_COMMAND_PCI_CONFIG, agpCommand);

    if ((s = xf86GetOptValString(info->Options, OPTION_BUS_TYPE))) {
	if (strcmp(s, "AGP") == 0) {
	    info->IsPCI = FALSE;
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Forced into AGP mode\n");
	} else if (strcmp(s, "PCI") == 0) {
	    info->IsPCI = TRUE;
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Forced into PCI mode\n");
	} else if (strcmp(s, "PCIE") == 0) {
	    info->IsPCI = TRUE;
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       "PCI Express not supported yet, using PCI mode\n");
	} else {
	    xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		       "Invalid BusType option, using detected type\n");
a1628 6
    } else if (xf86ReturnOptValBool(info->Options, OPTION_IS_PCI, FALSE)) {
	info->IsPCI = TRUE;
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG, "Forced into PCI mode\n");
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "ForcePCIMode is deprecated -- "
		   "use BusType option instead\n");
a1659 3

    /* read back to improve reliability on some cards. */
    val = INREG(info->DDCReg);
d1675 17
d1721 107
d1913 1
a1913 1
	if ((((*new)->HDisplay < p->HDisplay) &&
d1932 1
a1932 1
	}
d1958 1
a1958 1
/* When no mode provided in config file, this will add all modes supported in
d2068 1
a2068 1

d2106 1
a2106 1
    if (pScrn->monitor->DDC && !info->UseBiosDividers) {
d2110 1
a2110 1
	if ((DisplayType != MT_CRT) && !info->IsSecondary) {
d2196 1
a2196 1
	    /*
d2298 2
a2299 1
/* FP mode initialization routine for using on-chip RMX to scale
a2306 1
    DisplayModePtr  p, tmp;
d2317 1
a2317 1

d2349 1
a2349 1
	new->VSyncEnd   = new->VSyncStart + info->VSyncWidth;
a2376 38
    /* add in all default vesa modes smaller than panel size, used for randr*/
    for (p = pScrn->monitor->Modes; p && p->next; p = p->next->next) {
	if ((p->HDisplay <= info->PanelXRes) && (p->VDisplay <= info->PanelYRes)) {
	    tmp = first;
	    while (tmp) {
		if ((p->HDisplay == tmp->HDisplay) && (p->VDisplay == tmp->VDisplay)) break;
		tmp = tmp->next;
	    }
	    if (!tmp) {
		new             = xnfcalloc(1, sizeof(DisplayModeRec));
		new->name       = xnfalloc(strlen(p->name) + 1);
		strcpy(new->name, p->name);
		new->HDisplay   = p->HDisplay;
		new->VDisplay   = p->VDisplay;

		/* These values are effective values after expansion They are
		 * not really used to set CRTC registers.
		 */
		new->HTotal     = info->PanelXRes + info->HBlank;
		new->HSyncStart = info->PanelXRes + info->HOverPlus;
		new->HSyncEnd   = new->HSyncStart + info->HSyncWidth;
		new->VTotal     = info->PanelYRes + info->VBlank;
		new->VSyncStart = info->PanelYRes + info->VOverPlus;
		new->VSyncEnd   = new->VSyncStart + info->VSyncWidth;
		new->Clock      = info->DotClock;
		new->Flags     |= RADEON_USE_RMX;

		new->type      |= M_T_DEFAULT;

		new->next       = NULL;
		new->prev       = last;

		last->next = new;
		last = new;
	    }
	}
    }

d2500 2
a2501 2
    char            *s;
    char            **clone_mode_names = NULL;
a2502 1
    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
d2527 2
a2528 2
    clockRanges->interlaceAllowed  = (info->CloneType == MT_CRT);
    clockRanges->doubleScanAllowed = (info->CloneType == MT_CRT);
d2539 1
a2539 1
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Clone mode %s in config file is used\n", clone_mode_names[0]);
d2543 4
a2546 9
    for (i = 0; i < count; i++) {
	if (sscanf(clone_mode_names[i], "%dx%d",
		   &tmp_hdisplay, &tmp_vdisplay) == 2) {
	    if (pScrn->display->virtualX < tmp_hdisplay)
		pScrn->display->virtualX = tmp_hdisplay;
	    if (pScrn->display->virtualY < tmp_vdisplay)
		pScrn->display->virtualY = tmp_vdisplay;
	}
    }
d2579 36
a2614 13
    pScrn->monitor->DDC = pRADEONEnt->MonInfo2;
    if (pScrn->monitor->DDC) {
        if ((pScrn->monitor->nVrefresh == 0) || (pScrn->monitor->nHsync == 0)) {
            if (pScrn->monitor->nHsync == 0)
                RADEONSetSyncRangeFromEdid(pScrn, 1);
            if (pScrn->monitor->nVrefresh == 0)
                RADEONSetSyncRangeFromEdid(pScrn, 0);
        }
    } else if (info->ddc_mode) {
        ddc_mode = FALSE;
        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
                   "No DDC data available for clone mode, "
                   "DDCMode option is dismissed\n");
d2619 2
a2620 2
	    xf86ValidateModes(pScrn, pScrn->monitor->Modes,
			      clone_mode_names,
d2630 1
a2630 1
			      info->FbMapSize,
d2634 1
a2634 1
	info->IsSecondary = TRUE; /*fake secondary head*/
d2637 1
a2637 1
	info->IsSecondary = FALSE;
d2642 2
a2643 16
	if (modesFound < 1 && info->CloneType != MT_CRT) {
	    modesFound =
		xf86ValidateModes(pScrn, pScrn->monitor->Modes,
				  clone_mode_names,
				  clockRanges,
				  NULL,                     /* linePitches */
				  8 * 64,                   /* minPitch */
				  8 * 1024,                 /* maxPitch */
				  64 * pScrn->bitsPerPixel, /* pitchInc */
				  128,                      /* minHeight */
				  2048,                     /* maxHeight */
				  pScrn->display->virtualX,
				  pScrn->display->virtualY,
				  info->FbMapSize,
				  LOOKUP_BEST_REFRESH);
        }
a2646 2
        int valid = 0;
        save_mode = pScrn->modes;
a2649 1

d2655 13
a2667 17
	    if (pScrn->modes->Clock != 0.0) {

		clone_mode = xnfcalloc (1, sizeof (DisplayModeRec));
		if (!clone_mode) break;
		memcpy(clone_mode, pScrn->modes, sizeof(DisplayModeRec));
		clone_mode->name = xnfalloc(strlen(pScrn->modes->name) + 1);
		strcpy(clone_mode->name, pScrn->modes->name);

		if (!info->CurCloneMode) {
		    info->CloneModes = clone_mode;
		    info->CurCloneMode = clone_mode;
		    clone_mode->prev = NULL;
		} else {
		    clone_mode->prev = tmp_mode;
		    clone_mode->prev->next = clone_mode;
		}
		valid++;
d2669 2
a2670 3
		tmp_mode = clone_mode;
		clone_mode->next = NULL;
	    }
d2672 2
a2674 13

	/* no longer needed, free it */
	pScrn->modes = save_mode;
	while (pScrn->modes)
	  xf86DeleteMode(&pScrn->modes, pScrn->modes);
	pScrn->modes = NULL;

	/* modepool is no longer needed, free it */
	while (pScrn->modePool)
	  xf86DeleteMode(&pScrn->modePool, pScrn->modePool);
	pScrn->modePool = NULL;

	modesFound = valid;
d2689 1
d2706 4
d2722 4
a2725 2
    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
    char           *s;
a2756 4
    /* don't use RMX if we have a dual-tdms panels */
   if (pRADEONEnt->MonType2 == MT_DFP)
	info->ddc_mode = TRUE;

d2770 5
d2798 3
a2800 7
	       "Validating modes on %s head ---------\n",
	       info->IsSecondary ? "Secondary" : "Primary");

    if (info->IsSecondary)
        pScrn->monitor->DDC = pRADEONEnt->MonInfo2;
    else
        pScrn->monitor->DDC = pRADEONEnt->MonInfo1;
d2802 1
a2808 53
    if ((info->DisplayType == MT_DFP) ||
	(info->DisplayType == MT_LCD)) {
	if ((s = xf86GetOptValString(info->Options, OPTION_PANEL_SIZE))) {
	    int PanelX, PanelY;
	    DisplayModePtr  tmp_mode         = NULL;
	    if (sscanf(s, "%dx%d", &PanelX, &PanelY) == 2) {
		info->PanelXRes = PanelX;
		info->PanelYRes = PanelY;
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			   "Panel size is forced to: %s\n", s);

		/* We can't trust BIOS or DDC timings anymore,
		   Use whatever specified in the Modeline.
		   If no Modeline specified, we'll just pick the VESA mode at
		   60Hz refresh rate which is likely to be the best for a flat panel.
		*/
		info->ddc_mode = FALSE;
		pScrn->monitor->DDC = NULL;
		tmp_mode = pScrn->monitor->Modes;
		while(tmp_mode) {
		    if ((tmp_mode->HDisplay == PanelX) &&
			(tmp_mode->VDisplay == PanelY)) {

			float  refresh =
			    (float)tmp_mode->Clock * 1000.0 / tmp_mode->HTotal / tmp_mode->VTotal;
			if ((abs(60.0 - refresh) < 1.0) ||
			    (tmp_mode->type == 0)) {
			    info->HBlank     = tmp_mode->HTotal - tmp_mode->HDisplay;
			    info->HOverPlus  = tmp_mode->HSyncStart - tmp_mode->HDisplay;
			    info->HSyncWidth = tmp_mode->HSyncEnd - tmp_mode->HSyncStart;
			    info->VBlank     = tmp_mode->VTotal - tmp_mode->VDisplay;
			    info->VOverPlus  = tmp_mode->VSyncStart - tmp_mode->VDisplay;
			    info->VSyncWidth = tmp_mode->VSyncEnd - tmp_mode->VSyncStart;
			    info->DotClock   = tmp_mode->Clock;
			    info->Flags = 0;
			    break;
			}
		    }
		    tmp_mode = tmp_mode->next;
		}
		if (info->DotClock == 0) {
		    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
			       "No valid timing info for specified panel size.\n"
			       "Please specify the Modeline for this panel\n");
		    return FALSE;
		}
	    } else {
		xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
			   "Invalid PanelSize value: %s\n", s);
	    }
	}
    }

d2810 12
a2821 12
        /* If we still don't know sync range yet, let's try EDID.
         *
         * Note that, since we can have dual heads, Xconfigurator
         * may not be able to probe both monitors correctly through
         * vbe probe function (RADEONProbeDDC). Here we provide an
         * additional way to auto-detect sync ranges if they haven't
         * been added to XF86Config manually.
         */
        if (pScrn->monitor->nHsync <= 0)
            RADEONSetSyncRangeFromEdid(pScrn, 1);
        if (pScrn->monitor->nVrefresh <= 0)
            RADEONSetSyncRangeFromEdid(pScrn, 0);
a2823 1
    /* Get mode information */
d2825 1
a2838 1

a2867 1

d2884 2
a2885 48
	if (info->DisplayType != MT_CRT) {

	    /* some panels have DDC, but don't have internal scaler.
	     * in this case, we need to validate additional modes
	     * by using on-chip RMX.
	     */
	    int user_modes_asked = 0, user_modes_found = 0, i;
	    DisplayModePtr  tmp_mode = pScrn->modes;
	    while (pScrn->display->modes[user_modes_asked]) user_modes_asked++;
	    if (tmp_mode) {
		for (i = 0; i < modesFound; i++) {
		    if (tmp_mode->type & M_T_USERDEF) user_modes_found++;
		    tmp_mode = tmp_mode->next;
		}
	    }

	    if ((modesFound <= 1) || (user_modes_found < user_modes_asked)) {
		/* when panel size is not valid, try to validate
		 * mode using xf86ValidateModes routine
		 * This can happen when DDC is disabled.
		 */
		if (info->PanelXRes < 320 || info->PanelYRes < 200)
		    modesFound =
			xf86ValidateModes(pScrn,
					  pScrn->monitor->Modes,
					  pScrn->display->modes,
					  clockRanges,
					  NULL,                  /* linePitches */
					  8 * 64,                /* minPitch */
					  8 * 1024,              /* maxPitch */
					  64 * pScrn->bitsPerPixel, /* pitchInc */
					  128,                   /* minHeight */
					  2048,                  /* maxHeight */
					  pScrn->display->virtualX,
					  pScrn->display->virtualY,
					  info->FbMapSize,
					  LOOKUP_BEST_REFRESH);
		else if (!info->IsSecondary)
		    modesFound = RADEONValidateFPModes(pScrn, pScrn->display->modes);
	    }
        }

	/* Setup the screen's clockRanges for the VidMode extension */
	if (!pScrn->clockRanges) {
	    pScrn->clockRanges = xnfcalloc(sizeof(*(pScrn->clockRanges)), 1);
	    memcpy(pScrn->clockRanges, clockRanges, sizeof(*clockRanges));
	    pScrn->clockRanges->strategy = LOOKUP_BEST_REFRESH;
	}
d2900 5
d2918 1
a2918 1
		    pScrn->display->virtualX = clone_mode->HDisplay;
d2920 1
a2920 1
		    pScrn->display->virtualY = clone_mode->VDisplay;
d2935 11
a2945 1
    if (!xf86LoadSubModule(pScrn, "fb")) return FALSE;
d2947 1
d2949 3
d3027 1
a3027 1
    info->gartSize      = RADEON_DEFAULT_GART_SIZE;
d3030 1
a3030 1
    info->gartTexSize   = RADEON_DEFAULT_GART_TEX_SIZE;
d3053 1
a3053 1
	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
a3055 1
    }
d3057 18
a3074 11
    if (xf86GetOptValInteger(info->Options,
			     OPTION_GART_SIZE, (int *)&(info->gartSize))) {
	switch (info->gartSize) {
	case 4:
	case 8:
	case 16:
	case 32:
	case 64:
	case 128:
	case 256:
	    break;
d3076 8
a3083 4
	default:
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Illegal GART size: %d MB\n", info->gartSize);
	    return FALSE;
a3084 1
    }
d3086 16
a3101 7
    if (xf86GetOptValInteger(info->Options,
			     OPTION_RING_SIZE, &(info->ringSize))) {
	if (info->ringSize < 1 || info->ringSize >= (int)info->gartSize) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Illegal ring buffer size: %d MB\n",
		       info->ringSize);
	    return FALSE;
a3102 1
    }
d3104 2
a3105 3
    if (xf86GetOptValInteger(info->Options,
			     OPTION_BUFFER_SIZE, &(info->bufSize))) {
	if (info->bufSize < 1 || info->bufSize >= (int)info->gartSize) {
d3107 1
a3107 2
		       "Illegal vertex/indirect buffers size: %d MB\n",
		       info->bufSize);
a3109 9
	if (info->bufSize > 2) {
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Illegal vertex/indirect buffers size: %d MB\n",
		       info->bufSize);
	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		       "Clamping vertex/indirect buffers size to 2 MB\n");
	    info->bufSize = 2;
	}
    }
d3111 1
a3111 5
    if (info->ringSize + info->bufSize + info->gartTexSize >
	(int)info->gartSize) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Buffers are too big for requested GART space\n");
	return FALSE;
a3113 2
    info->gartTexSize = info->gartSize - (info->ringSize + info->bufSize);

d3132 1
a3132 1
					      OPTION_NO_BACKBUFFER,
d3173 1
a3173 2
    const char *s;

a3184 1
    info->MMIO         = NULL;
d3186 1
a3186 1
    info->pEnt         = xf86GetEntityInfo(pScrn->entityList[pScrn->numEntities - 1]);
a3192 19
    info->MMIOAddr   = info->PciInfo->memBase[2] & 0xffffff00;
    if (info->pEnt->device->IOBase) {
	xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
		   "MMIO address override, using 0x%08lx instead of 0x%08lx\n",
		   info->pEnt->device->IOBase,
		   info->MMIOAddr);
	info->MMIOAddr = info->pEnt->device->IOBase;
    } else if (!info->MMIOAddr) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid MMIO address\n");
	goto fail1;
    }
    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
	       "MMIO registers at 0x%08lx\n", info->MMIOAddr);

    if(!RADEONMapMMIO(pScrn)) {
	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
		   "Memory map the MMIO region failed\n");
	goto fail1;
    }
d3203 1
a3203 1
     */
d3207 4
a3210 4
    if (xf86IsEntityShared(info->pEnt->index)) {
	if (xf86IsPrimInitDone(info->pEnt->index)) {

	    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
d3213 5
a3217 1
	    if (!pRADEONEnt->HasSecondary) {
d3221 1
a3221 1
		goto fail2;
d3225 2
a3226 1
	    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
d3228 3
a3230 1
	    xf86SetPrimInitDone(info->pEnt->index);
d3232 1
d3234 2
a3243 1
	if(info->MMIO) RADEONUnmapMMIO(pScrn);
d3251 1
a3251 1
	goto fail2;
a3293 12
    info->DispPriority = 1;
    if ((s = xf86GetOptValString(info->Options, OPTION_DISP_PRIORITY))) {
	if (strcmp(s, "AUTO") == 0) {
	    info->DispPriority = 1;
	} else if (strcmp(s, "BIOS") == 0) {
	    info->DispPriority = 0;
	} else if (strcmp(s, "HIGH") == 0) {
	    info->DispPriority = 2;
	} else
	    info->DispPriority = 1;
    }

d3324 1
a3324 2
    RADEONPreInitDDC(pScrn);

d3327 6
d3334 1
a3334 2
    if (info->DisplayType == MT_DFP)
	RADEONGetTMDSInfo(pScrn);
a3359 3
    if(info->MMIO) RADEONUnmapMMIO(pScrn);
    info->MMIO = NULL;

d3368 1
a3368 4
    if (info->IsSecondary) {
        RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
	pRADEONEnt->HasSecondary = FALSE;
    }
a3379 5

 fail2:
    if(info->MMIO) RADEONUnmapMMIO(pScrn);
    info->MMIO = NULL;
 fail1:
a3380 1

d3483 1
a3483 1

d3594 2
a3595 2
				   established, but before fbScreenInit is
				   called.  fbScreenInit will eventually
d3618 1
a3618 10
	} else if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
		   (info->ChipFamily == CHIP_FAMILY_RS200) ||
		   (info->ChipFamily == CHIP_FAMILY_RS300)) {
	    info->directRenderingEnabled = FALSE;
	    xf86DrvMsg(scrnIndex, X_WARNING,
		       "Direct rendering not yet supported on "
		       "IGP320/330/340/350, 7000, 9000 integrated chips\n");
	} else if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		   (info->ChipFamily == CHIP_FAMILY_R350) ||
		   (info->ChipFamily == CHIP_FAMILY_RV350)) {
d3628 1
a3628 1
		if (xf86IsEntityShared(info->pEnt->index)) {
d3630 1
a3630 1
		    xf86DrvMsg(scrnIndex, X_WARNING,
d3640 10
d3655 1
d3661 26
d3706 1
d3709 1
d3757 1
a3757 1
		   "Using %d MB GART aperture\n", info->gartSize);
d3763 1
a3763 1
		   "Using %d MB for GART textures\n", info->gartTexSize);
d3780 1
a3780 1
	    info->textureSize = info->FbMapSize - 3 * bufferSize - depthSize;
d4011 1
a4011 1
		       "Using hardware cursor (scanline %ld)\n",
d4041 1
d4043 1
d4061 1
a4061 1
				/* Now that mi, fb, drm and others have
a4066 4
	if ((info->DispPriority == 1) && (!info->IsPCI)) {
	    /* we need to re-calculate bandwidth because of AGPMode difference. */
	    RADEONInitDispBandwidth(pScrn);
	}
d4106 3
a4108 3
	info->ChipFamily != CHIP_FAMILY_R300 &&
	info->ChipFamily != CHIP_FAMILY_R350 &&
	info->ChipFamily != CHIP_FAMILY_RV350) {
d4110 3
a4112 1
        RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
a4173 2
    OUTREG(RADEON_DISP_MERGE_CNTL,      restore->disp_merge_cntl);
    OUTREG(RADEON_CRTC_MORE_CNTL,       restore->crtc_more_cntl);
d4191 2
a4192 5
    OUTREG(RADEON_TV_DAC_CNTL, 0x00280203);
    if ((info->ChipFamily == CHIP_FAMILY_R200) ||
	(info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {
d4196 7
a4211 1
    OUTREG(RADEON_DISP2_MERGE_CNTL,      restore->disp2_merge_cntl);
d4213 1
a4213 2
    if ((info->DisplayType == MT_DFP && info->IsSecondary) ||
	info->CloneType == MT_DFP) {
d4218 1
a4236 1
    OUTREG(RADEON_TMDS_TRANSMITTER_CNTL,restore->tmds_transmitter_cntl);
d4241 1
a4241 20
    /* old AIW Radeon has some BIOS initialization problem
     * with display buffer underflow, only occurs to DFP
     */
    if (!info->HasCRTC2)
	OUTREG(RADEON_GRPH_BUFFER_CNTL,
	       INREG(RADEON_GRPH_BUFFER_CNTL) & ~0x7f0000);

    if (info->DisplayType != MT_DFP) {
	unsigned long tmpPixclksCntl = INPLL(pScrn, RADEON_PIXCLKS_CNTL);
        OUTREG(RADEON_BIOS_5_SCRATCH, restore->bios_5_scratch);

	if (info->IsMobility || info->IsIGP) {
	    /* Asic bug, when turning off LVDS_ON, we have to make sure
	       RADEON_PIXCLK_LVDS_ALWAYS_ON bit is off
	    */
	    if (!(restore->lvds_gen_cntl & RADEON_LVDS_ON)) {
		OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL, 0, ~RADEON_PIXCLK_LVDS_ALWAYS_ONb);
	    }
	}

a4256 6

	if (info->IsMobility || info->IsIGP) {
	    if (!(restore->lvds_gen_cntl & RADEON_LVDS_ON)) {
		OUTPLL(RADEON_PIXCLKS_CNTL, tmpPixclksCntl);
	    }
	}
a4318 12
    if (info->IsMobility) {
        /* A temporal workaround for the occational blanking on certain laptop panels.
           This appears to related to the PLL divider registers (fail to lock?).
	   It occurs even when all dividers are the same with their old settings.
           In this case we really don't need to fiddle with PLL registers.
           By doing this we can avoid the blanking problem with some panels.
        */
        if ((restore->ppll_ref_div == (INPLL(pScrn, RADEON_PPLL_REF_DIV) & RADEON_PPLL_REF_DIV_MASK)) &&
	    (restore->ppll_div_3 == (INPLL(pScrn, RADEON_PPLL_DIV_3) & (RADEON_PPLL_POST3_DIV_MASK | RADEON_PPLL_FB3_DIV_MASK))))
            return;
    }

d4336 1
a4336 3
    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {
d4347 1
a4347 1
		    (restore->ppll_ref_div << R300_PPLL_REF_DIV_ACC_SHIFT),
a4375 5
    xf86DrvMsg(0, X_INFO, "Wrote: rd=%d, fd=%d, pd=%d\n",
	       restore->ppll_ref_div & RADEON_PPLL_REF_DIV_MASK,
	       restore->ppll_div_3 & RADEON_PPLL_FB3_DIV_MASK,
	       (restore->ppll_div_3 & RADEON_PPLL_POST3_DIV_MASK) >> 16);

d4484 3
a4486 2
    RADEONInfoPtr      info = RADEONPTR(pScrn);
    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
d4493 4
a4496 1
	RADEONRestoreFPRegisters(pScrn, restore);
d4501 3
d4516 1
a4516 1
	if (!pRADEONEnt->RestorePrimary  && !info->IsSwitching)
d4526 1
d4530 5
a4534 1
	    RADEONRestoreFPRegisters(pScrn, &restore0);
d4552 4
a4555 1
	    RADEONRestoreFPRegisters(pScrn, restore);
a4585 2
    save->grph_buffer_cntl   = INREG(RADEON_GRPH_BUFFER_CNTL);
    save->grph2_buffer_cntl  = INREG(RADEON_GRPH2_BUFFER_CNTL);
a4625 2
    save->disp_merge_cntl      = INREG(RADEON_DISP_MERGE_CNTL);
    save->crtc_more_cntl       = INREG(RADEON_CRTC_MORE_CNTL);
a4643 7
    save->tmds_transmitter_cntl= INREG(RADEON_TMDS_TRANSMITTER_CNTL);
    save->bios_5_scratch       = INREG(RADEON_BIOS_5_SCRATCH);

    if (info->ChipFamily == CHIP_FAMILY_RV280) {
	/* bit 22 of TMDS_PLL_CNTL is read-back inverted */
	save->tmds_pll_cntl ^= (1 << 22);
    }
d4668 1
a4668 1
    save->disp2_merge_cntl      = INREG(RADEON_DISP2_MERGE_CNTL);
d4738 5
a4742 1
	RADEONSaveFPRegisters(pScrn, save);
a4815 2
    OUTREG(RADEON_GRPH_BUFFER_CNTL, restore->grph_buffer_cntl);
    OUTREG(RADEON_GRPH2_BUFFER_CNTL, restore->grph2_buffer_cntl);
d4821 1
a4821 1
    if ((xf86IsEntityShared(info->pEnt->index) || info->Clone)
d4849 2
a4850 1
        RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);
d4854 4
a4892 316
/* Calculate display buffer watermark to prevent buffer underflow */
static void RADEONInitDispBandwidth(ScrnInfoPtr pScrn)
{
    RADEONInfoPtr  info       = RADEONPTR(pScrn);
    RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);
    unsigned char *RADEONMMIO = info->MMIO;
    RADEONInfoPtr  info2 = NULL;

    DisplayModePtr mode1, mode2;

    CARD32 temp, data, mem_trcd, mem_trp, mem_tras, mem_trbs=0;
    float mem_tcas;
    int k1, c;
    CARD32 MemTrcdExtMemCntl[4]     = {1, 2, 3, 4};
    CARD32 MemTrpExtMemCntl[4]      = {1, 2, 3, 4};
    CARD32 MemTrasExtMemCntl[8]     = {1, 2, 3, 4, 5, 6, 7, 8};

    CARD32 MemTrcdMemTimingCntl[8]     = {1, 2, 3, 4, 5, 6, 7, 8};
    CARD32 MemTrpMemTimingCntl[8]      = {1, 2, 3, 4, 5, 6, 7, 8};
    CARD32 MemTrasMemTimingCntl[16]    = {4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19};

    float MemTcas[8]  = {0, 1, 2, 3, 0, 1.5, 2.5, 0};
    float MemTcas2[8] = {0, 1, 2, 3, 4, 5, 6, 7};
    float MemTrbs[8]  = {1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5};

    float mem_bw, peak_disp_bw;
    float min_mem_eff = 0.8;
    float sclk_eff, sclk_delay;
    float mc_latency_mclk, mc_latency_sclk, cur_latency_mclk, cur_latency_sclk;
    float disp_latency, disp_latency_overhead, disp_drain_rate, disp_drain_rate2;
    float pix_clk, pix_clk2; /* in MHz */
    int cur_size = 16;       /* in octawords */
    int critical_point, critical_point2;
    int stop_req, max_stop_req;
    float read_return_rate, time_disp1_drop_priority;

    if (pRADEONEnt->pSecondaryScrn) {
	if (info->IsSecondary) return;
	info2 = RADEONPTR(pRADEONEnt->pSecondaryScrn);
    }  else if (info->Clone) info2 = info;

    /*
     * Determine if there is enough bandwidth for current display mode
     */
    mem_bw = info->mclk * (info->RamWidth / 8) * (info->IsDDR ? 2 : 1);

    mode1 = info->CurrentLayout.mode;
    if (info->Clone)
	mode2 = info->CurCloneMode;
    else if ((pRADEONEnt->HasSecondary) && info2)
	mode2 = info2->CurrentLayout.mode;
    else
	mode2 = NULL;

    pix_clk = mode1->Clock/1000.0;
    if (mode2)
	pix_clk2 = mode2->Clock/1000.0;
    else
	pix_clk2 = 0;

    peak_disp_bw = (pix_clk * info->CurrentLayout.pixel_bytes);
    if (info2)
	peak_disp_bw +=	(pix_clk2 * info2->CurrentLayout.pixel_bytes);

    if (peak_disp_bw >= mem_bw * min_mem_eff) {
	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
		   "You may not have enough display bandwidth for current mode\n"
		   "If you have flickering problem, try to lower resolution, refresh rate, or color depth\n");
    }

    /*  CRTC1
        Set GRPH_BUFFER_CNTL register using h/w defined optimal values.
	GRPH_STOP_REQ <= MIN[ 0x7C, (CRTC_H_DISP + 1) * (bit depth) / 0x10 ]
    */
    stop_req = mode1->HDisplay * info->CurrentLayout.pixel_bytes / 16;

    /* setup Max GRPH_STOP_REQ default value */
    if ((info->ChipFamily == CHIP_FAMILY_RV100) ||
	(info->ChipFamily == CHIP_FAMILY_RV200) ||
	(info->ChipFamily == CHIP_FAMILY_RV250) ||
	(info->ChipFamily == CHIP_FAMILY_RV280) ||
	(info->ChipFamily == CHIP_FAMILY_RS100) ||
	(info->ChipFamily == CHIP_FAMILY_RS200) ||
	(info->ChipFamily == CHIP_FAMILY_RS300))
	max_stop_req = 0x5c;
    else
	max_stop_req  = 0x7c;
    if (stop_req > max_stop_req)
	stop_req = max_stop_req;

    /*  Get values from the EXT_MEM_CNTL register...converting its contents. */
    temp = INREG(RADEON_MEM_TIMING_CNTL);
    if ((info->ChipFamily == CHIP_FAMILY_RV100) || info->IsIGP) { /* RV100, M6, IGPs */
	mem_trcd      = MemTrcdExtMemCntl[(temp & 0x0c) >> 2];
	mem_trp       = MemTrpExtMemCntl[ (temp & 0x03) >> 0];
	mem_tras      = MemTrasExtMemCntl[(temp & 0x70) >> 4];
    } else { /* RV200 and later */
	mem_trcd      = MemTrcdMemTimingCntl[(temp & 0x07) >> 0];
	mem_trp       = MemTrpMemTimingCntl[ (temp & 0x700) >> 8];
	mem_tras      = MemTrasMemTimingCntl[(temp & 0xf000) >> 12];
    }

    /* Get values from the MEM_SDRAM_MODE_REG register...converting its */
    temp = INREG(RADEON_MEM_SDRAM_MODE_REG);
    data = (temp & (7<<20)) >> 20;
    if ((info->ChipFamily == CHIP_FAMILY_RV100) || info->IsIGP) { /* RV100, M6, IGPs */
	mem_tcas = MemTcas [data];
    } else {
	mem_tcas = MemTcas2 [data];
    }

    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {

	/* on the R300, Tcas is included in Trbs.
	*/
	temp = INREG(RADEON_MEM_CNTL);
	data = (R300_MEM_NUM_CHANNELS_MASK & temp);
	if (data == 2) {
	    if (R300_MEM_USE_CD_CH_ONLY & temp) {
		temp  = INREG(R300_MC_IND_INDEX);
		temp &= ~R300_MC_IND_ADDR_MASK;
		temp |= R300_MC_READ_CNTL_CD_mcind;
		OUTREG(R300_MC_IND_INDEX, temp);
		temp  = INREG(R300_MC_IND_DATA);
		data = (R300_MEM_RBS_POSITION_C_MASK & temp);
	    } else {
		temp = INREG(R300_MC_READ_CNTL_AB);
		data = (R300_MEM_RBS_POSITION_A_MASK & temp);
	    }
	} else {
	    temp = INREG(R300_MC_READ_CNTL_AB);
	    data = (R300_MEM_RBS_POSITION_A_MASK & temp);
	}

	mem_trbs = MemTrbs[data];
	mem_tcas += mem_trbs;
    }

    if ((info->ChipFamily == CHIP_FAMILY_RV100) || info->IsIGP) { /* RV100, M6, IGPs */
	/* DDR64 SCLK_EFF = SCLK for analysis */
	sclk_eff = info->sclk;
    } else {
#ifdef XF86DRI
	if (info->directRenderingEnabled)
	    sclk_eff = info->sclk - (info->agpMode * 50.0 / 3.0);
	else
#endif
	    sclk_eff = info->sclk;
    }

    /* Find the memory controller latency for the display client.
    */
    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
	(info->ChipFamily == CHIP_FAMILY_R350) ||
	(info->ChipFamily == CHIP_FAMILY_RV350)) {
	/*not enough for R350 ???*/
	/*
	if (!mode2) sclk_delay = 150;
	else {
	    if (info->RamWidth == 256) sclk_delay = 87;
	    else sclk_delay = 97;
	}
	*/
	sclk_delay = 250;
    } else {
	if ((info->ChipFamily == CHIP_FAMILY_RV100) ||
	    info->IsIGP) {
	    if (info->IsDDR) sclk_delay = 41;
	    else sclk_delay = 33;
	} else {
	    if (info->RamWidth == 128) sclk_delay = 57;
	    else sclk_delay = 41;
	}
    }

    mc_latency_sclk = sclk_delay / sclk_eff;

    if (info->IsDDR) {
	if (info->RamWidth == 32) {
	    k1 = 40;
	    c  = 3;
	} else {
	    k1 = 20;
	    c  = 1;
	}
    } else {
	k1 = 40;
	c  = 3;
    }
    mc_latency_mclk = ((2.0*mem_trcd + mem_tcas*c + 4.0*mem_tras + 4.0*mem_trp + k1) /
		       info->mclk) + (4.0 / sclk_eff);

    /*
      HW cursor time assuming worst case of full size colour cursor.
    */
    cur_latency_mclk = (mem_trp + MAX(mem_tras, (mem_trcd + 2*(cur_size - (info->IsDDR+1))))) / info->mclk;
    cur_latency_sclk = cur_size / sclk_eff;

    /*
      Find the total latency for the display data.
    */
    disp_latency_overhead = 8.0 / info->sclk;
    mc_latency_mclk = mc_latency_mclk + disp_latency_overhead + cur_latency_mclk;
    mc_latency_sclk = mc_latency_sclk + disp_latency_overhead + cur_latency_sclk;
    disp_latency = MAX(mc_latency_mclk, mc_latency_sclk);

    /*
      Find the drain rate of the display buffer.
    */
    disp_drain_rate = pix_clk / (16.0/info->CurrentLayout.pixel_bytes);
    if (info2)
	disp_drain_rate2 = pix_clk2 / (16.0/info2->CurrentLayout.pixel_bytes);
    else
	disp_drain_rate2 = 0;

    /*
      Find the critical point of the display buffer.
    */
    critical_point= (CARD32)(disp_drain_rate * disp_latency + 0.5);

    /* ???? */
    /*
    temp = (info->SavedReg.grph_buffer_cntl & RADEON_GRPH_CRITICAL_POINT_MASK) >> RADEON_GRPH_CRITICAL_POINT_SHIFT;
    if (critical_point < temp) critical_point = temp;
    */
    if (info->DispPriority == 2) {
	if (mode2) {
	    /*??some R300 cards have problem with this set to 0, when CRTC2 is enabled.*/
	    if (info->ChipFamily == CHIP_FAMILY_R300)
		critical_point += 0x10;
	    else
		critical_point = 0;
	}
	else
	    critical_point = 0;
    }

    /*
      The critical point should never be above max_stop_req-4.  Setting
      GRPH_CRITICAL_CNTL = 0 will thus force high priority all the time.
    */
    if (max_stop_req - critical_point < 4) critical_point = 0;

    temp = info->SavedReg.grph_buffer_cntl;
    temp &= ~(RADEON_GRPH_STOP_REQ_MASK);
    temp |= (stop_req << RADEON_GRPH_STOP_REQ_SHIFT);
    temp &= ~(RADEON_GRPH_START_REQ_MASK);
    if ((info->ChipFamily == CHIP_FAMILY_R350) &&
	(stop_req > 0x15)) {
	stop_req -= 0x10;
    }
    temp |= (stop_req << RADEON_GRPH_START_REQ_SHIFT);

    temp |= RADEON_GRPH_BUFFER_SIZE;
    temp &= ~(RADEON_GRPH_CRITICAL_CNTL   |
	      RADEON_GRPH_CRITICAL_AT_SOF |
	      RADEON_GRPH_STOP_CNTL);
    /*
      Write the result into the register.
    */
    OUTREG(RADEON_GRPH_BUFFER_CNTL, ((temp & ~RADEON_GRPH_CRITICAL_POINT_MASK) |
				     (critical_point << RADEON_GRPH_CRITICAL_POINT_SHIFT)));

    RADEONTRACE(("GRPH_BUFFER_CNTL from %x to %x\n",
	       info->SavedReg.grph_buffer_cntl, INREG(RADEON_GRPH_BUFFER_CNTL)));

    if (mode2) {
	stop_req = mode2->HDisplay * info2->CurrentLayout.pixel_bytes / 16;

	if (stop_req > max_stop_req) stop_req = max_stop_req;

	temp = info->SavedReg.grph2_buffer_cntl;
	temp &= ~(RADEON_GRPH_STOP_REQ_MASK);
	temp |= (stop_req << RADEON_GRPH_STOP_REQ_SHIFT);
	temp &= ~(RADEON_GRPH_START_REQ_MASK);
	if ((info->ChipFamily == CHIP_FAMILY_R350) &&
	    (stop_req > 0x15)) {
	    stop_req -= 0x10;
	}
	temp |= (stop_req << RADEON_GRPH_START_REQ_SHIFT);
	temp |= RADEON_GRPH_BUFFER_SIZE;
	temp &= ~(RADEON_GRPH_CRITICAL_CNTL   |
		  RADEON_GRPH_CRITICAL_AT_SOF |
		  RADEON_GRPH_STOP_CNTL);

	if ((info->ChipFamily == CHIP_FAMILY_RS100) ||
	    (info->ChipFamily == CHIP_FAMILY_RS200))
	    critical_point2 = 0;
	else {
	    read_return_rate = MIN(info->sclk, info->mclk*(info->RamWidth*(info->IsDDR+1)/128));
	    time_disp1_drop_priority = critical_point / (read_return_rate - disp_drain_rate);

	    critical_point2 = (CARD32)((disp_latency + time_disp1_drop_priority +
					disp_latency) * disp_drain_rate2 + 0.5);

	    if (info->DispPriority == 2) {
		if (info->ChipFamily == CHIP_FAMILY_R300)
		    critical_point2 += 0x10;
		else
		    critical_point2 = 0;
	    }

	    if (max_stop_req - critical_point2 < 4) critical_point2 = 0;

	}

	OUTREG(RADEON_GRPH2_BUFFER_CNTL, ((temp & ~RADEON_GRPH_CRITICAL_POINT_MASK) |
					  (critical_point2 << RADEON_GRPH_CRITICAL_POINT_SHIFT)));

	RADEONTRACE(("GRPH2_BUFFER_CNTL from %x to %x\n",
		     info->SavedReg.grph2_buffer_cntl, INREG(RADEON_GRPH2_BUFFER_CNTL)));
    }
}

d4904 1
d4909 6
a4914 6
    case 4:  format = 1; break;
    case 8:  format = 2; break;
    case 15: format = 3; break;      /*  555 */
    case 16: format = 4; break;      /*  565 */
    case 24: format = 5; break;      /*  RGB */
    case 32: format = 6; break;      /* xRGB */
d4921 1
a5017 10
    /* Some versions of BIOS setup CRTC_MORE_CNTL for a DFP, if we
       have a CRT here, it should be cleared to avoild a blank screen.
    */
    if (info->DisplayType == MT_CRT)
	save->crtc_more_cntl = (info->SavedReg.crtc_more_cntl &
				~(RADEON_CRTC_H_CUTOFF_ACTIVE_EN |
				  RADEON_CRTC_V_CUTOFF_ACTIVE_EN));
    else
	save->crtc_more_cntl = info->SavedReg.crtc_more_cntl;

a5018 2
    save->disp_merge_cntl = info->SavedReg.disp_merge_cntl;
    save->disp_merge_cntl &= ~RADEON_DISP_RGB_OFFSET_EN;
a5042 1
    RADEONEntPtr pRADEONEnt   = RADEONEntPriv(pScrn);
d5049 1
d5053 6
a5058 6
    case 4:  format = 1; break;
    case 8:  format = 2; break;
    case 15: format = 3; break;      /*  555 */
    case 16: format = 4; break;      /*  565 */
    case 24: format = 5; break;      /*  RGB */
    case 32: format = 6; break;      /* xRGB */
d5065 1
a5084 3
    /* always let TVDAC drive CRT2, we don't support tvout yet */
    save->dac2_cntl |= RADEON_DAC2_DAC2_CLK_SEL;
    save->disp_output_cntl = info->SavedReg.disp_output_cntl;
d5086 5
a5090 15
	info->ChipFamily == CHIP_FAMILY_R300 ||
	info->ChipFamily == CHIP_FAMILY_R350 ||
	info->ChipFamily == CHIP_FAMILY_RV350) {
	save->disp_output_cntl &= ~(RADEON_DISP_DAC_SOURCE_MASK |
				    RADEON_DISP_DAC2_SOURCE_MASK);
	if (pRADEONEnt->MonType1 != MT_CRT) {
	    save->disp_output_cntl |= (RADEON_DISP_DAC_SOURCE_CRTC2 |
				       RADEON_DISP_DAC2_SOURCE_CRTC2);
	} else {
	    if (pRADEONEnt->ReversedDAC) {
		save->disp_output_cntl |= RADEON_DISP_DAC2_SOURCE_CRTC2;
	    } else {
		save->disp_output_cntl |= RADEON_DISP_DAC_SOURCE_CRTC2;
	    }
	}
d5093 3
a5095 12
	/* Turn on 2nd CRT */
	if (pRADEONEnt->MonType1 != MT_CRT) {
	    /* This is for some sample boards with the VGA port
	       connected to the TVDAC, but BIOS doesn't reflect this.
	       Here we configure both DACs to use CRTC2.
	       Not sure if this happens in any retail board.
	    */
	    save->disp_hw_debug &= ~RADEON_CRT2_DISP1_SEL;
	    save->dac2_cntl |= RADEON_DAC2_DAC_CLK_SEL;
	} else {
	    if (pRADEONEnt->ReversedDAC) {
		save->disp_hw_debug &= ~RADEON_CRT2_DISP1_SEL;
d5097 7
a5103 3
	    } else {
		save->disp_hw_debug |= RADEON_CRT2_DISP1_SEL;
		save->dac2_cntl |= RADEON_DAC2_DAC_CLK_SEL;
d5105 1
a5105 1
	}
a5151 2
    save->disp2_merge_cntl = info->SavedReg.disp2_merge_cntl;
    save->disp2_merge_cntl &= ~(RADEON_DISP2_RGB_OFFSET_EN);
d5153 1
a5153 2
    if ((info->DisplayType == MT_DFP && info->IsSecondary) ||
	info->CloneType == MT_DFP) {
d5157 2
a5158 1
	save->fp2_gen_cntl        = (RADEON_FP2_PANEL_FORMAT |
a5159 14
	if (info->ChipFamily >= CHIP_FAMILY_R200) {
	    save->fp2_gen_cntl |= RADEON_FP2_DV0_EN;
	}

	if (info->ChipFamily == CHIP_FAMILY_R200 ||
	    info->ChipFamily == CHIP_FAMILY_R300 ||
	    info->ChipFamily == CHIP_FAMILY_R350 ||
	    info->ChipFamily == CHIP_FAMILY_RV350) {
	    save->fp2_gen_cntl &= ~RADEON_FP2_SOURCE_SEL_MASK;
	    save->fp2_gen_cntl |= RADEON_FP2_SOURCE_SEL_CRTC2;
	} else {
	    save->fp2_gen_cntl &= ~RADEON_FP2_SRC_SEL_MASK;
	    save->fp2_gen_cntl |= RADEON_FP2_SRC_SEL_CRTC2;
	}
d5161 1
a5161 1
	if (pScrn->rgbBits == 8)
d5168 3
a5170 1
	 *        high dot clock for certain panels.
d5172 6
a5201 25
    /* If the FP registers have been initialized before for a panel,
     * but the primary port is a CRT, we need to reinitialize
     * FP registers in order for CRT to work properly
     */

    if ((info->DisplayType != MT_DFP) && (info->DisplayType != MT_LCD)) {
        save->fp_crtc_h_total_disp = orig->fp_crtc_h_total_disp;
        save->fp_crtc_v_total_disp = orig->fp_crtc_v_total_disp;
        save->fp_gen_cntl          = 0;
        save->fp_h_sync_strt_wid   = orig->fp_h_sync_strt_wid;
        save->fp_horz_stretch      = 0;
        save->fp_v_sync_strt_wid   = orig->fp_v_sync_strt_wid;
        save->fp_vert_stretch      = 0;
        save->lvds_gen_cntl        = orig->lvds_gen_cntl;
        save->lvds_pll_cntl        = orig->lvds_pll_cntl;
        save->tmds_pll_cntl        = orig->tmds_pll_cntl;
        save->tmds_transmitter_cntl= orig->tmds_transmitter_cntl;

        save->lvds_gen_cntl |= ( RADEON_LVDS_DISPLAY_DIS | (1 << 23));
        save->lvds_gen_cntl &= ~(RADEON_LVDS_BLON | RADEON_LVDS_ON);
        save->fp_gen_cntl &= ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN);

        return;
    }

d5216 1
a5216 1
				   RADEON_HORZ_STRETCH_ENABLE);
d5271 1
a5271 1
    if (pScrn->rgbBits == 8)
d5279 8
a5294 2
    save->tmds_pll_cntl = orig->tmds_pll_cntl;
    save->tmds_transmitter_cntl= orig->tmds_transmitter_cntl;
d5301 2
a5302 2
	    save->lvds_gen_cntl |= (RADEON_LVDS_DISPLAY_DIS);
	    save->lvds_gen_cntl &= ~(RADEON_LVDS_BLON | RADEON_LVDS_ON);
a5307 10
	    RADEONEntPtr pRADEONEnt = RADEONEntPriv(pScrn);

	    /* BIOS will use this setting to reset displays upon lid close/open.
	     * Here we let BIOS controls LCD, but the driver will control the external CRT.
	     */
	    if (info->Clone || pRADEONEnt->HasSecondary)
		save->bios_5_scratch = 0x01020201;
	    else
		save->bios_5_scratch = orig->bios_5_scratch;

d5310 1
a5310 34

	} else if (info->DisplayType == MT_DFP) {
	    int i;
	    CARD32 tmp = orig->tmds_pll_cntl & 0xfffff;
	    for (i=0; i<4; i++) {
		if (info->tmds_pll[i].freq == 0) break;
		if (save->dot_clock_freq < info->tmds_pll[i].freq) {
		    tmp = info->tmds_pll[i].value ;
		    break;
		}
	    }
	    if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		(info->ChipFamily == CHIP_FAMILY_R350) ||
		(info->ChipFamily == CHIP_FAMILY_RV350) ||
		(info->ChipFamily == CHIP_FAMILY_RV280)) {
		if (tmp & 0xfff00000)
		    save->tmds_pll_cntl = tmp;
		else
		    save->tmds_pll_cntl = (orig->tmds_pll_cntl & 0xfff00000) | tmp;
	    } else save->tmds_pll_cntl = tmp;

	    RADEONTRACE(("TMDS_PLL from %x to %x\n",
			 orig->tmds_pll_cntl,
			 save->tmds_pll_cntl));

            save->tmds_transmitter_cntl &= ~(RADEON_TMDS_TRANSMITTER_PLLRST);
            if ((info->ChipFamily == CHIP_FAMILY_R300) ||
		(info->ChipFamily == CHIP_FAMILY_R350) ||
		(info->ChipFamily == CHIP_FAMILY_RV350) ||
		(info->ChipFamily == CHIP_FAMILY_R200) || !info->HasCRTC2)
		save->tmds_transmitter_cntl &= ~(RADEON_TMDS_TRANSMITTER_PLLEN);
            else /* weird, RV chips got this bit reversed? */
                save->tmds_transmitter_cntl |= (RADEON_TMDS_TRANSMITTER_PLLEN);

a5311 1
        }
a5350 1

a5354 5
    if (!post_div->divider) {
	save->pll_output_freq = freq;
	post_div = &post_divs[0];
    }

a5405 5
    if (!post_div->divider) {
	save->pll_output_freq_2 = freq;
	post_div = &post_divs[0];
    }

d5502 1
a5502 7
            if (info->UseBiosDividers) {
                save->ppll_ref_div = info->RefDivider;
                save->ppll_div_3   = info->FeedbackDivider | (info->PostDivider << 16);
                save->htotal_cntl  = 0;
            }
            else
		RADEONInitPLLRegisters(save, &info->pll, dot_clock);
d5518 4
a5521 1
    RADEONInitFPRegisters(pScrn, &info->SavedReg, save, mode, info);
a5539 4

    if (info->DispPriority)
	RADEONInitDispBandwidth(pScrn);

d5585 1
a5585 1
	    /* Try to match a mode on primary head
a5649 11
#ifdef X_XF86MiscPassMessage
Bool RADEONHandleMessage(int scrnIndex, const char* msgtype,
			 const char* msgval, char** retmsg)
{
    ErrorF("RADEONHandleMessage(%d, \"%s\", \"%s\", retmsg)\n", scrnIndex,
		    msgtype, msgval);
    *retmsg = "";
    return 0;
}
#endif

d5651 2
a5652 2
ModeStatus RADEONValidMode(int scrnIndex, DisplayModePtr mode,
			   Bool verbose, int flag)
d5654 2
a5655 3
    /* There are problems with double scan mode at high clocks
     * They're likely related PLL and display buffer settings.
     * Disable these modes for now.
d5657 1
a5657 4
    if (mode->Flags & V_DBLSCAN) {
	if ((mode->CrtcHDisplay >= 1024) || (mode->CrtcVDisplay >= 768))
	    return MODE_CLOCK_RANGE;
    }
d5692 5
a5696 1
	pSAREAPriv = DRIGetSAREAPrivate(pScrn->pScreen);
a5700 4

	if (pSAREAPriv->pfCurrentPage == 1) {
	    Base += info->backOffset;
	}
a5748 11
#ifdef XF86DRI
    if (info->directRenderingEnabled) {
	/* get the Radeon back into shape after resume */
	RADEONDRIResume(pScrn->pScreen);
    }
#endif
    /* this will get XVideo going again, but only if XVideo was initialised
       during server startup (hence the info->adaptor if). */
    if (info->adaptor)
	RADEONResetVideo(pScrn);

d5817 1
a5818 1
    RADEONUnmapMem(pScrn);
d5832 4
d5838 1
a5838 1
    xf86ClearPrimInitDone(info->pEnt->index);
a5937 68
	}

	if (PowerManagementMode == DPMSModeOn) {
	    if (info->IsSecondary) {
		if (info->DisplayType == MT_DFP) {
		    OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_BLANK_EN);
		    OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_ON, ~RADEON_FP2_ON);
		    if (info->ChipFamily >= CHIP_FAMILY_R200) {
			OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_DV0_EN, ~RADEON_FP2_DV0_EN);
		    }
		}
	    } else {
		if ((info->Clone) && (info->CloneType == MT_DFP)) {
		    OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_BLANK_EN);
		    OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_ON, ~RADEON_FP2_ON);
		    if (info->ChipFamily >= CHIP_FAMILY_R200) {
			OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_DV0_EN, ~RADEON_FP2_DV0_EN);
		    }
		}
		if (info->DisplayType == MT_DFP) {
		    OUTREGP (RADEON_FP_GEN_CNTL, (RADEON_FP_FPON | RADEON_FP_TMDS_EN),
			     ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN));
		} else if (info->DisplayType == MT_LCD) {

		    OUTREGP (RADEON_LVDS_GEN_CNTL, RADEON_LVDS_BLON, ~RADEON_LVDS_BLON);
		    usleep (info->PanelPwrDly * 1000);
		    OUTREGP (RADEON_LVDS_GEN_CNTL, RADEON_LVDS_ON, ~RADEON_LVDS_ON);
		}
	    }
	} else if ((PowerManagementMode == DPMSModeOff) ||
		   (PowerManagementMode == DPMSModeSuspend) ||
		   (PowerManagementMode == DPMSModeStandby)) {
	    if (info->IsSecondary) {
		if (info->DisplayType == MT_DFP) {
		    OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_BLANK_EN, ~RADEON_FP2_BLANK_EN);
		    OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_ON);
		    if (info->ChipFamily >= CHIP_FAMILY_R200) {
			OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_DV0_EN);
		    }
		}
	    } else {
		if ((info->Clone) && (info->CloneType == MT_DFP)) {
		    OUTREGP (RADEON_FP2_GEN_CNTL, RADEON_FP2_BLANK_EN, ~RADEON_FP2_BLANK_EN);
		    OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_ON);
		    if (info->ChipFamily >= CHIP_FAMILY_R200) {
			OUTREGP (RADEON_FP2_GEN_CNTL, 0, ~RADEON_FP2_DV0_EN);
		    }
		}
		if (info->DisplayType == MT_DFP) {
		    OUTREGP (RADEON_FP_GEN_CNTL, 0, ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN));
		} else if (info->DisplayType == MT_LCD) {
		    unsigned long tmpPixclksCntl = INPLL(pScrn, RADEON_PIXCLKS_CNTL);

		    if (info->IsMobility || info->IsIGP) {
			/* Asic bug, when turning off LVDS_ON, we have to make sure
			   RADEON_PIXCLK_LVDS_ALWAYS_ON bit is off
			*/
			OUTPLLP(pScrn, RADEON_PIXCLKS_CNTL, 0, ~RADEON_PIXCLK_LVDS_ALWAYS_ONb);
		    }

		    OUTREGP (RADEON_LVDS_GEN_CNTL, 0,
			     ~(RADEON_LVDS_BLON | RADEON_LVDS_ON));

		    if (info->IsMobility || info->IsIGP) {
			OUTPLL(RADEON_PIXCLKS_CNTL, tmpPixclksCntl);
		    }
		}
	    }
@


1.1.1.4
log
@Import OpenBSD X-Window subsystem (based upon XFree86 4.4RC2)
into vendor branch
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/ati/radeon_driver.c,v 1.118 2004/02/26 04:25:29 martin Exp $ */
a5060 1
	(info->ChipFamily == CHIP_FAMILY_RS300) ||
a5457 1
    RADEONSaveCommonRegisters(pScrn, save);
d5463 1
a6066 1
    /* Alhought we current onlu use aperture 0, also setting aperture 1 should not harm -ReneR */
a6069 1
	save->surface_cntl |= RADEON_NONSURF_AP1_SWP_16BPP;
a6073 1
	save->surface_cntl |= RADEON_NONSURF_AP1_SWP_32BPP;
a6636 1
    RADEONInitCommonRegisters(save, info);
d6642 1
@


1.1.1.5
log
@OpenBSD updated X-Window plus fontconfig 2.2.2.
@
text
@a1810 5
		case PCI_CHIP_RADEON_LW: /* Guessed based on iBook Open Firmware data -ReneR */
		    pll->reference_freq = 2700;
		    pll->reference_div  = 12;
		    pll->xclk           = 36000;
		    break;
a3686 1
#if !defined(__powerpc__)
d3689 1
a6512 3
#if defined(__powerpc__) /* on iBooks the LCD pannel needs tweaked PLL timings -ReneR */
    save->ppll_div_3     = 0x000600ad; /* -ReneR */
#endif
@


1.1.1.6
log
@OpenBSD XF4 tree (minus old and mit) as of today
-> lib and fvwm fixes
@
text
@d142 1
a142 4
    OPTION_MIN_DOTCLOCK,
#ifdef __powerpc__
    OPTION_IBOOKHACKS
#endif
a177 3
#ifdef __powerpc__
    { OPTION_IBOOKHACKS,     "iBookHacks",       OPTV_BOOLEAN, {0}, FALSE },
#endif
d1811 1
a1811 1
		case PCI_CHIP_RADEON_LW: /* Guess based on iBook OpenFirmware */
d2152 1
d3692 1
a3694 1
#if !defined(__powerpc__)
a5035 8
    /* 
     * Never do it on Apple iBook to avoid a blank screen.
     */
#ifdef __powerpc__
    if (xf86ReturnOptValBool(info->Options, OPTION_IBOOKHACKS, FALSE))
        return;
#endif

d6464 1
a6464 1
static void RADEONInitPLLRegisters(RADEONSavePtr save, RADEONInfoPtr info,
a6467 1
    RADEONPLLPtr pll = &info->pll;
d6517 3
a6519 8

    /* 
     * on iBooks the LCD pannel needs tweaked PLL timings 
     */
#ifdef __powerpc__
    if (xf86ReturnOptValBool(info->Options, OPTION_IBOOKHACKS, FALSE))
        save->ppll_div_3 = 0x000600ad;
    else
a6520 2
        save->ppll_div_3 = (save->feedback_div | (post_div->bitvalue << 16));

d6665 1
a6665 1
		RADEONInitPLLRegisters(save, info, dot_clock);
@


