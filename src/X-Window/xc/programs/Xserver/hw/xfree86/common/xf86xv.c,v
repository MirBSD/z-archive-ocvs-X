head	1.2;
access;
symbols
	tg-mergetmp-2:1.2
	cvs-200410241530:1.1.1.4
	cvs-200410012000:1.1.1.4
	cvs-200407221130:1.1.1.4
	cvs-200407141120:1.1.1.4
	cvs-200406231010:1.1.1.4
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.4
	XFree86_4_4_0:1.1.9.2
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.03.07.18.35.38;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.20.06.43;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.06.43;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.35.38;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.14.57;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.05.27.16.31.02;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.22.33;	author tg;	state Exp;
branches;
next	1.1.9.2;

1.1.9.2
date	2004.03.05.22.25.42;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@semi-automagic merge of these files (ie, I've skipped through the diffs,
and most of that was done by cvs or that weird script of some minutes ago)
@
text
@/*
 * XFree86 Xv DDX written by Mark Vojkovich (markv@@valinux.com)
 */
/*
 * Copyright (c) 1998-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86xv.c,v 1.38 2004/02/19 22:38:12 tsi Exp $ */

#include "misc.h"
#include "xf86.h"
#include "xf86_OSproc.h"

#include "X.h"
#include "Xproto.h"
#include "scrnintstr.h"
#include "regionstr.h"
#include "windowstr.h"
#include "pixmapstr.h"
#include "mivalidate.h"
#include "validate.h"
#include "resource.h"
#include "gcstruct.h"
#include "dixstruct.h"

#include "Xv.h"
#include "Xvproto.h"
#include "xvdix.h"
#ifdef XFree86LOADER
#include "xvmodproc.h"
#endif

#include "xf86xvpriv.h"


/* XvScreenRec fields */

static Bool xf86XVCloseScreen(int, ScreenPtr);
static int xf86XVQueryAdaptors(ScreenPtr, XvAdaptorPtr *, int *);

/* XvAdaptorRec fields */

static int xf86XVAllocatePort(unsigned long, XvPortPtr, XvPortPtr*);
static int xf86XVFreePort(XvPortPtr);
static int xf86XVPutVideo(ClientPtr, DrawablePtr,XvPortPtr, GCPtr,
				INT16, INT16, CARD16, CARD16,
				INT16, INT16, CARD16, CARD16);
static int xf86XVPutStill(ClientPtr, DrawablePtr,XvPortPtr, GCPtr,
				INT16, INT16, CARD16, CARD16,
				INT16, INT16, CARD16, CARD16);
static int xf86XVGetVideo(ClientPtr, DrawablePtr,XvPortPtr, GCPtr,
				INT16, INT16, CARD16, CARD16,
				INT16, INT16, CARD16, CARD16);
static int xf86XVGetStill(ClientPtr, DrawablePtr,XvPortPtr, GCPtr,
				INT16, INT16, CARD16, CARD16,
				INT16, INT16, CARD16, CARD16);
static int xf86XVStopVideo(ClientPtr, XvPortPtr, DrawablePtr);
static int xf86XVSetPortAttribute(ClientPtr, XvPortPtr, Atom, INT32);
static int xf86XVGetPortAttribute(ClientPtr, XvPortPtr, Atom, INT32*);
static int xf86XVQueryBestSize(ClientPtr, XvPortPtr, CARD8,
				CARD16, CARD16,CARD16, CARD16,
				unsigned int*, unsigned int*);
static int xf86XVPutImage(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
				INT16, INT16, CARD16, CARD16,
				INT16, INT16, CARD16, CARD16,
				XvImagePtr, unsigned char*, Bool,
				CARD16, CARD16);
static int xf86XVQueryImageAttributes(ClientPtr, XvPortPtr, XvImagePtr,
				CARD16*, CARD16*, int*, int*);


/* ScreenRec fields */

static Bool xf86XVDestroyWindow(WindowPtr pWin);
static void xf86XVWindowExposures(WindowPtr pWin, RegionPtr r1, RegionPtr r2);
static void xf86XVClipNotify(WindowPtr pWin, int dx, int dy);

/* ScrnInfoRec functions */

static Bool xf86XVEnterVT(int, int);
static void xf86XVLeaveVT(int, int);
static void xf86XVAdjustFrame(int index, int x, int y, int flags);

/* misc */

static Bool xf86XVInitAdaptors(ScreenPtr, XF86VideoAdaptorPtr*, int);


int XF86XVWindowIndex = -1;
int XF86XvScreenIndex = -1;
static unsigned long XF86XVGeneration = 0;
static unsigned long PortResource = 0;

#ifdef XFree86LOADER
int (*XvGetScreenIndexProc)(void) = NULL;
unsigned long (*XvGetRTPortProc)(void) = NULL;
int (*XvScreenInitProc)(ScreenPtr) = NULL;
#else
int (*XvGetScreenIndexProc)(void) = XvGetScreenIndex;
unsigned long (*XvGetRTPortProc)(void) = XvGetRTPort;
int (*XvScreenInitProc)(ScreenPtr) = XvScreenInit;
#endif


#define GET_XV_SCREEN(pScreen) \
	((XvScreenPtr)((pScreen)->devPrivates[XF86XvScreenIndex].ptr))

#define GET_XF86XV_SCREEN(pScreen) \
	((XF86XVScreenPtr)(GET_XV_SCREEN(pScreen)->devPriv.ptr))

#define GET_XF86XV_WINDOW(pWin) \
	((XF86XVWindowPtr)((pWin)->devPrivates[XF86XVWindowIndex].ptr))

static xf86XVInitGenericAdaptorPtr *GenDrivers = NULL;
static int NumGenDrivers = 0;

int
xf86XVRegisterGenericAdaptorDriver(
    xf86XVInitGenericAdaptorPtr InitFunc
){
  xf86XVInitGenericAdaptorPtr *newdrivers;

  newdrivers = xrealloc(GenDrivers, sizeof(xf86XVInitGenericAdaptorPtr) *
			(1 + NumGenDrivers));
  if (!newdrivers)
    return 0;
  GenDrivers = newdrivers;

  GenDrivers[NumGenDrivers++] = InitFunc;

  return 1;
}

int
xf86XVListGenericAdaptors(
    ScrnInfoPtr pScrn,
    XF86VideoAdaptorPtr **adaptors
){
    int i,j,n,num;
    XF86VideoAdaptorPtr *DrivAdap,*new;

    num = 0;
    *adaptors = NULL;
    /*
     * The v4l driver registers itself first, but can use surfaces registered
     * by other drivers.  So, call the v4l driver last.
     */
    for (i = NumGenDrivers; --i >= 0; ) {
	DrivAdap = NULL;
	n = (*GenDrivers[i])(pScrn, &DrivAdap);
	if (0 == n)
	    continue;
	new = xrealloc(*adaptors, sizeof(XF86VideoAdaptorPtr) * (num+n));
	if (NULL == new)
	    continue;
	*adaptors = new;
	for (j = 0; j < n; j++, num++)
	    (*adaptors)[num] = DrivAdap[j];
    }
    return num;
}


/****************  Offscreen surface stuff *******************/

typedef struct {
   XF86OffscreenImagePtr images;
   int num;
} OffscreenImageRec;

static OffscreenImageRec OffscreenImages[MAXSCREENS];

Bool
xf86XVRegisterOffscreenImages(
    ScreenPtr pScreen,
    XF86OffscreenImagePtr images,
    int num
){
    OffscreenImages[pScreen->myNum].num = num;
    OffscreenImages[pScreen->myNum].images = images;

    return TRUE;
}

XF86OffscreenImagePtr
xf86XVQueryOffscreenImages(
   ScreenPtr pScreen,
   int *num
){
   *num = OffscreenImages[pScreen->myNum].num;
   return OffscreenImages[pScreen->myNum].images;
}


XF86VideoAdaptorPtr
xf86XVAllocateVideoAdaptorRec(ScrnInfoPtr pScrn)
{
    return xcalloc(1, sizeof(XF86VideoAdaptorRec));
}

void
xf86XVFreeVideoAdaptorRec(XF86VideoAdaptorPtr ptr)
{
    xfree(ptr);
}


Bool
xf86XVScreenInit(
   ScreenPtr pScreen,
   XF86VideoAdaptorPtr *adaptors,
   int num
){
  ScrnInfoPtr pScrn;
  XF86XVScreenPtr ScreenPriv;
  XvScreenPtr pxvs;

  if(num <= 0 ||
     !XvGetScreenIndexProc || !XvGetRTPortProc || !XvScreenInitProc)
	return FALSE;

  if(XF86XVGeneration != serverGeneration) {
	if((XF86XVWindowIndex = AllocateWindowPrivateIndex()) < 0)
	    return FALSE;
	XF86XVGeneration = serverGeneration;
  }

  if(!AllocateWindowPrivate(pScreen,XF86XVWindowIndex,0))
	return FALSE;

  if(Success != (*XvScreenInitProc)(pScreen)) return FALSE;

  XF86XvScreenIndex = (*XvGetScreenIndexProc)();
  PortResource = (*XvGetRTPortProc)();

  pxvs = GET_XV_SCREEN(pScreen);

  /* Anyone initializing the Xv layer must provide these two.
     The Xv di layer calls them without even checking if they exist! */

  pxvs->ddCloseScreen = xf86XVCloseScreen;
  pxvs->ddQueryAdaptors = xf86XVQueryAdaptors;

  /* The Xv di layer provides us with a private hook so that we don't
     have to allocate our own screen private.  They also provide
     a CloseScreen hook so that we don't have to wrap it.  I'm not
     sure that I appreciate that.  */

  ScreenPriv = xalloc(sizeof(XF86XVScreenRec));
  pxvs->devPriv.ptr = (pointer)ScreenPriv;

  if(!ScreenPriv) return FALSE;

  pScrn = xf86Screens[pScreen->myNum];

  ScreenPriv->videoGC = NULL;  /* for the helper */

  ScreenPriv->DestroyWindow = pScreen->DestroyWindow;
  ScreenPriv->WindowExposures = pScreen->WindowExposures;
  ScreenPriv->ClipNotify = pScreen->ClipNotify;
  ScreenPriv->EnterVT = pScrn->EnterVT;
  ScreenPriv->LeaveVT = pScrn->LeaveVT;
  ScreenPriv->AdjustFrame = pScrn->AdjustFrame;

  pScreen->DestroyWindow = xf86XVDestroyWindow;
  pScreen->WindowExposures = xf86XVWindowExposures;
  pScreen->ClipNotify = xf86XVClipNotify;
  pScrn->EnterVT = xf86XVEnterVT;
  pScrn->LeaveVT = xf86XVLeaveVT;
  if(pScrn->AdjustFrame)
     pScrn->AdjustFrame = xf86XVAdjustFrame;

  if(!xf86XVInitAdaptors(pScreen, adaptors, num))
	return FALSE;

  return TRUE;
}

static void
xf86XVFreeAdaptor(XvAdaptorPtr pAdaptor)
{
   int i;

   xfree(pAdaptor->name);

   if(pAdaptor->pEncodings) {
      XvEncodingPtr pEncode = pAdaptor->pEncodings;

      for(i = 0; i < pAdaptor->nEncodings; i++, pEncode++)
	  xfree(pEncode->name);
      xfree(pAdaptor->pEncodings);
   }

   xfree(pAdaptor->pFormats);

   if(pAdaptor->pPorts) {
      XvPortPtr pPort = pAdaptor->pPorts;
      XvPortRecPrivatePtr pPriv;

      for(i = 0; i < pAdaptor->nPorts; i++, pPort++) {
	  pPriv = (XvPortRecPrivatePtr)pPort->devPriv.ptr;
	  if(pPriv) {
	     if(pPriv->clientClip)
		REGION_DESTROY(pAdaptor->pScreen, pPriv->clientClip);
	     if(pPriv->pCompositeClip && pPriv->FreeCompositeClip)
		REGION_DESTROY(pAdaptor->pScreen, pPriv->pCompositeClip);
	     xfree(pPriv);
	  }
      }
      xfree(pAdaptor->pPorts);
   }

   if(pAdaptor->nAttributes) {
      XvAttributePtr pAttribute = pAdaptor->pAttributes;

      for(i = 0; i < pAdaptor->nAttributes; i++, pAttribute++)
	  xfree(pAttribute->name);
      xfree(pAdaptor->pAttributes);
   }

   xfree(pAdaptor->pImages);
   xfree(pAdaptor->devPriv.ptr);
}

static Bool
xf86XVInitAdaptors(
   ScreenPtr pScreen,
   XF86VideoAdaptorPtr *infoPtr,
   int number
) {
  XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
  ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
  XF86VideoAdaptorPtr adaptorPtr;
  XvAdaptorPtr pAdaptor, pa;
  XvAdaptorRecPrivatePtr adaptorPriv;
  int na, numAdaptor;
  XvPortRecPrivatePtr portPriv;
  XvPortPtr pPort, pp;
  int numPort;
  XF86AttributePtr attributePtr;
  XvAttributePtr pAttribute, pat;
  XF86VideoFormatPtr formatPtr;
  XvFormatPtr pFormat, pf;
  int numFormat, totFormat;
  XF86VideoEncodingPtr encodingPtr;
  XvEncodingPtr pEncode, pe;
  XF86ImagePtr imagePtr;
  XvImagePtr pImage, pi;
  int numVisuals;
  VisualPtr pVisual;
  int i;

  pxvs->nAdaptors = 0;
  pxvs->pAdaptors = NULL;

  if(!(pAdaptor = xcalloc(number, sizeof(XvAdaptorRec))))
      return FALSE;

  for(pa = pAdaptor, na = 0, numAdaptor = 0; na < number; na++, adaptorPtr++) {
      adaptorPtr = infoPtr[na];

      if(!adaptorPtr->StopVideo || !adaptorPtr->SetPortAttribute ||
	 !adaptorPtr->GetPortAttribute || !adaptorPtr->QueryBestSize)
	   continue;

      /* client libs expect at least one encoding */
      if(!adaptorPtr->nEncodings || !adaptorPtr->pEncodings)
	   continue;

      pa->type = adaptorPtr->type;

      if(!adaptorPtr->PutVideo && !adaptorPtr->GetVideo)
	 pa->type &= ~XvVideoMask;

      if(!adaptorPtr->PutStill && !adaptorPtr->GetStill)
	 pa->type &= ~XvStillMask;

      if(!adaptorPtr->PutImage || !adaptorPtr->QueryImageAttributes)
	 pa->type &= ~XvImageMask;

      if(!adaptorPtr->PutVideo && !adaptorPtr->PutImage &&
							  !adaptorPtr->PutStill)
	 pa->type &= ~XvInputMask;

      if(!adaptorPtr->GetVideo && !adaptorPtr->GetStill)
	 pa->type &= ~XvOutputMask;

      if(!(adaptorPtr->type & (XvPixmapMask | XvWindowMask)))
	  continue;
      if(!(adaptorPtr->type & (XvImageMask | XvVideoMask | XvStillMask)))
	  continue;

      pa->pScreen = pScreen;
      pa->ddAllocatePort = xf86XVAllocatePort;
      pa->ddFreePort = xf86XVFreePort;
      pa->ddPutVideo = xf86XVPutVideo;
      pa->ddPutStill = xf86XVPutStill;
      pa->ddGetVideo = xf86XVGetVideo;
      pa->ddGetStill = xf86XVGetStill;
      pa->ddStopVideo = xf86XVStopVideo;
      pa->ddPutImage = xf86XVPutImage;
      pa->ddSetPortAttribute = xf86XVSetPortAttribute;
      pa->ddGetPortAttribute = xf86XVGetPortAttribute;
      pa->ddQueryBestSize = xf86XVQueryBestSize;
      pa->ddQueryImageAttributes = xf86XVQueryImageAttributes;
      if((pa->name = xalloc(strlen(adaptorPtr->name) + 1)))
	  strcpy(pa->name, adaptorPtr->name);

      if(adaptorPtr->nEncodings &&
	(pEncode = xcalloc(adaptorPtr->nEncodings, sizeof(XvEncodingRec)))) {

	for(pe = pEncode, encodingPtr = adaptorPtr->pEncodings, i = 0;
	    i < adaptorPtr->nEncodings; pe++, i++, encodingPtr++)
	{
	    pe->id = encodingPtr->id;
	    pe->pScreen = pScreen;
	    if((pe->name = xalloc(strlen(encodingPtr->name) + 1)))
		strcpy(pe->name, encodingPtr->name);
	    pe->width = encodingPtr->width;
	    pe->height = encodingPtr->height;
	    pe->rate.numerator = encodingPtr->rate.numerator;
	    pe->rate.denominator = encodingPtr->rate.denominator;
	}
	pa->nEncodings = adaptorPtr->nEncodings;
	pa->pEncodings = pEncode;
      }

      if(adaptorPtr->nImages &&
	 (pImage = xcalloc(adaptorPtr->nImages, sizeof(XvImageRec)))) {

	  for(i = 0, pi = pImage, imagePtr = adaptorPtr->pImages;
	      i < adaptorPtr->nImages; i++, pi++, imagePtr++)
	  {
	     pi->id = imagePtr->id;
	     pi->type = imagePtr->type;
	     pi->byte_order = imagePtr->byte_order;
	     memcpy(pi->guid, imagePtr->guid, 16);
	     pi->bits_per_pixel = imagePtr->bits_per_pixel;
	     pi->format = imagePtr->format;
	     pi->num_planes = imagePtr->num_planes;
	     pi->depth = imagePtr->depth;
	     pi->red_mask = imagePtr->red_mask;
	     pi->green_mask = imagePtr->green_mask;
	     pi->blue_mask = imagePtr->blue_mask;
	     pi->y_sample_bits = imagePtr->y_sample_bits;
	     pi->u_sample_bits = imagePtr->u_sample_bits;
	     pi->v_sample_bits = imagePtr->v_sample_bits;
	     pi->horz_y_period = imagePtr->horz_y_period;
	     pi->horz_u_period = imagePtr->horz_u_period;
	     pi->horz_v_period = imagePtr->horz_v_period;
	     pi->vert_y_period = imagePtr->vert_y_period;
	     pi->vert_u_period = imagePtr->vert_u_period;
	     pi->vert_v_period = imagePtr->vert_v_period;
	     memcpy(pi->component_order, imagePtr->component_order, 32);
	     pi->scanline_order = imagePtr->scanline_order;
	  }
	  pa->nImages = adaptorPtr->nImages;
	  pa->pImages = pImage;
      }

      if(adaptorPtr->nAttributes &&
	(pAttribute = xcalloc(adaptorPtr->nAttributes, sizeof(XvAttributeRec))))
      {
	for(pat = pAttribute, attributePtr = adaptorPtr->pAttributes, i = 0;
	    i < adaptorPtr->nAttributes; pat++, i++, attributePtr++)
	{
	    pat->flags = attributePtr->flags;
	    pat->min_value = attributePtr->min_value;
	    pat->max_value = attributePtr->max_value;
	    if((pat->name = xalloc(strlen(attributePtr->name) + 1)))
		strcpy(pat->name, attributePtr->name);
	}
	pa->nAttributes = adaptorPtr->nAttributes;
	pa->pAttributes = pAttribute;
      }


      totFormat = adaptorPtr->nFormats;

      if(!(pFormat = xcalloc(totFormat, sizeof(XvFormatRec)))) {
	  xf86XVFreeAdaptor(pa);
	  continue;
      }
      for(pf = pFormat, i = 0, numFormat = 0, formatPtr = adaptorPtr->pFormats;
	  i < adaptorPtr->nFormats; i++, formatPtr++)
      {
	  numVisuals = pScreen->numVisuals;
	  pVisual = pScreen->visuals;

	  while(numVisuals--) {
	      if((pVisual->class == formatPtr->class) &&
		 (pVisual->nplanes == formatPtr->depth)) {

		   if(numFormat >= totFormat) {
			void *moreSpace;
			totFormat *= 2;
			moreSpace = xrealloc(pFormat,
					     totFormat * sizeof(XvFormatRec));
			if(!moreSpace) break;
			pFormat = moreSpace;
			pf = pFormat + numFormat;
		   }

		   pf->visual = pVisual->vid;
		   pf->depth = formatPtr->depth;

		   pf++;
		   numFormat++;
	      }
	      pVisual++;
	  }
      }
      pa->nFormats = numFormat;
      pa->pFormats = pFormat;
      if(!numFormat) {
	  xf86XVFreeAdaptor(pa);
	  continue;
      }

      if(!(adaptorPriv = xcalloc(1, sizeof(XvAdaptorRecPrivate)))) {
	  xf86XVFreeAdaptor(pa);
	  continue;
      }

      adaptorPriv->flags = adaptorPtr->flags;
      adaptorPriv->PutVideo = adaptorPtr->PutVideo;
      adaptorPriv->PutStill = adaptorPtr->PutStill;
      adaptorPriv->GetVideo = adaptorPtr->GetVideo;
      adaptorPriv->GetStill = adaptorPtr->GetStill;
      adaptorPriv->StopVideo = adaptorPtr->StopVideo;
      adaptorPriv->SetPortAttribute = adaptorPtr->SetPortAttribute;
      adaptorPriv->GetPortAttribute = adaptorPtr->GetPortAttribute;
      adaptorPriv->QueryBestSize = adaptorPtr->QueryBestSize;
      adaptorPriv->QueryImageAttributes = adaptorPtr->QueryImageAttributes;
      adaptorPriv->PutImage = adaptorPtr->PutImage;
      adaptorPriv->ReputImage = adaptorPtr->ReputImage;

      pa->devPriv.ptr = (pointer)adaptorPriv;

      if(!(pPort = xcalloc(adaptorPtr->nPorts, sizeof(XvPortRec)))) {
	  xf86XVFreeAdaptor(pa);
	  continue;
      }
      for(pp = pPort, i = 0, numPort = 0;
	  i < adaptorPtr->nPorts; i++) {

	  if(!(pp->id = FakeClientID(0)))
		continue;

	  if(!(portPriv = xcalloc(1, sizeof(XvPortRecPrivate))))
		continue;

	  if(!AddResource(pp->id, PortResource, pp)) {
		xfree(portPriv);
		continue;
	  }

	  pp->pAdaptor = pa;
	  pp->pNotify = (XvPortNotifyPtr)NULL;
	  pp->pDraw = (DrawablePtr)NULL;
	  pp->client = (ClientPtr)NULL;
	  pp->grab.client = (ClientPtr)NULL;
	  pp->time = currentTime;
	  pp->devPriv.ptr = portPriv;

	  portPriv->pScrn = pScrn;
	  portPriv->AdaptorRec = adaptorPriv;
	  portPriv->DevPriv.ptr = adaptorPtr->pPortPrivates[i].ptr;

	  pp++;
	  numPort++;
      }
      pa->nPorts = numPort;
      pa->pPorts = pPort;
      if(!numPort) {
	  xf86XVFreeAdaptor(pa);
	  continue;
      }

      pa->base_id = pPort->id;

      pa++;
      numAdaptor++;
  }

  if(numAdaptor) {
      pxvs->nAdaptors = numAdaptor;
      pxvs->pAdaptors = pAdaptor;
  } else {
     xfree(pAdaptor);
     return FALSE;
  }

  return TRUE;
}

/* Video should be clipped to the intersection of the window cliplist
   and the client cliplist specified in the GC for which the video was
   initialized.  When we need to reclip a window, the GC that started
   the video may not even be around anymore.  That's why we save the
   client clip from the GC when the video is initialized.  We then
   use xf86XVUpdateCompositeClip to calculate the new composite clip
   when we need it.  This is different from what DEC did.  They saved
   the GC and used it's clip list when they needed to reclip the window,
   even if the client clip was different from the one the video was
   initialized with.  If the original GC was destroyed, they had to stop
   the video.  I like the new method better (MArk).

   This function only works for windows.  Will need to rewrite when
   (if) we support pixmap rendering.
*/

static void
xf86XVUpdateCompositeClip(XvPortRecPrivatePtr portPriv)
{
   RegionPtr	pregWin, pCompositeClip;
   WindowPtr	pWin;
   ScreenPtr	pScreen;
   Bool		freeCompClip = FALSE;

   if(portPriv->pCompositeClip)
	return;

   pWin = (WindowPtr)portPriv->pDraw;
   pScreen = pWin->drawable.pScreen;

   /* get window clip list */
   if(portPriv->subWindowMode == IncludeInferiors) {
	pregWin = NotClippedByChildren(pWin);
	freeCompClip = TRUE;
   } else
	pregWin = &pWin->clipList;

   if(!portPriv->clientClip) {
	portPriv->pCompositeClip = pregWin;
	portPriv->FreeCompositeClip = freeCompClip;
	return;
   }

   pCompositeClip = REGION_CREATE(pScreen, NullBox, 1);
   REGION_COPY(pScreen, pCompositeClip, portPriv->clientClip);
   REGION_TRANSLATE(pScreen, pCompositeClip,
			portPriv->pDraw->x + portPriv->clipOrg.x,
			portPriv->pDraw->y + portPriv->clipOrg.y);
   REGION_INTERSECT(pScreen, pCompositeClip, pregWin, pCompositeClip);

   portPriv->pCompositeClip = pCompositeClip;
   portPriv->FreeCompositeClip = TRUE;

   if(freeCompClip) {
	REGION_DESTROY(pScreen, pregWin);
   }
}

/* Save the current clientClip and update the CompositeClip whenever
   we have a fresh GC */

static void
xf86XVCopyClip(
   XvPortRecPrivatePtr portPriv,
   GCPtr pGC
){
    ScreenPtr pScreen = pGC->pScreen;

    /* copy the new clip if it exists */
    if((pGC->clientClipType == CT_REGION) && pGC->clientClip) {
	if(!portPriv->clientClip)
	    portPriv->clientClip = REGION_CREATE(pScreen, NullBox, 1);
	/* Note: this is in window coordinates */
	REGION_COPY(pScreen, portPriv->clientClip, pGC->clientClip);
    } else if(portPriv->clientClip) { /* free the old clientClip */
	REGION_DESTROY(pScreen, portPriv->clientClip);
	portPriv->clientClip = NULL;
    }

    /* get rid of the old clip list */
    if(portPriv->pCompositeClip && portPriv->FreeCompositeClip) {
	REGION_DESTROY(pScreen, portPriv->pCompositeClip);
    }

    portPriv->clipOrg = pGC->clipOrg;
    portPriv->pCompositeClip = pGC->pCompositeClip;
    portPriv->FreeCompositeClip = FALSE;
    portPriv->subWindowMode = pGC->subWindowMode;
}

static int
xf86XVRegetVideo(XvPortRecPrivatePtr portPriv)
{
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  ScreenPtr pScreen;
  int ret = Success;
  Bool clippedAway = FALSE;

  pScreen = portPriv->pDraw->pScreen;
  xf86XVUpdateCompositeClip(portPriv);

  /* translate the video region to the screen */
  WinBox.x1 = portPriv->pDraw->x + portPriv->drw_x;
  WinBox.y1 = portPriv->pDraw->y + portPriv->drw_y;
  WinBox.x2 = WinBox.x1 + portPriv->drw_w;
  WinBox.y2 = WinBox.y1 + portPriv->drw_h;

  /* clip to the window composite clip */
  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, portPriv->pCompositeClip);

  /* that's all if it's totally obscured */
  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
	clippedAway = TRUE;
	goto CLIP_VIDEO_BAILOUT;
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->GetVideo)(portPriv->pScrn,
			portPriv->vid_x, portPriv->vid_y,
			WinBox.x1, WinBox.y1,
			portPriv->vid_w, portPriv->vid_h,
			portPriv->drw_w, portPriv->drw_h,
			&ClipRegion, portPriv->DevPriv.ptr);

  if(ret == Success)
	portPriv->isOn = XV_ON;

CLIP_VIDEO_BAILOUT:

  if((clippedAway || (ret != Success)) && portPriv->isOn == XV_ON) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
  }

  /* This clip was copied and only good for one shot */
  if(!portPriv->FreeCompositeClip)
     portPriv->pCompositeClip = NULL;

  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);

  return ret;
}


static int
xf86XVReputVideo(XvPortRecPrivatePtr portPriv)
{
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  ScreenPtr pScreen;
  int ret = Success;
  Bool clippedAway = FALSE;

  pScreen = portPriv->pDraw->pScreen;

  xf86XVUpdateCompositeClip(portPriv);

  /* translate the video region to the screen */
  WinBox.x1 = portPriv->pDraw->x + portPriv->drw_x;
  WinBox.y1 = portPriv->pDraw->y + portPriv->drw_y;
  WinBox.x2 = WinBox.x1 + portPriv->drw_w;
  WinBox.y2 = WinBox.y1 + portPriv->drw_h;

  /* clip to the window composite clip */
  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, portPriv->pCompositeClip);

  /* clip and translate to the viewport */
  if(portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
     RegionRec VPReg;
     BoxRec VPBox;

     VPBox.x1 = portPriv->pScrn->frameX0;
     VPBox.y1 = portPriv->pScrn->frameY0;
     VPBox.x2 = portPriv->pScrn->frameX1;
     VPBox.y2 = portPriv->pScrn->frameY1;

     REGION_INIT(pScreen, &VPReg, &VPBox, 1);
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
     REGION_UNINIT(pScreen, &VPReg);
  }

  /* that's all if it's totally obscured */
  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
	clippedAway = TRUE;
	goto CLIP_VIDEO_BAILOUT;
  }

  /* bailout if we have to clip but the hardware doesn't support it */
  if(portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
     BoxPtr clipBox = REGION_RECTS(&ClipRegion);
     if(  (REGION_NUM_RECTS(&ClipRegion) != 1) ||
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
     {
	    clippedAway = TRUE;
	    goto CLIP_VIDEO_BAILOUT;
     }
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->PutVideo)(portPriv->pScrn,
			portPriv->vid_x, portPriv->vid_y,
			WinBox.x1, WinBox.y1,
			portPriv->vid_w, portPriv->vid_h,
			portPriv->drw_w, portPriv->drw_h,
			&ClipRegion, portPriv->DevPriv.ptr);

  if(ret == Success) portPriv->isOn = XV_ON;

CLIP_VIDEO_BAILOUT:

  if((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
  }

  /* This clip was copied and only good for one shot */
  if(!portPriv->FreeCompositeClip)
     portPriv->pCompositeClip = NULL;

  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);

  return ret;
}

static int
xf86XVReputImage(XvPortRecPrivatePtr portPriv)
{
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  ScreenPtr pScreen;
  int ret = Success;
  Bool clippedAway = FALSE;

  pScreen = portPriv->pDraw->pScreen;

  xf86XVUpdateCompositeClip(portPriv);

  /* translate the video region to the screen */
  WinBox.x1 = portPriv->pDraw->x + portPriv->drw_x;
  WinBox.y1 = portPriv->pDraw->y + portPriv->drw_y;
  WinBox.x2 = WinBox.x1 + portPriv->drw_w;
  WinBox.y2 = WinBox.y1 + portPriv->drw_h;

  /* clip to the window composite clip */
  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, portPriv->pCompositeClip);

  /* clip and translate to the viewport */
  if(portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
     RegionRec VPReg;
     BoxRec VPBox;

     VPBox.x1 = portPriv->pScrn->frameX0;
     VPBox.y1 = portPriv->pScrn->frameY0;
     VPBox.x2 = portPriv->pScrn->frameX1;
     VPBox.y2 = portPriv->pScrn->frameY1;

     REGION_INIT(pScreen, &VPReg, &VPBox, 1);
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
     REGION_UNINIT(pScreen, &VPReg);
  }

  /* that's all if it's totally obscured */
  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
	clippedAway = TRUE;
	goto CLIP_VIDEO_BAILOUT;
  }

  /* bailout if we have to clip but the hardware doesn't support it */
  if(portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
     BoxPtr clipBox = REGION_RECTS(&ClipRegion);
     if(  (REGION_NUM_RECTS(&ClipRegion) != 1) ||
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
     {
	    clippedAway = TRUE;
	    goto CLIP_VIDEO_BAILOUT;
     }
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->ReputImage)(portPriv->pScrn,
			WinBox.x1, WinBox.y1,
			&ClipRegion, portPriv->DevPriv.ptr);

  portPriv->isOn = (ret == Success) ? XV_ON : XV_OFF;

CLIP_VIDEO_BAILOUT:

  if((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
  }

  /* This clip was copied and only good for one shot */
  if(!portPriv->FreeCompositeClip)
     portPriv->pCompositeClip = NULL;

  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);

  return ret;
}


static int
xf86XVReputAllVideo(WindowPtr pWin, pointer data)
{
    XF86XVWindowPtr WinPriv = GET_XF86XV_WINDOW(pWin);

    while(WinPriv) {
	if(WinPriv->PortRec->type == XvInputMask)
	    xf86XVReputVideo(WinPriv->PortRec);
	else
	    xf86XVRegetVideo(WinPriv->PortRec);
	WinPriv = WinPriv->next;
    }

    return WT_WALKCHILDREN;
}

static int
xf86XVEnlistPortInWindow(WindowPtr pWin, XvPortRecPrivatePtr portPriv)
{
   XF86XVWindowPtr winPriv, PrivRoot;

   winPriv = PrivRoot = GET_XF86XV_WINDOW(pWin);

  /* Enlist our port in the window private */
   while(winPriv) {
	if(winPriv->PortRec == portPriv) /* we're already listed */
	    break;
	winPriv = winPriv->next;
   }

   if(!winPriv) {
	winPriv = xalloc(sizeof(XF86XVWindowRec));
	if(!winPriv) return BadAlloc;
	winPriv->PortRec = portPriv;
	winPriv->next = PrivRoot;
	pWin->devPrivates[XF86XVWindowIndex].ptr = (pointer)winPriv;
   }
   return Success;
}


static void
xf86XVRemovePortFromWindow(WindowPtr pWin, XvPortRecPrivatePtr portPriv)
{
     XF86XVWindowPtr winPriv, prevPriv = NULL;

     winPriv = GET_XF86XV_WINDOW(pWin);

     while(winPriv) {
	if(winPriv->PortRec == portPriv) {
	    if(prevPriv)
		prevPriv->next = winPriv->next;
	    else
		pWin->devPrivates[XF86XVWindowIndex].ptr =
					(pointer)winPriv->next;
	    xfree(winPriv);
	    break;
	}
	prevPriv = winPriv;
	winPriv = winPriv->next;
     }
     portPriv->pDraw = NULL;
}

/****  ScreenRec fields ****/

static Bool
xf86XVDestroyWindow(WindowPtr pWin)
{
  ScreenPtr pScreen = pWin->drawable.pScreen;
  XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
  XF86XVWindowPtr tmp, WinPriv = GET_XF86XV_WINDOW(pWin);
  int ret;

  while(WinPriv) {
     XvPortRecPrivatePtr pPriv = WinPriv->PortRec;

     if(pPriv->isOn > XV_OFF) {
	(*pPriv->AdaptorRec->StopVideo)(
			pPriv->pScrn, pPriv->DevPriv.ptr, TRUE);
	pPriv->isOn = XV_OFF;
     }

     pPriv->pDraw = NULL;
     tmp = WinPriv;
     WinPriv = WinPriv->next;
     xfree(tmp);
  }

  pWin->devPrivates[XF86XVWindowIndex].ptr = NULL;

  pScreen->DestroyWindow = ScreenPriv->DestroyWindow;
  ret = (*pScreen->DestroyWindow)(pWin);
  pScreen->DestroyWindow = xf86XVDestroyWindow;

  return ret;
}


static void
xf86XVWindowExposures(WindowPtr pWin, RegionPtr reg1, RegionPtr reg2)
{
  ScreenPtr pScreen = pWin->drawable.pScreen;
  XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
  XF86XVWindowPtr WinPriv = GET_XF86XV_WINDOW(pWin);
  XF86XVWindowPtr pPrev;
  XvPortRecPrivatePtr pPriv;
  Bool AreasExposed;

  AreasExposed = (WinPriv && reg1 && REGION_NOTEMPTY(pScreen, reg1));

  pScreen->WindowExposures = ScreenPriv->WindowExposures;
  (*pScreen->WindowExposures)(pWin, reg1, reg2);
  pScreen->WindowExposures = xf86XVWindowExposures;

  /* filter out XClearWindow/Area */
  if (!pWin->valdata) return;

  pPrev = NULL;

  while(WinPriv) {
     pPriv = WinPriv->PortRec;

     /* Reput anyone with a reput function */

     switch(pPriv->type) {
     case XvInputMask:
	xf86XVReputVideo(pPriv);
	break;
     case XvOutputMask:
	xf86XVRegetVideo(pPriv);
	break;
     default:  /* overlaid still/image*/
	if (pPriv->AdaptorRec->ReputImage)
	   xf86XVReputImage(pPriv);
	else if(AreasExposed) {
	    XF86XVWindowPtr tmp;

	    if (pPriv->isOn == XV_ON) {
		(*pPriv->AdaptorRec->StopVideo)(
		    pPriv->pScrn, pPriv->DevPriv.ptr, FALSE);
		pPriv->isOn = XV_PENDING;
	    }
	    pPriv->pDraw = NULL;

	    if(!pPrev)
	       pWin->devPrivates[XF86XVWindowIndex].ptr =
						(pointer)(WinPriv->next);
	    else
	       pPrev->next = WinPriv->next;
	    tmp = WinPriv;
	    WinPriv = WinPriv->next;
	    xfree(tmp);
	    continue;
	}
	break;
     }
     pPrev = WinPriv;
     WinPriv = WinPriv->next;
  }
}


static void
xf86XVClipNotify(WindowPtr pWin, int dx, int dy)
{
  ScreenPtr pScreen = pWin->drawable.pScreen;
  XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
  XF86XVWindowPtr WinPriv = GET_XF86XV_WINDOW(pWin);
  XF86XVWindowPtr tmp, pPrev = NULL;
  XvPortRecPrivatePtr pPriv;
  Bool visible = (pWin->visibility == VisibilityUnobscured) ||
		 (pWin->visibility == VisibilityPartiallyObscured);

  while(WinPriv) {
     pPriv = WinPriv->PortRec;

     if(pPriv->pCompositeClip && pPriv->FreeCompositeClip)
	REGION_DESTROY(pScreen, pPriv->pCompositeClip);

     pPriv->pCompositeClip = NULL;

     /* Stop everything except images, but stop them too if the
	window isn't visible.  But we only remove the images. */

     if(pPriv->type || !visible) {
	if(pPriv->isOn == XV_ON) {
	    (*pPriv->AdaptorRec->StopVideo)(
			pPriv->pScrn, pPriv->DevPriv.ptr, FALSE);
	    pPriv->isOn = XV_PENDING;
	}

	if(!pPriv->type) {  /* overlaid still/image */
	    pPriv->pDraw = NULL;

	    if(!pPrev)
	       pWin->devPrivates[XF86XVWindowIndex].ptr =
						(pointer)(WinPriv->next);
	    else
	       pPrev->next = WinPriv->next;
	    tmp = WinPriv;
	    WinPriv = WinPriv->next;
	    xfree(tmp);
	    continue;
	}
     }

     pPrev = WinPriv;
     WinPriv = WinPriv->next;
  }

  if(ScreenPriv->ClipNotify) {
      pScreen->ClipNotify = ScreenPriv->ClipNotify;
      (*pScreen->ClipNotify)(pWin, dx, dy);
      pScreen->ClipNotify = xf86XVClipNotify;
  }
}



/**** Required XvScreenRec fields ****/

static Bool
xf86XVCloseScreen(int i, ScreenPtr pScreen)
{
  ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
  XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
  XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
  XvAdaptorPtr pa;
  int c;

  /* Clear offscreen images */
  (void)memset(&OffscreenImages[pScreen->myNum], 0, sizeof(OffscreenImages[0]));

  if(!ScreenPriv) return TRUE;

  if(ScreenPriv->videoGC) {
     FreeGC(ScreenPriv->videoGC, 0);
     ScreenPriv->videoGC = NULL;
  }

  pScreen->DestroyWindow = ScreenPriv->DestroyWindow;
  pScreen->WindowExposures = ScreenPriv->WindowExposures;
  pScreen->ClipNotify = ScreenPriv->ClipNotify;

  pScrn->EnterVT = ScreenPriv->EnterVT;
  pScrn->LeaveVT = ScreenPriv->LeaveVT;
  pScrn->AdjustFrame = ScreenPriv->AdjustFrame;

  for(c = 0, pa = pxvs->pAdaptors; c < pxvs->nAdaptors; c++, pa++) {
       xf86XVFreeAdaptor(pa);
  }

  xfree(pxvs->pAdaptors);
  xfree(ScreenPriv);
  return TRUE;
}


static int
xf86XVQueryAdaptors(
   ScreenPtr pScreen,
   XvAdaptorPtr *p_pAdaptors,
   int *p_nAdaptors
){
  XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);

  *p_nAdaptors = pxvs->nAdaptors;
  *p_pAdaptors = pxvs->pAdaptors;

  return (Success);
}


/**** ScrnInfoRec fields ****/

static Bool
xf86XVEnterVT(int index, int flags)
{
    ScreenPtr pScreen = screenInfo.screens[index];
    XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
    Bool ret;

    ret = (*ScreenPriv->EnterVT)(index, flags);

    if(ret) WalkTree(pScreen, xf86XVReputAllVideo, 0);

    return ret;
}

static void
xf86XVLeaveVT(int index, int flags)
{
    ScreenPtr pScreen = screenInfo.screens[index];
    XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
    XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
    XvAdaptorPtr pAdaptor;
    XvPortPtr pPort;
    XvPortRecPrivatePtr pPriv;
    int i, j;

    for(i = 0; i < pxvs->nAdaptors; i++) {
	pAdaptor = &pxvs->pAdaptors[i];
	for(j = 0; j < pAdaptor->nPorts; j++) {
	    pPort = &pAdaptor->pPorts[j];
	    pPriv = (XvPortRecPrivatePtr)pPort->devPriv.ptr;
	    if(pPriv->isOn > XV_OFF) {

		(*pPriv->AdaptorRec->StopVideo)(
			pPriv->pScrn, pPriv->DevPriv.ptr, TRUE);
		pPriv->isOn = XV_OFF;

		if(pPriv->pCompositeClip && pPriv->FreeCompositeClip)
		    REGION_DESTROY(pScreen, pPriv->pCompositeClip);

		pPriv->pCompositeClip = NULL;

		if(!pPriv->type && pPriv->pDraw) { /* still */
		    xf86XVRemovePortFromWindow((WindowPtr)pPriv->pDraw, pPriv);
		}
	    }
	}
    }

    (*ScreenPriv->LeaveVT)(index, flags);
}

static void
xf86XVAdjustFrame(int index, int x, int y, int flags)
{
  ScrnInfoPtr pScrn = xf86Screens[index];
  ScreenPtr pScreen = pScrn->pScreen;
  XvScreenPtr pxvs = GET_XV_SCREEN(pScreen);
  XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
  WindowPtr pWin;
  XvAdaptorPtr pa;
  int c, i;

  if(ScreenPriv->AdjustFrame) {
	pScrn->AdjustFrame = ScreenPriv->AdjustFrame;
	(*pScrn->AdjustFrame)(index, x, y, flags);
	pScrn->AdjustFrame = xf86XVAdjustFrame;
  }

  for(c = pxvs->nAdaptors, pa = pxvs->pAdaptors; c > 0; c--, pa++) {
      XvPortPtr pPort = pa->pPorts;
      XvPortRecPrivatePtr pPriv;

      for(i = pa->nPorts; i > 0; i--, pPort++) {
	pPriv = (XvPortRecPrivatePtr)pPort->devPriv.ptr;

	if(!pPriv->type && (pPriv->isOn == XV_ON)) { /* overlaid still/image */

	  if(pPriv->pCompositeClip && pPriv->FreeCompositeClip)
	     REGION_DESTROY(pScreen, pPriv->pCompositeClip);

	  pPriv->pCompositeClip = NULL;

	  pWin = (WindowPtr)pPriv->pDraw;

	  if ((pPriv->AdaptorRec->ReputImage) &&
	     ((pWin->visibility == VisibilityUnobscured) ||
	      (pWin->visibility == VisibilityPartiallyObscured)))
	  {
	      xf86XVReputImage(pPriv);
	  } else {
	     (*pPriv->AdaptorRec->StopVideo)(
				 pPriv->pScrn, pPriv->DevPriv.ptr, FALSE);
	     xf86XVRemovePortFromWindow(pWin, pPriv);
	     pPriv->isOn = XV_PENDING;
	     continue;
	  }
	}
     }
  }
}


/**** XvAdaptorRec fields ****/

static int
xf86XVAllocatePort(
   unsigned long port,
   XvPortPtr pPort,
   XvPortPtr *ppPort
){
  *ppPort = pPort;
  return Success;
}



static int
xf86XVFreePort(XvPortPtr pPort)
{
  return Success;
}


static int
xf86XVPutVideo(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  int result;

  /* No dumping video to pixmaps... For now anyhow */
  if(pDraw->type != DRAWABLE_WINDOW) {
      pPort->pDraw = (DrawablePtr)NULL;
      return BadAlloc;
  }

  /* If we are changing windows, unregister our port in the old window */
  if(portPriv->pDraw && (portPriv->pDraw != pDraw))
     xf86XVRemovePortFromWindow((WindowPtr)(portPriv->pDraw), portPriv);

  /* Register our port with the new window */
  result =  xf86XVEnlistPortInWindow((WindowPtr)pDraw, portPriv);
  if(result != Success) return result;

  portPriv->pDraw = pDraw;
  portPriv->type = XvInputMask;

  /* save a copy of these parameters */
  portPriv->vid_x = vid_x;  portPriv->vid_y = vid_y;
  portPriv->vid_w = vid_w;  portPriv->vid_h = vid_h;
  portPriv->drw_x = drw_x;  portPriv->drw_y = drw_y;
  portPriv->drw_w = drw_w;  portPriv->drw_h = drw_h;

  /* make sure we have the most recent copy of the clientClip */
  xf86XVCopyClip(portPriv, pGC);

  /* To indicate to the DI layer that we were successful */
  pPort->pDraw = pDraw;

  if(!portPriv->pScrn->vtSema) return Success; /* Success ? */

  return(xf86XVReputVideo(portPriv));
}

static int
xf86XVPutStill(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  ScreenPtr pScreen;
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  int ret = Success;
  Bool clippedAway = FALSE;

  if (pDraw->type != DRAWABLE_WINDOW)
      return BadAlloc;

  if(!portPriv->pScrn->vtSema) return Success; /* Success ? */

  pScreen = pDraw->pScreen;

  WinBox.x1 = pDraw->x + drw_x;
  WinBox.y1 = pDraw->y + drw_y;
  WinBox.x2 = WinBox.x1 + drw_w;
  WinBox.y2 = WinBox.y1 + drw_h;

  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);

  if(portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
     RegionRec VPReg;
     BoxRec VPBox;

     VPBox.x1 = portPriv->pScrn->frameX0;
     VPBox.y1 = portPriv->pScrn->frameY0;
     VPBox.x2 = portPriv->pScrn->frameX1;
     VPBox.y2 = portPriv->pScrn->frameY1;

     REGION_INIT(pScreen, &VPReg, &VPBox, 1);
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
     REGION_UNINIT(pScreen, &VPReg);
  }

  if(portPriv->pDraw) {
     xf86XVRemovePortFromWindow((WindowPtr)(portPriv->pDraw), portPriv);
  }

  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
     clippedAway = TRUE;
     goto PUT_STILL_BAILOUT;
  }

  if(portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
     BoxPtr clipBox = REGION_RECTS(&ClipRegion);
     if(  (REGION_NUM_RECTS(&ClipRegion) != 1) ||
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
     {
	  clippedAway = TRUE;
	  goto PUT_STILL_BAILOUT;
     }
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->PutStill)(portPriv->pScrn,
		vid_x, vid_y, WinBox.x1, WinBox.y1,
		vid_w, vid_h, drw_w, drw_h,
		&ClipRegion, portPriv->DevPriv.ptr);

  if((ret == Success) &&
	(portPriv->AdaptorRec->flags & VIDEO_OVERLAID_STILLS)) {

     xf86XVEnlistPortInWindow((WindowPtr)pDraw, portPriv);
     portPriv->isOn = XV_ON;
     portPriv->pDraw = pDraw;
     portPriv->drw_x = drw_x;  portPriv->drw_y = drw_y;
     portPriv->drw_w = drw_w;  portPriv->drw_h = drw_h;
     portPriv->type = 0;  /* no mask means it's transient and should
			     not be reput once it's removed */
     pPort->pDraw = pDraw;  /* make sure we can get stop requests */
  }

PUT_STILL_BAILOUT:

  if((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
  }

  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);

  return ret;
}

static int
xf86XVGetVideo(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  int result;

  /* No pixmaps... For now anyhow */
  if(pDraw->type != DRAWABLE_WINDOW) {
      pPort->pDraw = (DrawablePtr)NULL;
      return BadAlloc;
  }

  /* If we are changing windows, unregister our port in the old window */
  if(portPriv->pDraw && (portPriv->pDraw != pDraw))
     xf86XVRemovePortFromWindow((WindowPtr)(portPriv->pDraw), portPriv);

  /* Register our port with the new window */
  result =  xf86XVEnlistPortInWindow((WindowPtr)pDraw, portPriv);
  if(result != Success) return result;

  portPriv->pDraw = pDraw;
  portPriv->type = XvOutputMask;

  /* save a copy of these parameters */
  portPriv->vid_x = vid_x;  portPriv->vid_y = vid_y;
  portPriv->vid_w = vid_w;  portPriv->vid_h = vid_h;
  portPriv->drw_x = drw_x;  portPriv->drw_y = drw_y;
  portPriv->drw_w = drw_w;  portPriv->drw_h = drw_h;

  /* make sure we have the most recent copy of the clientClip */
  xf86XVCopyClip(portPriv, pGC);

  /* To indicate to the DI layer that we were successful */
  pPort->pDraw = pDraw;

  if(!portPriv->pScrn->vtSema) return Success; /* Success ? */

  return(xf86XVRegetVideo(portPriv));
}

static int
xf86XVGetStill(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  ScreenPtr pScreen;
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  int ret = Success;
  Bool clippedAway = FALSE;

  if (pDraw->type != DRAWABLE_WINDOW)
      return BadAlloc;

  if(!portPriv->pScrn->vtSema) return Success; /* Success ? */

  pScreen = pDraw->pScreen;

  WinBox.x1 = pDraw->x + drw_x;
  WinBox.y1 = pDraw->y + drw_y;
  WinBox.x2 = WinBox.x1 + drw_w;
  WinBox.y2 = WinBox.y1 + drw_h;

  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);

  if(portPriv->pDraw) {
     xf86XVRemovePortFromWindow((WindowPtr)(portPriv->pDraw), portPriv);
  }

  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
     clippedAway = TRUE;
     goto GET_STILL_BAILOUT;
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->GetStill)(portPriv->pScrn,
		vid_x, vid_y, WinBox.x1, WinBox.y1,
		vid_w, vid_h, drw_w, drw_h,
		&ClipRegion, portPriv->DevPriv.ptr);

GET_STILL_BAILOUT:

  if((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
  }

  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);

  return ret;
}



static int
xf86XVStopVideo(
   ClientPtr client,
   XvPortPtr pPort,
   DrawablePtr pDraw
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);

  if(pDraw->type != DRAWABLE_WINDOW)
      return BadAlloc;

  xf86XVRemovePortFromWindow((WindowPtr)pDraw, portPriv);

  if(!portPriv->pScrn->vtSema) return Success; /* Success ? */

  /* Must free resources. */

  if(portPriv->isOn > XV_OFF) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, TRUE);
	portPriv->isOn = XV_OFF;
  }

  return Success;
}

static int
xf86XVSetPortAttribute(
   ClientPtr client,
   XvPortPtr pPort,
   Atom attribute,
   INT32 value
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);

  return((*portPriv->AdaptorRec->SetPortAttribute)(portPriv->pScrn,
		attribute, value, portPriv->DevPriv.ptr));
}


static int
xf86XVGetPortAttribute(
   ClientPtr client,
   XvPortPtr pPort,
   Atom attribute,
   INT32 *p_value
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);

  return((*portPriv->AdaptorRec->GetPortAttribute)(portPriv->pScrn,
		attribute, p_value, portPriv->DevPriv.ptr));
}



static int
xf86XVQueryBestSize(
   ClientPtr client,
   XvPortPtr pPort,
   CARD8 motion,
   CARD16 vid_w, CARD16 vid_h,
   CARD16 drw_w, CARD16 drw_h,
   unsigned int *p_w, unsigned int *p_h
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);

  (*portPriv->AdaptorRec->QueryBestSize)(portPriv->pScrn,
		(Bool)motion, vid_w, vid_h, drw_w, drw_h,
		p_w, p_h, portPriv->DevPriv.ptr);

  return Success;
}


static int
xf86XVPutImage(
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
   GCPtr pGC,
   INT16 src_x, INT16 src_y,
   CARD16 src_w, CARD16 src_h,
   INT16 drw_x, INT16 drw_y,
   CARD16 drw_w, CARD16 drw_h,
   XvImagePtr format,
   unsigned char* data,
   Bool sync,
   CARD16 width, CARD16 height
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);
  ScreenPtr pScreen;
  RegionRec WinRegion;
  RegionRec ClipRegion;
  BoxRec WinBox;
  int ret = Success;
  Bool clippedAway = FALSE;

  if (pDraw->type != DRAWABLE_WINDOW)
      return BadAlloc;

  if(!portPriv->pScrn->vtSema) return Success; /* Success ? */

  pScreen = pDraw->pScreen;

  WinBox.x1 = pDraw->x + drw_x;
  WinBox.y1 = pDraw->y + drw_y;
  WinBox.x2 = WinBox.x1 + drw_w;
  WinBox.y2 = WinBox.y1 + drw_h;

  REGION_INIT(pScreen, &WinRegion, &WinBox, 1);
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);

  if(portPriv->AdaptorRec->flags & VIDEO_CLIP_TO_VIEWPORT) {
     RegionRec VPReg;
     BoxRec VPBox;

     VPBox.x1 = portPriv->pScrn->frameX0;
     VPBox.y1 = portPriv->pScrn->frameY0;
     VPBox.x2 = portPriv->pScrn->frameX1 + 1;
     VPBox.y2 = portPriv->pScrn->frameY1 + 1;

     REGION_INIT(pScreen, &VPReg, &VPBox, 1);
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
     REGION_UNINIT(pScreen, &VPReg);
  }

  if(portPriv->pDraw) {
     xf86XVRemovePortFromWindow((WindowPtr)(portPriv->pDraw), portPriv);
  }

  if(!REGION_NOTEMPTY(pScreen, &ClipRegion)) {
     clippedAway = TRUE;
     goto PUT_IMAGE_BAILOUT;
  }

  if(portPriv->AdaptorRec->flags & VIDEO_NO_CLIPPING) {
     BoxPtr clipBox = REGION_RECTS(&ClipRegion);
     if(  (REGION_NUM_RECTS(&ClipRegion) != 1) ||
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
     {
	  clippedAway = TRUE;
	  goto PUT_IMAGE_BAILOUT;
     }
  }

  if(portPriv->AdaptorRec->flags & VIDEO_INVERT_CLIPLIST) {
     REGION_SUBTRACT(pScreen, &ClipRegion, &WinRegion, &ClipRegion);
  }

  ret = (*portPriv->AdaptorRec->PutImage)(portPriv->pScrn,
		src_x, src_y, WinBox.x1, WinBox.y1,
		src_w, src_h, drw_w, drw_h, format->id, data, width, height,
		sync, &ClipRegion, portPriv->DevPriv.ptr);

  if((ret == Success) &&
	(portPriv->AdaptorRec->flags & VIDEO_OVERLAID_IMAGES)) {

     xf86XVEnlistPortInWindow((WindowPtr)pDraw, portPriv);
     portPriv->isOn = XV_ON;
     portPriv->pDraw = pDraw;
     portPriv->drw_x = drw_x;  portPriv->drw_y = drw_y;
     portPriv->drw_w = drw_w;  portPriv->drw_h = drw_h;
     portPriv->type = 0;  /* no mask means it's transient and should
			     not be reput once it's removed */
     pPort->pDraw = pDraw;  /* make sure we can get stop requests */
  }

PUT_IMAGE_BAILOUT:

  if((clippedAway || (ret != Success)) && (portPriv->isOn == XV_ON)) {
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
  }

  REGION_UNINIT(pScreen, &WinRegion);
  REGION_UNINIT(pScreen, &ClipRegion);

  return ret;
}


static  int
xf86XVQueryImageAttributes(
   ClientPtr client,
   XvPortPtr pPort,
   XvImagePtr format,
   CARD16 *width,
   CARD16 *height,
   int *pitches,
   int *offsets
){
  XvPortRecPrivatePtr portPriv = (XvPortRecPrivatePtr)(pPort->devPriv.ptr);

  return (*portPriv->AdaptorRec->QueryImageAttributes)(portPriv->pScrn,
			format->id, width, height, pitches, offsets);
}

void
xf86XVFillKeyHelper (ScreenPtr pScreen, CARD32 key, RegionPtr clipboxes)
{
   XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
   DrawablePtr root = &WindowTable[pScreen->myNum]->drawable;
   XID pval[2];
   BoxPtr pbox = REGION_RECTS(clipboxes);
   int i, nbox = REGION_NUM_RECTS(clipboxes);
   xRectangle *rects;

   if(!xf86Screens[pScreen->myNum]->vtSema) return;

   if(!ScreenPriv->videoGC) {
       int status;
       pval[0] = key;
       pval[1] = IncludeInferiors;
       ScreenPriv->videoGC = CreateGC(root, GCForeground | GCSubwindowMode,
				      pval, &status);
       if(!ScreenPriv->videoGC) return;
       ValidateGC(root, ScreenPriv->videoGC);
   } else if (key != ScreenPriv->videoGC->fgPixel){
       pval[0] = key;
       ChangeGC(ScreenPriv->videoGC, GCForeground, pval);
       ValidateGC(root, ScreenPriv->videoGC);
   }

   rects = ALLOCATE_LOCAL(nbox * sizeof(xRectangle));

   for(i = 0; i < nbox; i++, pbox++) {
      rects[i].x = pbox->x1;
      rects[i].y = pbox->y1;
      rects[i].width = pbox->x2 - pbox->x1;
      rects[i].height = pbox->y2 - pbox->y1;
   }

   (*ScreenPriv->videoGC->ops->PolyFillRect)(
			     root, ScreenPriv->videoGC, nbox, rects);

   DEALLOCATE_LOCAL(rects);
}

/* xf86XVClipVideoHelper -

   Takes the dst box in standard X BoxRec form (top and left
   edges inclusive, bottom and right exclusive).  The new dst
   box is returned.  The source boundaries are given (x1, y1
   inclusive, x2, y2 exclusive) and returned are the new source
   boundaries in 16.16 fixed point.
*/

#define DummyScreen screenInfo.screens[0]

Bool
xf86XVClipVideoHelper(
    BoxPtr dst,
    INT32 *xa,
    INT32 *xb,
    INT32 *ya,
    INT32 *yb,
    RegionPtr reg,
    INT32 width,
    INT32 height
){
    double xsw, xdw, ysw, ydw;
    INT32 delta;
    BoxPtr extents = REGION_EXTENTS(DummyScreen, reg);
    int diff;

    xsw = (*xb - *xa) << 16;
    xdw = dst->x2 - dst->x1;
    ysw = (*yb - *ya) << 16;
    ydw = dst->y2 - dst->y1;

    *xa <<= 16; *xb <<= 16;
    *ya <<= 16; *yb <<= 16;

    diff = extents->x1 - dst->x1;
    if (diff > 0) {
	dst->x1 = extents->x1;
	*xa += (diff * xsw) / xdw;
    }
    diff = dst->x2 - extents->x2;
    if (diff > 0) {
	dst->x2 = extents->x2;
	*xb -= (diff * xsw) / xdw;
    }
    diff = extents->y1 - dst->y1;
    if (diff > 0) {
	dst->y1 = extents->y1;
	*ya += (diff * ysw) / ydw;
    }
    diff = dst->y2 - extents->y2;
    if (diff > 0) {
	dst->y2 = extents->y2;
	*yb -= (diff * ysw) / ydw;
    }

    if (*xa < 0) {
	diff = (((-*xa) * xdw) + xsw - 1) / xsw;
	dst->x1 += diff;
	*xa += (diff * xsw) / xdw;
    }
    delta = *xb - (width << 16);
    if (delta > 0) {
	diff = ((delta * xdw) + xsw - 1) / xsw;
	dst->x2 -= diff;
	*xb -= (diff * xsw) / xdw;
    }
    if (*xa >= *xb) return FALSE;

    if (*ya < 0) {
	diff = (((-*ya) * ydw) + ysw - 1) / ysw;
	dst->y1 += diff;
	*ya += (diff * ysw) / ydw;
    }
    delta = *yb - (height << 16);
    if (delta > 0) {
	diff = ((delta * ydw) + ysw - 1) / ysw;
	dst->y2 -= diff;
	*yb -= (diff * ysw) / ydw;
    }
    if (*ya >= *yb) return FALSE;

    if ((dst->x1 > extents->x1) || (dst->x2 < extents->x2) ||
	(dst->y1 > extents->y1) || (dst->y2 < extents->y2))
    {
	RegionRec clipReg;
	REGION_INIT(DummyScreen, &clipReg, dst, 1);
	REGION_INTERSECT(DummyScreen, reg, reg, &clipReg);
	REGION_UNINIT(DummyScreen, &clipReg);
    }
    return TRUE;
}

void
xf86XVCopyYUV12ToPacked(
    const void *srcy,
    const void *srcv,
    const void *srcu,
    void *dst,
    int srcPitchy,
    int srcPitchuv,
    int dstPitch,
    int h,
    int w
){
    CARD32 *Dst;
    const CARD8 *Y, *U, *V;
    int i, j;

    w >>= 1;

    for (j = 0;  j < h;  j++) {
	Dst = dst;
	Y = srcy;  V = srcv;  U = srcu;
	i = w;
	while (i >= 4) {
#if X_BYTE_ORDER == X_LITTLE_ENDIAN
	    Dst[0] = Y[0] | (Y[1] << 16) | (U[0] << 8) | (V[0] << 24);
	    Dst[1] = Y[2] | (Y[3] << 16) | (U[1] << 8) | (V[1] << 24);
	    Dst[2] = Y[4] | (Y[5] << 16) | (U[2] << 8) | (V[2] << 24);
	    Dst[3] = Y[6] | (Y[7] << 16) | (U[3] << 8) | (V[3] << 24);
#else
	    /* This assumes a little-endian framebuffer */
	    Dst[0] = (Y[0] << 24) | (Y[1] << 8) | (U[0] << 16) | V[0];
	    Dst[1] = (Y[2] << 24) | (Y[3] << 8) | (U[1] << 16) | V[1];
	    Dst[2] = (Y[4] << 24) | (Y[5] << 8) | (U[2] << 16) | V[2];
	    Dst[3] = (Y[6] << 24) | (Y[7] << 8) | (U[3] << 16) | V[3];
#endif
	    Dst += 4;  Y += 8;  V += 4;  U += 4;
	    i -= 4;
	}

	while (i--) {
#if X_BYTE_ORDER == X_LITTLE_ENDIAN
	    Dst[0] = Y[0] | (Y[1] << 16) | (U[0] << 8) | (V[0] << 24);
#else
	    /* This assumes a little-endian framebuffer */
	    Dst[0] = (Y[0] << 24) | (Y[1] << 8) | (U[0] << 16) | V[0];
#endif
	    Dst++;  Y += 2;  V++;  U++;
	}

	dst = (CARD8 *)dst + dstPitch;
	srcy = (const CARD8 *)srcy + srcPitchy;
	if (j & 1) {
	    srcu = (const CARD8 *)srcu + srcPitchuv;
	    srcv = (const CARD8 *)srcv + srcPitchuv;
	}
    }
}

void
xf86XVCopyPacked(
    const void *src,
    void *dst,
    int srcPitch,
    int dstPitch,
    int h,
    int w
){
    const CARD32 *Src;
    CARD32 *Dst;
    int i;

    w >>= 1;
    while (--h >= 0) {
	do {
	    Dst = dst;  Src = src;
	    i = w;
	    while (i >= 4) {
		Dst[0] = Src[0];
		Dst[1] = Src[1];
		Dst[2] = Src[2];
		Dst[3] = Src[3];
		Dst += 4;  Src += 4;  i -= 4;
	    }
	    if (!i) break;
	    Dst[0] = Src[0];
	    if (i == 1) break;
	    Dst[1] = Src[1];
	    if (i == 2) break;
	    Dst[2] = Src[2];
	} while (0);

	src = (const CARD8 *)src + srcPitch;
	dst = (CARD8 *)dst + dstPitch;
    }
}
@


1.1
log
@Initial revision
@
text
@d1 29
a29 1
/* 
d31 1
a31 7
   XFree86 Xv DDX written by Mark Vojkovich (markv@@valinux.com) 

   Copyright (C) 1998, 1999 - The XFree86 Project Inc.

*/

/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86xv.c,v 1.32 2001/08/22 22:13:43 dawes Exp $ */
d56 1
a56 1
#include "xf86xv.h"
d69 1
a69 1
   				INT16, INT16, CARD16, CARD16, 
d72 1
a72 1
   				INT16, INT16, CARD16, CARD16, 
d75 1
a75 1
   				INT16, INT16, CARD16, CARD16, 
d78 1
a78 1
   				INT16, INT16, CARD16, CARD16, 
d84 1
a84 1
   				CARD16, CARD16,CARD16, CARD16, 
d87 1
a87 1
   				INT16, INT16, CARD16, CARD16, 
d91 1
a91 1
static int xf86XVQueryImageAttributes(ClientPtr, XvPortPtr, XvImagePtr, 
a96 1
static Bool xf86XVCreateWindow(WindowPtr pWin);
d132 1
a132 1
  	((XF86XVScreenPtr)(GET_XV_SCREEN(pScreen)->devPriv.ptr))
d146 1
a146 1
  newdrivers = xrealloc(GenDrivers, sizeof(xf86XVInitGenericAdaptorPtr) * 
d151 1
a151 1
  
d159 1
a159 1
    ScrnInfoPtr          pScrn,
d167 7
a173 2
    for (i = 0; i < NumGenDrivers; i++) {
	n = GenDrivers[i](pScrn,&DrivAdap);
d186 32
d233 1
a233 1
   ScreenPtr pScreen, 
d243 1
a243 1
	return FALSE;  
d251 2
a252 2
  if(!AllocateWindowPrivate(pScreen,XF86XVWindowIndex,sizeof(XF86XVWindowRec)))
        return FALSE;
a280 1
  ScreenPriv->CreateWindow = pScreen->CreateWindow;
a287 1
  pScreen->CreateWindow = xf86XVCreateWindow;
d307 1
a307 2
   if(pAdaptor->name)
      xfree(pAdaptor->name);
d312 2
a313 3
      for(i = 0; i < pAdaptor->nEncodings; i++, pEncode++) {
          if(pEncode->name) xfree(pEncode->name);
      }
d317 1
a317 2
   if(pAdaptor->pFormats) 
      xfree(pAdaptor->pFormats);
d324 1
a324 1
          pPriv = (XvPortRecPrivatePtr)pPort->devPriv.ptr;
d326 1
a326 1
	     if(pPriv->clientClip) 
d328 1
a328 1
             if(pPriv->pCompositeClip && pPriv->FreeCompositeClip) 
d339 2
a340 4
      for(i = 0; i < pAdaptor->nAttributes; i++, pAttribute++) {
          if(pAttribute->name) xfree(pAttribute->name);
      }

d344 2
a345 5
   if(pAdaptor->nImages)
      xfree(pAdaptor->pImages);
	
   if(pAdaptor->devPriv.ptr)
      xfree(pAdaptor->devPriv.ptr);
d350 1
a350 1
   ScreenPtr pScreen, 
d379 1
a379 1
  if(!(pAdaptor = xcalloc(number, sizeof(XvAdaptorRec)))) 
d393 1
a393 1
      pa->type = adaptorPtr->type; 
d404 1
a404 1
      if(!adaptorPtr->PutVideo && !adaptorPtr->PutImage && 
d410 2
a411 2
	 
      if(!(adaptorPtr->type & (XvPixmapMask | XvWindowMask))) 
d413 1
a413 1
      if(!(adaptorPtr->type & (XvImageMask | XvVideoMask | XvStillMask))) 
d416 1
a416 1
      pa->pScreen = pScreen; 
d430 1
a430 1
          strcpy(pa->name, adaptorPtr->name);
d435 3
a437 3
	for(pe = pEncode, encodingPtr = adaptorPtr->pEncodings, i = 0; 
	    i < adaptorPtr->nEncodings; pe++, i++, encodingPtr++) 
        {
d441 1
a441 1
                strcpy(pe->name, encodingPtr->name);
d448 2
a449 2
	pa->pEncodings = pEncode;  
      } 
d452 1
a452 1
         (pImage = xcalloc(adaptorPtr->nImages, sizeof(XvImageRec)))) {
d454 3
a456 3
          for(i = 0, pi = pImage, imagePtr = adaptorPtr->pImages;
	      i < adaptorPtr->nImages; i++, pi++, imagePtr++) 
  	  {
d479 1
a479 1
          }
d487 3
a489 3
	for(pat = pAttribute, attributePtr = adaptorPtr->pAttributes, i = 0; 
	    i < adaptorPtr->nAttributes; pat++, i++, attributePtr++) 
        {
d494 1
a494 1
                strcpy(pat->name, attributePtr->name);
d497 2
a498 2
	pa->pAttributes = pAttribute;  
      } 
d504 2
a505 2
          xf86XVFreeAdaptor(pa);
          continue;
d507 2
a508 2
      for(pf = pFormat, i = 0, numFormat = 0, formatPtr = adaptorPtr->pFormats; 
	  i < adaptorPtr->nFormats; i++, formatPtr++) 
d511 1
a511 1
          pVisual = pScreen->visuals;
d513 3
a515 3
          while(numVisuals--) {
              if((pVisual->class == formatPtr->class) &&
                 (pVisual->nplanes == formatPtr->depth)) {
d518 1
a518 1
			void *moreSpace; 
d520 1
a520 1
			moreSpace = xrealloc(pFormat, 
d527 1
a527 1
                   pf->visual = pVisual->vid; 
d532 3
a534 3
              }
              pVisual++;
          }	
d537 1
a537 1
      pa->pFormats = pFormat;  
d539 2
a540 2
          xf86XVFreeAdaptor(pa);
          continue;
d544 2
a545 2
          xf86XVFreeAdaptor(pa);
          continue;
d564 2
a565 2
          xf86XVFreeAdaptor(pa);
          continue;
d567 1
a567 1
      for(pp = pPort, i = 0, numPort = 0; 
d570 1
a570 1
          if(!(pp->id = FakeClientID(0))) 
d573 1
a573 1
	  if(!(portPriv = xcalloc(1, sizeof(XvPortRecPrivate)))) 
d575 1
a575 1
	  
d581 7
a587 7
          pp->pAdaptor = pa;
          pp->pNotify = (XvPortNotifyPtr)NULL;
          pp->pDraw = (DrawablePtr)NULL;
          pp->client = (ClientPtr)NULL;
          pp->grab.client = (ClientPtr)NULL;
          pp->time = currentTime;
          pp->devPriv.ptr = portPriv;
d591 4
a594 4
          portPriv->DevPriv.ptr = adaptorPtr->pPortPrivates[i].ptr;
	
          pp++;
          numPort++;
d599 2
a600 2
          xf86XVFreeAdaptor(pa);
          continue;
d604 1
a604 1
      
d630 1
a630 1
   the video.  I like the new method better (MArk). 
d636 1
a636 1
static void  
d641 2
a642 1
   Bool 	freeCompClip = FALSE;
d648 1
d663 3
a665 3
   pCompositeClip = REGION_CREATE(pWin->pScreen, NullBox, 1);
   REGION_COPY(pWin->pScreen, pCompositeClip, portPriv->clientClip);
   REGION_TRANSLATE(pWin->pScreen, pCompositeClip,
d668 1
a668 1
   REGION_INTERSECT(pWin->pScreen, pCompositeClip, pregWin, pCompositeClip);
d674 2
a675 2
   	REGION_DESTROY(pWin->pScreen, pregWin);
   }    
d683 1
a683 1
   XvPortRecPrivatePtr portPriv, 
d686 2
d691 1
a691 1
	    portPriv->clientClip = REGION_CREATE(pGC->pScreen, NullBox, 1);
d693 1
a693 1
	REGION_COPY(pGC->pScreen, portPriv->clientClip, pGC->clientClip);
d695 1
a695 1
	REGION_DESTROY(pGC->pScreen, portPriv->clientClip);
d701 1
a701 1
	REGION_DESTROY(pWin->pScreen, portPriv->pCompositeClip);
d728 1
a728 1
  
d731 3
a733 3
  REGION_INIT(pScreen, &ClipRegion, NullBox, 1);
  REGION_INTERSECT(Screen, &ClipRegion, &WinRegion, portPriv->pCompositeClip); 
  
d744 5
a748 5
  ret = (*portPriv->AdaptorRec->GetVideo)(portPriv->pScrn, 
			portPriv->vid_x, portPriv->vid_y, 
			WinBox.x1, WinBox.y1, 
			portPriv->vid_w, portPriv->vid_h, 
			portPriv->drw_w, portPriv->drw_h, 
d792 1
a792 1
  
d795 2
a796 2
  REGION_INIT(pScreen, &ClipRegion, NullBox, 1);
  REGION_INTERSECT(Screen, &ClipRegion, &WinRegion, portPriv->pCompositeClip); 
d803 1
a803 1
     VPBox.x1 = portPriv->pScrn->frameX0;	
d805 1
a805 1
     VPBox.x2 = portPriv->pScrn->frameX1;	
d809 1
a809 1
     REGION_INTERSECT(Screen, &ClipRegion, &ClipRegion, &VPReg); 
d812 1
a812 1
  
d823 2
a824 2
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) || 
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2)) 
d835 2
a836 2
  ret = (*portPriv->AdaptorRec->PutVideo)(portPriv->pScrn, 
			portPriv->vid_x, portPriv->vid_y, 
d838 2
a839 2
			portPriv->vid_w, portPriv->vid_h, 
			portPriv->drw_w, portPriv->drw_h, 
d881 1
a881 1
  
d884 2
a885 2
  REGION_INIT(pScreen, &ClipRegion, NullBox, 1);
  REGION_INTERSECT(Screen, &ClipRegion, &WinRegion, portPriv->pCompositeClip); 
d892 1
a892 1
     VPBox.x1 = portPriv->pScrn->frameX0;	
d894 1
a894 1
     VPBox.x2 = portPriv->pScrn->frameX1;	
d898 1
a898 1
     REGION_INTERSECT(Screen, &ClipRegion, &ClipRegion, &VPReg); 
d901 1
a901 1
  
d912 2
a913 2
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) || 
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2)) 
d924 1
a924 1
  ret = (*portPriv->AdaptorRec->ReputImage)(portPriv->pScrn, 
d968 1
a968 1
   XF86XVWindowPtr winPriv, PrivRoot;    
d985 1
a985 1
   }   
d999 1
a999 1
	    if(prevPriv) 
d1001 2
a1002 2
	    else 
		pWin->devPrivates[XF86XVWindowIndex].ptr = 
d1007 1
a1007 1
	prevPriv = winPriv; 
a1014 18

static Bool
xf86XVCreateWindow(WindowPtr pWin)
{
  ScreenPtr pScreen = pWin->drawable.pScreen;
  XF86XVScreenPtr ScreenPriv = GET_XF86XV_SCREEN(pScreen);
  int ret;

  pScreen->CreateWindow = ScreenPriv->CreateWindow;
  ret = (*pScreen->CreateWindow)(pWin);
  pScreen->CreateWindow = xf86XVCreateWindow;

  if(ret) pWin->devPrivates[XF86XVWindowIndex].ptr = NULL;

  return ret;
}


d1066 1
a1066 1
   
d1077 1
a1077 1
	break;	     
d1079 2
a1080 2
	xf86XVRegetVideo(pPriv);	
	break;     
d1094 2
a1095 2
	    if(!pPrev) 
	       pWin->devPrivates[XF86XVWindowIndex].ptr = 		
d1112 1
a1112 1
static void 
d1131 1
a1131 1
     /* Stop everything except images, but stop them too if the 
d1144 2
a1145 2
	    if(!pPrev) 
	       pWin->devPrivates[XF86XVWindowIndex].ptr = 		
d1180 3
a1189 1
  pScreen->CreateWindow = ScreenPriv->CreateWindow;
d1194 2
a1195 2
  pScrn->EnterVT = ScreenPriv->EnterVT; 
  pScrn->LeaveVT = ScreenPriv->LeaveVT; 
d1198 1
a1198 1
  for(c = 0, pa = pxvs->pAdaptors; c < pxvs->nAdaptors; c++, pa++) { 
d1202 1
a1202 3
  if(pxvs->pAdaptors)
    xfree(pxvs->pAdaptors);

a1203 2


d1225 1
a1225 1
static Bool 
d1234 2
a1235 2
    if(ret) WalkTree(pScreen, xf86XVReputAllVideo, 0); 
 
d1239 1
a1239 1
static void 
d1286 1
a1286 1
 
d1292 2
a1293 2
   
  for(c = pxvs->nAdaptors, pa = pxvs->pAdaptors; c > 0; c--, pa++) { 
d1311 1
a1311 1
	      (pWin->visibility == VisibilityPartiallyObscured)))   	
d1354 2
a1355 2
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
d1367 1
a1367 1
  
d1390 1
a1390 1
  
d1402 2
a1403 2
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
d1426 1
a1426 1
  
d1428 2
a1429 2
  REGION_INIT(pScreen, &ClipRegion, NullBox, 1);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);   
d1435 1
a1435 1
     VPBox.x1 = portPriv->pScrn->frameX0;	
d1437 1
a1437 1
     VPBox.x2 = portPriv->pScrn->frameX1;	
d1441 1
a1441 1
     REGION_INTERSECT(Screen, &ClipRegion, &ClipRegion, &VPReg); 
d1457 1
a1457 1
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) || 
d1461 1
a1461 1
          goto PUT_STILL_BAILOUT;
d1469 1
a1469 1
  ret = (*portPriv->AdaptorRec->PutStill)(portPriv->pScrn, 
d1490 3
a1492 3
        (*portPriv->AdaptorRec->StopVideo)(
                portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
d1507 2
a1508 2
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
d1520 1
a1520 1
  
d1543 1
a1543 1
  
d1555 2
a1556 2
   INT16 vid_x, INT16 vid_y, 
   CARD16 vid_w, CARD16 vid_h, 
d1579 1
a1579 1
  
d1581 2
a1582 2
  REGION_INIT(pScreen, &ClipRegion, NullBox, 1);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);   
d1605 3
a1607 3
        (*portPriv->AdaptorRec->StopVideo)(
                portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
d1616 1
a1616 1
 
d1628 1
a1628 1
  
d1652 2
a1653 2
     
  return((*portPriv->AdaptorRec->SetPortAttribute)(portPriv->pScrn, 
d1666 2
a1667 2
     
  return((*portPriv->AdaptorRec->GetPortAttribute)(portPriv->pScrn, 
d1683 2
a1684 2
     
  (*portPriv->AdaptorRec->QueryBestSize)(portPriv->pScrn, 
d1692 1
a1692 1
static int 
d1694 3
a1696 3
   ClientPtr client, 
   DrawablePtr pDraw, 
   XvPortPtr pPort, 
d1698 2
a1699 2
   INT16 src_x, INT16 src_y, 
   CARD16 src_w, CARD16 src_h, 
d1726 1
a1726 1
  
d1728 2
a1729 2
  REGION_INIT(pScreen, &ClipRegion, NullBox, 1);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);   
d1735 1
a1735 1
     VPBox.x1 = portPriv->pScrn->frameX0;	
d1737 1
a1737 1
     VPBox.x2 = portPriv->pScrn->frameX1 + 1;	
d1741 1
a1741 1
     REGION_INTERSECT(Screen, &ClipRegion, &ClipRegion, &VPReg); 
d1757 1
a1757 1
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) || 
d1761 1
a1761 1
          goto PUT_IMAGE_BAILOUT;
d1769 1
a1769 1
  ret = (*portPriv->AdaptorRec->PutImage)(portPriv->pScrn, 
d1790 3
a1792 3
        (*portPriv->AdaptorRec->StopVideo)(
                portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
        portPriv->isOn = XV_PENDING;
d1802 1
a1802 1
static  int 
d1804 1
a1804 1
   ClientPtr client, 
d1806 3
a1808 3
   XvImagePtr format, 
   CARD16 *width, 
   CARD16 *height, 
d1814 1
a1814 1
  return (*portPriv->AdaptorRec->QueryImageAttributes)(portPriv->pScrn, 
d1835 1
a1835 1
                                      pval, &status);
d1852 1
a1852 1
 
d1854 1
a1854 1
                             root, ScreenPriv->videoGC, nbox, rects);
d1859 1
a1859 1
/* xf86XVClipVideoHelper -  
d1863 3
a1865 3
   box is returned.  The source boundaries are given (x1, y1 
   inclusive, x2, y2 exclusive) and returned are the new source 
   boundaries in 16.16 fixed point. 
d1881 2
a1882 1
    INT32 vscale, hscale, delta;
d1886 4
a1889 2
    hscale = ((*xb - *xa) << 16) / (dst->x2 - dst->x1);
    vscale = ((*yb - *ya) << 16) / (dst->y2 - dst->y1);
d1895 3
a1897 3
    if(diff > 0) {
        dst->x1 = extents->x1;
        *xa += diff * hscale;
d1900 3
a1902 3
    if(diff > 0) {
        dst->x2 = extents->x2;
        *xb -= diff * hscale;
d1905 3
a1907 3
    if(diff > 0) {
        dst->y1 = extents->y1;
        *ya += diff * vscale;
d1910 3
a1912 3
    if(diff > 0) {
        dst->y2 = extents->y2;
        *yb -= diff * vscale;
d1915 4
a1918 4
    if(*xa < 0) {
        diff =  (- *xa + hscale - 1)/ hscale;
        dst->x1 += diff;
        *xa += diff * hscale;
d1921 4
a1924 4
    if(delta > 0) {
        diff = (delta + hscale - 1)/ hscale;
        dst->x2 -= diff;
        *xb -= diff * hscale;
d1926 1
a1926 1
    if(*xa >= *xb) return FALSE;
d1928 4
a1931 4
    if(*ya < 0) {
        diff =  (- *ya + vscale - 1)/ vscale;
        dst->y1 += diff;
        *ya += diff * vscale;
d1934 4
a1937 4
    if(delta > 0) {
        diff = (delta + vscale - 1)/ vscale;
        dst->y2 -= diff;
        *yb -= diff * vscale;
d1939 1
a1939 1
    if(*ya >= *yb) return FALSE;
d1941 2
a1942 2
    if((dst->x1 != extents->x1) || (dst->x2 != extents->x2) ||
       (dst->y1 != extents->y1) || (dst->y2 != extents->y2))
d1944 4
a1947 4
        RegionRec clipReg;
        REGION_INIT(DummyScreen, &clipReg, dst, 1);
        REGION_INTERSECT(DummyScreen, reg, reg, &clipReg);
        REGION_UNINIT(DummyScreen, &clipReg);
d1952 15
d1968 1
a1968 1
/****************  Offscreen surface stuff *******************/
d1970 20
a1989 4
typedef struct {
   XF86OffscreenImagePtr images;
   int num;
} OffscreenImageRec;
d1991 9
a1999 2
static OffscreenImageRec OffscreenImages[MAXSCREENS];
static Bool offscreenInited = FALSE;
d2001 6
a2006 9
Bool 
xf86XVRegisterOffscreenImages(
    ScreenPtr pScreen,
    XF86OffscreenImagePtr images,
    int num
){
    if(!offscreenInited) {
	bzero(OffscreenImages, sizeof(OffscreenImages[MAXSCREENS]));
	offscreenInited = TRUE;
a2007 5
  
    OffscreenImages[pScreen->myNum].num = num;
    OffscreenImages[pScreen->myNum].images = images;

    return TRUE;
d2010 8
a2017 4
XF86OffscreenImagePtr
xf86XVQueryOffscreenImages(
   ScreenPtr pScreen,
   int *num
d2019 23
a2041 4
   if(!offscreenInited) {
	*num = 0;
	return NULL;
   }
d2043 3
a2045 2
   *num = OffscreenImages[pScreen->myNum].num;
   return OffscreenImages[pScreen->myNum].images;
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 29
/*
 * XFree86 Xv DDX written by Mark Vojkovich (markv@@valinux.com)
 */
/*
 * Copyright (c) 1998-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */
d3 7
a9 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86xv.c,v 1.37 2003/11/10 18:22:15 tsi Exp $ */
d34 1
a34 1
#include "xf86xvpriv.h"
d47 1
a47 1
				INT16, INT16, CARD16, CARD16,
d50 1
a50 1
				INT16, INT16, CARD16, CARD16,
d53 1
a53 1
				INT16, INT16, CARD16, CARD16,
d56 1
a56 1
				INT16, INT16, CARD16, CARD16,
d62 1
a62 1
				CARD16, CARD16,CARD16, CARD16,
d65 1
a65 1
				INT16, INT16, CARD16, CARD16,
d69 1
a69 1
static int xf86XVQueryImageAttributes(ClientPtr, XvPortPtr, XvImagePtr,
d75 1
d111 1
a111 1
	((XF86XVScreenPtr)(GET_XV_SCREEN(pScreen)->devPriv.ptr))
d125 1
a125 1
  newdrivers = xrealloc(GenDrivers, sizeof(xf86XVInitGenericAdaptorPtr) *
d130 1
a130 1

d138 1
a138 1
    ScrnInfoPtr pScrn,
d146 2
a147 7
    /*
     * The v4l driver registers itself first, but can use surfaces registered
     * by other drivers.  So, call the v4l driver last.
     */
    for (i = NumGenDrivers; --i >= 0; ) {
	DrivAdap = NULL;
	n = (*GenDrivers[i])(pScrn, &DrivAdap);
a159 32

/****************  Offscreen surface stuff *******************/

typedef struct {
   XF86OffscreenImagePtr images;
   int num;
} OffscreenImageRec;

static OffscreenImageRec OffscreenImages[MAXSCREENS];

Bool
xf86XVRegisterOffscreenImages(
    ScreenPtr pScreen,
    XF86OffscreenImagePtr images,
    int num
){
    OffscreenImages[pScreen->myNum].num = num;
    OffscreenImages[pScreen->myNum].images = images;

    return TRUE;
}

XF86OffscreenImagePtr
xf86XVQueryOffscreenImages(
   ScreenPtr pScreen,
   int *num
){
   *num = OffscreenImages[pScreen->myNum].num;
   return OffscreenImages[pScreen->myNum].images;
}


d175 1
a175 1
   ScreenPtr pScreen,
d185 1
a185 1
	return FALSE;
d193 2
a194 2
  if(!AllocateWindowPrivate(pScreen,XF86XVWindowIndex,0))
	return FALSE;
d223 1
d231 1
d251 2
a252 1
   xfree(pAdaptor->name);
d257 3
a259 2
      for(i = 0; i < pAdaptor->nEncodings; i++, pEncode++)
	  xfree(pEncode->name);
d263 2
a264 1
   xfree(pAdaptor->pFormats);
d271 1
a271 1
	  pPriv = (XvPortRecPrivatePtr)pPort->devPriv.ptr;
d273 1
a273 1
	     if(pPriv->clientClip)
d275 1
a275 1
	     if(pPriv->pCompositeClip && pPriv->FreeCompositeClip)
d286 4
a289 2
      for(i = 0; i < pAdaptor->nAttributes; i++, pAttribute++)
	  xfree(pAttribute->name);
d293 5
a297 2
   xfree(pAdaptor->pImages);
   xfree(pAdaptor->devPriv.ptr);
d302 1
a302 1
   ScreenPtr pScreen,
d331 1
a331 1
  if(!(pAdaptor = xcalloc(number, sizeof(XvAdaptorRec))))
d345 1
a345 1
      pa->type = adaptorPtr->type;
d356 1
a356 1
      if(!adaptorPtr->PutVideo && !adaptorPtr->PutImage &&
d362 2
a363 2

      if(!(adaptorPtr->type & (XvPixmapMask | XvWindowMask)))
d365 1
a365 1
      if(!(adaptorPtr->type & (XvImageMask | XvVideoMask | XvStillMask)))
d368 1
a368 1
      pa->pScreen = pScreen;
d382 1
a382 1
	  strcpy(pa->name, adaptorPtr->name);
d387 3
a389 3
	for(pe = pEncode, encodingPtr = adaptorPtr->pEncodings, i = 0;
	    i < adaptorPtr->nEncodings; pe++, i++, encodingPtr++)
	{
d393 1
a393 1
		strcpy(pe->name, encodingPtr->name);
d400 2
a401 2
	pa->pEncodings = pEncode;
      }
d404 1
a404 1
	 (pImage = xcalloc(adaptorPtr->nImages, sizeof(XvImageRec)))) {
d406 3
a408 3
	  for(i = 0, pi = pImage, imagePtr = adaptorPtr->pImages;
	      i < adaptorPtr->nImages; i++, pi++, imagePtr++)
	  {
d431 1
a431 1
	  }
d439 3
a441 3
	for(pat = pAttribute, attributePtr = adaptorPtr->pAttributes, i = 0;
	    i < adaptorPtr->nAttributes; pat++, i++, attributePtr++)
	{
d446 1
a446 1
		strcpy(pat->name, attributePtr->name);
d449 2
a450 2
	pa->pAttributes = pAttribute;
      }
d456 2
a457 2
	  xf86XVFreeAdaptor(pa);
	  continue;
d459 2
a460 2
      for(pf = pFormat, i = 0, numFormat = 0, formatPtr = adaptorPtr->pFormats;
	  i < adaptorPtr->nFormats; i++, formatPtr++)
d463 1
a463 1
	  pVisual = pScreen->visuals;
d465 3
a467 3
	  while(numVisuals--) {
	      if((pVisual->class == formatPtr->class) &&
		 (pVisual->nplanes == formatPtr->depth)) {
d470 1
a470 1
			void *moreSpace;
d472 1
a472 1
			moreSpace = xrealloc(pFormat,
d479 1
a479 1
		   pf->visual = pVisual->vid;
d484 3
a486 3
	      }
	      pVisual++;
	  }
d489 1
a489 1
      pa->pFormats = pFormat;
d491 2
a492 2
	  xf86XVFreeAdaptor(pa);
	  continue;
d496 2
a497 2
	  xf86XVFreeAdaptor(pa);
	  continue;
d516 2
a517 2
	  xf86XVFreeAdaptor(pa);
	  continue;
d519 1
a519 1
      for(pp = pPort, i = 0, numPort = 0;
d522 1
a522 1
	  if(!(pp->id = FakeClientID(0)))
d525 1
a525 1
	  if(!(portPriv = xcalloc(1, sizeof(XvPortRecPrivate))))
d527 1
a527 1

d533 7
a539 7
	  pp->pAdaptor = pa;
	  pp->pNotify = (XvPortNotifyPtr)NULL;
	  pp->pDraw = (DrawablePtr)NULL;
	  pp->client = (ClientPtr)NULL;
	  pp->grab.client = (ClientPtr)NULL;
	  pp->time = currentTime;
	  pp->devPriv.ptr = portPriv;
d543 4
a546 4
	  portPriv->DevPriv.ptr = adaptorPtr->pPortPrivates[i].ptr;

	  pp++;
	  numPort++;
d551 2
a552 2
	  xf86XVFreeAdaptor(pa);
	  continue;
d556 1
a556 1

d582 1
a582 1
   the video.  I like the new method better (MArk).
d588 1
a588 1
static void
d593 1
a593 2
   ScreenPtr	pScreen;
   Bool		freeCompClip = FALSE;
a598 1
   pScreen = pWin->drawable.pScreen;
d613 3
a615 3
   pCompositeClip = REGION_CREATE(pScreen, NullBox, 1);
   REGION_COPY(pScreen, pCompositeClip, portPriv->clientClip);
   REGION_TRANSLATE(pScreen, pCompositeClip,
d618 1
a618 1
   REGION_INTERSECT(pScreen, pCompositeClip, pregWin, pCompositeClip);
d624 2
a625 2
	REGION_DESTROY(pScreen, pregWin);
   }
d633 1
a633 1
   XvPortRecPrivatePtr portPriv,
a635 2
    ScreenPtr pScreen = pGC->pScreen;

d639 1
a639 1
	    portPriv->clientClip = REGION_CREATE(pScreen, NullBox, 1);
d641 1
a641 1
	REGION_COPY(pScreen, portPriv->clientClip, pGC->clientClip);
d643 1
a643 1
	REGION_DESTROY(pScreen, portPriv->clientClip);
d649 1
a649 1
	REGION_DESTROY(pScreen, portPriv->pCompositeClip);
d676 1
a676 1

d679 3
a681 3
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, portPriv->pCompositeClip);

d692 5
a696 5
  ret = (*portPriv->AdaptorRec->GetVideo)(portPriv->pScrn,
			portPriv->vid_x, portPriv->vid_y,
			WinBox.x1, WinBox.y1,
			portPriv->vid_w, portPriv->vid_h,
			portPriv->drw_w, portPriv->drw_h,
d740 1
a740 1

d743 2
a744 2
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, portPriv->pCompositeClip);
d751 1
a751 1
     VPBox.x1 = portPriv->pScrn->frameX0;
d753 1
a753 1
     VPBox.x2 = portPriv->pScrn->frameX1;
d757 1
a757 1
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
d760 1
a760 1

d771 2
a772 2
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
d783 2
a784 2
  ret = (*portPriv->AdaptorRec->PutVideo)(portPriv->pScrn,
			portPriv->vid_x, portPriv->vid_y,
d786 2
a787 2
			portPriv->vid_w, portPriv->vid_h,
			portPriv->drw_w, portPriv->drw_h,
d829 1
a829 1

d832 2
a833 2
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, portPriv->pCompositeClip);
d840 1
a840 1
     VPBox.x1 = portPriv->pScrn->frameX0;
d842 1
a842 1
     VPBox.x2 = portPriv->pScrn->frameX1;
d846 1
a846 1
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
d849 1
a849 1

d860 2
a861 2
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
d872 1
a872 1
  ret = (*portPriv->AdaptorRec->ReputImage)(portPriv->pScrn,
d916 1
a916 1
   XF86XVWindowPtr winPriv, PrivRoot;
d933 1
a933 1
   }
d947 1
a947 1
	    if(prevPriv)
d949 2
a950 2
	    else
		pWin->devPrivates[XF86XVWindowIndex].ptr =
d955 1
a955 1
	prevPriv = winPriv;
d963 18
d1032 1
a1032 1

d1043 1
a1043 1
	break;
d1045 2
a1046 2
	xf86XVRegetVideo(pPriv);
	break;
d1060 2
a1061 2
	    if(!pPrev)
	       pWin->devPrivates[XF86XVWindowIndex].ptr =
d1078 1
a1078 1
static void
d1097 1
a1097 1
     /* Stop everything except images, but stop them too if the
d1110 2
a1111 2
	    if(!pPrev)
	       pWin->devPrivates[XF86XVWindowIndex].ptr =
a1145 3
  /* Clear offscreen images */
  (void)memset(&OffscreenImages[pScreen->myNum], 0, sizeof(OffscreenImages[0]));

d1153 1
d1158 2
a1159 2
  pScrn->EnterVT = ScreenPriv->EnterVT;
  pScrn->LeaveVT = ScreenPriv->LeaveVT;
d1162 1
a1162 1
  for(c = 0, pa = pxvs->pAdaptors; c < pxvs->nAdaptors; c++, pa++) {
d1166 3
a1168 1
  xfree(pxvs->pAdaptors);
d1170 2
d1193 1
a1193 1
static Bool
d1202 2
a1203 2
    if(ret) WalkTree(pScreen, xf86XVReputAllVideo, 0);

d1207 1
a1207 1
static void
d1254 1
a1254 1

d1260 2
a1261 2

  for(c = pxvs->nAdaptors, pa = pxvs->pAdaptors; c > 0; c--, pa++) {
d1279 1
a1279 1
	      (pWin->visibility == VisibilityPartiallyObscured)))
d1322 2
a1323 2
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
d1335 1
a1335 1

d1358 1
a1358 1

d1370 2
a1371 2
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
d1394 1
a1394 1

d1396 2
a1397 2
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);
d1403 1
a1403 1
     VPBox.x1 = portPriv->pScrn->frameX0;
d1405 1
a1405 1
     VPBox.x2 = portPriv->pScrn->frameX1;
d1409 1
a1409 1
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
d1425 1
a1425 1
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
d1429 1
a1429 1
	  goto PUT_STILL_BAILOUT;
d1437 1
a1437 1
  ret = (*portPriv->AdaptorRec->PutStill)(portPriv->pScrn,
d1458 3
a1460 3
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
d1475 2
a1476 2
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
d1488 1
a1488 1

d1511 1
a1511 1

d1523 2
a1524 2
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
d1547 1
a1547 1

d1549 2
a1550 2
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);
d1573 3
a1575 3
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
d1584 1
a1584 1

d1596 1
a1596 1

d1620 2
a1621 2

  return((*portPriv->AdaptorRec->SetPortAttribute)(portPriv->pScrn,
d1634 2
a1635 2

  return((*portPriv->AdaptorRec->GetPortAttribute)(portPriv->pScrn,
d1651 2
a1652 2

  (*portPriv->AdaptorRec->QueryBestSize)(portPriv->pScrn,
d1660 1
a1660 1
static int
d1662 3
a1664 3
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
d1666 2
a1667 2
   INT16 src_x, INT16 src_y,
   CARD16 src_w, CARD16 src_h,
d1694 1
a1694 1

d1696 2
a1697 2
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);
d1703 1
a1703 1
     VPBox.x1 = portPriv->pScrn->frameX0;
d1705 1
a1705 1
     VPBox.x2 = portPriv->pScrn->frameX1 + 1;
d1709 1
a1709 1
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
d1725 1
a1725 1
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
d1729 1
a1729 1
	  goto PUT_IMAGE_BAILOUT;
d1737 1
a1737 1
  ret = (*portPriv->AdaptorRec->PutImage)(portPriv->pScrn,
d1758 3
a1760 3
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
d1770 1
a1770 1
static  int
d1772 1
a1772 1
   ClientPtr client,
d1774 3
a1776 3
   XvImagePtr format,
   CARD16 *width,
   CARD16 *height,
d1782 1
a1782 1
  return (*portPriv->AdaptorRec->QueryImageAttributes)(portPriv->pScrn,
d1803 1
a1803 1
				      pval, &status);
d1820 1
a1820 1

d1822 1
a1822 1
			     root, ScreenPriv->videoGC, nbox, rects);
d1827 1
a1827 1
/* xf86XVClipVideoHelper -
d1831 3
a1833 3
   box is returned.  The source boundaries are given (x1, y1
   inclusive, x2, y2 exclusive) and returned are the new source
   boundaries in 16.16 fixed point.
d1849 1
a1849 2
    double xsw, xdw, ysw, ydw;
    INT32 delta;
d1853 2
a1854 4
    xsw = (*xb - *xa) << 16;
    xdw = dst->x2 - dst->x1;
    ysw = (*yb - *ya) << 16;
    ydw = dst->y2 - dst->y1;
d1860 3
a1862 3
    if (diff > 0) {
	dst->x1 = extents->x1;
	*xa += (diff * xsw) / xdw;
d1865 3
a1867 3
    if (diff > 0) {
	dst->x2 = extents->x2;
	*xb -= (diff * xsw) / xdw;
d1870 3
a1872 3
    if (diff > 0) {
	dst->y1 = extents->y1;
	*ya += (diff * ysw) / ydw;
d1875 3
a1877 3
    if (diff > 0) {
	dst->y2 = extents->y2;
	*yb -= (diff * ysw) / ydw;
d1880 4
a1883 4
    if (*xa < 0) {
	diff = (((-*xa) * xdw) + xsw - 1) / xsw;
	dst->x1 += diff;
	*xa += (diff * xsw) / xdw;
d1886 4
a1889 4
    if (delta > 0) {
	diff = ((delta * xdw) + xsw - 1) / xsw;
	dst->x2 -= diff;
	*xb -= (diff * xsw) / xdw;
d1891 1
a1891 1
    if (*xa >= *xb) return FALSE;
d1893 4
a1896 4
    if (*ya < 0) {
	diff = (((-*ya) * ydw) + ysw - 1) / ysw;
	dst->y1 += diff;
	*ya += (diff * ysw) / ydw;
d1899 4
a1902 4
    if (delta > 0) {
	diff = ((delta * ydw) + ysw - 1) / ysw;
	dst->y2 -= diff;
	*yb -= (diff * ysw) / ydw;
d1904 1
a1904 1
    if (*ya >= *yb) return FALSE;
d1906 2
a1907 2
    if ((dst->x1 > extents->x1) || (dst->x2 < extents->x2) ||
	(dst->y1 > extents->y1) || (dst->y2 < extents->y2))
d1909 4
a1912 4
	RegionRec clipReg;
	REGION_INIT(DummyScreen, &clipReg, dst, 1);
	REGION_INTERSECT(DummyScreen, reg, reg, &clipReg);
	REGION_UNINIT(DummyScreen, &clipReg);
a1916 15
void
xf86XVCopyYUV12ToPacked(
    const void *srcy,
    const void *srcv,
    const void *srcu,
    void *dst,
    int srcPitchy,
    int srcPitchuv,
    int dstPitch,
    int h,
    int w
){
    CARD32 *Dst;
    const CARD8 *Y, *U, *V;
    int i, j;
d1918 1
a1918 1
    w >>= 1;
d1920 4
a1923 20
    for (j = 0;  j < h;  j++) {
	Dst = dst;
	Y = srcy;  V = srcv;  U = srcu;
	i = w;
	while (i >= 4) {
#if X_BYTE_ORDER == X_LITTLE_ENDIAN
	    Dst[0] = Y[0] | (Y[1] << 16) | (U[0] << 8) | (V[0] << 24);
	    Dst[1] = Y[2] | (Y[3] << 16) | (U[1] << 8) | (V[1] << 24);
	    Dst[2] = Y[4] | (Y[5] << 16) | (U[2] << 8) | (V[2] << 24);
	    Dst[3] = Y[6] | (Y[7] << 16) | (U[3] << 8) | (V[3] << 24);
#else
	    /* This assumes a little-endian framebuffer */
	    Dst[0] = (Y[0] << 24) | (Y[1] << 8) | (U[0] << 16) | Y[0];
	    Dst[1] = (Y[2] << 24) | (Y[3] << 8) | (U[1] << 16) | Y[1];
	    Dst[2] = (Y[4] << 24) | (Y[5] << 8) | (U[2] << 16) | Y[2];
	    Dst[3] = (Y[6] << 24) | (Y[7] << 8) | (U[3] << 16) | Y[3];
#endif
	    Dst += 4;  Y += 8;  V += 4;  U += 4;
	    i -= 4;
	}
d1925 2
a1926 9
	while (i--) {
#if X_BYTE_ORDER == X_LITTLE_ENDIAN
	    Dst[0] = Y[0] | (Y[1] << 16) | (U[0] << 8) | (V[0] << 24);
#else
	    /* This assumes a little-endian framebuffer */
	    Dst[0] = (Y[0] << 24) | (Y[1] << 8) | (U[0] << 16) | Y[0];
#endif
	    Dst++;  Y += 2;  V++;  U++;
	}
d1928 9
a1936 6
	dst = (CARD8 *)dst + dstPitch;
	srcy = (const CARD8 *)srcy + srcPitchy;
	if (j & 1) {
	    srcu = (const CARD8 *)srcu + srcPitchuv;
	    srcv = (const CARD8 *)srcv + srcPitchuv;
	}
d1938 5
d1945 4
a1948 8
void
xf86XVCopyPacked(
    const void *src,
    void *dst,
    int srcPitch,
    int dstPitch,
    int h,
    int w
d1950 4
a1953 23
    const CARD32 *Src;
    CARD32 *Dst;
    int i;

    w >>= 1;
    while (--h >= 0) {
	do {
	    Dst = dst;  Src = src;
	    i = w;
	    while (i >= 4) {
		Dst[0] = Src[0];
		Dst[1] = Src[1];
		Dst[2] = Src[2];
		Dst[3] = Src[3];
		Dst += 4;  Src += 4;  i -= 4;
	    }
	    if (!i) break;
	    Dst[0] = Src[0];
	    if (i == 1) break;
	    Dst[1] = Src[1];
	    if (i == 2) break;
	    Dst[2] = Src[2];
	} while (0);
d1955 2
a1956 3
	src = (const CARD8 *)src + srcPitch;
	dst = (CARD8 *)dst + dstPitch;
    }
@


1.1.9.2
log
@Import XFree86 4.4 from The XFree86(TM) Project, Inc.
(integrity cannot be checked)

got via cvs -qd anoncvs@@anoncvs.xfree86.org:/cvs co -Prxf-4_4_0 xc
@
text
@d31 1
a31 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86xv.c,v 1.38 2004/02/19 22:38:12 tsi Exp $ */
d1982 4
a1985 4
	    Dst[0] = (Y[0] << 24) | (Y[1] << 8) | (U[0] << 16) | V[0];
	    Dst[1] = (Y[2] << 24) | (Y[3] << 8) | (U[1] << 16) | V[1];
	    Dst[2] = (Y[4] << 24) | (Y[5] << 8) | (U[2] << 16) | V[2];
	    Dst[3] = (Y[6] << 24) | (Y[7] << 8) | (U[3] << 16) | V[3];
d1996 1
a1996 1
	    Dst[0] = (Y[0] << 24) | (Y[1] << 8) | (U[0] << 16) | V[0];
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d9 1
a9 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86xv.c,v 1.33 2002/11/09 01:18:11 keithp Exp $ */
d75 1
d193 1
a193 1
  if(!AllocateWindowPrivate(pScreen,XF86XVWindowIndex,0))
d223 1
d231 1
d963 18
d1153 1
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 29
/*
 * XFree86 Xv DDX written by Mark Vojkovich (markv@@valinux.com)
 */
/*
 * Copyright (c) 1998-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */
d3 7
a9 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86xv.c,v 1.37 2003/11/10 18:22:15 tsi Exp $ */
d34 1
a34 1
#include "xf86xvpriv.h"
d47 1
a47 1
				INT16, INT16, CARD16, CARD16,
d50 1
a50 1
				INT16, INT16, CARD16, CARD16,
d53 1
a53 1
				INT16, INT16, CARD16, CARD16,
d56 1
a56 1
				INT16, INT16, CARD16, CARD16,
d62 1
a62 1
				CARD16, CARD16,CARD16, CARD16,
d65 1
a65 1
				INT16, INT16, CARD16, CARD16,
d69 1
a69 1
static int xf86XVQueryImageAttributes(ClientPtr, XvPortPtr, XvImagePtr,
d110 1
a110 1
	((XF86XVScreenPtr)(GET_XV_SCREEN(pScreen)->devPriv.ptr))
d124 1
a124 1
  newdrivers = xrealloc(GenDrivers, sizeof(xf86XVInitGenericAdaptorPtr) *
d129 1
a129 1

d137 1
a137 1
    ScrnInfoPtr pScrn,
d145 2
a146 7
    /*
     * The v4l driver registers itself first, but can use surfaces registered
     * by other drivers.  So, call the v4l driver last.
     */
    for (i = NumGenDrivers; --i >= 0; ) {
	DrivAdap = NULL;
	n = (*GenDrivers[i])(pScrn, &DrivAdap);
a158 32

/****************  Offscreen surface stuff *******************/

typedef struct {
   XF86OffscreenImagePtr images;
   int num;
} OffscreenImageRec;

static OffscreenImageRec OffscreenImages[MAXSCREENS];

Bool
xf86XVRegisterOffscreenImages(
    ScreenPtr pScreen,
    XF86OffscreenImagePtr images,
    int num
){
    OffscreenImages[pScreen->myNum].num = num;
    OffscreenImages[pScreen->myNum].images = images;

    return TRUE;
}

XF86OffscreenImagePtr
xf86XVQueryOffscreenImages(
   ScreenPtr pScreen,
   int *num
){
   *num = OffscreenImages[pScreen->myNum].num;
   return OffscreenImages[pScreen->myNum].images;
}


d174 1
a174 1
   ScreenPtr pScreen,
d184 1
a184 1
	return FALSE;
d193 1
a193 1
	return FALSE;
d248 2
a249 1
   xfree(pAdaptor->name);
d254 3
a256 2
      for(i = 0; i < pAdaptor->nEncodings; i++, pEncode++)
	  xfree(pEncode->name);
d260 2
a261 1
   xfree(pAdaptor->pFormats);
d268 1
a268 1
	  pPriv = (XvPortRecPrivatePtr)pPort->devPriv.ptr;
d270 1
a270 1
	     if(pPriv->clientClip)
d272 1
a272 1
	     if(pPriv->pCompositeClip && pPriv->FreeCompositeClip)
d283 4
a286 2
      for(i = 0; i < pAdaptor->nAttributes; i++, pAttribute++)
	  xfree(pAttribute->name);
d290 5
a294 2
   xfree(pAdaptor->pImages);
   xfree(pAdaptor->devPriv.ptr);
d299 1
a299 1
   ScreenPtr pScreen,
d328 1
a328 1
  if(!(pAdaptor = xcalloc(number, sizeof(XvAdaptorRec))))
d342 1
a342 1
      pa->type = adaptorPtr->type;
d353 1
a353 1
      if(!adaptorPtr->PutVideo && !adaptorPtr->PutImage &&
d359 2
a360 2

      if(!(adaptorPtr->type & (XvPixmapMask | XvWindowMask)))
d362 1
a362 1
      if(!(adaptorPtr->type & (XvImageMask | XvVideoMask | XvStillMask)))
d365 1
a365 1
      pa->pScreen = pScreen;
d379 1
a379 1
	  strcpy(pa->name, adaptorPtr->name);
d384 3
a386 3
	for(pe = pEncode, encodingPtr = adaptorPtr->pEncodings, i = 0;
	    i < adaptorPtr->nEncodings; pe++, i++, encodingPtr++)
	{
d390 1
a390 1
		strcpy(pe->name, encodingPtr->name);
d397 2
a398 2
	pa->pEncodings = pEncode;
      }
d401 1
a401 1
	 (pImage = xcalloc(adaptorPtr->nImages, sizeof(XvImageRec)))) {
d403 3
a405 3
	  for(i = 0, pi = pImage, imagePtr = adaptorPtr->pImages;
	      i < adaptorPtr->nImages; i++, pi++, imagePtr++)
	  {
d428 1
a428 1
	  }
d436 3
a438 3
	for(pat = pAttribute, attributePtr = adaptorPtr->pAttributes, i = 0;
	    i < adaptorPtr->nAttributes; pat++, i++, attributePtr++)
	{
d443 1
a443 1
		strcpy(pat->name, attributePtr->name);
d446 2
a447 2
	pa->pAttributes = pAttribute;
      }
d453 2
a454 2
	  xf86XVFreeAdaptor(pa);
	  continue;
d456 2
a457 2
      for(pf = pFormat, i = 0, numFormat = 0, formatPtr = adaptorPtr->pFormats;
	  i < adaptorPtr->nFormats; i++, formatPtr++)
d460 1
a460 1
	  pVisual = pScreen->visuals;
d462 3
a464 3
	  while(numVisuals--) {
	      if((pVisual->class == formatPtr->class) &&
		 (pVisual->nplanes == formatPtr->depth)) {
d467 1
a467 1
			void *moreSpace;
d469 1
a469 1
			moreSpace = xrealloc(pFormat,
d476 1
a476 1
		   pf->visual = pVisual->vid;
d481 3
a483 3
	      }
	      pVisual++;
	  }
d486 1
a486 1
      pa->pFormats = pFormat;
d488 2
a489 2
	  xf86XVFreeAdaptor(pa);
	  continue;
d493 2
a494 2
	  xf86XVFreeAdaptor(pa);
	  continue;
d513 2
a514 2
	  xf86XVFreeAdaptor(pa);
	  continue;
d516 1
a516 1
      for(pp = pPort, i = 0, numPort = 0;
d519 1
a519 1
	  if(!(pp->id = FakeClientID(0)))
d522 1
a522 1
	  if(!(portPriv = xcalloc(1, sizeof(XvPortRecPrivate))))
d524 1
a524 1

d530 7
a536 7
	  pp->pAdaptor = pa;
	  pp->pNotify = (XvPortNotifyPtr)NULL;
	  pp->pDraw = (DrawablePtr)NULL;
	  pp->client = (ClientPtr)NULL;
	  pp->grab.client = (ClientPtr)NULL;
	  pp->time = currentTime;
	  pp->devPriv.ptr = portPriv;
d540 4
a543 4
	  portPriv->DevPriv.ptr = adaptorPtr->pPortPrivates[i].ptr;

	  pp++;
	  numPort++;
d548 2
a549 2
	  xf86XVFreeAdaptor(pa);
	  continue;
d553 1
a553 1

d579 1
a579 1
   the video.  I like the new method better (MArk).
d585 1
a585 1
static void
d590 1
a590 2
   ScreenPtr	pScreen;
   Bool		freeCompClip = FALSE;
a595 1
   pScreen = pWin->drawable.pScreen;
d610 3
a612 3
   pCompositeClip = REGION_CREATE(pScreen, NullBox, 1);
   REGION_COPY(pScreen, pCompositeClip, portPriv->clientClip);
   REGION_TRANSLATE(pScreen, pCompositeClip,
d615 1
a615 1
   REGION_INTERSECT(pScreen, pCompositeClip, pregWin, pCompositeClip);
d621 2
a622 2
	REGION_DESTROY(pScreen, pregWin);
   }
d630 1
a630 1
   XvPortRecPrivatePtr portPriv,
a632 2
    ScreenPtr pScreen = pGC->pScreen;

d636 1
a636 1
	    portPriv->clientClip = REGION_CREATE(pScreen, NullBox, 1);
d638 1
a638 1
	REGION_COPY(pScreen, portPriv->clientClip, pGC->clientClip);
d640 1
a640 1
	REGION_DESTROY(pScreen, portPriv->clientClip);
d646 1
a646 1
	REGION_DESTROY(pScreen, portPriv->pCompositeClip);
d673 1
a673 1

d676 3
a678 3
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, portPriv->pCompositeClip);

d689 5
a693 5
  ret = (*portPriv->AdaptorRec->GetVideo)(portPriv->pScrn,
			portPriv->vid_x, portPriv->vid_y,
			WinBox.x1, WinBox.y1,
			portPriv->vid_w, portPriv->vid_h,
			portPriv->drw_w, portPriv->drw_h,
d737 1
a737 1

d740 2
a741 2
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, portPriv->pCompositeClip);
d748 1
a748 1
     VPBox.x1 = portPriv->pScrn->frameX0;
d750 1
a750 1
     VPBox.x2 = portPriv->pScrn->frameX1;
d754 1
a754 1
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
d757 1
a757 1

d768 2
a769 2
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
d780 2
a781 2
  ret = (*portPriv->AdaptorRec->PutVideo)(portPriv->pScrn,
			portPriv->vid_x, portPriv->vid_y,
d783 2
a784 2
			portPriv->vid_w, portPriv->vid_h,
			portPriv->drw_w, portPriv->drw_h,
d826 1
a826 1

d829 2
a830 2
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, portPriv->pCompositeClip);
d837 1
a837 1
     VPBox.x1 = portPriv->pScrn->frameX0;
d839 1
a839 1
     VPBox.x2 = portPriv->pScrn->frameX1;
d843 1
a843 1
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
d846 1
a846 1

d857 2
a858 2
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
	  (clipBox->y1 != WinBox.y1) || (clipBox->y2 != WinBox.y2))
d869 1
a869 1
  ret = (*portPriv->AdaptorRec->ReputImage)(portPriv->pScrn,
d913 1
a913 1
   XF86XVWindowPtr winPriv, PrivRoot;
d930 1
a930 1
   }
d944 1
a944 1
	    if(prevPriv)
d946 2
a947 2
	    else
		pWin->devPrivates[XF86XVWindowIndex].ptr =
d952 1
a952 1
	prevPriv = winPriv;
d1011 1
a1011 1

d1022 1
a1022 1
	break;
d1024 2
a1025 2
	xf86XVRegetVideo(pPriv);
	break;
d1039 2
a1040 2
	    if(!pPrev)
	       pWin->devPrivates[XF86XVWindowIndex].ptr =
d1057 1
a1057 1
static void
d1076 1
a1076 1
     /* Stop everything except images, but stop them too if the
d1089 2
a1090 2
	    if(!pPrev)
	       pWin->devPrivates[XF86XVWindowIndex].ptr =
a1124 3
  /* Clear offscreen images */
  (void)memset(&OffscreenImages[pScreen->myNum], 0, sizeof(OffscreenImages[0]));

d1136 2
a1137 2
  pScrn->EnterVT = ScreenPriv->EnterVT;
  pScrn->LeaveVT = ScreenPriv->LeaveVT;
d1140 1
a1140 1
  for(c = 0, pa = pxvs->pAdaptors; c < pxvs->nAdaptors; c++, pa++) {
d1144 3
a1146 1
  xfree(pxvs->pAdaptors);
d1148 2
d1171 1
a1171 1
static Bool
d1180 2
a1181 2
    if(ret) WalkTree(pScreen, xf86XVReputAllVideo, 0);

d1185 1
a1185 1
static void
d1232 1
a1232 1

d1238 2
a1239 2

  for(c = pxvs->nAdaptors, pa = pxvs->pAdaptors; c > 0; c--, pa++) {
d1257 1
a1257 1
	      (pWin->visibility == VisibilityPartiallyObscured)))
d1300 2
a1301 2
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
d1313 1
a1313 1

d1336 1
a1336 1

d1348 2
a1349 2
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
d1372 1
a1372 1

d1374 2
a1375 2
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);
d1381 1
a1381 1
     VPBox.x1 = portPriv->pScrn->frameX0;
d1383 1
a1383 1
     VPBox.x2 = portPriv->pScrn->frameX1;
d1387 1
a1387 1
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
d1403 1
a1403 1
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
d1407 1
a1407 1
	  goto PUT_STILL_BAILOUT;
d1415 1
a1415 1
  ret = (*portPriv->AdaptorRec->PutStill)(portPriv->pScrn,
d1436 3
a1438 3
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
d1453 2
a1454 2
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
d1466 1
a1466 1

d1489 1
a1489 1

d1501 2
a1502 2
   INT16 vid_x, INT16 vid_y,
   CARD16 vid_w, CARD16 vid_h,
d1525 1
a1525 1

d1527 2
a1528 2
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);
d1551 3
a1553 3
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
d1562 1
a1562 1

d1574 1
a1574 1

d1598 2
a1599 2

  return((*portPriv->AdaptorRec->SetPortAttribute)(portPriv->pScrn,
d1612 2
a1613 2

  return((*portPriv->AdaptorRec->GetPortAttribute)(portPriv->pScrn,
d1629 2
a1630 2

  (*portPriv->AdaptorRec->QueryBestSize)(portPriv->pScrn,
d1638 1
a1638 1
static int
d1640 3
a1642 3
   ClientPtr client,
   DrawablePtr pDraw,
   XvPortPtr pPort,
d1644 2
a1645 2
   INT16 src_x, INT16 src_y,
   CARD16 src_w, CARD16 src_h,
d1672 1
a1672 1

d1674 2
a1675 2
  REGION_NULL(pScreen, &ClipRegion);
  REGION_INTERSECT(pScreen, &ClipRegion, &WinRegion, pGC->pCompositeClip);
d1681 1
a1681 1
     VPBox.x1 = portPriv->pScrn->frameX0;
d1683 1
a1683 1
     VPBox.x2 = portPriv->pScrn->frameX1 + 1;
d1687 1
a1687 1
     REGION_INTERSECT(pScreen, &ClipRegion, &ClipRegion, &VPReg);
d1703 1
a1703 1
	  (clipBox->x1 != WinBox.x1) || (clipBox->x2 != WinBox.x2) ||
d1707 1
a1707 1
	  goto PUT_IMAGE_BAILOUT;
d1715 1
a1715 1
  ret = (*portPriv->AdaptorRec->PutImage)(portPriv->pScrn,
d1736 3
a1738 3
	(*portPriv->AdaptorRec->StopVideo)(
		portPriv->pScrn, portPriv->DevPriv.ptr, FALSE);
	portPriv->isOn = XV_PENDING;
d1748 1
a1748 1
static  int
d1750 1
a1750 1
   ClientPtr client,
d1752 3
a1754 3
   XvImagePtr format,
   CARD16 *width,
   CARD16 *height,
d1760 1
a1760 1
  return (*portPriv->AdaptorRec->QueryImageAttributes)(portPriv->pScrn,
d1781 1
a1781 1
				      pval, &status);
d1798 1
a1798 1

d1800 1
a1800 1
			     root, ScreenPriv->videoGC, nbox, rects);
d1805 1
a1805 1
/* xf86XVClipVideoHelper -
d1809 3
a1811 3
   box is returned.  The source boundaries are given (x1, y1
   inclusive, x2, y2 exclusive) and returned are the new source
   boundaries in 16.16 fixed point.
d1827 1
a1827 2
    double xsw, xdw, ysw, ydw;
    INT32 delta;
d1831 2
a1832 4
    xsw = (*xb - *xa) << 16;
    xdw = dst->x2 - dst->x1;
    ysw = (*yb - *ya) << 16;
    ydw = dst->y2 - dst->y1;
d1838 3
a1840 3
    if (diff > 0) {
	dst->x1 = extents->x1;
	*xa += (diff * xsw) / xdw;
d1843 3
a1845 3
    if (diff > 0) {
	dst->x2 = extents->x2;
	*xb -= (diff * xsw) / xdw;
d1848 3
a1850 3
    if (diff > 0) {
	dst->y1 = extents->y1;
	*ya += (diff * ysw) / ydw;
d1853 3
a1855 3
    if (diff > 0) {
	dst->y2 = extents->y2;
	*yb -= (diff * ysw) / ydw;
d1858 4
a1861 4
    if (*xa < 0) {
	diff = (((-*xa) * xdw) + xsw - 1) / xsw;
	dst->x1 += diff;
	*xa += (diff * xsw) / xdw;
d1864 4
a1867 4
    if (delta > 0) {
	diff = ((delta * xdw) + xsw - 1) / xsw;
	dst->x2 -= diff;
	*xb -= (diff * xsw) / xdw;
d1869 1
a1869 1
    if (*xa >= *xb) return FALSE;
d1871 4
a1874 4
    if (*ya < 0) {
	diff = (((-*ya) * ydw) + ysw - 1) / ysw;
	dst->y1 += diff;
	*ya += (diff * ysw) / ydw;
d1877 4
a1880 4
    if (delta > 0) {
	diff = ((delta * ydw) + ysw - 1) / ysw;
	dst->y2 -= diff;
	*yb -= (diff * ysw) / ydw;
d1882 1
a1882 1
    if (*ya >= *yb) return FALSE;
d1884 2
a1885 2
    if ((dst->x1 > extents->x1) || (dst->x2 < extents->x2) ||
	(dst->y1 > extents->y1) || (dst->y2 < extents->y2))
d1887 4
a1890 4
	RegionRec clipReg;
	REGION_INIT(DummyScreen, &clipReg, dst, 1);
	REGION_INTERSECT(DummyScreen, reg, reg, &clipReg);
	REGION_UNINIT(DummyScreen, &clipReg);
a1894 15
void
xf86XVCopyYUV12ToPacked(
    const void *srcy,
    const void *srcv,
    const void *srcu,
    void *dst,
    int srcPitchy,
    int srcPitchuv,
    int dstPitch,
    int h,
    int w
){
    CARD32 *Dst;
    const CARD8 *Y, *U, *V;
    int i, j;
d1896 1
a1896 1
    w >>= 1;
d1898 4
a1901 20
    for (j = 0;  j < h;  j++) {
	Dst = dst;
	Y = srcy;  V = srcv;  U = srcu;
	i = w;
	while (i >= 4) {
#if X_BYTE_ORDER == X_LITTLE_ENDIAN
	    Dst[0] = Y[0] | (Y[1] << 16) | (U[0] << 8) | (V[0] << 24);
	    Dst[1] = Y[2] | (Y[3] << 16) | (U[1] << 8) | (V[1] << 24);
	    Dst[2] = Y[4] | (Y[5] << 16) | (U[2] << 8) | (V[2] << 24);
	    Dst[3] = Y[6] | (Y[7] << 16) | (U[3] << 8) | (V[3] << 24);
#else
	    /* This assumes a little-endian framebuffer */
	    Dst[0] = (Y[0] << 24) | (Y[1] << 8) | (U[0] << 16) | Y[0];
	    Dst[1] = (Y[2] << 24) | (Y[3] << 8) | (U[1] << 16) | Y[1];
	    Dst[2] = (Y[4] << 24) | (Y[5] << 8) | (U[2] << 16) | Y[2];
	    Dst[3] = (Y[6] << 24) | (Y[7] << 8) | (U[3] << 16) | Y[3];
#endif
	    Dst += 4;  Y += 8;  V += 4;  U += 4;
	    i -= 4;
	}
d1903 2
a1904 9
	while (i--) {
#if X_BYTE_ORDER == X_LITTLE_ENDIAN
	    Dst[0] = Y[0] | (Y[1] << 16) | (U[0] << 8) | (V[0] << 24);
#else
	    /* This assumes a little-endian framebuffer */
	    Dst[0] = (Y[0] << 24) | (Y[1] << 8) | (U[0] << 16) | Y[0];
#endif
	    Dst++;  Y += 2;  V++;  U++;
	}
d1906 9
a1914 6
	dst = (CARD8 *)dst + dstPitch;
	srcy = (const CARD8 *)srcy + srcPitchy;
	if (j & 1) {
	    srcu = (const CARD8 *)srcu + srcPitchuv;
	    srcv = (const CARD8 *)srcv + srcPitchuv;
	}
d1916 5
d1923 4
a1926 8
void
xf86XVCopyPacked(
    const void *src,
    void *dst,
    int srcPitch,
    int dstPitch,
    int h,
    int w
d1928 4
a1931 23
    const CARD32 *Src;
    CARD32 *Dst;
    int i;

    w >>= 1;
    while (--h >= 0) {
	do {
	    Dst = dst;  Src = src;
	    i = w;
	    while (i >= 4) {
		Dst[0] = Src[0];
		Dst[1] = Src[1];
		Dst[2] = Src[2];
		Dst[3] = Src[3];
		Dst += 4;  Src += 4;  i -= 4;
	    }
	    if (!i) break;
	    Dst[0] = Src[0];
	    if (i == 1) break;
	    Dst[1] = Src[1];
	    if (i == 2) break;
	    Dst[2] = Src[2];
	} while (0);
d1933 2
a1934 3
	src = (const CARD8 *)src + srcPitch;
	dst = (CARD8 *)dst + dstPitch;
    }
@


1.1.1.4
log
@Import OpenBSD X-Window subsystem (based upon XFree86 4.4RC2)
into vendor branch
@
text
@d31 1
a31 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/common/xf86xv.c,v 1.38 2004/02/19 22:38:12 tsi Exp $ */
d1982 4
a1985 4
	    Dst[0] = (Y[0] << 24) | (Y[1] << 8) | (U[0] << 16) | V[0];
	    Dst[1] = (Y[2] << 24) | (Y[3] << 8) | (U[1] << 16) | V[1];
	    Dst[2] = (Y[4] << 24) | (Y[5] << 8) | (U[2] << 16) | V[2];
	    Dst[3] = (Y[6] << 24) | (Y[7] << 8) | (U[3] << 16) | V[3];
d1996 1
a1996 1
	    Dst[0] = (Y[0] << 24) | (Y[1] << 8) | (U[0] << 16) | V[0];
@


