head	1.2;
access;
symbols
	tg-mergetmp-2:1.2
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407221130:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.2
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.03.07.18.35.08;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.20.06.39;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.06.39;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.35.32;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.14.31;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.22.26;	author tg;	state Exp;
branches;
next	1.1.9.2;

1.1.9.2
date	2004.03.05.22.25.17;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@semi-automagic merge of these files (ie, I've skipped through the diffs,
and most of that was done by cvs or that weird script of some minutes ago)
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/common/compiler.h,v 3.107 2004/02/13 23:58:35 dawes Exp $ */
/*
 * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Thomas Roell not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Thomas Roell makes no representations
 * about the suitability of this software for any purpose.  It is provided
 * "as is" without express or implied warranty.
 *
 * THOMAS ROELL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THOMAS ROELL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 */
/*
 * Copyright (c) 1994-2003 by The XFree86 Project, Inc.
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 *
 *   1.  Redistributions of source code must retain the above copyright
 *       notice, this list of conditions, and the following disclaimer.
 *
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer
 *       in the documentation and/or other materials provided with the
 *       distribution, and in the same place and form as other copyright,
 *       license and disclaimer information.
 *
 *   3.  The end-user documentation included with the redistribution,
 *       if any, must include the following acknowledgment: "This product
 *       includes software developed by The XFree86 Project, Inc
 *       (http://www.xfree86.org/) and its contributors", in the same
 *       place and form as other third-party acknowledgments.  Alternately,
 *       this acknowledgment may appear in the software itself, in the
 *       same form and location as other such third-party acknowledgments.
 *
 *   4.  Except as contained in this notice, the name of The XFree86
 *       Project, Inc shall not be used in advertising or otherwise to
 *       promote the sale, use or other dealings in this Software without
 *       prior written authorization from The XFree86 Project, Inc.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE XFREE86 PROJECT, INC OR ITS CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* $XConsortium: compiler.h /main/16 1996/10/25 15:38:34 kaleb $ */

#ifndef _COMPILER_H

# if !defined(_XF86_ANSIC_H) && defined(XFree86Module)
#  error missing #include "xf86_ansic.h" before #include "compiler.h"
# endif

# define _COMPILER_H

#if defined(__SUNPRO_C)
# define DO_PROTOTYPES
#endif

/* Allow drivers to use the GCC-supported __inline__ and/or __inline. */
# ifndef __inline__
#  if defined(__GNUC__)
    /* gcc has __inline__ */
#  elif defined(__HIGHC__)
#   define __inline__ _Inline
#  else
#   define __inline__ /**/
#  endif
# endif /* __inline__ */
# ifndef __inline
#  if defined(__GNUC__)
    /* gcc has __inline */
#  elif defined(__HIGHC__)
#   define __inline _Inline
#  else
#   define __inline /**/
#  endif
# endif /* __inline */

# if defined(IODEBUG) && defined(__GNUC__)
#  define outb RealOutb
#  define outw RealOutw
#  define outl RealOutl
#  define inb RealInb
#  define inw RealInw
#  define inl RealInl
# endif

# if defined(QNX4) /* Do this for now to keep Watcom happy */
#  define outb outp
#  define outw outpw
#  define outl outpd 
#  define inb inp
#  define inw inpw
#  define inl inpd

/* Define the ffs function for inlining */
extern int ffs(unsigned long);
#  pragma aux ffs_ = \
        "bsf edx, eax"          \
        "jnz bits_set"          \
        "xor eax, eax"          \
        "jmp exit1"             \
        "bits_set:"             \
        "mov eax, edx"          \
        "inc eax"               \
        "exit1:"                \
        __parm [eax]            \
        __modify [eax edx]      \
        __value [eax]           \
        ;
# endif

# if defined(NO_INLINE) || defined(DO_PROTOTYPES)

#  if !defined(__sparc__) && !defined(__arm32__) \
      && !(defined(__alpha__) && defined(linux))

extern void outb(unsigned short, unsigned char);
extern void outw(unsigned short, unsigned short);
extern void outl(unsigned short, unsigned int);
extern unsigned int inb(unsigned short);
extern unsigned int inw(unsigned short);
extern unsigned int inl(unsigned short);

#  else /* __sparc__,  __arm32__, __alpha__*/

extern void outb(unsigned long, unsigned char);
extern void outw(unsigned long, unsigned short);
extern void outl(unsigned long, unsigned int);
extern unsigned int inb(unsigned long);
extern unsigned int inw(unsigned long);
extern unsigned int inl(unsigned long);

#  endif /* __sparc__,  __arm32__, __alpha__ */

extern unsigned long ldq_u(unsigned long *);
extern unsigned long ldl_u(unsigned int *);
extern unsigned long ldw_u(unsigned short *);
extern void stq_u(unsigned long, unsigned long *);
extern void stl_u(unsigned long, unsigned int *);
extern void stw_u(unsigned long, unsigned short *);
extern void mem_barrier(void);
extern void write_mem_barrier(void);
extern void stl_brx(unsigned long, volatile unsigned char *, int);
extern void stw_brx(unsigned short, volatile unsigned char *, int);
extern unsigned long ldl_brx(volatile unsigned char *, int);
extern unsigned short ldw_brx(volatile unsigned char *, int);

# endif

# ifndef NO_INLINE
#  ifdef __GNUC__
#   if (defined(linux) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)) && defined(__alpha__)

#    ifdef linux
/* for Linux on Alpha, we use the LIBC _inx/_outx routines */
/* note that the appropriate setup via "ioperm" needs to be done */
/*  *before* any inx/outx is done. */

extern void (*_alpha_outb)(char val, unsigned long port);
static __inline__ void
outb(unsigned long port, unsigned char val)
{
    _alpha_outb(val, port);
}

extern void (*_alpha_outw)(short val, unsigned long port);
static __inline__ void
outw(unsigned long port, unsigned short val)
{
    _alpha_outw(val, port);
}

extern void (*_alpha_outl)(int val, unsigned long port);
static __inline__ void
outl(unsigned long port, unsigned int val)
{
    _alpha_outl(val, port);
}

extern unsigned int (*_alpha_inb)(unsigned long port);
static __inline__ unsigned int
inb(unsigned long port)
{
  return _alpha_inb(port);
}

extern unsigned int (*_alpha_inw)(unsigned long port);
static __inline__ unsigned int
inw(unsigned long port)
{
  return _alpha_inw(port);
}

extern unsigned int (*_alpha_inl)(unsigned long port);
static __inline__ unsigned int
inl(unsigned long port)
{
  return _alpha_inl(port);
}

#    endif /* linux */

#    if (defined(__FreeBSD__) || defined(__OpenBSD__)) \
      && !defined(DO_PROTOTYPES)

/* for FreeBSD and OpenBSD on Alpha, we use the libio (resp. libalpha) */
/*  inx/outx routines */
/* note that the appropriate setup via "ioperm" needs to be done */
/*  *before* any inx/outx is done. */

extern void outb(unsigned int port, unsigned char val);
extern void outw(unsigned int port, unsigned short val);
extern void outl(unsigned int port, unsigned int val);
extern unsigned char inb(unsigned int port);
extern unsigned short inw(unsigned int port);
extern unsigned int inl(unsigned int port);

#    endif /* (__FreeBSD__ || __OpenBSD__ ) && !DO_PROTOTYPES */


#if defined(__NetBSD__)
#include <machine/pio.h>
#endif /* __NetBSD__ */

/*
 * inline functions to do unaligned accesses
 * from linux/include/asm-alpha/unaligned.h
 */

/*
 * EGCS 1.1 knows about arbitrary unaligned loads.  Define some
 * packed structures to talk about such things with.
 */

struct __una_u64 { unsigned long  x __attribute__((packed)); };
struct __una_u32 { unsigned int   x __attribute__((packed)); };
struct __una_u16 { unsigned short x __attribute__((packed)); };

/*
 * Elemental unaligned loads 
 */
/* let's try making these things static */

static __inline__ unsigned long ldq_u(unsigned long * r11)
{
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
	const struct __una_u64 *ptr = (const struct __una_u64 *) r11;
	return ptr->x;
#    else
	unsigned long r1,r2;
	__asm__("ldq_u %0,%3\n\t"
		"ldq_u %1,%4\n\t"
		"extql %0,%2,%0\n\t"
		"extqh %1,%2,%1"
		:"=&r" (r1), "=&r" (r2)
		:"r" (r11),
		 "m" (*r11),
		 "m" (*(const unsigned long *)(7+(char *) r11)));
	return r1 | r2;
#    endif
}

static __inline__ unsigned long ldl_u(unsigned int * r11)
{
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
	const struct __una_u32 *ptr = (const struct __una_u32 *) r11;
	return ptr->x;
#    else
	unsigned long r1,r2;
	__asm__("ldq_u %0,%3\n\t"
		"ldq_u %1,%4\n\t"
		"extll %0,%2,%0\n\t"
		"extlh %1,%2,%1"
		:"=&r" (r1), "=&r" (r2)
		:"r" (r11),
		 "m" (*r11),
		 "m" (*(const unsigned long *)(3+(char *) r11)));
	return r1 | r2;
#    endif
}

static __inline__ unsigned long ldw_u(unsigned short * r11)
{
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
	const struct __una_u16 *ptr = (const struct __una_u16 *) r11;
	return ptr->x;
#    else
	unsigned long r1,r2;
	__asm__("ldq_u %0,%3\n\t"
		"ldq_u %1,%4\n\t"
		"extwl %0,%2,%0\n\t"
		"extwh %1,%2,%1"
		:"=&r" (r1), "=&r" (r2)
		:"r" (r11),
		 "m" (*r11),
		 "m" (*(const unsigned long *)(1+(char *) r11)));
	return r1 | r2;
#    endif
}

/*
 * Elemental unaligned stores 
 */

static __inline__ void stq_u(unsigned long r5, unsigned long * r11)
{
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
	struct __una_u64 *ptr = (struct __una_u64 *) r11;
	ptr->x = r5;
#    else
	unsigned long r1,r2,r3,r4;

	__asm__("ldq_u %3,%1\n\t"
		"ldq_u %2,%0\n\t"
		"insqh %6,%7,%5\n\t"
		"insql %6,%7,%4\n\t"
		"mskqh %3,%7,%3\n\t"
		"mskql %2,%7,%2\n\t"
		"bis %3,%5,%3\n\t"
		"bis %2,%4,%2\n\t"
		"stq_u %3,%1\n\t"
		"stq_u %2,%0"
		:"=m" (*r11),
		 "=m" (*(unsigned long *)(7+(char *) r11)),
		 "=&r" (r1), "=&r" (r2), "=&r" (r3), "=&r" (r4)
		:"r" (r5), "r" (r11));
#    endif
}

static __inline__ void stl_u(unsigned long r5, unsigned int * r11)
{
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
	struct __una_u32 *ptr = (struct __una_u32 *) r11;
	ptr->x = r5;
#    else
	unsigned long r1,r2,r3,r4;

	__asm__("ldq_u %3,%1\n\t"
		"ldq_u %2,%0\n\t"
		"inslh %6,%7,%5\n\t"
		"insll %6,%7,%4\n\t"
		"msklh %3,%7,%3\n\t"
		"mskll %2,%7,%2\n\t"
		"bis %3,%5,%3\n\t"
		"bis %2,%4,%2\n\t"
		"stq_u %3,%1\n\t"
		"stq_u %2,%0"
		:"=m" (*r11),
		 "=m" (*(unsigned long *)(3+(char *) r11)),
		 "=&r" (r1), "=&r" (r2), "=&r" (r3), "=&r" (r4)
		:"r" (r5), "r" (r11));
#    endif
}

static __inline__ void stw_u(unsigned long r5, unsigned short * r11)
{
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
	struct __una_u16 *ptr = (struct __una_u16 *) r11;
	ptr->x = r5;
#    else
	unsigned long r1,r2,r3,r4;

	__asm__("ldq_u %3,%1\n\t"
		"ldq_u %2,%0\n\t"
		"inswh %6,%7,%5\n\t"
		"inswl %6,%7,%4\n\t"
		"mskwh %3,%7,%3\n\t"
		"mskwl %2,%7,%2\n\t"
		"bis %3,%5,%3\n\t"
		"bis %2,%4,%2\n\t"
		"stq_u %3,%1\n\t"
		"stq_u %2,%0"
		:"=m" (*r11),
		 "=m" (*(unsigned long *)(1+(char *) r11)),
		 "=&r" (r1), "=&r" (r2), "=&r" (r3), "=&r" (r4)
		:"r" (r5), "r" (r11));
#    endif
}

/* to flush the I-cache before jumping to code which just got loaded */
#ifdef __FreeBSD__
#    define PAL_imb 134
#endif
#ifdef __OpenBSD__
#include <machine/pal.h>
#endif
#    define istream_mem_barrier() \
	__asm__ __volatile__("call_pal %0 #imb" : : "i" (PAL_imb) : "memory")
#    define mem_barrier()        __asm__ __volatile__("mb"  : : : "memory")
#    ifdef __ELF__
#     define write_mem_barrier()  __asm__ __volatile__("wmb" : : : "memory")
#    else  /*  ECOFF gas 2.6 doesn't know "wmb" :-(  */
#     define write_mem_barrier()  mem_barrier()
#    endif


#   elif defined(linux) && defined(__ia64__) 
 
#    include <inttypes.h>

#    include <sys/io.h>

struct __una_u64 { uint64_t x __attribute__((packed)); };
struct __una_u32 { uint32_t x __attribute__((packed)); };
struct __una_u16 { uint16_t x __attribute__((packed)); };

static __inline__ unsigned long
__uldq (const unsigned long * r11)
{
	const struct __una_u64 *ptr = (const struct __una_u64 *) r11;
	return ptr->x;
}

static __inline__ unsigned long
__uldl (const unsigned int * r11)
{
	const struct __una_u32 *ptr = (const struct __una_u32 *) r11;
	return ptr->x;
}

static __inline__ unsigned long
__uldw (const unsigned short * r11)
{
	const struct __una_u16 *ptr = (const struct __una_u16 *) r11;
	return ptr->x;
}

static __inline__ void
__ustq (unsigned long r5, unsigned long * r11)
{
	struct __una_u64 *ptr = (struct __una_u64 *) r11;
	ptr->x = r5;
}

static __inline__ void
__ustl (unsigned long r5, unsigned int * r11)
{
	struct __una_u32 *ptr = (struct __una_u32 *) r11;
	ptr->x = r5;
}

static __inline__ void
__ustw (unsigned long r5, unsigned short * r11)
{
	struct __una_u16 *ptr = (struct __una_u16 *) r11;
	ptr->x = r5;
}

#    define ldq_u(p)	__uldq(p)
#    define ldl_u(p)	__uldl(p)
#    define ldw_u(p)	__uldw(p) 
#    define stq_u(v,p)	__ustq(v,p)
#    define stl_u(v,p)	__ustl(v,p)
#    define stw_u(v,p)	__ustw(v,p)

#    ifndef __INTEL_COMPILER  
#      define mem_barrier()        __asm__ __volatile__ ("mf" ::: "memory")
#      define write_mem_barrier()  __asm__ __volatile__ ("mf" ::: "memory")
#    else
#      include "ia64intrin.h"
#      define mem_barrier() __mf()
#      define write_mem_barrier() __mf()
#    endif

/*
 * This is overkill, but for different reasons depending on where it is used.
 * This is thus general enough to be used everywhere cache flushes are needed.
 * It doesn't handle memory access serialisation by other processors, though.
 */
#    ifndef __INTEL_COMPILER
#       define ia64_flush_cache(Addr) \
	__asm__ __volatile__ ( \
		"fc %0;;;" \
		"sync.i;;;" \
		"mf;;;" \
		"srlz.i;;;" \
		:: "r"(Addr) : "memory")
#    else
#      define ia64_flush_cache(Addr) { \
        __fc(Addr);\
        __synci();\
        __mf();\
        __isrlz();\
       }
#    endif
#    undef outb
#    undef outw
#    undef outl
 
#    define outb(a,b)	_outb(b,a)
#    define outw(a,b)	_outw(b,a)
#    define outl(a,b)	_outl(b,a) 

#   elif defined(linux) && defined(__AMD64__) 
 
#    include <inttypes.h>

#    define ldq_u(p)	(*((unsigned long  *)(p)))
#    define ldl_u(p)	(*((unsigned int   *)(p)))
#    define ldw_u(p)	(*((unsigned short *)(p)))
#    define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#    define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#    define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
  
#    define mem_barrier() \
       __asm__ __volatile__ ("lock; addl $0,0(%%rsp)": : :"memory")
#    define write_mem_barrier() \
       __asm__ __volatile__ ("": : :"memory")


static __inline__ void
outb(unsigned short port, unsigned char val)
{
   __asm__ __volatile__("outb %0,%1" : :"a" (val), "d" (port));
}


static __inline__ void
outw(unsigned short port, unsigned short val)
{
   __asm__ __volatile__("outw %0,%1" : :"a" (val), "d" (port));
}

static __inline__ void
outl(unsigned short port, unsigned int val)
{
   __asm__ __volatile__("outl %0,%1" : :"a" (val), "d" (port));
}

static __inline__ unsigned int
inb(unsigned short port)
{
   unsigned char ret;
   __asm__ __volatile__("inb %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
}

static __inline__ unsigned int
inw(unsigned short port)
{
   unsigned short ret;
   __asm__ __volatile__("inw %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
}

static __inline__ unsigned int
inl(unsigned short port)
{
   unsigned int ret;
   __asm__ __volatile__("inl %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
}

#   elif (defined(linux) || defined(Lynx) || defined(sun) || defined(__OpenBSD__) || defined(__FreeBSD__)) && defined(__sparc__)

#    if !defined(Lynx)
#     ifndef ASI_PL
#      define ASI_PL 0x88
#     endif

#     define barrier() __asm__ __volatile__(".word 0x8143e00a": : :"memory")

static __inline__ void
outb(unsigned long port, unsigned char val)
{
	__asm__ __volatile__("stba %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (port), "i" (ASI_PL));
	barrier();
}

static __inline__ void
outw(unsigned long port, unsigned short val)
{
	__asm__ __volatile__("stha %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (port), "i" (ASI_PL));
	barrier();
}

static __inline__ void
outl(unsigned long port, unsigned int val)
{
	__asm__ __volatile__("sta %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (port), "i" (ASI_PL));
	barrier();
}

static __inline__ unsigned int
inb(unsigned long port)
{
	unsigned int ret;
	__asm__ __volatile__("lduba [%1] %2, %0"
			     : "=r" (ret)
			     : "r" (port), "i" (ASI_PL));
	return ret;
}

static __inline__ unsigned int
inw(unsigned long port)
{
	unsigned int ret;
	__asm__ __volatile__("lduha [%1] %2, %0"
			     : "=r" (ret)
			     : "r" (port), "i" (ASI_PL));
	return ret;
}

static __inline__ unsigned int
inl(unsigned long port)
{
	unsigned int ret;
	__asm__ __volatile__("lda [%1] %2, %0"
			     : "=r" (ret)
			     : "r" (port), "i" (ASI_PL));
	return ret;
}

static __inline__ unsigned char
xf86ReadMmio8(__volatile__ void *base, const unsigned long offset)
{
	unsigned long addr = ((unsigned long)base) + offset;
	unsigned char ret;

	__asm__ __volatile__("lduba [%1] %2, %0"
			     : "=r" (ret)
			     : "r" (addr), "i" (ASI_PL));
	return ret;
}

static __inline__ unsigned short
xf86ReadMmio16Be(__volatile__ void *base, const unsigned long offset)
{
	unsigned long addr = ((unsigned long)base) + offset;
	unsigned short ret;

	__asm__ __volatile__("lduh [%1], %0"
			     : "=r" (ret)
			     : "r" (addr));
	return ret;
}

static __inline__ unsigned short
xf86ReadMmio16Le(__volatile__ void *base, const unsigned long offset)
{
	unsigned long addr = ((unsigned long)base) + offset;
	unsigned short ret;

	__asm__ __volatile__("lduha [%1] %2, %0"
			     : "=r" (ret)
			     : "r" (addr), "i" (ASI_PL));
	return ret;
}

static __inline__ unsigned int
xf86ReadMmio32Be(__volatile__ void *base, const unsigned long offset)
{
	unsigned long addr = ((unsigned long)base) + offset;
	unsigned int ret;

	__asm__ __volatile__("ld [%1], %0"
			     : "=r" (ret)
			     : "r" (addr));
	return ret;
}

static __inline__ unsigned int
xf86ReadMmio32Le(__volatile__ void *base, const unsigned long offset)
{
	unsigned long addr = ((unsigned long)base) + offset;
	unsigned int ret;

	__asm__ __volatile__("lda [%1] %2, %0"
			     : "=r" (ret)
			     : "r" (addr), "i" (ASI_PL));
	return ret;
}

static __inline__ void
xf86WriteMmio8(__volatile__ void *base, const unsigned long offset,
	       const unsigned int val)
{
	unsigned long addr = ((unsigned long)base) + offset;

	__asm__ __volatile__("stba %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (addr), "i" (ASI_PL));
	barrier();
}

static __inline__ void
xf86WriteMmio16Be(__volatile__ void *base, const unsigned long offset,
		  const unsigned int val)
{
	unsigned long addr = ((unsigned long)base) + offset;

	__asm__ __volatile__("sth %0, [%1]"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
	barrier();
}

static __inline__ void
xf86WriteMmio16Le(__volatile__ void *base, const unsigned long offset,
		  const unsigned int val)
{
	unsigned long addr = ((unsigned long)base) + offset;

	__asm__ __volatile__("stha %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (addr), "i" (ASI_PL));
	barrier();
}

static __inline__ void
xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
		  const unsigned int val)
{
	unsigned long addr = ((unsigned long)base) + offset;

	__asm__ __volatile__("st %0, [%1]"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
	barrier();
}

static __inline__ void
xf86WriteMmio32Le(__volatile__ void *base, const unsigned long offset,
		  const unsigned int val)
{
	unsigned long addr = ((unsigned long)base) + offset;

	__asm__ __volatile__("sta %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (addr), "i" (ASI_PL));
	barrier();
}

static __inline__ void
xf86WriteMmio8NB(__volatile__ void *base, const unsigned long offset,
		 const unsigned int val)
{
	unsigned long addr = ((unsigned long)base) + offset;

	__asm__ __volatile__("stba %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (addr), "i" (ASI_PL));
}

static __inline__ void
xf86WriteMmio16BeNB(__volatile__ void *base, const unsigned long offset,
		    const unsigned int val)
{
	unsigned long addr = ((unsigned long)base) + offset;

	__asm__ __volatile__("sth %0, [%1]"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
}

static __inline__ void
xf86WriteMmio16LeNB(__volatile__ void *base, const unsigned long offset,
		    const unsigned int val)
{
	unsigned long addr = ((unsigned long)base) + offset;

	__asm__ __volatile__("stha %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (addr), "i" (ASI_PL));
}

static __inline__ void
xf86WriteMmio32BeNB(__volatile__ void *base, const unsigned long offset,
		    const unsigned int val)
{
	unsigned long addr = ((unsigned long)base) + offset;

	__asm__ __volatile__("st %0, [%1]"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
}

static __inline__ void
xf86WriteMmio32LeNB(__volatile__ void *base, const unsigned long offset,
		    const unsigned int val)
{
	unsigned long addr = ((unsigned long)base) + offset;

	__asm__ __volatile__("sta %0, [%1] %2"
			     : /* No outputs */
			     : "r" (val), "r" (addr), "i" (ASI_PL));
}

#    endif	/* !Lynx */

/*
 * EGCS 1.1 knows about arbitrary unaligned loads.  Define some
 * packed structures to talk about such things with.
 */

#    if defined(__arch64__) || defined(__sparcv9)
struct __una_u64 { unsigned long  x __attribute__((packed)); };
#    endif
struct __una_u32 { unsigned int   x __attribute__((packed)); };
struct __una_u16 { unsigned short x __attribute__((packed)); };

static __inline__ unsigned long ldq_u(unsigned long *p)
{
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
#     if defined(__arch64__) || defined(__sparcv9)
	const struct __una_u64 *ptr = (const struct __una_u64 *) p;
#     else
	const struct __una_u32 *ptr = (const struct __una_u32 *) p;
#     endif
	return ptr->x;
#    else
	unsigned long ret;
	memmove(&ret, p, sizeof(*p));
	return ret;
#    endif
}

static __inline__ unsigned long ldl_u(unsigned int *p)
{
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
	const struct __una_u32 *ptr = (const struct __una_u32 *) p;
	return ptr->x;
#    else
	unsigned int ret;
	memmove(&ret, p, sizeof(*p));
	return ret;
#    endif
}

static __inline__ unsigned long ldw_u(unsigned short *p)
{
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
	const struct __una_u16 *ptr = (const struct __una_u16 *) p;
	return ptr->x;
#    else
	unsigned short ret;
	memmove(&ret, p, sizeof(*p));
	return ret;
#    endif
}

static __inline__ void stq_u(unsigned long val, unsigned long *p)
{
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
#     if defined(__arch64__) || defined(__sparcv9)
	struct __una_u64 *ptr = (struct __una_u64 *) p;
#     else
	struct __una_u32 *ptr = (struct __una_u32 *) p;
#     endif
	ptr->x = val;
#    else
	unsigned long tmp = val;
	memmove(p, &tmp, sizeof(*p));
#    endif
}

static __inline__ void stl_u(unsigned long val, unsigned int *p)
{
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
	struct __una_u32 *ptr = (struct __una_u32 *) p;
	ptr->x = val;
#    else
	unsigned int tmp = val;
	memmove(p, &tmp, sizeof(*p));
#    endif
}

static __inline__ void stw_u(unsigned long val, unsigned short *p)
{
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
	struct __una_u16 *ptr = (struct __una_u16 *) p;
	ptr->x = val;
#    else
	unsigned short tmp = val;
	memmove(p, &tmp, sizeof(*p));
#    endif
}

#    define mem_barrier()         /* XXX: nop for now */
#    define write_mem_barrier()   /* XXX: nop for now */

#   elif defined(__mips__) || defined(__arm32__)
#ifdef __arm32__
#define PORT_SIZE long
#else
#define PORT_SIZE short
#endif

unsigned int IOPortBase;  /* Memory mapped I/O port area */

static __inline__ void
outb(unsigned PORT_SIZE port, unsigned char val)
{
	*(volatile unsigned char*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
}

static __inline__ void
outw(unsigned PORT_SIZE port, unsigned short val)
{
	*(volatile unsigned short*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
}

static __inline__ void
outl(unsigned PORT_SIZE port, unsigned int val)
{
	*(volatile unsigned int*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
}

static __inline__ unsigned int
inb(unsigned PORT_SIZE port)
{
	return *(volatile unsigned char*)(((unsigned PORT_SIZE)(port))+IOPortBase);
}

static __inline__ unsigned int
inw(unsigned PORT_SIZE port)
{
	return *(volatile unsigned short*)(((unsigned PORT_SIZE)(port))+IOPortBase);
}

static __inline__ unsigned int
inl(unsigned PORT_SIZE port)
{
	return *(volatile unsigned int*)(((unsigned PORT_SIZE)(port))+IOPortBase);
}


#    if defined(__mips__)
static __inline__ unsigned long ldq_u(unsigned long * r11)
{
	unsigned long r1;
	__asm__("lwr %0,%2\n\t"
		"lwl %0,%3\n\t"
		:"=&r" (r1)
		:"r" (r11),
		 "m" (*r11),
		 "m" (*(unsigned long *)(3+(char *) r11)));
	return r1;
}

static __inline__ unsigned long ldl_u(unsigned int * r11)
{
	unsigned long r1;
	__asm__("lwr %0,%2\n\t"
		"lwl %0,%3\n\t"
		:"=&r" (r1)
		:"r" (r11),
		 "m" (*r11),
		 "m" (*(unsigned long *)(3+(char *) r11)));
	return r1;
}

static __inline__ unsigned long ldw_u(unsigned short * r11)
{
	unsigned long r1;
	__asm__("lwr %0,%2\n\t"
		"lwl %0,%3\n\t"
		:"=&r" (r1)
		:"r" (r11),
		 "m" (*r11),
		 "m" (*(unsigned long *)(1+(char *) r11)));
	return r1;
}

#     ifdef linux	/* don't mess with other OSs */

/*
 * EGCS 1.1 knows about arbitrary unaligned loads (and we don't support older
 * versions anyway. Define some packed structures to talk about such things
 * with.
 */

struct __una_u32 { unsigned int   x __attribute__((packed)); };
struct __una_u16 { unsigned short x __attribute__((packed)); };

static __inline__ void stw_u(unsigned long val, unsigned short *p)
{
	struct __una_u16 *ptr = (struct __una_u16 *) p;
	ptr->x = val;
}

static __inline__ void stl_u(unsigned long val, unsigned int *p)
{
	struct __una_u32 *ptr = (struct __una_u32 *) p;
	ptr->x = val;
}

#       if X_BYTE_ORDER == X_BIG_ENDIAN
static __inline__ unsigned int
xf86ReadMmio32Be(__volatile__ void *base, const unsigned long offset)
{
	unsigned long addr = ((unsigned long)base) + offset;
	unsigned int ret;

	__asm__ __volatile__("lw %0, 0(%1)"
			     : "=r" (ret)
			     : "r" (addr));
	return ret;
}

static __inline__ void
xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
		  const unsigned int val)
{
	unsigned long addr = ((unsigned long)base) + offset;

	__asm__ __volatile__("sw %0, 0(%1)"
			     : /* No outputs */
			     : "r" (val), "r" (addr));
}
#      endif

#      define mem_barrier() \
        __asm__ __volatile__(					\
		"# prevent instructions being moved around\n\t"	\
       		".set\tnoreorder\n\t"				\
		"# 8 nops to fool the R4400 pipeline\n\t"	\
		"nop;nop;nop;nop;nop;nop;nop;nop\n\t"		\
		".set\treorder"					\
		: /* no output */				\
		: /* no input */				\
		: "memory")
#      define write_mem_barrier() mem_barrier()

#     else  /* !linux */

#      define stq_u(v,p)	stl_u(v,p)
#      define stl_u(v,p)	(*(unsigned char *)(p)) = (v); \
			(*(unsigned char *)(p)+1) = ((v) >> 8);  \
			(*(unsigned char *)(p)+2) = ((v) >> 16); \
			(*(unsigned char *)(p)+3) = ((v) >> 24)

#      define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
				(*(unsigned char *)(p)+1) = ((v) >> 8)

#      define mem_barrier()   /* NOP */
#     endif /* !linux */
#    endif /* __mips__ */

#    if defined(__arm32__)
#     define ldq_u(p)	(*((unsigned long  *)(p)))
#     define ldl_u(p)	(*((unsigned int   *)(p)))
#     define ldw_u(p)	(*((unsigned short *)(p)))
#     define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#     define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#     define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#     define mem_barrier()	/* NOP */
#     define write_mem_barrier()	/* NOP */
#    endif /* __arm32__ */

#   elif (defined(Lynx) || defined(linux) || defined(__OpenBSD__) || defined(__NetBSD__)) && defined(__powerpc__)

#    ifndef MAP_FAILED
#     define MAP_FAILED ((void *)-1)
#    endif

extern volatile unsigned char *ioBase;

#    define eieio()		__asm__ __volatile__ ("eieio" ::: "memory")

static __inline__ unsigned char
xf86ReadMmio8(__volatile__ void *base, const unsigned long offset)
{
        register unsigned char val;
        __asm__ __volatile__(
                        "lbzx %0,%1,%2\n\t"
                        "eieio"
                        : "=r" (val)
                        : "b" (base), "r" (offset),
                        "m" (*((volatile unsigned char *)base+offset)));
        return val;
}

static __inline__ unsigned short
xf86ReadMmio16Be(__volatile__ void *base, const unsigned long offset)
{
        register unsigned short val;
        __asm__ __volatile__(
                        "lhzx %0,%1,%2\n\t"
                        "eieio"
                        : "=r" (val)
                        : "b" (base), "r" (offset),
                        "m" (*((volatile unsigned char *)base+offset)));
        return val;
}

static __inline__ unsigned short
xf86ReadMmio16Le(__volatile__ void *base, const unsigned long offset)
{
        register unsigned short val;
        __asm__ __volatile__(
                        "lhbrx %0,%1,%2\n\t"
                        "eieio"
                        : "=r" (val)
                        : "b" (base), "r" (offset),
                        "m" (*((volatile unsigned char *)base+offset)));
        return val;
}

static __inline__ unsigned int
xf86ReadMmio32Be(__volatile__ void *base, const unsigned long offset)
{
        register unsigned int val;
        __asm__ __volatile__(
                        "lwzx %0,%1,%2\n\t"
                        "eieio"
                        : "=r" (val)
                        : "b" (base), "r" (offset),
                        "m" (*((volatile unsigned char *)base+offset)));
        return val;
}

static __inline__ unsigned int
xf86ReadMmio32Le(__volatile__ void *base, const unsigned long offset)
{
        register unsigned int val;
        __asm__ __volatile__(
                        "lwbrx %0,%1,%2\n\t"
                        "eieio"
                        : "=r" (val)
                        : "b" (base), "r" (offset),
                        "m" (*((volatile unsigned char *)base+offset)));
        return val;
}

static __inline__ void
xf86WriteMmioNB8(__volatile__ void *base, const unsigned long offset,
		 const unsigned char val)
{
        __asm__ __volatile__(
                        "stbx %1,%2,%3\n\t"
                        : "=m" (*((volatile unsigned char *)base+offset))
                        : "r" (val), "b" (base), "r" (offset));
}

static __inline__ void
xf86WriteMmioNB16Le(__volatile__ void *base, const unsigned long offset,
		    const unsigned short val)
{
        __asm__ __volatile__(
                        "sthbrx %1,%2,%3\n\t"
                        : "=m" (*((volatile unsigned char *)base+offset))
                        : "r" (val), "b" (base), "r" (offset));
}

static __inline__ void
xf86WriteMmioNB16Be(__volatile__ void *base, const unsigned long offset,
		    const unsigned short val)
{
        __asm__ __volatile__(
                        "sthx %1,%2,%3\n\t"
                        : "=m" (*((volatile unsigned char *)base+offset))
                        : "r" (val), "b" (base), "r" (offset));
}

static __inline__ void
xf86WriteMmioNB32Le(__volatile__ void *base, const unsigned long offset,
		    const unsigned int val)
{
        __asm__ __volatile__(
                        "stwbrx %1,%2,%3\n\t"
                        : "=m" (*((volatile unsigned char *)base+offset))
                        : "r" (val), "b" (base), "r" (offset));
}

static __inline__ void
xf86WriteMmioNB32Be(__volatile__ void *base, const unsigned long offset,
		    const unsigned int val)
{
        __asm__ __volatile__(
                        "stwx %1,%2,%3\n\t"
                        : "=m" (*((volatile unsigned char *)base+offset))
                        : "r" (val), "b" (base), "r" (offset));
}

static __inline__ void
xf86WriteMmio8(__volatile__ void *base, const unsigned long offset,
               const unsigned char val)
{
        xf86WriteMmioNB8(base, offset, val);
        eieio();
}

static __inline__ void
xf86WriteMmio16Le(__volatile__ void *base, const unsigned long offset,
                  const unsigned short val)
{
        xf86WriteMmioNB16Le(base, offset, val);
        eieio();
}

static __inline__ void
xf86WriteMmio16Be(__volatile__ void *base, const unsigned long offset,
                  const unsigned short val)
{
        xf86WriteMmioNB16Be(base, offset, val);
        eieio();
}

static __inline__ void
xf86WriteMmio32Le(__volatile__ void *base, const unsigned long offset,
                  const unsigned int val)
{
        xf86WriteMmioNB32Le(base, offset, val);
        eieio();
}

static __inline__ void
xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
                  const unsigned int val)
{
        xf86WriteMmioNB32Be(base, offset, val);
        eieio();
}


static __inline__ void
outb(unsigned short port, unsigned char value)
{
        if(ioBase == MAP_FAILED) return;
        xf86WriteMmio8((void *)ioBase, port, value);
}

static __inline__ void
outw(unsigned short port, unsigned short value)
{
        if(ioBase == MAP_FAILED) return;
        xf86WriteMmio16Le((void *)ioBase, port, value);
}

static __inline__ void
outl(unsigned short port, unsigned int value)
{
        if(ioBase == MAP_FAILED) return;
        xf86WriteMmio32Le((void *)ioBase, port, value);
}

static __inline__ unsigned int
inb(unsigned short port)
{
        if(ioBase == MAP_FAILED) return 0;
        return xf86ReadMmio8((void *)ioBase, port);
}

static __inline__ unsigned int
inw(unsigned short port)
{
        if(ioBase == MAP_FAILED) return 0;
        return xf86ReadMmio16Le((void *)ioBase, port);
}

static __inline__ unsigned int
inl(unsigned short port)
{
        if(ioBase == MAP_FAILED) return 0;
        return xf86ReadMmio32Le((void *)ioBase, port);
}

#    define ldq_u(p)	ldl_u(p)
#    define ldl_u(p)	((*(unsigned char *)(p))	| \
			(*((unsigned char *)(p)+1)<<8)	| \
			(*((unsigned char *)(p)+2)<<16)	| \
			(*((unsigned char *)(p)+3)<<24))
#    define ldw_u(p)	((*(unsigned char *)(p)) | \
			(*((unsigned char *)(p)+1)<<8))

#    define stq_u(v,p)	stl_u(v,p)
#    define stl_u(v,p)	(*(unsigned char *)(p)) = (v); \
				(*((unsigned char *)(p)+1)) = ((v) >> 8);  \
				(*((unsigned char *)(p)+2)) = ((v) >> 16); \
				(*((unsigned char *)(p)+3)) = ((v) >> 24)
#    define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
				(*((unsigned char *)(p)+1)) = ((v) >> 8)

#    define mem_barrier()	eieio()
#    define write_mem_barrier()	eieio()

#   else /* ix86 */

#    define ldq_u(p)	(*((unsigned long  *)(p)))
#    define ldl_u(p)	(*((unsigned int   *)(p)))
#    define ldw_u(p)	(*((unsigned short *)(p)))
#    define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#    define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#    define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#    define mem_barrier()   /* NOP */
#    define write_mem_barrier()   /* NOP */

#    if !defined(__SUNPRO_C)
#    if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__)
#     ifdef GCCUSESGAS

/*
 * If gcc uses gas rather than the native assembler, the syntax of these
 * inlines has to be different.		DHD
 */

static __inline__ void
outb(unsigned short port, unsigned char val)
{
   __asm__ __volatile__("outb %0,%1" : :"a" (val), "d" (port));
}


static __inline__ void
outw(unsigned short port, unsigned short val)
{
   __asm__ __volatile__("outw %0,%1" : :"a" (val), "d" (port));
}

static __inline__ void
outl(unsigned short port, unsigned int val)
{
   __asm__ __volatile__("outl %0,%1" : :"a" (val), "d" (port));
}

static __inline__ unsigned int
inb(unsigned short port)
{
   unsigned char ret;
   __asm__ __volatile__("inb %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
}

static __inline__ unsigned int
inw(unsigned short port)
{
   unsigned short ret;
   __asm__ __volatile__("inw %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
}

static __inline__ unsigned int
inl(unsigned short port)
{
   unsigned int ret;
   __asm__ __volatile__("inl %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
}

#     else	/* GCCUSESGAS */

static __inline__ void
outb(unsigned short port, unsigned char val)
{
  __asm__ __volatile__("out%B0 (%1)" : :"a" (val), "d" (port));
}

static __inline__ void
outw(unsigned short port, unsigned short val)
{
  __asm__ __volatile__("out%W0 (%1)" : :"a" (val), "d" (port));
}

static __inline__ void
outl(unsigned short port, unsigned int val)
{
  __asm__ __volatile__("out%L0 (%1)" : :"a" (val), "d" (port));
}

static __inline__ unsigned int
inb(unsigned short port)
{
  unsigned char ret;
  __asm__ __volatile__("in%B0 (%1)" :
		   "=a" (ret) :
		   "d" (port));
  return ret;
}

static __inline__ unsigned int
inw(unsigned short port)
{
  unsigned short ret;
  __asm__ __volatile__("in%W0 (%1)" :
		   "=a" (ret) :
		   "d" (port));
  return ret;
}

static __inline__ unsigned int
inl(unsigned short port)
{
  unsigned int ret;
  __asm__ __volatile__("in%L0 (%1)" :
                   "=a" (ret) :
                   "d" (port));
  return ret;
}

#     endif /* GCCUSESGAS */

#    else /* !defined(FAKEIT) && !defined(__mc68000__)  && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__)*/

static __inline__ void
outb(unsigned short port, unsigned char val)
{
}

static __inline__ void
outw(unsigned short port, unsigned short val)
{
}

static __inline__ void
outl(unsigned short port, unsigned int val)
{
}

static __inline__ unsigned int
inb(unsigned short port)
{
  return 0;
}

static __inline__ unsigned int
inw(unsigned short port)
{
  return 0;
}

static __inline__ unsigned int
inl(unsigned short port)
{
  return 0;
}

#    endif /* FAKEIT */
#    endif /* __SUNPRO_C */

#   endif /* ix86 */

#  elif defined(__powerpc__) /* && !__GNUC__ */
/*
 * NON-GCC PowerPC - Presumed to be PowerMAX OS for now
 */
#   ifndef PowerMAX_OS
#    error - Non-gcc PowerPC and !PowerMAXOS ???
#   endif

#   define PPCIO_DEBUG  0
#   define PPCIO_INLINE 1
#   define USE_ABS_MACRO 1
/*
 * Use compiler intrinsics to access certain PPC machine instructions
 */
#   define eieio() 	      __inst_eieio()
#   define stw_brx(val,base,ndx) __inst_sthbrx(val,base,ndx)
#   define stl_brx(val,base,ndx) __inst_stwbrx(val,base,ndx)
#   define ldw_brx(base,ndx)     __inst_lhbrx(base,ndx)
#   define ldl_brx(base,ndx)     __inst_lwbrx(base,ndx)

#   define ldq_u(p)	(*((unsigned long long  *)(p)))
#   define ldl_u(p)	(*((unsigned long   *)(p)))
#   define ldw_u(p)	(*((unsigned short *)(p)))
#   define stq_u(v,p)	(*(unsigned long long *)(p)) = (v)
#   define stl_u(v,p)	(*(unsigned long  *)(p)) = (v)
#   define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#   define mem_barrier()         eieio()
#   define write_mem_barrier()   eieio()

extern volatile unsigned char *ioBase;

#   if !defined(abs) && defined(USE_ABS_MACRO)
#    define abs(x) ((x) >= 0 ? (x) : -(x))
#   endif

#   undef inb
#   undef inw
#   undef inl
#   undef outb
#   undef outw
#   undef outl

#   if PPCIO_DEBUG

extern void debug_outb(unsigned int a, unsigned char b, int line, char *file); 
extern void debug_outw(unsigned int a, unsigned short w, int line, char *file); 
extern void debug_outl(unsigned int a, unsigned int l, int line, char *file); 
extern unsigned char debug_inb(unsigned int a, int line, char *file); 
extern unsigned short debug_inw(unsigned int a, int line, char *file); 
extern unsigned int debug_inl(unsigned int a, int line, char *file); 

#    define outb(a,b) debug_outb(a,b, __LINE__, __FILE__)
#    define outw(a,w) debug_outw(a,w, __LINE__, __FILE__)
#    define outl(a,l) debug_outl(a,l, __LINE__, __FILE__)
#    define inb(a)    debug_inb(a, __LINE__, __FILE__)
#    define inw(a)    debug_inw(a, __LINE__, __FILE__)
#    define inl(a)    debug_inl(a, __LINE__, __FILE__)

#   else /* !PPCIO_DEBUG */

extern unsigned char  inb(unsigned int a);
extern unsigned short inw(unsigned int a);
extern unsigned int   inl(unsigned int a);

#    if PPCIO_INLINE

#     define outb(a,b) \
            (*((volatile unsigned char *)(ioBase + (a))) = (b), eieio())
#     define outw(a,w) (stw_brx((w),ioBase,(a)), eieio())
#     define outl(a,l) (stl_brx((l),ioBase,(a)), eieio())

#    else /* !PPCIO_INLINE */

extern void outb(unsigned int a, unsigned char b);
extern void outw(unsigned int a, unsigned short w);
extern void outl(unsigned int a, unsigned int l);

#    endif /* PPCIO_INLINE */

#   endif /* !PPCIO_DEBUG */

#  else /* !GNUC && !PPC */
#   if !defined(QNX4)
#    if defined(__STDC__) && (__STDC__ == 1)
#     ifndef asm
#      define asm __asm
#     endif
#    endif
#    ifdef SVR4
#if 0
#     include <sys/types.h>
#endif
#     ifndef __HIGHC__
#      if !defined(__USLC__) && !defined(__SUNPRO_C)
#       define __USLC__
#      endif
#     endif
#    endif
#    ifndef SCO325
#     if defined(USL)
#      if defined(IN_MODULE)
#     /* avoid including <sys/types.h> for <sys/inline.h> on UnixWare */
#       define ushort unsigned short
#       define ushort_t unsigned short
#       define ulong unsigned long
#       define ulong_t unsigned long
#       define uint_t unsigned int
#       define uchar_t unsigned char
#      else
#       include <sys/types.h>
#      endif /* IN_MODULE */
#     endif /* USL */
#     if !defined(sgi) && !defined(__SUNPRO_C)
#      include <sys/inline.h>
#     endif
#    else
#     include "scoasm.h"
#    endif
#    if !defined(__HIGHC__) && !defined(SCO325) && !defined(sgi) && \
	!defined(__SUNPRO_C)
#     pragma asm partial_optimization outl
#     pragma asm partial_optimization outw
#     pragma asm partial_optimization outb
#     pragma asm partial_optimization inl
#     pragma asm partial_optimization inw
#     pragma asm partial_optimization inb
#    endif
#   endif
#   define ldq_u(p)	(*((unsigned long  *)(p)))
#   define ldl_u(p)	(*((unsigned int   *)(p)))
#   define ldw_u(p)	(*((unsigned short *)(p)))
#   define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#   define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#   define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#   define mem_barrier()   /* NOP */
#   define write_mem_barrier()   /* NOP */
#  endif /* __GNUC__ */

#  if defined(QNX4)
#   include <sys/types.h>
extern unsigned  inb(unsigned port);
extern unsigned  inw(unsigned port);
extern unsigned  inl(unsigned port);
extern void outb(unsigned port, unsigned val);
extern void outw(unsigned port, unsigned val);
extern void outl(unsigned port, unsigned val);
#  endif /* QNX4 */

#  if defined(IODEBUG) && defined(__GNUC__)
#   undef inb
#   undef inw
#   undef inl
#   undef outb
#   undef outw
#   undef outl
#   define inb(a) __extension__ ({unsigned char __c=RealInb(a); ErrorF("inb(0x%03x) = 0x%02x\t@@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})
#   define inw(a) __extension__ ({unsigned short __c=RealInw(a); ErrorF("inw(0x%03x) = 0x%04x\t@@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})
#   define inl(a) __extension__ ({unsigned int __c=RealInl(a); ErrorF("inl(0x%03x) = 0x%08x\t@@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})

#   define outb(a,b) (ErrorF("outb(0x%03x, 0x%02x)\t@@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutb(a,b))
#   define outw(a,b) (ErrorF("outw(0x%03x, 0x%04x)\t@@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutw(a,b))
#   define outl(a,b) (ErrorF("outl(0x%03x, 0x%08x)\t@@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutl(a,b))
#  endif

# endif /* NO_INLINE */

# ifdef __alpha__
/* entry points for Mmio memory access routines */
extern int (*xf86ReadMmio8)(void *, unsigned long);
extern int (*xf86ReadMmio16)(void *, unsigned long);
#  ifndef STANDALONE_MMIO
extern int (*xf86ReadMmio32)(void *, unsigned long);
#  else
/* Some DRI 3D drivers need MMIO_IN32. */
static __inline__ int
xf86ReadMmio32(void *Base, unsigned long Offset)
{
	__asm__ __volatile__("mb"  : : : "memory");
	return *(volatile CARD32*)((unsigned long)Base+(Offset));
}
#  endif
extern void (*xf86WriteMmio8)(int, void *, unsigned long);
extern void (*xf86WriteMmio16)(int, void *, unsigned long);
extern void (*xf86WriteMmio32)(int, void *, unsigned long);
extern void (*xf86WriteMmioNB8)(int, void *, unsigned long);
extern void (*xf86WriteMmioNB16)(int, void *, unsigned long);
extern void (*xf86WriteMmioNB32)(int, void *, unsigned long);
extern void xf86JensenMemToBus(char *, long, long, int);
extern void xf86JensenBusToMem(char *, char *, unsigned long, int);
extern void xf86SlowBCopyFromBus(unsigned char *, unsigned char *, int);
extern void xf86SlowBCopyToBus(unsigned char *, unsigned char *, int);

/* Some macros to hide the system dependencies for MMIO accesses */
/* Changed to kill noise generated by gcc's -Wcast-align */
#  define MMIO_IN8(base, offset) (*xf86ReadMmio8)(base, offset)
#  define MMIO_IN16(base, offset) (*xf86ReadMmio16)(base, offset)
#  ifndef STANDALONE_MMIO
#   define MMIO_IN32(base, offset) (*xf86ReadMmio32)(base, offset)
#  else
#   define MMIO_IN32(base, offset) xf86ReadMmio32(base, offset)
#  endif

#  if defined (JENSEN_SUPPORT)
#   define MMIO_OUT32(base, offset, val) \
    (*xf86WriteMmio32)((CARD32)(val), base, offset)
#   define MMIO_ONB32(base, offset, val) \
    (*xf86WriteMmioNB32)((CARD32)(val), base, offset)
#  else
#   define MMIO_OUT32(base, offset, val) \
    do { \
	write_mem_barrier(); \
	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val); \
    } while (0)
#   define MMIO_ONB32(base, offset, val) \
	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val)
#  endif

#  define MMIO_OUT8(base, offset, val) \
    (*xf86WriteMmio8)((CARD8)(val), base, offset)
#  define MMIO_OUT16(base, offset, val) \
    (*xf86WriteMmio16)((CARD16)(val), base, offset)
#  define MMIO_ONB8(base, offset, val) \
    (*xf86WriteMmioNB8)((CARD8)(val), base, offset)
#  define MMIO_ONB16(base, offset, val) \
    (*xf86WriteMmioNB16)((CARD16)(val), base, offset)
#  define MMIO_MOVE32(base, offset, val) \
    MMIO_OUT32(base, offset, val)

# elif defined(__powerpc__)  
 /* 
  * we provide byteswapping and no byteswapping functions here
  * with byteswapping as default, 
  * drivers that don't need byteswapping should define PPC_MMIO_IS_BE 
  */
#  define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
#  define MMIO_OUT8(base, offset, val) \
    xf86WriteMmio8(base, offset, (CARD8)(val))
#  define MMIO_ONB8(base, offset, val) \
    xf86WriteMmioNB8(base, offset, (CARD8)(val))

#  if defined(PPC_MMIO_IS_BE) /* No byteswapping */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
#   define MMIO_OUT16(base, offset, val) \
    xf86WriteMmio16Be(base, offset, (CARD16)(val))
#   define MMIO_OUT32(base, offset, val) \
    xf86WriteMmio32Be(base, offset, (CARD32)(val))
#   define MMIO_ONB16(base, offset, val) \
    xf86WriteMmioNB16Be(base, offset, (CARD16)(val))
#   define MMIO_ONB32(base, offset, val) \
    xf86WriteMmioNB32Be(base, offset, (CARD32)(val))
#  else /* byteswapping is the default */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
#   define MMIO_OUT16(base, offset, val) \
     xf86WriteMmio16Le(base, offset, (CARD16)(val))
#   define MMIO_OUT32(base, offset, val) \
     xf86WriteMmio32Le(base, offset, (CARD32)(val))
#   define MMIO_ONB16(base, offset, val) \
     xf86WriteMmioNB16Le(base, offset, (CARD16)(val))
#   define MMIO_ONB32(base, offset, val) \
     xf86WriteMmioNB32Le(base, offset, (CARD32)(val))
#  endif

#  define MMIO_MOVE32(base, offset, val) \
       xf86WriteMmio32Be(base, offset, (CARD32)(val))

static __inline__ void ppc_flush_icache(char *addr)
{
	__asm__ volatile (
		"dcbf 0,%0;" 
		"sync;" 
		"icbi 0,%0;" 
		"sync;" 
		"isync;" 
		: : "r"(addr) : "memory");
}

# elif defined(__sparc__)
 /*
  * Like powerpc, we provide byteswapping and no byteswapping functions
  * here with byteswapping as default, drivers that don't need byteswapping
  * should define SPARC_MMIO_IS_BE (perhaps create a generic macro so that we
  * do not need to use PPC_MMIO_IS_BE and the sparc one in all the same places
  * of drivers?).
  */
#  define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
#  define MMIO_OUT8(base, offset, val) \
    xf86WriteMmio8(base, offset, (CARD8)(val))
#  define MMIO_ONB8(base, offset, val) \
    xf86WriteMmio8NB(base, offset, (CARD8)(val))

#  if defined(SPARC_MMIO_IS_BE) /* No byteswapping */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
#   define MMIO_OUT16(base, offset, val) \
     xf86WriteMmio16Be(base, offset, (CARD16)(val))
#   define MMIO_OUT32(base, offset, val) \
     xf86WriteMmio32Be(base, offset, (CARD32)(val))
#   define MMIO_ONB16(base, offset, val) \
     xf86WriteMmio16BeNB(base, offset, (CARD16)(val))
#   define MMIO_ONB32(base, offset, val) \
     xf86WriteMmio32BeNB(base, offset, (CARD32)(val))
#  else /* byteswapping is the default */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
#   define MMIO_OUT16(base, offset, val) \
     xf86WriteMmio16Le(base, offset, (CARD16)(val))
#   define MMIO_OUT32(base, offset, val) \
     xf86WriteMmio32Le(base, offset, (CARD32)(val))
#   define MMIO_ONB16(base, offset, val) \
     xf86WriteMmio16LeNB(base, offset, (CARD16)(val))
#   define MMIO_ONB32(base, offset, val) \
     xf86WriteMmio32LeNB(base, offset, (CARD32)(val))
#  endif

#  define MMIO_MOVE32(base, offset, val) \
       xf86WriteMmio32Be(base, offset, (CARD32)(val))

# else /* !__alpha__ && !__powerpc__ && !__sparc__ */

#  define MMIO_IN8(base, offset) \
	*(volatile CARD8 *)(((CARD8*)(base)) + (offset))
#  define MMIO_IN16(base, offset) \
	*(volatile CARD16 *)(void *)(((CARD8*)(base)) + (offset))
#  define MMIO_IN32(base, offset) \
	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset))
#  define MMIO_OUT8(base, offset, val) \
	*(volatile CARD8 *)(((CARD8*)(base)) + (offset)) = (val)
#  define MMIO_OUT16(base, offset, val) \
	*(volatile CARD16 *)(void *)(((CARD8*)(base)) + (offset)) = (val)
#  define MMIO_OUT32(base, offset, val) \
	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val)
#  define MMIO_ONB8(base, offset, val) MMIO_OUT8(base, offset, val) 
#  define MMIO_ONB16(base, offset, val) MMIO_OUT16(base, offset, val) 
#  define MMIO_ONB32(base, offset, val) MMIO_OUT32(base, offset, val) 

#  define MMIO_MOVE32(base, offset, val) MMIO_OUT32(base, offset, val)

# endif /* __alpha__ */

/*
 * With Intel, the version in os-support/misc/SlowBcopy.s is used.
 * This avoids port I/O during the copy (which causes problems with
 * some hardware).
 */
# ifdef __alpha__
#  define slowbcopy_tobus(src,dst,count) xf86SlowBCopyToBus(src,dst,count)
#  define slowbcopy_frombus(src,dst,count) xf86SlowBCopyFromBus(src,dst,count)
# else /* __alpha__ */
#  define slowbcopy_tobus(src,dst,count) xf86SlowBcopy(src,dst,count)
#  define slowbcopy_frombus(src,dst,count) xf86SlowBcopy(src,dst,count)
# endif /* __alpha__ */

#endif /* _COMPILER_H */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/common/compiler.h,v 3.88 2002/01/07 20:38:27 dawes Exp $ */
d24 47
d75 8
a82 2
#if !defined(_XF86_ANSIC_H) && defined(XFree86Module)
# error missing #include "xf86_ansic.h" before #include "compiler.h"
d85 19
a103 1
#define _COMPILER_H
d105 7
a111 17
/* Allow drivers to use the GCC-supported __inline__ and/or __inline. */
#ifndef __inline__
# if defined(__GNUC__)
   /* gcc has __inline__ */
# elif defined(__HIGHC__)
#  define __inline__ _Inline
# else
#  define __inline__ /**/
# endif
#endif /* __inline__ */
#ifndef __inline
# if defined(__GNUC__)
   /* gcc has __inline */
# elif defined(__HIGHC__)
#  define __inline _Inline
# else
#  define __inline /**/
a112 10
#endif /* __inline */

#if defined(IODEBUG) && defined(__GNUC__)
#define outb RealOutb
#define outw RealOutw
#define outl RealOutl
#define inb RealInb
#define inw RealInw
#define inl RealInl
#endif
d114 7
a120 7
#if defined(QNX4) /* Do this for now to keep Watcom happy */
#define outb outp
#define outw outpw
#define outl outpd 
#define inb inp
#define inw inpw
#define inl inpd
d124 1
a124 1
#pragma aux ffs_ = \
d137 1
a137 1
#endif
d139 1
a139 1
#if defined(NO_INLINE) || defined(DO_PROTOTYPES)
d141 2
a142 1
#if !defined(__sparc__)
d151 1
a151 1
#else /* __sparc__ */
d160 1
a160 1
#endif /* __sparc__ */
a173 6
extern unsigned char rdinx(unsigned short, unsigned char);
extern void wrinx(unsigned short, unsigned char, unsigned char);
extern void modinx(unsigned short, unsigned char, unsigned char, unsigned char);
extern int testrg(unsigned short, unsigned char);
extern int testinx2(unsigned short, unsigned char, unsigned char);
extern int testinx(unsigned short, unsigned char);
d175 1
a175 1
#endif
d177 3
a179 1
#ifndef NO_INLINE
d181 1
a181 5
#ifdef __GNUC__

#if (defined(linux) || defined(__FreeBSD__) || defined(__OpenBSD__)) && defined(__alpha__)

#ifdef linux
d186 1
a186 1
extern void _outb(char val, unsigned short port);
d188 1
a188 1
outb(unsigned short port, unsigned char val)
d190 1
a190 1
    _outb(val, port);
d193 1
a193 1
extern void _outw(short val, unsigned short port);
d195 1
a195 1
outw(unsigned short port, unsigned short val)
d197 1
a197 1
    _outw(val, port);
d200 1
a200 1
extern void _outl(int val, unsigned short port);
d202 1
a202 1
outl(unsigned short port, unsigned int val)
d204 1
a204 1
    _outl(val, port);
d207 1
a207 1
extern unsigned int _inb(unsigned short port);
d209 1
a209 1
inb(unsigned short port)
d211 1
a211 1
  return _inb(port);
d214 1
a214 1
extern unsigned int _inw(unsigned short port);
d216 1
a216 1
inw(unsigned short port)
d218 1
a218 1
  return _inw(port);
d221 1
a221 1
extern unsigned int _inl(unsigned short port);
d223 1
a223 1
inl(unsigned short port)
d225 1
a225 1
  return _inl(port);
d228 1
a228 1
#endif /* linux */
d230 2
a231 1
#if defined(__FreeBSD__) && !defined(DO_PROTOTYPES)
d233 2
a234 1
/* for FreeBSD on Alpha, we use the libio inx/outx routines */
d245 1
a245 1
#endif /* __FreeBSD__ && !DO_PROTOTYPES */
a246 9
#ifdef __OpenBSD__
/* Code for OpenBSD/alpha */
/* XXXXX for now assume they're provided by some external lib */
extern void outb(unsigned int port, unsigned char val);
extern void outw(unsigned int port, unsigned short val);
extern void outl(unsigned int port, unsigned int val);
extern unsigned char inb(unsigned int port);
extern unsigned short inw(unsigned int port);
extern unsigned int inl(unsigned int port);
d248 3
a250 1
#endif
d273 1
a273 1
#if __GNUC__ > 2 || __GNUC_MINOR__ >= 91
d276 1
a276 1
#else
d287 1
a287 1
#endif
d292 1
a292 1
#if __GNUC__ > 2 || __GNUC_MINOR__ >= 91
d295 1
a295 1
#else
d306 1
a306 1
#endif
d311 1
a311 1
#if __GNUC__ > 2 || __GNUC_MINOR__ >= 91
d314 1
a314 1
#else
d325 1
a325 1
#endif
d334 1
a334 1
#if __GNUC__ > 2 || __GNUC_MINOR__ >= 91
d337 1
a337 1
#else
d354 1
a354 1
#endif
d359 1
a359 1
#if __GNUC__ > 2 || __GNUC_MINOR__ >= 91
d362 1
a362 1
#else
d379 1
a379 1
#endif
d384 1
a384 1
#if __GNUC__ > 2 || __GNUC_MINOR__ >= 91
d387 1
a387 1
#else
d404 1
a404 1
#endif
d409 1
a409 1
#define PAL_imb 134
d414 1
a414 1
#define istream_mem_barrier() \
d416 6
a421 6
#define mem_barrier()        __asm__ __volatile__("mb"  : : : "memory")
#ifdef __ELF__
#define write_mem_barrier()  __asm__ __volatile__("wmb" : : : "memory")
#else  /*  ECOFF gas 2.6 doesn't know "wmb" :-(  */
#define write_mem_barrier()  mem_barrier()
#endif
d424 1
a424 1
#elif defined(linux) && defined(__ia64__) 
d426 1
a426 1
#include <inttypes.h>
d428 1
a428 1
#include <sys/io.h>
d434 1
a434 1
extern __inline__ unsigned long
d441 1
a441 1
extern __inline__ unsigned long
d448 1
a448 1
extern __inline__ unsigned long
d455 1
a455 1
extern __inline__ void
d462 1
a462 1
extern __inline__ void
d469 1
a469 1
extern __inline__ void
d476 15
a490 9
#define ldq_u(p)	__uldq(p)
#define ldl_u(p)	__uldl(p)
#define ldw_u(p)	__uldw(p) 
#define stq_u(v,p)	__ustq(v,p)
#define stl_u(v,p)	__ustl(v,p)
#define stw_u(v,p)	__ustw(v,p)
  
#define mem_barrier()        __asm__ __volatile__ ("mf" ::: "memory")
#define write_mem_barrier()  __asm__ __volatile__ ("mf" ::: "memory")
d497 2
a498 1
#define ia64_flush_cache(Addr) \
d505 15
d521 1
a521 3
#undef outb
#undef outw
#undef outl
d523 70
a592 10
#define outb(a,b)	_outb(b,a)
#define outw(a,b)	_outw(b,a)
#define outl(a,b)	_outl(b,a) 

#elif (defined(linux) || defined(Lynx) || defined(sun)  || defined(__OpenBSD__)) && defined(__sparc__)

#if !defined(Lynx)
#ifndef ASI_PL
#define ASI_PL 0x88
#endif
d594 1
a594 1
#define barrier() __asm__ __volatile__(".word 0x8143e00a": : :"memory")
d828 1
a828 1
#endif	/* !Lynx */
d835 1
a835 1
#if defined(__arch64__) || defined(__sparcv9)
d837 1
a837 1
#endif
d843 2
a844 2
#if __GNUC__ > 2 || __GNUC_MINOR__ >= 91
#if defined(__arch64__) || defined(__sparcv9)
d846 1
a846 1
#else
d848 1
a848 1
#endif
d850 1
a850 1
#else
d854 1
a854 1
#endif
d859 1
a859 1
#if __GNUC__ > 2 || __GNUC_MINOR__ >= 91
d862 1
a862 1
#else
d866 1
a866 1
#endif
d871 1
a871 1
#if __GNUC__ > 2 || __GNUC_MINOR__ >= 91
d874 1
a874 1
#else
d878 1
a878 1
#endif
d883 2
a884 2
#if __GNUC__ > 2 || __GNUC_MINOR__ >= 91
#if defined(__arch64__) || defined(__sparcv9)
d886 1
a886 1
#else
d888 1
a888 1
#endif
d890 1
a890 1
#else
d893 1
a893 1
#endif
d898 1
a898 1
#if __GNUC__ > 2 || __GNUC_MINOR__ >= 91
d901 1
a901 1
#else
d904 1
a904 1
#endif
d909 1
a909 1
#if __GNUC__ > 2 || __GNUC_MINOR__ >= 91
d912 1
a912 1
#else
d915 1
a915 1
#endif
d918 2
a919 2
#define mem_barrier()         /* XXX: nop for now */
#define write_mem_barrier()   /* XXX: nop for now */
d921 6
a926 1
#elif defined(__mips__) || defined(__arm32__)
d931 1
a931 1
outb(unsigned short port, unsigned char val)
d933 1
a933 1
	*(volatile unsigned char*)(((unsigned short)(port))+IOPortBase) = val;
d937 1
a937 1
outw(unsigned short port, unsigned short val)
d939 1
a939 1
	*(volatile unsigned short*)(((unsigned short)(port))+IOPortBase) = val;
d943 1
a943 1
outl(unsigned short port, unsigned int val)
d945 1
a945 1
	*(volatile unsigned int*)(((unsigned short)(port))+IOPortBase) = val;
d949 1
a949 1
inb(unsigned short port)
d951 1
a951 1
	return *(volatile unsigned char*)(((unsigned short)(port))+IOPortBase);
d955 1
a955 1
inw(unsigned short port)
d957 1
a957 1
	return *(volatile unsigned short*)(((unsigned short)(port))+IOPortBase);
d961 1
a961 1
inl(unsigned short port)
d963 1
a963 1
	return *(volatile unsigned int*)(((unsigned short)(port))+IOPortBase);
d967 1
a967 1
#if defined(__mips__)
d1004 1
a1004 1
#ifdef linux	/* don't mess with other OSs */
d1027 1
a1027 1
#if X_BYTE_ORDER == X_BIG_ENDIAN
d1050 15
a1064 1
#endif
d1066 2
a1067 15
#define mem_barrier() \
__asm__ __volatile__(					\
	"# prevent instructions being moved around\n\t"	\
	".set\tnoreorder\n\t"				\
	"# 8 nops to fool the R4400 pipeline\n\t"	\
	"nop;nop;nop;nop;nop;nop;nop;nop\n\t"		\
	".set\treorder"					\
	: /* no output */				\
	: /* no input */				\
	: "memory")
#define write_mem_barrier() mem_barrier()

#else  /* !linux */
#define stq_u(v,p)	stl_u(v,p)
#define stl_u(v,p)	(*(unsigned char *)(p)) = (v); \
d1072 2
a1073 17
#define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
			(*(unsigned char *)(p)+1) = ((v) >> 8)

#define mem_barrier()   /* NOP */
#endif /* !linux */
#endif /* __mips__ */

#if defined(__arm32__)
#define ldq_u(p)	(*((unsigned long  *)(p)))
#define ldl_u(p)	(*((unsigned int   *)(p)))
#define ldw_u(p)	(*((unsigned short *)(p)))
#define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#define mem_barrier()	/* NOP */
#define write_mem_barrier()	/* NOP */
#endif /* __arm32__ */
d1075 20
a1094 5
#elif (defined(Lynx) || defined(linux) || defined(__OpenBSD__)) && defined(__powerpc__)

#ifndef MAP_FAILED
#define MAP_FAILED ((void *)-1)
#endif
d1098 1
a1098 1
#define eieio()		__asm__ __volatile__ ("eieio")
d1298 2
a1299 2
#define ldq_u(p)	ldl_u(p)
#define ldl_u(p)	((*(unsigned char *)(p))	| \
d1303 1
a1303 1
#define ldw_u(p)	((*(unsigned char *)(p)) | \
d1306 25
a1330 24
#define stq_u(v,p)	stl_u(v,p)
#define stl_u(v,p)	(*(unsigned char *)(p)) = (v); \
			(*((unsigned char *)(p)+1)) = ((v) >> 8);  \
			(*((unsigned char *)(p)+2)) = ((v) >> 16); \
			(*((unsigned char *)(p)+3)) = ((v) >> 24)
#define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
			(*((unsigned char *)(p)+1)) = ((v) >> 8)

#define mem_barrier()		eieio()
#define write_mem_barrier()	eieio()

#else /* ix86 */

#define ldq_u(p)	(*((unsigned long  *)(p)))
#define ldl_u(p)	(*((unsigned int   *)(p)))
#define ldw_u(p)	(*((unsigned short *)(p)))
#define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#define mem_barrier()   /* NOP */
#define write_mem_barrier()   /* NOP */

#if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__)
#ifdef GCCUSESGAS
d1386 1
a1386 1
#else	/* GCCUSESGAS */
d1436 1
a1436 1
#endif /* GCCUSESGAS */
d1438 1
a1438 1
#else /* !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) */
d1473 2
a1474 1
#endif /* FAKEIT */
d1476 1
a1476 1
#endif /* ix86 */
d1478 1
a1478 1
#elif defined(__powerpc__) /* && !__GNUC__ */
d1482 3
a1484 3
# ifndef PowerMAX_OS
# error - Non-gcc PowerPC and !PowerMAXOS ???
# endif
d1486 3
a1488 3
#define PPCIO_DEBUG  0
#define PPCIO_INLINE 1
#define USE_ABS_MACRO 1
d1492 14
a1505 14
#define eieio() 	      __inst_eieio()
#define stw_brx(val,base,ndx) __inst_sthbrx(val,base,ndx)
#define stl_brx(val,base,ndx) __inst_stwbrx(val,base,ndx)
#define ldw_brx(base,ndx)     __inst_lhbrx(base,ndx)
#define ldl_brx(base,ndx)     __inst_lwbrx(base,ndx)

#define ldq_u(p)	(*((unsigned long long  *)(p)))
#define ldl_u(p)	(*((unsigned long   *)(p)))
#define ldw_u(p)	(*((unsigned short *)(p)))
#define stq_u(v,p)	(*(unsigned long long *)(p)) = (v)
#define stl_u(v,p)	(*(unsigned long  *)(p)) = (v)
#define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#define mem_barrier()         eieio()
#define write_mem_barrier()   eieio()
d1509 3
a1511 3
#if !defined(abs) && defined(USE_ABS_MACRO)
#define abs(x) ((x) >= 0 ? (x) : -(x))
#endif
d1513 6
a1518 6
#undef inb
#undef inw
#undef inl
#undef outb
#undef outw
#undef outl
d1520 1
a1520 1
#if PPCIO_DEBUG
d1529 6
a1534 6
#define outb(a,b) debug_outb(a,b, __LINE__, __FILE__)
#define outw(a,w) debug_outw(a,w, __LINE__, __FILE__)
#define outl(a,l) debug_outl(a,l, __LINE__, __FILE__)
#define inb(a)    debug_inb(a, __LINE__, __FILE__)
#define inw(a)    debug_inw(a, __LINE__, __FILE__)
#define inl(a)    debug_inl(a, __LINE__, __FILE__)
d1536 1
a1536 1
#else /* !PPCIO_DEBUG */
d1542 1
a1542 1
# if PPCIO_INLINE
d1544 4
a1547 3
#define outb(a,b) (*((volatile unsigned char *)(ioBase + (a))) = (b), eieio())
#define outw(a,w) (stw_brx((w),ioBase,(a)), eieio())
#define outl(a,l) (stl_brx((l),ioBase,(a)), eieio())
d1549 1
a1549 1
# else /* !PPCIO_INLINE */
d1555 1
a1555 1
# endif /* PPCIO_INLINE */
d1557 1
a1557 1
#endif /* !PPCIO_DEBUG */
d1559 8
a1566 8
#else /* !GNUC && !PPC */
#if !defined(QNX4)
# if defined(__STDC__) && (__STDC__ == 1)
#  ifndef asm
#   define asm __asm
#  endif
# endif
# ifdef SVR4
d1568 1
a1568 1
#  include <sys/types.h>
d1570 9
a1578 9
#  ifndef __HIGHC__
#   ifndef __USLC__
#    define __USLC__
#   endif
#  endif
# endif
#  ifndef SCO325
#   if defined(USL)
#    if defined(IN_MODULE)
d1580 13
a1592 6
#     define ushort unsigned short
#     define ushort_t unsigned short
#     define ulong unsigned long
#     define ulong_t unsigned long
#     define uint_t unsigned int
#     define uchar_t unsigned char
d1594 21
a1614 7
#     include <sys/types.h>
#    endif /* IN_MODULE */
#   endif /* USL */
#   include <sys/inline.h>
#  else
#   include "scoasm.h"
#  endif
d1616 2
a1617 21
# if !defined(__HIGHC__) && !defined(SCO325)
#  pragma asm partial_optimization outl
#  pragma asm partial_optimization outw
#  pragma asm partial_optimization outb
#  pragma asm partial_optimization inl
#  pragma asm partial_optimization inw
#  pragma asm partial_optimization inb
# endif
#endif
#define ldq_u(p)	(*((unsigned long  *)(p)))
#define ldl_u(p)	(*((unsigned int   *)(p)))
#define ldw_u(p)	(*((unsigned short *)(p)))
#define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#define mem_barrier()   /* NOP */
#define write_mem_barrier()   /* NOP */
#endif /* __GNUC__ */

#if defined(QNX4)
#include <sys/types.h>
d1624 1
a1624 1
#endif /* QNX4 */
d1626 15
a1640 29
#if defined(IODEBUG) && defined(__GNUC__)
#undef inb
#undef inw
#undef inl
#undef outb
#undef outw
#undef outl
#define inb(a) __extension__ ({unsigned char __c=RealInb(a); ErrorF("inb(0x%03x) = 0x%02x\t@@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})
#define inw(a) __extension__ ({unsigned short __c=RealInw(a); ErrorF("inw(0x%03x) = 0x%04x\t@@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})
#define inl(a) __extension__ ({unsigned int __c=RealInl(a); ErrorF("inl(0x%03x) = 0x%08x\t@@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})

#define outb(a,b) (ErrorF("outb(0x%03x, 0x%02x)\t@@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutb(a,b))
#define outw(a,b) (ErrorF("outw(0x%03x, 0x%04x)\t@@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutw(a,b))
#define outl(a,b) (ErrorF("outl(0x%03x, 0x%08x)\t@@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutl(a,b))
#endif

/*
 * This header sometimes gets included where is isn't needed, and on some OSs
 * this causes problems because the following functions generate references to
 * inx() and outx() which can't be resolved.  If you need the extra definitions
 * below, #define COMPILER_H_EXTRAS.
 */

#ifdef COMPILER_H_EXTRAS
/*
 *-----------------------------------------------------------------------
 * Port manipulation convenience functions
 *-----------------------------------------------------------------------
 */
d1642 1
a1642 11
/*
 * rdinx - read the indexed byte port 'port', index 'ind', and return its value
 */
static __inline__ unsigned char 
rdinx(unsigned short port, unsigned char ind)
{
	if (port == 0x3C0)		/* reset attribute flip-flop */
		(void) inb(0x3DA);
	outb(port, ind);
	return inb(port+1);
}
d1644 1
a1644 75
/*
 * wrinx - write 'val' to port 'port', index 'ind'
 */
static __inline__ void 
wrinx(unsigned short port, unsigned char ind, unsigned char val)
{
	outb(port, ind);
	outb(port+1, val);
}

/*
 * modinx - in register 'port', index 'ind', set the bits in 'mask' as in 'new';
 *	    the other bits are unchanged.
 */
static __inline__ void
modinx(unsigned short port, unsigned char ind, 
       unsigned char mask, unsigned char new)
{
	unsigned char tmp;

	tmp = (rdinx(port, ind) & ~mask) | (new & mask);
	wrinx(port, ind, tmp);
}

/*
 * tstrg - returns true iff the bits in 'mask' of register 'port' are
 *	   readable & writable.
 */

static __inline__ int
testrg(unsigned short port, unsigned char mask)
{
	unsigned char old, new1, new2;

	old = inb(port);
	outb(port, old & ~mask);
	new1 = inb(port) & mask;
	outb(port, old | mask);
	new2 = inb(port) & mask;
	outb(port, old);
	return (new1 == 0) && (new2 == mask);
}

/*
 * testinx2 - returns true iff the bits in 'mask' of register 'port', index
 *	      'ind' are readable & writable.
 */
static __inline__ int
testinx2(unsigned short port, unsigned char ind, unsigned char mask)
{
	unsigned char old, new1, new2;

	old = rdinx(port, ind);
	wrinx(port, ind, old & ~mask);
	new1 = rdinx(port, ind) & mask;
	wrinx(port, ind, old | mask);
	new2 = rdinx(port, ind) & mask;
	wrinx(port, ind, old);
	return (new1 == 0) && (new2 == mask);
}

/*
 * testinx - returns true iff all bits of register 'port', index 'ind' are 
 *     	     readable & writable.
 */
static __inline__ int
testinx(unsigned short port, unsigned char ind)
{
	return testinx2(port, ind, 0xFF);
}
#endif /* COMPILER_H_EXTRAS */

#endif /* NO_INLINE */

#ifdef __alpha__
d1648 1
d1650 9
d1672 7
a1678 3
#define MMIO_IN8(base, offset) (*xf86ReadMmio8)(base, offset)
#define MMIO_IN16(base, offset) (*xf86ReadMmio16)(base, offset)
#define MMIO_IN32(base, offset) (*xf86ReadMmio32)(base, offset)
d1680 2
a1681 2
# if defined (JENSEN_SUPPORT)
#define MMIO_OUT32(base, offset, val) \
d1683 1
a1683 1
#define MMIO_ONB32(base, offset, val) \
d1685 2
a1686 2
# else
#define MMIO_OUT32(base, offset, val) \
d1691 1
a1691 1
#define MMIO_ONB32(base, offset, val) \
d1693 1
a1693 1
# endif
d1695 1
a1695 1
#define MMIO_OUT8(base, offset, val) \
d1697 1
a1697 1
#define MMIO_OUT16(base, offset, val) \
d1699 1
a1699 1
#define MMIO_ONB8(base, offset, val) \
d1701 1
a1701 1
#define MMIO_ONB16(base, offset, val) \
d1703 1
a1703 1
#define MMIO_MOVE32(base, offset, val) \
d1706 1
a1706 1
#elif defined(__powerpc__)  
d1712 2
a1713 2
# define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
# define MMIO_OUT8(base, offset, val) \
d1715 1
a1715 1
# define MMIO_ONB8(base, offset, val) \
d1718 4
a1721 4
# if defined(PPC_MMIO_IS_BE) /* No byteswapping */
#  define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
#  define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
#  define MMIO_OUT16(base, offset, val) \
d1723 1
a1723 1
#  define MMIO_OUT32(base, offset, val) \
d1725 1
a1725 1
#  define MMIO_ONB16(base, offset, val) \
d1727 1
a1727 1
#  define MMIO_ONB32(base, offset, val) \
d1729 12
a1740 12
# else /* byteswapping is the default */
#  define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
#  define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
#  define MMIO_OUT16(base, offset, val) \
    xf86WriteMmio16Le(base, offset, (CARD16)(val))
#  define MMIO_OUT32(base, offset, val) \
    xf86WriteMmio32Le(base, offset, (CARD32)(val))
#  define MMIO_ONB16(base, offset, val) \
    xf86WriteMmioNB16Le(base, offset, (CARD16)(val))
#  define MMIO_ONB32(base, offset, val) \
    xf86WriteMmioNB32Le(base, offset, (CARD32)(val))
# endif
d1742 2
a1743 2
#define MMIO_MOVE32(base, offset, val) \
    xf86WriteMmio32Be(base, offset, (CARD32)(val))
d1756 1
a1756 1
#elif defined(__sparc__)
d1764 2
a1765 2
# define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
# define MMIO_OUT8(base, offset, val) \
d1767 1
a1767 1
# define MMIO_ONB8(base, offset, val) \
d1770 23
a1792 23
# if defined(SPARC_MMIO_IS_BE) /* No byteswapping */
#  define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
#  define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
#  define MMIO_OUT16(base, offset, val) \
    xf86WriteMmio16Be(base, offset, (CARD16)(val))
#  define MMIO_OUT32(base, offset, val) \
    xf86WriteMmio32Be(base, offset, (CARD32)(val))
#  define MMIO_ONB16(base, offset, val) \
    xf86WriteMmio16BeNB(base, offset, (CARD16)(val))
#  define MMIO_ONB32(base, offset, val) \
    xf86WriteMmio32BeNB(base, offset, (CARD32)(val))
# else /* byteswapping is the default */
#  define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
#  define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
#  define MMIO_OUT16(base, offset, val) \
    xf86WriteMmio16Le(base, offset, (CARD16)(val))
#  define MMIO_OUT32(base, offset, val) \
    xf86WriteMmio32Le(base, offset, (CARD32)(val))
#  define MMIO_ONB16(base, offset, val) \
    xf86WriteMmio16LeNB(base, offset, (CARD16)(val))
#  define MMIO_ONB32(base, offset, val) \
    xf86WriteMmio32LeNB(base, offset, (CARD32)(val))
# endif
d1794 2
a1795 2
#define MMIO_MOVE32(base, offset, val) \
    xf86WriteMmio32Be(base, offset, (CARD32)(val))
d1797 1
a1797 1
#else /* !__alpha__ && !__powerpc__ && !__sparc__ */
d1799 1
a1799 1
#define MMIO_IN8(base, offset) \
d1801 1
a1801 1
#define MMIO_IN16(base, offset) \
d1803 1
a1803 1
#define MMIO_IN32(base, offset) \
d1805 1
a1805 1
#define MMIO_OUT8(base, offset, val) \
d1807 1
a1807 1
#define MMIO_OUT16(base, offset, val) \
d1809 1
a1809 1
#define MMIO_OUT32(base, offset, val) \
d1811 3
a1813 3
#define MMIO_ONB8(base, offset, val) MMIO_OUT8(base, offset, val) 
#define MMIO_ONB16(base, offset, val) MMIO_OUT16(base, offset, val) 
#define MMIO_ONB32(base, offset, val) MMIO_OUT32(base, offset, val) 
d1815 1
a1815 1
#define MMIO_MOVE32(base, offset, val) MMIO_OUT32(base, offset, val)
d1817 1
a1817 1
#endif /* __alpha__ */
d1824 7
a1830 7
#ifdef __alpha__
#define slowbcopy_tobus(src,dst,count) xf86SlowBCopyToBus(src,dst,count)
#define slowbcopy_frombus(src,dst,count) xf86SlowBCopyFromBus(src,dst,count)
#else /* __alpha__ */
#define slowbcopy_tobus(src,dst,count) xf86SlowBcopy(src,dst,count)
#define slowbcopy_frombus(src,dst,count) xf86SlowBcopy(src,dst,count)
#endif /* __alpha__ */
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/common/compiler.h,v 3.106 2004/02/02 03:55:28 dawes Exp $ */
a23 27
/*
 * Copyright (c) 1994-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

d28 3
a30 3
# if !defined(_XF86_ANSIC_H) && defined(XFree86Module)
#  error missing #include "xf86_ansic.h" before #include "compiler.h"
# endif
d32 1
a32 5
# define _COMPILER_H

#if defined(__SUNPRO_C)
# define DO_PROTOTYPES
#endif
d35 18
a52 18
# ifndef __inline__
#  if defined(__GNUC__)
    /* gcc has __inline__ */
#  elif defined(__HIGHC__)
#   define __inline__ _Inline
#  else
#   define __inline__ /**/
#  endif
# endif /* __inline__ */
# ifndef __inline
#  if defined(__GNUC__)
    /* gcc has __inline */
#  elif defined(__HIGHC__)
#   define __inline _Inline
#  else
#   define __inline /**/
#  endif
# endif /* __inline */
d54 8
a61 8
# if defined(IODEBUG) && defined(__GNUC__)
#  define outb RealOutb
#  define outw RealOutw
#  define outl RealOutl
#  define inb RealInb
#  define inw RealInw
#  define inl RealInl
# endif
d63 7
a69 7
# if defined(QNX4) /* Do this for now to keep Watcom happy */
#  define outb outp
#  define outw outpw
#  define outl outpd 
#  define inb inp
#  define inw inpw
#  define inl inpd
d73 1
a73 1
#  pragma aux ffs_ = \
d86 1
a86 1
# endif
d88 1
a88 1
# if defined(NO_INLINE) || defined(DO_PROTOTYPES)
d90 1
a90 2
#  if !defined(__sparc__) && !defined(__arm32__) \
      && !(defined(__alpha__) && defined(linux))
d99 1
a99 1
#  else /* __sparc__,  __arm32__, __alpha__*/
d108 1
a108 1
#  endif /* __sparc__,  __arm32__, __alpha__ */
d122 6
d129 5
a133 1
# endif
d135 1
a135 3
# ifndef NO_INLINE
#  ifdef __GNUC__
#   if (defined(linux) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)) && defined(__alpha__)
d137 1
a137 1
#    ifdef linux
d142 1
a142 1
extern void (*_alpha_outb)(char val, unsigned long port);
d144 1
a144 1
outb(unsigned long port, unsigned char val)
d146 1
a146 1
    _alpha_outb(val, port);
d149 1
a149 1
extern void (*_alpha_outw)(short val, unsigned long port);
d151 1
a151 1
outw(unsigned long port, unsigned short val)
d153 1
a153 1
    _alpha_outw(val, port);
d156 1
a156 1
extern void (*_alpha_outl)(int val, unsigned long port);
d158 1
a158 1
outl(unsigned long port, unsigned int val)
d160 1
a160 1
    _alpha_outl(val, port);
d163 1
a163 1
extern unsigned int (*_alpha_inb)(unsigned long port);
d165 1
a165 1
inb(unsigned long port)
d167 1
a167 1
  return _alpha_inb(port);
d170 1
a170 1
extern unsigned int (*_alpha_inw)(unsigned long port);
d172 1
a172 1
inw(unsigned long port)
d174 1
a174 1
  return _alpha_inw(port);
d177 1
a177 1
extern unsigned int (*_alpha_inl)(unsigned long port);
d179 1
a179 1
inl(unsigned long port)
d181 1
a181 1
  return _alpha_inl(port);
d184 1
a184 1
#    endif /* linux */
d186 1
a186 2
#    if (defined(__FreeBSD__) || defined(__OpenBSD__)) \
      && !defined(DO_PROTOTYPES)
d188 1
a188 2
/* for FreeBSD and OpenBSD on Alpha, we use the libio (resp. libalpha) */
/*  inx/outx routines */
d199 1
a199 1
#    endif /* (__FreeBSD__ || __OpenBSD__ ) && !DO_PROTOTYPES */
d201 9
d211 1
a211 3
#if defined(__NetBSD__)
#include <machine/pio.h>
#endif /* __NetBSD__ */
d234 1
a234 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d237 1
a237 1
#    else
d248 1
a248 1
#    endif
d253 1
a253 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d256 1
a256 1
#    else
d267 1
a267 1
#    endif
d272 1
a272 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d275 1
a275 1
#    else
d286 1
a286 1
#    endif
d295 1
a295 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d298 1
a298 1
#    else
d315 1
a315 1
#    endif
d320 1
a320 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d323 1
a323 1
#    else
d340 1
a340 1
#    endif
d345 1
a345 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d348 1
a348 1
#    else
d365 1
a365 1
#    endif
d369 7
a375 2
#    define PAL_imb 134
#    define istream_mem_barrier() \
d377 6
a382 6
#    define mem_barrier()        __asm__ __volatile__("mb"  : : : "memory")
#    ifdef __ELF__
#     define write_mem_barrier()  __asm__ __volatile__("wmb" : : : "memory")
#    else  /*  ECOFF gas 2.6 doesn't know "wmb" :-(  */
#     define write_mem_barrier()  mem_barrier()
#    endif
d385 1
a385 1
#   elif defined(linux) && defined(__ia64__) 
d387 1
a387 1
#    include <inttypes.h>
d389 1
a389 1
#    include <sys/io.h>
d395 1
a395 1
static __inline__ unsigned long
d402 1
a402 1
static __inline__ unsigned long
d409 1
a409 1
static __inline__ unsigned long
d416 1
a416 1
static __inline__ void
d423 1
a423 1
static __inline__ void
d430 1
a430 1
static __inline__ void
d437 9
a445 15
#    define ldq_u(p)	__uldq(p)
#    define ldl_u(p)	__uldl(p)
#    define ldw_u(p)	__uldw(p) 
#    define stq_u(v,p)	__ustq(v,p)
#    define stl_u(v,p)	__ustl(v,p)
#    define stw_u(v,p)	__ustw(v,p)

#    ifndef __INTEL_COMPILER  
#      define mem_barrier()        __asm__ __volatile__ ("mf" ::: "memory")
#      define write_mem_barrier()  __asm__ __volatile__ ("mf" ::: "memory")
#    else
#      include "ia64intrin.h"
#      define mem_barrier() __mf()
#      define write_mem_barrier() __mf()
#    endif
d452 1
a452 2
#    ifndef __INTEL_COMPILER
#       define ia64_flush_cache(Addr) \
a458 15
#    else
#      define ia64_flush_cache(Addr) { \
        __fc(Addr);\
        __synci();\
        __mf();\
        __isrlz();\
       }
#    endif
#    undef outb
#    undef outw
#    undef outl
 
#    define outb(a,b)	_outb(b,a)
#    define outw(a,b)	_outw(b,a)
#    define outl(a,b)	_outl(b,a) 
d460 3
a462 1
#   elif defined(linux) && defined(__AMD64__) 
d464 10
a473 13
#    include <inttypes.h>

#    define ldq_u(p)	(*((unsigned long  *)(p)))
#    define ldl_u(p)	(*((unsigned int   *)(p)))
#    define ldw_u(p)	(*((unsigned short *)(p)))
#    define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#    define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#    define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
  
#    define mem_barrier() \
       __asm__ __volatile__ ("lock; addl $0,0(%%rsp)": : :"memory")
#    define write_mem_barrier() \
       __asm__ __volatile__ ("": : :"memory")
d475 1
a475 58

static __inline__ void
outb(unsigned short port, unsigned char val)
{
   __asm__ __volatile__("outb %0,%1" : :"a" (val), "d" (port));
}


static __inline__ void
outw(unsigned short port, unsigned short val)
{
   __asm__ __volatile__("outw %0,%1" : :"a" (val), "d" (port));
}

static __inline__ void
outl(unsigned short port, unsigned int val)
{
   __asm__ __volatile__("outl %0,%1" : :"a" (val), "d" (port));
}

static __inline__ unsigned int
inb(unsigned short port)
{
   unsigned char ret;
   __asm__ __volatile__("inb %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
}

static __inline__ unsigned int
inw(unsigned short port)
{
   unsigned short ret;
   __asm__ __volatile__("inw %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
}

static __inline__ unsigned int
inl(unsigned short port)
{
   unsigned int ret;
   __asm__ __volatile__("inl %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
}

#   elif (defined(linux) || defined(Lynx) || defined(sun) || defined(__OpenBSD__) || defined(__FreeBSD__)) && defined(__sparc__)

#    if !defined(Lynx)
#     ifndef ASI_PL
#      define ASI_PL 0x88
#     endif

#     define barrier() __asm__ __volatile__(".word 0x8143e00a": : :"memory")
d709 1
a709 1
#    endif	/* !Lynx */
d716 1
a716 1
#    if defined(__arch64__) || defined(__sparcv9)
d718 1
a718 1
#    endif
d724 2
a725 2
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
#     if defined(__arch64__) || defined(__sparcv9)
d727 1
a727 1
#     else
d729 1
a729 1
#     endif
d731 1
a731 1
#    else
d735 1
a735 1
#    endif
d740 1
a740 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d743 1
a743 1
#    else
d747 1
a747 1
#    endif
d752 1
a752 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d755 1
a755 1
#    else
d759 1
a759 1
#    endif
d764 2
a765 2
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
#     if defined(__arch64__) || defined(__sparcv9)
d767 1
a767 1
#     else
d769 1
a769 1
#     endif
d771 1
a771 1
#    else
d774 1
a774 1
#    endif
d779 1
a779 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d782 1
a782 1
#    else
d785 1
a785 1
#    endif
d790 1
a790 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d793 1
a793 1
#    else
d796 1
a796 1
#    endif
d799 2
a800 2
#    define mem_barrier()         /* XXX: nop for now */
#    define write_mem_barrier()   /* XXX: nop for now */
d802 1
a802 6
#   elif defined(__mips__) || defined(__arm32__)
#ifdef __arm32__
#define PORT_SIZE long
#else
#define PORT_SIZE short
#endif
d807 1
a807 1
outb(unsigned PORT_SIZE port, unsigned char val)
d809 1
a809 1
	*(volatile unsigned char*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
d813 1
a813 1
outw(unsigned PORT_SIZE port, unsigned short val)
d815 1
a815 1
	*(volatile unsigned short*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
d819 1
a819 1
outl(unsigned PORT_SIZE port, unsigned int val)
d821 1
a821 1
	*(volatile unsigned int*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
d825 1
a825 1
inb(unsigned PORT_SIZE port)
d827 1
a827 1
	return *(volatile unsigned char*)(((unsigned PORT_SIZE)(port))+IOPortBase);
d831 1
a831 1
inw(unsigned PORT_SIZE port)
d833 1
a833 1
	return *(volatile unsigned short*)(((unsigned PORT_SIZE)(port))+IOPortBase);
d837 1
a837 1
inl(unsigned PORT_SIZE port)
d839 1
a839 1
	return *(volatile unsigned int*)(((unsigned PORT_SIZE)(port))+IOPortBase);
d843 1
a843 1
#    if defined(__mips__)
d880 1
a880 1
#     ifdef linux	/* don't mess with other OSs */
d903 1
a903 1
#       if X_BYTE_ORDER == X_BIG_ENDIAN
d926 1
a926 13
#      endif

#      define mem_barrier() \
        __asm__ __volatile__(					\
		"# prevent instructions being moved around\n\t"	\
       		".set\tnoreorder\n\t"				\
		"# 8 nops to fool the R4400 pipeline\n\t"	\
		"nop;nop;nop;nop;nop;nop;nop;nop\n\t"		\
		".set\treorder"					\
		: /* no output */				\
		: /* no input */				\
		: "memory")
#      define write_mem_barrier() mem_barrier()
d928 15
a942 4
#     else  /* !linux */

#      define stq_u(v,p)	stl_u(v,p)
#      define stl_u(v,p)	(*(unsigned char *)(p)) = (v); \
d947 17
a963 2
#      define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
				(*(unsigned char *)(p)+1) = ((v) >> 8)
d965 5
a969 20
#      define mem_barrier()   /* NOP */
#     endif /* !linux */
#    endif /* __mips__ */

#    if defined(__arm32__)
#     define ldq_u(p)	(*((unsigned long  *)(p)))
#     define ldl_u(p)	(*((unsigned int   *)(p)))
#     define ldw_u(p)	(*((unsigned short *)(p)))
#     define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#     define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#     define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#     define mem_barrier()	/* NOP */
#     define write_mem_barrier()	/* NOP */
#    endif /* __arm32__ */

#   elif (defined(Lynx) || defined(linux) || defined(__OpenBSD__) || defined(__NetBSD__)) && defined(__powerpc__)

#    ifndef MAP_FAILED
#     define MAP_FAILED ((void *)-1)
#    endif
d973 1
a973 1
#    define eieio()		__asm__ __volatile__ ("eieio" ::: "memory")
d1173 2
a1174 2
#    define ldq_u(p)	ldl_u(p)
#    define ldl_u(p)	((*(unsigned char *)(p))	| \
d1178 1
a1178 1
#    define ldw_u(p)	((*(unsigned char *)(p)) | \
d1181 24
a1204 25
#    define stq_u(v,p)	stl_u(v,p)
#    define stl_u(v,p)	(*(unsigned char *)(p)) = (v); \
				(*((unsigned char *)(p)+1)) = ((v) >> 8);  \
				(*((unsigned char *)(p)+2)) = ((v) >> 16); \
				(*((unsigned char *)(p)+3)) = ((v) >> 24)
#    define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
				(*((unsigned char *)(p)+1)) = ((v) >> 8)

#    define mem_barrier()	eieio()
#    define write_mem_barrier()	eieio()

#   else /* ix86 */

#    define ldq_u(p)	(*((unsigned long  *)(p)))
#    define ldl_u(p)	(*((unsigned int   *)(p)))
#    define ldw_u(p)	(*((unsigned short *)(p)))
#    define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#    define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#    define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#    define mem_barrier()   /* NOP */
#    define write_mem_barrier()   /* NOP */

#    if !defined(__SUNPRO_C)
#    if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__)
#     ifdef GCCUSESGAS
d1260 1
a1260 1
#     else	/* GCCUSESGAS */
d1310 1
a1310 1
#     endif /* GCCUSESGAS */
d1312 1
a1312 1
#    else /* !defined(FAKEIT) && !defined(__mc68000__)  && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__)*/
d1347 1
a1347 2
#    endif /* FAKEIT */
#    endif /* __SUNPRO_C */
d1349 1
a1349 1
#   endif /* ix86 */
d1351 1
a1351 1
#  elif defined(__powerpc__) /* && !__GNUC__ */
d1355 3
a1357 3
#   ifndef PowerMAX_OS
#    error - Non-gcc PowerPC and !PowerMAXOS ???
#   endif
d1359 3
a1361 3
#   define PPCIO_DEBUG  0
#   define PPCIO_INLINE 1
#   define USE_ABS_MACRO 1
d1365 14
a1378 14
#   define eieio() 	      __inst_eieio()
#   define stw_brx(val,base,ndx) __inst_sthbrx(val,base,ndx)
#   define stl_brx(val,base,ndx) __inst_stwbrx(val,base,ndx)
#   define ldw_brx(base,ndx)     __inst_lhbrx(base,ndx)
#   define ldl_brx(base,ndx)     __inst_lwbrx(base,ndx)

#   define ldq_u(p)	(*((unsigned long long  *)(p)))
#   define ldl_u(p)	(*((unsigned long   *)(p)))
#   define ldw_u(p)	(*((unsigned short *)(p)))
#   define stq_u(v,p)	(*(unsigned long long *)(p)) = (v)
#   define stl_u(v,p)	(*(unsigned long  *)(p)) = (v)
#   define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#   define mem_barrier()         eieio()
#   define write_mem_barrier()   eieio()
d1382 3
a1384 3
#   if !defined(abs) && defined(USE_ABS_MACRO)
#    define abs(x) ((x) >= 0 ? (x) : -(x))
#   endif
d1386 6
a1391 6
#   undef inb
#   undef inw
#   undef inl
#   undef outb
#   undef outw
#   undef outl
d1393 1
a1393 1
#   if PPCIO_DEBUG
d1402 6
a1407 6
#    define outb(a,b) debug_outb(a,b, __LINE__, __FILE__)
#    define outw(a,w) debug_outw(a,w, __LINE__, __FILE__)
#    define outl(a,l) debug_outl(a,l, __LINE__, __FILE__)
#    define inb(a)    debug_inb(a, __LINE__, __FILE__)
#    define inw(a)    debug_inw(a, __LINE__, __FILE__)
#    define inl(a)    debug_inl(a, __LINE__, __FILE__)
d1409 1
a1409 1
#   else /* !PPCIO_DEBUG */
d1415 1
a1415 1
#    if PPCIO_INLINE
d1417 3
a1419 4
#     define outb(a,b) \
            (*((volatile unsigned char *)(ioBase + (a))) = (b), eieio())
#     define outw(a,w) (stw_brx((w),ioBase,(a)), eieio())
#     define outl(a,l) (stl_brx((l),ioBase,(a)), eieio())
d1421 1
a1421 1
#    else /* !PPCIO_INLINE */
d1427 1
a1427 1
#    endif /* PPCIO_INLINE */
d1429 1
a1429 1
#   endif /* !PPCIO_DEBUG */
d1431 8
a1438 8
#  else /* !GNUC && !PPC */
#   if !defined(QNX4)
#    if defined(__STDC__) && (__STDC__ == 1)
#     ifndef asm
#      define asm __asm
#     endif
#    endif
#    ifdef SVR4
d1440 1
a1440 1
#     include <sys/types.h>
d1442 9
a1450 9
#     ifndef __HIGHC__
#      if !defined(__USLC__) && !defined(__SUNPRO_C)
#       define __USLC__
#      endif
#     endif
#    endif
#    ifndef SCO325
#     if defined(USL)
#      if defined(IN_MODULE)
d1452 6
a1457 13
#       define ushort unsigned short
#       define ushort_t unsigned short
#       define ulong unsigned long
#       define ulong_t unsigned long
#       define uint_t unsigned int
#       define uchar_t unsigned char
#      else
#       include <sys/types.h>
#      endif /* IN_MODULE */
#     endif /* USL */
#     if !defined(sgi) && !defined(__SUNPRO_C)
#      include <sys/inline.h>
#     endif
d1459 26
a1484 21
#     include "scoasm.h"
#    endif
#    if !defined(__HIGHC__) && !defined(SCO325) && !defined(sgi) && \
	!defined(__SUNPRO_C)
#     pragma asm partial_optimization outl
#     pragma asm partial_optimization outw
#     pragma asm partial_optimization outb
#     pragma asm partial_optimization inl
#     pragma asm partial_optimization inw
#     pragma asm partial_optimization inb
#    endif
#   endif
#   define ldq_u(p)	(*((unsigned long  *)(p)))
#   define ldl_u(p)	(*((unsigned int   *)(p)))
#   define ldw_u(p)	(*((unsigned short *)(p)))
#   define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#   define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#   define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#   define mem_barrier()   /* NOP */
#   define write_mem_barrier()   /* NOP */
#  endif /* __GNUC__ */
d1486 2
a1487 2
#  if defined(QNX4)
#   include <sys/types.h>
d1494 43
a1536 1
#  endif /* QNX4 */
d1538 71
a1608 15
#  if defined(IODEBUG) && defined(__GNUC__)
#   undef inb
#   undef inw
#   undef inl
#   undef outb
#   undef outw
#   undef outl
#   define inb(a) __extension__ ({unsigned char __c=RealInb(a); ErrorF("inb(0x%03x) = 0x%02x\t@@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})
#   define inw(a) __extension__ ({unsigned short __c=RealInw(a); ErrorF("inw(0x%03x) = 0x%04x\t@@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})
#   define inl(a) __extension__ ({unsigned int __c=RealInl(a); ErrorF("inl(0x%03x) = 0x%08x\t@@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})

#   define outb(a,b) (ErrorF("outb(0x%03x, 0x%02x)\t@@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutb(a,b))
#   define outw(a,b) (ErrorF("outw(0x%03x, 0x%04x)\t@@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutw(a,b))
#   define outl(a,b) (ErrorF("outl(0x%03x, 0x%08x)\t@@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutl(a,b))
#  endif
d1610 1
a1610 1
# endif /* NO_INLINE */
d1612 1
a1612 1
# ifdef __alpha__
a1615 1
#  ifndef STANDALONE_MMIO
a1616 9
#  else
/* Some DRI 3D drivers need MMIO_IN32. */
static __inline__ int
xf86ReadMmio32(void *Base, unsigned long Offset)
{
	__asm__ __volatile__("mb"  : : : "memory");
	return *(volatile CARD32*)((unsigned long)Base+(Offset));
}
#  endif
d1630 3
a1632 7
#  define MMIO_IN8(base, offset) (*xf86ReadMmio8)(base, offset)
#  define MMIO_IN16(base, offset) (*xf86ReadMmio16)(base, offset)
#  ifndef STANDALONE_MMIO
#   define MMIO_IN32(base, offset) (*xf86ReadMmio32)(base, offset)
#  else
#   define MMIO_IN32(base, offset) xf86ReadMmio32(base, offset)
#  endif
d1634 2
a1635 2
#  if defined (JENSEN_SUPPORT)
#   define MMIO_OUT32(base, offset, val) \
d1637 1
a1637 1
#   define MMIO_ONB32(base, offset, val) \
d1639 2
a1640 2
#  else
#   define MMIO_OUT32(base, offset, val) \
d1645 1
a1645 1
#   define MMIO_ONB32(base, offset, val) \
d1647 1
a1647 1
#  endif
d1649 1
a1649 1
#  define MMIO_OUT8(base, offset, val) \
d1651 1
a1651 1
#  define MMIO_OUT16(base, offset, val) \
d1653 1
a1653 1
#  define MMIO_ONB8(base, offset, val) \
d1655 1
a1655 1
#  define MMIO_ONB16(base, offset, val) \
d1657 1
a1657 1
#  define MMIO_MOVE32(base, offset, val) \
d1660 1
a1660 1
# elif defined(__powerpc__)  
d1666 2
a1667 2
#  define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
#  define MMIO_OUT8(base, offset, val) \
d1669 1
a1669 1
#  define MMIO_ONB8(base, offset, val) \
d1672 4
a1675 4
#  if defined(PPC_MMIO_IS_BE) /* No byteswapping */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
#   define MMIO_OUT16(base, offset, val) \
d1677 1
a1677 1
#   define MMIO_OUT32(base, offset, val) \
d1679 1
a1679 1
#   define MMIO_ONB16(base, offset, val) \
d1681 1
a1681 1
#   define MMIO_ONB32(base, offset, val) \
d1683 12
a1694 12
#  else /* byteswapping is the default */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
#   define MMIO_OUT16(base, offset, val) \
     xf86WriteMmio16Le(base, offset, (CARD16)(val))
#   define MMIO_OUT32(base, offset, val) \
     xf86WriteMmio32Le(base, offset, (CARD32)(val))
#   define MMIO_ONB16(base, offset, val) \
     xf86WriteMmioNB16Le(base, offset, (CARD16)(val))
#   define MMIO_ONB32(base, offset, val) \
     xf86WriteMmioNB32Le(base, offset, (CARD32)(val))
#  endif
d1696 2
a1697 2
#  define MMIO_MOVE32(base, offset, val) \
       xf86WriteMmio32Be(base, offset, (CARD32)(val))
d1710 1
a1710 1
# elif defined(__sparc__)
d1718 2
a1719 2
#  define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
#  define MMIO_OUT8(base, offset, val) \
d1721 1
a1721 1
#  define MMIO_ONB8(base, offset, val) \
d1724 23
a1746 23
#  if defined(SPARC_MMIO_IS_BE) /* No byteswapping */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
#   define MMIO_OUT16(base, offset, val) \
     xf86WriteMmio16Be(base, offset, (CARD16)(val))
#   define MMIO_OUT32(base, offset, val) \
     xf86WriteMmio32Be(base, offset, (CARD32)(val))
#   define MMIO_ONB16(base, offset, val) \
     xf86WriteMmio16BeNB(base, offset, (CARD16)(val))
#   define MMIO_ONB32(base, offset, val) \
     xf86WriteMmio32BeNB(base, offset, (CARD32)(val))
#  else /* byteswapping is the default */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
#   define MMIO_OUT16(base, offset, val) \
     xf86WriteMmio16Le(base, offset, (CARD16)(val))
#   define MMIO_OUT32(base, offset, val) \
     xf86WriteMmio32Le(base, offset, (CARD32)(val))
#   define MMIO_ONB16(base, offset, val) \
     xf86WriteMmio16LeNB(base, offset, (CARD16)(val))
#   define MMIO_ONB32(base, offset, val) \
     xf86WriteMmio32LeNB(base, offset, (CARD32)(val))
#  endif
d1748 2
a1749 2
#  define MMIO_MOVE32(base, offset, val) \
       xf86WriteMmio32Be(base, offset, (CARD32)(val))
d1751 1
a1751 1
# else /* !__alpha__ && !__powerpc__ && !__sparc__ */
d1753 1
a1753 1
#  define MMIO_IN8(base, offset) \
d1755 1
a1755 1
#  define MMIO_IN16(base, offset) \
d1757 1
a1757 1
#  define MMIO_IN32(base, offset) \
d1759 1
a1759 1
#  define MMIO_OUT8(base, offset, val) \
d1761 1
a1761 1
#  define MMIO_OUT16(base, offset, val) \
d1763 1
a1763 1
#  define MMIO_OUT32(base, offset, val) \
d1765 3
a1767 3
#  define MMIO_ONB8(base, offset, val) MMIO_OUT8(base, offset, val) 
#  define MMIO_ONB16(base, offset, val) MMIO_OUT16(base, offset, val) 
#  define MMIO_ONB32(base, offset, val) MMIO_OUT32(base, offset, val) 
d1769 1
a1769 1
#  define MMIO_MOVE32(base, offset, val) MMIO_OUT32(base, offset, val)
d1771 1
a1771 1
# endif /* __alpha__ */
d1778 7
a1784 7
# ifdef __alpha__
#  define slowbcopy_tobus(src,dst,count) xf86SlowBCopyToBus(src,dst,count)
#  define slowbcopy_frombus(src,dst,count) xf86SlowBCopyFromBus(src,dst,count)
# else /* __alpha__ */
#  define slowbcopy_tobus(src,dst,count) xf86SlowBcopy(src,dst,count)
#  define slowbcopy_frombus(src,dst,count) xf86SlowBcopy(src,dst,count)
# endif /* __alpha__ */
@


1.1.9.2
log
@Import XFree86 4.4 from The XFree86(TM) Project, Inc.
(integrity cannot be checked)

got via cvs -qd anoncvs@@anoncvs.xfree86.org:/cvs co -Prxf-4_4_0 xc
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/common/compiler.h,v 3.107 2004/02/13 23:58:35 dawes Exp $ */
a25 1
 * All rights reserved.
d27 22
a48 41
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 *
 *   1.  Redistributions of source code must retain the above copyright
 *       notice, this list of conditions, and the following disclaimer.
 *
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer
 *       in the documentation and/or other materials provided with the
 *       distribution, and in the same place and form as other copyright,
 *       license and disclaimer information.
 *
 *   3.  The end-user documentation included with the redistribution,
 *       if any, must include the following acknowledgment: "This product
 *       includes software developed by The XFree86 Project, Inc
 *       (http://www.xfree86.org/) and its contributors", in the same
 *       place and form as other third-party acknowledgments.  Alternately,
 *       this acknowledgment may appear in the software itself, in the
 *       same form and location as other such third-party acknowledgments.
 *
 *   4.  Except as contained in this notice, the name of The XFree86
 *       Project, Inc shall not be used in advertising or otherwise to
 *       promote the sale, use or other dealings in this Software without
 *       prior written authorization from The XFree86 Project, Inc.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE XFREE86 PROJECT, INC OR ITS CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/common/compiler.h,v 3.99 2003/01/29 15:23:20 tsi Exp $ */
d28 3
a30 3
# if !defined(_XF86_ANSIC_H) && defined(XFree86Module)
#  error missing #include "xf86_ansic.h" before #include "compiler.h"
# endif
d32 1
a32 1
# define _COMPILER_H
d35 18
a52 18
# ifndef __inline__
#  if defined(__GNUC__)
    /* gcc has __inline__ */
#  elif defined(__HIGHC__)
#   define __inline__ _Inline
#  else
#   define __inline__ /**/
#  endif
# endif /* __inline__ */
# ifndef __inline
#  if defined(__GNUC__)
    /* gcc has __inline */
#  elif defined(__HIGHC__)
#   define __inline _Inline
#  else
#   define __inline /**/
#  endif
# endif /* __inline */
d54 8
a61 8
# if defined(IODEBUG) && defined(__GNUC__)
#  define outb RealOutb
#  define outw RealOutw
#  define outl RealOutl
#  define inb RealInb
#  define inw RealInw
#  define inl RealInl
# endif
d63 7
a69 7
# if defined(QNX4) /* Do this for now to keep Watcom happy */
#  define outb outp
#  define outw outpw
#  define outl outpd 
#  define inb inp
#  define inw inpw
#  define inl inpd
d73 1
a73 1
#  pragma aux ffs_ = \
d86 1
a86 1
# endif
d88 1
a88 1
# if defined(NO_INLINE) || defined(DO_PROTOTYPES)
d90 1
a90 2
#  if !defined(__sparc__) && !defined(__arm32__) \
      && !(defined(__alpha__) && defined(linux))
d99 1
a99 1
#  else /* __sparc__,  __arm32__, __alpha__*/
d108 1
a108 1
#  endif /* __sparc__,  __arm32__, __alpha__ */
d122 10
d133 1
a133 1
# endif
d135 1
a135 3
# ifndef NO_INLINE
#  ifdef __GNUC__
#   if (defined(linux) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)) && defined(__alpha__)
d137 1
a137 1
#    ifdef linux
d142 1
a142 1
extern void (*_alpha_outb)(char val, unsigned long port);
d144 1
a144 1
outb(unsigned long port, unsigned char val)
d146 1
a146 1
    _alpha_outb(val, port);
d149 1
a149 1
extern void (*_alpha_outw)(short val, unsigned long port);
d151 1
a151 1
outw(unsigned long port, unsigned short val)
d153 1
a153 1
    _alpha_outw(val, port);
d156 1
a156 1
extern void (*_alpha_outl)(int val, unsigned long port);
d158 1
a158 1
outl(unsigned long port, unsigned int val)
d160 1
a160 1
    _alpha_outl(val, port);
d163 1
a163 1
extern unsigned int (*_alpha_inb)(unsigned long port);
d165 1
a165 1
inb(unsigned long port)
d167 1
a167 1
  return _alpha_inb(port);
d170 1
a170 1
extern unsigned int (*_alpha_inw)(unsigned long port);
d172 1
a172 1
inw(unsigned long port)
d174 1
a174 1
  return _alpha_inw(port);
d177 1
a177 1
extern unsigned int (*_alpha_inl)(unsigned long port);
d179 1
a179 1
inl(unsigned long port)
d181 1
a181 1
  return _alpha_inl(port);
d184 1
a184 1
#    endif /* linux */
d186 1
a186 2
#    if (defined(__FreeBSD__) || defined(__OpenBSD__)) \
      && !defined(DO_PROTOTYPES)
d188 1
a188 2
/* for FreeBSD and OpenBSD on Alpha, we use the libio (resp. libalpha) */
/*  inx/outx routines */
d199 1
a199 1
#    endif /* (__FreeBSD__ || __OpenBSD__ ) && !DO_PROTOTYPES */
d201 9
d211 1
a211 3
#if defined(__NetBSD__)
#include <machine/pio.h>
#endif /* __NetBSD__ */
d234 1
a234 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d237 1
a237 1
#    else
d248 1
a248 1
#    endif
d253 1
a253 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d256 1
a256 1
#    else
d267 1
a267 1
#    endif
d272 1
a272 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d275 1
a275 1
#    else
d286 1
a286 1
#    endif
d295 1
a295 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d298 1
a298 1
#    else
d315 1
a315 1
#    endif
d320 1
a320 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d323 1
a323 1
#    else
d340 1
a340 1
#    endif
d345 1
a345 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d348 1
a348 1
#    else
d365 1
a365 1
#    endif
d370 1
a370 1
#    define PAL_imb 134
d375 1
a375 1
#    define istream_mem_barrier() \
d377 6
a382 6
#    define mem_barrier()        __asm__ __volatile__("mb"  : : : "memory")
#    ifdef __ELF__
#     define write_mem_barrier()  __asm__ __volatile__("wmb" : : : "memory")
#    else  /*  ECOFF gas 2.6 doesn't know "wmb" :-(  */
#     define write_mem_barrier()  mem_barrier()
#    endif
d385 1
a385 1
#   elif defined(linux) && defined(__ia64__) 
d387 1
a387 1
#    include <inttypes.h>
d389 1
a389 1
#    include <sys/io.h>
d395 1
a395 1
static __inline__ unsigned long
d402 1
a402 1
static __inline__ unsigned long
d409 1
a409 1
static __inline__ unsigned long
d416 1
a416 1
static __inline__ void
d423 1
a423 1
static __inline__ void
d430 1
a430 1
static __inline__ void
d437 6
a442 6
#    define ldq_u(p)	__uldq(p)
#    define ldl_u(p)	__uldl(p)
#    define ldw_u(p)	__uldw(p) 
#    define stq_u(v,p)	__ustq(v,p)
#    define stl_u(v,p)	__ustl(v,p)
#    define stw_u(v,p)	__ustw(v,p)
d444 2
a445 2
#    define mem_barrier()        __asm__ __volatile__ ("mf" ::: "memory")
#    define write_mem_barrier()  __asm__ __volatile__ ("mf" ::: "memory")
d452 1
a452 1
#    define ia64_flush_cache(Addr) \
d460 3
a462 3
#    undef outb
#    undef outw
#    undef outl
d464 10
a473 69
#    define outb(a,b)	_outb(b,a)
#    define outw(a,b)	_outw(b,a)
#    define outl(a,b)	_outl(b,a) 

#   elif defined(linux) && defined(__x86_64__) 
 
#    include <inttypes.h>

#    define ldq_u(p)	(*((unsigned long  *)(p)))
#    define ldl_u(p)	(*((unsigned int   *)(p)))
#    define ldw_u(p)	(*((unsigned short *)(p)))
#    define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#    define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#    define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
  
#    define mem_barrier() \
       __asm__ __volatile__ ("lock; addl $0,0(%%rsp)": : :"memory")
#    define write_mem_barrier() \
       __asm__ __volatile__ ("": : :"memory")


static __inline__ void
outb(unsigned short port, unsigned char val)
{
   __asm__ __volatile__("outb %0,%1" : :"a" (val), "d" (port));
}


static __inline__ void
outw(unsigned short port, unsigned short val)
{
   __asm__ __volatile__("outw %0,%1" : :"a" (val), "d" (port));
}

static __inline__ void
outl(unsigned short port, unsigned int val)
{
   __asm__ __volatile__("outl %0,%1" : :"a" (val), "d" (port));
}

static __inline__ unsigned int
inb(unsigned short port)
{
   unsigned char ret;
   __asm__ __volatile__("inb %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
}

static __inline__ unsigned int
inw(unsigned short port)
{
   unsigned short ret;
   __asm__ __volatile__("inw %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
}

static __inline__ unsigned int
inl(unsigned short port)
{
   unsigned int ret;
   __asm__ __volatile__("inl %1,%0" :
       "=a" (ret) :
       "d" (port));
   return ret;
}
d475 1
a475 8
#   elif (defined(linux) || defined(Lynx) || defined(sun) || defined(__OpenBSD__)) && defined(__sparc__)

#    if !defined(Lynx)
#     ifndef ASI_PL
#      define ASI_PL 0x88
#     endif

#     define barrier() __asm__ __volatile__(".word 0x8143e00a": : :"memory")
d709 1
a709 1
#    endif	/* !Lynx */
d716 1
a716 1
#    if defined(__arch64__) || defined(__sparcv9)
d718 1
a718 1
#    endif
d724 2
a725 2
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
#     if defined(__arch64__) || defined(__sparcv9)
d727 1
a727 1
#     else
d729 1
a729 1
#     endif
d731 1
a731 1
#    else
d735 1
a735 1
#    endif
d740 1
a740 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d743 1
a743 1
#    else
d747 1
a747 1
#    endif
d752 1
a752 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d755 1
a755 1
#    else
d759 1
a759 1
#    endif
d764 2
a765 2
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
#     if defined(__arch64__) || defined(__sparcv9)
d767 1
a767 1
#     else
d769 1
a769 1
#     endif
d771 1
a771 1
#    else
d774 1
a774 1
#    endif
d779 1
a779 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d782 1
a782 1
#    else
d785 1
a785 1
#    endif
d790 1
a790 1
#    if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
d793 1
a793 1
#    else
d796 1
a796 1
#    endif
d799 2
a800 2
#    define mem_barrier()         /* XXX: nop for now */
#    define write_mem_barrier()   /* XXX: nop for now */
d802 1
a802 6
#   elif defined(__mips__) || defined(__arm32__)
#ifdef __arm32__
#define PORT_SIZE long
#else
#define PORT_SIZE short
#endif
d807 1
a807 1
outb(unsigned PORT_SIZE port, unsigned char val)
d809 1
a809 1
	*(volatile unsigned char*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
d813 1
a813 1
outw(unsigned PORT_SIZE port, unsigned short val)
d815 1
a815 1
	*(volatile unsigned short*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
d819 1
a819 1
outl(unsigned PORT_SIZE port, unsigned int val)
d821 1
a821 1
	*(volatile unsigned int*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
d825 1
a825 1
inb(unsigned PORT_SIZE port)
d827 1
a827 1
	return *(volatile unsigned char*)(((unsigned PORT_SIZE)(port))+IOPortBase);
d831 1
a831 1
inw(unsigned PORT_SIZE port)
d833 1
a833 1
	return *(volatile unsigned short*)(((unsigned PORT_SIZE)(port))+IOPortBase);
d837 1
a837 1
inl(unsigned PORT_SIZE port)
d839 1
a839 1
	return *(volatile unsigned int*)(((unsigned PORT_SIZE)(port))+IOPortBase);
d843 1
a843 1
#    if defined(__mips__)
d880 1
a880 1
#     ifdef linux	/* don't mess with other OSs */
d903 1
a903 1
#       if X_BYTE_ORDER == X_BIG_ENDIAN
d926 1
a926 1
#      endif
d928 15
a942 16
#      define mem_barrier() \
        __asm__ __volatile__(					\
		"# prevent instructions being moved around\n\t"	\
       		".set\tnoreorder\n\t"				\
		"# 8 nops to fool the R4400 pipeline\n\t"	\
		"nop;nop;nop;nop;nop;nop;nop;nop\n\t"		\
		".set\treorder"					\
		: /* no output */				\
		: /* no input */				\
		: "memory")
#      define write_mem_barrier() mem_barrier()

#     else  /* !linux */

#      define stq_u(v,p)	stl_u(v,p)
#      define stl_u(v,p)	(*(unsigned char *)(p)) = (v); \
d947 17
a963 2
#      define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
				(*(unsigned char *)(p)+1) = ((v) >> 8)
d965 5
a969 20
#      define mem_barrier()   /* NOP */
#     endif /* !linux */
#    endif /* __mips__ */

#    if defined(__arm32__)
#     define ldq_u(p)	(*((unsigned long  *)(p)))
#     define ldl_u(p)	(*((unsigned int   *)(p)))
#     define ldw_u(p)	(*((unsigned short *)(p)))
#     define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#     define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#     define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#     define mem_barrier()	/* NOP */
#     define write_mem_barrier()	/* NOP */
#    endif /* __arm32__ */

#   elif (defined(Lynx) || defined(linux) || defined(__OpenBSD__) || defined(__NetBSD__)) && defined(__powerpc__)

#    ifndef MAP_FAILED
#     define MAP_FAILED ((void *)-1)
#    endif
d973 1
a973 1
#    define eieio()		__asm__ __volatile__ ("eieio" ::: "memory")
d1173 2
a1174 2
#    define ldq_u(p)	ldl_u(p)
#    define ldl_u(p)	((*(unsigned char *)(p))	| \
d1178 1
a1178 1
#    define ldw_u(p)	((*(unsigned char *)(p)) | \
d1181 21
a1201 21
#    define stq_u(v,p)	stl_u(v,p)
#    define stl_u(v,p)	(*(unsigned char *)(p)) = (v); \
				(*((unsigned char *)(p)+1)) = ((v) >> 8);  \
				(*((unsigned char *)(p)+2)) = ((v) >> 16); \
				(*((unsigned char *)(p)+3)) = ((v) >> 24)
#    define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
				(*((unsigned char *)(p)+1)) = ((v) >> 8)

#    define mem_barrier()	eieio()
#    define write_mem_barrier()	eieio()

#   else /* ix86 */

#    define ldq_u(p)	(*((unsigned long  *)(p)))
#    define ldl_u(p)	(*((unsigned int   *)(p)))
#    define ldw_u(p)	(*((unsigned short *)(p)))
#    define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#    define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#    define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#    define mem_barrier()   /* NOP */
#    define write_mem_barrier()   /* NOP */
d1203 2
a1204 2
#    if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__)
#     ifdef GCCUSESGAS
d1260 1
a1260 1
#     else	/* GCCUSESGAS */
d1310 1
a1310 1
#     endif /* GCCUSESGAS */
d1312 1
a1312 1
#    else /* !defined(FAKEIT) && !defined(__mc68000__)  && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__)*/
d1347 1
a1347 1
#    endif /* FAKEIT */
d1349 1
a1349 1
#   endif /* ix86 */
d1351 1
a1351 1
#  elif defined(__powerpc__) /* && !__GNUC__ */
d1355 3
a1357 3
#   ifndef PowerMAX_OS
#    error - Non-gcc PowerPC and !PowerMAXOS ???
#   endif
d1359 3
a1361 3
#   define PPCIO_DEBUG  0
#   define PPCIO_INLINE 1
#   define USE_ABS_MACRO 1
d1365 14
a1378 14
#   define eieio() 	      __inst_eieio()
#   define stw_brx(val,base,ndx) __inst_sthbrx(val,base,ndx)
#   define stl_brx(val,base,ndx) __inst_stwbrx(val,base,ndx)
#   define ldw_brx(base,ndx)     __inst_lhbrx(base,ndx)
#   define ldl_brx(base,ndx)     __inst_lwbrx(base,ndx)

#   define ldq_u(p)	(*((unsigned long long  *)(p)))
#   define ldl_u(p)	(*((unsigned long   *)(p)))
#   define ldw_u(p)	(*((unsigned short *)(p)))
#   define stq_u(v,p)	(*(unsigned long long *)(p)) = (v)
#   define stl_u(v,p)	(*(unsigned long  *)(p)) = (v)
#   define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#   define mem_barrier()         eieio()
#   define write_mem_barrier()   eieio()
d1382 3
a1384 3
#   if !defined(abs) && defined(USE_ABS_MACRO)
#    define abs(x) ((x) >= 0 ? (x) : -(x))
#   endif
d1386 6
a1391 6
#   undef inb
#   undef inw
#   undef inl
#   undef outb
#   undef outw
#   undef outl
d1393 1
a1393 1
#   if PPCIO_DEBUG
d1402 6
a1407 6
#    define outb(a,b) debug_outb(a,b, __LINE__, __FILE__)
#    define outw(a,w) debug_outw(a,w, __LINE__, __FILE__)
#    define outl(a,l) debug_outl(a,l, __LINE__, __FILE__)
#    define inb(a)    debug_inb(a, __LINE__, __FILE__)
#    define inw(a)    debug_inw(a, __LINE__, __FILE__)
#    define inl(a)    debug_inl(a, __LINE__, __FILE__)
d1409 1
a1409 1
#   else /* !PPCIO_DEBUG */
d1415 1
a1415 1
#    if PPCIO_INLINE
d1417 3
a1419 4
#     define outb(a,b) \
            (*((volatile unsigned char *)(ioBase + (a))) = (b), eieio())
#     define outw(a,w) (stw_brx((w),ioBase,(a)), eieio())
#     define outl(a,l) (stl_brx((l),ioBase,(a)), eieio())
d1421 1
a1421 1
#    else /* !PPCIO_INLINE */
d1427 1
a1427 1
#    endif /* PPCIO_INLINE */
d1429 1
a1429 1
#   endif /* !PPCIO_DEBUG */
d1431 8
a1438 8
#  else /* !GNUC && !PPC */
#   if !defined(QNX4)
#    if defined(__STDC__) && (__STDC__ == 1)
#     ifndef asm
#      define asm __asm
#     endif
#    endif
#    ifdef SVR4
d1440 1
a1440 1
#     include <sys/types.h>
d1442 9
a1450 9
#     ifndef __HIGHC__
#      ifndef __USLC__
#       define __USLC__
#      endif
#     endif
#    endif
#    ifndef SCO325
#     if defined(USL)
#      if defined(IN_MODULE)
d1452 6
a1457 11
#       define ushort unsigned short
#       define ushort_t unsigned short
#       define ulong unsigned long
#       define ulong_t unsigned long
#       define uint_t unsigned int
#       define uchar_t unsigned char
#      else
#       include <sys/types.h>
#      endif /* IN_MODULE */
#     endif /* USL */
#     include <sys/inline.h>
d1459 26
a1484 20
#     include "scoasm.h"
#    endif
#    if !defined(__HIGHC__) && !defined(SCO325)
#     pragma asm partial_optimization outl
#     pragma asm partial_optimization outw
#     pragma asm partial_optimization outb
#     pragma asm partial_optimization inl
#     pragma asm partial_optimization inw
#     pragma asm partial_optimization inb
#    endif
#   endif
#   define ldq_u(p)	(*((unsigned long  *)(p)))
#   define ldl_u(p)	(*((unsigned int   *)(p)))
#   define ldw_u(p)	(*((unsigned short *)(p)))
#   define stq_u(v,p)	(*(unsigned long  *)(p)) = (v)
#   define stl_u(v,p)	(*(unsigned int   *)(p)) = (v)
#   define stw_u(v,p)	(*(unsigned short *)(p)) = (v)
#   define mem_barrier()   /* NOP */
#   define write_mem_barrier()   /* NOP */
#  endif /* __GNUC__ */
d1486 2
a1487 2
#  if defined(QNX4)
#   include <sys/types.h>
d1494 1
a1494 1
#  endif /* QNX4 */
d1496 113
a1608 15
#  if defined(IODEBUG) && defined(__GNUC__)
#   undef inb
#   undef inw
#   undef inl
#   undef outb
#   undef outw
#   undef outl
#   define inb(a) __extension__ ({unsigned char __c=RealInb(a); ErrorF("inb(0x%03x) = 0x%02x\t@@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})
#   define inw(a) __extension__ ({unsigned short __c=RealInw(a); ErrorF("inw(0x%03x) = 0x%04x\t@@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})
#   define inl(a) __extension__ ({unsigned int __c=RealInl(a); ErrorF("inl(0x%03x) = 0x%08x\t@@ line %4d, file %s\n", a, __c, __LINE__, __FILE__);__c;})

#   define outb(a,b) (ErrorF("outb(0x%03x, 0x%02x)\t@@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutb(a,b))
#   define outw(a,b) (ErrorF("outw(0x%03x, 0x%04x)\t@@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutw(a,b))
#   define outl(a,b) (ErrorF("outl(0x%03x, 0x%08x)\t@@ line %4d, file %s\n", a, b, __LINE__, __FILE__),RealOutl(a,b))
#  endif
d1610 1
a1610 1
# endif /* NO_INLINE */
d1612 1
a1612 1
# ifdef __alpha__
d1630 3
a1632 3
#  define MMIO_IN8(base, offset) (*xf86ReadMmio8)(base, offset)
#  define MMIO_IN16(base, offset) (*xf86ReadMmio16)(base, offset)
#  define MMIO_IN32(base, offset) (*xf86ReadMmio32)(base, offset)
d1634 2
a1635 2
#  if defined (JENSEN_SUPPORT)
#   define MMIO_OUT32(base, offset, val) \
d1637 1
a1637 1
#   define MMIO_ONB32(base, offset, val) \
d1639 2
a1640 2
#  else
#   define MMIO_OUT32(base, offset, val) \
d1645 1
a1645 1
#   define MMIO_ONB32(base, offset, val) \
d1647 1
a1647 1
#  endif
d1649 1
a1649 1
#  define MMIO_OUT8(base, offset, val) \
d1651 1
a1651 1
#  define MMIO_OUT16(base, offset, val) \
d1653 1
a1653 1
#  define MMIO_ONB8(base, offset, val) \
d1655 1
a1655 1
#  define MMIO_ONB16(base, offset, val) \
d1657 1
a1657 1
#  define MMIO_MOVE32(base, offset, val) \
d1660 1
a1660 1
# elif defined(__powerpc__)  
d1666 2
a1667 2
#  define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
#  define MMIO_OUT8(base, offset, val) \
d1669 1
a1669 1
#  define MMIO_ONB8(base, offset, val) \
d1672 4
a1675 4
#  if defined(PPC_MMIO_IS_BE) /* No byteswapping */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
#   define MMIO_OUT16(base, offset, val) \
d1677 1
a1677 1
#   define MMIO_OUT32(base, offset, val) \
d1679 1
a1679 1
#   define MMIO_ONB16(base, offset, val) \
d1681 1
a1681 1
#   define MMIO_ONB32(base, offset, val) \
d1683 12
a1694 12
#  else /* byteswapping is the default */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
#   define MMIO_OUT16(base, offset, val) \
     xf86WriteMmio16Le(base, offset, (CARD16)(val))
#   define MMIO_OUT32(base, offset, val) \
     xf86WriteMmio32Le(base, offset, (CARD32)(val))
#   define MMIO_ONB16(base, offset, val) \
     xf86WriteMmioNB16Le(base, offset, (CARD16)(val))
#   define MMIO_ONB32(base, offset, val) \
     xf86WriteMmioNB32Le(base, offset, (CARD32)(val))
#  endif
d1696 2
a1697 2
#  define MMIO_MOVE32(base, offset, val) \
       xf86WriteMmio32Be(base, offset, (CARD32)(val))
d1710 1
a1710 1
# elif defined(__sparc__)
d1718 2
a1719 2
#  define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
#  define MMIO_OUT8(base, offset, val) \
d1721 1
a1721 1
#  define MMIO_ONB8(base, offset, val) \
d1724 23
a1746 23
#  if defined(SPARC_MMIO_IS_BE) /* No byteswapping */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
#   define MMIO_OUT16(base, offset, val) \
     xf86WriteMmio16Be(base, offset, (CARD16)(val))
#   define MMIO_OUT32(base, offset, val) \
     xf86WriteMmio32Be(base, offset, (CARD32)(val))
#   define MMIO_ONB16(base, offset, val) \
     xf86WriteMmio16BeNB(base, offset, (CARD16)(val))
#   define MMIO_ONB32(base, offset, val) \
     xf86WriteMmio32BeNB(base, offset, (CARD32)(val))
#  else /* byteswapping is the default */
#   define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
#   define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
#   define MMIO_OUT16(base, offset, val) \
     xf86WriteMmio16Le(base, offset, (CARD16)(val))
#   define MMIO_OUT32(base, offset, val) \
     xf86WriteMmio32Le(base, offset, (CARD32)(val))
#   define MMIO_ONB16(base, offset, val) \
     xf86WriteMmio16LeNB(base, offset, (CARD16)(val))
#   define MMIO_ONB32(base, offset, val) \
     xf86WriteMmio32LeNB(base, offset, (CARD32)(val))
#  endif
d1748 2
a1749 2
#  define MMIO_MOVE32(base, offset, val) \
       xf86WriteMmio32Be(base, offset, (CARD32)(val))
d1751 1
a1751 1
# else /* !__alpha__ && !__powerpc__ && !__sparc__ */
d1753 1
a1753 1
#  define MMIO_IN8(base, offset) \
d1755 1
a1755 1
#  define MMIO_IN16(base, offset) \
d1757 1
a1757 1
#  define MMIO_IN32(base, offset) \
d1759 1
a1759 1
#  define MMIO_OUT8(base, offset, val) \
d1761 1
a1761 1
#  define MMIO_OUT16(base, offset, val) \
d1763 1
a1763 1
#  define MMIO_OUT32(base, offset, val) \
d1765 3
a1767 3
#  define MMIO_ONB8(base, offset, val) MMIO_OUT8(base, offset, val) 
#  define MMIO_ONB16(base, offset, val) MMIO_OUT16(base, offset, val) 
#  define MMIO_ONB32(base, offset, val) MMIO_OUT32(base, offset, val) 
d1769 1
a1769 1
#  define MMIO_MOVE32(base, offset, val) MMIO_OUT32(base, offset, val)
d1771 1
a1771 1
# endif /* __alpha__ */
d1778 7
a1784 7
# ifdef __alpha__
#  define slowbcopy_tobus(src,dst,count) xf86SlowBCopyToBus(src,dst,count)
#  define slowbcopy_frombus(src,dst,count) xf86SlowBCopyFromBus(src,dst,count)
# else /* __alpha__ */
#  define slowbcopy_tobus(src,dst,count) xf86SlowBcopy(src,dst,count)
#  define slowbcopy_frombus(src,dst,count) xf86SlowBcopy(src,dst,count)
# endif /* __alpha__ */
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/common/compiler.h,v 3.106 2004/02/02 03:55:28 dawes Exp $ */
a23 27
/*
 * Copyright (c) 1994-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

a33 4
#if defined(__SUNPRO_C)
# define DO_PROTOTYPES
#endif

d431 3
a433 9

#    ifndef __INTEL_COMPILER  
#      define mem_barrier()        __asm__ __volatile__ ("mf" ::: "memory")
#      define write_mem_barrier()  __asm__ __volatile__ ("mf" ::: "memory")
#    else
#      include "ia64intrin.h"
#      define mem_barrier() __mf()
#      define write_mem_barrier() __mf()
#    endif
d440 1
a440 2
#    ifndef __INTEL_COMPILER
#       define ia64_flush_cache(Addr) \
d447 1
a447 8
#    else
#      define ia64_flush_cache(Addr) { \
        __fc(Addr);\
        __synci();\
        __mf();\
        __isrlz();\
       }
#    endif
d456 1
a456 1
#   elif defined(linux) && defined(__AMD64__) 
d522 1
a522 1
#   elif (defined(linux) || defined(Lynx) || defined(sun) || defined(__OpenBSD__) || defined(__FreeBSD__)) && defined(__sparc__)
a1262 1
#    if !defined(__SUNPRO_C)
a1407 1
#    endif /* __SUNPRO_C */
d1504 1
a1504 1
#      if !defined(__USLC__) && !defined(__SUNPRO_C)
d1523 1
a1523 3
#     if !defined(sgi) && !defined(__SUNPRO_C)
#      include <sys/inline.h>
#     endif
d1527 1
a1527 2
#    if !defined(__HIGHC__) && !defined(SCO325) && !defined(sgi) && \
	!defined(__SUNPRO_C)
a1577 1
#  ifndef STANDALONE_MMIO
a1578 9
#  else
/* Some DRI 3D drivers need MMIO_IN32. */
static __inline__ int
xf86ReadMmio32(void *Base, unsigned long Offset)
{
	__asm__ __volatile__("mb"  : : : "memory");
	return *(volatile CARD32*)((unsigned long)Base+(Offset));
}
#  endif
d1594 1
a1594 5
#  ifndef STANDALONE_MMIO
#   define MMIO_IN32(base, offset) (*xf86ReadMmio32)(base, offset)
#  else
#   define MMIO_IN32(base, offset) xf86ReadMmio32(base, offset)
#  endif
@


