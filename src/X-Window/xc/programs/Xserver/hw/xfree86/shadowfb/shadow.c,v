head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407221130:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.09.02;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.09.02;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.37.44;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.26.57;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.25.41;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
   Copyright (C) 1999.  The XFree86 Project Inc.

   Written by Mark Vojkovich (mvojkovi@@ucsd.edu)
*/

/* $XFree86: xc/programs/Xserver/hw/xfree86/shadowfb/shadow.c,v 1.10 2000/02/08 13:13:33 eich Exp $ */

#include "X.h"
#include "Xproto.h"
#include "misc.h"
#include "pixmapstr.h"
#include "input.h"
#include "font.h"
#include "mi.h"
#include "scrnintstr.h"
#include "windowstr.h"
#include "gcstruct.h"
#include "dixfontstr.h"
#include "fontstruct.h"
#include "xf86.h"
#include "xf86str.h"
#include "shadowfb.h"


static Bool ShadowCloseScreen (int i, ScreenPtr pScreen);
static void ShadowRestoreAreas (    
    PixmapPtr pPixmap,
    RegionPtr prgn,
    int       xorg,
    int       yorg,
    WindowPtr pWin 
);
static void ShadowPaintWindow (
    WindowPtr pWin,
    RegionPtr prgn,
    int what 
);
static void ShadowCopyWindow(
    WindowPtr pWin,
    DDXPointRec ptOldOrg,
    RegionPtr prgn 
);
static Bool ShadowCreateGC(GCPtr pGC);
static Bool ShadowModifyPixmapHeader(
    PixmapPtr pPixmap,
    int width,
    int height,
    int depth,
    int bitsPerPixel,
    int devKind,
    pointer pPixData
);

static Bool ShadowEnterVT(int index, int flags);
static void ShadowLeaveVT(int index, int flags);
static void ShadowEnableDisableFBAccess(int index, Bool enable);


typedef struct {
  ScrnInfoPtr 				pScrn;
  RefreshAreaFuncPtr			refresh;
  CloseScreenProcPtr			CloseScreen;
  PaintWindowBackgroundProcPtr		PaintWindowBackground;
  PaintWindowBorderProcPtr		PaintWindowBorder;
  CopyWindowProcPtr			CopyWindow;
  CreateGCProcPtr			CreateGC;
  BackingStoreRestoreAreasProcPtr	RestoreAreas;  
  ModifyPixmapHeaderProcPtr		ModifyPixmapHeader;
  Bool				(*EnterVT)(int, int);
  void				(*LeaveVT)(int, int);
  void				(*EnableDisableFBAccess)(int, Bool);
  Bool				vtSema;
} ShadowScreenRec, *ShadowScreenPtr;

typedef struct {
   GCOps   *ops;
   GCFuncs *funcs;
} ShadowGCRec, *ShadowGCPtr;


static int ShadowScreenIndex = -1;
static int ShadowGCIndex = -1;
static unsigned long ShadowGeneration = 0;

#define GET_SCREEN_PRIVATE(pScreen) \
	(ShadowScreenPtr)((pScreen)->devPrivates[ShadowScreenIndex].ptr)
#define GET_GC_PRIVATE(pGC) \
	(ShadowGCPtr)((pGC)->devPrivates[ShadowGCIndex].ptr)

#define SHADOW_GC_FUNC_PROLOGUE(pGC)\
    ShadowGCPtr pGCPriv = GET_GC_PRIVATE(pGC);\
    (pGC)->funcs = pGCPriv->funcs;\
    if(pGCPriv->ops)\
        (pGC)->ops = pGCPriv->ops

#define SHADOW_GC_FUNC_EPILOGUE(pGC)\
    pGCPriv->funcs = (pGC)->funcs;\
    (pGC)->funcs = &ShadowGCFuncs;\
    if(pGCPriv->ops) {\
        pGCPriv->ops = (pGC)->ops;\
        (pGC)->ops = &ShadowGCOps;\
    }

#define SHADOW_GC_OP_PROLOGUE(pGC)\
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pGC->pScreen); \
    ShadowGCPtr pGCPriv = GET_GC_PRIVATE(pGC);\
    GCFuncs *oldFuncs = pGC->funcs;\
    pGC->funcs = pGCPriv->funcs;\
    pGC->ops = pGCPriv->ops

    
#define SHADOW_GC_OP_EPILOGUE(pGC)\
    pGCPriv->ops = pGC->ops;\
    pGC->funcs = oldFuncs;\
    pGC->ops   = &ShadowGCOps

#define IS_VISIBLE(pWin) (pPriv->vtSema && \
    (((WindowPtr)pWin)->visibility != VisibilityFullyObscured))

#define TRIM_BOX(box, pGC) { \
    BoxPtr extents = &pGC->pCompositeClip->extents;\
    if(box.x1 < extents->x1) box.x1 = extents->x1; \
    if(box.x2 > extents->x2) box.x2 = extents->x2; \
    if(box.y1 < extents->y1) box.y1 = extents->y1; \
    if(box.y2 > extents->y2) box.y2 = extents->y2; \
    }

#define TRANSLATE_BOX(box, pDraw) { \
    box.x1 += pDraw->x; \
    box.x2 += pDraw->x; \
    box.y1 += pDraw->y; \
    box.y2 += pDraw->y; \
    }

#define TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC) { \
    TRANSLATE_BOX(box, pDraw); \
    TRIM_BOX(box, pGC); \
    }

#define BOX_NOT_EMPTY(box) \
    (((box.x2 - box.x1) > 0) && ((box.y2 - box.y1) > 0))



Bool
ShadowFBInit (
    ScreenPtr		pScreen,
    RefreshAreaFuncPtr  refreshArea
){
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    ShadowScreenPtr pPriv;

    if(!refreshArea) return FALSE;
    
    if (ShadowGeneration != serverGeneration) {
	if(((ShadowScreenIndex = AllocateScreenPrivateIndex ()) < 0) ||
	   ((ShadowGCIndex = AllocateGCPrivateIndex()) < 0))
	    return FALSE;
	ShadowGeneration = serverGeneration;
    }

    if(!AllocateGCPrivate(pScreen, ShadowGCIndex, sizeof(ShadowGCRec)))
	return FALSE;

    if(!(pPriv = (ShadowScreenPtr)xalloc(sizeof(ShadowScreenRec))))
	return FALSE;

    pScreen->devPrivates[ShadowScreenIndex].ptr = (pointer)pPriv;  

    pPriv->pScrn = pScrn;
    pPriv->refresh = refreshArea;
    pPriv->vtSema = TRUE;

    pPriv->CloseScreen = pScreen->CloseScreen;
    pPriv->PaintWindowBackground = pScreen->PaintWindowBackground;
    pPriv->PaintWindowBorder = pScreen->PaintWindowBorder;
    pPriv->CopyWindow = pScreen->CopyWindow;
    pPriv->CreateGC = pScreen->CreateGC;
    pPriv->RestoreAreas = pScreen->BackingStoreFuncs.RestoreAreas;
    pPriv->ModifyPixmapHeader = pScreen->ModifyPixmapHeader;

    pPriv->EnterVT = pScrn->EnterVT;
    pPriv->LeaveVT = pScrn->LeaveVT;
    pPriv->EnableDisableFBAccess = pScrn->EnableDisableFBAccess;

    pScreen->CloseScreen = ShadowCloseScreen;
    pScreen->PaintWindowBackground = ShadowPaintWindow;
    pScreen->PaintWindowBorder = ShadowPaintWindow;
    pScreen->CopyWindow = ShadowCopyWindow;
    pScreen->CreateGC = ShadowCreateGC;
    pScreen->BackingStoreFuncs.RestoreAreas = ShadowRestoreAreas;
    pScreen->ModifyPixmapHeader = ShadowModifyPixmapHeader;

    pScrn->EnterVT = ShadowEnterVT;
    pScrn->LeaveVT = ShadowLeaveVT;
    pScrn->EnableDisableFBAccess = ShadowEnableDisableFBAccess;

    return TRUE;
}

/**********************************************************/

static Bool
ShadowEnterVT(int index, int flags)
{
    ScrnInfoPtr pScrn = xf86Screens[index];
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScrn->pScreen);
    BoxRec box;

    if((*pPriv->EnterVT)(index, flags)) {
	pPriv->vtSema = TRUE;

	box.x1 = box.y1 = 0;
	box.x2 = pScrn->pScreen->width;
	box.y2 = pScrn->pScreen->height;

	(*pPriv->refresh)(pScrn, 1, &box);

        return TRUE;
    }

    return FALSE;
}

static void
ShadowLeaveVT(int index, int flags)
{
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(xf86Screens[index]->pScreen);

    pPriv->vtSema = FALSE;

    (*pPriv->LeaveVT)(index, flags);
}

static void
ShadowEnableDisableFBAccess(int index, Bool enable)
{
    /* nothing happens here; nothing touches the real frame buffer */
}


/**********************************************************/


static Bool
ShadowCloseScreen (int i, ScreenPtr pScreen)
{
    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScreen);

    pScreen->CloseScreen = pPriv->CloseScreen;
    pScreen->PaintWindowBackground = pPriv->PaintWindowBackground;
    pScreen->PaintWindowBorder = pPriv->PaintWindowBorder;
    pScreen->CopyWindow = pPriv->CopyWindow;
    pScreen->CreateGC = pPriv->CreateGC;
    pScreen->BackingStoreFuncs.RestoreAreas = pPriv->RestoreAreas;
    pScreen->ModifyPixmapHeader = pPriv->ModifyPixmapHeader;

    pScrn->EnterVT = pPriv->EnterVT;
    pScrn->LeaveVT = pPriv->LeaveVT;
    pScrn->EnableDisableFBAccess = pPriv->EnableDisableFBAccess;

    xfree((pointer)pPriv);

    return (*pScreen->CloseScreen) (i, pScreen);
}


static void
ShadowRestoreAreas (    
    PixmapPtr pPixmap,
    RegionPtr prgn,
    int       xorg,
    int       yorg,
    WindowPtr pWin 
){
    ScreenPtr pScreen = pWin->drawable.pScreen;
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScreen);
    int num;

    pScreen->BackingStoreFuncs.RestoreAreas = pPriv->RestoreAreas;
    (*pScreen->BackingStoreFuncs.RestoreAreas) (
                pPixmap, prgn, xorg, yorg, pWin);
    pScreen->BackingStoreFuncs.RestoreAreas = ShadowRestoreAreas;

    if(pPriv->vtSema && (num = REGION_NUM_RECTS(prgn)))
	(*pPriv->refresh)(pPriv->pScrn, num, REGION_RECTS(prgn));
}


static void
ShadowPaintWindow(
  WindowPtr pWin,
  RegionPtr prgn,
  int what 
){
    ScreenPtr pScreen = pWin->drawable.pScreen;
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScreen);
    int num;

    if(what == PW_BACKGROUND) {
	pScreen->PaintWindowBackground = pPriv->PaintWindowBackground;
	(*pScreen->PaintWindowBackground) (pWin, prgn, what);
	pScreen->PaintWindowBackground = ShadowPaintWindow;
    } else {
	pScreen->PaintWindowBorder = pPriv->PaintWindowBorder;
	(*pScreen->PaintWindowBorder) (pWin, prgn, what);
	pScreen->PaintWindowBorder = ShadowPaintWindow;
    }

    if(pPriv->vtSema && (num = REGION_NUM_RECTS(prgn)))
	(*pPriv->refresh)(pPriv->pScrn, num, REGION_RECTS(prgn));    
}


static void 
ShadowCopyWindow(
   WindowPtr pWin,
   DDXPointRec ptOldOrg,
   RegionPtr prgn 
){
    ScreenPtr pScreen = pWin->drawable.pScreen;
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScreen);
    int num;

    pScreen->CopyWindow = pPriv->CopyWindow;
    (*pScreen->CopyWindow) (pWin, ptOldOrg, prgn);
    pScreen->CopyWindow = ShadowCopyWindow;

    if (pPriv->vtSema) {
	/* This is sortof cheating. We rely on the fact that
	   cfb translated prgn for us */

	REGION_INTERSECT(pScreen, prgn, &pWin->borderClip, prgn);
	if((num = REGION_NUM_RECTS(prgn)))
	    (*pPriv->refresh)(pPriv->pScrn, num, REGION_RECTS(prgn));    
    }

}

static Bool
ShadowModifyPixmapHeader(
    PixmapPtr pPixmap,
    int width,
    int height,
    int depth,
    int bitsPerPixel,
    int devKind,
    pointer pPixData
)
{
    ScreenPtr pScreen;
    ScrnInfoPtr pScrn;
    ShadowScreenPtr pPriv;
    Bool retval;
    PixmapPtr pScreenPix;

    if (!pPixmap)
	return FALSE;

    pScreen = pPixmap->drawable.pScreen;
    pScrn = xf86Screens[pScreen->myNum];

    pScreenPix = (*pScreen->GetScreenPixmap)(pScreen);
    
    if (pPixmap == pScreenPix && !pScrn->vtSema)
	pScreenPix->devPrivate = pScrn->pixmapPrivate;
    
    pPriv = GET_SCREEN_PRIVATE(pScreen);

    pScreen->ModifyPixmapHeader = pPriv->ModifyPixmapHeader;
    retval = (*pScreen->ModifyPixmapHeader)(pPixmap,
	width, height, depth, bitsPerPixel, devKind, pPixData);
    pScreen->ModifyPixmapHeader = ShadowModifyPixmapHeader;

    if (pPixmap == pScreenPix && !pScrn->vtSema)
    {
	pScrn->pixmapPrivate = pScreenPix->devPrivate;
	pScreenPix->devPrivate.ptr = 0;
    }
    return retval;
}

/**********************************************************/

static void ShadowValidateGC(GCPtr, unsigned long, DrawablePtr);
static void ShadowChangeGC(GCPtr, unsigned long);
static void ShadowCopyGC(GCPtr, unsigned long, GCPtr);
static void ShadowDestroyGC(GCPtr);
static void ShadowChangeClip(GCPtr, int, pointer, int);
static void ShadowDestroyClip(GCPtr);
static void ShadowCopyClip(GCPtr, GCPtr);

GCFuncs ShadowGCFuncs = {
    ShadowValidateGC, ShadowChangeGC, ShadowCopyGC, ShadowDestroyGC,
    ShadowChangeClip, ShadowDestroyClip, ShadowCopyClip
};


extern GCOps ShadowGCOps;

static Bool
ShadowCreateGC(GCPtr pGC)
{
    ScreenPtr pScreen = pGC->pScreen;
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScreen);
    ShadowGCPtr pGCPriv = GET_GC_PRIVATE(pGC);
    Bool ret;
   
    pScreen->CreateGC = pPriv->CreateGC;
    if((ret = (*pScreen->CreateGC) (pGC))) {
	pGCPriv->ops = NULL;
	pGCPriv->funcs = pGC->funcs;
	pGC->funcs = &ShadowGCFuncs;
    }
    pScreen->CreateGC = ShadowCreateGC;

    return ret;
}


static void
ShadowValidateGC(
   GCPtr         pGC,
   unsigned long changes,
   DrawablePtr   pDraw 
){
    SHADOW_GC_FUNC_PROLOGUE (pGC);
    (*pGC->funcs->ValidateGC)(pGC, changes, pDraw);
    if(pDraw->type == DRAWABLE_WINDOW)
	pGCPriv->ops = pGC->ops;  /* just so it's not NULL */
    else 
	pGCPriv->ops = NULL;
    SHADOW_GC_FUNC_EPILOGUE (pGC);
}


static void
ShadowDestroyGC(GCPtr pGC)
{
    SHADOW_GC_FUNC_PROLOGUE (pGC);
    (*pGC->funcs->DestroyGC)(pGC);
    SHADOW_GC_FUNC_EPILOGUE (pGC);
}

static void
ShadowChangeGC (
    GCPtr	    pGC,
    unsigned long   mask
){
    SHADOW_GC_FUNC_PROLOGUE (pGC);
    (*pGC->funcs->ChangeGC) (pGC, mask);
    SHADOW_GC_FUNC_EPILOGUE (pGC);
}

static void
ShadowCopyGC (
    GCPtr	    pGCSrc, 
    unsigned long   mask,
    GCPtr	    pGCDst
){
    SHADOW_GC_FUNC_PROLOGUE (pGCDst);
    (*pGCDst->funcs->CopyGC) (pGCSrc, mask, pGCDst);
    SHADOW_GC_FUNC_EPILOGUE (pGCDst);
}

static void
ShadowChangeClip (
    GCPtr   pGC,
    int		type,
    pointer	pvalue,
    int		nrects 
){
    SHADOW_GC_FUNC_PROLOGUE (pGC);
    (*pGC->funcs->ChangeClip) (pGC, type, pvalue, nrects);
    SHADOW_GC_FUNC_EPILOGUE (pGC);
}

static void
ShadowCopyClip(GCPtr pgcDst, GCPtr pgcSrc)
{
    SHADOW_GC_FUNC_PROLOGUE (pgcDst);
    (* pgcDst->funcs->CopyClip)(pgcDst, pgcSrc);
    SHADOW_GC_FUNC_EPILOGUE (pgcDst);
}

static void
ShadowDestroyClip(GCPtr pGC)
{
    SHADOW_GC_FUNC_PROLOGUE (pGC);
    (* pGC->funcs->DestroyClip)(pGC);
    SHADOW_GC_FUNC_EPILOGUE (pGC);
}




/**********************************************************/


static void
ShadowFillSpans(
    DrawablePtr pDraw,
    GC		*pGC,
    int		nInit,	
    DDXPointPtr pptInit,	
    int 	*pwidthInit,		
    int 	fSorted 
){
    SHADOW_GC_OP_PROLOGUE(pGC);    

    if(IS_VISIBLE(pDraw) && nInit) {
	DDXPointPtr ppt = pptInit;
	int *pwidth = pwidthInit;
	int i = nInit;
	BoxRec box;

	box.x1 = ppt->x;
	box.x2 = box.x1 + *pwidth;
	box.y2 = box.y1 = ppt->y;

	while(--i) {
	   ppt++;
	   pwidthInit++;
	   if(box.x1 > ppt->x) box.x1 = ppt->x;
	   if(box.x2 < (ppt->x + *pwidth)) 
		box.x2 = ppt->x + *pwidth;
	   if(box.y1 > ppt->y) box.y1 = ppt->y;
	   else if(box.y2 < ppt->y) box.y2 = ppt->y;
	}

	box.y2++;

	(*pGC->ops->FillSpans)(pDraw, pGC, nInit, pptInit, pwidthInit, fSorted);

	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    } else
	(*pGC->ops->FillSpans)(pDraw, pGC, nInit, pptInit, pwidthInit, fSorted);

    SHADOW_GC_OP_EPILOGUE(pGC);
}

static void
ShadowSetSpans(
    DrawablePtr		pDraw,
    GCPtr		pGC,
    char		*pcharsrc,
    DDXPointPtr 	pptInit,
    int			*pwidthInit,
    int			nspans,
    int			fSorted 
){
    SHADOW_GC_OP_PROLOGUE(pGC);

    if(IS_VISIBLE(pDraw) && nspans) {
	DDXPointPtr ppt = pptInit;
	int *pwidth = pwidthInit;
	int i = nspans;
	BoxRec box;

	box.x1 = ppt->x;
	box.x2 = box.x1 + *pwidth;
	box.y2 = box.y1 = ppt->y;

	while(--i) {
	   ppt++;
	   pwidth++;
	   if(box.x1 > ppt->x) box.x1 = ppt->x;
	   if(box.x2 < (ppt->x + *pwidth)) 
		box.x2 = ppt->x + *pwidth;
	   if(box.y1 > ppt->y) box.y1 = ppt->y;
	   else if(box.y2 < ppt->y) box.y2 = ppt->y;
	}

	box.y2++;

	(*pGC->ops->SetSpans)(pDraw, pGC, pcharsrc, pptInit, 
				pwidthInit, nspans, fSorted);

	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    } else
	(*pGC->ops->SetSpans)(pDraw, pGC, pcharsrc, pptInit, 
				pwidthInit, nspans, fSorted);

    SHADOW_GC_OP_EPILOGUE(pGC);
}

static void
ShadowPutImage(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		depth, 
    int x, int y, int w, int h,
    int		leftPad,
    int		format,
    char 	*pImage 
){
    SHADOW_GC_OP_PROLOGUE(pGC);
    (*pGC->ops->PutImage)(pDraw, pGC, depth, x, y, w, h, 
		leftPad, format, pImage);
    SHADOW_GC_OP_EPILOGUE(pGC);

    if(IS_VISIBLE(pDraw)) {
	BoxRec box;

	box.x1 = x + pDraw->x;
	box.x2 = box.x1 + w;
	box.y1 = y + pDraw->y;
	box.y2 = box.y1 + h;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    }
}

static RegionPtr
ShadowCopyArea(
    DrawablePtr pSrc,
    DrawablePtr pDst,
    GC *pGC,
    int srcx, int srcy,
    int width, int height,
    int dstx, int dsty 
){
    RegionPtr ret;
    SHADOW_GC_OP_PROLOGUE(pGC);
    ret = (*pGC->ops->CopyArea)(pSrc, pDst,
            pGC, srcx, srcy, width, height, dstx, dsty);
    SHADOW_GC_OP_EPILOGUE(pGC);

    if(IS_VISIBLE(pDst)) {
	BoxRec box;

	box.x1 = dstx + pDst->x;
	box.x2 = box.x1 + width;
	box.y1 = dsty + pDst->y;
	box.y2 = box.y1 + height;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    }

    return ret;
}

static RegionPtr
ShadowCopyPlane(
    DrawablePtr	pSrc,
    DrawablePtr	pDst,
    GCPtr pGC,
    int	srcx, int srcy,
    int	width, int height,
    int	dstx, int dsty,
    unsigned long bitPlane 
){
    RegionPtr ret;
    SHADOW_GC_OP_PROLOGUE(pGC);
    ret = (*pGC->ops->CopyPlane)(pSrc, pDst,
	       pGC, srcx, srcy, width, height, dstx, dsty, bitPlane);
    SHADOW_GC_OP_EPILOGUE(pGC);

    if(IS_VISIBLE(pDst)) {
	BoxRec box;

	box.x1 = dstx + pDst->x;
	box.x2 = box.x1 + width;
	box.y1 = dsty + pDst->y;
	box.y2 = box.y1 + height;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    }

    return ret;
}

static void
ShadowPolyPoint(
    DrawablePtr pDraw,
    GCPtr pGC,
    int mode,
    int npt,
    xPoint *pptInit 
){
    SHADOW_GC_OP_PROLOGUE(pGC);
    (*pGC->ops->PolyPoint)(pDraw, pGC, mode, npt, pptInit);
    SHADOW_GC_OP_EPILOGUE(pGC);

    if(IS_VISIBLE(pDraw) && npt) {
	BoxRec box;

	box.x2 = box.x1 = pptInit->x;
	box.y2 = box.y1 = pptInit->y;

	/* this could be slow if the points were spread out */

	while(--npt) {
	   pptInit++;
	   if(box.x1 > pptInit->x) box.x1 = pptInit->x;
	   else if(box.x2 < pptInit->x) box.x2 = pptInit->x;
	   if(box.y1 > pptInit->y) box.y1 = pptInit->y;
	   else if(box.y2 < pptInit->y) box.y2 = pptInit->y;
	}

	box.x2++;
	box.y2++;

	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    }
}

static void
ShadowPolylines(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		mode,		
    int		npt,		
    DDXPointPtr pptInit 
){
    SHADOW_GC_OP_PROLOGUE(pGC);
    (*pGC->ops->Polylines)(pDraw, pGC, mode, npt, pptInit);
    SHADOW_GC_OP_EPILOGUE(pGC);


    if(IS_VISIBLE(pDraw) && npt) {
	BoxRec box;
	int extra = pGC->lineWidth >> 1;

	box.x2 = box.x1 = pptInit->x;
	box.y2 = box.y1 = pptInit->y;

	if(npt > 1) {
	   if(pGC->joinStyle == JoinMiter)
		extra = 6 * pGC->lineWidth;
	   else if(pGC->capStyle == CapProjecting)
		extra = pGC->lineWidth;
        }

	if(mode == CoordModePrevious) {
	   int x = box.x1;
	   int y = box.y1;
	   while(--npt) {
		pptInit++;
		x += pptInit->x;
		y += pptInit->y;
		if(box.x1 > x) box.x1 = x;
		else if(box.x2 < x) box.x2 = x;
		if(box.y1 > y) box.y1 = y;
		else if(box.y2 < y) box.y2 = y;
	    }
	} else {
	   while(--npt) {
		pptInit++;
		if(box.x1 > pptInit->x) box.x1 = pptInit->x;
		else if(box.x2 < pptInit->x) box.x2 = pptInit->x;
		if(box.y1 > pptInit->y) box.y1 = pptInit->y;
		else if(box.y2 < pptInit->y) box.y2 = pptInit->y;
	    }
	}

	box.x2++;
	box.y2++;

	if(extra) {
	   box.x1 -= extra;
	   box.x2 += extra;
	   box.y1 -= extra;
	   box.y2 += extra;
        }

	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    }
}

static void 
ShadowPolySegment(
    DrawablePtr	pDraw,
    GCPtr	pGC,
    int		nseg,
    xSegment	*pSeg 
){
    SHADOW_GC_OP_PROLOGUE(pGC);
    (*pGC->ops->PolySegment)(pDraw, pGC, nseg, pSeg);
    SHADOW_GC_OP_EPILOGUE(pGC);

    if(IS_VISIBLE(pDraw) && nseg) {
	BoxRec box;
	int extra = pGC->lineWidth;

        if(pGC->capStyle != CapProjecting)	
	   extra >>= 1;

	if(pSeg->x2 > pSeg->x1) {
	    box.x1 = pSeg->x1;
	    box.x2 = pSeg->x2;
	} else {
	    box.x2 = pSeg->x1;
	    box.x1 = pSeg->x2;
	}

	if(pSeg->y2 > pSeg->y1) {
	    box.y1 = pSeg->y1;
	    box.y2 = pSeg->y2;
	} else {
	    box.y2 = pSeg->y1;
	    box.y1 = pSeg->y2;
	}

	while(--nseg) {
	    pSeg++;
	    if(pSeg->x2 > pSeg->x1) {
		if(pSeg->x1 < box.x1) box.x1 = pSeg->x1;
		if(pSeg->x2 > box.x2) box.x2 = pSeg->x2;
	    } else {
		if(pSeg->x2 < box.x1) box.x1 = pSeg->x2;
		if(pSeg->x1 > box.x2) box.x2 = pSeg->x1;
	    }
	    if(pSeg->y2 > pSeg->y1) {
		if(pSeg->y1 < box.y1) box.y1 = pSeg->y1;
		if(pSeg->y2 > box.y2) box.y2 = pSeg->y2;
	    } else {
		if(pSeg->y2 < box.y1) box.y1 = pSeg->y2;
		if(pSeg->y1 > box.y2) box.y2 = pSeg->y1;
	    }
	}

	box.x2++;
	box.y2++;

	if(extra) {
	   box.x1 -= extra;
	   box.x2 += extra;
	   box.y1 -= extra;
	   box.y2 += extra;
        }

	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    }
}

static void
ShadowPolyRectangle(
    DrawablePtr  pDraw,
    GCPtr        pGC,
    int	         nRects,
    xRectangle  *pRects 
){
    SHADOW_GC_OP_PROLOGUE(pGC);
    (*pGC->ops->PolyRectangle)(pDraw, pGC, nRects, pRects);
    SHADOW_GC_OP_EPILOGUE(pGC);

    if(IS_VISIBLE(pDraw) && nRects) {
	if(nRects >= 32) {
	    int extra = pGC->lineWidth >> 1;
	    BoxRec box;

	    box.x1 = pRects->x;
	    box.x2 = box.x1 + pRects->width;
	    box.y1 = pRects->y;
	    box.y2 = box.y1 + pRects->height;

	    while(--nRects) {
		pRects++;
		if(box.x1 > pRects->x) box.x1 = pRects->x;
		if(box.x2 < (pRects->x + pRects->width))
			box.x2 = pRects->x + pRects->width;
		if(box.y1 > pRects->y) box.y1 = pRects->y;
		if(box.y2 < (pRects->y + pRects->height))
			box.y2 = pRects->y + pRects->height;
	    }

	    if(extra) {
		box.x1 -= extra;
		box.x2 += extra;
		box.y1 -= extra;
		box.y2 += extra;
	    }

	    box.x2++;
	    box.y2++;

	    TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	    if(BOX_NOT_EMPTY(box))
		(*pPriv->refresh)(pPriv->pScrn, 1, &box);
	} else {
	    BoxPtr pbox, pBoxInit;
	    int offset1, offset2, offset3;
	    int num = 0;

	    offset2 = pGC->lineWidth;
	    if(!offset2) offset2 = 1;
	    offset1 = offset2 >> 1;
	    offset3 = offset2 - offset1;

	    pBoxInit = (BoxPtr)ALLOCATE_LOCAL(nRects * 4 * sizeof(BoxRec));
	    pbox = pBoxInit;

	    while(nRects--) {
		pbox->x1 = pRects->x - offset1;
		pbox->y1 = pRects->y - offset1;
		pbox->x2 = pbox->x1 + pRects->width + offset2;
		pbox->y2 = pbox->y1 + offset2;		
		TRIM_AND_TRANSLATE_BOX((*pbox), pDraw, pGC);
		if(BOX_NOT_EMPTY((*pbox))) {
		   num++;
		   pbox++;
		}

		pbox->x1 = pRects->x - offset1;
		pbox->y1 = pRects->y + offset3;
		pbox->x2 = pbox->x1 + offset2;
		pbox->y2 = pbox->y1 + pRects->height - offset2;		
		TRIM_AND_TRANSLATE_BOX((*pbox), pDraw, pGC);
		if(BOX_NOT_EMPTY((*pbox))) {
		   num++;
		   pbox++;
		}

		pbox->x1 = pRects->x + pRects->width - offset1;
		pbox->y1 = pRects->y + offset3;
		pbox->x2 = pbox->x1 + offset2;
		pbox->y2 = pbox->y1 + pRects->height - offset2;		
		TRIM_AND_TRANSLATE_BOX((*pbox), pDraw, pGC);
		if(BOX_NOT_EMPTY((*pbox))) {
		   num++;
		   pbox++;
		}

		pbox->x1 = pRects->x - offset1;
		pbox->y1 = pRects->y + pRects->height - offset1;
		pbox->x2 = pbox->x1 + pRects->width + offset2;
		pbox->y2 = pbox->y1 + offset2;		
		TRIM_AND_TRANSLATE_BOX((*pbox), pDraw, pGC);
		if(BOX_NOT_EMPTY((*pbox))) {
		   num++;
		   pbox++;
		}

		pRects++;
	    }
	    
	    if(num)
		(*pPriv->refresh)(pPriv->pScrn, num, pBoxInit);

	    DEALLOCATE_LOCAL(pBoxInit);
	}
    }
 }

static void
ShadowPolyArc(
    DrawablePtr	pDraw,
    GCPtr	pGC,
    int		narcs,
    xArc	*parcs 
){
    SHADOW_GC_OP_PROLOGUE(pGC);
    (*pGC->ops->PolyArc)(pDraw, pGC, narcs, parcs);
    SHADOW_GC_OP_EPILOGUE(pGC);

    if(IS_VISIBLE(pDraw) && narcs) {
	int extra = pGC->lineWidth >> 1;
	BoxRec box;

	box.x1 = parcs->x;
	box.x2 = box.x1 + parcs->width;
	box.y1 = parcs->y;
	box.y2 = box.y1 + parcs->height;

	/* should I break these up instead ? */

	while(--narcs) {
	   parcs++;
	   if(box.x1 > parcs->x) box.x1 = parcs->x;
	   if(box.x2 < (parcs->x + parcs->width))
		box.x2 = parcs->x + parcs->width;
	   if(box.y1 > parcs->y) box.y1 = parcs->y;
	   if(box.y2 < (parcs->y + parcs->height))
		box.y2 = parcs->y + parcs->height;
        }

	if(extra) {
	   box.x1 -= extra;
	   box.x2 += extra;
	   box.y1 -= extra;
	   box.y2 += extra;
        }

	box.x2++;
	box.y2++;

	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    }
}

static void
ShadowFillPolygon(
    DrawablePtr	pDraw,
    GCPtr	pGC,
    int		shape,
    int		mode,
    int		count,
    DDXPointPtr	pptInit 
){
    SHADOW_GC_OP_PROLOGUE(pGC);

    if(IS_VISIBLE(pDraw) && (count > 2)) {
	DDXPointPtr ppt = pptInit;
	int i = count;
	BoxRec box;

	box.x2 = box.x1 = ppt->x;
	box.y2 = box.y1 = ppt->y;

	if(mode != CoordModeOrigin) {
	   int x = box.x1;
	   int y = box.y1;
	   while(--i) {
		ppt++;
		x += ppt->x;
		y += ppt->y;
		if(box.x1 > x) box.x1 = x;
		else if(box.x2 < x) box.x2 = x;
		if(box.y1 > y) box.y1 = y;
		else if(box.y2 < y) box.y2 = y;
	    }
	} else {
	   while(--i) {
		ppt++;
		if(box.x1 > ppt->x) box.x1 = ppt->x;
		else if(box.x2 < ppt->x) box.x2 = ppt->x;
		if(box.y1 > ppt->y) box.y1 = ppt->y;
		else if(box.y2 < ppt->y) box.y2 = ppt->y;
	    }
	}

	box.x2++;
	box.y2++;

	(*pGC->ops->FillPolygon)(pDraw, pGC, shape, mode, count, pptInit);

	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    } else
	(*pGC->ops->FillPolygon)(pDraw, pGC, shape, mode, count, pptInit);

    SHADOW_GC_OP_EPILOGUE(pGC);
}


static void 
ShadowPolyFillRect(
    DrawablePtr	pDraw,
    GCPtr	pGC,
    int		nRectsInit, 
    xRectangle	*pRectsInit 
){
    SHADOW_GC_OP_PROLOGUE(pGC);

    if(IS_VISIBLE(pDraw) && nRectsInit) {
	BoxRec box;
	xRectangle *pRects = pRectsInit;
	int nRects = nRectsInit;

	box.x1 = pRects->x;
	box.x2 = box.x1 + pRects->width;
	box.y1 = pRects->y;
	box.y2 = box.y1 + pRects->height;

	while(--nRects) {
	    pRects++;
	    if(box.x1 > pRects->x) box.x1 = pRects->x;
	    if(box.x2 < (pRects->x + pRects->width))
		box.x2 = pRects->x + pRects->width;
	    if(box.y1 > pRects->y) box.y1 = pRects->y;
	    if(box.y2 < (pRects->y + pRects->height))
		box.y2 = pRects->y + pRects->height;
	}

	/* cfb messes with the pRectsInit so we have to do our
	   calculations first */

	(*pGC->ops->PolyFillRect)(pDraw, pGC, nRectsInit, pRectsInit);

	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box))
	    (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    } else
	(*pGC->ops->PolyFillRect)(pDraw, pGC, nRectsInit, pRectsInit);

    SHADOW_GC_OP_EPILOGUE(pGC);
}


static void
ShadowPolyFillArc(
    DrawablePtr	pDraw,
    GCPtr	pGC,
    int		narcs,
    xArc	*parcs 
){
    SHADOW_GC_OP_PROLOGUE(pGC);
    (*pGC->ops->PolyFillArc)(pDraw, pGC, narcs, parcs);
    SHADOW_GC_OP_EPILOGUE(pGC);

    if(IS_VISIBLE(pDraw) && narcs) {
	BoxRec box;

	box.x1 = parcs->x;
	box.x2 = box.x1 + parcs->width;
	box.y1 = parcs->y;
	box.y2 = box.y1 + parcs->height;

	/* should I break these up instead ? */

	while(--narcs) {
	   parcs++;
	   if(box.x1 > parcs->x) box.x1 = parcs->x;
	   if(box.x2 < (parcs->x + parcs->width))
		box.x2 = parcs->x + parcs->width;
	   if(box.y1 > parcs->y) box.y1 = parcs->y;
	   if(box.y2 < (parcs->y + parcs->height))
		box.y2 = parcs->y + parcs->height;
        }

	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    }

}

static int
ShadowPolyText8(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x, 
    int 	y,
    int 	count,
    char	*chars 
){
    int width;

    SHADOW_GC_OP_PROLOGUE(pGC);
    width = (*pGC->ops->PolyText8)(pDraw, pGC, x, y, count, chars);
    SHADOW_GC_OP_EPILOGUE(pGC);

    width -= x;

    if(IS_VISIBLE(pDraw) && (width > 0)) {
	BoxRec box;

	/* ugh */
	box.x1 = pDraw->x + x + FONTMINBOUNDS(pGC->font, leftSideBearing);
	box.x2 = pDraw->x + x + FONTMAXBOUNDS(pGC->font, rightSideBearing);

	if(count > 1) {
	   if(width > 0) box.x2 += width;
	   else box.x1 += width;
	}

	box.y1 = pDraw->y + y - FONTMAXBOUNDS(pGC->font, ascent);
	box.y2 = pDraw->y + y + FONTMAXBOUNDS(pGC->font, descent);

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    }

    return (width + x);
}

static int
ShadowPolyText16(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x,
    int		y,
    int 	count,
    unsigned short *chars 
){
    int width;

    SHADOW_GC_OP_PROLOGUE(pGC);
    width = (*pGC->ops->PolyText16)(pDraw, pGC, x, y, count, chars);
    SHADOW_GC_OP_EPILOGUE(pGC);

    width -= x;

    if(IS_VISIBLE(pDraw) && (width > 0)) {
	BoxRec box;

	/* ugh */
	box.x1 = pDraw->x + x + FONTMINBOUNDS(pGC->font, leftSideBearing);
	box.x2 = pDraw->x + x + FONTMAXBOUNDS(pGC->font, rightSideBearing);

	if(count > 1) {
	   if(width > 0) box.x2 += width;
	   else box.x1 += width;
	}

	box.y1 = pDraw->y + y - FONTMAXBOUNDS(pGC->font, ascent);
	box.y2 = pDraw->y + y + FONTMAXBOUNDS(pGC->font, descent);

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    }

    return (width + x);
}

static void
ShadowImageText8(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x, 
    int		y,
    int 	count,
    char	*chars 
){
    SHADOW_GC_OP_PROLOGUE(pGC);
    (*pGC->ops->ImageText8)(pDraw, pGC, x, y, count, chars);
    SHADOW_GC_OP_EPILOGUE(pGC);

    if(IS_VISIBLE(pDraw) && count) {
	int top, bot, Min, Max;
	BoxRec box;

	top = max(FONTMAXBOUNDS(pGC->font, ascent), FONTASCENT(pGC->font));
	bot = max(FONTMAXBOUNDS(pGC->font, descent), FONTDESCENT(pGC->font));

	Min = count * FONTMINBOUNDS(pGC->font, characterWidth);
	if(Min > 0) Min = 0;
	Max = count * FONTMAXBOUNDS(pGC->font, characterWidth);	
	if(Max < 0) Max = 0;

	/* ugh */
	box.x1 = pDraw->x + x + Min +
		FONTMINBOUNDS(pGC->font, leftSideBearing);
	box.x2 = pDraw->x + x + Max + 
		FONTMAXBOUNDS(pGC->font, rightSideBearing);

	box.y1 = pDraw->y + y - top;
	box.y2 = pDraw->y + y + bot;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    }
}
static void
ShadowImageText16(
    DrawablePtr pDraw,
    GCPtr	pGC,
    int		x,
    int		y,
    int 	count,
    unsigned short *chars 
){
    SHADOW_GC_OP_PROLOGUE(pGC);
    (*pGC->ops->ImageText16)(pDraw, pGC, x, y, count, chars);
    SHADOW_GC_OP_EPILOGUE(pGC);

    if(IS_VISIBLE(pDraw) && count) {
	int top, bot, Min, Max;
	BoxRec box;

	top = max(FONTMAXBOUNDS(pGC->font, ascent), FONTASCENT(pGC->font));
	bot = max(FONTMAXBOUNDS(pGC->font, descent), FONTDESCENT(pGC->font));

	Min = count * FONTMINBOUNDS(pGC->font, characterWidth);
	if(Min > 0) Min = 0;
	Max = count * FONTMAXBOUNDS(pGC->font, characterWidth);	
	if(Max < 0) Max = 0;

	/* ugh */
	box.x1 = pDraw->x + x + Min +
		FONTMINBOUNDS(pGC->font, leftSideBearing);
	box.x2 = pDraw->x + x + Max + 
		FONTMAXBOUNDS(pGC->font, rightSideBearing);

	box.y1 = pDraw->y + y - top;
	box.y2 = pDraw->y + y + bot;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    }
}


static void
ShadowImageGlyphBlt(
    DrawablePtr pDraw,
    GCPtr pGC,
    int x, int y,
    unsigned int nglyph,
    CharInfoPtr *ppci,
    pointer pglyphBase 
){
    SHADOW_GC_OP_PROLOGUE(pGC);
    (*pGC->ops->ImageGlyphBlt)(pDraw, pGC, x, y, nglyph, 
					ppci, pglyphBase);
    SHADOW_GC_OP_EPILOGUE(pGC);

    if(IS_VISIBLE(pDraw) && nglyph) {
	int top, bot, width = 0;
	BoxRec box;

	top = max(FONTMAXBOUNDS(pGC->font, ascent), FONTASCENT(pGC->font));
	bot = max(FONTMAXBOUNDS(pGC->font, descent), FONTDESCENT(pGC->font));

	box.x1 = ppci[0]->metrics.leftSideBearing;
	if(box.x1 > 0) box.x1 = 0;
	box.x2 = ppci[nglyph - 1]->metrics.rightSideBearing - 
		ppci[nglyph - 1]->metrics.characterWidth;
	if(box.x2 < 0) box.x2 = 0;

	box.x2 += pDraw->x + x;
	box.x1 += pDraw->x + x;
	   
	while(nglyph--) {
	    width += (*ppci)->metrics.characterWidth;
	    ppci++;
	}

	if(width > 0) 
	   box.x2 += width;
	else 
	   box.x1 += width;

	box.y1 = pDraw->y + y - top;
	box.y2 = pDraw->y + y + bot;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    }
}

static void
ShadowPolyGlyphBlt(
    DrawablePtr pDraw,
    GCPtr pGC,
    int x, int y,
    unsigned int nglyph,
    CharInfoPtr *ppci,
    pointer pglyphBase 
){
    SHADOW_GC_OP_PROLOGUE(pGC);
    (*pGC->ops->PolyGlyphBlt)(pDraw, pGC, x, y, nglyph, 
				ppci, pglyphBase);
    SHADOW_GC_OP_EPILOGUE(pGC);

    if(IS_VISIBLE(pDraw) && nglyph) {
	BoxRec box;

	/* ugh */
	box.x1 = pDraw->x + x + ppci[0]->metrics.leftSideBearing;
	box.x2 = pDraw->x + x + ppci[nglyph - 1]->metrics.rightSideBearing;

	if(nglyph > 1) {
	    int width = 0;

	    while(--nglyph) { 
		width += (*ppci)->metrics.characterWidth;
		ppci++;
	    }
	
	    if(width > 0) box.x2 += width;
	    else box.x1 += width;
	}

	box.y1 = pDraw->y + y - FONTMAXBOUNDS(pGC->font, ascent);
	box.y2 = pDraw->y + y + FONTMAXBOUNDS(pGC->font, descent);

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    }
}

static void
ShadowPushPixels(
    GCPtr	pGC,
    PixmapPtr	pBitMap,
    DrawablePtr pDraw,
    int	dx, int dy, int xOrg, int yOrg 
){
    SHADOW_GC_OP_PROLOGUE(pGC);
    (*pGC->ops->PushPixels)(pGC, pBitMap, pDraw, dx, dy, xOrg, yOrg);
    SHADOW_GC_OP_EPILOGUE(pGC);

    if(IS_VISIBLE(pDraw)) {
	BoxRec box;

	box.x1 = xOrg + pDraw->x;
	box.x2 = box.x1 + dx;
	box.y1 = yOrg + pDraw->y;
	box.y2 = box.y1 + dy;

	TRIM_BOX(box, pGC);
	if(BOX_NOT_EMPTY(box))
	   (*pPriv->refresh)(pPriv->pScrn, 1, &box);
    }
}


GCOps ShadowGCOps = {
    ShadowFillSpans, ShadowSetSpans, 
    ShadowPutImage, ShadowCopyArea, 
    ShadowCopyPlane, ShadowPolyPoint, 
    ShadowPolylines, ShadowPolySegment, 
    ShadowPolyRectangle, ShadowPolyArc, 
    ShadowFillPolygon, ShadowPolyFillRect, 
    ShadowPolyFillArc, ShadowPolyText8, 
    ShadowPolyText16, ShadowImageText8, 
    ShadowImageText16, ShadowImageGlyphBlt, 
    ShadowPolyGlyphBlt, ShadowPushPixels,
#ifdef NEED_LINEHELPER
    NULL,
#endif
    {NULL}		/* devPrivate */
};

@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@a4 2

   Pre-fb-write callbacks and RENDER support - Nolan Leake (nolan@@vmware.com)
d7 1
a7 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/shadowfb/shadow.c,v 1.21 2003/11/10 18:22:38 tsi Exp $ */
a24 6
#ifdef RENDER
# include "picturestr.h"
#endif

#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))
d57 1
a57 17

#ifdef RENDER
static void ShadowComposite(
    CARD8 op,
    PicturePtr pSrc,
    PicturePtr pMask,
    PicturePtr pDst,
    INT16 xSrc,
    INT16 ySrc,
    INT16 xMask,
    INT16 yMask,
    INT16 xDst,
    INT16 yDst,
    CARD16 width,
    CARD16 height
);
#endif /* RENDER */
d62 1
a62 2
  RefreshAreaFuncPtr			preRefresh;
  RefreshAreaFuncPtr                    postRefresh;
a69 3
#ifdef RENDER
  CompositeProcPtr Composite;
#endif /* RENDER */
d72 1
d147 1
a147 1
ShadowFBInit2 (
d149 1
a149 2
    RefreshAreaFuncPtr  preRefreshArea,
    RefreshAreaFuncPtr  postRefreshArea
a152 3
#ifdef RENDER
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);
#endif /* RENDER */
d154 1
a154 1
    if(!preRefreshArea && !postRefreshArea) return FALSE;
d172 1
a172 2
    pPriv->preRefresh = preRefreshArea;
    pPriv->postRefresh = postRefreshArea;
d185 1
d197 1
a197 7

#ifdef RENDER
    if(ps) {
      pPriv->Composite = ps->Composite;
      ps->Composite = ShadowComposite;
    }
#endif /* RENDER */
a201 8
Bool
ShadowFBInit (
    ScreenPtr		pScreen,
    RefreshAreaFuncPtr  refreshArea
){
    return ShadowFBInit2(pScreen, NULL, refreshArea);
}

d209 1
d213 7
d236 7
a250 3
#ifdef RENDER
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);
#endif /* RENDER */
d262 1
a262 6

#ifdef RENDER
    if(ps) {
        ps->Composite = pPriv->Composite;
    }
#endif /* RENDER */
d280 1
a280 5
    int num = 0;

    if(pPriv->vtSema && (num = REGION_NUM_RECTS(prgn)))
        if(pPriv->preRefresh)
            (*pPriv->preRefresh)(pPriv->pScrn, num, REGION_RECTS(prgn));
d287 2
a288 2
    if(num && pPriv->postRefresh)
	(*pPriv->postRefresh)(pPriv->pScrn, num, REGION_RECTS(prgn));
d300 1
a300 5
    int num = 0;

    if(pPriv->vtSema && (num = REGION_NUM_RECTS(prgn)))
        if(pPriv->preRefresh)
            (*pPriv->preRefresh)(pPriv->pScrn, num, REGION_RECTS(prgn));
d312 2
a313 2
    if(num && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, num, REGION_RECTS(prgn));    
d325 1
a325 2
    int num = 0;
    RegionRec rgnDst;
a326 16
    if (pPriv->vtSema) {
        REGION_NULL(pWin->drawable.pScreen, &rgnDst);
	REGION_COPY(pWin->drawable.pScreen, &rgnDst, prgn);
        
        REGION_TRANSLATE(pWin->drawable.pScreen, &rgnDst,
                         pWin->drawable.x - ptOldOrg.x,
                         pWin->drawable.y - ptOldOrg.y);
        REGION_INTERSECT(pScreen, &rgnDst, &pWin->borderClip, &rgnDst);
        if ((num = REGION_NUM_RECTS(&rgnDst))) {
            if(pPriv->preRefresh)
                (*pPriv->preRefresh)(pPriv->pScrn, num, REGION_RECTS(&rgnDst));
        } else {
            REGION_UNINIT(pWin->drawable.pScreen, &rgnDst);
        }
    }
    
d330 8
a337 5
    
    if (num) {
        if (pPriv->postRefresh)
            (*pPriv->postRefresh)(pPriv->pScrn, num, REGION_RECTS(&rgnDst));
        REGION_UNINIT(pWin->drawable.pScreen, &rgnDst);
d339 1
a384 55
#ifdef RENDER
static void
ShadowComposite(
    CARD8 op,
    PicturePtr pSrc,
    PicturePtr pMask,
    PicturePtr pDst,
    INT16 xSrc,
    INT16 ySrc,
    INT16 xMask,
    INT16 yMask,
    INT16 xDst,
    INT16 yDst,
    CARD16 width,
    CARD16 height
){
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScreen);
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    BoxRec box;
    BoxPtr extents;
    Bool boxNotEmpty = FALSE;

    if (pPriv->vtSema
	&& pDst->pDrawable->type == DRAWABLE_WINDOW) {

	box.x1 = pDst->pDrawable->x + xDst;
	box.y1 = pDst->pDrawable->y + yDst;
	box.x2 = box.x1 + width;
	box.y2 = box.y1 + height;

	extents = &pDst->pCompositeClip->extents;
	if(box.x1 < extents->x1) box.x1 = extents->x1;
	if(box.x2 > extents->x2) box.x2 = extents->x2;
	if(box.y1 < extents->y1) box.y1 = extents->y1;
	if(box.y2 > extents->y2) box.y2 = extents->y2;
	
	if (BOX_NOT_EMPTY(box)) {
	    if (pPriv->preRefresh)
		(*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
	    boxNotEmpty = TRUE;
	}
    }
    
    ps->Composite = pPriv->Composite;
    (*ps->Composite)(op, pSrc, pMask, pDst, xSrc, ySrc,
		     xMask, yMask, xDst, yDst, width, height);
    ps->Composite = ShadowComposite;

    if (pPriv->postRefresh && boxNotEmpty) {
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    }
}
#endif /* RENDER */

a517 1
        Bool boxNotEmpty = FALSE;
d525 1
a525 1
	   pwidth++;
a534 11
        if(!pGC->miTranslate) {
           TRANSLATE_BOX(box, pDraw);
        }
        TRIM_BOX(box, pGC); 

	if(BOX_NOT_EMPTY(box)) {
            if(pPriv->preRefresh)
                (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }

d537 3
a539 2
        if(boxNotEmpty && pPriv->postRefresh)
	   (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
a562 1
        Bool boxNotEmpty = FALSE;
a579 11
        if(!pGC->miTranslate) {
           TRANSLATE_BOX(box, pDraw);
        }
        TRIM_BOX(box, pGC);

	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }

d583 3
a585 2
	if(boxNotEmpty && pPriv->postRefresh)
	   (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
a602 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
    
d604 3
d609 2
d617 2
a618 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a619 9

    (*pGC->ops->PutImage)(pDraw, pGC, depth, x, y, w, h, 
		leftPad, format, pImage);
                
    if(boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
    SHADOW_GC_OP_EPILOGUE(pGC);

a631 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
    
d633 3
d638 2
d646 2
a647 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a648 8
    
    ret = (*pGC->ops->CopyArea)(pSrc, pDst,
            pGC, srcx, srcy, width, height, dstx, dsty);

    if(boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
    SHADOW_GC_OP_EPILOGUE(pGC);
a663 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
    
d665 3
d670 2
d678 2
a679 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a680 8
    
    ret = (*pGC->ops->CopyPlane)(pSrc, pDst,
	       pGC, srcx, srcy, width, height, dstx, dsty, bitPlane);
    
    if(boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
    SHADOW_GC_OP_EPILOGUE(pGC);
d690 1
a690 1
    int nptInit,
a692 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
    
d694 2
d697 2
a698 3
    if(IS_VISIBLE(pDraw) && nptInit) {
        xPoint *ppt = pptInit;
        int npt = nptInit;
d706 5
a710 5
	   ppt++;
	   if(box.x1 > ppt->x) box.x1 = ppt->x;
	   else if(box.x2 < ppt->x) box.x2 = ppt->x;
	   if(box.y1 > ppt->y) box.y1 = ppt->y;
	   else if(box.y2 < ppt->y) box.y2 = ppt->y;
d717 2
a718 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a719 7
    
    (*pGC->ops->PolyPoint)(pDraw, pGC, mode, nptInit, pptInit);
    
    if(boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
d727 1
a727 1
    int		nptInit,		
a729 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
    
d731 3
d735 2
a736 3
    if(IS_VISIBLE(pDraw) && nptInit) {
        DDXPointPtr ppt = pptInit;
        int npt = nptInit;
d753 3
a755 3
		ppt++;
		x += ppt->x;
		y += ppt->y;
d763 5
a767 5
		ppt++;
		if(box.x1 > ppt->x) box.x1 = ppt->x;
		else if(box.x2 < ppt->x) box.x2 = ppt->x;
		if(box.y1 > ppt->y) box.y1 = ppt->y;
		else if(box.y2 < ppt->y) box.y2 = ppt->y;
d782 2
a783 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a784 7
    
    (*pGC->ops->Polylines)(pDraw, pGC, mode, nptInit, pptInit);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
d791 2
a792 2
    int		nsegInit,
    xSegment	*pSegInit 
a793 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
   
d795 2
d798 2
a799 1
    if(IS_VISIBLE(pDraw) && nsegInit) {
a800 2
        xSegment *pSeg = pSegInit;
        int nseg = nsegInit;
d850 2
a851 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a852 7
    
    (*pGC->ops->PolySegment)(pDraw, pGC, nsegInit, pSegInit);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
d859 2
a860 2
    int	         nRectsInit,
    xRectangle  *pRectsInit 
a861 5
    BoxRec box;
    BoxPtr pBoxInit = NULL;
    Bool boxNotEmpty = FALSE;
    int num = 0;
    
d863 2
d866 1
a866 4
    if(IS_VISIBLE(pDraw) && nRectsInit) {
        xRectangle *pRects = pRectsInit;
        int nRects = nRectsInit;

d869 1
d897 2
a898 5
	    if(BOX_NOT_EMPTY(box)) {
                if(pPriv->preRefresh)
                   (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
                boxNotEmpty = TRUE;
            }
d900 1
a900 1
	    BoxPtr pbox;
d902 1
d956 4
a959 6
	    if(num) {
                if(pPriv->preRefresh)
                    (*pPriv->preRefresh)(pPriv->pScrn, num, pBoxInit);
            } else {
                DEALLOCATE_LOCAL(pBoxInit);
            }                
d962 1
a962 14

    (*pGC->ops->PolyRectangle)(pDraw, pGC, nRectsInit, pRectsInit);

    if(boxNotEmpty && pPriv->postRefresh) {
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    } else if(num) {
       if(pPriv->postRefresh)
          (*pPriv->postRefresh)(pPriv->pScrn, num, pBoxInit);
       DEALLOCATE_LOCAL(pBoxInit);
    }
    
    SHADOW_GC_OP_EPILOGUE(pGC);

}
d968 2
a969 2
    int		narcsInit,
    xArc	*parcsInit 
a970 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
   
d972 2
d975 3
a977 4
    if(IS_VISIBLE(pDraw) && narcsInit) {
        int narcs = narcsInit;
        xArc *parcs = parcsInit;
        int extra = pGC->lineWidth >> 1;
d1007 2
a1008 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a1009 8
    
    (*pGC->ops->PolyArc)(pDraw, pGC, narcsInit, parcsInit);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
    SHADOW_GC_OP_EPILOGUE(pGC);

a1026 1
        Bool boxNotEmpty = FALSE;
a1055 7
	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }

d1058 3
a1060 2
        if(boxNotEmpty && pPriv->postRefresh)
           (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);        
a1078 1
        Bool boxNotEmpty = FALSE;
a1099 7
	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box)) {
            if(pPriv->preRefresh)
                (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }

d1102 3
a1104 2
        if(boxNotEmpty && pPriv->postRefresh)
            (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
d1116 2
a1117 2
    int		narcsInit,
    xArc	*parcsInit 
a1118 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
   
d1120 2
d1123 2
a1124 3
    if(IS_VISIBLE(pDraw) && narcsInit) {
        xArc *parcs = parcsInit;
        int narcs = narcsInit;
d1144 2
a1145 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a1147 90
    (*pGC->ops->PolyFillArc)(pDraw, pGC, narcsInit, parcsInit);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);       
    
    SHADOW_GC_OP_EPILOGUE(pGC);
}

static void
ShadowTextExtent(FontPtr pFont, int count, char* chars,
                 FontEncoding fontEncoding, BoxPtr box)
{
    unsigned long n, i;
    int w;
    CharInfoPtr charinfo[255];	/* encoding only has 1 byte for count */

    GetGlyphs(pFont, (unsigned long)count, (unsigned char *)chars,
	      fontEncoding, &n, charinfo);
    w = 0;
    for (i=0; i < n; i++) {
        w += charinfo[i]->metrics.characterWidth;
    }
    if (i) {
    	w += charinfo[i - 1]->metrics.rightSideBearing;
    }
    
    box->x1 = 0;
    if (n) {
	if (charinfo[0]->metrics.leftSideBearing < 0) {
            box->x1 = charinfo[0]->metrics.leftSideBearing;
        }
    }
    box->x2 = w;
    box->y1 = -FONTMAXBOUNDS(pFont,ascent);
    box->y2 = FONTMAXBOUNDS(pFont,descent);
}



static void
ShadowFontToBox(BoxPtr BB, DrawablePtr pDrawable, GCPtr pGC, int x, int y,
                int count, char *chars, int wide)
{
    FontPtr pFont;

    pFont = pGC->font;
    if (pFont->info.constantWidth) {
        int ascent, descent, left, right = 0;

	ascent = MAX(pFont->info.fontAscent, pFont->info.maxbounds.ascent);
	descent = MAX(pFont->info.fontDescent, pFont->info.maxbounds.descent);
	left = pFont->info.maxbounds.leftSideBearing;
	if (count > 0) {
	    right = (count - 1) * pFont->info.maxbounds.characterWidth;
	}
	right += pFont->info.maxbounds.rightSideBearing;
	BB->x1 =
	    MAX(pDrawable->x + x - left, (REGION_EXTENTS(pGC->pScreen,
		&((WindowPtr) pDrawable)->winSize))->x1);
	BB->y1 =
	    MAX(pDrawable->y + y - ascent,
	    (REGION_EXTENTS(pGC->pScreen,
             &((WindowPtr) pDrawable)->winSize))->y1);
	BB->x2 =
	    MIN(pDrawable->x + x + right,
	    (REGION_EXTENTS(pGC->pScreen,
             &((WindowPtr) pDrawable)->winSize))->x2);
	BB->y2 =
	    MIN(pDrawable->y + y + descent,
	    (REGION_EXTENTS(pGC->pScreen,
             &((WindowPtr) pDrawable)->winSize))->y2);
    } else {
    	ShadowTextExtent(pFont, count, chars, wide ? (FONTLASTROW(pFont) == 0)
                         ? Linear16Bit : TwoD16Bit : Linear8Bit, BB);
	BB->x1 =
	    MAX(pDrawable->x + x + BB->x1, (REGION_EXTENTS(pGC->pScreen,
		&((WindowPtr) pDrawable)->winSize))->x1);
	BB->y1 =
	    MAX(pDrawable->y + y + BB->y1,
	    (REGION_EXTENTS(pGC->pScreen,
             &((WindowPtr) pDrawable)->winSize))->y1);
	BB->x2 =
	    MIN(pDrawable->x + x + BB->x2,
	    (REGION_EXTENTS(pGC->pScreen,
	     &((WindowPtr) pDrawable)->winSize))->x2);
	BB->y2 =
	    MIN(pDrawable->y + y + BB->y2,
	    (REGION_EXTENTS(pGC->pScreen, 
	     &((WindowPtr) pDrawable)->winSize))->y2);
    }
d1160 1
a1160 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
    
d1162 19
d1182 3
a1184 9
    if(IS_VISIBLE(pDraw)) {
        ShadowFontToBox(&box, pDraw, pGC, x, y, count, chars, 0);
       
        TRIM_BOX(box, pGC);
        if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a1185 2
    
    width = (*pGC->ops->PolyText8)(pDraw, pGC, x, y, count, chars);
d1187 1
a1187 6
    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
    SHADOW_GC_OP_EPILOGUE(pGC);

    return width;
a1199 2
    BoxRec box;
    Bool boxNotEmpty = FALSE;
d1202 4
d1207 6
a1212 10
    if(IS_VISIBLE(pDraw)) {
        ShadowFontToBox(&box, pDraw, pGC, x, y, count, (char*)chars, 1);
       
        TRIM_BOX(box, pGC);
        if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
    }
d1214 4
a1217 1
    width = (*pGC->ops->PolyText16)(pDraw, pGC, x, y, count, chars);
d1219 2
a1220 2
    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
d1222 4
a1225 1
    SHADOW_GC_OP_EPILOGUE(pGC);
d1227 1
a1227 1
    return width;
a1238 2
    BoxRec box;
    Bool boxNotEmpty = FALSE;
d1240 2
d1245 1
d1265 2
a1266 5
	if(BOX_NOT_EMPTY(box)) {
            if(pPriv->preRefresh) 
               (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
a1267 7
    
    (*pGC->ops->ImageText8)(pDraw, pGC, x, y, count, chars);

    if(boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
    SHADOW_GC_OP_EPILOGUE(pGC);
a1277 2
    BoxRec box;
    Bool boxNotEmpty = FALSE;
d1279 2
d1284 1
d1304 2
a1305 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a1306 7
    
    (*pGC->ops->ImageText16)(pDraw, pGC, x, y, count, chars);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);   
    
    SHADOW_GC_OP_EPILOGUE(pGC);
d1315 2
a1316 2
    unsigned int nglyphInit,
    CharInfoPtr *ppciInit,
a1318 2
    BoxRec box;
    Bool boxNotEmpty = FALSE;
d1320 3
d1324 1
a1324 3
    if(IS_VISIBLE(pDraw) && nglyphInit) {
        CharInfoPtr *ppci = ppciInit;
        unsigned int nglyph = nglyphInit;
d1326 1
d1354 2
a1355 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a1356 8

    (*pGC->ops->ImageGlyphBlt)(pDraw, pGC, x, y, nglyphInit, 
					ppciInit, pglyphBase);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
d1364 2
a1365 2
    unsigned int nglyphInit,
    CharInfoPtr *ppciInit,
a1367 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;

d1369 3
d1373 2
a1374 3
    if(IS_VISIBLE(pDraw) && nglyphInit) {
        CharInfoPtr *ppci = ppciInit;
        unsigned int nglyph = nglyphInit;
d1396 2
a1397 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a1398 8
    
    (*pGC->ops->PolyGlyphBlt)(pDraw, pGC, x, y, nglyphInit, 
				ppciInit, pglyphBase);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
a1407 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
    
d1409 2
d1413 1
a1413 7
	box.x1 = xOrg;
	box.y1 = yOrg;

        if(!pGC->miTranslate) {
           box.x1 += pDraw->x;          
           box.y1 += pDraw->y;          
        }
d1415 1
d1417 1
d1421 2
a1422 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a1423 7

    (*pGC->ops->PushPixels)(pGC, pBitMap, pDraw, dx, dy, xOrg, yOrg);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@a4 2

   Pre-fb-write callbacks and RENDER support - Nolan Leake (nolan@@vmware.com)
d7 1
a7 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/shadowfb/shadow.c,v 1.18 2003/02/21 15:06:19 eich Exp $ */
a24 6
#ifdef RENDER
# include "picturestr.h"
#endif

#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))
d57 1
a57 17

#ifdef RENDER
static void ShadowComposite(
    CARD8 op,
    PicturePtr pSrc,
    PicturePtr pMask,
    PicturePtr pDst,
    INT16 xSrc,
    INT16 ySrc,
    INT16 xMask,
    INT16 yMask,
    INT16 xDst,
    INT16 yDst,
    CARD16 width,
    CARD16 height
);
#endif /* RENDER */
d62 1
a62 2
  RefreshAreaFuncPtr			preRefresh;
  RefreshAreaFuncPtr                    postRefresh;
a69 3
#ifdef RENDER
  CompositeProcPtr Composite;
#endif /* RENDER */
d72 1
d147 1
a147 1
ShadowFBInit2 (
d149 1
a149 2
    RefreshAreaFuncPtr  preRefreshArea,
    RefreshAreaFuncPtr  postRefreshArea
a152 3
#ifdef RENDER
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);
#endif /* RENDER */
d154 1
a154 1
    if(!preRefreshArea && !postRefreshArea) return FALSE;
d172 1
a172 2
    pPriv->preRefresh = preRefreshArea;
    pPriv->postRefresh = postRefreshArea;
d185 1
d197 1
a197 7

#ifdef RENDER
    if(ps) {
      pPriv->Composite = ps->Composite;
      ps->Composite = ShadowComposite;
    }
#endif /* RENDER */
a201 8
Bool
ShadowFBInit (
    ScreenPtr		pScreen,
    RefreshAreaFuncPtr  refreshArea
){
    return ShadowFBInit2(pScreen, NULL, refreshArea);
}

d209 1
d213 7
d236 7
a250 3
#ifdef RENDER
    PictureScreenPtr ps = GetPictureScreenIfSet(pScreen);
#endif /* RENDER */
d262 1
a262 6

#ifdef RENDER
    if(ps) {
        ps->Composite = pPriv->Composite;
    }
#endif /* RENDER */
d280 1
a280 5
    int num = 0;

    if(pPriv->vtSema && (num = REGION_NUM_RECTS(prgn)))
        if(pPriv->preRefresh)
            (*pPriv->preRefresh)(pPriv->pScrn, num, REGION_RECTS(prgn));
d287 2
a288 2
    if(num && pPriv->postRefresh)
	(*pPriv->postRefresh)(pPriv->pScrn, num, REGION_RECTS(prgn));
d300 1
a300 5
    int num = 0;

    if(pPriv->vtSema && (num = REGION_NUM_RECTS(prgn)))
        if(pPriv->preRefresh)
            (*pPriv->preRefresh)(pPriv->pScrn, num, REGION_RECTS(prgn));
d312 2
a313 2
    if(num && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, num, REGION_RECTS(prgn));    
d325 1
a325 2
    int num = 0;
    RegionRec rgnDst;
a326 16
    if (pPriv->vtSema) {
        REGION_INIT(pWin->drawable.pScreen, &rgnDst, NullBox, 0);
	REGION_COPY(pWin->drawable.pScreen, &rgnDst, prgn);
        
        REGION_TRANSLATE(pWin->drawable.pScreen, &rgnDst,
                         pWin->drawable.x - ptOldOrg.x,
                         pWin->drawable.y - ptOldOrg.y);
        REGION_INTERSECT(pScreen, &rgnDst, &pWin->borderClip, &rgnDst);
        if ((num = REGION_NUM_RECTS(&rgnDst))) {
            if(pPriv->preRefresh)
                (*pPriv->preRefresh)(pPriv->pScrn, num, REGION_RECTS(&rgnDst));
        } else {
            REGION_UNINIT(pWin->drawable.pScreen, &rgnDst);
        }
    }
    
d330 8
a337 5
    
    if (num) {
        if (pPriv->postRefresh)
            (*pPriv->postRefresh)(pPriv->pScrn, num, REGION_RECTS(&rgnDst));
        REGION_UNINIT(pWin->drawable.pScreen, &rgnDst);
d339 1
a384 45
#ifdef RENDER
static void
ShadowComposite(
    CARD8 op,
    PicturePtr pSrc,
    PicturePtr pMask,
    PicturePtr pDst,
    INT16 xSrc,
    INT16 ySrc,
    INT16 xMask,
    INT16 yMask,
    INT16 xDst,
    INT16 yDst,
    CARD16 width,
    CARD16 height
){
    ScreenPtr pScreen = pDst->pDrawable->pScreen;
    ShadowScreenPtr pPriv = GET_SCREEN_PRIVATE(pScreen);
    PictureScreenPtr ps = GetPictureScreen(pScreen);
    BoxRec box;
    Bool boxNotEmpty = FALSE;

    box.x1 = pDst->pDrawable->x + xDst;
    box.y1 = pDst->pDrawable->y + yDst;
    box.x2 = box.x1 + width;
    box.y2 = box.y1 + height;

    if (pPriv->vtSema
	&& pDst->pDrawable->type == DRAWABLE_WINDOW && BOX_NOT_EMPTY(box)) {
        if (pPriv->preRefresh)
            (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
        boxNotEmpty = TRUE;
    }
    
    ps->Composite = pPriv->Composite;
    (*ps->Composite)(op, pSrc, pMask, pDst, xSrc, ySrc,
		     xMask, yMask, xDst, yDst, width, height);
    ps->Composite = ShadowComposite;

    if (pPriv->postRefresh && boxNotEmpty) {
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    }
}
#endif /* RENDER */

a517 1
        Bool boxNotEmpty = FALSE;
d525 1
a525 1
	   pwidth++;
a533 7
	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);

	if(BOX_NOT_EMPTY(box)) {
            if(pPriv->preRefresh)
                (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
d537 3
a539 2
        if(boxNotEmpty && pPriv->postRefresh)
	   (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
a562 1
        Bool boxNotEmpty = FALSE;
a578 7
	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);

	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
d583 3
a585 2
	if(boxNotEmpty && pPriv->postRefresh)
	   (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
a602 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
    
d604 3
d609 2
d617 2
a618 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a619 9

    (*pGC->ops->PutImage)(pDraw, pGC, depth, x, y, w, h, 
		leftPad, format, pImage);
                
    if(boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
    SHADOW_GC_OP_EPILOGUE(pGC);

a631 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
    
d633 3
d638 2
d646 2
a647 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a648 8
    
    ret = (*pGC->ops->CopyArea)(pSrc, pDst,
            pGC, srcx, srcy, width, height, dstx, dsty);

    if(boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
    SHADOW_GC_OP_EPILOGUE(pGC);
a663 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
    
d665 3
d670 2
d678 2
a679 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a680 8
    
    ret = (*pGC->ops->CopyPlane)(pSrc, pDst,
	       pGC, srcx, srcy, width, height, dstx, dsty, bitPlane);
    
    if(boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
    SHADOW_GC_OP_EPILOGUE(pGC);
d690 1
a690 1
    int nptInit,
a692 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
    
d694 2
d697 2
a698 3
    if(IS_VISIBLE(pDraw) && nptInit) {
        xPoint *ppt = pptInit;
        int npt = nptInit;
d706 5
a710 5
	   ppt++;
	   if(box.x1 > ppt->x) box.x1 = ppt->x;
	   else if(box.x2 < ppt->x) box.x2 = ppt->x;
	   if(box.y1 > ppt->y) box.y1 = ppt->y;
	   else if(box.y2 < ppt->y) box.y2 = ppt->y;
d717 2
a718 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a719 7
    
    (*pGC->ops->PolyPoint)(pDraw, pGC, mode, nptInit, pptInit);
    
    if(boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
d727 1
a727 1
    int		nptInit,		
a729 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
    
d731 2
d734 3
a736 3
    if(IS_VISIBLE(pDraw) && nptInit) {
        DDXPointPtr ppt = pptInit;
        int npt = nptInit;
d753 3
a755 3
		ppt++;
		x += ppt->x;
		y += ppt->y;
d763 5
a767 5
		ppt++;
		if(box.x1 > ppt->x) box.x1 = ppt->x;
		else if(box.x2 < ppt->x) box.x2 = ppt->x;
		if(box.y1 > ppt->y) box.y1 = ppt->y;
		else if(box.y2 < ppt->y) box.y2 = ppt->y;
d782 2
a783 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
	      (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a784 7
    
    (*pGC->ops->Polylines)(pDraw, pGC, mode, nptInit, pptInit);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
d791 2
a792 2
    int		nsegInit,
    xSegment	*pSegInit 
a793 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
   
d795 2
d798 2
a799 1
    if(IS_VISIBLE(pDraw) && nsegInit) {
a800 2
        xSegment *pSeg = pSegInit;
        int nseg = nsegInit;
d850 2
a851 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a852 7
    
    (*pGC->ops->PolySegment)(pDraw, pGC, nsegInit, pSegInit);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
d859 2
a860 2
    int	         nRectsInit,
    xRectangle  *pRectsInit 
a861 5
    BoxRec box;
    BoxPtr pBoxInit = NULL;
    Bool boxNotEmpty = FALSE;
    int num = 0;
    
d863 2
d866 1
a866 4
    if(IS_VISIBLE(pDraw) && nRectsInit) {
        xRectangle *pRects = pRectsInit;
        int nRects = nRectsInit;

d869 1
d897 2
a898 5
	    if(BOX_NOT_EMPTY(box)) {
                if(pPriv->preRefresh)
                   (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
                boxNotEmpty = TRUE;
            }
d900 1
a900 1
	    BoxPtr pbox;
d902 1
d956 4
a959 6
	    if(num) {
                if(pPriv->preRefresh)
                    (*pPriv->preRefresh)(pPriv->pScrn, num, pBoxInit);
            } else {
                DEALLOCATE_LOCAL(pBoxInit);
            }                
d962 1
a962 14

    (*pGC->ops->PolyRectangle)(pDraw, pGC, nRectsInit, pRectsInit);

    if(boxNotEmpty && pPriv->postRefresh) {
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    } else if(num) {
       if(pPriv->postRefresh)
          (*pPriv->postRefresh)(pPriv->pScrn, num, pBoxInit);
       DEALLOCATE_LOCAL(pBoxInit);
    }
    
    SHADOW_GC_OP_EPILOGUE(pGC);

}
d968 2
a969 2
    int		narcsInit,
    xArc	*parcsInit 
a970 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
   
d972 2
d975 3
a977 4
    if(IS_VISIBLE(pDraw) && narcsInit) {
        int narcs = narcsInit;
        xArc *parcs = parcsInit;
        int extra = pGC->lineWidth >> 1;
d1007 2
a1008 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a1009 8
    
    (*pGC->ops->PolyArc)(pDraw, pGC, narcsInit, parcsInit);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
    SHADOW_GC_OP_EPILOGUE(pGC);

a1026 1
        Bool boxNotEmpty = FALSE;
a1055 7
	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }

d1058 3
a1060 2
        if(boxNotEmpty && pPriv->postRefresh)
           (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);        
a1078 1
        Bool boxNotEmpty = FALSE;
a1099 7
	TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC);
	if(BOX_NOT_EMPTY(box)) {
            if(pPriv->preRefresh)
                (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }

d1102 3
a1104 2
        if(boxNotEmpty && pPriv->postRefresh)
            (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
d1116 2
a1117 2
    int		narcsInit,
    xArc	*parcsInit 
a1118 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
   
d1120 2
d1123 2
a1124 3
    if(IS_VISIBLE(pDraw) && narcsInit) {
        xArc *parcs = parcsInit;
        int narcs = narcsInit;
d1144 2
a1145 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a1147 90
    (*pGC->ops->PolyFillArc)(pDraw, pGC, narcsInit, parcsInit);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);       
    
    SHADOW_GC_OP_EPILOGUE(pGC);
}

static void
ShadowTextExtent(FontPtr pFont, int count, char* chars,
                 FontEncoding fontEncoding, BoxPtr box)
{
    unsigned long n, i;
    int w;
    CharInfoPtr charinfo[255];	/* encoding only has 1 byte for count */

    GetGlyphs(pFont, (unsigned long)count, (unsigned char *)chars,
	      fontEncoding, &n, charinfo);
    w = 0;
    for (i=0; i < n; i++) {
        w += charinfo[i]->metrics.characterWidth;
    }
    if (i) {
    	w += charinfo[i - 1]->metrics.rightSideBearing;
    }
    
    box->x1 = 0;
    if (n) {
	if (charinfo[0]->metrics.leftSideBearing < 0) {
            box->x1 = charinfo[0]->metrics.leftSideBearing;
        }
    }
    box->x2 = w;
    box->y1 = -FONTMAXBOUNDS(pFont,ascent);
    box->y2 = FONTMAXBOUNDS(pFont,descent);
}



static void
ShadowFontToBox(BoxPtr BB, DrawablePtr pDrawable, GCPtr pGC, int x, int y,
                int count, char *chars, int wide)
{
    FontPtr pFont;

    pFont = pGC->font;
    if (pFont->info.constantWidth) {
        int ascent, descent, left, right = 0;

	ascent = MAX(pFont->info.fontAscent, pFont->info.maxbounds.ascent);
	descent = MAX(pFont->info.fontDescent, pFont->info.maxbounds.descent);
	left = pFont->info.maxbounds.leftSideBearing;
	if (count > 0) {
	    right = (count - 1) * pFont->info.maxbounds.characterWidth;
	}
	right += pFont->info.maxbounds.rightSideBearing;
	BB->x1 =
	    MAX(pDrawable->x + x - left, (REGION_EXTENTS(pGC->pScreen,
		&((WindowPtr) pDrawable)->winSize))->x1);
	BB->y1 =
	    MAX(pDrawable->y + y - ascent,
	    (REGION_EXTENTS(pGC->pScreen,
             &((WindowPtr) pDrawable)->winSize))->y1);
	BB->x2 =
	    MIN(pDrawable->x + x + right,
	    (REGION_EXTENTS(pGC->pScreen,
             &((WindowPtr) pDrawable)->winSize))->x2);
	BB->y2 =
	    MIN(pDrawable->y + y + descent,
	    (REGION_EXTENTS(pGC->pScreen,
             &((WindowPtr) pDrawable)->winSize))->y2);
    } else {
    	ShadowTextExtent(pFont, count, chars, wide ? (FONTLASTROW(pFont) == 0)
                         ? Linear16Bit : TwoD16Bit : Linear8Bit, BB);
	BB->x1 =
	    MAX(pDrawable->x + x + BB->x1, (REGION_EXTENTS(pGC->pScreen,
		&((WindowPtr) pDrawable)->winSize))->x1);
	BB->y1 =
	    MAX(pDrawable->y + y + BB->y1,
	    (REGION_EXTENTS(pGC->pScreen,
             &((WindowPtr) pDrawable)->winSize))->y1);
	BB->x2 =
	    MIN(pDrawable->x + x + BB->x2,
	    (REGION_EXTENTS(pGC->pScreen,
	     &((WindowPtr) pDrawable)->winSize))->x2);
	BB->y2 =
	    MIN(pDrawable->y + y + BB->y2,
	    (REGION_EXTENTS(pGC->pScreen, 
	     &((WindowPtr) pDrawable)->winSize))->y2);
    }
d1160 1
a1160 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
    
d1162 7
d1170 15
a1184 9
    if(IS_VISIBLE(pDraw)) {
        ShadowFontToBox(&box, pDraw, pGC, x, y, count, chars, 0);
       
        TRIM_BOX(box, pGC);
        if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a1185 2
    
    width = (*pGC->ops->PolyText8)(pDraw, pGC, x, y, count, chars);
d1187 1
a1187 6
    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
    SHADOW_GC_OP_EPILOGUE(pGC);

    return width;
a1199 2
    BoxRec box;
    Bool boxNotEmpty = FALSE;
d1202 2
d1205 8
a1212 10
    if(IS_VISIBLE(pDraw)) {
        ShadowFontToBox(&box, pDraw, pGC, x, y, count, (char*)chars, 1);
       
        TRIM_BOX(box, pGC);
        if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
    }
d1214 4
a1217 1
    width = (*pGC->ops->PolyText16)(pDraw, pGC, x, y, count, chars);
d1219 2
a1220 2
    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
d1222 4
a1225 1
    SHADOW_GC_OP_EPILOGUE(pGC);
d1227 1
a1227 1
    return width;
a1238 2
    BoxRec box;
    Bool boxNotEmpty = FALSE;
d1240 2
d1245 1
d1265 2
a1266 5
	if(BOX_NOT_EMPTY(box)) {
            if(pPriv->preRefresh) 
               (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
            boxNotEmpty = TRUE;
        }
a1267 7
    
    (*pGC->ops->ImageText8)(pDraw, pGC, x, y, count, chars);

    if(boxNotEmpty && pPriv->postRefresh)
        (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);
    
    SHADOW_GC_OP_EPILOGUE(pGC);
a1277 2
    BoxRec box;
    Bool boxNotEmpty = FALSE;
d1279 2
d1284 1
d1304 2
a1305 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a1306 7
    
    (*pGC->ops->ImageText16)(pDraw, pGC, x, y, count, chars);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);   
    
    SHADOW_GC_OP_EPILOGUE(pGC);
d1315 2
a1316 2
    unsigned int nglyphInit,
    CharInfoPtr *ppciInit,
a1318 2
    BoxRec box;
    Bool boxNotEmpty = FALSE;
d1320 3
d1324 1
a1324 3
    if(IS_VISIBLE(pDraw) && nglyphInit) {
        CharInfoPtr *ppci = ppciInit;
        unsigned int nglyph = nglyphInit;
d1326 1
d1354 2
a1355 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a1356 8

    (*pGC->ops->ImageGlyphBlt)(pDraw, pGC, x, y, nglyphInit, 
					ppciInit, pglyphBase);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
d1364 2
a1365 2
    unsigned int nglyphInit,
    CharInfoPtr *ppciInit,
a1367 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;

d1369 3
d1373 2
a1374 3
    if(IS_VISIBLE(pDraw) && nglyphInit) {
        CharInfoPtr *ppci = ppciInit;
        unsigned int nglyph = nglyphInit;
d1396 2
a1397 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a1398 8
    
    (*pGC->ops->PolyGlyphBlt)(pDraw, pGC, x, y, nglyphInit, 
				ppciInit, pglyphBase);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
a1407 3
    BoxRec box;
    Bool boxNotEmpty = FALSE;
    
d1409 2
d1413 2
d1421 2
a1422 5
	if(BOX_NOT_EMPTY(box)) {
           if(pPriv->preRefresh)
              (*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
           boxNotEmpty = TRUE;
        }
a1423 7

    (*pGC->ops->PushPixels)(pGC, pBitMap, pDraw, dx, dy, xOrg, yOrg);

    if(boxNotEmpty && pPriv->postRefresh)
       (*pPriv->postRefresh)(pPriv->pScrn, 1, &box);

    SHADOW_GC_OP_EPILOGUE(pGC);
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d9 1
a9 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/shadowfb/shadow.c,v 1.21 2003/11/10 18:22:38 tsi Exp $ */
d375 1
a375 1
        REGION_NULL(pWin->drawable.pScreen, &rgnDst);
a463 1
    BoxPtr extents;
d466 5
d472 4
a475 18
	&& pDst->pDrawable->type == DRAWABLE_WINDOW) {

	box.x1 = pDst->pDrawable->x + xDst;
	box.y1 = pDst->pDrawable->y + yDst;
	box.x2 = box.x1 + width;
	box.y2 = box.y1 + height;

	extents = &pDst->pCompositeClip->extents;
	if(box.x1 < extents->x1) box.x1 = extents->x1;
	if(box.x2 > extents->x2) box.x2 = extents->x2;
	if(box.y1 < extents->y1) box.y1 = extents->y1;
	if(box.y2 > extents->y2) box.y2 = extents->y2;
	
	if (BOX_NOT_EMPTY(box)) {
	    if (pPriv->preRefresh)
		(*pPriv->preRefresh)(pPriv->pScrn, 1, &box);
	    boxNotEmpty = TRUE;
	}
d639 1
a639 5

        if(!pGC->miTranslate) {
           TRANSLATE_BOX(box, pDraw);
        }
        TRIM_BOX(box, pGC); 
d691 1
a691 5

        if(!pGC->miTranslate) {
           TRANSLATE_BOX(box, pDraw);
        }
        TRIM_BOX(box, pGC);
d1772 1
a1772 8
	box.x1 = xOrg;
	box.y1 = yOrg;

        if(!pGC->miTranslate) {
           box.x1 += pDraw->x;          
           box.y1 += pDraw->y;          
        }

d1774 1
@


