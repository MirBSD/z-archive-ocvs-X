head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407221130:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.08.30;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.08.30;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.37.24;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.24.10;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.24.59;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/elfloader.c,v 1.40 2002/01/14 18:16:52 dawes Exp $ */

/*
 *
 * Copyright 1995-1998 by Metro Link, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Metro Link, Inc. not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Metro Link, Inc. makes no
 * representations about the suitability of this software for any purpose.
 *  It is provided "as is" without express or implied warranty.
 *
 * METRO LINK, INC. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL METRO LINK, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>
#include <sys/mman.h>
#include <unistd.h>
#include <stdlib.h>
#ifdef __QNX__
#include <fcntl.h>
#else
#include <sys/fcntl.h>
#endif
#include <sys/stat.h>

#ifdef DBMALLOC
#include <debug/malloc.h>
#define Xalloc(size) malloc(size)
#define Xcalloc(size) calloc(1,(size))
#define Xfree(size) free(size)
#endif

#include "Xos.h"
#include "os.h"
#include "elf.h"

#include "sym.h"
#include "loader.h"

#include "compiler.h"

/*
#ifndef LDTEST
#define ELFDEBUG ErrorF
#endif
*/

#ifndef UseMMAP
#if defined (__ia64__) || defined (__sparc__)
#define MergeSectionAlloc
#endif
#endif

#if defined (__alpha__) || \
    defined (__ia64__) || \
    (defined (__sparc__) && \
     (defined (__arch64__) || \
      defined (__sparcv9)))
typedef Elf64_Ehdr Elf_Ehdr;
typedef Elf64_Shdr Elf_Shdr;
typedef Elf64_Sym Elf_Sym;
typedef Elf64_Rel Elf_Rel;
typedef Elf64_Rela Elf_Rela;
typedef Elf64_Addr Elf_Addr;
typedef Elf64_Half Elf_Half;
typedef Elf64_Off Elf_Off;
typedef Elf64_Sword Elf_Sword;
typedef Elf64_Word Elf_Word;
#define ELF_ST_BIND ELF64_ST_BIND
#define ELF_ST_TYPE ELF64_ST_TYPE
#define ELF_R_SYM ELF64_R_SYM
#define ELF_R_TYPE ELF64_R_TYPE

#if defined (__alpha__) || defined (__ia64__)
/*
 * The GOT is allocated dynamically. We need to keep a list of entries that
 * have already been added to the GOT. 
 *
 */
typedef struct _elf_GOT_Entry {
	Elf_Rela   *rel;
        int	offset;
	struct _elf_GOT_Entry *next;
} ELFGotEntryRec, *ELFGotEntryPtr;

typedef struct _elf_GOT {
	unsigned int	size;
	unsigned int	nuses;
	unsigned char	*freeptr;
	struct _elf_GOT	*next;
	unsigned char	section[1];
} ELFGotRec, *ELFGotPtr;

#ifdef MergeSectionAlloc
static ELFGotPtr ELFSharedGOTs;
#endif
#endif

#if defined (__ia64__)
/*
 * The PLT is allocated dynamically. We need to keep a list of entries that
 * have already been added to the PLT. 
 */
typedef struct _elf_PLT_Entry {
	Elf_Rela   *rel;
        int	offset;
	int	gotoffset;
	struct _elf_PLT_Entry *next;
} ELFPltEntryRec, *ELFPltEntryPtr;

/*
 * The OPD is allocated dynamically within the GOT. We need to keep a list
 * of entries that have already been added to the OPD.
 */
typedef struct _elf_OPD {
	LOOKUP	*l;
	int	index;
        int	offset;
	struct _elf_OPD *next;
} ELFOpdRec, *ELFOpdPtr;
#endif

#else
typedef Elf32_Ehdr Elf_Ehdr;
typedef Elf32_Shdr Elf_Shdr;
typedef Elf32_Sym Elf_Sym;
typedef Elf32_Rel Elf_Rel;
typedef Elf32_Rela Elf_Rela;
typedef Elf32_Addr Elf_Addr;
typedef Elf32_Half Elf_Half;
typedef Elf32_Off Elf_Off;
typedef Elf32_Sword Elf_Sword;
typedef Elf32_Word Elf_Word;
#define ELF_ST_BIND ELF32_ST_BIND
#define ELF_ST_TYPE ELF32_ST_TYPE
#define ELF_R_SYM ELF32_R_SYM
#define ELF_R_TYPE ELF32_R_TYPE
#endif

#if defined(__powerpc__) || \
    defined(__mc68000__) || \
    defined(__alpha__) || \
    defined(__sparc__) || \
    defined(__ia64__)
typedef Elf_Rela Elf_Rel_t;
#else
typedef Elf_Rel  Elf_Rel_t;
#endif

/*
 * This structure contains all of the information about a module
 * that has been loaded.
 */

typedef	struct {
	int	handle;
	int	module;
	int	fd;
	loader_funcs	*funcs;
	Elf_Ehdr 	*header;/* file header */
	int	numsh;
	Elf_Shdr	*sections;/* Address of the section header table */
	int	secsize;	/* size of the section table */
	unsigned char	**saddr;/* Start addresss of the section pointer table */
	unsigned char	*shstraddr; /* Start address of the section header string table */
	int	shstrndx;	/* index of the section header string table */
	int	shstrsize;	/* size of the section header string table */
	unsigned char *straddr;	/* Start address of the string table */
	int	strndx;		/* index of the string table */
	int	strsize;	/* size of the string table */
	unsigned char *text;	/* Start address of the .text section */
	int	txtndx;		/* index of the .text section */
	int	txtsize;	/* size of the .text section */
	unsigned char *data;	/* Start address of the .data section */
	int	datndx;		/* index of the .data section */
	int	datsize;	/* size of the .data section */
	unsigned char *data1;	/* Start address of the .data1 section */
	int	dat1ndx;	/* index of the .data1 section */
	int	dat1size;	/* size of the .data1 section */
	unsigned char *sdata;	/* Start address of the .sdata section */
	int	sdatndx;	/* index of the .sdata section */
	int	sdatsize;	/* size of the .sdata section */
	unsigned char *bss;	/* Start address of the .bss section */
	int	bssndx;		/* index of the .bss section */
	int	bsssize;	/* size of the .bss section */
	unsigned char *sbss;	/* Start address of the .sbss section */
	int	sbssndx;        /* index of the .sbss section */
	int	sbsssize;	/* size of the .sbss section */
	unsigned char *rodata;	/* Start address of the .rodata section */
	int	rodatndx;	/* index of the .rodata section */
	int	rodatsize;	/* size of the .rodata section */
	unsigned char *rodata1;	/* Start address of the .rodata section */
	int	rodat1ndx;	/* index of the .rodata section */
	int	rodat1size;	/* size of the .rodata section */
#if defined(__alpha__) || defined(__ia64__)
	unsigned char *got;     /* Start address of the .got section */
	ELFGotEntryPtr got_entries;  /* List of entries in the .got section */
	int     gotndx;         /* index of the .got section */
	int     gotsize;        /* actual size of the .got section */
	ELFGotPtr shared_got;	/* Pointer to ELFGotRec if shared */
#endif
#if defined(__ia64__)
	ELFOpdPtr opd_entries;  /* List of entries in the .opd section */
	unsigned char *plt;     /* Start address of the .plt section */
	ELFPltEntryPtr plt_entries;  /* List of entries in the .plt section */
	int     pltndx;         /* index of the .plt section */
	int     pltsize;        /* size of the .plt section */
#endif
	Elf_Sym *symtab;	/* Start address of the .symtab section */
	int	symndx;		/* index of the .symtab section */
	int	symsize;	/* size of the .symtab section */
	unsigned char *reltext;	/* Start address of the .rel.text section */
	int	reltxtndx;	/* index of the .rel.text section */
	int	reltxtsize;	/* size of the .rel.text section */
	unsigned char *reldata;	/* Start address of the .rel.data section */
	int	reldatndx;	/* index of the .rel.data section */
	int	reldatsize;	/* size of the .rel.data section */
	unsigned char *relsdata;/* Start address of the .rel.sdata section */
	int	relsdatndx;	/* index of the .rel.sdata section */
	int	relsdatsize;	/* size of the .rel.sdata section */
	unsigned char *relrodata;/* Start address of the .rel.rodata section */
	int	relrodatndx;	/* index of the .rel.rodata section */
	int	relrodatsize;	/* size of the .rel.rodata section */
	unsigned char *common;	/* Start address of the SHN_COMMON space */
	int	comsize;	/* size of the SHN_COMMON space */

	unsigned char *base;	/* Alloced address of section block */
	unsigned long baseptr;	/* Pointer to next free space in base */
	int	basesize;	/* Size of that allocation */
	}	ELFModuleRec, *ELFModulePtr;

/*
 * If a relocation is unable to be satisfied, then put it on a list
 * to try later after more modules have been loaded.
 */
typedef struct _elf_reloc {
	Elf_Rel_t	*rel;
	ELFModulePtr	file;
	Elf_Word	secn;
	struct _elf_reloc	*next;
} ELFRelocRec;

/*
 * symbols with a st_shndx of COMMON need to have space allocated for them.
 *
 * Gather all of these symbols together, and allocate one chunk when we
 * are done.
 */
typedef struct _elf_COMMON {
	Elf_Sym	   *sym;
	struct _elf_COMMON *next;
} ELFCommonRec;

static	ELFCommonPtr listCOMMON=NULL;

/* Prototypes for static functions */
static int ELFhashCleanOut(void *, itemPtr);
static char *ElfGetStringIndex(ELFModulePtr, int, int);
static char *ElfGetString(ELFModulePtr, int);
static char *ElfGetSectionName(ELFModulePtr, int);
static ELFRelocPtr ElfDelayRelocation(ELFModulePtr, Elf_Word, Elf_Rel_t *);
static ELFCommonPtr ElfAddCOMMON(Elf_Sym *);
static int ElfCOMMONSize(void);
static int ElfCreateCOMMON(ELFModulePtr,LOOKUP *);
static char *ElfGetSymbolNameIndex(ELFModulePtr, int, int);
static char *ElfGetSymbolName(ELFModulePtr, int);
static Elf_Addr ElfGetSymbolValue(ELFModulePtr, int);
static ELFRelocPtr Elf_RelocateEntry(ELFModulePtr, Elf_Word, Elf_Rel_t *, int);
static ELFRelocPtr ELFCollectRelocations(ELFModulePtr, int);
static LOOKUP *ELF_GetSymbols(ELFModulePtr, unsigned short **);
static void ELFCollectSections(ELFModulePtr, int, int *, int *);
#if defined(__alpha__) || defined(__ia64__)
static void ElfAddGOT(ELFModulePtr, Elf_Rel_t *);
static int ELFCreateGOT(ELFModulePtr, int);
#endif
#if defined(__ia64__)
static void ElfAddOPD(ELFModulePtr, int, LOOKUP *);
static void ELFCreateOPD(ELFModulePtr);
static void ElfAddPLT(ELFModulePtr, Elf_Rel_t *);
static void ELFCreatePLT(ELFModulePtr);
enum ia64_operand {
    IA64_OPND_IMM22,
    IA64_OPND_TGT25C
};
static void IA64InstallReloc(unsigned long *, int, enum ia64_operand, long);
#endif

#ifdef MergeSectionAlloc
static void *
ELFLoaderSectToMem(elffile, align, offset, size, label)
ELFModulePtr	elffile;
int		align;
unsigned long	offset;
int		size;
char		*label;
{
    void *ret;
    elffile->baseptr = (elffile->baseptr + align - 1) & ~(align - 1);
    ret = (void *)elffile->baseptr;
    _LoaderFileRead(elffile->fd, offset, ret, size);
    elffile->baseptr += size;
    return ret;
}

static void *
ELFLoaderSectCalloc(elffile, align, size)
ELFModulePtr	elffile;
int		align;
int		size;
{
    void *ret;
    elffile->baseptr = (elffile->baseptr + align - 1) & ~(align - 1);
    ret = (void *)elffile->baseptr;
    elffile->baseptr += size;
    memset(ret, 0, size);
    return ret;
}
#else
#define ELFLoaderSectToMem(elffile,align,offset,size,label)	\
_LoaderFileToMem((elffile)->fd,offset,size,label)
#define ELFLoaderSectCalloc(elffile,align,size) xf86loadercalloc(1,size)
#endif

/*
 * Utility Functions
 */


static int
ELFhashCleanOut(voidptr, item)
void *voidptr;
itemPtr item ;
{
    ELFModulePtr module = (ELFModulePtr) voidptr;
    return (module->handle == item->handle);
}

/*
 * Manage listResolv
 */
static ELFRelocPtr
ElfDelayRelocation(elffile, secn, rel)
ELFModulePtr	elffile;
Elf_Word	secn;
Elf_Rel_t	*rel;
{
    ELFRelocPtr	reloc;

    if ((reloc = xf86loadermalloc(sizeof(ELFRelocRec))) == NULL) {
	ErrorF( "ElfDelayRelocation() Unable to allocate memory!!!!\n" );
	return 0;
    }
    reloc->file=elffile;
    reloc->secn=secn;
    reloc->rel=rel;
    reloc->next=0;
#ifdef ELFDEBUG
    ELFDEBUG("ElfDelayRelocation %lx: file %lx, sec %d,"
	     " r_offset 0x%lx, r_info 0x%x",
	     reloc, elffile, secn, rel->r_offset, rel->r_info);
#if defined(__powerpc__) || \
    defined(__mc68000__) || \
    defined(__alpha__) || \
    defined(__sparc__) || \
    defined(__ia64__)
    ELFDEBUG(", r_addend 0x%lx", rel->r_addend);
#endif
    ELFDEBUG("\n");
#endif
    return reloc;
}

/*
 * Manage listCOMMON
 */
static ELFCommonPtr
ElfAddCOMMON(sym)
Elf_Sym	*sym;
{
    ELFCommonPtr common;

    if ((common = xf86loadermalloc(sizeof(ELFCommonRec))) == NULL) {
	ErrorF( "ElfAddCOMMON() Unable to allocate memory!!!!\n" );
	return 0;
    }
    common->sym=sym;
    common->next=0;
    return common;
}

static int
ElfCOMMONSize(void)
{
    int	size=0;
    ELFCommonPtr common;

    for (common = listCOMMON; common; common = common->next) {
	size+=common->sym->st_size;
#if defined(__alpha__) || \
    defined(__ia64__) || \
    (defined(__sparc__) && \
     (defined(__arch64__) || \
      defined(__sparcv9)))
	size = (size+7)&~0x7;
#endif
    }
    return size;
}

static int
ElfCreateCOMMON(elffile,pLookup)
ELFModulePtr	elffile;
LOOKUP		*pLookup;
{
    int	numsyms=0,size=0,l=0;
    int	offset=0,firstcommon=0;
    ELFCommonPtr common;

    if (listCOMMON == NULL)
	return TRUE;

    for (common = listCOMMON; common; common = common->next) {
	size+=common->sym->st_size;
#if defined(__alpha__) || \
    defined(__ia64__) || \
    (defined(__sparc__) && \
     (defined(__arch64__) || \
      defined(__sparcv9)))
	size = (size+7)&~0x7;
#endif
	numsyms++;
    }

#ifdef ELFDEBUG
    ELFDEBUG("ElfCreateCOMMON() %d entries (%d bytes) of COMMON data\n",
	     numsyms, size );
#endif

    elffile->comsize=size;
    if((elffile->common = ELFLoaderSectCalloc(elffile,8,size)) == NULL) {
	ErrorF( "ElfCreateCOMMON() Unable to allocate memory!!!!\n" );
	return FALSE;
    }

    if (DebuggerPresent)
    {
	ldrCommons = xf86loadermalloc(numsyms*sizeof(LDRCommon));
	nCommons = numsyms;
    }

    for (l = 0; pLookup[l].symName; l++)
	;
    firstcommon=l;
    
    /* Traverse the common list and create a lookup table with all the
     * common symbols.  Destroy the common list in the process.
     * See also ResolveSymbols.
     */
    while(listCOMMON) {
	common=listCOMMON;
	/* this is xstrdup because is should be more efficient. it is freed
	 * with xf86loaderfree
	 */
	pLookup[l].symName =
	    xf86loaderstrdup(ElfGetString(elffile,common->sym->st_name));
	pLookup[l].offset = (funcptr)(elffile->common + offset);
#ifdef ELFDEBUG
	ELFDEBUG("Adding common %lx %s\n",
		 pLookup[l].offset, pLookup[l].symName);
#endif
	
	/* Record the symbol address for gdb */
	if (DebuggerPresent && ldrCommons)
	{
	     ldrCommons[l-firstcommon].addr = (void *)pLookup[l].offset;
	     ldrCommons[l-firstcommon].name = pLookup[l].symName;
	     ldrCommons[l-firstcommon].namelen = strlen(pLookup[l].symName);
	}
	listCOMMON=common->next;
	offset+=common->sym->st_size;
#if defined(__alpha__) || \
    defined(__ia64__) || \
    (defined(__sparc__) && \
     (defined(__arch64__) || \
      defined(__sparcv9)))
	offset = (offset+7)&~0x7;  
#endif
	xf86loaderfree(common);
	l++;
    }
    /* listCOMMON == 0 */
    pLookup[l].symName=NULL; /* Terminate the list. */
    return TRUE;
}


/*
 * String Table
 */
static char *
ElfGetStringIndex(file, offset, index)
ELFModulePtr	file;
int offset;
int index;
{
    if( !offset || !index )
        return "";

    return (char *)(file->saddr[index]+offset);
}

static char *
ElfGetString(file, offset)
ELFModulePtr	file;
int offset;
{
    return ElfGetStringIndex( file, offset, file->strndx );
}

static char *
ElfGetSectionName(file, offset)
ELFModulePtr	file;
int offset;
{
    return (char *)(file->shstraddr+offset);
}



/*
 * Symbol Table
 */

/*
 * Get symbol name
 */
static char *
ElfGetSymbolNameIndex(elffile, index, secndx)
ELFModulePtr	elffile;
int index;
int secndx;
{
    Elf_Sym	*syms;

#ifdef ELFDEBUG
    ELFDEBUG("ElfGetSymbolNameIndex(%x,%x) ",index, secndx );
#endif

    syms=(Elf_Sym *)elffile->saddr[secndx];

#ifdef ELFDEBUG
    ELFDEBUG("%s ",ElfGetString(elffile, syms[index].st_name));
    ELFDEBUG("%x %x ",ELF_ST_BIND(syms[index].st_info),
	     ELF_ST_TYPE(syms[index].st_info));
    ELFDEBUG("%lx\n",syms[index].st_value);
#endif

    return ElfGetString(elffile,syms[index].st_name );
}

static char *
ElfGetSymbolName(elffile, index)
ELFModulePtr	elffile;
int index;
{
    return ElfGetSymbolNameIndex(elffile, index, elffile->symndx);
}

static Elf_Addr
ElfGetSymbolValue(elffile, index)
ELFModulePtr	elffile;
int index;
{
    Elf_Sym	*syms;
    Elf_Addr symval=0;	/* value of the indicated symbol */
    char *symname = NULL;		/* name of symbol in relocation */
    itemPtr symbol = NULL;		/* name/value of symbol */

    syms=(Elf_Sym *)elffile->saddr[elffile->symndx];

    switch( ELF_ST_TYPE(syms[index].st_info) )
	{
	case STT_NOTYPE:
	case STT_OBJECT:
	case STT_FUNC:
	    switch( ELF_ST_BIND(syms[index].st_info) )
		{
		case STB_LOCAL:
		    symval=(Elf_Addr)(
					elffile->saddr[syms[index].st_shndx]+
					syms[index].st_value);
#ifdef __ia64__
		    if( ELF_ST_TYPE(syms[index].st_info) == STT_FUNC ) {
			ELFOpdPtr opdent;
			for (opdent = elffile->opd_entries; opdent; opdent = opdent->next)
			    if (opdent->index == index)
				break;
			if(opdent) {
			    ((unsigned long *)(elffile->got+opdent->offset))[0] = symval;
			    ((unsigned long *)(elffile->got+opdent->offset))[1] = (long)elffile->got;
			    symval = (Elf_Addr)(elffile->got+opdent->offset);
			} 
		    }
#endif
		    break;
		case STB_GLOBAL:
		case STB_WEAK: /* STB_WEAK seems like a hack to cover for
					some other problem */
		    symname=
			ElfGetString(elffile,syms[index].st_name);
		    symbol = LoaderHashFind(symname);
		    if( symbol == 0 ) {
			return 0;
			}
		    symval=(Elf_Addr)symbol->address;
		    break;
		default:
		    symval=0;
		    ErrorF(
			   "ElfGetSymbolValue(), unhandled symbol scope %x\n",
			   ELF_ST_BIND(syms[index].st_info) );
		    break;
		}
#ifdef ELFDEBUG
	    ELFDEBUG( "%lx\t", symbol );
	    ELFDEBUG( "%lx\t", symval );
	    ELFDEBUG( "%s\n", symname ? symname : "NULL");
#endif
	    break;
	case STT_SECTION:
	    symval=(Elf_Addr)elffile->saddr[syms[index].st_shndx];
#ifdef ELFDEBUG
	    ELFDEBUG( "ST_SECTION %lx\n", symval );
#endif
	    break;
	case STT_FILE:
	case STT_LOPROC:
	case STT_HIPROC:
	default:
	    symval=0;
	    ErrorF( "ElfGetSymbolValue(), unhandled symbol type %x\n",
		    ELF_ST_TYPE(syms[index].st_info) );
	    break;
	}
    return symval;
}

#if defined(__powerpc__)
/*
 * This function returns the address of a pseudo PLT routine which can
 * be used to compute a function offset. This is needed because loaded
 * modules have an offset from the .text section of greater than 24 bits.
 * The code generated makes the assumption that all function entry points
 * will be within a 24 bit offset (non-PIC code).
 */
static Elf_Addr
ElfGetPltAddr(elffile, index)
ELFModulePtr	elffile;
int index;
{
    Elf_Sym	*syms;
    Elf_Addr symval=0;	/* value of the indicated symbol */
    char *symname = NULL;	/* name of symbol in relocation */
    itemPtr symbol;		/* name/value of symbol */

    syms=(Elf_Sym *)elffile->saddr[elffile->symndx];

    switch( ELF_ST_TYPE(syms[index].st_info) )
	{
	case STT_NOTYPE:
	case STT_OBJECT:
	case STT_FUNC:
	    switch( ELF_ST_BIND(syms[index].st_info) )
		{
		case STB_GLOBAL:
		    symname=
			ElfGetString(elffile,syms[index].st_name);
		    symbol=LoaderHashFind(symname);
		    if( symbol == 0 )
			return 0;
/*
 * Here we are building up a pseudo Plt function that can make a call to
 * a function that has an offset greater than 24 bits. The following code
 * is being used to implement this.

     1  00000000                                .extern realfunc
     2  00000000                                .global pltfunc
     3  00000000                        pltfunc:
     4  00000000  3d 80 00 00                   lis     r12,hi16(realfunc)
     5  00000004  61 8c 00 00                   ori     r12,r12,lo16(realfunc)
     6  00000008  7d 89 03 a6                   mtctr   r12
     7  0000000c  4e 80 04 20                   bctr

 */

		    symbol->code.plt[0]=0x3d80; /* lis     r12 */
		    symbol->code.plt[1]=(((Elf_Addr)symbol->address)&0xffff0000)>>16;
		    symbol->code.plt[2]=0x618c; /* ori     r12,r12 */
		    symbol->code.plt[3]=(((Elf_Addr)symbol->address)&0xffff);
		    symbol->code.plt[4]=0x7d89; /* mtcr    r12 */
		    symbol->code.plt[5]=0x03a6;
		    symbol->code.plt[6]=0x4e80; /* bctr */
		    symbol->code.plt[7]=0x0420;
		    symbol->address=(char *)&symbol->code.plt[0];
		    symval=(Elf_Addr)symbol->address;
		    ppc_flush_icache(&symbol->code.plt[0]);
		    ppc_flush_icache(&symbol->code.plt[6]);
		    break;
		default:
		    symval=0;
		    ErrorF(
			   "ElfGetPltAddr(), unhandled symbol scope %x\n",
			   ELF_ST_BIND(syms[index].st_info) );
		    break;
		}
#ifdef ELFDEBUG
	    ELFDEBUG( "ElfGetPlt: symbol=%lx\t", symbol );
	    ELFDEBUG( "newval=%lx\t", symval );
	    ELFDEBUG( "name=\"%s\"\n", symname ? symname : "NULL");
#endif
	    break;
	case STT_SECTION:
	case STT_FILE:
	case STT_LOPROC:
	case STT_HIPROC:
	default:
	    symval=0;
	    ErrorF( "ElfGetPltAddr(), Unexpected symbol type %x",
		    ELF_ST_TYPE(syms[index].st_info) );
	    ErrorF( "for a Plt request\n" );
	    break;
	}
    return symval;
}
#endif /* __powerpc__ */

#if defined(__alpha__) || defined(__ia64__)
/*
 * Manage GOT Entries
 */
static void
ElfAddGOT(elffile,rel)
ELFModulePtr	elffile;
Elf_Rel_t	*rel;
{
    ELFGotEntryPtr gotent;

#ifdef ELFDEBUG
    {
    Elf_Sym *sym;

    sym=(Elf_Sym *)&(elffile->symtab[ELF_R_SYM(rel->r_info)]);
    if( sym->st_name) {
	ELFDEBUG("ElfAddGOT: Adding GOT entry for %s\n", 
	    ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	}
    else
	ELFDEBUG("ElfAddGOT: Adding GOT entry for %s\n", 
	   ElfGetSectionName(elffile,elffile->sections[sym->st_shndx].sh_name));
    }
#endif

    for (gotent=elffile->got_entries;gotent;gotent=gotent->next) {
	if ( ELF_R_SYM(gotent->rel->r_info) == ELF_R_SYM(rel->r_info) &&
	     gotent->rel->r_addend == rel->r_addend )
		break;
    }

    if( gotent ) {
#ifdef ELFDEBUG
	ELFDEBUG("Entry already present in GOT\n");
#endif
	return;
    }

    if ((gotent = xf86loadermalloc(sizeof(ELFGotEntryRec))) == NULL) {
	ErrorF( "ElfAddGOT() Unable to allocate memory!!!!\n" );
	return;
    }

#ifdef ELFDEBUG
    ELFDEBUG("Entry added with offset %x\n",elffile->gotsize);
#endif
    gotent->rel=rel;
    gotent->offset=elffile->gotsize;
    gotent->next=elffile->got_entries;
    elffile->got_entries=gotent;
    elffile->gotsize+=8;
    return;
}

static int
ELFCreateGOT(elffile, maxalign)
ELFModulePtr	elffile;
int		maxalign;
{
#ifdef MergeSectionAlloc
    ELFGotPtr gots;
#endif
    int gotsize;

    /*
     * XXX:  Is it REALLY needed to ensure GOT's are non-null?
     */
#ifdef ELFDEBUG
    ELFDEBUG( "ELFCreateGOT: %x entries in the GOT\n", elffile->gotsize/8 );

    /*
     * Hmmm. Someone is getting here without any got entries, but they
     * may still have R_ALPHA_GPDISP relocations against the got.
     */
    if( elffile->gotsize == 0 ) 
	ELFDEBUG( "Module %s doesn't have any GOT entries!\n",
		_LoaderModuleToName(elffile->module) );
#endif
    if( elffile->gotsize == 0 ) elffile->gotsize=8;
    elffile->sections[elffile->gotndx].sh_size=elffile->gotsize;
    gotsize = elffile->gotsize;

#ifdef MergeSectionAlloc
#ifdef __alpha__
#define GOTDistance 0x100000
#endif
#ifdef __ia64__
#define GOTDistance 0x200000
#endif
    for (gots = ELFSharedGOTs; gots; gots = gots->next) {
	if (gots->freeptr + elffile->gotsize > gots->section + gots->size)
	    continue;
	if (gots->section > elffile->base) {
	    if (gots->section + gots->size - elffile->base >= GOTDistance)
		continue;
	} else {
	    if (elffile->base + elffile->basesize - gots->section >= GOTDistance)
		continue;
	}
	elffile->got = gots->freeptr;
	elffile->shared_got = gots;
	gots->freeptr = gots->freeptr + elffile->gotsize;
	gots->nuses++;
#ifdef ELFDEBUG
	ELFDEBUG( "ELFCreateGOT: GOT address %lx in shared GOT, nuses %d\n",
		  elffile->got, gots->nuses );
#endif
	return TRUE;
    }

    gotsize += 16383 + sizeof(ELFGotRec);
#endif

    if ((elffile->got = xf86loadermalloc(gotsize)) == NULL) {
	ErrorF( "ELFCreateGOT() Unable to allocate memory!!!!\n" );
	return FALSE;
    }

#ifdef MergeSectionAlloc
    if (elffile->got > elffile->base) {
	if (elffile->got + elffile->gotsize - elffile->base >= GOTDistance)
	    gotsize = 0;
    } else {
	if (elffile->base + elffile->basesize - elffile->got >= GOTDistance)
	    gotsize = 0;
    }

    if (!gotsize) {
	xf86loaderfree(elffile->got);
	elffile->basesize += 8 + elffile->gotsize;
	elffile->base = xf86loaderrealloc(elffile->base, elffile->basesize);
	if (elffile->base == NULL) {
	    ErrorF( "ELFCreateGOT() Unable to reallocate memory!!!!\n" );
	    return FALSE;
	}
	mprotect(elffile->base, elffile->basesize, PROT_READ|PROT_WRITE|PROT_EXEC);
	
	elffile->baseptr = ((long)elffile->base + (maxalign - 1)) & ~(maxalign - 1);
	elffile->got = (unsigned char *)((long)(elffile->base + elffile->basesize - elffile->gotsize) & ~7);
    } else {
	gots = (ELFGotPtr)elffile->got;
	elffile->got = gots->section;
	gots->size = gotsize - sizeof(ELFGotRec) + 1;
	gots->nuses = 1;
	gots->freeptr = gots->section + elffile->gotsize;
	gots->next = ELFSharedGOTs;
	ELFSharedGOTs = gots;
	elffile->shared_got = gots;
#ifdef ELFDEBUG
        ELFDEBUG( "ELFCreateGOT: Created a shareable GOT with size %d\n", gots->size);
#endif
    }
#endif

#ifdef ELFDEBUG
    ELFDEBUG( "ELFCreateGOT: GOT address %lx\n", elffile->got );
#endif

    return TRUE;
}
#endif

#if defined(__ia64__)
/*
 * Manage OPD Entries
 */
static void
ElfAddOPD(elffile,index,l)
ELFModulePtr	elffile;
int		index;
LOOKUP		*l;
{
    ELFOpdPtr opdent;

    if (index != -1) {
	for (opdent = elffile->opd_entries; opdent; opdent = opdent->next)
	    if (opdent->index == index)
		return;
    }

    if ((opdent = xf86loadermalloc(sizeof(ELFOpdRec))) == NULL) {
	ErrorF( "ElfAddOPD() Unable to allocate memory!!!!\n" );
	return;
    }

#ifdef ELFDEBUG
    ELFDEBUG("OPD Entry %d added with offset %x\n",index,elffile->gotsize);
#endif
    opdent->l=l;
    opdent->index=index;
    opdent->offset=elffile->gotsize;
    opdent->next=elffile->opd_entries;
    elffile->opd_entries=opdent;
    elffile->gotsize+=16;
    return ;
}

static void
ELFCreateOPD(elffile)
ELFModulePtr	elffile;
{
    ELFOpdPtr opdent;

    if (elffile->got == NULL)
	ErrorF( "ELFCreateOPD() Unallocated GOT!!!!\n" );

    for (opdent = elffile->opd_entries; opdent; opdent = opdent->next) {
	if (opdent->index != -1)
	    continue;
	((unsigned long *)(elffile->got+opdent->offset))[0] = (long)opdent->l->offset;
	((unsigned long *)(elffile->got+opdent->offset))[1] = (long)elffile->got;
	opdent->l->offset = (funcptr)(elffile->got+opdent->offset);
    }
}

/*
 * Manage PLT Entries
 */
static void
ElfAddPLT(elffile,rel)
ELFModulePtr	elffile;
Elf_Rel_t	*rel;
{
    ELFPltEntryPtr pltent;

#ifdef ELFDEBUG
    {
    Elf_Sym *sym;

    sym=(Elf_Sym *)&(elffile->symtab[ELF_R_SYM(rel->r_info)]);
    if( sym->st_name) {
	ELFDEBUG("ElfAddPLT: Adding PLT entry for %s\n", 
	    ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	}
    else
	ErrorF("ElfAddPLT: Add PLT entry for section??\n");
    }
#endif

    if (rel->r_addend)
	ErrorF("ElfAddPLT: Add PLT entry with non-zero addend??\n");

    for (pltent=elffile->plt_entries;pltent;pltent=pltent->next) {
	if ( ELF_R_SYM(pltent->rel->r_info) == ELF_R_SYM(rel->r_info) )
		break;
    }

    if( pltent ) {
#ifdef ELFDEBUG
	ELFDEBUG("Entry already present in PLT\n");
#endif
	return;
    }

    if ((pltent = xf86loadermalloc(sizeof(ELFPltEntryRec))) == NULL) {
	ErrorF( "ElfAddPLT() Unable to allocate memory!!!!\n" );
	return;
    }

#ifdef ELFDEBUG
    ELFDEBUG("Entry added with offset %x\n",elffile->pltsize);
#endif
    pltent->rel=rel;
    pltent->offset=elffile->pltsize;
    pltent->gotoffset=elffile->gotsize;
    pltent->next=elffile->plt_entries;
    elffile->plt_entries=pltent;
    elffile->pltsize+=32;
    elffile->gotsize+=16;
    return ;
}

static void
ELFCreatePLT(elffile)
ELFModulePtr	elffile;
{
#ifdef ELFDEBUG
    ELFDEBUG( "ELFCreatePLT: %x entries in the PLT\n", elffile->pltsize/8 );
#endif

    if( elffile->pltsize == 0 ) return;

    if ((elffile->plt = ELFLoaderSectCalloc(elffile,32,elffile->pltsize)) == NULL) {
	ErrorF( "ELFCreatePLT() Unable to allocate memory!!!!\n" );
	return;
    }
    elffile->sections[elffile->pltndx].sh_size=elffile->pltsize;
#ifdef ELFDEBUG
    ELFDEBUG( "ELFCreatePLT: PLT address %lx\n", elffile->plt );
#endif

    return;
}

static void
IA64InstallReloc(data128, slot, opnd, value)
unsigned long		*data128;
int			slot;
enum ia64_operand	opnd;
long			value;
{
    unsigned long data = 0;

#ifdef ELFDEBUG
    ELFDEBUG( "\nIA64InstallReloc %p %d %d %016lx\n", data128, slot, opnd, value);
    ELFDEBUG( "Before [%016lx%016lx]\n", data128[1], data128[0]);
#endif
    switch (slot) {
    case 0: data = *data128; break;
    case 1: memcpy(&data, (char *)data128 + 5, 8); break;
    case 2: memcpy(&data, (char *)data128 + 10, 6); break;
    default: FatalError("Unexpected slot in IA64InstallReloc()\n");
    }
    switch (opnd) {
    case IA64_OPND_IMM22:
	data &= ~(0x3fff9fc0000UL << slot);
	data |= (value & 0x7f) << (18 + slot);		/* [13:19] + 5 + slot */
	data |= (value & 0xff80) << (25 + slot);	/* [27:35] + 5 + slot */
	data |= (value & 0x1f0000) << (11 + slot);	/* [22:26] + 5 + slot */
	data |= (value & 0x200000) << (20 + slot);	/* [36:36] + 5 + slot */
	if (value << 42 >> 42 != value)
	    ErrorF("Relocation %016lx truncated to fit into IMM22\n", value);
	break;
    case IA64_OPND_TGT25C:
	data &= ~(0x23ffffc0000UL << slot);
	data |= (value & 0xfffff0) << (14 + slot);	/* [13:32] + 5 + slot */
	data |= (value & 0x1000000) << (17 + slot);	/* [36:36] + 5 + slot */
	if (value << 39 >> 39 != value || (value & 0xf))
	    ErrorF("Relocation %016lx truncated to fit into TGT25C\n", value);
	break;
    default:
	FatalError("Unhandled operand in IA64InstallReloc()\n");
    }
    switch (slot) {
    case 0: *data128 = data; break;
    case 1: memcpy((char *)data128 + 5, &data, 8); break;
    case 2: memcpy((char *)data128 + 10, &data, 6); break;
    default: FatalError("Unexpected slot in IA64InstallReloc()\n");
    }
    ia64_flush_cache(data128);
#ifdef ELFDEBUG
    ELFDEBUG( "After  [%016lx%016lx]\n", data128[1], data128[0]);
#endif
}

#endif

/*
 * Fix all of the relocations for the given section.
 * If the argument 'force' is non-zero, then the relocation will be
 * made even if the symbol can't be found (by substituting
 * LoaderDefaultFunc) otherwise, the relocation will be deferred.
 */
static ELFRelocPtr
Elf_RelocateEntry(elffile, secn, rel, force)
ELFModulePtr	elffile;
Elf_Word	secn;
Elf_Rel_t	*rel;
int		force;
{
    unsigned char *secp = elffile->saddr[secn];
    unsigned int *dest32;	/* address of the 32 bit place being modified */
#if defined(__powerpc__) || defined(__sparc__)
    unsigned short *dest16;	/* address of the 16 bit place being modified */
#endif
#if defined(__sparc__)
    unsigned char *dest8;	/* address of the 8 bit place being modified */
#endif
#if defined(__alpha__)
    unsigned int *dest32h;	/* address of the high 32 bit place being modified */
    unsigned long *dest64;
#endif
#if defined(__ia64__)
    unsigned long *dest64;
    unsigned long *dest128;
#endif
    Elf_Addr symval = 0;	/* value of the indicated symbol */

#ifdef ELFDEBUG
    ELFDEBUG( "%lx %d %d\n", rel->r_offset,
	      ELF_R_SYM(rel->r_info), ELF_R_TYPE(rel->r_info) );
#if defined(__powerpc__) || \
    defined(__mc68000__) || \
    defined(__alpha__) || \
    defined(__sparc__) || \
    defined(__ia64__)
    ELFDEBUG( "%lx", rel->r_addend );
#endif
    ELFDEBUG("\n");
#endif
#if defined(__alpha__)
    if (ELF_R_SYM(rel->r_info) && ELF_R_TYPE(rel->r_info) != R_ALPHA_GPDISP) {
#else
    if (ELF_R_SYM(rel->r_info)) {
#endif
	symval = ElfGetSymbolValue(elffile, ELF_R_SYM(rel->r_info));
	if (symval == 0) {
	    if (force) {
		symval = (Elf_Addr) &LoaderDefaultFunc;
	    } else {
#ifdef ELFDEBUG
		ELFDEBUG("***Unable to resolve symbol %s\n",
			 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
#endif
		return ElfDelayRelocation(elffile, secn, rel);
	    }
	}
    }

    switch( ELF_R_TYPE(rel->r_info) )
	{
#if defined(i386)
	case R_386_32:
	    dest32=(unsigned int *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    ELFDEBUG( "R_386_32\t");
	    ELFDEBUG( "dest32=%x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8lx\t", *dest32 );
#endif
	    *dest32=symval+(*dest32); /* S + A */
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8lx\n", *dest32 );
#endif
	    break;
	case R_386_PC32:
	    dest32=(unsigned int *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    ELFDEBUG( "R_386_PC32 %s\t",
			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symval=%lx\t", symval );
	    ELFDEBUG( "dest32=%x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8lx\t", *dest32 );
#endif

	    *dest32=symval+(*dest32)-(Elf_Addr)dest32; /* S + A - P */

#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8lx\n", *dest32 );
#endif

	    break;
#endif /* i386 */
#if defined(__alpha__)
	case R_ALPHA_NONE:
	case R_ALPHA_LITUSE:
	  break;
	  
	case R_ALPHA_REFQUAD:
	    dest64=(unsigned long *)(secp+rel->r_offset);
	    symval=ElfGetSymbolValue(elffile,
				     ELF_R_SYM(rel->r_info));
#ifdef ELFDEBUG
	    ELFDEBUG( "R_ALPHA_REFQUAD\t");
	    ELFDEBUG( "dest64=%lx\t", dest64 );
	    ELFDEBUG( "*dest64=%8.8lx\t", *dest64 );
#endif
	    *dest64=symval+rel->r_addend+(*dest64); /* S + A + P */
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest64=%8.8lx\n", *dest64 );
#endif
	  break;
	  
	case R_ALPHA_GPREL32:
	    {
	    dest64=(unsigned long *)(secp+rel->r_offset);
	    dest32=(unsigned int *)dest64;

#ifdef ELFDEBUG
	    ELFDEBUG( "R_ALPHA_GPREL32 %s\t", 
			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    ELFDEBUG( "secp=%lx\t", secp );
	    ELFDEBUG( "symval=%lx\t", symval );
	    ELFDEBUG( "dest32=%lx\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8x\t", *dest32 );
#endif
	    symval += rel->r_addend;
	    symval = ((unsigned char *)symval)-((unsigned char *)elffile->got);
#ifdef ELFDEBUG
	    ELFDEBUG( "symval=%lx\t", symval );
#endif
	    if( (symval&0xffffffff00000000) != 0x0000000000000000 &&
	        (symval&0xffffffff00000000) != 0xffffffff00000000 ) {
		FatalError("R_ALPHA_GPREL32 symval-got is too large for %s\n",
			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)));
	    }

	    *dest32=symval;
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%x\n", *dest32 );
#endif
	    break;
	    }
	case R_ALPHA_LITERAL:
	    {
	    ELFGotEntryPtr gotent;
	    dest32=(unsigned int *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    ELFDEBUG( "R_ALPHA_LITERAL %s\t", 
			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    ELFDEBUG( "secp=%lx\t", secp );
	    ELFDEBUG( "symval=%lx\t", symval );
	    ELFDEBUG( "dest32=%lx\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8x\t", *dest32 );
#endif

	    for (gotent=elffile->got_entries;gotent;gotent=gotent->next) {
		if ( ELF_R_SYM(gotent->rel->r_info) == ELF_R_SYM(rel->r_info) &&
	     	gotent->rel->r_addend == rel->r_addend )
			break;
	    }

	    /* Set the address in the GOT */
	    if( gotent ) {
		*(unsigned long *)(elffile->got+gotent->offset) =
							symval+rel->r_addend;
#ifdef ELFDEBUG
		ELFDEBUG("Setting gotent[%x]=%lx\t",
				gotent->offset, symval+rel->r_addend);
#endif
		if ((gotent->offset & 0xffff0000) != 0)
		    FatalError("\nR_ALPHA_LITERAL offset %x too large\n",
			       gotent->offset);
		(*dest32)|=(gotent->offset);	/* The address part is always 0 */
		}
	    else	{
		unsigned long val;
		
		/* S + A - P >> 2 */
		val=((symval+(rel->r_addend)-(Elf_Addr)dest32));
#ifdef ELFDEBUG
		ELFDEBUG("S+A-P=%x\t",val);
#endif
		if( (val & 0xffff0000) != 0xffff0000 &&
		    (val & 0xffff0000) != 0x00000000 )  {
		    ErrorF("\nR_ALPHA_LITERAL offset %x too large\n", val);
			break;
		}
		val &= 0x0000ffff;
		(*dest32)|=(val);	/* The address part is always 0 */
	    }
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif

	    break;
	    }
	  
	case R_ALPHA_GPDISP:
	    {
	    long offset;

	    dest32h=(unsigned int *)(secp+rel->r_offset);
	    dest32=(unsigned int *)((secp+rel->r_offset)+rel->r_addend);

#ifdef ELFDEBUG
	    ELFDEBUG( "R_ALPHA_GPDISP %s\t", 
			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    ELFDEBUG( "secp=%lx\t", secp );
	    ELFDEBUG( "got=%lx\t", elffile->got );
	    ELFDEBUG( "gp=%lx\t", gp );
	    ELFDEBUG( "dest32=%lx\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8x\t", *dest32 );
	    ELFDEBUG( "dest32h=%lx\t", dest32h );
	    ELFDEBUG( "*dest32h=%8.8x\t", *dest32h );
#endif
	    if ((*dest32h >> 26) != 9 || (*dest32 >> 26) != 8) {
	        ErrorF( "***Bad instructions in relocating %s\n",
			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    }

	    symval = (*dest32h & 0xffff) << 16 | (*dest32 & 0xffff);
	    symval = (symval ^ 0x80008000) - 0x80008000;
	    
	    offset = ((unsigned char *)elffile->got - (unsigned char *)dest32h);
#ifdef ELFDEBUG
	    ELFDEBUG( "symval=%lx\t", symval );
	    ELFDEBUG( "got-dest32=%lx\t", offset );
#endif

	    if( (offset >= 0x7fff8000L) || (offset < -0x80000000L) ) {
		FatalError( "Offset overflow for R_ALPHA_GPDISP\n");
	    }

	    symval += (unsigned long)offset;
#ifdef ELFDEBUG
	    ELFDEBUG( "symval=%lx\t", symval );
#endif
	    *dest32=(*dest32&0xffff0000) | (symval&0xffff);
	    *dest32h=(*dest32h&0xffff0000)|
			(((symval>>16)+((symval>>15)&1))&0xffff);
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8x\t", *dest32 );
	    ELFDEBUG( "*dest32h=%8.8x\n", *dest32h );
#endif
	  break;
	  }
	  
	case R_ALPHA_HINT:
	    dest32=(unsigned int *)((secp+rel->r_offset)+rel->r_addend);
#ifdef ELFDEBUG
	    ELFDEBUG( "R_ALPHA_HINT %s\t", 
			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    ELFDEBUG( "secp=%lx\t", secp );
	    ELFDEBUG( "symval=%lx\t", symval );
	    ELFDEBUG( "dest32=%lx\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8x\t", *dest32 );
#endif

#ifdef ELFDEBUG
	    ELFDEBUG( "symval=%lx\t", symval );
#endif
	    symval -= (Elf_Addr)(((unsigned char *)dest32)+4);
	    if (symval % 4 ) {
		ErrorF( "R_ALPHA_HINT bad alignment of offset\n");
		}
	    symval=symval>>2;

#ifdef ELFDEBUG
	    ELFDEBUG( "symval=%lx\t", symval );
#endif

	    if( symval & 0xffff8000 ) {
#ifdef ELFDEBUG
		ELFDEBUG("R_ALPHA_HINT symval too large\n" );
#endif
	    }

	    *dest32 = (*dest32&~0x3fff) | (symval&0x3fff);

#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	  break;
	  
#endif /* alpha */
#if defined(__mc68000__)
	case R_68K_32:
	    dest32=(unsigned int *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    ELFDEBUG( "R_68K_32\t" );
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symval=%x\t", symval );
	    ELFDEBUG( "r_addend=%x\t", rel->r_addend );
	    ELFDEBUG( "dest32=%8.8x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    {
		unsigned long val;
		/* S + A */
		val=symval+(rel->r_addend);
#ifdef ELFDEBUG
		ELFDEBUG("S+A=%x\t",val);
#endif
		*dest32=val; /* S + A */
	    }
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    break;
	case R_68K_PC32:
	    dest32=(unsigned int *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    ELFDEBUG( "R_68K_PC32\t" );
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symval=%x\t", symval );
	    ELFDEBUG( "r_addend=%x\t", rel->r_addend );
	    ELFDEBUG( "dest32=%8.8x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    {
		unsigned long val;
		/* S + A - P */
		val=symval+(rel->r_addend);
		val-=*dest32;
#ifdef ELFDEBUG
		ELFDEBUG("S+A=%x\t",val);
		ELFDEBUG("S+A-P=%x\t",val+(*dest32)-(Elf_Addr)dest32);
#endif
	        *dest32=val+(*dest32)-(Elf_Addr)dest32; /* S + A - P */
	    }
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    break;
#endif /* __mc68000__ */
#if defined(__powerpc__)
#if defined(PowerMAX_OS)
	case R_PPC_DISP24: /* 11 */
	    dest32=(unsigned long *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    ELFDEBUG( "R_PPC_DISP24 %s\t", ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symval=%x\t", symval );
	    ELFDEBUG( "dest32=%x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8x\t", *dest32 );
#endif

	    {
		unsigned long val;
		
		/* S + A - P >> 2 */
		val=((symval+(rel->r_addend)-(Elf_Addr)dest32));
#ifdef ELFDEBUG
		ELFDEBUG("S+A-P=%x\t",val);
#endif
		val = val>>2;
		if( (val & 0x3f000000) != 0x3f000000 &&
		    (val & 0x3f000000) != 0x00000000 )  {
#ifdef ELFDEBUG
		    ELFDEBUG("R_PPC_DISP24 offset %x too large\n", val<<2);
#endif
		    symval = ElfGetPltAddr(elffile,ELF_R_SYM(rel->r_info));
		    val=((symval+(rel->r_addend)-(Elf_Addr)dest32));
#ifdef ELFDEBUG
		    ELFDEBUG("PLT offset is %x\n", val);
#endif
		    val=val>>2;
		    if( (val & 0x3f000000) != 0x3f000000 &&
		         (val & 0x3f000000) != 0x00000000 )
			   FatalError("R_PPC_DISP24 PLT offset %x too large\n", val<<2);
		}
		val &= 0x00ffffff;
		(*dest32)|=(val<<2);	/* The address part is always 0 */
		ppc_flush_icache(dest32);
	    }
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    break;
	case R_PPC_16HU: /* 31 */
	    dest16=(unsigned short *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    dest32=(unsigned long *)(dest16-1);

#endif
#ifdef ELFDEBUG
	    ELFDEBUG( "R_PPC_16HU\t" );
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symval=%x\t", symval );
	    ELFDEBUG( "r_addend=%x\t", rel->r_addend );
	    ELFDEBUG( "dest16=%x\t", dest16 );
	    ELFDEBUG( "*dest16=%8.8x\t", *dest16 );
	    ELFDEBUG( "dest32=%8.8x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    {
		unsigned short val;
		/* S + A */
		val=((symval+(rel->r_addend))&0xffff0000)>>16;
#ifdef ELFDEBUG
		ELFDEBUG("uhi16(S+A)=%x\t",val);
#endif
		*dest16=val; /* S + A */
		ppc_flush_icache(dest16);
	    }
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest16=%8.8x\t", *dest16 );
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    break;
	case R_PPC_32: /* 32 */
	    dest32=(unsigned long *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    ELFDEBUG( "R_PPC_32\t" );
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symval=%x\t", symval );
	    ELFDEBUG( "r_addend=%x\t", rel->r_addend );
	    ELFDEBUG( "dest32=%8.8x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    {
		unsigned long val;
		/* S + A */
		val=symval+(rel->r_addend);
#ifdef ELFDEBUG
		ELFDEBUG("S+A=%x\t",val);
#endif
		*dest32=val; /* S + A */
		ppc_flush_icache(dest32);
	    }
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    break;
	case R_PPC_32UA: /* 33 */
	    dest32=(unsigned long *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    ELFDEBUG( "R_PPC_32UA\t" );
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symval=%x\t", symval );
	    ELFDEBUG( "r_addend=%x\t", rel->r_addend );
	    ELFDEBUG( "dest32=%8.8x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    {
		unsigned long val;
		unsigned char *dest8 = (unsigned char *)dest32;
		/* S + A */
		val=symval+(rel->r_addend);
#ifdef ELFDEBUG
		ELFDEBUG("S+A=%x\t",val);
#endif
		*dest8++=(val&0xff000000)>>24;
		*dest8++=(val&0x00ff0000)>>16;
		*dest8++=(val&0x0000ff00)>> 8;
		*dest8++=(val&0x000000ff);
		ppc_flush_icache(dest32);
	    }
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    break;
	case R_PPC_16H: /* 34 */
	    dest16=(unsigned short *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    dest32=(unsigned long *)(dest16-1);
#endif
#ifdef ELFDEBUG
	    ELFDEBUG( "R_PPC_16H\t" );
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symbol=%s\t", ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    ELFDEBUG( "symval=%x\t", symval );
	    ELFDEBUG( "r_addend=%x\t", rel->r_addend );
	    ELFDEBUG( "dest16=%x\t", dest16 );
	    ELFDEBUG( "*dest16=%8.8x\t", *dest16 );
	    ELFDEBUG( "dest32=%8.8x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    {
		unsigned short val;
		unsigned short loval;
		/* S + A */
		val=((symval+(rel->r_addend))&0xffff0000)>>16;
		loval=(symval+(rel->r_addend))&0xffff;
		if( loval & 0x8000 ) {
		    /*
		     * This is hi16(), instead of uhi16(). Because of this,
		     * if the lo16() will produce a negative offset, then
		     * we have to increment this part of the address to get
		     * the correct final result.
		     */
		    val++;
		}
#ifdef ELFDEBUG
		ELFDEBUG("hi16(S+A)=%x\t",val);
#endif
		*dest16=val; /* S + A */
		ppc_flush_icache(dest16);
	    }
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest16=%8.8x\t", *dest16 );
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    break;
	case R_PPC_16L: /* 35 */
	    dest16=(unsigned short *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    dest32=(unsigned long *)(dest16-1);
#endif
#ifdef ELFDEBUG
	    ELFDEBUG( "R_PPC_16L\t" );
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symval=%x\t", symval );
	    ELFDEBUG( "r_addend=%x\t", rel->r_addend );
	    ELFDEBUG( "dest16=%x\t", dest16 );
	    ELFDEBUG( "*dest16=%8.8x\t", *dest16 );
	    ELFDEBUG( "dest32=%8.8x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    {
		unsigned short val;
		/* S + A */
		val=(symval+(rel->r_addend))&0xffff;
#ifdef ELFDEBUG
		ELFDEBUG("lo16(S+A)=%x\t",val);
#endif
		*dest16=val; /* S + A */
		ppc_flush_icache(dest16);
	    }
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest16=%8.8x\t", *dest16 );
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    break;
#else
 /* Linux PPC */
	case R_PPC_ADDR32: /* 1 */
	    dest32=(unsigned int *)(secp+rel->r_offset);
	    symval=ElfGetSymbolValue(elffile,ELF_R_SYM(rel->r_info));
#ifdef ELFDEBUG
	    ELFDEBUG( "R_PPC_ADDR32\t" );
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symval=%x\t", symval );
	    ELFDEBUG( "r_addend=%x\t", rel->r_addend );
	    ELFDEBUG( "dest32=%8.8x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    {
		unsigned long val;
		/* S + A */
		val=symval+(rel->r_addend);
#ifdef ELFDEBUG
		ELFDEBUG("S+A=%x\t",val);
#endif
		*dest32=val; /* S + A */
		ppc_flush_icache(dest32);
	    }
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    break;
	case R_PPC_ADDR16_LO: /* 4 */
	    dest16=(unsigned short *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    dest32=(unsigned long *)(dest16-1);
#endif
#ifdef ELFDEBUG
	    ELFDEBUG( "R_PPC_ADDR16_LO\t" );
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symval=%x\t", symval );
	    ELFDEBUG( "r_addend=%x\t", rel->r_addend );
	    ELFDEBUG( "dest16=%x\t", dest16 );
	    ELFDEBUG( "*dest16=%8.8x\t", *dest16 );
#endif
	    {
		unsigned short val;
		/* S + A */
		val=(symval+(rel->r_addend))&0xffff;
#ifdef ELFDEBUG
		ELFDEBUG("lo16(S+A)=%x\t",val);
#endif
		*dest16=val; /* S + A */
		ppc_flush_icache(dest16);
	    }
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest16=%8.8x\t", *dest16 );
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    break;
	case R_PPC_ADDR16_HA: /* 6 */
	    dest16=(unsigned short *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    dest32=(unsigned long *)(dest16-1);
#endif
#ifdef ELFDEBUG
	    ELFDEBUG( "R_PPC_ADDR16_HA\t" );
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symval=%x\t", symval );
	    ELFDEBUG( "r_addend=%x\t", rel->r_addend );
	    ELFDEBUG( "dest16=%x\t", dest16 );
	    ELFDEBUG( "*dest16=%8.8x\t", *dest16 );
#endif
	    {
		unsigned short val;
		unsigned short loval;
		/* S + A */
		val=((symval+(rel->r_addend))&0xffff0000)>>16;
		loval=(symval+(rel->r_addend))&0xffff;
		if( loval & 0x8000 ) {
		    /*
		     * This is hi16(), instead of uhi16(). Because of this,
		     * if the lo16() will produce a negative offset, then
		     * we have to increment this part of the address to get
		     * the correct final result.
		     */
		    val++;
		}
#ifdef ELFDEBUG
		ELFDEBUG("hi16(S+A)=%x\t",val);
#endif
		*dest16=val; /* S + A */
		ppc_flush_icache(dest16);
	    }
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest16=%8.8x\t", *dest16 );
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    break;
	case R_PPC_REL24: /* 10 */
	    dest32=(unsigned int *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    ELFDEBUG( "R_PPC_REL24 %s\t", ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symval=%x\t", symval );
	    ELFDEBUG( "dest32=%x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8x\t", *dest32 );
#endif

	    {
		unsigned long val;
		
		/* S + A - P >> 2 */
		val=((symval+(rel->r_addend)-(Elf_Addr)dest32));
#ifdef ELFDEBUG
		ELFDEBUG("S+A-P=%x\t",val);
#endif
		val = val>>2;
		if( (val & 0x3f000000) != 0x3f000000 &&
		    (val & 0x3f000000) != 0x00000000 )  {
#ifdef ELFDEBUG
		    ELFDEBUG("R_PPC_REL24 offset %x too large\n", val<<2);
#endif
		    symval = ElfGetPltAddr(elffile,ELF_R_SYM(rel->r_info));
		    val=((symval+(rel->r_addend)-(Elf_Addr)dest32));
#ifdef ELFDEBUG
		    ELFDEBUG("PLT offset is %x\n", val);
#endif
		    val=val>>2;
		    if( (val & 0x3f000000) != 0x3f000000 &&
		         (val & 0x3f000000) != 0x00000000 )
			   FatalError("R_PPC_REL24 PLT offset %x too large\n", val<<2);
		}
		val &= 0x00ffffff;
		(*dest32)|=(val<<2);	/* The address part is always 0 */
		ppc_flush_icache(dest32);
	    }
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    break;
	case R_PPC_REL32: /* 26 */
	    dest32=(unsigned int *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    ELFDEBUG( "R_PPC_REL32\t" );
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symval=%x\t", symval );
	    ELFDEBUG( "r_addend=%x\t", rel->r_addend );
	    ELFDEBUG( "dest32=%8.8x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    {
		unsigned long val;
		/* S + A - P */
		val=symval+(rel->r_addend);
		val-=*dest32;
#ifdef ELFDEBUG
		ELFDEBUG("S+A=%x\t",val);
		ELFDEBUG("S+A-P=%x\t",val+(*dest32)-(Elf_Addr)dest32);
#endif
	        *dest32=val+(*dest32)-(Elf_Addr)dest32; /* S + A - P */
		ppc_flush_icache(dest32);
	    }
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8x\n", *dest32 );
#endif
	    break;
#endif /* PowerMAX_OS */
#endif /* __powerpc__ */
#ifdef __sparc__
	case R_SPARC_NONE:	/*  0 */
		break;

	case R_SPARC_8:		/*  1 */
		dest8 = (unsigned char *)(secp + rel->r_offset);
		symval += rel->r_addend;
		*dest8 = symval;
		break;

	case R_SPARC_16:	/*  2 */
		dest16 = (unsigned short *)(secp + rel->r_offset);
		symval += rel->r_addend;
		*dest16 = symval;
		break;

	case R_SPARC_32:	/*  3 */
	case R_SPARC_GLOB_DAT:	/* 20 */
	case R_SPARC_UA32:	/* 23 */
		dest32 = (unsigned int *)(secp + rel->r_offset);
		symval += rel->r_addend;
		((unsigned char *)dest32)[0] = (unsigned char)(symval >> 24);
		((unsigned char *)dest32)[1] = (unsigned char)(symval >> 16);
		((unsigned char *)dest32)[2] = (unsigned char)(symval >>  8);
		((unsigned char *)dest32)[3] = (unsigned char)(symval      );
		break;

	case R_SPARC_DISP8:	/*  4 */
		dest8 = (unsigned char *)(secp + rel->r_offset);
		symval += rel->r_addend;
		*dest8 = (symval - (Elf32_Addr) dest8);
		break;

	case R_SPARC_DISP16:	/*  5 */
		dest16 = (unsigned short *)(secp + rel->r_offset);
		symval += rel->r_addend;
		*dest16 = (symval - (Elf32_Addr) dest16);
		break;

	case R_SPARC_DISP32:	/*  6 */
		dest32 = (unsigned int *)(secp + rel->r_offset);
		symval += rel->r_addend;
		*dest32 = (symval - (Elf32_Addr) dest32);
		break;

	case R_SPARC_WDISP30:	/*  7 */
		dest32 = (unsigned int *)(secp + rel->r_offset);
		symval += rel->r_addend;
		*dest32 = ((*dest32 & 0xc0000000) |
			   ((symval - (Elf32_Addr) dest32) >> 2));
		break;

	case R_SPARC_HI22:	/*  9 */
		dest32 = (unsigned int *)(secp + rel->r_offset);
		symval += rel->r_addend;
		*dest32 = (*dest32 & 0xffc00000) | (symval >> 10);
		break;

	case R_SPARC_LO10:	/* 12 */
		dest32 = (unsigned int *)(secp + rel->r_offset);
		symval += rel->r_addend;
		*dest32 = (*dest32 & ~0x3ff) | (symval & 0x3ff);
		break;

	case R_SPARC_COPY:	/* 19 */
		/* Fix your code...  I'd rather dish out an error here
		 * so people will not link together PIC and non-PIC
		 * code into a final driver object file.
		 */
		ErrorF("Elf_RelocateEntry():"
		       "  Copy relocs not supported on Sparc.\n");
		break;

	case R_SPARC_JMP_SLOT:	/* 21 */
		dest32 = (unsigned int *)(secp + rel->r_offset);
		/* Before we change it the PLT entry looks like:
		 *
		 * pltent:	sethi	%hi(rela_plt_offset), %g1
		 *		b,a	PLT0
		 *		nop
		 *
		 * We change it into:
		 *
		 * pltent:	sethi	%hi(rela_plt_offset), %g1
		 *		sethi	%hi(symval), %g1
		 *		jmp	%g1 + %lo(symval), %g0
		 */
		symval += rel->r_addend;
		dest32[2] = 0x81c06000 | (symval & 0x3ff);
		__asm __volatile("flush %0 + 0x8" : : "r" (dest32));
		dest32[1] = 0x03000000 | (symval >> 10);
		__asm __volatile("flush %0 + 0x4" : : "r" (dest32));
		break;

	case R_SPARC_RELATIVE:	/* 22 */
		dest32 = (unsigned int *)(secp + rel->r_offset);
		*dest32 += (unsigned int)secp + rel->r_addend;
		break;
#endif
#ifdef __ia64__
	case R_IA64_NONE:
		break;

	case R_IA64_LTOFF_FPTR22:
	    if (rel->r_addend)
		FatalError("\nAddend for R_IA64_LTOFF_FPTR22 not supported\n");
#ifdef ELFDEBUG
	    ELFDEBUG( "opd=%016lx.%016lx\n",
		((long *)symval)[0], ((long *)symval)[1] );
#endif
	    /* FALLTHROUGH */
	case R_IA64_LTOFF22:
	    {
	    ELFGotEntryPtr gotent;
	    dest128=(unsigned long *)(secp+(rel->r_offset&~3));
#ifdef ELFDEBUG
	    ELFDEBUG( "%s %s\t", ELF_R_TYPE(rel->r_info) == R_IA64_LTOFF22 ?
			"R_IA64_LTOFF22" : "R_IA64_LTOFF_FPTR22",
			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    ELFDEBUG( "secp=%lx\t", secp );
	    ELFDEBUG( "symval=%lx\t", symval );
	    ELFDEBUG( "dest128=%lx\t", dest128 );
	    ELFDEBUG( "slot=%d\n", rel->r_offset & 3);
	    ELFDEBUG( "*dest128=[%016lx%016lx]\n", dest128[1], dest128[0]);
#endif

	    for (gotent=elffile->got_entries;gotent;gotent=gotent->next) {
		if ( ELF_R_SYM(gotent->rel->r_info) == ELF_R_SYM(rel->r_info) &&
	     	gotent->rel->r_addend == rel->r_addend )
			break;
	    }

	    /* Set the address in the GOT */
	    if( gotent ) {
		*(unsigned long *)(elffile->got+gotent->offset) =
							symval+rel->r_addend;
#ifdef ELFDEBUG
		ELFDEBUG("Setting gotent[%x]=%lx\n",
				gotent->offset, symval+rel->r_addend);
#endif
		if ((gotent->offset & 0xffe00000) != 0)
		    FatalError("\nR_IA64_LTOFF22 offset %x too large\n",
			       gotent->offset);
		IA64InstallReloc(dest128, rel->r_offset & 3, IA64_OPND_IMM22, gotent->offset);
	    }
	    else
		FatalError("\nCould not find GOT entry\n");
	    }
	    break;

	case R_IA64_PCREL21B:
	    {
	    ELFPltEntryPtr pltent;
	    dest128=(unsigned long *)(secp+(rel->r_offset&~3));
#ifdef ELFDEBUG
	    ELFDEBUG( "R_IA64_PCREL21B %s\t",
			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    ELFDEBUG( "secp=%lx\t", secp );
	    ELFDEBUG( "symval=%lx\t", symval );
	    ELFDEBUG( "opd=%lx.%lx\t", ((long *)symval)[0], ((long *)symval)[1]);
	    ELFDEBUG( "dest128=%lx\t", dest128 );
	    ELFDEBUG( "slot=%d\n", rel->r_offset & 3);
	    ELFDEBUG( "*dest128=[%016lx%016lx]\n", dest128[1], dest128[0]);
#endif
	    if (rel->r_addend)
		FatalError("\nAddend for PCREL21B not supported\n");
	    if (((long *)symval)[1] == (long)elffile->got
		&& (((unsigned long)dest128 - ((unsigned long *)symval)[0]) + 0x2000000 < 0x4000000)) {
		/* We can save the travel through PLT */
		IA64InstallReloc(dest128, rel->r_offset & 3, IA64_OPND_TGT25C,
				 ((unsigned long *)symval)[0] - (unsigned long)dest128);
		break;
	    }
	    for (pltent=elffile->plt_entries;pltent;pltent=pltent->next) {
		if ( ELF_R_SYM(pltent->rel->r_info) == ELF_R_SYM(rel->r_info) &&
	     	pltent->rel->r_addend == rel->r_addend )
			break;
	    }

	    /* Set the address in the PLT */
	    if (pltent == NULL)
		FatalError("\nCould not find PLT entry\n");
	    else {
		unsigned long *p = (unsigned long *)(elffile->plt+pltent->offset);
		unsigned long r = (unsigned long)symval - (unsigned long)elffile->got;

		if (r + 0x200000 >= 0x400000) {
			/* Too far from gp to use the official function descriptor,
			 * so we have to make a local one.
			 */
			r = pltent->gotoffset;
			memcpy(elffile->got+r, (char *)symval, 16);
		}

		/* [MMI] addl r15=NNN,r1;; ld8 r16=[r15],8; mov r14=r1;; */
		p[0] = 0x410024000200780bUL;
		p[1] = 0x84000801c028303cUL;
		/* [MIB] ld8 r1=[r15]; mov b6=r16; br.few b6;; */
		p[2] = 0x806010181e000811UL;
		p[3] = 0x0080006000038004UL;
		IA64InstallReloc(p, 0, IA64_OPND_IMM22, r);
		IA64InstallReloc(dest128, rel->r_offset & 3, IA64_OPND_TGT25C,
				 (unsigned long)p - (unsigned long)dest128);
	    }
	    }
	    break;

	case R_IA64_FPTR64LSB:
	    dest64=(unsigned long *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    ELFDEBUG( "R_IA64_FPTR64LSB %s\t",
			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    ELFDEBUG( "secp=%lx\t", secp );
	    ELFDEBUG( "symval=%lx\t", symval );
	    ELFDEBUG( "dest64=%lx\t", dest64 );
	    ELFDEBUG( "opd=%016lx.%016lx\n", ((long *)symval)[0], ((long *)symval)[1] );
#endif

	    if (rel->r_addend)
		FatalError("\nAddend not supported for R_IA64_FPTR64LSB\n");
	    *dest64 = symval;
	    ia64_flush_cache(dest64);
	    break;

	case R_IA64_DIR64LSB:
	    dest64=(unsigned long *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    ELFDEBUG( "R_IA64_DIR64LSB %s\t",
			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    ELFDEBUG( "secp=%lx\t", secp );
	    ELFDEBUG( "symval=%lx\t", symval );
	    ELFDEBUG( "dest64=%lx\n", dest64 );
#endif
	    *dest64 = symval + rel->r_addend;
	    ia64_flush_cache(dest64);
	    break;

	case R_IA64_GPREL22:
	    dest128=(unsigned long *)(secp+(rel->r_offset&~3));
#ifdef ELFDEBUG
	    ELFDEBUG( "R_IA64_GPREL22 %s\t",
			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    ELFDEBUG( "secp=%lx\t", secp );
	    ELFDEBUG( "symval=%lx\t", symval );
	    ELFDEBUG( "dest128=%lx\t", dest128 );
	    ELFDEBUG( "slot=%d\n", rel->r_offset & 3);
	    ELFDEBUG( "*dest128=[%016lx%016lx]\n", dest128[1], dest128[0]);
#endif
	    IA64InstallReloc(dest128, rel->r_offset & 3, IA64_OPND_IMM22,
		symval + rel->r_addend - (long)elffile->got);
	    break;

#endif

#if defined(__arm__)
	case R_ARM_ABS32:
	    dest32=(unsigned int *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    ELFDEBUG( "R_ARM_ABS32\t");
	    ELFDEBUG( "dest32=%x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8lx\t", *dest32 );
#endif
	    *dest32=symval+(*dest32); /* S + A */
#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8lx\n", *dest32 );
#endif
	    break;

	case R_ARM_REL32:
	    dest32=(unsigned int *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    {
	    char *namestr;
	    ELFDEBUG( "R_ARM_REL32 %s\t",
			namestr=ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    xf86loaderfree(namestr);
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symval=%lx\t", symval );
	    ELFDEBUG( "dest32=%x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8lx\t", *dest32 );
	    }
#endif

	    *dest32=symval+(*dest32)-(Elf_Addr)dest32; /* S + A - P */

#ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8lx\n", *dest32 );
#endif

	    break;

	case R_ARM_PC24:	
	    {
	    unsigned long val;
            dest32=(unsigned int *)(secp+rel->r_offset);
	    val = (*dest32 & 0x00ffffff) << 2;
            val = symval - (unsigned long)dest32 + val;	
            val >>= 2;
	    *dest32 = (*dest32 & 0xff000000) | (val & 0x00ffffff); 
	    arm_flush_cache(dest32);
	    }
	    break;

#endif /* (__arm__) */

	default:
	    ErrorF("Elf_RelocateEntry() Unsupported relocation type %d\n",
		   ELF_R_TYPE(rel->r_info));
	    break;
	    }
    return 0;
}

static ELFRelocPtr
ELFCollectRelocations(elffile, index)
ELFModulePtr	elffile;
int	index; /* The section to use as relocation data */
{
    int	i, numrel;
    Elf_Shdr	*sect=&(elffile->sections[index]);
    Elf_Rel_t	*rel=(Elf_Rel_t *)elffile->saddr[index];
    Elf_Sym	*syms;
    ELFRelocPtr reloc_head = NULL;
    ELFRelocPtr tmp;

    syms = (Elf_Sym *) elffile->saddr[elffile->symndx];

    numrel=sect->sh_size/sect->sh_entsize;

    for(i=0; i<numrel; i++ ) {
#if defined(__alpha__)
	if( ELF_R_TYPE(rel[i].r_info) == R_ALPHA_LITERAL) {
	    ElfAddGOT(elffile,&rel[i]);
	}   
#endif
#if defined(__ia64__)
	if (ELF_R_TYPE(rel[i].r_info) == R_IA64_LTOFF22
	    || ELF_R_TYPE(rel[i].r_info) == R_IA64_LTOFF_FPTR22) {
	    ElfAddGOT(elffile,&rel[i]);
	}
	if (ELF_R_TYPE(rel[i].r_info) == R_IA64_PCREL21B) {
	    ElfAddPLT(elffile,&rel[i]);
	}
	if (ELF_R_TYPE(rel[i].r_info) == R_IA64_LTOFF_FPTR22
	    || ELF_R_TYPE(rel[i].r_info) == R_IA64_FPTR64LSB) {
	    if (ELF_ST_BIND(syms[ELF_R_SYM(rel[i].r_info)].st_info) == STB_LOCAL) {
		ElfAddOPD(elffile, ELF_R_SYM(rel[i].r_info), NULL);
	    }
	}
#endif
	tmp = ElfDelayRelocation(elffile, sect->sh_info, &(rel[i]));
	tmp->next = reloc_head;
	reloc_head = tmp;
    }

    return reloc_head;
}

/*
 * ELF_GetSymbols()
 *
 * add the symbols to the symbol table maintained by the loader.
 */

static LOOKUP *
ELF_GetSymbols(elffile, psecttable)
ELFModulePtr	elffile;
unsigned short  **psecttable;
{
    Elf_Sym	*syms;
    Elf_Shdr	*sect;
    int		i, l, numsyms;
    LOOKUP	*lookup, *p;
    ELFCommonPtr tmp;
    unsigned short *secttable;

    syms=elffile->symtab;
    sect=&(elffile->sections[elffile->symndx]);
    numsyms=sect->sh_size/sect->sh_entsize;

    if ((lookup = xf86loadermalloc((numsyms+1)*sizeof(LOOKUP))) == NULL)
	return 0;

    if ((secttable = xf86loadercalloc(sizeof(unsigned short),(numsyms+1))) == NULL) {
	xf86loaderfree(lookup);
	return 0;
    }
    *psecttable = secttable;

    for(i=0,l=0; i<numsyms; i++)
	{
#ifdef ELFDEBUG
	    ELFDEBUG("value=%lx\tsize=%lx\tBIND=%x\tTYPE=%x\tndx=%x\t%s\n",
		     syms[i].st_value,syms[i].st_size,
		     ELF_ST_BIND(syms[i].st_info),ELF_ST_TYPE(syms[i].st_info),
		     syms[i].st_shndx,ElfGetString(elffile,syms[i].st_name) );
#endif

	    if( ELF_ST_BIND(syms[i].st_info) == STB_LOCAL )
		/* Don't add static symbols to the symbol table */
		continue;

	    switch( ELF_ST_TYPE(syms[i].st_info) )
		{
		case STT_OBJECT:
		case STT_FUNC:
		case STT_SECTION:
		case STT_NOTYPE:
		    switch(syms[i].st_shndx)
			{
			case SHN_ABS:
			    ErrorF("ELF_GetSymbols() Don't know how to handle SHN_ABS\n" );
			    break;
			case SHN_COMMON:
#ifdef ELFDEBUG
			    ELFDEBUG("Adding COMMON space for %s\n",
				     ElfGetString(elffile,syms[i].st_name) );
#endif
			    if (!LoaderHashFind(ElfGetString(elffile,
							syms[i].st_name))) {
				tmp = ElfAddCOMMON(&(syms[i]));
				if (tmp) {
				    tmp->next = listCOMMON;
				    listCOMMON = tmp;
				}
			    }			    
			    break;
			case SHN_UNDEF:
			    /*
			     * UNDEF will get resolved later, so the value
			     * doesn't really matter here.
			     */
			    /* since we don't know the value don't advertise the symbol */
			    break;
			default:
			    lookup[l].symName=xf86loaderstrdup(ElfGetString(elffile,syms[i].st_name));
			    lookup[l].offset=(funcptr)syms[i].st_value;
			    secttable[l] = syms[i].st_shndx;
#ifdef ELFDEBUG
			    ELFDEBUG("Adding symbol %lx(%d) %s\n",
				     lookup[l].offset, secttable[l], lookup[l].symName );
#endif
#ifdef __ia64__
			    if ( ELF_ST_TYPE(syms[i].st_info) == STT_FUNC ) {
				ElfAddOPD(elffile, -1, &lookup[l]);
			    }
#endif
			    l++;
			    break;
			}
		    break;
		case STT_FILE:
		case STT_LOPROC:
		case STT_HIPROC:
		    /* Skip this type */
#ifdef ELFDEBUG
		    ELFDEBUG("Skipping TYPE %d %s\n",
			     ELF_ST_TYPE(syms[i].st_info),
			     ElfGetString(elffile,syms[i].st_name));
#endif
		    break;
		default:
		    ErrorF("ELF_GetSymbols(): Unepected symbol type %d\n",
			   ELF_ST_TYPE(syms[i].st_info) );
		    break;
		}
	}

    lookup[l].symName=NULL; /* Terminate the list */

/*
 * Remove the ELF symbols that will show up in every object module.
 */
    for (i = 0, p = lookup; p->symName; i++, p++) {
	while (!strcmp(lookup[i].symName, ".text")
	       || !strcmp(lookup[i].symName, ".data")
	       || !strcmp(lookup[i].symName, ".bss")
	       || !strcmp(lookup[i].symName, ".comment")
	       || !strcmp(lookup[i].symName, ".note")
	       ) {
	    memmove(&(lookup[i]), &(lookup[i+1]), (l-- - i) * sizeof (LOOKUP));
	}
    }
    return lookup;
}

#define SecOffset(index) elffile->sections[index].sh_offset
#define SecSize(index) elffile->sections[index].sh_size
#define SecAlign(index) elffile->sections[index].sh_addralign

#define AdjustSize(i)				\
    if (!pass) {				\
	if (SecAlign(i) > *maxalign)		\
	    *maxalign = SecAlign(i);		\
	*totalsize += (SecAlign(i) - 1);	\
	*totalsize &= ~(SecAlign(i) - 1);	\
	*totalsize += SecSize(i);		\
	continue;				\
    } do { } while (0)

/*
 * ELFCollectSections
 *
 * Do the work required to load each section into memory.
 */
static void
ELFCollectSections(elffile,pass,totalsize,maxalign)
ELFModulePtr	elffile;
int		pass;
int		*totalsize;
int		*maxalign;
{
    int	i;

/*
 * Find and identify all of the Sections
 */

#ifdef ELFDEBUG
    ELFDEBUG("%d sections\n", elffile->numsh );
#endif

    for( i=1; i<elffile->numsh; i++) {
#ifdef ELFDEBUG
	ELFDEBUG("%d %s\n", i, ElfGetSectionName(elffile, elffile->sections[i].sh_name) );
#endif
	/* .text */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".text" ) == 0 ) {
	    AdjustSize(i);
	    elffile->text=ELFLoaderSectToMem(elffile,SecAlign(i),
					     SecOffset(i),SecSize(i),
					     ".text");
	    elffile->saddr[i]=elffile->text;
	    elffile->txtndx=i;
#ifdef ELFDEBUG
	    ELFDEBUG(".text starts at %lx\n", elffile->text );
#endif
	    elffile->txtsize=SecSize(i);
	    mprotect(elffile->text, elffile->txtsize, 
		     PROT_READ|PROT_WRITE|PROT_EXEC);
	    continue;
	}
	/* .data */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".data" ) == 0 ) {
	    AdjustSize(i);
	    elffile->data=ELFLoaderSectToMem(elffile,SecAlign(i),
					     SecOffset(i),SecSize(i),
					     ".data");
	    elffile->saddr[i]=elffile->data;
	    elffile->datndx=i;
#ifdef ELFDEBUG
	    ELFDEBUG(".data starts at %lx\n", elffile->data );
#endif
	    elffile->datsize=SecSize(i);
	    continue;
	}
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
							".data1" ) == 0 ) {
	    AdjustSize(i);
	    elffile->data1=ELFLoaderSectToMem(elffile,SecAlign(i),
					      SecOffset(i),SecSize(i),
					      ".data1");
	    elffile->saddr[i]=elffile->data1;
	    elffile->dat1ndx=i;
#ifdef ELFDEBUG
	    ELFDEBUG(".data1 starts at %lx\n", elffile->data1 );
#endif
	    elffile->dat1size=SecSize(i);
	    continue;
	}
	/* .sdata */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".sdata" ) == 0 ) {
	    AdjustSize(i);
	    elffile->sdata=ELFLoaderSectToMem(elffile,SecAlign(i),
					      SecOffset(i),SecSize(i),
					      ".sdata");
	    elffile->saddr[i]=elffile->sdata;
	    elffile->sdatndx=i;
#ifdef ELFDEBUG
	    ELFDEBUG(".sdata starts at %lx\n", elffile->sdata );
#endif
	    elffile->sdatsize=SecSize(i);
	    AdjustSize(i);
	    continue;
	}
	/* .bss */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".bss" ) == 0 ) {
	    AdjustSize(i);
	    if( SecSize(i) )
		elffile->bss = ELFLoaderSectCalloc(elffile,SecAlign(i),
						   SecSize(i));
	    else
		elffile->bss=NULL;
	    elffile->saddr[i]=elffile->bss;
	    elffile->bssndx=i;
#ifdef ELFDEBUG
	    ELFDEBUG(".bss starts at %lx\n", elffile->bss );
#endif
	    elffile->bsssize=SecSize(i);
	    continue;
	}
	/* .sbss */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".sbss" ) == 0 ) {
	    AdjustSize(i);
	    if( SecSize(i) )
		elffile->sbss = ELFLoaderSectCalloc(elffile,SecAlign(i),
						    SecSize(i));
	    else
		elffile->sbss=NULL;
	    elffile->saddr[i]=elffile->sbss;
	    elffile->sbssndx=i;
#ifdef ELFDEBUG
	    ELFDEBUG(".sbss starts at %lx\n", elffile->sbss );
#endif
	    elffile->sbsssize=SecSize(i);
	    continue;
	}
	/* .rodata */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rodata" ) == 0 ) {
	    AdjustSize(i);
	    elffile->rodata=ELFLoaderSectToMem(elffile,SecAlign(i),
					       SecOffset(i),SecSize(i),
					       ".rodata");
	    elffile->saddr[i]=elffile->rodata;
	    elffile->rodatndx=i;
#ifdef ELFDEBUG
	    ELFDEBUG(".rodata starts at %lx\n", elffile->rodata );
#endif
	    elffile->rodatsize=SecSize(i);
	    continue;
	}
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
							".rodata1" ) == 0 ) {
	    AdjustSize(i);
	    elffile->rodata1=ELFLoaderSectToMem(elffile,SecAlign(i),
						SecOffset(i),SecSize(i),
						".rodata1");
	    elffile->saddr[i]=elffile->rodata1;
	    elffile->rodat1ndx=i;
#ifdef ELFDEBUG
	    ELFDEBUG(".rodata1 starts at %lx\n", elffile->rodata1 );
#endif
	    elffile->rodat1size=SecSize(i);
	    continue;
	}
	/* .symtab */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".symtab" ) == 0 ) {
	    if (pass) continue;
	    elffile->symtab=(Elf_Sym *)_LoaderFileToMem(elffile->fd,SecOffset(i),
							SecSize(i),".symtab");
	    elffile->saddr[i]=(unsigned char *)elffile->symtab;
	    elffile->symndx=i;
	    elffile->symsize=SecSize(i);
#ifdef ELFDEBUG
	    ELFDEBUG(".symtab starts at %lx\n", elffile->symtab );
#endif
	    continue;
	}
	/* .strtab */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".strtab" ) == 0 ) {
	    if (pass) continue;
	    elffile->straddr=_LoaderFileToMem(elffile->fd,SecOffset(i),
					      SecSize(i),".strtab");
	    elffile->saddr[i]=(unsigned char *)elffile->straddr;
	    elffile->strndx=i;
	    elffile->strsize=SecSize(i);
#ifdef ELFDEBUG
	    ELFDEBUG(".strtab starts at %lx\n", elffile->straddr );
#endif
		continue;
		}
#if defined(i386) || defined(__alpha__) || defined(__ia64__) || defined(__arm__)
	/* .rel.text */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rel.text" ) == 0 ) {
	    if (pass) continue;
	    elffile->reltext=_LoaderFileToMem(elffile->fd,SecOffset(i),
					      SecSize(i),".rel.text");
	    elffile->saddr[i]=(unsigned char *)elffile->reltext;
	    elffile->reltxtndx=i;
	    elffile->reltxtsize=SecSize(i);
#ifdef ELFDEBUG
	    ELFDEBUG(".rel.text starts at %lx\n", elffile->reltext );
#endif
	    continue;
	}
	/* .rel.data */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rel.data" ) == 0 ) {
	    if (pass) continue;
	    elffile->reldata=_LoaderFileToMem(elffile->fd,SecOffset(i),
					      SecSize(i),".rel.data");
	    elffile->saddr[i]=(unsigned char *)elffile->reldata;
	    elffile->reldatndx=i;
	    elffile->reldatsize=SecSize(i);
#ifdef ELFDEBUG
	    ELFDEBUG(".rel.data starts at %lx\n", elffile->reldata );
#endif
	    continue;
	}
	/* .rel.rodata */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rel.rodata" ) == 0 ) {
	    if (pass) continue;
	    elffile->relrodata=_LoaderFileToMem(elffile->fd,SecOffset(i),
						SecSize(i),".rel.rodata");
	    elffile->saddr[i]=(unsigned char *)elffile->relrodata;
	    elffile->relrodatndx=i;
	    elffile->relrodatsize=SecSize(i);
#ifdef ELFDEBUG
	    ELFDEBUG(".rel.rodata starts at %lx\n", elffile->relrodata );
#endif
	    continue;
	}
#endif /* i386/alpha */
#if defined(__powerpc__) || defined(__mc68000__) || defined(__alpha__) || defined(__sparc__) || defined(__ia64__)
	/* .rela.text */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rela.text" ) == 0 ) {
	    if (pass) continue;
	    elffile->reltext=_LoaderFileToMem(elffile->fd,SecOffset(i),
					      SecSize(i),".rela.text");
	    elffile->saddr[i]=(unsigned char *)elffile->reltext;
	    elffile->reltxtndx=i;
	    elffile->reltxtsize=SecSize(i);
#ifdef ELFDEBUG
	    ELFDEBUG(".rela.text starts at %lx\n", elffile->reltext );
#endif
	    continue;
	}
	/* .rela.data */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rela.data" ) == 0 ) {
	    if (pass) continue;
	    elffile->reldata=_LoaderFileToMem(elffile->fd,SecOffset(i),
					      SecSize(i),".rela.data");
	    elffile->saddr[i]=(unsigned char *)elffile->reldata;
	    elffile->reldatndx=i;
	    elffile->reldatsize=SecSize(i);
#ifdef ELFDEBUG
	    ELFDEBUG(".rela.data starts at %lx\n", elffile->reldata );
#endif
	    continue;
	}
	/* .rela.sdata */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rela.sdata" ) == 0 ) {
	    if (pass) continue;
	    elffile->relsdata=_LoaderFileToMem(elffile->fd,SecOffset(i),
					       SecSize(i),".rela.sdata");
	    elffile->saddr[i]=(unsigned char *)elffile->relsdata;
	    elffile->relsdatndx=i;
	    elffile->relsdatsize=SecSize(i);
#ifdef ELFDEBUG
	    ELFDEBUG(".rela.sdata starts at %lx\n", elffile->relsdata );
#endif
	    continue;
	}
	/* .rela.rodata */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rela.rodata" ) == 0 ) {
	    if (pass) continue;
	    elffile->relrodata=_LoaderFileToMem(elffile->fd,SecOffset(i),
						SecSize(i),".rela.rodata");
	    elffile->saddr[i]=(unsigned char *)elffile->relrodata;
	    elffile->relrodatndx=i;
	    elffile->relrodatsize=SecSize(i);
#ifdef ELFDEBUG
	    ELFDEBUG(".rela.rodata starts at %lx\n", elffile->relrodata );
#endif
	    continue;
	}
#endif /* __powerpc__ || __mc68000__ */
	/* .shstrtab */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".shstrtab" ) == 0 ) {
	    continue;
	}
	/* .comment */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".comment" ) == 0 ) {
	    continue;
	}
	/* .debug */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".debug" ) == 0 ) {
	    continue;
	}
	/* .line */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".line" ) == 0 ) {
	    continue;
	}
	/* .note */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".note" ) == 0 ) {
	    continue;
	}
	/* .rel.debug */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rel.debug" ) == 0 ) {
	    continue;
	}
	/* .rel.line */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rel.line" ) == 0 ) {
	    continue;
	}
	/* .stab */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".stab" ) == 0 ) {
	    continue;
	}
	/* .rel.stab */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rel.stab" ) == 0 ) {
	    continue;
	}
	/* .rela.stab */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rela.stab" ) == 0 ) {
	    continue;
	}
	/* .stabstr */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".stabstr" ) == 0 ) {
	    continue;
	}
	/* .stab.* */
	if( strncmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".stab.", strlen(".stab.") ) == 0 ) {
	    continue;
	}
#if defined(__powerpc__) || defined(__mc68000__)
	/* .rela.tdesc */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rela.tdesc" ) == 0 ) {
	    continue;
	}
	/* .rela.debug_line */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rela.debug_line" ) == 0 ) {
	    continue;
	}
	/* .tdesc */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".tdesc" ) == 0 ) {
	    continue;
	}
	/* .debug_line */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".debug_line" ) == 0 ) {
	    continue;
	}
	/* $0001300 */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   "$0001300" ) == 0 ) {
	    continue;
	}
#endif
#if defined(__alpha__) || defined(__ia64__)
	/* .got */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".got" ) == 0 ) {
	    continue;
	}
#endif
#if defined(__alpha__)
	/* .mdebug */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".mdebug" ) == 0 ) {
	    continue;
	}
#endif
#if defined(__ia64__)
	/* .plt */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".plt" ) == 0 ) {
	    continue;
	}
	/* .IA_64.unwind, .IA_64.unwind_info and .rela.IA_64.unwind */
	/* FIXME I believe we don't need these */
	if( strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".IA_64.unwind" ) == 0
	   || strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rela.IA_64.unwind" ) == 0
	   || strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".IA_64.unwind_info" ) == 0
	   || strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".debug_abbrev" ) == 0
	   || strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".debug_info" ) == 0
	   || strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rela.debug_info" ) == 0
	   || strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".debug_line" ) == 0
	   || strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rela.debug_line" ) == 0
	   || strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".debug_pubnames" ) == 0
	   || strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rela.debug_pubnames" ) == 0
	   || strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".debug_aranges" ) == 0
	   || strcmp(ElfGetSectionName(elffile, elffile->sections[i].sh_name),
		   ".rela.debug_aranges" ) == 0
		) {
	    continue;
	}
#endif
	if (pass)
	    ErrorF("Not loading %s\n",
		   ElfGetSectionName(elffile, elffile->sections[i].sh_name) );
    }
}

/*
 * Public API for the ELF implementation of the loader.
 */
void *
ELFLoadModule(modrec, elffd, ppLookup)
loaderPtr	modrec;
int	elffd;
LOOKUP **ppLookup;
{
    ELFModulePtr elffile;
    Elf_Ehdr   *header;
    ELFRelocPtr  elf_reloc, tail;
    void	*v;
    LDRModulePtr elfmod;
    int		totalsize, maxalign, i;
    unsigned short *secttable;
    LOOKUP	*pLookup;

    ldrCommons = 0;
    nCommons = 0;

    if ((elffile = xf86loadercalloc(1, sizeof(ELFModuleRec))) == NULL) {
	ErrorF( "Unable to allocate ELFModuleRec\n" );
	return NULL;
    }

    elffile->handle=modrec->handle;
    elffile->module=modrec->module;
    elffile->fd=elffd;
    v=elffile->funcs=modrec->funcs;

/*
 *  Get the ELF header
 */
    elffile->header=
	(Elf_Ehdr*)_LoaderFileToMem(elffd, 0, sizeof(Elf_Ehdr), "header");
    header=(Elf_Ehdr *)elffile->header;

/*
 * Get the section table
 */
    elffile->numsh=header->e_shnum;
    elffile->secsize=(header->e_shentsize*header->e_shnum);
    elffile->sections=
	(Elf_Shdr *)_LoaderFileToMem(elffd, header->e_shoff, elffile->secsize,
				     "sections");
#if defined(__alpha__) || defined(__ia64__)
    /*
     * Need to allocate space for the .got section which will be
     * fabricated later
     */
    elffile->gotndx=header->e_shnum;
    header->e_shnum++;
#if defined(__ia64__)
    elffile->pltndx=header->e_shnum;
    header->e_shnum++;
#endif
    elffile->numsh=header->e_shnum;
    elffile->secsize=(header->e_shentsize*header->e_shnum);
    elffile->sections=xf86loaderrealloc(elffile->sections,elffile->secsize);
#endif
    elffile->saddr=xf86loadercalloc(elffile->numsh, sizeof(unsigned char *));

#if defined(__alpha__) || defined(__ia64__)
    /*
     * Manually fill in the entry for the .got section so ELFCollectSections()
     * will be able to find it.
     */
    elffile->sections[elffile->gotndx].sh_name=SecSize(header->e_shstrndx)+1;
    elffile->sections[elffile->gotndx].sh_type=SHT_PROGBITS;
    elffile->sections[elffile->gotndx].sh_flags=SHF_WRITE|SHF_ALLOC;
    elffile->sections[elffile->gotndx].sh_size=0;
    elffile->sections[elffile->gotndx].sh_addralign=8;
    /* Add room to copy ".got", and maintain alignment */
    SecSize(header->e_shstrndx)+=8;
#endif
#if defined(__ia64__)
    /*
     * Manually fill in the entry for the .plt section so ELFCollectSections()
     * will be able to find it.
     */
    elffile->sections[elffile->pltndx].sh_name=SecSize(header->e_shstrndx)+1;
    elffile->sections[elffile->pltndx].sh_type=SHT_PROGBITS;
    elffile->sections[elffile->pltndx].sh_flags=SHF_EXECINSTR|SHF_ALLOC;
    elffile->sections[elffile->pltndx].sh_size=0;
    elffile->sections[elffile->pltndx].sh_addralign=32;
    /* Add room to copy ".plt", and maintain alignment */
    SecSize(header->e_shstrndx)+=32;
#endif

/*
 * Get the section header string table
 */
    elffile->shstrsize = SecSize(header->e_shstrndx);
    elffile->shstraddr =
	_LoaderFileToMem(elffd, SecOffset(header->e_shstrndx),
			 SecSize(header->e_shstrndx), ".shstrtab");
    elffile->shstrndx = header->e_shstrndx;
#if defined(__alpha__) || defined(__ia64__)
    /*
     * Add the string for the .got section
     */
    strcpy((char*)(elffile->shstraddr+elffile->sections[elffile->gotndx].sh_name),
	   ".got");
#endif
#if defined(__ia64__)
    /*
     * Add the string for the .plt section
     */
    strcpy((char*)(elffile->shstraddr+elffile->sections[elffile->pltndx].sh_name),
	   ".plt");
#endif

/*
 * Load some desired sections, compute size of the remaining ones
 */
    totalsize = 0;
    maxalign = 0;
    ELFCollectSections(elffile, 0, &totalsize, &maxalign);

    if( elffile->straddr == NULL || elffile->strsize == 0 ) {
	ErrorF("No symbols found in this module\n");
	ELFUnloadModule(elffile);
	return NULL;
    }

/*
 * add symbols
 */
    *ppLookup = pLookup = ELF_GetSymbols(elffile, &secttable);

/*
 * Do relocations
 */
    if (elffile->reltxtndx) {
	elf_reloc = ELFCollectRelocations(elffile,elffile->reltxtndx);
	if (elf_reloc) {
	    for (tail = elf_reloc; tail->next; tail = tail->next)
		;
	    tail->next = _LoaderGetRelocations(v)->elf_reloc;
	    _LoaderGetRelocations(v)->elf_reloc = elf_reloc;
	}
    }
    if (elffile->reldatndx) {
	elf_reloc = ELFCollectRelocations(elffile,elffile->reldatndx);
	if (elf_reloc) {
	    for (tail = elf_reloc; tail->next; tail = tail->next)
		;
	    tail->next = _LoaderGetRelocations(v)->elf_reloc;
	    _LoaderGetRelocations(v)->elf_reloc = elf_reloc;
	}
    }
    if (elffile->relrodatndx) {
	elf_reloc = ELFCollectRelocations(elffile,elffile->relrodatndx);
	if (elf_reloc) {
	    for (tail = elf_reloc; tail->next; tail = tail->next)
		;
	    tail->next = _LoaderGetRelocations(v)->elf_reloc;
	    _LoaderGetRelocations(v)->elf_reloc = elf_reloc;
	}
    }
    if (elffile->relsdatndx) {
	elf_reloc = ELFCollectRelocations(elffile,elffile->relsdatndx);
	if (elf_reloc) {
	    for (tail = elf_reloc; tail->next; tail = tail->next)
		;
	    tail->next = _LoaderGetRelocations(v)->elf_reloc;
	    _LoaderGetRelocations(v)->elf_reloc = elf_reloc;
	}
    }

#if defined(__ia64__)
    totalsize += (elffile->sections[elffile->pltndx].sh_addralign - 1);
    totalsize &= ~(elffile->sections[elffile->pltndx].sh_addralign - 1);
    totalsize += elffile->pltsize;
    if (maxalign < elffile->sections[elffile->pltndx].sh_addralign)
	maxalign = elffile->sections[elffile->pltndx].sh_addralign;
#endif

    /* Space for COMMON */
    totalsize = (totalsize + 7) & ~7;
    totalsize += ElfCOMMONSize();

#ifdef MergeSectionAlloc
    elffile->basesize = totalsize + maxalign;
    elffile->base = xf86loadermalloc(elffile->basesize);
    if (elffile->base == NULL) {
	ErrorF( "Unable to allocate ELF sections\n" );
	return NULL;
    }
    mprotect(elffile->base, elffile->basesize, PROT_READ|PROT_WRITE|PROT_EXEC);
    elffile->baseptr = ((long)elffile->base + (maxalign - 1)) & ~(maxalign - 1);
#endif

#if defined(__alpha__) || defined(__ia64__)
    if (! ELFCreateGOT(elffile, maxalign))
	return NULL;
#endif
#if defined(__ia64__)
    ELFCreatePLT(elffile);
#endif

    ELFCollectSections(elffile, 1, NULL, NULL);

    for (i = 0; pLookup[i].symName; i++)
	if (secttable[i]) {
	    pLookup[i].offset = (funcptr)((long)pLookup[i].offset + (long)elffile->saddr[secttable[i]]);
#ifdef ELFDEBUG
	    ELFDEBUG("Finalizing symbol %lx %s\n",
		     pLookup[i].offset, pLookup[i].symName);
#endif
	}
    xf86loaderfree(secttable);

#if defined(__ia64__)
    ELFCreateOPD(elffile);
#endif

    if (! ElfCreateCOMMON(elffile, *ppLookup))
	return NULL;

    /* Record info for gdb - if we can't allocate the loader record fail
       silently (the user will find out soon enough that there's no VM left */
    if ((elfmod = xf86loadercalloc(1, sizeof(LDRModuleRec))) != NULL) {
	elfmod->name = strdup(modrec->name);
	elfmod->namelen = strlen(modrec->name);
	elfmod->version = 1;
	elfmod->text = elffile->text;
	elfmod->data = elffile->data;
	elfmod->rodata = elffile->rodata;
	elfmod->bss = elffile->bss;
	elfmod->next = ModList;
	elfmod->commons = ldrCommons;
	elfmod->commonslen = nCommons;

	ModList = elfmod;

	/* Tell GDB something interesting happened */
	_loader_debug_state();
    }
    return (void *)elffile;
}

void
ELFResolveSymbols(mod)
void *mod;
{
    ELFRelocPtr newlist, p, tmp;

    /* Try to relocate everything.  Build a new list containing entries
     * which we failed to relocate.  Destroy the old list in the process.
     */
    newlist = 0;
    for (p = _LoaderGetRelocations(mod)->elf_reloc; p; ) {
#ifdef ELFDEBUG
	ErrorF("ResolveSymbols: file %lx, sec %d, r_offset 0x%x, r_info 0x%lx\n",
	       p->file, p->secn, p->rel->r_offset, p->rel->r_info);
#endif
	tmp = Elf_RelocateEntry(p->file, p->secn, p->rel, FALSE);
	if (tmp) {
	    /* Failed to relocate.  Keep it in the list. */
	    tmp->next = newlist;
	    newlist = tmp;
	}
	tmp = p;
	p = p->next;
	xf86loaderfree(tmp);
    }
    _LoaderGetRelocations(mod)->elf_reloc=newlist;
}

int
ELFCheckForUnresolved(mod)
void	*mod;
{
    ELFRelocPtr	erel;
    char	*name;
    int flag, fatalsym=0;

    if ((erel = _LoaderGetRelocations(mod)->elf_reloc) == NULL)
	return 0;

    while( erel ) {
	Elf_RelocateEntry(erel->file, erel->secn, erel->rel, TRUE);
	name = ElfGetSymbolName(erel->file, ELF_R_SYM(erel->rel->r_info));
	flag = _LoaderHandleUnresolved(
	    name, _LoaderHandleToName(erel->file->handle));
	if(flag) fatalsym = 1;
	erel=erel->next;
    }
    return fatalsym;
}

void
ELFUnloadModule(modptr)
void *modptr;
{
    ELFModulePtr elffile = (ELFModulePtr)modptr;
    ELFRelocPtr  relptr, reltptr, *brelptr;

/*
 * Delete any unresolved relocations
 */

    relptr=_LoaderGetRelocations(elffile->funcs)->elf_reloc;
    brelptr=&(_LoaderGetRelocations(elffile->funcs)->elf_reloc);

    while(relptr) {
	if( relptr->file == elffile ) {
	    *brelptr=relptr->next;	/* take it out of the list */
	    reltptr=relptr;		/* save pointer to this node */
	    relptr=relptr->next;	/* advance the pointer */
	    xf86loaderfree(reltptr);		/* free the node */
	}
	else {
	    brelptr=&(relptr->next);
	    relptr=relptr->next;	/* advance the pointer */
	    }
    }

/*
 * Delete any symbols in the symbols table.
 */

    LoaderHashTraverse((void *)elffile, ELFhashCleanOut);

/*
 * Free the sections that were allocated.
 */
#define CheckandFree(ptr,size)  if(ptr) xf86loaderfree(ptr)
#define CheckandFreeFile(ptr,size)  if(ptr) _LoaderFreeFileMem((ptr),(size))

    CheckandFreeFile(elffile->straddr,elffile->strsize);
    CheckandFreeFile(elffile->symtab,elffile->symsize);
#ifdef MergeSectionAlloc
    CheckandFree(elffile->base,elffile->basesize);
#if defined(__alpha__) || defined(__ia64__)
    if (elffile->shared_got) {
	elffile->shared_got->nuses--;
	if (!elffile->shared_got->nuses) {
	    ELFGotPtr *pgot = &ELFSharedGOTs;
	    while (*pgot && *pgot != elffile->shared_got)
		pgot = &(*pgot)->next;
	    if (*pgot)
		*pgot = elffile->shared_got->next;
	    xf86loaderfree(elffile->shared_got);
	}
    }
#endif
#else
    CheckandFreeFile(elffile->text,elffile->txtsize);
    CheckandFreeFile(elffile->data,elffile->datsize);
    CheckandFreeFile(elffile->data1,elffile->dat1size);
    CheckandFreeFile(elffile->sdata,elffile->sdatsize);
    CheckandFree(elffile->bss,elffile->bsssize);
    CheckandFree(elffile->sbss,elffile->sbsssize);
    CheckandFreeFile(elffile->rodata,elffile->rodatsize);
    CheckandFreeFile(elffile->rodata1,elffile->rodat1size);
    CheckandFree(elffile->common,elffile->comsize);
#if defined(__alpha__) || defined(__ia64__)
    CheckandFree(elffile->got,elffile->gotsize);
#endif
#if defined(__ia64__)
    CheckandFree(elffile->plt,elffile->pltsize);
#endif
#endif
#if defined(__alpha__) || defined(__ia64__)
    {
	ELFGotEntryPtr gotent;
	while((gotent = elffile->got_entries)) {
	    elffile->got_entries = gotent->next;
	    xf86loaderfree(gotent);
	}
    }
#endif
#if defined(__ia64__)
    {
	ELFPltEntryPtr pltent;
	while ((pltent = elffile->plt_entries)) {
	    elffile->plt_entries = pltent->next;
	    xf86loaderfree(pltent);
	}
    }
    {
	ELFOpdPtr opdent;
	while ((opdent = elffile->opd_entries)) {
	    elffile->opd_entries = opdent->next;
	    xf86loaderfree(opdent);
	}
    }
#endif
    CheckandFreeFile(elffile->reltext,elffile->reltxtsize);
    CheckandFreeFile(elffile->reldata,elffile->reldatsize);
    CheckandFreeFile(elffile->relrodata,elffile->relrodatsize);
    CheckandFreeFile(elffile->relsdata,elffile->relsdatsize);
/*
 * Free the section table, section pointer array, and section names
 */
    _LoaderFreeFileMem(elffile->sections,elffile->secsize);
    xf86loaderfree(elffile->saddr);
    _LoaderFreeFileMem(elffile->header,sizeof(Elf_Ehdr));
    _LoaderFreeFileMem(elffile->shstraddr,elffile->shstrsize);

/*
 * Free the ELFModuleRec
 */
    xf86loaderfree(elffile);

    return;
}

char *
ELFAddressToSection(void *modptr, unsigned long address)
{
    ELFModulePtr elffile = (ELFModulePtr)modptr;
    int i;

    for( i=1; i<elffile->numsh; i++) {
	if( address >= (unsigned long)elffile->saddr[i] &&
	    address <= (unsigned long)elffile->saddr[i]+SecSize(i) ) {
		return ElfGetSectionName(elffile, elffile->sections[i].sh_name);
		}
	}
    return NULL;
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/elfloader.c,v 1.62 2003/11/06 18:38:13 tsi Exp $ */
a25 1
#ifndef __UNIXOS2__
a26 1
#endif
d30 1
a30 1
# include <fcntl.h>
d32 1
a32 1
# include <sys/fcntl.h>
a34 3
#if defined(linux) && defined (__ia64__)
#include <sys/mman.h>
#endif
d37 4
a40 4
# include <debug/malloc.h>
# define Xalloc(size) malloc(size)
# define Xcalloc(size) calloc(1,(size))
# define Xfree(size) free(size)
a51 10
#ifndef LOADERDEBUG
#define LOADERDEBUG 0
#endif

#if LOADERDEBUG
# define ELFDEBUG ErrorF
#endif

#if defined(__ia64__)

d53 2
a54 57
 * R_IA64_LTOFF22X and R_IA64_LDXMOV are relocation optimizations for
 * IA64. Conforming implementations must recognize them and may either
 * implement the optimization or may fallback to previous
 * non-optimized behavior by treating R_IA64_LTOFF22X as a
 * R_IA64_LTOFF22 and ignoring R_IA64_LDXMOV. The
 * IA64_LDX_OPTIMIZATION conditional controls the fallback behavior,
 * if defined the optimizations are performed.
 *
 * To implement the optimization we want to change is the sequence on
 * the left to that on the right, without regard to any intervening
 * instructions:
 * 
 * 1)  addl    t1=@@ltoff(var),gp    ==>    addl    t1=@@gprel(var),gp
 * 2)  ld8     t2=[t1]              ==>    mov     t2=t1
 * 3)  ld8     loc0=[t2]            ==>    ld8     loc0=[t2]
 * 
 * The relocations that match the above instructions are:
 * 
 * 1)  R_IA64_LTOFF22               ==>    R_IA64_LTOFF22X
 * 2)  --                           ==>    R_IA64_LDXMOV
 * 3)  --                           ==>    --
 *
 * First lets look at left hand column to understand the original
 * mechanism. The virtual address of a symbol is stored in the GOT,
 * when that symbol is referenced the following sequence occurs,
 * instruction 1 loads the address of the GOT entry containing the
 * virtural address of the symbol into t1. Instruction 2 loads the
 * virtual address of the symbol into t2 by dereferencing t1. Finally
 * the symbol is loaded in instruction 3 by dereferencing its virtual
 * address in t2.
 * 
 * The optimization that LTOFF22X/LDXMOV introduces is based on the
 * observation we are doing an extra load (instruction 2) if we can
 * generate the virtual address for the symbol without doing a lookup in
 * the GOT. This is possible if the virtual address of the symbol can be
 * computed via GP relative addressing. In other words the virtual
 * address of the symbol is a fixed offset from the GP. This fixed offset
 * must be within the limits of the signed 22 bit immediate offset in the
 * ld8 instruction, otherwise the original indirect GOT lookup must be
 * performed (LTOFF22).
 * 
 * If we can use GP relative addressing for the symbol then the
 * instruction that loaded the virtual address of the symbol into t2 must
 * also be patched, hence the introduction of the LDXMOV relocation. The
 * LDXMOV essentially turns the GOT lookup into a no-op by changing the
 * ld8 into a register move that preserves the register location of the
 * symbol's virtual address (e.g. t2).
 * 
 * The important point to recognize when implementing the LTOFF22X/LDXMOV
 * optimization is that relocations are interdependent, the LDXMOV is
 * only applied if the LTOFF22X is applied. It is also worth noting that
 * there is no relationship between LDXMOV relocations and LTOFF22X in
 * the ELF relocation section other than they share the same
 * symbol+addend value.
 */

#define IA64_LDX_OPTIMIZATION 1
d56 1
d59 3
a61 26
# if defined (__ia64__) || defined (__sparc__)
#  define MergeSectionAlloc
# endif
#endif

#if defined (DoMMAPedMerge)
# include <sys/mman.h>
# define MergeSectionAlloc
# define MMAP_PROT	(PROT_READ | PROT_WRITE | PROT_EXEC)
# if !defined(linux)
#  error    No MAP_ANON?
# endif
# if !defined (__AMD64__) || !defined(__linux__)
# define MMAP_FLAGS     (MAP_PRIVATE | MAP_ANON)
# else
# define MMAP_FLAGS     (MAP_PRIVATE | MAP_ANON | MAP_32BIT)
# endif
# if defined (MmapPageAlign)
#  define MMAP_ALIGN(size)    do { \
     int pagesize = getpagesize(); \
     size = ( size + pagesize - 1) / pagesize; \
     size *= pagesize; \
   } while (0);
# else
#  define MMAP_ALIGN(size)
# endif
a65 1
    defined (__AMD64__) || \
a78 1

d84 1
a84 1
# if defined (__alpha__) || defined (__ia64__)
d91 3
a93 3
    Elf_Rela *rel;
    int offset;
    struct _elf_GOT_Entry *next;
d97 5
a101 5
    unsigned int size;
    unsigned int nuses;
    unsigned char *freeptr;
    struct _elf_GOT *next;
    unsigned char section[1];
d104 1
a104 1
#  ifdef MergeSectionAlloc
d106 2
a107 2
#  endif
# endif
d109 1
a109 1
# if defined (__ia64__)
d115 4
a118 4
    Elf_Rela *rel;
    int offset;
    int gotoffset;
    struct _elf_PLT_Entry *next;
d126 4
a129 4
    LOOKUP *l;
    int index;
    int offset;
    struct _elf_OPD *next;
d131 1
a131 1
# endif
a143 1

d154 1
a154 2
    defined(__ia64__) || \
    defined(__AMD64__)
d157 1
a157 1
typedef Elf_Rel Elf_Rel_t;
a159 11
typedef struct {
    void *saddr;
    char *name;
    int ndx;
    int size;
    int flags;
} LoadSection;

#define RELOC_SECTION 0x1
#define LOADED_SECTION 0x2

d165 40
a204 13
typedef struct {
    int handle;
    int module;
    int fd;
    loader_funcs *funcs;
    Elf_Ehdr *header;		/* file header */
    int numsh;
    Elf_Shdr *sections;		/* Address of the section header table */
    int secsize;		/* size of the section table */
    unsigned char **saddr;	/* Start addresss of the section pointer table */
    unsigned char *shstraddr;	/* Start address of the section header string table */
    int shstrndx;		/* index of the section header string table */
    int shstrsize;		/* size of the section header string table */
d206 6
a211 6
    unsigned char *got;		/* Start address of the .got section */
    ELFGotEntryPtr got_entries;	/* List of entries in the .got section */
    int gotndx;			/* index of the .got section */
    int gotsize;		/* actual size of the .got section */
    ELFGotPtr shared_got;	/* Pointer to ELFGotRec if shared */
#endif				/*(__alpha__) || (__ia64__) */
d213 28
a240 20
    ELFOpdPtr opd_entries;	/* List of entries in the .opd section */
    unsigned char *plt;		/* Start address of the .plt section */
    ELFPltEntryPtr plt_entries;	/* List of entries in the .plt section */
    int pltndx;			/* index of the .plt section */
    int pltsize;		/* size of the .plt section */
#endif /*__ia64__*/
    Elf_Sym *symtab;		/* Start address of the .symtab section */
    int symndx;			/* index of the .symtab section */
    unsigned char *common;	/* Start address of the SHN_COMMON space */
    int comsize;		/* size of the SHN_COMMON space */

    unsigned char *base;	/* Alloced address of section block */
    unsigned long baseptr;	/* Pointer to next free space in base */
    int basesize;		/* Size of that allocation */
    unsigned char *straddr;	/* Start address of the string table */
    int strndx;			/* index of the string table */
    int strsize;		/* size of the string table */
    LoadSection *lsection;
    int lsectidx;
} ELFModuleRec, *ELFModulePtr;
d247 4
a250 4
    Elf_Rel_t *rel;
    ELFModulePtr file;
    Elf_Word secn;
    struct _elf_reloc *next;
d260 2
a261 2
    Elf_Sym *sym;
    struct _elf_COMMON *next;
d264 1
a264 1
static ELFCommonPtr listCOMMON = NULL;
d274 1
a274 1
static int ElfCreateCOMMON(ELFModulePtr, LOOKUP *);
d278 1
a278 2
static ELFRelocPtr Elf_RelocateEntry(ELFModulePtr, Elf_Word, Elf_Rel_t *,
				     int);
a281 1

d293 1
a293 2
    IA64_OPND_TGT25C,
    IA64_OPND_LDXMOV
d296 1
a296 1
#endif /*__ia64__*/
d300 6
a305 2
ELFLoaderSectToMem(ELFModulePtr elffile, int align, unsigned long offset,
		   int size, char *label)
a307 1

d316 4
a319 1
ELFLoaderSectCalloc(ELFModulePtr elffile, int align, int size)
a321 1

d325 1
a325 3
#ifndef DoMMAPedMerge
    memset(ret, 0, size);	/* mmap() does this for us */
#endif
d328 2
a329 2
#else /* MergeSectionAlloc */
# define ELFLoaderSectToMem(elffile,align,offset,size,label)	\
d331 1
a331 1
# define ELFLoaderSectCalloc(elffile,align,size) xf86loadercalloc(1,size)
d338 1
d340 3
a342 1
ELFhashCleanOut(void *voidptr, itemPtr item)
a344 1

d352 4
a355 1
ElfDelayRelocation(ELFModulePtr elffile, Elf_Word secn, Elf_Rel_t *rel)
d357 1
a357 1
    ELFRelocPtr reloc;
d360 1
a360 1
	ErrorF("ElfDelayRelocation() Unable to allocate memory!!!!\n");
d363 4
a366 4
    reloc->file = elffile;
    reloc->secn = secn;
    reloc->rel = rel;
    reloc->next = 0;
d368 1
a368 1
    ELFDEBUG("ElfDelayRelocation %p: file %p, sec %d,"
d370 2
a371 3
	     (void *)reloc, (void *)elffile, secn,
	     (unsigned long)rel->r_offset, rel->r_info);
# if defined(__powerpc__) || \
d375 1
a375 2
    defined(__ia64__) || \
    defined(__AMD64__)
d377 1
a377 1
# endif
d387 2
a388 1
ElfAddCOMMON(Elf_Sym *sym)
d393 1
a393 1
	ErrorF("ElfAddCOMMON() Unable to allocate memory!!!!\n");
d396 2
a397 2
    common->sym = sym;
    common->next = 0;
d404 1
a404 1
    int size = 0;
d408 1
a408 1
	size += common->sym->st_size;
a410 1
    defined(__AMD64__) || \
d414 1
a414 1
	size = (size + 7) & ~0x7;
d421 3
a423 1
ElfCreateCOMMON(ELFModulePtr elffile, LOOKUP *pLookup)
d425 2
a426 2
    int numsyms = 0, size = 0, l = 0;
    int offset = 0, firstcommon = 0;
d433 1
a433 1
	size += common->sym->st_size;
a435 1
    defined(__AMD64__) || \
d439 1
a439 1
	size = (size + 7) & ~0x7;
d446 1
a446 1
	     numsyms, size);
d449 3
a451 3
    elffile->comsize = size;
    if ((elffile->common = ELFLoaderSectCalloc(elffile, 8, size)) == NULL) {
	ErrorF("ElfCreateCOMMON() Unable to allocate memory!!!!\n");
d455 3
a457 2
    if (DebuggerPresent) {
	ldrCommons = xf86loadermalloc(numsyms * sizeof(LDRCommon));
d461 4
a464 3
    for (l = 0; pLookup[l].symName; l++) ;
    firstcommon = l;

d469 2
a470 2
    while (listCOMMON) {
	common = listCOMMON;
d475 2
a476 2
		xf86loaderstrdup(ElfGetString(elffile, common->sym->st_name));
	pLookup[l].offset = (funcptr) (elffile->common + offset);
d478 2
a479 2
	ELFDEBUG("Adding common %p %s\n",
		 (void *)pLookup[l].offset, pLookup[l].symName);
d481 1
a481 1

d483 5
a487 4
	if (DebuggerPresent && ldrCommons) {
	    ldrCommons[l - firstcommon].addr = (void *)pLookup[l].offset;
	    ldrCommons[l - firstcommon].name = pLookup[l].symName;
	    ldrCommons[l - firstcommon].namelen = strlen(pLookup[l].symName);
d489 2
a490 2
	listCOMMON = common->next;
	offset += common->sym->st_size;
a492 1
    defined(__AMD64__) || \
d496 1
a496 1
	offset = (offset + 7) & ~0x7;
d502 1
a502 1
    pLookup[l].symName = NULL;	/* Terminate the list. */
d506 1
d511 4
a514 1
ElfGetStringIndex(ELFModulePtr file, int offset, int index)
d516 2
a517 2
    if (!offset || !index)
	return "";
d519 1
a519 1
    return (char *)(file->saddr[index] + offset);
d523 3
a525 1
ElfGetString(ELFModulePtr file, int offset)
d527 1
a527 1
    return ElfGetStringIndex(file, offset, file->strndx);
d531 3
a533 1
ElfGetSectionName(ELFModulePtr file, int offset)
d535 1
a535 1
    return (char *)(file->shstraddr + offset);
d538 2
d548 4
a551 1
ElfGetSymbolNameIndex(ELFModulePtr elffile, int index, int secndx)
d553 1
a553 1
    Elf_Sym *syms;
d556 1
a556 1
    ELFDEBUG("ElfGetSymbolNameIndex(%x,%x) ", index, secndx);
d559 1
a559 1
    syms = (Elf_Sym *) elffile->saddr[secndx];
d562 2
a563 2
    ELFDEBUG("%s ", ElfGetString(elffile, syms[index].st_name));
    ELFDEBUG("%x %x ", ELF_ST_BIND(syms[index].st_info),
d565 1
a565 1
    ELFDEBUG("%lx\n", (unsigned long)syms[index].st_value);
d568 1
a568 1
    return ElfGetString(elffile, syms[index].st_name);
d572 3
a574 1
ElfGetSymbolName(ELFModulePtr elffile, int index)
d580 8
a587 6
ElfGetSymbolValue(ELFModulePtr elffile, int index)
{
    Elf_Sym *syms;
    Elf_Addr symval = 0;	/* value of the indicated symbol */
    char *symname = NULL;	/* name of symbol in relocation */
    itemPtr symbol = NULL;	/* name/value of symbol */
d589 1
a589 1
    syms = (Elf_Sym *) elffile->saddr[elffile->symndx];
d591 11
a601 8
    switch (ELF_ST_TYPE(syms[index].st_info)) {
    case STT_NOTYPE:
    case STT_OBJECT:
    case STT_FUNC:
	switch (ELF_ST_BIND(syms[index].st_info)) {
	case STB_LOCAL:
	    symval = (Elf_Addr) (elffile->saddr[syms[index].st_shndx] +
				 syms[index].st_value);
d603 30
a632 13
	    if (ELF_ST_TYPE(syms[index].st_info) == STT_FUNC) {
		ELFOpdPtr opdent;

		for (opdent = elffile->opd_entries; opdent;
		     opdent = opdent->next)
		    if (opdent->index == index)
			break;
		if (opdent) {
		    ((unsigned long *)(elffile->got + opdent->offset))[0] =
			    symval;
		    ((unsigned long *)(elffile->got + opdent->offset))[1] =
			    (long)elffile->got;
		    symval = (Elf_Addr) (elffile->got + opdent->offset);
d634 4
a637 1
	    }
d640 5
a644 9
	case STB_GLOBAL:
	case STB_WEAK:		/* STB_WEAK seems like a hack to cover for
				 * some other problem */
	    symname = ElfGetString(elffile, syms[index].st_name);
	    symbol = LoaderHashFind(symname);
	    if (symbol == 0) {
		return 0;
	    }
	    symval = (Elf_Addr) symbol->address;
d646 3
d650 3
a652 3
	    symval = 0;
	    ErrorF("ElfGetSymbolValue(), unhandled symbol scope %x\n",
		   ELF_ST_BIND(syms[index].st_info));
a654 21
#ifdef ELFDEBUG
	ELFDEBUG("%p\t", (void *)symbol);
	ELFDEBUG("%lx\t", (unsigned long)symval);
	ELFDEBUG("%s\n", symname ? symname : "NULL");
#endif
	break;
    case STT_SECTION:
	symval = (Elf_Addr) elffile->saddr[syms[index].st_shndx];
#ifdef ELFDEBUG
	ELFDEBUG("ST_SECTION %lx\n", (unsigned long)symval);
#endif
	break;
    case STT_FILE:
    case STT_LOPROC:
    case STT_HIPROC:
    default:
	symval = 0;
	ErrorF("ElfGetSymbolValue(), unhandled symbol type %x\n",
	       ELF_ST_TYPE(syms[index].st_info));
	break;
    }
d667 3
a669 1
ElfGetPltAddr(ELFModulePtr elffile, int index)
d671 2
a672 2
    Elf_Sym *syms;
    Elf_Addr symval = 0;	/* value of the indicated symbol */
d676 1
a676 1
    syms = (Elf_Sym *) elffile->saddr[elffile->symndx];
d678 13
a690 10
    switch (ELF_ST_TYPE(syms[index].st_info)) {
    case STT_NOTYPE:
    case STT_OBJECT:
    case STT_FUNC:
	switch (ELF_ST_BIND(syms[index].st_info)) {
	case STB_GLOBAL:
	    symname = ElfGetString(elffile, syms[index].st_name);
	    symbol = LoaderHashFind(symname);
	    if (symbol == 0)
		return 0;
d706 25
a730 13
	    symbol->code.plt[0] = 0x3d80;	/* lis     r12 */
	    symbol->code.plt[1] =
		    (((Elf_Addr) symbol->address) & 0xffff0000) >> 16;
	    symbol->code.plt[2] = 0x618c;	/* ori     r12,r12 */
	    symbol->code.plt[3] = (((Elf_Addr) symbol->address) & 0xffff);
	    symbol->code.plt[4] = 0x7d89;	/* mtcr    r12 */
	    symbol->code.plt[5] = 0x03a6;
	    symbol->code.plt[6] = 0x4e80;	/* bctr */
	    symbol->code.plt[7] = 0x0420;
	    symbol->address = (char *)&symbol->code.plt[0];
	    symval = (Elf_Addr) symbol->address;
	    ppc_flush_icache(&symbol->code.plt[0]);
	    ppc_flush_icache(&symbol->code.plt[6]);
d732 4
d737 4
a740 3
	    symval = 0;
	    ErrorF("ElfGetPltAddr(), unhandled symbol scope %x\n",
		   ELF_ST_BIND(syms[index].st_info));
a742 17
# ifdef ELFDEBUG
	ELFDEBUG("ElfGetPlt: symbol=%lx\t", symbol);
	ELFDEBUG("newval=%lx\t", symval);
	ELFDEBUG("name=\"%s\"\n", symname ? symname : "NULL");
# endif
	break;
    case STT_SECTION:
    case STT_FILE:
    case STT_LOPROC:
    case STT_HIPROC:
    default:
	symval = 0;
	ErrorF("ElfGetPltAddr(), Unexpected symbol type %x",
	       ELF_ST_TYPE(syms[index].st_info));
	ErrorF("for a Plt request\n");
	break;
    }
d752 3
a754 1
ElfAddGOT(ELFModulePtr elffile, Elf_Rel_t *rel)
d758 1
a758 1
# ifdef ELFDEBUG
d760 1
a760 1
	Elf_Sym *sym;
d762 8
a769 9
	sym = (Elf_Sym *) & (elffile->symtab[ELF_R_SYM(rel->r_info)]);
	if (sym->st_name) {
	    ELFDEBUG("ElfAddGOT: Adding GOT entry for %s\n",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	} else
	    ELFDEBUG("ElfAddGOT: Adding GOT entry for %s\n",
		     ElfGetSectionName(elffile,
				       elffile->sections[sym->st_shndx].
				       sh_name));
d771 1
a771 1
# endif
d773 4
a776 4
    for (gotent = elffile->got_entries; gotent; gotent = gotent->next) {
	if (ELF_R_SYM(gotent->rel->r_info) == ELF_R_SYM(rel->r_info) &&
	    gotent->rel->r_addend == rel->r_addend)
	    break;
d779 2
a780 2
    if (gotent) {
# ifdef ELFDEBUG
d782 1
a782 1
# endif
d787 1
a787 1
	ErrorF("ElfAddGOT() Unable to allocate memory!!!!\n");
d790 9
a798 8
# ifdef ELFDEBUG
    ELFDEBUG("Entry added with offset %x\n", elffile->gotsize);
# endif
    gotent->rel = rel;
    gotent->offset = elffile->gotsize;
    gotent->next = elffile->got_entries;
    elffile->got_entries = gotent;
    elffile->gotsize += 8;
d803 3
a805 1
ELFCreateGOT(ELFModulePtr elffile, int maxalign)
d807 1
a807 1
# ifdef MergeSectionAlloc
d809 1
a809 1
# endif
d815 2
a816 2
# ifdef ELFDEBUG
    ELFDEBUG("ELFCreateGOT: %x entries in the GOT\n", elffile->gotsize / 8);
d822 6
a827 7
    if (elffile->gotsize == 0)
	ELFDEBUG("Module %s doesn't have any GOT entries!\n",
		 _LoaderModuleToName(elffile->module));
# endif
    if (elffile->gotsize == 0)
	elffile->gotsize = 8;
    elffile->sections[elffile->gotndx].sh_size = elffile->gotsize;
d830 7
a836 7
# ifdef MergeSectionAlloc
#  ifdef __alpha__
#   define GOTDistance 0x100000
#  endif
#  ifdef __ia64__
#   define GOTDistance 0x200000
#  endif
d844 1
a844 2
	    if (elffile->base + elffile->basesize - gots->section >=
		GOTDistance)
d851 4
a854 4
#  ifdef ELFDEBUG
	ELFDEBUG("ELFCreateGOT: GOT address %lx in shared GOT, nuses %d\n",
		 elffile->got, gots->nuses);
#  endif
d859 1
a859 1
# endif	/*MergeSectionAlloc */
d862 1
a862 1
	ErrorF("ELFCreateGOT() Unable to allocate memory!!!!\n");
d865 2
a866 1
# ifdef MergeSectionAlloc
a876 1
#  if !defined(DoMMAPedMerge)
d880 1
a880 1
	    ErrorF("ELFCreateGOT() Unable to reallocate memory!!!!\n");
d883 4
a886 33
#   if defined(linux) && defined(__ia64__) || defined(__OpenBSD__)
	{
	    unsigned long page_size = getpagesize();
	    unsigned long round;

	    round = (unsigned long)elffile->base & (page_size - 1);
	    mprotect(elffile->base - round,
		     (elffile->basesize + round + page_size -
		      1) & ~(page_size - 1),
		     PROT_READ | PROT_WRITE | PROT_EXEC);
	}
#   endif
#  else
	{
	    int oldbasesize = elffile->basesize;

	    elffile->basesize += 8 + elffile->gotsize;
	    MMAP_ALIGN(elffile->basesize);
	    elffile->base = mremap(elffile->base, oldbasesize,
				   elffile->basesize, MREMAP_MAYMOVE);
	    if (elffile->base == NULL) {
		ErrorF("ELFCreateGOT() Unable to remap memory!!!!\n");
		return FALSE;
	    }
	}
#  endif

	elffile->baseptr =
		((long)elffile->base + (maxalign - 1)) & ~(maxalign - 1);
	elffile->got =
		(unsigned char
		 *)((long)(elffile->base + elffile->basesize -
			   elffile->gotsize) & ~7);
d888 1
a888 1
	gots = (ELFGotPtr) elffile->got;
d896 9
a904 10
#  ifdef ELFDEBUG
	ELFDEBUG("ELFCreateGOT: Created a shareable GOT with size %d\n",
		 gots->size);
#  endif
    }
# endif	/*MergeSectionAlloc */

# ifdef ELFDEBUG
    ELFDEBUG("ELFCreateGOT: GOT address %lx\n", elffile->got);
# endif
d908 1
a908 1
#endif /* defined(__alpha__) || defined(__ia64__) */
d915 4
a918 1
ElfAddOPD(ELFModulePtr elffile, int index, LOOKUP *l)
d929 1
a929 1
	ErrorF("ElfAddOPD() Unable to allocate memory!!!!\n");
d932 11
a942 10
# ifdef ELFDEBUG
    ELFDEBUG("OPD Entry %d added with offset %x\n", index, elffile->gotsize);
# endif
    opdent->l = l;
    opdent->index = index;
    opdent->offset = elffile->gotsize;
    opdent->next = elffile->opd_entries;
    elffile->opd_entries = opdent;
    elffile->gotsize += 16;
    return;
d946 2
a947 1
ELFCreateOPD(ELFModulePtr elffile)
d952 1
a952 1
	ErrorF("ELFCreateOPD() Unallocated GOT!!!!\n");
d957 3
a959 5
	((unsigned long *)(elffile->got + opdent->offset))[0] =
		(long)opdent->l->offset;
	((unsigned long *)(elffile->got + opdent->offset))[1] =
		(long)elffile->got;
	opdent->l->offset = (funcptr) (elffile->got + opdent->offset);
d967 3
a969 1
ElfAddPLT(ELFModulePtr elffile, Elf_Rel_t *rel)
d973 1
a973 1
# ifdef ELFDEBUG
d975 1
a975 1
	Elf_Sym *sym;
d977 7
a983 6
	sym = (Elf_Sym *) & (elffile->symtab[ELF_R_SYM(rel->r_info)]);
	if (sym->st_name) {
	    ELFDEBUG("ElfAddPLT: Adding PLT entry for %s\n",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	} else
	    ErrorF("ElfAddPLT: Add PLT entry for section??\n");
d985 1
a985 1
# endif
d990 3
a992 3
    for (pltent = elffile->plt_entries; pltent; pltent = pltent->next) {
	if (ELF_R_SYM(pltent->rel->r_info) == ELF_R_SYM(rel->r_info))
	    break;
d995 2
a996 2
    if (pltent) {
# ifdef ELFDEBUG
d998 1
a998 1
# endif
d1003 1
a1003 1
	ErrorF("ElfAddPLT() Unable to allocate memory!!!!\n");
d1006 12
a1017 11
# ifdef ELFDEBUG
    ELFDEBUG("Entry added with offset %x\n", elffile->pltsize);
# endif
    pltent->rel = rel;
    pltent->offset = elffile->pltsize;
    pltent->gotoffset = elffile->gotsize;
    pltent->next = elffile->plt_entries;
    elffile->plt_entries = pltent;
    elffile->pltsize += 32;
    elffile->gotsize += 16;
    return;
d1021 2
a1022 1
ELFCreatePLT(ELFModulePtr elffile)
d1024 3
a1026 3
# ifdef ELFDEBUG
    ELFDEBUG("ELFCreatePLT: %x entries in the PLT\n", elffile->pltsize / 8);
# endif
d1028 1
a1028 2
    if (elffile->pltsize == 0)
	return;
d1030 2
a1031 3
    if ((elffile->plt =
	 ELFLoaderSectCalloc(elffile, 32, elffile->pltsize)) == NULL) {
	ErrorF("ELFCreatePLT() Unable to allocate memory!!!!\n");
d1034 4
a1037 4
    elffile->sections[elffile->pltndx].sh_size = elffile->pltsize;
# ifdef ELFDEBUG
    ELFDEBUG("ELFCreatePLT: PLT address %lx\n", elffile->plt);
# endif
d1043 5
a1047 2
IA64InstallReloc(unsigned long *data128, int slot, enum ia64_operand opnd,
		 long value)
d1051 4
a1054 5
# ifdef ELFDEBUG
    ELFDEBUG("\nIA64InstallReloc %p %d %d %016lx\n", data128, slot, opnd,
	     value);
    ELFDEBUG("Before [%016lx%016lx]\n", data128[1], data128[0]);
# endif
d1056 4
a1059 11
    case 0:
	data = *data128;
	break;
    case 1:
	memcpy(&data, (char *)data128 + 5, 8);
	break;
    case 2:
	memcpy(&data, (char *)data128 + 10, 6);
	break;
    default:
	FatalError("Unexpected slot in IA64InstallReloc()\n");
d1064 1
a1064 1
	data |= (value & 0x7f) << (18 + slot);	/* [13:19] + 5 + slot */
a1077 19
#ifdef IA64_LDX_OPTIMIZATION
    case IA64_OPND_LDXMOV:
	/*
	 * Convert "ld8 t2=[t1]" to "mov t2=t1" which is really "add t2=0,t1"
	 * Mask all but the r3,r1,qp fields, 
	 * then OR in the ALU opcode = 8 into the opcode field [40:37]
	 * 
	 * Mask for the r3,r1,qp bit fields [26:20][12:6][5:0] = 0x7f01fff,
	 * This mask negated only within the 41 bit wide instruction and
	 * shifted left by 5 for the bundle template is 0x3FFF01FC0000
	 *
	 * opcode field [40:37] with a value of 8 is 0x10000000000
	 * shifted left by 5 for the bundle template is 0x200000000000
	 *
	 */
	data &= ~(0x3FFF01FC0000 << slot);
	data |= (0x200000000000 << slot);
	break;
#endif
d1082 4
a1085 11
    case 0:
	*data128 = data;
	break;
    case 1:
	memcpy((char *)data128 + 5, &data, 8);
	break;
    case 2:
	memcpy((char *)data128 + 10, &data, 6);
	break;
    default:
	FatalError("Unexpected slot in IA64InstallReloc()\n");
d1088 3
a1090 3
# ifdef ELFDEBUG
    ELFDEBUG("After  [%016lx%016lx]\n", data128[1], data128[0]);
# endif
d1093 1
a1093 1
#endif /*__ia64__*/
a1100 1

d1102 5
a1106 2
Elf_RelocateEntry(ELFModulePtr elffile, Elf_Word secn, Elf_Rel_t *rel,
		  int force)
a1108 2

#if !defined(__ia64__)
a1109 1
#endif
a1114 1
    unsigned long *dest64;
a1118 5
    unsigned short *dest16;
#endif
#if  defined(__AMD64__)
    unsigned long *dest64;
    int *dest32s;
d1127 3
a1129 3
    ELFDEBUG("%lx %d %d\n", (unsigned long)rel->r_offset,
	     ELF_R_SYM(rel->r_info), ELF_R_TYPE(rel->r_info));
# if defined(__powerpc__) || \
d1133 3
a1135 4
    defined(__ia64__) || \
    defined(__AMD64__)
    ELFDEBUG("%lx", rel->r_addend);
# endif
d1137 1
a1137 1
#endif /*ELFDEBUG*/
d1139 1
a1139 2
	    if (ELF_R_SYM(rel->r_info)
		&& ELF_R_TYPE(rel->r_info) != R_ALPHA_GPDISP)
d1141 1
a1141 1
	    if (ELF_R_SYM(rel->r_info))
a1142 1
    {
d1146 1
a1146 1
		symval = (Elf_Addr) & LoaderDefaultFunc;
d1157 2
a1158 1
    switch (ELF_R_TYPE(rel->r_info)) {
d1160 28
a1187 28
    case R_386_32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
# ifdef ELFDEBUG
	ELFDEBUG("R_386_32\t");
	ELFDEBUG("dest32=%p\t", (void *)dest32);
	ELFDEBUG("*dest32=%8.8x\t", (unsigned int)*dest32);
# endif
	*dest32 = symval + (*dest32);	/* S + A */
# ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8x\n", (unsigned int)*dest32);
# endif
	break;
    case R_386_PC32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
# ifdef ELFDEBUG
	ELFDEBUG("R_386_PC32 %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%p\t", secp);
	ELFDEBUG("symval=%lx\t", (unsigned long)symval);
	ELFDEBUG("dest32=%p\t", (void *)dest32);
	ELFDEBUG("*dest32=%8.8x\t", (unsigned int)*dest32);
# endif

	*dest32 = symval + (*dest32) - (Elf_Addr) dest32;	/* S + A - P */

# ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8x\n", (unsigned int)*dest32);
# endif
d1189 1
a1189 1
	break;
a1190 58
#if defined(__AMD64__)
    case R_X86_64_32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
# ifdef ELFDEBUG
	ELFDEBUG("R_X86_32\t");
	ELFDEBUG("dest32=%x\t", dest32);
	ELFDEBUG("*dest32=%8.8lx\t", *dest32);
	ELFDEBUG("r_addend=%lx\t", rel->r_addend);
# endif
	*dest32 = symval + rel->r_addend + (*dest32);	/* S + A */
# ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8lx\n", *dest32);
# endif
	break;
    case R_X86_64_32S:
	dest32s = (int *)(secp + rel->r_offset);
# ifdef ELFDEBUG
	ELFDEBUG("R_X86_64_32\t");
	ELFDEBUG("dest32s=%x\t", dest32s);
	ELFDEBUG("*dest32s=%8.8lx\t", *dest32s);
	ELFDEBUG("r_addend=%lx\t", rel->r_addend);
# endif
	*dest32s = symval + rel->r_addend + (*dest32s);	/* S + A */
# ifdef ELFDEBUG
	ELFDEBUG("*dest32s=%8.8lx\n", *dest32s);
# endif
	break;
    case R_X86_64_PC32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
# ifdef ELFDEBUG
	ELFDEBUG("R_X86_64_PC32 %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%lx\t", symval);
	ELFDEBUG("dest32=%x\t", dest32);
	ELFDEBUG("*dest32=%8.8lx\t", *dest32);
	ELFDEBUG("r_addend=%lx\t", rel->r_addend);
# endif
	*dest32 = symval + rel->r_addend + (*dest32) - (Elf_Addr) dest32;	/* S + A - P */

# ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8lx\n", *dest32);
# endif
	break;
    case R_X86_64_64:
	dest64 = (unsigned long *)(secp + rel->r_offset);
# ifdef ELFDEBUG
	ELFDEBUG("R_AMD64_64\t");
	ELFDEBUG("dest64=%x\t", dest64);
	ELFDEBUG("*dest64=%8.8lx\t", *dest64);
	ELFDEBUG("r_addend=%lx\t", rel->r_addend);
# endif
	*dest64 = symval + rel->r_addend + (*dest64);	/* S + A */
# ifdef ELFDEBUG
	ELFDEBUG("*dest64=%8.8lx\n", *dest64);
# endif
	break;
#endif /* __AMD64__ */
d1192 23
a1214 3
    case R_ALPHA_NONE:
    case R_ALPHA_LITUSE:
	break;
d1216 8
a1223 27
    case R_ALPHA_REFQUAD:
	dest64 = (unsigned long *)(secp + rel->r_offset);
	symval = ElfGetSymbolValue(elffile, ELF_R_SYM(rel->r_info));
# ifdef ELFDEBUG
	ELFDEBUG("R_ALPHA_REFQUAD\t");
	ELFDEBUG("dest64=%lx\t", dest64);
	ELFDEBUG("*dest64=%8.8lx\t", *dest64);
# endif
	*dest64 = symval + rel->r_addend + (*dest64);	/* S + A + P */
# ifdef ELFDEBUG
	ELFDEBUG("*dest64=%8.8lx\n", *dest64);
# endif
	break;

    case R_ALPHA_GPREL32:
	{
	    dest64 = (unsigned long *)(secp + rel->r_offset);
	    dest32 = (unsigned int *)dest64;

# ifdef ELFDEBUG
	    ELFDEBUG("R_ALPHA_GPREL32 %s\t",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	    ELFDEBUG("secp=%lx\t", secp);
	    ELFDEBUG("symval=%lx\t", symval);
	    ELFDEBUG("dest32=%lx\t", dest32);
	    ELFDEBUG("*dest32=%8.8x\t", *dest32);
# endif
d1225 6
a1230 7
	    symval = ((unsigned char *)symval) -
		    ((unsigned char *)elffile->got);
# ifdef ELFDEBUG
	    ELFDEBUG("symval=%lx\t", symval);
# endif
	    if ((symval & 0xffffffff00000000) != 0x0000000000000000 &&
		(symval & 0xffffffff00000000) != 0xffffffff00000000) {
d1232 1
a1232 1
			   ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
d1235 4
a1238 17
	    *dest32 = symval;
# ifdef ELFDEBUG
	    ELFDEBUG("*dest32=%x\n", *dest32);
# endif
	    break;
	}

    case R_ALPHA_GPRELLOW:
	{
	    dest64 = (unsigned long *)(secp + rel->r_offset);
	    dest16 = (unsigned short *)dest64;

	    symval += rel->r_addend;
	    symval = ((unsigned char *)symval) -
		    ((unsigned char *)elffile->got);

	    *dest16 = symval;
a1239 16
	}

    case R_ALPHA_GPRELHIGH:
	{
	    dest64 = (unsigned long *)(secp + rel->r_offset);
	    dest16 = (unsigned short *)dest64;

	    symval += rel->r_addend;
	    symval = ((unsigned char *)symval) -
		    ((unsigned char *)elffile->got);
	    symval = ((long)symval >> 16) + ((symval >> 15) & 1);
	    if ((long)symval > 0x7fff || (long)symval < -(long)0x8000) {
		FatalError
			("R_ALPHA_GPRELHIGH symval-got is too large for %s:%lx\n",
			 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)),
			 symval);
d1241 2
a1242 7

	    *dest16 = symval;
	    break;
	}

    case R_ALPHA_LITERAL:
	{
d1244 9
d1254 4
a1257 14
	    dest32 = (unsigned int *)(secp + rel->r_offset);
# ifdef ELFDEBUG
	    ELFDEBUG("R_ALPHA_LITERAL %s\t",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	    ELFDEBUG("secp=%lx\t", secp);
	    ELFDEBUG("symval=%lx\t", symval);
	    ELFDEBUG("dest32=%lx\t", dest32);
	    ELFDEBUG("*dest32=%8.8x\t", *dest32);
# endif

	    for (gotent = elffile->got_entries; gotent; gotent = gotent->next) {
		if (ELF_R_SYM(gotent->rel->r_info) == ELF_R_SYM(rel->r_info)
		    && gotent->rel->r_addend == rel->r_addend)
		    break;
d1261 4
a1264 4
	    if (gotent) {
		*(unsigned long *)(elffile->got + gotent->offset) =
			symval + rel->r_addend;
# ifdef ELFDEBUG
d1266 2
a1267 2
			 gotent->offset, symval + rel->r_addend);
# endif
d1271 3
a1273 2
		(*dest32) |= (gotent->offset);	/* The address part is always 0 */
	    } else {
d1275 1
a1275 1

d1277 6
a1282 6
		val = ((symval + (rel->r_addend) - (Elf_Addr) dest32));
# ifdef ELFDEBUG
		ELFDEBUG("S+A-P=%x\t", val);
# endif
		if ((val & 0xffff0000) != 0xffff0000 &&
		    (val & 0xffff0000) != 0x00000000) {
d1284 1
a1284 1
		    break;
d1287 1
a1287 1
		(*dest32) |= (val);	/* The address part is always 0 */
d1289 3
a1291 3
# ifdef ELFDEBUG
	    ELFDEBUG("*dest32=%8.8x\n", *dest32);
# endif
d1294 4
a1297 4
	}

    case R_ALPHA_GPDISP:
	{
d1300 2
a1301 2
	    dest32h = (unsigned int *)(secp + rel->r_offset);
	    dest32 = (unsigned int *)((secp + rel->r_offset) + rel->r_addend);
d1303 11
a1313 10
# ifdef ELFDEBUG
	    ELFDEBUG("R_ALPHA_GPDISP %s\t",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	    ELFDEBUG("secp=%lx\t", secp);
	    ELFDEBUG("got=%lx\t", elffile->got);
	    ELFDEBUG("dest32=%lx\t", dest32);
	    ELFDEBUG("*dest32=%8.8x\t", *dest32);
	    ELFDEBUG("dest32h=%lx\t", dest32h);
	    ELFDEBUG("*dest32h=%8.8x\t", *dest32h);
# endif
d1315 2
a1316 2
		ErrorF("***Bad instructions in relocating %s\n",
		       ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
d1321 6
d1328 2
a1329 9
	    offset = ((unsigned char *)elffile->got -
		      (unsigned char *)dest32h);
# ifdef ELFDEBUG
	    ELFDEBUG("symval=%lx\t", symval);
	    ELFDEBUG("got-dest32=%lx\t", offset);
# endif

	    if ((offset >= 0x7fff8000L) || (offset < -0x80000000L)) {
		FatalError("Offset overflow for R_ALPHA_GPDISP\n");
d1333 23
a1355 12
# ifdef ELFDEBUG
	    ELFDEBUG("symval=%lx\t", symval);
# endif
	    *dest32 = (*dest32 & 0xffff0000) | (symval & 0xffff);
	    *dest32h = (*dest32h & 0xffff0000) |
		    (((symval >> 16) + ((symval >> 15) & 1)) & 0xffff);
# ifdef ELFDEBUG
	    ELFDEBUG("*dest32=%8.8x\t", *dest32);
	    ELFDEBUG("*dest32h=%8.8x\n", *dest32h);
# endif
	    break;
	}
d1357 8
a1364 36
    case R_ALPHA_HINT:
	dest32 = (unsigned int *)((secp + rel->r_offset) + rel->r_addend);
# ifdef ELFDEBUG
	ELFDEBUG("R_ALPHA_HINT %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%lx\t", secp);
	ELFDEBUG("symval=%lx\t", symval);
	ELFDEBUG("dest32=%lx\t", dest32);
	ELFDEBUG("*dest32=%8.8x\t", *dest32);
# endif

# ifdef ELFDEBUG
	ELFDEBUG("symval=%lx\t", symval);
# endif
	symval -= (Elf_Addr) (((unsigned char *)dest32) + 4);
	if (symval % 4) {
	    ErrorF("R_ALPHA_HINT bad alignment of offset\n");
	}
	symval = symval >> 2;

# ifdef ELFDEBUG
	ELFDEBUG("symval=%lx\t", symval);
# endif

	if (symval & 0xffff8000) {
# ifdef ELFDEBUG
	    ELFDEBUG("R_ALPHA_HINT symval too large\n");
# endif
	}

	*dest32 = (*dest32 & ~0x3fff) | (symval & 0x3fff);

# ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
# endif
	break;
d1366 3
a1368 4
    case R_ALPHA_GPREL16:
	{
	    dest64 = (unsigned long *)(secp + rel->r_offset);
	    dest16 = (unsigned short *)dest64;
d1370 4
a1373 8
	    symval += rel->r_addend;
	    symval = ((unsigned char *)symval) -
		    ((unsigned char *)elffile->got);
	    if ((long)symval > 0x7fff || (long)symval < -(long)0x8000) {
		FatalError
			("R_ALPHA_GPREL16 symval-got is too large for %s:%lx\n",
			 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)),
			 symval);
d1376 1
a1376 3
	    *dest16 = symval;
	    break;
	}
d1378 5
d1385 48
a1432 50
    case R_68K_32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
# ifdef ELFDEBUG
	ELFDEBUG("R_68K_32\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
# endif
	{
	    unsigned long val;

	    /* S + A */
	    val = symval + (rel->r_addend);
# ifdef ELFDEBUG
	    ELFDEBUG("S+A=%x\t", val);
# endif
	    *dest32 = val;	/* S + A */
	}
# ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
# endif
	break;
    case R_68K_PC32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
# ifdef ELFDEBUG
	ELFDEBUG("R_68K_PC32\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
# endif
	{
	    unsigned long val;

	    /* S + A - P */
	    val = symval + (rel->r_addend);
	    val -= *dest32;
# ifdef ELFDEBUG
	    ELFDEBUG("S+A=%x\t", val);
	    ELFDEBUG("S+A-P=%x\t", val + (*dest32) - (Elf_Addr) dest32);
# endif
	    *dest32 = val + (*dest32) - (Elf_Addr) dest32;	/* S + A - P */
	}
# ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
# endif
	break;
d1435 10
a1444 11
# if defined(PowerMAX_OS)
    case R_PPC_DISP24:		/* 11 */
	dest32 = (unsigned long *)(secp + rel->r_offset);
#  ifdef ELFDEBUG
	ELFDEBUG("R_PPC_DISP24 %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("dest32=%x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\t", *dest32);
#  endif
d1446 36
a1481 2
	{
	    unsigned long val;
d1483 253
a1735 48
	    /* S + A - P >> 2 */
	    val = ((symval + (rel->r_addend) - (Elf_Addr) dest32));
#  ifdef ELFDEBUG
	    ELFDEBUG("S+A-P=%x\t", val);
#  endif
	    val = val >> 2;
	    if ((val & 0x3f000000) != 0x3f000000 &&
		(val & 0x3f000000) != 0x00000000) {
#  ifdef ELFDEBUG
		ELFDEBUG("R_PPC_DISP24 offset %x too large\n", val << 2);
#  endif
		symval = ElfGetPltAddr(elffile, ELF_R_SYM(rel->r_info));
		val = ((symval + (rel->r_addend) - (Elf_Addr) dest32));
#  ifdef ELFDEBUG
		ELFDEBUG("PLT offset is %x\n", val);
#  endif
		val = val >> 2;
		if ((val & 0x3f000000) != 0x3f000000 &&
		    (val & 0x3f000000) != 0x00000000)
		    FatalError("R_PPC_DISP24 PLT offset %x too large\n",
			       val << 2);
	    }
	    val &= 0x00ffffff;
	    (*dest32) |= (val << 2);	/* The address part is always 0 */
	    ppc_flush_icache(dest32);
	}
#  ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	break;
    case R_PPC_16HU:		/* 31 */
	dest16 = (unsigned short *)(secp + rel->r_offset);
#  ifdef ELFDEBUG
	dest32 = (unsigned long *)(dest16 - 1);

#  endif
#  ifdef ELFDEBUG
	ELFDEBUG("R_PPC_16HU\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest16=%x\t", dest16);
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	{
	    unsigned short val;
d1737 27
a1763 99
	    /* S + A */
	    val = ((symval + (rel->r_addend)) & 0xffff0000) >> 16;
#  ifdef ELFDEBUG
	    ELFDEBUG("uhi16(S+A)=%x\t", val);
#  endif
	    *dest16 = val;	/* S + A */
	    ppc_flush_icache(dest16);
	}
#  ifdef ELFDEBUG
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	break;
    case R_PPC_32:		/* 32 */
	dest32 = (unsigned long *)(secp + rel->r_offset);
#  ifdef ELFDEBUG
	ELFDEBUG("R_PPC_32\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	{
	    unsigned long val;

	    /* S + A */
	    val = symval + (rel->r_addend);
#  ifdef ELFDEBUG
	    ELFDEBUG("S+A=%x\t", val);
#  endif
	    *dest32 = val;	/* S + A */
	    ppc_flush_icache(dest32);
	}
#  ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	break;
    case R_PPC_32UA:		/* 33 */
	dest32 = (unsigned long *)(secp + rel->r_offset);
#  ifdef ELFDEBUG
	ELFDEBUG("R_PPC_32UA\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	{
	    unsigned long val;
	    unsigned char *dest8 = (unsigned char *)dest32;

	    /* S + A */
	    val = symval + (rel->r_addend);
#  ifdef ELFDEBUG
	    ELFDEBUG("S+A=%x\t", val);
#  endif
	    *dest8++ = (val & 0xff000000) >> 24;
	    *dest8++ = (val & 0x00ff0000) >> 16;
	    *dest8++ = (val & 0x0000ff00) >> 8;
	    *dest8++ = (val & 0x000000ff);
	    ppc_flush_icache(dest32);
	}
#  ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	break;
    case R_PPC_16H:		/* 34 */
	dest16 = (unsigned short *)(secp + rel->r_offset);
#  ifdef ELFDEBUG
	dest32 = (unsigned long *)(dest16 - 1);
#  endif
#  ifdef ELFDEBUG
	ELFDEBUG("R_PPC_16H\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symbol=%s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest16=%x\t", dest16);
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	{
	    unsigned short val;
	    unsigned short loval;

	    /* S + A */
	    val = ((symval + (rel->r_addend)) & 0xffff0000) >> 16;
	    loval = (symval + (rel->r_addend)) & 0xffff;
	    if (loval & 0x8000) {
		/*
		 * This is hi16(), instead of uhi16(). Because of this,
		 * if the lo16() will produce a negative offset, then
		 * we have to increment this part of the address to get
		 * the correct final result.
		 */
		val++;
d1765 25
a1789 127
#  ifdef ELFDEBUG
	    ELFDEBUG("hi16(S+A)=%x\t", val);
#  endif
	    *dest16 = val;	/* S + A */
	    ppc_flush_icache(dest16);
	}
#  ifdef ELFDEBUG
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	break;
    case R_PPC_16L:		/* 35 */
	dest16 = (unsigned short *)(secp + rel->r_offset);
#  ifdef ELFDEBUG
	dest32 = (unsigned long *)(dest16 - 1);
#  endif
#  ifdef ELFDEBUG
	ELFDEBUG("R_PPC_16L\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest16=%x\t", dest16);
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	{
	    unsigned short val;

	    /* S + A */
	    val = (symval + (rel->r_addend)) & 0xffff;
#  ifdef ELFDEBUG
	    ELFDEBUG("lo16(S+A)=%x\t", val);
#  endif
	    *dest16 = val;	/* S + A */
	    ppc_flush_icache(dest16);
	}
#  ifdef ELFDEBUG
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	break;
# else /* PowerMAX_OS */
	/* Linux PPC */
    case R_PPC_ADDR32:		/* 1 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
	symval = ElfGetSymbolValue(elffile, ELF_R_SYM(rel->r_info));
#  ifdef ELFDEBUG
	ELFDEBUG("R_PPC_ADDR32\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	{
	    unsigned long val;

	    /* S + A */
	    val = symval + (rel->r_addend);
#  ifdef ELFDEBUG
	    ELFDEBUG("S+A=%x\t", val);
#  endif
	    *dest32 = val;	/* S + A */
	    ppc_flush_icache(dest32);
	}
#  ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	break;
    case R_PPC_ADDR16_LO:	/* 4 */
	dest16 = (unsigned short *)(secp + rel->r_offset);
#  ifdef ELFDEBUG
	dest32 = (unsigned long *)(dest16 - 1);
#  endif
#  ifdef ELFDEBUG
	ELFDEBUG("R_PPC_ADDR16_LO\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest16=%x\t", dest16);
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
#  endif
	{
	    unsigned short val;

	    /* S + A */
	    val = (symval + (rel->r_addend)) & 0xffff;
#  ifdef ELFDEBUG
	    ELFDEBUG("lo16(S+A)=%x\t", val);
#  endif
	    *dest16 = val;	/* S + A */
	    ppc_flush_icache(dest16);
	}
#  ifdef ELFDEBUG
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	break;
    case R_PPC_ADDR16_HA:	/* 6 */
	dest16 = (unsigned short *)(secp + rel->r_offset);
#  ifdef ELFDEBUG
	dest32 = (unsigned long *)(dest16 - 1);
#  endif
#  ifdef ELFDEBUG
	ELFDEBUG("R_PPC_ADDR16_HA\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest16=%x\t", dest16);
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
#  endif
	{
	    unsigned short val;
	    unsigned short loval;

	    /* S + A */
	    val = ((symval + (rel->r_addend)) & 0xffff0000) >> 16;
	    loval = (symval + (rel->r_addend)) & 0xffff;
	    if (loval & 0x8000) {
		/*
		 * This is hi16(), instead of uhi16(). Because of this,
		 * if the lo16() will produce a negative offset, then
		 * we have to increment this part of the address to get
		 * the correct final result.
		 */
		val++;
d1791 5
a1795 83
#  ifdef ELFDEBUG
	    ELFDEBUG("hi16(S+A)=%x\t", val);
#  endif
	    *dest16 = val;	/* S + A */
	    ppc_flush_icache(dest16);
	}
#  ifdef ELFDEBUG
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	break;
    case R_PPC_REL24:		/* 10 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
#  ifdef ELFDEBUG
	ELFDEBUG("R_PPC_REL24 %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("dest32=%x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\t", *dest32);
#  endif

	{
	    unsigned long val;

	    /* S + A - P >> 2 */
	    val = ((symval + (rel->r_addend) - (Elf_Addr) dest32));
#  ifdef ELFDEBUG
	    ELFDEBUG("S+A-P=%x\t", val);
#  endif
	    val = val >> 2;
	    if ((val & 0x3f000000) != 0x3f000000 &&
		(val & 0x3f000000) != 0x00000000) {
#  ifdef ELFDEBUG
		ELFDEBUG("R_PPC_REL24 offset %x too large\n", val << 2);
#  endif
		symval = ElfGetPltAddr(elffile, ELF_R_SYM(rel->r_info));
		val = ((symval + (rel->r_addend) - (Elf_Addr) dest32));
#  ifdef ELFDEBUG
		ELFDEBUG("PLT offset is %x\n", val);
#  endif
		val = val >> 2;
		if ((val & 0x3f000000) != 0x3f000000 &&
		    (val & 0x3f000000) != 0x00000000)
		    FatalError("R_PPC_REL24 PLT offset %x too large\n",
			       val << 2);
	    }
	    val &= 0x00ffffff;
	    (*dest32) |= (val << 2);	/* The address part is always 0 */
	    ppc_flush_icache(dest32);
	}
#  ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	break;
    case R_PPC_REL32:		/* 26 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
#  ifdef ELFDEBUG
	ELFDEBUG("R_PPC_REL32\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	{
	    unsigned long val;

	    /* S + A - P */
	    val = symval + (rel->r_addend);
	    val -= *dest32;
#  ifdef ELFDEBUG
	    ELFDEBUG("S+A=%x\t", val);
	    ELFDEBUG("S+A-P=%x\t", val + (*dest32) - (Elf_Addr) dest32);
#  endif
	    *dest32 = val + (*dest32) - (Elf_Addr) dest32;	/* S + A - P */
	    ppc_flush_icache(dest32);
	}
#  ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	break;
# endif	/* PowerMAX_OS */
d1798 2
a1799 2
    case R_SPARC_NONE:		/*  0 */
	break;
d1801 5
a1805 5
    case R_SPARC_8:		/*  1 */
	dest8 = (unsigned char *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest8 = symval;
	break;
d1807 5
a1811 5
    case R_SPARC_16:		/*  2 */
	dest16 = (unsigned short *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest16 = symval;
	break;
d1813 10
a1822 9
    case R_SPARC_32:		/*  3 */
    case R_SPARC_UA32:		/* 23 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
	symval += rel->r_addend;
	((unsigned char *)dest32)[0] = (unsigned char)(symval >> 24);
	((unsigned char *)dest32)[1] = (unsigned char)(symval >> 16);
	((unsigned char *)dest32)[2] = (unsigned char)(symval >> 8);
	((unsigned char *)dest32)[3] = (unsigned char)(symval);
	break;
d1824 5
a1828 6
    case R_SPARC_GLOB_DAT:	/* 20 */
    case R_SPARC_64:		/* 32 */
	dest64 = (unsigned long *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest64 = symval;
	break;
d1830 5
a1834 5
    case R_SPARC_DISP8:	/*  4 */
	dest8 = (unsigned char *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest8 = (symval - (Elf_Addr) dest8);
	break;
d1836 5
a1840 5
    case R_SPARC_DISP16:	/*  5 */
	dest16 = (unsigned short *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest16 = (symval - (Elf_Addr) dest16);
	break;
d1842 6
a1847 5
    case R_SPARC_DISP32:	/*  6 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest32 = (symval - (Elf_Addr) dest32);
	break;
d1849 5
a1853 6
    case R_SPARC_WDISP30:	/*  7 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest32 = ((*dest32 & 0xc0000000) |
		   (((symval - (Elf_Addr) dest32) >> 2) & 0x3fffffff));
	break;
d1855 5
a1859 5
    case R_SPARC_HI22:		/*  9 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest32 = (*dest32 & 0xffc00000) | (symval >> 10);
	break;
d1861 8
a1868 5
    case R_SPARC_LO10:		/* 12 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest32 = (*dest32 & ~0x3ff) | (symval & 0x3ff);
	break;
d1870 20
a1889 8
    case R_SPARC_COPY:		/* 19 */
	/* Fix your code...  I'd rather dish out an error here
	 * so people will not link together PIC and non-PIC
	 * code into a final driver object file.
	 */
	ErrorF("Elf_RelocateEntry():"
	       "  Copy relocs not supported on Sparc.\n");
	break;
d1891 5
a1895 28
    case R_SPARC_JMP_SLOT:	/* 21 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
	/* Before we change it the PLT entry looks like:
	 *
	 * pltent:      sethi   %hi(rela_plt_offset), %g1
	 *              b,a     PLT0
	 *              nop
	 *
	 * We change it into:
	 *
	 * pltent:      sethi   %hi(rela_plt_offset), %g1
	 *              sethi   %hi(symval), %g1
	 *              jmp     %g1 + %lo(symval), %g0
	 */
	symval += rel->r_addend;
	dest32[2] = 0x81c06000 | (symval & 0x3ff);
	__asm __volatile("flush %0 + 0x8"::"r"(dest32));

	dest32[1] = 0x03000000 | (symval >> 10);
	__asm __volatile("flush %0 + 0x4"::"r"(dest32));

	break;

    case R_SPARC_RELATIVE:	/* 22 */
	dest64 = (unsigned long *)(secp + rel->r_offset);
	*dest64 = (unsigned long)secp + rel->r_addend;
	break;
#endif /*__sparc__*/
d1897 2
a1898 2
    case R_IA64_NONE:
	break;
d1900 6
a1905 11
    case R_IA64_LTOFF_FPTR22:
	if (rel->r_addend)
	    FatalError("\nAddend for R_IA64_LTOFF_FPTR22 not supported\n");
# ifdef ELFDEBUG
	ELFDEBUG("opd=%016lx.%016lx\n",
		 ((long *)symval)[0], ((long *)symval)[1]);
# endif
	/* FALLTHROUGH */
    case R_IA64_LTOFF22:
#ifndef IA64_LDX_OPTIMIZATION
    case R_IA64_LTOFF22X:	/* If not implementing LDXMOV optimization treat LTOFF22X as LTOFF22 */
d1907 3
a1909 1
	{
d1911 11
d1923 4
a1926 16
	    dest128 = (unsigned long *)(secp + (rel->r_offset & ~3));
# ifdef ELFDEBUG
	    ELFDEBUG("%s %s\t", ELF_R_TYPE(rel->r_info) == R_IA64_LTOFF22 ?
		     "R_IA64_LTOFF22" : "R_IA64_LTOFF_FPTR22",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	    ELFDEBUG("secp=%lx\t", secp);
	    ELFDEBUG("symval=%lx\t", symval);
	    ELFDEBUG("dest128=%lx\t", dest128);
	    ELFDEBUG("slot=%d\n", rel->r_offset & 3);
	    ELFDEBUG("*dest128=[%016lx%016lx]\n", dest128[1], dest128[0]);
# endif

	    for (gotent = elffile->got_entries; gotent; gotent = gotent->next) {
		if (ELF_R_SYM(gotent->rel->r_info) == ELF_R_SYM(rel->r_info)
		    && gotent->rel->r_addend == rel->r_addend)
		    break;
d1930 4
a1933 4
	    if (gotent) {
		*(unsigned long *)(elffile->got + gotent->offset) =
			symval + rel->r_addend;
# ifdef ELFDEBUG
d1935 2
a1936 2
			 gotent->offset, symval + rel->r_addend);
# endif
d1940 3
a1942 3
		IA64InstallReloc(dest128, rel->r_offset & 3, IA64_OPND_IMM22,
				 gotent->offset);
	    } else
d1944 2
a1945 2
	}
	break;
d1947 2
a1948 2
    case R_IA64_PCREL21B:
	{
d1950 11
a1960 13

	    dest128 = (unsigned long *)(secp + (rel->r_offset & ~3));
# ifdef ELFDEBUG
	    ELFDEBUG("R_IA64_PCREL21B %s\t",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	    ELFDEBUG("secp=%lx\t", secp);
	    ELFDEBUG("symval=%lx\t", symval);
	    ELFDEBUG("opd=%lx.%lx\t", ((long *)symval)[0],
		     ((long *)symval)[1]);
	    ELFDEBUG("dest128=%lx\t", dest128);
	    ELFDEBUG("slot=%d\n", rel->r_offset & 3);
	    ELFDEBUG("*dest128=[%016lx%016lx]\n", dest128[1], dest128[0]);
# endif
d1964 1
a1964 2
		&& (((unsigned long)dest128 - ((unsigned long *)symval)[0]) +
		    0x2000000 < 0x4000000)) {
d1967 1
a1967 2
				 ((unsigned long *)symval)[0] -
				 (unsigned long)dest128);
d1970 4
a1973 4
	    for (pltent = elffile->plt_entries; pltent; pltent = pltent->next) {
		if (ELF_R_SYM(pltent->rel->r_info) == ELF_R_SYM(rel->r_info)
		    && pltent->rel->r_addend == rel->r_addend)
		    break;
d1980 2
a1981 4
		unsigned long *p =
			(unsigned long *)(elffile->plt + pltent->offset);
		unsigned long r =
			(unsigned long)symval - (unsigned long)elffile->got;
d1984 5
a1988 5
		    /* Too far from gp to use the official function descriptor,
		     * so we have to make a local one.
		     */
		    r = pltent->gotoffset;
		    memcpy(elffile->got + r, (char *)symval, 16);
d2001 2
a2002 2
	}
	break;
d2004 10
a2013 17
    case R_IA64_FPTR64LSB:
	dest64 = (unsigned long *)(secp + rel->r_offset);
# ifdef ELFDEBUG
	ELFDEBUG("R_IA64_FPTR64LSB %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%lx\t", secp);
	ELFDEBUG("symval=%lx\t", symval);
	ELFDEBUG("dest64=%lx\t", dest64);
	ELFDEBUG("opd=%016lx.%016lx\n", ((long *)symval)[0],
		 ((long *)symval)[1]);
# endif

	if (rel->r_addend)
	    FatalError("\nAddend not supported for R_IA64_FPTR64LSB\n");
	*dest64 = symval;
	ia64_flush_cache(dest64);
	break;
d2015 5
a2019 12
    case R_IA64_DIR64LSB:
	dest64 = (unsigned long *)(secp + rel->r_offset);
# ifdef ELFDEBUG
	ELFDEBUG("R_IA64_DIR64LSB %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%lx\t", secp);
	ELFDEBUG("symval=%lx\t", symval);
	ELFDEBUG("dest64=%lx\n", dest64);
# endif
	*dest64 = symval + rel->r_addend;
	ia64_flush_cache(dest64);
	break;
d2021 2
a2022 2
    case R_IA64_PCREL64LSB:
	dest64 = (unsigned long *)(secp + rel->r_offset);
d2024 5
a2028 5
	ELFDEBUG("R_IA64_PCREL64LSB %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%lx\t", secp);
	ELFDEBUG("symval=%lx\t", symval);
	ELFDEBUG("dest64=%lx\n", dest64);
d2030 3
a2032 2
	*dest64 = symval + rel->r_addend - (unsigned long)dest64;
	break;
d2034 14
a2047 14
    case R_IA64_GPREL22:
	dest128 = (unsigned long *)(secp + (rel->r_offset & ~3));
# ifdef ELFDEBUG
	ELFDEBUG("R_IA64_GPREL22 %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%lx\t", secp);
	ELFDEBUG("symval=%lx\t", symval);
	ELFDEBUG("dest128=%lx\t", dest128);
	ELFDEBUG("slot=%d\n", rel->r_offset & 3);
	ELFDEBUG("*dest128=[%016lx%016lx]\n", dest128[1], dest128[0]);
# endif
	IA64InstallReloc(dest128, rel->r_offset & 3, IA64_OPND_IMM22,
			 symval + rel->r_addend - (long)elffile->got);
	break;
d2049 1
a2049 5
#ifdef IA64_LDX_OPTIMIZATION
    case R_IA64_LTOFF22X:
	{
	    ELFGotEntryPtr gotent;
	    long gp_offset = symval + rel->r_addend - (long)elffile->got;
d2051 13
a2063 1
	    dest128 = (unsigned long *)(secp + (rel->r_offset & ~3));
d2065 12
a2076 45
# ifdef ELFDEBUG
	    ELFDEBUG("R_IA64_LTOFF22X %s\t",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	    ELFDEBUG("secp=%lx\t", secp);
	    ELFDEBUG("symval=%lx\t", symval);
	    ELFDEBUG("dest128=%lx\t", dest128);
	    ELFDEBUG("slot=%d\n", rel->r_offset & 3);
# endif

	    if (gp_offset << 42 >> 42 != gp_offset) {
		/* Offset is too large for LTOFF22X, 
		 * fallback to using GOT lookup, e.g. LTOFF22. 
		 * Note: LDXMOV will fail the same test and will be ignored. */

# ifdef ELFDEBUG
		ELFDEBUG("gp_offset=%ld too large, using GOT instead (LTOFF22)\n", gp_offset);
# endif

		for (gotent = elffile->got_entries; gotent;
		     gotent = gotent->next) {
		    if (ELF_R_SYM(gotent->rel->r_info) ==
			ELF_R_SYM(rel->r_info)
			&& gotent->rel->r_addend == rel->r_addend)
			break;
		}

		/* Set the address in the GOT */
		if (gotent) {
		    *(unsigned long *)(elffile->got + gotent->offset) =
			    symval + rel->r_addend;
# ifdef ELFDEBUG
		    ELFDEBUG("Setting gotent[%x]=%lx\n", gotent->offset,
			     symval + rel->r_addend);
# endif
		    if ((gotent->offset & 0xffe00000) != 0)
			FatalError("\nR_IA64_LTOFF22 offset %x too large\n",
				   gotent->offset);
		} else {
		    FatalError("\nCould not find GOT entry\n");
		}
		gp_offset = gotent->offset;	/* Use GOT lookup */
	    } else {
# ifdef ELFDEBUG
		ELFDEBUG("using gp_offset=%ld (LTOFF22X)", gp_offset);
# endif
a2077 4
	    IA64InstallReloc(dest128, rel->r_offset & 3, IA64_OPND_IMM22,
			     gp_offset);
	}
	break;
d2080 1
a2080 5
    case R_IA64_LDXMOV:
# ifdef ELFDEBUG
	ELFDEBUG("R_IA64_LDXMOV %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
# endif
d2082 2
a2083 26
#ifdef IA64_LDX_OPTIMIZATION
	{
	    long gp_offset = symval + rel->r_addend - (long)elffile->got;

	    dest128 = (unsigned long *)(secp + (rel->r_offset & ~3));

	    if (gp_offset << 42 >> 42 != gp_offset) {
		/* Offset is too large for LTOFF22X, ignore this relocation */
# ifdef ELFDEBUG
		ELFDEBUG("offset = %ld too large, ignoring\n", gp_offset);
# endif
	    } else {

# ifdef ELFDEBUG
		ELFDEBUG("secp=%lx\t", secp);
		ELFDEBUG("symval=%lx\t", symval);
		ELFDEBUG("dest128=%lx\t", dest128);
		ELFDEBUG("slot=%d\n", rel->r_offset & 3);
		ELFDEBUG("offset=%ld\n", gp_offset);
		ELFDEBUG("*dest128=[%016lx%016lx]\n", dest128[1], dest128[0]);
# endif

		IA64InstallReloc(dest128, rel->r_offset & 3, IA64_OPND_LDXMOV,
				 0);
	    }
	}
a2084 1
	break;
d2086 1
a2086 40
#endif /*__ia64__*/

#if defined(__arm__)
    case R_ARM_ABS32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
# ifdef ELFDEBUG
	ELFDEBUG("R_ARM_ABS32\t");
	ELFDEBUG("dest32=%x\t", dest32);
	ELFDEBUG("*dest32=%8.8lx\t", *dest32);
# endif
	*dest32 = symval + (*dest32);	/* S + A */
# ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8lx\n", *dest32);
# endif
	break;

    case R_ARM_REL32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
# ifdef ELFDEBUG
	{
	    char *namestr;

	    ELFDEBUG("R_ARM_REL32 %s\t",
		     namestr =
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	    xf86loaderfree(namestr);
	    ELFDEBUG("secp=%x\t", secp);
	    ELFDEBUG("symval=%lx\t", symval);
	    ELFDEBUG("dest32=%x\t", dest32);
	    ELFDEBUG("*dest32=%8.8lx\t", *dest32);
	}
# endif

	*dest32 = symval + (*dest32) - (Elf_Addr) dest32;	/* S + A - P */

# ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8lx\n", *dest32);
# endif

	break;
d2088 2
a2089 2
    case R_ARM_PC24:
	{
d2091 1
a2091 2

	    dest32 = (unsigned int *)(secp + rel->r_offset);
d2093 3
a2095 4
	    val = symval - (unsigned long)dest32 + val;
	    val >>= 2;
	    *dest32 = (*dest32 & 0xff000000) | (val & 0x00ffffff);
#ifdef NOTYET
d2097 2
a2098 3
#endif
	}
	break;
d2102 5
a2106 5
    default:
	ErrorF("Elf_RelocateEntry() Unsupported relocation type %d\n",
	       (int)ELF_R_TYPE(rel->r_info));
	break;
    }
d2112 2
a2113 2
    ELFModulePtr elffile;
    int index;			/* The section to use as relocation data */
d2115 4
a2118 3
    int i, numrel;
    Elf_Shdr *sect = &(elffile->sections[index]);
    Elf_Rel_t *rel = (Elf_Rel_t *) elffile->saddr[index];
d2122 3
a2124 1
    numrel = sect->sh_size / sect->sh_entsize;
d2126 1
a2126 1
    for (i = 0; i < numrel; i++) {
d2128 3
a2130 3
	if (ELF_R_TYPE(rel[i].r_info) == R_ALPHA_LITERAL) {
	    ElfAddGOT(elffile, &rel[i]);
	}
a2133 1
	    || ELF_R_TYPE(rel[i].r_info) == R_IA64_LTOFF22X
d2135 1
a2135 1
	    ElfAddGOT(elffile, &rel[i]);
d2138 1
a2138 1
	    ElfAddPLT(elffile, &rel[i]);
d2142 1
a2142 4
	    Elf_Sym *syms = (Elf_Sym *) elffile->saddr[elffile->symndx];

	    if (ELF_ST_BIND(syms[ELF_R_SYM(rel[i].r_info)].st_info) ==
		STB_LOCAL) {
d2162 8
a2169 6
ELF_GetSymbols(ELFModulePtr elffile, unsigned short **psecttable)
{
    Elf_Sym *syms;
    Elf_Shdr *sect;
    int i, l, numsyms;
    LOOKUP *lookup, *p;
d2173 3
a2175 3
    syms = elffile->symtab;
    sect = &(elffile->sections[elffile->symndx]);
    numsyms = sect->sh_size / sect->sh_entsize;
d2177 1
a2177 1
    if ((lookup = xf86loadermalloc((numsyms + 1) * sizeof(LOOKUP))) == NULL)
d2180 1
a2180 2
    if ((secttable =
	 xf86loadercalloc(sizeof(unsigned short), (numsyms + 1))) == NULL) {
d2186 2
a2187 1
    for (i = 0, l = 0; i < numsyms; i++) {
d2189 4
a2192 5
	ELFDEBUG("value=%lx\tsize=%lx\tBIND=%x\tTYPE=%x\tndx=%x\t%s\n",
		 (unsigned long)syms[i].st_value,
		 (unsigned long)syms[i].st_size,
		 ELF_ST_BIND(syms[i].st_info), ELF_ST_TYPE(syms[i].st_info),
		 syms[i].st_shndx, ElfGetString(elffile, syms[i].st_name));
d2195 3
a2197 3
	if (ELF_ST_BIND(syms[i].st_info) == STB_LOCAL)
	    /* Don't add static symbols to the symbol table */
	    continue;
d2199 12
a2210 10
	switch (ELF_ST_TYPE(syms[i].st_info)) {
	case STT_OBJECT:
	case STT_FUNC:
	case STT_SECTION:
	case STT_NOTYPE:
	    switch (syms[i].st_shndx) {
	    case SHN_ABS:
		ErrorF("ELF_GetSymbols() Don't know how to handle SHN_ABS\n");
		break;
	    case SHN_COMMON:
d2212 2
a2213 2
		ELFDEBUG("Adding COMMON space for %s\n",
			 ElfGetString(elffile, syms[i].st_name));
d2215 23
a2237 25
		if (!LoaderHashFind(ElfGetString(elffile, syms[i].st_name))) {
		    tmp = ElfAddCOMMON(&(syms[i]));
		    if (tmp) {
			tmp->next = listCOMMON;
			listCOMMON = tmp;
		    }
		}
		break;
	    case SHN_UNDEF:
		/*
		 * UNDEF will get resolved later, so the value
		 * doesn't really matter here.
		 */
		/* since we don't know the value don't advertise the symbol */
		break;
	    default:
		lookup[l].symName =
			xf86loaderstrdup(ElfGetString
					 (elffile, syms[i].st_name));
		lookup[l].offset = (funcptr) syms[i].st_value;
		secttable[l] = syms[i].st_shndx;
#ifdef ELFDEBUG
		ELFDEBUG("Adding symbol %lx(%d) %s\n",
			 (unsigned long)lookup[l].offset, secttable[l],
			 lookup[l].symName);
d2240 12
a2251 12
		if (ELF_ST_TYPE(syms[i].st_info) == STT_FUNC) {
		    ElfAddOPD(elffile, -1, &lookup[l]);
		}
#endif
		l++;
		break;
	    }
	    break;
	case STT_FILE:
	case STT_LOPROC:
	case STT_HIPROC:
	    /* Skip this type */
d2253 3
a2255 3
	    ELFDEBUG("Skipping TYPE %d %s\n",
		     ELF_ST_TYPE(syms[i].st_info),
		     ElfGetString(elffile, syms[i].st_name));
d2257 6
a2262 5
	    break;
	default:
	    ErrorF("ELF_GetSymbols(): Unepected symbol type %d\n",
		   ELF_ST_TYPE(syms[i].st_info));
	    break;
a2263 1
    }
d2265 1
a2265 1
    lookup[l].symName = NULL;	/* Terminate the list */
d2276 2
a2277 4
		) {
	    memmove(&(lookup[i]), &(lookup[i + 1]), (l - i) * sizeof(LOOKUP));
	    memmove(&(secttable[i]), &(secttable[i + 1]),
		    (l-- - i) * sizeof(unsigned short));
a2285 3
#define SecType(index) elffile->sections[index].sh_type
#define SecFlags(index) elffile->sections[index].sh_flags
#define SecInfo(index) elffile->sections[index].sh_info
d2303 5
a2307 2
ELFCollectSections(ELFModulePtr elffile, int pass, int *totalsize,
		   int *maxalign)
d2309 1
a2309 2
    int i;
    int j;
a2313 4
    j = elffile->lsectidx;
    for (i = 1; i < elffile->numsh; i++) {
	int flags = 0;
	char *name = ElfGetSectionName(elffile, elffile->sections[i].sh_name);
d2315 145
a2459 6
#if defined(__alpha__) || defined(__ia64__)
	if (!strcmp(name, ".got")	/*Isn't there a more generic way to do this? */
# if defined(__ia64__)
	    || !strcmp(name, ".plt") || !strcmp(name, ".IA_64.unwind_info")
# endif
		)
d2461 12
a2473 20
	switch (SecType(i)) {
	case SHT_STRTAB:
	    if (!strcmp(name, ".shstrtab"))	/* already loaded */
		continue;
	    if (!strcmp(name, ".stabstr"))	/* ignore debug info */
		continue;
	case SHT_SYMTAB:
	    if (pass)
		continue;
	    flags = LOADED_SECTION;
	    flags |= RELOC_SECTION;
	    break;
	case SHT_REL:
	case SHT_RELA:
	    if (pass)
		continue;
	    if (!(SecFlags(SecInfo(i)) & SHF_ALLOC))
		continue;
#ifdef __ia64__
	    if (SecType(SecInfo(i)) == SHT_IA_64_UNWIND)
d2475 85
d2561 11
a2571 11
	    flags = LOADED_SECTION;
	    flags |= RELOC_SECTION;
	    break;
	case SHT_PROGBITS:
	    flags |= LOADED_SECTION;
	case SHT_NOBITS:
	    if (!(elffile->sections[i].sh_flags & SHF_ALLOC))
		continue;
	    AdjustSize(i);
	    break;
	default:
d2573 91
a2663 2
	    if (pass)
		ELFDEBUG("ELF: Not loading %s\n", name);
d2665 18
d2685 28
a2712 48

	elffile->lsection = xf86loaderrealloc(elffile->lsection,
					      (j + 1) * sizeof(LoadSection));
	if (!(flags & RELOC_SECTION)) {
	    if (flags & LOADED_SECTION) {
		elffile->lsection[j].saddr	/* sect. contains data */
			= ELFLoaderSectToMem(elffile, SecAlign(i),
					     SecOffset(i), SecSize(i), name);
	    } else {
		if (SecSize(i))
		    elffile->lsection[j].saddr
			    = ELFLoaderSectCalloc(elffile, SecAlign(i),
						  SecSize(i));
		else
		    elffile->lsection[j].saddr = NULL;
	    }
	} else {
	    elffile->lsection[j].saddr =
		    (Elf_Sym *) _LoaderFileToMem(elffile->fd, SecOffset(i),
						 SecSize(i), name);
	}
	elffile->saddr[i] = elffile->lsection[j].saddr;
#ifdef ELFDEBUG
	ELFDEBUG("%s starts at %p size: %lx\n",
		 name, elffile->saddr[i], (unsigned long)SecSize(i));
#endif
	elffile->lsection[j].name = name;
	elffile->lsection[j].ndx = i;
	elffile->lsection[j].size = SecSize(i);
	elffile->lsection[j].flags = flags;
	switch (SecType(i)) {
#ifdef __OpenBSD__
	case SHT_PROGBITS:
	    mprotect(elffile->lsection[j].saddr, SecSize(i),
		     PROT_READ | PROT_WRITE | PROT_EXEC);
	    break;
#endif
	case SHT_SYMTAB:
	    elffile->symtab = (Elf_Sym *) elffile->saddr[i];
	    elffile->symndx = i;
	    break;
	case SHT_STRTAB:
	    elffile->straddr = elffile->saddr[i];
	    elffile->strsize = elffile->lsection[j].size;
	    elffile->strndx = i;
	    break;
	default:
	    break;
d2714 4
a2717 1
	elffile->lsectidx = ++j;
d2725 4
a2728 1
ELFLoadModule(loaderPtr modrec, int elffd, LOOKUP **ppLookup)
d2731 3
a2733 3
    Elf_Ehdr *header;
    ELFRelocPtr elf_reloc, tail;
    void *v;
d2735 1
a2735 1
    int totalsize, maxalign, i;
d2737 1
a2737 1
    LOOKUP *pLookup;
a2741 3
#ifdef ELFDEBUG
    ELFDEBUG("Loading %s %s\n", modrec->name, modrec->cname);
#endif
d2743 1
a2743 1
	ErrorF("Unable to allocate ELFModuleRec\n");
d2747 4
a2750 4
    elffile->handle = modrec->handle;
    elffile->module = modrec->module;
    elffile->fd = elffd;
    v = elffile->funcs = modrec->funcs;
d2755 3
a2757 4
    elffile->header =
	    (Elf_Ehdr *) _LoaderFileToMem(elffd, 0, sizeof(Elf_Ehdr),
					  "header");
    header = (Elf_Ehdr *) elffile->header;
d2762 5
a2766 5
    elffile->numsh = header->e_shnum;
    elffile->secsize = (header->e_shentsize * header->e_shnum);
    elffile->sections =
	    (Elf_Shdr *) _LoaderFileToMem(elffd, header->e_shoff,
					  elffile->secsize, "sections");
d2772 1
a2772 1
    elffile->gotndx = header->e_shnum;
d2774 2
a2775 2
# if defined(__ia64__)
    elffile->pltndx = header->e_shnum;
d2777 6
a2782 8
# endif
    elffile->numsh = header->e_shnum;
    elffile->secsize = (header->e_shentsize * header->e_shnum);
    elffile->sections =
	    xf86loaderrealloc(elffile->sections, elffile->secsize);
#endif /*defined(__alpha__) || defined(__ia64__) */
    elffile->saddr =
	    xf86loadercalloc(elffile->numsh, sizeof(unsigned char *));
d2789 5
a2793 6
    elffile->sections[elffile->gotndx].sh_name =
	    SecSize(header->e_shstrndx) + 1;
    elffile->sections[elffile->gotndx].sh_type = SHT_PROGBITS;
    elffile->sections[elffile->gotndx].sh_flags = SHF_WRITE | SHF_ALLOC;
    elffile->sections[elffile->gotndx].sh_size = 0;
    elffile->sections[elffile->gotndx].sh_addralign = 8;
d2795 1
a2795 1
    SecSize(header->e_shstrndx) += 8;
d2802 5
a2806 6
    elffile->sections[elffile->pltndx].sh_name =
	    SecSize(header->e_shstrndx) + 1;
    elffile->sections[elffile->pltndx].sh_type = SHT_PROGBITS;
    elffile->sections[elffile->pltndx].sh_flags = SHF_EXECINSTR | SHF_ALLOC;
    elffile->sections[elffile->pltndx].sh_size = 0;
    elffile->sections[elffile->pltndx].sh_addralign = 32;
d2808 1
a2808 1
    SecSize(header->e_shstrndx) += 32;
d2816 2
a2817 2
	    _LoaderFileToMem(elffd, SecOffset(header->e_shstrndx),
			     SecSize(header->e_shstrndx), ".shstrtab");
d2823 2
a2824 2
    strcpy((char *)(elffile->shstraddr +
		    elffile->sections[elffile->gotndx].sh_name), ".got");
d2830 2
a2831 2
    strcpy((char *)(elffile->shstraddr +
		    elffile->sections[elffile->pltndx].sh_name), ".plt");
d2840 2
a2841 2
    if (elffile->straddr == NULL || elffile->strsize == 0) {
#if 0
a2842 1
#endif
d2844 1
a2844 1
	return (void *)-1L;
d2846 1
d2855 25
a2879 7
    for (i = 0; i < elffile->lsectidx; i++) {
	switch (SecType(elffile->lsection[i].ndx)) {
	case SHT_REL:
	case SHT_RELA:
	    break;
	default:
	    continue;
d2881 3
a2883 1
	elf_reloc = ELFCollectRelocations(elffile, elffile->lsection[i].ndx);
d2885 2
a2886 1
	    for (tail = elf_reloc; tail->next; tail = tail->next) ;
a2905 2

# if !defined(DoMMAPedMerge)
d2908 1
a2908 21
	ErrorF("Unable to allocate ELF sections\n");
	return NULL;
    }
#  if defined(linux) && defined(__ia64__) || defined(__OpenBSD__)
    {
	unsigned long page_size = getpagesize();
	unsigned long round;

	round = (unsigned long)elffile->base & (page_size - 1);
	mprotect(elffile->base - round,
		 (elffile->basesize + round + page_size - 1) & ~(page_size -
								 1),
		 PROT_READ | PROT_WRITE | PROT_EXEC);
    }
#  endif
# else
    MMAP_ALIGN(elffile->basesize);
    elffile->base = mmap(0, elffile->basesize, MMAP_PROT, MMAP_FLAGS, -1,
			 (off_t) 0);
    if (elffile->base == NULL) {
	ErrorF("Unable to mmap ELF sections\n");
d2911 2
a2912 3
# endif
    elffile->baseptr =
	    ((long)elffile->base + (maxalign - 1)) & ~(maxalign - 1);
d2916 1
a2916 1
    if (!ELFCreateGOT(elffile, maxalign))
d2927 1
a2927 3
	    pLookup[i].offset =
		    (funcptr) ((long)pLookup[i].offset +
			       (long)elffile->saddr[secttable[i]]);
d2929 2
a2930 2
	    ELFDEBUG("Finalizing symbol %p %s\n",
		     (void *)pLookup[i].offset, pLookup[i].symName);
d2939 1
a2939 1
    if (!ElfCreateCOMMON(elffile, *ppLookup))
d2943 1
a2943 1
     * silently (the user will find out soon enough that there's no VM left */
d2948 4
a2951 12
	for (i = 0; i < elffile->lsectidx; i++) {
	    char *name = elffile->lsection[i].name;

	    if (!strcmp(name, ".text"))
		elfmod->text = elffile->lsection[i].saddr;
	    else if (!strcmp(name, ".data"))
		elfmod->data = elffile->lsection[i].saddr;
	    else if (!strcmp(name, ".rodata"))
		elfmod->rodata = elffile->lsection[i].saddr;
	    else if (!strcmp(name, ".bss"))
		elfmod->bss = elffile->lsection[i].saddr;
	}
d2965 2
a2966 1
ELFResolveSymbols(void *mod)
d2974 1
a2974 1
    for (p = _LoaderGetRelocations(mod)->elf_reloc; p;) {
d2976 2
a2977 4
	ELFDEBUG("ResolveSymbols: "
		 "file %p, sec %d, r_offset 0x%x, r_info 0x%p\n",
		 (void *)p->file, p->secn, p->rel->r_offset,
		 (void *)p->rel->r_info);
d2989 1
a2989 1
    _LoaderGetRelocations(mod)->elf_reloc = newlist;
d2993 2
a2994 1
ELFCheckForUnresolved(void *mod)
d2996 3
a2998 3
    ELFRelocPtr erel;
    char *name;
    int flag, fatalsym = 0;
d3003 1
a3003 1
    while (erel) {
d3006 4
a3009 6
	flag = _LoaderHandleUnresolved(name,
				       _LoaderHandleToName(erel->file->
							   handle));
	if (flag)
	    fatalsym = 1;
	erel = erel->next;
d3015 2
a3016 1
ELFUnloadModule(void *modptr)
d3018 2
a3019 3
    ELFModulePtr elffile = (ELFModulePtr) modptr;
    ELFRelocPtr relptr, reltptr, *brelptr;
    int i;
d3025 2
a3026 2
    relptr = _LoaderGetRelocations(elffile->funcs)->elf_reloc;
    brelptr = &(_LoaderGetRelocations(elffile->funcs)->elf_reloc);
d3028 11
a3038 10
    while (relptr) {
	if (relptr->file == elffile) {
	    *brelptr = relptr->next;	/* take it out of the list */
	    reltptr = relptr;	/* save pointer to this node */
	    relptr = relptr->next;	/* advance the pointer */
	    xf86loaderfree(reltptr);	/* free the node */
	} else {
	    brelptr = &(relptr->next);
	    relptr = relptr->next;	/* advance the pointer */
	}
d3050 1
a3050 5
#if !defined (DoMMAPedMerge)
# define CheckandFree(ptr,size)  if(ptr) xf86loaderfree(ptr)
#else
# define CheckandFree(ptr,size) if (ptr) munmap(ptr,size)
#endif
d3053 2
d3056 2
a3057 2
    CheckandFree(elffile->base, elffile->basesize);
# if defined(__alpha__) || defined(__ia64__)
a3061 1

d3069 17
a3085 9
# endif
#else /*MergeSectionAlloc */
    CheckandFree(elffile->common, elffile->comsize);
# if defined(__alpha__) || defined(__ia64__)
    CheckandFree(elffile->got, elffile->gotsize);
# endif
# if defined(__ia64__)
    CheckandFree(elffile->plt, elffile->pltsize);
# endif
d3090 1
a3090 2

	while ((gotent = elffile->got_entries)) {
a3098 1

a3105 1

d3112 4
a3115 16

    for (i = 0; i < elffile->lsectidx; i++) {
#ifdef MergeSectionAlloc
	if (!(elffile->lsection[i].flags & RELOC_SECTION))
	    continue;
#endif
	if (elffile->lsection[i].flags & LOADED_SECTION) {
	    CheckandFreeFile(elffile->lsection[i].saddr,
			     elffile->lsection[i].size);
	} else {
	    CheckandFree(elffile->lsection[i].saddr,
			 elffile->lsection[i].size);
	}
    }
    xf86loaderfree(elffile->lsection);

d3119 1
a3119 1
    _LoaderFreeFileMem(elffile->sections, elffile->secsize);
d3121 2
a3122 2
    _LoaderFreeFileMem(elffile->header, sizeof(Elf_Ehdr));
    _LoaderFreeFileMem(elffile->shstraddr, elffile->shstrsize);
d3135 1
a3135 1
    ELFModulePtr elffile = (ELFModulePtr) modptr;
d3138 5
a3142 4
    for (i = 1; i < elffile->numsh; i++) {
	if (address >= (unsigned long)elffile->saddr[i] &&
	    address <= (unsigned long)elffile->saddr[i] + SecSize(i)) {
	    return ElfGetSectionName(elffile, elffile->sections[i].sh_name);
a3143 1
    }
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/elfloader.c,v 1.49 2003/01/24 17:26:35 tsi Exp $ */
d30 1
a30 1
# include <fcntl.h>
d32 1
a32 1
# include <sys/fcntl.h>
a34 3
#if defined(linux) && defined (__ia64__)
#include <sys/mman.h>
#endif
d37 4
a40 4
# include <debug/malloc.h>
# define Xalloc(size) malloc(size)
# define Xcalloc(size) calloc(1,(size))
# define Xfree(size) free(size)
a51 2
#undef LDTEST

d54 1
a54 1
# define ELFDEBUG ErrorF
d59 3
a61 26
# if defined (__ia64__) || defined (__sparc__)
#  define MergeSectionAlloc
# endif
#endif

#if defined (DoMMAPedMerge)
# include <sys/mman.h>
# define MergeSectionAlloc
# define MMAP_PROT	(PROT_READ | PROT_WRITE | PROT_EXEC)
# if !defined(linux)
#  error    No MAP_ANON?
# endif
# if !defined (__x86_64__)
# define MMAP_FLAGS     (MAP_PRIVATE | MAP_ANON)
# else
# define MMAP_FLAGS     (MAP_PRIVATE | MAP_ANON | MAP_32BIT)
# endif
# if defined (MmapPageAlign)
#  define MMAP_ALIGN(size)    do { \
     int pagesize = getpagesize(); \
     size = ( size + pagesize - 1) / pagesize; \
     size *= pagesize; \
   } while (0);
# else
#  define MMAP_ALIGN(size)
# endif
a65 1
    defined (__x86_64__) || \
d84 1
a84 1
# if defined (__alpha__) || defined (__ia64__)
d104 1
a104 1
#  ifdef MergeSectionAlloc
d106 2
a107 2
#  endif
# endif
d109 1
a109 1
# if defined (__ia64__)
d131 1
a131 1
# endif
d154 1
a154 2
    defined(__ia64__) || \
    defined(__x86_64__)
a159 11
typedef struct {
    void *saddr;
    char *name;
    int ndx;
    int size;
    int flags;
} LoadSection;

#define RELOC_SECTION 0x1
#define LOADED_SECTION 0x2

d178 27
d211 1
a211 1
#endif /*(__alpha__) || (__ia64__)*/
d218 1
a218 1
#endif /*__ia64__*/
d221 13
d240 1
a240 6
	unsigned char *straddr;	/* Start address of the string table */
	int	strndx;		/* index of the string table */
	int	strsize;	/* size of the string table */
	LoadSection *lsection;
	int	lsectidx;
}	ELFModuleRec, *ELFModulePtr;
d296 1
a296 1
#endif /*__ia64__*/
d325 1
a325 3
#ifndef DoMMAPedMerge
    memset(ret, 0, size); /* mmap() does this for us */
#endif
d328 2
a329 2
#else /* MergeSectionAlloc */
# define ELFLoaderSectToMem(elffile,align,offset,size,label)	\
d331 1
a331 1
# define ELFLoaderSectCalloc(elffile,align,size) xf86loadercalloc(1,size)
d371 1
a371 1
# if defined(__powerpc__) || \
d375 1
a375 2
    defined(__ia64__) || \
    defined(__x86_64__)
d377 1
a377 1
# endif
a410 1
    defined(__x86_64__) || \
a435 1
    defined(__x86_64__) || \
a492 1
    defined(__x86_64__) || \
d726 1
a726 1
# ifdef ELFDEBUG
d730 1
a730 1
# endif
d758 1
a758 1
# ifdef ELFDEBUG
d771 1
a771 1
# endif
d780 1
a780 1
# ifdef ELFDEBUG
d782 1
a782 1
# endif
d791 1
a791 1
# ifdef ELFDEBUG
d793 1
a793 1
# endif
d807 1
a807 1
# ifdef MergeSectionAlloc
d809 1
a809 1
# endif
d815 1
a815 1
# ifdef ELFDEBUG
d825 1
a825 1
# endif
d830 7
a836 7
# ifdef MergeSectionAlloc
#  ifdef __alpha__
#   define GOTDistance 0x100000
#  endif
#  ifdef __ia64__
#   define GOTDistance 0x200000
#  endif
d851 1
a851 1
#  ifdef ELFDEBUG
d854 1
a854 1
#  endif
d859 1
a859 1
# endif /*MergeSectionAlloc*/
d866 1
a866 1
# ifdef MergeSectionAlloc
a876 1
#  if !defined(DoMMAPedMerge)
d883 2
a884 24
#   if defined(linux) && defined(__ia64__) || defined(__OpenBSD__)
	{
	    unsigned long page_size = getpagesize();
	    unsigned long round;

	    round = (unsigned long)elffile->base & (page_size-1);
	    mprotect(elffile->base - round, (elffile->basesize+round+page_size-1) & ~(page_size-1),
		     PROT_READ|PROT_WRITE|PROT_EXEC);
	}
#   endif
#  else
	{
	    int oldbasesize = elffile->basesize;
	    elffile->basesize += 8 + elffile->gotsize;
	    MMAP_ALIGN(elffile->basesize);
	    elffile->base = mremap(elffile->base,oldbasesize,
				   elffile->basesize,MREMAP_MAYMOVE);
	    if (elffile->base == NULL) {
		ErrorF( "ELFCreateGOT() Unable to remap memory!!!!\n" );
		return FALSE;
	    }
	}
#  endif

d896 1
a896 1
#  ifdef ELFDEBUG
d898 1
a898 1
#  endif
d900 1
a900 1
# endif/*MergeSectionAlloc*/
d902 1
a902 1
# ifdef ELFDEBUG
d904 1
a904 1
# endif
d908 1
a908 1
#endif /* defined(__alpha__) || defined(__ia64__)*/
d933 1
a933 1
# ifdef ELFDEBUG
d935 1
a935 1
# endif
d973 1
a973 1
# ifdef ELFDEBUG
d985 1
a985 1
# endif
d996 1
a996 1
# ifdef ELFDEBUG
d998 1
a998 1
# endif
d1007 1
a1007 1
# ifdef ELFDEBUG
d1009 1
a1009 1
# endif
d1024 1
a1024 1
# ifdef ELFDEBUG
d1026 1
a1026 1
# endif
d1035 1
a1035 1
# ifdef ELFDEBUG
d1037 1
a1037 1
# endif
d1051 1
a1051 1
# ifdef ELFDEBUG
d1054 1
a1054 1
# endif
d1088 1
a1088 1
# ifdef ELFDEBUG
d1090 1
a1090 1
# endif
d1093 1
a1093 1
#endif /*__ia64__*/
a1100 1

a1108 1
#if !defined(__ia64__)
a1109 1
#endif
d1116 1
a1116 1
#if defined(__alpha__) 
a1118 5
    unsigned short *dest16;
#endif
#if  defined(__x86_64__)
    unsigned long *dest64;
    int *dest32s;
d1129 1
a1129 1
# if defined(__powerpc__) || \
d1133 1
a1133 2
    defined(__ia64__) || \
    defined(__x86_64__)
d1135 1
a1135 1
# endif
d1137 1
a1137 1
#endif /*ELFDEBUG*/
d1139 1
a1139 1
    if (ELF_R_SYM(rel->r_info) && ELF_R_TYPE(rel->r_info) != R_ALPHA_GPDISP) 
d1141 1
a1141 1
    if (ELF_R_SYM(rel->r_info))
a1142 1
    {
d1162 1
a1162 1
# ifdef ELFDEBUG
d1166 1
a1166 1
# endif
d1168 1
a1168 1
# ifdef ELFDEBUG
d1170 1
a1170 1
# endif
d1174 1
a1174 1
# ifdef ELFDEBUG
d1181 1
a1181 1
# endif
d1185 1
a1185 1
# ifdef ELFDEBUG
d1187 1
a1187 1
# endif
a1190 58
#if defined(__x86_64__)
	case R_X86_64_32:
	    dest32=(unsigned int *)(secp+rel->r_offset );
# ifdef ELFDEBUG
	    ELFDEBUG( "R_X86_32\t");
	    ELFDEBUG( "dest32=%x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8lx\t", *dest32 );
	    ELFDEBUG( "r_addend=%lx\t", rel->r_addend);
# endif
	    *dest32=symval + rel->r_addend + (*dest32); /* S + A */
# ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8lx\n", *dest32 );
# endif
	    break;
	case R_X86_64_32S:
	    dest32s=(int *)(secp+rel->r_offset);
# ifdef ELFDEBUG
	    ELFDEBUG( "R_X86_64_32\t");
	    ELFDEBUG( "dest32s=%x\t", dest32s );
	    ELFDEBUG( "*dest32s=%8.8lx\t", *dest32s );
	    ELFDEBUG( "r_addend=%lx\t", rel->r_addend);
# endif
	    *dest32s=symval + rel->r_addend + (*dest32s); /* S + A */
# ifdef ELFDEBUG
	    ELFDEBUG( "*dest32s=%8.8lx\n", *dest32s );
# endif
	    break;
	case R_X86_64_PC32:
	    dest32=(unsigned int *)(secp+rel->r_offset);
# ifdef ELFDEBUG
	    ELFDEBUG( "R_X86_64_PC32 %s\t",
			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    ELFDEBUG( "secp=%x\t", secp );
	    ELFDEBUG( "symval=%lx\t", symval );
	    ELFDEBUG( "dest32=%x\t", dest32 );
	    ELFDEBUG( "*dest32=%8.8lx\t", *dest32 );
	    ELFDEBUG( "r_addend=%lx\t", rel->r_addend);
# endif
	    *dest32 = symval + rel->r_addend + (*dest32)-(Elf_Addr)dest32; /* S + A - P */

# ifdef ELFDEBUG
	    ELFDEBUG( "*dest32=%8.8lx\n", *dest32 );
# endif
	    break;
	case R_X86_64_64:
	    dest64=(unsigned long *)(secp+rel->r_offset);
# ifdef ELFDEBUG
	    ELFDEBUG( "R_x86_64_64\t");
	    ELFDEBUG( "dest64=%x\t", dest64 );
	    ELFDEBUG( "*dest64=%8.8lx\t", *dest64 );
	    ELFDEBUG( "r_addend=%lx\t", rel->r_addend);
# endif
	    *dest64=symval + rel->r_addend + (*dest64); /* S + A */
# ifdef ELFDEBUG
	    ELFDEBUG( "*dest64=%8.8lx\n", *dest64 );
# endif
	    break;
#endif /* __x86_64__ */
d1200 1
a1200 1
# ifdef ELFDEBUG
d1204 1
a1204 1
# endif
d1206 1
a1206 1
# ifdef ELFDEBUG
d1208 1
a1208 1
# endif
d1216 1
a1216 1
# ifdef ELFDEBUG
d1223 1
a1223 1
# endif
d1226 1
a1226 1
# ifdef ELFDEBUG
d1228 1
a1228 1
# endif
d1236 1
a1236 1
# ifdef ELFDEBUG
d1238 1
a1238 30
# endif
	    break;
	    }

	case R_ALPHA_GPRELLOW:
	    {
	    dest64=(unsigned long *)(secp+rel->r_offset);
	    dest16=(unsigned short *)dest64;

	    symval += rel->r_addend;
	    symval = ((unsigned char *)symval)-((unsigned char *)elffile->got);

	    *dest16=symval;
	    break;
	    }

	case R_ALPHA_GPRELHIGH:
	    {
	    dest64=(unsigned long *)(secp+rel->r_offset);
	    dest16=(unsigned short *)dest64;

	    symval += rel->r_addend;
	    symval = ((unsigned char *)symval)-((unsigned char *)elffile->got);
	    symval = ((long)symval >> 16) + ((symval >> 15) & 1);
	    if( (long)symval > 0x7fff || (long)symval < -(long)0x8000 ) {
		FatalError("R_ALPHA_GPRELHIGH symval-got is too large for %s:%lx\n",
		ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)),symval);
	    }

	    *dest16=symval;
a1240 1

d1245 1
a1245 1
# ifdef ELFDEBUG
d1252 1
a1252 1
# endif
d1264 1
a1264 1
# ifdef ELFDEBUG
d1267 1
a1267 1
# endif
d1278 1
a1278 1
# ifdef ELFDEBUG
d1280 1
a1280 1
# endif
d1289 1
a1289 1
# ifdef ELFDEBUG
d1291 1
a1291 1
# endif
d1303 1
a1303 1
# ifdef ELFDEBUG
d1308 1
d1313 1
a1313 1
# endif
d1323 1
a1323 1
# ifdef ELFDEBUG
d1326 1
a1326 1
# endif
d1333 1
a1333 1
# ifdef ELFDEBUG
d1335 1
a1335 1
# endif
d1339 1
a1339 1
# ifdef ELFDEBUG
d1342 1
a1342 1
# endif
d1348 1
a1348 1
# ifdef ELFDEBUG
d1355 1
a1355 1
# endif
d1357 1
a1357 1
# ifdef ELFDEBUG
d1359 1
a1359 1
# endif
d1366 1
a1366 1
# ifdef ELFDEBUG
d1368 1
a1368 1
# endif
d1371 1
a1371 1
# ifdef ELFDEBUG
d1373 1
a1373 1
# endif
d1378 1
a1378 1
# ifdef ELFDEBUG
d1380 1
a1380 1
# endif
a1381 17

 	case R_ALPHA_GPREL16:
 	    {
 	    dest64=(unsigned long *)(secp+rel->r_offset);
 	    dest16=(unsigned short *)dest64;
 
 	    symval += rel->r_addend;
 	    symval = ((unsigned char *)symval)-((unsigned char *)elffile->got);
 	    if( (long)symval > 0x7fff ||
 	        (long)symval < -(long)0x8000 ) {
 		FatalError("R_ALPHA_GPREL16 symval-got is too large for %s:%lx\n",
 			ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)),symval);
 	    }
 
 	    *dest16=symval;
 	    break;
  	    }
d1387 1
a1387 1
# ifdef ELFDEBUG
d1394 1
a1394 1
# endif
d1399 1
a1399 1
# ifdef ELFDEBUG
d1401 1
a1401 1
# endif
d1404 1
a1404 1
# ifdef ELFDEBUG
d1406 1
a1406 1
# endif
d1410 1
a1410 1
# ifdef ELFDEBUG
d1417 1
a1417 1
# endif
d1423 1
a1423 1
# ifdef ELFDEBUG
d1426 1
a1426 1
# endif
d1429 1
a1429 1
# ifdef ELFDEBUG
d1431 1
a1431 1
# endif
d1435 1
a1435 1
# if defined(PowerMAX_OS)
d1438 1
a1438 1
#  ifdef ELFDEBUG
d1444 1
a1444 1
#  endif
d1451 1
a1451 1
#  ifdef ELFDEBUG
d1453 1
a1453 1
#  endif
d1457 1
a1457 1
#  ifdef ELFDEBUG
d1459 1
a1459 1
#  endif
d1462 1
a1462 1
#  ifdef ELFDEBUG
d1464 1
a1464 1
#  endif
d1474 1
a1474 1
#  ifdef ELFDEBUG
d1476 1
a1476 1
#  endif
d1480 1
a1480 1
#  ifdef ELFDEBUG
d1483 2
a1484 2
#  endif
#  ifdef ELFDEBUG
d1493 1
a1493 1
#  endif
d1498 1
a1498 1
#  ifdef ELFDEBUG
d1500 1
a1500 1
#  endif
d1504 1
a1504 1
#  ifdef ELFDEBUG
d1507 1
a1507 1
#  endif
d1511 1
a1511 1
#  ifdef ELFDEBUG
d1518 1
a1518 1
#  endif
d1523 1
a1523 1
#  ifdef ELFDEBUG
d1525 1
a1525 1
#  endif
d1529 1
a1529 1
#  ifdef ELFDEBUG
d1531 1
a1531 1
#  endif
d1535 1
a1535 1
#  ifdef ELFDEBUG
d1542 1
a1542 1
#  endif
d1548 1
a1548 1
#  ifdef ELFDEBUG
d1550 1
a1550 1
#  endif
d1557 1
a1557 1
#  ifdef ELFDEBUG
d1559 1
a1559 1
#  endif
d1563 1
a1563 1
#  ifdef ELFDEBUG
d1565 2
a1566 2
#  endif
#  ifdef ELFDEBUG
d1576 1
a1576 1
#  endif
d1592 1
a1592 1
#  ifdef ELFDEBUG
d1594 1
a1594 1
#  endif
d1598 1
a1598 1
#  ifdef ELFDEBUG
d1601 1
a1601 1
#  endif
d1605 1
a1605 1
#  ifdef ELFDEBUG
d1607 2
a1608 2
#  endif
#  ifdef ELFDEBUG
d1617 1
a1617 1
#  endif
d1622 1
a1622 1
#  ifdef ELFDEBUG
d1624 1
a1624 1
#  endif
d1628 1
a1628 1
#  ifdef ELFDEBUG
d1631 1
a1631 1
#  endif
d1633 1
a1633 1
# else /* PowerMAX_OS */
d1638 1
a1638 1
#  ifdef ELFDEBUG
d1645 1
a1645 1
#  endif
d1650 1
a1650 1
#  ifdef ELFDEBUG
d1652 1
a1652 1
#  endif
d1656 1
a1656 1
#  ifdef ELFDEBUG
d1658 1
a1658 1
#  endif
d1662 1
a1662 1
#  ifdef ELFDEBUG
d1664 2
a1665 2
#  endif
#  ifdef ELFDEBUG
d1672 1
a1672 1
#  endif
d1677 1
a1677 1
#  ifdef ELFDEBUG
d1679 1
a1679 1
#  endif
d1683 1
a1683 1
#  ifdef ELFDEBUG
d1686 1
a1686 1
#  endif
d1690 1
a1690 1
#  ifdef ELFDEBUG
d1692 2
a1693 2
#  endif
#  ifdef ELFDEBUG
d1700 1
a1700 1
#  endif
d1716 1
a1716 1
#  ifdef ELFDEBUG
d1718 1
a1718 1
#  endif
d1722 1
a1722 1
#  ifdef ELFDEBUG
d1725 1
a1725 1
#  endif
d1729 1
a1729 1
#  ifdef ELFDEBUG
d1735 1
a1735 1
#  endif
d1742 1
a1742 1
#  ifdef ELFDEBUG
d1744 1
a1744 1
#  endif
d1748 1
a1748 1
#  ifdef ELFDEBUG
d1750 1
a1750 1
#  endif
d1753 1
a1753 1
#  ifdef ELFDEBUG
d1755 1
a1755 1
#  endif
d1765 1
a1765 1
#  ifdef ELFDEBUG
d1767 1
a1767 1
#  endif
d1771 1
a1771 1
#  ifdef ELFDEBUG
d1778 1
a1778 1
#  endif
d1784 1
a1784 1
#  ifdef ELFDEBUG
d1787 1
a1787 1
#  endif
d1791 1
a1791 1
#  ifdef ELFDEBUG
d1793 1
a1793 1
#  endif
d1795 1
a1795 1
# endif /* PowerMAX_OS */
d1895 1
a1895 1
#endif /*__sparc__*/
d1903 1
a1903 1
# ifdef ELFDEBUG
d1906 1
a1906 1
# endif
d1912 1
a1912 1
# ifdef ELFDEBUG
d1921 1
a1921 1
# endif
d1933 1
a1933 1
# ifdef ELFDEBUG
d1936 1
a1936 1
# endif
d1951 1
a1951 1
# ifdef ELFDEBUG
d1960 1
a1960 1
# endif
d2006 1
a2006 1
# ifdef ELFDEBUG
d2013 1
a2013 1
# endif
d2023 1
a2023 1
# ifdef ELFDEBUG
d2029 1
a2029 1
# endif
a2033 12
	case R_IA64_PCREL64LSB:
	    dest64=(unsigned long *)(secp+rel->r_offset);
#ifdef ELFDEBUG
	    ELFDEBUG( "R_IA64_PCREL64LSB %s\t",
		      ElfGetSymbolName(elffile,ELF_R_SYM(rel->r_info)) );
	    ELFDEBUG( "secp=%lx\t", secp );
	    ELFDEBUG( "symval=%lx\t", symval );
	    ELFDEBUG( "dest64=%lx\n", dest64 );
#endif
	    *dest64 = symval + rel->r_addend - (unsigned long)dest64;
	    break;

d2036 1
a2036 1
# ifdef ELFDEBUG
d2044 1
a2044 1
# endif
d2049 1
a2049 1
#endif /*__ia64__*/
d2054 1
a2054 1
# ifdef ELFDEBUG
d2058 1
a2058 1
# endif
d2060 1
a2060 1
# ifdef ELFDEBUG
d2062 1
a2062 1
# endif
d2067 1
a2067 1
# ifdef ELFDEBUG
d2078 1
a2078 1
# endif
d2082 1
a2082 1
# ifdef ELFDEBUG
d2084 1
a2084 1
# endif
a2095 1
#ifdef NOTYET
a2096 1
#endif
a2285 3
#define SecType(index) elffile->sections[index].sh_type
#define SecFlags(index) elffile->sections[index].sh_flags
#define SecInfo(index) elffile->sections[index].sh_info
d2310 1
a2310 1
    int j;
d2314 5
a2318 1
    j = elffile->lsectidx;
d2320 154
a2473 13
	int flags = 0;
	char *name = ElfGetSectionName(elffile, elffile->sections[i].sh_name);

#if defined(__alpha__) || defined(__ia64__)
	if (!strcmp(name,".got") /*Isn't there a more generic way to do this?*/
# if defined(__ia64__)
	    || !strcmp(name,".plt") || !strcmp(name, ".IA_64.unwind_info")
# endif
	    ) continue;
#endif
	switch (SecType(i)) {
	case SHT_STRTAB:
	    if (!strcmp(name,".shstrtab")) /* already loaded */
d2475 77
a2551 3
	    if (!strcmp(name,".stabstr"))  /* ignore debug info */
		continue;
	case SHT_SYMTAB:
d2553 7
a2559 11
	    flags = LOADED_SECTION;
	    flags |= RELOC_SECTION;
	    break;
	case SHT_REL:
	case SHT_RELA:
  	    if (pass) continue;
	    if (! (SecFlags(SecInfo(i)) & SHF_ALLOC))
	      continue;
#ifdef __ia64__
	    if (SecType(SecInfo(i)) == SHT_IA_64_UNWIND)
	      continue;
d2561 11
a2571 11
  	    flags = LOADED_SECTION;
  	    flags |= RELOC_SECTION;
  	    break;
	case SHT_PROGBITS:
	    flags |= LOADED_SECTION;
	case SHT_NOBITS:
	    if (! (elffile->sections[i].sh_flags & SHF_ALLOC))
		continue;
	    AdjustSize(i);
	    break;
	default:
d2573 1
a2573 2
	    if (pass)
		ELFDEBUG("ELF: Not loading %s\n",name);
d2577 101
a2677 36
	
	elffile->lsection = xf86loaderrealloc(elffile->lsection,
					      (j + 1) * sizeof (LoadSection));
	if (!(flags & RELOC_SECTION)) {
	    if (flags & LOADED_SECTION) { 
		elffile->lsection[j].saddr /* sect. contains data */
		    = ELFLoaderSectToMem(elffile,SecAlign(i),SecOffset(i),
					 SecSize(i), name);
	    } else {
		if( SecSize(i) )
		    elffile->lsection[j].saddr  
			= ELFLoaderSectCalloc(elffile,SecAlign(i),
					      SecSize(i));
	        else
		    elffile->lsection[j].saddr = NULL;
	    }
	} else {
	    elffile->lsection[j].saddr =
		(Elf_Sym *)_LoaderFileToMem(elffile->fd,SecOffset(i),
					    SecSize(i),name);
	}
	elffile->saddr[i]=elffile->lsection[j].saddr;
#ifdef ELFDEBUG
	ELFDEBUG("%s starts at %lx size: %lx\n",
		 name, elffile->saddr[i], SecSize(i));
#endif	
	elffile->lsection[j].name= name;
	elffile->lsection[j].ndx = i;
	elffile->lsection[j].size=SecSize(i);
	elffile->lsection[j].flags=flags;
	switch (SecType(i)) {
#ifdef __OpenBSD__
	case SHT_PROGBITS:
	    mprotect(elffile->lsection[j].saddr, SecSize(i), 
		     PROT_READ|PROT_WRITE|PROT_EXEC);
	    break;
d2679 34
a2712 11
	case SHT_SYMTAB:
	    elffile->symtab = (Elf_Sym *)elffile->saddr[i];
	    elffile->symndx = i;
	    break;
	case SHT_STRTAB:
	    elffile->straddr = elffile->saddr[i];
	    elffile->strsize = elffile->lsection[j].size;
	    elffile->strndx = i;
	    break;
	default:
	    break;
d2714 4
a2717 1
	elffile->lsectidx = ++j;
d2738 1
a2738 1
    
a2741 3
#ifdef ELFDEBUG
    ELFDEBUG("Loading %s %s\n", modrec->name, modrec->cname);
#endif
d2763 1
a2763 1
    elffile->secsize=(header->e_shentsize * header->e_shnum);
d2774 1
a2774 1
# if defined(__ia64__)
d2777 1
a2777 1
# endif
d2781 1
a2781 1
#endif /*defined(__alpha__) || defined(__ia64__)*/
d2840 1
a2841 1
#if 0
a2842 1
#endif
d2844 1
a2844 1
	return (void *) -1L;
d2846 1
d2855 25
a2879 7
    for (i = 0; i < elffile->lsectidx; i++) {
	switch (SecType(elffile->lsection[i].ndx)) {
	case SHT_REL:
	case SHT_RELA:
	    break;
	default:
	    continue;
d2881 3
a2883 1
	elf_reloc = ELFCollectRelocations(elffile,elffile->lsection[i].ndx);
a2905 2
 
# if !defined(DoMMAPedMerge)
d2911 1
a2911 19
#  if defined(linux) && defined(__ia64__) || defined(__OpenBSD__)
    {
	unsigned long page_size = getpagesize();
	unsigned long round;

	round = (unsigned long)elffile->base & (page_size-1);
	mprotect(elffile->base - round, (elffile->basesize+round+page_size-1) & ~(page_size-1),
		 PROT_READ|PROT_WRITE|PROT_EXEC);
    }
#  endif
# else 
    MMAP_ALIGN(elffile->basesize);
    elffile->base = mmap( 0,elffile->basesize,MMAP_PROT,MMAP_FLAGS,-1,
			  (off_t)0);
    if (elffile->base == NULL) {
	ErrorF( "Unable to mmap ELF sections\n" );
	return NULL;
    }
# endif
d2948 4
a2951 11
	for (i=0; i < elffile->lsectidx;i++) {
	    char *name = elffile->lsection[i].name;
	    if (!strcmp(name,".text"))
		elfmod->text = elffile->lsection[i].saddr;
	    else if (!strcmp(name,".data"))
		elfmod->data = elffile->lsection[i].saddr;
	    else if (!strcmp(name,".rodata"))
		elfmod->rodata = elffile->lsection[i].saddr;
	    else if (!strcmp(name,".bss"))
		elfmod->bss = elffile->lsection[i].saddr;
	}
d3020 1
a3020 2
    int i;
    
d3050 1
a3050 5
#if !defined (DoMMAPedMerge)
# define CheckandFree(ptr,size)  if(ptr) xf86loaderfree(ptr)
#else 
# define CheckandFree(ptr,size) if (ptr) munmap(ptr,size)
#endif
d3053 2
d3057 1
a3057 1
# if defined(__alpha__) || defined(__ia64__)
d3069 10
a3078 2
# endif
#else /*MergeSectionAlloc*/
d3080 1
a3080 1
# if defined(__alpha__) || defined(__ia64__)
d3082 2
a3083 2
# endif
# if defined(__ia64__)
d3085 1
a3085 1
# endif
d3112 4
a3115 16

    for (i = 0; i < elffile->lsectidx; i++) {
#ifdef MergeSectionAlloc
	if (!(elffile->lsection[i].flags & RELOC_SECTION))
	    continue;
#endif
	if (elffile->lsection[i].flags & LOADED_SECTION) {
	    CheckandFreeFile(elffile->lsection[i].saddr,
			     elffile->lsection[i].size);
	} else {
	    CheckandFree(elffile->lsection[i].saddr,
			 elffile->lsection[i].size);
	}
    }
    xf86loaderfree(elffile->lsection);

d3123 1
a3123 2
	
    
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/elfloader.c,v 1.62 2003/11/06 18:38:13 tsi Exp $ */
a25 1
#ifndef __UNIXOS2__
a26 1
#endif
d55 1
a55 3
#ifndef LOADERDEBUG
#define LOADERDEBUG 0
#endif
d57 2
a58 1
#if LOADERDEBUG
d61 1
a61 62

#if defined(__ia64__)

/*
 * R_IA64_LTOFF22X and R_IA64_LDXMOV are relocation optimizations for
 * IA64. Conforming implementations must recognize them and may either
 * implement the optimization or may fallback to previous
 * non-optimized behavior by treating R_IA64_LTOFF22X as a
 * R_IA64_LTOFF22 and ignoring R_IA64_LDXMOV. The
 * IA64_LDX_OPTIMIZATION conditional controls the fallback behavior,
 * if defined the optimizations are performed.
 *
 * To implement the optimization we want to change is the sequence on
 * the left to that on the right, without regard to any intervening
 * instructions:
 * 
 * 1)  addl    t1=@@ltoff(var),gp    ==>    addl    t1=@@gprel(var),gp
 * 2)  ld8     t2=[t1]              ==>    mov     t2=t1
 * 3)  ld8     loc0=[t2]            ==>    ld8     loc0=[t2]
 * 
 * The relocations that match the above instructions are:
 * 
 * 1)  R_IA64_LTOFF22               ==>    R_IA64_LTOFF22X
 * 2)  --                           ==>    R_IA64_LDXMOV
 * 3)  --                           ==>    --
 *
 * First lets look at left hand column to understand the original
 * mechanism. The virtual address of a symbol is stored in the GOT,
 * when that symbol is referenced the following sequence occurs,
 * instruction 1 loads the address of the GOT entry containing the
 * virtural address of the symbol into t1. Instruction 2 loads the
 * virtual address of the symbol into t2 by dereferencing t1. Finally
 * the symbol is loaded in instruction 3 by dereferencing its virtual
 * address in t2.
 * 
 * The optimization that LTOFF22X/LDXMOV introduces is based on the
 * observation we are doing an extra load (instruction 2) if we can
 * generate the virtual address for the symbol without doing a lookup in
 * the GOT. This is possible if the virtual address of the symbol can be
 * computed via GP relative addressing. In other words the virtual
 * address of the symbol is a fixed offset from the GP. This fixed offset
 * must be within the limits of the signed 22 bit immediate offset in the
 * ld8 instruction, otherwise the original indirect GOT lookup must be
 * performed (LTOFF22).
 * 
 * If we can use GP relative addressing for the symbol then the
 * instruction that loaded the virtual address of the symbol into t2 must
 * also be patched, hence the introduction of the LDXMOV relocation. The
 * LDXMOV essentially turns the GOT lookup into a no-op by changing the
 * ld8 into a register move that preserves the register location of the
 * symbol's virtual address (e.g. t2).
 * 
 * The important point to recognize when implementing the LTOFF22X/LDXMOV
 * optimization is that relocations are interdependent, the LDXMOV is
 * only applied if the LTOFF22X is applied. It is also worth noting that
 * there is no relationship between LDXMOV relocations and LTOFF22X in
 * the ELF relocation section other than they share the same
 * symbol+addend value.
 */

#define IA64_LDX_OPTIMIZATION 1
#endif
d76 1
a76 1
# if !defined (__AMD64__) || !defined(__linux__)
d94 1
a94 1
    defined (__AMD64__) || \
a107 1

d120 3
a122 3
    Elf_Rela *rel;
    int offset;
    struct _elf_GOT_Entry *next;
d126 5
a130 5
    unsigned int size;
    unsigned int nuses;
    unsigned char *freeptr;
    struct _elf_GOT *next;
    unsigned char section[1];
d144 4
a147 4
    Elf_Rela *rel;
    int offset;
    int gotoffset;
    struct _elf_PLT_Entry *next;
d155 4
a158 4
    LOOKUP *l;
    int index;
    int offset;
    struct _elf_OPD *next;
a172 1

d184 1
a184 2
    defined(__AMD64__) || \
    defined(__amd64__) 
d187 1
a187 1
typedef Elf_Rel Elf_Rel_t;
d206 13
a218 13
typedef struct {
    int handle;
    int module;
    int fd;
    loader_funcs *funcs;
    Elf_Ehdr *header;		/* file header */
    int numsh;
    Elf_Shdr *sections;		/* Address of the section header table */
    int secsize;		/* size of the section table */
    unsigned char **saddr;	/* Start addresss of the section pointer table */
    unsigned char *shstraddr;	/* Start address of the section header string table */
    int shstrndx;		/* index of the section header string table */
    int shstrsize;		/* size of the section header string table */
d220 6
a225 6
    unsigned char *got;		/* Start address of the .got section */
    ELFGotEntryPtr got_entries;	/* List of entries in the .got section */
    int gotndx;			/* index of the .got section */
    int gotsize;		/* actual size of the .got section */
    ELFGotPtr shared_got;	/* Pointer to ELFGotRec if shared */
#endif				/*(__alpha__) || (__ia64__) */
d227 5
a231 5
    ELFOpdPtr opd_entries;	/* List of entries in the .opd section */
    unsigned char *plt;		/* Start address of the .plt section */
    ELFPltEntryPtr plt_entries;	/* List of entries in the .plt section */
    int pltndx;			/* index of the .plt section */
    int pltsize;		/* size of the .plt section */
d233 14
a246 14
    Elf_Sym *symtab;		/* Start address of the .symtab section */
    int symndx;			/* index of the .symtab section */
    unsigned char *common;	/* Start address of the SHN_COMMON space */
    int comsize;		/* size of the SHN_COMMON space */

    unsigned char *base;	/* Alloced address of section block */
    unsigned long baseptr;	/* Pointer to next free space in base */
    int basesize;		/* Size of that allocation */
    unsigned char *straddr;	/* Start address of the string table */
    int strndx;			/* index of the string table */
    int strsize;		/* size of the string table */
    LoadSection *lsection;
    int lsectidx;
} ELFModuleRec, *ELFModulePtr;
d253 4
a256 4
    Elf_Rel_t *rel;
    ELFModulePtr file;
    Elf_Word secn;
    struct _elf_reloc *next;
d266 2
a267 2
    Elf_Sym *sym;
    struct _elf_COMMON *next;
d270 1
a270 1
static ELFCommonPtr listCOMMON = NULL;
d280 1
a280 1
static int ElfCreateCOMMON(ELFModulePtr, LOOKUP *);
d284 1
a284 2
static ELFRelocPtr Elf_RelocateEntry(ELFModulePtr, Elf_Word, Elf_Rel_t *,
				     int);
a287 1

d299 1
a299 2
    IA64_OPND_TGT25C,
    IA64_OPND_LDXMOV
d306 6
a311 2
ELFLoaderSectToMem(ELFModulePtr elffile, int align, unsigned long offset,
		   int size, char *label)
a313 1

d322 4
a325 1
ELFLoaderSectCalloc(ELFModulePtr elffile, int align, int size)
a327 1

d332 1
a332 1
    memset(ret, 0, size);	/* mmap() does this for us */
d346 1
d348 3
a350 1
ELFhashCleanOut(void *voidptr, itemPtr item)
a352 1

d360 4
a363 1
ElfDelayRelocation(ELFModulePtr elffile, Elf_Word secn, Elf_Rel_t *rel)
d365 1
a365 1
    ELFRelocPtr reloc;
d368 1
a368 1
	ErrorF("ElfDelayRelocation() Unable to allocate memory!!!!\n");
d371 4
a374 4
    reloc->file = elffile;
    reloc->secn = secn;
    reloc->rel = rel;
    reloc->next = 0;
d376 1
a376 1
    ELFDEBUG("ElfDelayRelocation %p: file %p, sec %d,"
d378 1
a378 2
	     (void *)reloc, (void *)elffile, secn,
	     (unsigned long)rel->r_offset, rel->r_info);
d384 1
a384 2
    defined(__AMD64__) || \
    defined(__amd64__)
d396 2
a397 1
ElfAddCOMMON(Elf_Sym *sym)
d402 1
a402 1
	ErrorF("ElfAddCOMMON() Unable to allocate memory!!!!\n");
d405 2
a406 2
    common->sym = sym;
    common->next = 0;
d413 1
a413 1
    int size = 0;
d417 1
a417 1
	size += common->sym->st_size;
d420 1
a420 2
    defined(__AMD64__) || \
    defined(__amd64__) || \
d424 1
a424 1
	size = (size + 7) & ~0x7;
d431 3
a433 1
ElfCreateCOMMON(ELFModulePtr elffile, LOOKUP *pLookup)
d435 2
a436 2
    int numsyms = 0, size = 0, l = 0;
    int offset = 0, firstcommon = 0;
d443 1
a443 1
	size += common->sym->st_size;
d446 1
a446 2
    defined(__AMD64__) || \
    defined(__amd64__) || \
d450 1
a450 1
	size = (size + 7) & ~0x7;
d457 1
a457 1
	     numsyms, size);
d460 3
a462 3
    elffile->comsize = size;
    if ((elffile->common = ELFLoaderSectCalloc(elffile, 8, size)) == NULL) {
	ErrorF("ElfCreateCOMMON() Unable to allocate memory!!!!\n");
d466 3
a468 2
    if (DebuggerPresent) {
	ldrCommons = xf86loadermalloc(numsyms * sizeof(LDRCommon));
d472 4
a475 3
    for (l = 0; pLookup[l].symName; l++) ;
    firstcommon = l;

d480 2
a481 2
    while (listCOMMON) {
	common = listCOMMON;
d486 2
a487 2
		xf86loaderstrdup(ElfGetString(elffile, common->sym->st_name));
	pLookup[l].offset = (funcptr) (elffile->common + offset);
d489 2
a490 2
	ELFDEBUG("Adding common %p %s\n",
		 (void *)pLookup[l].offset, pLookup[l].symName);
d492 1
a492 1

d494 5
a498 4
	if (DebuggerPresent && ldrCommons) {
	    ldrCommons[l - firstcommon].addr = (void *)pLookup[l].offset;
	    ldrCommons[l - firstcommon].name = pLookup[l].symName;
	    ldrCommons[l - firstcommon].namelen = strlen(pLookup[l].symName);
d500 2
a501 2
	listCOMMON = common->next;
	offset += common->sym->st_size;
d504 1
a504 2
    defined(__AMD64__) || \
    defined(__amd64__) || \
d508 1
a508 1
	offset = (offset + 7) & ~0x7;
d514 1
a514 1
    pLookup[l].symName = NULL;	/* Terminate the list. */
d518 1
d523 4
a526 1
ElfGetStringIndex(ELFModulePtr file, int offset, int index)
d528 2
a529 2
    if (!offset || !index)
	return "";
d531 1
a531 1
    return (char *)(file->saddr[index] + offset);
d535 3
a537 1
ElfGetString(ELFModulePtr file, int offset)
d539 1
a539 1
    return ElfGetStringIndex(file, offset, file->strndx);
d543 3
a545 1
ElfGetSectionName(ELFModulePtr file, int offset)
d547 1
a547 1
    return (char *)(file->shstraddr + offset);
d550 2
d560 4
a563 1
ElfGetSymbolNameIndex(ELFModulePtr elffile, int index, int secndx)
d565 1
a565 1
    Elf_Sym *syms;
d568 1
a568 1
    ELFDEBUG("ElfGetSymbolNameIndex(%x,%x) ", index, secndx);
d571 1
a571 1
    syms = (Elf_Sym *) elffile->saddr[secndx];
d574 2
a575 2
    ELFDEBUG("%s ", ElfGetString(elffile, syms[index].st_name));
    ELFDEBUG("%x %x ", ELF_ST_BIND(syms[index].st_info),
d577 1
a577 1
    ELFDEBUG("%lx\n", (unsigned long)syms[index].st_value);
d580 1
a580 1
    return ElfGetString(elffile, syms[index].st_name);
d584 3
a586 1
ElfGetSymbolName(ELFModulePtr elffile, int index)
d592 8
a599 6
ElfGetSymbolValue(ELFModulePtr elffile, int index)
{
    Elf_Sym *syms;
    Elf_Addr symval = 0;	/* value of the indicated symbol */
    char *symname = NULL;	/* name of symbol in relocation */
    itemPtr symbol = NULL;	/* name/value of symbol */
d601 1
a601 1
    syms = (Elf_Sym *) elffile->saddr[elffile->symndx];
d603 11
a613 8
    switch (ELF_ST_TYPE(syms[index].st_info)) {
    case STT_NOTYPE:
    case STT_OBJECT:
    case STT_FUNC:
	switch (ELF_ST_BIND(syms[index].st_info)) {
	case STB_LOCAL:
	    symval = (Elf_Addr) (elffile->saddr[syms[index].st_shndx] +
				 syms[index].st_value);
d615 30
a644 13
	    if (ELF_ST_TYPE(syms[index].st_info) == STT_FUNC) {
		ELFOpdPtr opdent;

		for (opdent = elffile->opd_entries; opdent;
		     opdent = opdent->next)
		    if (opdent->index == index)
			break;
		if (opdent) {
		    ((unsigned long *)(elffile->got + opdent->offset))[0] =
			    symval;
		    ((unsigned long *)(elffile->got + opdent->offset))[1] =
			    (long)elffile->got;
		    symval = (Elf_Addr) (elffile->got + opdent->offset);
d646 4
a649 1
	    }
d652 5
a656 9
	case STB_GLOBAL:
	case STB_WEAK:		/* STB_WEAK seems like a hack to cover for
				 * some other problem */
	    symname = ElfGetString(elffile, syms[index].st_name);
	    symbol = LoaderHashFind(symname);
	    if (symbol == 0) {
		return 0;
	    }
	    symval = (Elf_Addr) symbol->address;
d658 3
d662 3
a664 3
	    symval = 0;
	    ErrorF("ElfGetSymbolValue(), unhandled symbol scope %x\n",
		   ELF_ST_BIND(syms[index].st_info));
a666 21
#ifdef ELFDEBUG
	ELFDEBUG("%p\t", (void *)symbol);
	ELFDEBUG("%lx\t", (unsigned long)symval);
	ELFDEBUG("%s\n", symname ? symname : "NULL");
#endif
	break;
    case STT_SECTION:
	symval = (Elf_Addr) elffile->saddr[syms[index].st_shndx];
#ifdef ELFDEBUG
	ELFDEBUG("ST_SECTION %lx\n", (unsigned long)symval);
#endif
	break;
    case STT_FILE:
    case STT_LOPROC:
    case STT_HIPROC:
    default:
	symval = 0;
	ErrorF("ElfGetSymbolValue(), unhandled symbol type %x\n",
	       ELF_ST_TYPE(syms[index].st_info));
	break;
    }
d679 3
a681 1
ElfGetPltAddr(ELFModulePtr elffile, int index)
d683 2
a684 2
    Elf_Sym *syms;
    Elf_Addr symval = 0;	/* value of the indicated symbol */
d688 1
a688 1
    syms = (Elf_Sym *) elffile->saddr[elffile->symndx];
d690 13
a702 10
    switch (ELF_ST_TYPE(syms[index].st_info)) {
    case STT_NOTYPE:
    case STT_OBJECT:
    case STT_FUNC:
	switch (ELF_ST_BIND(syms[index].st_info)) {
	case STB_GLOBAL:
	    symname = ElfGetString(elffile, syms[index].st_name);
	    symbol = LoaderHashFind(symname);
	    if (symbol == 0)
		return 0;
d718 25
a742 13
	    symbol->code.plt[0] = 0x3d80;	/* lis     r12 */
	    symbol->code.plt[1] =
		    (((Elf_Addr) symbol->address) & 0xffff0000) >> 16;
	    symbol->code.plt[2] = 0x618c;	/* ori     r12,r12 */
	    symbol->code.plt[3] = (((Elf_Addr) symbol->address) & 0xffff);
	    symbol->code.plt[4] = 0x7d89;	/* mtcr    r12 */
	    symbol->code.plt[5] = 0x03a6;
	    symbol->code.plt[6] = 0x4e80;	/* bctr */
	    symbol->code.plt[7] = 0x0420;
	    symbol->address = (char *)&symbol->code.plt[0];
	    symval = (Elf_Addr) symbol->address;
	    ppc_flush_icache(&symbol->code.plt[0]);
	    ppc_flush_icache(&symbol->code.plt[6]);
d744 4
d749 4
a752 3
	    symval = 0;
	    ErrorF("ElfGetPltAddr(), unhandled symbol scope %x\n",
		   ELF_ST_BIND(syms[index].st_info));
a754 17
# ifdef ELFDEBUG
	ELFDEBUG("ElfGetPlt: symbol=%lx\t", symbol);
	ELFDEBUG("newval=%lx\t", symval);
	ELFDEBUG("name=\"%s\"\n", symname ? symname : "NULL");
# endif
	break;
    case STT_SECTION:
    case STT_FILE:
    case STT_LOPROC:
    case STT_HIPROC:
    default:
	symval = 0;
	ErrorF("ElfGetPltAddr(), Unexpected symbol type %x",
	       ELF_ST_TYPE(syms[index].st_info));
	ErrorF("for a Plt request\n");
	break;
    }
d764 3
a766 1
ElfAddGOT(ELFModulePtr elffile, Elf_Rel_t *rel)
d772 1
a772 1
	Elf_Sym *sym;
d774 8
a781 9
	sym = (Elf_Sym *) & (elffile->symtab[ELF_R_SYM(rel->r_info)]);
	if (sym->st_name) {
	    ELFDEBUG("ElfAddGOT: Adding GOT entry for %s\n",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	} else
	    ELFDEBUG("ElfAddGOT: Adding GOT entry for %s\n",
		     ElfGetSectionName(elffile,
				       elffile->sections[sym->st_shndx].
				       sh_name));
d785 4
a788 4
    for (gotent = elffile->got_entries; gotent; gotent = gotent->next) {
	if (ELF_R_SYM(gotent->rel->r_info) == ELF_R_SYM(rel->r_info) &&
	    gotent->rel->r_addend == rel->r_addend)
	    break;
d791 1
a791 1
    if (gotent) {
d799 1
a799 1
	ErrorF("ElfAddGOT() Unable to allocate memory!!!!\n");
d802 1
d804 1
a804 1
    ELFDEBUG("Entry added with offset %x\n", elffile->gotsize);
d806 5
a810 5
    gotent->rel = rel;
    gotent->offset = elffile->gotsize;
    gotent->next = elffile->got_entries;
    elffile->got_entries = gotent;
    elffile->gotsize += 8;
d815 3
a817 1
ELFCreateGOT(ELFModulePtr elffile, int maxalign)
d828 1
a828 1
    ELFDEBUG("ELFCreateGOT: %x entries in the GOT\n", elffile->gotsize / 8);
d834 6
a839 7
    if (elffile->gotsize == 0)
	ELFDEBUG("Module %s doesn't have any GOT entries!\n",
		 _LoaderModuleToName(elffile->module));
# endif
    if (elffile->gotsize == 0)
	elffile->gotsize = 8;
    elffile->sections[elffile->gotndx].sh_size = elffile->gotsize;
d856 1
a856 2
	    if (elffile->base + elffile->basesize - gots->section >=
		GOTDistance)
d864 2
a865 2
	ELFDEBUG("ELFCreateGOT: GOT address %lx in shared GOT, nuses %d\n",
		 elffile->got, gots->nuses);
d871 1
a871 1
# endif	/*MergeSectionAlloc */
d874 1
a874 1
	ErrorF("ELFCreateGOT() Unable to allocate memory!!!!\n");
d877 1
d893 1
a893 1
	    ErrorF("ELFCreateGOT() Unable to reallocate memory!!!!\n");
d901 3
a903 5
	    round = (unsigned long)elffile->base & (page_size - 1);
	    mprotect(elffile->base - round,
		     (elffile->basesize + round + page_size -
		      1) & ~(page_size - 1),
		     PROT_READ | PROT_WRITE | PROT_EXEC);
a908 1

d911 2
a912 2
	    elffile->base = mremap(elffile->base, oldbasesize,
				   elffile->basesize, MREMAP_MAYMOVE);
d914 1
a914 1
		ErrorF("ELFCreateGOT() Unable to remap memory!!!!\n");
d920 2
a921 6
	elffile->baseptr =
		((long)elffile->base + (maxalign - 1)) & ~(maxalign - 1);
	elffile->got =
		(unsigned char
		 *)((long)(elffile->base + elffile->basesize -
			   elffile->gotsize) & ~7);
d923 1
a923 1
	gots = (ELFGotPtr) elffile->got;
d932 1
a932 2
	ELFDEBUG("ELFCreateGOT: Created a shareable GOT with size %d\n",
		 gots->size);
d935 1
a935 1
# endif	/*MergeSectionAlloc */
d938 1
a938 1
    ELFDEBUG("ELFCreateGOT: GOT address %lx\n", elffile->got);
d943 1
a943 1
#endif /* defined(__alpha__) || defined(__ia64__) */
d950 4
a953 1
ElfAddOPD(ELFModulePtr elffile, int index, LOOKUP *l)
d964 1
a964 1
	ErrorF("ElfAddOPD() Unable to allocate memory!!!!\n");
d967 1
d969 1
a969 1
    ELFDEBUG("OPD Entry %d added with offset %x\n", index, elffile->gotsize);
d971 7
a977 7
    opdent->l = l;
    opdent->index = index;
    opdent->offset = elffile->gotsize;
    opdent->next = elffile->opd_entries;
    elffile->opd_entries = opdent;
    elffile->gotsize += 16;
    return;
d981 2
a982 1
ELFCreateOPD(ELFModulePtr elffile)
d987 1
a987 1
	ErrorF("ELFCreateOPD() Unallocated GOT!!!!\n");
d992 3
a994 5
	((unsigned long *)(elffile->got + opdent->offset))[0] =
		(long)opdent->l->offset;
	((unsigned long *)(elffile->got + opdent->offset))[1] =
		(long)elffile->got;
	opdent->l->offset = (funcptr) (elffile->got + opdent->offset);
d1002 3
a1004 1
ElfAddPLT(ELFModulePtr elffile, Elf_Rel_t *rel)
d1010 1
a1010 1
	Elf_Sym *sym;
d1012 7
a1018 6
	sym = (Elf_Sym *) & (elffile->symtab[ELF_R_SYM(rel->r_info)]);
	if (sym->st_name) {
	    ELFDEBUG("ElfAddPLT: Adding PLT entry for %s\n",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	} else
	    ErrorF("ElfAddPLT: Add PLT entry for section??\n");
d1025 3
a1027 3
    for (pltent = elffile->plt_entries; pltent; pltent = pltent->next) {
	if (ELF_R_SYM(pltent->rel->r_info) == ELF_R_SYM(rel->r_info))
	    break;
d1030 1
a1030 1
    if (pltent) {
d1038 1
a1038 1
	ErrorF("ElfAddPLT() Unable to allocate memory!!!!\n");
d1041 1
d1043 1
a1043 1
    ELFDEBUG("Entry added with offset %x\n", elffile->pltsize);
d1045 8
a1052 8
    pltent->rel = rel;
    pltent->offset = elffile->pltsize;
    pltent->gotoffset = elffile->gotsize;
    pltent->next = elffile->plt_entries;
    elffile->plt_entries = pltent;
    elffile->pltsize += 32;
    elffile->gotsize += 16;
    return;
d1056 2
a1057 1
ELFCreatePLT(ELFModulePtr elffile)
d1060 1
a1060 1
    ELFDEBUG("ELFCreatePLT: %x entries in the PLT\n", elffile->pltsize / 8);
d1063 1
a1063 2
    if (elffile->pltsize == 0)
	return;
d1065 2
a1066 3
    if ((elffile->plt =
	 ELFLoaderSectCalloc(elffile, 32, elffile->pltsize)) == NULL) {
	ErrorF("ELFCreatePLT() Unable to allocate memory!!!!\n");
d1069 1
a1069 1
    elffile->sections[elffile->pltndx].sh_size = elffile->pltsize;
d1071 1
a1071 1
    ELFDEBUG("ELFCreatePLT: PLT address %lx\n", elffile->plt);
d1078 5
a1082 2
IA64InstallReloc(unsigned long *data128, int slot, enum ia64_operand opnd,
		 long value)
d1087 2
a1088 3
    ELFDEBUG("\nIA64InstallReloc %p %d %d %016lx\n", data128, slot, opnd,
	     value);
    ELFDEBUG("Before [%016lx%016lx]\n", data128[1], data128[0]);
d1091 4
a1094 11
    case 0:
	data = *data128;
	break;
    case 1:
	memcpy(&data, (char *)data128 + 5, 8);
	break;
    case 2:
	memcpy(&data, (char *)data128 + 10, 6);
	break;
    default:
	FatalError("Unexpected slot in IA64InstallReloc()\n");
d1099 1
a1099 1
	data |= (value & 0x7f) << (18 + slot);	/* [13:19] + 5 + slot */
a1112 19
#ifdef IA64_LDX_OPTIMIZATION
    case IA64_OPND_LDXMOV:
	/*
	 * Convert "ld8 t2=[t1]" to "mov t2=t1" which is really "add t2=0,t1"
	 * Mask all but the r3,r1,qp fields, 
	 * then OR in the ALU opcode = 8 into the opcode field [40:37]
	 * 
	 * Mask for the r3,r1,qp bit fields [26:20][12:6][5:0] = 0x7f01fff,
	 * This mask negated only within the 41 bit wide instruction and
	 * shifted left by 5 for the bundle template is 0x3FFF01FC0000
	 *
	 * opcode field [40:37] with a value of 8 is 0x10000000000
	 * shifted left by 5 for the bundle template is 0x200000000000
	 *
	 */
	data &= ~(0x3FFF01FC0000 << slot);
	data |= (0x200000000000 << slot);
	break;
#endif
d1117 4
a1120 11
    case 0:
	*data128 = data;
	break;
    case 1:
	memcpy((char *)data128 + 5, &data, 8);
	break;
    case 2:
	memcpy((char *)data128 + 10, &data, 6);
	break;
    default:
	FatalError("Unexpected slot in IA64InstallReloc()\n");
d1124 1
a1124 1
    ELFDEBUG("After  [%016lx%016lx]\n", data128[1], data128[0]);
d1138 5
a1142 2
Elf_RelocateEntry(ELFModulePtr elffile, Elf_Word secn, Elf_Rel_t *rel,
		  int force)
a1144 1

a1152 1
    unsigned long *dest64;
d1154 1
a1154 1
#if defined(__alpha__)
d1159 1
a1159 1
#if  defined(__AMD64__) || defined(__amd64__)
d1170 2
a1171 2
    ELFDEBUG("%lx %d %d\n", (unsigned long)rel->r_offset,
	     ELF_R_SYM(rel->r_info), ELF_R_TYPE(rel->r_info));
d1177 2
a1178 3
    defined(__AMD64__) || \
    defined(__amd64__)
    ELFDEBUG("%lx", rel->r_addend);
d1183 1
a1183 2
	    if (ELF_R_SYM(rel->r_info)
		&& ELF_R_TYPE(rel->r_info) != R_ALPHA_GPDISP)
d1185 1
a1185 1
	    if (ELF_R_SYM(rel->r_info))
d1191 1
a1191 1
		symval = (Elf_Addr) & LoaderDefaultFunc;
d1202 2
a1203 1
    switch (ELF_R_TYPE(rel->r_info)) {
d1205 2
a1206 2
    case R_386_32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
d1208 3
a1210 3
	ELFDEBUG("R_386_32\t");
	ELFDEBUG("dest32=%p\t", (void *)dest32);
	ELFDEBUG("*dest32=%8.8x\t", (unsigned int)*dest32);
d1212 1
a1212 1
	*dest32 = symval + (*dest32);	/* S + A */
d1214 1
a1214 1
	ELFDEBUG("*dest32=%8.8x\n", (unsigned int)*dest32);
d1216 3
a1218 3
	break;
    case R_386_PC32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
d1220 6
a1225 6
	ELFDEBUG("R_386_PC32 %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%p\t", secp);
	ELFDEBUG("symval=%lx\t", (unsigned long)symval);
	ELFDEBUG("dest32=%p\t", (void *)dest32);
	ELFDEBUG("*dest32=%8.8x\t", (unsigned int)*dest32);
d1228 1
a1228 1
	*dest32 = symval + (*dest32) - (Elf_Addr) dest32;	/* S + A - P */
d1231 1
a1231 1
	ELFDEBUG("*dest32=%8.8x\n", (unsigned int)*dest32);
d1234 1
a1234 1
	break;
d1236 8
a1243 8
#if defined(__AMD64__) || defined(__amd64__)
    case R_X86_64_32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
# ifdef ELFDEBUG
	ELFDEBUG("R_X86_32\t");
	ELFDEBUG("dest32=%x\t", dest32);
	ELFDEBUG("*dest32=%8.8lx\t", *dest32);
	ELFDEBUG("r_addend=%lx\t", rel->r_addend);
d1245 1
a1245 1
	*dest32 = symval + rel->r_addend + (*dest32);	/* S + A */
d1247 1
a1247 1
	ELFDEBUG("*dest32=%8.8lx\n", *dest32);
d1249 3
a1251 3
	break;
    case R_X86_64_32S:
	dest32s = (int *)(secp + rel->r_offset);
d1253 4
a1256 4
	ELFDEBUG("R_X86_64_32\t");
	ELFDEBUG("dest32s=%x\t", dest32s);
	ELFDEBUG("*dest32s=%8.8lx\t", *dest32s);
	ELFDEBUG("r_addend=%lx\t", rel->r_addend);
d1258 1
a1258 1
	*dest32s = symval + rel->r_addend + (*dest32s);	/* S + A */
d1260 1
a1260 1
	ELFDEBUG("*dest32s=%8.8lx\n", *dest32s);
d1262 3
a1264 3
	break;
    case R_X86_64_PC32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
d1266 7
a1272 7
	ELFDEBUG("R_X86_64_PC32 %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%lx\t", symval);
	ELFDEBUG("dest32=%x\t", dest32);
	ELFDEBUG("*dest32=%8.8lx\t", *dest32);
	ELFDEBUG("r_addend=%lx\t", rel->r_addend);
d1274 1
a1274 1
	*dest32 = symval + rel->r_addend + (*dest32) - (Elf_Addr) dest32;	/* S + A - P */
d1277 1
a1277 1
	ELFDEBUG("*dest32=%8.8lx\n", *dest32);
d1279 3
a1281 3
	break;
    case R_X86_64_64:
	dest64 = (unsigned long *)(secp + rel->r_offset);
d1283 4
a1286 4
	ELFDEBUG("R_AMD64_64\t");
	ELFDEBUG("dest64=%x\t", dest64);
	ELFDEBUG("*dest64=%8.8lx\t", *dest64);
	ELFDEBUG("r_addend=%lx\t", rel->r_addend);
d1288 1
a1288 1
	*dest64 = symval + rel->r_addend + (*dest64);	/* S + A */
d1290 1
a1290 1
	ELFDEBUG("*dest64=%8.8lx\n", *dest64);
d1292 2
a1293 2
	break;
#endif /* __AMD64__ */
d1295 31
a1325 30
    case R_ALPHA_NONE:
    case R_ALPHA_LITUSE:
	break;

    case R_ALPHA_REFQUAD:
	dest64 = (unsigned long *)(secp + rel->r_offset);
	symval = ElfGetSymbolValue(elffile, ELF_R_SYM(rel->r_info));
# ifdef ELFDEBUG
	ELFDEBUG("R_ALPHA_REFQUAD\t");
	ELFDEBUG("dest64=%lx\t", dest64);
	ELFDEBUG("*dest64=%8.8lx\t", *dest64);
# endif
	*dest64 = symval + rel->r_addend + (*dest64);	/* S + A + P */
# ifdef ELFDEBUG
	ELFDEBUG("*dest64=%8.8lx\n", *dest64);
# endif
	break;

    case R_ALPHA_GPREL32:
	{
	    dest64 = (unsigned long *)(secp + rel->r_offset);
	    dest32 = (unsigned int *)dest64;

# ifdef ELFDEBUG
	    ELFDEBUG("R_ALPHA_GPREL32 %s\t",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	    ELFDEBUG("secp=%lx\t", secp);
	    ELFDEBUG("symval=%lx\t", symval);
	    ELFDEBUG("dest32=%lx\t", dest32);
	    ELFDEBUG("*dest32=%8.8x\t", *dest32);
d1328 1
a1328 2
	    symval = ((unsigned char *)symval) -
		    ((unsigned char *)elffile->got);
d1330 1
a1330 1
	    ELFDEBUG("symval=%lx\t", symval);
d1332 2
a1333 2
	    if ((symval & 0xffffffff00000000) != 0x0000000000000000 &&
		(symval & 0xffffffff00000000) != 0xffffffff00000000) {
d1335 1
a1335 1
			   ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
d1338 1
a1338 1
	    *dest32 = symval;
d1340 1
a1340 1
	    ELFDEBUG("*dest32=%x\n", *dest32);
d1343 1
a1343 1
	}
d1345 4
a1348 4
    case R_ALPHA_GPRELLOW:
	{
	    dest64 = (unsigned long *)(secp + rel->r_offset);
	    dest16 = (unsigned short *)dest64;
d1351 1
a1351 2
	    symval = ((unsigned char *)symval) -
		    ((unsigned char *)elffile->got);
d1353 1
a1353 1
	    *dest16 = symval;
d1355 1
a1355 1
	}
d1357 4
a1360 4
    case R_ALPHA_GPRELHIGH:
	{
	    dest64 = (unsigned long *)(secp + rel->r_offset);
	    dest16 = (unsigned short *)dest64;
d1363 1
a1363 2
	    symval = ((unsigned char *)symval) -
		    ((unsigned char *)elffile->got);
d1365 3
a1367 5
	    if ((long)symval > 0x7fff || (long)symval < -(long)0x8000) {
		FatalError
			("R_ALPHA_GPRELHIGH symval-got is too large for %s:%lx\n",
			 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)),
			 symval);
d1370 1
a1370 1
	    *dest16 = symval;
d1372 1
a1372 1
	}
d1374 2
a1375 2
    case R_ALPHA_LITERAL:
	{
d1377 1
a1377 2

	    dest32 = (unsigned int *)(secp + rel->r_offset);
d1379 6
a1384 6
	    ELFDEBUG("R_ALPHA_LITERAL %s\t",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	    ELFDEBUG("secp=%lx\t", secp);
	    ELFDEBUG("symval=%lx\t", symval);
	    ELFDEBUG("dest32=%lx\t", dest32);
	    ELFDEBUG("*dest32=%8.8x\t", *dest32);
d1387 4
a1390 4
	    for (gotent = elffile->got_entries; gotent; gotent = gotent->next) {
		if (ELF_R_SYM(gotent->rel->r_info) == ELF_R_SYM(rel->r_info)
		    && gotent->rel->r_addend == rel->r_addend)
		    break;
d1394 3
a1396 3
	    if (gotent) {
		*(unsigned long *)(elffile->got + gotent->offset) =
			symval + rel->r_addend;
d1399 1
a1399 1
			 gotent->offset, symval + rel->r_addend);
d1404 3
a1406 2
		(*dest32) |= (gotent->offset);	/* The address part is always 0 */
	    } else {
d1408 1
a1408 1

d1410 1
a1410 1
		val = ((symval + (rel->r_addend) - (Elf_Addr) dest32));
d1412 1
a1412 1
		ELFDEBUG("S+A-P=%x\t", val);
d1414 2
a1415 2
		if ((val & 0xffff0000) != 0xffff0000 &&
		    (val & 0xffff0000) != 0x00000000) {
d1417 1
a1417 1
		    break;
d1420 1
a1420 1
		(*dest32) |= (val);	/* The address part is always 0 */
d1423 1
a1423 1
	    ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1427 4
a1430 4
	}

    case R_ALPHA_GPDISP:
	{
d1433 2
a1434 2
	    dest32h = (unsigned int *)(secp + rel->r_offset);
	    dest32 = (unsigned int *)((secp + rel->r_offset) + rel->r_addend);
d1437 8
a1444 8
	    ELFDEBUG("R_ALPHA_GPDISP %s\t",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	    ELFDEBUG("secp=%lx\t", secp);
	    ELFDEBUG("got=%lx\t", elffile->got);
	    ELFDEBUG("dest32=%lx\t", dest32);
	    ELFDEBUG("*dest32=%8.8x\t", *dest32);
	    ELFDEBUG("dest32h=%lx\t", dest32h);
	    ELFDEBUG("*dest32h=%8.8x\t", *dest32h);
d1447 2
a1448 2
		ErrorF("***Bad instructions in relocating %s\n",
		       ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
d1453 2
a1454 3

	    offset = ((unsigned char *)elffile->got -
		      (unsigned char *)dest32h);
d1456 2
a1457 2
	    ELFDEBUG("symval=%lx\t", symval);
	    ELFDEBUG("got-dest32=%lx\t", offset);
d1460 2
a1461 2
	    if ((offset >= 0x7fff8000L) || (offset < -0x80000000L)) {
		FatalError("Offset overflow for R_ALPHA_GPDISP\n");
d1466 1
a1466 1
	    ELFDEBUG("symval=%lx\t", symval);
d1468 3
a1470 3
	    *dest32 = (*dest32 & 0xffff0000) | (symval & 0xffff);
	    *dest32h = (*dest32h & 0xffff0000) |
		    (((symval >> 16) + ((symval >> 15) & 1)) & 0xffff);
d1472 2
a1473 2
	    ELFDEBUG("*dest32=%8.8x\t", *dest32);
	    ELFDEBUG("*dest32h=%8.8x\n", *dest32h);
d1475 5
a1479 5
	    break;
	}

    case R_ALPHA_HINT:
	dest32 = (unsigned int *)((secp + rel->r_offset) + rel->r_addend);
d1481 6
a1486 6
	ELFDEBUG("R_ALPHA_HINT %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%lx\t", secp);
	ELFDEBUG("symval=%lx\t", symval);
	ELFDEBUG("dest32=%lx\t", dest32);
	ELFDEBUG("*dest32=%8.8x\t", *dest32);
d1490 1
a1490 1
	ELFDEBUG("symval=%lx\t", symval);
d1492 5
a1496 5
	symval -= (Elf_Addr) (((unsigned char *)dest32) + 4);
	if (symval % 4) {
	    ErrorF("R_ALPHA_HINT bad alignment of offset\n");
	}
	symval = symval >> 2;
d1499 1
a1499 1
	ELFDEBUG("symval=%lx\t", symval);
d1502 1
a1502 1
	if (symval & 0xffff8000) {
d1504 1
a1504 1
	    ELFDEBUG("R_ALPHA_HINT symval too large\n");
d1506 1
a1506 1
	}
d1508 1
a1508 1
	*dest32 = (*dest32 & ~0x3fff) | (symval & 0x3fff);
d1511 1
a1511 1
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1513 1
a1513 20
	break;

    case R_ALPHA_GPREL16:
	{
	    dest64 = (unsigned long *)(secp + rel->r_offset);
	    dest16 = (unsigned short *)dest64;

	    symval += rel->r_addend;
	    symval = ((unsigned char *)symval) -
		    ((unsigned char *)elffile->got);
	    if ((long)symval > 0x7fff || (long)symval < -(long)0x8000) {
		FatalError
			("R_ALPHA_GPREL16 symval-got is too large for %s:%lx\n",
			 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)),
			 symval);
	    }

	    *dest16 = symval;
	    break;
	}
d1515 17
d1534 2
a1535 2
    case R_68K_32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
d1537 6
a1542 6
	ELFDEBUG("R_68K_32\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1544 4
a1547 5
	{
	    unsigned long val;

	    /* S + A */
	    val = symval + (rel->r_addend);
d1549 1
a1549 1
	    ELFDEBUG("S+A=%x\t", val);
d1551 2
a1552 2
	    *dest32 = val;	/* S + A */
	}
d1554 1
a1554 1
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1556 3
a1558 3
	break;
    case R_68K_PC32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
d1560 6
a1565 6
	ELFDEBUG("R_68K_PC32\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1567 5
a1571 6
	{
	    unsigned long val;

	    /* S + A - P */
	    val = symval + (rel->r_addend);
	    val -= *dest32;
d1573 2
a1574 2
	    ELFDEBUG("S+A=%x\t", val);
	    ELFDEBUG("S+A-P=%x\t", val + (*dest32) - (Elf_Addr) dest32);
d1576 2
a1577 2
	    *dest32 = val + (*dest32) - (Elf_Addr) dest32;	/* S + A - P */
	}
d1579 1
a1579 1
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1581 1
a1581 1
	break;
d1585 2
a1586 2
    case R_PPC_DISP24:		/* 11 */
	dest32 = (unsigned long *)(secp + rel->r_offset);
d1588 5
a1592 6
	ELFDEBUG("R_PPC_DISP24 %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("dest32=%x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\t", *dest32);
d1595 5
a1599 5
	{
	    unsigned long val;

	    /* S + A - P >> 2 */
	    val = ((symval + (rel->r_addend) - (Elf_Addr) dest32));
d1601 1
a1601 1
	    ELFDEBUG("S+A-P=%x\t", val);
d1603 3
a1605 3
	    val = val >> 2;
	    if ((val & 0x3f000000) != 0x3f000000 &&
		(val & 0x3f000000) != 0x00000000) {
d1607 1
a1607 1
		ELFDEBUG("R_PPC_DISP24 offset %x too large\n", val << 2);
d1609 2
a1610 2
		symval = ElfGetPltAddr(elffile, ELF_R_SYM(rel->r_info));
		val = ((symval + (rel->r_addend) - (Elf_Addr) dest32));
d1612 1
a1612 1
		ELFDEBUG("PLT offset is %x\n", val);
d1614 8
a1621 5
		val = val >> 2;
		if ((val & 0x3f000000) != 0x3f000000 &&
		    (val & 0x3f000000) != 0x00000000)
		    FatalError("R_PPC_DISP24 PLT offset %x too large\n",
			       val << 2);
a1622 4
	    val &= 0x00ffffff;
	    (*dest32) |= (val << 2);	/* The address part is always 0 */
	    ppc_flush_icache(dest32);
	}
d1624 1
a1624 1
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1626 3
a1628 3
	break;
    case R_PPC_16HU:		/* 31 */
	dest16 = (unsigned short *)(secp + rel->r_offset);
d1630 1
a1630 1
	dest32 = (unsigned long *)(dest16 - 1);
d1634 8
a1641 8
	ELFDEBUG("R_PPC_16HU\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest16=%x\t", dest16);
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1643 4
a1646 5
	{
	    unsigned short val;

	    /* S + A */
	    val = ((symval + (rel->r_addend)) & 0xffff0000) >> 16;
d1648 1
a1648 1
	    ELFDEBUG("uhi16(S+A)=%x\t", val);
d1650 3
a1652 3
	    *dest16 = val;	/* S + A */
	    ppc_flush_icache(dest16);
	}
d1654 2
a1655 2
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1657 3
a1659 3
	break;
    case R_PPC_32:		/* 32 */
	dest32 = (unsigned long *)(secp + rel->r_offset);
d1661 6
a1666 6
	ELFDEBUG("R_PPC_32\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1668 4
a1671 5
	{
	    unsigned long val;

	    /* S + A */
	    val = symval + (rel->r_addend);
d1673 1
a1673 1
	    ELFDEBUG("S+A=%x\t", val);
d1675 3
a1677 3
	    *dest32 = val;	/* S + A */
	    ppc_flush_icache(dest32);
	}
d1679 1
a1679 1
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1681 3
a1683 3
	break;
    case R_PPC_32UA:		/* 33 */
	dest32 = (unsigned long *)(secp + rel->r_offset);
d1685 6
a1690 30
	ELFDEBUG("R_PPC_32UA\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	{
	    unsigned long val;
	    unsigned char *dest8 = (unsigned char *)dest32;

	    /* S + A */
	    val = symval + (rel->r_addend);
#  ifdef ELFDEBUG
	    ELFDEBUG("S+A=%x\t", val);
#  endif
	    *dest8++ = (val & 0xff000000) >> 24;
	    *dest8++ = (val & 0x00ff0000) >> 16;
	    *dest8++ = (val & 0x0000ff00) >> 8;
	    *dest8++ = (val & 0x000000ff);
	    ppc_flush_icache(dest32);
	}
#  ifdef ELFDEBUG
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	break;
    case R_PPC_16H:		/* 34 */
	dest16 = (unsigned short *)(secp + rel->r_offset);
#  ifdef ELFDEBUG
	dest32 = (unsigned long *)(dest16 - 1);
d1692 49
d1742 1
a1742 10
	ELFDEBUG("R_PPC_16H\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symbol=%s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest16=%x\t", dest16);
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1744 2
a1745 15
	{
	    unsigned short val;
	    unsigned short loval;

	    /* S + A */
	    val = ((symval + (rel->r_addend)) & 0xffff0000) >> 16;
	    loval = (symval + (rel->r_addend)) & 0xffff;
	    if (loval & 0x8000) {
		/*
		 * This is hi16(), instead of uhi16(). Because of this,
		 * if the lo16() will produce a negative offset, then
		 * we have to increment this part of the address to get
		 * the correct final result.
		 */
		val++;
d1748 2
a1749 1
	    ELFDEBUG("hi16(S+A)=%x\t", val);
d1751 3
a1753 3
	    *dest16 = val;	/* S + A */
	    ppc_flush_icache(dest16);
	}
d1755 1
a1755 2
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
a1756 3
	break;
    case R_PPC_16L:		/* 35 */
	dest16 = (unsigned short *)(secp + rel->r_offset);
d1758 8
a1765 1
	dest32 = (unsigned long *)(dest16 - 1);
d1767 4
d1772 1
a1772 8
	ELFDEBUG("R_PPC_16L\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest16=%x\t", dest16);
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1774 3
a1776 5
	{
	    unsigned short val;

	    /* S + A */
	    val = (symval + (rel->r_addend)) & 0xffff;
d1778 2
a1779 1
	    ELFDEBUG("lo16(S+A)=%x\t", val);
d1781 13
a1793 6
	    *dest16 = val;	/* S + A */
	    ppc_flush_icache(dest16);
	}
#  ifdef ELFDEBUG
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1795 4
a1798 6
	break;
# else /* PowerMAX_OS */
	/* Linux PPC */
    case R_PPC_ADDR32:		/* 1 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
	symval = ElfGetSymbolValue(elffile, ELF_R_SYM(rel->r_info));
d1800 1
a1800 6
	ELFDEBUG("R_PPC_ADDR32\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1802 3
a1804 5
	{
	    unsigned long val;

	    /* S + A */
	    val = symval + (rel->r_addend);
d1806 1
a1806 1
	    ELFDEBUG("S+A=%x\t", val);
d1808 3
a1810 3
	    *dest32 = val;	/* S + A */
	    ppc_flush_icache(dest32);
	}
d1812 1
a1812 1
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
a1813 3
	break;
    case R_PPC_ADDR16_LO:	/* 4 */
	dest16 = (unsigned short *)(secp + rel->r_offset);
d1815 6
a1820 1
	dest32 = (unsigned long *)(dest16 - 1);
d1822 4
d1827 1
a1827 6
	ELFDEBUG("R_PPC_ADDR16_LO\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest16=%x\t", dest16);
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
d1829 3
a1831 5
	{
	    unsigned short val;

	    /* S + A */
	    val = (symval + (rel->r_addend)) & 0xffff;
d1833 2
a1834 1
	    ELFDEBUG("lo16(S+A)=%x\t", val);
d1836 3
a1838 3
	    *dest16 = val;	/* S + A */
	    ppc_flush_icache(dest16);
	}
d1840 1
a1840 2
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
a1841 3
	break;
    case R_PPC_ADDR16_HA:	/* 6 */
	dest16 = (unsigned short *)(secp + rel->r_offset);
d1843 6
a1848 1
	dest32 = (unsigned long *)(dest16 - 1);
d1850 15
d1866 1
a1866 6
	ELFDEBUG("R_PPC_ADDR16_HA\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest16=%x\t", dest16);
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
d1868 2
a1869 15
	{
	    unsigned short val;
	    unsigned short loval;

	    /* S + A */
	    val = ((symval + (rel->r_addend)) & 0xffff0000) >> 16;
	    loval = (symval + (rel->r_addend)) & 0xffff;
	    if (loval & 0x8000) {
		/*
		 * This is hi16(), instead of uhi16(). Because of this,
		 * if the lo16() will produce a negative offset, then
		 * we have to increment this part of the address to get
		 * the correct final result.
		 */
		val++;
d1872 2
a1873 1
	    ELFDEBUG("hi16(S+A)=%x\t", val);
d1875 3
a1877 10
	    *dest16 = val;	/* S + A */
	    ppc_flush_icache(dest16);
	}
#  ifdef ELFDEBUG
	ELFDEBUG("*dest16=%8.8x\t", *dest16);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
#  endif
	break;
    case R_PPC_REL24:		/* 10 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
d1879 5
a1883 6
	ELFDEBUG("R_PPC_REL24 %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("dest32=%x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\t", *dest32);
d1886 5
a1890 5
	{
	    unsigned long val;

	    /* S + A - P >> 2 */
	    val = ((symval + (rel->r_addend) - (Elf_Addr) dest32));
d1892 1
a1892 1
	    ELFDEBUG("S+A-P=%x\t", val);
d1894 3
a1896 3
	    val = val >> 2;
	    if ((val & 0x3f000000) != 0x3f000000 &&
		(val & 0x3f000000) != 0x00000000) {
d1898 1
a1898 1
		ELFDEBUG("R_PPC_REL24 offset %x too large\n", val << 2);
d1900 2
a1901 2
		symval = ElfGetPltAddr(elffile, ELF_R_SYM(rel->r_info));
		val = ((symval + (rel->r_addend) - (Elf_Addr) dest32));
d1903 1
a1903 1
		ELFDEBUG("PLT offset is %x\n", val);
d1905 8
a1912 5
		val = val >> 2;
		if ((val & 0x3f000000) != 0x3f000000 &&
		    (val & 0x3f000000) != 0x00000000)
		    FatalError("R_PPC_REL24 PLT offset %x too large\n",
			       val << 2);
a1913 4
	    val &= 0x00ffffff;
	    (*dest32) |= (val << 2);	/* The address part is always 0 */
	    ppc_flush_icache(dest32);
	}
d1915 1
a1915 1
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1917 3
a1919 3
	break;
    case R_PPC_REL32:		/* 26 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
d1921 6
a1926 6
	ELFDEBUG("R_PPC_REL32\t");
	ELFDEBUG("secp=%x\t", secp);
	ELFDEBUG("symval=%x\t", symval);
	ELFDEBUG("r_addend=%x\t", rel->r_addend);
	ELFDEBUG("dest32=%8.8x\t", dest32);
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1928 5
a1932 6
	{
	    unsigned long val;

	    /* S + A - P */
	    val = symval + (rel->r_addend);
	    val -= *dest32;
d1934 2
a1935 2
	    ELFDEBUG("S+A=%x\t", val);
	    ELFDEBUG("S+A-P=%x\t", val + (*dest32) - (Elf_Addr) dest32);
d1937 3
a1939 3
	    *dest32 = val + (*dest32) - (Elf_Addr) dest32;	/* S + A - P */
	    ppc_flush_icache(dest32);
	}
d1941 1
a1941 1
	ELFDEBUG("*dest32=%8.8x\n", *dest32);
d1943 2
a1944 2
	break;
# endif	/* PowerMAX_OS */
d1947 2
a1948 2
    case R_SPARC_NONE:		/*  0 */
	break;
d1950 5
a1954 5
    case R_SPARC_8:		/*  1 */
	dest8 = (unsigned char *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest8 = symval;
	break;
d1956 5
a1960 5
    case R_SPARC_16:		/*  2 */
	dest16 = (unsigned short *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest16 = symval;
	break;
d1962 10
a1971 9
    case R_SPARC_32:		/*  3 */
    case R_SPARC_UA32:		/* 23 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
	symval += rel->r_addend;
	((unsigned char *)dest32)[0] = (unsigned char)(symval >> 24);
	((unsigned char *)dest32)[1] = (unsigned char)(symval >> 16);
	((unsigned char *)dest32)[2] = (unsigned char)(symval >> 8);
	((unsigned char *)dest32)[3] = (unsigned char)(symval);
	break;
d1973 5
a1977 6
    case R_SPARC_GLOB_DAT:	/* 20 */
    case R_SPARC_64:		/* 32 */
	dest64 = (unsigned long *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest64 = symval;
	break;
d1979 5
a1983 5
    case R_SPARC_DISP8:	/*  4 */
	dest8 = (unsigned char *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest8 = (symval - (Elf_Addr) dest8);
	break;
d1985 5
a1989 5
    case R_SPARC_DISP16:	/*  5 */
	dest16 = (unsigned short *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest16 = (symval - (Elf_Addr) dest16);
	break;
d1991 6
a1996 5
    case R_SPARC_DISP32:	/*  6 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest32 = (symval - (Elf_Addr) dest32);
	break;
d1998 5
a2002 6
    case R_SPARC_WDISP30:	/*  7 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest32 = ((*dest32 & 0xc0000000) |
		   (((symval - (Elf_Addr) dest32) >> 2) & 0x3fffffff));
	break;
d2004 5
a2008 5
    case R_SPARC_HI22:		/*  9 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest32 = (*dest32 & 0xffc00000) | (symval >> 10);
	break;
d2010 8
a2017 5
    case R_SPARC_LO10:		/* 12 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
	symval += rel->r_addend;
	*dest32 = (*dest32 & ~0x3ff) | (symval & 0x3ff);
	break;
d2019 20
a2038 8
    case R_SPARC_COPY:		/* 19 */
	/* Fix your code...  I'd rather dish out an error here
	 * so people will not link together PIC and non-PIC
	 * code into a final driver object file.
	 */
	ErrorF("Elf_RelocateEntry():"
	       "  Copy relocs not supported on Sparc.\n");
	break;
d2040 4
a2043 27
    case R_SPARC_JMP_SLOT:	/* 21 */
	dest32 = (unsigned int *)(secp + rel->r_offset);
	/* Before we change it the PLT entry looks like:
	 *
	 * pltent:      sethi   %hi(rela_plt_offset), %g1
	 *              b,a     PLT0
	 *              nop
	 *
	 * We change it into:
	 *
	 * pltent:      sethi   %hi(rela_plt_offset), %g1
	 *              sethi   %hi(symval), %g1
	 *              jmp     %g1 + %lo(symval), %g0
	 */
	symval += rel->r_addend;
	dest32[2] = 0x81c06000 | (symval & 0x3ff);
	__asm __volatile("flush %0 + 0x8"::"r"(dest32));

	dest32[1] = 0x03000000 | (symval >> 10);
	__asm __volatile("flush %0 + 0x4"::"r"(dest32));

	break;

    case R_SPARC_RELATIVE:	/* 22 */
	dest64 = (unsigned long *)(secp + rel->r_offset);
	*dest64 = (unsigned long)secp + rel->r_addend;
	break;
d2046 2
a2047 2
    case R_IA64_NONE:
	break;
d2049 10
a2058 13
    case R_IA64_LTOFF_FPTR22:
	if (rel->r_addend)
	    FatalError("\nAddend for R_IA64_LTOFF_FPTR22 not supported\n");
# ifdef ELFDEBUG
	ELFDEBUG("opd=%016lx.%016lx\n",
		 ((long *)symval)[0], ((long *)symval)[1]);
# endif
	/* FALLTHROUGH */
    case R_IA64_LTOFF22:
#ifndef IA64_LDX_OPTIMIZATION
    case R_IA64_LTOFF22X:	/* If not implementing LDXMOV optimization treat LTOFF22X as LTOFF22 */
#endif
	{
d2060 1
a2060 2

	    dest128 = (unsigned long *)(secp + (rel->r_offset & ~3));
d2062 8
a2069 8
	    ELFDEBUG("%s %s\t", ELF_R_TYPE(rel->r_info) == R_IA64_LTOFF22 ?
		     "R_IA64_LTOFF22" : "R_IA64_LTOFF_FPTR22",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	    ELFDEBUG("secp=%lx\t", secp);
	    ELFDEBUG("symval=%lx\t", symval);
	    ELFDEBUG("dest128=%lx\t", dest128);
	    ELFDEBUG("slot=%d\n", rel->r_offset & 3);
	    ELFDEBUG("*dest128=[%016lx%016lx]\n", dest128[1], dest128[0]);
d2072 4
a2075 4
	    for (gotent = elffile->got_entries; gotent; gotent = gotent->next) {
		if (ELF_R_SYM(gotent->rel->r_info) == ELF_R_SYM(rel->r_info)
		    && gotent->rel->r_addend == rel->r_addend)
		    break;
d2079 3
a2081 3
	    if (gotent) {
		*(unsigned long *)(elffile->got + gotent->offset) =
			symval + rel->r_addend;
d2084 1
a2084 1
			 gotent->offset, symval + rel->r_addend);
d2089 3
a2091 3
		IA64InstallReloc(dest128, rel->r_offset & 3, IA64_OPND_IMM22,
				 gotent->offset);
	    } else
d2093 2
a2094 2
	}
	break;
d2096 2
a2097 2
    case R_IA64_PCREL21B:
	{
d2099 1
a2099 2

	    dest128 = (unsigned long *)(secp + (rel->r_offset & ~3));
d2101 8
a2108 9
	    ELFDEBUG("R_IA64_PCREL21B %s\t",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	    ELFDEBUG("secp=%lx\t", secp);
	    ELFDEBUG("symval=%lx\t", symval);
	    ELFDEBUG("opd=%lx.%lx\t", ((long *)symval)[0],
		     ((long *)symval)[1]);
	    ELFDEBUG("dest128=%lx\t", dest128);
	    ELFDEBUG("slot=%d\n", rel->r_offset & 3);
	    ELFDEBUG("*dest128=[%016lx%016lx]\n", dest128[1], dest128[0]);
d2113 1
a2113 2
		&& (((unsigned long)dest128 - ((unsigned long *)symval)[0]) +
		    0x2000000 < 0x4000000)) {
d2116 1
a2116 2
				 ((unsigned long *)symval)[0] -
				 (unsigned long)dest128);
d2119 4
a2122 4
	    for (pltent = elffile->plt_entries; pltent; pltent = pltent->next) {
		if (ELF_R_SYM(pltent->rel->r_info) == ELF_R_SYM(rel->r_info)
		    && pltent->rel->r_addend == rel->r_addend)
		    break;
d2129 2
a2130 4
		unsigned long *p =
			(unsigned long *)(elffile->plt + pltent->offset);
		unsigned long r =
			(unsigned long)symval - (unsigned long)elffile->got;
d2133 5
a2137 5
		    /* Too far from gp to use the official function descriptor,
		     * so we have to make a local one.
		     */
		    r = pltent->gotoffset;
		    memcpy(elffile->got + r, (char *)symval, 16);
d2150 2
a2151 20
	}
	break;

    case R_IA64_FPTR64LSB:
	dest64 = (unsigned long *)(secp + rel->r_offset);
# ifdef ELFDEBUG
	ELFDEBUG("R_IA64_FPTR64LSB %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%lx\t", secp);
	ELFDEBUG("symval=%lx\t", symval);
	ELFDEBUG("dest64=%lx\t", dest64);
	ELFDEBUG("opd=%016lx.%016lx\n", ((long *)symval)[0],
		 ((long *)symval)[1]);
# endif

	if (rel->r_addend)
	    FatalError("\nAddend not supported for R_IA64_FPTR64LSB\n");
	*dest64 = symval;
	ia64_flush_cache(dest64);
	break;
d2153 2
a2154 2
    case R_IA64_DIR64LSB:
	dest64 = (unsigned long *)(secp + rel->r_offset);
d2156 6
a2161 5
	ELFDEBUG("R_IA64_DIR64LSB %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%lx\t", secp);
	ELFDEBUG("symval=%lx\t", symval);
	ELFDEBUG("dest64=%lx\n", dest64);
a2162 3
	*dest64 = symval + rel->r_addend;
	ia64_flush_cache(dest64);
	break;
d2164 5
a2168 11
    case R_IA64_PCREL64LSB:
	dest64 = (unsigned long *)(secp + rel->r_offset);
#ifdef ELFDEBUG
	ELFDEBUG("R_IA64_PCREL64LSB %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%lx\t", secp);
	ELFDEBUG("symval=%lx\t", symval);
	ELFDEBUG("dest64=%lx\n", dest64);
#endif
	*dest64 = symval + rel->r_addend - (unsigned long)dest64;
	break;
d2170 2
a2171 2
    case R_IA64_GPREL22:
	dest128 = (unsigned long *)(secp + (rel->r_offset & ~3));
d2173 5
a2177 7
	ELFDEBUG("R_IA64_GPREL22 %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	ELFDEBUG("secp=%lx\t", secp);
	ELFDEBUG("symval=%lx\t", symval);
	ELFDEBUG("dest128=%lx\t", dest128);
	ELFDEBUG("slot=%d\n", rel->r_offset & 3);
	ELFDEBUG("*dest128=[%016lx%016lx]\n", dest128[1], dest128[0]);
d2179 3
a2181 3
	IA64InstallReloc(dest128, rel->r_offset & 3, IA64_OPND_IMM22,
			 symval + rel->r_addend - (long)elffile->got);
	break;
d2183 22
a2204 15
#ifdef IA64_LDX_OPTIMIZATION
    case R_IA64_LTOFF22X:
	{
	    ELFGotEntryPtr gotent;
	    long gp_offset = symval + rel->r_addend - (long)elffile->got;

	    dest128 = (unsigned long *)(secp + (rel->r_offset & ~3));

# ifdef ELFDEBUG
	    ELFDEBUG("R_IA64_LTOFF22X %s\t",
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
	    ELFDEBUG("secp=%lx\t", secp);
	    ELFDEBUG("symval=%lx\t", symval);
	    ELFDEBUG("dest128=%lx\t", dest128);
	    ELFDEBUG("slot=%d\n", rel->r_offset & 3);
a2205 38

	    if (gp_offset << 42 >> 42 != gp_offset) {
		/* Offset is too large for LTOFF22X, 
		 * fallback to using GOT lookup, e.g. LTOFF22. 
		 * Note: LDXMOV will fail the same test and will be ignored. */

# ifdef ELFDEBUG
		ELFDEBUG("gp_offset=%ld too large, using GOT instead (LTOFF22)\n", gp_offset);
# endif

		for (gotent = elffile->got_entries; gotent;
		     gotent = gotent->next) {
		    if (ELF_R_SYM(gotent->rel->r_info) ==
			ELF_R_SYM(rel->r_info)
			&& gotent->rel->r_addend == rel->r_addend)
			break;
		}

		/* Set the address in the GOT */
		if (gotent) {
		    *(unsigned long *)(elffile->got + gotent->offset) =
			    symval + rel->r_addend;
# ifdef ELFDEBUG
		    ELFDEBUG("Setting gotent[%x]=%lx\n", gotent->offset,
			     symval + rel->r_addend);
# endif
		    if ((gotent->offset & 0xffe00000) != 0)
			FatalError("\nR_IA64_LTOFF22 offset %x too large\n",
				   gotent->offset);
		} else {
		    FatalError("\nCould not find GOT entry\n");
		}
		gp_offset = gotent->offset;	/* Use GOT lookup */
	    } else {
# ifdef ELFDEBUG
		ELFDEBUG("using gp_offset=%ld (LTOFF22X)", gp_offset);
# endif
	    }
d2207 2
a2208 39
			     gp_offset);
	}
	break;
#endif

    case R_IA64_LDXMOV:
# ifdef ELFDEBUG
	ELFDEBUG("R_IA64_LDXMOV %s\t",
		 ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
# endif

#ifdef IA64_LDX_OPTIMIZATION
	{
	    long gp_offset = symval + rel->r_addend - (long)elffile->got;

	    dest128 = (unsigned long *)(secp + (rel->r_offset & ~3));

	    if (gp_offset << 42 >> 42 != gp_offset) {
		/* Offset is too large for LTOFF22X, ignore this relocation */
# ifdef ELFDEBUG
		ELFDEBUG("offset = %ld too large, ignoring\n", gp_offset);
# endif
	    } else {

# ifdef ELFDEBUG
		ELFDEBUG("secp=%lx\t", secp);
		ELFDEBUG("symval=%lx\t", symval);
		ELFDEBUG("dest128=%lx\t", dest128);
		ELFDEBUG("slot=%d\n", rel->r_offset & 3);
		ELFDEBUG("offset=%ld\n", gp_offset);
		ELFDEBUG("*dest128=[%016lx%016lx]\n", dest128[1], dest128[0]);
# endif

		IA64InstallReloc(dest128, rel->r_offset & 3, IA64_OPND_LDXMOV,
				 0);
	    }
	}
#endif
	break;
d2213 2
a2214 2
    case R_ARM_ABS32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
d2216 3
a2218 3
	ELFDEBUG("R_ARM_ABS32\t");
	ELFDEBUG("dest32=%x\t", dest32);
	ELFDEBUG("*dest32=%8.8lx\t", *dest32);
d2220 1
a2220 1
	*dest32 = symval + (*dest32);	/* S + A */
d2222 1
a2222 1
	ELFDEBUG("*dest32=%8.8lx\n", *dest32);
d2224 1
a2224 1
	break;
d2226 2
a2227 2
    case R_ARM_REL32:
	dest32 = (unsigned int *)(secp + rel->r_offset);
d2229 1
a2229 1
	{
d2231 2
a2232 4

	    ELFDEBUG("R_ARM_REL32 %s\t",
		     namestr =
		     ElfGetSymbolName(elffile, ELF_R_SYM(rel->r_info)));
d2234 5
a2238 5
	    ELFDEBUG("secp=%x\t", secp);
	    ELFDEBUG("symval=%lx\t", symval);
	    ELFDEBUG("dest32=%x\t", dest32);
	    ELFDEBUG("*dest32=%8.8lx\t", *dest32);
	}
d2241 1
a2241 1
	*dest32 = symval + (*dest32) - (Elf_Addr) dest32;	/* S + A - P */
d2244 1
a2244 1
	ELFDEBUG("*dest32=%8.8lx\n", *dest32);
d2247 1
a2247 1
	break;
d2249 2
a2250 2
    case R_ARM_PC24:
	{
d2252 1
a2252 2

	    dest32 = (unsigned int *)(secp + rel->r_offset);
d2254 3
a2256 3
	    val = symval - (unsigned long)dest32 + val;
	    val >>= 2;
	    *dest32 = (*dest32 & 0xff000000) | (val & 0x00ffffff);
d2260 2
a2261 2
	}
	break;
d2265 5
a2269 5
    default:
	ErrorF("Elf_RelocateEntry() Unsupported relocation type %d\n",
	       (int)ELF_R_TYPE(rel->r_info));
	break;
    }
d2275 2
a2276 2
    ELFModulePtr elffile;
    int index;			/* The section to use as relocation data */
d2278 4
a2281 3
    int i, numrel;
    Elf_Shdr *sect = &(elffile->sections[index]);
    Elf_Rel_t *rel = (Elf_Rel_t *) elffile->saddr[index];
d2285 3
a2287 1
    numrel = sect->sh_size / sect->sh_entsize;
d2289 1
a2289 1
    for (i = 0; i < numrel; i++) {
d2291 3
a2293 3
	if (ELF_R_TYPE(rel[i].r_info) == R_ALPHA_LITERAL) {
	    ElfAddGOT(elffile, &rel[i]);
	}
a2296 1
	    || ELF_R_TYPE(rel[i].r_info) == R_IA64_LTOFF22X
d2298 1
a2298 1
	    ElfAddGOT(elffile, &rel[i]);
d2301 1
a2301 1
	    ElfAddPLT(elffile, &rel[i]);
d2305 1
a2305 4
	    Elf_Sym *syms = (Elf_Sym *) elffile->saddr[elffile->symndx];

	    if (ELF_ST_BIND(syms[ELF_R_SYM(rel[i].r_info)].st_info) ==
		STB_LOCAL) {
d2325 8
a2332 6
ELF_GetSymbols(ELFModulePtr elffile, unsigned short **psecttable)
{
    Elf_Sym *syms;
    Elf_Shdr *sect;
    int i, l, numsyms;
    LOOKUP *lookup, *p;
d2336 3
a2338 3
    syms = elffile->symtab;
    sect = &(elffile->sections[elffile->symndx]);
    numsyms = sect->sh_size / sect->sh_entsize;
d2340 1
a2340 1
    if ((lookup = xf86loadermalloc((numsyms + 1) * sizeof(LOOKUP))) == NULL)
d2343 1
a2343 2
    if ((secttable =
	 xf86loadercalloc(sizeof(unsigned short), (numsyms + 1))) == NULL) {
d2349 2
a2350 1
    for (i = 0, l = 0; i < numsyms; i++) {
d2352 4
a2355 5
	ELFDEBUG("value=%lx\tsize=%lx\tBIND=%x\tTYPE=%x\tndx=%x\t%s\n",
		 (unsigned long)syms[i].st_value,
		 (unsigned long)syms[i].st_size,
		 ELF_ST_BIND(syms[i].st_info), ELF_ST_TYPE(syms[i].st_info),
		 syms[i].st_shndx, ElfGetString(elffile, syms[i].st_name));
d2358 3
a2360 3
	if (ELF_ST_BIND(syms[i].st_info) == STB_LOCAL)
	    /* Don't add static symbols to the symbol table */
	    continue;
d2362 12
a2373 10
	switch (ELF_ST_TYPE(syms[i].st_info)) {
	case STT_OBJECT:
	case STT_FUNC:
	case STT_SECTION:
	case STT_NOTYPE:
	    switch (syms[i].st_shndx) {
	    case SHN_ABS:
		ErrorF("ELF_GetSymbols() Don't know how to handle SHN_ABS\n");
		break;
	    case SHN_COMMON:
d2375 2
a2376 2
		ELFDEBUG("Adding COMMON space for %s\n",
			 ElfGetString(elffile, syms[i].st_name));
d2378 20
a2397 21
		if (!LoaderHashFind(ElfGetString(elffile, syms[i].st_name))) {
		    tmp = ElfAddCOMMON(&(syms[i]));
		    if (tmp) {
			tmp->next = listCOMMON;
			listCOMMON = tmp;
		    }
		}
		break;
	    case SHN_UNDEF:
		/*
		 * UNDEF will get resolved later, so the value
		 * doesn't really matter here.
		 */
		/* since we don't know the value don't advertise the symbol */
		break;
	    default:
		lookup[l].symName =
			xf86loaderstrdup(ElfGetString
					 (elffile, syms[i].st_name));
		lookup[l].offset = (funcptr) syms[i].st_value;
		secttable[l] = syms[i].st_shndx;
d2399 2
a2400 3
		ELFDEBUG("Adding symbol %lx(%d) %s\n",
			 (unsigned long)lookup[l].offset, secttable[l],
			 lookup[l].symName);
d2403 12
a2414 12
		if (ELF_ST_TYPE(syms[i].st_info) == STT_FUNC) {
		    ElfAddOPD(elffile, -1, &lookup[l]);
		}
#endif
		l++;
		break;
	    }
	    break;
	case STT_FILE:
	case STT_LOPROC:
	case STT_HIPROC:
	    /* Skip this type */
d2416 3
a2418 3
	    ELFDEBUG("Skipping TYPE %d %s\n",
		     ELF_ST_TYPE(syms[i].st_info),
		     ElfGetString(elffile, syms[i].st_name));
d2420 6
a2425 5
	    break;
	default:
	    ErrorF("ELF_GetSymbols(): Unepected symbol type %d\n",
		   ELF_ST_TYPE(syms[i].st_info));
	    break;
a2426 1
    }
d2428 1
a2428 1
    lookup[l].symName = NULL;	/* Terminate the list */
d2439 2
a2440 4
		) {
	    memmove(&(lookup[i]), &(lookup[i + 1]), (l - i) * sizeof(LOOKUP));
	    memmove(&(secttable[i]), &(secttable[i + 1]),
		    (l-- - i) * sizeof(unsigned short));
d2469 5
a2473 2
ELFCollectSections(ELFModulePtr elffile, int pass, int *totalsize,
		   int *maxalign)
d2475 1
a2475 1
    int i;
a2476 1

d2481 1
a2481 1
    for (i = 1; i < elffile->numsh; i++) {
d2486 1
a2486 1
	if (!strcmp(name, ".got")	/*Isn't there a more generic way to do this? */
d2488 1
a2488 1
	    || !strcmp(name, ".plt") || !strcmp(name, ".IA_64.unwind_info")
d2490 1
a2490 2
		)
	    continue;
d2494 1
a2494 1
	    if (!strcmp(name, ".shstrtab"))	/* already loaded */
d2496 1
a2496 1
	    if (!strcmp(name, ".stabstr"))	/* ignore debug info */
d2499 1
a2499 2
	    if (pass)
		continue;
d2505 3
a2507 4
	    if (pass)
		continue;
	    if (!(SecFlags(SecInfo(i)) & SHF_ALLOC))
		continue;
d2510 1
a2510 1
		continue;
d2512 3
a2514 3
	    flags = LOADED_SECTION;
	    flags |= RELOC_SECTION;
	    break;
d2518 1
a2518 1
	    if (!(elffile->sections[i].sh_flags & SHF_ALLOC))
d2525 1
a2525 1
		ELFDEBUG("ELF: Not loading %s\n", name);
d2529 1
a2529 1

d2531 1
a2531 1
					      (j + 1) * sizeof(LoadSection));
d2533 4
a2536 4
	    if (flags & LOADED_SECTION) {
		elffile->lsection[j].saddr	/* sect. contains data */
			= ELFLoaderSectToMem(elffile, SecAlign(i),
					     SecOffset(i), SecSize(i), name);
d2538 5
a2542 5
		if (SecSize(i))
		    elffile->lsection[j].saddr
			    = ELFLoaderSectCalloc(elffile, SecAlign(i),
						  SecSize(i));
		else
d2547 2
a2548 2
		    (Elf_Sym *) _LoaderFileToMem(elffile->fd, SecOffset(i),
						 SecSize(i), name);
d2550 1
a2550 1
	elffile->saddr[i] = elffile->lsection[j].saddr;
d2552 4
a2555 4
	ELFDEBUG("%s starts at %p size: %lx\n",
		 name, elffile->saddr[i], (unsigned long)SecSize(i));
#endif
	elffile->lsection[j].name = name;
d2557 2
a2558 2
	elffile->lsection[j].size = SecSize(i);
	elffile->lsection[j].flags = flags;
d2562 2
a2563 2
	    mprotect(elffile->lsection[j].saddr, SecSize(i),
		     PROT_READ | PROT_WRITE | PROT_EXEC);
d2567 1
a2567 1
	    elffile->symtab = (Elf_Sym *) elffile->saddr[i];
d2586 4
a2589 1
ELFLoadModule(loaderPtr modrec, int elffd, LOOKUP **ppLookup)
d2592 3
a2594 3
    Elf_Ehdr *header;
    ELFRelocPtr elf_reloc, tail;
    void *v;
d2596 1
a2596 1
    int totalsize, maxalign, i;
d2598 2
a2599 2
    LOOKUP *pLookup;

d2607 1
a2607 1
	ErrorF("Unable to allocate ELFModuleRec\n");
d2611 4
a2614 4
    elffile->handle = modrec->handle;
    elffile->module = modrec->module;
    elffile->fd = elffd;
    v = elffile->funcs = modrec->funcs;
d2619 3
a2621 4
    elffile->header =
	    (Elf_Ehdr *) _LoaderFileToMem(elffd, 0, sizeof(Elf_Ehdr),
					  "header");
    header = (Elf_Ehdr *) elffile->header;
d2626 5
a2630 5
    elffile->numsh = header->e_shnum;
    elffile->secsize = (header->e_shentsize * header->e_shnum);
    elffile->sections =
	    (Elf_Shdr *) _LoaderFileToMem(elffd, header->e_shoff,
					  elffile->secsize, "sections");
d2636 1
a2636 1
    elffile->gotndx = header->e_shnum;
d2639 1
a2639 1
    elffile->pltndx = header->e_shnum;
d2642 5
a2646 7
    elffile->numsh = header->e_shnum;
    elffile->secsize = (header->e_shentsize * header->e_shnum);
    elffile->sections =
	    xf86loaderrealloc(elffile->sections, elffile->secsize);
#endif /*defined(__alpha__) || defined(__ia64__) */
    elffile->saddr =
	    xf86loadercalloc(elffile->numsh, sizeof(unsigned char *));
d2653 5
a2657 6
    elffile->sections[elffile->gotndx].sh_name =
	    SecSize(header->e_shstrndx) + 1;
    elffile->sections[elffile->gotndx].sh_type = SHT_PROGBITS;
    elffile->sections[elffile->gotndx].sh_flags = SHF_WRITE | SHF_ALLOC;
    elffile->sections[elffile->gotndx].sh_size = 0;
    elffile->sections[elffile->gotndx].sh_addralign = 8;
d2659 1
a2659 1
    SecSize(header->e_shstrndx) += 8;
d2666 5
a2670 6
    elffile->sections[elffile->pltndx].sh_name =
	    SecSize(header->e_shstrndx) + 1;
    elffile->sections[elffile->pltndx].sh_type = SHT_PROGBITS;
    elffile->sections[elffile->pltndx].sh_flags = SHF_EXECINSTR | SHF_ALLOC;
    elffile->sections[elffile->pltndx].sh_size = 0;
    elffile->sections[elffile->pltndx].sh_addralign = 32;
d2672 1
a2672 1
    SecSize(header->e_shstrndx) += 32;
d2680 2
a2681 2
	    _LoaderFileToMem(elffd, SecOffset(header->e_shstrndx),
			     SecSize(header->e_shstrndx), ".shstrtab");
d2687 2
a2688 2
    strcpy((char *)(elffile->shstraddr +
		    elffile->sections[elffile->gotndx].sh_name), ".got");
d2694 2
a2695 2
    strcpy((char *)(elffile->shstraddr +
		    elffile->sections[elffile->pltndx].sh_name), ".plt");
d2704 1
a2704 1
    if (elffile->straddr == NULL || elffile->strsize == 0) {
d2709 1
a2709 1
	return (void *)-1L;
d2727 1
a2727 1
	elf_reloc = ELFCollectRelocations(elffile, elffile->lsection[i].ndx);
d2729 2
a2730 1
	    for (tail = elf_reloc; tail->next; tail = tail->next) ;
d2750 1
a2750 1

d2754 1
a2754 1
	ErrorF("Unable to allocate ELF sections\n");
d2762 3
a2764 5
	round = (unsigned long)elffile->base & (page_size - 1);
	mprotect(elffile->base - round,
		 (elffile->basesize + round + page_size - 1) & ~(page_size -
								 1),
		 PROT_READ | PROT_WRITE | PROT_EXEC);
d2767 1
a2767 1
# else
d2769 2
a2770 2
    elffile->base = mmap(0, elffile->basesize, MMAP_PROT, MMAP_FLAGS, -1,
			 (off_t) 0);
d2772 1
a2772 1
	ErrorF("Unable to mmap ELF sections\n");
d2776 1
a2776 2
    elffile->baseptr =
	    ((long)elffile->base + (maxalign - 1)) & ~(maxalign - 1);
d2780 1
a2780 1
    if (!ELFCreateGOT(elffile, maxalign))
d2791 1
a2791 3
	    pLookup[i].offset =
		    (funcptr) ((long)pLookup[i].offset +
			       (long)elffile->saddr[secttable[i]]);
d2793 2
a2794 2
	    ELFDEBUG("Finalizing symbol %p %s\n",
		     (void *)pLookup[i].offset, pLookup[i].symName);
d2803 1
a2803 1
    if (!ElfCreateCOMMON(elffile, *ppLookup))
d2807 1
a2807 1
     * silently (the user will find out soon enough that there's no VM left */
d2812 1
a2812 1
	for (i = 0; i < elffile->lsectidx; i++) {
d2814 1
a2814 2

	    if (!strcmp(name, ".text"))
d2816 1
a2816 1
	    else if (!strcmp(name, ".data"))
d2818 1
a2818 1
	    else if (!strcmp(name, ".rodata"))
d2820 1
a2820 1
	    else if (!strcmp(name, ".bss"))
d2836 2
a2837 1
ELFResolveSymbols(void *mod)
d2845 1
a2845 1
    for (p = _LoaderGetRelocations(mod)->elf_reloc; p;) {
d2847 2
a2848 4
	ELFDEBUG("ResolveSymbols: "
		 "file %p, sec %d, r_offset 0x%x, r_info 0x%p\n",
		 (void *)p->file, p->secn, p->rel->r_offset,
		 (void *)p->rel->r_info);
d2860 1
a2860 1
    _LoaderGetRelocations(mod)->elf_reloc = newlist;
d2864 2
a2865 1
ELFCheckForUnresolved(void *mod)
d2867 3
a2869 3
    ELFRelocPtr erel;
    char *name;
    int flag, fatalsym = 0;
d2874 1
a2874 1
    while (erel) {
d2877 4
a2880 6
	flag = _LoaderHandleUnresolved(name,
				       _LoaderHandleToName(erel->file->
							   handle));
	if (flag)
	    fatalsym = 1;
	erel = erel->next;
d2886 2
a2887 1
ELFUnloadModule(void *modptr)
d2889 2
a2890 2
    ELFModulePtr elffile = (ELFModulePtr) modptr;
    ELFRelocPtr relptr, reltptr, *brelptr;
d2892 1
a2892 1

d2897 2
a2898 2
    relptr = _LoaderGetRelocations(elffile->funcs)->elf_reloc;
    brelptr = &(_LoaderGetRelocations(elffile->funcs)->elf_reloc);
d2900 11
a2910 10
    while (relptr) {
	if (relptr->file == elffile) {
	    *brelptr = relptr->next;	/* take it out of the list */
	    reltptr = relptr;	/* save pointer to this node */
	    relptr = relptr->next;	/* advance the pointer */
	    xf86loaderfree(reltptr);	/* free the node */
	} else {
	    brelptr = &(relptr->next);
	    relptr = relptr->next;	/* advance the pointer */
	}
d2924 1
a2924 1
#else
d2930 1
a2930 1
    CheckandFree(elffile->base, elffile->basesize);
a2935 1

d2944 2
a2945 2
#else /*MergeSectionAlloc */
    CheckandFree(elffile->common, elffile->comsize);
d2947 1
a2947 1
    CheckandFree(elffile->got, elffile->gotsize);
d2950 1
a2950 1
    CheckandFree(elffile->plt, elffile->pltsize);
d2956 1
a2956 2

	while ((gotent = elffile->got_entries)) {
a2964 1

a2971 1

d2997 1
a2997 1
    _LoaderFreeFileMem(elffile->sections, elffile->secsize);
d2999 4
a3002 3
    _LoaderFreeFileMem(elffile->header, sizeof(Elf_Ehdr));
    _LoaderFreeFileMem(elffile->shstraddr, elffile->shstrsize);

d3014 1
a3014 1
    ELFModulePtr elffile = (ELFModulePtr) modptr;
d3017 5
a3021 4
    for (i = 1; i < elffile->numsh; i++) {
	if (address >= (unsigned long)elffile->saddr[i] &&
	    address <= (unsigned long)elffile->saddr[i] + SecSize(i)) {
	    return ElfGetSectionName(elffile, elffile->sections[i].sh_name);
a3022 1
    }
@


