head	1.2;
access;
symbols
	tg-mergetmp-2:1.2
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407221130:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.2
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.03.07.18.38.14;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.20.08.30;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.08.30;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.37.25;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.24.16;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.25.00;	author tg;	state Exp;
branches;
next	1.1.9.2;

1.1.9.2
date	2004.03.05.22.33.22;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@semi-automagic merge of these files (ie, I've skipped through the diffs,
and most of that was done by cvs or that weird script of some minutes ago)
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/loadmod.c,v 1.74 2004/02/13 23:58:45 dawes Exp $ */

/*
 *
 * Copyright 1995-1998 by Metro Link, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Metro Link, Inc. not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Metro Link, Inc. makes no
 * representations about the suitability of this software for any purpose.
 *  It is provided "as is" without express or implied warranty.
 *
 * METRO LINK, INC. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL METRO LINK, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1997-2002 by The XFree86 Project, Inc.
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 *
 *   1.  Redistributions of source code must retain the above copyright
 *       notice, this list of conditions, and the following disclaimer.
 *
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer
 *       in the documentation and/or other materials provided with the
 *       distribution, and in the same place and form as other copyright,
 *       license and disclaimer information.
 *
 *   3.  The end-user documentation included with the redistribution,
 *       if any, must include the following acknowledgment: "This product
 *       includes software developed by The XFree86 Project, Inc
 *       (http://www.xfree86.org/) and its contributors", in the same
 *       place and form as other third-party acknowledgments.  Alternately,
 *       this acknowledgment may appear in the software itself, in the
 *       same form and location as other such third-party acknowledgments.
 *
 *   4.  Except as contained in this notice, the name of The XFree86
 *       Project, Inc shall not be used in advertising or otherwise to
 *       promote the sale, use or other dealings in this Software without
 *       prior written authorization from The XFree86 Project, Inc.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE XFREE86 PROJECT, INC OR ITS CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "os.h"
/* For stat() and related stuff */
#define NO_OSLIB_PROTOTYPES
#include "xf86_OSlib.h"
#define LOADERDECLARATIONS
#include "loaderProcs.h"
#include "misc.h"
#include "xf86.h"
#include "xf86Priv.h"
#ifdef XINPUT
#include "xf86Xinput.h"
#endif
#include "loader.h"
#include "xf86Optrec.h"

#include <sys/types.h>
#include <regex.h>
#include <dirent.h>
#include <limits.h>

extern int check_unresolved_sema;

typedef struct _pattern {
    const char *pattern;
    regex_t rex;
} PatternRec, *PatternPtr;

/* Prototypes for static functions */
static char *FindModule(const char *, const char *, const char **,
			PatternPtr);
static Bool CheckVersion(const char *, XF86ModuleVersionInfo *,
			 const XF86ModReqInfo *);
static void UnloadModuleOrDriver(ModuleDescPtr mod);
static char *LoaderGetCanonicalName(const char *, PatternPtr);
static void RemoveChild(ModuleDescPtr);

ModuleVersions LoaderVersionInfo = {
    XF86_VERSION_CURRENT,
    ABI_ANSIC_VERSION,
    ABI_VIDEODRV_VERSION,
    ABI_XINPUT_VERSION,
    ABI_EXTENSION_VERSION,
    ABI_FONT_VERSION
};

#if 0
void
LoaderFixups(void)
{
    /* Need to call LRS here because the frame buffers get loaded last,
     * and the drivers depend on them. */

    LoaderResolveSymbols();
}
#endif

static void
FreeStringList(char **paths)
{
    char **p;

    if (!paths)
	return;

    for (p = paths; *p; p++)
	xfree(*p);

    xfree(paths);
}

static char **defaultPathList = NULL;

/*
 * Convert a comma-separated path into a NULL-terminated array of path
 * elements, rejecting any that are not full absolute paths, and appending
 * a '/' when it isn't already present.
 */
static char **
InitPathList(const char *path)
{
    char *fullpath = NULL;
    char *elem = NULL;
    char **list = NULL, **save = NULL;
    int len;
    int addslash;
    int n = 0;

    if (!path)
	return defaultPathList;

    fullpath = xstrdup(path);
    if (!fullpath)
	return NULL;
    elem = strtok(fullpath, ",");
    while (elem) {
	/* Only allow fully specified paths */
#ifndef __UNIXOS2__
	if (*elem == '/')
#else
	if (*elem == '/' || (strlen(elem) > 2 && isalpha(elem[0]) &&
			     elem[1] == ':' && elem[2] == '/'))
#endif
	{
	    len = strlen(elem);
	    addslash = (elem[len - 1] != '/');
	    if (addslash)
		len++;
	    save = list;
	    list = xrealloc(list, (n + 2) * sizeof(char *));
	    if (!list) {
		if (save) {
		    save[n] = NULL;
		    FreeStringList(save);
		}
		xfree(fullpath);
		return NULL;
	    }
	    list[n] = xalloc(len + 1);
	    if (!list[n]) {
		FreeStringList(list);
		xfree(fullpath);
		return NULL;
	    }
	    strcpy(list[n], elem);
	    if (addslash) {
		list[n][len - 1] = '/';
		list[n][len] = '\0';
	    }
	    n++;
	}
	elem = strtok(NULL, ",");
    }
    if (list)
	list[n] = NULL;
    return list;
}

static void
FreePathList(char **pathlist)
{
    if (pathlist && pathlist != defaultPathList)
	FreeStringList(pathlist);
}

void
LoaderSetPath(const char *path)
{
    if (!path)
	return;

    defaultPathList = InitPathList(path);
}

/* Standard set of module subdirectories to search, in order of preference */
static const char *stdSubdirs[] = {
    "drivers/",
    "input/",
    "multimedia/",
    "extensions/",
    "fonts/",
    "internal/",
    "",
    NULL
};

/*
 * Standard set of module name patterns to check, in order of preference
 * These are regular expressions (suitable for use with POSIX regex(3)).
 */
static PatternRec stdPatterns[] = {
    {"^lib(.*)\\.so$",},
    {"^lib(.*)\\.a$",},
    {"(.*)_drv\\.so$",},
    {"(.*)_drv\\.o$",},
    {"(.*)\\.so$",},
    {"(.*)\\.a$",},
    {"(.*)\\.o$",},
    {NULL,}
};

static PatternPtr
InitPatterns(const char **patternlist)
{
    char errmsg[80];
    int i, e;
    PatternPtr patterns = NULL;
    PatternPtr p = NULL;
    static int firstTime = 1;
    const char **s;

    if (firstTime) {
	/* precompile stdPatterns */
	firstTime = 0;
	for (p = stdPatterns; p->pattern; p++)
	    if ((e = regcomp(&p->rex, p->pattern, REG_EXTENDED)) != 0) {
		regerror(e, &p->rex, errmsg, sizeof(errmsg));
		FatalError("InitPatterns: regcomp error for `%s': %s\n",
			   p->pattern, errmsg);
	    }
    }

    if (patternlist) {
	for (i = 0, s = patternlist; *s; i++, s++)
	    if (*s == DEFAULT_LIST)
		i += sizeof(stdPatterns) / sizeof(stdPatterns[0]) - 1 - 1;
	patterns = xalloc((i + 1) * sizeof(PatternRec));
	if (!patterns) {
	    return NULL;
	}
	for (i = 0, s = patternlist; *s; i++, s++)
	    if (*s != DEFAULT_LIST) {
		p = patterns + i;
		p->pattern = *s;
		if ((e = regcomp(&p->rex, p->pattern, REG_EXTENDED)) != 0) {
		    regerror(e, &p->rex, errmsg, sizeof(errmsg));
		    ErrorF("InitPatterns: regcomp error for `%s': %s\n",
			   p->pattern, errmsg);
		    i--;
		}
	    } else {
		for (p = stdPatterns; p->pattern; p++, i++)
		    patterns[i] = *p;
		if (p != stdPatterns)
		    i--;
	    }
	patterns[i].pattern = NULL;
    } else
	patterns = stdPatterns;
    return patterns;
}

static void
FreePatterns(PatternPtr patterns)
{
    if (patterns && patterns != stdPatterns)
	xfree(patterns);
}

static const char **
InitSubdirs(const char **subdirlist)
{
    int i;
    const char **tmp_subdirlist = NULL;
    char **subdirs = NULL;
    const char **s, **stmp = NULL;
    const char *osname;
    const char *slash;
    int oslen = 0, len;
    Bool indefault;

    if (subdirlist == NULL) {
	subdirlist = tmp_subdirlist = xalloc(2 * sizeof(char *));
	if (subdirlist == NULL)
	    return NULL;
	subdirlist[0] = DEFAULT_LIST;
	subdirlist[1] = NULL;
    }

    LoaderGetOS(&osname, NULL, NULL, NULL);
    oslen = strlen(osname);

    {
	/* Count number of entries and check for invalid paths */
	for (i = 0, s = subdirlist; *s; i++, s++) {
	    if (*s == DEFAULT_LIST) {
		i += sizeof(stdSubdirs) / sizeof(stdSubdirs[0]) - 1 - 1;
	    } else {
		/*
		 * Path validity check.  Don't allow absolute paths, or
		 * paths containing "..".  To catch absolute paths on
		 * platforms that use driver letters, don't allow the ':'
		 * character to appear at all.
		 */
		if (**s == '/' || **s == '\\' || strchr(*s, ':') ||
		    strstr(*s, "..")) {
		    xf86Msg(X_ERROR, "InitSubdirs: Bad subdir: \"%s\"\n", *s);
		    if (tmp_subdirlist)
			xfree(tmp_subdirlist);
		    return NULL;
		}
	    }
	}
	subdirs = xalloc((i * 2 + 1) * sizeof(char *));
	if (!subdirs) {
	    if (tmp_subdirlist)
		xfree(tmp_subdirlist);
	    return NULL;
	}
	i = 0;
	s = subdirlist;
	indefault = FALSE;
	while (*s) {
	    if (*s == DEFAULT_LIST) {
		/* Divert to the default list */
		indefault = TRUE;
		stmp = ++s;
		s = stdSubdirs;
	    }
	    len = strlen(*s);
	    if (**s && (*s)[len - 1] != '/') {
		slash = "/";
		len++;
	    } else
		slash = "";
	    len += oslen + 2;
	    if (!(subdirs[i] = xalloc(len))) {
		while (--i >= 0)
		    xfree(subdirs[i]);
		xfree(subdirs);
		if (tmp_subdirlist)
		    xfree(tmp_subdirlist);
		return NULL;
	    }
	    /* tack on the OS name */
	    sprintf(subdirs[i], "%s%s%s/", *s, slash, osname);
	    i++;
	    /* path as given */
	    subdirs[i] = xstrdup(*s);
	    i++;
	    s++;
	    if (indefault && !s) {
		/* revert back to the main list */
		indefault = FALSE;
		s = stmp;
	    }
	}
	subdirs[i] = NULL;
    }
    if (tmp_subdirlist)
	xfree(tmp_subdirlist);
    return (const char **)subdirs;
}

static void
FreeSubdirs(const char **subdirs)
{
    const char **s;

    if (subdirs) {
	for (s = subdirs; *s; s++)
	    xfree(*s);
	xfree(subdirs);
    }
}

static char *
FindModule(const char *module, const char *dir, const char **subdirlist,
	   PatternPtr patterns)
{
    char buf[PATH_MAX + 1];
    char *dirpath = NULL;
    char *name = NULL;
    struct stat stat_buf;
    int len, dirlen;
    char *fp;
    DIR *d;
    const char **subdirs = NULL;
    PatternPtr p = NULL;
    const char **s;
    struct dirent *dp;
    regmatch_t match[2];

    subdirs = InitSubdirs(subdirlist);
    if (!subdirs)
	return NULL;

#ifndef __EMX__
    dirpath = (char *)dir;
#else
    dirpath = xalloc(strlen(dir) + 10);
    strcpy(dirpath, (char *)__XOS2RedirRoot(dir));
#endif
    if (strlen(dirpath) > PATH_MAX)
	return NULL;
    /*xf86Msg(X_INFO,"OS2DIAG: FindModule: dirpath=%s\n",dirpath); */

    for (s = subdirs; *s; s++) {
	if ((dirlen = strlen(dirpath) + strlen(*s)) > PATH_MAX)
	    continue;
	strcpy(buf, dirpath);
	strcat(buf, *s);
	/*xf86Msg(X_INFO,"OS2DIAG: FindModule: buf=%s\n",buf); */
	fp = buf + dirlen;
	if (stat(buf, &stat_buf) == 0 && S_ISDIR(stat_buf.st_mode) &&
	    (d = opendir(buf))) {
	    if (buf[dirlen - 1] != '/') {
		buf[dirlen++] = '/';
		fp++;
	    }
	    while ((dp = readdir(d))) {
		if (dirlen + strlen(dp->d_name) + 1 > PATH_MAX)
		    continue;
		strcpy(fp, dp->d_name);
		if (!(stat(buf, &stat_buf) == 0 && S_ISREG(stat_buf.st_mode)))
		    continue;
		for (p = patterns; p->pattern; p++) {
		    if (regexec(&p->rex, dp->d_name, 2, match, 0) == 0 &&
			match[1].rm_so != -1) {
			len = match[1].rm_eo - match[1].rm_so;
			if (len == strlen(module) &&
			    strncmp(module, dp->d_name + match[1].rm_so,
				    len) == 0) {
			    /*xf86Msg(X_INFO,"OS2DIAG: matching %s\n",buf); */
			    name = buf;
			    break;
			}
		    }
		}
		if (name)
		    break;
	    }
	    closedir(d);
	    if (name)
		break;
	}
    }
    FreeSubdirs(subdirs);
    if (dirpath != dir)
	xfree(dirpath);

    if (name) {
	return xstrdup(name);
    }
    return NULL;
}

char **
LoaderListDirs(const char **subdirlist, const char **patternlist)
{
    char buf[PATH_MAX + 1];
    char **pathlist;
    char **elem;
    const char **subdirs;
    const char **s;
    PatternPtr patterns;
    PatternPtr p;
    DIR *d;
    struct dirent *dp;
    regmatch_t match[2];
    struct stat stat_buf;
    int len, dirlen;
    char *fp;
    char **listing = NULL;
    char **save;
    int n = 0;

    if (!(pathlist = InitPathList(NULL)))
	return NULL;
    if (!(subdirs = InitSubdirs(subdirlist))) {
	FreePathList(pathlist);
	return NULL;
    }
    if (!(patterns = InitPatterns(patternlist))) {
	FreePathList(pathlist);
	FreeSubdirs(subdirs);
	return NULL;
    }

    for (elem = pathlist; *elem; elem++) {
	for (s = subdirs; *s; s++) {
	    if ((dirlen = strlen(*elem) + strlen(*s)) > PATH_MAX)
		continue;
	    strcpy(buf, *elem);
	    strcat(buf, *s);
	    fp = buf + dirlen;
	    if (stat(buf, &stat_buf) == 0 && S_ISDIR(stat_buf.st_mode) &&
		(d = opendir(buf))) {
		if (buf[dirlen - 1] != '/') {
		    buf[dirlen++] = '/';
		    fp++;
		}
		while ((dp = readdir(d))) {
		    if (dirlen + strlen(dp->d_name) > PATH_MAX)
			continue;
		    strcpy(fp, dp->d_name);
		    if (!(stat(buf, &stat_buf) == 0 &&
			  S_ISREG(stat_buf.st_mode)))
			continue;
		    for (p = patterns; p->pattern; p++) {
			if (regexec(&p->rex, dp->d_name, 2, match, 0) == 0 &&
			    match[1].rm_so != -1) {
			    len = match[1].rm_eo - match[1].rm_so;
			    save = listing;
			    listing = xrealloc(listing,
					       (n + 2) * sizeof(char *));
			    if (!listing) {
				if (save) {
				    save[n] = NULL;
				    FreeStringList(save);
				}
				FreePathList(pathlist);
				FreeSubdirs(subdirs);
				FreePatterns(patterns);
				return NULL;
			    }
			    listing[n] = xalloc(len + 1);
			    if (!listing[n]) {
				FreeStringList(listing);
				FreePathList(pathlist);
				FreeSubdirs(subdirs);
				FreePatterns(patterns);
				return NULL;
			    }
			    strncpy(listing[n], dp->d_name + match[1].rm_so,
				    len);
			    listing[n][len] = '\0';
			    n++;
			    break;
			}
		    }
		}
		closedir(d);
	    }
	}
    }
    if (listing)
	listing[n] = NULL;
    return listing;
}

void
LoaderFreeDirList(char **list)
{
    FreeStringList(list);
}

static Bool
CheckVersion(const char *module, XF86ModuleVersionInfo * data,
	     const XF86ModReqInfo * req)
{
    int vercode[4];
    char verstr[4];
    long ver = data->xf86version;
    MessageType errtype;

    xf86Msg(X_INFO, "Module %s: vendor=\"%s\"\n",
	    data->modname ? data->modname : "UNKNOWN!",
	    data->vendor ? data->vendor : "UNKNOWN!");

    if (ver > (4 << 24)) {
	/* 4.0.x and earlier */
	verstr[1] = verstr[3] = 0;
	verstr[2] = (ver & 0x1f) ? (ver & 0x1f) + 'a' - 1 : 0;
	ver >>= 5;
	verstr[0] = (ver & 0x1f) ? (ver & 0x1f) + 'A' - 1 : 0;
	ver >>= 5;
	vercode[2] = ver & 0x7f;
	ver >>= 7;
	vercode[1] = ver & 0x7f;
	ver >>= 7;
	vercode[0] = ver;
	xf86ErrorF("\tcompiled for %d.%d", vercode[0], vercode[1]);
	if (vercode[2] != 0)
	    xf86ErrorF(".%d", vercode[2]);
	xf86ErrorF("%s%s, module version = %d.%d.%d\n", verstr, verstr + 2,
		   data->majorversion, data->minorversion, data->patchlevel);
    } else {
	vercode[0] = ver / 10000000;
	vercode[1] = (ver / 100000) % 100;
	vercode[2] = (ver / 1000) % 100;
	vercode[3] = ver % 1000;
	xf86ErrorF("\tcompiled for %d.%d.%d", vercode[0], vercode[1],
		   vercode[2]);
	if (vercode[3] != 0)
	    xf86ErrorF(".%d", vercode[3]);
	xf86ErrorF(", module version = %d.%d.%d\n", data->majorversion,
		   data->minorversion, data->patchlevel);
    }

    if (data->moduleclass)
	xf86ErrorFVerb(2, "\tModule class: %s\n", data->moduleclass);

    ver = -1;
    if (data->abiclass) {
	int abimaj, abimin;
	int vermaj, vermin;

	if (!strcmp(data->abiclass, ABI_CLASS_ANSIC))
	    ver = LoaderVersionInfo.ansicVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_VIDEODRV))
	    ver = LoaderVersionInfo.videodrvVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_XINPUT))
	    ver = LoaderVersionInfo.xinputVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_EXTENSION))
	    ver = LoaderVersionInfo.extensionVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_FONT))
	    ver = LoaderVersionInfo.fontVersion;

	abimaj = GET_ABI_MAJOR(data->abiversion);
	abimin = GET_ABI_MINOR(data->abiversion);
	xf86ErrorFVerb(2, "\tABI class: %s, version %d.%d\n",
		       data->abiclass, abimaj, abimin);
	if (ver != -1) {
	    vermaj = GET_ABI_MAJOR(ver);
	    vermin = GET_ABI_MINOR(ver);
	    if (abimaj != vermaj) {
		if (LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL)
		    errtype = X_WARNING;
		else
		    errtype = X_ERROR;
		xf86MsgVerb(errtype, 0,
			    "module ABI major version (%d) doesn't"
			    " match the server's version (%d)\n",
			    abimaj, vermaj);
		if (!(LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL))
		    return FALSE;
	    } else if (abimin > vermin) {
		if (LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL)
		    errtype = X_WARNING;
		else
		    errtype = X_ERROR;
		xf86MsgVerb(errtype, 0,
			    "module ABI minor version (%d) is "
			    "newer than the server's version "
			    "(%d)\n", abimin, vermin);
		if (!(LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL))
		    return FALSE;
	    }
	}
    }

    /* Check against requirements that the caller has specified */
    if (req) {
	if (req->majorversion != MAJOR_UNSPEC) {
	    if (data->majorversion != req->majorversion) {
		xf86MsgVerb(X_WARNING, 2, "module major version (%d) "
			    "doesn't match required major version (%d)\n",
			    data->majorversion, req->majorversion);
		return FALSE;
	    } else if (req->minorversion != MINOR_UNSPEC) {
		if (data->minorversion < req->minorversion) {
		    xf86MsgVerb(X_WARNING, 2, "module minor version (%d) "
				"is less than the required minor version (%d)\n",
				data->minorversion, req->minorversion);
		    return FALSE;
		} else if (data->minorversion == req->minorversion &&
			   req->patchlevel != PATCH_UNSPEC) {
		    if (data->patchlevel < req->patchlevel) {
			xf86MsgVerb(X_WARNING, 2, "module patch level (%d) "
				    "is less than the required patch level (%d)\n",
				    data->patchlevel, req->patchlevel);
			return FALSE;
		    }
		}
	    }
	}
	if (req->moduleclass) {
	    if (!data->moduleclass ||
		strcmp(req->moduleclass, data->moduleclass)) {
		xf86MsgVerb(X_WARNING, 2, "Module class (%s) doesn't match "
			    "the required class (%s)\n",
			    data->moduleclass ? data->moduleclass : "<NONE>",
			    req->moduleclass);
		return FALSE;
	    }
	} else if (req->abiclass != ABI_CLASS_NONE) {
	    if (!data->abiclass || strcmp(req->abiclass, data->moduleclass)) {
		xf86MsgVerb(X_WARNING, 2, "ABI class (%s) doesn't match the "
			    "required ABI class (%s)\n",
			    data->abiclass ? data->abiclass : "<NONE>",
			    req->abiclass);
		return FALSE;
	    }
	}
	if ((req->abiclass != ABI_CLASS_NONE) &&
	    req->abiversion != ABI_VERS_UNSPEC) {
	    int reqmaj, reqmin, maj, min;

	    reqmaj = GET_ABI_MAJOR(req->abiversion);
	    reqmin = GET_ABI_MINOR(req->abiversion);
	    maj = GET_ABI_MAJOR(data->abiversion);
	    min = GET_ABI_MINOR(data->abiversion);
	    if (maj != reqmaj) {
		xf86MsgVerb(X_WARNING, 2, "ABI major version (%d) doesn't "
			    "match the required ABI major version (%d)\n",
			    maj, reqmaj);
		return FALSE;
	    }
	    /* XXX Maybe this should be the other way around? */
	    if (min > reqmin) {
		xf86MsgVerb(X_WARNING, 2, "module ABI minor version (%d) "
			    "is new than that available (%d)\n", min, reqmin);
		return FALSE;
	    }
	}
    }
#ifdef NOTYET
    if (data->checksum) {
	/* verify the checksum field */
	/* TO BE DONE */
    } else {
	ErrorF("\t*** Checksum field is 0 - this module is untrusted!\n");
    }
#endif
    return TRUE;
}

ModuleDescPtr
LoadSubModule(ModuleDescPtr parent, const char *module,
	      const char **subdirlist, const char **patternlist,
	      pointer options, const XF86ModReqInfo * modreq,
	      int *errmaj, int *errmin)
{
    ModuleDescPtr submod;

    xf86MsgVerb(X_INFO, 3, "Loading sub module \"%s\"\n", module);

    /* Absolute module paths are not allowed here */
#ifndef __UNIXOS2__
    if (module[0] == '/')
#else
    if (isalpha(module[0]) && module[1] == ':' && module[2] == '/')
#endif
    {
	xf86Msg(X_ERROR,
		"LoadSubModule: Absolute module path not permitted: \"%s\"\n",
		module);
	if (errmaj)
	    *errmaj = LDR_BADUSAGE;
	if (errmin)
	    *errmin = 0;
	return NULL;
    }

    submod = LoadModule(module, NULL, subdirlist, patternlist, options,
			modreq, errmaj, errmin);
    if (submod) {
	parent->child = AddSibling(parent->child, submod);
	submod->parent = parent;
    }
    return submod;
}

ModuleDescPtr
DuplicateModule(ModuleDescPtr mod, ModuleDescPtr parent)
{
    ModuleDescPtr ret;

    if (!mod)
	return NULL;

    ret = NewModuleDesc(mod->name);
    if (ret == NULL)
	return NULL;

    if (LoaderHandleOpen(mod->handle) == -1)
	return NULL;

    ret->filename = xstrdup(mod->filename);
    ret->identifier = mod->identifier;
    ret->client_id = mod->client_id;
    ret->in_use = mod->in_use;
    ret->handle = mod->handle;
    ret->SetupProc = mod->SetupProc;
    ret->TearDownProc = mod->TearDownProc;
    ret->TearDownData = NULL;
    ret->path = mod->path;
    ret->child = DuplicateModule(mod->child, ret);
    ret->sib = DuplicateModule(mod->sib, parent);
    ret->parent = parent;
    ret->VersionInfo = mod->VersionInfo;

    return ret;
}

/*
 * LoadModule: load a module
 *
 * module       The module name.  Normally this is not a filename but the
 *              module's "canonical name.  A full pathname is, however,
 *              also accepted.
 * path         A comma separated list of module directories.
 * subdirlist   A NULL terminated list of subdirectories to search.  When
 *              NULL, the default "stdSubdirs" list is used.  The default
 *              list is also substituted for entries with value DEFAULT_LIST.
 * patternlist  A NULL terminated list of regular expressions used to find
 *              module filenames.  Each regex should contain exactly one
 *              subexpression that corresponds to the canonical module name.
 *              When NULL, the default "stdPatterns" list is used.  The
 *              default list is also substituted for entries with value
 *              DEFAULT_LIST.
 * options      A NULL terminated list of Options that are passed to the
 *              module's SetupProc function.
 * modreq       An optional XF86ModReqInfo* containing
 *              version/ABI/vendor-ABI requirements to check for when
 *              loading the module.  The following fields of the
 *              XF86ModReqInfo struct are checked:
 *                majorversion - must match the module's majorversion exactly
 *                minorversion - the module's minorversion must be >= this
 *                patchlevel   - the module's minorversion.patchlevel must be
 *                               >= this.  Patchlevel is ignored when
 *                               minorversion is not set.
 *                abiclass     - (string) must match the module's abiclass
 *                abiversion   - must be consistent with the module's
 *                               abiversion (major equal, minor no older)
 *                moduleclass  - string must match the module's moduleclass
 *                               string
 *              "don't care" values are ~0 for numbers, and NULL for strings
 * errmaj       Major error return.
 * errmin       Minor error return.
 *
 */

ModuleDescPtr
LoadModule(const char *module, const char *path, const char **subdirlist,
	   const char **patternlist, pointer options,
	   const XF86ModReqInfo * modreq, int *errmaj, int *errmin)
{
    XF86ModuleData *initdata = NULL;
    char **pathlist = NULL;
    char *found = NULL;
    char *name = NULL;
    char **path_elem = NULL;
    char *p = NULL;
    ModuleDescPtr ret = NULL;
    int wasLoaded = 0;
    PatternPtr patterns = NULL;
    int noncanonical = 0;
    char *m = NULL;

    /*xf86Msg(X_INFO,"OS2DIAG: LoadModule: %s\n",module); */
    xf86MsgVerb(X_INFO, 3, "LoadModule: \"%s\"", module);

    patterns = InitPatterns(patternlist);
    name = LoaderGetCanonicalName(module, patterns);
    noncanonical = (name && strcmp(module, name) != 0);
    if (noncanonical) {
	xf86ErrorFVerb(3, " (%s)\n", name);
	xf86MsgVerb(X_WARNING, 1,
		    "LoadModule: given non-canonical module name \"%s\"\n",
		    module);
	m = name;
    } else {
	xf86ErrorFVerb(3, "\n");
	m = (char *)module;
    }
    if (!name) {
	if (errmaj)
	    *errmaj = LDR_BADUSAGE;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
    }
    ret = NewModuleDesc(name);
    if (!ret) {
	if (errmaj)
	    *errmaj = LDR_NOMEM;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
    }

    pathlist = InitPathList(path);
    if (!pathlist) {
	/* This could be a malloc failure too */
	if (errmaj)
	    *errmaj = LDR_BADUSAGE;
	if (errmin)
	    *errmin = 1;
	goto LoadModule_fail;
    }

    /* 
     * if the module name is not a full pathname, we need to
     * check the elements in the path
     */
#ifndef __UNIXOS2__
    if (module[0] == '/')
	found = xstrdup(module);
#else
    /* accept a drive name here */
    if (isalpha(module[0]) && module[1] == ':' && module[2] == '/')
	found = xstrdup(module);
#endif
    path_elem = pathlist;
    while (!found && *path_elem != NULL) {
	found = FindModule(m, *path_elem, subdirlist, patterns);
	path_elem++;
	/*
	 * When the module name isn't the canonical name, search for the
	 * former if no match was found for the latter.
	 */
	if (!*path_elem && m == name) {
	    path_elem = pathlist;
	    m = (char *)module;
	}
    }

    /* 
     * did we find the module?
     */
    if (!found) {
	xf86Msg(X_WARNING, "Warning, couldn't open module %s\n", module);
	if (errmaj)
	    *errmaj = LDR_NOENT;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
    }
    ret->handle = LoaderOpen(found, name, 0, errmaj, errmin, &wasLoaded);
    if (ret->handle < 0)
	goto LoadModule_fail;

    ret->filename = xstrdup(found);

    /*
     * now check if the special data object <modulename>ModuleData is
     * present.
     */
    p = xalloc(strlen(name) + strlen("ModuleData") + 1);
    if (!p) {
	if (errmaj)
	    *errmaj = LDR_NOMEM;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
    }
    strcpy(p, name);
    strcat(p, "ModuleData");
    initdata = LoaderSymbol(p);
    if (initdata) {
	ModuleSetupProc setup;
	ModuleTearDownProc teardown;
	XF86ModuleVersionInfo *vers;

	vers = initdata->vers;
	setup = initdata->setup;
	teardown = initdata->teardown;

	if (!wasLoaded) {
	    if (vers) {
		if (!CheckVersion(module, vers, modreq)) {
		    if (errmaj)
			*errmaj = LDR_MISMATCH;
		    if (errmin)
			*errmin = 0;
		    goto LoadModule_fail;
		}
	    } else {
		xf86Msg(X_ERROR,
			"LoadModule: Module %s does not supply"
			" version information\n", module);
		if (errmaj)
		    *errmaj = LDR_INVALID;
		if (errmin)
		    *errmin = 0;
		goto LoadModule_fail;
	    }
	}
	if (setup)
	    ret->SetupProc = setup;
	if (teardown)
	    ret->TearDownProc = teardown;
	ret->path = path;
	ret->VersionInfo = vers;
    } else {
	/* No initdata is OK for external modules */
	if (options == EXTERN_MODULE)
	    goto LoadModule_exit;

	/* no initdata, fail the load */
	xf86Msg(X_ERROR, "LoadModule: Module %s does not have a %s "
		"data object.\n", module, p);
	if (errmaj)
	    *errmaj = LDR_INVALID;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
    }
    if (ret->SetupProc) {
	ret->TearDownData = ret->SetupProc(ret, options, errmaj, errmin);
	if (!ret->TearDownData) {
	    goto LoadModule_fail;
	}
    } else if (options) {
	xf86Msg(X_WARNING, "Module Options present, but no SetupProc "
		"available for %s\n", module);
    }
    goto LoadModule_exit;

  LoadModule_fail:
    UnloadModule(ret);
    ret = NULL;

  LoadModule_exit:
    FreePathList(pathlist);
    FreePatterns(patterns);
    TestFree(found);
    TestFree(name);
    TestFree(p);

    /*
     * If you need to do something to keep the
     * instruction cache in sync with the main
     * memory before jumping to that code, you may
     * do it here.
     */
#ifdef __alpha__
    istream_mem_barrier();
#endif
    return ret;
}

ModuleDescPtr
LoadDriver(const char *module, const char *path, int handle, pointer options,
	   int *errmaj, int *errmin)
{
    return LoadModule(module, path, NULL, NULL, options, NULL, errmaj,
		      errmin);
}

void
UnloadModule(ModuleDescPtr mod)
{
    UnloadModuleOrDriver(mod);
}

void
UnloadDriver(ModuleDescPtr mod)
{
    UnloadModuleOrDriver(mod);
}

static void
UnloadModuleOrDriver(ModuleDescPtr mod)
{
    if (mod == NULL || mod->name == NULL)
	return;

    xf86MsgVerb(X_INFO, 3, "UnloadModule: \"%s\"\n", mod->name);

    if ((mod->TearDownProc) && (mod->TearDownData))
	mod->TearDownProc(mod->TearDownData);
    LoaderUnload(mod->handle);

    if (mod->child)
	UnloadModuleOrDriver(mod->child);
    if (mod->sib)
	UnloadModuleOrDriver(mod->sib);
    TestFree(mod->name);
    TestFree(mod->filename);
    xfree(mod);
#ifdef __alpha__
    istream_mem_barrier();
#endif
}

void
UnloadSubModule(ModuleDescPtr mod)
{
    if (mod == NULL || mod->name == NULL)
	return;

    xf86MsgVerb(X_INFO, 3, "UnloadSubModule: \"%s\"\n", mod->name);

    if ((mod->TearDownProc) && (mod->TearDownData))
	mod->TearDownProc(mod->TearDownData);
    LoaderUnload(mod->handle);

    RemoveChild(mod);

    if (mod->child)
	UnloadModuleOrDriver(mod->child);

    TestFree(mod->name);
    TestFree(mod->filename);
    xfree(mod);
}

void
FreeModuleDesc(ModuleDescPtr head)
{
    ModuleDescPtr sibs, prev;

    /*
     * only free it if it's not marked as in use. In use means that it may
     * be unloaded someday, and UnloadModule or UnloadDriver will free it
     */
    if (head->in_use)
	return;
    if (head->child)
	FreeModuleDesc(head->child);
    sibs = head;
    while (sibs) {
	prev = sibs;
	sibs = sibs->sib;
	TestFree(prev->name);
	xfree(prev);
    }
}

ModuleDescPtr
NewModuleDesc(const char *name)
{
    ModuleDescPtr mdp = xalloc(sizeof(ModuleDesc));

    if (mdp) {
	mdp->child = NULL;
	mdp->sib = NULL;
	mdp->parent = NULL;
	mdp->demand_next = NULL;
	mdp->name = xstrdup(name);
	mdp->filename = NULL;
	mdp->identifier = NULL;
	mdp->client_id = 0;
	mdp->in_use = 0;
	mdp->handle = -1;
	mdp->SetupProc = NULL;
	mdp->TearDownProc = NULL;
	mdp->TearDownData = NULL;
    }

    return (mdp);
}

ModuleDescPtr
AddSibling(ModuleDescPtr head, ModuleDescPtr new)
{
    new->sib = head;
    return (new);

}

static void
RemoveChild(ModuleDescPtr child)
{
    ModuleDescPtr mdp;
    ModuleDescPtr prevsib;
    ModuleDescPtr parent;

    if (!child->parent)
	return;

    parent = child->parent;
    if (parent->child == child) {
	parent->child = child->sib;
	return;
    }

    prevsib = parent->child;
    mdp = prevsib->sib;
    while (mdp && mdp != child) {
	prevsib = mdp;
	mdp = mdp->sib;
    }
    if (mdp == child)
	prevsib->sib = child->sib;
    return;
}

void
LoaderErrorMsg(const char *name, const char *modname, int errmaj, int errmin)
{
    const char *msg;

    switch (errmaj) {
    case LDR_NOERROR:
	msg = "no error";
	break;
    case LDR_NOMEM:
	msg = "out of memory";
	break;
    case LDR_NOENT:
	msg = "module does not exist";
	break;
    case LDR_NOSUBENT:
	msg = "a required submodule could not be loaded";
	break;
    case LDR_NOSPACE:
	msg = "too many modules";
	break;
    case LDR_NOMODOPEN:
	msg = "open failed";
	break;
    case LDR_UNKTYPE:
	msg = "unknown module type";
	break;
    case LDR_NOLOAD:
	msg = "loader failed";
	break;
    case LDR_ONCEONLY:
	msg = "once-only module";
	break;
    case LDR_NOPORTOPEN:
	msg = "port open failed";
	break;
    case LDR_NOHARDWARE:
	msg = "no hardware found";
	break;
    case LDR_MISMATCH:
	msg = "module requirement mismatch";
	break;
    case LDR_BADUSAGE:
	msg = "invalid argument(s) to LoadModule()";
	break;
    case LDR_INVALID:
	msg = "invalid module";
	break;
    case LDR_BADOS:
	msg = "module doesn't support this OS";
	break;
    case LDR_MODSPECIFIC:
	msg = "module-specific error";
	break;
    default:
	msg = "uknown error";
    }
    if (name)
	xf86Msg(X_ERROR, "%s: Failed to load module \"%s\" (%s, %d)\n",
		name, modname, msg, errmin);
    else
	xf86Msg(X_ERROR, "Failed to load module \"%s\" (%s, %d)\n",
		modname, msg, errmin);
}

/* Given a module path or file name, return the module's canonical name */
static char *
LoaderGetCanonicalName(const char *modname, PatternPtr patterns)
{
    char *str;
    const char *s;
    int len;
    PatternPtr p;
    regmatch_t match[2];

    /* Strip off any leading path */
    s = strrchr(modname, '/');
    if (s == NULL)
	s = modname;
    else
	s++;

    /* Find the first regex that is matched */
    for (p = patterns; p->pattern; p++)
	if (regexec(&p->rex, s, 2, match, 0) == 0 && match[1].rm_so != -1) {
	    len = match[1].rm_eo - match[1].rm_so;
	    str = xalloc(len + 1);
	    if (!str)
		return NULL;
	    strncpy(str, s + match[1].rm_so, len);
	    str[len] = '\0';
	    return str;
	}

    /* If there is no match, return the whole name minus the leading path */
    return xstrdup(s);
}

/*
 * Return the module version information.
 */
unsigned long
LoaderGetModuleVersion(ModuleDescPtr mod)
{
    if (!mod || !mod->VersionInfo)
	return 0;

    return MODULE_VERSION_NUMERIC(mod->VersionInfo->majorversion,
				  mod->VersionInfo->minorversion,
				  mod->VersionInfo->patchlevel);
}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/loadmod.c,v 1.66 2001/12/17 20:00:45 dawes Exp $ */
d25 46
a70 2

/* This file is best viewed with tab stops set to 4 spaces */
d95 2
a96 2
	const char *	pattern;
	regex_t			rex;
d100 5
a104 4
static char *FindModule (const char *, const char *, const char **, PatternPtr);
static Bool CheckVersion (const char *, XF86ModuleVersionInfo *,
				const XF86ModReqInfo *);
static void UnloadModuleOrDriver (ModuleDescPtr mod);
d109 6
a114 6
	XF86_VERSION_CURRENT,
	ABI_ANSIC_VERSION,
	ABI_VIDEODRV_VERSION,
	ABI_XINPUT_VERSION,
	ABI_EXTENSION_VERSION,
	ABI_FONT_VERSION
d119 1
a119 1
LoaderFixups (void)
d121 2
a122 2
	/* Need to call LRS here because the frame buffers get loaded last,
	 * and the drivers depend on them. */
d124 1
a124 1
	LoaderResolveSymbols ();
d131 1
a131 1
	char **p;
d133 2
a134 2
	if (!paths)
		return;
d136 2
a137 2
	for (p = paths; *p; p++)
		xfree(*p);
d139 1
a139 1
	xfree(paths);
d152 6
a157 6
	char *fullpath = NULL;
	char *elem = NULL;
	char **list = NULL, **save = NULL;
	int len;
	int addslash;
	int n = 0;
d159 2
a160 2
	if (!path)
		return defaultPathList;
d162 8
a169 8
	fullpath = xstrdup(path);
	if (!fullpath)
		return NULL;
	elem = strtok(fullpath, ",");
	while (elem) {
		/* Only allow fully specified paths */
#ifndef __EMX__
		if (*elem == '/')
d171 2
a172 2
		if (*elem == '/' || (strlen(elem) > 2 && isalpha(elem[0]) &&
							  elem[1] == ':' && elem[2] == '/'))
d174 11
a184 27
		{
			len = strlen(elem);
			addslash = (elem[len - 1] != '/');
			if (addslash)
				len++;
			save = list;
			list = xrealloc(list, (n + 2) * sizeof(char *));
			if (!list) {
				if (save) {
					save[n] = NULL;
					FreeStringList(save);
				}
				xfree(fullpath);
				return NULL;
			}
			list[n] = xalloc(len + 1);
			if (!list[n]) {
				FreeStringList(list);
				xfree(fullpath);
				return NULL;
			}
			strcpy(list[n], elem);
			if (addslash) {
				list[n][len - 1] = '/';
				list[n][len] = '\0';
			}
			n++;
d186 21
a206 5
		elem = strtok(NULL, ",");
	}
	if (list)
		list[n] = NULL;
	return list;
d212 2
a213 2
	if (pathlist && pathlist != defaultPathList)
		FreeStringList(pathlist);
d219 2
a220 2
	if (!path)
		return;
d222 1
a222 1
	defaultPathList = InitPathList(path);
d226 9
a234 10
static const char *stdSubdirs[] =
{
	"drivers/",
	"input/",
	"multimedia/",
	"extensions/",
	"fonts/",
	"internal/",
	"",
	NULL
d242 8
a249 8
	{ "^lib(.*)\\.so$", },
	{ "^lib(.*)\\.a$", },
	{ "(.*)_drv\\.so$", },
	{ "(.*)_drv\\.o$", },
	{ "(.*)\\.so$", },
	{ "(.*)\\.a$", },
	{ "(.*)\\.o$", },
	{ NULL, }
d255 35
a289 25
	char errmsg[80];
	int i, e;
	PatternPtr patterns = NULL;
	PatternPtr p = NULL;
	static int firstTime = 1;
	const char **s;

	if (firstTime) {
		/* precompile stdPatterns */
		firstTime = 0;
		for (p = stdPatterns; p->pattern; p++)
			if ((e = regcomp(&p->rex, p->pattern, REG_EXTENDED)) != 0) {
				regerror(e, &p->rex, errmsg, sizeof(errmsg));
				FatalError("InitPatterns: regcomp error for `%s': %s\n",
							p->pattern, errmsg);
			}
	}

	if (patternlist) {
		for (i = 0, s = patternlist; *s; i++, s++)
			if (*s == DEFAULT_LIST)
				i += sizeof(stdPatterns) / sizeof(stdPatterns[0]) - 1 - 1;
		patterns = xalloc((i + 1) * sizeof(PatternRec));
		if (!patterns) {
			return NULL;
d291 10
a300 20
		for (i = 0, s = patternlist; *s; i++, s++)
			if (*s != DEFAULT_LIST) {
				p = patterns + i;
				p->pattern = *s;
				if ((e = regcomp(&p->rex, p->pattern, REG_EXTENDED)) != 0) {
					regerror(e, &p->rex, errmsg, sizeof(errmsg));
					ErrorF("InitPatterns: regcomp error for `%s': %s\n",
							p->pattern, errmsg);
					i--;
				}
			} else {
				for (p = stdPatterns; p->pattern; p++, i++)
					patterns[i] = *p;
				if (p != stdPatterns)
					i--;
			}
		patterns[i].pattern = NULL;
	} else
		patterns = stdPatterns;
	return patterns;
d306 2
a307 2
	if (patterns && patterns != stdPatterns)
		xfree(patterns);
d313 4
a316 3
	int i;
	char **subdirs = NULL;
	const char **s, **stmp = NULL;
d323 7
a329 7
	    subdirlist = xalloc(2 * sizeof(char *));
	    if (subdirlist == NULL)
			return NULL;
		subdirlist[0] = DEFAULT_LIST;
		subdirlist[1] = NULL;
	}
	
d334 17
a350 17
		/* Count number of entries and check for invalid paths */
		for (i = 0, s = subdirlist; *s; i++, s++) {
			if (*s == DEFAULT_LIST) {
				i += sizeof(stdSubdirs) / sizeof(stdSubdirs[0]) - 1 - 1;
			} else {
				/*
				 * Path validity check.  Don't allow absolute paths, or
				 * paths containing "..".  To catch absolute paths on
				 * platforms that use driver letters, don't allow the ':'
				 * character to appear at all.
				 */
				if (**s == '/' || **s == '\\' || strchr(*s, ':') ||
					strstr(*s, "..")) {
					xf86Msg(X_ERROR, "InitSubdirs: Bad subdir: \"%s\"\n", *s);
					return NULL;
				}
			}
d352 42
a393 5
		subdirs = xalloc((i * 2 + 1) * sizeof(char *));
		if (!subdirs)
			return NULL;
		i = 0;
		s = subdirlist;
d395 2
a396 30
		while (*s) {
			if (*s == DEFAULT_LIST) {
				/* Divert to the default list */
				indefault = TRUE;
				stmp = ++s;
				s = stdSubdirs;
			}
			len = strlen(*s);
			if (**s && (*s)[len - 1] != '/') {
				slash = "/";
				len++;
			} else
				slash = "";
			len += oslen + 2;
			if (!(subdirs[i] = xalloc(len)))
				return NULL;
			/* tack on the OS name */
			sprintf(subdirs[i], "%s%s%s/", *s, slash, osname);
			i++;
			/* path as given */
			subdirs[i] = xstrdup(*s);
			i++;
			s++;
			if (indefault && !s) {
				/* revert back to the main list */
				indefault = FALSE;
				s = stmp;
			}
		}
		subdirs[i] = NULL;
d398 5
a402 1
	return (const char **)subdirs;
d408 1
a408 1
	const char **s;
d410 5
a414 5
	if (subdirs) {
		for (s = subdirs; *s; s++)
			xfree(*s);
		xfree(subdirs);
	}
d418 2
a419 2
FindModule (const char *module, const char *dir, const char **subdirlist,
			PatternPtr patterns)
d421 12
a432 12
	char buf[PATH_MAX + 1];
	char *dirpath = NULL;
	char *name = NULL;
	struct stat stat_buf;
	int len, dirlen;
	char *fp;
	DIR *d;
	const char **subdirs = NULL;
	PatternPtr p = NULL;
	const char **s;
	struct dirent *dp;
	regmatch_t match[2];
d434 3
a436 3
	subdirs = InitSubdirs(subdirlist);
	if (!subdirs)
		return NULL;
d439 1
a439 1
	dirpath = (char *)dir;
d441 2
a442 2
	dirpath = xalloc(strlen(dir) + 10);
	strcpy(dirpath, (char *) __XOS2RedirRoot (dir));
d444 3
a446 3
	if (strlen(dirpath) > PATH_MAX)
		return NULL;
	/*xf86Msg(X_INFO,"OS2DIAG: FindModule: dirpath=%s\n",dirpath);*/
d448 29
a476 12
	for (s = subdirs; *s; s++) {
		if ((dirlen = strlen(dirpath) + strlen(*s)) > PATH_MAX)
			continue;
		strcpy(buf, dirpath);
		strcat(buf, *s);
		/*xf86Msg(X_INFO,"OS2DIAG: FindModule: buf=%s\n",buf);*/
		fp = buf + dirlen;
		if (stat(buf, &stat_buf) == 0 && S_ISDIR(stat_buf.st_mode) &&
			(d = opendir(buf))) {
			if (buf[dirlen - 1] != '/') {
				buf[dirlen++] = '/';
				fp++;
d478 1
a478 24
			while ((dp = readdir(d))) {
				if (dirlen + strlen(dp->d_name) + 1 > PATH_MAX)
					continue;
				strcpy(fp, dp->d_name);
				if (!(stat(buf, &stat_buf) == 0 && S_ISREG(stat_buf.st_mode)))
					continue;
				for (p = patterns; p->pattern; p++) {
					if (regexec(&p->rex, dp->d_name, 2, match, 0) == 0 &&
						match[1].rm_so != -1) {
						len = match[1].rm_eo - match[1].rm_so;
						if (len == strlen(module) &&
							strncmp(module, dp->d_name + match[1].rm_so, len) == 0) {
							/*xf86Msg(X_INFO,"OS2DIAG: matching %s\n",buf);*/
							name = buf;
							break;
						}
					}
				}
				if (name)
					break;
			}
			closedir(d);
			if (name)
				break;
d480 6
d487 9
a495 8
	FreeSubdirs(subdirs);
	if (dirpath != dir)
		xfree(dirpath);

	if (name) {
		return xstrdup(name);
	}
	return NULL;
d501 16
a516 16
	char buf[PATH_MAX + 1];
	char **pathlist;
	char **elem;
	const char **subdirs;
	const char **s;
	PatternPtr patterns;
	PatternPtr p;
	DIR *d;
	struct dirent *dp;
	regmatch_t match[2];
	struct stat stat_buf;
	int len, dirlen;
	char *fp;
	char **listing = NULL;
	char **save;
	int n = 0;
d518 11
a528 11
	if (!(pathlist = InitPathList(NULL)))
		return NULL;
	if (!(subdirs = InitSubdirs(subdirlist))) {
		FreePathList(pathlist);
		return NULL;
	}
	if (!(patterns = InitPatterns(patternlist))) {
		FreePathList(pathlist);
		FreeSubdirs(subdirs);
		return NULL;
	}
d530 31
a560 12
	for (elem = pathlist; *elem; elem++) {
		for (s = subdirs; *s; s++) {
			if ((dirlen = strlen(*elem) + strlen(*s)) > PATH_MAX)
				continue;
			strcpy(buf, *elem);
			strcat(buf, *s);
			fp = buf + dirlen;
			if (stat(buf, &stat_buf) == 0 && S_ISDIR(stat_buf.st_mode) &&
				(d = opendir(buf))) {
				if (buf[dirlen - 1] != '/') {
					buf[dirlen++] = '/';
					fp++;
d562 18
a579 41
				while ((dp = readdir(d))) {
					if (dirlen + strlen(dp->d_name) > PATH_MAX)
						continue;
					strcpy(fp, dp->d_name);
					if (!(stat(buf, &stat_buf) == 0 &&
						  S_ISREG(stat_buf.st_mode)))
						continue;
					for (p = patterns; p->pattern; p++) {
						if (regexec(&p->rex, dp->d_name, 2, match, 0) == 0 &&
							match[1].rm_so != -1) {
							len = match[1].rm_eo - match[1].rm_so;
							save = listing;
							listing = xrealloc(listing,
											   (n + 2) * sizeof(char *));
							if (!listing) {
								if (save) {
									save[n] = NULL;
									FreeStringList(save);
								}
								FreePathList(pathlist);
								FreeSubdirs(subdirs);
								FreePatterns(patterns);
								return NULL;
							}
							listing[n] = xalloc(len + 1);
							if (!listing[n]) {
								FreeStringList(listing);
								FreePathList(pathlist);
								FreeSubdirs(subdirs);
								FreePatterns(patterns);
								return NULL;
							}
							strncpy(listing[n], dp->d_name + match[1].rm_so,
									len);
							listing[n][len] = '\0';
							n++;
							break;
						}
					}
				}
				closedir(d);
d581 1
d583 2
d586 4
a589 3
	if (listing)
		listing[n] = NULL;
	return listing;
d595 1
a595 1
	FreeStringList(list);
a597 1

d599 2
a600 2
CheckVersion (const char *module, XF86ModuleVersionInfo *data,
				const XF86ModReqInfo *req)
d602 38
a639 38
	int vercode[4];
	char verstr[4];
	long ver = data->xf86version;
	int errtype = 0;

	xf86Msg (X_INFO, "Module %s: vendor=\"%s\"\n",
			data->modname ? data->modname : "UNKNOWN!",
			data->vendor ? data->vendor : "UNKNOWN!");

	if (ver > (4 << 24)) {
		/* 4.0.x and earlier */
		verstr[1] = verstr[3] = 0;
		verstr[2] = (ver & 0x1f) ? (ver & 0x1f) + 'a' - 1 : 0;
		ver >>= 5;
		verstr[0] = (ver & 0x1f) ? (ver & 0x1f) + 'A' - 1 : 0;
		ver >>= 5;
		vercode[2] = ver & 0x7f;
		ver >>= 7;
		vercode[1] = ver & 0x7f;
		ver >>= 7;
		vercode[0] = ver;
		xf86ErrorF("\tcompiled for %d.%d", vercode[0], vercode[1]);
		if (vercode[2] != 0)
			xf86ErrorF(".%d", vercode[2]);
		xf86ErrorF("%s%s, module version = %d.%d.%d\n", verstr, verstr + 2,
				data->majorversion, data->minorversion, data->patchlevel);
	} else {
		vercode[0] = ver / 10000000;
		vercode[1] = (ver / 100000) % 100;
		vercode[2] = (ver / 1000) % 100;
		vercode[3] = ver % 1000;
		xf86ErrorF("\tcompiled for %d.%d.%d", vercode[0], vercode[1],
					vercode[2]);
		if (vercode[3] != 0)
			xf86ErrorF(".%d", vercode[3]);
		xf86ErrorF(", module version = %d.%d.%d\n", data->majorversion,
					data->minorversion, data->patchlevel);
	}
d642 73
a714 48
		xf86ErrorFVerb(2, "\tModule class: %s\n", data->moduleclass);
		
	ver = -1;
	if (data->abiclass) {
		int abimaj, abimin;
		int vermaj, vermin;

		if (!strcmp(data->abiclass, ABI_CLASS_ANSIC))
			ver = LoaderVersionInfo.ansicVersion;
		else if (!strcmp(data->abiclass, ABI_CLASS_VIDEODRV))
			ver = LoaderVersionInfo.videodrvVersion;
		else if (!strcmp(data->abiclass, ABI_CLASS_XINPUT))
			ver = LoaderVersionInfo.xinputVersion;
		else if (!strcmp(data->abiclass, ABI_CLASS_EXTENSION))
			ver = LoaderVersionInfo.extensionVersion;
		else if (!strcmp(data->abiclass, ABI_CLASS_FONT))
			ver = LoaderVersionInfo.fontVersion;

		abimaj = GET_ABI_MAJOR(data->abiversion);
		abimin = GET_ABI_MINOR(data->abiversion);
		xf86ErrorFVerb(2, "\tABI class: %s, version %d.%d\n",
			       data->abiclass, abimaj, abimin);
		if (ver != -1) {
			vermaj = GET_ABI_MAJOR(ver);
			vermin = GET_ABI_MINOR(ver);
			if (abimaj != vermaj) {
				if (LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL)
					errtype = X_WARNING;
				else
					errtype = X_ERROR;
				xf86MsgVerb(errtype, 0,
					"module ABI major version (%d) doesn't"
					" match the server's version (%d)\n",
					abimaj, vermaj);
				if (!(LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL))
					return FALSE;
			} else if (abimin > vermin) {
				if (LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL)
					errtype = X_WARNING;
				else
					errtype = X_ERROR;
				xf86MsgVerb(errtype, 0,
					"module ABI minor version (%d) is "
					"newer than the server's version "
					"(%d)\n", abimin, vermin);
				if (!(LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL))
					return FALSE;
			}
d716 1
d718 38
a755 65

	/* Check against requirements that the caller has specified */
	if (req) {
		if (req->majorversion != MAJOR_UNSPEC) {
			if (data->majorversion != req->majorversion) {
				xf86MsgVerb(X_WARNING, 2, "module major version (%d) "
							"doesn't match required major version (%d)\n",
							data->majorversion, req->majorversion);
				return FALSE;
			} else if (req->minorversion != MINOR_UNSPEC) {
				if (data->minorversion < req->minorversion) {
					xf86MsgVerb(X_WARNING, 2, "module minor version (%d) "
							"is less than the required minor version (%d)\n",
							data->minorversion, req->minorversion);
					return FALSE;
				} else if (data->minorversion == req->minorversion &&
						   req->patchlevel != PATCH_UNSPEC) {
					if (data->patchlevel < req->patchlevel) {
						xf86MsgVerb(X_WARNING, 2, "module patch level (%d) "
								"is less than the required patch level (%d)\n",
								data->patchlevel, req->patchlevel);
						return FALSE;
					}
				}
			}
		}
		if (req->moduleclass) {
			if (!data->moduleclass ||
				strcmp(req->moduleclass, data->moduleclass)) {
				xf86MsgVerb(X_WARNING, 2, "Module class (%s) doesn't match "
							"the required class (%s)\n",
							data->moduleclass ? data->moduleclass : "<NONE>",
							req->moduleclass);
				return FALSE;
			}
		} else if (req->abiclass != ABI_CLASS_NONE) {
			if (!data->abiclass || strcmp(req->abiclass, data->moduleclass)) {
				xf86MsgVerb(X_WARNING, 2, "ABI class (%s) doesn't match the "
							"required ABI class (%s)\n",
							data->abiclass ? data->abiclass : "<NONE>",
							req->abiclass);
				return FALSE;
			}
		}
		if ((req->abiclass != ABI_CLASS_NONE) &&
			req->abiversion != ABI_VERS_UNSPEC) {
			int reqmaj, reqmin, maj, min;
			reqmaj = GET_ABI_MAJOR(req->abiversion);
			reqmin = GET_ABI_MINOR(req->abiversion);
			maj = GET_ABI_MAJOR(data->abiversion);
			min = GET_ABI_MINOR(data->abiversion);
			if (maj != reqmaj) {
				xf86MsgVerb(X_WARNING, 2, "ABI major version (%d) doesn't "
							"match the required ABI major version (%d)\n",
							maj, reqmaj);
				return FALSE;
			}
			/* XXX Maybe this should be the other way around? */
			if (min > reqmin) {
				xf86MsgVerb(X_WARNING, 2, "module ABI minor version (%d) "
							"is new than that available (%d)\n",
							min, reqmin);
				return FALSE;
			}
		}
d757 1
a757 1

d759 6
a764 9
	if (data->checksum)
	{
		/* verify the checksum field */
		/* TO BE DONE */
	}
	else
	{
		ErrorF ("\t*** Checksum field is 0 - this module is untrusted!\n");
	}
d772 1
a772 1
	      pointer options, const XF86ModReqInfo *modreq,
d775 1
a775 1
	ModuleDescPtr submod;
d777 1
a777 1
	xf86MsgVerb(X_INFO, 3, "Loading sub module \"%s\"\n", module);
d779 3
a781 3
	/* Absolute module paths are not allowed here */
#ifndef __EMX__
	if (module[0] == '/')
d783 1
a783 1
	if (isalpha (module[0]) && module[1] == ':' && module[2] == '/')
d785 10
a794 10
	{
		xf86Msg(X_ERROR,
				"LoadSubModule: Absolute module path not permitted: \"%s\"\n",
				module);
		if (errmaj)
			*errmaj = LDR_BADUSAGE;
		if (errmin)
			*errmin = 0;
		return NULL;
	}
d796 7
a802 7
	submod = LoadModule (module, NULL, subdirlist, patternlist, options,
						 modreq, errmaj, errmin);
	if (submod) {
		parent->child = AddSibling (parent->child, submod);
		submod->parent = parent;
	}
	return submod;
d808 1
a808 1
	ModuleDescPtr ret;
d810 2
a811 2
	if (!mod)
		return NULL;
d813 3
a815 3
	ret = NewModuleDesc(mod->name);
	if (ret == NULL)
		return NULL;
d817 2
a818 2
	if (LoaderHandleOpen(mod->handle) == -1)
		return NULL;
d820 13
a832 12
	ret->filename = xstrdup(mod->filename);
	ret->identifier = mod->identifier;
	ret->client_id = mod->client_id;
	ret->in_use = mod->in_use;
	ret->handle = mod->handle;
	ret->SetupProc = mod->SetupProc;
	ret->TearDownProc = mod->TearDownProc;
	ret->TearDownData = NULL;
	ret->path = mod->path;
	ret->child = DuplicateModule(mod->child, ret);
	ret->sib = DuplicateModule(mod->sib, parent);
	ret->parent = parent;
d834 1
a834 1
	return ret;
d876 65
a940 69
LoadModule (const char *module, const char *path, const char **subdirlist,
			const char **patternlist, pointer options,
			const XF86ModReqInfo * modreq,
			int *errmaj, int *errmin)
{
	XF86ModuleData *initdata = NULL;
	char **pathlist = NULL;
	char *found = NULL;
	char *name = NULL;
	char **path_elem = NULL;
	char *p = NULL;
	ModuleDescPtr ret = NULL;
	int wasLoaded = 0;
	PatternPtr patterns = NULL;
	int noncanonical = 0;
	char *m = NULL;

	/*xf86Msg(X_INFO,"OS2DIAG: LoadModule: %s\n",module);*/
	xf86MsgVerb(X_INFO, 3, "LoadModule: \"%s\"", module);

	patterns = InitPatterns(patternlist);
	name = LoaderGetCanonicalName(module, patterns);
	noncanonical = (name && strcmp(module, name) != 0);
	if (noncanonical)
	{
		xf86ErrorFVerb(3, " (%s)\n", name);
		xf86MsgVerb(X_WARNING, 1,
					"LoadModule: given non-canonical module name \"%s\"\n",
					module);
		m = name;
	}
	else
	{
		xf86ErrorFVerb(3, "\n");
		m = (char *)module;
	}
	if (!name) {
		if (errmaj)
			*errmaj = LDR_BADUSAGE;
		if (errmin)
			*errmin = 0;
		goto LoadModule_fail;
	}
	ret = NewModuleDesc (name);
	if (!ret) {
		if (errmaj)
			*errmaj = LDR_NOMEM;
		if (errmin)
			*errmin = 0;
		goto LoadModule_fail;
	}

	pathlist = InitPathList(path);
	if (!pathlist) {
		/* This could be a malloc failure too */
		if (errmaj)
			*errmaj = LDR_BADUSAGE;
		if (errmin)
			*errmin = 1;
		goto LoadModule_fail;
	}

	/* 
	 * if the module name is not a full pathname, we need to
	 * check the elements in the path
	 */
#ifndef __EMX__
	if (module[0] == '/')
		found = xstrdup(module);
d942 3
a944 3
	/* accept a drive name here */
	if (isalpha (module[0]) && module[1] == ':' && module[2] == '/')
		found = xstrdup(module);
d946 4
a949 35
	path_elem = pathlist;
	while (!found && *path_elem != NULL)
	{
		found = FindModule (m, *path_elem, subdirlist, patterns);
		path_elem++;
		/*
		 * When the module name isn't the canonical name, search for the
		 * former if no match was found for the latter.
		 */
		if (!*path_elem && m == name)
		{
			path_elem = pathlist;
			m = (char *)module;
		}
	}

	/* 
	 * did we find the module?
	 */
	if (!found)
	{
		xf86Msg (X_WARNING, "Warning, couldn't open module %s\n",
				module);
		if (errmaj)
			*errmaj = LDR_NOENT;
		if (errmin)
			*errmin = 0;
		goto LoadModule_fail;
	}
	ret->handle = LoaderOpen (found, name, 0, errmaj, errmin, &wasLoaded);
	if (ret->handle < 0)
		goto LoadModule_fail;

	ret->filename = xstrdup(found);

d951 2
a952 2
	 * now check if the special data object <modulename>ModuleData is
	 * present.
d954 53
a1006 5
	p = xalloc (strlen (name) + strlen ("ModuleData") + 1);
	if (!p) {
		if (errmaj)
			*errmaj = LDR_NOMEM;
		if (errmin)
d1008 1
a1008 34
		goto LoadModule_fail;
	}
	strcpy (p, name);
	strcat (p, "ModuleData");
	initdata = LoaderSymbol (p);
	if (initdata)
	{
		ModuleSetupProc setup;
		ModuleTearDownProc teardown;
		XF86ModuleVersionInfo *vers;

		vers = initdata->vers;
		setup = initdata->setup;
		teardown = initdata->teardown;

		if (!wasLoaded) {
			if (vers) {
				if (!CheckVersion (module, vers, modreq)) {
					if (errmaj)
						*errmaj = LDR_MISMATCH;
					if (errmin)
						*errmin = 0;
					goto LoadModule_fail;
				}
			} else {
				xf86Msg(X_ERROR,
					"LoadModule: Module %s does not supply"
					" version information\n", module);
				if (errmaj)
					*errmaj = LDR_INVALID;
				if (errmin)
					*errmin = 0;
				goto LoadModule_fail;
			}
d1010 4
a1013 15
		if (setup)
			ret->SetupProc = setup;
		if (teardown)
			ret->TearDownProc = teardown;
		ret->path = path;
	}
	else
	{
		/* No initdata is OK for external modules */
		if (options == EXTERN_MODULE)
			goto LoadModule_exit;

		/* no initdata, fail the load */
		xf86Msg (X_ERROR, "LoadModule: Module %s does not have a %s "
				"data object.\n", module, p);
d1015 1
a1015 1
			*errmaj = LDR_INVALID;
d1017 1
a1017 1
			*errmin = 0;
d1019 1
d1021 30
a1050 14
	if (ret->SetupProc)
	{
		ret->TearDownData = ret->SetupProc (ret, options, errmaj, errmin);
		if (!ret->TearDownData)
		{
			goto LoadModule_fail;
		}
	}
	else if (options)
	{
		xf86Msg (X_WARNING, "Module Options present, but no SetupProc "
				"available for %s\n", module);
	}
	goto LoadModule_exit;
d1053 2
a1054 2
	UnloadModule (ret);
	ret = NULL;
d1057 12
a1068 12
	FreePathList(pathlist);
	FreePatterns(patterns);
	TestFree (found);
	TestFree (name);
	TestFree (p);

	/*
	 * If you need to do something to keep the
	 * instruction cache in sync with the main
	 * memory before jumping to that code, you may
	 * do it here.
	 */
d1070 1
a1070 1
	istream_mem_barrier();
d1072 1
a1072 1
	return ret;
d1076 2
a1077 2
LoadDriver (const char *module, const char *path, int handle, pointer options,
	    int *errmaj, int *errmin)
d1079 2
a1080 1
return LoadModule (module, path, NULL, NULL, options, NULL, errmaj, errmin);
d1084 1
a1084 1
UnloadModule (ModuleDescPtr mod)
d1086 1
a1086 1
	UnloadModuleOrDriver (mod);
d1090 1
a1090 1
UnloadDriver (ModuleDescPtr mod)
d1092 1
a1092 1
	UnloadModuleOrDriver (mod);
d1096 1
a1096 1
UnloadModuleOrDriver (ModuleDescPtr mod)
d1104 2
a1105 2
        mod->TearDownProc (mod->TearDownData);
    LoaderUnload (mod->handle);
d1108 1
a1108 1
        UnloadModuleOrDriver (mod->child);
d1110 4
a1113 4
        UnloadModuleOrDriver (mod->sib);
    TestFree (mod->name);
    TestFree (mod->filename);
    xfree (mod);
d1115 1
a1115 1
	istream_mem_barrier();
d1128 2
a1129 2
        mod->TearDownProc (mod->TearDownData);
    LoaderUnload (mod->handle);
d1134 1
a1134 1
        UnloadModuleOrDriver (mod->child);
d1136 3
a1138 3
    TestFree (mod->name);
    TestFree (mod->filename);
    xfree (mod);
d1142 1
a1142 1
FreeModuleDesc (ModuleDescPtr head)
d1144 1
a1144 1
	ModuleDescPtr sibs, prev;
d1146 15
a1160 16
	/*
	 * only free it if it's not marked as in use. In use means that it may
	 * be unloaded someday, and UnloadModule or UnloadDriver will free it
	 */
	if (head->in_use)
		return;
	if (head->child)
		FreeModuleDesc (head->child);
	sibs = head;
	while (sibs)
	{
		prev = sibs;
		sibs = sibs->sib;
		TestFree (prev->name);
		xfree (prev);
	}
d1164 1
a1164 1
NewModuleDesc (const char *name)
d1166 1
a1166 1
	ModuleDescPtr mdp = xalloc (sizeof (ModuleDesc));
d1168 15
a1182 16
	if (mdp)
	{
		mdp->child = NULL;
		mdp->sib = NULL;
		mdp->parent = NULL;
		mdp->demand_next = NULL;
		mdp->name = xstrdup (name);
		mdp->filename = NULL;
		mdp->identifier = NULL;
		mdp->client_id = 0;
		mdp->in_use = 0;
		mdp->handle = -1;
		mdp->SetupProc = NULL;
		mdp->TearDownProc = NULL;
		mdp->TearDownData = NULL;
	}
d1184 1
a1184 1
	return (mdp);
d1188 1
a1188 1
AddSibling (ModuleDescPtr head, ModuleDescPtr new)
d1196 1
a1196 1
RemoveChild (ModuleDescPtr child)
d1198 6
a1203 12
	ModuleDescPtr mdp;
	ModuleDescPtr prevsib;
	ModuleDescPtr parent;

	if (!child->parent)
		return;

	parent = child->parent;
	if (parent->child == child) {
		parent->child = child->sib;
		return;
	}
d1205 3
a1207 8
	prevsib = parent->child;
	mdp = prevsib->sib;
	while (mdp && mdp != child) {
		prevsib = mdp;
		mdp = mdp->sib;
	}
	if (mdp == child)
		prevsib->sib = child->sib;
d1209 11
d1225 1
a1225 1
	const char *msg;
d1227 58
a1284 58
	switch (errmaj) {
	case LDR_NOERROR:
		msg = "no error";
		break;
	case LDR_NOMEM:
		msg = "out of memory";
		break;
	case LDR_NOENT:
		msg = "module does not exist";
		break;
	case LDR_NOSUBENT:
		msg = "a required submodule could not be loaded";
		break;
	case LDR_NOSPACE:
		msg = "too many modules";
		break;
	case LDR_NOMODOPEN:
		msg = "open failed";
		break;
	case LDR_UNKTYPE:
		msg = "unknown module type";
		break;
	case LDR_NOLOAD:
		msg = "loader failed";
		break;
	case LDR_ONCEONLY:
		msg = "once-only module";
		break;
	case LDR_NOPORTOPEN:
		msg = "port open failed";
		break;
	case LDR_NOHARDWARE:
		msg = "no hardware found";
		break;
	case LDR_MISMATCH:
		msg = "module requirement mismatch";
		break;
	case LDR_BADUSAGE:
		msg = "invalid argument(s) to LoadModule()";
		break;
	case LDR_INVALID:
		msg = "invalid module";
		break;
	case LDR_BADOS:
		msg = "module doesn't support this OS";
		break;
	case LDR_MODSPECIFIC:
		msg = "module-specific error";
		break;
	default:
		msg = "uknown error";
	}
	if (name)
		xf86Msg(X_ERROR, "%s: Failed to load module \"%s\" (%s, %d)\n",
			name, modname, msg, errmin);
	else
		xf86Msg(X_ERROR, "Failed to load module \"%s\" (%s, %d)\n",
			modname, msg, errmin);
a1286 1

d1291 37
a1327 25
	char *str;
	const char *s;
	int len;
	PatternPtr p;
	regmatch_t match[2];

	/* Strip off any leading path */
	s = strrchr(modname, '/');
	if (s == NULL)
		s = modname;
	else
		s++;

	/* Find the first regex that is matched */
	for (p = patterns; p->pattern; p++)
		if (regexec(&p->rex, s, 2, match, 0) == 0 &&
			match[1].rm_so != -1) {
			len = match[1].rm_eo - match[1].rm_so;
			str = xalloc(len + 1);
			if (!str)
				return NULL;
			strncpy(str, s + match[1].rm_so, len);
			str[len] = '\0';
			return str;
		}
d1329 3
a1331 2
	/* If there is no match, return the whole name minus the leading path */
	return xstrdup(s);
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/loadmod.c,v 1.73 2003/11/03 05:11:51 tsi Exp $ */
d25 2
a26 26
/*
 * Copyright (c) 1997-2002 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */
d51 2
a52 2
    const char *pattern;
    regex_t rex;
d56 4
a59 5
static char *FindModule(const char *, const char *, const char **,
			PatternPtr);
static Bool CheckVersion(const char *, XF86ModuleVersionInfo *,
			 const XF86ModReqInfo *);
static void UnloadModuleOrDriver(ModuleDescPtr mod);
d64 6
a69 6
    XF86_VERSION_CURRENT,
    ABI_ANSIC_VERSION,
    ABI_VIDEODRV_VERSION,
    ABI_XINPUT_VERSION,
    ABI_EXTENSION_VERSION,
    ABI_FONT_VERSION
d74 1
a74 1
LoaderFixups(void)
d76 2
a77 2
    /* Need to call LRS here because the frame buffers get loaded last,
     * and the drivers depend on them. */
d79 1
a79 1
    LoaderResolveSymbols();
d86 1
a86 1
    char **p;
d88 2
a89 2
    if (!paths)
	return;
d91 2
a92 2
    for (p = paths; *p; p++)
	xfree(*p);
d94 1
a94 1
    xfree(paths);
d107 6
a112 6
    char *fullpath = NULL;
    char *elem = NULL;
    char **list = NULL, **save = NULL;
    int len;
    int addslash;
    int n = 0;
d114 2
a115 2
    if (!path)
	return defaultPathList;
d117 8
a124 8
    fullpath = xstrdup(path);
    if (!fullpath)
	return NULL;
    elem = strtok(fullpath, ",");
    while (elem) {
	/* Only allow fully specified paths */
#ifndef __UNIXOS2__
	if (*elem == '/')
d126 2
a127 2
	if (*elem == '/' || (strlen(elem) > 2 && isalpha(elem[0]) &&
			     elem[1] == ':' && elem[2] == '/'))
d129 27
a155 11
	{
	    len = strlen(elem);
	    addslash = (elem[len - 1] != '/');
	    if (addslash)
		len++;
	    save = list;
	    list = xrealloc(list, (n + 2) * sizeof(char *));
	    if (!list) {
		if (save) {
		    save[n] = NULL;
		    FreeStringList(save);
d157 5
a161 21
		xfree(fullpath);
		return NULL;
	    }
	    list[n] = xalloc(len + 1);
	    if (!list[n]) {
		FreeStringList(list);
		xfree(fullpath);
		return NULL;
	    }
	    strcpy(list[n], elem);
	    if (addslash) {
		list[n][len - 1] = '/';
		list[n][len] = '\0';
	    }
	    n++;
	}
	elem = strtok(NULL, ",");
    }
    if (list)
	list[n] = NULL;
    return list;
d167 2
a168 2
    if (pathlist && pathlist != defaultPathList)
	FreeStringList(pathlist);
d174 2
a175 2
    if (!path)
	return;
d177 1
a177 1
    defaultPathList = InitPathList(path);
d181 10
a190 9
static const char *stdSubdirs[] = {
    "drivers/",
    "input/",
    "multimedia/",
    "extensions/",
    "fonts/",
    "internal/",
    "",
    NULL
d198 8
a205 8
    {"^lib(.*)\\.so$",},
    {"^lib(.*)\\.a$",},
    {"(.*)_drv\\.so$",},
    {"(.*)_drv\\.o$",},
    {"(.*)\\.so$",},
    {"(.*)\\.a$",},
    {"(.*)\\.o$",},
    {NULL,}
d211 25
a235 35
    char errmsg[80];
    int i, e;
    PatternPtr patterns = NULL;
    PatternPtr p = NULL;
    static int firstTime = 1;
    const char **s;

    if (firstTime) {
	/* precompile stdPatterns */
	firstTime = 0;
	for (p = stdPatterns; p->pattern; p++)
	    if ((e = regcomp(&p->rex, p->pattern, REG_EXTENDED)) != 0) {
		regerror(e, &p->rex, errmsg, sizeof(errmsg));
		FatalError("InitPatterns: regcomp error for `%s': %s\n",
			   p->pattern, errmsg);
	    }
    }

    if (patternlist) {
	for (i = 0, s = patternlist; *s; i++, s++)
	    if (*s == DEFAULT_LIST)
		i += sizeof(stdPatterns) / sizeof(stdPatterns[0]) - 1 - 1;
	patterns = xalloc((i + 1) * sizeof(PatternRec));
	if (!patterns) {
	    return NULL;
	}
	for (i = 0, s = patternlist; *s; i++, s++)
	    if (*s != DEFAULT_LIST) {
		p = patterns + i;
		p->pattern = *s;
		if ((e = regcomp(&p->rex, p->pattern, REG_EXTENDED)) != 0) {
		    regerror(e, &p->rex, errmsg, sizeof(errmsg));
		    ErrorF("InitPatterns: regcomp error for `%s': %s\n",
			   p->pattern, errmsg);
		    i--;
d237 20
a256 10
	    } else {
		for (p = stdPatterns; p->pattern; p++, i++)
		    patterns[i] = *p;
		if (p != stdPatterns)
		    i--;
	    }
	patterns[i].pattern = NULL;
    } else
	patterns = stdPatterns;
    return patterns;
d262 2
a263 2
    if (patterns && patterns != stdPatterns)
	xfree(patterns);
d269 3
a271 4
    int i;
    const char **tmp_subdirlist = NULL;
    char **subdirs = NULL;
    const char **s, **stmp = NULL;
d278 7
a284 7
	subdirlist = tmp_subdirlist = xalloc(2 * sizeof(char *));
	if (subdirlist == NULL)
	    return NULL;
	subdirlist[0] = DEFAULT_LIST;
	subdirlist[1] = NULL;
    }

d289 17
a305 17
	/* Count number of entries and check for invalid paths */
	for (i = 0, s = subdirlist; *s; i++, s++) {
	    if (*s == DEFAULT_LIST) {
		i += sizeof(stdSubdirs) / sizeof(stdSubdirs[0]) - 1 - 1;
	    } else {
		/*
		 * Path validity check.  Don't allow absolute paths, or
		 * paths containing "..".  To catch absolute paths on
		 * platforms that use driver letters, don't allow the ':'
		 * character to appear at all.
		 */
		if (**s == '/' || **s == '\\' || strchr(*s, ':') ||
		    strstr(*s, "..")) {
		    xf86Msg(X_ERROR, "InitSubdirs: Bad subdir: \"%s\"\n", *s);
		    if (tmp_subdirlist)
			xfree(tmp_subdirlist);
		    return NULL;
d307 5
a311 42
	    }
	}
	subdirs = xalloc((i * 2 + 1) * sizeof(char *));
	if (!subdirs) {
	    if (tmp_subdirlist)
		xfree(tmp_subdirlist);
	    return NULL;
	}
	i = 0;
	s = subdirlist;
	indefault = FALSE;
	while (*s) {
	    if (*s == DEFAULT_LIST) {
		/* Divert to the default list */
		indefault = TRUE;
		stmp = ++s;
		s = stdSubdirs;
	    }
	    len = strlen(*s);
	    if (**s && (*s)[len - 1] != '/') {
		slash = "/";
		len++;
	    } else
		slash = "";
	    len += oslen + 2;
	    if (!(subdirs[i] = xalloc(len))) {
		while (--i >= 0)
		    xfree(subdirs[i]);
		xfree(subdirs);
		if (tmp_subdirlist)
		    xfree(tmp_subdirlist);
		return NULL;
	    }
	    /* tack on the OS name */
	    sprintf(subdirs[i], "%s%s%s/", *s, slash, osname);
	    i++;
	    /* path as given */
	    subdirs[i] = xstrdup(*s);
	    i++;
	    s++;
	    if (indefault && !s) {
		/* revert back to the main list */
d313 30
a342 2
		s = stmp;
	    }
d344 1
a344 5
	subdirs[i] = NULL;
    }
    if (tmp_subdirlist)
	xfree(tmp_subdirlist);
    return (const char **)subdirs;
d350 1
a350 1
    const char **s;
d352 5
a356 5
    if (subdirs) {
	for (s = subdirs; *s; s++)
	    xfree(*s);
	xfree(subdirs);
    }
d360 2
a361 2
FindModule(const char *module, const char *dir, const char **subdirlist,
	   PatternPtr patterns)
d363 12
a374 12
    char buf[PATH_MAX + 1];
    char *dirpath = NULL;
    char *name = NULL;
    struct stat stat_buf;
    int len, dirlen;
    char *fp;
    DIR *d;
    const char **subdirs = NULL;
    PatternPtr p = NULL;
    const char **s;
    struct dirent *dp;
    regmatch_t match[2];
d376 3
a378 3
    subdirs = InitSubdirs(subdirlist);
    if (!subdirs)
	return NULL;
d381 1
a381 1
    dirpath = (char *)dir;
d383 2
a384 2
    dirpath = xalloc(strlen(dir) + 10);
    strcpy(dirpath, (char *)__XOS2RedirRoot(dir));
d386 3
a388 3
    if (strlen(dirpath) > PATH_MAX)
	return NULL;
    /*xf86Msg(X_INFO,"OS2DIAG: FindModule: dirpath=%s\n",dirpath); */
d390 33
a422 29
    for (s = subdirs; *s; s++) {
	if ((dirlen = strlen(dirpath) + strlen(*s)) > PATH_MAX)
	    continue;
	strcpy(buf, dirpath);
	strcat(buf, *s);
	/*xf86Msg(X_INFO,"OS2DIAG: FindModule: buf=%s\n",buf); */
	fp = buf + dirlen;
	if (stat(buf, &stat_buf) == 0 && S_ISDIR(stat_buf.st_mode) &&
	    (d = opendir(buf))) {
	    if (buf[dirlen - 1] != '/') {
		buf[dirlen++] = '/';
		fp++;
	    }
	    while ((dp = readdir(d))) {
		if (dirlen + strlen(dp->d_name) + 1 > PATH_MAX)
		    continue;
		strcpy(fp, dp->d_name);
		if (!(stat(buf, &stat_buf) == 0 && S_ISREG(stat_buf.st_mode)))
		    continue;
		for (p = patterns; p->pattern; p++) {
		    if (regexec(&p->rex, dp->d_name, 2, match, 0) == 0 &&
			match[1].rm_so != -1) {
			len = match[1].rm_eo - match[1].rm_so;
			if (len == strlen(module) &&
			    strncmp(module, dp->d_name + match[1].rm_so,
				    len) == 0) {
			    /*xf86Msg(X_INFO,"OS2DIAG: matching %s\n",buf); */
			    name = buf;
			    break;
d424 3
a426 1
		    }
a427 6
		if (name)
		    break;
	    }
	    closedir(d);
	    if (name)
		break;
d429 8
a436 9
    }
    FreeSubdirs(subdirs);
    if (dirpath != dir)
	xfree(dirpath);

    if (name) {
	return xstrdup(name);
    }
    return NULL;
d442 16
a457 16
    char buf[PATH_MAX + 1];
    char **pathlist;
    char **elem;
    const char **subdirs;
    const char **s;
    PatternPtr patterns;
    PatternPtr p;
    DIR *d;
    struct dirent *dp;
    regmatch_t match[2];
    struct stat stat_buf;
    int len, dirlen;
    char *fp;
    char **listing = NULL;
    char **save;
    int n = 0;
d459 11
a469 11
    if (!(pathlist = InitPathList(NULL)))
	return NULL;
    if (!(subdirs = InitSubdirs(subdirlist))) {
	FreePathList(pathlist);
	return NULL;
    }
    if (!(patterns = InitPatterns(patternlist))) {
	FreePathList(pathlist);
	FreeSubdirs(subdirs);
	return NULL;
    }
d471 52
a522 31
    for (elem = pathlist; *elem; elem++) {
	for (s = subdirs; *s; s++) {
	    if ((dirlen = strlen(*elem) + strlen(*s)) > PATH_MAX)
		continue;
	    strcpy(buf, *elem);
	    strcat(buf, *s);
	    fp = buf + dirlen;
	    if (stat(buf, &stat_buf) == 0 && S_ISDIR(stat_buf.st_mode) &&
		(d = opendir(buf))) {
		if (buf[dirlen - 1] != '/') {
		    buf[dirlen++] = '/';
		    fp++;
		}
		while ((dp = readdir(d))) {
		    if (dirlen + strlen(dp->d_name) > PATH_MAX)
			continue;
		    strcpy(fp, dp->d_name);
		    if (!(stat(buf, &stat_buf) == 0 &&
			  S_ISREG(stat_buf.st_mode)))
			continue;
		    for (p = patterns; p->pattern; p++) {
			if (regexec(&p->rex, dp->d_name, 2, match, 0) == 0 &&
			    match[1].rm_so != -1) {
			    len = match[1].rm_eo - match[1].rm_so;
			    save = listing;
			    listing = xrealloc(listing,
					       (n + 2) * sizeof(char *));
			    if (!listing) {
				if (save) {
				    save[n] = NULL;
				    FreeStringList(save);
d524 1
a524 18
				FreePathList(pathlist);
				FreeSubdirs(subdirs);
				FreePatterns(patterns);
				return NULL;
			    }
			    listing[n] = xalloc(len + 1);
			    if (!listing[n]) {
				FreeStringList(listing);
				FreePathList(pathlist);
				FreeSubdirs(subdirs);
				FreePatterns(patterns);
				return NULL;
			    }
			    strncpy(listing[n], dp->d_name + match[1].rm_so,
				    len);
			    listing[n][len] = '\0';
			    n++;
			    break;
a525 1
		    }
a526 2
		closedir(d);
	    }
d528 3
a530 4
    }
    if (listing)
	listing[n] = NULL;
    return listing;
d536 1
a536 1
    FreeStringList(list);
d539 1
d541 2
a542 2
CheckVersion(const char *module, XF86ModuleVersionInfo * data,
	     const XF86ModReqInfo * req)
d544 38
a581 38
    int vercode[4];
    char verstr[4];
    long ver = data->xf86version;
    MessageType errtype;

    xf86Msg(X_INFO, "Module %s: vendor=\"%s\"\n",
	    data->modname ? data->modname : "UNKNOWN!",
	    data->vendor ? data->vendor : "UNKNOWN!");

    if (ver > (4 << 24)) {
	/* 4.0.x and earlier */
	verstr[1] = verstr[3] = 0;
	verstr[2] = (ver & 0x1f) ? (ver & 0x1f) + 'a' - 1 : 0;
	ver >>= 5;
	verstr[0] = (ver & 0x1f) ? (ver & 0x1f) + 'A' - 1 : 0;
	ver >>= 5;
	vercode[2] = ver & 0x7f;
	ver >>= 7;
	vercode[1] = ver & 0x7f;
	ver >>= 7;
	vercode[0] = ver;
	xf86ErrorF("\tcompiled for %d.%d", vercode[0], vercode[1]);
	if (vercode[2] != 0)
	    xf86ErrorF(".%d", vercode[2]);
	xf86ErrorF("%s%s, module version = %d.%d.%d\n", verstr, verstr + 2,
		   data->majorversion, data->minorversion, data->patchlevel);
    } else {
	vercode[0] = ver / 10000000;
	vercode[1] = (ver / 100000) % 100;
	vercode[2] = (ver / 1000) % 100;
	vercode[3] = ver % 1000;
	xf86ErrorF("\tcompiled for %d.%d.%d", vercode[0], vercode[1],
		   vercode[2]);
	if (vercode[3] != 0)
	    xf86ErrorF(".%d", vercode[3]);
	xf86ErrorF(", module version = %d.%d.%d\n", data->majorversion,
		   data->minorversion, data->patchlevel);
    }
d584 50
a633 1
	xf86ErrorFVerb(2, "\tModule class: %s\n", data->moduleclass);
d635 42
a676 71
    ver = -1;
    if (data->abiclass) {
	int abimaj, abimin;
	int vermaj, vermin;

	if (!strcmp(data->abiclass, ABI_CLASS_ANSIC))
	    ver = LoaderVersionInfo.ansicVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_VIDEODRV))
	    ver = LoaderVersionInfo.videodrvVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_XINPUT))
	    ver = LoaderVersionInfo.xinputVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_EXTENSION))
	    ver = LoaderVersionInfo.extensionVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_FONT))
	    ver = LoaderVersionInfo.fontVersion;

	abimaj = GET_ABI_MAJOR(data->abiversion);
	abimin = GET_ABI_MINOR(data->abiversion);
	xf86ErrorFVerb(2, "\tABI class: %s, version %d.%d\n",
		       data->abiclass, abimaj, abimin);
	if (ver != -1) {
	    vermaj = GET_ABI_MAJOR(ver);
	    vermin = GET_ABI_MINOR(ver);
	    if (abimaj != vermaj) {
		if (LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL)
		    errtype = X_WARNING;
		else
		    errtype = X_ERROR;
		xf86MsgVerb(errtype, 0,
			    "module ABI major version (%d) doesn't"
			    " match the server's version (%d)\n",
			    abimaj, vermaj);
		if (!(LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL))
		    return FALSE;
	    } else if (abimin > vermin) {
		if (LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL)
		    errtype = X_WARNING;
		else
		    errtype = X_ERROR;
		xf86MsgVerb(errtype, 0,
			    "module ABI minor version (%d) is "
			    "newer than the server's version "
			    "(%d)\n", abimin, vermin);
		if (!(LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL))
		    return FALSE;
	    }
	}
    }

    /* Check against requirements that the caller has specified */
    if (req) {
	if (req->majorversion != MAJOR_UNSPEC) {
	    if (data->majorversion != req->majorversion) {
		xf86MsgVerb(X_WARNING, 2, "module major version (%d) "
			    "doesn't match required major version (%d)\n",
			    data->majorversion, req->majorversion);
		return FALSE;
	    } else if (req->minorversion != MINOR_UNSPEC) {
		if (data->minorversion < req->minorversion) {
		    xf86MsgVerb(X_WARNING, 2, "module minor version (%d) "
				"is less than the required minor version (%d)\n",
				data->minorversion, req->minorversion);
		    return FALSE;
		} else if (data->minorversion == req->minorversion &&
			   req->patchlevel != PATCH_UNSPEC) {
		    if (data->patchlevel < req->patchlevel) {
			xf86MsgVerb(X_WARNING, 2, "module patch level (%d) "
				    "is less than the required patch level (%d)\n",
				    data->patchlevel, req->patchlevel);
			return FALSE;
		    }
d678 28
a705 1
	    }
d707 3
a709 38
	if (req->moduleclass) {
	    if (!data->moduleclass ||
		strcmp(req->moduleclass, data->moduleclass)) {
		xf86MsgVerb(X_WARNING, 2, "Module class (%s) doesn't match "
			    "the required class (%s)\n",
			    data->moduleclass ? data->moduleclass : "<NONE>",
			    req->moduleclass);
		return FALSE;
	    }
	} else if (req->abiclass != ABI_CLASS_NONE) {
	    if (!data->abiclass || strcmp(req->abiclass, data->moduleclass)) {
		xf86MsgVerb(X_WARNING, 2, "ABI class (%s) doesn't match the "
			    "required ABI class (%s)\n",
			    data->abiclass ? data->abiclass : "<NONE>",
			    req->abiclass);
		return FALSE;
	    }
	}
	if ((req->abiclass != ABI_CLASS_NONE) &&
	    req->abiversion != ABI_VERS_UNSPEC) {
	    int reqmaj, reqmin, maj, min;

	    reqmaj = GET_ABI_MAJOR(req->abiversion);
	    reqmin = GET_ABI_MINOR(req->abiversion);
	    maj = GET_ABI_MAJOR(data->abiversion);
	    min = GET_ABI_MINOR(data->abiversion);
	    if (maj != reqmaj) {
		xf86MsgVerb(X_WARNING, 2, "ABI major version (%d) doesn't "
			    "match the required ABI major version (%d)\n",
			    maj, reqmaj);
		return FALSE;
	    }
	    /* XXX Maybe this should be the other way around? */
	    if (min > reqmin) {
		xf86MsgVerb(X_WARNING, 2, "module ABI minor version (%d) "
			    "is new than that available (%d)\n", min, reqmin);
		return FALSE;
	    }
a710 8
    }
#ifdef NOTYET
    if (data->checksum) {
	/* verify the checksum field */
	/* TO BE DONE */
    } else {
	ErrorF("\t*** Checksum field is 0 - this module is untrusted!\n");
    }
d718 1
a718 1
	      pointer options, const XF86ModReqInfo * modreq,
d721 1
a721 1
    ModuleDescPtr submod;
d723 1
a723 1
    xf86MsgVerb(X_INFO, 3, "Loading sub module \"%s\"\n", module);
d725 3
a727 3
    /* Absolute module paths are not allowed here */
#ifndef __UNIXOS2__
    if (module[0] == '/')
d729 1
a729 1
    if (isalpha(module[0]) && module[1] == ':' && module[2] == '/')
d731 10
a740 10
    {
	xf86Msg(X_ERROR,
		"LoadSubModule: Absolute module path not permitted: \"%s\"\n",
		module);
	if (errmaj)
	    *errmaj = LDR_BADUSAGE;
	if (errmin)
	    *errmin = 0;
	return NULL;
    }
d742 7
a748 7
    submod = LoadModule(module, NULL, subdirlist, patternlist, options,
			modreq, errmaj, errmin);
    if (submod) {
	parent->child = AddSibling(parent->child, submod);
	submod->parent = parent;
    }
    return submod;
d754 1
a754 1
    ModuleDescPtr ret;
d756 2
a757 2
    if (!mod)
	return NULL;
d759 3
a761 3
    ret = NewModuleDesc(mod->name);
    if (ret == NULL)
	return NULL;
d763 2
a764 2
    if (LoaderHandleOpen(mod->handle) == -1)
	return NULL;
d766 12
a777 13
    ret->filename = xstrdup(mod->filename);
    ret->identifier = mod->identifier;
    ret->client_id = mod->client_id;
    ret->in_use = mod->in_use;
    ret->handle = mod->handle;
    ret->SetupProc = mod->SetupProc;
    ret->TearDownProc = mod->TearDownProc;
    ret->TearDownData = NULL;
    ret->path = mod->path;
    ret->child = DuplicateModule(mod->child, ret);
    ret->sib = DuplicateModule(mod->sib, parent);
    ret->parent = parent;
    ret->VersionInfo = mod->VersionInfo;
d779 1
a779 1
    return ret;
d821 69
a889 65
LoadModule(const char *module, const char *path, const char **subdirlist,
	   const char **patternlist, pointer options,
	   const XF86ModReqInfo * modreq, int *errmaj, int *errmin)
{
    XF86ModuleData *initdata = NULL;
    char **pathlist = NULL;
    char *found = NULL;
    char *name = NULL;
    char **path_elem = NULL;
    char *p = NULL;
    ModuleDescPtr ret = NULL;
    int wasLoaded = 0;
    PatternPtr patterns = NULL;
    int noncanonical = 0;
    char *m = NULL;

    /*xf86Msg(X_INFO,"OS2DIAG: LoadModule: %s\n",module); */
    xf86MsgVerb(X_INFO, 3, "LoadModule: \"%s\"", module);

    patterns = InitPatterns(patternlist);
    name = LoaderGetCanonicalName(module, patterns);
    noncanonical = (name && strcmp(module, name) != 0);
    if (noncanonical) {
	xf86ErrorFVerb(3, " (%s)\n", name);
	xf86MsgVerb(X_WARNING, 1,
		    "LoadModule: given non-canonical module name \"%s\"\n",
		    module);
	m = name;
    } else {
	xf86ErrorFVerb(3, "\n");
	m = (char *)module;
    }
    if (!name) {
	if (errmaj)
	    *errmaj = LDR_BADUSAGE;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
    }
    ret = NewModuleDesc(name);
    if (!ret) {
	if (errmaj)
	    *errmaj = LDR_NOMEM;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
    }

    pathlist = InitPathList(path);
    if (!pathlist) {
	/* This could be a malloc failure too */
	if (errmaj)
	    *errmaj = LDR_BADUSAGE;
	if (errmin)
	    *errmin = 1;
	goto LoadModule_fail;
    }

    /* 
     * if the module name is not a full pathname, we need to
     * check the elements in the path
     */
#ifndef __UNIXOS2__
    if (module[0] == '/')
	found = xstrdup(module);
d891 3
a893 3
    /* accept a drive name here */
    if (isalpha(module[0]) && module[1] == ':' && module[2] == '/')
	found = xstrdup(module);
d895 35
a929 4
    path_elem = pathlist;
    while (!found && *path_elem != NULL) {
	found = FindModule(m, *path_elem, subdirlist, patterns);
	path_elem++;
d931 2
a932 2
	 * When the module name isn't the canonical name, search for the
	 * former if no match was found for the latter.
d934 5
a938 53
	if (!*path_elem && m == name) {
	    path_elem = pathlist;
	    m = (char *)module;
	}
    }

    /* 
     * did we find the module?
     */
    if (!found) {
	xf86Msg(X_WARNING, "Warning, couldn't open module %s\n", module);
	if (errmaj)
	    *errmaj = LDR_NOENT;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
    }
    ret->handle = LoaderOpen(found, name, 0, errmaj, errmin, &wasLoaded);
    if (ret->handle < 0)
	goto LoadModule_fail;

    ret->filename = xstrdup(found);

    /*
     * now check if the special data object <modulename>ModuleData is
     * present.
     */
    p = xalloc(strlen(name) + strlen("ModuleData") + 1);
    if (!p) {
	if (errmaj)
	    *errmaj = LDR_NOMEM;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
    }
    strcpy(p, name);
    strcat(p, "ModuleData");
    initdata = LoaderSymbol(p);
    if (initdata) {
	ModuleSetupProc setup;
	ModuleTearDownProc teardown;
	XF86ModuleVersionInfo *vers;

	vers = initdata->vers;
	setup = initdata->setup;
	teardown = initdata->teardown;

	if (!wasLoaded) {
	    if (vers) {
		if (!CheckVersion(module, vers, modreq)) {
		    if (errmaj)
			*errmaj = LDR_MISMATCH;
		    if (errmin)
d940 34
a973 1
		    goto LoadModule_fail;
d975 15
a989 4
	    } else {
		xf86Msg(X_ERROR,
			"LoadModule: Module %s does not supply"
			" version information\n", module);
d991 1
a991 1
		    *errmaj = LDR_INVALID;
d993 1
a993 1
		    *errmin = 0;
a994 1
	    }
d996 14
a1009 30
	if (setup)
	    ret->SetupProc = setup;
	if (teardown)
	    ret->TearDownProc = teardown;
	ret->path = path;
	ret->VersionInfo = vers;
    } else {
	/* No initdata is OK for external modules */
	if (options == EXTERN_MODULE)
	    goto LoadModule_exit;

	/* no initdata, fail the load */
	xf86Msg(X_ERROR, "LoadModule: Module %s does not have a %s "
		"data object.\n", module, p);
	if (errmaj)
	    *errmaj = LDR_INVALID;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
    }
    if (ret->SetupProc) {
	ret->TearDownData = ret->SetupProc(ret, options, errmaj, errmin);
	if (!ret->TearDownData) {
	    goto LoadModule_fail;
	}
    } else if (options) {
	xf86Msg(X_WARNING, "Module Options present, but no SetupProc "
		"available for %s\n", module);
    }
    goto LoadModule_exit;
d1012 2
a1013 2
    UnloadModule(ret);
    ret = NULL;
d1016 12
a1027 12
    FreePathList(pathlist);
    FreePatterns(patterns);
    TestFree(found);
    TestFree(name);
    TestFree(p);

    /*
     * If you need to do something to keep the
     * instruction cache in sync with the main
     * memory before jumping to that code, you may
     * do it here.
     */
d1029 1
a1029 1
    istream_mem_barrier();
d1031 1
a1031 1
    return ret;
d1035 2
a1036 2
LoadDriver(const char *module, const char *path, int handle, pointer options,
	   int *errmaj, int *errmin)
d1038 1
a1038 2
    return LoadModule(module, path, NULL, NULL, options, NULL, errmaj,
		      errmin);
d1042 1
a1042 1
UnloadModule(ModuleDescPtr mod)
d1044 1
a1044 1
    UnloadModuleOrDriver(mod);
d1048 1
a1048 1
UnloadDriver(ModuleDescPtr mod)
d1050 1
a1050 1
    UnloadModuleOrDriver(mod);
d1054 1
a1054 1
UnloadModuleOrDriver(ModuleDescPtr mod)
d1062 2
a1063 2
	mod->TearDownProc(mod->TearDownData);
    LoaderUnload(mod->handle);
d1066 1
a1066 1
	UnloadModuleOrDriver(mod->child);
d1068 4
a1071 4
	UnloadModuleOrDriver(mod->sib);
    TestFree(mod->name);
    TestFree(mod->filename);
    xfree(mod);
d1073 1
a1073 1
    istream_mem_barrier();
d1086 2
a1087 2
	mod->TearDownProc(mod->TearDownData);
    LoaderUnload(mod->handle);
d1092 1
a1092 1
	UnloadModuleOrDriver(mod->child);
d1094 3
a1096 3
    TestFree(mod->name);
    TestFree(mod->filename);
    xfree(mod);
d1100 1
a1100 1
FreeModuleDesc(ModuleDescPtr head)
d1102 1
a1102 1
    ModuleDescPtr sibs, prev;
d1104 16
a1119 15
    /*
     * only free it if it's not marked as in use. In use means that it may
     * be unloaded someday, and UnloadModule or UnloadDriver will free it
     */
    if (head->in_use)
	return;
    if (head->child)
	FreeModuleDesc(head->child);
    sibs = head;
    while (sibs) {
	prev = sibs;
	sibs = sibs->sib;
	TestFree(prev->name);
	xfree(prev);
    }
d1123 1
a1123 1
NewModuleDesc(const char *name)
d1125 1
a1125 1
    ModuleDescPtr mdp = xalloc(sizeof(ModuleDesc));
d1127 16
a1142 15
    if (mdp) {
	mdp->child = NULL;
	mdp->sib = NULL;
	mdp->parent = NULL;
	mdp->demand_next = NULL;
	mdp->name = xstrdup(name);
	mdp->filename = NULL;
	mdp->identifier = NULL;
	mdp->client_id = 0;
	mdp->in_use = 0;
	mdp->handle = -1;
	mdp->SetupProc = NULL;
	mdp->TearDownProc = NULL;
	mdp->TearDownData = NULL;
    }
d1144 1
a1144 1
    return (mdp);
d1148 1
a1148 1
AddSibling(ModuleDescPtr head, ModuleDescPtr new)
d1156 1
a1156 1
RemoveChild(ModuleDescPtr child)
d1158 12
a1169 3
    ModuleDescPtr mdp;
    ModuleDescPtr prevsib;
    ModuleDescPtr parent;
d1171 8
a1178 1
    if (!child->parent)
a1179 16

    parent = child->parent;
    if (parent->child == child) {
	parent->child = child->sib;
	return;
    }

    prevsib = parent->child;
    mdp = prevsib->sib;
    while (mdp && mdp != child) {
	prevsib = mdp;
	mdp = mdp->sib;
    }
    if (mdp == child)
	prevsib->sib = child->sib;
    return;
d1185 1
a1185 1
    const char *msg;
d1187 58
a1244 58
    switch (errmaj) {
    case LDR_NOERROR:
	msg = "no error";
	break;
    case LDR_NOMEM:
	msg = "out of memory";
	break;
    case LDR_NOENT:
	msg = "module does not exist";
	break;
    case LDR_NOSUBENT:
	msg = "a required submodule could not be loaded";
	break;
    case LDR_NOSPACE:
	msg = "too many modules";
	break;
    case LDR_NOMODOPEN:
	msg = "open failed";
	break;
    case LDR_UNKTYPE:
	msg = "unknown module type";
	break;
    case LDR_NOLOAD:
	msg = "loader failed";
	break;
    case LDR_ONCEONLY:
	msg = "once-only module";
	break;
    case LDR_NOPORTOPEN:
	msg = "port open failed";
	break;
    case LDR_NOHARDWARE:
	msg = "no hardware found";
	break;
    case LDR_MISMATCH:
	msg = "module requirement mismatch";
	break;
    case LDR_BADUSAGE:
	msg = "invalid argument(s) to LoadModule()";
	break;
    case LDR_INVALID:
	msg = "invalid module";
	break;
    case LDR_BADOS:
	msg = "module doesn't support this OS";
	break;
    case LDR_MODSPECIFIC:
	msg = "module-specific error";
	break;
    default:
	msg = "uknown error";
    }
    if (name)
	xf86Msg(X_ERROR, "%s: Failed to load module \"%s\" (%s, %d)\n",
		name, modname, msg, errmin);
    else
	xf86Msg(X_ERROR, "Failed to load module \"%s\" (%s, %d)\n",
		modname, msg, errmin);
d1247 1
d1252 25
a1276 37
    char *str;
    const char *s;
    int len;
    PatternPtr p;
    regmatch_t match[2];

    /* Strip off any leading path */
    s = strrchr(modname, '/');
    if (s == NULL)
	s = modname;
    else
	s++;

    /* Find the first regex that is matched */
    for (p = patterns; p->pattern; p++)
	if (regexec(&p->rex, s, 2, match, 0) == 0 && match[1].rm_so != -1) {
	    len = match[1].rm_eo - match[1].rm_so;
	    str = xalloc(len + 1);
	    if (!str)
		return NULL;
	    strncpy(str, s + match[1].rm_so, len);
	    str[len] = '\0';
	    return str;
	}

    /* If there is no match, return the whole name minus the leading path */
    return xstrdup(s);
}

/*
 * Return the module version information.
 */
unsigned long
LoaderGetModuleVersion(ModuleDescPtr mod)
{
    if (!mod || !mod->VersionInfo)
	return 0;
d1278 2
a1279 3
    return MODULE_VERSION_NUMERIC(mod->VersionInfo->majorversion,
				  mod->VersionInfo->minorversion,
				  mod->VersionInfo->patchlevel);
@


1.1.9.2
log
@Import XFree86 4.4 from The XFree86(TM) Project, Inc.
(integrity cannot be checked)

got via cvs -qd anoncvs@@anoncvs.xfree86.org:/cvs co -Prxf-4_4_0 xc
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/loadmod.c,v 1.74 2004/02/13 23:58:45 dawes Exp $ */
a26 1
 * All rights reserved.
d28 22
a49 41
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 *
 *   1.  Redistributions of source code must retain the above copyright
 *       notice, this list of conditions, and the following disclaimer.
 *
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer
 *       in the documentation and/or other materials provided with the
 *       distribution, and in the same place and form as other copyright,
 *       license and disclaimer information.
 *
 *   3.  The end-user documentation included with the redistribution,
 *       if any, must include the following acknowledgment: "This product
 *       includes software developed by The XFree86 Project, Inc
 *       (http://www.xfree86.org/) and its contributors", in the same
 *       place and form as other third-party acknowledgments.  Alternately,
 *       this acknowledgment may appear in the software itself, in the
 *       same form and location as other such third-party acknowledgments.
 *
 *   4.  Except as contained in this notice, the name of The XFree86
 *       Project, Inc shall not be used in advertising or otherwise to
 *       promote the sale, use or other dealings in this Software without
 *       prior written authorization from The XFree86 Project, Inc.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE XFREE86 PROJECT, INC OR ITS CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/loadmod.c,v 1.68 2002/07/30 18:36:18 dawes Exp $ */
d123 1
a123 1
#ifndef __UNIXOS2__
d726 1
a726 1
#ifndef __UNIXOS2__
a777 1
	ret->VersionInfo = mod->VersionInfo;
d887 1
a887 1
#ifndef __UNIXOS2__
a979 1
		ret->VersionInfo = vers;
a1279 14
}

/*
 * Return the module version information.
 */
unsigned long
LoaderGetModuleVersion (ModuleDescPtr mod)
{
    if (!mod || !mod->VersionInfo)
		return 0;

    return MODULE_VERSION_NUMERIC(mod->VersionInfo->majorversion,
								  mod->VersionInfo->minorversion,
								  mod->VersionInfo->patchlevel);
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/loadmod.c,v 1.73 2003/11/03 05:11:51 tsi Exp $ */
d25 2
a26 26
/*
 * Copyright (c) 1997-2002 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */
d51 2
a52 2
    const char *pattern;
    regex_t rex;
d56 4
a59 5
static char *FindModule(const char *, const char *, const char **,
			PatternPtr);
static Bool CheckVersion(const char *, XF86ModuleVersionInfo *,
			 const XF86ModReqInfo *);
static void UnloadModuleOrDriver(ModuleDescPtr mod);
d64 6
a69 6
    XF86_VERSION_CURRENT,
    ABI_ANSIC_VERSION,
    ABI_VIDEODRV_VERSION,
    ABI_XINPUT_VERSION,
    ABI_EXTENSION_VERSION,
    ABI_FONT_VERSION
d74 1
a74 1
LoaderFixups(void)
d76 2
a77 2
    /* Need to call LRS here because the frame buffers get loaded last,
     * and the drivers depend on them. */
d79 1
a79 1
    LoaderResolveSymbols();
d86 1
a86 1
    char **p;
d88 2
a89 2
    if (!paths)
	return;
d91 2
a92 2
    for (p = paths; *p; p++)
	xfree(*p);
d94 1
a94 1
    xfree(paths);
d107 6
a112 6
    char *fullpath = NULL;
    char *elem = NULL;
    char **list = NULL, **save = NULL;
    int len;
    int addslash;
    int n = 0;
d114 2
a115 2
    if (!path)
	return defaultPathList;
d117 6
a122 6
    fullpath = xstrdup(path);
    if (!fullpath)
	return NULL;
    elem = strtok(fullpath, ",");
    while (elem) {
	/* Only allow fully specified paths */
d124 1
a124 1
	if (*elem == '/')
d126 2
a127 2
	if (*elem == '/' || (strlen(elem) > 2 && isalpha(elem[0]) &&
			     elem[1] == ':' && elem[2] == '/'))
d129 27
a155 11
	{
	    len = strlen(elem);
	    addslash = (elem[len - 1] != '/');
	    if (addslash)
		len++;
	    save = list;
	    list = xrealloc(list, (n + 2) * sizeof(char *));
	    if (!list) {
		if (save) {
		    save[n] = NULL;
		    FreeStringList(save);
d157 5
a161 21
		xfree(fullpath);
		return NULL;
	    }
	    list[n] = xalloc(len + 1);
	    if (!list[n]) {
		FreeStringList(list);
		xfree(fullpath);
		return NULL;
	    }
	    strcpy(list[n], elem);
	    if (addslash) {
		list[n][len - 1] = '/';
		list[n][len] = '\0';
	    }
	    n++;
	}
	elem = strtok(NULL, ",");
    }
    if (list)
	list[n] = NULL;
    return list;
d167 2
a168 2
    if (pathlist && pathlist != defaultPathList)
	FreeStringList(pathlist);
d174 2
a175 2
    if (!path)
	return;
d177 1
a177 1
    defaultPathList = InitPathList(path);
d181 10
a190 9
static const char *stdSubdirs[] = {
    "drivers/",
    "input/",
    "multimedia/",
    "extensions/",
    "fonts/",
    "internal/",
    "",
    NULL
d198 8
a205 8
    {"^lib(.*)\\.so$",},
    {"^lib(.*)\\.a$",},
    {"(.*)_drv\\.so$",},
    {"(.*)_drv\\.o$",},
    {"(.*)\\.so$",},
    {"(.*)\\.a$",},
    {"(.*)\\.o$",},
    {NULL,}
d211 25
a235 35
    char errmsg[80];
    int i, e;
    PatternPtr patterns = NULL;
    PatternPtr p = NULL;
    static int firstTime = 1;
    const char **s;

    if (firstTime) {
	/* precompile stdPatterns */
	firstTime = 0;
	for (p = stdPatterns; p->pattern; p++)
	    if ((e = regcomp(&p->rex, p->pattern, REG_EXTENDED)) != 0) {
		regerror(e, &p->rex, errmsg, sizeof(errmsg));
		FatalError("InitPatterns: regcomp error for `%s': %s\n",
			   p->pattern, errmsg);
	    }
    }

    if (patternlist) {
	for (i = 0, s = patternlist; *s; i++, s++)
	    if (*s == DEFAULT_LIST)
		i += sizeof(stdPatterns) / sizeof(stdPatterns[0]) - 1 - 1;
	patterns = xalloc((i + 1) * sizeof(PatternRec));
	if (!patterns) {
	    return NULL;
	}
	for (i = 0, s = patternlist; *s; i++, s++)
	    if (*s != DEFAULT_LIST) {
		p = patterns + i;
		p->pattern = *s;
		if ((e = regcomp(&p->rex, p->pattern, REG_EXTENDED)) != 0) {
		    regerror(e, &p->rex, errmsg, sizeof(errmsg));
		    ErrorF("InitPatterns: regcomp error for `%s': %s\n",
			   p->pattern, errmsg);
		    i--;
d237 20
a256 10
	    } else {
		for (p = stdPatterns; p->pattern; p++, i++)
		    patterns[i] = *p;
		if (p != stdPatterns)
		    i--;
	    }
	patterns[i].pattern = NULL;
    } else
	patterns = stdPatterns;
    return patterns;
d262 2
a263 2
    if (patterns && patterns != stdPatterns)
	xfree(patterns);
d269 3
a271 4
    int i;
    const char **tmp_subdirlist = NULL;
    char **subdirs = NULL;
    const char **s, **stmp = NULL;
d278 7
a284 7
	subdirlist = tmp_subdirlist = xalloc(2 * sizeof(char *));
	if (subdirlist == NULL)
	    return NULL;
	subdirlist[0] = DEFAULT_LIST;
	subdirlist[1] = NULL;
    }

d289 17
a305 17
	/* Count number of entries and check for invalid paths */
	for (i = 0, s = subdirlist; *s; i++, s++) {
	    if (*s == DEFAULT_LIST) {
		i += sizeof(stdSubdirs) / sizeof(stdSubdirs[0]) - 1 - 1;
	    } else {
		/*
		 * Path validity check.  Don't allow absolute paths, or
		 * paths containing "..".  To catch absolute paths on
		 * platforms that use driver letters, don't allow the ':'
		 * character to appear at all.
		 */
		if (**s == '/' || **s == '\\' || strchr(*s, ':') ||
		    strstr(*s, "..")) {
		    xf86Msg(X_ERROR, "InitSubdirs: Bad subdir: \"%s\"\n", *s);
		    if (tmp_subdirlist)
			xfree(tmp_subdirlist);
		    return NULL;
d307 5
a311 42
	    }
	}
	subdirs = xalloc((i * 2 + 1) * sizeof(char *));
	if (!subdirs) {
	    if (tmp_subdirlist)
		xfree(tmp_subdirlist);
	    return NULL;
	}
	i = 0;
	s = subdirlist;
	indefault = FALSE;
	while (*s) {
	    if (*s == DEFAULT_LIST) {
		/* Divert to the default list */
		indefault = TRUE;
		stmp = ++s;
		s = stdSubdirs;
	    }
	    len = strlen(*s);
	    if (**s && (*s)[len - 1] != '/') {
		slash = "/";
		len++;
	    } else
		slash = "";
	    len += oslen + 2;
	    if (!(subdirs[i] = xalloc(len))) {
		while (--i >= 0)
		    xfree(subdirs[i]);
		xfree(subdirs);
		if (tmp_subdirlist)
		    xfree(tmp_subdirlist);
		return NULL;
	    }
	    /* tack on the OS name */
	    sprintf(subdirs[i], "%s%s%s/", *s, slash, osname);
	    i++;
	    /* path as given */
	    subdirs[i] = xstrdup(*s);
	    i++;
	    s++;
	    if (indefault && !s) {
		/* revert back to the main list */
d313 30
a342 2
		s = stmp;
	    }
d344 1
a344 5
	subdirs[i] = NULL;
    }
    if (tmp_subdirlist)
	xfree(tmp_subdirlist);
    return (const char **)subdirs;
d350 1
a350 1
    const char **s;
d352 5
a356 5
    if (subdirs) {
	for (s = subdirs; *s; s++)
	    xfree(*s);
	xfree(subdirs);
    }
d360 2
a361 2
FindModule(const char *module, const char *dir, const char **subdirlist,
	   PatternPtr patterns)
d363 12
a374 12
    char buf[PATH_MAX + 1];
    char *dirpath = NULL;
    char *name = NULL;
    struct stat stat_buf;
    int len, dirlen;
    char *fp;
    DIR *d;
    const char **subdirs = NULL;
    PatternPtr p = NULL;
    const char **s;
    struct dirent *dp;
    regmatch_t match[2];
d376 3
a378 3
    subdirs = InitSubdirs(subdirlist);
    if (!subdirs)
	return NULL;
d381 1
a381 1
    dirpath = (char *)dir;
d383 2
a384 2
    dirpath = xalloc(strlen(dir) + 10);
    strcpy(dirpath, (char *)__XOS2RedirRoot(dir));
d386 3
a388 3
    if (strlen(dirpath) > PATH_MAX)
	return NULL;
    /*xf86Msg(X_INFO,"OS2DIAG: FindModule: dirpath=%s\n",dirpath); */
d390 33
a422 29
    for (s = subdirs; *s; s++) {
	if ((dirlen = strlen(dirpath) + strlen(*s)) > PATH_MAX)
	    continue;
	strcpy(buf, dirpath);
	strcat(buf, *s);
	/*xf86Msg(X_INFO,"OS2DIAG: FindModule: buf=%s\n",buf); */
	fp = buf + dirlen;
	if (stat(buf, &stat_buf) == 0 && S_ISDIR(stat_buf.st_mode) &&
	    (d = opendir(buf))) {
	    if (buf[dirlen - 1] != '/') {
		buf[dirlen++] = '/';
		fp++;
	    }
	    while ((dp = readdir(d))) {
		if (dirlen + strlen(dp->d_name) + 1 > PATH_MAX)
		    continue;
		strcpy(fp, dp->d_name);
		if (!(stat(buf, &stat_buf) == 0 && S_ISREG(stat_buf.st_mode)))
		    continue;
		for (p = patterns; p->pattern; p++) {
		    if (regexec(&p->rex, dp->d_name, 2, match, 0) == 0 &&
			match[1].rm_so != -1) {
			len = match[1].rm_eo - match[1].rm_so;
			if (len == strlen(module) &&
			    strncmp(module, dp->d_name + match[1].rm_so,
				    len) == 0) {
			    /*xf86Msg(X_INFO,"OS2DIAG: matching %s\n",buf); */
			    name = buf;
			    break;
d424 3
a426 1
		    }
a427 6
		if (name)
		    break;
	    }
	    closedir(d);
	    if (name)
		break;
d429 8
a436 9
    }
    FreeSubdirs(subdirs);
    if (dirpath != dir)
	xfree(dirpath);

    if (name) {
	return xstrdup(name);
    }
    return NULL;
d442 16
a457 16
    char buf[PATH_MAX + 1];
    char **pathlist;
    char **elem;
    const char **subdirs;
    const char **s;
    PatternPtr patterns;
    PatternPtr p;
    DIR *d;
    struct dirent *dp;
    regmatch_t match[2];
    struct stat stat_buf;
    int len, dirlen;
    char *fp;
    char **listing = NULL;
    char **save;
    int n = 0;
d459 11
a469 11
    if (!(pathlist = InitPathList(NULL)))
	return NULL;
    if (!(subdirs = InitSubdirs(subdirlist))) {
	FreePathList(pathlist);
	return NULL;
    }
    if (!(patterns = InitPatterns(patternlist))) {
	FreePathList(pathlist);
	FreeSubdirs(subdirs);
	return NULL;
    }
d471 52
a522 31
    for (elem = pathlist; *elem; elem++) {
	for (s = subdirs; *s; s++) {
	    if ((dirlen = strlen(*elem) + strlen(*s)) > PATH_MAX)
		continue;
	    strcpy(buf, *elem);
	    strcat(buf, *s);
	    fp = buf + dirlen;
	    if (stat(buf, &stat_buf) == 0 && S_ISDIR(stat_buf.st_mode) &&
		(d = opendir(buf))) {
		if (buf[dirlen - 1] != '/') {
		    buf[dirlen++] = '/';
		    fp++;
		}
		while ((dp = readdir(d))) {
		    if (dirlen + strlen(dp->d_name) > PATH_MAX)
			continue;
		    strcpy(fp, dp->d_name);
		    if (!(stat(buf, &stat_buf) == 0 &&
			  S_ISREG(stat_buf.st_mode)))
			continue;
		    for (p = patterns; p->pattern; p++) {
			if (regexec(&p->rex, dp->d_name, 2, match, 0) == 0 &&
			    match[1].rm_so != -1) {
			    len = match[1].rm_eo - match[1].rm_so;
			    save = listing;
			    listing = xrealloc(listing,
					       (n + 2) * sizeof(char *));
			    if (!listing) {
				if (save) {
				    save[n] = NULL;
				    FreeStringList(save);
d524 1
a524 18
				FreePathList(pathlist);
				FreeSubdirs(subdirs);
				FreePatterns(patterns);
				return NULL;
			    }
			    listing[n] = xalloc(len + 1);
			    if (!listing[n]) {
				FreeStringList(listing);
				FreePathList(pathlist);
				FreeSubdirs(subdirs);
				FreePatterns(patterns);
				return NULL;
			    }
			    strncpy(listing[n], dp->d_name + match[1].rm_so,
				    len);
			    listing[n][len] = '\0';
			    n++;
			    break;
a525 1
		    }
a526 2
		closedir(d);
	    }
d528 3
a530 4
    }
    if (listing)
	listing[n] = NULL;
    return listing;
d536 1
a536 1
    FreeStringList(list);
d539 1
d541 2
a542 2
CheckVersion(const char *module, XF86ModuleVersionInfo * data,
	     const XF86ModReqInfo * req)
d544 38
a581 38
    int vercode[4];
    char verstr[4];
    long ver = data->xf86version;
    MessageType errtype;

    xf86Msg(X_INFO, "Module %s: vendor=\"%s\"\n",
	    data->modname ? data->modname : "UNKNOWN!",
	    data->vendor ? data->vendor : "UNKNOWN!");

    if (ver > (4 << 24)) {
	/* 4.0.x and earlier */
	verstr[1] = verstr[3] = 0;
	verstr[2] = (ver & 0x1f) ? (ver & 0x1f) + 'a' - 1 : 0;
	ver >>= 5;
	verstr[0] = (ver & 0x1f) ? (ver & 0x1f) + 'A' - 1 : 0;
	ver >>= 5;
	vercode[2] = ver & 0x7f;
	ver >>= 7;
	vercode[1] = ver & 0x7f;
	ver >>= 7;
	vercode[0] = ver;
	xf86ErrorF("\tcompiled for %d.%d", vercode[0], vercode[1]);
	if (vercode[2] != 0)
	    xf86ErrorF(".%d", vercode[2]);
	xf86ErrorF("%s%s, module version = %d.%d.%d\n", verstr, verstr + 2,
		   data->majorversion, data->minorversion, data->patchlevel);
    } else {
	vercode[0] = ver / 10000000;
	vercode[1] = (ver / 100000) % 100;
	vercode[2] = (ver / 1000) % 100;
	vercode[3] = ver % 1000;
	xf86ErrorF("\tcompiled for %d.%d.%d", vercode[0], vercode[1],
		   vercode[2]);
	if (vercode[3] != 0)
	    xf86ErrorF(".%d", vercode[3]);
	xf86ErrorF(", module version = %d.%d.%d\n", data->majorversion,
		   data->minorversion, data->patchlevel);
    }
d584 50
a633 1
	xf86ErrorFVerb(2, "\tModule class: %s\n", data->moduleclass);
d635 63
a697 71
    ver = -1;
    if (data->abiclass) {
	int abimaj, abimin;
	int vermaj, vermin;

	if (!strcmp(data->abiclass, ABI_CLASS_ANSIC))
	    ver = LoaderVersionInfo.ansicVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_VIDEODRV))
	    ver = LoaderVersionInfo.videodrvVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_XINPUT))
	    ver = LoaderVersionInfo.xinputVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_EXTENSION))
	    ver = LoaderVersionInfo.extensionVersion;
	else if (!strcmp(data->abiclass, ABI_CLASS_FONT))
	    ver = LoaderVersionInfo.fontVersion;

	abimaj = GET_ABI_MAJOR(data->abiversion);
	abimin = GET_ABI_MINOR(data->abiversion);
	xf86ErrorFVerb(2, "\tABI class: %s, version %d.%d\n",
		       data->abiclass, abimaj, abimin);
	if (ver != -1) {
	    vermaj = GET_ABI_MAJOR(ver);
	    vermin = GET_ABI_MINOR(ver);
	    if (abimaj != vermaj) {
		if (LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL)
		    errtype = X_WARNING;
		else
		    errtype = X_ERROR;
		xf86MsgVerb(errtype, 0,
			    "module ABI major version (%d) doesn't"
			    " match the server's version (%d)\n",
			    abimaj, vermaj);
		if (!(LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL))
		    return FALSE;
	    } else if (abimin > vermin) {
		if (LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL)
		    errtype = X_WARNING;
		else
		    errtype = X_ERROR;
		xf86MsgVerb(errtype, 0,
			    "module ABI minor version (%d) is "
			    "newer than the server's version "
			    "(%d)\n", abimin, vermin);
		if (!(LoaderOptions & LDR_OPT_ABI_MISMATCH_NONFATAL))
		    return FALSE;
	    }
	}
    }

    /* Check against requirements that the caller has specified */
    if (req) {
	if (req->majorversion != MAJOR_UNSPEC) {
	    if (data->majorversion != req->majorversion) {
		xf86MsgVerb(X_WARNING, 2, "module major version (%d) "
			    "doesn't match required major version (%d)\n",
			    data->majorversion, req->majorversion);
		return FALSE;
	    } else if (req->minorversion != MINOR_UNSPEC) {
		if (data->minorversion < req->minorversion) {
		    xf86MsgVerb(X_WARNING, 2, "module minor version (%d) "
				"is less than the required minor version (%d)\n",
				data->minorversion, req->minorversion);
		    return FALSE;
		} else if (data->minorversion == req->minorversion &&
			   req->patchlevel != PATCH_UNSPEC) {
		    if (data->patchlevel < req->patchlevel) {
			xf86MsgVerb(X_WARNING, 2, "module patch level (%d) "
				    "is less than the required patch level (%d)\n",
				    data->patchlevel, req->patchlevel);
			return FALSE;
		    }
a698 1
	    }
d700 10
a709 38
	if (req->moduleclass) {
	    if (!data->moduleclass ||
		strcmp(req->moduleclass, data->moduleclass)) {
		xf86MsgVerb(X_WARNING, 2, "Module class (%s) doesn't match "
			    "the required class (%s)\n",
			    data->moduleclass ? data->moduleclass : "<NONE>",
			    req->moduleclass);
		return FALSE;
	    }
	} else if (req->abiclass != ABI_CLASS_NONE) {
	    if (!data->abiclass || strcmp(req->abiclass, data->moduleclass)) {
		xf86MsgVerb(X_WARNING, 2, "ABI class (%s) doesn't match the "
			    "required ABI class (%s)\n",
			    data->abiclass ? data->abiclass : "<NONE>",
			    req->abiclass);
		return FALSE;
	    }
	}
	if ((req->abiclass != ABI_CLASS_NONE) &&
	    req->abiversion != ABI_VERS_UNSPEC) {
	    int reqmaj, reqmin, maj, min;

	    reqmaj = GET_ABI_MAJOR(req->abiversion);
	    reqmin = GET_ABI_MINOR(req->abiversion);
	    maj = GET_ABI_MAJOR(data->abiversion);
	    min = GET_ABI_MINOR(data->abiversion);
	    if (maj != reqmaj) {
		xf86MsgVerb(X_WARNING, 2, "ABI major version (%d) doesn't "
			    "match the required ABI major version (%d)\n",
			    maj, reqmaj);
		return FALSE;
	    }
	    /* XXX Maybe this should be the other way around? */
	    if (min > reqmin) {
		xf86MsgVerb(X_WARNING, 2, "module ABI minor version (%d) "
			    "is new than that available (%d)\n", min, reqmin);
		return FALSE;
	    }
a710 8
    }
#ifdef NOTYET
    if (data->checksum) {
	/* verify the checksum field */
	/* TO BE DONE */
    } else {
	ErrorF("\t*** Checksum field is 0 - this module is untrusted!\n");
    }
d718 1
a718 1
	      pointer options, const XF86ModReqInfo * modreq,
d721 1
a721 1
    ModuleDescPtr submod;
d723 1
a723 1
    xf86MsgVerb(X_INFO, 3, "Loading sub module \"%s\"\n", module);
d725 1
a725 1
    /* Absolute module paths are not allowed here */
d727 1
a727 1
    if (module[0] == '/')
d729 1
a729 1
    if (isalpha(module[0]) && module[1] == ':' && module[2] == '/')
d731 10
a740 10
    {
	xf86Msg(X_ERROR,
		"LoadSubModule: Absolute module path not permitted: \"%s\"\n",
		module);
	if (errmaj)
	    *errmaj = LDR_BADUSAGE;
	if (errmin)
	    *errmin = 0;
	return NULL;
    }
d742 7
a748 7
    submod = LoadModule(module, NULL, subdirlist, patternlist, options,
			modreq, errmaj, errmin);
    if (submod) {
	parent->child = AddSibling(parent->child, submod);
	submod->parent = parent;
    }
    return submod;
d754 1
a754 1
    ModuleDescPtr ret;
d756 2
a757 2
    if (!mod)
	return NULL;
d759 3
a761 3
    ret = NewModuleDesc(mod->name);
    if (ret == NULL)
	return NULL;
d763 2
a764 2
    if (LoaderHandleOpen(mod->handle) == -1)
	return NULL;
d766 13
a778 13
    ret->filename = xstrdup(mod->filename);
    ret->identifier = mod->identifier;
    ret->client_id = mod->client_id;
    ret->in_use = mod->in_use;
    ret->handle = mod->handle;
    ret->SetupProc = mod->SetupProc;
    ret->TearDownProc = mod->TearDownProc;
    ret->TearDownData = NULL;
    ret->path = mod->path;
    ret->child = DuplicateModule(mod->child, ret);
    ret->sib = DuplicateModule(mod->sib, parent);
    ret->parent = parent;
    ret->VersionInfo = mod->VersionInfo;
d780 1
a780 1
    return ret;
d822 66
a887 62
LoadModule(const char *module, const char *path, const char **subdirlist,
	   const char **patternlist, pointer options,
	   const XF86ModReqInfo * modreq, int *errmaj, int *errmin)
{
    XF86ModuleData *initdata = NULL;
    char **pathlist = NULL;
    char *found = NULL;
    char *name = NULL;
    char **path_elem = NULL;
    char *p = NULL;
    ModuleDescPtr ret = NULL;
    int wasLoaded = 0;
    PatternPtr patterns = NULL;
    int noncanonical = 0;
    char *m = NULL;

    /*xf86Msg(X_INFO,"OS2DIAG: LoadModule: %s\n",module); */
    xf86MsgVerb(X_INFO, 3, "LoadModule: \"%s\"", module);

    patterns = InitPatterns(patternlist);
    name = LoaderGetCanonicalName(module, patterns);
    noncanonical = (name && strcmp(module, name) != 0);
    if (noncanonical) {
	xf86ErrorFVerb(3, " (%s)\n", name);
	xf86MsgVerb(X_WARNING, 1,
		    "LoadModule: given non-canonical module name \"%s\"\n",
		    module);
	m = name;
    } else {
	xf86ErrorFVerb(3, "\n");
	m = (char *)module;
    }
    if (!name) {
	if (errmaj)
	    *errmaj = LDR_BADUSAGE;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
    }
    ret = NewModuleDesc(name);
    if (!ret) {
	if (errmaj)
	    *errmaj = LDR_NOMEM;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
    }

    pathlist = InitPathList(path);
    if (!pathlist) {
	/* This could be a malloc failure too */
	if (errmaj)
	    *errmaj = LDR_BADUSAGE;
	if (errmin)
	    *errmin = 1;
	goto LoadModule_fail;
    }

    /* 
     * if the module name is not a full pathname, we need to
     * check the elements in the path
     */
d889 2
a890 2
    if (module[0] == '/')
	found = xstrdup(module);
d892 3
a894 3
    /* accept a drive name here */
    if (isalpha(module[0]) && module[1] == ':' && module[2] == '/')
	found = xstrdup(module);
d896 35
a930 4
    path_elem = pathlist;
    while (!found && *path_elem != NULL) {
	found = FindModule(m, *path_elem, subdirlist, patterns);
	path_elem++;
d932 2
a933 2
	 * When the module name isn't the canonical name, search for the
	 * former if no match was found for the latter.
d935 5
a939 53
	if (!*path_elem && m == name) {
	    path_elem = pathlist;
	    m = (char *)module;
	}
    }

    /* 
     * did we find the module?
     */
    if (!found) {
	xf86Msg(X_WARNING, "Warning, couldn't open module %s\n", module);
	if (errmaj)
	    *errmaj = LDR_NOENT;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
    }
    ret->handle = LoaderOpen(found, name, 0, errmaj, errmin, &wasLoaded);
    if (ret->handle < 0)
	goto LoadModule_fail;

    ret->filename = xstrdup(found);

    /*
     * now check if the special data object <modulename>ModuleData is
     * present.
     */
    p = xalloc(strlen(name) + strlen("ModuleData") + 1);
    if (!p) {
	if (errmaj)
	    *errmaj = LDR_NOMEM;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
    }
    strcpy(p, name);
    strcat(p, "ModuleData");
    initdata = LoaderSymbol(p);
    if (initdata) {
	ModuleSetupProc setup;
	ModuleTearDownProc teardown;
	XF86ModuleVersionInfo *vers;

	vers = initdata->vers;
	setup = initdata->setup;
	teardown = initdata->teardown;

	if (!wasLoaded) {
	    if (vers) {
		if (!CheckVersion(module, vers, modreq)) {
		    if (errmaj)
			*errmaj = LDR_MISMATCH;
		    if (errmin)
d941 34
a974 1
		    goto LoadModule_fail;
d976 16
a991 4
	    } else {
		xf86Msg(X_ERROR,
			"LoadModule: Module %s does not supply"
			" version information\n", module);
d993 1
a993 1
		    *errmaj = LDR_INVALID;
d995 1
a995 1
		    *errmin = 0;
a996 1
	    }
d998 14
a1011 30
	if (setup)
	    ret->SetupProc = setup;
	if (teardown)
	    ret->TearDownProc = teardown;
	ret->path = path;
	ret->VersionInfo = vers;
    } else {
	/* No initdata is OK for external modules */
	if (options == EXTERN_MODULE)
	    goto LoadModule_exit;

	/* no initdata, fail the load */
	xf86Msg(X_ERROR, "LoadModule: Module %s does not have a %s "
		"data object.\n", module, p);
	if (errmaj)
	    *errmaj = LDR_INVALID;
	if (errmin)
	    *errmin = 0;
	goto LoadModule_fail;
    }
    if (ret->SetupProc) {
	ret->TearDownData = ret->SetupProc(ret, options, errmaj, errmin);
	if (!ret->TearDownData) {
	    goto LoadModule_fail;
	}
    } else if (options) {
	xf86Msg(X_WARNING, "Module Options present, but no SetupProc "
		"available for %s\n", module);
    }
    goto LoadModule_exit;
d1014 2
a1015 2
    UnloadModule(ret);
    ret = NULL;
d1018 12
a1029 12
    FreePathList(pathlist);
    FreePatterns(patterns);
    TestFree(found);
    TestFree(name);
    TestFree(p);

    /*
     * If you need to do something to keep the
     * instruction cache in sync with the main
     * memory before jumping to that code, you may
     * do it here.
     */
d1031 1
a1031 1
    istream_mem_barrier();
d1033 1
a1033 1
    return ret;
d1037 2
a1038 2
LoadDriver(const char *module, const char *path, int handle, pointer options,
	   int *errmaj, int *errmin)
d1040 1
a1040 2
    return LoadModule(module, path, NULL, NULL, options, NULL, errmaj,
		      errmin);
d1044 1
a1044 1
UnloadModule(ModuleDescPtr mod)
d1046 1
a1046 1
    UnloadModuleOrDriver(mod);
d1050 1
a1050 1
UnloadDriver(ModuleDescPtr mod)
d1052 1
a1052 1
    UnloadModuleOrDriver(mod);
d1056 1
a1056 1
UnloadModuleOrDriver(ModuleDescPtr mod)
d1064 2
a1065 2
	mod->TearDownProc(mod->TearDownData);
    LoaderUnload(mod->handle);
d1068 1
a1068 1
	UnloadModuleOrDriver(mod->child);
d1070 4
a1073 4
	UnloadModuleOrDriver(mod->sib);
    TestFree(mod->name);
    TestFree(mod->filename);
    xfree(mod);
d1075 1
a1075 1
    istream_mem_barrier();
d1088 2
a1089 2
	mod->TearDownProc(mod->TearDownData);
    LoaderUnload(mod->handle);
d1094 1
a1094 1
	UnloadModuleOrDriver(mod->child);
d1096 3
a1098 3
    TestFree(mod->name);
    TestFree(mod->filename);
    xfree(mod);
d1102 1
a1102 1
FreeModuleDesc(ModuleDescPtr head)
d1104 1
a1104 1
    ModuleDescPtr sibs, prev;
d1106 16
a1121 15
    /*
     * only free it if it's not marked as in use. In use means that it may
     * be unloaded someday, and UnloadModule or UnloadDriver will free it
     */
    if (head->in_use)
	return;
    if (head->child)
	FreeModuleDesc(head->child);
    sibs = head;
    while (sibs) {
	prev = sibs;
	sibs = sibs->sib;
	TestFree(prev->name);
	xfree(prev);
    }
d1125 1
a1125 1
NewModuleDesc(const char *name)
d1127 1
a1127 1
    ModuleDescPtr mdp = xalloc(sizeof(ModuleDesc));
d1129 16
a1144 15
    if (mdp) {
	mdp->child = NULL;
	mdp->sib = NULL;
	mdp->parent = NULL;
	mdp->demand_next = NULL;
	mdp->name = xstrdup(name);
	mdp->filename = NULL;
	mdp->identifier = NULL;
	mdp->client_id = 0;
	mdp->in_use = 0;
	mdp->handle = -1;
	mdp->SetupProc = NULL;
	mdp->TearDownProc = NULL;
	mdp->TearDownData = NULL;
    }
d1146 1
a1146 1
    return (mdp);
d1150 1
a1150 1
AddSibling(ModuleDescPtr head, ModuleDescPtr new)
d1158 1
a1158 1
RemoveChild(ModuleDescPtr child)
d1160 12
a1171 3
    ModuleDescPtr mdp;
    ModuleDescPtr prevsib;
    ModuleDescPtr parent;
d1173 8
a1180 6
    if (!child->parent)
	return;

    parent = child->parent;
    if (parent->child == child) {
	parent->child = child->sib;
a1181 11
    }

    prevsib = parent->child;
    mdp = prevsib->sib;
    while (mdp && mdp != child) {
	prevsib = mdp;
	mdp = mdp->sib;
    }
    if (mdp == child)
	prevsib->sib = child->sib;
    return;
d1187 1
a1187 1
    const char *msg;
d1189 58
a1246 58
    switch (errmaj) {
    case LDR_NOERROR:
	msg = "no error";
	break;
    case LDR_NOMEM:
	msg = "out of memory";
	break;
    case LDR_NOENT:
	msg = "module does not exist";
	break;
    case LDR_NOSUBENT:
	msg = "a required submodule could not be loaded";
	break;
    case LDR_NOSPACE:
	msg = "too many modules";
	break;
    case LDR_NOMODOPEN:
	msg = "open failed";
	break;
    case LDR_UNKTYPE:
	msg = "unknown module type";
	break;
    case LDR_NOLOAD:
	msg = "loader failed";
	break;
    case LDR_ONCEONLY:
	msg = "once-only module";
	break;
    case LDR_NOPORTOPEN:
	msg = "port open failed";
	break;
    case LDR_NOHARDWARE:
	msg = "no hardware found";
	break;
    case LDR_MISMATCH:
	msg = "module requirement mismatch";
	break;
    case LDR_BADUSAGE:
	msg = "invalid argument(s) to LoadModule()";
	break;
    case LDR_INVALID:
	msg = "invalid module";
	break;
    case LDR_BADOS:
	msg = "module doesn't support this OS";
	break;
    case LDR_MODSPECIFIC:
	msg = "module-specific error";
	break;
    default:
	msg = "uknown error";
    }
    if (name)
	xf86Msg(X_ERROR, "%s: Failed to load module \"%s\" (%s, %d)\n",
		name, modname, msg, errmin);
    else
	xf86Msg(X_ERROR, "Failed to load module \"%s\" (%s, %d)\n",
		modname, msg, errmin);
d1249 1
d1254 25
a1278 24
    char *str;
    const char *s;
    int len;
    PatternPtr p;
    regmatch_t match[2];

    /* Strip off any leading path */
    s = strrchr(modname, '/');
    if (s == NULL)
	s = modname;
    else
	s++;

    /* Find the first regex that is matched */
    for (p = patterns; p->pattern; p++)
	if (regexec(&p->rex, s, 2, match, 0) == 0 && match[1].rm_so != -1) {
	    len = match[1].rm_eo - match[1].rm_so;
	    str = xalloc(len + 1);
	    if (!str)
		return NULL;
	    strncpy(str, s + match[1].rm_so, len);
	    str[len] = '\0';
	    return str;
	}
d1280 2
a1281 2
    /* If there is no match, return the whole name minus the leading path */
    return xstrdup(s);
d1288 1
a1288 1
LoaderGetModuleVersion(ModuleDescPtr mod)
d1291 1
a1291 1
	return 0;
d1294 2
a1295 2
				  mod->VersionInfo->minorversion,
				  mod->VersionInfo->patchlevel);
@


