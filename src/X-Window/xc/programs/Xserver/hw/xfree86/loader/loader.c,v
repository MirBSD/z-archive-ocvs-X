head	1.2;
access;
symbols
	tg-mergetmp-2:1.2
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407221130:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.2
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.03.07.18.38.11;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.20.08.30;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.08.30;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.37.25;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.24.13;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.24.59;	author tg;	state Exp;
branches;
next	1.1.9.2;

1.1.9.2
date	2004.03.05.22.33.20;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@semi-automagic merge of these files (ie, I've skipped through the diffs,
and most of that was done by cvs or that weird script of some minutes ago)
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/loader.c,v 1.72 2004/02/13 23:58:45 dawes Exp $ */

/*
 * Copyright 1995-1998 by Metro Link, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Metro Link, Inc. not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Metro Link, Inc. makes no
 * representations about the suitability of this software for any purpose.
 *  It is provided "as is" without express or implied warranty.
 *
 * METRO LINK, INC. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL METRO LINK, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 *
 *   1.  Redistributions of source code must retain the above copyright
 *       notice, this list of conditions, and the following disclaimer.
 *
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer
 *       in the documentation and/or other materials provided with the
 *       distribution, and in the same place and form as other copyright,
 *       license and disclaimer information.
 *
 *   3.  The end-user documentation included with the redistribution,
 *       if any, must include the following acknowledgment: "This product
 *       includes software developed by The XFree86 Project, Inc
 *       (http://www.xfree86.org/) and its contributors", in the same
 *       place and form as other third-party acknowledgments.  Alternately,
 *       this acknowledgment may appear in the software itself, in the
 *       same form and location as other such third-party acknowledgments.
 *
 *   4.  Except as contained in this notice, the name of The XFree86
 *       Project, Inc shall not be used in advertising or otherwise to
 *       promote the sale, use or other dealings in this Software without
 *       prior written authorization from The XFree86 Project, Inc.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE XFREE86 PROJECT, INC OR ITS CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#if defined(UseMMAP) || (defined(linux) && defined(__ia64__))
#include <sys/mman.h>
#endif
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#if defined(linux) && \
    (defined(__alpha__) || defined(__powerpc__) || defined(__ia64__) \
     || defined(__AMD64__))
#include <malloc.h>
#endif
#include <stdarg.h>
#include "ar.h"
#include "elf.h"
#include "coff.h"

#include "os.h"
#include "sym.h"
#include "loader.h"
#include "loaderProcs.h"
#include "xf86.h"
#include "xf86Priv.h"

#include "compiler.h"

extern LOOKUP miLookupTab[];
extern LOOKUP xfree86LookupTab[];
extern LOOKUP dixLookupTab[];
extern LOOKUP fontLookupTab[];
extern LOOKUP extLookupTab[];

/*
#define DEBUG
#define DEBUGAR
#define DEBUGLIST
#define DEBUGMEM
*/

int check_unresolved_sema = 0;

#if defined(Lynx) && defined(sun)
/* Cross build machine doesn;t have strerror() */
#define strerror(err) "strerror unsupported"
#endif

#ifdef __UNIXOS2__
void *os2ldcalloc(size_t, size_t);
#endif

#ifdef HANDLE_IN_HASH_ENTRY
/*
 * handles are used to identify files that are loaded. Even archives
 * are counted as a single file.
 */
#define MAX_HANDLE 256
#define HANDLE_FREE 0
#define HANDLE_USED 1
static char freeHandles[MAX_HANDLE];
static int refCount[MAX_HANDLE];
#endif

#if defined(__sparc__) && defined(__GNUC__) && !defined(__FreeBSD__)
# define SYMFUNCDOT(func) { "." #func, (funcptr)&__sparc_dot_ ## func },
# if !defined(__OpenBSD__)
# define SYMFUNCDOT89(func) { "." #func, (funcptr)&func ## _sparcv89 },
# define DEFFUNCDOT(func) 					\
extern void __sparc_dot_ ## func (void) __asm__ ("." #func);	\
extern void func ## _sparcv89 (void);
# else
# define SYMFUNCDOT(func) { "." #func, (funcptr)&__sparc_dot_ ## func },
# define DEFFUNCDOT(func) 					\
extern void __sparc_dot_ ## func (void) __asm__ ("." #func);
#endif
DEFFUNCDOT(rem)
DEFFUNCDOT(urem)
DEFFUNCDOT(mul)
DEFFUNCDOT(umul)
DEFFUNCDOT(div)
DEFFUNCDOT(udiv)
#ifdef linux
static LOOKUP SparcV89LookupTab[] = {
    SYMFUNCDOT89(rem)
    SYMFUNCDOT89(urem)
    SYMFUNCDOT89(mul)
    SYMFUNCDOT89(umul)
    SYMFUNCDOT89(div)
    SYMFUNCDOT89(udiv)
    {0, 0}
};
#endif
static LOOKUP SparcLookupTab[] = {
    SYMFUNCDOT(rem)
    SYMFUNCDOT(urem)
    SYMFUNCDOT(mul)
    SYMFUNCDOT(umul)
    SYMFUNCDOT(div)
    SYMFUNCDOT(udiv)
    {0, 0}
};

#ifdef linux
#if defined(__GNUC__) && defined(__GLIBC__)
#define HWCAP_SPARC_MULDIV	8
extern unsigned long int _dl_hwcap;
#endif

static int
sparcUseHWMulDiv(void)
{
    FILE *f;
    char buffer[1024];
    char *p;

#if defined(__GNUC__) && defined(__GLIBC__)
    unsigned long *hwcap;

    __asm(".weak _dl_hwcap");

    hwcap = &_dl_hwcap;
  __asm("": "=r"(hwcap):"0"(hwcap));
    if (hwcap) {
	if (*hwcap & HWCAP_SPARC_MULDIV)
	    return 1;
	else
	    return 0;
    }
#endif
    f = fopen("/proc/cpuinfo", "r");
    if (!f)
	return 0;
    while (fgets(buffer, 1024, f) != NULL) {
	if (!strncmp(buffer, "type", 4)) {
	    p = strstr(buffer, "sun4");
	    if (p && (p[4] == 'u' || p[4] == 'd' || p[4] == 'm')) {
		fclose(f);
		return 1;
	    }
	}
    }
    fclose(f);
    return 0;
}
#endif
#endif

/*
 * modules are used to identify compilation units (ie object modules).
 * Archives contain multiple modules, each of which is treated seperately.
 */
static int moduleseq = 0;

/*
 * GDB Interface
 * =============
 *
 * Linked list of loaded modules - gdb will traverse this to determine
 * whether it needs to add the symbols for the loaded module.
 */
LDRModulePtr ModList = 0;

/* Flag which gdb sets to let us know we're being debugged */
char DebuggerPresent = 0;

/* List of common symbols */
LDRCommonPtr ldrCommons;
int nCommons;

typedef struct {
    int num;
    const char **list;
} symlist;

/*
 * List of symbols that may be referenced, and which are allowed to be
 * unresolved providing that they don't appear on the "reqired" list.
 */
static symlist refList = { 0, NULL };

/* List of symbols that must not be unresolved */
static symlist reqList = { 0, NULL };

static int fatalReqSym = 0;

/* Prototypes for static functions. */
static int _GetModuleType(int, long);
static loaderPtr _LoaderListPush(void);
static loaderPtr _LoaderListPop(int);
 /*ARGSUSED*/ static void
ARCHIVEResolveSymbols(void *unused)
{
}
 /*ARGSUSED*/ static int
ARCHIVECheckForUnresolved(void *v)
{
    return 0;
}
 /*ARGSUSED*/ static char *
ARCHIVEAddressToSection(void *modptr, unsigned long address)
{
    return NULL;
}
 /*ARGSUSED*/ static void
ARCHIVEUnload(void *unused2)
{
}

/*
 * Array containing entry points for different formats.
 */

static loader_funcs funcs[] = {
    /* LD_ARCHIVE */
    {ARCHIVELoadModule,
     ARCHIVEResolveSymbols,
     ARCHIVECheckForUnresolved,
     ARCHIVEAddressToSection,
     ARCHIVEUnload, {0, 0, 0, 0, 0}},
    /* LD_ELFOBJECT */
    {ELFLoadModule,
     ELFResolveSymbols,
     ELFCheckForUnresolved,
     ELFAddressToSection,
     ELFUnloadModule, {0, 0, 0, 0, 0}},
    /* LD_COFFOBJECT */
    {COFFLoadModule,
     COFFResolveSymbols,
     COFFCheckForUnresolved,
     COFFAddressToSection,
     COFFUnloadModule, {0, 0, 0, 0, 0}},
    /* LD_XCOFFOBJECT */
    {COFFLoadModule,
     COFFResolveSymbols,
     COFFCheckForUnresolved,
     COFFAddressToSection,
     COFFUnloadModule, {0, 0, 0, 0, 0}},
    /* LD_AOUTOBJECT */
    {AOUTLoadModule,
     AOUTResolveSymbols,
     AOUTCheckForUnresolved,
     AOUTAddressToSection,
     AOUTUnloadModule, {0, 0, 0, 0, 0}},
    /* LD_AOUTDLOBJECT */
#ifdef DLOPEN_SUPPORT
    {DLLoadModule,
     DLResolveSymbols,
     DLCheckForUnresolved,
     ARCHIVEAddressToSection,
     DLUnloadModule, {0, 0, 0, 0, 0}},
#else
    {AOUTLoadModule,
     AOUTResolveSymbols,
     AOUTCheckForUnresolved,
     AOUTAddressToSection,
     AOUTUnloadModule, {0, 0, 0, 0, 0}},
#endif
    /* LD_ELFDLOBJECT */
#ifdef DLOPEN_SUPPORT
    {DLLoadModule,
     DLResolveSymbols,
     DLCheckForUnresolved,
     ARCHIVEAddressToSection,
     DLUnloadModule, {0, 0, 0, 0, 0}},
#else
    {ELFLoadModule,
     ELFResolveSymbols,
     ELFCheckForUnresolved,
     ELFAddressToSection,
     ELFUnloadModule, {0, 0, 0, 0, 0}},
#endif
};

int numloaders = sizeof(funcs) / sizeof(loader_funcs);

void
LoaderInit(void)
{
    const char *osname = NULL;

    LoaderAddSymbols(-1, -1, miLookupTab);
    LoaderAddSymbols(-1, -1, xfree86LookupTab);
    LoaderAddSymbols(-1, -1, dixLookupTab);
    LoaderAddSymbols(-1, -1, fontLookupTab);
    LoaderAddSymbols(-1, -1, extLookupTab);
#if defined(__sparc__) && !defined(__FreeBSD__)
#ifdef linux
    if (sparcUseHWMulDiv())
	LoaderAddSymbols(-1, -1, SparcV89LookupTab);
    else
#endif
	LoaderAddSymbols(-1, -1, SparcLookupTab);
#endif

    xf86MsgVerb(X_INFO, 2, "Module ABI versions:\n");
    xf86ErrorFVerb(2, "\t%s: %d.%d\n", ABI_CLASS_ANSIC,
		   GET_ABI_MAJOR(LoaderVersionInfo.ansicVersion),
		   GET_ABI_MINOR(LoaderVersionInfo.ansicVersion));
    xf86ErrorFVerb(2, "\t%s: %d.%d\n", ABI_CLASS_VIDEODRV,
		   GET_ABI_MAJOR(LoaderVersionInfo.videodrvVersion),
		   GET_ABI_MINOR(LoaderVersionInfo.videodrvVersion));
    xf86ErrorFVerb(2, "\t%s : %d.%d\n", ABI_CLASS_XINPUT,
		   GET_ABI_MAJOR(LoaderVersionInfo.xinputVersion),
		   GET_ABI_MINOR(LoaderVersionInfo.xinputVersion));
    xf86ErrorFVerb(2, "\t%s : %d.%d\n", ABI_CLASS_EXTENSION,
		   GET_ABI_MAJOR(LoaderVersionInfo.extensionVersion),
		   GET_ABI_MINOR(LoaderVersionInfo.extensionVersion));
    xf86ErrorFVerb(2, "\t%s : %d.%d\n", ABI_CLASS_FONT,
		   GET_ABI_MAJOR(LoaderVersionInfo.fontVersion),
		   GET_ABI_MINOR(LoaderVersionInfo.fontVersion));

    LoaderGetOS(&osname, NULL, NULL, NULL);
    if (osname)
	xf86MsgVerb(X_INFO, 2, "Loader running on %s\n", osname);

#if defined(linux) && \
    (defined(__alpha__) || defined(__powerpc__) || defined(__ia64__) \
     || ( defined __AMD64__ && ! defined UseMMAP && ! defined DoMMAPedMerge))
    /*
     * The glibc malloc uses mmap for large allocations anyway. This breaks
     * some relocation types because the offset overflow. See loader.h for more
     * details. We need to turn off this behavior here.
     */
    mallopt(M_MMAP_MAX, 0);
#endif
}

/*
 * Determine what type of object is being loaded.
 * This function is responsible for restoring the offset.
 * The fd and offset are used here so that when Archive processing
 * is enabled, individual elements of an archive can be evaluated
 * so the correct loader_funcs can be determined.
 */
static int
_GetModuleType(int fd, long offset)
{
    unsigned char buf[256];	/* long enough for the largest magic type */

    if (read(fd, buf, sizeof(buf)) < 0) {
	return -1;
    }
#ifdef DEBUG
    ErrorF("Checking module type %10s\n", buf);
    ErrorF("Checking module type %x %x %x %x\n", buf[0], buf[1], buf[2],
	   buf[3]);
#endif

    lseek(fd, offset, SEEK_SET);

    if (strncmp((char *)buf, ARMAG, SARMAG) == 0) {
	return LD_ARCHIVE;
    }
#if defined(AIAMAG)
    /* LynxOS PPC style archives */
    if (strncmp((char *)buf, AIAMAG, SAIAMAG) == 0) {
	return LD_ARCHIVE;
    }
#endif

    if (strncmp((char *)buf, ELFMAG, SELFMAG) == 0) {
	if (*((Elf32_Half *) (buf + ELFDLOFF)) == ELFDLMAG) {
	    return LD_ELFDLOBJECT;
	} else {
	    return LD_ELFOBJECT;
	}
    }

    if (buf[0] == 0x4c && buf[1] == 0x01) {
	/* I386MAGIC */
	return LD_COFFOBJECT;
    }
    if (buf[0] == 0x01 && buf[1] == 0xdf) {
	/* XCOFFMAGIC */
	return LD_COFFOBJECT;
    }
    if (buf[0] == 0x0d && buf[1] == 0x01) {
	/* ZCOFFMAGIC (LynxOS) */
	return LD_COFFOBJECT;
    }
    if (buf[0] == 0x00 && buf[1] == 0x86 && buf[2] == 0x01 && buf[3] == 0x07) {
	/* AOUTMAGIC */
	return LD_AOUTOBJECT;
    }
    if (buf[0] == 0x07 && buf[1] == 0x01
	&& (buf[2] == 0x64 || buf[2] == 0x86)) {
	/* AOUTMAGIC, (Linux OMAGIC, old impure format, also used by OS/2 */
	return LD_AOUTOBJECT;
    }
    if (buf[0] == 0x07 && buf[1] == 0x01 && buf[2] == 0x00 && buf[3] == 0x00) {
	/* AOUTMAGIC, BSDI */
	return LD_AOUTOBJECT;
    }
    if ((buf[0] == 0xc0 && buf[1] == 0x86) ||	/* big endian form */
	(buf[3] == 0xc0 && buf[2] == 0x86)) {	/* little endian form */
	/* i386 shared object */
	return LD_AOUTDLOBJECT;
    }

    return LD_UNKNOWN;
}

static int offsetbias = 0;	/* offset into archive */

/*
 * _LoaderFileToMem() loads the contents of a file into memory using
 * the most efficient method for a platform.
 */
void *
_LoaderFileToMem(int fd, unsigned long offset, int size, char *label)
{
#ifdef UseMMAP
    unsigned long ret;

# ifdef MmapPageAlign
    unsigned long pagesize;
    unsigned long new_size;
    unsigned long new_off;
    unsigned long new_off_bias;
# endif
# define MMAP_PROT	(PROT_READ|PROT_WRITE|PROT_EXEC)

# ifdef DEBUGMEM
    ErrorF("_LoaderFileToMem(%d,%u(%u),%d,%s)", fd, offset, offsetbias, size,
	   label);
# endif
# ifdef MmapPageAlign
    pagesize = getpagesize();
    new_size = (size + pagesize - 1) / pagesize;
    new_size *= pagesize;
    new_off = (offset + offsetbias) / pagesize;
    new_off *= pagesize;
    new_off_bias = (offset + offsetbias) - new_off;
    if ((new_off_bias + size) > new_size)
	new_size += pagesize;
    ret = (unsigned long)mmap(0, new_size, MMAP_PROT, MAP_PRIVATE
#  if defined(__AMD64__) || defined(__amd64__)
			      | MAP_32BIT
#  endif
			      , fd, new_off);
    if (ret == -1)
	FatalError("mmap() failed: %s\n", strerror(errno));
    return (void *)(ret + new_off_bias);
# else
    ret = (unsigned long)mmap(0, size, MMAP_PROT, MAP_PRIVATE
#  if defined(__AMD64__) || defined(__amd64__)
			      | MAP_32BIT
#  endif
			      , fd, offset + offsetbias);
    if (ret == -1)
	FatalError("mmap() failed: %s\n", strerror(errno));
    return (void *)ret;
# endif
#else
    char *ptr;

# ifdef DEBUGMEM
    ErrorF("_LoaderFileToMem(%d,%u(%u),%d,%s)", fd, offset, offsetbias, size,
	   label);
# endif

    if (size == 0) {
# ifdef DEBUGMEM
	ErrorF("=NULL\n", ptr);
# endif
	return NULL;
    }
# ifndef __UNIXOS2__
    if ((ptr = xf86loadercalloc(size, 1)) == NULL)
	FatalError("_LoaderFileToMem() malloc failed\n");
# else
    if ((ptr = os2ldcalloc(size, 1)) == NULL)
	FatalError("_LoaderFileToMem() malloc failed\n");
# endif
# if defined(linux) && defined(__ia64__)
    {
	unsigned long page_size = getpagesize();
	unsigned long round;

	round = (unsigned long)ptr & (page_size - 1);
	mprotect(ptr - round,
		 (size + round + page_size - 1) & ~(page_size - 1),
		 PROT_READ | PROT_WRITE | PROT_EXEC);
    }
# endif

    if (lseek(fd, offset + offsetbias, SEEK_SET) < 0)
	FatalError("\n_LoaderFileToMem() lseek() failed: %s\n",
		   strerror(errno));

    if (read(fd, ptr, size) != size)
	FatalError("\n_LoaderFileToMem() read() failed: %s\n",
		   strerror(errno));

# if (defined(linux) || defined(__NetBSD__) || defined(__OpenBSD__)) \
    && defined(__powerpc__)
    /*
     * Keep the instruction cache in sync with changes in the
     * main memory.
     */
    {
	int i;

	for (i = 0; i < size; i += 16)
	    ppc_flush_icache(ptr + i);
	ppc_flush_icache(ptr + size - 1);
    }
# endif

# ifdef DEBUGMEM
    ErrorF("=%lx\n", ptr);
# endif

    return (void *)ptr;
#endif
}

/*
 * _LoaderFreeFileMem() free the memory in which a file was loaded.
 */
void
_LoaderFreeFileMem(void *addr, int size)
{
#if defined (UseMMAP) && defined (MmapPageAlign)
    unsigned long pagesize = getpagesize();
    memType i_addr = (memType) addr;
    unsigned long new_size;
#endif
#ifdef DEBUGMEM
    ErrorF("_LoaderFreeFileMem(%x,%d)\n", addr, size);
#endif
#ifdef UseMMAP
# if defined (MmapPageAlign)
    i_addr /= pagesize;
    i_addr *= pagesize;
    new_size = (size + pagesize - 1) / pagesize;
    new_size *= pagesize;
    if (((memType) addr - i_addr + size) > new_size)
	new_size += pagesize;
    munmap((void *)i_addr, new_size);
# else
    munmap((void *)addr, size);
# endif
#else
    if (size == 0)
	return;

    xf86loaderfree(addr);
#endif

    return;
}

int
_LoaderFileRead(int fd, unsigned int offset, void *buf, int size)
{
    if (lseek(fd, offset + offsetbias, SEEK_SET) < 0)
	FatalError("_LoaderFileRead() lseek() failed: %s\n", strerror(errno));

    if (read(fd, buf, size) != size)
	FatalError("_LoaderFileRead() read() failed: %s\n", strerror(errno));

    return size;
}

static loaderPtr listHead = (loaderPtr) 0;

static loaderPtr
_LoaderListPush()
{
    loaderPtr item = xf86loadercalloc(1, sizeof(struct _loader));

    item->next = listHead;
    listHead = item;

    return item;
}

static loaderPtr
_LoaderListPop(int handle)
{
    loaderPtr item = listHead;
    loaderPtr *bptr = &listHead;	/* pointer to previous node */

    while (item) {
	if (item->handle == handle) {
	    *bptr = item->next;	/* remove this from the list */
	    return item;
	}
	bptr = &(item->next);
	item = item->next;
    }

    return 0;
}

/*
 * _LoaderHandleToName() will return the name of the first module with a
 * given handle. This requires getting the last module on the LIFO with
 * the given handle.
 */
char *
_LoaderHandleToName(int handle)
{
    loaderPtr item = listHead;
    loaderPtr aritem = NULL;
    loaderPtr lastitem = NULL;

    if (handle < 0) {
	return "(built-in)";
    }
    while (item) {
	if (item->handle == handle) {
	    if (strchr(item->name, ':') == NULL)
		aritem = item;
	    else
		lastitem = item;
	}
	item = item->next;
    }

    if (aritem)
	return aritem->name;

    if (lastitem)
	return lastitem->name;

    return 0;
}

/*
 * _LoaderHandleToCanonicalName() will return the cname of the first module
 * with a given handle. This requires getting the last module on the LIFO with
 * the given handle.
 */
char *
_LoaderHandleToCanonicalName(int handle)
{
    loaderPtr item = listHead;
    loaderPtr lastitem = NULL;

    if (handle < 0) {
	return "(built-in)";
    }
    while (item) {
	if (item->handle == handle) {
	    lastitem = item;
	}
	item = item->next;
    }

    if (lastitem)
	return lastitem->cname;

    return NULL;
}

/*
 * _LoaderModuleToName() will return the name of the first module with a
 * given handle. This requires getting the last module on the LIFO with
 * the given handle.
 */
char *
_LoaderModuleToName(int module)
{
    loaderPtr item = listHead;
    loaderPtr aritem = NULL;
    loaderPtr lastitem = NULL;

    if (module < 0) {
	return "(built-in)";
    }
    while (item) {
	if (item->module == module) {
	    if (strchr(item->name, ':') == NULL)
		aritem = item;
	    else
		lastitem = item;
	}
	item = item->next;
    }

    if (aritem)
	return aritem->name;

    if (lastitem)
	return lastitem->name;

    return 0;
}

/*
 * _LoaderAddressToSection() will return the name of the file & section
 * that contains the given address.
 */
int
_LoaderAddressToSection(const unsigned long address, const char **module,
			const char **section)
{
    loaderPtr item = listHead;

    while (item) {
	if ((*section =
	     item->funcs->AddressToSection(item->private, address)) != NULL) {
	    *module = _LoaderModuleToName(item->module);
	    return 1;
	}
	item = item->next;
    }

    return 0;
}

/*
 * Add a list of symbols to the referenced list.
 */

static void
AppendSymbol(symlist * list, const char *sym)
{
    list->list = xnfrealloc(list->list, (list->num + 1) * sizeof(char **));
    list->list[list->num] = sym;
    list->num++;
}

static void
AppendSymList(symlist * list, const char **syms)
{
    while (*syms) {
	AppendSymbol(list, *syms);
	syms++;
    }
}

static int
SymInList(symlist * list, char *sym)
{
    int i;

    for (i = 0; i < list->num; i++)
	if (strcmp(list->list[i], sym) == 0)
	    return 1;

    return 0;
}

void
LoaderVRefSymbols(const char *sym0, va_list args)
{
    const char *s;

    if (sym0 == NULL)
	return;

    s = sym0;
    do {
	AppendSymbol(&refList, s);
	s = va_arg(args, const char *);
    } while (s != NULL);
}

void
LoaderRefSymbols(const char *sym0, ...)
{
    va_list ap;

    va_start(ap, sym0);
    LoaderVRefSymbols(sym0, ap);
    va_end(ap);
}

void
LoaderVRefSymLists(const char **list0, va_list args)
{
    const char **l;

    if (list0 == NULL)
	return;

    l = list0;
    do {
	AppendSymList(&refList, l);
	l = va_arg(args, const char **);
    } while (l != NULL);
}

void
LoaderRefSymLists(const char **list0, ...)
{
    va_list ap;

    va_start(ap, list0);
    LoaderVRefSymLists(list0, ap);
    va_end(ap);
}

void
LoaderVReqSymLists(const char **list0, va_list args)
{
    const char **l;

    if (list0 == NULL)
	return;

    l = list0;
    do {
	AppendSymList(&reqList, l);
	l = va_arg(args, const char **);
    } while (l != NULL);
}

void
LoaderReqSymLists(const char **list0, ...)
{
    va_list ap;

    va_start(ap, list0);
    LoaderVReqSymLists(list0, ap);
    va_end(ap);
}

void
LoaderVReqSymbols(const char *sym0, va_list args)
{
    const char *s;

    if (sym0 == NULL)
	return;

    s = sym0;
    do {
	AppendSymbol(&reqList, s);
	s = va_arg(args, const char *);
    } while (s != NULL);
}

void
LoaderReqSymbols(const char *sym0, ...)
{
    va_list ap;

    va_start(ap, sym0);
    LoaderVReqSymbols(sym0, ap);
    va_end(ap);
}

/* 
 * _LoaderHandleUnresolved() decides what to do with an unresolved
 * symbol.  Symbols that are not on the "referenced" or "required" lists
 * get a warning if they are unresolved.  Symbols that are on the "required"
 * list generate a fatal error if they are unresolved.
 */

int
_LoaderHandleUnresolved(char *symbol, char *module)
{
    int fatalsym = 0;

    if (xf86ShowUnresolved && !fatalsym) {
	if (SymInList(&reqList, symbol)) {
	    fatalReqSym = 1;
	    ErrorF("Required symbol %s from module %s is unresolved!\n",
		   symbol, module);
	}
	if (!SymInList(&refList, symbol)) {
	    ErrorF("Symbol %s from module %s is unresolved!\n",
		   symbol, module);
	}
    }
    return (fatalsym);
}

/*
 * Handle an archive.
 */
void *
ARCHIVELoadModule(loaderPtr modrec, int arfd, LOOKUP ** ppLookup)
{
    loaderPtr tmp = NULL;
    void *ret = NULL;
    unsigned char magic[SARMAG];
    struct ar_hdr hdr;

#if defined(__powerpc__) && defined(Lynx)
    struct fl_hdr fhdr;
    char name[255];
    int namlen;
#endif
    unsigned int size;
    unsigned int offset;
    int arnamesize, modnamesize;
    char *slash, *longname;
    char *nametable = NULL;
    int nametablelen = 0;
    LOOKUP *lookup_ret, *p;
    LOOKUP *myLookup = NULL;	/* Does realloc behave if ptr == 0? */
    int modtype;
    int i;
    int numsyms = 0;

    /* lookup_ret = xf86loadermalloc(sizeof (LOOKUP *)); */

    arnamesize = strlen(modrec->name);

#if !(defined(__powerpc__) && defined(Lynx))
    read(arfd, magic, SARMAG);

    if (strncmp((const char *)magic, ARMAG, SARMAG) != 0) {
	ErrorF("ARCHIVELoadModule: wrong magic!!\n");
	return NULL;
    }
#else
    read(arfd, &fhdr, FL_HSZ);

    if (strncmp(fhdr.fl_magic, AIAMAG, SAIAMAG) != 0) {
	ErrorF("ARCHIVELoadModule: wrong magic!!\n");
	return NULL;
    }
#endif /* __powerpc__ && Lynx */

#ifdef DEBUGAR
    ErrorF("Looking for archive members starting at offset %o\n", offset);
#endif

    while (read(arfd, &hdr, sizeof(struct ar_hdr))) {

	longname = NULL;
	sscanf(hdr.ar_size, "%u", &size);
#if defined(__powerpc__) && defined(Lynx)
	sscanf(hdr.ar_namlen, "%d", &namlen);
	name[0] = hdr.ar_name[0];
	name[1] = hdr.ar_name[1];
	read(arfd, &name[2], namlen);
	name[namlen] = '\0';
	offset = lseek(arfd, 0, SEEK_CUR);
	if (offset & 0x1)	/* odd value */
	    offset = lseek(arfd, 1, SEEK_CUR);	/* make it an even boundary */
#endif
	offset = lseek(arfd, 0, SEEK_CUR);

	/* Check for a Symbol Table */
	if ((hdr.ar_name[0] == '/' && hdr.ar_name[1] == ' ') ||
#if defined(__powerpc__) && defined(Lynx)
	    namlen == 0 ||
#endif
	    strncmp(hdr.ar_name, "__.SYMDEF", 9) == 0) {
	    /* If the file name is NULL, then it is a symbol table */
#ifdef DEBUGAR
	    ErrorF("Symbol Table Member '%16.16s', size %d, offset %d\n",
		   hdr.ar_name, size, offset);
	    ErrorF("Symbol table size %d\n", size);
#endif
	    offset = lseek(arfd, offset + size, SEEK_SET);
	    if (offset & 0x1)	/* odd value */
		offset = lseek(arfd, 1, SEEK_CUR);	/* make it an even boundary */
	    continue;
	}

	/* Check for a String Table */
	if (hdr.ar_name[0] == '/' && hdr.ar_name[1] == '/') {
	    /* If the file name is '/', then it is a string table */
#ifdef DEBUGAR
	    ErrorF("String Table Member '%16.16s', size %d, offset %d\n",
		   hdr.ar_name, size, offset);
	    ErrorF("String table size %d\n", size);
#endif
	    nametablelen = size;
	    nametable = (char *)xf86loadermalloc(nametablelen);
	    read(arfd, nametable, size);
	    offset = lseek(arfd, 0, SEEK_CUR);
	    /* offset=lseek(arfd,offset+size,SEEK_SET); */
	    if (offset & 0x1)	/* odd value */
		offset = lseek(arfd, 1, SEEK_CUR);	/* make it an even boundary */
	    continue;
	}

	if (hdr.ar_name[0] == '/') {
	    /*  SYS V r4 style long member name */
	    int nameoffset = atol(&hdr.ar_name[1]);
	    char *membername;

	    if (!nametable) {
		ErrorF("Missing string table whilst processing %s\n",
		       modrec->name);
		offsetbias = 0;
		return NULL;
	    }
	    if (nameoffset > nametablelen) {
		ErrorF("Invalid string table offset (%s) whilst processing %s\n", hdr.ar_name, modrec->name);
		offsetbias = 0;
		xf86loaderfree(nametable);
		return NULL;
	    }
	    membername = nametable + nameoffset;
	    slash = strchr(membername, '/');
	    if (slash)
		*slash = '\0';
	    longname = xf86loadermalloc(arnamesize + strlen(membername) + 2);
	    strcpy(longname, modrec->name);
	    strcat(longname, ":");
	    strcat(longname, membername);
	} else if (hdr.ar_name[0] == '#' && hdr.ar_name[1] == '1' &&
		   hdr.ar_name[2] == '/') {
	    /* BSD 4.4 style long member name */
	    if (sscanf(hdr.ar_name + 3, "%d", &modnamesize) != 1) {
		ErrorF("Bad archive member %s\n", hdr.ar_name);
		offsetbias = 0;
		return NULL;
	    }
	    /* allocate space for fully qualified name */
	    longname = xf86loadermalloc(arnamesize + modnamesize + 2);
	    strcpy(longname, modrec->name);
	    strcat(longname, ":");
	    i = read(arfd, longname + modnamesize + 1, modnamesize);
	    if (i != modnamesize) {
		ErrorF("Bad archive member %s\n", hdr.ar_name);
		xf86loaderfree(longname);
		offsetbias = 0;
		return NULL;
	    }
	    longname[i] = '\0';
	    offset += i;
	    size -= i;
	} else {
	    /* Regular archive member */
#ifdef DEBUGAR
	    ErrorF("Member '%16.16s', size %d, offset %x\n",
#if !(defined(__powerpc__) && defined(Lynx))
		   hdr.ar_name,
#else
		   name,
#endif
		   size, offset);
#endif

	    slash = strchr(hdr.ar_name, '/');
	    if (slash == NULL) {
		/* BSD format without trailing slash */
		slash = strchr(hdr.ar_name, ' ');
	    }
	    /* SM: Make sure we do not overwrite other parts of struct */

	    if ((slash - hdr.ar_name) > sizeof(hdr.ar_name))
		slash = hdr.ar_name + sizeof(hdr.ar_name) - 1;
	    *slash = '\000';
	}
	if ((modtype = _GetModuleType(arfd, offset)) < 0) {
	    ErrorF("%s is an unrecognized module type\n", hdr.ar_name);
	    offsetbias = 0;
	    if (nametable)
		xf86loaderfree(nametable);
	    return NULL;
	}

	tmp = _LoaderListPush();

	tmp->handle = modrec->handle;
	tmp->module = moduleseq++;
	tmp->cname = xf86loadermalloc(strlen(modrec->cname) + 1);
	strcpy(tmp->cname, modrec->cname);
	tmp->funcs = &funcs[modtype];
	if (longname == NULL) {
	    modnamesize = strlen(hdr.ar_name);
	    tmp->name =
		    (char *)xf86loadermalloc(arnamesize + modnamesize + 2);
	    strcpy(tmp->name, modrec->name);
	    strcat(tmp->name, ":");
	    strcat(tmp->name, hdr.ar_name);

	} else {
	    tmp->name = longname;
	}
	offsetbias = offset;

	if ((tmp->private = funcs[modtype].LoadModule(tmp, arfd, &lookup_ret))
	    == NULL) {
	    ErrorF("Failed to load %s\n", hdr.ar_name);
	    offsetbias = 0;
	    if (nametable)
		xf86loaderfree(nametable);
	    return NULL;
	}

	offset = lseek(arfd, offset + size, SEEK_SET);
	if (offset & 0x1)	/* odd value */
	    lseek(arfd, 1, SEEK_CUR);	/* make it an even boundary */

	if (tmp->private == (void *)-1L) {
	    ErrorF("Skipping \"%s\":  No symbols found\n", tmp->name);
	    continue;
	} else
	    ret = tmp->private;

	/* Add the lookup table returned from funcs.LoadModule to the
	 * one we're going to return.
	 */
	for (i = 0, p = lookup_ret; p && p->symName; i++, p++) ;
	if (i) {
	    myLookup = xf86loaderrealloc(myLookup, (numsyms + i + 1)
					 * sizeof(LOOKUP));
	    if (!myLookup)
		continue;	/* Oh well! */

	    memcpy(&(myLookup[numsyms]), lookup_ret, i * sizeof(LOOKUP));
	    numsyms += i;
	    myLookup[numsyms].symName = 0;
	}
	xf86loaderfree(lookup_ret);
    }
    /* xf86loaderfree(lookup_ret); */
    offsetbias = 0;

    *ppLookup = myLookup;
    if (nametable)
	xf86loaderfree(nametable);

    return ret;
}

/*
 * Relocation list manipulation routines
 */

/*
 * _LoaderGetRelocations() Return the list of outstanding relocations
 */
LoaderRelocPtr
_LoaderGetRelocations(void *mod)
{
    loader_funcs *formatrec = (loader_funcs *) mod;

    return &(formatrec->pRelocs);
}

/*
 * Public Interface to the loader.
 */

int
LoaderOpen(const char *module, const char *cname, int handle,
	   int *errmaj, int *errmin, int *wasLoaded)
{
    loaderPtr tmp;
    int new_handle, modtype;
    int fd;
    LOOKUP *pLookup;

#if defined(DEBUG)
    ErrorF("LoaderOpen(%s)\n", module);
#endif

    /*
     * Check to see if the module is already loaded.
     * Only if we are loading it into an existing namespace.
     * If it is to be loaded into a new namespace, don't check.
     * Note: We only have one namespace.
     */
    if (handle >= 0) {
	tmp = listHead;
	while (tmp) {
#ifdef DEBUGLIST
	    ErrorF("strcmp(%x(%s),{%x} %x(%s))\n", module, module,
		   &(tmp->name), tmp->name, tmp->name);
#endif
	    if (!strcmp(module, tmp->name)) {
		refCount[tmp->handle]++;
		if (wasLoaded)
		    *wasLoaded = 1;
		xf86MsgVerb(X_INFO, 2, "Reloading %s\n", module);
		return tmp->handle;
	    }
	    tmp = tmp->next;
	}
    }

    /*
     * OK, it's a new one. Add it.
     */
    xf86Msg(X_INFO, "Loading %s\n", module);
    if (wasLoaded)
	*wasLoaded = 0;

    /*
     * Find a free handle.
     */
    new_handle = 1;
    while (freeHandles[new_handle] && new_handle < MAX_HANDLE)
	new_handle++;

    if (new_handle == MAX_HANDLE) {
	xf86Msg(X_ERROR, "Out of loader space\n");	/* XXX */
	if (errmaj)
	    *errmaj = LDR_NOSPACE;
	if (errmin)
	    *errmin = LDR_NOSPACE;
	return -1;
    }

    freeHandles[new_handle] = HANDLE_USED;
    refCount[new_handle] = 1;

    if ((fd = open(module, O_RDONLY)) < 0) {
	xf86Msg(X_ERROR, "Unable to open %s\n", module);
	freeHandles[new_handle] = HANDLE_FREE;
	if (errmaj)
	    *errmaj = LDR_NOMODOPEN;
	if (errmin)
	    *errmin = errno;
	return -1;
    }

    if ((modtype = _GetModuleType(fd, 0)) < 0) {
	xf86Msg(X_ERROR, "%s is an unrecognized module type\n", module);
	freeHandles[new_handle] = HANDLE_FREE;
	if (errmaj)
	    *errmaj = LDR_UNKTYPE;
	if (errmin)
	    *errmin = LDR_UNKTYPE;
	return -1;
    }

    tmp = _LoaderListPush();
    tmp->name = xf86loadermalloc(strlen(module) + 1);
    strcpy(tmp->name, module);
    tmp->cname = xf86loadermalloc(strlen(cname) + 1);
    strcpy(tmp->cname, cname);
    tmp->handle = new_handle;
    tmp->module = moduleseq++;
    tmp->funcs = &funcs[modtype];

    if ((tmp->private = funcs[modtype].LoadModule(tmp, fd, &pLookup)) == NULL) {
	xf86Msg(X_ERROR, "Failed to load %s\n", module);
	_LoaderListPop(new_handle);
	freeHandles[new_handle] = HANDLE_FREE;
	if (errmaj)
	    *errmaj = LDR_NOLOAD;
	if (errmin)
	    *errmin = LDR_NOLOAD;
	return -1;
    }

    if (tmp->private != (void *)-1L) {
	LoaderAddSymbols(new_handle, tmp->module, pLookup);
	xf86loaderfree(pLookup);
    }

    close(fd);

    return new_handle;
}

int
LoaderHandleOpen(int handle)
{
    if (handle < 0 || handle >= MAX_HANDLE)
	return -1;

    if (freeHandles[handle] != HANDLE_USED)
	return -1;

    refCount[handle]++;
    return handle;
}

void *
LoaderSymbol(const char *sym)
{
    int i;
    itemPtr item = NULL;

    for (i = 0; i < numloaders; i++)
	funcs[i].ResolveSymbols(&funcs[i]);

    item = (itemPtr) LoaderHashFind(sym);

    if (item)
	return item->address;
    else
#ifdef DLOPEN_SUPPORT
	return (DLFindSymbol(sym));
#else
	return NULL;
#endif
}

int
LoaderResolveSymbols(void)
{
    int i;

    for (i = 0; i < numloaders; i++)
	funcs[i].ResolveSymbols(&funcs[i]);
    return 0;
}

int
LoaderCheckUnresolved(int delay_flag)
{
    int i, ret = 0;
    LoaderResolveOptions delayFlag = (LoaderResolveOptions)delay_flag;

    LoaderResolveSymbols();

    if (delayFlag == LD_RESOLV_NOW) {
	if (check_unresolved_sema > 0)
	    check_unresolved_sema--;
	else
	    xf86Msg(X_WARNING, "LoaderCheckUnresolved: not enough "
		    "MAGIC_DONT_CHECK_UNRESOLVED\n");
    }

    if (!check_unresolved_sema || delayFlag == LD_RESOLV_FORCE)
	for (i = 0; i < numloaders; i++)
	    if (funcs[i].CheckForUnresolved(&funcs[i]))
		ret = 1;

    if (fatalReqSym)
	FatalError("Some required symbols were unresolved\n");

    return ret;
}

void xf86LoaderTrap(void);

void
xf86LoaderTrap(void)
{
}

void
LoaderDefaultFunc(void)
{
    ErrorF("\n\n\tThis should not happen!\n"
	   "\tAn unresolved function was called!\n");

    xf86LoaderTrap();

    FatalError("\n");
}

int
LoaderUnload(int handle)
{
    loaderRec fakeHead;
    loaderPtr tmp = &fakeHead;

    if (handle < 0 || handle > MAX_HANDLE)
	return -1;

    /*
     * check the reference count, only free it if it goes to zero
     */
    if (--refCount[handle])
	return 0;
    /*
     * find the loaderRecs associated with this handle.
     */

    while ((tmp = _LoaderListPop(handle)) != NULL) {
	if (strchr(tmp->name, ':') == NULL) {
	    /* It is not a member of an archive */
	    xf86Msg(X_INFO, "Unloading %s\n", tmp->name);
	}
	tmp->funcs->LoaderUnload(tmp->private);
	xf86loaderfree(tmp->name);
	xf86loaderfree(tmp->cname);
	xf86loaderfree(tmp);
    }

    freeHandles[handle] = HANDLE_FREE;

    return 0;
}

void
LoaderDuplicateSymbol(const char *symbol, const int handle)
{
    ErrorF("Duplicate symbol %s in %s\n", symbol,
	   listHead ? listHead->name : "(built-in)");
    ErrorF("Also defined in %s\n", _LoaderHandleToName(handle));
    FatalError("Module load failure\n");
}

/* GDB Sync function */
void
_loader_debug_state()
{
}

unsigned long LoaderOptions = 0;

void
LoaderResetOptions(void)
{
    LoaderOptions = 0;
}

void
LoaderSetOptions(unsigned long opts)
{
    LoaderOptions |= opts;
}

void
LoaderClearOptions(unsigned long opts)
{
    LoaderOptions &= ~opts;
}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/loader.c,v 1.55 2001/10/28 03:33:59 tsi Exp $ */
a3 1
 *
d24 47
d83 2
a84 1
    (defined(__alpha__) || defined(__powerpc__) || defined(__ia64__))
d121 2
a122 2
#ifdef __EMX__
void * os2ldcalloc(size_t,size_t);
d133 2
a134 2
static char freeHandles[MAX_HANDLE] ;
static int refCount[MAX_HANDLE] ;
d137 1
a137 1
#if defined(__sparc__) && defined(__GNUC__)
d157 7
a163 7
   SYMFUNCDOT89(rem)
   SYMFUNCDOT89(urem)
   SYMFUNCDOT89(mul)
   SYMFUNCDOT89(umul)
   SYMFUNCDOT89(div)
   SYMFUNCDOT89(udiv)
   { 0, 0 }
d167 7
a173 7
   SYMFUNCDOT(rem)
   SYMFUNCDOT(urem)
   SYMFUNCDOT(mul)
   SYMFUNCDOT(umul)
   SYMFUNCDOT(div)
   SYMFUNCDOT(udiv)
   { 0, 0 }
d175 1
d188 1
d191 1
d193 1
a193 1
    
d195 1
a195 1
    __asm("" : "=r" (hwcap) : "0" (hwcap));
d197 4
a200 4
        if (*hwcap & HWCAP_SPARC_MULDIV)
    	    return 1;
    	else
    	    return 0;
d203 3
a205 2
    f = fopen("/proc/cpuinfo","r");
    if (!f) return 0;
d207 7
a213 7
        if (!strncmp (buffer, "type", 4)) {
            p = strstr (buffer, "sun4");
            if (p && (p[4] == 'u' || p[4] == 'd' || p[4] == 'm')) {
                fclose(f);
                return 1;
            }
        }
d244 2
a245 2
    int			num;
    const char **	list;
d263 18
a280 9
/*ARGSUSED*/
static void ARCHIVEResolveSymbols(void *unused) {}
/*ARGSUSED*/
static int ARCHIVECheckForUnresolved(void *v) { return 0; }
/*ARGSUSED*/
static char *ARCHIVEAddressToSection(void *modptr, unsigned long address)
{ return NULL; }
/*ARGSUSED*/
static void ARCHIVEUnload(void *unused2) {}
d287 31
a317 31
	/* LD_ARCHIVE */
	{ARCHIVELoadModule,
	 ARCHIVEResolveSymbols,
	 ARCHIVECheckForUnresolved,
	 ARCHIVEAddressToSection,
	 ARCHIVEUnload, {0,0,0,0,0}},
	/* LD_ELFOBJECT */
	{ELFLoadModule,
	 ELFResolveSymbols,
	 ELFCheckForUnresolved,
	 ELFAddressToSection,
	 ELFUnloadModule, {0,0,0,0,0}},
	/* LD_COFFOBJECT */
	{COFFLoadModule,
	 COFFResolveSymbols,
	 COFFCheckForUnresolved,
	 COFFAddressToSection,
	 COFFUnloadModule, {0,0,0,0,0}},
	/* LD_XCOFFOBJECT */
	{COFFLoadModule,
	 COFFResolveSymbols,
	 COFFCheckForUnresolved,
	 COFFAddressToSection,
	 COFFUnloadModule, {0,0,0,0,0}},
	/* LD_AOUTOBJECT */
	{AOUTLoadModule,
	 AOUTResolveSymbols,
	 AOUTCheckForUnresolved,
	 AOUTAddressToSection,
	 AOUTUnloadModule, {0,0,0,0,0}},
	/* LD_AOUTDLOBJECT */
d319 5
a323 5
	{DLLoadModule,
	 DLResolveSymbols,
	 DLCheckForUnresolved,
	 ARCHIVEAddressToSection,
	 DLUnloadModule, {0,0,0,0,0}},
d325 5
a329 5
	{AOUTLoadModule,
	 AOUTResolveSymbols,
	 AOUTCheckForUnresolved,
	 AOUTAddressToSection,
	 AOUTUnloadModule, {0,0,0,0,0}},
d331 1
a331 1
	/* LD_ELFDLOBJECT */
d333 5
a337 5
	{DLLoadModule,
	 DLResolveSymbols,
	 DLCheckForUnresolved,
	 ARCHIVEAddressToSection,
	 DLUnloadModule, {0,0,0,0,0}},
d339 5
a343 5
	{ELFLoadModule,
	 ELFResolveSymbols,
	 ELFCheckForUnresolved,
	 ELFAddressToSection,
	 ELFUnloadModule, {0,0,0,0,0}},
d345 1
a345 3
	};

int	numloaders=sizeof(funcs)/sizeof(loader_funcs);
d347 1
d354 6
a359 6
    LoaderAddSymbols(-1, -1, miLookupTab ) ;
    LoaderAddSymbols(-1, -1, xfree86LookupTab ) ;
    LoaderAddSymbols(-1, -1, dixLookupTab ) ;
    LoaderAddSymbols(-1, -1, fontLookupTab ) ;
    LoaderAddSymbols(-1, -1, extLookupTab );
#ifdef __sparc__
d362 1
a362 1
	LoaderAddSymbols(-1, -1, SparcV89LookupTab ) ;
d365 2
a366 2
	LoaderAddSymbols(-1, -1, SparcLookupTab ) ;
#endif 
d370 2
a371 2
			GET_ABI_MAJOR(LoaderVersionInfo.ansicVersion),
			GET_ABI_MINOR(LoaderVersionInfo.ansicVersion));
d373 2
a374 2
			GET_ABI_MAJOR(LoaderVersionInfo.videodrvVersion),
			GET_ABI_MINOR(LoaderVersionInfo.videodrvVersion));
d376 2
a377 2
			GET_ABI_MAJOR(LoaderVersionInfo.xinputVersion),
			GET_ABI_MINOR(LoaderVersionInfo.xinputVersion));
d379 2
a380 2
			GET_ABI_MAJOR(LoaderVersionInfo.extensionVersion),
			GET_ABI_MINOR(LoaderVersionInfo.extensionVersion));
d382 2
a383 2
			GET_ABI_MAJOR(LoaderVersionInfo.fontVersion),
			GET_ABI_MINOR(LoaderVersionInfo.fontVersion));
d390 2
a391 1
    (defined(__alpha__) || defined(__powerpc__) || defined(__ia64__))
d397 1
a397 1
    mallopt(M_MMAP_MAX,0);
d411 1
a411 1
    unsigned char	buf[256]; /* long enough for the largest magic type */
d413 1
a413 1
    if( read(fd,buf,sizeof(buf)) < 0 ) {
a415 1

d417 3
a419 2
    ErrorF("Checking module type %10s\n", buf );
    ErrorF("Checking module type %x %x %x %x\n", buf[0], buf[1], buf[2], buf[3] );
d422 1
a422 1
    lseek(fd,offset,SEEK_SET);
d424 1
a424 1
    if (strncmp((char *) buf, ARMAG, SARMAG) == 0) {
a426 1

d429 1
a429 1
    if (strncmp((char *) buf, AIAMAG, SAIAMAG) == 0) {
d434 2
a435 2
    if (strncmp((char *) buf, ELFMAG, SELFMAG) == 0) {
	if( *((Elf32_Half *)(buf + ELFDLOFF)) == ELFDLMAG ) {
d442 1
a442 1
    if( buf[0] == 0x4c && buf[1] == 0x01 ) {
d446 1
a446 1
    if( buf[0] == 0x01 && buf[1] == 0xdf ) {
d449 2
a450 2
	}
    if( buf[0] == 0x0d && buf[1] == 0x01 ) {
d454 17
a470 18
    if( buf[0] == 0x00 && buf[1] == 0x86 && buf[2] == 0x01 && buf[3] == 0x07) {
        /* AOUTMAGIC */
        return LD_AOUTOBJECT;
    }
    if (buf[0] == 0x07 && buf[1] == 0x01 && (buf[2] == 0x64 || buf[2] == 0x86))
    {
        /* AOUTMAGIC, (Linux OMAGIC, old impure format, also used by OS/2 */
        return LD_AOUTOBJECT;
    }
    if (buf[0] == 0x07 && buf[1] == 0x01 && buf[2] == 0x00 && buf[3] == 0x00)
    {
        /* AOUTMAGIC, BSDI */
        return LD_AOUTOBJECT;
    }
    if ((buf[0] == 0xc0 && buf[1] == 0x86) || /* big endian form */
	(buf[3] == 0xc0 && buf[2] == 0x86)) { /* little endian form */
        /* i386 shared object */
        return LD_AOUTDLOBJECT;
d476 1
a477 1
static int	offsetbias=0; /* offset into archive */
d483 1
a483 1
_LoaderFileToMem(int fd, unsigned long offset,int size, char *label)
d486 1
a486 12
    unsigned long ret;	
#define MMAP_PROT	(PROT_READ|PROT_WRITE|PROT_EXEC)

#ifdef DEBUGMEM
    ErrorF("_LoaderFileToMem(%d,%u(%u),%d,%s)",fd,offset,offsetbias,size,label);
#endif

    ret = (unsigned long) mmap(0,size,MMAP_PROT,MAP_PRIVATE,
			       fd,offset+offsetbias);

    if(ret == -1)
	FatalError("mmap() failed: %s\n", strerror(errno) );
d488 37
d526 1
d530 9
a538 8
#ifdef DEBUGMEM
    ErrorF("_LoaderFileToMem(%d,%u(%u),%d,%s)",fd,offset,offsetbias,size,label);
#endif

    if(size == 0){
#ifdef DEBUGMEM
	ErrorF("=NULL\n",ptr);
#endif
d541 8
a548 9

#ifndef __EMX__
    if( (ptr=xf86loadercalloc(size,1)) == NULL )
	FatalError("_LoaderFileToMem() malloc failed\n" );
#else
    if( (ptr=os2ldcalloc(size,1)) == NULL )
	FatalError("_LoaderFileToMem() malloc failed\n" );
#endif
#if defined(linux) && defined(__ia64__)
d553 14
a566 5
	round = (unsigned long)ptr & (page_size-1);
	mprotect(ptr - round, (size+round+page_size-1) & ~(page_size-1),
		 PROT_READ|PROT_WRITE|PROT_EXEC);
    }
#endif
d568 2
a569 7
    if(lseek(fd,offset+offsetbias,SEEK_SET)<0)
	FatalError("\n_LoaderFileToMem() lseek() failed: %s\n",strerror(errno));

    if(read(fd,ptr,size)!=size)
	FatalError("\n_LoaderFileToMem() read() failed: %s\n",strerror(errno));

#if (defined(linux) || defined __OpenBSD__) && defined(__powerpc__) 
d574 8
a581 7
    { 
	int i; 
	for (i = 0; i < size; i += 16) 
	    ppc_flush_icache(ptr+i); 
	ppc_flush_icache(ptr+size-1); 
    } 
#endif
d583 3
a585 3
#ifdef DEBUGMEM
    ErrorF("=%lx\n",ptr);
#endif
d597 5
d603 1
a603 1
    ErrorF("_LoaderFreeFileMem(%x,%d)\n",addr,size);
d606 11
a616 1
    munmap(addr,size);
d618 1
a618 1
    if(size == 0)
d630 2
a631 2
    if(lseek(fd,offset+offsetbias,SEEK_SET)<0)
	FatalError("_LoaderFileRead() lseek() failed: %s\n", strerror(errno) );
d633 2
a634 2
    if(read(fd,buf,size)!=size)
	FatalError("_LoaderFileRead() read() failed: %s\n", strerror(errno) );
d639 1
a639 1
static loaderPtr listHead = (loaderPtr) 0 ;
d644 4
a647 3
  loaderPtr item = xf86loadercalloc(1, sizeof (struct _loader));
  item->next = listHead ;
  listHead = item;
d649 1
a649 1
  return item;
d655 2
a656 2
  loaderPtr item=listHead;
  loaderPtr *bptr=&listHead; /* pointer to previous node */
d658 3
a660 3
  while(item) {
	if( item->handle == handle ) {
	    *bptr=item->next;	/* remove this from the list */
a661 3
	    }
	bptr=&(item->next);
	item=item->next;
d663 3
d667 1
a667 1
  return 0;
d678 3
a680 3
  loaderPtr item=listHead;
  loaderPtr aritem=NULL;
  loaderPtr lastitem=NULL;
d682 1
a682 1
  if ( handle < 0 ) {
d684 5
a688 5
	}
  while(item) {
	if( item->handle == handle ) {
	    if( strchr(item->name,':') == NULL )
		aritem=item;
d690 1
a690 3
		lastitem=item;
	    }
	item=item->next;
d692 2
d695 2
a696 2
  if( aritem )
    return aritem->name;
d698 2
a699 2
  if( lastitem )
    return lastitem->name;
d701 1
a701 1
  return 0;
d712 2
a713 2
  loaderPtr item=listHead;
  loaderPtr lastitem=NULL;
d715 1
a715 1
  if ( handle < 0 ) {
d717 4
a720 4
  }
  while(item) {
	if( item->handle == handle ) {
		lastitem=item;
d722 2
a723 2
	item=item->next;
  }
d725 2
a726 2
  if( lastitem )
    return lastitem->cname;
d728 1
a728 1
  return NULL;
d739 3
a741 3
  loaderPtr item=listHead;
  loaderPtr aritem=NULL;
  loaderPtr lastitem=NULL;
d743 1
a743 1
  if ( module < 0 ) {
d745 5
a749 5
  }
  while(item) {
	if( item->module == module ) {
	    if( strchr(item->name,':') == NULL )
		aritem=item;
d751 1
a751 1
		lastitem=item;
d753 2
a754 2
	item=item->next;
  }
d756 2
a757 2
  if( aritem )
    return aritem->name;
d759 2
a760 2
  if( lastitem )
    return lastitem->name;
d762 1
a762 1
  return 0;
d771 1
a771 1
			const char ** section)
d773 1
a773 1
  loaderPtr item=listHead;
d775 5
a779 4
  while(item) {
	if( (*section=item->funcs->AddressToSection(item->private, address)) != NULL ) {
		*module=_LoaderModuleToName(item->module);
		return 1;
d781 2
a782 2
	item=item->next;
  }
d784 1
a784 1
  return 0;
a786 1

d792 1
a792 1
AppendSymbol(symlist *list, const char *sym)
d800 1
a800 1
AppendSymList(symlist *list, const char **syms)
d809 1
a809 1
SymInList(symlist *list, char *sym)
d826 1
a826 1
        return;
d830 2
a831 2
        AppendSymbol(&refList, s);
        s = va_arg(args, const char *);
d943 1
a943 1
    return(fatalsym);
d950 1
a950 1
ARCHIVELoadModule(loaderPtr modrec, int arfd, LOOKUP **ppLookup)
d953 4
a956 2
    unsigned char	magic[SARMAG];
    struct ar_hdr	hdr;
d958 10
a967 10
    struct fl_hdr	fhdr;
    char		name[255];
    int			namlen;
#endif
    unsigned int	size;
    unsigned int	offset;
    int	arnamesize, modnamesize;
    char	*slash, *longname;
    char		*nametable = NULL;
    int  		nametablelen = 0;
d969 1
a969 1
    LOOKUP *myLookup = NULL; /* Does realloc behave if ptr == 0? */
a972 1
    int resetoff;
d976 1
a976 1
    arnamesize=strlen(modrec->name);
d979 1
a979 1
    read(arfd,magic,SARMAG);
d981 2
a982 2
    if(strncmp((const char *)magic,ARMAG,SARMAG) != 0 ) {
	ErrorF("ARCHIVELoadModule: wrong magic!!\n" );
a984 1
    resetoff=SARMAG;
d986 1
a986 1
    read(arfd,&fhdr,FL_HSZ);
d988 2
a989 2
    if(strncmp(fhdr.fl_magic,AIAMAG,SAIAMAG) != 0 ) {
	ErrorF("ARCHIVELoadModule: wrong magic!!\n" );
a991 1
    resetoff=FL_HSZ;
d995 1
a995 1
    ErrorF("Looking for archive members starting at offset %o\n", offset );
d998 1
a998 1
    while( read(arfd,&hdr,sizeof(struct ar_hdr)) ) {
d1001 1
a1001 1
	sscanf(hdr.ar_size,"%d",&size);
d1003 8
a1010 8
	sscanf(hdr.ar_namlen,"%d",&namlen);
	name[0]=hdr.ar_name[0];
	name[1]=hdr.ar_name[1];
	read(arfd,&name[2],namlen);
	name[namlen]='\0';
	offset=lseek(arfd,0,SEEK_CUR);
	if( offset&0x1 ) /* odd value */
		offset=lseek(arfd,1,SEEK_CUR); /* make it an even boundary */
d1012 1
a1012 1
	offset=lseek(arfd,0,SEEK_CUR);
d1015 1
a1015 1
	if( (hdr.ar_name[0] == '/' && hdr.ar_name[1] == ' ') ||
d1019 1
a1019 1
	    strncmp(hdr.ar_name, "__.SYMDEF", 9) == 0 ) {
d1023 2
a1024 2
	           hdr.ar_name, size, offset );
	    ErrorF("Symbol table size %d\n", size );
d1026 3
a1028 3
	    offset=lseek(arfd,offset+size,SEEK_SET);
	    if( offset&0x1 ) /* odd value */
	        offset=lseek(arfd,1,SEEK_CUR); /* make it an even boundary */
d1033 1
a1033 1
	if( hdr.ar_name[0] == '/' && hdr.ar_name[1] == '/') { 
d1037 2
a1038 2
	           hdr.ar_name, size, offset );
	    ErrorF("String table size %d\n", size );
d1041 1
a1041 1
	    nametable=(char *)xf86loadermalloc(nametablelen);
d1043 1
a1043 1
	    offset=lseek(arfd,0,SEEK_CUR);
d1045 2
a1046 2
	    if( offset&0x1 ) /* odd value */
		    offset=lseek(arfd,1,SEEK_CUR); /* make it an even boundary */
d1054 1
d1056 2
a1057 2
		ErrorF( "Missing string table whilst processing %s\n", 
			modrec->name ) ;
d1062 1
a1062 2
		ErrorF( "Invalid string table offset (%s) whilst processing %s\n", 
			hdr.ar_name, modrec->name ) ;
d1068 1
a1068 1
	    slash=strchr(membername,'/');
d1072 3
a1074 3
	    strcpy(longname,modrec->name);
	    strcat(longname,":");
	    strcat(longname,membername);
d1078 1
a1078 1
            if (sscanf(hdr.ar_name+3, "%d", &modnamesize) != 1) {
d1085 3
a1087 3
	    strcpy(longname,modrec->name);
	    strcat(longname,":");
	    i = read(arfd, longname+modnamesize+1, modnamesize);
d1089 1
a1089 1
		ErrorF("Bad archive member %d\n", hdr.ar_name);
d1093 1
a1093 1
	    }               
d1097 1
a1097 1
	 } else {
d1106 1
a1106 1
		   size, offset );
d1109 1
a1109 1
	    slash=strchr(hdr.ar_name,'/');
d1112 2
a1113 2
		slash = strchr(hdr.ar_name,' ');
	    } 
d1115 4
a1118 4
        
	    if((slash - hdr.ar_name) > sizeof(hdr.ar_name)) 
                slash = hdr.ar_name + sizeof(hdr.ar_name) -1;
	    *slash='\000';
d1120 3
a1122 3
	if( (modtype=_GetModuleType(arfd,offset)) < 0 ) {
	    ErrorF( "%s is an unrecognized module type\n", hdr.ar_name ) ;
	    offsetbias=0;
d1128 1
a1128 1
	tmp=_LoaderListPush();
d1134 1
a1134 1
	tmp->funcs=&funcs[modtype];
d1136 7
a1142 6
	    modnamesize=strlen(hdr.ar_name);
	    tmp->name=(char *)xf86loadermalloc(arnamesize+modnamesize+2 );
	    strcpy(tmp->name,modrec->name);
	    strcat(tmp->name,":");
	    strcat(tmp->name,hdr.ar_name);
	    
d1146 1
a1146 1
	offsetbias=offset;
d1148 4
a1151 5
	if((tmp->private = funcs[modtype].LoadModule(tmp, arfd,
						     &lookup_ret))
	   == NULL) {
	    ErrorF( "Failed to load %s\n", hdr.ar_name ) ;
	    offsetbias=0;
d1157 9
a1165 3
	offset=lseek(arfd,offset+size,SEEK_SET);
	if( offset&0x1 ) /* odd value */
		lseek(arfd,1,SEEK_CUR); /* make it an even boundary */
d1170 1
a1170 2
	for (i = 0, p = lookup_ret; p && p->symName; i++, p++)
	    ;
d1173 1
a1173 1
					   * sizeof (LOOKUP));
d1175 1
a1175 1
		continue; /* Oh well! */
d1177 1
a1177 1
	    memcpy(&(myLookup[numsyms]), lookup_ret, i * sizeof (LOOKUP));
d1184 1
a1184 1
    offsetbias=0;
d1190 1
a1190 4
    if (tmp)
	return tmp->private;
    else
	return 0;
d1203 1
a1203 1
	loader_funcs	*formatrec = (loader_funcs *)mod;
d1205 1
a1205 1
	return  &(formatrec->pRelocs);
d1216 2
a1217 2
    loaderPtr tmp ;
    int new_handle, modtype ;
d1222 1
a1222 1
    ErrorF("LoaderOpen(%s)\n", module );
d1233 1
a1233 1
	while ( tmp ) {
d1235 2
a1236 2
	    ErrorF("strcmp(%x(%s),{%x} %x(%s))\n", module,module,&(tmp->name),
		   tmp->name,tmp->name );
d1238 1
a1238 1
	    if ( ! strcmp( module, tmp->name )) {
d1245 1
a1245 1
	    tmp = tmp->next ;
d1252 1
a1252 1
    xf86Msg(X_INFO, "Loading %s\n", module ) ;
d1260 2
a1261 2
    while ( freeHandles[new_handle] && new_handle < MAX_HANDLE )
	new_handle ++ ;
d1263 7
a1269 4
    if ( new_handle == MAX_HANDLE ) {
	xf86Msg(X_ERROR, "Out of loader space\n" ) ; /* XXX */
	if(errmaj) *errmaj = LDR_NOSPACE;
	return -1 ;
d1272 1
a1272 1
    freeHandles[new_handle] = HANDLE_USED ;
d1275 8
a1282 6
    if( (fd=open(module, O_RDONLY)) < 0 ) {
	xf86Msg(X_ERROR, "Unable to open %s\n", module );
	freeHandles[new_handle] = HANDLE_FREE ;
	if(errmaj) *errmaj = LDR_NOMODOPEN;
	if(errmin) *errmin = errno;
	return -1 ;
d1285 7
a1291 4
    if( (modtype=_GetModuleType(fd,0)) < 0 ) {
	xf86Msg(X_ERROR, "%s is an unrecognized module type\n", module ) ;
        freeHandles[new_handle] = HANDLE_FREE ;
	if(errmaj) *errmaj = LDR_UNKTYPE;
d1295 1
a1295 1
    tmp=_LoaderListPush();
d1302 1
a1302 1
    tmp->funcs=&funcs[modtype];
d1304 2
a1305 2
    if((tmp->private = funcs[modtype].LoadModule(tmp,fd, &pLookup)) == NULL) {
	xf86Msg(X_ERROR, "Failed to load %s\n", module ) ;
d1307 5
a1311 2
        freeHandles[new_handle] = HANDLE_FREE ;
	if(errmaj) *errmaj = LDR_NOLOAD;
d1315 4
a1318 2
    LoaderAddSymbols(new_handle, tmp->module, pLookup);
    xf86loaderfree(pLookup);
d1343 1
d1349 2
a1350 2
    if ( item )
	return item->address ;
d1353 1
a1353 1
	return(DLFindSymbol(sym));
d1363 2
a1364 1
    for(i=0;i<numloaders;i++)
d1370 1
a1370 1
LoaderCheckUnresolved(int delay_flag )
d1372 4
a1375 2
  int i,ret=0;
  LoaderResolveOptions delayFlag = delay_flag;
d1377 7
a1383 1
  LoaderResolveSymbols();
d1385 4
a1388 12
  if (delayFlag == LD_RESOLV_NOW) {
     if (check_unresolved_sema > 0) 
	check_unresolved_sema--;
     else 
	xf86Msg(X_WARNING, "LoaderCheckUnresolved: not enough "
		"MAGIC_DONT_CHECK_UNRESOLVED\n");
  }

  if (!check_unresolved_sema ||  delayFlag == LD_RESOLV_FORCE)
	for(i=0;i<numloaders;i++)
	   if (funcs[i].CheckForUnresolved(&funcs[i]))
		ret=1;
d1390 2
a1391 2
  if (fatalReqSym)
    FatalError("Some required symbols were unresolved\n");
d1393 1
a1393 1
  return ret;
d1406 4
a1409 2
	ErrorF("\n\n\tThis should not happen!\n"
		"\tAn unresolved function was called!\n");
d1411 1
a1411 3
	xf86LoaderTrap();
	
	FatalError("\n");
d1417 2
a1418 2
  loaderRec fakeHead ;
  loaderPtr tmp = & fakeHead ;
d1420 1
a1420 1
  if ( handle < 0 || handle > MAX_HANDLE )
d1423 4
a1426 4
 /*
  * check the reference count, only free it if it goes to zero
  */
  if (--refCount[handle])
d1428 8
a1435 8
 /*
  * find the loaderRecs associated with this handle.
  */

  while( (tmp=_LoaderListPop(handle)) != NULL ) {
	if( strchr(tmp->name,':') == NULL ) {
		/* It is not a member of an archive */
		xf86Msg(X_INFO, "Unloading %s\n", tmp->name ) ;
d1441 3
a1443 3
  }
  
  freeHandles[handle] = HANDLE_FREE ;
d1445 1
a1445 1
return 0;
d1452 1
a1452 1
		listHead ? listHead->name : "(built-in)");
d1458 2
a1459 1
void _loader_debug_state()
d1468 1
a1468 1
	LoaderOptions = 0;
d1474 1
a1474 1
	LoaderOptions |= opts;
d1480 1
a1480 1
	LoaderOptions &= ~opts;
a1481 1

@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/loader.c,v 1.71 2003/11/06 18:38:13 tsi Exp $ */
d4 1
a24 27
/*
 * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

d37 1
a37 2
    (defined(__alpha__) || defined(__powerpc__) || defined(__ia64__) \
    || defined(__AMD64__))
d74 2
a75 2
#ifdef __UNIXOS2__
void *os2ldcalloc(size_t, size_t);
d86 2
a87 2
static char freeHandles[MAX_HANDLE];
static int refCount[MAX_HANDLE];
d90 1
a90 1
#if defined(__sparc__) && defined(__GNUC__) && !defined(__FreeBSD__)
d110 7
a116 7
    SYMFUNCDOT89(rem)
    SYMFUNCDOT89(urem)
    SYMFUNCDOT89(mul)
    SYMFUNCDOT89(umul)
    SYMFUNCDOT89(div)
    SYMFUNCDOT89(udiv)
    {0, 0}
d120 7
a126 7
    SYMFUNCDOT(rem)
    SYMFUNCDOT(urem)
    SYMFUNCDOT(mul)
    SYMFUNCDOT(umul)
    SYMFUNCDOT(div)
    SYMFUNCDOT(udiv)
    {0, 0}
a127 1

a139 1

a141 1

d143 1
a143 1

d145 1
a145 1
  __asm("": "=r"(hwcap):"0"(hwcap));
d147 4
a150 4
	if (*hwcap & HWCAP_SPARC_MULDIV)
	    return 1;
	else
	    return 0;
d153 2
a154 3
    f = fopen("/proc/cpuinfo", "r");
    if (!f)
	return 0;
d156 7
a162 7
	if (!strncmp(buffer, "type", 4)) {
	    p = strstr(buffer, "sun4");
	    if (p && (p[4] == 'u' || p[4] == 'd' || p[4] == 'm')) {
		fclose(f);
		return 1;
	    }
	}
d193 2
a194 2
    int num;
    const char **list;
d212 9
a220 18
 /*ARGSUSED*/ static void
ARCHIVEResolveSymbols(void *unused)
{
}
 /*ARGSUSED*/ static int
ARCHIVECheckForUnresolved(void *v)
{
    return 0;
}
 /*ARGSUSED*/ static char *
ARCHIVEAddressToSection(void *modptr, unsigned long address)
{
    return NULL;
}
 /*ARGSUSED*/ static void
ARCHIVEUnload(void *unused2)
{
}
d227 31
a257 31
    /* LD_ARCHIVE */
    {ARCHIVELoadModule,
     ARCHIVEResolveSymbols,
     ARCHIVECheckForUnresolved,
     ARCHIVEAddressToSection,
     ARCHIVEUnload, {0, 0, 0, 0, 0}},
    /* LD_ELFOBJECT */
    {ELFLoadModule,
     ELFResolveSymbols,
     ELFCheckForUnresolved,
     ELFAddressToSection,
     ELFUnloadModule, {0, 0, 0, 0, 0}},
    /* LD_COFFOBJECT */
    {COFFLoadModule,
     COFFResolveSymbols,
     COFFCheckForUnresolved,
     COFFAddressToSection,
     COFFUnloadModule, {0, 0, 0, 0, 0}},
    /* LD_XCOFFOBJECT */
    {COFFLoadModule,
     COFFResolveSymbols,
     COFFCheckForUnresolved,
     COFFAddressToSection,
     COFFUnloadModule, {0, 0, 0, 0, 0}},
    /* LD_AOUTOBJECT */
    {AOUTLoadModule,
     AOUTResolveSymbols,
     AOUTCheckForUnresolved,
     AOUTAddressToSection,
     AOUTUnloadModule, {0, 0, 0, 0, 0}},
    /* LD_AOUTDLOBJECT */
d259 5
a263 5
    {DLLoadModule,
     DLResolveSymbols,
     DLCheckForUnresolved,
     ARCHIVEAddressToSection,
     DLUnloadModule, {0, 0, 0, 0, 0}},
d265 5
a269 5
    {AOUTLoadModule,
     AOUTResolveSymbols,
     AOUTCheckForUnresolved,
     AOUTAddressToSection,
     AOUTUnloadModule, {0, 0, 0, 0, 0}},
d271 1
a271 1
    /* LD_ELFDLOBJECT */
d273 5
a277 5
    {DLLoadModule,
     DLResolveSymbols,
     DLCheckForUnresolved,
     ARCHIVEAddressToSection,
     DLUnloadModule, {0, 0, 0, 0, 0}},
d279 5
a283 5
    {ELFLoadModule,
     ELFResolveSymbols,
     ELFCheckForUnresolved,
     ELFAddressToSection,
     ELFUnloadModule, {0, 0, 0, 0, 0}},
d285 3
a287 1
};
a288 1
int numloaders = sizeof(funcs) / sizeof(loader_funcs);
d295 6
a300 6
    LoaderAddSymbols(-1, -1, miLookupTab);
    LoaderAddSymbols(-1, -1, xfree86LookupTab);
    LoaderAddSymbols(-1, -1, dixLookupTab);
    LoaderAddSymbols(-1, -1, fontLookupTab);
    LoaderAddSymbols(-1, -1, extLookupTab);
#if defined(__sparc__) && !defined(__FreeBSD__)
d303 1
a303 1
	LoaderAddSymbols(-1, -1, SparcV89LookupTab);
d306 2
a307 2
	LoaderAddSymbols(-1, -1, SparcLookupTab);
#endif
d311 2
a312 2
		   GET_ABI_MAJOR(LoaderVersionInfo.ansicVersion),
		   GET_ABI_MINOR(LoaderVersionInfo.ansicVersion));
d314 2
a315 2
		   GET_ABI_MAJOR(LoaderVersionInfo.videodrvVersion),
		   GET_ABI_MINOR(LoaderVersionInfo.videodrvVersion));
d317 2
a318 2
		   GET_ABI_MAJOR(LoaderVersionInfo.xinputVersion),
		   GET_ABI_MINOR(LoaderVersionInfo.xinputVersion));
d320 2
a321 2
		   GET_ABI_MAJOR(LoaderVersionInfo.extensionVersion),
		   GET_ABI_MINOR(LoaderVersionInfo.extensionVersion));
d323 2
a324 2
		   GET_ABI_MAJOR(LoaderVersionInfo.fontVersion),
		   GET_ABI_MINOR(LoaderVersionInfo.fontVersion));
d331 1
a331 2
    (defined(__alpha__) || defined(__powerpc__) || defined(__ia64__) \
     || ( defined __AMD64__ && ! defined UseMMAP && ! defined DoMMAPedMerge))
d337 1
a337 1
    mallopt(M_MMAP_MAX, 0);
d351 1
a351 1
    unsigned char buf[256];	/* long enough for the largest magic type */
d353 1
a353 1
    if (read(fd, buf, sizeof(buf)) < 0) {
d356 1
d358 2
a359 3
    ErrorF("Checking module type %10s\n", buf);
    ErrorF("Checking module type %x %x %x %x\n", buf[0], buf[1], buf[2],
	   buf[3]);
d362 1
a362 1
    lseek(fd, offset, SEEK_SET);
d364 1
a364 1
    if (strncmp((char *)buf, ARMAG, SARMAG) == 0) {
d367 1
d370 1
a370 1
    if (strncmp((char *)buf, AIAMAG, SAIAMAG) == 0) {
d375 2
a376 2
    if (strncmp((char *)buf, ELFMAG, SELFMAG) == 0) {
	if (*((Elf32_Half *) (buf + ELFDLOFF)) == ELFDLMAG) {
d383 1
a383 1
    if (buf[0] == 0x4c && buf[1] == 0x01) {
d387 1
a387 1
    if (buf[0] == 0x01 && buf[1] == 0xdf) {
d390 2
a391 2
    }
    if (buf[0] == 0x0d && buf[1] == 0x01) {
d395 18
a412 17
    if (buf[0] == 0x00 && buf[1] == 0x86 && buf[2] == 0x01 && buf[3] == 0x07) {
	/* AOUTMAGIC */
	return LD_AOUTOBJECT;
    }
    if (buf[0] == 0x07 && buf[1] == 0x01
	&& (buf[2] == 0x64 || buf[2] == 0x86)) {
	/* AOUTMAGIC, (Linux OMAGIC, old impure format, also used by OS/2 */
	return LD_AOUTOBJECT;
    }
    if (buf[0] == 0x07 && buf[1] == 0x01 && buf[2] == 0x00 && buf[3] == 0x00) {
	/* AOUTMAGIC, BSDI */
	return LD_AOUTOBJECT;
    }
    if ((buf[0] == 0xc0 && buf[1] == 0x86) ||	/* big endian form */
	(buf[3] == 0xc0 && buf[2] == 0x86)) {	/* little endian form */
	/* i386 shared object */
	return LD_AOUTDLOBJECT;
a417 1
static int offsetbias = 0;	/* offset into archive */
d419 1
d425 1
a425 1
_LoaderFileToMem(int fd, unsigned long offset, int size, char *label)
d428 12
a439 1
    unsigned long ret;
a440 37
# ifdef MmapPageAlign
    unsigned long pagesize;
    unsigned long new_size;
    unsigned long new_off;
    unsigned long new_off_bias;
# endif
# define MMAP_PROT	(PROT_READ|PROT_WRITE|PROT_EXEC)

# ifdef DEBUGMEM
    ErrorF("_LoaderFileToMem(%d,%u(%u),%d,%s)", fd, offset, offsetbias, size,
	   label);
# endif
# ifdef MmapPageAlign
    pagesize = getpagesize();
    new_size = (size + pagesize - 1) / pagesize;
    new_size *= pagesize;
    new_off = (offset + offsetbias) / pagesize;
    new_off *= pagesize;
    new_off_bias = (offset + offsetbias) - new_off;
    if ((new_off_bias + size) > new_size)
	new_size += pagesize;
    ret = (unsigned long)mmap(0, new_size, MMAP_PROT, MAP_PRIVATE
#  ifdef __AMD64__
			      | MAP_32BIT
#  endif
			      , fd, new_off);
    if (ret == -1)
	FatalError("mmap() failed: %s\n", strerror(errno));
    return (void *)(ret + new_off_bias);
# else
    ret = (unsigned long)mmap(0, size, MMAP_PROT, MAP_PRIVATE
#  ifdef __AMD64__
			      | MAP_32BIT
#  endif
			      , fd, offset + offsetbias);
    if (ret == -1)
	FatalError("mmap() failed: %s\n", strerror(errno));
a441 1
# endif
d445 8
a452 9
# ifdef DEBUGMEM
    ErrorF("_LoaderFileToMem(%d,%u(%u),%d,%s)", fd, offset, offsetbias, size,
	   label);
# endif

    if (size == 0) {
# ifdef DEBUGMEM
	ErrorF("=NULL\n", ptr);
# endif
d455 9
a463 8
# ifndef __UNIXOS2__
    if ((ptr = xf86loadercalloc(size, 1)) == NULL)
	FatalError("_LoaderFileToMem() malloc failed\n");
# else
    if ((ptr = os2ldcalloc(size, 1)) == NULL)
	FatalError("_LoaderFileToMem() malloc failed\n");
# endif
# if defined(linux) && defined(__ia64__)
d468 8
a475 14
	round = (unsigned long)ptr & (page_size - 1);
	mprotect(ptr - round,
		 (size + round + page_size - 1) & ~(page_size - 1),
		 PROT_READ | PROT_WRITE | PROT_EXEC);
    }
# endif

    if (lseek(fd, offset + offsetbias, SEEK_SET) < 0)
	FatalError("\n_LoaderFileToMem() lseek() failed: %s\n",
		   strerror(errno));

    if (read(fd, ptr, size) != size)
	FatalError("\n_LoaderFileToMem() read() failed: %s\n",
		   strerror(errno));
d477 4
a480 2
# if (defined(linux) || defined(__NetBSD__) || defined(__OpenBSD__)) \
    && defined(__powerpc__)
d485 7
a491 2
    {
	int i;
d493 3
a495 9
	for (i = 0; i < size; i += 16)
	    ppc_flush_icache(ptr + i);
	ppc_flush_icache(ptr + size - 1);
    }
# endif

# ifdef DEBUGMEM
    ErrorF("=%lx\n", ptr);
# endif
a506 5
#if defined (UseMMAP) && defined (MmapPageAlign)
    unsigned long pagesize = getpagesize();
    memType i_addr = (memType) addr;
    unsigned long new_size;
#endif
d508 1
a508 1
    ErrorF("_LoaderFreeFileMem(%x,%d)\n", addr, size);
d511 1
a511 11
# if defined (MmapPageAlign)
    i_addr /= pagesize;
    i_addr *= pagesize;
    new_size = (size + pagesize - 1) / pagesize;
    new_size *= pagesize;
    if (((memType) addr - i_addr + size) > new_size)
	new_size += pagesize;
    munmap((void *)i_addr, new_size);
# else
    munmap((void *)addr, size);
# endif
d513 1
a513 1
    if (size == 0)
d525 2
a526 2
    if (lseek(fd, offset + offsetbias, SEEK_SET) < 0)
	FatalError("_LoaderFileRead() lseek() failed: %s\n", strerror(errno));
d528 2
a529 2
    if (read(fd, buf, size) != size)
	FatalError("_LoaderFileRead() read() failed: %s\n", strerror(errno));
d534 1
a534 1
static loaderPtr listHead = (loaderPtr) 0;
d539 3
a541 1
    loaderPtr item = xf86loadercalloc(1, sizeof(struct _loader));
d543 1
a543 4
    item->next = listHead;
    listHead = item;

    return item;
d549 2
a550 2
    loaderPtr item = listHead;
    loaderPtr *bptr = &listHead;	/* pointer to previous node */
d552 3
a554 3
    while (item) {
	if (item->handle == handle) {
	    *bptr = item->next;	/* remove this from the list */
d556 3
a559 3
	bptr = &(item->next);
	item = item->next;
    }
d561 1
a561 1
    return 0;
d572 3
a574 3
    loaderPtr item = listHead;
    loaderPtr aritem = NULL;
    loaderPtr lastitem = NULL;
d576 1
a576 1
    if (handle < 0) {
d578 5
a582 5
    }
    while (item) {
	if (item->handle == handle) {
	    if (strchr(item->name, ':') == NULL)
		aritem = item;
d584 3
a586 1
		lastitem = item;
a587 2
	item = item->next;
    }
d589 2
a590 2
    if (aritem)
	return aritem->name;
d592 2
a593 2
    if (lastitem)
	return lastitem->name;
d595 1
a595 1
    return 0;
d606 2
a607 2
    loaderPtr item = listHead;
    loaderPtr lastitem = NULL;
d609 1
a609 1
    if (handle < 0) {
d611 4
a614 4
    }
    while (item) {
	if (item->handle == handle) {
	    lastitem = item;
d616 2
a617 2
	item = item->next;
    }
d619 2
a620 2
    if (lastitem)
	return lastitem->cname;
d622 1
a622 1
    return NULL;
d633 3
a635 3
    loaderPtr item = listHead;
    loaderPtr aritem = NULL;
    loaderPtr lastitem = NULL;
d637 1
a637 1
    if (module < 0) {
d639 5
a643 5
    }
    while (item) {
	if (item->module == module) {
	    if (strchr(item->name, ':') == NULL)
		aritem = item;
d645 1
a645 1
		lastitem = item;
d647 2
a648 2
	item = item->next;
    }
d650 2
a651 2
    if (aritem)
	return aritem->name;
d653 2
a654 2
    if (lastitem)
	return lastitem->name;
d656 1
a656 1
    return 0;
d665 1
a665 1
			const char **section)
d667 1
a667 1
    loaderPtr item = listHead;
d669 4
a672 5
    while (item) {
	if ((*section =
	     item->funcs->AddressToSection(item->private, address)) != NULL) {
	    *module = _LoaderModuleToName(item->module);
	    return 1;
d674 2
a675 2
	item = item->next;
    }
d677 1
a677 1
    return 0;
d680 1
d686 1
a686 1
AppendSymbol(symlist * list, const char *sym)
d694 1
a694 1
AppendSymList(symlist * list, const char **syms)
d703 1
a703 1
SymInList(symlist * list, char *sym)
d720 1
a720 1
	return;
d724 2
a725 2
	AppendSymbol(&refList, s);
	s = va_arg(args, const char *);
d837 1
a837 1
    return (fatalsym);
d844 1
a844 1
ARCHIVELoadModule(loaderPtr modrec, int arfd, LOOKUP ** ppLookup)
d847 2
a848 4
    void *ret = NULL;
    unsigned char magic[SARMAG];
    struct ar_hdr hdr;

d850 10
a859 10
    struct fl_hdr fhdr;
    char name[255];
    int namlen;
#endif
    unsigned int size;
    unsigned int offset;
    int arnamesize, modnamesize;
    char *slash, *longname;
    char *nametable = NULL;
    int nametablelen = 0;
d861 1
a861 1
    LOOKUP *myLookup = NULL;	/* Does realloc behave if ptr == 0? */
d865 1
d869 1
a869 1
    arnamesize = strlen(modrec->name);
d872 1
a872 1
    read(arfd, magic, SARMAG);
d874 2
a875 2
    if (strncmp((const char *)magic, ARMAG, SARMAG) != 0) {
	ErrorF("ARCHIVELoadModule: wrong magic!!\n");
d878 1
d880 1
a880 1
    read(arfd, &fhdr, FL_HSZ);
d882 2
a883 2
    if (strncmp(fhdr.fl_magic, AIAMAG, SAIAMAG) != 0) {
	ErrorF("ARCHIVELoadModule: wrong magic!!\n");
d886 1
d890 1
a890 1
    ErrorF("Looking for archive members starting at offset %o\n", offset);
d893 1
a893 1
    while (read(arfd, &hdr, sizeof(struct ar_hdr))) {
d896 1
a896 1
	sscanf(hdr.ar_size, "%u", &size);
d898 8
a905 8
	sscanf(hdr.ar_namlen, "%d", &namlen);
	name[0] = hdr.ar_name[0];
	name[1] = hdr.ar_name[1];
	read(arfd, &name[2], namlen);
	name[namlen] = '\0';
	offset = lseek(arfd, 0, SEEK_CUR);
	if (offset & 0x1)	/* odd value */
	    offset = lseek(arfd, 1, SEEK_CUR);	/* make it an even boundary */
d907 1
a907 1
	offset = lseek(arfd, 0, SEEK_CUR);
d910 1
a910 1
	if ((hdr.ar_name[0] == '/' && hdr.ar_name[1] == ' ') ||
d914 1
a914 1
	    strncmp(hdr.ar_name, "__.SYMDEF", 9) == 0) {
d918 2
a919 2
		   hdr.ar_name, size, offset);
	    ErrorF("Symbol table size %d\n", size);
d921 3
a923 3
	    offset = lseek(arfd, offset + size, SEEK_SET);
	    if (offset & 0x1)	/* odd value */
		offset = lseek(arfd, 1, SEEK_CUR);	/* make it an even boundary */
d928 1
a928 1
	if (hdr.ar_name[0] == '/' && hdr.ar_name[1] == '/') {
d932 2
a933 2
		   hdr.ar_name, size, offset);
	    ErrorF("String table size %d\n", size);
d936 1
a936 1
	    nametable = (char *)xf86loadermalloc(nametablelen);
d938 1
a938 1
	    offset = lseek(arfd, 0, SEEK_CUR);
d940 2
a941 2
	    if (offset & 0x1)	/* odd value */
		offset = lseek(arfd, 1, SEEK_CUR);	/* make it an even boundary */
a948 1

d950 2
a951 2
		ErrorF("Missing string table whilst processing %s\n",
		       modrec->name);
d956 2
a957 1
		ErrorF("Invalid string table offset (%s) whilst processing %s\n", hdr.ar_name, modrec->name);
d963 1
a963 1
	    slash = strchr(membername, '/');
d967 3
a969 3
	    strcpy(longname, modrec->name);
	    strcat(longname, ":");
	    strcat(longname, membername);
d973 1
a973 1
	    if (sscanf(hdr.ar_name + 3, "%d", &modnamesize) != 1) {
d980 3
a982 3
	    strcpy(longname, modrec->name);
	    strcat(longname, ":");
	    i = read(arfd, longname + modnamesize + 1, modnamesize);
d984 1
a984 1
		ErrorF("Bad archive member %s\n", hdr.ar_name);
d988 1
a988 1
	    }
d992 1
a992 1
	} else {
d1001 1
a1001 1
		   size, offset);
d1004 1
a1004 1
	    slash = strchr(hdr.ar_name, '/');
d1007 2
a1008 2
		slash = strchr(hdr.ar_name, ' ');
	    }
d1010 4
a1013 4

	    if ((slash - hdr.ar_name) > sizeof(hdr.ar_name))
		slash = hdr.ar_name + sizeof(hdr.ar_name) - 1;
	    *slash = '\000';
d1015 3
a1017 3
	if ((modtype = _GetModuleType(arfd, offset)) < 0) {
	    ErrorF("%s is an unrecognized module type\n", hdr.ar_name);
	    offsetbias = 0;
d1023 1
a1023 1
	tmp = _LoaderListPush();
d1029 1
a1029 1
	tmp->funcs = &funcs[modtype];
d1031 6
a1036 7
	    modnamesize = strlen(hdr.ar_name);
	    tmp->name =
		    (char *)xf86loadermalloc(arnamesize + modnamesize + 2);
	    strcpy(tmp->name, modrec->name);
	    strcat(tmp->name, ":");
	    strcat(tmp->name, hdr.ar_name);

d1040 1
a1040 1
	offsetbias = offset;
d1042 5
a1046 4
	if ((tmp->private = funcs[modtype].LoadModule(tmp, arfd, &lookup_ret))
	    == NULL) {
	    ErrorF("Failed to load %s\n", hdr.ar_name);
	    offsetbias = 0;
d1052 3
a1054 9
	offset = lseek(arfd, offset + size, SEEK_SET);
	if (offset & 0x1)	/* odd value */
	    lseek(arfd, 1, SEEK_CUR);	/* make it an even boundary */

	if (tmp->private == (void *)-1L) {
	    ErrorF("Skipping \"%s\":  No symbols found\n", tmp->name);
	    continue;
	} else
	    ret = tmp->private;
d1059 2
a1060 1
	for (i = 0, p = lookup_ret; p && p->symName; i++, p++) ;
d1063 1
a1063 1
					 * sizeof(LOOKUP));
d1065 1
a1065 1
		continue;	/* Oh well! */
d1067 1
a1067 1
	    memcpy(&(myLookup[numsyms]), lookup_ret, i * sizeof(LOOKUP));
d1074 1
a1074 1
    offsetbias = 0;
d1080 4
a1083 1
    return ret;
d1096 1
a1096 1
    loader_funcs *formatrec = (loader_funcs *) mod;
d1098 1
a1098 1
    return &(formatrec->pRelocs);
d1109 2
a1110 2
    loaderPtr tmp;
    int new_handle, modtype;
d1115 1
a1115 1
    ErrorF("LoaderOpen(%s)\n", module);
d1126 1
a1126 1
	while (tmp) {
d1128 2
a1129 2
	    ErrorF("strcmp(%x(%s),{%x} %x(%s))\n", module, module,
		   &(tmp->name), tmp->name, tmp->name);
d1131 1
a1131 1
	    if (!strcmp(module, tmp->name)) {
d1138 1
a1138 1
	    tmp = tmp->next;
d1145 1
a1145 1
    xf86Msg(X_INFO, "Loading %s\n", module);
d1153 2
a1154 2
    while (freeHandles[new_handle] && new_handle < MAX_HANDLE)
	new_handle++;
d1156 4
a1159 7
    if (new_handle == MAX_HANDLE) {
	xf86Msg(X_ERROR, "Out of loader space\n");	/* XXX */
	if (errmaj)
	    *errmaj = LDR_NOSPACE;
	if (errmin)
	    *errmin = LDR_NOSPACE;
	return -1;
d1162 1
a1162 1
    freeHandles[new_handle] = HANDLE_USED;
d1165 6
a1170 8
    if ((fd = open(module, O_RDONLY)) < 0) {
	xf86Msg(X_ERROR, "Unable to open %s\n", module);
	freeHandles[new_handle] = HANDLE_FREE;
	if (errmaj)
	    *errmaj = LDR_NOMODOPEN;
	if (errmin)
	    *errmin = errno;
	return -1;
d1173 4
a1176 7
    if ((modtype = _GetModuleType(fd, 0)) < 0) {
	xf86Msg(X_ERROR, "%s is an unrecognized module type\n", module);
	freeHandles[new_handle] = HANDLE_FREE;
	if (errmaj)
	    *errmaj = LDR_UNKTYPE;
	if (errmin)
	    *errmin = LDR_UNKTYPE;
d1180 1
a1180 1
    tmp = _LoaderListPush();
d1187 1
a1187 1
    tmp->funcs = &funcs[modtype];
d1189 2
a1190 2
    if ((tmp->private = funcs[modtype].LoadModule(tmp, fd, &pLookup)) == NULL) {
	xf86Msg(X_ERROR, "Failed to load %s\n", module);
d1192 2
a1193 5
	freeHandles[new_handle] = HANDLE_FREE;
	if (errmaj)
	    *errmaj = LDR_NOLOAD;
	if (errmin)
	    *errmin = LDR_NOLOAD;
d1197 2
a1198 4
    if (tmp->private != (void *)-1L) {
	LoaderAddSymbols(new_handle, tmp->module, pLookup);
	xf86loaderfree(pLookup);
    }
a1222 1

d1228 2
a1229 2
    if (item)
	return item->address;
d1232 1
a1232 1
	return (DLFindSymbol(sym));
d1242 1
a1242 2

    for (i = 0; i < numloaders; i++)
d1248 1
a1248 1
LoaderCheckUnresolved(int delay_flag)
d1250 2
a1251 4
    int i, ret = 0;
    LoaderResolveOptions delayFlag = (LoaderResolveOptions)delay_flag;

    LoaderResolveSymbols();
d1253 1
a1253 7
    if (delayFlag == LD_RESOLV_NOW) {
	if (check_unresolved_sema > 0)
	    check_unresolved_sema--;
	else
	    xf86Msg(X_WARNING, "LoaderCheckUnresolved: not enough "
		    "MAGIC_DONT_CHECK_UNRESOLVED\n");
    }
d1255 12
a1266 4
    if (!check_unresolved_sema || delayFlag == LD_RESOLV_FORCE)
	for (i = 0; i < numloaders; i++)
	    if (funcs[i].CheckForUnresolved(&funcs[i]))
		ret = 1;
d1268 2
a1269 2
    if (fatalReqSym)
	FatalError("Some required symbols were unresolved\n");
d1271 1
a1271 1
    return ret;
d1284 2
a1285 4
    ErrorF("\n\n\tThis should not happen!\n"
	   "\tAn unresolved function was called!\n");

    xf86LoaderTrap();
d1287 3
a1289 1
    FatalError("\n");
d1295 2
a1296 2
    loaderRec fakeHead;
    loaderPtr tmp = &fakeHead;
d1298 1
a1298 1
    if (handle < 0 || handle > MAX_HANDLE)
d1301 4
a1304 4
    /*
     * check the reference count, only free it if it goes to zero
     */
    if (--refCount[handle])
d1306 8
a1313 8
    /*
     * find the loaderRecs associated with this handle.
     */

    while ((tmp = _LoaderListPop(handle)) != NULL) {
	if (strchr(tmp->name, ':') == NULL) {
	    /* It is not a member of an archive */
	    xf86Msg(X_INFO, "Unloading %s\n", tmp->name);
d1319 3
a1321 3
    }

    freeHandles[handle] = HANDLE_FREE;
d1323 1
a1323 1
    return 0;
d1330 1
a1330 1
	   listHead ? listHead->name : "(built-in)");
d1336 1
a1336 2
void
_loader_debug_state()
d1345 1
a1345 1
    LoaderOptions = 0;
d1351 1
a1351 1
    LoaderOptions |= opts;
d1357 1
a1357 1
    LoaderOptions &= ~opts;
d1359 1
@


1.1.9.2
log
@Import XFree86 4.4 from The XFree86(TM) Project, Inc.
(integrity cannot be checked)

got via cvs -qd anoncvs@@anoncvs.xfree86.org:/cvs co -Prxf-4_4_0 xc
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/loader.c,v 1.72 2004/02/13 23:58:45 dawes Exp $ */
a25 1
 * All rights reserved.
d27 22
a48 41
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 *
 *   1.  Redistributions of source code must retain the above copyright
 *       notice, this list of conditions, and the following disclaimer.
 *
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer
 *       in the documentation and/or other materials provided with the
 *       distribution, and in the same place and form as other copyright,
 *       license and disclaimer information.
 *
 *   3.  The end-user documentation included with the redistribution,
 *       if any, must include the following acknowledgment: "This product
 *       includes software developed by The XFree86 Project, Inc
 *       (http://www.xfree86.org/) and its contributors", in the same
 *       place and form as other third-party acknowledgments.  Alternately,
 *       this acknowledgment may appear in the software itself, in the
 *       same form and location as other such third-party acknowledgments.
 *
 *   4.  Except as contained in this notice, the name of The XFree86
 *       Project, Inc shall not be used in advertising or otherwise to
 *       promote the sale, use or other dealings in this Software without
 *       prior written authorization from The XFree86 Project, Inc.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE XFREE86 PROJECT, INC OR ITS CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/loader.c,v 1.63 2002/11/25 14:05:03 eich Exp $ */
d37 1
a37 2
    (defined(__alpha__) || defined(__powerpc__) || defined(__ia64__) \
    || defined(__x86_64__))
d74 1
a74 1
#ifdef __UNIXOS2__
d331 1
a331 2
    (defined(__alpha__) || defined(__powerpc__) || defined(__ia64__) \
     || ( defined __x86_64__ && ! defined UseMMAP && ! defined DoMMAPedMerge))
d429 1
a429 7
# ifdef MmapPageAlign
    unsigned long pagesize;
    unsigned long new_size;
    unsigned long new_off;
    unsigned long new_off_bias;
# endif
# define MMAP_PROT	(PROT_READ|PROT_WRITE|PROT_EXEC)
d431 1
a431 1
# ifdef DEBUGMEM
d433 5
a437 25
# endif
# ifdef MmapPageAlign
    pagesize = getpagesize();
    new_size = (size + pagesize - 1) / pagesize;
    new_size *= pagesize;
    new_off = (offset + offsetbias) / pagesize;
    new_off *= pagesize;
    new_off_bias = (offset + offsetbias) - new_off;
    if ((new_off_bias + size) > new_size) new_size += pagesize;
    ret = (unsigned long) mmap(0,new_size,MMAP_PROT,MAP_PRIVATE
#  ifdef __x86_64__
			       | MAP_32BIT
#  endif
			       ,
			       fd,new_off);
    if(ret == -1)
	FatalError("mmap() failed: %s\n", strerror(errno) );
    return (void *)(ret + new_off_bias);
# else
    ret = (unsigned long) mmap(0,size,MMAP_PROT,MAP_PRIVATE
#  ifdef __x86_64__
			       | MAP_32BIT
#  endif
			       ,
			       fd,offset + offsetbias);
d440 1
a441 1
# endif
d445 1
a445 1
# ifdef DEBUGMEM
d447 1
a447 1
# endif
d450 1
a450 1
# ifdef DEBUGMEM
d452 1
a452 1
# endif
d456 1
a456 1
# ifndef __UNIXOS2__
d459 1
a459 1
# else
d462 2
a463 2
# endif
# if defined(linux) && defined(__ia64__)
d472 1
a472 1
# endif
d480 1
a480 2
# if (defined(linux) || defined(__NetBSD__) || defined(__OpenBSD__)) \
    && defined(__powerpc__) 
d491 1
a491 1
# endif
d493 1
a493 1
# ifdef DEBUGMEM
d495 1
a495 1
# endif
a506 5
#if defined (UseMMAP) && defined (MmapPageAlign)
    unsigned long pagesize = getpagesize();
    memType i_addr = (memType)addr;
    unsigned long new_size;
#endif
d511 1
a511 10
# if defined (MmapPageAlign)
    i_addr /=  pagesize;
    i_addr *=  pagesize;
    new_size = (size + pagesize - 1) / pagesize;
    new_size *= pagesize;
    if (((memType)addr - i_addr + size) > new_size) new_size += pagesize;
    munmap((void *)i_addr,new_size);
# else
    munmap((void *)addr,size);
# endif
a846 1
    void *ret = NULL;
a1055 7
	if (tmp->private == (void *) -1L) {
	    ErrorF("Skipping \"%s\":  No symbols found\n", tmp->name);
	    continue;
	}
	else
	    ret = tmp->private;

d1080 4
a1083 1
    return ret;
a1158 1
	if(errmin) *errmin = LDR_NOSPACE;
a1176 1
	if(errmin) *errmin = LDR_UNKTYPE;
a1193 1
	if(errmin) *errmin = LDR_NOLOAD;
d1197 2
a1198 4
    if (tmp->private != (void *) -1L) {
	LoaderAddSymbols(new_handle, tmp->module, pLookup);
	xf86loaderfree(pLookup);
    }
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/loader.c,v 1.71 2003/11/06 18:38:13 tsi Exp $ */
d4 1
a24 27
/*
 * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Except as contained in this notice, the name of the copyright holder(s)
 * and author(s) shall not be used in advertising or otherwise to promote
 * the sale, use or other dealings in this Software without prior written
 * authorization from the copyright holder(s) and author(s).
 */

d38 1
a38 1
     || defined(__AMD64__))
d76 1
a76 1
void *os2ldcalloc(size_t, size_t);
d87 2
a88 2
static char freeHandles[MAX_HANDLE];
static int refCount[MAX_HANDLE];
d91 1
a91 1
#if defined(__sparc__) && defined(__GNUC__) && !defined(__FreeBSD__)
d111 7
a117 7
    SYMFUNCDOT89(rem)
    SYMFUNCDOT89(urem)
    SYMFUNCDOT89(mul)
    SYMFUNCDOT89(umul)
    SYMFUNCDOT89(div)
    SYMFUNCDOT89(udiv)
    {0, 0}
d121 7
a127 7
    SYMFUNCDOT(rem)
    SYMFUNCDOT(urem)
    SYMFUNCDOT(mul)
    SYMFUNCDOT(umul)
    SYMFUNCDOT(div)
    SYMFUNCDOT(udiv)
    {0, 0}
a128 1

a140 1

a142 1

d144 1
a144 1

d146 1
a146 1
  __asm("": "=r"(hwcap):"0"(hwcap));
d148 4
a151 4
	if (*hwcap & HWCAP_SPARC_MULDIV)
	    return 1;
	else
	    return 0;
d154 2
a155 3
    f = fopen("/proc/cpuinfo", "r");
    if (!f)
	return 0;
d157 7
a163 7
	if (!strncmp(buffer, "type", 4)) {
	    p = strstr(buffer, "sun4");
	    if (p && (p[4] == 'u' || p[4] == 'd' || p[4] == 'm')) {
		fclose(f);
		return 1;
	    }
	}
d194 2
a195 2
    int num;
    const char **list;
d213 9
a221 18
 /*ARGSUSED*/ static void
ARCHIVEResolveSymbols(void *unused)
{
}
 /*ARGSUSED*/ static int
ARCHIVECheckForUnresolved(void *v)
{
    return 0;
}
 /*ARGSUSED*/ static char *
ARCHIVEAddressToSection(void *modptr, unsigned long address)
{
    return NULL;
}
 /*ARGSUSED*/ static void
ARCHIVEUnload(void *unused2)
{
}
d228 31
a258 31
    /* LD_ARCHIVE */
    {ARCHIVELoadModule,
     ARCHIVEResolveSymbols,
     ARCHIVECheckForUnresolved,
     ARCHIVEAddressToSection,
     ARCHIVEUnload, {0, 0, 0, 0, 0}},
    /* LD_ELFOBJECT */
    {ELFLoadModule,
     ELFResolveSymbols,
     ELFCheckForUnresolved,
     ELFAddressToSection,
     ELFUnloadModule, {0, 0, 0, 0, 0}},
    /* LD_COFFOBJECT */
    {COFFLoadModule,
     COFFResolveSymbols,
     COFFCheckForUnresolved,
     COFFAddressToSection,
     COFFUnloadModule, {0, 0, 0, 0, 0}},
    /* LD_XCOFFOBJECT */
    {COFFLoadModule,
     COFFResolveSymbols,
     COFFCheckForUnresolved,
     COFFAddressToSection,
     COFFUnloadModule, {0, 0, 0, 0, 0}},
    /* LD_AOUTOBJECT */
    {AOUTLoadModule,
     AOUTResolveSymbols,
     AOUTCheckForUnresolved,
     AOUTAddressToSection,
     AOUTUnloadModule, {0, 0, 0, 0, 0}},
    /* LD_AOUTDLOBJECT */
d260 5
a264 5
    {DLLoadModule,
     DLResolveSymbols,
     DLCheckForUnresolved,
     ARCHIVEAddressToSection,
     DLUnloadModule, {0, 0, 0, 0, 0}},
d266 5
a270 5
    {AOUTLoadModule,
     AOUTResolveSymbols,
     AOUTCheckForUnresolved,
     AOUTAddressToSection,
     AOUTUnloadModule, {0, 0, 0, 0, 0}},
d272 1
a272 1
    /* LD_ELFDLOBJECT */
d274 5
a278 5
    {DLLoadModule,
     DLResolveSymbols,
     DLCheckForUnresolved,
     ARCHIVEAddressToSection,
     DLUnloadModule, {0, 0, 0, 0, 0}},
d280 5
a284 5
    {ELFLoadModule,
     ELFResolveSymbols,
     ELFCheckForUnresolved,
     ELFAddressToSection,
     ELFUnloadModule, {0, 0, 0, 0, 0}},
d286 3
a288 1
};
a289 1
int numloaders = sizeof(funcs) / sizeof(loader_funcs);
d296 6
a301 6
    LoaderAddSymbols(-1, -1, miLookupTab);
    LoaderAddSymbols(-1, -1, xfree86LookupTab);
    LoaderAddSymbols(-1, -1, dixLookupTab);
    LoaderAddSymbols(-1, -1, fontLookupTab);
    LoaderAddSymbols(-1, -1, extLookupTab);
#if defined(__sparc__) && !defined(__FreeBSD__)
d304 1
a304 1
	LoaderAddSymbols(-1, -1, SparcV89LookupTab);
d307 2
a308 2
	LoaderAddSymbols(-1, -1, SparcLookupTab);
#endif
d312 2
a313 2
		   GET_ABI_MAJOR(LoaderVersionInfo.ansicVersion),
		   GET_ABI_MINOR(LoaderVersionInfo.ansicVersion));
d315 2
a316 2
		   GET_ABI_MAJOR(LoaderVersionInfo.videodrvVersion),
		   GET_ABI_MINOR(LoaderVersionInfo.videodrvVersion));
d318 2
a319 2
		   GET_ABI_MAJOR(LoaderVersionInfo.xinputVersion),
		   GET_ABI_MINOR(LoaderVersionInfo.xinputVersion));
d321 2
a322 2
		   GET_ABI_MAJOR(LoaderVersionInfo.extensionVersion),
		   GET_ABI_MINOR(LoaderVersionInfo.extensionVersion));
d324 2
a325 2
		   GET_ABI_MAJOR(LoaderVersionInfo.fontVersion),
		   GET_ABI_MINOR(LoaderVersionInfo.fontVersion));
d333 1
a333 1
     || ( defined __AMD64__ && ! defined UseMMAP && ! defined DoMMAPedMerge))
d339 1
a339 1
    mallopt(M_MMAP_MAX, 0);
d353 1
a353 1
    unsigned char buf[256];	/* long enough for the largest magic type */
d355 1
a355 1
    if (read(fd, buf, sizeof(buf)) < 0) {
d358 1
d360 2
a361 3
    ErrorF("Checking module type %10s\n", buf);
    ErrorF("Checking module type %x %x %x %x\n", buf[0], buf[1], buf[2],
	   buf[3]);
d364 1
a364 1
    lseek(fd, offset, SEEK_SET);
d366 1
a366 1
    if (strncmp((char *)buf, ARMAG, SARMAG) == 0) {
d369 1
d372 1
a372 1
    if (strncmp((char *)buf, AIAMAG, SAIAMAG) == 0) {
d377 2
a378 2
    if (strncmp((char *)buf, ELFMAG, SELFMAG) == 0) {
	if (*((Elf32_Half *) (buf + ELFDLOFF)) == ELFDLMAG) {
d385 1
a385 1
    if (buf[0] == 0x4c && buf[1] == 0x01) {
d389 1
a389 1
    if (buf[0] == 0x01 && buf[1] == 0xdf) {
d392 2
a393 2
    }
    if (buf[0] == 0x0d && buf[1] == 0x01) {
d397 18
a414 17
    if (buf[0] == 0x00 && buf[1] == 0x86 && buf[2] == 0x01 && buf[3] == 0x07) {
	/* AOUTMAGIC */
	return LD_AOUTOBJECT;
    }
    if (buf[0] == 0x07 && buf[1] == 0x01
	&& (buf[2] == 0x64 || buf[2] == 0x86)) {
	/* AOUTMAGIC, (Linux OMAGIC, old impure format, also used by OS/2 */
	return LD_AOUTOBJECT;
    }
    if (buf[0] == 0x07 && buf[1] == 0x01 && buf[2] == 0x00 && buf[3] == 0x00) {
	/* AOUTMAGIC, BSDI */
	return LD_AOUTOBJECT;
    }
    if ((buf[0] == 0xc0 && buf[1] == 0x86) ||	/* big endian form */
	(buf[3] == 0xc0 && buf[2] == 0x86)) {	/* little endian form */
	/* i386 shared object */
	return LD_AOUTDLOBJECT;
a419 1
static int offsetbias = 0;	/* offset into archive */
d421 1
d427 1
a427 1
_LoaderFileToMem(int fd, unsigned long offset, int size, char *label)
d430 1
a430 2
    unsigned long ret;

d440 1
a440 2
    ErrorF("_LoaderFileToMem(%d,%u(%u),%d,%s)", fd, offset, offsetbias, size,
	   label);
d449 4
a452 5
    if ((new_off_bias + size) > new_size)
	new_size += pagesize;
    ret = (unsigned long)mmap(0, new_size, MMAP_PROT, MAP_PRIVATE
#  if defined(__AMD64__) || defined(__amd64__)
			      | MAP_32BIT
d454 4
a457 3
			      , fd, new_off);
    if (ret == -1)
	FatalError("mmap() failed: %s\n", strerror(errno));
d460 3
a462 3
    ret = (unsigned long)mmap(0, size, MMAP_PROT, MAP_PRIVATE
#  if defined(__AMD64__) || defined(__amd64__)
			      | MAP_32BIT
d464 4
a467 3
			      , fd, offset + offsetbias);
    if (ret == -1)
	FatalError("mmap() failed: %s\n", strerror(errno));
d474 1
a474 2
    ErrorF("_LoaderFileToMem(%d,%u(%u),%d,%s)", fd, offset, offsetbias, size,
	   label);
d477 1
a477 1
    if (size == 0) {
d479 1
a479 1
	ErrorF("=NULL\n", ptr);
d483 1
d485 2
a486 2
    if ((ptr = xf86loadercalloc(size, 1)) == NULL)
	FatalError("_LoaderFileToMem() malloc failed\n");
d488 2
a489 2
    if ((ptr = os2ldcalloc(size, 1)) == NULL)
	FatalError("_LoaderFileToMem() malloc failed\n");
d496 3
a498 4
	round = (unsigned long)ptr & (page_size - 1);
	mprotect(ptr - round,
		 (size + round + page_size - 1) & ~(page_size - 1),
		 PROT_READ | PROT_WRITE | PROT_EXEC);
d502 5
a506 7
    if (lseek(fd, offset + offsetbias, SEEK_SET) < 0)
	FatalError("\n_LoaderFileToMem() lseek() failed: %s\n",
		   strerror(errno));

    if (read(fd, ptr, size) != size)
	FatalError("\n_LoaderFileToMem() read() failed: %s\n",
		   strerror(errno));
d509 1
a509 1
    && defined(__powerpc__)
d514 6
a519 7
    {
	int i;

	for (i = 0; i < size; i += 16)
	    ppc_flush_icache(ptr + i);
	ppc_flush_icache(ptr + size - 1);
    }
d523 1
a523 1
    ErrorF("=%lx\n", ptr);
d538 1
a538 1
    memType i_addr = (memType) addr;
d542 1
a542 1
    ErrorF("_LoaderFreeFileMem(%x,%d)\n", addr, size);
d546 2
a547 2
    i_addr /= pagesize;
    i_addr *= pagesize;
d550 2
a551 3
    if (((memType) addr - i_addr + size) > new_size)
	new_size += pagesize;
    munmap((void *)i_addr, new_size);
d553 1
a553 1
    munmap((void *)addr, size);
d556 1
a556 1
    if (size == 0)
d568 2
a569 2
    if (lseek(fd, offset + offsetbias, SEEK_SET) < 0)
	FatalError("_LoaderFileRead() lseek() failed: %s\n", strerror(errno));
d571 2
a572 2
    if (read(fd, buf, size) != size)
	FatalError("_LoaderFileRead() read() failed: %s\n", strerror(errno));
d577 1
a577 1
static loaderPtr listHead = (loaderPtr) 0;
d582 3
a584 1
    loaderPtr item = xf86loadercalloc(1, sizeof(struct _loader));
d586 1
a586 4
    item->next = listHead;
    listHead = item;

    return item;
d592 2
a593 2
    loaderPtr item = listHead;
    loaderPtr *bptr = &listHead;	/* pointer to previous node */
d595 3
a597 3
    while (item) {
	if (item->handle == handle) {
	    *bptr = item->next;	/* remove this from the list */
d599 3
a602 3
	bptr = &(item->next);
	item = item->next;
    }
d604 1
a604 1
    return 0;
d615 3
a617 3
    loaderPtr item = listHead;
    loaderPtr aritem = NULL;
    loaderPtr lastitem = NULL;
d619 1
a619 1
    if (handle < 0) {
d621 5
a625 5
    }
    while (item) {
	if (item->handle == handle) {
	    if (strchr(item->name, ':') == NULL)
		aritem = item;
d627 3
a629 1
		lastitem = item;
a630 2
	item = item->next;
    }
d632 2
a633 2
    if (aritem)
	return aritem->name;
d635 2
a636 2
    if (lastitem)
	return lastitem->name;
d638 1
a638 1
    return 0;
d649 2
a650 2
    loaderPtr item = listHead;
    loaderPtr lastitem = NULL;
d652 1
a652 1
    if (handle < 0) {
d654 4
a657 4
    }
    while (item) {
	if (item->handle == handle) {
	    lastitem = item;
d659 2
a660 2
	item = item->next;
    }
d662 2
a663 2
    if (lastitem)
	return lastitem->cname;
d665 1
a665 1
    return NULL;
d676 3
a678 3
    loaderPtr item = listHead;
    loaderPtr aritem = NULL;
    loaderPtr lastitem = NULL;
d680 1
a680 1
    if (module < 0) {
d682 5
a686 5
    }
    while (item) {
	if (item->module == module) {
	    if (strchr(item->name, ':') == NULL)
		aritem = item;
d688 1
a688 1
		lastitem = item;
d690 2
a691 2
	item = item->next;
    }
d693 2
a694 2
    if (aritem)
	return aritem->name;
d696 2
a697 2
    if (lastitem)
	return lastitem->name;
d699 1
a699 1
    return 0;
d708 1
a708 1
			const char **section)
d710 1
a710 1
    loaderPtr item = listHead;
d712 4
a715 5
    while (item) {
	if ((*section =
	     item->funcs->AddressToSection(item->private, address)) != NULL) {
	    *module = _LoaderModuleToName(item->module);
	    return 1;
d717 2
a718 2
	item = item->next;
    }
d720 1
a720 1
    return 0;
d723 1
d729 1
a729 1
AppendSymbol(symlist * list, const char *sym)
d737 1
a737 1
AppendSymList(symlist * list, const char **syms)
d746 1
a746 1
SymInList(symlist * list, char *sym)
d763 1
a763 1
	return;
d767 2
a768 2
	AppendSymbol(&refList, s);
	s = va_arg(args, const char *);
d880 1
a880 1
    return (fatalsym);
d887 1
a887 1
ARCHIVELoadModule(loaderPtr modrec, int arfd, LOOKUP ** ppLookup)
d891 2
a892 3
    unsigned char magic[SARMAG];
    struct ar_hdr hdr;

d894 10
a903 10
    struct fl_hdr fhdr;
    char name[255];
    int namlen;
#endif
    unsigned int size;
    unsigned int offset;
    int arnamesize, modnamesize;
    char *slash, *longname;
    char *nametable = NULL;
    int nametablelen = 0;
d905 1
a905 1
    LOOKUP *myLookup = NULL;	/* Does realloc behave if ptr == 0? */
d909 1
d913 1
a913 1
    arnamesize = strlen(modrec->name);
d916 1
a916 1
    read(arfd, magic, SARMAG);
d918 2
a919 2
    if (strncmp((const char *)magic, ARMAG, SARMAG) != 0) {
	ErrorF("ARCHIVELoadModule: wrong magic!!\n");
d922 1
d924 1
a924 1
    read(arfd, &fhdr, FL_HSZ);
d926 2
a927 2
    if (strncmp(fhdr.fl_magic, AIAMAG, SAIAMAG) != 0) {
	ErrorF("ARCHIVELoadModule: wrong magic!!\n");
d930 1
d934 1
a934 1
    ErrorF("Looking for archive members starting at offset %o\n", offset);
d937 1
a937 1
    while (read(arfd, &hdr, sizeof(struct ar_hdr))) {
d940 1
a940 1
	sscanf(hdr.ar_size, "%u", &size);
d942 8
a949 8
	sscanf(hdr.ar_namlen, "%d", &namlen);
	name[0] = hdr.ar_name[0];
	name[1] = hdr.ar_name[1];
	read(arfd, &name[2], namlen);
	name[namlen] = '\0';
	offset = lseek(arfd, 0, SEEK_CUR);
	if (offset & 0x1)	/* odd value */
	    offset = lseek(arfd, 1, SEEK_CUR);	/* make it an even boundary */
d951 1
a951 1
	offset = lseek(arfd, 0, SEEK_CUR);
d954 1
a954 1
	if ((hdr.ar_name[0] == '/' && hdr.ar_name[1] == ' ') ||
d958 1
a958 1
	    strncmp(hdr.ar_name, "__.SYMDEF", 9) == 0) {
d962 2
a963 2
		   hdr.ar_name, size, offset);
	    ErrorF("Symbol table size %d\n", size);
d965 3
a967 3
	    offset = lseek(arfd, offset + size, SEEK_SET);
	    if (offset & 0x1)	/* odd value */
		offset = lseek(arfd, 1, SEEK_CUR);	/* make it an even boundary */
d972 1
a972 1
	if (hdr.ar_name[0] == '/' && hdr.ar_name[1] == '/') {
d976 2
a977 2
		   hdr.ar_name, size, offset);
	    ErrorF("String table size %d\n", size);
d980 1
a980 1
	    nametable = (char *)xf86loadermalloc(nametablelen);
d982 1
a982 1
	    offset = lseek(arfd, 0, SEEK_CUR);
d984 2
a985 2
	    if (offset & 0x1)	/* odd value */
		offset = lseek(arfd, 1, SEEK_CUR);	/* make it an even boundary */
a992 1

d994 2
a995 2
		ErrorF("Missing string table whilst processing %s\n",
		       modrec->name);
d1000 2
a1001 1
		ErrorF("Invalid string table offset (%s) whilst processing %s\n", hdr.ar_name, modrec->name);
d1007 1
a1007 1
	    slash = strchr(membername, '/');
d1011 3
a1013 3
	    strcpy(longname, modrec->name);
	    strcat(longname, ":");
	    strcat(longname, membername);
d1017 1
a1017 1
	    if (sscanf(hdr.ar_name + 3, "%d", &modnamesize) != 1) {
d1024 3
a1026 3
	    strcpy(longname, modrec->name);
	    strcat(longname, ":");
	    i = read(arfd, longname + modnamesize + 1, modnamesize);
d1028 1
a1028 1
		ErrorF("Bad archive member %s\n", hdr.ar_name);
d1032 1
a1032 1
	    }
d1036 1
a1036 1
	} else {
d1045 1
a1045 1
		   size, offset);
d1048 1
a1048 1
	    slash = strchr(hdr.ar_name, '/');
d1051 2
a1052 2
		slash = strchr(hdr.ar_name, ' ');
	    }
d1054 4
a1057 4

	    if ((slash - hdr.ar_name) > sizeof(hdr.ar_name))
		slash = hdr.ar_name + sizeof(hdr.ar_name) - 1;
	    *slash = '\000';
d1059 3
a1061 3
	if ((modtype = _GetModuleType(arfd, offset)) < 0) {
	    ErrorF("%s is an unrecognized module type\n", hdr.ar_name);
	    offsetbias = 0;
d1067 1
a1067 1
	tmp = _LoaderListPush();
d1073 1
a1073 1
	tmp->funcs = &funcs[modtype];
d1075 6
a1080 7
	    modnamesize = strlen(hdr.ar_name);
	    tmp->name =
		    (char *)xf86loadermalloc(arnamesize + modnamesize + 2);
	    strcpy(tmp->name, modrec->name);
	    strcat(tmp->name, ":");
	    strcat(tmp->name, hdr.ar_name);

d1084 1
a1084 1
	offsetbias = offset;
d1086 5
a1090 4
	if ((tmp->private = funcs[modtype].LoadModule(tmp, arfd, &lookup_ret))
	    == NULL) {
	    ErrorF("Failed to load %s\n", hdr.ar_name);
	    offsetbias = 0;
d1096 3
a1098 3
	offset = lseek(arfd, offset + size, SEEK_SET);
	if (offset & 0x1)	/* odd value */
	    lseek(arfd, 1, SEEK_CUR);	/* make it an even boundary */
d1100 1
a1100 1
	if (tmp->private == (void *)-1L) {
d1103 2
a1104 1
	} else
d1110 2
a1111 1
	for (i = 0, p = lookup_ret; p && p->symName; i++, p++) ;
d1114 1
a1114 1
					 * sizeof(LOOKUP));
d1116 1
a1116 1
		continue;	/* Oh well! */
d1118 1
a1118 1
	    memcpy(&(myLookup[numsyms]), lookup_ret, i * sizeof(LOOKUP));
d1125 1
a1125 1
    offsetbias = 0;
d1144 1
a1144 1
    loader_funcs *formatrec = (loader_funcs *) mod;
d1146 1
a1146 1
    return &(formatrec->pRelocs);
d1157 2
a1158 2
    loaderPtr tmp;
    int new_handle, modtype;
d1163 1
a1163 1
    ErrorF("LoaderOpen(%s)\n", module);
d1174 1
a1174 1
	while (tmp) {
d1176 2
a1177 2
	    ErrorF("strcmp(%x(%s),{%x} %x(%s))\n", module, module,
		   &(tmp->name), tmp->name, tmp->name);
d1179 1
a1179 1
	    if (!strcmp(module, tmp->name)) {
d1186 1
a1186 1
	    tmp = tmp->next;
d1193 1
a1193 1
    xf86Msg(X_INFO, "Loading %s\n", module);
d1201 2
a1202 2
    while (freeHandles[new_handle] && new_handle < MAX_HANDLE)
	new_handle++;
d1204 5
a1208 7
    if (new_handle == MAX_HANDLE) {
	xf86Msg(X_ERROR, "Out of loader space\n");	/* XXX */
	if (errmaj)
	    *errmaj = LDR_NOSPACE;
	if (errmin)
	    *errmin = LDR_NOSPACE;
	return -1;
d1211 1
a1211 1
    freeHandles[new_handle] = HANDLE_USED;
d1214 6
a1219 8
    if ((fd = open(module, O_RDONLY)) < 0) {
	xf86Msg(X_ERROR, "Unable to open %s\n", module);
	freeHandles[new_handle] = HANDLE_FREE;
	if (errmaj)
	    *errmaj = LDR_NOMODOPEN;
	if (errmin)
	    *errmin = errno;
	return -1;
d1222 5
a1226 7
    if ((modtype = _GetModuleType(fd, 0)) < 0) {
	xf86Msg(X_ERROR, "%s is an unrecognized module type\n", module);
	freeHandles[new_handle] = HANDLE_FREE;
	if (errmaj)
	    *errmaj = LDR_UNKTYPE;
	if (errmin)
	    *errmin = LDR_UNKTYPE;
d1230 1
a1230 1
    tmp = _LoaderListPush();
d1237 1
a1237 1
    tmp->funcs = &funcs[modtype];
d1239 2
a1240 2
    if ((tmp->private = funcs[modtype].LoadModule(tmp, fd, &pLookup)) == NULL) {
	xf86Msg(X_ERROR, "Failed to load %s\n", module);
d1242 3
a1244 5
	freeHandles[new_handle] = HANDLE_FREE;
	if (errmaj)
	    *errmaj = LDR_NOLOAD;
	if (errmin)
	    *errmin = LDR_NOLOAD;
d1248 1
a1248 1
    if (tmp->private != (void *)-1L) {
a1275 1

d1281 2
a1282 2
    if (item)
	return item->address;
d1285 1
a1285 1
	return (DLFindSymbol(sym));
d1295 1
a1295 2

    for (i = 0; i < numloaders; i++)
d1301 1
a1301 1
LoaderCheckUnresolved(int delay_flag)
d1303 2
a1304 2
    int i, ret = 0;
    LoaderResolveOptions delayFlag = (LoaderResolveOptions)delay_flag;
d1306 1
a1306 9
    LoaderResolveSymbols();

    if (delayFlag == LD_RESOLV_NOW) {
	if (check_unresolved_sema > 0)
	    check_unresolved_sema--;
	else
	    xf86Msg(X_WARNING, "LoaderCheckUnresolved: not enough "
		    "MAGIC_DONT_CHECK_UNRESOLVED\n");
    }
d1308 12
a1319 4
    if (!check_unresolved_sema || delayFlag == LD_RESOLV_FORCE)
	for (i = 0; i < numloaders; i++)
	    if (funcs[i].CheckForUnresolved(&funcs[i]))
		ret = 1;
d1321 2
a1322 2
    if (fatalReqSym)
	FatalError("Some required symbols were unresolved\n");
d1324 1
a1324 1
    return ret;
d1337 2
a1338 4
    ErrorF("\n\n\tThis should not happen!\n"
	   "\tAn unresolved function was called!\n");

    xf86LoaderTrap();
d1340 3
a1342 1
    FatalError("\n");
d1348 2
a1349 2
    loaderRec fakeHead;
    loaderPtr tmp = &fakeHead;
d1351 1
a1351 1
    if (handle < 0 || handle > MAX_HANDLE)
d1354 4
a1357 4
    /*
     * check the reference count, only free it if it goes to zero
     */
    if (--refCount[handle])
d1359 8
a1366 8
    /*
     * find the loaderRecs associated with this handle.
     */

    while ((tmp = _LoaderListPop(handle)) != NULL) {
	if (strchr(tmp->name, ':') == NULL) {
	    /* It is not a member of an archive */
	    xf86Msg(X_INFO, "Unloading %s\n", tmp->name);
d1372 3
a1374 3
    }

    freeHandles[handle] = HANDLE_FREE;
d1376 1
a1376 1
    return 0;
d1383 1
a1383 1
	   listHead ? listHead->name : "(built-in)");
d1389 1
a1389 2
void
_loader_debug_state()
d1398 1
a1398 1
    LoaderOptions = 0;
d1404 1
a1404 1
    LoaderOptions |= opts;
d1410 1
a1410 1
    LoaderOptions &= ~opts;
d1412 1
@


