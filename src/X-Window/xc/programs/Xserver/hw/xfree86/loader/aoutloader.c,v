head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.2
	cvs-200410241530:1.1.1.2
	cvs-200410012000:1.1.1.2
	cvs-200407221130:1.1.1.2
	cvs-200407141120:1.1.1.2
	cvs-200406231010:1.1.1.2
	MIRBSD_7quater:1.1.1.1
	cvs-200405271510:1.1.1.2
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.2
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.4
	MIRBSD_7:1.1.1.1.0.2
	MIRBSD_7ter:1.1.1.1
	cvs-20011091815:1.1.1.1
	cvs-200309162130:1.1.1.1
	cvs-200308302005:1.1.1.1
	ctmx-0387:1.1.1.1
	ctmx-0384:1.1.1.1
	MIRBSD_5:1.1.1.1
	ctmx-0375:1.1.1.1
	ctmx-0373:1.1.1.1
	ctm-0371:1.1.1.1
	ctm-0370:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-0363:1.1.1.1
	ctm-0359:1.1.1.1
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.08.29;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.08.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.03.02.18.24.06;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.24.58;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/aoutloader.c,v 1.17 2001/11/16 16:47:55 dawes Exp $ */

/*
 *
 * Copyright (c) 1997 Matthieu Herrb
 * Copyright 1995-1998 Metro Link, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Metro Link, Inc. not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Metro Link, Inc. makes no
 * representations about the suitability of this software for any purpose.
 *  It is provided "as is" without express or implied warranty.
 *
 * METRO LINK, INC. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL METRO LINK, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 *
 * Modified 21/02/97 by Sebastien Marineau to support OS/2 a.out objects
 */
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#ifdef __QNX__
#include <fcntl.h>
#else
#include <sys/fcntl.h>
#endif
#include <sys/stat.h>
#include <netinet/in.h>

#ifdef DBMALLOC
#include <debug/malloc.h>
#define Xalloc(size) malloc(size)
#define Xcalloc(size) calloc(1,(size))
#define Xfree(size) free(size)
#endif

#include "Xos.h"
#include "os.h"
#include "aout.h"

#include "sym.h"
#include "loader.h"
#include "aoutloader.h"

/*
#define AOUTDEBUG ErrorF
*/


#ifndef MIN
#define MIN(a,b) ((a)<(b)?(a):(b))
#endif

/*
 * This structure contains all of the information about a module
 * that has been loaded.
 */

typedef struct {
    int     handle;
    int     module;
    int     fd;
    loader_funcs	*funcs;
    AOUTHDR      *header;/* file header */
    unsigned char *text;       /* Start address of the text section */
    unsigned int  textsize;    /* Size of the text section */
    unsigned char *data;       /* Start address of the data section */
    unsigned int  datasize;    /* Size of the data section */
    unsigned char *bss;        /* Start address of the bss data */
    unsigned int  bsssize;     /* Size of the bss section */
    struct relocation_info *txtrel;    /* Start address of the text relocation table */
    struct relocation_info *datarel;    /* Start address of the data relocation table */
    AOUT_nlist *symtab;        /* Start address of the symbol table */
    unsigned char *strings;    /* Start address of the string table */
    unsigned long strsize;     /* size of string table */
    unsigned char *common;	/* Start address of the common data */
    unsigned long comsize;	/* size of common data */
} AOUTModuleRec, *AOUTModulePtr;

/*
 * If an relocation is unable to be satisfied, then put it on a list
 * to try later after more modules have been loaded.
 */
typedef struct AOUT_RELOC {
    AOUTModulePtr file;
    struct relocation_info *rel;
    int type;			/* AOUT_TEXT or AOUT_DATA */
    struct AOUT_RELOC *next;
} AOUTRelocRec;

/*
 * Symbols with a section number of 0 (N_UNDF) but a value of non-zero
 * need to have space allocated for them.
 *
 * Gather all of these symbols together, and allocate one chunk when we
 * are done.
 */

typedef struct AOUT_COMMON {
    struct AOUT_nlist *sym;
    int index;
    struct AOUT_COMMON *next;
} AOUTCommonRec;

static AOUTCommonPtr listCOMMON = NULL;

/* prototypes for static functions */
static int AOUTHashCleanOut(void *, itemPtr);
static char *AOUTGetSymbolName(AOUTModulePtr, struct AOUT_nlist *);
static void *AOUTGetSymbolValue(AOUTModulePtr, int);
static AOUTCommonPtr AOUTAddCommon(struct AOUT_nlist *, int);
static LOOKUP *AOUTCreateCommon(AOUTModulePtr);
static LOOKUP *AOUT_GetSymbols(AOUTModulePtr);
static AOUTRelocPtr AOUTDelayRelocation(AOUTModulePtr, int, struct relocation_info_i386 *);
static AOUTRelocPtr AOUTCollectRelocations(AOUTModulePtr);
static void AOUT_Relocate(unsigned long *, unsigned long, int);
static AOUTRelocPtr AOUT_RelocateEntry(AOUTModulePtr, int, struct relocation_info_i386 *);

/*
 * Return 1 if the symbol in item belongs to aoutfile
 */
static int
AOUTHashCleanOut(void *voidptr, itemPtr item)
{
    AOUTModulePtr aoutfile = (AOUTModulePtr) voidptr;
    return (aoutfile->handle == item->handle);
}

/*
 * Manage listResolv 
 */
static AOUTRelocPtr
AOUTDelayRelocation(AOUTModulePtr aoutfile, int type, 
			struct relocation_info *rel)
{
    AOUTRelocPtr reloc;

    if ((reloc = xf86loadermalloc(sizeof(AOUTRelocRec))) == NULL) {
	ErrorF("AOUTDelayRelocation() Unable to allocate memory\n");
	return NULL;
    }
    if ((unsigned long)rel < 0x200) {
	ErrorF("bug");
    }
    reloc->file = aoutfile;
    reloc->type = type;
    reloc->rel = rel;
    reloc->next = 0;
    return reloc;
}
	


/*
 * Manage listCOMMON
 */

static AOUTCommonPtr
AOUTAddCommon(struct AOUT_nlist *sym, int index)
{
    AOUTCommonPtr common;

    if ((common = xf86loadermalloc(sizeof (AOUTCommonRec))) == NULL) {
	ErrorF( "AOUTAddCommon() Unable to allocate memory\n" );
	return 0;
    }
    common->sym = sym;
    common->index = index;
    common->next = 0;
    return common;
}

static LOOKUP *
AOUTCreateCommon(AOUTModulePtr aoutfile)
{
    int	numsyms = 0, size = 0, l = 0;
    int	offset = 0;
    AOUTCommonPtr common;
    LOOKUP *lookup;

    if (listCOMMON == NULL)
	return NULL;

    common = listCOMMON;
    for (common = listCOMMON; common; common = common->next) {
	/* Ensure long word alignment */
	if( (common->sym->n_value & (sizeof(long)-1)) != 0 )
	    common->sym->n_value = (common->sym->n_value + (sizeof(long)-1))
	       & ~(sizeof(long)-1);

	/* accumulate the sizes */
	size += common->sym->n_value;
	numsyms++;
    } /* while */

#ifdef AOUTDEBUG
    AOUTDEBUG("AOUTCreateCommon() %d entries (%d bytes) of COMMON data\n",
	      numsyms, size );
#endif
    
    if ((lookup = xf86loadermalloc((numsyms+1)*sizeof(LOOKUP))) == NULL) {
        ErrorF( "AOUTCreateCommon() Unable to allocate memory\n" );
        return NULL;
    }
    
    aoutfile->comsize = size;
    if ((aoutfile->common = xf86loadercalloc(1,size)) == NULL) {
        ErrorF( "AOUTCreateCommon() Unable to allocate memory\n" );
        return NULL;
    }
    
    while (listCOMMON) {
        common = listCOMMON;
        lookup[l].symName= AOUTGetSymbolName(aoutfile, common->sym);
        lookup[l].offset = (funcptr)(aoutfile->common+offset);
#ifdef AOUTDEBUG
        AOUTDEBUG("Adding %x %s\n", lookup[l].offset, lookup[l].symName );
#endif
        listCOMMON = common->next;
        offset += common->sym->n_value;
        xf86loaderfree(common);
        l++;
    } /* while */
    /* listCOMMON == NULL */

    lookup[l].symName=NULL; /* Terminate the list */
    return lookup;
}

/*
 * Symbol Table
 */

static char *
AOUTGetString(AOUTModulePtr aoutfile, int index)
{
    char *symname = (char *) &(aoutfile->strings[index]);

    if (symname[0] == '_') {
	symname++;
    }

    return symname;
}
/*
 * Return the name of a symbol 
 */
static char *
AOUTGetSymbolName(AOUTModulePtr aoutfile, struct AOUT_nlist *sym)
{
    char *symname = AOUTGetString(aoutfile,sym->n_un.n_strx);
    char *name;

    name=xf86loadermalloc(strlen(symname)+1);
    if (!name)
	FatalError("AOUTGetSymbolName: Out of memory\n");

    strcpy(name,symname);

    return name;
}

/*
 * Return the value of a symbol in the loader's symbol table
 */
static void *
AOUTGetSymbolValue(AOUTModulePtr aoutfile, int index)
{
    void *symval = NULL; /* value of the indicated symbol */
    itemPtr symbol = NULL;		/* name/value of symbol */
    char *name = NULL;

    name = AOUTGetSymbolName(aoutfile, aoutfile->symtab + index);

    if( name )
	symbol = LoaderHashFind(name);

    if (symbol)
	symval = (unsigned char *)symbol->address;

    xf86loaderfree(name);
    return symval;
}


/*
 * Perform the actual relocation 
 */
static void
AOUT_Relocate(unsigned long *destl, unsigned long val, int pcrel)
{
#ifdef AOUTDEBUG
    AOUTDEBUG("AOUT_Relocate %p : %08x %s",
	      destl, *destl, pcrel == 1 ? "rel" : "abs");  

#endif
    if (pcrel) {
	/* relative to PC */
	*destl = val -  ((unsigned long)destl + sizeof(long));
    } else {
	*destl += val;
    }
#ifdef AOUTDEBUG
    AOUTDEBUG(" -> %08x\n", *destl);
#endif
}


/*
 * Fix the relocation for text or data section
 */
static AOUTRelocPtr
AOUT_RelocateEntry(AOUTModulePtr aoutfile, int type,
		   struct relocation_info *rel) 
{
    AOUTHDR *header = aoutfile->header;
    AOUT_nlist *symtab = aoutfile->symtab;
    int symnum;
    void *symval;
    unsigned long *destl;	/* address of the location to be modified */

    symnum = rel->r_symbolnum;
#ifdef AOUTDEBUG 
    {
    char *name;
    if (rel->r_extern) {
	AOUTDEBUG("AOUT_RelocateEntry: extern %s\n", 
		  name=AOUTGetSymbolName(aoutfile, symtab+symnum));
        xf86loaderfree(name);
    } else {
	AOUTDEBUG("AOUT_RelocateEntry: intern\n");
    }
    AOUTDEBUG("  pcrel: %d", rel->r_pcrel);
    AOUTDEBUG("  length: %d", rel->r_length);
    AOUTDEBUG("  baserel: %d", rel->r_baserel);
    AOUTDEBUG("  jmptable: %d", rel->r_jmptable);
    AOUTDEBUG("  relative: %d", rel->r_relative);
    AOUTDEBUG("  copy: %d\n", rel->r_copy);    
    }
#endif /* AOUTDEBUG */

    if (rel->r_length != 2) {
	ErrorF("AOUT_ReloateEntry: length != 2\n");
    }
    /* 
     * First find the address to modify
     */
    switch (type) {
      case AOUT_TEXT:
	/* Check that the relocation offset is in the text segment */
	if (rel->r_address > header->a_text) {
	    ErrorF("AOUT_RelocateEntry(): "
		   "text relocation out of text section\n");
	} 
	destl = (unsigned long *)(aoutfile->text + rel->r_address);
	break;
      case AOUT_DATA:
	/* Check that the relocation offset is in the data segment */
	if (rel->r_address > header->a_data) {
	    ErrorF("AOUT_RelocateEntry():"
		   "data relocation out of data section\n");
	}
	destl = (unsigned long *)(aoutfile->data + rel->r_address);
	break;
      default:
	ErrorF("AOUT_RelocateEntry(): unknown section type %d\n", type);
	return 0;
    } /* switch */

    /*
     * Now handle the relocation 
     */
    if (rel->r_extern) {
	/* Lookup the symbol in the loader's symbol table */
	symval = AOUTGetSymbolValue(aoutfile, symnum);
	if (symval != 0) {
	    /* we've got the value */
	    AOUT_Relocate(destl, (unsigned long) symval, rel->r_pcrel);
	    return 0;
	} else {
	    /* The symbol should be undefined */
	    switch (symtab[symnum].n_type & AOUT_TYPE) {
	      case AOUT_UNDF:
#ifdef AOUTDEBUG
		AOUTDEBUG("  extern AOUT_UNDEF\n");
#endif
		/* Add this relocation back to the global list */
		return AOUTDelayRelocation(aoutfile,type,rel);

	      default:
		ErrorF("AOUT_RelocateEntry():"
		       " impossible intern relocation type: %d\n", 
		       symtab[symnum].n_type);
		return 0;
	    } /* switch */
	}
    } else {
	/* intern */
	switch (rel->r_symbolnum) {
	  case AOUT_TEXT:
#ifdef AOUTDEBUG
	    AOUTDEBUG("  AOUT_TEXT\n");
#endif
	    /* Only absolute intern text relocations need to be handled */
	    if (rel->r_pcrel == 0) 
		AOUT_Relocate(destl, (unsigned long)aoutfile->text, 
			      rel->r_pcrel);
	    return 0;
	  case AOUT_DATA:
#ifdef AOUTDEBUG
	    AOUTDEBUG("  AOUT_DATA\n");
#endif
	    if (rel->r_pcrel == 0) 
		AOUT_Relocate(destl, (unsigned long)aoutfile->data
			      - header->a_text, rel->r_pcrel);
	    else
		ErrorF("AOUT_RelocateEntry(): "
		       "don't know how to handle data pc-relative reloc\n");
	    
	    return 0;
	  case AOUT_BSS:
#ifdef AOUTDEBUG
	    AOUTDEBUG("  AOUT_BSS\n");
#endif
	    if (rel->r_pcrel == 0)
		AOUT_Relocate(destl, (unsigned long)aoutfile->bss
			      - header->a_text - header->a_data, 
			      rel->r_pcrel);
	    else
		ErrorF("AOUT_RelocateEntry(): "
		       "don't know how to handle bss pc-relative reloc\n");
	    
	    return 0;
	  default:
	    ErrorF("AOUT_RelocateEntry():"
		   " unknown intern relocation type: %d\n", rel->r_symbolnum);
	    return 0;
	} /* switch */
    }
} /* AOUT_RelocateEntry */
    
static AOUTRelocPtr
AOUTCollectRelocations(AOUTModulePtr aoutfile)
{
    AOUTHDR *header = aoutfile->header;
    int i, nreloc;
    struct relocation_info *rel;
    AOUTRelocPtr reloc_head = NULL;
    AOUTRelocPtr tmp;

    /* Text relocations */
    if (aoutfile->text != NULL && aoutfile->txtrel != NULL) {
	nreloc = header->a_trsize/sizeof(struct relocation_info);

	for (i = 0; i < nreloc; i++) {
	    rel = aoutfile->txtrel + i;
	    tmp = AOUTDelayRelocation(aoutfile, AOUT_TEXT, rel);
	    if (tmp) {
		tmp->next = reloc_head;
		reloc_head = tmp;
	    }
	} /* for */
    }
    /* Data relocations */
    if (aoutfile->data != NULL && aoutfile->datarel != NULL) {
	nreloc = header->a_drsize/sizeof(struct relocation_info);
    
	for (i = 0; i < nreloc; i++) {
	    rel = aoutfile->datarel + i;
	    tmp = AOUTDelayRelocation(aoutfile, AOUT_DATA, rel);
	    tmp->next = reloc_head;
	    reloc_head = tmp;
	} /* for */
    }
    return reloc_head;
} /* AOUTCollectRelocations */

/*
 * AOUT_GetSymbols()
 * 
 * add the symbols to the loader's symbol table
 */
static LOOKUP * 
AOUT_GetSymbols(AOUTModulePtr aoutfile)
{
    int fd = aoutfile->fd;
    AOUTHDR *header = aoutfile->header;
    int nsyms, soff, i, l;
    char *symname;
    AOUT_nlist *s;
    LOOKUP *lookup, *lookup_common;
    AOUTCommonPtr tmp;

    aoutfile->symtab = (AOUT_nlist *)_LoaderFileToMem(fd,
						      AOUT_SYMOFF(header),
						      header->a_syms,
						      "symbols");
    nsyms = header->a_syms/sizeof(AOUT_nlist);
    lookup = xf86loadermalloc(nsyms * sizeof(LOOKUP));
    if (lookup == NULL) {
	ErrorF("AOUT_GetSymbols(): can't allocate memory\n");
	return NULL;
    }
    for (i = 0, l = 0; i < nsyms; i++) {
	s = aoutfile->symtab + i;
	soff=s->n_un.n_strx;
	if (soff == 0 || (s->n_type & AOUT_STAB) != 0) 
	    continue;
	symname=AOUTGetSymbolName(aoutfile,s);
#ifdef AOUTDEBUG
	AOUTDEBUG("AOUT_GetSymbols(): %s %02x %02x %08x\n",
		  symname, s->n_type,
		  s->n_other, s->n_value);
#endif
	switch (s->n_type & AOUT_TYPE) {
	  case AOUT_UNDF:
	    if (s->n_value != 0) {
		if (!LoaderHashFind(symname)) {
#ifdef AOUTDEBUG
		    AOUTDEBUG("Adding common %s\n", symname);
#endif
		    tmp = AOUTAddCommon(s, i);
		    if (tmp) {
			tmp->next = listCOMMON;
			listCOMMON = tmp;
		    }
		}
	    } else {
#ifdef AOUTDEBUG
		AOUTDEBUG("Adding undef %s\n", symname);
#endif
	    }
	    xf86loaderfree(symname);
	    break;
	  case AOUT_TEXT:
	    if (s->n_type & AOUT_EXT) {
		lookup[l].symName = symname;
		/* text symbols start at 0 */
		lookup[l].offset = (funcptr)(aoutfile->text + s->n_value);
#ifdef AOUTDEBUG
		AOUTDEBUG("Adding text %s %08x\n", symname, lookup[l].offset);
#endif
		l++;
	    } else {
		xf86loaderfree(symname);
	    }
	    break;
	  case AOUT_DATA :
	    if (s->n_type & AOUT_EXT) {
		lookup[l].symName = symname;
		/* data symbols are following text */
		lookup[l].offset = (funcptr)(aoutfile->data + 
					       s->n_value - header->a_text);
#ifdef AOUTDEBUG
		AOUTDEBUG("Adding data %s %08x\n", symname, lookup[l].offset);
#endif
		l++;
	    } else {
		xf86loaderfree(symname);
	    }
	    break;
	  case AOUT_BSS:
	    if (s->n_type & AOUT_EXT) {
		lookup[l].symName = symname;
		/* bss symbols follow both text and data */
		lookup[l].offset = (funcptr)(aoutfile->bss + s->n_value 
					       - (header->a_data 
						  + header->a_text));
#ifdef AOUTDEBUG
		AOUTDEBUG("Adding bss %s %08x\n", symname, lookup[l].offset);
#endif
		l++;
	    } else {
		xf86loaderfree(symname);
	    }
	    break;
	  case AOUT_FN:
#ifdef AOUTDEBUG
	    if (n->n_type& AOUT_EXT) {
		AOUTDEBUG("Ignoring AOUT_FN %s\n", symname);
	    } else {
		AOUTDEBUG("Ignoring AOUT_WARN %s\n", symname);
	    }
#endif
	    xf86loaderfree(symname);
	    break;
	  default:
		ErrorF("Unknown symbol type %x\n", s->n_type & AOUT_TYPE);
		xf86loaderfree(symname);
	} /* switch */
    } /* for */
    lookup[l].symName = NULL;
    
    lookup_common = AOUTCreateCommon(aoutfile);
    if (lookup_common) {
	LOOKUP *p;

	for (i = 0, p = lookup_common; p->symName; i++, p++)
	    ;
	memcpy(&(lookup[l]), lookup_common, i * sizeof (LOOKUP));

	xf86loaderfree(lookup_common);
	l += i;
	lookup[l].symName = NULL;
    }
    return lookup;
} /* AOUT_GetSymbols */

/*
 * Public API for the a.out implementation of the loader
 */
void *
AOUTLoadModule(loaderPtr modrec,
	       int aoutfd,
	       LOOKUP **ppLookup)
{
    AOUTModulePtr aoutfile = NULL;
    AOUTHDR *header;
    AOUTRelocPtr reloc, tail;
    void	*v;

#ifdef AOUTDEBUG
    AOUTDEBUG("AOUTLoadModule(%s, %d, %d)\n",
	      modrec->name, modrec->handle, aoutfd);
#endif
    if ((aoutfile=xf86loadercalloc(1,sizeof(AOUTModuleRec))) == NULL ) {
	ErrorF( "Unable to allocate AOUTModuleRec\n" );
	return NULL;
    }

    aoutfile->handle=modrec->handle;
    aoutfile->module=modrec->module;
    aoutfile->fd=aoutfd;
    v=aoutfile->funcs=modrec->funcs;

    /*
     *  Get the a.out header
     */
    aoutfile->header=(AOUTHDR *)_LoaderFileToMem(aoutfd,0,sizeof(AOUTHDR),
						 "header");
    header= (AOUTHDR *)aoutfile->header;

    /* 
     * Load the 6 other sections 
     */
    /* text */
    if (header->a_text != 0) {
	aoutfile->text = _LoaderFileToMem(aoutfile->fd, 
					  AOUT_TXTOFF(header),
					  header->a_text, "text");
	aoutfile->textsize = header->a_text;
    } else {
	aoutfile->text = NULL;
    }
    /* data */
    if (header->a_data != 0) {
	aoutfile->data = _LoaderFileToMem(aoutfile->fd,
					  AOUT_DATOFF(header),
					  header->a_data, "data");
	aoutfile->datasize = header->a_data;
    } else {
	aoutfile->data = NULL;
    }
    /* bss */
    if (header->a_bss != 0) {
	aoutfile->bss = xf86loadercalloc(1, header->a_bss);
	aoutfile->bsssize = header->a_bss;
    } else {
	aoutfile->bss = NULL;
    }
    /* Text Relocations */
    if (header->a_trsize != 0) {
	aoutfile->txtrel = _LoaderFileToMem(aoutfile->fd,
					    AOUT_TRELOFF(header),
					    header->a_trsize, "txtrel");
    } else {
	aoutfile->txtrel = NULL;
    }
    /* Data Relocations */
    if (header->a_drsize != 0) {
	aoutfile->datarel = _LoaderFileToMem(aoutfile->fd,
					    AOUT_DRELOFF(header),
					    header->a_drsize, "datarel");
    } else {
	aoutfile->datarel = NULL;
    }
    /* String table */
    _LoaderFileRead(aoutfile->fd, AOUT_STROFF(header), 
		    &(aoutfile->strsize), sizeof(int));
    if (aoutfile->strsize != 0) {
	aoutfile->strings = _LoaderFileToMem(aoutfile->fd,
					     AOUT_STROFF(header),
					     aoutfile->strsize, "strings");
    } else {
	aoutfile->strings = NULL;
    }
    /* load symbol table */
    *ppLookup = AOUT_GetSymbols(aoutfile);

    /* Do relocations */
    reloc = AOUTCollectRelocations(aoutfile);

    if (reloc) {
	for (tail = reloc; tail->next; tail = tail->next)
	    ;
	tail->next = _LoaderGetRelocations(v)->aout_reloc;
	_LoaderGetRelocations(v)->aout_reloc = reloc;
    }

    return (void *)aoutfile;
}

void
AOUTResolveSymbols(mod)
void	*mod;
{
    AOUTRelocPtr newlist, p, tmp;

#ifdef AOUTDEBUG
    AOUTDEBUG("AOUTResolveSymbols()\n");
#endif

    newlist = 0;
    for (p = _LoaderGetRelocations(mod)->aout_reloc; p; ) {
	tmp = AOUT_RelocateEntry(p->file, p->type, p->rel);
	if (tmp) {
	    /* Failed to relocate.  Keep it in the list. */
	    tmp->next = newlist;
	    newlist = tmp;
	}
	tmp = p;
	p = p->next;
	xf86loaderfree(tmp);
    }
    _LoaderGetRelocations(mod)->aout_reloc = newlist;
} /* AOUTResolveSymbols */

int
AOUTCheckForUnresolved(mod)
void	*mod;
{
    int symnum;
    AOUTRelocPtr crel;
    char *name;
    int fatalsym = 0, flag;

#ifdef AOUTDEBUG
    AOUTDEBUG("AOUTCheckForUnResolved()\n");
#endif
    if ((crel = _LoaderGetRelocations(mod)->aout_reloc) == NULL)
	return 0;

    while (crel) {
	if (crel->type == AOUT_TEXT) {
	    /* Attempt to make unresolved  text references 
	       point to a default function */
	    AOUT_Relocate((unsigned long *)(crel->file->text 
					    + crel->rel->r_address) ,
			  (unsigned long)LoaderDefaultFunc, 
			  crel->rel->r_pcrel);
	}
	symnum = crel->rel->r_symbolnum;
        name=AOUTGetSymbolName(crel->file, crel->file->symtab + symnum);
        flag = _LoaderHandleUnresolved(name,
		   _LoaderHandleToName(crel->file->handle));
	xf86loaderfree(name);
        if (flag) fatalsym = 1;
	crel = crel->next;
    }
    return fatalsym;
}

void
AOUTUnloadModule(void *modptr)
{
    AOUTModulePtr aoutfile = (AOUTModulePtr)modptr;
    AOUTRelocPtr relptr, *prevptr;
#ifdef AOUTDEBUG
    AOUTDEBUG("AOUTUnLoadModule(0x%p)\n", modptr);
#endif

/*
 * Delete any unresolved relocations
 */

    relptr=_LoaderGetRelocations(aoutfile->funcs)->aout_reloc;
    prevptr=&(_LoaderGetRelocations(aoutfile->funcs)->aout_reloc);

    while (relptr) {
	if (relptr->file == aoutfile) {
	    *prevptr = relptr->next;
	    xf86loaderfree(relptr);
	    relptr = *prevptr;
	} else {
	    prevptr = &(relptr->next);
	    relptr = relptr->next;
	}
    } /* while */
	    
    /* clean the symbols table */
    LoaderHashTraverse((void *)aoutfile, AOUTHashCleanOut);

#define CheckandFree(ptr,size)  if(ptr) _LoaderFreeFileMem((ptr),(size))

    CheckandFree(aoutfile->strings,aoutfile->strsize);
    CheckandFree(aoutfile->symtab,aoutfile->header->a_syms);
    CheckandFree(aoutfile->datarel,aoutfile->header->a_drsize);
    CheckandFree(aoutfile->txtrel,aoutfile->header->a_trsize);
    CheckandFree(aoutfile->data,aoutfile->header->a_data);
    CheckandFree(aoutfile->text,aoutfile->header->a_text);
    /* Free allocated sections */
    if (aoutfile->bss != NULL) {
	xf86loaderfree(aoutfile->bss);
    }
    if (aoutfile->common != NULL) {
	xf86loaderfree(aoutfile->common);
    }

    /* Free header */
    _LoaderFreeFileMem(aoutfile->header, sizeof(AOUTHDR));

    /* Free the module structure itself */
    xf86loaderfree(aoutfile);

    return;
}

char *
AOUTAddressToSection(void *modptr, unsigned long address)
{
    AOUTModulePtr aoutfile = (AOUTModulePtr)modptr;

    if( address >= (unsigned long)aoutfile->text &&
            address <= (unsigned long)aoutfile->text+aoutfile->textsize ) {
                return "text";
                }
    if( address >= (unsigned long)aoutfile->data &&
            address <= (unsigned long)aoutfile->data+aoutfile->datasize ) {
                return "data";
                }
    if( address >= (unsigned long)aoutfile->bss &&
            address <= (unsigned long)aoutfile->bss+aoutfile->bsssize ) {
                return "bss";
                }

    return NULL;
}

@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/aoutloader.c,v 1.20 2003/10/15 17:46:00 dawes Exp $ */
d55 3
a57 3
#ifndef LOADERDEBUG
#define LOADERDEBUG 0
#endif
a58 3
#if LOADERDEBUG
#define AOUTDEBUG ErrorF
#endif
d70 16
a85 16
    int handle;
    int module;
    int fd;
    loader_funcs *funcs;
    AOUTHDR *header;		/* file header */
    unsigned char *text;	/* Start address of the text section */
    unsigned int textsize;	/* Size of the text section */
    unsigned char *data;	/* Start address of the data section */
    unsigned int datasize;	/* Size of the data section */
    unsigned char *bss;		/* Start address of the bss data */
    unsigned int bsssize;	/* Size of the bss section */
    struct relocation_info *txtrel;	/* Start address of the text relocation table */
    struct relocation_info *datarel;	/* Start address of the data relocation table */
    AOUT_nlist *symtab;		/* Start address of the symbol table */
    unsigned char *strings;	/* Start address of the string table */
    unsigned long strsize;	/* size of string table */
d124 1
a124 2
static AOUTRelocPtr AOUTDelayRelocation(AOUTModulePtr, int,
					struct relocation_info_i386 *);
d127 1
a127 2
static AOUTRelocPtr AOUT_RelocateEntry(AOUTModulePtr, int,
				       struct relocation_info_i386 *);
a135 1

d143 2
a144 2
AOUTDelayRelocation(AOUTModulePtr aoutfile, int type,
		    struct relocation_info *rel)
d161 2
d173 2
a174 2
    if ((common = xf86loadermalloc(sizeof(AOUTCommonRec))) == NULL) {
	ErrorF("AOUTAddCommon() Unable to allocate memory\n");
d186 2
a187 2
    int numsyms = 0, size = 0, l = 0;
    int offset = 0;
d197 3
a199 3
	if ((common->sym->n_value & (sizeof(long) - 1)) != 0)
	    common->sym->n_value = (common->sym->n_value + (sizeof(long) - 1))
		    & ~(sizeof(long) - 1);
d204 1
a204 1
    }				/* while */
d208 1
a208 1
	      numsyms, size);
d210 4
a213 4

    if ((lookup = xf86loadermalloc((numsyms + 1) * sizeof(LOOKUP))) == NULL) {
	ErrorF("AOUTCreateCommon() Unable to allocate memory\n");
	return NULL;
d215 1
a215 1

d217 3
a219 3
    if ((aoutfile->common = xf86loadercalloc(1, size)) == NULL) {
	ErrorF("AOUTCreateCommon() Unable to allocate memory\n");
	return NULL;
d221 1
a221 1

d223 11
a233 12
	common = listCOMMON;
	lookup[l].symName = AOUTGetSymbolName(aoutfile, common->sym);
	lookup[l].offset = (funcptr) (aoutfile->common + offset);
#ifdef AOUTDEBUG
	AOUTDEBUG("Adding %p %s\n", (void *)lookup[l].offset,
		  lookup[l].symName);
#endif
	listCOMMON = common->next;
	offset += common->sym->n_value;
	xf86loaderfree(common);
	l++;
    }				/* while */
d236 1
a236 1
    lookup[l].symName = NULL;	/* Terminate the list */
d247 1
a247 1
    char *symname = (char *)&(aoutfile->strings[index]);
a254 1

d261 1
a261 1
    char *symname = AOUTGetString(aoutfile, sym->n_un.n_strx);
d264 1
a264 1
    name = xf86loadermalloc(strlen(symname) + 1);
d268 1
a268 1
    strcpy(name, symname);
d279 2
a280 2
    void *symval = NULL;	/* value of the indicated symbol */
    itemPtr symbol = NULL;	/* name/value of symbol */
d285 1
a285 1
    if (name)
d295 1
d303 2
a304 2
    AOUTDEBUG("AOUT_Relocate %p : %08lx %s",
	      (void *)destl, *destl, pcrel == 1 ? "rel" : "abs");
d309 1
a309 1
	*destl = val - ((unsigned long)destl + sizeof(long));
d314 1
a314 1
    AOUTDEBUG(" -> %08lx\n", *destl);
d318 1
d324 1
a324 1
		   struct relocation_info *rel)
d333 1
a333 1
#ifdef AOUTDEBUG
d335 14
a348 15
	char *name;

	if (rel->r_extern) {
	    AOUTDEBUG("AOUT_RelocateEntry: extern %s\n",
		      name = AOUTGetSymbolName(aoutfile, symtab + symnum));
	    xf86loaderfree(name);
	} else {
	    AOUTDEBUG("AOUT_RelocateEntry: intern\n");
	}
	AOUTDEBUG("  pcrel: %d", rel->r_pcrel);
	AOUTDEBUG("  length: %d", rel->r_length);
	AOUTDEBUG("  baserel: %d", rel->r_baserel);
	AOUTDEBUG("  jmptable: %d", rel->r_jmptable);
	AOUTDEBUG("  relative: %d", rel->r_relative);
	AOUTDEBUG("  copy: %d\n", rel->r_copy);
d359 1
a359 1
    case AOUT_TEXT:
d364 1
a364 1
	}
d367 1
a367 1
    case AOUT_DATA:
d375 1
a375 1
    default:
d378 1
a378 1
    }				/* switch */
d388 1
a388 1
	    AOUT_Relocate(destl, (unsigned long)symval, rel->r_pcrel);
d393 1
a393 1
	    case AOUT_UNDF:
d398 1
a398 1
		return AOUTDelayRelocation(aoutfile, type, rel);
d400 1
a400 1
	    default:
d402 1
a402 1
		       " impossible intern relocation type: %d\n",
d405 1
a405 1
	    }			/* switch */
d410 1
a410 1
	case AOUT_TEXT:
d415 2
a416 2
	    if (rel->r_pcrel == 0)
		AOUT_Relocate(destl, (unsigned long)aoutfile->text,
d419 1
a419 1
	case AOUT_DATA:
d423 1
a423 1
	    if (rel->r_pcrel == 0)
d429 1
a429 1

d431 1
a431 1
	case AOUT_BSS:
d437 1
a437 1
			      - header->a_text - header->a_data,
d442 1
a442 1

d444 1
a444 1
	default:
d448 1
a448 1
	}			/* switch */
d450 2
a451 2
}				/* AOUT_RelocateEntry */

d463 1
a463 1
	nreloc = header->a_trsize / sizeof(struct relocation_info);
d472 1
a472 1
	}			/* for */
d476 2
a477 2
	nreloc = header->a_drsize / sizeof(struct relocation_info);

d483 1
a483 1
	}			/* for */
d486 1
a486 1
}				/* AOUTCollectRelocations */
d493 1
a493 1
static LOOKUP *
d504 5
a508 5
    aoutfile->symtab = (AOUT_nlist *) _LoaderFileToMem(fd,
						       AOUT_SYMOFF(header),
						       header->a_syms,
						       "symbols");
    nsyms = header->a_syms / sizeof(AOUT_nlist);
d516 2
a517 2
	soff = s->n_un.n_strx;
	if (soff == 0 || (s->n_type & AOUT_STAB) != 0)
d519 1
a519 1
	symname = AOUTGetSymbolName(aoutfile, s);
d521 3
a523 2
	AOUTDEBUG("AOUT_GetSymbols(): %s %02x %02x %08lx\n",
		  symname, s->n_type, s->n_other, s->n_value);
d526 1
a526 1
	case AOUT_UNDF:
d545 1
a545 1
	case AOUT_TEXT:
d549 1
a549 1
		lookup[l].offset = (funcptr) (aoutfile->text + s->n_value);
d551 1
a551 2
		AOUTDEBUG("Adding text %s %p\n", symname,
			  (void *)lookup[l].offset);
d558 1
a558 1
	case AOUT_DATA:
d562 2
a563 2
		lookup[l].offset = (funcptr) (aoutfile->data +
					      s->n_value - header->a_text);
d565 1
a565 2
		AOUTDEBUG("Adding data %s %p\n", symname,
			  (void *)lookup[l].offset);
d572 1
a572 1
	case AOUT_BSS:
d576 3
a578 3
		lookup[l].offset = (funcptr) (aoutfile->bss + s->n_value
					      - (header->a_data
						 + header->a_text));
d580 1
a580 2
		AOUTDEBUG("Adding bss %s %p\n", symname,
			  (void *)lookup[l].offset);
d587 1
a587 1
	case AOUT_FN:
d589 1
a589 1
	    if (s->n_type & AOUT_EXT) {
d597 5
a601 5
	default:
	    ErrorF("Unknown symbol type %x\n", s->n_type & AOUT_TYPE);
	    xf86loaderfree(symname);
	}			/* switch */
    }				/* for */
d603 1
a603 1

d608 3
a610 2
	for (i = 0, p = lookup_common; p->symName; i++, p++) ;
	memcpy(&(lookup[l]), lookup_common, i * sizeof(LOOKUP));
d617 1
a617 1
}				/* AOUT_GetSymbols */
d623 3
a625 1
AOUTLoadModule(loaderPtr modrec, int aoutfd, LOOKUP ** ppLookup)
d630 1
a630 1
    void *v;
d636 2
a637 2
    if ((aoutfile = xf86loadercalloc(1, sizeof(AOUTModuleRec))) == NULL) {
	ErrorF("Unable to allocate AOUTModuleRec\n");
d641 4
a644 4
    aoutfile->handle = modrec->handle;
    aoutfile->module = modrec->module;
    aoutfile->fd = aoutfd;
    v = aoutfile->funcs = modrec->funcs;
d649 3
a651 4
    aoutfile->header =
	    (AOUTHDR *) _LoaderFileToMem(aoutfd, 0, sizeof(AOUTHDR),
					 "header");
    header = (AOUTHDR *) aoutfile->header;
d658 1
a658 1
	aoutfile->text = _LoaderFileToMem(aoutfile->fd,
d692 2
a693 2
					     AOUT_DRELOFF(header),
					     header->a_drsize, "datarel");
d698 1
a698 1
    _LoaderFileRead(aoutfile->fd, AOUT_STROFF(header),
d714 2
a715 1
	for (tail = reloc; tail->next; tail = tail->next) ;
d724 2
a725 1
AOUTResolveSymbols(void *mod)
d734 1
a734 1
    for (p = _LoaderGetRelocations(mod)->aout_reloc; p;) {
d746 1
a746 1
}				/* AOUTResolveSymbols */
d749 2
a750 1
AOUTCheckForUnresolved(void *mod)
d766 4
a769 4
	     * point to a default function */
	    AOUT_Relocate((unsigned long *)(crel->file->text
					    + crel->rel->r_address),
			  (unsigned long)LoaderDefaultFunc,
d773 3
a775 4
	name = AOUTGetSymbolName(crel->file, crel->file->symtab + symnum);
	flag = _LoaderHandleUnresolved(name,
				       _LoaderHandleToName(crel->file->
							   handle));
d777 1
a777 2
	if (flag)
	    fatalsym = 1;
d786 1
a786 1
    AOUTModulePtr aoutfile = (AOUTModulePtr) modptr;
a787 1

d796 2
a797 2
    relptr = _LoaderGetRelocations(aoutfile->funcs)->aout_reloc;
    prevptr = &(_LoaderGetRelocations(aoutfile->funcs)->aout_reloc);
d808 2
a809 2
    }				/* while */

d815 6
a820 6
    CheckandFree(aoutfile->strings, aoutfile->strsize);
    CheckandFree(aoutfile->symtab, aoutfile->header->a_syms);
    CheckandFree(aoutfile->datarel, aoutfile->header->a_drsize);
    CheckandFree(aoutfile->txtrel, aoutfile->header->a_trsize);
    CheckandFree(aoutfile->data, aoutfile->header->a_data);
    CheckandFree(aoutfile->text, aoutfile->header->a_text);
d841 1
a841 1
    AOUTModulePtr aoutfile = (AOUTModulePtr) modptr;
d843 12
a854 12
    if (address >= (unsigned long)aoutfile->text &&
	address <= (unsigned long)aoutfile->text + aoutfile->textsize) {
	return "text";
    }
    if (address >= (unsigned long)aoutfile->data &&
	address <= (unsigned long)aoutfile->data + aoutfile->datasize) {
	return "data";
    }
    if (address >= (unsigned long)aoutfile->bss &&
	address <= (unsigned long)aoutfile->bss + aoutfile->bsssize) {
	return "bss";
    }
d858 1
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/hw/xfree86/loader/aoutloader.c,v 1.20 2003/10/15 17:46:00 dawes Exp $ */
d55 3
a57 3
#ifndef LOADERDEBUG
#define LOADERDEBUG 0
#endif
a58 3
#if LOADERDEBUG
#define AOUTDEBUG ErrorF
#endif
d70 16
a85 16
    int handle;
    int module;
    int fd;
    loader_funcs *funcs;
    AOUTHDR *header;		/* file header */
    unsigned char *text;	/* Start address of the text section */
    unsigned int textsize;	/* Size of the text section */
    unsigned char *data;	/* Start address of the data section */
    unsigned int datasize;	/* Size of the data section */
    unsigned char *bss;		/* Start address of the bss data */
    unsigned int bsssize;	/* Size of the bss section */
    struct relocation_info *txtrel;	/* Start address of the text relocation table */
    struct relocation_info *datarel;	/* Start address of the data relocation table */
    AOUT_nlist *symtab;		/* Start address of the symbol table */
    unsigned char *strings;	/* Start address of the string table */
    unsigned long strsize;	/* size of string table */
d124 1
a124 2
static AOUTRelocPtr AOUTDelayRelocation(AOUTModulePtr, int,
					struct relocation_info_i386 *);
d127 1
a127 2
static AOUTRelocPtr AOUT_RelocateEntry(AOUTModulePtr, int,
				       struct relocation_info_i386 *);
a135 1

d143 2
a144 2
AOUTDelayRelocation(AOUTModulePtr aoutfile, int type,
		    struct relocation_info *rel)
d161 2
d173 2
a174 2
    if ((common = xf86loadermalloc(sizeof(AOUTCommonRec))) == NULL) {
	ErrorF("AOUTAddCommon() Unable to allocate memory\n");
d186 2
a187 2
    int numsyms = 0, size = 0, l = 0;
    int offset = 0;
d197 3
a199 3
	if ((common->sym->n_value & (sizeof(long) - 1)) != 0)
	    common->sym->n_value = (common->sym->n_value + (sizeof(long) - 1))
		    & ~(sizeof(long) - 1);
d204 1
a204 1
    }				/* while */
d208 1
a208 1
	      numsyms, size);
d210 4
a213 4

    if ((lookup = xf86loadermalloc((numsyms + 1) * sizeof(LOOKUP))) == NULL) {
	ErrorF("AOUTCreateCommon() Unable to allocate memory\n");
	return NULL;
d215 1
a215 1

d217 3
a219 3
    if ((aoutfile->common = xf86loadercalloc(1, size)) == NULL) {
	ErrorF("AOUTCreateCommon() Unable to allocate memory\n");
	return NULL;
d221 1
a221 1

d223 11
a233 12
	common = listCOMMON;
	lookup[l].symName = AOUTGetSymbolName(aoutfile, common->sym);
	lookup[l].offset = (funcptr) (aoutfile->common + offset);
#ifdef AOUTDEBUG
	AOUTDEBUG("Adding %p %s\n", (void *)lookup[l].offset,
		  lookup[l].symName);
#endif
	listCOMMON = common->next;
	offset += common->sym->n_value;
	xf86loaderfree(common);
	l++;
    }				/* while */
d236 1
a236 1
    lookup[l].symName = NULL;	/* Terminate the list */
d247 1
a247 1
    char *symname = (char *)&(aoutfile->strings[index]);
a254 1

d261 1
a261 1
    char *symname = AOUTGetString(aoutfile, sym->n_un.n_strx);
d264 1
a264 1
    name = xf86loadermalloc(strlen(symname) + 1);
d268 1
a268 1
    strcpy(name, symname);
d279 2
a280 2
    void *symval = NULL;	/* value of the indicated symbol */
    itemPtr symbol = NULL;	/* name/value of symbol */
d285 1
a285 1
    if (name)
d295 1
d303 2
a304 2
    AOUTDEBUG("AOUT_Relocate %p : %08lx %s",
	      (void *)destl, *destl, pcrel == 1 ? "rel" : "abs");
d309 1
a309 1
	*destl = val - ((unsigned long)destl + sizeof(long));
d314 1
a314 1
    AOUTDEBUG(" -> %08lx\n", *destl);
d318 1
d324 1
a324 1
		   struct relocation_info *rel)
d333 1
a333 1
#ifdef AOUTDEBUG
d335 14
a348 15
	char *name;

	if (rel->r_extern) {
	    AOUTDEBUG("AOUT_RelocateEntry: extern %s\n",
		      name = AOUTGetSymbolName(aoutfile, symtab + symnum));
	    xf86loaderfree(name);
	} else {
	    AOUTDEBUG("AOUT_RelocateEntry: intern\n");
	}
	AOUTDEBUG("  pcrel: %d", rel->r_pcrel);
	AOUTDEBUG("  length: %d", rel->r_length);
	AOUTDEBUG("  baserel: %d", rel->r_baserel);
	AOUTDEBUG("  jmptable: %d", rel->r_jmptable);
	AOUTDEBUG("  relative: %d", rel->r_relative);
	AOUTDEBUG("  copy: %d\n", rel->r_copy);
d359 1
a359 1
    case AOUT_TEXT:
d364 1
a364 1
	}
d367 1
a367 1
    case AOUT_DATA:
d375 1
a375 1
    default:
d378 1
a378 1
    }				/* switch */
d388 1
a388 1
	    AOUT_Relocate(destl, (unsigned long)symval, rel->r_pcrel);
d393 1
a393 1
	    case AOUT_UNDF:
d398 1
a398 1
		return AOUTDelayRelocation(aoutfile, type, rel);
d400 1
a400 1
	    default:
d402 1
a402 1
		       " impossible intern relocation type: %d\n",
d405 1
a405 1
	    }			/* switch */
d410 1
a410 1
	case AOUT_TEXT:
d415 2
a416 2
	    if (rel->r_pcrel == 0)
		AOUT_Relocate(destl, (unsigned long)aoutfile->text,
d419 1
a419 1
	case AOUT_DATA:
d423 1
a423 1
	    if (rel->r_pcrel == 0)
d429 1
a429 1

d431 1
a431 1
	case AOUT_BSS:
d437 1
a437 1
			      - header->a_text - header->a_data,
d442 1
a442 1

d444 1
a444 1
	default:
d448 1
a448 1
	}			/* switch */
d450 2
a451 2
}				/* AOUT_RelocateEntry */

d463 1
a463 1
	nreloc = header->a_trsize / sizeof(struct relocation_info);
d472 1
a472 1
	}			/* for */
d476 2
a477 2
	nreloc = header->a_drsize / sizeof(struct relocation_info);

d483 1
a483 1
	}			/* for */
d486 1
a486 1
}				/* AOUTCollectRelocations */
d493 1
a493 1
static LOOKUP *
d504 5
a508 5
    aoutfile->symtab = (AOUT_nlist *) _LoaderFileToMem(fd,
						       AOUT_SYMOFF(header),
						       header->a_syms,
						       "symbols");
    nsyms = header->a_syms / sizeof(AOUT_nlist);
d516 2
a517 2
	soff = s->n_un.n_strx;
	if (soff == 0 || (s->n_type & AOUT_STAB) != 0)
d519 1
a519 1
	symname = AOUTGetSymbolName(aoutfile, s);
d521 3
a523 2
	AOUTDEBUG("AOUT_GetSymbols(): %s %02x %02x %08lx\n",
		  symname, s->n_type, s->n_other, s->n_value);
d526 1
a526 1
	case AOUT_UNDF:
d545 1
a545 1
	case AOUT_TEXT:
d549 1
a549 1
		lookup[l].offset = (funcptr) (aoutfile->text + s->n_value);
d551 1
a551 2
		AOUTDEBUG("Adding text %s %p\n", symname,
			  (void *)lookup[l].offset);
d558 1
a558 1
	case AOUT_DATA:
d562 2
a563 2
		lookup[l].offset = (funcptr) (aoutfile->data +
					      s->n_value - header->a_text);
d565 1
a565 2
		AOUTDEBUG("Adding data %s %p\n", symname,
			  (void *)lookup[l].offset);
d572 1
a572 1
	case AOUT_BSS:
d576 3
a578 3
		lookup[l].offset = (funcptr) (aoutfile->bss + s->n_value
					      - (header->a_data
						 + header->a_text));
d580 1
a580 2
		AOUTDEBUG("Adding bss %s %p\n", symname,
			  (void *)lookup[l].offset);
d587 1
a587 1
	case AOUT_FN:
d589 1
a589 1
	    if (s->n_type & AOUT_EXT) {
d597 5
a601 5
	default:
	    ErrorF("Unknown symbol type %x\n", s->n_type & AOUT_TYPE);
	    xf86loaderfree(symname);
	}			/* switch */
    }				/* for */
d603 1
a603 1

d608 3
a610 2
	for (i = 0, p = lookup_common; p->symName; i++, p++) ;
	memcpy(&(lookup[l]), lookup_common, i * sizeof(LOOKUP));
d617 1
a617 1
}				/* AOUT_GetSymbols */
d623 3
a625 1
AOUTLoadModule(loaderPtr modrec, int aoutfd, LOOKUP ** ppLookup)
d630 1
a630 1
    void *v;
d636 2
a637 2
    if ((aoutfile = xf86loadercalloc(1, sizeof(AOUTModuleRec))) == NULL) {
	ErrorF("Unable to allocate AOUTModuleRec\n");
d641 4
a644 4
    aoutfile->handle = modrec->handle;
    aoutfile->module = modrec->module;
    aoutfile->fd = aoutfd;
    v = aoutfile->funcs = modrec->funcs;
d649 3
a651 4
    aoutfile->header =
	    (AOUTHDR *) _LoaderFileToMem(aoutfd, 0, sizeof(AOUTHDR),
					 "header");
    header = (AOUTHDR *) aoutfile->header;
d658 1
a658 1
	aoutfile->text = _LoaderFileToMem(aoutfile->fd,
d692 2
a693 2
					     AOUT_DRELOFF(header),
					     header->a_drsize, "datarel");
d698 1
a698 1
    _LoaderFileRead(aoutfile->fd, AOUT_STROFF(header),
d714 2
a715 1
	for (tail = reloc; tail->next; tail = tail->next) ;
d724 2
a725 1
AOUTResolveSymbols(void *mod)
d734 1
a734 1
    for (p = _LoaderGetRelocations(mod)->aout_reloc; p;) {
d746 1
a746 1
}				/* AOUTResolveSymbols */
d749 2
a750 1
AOUTCheckForUnresolved(void *mod)
d766 4
a769 4
	     * point to a default function */
	    AOUT_Relocate((unsigned long *)(crel->file->text
					    + crel->rel->r_address),
			  (unsigned long)LoaderDefaultFunc,
d773 3
a775 4
	name = AOUTGetSymbolName(crel->file, crel->file->symtab + symnum);
	flag = _LoaderHandleUnresolved(name,
				       _LoaderHandleToName(crel->file->
							   handle));
d777 1
a777 2
	if (flag)
	    fatalsym = 1;
d786 1
a786 1
    AOUTModulePtr aoutfile = (AOUTModulePtr) modptr;
a787 1

d796 2
a797 2
    relptr = _LoaderGetRelocations(aoutfile->funcs)->aout_reloc;
    prevptr = &(_LoaderGetRelocations(aoutfile->funcs)->aout_reloc);
d808 2
a809 2
    }				/* while */

d815 6
a820 6
    CheckandFree(aoutfile->strings, aoutfile->strsize);
    CheckandFree(aoutfile->symtab, aoutfile->header->a_syms);
    CheckandFree(aoutfile->datarel, aoutfile->header->a_drsize);
    CheckandFree(aoutfile->txtrel, aoutfile->header->a_trsize);
    CheckandFree(aoutfile->data, aoutfile->header->a_data);
    CheckandFree(aoutfile->text, aoutfile->header->a_text);
d841 1
a841 1
    AOUTModulePtr aoutfile = (AOUTModulePtr) modptr;
d843 12
a854 12
    if (address >= (unsigned long)aoutfile->text &&
	address <= (unsigned long)aoutfile->text + aoutfile->textsize) {
	return "text";
    }
    if (address >= (unsigned long)aoutfile->data &&
	address <= (unsigned long)aoutfile->data + aoutfile->datasize) {
	return "data";
    }
    if (address >= (unsigned long)aoutfile->bss &&
	address <= (unsigned long)aoutfile->bss + aoutfile->bsssize) {
	return "bss";
    }
d858 1
@

