head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.2
	cvs-200410241530:1.1.1.2
	cvs-200410012000:1.1.1.2
	cvs-200407221130:1.1.1.2
	cvs-200407141120:1.1.1.2
	cvs-200406231010:1.1.1.2
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.2
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.2
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.08.21;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.08.21;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.37.19;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.24.51;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* 
 * Copyright (c) 1998  Metro Link Incorporated
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, cpy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
 * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Except as contained in this notice, the name of the Metro Link shall not be
 * used in advertising or otherwise to promote the sale, use or other dealings
 * in this Software without prior written authorization from Metro Link.
 *
 */
/* $XFree86: xc/programs/Xserver/hw/xfree86/input/magellan/magellan.c,v 1.10 2001/11/26 16:25:53 dawes Exp $ */

#define _MAGELLAN_C_
/*****************************************************************************
 *	Standard Headers
 ****************************************************************************/

#include <misc.h>
#include <xf86.h>
#define NEED_XF86_TYPES
#include <xf86_ansic.h>
#include <xf86_OSproc.h>
#include <xf86Xinput.h>
#include <xisb.h>
#include <exevents.h>			/* Needed for InitValuator/Proximity stuff	*/

/*****************************************************************************
 *	Local Headers
 ****************************************************************************/
#include "magellan.h"

/*****************************************************************************
 *	Variables without includable headers
 ****************************************************************************/

/*****************************************************************************
 *	Local Variables
 ****************************************************************************/
static XF86ModuleVersionInfo VersionRec =
{
	"magellan",
	MODULEVENDORSTRING,
	MODINFOSTRING1,
	MODINFOSTRING2,
	XF86_VERSION_CURRENT,
	1, 0, 0,
	ABI_CLASS_XINPUT,
	ABI_XINPUT_VERSION,
	MOD_CLASS_XINPUT,
	{0, 0, 0, 0}				/* signature, to be patched into the file by
								 * a tool */
};

/* 
 * Be sure to set vmin appropriately for your device's protocol. You want to
 * read a full packet before returning
 */
static const char *default_options[] =
{
	"BaudRate", "9600",
	"StopBits", "2",
	"DataBits", "8",
	"Parity", "None",
	"Vmin", "26",
	"Vtime", "1",
	"FlowControl", "None"
};

XF86ModuleData magellanModuleData = { &VersionRec, SetupProc, TearDownProc };

/*****************************************************************************
 *	Function Definitions
 ****************************************************************************/


/* 
 * The TearDownProc may have to be tailored to your device
 */
static void
TearDownProc( pointer p )
{
	LocalDevicePtr local = (LocalDevicePtr) p;
	MagellanPrivatePtr priv = (MagellanPrivatePtr) local->private;

	DeviceOff (local->dev);

	xf86CloseSerial (local->fd);
	XisbFree (priv->buffer);
	xfree (priv);
	xfree (local->name);
	xfree (local);
}

static pointer
SetupProc(	pointer module,
			pointer options,
			int *errmaj,
			int *errmin )
{
	LocalDevicePtr local = xcalloc (1, sizeof (LocalDeviceRec));
	MagellanPrivatePtr priv = xcalloc (1, sizeof (MagellanPrivateRec));
	pointer	defaults,
			merged;

	if ((!local) || (!priv))
		goto SetupProc_fail;

	defaults = xf86OptionListCreate (default_options,
				  (sizeof (default_options) / sizeof (default_options[0])), 0);
	merged = xf86OptionListMerge( defaults, options );

	xf86OptionListReport( merged );

	local->fd = xf86OpenSerial (merged);
	if (local->fd == -1)
	{
		ErrorF ("Magellan driver unable to open device\n");
		*errmaj = LDR_NOPORTOPEN;
		*errmin = xf86GetErrno ();
		goto SetupProc_fail;
	}

	priv->buffer = XisbNew (local->fd, 200);

	DBG (9, XisbTrace (priv->buffer, 1));

	/* 
	 * Verify that hardware is attached and fuctional
	 */
	if (QueryHardware (priv, errmaj, errmin) != Success)
	{
		ErrorF ("Unable to query/initialize Magellan hardware.\n");
		goto SetupProc_fail;
	}

	/* this results in an xstrdup that must be freed later */
	local->name = xf86SetStrOption( merged, "DeviceName", "Magellan Space Mouse" );

	local->type_name = XI_SPACEBALL;
	/* 
	 * Standard setup for the local device record
	 */
	local->device_control = DeviceControl;
	local->read_input = ReadInput;
	local->control_proc = ControlProc;
	local->close_proc = CloseProc;
	local->switch_mode = SwitchMode;
	local->conversion_proc = ConvertProc;
	local->dev = NULL;
	local->private = priv;
	local->private_flags = 0;
	local->history_size = xf86SetIntOption( merged, "HistorySize", 0);

	xf86AddLocalDevice (local, merged);

	/* return the LocalDevice */
	return (local);

	/* 
	 * If something went wrong, cleanup and return NULL
	 */
  SetupProc_fail:
	if ((local) && (local->fd))
		xf86CloseSerial (local->fd);
	if ((local) && (local->name))
		xfree (local->name);
	if (local)
		xfree (local);

	if ((priv) && (priv->buffer))
		XisbFree (priv->buffer);
	if (priv)
		xfree (priv);
	return (NULL);
}

static Bool
DeviceControl (DeviceIntPtr dev, int mode)
{
	Bool	RetValue;

	switch (mode)
	{
	case DEVICE_INIT:
		DeviceInit (dev);
		RetValue = Success;
		break;
	case DEVICE_ON:
		RetValue = DeviceOn( dev );
		break;
	case DEVICE_OFF:
		RetValue = DeviceOff( dev );
		break;
	case DEVICE_CLOSE:
		RetValue = DeviceClose( dev );
		break;
	default:
		RetValue = BadValue;
	}

	return( RetValue );
}

static Bool
DeviceOn (DeviceIntPtr dev)
{
	LocalDevicePtr local = (LocalDevicePtr) dev->public.devicePrivate;

	AddEnabledDevice (local->fd);
	dev->public.on = TRUE;
	return (Success);
}

static Bool
DeviceOff (DeviceIntPtr dev)
{
	LocalDevicePtr local = (LocalDevicePtr) dev->public.devicePrivate;

	RemoveEnabledDevice (local->fd);
	dev->public.on = FALSE;
	return (Success);
}

static Bool
DeviceClose (DeviceIntPtr dev)
{
	return (Success);
}

static Bool
DeviceInit (DeviceIntPtr dev)
{
	LocalDevicePtr local = (LocalDevicePtr) dev->public.devicePrivate;
	unsigned char map[] =
	{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
	int i;

	if (InitButtonClassDeviceStruct (dev, 9, map) == FALSE)
	{
		ErrorF ("Unable to allocate Magellan ButtonClassDeviceStruct\n");
		return !Success;
	}

	if (InitFocusClassDeviceStruct (dev) == FALSE)
	{
		ErrorF("Unable to allocate Magellan FocusClassDeviceStruct\n");
		return !Success;
    }

	if (InitValuatorClassDeviceStruct (dev, 6, xf86GetMotionEvents,
									local->history_size, Absolute) == FALSE)
	{
		ErrorF ("Unable to allocate Magellan ValuatorClassDeviceStruct\n");
		return !Success;
	}
	else
	{
		for (i = 0; i <= 6; i++)
		{
			InitValuatorAxisStruct(dev, i, MAGELLAN_MIN, MAGELLAN_MAX,
				MAGELLAN_RES, 0, MAGELLAN_RES);
		}
	}

#ifdef BELL_FEEDBACK_SUPPORT
	/*
	The InitBellFeedbackClassDeviceStruct function is not exported in the
	4.3.0 or 4.3.1 Xmetro loader. We'll leave this out to stay compatible
	*/

	if (InitBellFeedbackClassDeviceStruct (dev, MagellanBellSound,
		MagellanBellCtrl) == FALSE)
	{
		ErrorF ("Unable to allocate Magellan BellFeedbackClassDeviceStruct\n");
		return !Success;
	}
#endif

	/* 
	 * Allocate the motion events buffer.
	 */
	xf86MotionHistoryAllocate (local);
	return (Success);
}

static void
ReadInput (LocalDevicePtr local)
{
	int x, y, z;
	int a, b, c;
	int i, buttons;
	MagellanPrivatePtr priv = (MagellanPrivatePtr) (local->private);

	/* 
	 * set blocking to -1 on the first call because we know there is data to
	 * read. Xisb automatically clears it after one successful read so that
	 * succeeding reads are preceeded buy a select with a 0 timeout to prevent
	 * read from blocking indefinately.
	 */
	XisbBlockDuration (priv->buffer, -1);
	while (MagellanGetPacket (priv) == Success)
	{
		/* 
		 * Examine priv->packet and call these functions as appropriate:
		 *
		 xf86PostMotionEvent
		 xf86PostButtonEvent
		 */

		switch (priv->packet[0])
		{
			case 'd':	/* motion packet */
				if (strlen (priv->packet) == 26)
				{
					x = 
					MagellanNibble( priv->packet[1] ) * 4096 +
					MagellanNibble( priv->packet[2] ) * 256 +
					MagellanNibble( priv->packet[3] ) * 16 +
					MagellanNibble( priv->packet[4] ) - 32768;
					y = 
					MagellanNibble( priv->packet[5] ) * 4096 +
					MagellanNibble( priv->packet[6] ) * 256 +
					MagellanNibble( priv->packet[7] ) * 16 +
					MagellanNibble( priv->packet[8] ) - 32768;
					z = 
					MagellanNibble( priv->packet[9] ) * 4096 +
					MagellanNibble( priv->packet[10] ) * 256 +
					MagellanNibble( priv->packet[11] ) * 16 +
					MagellanNibble( priv->packet[12] ) - 32768;

					a =
					MagellanNibble( priv->packet[13] ) * 4096 +
					MagellanNibble( priv->packet[14] ) * 256 +
					MagellanNibble( priv->packet[15] ) * 16 +
					MagellanNibble( priv->packet[16] ) - 32768;
					b = 
					MagellanNibble( priv->packet[17] ) * 4096 +
					MagellanNibble( priv->packet[18] ) * 256 +
					MagellanNibble( priv->packet[19] ) * 16 +
					MagellanNibble( priv->packet[20] ) - 32768;
					c = 
					MagellanNibble( priv->packet[21] ) * 4096 +
					MagellanNibble( priv->packet[22] ) * 256 +
					MagellanNibble( priv->packet[23] ) * 16 +
					MagellanNibble( priv->packet[24] ) - 32768;

					xf86ErrorFVerb( 5, "Magellan motion %d %d %d -- %d %d %d\n",
										x, y, z, a, b, c );
					xf86PostMotionEvent(local->dev, TRUE, 0, 6,
						x, y, z, a, b, c);
				}
				else
					ErrorF ("Magellan recieved a short \'d\'packet\n");
			break;

			case 'k': /* button packet */
				if (strlen (priv->packet) == 5)
				{
				buttons = MagellanNibble( priv->packet[1] ) * 1 +
                          MagellanNibble( priv->packet[2] ) * 16 +
                          MagellanNibble( priv->packet[3] ) * 256; 
				if (priv->old_buttons != buttons)
					for (i = 0; i < 9; i++)
					{	
						if ((priv->old_buttons&(1<<i)) != (buttons&(1<<i)))
						{
							xf86PostButtonEvent(local->dev, FALSE, i+1,
								(buttons&(1<<i)), 0, 0);
				xf86ErrorFVerb( 5, "Magellan setting button %d to %d\n",
					i+1, (buttons&(1<<i)) );
						}
					}
				priv->old_buttons = buttons;
				}
				else
					ErrorF ("Magellan recieved a short \'k\'packet\n");
			break;
		}
	}
}

static int
ControlProc (LocalDevicePtr local, xDeviceCtl * control)
{
	return (Success);
}

#ifdef BELL_FEEDBACK_SUPPORT
/*
The bell functions are stubbed out for now because they can't be used with the
4.3.0 and 4.3.1 Xmetro binaries. The device can only control the duration of
the beep.
*/
static void
MagellanBellCtrl(DeviceIntPtr dev, BellCtrl *ctrl)
{
}

static void
MagellanBellSound(int percent, DeviceIntPtr dev, pointer ctrl, int unknown)
{
}
#endif

static void
CloseProc (LocalDevicePtr local)
{
}

static int
SwitchMode (ClientPtr client, DeviceIntPtr dev, int mode)
{
	return (Success);
}

/* 
 * The ConvertProc function may need to be tailored for your device.
 * This function converts the device's valuator outputs to x and y coordinates
 * to simulate mouse events.
 */
static Bool
ConvertProc (LocalDevicePtr local,
			 int first,
			 int num,
			 int v0,
			 int v1,
			 int v2,
			 int v3,
			 int v4,
			 int v5,
			 int *x,
			 int *y)
{

	*x = v3;
	*y = v4;
	return (Success);
}

#define WriteString(str)\
XisbWrite (priv->buffer, (unsigned char *)(str), strlen(str)); \
	XisbBlockDuration (priv->buffer, 1000000); \
	if ((MagellanGetPacket (priv) != Success) || \
		(strcmp (priv->packet, (str)) != 0)) \
			return (!Success);


static Bool
QueryHardware (MagellanPrivatePtr priv, int *errmaj, int *errmin)
{
	*errmaj = LDR_NOHARDWARE;

	/* the device resets when the port is opened. Give it time to finish */
	milisleep (1000);

	XisbWrite (priv->buffer, (unsigned char *)MagellanAttention, strlen(MagellanAttention));
	WriteString (MagellanInitString);
	WriteString (MagellanInitString);
	WriteString (MagellanSensitivity);
	WriteString (MagellanPeriod);
	WriteString (MagellanMode);
	WriteString (MagellanNullRadius);

	XisbWrite (priv->buffer, (unsigned char *)MagellanVersion, strlen(MagellanVersion));
	/* block for up to 1 second while trying to read the response */
	XisbBlockDuration (priv->buffer, 1000000);
	NewPacket (priv);
	
	if ((MagellanGetPacket (priv) == Success) && (priv->packet[0] == 'v'))
	{
		priv->packet[strlen(priv->packet) - 1] = '\0';
		xf86MsgVerb( X_PROBED, 3, " initialized: %s\n",  &(priv->packet[3]) );
	}
	else
		return (!Success);

	return (Success);
}

static void
NewPacket (MagellanPrivatePtr priv)
{
    priv->lex_mode = magellan_normal;
    priv->packeti = 0;
}

static Bool
MagellanGetPacket (MagellanPrivatePtr priv)
{
	int count = 0;
	int c;

	while ((c = XisbRead (priv->buffer)) >= 0)
	{
		/* 
		 * fail after 500 bytes so the server doesn't hang forever if a
		 * device sends bad data.
		 */
		if (count++ > 500)
		{
			NewPacket (priv);
			return (!Success);
		}

		switch (priv->lex_mode)
		{
		case magellan_normal:
			if (priv->packeti > MAGELLAN_PACKET_SIZE)
			{
				NewPacket (priv);
				return (!Success);
			}
			priv->packet[priv->packeti] = c;
			priv->packeti++;
			if (c == '\r')
			{
				priv->packet[priv->packeti] = '\0';
				NewPacket (priv);
				return (Success);
			}
			break;
		}
	}
	return (!Success);
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d27 1
a27 9

/*
 * port to XFree4.2.0 Copyright (c) 2002 Christoph Koulen
 * chris@@real-aix.de
 *
 * port based on pre-XFree4.2.0 driver code v1.10 and XFree4.2.0 SpaceOrb driver code
 */
 
/* $XFree86: xc/programs/Xserver/hw/xfree86/input/magellan/magellan.c,v 1.11 2002/06/07 21:03:27 alanh Exp $ */
a54 13

InputDriverRec MAGELLAN = {
       1,
       "magellan",
       NULL,
       MagellanPreInit,
       NULL,
       NULL,
       0
};

#ifdef XFree86LOADER

d70 3
a72 4
/* The following list of symbols that has been taken without modification from the 
   SpaceOrb driver code.
   This has resulted in a working magellan driver.
   You may be able to strip this list for the magellan device;
d74 9
a82 41
static const char *reqSymbols[] = {
        "AddEnabledDevice",
        "ErrorF",
        "InitButtonClassDeviceStruct",
        "InitProximityClassDeviceStruct",
        "InitValuatorAxisStruct",
        "InitValuatorClassDeviceStruct",
        "InitPtrFeedbackClassDeviceStruct",
        "RemoveEnabledDevice",
        "Xcalloc",
        "Xfree",
        "XisbBlockDuration",
        "XisbFree",
        "XisbNew",
        "XisbRead",
        "XisbTrace",
        "screenInfo",
        "xf86AddInputDriver",
        "xf86AllocateInput",
        "xf86CloseSerial",
        "xf86CollectInputOptions",
        "xf86ErrorFVerb",
        "xf86FindOptionValue",
        "xf86GetMotionEvents",
        "xf86GetVerbosity",
        "xf86MotionHistoryAllocate",
        "xf86NameCmp",
        "xf86OpenSerial",
        "xf86OptionListCreate",
        "xf86OptionListMerge",
        "xf86OptionListReport",
        "xf86PostButtonEvent",
        "xf86PostMotionEvent",
        "xf86PostProximityEvent",
        "xf86ProcessCommonOptions",
        "xf86ScaleAxis",
        "xf86SetIntOption",
        "xf86SetStrOption",
        "xf86XInputSetScreen",
        "xf86XInputSetSendCoreEvents",
        NULL
d85 6
a90 9
static pointer
MAGELLANSetupProc(pointer module,
		  pointer options,
		  int *errmaj,
		  int *errmin ) {
  xf86LoaderReqSymLists(reqSymbols, NULL);
  xf86AddInputDriver(&MAGELLAN, module, 0);
  return (pointer) 1;
}
d98 2
a99 4
  if (!xf86ServerIsOnlyDetecting()) {
  
	InputInfoPtr pInfo = (InputInfoPtr) p;
	MAGELLANPrivatePtr priv = (MAGELLANPrivatePtr) pInfo->private;
d101 1
a101 1
	DeviceOff (pInfo->dev);
d103 1
a103 1
	xf86CloseSerial (pInfo->fd);
d106 2
a107 3
	xfree (pInfo->name);
	xfree (pInfo);
  }
d110 19
a128 1
XF86ModuleData magellanModuleData = { &VersionRec, MAGELLANSetupProc, TearDownProc };
d130 8
a137 22
#endif /* XFreeLOADER */
/* 
 * Be sure to set vmin appropriately for your device's protocol. You want to
 * read a full packet before returning;
 *
 * These settings have been found to work for a device which identifies itself as follows:
 *
 * MAGELLAN  Version 5.49  by LOGITECH INC. 10/22/96
 *
 * newer devices may require different settings.
 */
static const char *default_options[] =
{
	"BaudRate", "9600",
	"StopBits", "2",
	"DataBits", "8",
	"Parity", "None",
	"Vmin", "26",
	"Vtime", "1",
	"FlowControl", "Xoff",
        NULL,
};
d139 1
d141 1
a141 3
/*****************************************************************************
 *	Function Definitions
 ****************************************************************************/
d143 7
a149 12
static InputInfoPtr
MagellanPreInit(InputDriverPtr drv, IDevPtr dev, int flags)
{              
        InputInfoPtr pInfo;
        MAGELLANPrivatePtr priv = xcalloc (1, sizeof (MAGELLANPrivateRec));

	if (!priv)
		return NULL;

        if (!(pInfo = xf86AllocateInput(drv, 0))) {
		xfree(priv);
                return NULL;
a150 32
  
	priv->lex_mode = magellan_normal;
	priv->packeti = 0;
	priv->old_buttons=0;
	priv->buffer= NULL;
	
	pInfo->type_name = XI_SPACEBALL;
	pInfo->device_control = DeviceControl;
	pInfo->read_input = ReadInput;
	pInfo->control_proc = ControlProc;
	pInfo->close_proc = CloseProc;
	pInfo->switch_mode = SwitchMode;
	pInfo->conversion_proc = ConvertProc;
	pInfo->dev = NULL;
	pInfo->private = priv;
	pInfo->private_flags = 0;
	pInfo->flags = 0;
        pInfo->conf_idev = dev;

	xf86CollectInputOptions(pInfo, default_options, NULL);

        xf86OptionListReport( pInfo->options );

        pInfo->fd = xf86OpenSerial (pInfo->options);
        if (pInfo->fd == -1)
        {
	  ErrorF ("MAGELLAN driver unable to open device\n");
	  goto SetupProc_fail;
        }
	
	priv->buffer = XisbNew (pInfo->fd, 200);
	DBG (9, XisbTrace (priv->buffer, 1));
d152 4
d157 1
a157 1
	 * Verify the hardware is attached and functional
d159 15
a173 18
        if (QueryHardware (priv) != Success)
        {
	  ErrorF ("Unable to query/initialize MAGELLAN hardware.\n");
	  goto SetupProc_fail;
        }

        /* this results in an xstrdup that must be freed later */
	/* the last string "spaceball" is the one to make glut 3.7 believe
	   a "spaceball" device ist present. 
	   This decision is based on string comparison!
	*/
        pInfo->name = xf86SetStrOption( pInfo->options, "DeviceName", "spaceball");
	pInfo->history_size = xf86SetIntOption( pInfo->options, "HistorySize", 0 );
	
        xf86ProcessCommonOptions(pInfo, pInfo->options);
	
        pInfo->flags |= XI86_CONFIGURED;
        return (pInfo);
d179 6
a184 4
        if ((pInfo) && (pInfo->fd))
                xf86CloseSerial (pInfo->fd);
        if ((pInfo) && (pInfo->name))
                xfree (pInfo->name);
d186 2
a187 2
        if ((priv) && (priv->buffer))
                XisbFree (priv->buffer);
d189 2
a190 2
                xfree (priv);
        return (pInfo);
a192 2


d223 1
a223 1
	InputInfoPtr pInfo = dev->public.devicePrivate;
d225 1
a225 1
	AddEnabledDevice (pInfo->fd);
d233 1
a233 1
	InputInfoPtr pInfo = dev->public.devicePrivate;
d235 1
a235 1
	RemoveEnabledDevice (pInfo->fd);
d249 10
a258 11
  InputInfoPtr pInfo = dev->public.devicePrivate;
  unsigned char map[] =
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

  int i;

  if (InitButtonClassDeviceStruct (dev, 9, map) == FALSE)
    {
      ErrorF ("Unable to allocate MAGELLAN ButtonClassDeviceStruct\n");
      return !Success;
    }
d260 4
a263 4
  if (InitFocusClassDeviceStruct (dev) == FALSE)
    {
      ErrorF("Unable to allocate MAGELLAN FocusClassDeviceStruct\n");
      return !Success;
d266 7
a272 9
  if (InitValuatorClassDeviceStruct (dev, 6, xf86GetMotionEvents,
				     pInfo->history_size, Absolute) == FALSE)
    {
      ErrorF ("Unable to allocate MAGELLAN ValuatorClassDeviceStruct\n");
      return !Success;
    }
  else
    {
      for (i = 0; i <= 6; i++)
d274 5
a278 1
	  InitValuatorAxisStruct(dev, i, MAGELLAN_MIN, MAGELLAN_MAX, MAGELLAN_RES, 0, MAGELLAN_RES);
a279 1
    }
d282 11
a292 16
  /*
    The InitBellFeedbackClassDeviceStruct function is not exported in the
    4.3.0 or 4.3.1 Xmetro loader. We'll leave this out to stay compatible
  */
  /*
    unsure, whether this still is true for the XFree4.2.0 port. 
    Didn't bother to find out.
    Christoph Koulen
  */

  if (InitBellFeedbackClassDeviceStruct (dev, MagellanBellSound,
					 MagellanBellCtrl) == FALSE)
    {
      ErrorF ("Unable to allocate Magellan BellFeedbackClassDeviceStruct\n");
      return !Success;
    }
d295 5
a299 5
  /* 
   * Allocate the motion events buffer.
   */
  xf86MotionHistoryAllocate (pInfo);
  return (Success);
d305 81
a385 81
  int x, y, z;
  int a, b, c;
  int i, buttons;
  MAGELLANPrivatePtr priv = (MAGELLANPrivatePtr) (local->private);

  /* 
   * set blocking to -1 on the first call because we know there is data to
   * read. Xisb automatically clears it after one successful read so that
   * succeeding reads are preceeded by a select with a 0 timeout to prevent
   * read from blocking indefinitely.
   */
  XisbBlockDuration (priv->buffer, -1);
  while (MAGELLANGetPacket (priv) == Success)
    {
      /* 
       * Examine priv->packet and call these functions as appropriate:
       *
       xf86PostMotionEvent
       xf86PostButtonEvent
      */

      switch (priv->packet[0])
	{
	case 'd':	/* motion packet */
	  if (strlen (priv->packet) == 26)
	    {
	      x = 
		MagellanNibble( priv->packet[1] ) * 4096 +
		MagellanNibble( priv->packet[2] ) * 256 +
		MagellanNibble( priv->packet[3] ) * 16 +
		MagellanNibble( priv->packet[4] ) - 32768;
	      y = 
		MagellanNibble( priv->packet[5] ) * 4096 +
		MagellanNibble( priv->packet[6] ) * 256 +
		MagellanNibble( priv->packet[7] ) * 16 +
		MagellanNibble( priv->packet[8] ) - 32768;
	      z = 
		MagellanNibble( priv->packet[9]  ) * 4096 +
		MagellanNibble( priv->packet[10] ) * 256 +
		MagellanNibble( priv->packet[11] ) * 16 +
		MagellanNibble( priv->packet[12] ) - 32768;
	      
	      a =
		MagellanNibble( priv->packet[13] ) * 4096 +
		MagellanNibble( priv->packet[14] ) * 256 +
		MagellanNibble( priv->packet[15] ) * 16 +
		MagellanNibble( priv->packet[16] ) - 32768;
	      b = 
		MagellanNibble( priv->packet[17] ) * 4096 +
		MagellanNibble( priv->packet[18] ) * 256 +
		MagellanNibble( priv->packet[19] ) * 16 +
		MagellanNibble( priv->packet[20] ) - 32768;
	      c = 
		MagellanNibble( priv->packet[21] ) * 4096 +
		MagellanNibble( priv->packet[22] ) * 256 +
		MagellanNibble( priv->packet[23] ) * 16 +
		MagellanNibble( priv->packet[24] ) - 32768;

	      xf86ErrorFVerb( 5, "Magellan motion %d %d %d -- %d %d %d\n",
			      x, y, z, a, b, c );
	      xf86PostMotionEvent(local->dev, TRUE, 0, 6,
				  x, y, z, a, b, c);
	    }
	  else
	    ErrorF ("Magellan received a short \'d\'packet\n");
	  break;

	case 'k': /* button packet */
	  if (strlen (priv->packet) == 5)
	    {
	      buttons = MagellanNibble( priv->packet[1] ) * 1 +
		        MagellanNibble( priv->packet[2] ) * 16 +
		        MagellanNibble( priv->packet[3] ) * 256; 
	      if (priv->old_buttons != buttons)
		for (i = 0; i < 9; i++)
		  {	
		    if ((priv->old_buttons&(1<<i)) != (buttons&(1<<i)))
		      {
			xf86PostButtonEvent(local->dev, FALSE, i+1,
					    (buttons&(1<<i)), 0, 0);
			xf86ErrorFVerb( 5, "Magellan setting button %d to %d\n",
d387 8
a394 7
		      }
		  }
	      priv->old_buttons = buttons;
	    }
	  else
	    ErrorF ("Magellan received a short \'k\'packet\n");
	  break;
a395 1
    }
d401 1
a401 1
  return (Success);
d429 1
a429 1
  return (Success);
d439 10
a448 10
	     int first,
	     int num,
	     int v0,
	     int v1,
	     int v2,
	     int v3,
	     int v4,
	     int v5,
	     int *x,
	     int *y)
d451 3
a453 3
  *x = v3;
  *y = v4;
  return (Success);
d459 1
a459 1
	if ((MAGELLANGetPacket (priv) != Success) || \
d465 1
a465 1
QueryHardware (MAGELLANPrivatePtr priv)
d467 1
a467 2
  /* the device resets when the port is opened. Give it time to finish */
  milisleep (1000);
d469 15
a483 21
  XisbWrite (priv->buffer, (unsigned char *)MagellanModeOff, strlen(MagellanModeOff));
  XisbBlockDuration (priv->buffer, 200000);
  MAGELLANGetPacket(priv);

  XisbWrite (priv->buffer, (unsigned char *)MagellanInitString, strlen(MagellanInitString));
  XisbBlockDuration (priv->buffer, 200000);
  MAGELLANGetPacket(priv);
  XisbWrite (priv->buffer, (unsigned char *)MagellanInitString, strlen(MagellanInitString));
  XisbBlockDuration (priv->buffer, 200000);
  MAGELLANGetPacket(priv);

  WriteString (MagellanSensitivity);
  WriteString (MagellanPeriod);
  WriteString (MagellanNullRadius);
  WriteString (MagellanMode);
  XisbWrite (priv->buffer, (unsigned char *)MagellanVersion, strlen(MagellanVersion));


  /* block for up to 1 second while trying to read the response */
  XisbBlockDuration (priv->buffer, 1000000);
  NewPacket (priv);
d485 7
a491 7
  if ((MAGELLANGetPacket (priv) == Success) && (priv->packet[0] == 'v'))
    {
      priv->packet[strlen(priv->packet) - 1] = '\0';
      xf86MsgVerb( X_PROBED, 3, " initialized: %s\n",  &(priv->packet[3]) );
    }
  else
    return (!Success);
d493 1
a493 1
  return (Success);
d497 1
a497 1
NewPacket (MAGELLANPrivatePtr priv)
d499 2
a500 2
  priv->lex_mode = magellan_normal;
  priv->packeti = 0;
d504 1
a504 1
MAGELLANGetPacket (MAGELLANPrivatePtr priv)
d506 2
a507 2
  int count = 0;
  int c;
d509 1
a509 7
  while ((c = XisbRead (priv->buffer)) >= 0)
    {
      /* 
       * fail after 500 bytes so the server doesn't hang forever if a
       * device sends bad data.
       */
      if (count++ > 500)
d511 9
a519 3
	  NewPacket (priv);
	  return (!Success);
	}
d521 18
a538 25
      switch (priv->lex_mode)
	{
	case magellan_normal:
	  if (priv->packeti > MAGELLAN_PACKET_SIZE)
	    {
	      NewPacket (priv);
	      return (!Success);
	    }
	  priv->packet[priv->packeti] = c;
	  priv->packeti++;

	  /* BEWARE: SpaceMouse echoes back most everything you send her.
	   * be sure NOT to send command strings that contain "\r" somewhere in the middle!
	   * "Success" of this function  will be reported upon the first "\r" received".
	   * You might end up with the rest of a SpaceMouse echo still waiting in the
	   * buffer, which would make the comparison between command sent and the answer
	   * returned by SpaceMouse fail for the next command!
	   */
	  if (c == '\r')
	    {
	      priv->packet[priv->packeti] = '\0';
	      NewPacket (priv);
	      return (Success);
	    }
	  break;
d540 1
a540 2
    }
  return (!Success);
a541 15















@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d27 1
a27 9

/*
 * port to XFree4.2.0 Copyright (c) 2002 Christoph Koulen
 * chris@@real-aix.de
 *
 * port based on pre-XFree4.2.0 driver code v1.10 and XFree4.2.0 SpaceOrb driver code
 */
 
/* $XFree86: xc/programs/Xserver/hw/xfree86/input/magellan/magellan.c,v 1.11 2002/06/07 21:03:27 alanh Exp $ */
a54 13

InputDriverRec MAGELLAN = {
       1,
       "magellan",
       NULL,
       MagellanPreInit,
       NULL,
       NULL,
       0
};

#ifdef XFree86LOADER

d70 3
a72 4
/* The following list of symbols that has been taken without modification from the 
   SpaceOrb driver code.
   This has resulted in a working magellan driver.
   You may be able to strip this list for the magellan device;
d74 9
a82 41
static const char *reqSymbols[] = {
        "AddEnabledDevice",
        "ErrorF",
        "InitButtonClassDeviceStruct",
        "InitProximityClassDeviceStruct",
        "InitValuatorAxisStruct",
        "InitValuatorClassDeviceStruct",
        "InitPtrFeedbackClassDeviceStruct",
        "RemoveEnabledDevice",
        "Xcalloc",
        "Xfree",
        "XisbBlockDuration",
        "XisbFree",
        "XisbNew",
        "XisbRead",
        "XisbTrace",
        "screenInfo",
        "xf86AddInputDriver",
        "xf86AllocateInput",
        "xf86CloseSerial",
        "xf86CollectInputOptions",
        "xf86ErrorFVerb",
        "xf86FindOptionValue",
        "xf86GetMotionEvents",
        "xf86GetVerbosity",
        "xf86MotionHistoryAllocate",
        "xf86NameCmp",
        "xf86OpenSerial",
        "xf86OptionListCreate",
        "xf86OptionListMerge",
        "xf86OptionListReport",
        "xf86PostButtonEvent",
        "xf86PostMotionEvent",
        "xf86PostProximityEvent",
        "xf86ProcessCommonOptions",
        "xf86ScaleAxis",
        "xf86SetIntOption",
        "xf86SetStrOption",
        "xf86XInputSetScreen",
        "xf86XInputSetSendCoreEvents",
        NULL
d85 6
a90 9
static pointer
MAGELLANSetupProc(pointer module,
		  pointer options,
		  int *errmaj,
		  int *errmin ) {
  xf86LoaderReqSymLists(reqSymbols, NULL);
  xf86AddInputDriver(&MAGELLAN, module, 0);
  return (pointer) 1;
}
d98 2
a99 4
  if (!xf86ServerIsOnlyDetecting()) {
  
	InputInfoPtr pInfo = (InputInfoPtr) p;
	MAGELLANPrivatePtr priv = (MAGELLANPrivatePtr) pInfo->private;
d101 1
a101 1
	DeviceOff (pInfo->dev);
d103 1
a103 1
	xf86CloseSerial (pInfo->fd);
d106 2
a107 3
	xfree (pInfo->name);
	xfree (pInfo);
  }
d110 19
a128 1
XF86ModuleData magellanModuleData = { &VersionRec, MAGELLANSetupProc, TearDownProc };
d130 8
a137 22
#endif /* XFreeLOADER */
/* 
 * Be sure to set vmin appropriately for your device's protocol. You want to
 * read a full packet before returning;
 *
 * These settings have been found to work for a device which identifies itself as follows:
 *
 * MAGELLAN  Version 5.49  by LOGITECH INC. 10/22/96
 *
 * newer devices may require different settings.
 */
static const char *default_options[] =
{
	"BaudRate", "9600",
	"StopBits", "2",
	"DataBits", "8",
	"Parity", "None",
	"Vmin", "26",
	"Vtime", "1",
	"FlowControl", "Xoff",
        NULL,
};
d139 1
d141 1
a141 3
/*****************************************************************************
 *	Function Definitions
 ****************************************************************************/
d143 7
a149 12
static InputInfoPtr
MagellanPreInit(InputDriverPtr drv, IDevPtr dev, int flags)
{              
        InputInfoPtr pInfo;
        MAGELLANPrivatePtr priv = xcalloc (1, sizeof (MAGELLANPrivateRec));

	if (!priv)
		return NULL;

        if (!(pInfo = xf86AllocateInput(drv, 0))) {
		xfree(priv);
                return NULL;
a150 32
  
	priv->lex_mode = magellan_normal;
	priv->packeti = 0;
	priv->old_buttons=0;
	priv->buffer= NULL;
	
	pInfo->type_name = XI_SPACEBALL;
	pInfo->device_control = DeviceControl;
	pInfo->read_input = ReadInput;
	pInfo->control_proc = ControlProc;
	pInfo->close_proc = CloseProc;
	pInfo->switch_mode = SwitchMode;
	pInfo->conversion_proc = ConvertProc;
	pInfo->dev = NULL;
	pInfo->private = priv;
	pInfo->private_flags = 0;
	pInfo->flags = 0;
        pInfo->conf_idev = dev;

	xf86CollectInputOptions(pInfo, default_options, NULL);

        xf86OptionListReport( pInfo->options );

        pInfo->fd = xf86OpenSerial (pInfo->options);
        if (pInfo->fd == -1)
        {
	  ErrorF ("MAGELLAN driver unable to open device\n");
	  goto SetupProc_fail;
        }
	
	priv->buffer = XisbNew (pInfo->fd, 200);
	DBG (9, XisbTrace (priv->buffer, 1));
d152 4
d157 1
a157 1
	 * Verify the hardware is attached and functional
d159 15
a173 18
        if (QueryHardware (priv) != Success)
        {
	  ErrorF ("Unable to query/initialize MAGELLAN hardware.\n");
	  goto SetupProc_fail;
        }

        /* this results in an xstrdup that must be freed later */
	/* the last string "spaceball" is the one to make glut 3.7 believe
	   a "spaceball" device ist present. 
	   This decision is based on string comparison!
	*/
        pInfo->name = xf86SetStrOption( pInfo->options, "DeviceName", "spaceball");
	pInfo->history_size = xf86SetIntOption( pInfo->options, "HistorySize", 0 );
	
        xf86ProcessCommonOptions(pInfo, pInfo->options);
	
        pInfo->flags |= XI86_CONFIGURED;
        return (pInfo);
d179 6
a184 4
        if ((pInfo) && (pInfo->fd))
                xf86CloseSerial (pInfo->fd);
        if ((pInfo) && (pInfo->name))
                xfree (pInfo->name);
d186 2
a187 2
        if ((priv) && (priv->buffer))
                XisbFree (priv->buffer);
d189 2
a190 2
                xfree (priv);
        return (pInfo);
a192 2


d223 1
a223 1
	InputInfoPtr pInfo = dev->public.devicePrivate;
d225 1
a225 1
	AddEnabledDevice (pInfo->fd);
d233 1
a233 1
	InputInfoPtr pInfo = dev->public.devicePrivate;
d235 1
a235 1
	RemoveEnabledDevice (pInfo->fd);
d249 10
a258 11
  InputInfoPtr pInfo = dev->public.devicePrivate;
  unsigned char map[] =
  {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

  int i;

  if (InitButtonClassDeviceStruct (dev, 9, map) == FALSE)
    {
      ErrorF ("Unable to allocate MAGELLAN ButtonClassDeviceStruct\n");
      return !Success;
    }
d260 4
a263 4
  if (InitFocusClassDeviceStruct (dev) == FALSE)
    {
      ErrorF("Unable to allocate MAGELLAN FocusClassDeviceStruct\n");
      return !Success;
d266 7
a272 9
  if (InitValuatorClassDeviceStruct (dev, 6, xf86GetMotionEvents,
				     pInfo->history_size, Absolute) == FALSE)
    {
      ErrorF ("Unable to allocate MAGELLAN ValuatorClassDeviceStruct\n");
      return !Success;
    }
  else
    {
      for (i = 0; i <= 6; i++)
d274 5
a278 1
	  InitValuatorAxisStruct(dev, i, MAGELLAN_MIN, MAGELLAN_MAX, MAGELLAN_RES, 0, MAGELLAN_RES);
a279 1
    }
d282 11
a292 16
  /*
    The InitBellFeedbackClassDeviceStruct function is not exported in the
    4.3.0 or 4.3.1 Xmetro loader. We'll leave this out to stay compatible
  */
  /*
    unsure, whether this still is true for the XFree4.2.0 port. 
    Didn't bother to find out.
    Christoph Koulen
  */

  if (InitBellFeedbackClassDeviceStruct (dev, MagellanBellSound,
					 MagellanBellCtrl) == FALSE)
    {
      ErrorF ("Unable to allocate Magellan BellFeedbackClassDeviceStruct\n");
      return !Success;
    }
d295 5
a299 5
  /* 
   * Allocate the motion events buffer.
   */
  xf86MotionHistoryAllocate (pInfo);
  return (Success);
d305 81
a385 81
  int x, y, z;
  int a, b, c;
  int i, buttons;
  MAGELLANPrivatePtr priv = (MAGELLANPrivatePtr) (local->private);

  /* 
   * set blocking to -1 on the first call because we know there is data to
   * read. Xisb automatically clears it after one successful read so that
   * succeeding reads are preceeded by a select with a 0 timeout to prevent
   * read from blocking indefinitely.
   */
  XisbBlockDuration (priv->buffer, -1);
  while (MAGELLANGetPacket (priv) == Success)
    {
      /* 
       * Examine priv->packet and call these functions as appropriate:
       *
       xf86PostMotionEvent
       xf86PostButtonEvent
      */

      switch (priv->packet[0])
	{
	case 'd':	/* motion packet */
	  if (strlen (priv->packet) == 26)
	    {
	      x = 
		MagellanNibble( priv->packet[1] ) * 4096 +
		MagellanNibble( priv->packet[2] ) * 256 +
		MagellanNibble( priv->packet[3] ) * 16 +
		MagellanNibble( priv->packet[4] ) - 32768;
	      y = 
		MagellanNibble( priv->packet[5] ) * 4096 +
		MagellanNibble( priv->packet[6] ) * 256 +
		MagellanNibble( priv->packet[7] ) * 16 +
		MagellanNibble( priv->packet[8] ) - 32768;
	      z = 
		MagellanNibble( priv->packet[9]  ) * 4096 +
		MagellanNibble( priv->packet[10] ) * 256 +
		MagellanNibble( priv->packet[11] ) * 16 +
		MagellanNibble( priv->packet[12] ) - 32768;
	      
	      a =
		MagellanNibble( priv->packet[13] ) * 4096 +
		MagellanNibble( priv->packet[14] ) * 256 +
		MagellanNibble( priv->packet[15] ) * 16 +
		MagellanNibble( priv->packet[16] ) - 32768;
	      b = 
		MagellanNibble( priv->packet[17] ) * 4096 +
		MagellanNibble( priv->packet[18] ) * 256 +
		MagellanNibble( priv->packet[19] ) * 16 +
		MagellanNibble( priv->packet[20] ) - 32768;
	      c = 
		MagellanNibble( priv->packet[21] ) * 4096 +
		MagellanNibble( priv->packet[22] ) * 256 +
		MagellanNibble( priv->packet[23] ) * 16 +
		MagellanNibble( priv->packet[24] ) - 32768;

	      xf86ErrorFVerb( 5, "Magellan motion %d %d %d -- %d %d %d\n",
			      x, y, z, a, b, c );
	      xf86PostMotionEvent(local->dev, TRUE, 0, 6,
				  x, y, z, a, b, c);
	    }
	  else
	    ErrorF ("Magellan received a short \'d\'packet\n");
	  break;

	case 'k': /* button packet */
	  if (strlen (priv->packet) == 5)
	    {
	      buttons = MagellanNibble( priv->packet[1] ) * 1 +
		        MagellanNibble( priv->packet[2] ) * 16 +
		        MagellanNibble( priv->packet[3] ) * 256; 
	      if (priv->old_buttons != buttons)
		for (i = 0; i < 9; i++)
		  {	
		    if ((priv->old_buttons&(1<<i)) != (buttons&(1<<i)))
		      {
			xf86PostButtonEvent(local->dev, FALSE, i+1,
					    (buttons&(1<<i)), 0, 0);
			xf86ErrorFVerb( 5, "Magellan setting button %d to %d\n",
d387 8
a394 7
		      }
		  }
	      priv->old_buttons = buttons;
	    }
	  else
	    ErrorF ("Magellan received a short \'k\'packet\n");
	  break;
a395 1
    }
d401 1
a401 1
  return (Success);
d429 1
a429 1
  return (Success);
d439 10
a448 10
	     int first,
	     int num,
	     int v0,
	     int v1,
	     int v2,
	     int v3,
	     int v4,
	     int v5,
	     int *x,
	     int *y)
d451 3
a453 3
  *x = v3;
  *y = v4;
  return (Success);
d459 1
a459 1
	if ((MAGELLANGetPacket (priv) != Success) || \
d465 1
a465 1
QueryHardware (MAGELLANPrivatePtr priv)
d467 1
a467 2
  /* the device resets when the port is opened. Give it time to finish */
  milisleep (1000);
d469 15
a483 21
  XisbWrite (priv->buffer, (unsigned char *)MagellanModeOff, strlen(MagellanModeOff));
  XisbBlockDuration (priv->buffer, 200000);
  MAGELLANGetPacket(priv);

  XisbWrite (priv->buffer, (unsigned char *)MagellanInitString, strlen(MagellanInitString));
  XisbBlockDuration (priv->buffer, 200000);
  MAGELLANGetPacket(priv);
  XisbWrite (priv->buffer, (unsigned char *)MagellanInitString, strlen(MagellanInitString));
  XisbBlockDuration (priv->buffer, 200000);
  MAGELLANGetPacket(priv);

  WriteString (MagellanSensitivity);
  WriteString (MagellanPeriod);
  WriteString (MagellanNullRadius);
  WriteString (MagellanMode);
  XisbWrite (priv->buffer, (unsigned char *)MagellanVersion, strlen(MagellanVersion));


  /* block for up to 1 second while trying to read the response */
  XisbBlockDuration (priv->buffer, 1000000);
  NewPacket (priv);
d485 7
a491 7
  if ((MAGELLANGetPacket (priv) == Success) && (priv->packet[0] == 'v'))
    {
      priv->packet[strlen(priv->packet) - 1] = '\0';
      xf86MsgVerb( X_PROBED, 3, " initialized: %s\n",  &(priv->packet[3]) );
    }
  else
    return (!Success);
d493 1
a493 1
  return (Success);
d497 1
a497 1
NewPacket (MAGELLANPrivatePtr priv)
d499 2
a500 2
  priv->lex_mode = magellan_normal;
  priv->packeti = 0;
d504 1
a504 1
MAGELLANGetPacket (MAGELLANPrivatePtr priv)
d506 2
a507 2
  int count = 0;
  int c;
d509 1
a509 7
  while ((c = XisbRead (priv->buffer)) >= 0)
    {
      /* 
       * fail after 500 bytes so the server doesn't hang forever if a
       * device sends bad data.
       */
      if (count++ > 500)
d511 9
a519 3
	  NewPacket (priv);
	  return (!Success);
	}
d521 18
a538 25
      switch (priv->lex_mode)
	{
	case magellan_normal:
	  if (priv->packeti > MAGELLAN_PACKET_SIZE)
	    {
	      NewPacket (priv);
	      return (!Success);
	    }
	  priv->packet[priv->packeti] = c;
	  priv->packeti++;

	  /* BEWARE: SpaceMouse echoes back most everything you send her.
	   * be sure NOT to send command strings that contain "\r" somewhere in the middle!
	   * "Success" of this function  will be reported upon the first "\r" received".
	   * You might end up with the rest of a SpaceMouse echo still waiting in the
	   * buffer, which would make the comparison between command sent and the answer
	   * returned by SpaceMouse fail for the next command!
	   */
	  if (c == '\r')
	    {
	      priv->packet[priv->packeti] = '\0';
	      NewPacket (priv);
	      return (Success);
	    }
	  break;
d540 1
a540 2
    }
  return (!Success);
a541 15















@

