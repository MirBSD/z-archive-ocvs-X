head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.09.26;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.09.26;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.38.02;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.29.03;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.26.12;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Harold L Hunt II
 */
/* $XFree86: xc/programs/Xserver/hw/xwin/winshadgdi.c,v 1.19 2001/11/21 08:51:24 alanh Exp $ */

#include "win.h"

static
Bool
winQueryScreenDIBFormat (ScreenPtr pScreen, BITMAPINFOHEADER *pbmih)
{
  winScreenPriv(pScreen);
  HBITMAP		hbmp;
#if CYGDEBUG
  LPDWORD		pdw = NULL;
#endif
  
  /* Create a memory bitmap compatible with the screen */
  hbmp = CreateCompatibleBitmap (pScreenPriv->hdcScreen, 1, 1);
  if (hbmp == NULL)
    {
      ErrorF ("winQueryScreenDIBFormat () - CreateCompatibleBitmap failed\n");
      return FALSE;
    }
  
  /* Initialize our bitmap info header */
  ZeroMemory (pbmih, sizeof (BITMAPINFOHEADER) + 256 * sizeof (RGBQUAD));
  pbmih->biSize = sizeof (BITMAPINFOHEADER);

  /* Get the biBitCount */
  if (!GetDIBits (pScreenPriv->hdcScreen,
		  hbmp,
		  0, 1,
		  NULL,
		  (BITMAPINFO*) pbmih,
		  DIB_RGB_COLORS))
    {
      ErrorF ("winQueryScreenDIBFormat () - First call to GetDIBits failed\n");
      DeleteObject (hbmp);
      return FALSE;
    }

#if CYGDEBUG
  /* Get a pointer to bitfields */
  pdw = (DWORD*) ((CARD8*)pbmih + sizeof (BITMAPINFOHEADER));

  ErrorF ("winQueryScreenDIBFormat () - First call masks: %08x %08x %08x\n",
	  pdw[0], pdw[1], pdw[2]);
#endif

  /* Get optimal color table, or the optimal bitfields */
  if (!GetDIBits (pScreenPriv->hdcScreen,
		  hbmp,
		  0, 1,
		  NULL,
		  (BITMAPINFO*)pbmih,
		  DIB_RGB_COLORS))
    {
      ErrorF ("winQueryScreenDIBFormat () - Second call to GetDIBits "\
	      "failed\n");
      DeleteObject (hbmp);
      return FALSE;
    }

  /* Free memory */
  DeleteObject (hbmp);
  
  return TRUE;
}

static
Bool
winQueryRGBBitsAndMasks (ScreenPtr pScreen)
{
  winScreenPriv(pScreen);
  BITMAPINFOHEADER	*pbmih = NULL;
  Bool			fReturn = TRUE;
  LPDWORD		pdw = NULL;
  DWORD			dwRedBits, dwGreenBits, dwBlueBits;

  /* Color masks for 8 bpp are standardized */
  if (GetDeviceCaps (pScreenPriv->hdcScreen, RASTERCAPS) & RC_PALETTE)
    {
      /* 
       * RGB BPP for 8 bit palletes is always 8
       * and the color masks are always 0.
       */
      pScreenPriv->dwBitsPerRGB = 8;
      pScreenPriv->dwRedMask = 0x0L;
      pScreenPriv->dwGreenMask = 0x0L;
      pScreenPriv->dwBlueMask = 0x0L;
      return TRUE;
    }

  /* Color masks for 24 bpp are standardized */
  if (GetDeviceCaps (pScreenPriv->hdcScreen, PLANES)
      * GetDeviceCaps (pScreenPriv->hdcScreen, BITSPIXEL) == 24)
    {
      /* 8 bits per primary color */
      pScreenPriv->dwBitsPerRGB = 8;

      /* Set screen privates masks */
      pScreenPriv->dwRedMask = WIN_24BPP_MASK_RED;
      pScreenPriv->dwGreenMask = WIN_24BPP_MASK_GREEN;
      pScreenPriv->dwBlueMask = WIN_24BPP_MASK_BLUE;
      
      return TRUE;
    }

  /* Allocate a bitmap header and color table */
  pbmih = (BITMAPINFOHEADER*) xalloc (sizeof (BITMAPINFOHEADER)
				      + 256  * sizeof (RGBQUAD));
  if (pbmih == NULL)
    {
      ErrorF ("winQueryRGBBitsAndMasks () - xalloc failed\n");
      return FALSE;
    }

  /* Get screen description */
  if (winQueryScreenDIBFormat (pScreen, pbmih))
    {
      /* Get a pointer to bitfields */
      pdw = (DWORD*) ((CARD8*)pbmih + sizeof (BITMAPINFOHEADER));
      
#if CYGDEBUG
      ErrorF ("winQueryRGBBitsAndMasks () - Masks: %08x %08x %08x\n",
	      pdw[0], pdw[1], pdw[2]);
#endif

      /* Count the number of bits in each mask */
      dwRedBits = winCountBits (pdw[0]);
      dwGreenBits = winCountBits (pdw[1]);
      dwBlueBits = winCountBits (pdw[2]);

      /* Find maximum bits per red, green, blue */
      if (dwRedBits > dwGreenBits && dwRedBits > dwBlueBits)
	pScreenPriv->dwBitsPerRGB = dwRedBits;
      else if (dwGreenBits > dwRedBits && dwGreenBits > dwBlueBits)
	pScreenPriv->dwBitsPerRGB = dwGreenBits;
      else
	pScreenPriv->dwBitsPerRGB = dwBlueBits;

      /* Set screen privates masks */
      pScreenPriv->dwRedMask = pdw[0];
      pScreenPriv->dwGreenMask = pdw[1];
      pScreenPriv->dwBlueMask = pdw[2];
    }
  else
    {
      ErrorF ("winQueryRGBBitsAndMasks () - winQueryScreenDIBFormat failed\n");
      xfree (pbmih);
      fReturn = FALSE;
    }

  /* Free memory */
  xfree (pbmih);

  return fReturn;
}

/* Allocate a DIB for the shadow framebuffer GDI server */
Bool
winAllocateFBShadowGDI (ScreenPtr pScreen)
{
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  BITMAPINFOHEADER	*pbmih = NULL;
#if CYGDEBUG
  DIBSECTION		dibsection;
#endif
  Bool			fReturn = TRUE;

  /* Get device contexts for the screen and shadow bitmap */
  pScreenPriv->hdcScreen = GetDC (pScreenPriv->hwndScreen);
  pScreenPriv->hdcShadow = CreateCompatibleDC (pScreenPriv->hdcScreen);

  /* Allocate bitmap info header */
  pbmih = (BITMAPINFOHEADER*) xalloc (sizeof (BITMAPINFOHEADER)
				      + 256 * sizeof (RGBQUAD));
  if (pbmih == NULL)
    {
      ErrorF ("winAllocateFBShadowGDI - xalloc () failed\n");
      return FALSE;
    }

  /* Query the screen format */
  fReturn = winQueryScreenDIBFormat (pScreen, pbmih);

  /* Describe shadow bitmap to be created */
  pbmih->biWidth = pScreenInfo->dwWidth;
  pbmih->biHeight = -pScreenInfo->dwHeight;
  
  /* Create a DI shadow bitmap with a bit pointer */
  pScreenPriv->hbmpShadow = CreateDIBSection (pScreenPriv->hdcScreen,
					      (BITMAPINFO *) pbmih,
					      DIB_RGB_COLORS,
					      (VOID**) &pScreenInfo->pfb,
					      NULL,
					      0);
  if (pScreenPriv->hbmpShadow == NULL || pScreenInfo->pfb == NULL)
    {
      ErrorF ("winAllocateFBShadowGDI () - CreateDIBSection failed\n");
      return FALSE;
    }
  else
    {
#if CYGDEBUG
      ErrorF ("winAllocateFBShadowGDI () - Shadow buffer allocated\n");
#endif
    }

#if CYGDEBUG
  /* Get information about the bitmap that was allocated */
  GetObject (pScreenPriv->hbmpShadow, sizeof (dibsection),
	     &dibsection);

  /* Print information about bitmap allocated */
  ErrorF ("winAllocateFBShadowGDI () - Dibsection width: %d height: %d\n",
	  dibsection.dsBmih.biWidth, dibsection.dsBmih.biHeight);
#endif

  /* Select the shadow bitmap into the shadow DC */
  SelectObject (pScreenPriv->hdcShadow,
		pScreenPriv->hbmpShadow);

#if CYGDEBUG
  ErrorF ("winAllocateFBShadowGDI () - Attempting a shadow blit\n");
#endif

  /* Do a test blit from the shadow to the screen, I think */
  fReturn = BitBlt (pScreenPriv->hdcScreen,
		    0, 0,
		    pScreenInfo->dwWidth, pScreenInfo->dwHeight,
		    pScreenPriv->hdcShadow,
		    0, 0,
		    SRCCOPY);
  if (fReturn)
    {
#if CYGDEBUG
      ErrorF ("winAllocateFBShadowGDI () - Shadow blit success\n");
#endif
    }
  else
    {
      ErrorF ("winAllocateFBShadowGDI () - Shadow blit failure\n");
      return FALSE;
    }

  /* Set screeninfo stride */
  pScreenInfo->dwStrideBytes = pScreenInfo->dwPaddedWidth;
  pScreenInfo->dwStride = (pScreenInfo->dwStrideBytes * 8)
    / pScreenInfo->dwDepth;
  
  /* See if the shadow bitmap will be larger than the DIB size limit */
  if (pScreenInfo->dwWidth * pScreenInfo->dwHeight * pScreenInfo->dwDepth
      >= WIN_DIB_MAXIMUM_SIZE)
    {
      ErrorF ("winAdjustVideoModeShadowGDI () - Requested DIB (bitmap) "
	      "will be larger than %d MB.  The surface may fail to be "
	      "allocated on Windows 95, 98, or Me, due to a %d MB limit in "
	      "DIB size.  This limit does not apply to Windows NT/2000, and "
	      "this message may be ignored on those platforms.\n",
	      WIN_DIB_MAXIMUM_SIZE_MB, WIN_DIB_MAXIMUM_SIZE_MB);
    }

  return fReturn;
}

/* Blit the damaged regions of the shadow fb to the screen */
void
winShadowUpdateGDI (ScreenPtr pScreen, 
		    shadowBufPtr pBuf)
{
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  RegionPtr		damage = &pBuf->damage;
  DWORD			dwBox = REGION_NUM_RECTS (damage);
  BoxPtr		pBox = REGION_RECTS (damage);
  int			x, y, w, h;

  /* Return immediately if the app is not active and we are fullscreen */
  if (!pScreenPriv->fActive && pScreenInfo->fFullScreen) return;

  /* Loop through all boxes in the damaged region */
  while (dwBox--)
    {
      /* Calculate x offset, y offset, width, and height for
	 current damage box
      */
      x = pBox->x1;
      y = pBox->y1;
      w = pBox->x2 - pBox->x1;
      h = pBox->y2 - pBox->y1;

      BitBlt (pScreenPriv->hdcScreen,
	      x, y,
	      w, h,
	      pScreenPriv->hdcShadow,
	      x, y,
	      SRCCOPY);

      /* Get a pointer to the next box */
      ++pBox;
    }
}

/* See Porting Layer Definition - p. 33 */
/*
 * We wrap whatever CloseScreen procedure was specified by fb;
 * a pointer to said procedure is stored in our privates.
 */
Bool
winCloseScreenShadowGDI (int nIndex, ScreenPtr pScreen)
{
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  Bool			fReturn;

#if CYGDEBUG
  ErrorF ("winCloseScreenShadowGDI () - Freeing screen resources\n");
#endif

  /* Flag that the screen is closed */
  pScreenPriv->fClosed = TRUE;
  pScreenPriv->fActive = FALSE;

  /* Call the wrapped CloseScreen procedure */
  pScreen->CloseScreen = pScreenPriv->CloseScreen;
  fReturn = (*pScreen->CloseScreen) (nIndex, pScreen);

  /* Delete the window property */
  RemoveProp (pScreenPriv->hwndScreen, WIN_SCR_PROP);

  /* Free the shadow DC; which allows the bitmap to be freed */
  DeleteDC (pScreenPriv->hdcShadow);
  
  /* Free the shadow bitmap */
  DeleteObject (pScreenPriv->hbmpShadow);

  /* Free the screen DC */
  ReleaseDC (pScreenPriv->hwndScreen, pScreenPriv->hdcScreen);

  /* Kill our window */
  if (pScreenPriv->hwndScreen)
    {
      DestroyWindow (pScreenPriv->hwndScreen);
      pScreenPriv->hwndScreen = NULL;
    }

  /* Invalidate our screeninfo's pointer to the screen */
  pScreenInfo->pScreen = NULL;

  /* Invalidate the ScreenInfo's fb pointer */
  pScreenInfo->pfb = NULL;

  /* Free the screen privates for this screen */
  xfree ((pointer) pScreenPriv);

  return fReturn;
}

Bool
winInitVisualsShadowGDI (ScreenPtr pScreen)
{
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;

  /* Determine our color masks */
  if (!winQueryRGBBitsAndMasks (pScreen))
    {
      ErrorF ("winInitVisualsShadowGDI () - winQueryRGBBitsAndMasks failed\n");
      return FALSE;
    }

  /* Display debugging information */
  ErrorF ("winInitVisualsGDI () - Masks %08x %08x %08x BPRGB %d d %d\n",
	  pScreenPriv->dwRedMask,
	  pScreenPriv->dwGreenMask,
	  pScreenPriv->dwBlueMask,
	  pScreenPriv->dwBitsPerRGB,
	  pScreenInfo->dwDepth);

  /* Create a single visual according to the Windows screen depth */
  switch (pScreenInfo->dwDepth)
    {
    case 32:
    case 24:
    case 16:
    case 15:
      /* Setup the real visual */
      if (!miSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     TrueColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     TrueColor,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsGDI () - miSetVisualTypesAndMasks failed\n");
	  return FALSE;
	}
      break;

    case 8:
      if (!miSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     PseudoColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     PseudoColor,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsGDI () - miSetVisualTypesAndMasks failed\n");
	  return FALSE;
	}
      break;

    default:
      ErrorF ("winInitVisualsGDI () - Unknown screen depth\n");
      return FALSE;
    }

#if CYGDEBUG
  ErrorF ("winInitVisualsGDI () - Returning\n");
#endif

  return TRUE;
}

/* Adjust the video mode */
Bool
winAdjustVideoModeShadowGDI (ScreenPtr pScreen)
{
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  HDC			hdc;
  DWORD			dwDepth;
  
  hdc = GetDC (NULL);

  /* We're in serious trouble if we can't get a DC */
  if (hdc == NULL)
    {
      ErrorF ("winAdjustVideoModeShadowGDI () - GetDC () failed\n");
      return FALSE;
    }

  /* Query GDI for current display depth */
  dwDepth = GetDeviceCaps (hdc, BITSPIXEL);

  /* GDI cannot change the screen depth */
  if (pScreenInfo->dwDepth == WIN_DEFAULT_DEPTH)
    {
      /* No -depth parameter passed, let the user know the depth being used */
      ErrorF ("winAdjustVideoModeShadowGDI () - Using Windows display "
	      "depth of %d bits per pixel\n", dwDepth);

      /* Use GDI's depth */
      pScreenInfo->dwDepth = dwDepth;
    }
  else if (dwDepth != pScreenInfo->dwDepth)
    {
      /* Warn user if GDI depth is different than -depth parameter */
      ErrorF ("winAdjustVideoModeShadowGDI () - Command line depth: %d, "\
	      "using depth: %d\n", pScreenInfo->dwDepth, dwDepth);

      /* We'll use GDI's depth */
      pScreenInfo->dwDepth = dwDepth;
    }
  
  /* Release our DC */
  ReleaseDC (NULL, hdc);
  hdc = NULL;

  return TRUE;
}

/* Blt exposed regions to the screen */
Bool
winBltExposedRegionsShadowGDI (ScreenPtr pScreen)
{
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  winPrivCmapPtr	pCmapPriv = NULL;
  HDC			hdcUpdate;
  PAINTSTRUCT		ps;

  /* BeginPaint gives us an hdc that clips to the invalidated region */
  hdcUpdate = BeginPaint (pScreenPriv->hwndScreen, &ps);

  /* Realize the palette, if we have one */
  if (pScreenPriv->pcmapInstalled != NULL)
    {
      pCmapPriv = winGetCmapPriv (pScreenPriv->pcmapInstalled);
      
      SelectPalette (hdcUpdate, pCmapPriv->hPalette, FALSE);
      RealizePalette (hdcUpdate);
    }

  /* Our BitBlt will be clipped to the invalidated region */
  BitBlt (hdcUpdate,
	  0, 0,
	  pScreenInfo->dwWidth, pScreenInfo->dwHeight,
	  pScreenPriv->hdcShadow,
	  0, 0,
	  SRCCOPY);

  /* EndPaint frees the DC */
  EndPaint (pScreenPriv->hwndScreen, &ps);

  return TRUE;
}

Bool
winActivateAppShadowGDI (ScreenPtr pScreen)
{
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;

#if CYGDEBUG
  ErrorF ("winActivateAppShadowGDI ()\n");
#endif

  /*
   * Are we active?
   * Are we fullscreen?
   */
  if (pScreenPriv->fActive
      && pScreenInfo->fFullScreen)
    {
      /*
       * Activating, attempt to bring our window 
       * to the top of the display
       */
      ShowWindow (pScreenPriv->hwndScreen, SW_RESTORE);
    }
  else if (!pScreenPriv->fActive
	   && pScreenInfo->fFullScreen)
    {
      /*
       * Deactivating, stuff our window onto the
       * task bar.
       */
      ShowWindow (pScreenPriv->hwndScreen, SW_MINIMIZE);
    }

#if CYGDEBUG
  ErrorF ("winActivateAppShadowGDI () - Returning\n");
#endif

  return TRUE;
}


/*
 * Reblit the shadow framebuffer to the screen.
 */

Bool
winRedrawScreenShadowGDI (ScreenPtr pScreen)
{
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;

  /* Redraw the whole window, to take account for the new colors */
  BitBlt (pScreenPriv->hdcScreen,
	  0, 0,
	  pScreenInfo->dwWidth, pScreenInfo->dwHeight,
	  pScreenPriv->hdcShadow,
	  0, 0,
	  SRCCOPY);

  return TRUE;
}

Bool
winRealizeInstalledPaletteShadowGDI (ScreenPtr pScreen)
{
  winScreenPriv(pScreen);
  winPrivCmapPtr	pCmapPriv = NULL;

#if CYGDEBUG
  ErrorF ("winRealizeInstalledPaletteShadowGDI ()\n");
#endif

  /* Don't do anything if there is not a colormap */
  if (pScreenPriv->pcmapInstalled == NULL)
    {
#if CYGDEBUG
      ErrorF ("winRealizeInstalledPaletteShadowGDI () - No colormap "
	      "installed\n");
#endif
      return TRUE;
    }

  pCmapPriv = winGetCmapPriv (pScreenPriv->pcmapInstalled);
  
  /* Realize our palette for the screen */
  if (RealizePalette (pScreenPriv->hdcScreen) == GDI_ERROR)
    {
      ErrorF ("winRealizeInstalledPaletteShadowGDI () - RealizePalette () "
	      "failed\n");
      return FALSE;
    }
  
  /* Set the DIB color table */
  if (SetDIBColorTable (pScreenPriv->hdcShadow,
			0,
			WIN_NUM_PALETTE_ENTRIES,
			pCmapPriv->rgbColors) == 0)
    {
      ErrorF ("winRealizeInstalledPaletteShadowGDI () - SetDIBColorTable () "
	      "failed\n");
      return FALSE;
    }
  
  return TRUE;
}


/* Install the specified colormap */
Bool
winInstallColormapShadowGDI (ColormapPtr pColormap)
{
  ScreenPtr		pScreen = pColormap->pScreen;
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  winCmapPriv(pColormap);

  /*
   * Tell Windows to install the new colormap
   */
  if (SelectPalette (pScreenPriv->hdcScreen,
		     pCmapPriv->hPalette,
		     FALSE) == NULL)
    {
      ErrorF ("winInstallColormapShadowGDI () - SelectPalette () failed\n");
      return FALSE;
    }
      
  /* Realize the palette */
  if (GDI_ERROR == RealizePalette (pScreenPriv->hdcScreen))
    {
      ErrorF ("winInstallColormapShadowGDI () - RealizePalette () failed\n");
      return FALSE;
    }

  /* Set the DIB color table */
  if (SetDIBColorTable (pScreenPriv->hdcShadow,
			0,
			WIN_NUM_PALETTE_ENTRIES,
			pCmapPriv->rgbColors) == 0)
    {
      ErrorF ("winInstallColormapShadowGDI () - SetDIBColorTable () failed\n");
      return FALSE;
    }

  /* Redraw the whole window, to take account for the new colors */
  BitBlt (pScreenPriv->hdcScreen,
	  0, 0,
	  pScreenInfo->dwWidth, pScreenInfo->dwHeight,
	  pScreenPriv->hdcShadow,
	  0, 0,
	  SRCCOPY);

  /* Save a pointer to the newly installed colormap */
  pScreenPriv->pcmapInstalled = pColormap;

  return TRUE;
}


/* Store the specified colors in the specified colormap */
Bool
winStoreColorsShadowGDI (ColormapPtr pColormap,
			 int ndef,
			 xColorItem *pdefs)
{
  ScreenPtr		pScreen = pColormap->pScreen;
  winScreenPriv(pScreen);
  winCmapPriv(pColormap);
  ColormapPtr curpmap = pScreenPriv->pcmapInstalled;
  
  /* Put the X colormap entries into the Windows logical palette */
  if (SetPaletteEntries (pCmapPriv->hPalette,
			 pdefs[0].pixel,
			 ndef,
			 pCmapPriv->peColors + pdefs[0].pixel) == 0)
    {
      ErrorF ("winStoreColorsShadowGDI () - SetPaletteEntries () failed\n");
      return FALSE;
    }

  /* Don't install the Windows palette if the colormap is not installed */
  if (pColormap != curpmap)
    {
      return TRUE;
    }

  /* Try to install the newly modified colormap */
  if (!winInstallColormapShadowGDI (pColormap))
    {
      ErrorF ("winInstallColormapShadowGDI () - winInstallColormapShadowGDI "
	      "failed\n");
      return FALSE;
    }

#if 0
  /* Tell Windows that the palette has changed */
  RealizePalette (pScreenPriv->hdcScreen);
  
  /* Set the DIB color table */
  if (SetDIBColorTable (pScreenPriv->hdcShadow,
			pdefs[0].pixel,
			ndef,
			pCmapPriv->rgbColors + pdefs[0].pixel) == 0)
    {
      ErrorF ("winInstallColormapShadowGDI () - SetDIBColorTable () failed\n");
      return FALSE;
    }

  /* Save a pointer to the newly installed colormap */
  pScreenPriv->pcmapInstalled = pColormap;
#endif

  return TRUE;
}


/* Colormap initialization procedure */
Bool
winCreateColormapShadowGDI (ColormapPtr pColormap)
{
  LPLOGPALETTE		lpPaletteNew = NULL;
  DWORD			dwEntriesMax;
  VisualPtr		pVisual;
  HPALETTE		hpalNew = NULL;
  winCmapPriv(pColormap);

  /* Get a pointer to the visual that the colormap belongs to */
  pVisual = pColormap->pVisual;

  /* Get the maximum number of palette entries for this visual */
  dwEntriesMax = pVisual->ColormapEntries;

  /* Allocate a Windows logical color palette with max entries */
  lpPaletteNew = xalloc (sizeof (LOGPALETTE)
			 + (dwEntriesMax - 1) * sizeof (PALETTEENTRY));
  if (lpPaletteNew == NULL)
    {
      ErrorF ("winCreateColormapShadowGDI () - Couldn't allocate palette "
	      "with %d entries\n",
	      dwEntriesMax);
      return FALSE;
    }

  /* Zero out the colormap */
  ZeroMemory (lpPaletteNew, sizeof (LOGPALETTE)
	      + (dwEntriesMax - 1) * sizeof (PALETTEENTRY));
  
  /* Set the logical palette structure */
  lpPaletteNew->palVersion = 0x0300;
  lpPaletteNew->palNumEntries = dwEntriesMax;

  /* Tell Windows to create the palette */
  hpalNew = CreatePalette (lpPaletteNew);
  if (hpalNew == NULL)
    {
      ErrorF ("winCreateColormapShadowGDI () - CreatePalette () failed\n");
      free (lpPaletteNew);
      return FALSE;
    }

  /* Save the Windows logical palette handle in the X colormaps' privates */
  pCmapPriv->hPalette = hpalNew;

  /* Free the palette initialization memory */
  xfree (lpPaletteNew);

  return TRUE;
}


/* Colormap destruction procedure */
Bool
winDestroyColormapShadowGDI (ColormapPtr pColormap)
{
  winScreenPriv(pColormap->pScreen);
  winCmapPriv(pColormap);

  /*
   * Is colormap to be destroyed the default?
   *
   * Non-default colormaps should have had winUninstallColormap
   * called on them before we get here.  The default colormap
   * will not have had winUninstallColormap called on it.  Thus,
   * we need to handle the default colormap in a special way.
   */
  if (pColormap->flags & IsDefault)
    {
#if CYGDEBUG
      ErrorF ("winDestroyColormapShadowGDI () - Destroying default "
	      "colormap\n");
#endif
      
      /*
       * FIXME: Walk the list of all screens, popping the default
       * palette out of each screen device context.
       */
      
      /* Pop the palette out of the device context */
      SelectPalette (pScreenPriv->hdcScreen,
		     GetStockObject (DEFAULT_PALETTE),
		     FALSE);

      /* Clear our private installed colormap pointer */
      pScreenPriv->pcmapInstalled = NULL;
    }
  
  /* Try to delete the logical palette */
  if (DeleteObject (pCmapPriv->hPalette) == 0)
    {
      ErrorF ("winDestroyColormap () - DeleteObject () failed\n");
      return FALSE;
    }
  
  /* Invalidate the colormap privates */
  pCmapPriv->hPalette = NULL;

  return TRUE;
}


/* Set engine specific funtions */
Bool
winSetEngineFunctionsShadowGDI (ScreenPtr pScreen)
{
  winScreenPriv(pScreen);
  winScreenInfo		*pScreenInfo = pScreenPriv->pScreenInfo;
  
  /* Set our pointers */
  pScreenPriv->pwinAllocateFB = winAllocateFBShadowGDI;
  pScreenPriv->pwinShadowUpdate = winShadowUpdateGDI;
  pScreenPriv->pwinCloseScreen = winCloseScreenShadowGDI;
  pScreenPriv->pwinInitVisuals = winInitVisualsShadowGDI;
  pScreenPriv->pwinAdjustVideoMode = winAdjustVideoModeShadowGDI;
  if (pScreenInfo->fFullScreen)
    pScreenPriv->pwinCreateBoundingWindow = winCreateBoundingWindowFullScreen;
  else
    pScreenPriv->pwinCreateBoundingWindow = winCreateBoundingWindowWindowed;
  pScreenPriv->pwinFinishScreenInit = winFinishScreenInitFB;
  pScreenPriv->pwinBltExposedRegions = winBltExposedRegionsShadowGDI;
  pScreenPriv->pwinActivateApp = winActivateAppShadowGDI;
  pScreenPriv->pwinRedrawScreen = winRedrawScreenShadowGDI;
  pScreenPriv->pwinRealizeInstalledPalette = 
    winRealizeInstalledPaletteShadowGDI;
  pScreenPriv->pwinInstallColormap = winInstallColormapShadowGDI;
  pScreenPriv->pwinStoreColors = winStoreColorsShadowGDI;
  pScreenPriv->pwinCreateColormap = winCreateColormapShadowGDI;
  pScreenPriv->pwinDestroyColormap = winDestroyColormapShadowGDI;
  pScreenPriv->pwinHotKeyAltTab = (winHotKeyAltTabPtr) (void (*)())NoopDDA;

  return TRUE;
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d30 1
a30 1
/* $XFree86: xc/programs/Xserver/hw/xwin/winshadgdi.c,v 1.23 2003/07/29 21:25:18 dawes Exp $ */
a33 12
/*
 * Local function prototypes
 */

BOOL CALLBACK
winRedrawAllProcShadowGDI (HWND hwnd, LPARAM lParam);


/*
 * Internal function to get the DIB format that is compatible with the screen
 */

d48 1
a48 1
      ErrorF ("winQueryScreenDIBFormat - CreateCompatibleBitmap failed\n");
d64 1
a64 1
      ErrorF ("winQueryScreenDIBFormat - First call to GetDIBits failed\n");
d73 1
a73 1
  ErrorF ("winQueryScreenDIBFormat - First call masks: %08x %08x %08x\n",
d85 1
a85 1
      ErrorF ("winQueryScreenDIBFormat - Second call to GetDIBits "
a96 5

/*
 * Internal function to determine the GDI bits per rgb and bit masks
 */

a124 3
      ErrorF ("winQueryRGBBitsAndMasks - GetDeviceCaps (BITSPIXEL) "
	      "returned 24 for the screen.  Using default 24bpp masks.\n");

d137 1
a137 1
  pbmih = (BITMAPINFOHEADER*) malloc (sizeof (BITMAPINFOHEADER)
d141 1
a141 1
      ErrorF ("winQueryRGBBitsAndMasks - malloc failed\n");
d152 1
a152 1
      ErrorF ("winQueryRGBBitsAndMasks - Masks: %08x %08x %08x\n",
d176 2
a177 2
      ErrorF ("winQueryRGBBitsAndMasks - winQueryScreenDIBFormat failed\n");
      free (pbmih);
d182 1
a182 1
  free (pbmih);
d187 1
a187 26

/*
 * Redraw all ---?
 */

BOOL CALLBACK
winRedrawAllProcShadowGDI (HWND hwnd, LPARAM lParam)
{
  char strClassName[100];

  if (GetClassName (hwnd, strClassName, 100))
    {
      if (strncmp (WINDOW_CLASS_X, strClassName, strlen (WINDOW_CLASS_X)) == 0)
	{
	  InvalidateRect (hwnd, NULL, FALSE);
	  UpdateWindow (hwnd);
	}
    }
  return TRUE;
}


/*
 * Allocate a DIB for the shadow framebuffer GDI server
 */

d194 1
d196 1
d204 1
a204 1
  pbmih = (BITMAPINFOHEADER*) malloc (sizeof (BITMAPINFOHEADER)
d208 1
a208 1
      ErrorF ("winAllocateFBShadowGDI - malloc () failed\n");
a218 4
  ErrorF ("winAllocateFBShadowGDI - Creating DIB with width: %d height: %d "
	  "depth: %d\n",
	  pbmih->biWidth, -pbmih->biHeight, pbmih->biBitCount);

d228 1
a228 1
      ErrorF ("winAllocateFBShadowGDI - CreateDIBSection failed\n");
d234 1
a234 1
      ErrorF ("winAllocateFBShadowGDI - Shadow buffer allocated\n");
d238 1
d240 1
a240 2
  GetObject (pScreenPriv->hbmpShadow,
	     sizeof (dibsection),
a242 1
#if CYGDEBUG || YES
d244 2
a245 5
  ErrorF ("winAllocateFBShadowGDI - Dibsection width: %d height: %d "
	  "depth: %d size image: %d\n",
	  dibsection.dsBmih.biWidth, dibsection.dsBmih.biHeight,
	  dibsection.dsBmih.biBitCount,
	  dibsection.dsBmih.biSizeImage);
d253 1
a253 1
  ErrorF ("winAllocateFBShadowGDI - Attempting a shadow blit\n");
d266 1
a266 1
      ErrorF ("winAllocateFBShadowGDI - Shadow blit success\n");
d271 1
a271 1
      ErrorF ("winAllocateFBShadowGDI - Shadow blit failure\n");
a274 11
  /* Look for height weirdness */
  if (dibsection.dsBmih.biHeight < 0)
    {
      /* FIXME: Figure out why biHeight is sometimes negative */
      ErrorF ("winAllocateFBShadowGDI - WEIRDNESS - biHeight "
	      "still negative: %d\n"
	      "winAllocateFBShadowGDI - WEIRDNESS - Flipping biHeight sign\n",
	      dibsection.dsBmih.biHeight);
      dibsection.dsBmih.biHeight = -dibsection.dsBmih.biHeight;
    }

d276 4
a279 9
  pScreenInfo->dwStride = ((dibsection.dsBmih.biSizeImage
			    / dibsection.dsBmih.biHeight)
			   * 8) / pScreenInfo->dwBPP;

#if CYGDEBUG || YES
  ErrorF ("winAllocateFBShadowGDI - Created shadow stride: %d\n",
	  pScreenInfo->dwStride);
#endif

d281 1
a281 1
  if (pScreenInfo->dwWidth * pScreenInfo->dwHeight * pScreenInfo->dwBPP
d284 1
a284 1
      ErrorF ("winAllocateFBShadowGDI - Requested DIB (bitmap) "
a291 10
  /* Determine our color masks */
  if (!winQueryRGBBitsAndMasks (pScreen))
    {
      ErrorF ("winAllocateFBShadowGDI - winQueryRGBBitsAndMasks failed\n");
      return FALSE;
    }

  /* Redraw all windows */
  if (pScreenInfo->fMultiWindow) EnumWindows(winRedrawAllProcShadowGDI, 0);

d295 1
a295 5

/*
 * Blit the damaged regions of the shadow fb to the screen
 */

a305 13
  HRGN			hrgnTemp = NULL, hrgnCombined = NULL;
#if WIN_UPDATE_STATS
  static DWORD		s_dwNonUnitRegions = 0;
  static DWORD		s_dwTotalUpdates = 0;
  static DWORD		s_dwTotalBoxes = 0;
#endif

  /*
   * Return immediately if the app is not active
   * and we are fullscreen, or if we have a bad display depth
   */
  if ((!pScreenPriv->fActive && pScreenInfo->fFullScreen)
      || pScreenPriv->fBadDepth) return;
d307 2
a308 3
#if WIN_UPDATE_STATS
  ++s_dwTotalUpdates;
  s_dwTotalBoxes += dwBox;
d310 2
a311 1
  if (dwBox != 1)
d313 7
a319 11
      ++s_dwNonUnitRegions;
      ErrorF ("winShadowUpdatGDI - dwBox: %d\n", dwBox);
    }
  
  if ((s_dwTotalUpdates % 100) == 0)
    ErrorF ("winShadowUpdateGDI - %d%% non-unity regions, avg boxes: %d "
	    "nu: %d tu: %d\n",
	    (s_dwNonUnitRegions * 100) / s_dwTotalUpdates,
	    s_dwTotalBoxes / s_dwTotalUpdates,
	    s_dwNonUnitRegions, s_dwTotalUpdates);
#endif /* WIN_UPDATE_STATS */
a320 56
  /*
   * Handle small regions with multiple blits,
   * handle large regions by creating a clipping region and 
   * doing a single blit constrained to that clipping region.
   */
  if (pScreenInfo->dwClipUpdatesNBoxes == 0
      || dwBox < pScreenInfo->dwClipUpdatesNBoxes)
    {
      /* Loop through all boxes in the damaged region */
      while (dwBox--)
	{
	  /*
	   * Calculate x offset, y offset, width, and height for
	   * current damage box
	   */
	  x = pBox->x1;
	  y = pBox->y1;
	  w = pBox->x2 - pBox->x1;
	  h = pBox->y2 - pBox->y1;
	  
	  BitBlt (pScreenPriv->hdcScreen,
		  x, y,
		  w, h,
		  pScreenPriv->hdcShadow,
		  x, y,
		  SRCCOPY);
	  
	  /* Get a pointer to the next box */
	  ++pBox;
	}
    }
  else
    {
      BoxPtr		pBoxExtents = REGION_EXTENTS (pScreen, damage);

      /* Compute a GDI region from the damaged region */
      hrgnCombined = CreateRectRgn (pBox->x1, pBox->y1, pBox->x2, pBox->y2);
      dwBox--;
      pBox++;
      while (dwBox--)
	{
	  hrgnTemp = CreateRectRgn (pBox->x1, pBox->y1, pBox->x2, pBox->y2);
	  CombineRgn (hrgnCombined, hrgnCombined, hrgnTemp, RGN_OR);
	  DeleteObject (hrgnTemp);
	  pBox++;
	}
      
      /* Install the GDI region as a clipping region */
      SelectClipRgn (pScreenPriv->hdcScreen, hrgnCombined);
      DeleteObject (hrgnCombined);
      hrgnCombined = NULL;
      
      /*
       * Blit the shadow buffer to the screen,
       * constrained to the clipping region.
       */
d322 2
a323 3
	      pBoxExtents->x1, pBoxExtents->y1,
	      pBoxExtents->x2 - pBoxExtents->x1,
	      pBoxExtents->y2 - pBoxExtents->y1,
d325 1
a325 1
	      pBoxExtents->x1, pBoxExtents->y1,
d328 2
a329 2
      /* Reset the clip region */
      SelectClipRgn (pScreenPriv->hdcScreen, NULL);
a330 3

  /* Redraw all windows */
  if (pScreenInfo->fMultiWindow) EnumWindows(winRedrawAllProcShadowGDI, 0);
a332 1

a337 1

d346 1
a346 1
  ErrorF ("winCloseScreenShadowGDI - Freeing screen resources\n");
a368 11
  /* Delete tray icon, if we have one */
  if (!pScreenInfo->fNoTrayIcon)
    winDeleteNotifyIcon (pScreenPriv);

  /* Free the exit confirmation dialog box, if it exists */
  if (g_hDlgExit != NULL)
    {
      DestroyWindow (g_hDlgExit);
      g_hDlgExit = NULL;
    }

a375 3
  /* Destroy the thread startup mutex */
  pthread_mutex_destroy (&pScreenPriv->pmServerStarted);

d383 1
a383 1
  free ((pointer) pScreenPriv);
a387 9

/*
 * Tell mi what sort of visuals we need.
 * 
 * Generally we only need one visual, as our screen can only
 * handle one format at a time, I believe.  You may want
 * to verify that last sentence.
 */

d394 7
d402 1
a402 2
  ErrorF ("winInitVisualsShadowGDI - Masks %08x %08x %08x BPRGB %d d %d "
	  "bpp %d\n",
d407 1
a407 2
	  pScreenInfo->dwDepth,
	  pScreenInfo->dwBPP);
d412 1
a415 1
#if defined(XFree86Server)
d420 1
a420 1
				     -1,
d425 1
a425 20
	  ErrorF ("winInitVisualsShadowGDI - miSetVisualTypesAndMasks "
		  "failed\n");
	  return FALSE;
	}

#if WIN_EMULATE_PSEUDO_SUPPORT
      if (!pScreenInfo->fEmulatePseudo)
	break;

      /* Setup a pseudocolor visual */
      if (!miSetVisualTypesAndMasks (8,
				     PseudoColorMask,
				     8,
				     -1,
				     0,
				     0,
				     0))
	{
	  ErrorF ("winInitVisualsShadowGDI - miSetVisualTypesAndMasks "
		  "failed for PseudoColor\n");
a427 33
#endif
#else /* XFree86Server */
      /* Setup the real visual */
      if (!fbSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     TrueColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsShadowGDI - fbSetVisualTypesAndMasks "
		  "failed for TrueColor\n");
	  return FALSE;
	}

#if WIN_EMULATE_PSEUDO_SUPPORT
      if (!pScreenInfo->fEmulatePseudo)
	break;

      /* Setup a pseudocolor visual */
      if (!fbSetVisualTypesAndMasks (8,
				     PseudoColorMask,
				     8,
				     0,
				     0,
				     0))
	{
	  ErrorF ("winInitVisualsShadowGDI - fbSetVisualTypesAndMasks "
		  "failed for PseudoColor\n");
	  return FALSE;
	}
#endif
#endif /* XFree86Server */
a430 1
#if defined(XFree86Server)
d439 1
a439 2
	  ErrorF ("winInitVisualsShadowGDI - miSetVisualTypesAndMasks "
		  "failed\n");
a441 13
#else /* XFree86Server */
      if (!fbSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     PseudoColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsShadowGDI - fbSetVisualTypesAndMasks "
		  "failed\n");
	  return FALSE;
	}
#endif
d445 1
a445 1
      ErrorF ("winInitVisualsShadowGDI - Unknown screen depth\n");
d450 1
a450 1
  ErrorF ("winInitVisualsShadowGDI - Returning\n");
d456 1
a456 5

/*
 * Adjust the proposed video mode
 */

d463 1
a463 1
  DWORD			dwBPP;
d470 1
a470 1
      ErrorF ("winAdjustVideoModeShadowGDI - GetDC () failed\n");
d475 1
a475 1
  dwBPP = GetDeviceCaps (hdc, BITSPIXEL);
d478 1
a478 1
  if (pScreenInfo->dwBPP == WIN_DEFAULT_BPP)
d481 2
a482 2
      ErrorF ("winAdjustVideoModeShadowGDI - Using Windows display "
	      "depth of %d bits per pixel\n", dwBPP);
d485 1
a485 1
      pScreenInfo->dwBPP = dwBPP;
d487 1
a487 1
  else if (dwBPP != pScreenInfo->dwBPP)
d490 2
a491 2
      ErrorF ("winAdjustVideoModeShadowGDI - Command line bpp: %d, "\
	      "using bpp: %d\n", pScreenInfo->dwBPP, dwBPP);
d494 1
a494 1
      pScreenInfo->dwBPP = dwBPP;
d504 1
a504 5

/*
 * Blt exposed regions to the screen
 */

a536 3
  /* Redraw all windows */
  if (pScreenInfo->fMultiWindow) EnumWindows(winRedrawAllProcShadowGDI, 0);

a539 5

/*
 * Do any engine-specific appliation-activation processing
 */

d547 1
a547 1
  ErrorF ("winActivateAppShadowGDI\n");
d574 1
a574 1
  ErrorF ("winActivateAppShadowGDI - Returning\n");
a598 2
  /* Redraw all windows */
  if (pScreenInfo->fMultiWindow) EnumWindows(winRedrawAllProcShadowGDI, 0);
a601 5

/*
 * Realize the currently installed colormap
 */

d609 1
a609 1
  ErrorF ("winRealizeInstalledPaletteShadowGDI\n");
d616 1
a616 1
      ErrorF ("winRealizeInstalledPaletteShadowGDI - No colormap "
d627 1
a627 1
      ErrorF ("winRealizeInstalledPaletteShadowGDI - RealizePalette () "
d638 1
a638 1
      ErrorF ("winRealizeInstalledPaletteShadowGDI - SetDIBColorTable () "
d647 1
a647 4
/*
 * Install the specified colormap
 */

d663 1
a663 1
      ErrorF ("winInstallColormapShadowGDI - SelectPalette () failed\n");
d670 1
a670 1
      ErrorF ("winInstallColormapShadowGDI - RealizePalette () failed\n");
d680 1
a680 1
      ErrorF ("winInstallColormapShadowGDI - SetDIBColorTable () failed\n");
a694 3
  /* Redraw all windows */
  if (pScreenInfo->fMultiWindow) EnumWindows(winRedrawAllProcShadowGDI, 0);

d699 1
a699 4
/*
 * Store the specified colors in the specified colormap
 */

d716 1
a716 1
      ErrorF ("winStoreColorsShadowGDI - SetPaletteEntries () failed\n");
d729 1
a729 1
      ErrorF ("winInstallColormapShadowGDI - winInstallColormapShadowGDI "
d744 1
a744 1
      ErrorF ("winInstallColormapShadowGDI - SetDIBColorTable () failed\n");
d756 1
a756 4
/*
 * Colormap initialization procedure
 */

d773 1
a773 1
  lpPaletteNew = malloc (sizeof (LOGPALETTE)
d777 1
a777 1
      ErrorF ("winCreateColormapShadowGDI - Couldn't allocate palette "
d795 1
a795 1
      ErrorF ("winCreateColormapShadowGDI - CreatePalette () failed\n");
d804 1
a804 1
  free (lpPaletteNew);
d810 1
a810 4
/*
 * Colormap destruction procedure
 */

d828 1
a828 1
      ErrorF ("winDestroyColormapShadowGDI - Destroying default "
d849 1
a849 1
      ErrorF ("winDestroyColormap - DeleteObject () failed\n");
d860 1
a860 4
/*
 * Set engine specific funtions
 */

d887 1
a887 5
  pScreenPriv->pwinHotKeyAltTab = (winHotKeyAltTabProcPtr) (void (*)())NoopDDA;
  pScreenPriv->pwinCreatePrimarySurface
    = (winCreatePrimarySurfaceProcPtr) (void (*)())NoopDDA;
  pScreenPriv->pwinReleasePrimarySurface
    = (winReleasePrimarySurfaceProcPtr) (void (*)())NoopDDA;
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d30 1
a30 1
/* $XFree86: xc/programs/Xserver/hw/xwin/winshadgdi.c,v 1.22 2003/02/12 15:01:38 alanh Exp $ */
a33 12
/*
 * Local function prototypes
 */

BOOL CALLBACK
winRedrawAllProcShadowGDI (HWND hwnd, LPARAM lParam);


/*
 * Internal function to get the DIB format that is compatible with the screen
 */

d48 1
a48 1
      ErrorF ("winQueryScreenDIBFormat - CreateCompatibleBitmap failed\n");
d64 1
a64 1
      ErrorF ("winQueryScreenDIBFormat - First call to GetDIBits failed\n");
d73 1
a73 1
  ErrorF ("winQueryScreenDIBFormat - First call masks: %08x %08x %08x\n",
d85 1
a85 1
      ErrorF ("winQueryScreenDIBFormat - Second call to GetDIBits "
a96 5

/*
 * Internal function to determine the GDI bits per rgb and bit masks
 */

a124 3
      ErrorF ("winQueryRGBBitsAndMasks - GetDeviceCaps (BITSPIXEL) "
	      "returned 24 for the screen.  Using default 24bpp masks.\n");

d137 1
a137 1
  pbmih = (BITMAPINFOHEADER*) malloc (sizeof (BITMAPINFOHEADER)
d141 1
a141 1
      ErrorF ("winQueryRGBBitsAndMasks - malloc failed\n");
d152 1
a152 1
      ErrorF ("winQueryRGBBitsAndMasks - Masks: %08x %08x %08x\n",
d176 2
a177 2
      ErrorF ("winQueryRGBBitsAndMasks - winQueryScreenDIBFormat failed\n");
      free (pbmih);
d182 1
a182 1
  free (pbmih);
d187 1
a187 26

/*
 * Redraw all ---?
 */

BOOL CALLBACK
winRedrawAllProcShadowGDI (HWND hwnd, LPARAM lParam)
{
  char strClassName[100];

  if (GetClassName (hwnd, strClassName, 100))
    {
      if(strcmp (WINDOW_CLASS_X, strClassName) == 0)
	{
	  InvalidateRect (hwnd, NULL, FALSE);
	  UpdateWindow (hwnd);
	}
    }
  return TRUE;
}


/*
 * Allocate a DIB for the shadow framebuffer GDI server
 */

d194 1
d196 1
d204 1
a204 1
  pbmih = (BITMAPINFOHEADER*) malloc (sizeof (BITMAPINFOHEADER)
d208 1
a208 1
      ErrorF ("winAllocateFBShadowGDI - malloc () failed\n");
a218 4
  ErrorF ("winAllocateFBShadowGDI - Creating DIB with width: %d height: %d "
	  "depth: %d\n",
	  pbmih->biWidth, -pbmih->biHeight, pbmih->biBitCount);

d228 1
a228 1
      ErrorF ("winAllocateFBShadowGDI - CreateDIBSection failed\n");
d234 1
a234 1
      ErrorF ("winAllocateFBShadowGDI - Shadow buffer allocated\n");
d238 1
d240 1
a240 2
  GetObject (pScreenPriv->hbmpShadow,
	     sizeof (dibsection),
a242 1
#if CYGDEBUG || YES
d244 2
a245 5
  ErrorF ("winAllocateFBShadowGDI - Dibsection width: %d height: %d "
	  "depth: %d size image: %d\n",
	  dibsection.dsBmih.biWidth, dibsection.dsBmih.biHeight,
	  dibsection.dsBmih.biBitCount,
	  dibsection.dsBmih.biSizeImage);
d253 1
a253 1
  ErrorF ("winAllocateFBShadowGDI - Attempting a shadow blit\n");
d266 1
a266 1
      ErrorF ("winAllocateFBShadowGDI - Shadow blit success\n");
d271 1
a271 1
      ErrorF ("winAllocateFBShadowGDI - Shadow blit failure\n");
d276 4
a279 9
  pScreenInfo->dwStride = ((dibsection.dsBmih.biSizeImage
			    / dibsection.dsBmih.biHeight)
			   * 8) / pScreenInfo->dwBPP;

#if CYGDEBUG || YES
  ErrorF ("winAllocateFBShadowGDI - Created shadow stride: %d\n",
	  pScreenInfo->dwStride);
#endif

d281 1
a281 1
  if (pScreenInfo->dwWidth * pScreenInfo->dwHeight * pScreenInfo->dwBPP
d284 1
a284 1
      ErrorF ("winAllocateFBShadowGDI - Requested DIB (bitmap) "
a291 10
  /* Determine our color masks */
  if (!winQueryRGBBitsAndMasks (pScreen))
    {
      ErrorF ("winAllocateFBShadowGDI - winQueryRGBBitsAndMasks failed\n");
      return FALSE;
    }

  /* Redraw all windows */
  if (pScreenInfo->fMultiWindow) EnumWindows(winRedrawAllProcShadowGDI, 0);

d295 1
a295 5

/*
 * Blit the damaged regions of the shadow fb to the screen
 */

a305 13
  HRGN			hrgnTemp = NULL, hrgnCombined = NULL;
#if WIN_UPDATE_STATS
  static DWORD		s_dwNonUnitRegions = 0;
  static DWORD		s_dwTotalUpdates = 0;
  static DWORD		s_dwTotalBoxes = 0;
#endif

  /*
   * Return immediately if the app is not active
   * and we are fullscreen, or if we have a bad display depth
   */
  if ((!pScreenPriv->fActive && pScreenInfo->fFullScreen)
      || pScreenPriv->fBadDepth) return;
d307 2
a308 3
#if WIN_UPDATE_STATS
  ++s_dwTotalUpdates;
  s_dwTotalBoxes += dwBox;
d310 2
a311 1
  if (dwBox != 1)
d313 7
a319 11
      ++s_dwNonUnitRegions;
      ErrorF ("winShadowUpdatGDI - dwBox: %d\n", dwBox);
    }
  
  if ((s_dwTotalUpdates % 100) == 0)
    ErrorF ("winShadowUpdateGDI - %d%% non-unity regions, avg boxes: %d "
	    "nu: %d tu: %d\n",
	    (s_dwNonUnitRegions * 100) / s_dwTotalUpdates,
	    s_dwTotalBoxes / s_dwTotalUpdates,
	    s_dwNonUnitRegions, s_dwTotalUpdates);
#endif /* WIN_UPDATE_STATS */
a320 56
  /*
   * Handle small regions with multiple blits,
   * handle large regions by creating a clipping region and 
   * doing a single blit constrained to that clipping region.
   */
  if (pScreenInfo->dwClipUpdatesNBoxes == 0
      || dwBox < pScreenInfo->dwClipUpdatesNBoxes)
    {
      /* Loop through all boxes in the damaged region */
      while (dwBox--)
	{
	  /*
	   * Calculate x offset, y offset, width, and height for
	   * current damage box
	   */
	  x = pBox->x1;
	  y = pBox->y1;
	  w = pBox->x2 - pBox->x1;
	  h = pBox->y2 - pBox->y1;
	  
	  BitBlt (pScreenPriv->hdcScreen,
		  x, y,
		  w, h,
		  pScreenPriv->hdcShadow,
		  x, y,
		  SRCCOPY);
	  
	  /* Get a pointer to the next box */
	  ++pBox;
	}
    }
  else
    {
      BoxPtr		pBoxExtents = REGION_EXTENTS (pScreen, damage);

      /* Compute a GDI region from the damaged region */
      hrgnCombined = CreateRectRgn (pBox->x1, pBox->y1, pBox->x2, pBox->y2);
      dwBox--;
      pBox++;
      while (dwBox--)
	{
	  hrgnTemp = CreateRectRgn (pBox->x1, pBox->y1, pBox->x2, pBox->y2);
	  CombineRgn (hrgnCombined, hrgnCombined, hrgnTemp, RGN_OR);
	  DeleteObject (hrgnTemp);
	  pBox++;
	}
      
      /* Install the GDI region as a clipping region */
      SelectClipRgn (pScreenPriv->hdcScreen, hrgnCombined);
      DeleteObject (hrgnCombined);
      hrgnCombined = NULL;
      
      /*
       * Blit the shadow buffer to the screen,
       * constrained to the clipping region.
       */
d322 2
a323 3
	      pBoxExtents->x1, pBoxExtents->y1,
	      pBoxExtents->x2 - pBoxExtents->x1,
	      pBoxExtents->y2 - pBoxExtents->y1,
d325 1
a325 1
	      pBoxExtents->x1, pBoxExtents->y1,
d328 2
a329 2
      /* Reset the clip region */
      SelectClipRgn (pScreenPriv->hdcScreen, NULL);
a330 3

  /* Redraw all windows */
  if (pScreenInfo->fMultiWindow) EnumWindows(winRedrawAllProcShadowGDI, 0);
a332 1

a337 1

d346 1
a346 1
  ErrorF ("winCloseScreenShadowGDI - Freeing screen resources\n");
a375 3
  /* Destroy the thread startup mutex */
  pthread_mutex_destroy (&pScreenPriv->pmServerStarted);

d383 1
a383 1
  free ((pointer) pScreenPriv);
a387 9

/*
 * Tell mi what sort of visuals we need.
 * 
 * Generally we only need one visual, as our screen can only
 * handle one format at a time, I believe.  You may want
 * to verify that last sentence.
 */

d394 7
d402 1
a402 2
  ErrorF ("winInitVisualsShadowGDI - Masks %08x %08x %08x BPRGB %d d %d "
	  "bpp %d\n",
d407 1
a407 2
	  pScreenInfo->dwDepth,
	  pScreenInfo->dwBPP);
d412 1
a415 1
#if defined(XFree86Server)
d420 1
a420 1
				     -1,
d425 1
a425 2
	  ErrorF ("winInitVisualsShadowGDI - miSetVisualTypesAndMasks "
		  "failed\n");
a427 51

#if WIN_EMULATE_PSEUDO_SUPPORT
      if (!pScreenInfo->fEmulatePseudo)
	break;

      /* Setup a pseudocolor visual */
      if (!miSetVisualTypesAndMasks (8,
				     PseudoColorMask,
				     8,
				     -1,
				     0,
				     0,
				     0))
	{
	  ErrorF ("winInitVisualsShadowGDI - miSetVisualTypesAndMasks "
		  "failed for PseudoColor\n");
	  return FALSE;
	}
#endif
#else /* XFree86Server */
      /* Setup the real visual */
      if (!fbSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     TrueColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsShadowGDI - fbSetVisualTypesAndMasks "
		  "failed for TrueColor\n");
	  return FALSE;
	}

#if WIN_EMULATE_PSEUDO_SUPPORT
      if (!pScreenInfo->fEmulatePseudo)
	break;

      /* Setup a pseudocolor visual */
      if (!fbSetVisualTypesAndMasks (8,
				     PseudoColorMask,
				     8,
				     0,
				     0,
				     0))
	{
	  ErrorF ("winInitVisualsShadowGDI - fbSetVisualTypesAndMasks "
		  "failed for PseudoColor\n");
	  return FALSE;
	}
#endif
#endif /* XFree86Server */
a430 1
#if defined(XFree86Server)
d439 1
a439 14
	  ErrorF ("winInitVisualsShadowGDI - miSetVisualTypesAndMasks "
		  "failed\n");
	  return FALSE;
	}
#else /* XFree86Server */
      if (!fbSetVisualTypesAndMasks (pScreenInfo->dwDepth,
				     PseudoColorMask,
				     pScreenPriv->dwBitsPerRGB,
				     pScreenPriv->dwRedMask,
				     pScreenPriv->dwGreenMask,
				     pScreenPriv->dwBlueMask))
	{
	  ErrorF ("winInitVisualsShadowGDI - fbSetVisualTypesAndMasks "
		  "failed\n");
a441 1
#endif
d445 1
a445 1
      ErrorF ("winInitVisualsShadowGDI - Unknown screen depth\n");
d450 1
a450 1
  ErrorF ("winInitVisualsShadowGDI - Returning\n");
d456 1
a456 5

/*
 * Adjust the proposed video mode
 */

d463 1
a463 1
  DWORD			dwBPP;
d470 1
a470 1
      ErrorF ("winAdjustVideoModeShadowGDI - GetDC () failed\n");
d475 1
a475 1
  dwBPP = GetDeviceCaps (hdc, BITSPIXEL);
d478 1
a478 1
  if (pScreenInfo->dwBPP == WIN_DEFAULT_BPP)
d481 2
a482 2
      ErrorF ("winAdjustVideoModeShadowGDI - Using Windows display "
	      "depth of %d bits per pixel\n", dwBPP);
d485 1
a485 1
      pScreenInfo->dwBPP = dwBPP;
d487 1
a487 1
  else if (dwBPP != pScreenInfo->dwBPP)
d490 2
a491 2
      ErrorF ("winAdjustVideoModeShadowGDI - Command line bpp: %d, "\
	      "using bpp: %d\n", pScreenInfo->dwBPP, dwBPP);
d494 1
a494 1
      pScreenInfo->dwBPP = dwBPP;
d504 1
a504 5

/*
 * Blt exposed regions to the screen
 */

a536 3
  /* Redraw all windows */
  if (pScreenInfo->fMultiWindow) EnumWindows(winRedrawAllProcShadowGDI, 0);

a539 5

/*
 * Do any engine-specific appliation-activation processing
 */

d547 1
a547 1
  ErrorF ("winActivateAppShadowGDI\n");
d574 1
a574 1
  ErrorF ("winActivateAppShadowGDI - Returning\n");
a598 2
  /* Redraw all windows */
  if (pScreenInfo->fMultiWindow) EnumWindows(winRedrawAllProcShadowGDI, 0);
a601 5

/*
 * Realize the currently installed colormap
 */

d609 1
a609 1
  ErrorF ("winRealizeInstalledPaletteShadowGDI\n");
d616 1
a616 1
      ErrorF ("winRealizeInstalledPaletteShadowGDI - No colormap "
d627 1
a627 1
      ErrorF ("winRealizeInstalledPaletteShadowGDI - RealizePalette () "
d638 1
a638 1
      ErrorF ("winRealizeInstalledPaletteShadowGDI - SetDIBColorTable () "
d647 1
a647 4
/*
 * Install the specified colormap
 */

d663 1
a663 1
      ErrorF ("winInstallColormapShadowGDI - SelectPalette () failed\n");
d670 1
a670 1
      ErrorF ("winInstallColormapShadowGDI - RealizePalette () failed\n");
d680 1
a680 1
      ErrorF ("winInstallColormapShadowGDI - SetDIBColorTable () failed\n");
a694 3
  /* Redraw all windows */
  if (pScreenInfo->fMultiWindow) EnumWindows(winRedrawAllProcShadowGDI, 0);

d699 1
a699 4
/*
 * Store the specified colors in the specified colormap
 */

d716 1
a716 1
      ErrorF ("winStoreColorsShadowGDI - SetPaletteEntries () failed\n");
d729 1
a729 1
      ErrorF ("winInstallColormapShadowGDI - winInstallColormapShadowGDI "
d744 1
a744 1
      ErrorF ("winInstallColormapShadowGDI - SetDIBColorTable () failed\n");
d756 1
a756 4
/*
 * Colormap initialization procedure
 */

d773 1
a773 1
  lpPaletteNew = malloc (sizeof (LOGPALETTE)
d777 1
a777 1
      ErrorF ("winCreateColormapShadowGDI - Couldn't allocate palette "
d795 1
a795 1
      ErrorF ("winCreateColormapShadowGDI - CreatePalette () failed\n");
d804 1
a804 1
  free (lpPaletteNew);
d810 1
a810 4
/*
 * Colormap destruction procedure
 */

d828 1
a828 1
      ErrorF ("winDestroyColormapShadowGDI - Destroying default "
d849 1
a849 1
      ErrorF ("winDestroyColormap - DeleteObject () failed\n");
d860 1
a860 4
/*
 * Set engine specific funtions
 */

d887 1
a887 5
  pScreenPriv->pwinHotKeyAltTab = (winHotKeyAltTabProcPtr) (void (*)())NoopDDA;
  pScreenPriv->pwinCreatePrimarySurface
    = (winCreatePrimarySurfaceProcPtr) (void (*)())NoopDDA;
  pScreenPriv->pwinReleasePrimarySurface
    = (winReleasePrimarySurfaceProcPtr) (void (*)())NoopDDA;
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d30 1
a30 1
/* $XFree86: xc/programs/Xserver/hw/xwin/winshadgdi.c,v 1.23 2003/07/29 21:25:18 dawes Exp $ */
d219 1
a219 1
      if (strncmp (WINDOW_CLASS_X, strClassName, strlen (WINDOW_CLASS_X)) == 0)
a325 11
  /* Look for height weirdness */
  if (dibsection.dsBmih.biHeight < 0)
    {
      /* FIXME: Figure out why biHeight is sometimes negative */
      ErrorF ("winAllocateFBShadowGDI - WEIRDNESS - biHeight "
	      "still negative: %d\n"
	      "winAllocateFBShadowGDI - WEIRDNESS - Flipping biHeight sign\n",
	      dibsection.dsBmih.biHeight);
      dibsection.dsBmih.biHeight = -dibsection.dsBmih.biHeight;
    }

a516 11

  /* Delete tray icon, if we have one */
  if (!pScreenInfo->fNoTrayIcon)
    winDeleteNotifyIcon (pScreenPriv);

  /* Free the exit confirmation dialog box, if it exists */
  if (g_hDlgExit != NULL)
    {
      DestroyWindow (g_hDlgExit);
      g_hDlgExit = NULL;
    }
@


