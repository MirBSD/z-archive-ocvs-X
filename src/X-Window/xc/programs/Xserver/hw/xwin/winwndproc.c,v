head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.09.26;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.09.26;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.38.02;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.29.05;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.26.12;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Dakshinamurthy Karra
 *		Suhaib M Siddiqi
 *		Peter Busch
 *		Harold L Hunt II
 */
/* $XFree86: xc/programs/Xserver/hw/xwin/winwndproc.c,v 1.19 2001/11/21 08:51:24 alanh Exp $ */

#include "win.h"


/*
 * Called by winWakeupHandler
 * Processes current Windows message
 */

LRESULT CALLBACK
winWindowProc (HWND hwnd, UINT message, 
	       WPARAM wParam, LPARAM lParam)
{
  static winPrivScreenPtr	pScreenPriv = NULL;
  static winScreenInfo		*pScreenInfo = NULL;
  static ScreenPtr		pScreen = NULL;
  static HWND			hwndLastMouse = NULL;
  static unsigned long		ulServerGeneration = 0;
  winPrivScreenPtr		pScreenPrivLast;
  int				iScanCode;
  int				i;
  static HWND			hwndLastPrivates = NULL;

  /* Watch for server regeneration */
  if (g_ulServerGeneration != ulServerGeneration)
    {
      /*
       * Might as well declare that this window received 
       * the last mouse message
       */
      hwndLastMouse = hwnd;
      
      /* Store new server generation */
      ulServerGeneration = g_ulServerGeneration;
    }

  /* Only retrieve new privates pointers if window handle is null or changed */
  if ((pScreenPriv == NULL || hwnd != hwndLastPrivates)
      && (pScreenPriv = GetProp (hwnd, WIN_SCR_PROP)) != NULL)
    {
#if CYGDEGUG
      ErrorF ("winWindowProc () - Setting privates handle\n");
#endif
      pScreenInfo = pScreenPriv->pScreenInfo;
      pScreen = pScreenInfo->pScreen;
      hwndLastPrivates = hwnd;
    }
  else if (pScreenPriv == NULL)
    {
      /* For safety, handle case that should never happen */
      pScreenInfo = NULL;
      pScreen = NULL;
      hwndLastPrivates = NULL;
    }

  /* Branch on message type */
  switch (message)
    {
    case WM_CREATE:
#if CYGDEBUG
      ErrorF ("winWindowProc () - WM_CREATE\n");
#endif
      
      /*
       * Add a property to our display window that references
       * this screens' privates.
       *
       * This allows the window procedure to refer to the
       * appropriate window DC and shadow DC for the window that
       * it is processing.  We use this to repaint exposed
       * areas of our display window.
       */
      pScreenPriv = ((LPCREATESTRUCT) lParam)->lpCreateParams;
      pScreenInfo = pScreenPriv->pScreenInfo;
      pScreen = pScreenInfo->pScreen;
      hwndLastPrivates = hwnd;
      SetProp (hwnd, WIN_SCR_PROP, pScreenPriv);

      /* Store the mode key states so restore doesn't try to restore them */
      winStoreModeKeyStates (pScreen);
      return 0;

    case WM_PAINT:
#if CYGDEBUG
      ErrorF ("winWindowProc () - WM_PAINT\n");
#endif
      /* Only paint if we have privates and the server is enabled */
      if (pScreenPriv == NULL
	  || !pScreenPriv->fEnabled
	  || (pScreenInfo->fFullScreen && !pScreenPriv->fActive))
	{
	  /* We don't want to paint */
	  break;
	}

      /* Break out here if we don't have a valid paint routine */
      if (pScreenPriv->pwinBltExposedRegions == NULL)
	break;
      
      /* Call the engine dependent repainter */
      (*pScreenPriv->pwinBltExposedRegions) (pScreen);
      return 0;

    case WM_PALETTECHANGED:
      {
#if CYGDEBUG
	ErrorF ("winWindowProc () WM_PALETTECHANGED\n");
#endif
	/* Don't process if we don't have privates or a colormap */
	if (pScreenPriv == NULL || pScreenPriv->pcmapInstalled == NULL)
	  break;

	/* Return if we caused the palette to change */
	if ((HWND) wParam == hwnd)
	  {
	    /* Redraw the screen */
	    (*pScreenPriv->pwinRedrawScreen) (pScreen);
	    return 0;
	  }
	
	/* Reinstall the windows palette */
	(*pScreenPriv->pwinRealizeInstalledPalette) (pScreen);
	
	/* Redraw the screen */
	(*pScreenPriv->pwinRedrawScreen) (pScreen);
	return 0;
      }

    case WM_MOUSEMOVE:
      /* We can't do anything without privates */
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      
      /* Has the mouse pointer crossed screens? */
      if (pScreen != miPointerCurrentScreen ())
	miPointerSetNewScreen (pScreenInfo->dwScreen, 0, 0);

      /* Sometimes we hide, sometimes we show */
      if (hwndLastMouse != NULL && hwndLastMouse != hwnd)
	{
	  /* Cursor is now over NC area of another screen */
	  pScreenPrivLast = GetProp (hwndLastMouse, WIN_SCR_PROP);
	  if (pScreenPrivLast == NULL)
	    {
	      ErrorF ("winWindowProc () - WM_MOUSEMOVE - Couldn't obtain "
		      "last screen privates\n");
	      return 0;
	    }

	  /* Show cursor if last screen is still hiding it */
	  if (!pScreenPrivLast->fCursor)
	    {
	      pScreenPrivLast->fCursor = TRUE;
	      ShowCursor (TRUE);
	    }

	  /* Hide cursor for our screen if we are not hiding it */
	  if (pScreenPriv->fCursor)
	    {
	      pScreenPriv->fCursor = FALSE;
	      ShowCursor (FALSE);
	    }
	}
      else if (pScreenPriv->fActive
	  && pScreenPriv->fCursor)
	{
	  /* Hide Windows cursor */
	  pScreenPriv->fCursor = FALSE;
	  ShowCursor (FALSE);
	}
      else if (!pScreenPriv->fActive
	       && !pScreenPriv->fCursor)
	{
	  /* Show Windows cursor */
	  pScreenPriv->fCursor = TRUE;
	  ShowCursor (TRUE);
	}

      /* Deliver absolute cursor position to X Server */
      miPointerAbsoluteCursor (GET_X_LPARAM(lParam),
			       GET_Y_LPARAM(lParam),
			       g_c32LastInputEventTime = GetTickCount ());

      /* Store pointer to last window handle */
      hwndLastMouse = hwnd;
      return 0;

    case WM_NCMOUSEMOVE:
      /* We can't do anything without privates */
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;

      /* Non-client mouse movement, show Windows cursor */
      if (hwndLastMouse != NULL && hwndLastMouse != hwnd)
	{
	  /* Cursor is now over NC area of another screen */
	  pScreenPrivLast = GetProp (hwndLastMouse, WIN_SCR_PROP);
	  if (pScreenPrivLast == NULL)
	    {
	      ErrorF ("winWindowProc () - WM_NCMOUSEMOVE - Couldn't obtain "
		      "last screen privates\n");
	      return 0;
	    }

	  /* Show cursor if last screen is still hiding it */
	  if (!pScreenPrivLast->fCursor)
	    {
	      pScreenPrivLast->fCursor = TRUE;
	      ShowCursor (TRUE);
	    }

	  /* Hide cursor for our screen if we are not hiding it */
	  if (pScreenPriv->fCursor)
	    {
	      pScreenPriv->fCursor = FALSE;
	      ShowCursor (FALSE);
	    }
	}
      else if (!pScreenPriv->fCursor)
	{
	  pScreenPriv->fCursor = TRUE;
	  ShowCursor (TRUE);
	}

      /* Store pointer to last window handle */
      hwndLastMouse = hwnd;
      return 0;

    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      return winMouseButtonsHandle (pScreen, ButtonPress, Button1, wParam);
      
    case WM_LBUTTONUP:
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      return winMouseButtonsHandle (pScreen, ButtonRelease, Button1, wParam);

    case WM_MBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      return winMouseButtonsHandle (pScreen, ButtonPress, Button2, wParam);
      
    case WM_MBUTTONUP:
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      return winMouseButtonsHandle (pScreen, ButtonRelease, Button2, wParam);
      
    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      return winMouseButtonsHandle (pScreen, ButtonPress, Button3, wParam);
      
    case WM_RBUTTONUP:
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      return winMouseButtonsHandle (pScreen, ButtonRelease, Button3, wParam);

    case WM_TIMER:
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;

      /* Branch on the timer id */
      switch (wParam)
	{
	case WIN_E3B_TIMER_ID:
	  /* Send delayed button press */
	  winMouseButtonsSendEvent (ButtonPress,
				    pScreenPriv->iE3BCachedPress);

	  /* Kill this timer */
	  KillTimer (pScreenPriv->hwndScreen, WIN_E3B_TIMER_ID);

	  /* Clear screen privates flags */
	  pScreenPriv->iE3BCachedPress = 0;
	  break;
	}
      return 0;

    case WM_MOUSEWHEEL:
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;
      return winMouseWheel (pScreen, GET_WHEEL_DELTA_WPARAM(wParam));

    case WM_SETFOCUS:
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;

      /* Restore the state of all mode keys */
      winRestoreModeKeyStates (pScreen);
      return 0;

    case WM_KILLFOCUS:
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;

      /* Store the state of all mode keys */
      winStoreModeKeyStates (pScreen);

      /* Release any pressed modifiers */
      winKeybdReleaseModifierKeys ();
      return 0;

    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;

      /*
       * FIXME: Catching Alt-F4 like this is really terrible.  This should
       * be generalized to handle other Windows keyboard signals.  Actually,
       * the list keys to catch and the actions to perform when caught should
       * be configurable; that way user's can customize the keys that they
       * need to have passed through to their window manager or apps, or they
       * can remap certain actions to new key codes that do not conflict
       * with the X apps that they are using.  Yeah, that'll take awhile.
       */
      if ((pScreenInfo->fUseWinKillKey && wParam == VK_F4
	   && (GetKeyState (VK_MENU) & 0x8000))
	  || (pScreenInfo->fUseUnixKillKey && wParam == VK_BACK
	      && (GetKeyState (VK_MENU) & 0x8000)
	      && (GetKeyState (VK_CONTROL) & 0x8000))) 
	{
	  /*
	   * Better leave this message here, just in case some unsuspecting
	   * user enters Alt + F4 and is surprised when the application
	   * quits.
	   */
	  ErrorF ("winWindowProc () - Closekey hit, quitting\n");
	  
	  /* Tell our message queue to give up */
	  PostMessage (hwnd, WM_CLOSE, 0, 0);
	  return 0;
	}
      
      /*
       * Don't do anything for the Windows keys, as focus will soon
       * be returned to Windows.  We may be able to trap the Windows keys,
       * but we should determine if that is desirable before doing so.
       */
      if (wParam == VK_LWIN || wParam == VK_RWIN)
	break;

      /* Discard fake Ctrl_L presses that precede AltGR on non-US keyboards */
      if (winIsFakeCtrl_L (message, wParam, lParam))
	return 0;
      
      /* Send the key event(s) */
      winTranslateKey (wParam, lParam, &iScanCode);
      for (i = 0; i < LOWORD(lParam); ++i)
	winSendKeyEvent (iScanCode, TRUE);
      return 0;

    case WM_SYSKEYUP:
    case WM_KEYUP:
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;

      /*
       * Don't do anything for the Windows keys, as focus will soon
       * be returned to Windows.  We may be able to trap the Windows keys,
       * but we should determine if that is desirable before doing so.
       */
      if (wParam == VK_LWIN || wParam == VK_RWIN)
	break;

      /* Ignore the fake Ctrl_L that follows an AltGr release */
      if (winIsFakeCtrl_L (message, wParam, lParam))
	return 0;

      /* Enqueue a keyup event */
      winTranslateKey (wParam, lParam, &iScanCode);
      winSendKeyEvent (iScanCode, FALSE);
      return 0;

    case WM_HOTKEY:
      if (pScreenPriv == NULL)
	break;

      /* Call the engine-specific hot key handler */
      (*pScreenPriv->pwinHotKeyAltTab) (pScreen);
      return 0;

    case WM_ACTIVATE:
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;

#if CYGDEBUG
      ErrorF ("winWindowProc () - WM_ACTIVATE\n");
#endif
      /*
       * Focus is being changed to another window.
       * The other window may or may not belong to
       * our process.
       */

      /* Clear any lingering wheel delta */
      pScreenPriv->iDeltaZ = 0;

      /* Have we changed X screens? */
      if ((LOWORD (wParam) == WA_ACTIVE || LOWORD (wParam) == WA_CLICKACTIVE)
	  && pScreenPriv->fEnabled && pScreen != miPointerCurrentScreen ())
	miPointerSetNewScreen (pScreenInfo->dwScreen, 0, 0);

      /* Handle showing or hiding the mouse */
      if (hwndLastMouse != NULL && hwndLastMouse != hwnd)
	{
	  /*
	   * Activation has transferred between screens.
	   * This section is processed by the screen receiving
	   * focus, as it is the only one that notices the difference
	   * between hwndLastMouse and hwnd.
	   */
	  pScreenPrivLast = GetProp (hwndLastMouse, WIN_SCR_PROP);
	  if (pScreenPrivLast == NULL)
	    {
	      ErrorF ("winWindowProc () - WM_ACTIVATE - Couldn't obtain last "
		      "screen privates\n");
	      return 0;
	    }

	  /* Show cursor if last screen is still hiding it */
	  if (!pScreenPrivLast->fCursor)
	    {
	      pScreenPrivLast->fCursor = TRUE;
	      ShowCursor (TRUE);
	    }

	  /* Hide cursor for our screen if we are not hiding it */
	  if (pScreenPriv->fCursor)
	    {
	      pScreenPriv->fCursor = FALSE;
	      ShowCursor (FALSE);
	    }
	}
      else if ((LOWORD(wParam) == WA_ACTIVE
		|| LOWORD(wParam) == WA_CLICKACTIVE)
	       && pScreenPriv->fCursor)
	{
	  pScreenPriv->fCursor = FALSE;
	  ShowCursor (FALSE);
	}
      else if (LOWORD(wParam) == WA_INACTIVE
	       && !pScreenPriv->fCursor)
	{
	  pScreenPriv->fCursor = TRUE;
	  ShowCursor (TRUE);
	}

      /* Store last active window handle */
      hwndLastMouse = hwnd;
      return 0;

    case WM_ACTIVATEAPP:
      if (pScreenPriv == NULL || pScreenInfo->fIgnoreInput)
	break;

#if CYGDEBUG
      ErrorF ("winWindowProc () - WM_ACTIVATEAPP\n");
#endif
      /* Activate or deactivate */
      pScreenPriv->fActive = wParam;

      /* Are we activating or deactivating? */
      if (pScreenPriv->fActive
	  && pScreenPriv->fCursor)
	{
	  pScreenPriv->fCursor = FALSE;
	  ShowCursor (FALSE);
	}
      else if (!pScreenPriv->fActive
	       && !pScreenPriv->fCursor)
	{
	  pScreenPriv->fCursor = TRUE;
	  ShowCursor (TRUE);
	}

      /* Call engine specific screen activation/deactivation function */
      (*pScreenPriv->pwinActivateApp) (pScreen);
      return 0;

    case WM_CLOSE:
      /* Tell X that we are giving up */
      GiveUp (0);
      return 0;
    }

  return DefWindowProc (hwnd, message, wParam, lParam);
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@a31 1
 *		MATSUZAKI Kensuke
d33 1
a33 1
/* $XFree86: xc/programs/Xserver/hw/xwin/winwndproc.c,v 1.26 2003/10/02 13:30:11 eich Exp $ */
a35 9
#include <commctrl.h>
#include "winprefs.h"

/*
 * Global variables
 */

Bool			g_fCursor = TRUE;

d47 6
a52 7
  static winPrivScreenPtr	s_pScreenPriv = NULL;
  static winScreenInfo		*s_pScreenInfo = NULL;
  static ScreenPtr		s_pScreen = NULL;
  static HWND			s_hwndLastPrivates = NULL;
  static HINSTANCE		s_hInstance;
  static Bool			s_fTracking = FALSE;
  static unsigned long		s_ulServerGeneration = 0;
d55 1
d58 1
a58 1
  if (g_ulServerGeneration != s_ulServerGeneration)
d60 6
d67 1
a67 1
      s_ulServerGeneration = g_ulServerGeneration;
d71 2
a72 2
  if ((s_pScreenPriv == NULL || hwnd != s_hwndLastPrivates)
      && (s_pScreenPriv = GetProp (hwnd, WIN_SCR_PROP)) != NULL)
d74 2
a75 2
#if CYGDEBUG
      ErrorF ("winWindowProc - Setting privates handle\n");
d77 3
a79 3
      s_pScreenInfo = s_pScreenPriv->pScreenInfo;
      s_pScreen = s_pScreenInfo->pScreen;
      s_hwndLastPrivates = hwnd;
d81 1
a81 1
  else if (s_pScreenPriv == NULL)
d84 3
a86 3
      s_pScreenInfo = NULL;
      s_pScreen = NULL;
      s_hwndLastPrivates = NULL;
a91 4
    case WM_TRAYICON:
      return winHandleIconMessage (hwnd, message, wParam, lParam,
				   s_pScreenPriv);

d94 1
a94 1
      ErrorF ("winWindowProc - WM_CREATE\n");
d106 5
a110 6
      s_pScreenPriv = ((LPCREATESTRUCT) lParam)->lpCreateParams;
      s_hInstance = ((LPCREATESTRUCT) lParam)->hInstance;
      s_pScreenInfo = s_pScreenPriv->pScreenInfo;
      s_pScreen = s_pScreenInfo->pScreen;
      s_hwndLastPrivates = hwnd;
      SetProp (hwnd, WIN_SCR_PROP, s_pScreenPriv);
d113 1
a113 18
      winStoreModeKeyStates (s_pScreen);

      /* Setup tray icon */
      if (!s_pScreenInfo->fNoTrayIcon)
	{
	  /*
	   * NOTE: The WM_CREATE message is processed before CreateWindowEx
	   * returns, so s_pScreenPriv->hwndScreen is invalid at this point.
	   * We go ahead and copy our hwnd parameter over top of the screen
	   * privates hwndScreen so that we have a valid value for
	   * that member.  Otherwise, the tray icon will disappear
	   * the first time you move the mouse over top of it.
	   */
	  
	  s_pScreenPriv->hwndScreen = hwnd;

	  winInitNotifyIcon (s_pScreenPriv);
	}
a115 464
    case WM_DISPLAYCHANGE:
      /* We cannot handle a display mode change during initialization */
      if (s_pScreenInfo == NULL)
	FatalError ("winWindowProc - WM_DISPLAYCHANGE - The display "
		    "mode changed while we were intializing.  This is "
		    "very bad and unexpected.  Exiting.\n");

      /*
       * We do not care about display changes with
       * fullscreen DirectDraw engines, because those engines set
       * their own mode when they become active.
       */
      if (s_pScreenInfo->fFullScreen
	  && (s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DD
	      || s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL
	      || s_pScreenInfo->dwEngine == WIN_SERVER_PRIMARY_DD))
	{
	  /* 
	   * Store the new display dimensions and depth.
	   * We do this here for future compatibility in case we
	   * ever allow switching from fullscreen to windowed mode.
	   */
	  s_pScreenPriv->dwLastWindowsWidth = GetSystemMetrics (SM_CXSCREEN);
	  s_pScreenPriv->dwLastWindowsHeight = GetSystemMetrics (SM_CYSCREEN);
	  s_pScreenPriv->dwLastWindowsBitsPixel
	    = GetDeviceCaps (s_pScreenPriv->hdcScreen, BITSPIXEL);	  
	  break;
	}
      
      ErrorF ("winWindowProc - WM_DISPLAYCHANGE - orig bpp: %d, last bpp: %d, "
	      "new bpp: %d\n",
	      s_pScreenInfo->dwBPP,
	      s_pScreenPriv->dwLastWindowsBitsPixel,
	      wParam);

      ErrorF ("winWindowProc - WM_DISPLAYCHANGE - new width: %d "
	      "new height: %d\n",
	      LOWORD (lParam), HIWORD (lParam));

      /*
       * TrueColor --> TrueColor depth changes are disruptive for:
       *	Windowed:
       *		Shadow DirectDraw
       *		Shadow DirectDraw Non-Locking
       *		Primary DirectDraw
       *
       * TrueColor --> TrueColor depth changes are non-optimal for:
       *	Windowed:
       *		Shadow GDI
       *
       *	FullScreen:
       *		Shadow GDI
       *
       * TrueColor --> PseudoColor or vice versa are disruptive for:
       *	Windowed:
       *		Shadow DirectDraw
       *		Shadow DirectDraw Non-Locking
       *		Primary DirectDraw
       *		Shadow GDI
       */

      /*
       * Check for a disruptive change in depth.
       * We can only display a message for a disruptive depth change,
       * we cannot do anything to correct the situation.
       */
      if ((s_pScreenInfo->dwBPP != wParam)
	  && (s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DD
	      || s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL
	      || s_pScreenInfo->dwEngine == WIN_SERVER_PRIMARY_DD))
	{
	  /* Cannot display the visual until the depth is restored */
	  ErrorF ("winWindowProc - Disruptive change in depth\n");

	  /* Display Exit dialog */
	  winDisplayDepthChangeDialog (s_pScreenPriv);

	  /* Flag that we have an invalid screen depth */
	  s_pScreenPriv->fBadDepth = TRUE;

	  /* Minimize the display window */
	  ShowWindow (hwnd, SW_MINIMIZE);
	}
      else
	{
	  /* Flag that we have a valid screen depth */
	  s_pScreenPriv->fBadDepth = FALSE;
	}
      
      /*
       * Check for a change in display dimensions.
       * We can simply recreate the same-sized primary surface when
       * the display dimensions change.
       */
      if (s_pScreenPriv->dwLastWindowsWidth != LOWORD (lParam)
	  || s_pScreenPriv->dwLastWindowsHeight != HIWORD (lParam))
	{
	  /*
	   * NOTE: The non-DirectDraw engines set the ReleasePrimarySurface
	   * and CreatePrimarySurface function pointers to point
	   * to the no operation function, NoopDDA.  This allows us
	   * to blindly call these functions, even if they are not
	   * relevant to the current engine (e.g., Shadow GDI).
	   */

#if CYGDEBUG
	  ErrorF ("winWindowProc - WM_DISPLAYCHANGE - Dimensions changed\n");
#endif
	  
	  /* Release the old primary surface */
	  (*s_pScreenPriv->pwinReleasePrimarySurface) (s_pScreen);

#if CYGDEBUG
	  ErrorF ("winWindowProc - WM_DISPLAYCHANGE - Released "
		  "primary surface\n");
#endif

	  /* Create the new primary surface */
	  (*s_pScreenPriv->pwinCreatePrimarySurface) (s_pScreen);

#if CYGDEBUG
	  ErrorF ("winWindowProc - WM_DISPLAYCHANGE - Recreated "
		  "primary surface\n");
#endif
	}
      else
	{
#if CYGDEBUG
	  ErrorF ("winWindowProc - WM_DISPLAYCHANGE - Dimensions did not "
		  "change\n");
#endif
	}

      /* Store the new display dimensions and depth */
      s_pScreenPriv->dwLastWindowsWidth = GetSystemMetrics (SM_CXSCREEN);
      s_pScreenPriv->dwLastWindowsHeight = GetSystemMetrics (SM_CYSCREEN);
      s_pScreenPriv->dwLastWindowsBitsPixel
	= GetDeviceCaps (s_pScreenPriv->hdcScreen, BITSPIXEL);
      break;

    case WM_SIZE:
      {
	SCROLLINFO		si;
	RECT			rcWindow;
	int			iWidth, iHeight;

#if CYGDEBUG
	ErrorF ("winWindowProc - WM_SIZE\n");
#endif

	/* Break if we do not use scrollbars */
	if (!s_pScreenInfo->fScrollbars
	    || !s_pScreenInfo->fDecoration
	    || s_pScreenInfo->fRootless
	    || s_pScreenInfo->fMultiWindow
	    || s_pScreenInfo->fFullScreen)
	  break;

	/* No need to resize if we get minimized */
	if (wParam == SIZE_MINIMIZED)
	  return 0;

	/*
	 * Get the size of the whole window, including client area,
	 * scrollbars, and non-client area decorations (caption, borders).
	 * We do this because we need to check if the client area
	 * without scrollbars is large enough to display the whole visual.
	 * The new client area size passed by lParam already subtracts
	 * the size of the scrollbars if they are currently displayed.
	 * So checking is LOWORD(lParam) == visual_width and
	 * HIWORD(lParam) == visual_height will never tell us to hide
	 * the scrollbars because the client area would always be too small.
	 * GetClientRect returns the same sizes given by lParam, so we
	 * cannot use GetClientRect either.
	 */
	GetWindowRect (hwnd, &rcWindow);
	iWidth = rcWindow.right - rcWindow.left;
	iHeight = rcWindow.bottom - rcWindow.top;

	ErrorF ("winWindowProc - WM_SIZE - window w: %d h: %d, "
		"new client area w: %d h: %d\n",
		iWidth, iHeight, LOWORD (lParam), HIWORD (lParam));

	/* Subtract the frame size from the window size. */
	iWidth -= 2 * GetSystemMetrics (SM_CXSIZEFRAME);
	iHeight -= (2 * GetSystemMetrics (SM_CYSIZEFRAME)
		    + GetSystemMetrics (SM_CYCAPTION));

	/*
	 * Update scrollbar page sizes.
	 * NOTE: If page size == range, then the scrollbar is
	 * automatically hidden.
	 */

	/* Is the naked client area large enough to show the whole visual? */
	if (iWidth < s_pScreenInfo->dwWidth
	    || iHeight < s_pScreenInfo->dwHeight)
	  {
	    /* Client area too small to display visual, use scrollbars */
	    iWidth -= GetSystemMetrics (SM_CXVSCROLL);
	    iHeight -= GetSystemMetrics (SM_CYHSCROLL);
	  }
	
	/* Set the horizontal scrollbar page size */
	si.cbSize = sizeof (si);
	si.fMask = SIF_PAGE | SIF_RANGE;
	si.nMin = 0;
	si.nMax = s_pScreenInfo->dwWidth - 1;
	si.nPage = iWidth;
	SetScrollInfo (hwnd, SB_HORZ, &si, TRUE);
	
	/* Set the vertical scrollbar page size */
	si.cbSize = sizeof (si);
	si.fMask = SIF_PAGE | SIF_RANGE;
	si.nMin = 0;
	si.nMax = s_pScreenInfo->dwHeight - 1;
	si.nPage = iHeight;
	SetScrollInfo (hwnd, SB_VERT, &si, TRUE);

	/*
	 * NOTE: Scrollbars may have moved if they were at the 
	 * far right/bottom, so we query their current position.
	 */
	
	/* Get the horizontal scrollbar position and set the offset */
	si.cbSize = sizeof (si);
	si.fMask = SIF_POS;
	GetScrollInfo (hwnd, SB_HORZ, &si);
	s_pScreenInfo->dwXOffset = -si.nPos;
	
	/* Get the vertical scrollbar position and set the offset */
	si.cbSize = sizeof (si);
	si.fMask = SIF_POS;
	GetScrollInfo (hwnd, SB_VERT, &si);
	s_pScreenInfo->dwYOffset = -si.nPos;
      }
      return 0;

    case WM_VSCROLL:
      {
	SCROLLINFO		si;
	int			iVertPos;

#if CYGDEBUG
	ErrorF ("winWindowProc - WM_VSCROLL\n");
#endif
      
	/* Get vertical scroll bar info */
	si.cbSize = sizeof (si);
	si.fMask = SIF_ALL;
	GetScrollInfo (hwnd, SB_VERT, &si);

	/* Save the vertical position for comparison later */
	iVertPos = si.nPos;

	/*
	 * Don't forget:
	 * moving the scrollbar to the DOWN, scroll the content UP
	 */
	switch (LOWORD(wParam))
	  {
	  case SB_TOP:
	    si.nPos = si.nMin;
	    break;
	  
	  case SB_BOTTOM:
	    si.nPos = si.nMax - si.nPage + 1;
	    break;

	  case SB_LINEUP:
	    si.nPos -= 1;
	    break;
	  
	  case SB_LINEDOWN:
	    si.nPos += 1;
	    break;
	  
	  case SB_PAGEUP:
	    si.nPos -= si.nPage;
	    break;
	  
	  case SB_PAGEDOWN:
	    si.nPos += si.nPage;
	    break;

	  case SB_THUMBTRACK:
	    si.nPos = si.nTrackPos;
	    break;

	  default:
	    break;
	  }

	/*
	 * We retrieve the position after setting it,
	 * because Windows may adjust it.
	 */
	si.fMask = SIF_POS;
	SetScrollInfo (hwnd, SB_VERT, &si, TRUE);
	GetScrollInfo (hwnd, SB_VERT, &si);
      
	/* Scroll the window if the position has changed */
	if (si.nPos != iVertPos)
	  {
	    /* Save the new offset for bit block transfers, etc. */
	    s_pScreenInfo->dwYOffset = -si.nPos;

	    /* Change displayed region in the window */
	    ScrollWindowEx (hwnd,
			    0,
			    iVertPos - si.nPos,
			    NULL,
			    NULL,
			    NULL,
			    NULL,
			    SW_INVALIDATE);
	  
	    /* Redraw the window contents */
	    UpdateWindow (hwnd);
	  }
      }
      return 0;

    case WM_HSCROLL:
      {
	SCROLLINFO		si;
	int			iHorzPos;

#if CYGDEBUG
	ErrorF ("winWindowProc - WM_HSCROLL\n");
#endif
      
	/* Get horizontal scroll bar info */
	si.cbSize = sizeof (si);
	si.fMask = SIF_ALL;
	GetScrollInfo (hwnd, SB_HORZ, &si);

	/* Save the horizontal position for comparison later */
	iHorzPos = si.nPos;

	/*
	 * Don't forget:
	 * moving the scrollbar to the RIGHT, scroll the content LEFT
	 */
	switch (LOWORD(wParam))
	  {
	  case SB_LEFT:
	    si.nPos = si.nMin;
	    break;
	  
	  case SB_RIGHT:
	    si.nPos = si.nMax - si.nPage + 1;
	    break;

	  case SB_LINELEFT:
	    si.nPos -= 1;
	    break;
	  
	  case SB_LINERIGHT:
	    si.nPos += 1;
	    break;
	  
	  case SB_PAGELEFT:
	    si.nPos -= si.nPage;
	    break;
	  
	  case SB_PAGERIGHT:
	    si.nPos += si.nPage;
	    break;

	  case SB_THUMBTRACK:
	    si.nPos = si.nTrackPos;
	    break;

	  default:
	    break;
	  }

	/*
	 * We retrieve the position after setting it,
	 * because Windows may adjust it.
	 */
	si.fMask = SIF_POS;
	SetScrollInfo (hwnd, SB_HORZ, &si, TRUE);
	GetScrollInfo (hwnd, SB_HORZ, &si);
      
	/* Scroll the window if the position has changed */
	if (si.nPos != iHorzPos)
	  {
	    /* Save the new offset for bit block transfers, etc. */
	    s_pScreenInfo->dwXOffset = -si.nPos;

	    /* Change displayed region in the window */
	    ScrollWindowEx (hwnd,
			    iHorzPos - si.nPos,
			    0,
			    NULL,
			    NULL,
			    NULL,
			    NULL,
			    SW_INVALIDATE);
	  
	    /* Redraw the window contents */
	    UpdateWindow (hwnd);
	  }
      }
      return 0;

    case WM_GETMINMAXINFO:
      {
	MINMAXINFO		*pMinMaxInfo = (MINMAXINFO *) lParam;
	int			iCaptionHeight;
	int			iBorderHeight, iBorderWidth;

#if CYGDEBUG	
	ErrorF ("winWindowProc - WM_GETMINMAXINFO - pScreenInfo: %08x\n",
		s_pScreenInfo);
#endif

	/* Can't do anything without screen info */
	if (s_pScreenInfo == NULL
	    || !s_pScreenInfo->fScrollbars
	    || s_pScreenInfo->fFullScreen
	    || !s_pScreenInfo->fDecoration
	    || s_pScreenInfo->fRootless
	    || s_pScreenInfo->fMultiWindow)
	  break;

	/*
	 * Here we can override the maximum tracking size, which
	 * is the largest size that can be assigned to our window
	 * via the sizing border.
	 */

	/*
	 * FIXME: Do we only need to do this once, since our visual size
	 * does not change?  Does Windows store this value statically
	 * once we have set it once?
	 */

	/* Get the border and caption sizes */
	iCaptionHeight = GetSystemMetrics (SM_CYCAPTION);
	iBorderWidth = 2 * GetSystemMetrics (SM_CXSIZEFRAME);
	iBorderHeight = 2 * GetSystemMetrics (SM_CYSIZEFRAME);
	
	/* Allow the full visual to be displayed */
	pMinMaxInfo->ptMaxTrackSize.x
	  = s_pScreenInfo->dwWidth + iBorderWidth;
	pMinMaxInfo->ptMaxTrackSize.y
	  = s_pScreenInfo->dwHeight + iBorderHeight + iCaptionHeight;
      }
      return 0;

    case WM_ERASEBKGND:
#if CYGDEBUG
      ErrorF ("winWindowProc - WM_ERASEBKGND\n");
#endif
      /*
       * Pretend that we did erase the background but we don't care,
       * the application uses the full window estate. This avoids some
       * flickering when resizing.
       */
      return TRUE;

d118 1
a118 1
      ErrorF ("winWindowProc - WM_PAINT\n");
d121 3
a123 4
      if (s_pScreenPriv == NULL
	  || !s_pScreenPriv->fEnabled
	  || (s_pScreenInfo->fFullScreen && !s_pScreenPriv->fActive)
	  || s_pScreenPriv->fBadDepth)
d130 1
a130 1
      if (s_pScreenPriv->pwinBltExposedRegions == NULL)
d134 1
a134 1
      (*s_pScreenPriv->pwinBltExposedRegions) (s_pScreen);
d140 1
a140 1
	ErrorF ("winWindowProc - WM_PALETTECHANGED\n");
d142 2
a143 7
	/*
	 * Don't process if we don't have privates or a colormap,
	 * or if we have an invalid depth.
	 */
	if (s_pScreenPriv == NULL
	    || s_pScreenPriv->pcmapInstalled == NULL
	    || s_pScreenPriv->fBadDepth)
d150 1
a150 1
	    (*s_pScreenPriv->pwinRedrawScreen) (s_pScreen);
d155 1
a155 1
	(*s_pScreenPriv->pwinRealizeInstalledPalette) (s_pScreen);
d158 1
a158 1
	(*s_pScreenPriv->pwinRedrawScreen) (s_pScreen);
d164 1
a164 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d166 1
a166 1

d168 2
a169 4
      if (s_pScreen != miPointerCurrentScreen ())
	miPointerSetNewScreen (s_pScreenInfo->dwScreen,
			       GET_X_LPARAM(lParam)-s_pScreenInfo->dwXOffset,
			       GET_Y_LPARAM(lParam)-s_pScreenInfo->dwYOffset);
d171 2
a172 2
      /* Are we tracking yet? */
      if (!s_fTracking)
d174 15
a188 11
	  TRACKMOUSEEVENT		tme;
	  
	  /* Setup data structure */
	  ZeroMemory (&tme, sizeof (tme));
	  tme.cbSize = sizeof (tme);
	  tme.dwFlags = TME_LEAVE;
	  tme.hwndTrack = hwnd;

	  /* Call the tracking function */
	  if (!(*g_fpTrackMouseEvent) (&tme))
	    ErrorF ("winWindowProc - _TrackMouseEvent failed\n");
d190 6
a195 2
	  /* Flag that we are tracking now */
	  s_fTracking = TRUE;
d197 2
a198 3

      /* Hide or show the Windows mouse cursor */
      if (g_fCursor && (s_pScreenPriv->fActive || s_pScreenInfo->fLessPointer))
d201 1
a201 1
	  g_fCursor = FALSE;
d204 2
a205 2
      else if (!g_fCursor && !s_pScreenPriv->fActive
	       && !s_pScreenInfo->fLessPointer)
d208 1
a208 1
	  g_fCursor = TRUE;
d211 1
a211 1
      
d213 2
a214 2
      miPointerAbsoluteCursor (GET_X_LPARAM(lParam)-s_pScreenInfo->dwXOffset,
			       GET_Y_LPARAM(lParam)-s_pScreenInfo->dwYOffset,
d216 3
a221 9
      /*
       * We break instead of returning 0 since we need to call
       * DefWindowProc to get the mouse cursor changes
       * and min/max/close button highlighting in Windows XP.
       * The Platform SDK says that you should return 0 if you
       * process this message, but it fails to mention that you
       * will give up any default functionality if you do return 0.
       */
      
d223 1
a223 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d225 1
a225 1
      
d227 1
a227 1
      if (!g_fCursor)
d229 8
a236 4
	  g_fCursor = TRUE;
	  ShowCursor (TRUE);
	}
      break;
d238 6
a243 2
    case WM_MOUSELEAVE:
      /* Mouse has left our client area */
d245 8
a252 5
      /* Flag that we are no longer tracking */
      s_fTracking = FALSE;

      /* Show the mouse cursor, if necessary */
      if (!g_fCursor)
d254 1
a254 1
	  g_fCursor = TRUE;
d257 3
d264 1
a264 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d266 1
a266 2
      if (s_pScreenInfo->fRootless) SetCapture (hwnd);
      return winMouseButtonsHandle (s_pScreen, ButtonPress, Button1, wParam);
d269 1
a269 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d271 1
a271 2
      if (s_pScreenInfo->fRootless) ReleaseCapture ();
      return winMouseButtonsHandle (s_pScreen, ButtonRelease, Button1, wParam);
d275 1
a275 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d277 1
a277 2
      if (s_pScreenInfo->fRootless) SetCapture (hwnd);
      return winMouseButtonsHandle (s_pScreen, ButtonPress, Button2, wParam);
d280 1
a280 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d282 1
a282 2
      if (s_pScreenInfo->fRootless) ReleaseCapture ();
      return winMouseButtonsHandle (s_pScreen, ButtonRelease, Button2, wParam);
d286 1
a286 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d288 1
a288 2
      if (s_pScreenInfo->fRootless) SetCapture (hwnd);
      return winMouseButtonsHandle (s_pScreen, ButtonPress, Button3, wParam);
d291 1
a291 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d293 1
a293 2
      if (s_pScreenInfo->fRootless) ReleaseCapture ();
      return winMouseButtonsHandle (s_pScreen, ButtonRelease, Button3, wParam);
d296 1
a296 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d305 1
a305 1
				    s_pScreenPriv->iE3BCachedPress);
d308 1
a308 1
	  KillTimer (s_pScreenPriv->hwndScreen, WIN_E3B_TIMER_ID);
d311 1
a311 1
	  s_pScreenPriv->iE3BCachedPress = 0;
a312 16

	case WIN_POLLING_MOUSE_TIMER_ID:
	  {
	    POINT		point;
	    
	    /* Get the current position of the mouse cursor */
	    GetCursorPos (&point);
	    
	    /* Map from screen (-X, -Y) to root (0, 0) */
	    point.x -= GetSystemMetrics (SM_XVIRTUALSCREEN);
	    point.y -= GetSystemMetrics (SM_YVIRTUALSCREEN);
	    
	    /* Deliver absolute cursor position to X Server */
	    miPointerAbsoluteCursor (point.x, point.y,
				     g_c32LastInputEventTime = GetTickCount());
	  }
a315 5
    case WM_CTLCOLORSCROLLBAR:
      FatalError ("winWindowProc - WM_CTLCOLORSCROLLBAR - We are not "
		  "supposed to get this message.  Exiting.\n");
      return 0;

d317 1
a317 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d319 1
a319 5
#if CYGDEBUG
      ErrorF ("winWindowProc - WM_MOUSEWHEEL\n");
#endif
      winMouseWheel (s_pScreen, GET_WHEEL_DELTA_WPARAM(wParam));
      break;
d322 1
a322 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d326 1
a326 1
      winRestoreModeKeyStates (s_pScreen);
d330 1
a330 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d334 1
a334 5
      winStoreModeKeyStates (s_pScreen);

      /* Release any pressed keys */
      winKeybdReleaseKeys ();
      return 0;
d336 2
a337 13
#if WIN_NEW_KEYBOARD_SUPPORT
    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
    case WM_SYSKEYUP:
    case WM_KEYUP:
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;

      /* Don't process keys if we are not active */
      if (!s_pScreenPriv->fActive)
	return 0;

      winProcessKeyEvent ((DWORD)wParam, (DWORD) lParam);
a339 5
    case WM_DEADCHAR:
    case WM_SYSDEADCHAR:
      return 0;

#else /* WIN_NEW_KEYBOARD_SUPPORT */
d342 1
a342 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d354 1
a354 1
      if ((s_pScreenInfo->fUseWinKillKey && wParam == VK_F4
d356 1
a356 1
	  || (s_pScreenInfo->fUseUnixKillKey && wParam == VK_BACK
d358 1
a358 1
	      && (GetKeyState (VK_CONTROL) & 0x8000)))
d365 1
a365 1
	  ErrorF ("winWindowProc - WM_*KEYDOWN - Closekey hit, quitting\n");
d367 2
a368 2
	  /* Display Exit dialog */
	  winDisplayExitDialog (s_pScreenPriv);
d392 1
a392 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
a410 1
#endif /* WIN_NEW_KEYBOARD_SUPPORT */
d413 1
a413 1
      if (s_pScreenPriv == NULL)
d417 1
a417 1
      (*s_pScreenPriv->pwinHotKeyAltTab) (s_pScreen);
d421 1
a421 2
      if (s_pScreenPriv == NULL
	  || s_pScreenInfo->fIgnoreInput)
a423 25
      /* TODO: Override display of window when we have a bad depth */
      if (LOWORD(wParam) != WA_INACTIVE && s_pScreenPriv->fBadDepth)
	{
	  ErrorF ("winWindowProc - WM_ACTIVATE - Bad depth, trying "
		  "to override window activation\n");

	  /* Minimize the window */
	  ShowWindow (hwnd, SW_MINIMIZE);

	  /* Display dialog box */
	  if (g_hDlgDepthChange != NULL)
	    {
	      /* Make the existing dialog box active */
	      SetActiveWindow (g_hDlgDepthChange);
	    }
	  else
	    {
	      /* TODO: Recreate the dialog box and bring to the top */
	      ShowWindow (g_hDlgDepthChange, SW_SHOWDEFAULT);
	    }

	  /* Don't do any other processing of this message */
	  return 0;
	}

d425 1
a425 1
      ErrorF ("winWindowProc - WM_ACTIVATE\n");
a426 1

d434 6
a439 1
      s_pScreenPriv->iDeltaZ = 0;
d441 2
a442 3
      /* Reshow the Windows mouse cursor if we are being deactivated */
      if (LOWORD(wParam) == WA_INACTIVE
	  && !g_fCursor)
d444 39
a482 2
	  /* Show Windows cursor */
	  g_fCursor = TRUE;
d485 3
d491 1
a491 2
      if (s_pScreenPriv == NULL
	  || s_pScreenInfo->fIgnoreInput)
d495 1
a495 1
      ErrorF ("winWindowProc - WM_ACTIVATEAPP\n");
a496 1

d498 1
a498 1
      s_pScreenPriv->fActive = wParam;
d500 3
a502 3
      /* Reshow the Windows mouse cursor if we are being deactivated */
      if (!s_pScreenPriv->fActive
	  && !g_fCursor)
d504 7
a510 2
	  /* Show Windows cursor */
	  g_fCursor = TRUE;
d515 1
a515 1
      (*s_pScreenPriv->pwinActivateApp) (s_pScreen);
d518 2
a519 29
    case WM_COMMAND:
      switch (LOWORD (wParam))
	{
	case ID_APP_EXIT:
	  /* Display Exit dialog */
	  winDisplayExitDialog (s_pScreenPriv);
	  return 0;

	case ID_APP_HIDE_ROOT:
	  ShowWindow (s_pScreenPriv->hwndScreen, SW_HIDE);
	  s_pScreenPriv->fRootWindowShown = FALSE;
	  return 0;

	case ID_APP_SHOW_ROOT:
	  ShowWindow (s_pScreenPriv->hwndScreen, SW_SHOW);
	  s_pScreenPriv->fRootWindowShown = TRUE;
	  return 0;

	default:
	  /* It's probably one of the custom menus... */
	  return HandleCustomWM_COMMAND (0, LOWORD (wParam));
	  
	}
      break;

    case WM_GIVEUP:
       /* Tell X that we are giving up */
      winDeinitClipboard ();
      winDeinitMultiWindowWM ();
a520 5
      return 0;

    case WM_CLOSE:
      /* Display Exit dialog */
      winDisplayExitDialog (s_pScreenPriv);
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@a31 1
 *		MATSUZAKI Kensuke
d33 1
a33 1
/* $XFree86: xc/programs/Xserver/hw/xwin/winwndproc.c,v 1.24 2003/02/12 15:01:38 alanh Exp $ */
a35 5
#include <commctrl.h>

BOOL CALLBACK
winChangeDepthDlgProc (HWND hDialog, UINT message,
		       WPARAM wParam, LPARAM lParam);
d47 6
a52 8
  static winPrivScreenPtr	s_pScreenPriv = NULL;
  static winScreenInfo		*s_pScreenInfo = NULL;
  static ScreenPtr		s_pScreen = NULL;
  static HWND			s_hwndLastPrivates = NULL;
  static HINSTANCE		s_hInstance;
  static Bool			s_fCursor = TRUE;
  static Bool			s_fTracking = FALSE;
  static unsigned long		s_ulServerGeneration = 0;
d55 1
d58 1
a58 1
  if (g_ulServerGeneration != s_ulServerGeneration)
d60 6
d67 1
a67 1
      s_ulServerGeneration = g_ulServerGeneration;
d71 2
a72 2
  if ((s_pScreenPriv == NULL || hwnd != s_hwndLastPrivates)
      && (s_pScreenPriv = GetProp (hwnd, WIN_SCR_PROP)) != NULL)
d74 2
a75 2
#if CYGDEBUG
      ErrorF ("winWindowProc - Setting privates handle\n");
d77 3
a79 3
      s_pScreenInfo = s_pScreenPriv->pScreenInfo;
      s_pScreen = s_pScreenInfo->pScreen;
      s_hwndLastPrivates = hwnd;
d81 1
a81 1
  else if (s_pScreenPriv == NULL)
d84 3
a86 3
      s_pScreenInfo = NULL;
      s_pScreen = NULL;
      s_hwndLastPrivates = NULL;
d94 1
a94 1
      ErrorF ("winWindowProc - WM_CREATE\n");
d106 5
a110 6
      s_pScreenPriv = ((LPCREATESTRUCT) lParam)->lpCreateParams;
      s_hInstance = ((LPCREATESTRUCT) lParam)->hInstance;
      s_pScreenInfo = s_pScreenPriv->pScreenInfo;
      s_pScreen = s_pScreenInfo->pScreen;
      s_hwndLastPrivates = hwnd;
      SetProp (hwnd, WIN_SCR_PROP, s_pScreenPriv);
d113 1
a113 1
      winStoreModeKeyStates (s_pScreen);
a115 495
    case WM_DISPLAYCHANGE:
      /* We cannot handle a display mode change during initialization */
      if (s_pScreenInfo == NULL)
	FatalError ("winWindowProc - WM_DISPLAYCHANGE - The display "
		    "mode changed while we were intializing.  This is "
		    "very bad and unexpected.  Exiting.\n");

      /*
       * We do not care about display changes with
       * fullscreen DirectDraw engines, because those engines set
       * their own mode when they become active.
       */
      if (s_pScreenInfo->fFullScreen
	  && (s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DD
	      || s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL
	      || s_pScreenInfo->dwEngine == WIN_SERVER_PRIMARY_DD))
	{
	  /* 
	   * Store the new display dimensions and depth.
	   * We do this here for future compatibility in case we
	   * ever allow switching from fullscreen to windowed mode.
	   */
	  s_pScreenPriv->dwLastWindowsWidth = GetSystemMetrics (SM_CXSCREEN);
	  s_pScreenPriv->dwLastWindowsHeight = GetSystemMetrics (SM_CYSCREEN);
	  s_pScreenPriv->dwLastWindowsBitsPixel
	    = GetDeviceCaps (s_pScreenPriv->hdcScreen, BITSPIXEL);	  
	  break;
	}
      
      ErrorF ("winWindowProc - WM_DISPLAYCHANGE - orig bpp: %d, last bpp: %d, "
	      "new bpp: %d\n",
	      s_pScreenInfo->dwBPP,
	      s_pScreenPriv->dwLastWindowsBitsPixel,
	      wParam);

      ErrorF ("winWindowProc - WM_DISPLAYCHANGE - new width: %d "
	      "new height: %d\n",
	      LOWORD (lParam), HIWORD (lParam));

      /*
       * TrueColor --> TrueColor depth changes are disruptive for:
       *	Windowed:
       *		Shadow DirectDraw
       *		Shadow DirectDraw Non-Locking
       *		Primary DirectDraw
       *
       * TrueColor --> TrueColor depth changs are non-optimal for:
       *	Windowed:
       *		Shadow GDI
       *
       *	FullScreen:
       *		Shadow GDI
       *
       * TrueColor --> PseudoColor or vice versa are disruptive for:
       *	Windowed:
       *		Shadow DirectDraw
       *		Shadow DirectDraw Non-Locking
       *		Primary DirectDraw
       *		Shadow GDI
       */

      /*
       * Check for a disruptive change in depth.
       * We can only display a message for a disruptive depth change,
       * we cannot do anything to correct the situation.
       */
      if ((s_pScreenInfo->dwBPP != wParam)
	  && (s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DD
	      || s_pScreenInfo->dwEngine == WIN_SERVER_SHADOW_DDNL
	      || s_pScreenInfo->dwEngine == WIN_SERVER_PRIMARY_DD))
	{
	  /* Cannot display the visual until the depth is restored */
	  ErrorF ("winWindowProc - Disruptive change in depth\n");

	  /* Check if the dialog box already exists */
	  if (g_hDlgDepthChange != NULL)
	    {
	      ErrorF ("winWindowProc - Dialog box already exists\n");

	      /* Dialog box already exists, just display it */
	      ShowWindow (g_hDlgDepthChange, SW_SHOWDEFAULT);
	    }
	  else
	    {
	      /*
	       * Display a notification to the user that the visual 
	       * will not be displayed until the Windows display depth 
	       * is restored to the original value.
	       */
	      g_hDlgDepthChange = CreateDialogParam (s_hInstance,
						     "DEPTH_CHANGE_BOX",
						     hwnd,
						     winChangeDepthDlgProc,
						     (int) s_pScreenPriv);
	      
	      /* Show the dialog box */
	      ShowWindow (g_hDlgDepthChange, SW_SHOW);
	      
	      ErrorF ("winWindowProc - DialogBox returned: %d\n",
		      g_hDlgDepthChange);
	      ErrorF ("winWindowProc - GetLastError: %d\n", GetLastError ());
	      
	      /* Minimize the display window */
	      ShowWindow (hwnd, SW_MINIMIZE);
	      
	      /* Flag that we have an invalid screen depth */
	      s_pScreenPriv->fBadDepth = TRUE;
	      
	      /*
	       * TODO: Redisplay the dialog box if it is not
	       * currently displayed.
	       */
	    }
	}
      else
	{
	  /* Flag that we have a valid screen depth */
	  s_pScreenPriv->fBadDepth = FALSE;
	}
      
      /*
       * Check for a change in display dimensions.
       * We can simply recreate the same-sized primary surface when
       * the display dimensions change.
       */
      if (s_pScreenPriv->dwLastWindowsWidth != LOWORD (lParam)
	  || s_pScreenPriv->dwLastWindowsHeight != HIWORD (lParam))
	{
	  /*
	   * NOTE: The non-DirectDraw engines set the ReleasePrimarySurface
	   * and CreatePrimarySurface function pointers to point
	   * to the no operation function, NoopDDA.  This allows us
	   * to blindly call these functions, even if they are not
	   * relevant to the current engine (e.g., Shadow GDI).
	   */

#if CYGDEBUG
	  ErrorF ("winWindowProc - WM_DISPLAYCHANGE - Dimensions changed\n");
#endif
	  
	  /* Release the old primary surface */
	  (*s_pScreenPriv->pwinReleasePrimarySurface) (s_pScreen);

#if CYGDEBUG
	  ErrorF ("winWindowProc - WM_DISPLAYCHANGE - Released "
		  "primary surface\n");
#endif

	  /* Create the new primary surface */
	  (*s_pScreenPriv->pwinCreatePrimarySurface) (s_pScreen);

#if CYGDEBUG
	  ErrorF ("winWindowProc - WM_DISPLAYCHANGE - Recreated "
		  "primary surface\n");
#endif
	}
      else
	{
#if CYGDEBUG
	  ErrorF ("winWindowProc - WM_DISPLAYCHANGE - Dimensions did not "
		  "change\n");
#endif
	}

      /* Store the new display dimensions and depth */
      s_pScreenPriv->dwLastWindowsWidth = GetSystemMetrics (SM_CXSCREEN);
      s_pScreenPriv->dwLastWindowsHeight = GetSystemMetrics (SM_CYSCREEN);
      s_pScreenPriv->dwLastWindowsBitsPixel
	= GetDeviceCaps (s_pScreenPriv->hdcScreen, BITSPIXEL);
      break;

    case WM_SIZE:
      {
	SCROLLINFO		si;
	RECT			rcWindow;
	int			iWidth, iHeight;

#if CYGDEBUG
	ErrorF ("winWindowProc - WM_SIZE\n");
#endif

	/* Break if we do not use scrollbars */
	if (!s_pScreenInfo->fScrollbars
	    || !s_pScreenInfo->fDecoration
	    || s_pScreenInfo->fRootless
	    || s_pScreenInfo->fMultiWindow
	    || s_pScreenInfo->fFullScreen)
	  break;

	/* No need to resize if we get minimized */
	if (wParam == SIZE_MINIMIZED)
	  return 0;

	/*
	 * Get the size of the whole window, including client area,
	 * scrollbars, and non-client area decorations (caption, borders).
	 * We do this because we need to check if the client area
	 * without scrollbars is large enough to display the whole visual.
	 * The new client area size passed by lParam already subtracts
	 * the size of the scrollbars if they are currently displayed.
	 * So checking is LOWORD(lParam) == visual_width and
	 * HIWORD(lParam) == visual_height will never tell us to hide
	 * the scrollbars because the client area would always be too small.
	 * GetClientRect returns the same sizes given by lParam, so we
	 * cannot use GetClientRect either.
	 */
	GetWindowRect (hwnd, &rcWindow);
	iWidth = rcWindow.right - rcWindow.left;
	iHeight = rcWindow.bottom - rcWindow.top;

	ErrorF ("winWindowProc - WM_SIZE - window w: %d h: %d, "
		"new client area w: %d h: %d\n",
		iWidth, iHeight, LOWORD (lParam), HIWORD (lParam));

	/* Subtract the frame size from the window size. */
	iWidth -= 2 * GetSystemMetrics (SM_CXSIZEFRAME);
	iHeight -= (2 * GetSystemMetrics (SM_CYSIZEFRAME)
		    + GetSystemMetrics (SM_CYCAPTION));

	/*
	 * Update scrollbar page sizes.
	 * NOTE: If page size == range, then the scrollbar is
	 * automatically hidden.
	 */

	/* Is the naked client area large enough to show the whole visual? */
	if (iWidth < s_pScreenInfo->dwWidth
	    || iHeight < s_pScreenInfo->dwHeight)
	  {
	    /* Client area too small to display visual, use scrollbars */
	    iWidth -= GetSystemMetrics (SM_CXVSCROLL);
	    iHeight -= GetSystemMetrics (SM_CYHSCROLL);
	  }
	
	/* Set the horizontal scrollbar page size */
	si.cbSize = sizeof (si);
	si.fMask = SIF_PAGE | SIF_RANGE;
	si.nMin = 0;
	si.nMax = s_pScreenInfo->dwWidth - 1;
	si.nPage = iWidth;
	SetScrollInfo (hwnd, SB_HORZ, &si, TRUE);
	
	/* Set the vertical scrollbar page size */
	si.cbSize = sizeof (si);
	si.fMask = SIF_PAGE | SIF_RANGE;
	si.nMin = 0;
	si.nMax = s_pScreenInfo->dwHeight - 1;
	si.nPage = iHeight;
	SetScrollInfo (hwnd, SB_VERT, &si, TRUE);

	/*
	 * NOTE: Scrollbars may have moved if they were at the 
	 * far right/bottom, so we query their current position.
	 */
	
	/* Get the horizontal scrollbar position and set the offset */
	si.cbSize = sizeof (si);
	si.fMask = SIF_POS;
	GetScrollInfo (hwnd, SB_HORZ, &si);
	s_pScreenInfo->dwXOffset = -si.nPos;
	
	/* Get the vertical scrollbar position and set the offset */
	si.cbSize = sizeof (si);
	si.fMask = SIF_POS;
	GetScrollInfo (hwnd, SB_VERT, &si);
	s_pScreenInfo->dwYOffset = -si.nPos;
      }
      return 0;

    case WM_VSCROLL:
      {
	SCROLLINFO		si;
	int			iVertPos;

#if CYGDEBUG
	ErrorF ("winWindowProc - WM_VSCROLL\n");
#endif
      
	/* Get vertical scroll bar info */
	si.cbSize = sizeof (si);
	si.fMask = SIF_ALL;
	GetScrollInfo (hwnd, SB_VERT, &si);

	/* Save the vertical position for comparison later */
	iVertPos = si.nPos;

	/*
	 * Don't forget:
	 * moving the scrollbar to the DOWN, scroll the content UP
	 */
	switch (LOWORD(wParam))
	  {
	  case SB_TOP:
	    si.nPos = si.nMin;
	    break;
	  
	  case SB_BOTTOM:
	    si.nPos = si.nMax - si.nPage + 1;
	    break;

	  case SB_LINEUP:
	    si.nPos -= 1;
	    break;
	  
	  case SB_LINEDOWN:
	    si.nPos += 1;
	    break;
	  
	  case SB_PAGEUP:
	    si.nPos -= si.nPage;
	    break;
	  
	  case SB_PAGEDOWN:
	    si.nPos += si.nPage;
	    break;

	  case SB_THUMBTRACK:
	    si.nPos = si.nTrackPos;
	    break;

	  default:
	    break;
	  }

	/*
	 * We retrieve the position after setting it,
	 * because Windows may adjust it.
	 */
	si.fMask = SIF_POS;
	SetScrollInfo (hwnd, SB_VERT, &si, TRUE);
	GetScrollInfo (hwnd, SB_VERT, &si);
      
	/* Scroll the window if the position has changed */
	if (si.nPos != iVertPos)
	  {
	    /* Save the new offset for bit block transfers, etc. */
	    s_pScreenInfo->dwYOffset = -si.nPos;

	    /* Change displayed region in the window */
	    ScrollWindowEx (hwnd,
			    0,
			    iVertPos - si.nPos,
			    NULL,
			    NULL,
			    NULL,
			    NULL,
			    SW_INVALIDATE);
	  
	    /* Redraw the window contents */
	    UpdateWindow (hwnd);
	  }
      }
      return 0;

    case WM_HSCROLL:
      {
	SCROLLINFO		si;
	int			iHorzPos;

#if CYGDEBUG
	ErrorF ("winWindowProc - WM_HSCROLL\n");
#endif
      
	/* Get horizontal scroll bar info */
	si.cbSize = sizeof (si);
	si.fMask = SIF_ALL;
	GetScrollInfo (hwnd, SB_HORZ, &si);

	/* Save the horizontal position for comparison later */
	iHorzPos = si.nPos;

	/*
	 * Don't forget:
	 * moving the scrollbar to the RIGHT, scroll the content LEFT
	 */
	switch (LOWORD(wParam))
	  {
	  case SB_LEFT:
	    si.nPos = si.nMin;
	    break;
	  
	  case SB_RIGHT:
	    si.nPos = si.nMax - si.nPage + 1;
	    break;

	  case SB_LINELEFT:
	    si.nPos -= 1;
	    break;
	  
	  case SB_LINERIGHT:
	    si.nPos += 1;
	    break;
	  
	  case SB_PAGELEFT:
	    si.nPos -= si.nPage;
	    break;
	  
	  case SB_PAGERIGHT:
	    si.nPos += si.nPage;
	    break;

	  case SB_THUMBTRACK:
	    si.nPos = si.nTrackPos;
	    break;

	  default:
	    break;
	  }

	/*
	 * We retrieve the position after setting it,
	 * because Windows may adjust it.
	 */
	si.fMask = SIF_POS;
	SetScrollInfo (hwnd, SB_HORZ, &si, TRUE);
	GetScrollInfo (hwnd, SB_HORZ, &si);
      
	/* Scroll the window if the position has changed */
	if (si.nPos != iHorzPos)
	  {
	    /* Save the new offset for bit block transfers, etc. */
	    s_pScreenInfo->dwXOffset = -si.nPos;

	    /* Change displayed region in the window */
	    ScrollWindowEx (hwnd,
			    iHorzPos - si.nPos,
			    0,
			    NULL,
			    NULL,
			    NULL,
			    NULL,
			    SW_INVALIDATE);
	  
	    /* Redraw the window contents */
	    UpdateWindow (hwnd);
	  }
      }
      return 0;

    case WM_GETMINMAXINFO:
      {
	MINMAXINFO		*pMinMaxInfo = (MINMAXINFO *) lParam;
	int			iCaptionHeight;
	int			iBorderHeight, iBorderWidth;

#if CYGDEBUG	
	ErrorF ("winWindowProc - WM_GETMINMAXINFO - pScreenInfo: %08x\n",
		s_pScreenInfo);
#endif

	/* Can't do anything without screen info */
	if (s_pScreenInfo == NULL
	    || !s_pScreenInfo->fScrollbars
	    || s_pScreenInfo->fFullScreen
	    || !s_pScreenInfo->fDecoration
	    || s_pScreenInfo->fRootless
	    || s_pScreenInfo->fMultiWindow)
	  break;

	/*
	 * Here we can override the maximum tracking size, which
	 * is the largest size that can be assigned to our window
	 * via the sizing border.
	 */

	/*
	 * FIXME: Do we only need to do this once, since our visual size
	 * does not change?  Does Windows store this value statically
	 * once we have set it once?
	 */

	/* Get the border and caption sizes */
	iCaptionHeight = GetSystemMetrics (SM_CYCAPTION);
	iBorderWidth = 2 * GetSystemMetrics (SM_CXSIZEFRAME);
	iBorderHeight = 2 * GetSystemMetrics (SM_CYSIZEFRAME);
	
	/* Allow the full visual to be displayed */
	pMinMaxInfo->ptMaxTrackSize.x
	  = s_pScreenInfo->dwWidth + iBorderWidth;
	pMinMaxInfo->ptMaxTrackSize.y
	  = s_pScreenInfo->dwHeight + iBorderHeight + iCaptionHeight;
      }
      return 0;

    case WM_ERASEBKGND:
#if CYGDEBUG
      ErrorF ("winWindowProc - WM_ERASEBKGND\n");
#endif
      /*
       * Pretend that we did erase the background but we don't care,
       * the application uses the full window estate. This avoids some
       * flickering when resizing.
       */
      return TRUE;

d118 1
a118 1
      ErrorF ("winWindowProc - WM_PAINT\n");
d121 3
a123 4
      if (s_pScreenPriv == NULL
	  || !s_pScreenPriv->fEnabled
	  || (s_pScreenInfo->fFullScreen && !s_pScreenPriv->fActive)
	  || s_pScreenPriv->fBadDepth)
d130 1
a130 1
      if (s_pScreenPriv->pwinBltExposedRegions == NULL)
d134 1
a134 1
      (*s_pScreenPriv->pwinBltExposedRegions) (s_pScreen);
d140 1
a140 1
	ErrorF ("winWindowProc - WM_PALETTECHANGED\n");
d142 2
a143 7
	/*
	 * Don't process if we don't have privates or a colormap,
	 * or if we have an invalid depth.
	 */
	if (s_pScreenPriv == NULL
	    || s_pScreenPriv->pcmapInstalled == NULL
	    || s_pScreenPriv->fBadDepth)
d150 1
a150 1
	    (*s_pScreenPriv->pwinRedrawScreen) (s_pScreen);
d155 1
a155 1
	(*s_pScreenPriv->pwinRealizeInstalledPalette) (s_pScreen);
d158 1
a158 1
	(*s_pScreenPriv->pwinRedrawScreen) (s_pScreen);
d164 1
a164 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d166 1
a166 1

d168 2
a169 4
      if (s_pScreen != miPointerCurrentScreen ())
	miPointerSetNewScreen (s_pScreenInfo->dwScreen,
			       GET_X_LPARAM(lParam)-s_pScreenInfo->dwXOffset,
			       GET_Y_LPARAM(lParam)-s_pScreenInfo->dwYOffset);
d171 2
a172 2
      /* Are we tracking yet? */
      if (!s_fTracking)
d174 15
a188 11
	  TRACKMOUSEEVENT		tme;
	  
	  /* Setup data structure */
	  ZeroMemory (&tme, sizeof (tme));
	  tme.cbSize = sizeof (tme);
	  tme.dwFlags = TME_LEAVE;
	  tme.hwndTrack = hwnd;

	  /* Call the tracking function */
	  if (!(*g_fpTrackMouseEvent) (&tme))
	    ErrorF ("winWindowProc - _TrackMouseEvent failed\n");
d190 6
a195 2
	  /* Flag that we are tracking now */
	  s_fTracking = TRUE;
d197 2
a198 3

      /* Hide or show the Windows mouse cursor */
      if (s_fCursor && (s_pScreenPriv->fActive || s_pScreenInfo->fLessPointer))
d201 1
a201 1
	  s_fCursor = FALSE;
d204 2
a205 2
      else if (!s_fCursor && !s_pScreenPriv->fActive
	       && !s_pScreenInfo->fLessPointer)
d208 1
a208 1
	  s_fCursor = TRUE;
d211 1
a211 1
      
d213 2
a214 2
      miPointerAbsoluteCursor (GET_X_LPARAM(lParam)-s_pScreenInfo->dwXOffset,
			       GET_Y_LPARAM(lParam)-s_pScreenInfo->dwYOffset,
d216 3
a221 9
      /*
       * We break instead of returning 0 since we need to call
       * DefWindowProc to get the mouse cursor changes
       * and min/max/close button highlighting in Windows XP.
       * The Platform SDK says that you should return 0 if you
       * process this message, but it fails to mention that you
       * will give up any default functionality if you do return 0.
       */
      
d223 1
a223 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d225 1
a225 1
      
d227 1
a227 1
      if (!s_fCursor)
d229 8
a236 4
	  s_fCursor = TRUE;
	  ShowCursor (TRUE);
	}
      break;
d238 6
a243 2
    case WM_MOUSELEAVE:
      /* Mouse has left our client area */
d245 8
a252 5
      /* Flag that we are no longer tracking */
      s_fTracking = FALSE;

      /* Show the mouse cursor, if necessary */
      if (!s_fCursor)
d254 1
a254 1
	  s_fCursor = TRUE;
d257 3
d264 1
a264 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d266 1
a266 2
      if (s_pScreenInfo->fRootless) SetCapture (hwnd);
      return winMouseButtonsHandle (s_pScreen, ButtonPress, Button1, wParam);
d269 1
a269 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d271 1
a271 2
      if (s_pScreenInfo->fRootless) ReleaseCapture ();
      return winMouseButtonsHandle (s_pScreen, ButtonRelease, Button1, wParam);
d275 1
a275 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d277 1
a277 2
      if (s_pScreenInfo->fRootless) SetCapture (hwnd);
      return winMouseButtonsHandle (s_pScreen, ButtonPress, Button2, wParam);
d280 1
a280 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d282 1
a282 2
      if (s_pScreenInfo->fRootless) ReleaseCapture ();
      return winMouseButtonsHandle (s_pScreen, ButtonRelease, Button2, wParam);
d286 1
a286 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d288 1
a288 2
      if (s_pScreenInfo->fRootless) SetCapture (hwnd);
      return winMouseButtonsHandle (s_pScreen, ButtonPress, Button3, wParam);
d291 1
a291 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d293 1
a293 2
      if (s_pScreenInfo->fRootless) ReleaseCapture ();
      return winMouseButtonsHandle (s_pScreen, ButtonRelease, Button3, wParam);
d296 1
a296 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d305 1
a305 1
				    s_pScreenPriv->iE3BCachedPress);
d308 1
a308 1
	  KillTimer (s_pScreenPriv->hwndScreen, WIN_E3B_TIMER_ID);
d311 1
a311 1
	  s_pScreenPriv->iE3BCachedPress = 0;
a315 5
    case WM_CTLCOLORSCROLLBAR:
      FatalError ("winWindowProc - WM_CTLCOLORSCROLLBAR - We are not "
		  "supposed to get this message.  Exiting.\n");
      return 0;

d317 1
a317 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d319 1
a319 5
#if CYGDEBUG
      ErrorF ("winWindowProc - WM_MOUSEWHEEL\n");
#endif
      winMouseWheel (s_pScreen, GET_WHEEL_DELTA_WPARAM(wParam));
      break;
d322 1
a322 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d326 1
a326 1
      winRestoreModeKeyStates (s_pScreen);
d330 1
a330 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d334 1
a334 1
      winStoreModeKeyStates (s_pScreen);
d336 2
a337 2
      /* Release any pressed keys */
      winKeybdReleaseKeys ();
a339 1
#if WIN_NEW_KEYBOARD_SUPPORT
d342 1
a342 20
    case WM_SYSKEYUP:
    case WM_KEYUP:
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;

      /* Don't process keys if we are not active */
      if (!s_pScreenPriv->fActive)
	return 0;

      winProcessKeyEvent ((DWORD)wParam, (DWORD) lParam);
      return 0;

    case WM_DEADCHAR:
    case WM_SYSDEADCHAR:
      return 0;

#else /* WIN_NEW_KEYBOARD_SUPPORT */
    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
d354 1
a354 1
      if ((s_pScreenInfo->fUseWinKillKey && wParam == VK_F4
d356 1
a356 1
	  || (s_pScreenInfo->fUseUnixKillKey && wParam == VK_BACK
d365 1
a365 1
	  ErrorF ("winWindowProc - WM_*KEYDOWN - Closekey hit, quitting\n");
d392 1
a392 1
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
a410 1
#endif /* WIN_NEW_KEYBOARD_SUPPORT */
d413 1
a413 1
      if (s_pScreenPriv == NULL)
d417 1
a417 1
      (*s_pScreenPriv->pwinHotKeyAltTab) (s_pScreen);
d421 1
a421 2
      if (s_pScreenPriv == NULL
	  || s_pScreenInfo->fIgnoreInput)
a423 27
      /* TODO: Override display of window when we have a bad depth */
      if (LOWORD(wParam) != WA_INACTIVE && s_pScreenPriv->fBadDepth)
	{
	  ErrorF ("winWindowProc - WM_ACTIVATE - Bad depth, trying "
		  "to override window activation\n");

	  /* Minimize the window */
	  ShowWindow (hwnd, SW_MINIMIZE);

	  /* Display dialog box */
	  if (g_hDlgDepthChange != NULL)
	    {
	      /* Make the existing dialog box active */
	      SetActiveWindow (g_hDlgDepthChange);
	    }
	  else
	    {
	      /* TODO: Recreate the dialog box and bring to the top */
	      ShowWindow (g_hDlgDepthChange, SW_SHOWDEFAULT);
	    }

	  /* Don't do any other processing of this message */
	  return 0;
	}



d425 1
a425 1
      ErrorF ("winWindowProc - WM_ACTIVATE\n");
a426 1

d434 1
a434 1
      s_pScreenPriv->iDeltaZ = 0;
d436 45
a480 3
      /* Reshow the Windows mouse cursor if we are being deactivated */
      if (LOWORD(wParam) == WA_INACTIVE
	  && !s_fCursor)
d482 1
a482 2
	  /* Show Windows cursor */
	  s_fCursor = TRUE;
d485 3
d491 1
a491 2
      if (s_pScreenPriv == NULL
	  || s_pScreenInfo->fIgnoreInput)
d495 1
a495 1
      ErrorF ("winWindowProc - WM_ACTIVATEAPP\n");
a496 1

d498 1
a498 1
      s_pScreenPriv->fActive = wParam;
d500 9
a508 3
      /* Reshow the Windows mouse cursor if we are being deactivated */
      if (!s_pScreenPriv->fActive
	  && !s_fCursor)
d510 1
a510 2
	  /* Show Windows cursor */
	  s_fCursor = TRUE;
d515 1
a515 1
      (*s_pScreenPriv->pwinActivateApp) (s_pScreen);
a524 98
}


/*
 * Process messages for the dialog that is displayed for
 * disruptive screen depth changes. 
 */

BOOL CALLBACK
winChangeDepthDlgProc (HWND hwndDialog, UINT message,
		       WPARAM wParam, LPARAM lParam)
{
  static winPrivScreenPtr	s_pScreenPriv = NULL;
  static winScreenInfo		*s_pScreenInfo = NULL;
  static ScreenPtr		s_pScreen = NULL;

#if CYGDEBUG
  ErrorF ("winChangeDepthDlgProc\n");
#endif

  /* Branch on message type */
  switch (message)
    {
    case WM_INITDIALOG:
#if CYGDEBUG
      ErrorF ("winChangeDepthDlgProc - WM_INITDIALOG\n");
#endif

      /* Store pointers to private structures for future use */
      s_pScreenPriv = (winPrivScreenPtr) lParam;
      s_pScreenInfo = s_pScreenPriv->pScreenInfo;
      s_pScreen = s_pScreenInfo->pScreen;

#if CYGDEBUG
      ErrorF ("winChangeDepthDlgProc - WM_INITDIALG - s_pScreenPriv: %08x, "
	      "s_pScreenInfo: %08x, s_pScreen: %08x\n",
	      s_pScreenPriv, s_pScreenInfo, s_pScreen);
#endif

#if CYGDEBUG
      ErrorF ("winChangeDepthDlgProc - WM_INITDIALOG - orig bpp: %d, "
	      "last bpp: %d\n",
	      s_pScreenInfo->dwBPP,
	      s_pScreenPriv->dwLastWindowsBitsPixel);
#endif
      return TRUE;

    case WM_DISPLAYCHANGE:
#if CYGDEBUG
      ErrorF ("winChangeDepthDlgProc - WM_DISPLAYCHANGE - orig bpp: %d, "
	      "last bpp: %d, new bpp: %d\n",
	      s_pScreenInfo->dwBPP,
	      s_pScreenPriv->dwLastWindowsBitsPixel,
	      wParam);
#endif

      /* Dismiss the dialog if the display returns to the original depth */
      if (wParam == s_pScreenInfo->dwBPP)
	{
	  ErrorF ("winChangeDelthDlgProc - wParam == s_pScreenInfo->dwBPP\n");

	  /* Depth has been restored, dismiss dialog */
	  DestroyWindow (g_hDlgDepthChange);
	  g_hDlgDepthChange = NULL;

	  /* Flag that we have a valid screen depth */
	  s_pScreenPriv->fBadDepth = FALSE;
	}
      return TRUE;

    case WM_COMMAND:
      switch (LOWORD (wParam))
	{
	case IDOK:
	case IDCANCEL:
	  ErrorF ("winChangeDepthDlgProc - WM_COMMAND - IDOK or IDCANCEL\n");

	  /* 
	   * User dismissed the dialog, hide it until the
	   * display mode is restored.
	   */
	  ShowWindow (g_hDlgDepthChange, SW_HIDE);
	  return TRUE;
	}
      break;

    case WM_CLOSE:
      ErrorF ("winChangeDepthDlgProc - WM_CLOSE\n");

      /* 
       * User dismissed the dialog, hide it until the
       * display mode is restored.
       */
      ShowWindow (g_hDlgDepthChange, SW_HIDE);
      return TRUE;
    }

  return FALSE;
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d34 1
a34 1
/* $XFree86: xc/programs/Xserver/hw/xwin/winwndproc.c,v 1.26 2003/10/02 13:30:11 eich Exp $ */
a37 7
#include "winprefs.h"

/*
 * Global variables
 */

Bool			g_fCursor = TRUE;
d39 3
d58 1
a92 4
    case WM_TRAYICON:
      return winHandleIconMessage (hwnd, message, wParam, lParam,
				   s_pScreenPriv);

a115 17

      /* Setup tray icon */
      if (!s_pScreenInfo->fNoTrayIcon)
	{
	  /*
	   * NOTE: The WM_CREATE message is processed before CreateWindowEx
	   * returns, so s_pScreenPriv->hwndScreen is invalid at this point.
	   * We go ahead and copy our hwnd parameter over top of the screen
	   * privates hwndScreen so that we have a valid value for
	   * that member.  Otherwise, the tray icon will disappear
	   * the first time you move the mouse over top of it.
	   */
	  
	  s_pScreenPriv->hwndScreen = hwnd;

	  winInitNotifyIcon (s_pScreenPriv);
	}
d164 1
a164 1
       * TrueColor --> TrueColor depth changes are non-optimal for:
d192 4
a195 2
	  /* Display Exit dialog */
	  winDisplayDepthChangeDialog (s_pScreenPriv);
d197 34
a230 5
	  /* Flag that we have an invalid screen depth */
	  s_pScreenPriv->fBadDepth = TRUE;

	  /* Minimize the display window */
	  ShowWindow (hwnd, SW_MINIMIZE);
d696 1
a696 1
      if (g_fCursor && (s_pScreenPriv->fActive || s_pScreenInfo->fLessPointer))
d699 1
a699 1
	  g_fCursor = FALSE;
d702 1
a702 1
      else if (!g_fCursor && !s_pScreenPriv->fActive
d706 1
a706 1
	  g_fCursor = TRUE;
d731 1
a731 1
      if (!g_fCursor)
d733 1
a733 1
	  g_fCursor = TRUE;
d745 1
a745 1
      if (!g_fCursor)
d747 1
a747 1
	  g_fCursor = TRUE;
a808 16

	case WIN_POLLING_MOUSE_TIMER_ID:
	  {
	    POINT		point;
	    
	    /* Get the current position of the mouse cursor */
	    GetCursorPos (&point);
	    
	    /* Map from screen (-X, -Y) to root (0, 0) */
	    point.x -= GetSystemMetrics (SM_XVIRTUALSCREEN);
	    point.y -= GetSystemMetrics (SM_YVIRTUALSCREEN);
	    
	    /* Deliver absolute cursor position to X Server */
	    miPointerAbsoluteCursor (point.x, point.y,
				     g_c32LastInputEventTime = GetTickCount());
	  }
d883 1
a883 1
	      && (GetKeyState (VK_CONTROL) & 0x8000)))
d892 2
a893 2
	  /* Display Exit dialog */
	  winDisplayExitDialog (s_pScreenPriv);
d976 2
d993 1
a993 1
	  && !g_fCursor)
d996 1
a996 1
	  g_fCursor = TRUE;
d1015 1
a1015 1
	  && !g_fCursor)
d1018 1
a1018 1
	  g_fCursor = TRUE;
d1026 77
d1106 3
a1108 4
	case ID_APP_EXIT:
	  /* Display Exit dialog */
	  winDisplayExitDialog (s_pScreenPriv);
	  return 0;
d1110 6
a1115 14
	case ID_APP_HIDE_ROOT:
	  ShowWindow (s_pScreenPriv->hwndScreen, SW_HIDE);
	  s_pScreenPriv->fRootWindowShown = FALSE;
	  return 0;

	case ID_APP_SHOW_ROOT:
	  ShowWindow (s_pScreenPriv->hwndScreen, SW_SHOW);
	  s_pScreenPriv->fRootWindowShown = TRUE;
	  return 0;

	default:
	  /* It's probably one of the custom menus... */
	  return HandleCustomWM_COMMAND (0, LOWORD (wParam));
	  
d1119 2
a1120 6
    case WM_GIVEUP:
       /* Tell X that we are giving up */
      winDeinitClipboard ();
      winDeinitMultiWindowWM ();
      GiveUp (0);
      return 0;
d1122 6
a1127 4
    case WM_CLOSE:
      /* Display Exit dialog */
      winDisplayExitDialog (s_pScreenPriv);
      return 0;
d1130 1
a1130 1
  return DefWindowProc (hwnd, message, wParam, lParam);
@


