head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.2
	cvs-200410241530:1.1.1.2
	cvs-200410012000:1.1.1.2
	cvs-200407141120:1.1.1.2
	cvs-200406231010:1.1.1.2
	MIRBSD_7quater:1.1.1.1
	cvs-200405271510:1.1.1.2
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.2
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.4
	MIRBSD_7:1.1.1.1.0.2
	MIRBSD_7ter:1.1.1.1
	cvs-20011091815:1.1.1.1
	cvs-200309162130:1.1.1.1
	cvs-200308302005:1.1.1.1
	ctmx-0387:1.1.1.1
	ctmx-0384:1.1.1.1
	MIRBSD_5:1.1.1.1
	ctmx-0375:1.1.1.1
	ctmx-0373:1.1.1.1
	ctm-0371:1.1.1.1
	ctm-0370:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-0363:1.1.1.1
	ctm-0359:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.04.08.18.38.01;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.04.08.18.38.01;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.03.02.18.28.57;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.26.08;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 *Copyright (C) 1994-2000 The XFree86 Project, Inc. All Rights Reserved.
 *
 *Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 *"Software"), to deal in the Software without restriction, including
 *without limitation the rights to use, copy, modify, merge, publish,
 *distribute, sublicense, and/or sell copies of the Software, and to
 *permit persons to whom the Software is furnished to do so, subject to
 *the following conditions:
 *
 *The above copyright notice and this permission notice shall be
 *included in all copies or substantial portions of the Software.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *NONINFRINGEMENT. IN NO EVENT SHALL THE XFREE86 PROJECT BE LIABLE FOR
 *ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 *CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 *Except as contained in this notice, the name of the XFree86 Project
 *shall not be used in advertising or otherwise to promote the sale, use
 *or other dealings in this Software without prior written authorization
 *from the XFree86 Project.
 *
 * Authors:	Kensuke Matsuzaki
 */
/* $XFree86: xc/programs/Xserver/hw/xwin/winmultiwindowwindow.c,v 1.1 2003/02/12 15:01:38 alanh Exp $ */

#include "win.h"
#include "dixevents.h"


/*
 * Prototypes for local functions
 */

static void
winCreateWindowsWindow (WindowPtr pWin);

static void
winDestroyWindowsWindow (WindowPtr pWin);

static void
winUpdateWindowsWindow (WindowPtr pWin);

static XID
winGetWindowID (WindowPtr pWin);

static void
SendConfigureNotify (WindowPtr pWin);

static
void
winUpdateRgn (WindowPtr pWindow);

#ifdef SHAPE
static
void
winReshape (WindowPtr pWin);
#endif


/*
 * Local globals
 */

static UINT s_nIDPollingMouse = 2;

#if 0
static BOOL s_fMoveByX = FALSE;
#endif


/*
 * Constant defines
 */


#define MOUSE_POLLING_INTERVAL 500
#define WIN_MULTIWINDOW_SHAPE YES

/*
 * Macros
 */

#define SubSend(pWin) \
    ((pWin->eventMask|wOtherEventMasks(pWin)) & SubstructureNotifyMask)

#define StrSend(pWin) \
    ((pWin->eventMask|wOtherEventMasks(pWin)) & StructureNotifyMask)

#define SubStrSend(pWin,pParent) (StrSend(pWin) || SubSend(pParent))


/*
 * CreateWindow - See Porting Layer Definition - p. 37
 */

Bool
winCreateWindowMultiWindow (WindowPtr pWin)
{
  Bool			fResult = TRUE;
  winWindowPriv(pWin);

#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winCreateWindowMultiWindow - pWin: %08x\n", pWin);
#endif
  
  /* Call any wrapped CreateWindow function */
  if (winGetScreenPriv(pWin->drawable.pScreen)->CreateWindow)
    fResult = winGetScreenPriv(pWin->drawable.pScreen)->CreateWindow (pWin);
  
  /* Initialize some privates values */
  pWinPriv->hRgn = NULL;
  pWinPriv->hWnd = NULL;
  pWinPriv->pScreenPriv = winGetScreenPriv(pWin->drawable.pScreen);
  pWinPriv->fXKilled = FALSE;
  
  return fResult;
}


/*
 * DestroyWindow - See Porting Layer Definition - p. 37
 */

Bool
winDestroyWindowMultiWindow (WindowPtr pWin)
{
  Bool			fResult = TRUE;
  winWindowPriv(pWin);

#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winDestroyWindowMultiWindow - pWin: %08x\n", pWin);
#endif
  
  /* Call any wrapped DestroyWindow function */
  if (winGetScreenPriv(pWin->drawable.pScreen)->DestroyWindow)
    fResult = winGetScreenPriv(pWin->drawable.pScreen)->DestroyWindow (pWin);
  
  /* Flag that the window has been destroyed */
  pWinPriv->fXKilled = TRUE;
  
  /* Kill the MS Windows window associated with this window */
  winDestroyWindowsWindow (pWin); 

  return fResult;
}


/*
 * PositionWindow - See Porting Layer Definition - p. 37
 */

Bool
winPositionWindowMultiWindow (WindowPtr pWin, int x, int y)
{
  Bool			fResult = TRUE;
  int		        iX, iY, iWidth, iHeight, iBorder;
  winWindowPriv(pWin);
  HWND hWnd = pWinPriv->hWnd;
  RECT rcNew;
  RECT rcOld;
#if CYGMULTIWINDOW_DEBUG
  RECT rcClient;
  RECT *lpRc;
#endif
  DWORD dwExStyle;
  DWORD dwStyle;

#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winPositionWindowMultiWindow - pWin: %08x\n", pWin);
#endif
  
  /* Call any wrapped PositionWindow function */
  if (winGetScreenPriv(pWin->drawable.pScreen)->PositionWindow)
    fResult = winGetScreenPriv(pWin->drawable.pScreen)->PositionWindow (pWin, x, y);
  
  /* Bail out if the Windows window handle is bad */
  if (!hWnd)
    return fResult;

  /* Get the Windows window style and extended style */
  dwExStyle = GetWindowLongPtr (hWnd, GWL_EXSTYLE);
  dwStyle = GetWindowLongPtr (hWnd, GWL_STYLE);

  /* Get the width of the X window border */
  iBorder = wBorderWidth (pWin);
  
  /* Get the X and Y location of the X window */
  iX = pWin->drawable.x;
  iY = pWin->drawable.y;

  /* Get the height and width of the X window */
  iWidth = pWin->drawable.width;
  iHeight = pWin->drawable.height;

  /* Store the origin, height, and width in a rectangle structure */
  SetRect (&rcNew, iX, iY, iX + iWidth, iY + iHeight);

#if CYGMULTIWINDOW_DEBUG
  lpRc = &rcNew;
  ErrorF ("winPositionWindowMultiWindow - (%d ms)drawable (%d, %d)-(%d, %d)\n",
	  GetTickCount (), lpRc->left, lpRc->top, lpRc->right, lpRc->bottom);
#endif

  /*
   * Calculate the required size of the Windows window rectangle,
   * given the size of the Windows window client area.
   */
  AdjustWindowRectEx (&rcNew, dwStyle, FALSE, dwExStyle);

  /* Get a rectangle describing the old Windows window */
  GetWindowRect (hWnd, &rcOld);

#if CYGMULTIWINDOW_DEBUG
  /* Get a rectangle describing the Windows window client area */
  GetClientRect (hWnd, &rcClient);

  lpRc = &rcNew;
  ErrorF ("winPositionWindowMultiWindow - (%d ms)rcNew (%d, %d)-(%d, %d)\n",
	  GetTickCount (), lpRc->left, lpRc->top, lpRc->right, lpRc->bottom);
      
  lpRc = &rcOld;
  ErrorF ("winPositionWindowMultiWindow - (%d ms)rcOld (%d, %d)-(%d, %d)\n",
	  GetTickCount (), lpRc->left, lpRc->top, lpRc->right, lpRc->bottom);
      
  lpRc = &rcClient;
  ErrorF ("(%d ms)rcClient (%d, %d)-(%d, %d)\n",
	  GetTickCount (), lpRc->left, lpRc->top, lpRc->right, lpRc->bottom);
#endif

  /* Check if the old rectangle and new rectangle are the same */
  if (!EqualRect (&rcNew, &rcOld))
    {
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winPositionWindowMultiWindow - Need to move\n");
#endif

      /* Change the position and dimensions of the Windows window */
      MoveWindow (hWnd,
		  rcNew.left, rcNew.top,
		  rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
		  TRUE);
    }
  else
    {
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winPositionWindowMultiWindow - Not need to move\n");
#endif
    }

  return fResult;
}


/*
 * ChangeWindowAttributes - See Porting Layer Definition - p. 37
 */

Bool
winChangeWindowAttributesMultiWindow (WindowPtr pWin, unsigned long mask)
{
  Bool			fResult = TRUE;

#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winChangeWindowAttributesMultiWindow - pWin: %08x\n", pWin);
#endif
  
  /* Call any wrapped ChangeWindowAttributes function */
  if (winGetScreenPriv(pWin->drawable.pScreen)->ChangeWindowAttributes)
    fResult = winGetScreenPriv(pWin->drawable.pScreen)->ChangeWindowAttributes (pWin, mask);
  
  /*
   * NOTE: We do not currently need to do anything here.
   */

  return fResult;
}


/*
 * UnmapWindow - See Porting Layer Definition - p. 37
 * Also referred to as UnrealizeWindow
 */

Bool
winUnmapWindowMultiWindow (WindowPtr pWin)
{
  Bool			fResult = TRUE;
  winWindowPriv(pWin);

#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winUnmapWindowMultiWindow - pWin: %08x\n", pWin);
#endif
  
  /* Call any wrapped UnrealizeWindow function */
  if (winGetScreenPriv(pWin->drawable.pScreen)->UnrealizeWindow)
    fResult = winGetScreenPriv(pWin->drawable.pScreen)->UnrealizeWindow (pWin);
  
  /* Flag that the window has been killed */
  pWinPriv->fXKilled = TRUE;
 
  /* Destroy the Windows window associated with this X window */
  winDestroyWindowsWindow (pWin);

  return fResult;
}


/*
 * MapWindow - See Porting Layer Definition - p. 37
 * Also referred to as RealizeWindow
 */

Bool
winMapWindowMultiWindow (WindowPtr pWin)
{
  Bool			fResult = TRUE;
  winWindowPriv(pWin);

#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winMapWindowMultiWindow - pWin: %08x\n", pWin);
#endif
  
  /* Call any wrapped RealizeWindow function */
  if (winGetScreenPriv(pWin->drawable.pScreen)->RealizeWindow)
    fResult = winGetScreenPriv(pWin->drawable.pScreen)->RealizeWindow (pWin);
  
  /* Flag that this window has not been destroyed */
  pWinPriv->fXKilled = FALSE;

  /* Refresh/redisplay the Windows window associated with this X window */
  winUpdateWindowsWindow (pWin);

#if WIN_MULTIWINDOW_SHAPE
  winReshape (pWin);
  winUpdateRgn (pWin);
#endif

  return fResult;
}


/*
 * ReparentWindow - See Porting Layer Definition - p. 42
 */

void
winReparentWindowMultiWindow (WindowPtr pWin, WindowPtr pPriorParent)
{
#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winReparentMultiWindow - pWin: %08x\n", pWin);
#endif

  /* Call any wrapped ReparentWindow function */
  if (winGetScreenPriv(pWin->drawable.pScreen)->ReparentWindow)
    winGetScreenPriv(pWin->drawable.pScreen)->ReparentWindow (pWin,
							      pPriorParent);
  
  /* Update the Windows window associated with this X window */
  winUpdateWindowsWindow (pWin);
}


/*
 * RestackWindow - Shuffle the z-order of a window
 */

void
winRestackWindowMultiWindow (WindowPtr pWin, WindowPtr pOldNextSib)
{
  WindowPtr		pPrevWin;
  UINT			uFlags;
  HWND			hInsertAfter;
  winWindowPriv(pWin);

#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winRestackMultiWindow - %08x\n", pWin);
#endif
  
  /* Call any wrapped RestackWindow function */
  if (winGetScreenPriv(pWin->drawable.pScreen)->RestackWindow)
    winGetScreenPriv(pWin->drawable.pScreen)->RestackWindow (pWin,
							     pOldNextSib);
  
  /* Bail out if no window privates or window handle is invalid */
  if (!pWinPriv || !pWinPriv->hWnd)
    return;

  /* Get a pointer to our previous sibling window */
  pPrevWin = pWin->prevSib;

  /*
   * Look for a sibling window with
   * valid privates and window handle
   */
  while (pPrevWin
	 && !winGetWindowPriv(pPrevWin)
	 && !winGetWindowPriv(pPrevWin)->hWnd)
    pPrevWin = pPrevWin->prevSib;
      
  /* Check if we found a valid sibling */
  if (pPrevWin)
    {
      /* Valid sibling - get handle to insert window after */
      hInsertAfter = winGetWindowPriv(pPrevWin)->hWnd;
      uFlags = SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE;
    }
  else
    {
      /* No valid sibling - make this window the top window */
      hInsertAfter = HWND_TOP;
      uFlags = SWP_NOMOVE | SWP_NOSIZE;
    }
      
  /* Perform the restacking operation in Windows */
  SetWindowPos (pWinPriv->hWnd,
		hInsertAfter,
		0, 0,
		0, 0,
		uFlags);
}


/*
 * SetShape - See Porting Layer Definition - p. 42
 */

#ifdef SHAPE
void
winSetShapeMultiWindow (WindowPtr pWin)
{
#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winSetShapeMultiWindow - pWin: %08x\n", pWin);
#endif
  
  /* Call any wrapped SetShape function */
  if (winGetScreenPriv(pWin->drawable.pScreen)->SetShape)
    winGetScreenPriv(pWin->drawable.pScreen)->SetShape (pWin);
  
  /*
   * NOTE: We do not currently do anything here.
   */

#if WIN_MULTIWINDOW_SHAPE
  winReshape (pWin);
  winUpdateRgn (pWin);
#endif

  return;
}
#endif


/*
 * winUpdateRgn - Local function to update a Windows window region
 */

static
void
winUpdateRgn (WindowPtr pWin)
{
#if 1
  SetWindowRgn (winGetWindowPriv(pWin)->hWnd,
		winGetWindowPriv(pWin)->hRgn, TRUE);
#endif
}


/*
 * winReshape - Computes the composite clipping region for a window
 */

#ifdef SHAPE
static
void
winReshape (WindowPtr pWin)
{
  int		nRects;
  ScreenPtr	pScreen = pWin->drawable.pScreen;
  RegionRec	rrNewShape;
  BoxPtr	pShape, pRects, pEnd;
  HRGN		hRgn, hRgnRect;
  winWindowPriv(pWin);

#if CYGDEBUG
  ErrorF ("winReshape ()\n");
#endif
  
  /* Bail if the window is the root window */
  if (pWin->parent == NULL)
    return;

  /* Bail if the window is not top level */
  if (pWin->parent->parent != NULL)
    return;

  /* Bail if Windows window handle is invalid */
  if (pWinPriv->hWnd == NULL)
    return;
  
  /* Free any existing window region stored in the window privates */
  if (pWinPriv->hRgn != NULL)
    {
      DeleteObject (pWinPriv->hRgn);
      pWinPriv->hRgn = NULL;
    }
  
  /* Bail if the window has no bounding region defined */
  if (!wBoundingShape (pWin))
    return;

  REGION_INIT(pScreen, &rrNewShape, NullBox, 0);
  REGION_COPY(pScreen, &rrNewShape, wBoundingShape(pWin));
  REGION_TRANSLATE(pScreen,
		   &rrNewShape,
		   pWin->borderWidth,
                   pWin->borderWidth);
  
  nRects = REGION_NUM_RECTS(&rrNewShape);
  pShape = REGION_RECTS(&rrNewShape);
  
  /* Don't do anything if there are no rectangles in the region */
  if (nRects > 0)
    {
      RECT			rcClient;
      RECT			rcWindow;
      int			iOffsetX, iOffsetY;
      
      /* Get client rectangle */
      if (!GetClientRect (pWinPriv->hWnd, &rcClient))
	{
	  ErrorF ("winReshape - GetClientRect failed, bailing: %d\n",
		  GetLastError ());
	  return;
	}

      /* Translate client rectangle coords to screen coords */
      /* NOTE: Only transforms top and left members */
      ClientToScreen (pWinPriv->hWnd, (LPPOINT) &rcClient);

      /* Get window rectangle */
      if (!GetWindowRect (pWinPriv->hWnd, &rcWindow))
	{
	  ErrorF ("winReshape - GetWindowRect failed, bailing: %d\n",
		  GetLastError ());
	  return;
	}

      /* Calculate offset from window upper-left to client upper-left */
      iOffsetX = rcClient.left - rcWindow.left;
      iOffsetY = rcClient.top - rcWindow.top;

      /* Create initial Windows region for title bar */
      /* FIXME: Mean, nasty, ugly hack!!! */
      hRgn = CreateRectRgn (0, 0, rcWindow.right, iOffsetY);
      if (hRgn == NULL)
	{
	  ErrorF ("winReshape - Initial CreateRectRgn (%d, %d, %d, %d) "
		  "failed: %d\n",
		  0, 0, rcWindow.right, iOffsetY, GetLastError ());
	}

      /* Loop through all rectangles in the X region */
      for (pRects = pShape, pEnd = pShape + nRects; pRects < pEnd; pRects++)
        {
	  /* Create a Windows region for the X rectangle */
	  hRgnRect = CreateRectRgn (pRects->x1 + iOffsetX - 1,
				    pRects->y1 + iOffsetY - 1,
				    pRects->x2 + iOffsetX - 1,
				    pRects->y2 + iOffsetY - 1);
	  if (hRgnRect == NULL)
	    {
	      ErrorF ("winReshape - Loop CreateRectRgn (%d, %d, %d, %d) "
		      "failed: %d\n"
		      "\tx1: %d x2: %d xOff: %d y1: %d y2: %d yOff: %d\n",
		      pRects->x1 + iOffsetX - 1,
		      pRects->y1 + iOffsetY - 1,
		      pRects->x2 + iOffsetX - 1,
		      pRects->y2 + iOffsetY - 1,
		      GetLastError (),
		      pRects->x1, pRects->x2, iOffsetX,
		      pRects->y1, pRects->y2, iOffsetY);
	    }

	  /* Merge the Windows region with the accumulated region */
	  if (CombineRgn (hRgn, hRgn, hRgnRect, RGN_OR) == ERROR)
	    {
	      ErrorF ("winReshape - CombineRgn () failed: %d\n",
		      GetLastError ());
	    }

	  /* Delete the temporary Windows region */
	  DeleteObject (hRgnRect);
        }
      
      /* Save a handle to the composite region in the window privates */
      pWinPriv->hRgn = hRgn;
    }

  REGION_UNINIT(pScreen, &rrNewShape);
  
  return;
}
#endif


/*
 * winTopLevelWindowProc - Window procedure for all top-level Windows windows.
 */

LRESULT CALLBACK
winTopLevelWindowProc (HWND hwnd, UINT message, 
		       WPARAM wParam, LPARAM lParam)
{
  POINT			ptMouse;
  HDC			hdcUpdate;
  PAINTSTRUCT		ps;
  WindowPtr		pWin = NULL;
  winPrivWinPtr	        pWinPriv = NULL;
  ScreenPtr		s_pScreen = NULL;
  winPrivScreenPtr	s_pScreenPriv = NULL;
  winScreenInfo		*s_pScreenInfo = NULL;
  HWND			hwndScreen = NULL;
  DrawablePtr		pDraw = NULL;
  int		        iX, iY, iWidth, iHeight, iBorder;
  winWMMessageRec	wmMsg;
  static Bool		s_fTracking = FALSE;
  static Bool           s_fCursor = TRUE;
  
  /* Check if the Windows window property for our X window pointer is valid */
  if ((pWin = GetProp (hwnd, WIN_WINDOW_PROP)) != NULL)
    {
      /* Our X window pointer is valid */

      /* Get pointers to the drawable and the screen */
      pDraw		= &pWin->drawable;
      s_pScreen		= pWin->drawable.pScreen;

      /* Get a pointer to our window privates */
      pWinPriv		= winGetWindowPriv(pWin);

      /* Get pointers to our screen privates and screen info */
      s_pScreenPriv	= pWinPriv->pScreenPriv;
      s_pScreenInfo	= s_pScreenPriv->pScreenInfo;

      /* Get the handle for our screen-sized window */
      /* NOTE: This will be going away at some point, right?  Harold Hunt - 2003/01/15 */
      hwndScreen	= s_pScreenPriv->hwndScreen;

      /* */
      wmMsg.msg		= 0;
      wmMsg.hwndWindow	= hwnd;
      wmMsg.iWindow	= (Window)GetProp (hwnd, WIN_WID_PROP);

#if 1
      wmMsg.iX		= pWinPriv->iX;
      wmMsg.iY		= pWinPriv->iY;
      wmMsg.iWidth	= pWinPriv->iWidth;
      wmMsg.iHeight	= pWinPriv->iHeight;
#else
      wmMsg.iX		= pDraw.x;
      wmMsg.iY		= pDraw.y;
      wmMsg.iWidth	= pDraw.width;
      wmMsg.iHeight	= pDraw.height;
#endif


#if 0
      /*
       * Print some debugging information
       */

      ErrorF ("hWnd %08X\n", hwnd);
      ErrorF ("pWin %08X\n", pWin);
      ErrorF ("pDraw %08X\n", pDraw);
      ErrorF ("\ttype %08X\n", pWin->drawable.type);
      ErrorF ("\tclass %08X\n", pWin->drawable.class);
      ErrorF ("\tdepth %08X\n", pWin->drawable.depth);
      ErrorF ("\tbitsPerPixel %08X\n", pWin->drawable.bitsPerPixel);
      ErrorF ("\tid %08X\n", pWin->drawable.id);
      ErrorF ("\tx %08X\n", pWin->drawable.x);
      ErrorF ("\ty %08X\n", pWin->drawable.y);
      ErrorF ("\twidth %08X\n", pWin->drawable.width);
      ErrorF ("\thenght %08X\n", pWin->drawable.height);
      ErrorF ("\tpScreen %08X\n", pWin->drawable.pScreen);
      ErrorF ("\tserialNumber %08X\n", pWin->drawable.serialNumber);
      ErrorF ("g_iWindowPrivateIndex %d\n", g_iWindowPrivateIndex);
      ErrorF ("pWinPriv %08X\n", pWinPriv);
      ErrorF ("s_pScreenPriv %08X\n", s_pScreenPriv);
      ErrorF ("s_pScreenInfo %08X\n", s_pScreenInfo);
      ErrorF ("hwndScreen %08X\n", hwndScreen);
#endif
    }



  /* Branch on message type */
  switch (message)
    {
    case WM_CREATE:
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winTopLevelWindowProc - WM_CREATE\n");
#endif

      /* */
      SetProp (hwnd,
	       WIN_WINDOW_PROP,
	       (HANDLE)((LPCREATESTRUCT) lParam)->lpCreateParams);
      
      /* */
      SetProp (hwnd,
	       WIN_WID_PROP,
	       (HANDLE)winGetWindowID (((LPCREATESTRUCT) lParam)->lpCreateParams));
      return 0;
      
    case WM_PAINT:
      /* Only paint if our window handle is valid */
      if (hwndScreen == NULL)
	break;

      /* BeginPaint gives us an hdc that clips to the invalidated region */
      hdcUpdate = BeginPaint (hwnd, &ps);

#if 0
      /* NOTE: Doesn't appear to be used - Harold Hunt - 2003/01/15 */
      /* Get the dimensions of the client area */
      GetClientRect (hwnd, &rcClient);
#endif

      /* Get the position and dimensions of the window */
      iBorder = wBorderWidth (pWin);
      iX = pWin->drawable.x;
      iY = pWin->drawable.y;
      iWidth = pWin->drawable.width;
      iHeight = pWin->drawable.height;

      /* Try to copy from the shadow buffer */
      if (!BitBlt (hdcUpdate,
		   0, 0,
		   iWidth, iHeight,
		   s_pScreenPriv->hdcShadow,
		   iX, iY,
		   SRCCOPY))
	{
	  LPVOID lpMsgBuf;
	  
	  /* Display a fancy error message */
	  FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | 
			 FORMAT_MESSAGE_FROM_SYSTEM | 
			 FORMAT_MESSAGE_IGNORE_INSERTS,
			 NULL,
			 GetLastError (),
			 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			 (LPTSTR) &lpMsgBuf,
			 0, NULL);

	  ErrorF ("winTopLevelWindowProc - BitBlt failed: %s\n",
		  (LPSTR)lpMsgBuf);
	  LocalFree (lpMsgBuf);
	}

      /* EndPaint frees the DC */
      EndPaint (hwndScreen, &ps);
      return 0;


#if 1
    case WM_MOUSEMOVE:
      /* Unpack the client area mouse coordinates */
      ptMouse.x = GET_X_LPARAM(lParam);
      ptMouse.y = GET_Y_LPARAM(lParam);

      /* Translate the client area mouse coordinates to screen coordinates */
      ClientToScreen (hwnd, &ptMouse);

      /* We can't do anything without privates */
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;

      /* Has the mouse pointer crossed screens? */
      if (s_pScreen != miPointerCurrentScreen ())
	miPointerSetNewScreen (s_pScreenInfo->dwScreen,
			       ptMouse.x - s_pScreenInfo->dwXOffset,
			       ptMouse.y - s_pScreenInfo->dwYOffset);

      /* Are we tracking yet? */
      if (!s_fTracking)
	{
	  TRACKMOUSEEVENT		tme;
	  
	  /* Setup data structure */
	  ZeroMemory (&tme, sizeof (tme));
	  tme.cbSize = sizeof (tme);
	  tme.dwFlags = TME_LEAVE;
	  tme.hwndTrack = hwnd;

	  /* Call the tracking function */
	  if (!(*g_fpTrackMouseEvent) (&tme))
	    ErrorF ("winTopLevelWindowProc - _TrackMouseEvent failed\n");

	  /* Flag that we are tracking now */
	  s_fTracking = TRUE;
	}
      
      /* Hide or show the Windows mouse cursor */
      if (s_fCursor)
	{
	  /* Hide Windows cursor */
	  s_fCursor = FALSE;
	  ShowCursor (FALSE);
	  KillTimer (hwnd, s_nIDPollingMouse);
	}

      /* Deliver absolute cursor position to X Server */
      miPointerAbsoluteCursor (ptMouse.x - s_pScreenInfo->dwXOffset,
			       ptMouse.y - s_pScreenInfo->dwYOffset,
			       g_c32LastInputEventTime = GetTickCount ());
      return 0;
      
    case WM_NCMOUSEMOVE:
      /*
       * We break instead of returning 0 since we need to call
       * DefWindowProc to get the mouse cursor changes
       * and min/max/close button highlighting in Windows XP.
       * The Platform SDK says that you should return 0 if you
       * process this message, but it fails to mention that you
       * will give up any default functionality if you do return 0.
       */
      
      /* We can't do anything without privates */
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;

      /* Non-client mouse movement, show Windows cursor */
      if (!s_fCursor)
	{
	  s_fCursor = TRUE;
	  ShowCursor (TRUE);
	  SetTimer (hwnd, s_nIDPollingMouse, MOUSE_POLLING_INTERVAL, NULL);
	}
      break;

    case WM_MOUSELEAVE:
      /* Mouse has left our client area */

      /* Flag that we are no longer tracking */
      s_fTracking = FALSE;

      /* Show the mouse cursor, if necessary */
      if (!s_fCursor)
	{
	  s_fCursor = TRUE;
	  ShowCursor (TRUE);
	  SetTimer (hwnd, s_nIDPollingMouse, MOUSE_POLLING_INTERVAL, NULL);
	}
      return 0;

    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
      return winMouseButtonsHandle (s_pScreen, ButtonPress, Button1, wParam);
      
    case WM_LBUTTONUP:
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
      return winMouseButtonsHandle (s_pScreen, ButtonRelease, Button1, wParam);

    case WM_MBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
      return winMouseButtonsHandle (s_pScreen, ButtonPress, Button2, wParam);
      
    case WM_MBUTTONUP:
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
      return winMouseButtonsHandle (s_pScreen, ButtonRelease, Button2, wParam);
      
    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
      return winMouseButtonsHandle (s_pScreen, ButtonPress, Button3, wParam);
      
    case WM_RBUTTONUP:
      if (s_pScreenPriv == NULL || s_pScreenInfo->fIgnoreInput)
	break;
      return winMouseButtonsHandle (s_pScreen, ButtonRelease, Button3, wParam);

#else

    case WM_MOUSEMOVE:
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winTopLevelWindowProc - WM_MOUSEMOVE*\n");
#endif

      /* Unpack the client area mouse coordinates */
      ptMouse.x = GET_X_LPARAM(lParam);
      ptMouse.y = GET_Y_LPARAM(lParam);

      /* Translate the client area mouse coordinates to screen coordinates */
      ClientToScreen (hwnd, &ptMouse);

      /* Pass the message to the root window */
      SendMessage (hwndScreen, message, wParam, MAKELONG(ptMouse.x, ptMouse.y));
      return  0;

    case WM_NCMOUSEMOVE:
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_MBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_MOUSELEAVE:
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winTopLevelWindowProc - WM_*BUTTON*\n");
#endif

      /* Pass the message to the root window */
      SendMessage(hwndScreen, message, wParam, MAKELONG(ptMouse.x, ptMouse.y));
      return  0;
#endif

    case WM_MOUSEWHEEL:
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winTopLevelWindowProc - WM_MOUSEWHEEL\n");
#endif
      
      /* Pass the message to the root window */
      SendMessage(hwndScreen, message, wParam, lParam);
      return 0;

    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
    case WM_SYSDEADCHAR:
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_DEADCHAR:
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winTopLevelWindowProc - WM_*KEY*\n");
#endif

      /* Pass the message to the root window */
      SendMessage (hwndScreen, message, wParam, lParam);
      return 0;

    case WM_HOTKEY:
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winTopLevelWindowProc - WM_HOTKEY\n");
#endif

      /* Pass the message to the root window */
      SendMessage (hwndScreen, message, wParam, lParam);
      return 0;


#if 1
    case WM_ACTIVATE:
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winTopLevelWindowProc - WM_ACTIVATE\n");
#endif

      /* Pass the message to the root window */
      SendMessage (hwndScreen, message, wParam, lParam);

      /* Bail if inactivating */
      if (LOWORD(wParam) == WA_INACTIVE)
	return 0;

      /* Check if the current window is the active window in Windows */
      if (GetActiveWindow () == hwnd)
	{
	  /* Tell our Window Manager thread to raise the window */
	  wmMsg.msg = WM_WM_RAISE;
	  winSendMessageToWM (s_pScreenPriv->pWMInfo, &wmMsg);
	}
      
      /* Tell our Window Manager thread to activate the window */
      wmMsg.msg = WM_WM_ACTIVATE;
      winSendMessageToWM (s_pScreenPriv->pWMInfo, &wmMsg);
	  
      return 0;

    case WM_ACTIVATEAPP:
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winTopLevelWindowProc - WM_ACTIVATEAPP\n");
#endif
      
      /* Pass the message to the root window */
      SendMessage (hwndScreen, message, wParam, lParam);
      return 0;
#endif


    case WM_CLOSE:
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winTopLevelWindowProc - WM_CLOSE\n");
#endif
      /* Branch on if the window was killed in X already */
      if (pWinPriv->fXKilled)
        {
	  /* Window was killed, go ahead and destroy the window */
	  DestroyWindow (hwnd);
	}
      else
	{
	  /* Tell our Window Manager thread to kill the window */
	  wmMsg.msg = WM_WM_KILL;
	  winSendMessageToWM (s_pScreenPriv->pWMInfo, &wmMsg);
	}
      return 0;

    case WM_DESTROY:
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winTopLevelWindowProc - WM_DESTROY\n");
#endif

      /* Branch on if the window was killed in X already */
      if (pWinPriv && !pWinPriv->fXKilled)
	{
	  ErrorF ("winTopLevelWindowProc - WM_DESTROY - WM_WM_KILL\n");
	  
	  /* Tell our Window Manager thread to kill the window */
	  wmMsg.msg = WM_WM_KILL;
	  winSendMessageToWM (s_pScreenPriv->pWMInfo, &wmMsg);
	}

#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winTopLevelWindowProc - WM_DESTROY\n");
#endif
      break;

    case WM_MOVE:
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winTopLevelWindowProc - WM_MOVE - %d ms\n", GetTickCount ());
#endif
      
      /* Bail if Windows window is not actually moving */
      if (pWinPriv->iX == (short) LOWORD(lParam)
	  && pWinPriv->iY == (short) HIWORD(lParam))
	break;

      /* Get new position */
      pWinPriv->iX = (short) LOWORD(lParam);
      pWinPriv->iY = (short) HIWORD(lParam);

#if CYGMULTIWINDOW_DEBUG
      ErrorF ("\t(%d, %d)\n", pWinPriv->iX, pWinPriv->iY);
#endif

      /* Notify the X client that its window is moving */
      if (SubStrSend(pWin, pWin->parent))
	SendConfigureNotify (pWin);

      /* Tell X that the window is moving */
      (s_pScreen->MoveWindow) (pWin,
			       (int)(short) LOWORD(lParam) - wBorderWidth (pWin),
			       (int)(short) HIWORD(lParam) - wBorderWidth (pWin),
			       pWin->nextSib,
			       VTMove);
      return 0;

    case WM_SHOWWINDOW:
      /* Bail out if the window is being hidden */
      if (!wParam)
	return 0;

      /* Tell X to map the window */
      MapWindow (pWin, wClient(pWin));

      /* */
      if (!pWin->overrideRedirect)
	{
	  DWORD		dwExStyle;
	  DWORD		dwStyle;
	  RECT		rcNew;
	  int		iDx, iDy;
	      
	  /* Flag that this window needs to be made active when clicked */
	  SetProp (hwnd, WIN_NEEDMANAGE_PROP, (HANDLE) 1);

	  /* Get the standard and extended window style information */
	  dwExStyle = GetWindowLongPtr (hwnd, GWL_EXSTYLE);
	  dwStyle = GetWindowLongPtr (hwnd, GWL_STYLE);

	  /* */
	  if (dwExStyle != WS_EX_APPWINDOW)
	    {
	      /* Setup a rectangle with the X window position and size */
	      SetRect (&rcNew,
		       pWinPriv->iX,
		       pWinPriv->iY,
		       pWinPriv->iX + pWinPriv->iWidth,
		       pWinPriv->iY + pWinPriv->iHeight);

#if 0
	      ErrorF ("winTopLevelWindowProc - (%d, %d)-(%d, %d)\n",
		      rcNew.left, rcNew.top,
		      rcNew.right, rcNew.bottom);
#endif

	      /* */
	      AdjustWindowRectEx (&rcNew,
				  WS_POPUP | WS_SIZEBOX | WS_OVERLAPPEDWINDOW,
				  FALSE,
				  WS_EX_APPWINDOW);

	      /* Calculate position deltas */
	      iDx = pWinPriv->iX - rcNew.left;
	      iDy = pWinPriv->iY - rcNew.top;

	      /* Calculate new rectangle */
	      rcNew.left += iDx;
	      rcNew.right += iDx;
	      rcNew.top += iDy;
	      rcNew.bottom += iDy;

#if 0
	      ErrorF ("winTopLevelWindowProc - (%d, %d)-(%d, %d)\n",
		      rcNew.left, rcNew.top,
		      rcNew.right, rcNew.bottom);
#endif

	      /* Set the window extended style flags */
	      SetWindowLongPtr (hwnd, GWL_EXSTYLE, WS_EX_APPWINDOW);

	      /* Set the window standard style flags */
	      SetWindowLongPtr (hwnd, GWL_STYLE, WS_POPUP | WS_SIZEBOX | WS_OVERLAPPEDWINDOW);

	      /* Positon the Windows window */
	      SetWindowPos (hwnd, HWND_TOP,
			    rcNew.left, rcNew.top,
			    rcNew.right - rcNew.left, rcNew.bottom - rcNew.top,
			    SWP_NOMOVE | SWP_FRAMECHANGED | SWP_SHOWWINDOW | SWP_NOACTIVATE);

	      /* Bring the Window window to the foreground */
	      SetForegroundWindow (hwnd);
	    }
	}
	  
      /* Setup the Window Manager message */
      wmMsg.msg = WM_WM_MAP;
      wmMsg.iWidth = pWinPriv->iWidth;
      wmMsg.iHeight = pWinPriv->iHeight;

      /* Tell our Window Manager thread to map the window */
      winSendMessageToWM (s_pScreenPriv->pWMInfo, &wmMsg);

      /* Setup the Window Manager message */
      wmMsg.msg = WM_WM_RAISE;

      /* Tell our Window Manager thread to raise the window */
      winSendMessageToWM (s_pScreenPriv->pWMInfo, &wmMsg);
      return 0;

    case WM_SIZE:
      /* see dix/window.c */

#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winTopLevelWindowProc - WM_SIZE - %d ms\n", GetTickCount ());
#endif

      switch (wParam)
	{
	case SIZE_MINIMIZED:
#if CYGMULTIWINDOW_DEBUG
	  ErrorF ("\tSIZE_MINIMIZED\n");
#endif
	  
	  wmMsg.msg = WM_WM_LOWER;

	  /* Tell our Window Manager thread to lower the window */
	  winSendMessageToWM (s_pScreenPriv->pWMInfo, &wmMsg);
	  break;

	case SIZE_RESTORED:
	case SIZE_MAXIMIZED:
	  if (pWinPriv->iWidth == (short) LOWORD(lParam)
	      && pWinPriv->iHeight == (short) HIWORD(lParam))
	    break;
	  
	  /* Get the dimensions of the Windows window */
	  pWinPriv->iWidth = (short) LOWORD(lParam);
	  pWinPriv->iHeight = (short) HIWORD(lParam);

#if CYGMULTIWINDOW_DEBUG
	  ErrorF ("\t(%d, %d)\n", pWinPriv->iWidth, pWinPriv->iHeight);
#endif

	  /* Check if resize events are redirected */
	  if ((pWin->eventMask | wOtherEventMasks (pWin)) & ResizeRedirectMask)
	    {
	      xEvent		eventT;

	      /* Setup the X event structure */
	      eventT.u.u.type = ResizeRequest;
	      eventT.u.resizeRequest.window = pWin->drawable.id;
	      eventT.u.resizeRequest.width = pWinPriv->iWidth;
	      eventT.u.resizeRequest.height = pWinPriv->iHeight;

	      /* */
	      if (MaybeDeliverEventsToClient (pWin, &eventT, 1,
					      ResizeRedirectMask,
					      wClient(pWin)) == 1)
		break;
	    }

	  /* Notify the X client that its window is being resized */
	  if (SubStrSend (pWin, pWin->parent))
	    SendConfigureNotify (pWin);
	  
	  /* Tell the X server that the window is being resized */
	  (s_pScreen->ResizeWindow) (pWin,
				     pWinPriv->iX - wBorderWidth (pWin),
				     pWinPriv->iY - wBorderWidth (pWin),
				     pWinPriv->iWidth,
				     pWinPriv->iHeight,
				     pWin->nextSib);

	  /* Tell X to redraw the exposed portions of the window */
	  {
	    RegionRec		temp;

	    /* Get the region describing the X window clip list */
	    REGION_INIT(s_pScreen, &temp, NullBox, 0);
	    REGION_COPY(s_pScreen, &temp, &pWin->clipList);

	    /* Expose the clipped region */
	    (*s_pScreen->WindowExposures) (pWin, &temp, NullRegion);

	    /* Free the region */
	    REGION_UNINIT(s_pScreen, &temp);
	  }
	  break;

#if 0
	case SIZE_MAXIMIZED:
#if CYGMULTIWINDOW_DEBUG
	  ErrorF ("\tSIZE_MAXIMIZED\n");
#endif

	  /* Get the dimensions of the window */
	  pWinPriv->iWidth = (int)(short) LOWORD(lParam);
	  pWinPriv->iHeight = (int)(short) HIWORD(lParam);

#if CYGMULTIWINDOW_DEBUG
	  ErrorF ("\t(%d, %d)\n", pWinPriv->iWidth, pWinPriv->iHeight);
#endif

	  /* */
	  if ((pWin->eventMask|wOtherEventMasks(pWin)) & ResizeRedirectMask)
	    {
	      xEvent		eventT;
	      
	      eventT.u.u.type = ResizeRequest;
	      eventT.u.resizeRequest.window = pWin->drawable.id;
	      eventT.u.resizeRequest.width = pWinPriv->iWidth;
	      eventT.u.resizeRequest.height = pWinPriv->iHeight;
	      if (MaybeDeliverEventsToClient (pWin, &eventT, 1,
					      ResizeRedirectMask,
					      wClient(pWin)) == 1);
	    }
	  
	  
	  (s_pScreen->ResizeWindow) (pWin,
				     pWinPriv->iX - wBorderWidth (pWin),
				     pWinPriv->iY - wBorderWidth (pWin),
				     pWinPriv->iWidth,
				     pWinPriv->iHeight,
				     pWin->nextSib);
	  break;
#endif

	default:
	  break;
	}
      return 0;

    case WM_MOUSEACTIVATE:
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winTopLevelWindowProc - WM_MOUSEACTIVATE\n");
#endif

      /* Check if this window needs to be made active when clicked */
      if (!GetProp (pWinPriv->hWnd, WIN_NEEDMANAGE_PROP))
	{
#if CYGMULTIWINDOW_DEBUG
	  ErrorF ("winTopLevelWindowProc - WM_MOUSEACTIVATE - MA_NOACTIVATE\n");
#endif

	  /* */
	  return MA_NOACTIVATE;
	}
      break;

    case WM_TIMER:
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winTopLevelWindowProc - WM_TIMER - %d ms\n", GetTickCount ());
#endif
      
      /* Branch on the type of timer event that fired */
      if (wParam == s_nIDPollingMouse)
	{
	  POINT		point;

	  /* Get the current position of the mouse cursor */
	  GetCursorPos (&point);

	  /* Deliver absolute cursor position to X Server */
	  miPointerAbsoluteCursor (point.x, point.y,
				   g_c32LastInputEventTime = GetTickCount ());
	}
      else
	{
	  ErrorF ("winTopLevelWindowProc - Unknown WM_TIMER\n");
	}
      return 0;

    default:
      break;
    }

  return DefWindowProc (hwnd, message, wParam, lParam);
}


/*
 * winCreateWindowsWindow - Create a Windows window associated with an X window
 */

static void
winCreateWindowsWindow (WindowPtr pWin)
{
  int                   iX, iY;
  int			iWidth;
  int			iHeight;
  int                   iBorder;
  HWND			hWnd;
  WNDCLASS		wc;
  winWindowPriv(pWin);

#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winCreateWindowsWindow - pWin: %08x\n", pWin);
#endif

  iBorder = wBorderWidth (pWin);
  
  iX = pWin->drawable.x;
  iY = pWin->drawable.y;
  
  iWidth = pWin->drawable.width;
  iHeight = pWin->drawable.height;
  
  /* Setup our window class */
  wc.style = CS_HREDRAW | CS_VREDRAW;
  wc.lpfnWndProc = winTopLevelWindowProc;
  wc.cbClsExtra = 0;
  wc.cbWndExtra = 0;
  wc.hInstance = g_hInstance;
  wc.hIcon = LoadIcon (g_hInstance, MAKEINTRESOURCE(IDI_XWIN));
  wc.hCursor = 0;
  wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
  wc.lpszMenuName = NULL;
  wc.lpszClassName = WINDOW_CLASS_X;
  RegisterClass (&wc);

  /* Create the window */
  hWnd = CreateWindowExA (WS_EX_TOOLWINDOW,			/* Extended styles */
			  WINDOW_CLASS_X,			/* Class name */
			  WINDOW_TITLE_X,			/* Window name */
			  WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
			  iX,					/* Horizontal position */
			  iY,					/* Vertical position */
			  iWidth,				/* Right edge */ 
			  iHeight,				/* Bottom edge */
			  (HWND) NULL,				/* No parent or owner window */
			  (HMENU) NULL,				/* No menu */
			  GetModuleHandle (NULL),		/* Instance handle */
			  pWin);				/* ScreenPrivates */
  if (hWnd == NULL)
    {
      ErrorF ("winCreateWindowsWindow - CreateWindowExA () failed: %d\n",
	      GetLastError ());
    }
  
  pWinPriv->hWnd = hWnd;


  SetProp (pWinPriv->hWnd, WIN_WID_PROP, (HANDLE) winGetWindowID(pWin));

  /* Flag that this Windows window handles its own activation */
  SetProp (pWinPriv->hWnd, WIN_NEEDMANAGE_PROP, (HANDLE) 0);
}


/*
 * winDestroyWindowsWindow - Destroy a Windows window associated with an X window
 */

static void
winDestroyWindowsWindow (WindowPtr pWin)
{
  MSG			msg;
  winWindowPriv(pWin);
  
#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winDestroyWindowsWindow\n");
#endif


  /* Bail out if the Windows window handle is invalid */
  if (pWinPriv->hWnd == NULL)
    return;


  SetProp (pWinPriv->hWnd, WIN_WINDOW_PROP, 0);
  
  DestroyWindow (pWinPriv->hWnd);

  pWinPriv->hWnd = NULL;
  
  /* Process all messages on our queue */
  while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE))
    {
      if (g_hDlgDepthChange == 0 || !IsDialogMessage (g_hDlgDepthChange, &msg))
	{
	  DispatchMessage (&msg);
	}
    }
  
#if CYGMULTIWINDOW_DEBUG
  ErrorF ("-winDestroyWindowsWindow\n");
#endif
}


/*
 * winUpdateWindowsWindow - Redisplay/redraw a Windows window associated with an X window
 */

static void
winUpdateWindowsWindow (WindowPtr pWin)
{
  winWindowPriv(pWin);
  HWND			hWnd = pWinPriv->hWnd;

#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winUpdateWindowsWindow\n");
#endif

  /* Check if the Windows window's parents have been destroyed */
  if (pWin->parent != NULL
      && pWin->parent->parent == NULL
      && pWin->mapped)
    {
      /* Create the Windows window if it has been destroyed */
      if (hWnd == NULL)
	{
	  winCreateWindowsWindow (pWin);
	  assert (pWinPriv->hWnd != NULL);
	}

      /* Display the window without activating it */
      ShowWindow (pWinPriv->hWnd, SW_SHOWNOACTIVATE);

      /* Send first paint message */
      UpdateWindow (pWinPriv->hWnd);
    }
  else if (hWnd != NULL)
    {
      /* Destroy the Windows window if its parents are destroyed */
      winDestroyWindowsWindow (pWin);
      assert (pWinPriv->hWnd == NULL);
    }

#if CYGMULTIWINDOW_DEBUG
  ErrorF ("-winUpdateWindowsWindow\n");
#endif
}








typedef struct {
    pointer		value;
    XID			id;
} WindowIDPairRec, *WindowIDPairPtr;





/*
 * winFindWindow - 
 */

static void
winFindWindow (pointer value, XID id, pointer cdata)
{
  WindowIDPairPtr	wi = (WindowIDPairPtr)cdata;

  if (value == wi->value)
    {
      wi->id = id;
    }
}


/*
 * winGetWindowID - 
 */

static XID
winGetWindowID (WindowPtr pWin)
{
  WindowIDPairRec	wi = {pWin, 0};
  ClientPtr		c = wClient(pWin);
  
  /* */
  FindClientResourcesByType (c, RT_WINDOW, winFindWindow, &wi);

#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winGetWindowID - Window ID: %d\n", wi.id);
#endif

  return wi.id;
}


/*
 * SendConfigureNotify - 
 */

static void
SendConfigureNotify(WindowPtr pWin)
{
  xEvent		event;
  winWindowPriv(pWin);

  event.u.u.type = ConfigureNotify;
  event.u.configureNotify.window = pWin->drawable.id;

  if (pWin->nextSib)
    event.u.configureNotify.aboveSibling = pWin->nextSib->drawable.id;
  else
    event.u.configureNotify.aboveSibling = None;

  event.u.configureNotify.x = pWinPriv->iX - wBorderWidth (pWin);
  event.u.configureNotify.y = pWinPriv->iY - wBorderWidth (pWin);

  event.u.configureNotify.width = pWinPriv->iWidth;
  event.u.configureNotify.height = pWinPriv->iHeight;

  event.u.configureNotify.borderWidth = wBorderWidth (pWin);

  event.u.configureNotify.override = pWin->overrideRedirect;

  /* */
  DeliverEvents (pWin, &event, 1, NullWindow);
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@a28 2
 *		Earle F. Philhower, III
 *		Harold L Hunt II
d30 1
a30 1
/* $XFree86: xc/programs/Xserver/hw/xwin/winmultiwindowwindow.c,v 1.3 2003/10/02 13:30:10 eich Exp $ */
a33 9
#include "winmultiwindowclass.h"
#include "winprefs.h"


/*
 * External global variables
 */

extern HICON		g_hiconX;
d49 3
d53 18
a70 1
winFindWindow (pointer value, XID id, pointer cdata);
d73 1
a73 2
static void
winRestackXWindow (WindowPtr pWin, int smode);
a80 1
#define MOUSE_POLLING_INTERVAL		500
d82 2
a120 1
  pWinPriv->fNeedRestore = FALSE;
d194 2
a195 2
  iX = pWin->drawable.x + GetSystemMetrics (SM_XVIRTUALSCREEN);
  iY = pWin->drawable.y + GetSystemMetrics (SM_YVIRTUALSCREEN);
d339 3
a341 4
#ifdef SHAPE
  /* Update the Windows window's shape */
  winReshapeMultiWindow (pWin);
  winUpdateRgnMultiWindow (pWin);
a378 1
  HWND                  hWnd = NULL;
a389 3
  if (winGetScreenPriv(pWin->drawable.pScreen)->fRestacking)
    return;

a411 16
  
      hWnd = GetNextWindow (pWinPriv->hWnd, GW_HWNDPREV);

      do
	{
	  if (GetProp (hWnd, WIN_WINDOW_PROP))
	    {
	      if (hWnd == winGetWindowPriv(pPrevWin)->hWnd)
		{
		  uFlags |= SWP_NOZORDER;
		}
	      break;
	    }
	  hWnd = GetNextWindow (hWnd, GW_HWNDPREV);
	}
      while (hWnd);
d430 46
a475 1
 * winCreateWindowsWindow - Create a Windows window associated with an X window
d478 4
a481 2
static void
winCreateWindowsWindow (WindowPtr pWin)
d483 5
a487 6
  int                   iX, iY;
  int			iWidth;
  int			iHeight;
  int                   iBorder;
  HWND			hWnd;
  WNDCLASS		wc;
a488 5
  HICON                 hIcon;
#define CLASS_NAME_LENGTH 512
  char                  pszClass[CLASS_NAME_LENGTH], pszWindowID[12];
  char                  *res_name, *res_class, *res_role;
  static int		s_iWindowID = 0;
d490 2
a491 2
#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winCreateWindowsWindow - pWin: %08x\n", pWin);
d493 4
d498 7
a504 1
  iBorder = wBorderWidth (pWin);
d506 6
a511 2
  iX = pWin->drawable.x + GetSystemMetrics (SM_XVIRTUALSCREEN);
  iY = pWin->drawable.y + GetSystemMetrics (SM_YVIRTUALSCREEN);
d513 3
a515 2
  iWidth = pWin->drawable.width;
  iHeight = pWin->drawable.height;
d517 6
a522 3
  /* Load default X icon in case it's not ready yet */
  if (!g_hiconX)
    g_hiconX = (HICON)winOverrideDefaultIcon();
d524 82
a605 2
  if (!g_hiconX)
    g_hiconX = LoadIcon (g_hInstance, MAKEINTRESOURCE(IDI_XWIN));
d607 27
a633 2
  /* Try and get the icon from WM_HINTS */
  hIcon = winXIconToHICON (pWin);
d635 36
a670 3
  /* Use default X icon if no icon loaded from WM_HINTS */
  if (!hIcon)
    hIcon = g_hiconX;
a671 2
  /* Set standard class name prefix so we can identify window easily */
  strncpy (pszClass, WINDOW_CLASS_X, strlen (WINDOW_CLASS_X));
d673 31
a703 1
  if (winMultiWindowGetClassHint (pWin, &res_name, &res_class))
d705 342
a1046 4
      strncat (pszClass, "-", 1);
      strncat (pszClass, res_name, CLASS_NAME_LENGTH - strlen (pszClass));
      strncat (pszClass, "-", 1);
      strncat (pszClass, res_class, CLASS_NAME_LENGTH - strlen (pszClass));
d1048 35
a1082 6
      /* Check if a window class is provided by the WM_WINDOW_ROLE property,
       * if not use the WM_CLASS information.
       * For further information see:
       * http://tronche.com/gui/x/icccm/sec-5.html
       */ 
      if (winMultiWindowGetWindowRole (pWin, &res_role) )
d1084 65
a1148 3
	  strcat (pszClass, "-");
	  strcat (pszClass, res_role);
	  free (res_role);
d1150 54
d1205 126
a1330 2
      free (res_name);
      free (res_class);
d1333 18
a1350 3
  /* Add incrementing window ID to make unique class name */
  sprintf (pszWindowID, "-%x", s_iWindowID++);
  strcat (pszClass, pszWindowID);
d1353 1
a1353 1
  ErrorF ("winCreateWindowsWindow - Creating class: %s\n", pszClass);
d1356 8
d1370 1
a1370 1
  wc.hIcon = hIcon;
d1374 1
a1374 1
  wc.lpszClassName = pszClass;
d1378 3
a1380 3
  hWnd = CreateWindowExA (WS_EX_TOOLWINDOW,	/* Extended styles */
			  pszClass,		/* Class name */
			  WINDOW_TITLE_X,	/* Window name */
d1382 8
a1389 8
			  iX,			/* Horizontal position */
			  iY,			/* Vertical position */
			  iWidth,		/* Right edge */ 
			  iHeight,		/* Bottom edge */
			  (HWND) NULL,		/* No parent or owner window */
			  (HMENU) NULL,		/* No menu */
			  GetModuleHandle (NULL), /* Instance handle */
			  pWin);		/* ScreenPrivates */
d1398 1
a1398 3
  /* Cause the "Always On Top" to be added in main WNDPROC */
  PostMessage (hWnd, WM_INIT_SYS_MENU, 0, 0);
  
d1407 1
a1407 2
 * winDestroyWindowsWindow - Destroy a Windows window associated
 * with an X window
a1414 4
  HICON			hiconClass;
  HMODULE		hInstance;
  int			iReturn;
  char			pszClass[512];
d1420 1
d1425 1
a1426 5

  /* Store the info we need to destroy after this window is gone */
  hInstance = (HINSTANCE) GetClassLong (pWinPriv->hWnd, GCL_HMODULE);
  hiconClass = (HICON) GetClassLong (pWinPriv->hWnd, GCL_HICON);
  iReturn = GetClassName (pWinPriv->hWnd, pszClass, 512);
a1427 1
  /* Destroy the Windows window */
a1429 1
  /* Null our handle to the Window so referencing it will cause an error */
d1440 1
a1440 24

  /* Only if we were able to get the name */
  if (iReturn)
    { 
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winDestroyWindowsWindow - Unregistering %s: ", pszClass);
#endif
      iReturn = UnregisterClass (pszClass, hInstance);
      
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winDestroyWindowsWindow - %d Deleting Icon: ", iReturn);
#endif
      
      /* Only delete if it's not the default */
      if (hiconClass != g_hiconX &&
	  !winIconIsOverride((unsigned long)hiconClass))
	{ 
	  iReturn = DestroyIcon (hiconClass);
#if CYGMULTIWINDOW_DEBUG
	  ErrorF ("winDestroyWindowsWindow - %d\n", iReturn);
#endif
	}
    }

d1448 1
a1448 2
 * winUpdateWindowsWindow - Redisplay/redraw a Windows window
 * associated with an X window
a1491 3
/*
 * winGetWindowID - 
 */
a1492 8
XID
winGetWindowID (WindowPtr pWin)
{
  WindowIDPairRec	wi = {pWin, 0};
  ClientPtr		c = wClient(pWin);
  
  /* */
  FindClientResourcesByType (c, RT_WINDOW, winFindWindow, &wi);
a1493 3
#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winGetWindowID - Window ID: %d\n", wi.id);
#endif
a1494 2
  return wi.id;
}
a1496 3
/*
 * winMoveXWindow - 
 */
d1498 4
a1501 4
void
winMoveXWindow (WindowPtr pWin, int x, int y)
{
  XID *vlist = malloc(sizeof(long)*2);
a1502 5
  (CARD32*)vlist[0] = x;
  (CARD32*)vlist[1] = y;
  ConfigureWindow (pWin, CWX | CWY, vlist, wClient(pWin));
  free(vlist);
}
a1504 14
/*
 * winResizeXWindow - 
 */

void
winResizeXWindow (WindowPtr pWin, int w, int h)
{
  XID *vlist = malloc(sizeof(long)*2);

  (CARD32*)vlist[0] = w;
  (CARD32*)vlist[1] = h;
  ConfigureWindow (pWin, CWWidth | CWHeight, vlist, wClient(pWin));
  free(vlist);
}
a1522 1
#if 0
d1524 1
a1524 1
 * winRestackXWindow - 
d1527 2
a1528 2
static void
winRestackXWindow (WindowPtr pWin, int smode)
d1530 5
a1534 1
  XID *vlist = malloc(sizeof(unsigned long));
d1536 3
a1538 5
  if (vlist == NULL)
    {
      ErrorF ("winRestackXWindow - malloc () failed\n");
      return;
    }
d1540 1
a1540 11
  if (pWin == NULL)
    {
      ErrorF ("winRestackXWindow - NULL window\n");
      free(vlist);
      return;
    }

  *((unsigned long*)vlist) = smode;
  ConfigureWindow (pWin, CWStackMode, vlist, wClient(pWin));

  free(vlist);
a1541 1
#endif
d1545 1
a1545 1
 * winReorderWindowsMultiWindow - 
d1548 2
a1549 2
void
winReorderWindowsMultiWindow (ScreenPtr pScreen)
d1551 2
a1552 4
  winScreenPriv(pScreen);
  HWND hwnd = NULL;
  WindowPtr pWin = NULL;
  WindowPtr pWinSib = NULL;
d1554 2
a1555 3
#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winOrderWindowsMultiWindow\n");
#endif
d1557 4
a1560 1
  pScreenPriv->fRestacking = TRUE;
d1562 2
a1563 6
  if (pScreenPriv->fWindowOrderChanged)
    {
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winOrderWindowsMultiWindow - Need to restack\n");
#endif
      hwnd = GetTopWindow (NULL);
d1565 2
a1566 30
      while (hwnd)
	{
	  if (GetProp (hwnd, WIN_WINDOW_PROP))
	    {
	      pWinSib = pWin;
	      pWin = GetProp (hwnd, WIN_WINDOW_PROP);
	      
	      if (pWinSib)
		{
		  XID *vlist = malloc (sizeof(long) * 2);
		  
		  if (vlist == NULL)
		    {
		      ErrorF ("winOrderWindowsMultiWindow - malloc () "
			      "failed\n");
		      return;
		    }
		  
		  ((long*)vlist)[0] = winGetWindowID (pWinSib);
		  ((long*)vlist)[1] = Below;

		  ConfigureWindow (pWin, CWSibling | CWStackMode,
				   vlist, wClient(pWin));
		  
		  free (vlist);
		}
	    }
	  hwnd = GetNextWindow (hwnd, GW_HWNDNEXT);
	}
    }
d1568 1
a1568 3
  pScreenPriv->fRestacking = FALSE;
  pScreenPriv->fWindowOrderChanged = FALSE;
}
d1570 1
d1572 2
a1573 15
/*
 * winMinimizeWindow - Minimize in response to WM_CHANGE_STATE
 */

void
winMinimizeWindow (Window id)
{
  WindowPtr		pWin;
  winPrivWinPtr	pWinPriv;
  
  pWin = LookupIDByType (id, RT_WINDOW);
  
  pWinPriv = winGetWindowPriv (pWin);
  
  ShowWindow (pWinPriv->hWnd, SW_MINIMIZE);
@


1.1.1.1
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@@


1.1.1.2
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@a28 2
 *		Earle F. Philhower, III
 *		Harold L Hunt II
d30 1
a30 1
/* $XFree86: xc/programs/Xserver/hw/xwin/winmultiwindowwindow.c,v 1.3 2003/10/02 13:30:10 eich Exp $ */
a33 9
#include "winmultiwindowclass.h"
#include "winprefs.h"


/*
 * External global variables
 */

extern HICON		g_hiconX;
d49 3
d53 18
a70 1
winFindWindow (pointer value, XID id, pointer cdata);
d73 1
a73 2
static void
winRestackXWindow (WindowPtr pWin, int smode);
a80 1
#define MOUSE_POLLING_INTERVAL		500
d82 2
a120 1
  pWinPriv->fNeedRestore = FALSE;
d194 2
a195 2
  iX = pWin->drawable.x + GetSystemMetrics (SM_XVIRTUALSCREEN);
  iY = pWin->drawable.y + GetSystemMetrics (SM_YVIRTUALSCREEN);
d339 3
a341 4
#ifdef SHAPE
  /* Update the Windows window's shape */
  winReshapeMultiWindow (pWin);
  winUpdateRgnMultiWindow (pWin);
a378 1
  HWND                  hWnd = NULL;
a389 3
  if (winGetScreenPriv(pWin->drawable.pScreen)->fRestacking)
    return;

a411 16
  
      hWnd = GetNextWindow (pWinPriv->hWnd, GW_HWNDPREV);

      do
	{
	  if (GetProp (hWnd, WIN_WINDOW_PROP))
	    {
	      if (hWnd == winGetWindowPriv(pPrevWin)->hWnd)
		{
		  uFlags |= SWP_NOZORDER;
		}
	      break;
	    }
	  hWnd = GetNextWindow (hWnd, GW_HWNDPREV);
	}
      while (hWnd);
d430 46
a475 1
 * winCreateWindowsWindow - Create a Windows window associated with an X window
d478 4
a481 2
static void
winCreateWindowsWindow (WindowPtr pWin)
d483 5
a487 6
  int                   iX, iY;
  int			iWidth;
  int			iHeight;
  int                   iBorder;
  HWND			hWnd;
  WNDCLASS		wc;
a488 5
  HICON                 hIcon;
#define CLASS_NAME_LENGTH 512
  char                  pszClass[CLASS_NAME_LENGTH], pszWindowID[12];
  char                  *res_name, *res_class, *res_role;
  static int		s_iWindowID = 0;
d490 2
a491 2
#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winCreateWindowsWindow - pWin: %08x\n", pWin);
d493 4
d498 7
a504 1
  iBorder = wBorderWidth (pWin);
d506 6
a511 2
  iX = pWin->drawable.x + GetSystemMetrics (SM_XVIRTUALSCREEN);
  iY = pWin->drawable.y + GetSystemMetrics (SM_YVIRTUALSCREEN);
d513 3
a515 2
  iWidth = pWin->drawable.width;
  iHeight = pWin->drawable.height;
d517 6
a522 3
  /* Load default X icon in case it's not ready yet */
  if (!g_hiconX)
    g_hiconX = (HICON)winOverrideDefaultIcon();
d524 82
a605 2
  if (!g_hiconX)
    g_hiconX = LoadIcon (g_hInstance, MAKEINTRESOURCE(IDI_XWIN));
d607 27
a633 2
  /* Try and get the icon from WM_HINTS */
  hIcon = winXIconToHICON (pWin);
d635 36
a670 3
  /* Use default X icon if no icon loaded from WM_HINTS */
  if (!hIcon)
    hIcon = g_hiconX;
a671 2
  /* Set standard class name prefix so we can identify window easily */
  strncpy (pszClass, WINDOW_CLASS_X, strlen (WINDOW_CLASS_X));
d673 31
a703 1
  if (winMultiWindowGetClassHint (pWin, &res_name, &res_class))
d705 342
a1046 4
      strncat (pszClass, "-", 1);
      strncat (pszClass, res_name, CLASS_NAME_LENGTH - strlen (pszClass));
      strncat (pszClass, "-", 1);
      strncat (pszClass, res_class, CLASS_NAME_LENGTH - strlen (pszClass));
d1048 35
a1082 6
      /* Check if a window class is provided by the WM_WINDOW_ROLE property,
       * if not use the WM_CLASS information.
       * For further information see:
       * http://tronche.com/gui/x/icccm/sec-5.html
       */ 
      if (winMultiWindowGetWindowRole (pWin, &res_role) )
d1084 65
a1148 3
	  strcat (pszClass, "-");
	  strcat (pszClass, res_role);
	  free (res_role);
d1150 54
d1205 126
a1330 2
      free (res_name);
      free (res_class);
d1333 18
a1350 3
  /* Add incrementing window ID to make unique class name */
  sprintf (pszWindowID, "-%x", s_iWindowID++);
  strcat (pszClass, pszWindowID);
d1353 1
a1353 1
  ErrorF ("winCreateWindowsWindow - Creating class: %s\n", pszClass);
d1356 8
d1370 1
a1370 1
  wc.hIcon = hIcon;
d1374 1
a1374 1
  wc.lpszClassName = pszClass;
d1378 3
a1380 3
  hWnd = CreateWindowExA (WS_EX_TOOLWINDOW,	/* Extended styles */
			  pszClass,		/* Class name */
			  WINDOW_TITLE_X,	/* Window name */
d1382 8
a1389 8
			  iX,			/* Horizontal position */
			  iY,			/* Vertical position */
			  iWidth,		/* Right edge */ 
			  iHeight,		/* Bottom edge */
			  (HWND) NULL,		/* No parent or owner window */
			  (HMENU) NULL,		/* No menu */
			  GetModuleHandle (NULL), /* Instance handle */
			  pWin);		/* ScreenPrivates */
d1398 1
a1398 3
  /* Cause the "Always On Top" to be added in main WNDPROC */
  PostMessage (hWnd, WM_INIT_SYS_MENU, 0, 0);
  
d1407 1
a1407 2
 * winDestroyWindowsWindow - Destroy a Windows window associated
 * with an X window
a1414 4
  HICON			hiconClass;
  HMODULE		hInstance;
  int			iReturn;
  char			pszClass[512];
d1420 1
d1425 1
a1426 5

  /* Store the info we need to destroy after this window is gone */
  hInstance = (HINSTANCE) GetClassLong (pWinPriv->hWnd, GCL_HMODULE);
  hiconClass = (HICON) GetClassLong (pWinPriv->hWnd, GCL_HICON);
  iReturn = GetClassName (pWinPriv->hWnd, pszClass, 512);
a1427 1
  /* Destroy the Windows window */
a1429 1
  /* Null our handle to the Window so referencing it will cause an error */
d1440 1
a1440 24

  /* Only if we were able to get the name */
  if (iReturn)
    { 
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winDestroyWindowsWindow - Unregistering %s: ", pszClass);
#endif
      iReturn = UnregisterClass (pszClass, hInstance);
      
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winDestroyWindowsWindow - %d Deleting Icon: ", iReturn);
#endif
      
      /* Only delete if it's not the default */
      if (hiconClass != g_hiconX &&
	  !winIconIsOverride((unsigned long)hiconClass))
	{ 
	  iReturn = DestroyIcon (hiconClass);
#if CYGMULTIWINDOW_DEBUG
	  ErrorF ("winDestroyWindowsWindow - %d\n", iReturn);
#endif
	}
    }

d1448 1
a1448 2
 * winUpdateWindowsWindow - Redisplay/redraw a Windows window
 * associated with an X window
a1491 3
/*
 * winGetWindowID - 
 */
a1492 8
XID
winGetWindowID (WindowPtr pWin)
{
  WindowIDPairRec	wi = {pWin, 0};
  ClientPtr		c = wClient(pWin);
  
  /* */
  FindClientResourcesByType (c, RT_WINDOW, winFindWindow, &wi);
a1493 3
#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winGetWindowID - Window ID: %d\n", wi.id);
#endif
a1494 2
  return wi.id;
}
a1496 3
/*
 * winMoveXWindow - 
 */
d1498 4
a1501 4
void
winMoveXWindow (WindowPtr pWin, int x, int y)
{
  XID *vlist = malloc(sizeof(long)*2);
a1502 5
  (CARD32*)vlist[0] = x;
  (CARD32*)vlist[1] = y;
  ConfigureWindow (pWin, CWX | CWY, vlist, wClient(pWin));
  free(vlist);
}
a1504 14
/*
 * winResizeXWindow - 
 */

void
winResizeXWindow (WindowPtr pWin, int w, int h)
{
  XID *vlist = malloc(sizeof(long)*2);

  (CARD32*)vlist[0] = w;
  (CARD32*)vlist[1] = h;
  ConfigureWindow (pWin, CWWidth | CWHeight, vlist, wClient(pWin));
  free(vlist);
}
a1522 1
#if 0
d1524 1
a1524 1
 * winRestackXWindow - 
d1527 2
a1528 2
static void
winRestackXWindow (WindowPtr pWin, int smode)
d1530 5
a1534 1
  XID *vlist = malloc(sizeof(unsigned long));
d1536 3
a1538 5
  if (vlist == NULL)
    {
      ErrorF ("winRestackXWindow - malloc () failed\n");
      return;
    }
d1540 1
a1540 11
  if (pWin == NULL)
    {
      ErrorF ("winRestackXWindow - NULL window\n");
      free(vlist);
      return;
    }

  *((unsigned long*)vlist) = smode;
  ConfigureWindow (pWin, CWStackMode, vlist, wClient(pWin));

  free(vlist);
a1541 1
#endif
d1545 1
a1545 1
 * winReorderWindowsMultiWindow - 
d1548 2
a1549 2
void
winReorderWindowsMultiWindow (ScreenPtr pScreen)
d1551 2
a1552 4
  winScreenPriv(pScreen);
  HWND hwnd = NULL;
  WindowPtr pWin = NULL;
  WindowPtr pWinSib = NULL;
d1554 2
a1555 3
#if CYGMULTIWINDOW_DEBUG
  ErrorF ("winOrderWindowsMultiWindow\n");
#endif
d1557 4
a1560 1
  pScreenPriv->fRestacking = TRUE;
d1562 2
a1563 6
  if (pScreenPriv->fWindowOrderChanged)
    {
#if CYGMULTIWINDOW_DEBUG
      ErrorF ("winOrderWindowsMultiWindow - Need to restack\n");
#endif
      hwnd = GetTopWindow (NULL);
d1565 2
a1566 30
      while (hwnd)
	{
	  if (GetProp (hwnd, WIN_WINDOW_PROP))
	    {
	      pWinSib = pWin;
	      pWin = GetProp (hwnd, WIN_WINDOW_PROP);
	      
	      if (pWinSib)
		{
		  XID *vlist = malloc (sizeof(long) * 2);
		  
		  if (vlist == NULL)
		    {
		      ErrorF ("winOrderWindowsMultiWindow - malloc () "
			      "failed\n");
		      return;
		    }
		  
		  ((long*)vlist)[0] = winGetWindowID (pWinSib);
		  ((long*)vlist)[1] = Below;

		  ConfigureWindow (pWin, CWSibling | CWStackMode,
				   vlist, wClient(pWin));
		  
		  free (vlist);
		}
	    }
	  hwnd = GetNextWindow (hwnd, GW_HWNDNEXT);
	}
    }
d1568 1
a1568 3
  pScreenPriv->fRestacking = FALSE;
  pScreenPriv->fWindowOrderChanged = FALSE;
}
d1570 1
d1572 2
a1573 15
/*
 * winMinimizeWindow - Minimize in response to WM_CHANGE_STATE
 */

void
winMinimizeWindow (Window id)
{
  WindowPtr		pWin;
  winPrivWinPtr	pWinPriv;
  
  pWin = LookupIDByType (id, RT_WINDOW);
  
  pWinPriv = winGetWindowPriv (pWin);
  
  ShowWindow (pWinPriv->hWnd, SW_MINIMIZE);
@

