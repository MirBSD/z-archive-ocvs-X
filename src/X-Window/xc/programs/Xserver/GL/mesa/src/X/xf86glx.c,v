head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.03.22.20.05.29;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.05.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.33.47;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.09.29;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.20.43;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* $XFree86: xc/programs/Xserver/GL/mesa/src/X/xf86glx.c,v 1.11 2001/10/31 22:50:27 tsi Exp $ */
/**************************************************************************

Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sub license, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

**************************************************************************/

/*
 * Authors:
 *   Kevin E. Martin <kevin@@precisioninsight.com>
 *   Brian E. Paul <brian@@precisioninsight.com>
 *
 */

#include <miscstruct.h>
#include <resource.h>
#include <GL/gl.h>
#include <GL/glxint.h>
#include <GL/glxtokens.h>
#include <scrnintstr.h>
#include <config.h>
#include <glxserver.h>
#include <glxscreens.h>
#include <glxdrawable.h>
#include <glxcontext.h>
#include <glxext.h>
#include <glxutil.h>
#include "xf86glxint.h"
#include "xmesaP.h"
#include <GL/xf86glx.h>

/*
 * This define is for the glcore.h header file.
 * If you add it here, then make sure you also add it in
 * ../../../glx/Imakefile.
 */
#if 0
#define DEBUG
#include <GL/internal/glcore.h>
#undef DEBUG
#else
#include <GL/internal/glcore.h>
#endif


/*
 * This structure is statically allocated in the __glXScreens[]
 * structure.  This struct is not used anywhere other than in
 * __glXScreenInit to initialize each of the active screens
 * (__glXActiveScreens[]).  Several of the fields must be initialized by
 * the screenProbe routine before they are copied to the active screens
 * struct.  In particular, the contextCreate, pGlxVisual, numVisuals,
 * and numUsableVisuals fields must be initialized.
 */
__GLXscreenInfo __glDDXScreenInfo = {
    __MESA_screenProbe,   /* Must be generic and handle all screens */
    __MESA_createContext, /* Substitute screen's createContext routine */
    __MESA_createBuffer,  /* Substitute screen's createBuffer routine */
    NULL,                 /* Set up pGlxVisual in probe */
    NULL,                 /* Set up pVisualPriv in probe */
    0,                    /* Set up numVisuals in probe */
    0,                    /* Set up numUsableVisuals in probe */
    "Vendor String",      /* GLXvendor is overwritten by __glXScreenInit */
    "Version String",     /* GLXversion is overwritten by __glXScreenInit */
    "Extensions String",  /* GLXextensions is overwritten by __glXScreenInit */
    NULL                  /* WrappedPositionWindow is overwritten */
};

__GLXextensionInfo __glDDXExtensionInfo = {
    GL_CORE_MESA,
    __MESA_resetExtension,
    __MESA_initVisuals,
    __MESA_setVisualConfigs
};

static __MESA_screen  MESAScreens[MAXSCREENS];
static __GLcontext   *MESA_CC        = NULL;

static int                 numConfigs     = 0;
static __GLXvisualConfig  *visualConfigs  = NULL;
static void              **visualPrivates = NULL;


static int count_bits(unsigned int n)
{
   int bits = 0;

   while (n > 0) {
      if (n & 1) bits++;
      n >>= 1;
   }
   return bits;
}


static XMesaVisual find_mesa_visual(int screen, VisualID vid)
{
    XMesaVisual xm_vis = NULL;
    __MESA_screen *pMScr = &MESAScreens[screen];
    int i;

    for (i = 0; i < pMScr->num_vis; i++) {
	if (pMScr->glx_vis[i].vid == vid) {
	    break;
	}
    }

    if (i < pMScr->num_vis) {
	xm_vis = pMScr->xm_vis[i];
    }
    return xm_vis;
}


/*
 * In the case the driver has no GLX visuals we'll use these.
 * [0] = RGB, double buffered
 * [1] = RGB, double buffered, stencil, accum
 * [2] = CI, double buffered
 */
#define NUM_FALLBACK_CONFIGS 3
static __GLXvisualConfig FallbackConfigs[NUM_FALLBACK_CONFIGS] = {
  {
    -1,                 /* vid */
    -1,                 /* class */
    True,               /* rgba */
    -1, -1, -1, 0,      /* rgba sizes */
    -1, -1, -1, 0,      /* rgba masks */
     0,  0,  0, 0,      /* rgba accum sizes */
    True,               /* doubleBuffer */
    False,              /* stereo */
    -1,                 /* bufferSize */
    16,                 /* depthSize */
    0,                  /* stencilSize */
    0,                  /* auxBuffers */
    0,                  /* level */
    GLX_NONE_EXT,       /* visualRating */
    0,                  /* transparentPixel */
    0, 0, 0, 0,         /* transparent rgba color (floats scaled to ints) */
    0                   /* transparentIndex */
  },
  {
    -1,                 /* vid */
    -1,                 /* class */
    True,               /* rgba */
    -1, -1, -1, 0,      /* rgba sizes */
    -1, -1, -1, 0,      /* rgba masks */
    16, 16, 16, 0,      /* rgba accum sizes */
    True,               /* doubleBuffer */
    False,              /* stereo */
    -1,                 /* bufferSize */
    16,                 /* depthSize */
    8,                  /* stencilSize */
    0,                  /* auxBuffers */
    0,                  /* level */
    GLX_NONE_EXT,       /* visualRating */
    0,                  /* transparentPixel */
    0, 0, 0, 0,         /* transparent rgba color (floats scaled to ints) */
    0                   /* transparentIndex */
  },
  {
    -1,                 /* vid */
    -1,                 /* class */
    False,              /* color index */
    -1, -1, -1, 0,      /* rgba sizes */
    -1, -1, -1, 0,      /* rgba masks */
     0,  0,  0, 0,      /* rgba accum sizes */
    True,               /* doubleBuffer */
    False,              /* stereo */
    -1,                 /* bufferSize */
    16,                 /* depthSize */
    0,                  /* stencilSize */
    0,                  /* auxBuffers */
    0,                  /* level */
    GLX_NONE_EXT,       /* visualRating */
    0,                  /* transparentPixel */
    0, 0, 0, 0,         /* transparent rgba color (floats scaled to ints) */
    0                   /* transparentIndex */
  },
};


static Bool init_visuals(int *nvisualp, VisualPtr *visualp,
			 VisualID *defaultVisp,
			 int ndepth, DepthPtr pdepth,
			 int rootDepth)
{
    int numRGBconfigs;
    int numCIconfigs;
    int numVisuals = *nvisualp;
    int numNewVisuals;
    int numNewConfigs;
    VisualPtr pVisual = *visualp;
    VisualPtr pVisualNew = NULL;
    VisualID *orig_vid = NULL;
    __GLXvisualConfig *glXVisualPtr = NULL;
    __GLXvisualConfig *pNewVisualConfigs = NULL;
    void **glXVisualPriv;
    void **pNewVisualPriv;
    int found_default;
    int i, j, k;

    if (numConfigs > 0)
        numNewConfigs = numConfigs;
    else
        numNewConfigs = NUM_FALLBACK_CONFIGS;

    /* Alloc space for the list of new GLX visuals */
    pNewVisualConfigs = (__GLXvisualConfig *)
                     __glXMalloc(numNewConfigs * sizeof(__GLXvisualConfig));
    if (!pNewVisualConfigs) {
	return FALSE;
    }

    /* Alloc space for the list of new GLX visual privates */
    pNewVisualPriv = (void **) __glXMalloc(numNewConfigs * sizeof(void *));
    if (!pNewVisualPriv) {
	__glXFree(pNewVisualConfigs);
	return FALSE;
    }

    /*
    ** If SetVisualConfigs was not called, then use default GLX
    ** visual configs.
    */
    if (numConfigs == 0) {
	memcpy(pNewVisualConfigs, FallbackConfigs,
               NUM_FALLBACK_CONFIGS * sizeof(__GLXvisualConfig));
	memset(pNewVisualPriv, 0, NUM_FALLBACK_CONFIGS * sizeof(void *));
    }
    else {
        /* copy driver's visual config info */
        for (i = 0; i < numConfigs; i++) {
            pNewVisualConfigs[i] = visualConfigs[i];
            pNewVisualPriv[i] = visualPrivates[i];
        }
    }


    /* Count the number of RGB and CI visual configs */
    numRGBconfigs = 0;
    numCIconfigs = 0;
    for (i = 0; i < numNewConfigs; i++) {
	if (pNewVisualConfigs[i].rgba)
	    numRGBconfigs++;
	else
	    numCIconfigs++;
    }

    /* Count the total number of visuals to compute */
    numNewVisuals = 0;
    for (i = 0; i < numVisuals; i++) {
        numNewVisuals +=
	    (pVisual[i].class == TrueColor || pVisual[i].class == DirectColor)
	    ? numRGBconfigs : numCIconfigs;
    }

    /* Reset variables for use with the next screen/driver's visual configs */
    visualConfigs = NULL;
    numConfigs = 0;

    /* Alloc temp space for the list of orig VisualIDs for each new visual */
    orig_vid = (VisualID *)__glXMalloc(numNewVisuals * sizeof(VisualID));
    if (!orig_vid) {
	__glXFree(pNewVisualPriv);
	__glXFree(pNewVisualConfigs);
	return FALSE;
    }

    /* Alloc space for the list of glXVisuals */
    glXVisualPtr = (__GLXvisualConfig *)__glXMalloc(numNewVisuals *
						    sizeof(__GLXvisualConfig));
    if (!glXVisualPtr) {
	__glXFree(orig_vid);
	__glXFree(pNewVisualPriv);
	__glXFree(pNewVisualConfigs);
	return FALSE;
    }

    /* Alloc space for the list of glXVisualPrivates */
    glXVisualPriv = (void **)__glXMalloc(numNewVisuals * sizeof(void *));
    if (!glXVisualPriv) {
	__glXFree(glXVisualPtr);
	__glXFree(orig_vid);
	__glXFree(pNewVisualPriv);
	__glXFree(pNewVisualConfigs);
	return FALSE;
    }

    /* Alloc space for the new list of the X server's visuals */
    pVisualNew = (VisualPtr)__glXMalloc(numNewVisuals * sizeof(VisualRec));
    if (!pVisualNew) {
	__glXFree(glXVisualPriv);
	__glXFree(glXVisualPtr);
	__glXFree(orig_vid);
	__glXFree(pNewVisualPriv);
	__glXFree(pNewVisualConfigs);
	return FALSE;
    }

    /* Initialize the new visuals */
    found_default = FALSE;
    for (i = j = 0; i < numVisuals; i++) {
        int is_rgb = (pVisual[i].class == TrueColor ||
		      pVisual[i].class == DirectColor);

	for (k = 0; k < numNewConfigs; k++) {
	    if (pNewVisualConfigs[k].rgba != is_rgb)
		continue;

	    /* Initialize the new visual */
	    pVisualNew[j] = pVisual[i];
	    pVisualNew[j].vid = FakeClientID(0);

	    /* Check for the default visual */
	    if (!found_default && pVisual[i].vid == *defaultVisp) {
		*defaultVisp = pVisualNew[j].vid;
		found_default = TRUE;
	    }

	    /* Save the old VisualID */
	    orig_vid[j] = pVisual[i].vid;

	    /* Initialize the glXVisual */
	    glXVisualPtr[j] = pNewVisualConfigs[k];
	    glXVisualPtr[j].vid = pVisualNew[j].vid;

	    /*
	     * If the class is -1, then assume the X visual information
	     * is identical to what GLX needs, and take them from the X
	     * visual.  NOTE: if class != -1, then all other fields MUST
	     * be initialized.
	     */
	    if (glXVisualPtr[j].class == -1) {
		glXVisualPtr[j].class      = pVisual[i].class;
		glXVisualPtr[j].redSize    = count_bits(pVisual[i].redMask);
		glXVisualPtr[j].greenSize  = count_bits(pVisual[i].greenMask);
		glXVisualPtr[j].blueSize   = count_bits(pVisual[i].blueMask);
		glXVisualPtr[j].alphaSize  = glXVisualPtr[j].alphaSize;
		glXVisualPtr[j].redMask    = pVisual[i].redMask;
		glXVisualPtr[j].greenMask  = pVisual[i].greenMask;
		glXVisualPtr[j].blueMask   = pVisual[i].blueMask;
		glXVisualPtr[j].alphaMask  = glXVisualPtr[j].alphaMask;
		glXVisualPtr[j].bufferSize = rootDepth;
	    }

	    /* Save the device-dependent private for this visual */
	    glXVisualPriv[j] = pNewVisualPriv[k];

	    j++;
	}
    }

    assert(j <= numNewVisuals);

    /* Save the GLX visuals in the screen structure */
    MESAScreens[screenInfo.numScreens-1].num_vis = numNewVisuals;
    MESAScreens[screenInfo.numScreens-1].glx_vis = glXVisualPtr;
    MESAScreens[screenInfo.numScreens-1].private = glXVisualPriv;

    /* Set up depth's VisualIDs */
    for (i = 0; i < ndepth; i++) {
	int numVids = 0;
	VisualID *pVids = NULL;
	int k, n = 0;

	/* Count the new number of VisualIDs at this depth */
	for (j = 0; j < pdepth[i].numVids; j++)
	    for (k = 0; k < numNewVisuals; k++)
		if (pdepth[i].vids[j] == orig_vid[k])
		    numVids++;

	/* Allocate a new list of VisualIDs for this depth */
	pVids = (VisualID *)__glXMalloc(numVids * sizeof(VisualID));

	/* Initialize the new list of VisualIDs for this depth */
	for (j = 0; j < pdepth[i].numVids; j++)
	    for (k = 0; k < numNewVisuals; k++)
		if (pdepth[i].vids[j] == orig_vid[k])
		    pVids[n++] = pVisualNew[k].vid;

	/* Update this depth's list of VisualIDs */
	__glXFree(pdepth[i].vids);
	pdepth[i].vids = pVids;
	pdepth[i].numVids = numVids;
    }

    /* Update the X server's visuals */
    *nvisualp = numNewVisuals;
    *visualp = pVisualNew;

    /* Free the old list of the X server's visuals */
    __glXFree(pVisual);

    /* Clean up temporary allocations */
    __glXFree(orig_vid);
    __glXFree(pNewVisualPriv);
    __glXFree(pNewVisualConfigs);

    /* Free the private list created by DDX HW driver */
    if (visualPrivates)
        xfree(visualPrivates);
    visualPrivates = NULL;

    return TRUE;
}

void __MESA_setVisualConfigs(int nconfigs, __GLXvisualConfig *configs,
			     void **privates)
{
    (void)kernel8;
    (void)DitherValues;
    numConfigs = nconfigs;
    visualConfigs = configs;
    visualPrivates = privates;
}

Bool __MESA_initVisuals(VisualPtr *visualp, DepthPtr *depthp,
			int *nvisualp, int *ndepthp, int *rootDepthp,
			VisualID *defaultVisp, unsigned long sizes,
			int bitsPerRGB)
{
    /*
     * Setup the visuals supported by this particular screen.
     */
    return init_visuals(nvisualp, visualp, defaultVisp,
			*ndepthp, *depthp, *rootDepthp);
}

static void fixup_visuals(int screen)
{
    ScreenPtr pScreen = screenInfo.screens[screen];
    __MESA_screen *pMScr = &MESAScreens[screen];
    __GLXvisualConfig *pGLXVis  = pMScr->glx_vis;
    VisualPtr pVis;
    int i, j;

    for (i = 0; i < pMScr->num_vis; i++, pGLXVis++) {
	pVis = pScreen->visuals;

	/* Find a visual that matches the GLX visual's class and size */
	for (j = 0; j < pScreen->numVisuals; j++, pVis++) {
	    if (pVis->class == pGLXVis->class &&
		pVis->nplanes == pGLXVis->bufferSize) {

		/* Fixup the masks */
		pGLXVis->redMask   = pVis->redMask;
		pGLXVis->greenMask = pVis->greenMask;
		pGLXVis->blueMask  = pVis->blueMask;

		/* Recalc the sizes */
		pGLXVis->redSize   = count_bits(pGLXVis->redMask);
		pGLXVis->greenSize = count_bits(pGLXVis->greenMask);
		pGLXVis->blueSize  = count_bits(pGLXVis->blueMask);
	    }
	}
    }
}

static void init_screen_visuals(int screen)
{
    ScreenPtr pScreen = screenInfo.screens[screen];
    __GLXvisualConfig *pGLXVis = MESAScreens[screen].glx_vis;
    XMesaVisual *pXMesaVisual;
    VisualPtr pVis;
    int *used;
    int i, j;

    /* Alloc space for the list of XMesa visuals */
    pXMesaVisual = (XMesaVisual *)__glXMalloc(MESAScreens[screen].num_vis *
					      sizeof(XMesaVisual));
    __glXMemset(pXMesaVisual, 0,
		MESAScreens[screen].num_vis * sizeof(XMesaVisual));

    used = (int *)__glXMalloc(pScreen->numVisuals * sizeof(int));
    __glXMemset(used, 0, pScreen->numVisuals * sizeof(int));

    for (i = 0; i < MESAScreens[screen].num_vis; i++, pGLXVis++) {

	pVis = pScreen->visuals;
	for (j = 0; j < pScreen->numVisuals; j++, pVis++) {

	    if (pVis->class == pGLXVis->class &&
		pVis->nplanes == pGLXVis->bufferSize &&
		!used[j]) {

		if (pVis->redMask   == pGLXVis->redMask &&
		    pVis->greenMask == pGLXVis->greenMask &&
		    pVis->blueMask  == pGLXVis->blueMask) {

		    /* Create the XMesa visual */
		    pXMesaVisual[i] =
                         XMesaCreateVisual(pScreen,
					   pVis,
					   pGLXVis->rgba,
					   (pGLXVis->alphaSize > 0),
					   pGLXVis->doubleBuffer,
					   pGLXVis->stereo,
					   GL_TRUE, /* ximage_flag */
					   pGLXVis->depthSize,
					   pGLXVis->stencilSize,
					   pGLXVis->accumRedSize,
					   pGLXVis->accumGreenSize,
					   pGLXVis->accumBlueSize,
					   pGLXVis->accumAlphaSize,
                                           0,  /* numSamples */
					   pGLXVis->level,
                                           pGLXVis->visualRating );
		    /* Set the VisualID */
		    pGLXVis->vid = pVis->vid;

		    /* Mark this visual used */
		    used[j] = 1;
		    break;
		}
	    }
	}
    }

    __glXFree(used);

    MESAScreens[screen].xm_vis = pXMesaVisual;
}

Bool __MESA_screenProbe(int screen)
{
    /*
     * Set up the current screen's visuals.
     */
    __glDDXScreenInfo.pGlxVisual = MESAScreens[screen].glx_vis;
    __glDDXScreenInfo.pVisualPriv = MESAScreens[screen].private;
    __glDDXScreenInfo.numVisuals =
	__glDDXScreenInfo.numUsableVisuals = MESAScreens[screen].num_vis;

    /*
     * Set the current screen's createContext routine.  This could be
     * wrapped by a DDX GLX context creation routine.
     */
    __glDDXScreenInfo.createContext = __MESA_createContext;

    /*
     * The ordering of the rgb compenents might have been changed by the
     * driver after mi initialized them.
     */
    fixup_visuals(screen);

    /*
     * Find the GLX visuals that are supported by this screen and create
     * XMesa's visuals.
     */
    init_screen_visuals(screen);

    return TRUE;
}

extern void __MESA_resetExtension(void)
{
    int i, j;

    XMesaReset();

    for (i = 0; i < screenInfo.numScreens; i++) {
	for (j = 0; j < MESAScreens[i].num_vis; j++) {
	  if (MESAScreens[i].xm_vis[j]) {
	        XMesaDestroyVisual(MESAScreens[i].xm_vis[j]);
		MESAScreens[i].xm_vis[j] = NULL;
	  }
	}
	__glXFree(MESAScreens[i].glx_vis);
	MESAScreens[i].glx_vis = NULL;
	MESAScreens[i].num_vis = 0;
    }
    __glDDXScreenInfo.pGlxVisual = NULL;
    MESA_CC = NULL;
}

void __MESA_createBuffer(__GLXdrawablePrivate *glxPriv)
{
    DrawablePtr pDraw = glxPriv->pDraw;
    XMesaVisual xm_vis = find_mesa_visual(pDraw->pScreen->myNum,
					  glxPriv->pGlxVisual->vid);
    __GLdrawablePrivate *glPriv = &glxPriv->glPriv;
    __MESA_buffer buf;

    buf = (__MESA_buffer)__glXMalloc(sizeof(struct __MESA_bufferRec));

    /* Create Mesa's buffers */
    if (glxPriv->type == DRAWABLE_WINDOW) {
	buf->xm_buf = (void *)XMesaCreateWindowBuffer(xm_vis,
						      (WindowPtr)pDraw);
    } else {
	buf->xm_buf = (void *)XMesaCreatePixmapBuffer(xm_vis,
						      (PixmapPtr)pDraw, 0);
    }

    /* Wrap the front buffer's resize routine */
    buf->fbresize = glPriv->frontBuffer.resize;
    glPriv->frontBuffer.resize = __MESA_resizeBuffers;

    /* Wrap the swap buffers routine */
    buf->fbswap = glxPriv->swapBuffers;
    glxPriv->swapBuffers = __MESA_swapBuffers;

    /* Save Mesa's private buffer structure */
    glPriv->private = (void *)buf;
    glPriv->freePrivate = __MESA_destroyBuffer;
}

GLboolean __MESA_resizeBuffers(__GLdrawableBuffer *buffer,
			       GLint x, GLint y,
			       GLuint width, GLuint height, 
			       __GLdrawablePrivate *glPriv,
			       GLuint bufferMask)
{
    __MESA_buffer buf = (__MESA_buffer)glPriv->private;

    if (buf->xm_buf && buf->xm_buf->xm_context) {
	GLcontext *ctx = buf->xm_buf->xm_context->gl_ctx;
	XMesaForceCurrent(buf->xm_buf->xm_context);
	(*ctx->CurrentDispatch->ResizeBuffersMESA)();
        if (MESA_CC)
           XMesaForceCurrent(MESA_CC->xm_ctx);
    }

    return (*buf->fbresize)(buffer, x, y, width, height, glPriv, bufferMask);
}

GLboolean __MESA_swapBuffers(__GLXdrawablePrivate *glxPriv)
{
    __MESA_buffer buf = (__MESA_buffer)glxPriv->glPriv.private;

    /*
    ** Do not call the wrapped swap buffers routine since Mesa has
    ** already done the swap.
    */
    XMesaSwapBuffers(buf->xm_buf);

    return GL_TRUE;
}

void __MESA_destroyBuffer(__GLdrawablePrivate *glPriv)
{
    __MESA_buffer buf = (__MESA_buffer)glPriv->private;
    __GLXdrawablePrivate *glxPriv = (__GLXdrawablePrivate *)glPriv->other;

    /* Destroy Mesa's buffers */
    if (buf->xm_buf)
	XMesaDestroyBuffer(buf->xm_buf);

    /* Unwrap these routines */
    glxPriv->swapBuffers = buf->fbswap;
    glPriv->frontBuffer.resize = buf->fbresize;

    __glXFree(glPriv->private);
    glPriv->private = NULL;
}

__GLinterface *__MESA_createContext(__GLimports *imports,
				    __GLcontextModes *modes,
				    __GLinterface *shareGC)
{
    __GLcontext *gl_ctx;
    XMesaContext m_share = NULL;
    XMesaVisual xm_vis;
    __GLXcontext *glxc = (__GLXcontext *)imports->other;

    gl_ctx = (__GLcontext *)__glXMalloc(sizeof(__GLcontext));
    if (!gl_ctx)
	return NULL;

    gl_ctx->iface.imports = *imports;

    gl_ctx->iface.exports.destroyContext = __MESA_destroyContext;
    gl_ctx->iface.exports.loseCurrent = __MESA_loseCurrent;
    gl_ctx->iface.exports.makeCurrent = __MESA_makeCurrent;
    gl_ctx->iface.exports.shareContext = __MESA_shareContext;
    gl_ctx->iface.exports.copyContext = __MESA_copyContext;
    gl_ctx->iface.exports.forceCurrent = __MESA_forceCurrent;
    gl_ctx->iface.exports.notifyResize = __MESA_notifyResize;
    gl_ctx->iface.exports.notifyDestroy = __MESA_notifyDestroy;
    gl_ctx->iface.exports.notifySwapBuffers = __MESA_notifySwapBuffers;
    gl_ctx->iface.exports.dispatchExec = __MESA_dispatchExec;
    gl_ctx->iface.exports.beginDispatchOverride = __MESA_beginDispatchOverride;
    gl_ctx->iface.exports.endDispatchOverride = __MESA_endDispatchOverride;

    if (shareGC) m_share = ((__GLcontext *)shareGC)->xm_ctx;
    xm_vis = find_mesa_visual(glxc->pScreen->myNum, glxc->pGlxVisual->vid);
    if (xm_vis) {
	gl_ctx->xm_ctx = XMesaCreateContext(xm_vis, m_share);
    } else {
	__glXFree(gl_ctx);
	gl_ctx = NULL;
    }

    return (__GLinterface *)gl_ctx;
}

GLboolean __MESA_destroyContext(__GLcontext *gc)
{
    XMesaDestroyContext(gc->xm_ctx);
    __glXFree(gc);
    return GL_TRUE;
}

GLboolean __MESA_loseCurrent(__GLcontext *gc)
{
    MESA_CC = NULL;
    __glXLastContext = NULL;
    return XMesaLoseCurrent(gc->xm_ctx);
}

GLboolean __MESA_makeCurrent(__GLcontext *gc, __GLdrawablePrivate *glPriv)
{
    __MESA_buffer buf = (__MESA_buffer)glPriv->private;

    MESA_CC = gc;
    return XMesaMakeCurrent(gc->xm_ctx, buf->xm_buf);
}

GLboolean __MESA_shareContext(__GLcontext *gc, __GLcontext *gcShare)
{
    /* NOT_DONE */
    ErrorF("__MESA_shareContext\n");
    return GL_FALSE;
}

GLboolean __MESA_copyContext(__GLcontext *dst, const __GLcontext *src,
			     GLuint mask)
{
    /* NOT_DONE */
    ErrorF("__MESA_copyContext\n");
    return GL_FALSE;
}

GLboolean __MESA_forceCurrent(__GLcontext *gc)
{
    MESA_CC = gc;
    return XMesaForceCurrent(gc->xm_ctx);
}

GLboolean __MESA_notifyResize(__GLcontext *gc)
{
    /* NOT_DONE */
    ErrorF("__MESA_notifyResize\n");
    return GL_FALSE;
}

void __MESA_notifyDestroy(__GLcontext *gc)
{
    /* NOT_DONE */
    ErrorF("__MESA_notifyDestroy\n");
    return;
}

void __MESA_notifySwapBuffers(__GLcontext *gc)
{
    /* NOT_DONE */
    ErrorF("__MESA_notifySwapBuffers\n");
    return;
}

struct __GLdispatchStateRec *__MESA_dispatchExec(__GLcontext *gc)
{
    /* NOT_DONE */
    ErrorF("__MESA_dispatchExec\n");
    return NULL;
}

void __MESA_beginDispatchOverride(__GLcontext *gc)
{
    /* NOT_DONE */
    ErrorF("__MESA_beginDispatchOverride\n");
    return;
}

void __MESA_endDispatchOverride(__GLcontext *gc)
{
    /* NOT_DONE */
    ErrorF("__MESA_endDispatchOverride\n");
    return;
}

GLint __glEvalComputeK(GLenum target)
{
    switch (target) {
    case GL_MAP1_VERTEX_4:
    case GL_MAP1_COLOR_4:
    case GL_MAP1_TEXTURE_COORD_4:
    case GL_MAP2_VERTEX_4:
    case GL_MAP2_COLOR_4:
    case GL_MAP2_TEXTURE_COORD_4:
	return 4;
    case GL_MAP1_VERTEX_3:
    case GL_MAP1_TEXTURE_COORD_3:
    case GL_MAP1_NORMAL:
    case GL_MAP2_VERTEX_3:
    case GL_MAP2_TEXTURE_COORD_3:
    case GL_MAP2_NORMAL:
	return 3;
    case GL_MAP1_TEXTURE_COORD_2:
    case GL_MAP2_TEXTURE_COORD_2:
	return 2;
    case GL_MAP1_TEXTURE_COORD_1:
    case GL_MAP2_TEXTURE_COORD_1:
    case GL_MAP1_INDEX:
    case GL_MAP2_INDEX:
	return 1;
    default:
	return 0;
    }
}

GLuint __glFloorLog2(GLuint val)
{
    int c = 0;

    while (val > 1) {
	c++;
	val >>= 1;
    }
    return c;
}

@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/GL/mesa/src/X/xf86glx.c,v 1.21 2003/10/28 22:50:18 tsi Exp $ */
d36 1
a36 1
#include <regionstr.h>
a49 1
#include "context.h"
a51 1
#include "context.h"
d98 1
a124 1
	    xm_vis = pMScr->xm_vis[i];
d129 3
d137 4
a140 4
 * In the case the driver defines no GLX visuals we'll use these.
 * Note that for TrueColor and DirectColor visuals, bufferSize is the 
 * sum of redSize, greenSize, blueSize and alphaSize, which may be larger 
 * than the nplanes/rootDepth of the server's X11 visuals
d142 1
a142 1
#define NUM_FALLBACK_CONFIGS 5
a143 1
  /* [0] = RGB, double buffered, Z */
d158 2
a159 2
    GLX_NONE,           /* visualRating */
    GLX_NONE,           /* transparentPixel */
a162 1
  /* [1] = RGB, double buffered, Z, stencil, accum */
d177 2
a178 42
    GLX_NONE,           /* visualRating */
    GLX_NONE,           /* transparentPixel */
    0, 0, 0, 0,         /* transparent rgba color (floats scaled to ints) */
    0                   /* transparentIndex */
  },
  /* [2] = RGB+Alpha, double buffered, Z, stencil, accum */
  {
    -1,                 /* vid */
    -1,                 /* class */
    True,               /* rgba */
    -1, -1, -1, 8,      /* rgba sizes */
    -1, -1, -1, -1,     /* rgba masks */
    16, 16, 16, 16,     /* rgba accum sizes */
    True,               /* doubleBuffer */
    False,              /* stereo */
    -1,                 /* bufferSize */
    16,                 /* depthSize */
    8,                  /* stencilSize */
    0,                  /* auxBuffers */
    0,                  /* level */
    GLX_NONE,           /* visualRating */
    GLX_NONE,           /* transparentPixel */
    0, 0, 0, 0,         /* transparent rgba color (floats scaled to ints) */
    0                   /* transparentIndex */
  },
  /* [3] = RGB+Alpha, single buffered, Z, stencil, accum */
  {
    -1,                 /* vid */
    -1,                 /* class */
    True,               /* rgba */
    -1, -1, -1, 8,      /* rgba sizes */
    -1, -1, -1, -1,     /* rgba masks */
    16, 16, 16, 16,     /* rgba accum sizes */
    False,              /* doubleBuffer */
    False,              /* stereo */
    -1,                 /* bufferSize */
    16,                 /* depthSize */
    8,                  /* stencilSize */
    0,                  /* auxBuffers */
    0,                  /* level */
    GLX_NONE,           /* visualRating */
    GLX_NONE,           /* transparentPixel */
a181 1
  /* [4] = CI, double buffered, Z */
d185 1
a185 1
    False,              /* rgba? (false = color index) */
d196 2
a197 2
    GLX_NONE,           /* visualRating */
    GLX_NONE,           /* transparentPixel */
d260 1
d365 1
a365 8
		if (is_rgb) {
		    glXVisualPtr[j].bufferSize = glXVisualPtr[j].redSize +
		                                 glXVisualPtr[j].greenSize +
		                                 glXVisualPtr[j].blueSize +
		                                 glXVisualPtr[j].alphaSize;
		} else {
		    glXVisualPtr[j].bufferSize = rootDepth;
		}
d465 1
a465 1
		pVis->nplanes == (pGLXVis->bufferSize - pGLXVis->alphaSize)) {
d505 1
a505 1
		pVis->nplanes == (pGLXVis->bufferSize - pGLXVis->alphaSize) &&
a591 4
	__glXFree(MESAScreens[i].private);
	MESAScreens[i].private = NULL;
	__glXFree(MESAScreens[i].xm_vis);
	MESAScreens[i].xm_vis = NULL;
d595 1
d638 7
a644 2
    if (buf->xm_buf)
	XMesaResizeBuffers(buf->xm_buf);
d683 3
a685 2
    __GLcontext *gl_ctx = NULL;
    __GLcontext *m_share = NULL;
a686 1
    XMesaVisual xm_vis;
d688 18
a705 2
    if (shareGC) 
       m_share = (__GLcontext *)shareGC;
d707 1
d710 4
a713 3
       XMesaContext xmshare = m_share ? m_share->DriverCtx : 0;
       XMesaContext xmctx = XMesaCreateContext(xm_vis, xmshare);
       gl_ctx = xmctx ? xmctx->gl_ctx : 0;
a715 17
    if (!gl_ctx)
       return NULL;
	
    gl_ctx->imports = *imports;
    gl_ctx->exports.destroyContext = __MESA_destroyContext;
    gl_ctx->exports.loseCurrent = __MESA_loseCurrent;
    gl_ctx->exports.makeCurrent = __MESA_makeCurrent;
    gl_ctx->exports.shareContext = __MESA_shareContext;
    gl_ctx->exports.copyContext = __MESA_copyContext;
    gl_ctx->exports.forceCurrent = __MESA_forceCurrent;
    gl_ctx->exports.notifyResize = __MESA_notifyResize;
    gl_ctx->exports.notifyDestroy = __MESA_notifyDestroy;
    gl_ctx->exports.notifySwapBuffers = __MESA_notifySwapBuffers;
    gl_ctx->exports.dispatchExec = __MESA_dispatchExec;
    gl_ctx->exports.beginDispatchOverride = __MESA_beginDispatchOverride;
    gl_ctx->exports.endDispatchOverride = __MESA_endDispatchOverride;

d721 2
a722 2
    XMesaContext xmesa = (XMesaContext) gc->DriverCtx;
    XMesaDestroyContext( xmesa );
d728 1
a728 1
    XMesaContext xmesa = (XMesaContext) gc->DriverCtx;
d730 1
a730 1
    return XMesaLoseCurrent(xmesa);
d733 1
a733 1
GLboolean __MESA_makeCurrent(__GLcontext *gc)
d735 1
a735 5
    __GLdrawablePrivate *drawPriv = gc->imports.getDrawablePrivate( gc );
    __MESA_buffer drawBuf = (__MESA_buffer)drawPriv->private;
    __GLdrawablePrivate *readPriv = gc->imports.getReadablePrivate( gc );
    __MESA_buffer readBuf = (__MESA_buffer)readPriv->private;
    XMesaContext xmesa = (XMesaContext) gc->DriverCtx;
d737 2
a738 1
    return XMesaMakeCurrent2(xmesa, drawBuf->xm_buf, readBuf->xm_buf);
a743 1
    /* XXX I don't see where/how this could ever be called */
d751 3
a753 4
    XMesaContext xm_dst = (XMesaContext) dst->DriverCtx;
    const XMesaContext xm_src = (XMesaContext) src->DriverCtx;
    _mesa_copy_context(xm_src->gl_ctx, xm_dst->gl_ctx, mask);
    return GL_TRUE;
d758 2
a759 2
    XMesaContext xmesa = (XMesaContext) gc->DriverCtx;
    return XMesaForceCurrent(xmesa);
d778 3
a780 1
    _mesa_notifySwapBuffers(gc);
a802 6


/*
 * Server-side GLX uses these functions which are normally defined
 * in the OpenGL SI.
 */
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/GL/mesa/src/X/xf86glx.c,v 1.18 2002/12/17 05:03:24 dawes Exp $ */
a49 1
#include "context.h"
a51 1
#include "context.h"
a124 1
	    xm_vis = pMScr->xm_vis[i];
d129 3
d138 3
a140 4
 * One thing is funny here: the bufferSize field doesn't always include
 * the alpha bits.  That is, bufferSize may be 24 when we have 8 bits
 * of red, green, blue and alpha.  If set set bufferSize to 32 we may
 * foul-up the visual matching code below (search for bufferSize).
d142 1
a142 1
#define NUM_FALLBACK_CONFIGS 5
a143 1
  /* [0] = RGB, double buffered, Z */
a162 1
  /* [1] = RGB, double buffered, Z, stencil, accum */
a181 41
  /* [2] = RGB+Alpha, double buffered, Z, stencil, accum */
  {
    -1,                 /* vid */
    -1,                 /* class */
    True,               /* rgba */
    -1, -1, -1, 8,      /* rgba sizes */
    -1, -1, -1, -1,     /* rgba masks */
    16, 16, 16, 16,     /* rgba accum sizes */
    True,               /* doubleBuffer */
    False,              /* stereo */
    -1,                 /* bufferSize */
    16,                 /* depthSize */
    8,                  /* stencilSize */
    0,                  /* auxBuffers */
    0,                  /* level */
    GLX_NONE_EXT,       /* visualRating */
    0,                  /* transparentPixel */
    0, 0, 0, 0,         /* transparent rgba color (floats scaled to ints) */
    0                   /* transparentIndex */
  },
  /* [3] = RGB+Alpha, single buffered, Z, stencil, accum */
  {
    -1,                 /* vid */
    -1,                 /* class */
    True,               /* rgba */
    -1, -1, -1, 8,      /* rgba sizes */
    -1, -1, -1, -1,     /* rgba masks */
    16, 16, 16, 16,     /* rgba accum sizes */
    False,              /* doubleBuffer */
    False,              /* stereo */
    -1,                 /* bufferSize */
    16,                 /* depthSize */
    8,                  /* stencilSize */
    0,                  /* auxBuffers */
    0,                  /* level */
    GLX_NONE_EXT,       /* visualRating */
    0,                  /* transparentPixel */
    0, 0, 0, 0,         /* transparent rgba color (floats scaled to ints) */
    0                   /* transparentIndex */
  },
  /* [4] = CI, double buffered, Z */
d185 1
a185 1
    False,              /* rgba? (false = color index) */
d260 1
a591 4
	__glXFree(MESAScreens[i].private);
	MESAScreens[i].private = NULL;
	__glXFree(MESAScreens[i].xm_vis);
	MESAScreens[i].xm_vis = NULL;
d638 7
a644 2
    if (buf->xm_buf)
	XMesaResizeBuffers(buf->xm_buf);
d683 3
a685 2
    __GLcontext *gl_ctx = NULL;
    __GLcontext *m_share = NULL;
a686 1
    XMesaVisual xm_vis;
d688 18
a705 2
    if (shareGC) 
       m_share = (__GLcontext *)shareGC;
d707 1
d710 4
a713 3
       XMesaContext xmshare = m_share ? m_share->DriverCtx : 0;
       XMesaContext xmctx = XMesaCreateContext(xm_vis, xmshare);
       gl_ctx = xmctx ? xmctx->gl_ctx : 0;
a715 17
    if (!gl_ctx)
       return NULL;
	
    gl_ctx->imports = *imports;
    gl_ctx->exports.destroyContext = __MESA_destroyContext;
    gl_ctx->exports.loseCurrent = __MESA_loseCurrent;
    gl_ctx->exports.makeCurrent = __MESA_makeCurrent;
    gl_ctx->exports.shareContext = __MESA_shareContext;
    gl_ctx->exports.copyContext = __MESA_copyContext;
    gl_ctx->exports.forceCurrent = __MESA_forceCurrent;
    gl_ctx->exports.notifyResize = __MESA_notifyResize;
    gl_ctx->exports.notifyDestroy = __MESA_notifyDestroy;
    gl_ctx->exports.notifySwapBuffers = __MESA_notifySwapBuffers;
    gl_ctx->exports.dispatchExec = __MESA_dispatchExec;
    gl_ctx->exports.beginDispatchOverride = __MESA_beginDispatchOverride;
    gl_ctx->exports.endDispatchOverride = __MESA_endDispatchOverride;

d721 2
a722 2
    XMesaContext xmesa = (XMesaContext) gc->DriverCtx;
    XMesaDestroyContext( xmesa );
a727 1
    XMesaContext xmesa = (XMesaContext) gc->DriverCtx;
d730 1
a730 1
    return XMesaLoseCurrent(xmesa);
d733 1
a733 1
GLboolean __MESA_makeCurrent(__GLcontext *gc, __GLdrawablePrivate *oldglPriv)
a734 2
    /* We don't use oldglPriv - kept for backwards compatibility */
    __GLdrawablePrivate *glPriv = gc->imports.getDrawablePrivate( gc );
a735 1
    XMesaContext xmesa = (XMesaContext) gc->DriverCtx;
d738 1
a738 1
    return XMesaMakeCurrent(xmesa, buf->xm_buf);
a743 1
    /* XXX I don't see where/how this could ever be called */
d751 3
a753 4
    XMesaContext xm_dst = (XMesaContext) dst->DriverCtx;
    const XMesaContext xm_src = (const XMesaContext) src->DriverCtx;
    _mesa_copy_context(xm_src->gl_ctx, xm_dst->gl_ctx, mask);
    return GL_TRUE;
a757 1
    XMesaContext xmesa = (XMesaContext) gc->DriverCtx;
d759 1
a759 1
    return XMesaForceCurrent(xmesa);
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/GL/mesa/src/X/xf86glx.c,v 1.21 2003/10/28 22:50:18 tsi Exp $ */
d36 1
a36 1
#include <regionstr.h>
d100 1
d137 5
a141 4
 * In the case the driver defines no GLX visuals we'll use these.
 * Note that for TrueColor and DirectColor visuals, bufferSize is the 
 * sum of redSize, greenSize, blueSize and alphaSize, which may be larger 
 * than the nplanes/rootDepth of the server's X11 visuals
d160 2
a161 2
    GLX_NONE,           /* visualRating */
    GLX_NONE,           /* transparentPixel */
d180 2
a181 2
    GLX_NONE,           /* visualRating */
    GLX_NONE,           /* transparentPixel */
d200 2
a201 2
    GLX_NONE,           /* visualRating */
    GLX_NONE,           /* transparentPixel */
d220 2
a221 2
    GLX_NONE,           /* visualRating */
    GLX_NONE,           /* transparentPixel */
d240 2
a241 2
    GLX_NONE,           /* visualRating */
    GLX_NONE,           /* transparentPixel */
d408 1
a408 8
		if (is_rgb) {
		    glXVisualPtr[j].bufferSize = glXVisualPtr[j].redSize +
		                                 glXVisualPtr[j].greenSize +
		                                 glXVisualPtr[j].blueSize +
		                                 glXVisualPtr[j].alphaSize;
		} else {
		    glXVisualPtr[j].bufferSize = rootDepth;
		}
d508 1
a508 1
		pVis->nplanes == (pGLXVis->bufferSize - pGLXVis->alphaSize)) {
d548 1
a548 1
		pVis->nplanes == (pGLXVis->bufferSize - pGLXVis->alphaSize) &&
d642 1
d770 1
d775 1
a775 1
GLboolean __MESA_makeCurrent(__GLcontext *gc)
d777 3
a779 4
    __GLdrawablePrivate *drawPriv = gc->imports.getDrawablePrivate( gc );
    __MESA_buffer drawBuf = (__MESA_buffer)drawPriv->private;
    __GLdrawablePrivate *readPriv = gc->imports.getReadablePrivate( gc );
    __MESA_buffer readBuf = (__MESA_buffer)readPriv->private;
d782 2
a783 1
    return XMesaMakeCurrent2(xmesa, drawBuf->xm_buf, readBuf->xm_buf);
d798 1
a798 1
    const XMesaContext xm_src = (XMesaContext) src->DriverCtx;
d806 1
d826 3
a828 1
    _mesa_notifySwapBuffers(gc);
a850 6


/*
 * Server-side GLX uses these functions which are normally defined
 * in the OpenGL SI.
 */
@


