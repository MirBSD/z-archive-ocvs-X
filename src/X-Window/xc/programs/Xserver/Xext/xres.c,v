head	1.1;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.4
	cvs-200410241530:1.1.1.4
	cvs-200410012000:1.1.1.4
	cvs-200407141120:1.1.1.4
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.1
	cvs-200405271510:1.1.1.2
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.2
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.1
	MIRBSD_7_ALPHA:1.1.1.1.0.4
	MIRBSD_7:1.1.1.1.0.2
	MIRBSD_7ter:1.1.1.1
	cvs-20011091815:1.1.1.1
	cvs-200309162130:1.1.1.1
	cvs-200308302005:1.1.1.1
	ctmx-0387:1.1.1.1
	ctmx-0384:1.1.1.1
	MIRBSD_5:1.1.1.1
	ctmx-0375:1.1.1.1
	ctmx-0373:1.1.1.1
	ctm-0371:1.1.1.1
	ctm-0370:1.1.1.1
	MIRBSD_4:1.1.1.1
	ctm-0363:1.1.1.1
	ctm-0359:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.04.08.18.34.17;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.04.08.18.34.17;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.03.02.18.09.56;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.06.23.11.35.15;	author tg;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.07.14.12.01.01;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.20.48;	author tg;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
   Copyright (c) 2002  XFree86 Inc
*/
/* $XFree86: xc/programs/Xserver/Xext/xres.c,v 1.5 2002/07/01 02:25:55 tsi Exp $ */

#define NEED_EVENTS
#define NEED_REPLIES
#include "X.h"
#include "Xproto.h"
#include "misc.h"
#include "os.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "swaprep.h"
#include "XResproto.h"
#include "pixmapstr.h"

extern RESTYPE lastResourceType;
extern RESTYPE TypeMask;
extern Atom *ResourceNames;

static int
ProcXResQueryVersion (ClientPtr client)
{
    REQUEST(xXResQueryVersionReq);
    xXResQueryVersionReply rep;
    CARD16 client_major, client_minor;  /* not used */

    REQUEST_SIZE_MATCH (xXResQueryVersionReq);

    client_major = stuff->client_major;
    client_minor = stuff->client_minor;

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.server_major = XRES_MAJOR_VERSION;
    rep.server_minor = XRES_MINOR_VERSION;   
    if (client->swapped) { 
        int n;
        swaps(&rep.sequenceNumber, n);
        swapl(&rep.length, n);     
        swaps(&rep.server_major, n);
        swaps(&rep.server_minor, n);
    }
    WriteToClient(client, sizeof (xXResQueryVersionReply), (char *)&rep);
    return (client->noClientException);
}

static int
ProcXResQueryClients (ClientPtr client)
{
    /* REQUEST(xXResQueryClientsReq); */
    xXResQueryClientsReply rep;
    int *current_clients;
    int i;

    REQUEST_SIZE_MATCH(xXResQueryClientsReq);

    current_clients = ALLOCATE_LOCAL((currentMaxClients - 1) * sizeof(int));

    rep.num_clients = 0;
    for(i = 1; i < currentMaxClients; i++) {
       if(clients[i]) {
           current_clients[rep.num_clients] = i;
           rep.num_clients++;   
       }
    }

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = rep.num_clients * sz_xXResClient >> 2;
    if (client->swapped) {
        int n;
        swaps (&rep.sequenceNumber, n);
        swapl (&rep.length, n);
        swapl (&rep.num_clients, n);
    }   
    WriteToClient (client, sizeof (xXResQueryClientsReply), (char *) &rep);

    if(rep.num_clients) {
        xXResClient scratch;

        for(i = 0; i < rep.num_clients; i++) {
            scratch.resource_base = clients[current_clients[i]]->clientAsMask;
            scratch.resource_mask = RESOURCE_ID_MASK;
        
            if(client->swapped) {
                register int n;
                swapl (&scratch.resource_base, n);
                swapl (&scratch.resource_mask, n);
            }
            WriteToClient (client, sz_xXResClient, (char *) &scratch);
        }
    }

    DEALLOCATE_LOCAL(current_clients);

    return (client->noClientException);
}


static void
ResFindAllRes (pointer value, XID id, RESTYPE type, pointer cdata)
{
    int *counts = (int *)cdata;

    counts[(type & TypeMask) - 1]++;
}

static int
ProcXResQueryClientResources (ClientPtr client)
{
    REQUEST(xXResQueryClientResourcesReq);
    xXResQueryClientResourcesReply rep;
    int i, clientID;
    int *counts;

    REQUEST_SIZE_MATCH(xXResQueryClientResourcesReq);

    clientID = CLIENT_ID(stuff->xid);

    /* we could remove the (clientID == 0) check if we wanted to allow
       probing the X-server's resource usage */
    if(!clientID || (clientID >= currentMaxClients) || !clients[clientID]) {
        client->errorValue = stuff->xid;
        return BadValue;
    }

    counts = ALLOCATE_LOCAL((lastResourceType + 1) * sizeof(int));

    memset(counts, 0, (lastResourceType + 1) * sizeof(int));

    FindAllClientResources(clients[clientID], ResFindAllRes, counts);

    rep.num_types = 0;

    for(i = 0; i <= lastResourceType; i++) {
       if(counts[i]) rep.num_types++;
    }

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = rep.num_types * sz_xXResType >> 2;
    if (client->swapped) {
        int n;
        swaps (&rep.sequenceNumber, n);
        swapl (&rep.length, n);
        swapl (&rep.num_types, n);
    }   
    WriteToClient (client,sizeof(xXResQueryClientResourcesReply),(char*)&rep);

    if(rep.num_types) {
        xXResType scratch;

        for(i = 0; i < lastResourceType; i++) {
            if(!counts[i]) continue;

            if(!ResourceNames[i + 1]) {
                char buf[40];
                sprintf(buf, "Unregistered resource %i", i + 1);
                RegisterResourceName(i + 1, buf);
            }

            scratch.resource_type = ResourceNames[i + 1];
            scratch.count = counts[i];

            if(client->swapped) {
                register int n;
                swapl (&scratch.resource_type, n);
                swapl (&scratch.count, n);
            }
            WriteToClient (client, sz_xXResType, (char *) &scratch);
        }
    }

    DEALLOCATE_LOCAL(counts);
    
    return (client->noClientException);
}

static void 
ResFindPixmaps (pointer value, XID id, pointer cdata)
{
   unsigned long *bytes = (unsigned long *)cdata;
   PixmapPtr pix = (PixmapPtr)value;

   *bytes += (pix->devKind * pix->drawable.height);
}

static int
ProcXResQueryClientPixmapBytes (ClientPtr client)
{
    REQUEST(xXResQueryClientPixmapBytesReq);
    xXResQueryClientPixmapBytesReply rep;
    int clientID;
    unsigned long bytes;

    REQUEST_SIZE_MATCH(xXResQueryClientPixmapBytesReq);

    clientID = CLIENT_ID(stuff->xid);

    /* we could remove the (clientID == 0) check if we wanted to allow
       probing the X-server's resource usage */
    if(!clientID || (clientID >= currentMaxClients) || !clients[clientID]) {
        client->errorValue = stuff->xid;
        return BadValue;
    }

    bytes = 0;

    FindClientResourcesByType(clients[clientID], RT_PIXMAP, ResFindPixmaps, 
                              (pointer)(&bytes));

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.length = 0;
    rep.bytes = bytes;
#ifdef XSERVER64
    rep.bytes_overflow = bytes >> 32;
#else
    rep.bytes_overflow = 0;
#endif
    if (client->swapped) {
        int n;
        swaps (&rep.sequenceNumber, n);
        swapl (&rep.length, n);
        swapl (&rep.bytes, n);
        swapl (&rep.bytes_overflow, n);
    }
    WriteToClient (client,sizeof(xXResQueryClientPixmapBytesReply),(char*)&rep);

    return (client->noClientException);
}


static void
ResResetProc (ExtensionEntry *extEntry) { }

static int
ProcResDispatch (ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_XResQueryVersion:
        return ProcXResQueryVersion(client);
    case X_XResQueryClients:
        return ProcXResQueryClients(client);
    case X_XResQueryClientResources:
        return ProcXResQueryClientResources(client);
    case X_XResQueryClientPixmapBytes:
        return ProcXResQueryClientPixmapBytes(client);
    default: break;
    }

    return BadRequest;
}

static int
SProcXResQueryVersion (ClientPtr client)
{
    REQUEST(xXResQueryVersionReq);
    int n;

    REQUEST_SIZE_MATCH (xXResQueryVersionReq);
    swaps(&stuff->client_major,n);
    swaps(&stuff->client_minor,n);
    return ProcXResQueryVersion(client);
}

static int
SProcXResQueryClientResources (ClientPtr client)
{
    REQUEST(xXResQueryClientResourcesReq);
    int n;

    REQUEST_SIZE_MATCH (xXResQueryClientResourcesReq);
    swaps(&stuff->xid,n);
    return ProcXResQueryClientResources(client);
}

static int
SProcXResQueryClientPixmapBytes (ClientPtr client)
{
    REQUEST(xXResQueryClientPixmapBytesReq);
    int n;

    REQUEST_SIZE_MATCH (xXResQueryClientPixmapBytesReq);
    swaps(&stuff->xid,n);
    return ProcXResQueryClientPixmapBytes(client);
}

static int
SProcResDispatch (ClientPtr client)
{
    REQUEST(xReq);
    int n;

    swaps(&stuff->length,n);

    switch (stuff->data) {
    case X_XResQueryVersion:
        return SProcXResQueryVersion(client);
    case X_XResQueryClients:  /* nothing to swap */
        return ProcXResQueryClients(client);
    case X_XResQueryClientResources:
        return SProcXResQueryClientResources(client);
    case X_XResQueryClientPixmapBytes:
        return SProcXResQueryClientPixmapBytes(client);
    default: break;
    }

    return BadRequest;
}

void
ResExtensionInit(void)
{
    ExtensionEntry *extEntry;

    extEntry = AddExtension(XRES_NAME, 0, 0,
                            ProcResDispatch, SProcResDispatch,
                            ResResetProc, StandardMinorOpcode);

    RegisterResourceName(RT_NONE, "NONE");
    RegisterResourceName(RT_WINDOW, "WINDOW");
    RegisterResourceName(RT_PIXMAP, "PIXMAP");
    RegisterResourceName(RT_GC, "GC");
    RegisterResourceName(RT_FONT, "FONT");
    RegisterResourceName(RT_CURSOR, "CURSOR");
    RegisterResourceName(RT_COLORMAP, "COLORMAP");
    RegisterResourceName(RT_CMAPENTRY, "COLORMAP ENTRY");
    RegisterResourceName(RT_OTHERCLIENT, "OTHER CLIENT");
    RegisterResourceName(RT_PASSIVEGRAB, "PASSIVE GRAB");
}
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d4 1
a4 1
/* $XFree86: xc/programs/Xserver/Xext/xres.c,v 1.8 2003/10/28 23:08:44 tsi Exp $ */
d17 4
a20 1
#include "modinit.h"
a32 2
    (void) client_major;
    (void) client_minor;
d317 1
a317 1
ResExtensionInit(INITARGS)
d319 3
a321 1
    (void) AddExtension(XRES_NAME, 0, 0,
@


1.1.1.1
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@@


1.1.1.2
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d4 1
a4 1
/* $XFree86: xc/programs/Xserver/Xext/xres.c,v 1.8 2003/10/28 23:08:44 tsi Exp $ */
d17 4
a20 1
#include "modinit.h"
a32 2
    (void) client_major;
    (void) client_minor;
d317 1
a317 1
ResExtensionInit(INITARGS)
d319 3
a321 1
    (void) AddExtension(XRES_NAME, 0, 0,
@


1.1.1.3
log
@OpenBSD updated X-Window plus fontconfig 2.2.2.
@
text
@d55 1
a55 1
    int i, num_clients;
d61 1
a61 1
    num_clients = 0;
d64 2
a65 2
           current_clients[num_clients] = i;
           num_clients++;   
a70 1
    rep.num_clients = num_clients;
d80 1
a80 1
    if(num_clients) {
d83 1
a83 1
        for(i = 0; i < num_clients; i++) {
d115 1
a115 1
    int i, clientID, num_types;
d135 1
a135 1
    num_types = 0;
d138 1
a138 1
       if(counts[i]) num_types++;
a142 1
    rep.num_types = num_types;
d152 1
a152 1
    if(num_types) {
@


1.1.1.4
log
@OpenBSD XF4 tree (minus old and mit) as of today
-> lib and fvwm fixes
@
text
@d162 1
a162 1
                snprintf(buf, sizeof(buf), "Unregistered resource %i", i + 1);
@


