head	1.2;
access;
symbols
	tg-mergetmp-2:1.2
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.2
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.03.07.18.34.45;	author tg;	state Stab;
branches;
next	1.1;

1.1
date	2003.03.22.20.05.53;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.05.53;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.34.17;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.18.09.53;	author tg;	state Exp;
branches;
next	;

1.1.9.1
date	2004.02.14.19.20.48;	author tg;	state Exp;
branches;
next	1.1.9.2;

1.1.9.2
date	2004.03.05.22.21.40;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@semi-automagic merge of these files (ie, I've skipped through the diffs,
and most of that was done by cvs or that weird script of some minutes ago)
@
text
@/* $XFree86: xc/programs/Xserver/Xext/xf86misc.c,v 3.42 2004/02/13 23:58:30 dawes Exp $ */

/*
 * Copyright (c) 1995, 1996  The XFree86 Project, Inc
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 *
 *   1.  Redistributions of source code must retain the above copyright
 *       notice, this list of conditions, and the following disclaimer.
 *
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer
 *       in the documentation and/or other materials provided with the
 *       distribution, and in the same place and form as other copyright,
 *       license and disclaimer information.
 *
 *   3.  The end-user documentation included with the redistribution,
 *       if any, must include the following acknowledgment: "This product
 *       includes software developed by The XFree86 Project, Inc
 *       (http://www.xfree86.org/) and its contributors", in the same
 *       place and form as other third-party acknowledgments.  Alternately,
 *       this acknowledgment may appear in the software itself, in the
 *       same form and location as other such third-party acknowledgments.
 *
 *   4.  Except as contained in this notice, the name of The XFree86
 *       Project, Inc shall not be used in advertising or otherwise to
 *       promote the sale, use or other dealings in this Software without
 *       prior written authorization from The XFree86 Project, Inc.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE XFREE86 PROJECT, INC OR ITS CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* THIS IS NOT AN X CONSORTIUM STANDARD */

#define NEED_REPLIES
#define NEED_EVENTS
#include "X.h"
#include "Xproto.h"
#include "misc.h"
#include "dixstruct.h"
#include "extnsionst.h"
#include "scrnintstr.h"
#include "inputstr.h"
#include "servermd.h"
#define _XF86MISC_SERVER_
#undef _XF86MISC_SAVER_COMPAT_
#include "xf86mscstr.h"
#include "swaprep.h"
#include "xf86.h"
#include "Xfuncproto.h"
#include "xf86miscproc.h"

#if 0
#include <X11/Xtrans.h>
#include "../os/osdep.h"
#include <X11/Xauth.h>
#ifndef USL
#ifndef Lynx
#include <sys/socket.h>
#else
#include <socket.h>
#endif
#endif /* USL */
#endif

#ifdef EXTMODULE
#include "xf86_ansic.h"
#endif

static int miscErrorBase;
static int MiscGeneration = 0;
static int MiscClientPrivateIndex;

/* This holds the client's version information */
typedef struct {
    int		major;
    int		minor;
} MiscPrivRec, *MiscPrivPtr;

#define MPRIV(c) ((c)->devPrivates[MiscClientPrivateIndex].ptr)

static void XF86MiscResetProc(
    ExtensionEntry* /* extEntry */
);

static void
ClientVersion(ClientPtr client, int *major, int *minor)
{
    MiscPrivPtr pPriv;

    pPriv = MPRIV(client);
    if (!pPriv) {
	if (major) *major = 0;
	if (minor) *minor = 0;
	return;
    }
    
    if (major) *major = pPriv->major;
    if (minor) *minor = pPriv->minor;
}

static DISPATCH_PROC(ProcXF86MiscDispatch);
static DISPATCH_PROC(ProcXF86MiscQueryVersion);
static DISPATCH_PROC(ProcXF86MiscGetKbdSettings);
static DISPATCH_PROC(ProcXF86MiscGetMouseSettings);
static DISPATCH_PROC(ProcXF86MiscSetKbdSettings);
static DISPATCH_PROC(ProcXF86MiscSetMouseSettings);
static DISPATCH_PROC(ProcXF86MiscSetGrabKeysState);
static DISPATCH_PROC(ProcXF86MiscSetClientVersion);
static DISPATCH_PROC(ProcXF86MiscGetFilePaths);
static DISPATCH_PROC(ProcXF86MiscPassMessage);
#ifdef _XF86MISC_SAVER_COMPAT_
static DISPATCH_PROC(ProcXF86MiscGetSaver);
static DISPATCH_PROC(ProcXF86MiscSetSaver);
#endif
static DISPATCH_PROC(SProcXF86MiscDispatch);
static DISPATCH_PROC(SProcXF86MiscQueryVersion);
static DISPATCH_PROC(SProcXF86MiscGetKbdSettings);
static DISPATCH_PROC(SProcXF86MiscGetMouseSettings);
static DISPATCH_PROC(SProcXF86MiscSetKbdSettings);
static DISPATCH_PROC(SProcXF86MiscSetMouseSettings);
static DISPATCH_PROC(SProcXF86MiscSetGrabKeysState);
static DISPATCH_PROC(SProcXF86MiscSetClientVersion);
static DISPATCH_PROC(SProcXF86MiscGetFilePaths);
static DISPATCH_PROC(SProcXF86MiscPassMessage);
#ifdef _XF86MISC_SAVER_COMPAT_
static DISPATCH_PROC(SProcXF86MiscGetSaver);
static DISPATCH_PROC(SProcXF86MiscSetSaver);
#endif

#if 0
static unsigned char XF86MiscReqCode = 0;
#endif

#ifdef DEBUG
# define DEBUG_P(x) ErrorF(x"\n");
#else
# define DEBUG_P(x) /**/
#endif

#define MISCERR(x)	(miscErrorBase + x)

void
XFree86MiscExtensionInit(void)
{
    ExtensionEntry* extEntry;

    DEBUG_P("XFree86MiscExtensionInit");

    if (!xf86GetModInDevEnabled())
	return;

    /*
     * Allocate a client private index to hold the client's version
     * information.
     */
    if (MiscGeneration != serverGeneration) {
	MiscClientPrivateIndex = AllocateClientPrivateIndex();
	/*
	 * Allocate 0 length, and use the private to hold a pointer to our
	 * MiscPrivRec.
	 */
	if (!AllocateClientPrivate(MiscClientPrivateIndex, 0)) {
	    ErrorF("XFree86MiscExtensionInit: "
		   "AllocateClientPrivate failed\n");
	    return;
	}
	MiscGeneration = serverGeneration;
    }
    
    if (
	(extEntry = AddExtension(XF86MISCNAME,
				XF86MiscNumberEvents,
				XF86MiscNumberErrors,
				ProcXF86MiscDispatch,
				SProcXF86MiscDispatch,
				XF86MiscResetProc,
				StandardMinorOpcode))) {
#if 0
	XF86MiscReqCode = (unsigned char)extEntry->base;
#endif
	miscErrorBase = extEntry->errorBase;
    }
}

/*ARGSUSED*/
static void
XF86MiscResetProc (extEntry)
    ExtensionEntry* extEntry;
{
}

static int
ProcXF86MiscQueryVersion(client)
    register ClientPtr client;
{
    xXF86MiscQueryVersionReply rep;
    register int n;

    DEBUG_P("XF86MiscQueryVersion");

    REQUEST_SIZE_MATCH(xXF86MiscQueryVersionReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.majorVersion = XF86MISC_MAJOR_VERSION;
    rep.minorVersion = XF86MISC_MINOR_VERSION;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    	swaps(&rep.majorVersion, n);
    	swaps(&rep.minorVersion, n);
    }
    WriteToClient(client, sizeof(xXF86MiscQueryVersionReply), (char *)&rep);
    return (client->noClientException);
}

#ifdef _XF86MISC_SAVER_COMPAT_
/* THESE HAVE NOT BEEN CONVERTED TO THE NEW DESIGN */

/*
 * This will go away, but remains for now for compatibility with older
 * clients.
 */
static int
ProcXF86MiscSetSaver(client)
    register ClientPtr client;
{
    REQUEST(xXF86MiscSetSaverReq);
    ScrnInfoPtr vptr;

    if (stuff->screen > screenInfo.numScreens)
	return BadValue;

    vptr = (ScrnInfoPtr) screenInfo.screens[stuff->screen]->devPrivates[xf86ScreenIndex].ptr;

    REQUEST_SIZE_MATCH(xXF86MiscSetSaverReq);

    if (stuff->suspendTime < 0)
	return BadValue;
    if (stuff->offTime < 0)
	return BadValue;

    return (client->noClientException);
}

/*
 * This will go away, but remains for now for compatibility with older
 * clients.
 */
static int
ProcXF86MiscGetSaver(client)
    register ClientPtr client;
{
    REQUEST(xXF86MiscGetSaverReq);
    xXF86MiscGetSaverReply rep;
    register int n;
    ScrnInfoPtr vptr;

    if (stuff->screen > screenInfo.numScreens)
	return BadValue;

    vptr = (ScrnInfoPtr) screenInfo.screens[stuff->screen]->devPrivates[xf86ScreenIndex].ptr;

    REQUEST_SIZE_MATCH(xXF86MiscGetSaverReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.suspendTime = 0;
    rep.offTime = 0;
    
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    	swapl(&rep.suspendTime, n);
    	swapl(&rep.offTime, n);
    }
    WriteToClient(client, SIZEOF(xXF86MiscGetSaverReply), (char *)&rep);
    return (client->noClientException);
}

#endif /* _XF86MISC_SAVER_COMPAT_ */

static int
ProcXF86MiscGetMouseSettings(client)
    register ClientPtr client;
{
    xXF86MiscGetMouseSettingsReply rep;
    char *devname;
    pointer mouse;
    register int n;

    DEBUG_P("XF86MiscGetMouseSettings");

    REQUEST_SIZE_MATCH(xXF86MiscGetMouseSettingsReq);
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;

    if (!MiscExtGetMouseSettings(&mouse, &devname))
	return BadValue;

    rep.mousetype =	  MiscExtGetMouseValue(mouse, MISC_MSE_PROTO);
    rep.baudrate =	  MiscExtGetMouseValue(mouse, MISC_MSE_BAUDRATE);
    rep.samplerate =	  MiscExtGetMouseValue(mouse, MISC_MSE_SAMPLERATE);
    rep.resolution =	  MiscExtGetMouseValue(mouse, MISC_MSE_RESOLUTION);
    rep.buttons =	  MiscExtGetMouseValue(mouse, MISC_MSE_BUTTONS);
    rep.emulate3buttons = MiscExtGetMouseValue(mouse, MISC_MSE_EM3BUTTONS);
    rep.emulate3timeout = MiscExtGetMouseValue(mouse, MISC_MSE_EM3TIMEOUT);
    rep.chordmiddle =	  MiscExtGetMouseValue(mouse, MISC_MSE_CHORDMIDDLE);
    rep.flags =		  MiscExtGetMouseValue(mouse, MISC_MSE_FLAGS);
    rep.devnamelen = (devname? strlen(devname): 0);
    rep.length = (sizeof(xXF86MiscGetMouseSettingsReply) -
		  sizeof(xGenericReply) + ((rep.devnamelen+3) & ~3)) >> 2;
    
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    	swapl(&rep.mousetype, n);
    	swapl(&rep.baudrate, n);
    	swapl(&rep.samplerate, n);
    	swapl(&rep.resolution, n);
    	swapl(&rep.buttons, n);
    	swapl(&rep.emulate3buttons, n);
    	swapl(&rep.emulate3timeout, n);
    	swapl(&rep.chordmiddle, n);
    	swapl(&rep.flags, n);
    }
    WriteToClient(client, SIZEOF(xXF86MiscGetMouseSettingsReply), (char *)&rep);
    MiscExtDestroyStruct(mouse, MISC_POINTER);
    
    if (rep.devnamelen)
        WriteToClient(client, rep.devnamelen, devname);
    return (client->noClientException);
}

static int
ProcXF86MiscGetKbdSettings(client)
    register ClientPtr client;
{
    xXF86MiscGetKbdSettingsReply rep;
    pointer kbd;
    register int n;

    DEBUG_P("XF86MiscGetKbdSettings");

    REQUEST_SIZE_MATCH(xXF86MiscGetKbdSettingsReq);
    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    if (!MiscExtGetKbdSettings(&kbd))
	return BadValue;

    rep.kbdtype =	MiscExtGetKbdValue(kbd, MISC_KBD_TYPE);
    rep.rate =		MiscExtGetKbdValue(kbd, MISC_KBD_RATE);
    rep.delay =		MiscExtGetKbdValue(kbd, MISC_KBD_DELAY);
    rep.servnumlock =	MiscExtGetKbdValue(kbd, MISC_KBD_SERVNUMLOCK);
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    	swapl(&rep.kbdtype, n);
    	swapl(&rep.rate, n);
    	swapl(&rep.delay, n);
    }
    WriteToClient(client, SIZEOF(xXF86MiscGetKbdSettingsReply), (char *)&rep);
    return (client->noClientException);
}

static int
ProcXF86MiscSetMouseSettings(client)
    register ClientPtr client;
{
    MiscExtReturn ret;
    pointer mouse;
    char *devname = NULL;
    int major, minor;
    
    REQUEST(xXF86MiscSetMouseSettingsReq);

    DEBUG_P("XF86MiscSetMouseSettings");

    REQUEST_AT_LEAST_SIZE(xXF86MiscSetMouseSettingsReq);

    ClientVersion(client, &major, &minor);
    
    if (xf86GetVerbosity() > 1) {
	ErrorF("SetMouseSettings - type: %d brate: %d srate: %d chdmid: %d\n",
		(int)stuff->mousetype, (int)stuff->baudrate,
		(int)stuff->samplerate, stuff->chordmiddle);
	ErrorF("                   em3but: %d em3tim: %d res: %d flags: %ld\n",
		stuff->emulate3buttons, (int)stuff->emulate3timeout,
		(int)stuff->resolution, (unsigned long)stuff->flags);
    }

    if ((mouse = MiscExtCreateStruct(MISC_POINTER)) == (pointer) 0)
	return BadAlloc;

    MiscExtSetMouseValue(mouse, MISC_MSE_PROTO,		stuff->mousetype);
    MiscExtSetMouseValue(mouse, MISC_MSE_BAUDRATE,	stuff->baudrate);
    MiscExtSetMouseValue(mouse, MISC_MSE_SAMPLERATE,	stuff->samplerate);
    MiscExtSetMouseValue(mouse, MISC_MSE_RESOLUTION,	stuff->resolution);
    MiscExtSetMouseValue(mouse, MISC_MSE_BUTTONS,	stuff->buttons);
    MiscExtSetMouseValue(mouse, MISC_MSE_EM3BUTTONS,	stuff->emulate3buttons);
    MiscExtSetMouseValue(mouse, MISC_MSE_EM3TIMEOUT,	stuff->emulate3timeout);
    MiscExtSetMouseValue(mouse, MISC_MSE_CHORDMIDDLE,	stuff->chordmiddle);
    MiscExtSetMouseValue(mouse, MISC_MSE_FLAGS,		stuff->flags);
    
    if ((major > 0 || minor > 5) && stuff->devnamelen) {
	int size = sizeof(xXF86MiscSetMouseSettingsReq) + stuff->devnamelen;
	size = (size + 3) >> 2;
	if (client->req_len < size)
	    return BadLength;
	if (stuff->devnamelen) {
	    if (!(devname = xalloc(stuff->devnamelen)))
		return BadAlloc;
	    strncpy(devname,(char*)(&stuff[1]),stuff->devnamelen);
	    if (xf86GetVerbosity() > 1)
		ErrorF("SetMouseSettings - device: %s\n",devname);
	    MiscExtSetMouseDevice(mouse, devname);
	}
    }

    ret = MiscExtApply(mouse, MISC_POINTER);

    if (devname)
	xfree(devname);
    
    switch ((ret)) {
        case MISC_RET_SUCCESS:      break;
	case MISC_RET_BADVAL:       return BadValue;
	case MISC_RET_BADMSEPROTO:  return MISCERR(XF86MiscBadMouseProtocol);
	case MISC_RET_BADBAUDRATE:  return MISCERR(XF86MiscBadMouseBaudRate);
	case MISC_RET_BADFLAGS:     return MISCERR(XF86MiscBadMouseFlags);
        case MISC_RET_BADCOMBO:     return MISCERR(XF86MiscBadMouseCombo);
        case MISC_RET_NOMODULE:     return MISCERR(XF86MiscNoModule);
        default:
	    ErrorF("Unexpected return from MiscExtApply(POINTER) = %d\n", ret);
	    return BadImplementation;
    }

    if (xf86GetVerbosity() > 1)
	ErrorF("SetMouseSettings - Succeeded\n");
    return (client->noClientException);
}

static int
ProcXF86MiscSetKbdSettings(client)
    register ClientPtr client;
{
    MiscExtReturn ret;
    pointer kbd;
    REQUEST(xXF86MiscSetKbdSettingsReq);

    DEBUG_P("XF86MiscSetKbdSettings");

    REQUEST_SIZE_MATCH(xXF86MiscSetKbdSettingsReq);

    if (xf86GetVerbosity() > 1)
	ErrorF("SetKbdSettings - type: %d rate: %d delay: %d snumlk: %d\n",
		(int)stuff->kbdtype, (int)stuff->rate,
		(int)stuff->delay, stuff->servnumlock);

    if ((kbd = MiscExtCreateStruct(MISC_KEYBOARD)) == (pointer) 0)
	return BadAlloc;

    MiscExtSetKbdValue(kbd, MISC_KBD_TYPE,		stuff->kbdtype);
    MiscExtSetKbdValue(kbd, MISC_KBD_RATE,		stuff->rate);
    MiscExtSetKbdValue(kbd, MISC_KBD_DELAY,		stuff->delay);
    MiscExtSetKbdValue(kbd, MISC_KBD_SERVNUMLOCK,	stuff->servnumlock);

    switch ((ret = MiscExtApply(kbd, MISC_KEYBOARD))) {
	case MISC_RET_SUCCESS:      break;
	case MISC_RET_BADVAL:       return BadValue;
	case MISC_RET_BADKBDTYPE:   return MISCERR(XF86MiscBadKbdType);
	default:
	    ErrorF("Unexpected return from MiscExtApply(KEYBOARD) = %d\n", ret);
	    return BadImplementation;
    }

    if (xf86GetVerbosity() > 1)
	ErrorF("SetKbdSettings - Succeeded\n");
    return (client->noClientException);
}

static int
ProcXF86MiscSetGrabKeysState(client)
    register ClientPtr client;
{
    int n, status;
    xXF86MiscSetGrabKeysStateReply rep;
    REQUEST(xXF86MiscSetGrabKeysStateReq);

    DEBUG_P("XF86MiscSetGrabKeysState");

    REQUEST_SIZE_MATCH(xXF86MiscSetGrabKeysStateReq);

    if ((status = MiscExtSetGrabKeysState(client, stuff->enable)) == 0) {
	if (xf86GetVerbosity() > 1)
	    ErrorF("SetGrabKeysState - %s\n",
		   stuff->enable ? "enabled" : "disabled");
    }

    rep.type = X_Reply;
    rep.length = 0;
    rep.sequenceNumber = client->sequence;
    rep.status = status;
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    	swapl(&rep.status, n);
    }
    WriteToClient(client, SIZEOF(xXF86MiscSetGrabKeysStateReply), (char *)&rep);

    return (client->noClientException);
}

static int
ProcXF86MiscSetClientVersion(ClientPtr client)
{
    REQUEST(xXF86MiscSetClientVersionReq);

    MiscPrivPtr pPriv;

    DEBUG_P("XF86MiscSetClientVersion");

    REQUEST_SIZE_MATCH(xXF86MiscSetClientVersionReq);

    if ((pPriv = MPRIV(client)) == NULL) {
	pPriv = xalloc(sizeof(MiscPrivRec));
	if (!pPriv)
	    return BadAlloc;
	MPRIV(client) = pPriv;
    }
    ErrorF("SetClientVersion: %i %i\n",stuff->major,stuff->minor);
    pPriv->major = stuff->major;
    pPriv->minor = stuff->minor;
    
    return (client->noClientException);
}

static int
ProcXF86MiscGetFilePaths(client)
    register ClientPtr client;
{
    xXF86MiscGetFilePathsReply rep;
    const char *configfile;
    const char *modulepath;
    const char *logfile;
    register int n;

    DEBUG_P("XF86MiscGetFilePaths");

    REQUEST_SIZE_MATCH(xXF86MiscGetFilePathsReq);
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;

    if (!MiscExtGetFilePaths(&configfile, &modulepath, &logfile))
	return BadValue;

    rep.configlen = (configfile? strlen(configfile): 0);
    rep.modulelen = (modulepath? strlen(modulepath): 0);
    rep.loglen = (logfile? strlen(logfile): 0);
    rep.length = (SIZEOF(xXF86MiscGetFilePathsReply) - SIZEOF(xGenericReply) +
		  ((rep.configlen + 3) & ~3) +
		  ((rep.modulelen + 3) & ~3) +
		  ((rep.loglen + 3) & ~3) ) >> 2;
    
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    	swaps(&rep.configlen, n);
    	swaps(&rep.modulelen, n);
    	swaps(&rep.loglen, n);
    }
    WriteToClient(client, SIZEOF(xXF86MiscGetFilePathsReply), (char *)&rep);
    
    if (rep.configlen)
        WriteToClient(client, rep.configlen, (char *)configfile);
    if (rep.modulelen)
        WriteToClient(client, rep.modulelen, (char *)modulepath);
    if (rep.loglen)
        WriteToClient(client, rep.loglen, (char *)logfile);

    return (client->noClientException);
}

static int
ProcXF86MiscPassMessage(client)
    register ClientPtr client;
{
    xXF86MiscPassMessageReply rep;
    char *msgtype, *msgval, *retstr;
    int retval, size;
    register int n;

    REQUEST(xXF86MiscPassMessageReq);

    DEBUG_P("XF86MiscPassMessage");

    REQUEST_AT_LEAST_SIZE(xXF86MiscPassMessageReq);
    size = (sizeof(xXF86MiscPassMessageReq) + 3) >> 2;
    size+= (stuff->typelen + 3) >> 2;
    size+= (stuff->vallen  + 3) >> 2;
    if (client->req_len < size)
	return BadLength;
    if (stuff->typelen) {
	if (!(msgtype = xalloc(stuff->typelen)))
	    return BadAlloc;
	strncpy(msgtype,(char*)(&stuff[1]),stuff->typelen);
    } else return BadValue;
    if (stuff->vallen) {
	if (!(msgval = xalloc(stuff->vallen)))
	    return BadAlloc;
	strncpy(msgval,(char*)(&stuff[1] + ((stuff->typelen + 3) & ~3)),
			stuff->vallen);
    } else return BadValue;

    if ((retval= MiscExtPassMessage(stuff->screen,msgtype,msgval,&retstr)) != 0)
	return retval;

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.mesglen = (retstr? strlen(retstr): 0);
    rep.length = (SIZEOF(xXF86MiscPassMessageReply) - SIZEOF(xGenericReply) +
		  ((rep.mesglen + 3) & ~3)) >> 2;
    
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    	swaps(&rep.mesglen, n);
    }
    WriteToClient(client, SIZEOF(xXF86MiscPassMessageReply), (char *)&rep);
    
    if (rep.mesglen)
        WriteToClient(client, rep.mesglen, (char *)retstr);

    return (client->noClientException);
}

static int
ProcXF86MiscDispatch (client)
    register ClientPtr	client;
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_XF86MiscQueryVersion:
	return ProcXF86MiscQueryVersion(client);
#ifdef _XF86MISC_SAVER_COMPAT_
    case X_XF86MiscGetSaver:
	return ProcXF86MiscGetSaver(client);
    case X_XF86MiscSetSaver:
	return ProcXF86MiscSetSaver(client);
#endif
    case X_XF86MiscGetMouseSettings:
	return ProcXF86MiscGetMouseSettings(client);
    case X_XF86MiscGetKbdSettings:
	return ProcXF86MiscGetKbdSettings(client);
    case X_XF86MiscSetClientVersion:
		return ProcXF86MiscSetClientVersion(client);
    case X_XF86MiscGetFilePaths:
	return ProcXF86MiscGetFilePaths(client);
    case X_XF86MiscPassMessage:
	return ProcXF86MiscPassMessage(client);
    default:
	if (!xf86GetModInDevEnabled())
	    return miscErrorBase + XF86MiscModInDevDisabled;
	if (xf86GetModInDevAllowNonLocal() || LocalClient (client)) {
	    switch (stuff->data) {
	        case X_XF86MiscSetMouseSettings:
		    return ProcXF86MiscSetMouseSettings(client);
	        case X_XF86MiscSetKbdSettings:
		    return ProcXF86MiscSetKbdSettings(client);
		case X_XF86MiscSetGrabKeysState:
		    return ProcXF86MiscSetGrabKeysState(client);
	        default:
		    return BadRequest;
	    }
	} else
	    return miscErrorBase + XF86MiscModInDevClientNotLocal;
    }
}

static int
SProcXF86MiscQueryVersion(client)
    register ClientPtr	client;
{
    register int n;
    REQUEST(xXF86MiscQueryVersionReq);
    swaps(&stuff->length, n);
    return ProcXF86MiscQueryVersion(client);
}

#ifdef _XF86MISC_SAVER_COMPAT_
static int
SProcXF86MiscGetSaver(client)
    ClientPtr client;
{
    register int n;
    REQUEST(xXF86MiscGetSaverReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscGetSaverReq);
    swaps(&stuff->screen, n);
    return ProcXF86MiscGetSaver(client);
}

static int
SProcXF86MiscSetSaver(client)
    ClientPtr client;
{
    register int n;
    REQUEST(xXF86MiscSetSaverReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscSetSaverReq);
    swaps(&stuff->screen, n);
    swapl(&stuff->suspendTime, n);
    swapl(&stuff->offTime, n);
    return ProcXF86MiscSetSaver(client);
}
#endif /* _XF86MISC_SAVER_COMPAT_ */

static int
SProcXF86MiscGetMouseSettings(client)
    ClientPtr client;
{
    register int n;
    REQUEST(xXF86MiscGetMouseSettingsReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscGetMouseSettingsReq);
    return ProcXF86MiscGetMouseSettings(client);
}

static int
SProcXF86MiscGetKbdSettings(client)
    ClientPtr client;
{
    register int n;
    REQUEST(xXF86MiscGetKbdSettingsReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscGetKbdSettingsReq);
    return ProcXF86MiscGetKbdSettings(client);
}

static int
SProcXF86MiscSetMouseSettings(client)
    ClientPtr client;
{
    register int n;
    REQUEST(xXF86MiscSetMouseSettingsReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscSetMouseSettingsReq);
    swapl(&stuff->mousetype, n);
    swapl(&stuff->baudrate, n);
    swapl(&stuff->samplerate, n);
    swapl(&stuff->resolution, n);
    swapl(&stuff->buttons, n);
    swapl(&stuff->emulate3timeout, n);
    swapl(&stuff->flags, n);
    return ProcXF86MiscSetMouseSettings(client);
}

static int
SProcXF86MiscSetKbdSettings(client)
    ClientPtr client;
{
    register int n;
    REQUEST(xXF86MiscSetKbdSettingsReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscSetKbdSettingsReq);
    swapl(&stuff->kbdtype, n);
    swapl(&stuff->rate, n);
    swapl(&stuff->delay, n);
    return ProcXF86MiscSetKbdSettings(client);
}

static int
SProcXF86MiscSetGrabKeysState(client)
    ClientPtr client;
{
    register int n;
    REQUEST(xXF86MiscSetGrabKeysStateReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscSetGrabKeysStateReq);
    swaps(&stuff->enable, n);
    return ProcXF86MiscSetGrabKeysState(client);
}

static int
SProcXF86MiscSetClientVersion(ClientPtr client)
{
    register int n;
    REQUEST(xXF86MiscSetClientVersionReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscSetClientVersionReq);
    swaps(&stuff->major, n);
    swaps(&stuff->minor, n);
    return ProcXF86MiscSetClientVersion(client);
}

static int
SProcXF86MiscGetFilePaths(client)
    ClientPtr client;
{
    register int n;
    REQUEST(xXF86MiscGetFilePathsReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscGetFilePathsReq);
    return ProcXF86MiscGetFilePaths(client);
}

static int
SProcXF86MiscPassMessage(client)
    ClientPtr client;
{
    register int n;
    REQUEST(xXF86MiscPassMessageReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscPassMessageReq);
    return ProcXF86MiscPassMessage(client);
}

static int
SProcXF86MiscDispatch (client)
    register ClientPtr	client;
{
    REQUEST(xReq);
    switch (stuff->data)
    {
    case X_XF86MiscQueryVersion:
	return SProcXF86MiscQueryVersion(client);
#ifdef _XF86MISC_SAVER_COMPAT_
    case X_XF86MiscGetSaver:
	return SProcXF86MiscGetSaver(client);
    case X_XF86MiscSetSaver:
	return SProcXF86MiscSetSaver(client);
#endif
    case X_XF86MiscGetMouseSettings:
	return SProcXF86MiscGetMouseSettings(client);
    case X_XF86MiscGetKbdSettings:
	return SProcXF86MiscGetKbdSettings(client);
    case X_XF86MiscSetClientVersion:
	return SProcXF86MiscSetClientVersion(client);
    case X_XF86MiscGetFilePaths:
	return SProcXF86MiscGetFilePaths(client);
    case X_XF86MiscPassMessage:
	return SProcXF86MiscPassMessage(client);
    default:
	if (!xf86GetModInDevEnabled())
	    return miscErrorBase + XF86MiscModInDevDisabled;
	if (xf86GetModInDevAllowNonLocal() || LocalClient (client)) {
	    switch (stuff->data) {
	        case X_XF86MiscSetMouseSettings:
		    return SProcXF86MiscSetMouseSettings(client);
	        case X_XF86MiscSetKbdSettings:
		    return SProcXF86MiscSetKbdSettings(client);
	        case X_XF86MiscSetGrabKeysState:
		    return SProcXF86MiscSetGrabKeysState(client);
	        default:
		    return BadRequest;
	    }
	} else
	    return miscErrorBase + XF86MiscModInDevClientNotLocal;
    }
}

@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/Xext/xf86misc.c,v 3.35 2001/08/15 16:25:20 paulo Exp $ */
d5 43
d88 10
a99 1
#if NeedFunctionPrototypes
a100 1
#endif
d103 16
d126 3
d140 3
d148 1
d150 1
d170 18
d196 1
d198 1
d391 3
d398 1
a398 1
    REQUEST_SIZE_MATCH(xXF86MiscSetMouseSettingsReq);
d400 2
d404 5
a408 5
		stuff->mousetype, stuff->baudrate,
		stuff->samplerate, stuff->chordmiddle);
	ErrorF("                   em3but: %d em3tim: %d res: %d flags: %d\n",
		stuff->emulate3buttons, stuff->emulate3timeout,
		stuff->resolution, stuff->flags);
d423 17
d441 4
a444 1
    switch ((ret = MiscExtApply(mouse, MISC_POINTER))) {
d476 2
a477 2
		stuff->kbdtype, stuff->rate,
		stuff->delay, stuff->servnumlock);
d534 123
d675 6
d805 34
d857 6
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/Xext/xf86misc.c,v 3.41 2003/11/17 22:20:27 dawes Exp $ */
a44 10
static int MiscGeneration = 0;
static int MiscClientPrivateIndex;

/* This holds the client's version information */
typedef struct {
    int		major;
    int		minor;
} MiscPrivRec, *MiscPrivPtr;

#define MPRIV(c) ((c)->devPrivates[MiscClientPrivateIndex].ptr)
d47 1
d49 1
a51 16
static void
ClientVersion(ClientPtr client, int *major, int *minor)
{
    MiscPrivPtr pPriv;

    pPriv = MPRIV(client);
    if (!pPriv) {
	if (major) *major = 0;
	if (minor) *minor = 0;
	return;
    }
    
    if (major) *major = pPriv->major;
    if (minor) *minor = pPriv->minor;
}

a58 3
static DISPATCH_PROC(ProcXF86MiscSetClientVersion);
static DISPATCH_PROC(ProcXF86MiscGetFilePaths);
static DISPATCH_PROC(ProcXF86MiscPassMessage);
a69 3
static DISPATCH_PROC(SProcXF86MiscSetClientVersion);
static DISPATCH_PROC(SProcXF86MiscGetFilePaths);
static DISPATCH_PROC(SProcXF86MiscPassMessage);
a74 1
#if 0
a75 1
#endif
a94 18
    /*
     * Allocate a client private index to hold the client's version
     * information.
     */
    if (MiscGeneration != serverGeneration) {
	MiscClientPrivateIndex = AllocateClientPrivateIndex();
	/*
	 * Allocate 0 length, and use the private to hold a pointer to our
	 * MiscPrivRec.
	 */
	if (!AllocateClientPrivate(MiscClientPrivateIndex, 0)) {
	    ErrorF("XFree86MiscExtensionInit: "
		   "AllocateClientPrivate failed\n");
	    return;
	}
	MiscGeneration = serverGeneration;
    }
    
a102 1
#if 0
a103 1
#endif
a295 3
    char *devname = NULL;
    int major, minor;
    
d300 1
a300 1
    REQUEST_AT_LEAST_SIZE(xXF86MiscSetMouseSettingsReq);
a301 2
    ClientVersion(client, &major, &minor);
    
d304 5
a308 5
		(int)stuff->mousetype, (int)stuff->baudrate,
		(int)stuff->samplerate, stuff->chordmiddle);
	ErrorF("                   em3but: %d em3tim: %d res: %d flags: %ld\n",
		stuff->emulate3buttons, (int)stuff->emulate3timeout,
		(int)stuff->resolution, (unsigned long)stuff->flags);
a322 17
    
    if ((major > 0 || minor > 5) && stuff->devnamelen) {
	int size = sizeof(xXF86MiscSetMouseSettingsReq) + stuff->devnamelen;
	size = (size + 3) >> 2;
	if (client->req_len < size)
	    return BadLength;
	if (stuff->devnamelen) {
	    if (!(devname = xalloc(stuff->devnamelen)))
		return BadAlloc;
	    strncpy(devname,(char*)(&stuff[1]),stuff->devnamelen);
	    if (xf86GetVerbosity() > 1)
		ErrorF("SetMouseSettings - device: %s\n",devname);
	    MiscExtSetMouseDevice(mouse, devname);
	}
    }

    ret = MiscExtApply(mouse, MISC_POINTER);
d324 1
a324 4
    if (devname)
	xfree(devname);
    
    switch ((ret)) {
d356 2
a357 2
		(int)stuff->kbdtype, (int)stuff->rate,
		(int)stuff->delay, stuff->servnumlock);
a413 123
ProcXF86MiscSetClientVersion(ClientPtr client)
{
    REQUEST(xXF86MiscSetClientVersionReq);

    MiscPrivPtr pPriv;

    DEBUG_P("XF86MiscSetClientVersion");

    REQUEST_SIZE_MATCH(xXF86MiscSetClientVersionReq);

    if ((pPriv = MPRIV(client)) == NULL) {
	pPriv = xalloc(sizeof(MiscPrivRec));
	if (!pPriv)
	    return BadAlloc;
	MPRIV(client) = pPriv;
    }
    ErrorF("SetClientVersion: %i %i\n",stuff->major,stuff->minor);
    pPriv->major = stuff->major;
    pPriv->minor = stuff->minor;
    
    return (client->noClientException);
}

static int
ProcXF86MiscGetFilePaths(client)
    register ClientPtr client;
{
    xXF86MiscGetFilePathsReply rep;
    const char *configfile;
    const char *modulepath;
    const char *logfile;
    register int n;

    DEBUG_P("XF86MiscGetFilePaths");

    REQUEST_SIZE_MATCH(xXF86MiscGetFilePathsReq);
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;

    if (!MiscExtGetFilePaths(&configfile, &modulepath, &logfile))
	return BadValue;

    rep.configlen = (configfile? strlen(configfile): 0);
    rep.modulelen = (modulepath? strlen(modulepath): 0);
    rep.loglen = (logfile? strlen(logfile): 0);
    rep.length = (SIZEOF(xXF86MiscGetFilePathsReply) - SIZEOF(xGenericReply) +
		  ((rep.configlen + 3) & ~3) +
		  ((rep.modulelen + 3) & ~3) +
		  ((rep.loglen + 3) & ~3) ) >> 2;
    
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    	swaps(&rep.configlen, n);
    	swaps(&rep.modulelen, n);
    	swaps(&rep.loglen, n);
    }
    WriteToClient(client, SIZEOF(xXF86MiscGetFilePathsReply), (char *)&rep);
    
    if (rep.configlen)
        WriteToClient(client, rep.configlen, (char *)configfile);
    if (rep.modulelen)
        WriteToClient(client, rep.modulelen, (char *)modulepath);
    if (rep.loglen)
        WriteToClient(client, rep.loglen, (char *)logfile);

    return (client->noClientException);
}

static int
ProcXF86MiscPassMessage(client)
    register ClientPtr client;
{
    xXF86MiscPassMessageReply rep;
    char *msgtype, *msgval, *retstr;
    int retval, size;
    register int n;

    REQUEST(xXF86MiscPassMessageReq);

    DEBUG_P("XF86MiscPassMessage");

    REQUEST_AT_LEAST_SIZE(xXF86MiscPassMessageReq);
    size = (sizeof(xXF86MiscPassMessageReq) + 3) >> 2;
    size+= (stuff->typelen + 3) >> 2;
    size+= (stuff->vallen  + 3) >> 2;
    if (client->req_len < size)
	return BadLength;
    if (stuff->typelen) {
	if (!(msgtype = xalloc(stuff->typelen)))
	    return BadAlloc;
	strncpy(msgtype,(char*)(&stuff[1]),stuff->typelen);
    } else return BadValue;
    if (stuff->vallen) {
	if (!(msgval = xalloc(stuff->vallen)))
	    return BadAlloc;
	strncpy(msgval,(char*)(&stuff[1] + ((stuff->typelen + 3) & ~3)),
			stuff->vallen);
    } else return BadValue;

    if ((retval= MiscExtPassMessage(stuff->screen,msgtype,msgval,&retstr)) != 0)
	return retval;

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.mesglen = (retstr? strlen(retstr): 0);
    rep.length = (SIZEOF(xXF86MiscPassMessageReply) - SIZEOF(xGenericReply) +
		  ((rep.mesglen + 3) & ~3)) >> 2;
    
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    	swaps(&rep.mesglen, n);
    }
    WriteToClient(client, SIZEOF(xXF86MiscPassMessageReply), (char *)&rep);
    
    if (rep.mesglen)
        WriteToClient(client, rep.mesglen, (char *)retstr);

    return (client->noClientException);
}

static int
a431 6
    case X_XF86MiscSetClientVersion:
		return ProcXF86MiscSetClientVersion(client);
    case X_XF86MiscGetFilePaths:
	return ProcXF86MiscGetFilePaths(client);
    case X_XF86MiscPassMessage:
	return ProcXF86MiscPassMessage(client);
a555 34
SProcXF86MiscSetClientVersion(ClientPtr client)
{
    register int n;
    REQUEST(xXF86MiscSetClientVersionReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscSetClientVersionReq);
    swaps(&stuff->major, n);
    swaps(&stuff->minor, n);
    return ProcXF86MiscSetClientVersion(client);
}

static int
SProcXF86MiscGetFilePaths(client)
    ClientPtr client;
{
    register int n;
    REQUEST(xXF86MiscGetFilePathsReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscGetFilePathsReq);
    return ProcXF86MiscGetFilePaths(client);
}

static int
SProcXF86MiscPassMessage(client)
    ClientPtr client;
{
    register int n;
    REQUEST(xXF86MiscPassMessageReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscPassMessageReq);
    return ProcXF86MiscPassMessage(client);
}

static int
a573 6
    case X_XF86MiscSetClientVersion:
	return SProcXF86MiscSetClientVersion(client);
    case X_XF86MiscGetFilePaths:
	return SProcXF86MiscGetFilePaths(client);
    case X_XF86MiscPassMessage:
	return SProcXF86MiscPassMessage(client);
@


1.1.9.2
log
@Import XFree86 4.4 from The XFree86(TM) Project, Inc.
(integrity cannot be checked)

got via cvs -qd anoncvs@@anoncvs.xfree86.org:/cvs co -Prxf-4_4_0 xc
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/Xext/xf86misc.c,v 3.42 2004/02/13 23:58:30 dawes Exp $ */
a4 43
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject
 * to the following conditions:
 *
 *   1.  Redistributions of source code must retain the above copyright
 *       notice, this list of conditions, and the following disclaimer.
 *
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer
 *       in the documentation and/or other materials provided with the
 *       distribution, and in the same place and form as other copyright,
 *       license and disclaimer information.
 *
 *   3.  The end-user documentation included with the redistribution,
 *       if any, must include the following acknowledgment: "This product
 *       includes software developed by The XFree86 Project, Inc
 *       (http://www.xfree86.org/) and its contributors", in the same
 *       place and form as other third-party acknowledgments.  Alternately,
 *       this acknowledgment may appear in the software itself, in the
 *       same form and location as other such third-party acknowledgments.
 *
 *   4.  Except as contained in this notice, the name of The XFree86
 *       Project, Inc shall not be used in advertising or otherwise to
 *       promote the sale, use or other dealings in this Software without
 *       prior written authorization from The XFree86 Project, Inc.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE XFREE86 PROJECT, INC OR ITS CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/Xext/xf86misc.c,v 3.37 2002/11/20 04:04:58 dawes Exp $ */
a44 10
static int MiscGeneration = 0;
static int MiscClientPrivateIndex;

/* This holds the client's version information */
typedef struct {
    int		major;
    int		minor;
} MiscPrivRec, *MiscPrivPtr;

#define MPRIV(c) ((c)->devPrivates[MiscClientPrivateIndex].ptr)
a51 16
static void
ClientVersion(ClientPtr client, int *major, int *minor)
{
    MiscPrivPtr pPriv;

    pPriv = MPRIV(client);
    if (!pPriv) {
	if (major) *major = 0;
	if (minor) *minor = 0;
	return;
    }
    
    if (major) *major = pPriv->major;
    if (minor) *minor = pPriv->minor;
}

a58 2
static DISPATCH_PROC(ProcXF86MiscSetClientVersion);
static DISPATCH_PROC(ProcXF86MiscGetFilePaths);
a69 2
static DISPATCH_PROC(SProcXF86MiscSetClientVersion);
static DISPATCH_PROC(SProcXF86MiscGetFilePaths);
a94 18
    /*
     * Allocate a client private index to hold the client's version
     * information.
     */
    if (MiscGeneration != serverGeneration) {
	MiscClientPrivateIndex = AllocateClientPrivateIndex();
	/*
	 * Allocate 0 length, and use the private to hold a pointer to our
	 * MiscPrivRec.
	 */
	if (!AllocateClientPrivate(MiscClientPrivateIndex, 0)) {
	    ErrorF("XFree86MiscExtensionInit: "
		   "AllocateClientPrivate failed\n");
	    return;
	}
	MiscGeneration = serverGeneration;
    }
    
a295 3
    char *devname = NULL;
    int major, minor;
    
d300 1
a300 1
    REQUEST_AT_LEAST_SIZE(xXF86MiscSetMouseSettingsReq);
a301 2
    ClientVersion(client, &major, &minor);
    
a310 1
    
a322 17
    
    if ((major > 0 || minor > 5) && stuff->devnamelen) {
	int size = sizeof(xXF86MiscSetMouseSettingsReq) + stuff->devnamelen;
	size = (size + 3) >> 2;
	if (client->req_len < size)
	    return BadLength;
	if (stuff->devnamelen) {
	    if (!(devname = xalloc(stuff->devnamelen)))
		return BadAlloc;
	    strncpy(devname,(char*)(&stuff[1]),stuff->devnamelen);
	    if (xf86GetVerbosity() > 1)
		ErrorF("SetMouseSettings - device: %s\n",devname);
	    MiscExtSetMouseDevice(mouse, devname);
	}
    }

    ret = MiscExtApply(mouse, MISC_POINTER);
d324 1
a324 4
    if (devname)
	xfree(devname);
    
    switch ((ret)) {
a413 70
ProcXF86MiscSetClientVersion(ClientPtr client)
{
    REQUEST(xXF86MiscSetClientVersionReq);

    MiscPrivPtr pPriv;

    DEBUG_P("XF86MiscSetClientVersion");

    REQUEST_SIZE_MATCH(xXF86MiscSetClientVersionReq);

    if ((pPriv = MPRIV(client)) == NULL) {
	pPriv = xalloc(sizeof(MiscPrivRec));
	if (!pPriv)
	    return BadAlloc;
	MPRIV(client) = pPriv;
    }
    ErrorF("SetClientVersion: %i %i\n",stuff->major,stuff->minor);
    pPriv->major = stuff->major;
    pPriv->minor = stuff->minor;
    
    return (client->noClientException);
}

static int
ProcXF86MiscGetFilePaths(client)
    register ClientPtr client;
{
    xXF86MiscGetFilePathsReply rep;
    const char *configfile;
    const char *modulepath;
    const char *logfile;
    register int n;

    DEBUG_P("XF86MiscGetFilePaths");

    REQUEST_SIZE_MATCH(xXF86MiscGetFilePathsReq);
    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;

    if (!MiscExtGetFilePaths(&configfile, &modulepath, &logfile))
	return BadValue;

    rep.configlen = (configfile? strlen(configfile): 0);
    rep.modulelen = (modulepath? strlen(modulepath): 0);
    rep.loglen = (logfile? strlen(logfile): 0);
    rep.length = (SIZEOF(xXF86MiscGetFilePathsReply) - SIZEOF(xGenericReply) +
		  ((rep.configlen + 3) & ~3) +
		  ((rep.modulelen + 3) & ~3) +
		  ((rep.loglen + 3) & ~3) ) >> 2;
    
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    	swaps(&rep.configlen, n);
    	swaps(&rep.modulelen, n);
    	swaps(&rep.loglen, n);
    }
    WriteToClient(client, SIZEOF(xXF86MiscGetFilePathsReply), (char *)&rep);
    
    if (rep.configlen)
        WriteToClient(client, rep.configlen, (char *)configfile);
    if (rep.modulelen)
        WriteToClient(client, rep.modulelen, (char *)modulepath);
    if (rep.loglen)
        WriteToClient(client, rep.loglen, (char *)logfile);

    return (client->noClientException);
}

static int
a431 4
    case X_XF86MiscSetClientVersion:
		return ProcXF86MiscSetClientVersion(client);
    case X_XF86MiscGetFilePaths:
	return ProcXF86MiscGetFilePaths(client);
a555 23
SProcXF86MiscSetClientVersion(ClientPtr client)
{
    register int n;
    REQUEST(xXF86MiscSetClientVersionReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscSetClientVersionReq);
    swaps(&stuff->major, n);
    swaps(&stuff->minor, n);
    return ProcXF86MiscSetClientVersion(client);
}

static int
SProcXF86MiscGetFilePaths(client)
    ClientPtr client;
{
    register int n;
    REQUEST(xXF86MiscGetFilePathsReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscGetFilePathsReq);
    return ProcXF86MiscGetFilePaths(client);
}

static int
a573 4
    case X_XF86MiscSetClientVersion:
	return SProcXF86MiscSetClientVersion(client);
    case X_XF86MiscGetFilePaths:
	return SProcXF86MiscGetFilePaths(client);
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
a1 1
/* $XFree86: xc/programs/Xserver/Xext/xf86misc.c,v 3.41 2003/11/17 22:20:27 dawes Exp $ */
d57 1
d59 1
a86 1
static DISPATCH_PROC(ProcXF86MiscPassMessage);
a99 1
static DISPATCH_PROC(SProcXF86MiscPassMessage);
a104 1
#if 0
a105 1
#endif
a150 1
#if 0
a151 1
#endif
d357 5
a361 5
		(int)stuff->mousetype, (int)stuff->baudrate,
		(int)stuff->samplerate, stuff->chordmiddle);
	ErrorF("                   em3but: %d em3tim: %d res: %d flags: %ld\n",
		stuff->emulate3buttons, (int)stuff->emulate3timeout,
		(int)stuff->resolution, (unsigned long)stuff->flags);
d364 1
d430 2
a431 2
		(int)stuff->kbdtype, (int)stuff->rate,
		(int)stuff->delay, stuff->servnumlock);
a557 53
ProcXF86MiscPassMessage(client)
    register ClientPtr client;
{
    xXF86MiscPassMessageReply rep;
    char *msgtype, *msgval, *retstr;
    int retval, size;
    register int n;

    REQUEST(xXF86MiscPassMessageReq);

    DEBUG_P("XF86MiscPassMessage");

    REQUEST_AT_LEAST_SIZE(xXF86MiscPassMessageReq);
    size = (sizeof(xXF86MiscPassMessageReq) + 3) >> 2;
    size+= (stuff->typelen + 3) >> 2;
    size+= (stuff->vallen  + 3) >> 2;
    if (client->req_len < size)
	return BadLength;
    if (stuff->typelen) {
	if (!(msgtype = xalloc(stuff->typelen)))
	    return BadAlloc;
	strncpy(msgtype,(char*)(&stuff[1]),stuff->typelen);
    } else return BadValue;
    if (stuff->vallen) {
	if (!(msgval = xalloc(stuff->vallen)))
	    return BadAlloc;
	strncpy(msgval,(char*)(&stuff[1] + ((stuff->typelen + 3) & ~3)),
			stuff->vallen);
    } else return BadValue;

    if ((retval= MiscExtPassMessage(stuff->screen,msgtype,msgval,&retstr)) != 0)
	return retval;

    rep.type = X_Reply;
    rep.sequenceNumber = client->sequence;
    rep.mesglen = (retstr? strlen(retstr): 0);
    rep.length = (SIZEOF(xXF86MiscPassMessageReply) - SIZEOF(xGenericReply) +
		  ((rep.mesglen + 3) & ~3)) >> 2;
    
    if (client->swapped) {
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.length, n);
    	swaps(&rep.mesglen, n);
    }
    WriteToClient(client, SIZEOF(xXF86MiscPassMessageReply), (char *)&rep);
    
    if (rep.mesglen)
        WriteToClient(client, rep.mesglen, (char *)retstr);

    return (client->noClientException);
}

static int
a579 2
    case X_XF86MiscPassMessage:
	return ProcXF86MiscPassMessage(client);
a726 11
SProcXF86MiscPassMessage(client)
    ClientPtr client;
{
    register int n;
    REQUEST(xXF86MiscPassMessageReq);
    swaps(&stuff->length, n);
    REQUEST_SIZE_MATCH(xXF86MiscPassMessageReq);
    return ProcXF86MiscPassMessage(client);
}

static int
a748 2
    case X_XF86MiscPassMessage:
	return SProcXF86MiscPassMessage(client);
@


