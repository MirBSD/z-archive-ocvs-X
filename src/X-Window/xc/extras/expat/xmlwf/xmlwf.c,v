head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.3
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.3
	MIRBSD_7_ALPHA:1.1.1.3.0.4
	MIRBSD_7:1.1.1.3.0.2
	MIRBSD_7ter:1.1.1.3
	cvs-20011091815:1.1.1.3
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.29.25;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.04.08.18.20.30;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.04.08.18.20.30;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.15.15.20;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.09.18.33.39;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.05.54;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@/*
Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
See the file COPYING for copying permission.
*/

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>

#include "expat.h"
#include "codepage.h"
#include "xmlfile.h"
#include "xmltchar.h"

#ifdef _MSC_VER
#include <crtdbg.h>
#endif

/* This ensures proper sorting. */

#define NSSEP T('\001')

static void characterData(void *userData, const XML_Char *s, int len)
{
  FILE *fp = userData;
  for (; len > 0; --len, ++s) {
    switch (*s) {
    case T('&'):
      fputts(T("&amp;"), fp);
      break;
    case T('<'):
      fputts(T("&lt;"), fp);
      break;
    case T('>'):
      fputts(T("&gt;"), fp);
      break;
#ifdef W3C14N
    case 13:
      fputts(T("&#xD;"), fp);
      break;
#else
    case T('"'):
      fputts(T("&quot;"), fp);
      break;
    case 9:
    case 10:
    case 13:
      ftprintf(fp, T("&#%d;"), *s);
      break;
#endif
    default:
      puttc(*s, fp);
      break;
    }
  }
}

static void attributeValue(FILE *fp, const XML_Char *s)
{
  puttc(T('='), fp);
  puttc(T('"'), fp);
  for (;;) {
    switch (*s) {
    case 0:
    case NSSEP:
      puttc(T('"'), fp);
      return;
    case T('&'):
      fputts(T("&amp;"), fp);
      break;
    case T('<'):
      fputts(T("&lt;"), fp);
      break;
    case T('"'):
      fputts(T("&quot;"), fp);
      break;
#ifdef W3C14N
    case 9:
      fputts(T("&#x9;"), fp);
      break;
    case 10:
      fputts(T("&#xA;"), fp);
      break;
    case 13:
      fputts(T("&#xD;"), fp);
      break;
#else
    case T('>'):
      fputts(T("&gt;"), fp);
      break;
    case 9:
    case 10:
    case 13:
      ftprintf(fp, T("&#%d;"), *s);
      break;
#endif
    default:
      puttc(*s, fp);
      break;
    }
    s++;
  }
}

/* Lexicographically comparing UTF-8 encoded attribute values,
is equivalent to lexicographically comparing based on the character number. */

static int attcmp(const void *att1, const void *att2)
{
  return tcscmp(*(const XML_Char **)att1, *(const XML_Char **)att2);
}

static void startElement(void *userData, const XML_Char *name, const XML_Char **atts)
{
  int nAtts;
  const XML_Char **p;
  FILE *fp = userData;
  puttc(T('<'), fp);
  fputts(name, fp);

  p = atts;
  while (*p)
    ++p;
  nAtts = (p - atts) >> 1;
  if (nAtts > 1)
    qsort((void *)atts, nAtts, sizeof(XML_Char *) * 2, attcmp);
  while (*atts) {
    puttc(T(' '), fp);
    fputts(*atts++, fp);
    attributeValue(fp, *atts);
    atts++;
  }
  puttc(T('>'), fp);
}

static void endElement(void *userData, const XML_Char *name)
{
  FILE *fp = userData;
  puttc(T('<'), fp);
  puttc(T('/'), fp);
  fputts(name, fp);
  puttc(T('>'), fp);
}

static int nsattcmp(const void *p1, const void *p2)
{
  const XML_Char *att1 = *(const XML_Char **)p1;
  const XML_Char *att2 = *(const XML_Char **)p2;
  int sep1 = (tcsrchr(att1, NSSEP) != 0);
  int sep2 = (tcsrchr(att1, NSSEP) != 0);
  if (sep1 != sep2)
    return sep1 - sep2;
  return tcscmp(att1, att2);
}

static void startElementNS(void *userData, const XML_Char *name, const XML_Char **atts)
{
  int nAtts;
  int nsi;
  const XML_Char **p;
  FILE *fp = userData;
  const XML_Char *sep;
  puttc(T('<'), fp);

  sep = tcsrchr(name, NSSEP);
  if (sep) {
    fputts(T("n1:"), fp);
    fputts(sep + 1, fp);
    fputts(T(" xmlns:n1"), fp);
    attributeValue(fp, name);
    nsi = 2;
  }
  else {
    fputts(name, fp);
    nsi = 1;
  }

  p = atts;
  while (*p)
    ++p;
  nAtts = (p - atts) >> 1;
  if (nAtts > 1)
    qsort((void *)atts, nAtts, sizeof(XML_Char *) * 2, nsattcmp);
  while (*atts) {
    name = *atts++;
    sep = tcsrchr(name, NSSEP);
    puttc(T(' '), fp);
    if (sep) {
      ftprintf(fp, T("n%d:"), nsi);
      fputts(sep + 1, fp);
    }
    else
      fputts(name, fp);
    attributeValue(fp, *atts);
    if (sep) {
      ftprintf(fp, T(" xmlns:n%d"), nsi++);
      attributeValue(fp, name);
    }
    atts++;
  }
  puttc(T('>'), fp);
}

static void endElementNS(void *userData, const XML_Char *name)
{
  FILE *fp = userData;
  const XML_Char *sep;
  puttc(T('<'), fp);
  puttc(T('/'), fp);
  sep = tcsrchr(name, NSSEP);
  if (sep) {
    fputts(T("n1:"), fp);
    fputts(sep + 1, fp);
  }
  else
    fputts(name, fp);
  puttc(T('>'), fp);
}

#ifndef W3C14N

static void processingInstruction(void *userData, const XML_Char *target, const XML_Char *data)
{
  FILE *fp = userData;
  puttc(T('<'), fp);
  puttc(T('?'), fp);
  fputts(target, fp);
  puttc(T(' '), fp);
  fputts(data, fp);
  puttc(T('?'), fp);
  puttc(T('>'), fp);
}

#endif /* not W3C14N */

static void defaultCharacterData(XML_Parser parser, const XML_Char *s, int len)
{
  XML_DefaultCurrent(parser);
}

static void defaultStartElement(XML_Parser parser, const XML_Char *name, const XML_Char **atts)
{
  XML_DefaultCurrent(parser);
}

static void defaultEndElement(XML_Parser parser, const XML_Char *name)
{
  XML_DefaultCurrent(parser);
}

static void defaultProcessingInstruction(XML_Parser parser, const XML_Char *target, const XML_Char *data)
{
  XML_DefaultCurrent(parser);
}

static void nopCharacterData(XML_Parser parser, const XML_Char *s, int len)
{
}

static void nopStartElement(XML_Parser parser, const XML_Char *name, const XML_Char **atts)
{
}

static void nopEndElement(XML_Parser parser, const XML_Char *name)
{
}

static void nopProcessingInstruction(XML_Parser parser, const XML_Char *target, const XML_Char *data)
{
}

static void markup(XML_Parser parser, const XML_Char *s, int len)
{
  FILE *fp = XML_GetUserData(parser);
  for (; len > 0; --len, ++s)
    puttc(*s, fp);
}

static
void metaLocation(XML_Parser parser)
{
  const XML_Char *uri = XML_GetBase(parser);
  if (uri)
    ftprintf(XML_GetUserData(parser), T(" uri=\"%s\""), uri);
  ftprintf(XML_GetUserData(parser),
           T(" byte=\"%ld\" nbytes=\"%d\" line=\"%d\" col=\"%d\""),
	   XML_GetCurrentByteIndex(parser),
	   XML_GetCurrentByteCount(parser),
	   XML_GetCurrentLineNumber(parser),
	   XML_GetCurrentColumnNumber(parser));
}

static
void metaStartDocument(XML_Parser parser)
{
  fputts(T("<document>\n"), XML_GetUserData(parser));
}

static
void metaEndDocument(XML_Parser parser)
{
  fputts(T("</document>\n"), XML_GetUserData(parser));
}

static
void metaStartElement(XML_Parser parser, const XML_Char *name, const XML_Char **atts)
{
  FILE *fp = XML_GetUserData(parser);
  const XML_Char **specifiedAttsEnd
    = atts + XML_GetSpecifiedAttributeCount(parser);
  const XML_Char **idAttPtr;
  int idAttIndex = XML_GetIdAttributeIndex(parser);
  if (idAttIndex < 0)
    idAttPtr = 0;
  else
    idAttPtr = atts + idAttIndex;
    
  ftprintf(fp, T("<starttag name=\"%s\""), name);
  metaLocation(parser);
  if (*atts) {
    fputts(T(">\n"), fp);
    do {
      ftprintf(fp, T("<attribute name=\"%s\" value=\""), atts[0]);
      characterData(fp, atts[1], tcslen(atts[1]));
      if (atts >= specifiedAttsEnd)
	fputts(T("\" defaulted=\"yes\"/>\n"), fp);
      else if (atts == idAttPtr)
	fputts(T("\" id=\"yes\"/>\n"), fp);
      else
	fputts(T("\"/>\n"), fp);
    } while (*(atts += 2));
    fputts(T("</starttag>\n"), fp);
  }
  else
    fputts(T("/>\n"), fp);
}

static
void metaEndElement(XML_Parser parser, const XML_Char *name)
{
  FILE *fp = XML_GetUserData(parser);
  ftprintf(fp, T("<endtag name=\"%s\""), name);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaProcessingInstruction(XML_Parser parser, const XML_Char *target, const XML_Char *data)
{
  FILE *fp = XML_GetUserData(parser);
  ftprintf(fp, T("<pi target=\"%s\" data=\""), target);
  characterData(fp, data, tcslen(data));
  puttc(T('"'), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaComment(XML_Parser parser, const XML_Char *data)
{
  FILE *fp = XML_GetUserData(parser);
  fputts(T("<comment data=\""), fp);
  characterData(fp, data, tcslen(data));
  puttc(T('"'), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaStartCdataSection(XML_Parser parser)
{
  FILE *fp = XML_GetUserData(parser);
  fputts(T("<startcdata"), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaEndCdataSection(XML_Parser parser)
{
  FILE *fp = XML_GetUserData(parser);
  fputts(T("<endcdata"), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaCharacterData(XML_Parser parser, const XML_Char *s, int len)
{
  FILE *fp = XML_GetUserData(parser);
  fputts(T("<chars str=\""), fp);
  characterData(fp, s, len);
  puttc(T('"'), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaStartDoctypeDecl(XML_Parser parser,
			  const XML_Char *doctypeName,
			  const XML_Char *sysid,
			  const XML_Char *pubid,
			  int has_internal_subset)
{
  FILE *fp = XML_GetUserData(parser);
  ftprintf(fp, T("<startdoctype name=\"%s\""), doctypeName);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaEndDoctypeDecl(XML_Parser parser)
{
  FILE *fp = XML_GetUserData(parser);
  fputts(T("<enddoctype"), fp);
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}

static
void metaNotationDecl(XML_Parser parser,
		      const XML_Char *notationName,
		      const XML_Char *base,
		      const XML_Char *systemId,
		      const XML_Char *publicId)
{
  FILE *fp = XML_GetUserData(parser);
  ftprintf(fp, T("<notation name=\"%s\""), notationName);
  if (publicId)
    ftprintf(fp, T(" public=\"%s\""), publicId);
  if (systemId) {
    fputts(T(" system=\""), fp);
    characterData(fp, systemId, tcslen(systemId));
    puttc(T('"'), fp);
  }
  metaLocation(parser);
  fputts(T("/>\n"), fp);
}


static
void metaEntityDecl(XML_Parser parser,
		    const XML_Char *entityName,
		    int  is_param,
		    const XML_Char *value,
		    int  value_length,
		    const XML_Char *base,
		    const XML_Char *systemId,
		    const XML_Char *publicId,
		    const XML_Char *notationName)
{
  FILE *fp = XML_GetUserData(parser);

  if (value) {
    ftprintf(fp, T("<entity name=\"%s\""), entityName);
    metaLocation(parser);
    puttc(T('>'), fp);
    characterData(fp, value, value_length);
    fputts(T("</entity/>\n"), fp);
  }
  else if (notationName) {
    ftprintf(fp, T("<entity name=\"%s\""), entityName);
    if (publicId)
      ftprintf(fp, T(" public=\"%s\""), publicId);
    fputts(T(" system=\""), fp);
    characterData(fp, systemId, tcslen(systemId));
    puttc(T('"'), fp);
    ftprintf(fp, T(" notation=\"%s\""), notationName);
    metaLocation(parser);
    fputts(T("/>\n"), fp);
  }
  else {
    ftprintf(fp, T("<entity name=\"%s\""), entityName);
    if (publicId)
      ftprintf(fp, T(" public=\"%s\""), publicId);
    fputts(T(" system=\""), fp);
    characterData(fp, systemId, tcslen(systemId));
    puttc(T('"'), fp);
    metaLocation(parser);
    fputts(T("/>\n"), fp);
  }
}

static
void metaStartNamespaceDecl(XML_Parser parser,
			    const XML_Char *prefix,
			    const XML_Char *uri)
{
  FILE *fp = XML_GetUserData(parser);
  fputts(T("<startns"), fp);
  if (prefix)
    ftprintf(fp, T(" prefix=\"%s\""), prefix);
  if (uri) {
    fputts(T(" ns=\""), fp);
    characterData(fp, uri, tcslen(uri));
    fputts(T("\"/>\n"), fp);
  }
  else
    fputts(T("/>\n"), fp);
}

static
void metaEndNamespaceDecl(XML_Parser parser, const XML_Char *prefix)
{
  FILE *fp = XML_GetUserData(parser);
  if (!prefix)
    fputts(T("<endns/>\n"), fp);
  else
    ftprintf(fp, T("<endns prefix=\"%s\"/>\n"), prefix);
}

static
int unknownEncodingConvert(void *data, const char *p)
{
  return codepageConvert(*(int *)data, p);
}

static
int unknownEncoding(void *userData,
		    const XML_Char *name,
		    XML_Encoding *info)
{
  int cp;
  static const XML_Char prefixL[] = T("windows-");
  static const XML_Char prefixU[] = T("WINDOWS-");
  int i;

  for (i = 0; prefixU[i]; i++)
    if (name[i] != prefixU[i] && name[i] != prefixL[i])
      return 0;
  
  cp = 0;
  for (; name[i]; i++) {
    static const XML_Char digits[] = T("0123456789");
    const XML_Char *s = tcschr(digits, name[i]);
    if (!s)
      return 0;
    cp *= 10;
    cp += s - digits;
    if (cp >= 0x10000)
      return 0;
  }
  if (!codepageMap(cp, info->map))
    return 0;
  info->convert = unknownEncodingConvert;
  /* We could just cast the code page integer to a void *,
  and avoid the use of release. */
  info->release = free;
  info->data = malloc(sizeof(int));
  if (!info->data)
    return 0;
  *(int *)info->data = cp;
  return 1;
}

static
int notStandalone(void *userData)
{
  return 0;
}

static
void usage(const XML_Char *prog)
{
  ftprintf(stderr, T("usage: %s [-n] [-p] [-r] [-s] [-w] [-x] [-d output-dir] [-e encoding] file ...\n"), prog);
  exit(1);
}

int tmain(int argc, XML_Char **argv)
{
  int i, j;
  const XML_Char *outputDir = 0;
  const XML_Char *encoding = 0;
  unsigned processFlags = XML_MAP_FILE;
  int windowsCodePages = 0;
  int outputType = 0;
  int useNamespaces = 0;
  int requireStandalone = 0;
  int paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;

#ifdef _MSC_VER
  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
#endif

  i = 1;
  j = 0;
  while (i < argc) {
    if (j == 0) {
      if (argv[i][0] != T('-'))
	break;
      if (argv[i][1] == T('-') && argv[i][2] == T('\0')) {
	i++;
	break;
      }
      j++;
    }
    switch (argv[i][j]) {
    case T('r'):
      processFlags &= ~XML_MAP_FILE;
      j++;
      break;
    case T('s'):
      requireStandalone = 1;
      j++;
      break;
    case T('n'):
      useNamespaces = 1;
      j++;
      break;
    case T('p'):
      paramEntityParsing = XML_PARAM_ENTITY_PARSING_ALWAYS;
      /* fall through */
    case T('x'):
      processFlags |= XML_EXTERNAL_ENTITIES;
      j++;
      break;
    case T('w'):
      windowsCodePages = 1;
      j++;
      break;
    case T('m'):
      outputType = 'm';
      j++;
      break;
    case T('c'):
      outputType = 'c';
      useNamespaces = 0;
      j++;
      break;
    case T('t'):
      outputType = 't';
      j++;
      break;
    case T('d'):
      if (argv[i][j + 1] == T('\0')) {
	if (++i == argc)
	  usage(argv[0]);
	outputDir = argv[i];
      }
      else
	outputDir = argv[i] + j + 1;
      i++;
      j = 0;
      break;
    case T('e'):
      if (argv[i][j + 1] == T('\0')) {
	if (++i == argc)
	  usage(argv[0]);
	encoding = argv[i];
      }
      else
	encoding = argv[i] + j + 1;
      i++;
      j = 0;
      break;
    case T('\0'):
      if (j > 1) {
	i++;
	j = 0;
	break;
      }
      /* fall through */
    default:
      usage(argv[0]);
    }
  }
  if (i == argc)
    usage(argv[0]);
  for (; i < argc; i++) {
    FILE *fp = 0;
    XML_Char *outName = 0;
    int result;
    XML_Parser parser;
    if (useNamespaces)
      parser = XML_ParserCreateNS(encoding, NSSEP);
    else
      parser = XML_ParserCreate(encoding);
    if (requireStandalone)
      XML_SetNotStandaloneHandler(parser, notStandalone);
    XML_SetParamEntityParsing(parser, paramEntityParsing);
    if (outputType == 't') {
      /* This is for doing timings; this gives a more realistic estimate of
	 the parsing time. */
      outputDir = 0;
      XML_SetElementHandler(parser, nopStartElement, nopEndElement);
      XML_SetCharacterDataHandler(parser, nopCharacterData);
      XML_SetProcessingInstructionHandler(parser, nopProcessingInstruction);
    }
    else if (outputDir) {
      const XML_Char *file = argv[i];
      if (tcsrchr(file, T('/')))
	file = tcsrchr(file, T('/')) + 1;
#ifdef WIN32
      if (tcsrchr(file, T('\\')))
	file = tcsrchr(file, T('\\')) + 1;
#endif
      outName = malloc((tcslen(outputDir) + tcslen(file) + 2) * sizeof(XML_Char));
      tcscpy(outName, outputDir);
      tcscat(outName, T("/"));
      tcscat(outName, file);
      fp = tfopen(outName, T("wb"));
      if (!fp) {
	tperror(outName);
	exit(1);
      }
      setvbuf(fp, NULL, _IOFBF, 16384);
#ifdef XML_UNICODE
      puttc(0xFEFF, fp);
#endif
      XML_SetUserData(parser, fp);
      switch (outputType) {
      case 'm':
	XML_UseParserAsHandlerArg(parser);
	XML_SetElementHandler(parser, metaStartElement, metaEndElement);
	XML_SetProcessingInstructionHandler(parser, metaProcessingInstruction);
	XML_SetCommentHandler(parser, metaComment);
	XML_SetCdataSectionHandler(parser, metaStartCdataSection, metaEndCdataSection);
	XML_SetCharacterDataHandler(parser, metaCharacterData);
	XML_SetDoctypeDeclHandler(parser, metaStartDoctypeDecl, metaEndDoctypeDecl);
	XML_SetEntityDeclHandler(parser, metaEntityDecl);
	XML_SetNotationDeclHandler(parser, metaNotationDecl);
	XML_SetNamespaceDeclHandler(parser, metaStartNamespaceDecl, metaEndNamespaceDecl);
	metaStartDocument(parser);
	break;
      case 'c':
	XML_UseParserAsHandlerArg(parser);
	XML_SetDefaultHandler(parser, markup);
	XML_SetElementHandler(parser, defaultStartElement, defaultEndElement);
	XML_SetCharacterDataHandler(parser, defaultCharacterData);
	XML_SetProcessingInstructionHandler(parser, defaultProcessingInstruction);
	break;
      default:
	if (useNamespaces)
	  XML_SetElementHandler(parser, startElementNS, endElementNS);
	else
	  XML_SetElementHandler(parser, startElement, endElement);
	XML_SetCharacterDataHandler(parser, characterData);
#ifndef W3C14N
	XML_SetProcessingInstructionHandler(parser, processingInstruction);
#endif /* not W3C14N */
	break;
      }
    }
    if (windowsCodePages)
      XML_SetUnknownEncodingHandler(parser, unknownEncoding, 0);
    result = XML_ProcessFile(parser, argv[i], processFlags);
    if (outputDir) {
      if (outputType == 'm')
	metaEndDocument(parser);
      fclose(fp);
      if (!result)
	tremove(outName);
      free(outName);
    }
    XML_ParserFree(parser);
  }
  return 0;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 3
a3 2
/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
   See the file COPYING for copying permission.
d24 1
a24 2
static void
characterData(void *userData, const XML_Char *s, int len)
d59 1
a59 2
static void
attributeValue(FILE *fp, const XML_Char *s)
d109 1
a109 2
static int
attcmp(const void *att1, const void *att2)
d114 1
a114 2
static void
startElement(void *userData, const XML_Char *name, const XML_Char **atts)
d137 1
a137 2
static void
endElement(void *userData, const XML_Char *name)
d146 1
a146 2
static int
nsattcmp(const void *p1, const void *p2)
d157 1
a157 2
static void
startElementNS(void *userData, const XML_Char *name, const XML_Char **atts)
d205 1
a205 2
static void
endElementNS(void *userData, const XML_Char *name)
d223 1
a223 3
static void
processingInstruction(void *userData, const XML_Char *target,
                      const XML_Char *data)
d237 1
a237 2
static void
defaultCharacterData(void *userData, const XML_Char *s, int len)
d239 1
a239 1
  XML_DefaultCurrent((XML_Parser) userData);
d242 1
a242 3
static void
defaultStartElement(void *userData, const XML_Char *name,
                    const XML_Char **atts)
d244 1
a244 1
  XML_DefaultCurrent((XML_Parser) userData);
d247 1
a247 2
static void
defaultEndElement(void *userData, const XML_Char *name)
d249 1
a249 1
  XML_DefaultCurrent((XML_Parser) userData);
d252 1
a252 3
static void
defaultProcessingInstruction(void *userData, const XML_Char *target,
                             const XML_Char *data)
d254 1
a254 1
  XML_DefaultCurrent((XML_Parser) userData);
d257 1
a257 2
static void
nopCharacterData(void *userData, const XML_Char *s, int len)
d261 1
a261 2
static void
nopStartElement(void *userData, const XML_Char *name, const XML_Char **atts)
d265 1
a265 2
static void
nopEndElement(void *userData, const XML_Char *name)
d269 1
a269 3
static void
nopProcessingInstruction(void *userData, const XML_Char *target,
                         const XML_Char *data)
d273 1
a273 2
static void
markup(void *userData, const XML_Char *s, int len)
d275 1
a275 1
  FILE *fp = XML_GetUserData((XML_Parser) userData);
d280 2
a281 2
static void
metaLocation(XML_Parser parser)
d288 4
a291 4
           XML_GetCurrentByteIndex(parser),
           XML_GetCurrentByteCount(parser),
           XML_GetCurrentLineNumber(parser),
           XML_GetCurrentColumnNumber(parser));
d294 2
a295 2
static void
metaStartDocument(void *userData)
d297 1
a297 1
  fputts(T("<document>\n"), XML_GetUserData((XML_Parser) userData));
d300 2
a301 2
static void
metaEndDocument(void *userData)
d303 1
a303 1
  fputts(T("</document>\n"), XML_GetUserData((XML_Parser) userData));
d306 2
a307 3
static void
metaStartElement(void *userData, const XML_Char *name,
                 const XML_Char **atts)
a308 1
  XML_Parser parser = (XML_Parser) userData;
d327 1
a327 1
        fputts(T("\" defaulted=\"yes\"/>\n"), fp);
d329 1
a329 1
        fputts(T("\" id=\"yes\"/>\n"), fp);
d331 1
a331 1
        fputts(T("\"/>\n"), fp);
d339 2
a340 2
static void
metaEndElement(void *userData, const XML_Char *name)
a341 1
  XML_Parser parser = (XML_Parser) userData;
d348 2
a349 3
static void
metaProcessingInstruction(void *userData, const XML_Char *target,
                          const XML_Char *data)
a350 1
  XML_Parser parser = (XML_Parser) userData;
d359 2
a360 2
static void
metaComment(void *userData, const XML_Char *data)
a361 1
  XML_Parser parser = (XML_Parser) userData;
d370 2
a371 2
static void
metaStartCdataSection(void *userData)
a372 1
  XML_Parser parser = (XML_Parser) userData;
d379 2
a380 2
static void
metaEndCdataSection(void *userData)
a381 1
  XML_Parser parser = (XML_Parser) userData;
d388 2
a389 2
static void
metaCharacterData(void *userData, const XML_Char *s, int len)
a390 1
  XML_Parser parser = (XML_Parser) userData;
d399 6
a404 6
static void
metaStartDoctypeDecl(void *userData,
                     const XML_Char *doctypeName,
                     const XML_Char *sysid,
                     const XML_Char *pubid,
                     int has_internal_subset)
a405 1
  XML_Parser parser = (XML_Parser) userData;
d412 2
a413 2
static void
metaEndDoctypeDecl(void *userData)
a414 1
  XML_Parser parser = (XML_Parser) userData;
d421 6
a426 6
static void
metaNotationDecl(void *userData,
                 const XML_Char *notationName,
                 const XML_Char *base,
                 const XML_Char *systemId,
                 const XML_Char *publicId)
a427 1
  XML_Parser parser = (XML_Parser) userData;
d442 10
a451 10
static void
metaEntityDecl(void *userData,
               const XML_Char *entityName,
               int  is_param,
               const XML_Char *value,
               int  value_length,
               const XML_Char *base,
               const XML_Char *systemId,
               const XML_Char *publicId,
               const XML_Char *notationName)
a452 1
  XML_Parser parser = (XML_Parser) userData;
d485 4
a488 4
static void
metaStartNamespaceDecl(void *userData,
                       const XML_Char *prefix,
                       const XML_Char *uri)
a489 1
  XML_Parser parser = (XML_Parser) userData;
d503 2
a504 2
static void
metaEndNamespaceDecl(void *userData, const XML_Char *prefix)
a505 1
  XML_Parser parser = (XML_Parser) userData;
d513 2
a514 2
static int
unknownEncodingConvert(void *data, const char *p)
d519 4
a522 2
static int
unknownEncoding(void *userData, const XML_Char *name, XML_Encoding *info)
d557 2
a558 2
static int
notStandalone(void *userData)
d563 2
a564 2
static void
showVersion(XML_Char *prog)
d566 2
a567 26
  XML_Char *s = prog;
  XML_Char ch;
  const XML_Feature *features = XML_GetFeatureList();
  while ((ch = *s) != 0) {
    if (ch == '/'
#ifdef WIN32
        || ch == '\\'
#endif
        )
      prog = s + 1;
    ++s;
  }
  ftprintf(stdout, T("%s using %s\n"), prog, XML_ExpatVersion());
  if (features != NULL && features[0].feature != XML_FEATURE_END) {
    int i = 1;
    ftprintf(stdout, T("%s"), features[0].name);
    if (features[0].value)
      ftprintf(stdout, T("=%ld"), features[0].value);
    while (features[i].feature != XML_FEATURE_END) {
      ftprintf(stdout, T(", %s"), features[i].name);
      if (features[i].value)
        ftprintf(stdout, T("=%ld"), features[i].value);
      ++i;
    }
    ftprintf(stdout, T("\n"));
  }
d570 1
a570 11
static void
usage(const XML_Char *prog, int rc)
{
  ftprintf(stderr,
           T("usage: %s [-n] [-p] [-r] [-s] [-w] [-x] [-d output-dir] "
             "[-e encoding] file ...\n"), prog);
  exit(rc);
}

int
tmain(int argc, XML_Char **argv)
d573 2
a574 2
  const XML_Char *outputDir = NULL;
  const XML_Char *encoding = NULL;
a580 1
  int useStdin = 0;
d591 1
a591 1
        break;
d593 2
a594 2
        i++;
        break;
d637 3
a639 3
        if (++i == argc)
          usage(argv[0], 2);
        outputDir = argv[i];
d642 1
a642 1
        outputDir = argv[i] + j + 1;
d648 3
a650 3
        if (++i == argc)
          usage(argv[0], 2);
        encoding = argv[i];
d653 1
a653 1
        encoding = argv[i] + j + 1;
a656 6
    case T('h'):
      usage(argv[0], 0);
      return 0;
    case T('v'):
      showVersion(argv[0]);
      return 0;
d659 3
a661 3
        i++;
        j = 0;
        break;
d665 1
a665 1
      usage(argv[0], 2);
d668 2
a669 5
  if (i == argc) {
    useStdin = 1;
    processFlags &= ~XML_MAP_FILE;
    i--;
  }
d684 1
a684 1
         the parsing time. */
d691 1
a691 1
      const XML_Char *file = useStdin ? T("STDIN") : argv[i];
d693 1
a693 1
        file = tcsrchr(file, T('/')) + 1;
d696 1
a696 1
        file = tcsrchr(file, T('\\')) + 1;
d698 1
a698 2
      outName = malloc((tcslen(outputDir) + tcslen(file) + 2)
                       * sizeof(XML_Char));
d704 2
a705 2
        tperror(outName);
        exit(1);
d714 12
a725 15
        XML_UseParserAsHandlerArg(parser);
        XML_SetElementHandler(parser, metaStartElement, metaEndElement);
        XML_SetProcessingInstructionHandler(parser, metaProcessingInstruction);
        XML_SetCommentHandler(parser, metaComment);
        XML_SetCdataSectionHandler(parser, metaStartCdataSection,
                                   metaEndCdataSection);
        XML_SetCharacterDataHandler(parser, metaCharacterData);
        XML_SetDoctypeDeclHandler(parser, metaStartDoctypeDecl,
                                  metaEndDoctypeDecl);
        XML_SetEntityDeclHandler(parser, metaEntityDecl);
        XML_SetNotationDeclHandler(parser, metaNotationDecl);
        XML_SetNamespaceDeclHandler(parser, metaStartNamespaceDecl,
                                    metaEndNamespaceDecl);
        metaStartDocument(parser);
        break;
d727 6
a732 7
        XML_UseParserAsHandlerArg(parser);
        XML_SetDefaultHandler(parser, markup);
        XML_SetElementHandler(parser, defaultStartElement, defaultEndElement);
        XML_SetCharacterDataHandler(parser, defaultCharacterData);
        XML_SetProcessingInstructionHandler(parser,
                                            defaultProcessingInstruction);
        break;
d734 5
a738 5
        if (useNamespaces)
          XML_SetElementHandler(parser, startElementNS, endElementNS);
        else
          XML_SetElementHandler(parser, startElement, endElement);
        XML_SetCharacterDataHandler(parser, characterData);
d740 1
a740 1
        XML_SetProcessingInstructionHandler(parser, processingInstruction);
d742 1
a742 1
        break;
d747 1
a747 1
    result = XML_ProcessFile(parser, useStdin ? NULL : argv[i], processFlags);
d750 1
a750 1
        metaEndDocument(parser);
d753 1
a753 1
        tremove(outName);
@


1.1.1.1
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@@


1.1.1.2
log
@Import OpenBSD tree again due to CVS bugs
@
text
@d1 3
a3 2
/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
   See the file COPYING for copying permission.
d24 1
a24 2
static void
characterData(void *userData, const XML_Char *s, int len)
d59 1
a59 2
static void
attributeValue(FILE *fp, const XML_Char *s)
d109 1
a109 2
static int
attcmp(const void *att1, const void *att2)
d114 1
a114 2
static void
startElement(void *userData, const XML_Char *name, const XML_Char **atts)
d137 1
a137 2
static void
endElement(void *userData, const XML_Char *name)
d146 1
a146 2
static int
nsattcmp(const void *p1, const void *p2)
d157 1
a157 2
static void
startElementNS(void *userData, const XML_Char *name, const XML_Char **atts)
d205 1
a205 2
static void
endElementNS(void *userData, const XML_Char *name)
d223 1
a223 3
static void
processingInstruction(void *userData, const XML_Char *target,
                      const XML_Char *data)
d237 1
a237 2
static void
defaultCharacterData(XML_Parser parser, const XML_Char *s, int len)
d242 1
a242 3
static void
defaultStartElement(XML_Parser parser, const XML_Char *name,
                    const XML_Char **atts)
d247 1
a247 2
static void
defaultEndElement(XML_Parser parser, const XML_Char *name)
d252 1
a252 3
static void
defaultProcessingInstruction(XML_Parser parser, const XML_Char *target,
                             const XML_Char *data)
d257 1
a257 2
static void
nopCharacterData(XML_Parser parser, const XML_Char *s, int len)
d261 1
a261 2
static void
nopStartElement(XML_Parser parser, const XML_Char *name, const XML_Char **atts)
d265 1
a265 2
static void
nopEndElement(XML_Parser parser, const XML_Char *name)
d269 1
a269 3
static void
nopProcessingInstruction(XML_Parser parser, const XML_Char *target,
                         const XML_Char *data)
d273 1
a273 2
static void
markup(XML_Parser parser, const XML_Char *s, int len)
d280 2
a281 2
static void
metaLocation(XML_Parser parser)
d288 4
a291 4
           XML_GetCurrentByteIndex(parser),
           XML_GetCurrentByteCount(parser),
           XML_GetCurrentLineNumber(parser),
           XML_GetCurrentColumnNumber(parser));
d294 2
a295 2
static void
metaStartDocument(XML_Parser parser)
d300 2
a301 2
static void
metaEndDocument(XML_Parser parser)
d306 2
a307 3
static void
metaStartElement(XML_Parser parser, const XML_Char *name,
                 const XML_Char **atts)
d327 1
a327 1
        fputts(T("\" defaulted=\"yes\"/>\n"), fp);
d329 1
a329 1
        fputts(T("\" id=\"yes\"/>\n"), fp);
d331 1
a331 1
        fputts(T("\"/>\n"), fp);
d339 2
a340 2
static void
metaEndElement(XML_Parser parser, const XML_Char *name)
d348 2
a349 3
static void
metaProcessingInstruction(XML_Parser parser, const XML_Char *target,
                          const XML_Char *data)
d359 2
a360 2
static void
metaComment(XML_Parser parser, const XML_Char *data)
d370 2
a371 2
static void
metaStartCdataSection(XML_Parser parser)
d379 2
a380 2
static void
metaEndCdataSection(XML_Parser parser)
d388 2
a389 2
static void
metaCharacterData(XML_Parser parser, const XML_Char *s, int len)
d399 6
a404 6
static void
metaStartDoctypeDecl(XML_Parser parser,
                     const XML_Char *doctypeName,
                     const XML_Char *sysid,
                     const XML_Char *pubid,
                     int has_internal_subset)
d412 2
a413 2
static void
metaEndDoctypeDecl(XML_Parser parser)
d421 6
a426 6
static void
metaNotationDecl(XML_Parser parser,
                 const XML_Char *notationName,
                 const XML_Char *base,
                 const XML_Char *systemId,
                 const XML_Char *publicId)
d442 10
a451 10
static void
metaEntityDecl(XML_Parser parser,
               const XML_Char *entityName,
               int  is_param,
               const XML_Char *value,
               int  value_length,
               const XML_Char *base,
               const XML_Char *systemId,
               const XML_Char *publicId,
               const XML_Char *notationName)
d485 4
a488 4
static void
metaStartNamespaceDecl(XML_Parser parser,
                       const XML_Char *prefix,
                       const XML_Char *uri)
d503 2
a504 2
static void
metaEndNamespaceDecl(XML_Parser parser, const XML_Char *prefix)
d513 2
a514 2
static int
unknownEncodingConvert(void *data, const char *p)
d519 4
a522 2
static int
unknownEncoding(void *userData, const XML_Char *name, XML_Encoding *info)
d557 2
a558 2
static int
notStandalone(void *userData)
d563 2
a564 2
static void
showVersion(XML_Char *prog)
d566 2
a567 17
  XML_Char *s = prog;
  XML_Char ch;
  while ((ch = *s) != 0) {
    if (ch == '/' || ch == '\\')
      prog = s + 1;
    ++s;
  }
  ftprintf(stdout, T("%s using %s\n"), prog, XML_ExpatVersion());
}

static void
usage(const XML_Char *prog, int rc)
{
  ftprintf(stderr,
           T("usage: %s [-n] [-p] [-r] [-s] [-w] [-x] [-d output-dir] "
             "[-e encoding] file ...\n"), prog);
  exit(rc);
d570 1
a570 2
int
tmain(int argc, XML_Char **argv)
d573 2
a574 2
  const XML_Char *outputDir = NULL;
  const XML_Char *encoding = NULL;
a580 1
  int useStdin = 0;
d591 1
a591 1
        break;
d593 2
a594 2
        i++;
        break;
d637 3
a639 3
        if (++i == argc)
          usage(argv[0], 2);
        outputDir = argv[i];
d642 1
a642 1
        outputDir = argv[i] + j + 1;
d648 3
a650 3
        if (++i == argc)
          usage(argv[0], 2);
        encoding = argv[i];
d653 1
a653 1
        encoding = argv[i] + j + 1;
a656 6
    case T('h'):
      usage(argv[0], 0);
      return 0;
    case T('v'):
      showVersion(argv[0]);
      return 0;
d659 3
a661 3
        i++;
        j = 0;
        break;
d665 1
a665 1
      usage(argv[0], 2);
d668 2
a669 5
  if (i == argc) {
    useStdin = 1;
    processFlags &= ~XML_MAP_FILE;
    i--;
  }
d684 1
a684 1
         the parsing time. */
d691 1
a691 1
      const XML_Char *file = useStdin ? T("STDIN") : argv[i];
d693 1
a693 1
        file = tcsrchr(file, T('/')) + 1;
d696 1
a696 1
        file = tcsrchr(file, T('\\')) + 1;
d698 1
a698 2
      outName = malloc((tcslen(outputDir) + tcslen(file) + 2)
                       * sizeof(XML_Char));
d704 2
a705 2
        tperror(outName);
        exit(1);
d714 12
a725 15
        XML_UseParserAsHandlerArg(parser);
        XML_SetElementHandler(parser, metaStartElement, metaEndElement);
        XML_SetProcessingInstructionHandler(parser, metaProcessingInstruction);
        XML_SetCommentHandler(parser, metaComment);
        XML_SetCdataSectionHandler(parser, metaStartCdataSection,
                                   metaEndCdataSection);
        XML_SetCharacterDataHandler(parser, metaCharacterData);
        XML_SetDoctypeDeclHandler(parser, metaStartDoctypeDecl,
                                  metaEndDoctypeDecl);
        XML_SetEntityDeclHandler(parser, metaEntityDecl);
        XML_SetNotationDeclHandler(parser, metaNotationDecl);
        XML_SetNamespaceDeclHandler(parser, metaStartNamespaceDecl,
                                    metaEndNamespaceDecl);
        metaStartDocument(parser);
        break;
d727 6
a732 7
        XML_UseParserAsHandlerArg(parser);
        XML_SetDefaultHandler(parser, markup);
        XML_SetElementHandler(parser, defaultStartElement, defaultEndElement);
        XML_SetCharacterDataHandler(parser, defaultCharacterData);
        XML_SetProcessingInstructionHandler(parser,
                                            defaultProcessingInstruction);
        break;
d734 5
a738 5
        if (useNamespaces)
          XML_SetElementHandler(parser, startElementNS, endElementNS);
        else
          XML_SetElementHandler(parser, startElement, endElement);
        XML_SetCharacterDataHandler(parser, characterData);
d740 1
a740 1
        XML_SetProcessingInstructionHandler(parser, processingInstruction);
d742 1
a742 1
        break;
d747 1
a747 1
    result = XML_ProcessFile(parser, useStdin ? NULL : argv[i], processFlags);
d750 1
a750 1
        metaEndDocument(parser);
d753 1
a753 1
        tremove(outName);
@


1.1.1.3
log
@sync with OpenBSD's idea of X-Window as of now();
@
text
@d247 1
a247 1
defaultCharacterData(void *userData, const XML_Char *s, int len)
d249 1
a249 1
  XML_DefaultCurrent((XML_Parser) userData);
d253 1
a253 1
defaultStartElement(void *userData, const XML_Char *name,
d256 1
a256 1
  XML_DefaultCurrent((XML_Parser) userData);
d260 1
a260 1
defaultEndElement(void *userData, const XML_Char *name)
d262 1
a262 1
  XML_DefaultCurrent((XML_Parser) userData);
d266 1
a266 1
defaultProcessingInstruction(void *userData, const XML_Char *target,
d269 1
a269 1
  XML_DefaultCurrent((XML_Parser) userData);
d273 1
a273 1
nopCharacterData(void *userData, const XML_Char *s, int len)
d278 1
a278 1
nopStartElement(void *userData, const XML_Char *name, const XML_Char **atts)
d283 1
a283 1
nopEndElement(void *userData, const XML_Char *name)
d288 1
a288 1
nopProcessingInstruction(void *userData, const XML_Char *target,
d294 1
a294 1
markup(void *userData, const XML_Char *s, int len)
d296 1
a296 1
  FILE *fp = XML_GetUserData((XML_Parser) userData);
d316 1
a316 1
metaStartDocument(void *userData)
d318 1
a318 1
  fputts(T("<document>\n"), XML_GetUserData((XML_Parser) userData));
d322 1
a322 1
metaEndDocument(void *userData)
d324 1
a324 1
  fputts(T("</document>\n"), XML_GetUserData((XML_Parser) userData));
d328 1
a328 1
metaStartElement(void *userData, const XML_Char *name,
a330 1
  XML_Parser parser = (XML_Parser) userData;
d362 1
a362 1
metaEndElement(void *userData, const XML_Char *name)
a363 1
  XML_Parser parser = (XML_Parser) userData;
d371 1
a371 1
metaProcessingInstruction(void *userData, const XML_Char *target,
a373 1
  XML_Parser parser = (XML_Parser) userData;
d383 1
a383 1
metaComment(void *userData, const XML_Char *data)
a384 1
  XML_Parser parser = (XML_Parser) userData;
d394 1
a394 1
metaStartCdataSection(void *userData)
a395 1
  XML_Parser parser = (XML_Parser) userData;
d403 1
a403 1
metaEndCdataSection(void *userData)
a404 1
  XML_Parser parser = (XML_Parser) userData;
d412 1
a412 1
metaCharacterData(void *userData, const XML_Char *s, int len)
a413 1
  XML_Parser parser = (XML_Parser) userData;
d423 1
a423 1
metaStartDoctypeDecl(void *userData,
a428 1
  XML_Parser parser = (XML_Parser) userData;
d436 1
a436 1
metaEndDoctypeDecl(void *userData)
a437 1
  XML_Parser parser = (XML_Parser) userData;
d445 1
a445 1
metaNotationDecl(void *userData,
a450 1
  XML_Parser parser = (XML_Parser) userData;
d466 1
a466 1
metaEntityDecl(void *userData,
a475 1
  XML_Parser parser = (XML_Parser) userData;
d509 1
a509 1
metaStartNamespaceDecl(void *userData,
a512 1
  XML_Parser parser = (XML_Parser) userData;
d527 1
a527 1
metaEndNamespaceDecl(void *userData, const XML_Char *prefix)
a528 1
  XML_Parser parser = (XML_Parser) userData;
a588 1
  const XML_Feature *features = XML_GetFeatureList();
d590 1
a590 5
    if (ch == '/'
#ifdef WIN32
        || ch == '\\'
#endif
        )
a594 13
  if (features != NULL && features[0].feature != XML_FEATURE_END) {
    int i = 1;
    ftprintf(stdout, T("%s"), features[0].name);
    if (features[0].value)
      ftprintf(stdout, T("=%ld"), features[0].value);
    while (features[i].feature != XML_FEATURE_END) {
      ftprintf(stdout, T(", %s"), features[i].name);
      if (features[i].value)
        ftprintf(stdout, T("=%ld"), features[i].value);
      ++i;
    }
    ftprintf(stdout, T("\n"));
  }
@


