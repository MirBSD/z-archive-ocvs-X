head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.3
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.3
	MIRBSD_7_ALPHA:1.1.1.3.0.4
	MIRBSD_7:1.1.1.3.0.2
	MIRBSD_7ter:1.1.1.3
	cvs-20011091815:1.1.1.3
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.29.24;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.04.08.18.20.29;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.04.08.18.20.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.15.15.15;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.09.18.33.37;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.05.50;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@/*
Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd
See the file COPYING for copying permission.
*/

#ifdef COMPILED_FROM_DSP
#  include "winconfig.h"
#  define XMLPARSEAPI(type) __declspec(dllexport) type __cdecl
#  include "expat.h"
#  undef XMLPARSEAPI
#else
#include <config.h>

#ifdef __declspec
#  define XMLPARSEAPI(type) __declspec(dllexport) type __cdecl
#endif

#include "expat.h"

#ifdef __declspec
#  undef XMLPARSEAPI
#endif
#endif /* ndef COMPILED_FROM_DSP */

#include <stddef.h>
#include <string.h>

#ifdef XML_UNICODE
#define XML_ENCODE_MAX XML_UTF16_ENCODE_MAX
#define XmlConvert XmlUtf16Convert
#define XmlGetInternalEncoding XmlGetUtf16InternalEncoding
#define XmlGetInternalEncodingNS XmlGetUtf16InternalEncodingNS
#define XmlEncode XmlUtf16Encode
#define MUST_CONVERT(enc, s) (!(enc)->isUtf16 || (((unsigned long)s) & 1))
typedef unsigned short ICHAR;
#else
#define XML_ENCODE_MAX XML_UTF8_ENCODE_MAX
#define XmlConvert XmlUtf8Convert
#define XmlGetInternalEncoding XmlGetUtf8InternalEncoding
#define XmlGetInternalEncodingNS XmlGetUtf8InternalEncodingNS
#define XmlEncode XmlUtf8Encode
#define MUST_CONVERT(enc, s) (!(enc)->isUtf8)
typedef char ICHAR;
#endif


#ifndef XML_NS

#define XmlInitEncodingNS XmlInitEncoding
#define XmlInitUnknownEncodingNS XmlInitUnknownEncoding
#undef XmlGetInternalEncodingNS
#define XmlGetInternalEncodingNS XmlGetInternalEncoding
#define XmlParseXmlDeclNS XmlParseXmlDecl

#endif

#ifdef XML_UNICODE_WCHAR_T
#define XML_T(x) L ## x
#else
#define XML_T(x) x
#endif

/* Round up n to be a multiple of sz, where sz is a power of 2. */
#define ROUND_UP(n, sz) (((n) + ((sz) - 1)) & ~((sz) - 1))

#include "xmltok.h"
#include "xmlrole.h"

typedef const XML_Char *KEY;

typedef struct {
  KEY name;
} NAMED;

typedef struct {
  NAMED **v;
  size_t size;
  size_t used;
  size_t usedLim;
  XML_Memory_Handling_Suite *mem;
} HASH_TABLE;

typedef struct {
  NAMED **p;
  NAMED **end;
} HASH_TABLE_ITER;

#define INIT_TAG_BUF_SIZE 32  /* must be a multiple of sizeof(XML_Char) */
#define INIT_DATA_BUF_SIZE 1024
#define INIT_ATTS_SIZE 16
#define INIT_BLOCK_SIZE 1024
#define INIT_BUFFER_SIZE 1024

#define EXPAND_SPARE 24

typedef struct binding {
  struct prefix *prefix;
  struct binding *nextTagBinding;
  struct binding *prevPrefixBinding;
  const struct attribute_id *attId;
  XML_Char *uri;
  int uriLen;
  int uriAlloc;
} BINDING;

typedef struct prefix {
  const XML_Char *name;
  BINDING *binding;
} PREFIX;

typedef struct {
  const XML_Char *str;
  const XML_Char *localPart;
  int uriLen;
} TAG_NAME;

typedef struct tag {
  struct tag *parent;
  const char *rawName;
  int rawNameLength;
  TAG_NAME name;
  char *buf;
  char *bufEnd;
  BINDING *bindings;
} TAG;

typedef struct {
  const XML_Char *name;
  const XML_Char *textPtr;
  int textLen;
  const XML_Char *systemId;
  const XML_Char *base;
  const XML_Char *publicId;
  const XML_Char *notation;
  char open;
  char is_param;
} ENTITY;

typedef struct {
  enum XML_Content_Type		type;
  enum XML_Content_Quant	quant;
  const XML_Char *		name;
  int				firstchild;
  int				lastchild;
  int				childcnt;
  int				nextsib;
} CONTENT_SCAFFOLD;

typedef struct block {
  struct block *next;
  int size;
  XML_Char s[1];
} BLOCK;

typedef struct {
  BLOCK *blocks;
  BLOCK *freeBlocks;
  const XML_Char *end;
  XML_Char *ptr;
  XML_Char *start;
  XML_Memory_Handling_Suite *mem;
} STRING_POOL;

/* The XML_Char before the name is used to determine whether
an attribute has been specified. */
typedef struct attribute_id {
  XML_Char *name;
  PREFIX *prefix;
  char maybeTokenized;
  char xmlns;
} ATTRIBUTE_ID;

typedef struct {
  const ATTRIBUTE_ID *id;
  char isCdata;
  const XML_Char *value;
} DEFAULT_ATTRIBUTE;

typedef struct {
  const XML_Char *name;
  PREFIX *prefix;
  const ATTRIBUTE_ID *idAtt;
  int nDefaultAtts;
  int allocDefaultAtts;
  DEFAULT_ATTRIBUTE *defaultAtts;
} ELEMENT_TYPE;

typedef struct {
  HASH_TABLE generalEntities;
  HASH_TABLE elementTypes;
  HASH_TABLE attributeIds;
  HASH_TABLE prefixes;
  STRING_POOL pool;
  int complete;
  int standalone;
#ifdef XML_DTD
  HASH_TABLE paramEntities;
#endif /* XML_DTD */
  PREFIX defaultPrefix;
  /* === scaffolding for building content model === */
  int in_eldecl;
  CONTENT_SCAFFOLD *scaffold;
  unsigned contentStringLen;
  unsigned scaffSize;
  unsigned scaffCount;
  int scaffLevel;
  int *scaffIndex;
} DTD;

typedef struct open_internal_entity {
  const char *internalEventPtr;
  const char *internalEventEndPtr;
  struct open_internal_entity *next;
  ENTITY *entity;
} OPEN_INTERNAL_ENTITY;

typedef enum XML_Error Processor(XML_Parser parser,
				 const char *start,
				 const char *end,
				 const char **endPtr);

static Processor prologProcessor;
static Processor prologInitProcessor;
static Processor contentProcessor;
static Processor cdataSectionProcessor;
#ifdef XML_DTD
static Processor ignoreSectionProcessor;
#endif /* XML_DTD */
static Processor epilogProcessor;
static Processor errorProcessor;
static Processor externalEntityInitProcessor;
static Processor externalEntityInitProcessor2;
static Processor externalEntityInitProcessor3;
static Processor externalEntityContentProcessor;

static enum XML_Error
handleUnknownEncoding(XML_Parser parser, const XML_Char *encodingName);
static enum XML_Error
processXmlDecl(XML_Parser parser, int isGeneralTextEntity, const char *, const char *);
static enum XML_Error
initializeEncoding(XML_Parser parser);
static enum XML_Error
doProlog(XML_Parser parser, const ENCODING *enc, const char *s,
	 const char *end, int tok, const char *next, const char **nextPtr);
static enum XML_Error
processInternalParamEntity(XML_Parser parser, ENTITY *entity);
static enum XML_Error
doContent(XML_Parser parser, int startTagLevel, const ENCODING *enc,
	  const char *start, const char *end, const char **endPtr);
static enum XML_Error
doCdataSection(XML_Parser parser, const ENCODING *, const char **startPtr, const char *end, const char **nextPtr);
#ifdef XML_DTD
static enum XML_Error
doIgnoreSection(XML_Parser parser, const ENCODING *, const char **startPtr, const char *end, const char **nextPtr);
#endif /* XML_DTD */
static enum XML_Error storeAtts(XML_Parser parser, const ENCODING *, const char *s,
				TAG_NAME *tagNamePtr, BINDING **bindingsPtr);
static
int addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId, const XML_Char *uri, BINDING **bindingsPtr);

static int
defineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *,
		int isCdata, int isId, const XML_Char *dfltValue,
		XML_Parser parser);

static enum XML_Error
storeAttributeValue(XML_Parser parser, const ENCODING *, int isCdata, const char *, const char *,
		    STRING_POOL *);
static enum XML_Error
appendAttributeValue(XML_Parser parser, const ENCODING *, int isCdata, const char *, const char *,
		    STRING_POOL *);
static ATTRIBUTE_ID *
getAttributeId(XML_Parser parser, const ENCODING *enc, const char *start, const char *end);
static int setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *);
static enum XML_Error
storeEntityValue(XML_Parser parser, const ENCODING *enc, const char *start, const char *end);
static int
reportProcessingInstruction(XML_Parser parser, const ENCODING *enc, const char *start, const char *end);
static int
reportComment(XML_Parser parser, const ENCODING *enc, const char *start, const char *end);
static void
reportDefault(XML_Parser parser, const ENCODING *enc, const char *start, const char *end);

static const XML_Char *getContext(XML_Parser parser);
static int setContext(XML_Parser parser, const XML_Char *context);
static void normalizePublicId(XML_Char *s);
static int dtdInit(DTD *, XML_Parser parser);

static void dtdDestroy(DTD *, XML_Parser parser);

static int dtdCopy(DTD *newDtd, const DTD *oldDtd, XML_Parser parser);

static int copyEntityTable(HASH_TABLE *, STRING_POOL *, const HASH_TABLE *,
			   XML_Parser parser);

#ifdef XML_DTD
static void dtdSwap(DTD *, DTD *);
#endif /* XML_DTD */

static NAMED *lookup(HASH_TABLE *table, KEY name, size_t createSize);

static void hashTableInit(HASH_TABLE *, XML_Memory_Handling_Suite *ms);

static void hashTableDestroy(HASH_TABLE *);
static void hashTableIterInit(HASH_TABLE_ITER *, const HASH_TABLE *);
static NAMED *hashTableIterNext(HASH_TABLE_ITER *);
static void poolInit(STRING_POOL *, XML_Memory_Handling_Suite *ms);
static void poolClear(STRING_POOL *);
static void poolDestroy(STRING_POOL *);
static XML_Char *poolAppend(STRING_POOL *pool, const ENCODING *enc,
			    const char *ptr, const char *end);
static XML_Char *poolStoreString(STRING_POOL *pool, const ENCODING *enc,
				  const char *ptr, const char *end);

static int poolGrow(STRING_POOL *pool);

static int nextScaffoldPart(XML_Parser parser);
static XML_Content *build_model(XML_Parser parser);

static const XML_Char *poolCopyString(STRING_POOL *pool, const XML_Char *s);
static const XML_Char *poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n);
static const XML_Char *poolAppendString(STRING_POOL *pool, const XML_Char *s);
static ELEMENT_TYPE * getElementType(XML_Parser Paraser,
				     const ENCODING *enc,
				     const char *ptr,
				     const char *end);

#define poolStart(pool) ((pool)->start)
#define poolEnd(pool) ((pool)->ptr)
#define poolLength(pool) ((pool)->ptr - (pool)->start)
#define poolChop(pool) ((void)--(pool->ptr))
#define poolLastChar(pool) (((pool)->ptr)[-1])
#define poolDiscard(pool) ((pool)->ptr = (pool)->start)
#define poolFinish(pool) ((pool)->start = (pool)->ptr)
#define poolAppendChar(pool, c) \
  (((pool)->ptr == (pool)->end && !poolGrow(pool)) \
   ? 0 \
   : ((*((pool)->ptr)++ = c), 1))

typedef struct {
  /* The first member must be userData so that the XML_GetUserData macro works. */
  void *m_userData;
  void *m_handlerArg;
  char *m_buffer;
  XML_Memory_Handling_Suite m_mem;
  /* first character to be parsed */
  const char *m_bufferPtr;
  /* past last character to be parsed */
  char *m_bufferEnd;
  /* allocated end of buffer */
  const char *m_bufferLim;
  long m_parseEndByteIndex;
  const char *m_parseEndPtr;
  XML_Char *m_dataBuf;
  XML_Char *m_dataBufEnd;
  XML_StartElementHandler m_startElementHandler;
  XML_EndElementHandler m_endElementHandler;
  XML_CharacterDataHandler m_characterDataHandler;
  XML_ProcessingInstructionHandler m_processingInstructionHandler;
  XML_CommentHandler m_commentHandler;
  XML_StartCdataSectionHandler m_startCdataSectionHandler;
  XML_EndCdataSectionHandler m_endCdataSectionHandler;
  XML_DefaultHandler m_defaultHandler;
  XML_StartDoctypeDeclHandler m_startDoctypeDeclHandler;
  XML_EndDoctypeDeclHandler m_endDoctypeDeclHandler;
  XML_UnparsedEntityDeclHandler m_unparsedEntityDeclHandler;
  XML_NotationDeclHandler m_notationDeclHandler;
  XML_StartNamespaceDeclHandler m_startNamespaceDeclHandler;
  XML_EndNamespaceDeclHandler m_endNamespaceDeclHandler;
  XML_NotStandaloneHandler m_notStandaloneHandler;
  XML_ExternalEntityRefHandler m_externalEntityRefHandler;
  void *m_externalEntityRefHandlerArg;
  XML_UnknownEncodingHandler m_unknownEncodingHandler;
  XML_ElementDeclHandler m_elementDeclHandler;
  XML_AttlistDeclHandler m_attlistDeclHandler;
  XML_EntityDeclHandler m_entityDeclHandler;
  XML_XmlDeclHandler m_xmlDeclHandler;
  const ENCODING *m_encoding;
  INIT_ENCODING m_initEncoding;
  const ENCODING *m_internalEncoding;
  const XML_Char *m_protocolEncodingName;
  int m_ns;
  int m_ns_triplets;
  void *m_unknownEncodingMem;
  void *m_unknownEncodingData;
  void *m_unknownEncodingHandlerData;
  void (*m_unknownEncodingRelease)(void *);
  PROLOG_STATE m_prologState;
  Processor *m_processor;
  enum XML_Error m_errorCode;
  const char *m_eventPtr;
  const char *m_eventEndPtr;
  const char *m_positionPtr;
  OPEN_INTERNAL_ENTITY *m_openInternalEntities;
  int m_defaultExpandInternalEntities;
  int m_tagLevel;
  ENTITY *m_declEntity;
  const XML_Char *m_doctypeName;
  const XML_Char *m_doctypeSysid;
  const XML_Char *m_doctypePubid;
  const XML_Char *m_declAttributeType;
  const XML_Char *m_declNotationName;
  const XML_Char *m_declNotationPublicId;
  ELEMENT_TYPE *m_declElementType;
  ATTRIBUTE_ID *m_declAttributeId;
  char m_declAttributeIsCdata;
  char m_declAttributeIsId;
  DTD m_dtd;
  const XML_Char *m_curBase;
  TAG *m_tagStack;
  TAG *m_freeTagList;
  BINDING *m_inheritedBindings;
  BINDING *m_freeBindingList;
  int m_attsSize;
  int m_nSpecifiedAtts;
  int m_idAttIndex;
  ATTRIBUTE *m_atts;
  POSITION m_position;
  STRING_POOL m_tempPool;
  STRING_POOL m_temp2Pool;
  char *m_groupConnector;
  unsigned m_groupSize;
  int m_hadExternalDoctype;
  XML_Char m_namespaceSeparator;
#ifdef XML_DTD
  enum XML_ParamEntityParsing m_paramEntityParsing;
  XML_Parser m_parentParser;
#endif
} Parser;

#define MALLOC(s) (((Parser *)parser)->m_mem.malloc_fcn((s)))
#define REALLOC(p,s) (((Parser *)parser)->m_mem.realloc_fcn((p),(s)))
#define FREE(p) (((Parser *)parser)->m_mem.free_fcn((p)))

#define userData (((Parser *)parser)->m_userData)
#define handlerArg (((Parser *)parser)->m_handlerArg)
#define startElementHandler (((Parser *)parser)->m_startElementHandler)
#define endElementHandler (((Parser *)parser)->m_endElementHandler)
#define characterDataHandler (((Parser *)parser)->m_characterDataHandler)
#define processingInstructionHandler (((Parser *)parser)->m_processingInstructionHandler)
#define commentHandler (((Parser *)parser)->m_commentHandler)
#define startCdataSectionHandler (((Parser *)parser)->m_startCdataSectionHandler)
#define endCdataSectionHandler (((Parser *)parser)->m_endCdataSectionHandler)
#define defaultHandler (((Parser *)parser)->m_defaultHandler)
#define startDoctypeDeclHandler (((Parser *)parser)->m_startDoctypeDeclHandler)
#define endDoctypeDeclHandler (((Parser *)parser)->m_endDoctypeDeclHandler)
#define unparsedEntityDeclHandler (((Parser *)parser)->m_unparsedEntityDeclHandler)
#define notationDeclHandler (((Parser *)parser)->m_notationDeclHandler)
#define startNamespaceDeclHandler (((Parser *)parser)->m_startNamespaceDeclHandler)
#define endNamespaceDeclHandler (((Parser *)parser)->m_endNamespaceDeclHandler)
#define notStandaloneHandler (((Parser *)parser)->m_notStandaloneHandler)
#define externalEntityRefHandler (((Parser *)parser)->m_externalEntityRefHandler)
#define externalEntityRefHandlerArg (((Parser *)parser)->m_externalEntityRefHandlerArg)
#define internalEntityRefHandler (((Parser *)parser)->m_internalEntityRefHandler)
#define unknownEncodingHandler (((Parser *)parser)->m_unknownEncodingHandler)
#define elementDeclHandler (((Parser *)parser)->m_elementDeclHandler)
#define attlistDeclHandler (((Parser *)parser)->m_attlistDeclHandler)
#define entityDeclHandler (((Parser *)parser)->m_entityDeclHandler)
#define xmlDeclHandler (((Parser *)parser)->m_xmlDeclHandler)
#define encoding (((Parser *)parser)->m_encoding)
#define initEncoding (((Parser *)parser)->m_initEncoding)
#define internalEncoding (((Parser *)parser)->m_internalEncoding)
#define unknownEncodingMem (((Parser *)parser)->m_unknownEncodingMem)
#define unknownEncodingData (((Parser *)parser)->m_unknownEncodingData)
#define unknownEncodingHandlerData \
  (((Parser *)parser)->m_unknownEncodingHandlerData)
#define unknownEncodingRelease (((Parser *)parser)->m_unknownEncodingRelease)
#define protocolEncodingName (((Parser *)parser)->m_protocolEncodingName)
#define ns (((Parser *)parser)->m_ns)
#define ns_triplets (((Parser *)parser)->m_ns_triplets)
#define prologState (((Parser *)parser)->m_prologState)
#define processor (((Parser *)parser)->m_processor)
#define errorCode (((Parser *)parser)->m_errorCode)
#define eventPtr (((Parser *)parser)->m_eventPtr)
#define eventEndPtr (((Parser *)parser)->m_eventEndPtr)
#define positionPtr (((Parser *)parser)->m_positionPtr)
#define position (((Parser *)parser)->m_position)
#define openInternalEntities (((Parser *)parser)->m_openInternalEntities)
#define defaultExpandInternalEntities (((Parser *)parser)->m_defaultExpandInternalEntities)
#define tagLevel (((Parser *)parser)->m_tagLevel)
#define buffer (((Parser *)parser)->m_buffer)
#define bufferPtr (((Parser *)parser)->m_bufferPtr)
#define bufferEnd (((Parser *)parser)->m_bufferEnd)
#define parseEndByteIndex (((Parser *)parser)->m_parseEndByteIndex)
#define parseEndPtr (((Parser *)parser)->m_parseEndPtr)
#define bufferLim (((Parser *)parser)->m_bufferLim)
#define dataBuf (((Parser *)parser)->m_dataBuf)
#define dataBufEnd (((Parser *)parser)->m_dataBufEnd)
#define dtd (((Parser *)parser)->m_dtd)
#define curBase (((Parser *)parser)->m_curBase)
#define declEntity (((Parser *)parser)->m_declEntity)
#define doctypeName (((Parser *)parser)->m_doctypeName)
#define doctypeSysid (((Parser *)parser)->m_doctypeSysid)
#define doctypePubid (((Parser *)parser)->m_doctypePubid)
#define declAttributeType (((Parser *)parser)->m_declAttributeType)
#define declNotationName (((Parser *)parser)->m_declNotationName)
#define declNotationPublicId (((Parser *)parser)->m_declNotationPublicId)
#define declElementType (((Parser *)parser)->m_declElementType)
#define declAttributeId (((Parser *)parser)->m_declAttributeId)
#define declAttributeIsCdata (((Parser *)parser)->m_declAttributeIsCdata)
#define declAttributeIsId (((Parser *)parser)->m_declAttributeIsId)
#define freeTagList (((Parser *)parser)->m_freeTagList)
#define freeBindingList (((Parser *)parser)->m_freeBindingList)
#define inheritedBindings (((Parser *)parser)->m_inheritedBindings)
#define tagStack (((Parser *)parser)->m_tagStack)
#define atts (((Parser *)parser)->m_atts)
#define attsSize (((Parser *)parser)->m_attsSize)
#define nSpecifiedAtts (((Parser *)parser)->m_nSpecifiedAtts)
#define idAttIndex (((Parser *)parser)->m_idAttIndex)
#define tempPool (((Parser *)parser)->m_tempPool)
#define temp2Pool (((Parser *)parser)->m_temp2Pool)
#define groupConnector (((Parser *)parser)->m_groupConnector)
#define groupSize (((Parser *)parser)->m_groupSize)
#define hadExternalDoctype (((Parser *)parser)->m_hadExternalDoctype)
#define namespaceSeparator (((Parser *)parser)->m_namespaceSeparator)
#ifdef XML_DTD
#define parentParser (((Parser *)parser)->m_parentParser)
#define paramEntityParsing (((Parser *)parser)->m_paramEntityParsing)
#endif /* XML_DTD */

#ifdef COMPILED_FROM_DSP
BOOL WINAPI DllMain(HINSTANCE h, DWORD r, LPVOID p) {
  return TRUE;
}
#endif /* def COMPILED_FROM_DSP */

#ifdef _MSC_VER
#ifdef _DEBUG
Parser *asParser(XML_Parser parser)
{
  return parser;
}
#endif
#endif

XML_Parser XML_ParserCreate(const XML_Char *encodingName)
{
  return XML_ParserCreate_MM(encodingName, NULL, NULL);
}

XML_Parser XML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep)
{
  XML_Char tmp[2];
  *tmp = nsSep;
  return XML_ParserCreate_MM(encodingName, NULL, tmp);
}

XML_Parser
XML_ParserCreate_MM(const XML_Char *encodingName,
		    const XML_Memory_Handling_Suite *memsuite,
		    const XML_Char *nameSep) {
  
  XML_Parser parser;
  static
  const XML_Char implicitContext[] = {
    XML_T('x'), XML_T('m'), XML_T('l'), XML_T('='),
    XML_T('h'), XML_T('t'), XML_T('t'), XML_T('p'), XML_T(':'),
    XML_T('/'), XML_T('/'), XML_T('w'), XML_T('w'), XML_T('w'),
    XML_T('.'), XML_T('w'), XML_T('3'),
    XML_T('.'), XML_T('o'), XML_T('r'), XML_T('g'),
    XML_T('/'), XML_T('X'), XML_T('M'), XML_T('L'),
    XML_T('/'), XML_T('1'), XML_T('9'), XML_T('9'), XML_T('8'),
    XML_T('/'), XML_T('n'), XML_T('a'), XML_T('m'), XML_T('e'),
    XML_T('s'), XML_T('p'), XML_T('a'), XML_T('c'), XML_T('e'),
    XML_T('\0')
  };


  if (memsuite) {
    XML_Memory_Handling_Suite *mtemp;
    parser = memsuite->malloc_fcn(sizeof(Parser));
    mtemp = &(((Parser *) parser)->m_mem);
    mtemp->malloc_fcn = memsuite->malloc_fcn;
    mtemp->realloc_fcn = memsuite->realloc_fcn;
    mtemp->free_fcn = memsuite->free_fcn;
  }
  else {
    XML_Memory_Handling_Suite *mtemp;
    parser = malloc(sizeof(Parser));
    mtemp = &(((Parser *) parser)->m_mem);
    mtemp->malloc_fcn = malloc;
    mtemp->realloc_fcn = realloc;
    mtemp->free_fcn = free;
  }

  if (!parser)
    return parser;
  processor = prologInitProcessor;
  XmlPrologStateInit(&prologState);
  userData = 0;
  handlerArg = 0;
  startElementHandler = 0;
  endElementHandler = 0;
  characterDataHandler = 0;
  processingInstructionHandler = 0;
  commentHandler = 0;
  startCdataSectionHandler = 0;
  endCdataSectionHandler = 0;
  defaultHandler = 0;
  startDoctypeDeclHandler = 0;
  endDoctypeDeclHandler = 0;
  unparsedEntityDeclHandler = 0;
  notationDeclHandler = 0;
  startNamespaceDeclHandler = 0;
  endNamespaceDeclHandler = 0;
  notStandaloneHandler = 0;
  externalEntityRefHandler = 0;
  externalEntityRefHandlerArg = parser;
  unknownEncodingHandler = 0;
  elementDeclHandler = 0;
  attlistDeclHandler = 0;
  entityDeclHandler = 0;
  xmlDeclHandler = 0;
  buffer = 0;
  bufferPtr = 0;
  bufferEnd = 0;
  parseEndByteIndex = 0;
  parseEndPtr = 0;
  bufferLim = 0;
  declElementType = 0;
  declAttributeId = 0;
  declEntity = 0;
  doctypeName = 0;
  doctypeSysid = 0;
  doctypePubid = 0;
  declAttributeType = 0;
  declNotationName = 0;
  declNotationPublicId = 0;
  memset(&position, 0, sizeof(POSITION));
  errorCode = XML_ERROR_NONE;
  eventPtr = 0;
  eventEndPtr = 0;
  positionPtr = 0;
  openInternalEntities = 0;
  tagLevel = 0;
  tagStack = 0;
  freeTagList = 0;
  freeBindingList = 0;
  inheritedBindings = 0;
  attsSize = INIT_ATTS_SIZE;
  atts = MALLOC(attsSize * sizeof(ATTRIBUTE));
  nSpecifiedAtts = 0;
  dataBuf = MALLOC(INIT_DATA_BUF_SIZE * sizeof(XML_Char));
  groupSize = 0;
  groupConnector = 0;
  hadExternalDoctype = 0;
  unknownEncodingMem = 0;
  unknownEncodingRelease = 0;
  unknownEncodingData = 0;
  unknownEncodingHandlerData = 0;
  namespaceSeparator = '!';
#ifdef XML_DTD
  parentParser = 0;
  paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;
#endif
  ns = 0;
  ns_triplets = 0;
  poolInit(&tempPool, &(((Parser *) parser)->m_mem));
  poolInit(&temp2Pool, &(((Parser *) parser)->m_mem));
  protocolEncodingName = encodingName ? poolCopyString(&tempPool, encodingName) : 0;
  curBase = 0;
  if (!dtdInit(&dtd, parser) || !atts || !dataBuf
      || (encodingName && !protocolEncodingName)) {
    XML_ParserFree(parser);
    return 0;
  }
  dataBufEnd = dataBuf + INIT_DATA_BUF_SIZE;

  if (nameSep) {
    XmlInitEncodingNS(&initEncoding, &encoding, 0);
    ns = 1;
    internalEncoding = XmlGetInternalEncodingNS();
    namespaceSeparator = *nameSep;

    if (! setContext(parser, implicitContext)) {
      XML_ParserFree(parser);
      return 0;
    }
  }
  else {
    XmlInitEncoding(&initEncoding, &encoding, 0);
    internalEncoding = XmlGetInternalEncoding();
  }

  return parser;
}  /* End XML_ParserCreate_MM */

int XML_SetEncoding(XML_Parser parser, const XML_Char *encodingName)
{
  if (!encodingName)
    protocolEncodingName = 0;
  else {
    protocolEncodingName = poolCopyString(&tempPool, encodingName);
    if (!protocolEncodingName)
      return 0;
  }
  return 1;
}

XML_Parser XML_ExternalEntityParserCreate(XML_Parser oldParser,
					  const XML_Char *context,
					  const XML_Char *encodingName)
{
  XML_Parser parser = oldParser;
  DTD *oldDtd = &dtd;
  XML_StartElementHandler oldStartElementHandler = startElementHandler;
  XML_EndElementHandler oldEndElementHandler = endElementHandler;
  XML_CharacterDataHandler oldCharacterDataHandler = characterDataHandler;
  XML_ProcessingInstructionHandler oldProcessingInstructionHandler = processingInstructionHandler;
  XML_CommentHandler oldCommentHandler = commentHandler;
  XML_StartCdataSectionHandler oldStartCdataSectionHandler = startCdataSectionHandler;
  XML_EndCdataSectionHandler oldEndCdataSectionHandler = endCdataSectionHandler;
  XML_DefaultHandler oldDefaultHandler = defaultHandler;
  XML_UnparsedEntityDeclHandler oldUnparsedEntityDeclHandler = unparsedEntityDeclHandler;
  XML_NotationDeclHandler oldNotationDeclHandler = notationDeclHandler;
  XML_StartNamespaceDeclHandler oldStartNamespaceDeclHandler = startNamespaceDeclHandler;
  XML_EndNamespaceDeclHandler oldEndNamespaceDeclHandler = endNamespaceDeclHandler;
  XML_NotStandaloneHandler oldNotStandaloneHandler = notStandaloneHandler;
  XML_ExternalEntityRefHandler oldExternalEntityRefHandler = externalEntityRefHandler;
  XML_UnknownEncodingHandler oldUnknownEncodingHandler = unknownEncodingHandler;
  XML_ElementDeclHandler oldElementDeclHandler = elementDeclHandler;
  XML_AttlistDeclHandler oldAttlistDeclHandler = attlistDeclHandler;
  XML_EntityDeclHandler oldEntityDeclHandler = entityDeclHandler;
  XML_XmlDeclHandler oldXmlDeclHandler = xmlDeclHandler;
  ELEMENT_TYPE * oldDeclElementType = declElementType;

  void *oldUserData = userData;
  void *oldHandlerArg = handlerArg;
  int oldDefaultExpandInternalEntities = defaultExpandInternalEntities;
  void *oldExternalEntityRefHandlerArg = externalEntityRefHandlerArg;
#ifdef XML_DTD
  int oldParamEntityParsing = paramEntityParsing;
#endif
  int oldns_triplets = ns_triplets;

  if (ns) {
    XML_Char tmp[2];

    *tmp = namespaceSeparator;
    parser = XML_ParserCreate_MM(encodingName, &((Parser *)parser)->m_mem,
				 tmp);
  }
  else {
    parser = XML_ParserCreate_MM(encodingName, &((Parser *)parser)->m_mem,
				 NULL);
  }

  if (!parser)
    return 0;

  startElementHandler = oldStartElementHandler;
  endElementHandler = oldEndElementHandler;
  characterDataHandler = oldCharacterDataHandler;
  processingInstructionHandler = oldProcessingInstructionHandler;
  commentHandler = oldCommentHandler;
  startCdataSectionHandler = oldStartCdataSectionHandler;
  endCdataSectionHandler = oldEndCdataSectionHandler;
  defaultHandler = oldDefaultHandler;
  unparsedEntityDeclHandler = oldUnparsedEntityDeclHandler;
  notationDeclHandler = oldNotationDeclHandler;
  startNamespaceDeclHandler = oldStartNamespaceDeclHandler;
  endNamespaceDeclHandler = oldEndNamespaceDeclHandler;
  notStandaloneHandler = oldNotStandaloneHandler;
  externalEntityRefHandler = oldExternalEntityRefHandler;
  unknownEncodingHandler = oldUnknownEncodingHandler;
  elementDeclHandler = oldElementDeclHandler;
  attlistDeclHandler = oldAttlistDeclHandler;
  entityDeclHandler = oldEntityDeclHandler;
  xmlDeclHandler = oldXmlDeclHandler;
  declElementType = oldDeclElementType;
  userData = oldUserData;
  if (oldUserData == oldHandlerArg)
    handlerArg = userData;
  else
    handlerArg = parser;
  if (oldExternalEntityRefHandlerArg != oldParser)
    externalEntityRefHandlerArg = oldExternalEntityRefHandlerArg;
  defaultExpandInternalEntities = oldDefaultExpandInternalEntities;
  ns_triplets = oldns_triplets;
#ifdef XML_DTD
  paramEntityParsing = oldParamEntityParsing;
  if (context) {
#endif /* XML_DTD */
    if (!dtdCopy(&dtd, oldDtd, parser) || !setContext(parser, context)) {
      XML_ParserFree(parser);
      return 0;
    }
    processor = externalEntityInitProcessor;
#ifdef XML_DTD
  }
  else {
    dtdSwap(&dtd, oldDtd);
    parentParser = oldParser;
    XmlPrologStateInitExternalEntity(&prologState);
    dtd.complete = 1;
    hadExternalDoctype = 1;
  }
#endif /* XML_DTD */
  return parser;
}

static
void destroyBindings(BINDING *bindings, XML_Parser parser)
{
  for (;;) {
    BINDING *b = bindings;
    if (!b)
      break;
    bindings = b->nextTagBinding;
    FREE(b->uri);
    FREE(b);
  }
}

void XML_ParserFree(XML_Parser parser)
{
  for (;;) {
    TAG *p;
    if (tagStack == 0) {
      if (freeTagList == 0)
	break;
      tagStack = freeTagList;
      freeTagList = 0;
    }
    p = tagStack;
    tagStack = tagStack->parent;
    FREE(p->buf);
    destroyBindings(p->bindings, parser);
    FREE(p);
  }
  destroyBindings(freeBindingList, parser);
  destroyBindings(inheritedBindings, parser);
  poolDestroy(&tempPool);
  poolDestroy(&temp2Pool);
#ifdef XML_DTD
  if (parentParser) {
    if (hadExternalDoctype)
      dtd.complete = 0;
    dtdSwap(&dtd, &((Parser *)parentParser)->m_dtd);
  }
#endif /* XML_DTD */
  dtdDestroy(&dtd, parser);
  FREE((void *)atts);
  if (groupConnector)
    FREE(groupConnector);
  if (buffer)
    FREE(buffer);
  FREE(dataBuf);
  if (unknownEncodingMem)
    FREE(unknownEncodingMem);
  if (unknownEncodingRelease)
    unknownEncodingRelease(unknownEncodingData);
  FREE(parser);
}

void XML_UseParserAsHandlerArg(XML_Parser parser)
{
  handlerArg = parser;
}

void
XML_SetReturnNSTriplet(XML_Parser parser, int do_nst) {
  ns_triplets = do_nst;
}

void XML_SetUserData(XML_Parser parser, void *p)
{
  if (handlerArg == userData)
    handlerArg = userData = p;
  else
    userData = p;
}

int XML_SetBase(XML_Parser parser, const XML_Char *p)
{
  if (p) {
    p = poolCopyString(&dtd.pool, p);
    if (!p)
      return 0;
    curBase = p;
  }
  else
    curBase = 0;
  return 1;
}

const XML_Char *XML_GetBase(XML_Parser parser)
{
  return curBase;
}

int XML_GetSpecifiedAttributeCount(XML_Parser parser)
{
  return nSpecifiedAtts;
}

int XML_GetIdAttributeIndex(XML_Parser parser)
{
  return idAttIndex;
}

void XML_SetElementHandler(XML_Parser parser,
			   XML_StartElementHandler start,
			   XML_EndElementHandler end)
{
  startElementHandler = start;
  endElementHandler = end;
}

void XML_SetStartElementHandler(XML_Parser parser,
				XML_StartElementHandler start) {
  startElementHandler = start;
}

void XML_SetEndElementHandler(XML_Parser parser,
			      XML_EndElementHandler end) {
  endElementHandler = end;
}

void XML_SetCharacterDataHandler(XML_Parser parser,
				 XML_CharacterDataHandler handler)
{
  characterDataHandler = handler;
}

void XML_SetProcessingInstructionHandler(XML_Parser parser,
					 XML_ProcessingInstructionHandler handler)
{
  processingInstructionHandler = handler;
}

void XML_SetCommentHandler(XML_Parser parser,
			   XML_CommentHandler handler)
{
  commentHandler = handler;
}

void XML_SetCdataSectionHandler(XML_Parser parser,
				XML_StartCdataSectionHandler start,
			        XML_EndCdataSectionHandler end)
{
  startCdataSectionHandler = start;
  endCdataSectionHandler = end;
}

void XML_SetStartCdataSectionHandler(XML_Parser parser,
                                     XML_StartCdataSectionHandler start) {
  startCdataSectionHandler = start;
}

void XML_SetEndCdataSectionHandler(XML_Parser parser,
                                   XML_EndCdataSectionHandler end) {
  endCdataSectionHandler = end;
}

void XML_SetDefaultHandler(XML_Parser parser,
			   XML_DefaultHandler handler)
{
  defaultHandler = handler;
  defaultExpandInternalEntities = 0;
}

void XML_SetDefaultHandlerExpand(XML_Parser parser,
				 XML_DefaultHandler handler)
{
  defaultHandler = handler;
  defaultExpandInternalEntities = 1;
}

void XML_SetDoctypeDeclHandler(XML_Parser parser,
			       XML_StartDoctypeDeclHandler start,
			       XML_EndDoctypeDeclHandler end)
{
  startDoctypeDeclHandler = start;
  endDoctypeDeclHandler = end;
}

void XML_SetStartDoctypeDeclHandler(XML_Parser parser,
				    XML_StartDoctypeDeclHandler start) {
  startDoctypeDeclHandler = start;
}

void XML_SetEndDoctypeDeclHandler(XML_Parser parser,
				  XML_EndDoctypeDeclHandler end) {
  endDoctypeDeclHandler = end;
}

void XML_SetUnparsedEntityDeclHandler(XML_Parser parser,
				      XML_UnparsedEntityDeclHandler handler)
{
  unparsedEntityDeclHandler = handler;
}

void XML_SetNotationDeclHandler(XML_Parser parser,
				XML_NotationDeclHandler handler)
{
  notationDeclHandler = handler;
}

void XML_SetNamespaceDeclHandler(XML_Parser parser,
				 XML_StartNamespaceDeclHandler start,
				 XML_EndNamespaceDeclHandler end)
{
  startNamespaceDeclHandler = start;
  endNamespaceDeclHandler = end;
}

void XML_SetStartNamespaceDeclHandler(XML_Parser parser,
				      XML_StartNamespaceDeclHandler start) {
  startNamespaceDeclHandler = start;
}

void XML_SetEndNamespaceDeclHandler(XML_Parser parser,
				    XML_EndNamespaceDeclHandler end) {
  endNamespaceDeclHandler = end;
}


void XML_SetNotStandaloneHandler(XML_Parser parser,
				 XML_NotStandaloneHandler handler)
{
  notStandaloneHandler = handler;
}

void XML_SetExternalEntityRefHandler(XML_Parser parser,
				     XML_ExternalEntityRefHandler handler)
{
  externalEntityRefHandler = handler;
}

void XML_SetExternalEntityRefHandlerArg(XML_Parser parser, void *arg)
{
  if (arg)
    externalEntityRefHandlerArg = arg;
  else
    externalEntityRefHandlerArg = parser;
}

void XML_SetUnknownEncodingHandler(XML_Parser parser,
				   XML_UnknownEncodingHandler handler,
				   void *data)
{
  unknownEncodingHandler = handler;
  unknownEncodingHandlerData = data;
}

void XML_SetElementDeclHandler(XML_Parser parser,
			       XML_ElementDeclHandler eldecl)
{
  elementDeclHandler = eldecl;
}

void XML_SetAttlistDeclHandler(XML_Parser parser,
			       XML_AttlistDeclHandler attdecl)
{
  attlistDeclHandler = attdecl;
}

void XML_SetEntityDeclHandler(XML_Parser parser,
			      XML_EntityDeclHandler handler)
{
  entityDeclHandler = handler;
}

void XML_SetXmlDeclHandler(XML_Parser parser,
			   XML_XmlDeclHandler handler) {
  xmlDeclHandler = handler;
}

int XML_SetParamEntityParsing(XML_Parser parser,
			      enum XML_ParamEntityParsing parsing)
{
#ifdef XML_DTD
  paramEntityParsing = parsing;
  return 1;
#else
  return parsing == XML_PARAM_ENTITY_PARSING_NEVER;
#endif
}

int XML_Parse(XML_Parser parser, const char *s, int len, int isFinal)
{
  if (len == 0) {
    if (!isFinal)
      return 1;
    positionPtr = bufferPtr;
    errorCode = processor(parser, bufferPtr, parseEndPtr = bufferEnd, 0);
    if (errorCode == XML_ERROR_NONE)
      return 1;
    eventEndPtr = eventPtr;
    processor = errorProcessor;
    return 0;
  }
#ifndef XML_CONTEXT_BYTES
  else if (bufferPtr == bufferEnd) {
    const char *end;
    int nLeftOver;
    parseEndByteIndex += len;
    positionPtr = s;
    if (isFinal) {
      errorCode = processor(parser, s, parseEndPtr = s + len, 0);
      if (errorCode == XML_ERROR_NONE)
	return 1;
      eventEndPtr = eventPtr;
      processor = errorProcessor;
      return 0;
    }
    errorCode = processor(parser, s, parseEndPtr = s + len, &end);
    if (errorCode != XML_ERROR_NONE) {
      eventEndPtr = eventPtr;
      processor = errorProcessor;
      return 0;
    }
    XmlUpdatePosition(encoding, positionPtr, end, &position);
    nLeftOver = s + len - end;
    if (nLeftOver) {
      if (buffer == 0 || nLeftOver > bufferLim - buffer) {
	/* FIXME avoid integer overflow */
	buffer = buffer == 0 ? MALLOC(len * 2) : REALLOC(buffer, len * 2);
	/* FIXME storage leak if realloc fails */
	if (!buffer) {
	  errorCode = XML_ERROR_NO_MEMORY;
	  eventPtr = eventEndPtr = 0;
	  processor = errorProcessor;
	  return 0;
	}
	bufferLim = buffer + len * 2;
      }
      memcpy(buffer, end, nLeftOver);
      bufferPtr = buffer;
      bufferEnd = buffer + nLeftOver;
    }
    return 1;
  }
#endif  /* not defined XML_CONTEXT_BYTES */
  else {
    memcpy(XML_GetBuffer(parser, len), s, len);
    return XML_ParseBuffer(parser, len, isFinal);
  }
}

int XML_ParseBuffer(XML_Parser parser, int len, int isFinal)
{
  const char *start = bufferPtr;
  positionPtr = start;
  bufferEnd += len;
  parseEndByteIndex += len;
  errorCode = processor(parser, start, parseEndPtr = bufferEnd,
			isFinal ? (const char **)0 : &bufferPtr);
  if (errorCode == XML_ERROR_NONE) {
    if (!isFinal)
      XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);
    return 1;
  }
  else {
    eventEndPtr = eventPtr;
    processor = errorProcessor;
    return 0;
  }
}

void *XML_GetBuffer(XML_Parser parser, int len)
{
  if (len > bufferLim - bufferEnd) {
    /* FIXME avoid integer overflow */
    int neededSize = len + (bufferEnd - bufferPtr);
#ifdef XML_CONTEXT_BYTES
    int keep = bufferPtr - buffer;

    if (keep > XML_CONTEXT_BYTES)
      keep = XML_CONTEXT_BYTES;
    neededSize += keep;
#endif  /* defined XML_CONTEXT_BYTES */
    if (neededSize  <= bufferLim - buffer) {
#ifdef XML_CONTEXT_BYTES
      if (keep < bufferPtr - buffer) {
	int offset = (bufferPtr - buffer) - keep;
	memmove(buffer, &buffer[offset], bufferEnd - bufferPtr + keep);
	bufferEnd -= offset;
	bufferPtr -= offset;
      }
#else
      memmove(buffer, bufferPtr, bufferEnd - bufferPtr);
      bufferEnd = buffer + (bufferEnd - bufferPtr);
      bufferPtr = buffer;
#endif  /* not defined XML_CONTEXT_BYTES */
    }
    else {
      char *newBuf;
      int bufferSize = bufferLim - bufferPtr;
      if (bufferSize == 0)
	bufferSize = INIT_BUFFER_SIZE;
      do {
	bufferSize *= 2;
      } while (bufferSize < neededSize);
      newBuf = MALLOC(bufferSize);
      if (newBuf == 0) {
	errorCode = XML_ERROR_NO_MEMORY;
	return 0;
      }
      bufferLim = newBuf + bufferSize;
#ifdef XML_CONTEXT_BYTES
      if (bufferPtr) {
	int keep = bufferPtr - buffer;
	if (keep > XML_CONTEXT_BYTES)
	  keep = XML_CONTEXT_BYTES;
	memcpy(newBuf, &bufferPtr[-keep], bufferEnd - bufferPtr + keep);
	FREE(buffer);
	buffer = newBuf;
	bufferEnd = buffer + (bufferEnd - bufferPtr) + keep;
	bufferPtr = buffer + keep;
      }
      else {
	bufferEnd = newBuf + (bufferEnd - bufferPtr);
	bufferPtr = buffer = newBuf;
      }
#else
      if (bufferPtr) {
	memcpy(newBuf, bufferPtr, bufferEnd - bufferPtr);
	FREE(buffer);
      }
      bufferEnd = newBuf + (bufferEnd - bufferPtr);
      bufferPtr = buffer = newBuf;
#endif  /* not defined XML_CONTEXT_BYTES */
    }
  }
  return bufferEnd;
}

enum XML_Error XML_GetErrorCode(XML_Parser parser)
{
  return errorCode;
}

long XML_GetCurrentByteIndex(XML_Parser parser)
{
  if (eventPtr)
    return parseEndByteIndex - (parseEndPtr - eventPtr);
  return -1;
}

int XML_GetCurrentByteCount(XML_Parser parser)
{
  if (eventEndPtr && eventPtr)
    return eventEndPtr - eventPtr;
  return 0;
}

const char * XML_GetInputContext(XML_Parser parser, int *offset, int *size)
{
#ifdef XML_CONTEXT_BYTES
  if (eventPtr && buffer) {
    *offset = eventPtr - buffer;
    *size   = bufferEnd - buffer;
    return buffer;
  }
#endif /* defined XML_CONTEXT_BYTES */
  return (char *) 0;
}

int XML_GetCurrentLineNumber(XML_Parser parser)
{
  if (eventPtr) {
    XmlUpdatePosition(encoding, positionPtr, eventPtr, &position);
    positionPtr = eventPtr;
  }
  return position.lineNumber + 1;
}

int XML_GetCurrentColumnNumber(XML_Parser parser)
{
  if (eventPtr) {
    XmlUpdatePosition(encoding, positionPtr, eventPtr, &position);
    positionPtr = eventPtr;
  }
  return position.columnNumber;
}

void XML_DefaultCurrent(XML_Parser parser)
{
  if (defaultHandler) {
    if (openInternalEntities)
      reportDefault(parser,
	            internalEncoding,
		    openInternalEntities->internalEventPtr,
		    openInternalEntities->internalEventEndPtr);
    else
      reportDefault(parser, encoding, eventPtr, eventEndPtr);
  }
}

const XML_LChar *XML_ErrorString(int code)
{
  static const XML_LChar *message[] = {
    0,
    XML_T("out of memory"),
    XML_T("syntax error"),
    XML_T("no element found"),
    XML_T("not well-formed (invalid token)"),
    XML_T("unclosed token"),
    XML_T("unclosed token"),
    XML_T("mismatched tag"),
    XML_T("duplicate attribute"),
    XML_T("junk after document element"),
    XML_T("illegal parameter entity reference"),
    XML_T("undefined entity"),
    XML_T("recursive entity reference"),
    XML_T("asynchronous entity"),
    XML_T("reference to invalid character number"),
    XML_T("reference to binary entity"),
    XML_T("reference to external entity in attribute"),
    XML_T("xml processing instruction not at start of external entity"),
    XML_T("unknown encoding"),
    XML_T("encoding specified in XML declaration is incorrect"),
    XML_T("unclosed CDATA section"),
    XML_T("error in processing external entity reference"),
    XML_T("document is not standalone"),
    XML_T("unexpected parser state - please send a bug report")
  };
  if (code > 0 && code < sizeof(message)/sizeof(message[0]))
    return message[code];
  return 0;
}

const XML_LChar *
XML_ExpatVersion(void) {
  return VERSION;
}

XML_Expat_Version
XML_ExpatVersionInfo(void) {
  XML_Expat_Version version;

  version.major = XML_MAJOR_VERSION;
  version.minor = XML_MINOR_VERSION;
  version.micro = XML_MICRO_VERSION;

  return version;
}

static
enum XML_Error contentProcessor(XML_Parser parser,
				const char *start,
				const char *end,
				const char **endPtr)
{
  return doContent(parser, 0, encoding, start, end, endPtr);
}

static
enum XML_Error externalEntityInitProcessor(XML_Parser parser,
					   const char *start,
					   const char *end,
					   const char **endPtr)
{
  enum XML_Error result = initializeEncoding(parser);
  if (result != XML_ERROR_NONE)
    return result;
  processor = externalEntityInitProcessor2;
  return externalEntityInitProcessor2(parser, start, end, endPtr);
}

static
enum XML_Error externalEntityInitProcessor2(XML_Parser parser,
					    const char *start,
					    const char *end,
					    const char **endPtr)
{
  const char *next;
  int tok = XmlContentTok(encoding, start, end, &next);
  switch (tok) {
  case XML_TOK_BOM:
    start = next;
    break;
  case XML_TOK_PARTIAL:
    if (endPtr) {
      *endPtr = start;
      return XML_ERROR_NONE;
    }
    eventPtr = start;
    return XML_ERROR_UNCLOSED_TOKEN;
  case XML_TOK_PARTIAL_CHAR:
    if (endPtr) {
      *endPtr = start;
      return XML_ERROR_NONE;
    }
    eventPtr = start;
    return XML_ERROR_PARTIAL_CHAR;
  }
  processor = externalEntityInitProcessor3;
  return externalEntityInitProcessor3(parser, start, end, endPtr);
}

static
enum XML_Error externalEntityInitProcessor3(XML_Parser parser,
					    const char *start,
					    const char *end,
					    const char **endPtr)
{
  const char *next;
  int tok = XmlContentTok(encoding, start, end, &next);
  switch (tok) {
  case XML_TOK_XML_DECL:
    {
      enum XML_Error result = processXmlDecl(parser, 1, start, next);
      if (result != XML_ERROR_NONE)
	return result;
      start = next;
    }
    break;
  case XML_TOK_PARTIAL:
    if (endPtr) {
      *endPtr = start;
      return XML_ERROR_NONE;
    }
    eventPtr = start;
    return XML_ERROR_UNCLOSED_TOKEN;
  case XML_TOK_PARTIAL_CHAR:
    if (endPtr) {
      *endPtr = start;
      return XML_ERROR_NONE;
    }
    eventPtr = start;
    return XML_ERROR_PARTIAL_CHAR;
  }
  processor = externalEntityContentProcessor;
  tagLevel = 1;
  return doContent(parser, 1, encoding, start, end, endPtr);
}

static
enum XML_Error externalEntityContentProcessor(XML_Parser parser,
					      const char *start,
					      const char *end,
					      const char **endPtr)
{
  return doContent(parser, 1, encoding, start, end, endPtr);
}

static enum XML_Error
doContent(XML_Parser parser,
	  int startTagLevel,
	  const ENCODING *enc,
	  const char *s,
	  const char *end,
	  const char **nextPtr)
{
  const char **eventPP;
  const char **eventEndPP;
  if (enc == encoding) {
    eventPP = &eventPtr;
    eventEndPP = &eventEndPtr;
  }
  else {
    eventPP = &(openInternalEntities->internalEventPtr);
    eventEndPP = &(openInternalEntities->internalEventEndPtr);
  }
  *eventPP = s;
  for (;;) {
    const char *next = s; /* XmlContentTok doesn't always set the last arg */
    int tok = XmlContentTok(enc, s, end, &next);
    *eventEndPP = next;
    switch (tok) {
    case XML_TOK_TRAILING_CR:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      *eventEndPP = end;
      if (characterDataHandler) {
	XML_Char c = 0xA;
	characterDataHandler(handlerArg, &c, 1);
      }
      else if (defaultHandler)
	reportDefault(parser, enc, s, end);
      if (startTagLevel == 0)
	return XML_ERROR_NO_ELEMENTS;
      if (tagLevel != startTagLevel)
	return XML_ERROR_ASYNC_ENTITY;
      return XML_ERROR_NONE;
    case XML_TOK_NONE:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      if (startTagLevel > 0) {
	if (tagLevel != startTagLevel)
	  return XML_ERROR_ASYNC_ENTITY;
	return XML_ERROR_NONE;
      }
      return XML_ERROR_NO_ELEMENTS;
    case XML_TOK_INVALID:
      *eventPP = next;
      return XML_ERROR_INVALID_TOKEN;
    case XML_TOK_PARTIAL:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      return XML_ERROR_UNCLOSED_TOKEN;
    case XML_TOK_PARTIAL_CHAR:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      return XML_ERROR_PARTIAL_CHAR;
    case XML_TOK_ENTITY_REF:
      {
	const XML_Char *name;
	ENTITY *entity;
	XML_Char ch = XmlPredefinedEntityName(enc,
					      s + enc->minBytesPerChar,
					      next - enc->minBytesPerChar);
	if (ch) {
	  if (characterDataHandler)
	    characterDataHandler(handlerArg, &ch, 1);
	  else if (defaultHandler)
	    reportDefault(parser, enc, s, next);
	  break;
	}
	name = poolStoreString(&dtd.pool, enc,
				s + enc->minBytesPerChar,
				next - enc->minBytesPerChar);
	if (!name)
	  return XML_ERROR_NO_MEMORY;
	entity = (ENTITY *)lookup(&dtd.generalEntities, name, 0);
	poolDiscard(&dtd.pool);
	if (!entity) {
	  if (dtd.complete || dtd.standalone)
	    return XML_ERROR_UNDEFINED_ENTITY;
	  if (defaultHandler)
	    reportDefault(parser, enc, s, next);
	  break;
	}
	if (entity->open)
	  return XML_ERROR_RECURSIVE_ENTITY_REF;
	if (entity->notation)
	  return XML_ERROR_BINARY_ENTITY_REF;
	if (entity) {
	  if (entity->textPtr) {
	    enum XML_Error result;
	    OPEN_INTERNAL_ENTITY openEntity;
	    if (defaultHandler && !defaultExpandInternalEntities) {
	      reportDefault(parser, enc, s, next);
	      break;
	    }
	    entity->open = 1;
	    openEntity.next = openInternalEntities;
	    openInternalEntities = &openEntity;
	    openEntity.entity = entity;
	    openEntity.internalEventPtr = 0;
	    openEntity.internalEventEndPtr = 0;
	    result = doContent(parser,
			       tagLevel,
			       internalEncoding,
			       (char *)entity->textPtr,
			       (char *)(entity->textPtr + entity->textLen),
			       0);
	    entity->open = 0;
	    openInternalEntities = openEntity.next;
	    if (result)
	      return result;
	  }
	  else if (externalEntityRefHandler) {
	    const XML_Char *context;
	    entity->open = 1;
	    context = getContext(parser);
	    entity->open = 0;
	    if (!context)
	      return XML_ERROR_NO_MEMORY;
	    if (!externalEntityRefHandler(externalEntityRefHandlerArg,
				          context,
					  entity->base,
					  entity->systemId,
					  entity->publicId))
	      return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
	    poolDiscard(&tempPool);
	  }
	  else if (defaultHandler)
	    reportDefault(parser, enc, s, next);
	}
	break;
      }
    case XML_TOK_START_TAG_WITH_ATTS:
      if (!startElementHandler) {
	enum XML_Error result = storeAtts(parser, enc, s, 0, 0);
	if (result)
	  return result;
      }
      /* fall through */
    case XML_TOK_START_TAG_NO_ATTS:
      {
	TAG *tag;
	if (freeTagList) {
	  tag = freeTagList;
	  freeTagList = freeTagList->parent;
	}
	else {
	  tag = MALLOC(sizeof(TAG));
	  if (!tag)
	    return XML_ERROR_NO_MEMORY;
	  tag->buf = MALLOC(INIT_TAG_BUF_SIZE);
	  if (!tag->buf)
	    return XML_ERROR_NO_MEMORY;
	  tag->bufEnd = tag->buf + INIT_TAG_BUF_SIZE;
	}
	tag->bindings = 0;
	tag->parent = tagStack;
	tagStack = tag;
	tag->name.localPart = 0;
	tag->rawName = s + enc->minBytesPerChar;
	tag->rawNameLength = XmlNameLength(enc, tag->rawName);
	if (nextPtr) {
	  /* Need to guarantee that:
	     tag->buf + ROUND_UP(tag->rawNameLength, sizeof(XML_Char)) <= tag->bufEnd - sizeof(XML_Char) */
	  if (tag->rawNameLength + (int)(sizeof(XML_Char) - 1) + (int)sizeof(XML_Char) > tag->bufEnd - tag->buf) {
	    int bufSize = tag->rawNameLength * 4;
	    bufSize = ROUND_UP(bufSize, sizeof(XML_Char));
	    tag->buf = REALLOC(tag->buf, bufSize);
	    if (!tag->buf)
	      return XML_ERROR_NO_MEMORY;
	    tag->bufEnd = tag->buf + bufSize;
	  }
	  memcpy(tag->buf, tag->rawName, tag->rawNameLength);
	  tag->rawName = tag->buf;
	}
	++tagLevel;
	if (startElementHandler) {
	  enum XML_Error result;
	  XML_Char *toPtr;
	  for (;;) {
	    const char *rawNameEnd = tag->rawName + tag->rawNameLength;
	    const char *fromPtr = tag->rawName;
	    int bufSize;
	    if (nextPtr)
	      toPtr = (XML_Char *)(tag->buf + ROUND_UP(tag->rawNameLength, sizeof(XML_Char)));
	    else
	      toPtr = (XML_Char *)tag->buf;
	    tag->name.str = toPtr;
	    XmlConvert(enc,
		       &fromPtr, rawNameEnd,
		       (ICHAR **)&toPtr, (ICHAR *)tag->bufEnd - 1);
	    if (fromPtr == rawNameEnd)
	      break;
	    bufSize = (tag->bufEnd - tag->buf) << 1;
	    tag->buf = REALLOC(tag->buf, bufSize);
	    if (!tag->buf)
	      return XML_ERROR_NO_MEMORY;
	    tag->bufEnd = tag->buf + bufSize;
	    if (nextPtr)
	      tag->rawName = tag->buf;
	  }
	  *toPtr = XML_T('\0');
	  result = storeAtts(parser, enc, s, &(tag->name), &(tag->bindings));
	  if (result)
	    return result;
	  startElementHandler(handlerArg, tag->name.str, (const XML_Char **)atts);
	  poolClear(&tempPool);
	}
	else {
	  tag->name.str = 0;
	  if (defaultHandler)
	    reportDefault(parser, enc, s, next);
	}
	break;
      }
    case XML_TOK_EMPTY_ELEMENT_WITH_ATTS:
      if (!startElementHandler) {
	enum XML_Error result = storeAtts(parser, enc, s, 0, 0);
	if (result)
	  return result;
      }
      /* fall through */
    case XML_TOK_EMPTY_ELEMENT_NO_ATTS:
      if (startElementHandler || endElementHandler) {
	const char *rawName = s + enc->minBytesPerChar;
	enum XML_Error result;
	BINDING *bindings = 0;
	TAG_NAME name;
	name.str = poolStoreString(&tempPool, enc, rawName,
				   rawName + XmlNameLength(enc, rawName));
	if (!name.str)
	  return XML_ERROR_NO_MEMORY;
	poolFinish(&tempPool);
	result = storeAtts(parser, enc, s, &name, &bindings);
	if (result)
	  return result;
	poolFinish(&tempPool);
	if (startElementHandler)
	  startElementHandler(handlerArg, name.str, (const XML_Char **)atts);
	if (endElementHandler) {
	  if (startElementHandler)
	    *eventPP = *eventEndPP;
	  endElementHandler(handlerArg, name.str);
	}
	poolClear(&tempPool);
	while (bindings) {
	  BINDING *b = bindings;
	  if (endNamespaceDeclHandler)
	    endNamespaceDeclHandler(handlerArg, b->prefix->name);
	  bindings = bindings->nextTagBinding;
	  b->nextTagBinding = freeBindingList;
	  freeBindingList = b;
	  b->prefix->binding = b->prevPrefixBinding;
	}
      }
      else if (defaultHandler)
	reportDefault(parser, enc, s, next);
      if (tagLevel == 0)
	return epilogProcessor(parser, next, end, nextPtr);
      break;
    case XML_TOK_END_TAG:
      if (tagLevel == startTagLevel)
        return XML_ERROR_ASYNC_ENTITY;
      else {
	int len;
	const char *rawName;
	TAG *tag = tagStack;
	tagStack = tag->parent;
	tag->parent = freeTagList;
	freeTagList = tag;
	rawName = s + enc->minBytesPerChar*2;
	len = XmlNameLength(enc, rawName);
	if (len != tag->rawNameLength
	    || memcmp(tag->rawName, rawName, len) != 0) {
	  *eventPP = rawName;
	  return XML_ERROR_TAG_MISMATCH;
	}
	--tagLevel;
	if (endElementHandler && tag->name.str) {
	  if (tag->name.localPart) {
	    XML_Char *to = (XML_Char *)tag->name.str + tag->name.uriLen;
	    const XML_Char *from = tag->name.localPart;
	    while ((*to++ = *from++) != 0)
	      ;
	  }
	  endElementHandler(handlerArg, tag->name.str);
	}
	else if (defaultHandler)
	  reportDefault(parser, enc, s, next);
	while (tag->bindings) {
	  BINDING *b = tag->bindings;
	  if (endNamespaceDeclHandler)
	    endNamespaceDeclHandler(handlerArg, b->prefix->name);
	  tag->bindings = tag->bindings->nextTagBinding;
	  b->nextTagBinding = freeBindingList;
	  freeBindingList = b;
	  b->prefix->binding = b->prevPrefixBinding;
	}
	if (tagLevel == 0)
	  return epilogProcessor(parser, next, end, nextPtr);
      }
      break;
    case XML_TOK_CHAR_REF:
      {
	int n = XmlCharRefNumber(enc, s);
	if (n < 0)
	  return XML_ERROR_BAD_CHAR_REF;
	if (characterDataHandler) {
	  XML_Char buf[XML_ENCODE_MAX];
	  characterDataHandler(handlerArg, buf, XmlEncode(n, (ICHAR *)buf));
	}
	else if (defaultHandler)
	  reportDefault(parser, enc, s, next);
      }
      break;
    case XML_TOK_XML_DECL:
      return XML_ERROR_MISPLACED_XML_PI;
    case XML_TOK_DATA_NEWLINE:
      if (characterDataHandler) {
	XML_Char c = 0xA;
	characterDataHandler(handlerArg, &c, 1);
      }
      else if (defaultHandler)
	reportDefault(parser, enc, s, next);
      break;
    case XML_TOK_CDATA_SECT_OPEN:
      {
	enum XML_Error result;
	if (startCdataSectionHandler)
  	  startCdataSectionHandler(handlerArg);
#if 0
	/* Suppose you doing a transformation on a document that involves
	   changing only the character data.  You set up a defaultHandler
	   and a characterDataHandler.  The defaultHandler simply copies
	   characters through.  The characterDataHandler does the transformation
	   and writes the characters out escaping them as necessary.  This case
	   will fail to work if we leave out the following two lines (because &
	   and < inside CDATA sections will be incorrectly escaped).

	   However, now we have a start/endCdataSectionHandler, so it seems
	   easier to let the user deal with this. */

	else if (characterDataHandler)
  	  characterDataHandler(handlerArg, dataBuf, 0);
#endif
	else if (defaultHandler)
	  reportDefault(parser, enc, s, next);
	result = doCdataSection(parser, enc, &next, end, nextPtr);
	if (!next) {
	  processor = cdataSectionProcessor;
	  return result;
	}
      }
      break;
    case XML_TOK_TRAILING_RSQB:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      if (characterDataHandler) {
	if (MUST_CONVERT(enc, s)) {
	  ICHAR *dataPtr = (ICHAR *)dataBuf;
	  XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)dataBufEnd);
	  characterDataHandler(handlerArg, dataBuf, dataPtr - (ICHAR *)dataBuf);
	}
	else
	  characterDataHandler(handlerArg,
		  	       (XML_Char *)s,
			       (XML_Char *)end - (XML_Char *)s);
      }
      else if (defaultHandler)
	reportDefault(parser, enc, s, end);
      if (startTagLevel == 0) {
        *eventPP = end;
	return XML_ERROR_NO_ELEMENTS;
      }
      if (tagLevel != startTagLevel) {
	*eventPP = end;
	return XML_ERROR_ASYNC_ENTITY;
      }
      return XML_ERROR_NONE;
    case XML_TOK_DATA_CHARS:
      if (characterDataHandler) {
	if (MUST_CONVERT(enc, s)) {
	  for (;;) {
	    ICHAR *dataPtr = (ICHAR *)dataBuf;
	    XmlConvert(enc, &s, next, &dataPtr, (ICHAR *)dataBufEnd);
	    *eventEndPP = s;
	    characterDataHandler(handlerArg, dataBuf, dataPtr - (ICHAR *)dataBuf);
	    if (s == next)
	      break;
	    *eventPP = s;
	  }
	}
	else
	  characterDataHandler(handlerArg,
			       (XML_Char *)s,
			       (XML_Char *)next - (XML_Char *)s);
      }
      else if (defaultHandler)
	reportDefault(parser, enc, s, next);
      break;
    case XML_TOK_PI:
      if (!reportProcessingInstruction(parser, enc, s, next))
	return XML_ERROR_NO_MEMORY;
      break;
    case XML_TOK_COMMENT:
      if (!reportComment(parser, enc, s, next))
	return XML_ERROR_NO_MEMORY;
      break;
    default:
      if (defaultHandler)
	reportDefault(parser, enc, s, next);
      break;
    }
    *eventPP = s = next;
  }
  /* not reached */
}

/* If tagNamePtr is non-null, build a real list of attributes,
otherwise just check the attributes for well-formedness. */

static enum XML_Error storeAtts(XML_Parser parser, const ENCODING *enc,
				const char *attStr, TAG_NAME *tagNamePtr,
				BINDING **bindingsPtr)
{
  ELEMENT_TYPE *elementType = 0;
  int nDefaultAtts = 0;
  const XML_Char **appAtts;   /* the attribute list to pass to the application */
  int attIndex = 0;
  int i;
  int n;
  int nPrefixes = 0;
  BINDING *binding;
  const XML_Char *localPart;

  /* lookup the element type name */
  if (tagNamePtr) {
    elementType = (ELEMENT_TYPE *)lookup(&dtd.elementTypes, tagNamePtr->str,0);
    if (!elementType) {
      tagNamePtr->str = poolCopyString(&dtd.pool, tagNamePtr->str);
      if (!tagNamePtr->str)
	return XML_ERROR_NO_MEMORY;
      elementType = (ELEMENT_TYPE *)lookup(&dtd.elementTypes, tagNamePtr->str, sizeof(ELEMENT_TYPE));
      if (!elementType)
        return XML_ERROR_NO_MEMORY;
      if (ns && !setElementTypePrefix(parser, elementType))
        return XML_ERROR_NO_MEMORY;
    }
    nDefaultAtts = elementType->nDefaultAtts;
  }
  /* get the attributes from the tokenizer */
  n = XmlGetAttributes(enc, attStr, attsSize, atts);
  if (n + nDefaultAtts > attsSize) {
    int oldAttsSize = attsSize;
    attsSize = n + nDefaultAtts + INIT_ATTS_SIZE;
    atts = REALLOC((void *)atts, attsSize * sizeof(ATTRIBUTE));
    if (!atts)
      return XML_ERROR_NO_MEMORY;
    if (n > oldAttsSize)
      XmlGetAttributes(enc, attStr, n, atts);
  }
  appAtts = (const XML_Char **)atts;
  for (i = 0; i < n; i++) {
    /* add the name and value to the attribute list */
    ATTRIBUTE_ID *attId = getAttributeId(parser, enc, atts[i].name,
					 atts[i].name
					 + XmlNameLength(enc, atts[i].name));
    if (!attId)
      return XML_ERROR_NO_MEMORY;
    /* detect duplicate attributes */
    if ((attId->name)[-1]) {
      if (enc == encoding)
	eventPtr = atts[i].name;
      return XML_ERROR_DUPLICATE_ATTRIBUTE;
    }
    (attId->name)[-1] = 1;
    appAtts[attIndex++] = attId->name;
    if (!atts[i].normalized) {
      enum XML_Error result;
      int isCdata = 1;

      /* figure out whether declared as other than CDATA */
      if (attId->maybeTokenized) {
	int j;
	for (j = 0; j < nDefaultAtts; j++) {
	  if (attId == elementType->defaultAtts[j].id) {
	    isCdata = elementType->defaultAtts[j].isCdata;
	    break;
	  }
	}
      }

      /* normalize the attribute value */
      result = storeAttributeValue(parser, enc, isCdata,
				   atts[i].valuePtr, atts[i].valueEnd,
			           &tempPool);
      if (result)
	return result;
      if (tagNamePtr) {
	appAtts[attIndex] = poolStart(&tempPool);
	poolFinish(&tempPool);
      }
      else
	poolDiscard(&tempPool);
    }
    else if (tagNamePtr) {
      /* the value did not need normalizing */
      appAtts[attIndex] = poolStoreString(&tempPool, enc, atts[i].valuePtr, atts[i].valueEnd);
      if (appAtts[attIndex] == 0)
	return XML_ERROR_NO_MEMORY;
      poolFinish(&tempPool);
    }
    /* handle prefixed attribute names */
    if (attId->prefix && tagNamePtr) {
      if (attId->xmlns) {
	/* deal with namespace declarations here */
        if (!addBinding(parser, attId->prefix, attId, appAtts[attIndex], bindingsPtr))
          return XML_ERROR_NO_MEMORY;
        --attIndex;
      }
      else {
	/* deal with other prefixed names later */
        attIndex++;
        nPrefixes++;
        (attId->name)[-1] = 2;
      }
    }
    else
      attIndex++;
  }
  if (tagNamePtr) {
    int j;
    nSpecifiedAtts = attIndex;
    if (elementType->idAtt && (elementType->idAtt->name)[-1]) {
      for (i = 0; i < attIndex; i += 2)
	if (appAtts[i] == elementType->idAtt->name) {
	  idAttIndex = i;
	  break;
	}
    }
    else
      idAttIndex = -1;
    /* do attribute defaulting */
    for (j = 0; j < nDefaultAtts; j++) {
      const DEFAULT_ATTRIBUTE *da = elementType->defaultAtts + j;
      if (!(da->id->name)[-1] && da->value) {
        if (da->id->prefix) {
          if (da->id->xmlns) {
	    if (!addBinding(parser, da->id->prefix, da->id, da->value, bindingsPtr))
	      return XML_ERROR_NO_MEMORY;
	  }
          else {
	    (da->id->name)[-1] = 2;
	    nPrefixes++;
  	    appAtts[attIndex++] = da->id->name;
	    appAtts[attIndex++] = da->value;
	  }
	}
	else {
	  (da->id->name)[-1] = 1;
	  appAtts[attIndex++] = da->id->name;
	  appAtts[attIndex++] = da->value;
	}
      }
    }
    appAtts[attIndex] = 0;
  }
  i = 0;
  if (nPrefixes) {
    /* expand prefixed attribute names */
    for (; i < attIndex; i += 2) {
      if (appAtts[i][-1] == 2) {
        ATTRIBUTE_ID *id;
        ((XML_Char *)(appAtts[i]))[-1] = 0;
	id = (ATTRIBUTE_ID *)lookup(&dtd.attributeIds, appAtts[i], 0);
	if (id->prefix->binding) {
	  int j;
	  const BINDING *b = id->prefix->binding;
	  const XML_Char *s = appAtts[i];
	  for (j = 0; j < b->uriLen; j++) {
	    if (!poolAppendChar(&tempPool, b->uri[j]))
	      return XML_ERROR_NO_MEMORY;
	  }
	  while (*s++ != ':')
	    ;
	  do {
	    if (!poolAppendChar(&tempPool, *s))
	      return XML_ERROR_NO_MEMORY;
	  } while (*s++);
	  if (ns_triplets) {
	    tempPool.ptr[-1] = namespaceSeparator;
	    s = b->prefix->name;
	    do {
	      if (!poolAppendChar(&tempPool, *s))
		return XML_ERROR_NO_MEMORY;
	    } while (*s++);
	  }

	  appAtts[i] = poolStart(&tempPool);
	  poolFinish(&tempPool);
	}
	if (!--nPrefixes)
	  break;
      }
      else
	((XML_Char *)(appAtts[i]))[-1] = 0;
    }
  }
  /* clear the flags that say whether attributes were specified */
  for (; i < attIndex; i += 2)
    ((XML_Char *)(appAtts[i]))[-1] = 0;
  if (!tagNamePtr)
    return XML_ERROR_NONE;
  for (binding = *bindingsPtr; binding; binding = binding->nextTagBinding)
    binding->attId->name[-1] = 0;
  /* expand the element type name */
  if (elementType->prefix) {
    binding = elementType->prefix->binding;
    if (!binding)
      return XML_ERROR_NONE;
    localPart = tagNamePtr->str;
    while (*localPart++ != XML_T(':'))
      ;
  }
  else if (dtd.defaultPrefix.binding) {
    binding = dtd.defaultPrefix.binding;
    localPart = tagNamePtr->str;
  }
  else
    return XML_ERROR_NONE;
  tagNamePtr->localPart = localPart;
  tagNamePtr->uriLen = binding->uriLen;
  for (i = 0; localPart[i++];)
    ;
  n = i + binding->uriLen;
  if (n > binding->uriAlloc) {
    TAG *p;
    XML_Char *uri = MALLOC((n + EXPAND_SPARE) * sizeof(XML_Char));
    if (!uri)
      return XML_ERROR_NO_MEMORY;
    binding->uriAlloc = n + EXPAND_SPARE;
    memcpy(uri, binding->uri, binding->uriLen * sizeof(XML_Char));
    for (p = tagStack; p; p = p->parent)
      if (p->name.str == binding->uri)
	p->name.str = uri;
    FREE(binding->uri);
    binding->uri = uri;
  }
  memcpy(binding->uri + binding->uriLen, localPart, i * sizeof(XML_Char));
  tagNamePtr->str = binding->uri;
  return XML_ERROR_NONE;
}

static
int addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId, const XML_Char *uri, BINDING **bindingsPtr)
{
  BINDING *b;
  int len;
  for (len = 0; uri[len]; len++)
    ;
  if (namespaceSeparator)
    len++;
  if (freeBindingList) {
    b = freeBindingList;
    if (len > b->uriAlloc) {
      b->uri = REALLOC(b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));
      if (!b->uri)
	return 0;
      b->uriAlloc = len + EXPAND_SPARE;
    }
    freeBindingList = b->nextTagBinding;
  }
  else {
    b = MALLOC(sizeof(BINDING));
    if (!b)
      return 0;
    b->uri = MALLOC(sizeof(XML_Char) * (len + EXPAND_SPARE));
    if (!b->uri) {
      FREE(b);
      return 0;
    }
    b->uriAlloc = len + EXPAND_SPARE;
  }
  b->uriLen = len;
  memcpy(b->uri, uri, len * sizeof(XML_Char));
  if (namespaceSeparator)
    b->uri[len - 1] = namespaceSeparator;
  b->prefix = prefix;
  b->attId = attId;
  b->prevPrefixBinding = prefix->binding;
  if (*uri == XML_T('\0') && prefix == &dtd.defaultPrefix)
    prefix->binding = 0;
  else
    prefix->binding = b;
  b->nextTagBinding = *bindingsPtr;
  *bindingsPtr = b;
  if (startNamespaceDeclHandler)
    startNamespaceDeclHandler(handlerArg, prefix->name,
			      prefix->binding ? uri : 0);
  return 1;
}

/* The idea here is to avoid using stack for each CDATA section when
the whole file is parsed with one call. */

static
enum XML_Error cdataSectionProcessor(XML_Parser parser,
				     const char *start,
			    	     const char *end,
				     const char **endPtr)
{
  enum XML_Error result = doCdataSection(parser, encoding, &start, end, endPtr);
  if (start) {
    processor = contentProcessor;
    return contentProcessor(parser, start, end, endPtr);
  }
  return result;
}

/* startPtr gets set to non-null is the section is closed, and to null if
the section is not yet closed. */

static
enum XML_Error doCdataSection(XML_Parser parser,
			      const ENCODING *enc,
			      const char **startPtr,
			      const char *end,
			      const char **nextPtr)
{
  const char *s = *startPtr;
  const char **eventPP;
  const char **eventEndPP;
  if (enc == encoding) {
    eventPP = &eventPtr;
    *eventPP = s;
    eventEndPP = &eventEndPtr;
  }
  else {
    eventPP = &(openInternalEntities->internalEventPtr);
    eventEndPP = &(openInternalEntities->internalEventEndPtr);
  }
  *eventPP = s;
  *startPtr = 0;
  for (;;) {
    const char *next;
    int tok = XmlCdataSectionTok(enc, s, end, &next);
    *eventEndPP = next;
    switch (tok) {
    case XML_TOK_CDATA_SECT_CLOSE:
      if (endCdataSectionHandler)
	endCdataSectionHandler(handlerArg);
#if 0
      /* see comment under XML_TOK_CDATA_SECT_OPEN */
      else if (characterDataHandler)
	characterDataHandler(handlerArg, dataBuf, 0);
#endif
      else if (defaultHandler)
	reportDefault(parser, enc, s, next);
      *startPtr = next;
      return XML_ERROR_NONE;
    case XML_TOK_DATA_NEWLINE:
      if (characterDataHandler) {
	XML_Char c = 0xA;
	characterDataHandler(handlerArg, &c, 1);
      }
      else if (defaultHandler)
	reportDefault(parser, enc, s, next);
      break;
    case XML_TOK_DATA_CHARS:
      if (characterDataHandler) {
	if (MUST_CONVERT(enc, s)) {
	  for (;;) {
  	    ICHAR *dataPtr = (ICHAR *)dataBuf;
	    XmlConvert(enc, &s, next, &dataPtr, (ICHAR *)dataBufEnd);
	    *eventEndPP = next;
	    characterDataHandler(handlerArg, dataBuf, dataPtr - (ICHAR *)dataBuf);
	    if (s == next)
	      break;
	    *eventPP = s;
	  }
	}
	else
	  characterDataHandler(handlerArg,
		  	       (XML_Char *)s,
			       (XML_Char *)next - (XML_Char *)s);
      }
      else if (defaultHandler)
	reportDefault(parser, enc, s, next);
      break;
    case XML_TOK_INVALID:
      *eventPP = next;
      return XML_ERROR_INVALID_TOKEN;
    case XML_TOK_PARTIAL_CHAR:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      return XML_ERROR_PARTIAL_CHAR;
    case XML_TOK_PARTIAL:
    case XML_TOK_NONE:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      return XML_ERROR_UNCLOSED_CDATA_SECTION;
    default:
      *eventPP = next;
      return XML_ERROR_UNEXPECTED_STATE;
    }
    *eventPP = s = next;
  }
  /* not reached */
}

#ifdef XML_DTD

/* The idea here is to avoid using stack for each IGNORE section when
the whole file is parsed with one call. */

static
enum XML_Error ignoreSectionProcessor(XML_Parser parser,
				      const char *start,
				      const char *end,
				      const char **endPtr)
{
  enum XML_Error result = doIgnoreSection(parser, encoding, &start, end, endPtr);
  if (start) {
    processor = prologProcessor;
    return prologProcessor(parser, start, end, endPtr);
  }
  return result;
}

/* startPtr gets set to non-null is the section is closed, and to null if
the section is not yet closed. */

static
enum XML_Error doIgnoreSection(XML_Parser parser,
			       const ENCODING *enc,
			       const char **startPtr,
			       const char *end,
			       const char **nextPtr)
{
  const char *next;
  int tok;
  const char *s = *startPtr;
  const char **eventPP;
  const char **eventEndPP;
  if (enc == encoding) {
    eventPP = &eventPtr;
    *eventPP = s;
    eventEndPP = &eventEndPtr;
  }
  else {
    eventPP = &(openInternalEntities->internalEventPtr);
    eventEndPP = &(openInternalEntities->internalEventEndPtr);
  }
  *eventPP = s;
  *startPtr = 0;
  tok = XmlIgnoreSectionTok(enc, s, end, &next);
  *eventEndPP = next;
  switch (tok) {
  case XML_TOK_IGNORE_SECT:
    if (defaultHandler)
      reportDefault(parser, enc, s, next);
    *startPtr = next;
    return XML_ERROR_NONE;
  case XML_TOK_INVALID:
    *eventPP = next;
    return XML_ERROR_INVALID_TOKEN;
  case XML_TOK_PARTIAL_CHAR:
    if (nextPtr) {
      *nextPtr = s;
      return XML_ERROR_NONE;
    }
    return XML_ERROR_PARTIAL_CHAR;
  case XML_TOK_PARTIAL:
  case XML_TOK_NONE:
    if (nextPtr) {
      *nextPtr = s;
      return XML_ERROR_NONE;
    }
    return XML_ERROR_SYNTAX; /* XML_ERROR_UNCLOSED_IGNORE_SECTION */
  default:
    *eventPP = next;
    return XML_ERROR_UNEXPECTED_STATE;
  }
  /* not reached */
}

#endif /* XML_DTD */

static enum XML_Error
initializeEncoding(XML_Parser parser)
{
  const char *s;
#ifdef XML_UNICODE
  char encodingBuf[128];
  if (!protocolEncodingName)
    s = 0;
  else {
    int i;
    for (i = 0; protocolEncodingName[i]; i++) {
      if (i == sizeof(encodingBuf) - 1
	  || (protocolEncodingName[i] & ~0x7f) != 0) {
	encodingBuf[0] = '\0';
	break;
      }
      encodingBuf[i] = (char)protocolEncodingName[i];
    }
    encodingBuf[i] = '\0';
    s = encodingBuf;
  }
#else
  s = protocolEncodingName;
#endif
  if ((ns ? XmlInitEncodingNS : XmlInitEncoding)(&initEncoding, &encoding, s))
    return XML_ERROR_NONE;
  return handleUnknownEncoding(parser, protocolEncodingName);
}

static enum XML_Error
processXmlDecl(XML_Parser parser, int isGeneralTextEntity,
	       const char *s, const char *next)
{
  const char *encodingName = 0;
  const char *storedEncName = 0;
  const ENCODING *newEncoding = 0;
  const char *version = 0;
  const char *versionend;
  const char *storedversion = 0;
  int standalone = -1;
  if (!(ns
        ? XmlParseXmlDeclNS
	: XmlParseXmlDecl)(isGeneralTextEntity,
		           encoding,
		           s,
		           next,
		           &eventPtr,
		           &version,
			   &versionend,
		           &encodingName,
		           &newEncoding,
		           &standalone))
    return XML_ERROR_SYNTAX;
  if (!isGeneralTextEntity && standalone == 1) {
    dtd.standalone = 1;
#ifdef XML_DTD
    if (paramEntityParsing == XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE)
      paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;
#endif /* XML_DTD */
  }
  if (xmlDeclHandler) {
    if (encodingName) {
      storedEncName = poolStoreString(&temp2Pool,
				      encoding,
				      encodingName,
				      encodingName
				      + XmlNameLength(encoding, encodingName));
      if (! storedEncName)
	return XML_ERROR_NO_MEMORY;
      poolFinish(&temp2Pool);
    }
    if (version) {
      storedversion = poolStoreString(&temp2Pool,
				      encoding,
				      version,
				      versionend - encoding->minBytesPerChar);
      if (! storedversion)
	return XML_ERROR_NO_MEMORY;
    }
    xmlDeclHandler(handlerArg, storedversion, storedEncName, standalone);
  }
  else if (defaultHandler)
    reportDefault(parser, encoding, s, next);
  if (!protocolEncodingName) {
    if (newEncoding) {
      if (newEncoding->minBytesPerChar != encoding->minBytesPerChar) {
	eventPtr = encodingName;
	return XML_ERROR_INCORRECT_ENCODING;
      }
      encoding = newEncoding;
    }
    else if (encodingName) {
      enum XML_Error result;
      if (! storedEncName) {
	storedEncName = poolStoreString(&temp2Pool,
					encoding,
					encodingName,
					encodingName
					+ XmlNameLength(encoding, encodingName));
	if (! storedEncName)
	  return XML_ERROR_NO_MEMORY;
      }
      result = handleUnknownEncoding(parser, storedEncName);
      poolClear(&tempPool);
      if (result == XML_ERROR_UNKNOWN_ENCODING)
	eventPtr = encodingName;
      return result;
    }
  }

  if (storedEncName || storedversion)
    poolClear(&temp2Pool);

  return XML_ERROR_NONE;
}

static enum XML_Error
handleUnknownEncoding(XML_Parser parser, const XML_Char *encodingName)
{
  if (unknownEncodingHandler) {
    XML_Encoding info;
    int i;
    for (i = 0; i < 256; i++)
      info.map[i] = -1;
    info.convert = 0;
    info.data = 0;
    info.release = 0;
    if (unknownEncodingHandler(unknownEncodingHandlerData, encodingName, &info)) {
      ENCODING *enc;
      unknownEncodingMem = MALLOC(XmlSizeOfUnknownEncoding());
      if (!unknownEncodingMem) {
	if (info.release)
	  info.release(info.data);
	return XML_ERROR_NO_MEMORY;
      }
      enc = (ns
	     ? XmlInitUnknownEncodingNS
	     : XmlInitUnknownEncoding)(unknownEncodingMem,
				       info.map,
				       info.convert,
				       info.data);
      if (enc) {
	unknownEncodingData = info.data;
	unknownEncodingRelease = info.release;
	encoding = enc;
	return XML_ERROR_NONE;
      }
    }
    if (info.release)
      info.release(info.data);
  }
  return XML_ERROR_UNKNOWN_ENCODING;
}

static enum XML_Error
prologInitProcessor(XML_Parser parser,
		    const char *s,
		    const char *end,
		    const char **nextPtr)
{
  enum XML_Error result = initializeEncoding(parser);
  if (result != XML_ERROR_NONE)
    return result;
  processor = prologProcessor;
  return prologProcessor(parser, s, end, nextPtr);
}

static enum XML_Error
prologProcessor(XML_Parser parser,
		const char *s,
		const char *end,
		const char **nextPtr)
{
  const char *next;
  int tok = XmlPrologTok(encoding, s, end, &next);
  return doProlog(parser, encoding, s, end, tok, next, nextPtr);
}

static enum XML_Error
doProlog(XML_Parser parser,
	 const ENCODING *enc,
	 const char *s,
	 const char *end,
	 int tok,
	 const char *next,
	 const char **nextPtr)
{
#ifdef XML_DTD
  static const XML_Char externalSubsetName[] = { '#' , '\0' };
#endif /* XML_DTD */

  const char **eventPP;
  const char **eventEndPP;
  enum XML_Content_Quant quant;

  if (enc == encoding) {
    eventPP = &eventPtr;
    eventEndPP = &eventEndPtr;
  }
  else {
    eventPP = &(openInternalEntities->internalEventPtr);
    eventEndPP = &(openInternalEntities->internalEventEndPtr);
  }
  for (;;) {
    int role;
    *eventPP = s;
    *eventEndPP = next;
    if (tok <= 0) {
      if (nextPtr != 0 && tok != XML_TOK_INVALID) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      switch (tok) {
      case XML_TOK_INVALID:
	*eventPP = next;
	return XML_ERROR_INVALID_TOKEN;
      case XML_TOK_PARTIAL:
	return XML_ERROR_UNCLOSED_TOKEN;
      case XML_TOK_PARTIAL_CHAR:
	return XML_ERROR_PARTIAL_CHAR;
      case XML_TOK_NONE:
#ifdef XML_DTD
	if (enc != encoding)
	  return XML_ERROR_NONE;
	if (parentParser) {
	  if (XmlTokenRole(&prologState, XML_TOK_NONE, end, end, enc)
	      == XML_ROLE_ERROR)
	    return XML_ERROR_SYNTAX;
	  hadExternalDoctype = 0;
	  return XML_ERROR_NONE;
	}
#endif /* XML_DTD */
	return XML_ERROR_NO_ELEMENTS;
      default:
	tok = -tok;
	next = end;
	break;
      }
    }
    role = XmlTokenRole(&prologState, tok, s, next, enc);
    switch (role) {
    case XML_ROLE_XML_DECL:
      {
	enum XML_Error result = processXmlDecl(parser, 0, s, next);
	if (result != XML_ERROR_NONE)
	  return result;
	enc = encoding;
      }
      break;
    case XML_ROLE_DOCTYPE_NAME:
      if (startDoctypeDeclHandler) {
	doctypeName = poolStoreString(&tempPool, enc, s, next);
	if (! doctypeName)
	  return XML_ERROR_NO_MEMORY;
	poolFinish(&tempPool);
	doctypeSysid = 0;
	doctypePubid = 0;
      }
      break;
    case XML_ROLE_DOCTYPE_INTERNAL_SUBSET:
      if (startDoctypeDeclHandler) {
	startDoctypeDeclHandler(handlerArg, doctypeName, doctypeSysid,
				doctypePubid, 1);
	doctypeName = 0;
	poolClear(&tempPool);
      }
      break;
#ifdef XML_DTD
    case XML_ROLE_TEXT_DECL:
      {
	enum XML_Error result = processXmlDecl(parser, 1, s, next);
	if (result != XML_ERROR_NONE)
	  return result;
	enc = encoding;
      }
      break;
#endif /* XML_DTD */
    case XML_ROLE_DOCTYPE_PUBLIC_ID:
      if (startDoctypeDeclHandler) {
	doctypePubid = poolStoreString(&tempPool, enc, s + 1, next - 1);
	if (! doctypePubid)
	  return XML_ERROR_NO_MEMORY;
	poolFinish(&tempPool);
      }
#ifdef XML_DTD
      declEntity = (ENTITY *)lookup(&dtd.paramEntities,
				    externalSubsetName,
				    sizeof(ENTITY));
      if (!declEntity)
	return XML_ERROR_NO_MEMORY;
#endif /* XML_DTD */
      /* fall through */
    case XML_ROLE_ENTITY_PUBLIC_ID:
      if (!XmlIsPublicId(enc, s, next, eventPP))
	return XML_ERROR_SYNTAX;
      if (declEntity) {
	XML_Char *tem = poolStoreString(&dtd.pool,
	                                enc,
					s + enc->minBytesPerChar,
	  				next - enc->minBytesPerChar);
	if (!tem)
	  return XML_ERROR_NO_MEMORY;
	normalizePublicId(tem);
	declEntity->publicId = tem;
	poolFinish(&dtd.pool);
      }
      break;
    case XML_ROLE_DOCTYPE_CLOSE:
      if (doctypeName) {
	startDoctypeDeclHandler(handlerArg, doctypeName,
				doctypeSysid, doctypePubid, 0);
	poolClear(&tempPool);
      }
      if (dtd.complete && hadExternalDoctype) {
	dtd.complete = 0;
#ifdef XML_DTD
	if (paramEntityParsing && externalEntityRefHandler) {
	  ENTITY *entity = (ENTITY *)lookup(&dtd.paramEntities,
					    externalSubsetName,
					    0);
	  if (!externalEntityRefHandler(externalEntityRefHandlerArg,
					0,
					entity->base,
					entity->systemId,
					entity->publicId))
	   return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
	}
#endif /* XML_DTD */
	if (!dtd.complete
	    && !dtd.standalone
	    && notStandaloneHandler
	    && !notStandaloneHandler(handlerArg))
	  return XML_ERROR_NOT_STANDALONE;
      }
      if (endDoctypeDeclHandler)
	endDoctypeDeclHandler(handlerArg);
      break;
    case XML_ROLE_INSTANCE_START:
      processor = contentProcessor;
      return contentProcessor(parser, s, end, nextPtr);
    case XML_ROLE_ATTLIST_ELEMENT_NAME:
      declElementType = getElementType(parser, enc, s, next);
      if (!declElementType)
	return XML_ERROR_NO_MEMORY;
      break;
    case XML_ROLE_ATTRIBUTE_NAME:
      declAttributeId = getAttributeId(parser, enc, s, next);
      if (!declAttributeId)
	return XML_ERROR_NO_MEMORY;
      declAttributeIsCdata = 0;
      declAttributeType = 0;
      declAttributeIsId = 0;
      break;
    case XML_ROLE_ATTRIBUTE_TYPE_CDATA:
      declAttributeIsCdata = 1;
      declAttributeType = "CDATA";
      break;
    case XML_ROLE_ATTRIBUTE_TYPE_ID:
      declAttributeIsId = 1;
      declAttributeType = "ID";
      break;
    case XML_ROLE_ATTRIBUTE_TYPE_IDREF:
      declAttributeType = "IDREF";
      break;
    case XML_ROLE_ATTRIBUTE_TYPE_IDREFS:
      declAttributeType = "IDREFS";
      break;
    case XML_ROLE_ATTRIBUTE_TYPE_ENTITY:
      declAttributeType = "ENTITY";
      break;
    case XML_ROLE_ATTRIBUTE_TYPE_ENTITIES:
      declAttributeType = "ENTITIES";
      break;
    case XML_ROLE_ATTRIBUTE_TYPE_NMTOKEN:
      declAttributeType = "NMTOKEN";
      break;
    case XML_ROLE_ATTRIBUTE_TYPE_NMTOKENS:
      declAttributeType = "NMTOKENS";
      break;

    case XML_ROLE_ATTRIBUTE_ENUM_VALUE:
    case XML_ROLE_ATTRIBUTE_NOTATION_VALUE:
      if (attlistDeclHandler)
      {
	char *prefix;
	if (declAttributeType) {
	  prefix = "|";
	}
	else {
	  prefix = (role == XML_ROLE_ATTRIBUTE_NOTATION_VALUE
		    ? "NOTATION("
		    : "(");
	}
	if (! poolAppendString(&tempPool, prefix))
	  return XML_ERROR_NO_MEMORY;
	if (! poolAppend(&tempPool, enc, s, next))
	  return XML_ERROR_NO_MEMORY;
	declAttributeType = tempPool.start;
      }
      break;
    case XML_ROLE_IMPLIED_ATTRIBUTE_VALUE:
    case XML_ROLE_REQUIRED_ATTRIBUTE_VALUE:
      if (dtd.complete
	  && !defineAttribute(declElementType, declAttributeId,
			      declAttributeIsCdata, declAttributeIsId, 0,
			      parser))
	return XML_ERROR_NO_MEMORY;
      if (attlistDeclHandler && declAttributeType) {
	if (*declAttributeType == '('
	    || (*declAttributeType == 'N' && declAttributeType[1] == 'O')) {
	  /* Enumerated or Notation type */
	  if (! poolAppendChar(&tempPool, ')')
	      || ! poolAppendChar(&tempPool, '\0'))
	    return XML_ERROR_NO_MEMORY;
	  declAttributeType = tempPool.start;
	  poolFinish(&tempPool);
	}
	*eventEndPP = s;
	attlistDeclHandler(handlerArg, declElementType->name,
			   declAttributeId->name, declAttributeType,
			   0, role == XML_ROLE_REQUIRED_ATTRIBUTE_VALUE);
	poolClear(&tempPool);
      }
      break;
    case XML_ROLE_DEFAULT_ATTRIBUTE_VALUE:
    case XML_ROLE_FIXED_ATTRIBUTE_VALUE:
      {
	const XML_Char *attVal;
	enum XML_Error result
	  = storeAttributeValue(parser, enc, declAttributeIsCdata,
				s + enc->minBytesPerChar,
			        next - enc->minBytesPerChar,
			        &dtd.pool);
	if (result)
	  return result;
	attVal = poolStart(&dtd.pool);
	poolFinish(&dtd.pool);
	if (dtd.complete
	    /* ID attributes aren't allowed to have a default */
	    && !defineAttribute(declElementType, declAttributeId, declAttributeIsCdata, 0, attVal, parser))
	  return XML_ERROR_NO_MEMORY;
	if (attlistDeclHandler && declAttributeType) {
	  if (*declAttributeType == '('
	      || (*declAttributeType == 'N' && declAttributeType[1] == 'O')) {
	    /* Enumerated or Notation type */
	    if (! poolAppendChar(&tempPool, ')')
		|| ! poolAppendChar(&tempPool, '\0'))
	      return XML_ERROR_NO_MEMORY;
	    declAttributeType = tempPool.start;
	    poolFinish(&tempPool);
	  }
	  *eventEndPP = s;
	  attlistDeclHandler(handlerArg, declElementType->name,
			     declAttributeId->name, declAttributeType,
			     attVal,
			     role == XML_ROLE_FIXED_ATTRIBUTE_VALUE);
	  poolClear(&tempPool);
	}
	break;
      }
    case XML_ROLE_ENTITY_VALUE:
      {
	enum XML_Error result = storeEntityValue(parser, enc,
						 s + enc->minBytesPerChar,
						 next - enc->minBytesPerChar);
	if (declEntity) {
	  declEntity->textPtr = poolStart(&dtd.pool);
	  declEntity->textLen = poolLength(&dtd.pool);
	  poolFinish(&dtd.pool);
	  if (entityDeclHandler) {
	    *eventEndPP = s;
	    entityDeclHandler(handlerArg,
			      declEntity->name,
			      declEntity->is_param,
			      declEntity->textPtr,
			      declEntity->textLen,
			      curBase, 0, 0, 0);
	  }
	}
	else
	  poolDiscard(&dtd.pool);
	if (result != XML_ERROR_NONE)
	  return result;
      }
      break;
    case XML_ROLE_DOCTYPE_SYSTEM_ID:
      if (startDoctypeDeclHandler) {
	doctypeSysid = poolStoreString(&tempPool, enc, s + 1, next - 1);
	if (! doctypeSysid)
	  return XML_ERROR_NO_MEMORY;
	poolFinish(&tempPool);
      }
      if (!dtd.standalone
#ifdef XML_DTD
	  && !paramEntityParsing
#endif /* XML_DTD */
	  && notStandaloneHandler
	  && !notStandaloneHandler(handlerArg))
	return XML_ERROR_NOT_STANDALONE;
      hadExternalDoctype = 1;
#ifndef XML_DTD
      break;
#else /* XML_DTD */
      if (!declEntity) {
	declEntity = (ENTITY *)lookup(&dtd.paramEntities,
				      externalSubsetName,
				      sizeof(ENTITY));
	declEntity->publicId = 0;
	if (!declEntity)
	  return XML_ERROR_NO_MEMORY;
      }
      /* fall through */
#endif /* XML_DTD */
    case XML_ROLE_ENTITY_SYSTEM_ID:
      if (declEntity) {
	declEntity->systemId = poolStoreString(&dtd.pool, enc,
	                                       s + enc->minBytesPerChar,
	  				       next - enc->minBytesPerChar);
	if (!declEntity->systemId)
	  return XML_ERROR_NO_MEMORY;
	declEntity->base = curBase;
	poolFinish(&dtd.pool);
      }
      break;
    case XML_ROLE_ENTITY_COMPLETE:
      if (declEntity && entityDeclHandler) {
	*eventEndPP = s;
	entityDeclHandler(handlerArg,
			  declEntity->name,
			  0,0,0,
			  declEntity->base,
			  declEntity->systemId,
			  declEntity->publicId,
			  0);
      }
      break;
    case XML_ROLE_ENTITY_NOTATION_NAME:
      if (declEntity) {
	declEntity->notation = poolStoreString(&dtd.pool, enc, s, next);
	if (!declEntity->notation)
	  return XML_ERROR_NO_MEMORY;
	poolFinish(&dtd.pool);
	if (unparsedEntityDeclHandler) {
	  *eventEndPP = s;
	  unparsedEntityDeclHandler(handlerArg,
				    declEntity->name,
				    declEntity->base,
				    declEntity->systemId,
				    declEntity->publicId,
				    declEntity->notation);
	}
	else if (entityDeclHandler) {
	  *eventEndPP = s;
	  entityDeclHandler(handlerArg,
			    declEntity->name,
			    0,0,0,
			    declEntity->base,
			    declEntity->systemId,
			    declEntity->publicId,
			    declEntity->notation);
	}
      }
      break;
    case XML_ROLE_GENERAL_ENTITY_NAME:
      {
	const XML_Char *name;
	if (XmlPredefinedEntityName(enc, s, next)) {
	  declEntity = 0;
	  break;
	}
	name = poolStoreString(&dtd.pool, enc, s, next);
	if (!name)
	  return XML_ERROR_NO_MEMORY;
	if (dtd.complete) {
	  declEntity = (ENTITY *)lookup(&dtd.generalEntities, name, sizeof(ENTITY));
	  if (!declEntity)
	    return XML_ERROR_NO_MEMORY;
	  if (declEntity->name != name) {
	    poolDiscard(&dtd.pool);
	    declEntity = 0;
	  }
	  else {
	    poolFinish(&dtd.pool);
	    declEntity->publicId = 0;
	    declEntity->is_param = 0;
	  }
	}
	else {
	  poolDiscard(&dtd.pool);
	  declEntity = 0;
	}
      }
      break;
    case XML_ROLE_PARAM_ENTITY_NAME:
#ifdef XML_DTD
      if (dtd.complete) {
	const XML_Char *name = poolStoreString(&dtd.pool, enc, s, next);
	if (!name)
	  return XML_ERROR_NO_MEMORY;
	declEntity = (ENTITY *)lookup(&dtd.paramEntities,
				      name, sizeof(ENTITY));
	if (!declEntity)
	  return XML_ERROR_NO_MEMORY;
	if (declEntity->name != name) {
	  poolDiscard(&dtd.pool);
	  declEntity = 0;
	}
	else {
	  poolFinish(&dtd.pool);
	  declEntity->publicId = 0;
	  declEntity->is_param = 1;
	}
      }
#else /* not XML_DTD */
      declEntity = 0;
#endif /* not XML_DTD */
      break;
    case XML_ROLE_NOTATION_NAME:
      declNotationPublicId = 0;
      declNotationName = 0;
      if (notationDeclHandler) {
	declNotationName = poolStoreString(&tempPool, enc, s, next);
	if (!declNotationName)
	  return XML_ERROR_NO_MEMORY;
	poolFinish(&tempPool);
      }
      break;
    case XML_ROLE_NOTATION_PUBLIC_ID:
      if (!XmlIsPublicId(enc, s, next, eventPP))
	return XML_ERROR_SYNTAX;
      if (declNotationName) {
	XML_Char *tem = poolStoreString(&tempPool,
	                                enc,
					s + enc->minBytesPerChar,
	  				next - enc->minBytesPerChar);
	if (!tem)
	  return XML_ERROR_NO_MEMORY;
	normalizePublicId(tem);
	declNotationPublicId = tem;
	poolFinish(&tempPool);
      }
      break;
    case XML_ROLE_NOTATION_SYSTEM_ID:
      if (declNotationName && notationDeclHandler) {
	const XML_Char *systemId
	  = poolStoreString(&tempPool, enc,
			    s + enc->minBytesPerChar,
	  		    next - enc->minBytesPerChar);
	if (!systemId)
	  return XML_ERROR_NO_MEMORY;
	*eventEndPP = s;
	notationDeclHandler(handlerArg,
			    declNotationName,
			    curBase,
			    systemId,
			    declNotationPublicId);
      }
      poolClear(&tempPool);
      break;
    case XML_ROLE_NOTATION_NO_SYSTEM_ID:
      if (declNotationPublicId && notationDeclHandler) {
	*eventEndPP = s;
	notationDeclHandler(handlerArg,
			    declNotationName,
			    curBase,
			    0,
			    declNotationPublicId);
      }
      poolClear(&tempPool);
      break;
    case XML_ROLE_ERROR:
      switch (tok) {
      case XML_TOK_PARAM_ENTITY_REF:
	return XML_ERROR_PARAM_ENTITY_REF;
      case XML_TOK_XML_DECL:
	return XML_ERROR_MISPLACED_XML_PI;
      default:
	return XML_ERROR_SYNTAX;
      }
#ifdef XML_DTD
    case XML_ROLE_IGNORE_SECT:
      {
	enum XML_Error result;
	if (defaultHandler)
	  reportDefault(parser, enc, s, next);
	result = doIgnoreSection(parser, enc, &next, end, nextPtr);
	if (!next) {
	  processor = ignoreSectionProcessor;
	  return result;
	}
      }
      break;
#endif /* XML_DTD */
    case XML_ROLE_GROUP_OPEN:
      if (prologState.level >= groupSize) {
	if (groupSize) {
	  groupConnector = REALLOC(groupConnector, groupSize *= 2);
	  if (dtd.scaffIndex)
	    dtd.scaffIndex = REALLOC(dtd.scaffIndex, groupSize * sizeof(int));
	}
	else
	  groupConnector = MALLOC(groupSize = 32);
	if (!groupConnector)
	  return XML_ERROR_NO_MEMORY;
      }
      groupConnector[prologState.level] = 0;
      if (dtd.in_eldecl) {
	int myindex = nextScaffoldPart(parser);
	if (myindex < 0)
	  return XML_ERROR_NO_MEMORY;
	dtd.scaffIndex[dtd.scaffLevel] = myindex;
	dtd.scaffLevel++;
	dtd.scaffold[myindex].type = XML_CTYPE_SEQ;
      }
      break;
    case XML_ROLE_GROUP_SEQUENCE:
      if (groupConnector[prologState.level] == '|')
	return XML_ERROR_SYNTAX;
      groupConnector[prologState.level] = ',';
      break;
    case XML_ROLE_GROUP_CHOICE:
      if (groupConnector[prologState.level] == ',')
	return XML_ERROR_SYNTAX;
      if (dtd.in_eldecl
	  && ! groupConnector[prologState.level]
	  && dtd.scaffold[dtd.scaffIndex[dtd.scaffLevel - 1]].type != XML_CTYPE_MIXED
	  ) {
	dtd.scaffold[dtd.scaffIndex[dtd.scaffLevel - 1]].type = XML_CTYPE_CHOICE;
      }
      groupConnector[prologState.level] = '|';
      break;
    case XML_ROLE_PARAM_ENTITY_REF:
#ifdef XML_DTD
    case XML_ROLE_INNER_PARAM_ENTITY_REF:
      if (paramEntityParsing
	  && (dtd.complete || role == XML_ROLE_INNER_PARAM_ENTITY_REF)) {
	const XML_Char *name;
	ENTITY *entity;
	name = poolStoreString(&dtd.pool, enc,
				s + enc->minBytesPerChar,
				next - enc->minBytesPerChar);
	if (!name)
	  return XML_ERROR_NO_MEMORY;
	entity = (ENTITY *)lookup(&dtd.paramEntities, name, 0);
	poolDiscard(&dtd.pool);
	if (!entity) {
	  /* FIXME what to do if !dtd.complete? */
	  return XML_ERROR_UNDEFINED_ENTITY;
	}
	if (entity->open)
	  return XML_ERROR_RECURSIVE_ENTITY_REF;
	if (entity->textPtr) {
	  enum XML_Error result;
	  result = processInternalParamEntity(parser, entity);
	  if (result != XML_ERROR_NONE)
	    return result;
	  break;
	}
	if (role == XML_ROLE_INNER_PARAM_ENTITY_REF)
	  return XML_ERROR_PARAM_ENTITY_REF;
	if (externalEntityRefHandler) {
	  dtd.complete = 0;
	  entity->open = 1;
	  if (!externalEntityRefHandler(externalEntityRefHandlerArg,
					0,
					entity->base,
					entity->systemId,
					entity->publicId)) {
	    entity->open = 0;
	    return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
	  }
	  entity->open = 0;
	  if (dtd.complete)
	    break;
	}
      }
#endif /* XML_DTD */
      if (!dtd.standalone
	  && notStandaloneHandler
	  && !notStandaloneHandler(handlerArg))
	return XML_ERROR_NOT_STANDALONE;
      dtd.complete = 0;
      if (defaultHandler)
	reportDefault(parser, enc, s, next);
      break;

      /* Element declaration stuff */

    case XML_ROLE_ELEMENT_NAME:
      if (elementDeclHandler) {
	declElementType = getElementType(parser, enc, s, next);
	if (! declElementType)
	  return XML_ERROR_NO_MEMORY;
	dtd.scaffLevel = 0;
	dtd.scaffCount = 0;
	dtd.in_eldecl = 1;
      }
      break;

    case XML_ROLE_CONTENT_ANY:
    case XML_ROLE_CONTENT_EMPTY:
      if (dtd.in_eldecl) {
	if (elementDeclHandler) {
	  XML_Content * content = (XML_Content *) MALLOC(sizeof(XML_Content));
	  if (! content)
	    return XML_ERROR_NO_MEMORY;
	  content->quant = XML_CQUANT_NONE;
	  content->name = 0;
	  content->numchildren = 0;
	  content->children = 0;
	  content->type = ((role == XML_ROLE_CONTENT_ANY) ?
			   XML_CTYPE_ANY :
			   XML_CTYPE_EMPTY);
	  *eventEndPP = s;
	  elementDeclHandler(handlerArg, declElementType->name, content);
	}
	dtd.in_eldecl = 0;
      }
      break;
      
    case XML_ROLE_CONTENT_PCDATA:
      if (dtd.in_eldecl) {
	dtd.scaffold[dtd.scaffIndex[dtd.scaffLevel - 1]].type = XML_CTYPE_MIXED;
      }
      break;

    case XML_ROLE_CONTENT_ELEMENT:
      quant = XML_CQUANT_NONE;
      goto elementContent;
    case XML_ROLE_CONTENT_ELEMENT_OPT:
      quant = XML_CQUANT_OPT;
      goto elementContent;
    case XML_ROLE_CONTENT_ELEMENT_REP:
      quant = XML_CQUANT_REP;
      goto elementContent;
    case XML_ROLE_CONTENT_ELEMENT_PLUS:
      quant = XML_CQUANT_PLUS;
    elementContent:
      if (dtd.in_eldecl)
	{
	  ELEMENT_TYPE *el;
	  const char *nxt = quant == XML_CQUANT_NONE ? next : next - 1;
	  int myindex = nextScaffoldPart(parser);
	  if (myindex < 0)
	    return XML_ERROR_NO_MEMORY;
	  dtd.scaffold[myindex].type = XML_CTYPE_NAME;
	  dtd.scaffold[myindex].quant = quant;
	  el = getElementType(parser, enc, s, nxt);
	  if (! el)
	    return XML_ERROR_NO_MEMORY;
	  dtd.scaffold[myindex].name = el->name;
	  dtd.contentStringLen +=  nxt - s + 1;
	}
      break;

    case XML_ROLE_GROUP_CLOSE:
      quant = XML_CQUANT_NONE;
      goto closeGroup;
    case XML_ROLE_GROUP_CLOSE_OPT:
      quant = XML_CQUANT_OPT;
      goto closeGroup;
    case XML_ROLE_GROUP_CLOSE_REP:
      quant = XML_CQUANT_REP;
      goto closeGroup;
    case XML_ROLE_GROUP_CLOSE_PLUS:
      quant = XML_CQUANT_PLUS;
    closeGroup:
      if (dtd.in_eldecl) {
	dtd.scaffLevel--;
	dtd.scaffold[dtd.scaffIndex[dtd.scaffLevel]].quant = quant;
	if (dtd.scaffLevel == 0) {
	  if (elementDeclHandler) {
	    XML_Content *model = build_model(parser);
	    if (! model)
	      return XML_ERROR_NO_MEMORY;
	    *eventEndPP = s;
	    elementDeclHandler(handlerArg, declElementType->name, model);
	  }
	  dtd.in_eldecl = 0;
	  dtd.contentStringLen = 0;
	}
      }
      break;
      /* End element declaration stuff */

    case XML_ROLE_NONE:
      switch (tok) {
      case XML_TOK_PI:
	if (!reportProcessingInstruction(parser, enc, s, next))
	  return XML_ERROR_NO_MEMORY;
	break;
      case XML_TOK_COMMENT:
	if (!reportComment(parser, enc, s, next))
	  return XML_ERROR_NO_MEMORY;
	break;
      }
      break;
    }
    if (defaultHandler) {
      switch (tok) {
      case XML_TOK_PI:
      case XML_TOK_COMMENT:
      case XML_TOK_BOM:
      case XML_TOK_XML_DECL:
#ifdef XML_DTD
      case XML_TOK_IGNORE_SECT:
#endif /* XML_DTD */
      case XML_TOK_PARAM_ENTITY_REF:
	break;
      default:
#ifdef XML_DTD
	if (role != XML_ROLE_IGNORE_SECT)
#endif /* XML_DTD */
	  reportDefault(parser, enc, s, next);
      }
    }
    s = next;
    tok = XmlPrologTok(enc, s, end, &next);
  }
  /* not reached */
}

static
enum XML_Error epilogProcessor(XML_Parser parser,
			       const char *s,
			       const char *end,
			       const char **nextPtr)
{
  processor = epilogProcessor;
  eventPtr = s;
  for (;;) {
    const char *next;
    int tok = XmlPrologTok(encoding, s, end, &next);
    eventEndPtr = next;
    switch (tok) {
    case -XML_TOK_PROLOG_S:
      if (defaultHandler) {
	eventEndPtr = end;
	reportDefault(parser, encoding, s, end);
      }
      /* fall through */
    case XML_TOK_NONE:
      if (nextPtr)
	*nextPtr = end;
      return XML_ERROR_NONE;
    case XML_TOK_PROLOG_S:
      if (defaultHandler)
	reportDefault(parser, encoding, s, next);
      break;
    case XML_TOK_PI:
      if (!reportProcessingInstruction(parser, encoding, s, next))
	return XML_ERROR_NO_MEMORY;
      break;
    case XML_TOK_COMMENT:
      if (!reportComment(parser, encoding, s, next))
	return XML_ERROR_NO_MEMORY;
      break;
    case XML_TOK_INVALID:
      eventPtr = next;
      return XML_ERROR_INVALID_TOKEN;
    case XML_TOK_PARTIAL:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      return XML_ERROR_UNCLOSED_TOKEN;
    case XML_TOK_PARTIAL_CHAR:
      if (nextPtr) {
	*nextPtr = s;
	return XML_ERROR_NONE;
      }
      return XML_ERROR_PARTIAL_CHAR;
    default:
      return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;
    }
    eventPtr = s = next;
  }
}

#ifdef XML_DTD

static enum XML_Error
processInternalParamEntity(XML_Parser parser, ENTITY *entity)
{
  const char *s, *end, *next;
  int tok;
  enum XML_Error result;
  OPEN_INTERNAL_ENTITY openEntity;
  entity->open = 1;
  openEntity.next = openInternalEntities;
  openInternalEntities = &openEntity;
  openEntity.entity = entity;
  openEntity.internalEventPtr = 0;
  openEntity.internalEventEndPtr = 0;
  s = (char *)entity->textPtr;
  end = (char *)(entity->textPtr + entity->textLen);
  tok = XmlPrologTok(internalEncoding, s, end, &next);
  result = doProlog(parser, internalEncoding, s, end, tok, next, 0);
  entity->open = 0;
  openInternalEntities = openEntity.next;
  return result;
}

#endif /* XML_DTD */

static
enum XML_Error errorProcessor(XML_Parser parser,
			      const char *s,
			      const char *end,
			      const char **nextPtr)
{
  return errorCode;
}

static enum XML_Error
storeAttributeValue(XML_Parser parser, const ENCODING *enc, int isCdata,
		    const char *ptr, const char *end,
		    STRING_POOL *pool)
{
  enum XML_Error result = appendAttributeValue(parser, enc, isCdata, ptr, end, pool);
  if (result)
    return result;
  if (!isCdata && poolLength(pool) && poolLastChar(pool) == 0x20)
    poolChop(pool);
  if (!poolAppendChar(pool, XML_T('\0')))
    return XML_ERROR_NO_MEMORY;
  return XML_ERROR_NONE;
}

static enum XML_Error
appendAttributeValue(XML_Parser parser, const ENCODING *enc, int isCdata,
		     const char *ptr, const char *end,
		     STRING_POOL *pool)
{
  for (;;) {
    const char *next;
    int tok = XmlAttributeValueTok(enc, ptr, end, &next);
    switch (tok) {
    case XML_TOK_NONE:
      return XML_ERROR_NONE;
    case XML_TOK_INVALID:
      if (enc == encoding)
	eventPtr = next;
      return XML_ERROR_INVALID_TOKEN;
    case XML_TOK_PARTIAL:
      if (enc == encoding)
	eventPtr = ptr;
      return XML_ERROR_INVALID_TOKEN;
    case XML_TOK_CHAR_REF:
      {
	XML_Char buf[XML_ENCODE_MAX];
	int i;
	int n = XmlCharRefNumber(enc, ptr);
	if (n < 0) {
	  if (enc == encoding)
	    eventPtr = ptr;
      	  return XML_ERROR_BAD_CHAR_REF;
	}
	if (!isCdata
	    && n == 0x20 /* space */
	    && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))
	  break;
	n = XmlEncode(n, (ICHAR *)buf);
	if (!n) {
	  if (enc == encoding)
	    eventPtr = ptr;
	  return XML_ERROR_BAD_CHAR_REF;
	}
	for (i = 0; i < n; i++) {
	  if (!poolAppendChar(pool, buf[i]))
	    return XML_ERROR_NO_MEMORY;
	}
      }
      break;
    case XML_TOK_DATA_CHARS:
      if (!poolAppend(pool, enc, ptr, next))
	return XML_ERROR_NO_MEMORY;
      break;
      break;
    case XML_TOK_TRAILING_CR:
      next = ptr + enc->minBytesPerChar;
      /* fall through */
    case XML_TOK_ATTRIBUTE_VALUE_S:
    case XML_TOK_DATA_NEWLINE:
      if (!isCdata && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))
	break;
      if (!poolAppendChar(pool, 0x20))
	return XML_ERROR_NO_MEMORY;
      break;
    case XML_TOK_ENTITY_REF:
      {
	const XML_Char *name;
	ENTITY *entity;
	XML_Char ch = XmlPredefinedEntityName(enc,
					      ptr + enc->minBytesPerChar,
					      next - enc->minBytesPerChar);
	if (ch) {
	  if (!poolAppendChar(pool, ch))
  	    return XML_ERROR_NO_MEMORY;
	  break;
	}
	name = poolStoreString(&temp2Pool, enc,
			       ptr + enc->minBytesPerChar,
			       next - enc->minBytesPerChar);
	if (!name)
	  return XML_ERROR_NO_MEMORY;
	entity = (ENTITY *)lookup(&dtd.generalEntities, name, 0);
	poolDiscard(&temp2Pool);
	if (!entity) {
	  if (dtd.complete) {
	    if (enc == encoding)
	      eventPtr = ptr;
	    return XML_ERROR_UNDEFINED_ENTITY;
	  }
	}
	else if (entity->open) {
	  if (enc == encoding)
	    eventPtr = ptr;
	  return XML_ERROR_RECURSIVE_ENTITY_REF;
	}
	else if (entity->notation) {
	  if (enc == encoding)
	    eventPtr = ptr;
	  return XML_ERROR_BINARY_ENTITY_REF;
	}
	else if (!entity->textPtr) {
	  if (enc == encoding)
	    eventPtr = ptr;
  	  return XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF;
	}
	else {
	  enum XML_Error result;
	  const XML_Char *textEnd = entity->textPtr + entity->textLen;
	  entity->open = 1;
	  result = appendAttributeValue(parser, internalEncoding, isCdata, (char *)entity->textPtr, (char *)textEnd, pool);
	  entity->open = 0;
	  if (result)
	    return result;
	}
      }
      break;
    default:
      if (enc == encoding)
	eventPtr = ptr;
      return XML_ERROR_UNEXPECTED_STATE;
    }
    ptr = next;
  }
  /* not reached */
}

static
enum XML_Error storeEntityValue(XML_Parser parser,
				const ENCODING *enc,
				const char *entityTextPtr,
				const char *entityTextEnd)
{
  STRING_POOL *pool = &(dtd.pool);
  for (;;) {
    const char *next;
    int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);
    switch (tok) {
    case XML_TOK_PARAM_ENTITY_REF:
#ifdef XML_DTD
      if (parentParser || enc != encoding) {
	enum XML_Error result;
	const XML_Char *name;
	ENTITY *entity;
	name = poolStoreString(&tempPool, enc,
			       entityTextPtr + enc->minBytesPerChar,
			       next - enc->minBytesPerChar);
	if (!name)
	  return XML_ERROR_NO_MEMORY;
	entity = (ENTITY *)lookup(&dtd.paramEntities, name, 0);
	poolDiscard(&tempPool);
	if (!entity) {
	  if (enc == encoding)
	    eventPtr = entityTextPtr;
	  return XML_ERROR_UNDEFINED_ENTITY;
	}
	if (entity->open) {
	  if (enc == encoding)
	    eventPtr = entityTextPtr;
	  return XML_ERROR_RECURSIVE_ENTITY_REF;
	}
	if (entity->systemId) {
	  if (enc == encoding)
	    eventPtr = entityTextPtr;
	  return XML_ERROR_PARAM_ENTITY_REF;
	}
	entity->open = 1;
	result = storeEntityValue(parser,
				  internalEncoding,
				  (char *)entity->textPtr,
				  (char *)(entity->textPtr + entity->textLen));
	entity->open = 0;
	if (result)
	  return result;
	break;
      }
#endif /* XML_DTD */
      eventPtr = entityTextPtr;
      return XML_ERROR_SYNTAX;
    case XML_TOK_NONE:
      return XML_ERROR_NONE;
    case XML_TOK_ENTITY_REF:
    case XML_TOK_DATA_CHARS:
      if (!poolAppend(pool, enc, entityTextPtr, next))
	return XML_ERROR_NO_MEMORY;
      break;
    case XML_TOK_TRAILING_CR:
      next = entityTextPtr + enc->minBytesPerChar;
      /* fall through */
    case XML_TOK_DATA_NEWLINE:
      if (pool->end == pool->ptr && !poolGrow(pool))
	return XML_ERROR_NO_MEMORY;
      *(pool->ptr)++ = 0xA;
      break;
    case XML_TOK_CHAR_REF:
      {
	XML_Char buf[XML_ENCODE_MAX];
	int i;
	int n = XmlCharRefNumber(enc, entityTextPtr);
	if (n < 0) {
	  if (enc == encoding)
	    eventPtr = entityTextPtr;
	  return XML_ERROR_BAD_CHAR_REF;
	}
	n = XmlEncode(n, (ICHAR *)buf);
	if (!n) {
	  if (enc == encoding)
	    eventPtr = entityTextPtr;
	  return XML_ERROR_BAD_CHAR_REF;
	}
	for (i = 0; i < n; i++) {
	  if (pool->end == pool->ptr && !poolGrow(pool))
	    return XML_ERROR_NO_MEMORY;
	  *(pool->ptr)++ = buf[i];
	}
      }
      break;
    case XML_TOK_PARTIAL:
      if (enc == encoding)
	eventPtr = entityTextPtr;
      return XML_ERROR_INVALID_TOKEN;
    case XML_TOK_INVALID:
      if (enc == encoding)
	eventPtr = next;
      return XML_ERROR_INVALID_TOKEN;
    default:
      if (enc == encoding)
	eventPtr = entityTextPtr;
      return XML_ERROR_UNEXPECTED_STATE;
    }
    entityTextPtr = next;
  }
  /* not reached */
}

static void
normalizeLines(XML_Char *s)
{
  XML_Char *p;
  for (;; s++) {
    if (*s == XML_T('\0'))
      return;
    if (*s == 0xD)
      break;
  }
  p = s;
  do {
    if (*s == 0xD) {
      *p++ = 0xA;
      if (*++s == 0xA)
        s++;
    }
    else
      *p++ = *s++;
  } while (*s);
  *p = XML_T('\0');
}

static int
reportProcessingInstruction(XML_Parser parser, const ENCODING *enc, const char *start, const char *end)
{
  const XML_Char *target;
  XML_Char *data;
  const char *tem;
  if (!processingInstructionHandler) {
    if (defaultHandler)
      reportDefault(parser, enc, start, end);
    return 1;
  }
  start += enc->minBytesPerChar * 2;
  tem = start + XmlNameLength(enc, start);
  target = poolStoreString(&tempPool, enc, start, tem);
  if (!target)
    return 0;
  poolFinish(&tempPool);
  data = poolStoreString(&tempPool, enc,
			XmlSkipS(enc, tem),
			end - enc->minBytesPerChar*2);
  if (!data)
    return 0;
  normalizeLines(data);
  processingInstructionHandler(handlerArg, target, data);
  poolClear(&tempPool);
  return 1;
}

static int
reportComment(XML_Parser parser, const ENCODING *enc, const char *start, const char *end)
{
  XML_Char *data;
  if (!commentHandler) {
    if (defaultHandler)
      reportDefault(parser, enc, start, end);
    return 1;
  }
  data = poolStoreString(&tempPool,
                         enc,
                         start + enc->minBytesPerChar * 4, 
			 end - enc->minBytesPerChar * 3);
  if (!data)
    return 0;
  normalizeLines(data);
  commentHandler(handlerArg, data);
  poolClear(&tempPool);
  return 1;
}

static void
reportDefault(XML_Parser parser, const ENCODING *enc, const char *s, const char *end)
{
  if (MUST_CONVERT(enc, s)) {
    const char **eventPP;
    const char **eventEndPP;
    if (enc == encoding) {
      eventPP = &eventPtr;
      eventEndPP = &eventEndPtr;
    }
    else {
      eventPP = &(openInternalEntities->internalEventPtr);
      eventEndPP = &(openInternalEntities->internalEventEndPtr);
    }
    do {
      ICHAR *dataPtr = (ICHAR *)dataBuf;
      XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)dataBufEnd);
      *eventEndPP = s;
      defaultHandler(handlerArg, dataBuf, dataPtr - (ICHAR *)dataBuf);
      *eventPP = s;
    } while (s != end);
  }
  else
    defaultHandler(handlerArg, (XML_Char *)s, (XML_Char *)end - (XML_Char *)s);
}


static int
defineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *attId, int isCdata,
		int isId, const XML_Char *value, XML_Parser parser)
{
  DEFAULT_ATTRIBUTE *att;
  if (value || isId) {
    /* The handling of default attributes gets messed up if we have
       a default which duplicates a non-default. */
    int i;
    for (i = 0; i < type->nDefaultAtts; i++)
      if (attId == type->defaultAtts[i].id)
	return 1;
    if (isId && !type->idAtt && !attId->xmlns)
      type->idAtt = attId;
  }
  if (type->nDefaultAtts == type->allocDefaultAtts) {
    if (type->allocDefaultAtts == 0) {
      type->allocDefaultAtts = 8;
      type->defaultAtts = MALLOC(type->allocDefaultAtts*sizeof(DEFAULT_ATTRIBUTE));
    }
    else {
      type->allocDefaultAtts *= 2;
      type->defaultAtts = REALLOC(type->defaultAtts,
				  type->allocDefaultAtts*sizeof(DEFAULT_ATTRIBUTE));
    }
    if (!type->defaultAtts)
      return 0;
  }
  att = type->defaultAtts + type->nDefaultAtts;
  att->id = attId;
  att->value = value;
  att->isCdata = isCdata;
  if (!isCdata)
    attId->maybeTokenized = 1;
  type->nDefaultAtts += 1;
  return 1;
}

static int setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)
{
  const XML_Char *name;
  for (name = elementType->name; *name; name++) {
    if (*name == XML_T(':')) {
      PREFIX *prefix;
      const XML_Char *s;
      for (s = elementType->name; s != name; s++) {
	if (!poolAppendChar(&dtd.pool, *s))
	  return 0;
      }
      if (!poolAppendChar(&dtd.pool, XML_T('\0')))
	return 0;
      prefix = (PREFIX *)lookup(&dtd.prefixes, poolStart(&dtd.pool), sizeof(PREFIX));
      if (!prefix)
	return 0;
      if (prefix->name == poolStart(&dtd.pool))
	poolFinish(&dtd.pool);
      else
	poolDiscard(&dtd.pool);
      elementType->prefix = prefix;

    }
  }
  return 1;
}

static ATTRIBUTE_ID *
getAttributeId(XML_Parser parser, const ENCODING *enc, const char *start, const char *end)
{
  ATTRIBUTE_ID *id;
  const XML_Char *name;
  if (!poolAppendChar(&dtd.pool, XML_T('\0')))
    return 0;
  name = poolStoreString(&dtd.pool, enc, start, end);
  if (!name)
    return 0;
  ++name;
  id = (ATTRIBUTE_ID *)lookup(&dtd.attributeIds, name, sizeof(ATTRIBUTE_ID));
  if (!id)
    return 0;
  if (id->name != name)
    poolDiscard(&dtd.pool);
  else {
    poolFinish(&dtd.pool);
    if (!ns)
      ;
    else if (name[0] == 'x'
	&& name[1] == 'm'
	&& name[2] == 'l'
	&& name[3] == 'n'
	&& name[4] == 's'
	&& (name[5] == XML_T('\0') || name[5] == XML_T(':'))) {
      if (name[5] == '\0')
	id->prefix = &dtd.defaultPrefix;
      else
	id->prefix = (PREFIX *)lookup(&dtd.prefixes, name + 6, sizeof(PREFIX));
      id->xmlns = 1;
    }
    else {
      int i;
      for (i = 0; name[i]; i++) {
	if (name[i] == XML_T(':')) {
	  int j;
	  for (j = 0; j < i; j++) {
	    if (!poolAppendChar(&dtd.pool, name[j]))
	      return 0;
	  }
	  if (!poolAppendChar(&dtd.pool, XML_T('\0')))
	    return 0;
	  id->prefix = (PREFIX *)lookup(&dtd.prefixes, poolStart(&dtd.pool), sizeof(PREFIX));
	  if (id->prefix->name == poolStart(&dtd.pool))
	    poolFinish(&dtd.pool);
	  else
	    poolDiscard(&dtd.pool);
	  break;
	}
      }
    }
  }
  return id;
}

#define CONTEXT_SEP XML_T('\f')

static
const XML_Char *getContext(XML_Parser parser)
{
  HASH_TABLE_ITER iter;
  int needSep = 0;

  if (dtd.defaultPrefix.binding) {
    int i;
    int len;
    if (!poolAppendChar(&tempPool, XML_T('=')))
      return 0;
    len = dtd.defaultPrefix.binding->uriLen;
    if (namespaceSeparator != XML_T('\0'))
      len--;
    for (i = 0; i < len; i++)
      if (!poolAppendChar(&tempPool, dtd.defaultPrefix.binding->uri[i]))
  	return 0;
    needSep = 1;
  }

  hashTableIterInit(&iter, &(dtd.prefixes));
  for (;;) {
    int i;
    int len;
    const XML_Char *s;
    PREFIX *prefix = (PREFIX *)hashTableIterNext(&iter);
    if (!prefix)
      break;
    if (!prefix->binding)
      continue;
    if (needSep && !poolAppendChar(&tempPool, CONTEXT_SEP))
      return 0;
    for (s = prefix->name; *s; s++)
      if (!poolAppendChar(&tempPool, *s))
        return 0;
    if (!poolAppendChar(&tempPool, XML_T('=')))
      return 0;
    len = prefix->binding->uriLen;
    if (namespaceSeparator != XML_T('\0'))
      len--;
    for (i = 0; i < len; i++)
      if (!poolAppendChar(&tempPool, prefix->binding->uri[i]))
        return 0;
    needSep = 1;
  }


  hashTableIterInit(&iter, &(dtd.generalEntities));
  for (;;) {
    const XML_Char *s;
    ENTITY *e = (ENTITY *)hashTableIterNext(&iter);
    if (!e)
      break;
    if (!e->open)
      continue;
    if (needSep && !poolAppendChar(&tempPool, CONTEXT_SEP))
      return 0;
    for (s = e->name; *s; s++)
      if (!poolAppendChar(&tempPool, *s))
        return 0;
    needSep = 1;
  }

  if (!poolAppendChar(&tempPool, XML_T('\0')))
    return 0;
  return tempPool.start;
}

static
int setContext(XML_Parser parser, const XML_Char *context)
{
  const XML_Char *s = context;

  while (*context != XML_T('\0')) {
    if (*s == CONTEXT_SEP || *s == XML_T('\0')) {
      ENTITY *e;
      if (!poolAppendChar(&tempPool, XML_T('\0')))
	return 0;
      e = (ENTITY *)lookup(&dtd.generalEntities, poolStart(&tempPool), 0);
      if (e)
	e->open = 1;
      if (*s != XML_T('\0'))
	s++;
      context = s;
      poolDiscard(&tempPool);
    }
    else if (*s == '=') {
      PREFIX *prefix;
      if (poolLength(&tempPool) == 0)
	prefix = &dtd.defaultPrefix;
      else {
	if (!poolAppendChar(&tempPool, XML_T('\0')))
	  return 0;
	prefix = (PREFIX *)lookup(&dtd.prefixes, poolStart(&tempPool), sizeof(PREFIX));
	if (!prefix)
	  return 0;
        if (prefix->name == poolStart(&tempPool)) {
	  prefix->name = poolCopyString(&dtd.pool, prefix->name);
	  if (!prefix->name)
	    return 0;
	}
	poolDiscard(&tempPool);
      }
      for (context = s + 1; *context != CONTEXT_SEP && *context != XML_T('\0'); context++)
        if (!poolAppendChar(&tempPool, *context))
          return 0;
      if (!poolAppendChar(&tempPool, XML_T('\0')))
	return 0;
      if (!addBinding(parser, prefix, 0, poolStart(&tempPool), &inheritedBindings))
	return 0;
      poolDiscard(&tempPool);
      if (*context != XML_T('\0'))
	++context;
      s = context;
    }
    else {
      if (!poolAppendChar(&tempPool, *s))
	return 0;
      s++;
    }
  }
  return 1;
}


static
void normalizePublicId(XML_Char *publicId)
{
  XML_Char *p = publicId;
  XML_Char *s;
  for (s = publicId; *s; s++) {
    switch (*s) {
    case 0x20:
    case 0xD:
    case 0xA:
      if (p != publicId && p[-1] != 0x20)
	*p++ = 0x20;
      break;
    default:
      *p++ = *s;
    }
  }
  if (p != publicId && p[-1] == 0x20)
    --p;
  *p = XML_T('\0');
}

static int dtdInit(DTD *p, XML_Parser parser)
{
  XML_Memory_Handling_Suite *ms = &((Parser *) parser)->m_mem; 
  poolInit(&(p->pool), ms);
  hashTableInit(&(p->generalEntities), ms);
  hashTableInit(&(p->elementTypes), ms);
  hashTableInit(&(p->attributeIds), ms);
  hashTableInit(&(p->prefixes), ms);
  p->complete = 1;
  p->standalone = 0;
#ifdef XML_DTD
  hashTableInit(&(p->paramEntities), ms);
#endif /* XML_DTD */
  p->defaultPrefix.name = 0;
  p->defaultPrefix.binding = 0;

  p->in_eldecl = 0;
  p->scaffIndex = 0;
  p->scaffLevel = 0;
  p->scaffold = 0;
  p->contentStringLen = 0;
  p->scaffSize = 0;
  p->scaffCount = 0;

  return 1;
}

#ifdef XML_DTD

static void dtdSwap(DTD *p1, DTD *p2)
{
  DTD tem;
  memcpy(&tem, p1, sizeof(DTD));
  memcpy(p1, p2, sizeof(DTD));
  memcpy(p2, &tem, sizeof(DTD));
}

#endif /* XML_DTD */

static void dtdDestroy(DTD *p, XML_Parser parser)
{
  HASH_TABLE_ITER iter;
  hashTableIterInit(&iter, &(p->elementTypes));
  for (;;) {
    ELEMENT_TYPE *e = (ELEMENT_TYPE *)hashTableIterNext(&iter);
    if (!e)
      break;
    if (e->allocDefaultAtts != 0)
      FREE(e->defaultAtts);
  }
  hashTableDestroy(&(p->generalEntities));
#ifdef XML_DTD
  hashTableDestroy(&(p->paramEntities));
#endif /* XML_DTD */
  hashTableDestroy(&(p->elementTypes));
  hashTableDestroy(&(p->attributeIds));
  hashTableDestroy(&(p->prefixes));
  poolDestroy(&(p->pool));
  if (p->scaffIndex)
    FREE(p->scaffIndex);
  if (p->scaffold)
    FREE(p->scaffold);
}

/* Do a deep copy of the DTD.  Return 0 for out of memory; non-zero otherwise.
The new DTD has already been initialized. */

static int dtdCopy(DTD *newDtd, const DTD *oldDtd, XML_Parser parser)
{
  HASH_TABLE_ITER iter;

  /* Copy the prefix table. */

  hashTableIterInit(&iter, &(oldDtd->prefixes));
  for (;;) {
    const XML_Char *name;
    const PREFIX *oldP = (PREFIX *)hashTableIterNext(&iter);
    if (!oldP)
      break;
    name = poolCopyString(&(newDtd->pool), oldP->name);
    if (!name)
      return 0;
    if (!lookup(&(newDtd->prefixes), name, sizeof(PREFIX)))
      return 0;
  }

  hashTableIterInit(&iter, &(oldDtd->attributeIds));

  /* Copy the attribute id table. */

  for (;;) {
    ATTRIBUTE_ID *newA;
    const XML_Char *name;
    const ATTRIBUTE_ID *oldA = (ATTRIBUTE_ID *)hashTableIterNext(&iter);

    if (!oldA)
      break;
    /* Remember to allocate the scratch byte before the name. */
    if (!poolAppendChar(&(newDtd->pool), XML_T('\0')))
      return 0;
    name = poolCopyString(&(newDtd->pool), oldA->name);
    if (!name)
      return 0;
    ++name;
    newA = (ATTRIBUTE_ID *)lookup(&(newDtd->attributeIds), name, sizeof(ATTRIBUTE_ID));
    if (!newA)
      return 0;
    newA->maybeTokenized = oldA->maybeTokenized;
    if (oldA->prefix) {
      newA->xmlns = oldA->xmlns;
      if (oldA->prefix == &oldDtd->defaultPrefix)
	newA->prefix = &newDtd->defaultPrefix;
      else
	newA->prefix = (PREFIX *)lookup(&(newDtd->prefixes), oldA->prefix->name, 0);
    }
  }

  /* Copy the element type table. */

  hashTableIterInit(&iter, &(oldDtd->elementTypes));

  for (;;) {
    int i;
    ELEMENT_TYPE *newE;
    const XML_Char *name;
    const ELEMENT_TYPE *oldE = (ELEMENT_TYPE *)hashTableIterNext(&iter);
    if (!oldE)
      break;
    name = poolCopyString(&(newDtd->pool), oldE->name);
    if (!name)
      return 0;
    newE = (ELEMENT_TYPE *)lookup(&(newDtd->elementTypes), name, sizeof(ELEMENT_TYPE));
    if (!newE)
      return 0;
    if (oldE->nDefaultAtts) {
      newE->defaultAtts = (DEFAULT_ATTRIBUTE *)MALLOC(oldE->nDefaultAtts * sizeof(DEFAULT_ATTRIBUTE));
      if (!newE->defaultAtts)
	return 0;
    }
    if (oldE->idAtt)
      newE->idAtt = (ATTRIBUTE_ID *)lookup(&(newDtd->attributeIds), oldE->idAtt->name, 0);
    newE->allocDefaultAtts = newE->nDefaultAtts = oldE->nDefaultAtts;
    if (oldE->prefix)
      newE->prefix = (PREFIX *)lookup(&(newDtd->prefixes), oldE->prefix->name, 0);
    for (i = 0; i < newE->nDefaultAtts; i++) {
      newE->defaultAtts[i].id = (ATTRIBUTE_ID *)lookup(&(newDtd->attributeIds), oldE->defaultAtts[i].id->name, 0);
      newE->defaultAtts[i].isCdata = oldE->defaultAtts[i].isCdata;
      if (oldE->defaultAtts[i].value) {
	newE->defaultAtts[i].value = poolCopyString(&(newDtd->pool), oldE->defaultAtts[i].value);
	if (!newE->defaultAtts[i].value)
  	  return 0;
      }
      else
	newE->defaultAtts[i].value = 0;
    }
  }

  /* Copy the entity tables. */
  if (!copyEntityTable(&(newDtd->generalEntities),
		       &(newDtd->pool),
		       &(oldDtd->generalEntities), parser))
      return 0;

#ifdef XML_DTD
  if (!copyEntityTable(&(newDtd->paramEntities),
		       &(newDtd->pool),
		       &(oldDtd->paramEntities), parser))
      return 0;
#endif /* XML_DTD */

  newDtd->complete = oldDtd->complete;
  newDtd->standalone = oldDtd->standalone;

  /* Don't want deep copying for scaffolding */
  newDtd->in_eldecl = oldDtd->in_eldecl;
  newDtd->scaffold = oldDtd->scaffold;
  newDtd->contentStringLen = oldDtd->contentStringLen;
  newDtd->scaffSize = oldDtd->scaffSize;
  newDtd->scaffLevel = oldDtd->scaffLevel;
  newDtd->scaffIndex = oldDtd->scaffIndex;

  return 1;
}  /* End dtdCopy */

static int copyEntityTable(HASH_TABLE *newTable,
			   STRING_POOL *newPool,
			   const HASH_TABLE *oldTable,
			   XML_Parser parser)
{
  HASH_TABLE_ITER iter;
  const XML_Char *cachedOldBase = 0;
  const XML_Char *cachedNewBase = 0;

  hashTableIterInit(&iter, oldTable);

  for (;;) {
    ENTITY *newE;
    const XML_Char *name;
    const ENTITY *oldE = (ENTITY *)hashTableIterNext(&iter);
    if (!oldE)
      break;
    name = poolCopyString(newPool, oldE->name);
    if (!name)
      return 0;
    newE = (ENTITY *)lookup(newTable, name, sizeof(ENTITY));
    if (!newE)
      return 0;
    if (oldE->systemId) {
      const XML_Char *tem = poolCopyString(newPool, oldE->systemId);
      if (!tem)
	return 0;
      newE->systemId = tem;
      if (oldE->base) {
	if (oldE->base == cachedOldBase)
	  newE->base = cachedNewBase;
	else {
	  cachedOldBase = oldE->base;
	  tem = poolCopyString(newPool, cachedOldBase);
	  if (!tem)
	    return 0;
	  cachedNewBase = newE->base = tem;
	}
      }
    }
    else {
      const XML_Char *tem = poolCopyStringN(newPool, oldE->textPtr, oldE->textLen);
      if (!tem)
	return 0;
      newE->textPtr = tem;
      newE->textLen = oldE->textLen;
    }
    if (oldE->notation) {
      const XML_Char *tem = poolCopyString(newPool, oldE->notation);
      if (!tem)
	return 0;
      newE->notation = tem;
    }
  }
  return 1;
}

#define INIT_SIZE 64

static
int keyeq(KEY s1, KEY s2)
{
  for (; *s1 == *s2; s1++, s2++)
    if (*s1 == 0)
      return 1;
  return 0;
}

static
unsigned long hash(KEY s)
{
  unsigned long h = 0;
  while (*s)
    h = (h << 5) + h + (unsigned char)*s++;
  return h;
}

static
NAMED *lookup(HASH_TABLE *table, KEY name, size_t createSize)
{
  size_t i;
  if (table->size == 0) {
    size_t tsize;

    if (!createSize)
      return 0;
    tsize = INIT_SIZE * sizeof(NAMED *);
    table->v = table->mem->malloc_fcn(tsize);
    if (!table->v)
      return 0;
    memset(table->v, 0, tsize);
    table->size = INIT_SIZE;
    table->usedLim = INIT_SIZE / 2;
    i = hash(name) & (table->size - 1);
  }
  else {
    unsigned long h = hash(name);
    for (i = h & (table->size - 1);
         table->v[i];
         i == 0 ? i = table->size - 1 : --i) {
      if (keyeq(name, table->v[i]->name))
	return table->v[i];
    }
    if (!createSize)
      return 0;
    if (table->used == table->usedLim) {
      /* check for overflow */
      size_t newSize = table->size * 2;
      size_t tsize = newSize * sizeof(NAMED *);
      NAMED **newV = table->mem->malloc_fcn(tsize);
      if (!newV)
	return 0;
      memset(newV, 0, tsize);
      for (i = 0; i < table->size; i++)
	if (table->v[i]) {
	  size_t j;
	  for (j = hash(table->v[i]->name) & (newSize - 1);
	       newV[j];
	       j == 0 ? j = newSize - 1 : --j)
	    ;
	  newV[j] = table->v[i];
	}
      table->mem->free_fcn(table->v);
      table->v = newV;
      table->size = newSize;
      table->usedLim = newSize/2;
      for (i = h & (table->size - 1);
	   table->v[i];
	   i == 0 ? i = table->size - 1 : --i)
	;
    }
  }
  table->v[i] = table->mem->malloc_fcn(createSize);
  if (!table->v[i])
    return 0;
  memset(table->v[i], 0, createSize);
  table->v[i]->name = name;
  (table->used)++;
  return table->v[i];
}

static
void hashTableDestroy(HASH_TABLE *table)
{
  size_t i;
  for (i = 0; i < table->size; i++) {
    NAMED *p = table->v[i];
    if (p)
      table->mem->free_fcn(p);
  }
  if (table->v)
    table->mem->free_fcn(table->v);
}

static
void hashTableInit(HASH_TABLE *p, XML_Memory_Handling_Suite *ms)
{
  p->size = 0;
  p->usedLim = 0;
  p->used = 0;
  p->v = 0;
  p->mem = ms;
}

static
void hashTableIterInit(HASH_TABLE_ITER *iter, const HASH_TABLE *table)
{
  iter->p = table->v;
  iter->end = iter->p + table->size;
}

static
NAMED *hashTableIterNext(HASH_TABLE_ITER *iter)
{
  while (iter->p != iter->end) {
    NAMED *tem = *(iter->p)++;
    if (tem)
      return tem;
  }
  return 0;
}


static
void poolInit(STRING_POOL *pool, XML_Memory_Handling_Suite *ms)
{
  pool->blocks = 0;
  pool->freeBlocks = 0;
  pool->start = 0;
  pool->ptr = 0;
  pool->end = 0;
  pool->mem = ms;
}

static
void poolClear(STRING_POOL *pool)
{
  if (!pool->freeBlocks)
    pool->freeBlocks = pool->blocks;
  else {
    BLOCK *p = pool->blocks;
    while (p) {
      BLOCK *tem = p->next;
      p->next = pool->freeBlocks;
      pool->freeBlocks = p;
      p = tem;
    }
  }
  pool->blocks = 0;
  pool->start = 0;
  pool->ptr = 0;
  pool->end = 0;
}

static
void poolDestroy(STRING_POOL *pool)
{
  BLOCK *p = pool->blocks;
  while (p) {
    BLOCK *tem = p->next;
    pool->mem->free_fcn(p);
    p = tem;
  }
  pool->blocks = 0;
  p = pool->freeBlocks;
  while (p) {
    BLOCK *tem = p->next;
    pool->mem->free_fcn(p);
    p = tem;
  }
  pool->freeBlocks = 0;
  pool->ptr = 0;
  pool->start = 0;
  pool->end = 0;
}

static
XML_Char *poolAppend(STRING_POOL *pool, const ENCODING *enc,
		     const char *ptr, const char *end)
{
  if (!pool->ptr && !poolGrow(pool))
    return 0;
  for (;;) {
    XmlConvert(enc, &ptr, end, (ICHAR **)&(pool->ptr), (ICHAR *)pool->end);
    if (ptr == end)
      break;
    if (!poolGrow(pool))
      return 0;
  }
  return pool->start;
}

static const XML_Char *poolCopyString(STRING_POOL *pool, const XML_Char *s)
{
  do {
    if (!poolAppendChar(pool, *s))
      return 0;
  } while (*s++);
  s = pool->start;
  poolFinish(pool);
  return s;
}

static const XML_Char *poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n)
{
  if (!pool->ptr && !poolGrow(pool))
    return 0;
  for (; n > 0; --n, s++) {
    if (!poolAppendChar(pool, *s))
      return 0;

  }
  s = pool->start;
  poolFinish(pool);
  return s;
}

static
const XML_Char *poolAppendString(STRING_POOL *pool, const XML_Char *s)
{
  while (*s) {
    if (!poolAppendChar(pool, *s))
      return 0;
    s++;
  } 
  return pool->start;
}  /* End poolAppendString */

static
XML_Char *poolStoreString(STRING_POOL *pool, const ENCODING *enc,
			  const char *ptr, const char *end)
{
  if (!poolAppend(pool, enc, ptr, end))
    return 0;
  if (pool->ptr == pool->end && !poolGrow(pool))
    return 0;
  *(pool->ptr)++ = 0;
  return pool->start;
}

static
int poolGrow(STRING_POOL *pool)
{
  if (pool->freeBlocks) {
    if (pool->start == 0) {
      pool->blocks = pool->freeBlocks;
      pool->freeBlocks = pool->freeBlocks->next;
      pool->blocks->next = 0;
      pool->start = pool->blocks->s;
      pool->end = pool->start + pool->blocks->size;
      pool->ptr = pool->start;
      return 1;
    }
    if (pool->end - pool->start < pool->freeBlocks->size) {
      BLOCK *tem = pool->freeBlocks->next;
      pool->freeBlocks->next = pool->blocks;
      pool->blocks = pool->freeBlocks;
      pool->freeBlocks = tem;
      memcpy(pool->blocks->s, pool->start, (pool->end - pool->start) * sizeof(XML_Char));
      pool->ptr = pool->blocks->s + (pool->ptr - pool->start);
      pool->start = pool->blocks->s;
      pool->end = pool->start + pool->blocks->size;
      return 1;
    }
  }
  if (pool->blocks && pool->start == pool->blocks->s) {
    int blockSize = (pool->end - pool->start)*2;
    pool->blocks = pool->mem->realloc_fcn(pool->blocks, offsetof(BLOCK, s) + blockSize * sizeof(XML_Char));
    if (!pool->blocks)
      return 0;
    pool->blocks->size = blockSize;
    pool->ptr = pool->blocks->s + (pool->ptr - pool->start);
    pool->start = pool->blocks->s;
    pool->end = pool->start + blockSize;
  }
  else {
    BLOCK *tem;
    int blockSize = pool->end - pool->start;
    if (blockSize < INIT_BLOCK_SIZE)
      blockSize = INIT_BLOCK_SIZE;
    else
      blockSize *= 2;
    tem = pool->mem->malloc_fcn(offsetof(BLOCK, s) + blockSize * sizeof(XML_Char));
    if (!tem)
      return 0;
    tem->size = blockSize;
    tem->next = pool->blocks;
    pool->blocks = tem;
    if (pool->ptr != pool->start)
      memcpy(tem->s, pool->start, (pool->ptr - pool->start) * sizeof(XML_Char));
    pool->ptr = tem->s + (pool->ptr - pool->start);
    pool->start = tem->s;
    pool->end = tem->s + blockSize;
  }
  return 1;
}

static int
nextScaffoldPart(XML_Parser parser)
{
  CONTENT_SCAFFOLD * me;
  int next;

  if (! dtd.scaffIndex) {
    dtd.scaffIndex = MALLOC(groupSize * sizeof(int));
    if (! dtd.scaffIndex)
      return -1;
    dtd.scaffIndex[0] = 0;
  }

  if (dtd.scaffCount >= dtd.scaffSize) {
    if (dtd.scaffold) {
      dtd.scaffSize *= 2;
      dtd.scaffold = (CONTENT_SCAFFOLD *) REALLOC(dtd.scaffold,
					      dtd.scaffSize * sizeof(CONTENT_SCAFFOLD));
    }
    else {
      dtd.scaffSize = 32;
      dtd.scaffold = (CONTENT_SCAFFOLD *) MALLOC(dtd.scaffSize * sizeof(CONTENT_SCAFFOLD));
    }
    if (! dtd.scaffold)
      return -1;
  }
  next = dtd.scaffCount++;
  me = &dtd.scaffold[next];
  if (dtd.scaffLevel) { 
    CONTENT_SCAFFOLD *parent = &dtd.scaffold[dtd.scaffIndex[dtd.scaffLevel - 1]];
    if (parent->lastchild) {
      dtd.scaffold[parent->lastchild].nextsib = next;
    }
    if (! parent->childcnt)
      parent->firstchild = next;
    parent->lastchild = next;
    parent->childcnt++;
  }
  me->firstchild = me->lastchild = me->childcnt = me->nextsib = 0;
  return next;
}  /* End nextScaffoldPart */

static void
build_node (XML_Parser parser,
	    int src_node,
	    XML_Content *dest,
	    XML_Content **contpos,
	    char **strpos)
{
  dest->type = dtd.scaffold[src_node].type;
  dest->quant = dtd.scaffold[src_node].quant;
  if (dest->type == XML_CTYPE_NAME) {
    const char *src;
    dest->name = *strpos;
    src = dtd.scaffold[src_node].name;
    for (;;) {
      *(*strpos)++ = *src;
      if (! *src)
	break;
      src++;
    }
    dest->numchildren = 0;
    dest->children = 0;
  }
  else {
    unsigned int i;
    int cn;
    dest->numchildren = dtd.scaffold[src_node].childcnt;
    dest->children = *contpos;
    *contpos += dest->numchildren;
    for (i = 0, cn = dtd.scaffold[src_node].firstchild;
	 i < dest->numchildren;
	 i++, cn = dtd.scaffold[cn].nextsib) {
      build_node(parser, cn, &(dest->children[i]), contpos, strpos);
    }
    dest->name = 0;
  }
}  /* End build_node */

static XML_Content *
build_model (XML_Parser parser)
{
  XML_Content *ret;
  XML_Content *cpos;
  char * str;
  int allocsize = dtd.scaffCount * sizeof(XML_Content) + dtd.contentStringLen;
  
  ret = MALLOC(allocsize);
  if (! ret)
    return 0;

  str =  (char *) (&ret[dtd.scaffCount]);
  cpos = &ret[1];

  build_node(parser, 0, ret, &cpos, &str);
  return ret;
}  /* End build_model */

static ELEMENT_TYPE *
getElementType(XML_Parser parser,
	       const ENCODING *enc,
	       const char *ptr,
	       const char *end)
{
  const XML_Char *name = poolStoreString(&dtd.pool, enc, ptr, end);
  ELEMENT_TYPE *ret;

  if (! name)
    return 0;
  ret = (ELEMENT_TYPE *) lookup(&dtd.elementTypes, name, sizeof(ELEMENT_TYPE));
  if (! ret)
    return 0;
  if (ret->name != name)
    poolDiscard(&dtd.pool);
  else {
    poolFinish(&dtd.pool);
    if (!setElementTypePrefix(parser, ret))
      return 0;
  }
  return ret;
}  /* End getElementType */
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 3
a3 2
/* Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd
   See the file COPYING for copying permission.
a4 4
/* $XFree86: xc/extras/expat/lib/xmlparse.c,v 1.3 2003/09/29 23:39:30 alanh Exp $ */

#include <stddef.h>
#include <string.h>                     /* memset(), memcpy() */
d7 4
a10 11

#include "winconfig.h"
#define XMLPARSEAPI(type) type __cdecl
#include "expat.h"
#undef XMLPARSEAPI

#elif defined(MACOS_CLASSIC)

#include "macconfig.h"
#include "expat.h"

d12 1
a12 2

#include <expat_config.h>
d15 1
a15 1
#define XMLPARSEAPI(type) type __cdecl
d21 1
a21 1
#undef XMLPARSEAPI
d25 3
a56 2
#ifdef XML_UNICODE

d58 1
a58 2
#define XML_T(x) (const wchar_t)x
#define XML_L(x) L ## x
a59 6
#define XML_T(x) (const unsigned short)x
#define XML_L(x) x
#endif

#else

a60 2
#define XML_L(x) x

a65 10
/* Handle the case where memmove() doesn't exist. */
#ifndef HAVE_MEMMOVE
#ifdef HAVE_BCOPY
#define memmove(d,s,l) bcopy((s),(d),(l))
#else
#error memmove does not exist on this platform, nor is a substitute available
#endif /* HAVE_BCOPY */
#endif /* HAVE_MEMMOVE */

#include "internal.h"
d80 1
a80 1
  const XML_Memory_Handling_Suite *mem;
a113 2
  const XML_Char *prefix;
  int strLen;
a114 1
  int prefixLen;
a116 13
/* TAG represents an open element.
   The name of the element is stored in both the document and API
   encodings.  The memory buffer 'buf' is a separately-allocated
   memory area which stores the name.  During the XML_Parse()/
   XMLParseBuffer() when the element is open, the memory for the 'raw'
   version of the name (in the document encoding) is shared with the
   document buffer.  If the element is open across calls to
   XML_Parse()/XML_ParseBuffer(), the buffer is re-allocated to
   contain the 'raw' name as well.

   A parser re-uses these structures, maintaining a list of allocated
   TAG objects in a free list.
*/
d118 2
a119 2
  struct tag *parent;           /* parent of this element */
  const char *rawName;          /* tagName in the original encoding */
d121 3
a123 3
  TAG_NAME name;                /* tagName in the API encoding */
  char *buf;                    /* buffer for name components */
  char *bufEnd;                 /* end of the buffer */
d135 2
a136 3
  XML_Bool open;
  XML_Bool is_param;
  XML_Bool is_internal; /* true if declared in internal subset outside PE */
d140 7
a146 7
  enum XML_Content_Type         type;
  enum XML_Content_Quant        quant;
  const XML_Char *              name;
  int                           firstchild;
  int                           lastchild;
  int                           childcnt;
  int                           nextsib;
a148 2
#define INIT_SCAFFOLD_ELEMENTS 32

d161 1
a161 1
  const XML_Memory_Handling_Suite *mem;
d165 1
a165 1
   an attribute has been specified. */
d169 2
a170 2
  XML_Bool maybeTokenized;
  XML_Bool xmlns;
d175 1
a175 1
  XML_Bool isCdata;
d194 2
a195 7
  STRING_POOL entityValuePool;
  /* false once a parameter entity reference has been skipped */
  XML_Bool keepProcessing;
  /* true once an internal or external PE reference has been encountered;
     this includes the reference to an external subset */
  XML_Bool hasParamEntityRefs;
  XML_Bool standalone;
a196 2
  /* indicates if external PE has been read */
  XML_Bool paramEntityRead;
d201 1
a201 1
  XML_Bool in_eldecl;
d217 4
a220 4
typedef enum XML_Error PTRCALL Processor(XML_Parser parser,
                                         const char *start,
                                         const char *end,
                                         const char **endPtr);
a227 4
static Processor externalParEntProcessor;
static Processor externalParEntInitProcessor;
static Processor entityValueProcessor;
static Processor entityValueInitProcessor;
d239 1
a239 2
processXmlDecl(XML_Parser parser, int isGeneralTextEntity,
               const char *, const char *);
d244 1
a244 1
         const char *end, int tok, const char *next, const char **nextPtr);
d249 1
a249 1
          const char *start, const char *end, const char **endPtr);
d251 1
a251 2
doCdataSection(XML_Parser parser, const ENCODING *, const char **startPtr,
               const char *end, const char **nextPtr);
d254 1
a254 2
doIgnoreSection(XML_Parser parser, const ENCODING *, const char **startPtr,
                const char *end, const char **nextPtr);
d256 4
a260 6
static enum XML_Error
storeAtts(XML_Parser parser, const ENCODING *, const char *s,
          TAG_NAME *tagNamePtr, BINDING **bindingsPtr);
static enum XML_Error
addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,
           const XML_Char *uri, BINDING **bindingsPtr);
d263 3
a265 2
                XML_Bool isCdata, XML_Bool isId, const XML_Char *dfltValue,
                XML_Parser parser);
d267 2
a268 2
storeAttributeValue(XML_Parser parser, const ENCODING *, XML_Bool isCdata,
                    const char *, const char *, STRING_POOL *);
d270 2
a271 2
appendAttributeValue(XML_Parser parser, const ENCODING *, XML_Bool isCdata,
                     const char *, const char *, STRING_POOL *);
d273 2
a274 4
getAttributeId(XML_Parser parser, const ENCODING *enc, const char *start,
               const char *end);
static int
setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *);
d276 1
a276 2
storeEntityValue(XML_Parser parser, const ENCODING *enc, const char *start,
                 const char *end);
d278 1
a278 2
reportProcessingInstruction(XML_Parser parser, const ENCODING *enc,
                            const char *start, const char *end);
d280 1
a280 2
reportComment(XML_Parser parser, const ENCODING *enc, const char *start,
              const char *end);
d282 8
a289 2
reportDefault(XML_Parser parser, const ENCODING *enc, const char *start,
              const char *end);
d291 8
a298 15
static const XML_Char * getContext(XML_Parser parser);
static XML_Bool
setContext(XML_Parser parser, const XML_Char *context);

static void FASTCALL normalizePublicId(XML_Char *s);

static DTD * dtdCreate(const XML_Memory_Handling_Suite *ms);
/* do not call if parentParser != NULL */
static void dtdReset(DTD *p, const XML_Memory_Handling_Suite *ms);
static void
dtdDestroy(DTD *p, XML_Bool isDocEntity, const XML_Memory_Handling_Suite *ms);
static int
dtdCopy(DTD *newDtd, const DTD *oldDtd, const XML_Memory_Handling_Suite *ms);
static int
copyEntityTable(HASH_TABLE *, STRING_POOL *, const HASH_TABLE *);
d300 1
a300 27
static NAMED *
lookup(HASH_TABLE *table, KEY name, size_t createSize);
static void FASTCALL
hashTableInit(HASH_TABLE *, const XML_Memory_Handling_Suite *ms);
static void FASTCALL hashTableClear(HASH_TABLE *);
static void FASTCALL hashTableDestroy(HASH_TABLE *);
static void FASTCALL
hashTableIterInit(HASH_TABLE_ITER *, const HASH_TABLE *);
static NAMED * FASTCALL hashTableIterNext(HASH_TABLE_ITER *);

static void FASTCALL
poolInit(STRING_POOL *, const XML_Memory_Handling_Suite *ms);
static void FASTCALL poolClear(STRING_POOL *);
static void FASTCALL poolDestroy(STRING_POOL *);
static XML_Char *
poolAppend(STRING_POOL *pool, const ENCODING *enc,
           const char *ptr, const char *end);
static XML_Char *
poolStoreString(STRING_POOL *pool, const ENCODING *enc,
                const char *ptr, const char *end);
static XML_Bool FASTCALL poolGrow(STRING_POOL *pool);
static const XML_Char * FASTCALL
poolCopyString(STRING_POOL *pool, const XML_Char *s);
static const XML_Char *
poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n);
static const XML_Char * FASTCALL
poolAppendString(STRING_POOL *pool, const XML_Char *s);
d302 1
a302 5
static int FASTCALL nextScaffoldPart(XML_Parser parser);
static XML_Content * build_model(XML_Parser parser);
static ELEMENT_TYPE *
getElementType(XML_Parser parser, const ENCODING *enc,
               const char *ptr, const char *end);
d304 23
a326 7
static XML_Parser
parserCreate(const XML_Char *encodingName,
             const XML_Memory_Handling_Suite *memsuite,
             const XML_Char *nameSep,
             DTD *dtd);
static void
parserInit(XML_Parser parser, const XML_Char *encodingName);
d340 2
a341 3
struct XML_ParserStruct {
  /* The first member must be userData so that the XML_GetUserData
     macro works. */
d345 1
a345 1
  const XML_Memory_Handling_Suite m_mem;
d372 1
a372 2
  XML_Parser m_externalEntityRefHandlerArg;
  XML_SkippedEntityHandler m_skippedEntityHandler;
d382 2
a383 2
  XML_Bool m_ns;
  XML_Bool m_ns_triplets;
d395 1
a395 1
  XML_Bool m_defaultExpandInternalEntities;
d406 3
a408 3
  XML_Bool m_declAttributeIsCdata;
  XML_Bool m_declAttributeIsId;
  DTD *m_dtd;
d423 1
a424 1
  XML_Parser m_parentParser;
a425 2
  XML_Bool m_isParamEntity;
  XML_Bool m_useForeignDTD;
d427 1
d429 1
a429 1
};
d431 34
a464 42
#define MALLOC(s) (parser->m_mem.malloc_fcn((s)))
#define REALLOC(p,s) (parser->m_mem.realloc_fcn((p),(s)))
#define FREE(p) (parser->m_mem.free_fcn((p)))

#define userData (parser->m_userData)
#define handlerArg (parser->m_handlerArg)
#define startElementHandler (parser->m_startElementHandler)
#define endElementHandler (parser->m_endElementHandler)
#define characterDataHandler (parser->m_characterDataHandler)
#define processingInstructionHandler \
        (parser->m_processingInstructionHandler)
#define commentHandler (parser->m_commentHandler)
#define startCdataSectionHandler \
        (parser->m_startCdataSectionHandler)
#define endCdataSectionHandler (parser->m_endCdataSectionHandler)
#define defaultHandler (parser->m_defaultHandler)
#define startDoctypeDeclHandler (parser->m_startDoctypeDeclHandler)
#define endDoctypeDeclHandler (parser->m_endDoctypeDeclHandler)
#define unparsedEntityDeclHandler \
        (parser->m_unparsedEntityDeclHandler)
#define notationDeclHandler (parser->m_notationDeclHandler)
#define startNamespaceDeclHandler \
        (parser->m_startNamespaceDeclHandler)
#define endNamespaceDeclHandler (parser->m_endNamespaceDeclHandler)
#define notStandaloneHandler (parser->m_notStandaloneHandler)
#define externalEntityRefHandler \
        (parser->m_externalEntityRefHandler)
#define externalEntityRefHandlerArg \
        (parser->m_externalEntityRefHandlerArg)
#define internalEntityRefHandler \
        (parser->m_internalEntityRefHandler)
#define skippedEntityHandler (parser->m_skippedEntityHandler)
#define unknownEncodingHandler (parser->m_unknownEncodingHandler)
#define elementDeclHandler (parser->m_elementDeclHandler)
#define attlistDeclHandler (parser->m_attlistDeclHandler)
#define entityDeclHandler (parser->m_entityDeclHandler)
#define xmlDeclHandler (parser->m_xmlDeclHandler)
#define encoding (parser->m_encoding)
#define initEncoding (parser->m_initEncoding)
#define internalEncoding (parser->m_internalEncoding)
#define unknownEncodingMem (parser->m_unknownEncodingMem)
#define unknownEncodingData (parser->m_unknownEncodingData)
d466 50
a515 51
  (parser->m_unknownEncodingHandlerData)
#define unknownEncodingRelease (parser->m_unknownEncodingRelease)
#define protocolEncodingName (parser->m_protocolEncodingName)
#define ns (parser->m_ns)
#define ns_triplets (parser->m_ns_triplets)
#define prologState (parser->m_prologState)
#define processor (parser->m_processor)
#define errorCode (parser->m_errorCode)
#define eventPtr (parser->m_eventPtr)
#define eventEndPtr (parser->m_eventEndPtr)
#define positionPtr (parser->m_positionPtr)
#define position (parser->m_position)
#define openInternalEntities (parser->m_openInternalEntities)
#define defaultExpandInternalEntities \
        (parser->m_defaultExpandInternalEntities)
#define tagLevel (parser->m_tagLevel)
#define buffer (parser->m_buffer)
#define bufferPtr (parser->m_bufferPtr)
#define bufferEnd (parser->m_bufferEnd)
#define parseEndByteIndex (parser->m_parseEndByteIndex)
#define parseEndPtr (parser->m_parseEndPtr)
#define bufferLim (parser->m_bufferLim)
#define dataBuf (parser->m_dataBuf)
#define dataBufEnd (parser->m_dataBufEnd)
#define _dtd (parser->m_dtd)
#define curBase (parser->m_curBase)
#define declEntity (parser->m_declEntity)
#define doctypeName (parser->m_doctypeName)
#define doctypeSysid (parser->m_doctypeSysid)
#define doctypePubid (parser->m_doctypePubid)
#define declAttributeType (parser->m_declAttributeType)
#define declNotationName (parser->m_declNotationName)
#define declNotationPublicId (parser->m_declNotationPublicId)
#define declElementType (parser->m_declElementType)
#define declAttributeId (parser->m_declAttributeId)
#define declAttributeIsCdata (parser->m_declAttributeIsCdata)
#define declAttributeIsId (parser->m_declAttributeIsId)
#define freeTagList (parser->m_freeTagList)
#define freeBindingList (parser->m_freeBindingList)
#define inheritedBindings (parser->m_inheritedBindings)
#define tagStack (parser->m_tagStack)
#define atts (parser->m_atts)
#define attsSize (parser->m_attsSize)
#define nSpecifiedAtts (parser->m_nSpecifiedAtts)
#define idAttIndex (parser->m_idAttIndex)
#define tempPool (parser->m_tempPool)
#define temp2Pool (parser->m_temp2Pool)
#define groupConnector (parser->m_groupConnector)
#define groupSize (parser->m_groupSize)
#define namespaceSeparator (parser->m_namespaceSeparator)
#define parentParser (parser->m_parentParser)
d517 2
a518 3
#define isParamEntity (parser->m_isParamEntity)
#define useForeignDTD (parser->m_useForeignDTD)
#define paramEntityParsing (parser->m_paramEntityParsing)
d521 14
a534 10
#define parsing \
  (parentParser \
    ? \
    (isParamEntity \
      ? \
      (processor != externalParEntInitProcessor) \
      : \
      (processor != externalEntityInitProcessor)) \
    : \
    (processor != prologInitProcessor))
d536 1
a536 2
XML_Parser
XML_ParserCreate(const XML_Char *encodingName)
d541 1
a541 2
XML_Parser
XML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep)
a547 7
static const XML_Char implicitContext[] = {
  'x', 'm', 'l', '=', 'h', 't', 't', 'p', ':', '/', '/',
  'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g', '/',
  'X', 'M', 'L', '/', '1', '9', '9', '8', '/',
  'n', 'a', 'm', 'e', 's', 'p', 'a', 'c', 'e', '\0'
};

d550 17
a566 15
                    const XML_Memory_Handling_Suite *memsuite,
                    const XML_Char *nameSep)
{
  XML_Parser parser = parserCreate(encodingName, memsuite, nameSep, NULL);
  if (parser != NULL && ns) {
    /* implicit context only set for root parser, since child
       parsers (i.e. external entity parsers) will inherit it
    */
    if (!setContext(parser, implicitContext)) {
      XML_ParserFree(parser);
      return NULL;
    }
  }
  return parser;
}
a567 7
static XML_Parser
parserCreate(const XML_Char *encodingName,
             const XML_Memory_Handling_Suite *memsuite,
             const XML_Char *nameSep,
             DTD *dtd)
{
  XML_Parser parser;
d571 5
a575 8
    parser = (XML_Parser)
      memsuite->malloc_fcn(sizeof(struct XML_ParserStruct));
    if (parser != NULL) {
      mtemp = (XML_Memory_Handling_Suite *)&(parser->m_mem);
      mtemp->malloc_fcn = memsuite->malloc_fcn;
      mtemp->realloc_fcn = memsuite->realloc_fcn;
      mtemp->free_fcn = memsuite->free_fcn;
    }
d579 5
a583 7
    parser = (XML_Parser)malloc(sizeof(struct XML_ParserStruct));
    if (parser != NULL) {
      mtemp = (XML_Memory_Handling_Suite *)&(parser->m_mem);
      mtemp->malloc_fcn = malloc;
      mtemp->realloc_fcn = realloc;
      mtemp->free_fcn = free;
    }
d588 52
a639 4

  buffer = NULL;
  bufferLim = NULL;

d641 3
a643 28
  atts = (ATTRIBUTE *)MALLOC(attsSize * sizeof(ATTRIBUTE));
  if (atts == NULL) {
    FREE(parser);
    return NULL;
  }
  dataBuf = (XML_Char *)MALLOC(INIT_DATA_BUF_SIZE * sizeof(XML_Char));
  if (dataBuf == NULL) {
    FREE(atts);
    FREE(parser);
    return NULL;
  }
  dataBufEnd = dataBuf + INIT_DATA_BUF_SIZE;

  if (dtd)
    _dtd = dtd;
  else {
    _dtd = dtdCreate(&parser->m_mem);
    if (_dtd == NULL) {
      FREE(dataBuf);
      FREE(atts);
      FREE(parser);
      return NULL;
    }
  }

  freeBindingList = NULL;
  freeTagList = NULL;

d645 6
a650 5
  groupConnector = NULL;

  unknownEncodingHandler = NULL;
  unknownEncodingHandlerData = NULL;

d652 12
a663 8
  ns = XML_FALSE;
  ns_triplets = XML_FALSE;

  poolInit(&tempPool, &(parser->m_mem));
  poolInit(&temp2Pool, &(parser->m_mem));
  parserInit(parser, encodingName);

  if (encodingName && !protocolEncodingName) {
d665 1
a665 1
    return NULL;
d667 1
d670 2
a671 1
    ns = XML_TRUE;
d674 5
d681 1
d686 1
a686 72
}

static void
parserInit(XML_Parser parser, const XML_Char *encodingName)
{
  processor = prologInitProcessor;
  XmlPrologStateInit(&prologState);
  protocolEncodingName = (encodingName != NULL
                          ? poolCopyString(&tempPool, encodingName)
                          : NULL);
  curBase = NULL;
  XmlInitEncoding(&initEncoding, &encoding, 0);
  userData = NULL;
  handlerArg = NULL;
  startElementHandler = NULL;
  endElementHandler = NULL;
  characterDataHandler = NULL;
  processingInstructionHandler = NULL;
  commentHandler = NULL;
  startCdataSectionHandler = NULL;
  endCdataSectionHandler = NULL;
  defaultHandler = NULL;
  startDoctypeDeclHandler = NULL;
  endDoctypeDeclHandler = NULL;
  unparsedEntityDeclHandler = NULL;
  notationDeclHandler = NULL;
  startNamespaceDeclHandler = NULL;
  endNamespaceDeclHandler = NULL;
  notStandaloneHandler = NULL;
  externalEntityRefHandler = NULL;
  externalEntityRefHandlerArg = parser;
  skippedEntityHandler = NULL;
  elementDeclHandler = NULL;
  attlistDeclHandler = NULL;
  entityDeclHandler = NULL;
  xmlDeclHandler = NULL;
  bufferPtr = buffer;
  bufferEnd = buffer;
  parseEndByteIndex = 0;
  parseEndPtr = NULL;
  declElementType = NULL;
  declAttributeId = NULL;
  declEntity = NULL;
  doctypeName = NULL;
  doctypeSysid = NULL;
  doctypePubid = NULL;
  declAttributeType = NULL;
  declNotationName = NULL;
  declNotationPublicId = NULL;
  declAttributeIsCdata = XML_FALSE;
  declAttributeIsId = XML_FALSE;
  memset(&position, 0, sizeof(POSITION));
  errorCode = XML_ERROR_NONE;
  eventPtr = NULL;
  eventEndPtr = NULL;
  positionPtr = NULL;
  openInternalEntities = 0;
  defaultExpandInternalEntities = XML_TRUE;
  tagLevel = 0;
  tagStack = NULL;
  inheritedBindings = NULL;
  nSpecifiedAtts = 0;
  unknownEncodingMem = NULL;
  unknownEncodingRelease = NULL;
  unknownEncodingData = NULL;
  parentParser = NULL;
#ifdef XML_DTD
  isParamEntity = XML_FALSE;
  useForeignDTD = XML_FALSE;
  paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;
#endif
}
d688 1
a688 3
/* moves list of bindings to freeBindingList */
static void FASTCALL
moveToFreeBindingList(XML_Parser parser, BINDING *bindings)
d690 2
a691 47
  while (bindings) {
    BINDING *b = bindings;
    bindings = bindings->nextTagBinding;
    b->nextTagBinding = freeBindingList;
    freeBindingList = b;
  }
}

XML_Bool
XML_ParserReset(XML_Parser parser, const XML_Char *encodingName)
{
  TAG *tStk;
  if (parentParser)
    return XML_FALSE;
  /* move tagStack to freeTagList */
  tStk = tagStack;
  while (tStk) {
    TAG *tag = tStk;
    tStk = tStk->parent;
    tag->parent = freeTagList;
    moveToFreeBindingList(parser, tag->bindings);
    tag->bindings = NULL;
    freeTagList = tag;
  }
  moveToFreeBindingList(parser, inheritedBindings);
  if (unknownEncodingMem)
    FREE(unknownEncodingMem);
  if (unknownEncodingRelease)
    unknownEncodingRelease(unknownEncodingData);
  poolClear(&tempPool);
  poolClear(&temp2Pool);
  parserInit(parser, encodingName);
  dtdReset(_dtd, &parser->m_mem);
  return setContext(parser, implicitContext);
}

enum XML_Status
XML_SetEncoding(XML_Parser parser, const XML_Char *encodingName)
{
  /* Block after XML_Parse()/XML_ParseBuffer() has been called.
     XXX There's no way for the caller to determine which of the
     XXX possible error cases caused the XML_STATUS_ERROR return.
  */
  if (parsing)
    return XML_STATUS_ERROR;
  if (encodingName == NULL)
    protocolEncodingName = NULL;
d695 1
a695 1
      return XML_STATUS_ERROR;
d697 1
a697 1
  return XML_STATUS_OK;
d700 3
a702 4
XML_Parser
XML_ExternalEntityParserCreate(XML_Parser oldParser,
                               const XML_Char *context,
                               const XML_Char *encodingName)
d705 1
a705 2
  DTD *newDtd = NULL;
  DTD *oldDtd = _dtd;
d709 1
a709 2
  XML_ProcessingInstructionHandler oldProcessingInstructionHandler
      = processingInstructionHandler;
d711 2
a712 4
  XML_StartCdataSectionHandler oldStartCdataSectionHandler
      = startCdataSectionHandler;
  XML_EndCdataSectionHandler oldEndCdataSectionHandler
      = endCdataSectionHandler;
d714 1
a714 2
  XML_UnparsedEntityDeclHandler oldUnparsedEntityDeclHandler
      = unparsedEntityDeclHandler;
d716 2
a717 4
  XML_StartNamespaceDeclHandler oldStartNamespaceDeclHandler
      = startNamespaceDeclHandler;
  XML_EndNamespaceDeclHandler oldEndNamespaceDeclHandler
      = endNamespaceDeclHandler;
d719 2
a720 5
  XML_ExternalEntityRefHandler oldExternalEntityRefHandler
      = externalEntityRefHandler;
  XML_SkippedEntityHandler oldSkippedEntityHandler = skippedEntityHandler;
  XML_UnknownEncodingHandler oldUnknownEncodingHandler
      = unknownEncodingHandler;
d729 2
a730 2
  XML_Bool oldDefaultExpandInternalEntities = defaultExpandInternalEntities;
  XML_Parser oldExternalEntityRefHandlerArg = externalEntityRefHandlerArg;
d732 1
a732 2
  enum XML_ParamEntityParsing oldParamEntityParsing = paramEntityParsing;
  int oldInEntityValue = prologState.inEntityValue;
d734 1
a734 1
  XML_Bool oldns_triplets = ns_triplets;
a735 10
#ifdef XML_DTD
  if (!context)
    newDtd = oldDtd;
#endif /* XML_DTD */

  /* Note that the magical uses of the pre-processor to make field
     access look more like C++ require that `parser' be overwritten
     here.  This makes this function more painful to follow than it
     would be otherwise.
  */
d738 1
d740 2
a741 1
    parser = parserCreate(encodingName, &parser->m_mem, tmp, newDtd);
d744 2
a745 1
    parser = parserCreate(encodingName, &parser->m_mem, NULL, newDtd);
d749 1
a749 1
    return NULL;
a764 1
  skippedEntityHandler = oldSkippedEntityHandler;
a779 1
  parentParser = oldParser;
a781 1
  prologState.inEntityValue = oldInEntityValue;
d784 1
a784 2
    if (!dtdCopy(_dtd, oldDtd, &parser->m_mem)
      || !setContext(parser, context)) {
d786 1
a786 1
      return NULL;
d792 2
a793 8
    /* The DTD instance referenced by _dtd is shared between the document's
       root parser and external PE parsers, therefore one does not need to
       call setContext. In addition, one also *must* not call setContext,
       because this would overwrite existing prefix->binding pointers in
       _dtd with ones that get destroyed with the external PE parser.
       This would leave those prefixes with dangling pointers.
    */
    isParamEntity = XML_TRUE;
d795 2
a796 1
    processor = externalParEntInitProcessor;
d802 2
a803 2
static void FASTCALL
destroyBindings(BINDING *bindings, XML_Parser parser)
d815 1
a815 2
void
XML_ParserFree(XML_Parser parser)
d819 3
a821 3
    if (tagStack == NULL) {
      if (freeTagList == NULL)
        break;
d823 1
a823 1
      freeTagList = NULL;
d836 5
a840 6
  /* external parameter entity parsers share the DTD structure
     parser->m_dtd with the root parser, so we must not destroy it
  */
  if (!isParamEntity && _dtd)
#else
  if (_dtd)
d842 1
a842 1
    dtdDestroy(_dtd, (XML_Bool)!parentParser, &parser->m_mem);
d856 1
a856 2
void
XML_UseParserAsHandlerArg(XML_Parser parser)
a860 14
enum XML_Error
XML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD)
{
#ifdef XML_DTD
  /* block after XML_Parse()/XML_ParseBuffer() has been called */
  if (parsing)
    return XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING;
  useForeignDTD = useDTD;
  return XML_ERROR_NONE;
#else
  return XML_ERROR_FEATURE_REQUIRES_XML_DTD;
#endif
}

d862 2
a863 6
XML_SetReturnNSTriplet(XML_Parser parser, int do_nst)
{
  /* block after XML_Parse()/XML_ParseBuffer() has been called */
  if (parsing)
    return;
  ns_triplets = do_nst ? XML_TRUE : XML_FALSE;
d866 1
a866 2
void
XML_SetUserData(XML_Parser parser, void *p)
d874 1
a874 2
enum XML_Status
XML_SetBase(XML_Parser parser, const XML_Char *p)
d877 1
a877 1
    p = poolCopyString(&_dtd->pool, p);
d879 1
a879 1
      return XML_STATUS_ERROR;
d883 2
a884 2
    curBase = NULL;
  return XML_STATUS_OK;
d887 1
a887 2
const XML_Char *
XML_GetBase(XML_Parser parser)
d892 1
a892 2
int
XML_GetSpecifiedAttributeCount(XML_Parser parser)
d897 1
a897 2
int
XML_GetIdAttributeIndex(XML_Parser parser)
d902 3
a904 4
void
XML_SetElementHandler(XML_Parser parser,
                      XML_StartElementHandler start,
                      XML_EndElementHandler end)
d910 2
a911 3
void
XML_SetStartElementHandler(XML_Parser parser,
                           XML_StartElementHandler start) {
d915 2
a916 3
void
XML_SetEndElementHandler(XML_Parser parser,
                         XML_EndElementHandler end) {
d920 2
a921 3
void
XML_SetCharacterDataHandler(XML_Parser parser,
                            XML_CharacterDataHandler handler)
d926 2
a927 3
void
XML_SetProcessingInstructionHandler(XML_Parser parser,
                                    XML_ProcessingInstructionHandler handler)
d932 2
a933 3
void
XML_SetCommentHandler(XML_Parser parser,
                      XML_CommentHandler handler)
d938 3
a940 4
void
XML_SetCdataSectionHandler(XML_Parser parser,
                           XML_StartCdataSectionHandler start,
                           XML_EndCdataSectionHandler end)
d946 2
a947 3
void
XML_SetStartCdataSectionHandler(XML_Parser parser,
                                XML_StartCdataSectionHandler start) {
d951 2
a952 3
void
XML_SetEndCdataSectionHandler(XML_Parser parser,
                              XML_EndCdataSectionHandler end) {
d956 2
a957 3
void
XML_SetDefaultHandler(XML_Parser parser,
                      XML_DefaultHandler handler)
d960 1
a960 1
  defaultExpandInternalEntities = XML_FALSE;
d963 2
a964 3
void
XML_SetDefaultHandlerExpand(XML_Parser parser,
                            XML_DefaultHandler handler)
d967 1
a967 1
  defaultExpandInternalEntities = XML_TRUE;
d970 3
a972 4
void
XML_SetDoctypeDeclHandler(XML_Parser parser,
                          XML_StartDoctypeDeclHandler start,
                          XML_EndDoctypeDeclHandler end)
d978 2
a979 3
void
XML_SetStartDoctypeDeclHandler(XML_Parser parser,
                               XML_StartDoctypeDeclHandler start) {
d983 2
a984 3
void
XML_SetEndDoctypeDeclHandler(XML_Parser parser,
                             XML_EndDoctypeDeclHandler end) {
d988 2
a989 3
void
XML_SetUnparsedEntityDeclHandler(XML_Parser parser,
                                 XML_UnparsedEntityDeclHandler handler)
d994 2
a995 3
void
XML_SetNotationDeclHandler(XML_Parser parser,
                           XML_NotationDeclHandler handler)
d1000 3
a1002 4
void
XML_SetNamespaceDeclHandler(XML_Parser parser,
                            XML_StartNamespaceDeclHandler start,
                            XML_EndNamespaceDeclHandler end)
d1008 2
a1009 3
void
XML_SetStartNamespaceDeclHandler(XML_Parser parser,
                                 XML_StartNamespaceDeclHandler start) {
d1013 2
a1014 3
void
XML_SetEndNamespaceDeclHandler(XML_Parser parser,
                               XML_EndNamespaceDeclHandler end) {
d1018 3
a1020 3
void
XML_SetNotStandaloneHandler(XML_Parser parser,
                            XML_NotStandaloneHandler handler)
d1025 2
a1026 3
void
XML_SetExternalEntityRefHandler(XML_Parser parser,
                                XML_ExternalEntityRefHandler handler)
d1031 1
a1031 2
void
XML_SetExternalEntityRefHandlerArg(XML_Parser parser, void *arg)
d1034 1
a1034 1
    externalEntityRefHandlerArg = (XML_Parser)arg;
d1039 3
a1041 11
void
XML_SetSkippedEntityHandler(XML_Parser parser,
                            XML_SkippedEntityHandler handler)
{
  skippedEntityHandler = handler;
}

void
XML_SetUnknownEncodingHandler(XML_Parser parser,
                              XML_UnknownEncodingHandler handler,
                              void *data)
d1047 2
a1048 3
void
XML_SetElementDeclHandler(XML_Parser parser,
                          XML_ElementDeclHandler eldecl)
d1053 2
a1054 3
void
XML_SetAttlistDeclHandler(XML_Parser parser,
                          XML_AttlistDeclHandler attdecl)
d1059 2
a1060 3
void
XML_SetEntityDeclHandler(XML_Parser parser,
                         XML_EntityDeclHandler handler)
d1065 2
a1066 3
void
XML_SetXmlDeclHandler(XML_Parser parser,
                      XML_XmlDeclHandler handler) {
d1070 2
a1071 3
int
XML_SetParamEntityParsing(XML_Parser parser,
                          enum XML_ParamEntityParsing peParsing)
a1072 3
  /* block after XML_Parse()/XML_ParseBuffer() has been called */
  if (parsing)
    return 0;
d1074 1
a1074 1
  paramEntityParsing = peParsing;
d1077 1
a1077 1
  return peParsing == XML_PARAM_ENTITY_PARSING_NEVER;
d1081 1
a1081 2
enum XML_Status
XML_Parse(XML_Parser parser, const char *s, int len, int isFinal)
d1085 1
a1085 1
      return XML_STATUS_OK;
d1089 1
a1089 1
      return XML_STATUS_OK;
d1092 1
a1092 1
    return XML_STATUS_ERROR;
d1103 1
a1103 1
        return XML_STATUS_OK;
d1106 1
a1106 1
      return XML_STATUS_ERROR;
d1112 1
a1112 1
      return XML_STATUS_ERROR;
a1114 1
    positionPtr = end;
d1117 11
a1127 18
      if (buffer == NULL || nLeftOver > bufferLim - buffer) {
        /* FIXME avoid integer overflow */
        char *temp;
        temp = (buffer == NULL
                ? (char *)MALLOC(len * 2)
                : (char *)REALLOC(buffer, len * 2));
        if (temp == NULL) {
          errorCode = XML_ERROR_NO_MEMORY;
          return XML_STATUS_ERROR;
        }
        buffer = temp;
        if (!buffer) {
          errorCode = XML_ERROR_NO_MEMORY;
          eventPtr = eventEndPtr = NULL;
          processor = errorProcessor;
          return XML_STATUS_ERROR;
        }
        bufferLim = buffer + len * 2;
d1133 1
a1133 1
    return XML_STATUS_OK;
d1137 2
a1138 7
    void *buff = XML_GetBuffer(parser, len);
    if (buff == NULL)
      return XML_STATUS_ERROR;
    else {
      memcpy(buff, s, len);
      return XML_ParseBuffer(parser, len, isFinal);
    }
d1142 1
a1142 2
enum XML_Status
XML_ParseBuffer(XML_Parser parser, int len, int isFinal)
d1149 1
a1149 1
                        isFinal ? (const char **)NULL : &bufferPtr);
d1151 1
a1151 1
    if (!isFinal) {
d1153 1
a1153 3
      positionPtr = bufferPtr;
    }
    return XML_STATUS_OK;
d1158 1
a1158 1
    return XML_STATUS_ERROR;
d1162 1
a1162 2
void *
XML_GetBuffer(XML_Parser parser, int len)
d1177 4
a1180 4
        int offset = (bufferPtr - buffer) - keep;
        memmove(buffer, &buffer[offset], bufferEnd - bufferPtr + keep);
        bufferEnd -= offset;
        bufferPtr -= offset;
d1192 1
a1192 1
        bufferSize = INIT_BUFFER_SIZE;
d1194 1
a1194 1
        bufferSize *= 2;
d1196 1
a1196 1
      newBuf = (char *)MALLOC(bufferSize);
d1198 2
a1199 2
        errorCode = XML_ERROR_NO_MEMORY;
        return NULL;
d1204 8
a1211 8
        int keep = bufferPtr - buffer;
        if (keep > XML_CONTEXT_BYTES)
          keep = XML_CONTEXT_BYTES;
        memcpy(newBuf, &bufferPtr[-keep], bufferEnd - bufferPtr + keep);
        FREE(buffer);
        buffer = newBuf;
        bufferEnd = buffer + (bufferEnd - bufferPtr) + keep;
        bufferPtr = buffer + keep;
d1214 2
a1215 2
        bufferEnd = newBuf + (bufferEnd - bufferPtr);
        bufferPtr = buffer = newBuf;
d1219 2
a1220 2
        memcpy(newBuf, bufferPtr, bufferEnd - bufferPtr);
        FREE(buffer);
d1230 1
a1230 2
enum XML_Error
XML_GetErrorCode(XML_Parser parser)
d1235 1
a1235 2
long
XML_GetCurrentByteIndex(XML_Parser parser)
d1242 1
a1242 2
int
XML_GetCurrentByteCount(XML_Parser parser)
d1249 1
a1249 2
const char *
XML_GetInputContext(XML_Parser parser, int *offset, int *size)
d1261 1
a1261 2
int
XML_GetCurrentLineNumber(XML_Parser parser)
d1270 1
a1270 2
int
XML_GetCurrentColumnNumber(XML_Parser parser)
d1279 1
a1279 26
void
XML_FreeContentModel(XML_Parser parser, XML_Content *model)
{
  FREE(model);
}

void *
XML_MemMalloc(XML_Parser parser, size_t size)
{
  return MALLOC(size);
}

void *
XML_MemRealloc(XML_Parser parser, void *ptr, size_t size)
{
  return REALLOC(ptr, size);
}

void
XML_MemFree(XML_Parser parser, void *ptr)
{
  FREE(ptr);
}

void
XML_DefaultCurrent(XML_Parser parser)
d1284 3
a1286 3
                    internalEncoding,
                    openInternalEntities->internalEventPtr,
                    openInternalEntities->internalEventEndPtr);
d1292 1
a1292 2
const XML_LChar *
XML_ErrorString(enum XML_Error code)
d1296 23
a1318 26
    XML_L("out of memory"),
    XML_L("syntax error"),
    XML_L("no element found"),
    XML_L("not well-formed (invalid token)"),
    XML_L("unclosed token"),
    XML_L("partial character"),
    XML_L("mismatched tag"),
    XML_L("duplicate attribute"),
    XML_L("junk after document element"),
    XML_L("illegal parameter entity reference"),
    XML_L("undefined entity"),
    XML_L("recursive entity reference"),
    XML_L("asynchronous entity"),
    XML_L("reference to invalid character number"),
    XML_L("reference to binary entity"),
    XML_L("reference to external entity in attribute"),
    XML_L("xml declaration not at start of external entity"),
    XML_L("unknown encoding"),
    XML_L("encoding specified in XML declaration is incorrect"),
    XML_L("unclosed CDATA section"),
    XML_L("error in processing external entity reference"),
    XML_L("document is not standalone"),
    XML_L("unexpected parser state - please send a bug report"),
    XML_L("entity declared in parameter entity"),
    XML_L("requested feature requires XML_DTD support in Expat"),
    XML_L("cannot change setting once parsing has begun")
d1322 1
a1322 1
  return NULL;
d1327 1
a1327 16

  /* V1 is used to string-ize the version number. However, it would
     string-ize the actual version macro *names* unless we get them
     substituted before being passed to V1. CPP is defined to expand
     a macro, then rescan for more expansions. Thus, we use V2 to expand
     the version macros, then CPP will expand the resulting V1() macro
     with the correct numerals. */
  /* ### I'm assuming cpp is portable in this respect... */

#define V1(a,b,c) XML_L(#a)XML_L(".")XML_L(#b)XML_L(".")XML_L(#c)
#define V2(a,b,c) XML_L("expat_")V1(a,b,c)

  return V2(XML_MAJOR_VERSION, XML_MINOR_VERSION, XML_MICRO_VERSION);

#undef V1
#undef V2
d1331 1
a1331 2
XML_ExpatVersionInfo(void)
{
d1341 7
a1347 28
const XML_Feature *
XML_GetFeatureList(void)
{
  static XML_Feature features[] = {
    {XML_FEATURE_SIZEOF_XML_CHAR,  XML_L("sizeof(XML_Char)")},
    {XML_FEATURE_SIZEOF_XML_LCHAR, XML_L("sizeof(XML_LChar)")},
#ifdef XML_UNICODE
    {XML_FEATURE_UNICODE,          XML_L("XML_UNICODE")},
#endif
#ifdef XML_UNICODE_WCHAR_T
    {XML_FEATURE_UNICODE_WCHAR_T,  XML_L("XML_UNICODE_WCHAR_T")},
#endif
#ifdef XML_DTD
    {XML_FEATURE_DTD,              XML_L("XML_DTD")},
#endif
#ifdef XML_CONTEXT_BYTES
    {XML_FEATURE_CONTEXT_BYTES,    XML_L("XML_CONTEXT_BYTES"),
     XML_CONTEXT_BYTES},
#endif
#ifdef XML_MIN_SIZE
    {XML_FEATURE_MIN_SIZE,         XML_L("XML_MIN_SIZE")},
#endif
    {XML_FEATURE_END,              NULL}
  };

  features[0].value = sizeof(XML_Char);
  features[1].value = sizeof(XML_LChar);
  return features;
d1350 5
a1354 70
/* Initially tag->rawName always points into the parse buffer;
   for those TAG instances opened while the current parse buffer was
   processed, and not yet closed, we need to store tag->rawName in a more
   permanent location, since the parse buffer is about to be discarded.
*/
static XML_Bool
storeRawNames(XML_Parser parser)
{
  TAG *tag = tagStack;
  while (tag) {
    int bufSize;
    int nameLen = sizeof(XML_Char) * (tag->name.strLen + 1);
    char *rawNameBuf = tag->buf + nameLen;
    /* Stop if already stored.  Since tagStack is a stack, we can stop
       at the first entry that has already been copied; everything
       below it in the stack is already been accounted for in a
       previous call to this function.
    */
    if (tag->rawName == rawNameBuf)
      break;
    /* For re-use purposes we need to ensure that the
       size of tag->buf is a multiple of sizeof(XML_Char).
    */
    bufSize = nameLen + ROUND_UP(tag->rawNameLength, sizeof(XML_Char));
    if (bufSize > tag->bufEnd - tag->buf) {
      char *temp = (char *)REALLOC(tag->buf, bufSize);
      if (temp == NULL)
        return XML_FALSE;
      /* if tag->name.str points to tag->buf (only when namespace
         processing is off) then we have to update it
      */
      if (tag->name.str == (XML_Char *)tag->buf)
        tag->name.str = (XML_Char *)temp;
      /* if tag->name.localPart is set (when namespace processing is on)
         then update it as well, since it will always point into tag->buf
      */
      if (tag->name.localPart)
        tag->name.localPart = (XML_Char *)temp + (tag->name.localPart -
                                                  (XML_Char *)tag->buf);
      tag->buf = temp;
      tag->bufEnd = temp + bufSize;
      rawNameBuf = temp + nameLen;
    }
    memcpy(rawNameBuf, tag->rawName, tag->rawNameLength);
    tag->rawName = rawNameBuf;
    tag = tag->parent;
  }
  return XML_TRUE;
}

static enum XML_Error PTRCALL
contentProcessor(XML_Parser parser,
                 const char *start,
                 const char *end,
                 const char **endPtr)
{
  enum XML_Error result =
    doContent(parser, 0, encoding, start, end, endPtr);
  if (result != XML_ERROR_NONE)
    return result;
  if (!storeRawNames(parser))
    return XML_ERROR_NO_MEMORY;
  return result;
}

static enum XML_Error PTRCALL
externalEntityInitProcessor(XML_Parser parser,
                            const char *start,
                            const char *end,
                            const char **endPtr)
d1363 5
a1367 5
static enum XML_Error PTRCALL
externalEntityInitProcessor2(XML_Parser parser,
                             const char *start,
                             const char *end,
                             const char **endPtr)
d1369 1
a1369 1
  const char *next = start; /* XmlContentTok doesn't always set the last arg */
a1372 9
    /* If we are at the end of the buffer, this would cause the next stage,
       i.e. externalEntityInitProcessor3, to pass control directly to
       doContent (by detecting XML_TOK_NONE) without processing any xml text
       declaration - causing the error XML_ERROR_MISPLACED_XML_PI in doContent.
    */
    if (next == end && endPtr) {
      *endPtr = next;
      return XML_ERROR_NONE;
    }
d1394 5
a1398 5
static enum XML_Error PTRCALL
externalEntityInitProcessor3(XML_Parser parser,
                             const char *start,
                             const char *end,
                             const char **endPtr)
d1400 1
a1400 1
  const char *next = start; /* XmlContentTok doesn't always set the last arg */
d1407 1
a1407 1
        return result;
d1428 1
a1428 1
  return externalEntityContentProcessor(parser, start, end, endPtr);
d1431 5
a1435 5
static enum XML_Error PTRCALL
externalEntityContentProcessor(XML_Parser parser,
                               const char *start,
                               const char *end,
                               const char **endPtr)
d1437 1
a1437 7
  enum XML_Error result =
    doContent(parser, 1, encoding, start, end, endPtr);
  if (result != XML_ERROR_NONE)
    return result;
  if (!storeRawNames(parser))
    return XML_ERROR_NO_MEMORY;
  return result;
d1442 5
a1446 5
          int startTagLevel,
          const ENCODING *enc,
          const char *s,
          const char *end,
          const char **nextPtr)
a1447 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d1466 2
a1467 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d1471 2
a1472 2
        XML_Char c = 0xA;
        characterDataHandler(handlerArg, &c, 1);
d1475 1
a1475 1
        reportDefault(parser, enc, s, end);
d1477 1
a1477 1
        return XML_ERROR_NO_ELEMENTS;
d1479 1
a1479 1
        return XML_ERROR_ASYNC_ENTITY;
d1483 2
a1484 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d1487 3
a1489 3
        if (tagLevel != startTagLevel)
          return XML_ERROR_ASYNC_ENTITY;
        return XML_ERROR_NONE;
d1497 2
a1498 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d1503 2
a1504 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d1509 80
a1588 85
        const XML_Char *name;
        ENTITY *entity;
        XML_Char ch = (XML_Char) XmlPredefinedEntityName(enc,
                                              s + enc->minBytesPerChar,
                                              next - enc->minBytesPerChar);
        if (ch) {
          if (characterDataHandler)
            characterDataHandler(handlerArg, &ch, 1);
          else if (defaultHandler)
            reportDefault(parser, enc, s, next);
          break;
        }
        name = poolStoreString(&dtd->pool, enc,
                                s + enc->minBytesPerChar,
                                next - enc->minBytesPerChar);
        if (!name)
          return XML_ERROR_NO_MEMORY;
        entity = (ENTITY *)lookup(&dtd->generalEntities, name, 0);
        poolDiscard(&dtd->pool);
        /* First, determine if a check for an existing declaration is needed;
           if yes, check that the entity exists, and that it is internal,
           otherwise call the skipped entity or default handler.
        */
        if (!dtd->hasParamEntityRefs || dtd->standalone) {
          if (!entity)
            return XML_ERROR_UNDEFINED_ENTITY;
          else if (!entity->is_internal)
            return XML_ERROR_ENTITY_DECLARED_IN_PE;
        }
        else if (!entity) {
          if (skippedEntityHandler)
            skippedEntityHandler(handlerArg, name, 0);
          else if (defaultHandler)
            reportDefault(parser, enc, s, next);
          break;
        }
        if (entity->open)
          return XML_ERROR_RECURSIVE_ENTITY_REF;
        if (entity->notation)
          return XML_ERROR_BINARY_ENTITY_REF;
        if (entity->textPtr) {
          enum XML_Error result;
          OPEN_INTERNAL_ENTITY openEntity;
          if (!defaultExpandInternalEntities) {
            if (skippedEntityHandler)
              skippedEntityHandler(handlerArg, entity->name, 0);
            else if (defaultHandler)
              reportDefault(parser, enc, s, next);
            break;
          }
          entity->open = XML_TRUE;
          openEntity.next = openInternalEntities;
          openInternalEntities = &openEntity;
          openEntity.entity = entity;
          openEntity.internalEventPtr = NULL;
          openEntity.internalEventEndPtr = NULL;
          result = doContent(parser,
                             tagLevel,
                             internalEncoding,
                             (char *)entity->textPtr,
                             (char *)(entity->textPtr + entity->textLen),
                             0);
          entity->open = XML_FALSE;
          openInternalEntities = openEntity.next;
          if (result)
            return result;
        }
        else if (externalEntityRefHandler) {
          const XML_Char *context;
          entity->open = XML_TRUE;
          context = getContext(parser);
          entity->open = XML_FALSE;
          if (!context)
            return XML_ERROR_NO_MEMORY;
          if (!externalEntityRefHandler((XML_Parser)externalEntityRefHandlerArg,
                                        context,
                                        entity->base,
                                        entity->systemId,
                                        entity->publicId))
            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
          poolDiscard(&tempPool);
        }
        else if (defaultHandler)
          reportDefault(parser, enc, s, next);
        break;
d1590 1
a1591 2
      /* fall through */
    case XML_TOK_START_TAG_WITH_ATTS:
d1593 79
a1671 64
        TAG *tag;
        enum XML_Error result;
        XML_Char *toPtr;
        if (freeTagList) {
          tag = freeTagList;
          freeTagList = freeTagList->parent;
        }
        else {
          tag = (TAG *)MALLOC(sizeof(TAG));
          if (!tag)
            return XML_ERROR_NO_MEMORY;
          tag->buf = (char *)MALLOC(INIT_TAG_BUF_SIZE);
          if (!tag->buf) {
            FREE(tag);
            return XML_ERROR_NO_MEMORY;
          }
          tag->bufEnd = tag->buf + INIT_TAG_BUF_SIZE;
        }
        tag->bindings = NULL;
        tag->parent = tagStack;
        tagStack = tag;
        tag->name.localPart = NULL;
        tag->name.prefix = NULL;
        tag->rawName = s + enc->minBytesPerChar;
        tag->rawNameLength = XmlNameLength(enc, tag->rawName);
        ++tagLevel;
        {
          const char *rawNameEnd = tag->rawName + tag->rawNameLength;
          const char *fromPtr = tag->rawName;
          toPtr = (XML_Char *)tag->buf;
          for (;;) {
            int bufSize;
            int convLen;
            XmlConvert(enc,
                       &fromPtr, rawNameEnd,
                       (ICHAR **)&toPtr, (ICHAR *)tag->bufEnd - 1);
            convLen = toPtr - (XML_Char *)tag->buf;
            if (fromPtr == rawNameEnd) {
              tag->name.strLen = convLen;
              break;
            }
            bufSize = (tag->bufEnd - tag->buf) << 1;
            {
              char *temp = (char *)REALLOC(tag->buf, bufSize);
              if (temp == NULL)
                return XML_ERROR_NO_MEMORY;
              tag->buf = temp;
              tag->bufEnd = temp + bufSize;
              toPtr = (XML_Char *)temp + convLen;
            }
          }
        }
        tag->name.str = (XML_Char *)tag->buf;
        *toPtr = XML_T('\0');
        result = storeAtts(parser, enc, s, &(tag->name), &(tag->bindings));
        if (result)
          return result;
        if (startElementHandler)
          startElementHandler(handlerArg, tag->name.str,
                              (const XML_Char **)atts);
        else if (defaultHandler)
          reportDefault(parser, enc, s, next);
        poolClear(&tempPool);
        break;
d1673 1
d1675 31
a1705 39
      /* fall through */
    case XML_TOK_EMPTY_ELEMENT_WITH_ATTS:
      {
        const char *rawName = s + enc->minBytesPerChar;
        enum XML_Error result;
        BINDING *bindings = NULL;
        XML_Bool noElmHandlers = XML_TRUE;
        TAG_NAME name;
        name.str = poolStoreString(&tempPool, enc, rawName,
                                   rawName + XmlNameLength(enc, rawName));
        if (!name.str)
          return XML_ERROR_NO_MEMORY;
        poolFinish(&tempPool);
        result = storeAtts(parser, enc, s, &name, &bindings);
        if (result)
          return result;
        poolFinish(&tempPool);
        if (startElementHandler) {
          startElementHandler(handlerArg, name.str, (const XML_Char **)atts);
          noElmHandlers = XML_FALSE;
        }
        if (endElementHandler) {
          if (startElementHandler)
            *eventPP = *eventEndPP;
          endElementHandler(handlerArg, name.str);
          noElmHandlers = XML_FALSE;
        }
        if (noElmHandlers && defaultHandler)
          reportDefault(parser, enc, s, next);
        poolClear(&tempPool);
        while (bindings) {
          BINDING *b = bindings;
          if (endNamespaceDeclHandler)
            endNamespaceDeclHandler(handlerArg, b->prefix->name);
          bindings = bindings->nextTagBinding;
          b->nextTagBinding = freeBindingList;
          freeBindingList = b;
          b->prefix->binding = b->prevPrefixBinding;
        }
d1707 2
d1710 1
a1710 1
        return epilogProcessor(parser, next, end, nextPtr);
d1716 36
a1751 49
        int len;
        const char *rawName;
        TAG *tag = tagStack;
        tagStack = tag->parent;
        tag->parent = freeTagList;
        freeTagList = tag;
        rawName = s + enc->minBytesPerChar*2;
        len = XmlNameLength(enc, rawName);
        if (len != tag->rawNameLength
            || memcmp(tag->rawName, rawName, len) != 0) {
          *eventPP = rawName;
          return XML_ERROR_TAG_MISMATCH;
        }
        --tagLevel;
        if (endElementHandler) {
          const XML_Char *localPart;
          const XML_Char *prefix;
          XML_Char *uri;
          localPart = tag->name.localPart;
          if (ns && localPart) {
            /* localPart and prefix may have been overwritten in
               tag->name.str, since this points to the binding->uri
               buffer which gets re-used; so we have to add them again
            */
            uri = (XML_Char *)tag->name.str + tag->name.uriLen;
            /* don't need to check for space - already done in storeAtts() */
            while (*localPart) *uri++ = *localPart++;
            prefix = (XML_Char *)tag->name.prefix;
            if (ns_triplets && prefix) {
              *uri++ = namespaceSeparator;
              while (*prefix) *uri++ = *prefix++;
             }
            *uri = XML_T('\0');
          }
          endElementHandler(handlerArg, tag->name.str);
        }
        else if (defaultHandler)
          reportDefault(parser, enc, s, next);
        while (tag->bindings) {
          BINDING *b = tag->bindings;
          if (endNamespaceDeclHandler)
            endNamespaceDeclHandler(handlerArg, b->prefix->name);
          tag->bindings = tag->bindings->nextTagBinding;
          b->nextTagBinding = freeBindingList;
          freeBindingList = b;
          b->prefix->binding = b->prevPrefixBinding;
        }
        if (tagLevel == 0)
          return epilogProcessor(parser, next, end, nextPtr);
d1756 9
a1764 9
        int n = XmlCharRefNumber(enc, s);
        if (n < 0)
          return XML_ERROR_BAD_CHAR_REF;
        if (characterDataHandler) {
          XML_Char buf[XML_ENCODE_MAX];
          characterDataHandler(handlerArg, buf, XmlEncode(n, (ICHAR *)buf));
        }
        else if (defaultHandler)
          reportDefault(parser, enc, s, next);
d1771 2
a1772 2
        XML_Char c = 0xA;
        characterDataHandler(handlerArg, &c, 1);
d1775 1
a1775 1
        reportDefault(parser, enc, s, next);
d1779 3
a1781 3
        enum XML_Error result;
        if (startCdataSectionHandler)
          startCdataSectionHandler(handlerArg);
d1783 13
a1795 14
        /* Suppose you doing a transformation on a document that involves
           changing only the character data.  You set up a defaultHandler
           and a characterDataHandler.  The defaultHandler simply copies
           characters through.  The characterDataHandler does the
           transformation and writes the characters out escaping them as
           necessary.  This case will fail to work if we leave out the
           following two lines (because & and < inside CDATA sections will
           be incorrectly escaped).

           However, now we have a start/endCdataSectionHandler, so it seems
           easier to let the user deal with this.
        */
        else if (characterDataHandler)
          characterDataHandler(handlerArg, dataBuf, 0);
d1797 7
a1803 7
        else if (defaultHandler)
          reportDefault(parser, enc, s, next);
        result = doCdataSection(parser, enc, &next, end, nextPtr);
        if (!next) {
          processor = cdataSectionProcessor;
          return result;
        }
d1808 2
a1809 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d1812 9
a1820 10
        if (MUST_CONVERT(enc, s)) {
          ICHAR *dataPtr = (ICHAR *)dataBuf;
          XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)dataBufEnd);
          characterDataHandler(handlerArg, dataBuf,
                               dataPtr - (ICHAR *)dataBuf);
        }
        else
          characterDataHandler(handlerArg,
                               (XML_Char *)s,
                               (XML_Char *)end - (XML_Char *)s);
d1823 1
a1823 1
        reportDefault(parser, enc, s, end);
d1826 1
a1826 1
        return XML_ERROR_NO_ELEMENTS;
d1829 2
a1830 2
        *eventPP = end;
        return XML_ERROR_ASYNC_ENTITY;
d1835 15
a1849 16
        if (MUST_CONVERT(enc, s)) {
          for (;;) {
            ICHAR *dataPtr = (ICHAR *)dataBuf;
            XmlConvert(enc, &s, next, &dataPtr, (ICHAR *)dataBufEnd);
            *eventEndPP = s;
            characterDataHandler(handlerArg, dataBuf,
                                 dataPtr - (ICHAR *)dataBuf);
            if (s == next)
              break;
            *eventPP = s;
          }
        }
        else
          characterDataHandler(handlerArg,
                               (XML_Char *)s,
                               (XML_Char *)next - (XML_Char *)s);
d1852 1
a1852 1
        reportDefault(parser, enc, s, next);
d1856 1
a1856 1
        return XML_ERROR_NO_MEMORY;
d1860 1
a1860 1
        return XML_ERROR_NO_MEMORY;
d1864 1
a1864 1
        reportDefault(parser, enc, s, next);
d1872 6
a1877 14
/* Precondition: all arguments must be non-NULL;
   Purpose:
   - normalize attributes
   - check attributes for well-formedness
   - generate namespace aware attribute names (URI, prefix)
   - build list of attributes for startElementHandler
   - default attributes
   - process namespace declarations (check and report them)
   - generate namespace aware element name (URI, prefix)
*/
static enum XML_Error
storeAtts(XML_Parser parser, const ENCODING *enc,
          const char *attStr, TAG_NAME *tagNamePtr,
          BINDING **bindingsPtr)
d1879 1
a1879 2
  DTD * const dtd = _dtd;  /* save one level of indirection */
  ELEMENT_TYPE *elementType = NULL;
d1881 1
a1881 1
  const XML_Char **appAtts;   /* the attribute list for the application */
a1882 1
  int prefixLen;
a1884 1
  XML_Char *uri;
d1890 13
a1902 11
  elementType = (ELEMENT_TYPE *)lookup(&dtd->elementTypes, tagNamePtr->str,0);
  if (!elementType) {
    const XML_Char *name = poolCopyString(&dtd->pool, tagNamePtr->str);
    if (!name)
      return XML_ERROR_NO_MEMORY;
    elementType = (ELEMENT_TYPE *)lookup(&dtd->elementTypes, name,
                                         sizeof(ELEMENT_TYPE));
    if (!elementType)
      return XML_ERROR_NO_MEMORY;
    if (ns && !setElementTypePrefix(parser, elementType))
      return XML_ERROR_NO_MEMORY;
a1903 2
  nDefaultAtts = elementType->nDefaultAtts;

a1907 1
    ATTRIBUTE *temp;
d1909 2
a1910 2
    temp = (ATTRIBUTE *)REALLOC((void *)atts, attsSize * sizeof(ATTRIBUTE));
    if (temp == NULL)
a1911 1
    atts = temp;
a1914 1

d1919 2
a1920 2
                                         atts[i].name
                                         + XmlNameLength(enc, atts[i].name));
d1926 1
a1926 1
        eventPtr = atts[i].name;
d1933 1
a1933 1
      XML_Bool isCdata = XML_TRUE;
d1937 7
a1943 7
        int j;
        for (j = 0; j < nDefaultAtts; j++) {
          if (attId == elementType->defaultAtts[j].id) {
            isCdata = elementType->defaultAtts[j].isCdata;
            break;
          }
        }
d1948 2
a1949 2
                                   atts[i].valuePtr, atts[i].valueEnd,
                                   &tempPool);
d1951 7
a1957 3
        return result;
      appAtts[attIndex] = poolStart(&tempPool);
      poolFinish(&tempPool);
d1959 1
a1959 1
    else {
d1961 1
a1961 2
      appAtts[attIndex] = poolStoreString(&tempPool, enc, atts[i].valuePtr,
                                          atts[i].valueEnd);
d1963 1
a1963 1
        return XML_ERROR_NO_MEMORY;
d1967 1
a1967 1
    if (attId->prefix) {
d1969 3
a1971 5
        /* deal with namespace declarations here */
        enum XML_Error result = addBinding(parser, attId->prefix, attId,
                                           appAtts[attIndex], bindingsPtr);
        if (result)
          return result;
d1975 1
a1975 1
        /* deal with other prefixed names later */
d1984 33
a2016 35

  /* set-up for XML_GetSpecifiedAttributeCount and XML_GetIdAttributeIndex */
  nSpecifiedAtts = attIndex;
  if (elementType->idAtt && (elementType->idAtt->name)[-1]) {
    for (i = 0; i < attIndex; i += 2)
      if (appAtts[i] == elementType->idAtt->name) {
        idAttIndex = i;
        break;
      }
  }
  else
    idAttIndex = -1;

  /* do attribute defaulting */
  for (i = 0; i < nDefaultAtts; i++) {
    const DEFAULT_ATTRIBUTE *da = elementType->defaultAtts + i;
    if (!(da->id->name)[-1] && da->value) {
      if (da->id->prefix) {
        if (da->id->xmlns) {
          enum XML_Error result = addBinding(parser, da->id->prefix, da->id,
                                             da->value, bindingsPtr);
          if (result)
            return result;
        }
        else {
          (da->id->name)[-1] = 2;
          nPrefixes++;
          appAtts[attIndex++] = da->id->name;
          appAtts[attIndex++] = da->value;
        }
      }
      else {
        (da->id->name)[-1] = 1;
        appAtts[attIndex++] = da->id->name;
        appAtts[attIndex++] = da->value;
d2019 1
a2020 2
  appAtts[attIndex] = 0;

d2028 29
a2056 29
        id = (ATTRIBUTE_ID *)lookup(&dtd->attributeIds, appAtts[i], 0);
        if (id->prefix->binding) {
          int j;
          const BINDING *b = id->prefix->binding;
          const XML_Char *s = appAtts[i];
          for (j = 0; j < b->uriLen; j++) {
            if (!poolAppendChar(&tempPool, b->uri[j]))
              return XML_ERROR_NO_MEMORY;
          }
          while (*s++ != XML_T(':'))
            ;
          do {
            if (!poolAppendChar(&tempPool, *s))
              return XML_ERROR_NO_MEMORY;
          } while (*s++);
          if (ns_triplets) {
            tempPool.ptr[-1] = namespaceSeparator;
            s = b->prefix->name;
            do {
              if (!poolAppendChar(&tempPool, *s))
                return XML_ERROR_NO_MEMORY;
            } while (*s++);
          }

          appAtts[i] = poolStart(&tempPool);
          poolFinish(&tempPool);
        }
        if (!--nPrefixes)
          break;
d2059 1
a2059 1
        ((XML_Char *)(appAtts[i]))[-1] = 0;
d2065 2
a2068 1

d2078 2
a2079 2
  else if (dtd->defaultPrefix.binding) {
    binding = dtd->defaultPrefix.binding;
a2083 5
  prefixLen = 0;
  if (ns && ns_triplets && binding->prefix->name) {
    for (; binding->prefix->name[prefixLen++];)
      ;
  }
a2085 2
  tagNamePtr->prefix = binding->prefix->name;
  tagNamePtr->prefixLen = prefixLen;
d2088 1
a2088 1
  n = i + binding->uriLen + prefixLen;
d2091 1
a2091 1
    uri = (XML_Char *)MALLOC((n + EXPAND_SPARE) * sizeof(XML_Char));
d2098 1
a2098 1
        p->name.str = uri;
d2102 1
a2102 7
  uri = binding->uri + binding->uriLen;
  memcpy(uri, localPart, i * sizeof(XML_Char));
  if (prefixLen) {
        uri = uri + (i - 1);
    if (namespaceSeparator) { *(uri) = namespaceSeparator; }
    memcpy(uri + 1, binding->prefix->name, prefixLen * sizeof(XML_Char));
  }
d2107 2
a2108 6
/* addBinding() overwrites the value of prefix->binding without checking.
   Therefore one must keep track of the old value outside of addBinding().
*/
static enum XML_Error
addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,
           const XML_Char *uri, BINDING **bindingsPtr)
a2111 5

  /* empty string is only valid when there is no prefix per XML NS 1.0 */
  if (*uri == XML_T('\0') && prefix->name)
    return XML_ERROR_SYNTAX;

d2119 3
a2121 5
      XML_Char *temp = (XML_Char *)REALLOC(b->uri,
                          sizeof(XML_Char) * (len + EXPAND_SPARE));
      if (temp == NULL)
        return XML_ERROR_NO_MEMORY;
      b->uri = temp;
d2127 1
a2127 1
    b = (BINDING *)MALLOC(sizeof(BINDING));
d2129 2
a2130 2
      return XML_ERROR_NO_MEMORY;
    b->uri = (XML_Char *)MALLOC(sizeof(XML_Char) * (len + EXPAND_SPARE));
d2133 1
a2133 1
      return XML_ERROR_NO_MEMORY;
d2144 2
a2145 2
  if (*uri == XML_T('\0') && prefix == &_dtd->defaultPrefix)
    prefix->binding = NULL;
d2152 2
a2153 2
                              prefix->binding ? uri : 0);
  return XML_ERROR_NONE;
d2157 7
a2163 7
   the whole file is parsed with one call.
*/
static enum XML_Error PTRCALL
cdataSectionProcessor(XML_Parser parser,
                      const char *start,
                      const char *end,
                      const char **endPtr)
d2165 1
a2165 2
  enum XML_Error result = doCdataSection(parser, encoding, &start,
                                         end, endPtr);
d2167 2
a2168 8
    if (parentParser) {  /* we are parsing an external entity */
      processor = externalEntityContentProcessor;
      return externalEntityContentProcessor(parser, start, end, endPtr);
    }
    else {
      processor = contentProcessor;
      return contentProcessor(parser, start, end, endPtr);
    }
d2174 8
a2181 8
   the section is not yet closed.
*/
static enum XML_Error
doCdataSection(XML_Parser parser,
               const ENCODING *enc,
               const char **startPtr,
               const char *end,
               const char **nextPtr)
d2196 1
a2196 1
  *startPtr = NULL;
d2204 1
a2204 1
        endCdataSectionHandler(handlerArg);
d2208 1
a2208 1
        characterDataHandler(handlerArg, dataBuf, 0);
d2211 1
a2211 1
        reportDefault(parser, enc, s, next);
d2216 2
a2217 2
        XML_Char c = 0xA;
        characterDataHandler(handlerArg, &c, 1);
d2220 1
a2220 1
        reportDefault(parser, enc, s, next);
d2224 15
a2238 16
        if (MUST_CONVERT(enc, s)) {
          for (;;) {
            ICHAR *dataPtr = (ICHAR *)dataBuf;
            XmlConvert(enc, &s, next, &dataPtr, (ICHAR *)dataBufEnd);
            *eventEndPP = next;
            characterDataHandler(handlerArg, dataBuf,
                                 dataPtr - (ICHAR *)dataBuf);
            if (s == next)
              break;
            *eventPP = s;
          }
        }
        else
          characterDataHandler(handlerArg,
                               (XML_Char *)s,
                               (XML_Char *)next - (XML_Char *)s);
d2241 1
a2241 1
        reportDefault(parser, enc, s, next);
d2248 2
a2249 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d2255 2
a2256 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d2271 7
a2277 7
   the whole file is parsed with one call.
*/
static enum XML_Error PTRCALL
ignoreSectionProcessor(XML_Parser parser,
                       const char *start,
                       const char *end,
                       const char **endPtr)
d2279 1
a2279 2
  enum XML_Error result = doIgnoreSection(parser, encoding, &start,
                                          end, endPtr);
d2287 9
a2295 9
/* startPtr gets set to non-null is the section is closed, and to null
   if the section is not yet closed.
*/
static enum XML_Error
doIgnoreSection(XML_Parser parser,
                const ENCODING *enc,
                const char **startPtr,
                const char *end,
                const char **nextPtr)
d2312 1
a2312 1
  *startPtr = NULL;
d2353 1
a2353 1
    s = NULL;
d2358 3
a2360 3
          || (protocolEncodingName[i] & ~0x7f) != 0) {
        encodingBuf[0] = '\0';
        break;
d2377 1
a2377 1
               const char *s, const char *next)
d2379 4
a2382 4
  const char *encodingName = NULL;
  const XML_Char *storedEncName = NULL;
  const ENCODING *newEncoding = NULL;
  const char *version = NULL;
d2384 1
a2384 1
  const XML_Char *storedversion = NULL;
d2388 10
a2397 10
        : XmlParseXmlDecl)(isGeneralTextEntity,
                           encoding,
                           s,
                           next,
                           &eventPtr,
                           &version,
                           &versionend,
                           &encodingName,
                           &newEncoding,
                           &standalone))
d2400 1
a2400 1
    _dtd->standalone = XML_TRUE;
d2407 1
a2407 1
    if (encodingName != NULL) {
d2409 6
a2414 6
                                      encoding,
                                      encodingName,
                                      encodingName
                                      + XmlNameLength(encoding, encodingName));
      if (!storedEncName)
              return XML_ERROR_NO_MEMORY;
d2419 5
a2423 5
                                      encoding,
                                      version,
                                      versionend - encoding->minBytesPerChar);
      if (!storedversion)
        return XML_ERROR_NO_MEMORY;
d2429 1
a2429 1
  if (protocolEncodingName == NULL) {
d2432 2
a2433 2
        eventPtr = encodingName;
        return XML_ERROR_INCORRECT_ENCODING;
d2439 8
a2446 6
      if (!storedEncName) {
        storedEncName = poolStoreString(
          &temp2Pool, encoding, encodingName,
          encodingName + XmlNameLength(encoding, encodingName));
        if (!storedEncName)
          return XML_ERROR_NO_MEMORY;
d2449 1
a2449 1
      poolClear(&temp2Pool);
d2451 1
a2451 1
        eventPtr = encodingName;
d2470 4
a2473 5
    info.convert = NULL;
    info.data = NULL;
    info.release = NULL;
    if (unknownEncodingHandler(unknownEncodingHandlerData, encodingName,
                               &info)) {
d2477 3
a2479 174
        if (info.release)
          info.release(info.data);
        return XML_ERROR_NO_MEMORY;
      }
      enc = (ns
             ? XmlInitUnknownEncodingNS
             : XmlInitUnknownEncoding)(unknownEncodingMem,
                                       info.map,
                                       info.convert,
                                       info.data);
      if (enc) {
        unknownEncodingData = info.data;
        unknownEncodingRelease = info.release;
        encoding = enc;
        return XML_ERROR_NONE;
      }
    }
    if (info.release != NULL)
      info.release(info.data);
  }
  return XML_ERROR_UNKNOWN_ENCODING;
}

static enum XML_Error PTRCALL
prologInitProcessor(XML_Parser parser,
                    const char *s,
                    const char *end,
                    const char **nextPtr)
{
  enum XML_Error result = initializeEncoding(parser);
  if (result != XML_ERROR_NONE)
    return result;
  processor = prologProcessor;
  return prologProcessor(parser, s, end, nextPtr);
}

#ifdef XML_DTD

static enum XML_Error PTRCALL
externalParEntInitProcessor(XML_Parser parser,
                            const char *s,
                            const char *end,
                            const char **nextPtr)
{
  enum XML_Error result = initializeEncoding(parser);
  if (result != XML_ERROR_NONE)
    return result;

  /* we know now that XML_Parse(Buffer) has been called,
     so we consider the external parameter entity read */
  _dtd->paramEntityRead = XML_TRUE;

  if (prologState.inEntityValue) {
    processor = entityValueInitProcessor;
    return entityValueInitProcessor(parser, s, end, nextPtr);
  }
  else {
    processor = externalParEntProcessor;
    return externalParEntProcessor(parser, s, end, nextPtr);
  }
}

static enum XML_Error PTRCALL
entityValueInitProcessor(XML_Parser parser,
                         const char *s,
                         const char *end,
                         const char **nextPtr)
{
  const char *start = s;
  const char *next = s;
  int tok;

  for (;;) {
    tok = XmlPrologTok(encoding, start, end, &next);
    if (tok <= 0) {
      if (nextPtr != 0 && tok != XML_TOK_INVALID) {
              *nextPtr = s;
              return XML_ERROR_NONE;
      }
      switch (tok) {
      case XML_TOK_INVALID:
              return XML_ERROR_INVALID_TOKEN;
      case XML_TOK_PARTIAL:
              return XML_ERROR_UNCLOSED_TOKEN;
      case XML_TOK_PARTIAL_CHAR:
              return XML_ERROR_PARTIAL_CHAR;
      case XML_TOK_NONE:   /* start == end */
      default:
        break;
      }
      return storeEntityValue(parser, encoding, s, end);
    }
    else if (tok == XML_TOK_XML_DECL) {
      enum XML_Error result = processXmlDecl(parser, 0, start, next);
            if (result != XML_ERROR_NONE)
              return result;
      if (nextPtr) *nextPtr = next;
      /* stop scanning for text declaration - we found one */
      processor = entityValueProcessor;
      return entityValueProcessor(parser, next, end, nextPtr);
    }
    /* If we are at the end of the buffer, this would cause XmlPrologTok to
       return XML_TOK_NONE on the next call, which would then cause the
       function to exit with *nextPtr set to s - that is what we want for other
       tokens, but not for the BOM - we would rather like to skip it;
       then, when this routine is entered the next time, XmlPrologTok will
       return XML_TOK_INVALID, since the BOM is still in the buffer
    */
    else if (tok == XML_TOK_BOM && next == end && nextPtr) {
      *nextPtr = next;
      return XML_ERROR_NONE;
    }
    start = next;
  }
}

static enum XML_Error PTRCALL
externalParEntProcessor(XML_Parser parser,
                        const char *s,
                        const char *end,
                        const char **nextPtr)
{
  const char *start = s;
  const char *next = s;
  int tok;

  tok = XmlPrologTok(encoding, start, end, &next);
  if (tok <= 0) {
    if (nextPtr != 0 && tok != XML_TOK_INVALID) {
      *nextPtr = s;
      return XML_ERROR_NONE;
    }
    switch (tok) {
    case XML_TOK_INVALID:
      return XML_ERROR_INVALID_TOKEN;
    case XML_TOK_PARTIAL:
      return XML_ERROR_UNCLOSED_TOKEN;
    case XML_TOK_PARTIAL_CHAR:
      return XML_ERROR_PARTIAL_CHAR;
    case XML_TOK_NONE:   /* start == end */
    default:
      break;
    }
  }
  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.
     However, when parsing an external subset, doProlog will not accept a BOM
     as valid, and report a syntax error, so we have to skip the BOM
  */
  else if (tok == XML_TOK_BOM) {
    s = next;
    tok = XmlPrologTok(encoding, s, end, &next);
  }

  processor = prologProcessor;
  return doProlog(parser, encoding, s, end, tok, next, nextPtr);
}

static enum XML_Error PTRCALL
entityValueProcessor(XML_Parser parser,
                     const char *s,
                     const char *end,
                     const char **nextPtr)
{
  const char *start = s;
  const char *next = s;
  const ENCODING *enc = encoding;
  int tok;

  for (;;) {
    tok = XmlPrologTok(enc, start, end, &next);
    if (tok <= 0) {
      if (nextPtr != 0 && tok != XML_TOK_INVALID) {
        *nextPtr = s;
        return XML_ERROR_NONE;
d2481 11
a2491 10
      switch (tok) {
      case XML_TOK_INVALID:
              return XML_ERROR_INVALID_TOKEN;
      case XML_TOK_PARTIAL:
              return XML_ERROR_UNCLOSED_TOKEN;
      case XML_TOK_PARTIAL_CHAR:
              return XML_ERROR_PARTIAL_CHAR;
      case XML_TOK_NONE:   /* start == end */
      default:
        break;
a2492 1
      return storeEntityValue(parser, enc, s, end);
d2494 2
a2495 1
    start = next;
d2497 1
d2500 12
a2511 1
#endif /* XML_DTD */
d2513 1
a2513 1
static enum XML_Error PTRCALL
d2515 3
a2517 3
                const char *s,
                const char *end,
                const char **nextPtr)
d2519 1
a2519 1
  const char *next = s;
d2526 6
a2531 6
         const ENCODING *enc,
         const char *s,
         const char *end,
         int tok,
         const char *next,
         const char **nextPtr)
a2535 17
  static const XML_Char atypeCDATA[] = { 'C', 'D', 'A', 'T', 'A', '\0' };
  static const XML_Char atypeID[] = { 'I', 'D', '\0' };
  static const XML_Char atypeIDREF[] = { 'I', 'D', 'R', 'E', 'F', '\0' };
  static const XML_Char atypeIDREFS[] = { 'I', 'D', 'R', 'E', 'F', 'S', '\0' };
  static const XML_Char atypeENTITY[] = { 'E', 'N', 'T', 'I', 'T', 'Y', '\0' };
  static const XML_Char atypeENTITIES[] =
      { 'E', 'N', 'T', 'I', 'T', 'I', 'E', 'S', '\0' };
  static const XML_Char atypeNMTOKEN[] = {
      'N', 'M', 'T', 'O', 'K', 'E', 'N', '\0' };
  static const XML_Char atypeNMTOKENS[] = {
      'N', 'M', 'T', 'O', 'K', 'E', 'N', 'S', '\0' };
  static const XML_Char notationPrefix[] = {
      'N', 'O', 'T', 'A', 'T', 'I', 'O', 'N', '(', '\0' };
  static const XML_Char enumValueSep[] = { '|', '\0' };
  static const XML_Char enumValueStart[] = { '(', '\0' };

  DTD * const dtd = _dtd;  /* save one level of indirection */
a2550 1
    XML_Bool handleDefault = XML_TRUE;
d2555 2
a2556 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d2560 2
a2561 2
        *eventPP = next;
        return XML_ERROR_INVALID_TOKEN;
d2563 1
a2563 1
        return XML_ERROR_UNCLOSED_TOKEN;
d2565 1
a2565 1
        return XML_ERROR_PARTIAL_CHAR;
d2568 9
a2576 8
        if (enc != encoding)
          return XML_ERROR_NONE;
        if (isParamEntity) {
          if (XmlTokenRole(&prologState, XML_TOK_NONE, end, end, enc)
              == XML_ROLE_ERROR)
            return XML_ERROR_SYNTAX;
          return XML_ERROR_NONE;
        }
d2578 1
a2578 1
        return XML_ERROR_NO_ELEMENTS;
d2580 3
a2582 3
        tok = -tok;
        next = end;
        break;
d2589 4
a2592 5
        enum XML_Error result = processXmlDecl(parser, 0, s, next);
        if (result != XML_ERROR_NONE)
          return result;
        enc = encoding;
        handleDefault = XML_FALSE;
d2597 6
a2602 6
        doctypeName = poolStoreString(&tempPool, enc, s, next);
        if (!doctypeName)
          return XML_ERROR_NO_MEMORY;
        poolFinish(&tempPool);
        doctypePubid = NULL;
        handleDefault = XML_FALSE;
a2603 1
      doctypeSysid = NULL; /* always initialize to NULL */
d2607 4
a2610 5
        startDoctypeDeclHandler(handlerArg, doctypeName, doctypeSysid,
                                doctypePubid, 1);
        doctypeName = NULL;
        poolClear(&tempPool);
        handleDefault = XML_FALSE;
d2616 4
a2619 5
        enum XML_Error result = processXmlDecl(parser, 1, s, next);
        if (result != XML_ERROR_NONE)
          return result;
        enc = encoding;
        handleDefault = XML_FALSE;
a2623 4
#ifdef XML_DTD
      useForeignDTD = XML_FALSE;
#endif /* XML_DTD */
      dtd->hasParamEntityRefs = XML_TRUE;
d2625 4
a2628 7
        doctypePubid = poolStoreString(&tempPool, enc,
                                       s + enc->minBytesPerChar,
                                       next - enc->minBytesPerChar);
        if (!doctypePubid)
          return XML_ERROR_NO_MEMORY;
        poolFinish(&tempPool);
        handleDefault = XML_FALSE;
d2631 3
a2633 3
      declEntity = (ENTITY *)lookup(&dtd->paramEntities,
                                    externalSubsetName,
                                    sizeof(ENTITY));
d2635 1
a2635 1
        return XML_ERROR_NO_MEMORY;
d2640 11
a2650 13
        return XML_ERROR_SYNTAX;
      if (dtd->keepProcessing && declEntity) {
        XML_Char *tem = poolStoreString(&dtd->pool,
                                        enc,
                                        s + enc->minBytesPerChar,
                                        next - enc->minBytesPerChar);
        if (!tem)
          return XML_ERROR_NO_MEMORY;
        normalizePublicId(tem);
        declEntity->publicId = tem;
        poolFinish(&dtd->pool);
        if (entityDeclHandler)
          handleDefault = XML_FALSE;
d2655 18
a2672 36
        startDoctypeDeclHandler(handlerArg, doctypeName,
                                doctypeSysid, doctypePubid, 0);
        poolClear(&tempPool);
        handleDefault = XML_FALSE;
      }
      /* doctypeSysid will be non-NULL in the case of a previous
         XML_ROLE_DOCTYPE_SYSTEM_ID, even if startDoctypeDeclHandler
         was not set, indicating an external subset
      */
#ifdef XML_DTD
      if (doctypeSysid || useForeignDTD) {
        dtd->hasParamEntityRefs = XML_TRUE; /* when docTypeSysid == NULL */
        if (paramEntityParsing && externalEntityRefHandler) {
          ENTITY *entity = (ENTITY *)lookup(&dtd->paramEntities,
                                            externalSubsetName,
                                            sizeof(ENTITY));
          if (!entity)
            return XML_ERROR_NO_MEMORY;
          if (useForeignDTD)
            entity->base = curBase;
          dtd->paramEntityRead = XML_FALSE;
          if (!externalEntityRefHandler(externalEntityRefHandlerArg,
                                        0,
                                        entity->base,
                                        entity->systemId,
                                        entity->publicId))
            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
          if (dtd->paramEntityRead &&
              !dtd->standalone &&
              notStandaloneHandler &&
              !notStandaloneHandler(handlerArg))
            return XML_ERROR_NOT_STANDALONE;
          /* end of DTD - no need to update dtd->keepProcessing */
        }
        useForeignDTD = XML_FALSE;
      }
d2674 5
a2678 3
      if (endDoctypeDeclHandler) {
        endDoctypeDeclHandler(handlerArg);
        handleDefault = XML_FALSE;
d2680 2
a2683 29
#ifdef XML_DTD
      /* if there is no DOCTYPE declaration then now is the
         last chance to read the foreign DTD
      */
      if (useForeignDTD) {
        dtd->hasParamEntityRefs = XML_TRUE;
        if (paramEntityParsing && externalEntityRefHandler) {
          ENTITY *entity = (ENTITY *)lookup(&dtd->paramEntities,
                                            externalSubsetName,
                                            sizeof(ENTITY));
          if (!entity)
            return XML_ERROR_NO_MEMORY;
          entity->base = curBase;
          dtd->paramEntityRead = XML_FALSE;
          if (!externalEntityRefHandler(externalEntityRefHandlerArg,
                                        0,
                                        entity->base,
                                        entity->systemId,
                                        entity->publicId))
            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
          if (dtd->paramEntityRead &&
              !dtd->standalone &&
              notStandaloneHandler &&
              !notStandaloneHandler(handlerArg))
            return XML_ERROR_NOT_STANDALONE;
          /* end of DTD - no need to update dtd->keepProcessing */
        }
      }
#endif /* XML_DTD */
d2689 2
a2690 2
        return XML_ERROR_NO_MEMORY;
      goto checkAttListDeclHandler;
d2694 5
a2698 5
        return XML_ERROR_NO_MEMORY;
      declAttributeIsCdata = XML_FALSE;
      declAttributeType = NULL;
      declAttributeIsId = XML_FALSE;
      goto checkAttListDeclHandler;
d2700 3
a2702 3
      declAttributeIsCdata = XML_TRUE;
      declAttributeType = atypeCDATA;
      goto checkAttListDeclHandler;
d2704 3
a2706 3
      declAttributeIsId = XML_TRUE;
      declAttributeType = atypeID;
      goto checkAttListDeclHandler;
d2708 2
a2709 2
      declAttributeType = atypeIDREF;
      goto checkAttListDeclHandler;
d2711 2
a2712 2
      declAttributeType = atypeIDREFS;
      goto checkAttListDeclHandler;
d2714 2
a2715 2
      declAttributeType = atypeENTITY;
      goto checkAttListDeclHandler;
d2717 2
a2718 2
      declAttributeType = atypeENTITIES;
      goto checkAttListDeclHandler;
d2720 2
a2721 2
      declAttributeType = atypeNMTOKEN;
      goto checkAttListDeclHandler;
d2723 1
a2723 4
      declAttributeType = atypeNMTOKENS;
    checkAttListDeclHandler:
      if (dtd->keepProcessing && attlistDeclHandler)
        handleDefault = XML_FALSE;
d2725 1
d2728 16
a2743 16
      if (dtd->keepProcessing && attlistDeclHandler) {
        const XML_Char *prefix;
        if (declAttributeType) {
          prefix = enumValueSep;
        }
        else {
          prefix = (role == XML_ROLE_ATTRIBUTE_NOTATION_VALUE
                    ? notationPrefix
                    : enumValueStart);
        }
        if (!poolAppendString(&tempPool, prefix))
          return XML_ERROR_NO_MEMORY;
        if (!poolAppend(&tempPool, enc, s, next))
          return XML_ERROR_NO_MEMORY;
        declAttributeType = tempPool.start;
        handleDefault = XML_FALSE;
d2748 20
a2767 23
      if (dtd->keepProcessing) {
        if (!defineAttribute(declElementType, declAttributeId,
                              declAttributeIsCdata, declAttributeIsId, 0,
                              parser))
          return XML_ERROR_NO_MEMORY;
        if (attlistDeclHandler && declAttributeType) {
          if (*declAttributeType == XML_T('(')
              || (*declAttributeType == XML_T('N')
                  && declAttributeType[1] == XML_T('O'))) {
            /* Enumerated or Notation type */
            if (!poolAppendChar(&tempPool, XML_T(')'))
                || !poolAppendChar(&tempPool, XML_T('\0')))
              return XML_ERROR_NO_MEMORY;
            declAttributeType = tempPool.start;
            poolFinish(&tempPool);
          }
          *eventEndPP = s;
          attlistDeclHandler(handlerArg, declElementType->name,
                             declAttributeId->name, declAttributeType,
                             0, role == XML_ROLE_REQUIRED_ATTRIBUTE_VALUE);
          poolClear(&tempPool);
          handleDefault = XML_FALSE;
        }
d2772 33
a2804 34
      if (dtd->keepProcessing) {
        const XML_Char *attVal;
        enum XML_Error result
          = storeAttributeValue(parser, enc, declAttributeIsCdata,
                                s + enc->minBytesPerChar,
                                next - enc->minBytesPerChar,
                                &dtd->pool);
        if (result)
          return result;
        attVal = poolStart(&dtd->pool);
        poolFinish(&dtd->pool);
        /* ID attributes aren't allowed to have a default */
        if (!defineAttribute(declElementType, declAttributeId,
                             declAttributeIsCdata, XML_FALSE, attVal, parser))
          return XML_ERROR_NO_MEMORY;
        if (attlistDeclHandler && declAttributeType) {
          if (*declAttributeType == XML_T('(')
              || (*declAttributeType == XML_T('N')
                  && declAttributeType[1] == XML_T('O'))) {
            /* Enumerated or Notation type */
            if (!poolAppendChar(&tempPool, XML_T(')'))
                || !poolAppendChar(&tempPool, XML_T('\0')))
              return XML_ERROR_NO_MEMORY;
            declAttributeType = tempPool.start;
            poolFinish(&tempPool);
          }
          *eventEndPP = s;
          attlistDeclHandler(handlerArg, declElementType->name,
                             declAttributeId->name, declAttributeType,
                             attVal,
                             role == XML_ROLE_FIXED_ATTRIBUTE_VALUE);
          poolClear(&tempPool);
          handleDefault = XML_FALSE;
        }
a2805 1
      break;
d2807 22
a2828 23
      if (dtd->keepProcessing) {
        enum XML_Error result = storeEntityValue(parser, enc,
                                            s + enc->minBytesPerChar,
                                            next - enc->minBytesPerChar);
        if (declEntity) {
          declEntity->textPtr = poolStart(&dtd->entityValuePool);
          declEntity->textLen = poolLength(&dtd->entityValuePool);
          poolFinish(&dtd->entityValuePool);
          if (entityDeclHandler) {
            *eventEndPP = s;
            entityDeclHandler(handlerArg,
                              declEntity->name,
                              declEntity->is_param,
                              declEntity->textPtr,
                              declEntity->textLen,
                              curBase, 0, 0, 0);
            handleDefault = XML_FALSE;
          }
        }
        else
          poolDiscard(&dtd->entityValuePool);
        if (result != XML_ERROR_NONE)
          return result;
a2831 4
#ifdef XML_DTD
      useForeignDTD = XML_FALSE;
#endif /* XML_DTD */
      dtd->hasParamEntityRefs = XML_TRUE;
d2833 4
a2836 7
        doctypeSysid = poolStoreString(&tempPool, enc,
                                       s + enc->minBytesPerChar,
                                       next - enc->minBytesPerChar);
        if (doctypeSysid == NULL)
          return XML_ERROR_NO_MEMORY;
        poolFinish(&tempPool);
        handleDefault = XML_FALSE;
d2838 1
d2840 1
a2840 8
      else
        /* use externalSubsetName to make doctypeSysid non-NULL
           for the case where no startDoctypeDeclHandler is set */
        doctypeSysid = externalSubsetName;
#endif /* XML_DTD */
      if (!dtd->standalone
#ifdef XML_DTD
          && !paramEntityParsing
d2842 4
a2845 3
          && notStandaloneHandler
          && !notStandaloneHandler(handlerArg))
        return XML_ERROR_NOT_STANDALONE;
d2850 6
a2855 6
        declEntity = (ENTITY *)lookup(&dtd->paramEntities,
                                      externalSubsetName,
                                      sizeof(ENTITY));
        if (!declEntity)
          return XML_ERROR_NO_MEMORY;
        declEntity->publicId = NULL;
d2860 8
a2867 10
      if (dtd->keepProcessing && declEntity) {
        declEntity->systemId = poolStoreString(&dtd->pool, enc,
                                               s + enc->minBytesPerChar,
                                               next - enc->minBytesPerChar);
        if (!declEntity->systemId)
          return XML_ERROR_NO_MEMORY;
        declEntity->base = curBase;
        poolFinish(&dtd->pool);
        if (entityDeclHandler)
          handleDefault = XML_FALSE;
d2871 9
a2879 11
      if (dtd->keepProcessing && declEntity && entityDeclHandler) {
        *eventEndPP = s;
        entityDeclHandler(handlerArg,
                          declEntity->name,
                          declEntity->is_param,
                          0,0,
                          declEntity->base,
                          declEntity->systemId,
                          declEntity->publicId,
                          0);
        handleDefault = XML_FALSE;
d2883 24
a2906 26
      if (dtd->keepProcessing && declEntity) {
        declEntity->notation = poolStoreString(&dtd->pool, enc, s, next);
        if (!declEntity->notation)
          return XML_ERROR_NO_MEMORY;
        poolFinish(&dtd->pool);
        if (unparsedEntityDeclHandler) {
          *eventEndPP = s;
          unparsedEntityDeclHandler(handlerArg,
                                    declEntity->name,
                                    declEntity->base,
                                    declEntity->systemId,
                                    declEntity->publicId,
                                    declEntity->notation);
          handleDefault = XML_FALSE;
        }
        else if (entityDeclHandler) {
          *eventEndPP = s;
          entityDeclHandler(handlerArg,
                            declEntity->name,
                            0,0,0,
                            declEntity->base,
                            declEntity->systemId,
                            declEntity->publicId,
                            declEntity->notation);
          handleDefault = XML_FALSE;
        }
d2911 26
a2936 32
        if (XmlPredefinedEntityName(enc, s, next)) {
          declEntity = NULL;
          break;
        }
        if (dtd->keepProcessing) {
          const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);
          if (!name)
            return XML_ERROR_NO_MEMORY;
          declEntity = (ENTITY *)lookup(&dtd->generalEntities, name,
                                        sizeof(ENTITY));
          if (!declEntity)
            return XML_ERROR_NO_MEMORY;
          if (declEntity->name != name) {
            poolDiscard(&dtd->pool);
            declEntity = NULL;
          }
          else {
            poolFinish(&dtd->pool);
            declEntity->publicId = NULL;
            declEntity->is_param = XML_FALSE;
            /* if we have a parent parser or are reading an internal parameter
               entity, then the entity declaration is not considered "internal"
            */
            declEntity->is_internal = !(parentParser || openInternalEntities);
            if (entityDeclHandler)
              handleDefault = XML_FALSE;
          }
        }
        else {
          poolDiscard(&dtd->pool);
          declEntity = NULL;
        }
d2941 17
a2957 27
      if (dtd->keepProcessing) {
        const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);
        if (!name)
          return XML_ERROR_NO_MEMORY;
        declEntity = (ENTITY *)lookup(&dtd->paramEntities,
                                           name, sizeof(ENTITY));
        if (!declEntity)
          return XML_ERROR_NO_MEMORY;
        if (declEntity->name != name) {
          poolDiscard(&dtd->pool);
          declEntity = NULL;
        }
        else {
          poolFinish(&dtd->pool);
          declEntity->publicId = NULL;
          declEntity->is_param = XML_TRUE;
          /* if we have a parent parser or are reading an internal parameter
             entity, then the entity declaration is not considered "internal"
          */
          declEntity->is_internal = !(parentParser || openInternalEntities);
          if (entityDeclHandler)
            handleDefault = XML_FALSE;
        }
      }
      else {
        poolDiscard(&dtd->pool);
        declEntity = NULL;
d2960 2
a2961 2
      declEntity = NULL;
#endif /* XML_DTD */
d2964 2
a2965 2
      declNotationPublicId = NULL;
      declNotationName = NULL;
d2967 4
a2970 5
        declNotationName = poolStoreString(&tempPool, enc, s, next);
        if (!declNotationName)
          return XML_ERROR_NO_MEMORY;
        poolFinish(&tempPool);
        handleDefault = XML_FALSE;
d2975 11
a2985 12
        return XML_ERROR_SYNTAX;
      if (declNotationName) {  /* means notationDeclHandler != NULL */
        XML_Char *tem = poolStoreString(&tempPool,
                                        enc,
                                        s + enc->minBytesPerChar,
                                        next - enc->minBytesPerChar);
        if (!tem)
          return XML_ERROR_NO_MEMORY;
        normalizePublicId(tem);
        declNotationPublicId = tem;
        poolFinish(&tempPool);
        handleDefault = XML_FALSE;
d2990 12
a3001 13
        const XML_Char *systemId
          = poolStoreString(&tempPool, enc,
                            s + enc->minBytesPerChar,
                            next - enc->minBytesPerChar);
        if (!systemId)
          return XML_ERROR_NO_MEMORY;
        *eventEndPP = s;
        notationDeclHandler(handlerArg,
                            declNotationName,
                            curBase,
                            systemId,
                            declNotationPublicId);
        handleDefault = XML_FALSE;
d3007 6
a3012 7
        *eventEndPP = s;
        notationDeclHandler(handlerArg,
                            declNotationName,
                            curBase,
                            0,
                            declNotationPublicId);
        handleDefault = XML_FALSE;
d3019 1
a3019 1
        return XML_ERROR_PARAM_ENTITY_REF;
d3021 1
a3021 1
        return XML_ERROR_MISPLACED_XML_PI;
d3023 1
a3023 1
        return XML_ERROR_SYNTAX;
d3028 8
a3035 9
        enum XML_Error result;
        if (defaultHandler)
          reportDefault(parser, enc, s, next);
        handleDefault = XML_FALSE;
        result = doIgnoreSection(parser, enc, &next, end, nextPtr);
        if (!next) {
          processor = ignoreSectionProcessor;
          return result;
        }
d3041 9
a3049 18
        if (groupSize) {
          char *temp = (char *)REALLOC(groupConnector, groupSize *= 2);
          if (temp == NULL)
            return XML_ERROR_NO_MEMORY;
          groupConnector = temp;
          if (dtd->scaffIndex) {
            int *temp = (int *)REALLOC(dtd->scaffIndex,
                          groupSize * sizeof(int));
            if (temp == NULL)
              return XML_ERROR_NO_MEMORY;
            dtd->scaffIndex = temp;
          }
        }
        else {
          groupConnector = (char *)MALLOC(groupSize = 32);
          if (!groupConnector)
            return XML_ERROR_NO_MEMORY;
        }
d3052 7
a3058 9
      if (dtd->in_eldecl) {
        int myindex = nextScaffoldPart(parser);
        if (myindex < 0)
          return XML_ERROR_NO_MEMORY;
        dtd->scaffIndex[dtd->scaffLevel] = myindex;
        dtd->scaffLevel++;
        dtd->scaffold[myindex].type = XML_CTYPE_SEQ;
        if (elementDeclHandler)
          handleDefault = XML_FALSE;
d3063 1
a3063 1
        return XML_ERROR_SYNTAX;
a3064 2
      if (dtd->in_eldecl && elementDeclHandler)
        handleDefault = XML_FALSE;
d3068 6
a3073 10
        return XML_ERROR_SYNTAX;
      if (dtd->in_eldecl
          && !groupConnector[prologState.level]
          && (dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type
              != XML_CTYPE_MIXED)
          ) {
        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type
            = XML_CTYPE_CHOICE;
        if (elementDeclHandler)
          handleDefault = XML_FALSE;
d3080 41
a3120 72
      /* PE references in internal subset are
         not allowed within declarations      */
      if (prologState.documentEntity &&
          role == XML_ROLE_INNER_PARAM_ENTITY_REF)
        return XML_ERROR_PARAM_ENTITY_REF;
      dtd->hasParamEntityRefs = XML_TRUE;
      if (!paramEntityParsing)
        dtd->keepProcessing = dtd->standalone;
      else {
        const XML_Char *name;
        ENTITY *entity;
        name = poolStoreString(&dtd->pool, enc,
                                s + enc->minBytesPerChar,
                                next - enc->minBytesPerChar);
        if (!name)
          return XML_ERROR_NO_MEMORY;
        entity = (ENTITY *)lookup(&dtd->paramEntities, name, 0);
        poolDiscard(&dtd->pool);
        /* first, determine if a check for an existing declaration is needed;
           if yes, check that the entity exists, and that it is internal,
           otherwise call the skipped entity handler
        */
        if (prologState.documentEntity &&
            (dtd->standalone
             ? !openInternalEntities
             : !dtd->hasParamEntityRefs)) {
          if (!entity)
            return XML_ERROR_UNDEFINED_ENTITY;
          else if (!entity->is_internal)
            return XML_ERROR_ENTITY_DECLARED_IN_PE;
        }
        else if (!entity) {
          dtd->keepProcessing = dtd->standalone;
          /* cannot report skipped entities in declarations */
          if ((role == XML_ROLE_PARAM_ENTITY_REF) && skippedEntityHandler) {
            skippedEntityHandler(handlerArg, name, 1);
            handleDefault = XML_FALSE;
          }
          break;
        }
        if (entity->open)
          return XML_ERROR_RECURSIVE_ENTITY_REF;
        if (entity->textPtr) {
          enum XML_Error result;
          result = processInternalParamEntity(parser, entity);
          if (result != XML_ERROR_NONE)
            return result;
          handleDefault = XML_FALSE;
          break;
        }
        if (externalEntityRefHandler) {
          dtd->paramEntityRead = XML_FALSE;
          entity->open = XML_TRUE;
          if (!externalEntityRefHandler(externalEntityRefHandlerArg,
                                        0,
                                        entity->base,
                                        entity->systemId,
                                        entity->publicId)) {
            entity->open = XML_FALSE;
            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
          }
          entity->open = XML_FALSE;
          handleDefault = XML_FALSE;
          if (!dtd->paramEntityRead) {
            dtd->keepProcessing = dtd->standalone;
            break;
          }
        }
        else {
          dtd->keepProcessing = dtd->standalone;
          break;
        }
d3123 7
a3129 4
      if (!dtd->standalone &&
          notStandaloneHandler &&
          !notStandaloneHandler(handlerArg))
        return XML_ERROR_NOT_STANDALONE;
d3132 1
a3132 1
    /* Element declaration stuff */
d3136 6
a3141 7
        declElementType = getElementType(parser, enc, s, next);
        if (!declElementType)
          return XML_ERROR_NO_MEMORY;
        dtd->scaffLevel = 0;
        dtd->scaffCount = 0;
        dtd->in_eldecl = XML_TRUE;
        handleDefault = XML_FALSE;
d3147 16
a3162 17
      if (dtd->in_eldecl) {
        if (elementDeclHandler) {
          XML_Content * content = (XML_Content *) MALLOC(sizeof(XML_Content));
          if (!content)
            return XML_ERROR_NO_MEMORY;
          content->quant = XML_CQUANT_NONE;
          content->name = NULL;
          content->numchildren = 0;
          content->children = NULL;
          content->type = ((role == XML_ROLE_CONTENT_ANY) ?
                           XML_CTYPE_ANY :
                           XML_CTYPE_EMPTY);
          *eventEndPP = s;
          elementDeclHandler(handlerArg, declElementType->name, content);
          handleDefault = XML_FALSE;
        }
        dtd->in_eldecl = XML_FALSE;
d3165 1
a3165 1

d3167 2
a3168 5
      if (dtd->in_eldecl) {
        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type
            = XML_CTYPE_MIXED;
        if (elementDeclHandler)
          handleDefault = XML_FALSE;
d3184 15
a3198 23
      if (dtd->in_eldecl) {
        ELEMENT_TYPE *el;
        const XML_Char *name;
        int nameLen;
        const char *nxt = (quant == XML_CQUANT_NONE
                           ? next
                           : next - enc->minBytesPerChar);
        int myindex = nextScaffoldPart(parser);
        if (myindex < 0)
          return XML_ERROR_NO_MEMORY;
        dtd->scaffold[myindex].type = XML_CTYPE_NAME;
        dtd->scaffold[myindex].quant = quant;
        el = getElementType(parser, enc, s, nxt);
        if (!el)
          return XML_ERROR_NO_MEMORY;
        name = el->name;
        dtd->scaffold[myindex].name = name;
        nameLen = 0;
        for (; name[nameLen++]; );
        dtd->contentStringLen +=  nameLen;
        if (elementDeclHandler)
          handleDefault = XML_FALSE;
      }
d3213 14
a3226 16
      if (dtd->in_eldecl) {
        if (elementDeclHandler)
          handleDefault = XML_FALSE;
        dtd->scaffLevel--;
        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel]].quant = quant;
        if (dtd->scaffLevel == 0) {
          if (!handleDefault) {
            XML_Content *model = build_model(parser);
            if (!model)
              return XML_ERROR_NO_MEMORY;
            *eventEndPP = s;
            elementDeclHandler(handlerArg, declElementType->name, model);
          }
          dtd->in_eldecl = XML_FALSE;
          dtd->contentStringLen = 0;
        }
d3231 11
a3241 4
    case XML_ROLE_PI:
      if (!reportProcessingInstruction(parser, enc, s, next))
        return XML_ERROR_NO_MEMORY;
      handleDefault = XML_FALSE;
d3243 2
a3244 6
    case XML_ROLE_COMMENT:
      if (!reportComment(parser, enc, s, next))
        return XML_ERROR_NO_MEMORY;
      handleDefault = XML_FALSE;
      break;
    case XML_ROLE_NONE:
d3246 2
d3249 11
a3259 2
        handleDefault = XML_FALSE;
        break;
d3261 1
a3261 26
      break;
    case XML_ROLE_DOCTYPE_NONE:
      if (startDoctypeDeclHandler)
        handleDefault = XML_FALSE;
      break;
    case XML_ROLE_ENTITY_NONE:
      if (dtd->keepProcessing && entityDeclHandler)
        handleDefault = XML_FALSE;
      break;
    case XML_ROLE_NOTATION_NONE:
      if (notationDeclHandler)
        handleDefault = XML_FALSE;
      break;
    case XML_ROLE_ATTLIST_NONE:
      if (dtd->keepProcessing && attlistDeclHandler)
        handleDefault = XML_FALSE;
      break;
    case XML_ROLE_ELEMENT_NONE:
      if (elementDeclHandler)
        handleDefault = XML_FALSE;
      break;
    } /* end of big switch */

    if (handleDefault && defaultHandler)
      reportDefault(parser, enc, s, next);

d3268 5
a3272 5
static enum XML_Error PTRCALL
epilogProcessor(XML_Parser parser,
                const char *s,
                const char *end,
                const char **nextPtr)
d3277 1
a3277 1
    const char *next = NULL;
a3280 1
    /* report partial linebreak - it might be the last token */
d3283 2
a3284 2
        eventEndPtr = next;
        reportDefault(parser, encoding, s, next);
d3286 1
a3286 3
      if (nextPtr)
        *nextPtr = next;
      return XML_ERROR_NONE;
d3289 1
a3289 1
        *nextPtr = s;
d3293 1
a3293 1
        reportDefault(parser, encoding, s, next);
d3297 1
a3297 1
        return XML_ERROR_NO_MEMORY;
d3301 1
a3301 1
        return XML_ERROR_NO_MEMORY;
d3308 2
a3309 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d3314 2
a3315 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d3334 1
a3334 1
  entity->open = XML_TRUE;
d3338 2
a3339 2
  openEntity.internalEventPtr = NULL;
  openEntity.internalEventEndPtr = NULL;
d3344 1
a3344 1
  entity->open = XML_FALSE;
d3351 5
a3355 5
static enum XML_Error PTRCALL
errorProcessor(XML_Parser parser,
               const char *s,
               const char *end,
               const char **nextPtr)
d3361 3
a3363 3
storeAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,
                    const char *ptr, const char *end,
                    STRING_POOL *pool)
d3365 1
a3365 2
  enum XML_Error result = appendAttributeValue(parser, enc, isCdata, ptr,
                                               end, pool);
d3376 3
a3378 3
appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,
                     const char *ptr, const char *end,
                     STRING_POOL *pool)
a3379 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d3388 1
a3388 1
        eventPtr = next;
d3392 1
a3392 1
        eventPtr = ptr;
d3396 22
a3417 22
        XML_Char buf[XML_ENCODE_MAX];
        int i;
        int n = XmlCharRefNumber(enc, ptr);
        if (n < 0) {
          if (enc == encoding)
            eventPtr = ptr;
          return XML_ERROR_BAD_CHAR_REF;
        }
        if (!isCdata
            && n == 0x20 /* space */
            && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))
          break;
        n = XmlEncode(n, (ICHAR *)buf);
        if (!n) {
          if (enc == encoding)
            eventPtr = ptr;
          return XML_ERROR_BAD_CHAR_REF;
        }
        for (i = 0; i < n; i++) {
          if (!poolAppendChar(pool, buf[i]))
            return XML_ERROR_NO_MEMORY;
        }
d3422 2
a3423 1
        return XML_ERROR_NO_MEMORY;
d3431 1
a3431 1
        break;
d3433 1
a3433 1
        return XML_ERROR_NO_MEMORY;
d3437 48
a3484 74
        const XML_Char *name;
        ENTITY *entity;
        char checkEntityDecl;
        XML_Char ch = (XML_Char) XmlPredefinedEntityName(enc,
                                              ptr + enc->minBytesPerChar,
                                              next - enc->minBytesPerChar);
        if (ch) {
          if (!poolAppendChar(pool, ch))
                return XML_ERROR_NO_MEMORY;
          break;
        }
        name = poolStoreString(&temp2Pool, enc,
                               ptr + enc->minBytesPerChar,
                               next - enc->minBytesPerChar);
        if (!name)
          return XML_ERROR_NO_MEMORY;
        entity = (ENTITY *)lookup(&dtd->generalEntities, name, 0);
        poolDiscard(&temp2Pool);
        /* first, determine if a check for an existing declaration is needed;
           if yes, check that the entity exists, and that it is internal,
           otherwise call the default handler (if called from content)
        */
        if (pool == &dtd->pool)  /* are we called from prolog? */
          checkEntityDecl =
#ifdef XML_DTD
              prologState.documentEntity &&
#endif /* XML_DTD */
              (dtd->standalone
               ? !openInternalEntities
               : !dtd->hasParamEntityRefs);
        else /* if (pool == &tempPool): we are called from content */
          checkEntityDecl = !dtd->hasParamEntityRefs || dtd->standalone;
        if (checkEntityDecl) {
          if (!entity)
            return XML_ERROR_UNDEFINED_ENTITY;
          else if (!entity->is_internal)
            return XML_ERROR_ENTITY_DECLARED_IN_PE;
        }
        else if (!entity) {
          /* cannot report skipped entity here - see comments on
             skippedEntityHandler
          if (skippedEntityHandler)
            skippedEntityHandler(handlerArg, name, 0);
          */
          if ((pool == &tempPool) && defaultHandler)
            reportDefault(parser, enc, ptr, next);
          break;
        }
        if (entity->open) {
          if (enc == encoding)
            eventPtr = ptr;
          return XML_ERROR_RECURSIVE_ENTITY_REF;
        }
        if (entity->notation) {
          if (enc == encoding)
            eventPtr = ptr;
          return XML_ERROR_BINARY_ENTITY_REF;
        }
        if (!entity->textPtr) {
          if (enc == encoding)
            eventPtr = ptr;
              return XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF;
        }
        else {
          enum XML_Error result;
          const XML_Char *textEnd = entity->textPtr + entity->textLen;
          entity->open = XML_TRUE;
          result = appendAttributeValue(parser, internalEncoding, isCdata,
                                        (char *)entity->textPtr,
                                        (char *)textEnd, pool);
          entity->open = XML_FALSE;
          if (result)
            return result;
        }
d3489 1
a3489 1
        eventPtr = ptr;
d3497 7
a3503 21
static enum XML_Error
storeEntityValue(XML_Parser parser,
                 const ENCODING *enc,
                 const char *entityTextPtr,
                 const char *entityTextEnd)
{
  DTD * const dtd = _dtd;  /* save one level of indirection */
  STRING_POOL *pool = &(dtd->entityValuePool);
  enum XML_Error result = XML_ERROR_NONE;
#ifdef XML_DTD
  int oldInEntityValue = prologState.inEntityValue;
  prologState.inEntityValue = 1;
#endif /* XML_DTD */
  /* never return Null for the value argument in EntityDeclHandler,
     since this would indicate an external entity; therefore we
     have to make sure that entityValuePool.start is not null */
  if (!pool->blocks) {
    if (!poolGrow(pool))
      return XML_ERROR_NO_MEMORY;
  }

d3510 35
a3544 60
      if (isParamEntity || enc != encoding) {
        const XML_Char *name;
        ENTITY *entity;
        name = poolStoreString(&tempPool, enc,
                               entityTextPtr + enc->minBytesPerChar,
                               next - enc->minBytesPerChar);
        if (!name) {
          result = XML_ERROR_NO_MEMORY;
          goto endEntityValue;
        }
        entity = (ENTITY *)lookup(&dtd->paramEntities, name, 0);
        poolDiscard(&tempPool);
        if (!entity) {
          /* not a well-formedness error - see XML 1.0: WFC Entity Declared */
          /* cannot report skipped entity here - see comments on
             skippedEntityHandler
          if (skippedEntityHandler)
            skippedEntityHandler(handlerArg, name, 0);
          */
          dtd->keepProcessing = dtd->standalone;
          goto endEntityValue;
        }
        if (entity->open) {
          if (enc == encoding)
            eventPtr = entityTextPtr;
          result = XML_ERROR_RECURSIVE_ENTITY_REF;
          goto endEntityValue;
        }
        if (entity->systemId) {
          if (externalEntityRefHandler) {
            dtd->paramEntityRead = XML_FALSE;
            entity->open = XML_TRUE;
            if (!externalEntityRefHandler(externalEntityRefHandlerArg,
                                          0,
                                          entity->base,
                                          entity->systemId,
                                          entity->publicId)) {
              entity->open = XML_FALSE;
              result = XML_ERROR_EXTERNAL_ENTITY_HANDLING;
              goto endEntityValue;
            }
            entity->open = XML_FALSE;
            if (!dtd->paramEntityRead)
              dtd->keepProcessing = dtd->standalone;
          }
          else
            dtd->keepProcessing = dtd->standalone;
        }
        else {
          entity->open = XML_TRUE;
          result = storeEntityValue(parser,
                                    internalEncoding,
                                    (char *)entity->textPtr,
                                    (char *)(entity->textPtr
                                             + entity->textLen));
          entity->open = XML_FALSE;
          if (result)
            goto endEntityValue;
        }
        break;
a3546 2
      /* in the internal subset, PE references are not legal
         within markup declarations, e.g entity values in this case */
d3548 1
a3548 2
      result = XML_ERROR_PARAM_ENTITY_REF;
      goto endEntityValue;
d3550 1
a3550 2
      result = XML_ERROR_NONE;
      goto endEntityValue;
d3553 2
a3554 4
      if (!poolAppend(pool, enc, entityTextPtr, next)) {
        result = XML_ERROR_NO_MEMORY;
        goto endEntityValue;
      }
d3560 2
a3561 4
      if (pool->end == pool->ptr && !poolGrow(pool)) {
              result = XML_ERROR_NO_MEMORY;
        goto endEntityValue;
      }
d3566 19
a3584 23
        XML_Char buf[XML_ENCODE_MAX];
        int i;
        int n = XmlCharRefNumber(enc, entityTextPtr);
        if (n < 0) {
          if (enc == encoding)
            eventPtr = entityTextPtr;
          result = XML_ERROR_BAD_CHAR_REF;
          goto endEntityValue;
        }
        n = XmlEncode(n, (ICHAR *)buf);
        if (!n) {
          if (enc == encoding)
            eventPtr = entityTextPtr;
          result = XML_ERROR_BAD_CHAR_REF;
          goto endEntityValue;
        }
        for (i = 0; i < n; i++) {
          if (pool->end == pool->ptr && !poolGrow(pool)) {
            result = XML_ERROR_NO_MEMORY;
            goto endEntityValue;
          }
          *(pool->ptr)++ = buf[i];
        }
d3589 2
a3590 3
        eventPtr = entityTextPtr;
      result = XML_ERROR_INVALID_TOKEN;
      goto endEntityValue;
d3593 2
a3594 3
        eventPtr = next;
      result = XML_ERROR_INVALID_TOKEN;
      goto endEntityValue;
d3597 2
a3598 3
        eventPtr = entityTextPtr;
      result = XML_ERROR_UNEXPECTED_STATE;
      goto endEntityValue;
d3602 1
a3602 5
endEntityValue:
#ifdef XML_DTD
  prologState.inEntityValue = oldInEntityValue;
#endif /* XML_DTD */
  return result;
d3605 1
a3605 1
static void FASTCALL
d3629 1
a3629 2
reportProcessingInstruction(XML_Parser parser, const ENCODING *enc,
                            const char *start, const char *end)
d3646 2
a3647 2
                        XmlSkipS(enc, tem),
                        end - enc->minBytesPerChar*2);
d3657 1
a3657 2
reportComment(XML_Parser parser, const ENCODING *enc,
              const char *start, const char *end)
d3667 2
a3668 2
                         start + enc->minBytesPerChar * 4,
                         end - enc->minBytesPerChar * 3);
d3678 1
a3678 2
reportDefault(XML_Parser parser, const ENCODING *enc,
              const char *s, const char *end)
d3705 2
a3706 2
defineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *attId, XML_Bool isCdata,
                XML_Bool isId, const XML_Char *value, XML_Parser parser)
d3715 1
a3715 1
        return 1;
d3722 1
a3722 4
      type->defaultAtts = (DEFAULT_ATTRIBUTE *)MALLOC(type->allocDefaultAtts 
                            * sizeof(DEFAULT_ATTRIBUTE));
      if (!type->defaultAtts)
        return 0;
d3725 3
a3727 8
      DEFAULT_ATTRIBUTE *temp;
      int count = type->allocDefaultAtts * 2;
      temp = (DEFAULT_ATTRIBUTE *)
        REALLOC(type->defaultAtts, (count * sizeof(DEFAULT_ATTRIBUTE)));
      if (temp == NULL)
        return 0;
      type->allocDefaultAtts = count;
      type->defaultAtts = temp;
d3729 2
d3737 1
a3737 1
    attId->maybeTokenized = XML_TRUE;
d3742 1
a3742 2
static int
setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)
a3743 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d3750 2
a3751 2
        if (!poolAppendChar(&dtd->pool, *s))
          return 0;
d3753 3
a3755 4
      if (!poolAppendChar(&dtd->pool, XML_T('\0')))
        return 0;
      prefix = (PREFIX *)lookup(&dtd->prefixes, poolStart(&dtd->pool),
                                sizeof(PREFIX));
d3757 3
a3759 3
        return 0;
      if (prefix->name == poolStart(&dtd->pool))
        poolFinish(&dtd->pool);
d3761 1
a3761 1
        poolDiscard(&dtd->pool);
d3770 1
a3770 2
getAttributeId(XML_Parser parser, const ENCODING *enc,
               const char *start, const char *end)
a3771 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d3774 3
a3776 3
  if (!poolAppendChar(&dtd->pool, XML_T('\0')))
    return NULL;
  name = poolStoreString(&dtd->pool, enc, start, end);
d3778 1
a3778 1
    return NULL;
d3780 1
a3780 1
  id = (ATTRIBUTE_ID *)lookup(&dtd->attributeIds, name, sizeof(ATTRIBUTE_ID));
d3782 1
a3782 1
    return NULL;
d3784 1
a3784 1
    poolDiscard(&dtd->pool);
d3786 1
a3786 1
    poolFinish(&dtd->pool);
d3789 8
a3796 8
    else if (name[0] == XML_T('x')
        && name[1] == XML_T('m')
        && name[2] == XML_T('l')
        && name[3] == XML_T('n')
        && name[4] == XML_T('s')
        && (name[5] == XML_T('\0') || name[5] == XML_T(':'))) {
      if (name[5] == XML_T('\0'))
        id->prefix = &dtd->defaultPrefix;
d3798 2
a3799 2
        id->prefix = (PREFIX *)lookup(&dtd->prefixes, name + 6, sizeof(PREFIX));
      id->xmlns = XML_TRUE;
d3804 15
a3818 16
        if (name[i] == XML_T(':')) {
          int j;
          for (j = 0; j < i; j++) {
            if (!poolAppendChar(&dtd->pool, name[j]))
              return NULL;
          }
          if (!poolAppendChar(&dtd->pool, XML_T('\0')))
            return NULL;
          id->prefix = (PREFIX *)lookup(&dtd->prefixes, poolStart(&dtd->pool),
                                        sizeof(PREFIX));
          if (id->prefix->name == poolStart(&dtd->pool))
            poolFinish(&dtd->pool);
          else
            poolDiscard(&dtd->pool);
          break;
        }
d3827 2
a3828 2
static const XML_Char *
getContext(XML_Parser parser)
a3829 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d3831 1
a3831 1
  XML_Bool needSep = XML_FALSE;
d3833 1
a3833 1
  if (dtd->defaultPrefix.binding) {
d3837 2
a3838 2
      return NULL;
    len = dtd->defaultPrefix.binding->uriLen;
d3842 3
a3844 3
      if (!poolAppendChar(&tempPool, dtd->defaultPrefix.binding->uri[i]))
        return NULL;
    needSep = XML_TRUE;
d3847 1
a3847 1
  hashTableIterInit(&iter, &(dtd->prefixes));
d3858 1
a3858 1
      return NULL;
d3861 1
a3861 1
        return NULL;
d3863 1
a3863 1
      return NULL;
d3869 2
a3870 2
        return NULL;
    needSep = XML_TRUE;
d3874 1
a3874 1
  hashTableIterInit(&iter, &(dtd->generalEntities));
d3883 1
a3883 1
      return NULL;
d3887 1
a3887 1
    needSep = XML_TRUE;
d3891 1
a3891 1
    return NULL;
d3895 2
a3896 2
static XML_Bool
setContext(XML_Parser parser, const XML_Char *context)
a3897 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d3904 2
a3905 2
        return XML_FALSE;
      e = (ENTITY *)lookup(&dtd->generalEntities, poolStart(&tempPool), 0);
d3907 1
a3907 1
        e->open = XML_TRUE;
d3909 1
a3909 1
        s++;
d3913 1
a3913 1
    else if (*s == XML_T('=')) {
d3916 1
a3916 1
        prefix = &dtd->defaultPrefix;
d3918 5
a3922 6
        if (!poolAppendChar(&tempPool, XML_T('\0')))
          return XML_FALSE;
        prefix = (PREFIX *)lookup(&dtd->prefixes, poolStart(&tempPool),
                                  sizeof(PREFIX));
        if (!prefix)
          return XML_FALSE;
d3924 7
a3930 9
          prefix->name = poolCopyString(&dtd->pool, prefix->name);
          if (!prefix->name)
            return XML_FALSE;
        }
        poolDiscard(&tempPool);
      }
      for (context = s + 1;
           *context != CONTEXT_SEP && *context != XML_T('\0');
           context++)
d3932 1
a3932 1
          return XML_FALSE;
d3934 3
a3936 4
        return XML_FALSE;
      if (addBinding(parser, prefix, 0, poolStart(&tempPool),
                     &inheritedBindings) != XML_ERROR_NONE)
        return XML_FALSE;
d3939 1
a3939 1
        ++context;
d3944 1
a3944 1
        return XML_FALSE;
d3948 1
a3948 1
  return XML_TRUE;
d3951 3
a3953 2
static void FASTCALL
normalizePublicId(XML_Char *publicId)
d3963 1
a3963 1
        *p++ = 0x20;
d3974 1
a3974 2
static DTD *
dtdCreate(const XML_Memory_Handling_Suite *ms)
d3976 1
a3976 3
  DTD *p = (DTD *)ms->malloc_fcn(sizeof(DTD));
  if (p == NULL)
    return p;
a3977 3
#ifdef XML_DTD
  poolInit(&(p->entityValuePool), ms);
#endif /* XML_DTD */
d3982 2
a3984 1
  p->paramEntityRead = XML_FALSE;
d3987 2
a3988 2
  p->defaultPrefix.name = NULL;
  p->defaultPrefix.binding = NULL;
d3990 2
a3991 3
  p->in_eldecl = XML_FALSE;
  p->scaffIndex = NULL;
  p->scaffold = NULL;
d3993 2
a3996 1
  p->contentStringLen = 0;
d3998 1
a3998 4
  p->keepProcessing = XML_TRUE;
  p->hasParamEntityRefs = XML_FALSE;
  p->standalone = XML_FALSE;
  return p;
a4000 13
static void
dtdReset(DTD *p, const XML_Memory_Handling_Suite *ms)
{
  HASH_TABLE_ITER iter;
  hashTableIterInit(&iter, &(p->elementTypes));
  for (;;) {
    ELEMENT_TYPE *e = (ELEMENT_TYPE *)hashTableIterNext(&iter);
    if (!e)
      break;
    if (e->allocDefaultAtts != 0)
      ms->free_fcn(e->defaultAtts);
  }
  hashTableClear(&(p->generalEntities));
a4001 12
  p->paramEntityRead = XML_FALSE;
  hashTableClear(&(p->paramEntities));
#endif /* XML_DTD */
  hashTableClear(&(p->elementTypes));
  hashTableClear(&(p->attributeIds));
  hashTableClear(&(p->prefixes));
  poolClear(&(p->pool));
#ifdef XML_DTD
  poolClear(&(p->entityValuePool));
#endif /* XML_DTD */
  p->defaultPrefix.name = NULL;
  p->defaultPrefix.binding = NULL;
d4003 7
a4009 13
  p->in_eldecl = XML_FALSE;
  if (p->scaffIndex) {
    ms->free_fcn(p->scaffIndex);
    p->scaffIndex = NULL;
  }
  if (p->scaffold) {
    ms->free_fcn(p->scaffold);
    p->scaffold = NULL;
  }
  p->scaffLevel = 0;
  p->scaffSize = 0;
  p->scaffCount = 0;
  p->contentStringLen = 0;
d4011 1
a4011 4
  p->keepProcessing = XML_TRUE;
  p->hasParamEntityRefs = XML_FALSE;
  p->standalone = XML_FALSE;
}
d4013 1
a4013 2
static void
dtdDestroy(DTD *p, XML_Bool isDocEntity, const XML_Memory_Handling_Suite *ms)
d4022 1
a4022 1
      ms->free_fcn(e->defaultAtts);
d4032 4
a4035 10
#ifdef XML_DTD
  poolDestroy(&(p->entityValuePool));
#endif /* XML_DTD */
  if (isDocEntity) {
    if (p->scaffIndex)
      ms->free_fcn(p->scaffIndex);
    if (p->scaffold)
      ms->free_fcn(p->scaffold);
  }
  ms->free_fcn(p);
d4038 4
a4041 5
/* Do a deep copy of the DTD. Return 0 for out of memory, non-zero otherwise.
   The new DTD has already been initialized.
*/
static int
dtdCopy(DTD *newDtd, const DTD *oldDtd, const XML_Memory_Handling_Suite *ms)
d4078 1
a4078 2
    newA = (ATTRIBUTE_ID *)lookup(&(newDtd->attributeIds), name,
                                  sizeof(ATTRIBUTE_ID));
d4085 1
a4085 1
        newA->prefix = &newDtd->defaultPrefix;
d4087 1
a4087 2
        newA->prefix = (PREFIX *)lookup(&(newDtd->prefixes),
                                        oldA->prefix->name, 0);
d4105 1
a4105 2
    newE = (ELEMENT_TYPE *)lookup(&(newDtd->elementTypes), name,
                                  sizeof(ELEMENT_TYPE));
d4109 3
a4111 6
      newE->defaultAtts = (DEFAULT_ATTRIBUTE *)
          ms->malloc_fcn(oldE->nDefaultAtts * sizeof(DEFAULT_ATTRIBUTE));
      if (!newE->defaultAtts) {
        ms->free_fcn(newE);
        return 0;
      }
d4114 1
a4114 2
      newE->idAtt = (ATTRIBUTE_ID *)
          lookup(&(newDtd->attributeIds), oldE->idAtt->name, 0);
d4117 1
a4117 2
      newE->prefix = (PREFIX *)lookup(&(newDtd->prefixes),
                                      oldE->prefix->name, 0);
d4119 1
a4119 2
      newE->defaultAtts[i].id = (ATTRIBUTE_ID *)
          lookup(&(newDtd->attributeIds), oldE->defaultAtts[i].id->name, 0);
d4122 3
a4124 4
        newE->defaultAtts[i].value
            = poolCopyString(&(newDtd->pool), oldE->defaultAtts[i].value);
        if (!newE->defaultAtts[i].value)
          return 0;
d4127 1
a4127 1
        newE->defaultAtts[i].value = NULL;
d4133 2
a4134 2
                       &(newDtd->pool),
                       &(oldDtd->generalEntities)))
d4139 2
a4140 2
                       &(newDtd->pool),
                       &(oldDtd->paramEntities)))
a4141 1
  newDtd->paramEntityRead = oldDtd->paramEntityRead;
d4144 1
a4144 2
  newDtd->keepProcessing = oldDtd->keepProcessing;
  newDtd->hasParamEntityRefs = oldDtd->hasParamEntityRefs;
d4158 4
a4161 4
static int
copyEntityTable(HASH_TABLE *newTable,
                STRING_POOL *newPool,
                const HASH_TABLE *oldTable)
d4164 2
a4165 2
  const XML_Char *cachedOldBase = NULL;
  const XML_Char *cachedNewBase = NULL;
d4184 1
a4184 1
        return 0;
d4187 9
a4195 15
        if (oldE->base == cachedOldBase)
          newE->base = cachedNewBase;
        else {
          cachedOldBase = oldE->base;
          tem = poolCopyString(newPool, cachedOldBase);
          if (!tem)
            return 0;
          cachedNewBase = newE->base = tem;
        }
      }
      if (oldE->publicId) {
        tem = poolCopyString(newPool, oldE->publicId);
        if (!tem)
          return 0;
        newE->publicId = tem;
d4199 1
a4199 2
      const XML_Char *tem = poolCopyStringN(newPool, oldE->textPtr,
                                            oldE->textLen);
d4201 1
a4201 1
        return 0;
d4208 1
a4208 1
        return 0;
a4210 2
    newE->is_param = oldE->is_param;
    newE->is_internal = oldE->is_internal;
d4217 2
a4218 2
static int FASTCALL
keyeq(KEY s1, KEY s2)
d4226 2
a4227 2
static unsigned long FASTCALL
hash(KEY s)
d4235 2
a4236 2
static NAMED *
lookup(HASH_TABLE *table, KEY name, size_t createSize)
d4243 1
a4243 1
      return NULL;
d4245 1
a4245 1
    table->v = (NAMED **)table->mem->malloc_fcn(tsize);
d4247 1
a4247 1
      return NULL;
d4259 1
a4259 1
        return table->v[i];
d4262 1
a4262 1
      return NULL;
d4267 1
a4267 1
      NAMED **newV = (NAMED **)table->mem->malloc_fcn(tsize);
d4269 1
a4269 1
        return NULL;
d4272 8
a4279 8
        if (table->v[i]) {
          size_t j;
          for (j = hash(table->v[i]->name) & (newSize - 1);
               newV[j];
               j == 0 ? j = newSize - 1 : --j)
            ;
          newV[j] = table->v[i];
        }
d4285 3
a4287 3
           table->v[i];
           i == 0 ? i = table->size - 1 : --i)
        ;
d4290 1
a4290 1
  table->v[i] = (NAMED *)table->mem->malloc_fcn(createSize);
d4292 1
a4292 1
    return NULL;
d4299 2
a4300 17
static void FASTCALL
hashTableClear(HASH_TABLE *table)
{
  size_t i;
  for (i = 0; i < table->size; i++) {
    NAMED *p = table->v[i];
    if (p) {
      table->mem->free_fcn(p);
      table->v[i] = NULL;
    }
  }
  table->usedLim = table->size / 2;
  table->used = 0;
}

static void FASTCALL
hashTableDestroy(HASH_TABLE *table)
d4312 2
a4313 2
static void FASTCALL
hashTableInit(HASH_TABLE *p, const XML_Memory_Handling_Suite *ms)
d4318 1
a4318 1
  p->v = NULL;
d4322 2
a4323 2
static void FASTCALL
hashTableIterInit(HASH_TABLE_ITER *iter, const HASH_TABLE *table)
d4329 2
a4330 2
static NAMED * FASTCALL
hashTableIterNext(HASH_TABLE_ITER *iter)
d4337 1
a4337 1
  return NULL;
d4340 3
a4342 2
static void FASTCALL
poolInit(STRING_POOL *pool, const XML_Memory_Handling_Suite *ms)
d4344 5
a4348 5
  pool->blocks = NULL;
  pool->freeBlocks = NULL;
  pool->start = NULL;
  pool->ptr = NULL;
  pool->end = NULL;
d4352 2
a4353 2
static void FASTCALL
poolClear(STRING_POOL *pool)
d4366 4
a4369 4
  pool->blocks = NULL;
  pool->start = NULL;
  pool->ptr = NULL;
  pool->end = NULL;
d4372 2
a4373 2
static void FASTCALL
poolDestroy(STRING_POOL *pool)
d4381 1
d4388 4
d4394 3
a4396 3
static XML_Char *
poolAppend(STRING_POOL *pool, const ENCODING *enc,
           const char *ptr, const char *end)
d4399 1
a4399 1
    return NULL;
d4405 1
a4405 1
      return NULL;
d4410 1
a4410 2
static const XML_Char * FASTCALL
poolCopyString(STRING_POOL *pool, const XML_Char *s)
d4414 1
a4414 1
      return NULL;
d4421 1
a4421 2
static const XML_Char *
poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n)
d4424 1
a4424 1
    return NULL;
d4427 2
a4428 1
      return NULL;
d4435 2
a4436 2
static const XML_Char * FASTCALL
poolAppendString(STRING_POOL *pool, const XML_Char *s)
d4440 1
a4440 1
      return NULL;
d4442 1
a4442 1
  }
d4444 1
a4444 1
}
d4446 3
a4448 3
static XML_Char *
poolStoreString(STRING_POOL *pool, const ENCODING *enc,
                const char *ptr, const char *end)
d4451 1
a4451 1
    return NULL;
d4453 1
a4453 1
    return NULL;
d4458 2
a4459 2
static XML_Bool FASTCALL
poolGrow(STRING_POOL *pool)
d4465 1
a4465 1
      pool->blocks->next = NULL;
d4469 1
a4469 1
      return XML_TRUE;
d4476 1
a4476 2
      memcpy(pool->blocks->s, pool->start,
             (pool->end - pool->start) * sizeof(XML_Char));
d4480 1
a4480 1
      return XML_TRUE;
d4485 3
a4487 6
    pool->blocks = (BLOCK *)
      pool->mem->realloc_fcn(pool->blocks,
			     (offsetof(BLOCK, s)
			      + blockSize * sizeof(XML_Char)));
    if (pool->blocks == NULL)
      return XML_FALSE;
d4500 1
a4500 2
    tem = (BLOCK *)pool->mem->malloc_fcn(offsetof(BLOCK, s)
					+ blockSize * sizeof(XML_Char));
d4502 1
a4502 1
      return XML_FALSE;
d4507 1
a4507 2
      memcpy(tem->s, pool->start,
             (pool->ptr - pool->start) * sizeof(XML_Char));
d4512 1
a4512 1
  return XML_TRUE;
d4515 1
a4515 1
static int FASTCALL
a4517 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d4521 3
a4523 3
  if (!dtd->scaffIndex) {
    dtd->scaffIndex = (int *)MALLOC(groupSize * sizeof(int));
    if (!dtd->scaffIndex)
d4525 1
a4525 1
    dtd->scaffIndex[0] = 0;
d4528 5
a4532 8
  if (dtd->scaffCount >= dtd->scaffSize) {
    CONTENT_SCAFFOLD *temp;
    if (dtd->scaffold) {
      temp = (CONTENT_SCAFFOLD *)
        REALLOC(dtd->scaffold, dtd->scaffSize * 2 * sizeof(CONTENT_SCAFFOLD));
      if (temp == NULL)
        return -1;
      dtd->scaffSize *= 2;
d4535 10
a4544 12
      temp = (CONTENT_SCAFFOLD *)MALLOC(INIT_SCAFFOLD_ELEMENTS
                                        * sizeof(CONTENT_SCAFFOLD));
      if (temp == NULL)
        return -1;
      dtd->scaffSize = INIT_SCAFFOLD_ELEMENTS;
    }
    dtd->scaffold = temp;
  }
  next = dtd->scaffCount++;
  me = &dtd->scaffold[next];
  if (dtd->scaffLevel) {
    CONTENT_SCAFFOLD *parent = &dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel-1]];
d4546 1
a4546 1
      dtd->scaffold[parent->lastchild].nextsib = next;
d4548 1
a4548 1
    if (!parent->childcnt)
d4555 1
a4555 1
}
d4558 8
a4565 9
build_node(XML_Parser parser,
           int src_node,
           XML_Content *dest,
           XML_Content **contpos,
           XML_Char **strpos)
{
  DTD * const dtd = _dtd;  /* save one level of indirection */
  dest->type = dtd->scaffold[src_node].type;
  dest->quant = dtd->scaffold[src_node].quant;
d4567 1
a4567 1
    const XML_Char *src;
d4569 1
a4569 1
    src = dtd->scaffold[src_node].name;
d4572 2
a4573 2
      if (!*src)
        break;
d4577 1
a4577 1
    dest->children = NULL;
d4582 1
a4582 1
    dest->numchildren = dtd->scaffold[src_node].childcnt;
d4585 3
a4587 3
    for (i = 0, cn = dtd->scaffold[src_node].firstchild;
         i < dest->numchildren;
         i++, cn = dtd->scaffold[cn].nextsib) {
d4590 1
a4590 1
    dest->name = NULL;
d4592 1
a4592 1
}
a4596 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d4599 6
a4604 7
  XML_Char * str;
  int allocsize = (dtd->scaffCount * sizeof(XML_Content)
                   + (dtd->contentStringLen * sizeof(XML_Char)));

  ret = (XML_Content *)MALLOC(allocsize);
  if (!ret)
    return NULL;
d4606 1
a4606 1
  str =  (XML_Char *) (&ret[dtd->scaffCount]);
d4611 1
a4611 1
}
d4615 3
a4617 3
               const ENCODING *enc,
               const char *ptr,
               const char *end)
d4619 1
a4619 2
  DTD * const dtd = _dtd;  /* save one level of indirection */
  const XML_Char *name = poolStoreString(&dtd->pool, enc, ptr, end);
d4622 5
a4626 5
  if (!name)
    return NULL;
  ret = (ELEMENT_TYPE *) lookup(&dtd->elementTypes, name, sizeof(ELEMENT_TYPE));
  if (!ret)
    return NULL;
d4628 1
a4628 1
    poolDiscard(&dtd->pool);
d4630 1
a4630 1
    poolFinish(&dtd->pool);
d4632 1
a4632 1
      return NULL;
d4635 1
a4635 1
}
@


1.1.1.1
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@@


1.1.1.2
log
@Import OpenBSD tree again due to CVS bugs
@
text
@d1 3
a3 2
/* Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd
   See the file COPYING for copying permission.
a5 3
#include <stddef.h>
#include <string.h>                     /* memset(), memcpy() */

d7 4
a10 11

#include "winconfig.h"
#define XMLPARSEAPI(type) __declspec(dllexport) type __cdecl
#include "expat.h"
#undef XMLPARSEAPI

#elif defined(MACOS_CLASSIC)

#include "macconfig.h"
#include "expat.h"

d12 1
a12 2

#include <expat_config.h>
d15 1
a15 1
#define XMLPARSEAPI(type) __declspec(dllexport) type __cdecl
d21 1
a21 1
#undef XMLPARSEAPI
d25 3
a56 2
#ifdef XML_UNICODE

d58 1
a58 2
#define XML_T(x) (const wchar_t)x
#define XML_L(x) L ## x
a59 6
#define XML_T(x) (const unsigned short)x
#define XML_L(x) x
#endif

#else

a60 2
#define XML_L(x) x

a65 9
/* Handle the case where memmove() doesn't exist. */
#ifndef HAVE_MEMMOVE
#ifdef HAVE_BCOPY
#define memmove(d,s,l) bcopy((s),(d),(l))
#else
#error memmove does not exist on this platform, nor is a substitute available
#endif /* HAVE_BCOPY */
#endif /* HAVE_MEMMOVE */

a113 1
  const XML_Char *prefix;
a114 1
  int prefixLen;
a136 1
  char is_internal;  /* true if declared in internal subset outside any PE */
d140 7
a146 7
  enum XML_Content_Type         type;
  enum XML_Content_Quant        quant;
  const XML_Char *              name;
  int                           firstchild;
  int                           lastchild;
  int                           childcnt;
  int                           nextsib;
a148 2
#define INIT_SCAFFOLD_ELEMENTS 32

d194 2
a195 8
  STRING_POOL entityValuePool;
  /* false once a parameter entity reference has been skipped */
  char keepProcessing;
  /* indicates if external PE has been read */
  char paramEntityRead;
  /* true once an internal or external PE has been read */
  char hasParamEntities;
  char standalone;
d201 1
a201 1
  char in_eldecl;
d218 3
a220 3
                                 const char *start,
                                 const char *end,
                                 const char **endPtr);
a227 4
static Processor externalParEntProcessor;
static Processor externalParEntInitProcessor;
static Processor entityValueProcessor;
static Processor entityValueInitProcessor;
d239 1
a239 2
processXmlDecl(XML_Parser parser, int isGeneralTextEntity,
               const char *, const char *);
d244 1
a244 1
         const char *end, int tok, const char *next, const char **nextPtr);
d249 1
a249 1
          const char *start, const char *end, const char **endPtr);
d251 1
a251 2
doCdataSection(XML_Parser parser, const ENCODING *, const char **startPtr,
               const char *end, const char **nextPtr);
d254 1
a254 2
doIgnoreSection(XML_Parser parser, const ENCODING *, const char **startPtr,
                const char *end, const char **nextPtr);
d256 4
a259 6
static enum XML_Error
storeAtts(XML_Parser parser, const ENCODING *,
          const char *s, TAG_NAME *tagNamePtr, BINDING **bindingsPtr);
static int
addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,
           const XML_Char *uri, BINDING **bindingsPtr);
d263 2
a264 2
                int isCdata, int isId, const XML_Char *dfltValue,
                XML_Parser parser);
d267 2
a268 2
storeAttributeValue(XML_Parser parser, const ENCODING *, int isCdata,
                    const char *, const char *, STRING_POOL *);
d270 2
a271 2
appendAttributeValue(XML_Parser parser, const ENCODING *, int isCdata,
                     const char *, const char *, STRING_POOL *);
d273 2
a274 4
getAttributeId(XML_Parser parser, const ENCODING *enc, const char *start,
               const char *end);
static int
setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *);
d276 1
a276 2
storeEntityValue(XML_Parser parser, const ENCODING *enc, const char *start,
                 const char *end);
d278 1
a278 2
reportProcessingInstruction(XML_Parser parser, const ENCODING *enc,
                            const char *start, const char *end);
d280 1
a280 2
reportComment(XML_Parser parser, const ENCODING *enc, const char *start,
              const char *end);
d282 1
a282 2
reportDefault(XML_Parser parser, const ENCODING *enc, const char *start,
              const char *end);
d294 1
a294 1
                           XML_Parser parser);
d311 1
a311 1
                            const char *ptr, const char *end);
d313 1
a313 1
                                  const char *ptr, const char *end);
d321 1
a321 2
static const XML_Char *poolCopyStringN(STRING_POOL *pool, const XML_Char *s,
                                       int n);
d324 3
a326 5
                                     const ENCODING *enc,
                                     const char *ptr,
                                     const char *end);

static int parserInit(XML_Parser parser, const XML_Char *encodingName);
d341 1
a341 2
  /* The first member must be userData so that the XML_GetUserData
     macro works. */
a372 1
  XML_SkippedEntityHandler m_skippedEntityHandler;
d423 1
a424 1
  XML_Parser m_parentParser;
a425 1
  int m_isParamEntity;
d427 1
a454 1
#define skippedEntityHandler (((Parser *)parser)->m_skippedEntityHandler)
d514 1
d516 1
a517 2
#ifdef XML_DTD
#define isParamEntity (((Parser *)parser)->m_isParamEntity)
d522 1
a522 2
BOOL WINAPI
DllMain(HINSTANCE h, DWORD r, LPVOID p) {
d529 1
a529 2
Parser *
asParser(XML_Parser parser)
d536 1
a536 2
XML_Parser
XML_ParserCreate(const XML_Char *encodingName)
d541 1
a541 2
XML_Parser
XML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep)
d550 3
a552 2
                    const XML_Memory_Handling_Suite *memsuite,
                    const XML_Char *nameSep) {
d554 12
a565 5
  static const XML_Char implicitContext[] = {
    'x', 'm', 'l', '=', 'h', 't', 't', 'p', ':', '/', '/',
    'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g', '/',
    'X', 'M', 'L', '/', '1', '9', '9', '8', '/',
    'n', 'a', 'm', 'e', 's', 'p', 'a', 'c', 'e', '\0'
d572 4
a575 6
    if (parser != NULL) {
      mtemp = &(((Parser *) parser)->m_mem);
      mtemp->malloc_fcn = memsuite->malloc_fcn;
      mtemp->realloc_fcn = memsuite->realloc_fcn;
      mtemp->free_fcn = memsuite->free_fcn;
    }
d580 4
a583 6
    if (parser != NULL) {
      mtemp = &(((Parser *) parser)->m_mem);
      mtemp->malloc_fcn = malloc;
      mtemp->realloc_fcn = realloc;
      mtemp->free_fcn = free;
    }
d588 52
a639 4

  buffer = NULL;
  bufferLim = NULL;

d642 1
a642 4
  if (atts == NULL) {
    FREE(parser);
    return NULL;
  }
d644 7
a650 10
  if (dataBuf == NULL) {
    FREE(atts);
    FREE(parser);
    return NULL;
  }
  dataBufEnd = dataBuf + INIT_DATA_BUF_SIZE;
  freeBindingList = NULL;
  inheritedBindings = NULL;
  freeTagList = NULL;

d652 4
d660 4
a663 3

  if (!parserInit(parser, encodingName) || !atts
      || !dataBuf || (encodingName && !protocolEncodingName)) {
d665 1
a665 1
    return NULL;
d667 1
d670 1
d675 1
a675 1
    if (!setContext(parser, implicitContext)) {
d677 1
a677 1
      return NULL;
d681 1
d686 1
a686 1
}
d688 1
a688 2
static int
parserInit(XML_Parser parser, const XML_Char *encodingName)
d690 2
a691 90
  processor = prologInitProcessor;
  XmlPrologStateInit(&prologState);
  protocolEncodingName = (encodingName != NULL
                          ? poolCopyString(&tempPool, encodingName)
                          : NULL);
  curBase = NULL;
  XmlInitEncoding(&initEncoding, &encoding, 0);
  userData = NULL;
  handlerArg = NULL;
  startElementHandler = NULL;
  endElementHandler = NULL;
  characterDataHandler = NULL;
  processingInstructionHandler = NULL;
  commentHandler = NULL;
  startCdataSectionHandler = NULL;
  endCdataSectionHandler = NULL;
  defaultHandler = NULL;
  startDoctypeDeclHandler = NULL;
  endDoctypeDeclHandler = NULL;
  unparsedEntityDeclHandler = NULL;
  notationDeclHandler = NULL;
  startNamespaceDeclHandler = NULL;
  endNamespaceDeclHandler = NULL;
  notStandaloneHandler = NULL;
  externalEntityRefHandler = NULL;
  externalEntityRefHandlerArg = parser;
  skippedEntityHandler = NULL;
  unknownEncodingHandler = NULL;
  elementDeclHandler = NULL;
  attlistDeclHandler = NULL;
  entityDeclHandler = NULL;
  xmlDeclHandler = NULL;
  bufferPtr = buffer;
  bufferEnd = buffer;
  parseEndByteIndex = 0;
  parseEndPtr = NULL;
  declElementType = NULL;
  declAttributeId = NULL;
  declEntity = NULL;
  doctypeName = NULL;
  doctypeSysid = NULL;
  doctypePubid = NULL;
  declAttributeType = NULL;
  declNotationName = NULL;
  declNotationPublicId = NULL;
  declAttributeIsCdata = 0;
  declAttributeIsId = 0;
  memset(&position, 0, sizeof(POSITION));
  errorCode = XML_ERROR_NONE;
  eventPtr = NULL;
  eventEndPtr = NULL;
  positionPtr = NULL;
  openInternalEntities = 0;
  defaultExpandInternalEntities = 1;
  tagLevel = 0;
  tagStack = 0;
  nSpecifiedAtts = 0;
  groupSize = 0;
  groupConnector = NULL;
  unknownEncodingMem = NULL;
  unknownEncodingRelease = NULL;
  unknownEncodingData = NULL;
  unknownEncodingHandlerData = NULL;
  parentParser = NULL;
#ifdef XML_DTD
  isParamEntity = 0;
  paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;
  return dtdInit(&dtd, parser);
#else
  return 1;
#endif
}

int
XML_ParserReset(XML_Parser parser, const XML_Char *encodingName)
{
  if (parentParser) return 0;
#ifdef XML_DTD
  if (dtd.scaffold) dtdDestroy(&dtd, parser);
#endif
  poolClear(&tempPool);
  poolClear(&temp2Pool);
  return parserInit(parser, encodingName);
}

int
XML_SetEncoding(XML_Parser parser, const XML_Char *encodingName)
{
  if (encodingName == NULL)
    protocolEncodingName = NULL;
d700 3
a702 4
XML_Parser
XML_ExternalEntityParserCreate(XML_Parser oldParser,
                               const XML_Char *context,
                               const XML_Char *encodingName)
a719 1
  XML_SkippedEntityHandler oldSkippedEntityHandler = skippedEntityHandler;
a732 1
  int oldInEntityValue = prologState.inEntityValue;
d741 1
a741 1
                                 tmp);
d745 1
a745 1
                                 NULL);
d749 1
a749 1
    return NULL;
a764 1
  skippedEntityHandler = oldSkippedEntityHandler;
a779 1
  parentParser = oldParser;
a781 1
  prologState.inEntityValue = oldInEntityValue;
d786 1
a786 1
      return NULL;
d793 1
a793 1
    isParamEntity = 1;
d795 2
a796 1
    processor = externalParEntInitProcessor;
d802 2
a803 2
static void
destroyBindings(BINDING *bindings, XML_Parser parser)
d815 1
a815 2
void
XML_ParserFree(XML_Parser parser)
d820 2
a821 2
      if (freeTagList == NULL)
        break;
d823 1
a823 1
      freeTagList = NULL;
d836 3
a838 1
  if (isParamEntity)
d840 1
d856 1
a856 2
void
XML_UseParserAsHandlerArg(XML_Parser parser)
d866 1
a866 2
void
XML_SetUserData(XML_Parser parser, void *p)
d874 1
a874 2
int
XML_SetBase(XML_Parser parser, const XML_Char *p)
d883 1
a883 1
    curBase = NULL;
d887 1
a887 2
const XML_Char *
XML_GetBase(XML_Parser parser)
d892 1
a892 2
int
XML_GetSpecifiedAttributeCount(XML_Parser parser)
d897 1
a897 2
int
XML_GetIdAttributeIndex(XML_Parser parser)
d902 3
a904 4
void
XML_SetElementHandler(XML_Parser parser,
                      XML_StartElementHandler start,
                      XML_EndElementHandler end)
d910 2
a911 3
void
XML_SetStartElementHandler(XML_Parser parser,
                           XML_StartElementHandler start) {
d915 2
a916 3
void
XML_SetEndElementHandler(XML_Parser parser,
                         XML_EndElementHandler end) {
d920 2
a921 3
void
XML_SetCharacterDataHandler(XML_Parser parser,
                            XML_CharacterDataHandler handler)
d926 2
a927 3
void
XML_SetProcessingInstructionHandler(XML_Parser parser,
                                    XML_ProcessingInstructionHandler handler)
d932 2
a933 3
void
XML_SetCommentHandler(XML_Parser parser,
                      XML_CommentHandler handler)
d938 3
a940 4
void
XML_SetCdataSectionHandler(XML_Parser parser,
                           XML_StartCdataSectionHandler start,
                           XML_EndCdataSectionHandler end)
d946 2
a947 3
void
XML_SetStartCdataSectionHandler(XML_Parser parser,
                                XML_StartCdataSectionHandler start) {
d951 2
a952 3
void
XML_SetEndCdataSectionHandler(XML_Parser parser,
                              XML_EndCdataSectionHandler end) {
d956 2
a957 3
void
XML_SetDefaultHandler(XML_Parser parser,
                      XML_DefaultHandler handler)
d963 2
a964 3
void
XML_SetDefaultHandlerExpand(XML_Parser parser,
                            XML_DefaultHandler handler)
d970 3
a972 4
void
XML_SetDoctypeDeclHandler(XML_Parser parser,
                          XML_StartDoctypeDeclHandler start,
                          XML_EndDoctypeDeclHandler end)
d978 2
a979 3
void
XML_SetStartDoctypeDeclHandler(XML_Parser parser,
                               XML_StartDoctypeDeclHandler start) {
d983 2
a984 3
void
XML_SetEndDoctypeDeclHandler(XML_Parser parser,
                             XML_EndDoctypeDeclHandler end) {
d988 2
a989 3
void
XML_SetUnparsedEntityDeclHandler(XML_Parser parser,
                                 XML_UnparsedEntityDeclHandler handler)
d994 2
a995 3
void
XML_SetNotationDeclHandler(XML_Parser parser,
                           XML_NotationDeclHandler handler)
d1000 3
a1002 4
void
XML_SetNamespaceDeclHandler(XML_Parser parser,
                            XML_StartNamespaceDeclHandler start,
                            XML_EndNamespaceDeclHandler end)
d1008 2
a1009 3
void
XML_SetStartNamespaceDeclHandler(XML_Parser parser,
                                 XML_StartNamespaceDeclHandler start) {
d1013 2
a1014 3
void
XML_SetEndNamespaceDeclHandler(XML_Parser parser,
                               XML_EndNamespaceDeclHandler end) {
d1018 3
a1020 3
void
XML_SetNotStandaloneHandler(XML_Parser parser,
                            XML_NotStandaloneHandler handler)
d1025 2
a1026 3
void
XML_SetExternalEntityRefHandler(XML_Parser parser,
                                XML_ExternalEntityRefHandler handler)
d1031 1
a1031 2
void
XML_SetExternalEntityRefHandlerArg(XML_Parser parser, void *arg)
d1039 3
a1041 11
void
XML_SetSkippedEntityHandler(XML_Parser parser,
                            XML_SkippedEntityHandler handler)
{
  skippedEntityHandler = handler;
}

void
XML_SetUnknownEncodingHandler(XML_Parser parser,
                              XML_UnknownEncodingHandler handler,
                              void *data)
d1047 2
a1048 3
void
XML_SetElementDeclHandler(XML_Parser parser,
                          XML_ElementDeclHandler eldecl)
d1053 2
a1054 3
void
XML_SetAttlistDeclHandler(XML_Parser parser,
                          XML_AttlistDeclHandler attdecl)
d1059 2
a1060 3
void
XML_SetEntityDeclHandler(XML_Parser parser,
                         XML_EntityDeclHandler handler)
d1065 2
a1066 3
void
XML_SetXmlDeclHandler(XML_Parser parser,
                      XML_XmlDeclHandler handler) {
d1070 2
a1071 3
int
XML_SetParamEntityParsing(XML_Parser parser,
                          enum XML_ParamEntityParsing parsing)
d1081 1
a1081 2
int
XML_Parse(XML_Parser parser, const char *s, int len, int isFinal)
d1103 1
a1103 1
        return 1;
d1118 10
a1127 15
        /* FIXME avoid integer overflow */
        char *temp;
        temp = buffer == 0 ? MALLOC(len * 2) : REALLOC(buffer, len * 2);
        if (temp == NULL) {
          errorCode = XML_ERROR_NO_MEMORY;
          return 0;
        }
        buffer = temp;
        if (!buffer) {
          errorCode = XML_ERROR_NO_MEMORY;
          eventPtr = eventEndPtr = NULL;
          processor = errorProcessor;
          return 0;
        }
        bufferLim = buffer + len * 2;
d1137 2
a1138 7
    void *buff = XML_GetBuffer(parser, len);
    if (buff == NULL)
      return 0;
    else {
      memcpy(buff, s, len);
      return XML_ParseBuffer(parser, len, isFinal);
    }
d1142 1
a1142 2
int
XML_ParseBuffer(XML_Parser parser, int len, int isFinal)
d1149 1
a1149 1
                        isFinal ? (const char **)0 : &bufferPtr);
d1162 1
a1162 2
void *
XML_GetBuffer(XML_Parser parser, int len)
d1177 4
a1180 4
        int offset = (bufferPtr - buffer) - keep;
        memmove(buffer, &buffer[offset], bufferEnd - bufferPtr + keep);
        bufferEnd -= offset;
        bufferPtr -= offset;
d1192 1
a1192 1
        bufferSize = INIT_BUFFER_SIZE;
d1194 1
a1194 1
        bufferSize *= 2;
d1198 2
a1199 2
        errorCode = XML_ERROR_NO_MEMORY;
        return NULL;
d1204 8
a1211 8
        int keep = bufferPtr - buffer;
        if (keep > XML_CONTEXT_BYTES)
          keep = XML_CONTEXT_BYTES;
        memcpy(newBuf, &bufferPtr[-keep], bufferEnd - bufferPtr + keep);
        FREE(buffer);
        buffer = newBuf;
        bufferEnd = buffer + (bufferEnd - bufferPtr) + keep;
        bufferPtr = buffer + keep;
d1214 2
a1215 2
        bufferEnd = newBuf + (bufferEnd - bufferPtr);
        bufferPtr = buffer = newBuf;
d1219 2
a1220 2
        memcpy(newBuf, bufferPtr, bufferEnd - bufferPtr);
        FREE(buffer);
d1230 1
a1230 2
enum XML_Error
XML_GetErrorCode(XML_Parser parser)
d1235 1
a1235 2
long
XML_GetCurrentByteIndex(XML_Parser parser)
d1242 1
a1242 2
int
XML_GetCurrentByteCount(XML_Parser parser)
d1249 1
a1249 2
const char *
XML_GetInputContext(XML_Parser parser, int *offset, int *size)
d1261 1
a1261 2
int
XML_GetCurrentLineNumber(XML_Parser parser)
d1270 1
a1270 2
int
XML_GetCurrentColumnNumber(XML_Parser parser)
d1279 1
a1279 2
void
XML_DefaultCurrent(XML_Parser parser)
d1284 3
a1286 3
                    internalEncoding,
                    openInternalEntities->internalEventPtr,
                    openInternalEntities->internalEventEndPtr);
d1292 1
a1292 2
const XML_LChar *
XML_ErrorString(int code)
d1296 23
a1318 24
    XML_L("out of memory"),
    XML_L("syntax error"),
    XML_L("no element found"),
    XML_L("not well-formed (invalid token)"),
    XML_L("unclosed token"),
    XML_L("partial character"),
    XML_L("mismatched tag"),
    XML_L("duplicate attribute"),
    XML_L("junk after document element"),
    XML_L("illegal parameter entity reference"),
    XML_L("undefined entity"),
    XML_L("recursive entity reference"),
    XML_L("asynchronous entity"),
    XML_L("reference to invalid character number"),
    XML_L("reference to binary entity"),
    XML_L("reference to external entity in attribute"),
    XML_L("xml processing instruction not at start of external entity"),
    XML_L("unknown encoding"),
    XML_L("encoding specified in XML declaration is incorrect"),
    XML_L("unclosed CDATA section"),
    XML_L("error in processing external entity reference"),
    XML_L("document is not standalone"),
    XML_L("unexpected parser state - please send a bug report"),
    XML_L("entity declared in parameter entity")
d1322 1
a1322 1
  return NULL;
d1327 1
a1327 16

  /* V1 is used to string-ize the version number. However, it would
     string-ize the actual version macro *names* unless we get them
     substituted before being passed to V1. CPP is defined to expand
     a macro, then rescan for more expansions. Thus, we use V2 to expand
     the version macros, then CPP will expand the resulting V1() macro
     with the correct numerals. */
  /* ### I'm assuming cpp is portable in this respect... */

#define V1(a,b,c) XML_L("expat_")XML_L(#a)XML_L(".")XML_L(#b)XML_L(".")XML_L(#c)
#define V2(a,b,c) V1(a,b,c)

  return V2(XML_MAJOR_VERSION, XML_MINOR_VERSION, XML_MICRO_VERSION);

#undef V1
#undef V2
d1343 3
a1345 3
                                const char *start,
                                const char *end,
                                const char **endPtr)
d1350 5
a1354 5
static enum XML_Error
externalEntityInitProcessor(XML_Parser parser,
                            const char *start,
                            const char *end,
                            const char **endPtr)
d1363 5
a1367 5
static enum XML_Error
externalEntityInitProcessor2(XML_Parser parser,
                             const char *start,
                             const char *end,
                             const char **endPtr)
d1369 1
a1369 1
  const char *next = start; /* XmlContentTok doesn't always set the last arg */
a1372 9
    /* If we are at the end of the buffer, this would cause the next stage,
       i.e. externalEntityInitProcessor3, to pass control directly to
       doContent (by detecting XML_TOK_NONE) without processing any xml text
       declaration - causing the error XML_ERROR_MISPLACED_XML_PI in doContent.
    */
    if (next == end && endPtr) {
      *endPtr = next;
      return XML_ERROR_NONE;
    }
d1394 5
a1398 5
static enum XML_Error
externalEntityInitProcessor3(XML_Parser parser,
                             const char *start,
                             const char *end,
                             const char **endPtr)
d1400 1
a1400 1
  const char *next = start; /* XmlContentTok doesn't always set the last arg */
d1407 1
a1407 1
        return result;
d1431 5
a1435 5
static enum XML_Error
externalEntityContentProcessor(XML_Parser parser,
                               const char *start,
                               const char *end,
                               const char **endPtr)
d1442 5
a1446 5
          int startTagLevel,
          const ENCODING *enc,
          const char *s,
          const char *end,
          const char **nextPtr)
d1466 2
a1467 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d1471 2
a1472 2
        XML_Char c = 0xA;
        characterDataHandler(handlerArg, &c, 1);
d1475 1
a1475 1
        reportDefault(parser, enc, s, end);
d1477 1
a1477 1
        return XML_ERROR_NO_ELEMENTS;
d1479 1
a1479 1
        return XML_ERROR_ASYNC_ENTITY;
d1483 2
a1484 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d1487 3
a1489 3
        if (tagLevel != startTagLevel)
          return XML_ERROR_ASYNC_ENTITY;
        return XML_ERROR_NONE;
d1497 2
a1498 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d1503 2
a1504 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d1509 74
a1582 85
        const XML_Char *name;
        ENTITY *entity;
        XML_Char ch = (XML_Char) XmlPredefinedEntityName(enc,
                                              s + enc->minBytesPerChar,
                                              next - enc->minBytesPerChar);
        if (ch) {
          if (characterDataHandler)
            characterDataHandler(handlerArg, &ch, 1);
          else if (defaultHandler)
            reportDefault(parser, enc, s, next);
          break;
        }
        name = poolStoreString(&dtd.pool, enc,
                                s + enc->minBytesPerChar,
                                next - enc->minBytesPerChar);
        if (!name)
          return XML_ERROR_NO_MEMORY;
        entity = (ENTITY *)lookup(&dtd.generalEntities, name, 0);
        poolDiscard(&dtd.pool);
        /* First, determine if a check for an existing declaration is needed;
           if yes, check that the entity exists, and that it is internal,
           otherwise call the skipped entity or default handler.
        */
        if (!dtd.hasParamEntities || dtd.standalone) {
          if (!entity)
            return XML_ERROR_UNDEFINED_ENTITY;
          else if (!entity->is_internal)
            return XML_ERROR_ENTITY_DECLARED_IN_PE;
        }
        else if (!entity) {
          if (skippedEntityHandler)
            skippedEntityHandler(handlerArg, name, 0);
          else if (defaultHandler)
            reportDefault(parser, enc, s, next);
          break;
        }
        if (entity->open)
          return XML_ERROR_RECURSIVE_ENTITY_REF;
        if (entity->notation)
          return XML_ERROR_BINARY_ENTITY_REF;
        if (entity->textPtr) {
          enum XML_Error result;
          OPEN_INTERNAL_ENTITY openEntity;
          if (!defaultExpandInternalEntities) {
            if (skippedEntityHandler)
              skippedEntityHandler(handlerArg, entity->name, 0);
            else if (defaultHandler)
              reportDefault(parser, enc, s, next);
            break;
          }
          entity->open = 1;
          openEntity.next = openInternalEntities;
          openInternalEntities = &openEntity;
          openEntity.entity = entity;
          openEntity.internalEventPtr = NULL;
          openEntity.internalEventEndPtr = NULL;
          result = doContent(parser,
                             tagLevel,
                             internalEncoding,
                             (char *)entity->textPtr,
                             (char *)(entity->textPtr + entity->textLen),
                             0);
          entity->open = 0;
          openInternalEntities = openEntity.next;
          if (result)
            return result;
        }
        else if (externalEntityRefHandler) {
          const XML_Char *context;
          entity->open = 1;
          context = getContext(parser);
          entity->open = 0;
          if (!context)
            return XML_ERROR_NO_MEMORY;
          if (!externalEntityRefHandler(externalEntityRefHandlerArg,
                                        context,
                                        entity->base,
                                        entity->systemId,
                                        entity->publicId))
            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
          poolDiscard(&tempPool);
        }
        else if (defaultHandler)
          reportDefault(parser, enc, s, next);
        break;
d1586 3
a1588 3
        enum XML_Error result = storeAtts(parser, enc, s, 0, 0);
        if (result)
          return result;
d1593 73
a1665 83
        TAG *tag;
        enum XML_Error result;
        XML_Char *toPtr;
        if (freeTagList) {
          tag = freeTagList;
          freeTagList = freeTagList->parent;
        }
        else {
          tag = MALLOC(sizeof(TAG));
          if (!tag)
            return XML_ERROR_NO_MEMORY;
          tag->buf = MALLOC(INIT_TAG_BUF_SIZE);
          if (!tag->buf) {
            FREE(tag);
            return XML_ERROR_NO_MEMORY;
          }
          tag->bufEnd = tag->buf + INIT_TAG_BUF_SIZE;
        }
        tag->bindings = NULL;
        tag->parent = tagStack;
        tagStack = tag;
        tag->name.localPart = NULL;
        tag->name.prefix = NULL;
        tag->rawName = s + enc->minBytesPerChar;
        tag->rawNameLength = XmlNameLength(enc, tag->rawName);
        if (nextPtr) {
          /* Need to guarantee that:
             tag->buf + ROUND_UP(tag->rawNameLength, sizeof(XML_Char))
                <= tag->bufEnd - sizeof(XML_Char) */
          if (tag->rawNameLength + (int)(sizeof(XML_Char) - 1)
              + (int)sizeof(XML_Char) > tag->bufEnd - tag->buf) {
            int bufSize = tag->rawNameLength * 4;
            bufSize = ROUND_UP(bufSize, sizeof(XML_Char));
            {
              char *temp = REALLOC(tag->buf, bufSize);
              if (temp == NULL)
                return XML_ERROR_NO_MEMORY;
              tag->buf = temp;
            }
            tag->bufEnd = tag->buf + bufSize;
          }
          memcpy(tag->buf, tag->rawName, tag->rawNameLength);
          tag->rawName = tag->buf;
        }
        ++tagLevel;
        for (;;) {
          const char *rawNameEnd = tag->rawName + tag->rawNameLength;
          const char *fromPtr = tag->rawName;
          int bufSize;
          if (nextPtr)
            toPtr = (XML_Char *)(tag->buf + ROUND_UP(tag->rawNameLength,
                                                     sizeof(XML_Char)));
          else
            toPtr = (XML_Char *)tag->buf;
          tag->name.str = toPtr;
          XmlConvert(enc,
                     &fromPtr, rawNameEnd,
                     (ICHAR **)&toPtr, (ICHAR *)tag->bufEnd - 1);
          if (fromPtr == rawNameEnd)
            break;
          bufSize = (tag->bufEnd - tag->buf) << 1;
          {
            char *temp = REALLOC(tag->buf, bufSize);
            if (temp == NULL)
              return XML_ERROR_NO_MEMORY;
            tag->buf = temp;
          }
          tag->bufEnd = tag->buf + bufSize;
          if (nextPtr)
            tag->rawName = tag->buf;
        }
        *toPtr = XML_T('\0');
        if (startElementHandler) {
          result = storeAtts(parser, enc, s, &(tag->name), &(tag->bindings));
          if (result)
            return result;
          startElementHandler(handlerArg, tag->name.str,
                              (const XML_Char **)atts);
        }
        else if (defaultHandler)
          reportDefault(parser, enc, s, next);
        poolClear(&tempPool);
        break;
d1669 3
a1671 3
        enum XML_Error result = storeAtts(parser, enc, s, 0, 0);
        if (result)
          return result;
d1676 30
a1705 30
        const char *rawName = s + enc->minBytesPerChar;
        enum XML_Error result;
        BINDING *bindings = NULL;
        TAG_NAME name;
        name.str = poolStoreString(&tempPool, enc, rawName,
                                   rawName + XmlNameLength(enc, rawName));
        if (!name.str)
          return XML_ERROR_NO_MEMORY;
        poolFinish(&tempPool);
        result = storeAtts(parser, enc, s, &name, &bindings);
        if (result)
          return result;
        poolFinish(&tempPool);
        if (startElementHandler)
          startElementHandler(handlerArg, name.str, (const XML_Char **)atts);
        if (endElementHandler) {
          if (startElementHandler)
            *eventPP = *eventEndPP;
          endElementHandler(handlerArg, name.str);
        }
        poolClear(&tempPool);
        while (bindings) {
          BINDING *b = bindings;
          if (endNamespaceDeclHandler)
            endNamespaceDeclHandler(handlerArg, b->prefix->name);
          bindings = bindings->nextTagBinding;
          b->nextTagBinding = freeBindingList;
          freeBindingList = b;
          b->prefix->binding = b->prevPrefixBinding;
        }
d1708 1
a1708 1
        reportDefault(parser, enc, s, next);
d1710 1
a1710 1
        return epilogProcessor(parser, next, end, nextPtr);
d1716 36
a1751 49
        int len;
        const char *rawName;
        TAG *tag = tagStack;
        tagStack = tag->parent;
        tag->parent = freeTagList;
        freeTagList = tag;
        rawName = s + enc->minBytesPerChar*2;
        len = XmlNameLength(enc, rawName);
        if (len != tag->rawNameLength
            || memcmp(tag->rawName, rawName, len) != 0) {
          *eventPP = rawName;
          return XML_ERROR_TAG_MISMATCH;
        }
        --tagLevel;
        if (endElementHandler) {
          const XML_Char *localPart;
          const XML_Char *prefix;
          XML_Char *uri;
          localPart = tag->name.localPart;
          if (ns && localPart) {
            /* localPart and prefix may have been overwritten in
               tag->name.str, since this points to the binding->uri
               buffer which gets re-used; so we have to add them again
            */
            uri = (XML_Char *)tag->name.str + tag->name.uriLen;
            /* don't need to check for space - already done in storeAtts() */
            while (*localPart) *uri++ = *localPart++;
            prefix = (XML_Char *)tag->name.prefix;
            if (ns_triplets && prefix) {
              *uri++ = namespaceSeparator;
              while (*prefix) *uri++ = *prefix++;
             }
            *uri = XML_T('\0');
          }
          endElementHandler(handlerArg, tag->name.str);
        }
        else if (defaultHandler)
          reportDefault(parser, enc, s, next);
        while (tag->bindings) {
          BINDING *b = tag->bindings;
          if (endNamespaceDeclHandler)
            endNamespaceDeclHandler(handlerArg, b->prefix->name);
          tag->bindings = tag->bindings->nextTagBinding;
          b->nextTagBinding = freeBindingList;
          freeBindingList = b;
          b->prefix->binding = b->prevPrefixBinding;
        }
        if (tagLevel == 0)
          return epilogProcessor(parser, next, end, nextPtr);
d1756 9
a1764 9
        int n = XmlCharRefNumber(enc, s);
        if (n < 0)
          return XML_ERROR_BAD_CHAR_REF;
        if (characterDataHandler) {
          XML_Char buf[XML_ENCODE_MAX];
          characterDataHandler(handlerArg, buf, XmlEncode(n, (ICHAR *)buf));
        }
        else if (defaultHandler)
          reportDefault(parser, enc, s, next);
d1771 2
a1772 2
        XML_Char c = 0xA;
        characterDataHandler(handlerArg, &c, 1);
d1775 1
a1775 1
        reportDefault(parser, enc, s, next);
d1779 3
a1781 3
        enum XML_Error result;
        if (startCdataSectionHandler)
          startCdataSectionHandler(handlerArg);
d1783 13
a1795 14
        /* Suppose you doing a transformation on a document that involves
           changing only the character data.  You set up a defaultHandler
           and a characterDataHandler.  The defaultHandler simply copies
           characters through.  The characterDataHandler does the
           transformation and writes the characters out escaping them as
           necessary.  This case will fail to work if we leave out the
           following two lines (because & and < inside CDATA sections will
           be incorrectly escaped).

           However, now we have a start/endCdataSectionHandler, so it seems
           easier to let the user deal with this.
        */
        else if (characterDataHandler)
          characterDataHandler(handlerArg, dataBuf, 0);
d1797 7
a1803 7
        else if (defaultHandler)
          reportDefault(parser, enc, s, next);
        result = doCdataSection(parser, enc, &next, end, nextPtr);
        if (!next) {
          processor = cdataSectionProcessor;
          return result;
        }
d1808 2
a1809 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d1812 9
a1820 10
        if (MUST_CONVERT(enc, s)) {
          ICHAR *dataPtr = (ICHAR *)dataBuf;
          XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)dataBufEnd);
          characterDataHandler(handlerArg, dataBuf,
                               dataPtr - (ICHAR *)dataBuf);
        }
        else
          characterDataHandler(handlerArg,
                               (XML_Char *)s,
                               (XML_Char *)end - (XML_Char *)s);
d1823 1
a1823 1
        reportDefault(parser, enc, s, end);
d1826 1
a1826 1
        return XML_ERROR_NO_ELEMENTS;
d1829 2
a1830 2
        *eventPP = end;
        return XML_ERROR_ASYNC_ENTITY;
d1835 15
a1849 16
        if (MUST_CONVERT(enc, s)) {
          for (;;) {
            ICHAR *dataPtr = (ICHAR *)dataBuf;
            XmlConvert(enc, &s, next, &dataPtr, (ICHAR *)dataBufEnd);
            *eventEndPP = s;
            characterDataHandler(handlerArg, dataBuf,
                                 dataPtr - (ICHAR *)dataBuf);
            if (s == next)
              break;
            *eventPP = s;
          }
        }
        else
          characterDataHandler(handlerArg,
                               (XML_Char *)s,
                               (XML_Char *)next - (XML_Char *)s);
d1852 1
a1852 1
        reportDefault(parser, enc, s, next);
d1856 1
a1856 1
        return XML_ERROR_NO_MEMORY;
d1860 1
a1860 1
        return XML_ERROR_NO_MEMORY;
d1864 1
a1864 1
        reportDefault(parser, enc, s, next);
d1873 5
a1877 6
   otherwise just check the attributes for well-formedness.
*/
static enum XML_Error
storeAtts(XML_Parser parser, const ENCODING *enc,
          const char *attStr, TAG_NAME *tagNamePtr,
          BINDING **bindingsPtr)
d1879 1
a1879 1
  ELEMENT_TYPE *elementType = NULL;
d1881 1
a1881 1
  const XML_Char **appAtts;   /* the attribute list for the application */
a1882 1
  int prefixLen;
a1884 1
  XML_Char *uri;
d1895 2
a1896 3
        return XML_ERROR_NO_MEMORY;
      elementType = (ELEMENT_TYPE *)lookup(&dtd.elementTypes, tagNamePtr->str,
                                           sizeof(ELEMENT_TYPE));
a1907 1
    ATTRIBUTE *temp;
d1909 2
a1910 2
    temp = REALLOC((void *)atts, attsSize * sizeof(ATTRIBUTE));
    if (temp == NULL)
a1911 1
    atts = temp;
d1919 2
a1920 2
                                         atts[i].name
                                         + XmlNameLength(enc, atts[i].name));
d1926 1
a1926 1
        eventPtr = atts[i].name;
d1937 7
a1943 7
        int j;
        for (j = 0; j < nDefaultAtts; j++) {
          if (attId == elementType->defaultAtts[j].id) {
            isCdata = elementType->defaultAtts[j].isCdata;
            break;
          }
        }
d1948 2
a1949 2
                                   atts[i].valuePtr, atts[i].valueEnd,
                                   &tempPool);
d1951 1
a1951 1
        return result;
d1953 2
a1954 2
        appAtts[attIndex] = poolStart(&tempPool);
        poolFinish(&tempPool);
d1957 1
a1957 1
        poolDiscard(&tempPool);
d1961 1
a1961 2
      appAtts[attIndex] = poolStoreString(&tempPool, enc, atts[i].valuePtr,
                                          atts[i].valueEnd);
d1963 1
a1963 1
        return XML_ERROR_NO_MEMORY;
d1969 2
a1970 3
        /* deal with namespace declarations here */
        if (!addBinding(parser, attId->prefix, attId, appAtts[attIndex],
                        bindingsPtr))
d1975 1
a1975 1
        /* deal with other prefixed names later */
d1989 4
a1992 4
        if (appAtts[i] == elementType->idAtt->name) {
          idAttIndex = i;
          break;
        }
d2002 3
a2004 4
            if (!addBinding(parser, da->id->prefix, da->id, da->value,
                            bindingsPtr))
              return XML_ERROR_NO_MEMORY;
          }
d2006 11
a2016 11
            (da->id->name)[-1] = 2;
            nPrefixes++;
            appAtts[attIndex++] = da->id->name;
            appAtts[attIndex++] = da->value;
          }
        }
        else {
          (da->id->name)[-1] = 1;
          appAtts[attIndex++] = da->id->name;
          appAtts[attIndex++] = da->value;
        }
d2028 29
a2056 29
        id = (ATTRIBUTE_ID *)lookup(&dtd.attributeIds, appAtts[i], 0);
        if (id->prefix->binding) {
          int j;
          const BINDING *b = id->prefix->binding;
          const XML_Char *s = appAtts[i];
          for (j = 0; j < b->uriLen; j++) {
            if (!poolAppendChar(&tempPool, b->uri[j]))
              return XML_ERROR_NO_MEMORY;
          }
          while (*s++ != XML_T(':'))
            ;
          do {
            if (!poolAppendChar(&tempPool, *s))
              return XML_ERROR_NO_MEMORY;
          } while (*s++);
          if (ns_triplets) {
            tempPool.ptr[-1] = namespaceSeparator;
            s = b->prefix->name;
            do {
              if (!poolAppendChar(&tempPool, *s))
                return XML_ERROR_NO_MEMORY;
            } while (*s++);
          }

          appAtts[i] = poolStart(&tempPool);
          poolFinish(&tempPool);
        }
        if (!--nPrefixes)
          break;
d2059 1
a2059 1
        ((XML_Char *)(appAtts[i]))[-1] = 0;
a2083 5
  prefixLen = 0;
  if (ns && ns_triplets && binding->prefix->name) {
    for (; binding->prefix->name[prefixLen++];)
      ;
  }
a2085 2
  tagNamePtr->prefix = binding->prefix->name;
  tagNamePtr->prefixLen = prefixLen;
d2088 1
a2088 1
  n = i + binding->uriLen + prefixLen;
d2091 1
a2091 1
    uri = MALLOC((n + EXPAND_SPARE) * sizeof(XML_Char));
d2098 1
a2098 1
        p->name.str = uri;
d2102 1
a2102 7
  uri = binding->uri + binding->uriLen;
  memcpy(uri, localPart, i * sizeof(XML_Char));
  if (prefixLen) {
        uri = uri + (i - 1);
    if (namespaceSeparator) { *(uri) = namespaceSeparator; }
    memcpy(uri + 1, binding->prefix->name, prefixLen * sizeof(XML_Char));
  }
d2107 2
a2108 3
static int
addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,
           const XML_Char *uri, BINDING **bindingsPtr)
d2119 3
a2121 5
      XML_Char *temp = REALLOC(b->uri,
                               sizeof(XML_Char) * (len + EXPAND_SPARE));
      if (temp == NULL)
        return 0;
      b->uri = temp;
d2145 1
a2145 1
    prefix->binding = NULL;
d2152 1
a2152 1
                              prefix->binding ? uri : 0);
d2157 7
a2163 7
   the whole file is parsed with one call.
*/
static enum XML_Error
cdataSectionProcessor(XML_Parser parser,
                      const char *start,
                      const char *end,
                      const char **endPtr)
d2165 1
a2165 2
  enum XML_Error result = doCdataSection(parser, encoding, &start,
                                         end, endPtr);
d2167 2
a2168 8
    if (parentParser) {  /* we are parsing an external entity */
      processor = externalEntityContentProcessor;
      return externalEntityContentProcessor(parser, start, end, endPtr);
    }
    else {
      processor = contentProcessor;
      return contentProcessor(parser, start, end, endPtr);
    }
d2174 8
a2181 8
   the section is not yet closed.
*/
static enum XML_Error
doCdataSection(XML_Parser parser,
               const ENCODING *enc,
               const char **startPtr,
               const char *end,
               const char **nextPtr)
d2196 1
a2196 1
  *startPtr = NULL;
d2204 1
a2204 1
        endCdataSectionHandler(handlerArg);
d2208 1
a2208 1
        characterDataHandler(handlerArg, dataBuf, 0);
d2211 1
a2211 1
        reportDefault(parser, enc, s, next);
d2216 2
a2217 2
        XML_Char c = 0xA;
        characterDataHandler(handlerArg, &c, 1);
d2220 1
a2220 1
        reportDefault(parser, enc, s, next);
d2224 15
a2238 16
        if (MUST_CONVERT(enc, s)) {
          for (;;) {
            ICHAR *dataPtr = (ICHAR *)dataBuf;
            XmlConvert(enc, &s, next, &dataPtr, (ICHAR *)dataBufEnd);
            *eventEndPP = next;
            characterDataHandler(handlerArg, dataBuf,
                                 dataPtr - (ICHAR *)dataBuf);
            if (s == next)
              break;
            *eventPP = s;
          }
        }
        else
          characterDataHandler(handlerArg,
                               (XML_Char *)s,
                               (XML_Char *)next - (XML_Char *)s);
d2241 1
a2241 1
        reportDefault(parser, enc, s, next);
d2248 2
a2249 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d2255 2
a2256 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d2271 7
a2277 7
   the whole file is parsed with one call.
*/
static enum XML_Error
ignoreSectionProcessor(XML_Parser parser,
                       const char *start,
                       const char *end,
                       const char **endPtr)
d2279 1
a2279 2
  enum XML_Error result = doIgnoreSection(parser, encoding, &start,
                                          end, endPtr);
d2287 9
a2295 9
/* startPtr gets set to non-null is the section is closed, and to null
   if the section is not yet closed.
*/
static enum XML_Error
doIgnoreSection(XML_Parser parser,
                const ENCODING *enc,
                const char **startPtr,
                const char *end,
                const char **nextPtr)
d2312 1
a2312 1
  *startPtr = NULL;
d2353 1
a2353 1
    s = NULL;
d2358 3
a2360 3
          || (protocolEncodingName[i] & ~0x7f) != 0) {
        encodingBuf[0] = '\0';
        break;
d2377 1
a2377 1
               const char *s, const char *next)
d2379 4
a2382 4
  const char *encodingName = NULL;
  const XML_Char *storedEncName = NULL;
  const ENCODING *newEncoding = NULL;
  const char *version = NULL;
d2384 1
a2384 1
  const XML_Char *storedversion = NULL;
d2388 10
a2397 10
        : XmlParseXmlDecl)(isGeneralTextEntity,
                           encoding,
                           s,
                           next,
                           &eventPtr,
                           &version,
                           &versionend,
                           &encodingName,
                           &newEncoding,
                           &standalone))
d2407 1
a2407 1
    if (encodingName != NULL) {
d2409 6
a2414 6
                                      encoding,
                                      encodingName,
                                      encodingName
                                      + XmlNameLength(encoding, encodingName));
      if (!storedEncName)
              return XML_ERROR_NO_MEMORY;
d2419 5
a2423 5
                                      encoding,
                                      version,
                                      versionend - encoding->minBytesPerChar);
      if (!storedversion)
        return XML_ERROR_NO_MEMORY;
d2429 1
a2429 1
  if (protocolEncodingName == NULL) {
d2432 2
a2433 2
        eventPtr = encodingName;
        return XML_ERROR_INCORRECT_ENCODING;
d2439 8
a2446 6
      if (!storedEncName) {
        storedEncName = poolStoreString(
          &temp2Pool, encoding, encodingName,
          encodingName + XmlNameLength(encoding, encodingName));
        if (!storedEncName)
          return XML_ERROR_NO_MEMORY;
d2451 1
a2451 1
        eventPtr = encodingName;
d2470 4
a2473 5
    info.convert = NULL;
    info.data = NULL;
    info.release = NULL;
    if (unknownEncodingHandler(unknownEncodingHandlerData, encodingName,
                               &info)) {
d2477 3
a2479 3
        if (info.release)
          info.release(info.data);
        return XML_ERROR_NO_MEMORY;
d2482 5
a2486 5
             ? XmlInitUnknownEncodingNS
             : XmlInitUnknownEncoding)(unknownEncodingMem,
                                       info.map,
                                       info.convert,
                                       info.data);
d2488 4
a2491 4
        unknownEncodingData = info.data;
        unknownEncodingRelease = info.release;
        encoding = enc;
        return XML_ERROR_NONE;
d2494 1
a2494 1
    if (info.release != NULL)
d2502 3
a2504 3
                    const char *s,
                    const char *end,
                    const char **nextPtr)
a2512 159
#ifdef XML_DTD

static enum XML_Error
externalParEntInitProcessor(XML_Parser parser,
                    const char *s,
                    const char *end,
                    const char **nextPtr)
{
  enum XML_Error result = initializeEncoding(parser);
  if (result != XML_ERROR_NONE)
    return result;

  /* we know now that XML_Parse(Buffer) has been called,
     so we assume we actually have an external parameter entity */
  dtd.hasParamEntities = 1;
  dtd.paramEntityRead = 1;

  if (prologState.inEntityValue) {
    processor = entityValueInitProcessor;
    return entityValueInitProcessor(parser, s, end, nextPtr);
  }
  else {
    processor = externalParEntProcessor;
    return externalParEntProcessor(parser, s, end, nextPtr);
  }
}

static enum XML_Error
entityValueInitProcessor(XML_Parser parser,
                const char *s,
                const char *end,
                const char **nextPtr)
{
  const char *start = s;
  const char *next = s;
  int tok;

  for (;;) {
    tok = XmlPrologTok(encoding, start, end, &next);
    if (tok <= 0) {
      if (nextPtr != 0 && tok != XML_TOK_INVALID) {
              *nextPtr = s;
              return XML_ERROR_NONE;
      }
      switch (tok) {
      case XML_TOK_INVALID:
              return XML_ERROR_INVALID_TOKEN;
      case XML_TOK_PARTIAL:
              return XML_ERROR_UNCLOSED_TOKEN;
      case XML_TOK_PARTIAL_CHAR:
              return XML_ERROR_PARTIAL_CHAR;
      case XML_TOK_NONE:   /* start == end */
      default:
        break;
      }
      return storeEntityValue(parser, encoding, s, end);
    }
    else if (tok == XML_TOK_XML_DECL) {
      enum XML_Error result = processXmlDecl(parser, 0, start, next);
            if (result != XML_ERROR_NONE)
              return result;
      if (nextPtr) *nextPtr = next;
      /* stop scanning for text declaration - we found one */
      processor = entityValueProcessor;
      return entityValueProcessor(parser, next, end, nextPtr);
    }
    /* If we are at the end of the buffer, this would cause XmlPrologTok to
       return XML_TOK_NONE on the next call, which would then cause the
       function to exit with *nextPtr set to s - that is what we want for other
       tokens, but not for the BOM - we would rather like to skip it;
       then, when this routine is entered the next time, XmlPrologTok will
       return XML_TOK_INVALID, since the BOM is still in the buffer
    */
    else if (tok == XML_TOK_BOM && next == end && nextPtr) {
      *nextPtr = next;
      return XML_ERROR_NONE;
    }
    start = next;
  }
}

static enum XML_Error
externalParEntProcessor(XML_Parser parser,
                const char *s,
                const char *end,
                const char **nextPtr)
{
  const char *start = s;
  const char *next = s;
  int tok;

  tok = XmlPrologTok(encoding, start, end, &next);
  if (tok <= 0) {
    if (nextPtr != 0 && tok != XML_TOK_INVALID) {
      *nextPtr = s;
      return XML_ERROR_NONE;
    }
    switch (tok) {
    case XML_TOK_INVALID:
      return XML_ERROR_INVALID_TOKEN;
    case XML_TOK_PARTIAL:
      return XML_ERROR_UNCLOSED_TOKEN;
    case XML_TOK_PARTIAL_CHAR:
      return XML_ERROR_PARTIAL_CHAR;
    case XML_TOK_NONE:   /* start == end */
    default:
      break;
    }
  }
  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.
     However, when parsing an external subset, doProlog will not accept a BOM
     as valid, and report a syntax error, so we have to skip the BOM
  */
  else if (tok == XML_TOK_BOM) {
    s = next;
    tok = XmlPrologTok(encoding, s, end, &next);
  }

  processor = prologProcessor;
  return doProlog(parser, encoding, s, end, tok, next, nextPtr);
}

static enum XML_Error
entityValueProcessor(XML_Parser parser,
                const char *s,
                const char *end,
                const char **nextPtr)
{
  const char *start = s;
  const char *next = s;
  const ENCODING *enc = encoding;
  int tok;

  for (;;) {
    tok = XmlPrologTok(enc, start, end, &next);
    if (tok <= 0) {
      if (nextPtr != 0 && tok != XML_TOK_INVALID) {
        *nextPtr = s;
        return XML_ERROR_NONE;
      }
      switch (tok) {
      case XML_TOK_INVALID:
              return XML_ERROR_INVALID_TOKEN;
      case XML_TOK_PARTIAL:
              return XML_ERROR_UNCLOSED_TOKEN;
      case XML_TOK_PARTIAL_CHAR:
              return XML_ERROR_PARTIAL_CHAR;
      case XML_TOK_NONE:   /* start == end */
      default:
        break;
      }
      return storeEntityValue(parser, enc, s, end);
    }
    start = next;
  }
}

#endif /* XML_DTD */

d2515 3
a2517 3
                const char *s,
                const char *end,
                const char **nextPtr)
d2519 1
a2519 1
  const char *next = s;
d2526 6
a2531 6
         const ENCODING *enc,
         const char *s,
         const char *end,
         int tok,
         const char *next,
         const char **nextPtr)
a2535 11
  static const XML_Char atypeCDATA[] = { 'C', 'D', 'A', 'T', 'A', '\0' };
  static const XML_Char atypeID[] = { 'I', 'D', '\0' };
  static const XML_Char atypeIDREF[] = { 'I', 'D', 'R', 'E', 'F', '\0' };
  static const XML_Char atypeIDREFS[] = { 'I', 'D', 'R', 'E', 'F', 'S', '\0' };
  static const XML_Char atypeENTITY[] = { 'E', 'N', 'T', 'I', 'T', 'Y', '\0' };
  static const XML_Char atypeENTITIES[] = { 'E', 'N', 'T', 'I', 'T', 'I', 'E', 'S', '\0' };
  static const XML_Char atypeNMTOKEN[] = { 'N', 'M', 'T', 'O', 'K', 'E', 'N', '\0' };
  static const XML_Char atypeNMTOKENS[] = { 'N', 'M', 'T', 'O', 'K', 'E', 'N', 'S', '\0' };
  static const XML_Char notationPrefix[] = { 'N', 'O', 'T', 'A', 'T', 'I', 'O', 'N', '(', '\0' };
  static const XML_Char enumValueSep[] = { '|', '\0' };
  static const XML_Char enumValueStart[] = { '(', '\0' };
d2555 2
a2556 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d2560 2
a2561 2
        *eventPP = next;
        return XML_ERROR_INVALID_TOKEN;
d2563 1
a2563 1
        return XML_ERROR_UNCLOSED_TOKEN;
d2565 1
a2565 1
        return XML_ERROR_PARTIAL_CHAR;
d2568 9
a2576 8
        if (enc != encoding)
          return XML_ERROR_NONE;
        if (isParamEntity) {
          if (XmlTokenRole(&prologState, XML_TOK_NONE, end, end, enc)
              == XML_ROLE_ERROR)
            return XML_ERROR_SYNTAX;
          return XML_ERROR_NONE;
        }
d2578 1
a2578 1
        return XML_ERROR_NO_ELEMENTS;
d2580 3
a2582 3
        tok = -tok;
        next = end;
        break;
d2589 4
a2592 4
        enum XML_Error result = processXmlDecl(parser, 0, s, next);
        if (result != XML_ERROR_NONE)
          return result;
        enc = encoding;
d2597 6
a2602 5
        doctypeName = poolStoreString(&tempPool, enc, s, next);
        if (!doctypeName)
          return XML_ERROR_NO_MEMORY;
        poolFinish(&tempPool);
        doctypePubid = NULL;
a2603 1
      doctypeSysid = NULL; /* always initialize to NULL */
d2607 4
a2610 4
        startDoctypeDeclHandler(handlerArg, doctypeName, doctypeSysid,
                                doctypePubid, 1);
        doctypeName = NULL;
        poolClear(&tempPool);
d2616 4
a2619 4
        enum XML_Error result = processXmlDecl(parser, 1, s, next);
        if (result != XML_ERROR_NONE)
          return result;
        enc = encoding;
d2625 4
a2628 6
        doctypePubid = poolStoreString(&tempPool, enc,
                                       s + enc->minBytesPerChar,
                                       next - enc->minBytesPerChar);
        if (!doctypePubid)
          return XML_ERROR_NO_MEMORY;
        poolFinish(&tempPool);
d2632 2
a2633 2
                                    externalSubsetName,
                                    sizeof(ENTITY));
d2635 1
a2635 1
        return XML_ERROR_NO_MEMORY;
d2640 1
a2640 1
        return XML_ERROR_SYNTAX;
d2642 9
a2650 9
        XML_Char *tem = poolStoreString(&dtd.pool,
                                        enc,
                                        s + enc->minBytesPerChar,
                                        next - enc->minBytesPerChar);
        if (!tem)
          return XML_ERROR_NO_MEMORY;
        normalizePublicId(tem);
        declEntity->publicId = tem;
        poolFinish(&dtd.pool);
d2655 6
a2660 9
        startDoctypeDeclHandler(handlerArg, doctypeName,
                                doctypeSysid, doctypePubid, 0);
        poolClear(&tempPool);
      }
      /* doctypeSysid will be non-NULL in the case of
         XML_ROLE_DOCTYPE_SYSTEM_ID, even if startDoctypeDeclHandler
         was not set, indicating an external subset
      */
      if ((dtd.keepProcessing || dtd.standalone) && doctypeSysid) {
d2662 11
a2672 16
        if (paramEntityParsing && externalEntityRefHandler) {
          ENTITY *entity = (ENTITY *)lookup(&dtd.paramEntities,
                                            externalSubsetName,
                                            0);
          dtd.paramEntityRead = 0;
          if (!externalEntityRefHandler(externalEntityRefHandlerArg,
                                        0,
                                        entity->base,
                                        entity->systemId,
                                        entity->publicId))
            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
          if (!dtd.paramEntityRead)
            dtd.keepProcessing = 0;
        }
        else
          dtd.keepProcessing = 0;
d2674 5
a2678 5
        if (dtd.paramEntityRead
            && !dtd.standalone
            && notStandaloneHandler
            && !notStandaloneHandler(handlerArg))
          return XML_ERROR_NOT_STANDALONE;
d2681 1
a2681 1
        endDoctypeDeclHandler(handlerArg);
d2689 1
a2689 1
        return XML_ERROR_NO_MEMORY;
d2694 1
a2694 1
        return XML_ERROR_NO_MEMORY;
d2696 1
a2696 1
      declAttributeType = NULL;
d2701 1
a2701 1
      declAttributeType = atypeCDATA;
d2705 1
a2705 1
      declAttributeType = atypeID;
d2708 1
a2708 1
      declAttributeType = atypeIDREF;
d2711 1
a2711 1
      declAttributeType = atypeIDREFS;
d2714 1
a2714 1
      declAttributeType = atypeENTITY;
d2717 1
a2717 1
      declAttributeType = atypeENTITIES;
d2720 1
a2720 1
      declAttributeType = atypeNMTOKEN;
d2723 1
a2723 1
      declAttributeType = atypeNMTOKENS;
d2725 1
d2728 16
a2743 15
      if (attlistDeclHandler) {
        const XML_Char *prefix;
        if (declAttributeType) {
          prefix = enumValueSep;
        }
        else {
          prefix = (role == XML_ROLE_ATTRIBUTE_NOTATION_VALUE
                    ? notationPrefix
                    : enumValueStart);
        }
        if (!poolAppendString(&tempPool, prefix))
          return XML_ERROR_NO_MEMORY;
        if (!poolAppend(&tempPool, enc, s, next))
          return XML_ERROR_NO_MEMORY;
        declAttributeType = tempPool.start;
d2748 20
a2767 22
      if (dtd.keepProcessing || dtd.standalone) {
        if (!defineAttribute(declElementType, declAttributeId,
                              declAttributeIsCdata, declAttributeIsId, 0,
                              parser))
          return XML_ERROR_NO_MEMORY;
        if (attlistDeclHandler && declAttributeType) {
          if (*declAttributeType == XML_T('(')
              || (*declAttributeType == XML_T('N')
                  && declAttributeType[1] == XML_T('O'))) {
            /* Enumerated or Notation type */
            if (!poolAppendChar(&tempPool, XML_T(')'))
                || !poolAppendChar(&tempPool, XML_T('\0')))
              return XML_ERROR_NO_MEMORY;
            declAttributeType = tempPool.start;
            poolFinish(&tempPool);
          }
          *eventEndPP = s;
          attlistDeclHandler(handlerArg, declElementType->name,
                             declAttributeId->name, declAttributeType,
                             0, role == XML_ROLE_REQUIRED_ATTRIBUTE_VALUE);
          poolClear(&tempPool);
        }
d2772 33
a2804 33
      if (dtd.keepProcessing || dtd.standalone) {
        const XML_Char *attVal;
        enum XML_Error result
          = storeAttributeValue(parser, enc, declAttributeIsCdata,
                                s + enc->minBytesPerChar,
                                next - enc->minBytesPerChar,
                                &dtd.pool);
        if (result)
          return result;
        attVal = poolStart(&dtd.pool);
        poolFinish(&dtd.pool);
        /* ID attributes aren't allowed to have a default */
        if (!defineAttribute(declElementType, declAttributeId,
                       declAttributeIsCdata, 0, attVal, parser))
          return XML_ERROR_NO_MEMORY;
        if (attlistDeclHandler && declAttributeType) {
          if (*declAttributeType == XML_T('(')
              || (*declAttributeType == XML_T('N')
                  && declAttributeType[1] == XML_T('O'))) {
            /* Enumerated or Notation type */
            if (!poolAppendChar(&tempPool, XML_T(')'))
                || !poolAppendChar(&tempPool, XML_T('\0')))
              return XML_ERROR_NO_MEMORY;
            declAttributeType = tempPool.start;
            poolFinish(&tempPool);
          }
          *eventEndPP = s;
          attlistDeclHandler(handlerArg, declElementType->name,
                             declAttributeId->name, declAttributeType,
                             attVal,
                             role == XML_ROLE_FIXED_ATTRIBUTE_VALUE);
          poolClear(&tempPool);
        }
a2805 1
      break;
d2808 21
a2828 21
        enum XML_Error result = storeEntityValue(parser, enc,
                                                 s + enc->minBytesPerChar,
                                                 next - enc->minBytesPerChar);
        if (declEntity) {
          declEntity->textPtr = poolStart(&dtd.entityValuePool);
          declEntity->textLen = poolLength(&dtd.entityValuePool);
          poolFinish(&dtd.entityValuePool);
          if (entityDeclHandler) {
            *eventEndPP = s;
            entityDeclHandler(handlerArg,
                              declEntity->name,
                              declEntity->is_param,
                              declEntity->textPtr,
                              declEntity->textLen,
                              curBase, 0, 0, 0);
          }
        }
        else
          poolDiscard(&dtd.entityValuePool);
        if (result != XML_ERROR_NONE)
          return result;
d2833 4
a2836 6
        doctypeSysid = poolStoreString(&tempPool, enc,
                                       s + enc->minBytesPerChar,
                                       next - enc->minBytesPerChar);
        if (doctypeSysid == NULL)
          return XML_ERROR_NO_MEMORY;
        poolFinish(&tempPool);
a2837 6
      else
#ifdef XML_DTD
        /* use externalSubsetName to make doctypeSysid non-NULL
           for the case where no startDoctypeDeclHandler is set */
        doctypeSysid = externalSubsetName;
#endif /* XML_DTD */
d2840 1
a2840 1
          && !paramEntityParsing
d2842 4
a2845 3
          && notStandaloneHandler
          && !notStandaloneHandler(handlerArg))
        return XML_ERROR_NOT_STANDALONE;
d2850 6
a2855 6
        declEntity = (ENTITY *)lookup(&dtd.paramEntities,
                                      externalSubsetName,
                                      sizeof(ENTITY));
        if (!declEntity)
          return XML_ERROR_NO_MEMORY;
        declEntity->publicId = NULL;
d2861 7
a2867 7
        declEntity->systemId = poolStoreString(&dtd.pool, enc,
                                               s + enc->minBytesPerChar,
                                               next - enc->minBytesPerChar);
        if (!declEntity->systemId)
          return XML_ERROR_NO_MEMORY;
        declEntity->base = curBase;
        poolFinish(&dtd.pool);
d2872 8
a2879 9
        *eventEndPP = s;
        entityDeclHandler(handlerArg,
                          declEntity->name,
                          declEntity->is_param,
                          0,0,
                          declEntity->base,
                          declEntity->systemId,
                          declEntity->publicId,
                          0);
d2884 23
a2906 23
        declEntity->notation = poolStoreString(&dtd.pool, enc, s, next);
        if (!declEntity->notation)
          return XML_ERROR_NO_MEMORY;
        poolFinish(&dtd.pool);
        if (unparsedEntityDeclHandler) {
          *eventEndPP = s;
          unparsedEntityDeclHandler(handlerArg,
                                    declEntity->name,
                                    declEntity->base,
                                    declEntity->systemId,
                                    declEntity->publicId,
                                    declEntity->notation);
        }
        else if (entityDeclHandler) {
          *eventEndPP = s;
          entityDeclHandler(handlerArg,
                            declEntity->name,
                            0,0,0,
                            declEntity->base,
                            declEntity->systemId,
                            declEntity->publicId,
                            declEntity->notation);
        }
d2911 26
a2936 30
        if (XmlPredefinedEntityName(enc, s, next)) {
          declEntity = NULL;
          break;
        }
        if (dtd.keepProcessing || dtd.standalone) {
          const XML_Char *name = poolStoreString(&dtd.pool, enc, s, next);
          if (!name)
            return XML_ERROR_NO_MEMORY;
          declEntity = (ENTITY *)lookup(&dtd.generalEntities, name,
                                        sizeof(ENTITY));
          if (!declEntity)
            return XML_ERROR_NO_MEMORY;
          if (declEntity->name != name) {
            poolDiscard(&dtd.pool);
            declEntity = NULL;
          }
          else {
            poolFinish(&dtd.pool);
            declEntity->publicId = NULL;
            declEntity->is_param = 0;
            /* if we have a parent parser or are reading an internal parameter
               entity, then the entity declaration is not considered "internal"
            */
            declEntity->is_internal = !(parentParser || openInternalEntities);
          }
        }
        else {
          poolDiscard(&dtd.pool);
          declEntity = NULL;
        }
d2941 17
a2957 25
      if (dtd.keepProcessing || dtd.standalone) {
        const XML_Char *name = poolStoreString(&dtd.pool, enc, s, next);
        if (!name)
          return XML_ERROR_NO_MEMORY;
        declEntity = (ENTITY *)lookup(&dtd.paramEntities,
                                           name, sizeof(ENTITY));
        if (!declEntity)
          return XML_ERROR_NO_MEMORY;
        if (declEntity->name != name) {
          poolDiscard(&dtd.pool);
          declEntity = 0;
        }
        else {
          poolFinish(&dtd.pool);
          declEntity->publicId = 0;
          declEntity->is_param = 1;
          /* if we have a parent parser or are reading an internal parameter
             entity, then the entity declaration is not considered "internal"
          */
          declEntity->is_internal = !(parentParser || openInternalEntities);
        }
      }
      else {
        poolDiscard(&dtd.pool);
        declEntity = NULL;
d2960 2
a2961 2
      declEntity = NULL;
#endif /* XML_DTD */
d2964 2
a2965 2
      declNotationPublicId = NULL;
      declNotationName = NULL;
d2967 4
a2970 4
        declNotationName = poolStoreString(&tempPool, enc, s, next);
        if (!declNotationName)
          return XML_ERROR_NO_MEMORY;
        poolFinish(&tempPool);
d2975 1
a2975 1
        return XML_ERROR_SYNTAX;
d2977 9
a2985 9
        XML_Char *tem = poolStoreString(&tempPool,
                                        enc,
                                        s + enc->minBytesPerChar,
                                        next - enc->minBytesPerChar);
        if (!tem)
          return XML_ERROR_NO_MEMORY;
        normalizePublicId(tem);
        declNotationPublicId = tem;
        poolFinish(&tempPool);
d2990 12
a3001 12
        const XML_Char *systemId
          = poolStoreString(&tempPool, enc,
                            s + enc->minBytesPerChar,
                            next - enc->minBytesPerChar);
        if (!systemId)
          return XML_ERROR_NO_MEMORY;
        *eventEndPP = s;
        notationDeclHandler(handlerArg,
                            declNotationName,
                            curBase,
                            systemId,
                            declNotationPublicId);
d3007 6
a3012 6
        *eventEndPP = s;
        notationDeclHandler(handlerArg,
                            declNotationName,
                            curBase,
                            0,
                            declNotationPublicId);
d3019 1
a3019 1
        return XML_ERROR_PARAM_ENTITY_REF;
d3021 1
a3021 1
        return XML_ERROR_MISPLACED_XML_PI;
d3023 1
a3023 1
        return XML_ERROR_SYNTAX;
d3028 8
a3035 8
        enum XML_Error result;
        if (defaultHandler)
          reportDefault(parser, enc, s, next);
        result = doIgnoreSection(parser, enc, &next, end, nextPtr);
        if (!next) {
          processor = ignoreSectionProcessor;
          return result;
        }
d3041 9
a3049 17
        if (groupSize) {
          char *temp = REALLOC(groupConnector, groupSize *= 2);
          if (temp == NULL)
            return XML_ERROR_NO_MEMORY;
          groupConnector = temp;
          if (dtd.scaffIndex) {
            int *temp = REALLOC(dtd.scaffIndex, groupSize * sizeof(int));
            if (temp == NULL)
              return XML_ERROR_NO_MEMORY;
            dtd.scaffIndex = temp;
          }
        }
        else {
          groupConnector = MALLOC(groupSize = 32);
          if (!groupConnector)
            return XML_ERROR_NO_MEMORY;
        }
d3053 6
a3058 6
        int myindex = nextScaffoldPart(parser);
        if (myindex < 0)
          return XML_ERROR_NO_MEMORY;
        dtd.scaffIndex[dtd.scaffLevel] = myindex;
        dtd.scaffLevel++;
        dtd.scaffold[myindex].type = XML_CTYPE_SEQ;
d3063 1
a3063 1
        return XML_ERROR_SYNTAX;
d3068 1
a3068 1
        return XML_ERROR_SYNTAX;
d3070 4
a3073 6
          && !groupConnector[prologState.level]
          && (dtd.scaffold[dtd.scaffIndex[dtd.scaffLevel - 1]].type
              != XML_CTYPE_MIXED)
          ) {
        dtd.scaffold[dtd.scaffIndex[dtd.scaffLevel - 1]].type
            = XML_CTYPE_CHOICE;
d3080 41
a3120 61
      /* PE references in internal subset are
         not allowed within declarations      */
      if (prologState.documentEntity &&
          role == XML_ROLE_INNER_PARAM_ENTITY_REF)
        return XML_ERROR_PARAM_ENTITY_REF;
      if (!paramEntityParsing)
        dtd.keepProcessing = 0;
      else {
        const XML_Char *name;
        ENTITY *entity;
        name = poolStoreString(&dtd.pool, enc,
                                s + enc->minBytesPerChar,
                                next - enc->minBytesPerChar);
        if (!name)
          return XML_ERROR_NO_MEMORY;
        entity = (ENTITY *)lookup(&dtd.paramEntities, name, 0);
        poolDiscard(&dtd.pool);
        /* first, determine if a check for an existing declaration is needed;
           if yes, check that the entity exists, and that it is internal,
           otherwise call the skipped entity handler
        */
        if (prologState.documentEntity &&
            (dtd.standalone ? !openInternalEntities : !dtd.hasParamEntities)) {
          if (!entity)
            return XML_ERROR_UNDEFINED_ENTITY;
          else if (!entity->is_internal)
            return XML_ERROR_ENTITY_DECLARED_IN_PE;
        }
        else if (!entity) {
          dtd.keepProcessing = 0;
          /* cannot report skipped entities in declarations */
          if ((role == XML_ROLE_PARAM_ENTITY_REF) && skippedEntityHandler)
            skippedEntityHandler(handlerArg, name, 1);
          break;
        }
        if (entity->open)
          return XML_ERROR_RECURSIVE_ENTITY_REF;
        if (entity->textPtr) {
          enum XML_Error result;
          result = processInternalParamEntity(parser, entity);
          if (result != XML_ERROR_NONE)
            return result;
          break;
        }
        if (externalEntityRefHandler) {
          dtd.paramEntityRead = 0;
          entity->open = 1;
          if (!externalEntityRefHandler(externalEntityRefHandlerArg,
                                        0,
                                        entity->base,
                                        entity->systemId,
                                        entity->publicId)) {
            entity->open = 0;
            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
          }
          entity->open = 0;
          if (!dtd.paramEntityRead) {
            dtd.keepProcessing = 0;
            break;
          }
        }
d3124 6
a3129 9
          && notStandaloneHandler
          && !notStandaloneHandler(handlerArg))
        return XML_ERROR_NOT_STANDALONE;
      if (
#ifdef XML_DTD
          !paramEntityParsing &&
#endif /* XML_DTD */
          defaultHandler)
        reportDefault(parser, enc, s, next);
d3136 6
a3141 6
              declElementType = getElementType(parser, enc, s, next);
        if (!declElementType)
                return XML_ERROR_NO_MEMORY;
              dtd.scaffLevel = 0;
              dtd.scaffCount = 0;
              dtd.in_eldecl = 1;
d3148 15
a3162 15
        if (elementDeclHandler) {
          XML_Content * content = (XML_Content *) MALLOC(sizeof(XML_Content));
          if (!content)
            return XML_ERROR_NO_MEMORY;
          content->quant = XML_CQUANT_NONE;
          content->name = NULL;
          content->numchildren = 0;
          content->children = NULL;
          content->type = ((role == XML_ROLE_CONTENT_ANY) ?
                           XML_CTYPE_ANY :
                           XML_CTYPE_EMPTY);
          *eventEndPP = s;
          elementDeclHandler(handlerArg, declElementType->name, content);
        }
        dtd.in_eldecl = 0;
d3165 1
a3165 1

d3168 1
a3168 2
        dtd.scaffold[dtd.scaffIndex[dtd.scaffLevel - 1]].type
            = XML_CTYPE_MIXED;
d3184 15
a3198 21
      if (dtd.in_eldecl) {
        ELEMENT_TYPE *el;
        const XML_Char *name;
        int nameLen;
        const char *nxt = (quant == XML_CQUANT_NONE
                           ? next
                           : next - enc->minBytesPerChar);
        int myindex = nextScaffoldPart(parser);
        if (myindex < 0)
          return XML_ERROR_NO_MEMORY;
        dtd.scaffold[myindex].type = XML_CTYPE_NAME;
        dtd.scaffold[myindex].quant = quant;
        el = getElementType(parser, enc, s, nxt);
        if (!el)
          return XML_ERROR_NO_MEMORY;
        name = el->name;
        dtd.scaffold[myindex].name = name;
        nameLen = 0;
        for (; name[nameLen++]; );
        dtd.contentStringLen +=  nameLen;
      }
d3214 13
a3226 13
        dtd.scaffLevel--;
        dtd.scaffold[dtd.scaffIndex[dtd.scaffLevel]].quant = quant;
        if (dtd.scaffLevel == 0) {
          if (elementDeclHandler) {
            XML_Content *model = build_model(parser);
            if (!model)
              return XML_ERROR_NO_MEMORY;
            *eventEndPP = s;
            elementDeclHandler(handlerArg, declElementType->name, model);
          }
          dtd.in_eldecl = 0;
          dtd.contentStringLen = 0;
        }
d3234 3
a3236 3
        if (!reportProcessingInstruction(parser, enc, s, next))
          return XML_ERROR_NO_MEMORY;
        break;
d3238 3
a3240 3
        if (!reportComment(parser, enc, s, next))
          return XML_ERROR_NO_MEMORY;
        break;
d3243 1
a3243 2
    } /* end of big switch */

d3254 1
a3254 1
        break;
d3257 1
a3257 1
        if (role != XML_ROLE_IGNORE_SECT)
d3259 1
a3259 1
          reportDefault(parser, enc, s, next);
a3261 1

d3268 5
a3272 5
static enum XML_Error
epilogProcessor(XML_Parser parser,
                const char *s,
                const char *end,
                const char **nextPtr)
d3277 1
a3277 1
    const char *next = NULL;
d3283 2
a3284 2
        eventEndPtr = end;
        reportDefault(parser, encoding, s, end);
d3289 1
a3289 1
        *nextPtr = end;
d3293 1
a3293 1
        reportDefault(parser, encoding, s, next);
d3297 1
a3297 1
        return XML_ERROR_NO_MEMORY;
d3301 1
a3301 1
        return XML_ERROR_NO_MEMORY;
d3308 2
a3309 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d3314 2
a3315 2
        *nextPtr = s;
        return XML_ERROR_NONE;
d3338 2
a3339 2
  openEntity.internalEventPtr = NULL;
  openEntity.internalEventEndPtr = NULL;
a3341 1
  dtd.hasParamEntities = 1;
d3351 5
a3355 5
static enum XML_Error
errorProcessor(XML_Parser parser,
               const char *s,
               const char *end,
               const char **nextPtr)
d3362 2
a3363 2
                    const char *ptr, const char *end,
                    STRING_POOL *pool)
d3365 1
a3365 2
  enum XML_Error result = appendAttributeValue(parser, enc, isCdata, ptr,
                                               end, pool);
d3377 2
a3378 2
                     const char *ptr, const char *end,
                     STRING_POOL *pool)
d3388 1
a3388 1
        eventPtr = next;
d3392 1
a3392 1
        eventPtr = ptr;
d3396 22
a3417 22
        XML_Char buf[XML_ENCODE_MAX];
        int i;
        int n = XmlCharRefNumber(enc, ptr);
        if (n < 0) {
          if (enc == encoding)
            eventPtr = ptr;
          return XML_ERROR_BAD_CHAR_REF;
        }
        if (!isCdata
            && n == 0x20 /* space */
            && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))
          break;
        n = XmlEncode(n, (ICHAR *)buf);
        if (!n) {
          if (enc == encoding)
            eventPtr = ptr;
          return XML_ERROR_BAD_CHAR_REF;
        }
        for (i = 0; i < n; i++) {
          if (!poolAppendChar(pool, buf[i]))
            return XML_ERROR_NO_MEMORY;
        }
d3422 2
a3423 1
        return XML_ERROR_NO_MEMORY;
d3431 1
a3431 1
        break;
d3433 1
a3433 1
        return XML_ERROR_NO_MEMORY;
d3437 48
a3484 72
        const XML_Char *name;
        ENTITY *entity;
        char checkEntityDecl;
        XML_Char ch = (XML_Char) XmlPredefinedEntityName(enc,
                                              ptr + enc->minBytesPerChar,
                                              next - enc->minBytesPerChar);
        if (ch) {
          if (!poolAppendChar(pool, ch))
                return XML_ERROR_NO_MEMORY;
          break;
        }
        name = poolStoreString(&temp2Pool, enc,
                               ptr + enc->minBytesPerChar,
                               next - enc->minBytesPerChar);
        if (!name)
          return XML_ERROR_NO_MEMORY;
        entity = (ENTITY *)lookup(&dtd.generalEntities, name, 0);
        poolDiscard(&temp2Pool);
        /* first, determine if a check for an existing declaration is needed;
           if yes, check that the entity exists, and that it is internal,
           otherwise call the default handler (if called from content)
        */
        if (pool == &dtd.pool)  /* are we called from prolog? */
          checkEntityDecl =
#ifdef XML_DTD
              prologState.documentEntity &&
#endif /* XML_DTD */
              (dtd.standalone ? !openInternalEntities : !dtd.hasParamEntities);
        else /* if (pool == &tempPool): we are called from content */
          checkEntityDecl = !dtd.hasParamEntities || dtd.standalone;
        if (checkEntityDecl) {
          if (!entity)
            return XML_ERROR_UNDEFINED_ENTITY;
          else if (!entity->is_internal)
            return XML_ERROR_ENTITY_DECLARED_IN_PE;
        }
        else if (!entity) {
          /* cannot report skipped entity here - see comments on
             skippedEntityHandler
          if (skippedEntityHandler)
            skippedEntityHandler(handlerArg, name, 0);
          */
          if ((pool == &tempPool) && defaultHandler)
            reportDefault(parser, enc, ptr, next);
          break;
        }
        if (entity->open) {
          if (enc == encoding)
            eventPtr = ptr;
          return XML_ERROR_RECURSIVE_ENTITY_REF;
        }
        if (entity->notation) {
          if (enc == encoding)
            eventPtr = ptr;
          return XML_ERROR_BINARY_ENTITY_REF;
        }
        if (!entity->textPtr) {
          if (enc == encoding)
            eventPtr = ptr;
              return XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF;
        }
        else {
          enum XML_Error result;
          const XML_Char *textEnd = entity->textPtr + entity->textLen;
          entity->open = 1;
          result = appendAttributeValue(parser, internalEncoding, isCdata,
                                        (char *)entity->textPtr,
                                        (char *)textEnd, pool);
          entity->open = 0;
          if (result)
            return result;
        }
d3489 1
a3489 1
        eventPtr = ptr;
d3497 5
a3501 5
static enum XML_Error
storeEntityValue(XML_Parser parser,
                 const ENCODING *enc,
                 const char *entityTextPtr,
                 const char *entityTextEnd)
d3503 1
a3503 14
  STRING_POOL *pool = &(dtd.entityValuePool);
  enum XML_Error result = XML_ERROR_NONE;
#ifdef XML_DTD
  int oldInEntityValue = prologState.inEntityValue;
  prologState.inEntityValue = 1;
#endif /* XML_DTD */
  /* never return Null for the value argument in EntityDeclHandler,
     since this would indicate an external entity; therefore we
     have to make sure that entityValuePool.start is not null */
  if (!pool->blocks) {
    if (!poolGrow(pool))
      return XML_ERROR_NO_MEMORY;
  }

d3510 35
a3544 58
      if (isParamEntity || enc != encoding) {
        const XML_Char *name;
        ENTITY *entity;
        name = poolStoreString(&tempPool, enc,
                               entityTextPtr + enc->minBytesPerChar,
                               next - enc->minBytesPerChar);
        if (!name) {
          result = XML_ERROR_NO_MEMORY;
          goto endEntityValue;
        }
        entity = (ENTITY *)lookup(&dtd.paramEntities, name, 0);
        poolDiscard(&tempPool);
        if (!entity) {
          /* not a well-formedness error - see XML 1.0: WFC Entity Declared */
          /* cannot report skipped entity here - see comments on
             skippedEntityHandler
          if (skippedEntityHandler)
            skippedEntityHandler(handlerArg, name, 0);
          */
          dtd.keepProcessing = 0;
          goto endEntityValue;
        }
        if (entity->open) {
          if (enc == encoding)
            eventPtr = entityTextPtr;
          result = XML_ERROR_RECURSIVE_ENTITY_REF;
          goto endEntityValue;
        }
        if (entity->systemId) {
          if (externalEntityRefHandler) {
            dtd.paramEntityRead = 0;
            entity->open = 1;
            if (!externalEntityRefHandler(externalEntityRefHandlerArg,
                                          0,
                                          entity->base,
                                          entity->systemId,
                                          entity->publicId)) {
              entity->open = 0;
              result = XML_ERROR_EXTERNAL_ENTITY_HANDLING;
              goto endEntityValue;
            }
            entity->open = 0;
            if (!dtd.paramEntityRead)
              dtd.keepProcessing = 0;
          }
        }
        else {
          entity->open = 1;
          result = storeEntityValue(parser,
                                    internalEncoding,
                                    (char *)entity->textPtr,
                                    (char *)(entity->textPtr
                                             + entity->textLen));
          entity->open = 0;
          if (result)
            goto endEntityValue;
        }
        break;
a3546 2
      /* in the internal subset, PE references are not legal
         within markup declarations, e.g entity values in this case */
d3548 1
a3548 2
      result = XML_ERROR_PARAM_ENTITY_REF;
      goto endEntityValue;
d3550 1
a3550 2
      result = XML_ERROR_NONE;
      goto endEntityValue;
d3553 2
a3554 4
      if (!poolAppend(pool, enc, entityTextPtr, next)) {
        result = XML_ERROR_NO_MEMORY;
        goto endEntityValue;
      }
d3560 2
a3561 4
      if (pool->end == pool->ptr && !poolGrow(pool)) {
              result = XML_ERROR_NO_MEMORY;
        goto endEntityValue;
      }
d3566 19
a3584 23
        XML_Char buf[XML_ENCODE_MAX];
        int i;
        int n = XmlCharRefNumber(enc, entityTextPtr);
        if (n < 0) {
          if (enc == encoding)
            eventPtr = entityTextPtr;
          result = XML_ERROR_BAD_CHAR_REF;
          goto endEntityValue;
        }
        n = XmlEncode(n, (ICHAR *)buf);
        if (!n) {
          if (enc == encoding)
            eventPtr = entityTextPtr;
          result = XML_ERROR_BAD_CHAR_REF;
          goto endEntityValue;
        }
        for (i = 0; i < n; i++) {
          if (pool->end == pool->ptr && !poolGrow(pool)) {
            result = XML_ERROR_NO_MEMORY;
            goto endEntityValue;
          }
          *(pool->ptr)++ = buf[i];
        }
d3589 2
a3590 3
        eventPtr = entityTextPtr;
      result = XML_ERROR_INVALID_TOKEN;
      goto endEntityValue;
d3593 2
a3594 3
        eventPtr = next;
      result = XML_ERROR_INVALID_TOKEN;
      goto endEntityValue;
d3597 2
a3598 3
        eventPtr = entityTextPtr;
      result = XML_ERROR_UNEXPECTED_STATE;
      goto endEntityValue;
d3602 1
a3602 5
endEntityValue:
#ifdef XML_DTD
  prologState.inEntityValue = oldInEntityValue;
#endif /* XML_DTD */
  return result;
d3629 1
a3629 2
reportProcessingInstruction(XML_Parser parser, const ENCODING *enc,
                            const char *start, const char *end)
d3646 2
a3647 2
                        XmlSkipS(enc, tem),
                        end - enc->minBytesPerChar*2);
d3657 1
a3657 2
reportComment(XML_Parser parser, const ENCODING *enc,
              const char *start, const char *end)
d3667 2
a3668 2
                         start + enc->minBytesPerChar * 4,
                         end - enc->minBytesPerChar * 3);
d3678 1
a3678 2
reportDefault(XML_Parser parser, const ENCODING *enc,
              const char *s, const char *end)
d3706 1
a3706 1
                int isId, const XML_Char *value, XML_Parser parser)
d3715 1
a3715 1
        return 1;
d3722 1
a3722 4
      type->defaultAtts = MALLOC(type->allocDefaultAtts
                                 * sizeof(DEFAULT_ATTRIBUTE));
      if (!type->defaultAtts)
        return 0;
d3725 3
a3727 7
      DEFAULT_ATTRIBUTE *temp;
      int count = type->allocDefaultAtts * 2;
      temp = REALLOC(type->defaultAtts, (count * sizeof(DEFAULT_ATTRIBUTE)));
      if (temp == NULL)
        return 0;
      type->allocDefaultAtts = count;
      type->defaultAtts = temp;
d3729 2
d3735 1
a3735 1
  att->isCdata = (char)isCdata;
d3742 1
a3742 2
static int
setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)
d3750 2
a3751 2
        if (!poolAppendChar(&dtd.pool, *s))
          return 0;
d3754 2
a3755 3
        return 0;
      prefix = (PREFIX *)lookup(&dtd.prefixes, poolStart(&dtd.pool),
                                sizeof(PREFIX));
d3757 1
a3757 1
        return 0;
d3759 1
a3759 1
        poolFinish(&dtd.pool);
d3761 1
a3761 1
        poolDiscard(&dtd.pool);
d3770 1
a3770 2
getAttributeId(XML_Parser parser, const ENCODING *enc,
               const char *start, const char *end)
d3775 1
a3775 1
    return NULL;
d3778 1
a3778 1
    return NULL;
d3782 1
a3782 1
    return NULL;
d3790 5
a3794 5
        && name[1] == 'm'
        && name[2] == 'l'
        && name[3] == 'n'
        && name[4] == 's'
        && (name[5] == XML_T('\0') || name[5] == XML_T(':'))) {
d3796 1
a3796 1
        id->prefix = &dtd.defaultPrefix;
d3798 1
a3798 1
        id->prefix = (PREFIX *)lookup(&dtd.prefixes, name + 6, sizeof(PREFIX));
d3804 15
a3818 16
        if (name[i] == XML_T(':')) {
          int j;
          for (j = 0; j < i; j++) {
            if (!poolAppendChar(&dtd.pool, name[j]))
              return NULL;
          }
          if (!poolAppendChar(&dtd.pool, XML_T('\0')))
            return NULL;
          id->prefix = (PREFIX *)lookup(&dtd.prefixes, poolStart(&dtd.pool),
                                        sizeof(PREFIX));
          if (id->prefix->name == poolStart(&dtd.pool))
            poolFinish(&dtd.pool);
          else
            poolDiscard(&dtd.pool);
          break;
        }
d3827 2
a3828 2
static const XML_Char *
getContext(XML_Parser parser)
d3837 1
a3837 1
      return NULL;
d3843 1
a3843 1
        return NULL;
d3858 1
a3858 1
      return NULL;
d3861 1
a3861 1
        return NULL;
d3863 1
a3863 1
      return NULL;
d3869 1
a3869 1
        return NULL;
d3883 1
a3883 1
      return NULL;
d3891 1
a3891 1
    return NULL;
d3895 2
a3896 2
static int
setContext(XML_Parser parser, const XML_Char *context)
d3904 1
a3904 1
        return 0;
d3907 1
a3907 1
        e->open = 1;
d3909 1
a3909 1
        s++;
d3913 1
a3913 1
    else if (*s == XML_T('=')) {
d3916 1
a3916 1
        prefix = &dtd.defaultPrefix;
d3918 5
a3922 6
        if (!poolAppendChar(&tempPool, XML_T('\0')))
          return 0;
        prefix = (PREFIX *)lookup(&dtd.prefixes, poolStart(&tempPool),
                                  sizeof(PREFIX));
        if (!prefix)
          return 0;
d3924 7
a3930 9
          prefix->name = poolCopyString(&dtd.pool, prefix->name);
          if (!prefix->name)
            return 0;
        }
        poolDiscard(&tempPool);
      }
      for (context = s + 1;
           *context != CONTEXT_SEP && *context != XML_T('\0');
           context++)
d3934 3
a3936 4
        return 0;
      if (!addBinding(parser, prefix, 0, poolStart(&tempPool),
                      &inheritedBindings))
        return 0;
d3939 1
a3939 1
        ++context;
d3944 1
a3944 1
        return 0;
d3951 3
a3953 2
static void
normalizePublicId(XML_Char *publicId)
d3963 1
a3963 1
        *p++ = 0x20;
d3974 1
a3974 2
static int
dtdInit(DTD *p, XML_Parser parser)
d3976 1
a3976 1
  XML_Memory_Handling_Suite *ms = &((Parser *) parser)->m_mem;
a3977 3
#ifdef XML_DTD
  poolInit(&(p->entityValuePool), ms);
#endif /* XML_DTD */
d3982 1
a3982 3
  p->keepProcessing = 1;
  p->paramEntityRead = 0;
  p->hasParamEntities = 0;
d3987 2
a3988 2
  p->defaultPrefix.name = NULL;
  p->defaultPrefix.binding = NULL;
d3993 1
a3993 1
  p->scaffold = NULL;
d4003 1
a4003 2
static void
dtdSwap(DTD *p1, DTD *p2)
d4013 1
a4013 2
static void
dtdDestroy(DTD *p, XML_Parser parser)
d4032 4
a4035 9
#ifdef XML_DTD
  poolDestroy(&(p->entityValuePool));
#endif /* XML_DTD */
  if (!parentParser) {
    if (p->scaffIndex)
      FREE(p->scaffIndex);
    if (p->scaffold)
      FREE(p->scaffold);
  }
d4039 3
a4041 4
   The new DTD has already been initialized.
*/
static int
dtdCopy(DTD *newDtd, const DTD *oldDtd, XML_Parser parser)
d4078 1
a4078 2
    newA = (ATTRIBUTE_ID *)lookup(&(newDtd->attributeIds), name,
                                  sizeof(ATTRIBUTE_ID));
d4085 1
a4085 1
        newA->prefix = &newDtd->defaultPrefix;
d4087 1
a4087 2
        newA->prefix = (PREFIX *)lookup(&(newDtd->prefixes),
                                        oldA->prefix->name, 0);
d4105 1
a4105 2
    newE = (ELEMENT_TYPE *)lookup(&(newDtd->elementTypes), name,
                                  sizeof(ELEMENT_TYPE));
d4109 3
a4111 6
      newE->defaultAtts = (DEFAULT_ATTRIBUTE *)
          MALLOC(oldE->nDefaultAtts * sizeof(DEFAULT_ATTRIBUTE));
      if (!newE->defaultAtts) {
        FREE(newE);
        return 0;
      }
d4114 1
a4114 2
      newE->idAtt = (ATTRIBUTE_ID *)
          lookup(&(newDtd->attributeIds), oldE->idAtt->name, 0);
d4117 1
a4117 2
      newE->prefix = (PREFIX *)lookup(&(newDtd->prefixes),
                                      oldE->prefix->name, 0);
d4119 1
a4119 2
      newE->defaultAtts[i].id = (ATTRIBUTE_ID *)
          lookup(&(newDtd->attributeIds), oldE->defaultAtts[i].id->name, 0);
d4122 3
a4124 4
        newE->defaultAtts[i].value
            = poolCopyString(&(newDtd->pool), oldE->defaultAtts[i].value);
        if (!newE->defaultAtts[i].value)
          return 0;
d4127 1
a4127 1
        newE->defaultAtts[i].value = NULL;
d4133 2
a4134 2
                       &(newDtd->pool),
                       &(oldDtd->generalEntities), parser))
d4139 2
a4140 2
                       &(newDtd->pool),
                       &(oldDtd->paramEntities), parser))
d4144 1
a4144 3
  newDtd->keepProcessing = oldDtd->keepProcessing;
  newDtd->paramEntityRead = oldDtd->paramEntityRead;
  newDtd->hasParamEntities = oldDtd->hasParamEntities;
d4158 4
a4161 5
static int
copyEntityTable(HASH_TABLE *newTable,
                STRING_POOL *newPool,
                const HASH_TABLE *oldTable,
                XML_Parser parser)
d4164 2
a4165 2
  const XML_Char *cachedOldBase = NULL;
  const XML_Char *cachedNewBase = NULL;
d4184 1
a4184 1
        return 0;
d4187 9
a4195 15
        if (oldE->base == cachedOldBase)
          newE->base = cachedNewBase;
        else {
          cachedOldBase = oldE->base;
          tem = poolCopyString(newPool, cachedOldBase);
          if (!tem)
            return 0;
          cachedNewBase = newE->base = tem;
        }
      }
      if (oldE->publicId) {
        tem = poolCopyString(newPool, oldE->publicId);
        if (!tem)
          return 0;
        newE->publicId = tem;
d4199 1
a4199 2
      const XML_Char *tem = poolCopyStringN(newPool, oldE->textPtr,
                                            oldE->textLen);
d4201 1
a4201 1
        return 0;
d4208 1
a4208 1
        return 0;
a4210 2
    newE->is_param = oldE->is_param;
    newE->is_internal = oldE->is_internal;
d4217 2
a4218 2
static int
keyeq(KEY s1, KEY s2)
d4226 2
a4227 2
static unsigned long
hash(KEY s)
d4235 2
a4236 2
static NAMED *
lookup(HASH_TABLE *table, KEY name, size_t createSize)
d4243 1
a4243 1
      return NULL;
d4247 1
a4247 1
      return NULL;
d4259 1
a4259 1
        return table->v[i];
d4262 1
a4262 1
      return NULL;
d4269 1
a4269 1
        return NULL;
d4272 8
a4279 8
        if (table->v[i]) {
          size_t j;
          for (j = hash(table->v[i]->name) & (newSize - 1);
               newV[j];
               j == 0 ? j = newSize - 1 : --j)
            ;
          newV[j] = table->v[i];
        }
d4285 3
a4287 3
           table->v[i];
           i == 0 ? i = table->size - 1 : --i)
        ;
d4292 1
a4292 1
    return NULL;
d4299 2
a4300 2
static void
hashTableDestroy(HASH_TABLE *table)
d4312 2
a4313 2
static void
hashTableInit(HASH_TABLE *p, XML_Memory_Handling_Suite *ms)
d4322 2
a4323 2
static void
hashTableIterInit(HASH_TABLE_ITER *iter, const HASH_TABLE *table)
d4329 2
a4330 2
static NAMED *
hashTableIterNext(HASH_TABLE_ITER *iter)
d4337 1
a4337 1
  return NULL;
d4340 3
a4342 2
static void
poolInit(STRING_POOL *pool, XML_Memory_Handling_Suite *ms)
d4352 2
a4353 2
static void
poolClear(STRING_POOL *pool)
d4372 2
a4373 2
static void
poolDestroy(STRING_POOL *pool)
d4394 3
a4396 3
static XML_Char *
poolAppend(STRING_POOL *pool, const ENCODING *enc,
           const char *ptr, const char *end)
d4399 1
a4399 1
    return NULL;
d4405 1
a4405 1
      return NULL;
d4410 1
a4410 2
static const XML_Char *
poolCopyString(STRING_POOL *pool, const XML_Char *s)
d4414 1
a4414 1
      return NULL;
d4421 1
a4421 2
static const XML_Char *
poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n)
d4424 1
a4424 1
    return NULL;
d4427 2
a4428 1
      return NULL;
d4435 2
a4436 2
static const XML_Char *
poolAppendString(STRING_POOL *pool, const XML_Char *s)
d4440 1
a4440 1
      return NULL;
d4442 1
a4442 1
  }
d4444 1
a4444 1
}
d4446 3
a4448 3
static XML_Char *
poolStoreString(STRING_POOL *pool, const ENCODING *enc,
                const char *ptr, const char *end)
d4451 1
a4451 1
    return NULL;
d4453 1
a4453 1
    return NULL;
d4458 2
a4459 2
static int
poolGrow(STRING_POOL *pool)
d4465 1
a4465 1
      pool->blocks->next = NULL;
d4476 1
a4476 2
      memcpy(pool->blocks->s, pool->start,
             (pool->end - pool->start) * sizeof(XML_Char));
d4485 1
a4485 3
    pool->blocks = pool->mem->realloc_fcn(pool->blocks,
                                          offsetof(BLOCK, s)
                                          + blockSize * sizeof(XML_Char));
d4500 1
a4500 2
    tem = pool->mem->malloc_fcn(offsetof(BLOCK, s)
                                + blockSize * sizeof(XML_Char));
d4507 1
a4507 2
      memcpy(tem->s, pool->start,
             (pool->ptr - pool->start) * sizeof(XML_Char));
d4521 1
a4521 1
  if (!dtd.scaffIndex) {
d4523 1
a4523 1
    if (!dtd.scaffIndex)
a4528 1
    CONTENT_SCAFFOLD *temp;
a4529 4
      temp = (CONTENT_SCAFFOLD *)
        REALLOC(dtd.scaffold, dtd.scaffSize * 2 * sizeof(CONTENT_SCAFFOLD));
      if (temp == NULL)
        return -1;
d4531 2
d4535 2
a4536 4
      temp = MALLOC(INIT_SCAFFOLD_ELEMENTS * sizeof(CONTENT_SCAFFOLD));
      if (temp == NULL)
        return -1;
      dtd.scaffSize = INIT_SCAFFOLD_ELEMENTS;
d4538 2
a4539 1
    dtd.scaffold = temp;
d4543 2
a4544 2
  if (dtd.scaffLevel) {
    CONTENT_SCAFFOLD *parent = &dtd.scaffold[dtd.scaffIndex[dtd.scaffLevel-1]];
d4548 1
a4548 1
    if (!parent->childcnt)
d4555 1
a4555 1
}
d4558 5
a4562 5
build_node(XML_Parser parser,
           int src_node,
           XML_Content *dest,
           XML_Content **contpos,
           XML_Char **strpos)
d4567 1
a4567 1
    const XML_Char *src;
d4572 2
a4573 2
      if (!*src)
        break;
d4577 1
a4577 1
    dest->children = NULL;
d4586 2
a4587 2
         i < dest->numchildren;
         i++, cn = dtd.scaffold[cn].nextsib) {
d4590 1
a4590 1
    dest->name = NULL;
d4592 1
a4592 1
}
d4599 3
a4601 4
  XML_Char * str;
  int allocsize = (dtd.scaffCount * sizeof(XML_Content)
                   + (dtd.contentStringLen * sizeof(XML_Char)));

d4603 2
a4604 2
  if (!ret)
    return NULL;
d4606 1
a4606 1
  str =  (XML_Char *) (&ret[dtd.scaffCount]);
d4611 1
a4611 1
}
d4615 3
a4617 3
               const ENCODING *enc,
               const char *ptr,
               const char *end)
d4622 2
a4623 2
  if (!name)
    return NULL;
d4625 2
a4626 2
  if (!ret)
    return NULL;
d4632 1
a4632 1
      return NULL;
d4635 1
a4635 1
}
@


1.1.1.3
log
@sync with OpenBSD's idea of X-Window as of now();
@
text
@a3 1
/* $XFree86: xc/extras/expat/lib/xmlparse.c,v 1.3 2003/09/29 23:39:30 alanh Exp $ */
d11 1
a11 1
#define XMLPARSEAPI(type) type __cdecl
d25 1
a25 1
#define XMLPARSEAPI(type) type __cdecl
a92 1
#include "internal.h"
d107 1
a107 1
  const XML_Memory_Handling_Suite *mem;
a141 1
  int strLen;
a145 13
/* TAG represents an open element.
   The name of the element is stored in both the document and API
   encodings.  The memory buffer 'buf' is a separately-allocated
   memory area which stores the name.  During the XML_Parse()/
   XMLParseBuffer() when the element is open, the memory for the 'raw'
   version of the name (in the document encoding) is shared with the
   document buffer.  If the element is open across calls to
   XML_Parse()/XML_ParseBuffer(), the buffer is re-allocated to
   contain the 'raw' name as well.

   A parser re-uses these structures, maintaining a list of allocated
   TAG objects in a free list.
*/
d147 2
a148 2
  struct tag *parent;           /* parent of this element */
  const char *rawName;          /* tagName in the original encoding */
d150 3
a152 3
  TAG_NAME name;                /* tagName in the API encoding */
  char *buf;                    /* buffer for name components */
  char *bufEnd;                 /* end of the buffer */
d164 3
a166 3
  XML_Bool open;
  XML_Bool is_param;
  XML_Bool is_internal; /* true if declared in internal subset outside PE */
d193 1
a193 1
  const XML_Memory_Handling_Suite *mem;
d197 1
a197 1
   an attribute has been specified. */
d201 2
a202 2
  XML_Bool maybeTokenized;
  XML_Bool xmlns;
d207 1
a207 1
  XML_Bool isCdata;
d228 6
a233 5
  XML_Bool keepProcessing;
  /* true once an internal or external PE reference has been encountered;
     this includes the reference to an external subset */
  XML_Bool hasParamEntityRefs;
  XML_Bool standalone;
a234 2
  /* indicates if external PE has been read */
  XML_Bool paramEntityRead;
d239 1
a239 1
  XML_Bool in_eldecl;
d255 4
a258 4
typedef enum XML_Error PTRCALL Processor(XML_Parser parser,
                                         const char *start,
                                         const char *end,
                                         const char **endPtr);
a300 4

static enum XML_Error
storeAtts(XML_Parser parser, const ENCODING *, const char *s,
          TAG_NAME *tagNamePtr, BINDING **bindingsPtr);
d302 3
d307 1
d310 1
a310 1
                XML_Bool isCdata, XML_Bool isId, const XML_Char *dfltValue,
d312 1
d314 1
a314 1
storeAttributeValue(XML_Parser parser, const ENCODING *, XML_Bool isCdata,
d317 1
a317 1
appendAttributeValue(XML_Parser parser, const ENCODING *, XML_Bool isCdata,
d337 17
a353 15
static const XML_Char * getContext(XML_Parser parser);
static XML_Bool
setContext(XML_Parser parser, const XML_Char *context);

static void FASTCALL normalizePublicId(XML_Char *s);

static DTD * dtdCreate(const XML_Memory_Handling_Suite *ms);
/* do not call if parentParser != NULL */
static void dtdReset(DTD *p, const XML_Memory_Handling_Suite *ms);
static void
dtdDestroy(DTD *p, XML_Bool isDocEntity, const XML_Memory_Handling_Suite *ms);
static int
dtdCopy(DTD *newDtd, const DTD *oldDtd, const XML_Memory_Handling_Suite *ms);
static int
copyEntityTable(HASH_TABLE *, STRING_POOL *, const HASH_TABLE *);
d355 1
a355 27
static NAMED *
lookup(HASH_TABLE *table, KEY name, size_t createSize);
static void FASTCALL
hashTableInit(HASH_TABLE *, const XML_Memory_Handling_Suite *ms);
static void FASTCALL hashTableClear(HASH_TABLE *);
static void FASTCALL hashTableDestroy(HASH_TABLE *);
static void FASTCALL
hashTableIterInit(HASH_TABLE_ITER *, const HASH_TABLE *);
static NAMED * FASTCALL hashTableIterNext(HASH_TABLE_ITER *);

static void FASTCALL
poolInit(STRING_POOL *, const XML_Memory_Handling_Suite *ms);
static void FASTCALL poolClear(STRING_POOL *);
static void FASTCALL poolDestroy(STRING_POOL *);
static XML_Char *
poolAppend(STRING_POOL *pool, const ENCODING *enc,
           const char *ptr, const char *end);
static XML_Char *
poolStoreString(STRING_POOL *pool, const ENCODING *enc,
                const char *ptr, const char *end);
static XML_Bool FASTCALL poolGrow(STRING_POOL *pool);
static const XML_Char * FASTCALL
poolCopyString(STRING_POOL *pool, const XML_Char *s);
static const XML_Char *
poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n);
static const XML_Char * FASTCALL
poolAppendString(STRING_POOL *pool, const XML_Char *s);
d357 24
a380 5
static int FASTCALL nextScaffoldPart(XML_Parser parser);
static XML_Content * build_model(XML_Parser parser);
static ELEMENT_TYPE *
getElementType(XML_Parser parser, const ENCODING *enc,
               const char *ptr, const char *end);
d382 1
a382 7
static XML_Parser
parserCreate(const XML_Char *encodingName,
             const XML_Memory_Handling_Suite *memsuite,
             const XML_Char *nameSep,
             DTD *dtd);
static void
parserInit(XML_Parser parser, const XML_Char *encodingName);
d396 1
a396 1
struct XML_ParserStruct {
d402 1
a402 1
  const XML_Memory_Handling_Suite m_mem;
d429 1
a429 1
  XML_Parser m_externalEntityRefHandlerArg;
d440 2
a441 2
  XML_Bool m_ns;
  XML_Bool m_ns_triplets;
d453 1
a453 1
  XML_Bool m_defaultExpandInternalEntities;
d464 3
a466 3
  XML_Bool m_declAttributeIsCdata;
  XML_Bool m_declAttributeIsId;
  DTD *m_dtd;
d484 1
a484 2
  XML_Bool m_isParamEntity;
  XML_Bool m_useForeignDTD;
d487 1
a487 1
};
d489 35
a523 42
#define MALLOC(s) (parser->m_mem.malloc_fcn((s)))
#define REALLOC(p,s) (parser->m_mem.realloc_fcn((p),(s)))
#define FREE(p) (parser->m_mem.free_fcn((p)))

#define userData (parser->m_userData)
#define handlerArg (parser->m_handlerArg)
#define startElementHandler (parser->m_startElementHandler)
#define endElementHandler (parser->m_endElementHandler)
#define characterDataHandler (parser->m_characterDataHandler)
#define processingInstructionHandler \
        (parser->m_processingInstructionHandler)
#define commentHandler (parser->m_commentHandler)
#define startCdataSectionHandler \
        (parser->m_startCdataSectionHandler)
#define endCdataSectionHandler (parser->m_endCdataSectionHandler)
#define defaultHandler (parser->m_defaultHandler)
#define startDoctypeDeclHandler (parser->m_startDoctypeDeclHandler)
#define endDoctypeDeclHandler (parser->m_endDoctypeDeclHandler)
#define unparsedEntityDeclHandler \
        (parser->m_unparsedEntityDeclHandler)
#define notationDeclHandler (parser->m_notationDeclHandler)
#define startNamespaceDeclHandler \
        (parser->m_startNamespaceDeclHandler)
#define endNamespaceDeclHandler (parser->m_endNamespaceDeclHandler)
#define notStandaloneHandler (parser->m_notStandaloneHandler)
#define externalEntityRefHandler \
        (parser->m_externalEntityRefHandler)
#define externalEntityRefHandlerArg \
        (parser->m_externalEntityRefHandlerArg)
#define internalEntityRefHandler \
        (parser->m_internalEntityRefHandler)
#define skippedEntityHandler (parser->m_skippedEntityHandler)
#define unknownEncodingHandler (parser->m_unknownEncodingHandler)
#define elementDeclHandler (parser->m_elementDeclHandler)
#define attlistDeclHandler (parser->m_attlistDeclHandler)
#define entityDeclHandler (parser->m_entityDeclHandler)
#define xmlDeclHandler (parser->m_xmlDeclHandler)
#define encoding (parser->m_encoding)
#define initEncoding (parser->m_initEncoding)
#define internalEncoding (parser->m_internalEncoding)
#define unknownEncodingMem (parser->m_unknownEncodingMem)
#define unknownEncodingData (parser->m_unknownEncodingData)
d525 50
a574 51
  (parser->m_unknownEncodingHandlerData)
#define unknownEncodingRelease (parser->m_unknownEncodingRelease)
#define protocolEncodingName (parser->m_protocolEncodingName)
#define ns (parser->m_ns)
#define ns_triplets (parser->m_ns_triplets)
#define prologState (parser->m_prologState)
#define processor (parser->m_processor)
#define errorCode (parser->m_errorCode)
#define eventPtr (parser->m_eventPtr)
#define eventEndPtr (parser->m_eventEndPtr)
#define positionPtr (parser->m_positionPtr)
#define position (parser->m_position)
#define openInternalEntities (parser->m_openInternalEntities)
#define defaultExpandInternalEntities \
        (parser->m_defaultExpandInternalEntities)
#define tagLevel (parser->m_tagLevel)
#define buffer (parser->m_buffer)
#define bufferPtr (parser->m_bufferPtr)
#define bufferEnd (parser->m_bufferEnd)
#define parseEndByteIndex (parser->m_parseEndByteIndex)
#define parseEndPtr (parser->m_parseEndPtr)
#define bufferLim (parser->m_bufferLim)
#define dataBuf (parser->m_dataBuf)
#define dataBufEnd (parser->m_dataBufEnd)
#define _dtd (parser->m_dtd)
#define curBase (parser->m_curBase)
#define declEntity (parser->m_declEntity)
#define doctypeName (parser->m_doctypeName)
#define doctypeSysid (parser->m_doctypeSysid)
#define doctypePubid (parser->m_doctypePubid)
#define declAttributeType (parser->m_declAttributeType)
#define declNotationName (parser->m_declNotationName)
#define declNotationPublicId (parser->m_declNotationPublicId)
#define declElementType (parser->m_declElementType)
#define declAttributeId (parser->m_declAttributeId)
#define declAttributeIsCdata (parser->m_declAttributeIsCdata)
#define declAttributeIsId (parser->m_declAttributeIsId)
#define freeTagList (parser->m_freeTagList)
#define freeBindingList (parser->m_freeBindingList)
#define inheritedBindings (parser->m_inheritedBindings)
#define tagStack (parser->m_tagStack)
#define atts (parser->m_atts)
#define attsSize (parser->m_attsSize)
#define nSpecifiedAtts (parser->m_nSpecifiedAtts)
#define idAttIndex (parser->m_idAttIndex)
#define tempPool (parser->m_tempPool)
#define temp2Pool (parser->m_temp2Pool)
#define groupConnector (parser->m_groupConnector)
#define groupSize (parser->m_groupSize)
#define namespaceSeparator (parser->m_namespaceSeparator)
#define parentParser (parser->m_parentParser)
d576 2
a577 3
#define isParamEntity (parser->m_isParamEntity)
#define useForeignDTD (parser->m_useForeignDTD)
#define paramEntityParsing (parser->m_paramEntityParsing)
d580 16
a595 10
#define parsing \
  (parentParser \
    ? \
    (isParamEntity \
      ? \
      (processor != externalParEntInitProcessor) \
      : \
      (processor != externalEntityInitProcessor)) \
    : \
    (processor != prologInitProcessor))
a610 7
static const XML_Char implicitContext[] = {
  'x', 'm', 'l', '=', 'h', 't', 't', 'p', ':', '/', '/',
  'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g', '/',
  'X', 'M', 'L', '/', '1', '9', '9', '8', '/',
  'n', 'a', 'm', 'e', 's', 'p', 'a', 'c', 'e', '\0'
};

d614 8
a621 14
                    const XML_Char *nameSep)
{
  XML_Parser parser = parserCreate(encodingName, memsuite, nameSep, NULL);
  if (parser != NULL && ns) {
    /* implicit context only set for root parser, since child
       parsers (i.e. external entity parsers) will inherit it
    */
    if (!setContext(parser, implicitContext)) {
      XML_ParserFree(parser);
      return NULL;
    }
  }
  return parser;
}
a622 7
static XML_Parser
parserCreate(const XML_Char *encodingName,
             const XML_Memory_Handling_Suite *memsuite,
             const XML_Char *nameSep,
             DTD *dtd)
{
  XML_Parser parser;
d626 1
a626 2
    parser = (XML_Parser)
      memsuite->malloc_fcn(sizeof(struct XML_ParserStruct));
d628 1
a628 1
      mtemp = (XML_Memory_Handling_Suite *)&(parser->m_mem);
d636 1
a636 1
    parser = (XML_Parser)malloc(sizeof(struct XML_ParserStruct));
d638 1
a638 1
      mtemp = (XML_Memory_Handling_Suite *)&(parser->m_mem);
d652 1
a652 1
  atts = (ATTRIBUTE *)MALLOC(attsSize * sizeof(ATTRIBUTE));
d657 1
a657 1
  dataBuf = (XML_Char *)MALLOC(INIT_DATA_BUF_SIZE * sizeof(XML_Char));
a663 13

  if (dtd)
    _dtd = dtd;
  else {
    _dtd = dtdCreate(&parser->m_mem);
    if (_dtd == NULL) {
      FREE(dataBuf);
      FREE(atts);
      FREE(parser);
      return NULL;
    }
  }

d665 1
a667 6
  groupSize = 0;
  groupConnector = NULL;

  unknownEncodingHandler = NULL;
  unknownEncodingHandlerData = NULL;

d669 4
a672 2
  ns = XML_FALSE;
  ns_triplets = XML_FALSE;
d674 2
a675 5
  poolInit(&tempPool, &(parser->m_mem));
  poolInit(&temp2Pool, &(parser->m_mem));
  parserInit(parser, encodingName);

  if (encodingName && !protocolEncodingName) {
d681 1
a681 1
    ns = XML_TRUE;
d684 5
d697 1
a697 1
static void
d727 1
d745 2
a746 2
  declAttributeIsCdata = XML_FALSE;
  declAttributeIsId = XML_FALSE;
d753 1
a753 1
  defaultExpandInternalEntities = XML_TRUE;
d755 1
a755 2
  tagStack = NULL;
  inheritedBindings = NULL;
d757 2
d762 1
d765 1
a765 2
  isParamEntity = XML_FALSE;
  useForeignDTD = XML_FALSE;
d767 3
d773 1
a773 13
/* moves list of bindings to freeBindingList */
static void FASTCALL
moveToFreeBindingList(XML_Parser parser, BINDING *bindings)
{
  while (bindings) {
    BINDING *b = bindings;
    bindings = bindings->nextTagBinding;
    b->nextTagBinding = freeBindingList;
    freeBindingList = b;
  }
}

XML_Bool
d776 4
a779 18
  TAG *tStk;
  if (parentParser)
    return XML_FALSE;
  /* move tagStack to freeTagList */
  tStk = tagStack;
  while (tStk) {
    TAG *tag = tStk;
    tStk = tStk->parent;
    tag->parent = freeTagList;
    moveToFreeBindingList(parser, tag->bindings);
    tag->bindings = NULL;
    freeTagList = tag;
  }
  moveToFreeBindingList(parser, inheritedBindings);
  if (unknownEncodingMem)
    FREE(unknownEncodingMem);
  if (unknownEncodingRelease)
    unknownEncodingRelease(unknownEncodingData);
d782 1
a782 3
  parserInit(parser, encodingName);
  dtdReset(_dtd, &parser->m_mem);
  return setContext(parser, implicitContext);
d785 1
a785 1
enum XML_Status
a787 6
  /* Block after XML_Parse()/XML_ParseBuffer() has been called.
     XXX There's no way for the caller to determine which of the
     XXX possible error cases caused the XML_STATUS_ERROR return.
  */
  if (parsing)
    return XML_STATUS_ERROR;
d793 1
a793 1
      return XML_STATUS_ERROR;
d795 1
a795 1
  return XML_STATUS_OK;
d804 1
a804 2
  DTD *newDtd = NULL;
  DTD *oldDtd = _dtd;
d808 1
a808 2
  XML_ProcessingInstructionHandler oldProcessingInstructionHandler
      = processingInstructionHandler;
d810 2
a811 4
  XML_StartCdataSectionHandler oldStartCdataSectionHandler
      = startCdataSectionHandler;
  XML_EndCdataSectionHandler oldEndCdataSectionHandler
      = endCdataSectionHandler;
d813 1
a813 2
  XML_UnparsedEntityDeclHandler oldUnparsedEntityDeclHandler
      = unparsedEntityDeclHandler;
d815 2
a816 4
  XML_StartNamespaceDeclHandler oldStartNamespaceDeclHandler
      = startNamespaceDeclHandler;
  XML_EndNamespaceDeclHandler oldEndNamespaceDeclHandler
      = endNamespaceDeclHandler;
d818 1
a818 2
  XML_ExternalEntityRefHandler oldExternalEntityRefHandler
      = externalEntityRefHandler;
d820 1
a820 2
  XML_UnknownEncodingHandler oldUnknownEncodingHandler
      = unknownEncodingHandler;
d829 2
a830 2
  XML_Bool oldDefaultExpandInternalEntities = defaultExpandInternalEntities;
  XML_Parser oldExternalEntityRefHandlerArg = externalEntityRefHandlerArg;
d832 1
a832 1
  enum XML_ParamEntityParsing oldParamEntityParsing = paramEntityParsing;
d835 1
a835 1
  XML_Bool oldns_triplets = ns_triplets;
a836 10
#ifdef XML_DTD
  if (!context)
    newDtd = oldDtd;
#endif /* XML_DTD */

  /* Note that the magical uses of the pre-processor to make field
     access look more like C++ require that `parser' be overwritten
     here.  This makes this function more painful to follow than it
     would be otherwise.
  */
d839 1
d841 2
a842 1
    parser = parserCreate(encodingName, &parser->m_mem, tmp, newDtd);
d845 2
a846 1
    parser = parserCreate(encodingName, &parser->m_mem, NULL, newDtd);
d888 1
a888 2
    if (!dtdCopy(_dtd, oldDtd, &parser->m_mem)
      || !setContext(parser, context)) {
d896 2
a897 8
    /* The DTD instance referenced by _dtd is shared between the document's
       root parser and external PE parsers, therefore one does not need to
       call setContext. In addition, one also *must* not call setContext,
       because this would overwrite existing prefix->binding pointers in
       _dtd with ones that get destroyed with the external PE parser.
       This would leave those prefixes with dangling pointers.
    */
    isParamEntity = XML_TRUE;
d905 1
a905 1
static void FASTCALL
d923 1
a923 1
    if (tagStack == NULL) {
d940 2
a941 6
  /* external parameter entity parsers share the DTD structure
     parser->m_dtd with the root parser, so we must not destroy it
  */
  if (!isParamEntity && _dtd)
#else
  if (_dtd)
d943 1
a943 1
    dtdDestroy(_dtd, (XML_Bool)!parentParser, &parser->m_mem);
a962 14
enum XML_Error
XML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD)
{
#ifdef XML_DTD
  /* block after XML_Parse()/XML_ParseBuffer() has been called */
  if (parsing)
    return XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING;
  useForeignDTD = useDTD;
  return XML_ERROR_NONE;
#else
  return XML_ERROR_FEATURE_REQUIRES_XML_DTD;
#endif
}

d964 2
a965 6
XML_SetReturnNSTriplet(XML_Parser parser, int do_nst)
{
  /* block after XML_Parse()/XML_ParseBuffer() has been called */
  if (parsing)
    return;
  ns_triplets = do_nst ? XML_TRUE : XML_FALSE;
d977 1
a977 1
enum XML_Status
d981 1
a981 1
    p = poolCopyString(&_dtd->pool, p);
d983 1
a983 1
      return XML_STATUS_ERROR;
d988 1
a988 1
  return XML_STATUS_OK;
d1077 1
a1077 1
  defaultExpandInternalEntities = XML_FALSE;
d1085 1
a1085 1
  defaultExpandInternalEntities = XML_TRUE;
d1162 1
a1162 1
    externalEntityRefHandlerArg = (XML_Parser)arg;
d1212 1
a1212 1
                          enum XML_ParamEntityParsing peParsing)
a1213 3
  /* block after XML_Parse()/XML_ParseBuffer() has been called */
  if (parsing)
    return 0;
d1215 1
a1215 1
  paramEntityParsing = peParsing;
d1218 1
a1218 1
  return peParsing == XML_PARAM_ENTITY_PARSING_NEVER;
d1222 1
a1222 1
enum XML_Status
d1227 1
a1227 1
      return XML_STATUS_OK;
d1231 1
a1231 1
      return XML_STATUS_OK;
d1234 1
a1234 1
    return XML_STATUS_ERROR;
d1245 1
a1245 1
        return XML_STATUS_OK;
d1248 1
a1248 1
      return XML_STATUS_ERROR;
d1254 1
a1254 1
      return XML_STATUS_ERROR;
a1256 1
    positionPtr = end;
d1259 1
a1259 1
      if (buffer == NULL || nLeftOver > bufferLim - buffer) {
d1262 1
a1262 3
        temp = (buffer == NULL
                ? (char *)MALLOC(len * 2)
                : (char *)REALLOC(buffer, len * 2));
d1265 1
a1265 1
          return XML_STATUS_ERROR;
d1272 1
a1272 1
          return XML_STATUS_ERROR;
d1280 1
a1280 1
    return XML_STATUS_OK;
d1286 1
a1286 1
      return XML_STATUS_ERROR;
d1294 1
a1294 1
enum XML_Status
d1302 1
a1302 1
                        isFinal ? (const char **)NULL : &bufferPtr);
d1304 1
a1304 1
    if (!isFinal) {
d1306 1
a1306 3
      positionPtr = bufferPtr;
    }
    return XML_STATUS_OK;
d1311 1
a1311 1
    return XML_STATUS_ERROR;
d1350 1
a1350 1
      newBuf = (char *)MALLOC(bufferSize);
a1439 24
XML_FreeContentModel(XML_Parser parser, XML_Content *model)
{
  FREE(model);
}

void *
XML_MemMalloc(XML_Parser parser, size_t size)
{
  return MALLOC(size);
}

void *
XML_MemRealloc(XML_Parser parser, void *ptr, size_t size)
{
  return REALLOC(ptr, size);
}

void
XML_MemFree(XML_Parser parser, void *ptr)
{
  FREE(ptr);
}

void
d1454 1
a1454 1
XML_ErrorString(enum XML_Error code)
d1474 1
a1474 1
    XML_L("xml declaration not at start of external entity"),
d1481 1
a1481 3
    XML_L("entity declared in parameter entity"),
    XML_L("requested feature requires XML_DTD support in Expat"),
    XML_L("cannot change setting once parsing has begun")
d1499 2
a1500 2
#define V1(a,b,c) XML_L(#a)XML_L(".")XML_L(#b)XML_L(".")XML_L(#c)
#define V2(a,b,c) XML_L("expat_")V1(a,b,c)
d1509 1
a1509 2
XML_ExpatVersionInfo(void)
{
d1519 5
a1523 2
const XML_Feature *
XML_GetFeatureList(void)
d1525 1
a1525 25
  static XML_Feature features[] = {
    {XML_FEATURE_SIZEOF_XML_CHAR,  XML_L("sizeof(XML_Char)")},
    {XML_FEATURE_SIZEOF_XML_LCHAR, XML_L("sizeof(XML_LChar)")},
#ifdef XML_UNICODE
    {XML_FEATURE_UNICODE,          XML_L("XML_UNICODE")},
#endif
#ifdef XML_UNICODE_WCHAR_T
    {XML_FEATURE_UNICODE_WCHAR_T,  XML_L("XML_UNICODE_WCHAR_T")},
#endif
#ifdef XML_DTD
    {XML_FEATURE_DTD,              XML_L("XML_DTD")},
#endif
#ifdef XML_CONTEXT_BYTES
    {XML_FEATURE_CONTEXT_BYTES,    XML_L("XML_CONTEXT_BYTES"),
     XML_CONTEXT_BYTES},
#endif
#ifdef XML_MIN_SIZE
    {XML_FEATURE_MIN_SIZE,         XML_L("XML_MIN_SIZE")},
#endif
    {XML_FEATURE_END,              NULL}
  };

  features[0].value = sizeof(XML_Char);
  features[1].value = sizeof(XML_LChar);
  return features;
d1528 1
a1528 66
/* Initially tag->rawName always points into the parse buffer;
   for those TAG instances opened while the current parse buffer was
   processed, and not yet closed, we need to store tag->rawName in a more
   permanent location, since the parse buffer is about to be discarded.
*/
static XML_Bool
storeRawNames(XML_Parser parser)
{
  TAG *tag = tagStack;
  while (tag) {
    int bufSize;
    int nameLen = sizeof(XML_Char) * (tag->name.strLen + 1);
    char *rawNameBuf = tag->buf + nameLen;
    /* Stop if already stored.  Since tagStack is a stack, we can stop
       at the first entry that has already been copied; everything
       below it in the stack is already been accounted for in a
       previous call to this function.
    */
    if (tag->rawName == rawNameBuf)
      break;
    /* For re-use purposes we need to ensure that the
       size of tag->buf is a multiple of sizeof(XML_Char).
    */
    bufSize = nameLen + ROUND_UP(tag->rawNameLength, sizeof(XML_Char));
    if (bufSize > tag->bufEnd - tag->buf) {
      char *temp = (char *)REALLOC(tag->buf, bufSize);
      if (temp == NULL)
        return XML_FALSE;
      /* if tag->name.str points to tag->buf (only when namespace
         processing is off) then we have to update it
      */
      if (tag->name.str == (XML_Char *)tag->buf)
        tag->name.str = (XML_Char *)temp;
      /* if tag->name.localPart is set (when namespace processing is on)
         then update it as well, since it will always point into tag->buf
      */
      if (tag->name.localPart)
        tag->name.localPart = (XML_Char *)temp + (tag->name.localPart -
                                                  (XML_Char *)tag->buf);
      tag->buf = temp;
      tag->bufEnd = temp + bufSize;
      rawNameBuf = temp + nameLen;
    }
    memcpy(rawNameBuf, tag->rawName, tag->rawNameLength);
    tag->rawName = rawNameBuf;
    tag = tag->parent;
  }
  return XML_TRUE;
}

static enum XML_Error PTRCALL
contentProcessor(XML_Parser parser,
                 const char *start,
                 const char *end,
                 const char **endPtr)
{
  enum XML_Error result =
    doContent(parser, 0, encoding, start, end, endPtr);
  if (result != XML_ERROR_NONE)
    return result;
  if (!storeRawNames(parser))
    return XML_ERROR_NO_MEMORY;
  return result;
}

static enum XML_Error PTRCALL
d1541 1
a1541 1
static enum XML_Error PTRCALL
d1581 1
a1581 1
static enum XML_Error PTRCALL
d1615 1
a1615 1
  return externalEntityContentProcessor(parser, start, end, endPtr);
d1618 1
a1618 1
static enum XML_Error PTRCALL
d1624 1
a1624 7
  enum XML_Error result =
    doContent(parser, 1, encoding, start, end, endPtr);
  if (result != XML_ERROR_NONE)
    return result;
  if (!storeRawNames(parser))
    return XML_ERROR_NO_MEMORY;
  return result;
a1634 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d1708 1
a1708 1
        name = poolStoreString(&dtd->pool, enc,
d1713 2
a1714 2
        entity = (ENTITY *)lookup(&dtd->generalEntities, name, 0);
        poolDiscard(&dtd->pool);
d1719 1
a1719 1
        if (!dtd->hasParamEntityRefs || dtd->standalone) {
d1746 1
a1746 1
          entity->open = XML_TRUE;
d1758 1
a1758 1
          entity->open = XML_FALSE;
d1765 1
a1765 1
          entity->open = XML_TRUE;
d1767 1
a1767 1
          entity->open = XML_FALSE;
d1770 1
a1770 1
          if (!externalEntityRefHandler((XML_Parser)externalEntityRefHandlerArg,
d1782 7
a1789 2
      /* fall through */
    case XML_TOK_START_TAG_WITH_ATTS:
d1799 1
a1799 1
          tag = (TAG *)MALLOC(sizeof(TAG));
d1802 1
a1802 1
          tag->buf = (char *)MALLOC(INIT_TAG_BUF_SIZE);
d1816 8
a1823 17
        ++tagLevel;
        {
          const char *rawNameEnd = tag->rawName + tag->rawNameLength;
          const char *fromPtr = tag->rawName;
          toPtr = (XML_Char *)tag->buf;
          for (;;) {
            int bufSize;
            int convLen;
            XmlConvert(enc,
                       &fromPtr, rawNameEnd,
                       (ICHAR **)&toPtr, (ICHAR *)tag->bufEnd - 1);
            convLen = toPtr - (XML_Char *)tag->buf;
            if (fromPtr == rawNameEnd) {
              tag->name.strLen = convLen;
              break;
            }
            bufSize = (tag->bufEnd - tag->buf) << 1;
d1825 1
a1825 1
              char *temp = (char *)REALLOC(tag->buf, bufSize);
a1828 2
              tag->bufEnd = temp + bufSize;
              toPtr = (XML_Char *)temp + convLen;
d1830 1
d1832 29
a1861 1
        tag->name.str = (XML_Char *)tag->buf;
d1863 4
a1866 4
        result = storeAtts(parser, enc, s, &(tag->name), &(tag->bindings));
        if (result)
          return result;
        if (startElementHandler)
d1869 1
d1875 7
d1883 1
a1883 3
      /* fall through */
    case XML_TOK_EMPTY_ELEMENT_WITH_ATTS:
      {
a1886 1
        XML_Bool noElmHandlers = XML_TRUE;
d1897 1
a1897 1
        if (startElementHandler) {
a1898 2
          noElmHandlers = XML_FALSE;
        }
a1902 1
          noElmHandlers = XML_FALSE;
a1903 2
        if (noElmHandlers && defaultHandler)
          reportDefault(parser, enc, s, next);
d1915 2
d2096 2
a2097 9
/* Precondition: all arguments must be non-NULL;
   Purpose:
   - normalize attributes
   - check attributes for well-formedness
   - generate namespace aware attribute names (URI, prefix)
   - build list of attributes for startElementHandler
   - default attributes
   - process namespace declarations (check and report them)
   - generate namespace aware element name (URI, prefix)
a2103 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d2117 14
a2130 11
  elementType = (ELEMENT_TYPE *)lookup(&dtd->elementTypes, tagNamePtr->str,0);
  if (!elementType) {
    const XML_Char *name = poolCopyString(&dtd->pool, tagNamePtr->str);
    if (!name)
      return XML_ERROR_NO_MEMORY;
    elementType = (ELEMENT_TYPE *)lookup(&dtd->elementTypes, name,
                                         sizeof(ELEMENT_TYPE));
    if (!elementType)
      return XML_ERROR_NO_MEMORY;
    if (ns && !setElementTypePrefix(parser, elementType))
      return XML_ERROR_NO_MEMORY;
a2131 2
  nDefaultAtts = elementType->nDefaultAtts;

d2138 1
a2138 1
    temp = (ATTRIBUTE *)REALLOC((void *)atts, attsSize * sizeof(ATTRIBUTE));
a2144 1

d2163 1
a2163 1
      XML_Bool isCdata = XML_TRUE;
d2182 6
a2187 2
      appAtts[attIndex] = poolStart(&tempPool);
      poolFinish(&tempPool);
d2189 1
a2189 1
    else {
d2198 1
a2198 1
    if (attId->prefix) {
d2201 3
a2203 4
        enum XML_Error result = addBinding(parser, attId->prefix, attId,
                                           appAtts[attIndex], bindingsPtr);
        if (result)
          return result;
d2216 28
a2243 23

  /* set-up for XML_GetSpecifiedAttributeCount and XML_GetIdAttributeIndex */
  nSpecifiedAtts = attIndex;
  if (elementType->idAtt && (elementType->idAtt->name)[-1]) {
    for (i = 0; i < attIndex; i += 2)
      if (appAtts[i] == elementType->idAtt->name) {
        idAttIndex = i;
        break;
      }
  }
  else
    idAttIndex = -1;

  /* do attribute defaulting */
  for (i = 0; i < nDefaultAtts; i++) {
    const DEFAULT_ATTRIBUTE *da = elementType->defaultAtts + i;
    if (!(da->id->name)[-1] && da->value) {
      if (da->id->prefix) {
        if (da->id->xmlns) {
          enum XML_Error result = addBinding(parser, da->id->prefix, da->id,
                                             da->value, bindingsPtr);
          if (result)
            return result;
d2246 1
a2246 2
          (da->id->name)[-1] = 2;
          nPrefixes++;
a2250 5
      else {
        (da->id->name)[-1] = 1;
        appAtts[attIndex++] = da->id->name;
        appAtts[attIndex++] = da->value;
      }
d2252 1
a2253 2
  appAtts[attIndex] = 0;

d2261 1
a2261 1
        id = (ATTRIBUTE_ID *)lookup(&dtd->attributeIds, appAtts[i], 0);
d2298 2
a2301 1

d2311 2
a2312 2
  else if (dtd->defaultPrefix.binding) {
    binding = dtd->defaultPrefix.binding;
d2331 1
a2331 1
    uri = (XML_Char *)MALLOC((n + EXPAND_SPARE) * sizeof(XML_Char));
d2353 1
a2353 4
/* addBinding() overwrites the value of prefix->binding without checking.
   Therefore one must keep track of the old value outside of addBinding().
*/
static enum XML_Error
a2358 5

  /* empty string is only valid when there is no prefix per XML NS 1.0 */
  if (*uri == XML_T('\0') && prefix->name)
    return XML_ERROR_SYNTAX;

d2366 2
a2367 2
      XML_Char *temp = (XML_Char *)REALLOC(b->uri,
                          sizeof(XML_Char) * (len + EXPAND_SPARE));
d2369 1
a2369 1
        return XML_ERROR_NO_MEMORY;
d2376 1
a2376 1
    b = (BINDING *)MALLOC(sizeof(BINDING));
d2378 2
a2379 2
      return XML_ERROR_NO_MEMORY;
    b->uri = (XML_Char *)MALLOC(sizeof(XML_Char) * (len + EXPAND_SPARE));
d2382 1
a2382 1
      return XML_ERROR_NO_MEMORY;
d2393 1
a2393 1
  if (*uri == XML_T('\0') && prefix == &_dtd->defaultPrefix)
d2402 1
a2402 1
  return XML_ERROR_NONE;
d2408 1
a2408 1
static enum XML_Error PTRCALL
d2530 1
a2530 1
static enum XML_Error PTRCALL
d2658 1
a2658 1
    _dtd->standalone = XML_TRUE;
d2705 1
a2705 1
      poolClear(&temp2Pool);
d2757 1
a2757 1
static enum XML_Error PTRCALL
d2772 1
a2772 1
static enum XML_Error PTRCALL
d2774 3
a2776 3
                            const char *s,
                            const char *end,
                            const char **nextPtr)
d2783 3
a2785 2
     so we consider the external parameter entity read */
  _dtd->paramEntityRead = XML_TRUE;
d2797 1
a2797 1
static enum XML_Error PTRCALL
d2799 3
a2801 3
                         const char *s,
                         const char *end,
                         const char **nextPtr)
d2851 1
a2851 1
static enum XML_Error PTRCALL
d2853 3
a2855 3
                        const char *s,
                        const char *end,
                        const char **nextPtr)
d2892 1
a2892 1
static enum XML_Error PTRCALL
d2894 3
a2896 3
                     const char *s,
                     const char *end,
                     const char **nextPtr)
d2929 1
a2929 1
static enum XML_Error PTRCALL
d2957 4
a2960 8
  static const XML_Char atypeENTITIES[] =
      { 'E', 'N', 'T', 'I', 'T', 'I', 'E', 'S', '\0' };
  static const XML_Char atypeNMTOKEN[] = {
      'N', 'M', 'T', 'O', 'K', 'E', 'N', '\0' };
  static const XML_Char atypeNMTOKENS[] = {
      'N', 'M', 'T', 'O', 'K', 'E', 'N', 'S', '\0' };
  static const XML_Char notationPrefix[] = {
      'N', 'O', 'T', 'A', 'T', 'I', 'O', 'N', '(', '\0' };
a2963 2
  DTD * const dtd = _dtd;  /* save one level of indirection */

a2977 1
    XML_Bool handleDefault = XML_TRUE;
a3018 1
        handleDefault = XML_FALSE;
a3027 1
        handleDefault = XML_FALSE;
a3036 1
        handleDefault = XML_FALSE;
a3045 1
        handleDefault = XML_FALSE;
a3049 4
#ifdef XML_DTD
      useForeignDTD = XML_FALSE;
#endif /* XML_DTD */
      dtd->hasParamEntityRefs = XML_TRUE;
a3056 1
        handleDefault = XML_FALSE;
d3059 1
a3059 1
      declEntity = (ENTITY *)lookup(&dtd->paramEntities,
d3069 2
a3070 2
      if (dtd->keepProcessing && declEntity) {
        XML_Char *tem = poolStoreString(&dtd->pool,
d3078 1
a3078 3
        poolFinish(&dtd->pool);
        if (entityDeclHandler)
          handleDefault = XML_FALSE;
a3085 1
        handleDefault = XML_FALSE;
d3087 1
a3087 1
      /* doctypeSysid will be non-NULL in the case of a previous
d3091 1
a3092 2
      if (doctypeSysid || useForeignDTD) {
        dtd->hasParamEntityRefs = XML_TRUE; /* when docTypeSysid == NULL */
d3094 1
a3094 1
          ENTITY *entity = (ENTITY *)lookup(&dtd->paramEntities,
d3096 2
a3097 6
                                            sizeof(ENTITY));
          if (!entity)
            return XML_ERROR_NO_MEMORY;
          if (useForeignDTD)
            entity->base = curBase;
          dtd->paramEntityRead = XML_FALSE;
d3104 2
a3105 6
          if (dtd->paramEntityRead &&
              !dtd->standalone &&
              notStandaloneHandler &&
              !notStandaloneHandler(handlerArg))
            return XML_ERROR_NOT_STANDALONE;
          /* end of DTD - no need to update dtd->keepProcessing */
d3107 8
a3114 1
        useForeignDTD = XML_FALSE;
d3116 1
a3116 2
#endif /* XML_DTD */
      if (endDoctypeDeclHandler) {
a3117 2
        handleDefault = XML_FALSE;
      }
a3119 29
#ifdef XML_DTD
      /* if there is no DOCTYPE declaration then now is the
         last chance to read the foreign DTD
      */
      if (useForeignDTD) {
        dtd->hasParamEntityRefs = XML_TRUE;
        if (paramEntityParsing && externalEntityRefHandler) {
          ENTITY *entity = (ENTITY *)lookup(&dtd->paramEntities,
                                            externalSubsetName,
                                            sizeof(ENTITY));
          if (!entity)
            return XML_ERROR_NO_MEMORY;
          entity->base = curBase;
          dtd->paramEntityRead = XML_FALSE;
          if (!externalEntityRefHandler(externalEntityRefHandlerArg,
                                        0,
                                        entity->base,
                                        entity->systemId,
                                        entity->publicId))
            return XML_ERROR_EXTERNAL_ENTITY_HANDLING;
          if (dtd->paramEntityRead &&
              !dtd->standalone &&
              notStandaloneHandler &&
              !notStandaloneHandler(handlerArg))
            return XML_ERROR_NOT_STANDALONE;
          /* end of DTD - no need to update dtd->keepProcessing */
        }
      }
#endif /* XML_DTD */
d3126 1
a3126 1
      goto checkAttListDeclHandler;
d3131 1
a3131 1
      declAttributeIsCdata = XML_FALSE;
d3133 2
a3134 2
      declAttributeIsId = XML_FALSE;
      goto checkAttListDeclHandler;
d3136 1
a3136 1
      declAttributeIsCdata = XML_TRUE;
d3138 1
a3138 1
      goto checkAttListDeclHandler;
d3140 1
a3140 1
      declAttributeIsId = XML_TRUE;
d3142 1
a3142 1
      goto checkAttListDeclHandler;
d3145 1
a3145 1
      goto checkAttListDeclHandler;
d3148 1
a3148 1
      goto checkAttListDeclHandler;
d3151 1
a3151 1
      goto checkAttListDeclHandler;
d3154 1
a3154 1
      goto checkAttListDeclHandler;
d3157 1
a3157 1
      goto checkAttListDeclHandler;
a3159 3
    checkAttListDeclHandler:
      if (dtd->keepProcessing && attlistDeclHandler)
        handleDefault = XML_FALSE;
d3163 1
a3163 1
      if (dtd->keepProcessing && attlistDeclHandler) {
a3177 1
        handleDefault = XML_FALSE;
d3182 1
a3182 1
      if (dtd->keepProcessing) {
a3202 1
          handleDefault = XML_FALSE;
d3208 1
a3208 1
      if (dtd->keepProcessing) {
d3214 1
a3214 1
                                &dtd->pool);
d3217 2
a3218 2
        attVal = poolStart(&dtd->pool);
        poolFinish(&dtd->pool);
d3221 1
a3221 1
                             declAttributeIsCdata, XML_FALSE, attVal, parser))
a3239 1
          handleDefault = XML_FALSE;
d3244 1
a3244 1
      if (dtd->keepProcessing) {
d3246 2
a3247 2
                                            s + enc->minBytesPerChar,
                                            next - enc->minBytesPerChar);
d3249 3
a3251 3
          declEntity->textPtr = poolStart(&dtd->entityValuePool);
          declEntity->textLen = poolLength(&dtd->entityValuePool);
          poolFinish(&dtd->entityValuePool);
a3259 1
            handleDefault = XML_FALSE;
d3263 1
a3263 1
          poolDiscard(&dtd->entityValuePool);
a3268 4
#ifdef XML_DTD
      useForeignDTD = XML_FALSE;
#endif /* XML_DTD */
      dtd->hasParamEntityRefs = XML_TRUE;
a3275 1
        handleDefault = XML_FALSE;
d3277 1
a3278 1
      else
d3283 1
a3283 1
      if (!dtd->standalone
d3294 1
a3294 1
        declEntity = (ENTITY *)lookup(&dtd->paramEntities,
d3304 2
a3305 2
      if (dtd->keepProcessing && declEntity) {
        declEntity->systemId = poolStoreString(&dtd->pool, enc,
d3311 1
a3311 3
        poolFinish(&dtd->pool);
        if (entityDeclHandler)
          handleDefault = XML_FALSE;
d3315 1
a3315 1
      if (dtd->keepProcessing && declEntity && entityDeclHandler) {
a3324 1
        handleDefault = XML_FALSE;
d3328 2
a3329 2
      if (dtd->keepProcessing && declEntity) {
        declEntity->notation = poolStoreString(&dtd->pool, enc, s, next);
d3332 1
a3332 1
        poolFinish(&dtd->pool);
a3340 1
          handleDefault = XML_FALSE;
a3350 1
          handleDefault = XML_FALSE;
d3360 2
a3361 2
        if (dtd->keepProcessing) {
          const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);
d3364 1
a3364 1
          declEntity = (ENTITY *)lookup(&dtd->generalEntities, name,
d3369 1
a3369 1
            poolDiscard(&dtd->pool);
d3373 1
a3373 1
            poolFinish(&dtd->pool);
d3375 1
a3375 1
            declEntity->is_param = XML_FALSE;
a3379 2
            if (entityDeclHandler)
              handleDefault = XML_FALSE;
d3383 1
a3383 1
          poolDiscard(&dtd->pool);
d3390 2
a3391 2
      if (dtd->keepProcessing) {
        const XML_Char *name = poolStoreString(&dtd->pool, enc, s, next);
d3394 1
a3394 1
        declEntity = (ENTITY *)lookup(&dtd->paramEntities,
d3399 2
a3400 2
          poolDiscard(&dtd->pool);
          declEntity = NULL;
d3403 3
a3405 3
          poolFinish(&dtd->pool);
          declEntity->publicId = NULL;
          declEntity->is_param = XML_TRUE;
a3409 2
          if (entityDeclHandler)
            handleDefault = XML_FALSE;
d3413 1
a3413 1
        poolDiscard(&dtd->pool);
a3427 1
        handleDefault = XML_FALSE;
d3433 1
a3433 1
      if (declNotationName) {  /* means notationDeclHandler != NULL */
a3442 1
        handleDefault = XML_FALSE;
a3458 1
        handleDefault = XML_FALSE;
a3469 1
        handleDefault = XML_FALSE;
a3487 1
        handleDefault = XML_FALSE;
d3499 1
a3499 1
          char *temp = (char *)REALLOC(groupConnector, groupSize *= 2);
d3503 2
a3504 3
          if (dtd->scaffIndex) {
            int *temp = (int *)REALLOC(dtd->scaffIndex,
                          groupSize * sizeof(int));
d3507 1
a3507 1
            dtd->scaffIndex = temp;
d3511 1
a3511 1
          groupConnector = (char *)MALLOC(groupSize = 32);
d3517 1
a3517 1
      if (dtd->in_eldecl) {
d3521 3
a3523 5
        dtd->scaffIndex[dtd->scaffLevel] = myindex;
        dtd->scaffLevel++;
        dtd->scaffold[myindex].type = XML_CTYPE_SEQ;
        if (elementDeclHandler)
          handleDefault = XML_FALSE;
a3529 2
      if (dtd->in_eldecl && elementDeclHandler)
        handleDefault = XML_FALSE;
d3534 1
a3534 1
      if (dtd->in_eldecl
d3536 1
a3536 1
          && (dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type
d3539 1
a3539 1
        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type
a3540 2
        if (elementDeclHandler)
          handleDefault = XML_FALSE;
a3551 1
      dtd->hasParamEntityRefs = XML_TRUE;
d3553 1
a3553 1
        dtd->keepProcessing = dtd->standalone;
d3557 1
a3557 1
        name = poolStoreString(&dtd->pool, enc,
d3562 2
a3563 2
        entity = (ENTITY *)lookup(&dtd->paramEntities, name, 0);
        poolDiscard(&dtd->pool);
d3569 1
a3569 3
            (dtd->standalone
             ? !openInternalEntities
             : !dtd->hasParamEntityRefs)) {
d3576 1
a3576 1
          dtd->keepProcessing = dtd->standalone;
d3578 1
a3578 1
          if ((role == XML_ROLE_PARAM_ENTITY_REF) && skippedEntityHandler) {
a3579 2
            handleDefault = XML_FALSE;
          }
a3588 1
          handleDefault = XML_FALSE;
d3592 2
a3593 2
          dtd->paramEntityRead = XML_FALSE;
          entity->open = XML_TRUE;
d3599 1
a3599 1
            entity->open = XML_FALSE;
d3602 3
a3604 4
          entity->open = XML_FALSE;
          handleDefault = XML_FALSE;
          if (!dtd->paramEntityRead) {
            dtd->keepProcessing = dtd->standalone;
a3607 4
        else {
          dtd->keepProcessing = dtd->standalone;
          break;
        }
d3610 3
a3612 3
      if (!dtd->standalone &&
          notStandaloneHandler &&
          !notStandaloneHandler(handlerArg))
d3614 6
d3622 1
a3622 1
    /* Element declaration stuff */
d3626 1
a3626 1
        declElementType = getElementType(parser, enc, s, next);
d3628 4
a3631 5
          return XML_ERROR_NO_MEMORY;
        dtd->scaffLevel = 0;
        dtd->scaffCount = 0;
        dtd->in_eldecl = XML_TRUE;
        handleDefault = XML_FALSE;
d3637 1
a3637 1
      if (dtd->in_eldecl) {
a3650 1
          handleDefault = XML_FALSE;
d3652 1
a3652 1
        dtd->in_eldecl = XML_FALSE;
d3657 2
a3658 2
      if (dtd->in_eldecl) {
        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel - 1]].type
a3659 2
        if (elementDeclHandler)
          handleDefault = XML_FALSE;
d3675 1
a3675 1
      if (dtd->in_eldecl) {
d3685 2
a3686 2
        dtd->scaffold[myindex].type = XML_CTYPE_NAME;
        dtd->scaffold[myindex].quant = quant;
d3691 1
a3691 1
        dtd->scaffold[myindex].name = name;
d3694 1
a3694 3
        dtd->contentStringLen +=  nameLen;
        if (elementDeclHandler)
          handleDefault = XML_FALSE;
d3710 5
a3714 7
      if (dtd->in_eldecl) {
        if (elementDeclHandler)
          handleDefault = XML_FALSE;
        dtd->scaffLevel--;
        dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel]].quant = quant;
        if (dtd->scaffLevel == 0) {
          if (!handleDefault) {
d3721 2
a3722 2
          dtd->in_eldecl = XML_FALSE;
          dtd->contentStringLen = 0;
a3727 10
    case XML_ROLE_PI:
      if (!reportProcessingInstruction(parser, enc, s, next))
        return XML_ERROR_NO_MEMORY;
      handleDefault = XML_FALSE;
      break;
    case XML_ROLE_COMMENT:
      if (!reportComment(parser, enc, s, next))
        return XML_ERROR_NO_MEMORY;
      handleDefault = XML_FALSE;
      break;
d3730 7
a3736 2
      case XML_TOK_BOM:
        handleDefault = XML_FALSE;
a3739 20
    case XML_ROLE_DOCTYPE_NONE:
      if (startDoctypeDeclHandler)
        handleDefault = XML_FALSE;
      break;
    case XML_ROLE_ENTITY_NONE:
      if (dtd->keepProcessing && entityDeclHandler)
        handleDefault = XML_FALSE;
      break;
    case XML_ROLE_NOTATION_NONE:
      if (notationDeclHandler)
        handleDefault = XML_FALSE;
      break;
    case XML_ROLE_ATTLIST_NONE:
      if (dtd->keepProcessing && attlistDeclHandler)
        handleDefault = XML_FALSE;
      break;
    case XML_ROLE_ELEMENT_NONE:
      if (elementDeclHandler)
        handleDefault = XML_FALSE;
      break;
d3742 18
a3759 2
    if (handleDefault && defaultHandler)
      reportDefault(parser, enc, s, next);
d3767 1
a3767 1
static enum XML_Error PTRCALL
a3779 1
    /* report partial linebreak - it might be the last token */
d3782 2
a3783 2
        eventEndPtr = next;
        reportDefault(parser, encoding, s, next);
d3785 1
a3785 3
      if (nextPtr)
        *nextPtr = next;
      return XML_ERROR_NONE;
d3788 1
a3788 1
        *nextPtr = s;
d3833 1
a3833 1
  entity->open = XML_TRUE;
d3841 1
d3844 1
a3844 1
  entity->open = XML_FALSE;
d3851 1
a3851 1
static enum XML_Error PTRCALL
d3861 1
a3861 1
storeAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,
d3877 1
a3877 1
appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,
a3880 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d3953 1
a3953 1
        entity = (ENTITY *)lookup(&dtd->generalEntities, name, 0);
d3959 1
a3959 1
        if (pool == &dtd->pool)  /* are we called from prolog? */
d3964 1
a3964 3
              (dtd->standalone
               ? !openInternalEntities
               : !dtd->hasParamEntityRefs);
d3966 1
a3966 1
          checkEntityDecl = !dtd->hasParamEntityRefs || dtd->standalone;
d4001 1
a4001 1
          entity->open = XML_TRUE;
d4005 1
a4005 1
          entity->open = XML_FALSE;
d4027 1
a4027 2
  DTD * const dtd = _dtd;  /* save one level of indirection */
  STRING_POOL *pool = &(dtd->entityValuePool);
d4057 1
a4057 1
        entity = (ENTITY *)lookup(&dtd->paramEntities, name, 0);
d4066 1
a4066 1
          dtd->keepProcessing = dtd->standalone;
d4077 2
a4078 2
            dtd->paramEntityRead = XML_FALSE;
            entity->open = XML_TRUE;
d4084 1
a4084 1
              entity->open = XML_FALSE;
d4088 3
a4090 3
            entity->open = XML_FALSE;
            if (!dtd->paramEntityRead)
              dtd->keepProcessing = dtd->standalone;
a4091 2
          else
            dtd->keepProcessing = dtd->standalone;
d4094 1
a4094 1
          entity->open = XML_TRUE;
d4100 1
a4100 1
          entity->open = XML_FALSE;
d4184 1
a4184 1
static void FASTCALL
d4287 2
a4288 2
defineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *attId, XML_Bool isCdata,
                XML_Bool isId, const XML_Char *value, XML_Parser parser)
d4304 2
a4305 2
      type->defaultAtts = (DEFAULT_ATTRIBUTE *)MALLOC(type->allocDefaultAtts 
                            * sizeof(DEFAULT_ATTRIBUTE));
d4312 1
a4312 2
      temp = (DEFAULT_ATTRIBUTE *)
        REALLOC(type->defaultAtts, (count * sizeof(DEFAULT_ATTRIBUTE)));
d4322 1
a4322 1
  att->isCdata = isCdata;
d4324 1
a4324 1
    attId->maybeTokenized = XML_TRUE;
a4331 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d4338 1
a4338 1
        if (!poolAppendChar(&dtd->pool, *s))
d4341 1
a4341 1
      if (!poolAppendChar(&dtd->pool, XML_T('\0')))
d4343 1
a4343 1
      prefix = (PREFIX *)lookup(&dtd->prefixes, poolStart(&dtd->pool),
d4347 2
a4348 2
      if (prefix->name == poolStart(&dtd->pool))
        poolFinish(&dtd->pool);
d4350 1
a4350 1
        poolDiscard(&dtd->pool);
a4361 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d4364 1
a4364 1
  if (!poolAppendChar(&dtd->pool, XML_T('\0')))
d4366 1
a4366 1
  name = poolStoreString(&dtd->pool, enc, start, end);
d4370 1
a4370 1
  id = (ATTRIBUTE_ID *)lookup(&dtd->attributeIds, name, sizeof(ATTRIBUTE_ID));
d4374 1
a4374 1
    poolDiscard(&dtd->pool);
d4376 1
a4376 1
    poolFinish(&dtd->pool);
d4379 5
a4383 5
    else if (name[0] == XML_T('x')
        && name[1] == XML_T('m')
        && name[2] == XML_T('l')
        && name[3] == XML_T('n')
        && name[4] == XML_T('s')
d4385 2
a4386 2
      if (name[5] == XML_T('\0'))
        id->prefix = &dtd->defaultPrefix;
d4388 2
a4389 2
        id->prefix = (PREFIX *)lookup(&dtd->prefixes, name + 6, sizeof(PREFIX));
      id->xmlns = XML_TRUE;
d4397 1
a4397 1
            if (!poolAppendChar(&dtd->pool, name[j]))
d4400 1
a4400 1
          if (!poolAppendChar(&dtd->pool, XML_T('\0')))
d4402 1
a4402 1
          id->prefix = (PREFIX *)lookup(&dtd->prefixes, poolStart(&dtd->pool),
d4404 2
a4405 2
          if (id->prefix->name == poolStart(&dtd->pool))
            poolFinish(&dtd->pool);
d4407 1
a4407 1
            poolDiscard(&dtd->pool);
a4420 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d4422 1
a4422 1
  XML_Bool needSep = XML_FALSE;
d4424 1
a4424 1
  if (dtd->defaultPrefix.binding) {
d4429 1
a4429 1
    len = dtd->defaultPrefix.binding->uriLen;
d4433 1
a4433 1
      if (!poolAppendChar(&tempPool, dtd->defaultPrefix.binding->uri[i]))
d4435 1
a4435 1
    needSep = XML_TRUE;
d4438 1
a4438 1
  hashTableIterInit(&iter, &(dtd->prefixes));
d4461 1
a4461 1
    needSep = XML_TRUE;
d4465 1
a4465 1
  hashTableIterInit(&iter, &(dtd->generalEntities));
d4478 1
a4478 1
    needSep = XML_TRUE;
d4486 1
a4486 1
static XML_Bool
a4488 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d4495 2
a4496 2
        return XML_FALSE;
      e = (ENTITY *)lookup(&dtd->generalEntities, poolStart(&tempPool), 0);
d4498 1
a4498 1
        e->open = XML_TRUE;
d4507 1
a4507 1
        prefix = &dtd->defaultPrefix;
d4510 2
a4511 2
          return XML_FALSE;
        prefix = (PREFIX *)lookup(&dtd->prefixes, poolStart(&tempPool),
d4514 1
a4514 1
          return XML_FALSE;
d4516 1
a4516 1
          prefix->name = poolCopyString(&dtd->pool, prefix->name);
d4518 1
a4518 1
            return XML_FALSE;
d4526 1
a4526 1
          return XML_FALSE;
d4528 4
a4531 4
        return XML_FALSE;
      if (addBinding(parser, prefix, 0, poolStart(&tempPool),
                     &inheritedBindings) != XML_ERROR_NONE)
        return XML_FALSE;
d4539 1
a4539 1
        return XML_FALSE;
d4543 1
a4543 1
  return XML_TRUE;
d4546 1
a4546 1
static void FASTCALL
d4568 2
a4569 2
static DTD *
dtdCreate(const XML_Memory_Handling_Suite *ms)
d4571 1
a4571 3
  DTD *p = (DTD *)ms->malloc_fcn(sizeof(DTD));
  if (p == NULL)
    return p;
d4580 4
a4584 1
  p->paramEntityRead = XML_FALSE;
d4590 3
a4592 2
  p->in_eldecl = XML_FALSE;
  p->scaffIndex = NULL;
d4594 1
a4594 1
  p->scaffLevel = 0;
a4596 1
  p->contentStringLen = 0;
d4598 1
a4598 4
  p->keepProcessing = XML_TRUE;
  p->hasParamEntityRefs = XML_FALSE;
  p->standalone = XML_FALSE;
  return p;
d4601 2
d4604 1
a4604 1
dtdReset(DTD *p, const XML_Memory_Handling_Suite *ms)
d4606 6
a4611 20
  HASH_TABLE_ITER iter;
  hashTableIterInit(&iter, &(p->elementTypes));
  for (;;) {
    ELEMENT_TYPE *e = (ELEMENT_TYPE *)hashTableIterNext(&iter);
    if (!e)
      break;
    if (e->allocDefaultAtts != 0)
      ms->free_fcn(e->defaultAtts);
  }
  hashTableClear(&(p->generalEntities));
#ifdef XML_DTD
  p->paramEntityRead = XML_FALSE;
  hashTableClear(&(p->paramEntities));
#endif /* XML_DTD */
  hashTableClear(&(p->elementTypes));
  hashTableClear(&(p->attributeIds));
  hashTableClear(&(p->prefixes));
  poolClear(&(p->pool));
#ifdef XML_DTD
  poolClear(&(p->entityValuePool));
a4612 21
  p->defaultPrefix.name = NULL;
  p->defaultPrefix.binding = NULL;

  p->in_eldecl = XML_FALSE;
  if (p->scaffIndex) {
    ms->free_fcn(p->scaffIndex);
    p->scaffIndex = NULL;
  }
  if (p->scaffold) {
    ms->free_fcn(p->scaffold);
    p->scaffold = NULL;
  }
  p->scaffLevel = 0;
  p->scaffSize = 0;
  p->scaffCount = 0;
  p->contentStringLen = 0;

  p->keepProcessing = XML_TRUE;
  p->hasParamEntityRefs = XML_FALSE;
  p->standalone = XML_FALSE;
}
d4615 1
a4615 1
dtdDestroy(DTD *p, XML_Bool isDocEntity, const XML_Memory_Handling_Suite *ms)
d4624 1
a4624 1
      ms->free_fcn(e->defaultAtts);
d4637 1
a4637 1
  if (isDocEntity) {
d4639 1
a4639 1
      ms->free_fcn(p->scaffIndex);
d4641 1
a4641 1
      ms->free_fcn(p->scaffold);
a4642 1
  ms->free_fcn(p);
d4645 1
a4645 1
/* Do a deep copy of the DTD. Return 0 for out of memory, non-zero otherwise.
d4649 1
a4649 1
dtdCopy(DTD *newDtd, const DTD *oldDtd, const XML_Memory_Handling_Suite *ms)
d4721 1
a4721 1
          ms->malloc_fcn(oldE->nDefaultAtts * sizeof(DEFAULT_ATTRIBUTE));
d4723 1
a4723 1
        ms->free_fcn(newE);
d4752 1
a4752 1
                       &(oldDtd->generalEntities)))
d4758 1
a4758 1
                       &(oldDtd->paramEntities)))
a4759 1
  newDtd->paramEntityRead = oldDtd->paramEntityRead;
d4763 2
a4764 1
  newDtd->hasParamEntityRefs = oldDtd->hasParamEntityRefs;
d4781 2
a4782 1
                const HASH_TABLE *oldTable)
d4847 1
a4847 1
static int FASTCALL
d4856 1
a4856 1
static unsigned long FASTCALL
d4875 1
a4875 1
    table->v = (NAMED **)table->mem->malloc_fcn(tsize);
d4897 1
a4897 1
      NAMED **newV = (NAMED **)table->mem->malloc_fcn(tsize);
d4920 1
a4920 1
  table->v[i] = (NAMED *)table->mem->malloc_fcn(createSize);
d4929 1
a4929 16
static void FASTCALL
hashTableClear(HASH_TABLE *table)
{
  size_t i;
  for (i = 0; i < table->size; i++) {
    NAMED *p = table->v[i];
    if (p) {
      table->mem->free_fcn(p);
      table->v[i] = NULL;
    }
  }
  table->usedLim = table->size / 2;
  table->used = 0;
}

static void FASTCALL
d4942 2
a4943 2
static void FASTCALL
hashTableInit(HASH_TABLE *p, const XML_Memory_Handling_Suite *ms)
d4948 1
a4948 1
  p->v = NULL;
d4952 1
a4952 1
static void FASTCALL
d4959 1
a4959 1
static NAMED * FASTCALL
d4970 2
a4971 2
static void FASTCALL
poolInit(STRING_POOL *pool, const XML_Memory_Handling_Suite *ms)
d4973 5
a4977 5
  pool->blocks = NULL;
  pool->freeBlocks = NULL;
  pool->start = NULL;
  pool->ptr = NULL;
  pool->end = NULL;
d4981 1
a4981 1
static void FASTCALL
d4995 4
a4998 4
  pool->blocks = NULL;
  pool->start = NULL;
  pool->ptr = NULL;
  pool->end = NULL;
d5001 1
a5001 1
static void FASTCALL
d5010 1
d5017 4
d5039 1
a5039 1
static const XML_Char * FASTCALL
d5065 1
a5065 1
static const XML_Char * FASTCALL
d5088 1
a5088 1
static XML_Bool FASTCALL
d5099 1
a5099 1
      return XML_TRUE;
d5111 1
a5111 1
      return XML_TRUE;
d5116 5
a5120 6
    pool->blocks = (BLOCK *)
      pool->mem->realloc_fcn(pool->blocks,
			     (offsetof(BLOCK, s)
			      + blockSize * sizeof(XML_Char)));
    if (pool->blocks == NULL)
      return XML_FALSE;
d5133 2
a5134 2
    tem = (BLOCK *)pool->mem->malloc_fcn(offsetof(BLOCK, s)
					+ blockSize * sizeof(XML_Char));
d5136 1
a5136 1
      return XML_FALSE;
d5147 1
a5147 1
  return XML_TRUE;
d5150 1
a5150 1
static int FASTCALL
a5152 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d5156 3
a5158 3
  if (!dtd->scaffIndex) {
    dtd->scaffIndex = (int *)MALLOC(groupSize * sizeof(int));
    if (!dtd->scaffIndex)
d5160 1
a5160 1
    dtd->scaffIndex[0] = 0;
d5163 1
a5163 1
  if (dtd->scaffCount >= dtd->scaffSize) {
d5165 1
a5165 1
    if (dtd->scaffold) {
d5167 1
a5167 1
        REALLOC(dtd->scaffold, dtd->scaffSize * 2 * sizeof(CONTENT_SCAFFOLD));
d5170 1
a5170 1
      dtd->scaffSize *= 2;
d5173 1
a5173 2
      temp = (CONTENT_SCAFFOLD *)MALLOC(INIT_SCAFFOLD_ELEMENTS
                                        * sizeof(CONTENT_SCAFFOLD));
d5176 1
a5176 1
      dtd->scaffSize = INIT_SCAFFOLD_ELEMENTS;
d5178 1
a5178 1
    dtd->scaffold = temp;
d5180 4
a5183 4
  next = dtd->scaffCount++;
  me = &dtd->scaffold[next];
  if (dtd->scaffLevel) {
    CONTENT_SCAFFOLD *parent = &dtd->scaffold[dtd->scaffIndex[dtd->scaffLevel-1]];
d5185 1
a5185 1
      dtd->scaffold[parent->lastchild].nextsib = next;
d5203 2
a5204 3
  DTD * const dtd = _dtd;  /* save one level of indirection */
  dest->type = dtd->scaffold[src_node].type;
  dest->quant = dtd->scaffold[src_node].quant;
d5208 1
a5208 1
    src = dtd->scaffold[src_node].name;
d5221 1
a5221 1
    dest->numchildren = dtd->scaffold[src_node].childcnt;
d5224 1
a5224 1
    for (i = 0, cn = dtd->scaffold[src_node].firstchild;
d5226 1
a5226 1
         i++, cn = dtd->scaffold[cn].nextsib) {
a5235 1
  DTD * const dtd = _dtd;  /* save one level of indirection */
d5239 2
a5240 2
  int allocsize = (dtd->scaffCount * sizeof(XML_Content)
                   + (dtd->contentStringLen * sizeof(XML_Char)));
d5242 1
a5242 1
  ret = (XML_Content *)MALLOC(allocsize);
d5246 1
a5246 1
  str =  (XML_Char *) (&ret[dtd->scaffCount]);
d5259 1
a5259 2
  DTD * const dtd = _dtd;  /* save one level of indirection */
  const XML_Char *name = poolStoreString(&dtd->pool, enc, ptr, end);
d5264 1
a5264 1
  ret = (ELEMENT_TYPE *) lookup(&dtd->elementTypes, name, sizeof(ELEMENT_TYPE));
d5268 1
a5268 1
    poolDiscard(&dtd->pool);
d5270 1
a5270 1
    poolFinish(&dtd->pool);
@


