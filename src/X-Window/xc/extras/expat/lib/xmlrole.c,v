head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.3
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.3
	MIRBSD_7_ALPHA:1.1.1.3.0.4
	MIRBSD_7:1.1.1.3.0.2
	MIRBSD_7ter:1.1.1.3
	cvs-20011091815:1.1.1.3
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.29.24;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.04.08.18.20.29;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.04.08.18.20.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.15.15.16;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.09.18.33.37;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.05.51;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@/*
Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
See the file COPYING for copying permission.
*/

#if 0
static char RCSId[]
  = "$Header: /lcvs/src/X-Window/xc/extras/expat/lib/xmlrole.c,v 1.1 2003/04/08 18:20:29 tg Exp $";
#endif

/* $XFree86: xc/extras/expat/lib/xmlrole.c,v 1.2 2002/04/07 04:03:19 tsi Exp $ */

#ifdef COMPILED_FROM_DSP
#  include "winconfig.h"
#else
#  include <config.h>
#endif /* ndef COMPILED_FROM_DSP */

#include "xmlrole.h"
#include "ascii.h"

/* Doesn't check:

 that ,| are not mixed in a model group
 content of literals

*/

static const char KW_ANY[] = { ASCII_A, ASCII_N, ASCII_Y, '\0' };
static const char KW_ATTLIST[] = { ASCII_A, ASCII_T, ASCII_T, ASCII_L, ASCII_I, ASCII_S, ASCII_T, '\0' };
static const char KW_CDATA[] = { ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\0' };
static const char KW_DOCTYPE[] = { ASCII_D, ASCII_O, ASCII_C, ASCII_T, ASCII_Y, ASCII_P, ASCII_E, '\0' };
static const char KW_ELEMENT[] = { ASCII_E, ASCII_L, ASCII_E, ASCII_M, ASCII_E, ASCII_N, ASCII_T, '\0' };
static const char KW_EMPTY[] = { ASCII_E, ASCII_M, ASCII_P, ASCII_T, ASCII_Y, '\0' };
static const char KW_ENTITIES[] = { ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T, ASCII_I, ASCII_E, ASCII_S, '\0' };
static const char KW_ENTITY[] = { ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T, ASCII_Y, '\0' };
static const char KW_FIXED[] = { ASCII_F, ASCII_I, ASCII_X, ASCII_E, ASCII_D, '\0' };
static const char KW_ID[] = { ASCII_I, ASCII_D, '\0' };
static const char KW_IDREF[] = { ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, '\0' };
static const char KW_IDREFS[] = { ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, ASCII_S, '\0' };
static const char KW_IGNORE[] = { ASCII_I, ASCII_G, ASCII_N, ASCII_O, ASCII_R, ASCII_E, '\0' };
static const char KW_IMPLIED[] = { ASCII_I, ASCII_M, ASCII_P, ASCII_L, ASCII_I, ASCII_E, ASCII_D, '\0' };
static const char KW_INCLUDE[] = { ASCII_I, ASCII_N, ASCII_C, ASCII_L, ASCII_U, ASCII_D, ASCII_E, '\0' };
static const char KW_NDATA[] = { ASCII_N, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\0' };
static const char KW_NMTOKEN[] = { ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K, ASCII_E, ASCII_N, '\0' };
static const char KW_NMTOKENS[] = { ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K, ASCII_E, ASCII_N, ASCII_S, '\0' };
static const char KW_NOTATION[] = { ASCII_N, ASCII_O, ASCII_T, ASCII_A, ASCII_T, ASCII_I, ASCII_O, ASCII_N, '\0' };
static const char KW_PCDATA[] = { ASCII_P, ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\0' };
static const char KW_PUBLIC[] = { ASCII_P, ASCII_U, ASCII_B, ASCII_L, ASCII_I, ASCII_C, '\0' };
static const char KW_REQUIRED[] = { ASCII_R, ASCII_E, ASCII_Q, ASCII_U, ASCII_I, ASCII_R, ASCII_E, ASCII_D, '\0' };
static const char KW_SYSTEM[] = { ASCII_S, ASCII_Y, ASCII_S, ASCII_T, ASCII_E, ASCII_M, '\0' };

#ifndef MIN_BYTES_PER_CHAR
#define MIN_BYTES_PER_CHAR(enc) ((enc)->minBytesPerChar)
#endif

#ifdef XML_DTD
#define setTopLevel(state) \
  ((state)->handler = ((state)->documentEntity \
                       ? internalSubset \
                       : externalSubset1))
#else /* not XML_DTD */
#define setTopLevel(state) ((state)->handler = internalSubset)
#endif /* not XML_DTD */

typedef int PROLOG_HANDLER(PROLOG_STATE *state,
			   int tok,
			   const char *ptr,
			   const char *end,
			   const ENCODING *enc);

static PROLOG_HANDLER
  prolog0, prolog1, prolog2,
  doctype0, doctype1, doctype2, doctype3, doctype4, doctype5,
  internalSubset,
  entity0, entity1, entity2, entity3, entity4, entity5, entity6,
  entity7, entity8, entity9,
  notation0, notation1, notation2, notation3, notation4,
  attlist0, attlist1, attlist2, attlist3, attlist4, attlist5, attlist6,
  attlist7, attlist8, attlist9,
  element0, element1, element2, element3, element4, element5, element6,
  element7,
#ifdef XML_DTD
  externalSubset0, externalSubset1,
  condSect0, condSect1, condSect2,
#endif /* XML_DTD */
  declClose,
  error;

static
int common(PROLOG_STATE *state, int tok);

static
int prolog0(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    state->handler = prolog1;
    return XML_ROLE_NONE;
  case XML_TOK_XML_DECL:
    state->handler = prolog1;
    return XML_ROLE_XML_DECL;
  case XML_TOK_PI:
    state->handler = prolog1;
    return XML_ROLE_NONE;
  case XML_TOK_COMMENT:
    state->handler = prolog1;
  case XML_TOK_BOM:
    return XML_ROLE_NONE;
  case XML_TOK_DECL_OPEN:
    if (!XmlNameMatchesAscii(enc,
			     ptr + 2 * MIN_BYTES_PER_CHAR(enc),
			     end,
			     KW_DOCTYPE))
      break;
    state->handler = doctype0;
    return XML_ROLE_NONE;
  case XML_TOK_INSTANCE_START:
    state->handler = error;
    return XML_ROLE_INSTANCE_START;
  }
  return common(state, tok);
}

static
int prolog1(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_PI:
  case XML_TOK_COMMENT:
  case XML_TOK_BOM:
    return XML_ROLE_NONE;
  case XML_TOK_DECL_OPEN:
    if (!XmlNameMatchesAscii(enc,
			     ptr + 2 * MIN_BYTES_PER_CHAR(enc),
			     end,
			     KW_DOCTYPE))
      break;
    state->handler = doctype0;
    return XML_ROLE_NONE;
  case XML_TOK_INSTANCE_START:
    state->handler = error;
    return XML_ROLE_INSTANCE_START;
  }
  return common(state, tok);
}

static
int prolog2(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_PI:
  case XML_TOK_COMMENT:
    return XML_ROLE_NONE;
  case XML_TOK_INSTANCE_START:
    state->handler = error;
    return XML_ROLE_INSTANCE_START;
  }
  return common(state, tok);
}

static
int doctype0(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = doctype1;
    return XML_ROLE_DOCTYPE_NAME;
  }
  return common(state, tok);
}

static
int doctype1(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_OPEN_BRACKET:
    state->handler = internalSubset;
    return XML_ROLE_DOCTYPE_INTERNAL_SUBSET;
  case XML_TOK_DECL_CLOSE:
    state->handler = prolog2;
    return XML_ROLE_DOCTYPE_CLOSE;
  case XML_TOK_NAME:
    if (XmlNameMatchesAscii(enc, ptr, end, KW_SYSTEM)) {
      state->handler = doctype3;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc, ptr, end, KW_PUBLIC)) {
      state->handler = doctype2;
      return XML_ROLE_NONE;
    }
    break;
  }
  return common(state, tok);
}

static
int doctype2(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = doctype3;
    return XML_ROLE_DOCTYPE_PUBLIC_ID;
  }
  return common(state, tok);
}

static
int doctype3(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = doctype4;
    return XML_ROLE_DOCTYPE_SYSTEM_ID;
  }
  return common(state, tok);
}

static
int doctype4(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_OPEN_BRACKET:
    state->handler = internalSubset;
    return XML_ROLE_DOCTYPE_INTERNAL_SUBSET;
  case XML_TOK_DECL_CLOSE:
    state->handler = prolog2;
    return XML_ROLE_DOCTYPE_CLOSE;
  }
  return common(state, tok);
}

static
int doctype5(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_DECL_CLOSE:
    state->handler = prolog2;
    return XML_ROLE_DOCTYPE_CLOSE;
  }
  return common(state, tok);
}

static
int internalSubset(PROLOG_STATE *state,
		   int tok,
		   const char *ptr,
		   const char *end,
		   const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_DECL_OPEN:
    if (XmlNameMatchesAscii(enc,
			    ptr + 2 * MIN_BYTES_PER_CHAR(enc),
			    end,
			    KW_ENTITY)) {
      state->handler = entity0;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc,
			    ptr + 2 * MIN_BYTES_PER_CHAR(enc),
			    end,
			    KW_ATTLIST)) {
      state->handler = attlist0;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc,
			    ptr + 2 * MIN_BYTES_PER_CHAR(enc),
			    end,
			    KW_ELEMENT)) {
      state->handler = element0;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc,
			    ptr + 2 * MIN_BYTES_PER_CHAR(enc),
			    end,
			    KW_NOTATION)) {
      state->handler = notation0;
      return XML_ROLE_NONE;
    }
    break;
  case XML_TOK_PI:
  case XML_TOK_COMMENT:
    return XML_ROLE_NONE;
  case XML_TOK_PARAM_ENTITY_REF:
    return XML_ROLE_PARAM_ENTITY_REF;
  case XML_TOK_CLOSE_BRACKET:
    state->handler = doctype5;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

#ifdef XML_DTD

static
int externalSubset0(PROLOG_STATE *state,
		    int tok,
		    const char *ptr,
		    const char *end,
		    const ENCODING *enc)
{
  state->handler = externalSubset1;
  if (tok == XML_TOK_XML_DECL)
    return XML_ROLE_TEXT_DECL;
  return externalSubset1(state, tok, ptr, end, enc);
}

static
int externalSubset1(PROLOG_STATE *state,
		    int tok,
		    const char *ptr,
		    const char *end,
		    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_COND_SECT_OPEN:
    state->handler = condSect0;
    return XML_ROLE_NONE;
  case XML_TOK_COND_SECT_CLOSE:
    if (state->includeLevel == 0)
      break;
    state->includeLevel -= 1;
    return XML_ROLE_NONE;
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_CLOSE_BRACKET:
    break;
  case XML_TOK_NONE:
    if (state->includeLevel)
      break;
    return XML_ROLE_NONE;
  default:
    return internalSubset(state, tok, ptr, end, enc);
  }
  return common(state, tok);
}

#endif /* XML_DTD */

static
int entity0(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_PERCENT:
    state->handler = entity1;
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    state->handler = entity2;
    return XML_ROLE_GENERAL_ENTITY_NAME;
  }
  return common(state, tok);
}

static
int entity1(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    state->handler = entity7;
    return XML_ROLE_PARAM_ENTITY_NAME;
  }
  return common(state, tok);
}

static
int entity2(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    if (XmlNameMatchesAscii(enc, ptr, end, KW_SYSTEM)) {
      state->handler = entity4;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc, ptr, end, KW_PUBLIC)) {
      state->handler = entity3;
      return XML_ROLE_NONE;
    }
    break;
  case XML_TOK_LITERAL:
    state->handler = declClose;
    return XML_ROLE_ENTITY_VALUE;
  }
  return common(state, tok);
}

static
int entity3(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = entity4;
    return XML_ROLE_ENTITY_PUBLIC_ID;
  }
  return common(state, tok);
}


static
int entity4(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = entity5;
    return XML_ROLE_ENTITY_SYSTEM_ID;
  }
  return common(state, tok);
}

static
int entity5(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_DECL_CLOSE:
    setTopLevel(state);
    return XML_ROLE_ENTITY_COMPLETE;
  case XML_TOK_NAME:
    if (XmlNameMatchesAscii(enc, ptr, end, KW_NDATA)) {
      state->handler = entity6;
      return XML_ROLE_NONE;
    }
    break;
  }
  return common(state, tok);
}

static
int entity6(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    state->handler = declClose;
    return XML_ROLE_ENTITY_NOTATION_NAME;
  }
  return common(state, tok);
}

static
int entity7(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    if (XmlNameMatchesAscii(enc, ptr, end, KW_SYSTEM)) {
      state->handler = entity9;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc, ptr, end, KW_PUBLIC)) {
      state->handler = entity8;
      return XML_ROLE_NONE;
    }
    break;
  case XML_TOK_LITERAL:
    state->handler = declClose;
    return XML_ROLE_ENTITY_VALUE;
  }
  return common(state, tok);
}

static
int entity8(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = entity9;
    return XML_ROLE_ENTITY_PUBLIC_ID;
  }
  return common(state, tok);
}

static
int entity9(PROLOG_STATE *state,
	    int tok,
	    const char *ptr,
	    const char *end,
	    const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = declClose;
    return XML_ROLE_ENTITY_SYSTEM_ID;
  }
  return common(state, tok);
}

static
int notation0(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    state->handler = notation1;
    return XML_ROLE_NOTATION_NAME;
  }
  return common(state, tok);
}

static
int notation1(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    if (XmlNameMatchesAscii(enc, ptr, end, KW_SYSTEM)) {
      state->handler = notation3;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc, ptr, end, KW_PUBLIC)) {
      state->handler = notation2;
      return XML_ROLE_NONE;
    }
    break;
  }
  return common(state, tok);
}

static
int notation2(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = notation4;
    return XML_ROLE_NOTATION_PUBLIC_ID;
  }
  return common(state, tok);
}

static
int notation3(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = declClose;
    return XML_ROLE_NOTATION_SYSTEM_ID;
  }
  return common(state, tok);
}

static
int notation4(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = declClose;
    return XML_ROLE_NOTATION_SYSTEM_ID;
  case XML_TOK_DECL_CLOSE:
    setTopLevel(state);
    return XML_ROLE_NOTATION_NO_SYSTEM_ID;
  }
  return common(state, tok);
}

static
int attlist0(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = attlist1;
    return XML_ROLE_ATTLIST_ELEMENT_NAME;
  }
  return common(state, tok);
}

static
int attlist1(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_DECL_CLOSE:
    setTopLevel(state);
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = attlist2;
    return XML_ROLE_ATTRIBUTE_NAME;
  }
  return common(state, tok);
}

static
int attlist2(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    {
      static const char *types[] = {
	KW_CDATA,
        KW_ID,
        KW_IDREF,
        KW_IDREFS,
        KW_ENTITY,
        KW_ENTITIES,
        KW_NMTOKEN,
        KW_NMTOKENS,
      };
      int i;
      for (i = 0; i < (int)(sizeof(types)/sizeof(types[0])); i++)
	if (XmlNameMatchesAscii(enc, ptr, end, types[i])) {
	  state->handler = attlist8;
	  return XML_ROLE_ATTRIBUTE_TYPE_CDATA + i;
	}
    }
    if (XmlNameMatchesAscii(enc, ptr, end, KW_NOTATION)) {
      state->handler = attlist5;
      return XML_ROLE_NONE;
    }
    break;
  case XML_TOK_OPEN_PAREN:
    state->handler = attlist3;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

static
int attlist3(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NMTOKEN:
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = attlist4;
    return XML_ROLE_ATTRIBUTE_ENUM_VALUE;
  }
  return common(state, tok);
}

static
int attlist4(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_CLOSE_PAREN:
    state->handler = attlist8;
    return XML_ROLE_NONE;
  case XML_TOK_OR:
    state->handler = attlist3;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

static
int attlist5(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_OPEN_PAREN:
    state->handler = attlist6;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}


static
int attlist6(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    state->handler = attlist7;
    return XML_ROLE_ATTRIBUTE_NOTATION_VALUE;
  }
  return common(state, tok);
}

static
int attlist7(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_CLOSE_PAREN:
    state->handler = attlist8;
    return XML_ROLE_NONE;
  case XML_TOK_OR:
    state->handler = attlist6;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

/* default value */
static
int attlist8(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_POUND_NAME:
    if (XmlNameMatchesAscii(enc,
			    ptr + MIN_BYTES_PER_CHAR(enc),
			    end,
			    KW_IMPLIED)) {
      state->handler = attlist1;
      return XML_ROLE_IMPLIED_ATTRIBUTE_VALUE;
    }
    if (XmlNameMatchesAscii(enc,
			    ptr + MIN_BYTES_PER_CHAR(enc),
			    end,
			    KW_REQUIRED)) {
      state->handler = attlist1;
      return XML_ROLE_REQUIRED_ATTRIBUTE_VALUE;
    }
    if (XmlNameMatchesAscii(enc,
			    ptr + MIN_BYTES_PER_CHAR(enc),
			    end,
			    KW_FIXED)) {
      state->handler = attlist9;
      return XML_ROLE_NONE;
    }
    break;
  case XML_TOK_LITERAL:
    state->handler = attlist1;
    return XML_ROLE_DEFAULT_ATTRIBUTE_VALUE;
  }
  return common(state, tok);
}

static
int attlist9(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_LITERAL:
    state->handler = attlist1;
    return XML_ROLE_FIXED_ATTRIBUTE_VALUE;
  }
  return common(state, tok);
}

static
int element0(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = element1;
    return XML_ROLE_ELEMENT_NAME;
  }
  return common(state, tok);
}

static
int element1(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    if (XmlNameMatchesAscii(enc, ptr, end, KW_EMPTY)) {
      state->handler = declClose;
      return XML_ROLE_CONTENT_EMPTY;
    }
    if (XmlNameMatchesAscii(enc, ptr, end, KW_ANY)) {
      state->handler = declClose;
      return XML_ROLE_CONTENT_ANY;
    }
    break;
  case XML_TOK_OPEN_PAREN:
    state->handler = element2;
    state->level = 1;
    return XML_ROLE_GROUP_OPEN;
  }
  return common(state, tok);
}

static
int element2(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_POUND_NAME:
    if (XmlNameMatchesAscii(enc,
			    ptr + MIN_BYTES_PER_CHAR(enc),
			    end,
			    KW_PCDATA)) {
      state->handler = element3;
      return XML_ROLE_CONTENT_PCDATA;
    }
    break;
  case XML_TOK_OPEN_PAREN:
    state->level = 2;
    state->handler = element6;
    return XML_ROLE_GROUP_OPEN;
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT;
  case XML_TOK_NAME_QUESTION:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT_OPT;
  case XML_TOK_NAME_ASTERISK:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT_REP;
  case XML_TOK_NAME_PLUS:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT_PLUS;
  }
  return common(state, tok);
}

static
int element3(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_CLOSE_PAREN:
    state->handler = declClose;
    return XML_ROLE_GROUP_CLOSE;
  case XML_TOK_CLOSE_PAREN_ASTERISK:
    state->handler = declClose;
    return XML_ROLE_GROUP_CLOSE_REP;
  case XML_TOK_OR:
    state->handler = element4;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

static
int element4(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = element5;
    return XML_ROLE_CONTENT_ELEMENT;
  }
  return common(state, tok);
}

static
int element5(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_CLOSE_PAREN_ASTERISK:
    state->handler = declClose;
    return XML_ROLE_GROUP_CLOSE_REP;
  case XML_TOK_OR:
    state->handler = element4;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

static
int element6(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_OPEN_PAREN:
    state->level += 1;
    return XML_ROLE_GROUP_OPEN;
  case XML_TOK_NAME:
  case XML_TOK_PREFIXED_NAME:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT;
  case XML_TOK_NAME_QUESTION:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT_OPT;
  case XML_TOK_NAME_ASTERISK:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT_REP;
  case XML_TOK_NAME_PLUS:
    state->handler = element7;
    return XML_ROLE_CONTENT_ELEMENT_PLUS;
  }
  return common(state, tok);
}

static
int element7(PROLOG_STATE *state,
	     int tok,
	     const char *ptr,
	     const char *end,
	     const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_CLOSE_PAREN:
    state->level -= 1;
    if (state->level == 0)
      state->handler = declClose;
    return XML_ROLE_GROUP_CLOSE;
  case XML_TOK_CLOSE_PAREN_ASTERISK:
    state->level -= 1;
    if (state->level == 0)
      state->handler = declClose;
    return XML_ROLE_GROUP_CLOSE_REP;
  case XML_TOK_CLOSE_PAREN_QUESTION:
    state->level -= 1;
    if (state->level == 0)
      state->handler = declClose;
    return XML_ROLE_GROUP_CLOSE_OPT;
  case XML_TOK_CLOSE_PAREN_PLUS:
    state->level -= 1;
    if (state->level == 0)
      state->handler = declClose;
    return XML_ROLE_GROUP_CLOSE_PLUS;
  case XML_TOK_COMMA:
    state->handler = element6;
    return XML_ROLE_GROUP_SEQUENCE;
  case XML_TOK_OR:
    state->handler = element6;
    return XML_ROLE_GROUP_CHOICE;
  }
  return common(state, tok);
}

#ifdef XML_DTD

static
int condSect0(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_NAME:
    if (XmlNameMatchesAscii(enc, ptr, end, KW_INCLUDE)) {
      state->handler = condSect1;
      return XML_ROLE_NONE;
    }
    if (XmlNameMatchesAscii(enc, ptr, end, KW_IGNORE)) {
      state->handler = condSect2;
      return XML_ROLE_NONE;
    }
    break;
  }
  return common(state, tok);
}

static
int condSect1(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_OPEN_BRACKET:
    state->handler = externalSubset1;
    state->includeLevel += 1;
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

static
int condSect2(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_OPEN_BRACKET:
    state->handler = externalSubset1;
    return XML_ROLE_IGNORE_SECT;
  }
  return common(state, tok);
}

#endif /* XML_DTD */

static
int declClose(PROLOG_STATE *state,
	      int tok,
	      const char *ptr,
	      const char *end,
	      const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_DECL_CLOSE:
    setTopLevel(state);
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}

#if 0

static
int ignore(PROLOG_STATE *state,
	   int tok,
	   const char *ptr,
	   const char *end,
	   const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_DECL_CLOSE:
    state->handler = internalSubset;
    return 0;
  default:
    return XML_ROLE_NONE;
  }
  return common(state, tok);
}
#endif

static
int error(PROLOG_STATE *state,
	  int tok,
	  const char *ptr,
	  const char *end,
	  const ENCODING *enc)
{
  return XML_ROLE_NONE;
}

static
int common(PROLOG_STATE *state, int tok)
{
#ifdef XML_DTD
  if (!state->documentEntity && tok == XML_TOK_PARAM_ENTITY_REF)
    return XML_ROLE_INNER_PARAM_ENTITY_REF;
#endif
  state->handler = error;
  return XML_ROLE_ERROR;
}

void XmlPrologStateInit(PROLOG_STATE *state)
{
  state->handler = prolog0;
#ifdef XML_DTD
  state->documentEntity = 1;
  state->includeLevel = 0;
#endif /* XML_DTD */
}

#ifdef XML_DTD

void XmlPrologStateInitExternalEntity(PROLOG_STATE *state)
{
  state->handler = externalSubset0;
  state->documentEntity = 0;
  state->includeLevel = 0;
}

#endif /* XML_DTD */
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
  = "$Header: /cvs/XF4/xc/extras/expat/lib/xmlrole.c,v 1.2 2003/04/01 22:36:11 matthieu Exp $";
@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 3
a3 2
/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
   See the file COPYING for copying permission.
d6 6
a11 1
/* $XFree86: xc/extras/expat/lib/xmlrole.c,v 1.4 2003/09/29 23:39:30 alanh Exp $ */
d14 1
a14 3
#include "winconfig.h"
#elif defined(MACOS_CLASSIC)
#include "macconfig.h"
d16 1
a16 1
#include <expat_config.h>
a18 1
#include "internal.h"
d29 23
a51 50
static const char KW_ANY[] = {
    ASCII_A, ASCII_N, ASCII_Y, '\0' };
static const char KW_ATTLIST[] = {
    ASCII_A, ASCII_T, ASCII_T, ASCII_L, ASCII_I, ASCII_S, ASCII_T, '\0' };
static const char KW_CDATA[] = {
    ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\0' };
static const char KW_DOCTYPE[] = {
    ASCII_D, ASCII_O, ASCII_C, ASCII_T, ASCII_Y, ASCII_P, ASCII_E, '\0' };
static const char KW_ELEMENT[] = {
    ASCII_E, ASCII_L, ASCII_E, ASCII_M, ASCII_E, ASCII_N, ASCII_T, '\0' };
static const char KW_EMPTY[] = {
    ASCII_E, ASCII_M, ASCII_P, ASCII_T, ASCII_Y, '\0' };
static const char KW_ENTITIES[] = {
    ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T, ASCII_I, ASCII_E, ASCII_S,
    '\0' };
static const char KW_ENTITY[] = {
    ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T, ASCII_Y, '\0' };
static const char KW_FIXED[] = {
    ASCII_F, ASCII_I, ASCII_X, ASCII_E, ASCII_D, '\0' };
static const char KW_ID[] = {
    ASCII_I, ASCII_D, '\0' };
static const char KW_IDREF[] = {
    ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, '\0' };
static const char KW_IDREFS[] = {
    ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, ASCII_S, '\0' };
static const char KW_IGNORE[] = {
    ASCII_I, ASCII_G, ASCII_N, ASCII_O, ASCII_R, ASCII_E, '\0' };
static const char KW_IMPLIED[] = {
    ASCII_I, ASCII_M, ASCII_P, ASCII_L, ASCII_I, ASCII_E, ASCII_D, '\0' };
static const char KW_INCLUDE[] = {
    ASCII_I, ASCII_N, ASCII_C, ASCII_L, ASCII_U, ASCII_D, ASCII_E, '\0' };
static const char KW_NDATA[] = {
    ASCII_N, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\0' };
static const char KW_NMTOKEN[] = {
    ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K, ASCII_E, ASCII_N, '\0' };
static const char KW_NMTOKENS[] = {
    ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K, ASCII_E, ASCII_N, ASCII_S,
    '\0' };
static const char KW_NOTATION[] =
    { ASCII_N, ASCII_O, ASCII_T, ASCII_A, ASCII_T, ASCII_I, ASCII_O, ASCII_N,
      '\0' };
static const char KW_PCDATA[] = {
    ASCII_P, ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\0' };
static const char KW_PUBLIC[] = {
    ASCII_P, ASCII_U, ASCII_B, ASCII_L, ASCII_I, ASCII_C, '\0' };
static const char KW_REQUIRED[] = {
    ASCII_R, ASCII_E, ASCII_Q, ASCII_U, ASCII_I, ASCII_R, ASCII_E, ASCII_D,
    '\0' };
static const char KW_SYSTEM[] = {
    ASCII_S, ASCII_Y, ASCII_S, ASCII_T, ASCII_E, ASCII_M, '\0' };
d66 5
a70 5
typedef int PTRCALL PROLOG_HANDLER(PROLOG_STATE *state,
                                   int tok,
                                   const char *ptr,
                                   const char *end,
                                   const ENCODING *enc);
d77 1
a77 1
  entity7, entity8, entity9, entity10,
d90 2
a91 1
static int FASTCALL common(PROLOG_STATE *state, int tok);
d93 6
a98 6
static int PTRCALL
prolog0(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d109 1
a109 1
    return XML_ROLE_PI;
a111 1
    return XML_ROLE_COMMENT;
d116 3
a118 3
                             ptr + 2 * MIN_BYTES_PER_CHAR(enc),
                             end,
                             KW_DOCTYPE))
d121 1
a121 1
    return XML_ROLE_DOCTYPE_NONE;
d129 6
a134 6
static int PTRCALL
prolog1(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
a139 1
    return XML_ROLE_PI;
a140 1
    return XML_ROLE_COMMENT;
d145 3
a147 3
                             ptr + 2 * MIN_BYTES_PER_CHAR(enc),
                             end,
                             KW_DOCTYPE))
d150 1
a150 1
    return XML_ROLE_DOCTYPE_NONE;
d158 6
a163 6
static int PTRCALL
prolog2(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
a168 1
    return XML_ROLE_PI;
d170 1
a170 1
    return XML_ROLE_COMMENT;
d178 6
a183 6
static int PTRCALL
doctype0(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d187 1
a187 1
    return XML_ROLE_DOCTYPE_NONE;
d196 6
a201 6
static int PTRCALL
doctype1(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d205 1
a205 1
    return XML_ROLE_DOCTYPE_NONE;
d215 1
a215 1
      return XML_ROLE_DOCTYPE_NONE;
d219 1
a219 1
      return XML_ROLE_DOCTYPE_NONE;
d226 6
a231 6
static int PTRCALL
doctype2(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d235 1
a235 1
    return XML_ROLE_DOCTYPE_NONE;
d243 6
a248 6
static int PTRCALL
doctype3(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d252 1
a252 1
    return XML_ROLE_DOCTYPE_NONE;
d260 6
a265 6
static int PTRCALL
doctype4(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d269 1
a269 1
    return XML_ROLE_DOCTYPE_NONE;
d280 6
a285 6
static int PTRCALL
doctype5(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d289 1
a289 1
    return XML_ROLE_DOCTYPE_NONE;
d297 6
a302 6
static int PTRCALL
internalSubset(PROLOG_STATE *state,
               int tok,
               const char *ptr,
               const char *end,
               const ENCODING *enc)
d309 3
a311 3
                            ptr + 2 * MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_ENTITY)) {
d313 1
a313 1
      return XML_ROLE_ENTITY_NONE;
d316 3
a318 3
                            ptr + 2 * MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_ATTLIST)) {
d320 1
a320 1
      return XML_ROLE_ATTLIST_NONE;
d323 3
a325 3
                            ptr + 2 * MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_ELEMENT)) {
d327 1
a327 1
      return XML_ROLE_ELEMENT_NONE;
d330 3
a332 3
                            ptr + 2 * MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_NOTATION)) {
d334 1
a334 1
      return XML_ROLE_NOTATION_NONE;
a337 1
    return XML_ROLE_PI;
d339 1
a339 1
    return XML_ROLE_COMMENT;
d344 1
a344 1
    return XML_ROLE_DOCTYPE_NONE;
d351 6
a356 6
static int PTRCALL
externalSubset0(PROLOG_STATE *state,
                int tok,
                const char *ptr,
                const char *end,
                const ENCODING *enc)
d364 6
a369 6
static int PTRCALL
externalSubset1(PROLOG_STATE *state,
                int tok,
                const char *ptr,
                const char *end,
                const ENCODING *enc)
d396 6
a401 6
static int PTRCALL
entity0(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d405 1
a405 1
    return XML_ROLE_ENTITY_NONE;
d408 1
a408 1
    return XML_ROLE_ENTITY_NONE;
d416 6
a421 6
static int PTRCALL
entity1(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d425 1
a425 1
    return XML_ROLE_ENTITY_NONE;
d433 6
a438 6
static int PTRCALL
entity2(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d442 1
a442 1
    return XML_ROLE_ENTITY_NONE;
d446 1
a446 1
      return XML_ROLE_ENTITY_NONE;
d450 1
a450 1
      return XML_ROLE_ENTITY_NONE;
a454 1
    state->role_none = XML_ROLE_ENTITY_NONE;
d460 6
a465 6
static int PTRCALL
entity3(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d469 1
a469 1
    return XML_ROLE_ENTITY_NONE;
d477 7
a483 6
static int PTRCALL
entity4(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d487 1
a487 1
    return XML_ROLE_ENTITY_NONE;
d495 6
a500 6
static int PTRCALL
entity5(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d504 1
a504 1
    return XML_ROLE_ENTITY_NONE;
d511 1
a511 1
      return XML_ROLE_ENTITY_NONE;
d518 6
a523 6
static int PTRCALL
entity6(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d527 1
a527 1
    return XML_ROLE_ENTITY_NONE;
a529 1
    state->role_none = XML_ROLE_ENTITY_NONE;
d535 6
a540 6
static int PTRCALL
entity7(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d544 1
a544 1
    return XML_ROLE_ENTITY_NONE;
d548 1
a548 1
      return XML_ROLE_ENTITY_NONE;
d552 1
a552 1
      return XML_ROLE_ENTITY_NONE;
a556 1
    state->role_none = XML_ROLE_ENTITY_NONE;
d562 6
a567 6
static int PTRCALL
entity8(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d571 1
a571 1
    return XML_ROLE_ENTITY_NONE;
d579 6
a584 6
static int PTRCALL
entity9(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d588 1
a588 1
    return XML_ROLE_ENTITY_NONE;
d590 1
a590 1
    state->handler = entity10;
d596 6
a601 6
static int PTRCALL
entity10(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d605 1
a605 18
    return XML_ROLE_ENTITY_NONE;
  case XML_TOK_DECL_CLOSE:
    setTopLevel(state);
    return XML_ROLE_ENTITY_COMPLETE;
  }
  return common(state, tok);
}

static int PTRCALL
notation0(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NOTATION_NONE;
d613 6
a618 6
static int PTRCALL
notation1(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d622 1
a622 1
    return XML_ROLE_NOTATION_NONE;
d626 1
a626 1
      return XML_ROLE_NOTATION_NONE;
d630 1
a630 1
      return XML_ROLE_NOTATION_NONE;
d637 6
a642 6
static int PTRCALL
notation2(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d646 1
a646 1
    return XML_ROLE_NOTATION_NONE;
d654 6
a659 6
static int PTRCALL
notation3(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d663 1
a663 1
    return XML_ROLE_NOTATION_NONE;
a665 1
    state->role_none = XML_ROLE_NOTATION_NONE;
d671 6
a676 6
static int PTRCALL
notation4(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d680 1
a680 1
    return XML_ROLE_NOTATION_NONE;
a682 1
    state->role_none = XML_ROLE_NOTATION_NONE;
d691 6
a696 6
static int PTRCALL
attlist0(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d700 1
a700 1
    return XML_ROLE_ATTLIST_NONE;
d709 6
a714 6
static int PTRCALL
attlist1(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d718 1
a718 1
    return XML_ROLE_ATTLIST_NONE;
d721 1
a721 1
    return XML_ROLE_ATTLIST_NONE;
d730 6
a735 6
static int PTRCALL
attlist2(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d739 1
a739 1
    return XML_ROLE_ATTLIST_NONE;
d743 1
a743 1
        KW_CDATA,
d754 4
a757 4
        if (XmlNameMatchesAscii(enc, ptr, end, types[i])) {
          state->handler = attlist8;
          return XML_ROLE_ATTRIBUTE_TYPE_CDATA + i;
        }
d761 1
a761 1
      return XML_ROLE_ATTLIST_NONE;
d766 1
a766 1
    return XML_ROLE_ATTLIST_NONE;
d771 6
a776 6
static int PTRCALL
attlist3(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d780 1
a780 1
    return XML_ROLE_ATTLIST_NONE;
d790 6
a795 6
static int PTRCALL
attlist4(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d799 1
a799 1
    return XML_ROLE_ATTLIST_NONE;
d802 1
a802 1
    return XML_ROLE_ATTLIST_NONE;
d805 1
a805 1
    return XML_ROLE_ATTLIST_NONE;
d810 6
a815 6
static int PTRCALL
attlist5(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d819 1
a819 1
    return XML_ROLE_ATTLIST_NONE;
d822 1
a822 1
    return XML_ROLE_ATTLIST_NONE;
d827 7
a833 6
static int PTRCALL
attlist6(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d837 1
a837 1
    return XML_ROLE_ATTLIST_NONE;
d845 6
a850 6
static int PTRCALL
attlist7(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d854 1
a854 1
    return XML_ROLE_ATTLIST_NONE;
d857 1
a857 1
    return XML_ROLE_ATTLIST_NONE;
d860 1
a860 1
    return XML_ROLE_ATTLIST_NONE;
d866 6
a871 6
static int PTRCALL
attlist8(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d875 1
a875 1
    return XML_ROLE_ATTLIST_NONE;
d878 3
a880 3
                            ptr + MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_IMPLIED)) {
d885 3
a887 3
                            ptr + MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_REQUIRED)) {
d892 3
a894 3
                            ptr + MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_FIXED)) {
d896 1
a896 1
      return XML_ROLE_ATTLIST_NONE;
d906 6
a911 6
static int PTRCALL
attlist9(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d915 1
a915 1
    return XML_ROLE_ATTLIST_NONE;
d923 6
a928 6
static int PTRCALL
element0(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d932 1
a932 1
    return XML_ROLE_ELEMENT_NONE;
d941 6
a946 6
static int PTRCALL
element1(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d950 1
a950 1
    return XML_ROLE_ELEMENT_NONE;
a953 1
      state->role_none = XML_ROLE_ELEMENT_NONE;
a957 1
      state->role_none = XML_ROLE_ELEMENT_NONE;
d969 6
a974 6
static int PTRCALL
element2(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d978 1
a978 1
    return XML_ROLE_ELEMENT_NONE;
d981 3
a983 3
                            ptr + MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_PCDATA)) {
d1009 6
a1014 6
static int PTRCALL
element3(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d1018 1
a1018 1
    return XML_ROLE_ELEMENT_NONE;
a1020 1
    state->role_none = XML_ROLE_ELEMENT_NONE;
a1023 1
    state->role_none = XML_ROLE_ELEMENT_NONE;
d1027 1
a1027 1
    return XML_ROLE_ELEMENT_NONE;
d1032 6
a1037 6
static int PTRCALL
element4(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d1041 1
a1041 1
    return XML_ROLE_ELEMENT_NONE;
d1050 6
a1055 6
static int PTRCALL
element5(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d1059 1
a1059 1
    return XML_ROLE_ELEMENT_NONE;
a1061 1
    state->role_none = XML_ROLE_ELEMENT_NONE;
d1065 1
a1065 1
    return XML_ROLE_ELEMENT_NONE;
d1070 6
a1075 6
static int PTRCALL
element6(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d1079 1
a1079 1
    return XML_ROLE_ELEMENT_NONE;
d1100 6
a1105 6
static int PTRCALL
element7(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d1109 1
a1109 1
    return XML_ROLE_ELEMENT_NONE;
d1112 1
a1112 1
    if (state->level == 0) {
a1113 2
      state->role_none = XML_ROLE_ELEMENT_NONE;
    }
d1117 1
a1117 1
    if (state->level == 0) {
a1118 2
      state->role_none = XML_ROLE_ELEMENT_NONE;
    }
d1122 1
a1122 1
    if (state->level == 0) {
a1123 2
      state->role_none = XML_ROLE_ELEMENT_NONE;
    }
d1127 1
a1127 1
    if (state->level == 0) {
a1128 2
      state->role_none = XML_ROLE_ELEMENT_NONE;
    }
d1142 6
a1147 6
static int PTRCALL
condSect0(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d1166 6
a1171 6
static int PTRCALL
condSect1(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d1184 6
a1189 6
static int PTRCALL
condSect2(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d1203 6
a1208 6
static int PTRCALL
declClose(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d1212 1
a1212 1
    return state->role_none;
d1215 1
a1215 1
    return state->role_none;
d1220 26
a1245 6
static int PTRCALL
error(PROLOG_STATE *state,
      int tok,
      const char *ptr,
      const char *end,
      const ENCODING *enc)
d1250 2
a1251 2
static int FASTCALL
common(PROLOG_STATE *state, int tok)
d1261 1
a1261 2
void
XmlPrologStateInit(PROLOG_STATE *state)
a1266 1
  state->inEntityValue = 0;
d1272 1
a1272 2
void
XmlPrologStateInitExternalEntity(PROLOG_STATE *state)
@


1.1.1.1
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@@


1.1.1.2
log
@Import OpenBSD tree again due to CVS bugs
@
text
@d1 3
a3 2
/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd
   See the file COPYING for copying permission.
d6 6
a11 1
/* $XFree86: xc/extras/expat/lib/xmlrole.c,v 1.3 2003/04/10 20:05:16 herrb Exp $ */
d14 1
a14 3
#include "winconfig.h"
#elif defined(MACOS_CLASSIC)
#include "macconfig.h"
d16 1
a16 1
#include <expat_config.h>
d67 4
a70 4
                           int tok,
                           const char *ptr,
                           const char *end,
                           const ENCODING *enc);
d77 1
a77 1
  entity7, entity8, entity9, entity10,
d90 2
a91 1
static int common(PROLOG_STATE *state, int tok);
d93 6
a98 6
static int
prolog0(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d116 3
a118 3
                             ptr + 2 * MIN_BYTES_PER_CHAR(enc),
                             end,
                             KW_DOCTYPE))
d129 6
a134 6
static int
prolog1(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d145 3
a147 3
                             ptr + 2 * MIN_BYTES_PER_CHAR(enc),
                             end,
                             KW_DOCTYPE))
d158 6
a163 6
static int
prolog2(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d178 6
a183 6
static int
doctype0(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d196 6
a201 6
static int
doctype1(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d226 6
a231 6
static int
doctype2(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d243 6
a248 6
static int
doctype3(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d260 6
a265 6
static int
doctype4(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d280 6
a285 6
static int
doctype5(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d297 6
a302 6
static int
internalSubset(PROLOG_STATE *state,
               int tok,
               const char *ptr,
               const char *end,
               const ENCODING *enc)
d309 3
a311 3
                            ptr + 2 * MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_ENTITY)) {
d316 3
a318 3
                            ptr + 2 * MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_ATTLIST)) {
d323 3
a325 3
                            ptr + 2 * MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_ELEMENT)) {
d330 3
a332 3
                            ptr + 2 * MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_NOTATION)) {
d351 6
a356 6
static int
externalSubset0(PROLOG_STATE *state,
                int tok,
                const char *ptr,
                const char *end,
                const ENCODING *enc)
d364 6
a369 6
static int
externalSubset1(PROLOG_STATE *state,
                int tok,
                const char *ptr,
                const char *end,
                const ENCODING *enc)
d396 6
a401 6
static int
entity0(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d416 6
a421 6
static int
entity1(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d433 6
a438 6
static int
entity2(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d460 6
a465 6
static int
entity3(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d477 7
a483 6
static int
entity4(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d495 6
a500 6
static int
entity5(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d518 6
a523 6
static int
entity6(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d535 6
a540 6
static int
entity7(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d562 6
a567 6
static int
entity8(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d579 6
a584 6
static int
entity9(PROLOG_STATE *state,
        int tok,
        const char *ptr,
        const char *end,
        const ENCODING *enc)
d590 1
a590 1
    state->handler = entity10;
d596 6
a601 23
static int
entity10(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
{
  switch (tok) {
  case XML_TOK_PROLOG_S:
    return XML_ROLE_NONE;
  case XML_TOK_DECL_CLOSE:
    setTopLevel(state);
    return XML_ROLE_ENTITY_COMPLETE;
  }
  return common(state, tok);
}

static int
notation0(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d613 6
a618 6
static int
notation1(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d637 6
a642 6
static int
notation2(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d654 6
a659 6
static int
notation3(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d671 6
a676 6
static int
notation4(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d691 6
a696 6
static int
attlist0(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d709 6
a714 6
static int
attlist1(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d730 6
a735 6
static int
attlist2(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d743 1
a743 1
        KW_CDATA,
d754 4
a757 4
        if (XmlNameMatchesAscii(enc, ptr, end, types[i])) {
          state->handler = attlist8;
          return XML_ROLE_ATTRIBUTE_TYPE_CDATA + i;
        }
d771 6
a776 6
static int
attlist3(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d790 6
a795 6
static int
attlist4(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d810 6
a815 6
static int
attlist5(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d828 6
a833 6
static int
attlist6(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d845 6
a850 6
static int
attlist7(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d866 6
a871 6
static int
attlist8(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d878 3
a880 3
                            ptr + MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_IMPLIED)) {
d885 3
a887 3
                            ptr + MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_REQUIRED)) {
d892 3
a894 3
                            ptr + MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_FIXED)) {
d906 6
a911 6
static int
attlist9(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d923 6
a928 6
static int
element0(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d941 6
a946 6
static int
element1(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d969 6
a974 6
static int
element2(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d981 3
a983 3
                            ptr + MIN_BYTES_PER_CHAR(enc),
                            end,
                            KW_PCDATA)) {
d1009 6
a1014 6
static int
element3(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d1032 6
a1037 6
static int
element4(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d1050 6
a1055 6
static int
element5(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d1070 6
a1075 6
static int
element6(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d1100 6
a1105 6
static int
element7(PROLOG_STATE *state,
         int tok,
         const char *ptr,
         const char *end,
         const ENCODING *enc)
d1142 6
a1147 6
static int
condSect0(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d1166 6
a1171 6
static int
condSect1(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d1184 6
a1189 6
static int
condSect2(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d1203 6
a1208 6
static int
declClose(PROLOG_STATE *state,
          int tok,
          const char *ptr,
          const char *end,
          const ENCODING *enc)
d1220 26
a1245 6
static int
error(PROLOG_STATE *state,
      int tok,
      const char *ptr,
      const char *end,
      const ENCODING *enc)
d1250 2
a1251 2
static int
common(PROLOG_STATE *state, int tok)
d1261 1
a1261 2
void
XmlPrologStateInit(PROLOG_STATE *state)
a1266 1
  state->inEntityValue = 0;
d1272 1
a1272 2
void
XmlPrologStateInitExternalEntity(PROLOG_STATE *state)
@


1.1.1.3
log
@sync with OpenBSD's idea of X-Window as of now();
@
text
@d5 1
a5 1
/* $XFree86: xc/extras/expat/lib/xmlrole.c,v 1.4 2003/09/29 23:39:30 alanh Exp $ */
a14 1
#include "internal.h"
d25 23
a47 50
static const char KW_ANY[] = {
    ASCII_A, ASCII_N, ASCII_Y, '\0' };
static const char KW_ATTLIST[] = {
    ASCII_A, ASCII_T, ASCII_T, ASCII_L, ASCII_I, ASCII_S, ASCII_T, '\0' };
static const char KW_CDATA[] = {
    ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\0' };
static const char KW_DOCTYPE[] = {
    ASCII_D, ASCII_O, ASCII_C, ASCII_T, ASCII_Y, ASCII_P, ASCII_E, '\0' };
static const char KW_ELEMENT[] = {
    ASCII_E, ASCII_L, ASCII_E, ASCII_M, ASCII_E, ASCII_N, ASCII_T, '\0' };
static const char KW_EMPTY[] = {
    ASCII_E, ASCII_M, ASCII_P, ASCII_T, ASCII_Y, '\0' };
static const char KW_ENTITIES[] = {
    ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T, ASCII_I, ASCII_E, ASCII_S,
    '\0' };
static const char KW_ENTITY[] = {
    ASCII_E, ASCII_N, ASCII_T, ASCII_I, ASCII_T, ASCII_Y, '\0' };
static const char KW_FIXED[] = {
    ASCII_F, ASCII_I, ASCII_X, ASCII_E, ASCII_D, '\0' };
static const char KW_ID[] = {
    ASCII_I, ASCII_D, '\0' };
static const char KW_IDREF[] = {
    ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, '\0' };
static const char KW_IDREFS[] = {
    ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, ASCII_S, '\0' };
static const char KW_IGNORE[] = {
    ASCII_I, ASCII_G, ASCII_N, ASCII_O, ASCII_R, ASCII_E, '\0' };
static const char KW_IMPLIED[] = {
    ASCII_I, ASCII_M, ASCII_P, ASCII_L, ASCII_I, ASCII_E, ASCII_D, '\0' };
static const char KW_INCLUDE[] = {
    ASCII_I, ASCII_N, ASCII_C, ASCII_L, ASCII_U, ASCII_D, ASCII_E, '\0' };
static const char KW_NDATA[] = {
    ASCII_N, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\0' };
static const char KW_NMTOKEN[] = {
    ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K, ASCII_E, ASCII_N, '\0' };
static const char KW_NMTOKENS[] = {
    ASCII_N, ASCII_M, ASCII_T, ASCII_O, ASCII_K, ASCII_E, ASCII_N, ASCII_S,
    '\0' };
static const char KW_NOTATION[] =
    { ASCII_N, ASCII_O, ASCII_T, ASCII_A, ASCII_T, ASCII_I, ASCII_O, ASCII_N,
      '\0' };
static const char KW_PCDATA[] = {
    ASCII_P, ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\0' };
static const char KW_PUBLIC[] = {
    ASCII_P, ASCII_U, ASCII_B, ASCII_L, ASCII_I, ASCII_C, '\0' };
static const char KW_REQUIRED[] = {
    ASCII_R, ASCII_E, ASCII_Q, ASCII_U, ASCII_I, ASCII_R, ASCII_E, ASCII_D,
    '\0' };
static const char KW_SYSTEM[] = {
    ASCII_S, ASCII_Y, ASCII_S, ASCII_T, ASCII_E, ASCII_M, '\0' };
d62 5
a66 5
typedef int PTRCALL PROLOG_HANDLER(PROLOG_STATE *state,
                                   int tok,
                                   const char *ptr,
                                   const char *end,
                                   const ENCODING *enc);
d86 1
a86 1
static int FASTCALL common(PROLOG_STATE *state, int tok);
d88 1
a88 1
static int PTRCALL
d104 1
a104 1
    return XML_ROLE_PI;
a106 1
    return XML_ROLE_COMMENT;
d116 1
a116 1
    return XML_ROLE_DOCTYPE_NONE;
d124 1
a124 1
static int PTRCALL
a134 1
    return XML_ROLE_PI;
a135 1
    return XML_ROLE_COMMENT;
d145 1
a145 1
    return XML_ROLE_DOCTYPE_NONE;
d153 1
a153 1
static int PTRCALL
a163 1
    return XML_ROLE_PI;
d165 1
a165 1
    return XML_ROLE_COMMENT;
d173 1
a173 1
static int PTRCALL
d182 1
a182 1
    return XML_ROLE_DOCTYPE_NONE;
d191 1
a191 1
static int PTRCALL
d200 1
a200 1
    return XML_ROLE_DOCTYPE_NONE;
d210 1
a210 1
      return XML_ROLE_DOCTYPE_NONE;
d214 1
a214 1
      return XML_ROLE_DOCTYPE_NONE;
d221 1
a221 1
static int PTRCALL
d230 1
a230 1
    return XML_ROLE_DOCTYPE_NONE;
d238 1
a238 1
static int PTRCALL
d247 1
a247 1
    return XML_ROLE_DOCTYPE_NONE;
d255 1
a255 1
static int PTRCALL
d264 1
a264 1
    return XML_ROLE_DOCTYPE_NONE;
d275 1
a275 1
static int PTRCALL
d284 1
a284 1
    return XML_ROLE_DOCTYPE_NONE;
d292 1
a292 1
static int PTRCALL
d308 1
a308 1
      return XML_ROLE_ENTITY_NONE;
d315 1
a315 1
      return XML_ROLE_ATTLIST_NONE;
d322 1
a322 1
      return XML_ROLE_ELEMENT_NONE;
d329 1
a329 1
      return XML_ROLE_NOTATION_NONE;
a332 1
    return XML_ROLE_PI;
d334 1
a334 1
    return XML_ROLE_COMMENT;
d339 1
a339 1
    return XML_ROLE_DOCTYPE_NONE;
d346 1
a346 1
static int PTRCALL
d359 1
a359 1
static int PTRCALL
d391 1
a391 1
static int PTRCALL
d400 1
a400 1
    return XML_ROLE_ENTITY_NONE;
d403 1
a403 1
    return XML_ROLE_ENTITY_NONE;
d411 1
a411 1
static int PTRCALL
d420 1
a420 1
    return XML_ROLE_ENTITY_NONE;
d428 1
a428 1
static int PTRCALL
d437 1
a437 1
    return XML_ROLE_ENTITY_NONE;
d441 1
a441 1
      return XML_ROLE_ENTITY_NONE;
d445 1
a445 1
      return XML_ROLE_ENTITY_NONE;
a449 1
    state->role_none = XML_ROLE_ENTITY_NONE;
d455 1
a455 1
static int PTRCALL
d464 1
a464 1
    return XML_ROLE_ENTITY_NONE;
d472 1
a472 1
static int PTRCALL
d481 1
a481 1
    return XML_ROLE_ENTITY_NONE;
d489 1
a489 1
static int PTRCALL
d498 1
a498 1
    return XML_ROLE_ENTITY_NONE;
d505 1
a505 1
      return XML_ROLE_ENTITY_NONE;
d512 1
a512 1
static int PTRCALL
d521 1
a521 1
    return XML_ROLE_ENTITY_NONE;
a523 1
    state->role_none = XML_ROLE_ENTITY_NONE;
d529 1
a529 1
static int PTRCALL
d538 1
a538 1
    return XML_ROLE_ENTITY_NONE;
d542 1
a542 1
      return XML_ROLE_ENTITY_NONE;
d546 1
a546 1
      return XML_ROLE_ENTITY_NONE;
a550 1
    state->role_none = XML_ROLE_ENTITY_NONE;
d556 1
a556 1
static int PTRCALL
d565 1
a565 1
    return XML_ROLE_ENTITY_NONE;
d573 1
a573 1
static int PTRCALL
d582 1
a582 1
    return XML_ROLE_ENTITY_NONE;
d590 1
a590 1
static int PTRCALL
d599 1
a599 1
    return XML_ROLE_ENTITY_NONE;
d607 1
a607 1
static int PTRCALL
d616 1
a616 1
    return XML_ROLE_NOTATION_NONE;
d624 1
a624 1
static int PTRCALL
d633 1
a633 1
    return XML_ROLE_NOTATION_NONE;
d637 1
a637 1
      return XML_ROLE_NOTATION_NONE;
d641 1
a641 1
      return XML_ROLE_NOTATION_NONE;
d648 1
a648 1
static int PTRCALL
d657 1
a657 1
    return XML_ROLE_NOTATION_NONE;
d665 1
a665 1
static int PTRCALL
d674 1
a674 1
    return XML_ROLE_NOTATION_NONE;
a676 1
    state->role_none = XML_ROLE_NOTATION_NONE;
d682 1
a682 1
static int PTRCALL
d691 1
a691 1
    return XML_ROLE_NOTATION_NONE;
a693 1
    state->role_none = XML_ROLE_NOTATION_NONE;
d702 1
a702 1
static int PTRCALL
d711 1
a711 1
    return XML_ROLE_ATTLIST_NONE;
d720 1
a720 1
static int PTRCALL
d729 1
a729 1
    return XML_ROLE_ATTLIST_NONE;
d732 1
a732 1
    return XML_ROLE_ATTLIST_NONE;
d741 1
a741 1
static int PTRCALL
d750 1
a750 1
    return XML_ROLE_ATTLIST_NONE;
d772 1
a772 1
      return XML_ROLE_ATTLIST_NONE;
d777 1
a777 1
    return XML_ROLE_ATTLIST_NONE;
d782 1
a782 1
static int PTRCALL
d791 1
a791 1
    return XML_ROLE_ATTLIST_NONE;
d801 1
a801 1
static int PTRCALL
d810 1
a810 1
    return XML_ROLE_ATTLIST_NONE;
d813 1
a813 1
    return XML_ROLE_ATTLIST_NONE;
d816 1
a816 1
    return XML_ROLE_ATTLIST_NONE;
d821 1
a821 1
static int PTRCALL
d830 1
a830 1
    return XML_ROLE_ATTLIST_NONE;
d833 1
a833 1
    return XML_ROLE_ATTLIST_NONE;
d838 2
a839 1
static int PTRCALL
d848 1
a848 1
    return XML_ROLE_ATTLIST_NONE;
d856 1
a856 1
static int PTRCALL
d865 1
a865 1
    return XML_ROLE_ATTLIST_NONE;
d868 1
a868 1
    return XML_ROLE_ATTLIST_NONE;
d871 1
a871 1
    return XML_ROLE_ATTLIST_NONE;
d877 1
a877 1
static int PTRCALL
d886 1
a886 1
    return XML_ROLE_ATTLIST_NONE;
d907 1
a907 1
      return XML_ROLE_ATTLIST_NONE;
d917 1
a917 1
static int PTRCALL
d926 1
a926 1
    return XML_ROLE_ATTLIST_NONE;
d934 1
a934 1
static int PTRCALL
d943 1
a943 1
    return XML_ROLE_ELEMENT_NONE;
d952 1
a952 1
static int PTRCALL
d961 1
a961 1
    return XML_ROLE_ELEMENT_NONE;
a964 1
      state->role_none = XML_ROLE_ELEMENT_NONE;
a968 1
      state->role_none = XML_ROLE_ELEMENT_NONE;
d980 1
a980 1
static int PTRCALL
d989 1
a989 1
    return XML_ROLE_ELEMENT_NONE;
d1020 1
a1020 1
static int PTRCALL
d1029 1
a1029 1
    return XML_ROLE_ELEMENT_NONE;
a1031 1
    state->role_none = XML_ROLE_ELEMENT_NONE;
a1034 1
    state->role_none = XML_ROLE_ELEMENT_NONE;
d1038 1
a1038 1
    return XML_ROLE_ELEMENT_NONE;
d1043 1
a1043 1
static int PTRCALL
d1052 1
a1052 1
    return XML_ROLE_ELEMENT_NONE;
d1061 1
a1061 1
static int PTRCALL
d1070 1
a1070 1
    return XML_ROLE_ELEMENT_NONE;
a1072 1
    state->role_none = XML_ROLE_ELEMENT_NONE;
d1076 1
a1076 1
    return XML_ROLE_ELEMENT_NONE;
d1081 1
a1081 1
static int PTRCALL
d1090 1
a1090 1
    return XML_ROLE_ELEMENT_NONE;
d1111 1
a1111 1
static int PTRCALL
d1120 1
a1120 1
    return XML_ROLE_ELEMENT_NONE;
d1123 1
a1123 1
    if (state->level == 0) {
a1124 2
      state->role_none = XML_ROLE_ELEMENT_NONE;
    }
d1128 1
a1128 1
    if (state->level == 0) {
a1129 2
      state->role_none = XML_ROLE_ELEMENT_NONE;
    }
d1133 1
a1133 1
    if (state->level == 0) {
a1134 2
      state->role_none = XML_ROLE_ELEMENT_NONE;
    }
d1138 1
a1138 1
    if (state->level == 0) {
a1139 2
      state->role_none = XML_ROLE_ELEMENT_NONE;
    }
d1153 1
a1153 1
static int PTRCALL
d1177 1
a1177 1
static int PTRCALL
d1195 1
a1195 1
static int PTRCALL
d1214 1
a1214 1
static int PTRCALL
d1223 1
a1223 1
    return state->role_none;
d1226 1
a1226 1
    return state->role_none;
d1231 1
a1231 1
static int PTRCALL
d1241 1
a1241 1
static int FASTCALL
@


