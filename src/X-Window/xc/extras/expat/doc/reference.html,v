head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.3
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.3
	MIRBSD_7_ALPHA:1.1.1.3.0.4
	MIRBSD_7:1.1.1.3.0.2
	MIRBSD_7ter:1.1.1.3
	cvs-20011091815:1.1.1.3
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2003.05.16.16.29.21;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.04.08.18.20.29;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.04.08.18.20.29;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.13.15.15.15;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.11.09.18.33.35;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.05.47;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>

<!-- Copyright 1999,2000 Clark Cooper <coopercc@@netheaven.com>
     All rights reserved.
     This is free software. You may distribute or modify according to
     the terms of the MIT/X License -->
  <title>Expat XML Parser</title>
  <meta name="author" content="Clark Cooper, coopercc@@netheaven.com">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <link href="style.css" rel="stylesheet" type="text/css">
</head>
<body>
<h1>Expat XML Parser</h1>

<p>Expat is a library, written in C, for parsing XML documents. It's the
underlying XML parser for the open source Mozilla project, perl's
XML::Parser, and other open-source XML parsers.</p>

<p>This library is the creation of James Clark, who's also given us
groff (an nroff look-alike), Jade (an implemention of ISO's DSSSL stylesheet
language for SGML), XP (a Java XML parser package), XT (a Java XSL engine).
James was also the technical lead on the XML Working Group at W3 that produced
the XML specification.</p>

<p>This is free software, licensed under the
<a href="../COPYING">MIT/X Consortium license</a>. You may download it from
<a href="http://expat.sourceforge.net">the expat homepage on Source Forge</a>.
</p>

<p>The bulk of this document was originally commissioned as an article by
<a href="http://www.xml.com/">XML.com</a>. They graciously allowed me to retain
copyright and to distribute it with expat.

<hr>
<h2>Table of Contents</h2>
<ul>
  <li><a href="#overview">Overview</a></li>
  <li><a href="#building">Building and Installing</a></li>
  <li><a href="#using">Using expat</a></li>
  <li><a href="#examples">Some examples</a></li>
  <li><a href="#reference">Reference</a>
      <ul>
          <li><a href="#creation">Parser Creation Functions</a>
              <ul>
                  <li><a href="#XML_ParserCreate">XML_ParserCreate</a></li>
		  <li><a href="#XML_ParserCreateNS">XML_ParserCreateNS</a></li>
		  <li><a href="#XML_ParserCreate_MM">XML_ParserCreate_MM</a></li>
		  <li><a href="#XML_ExternalEntityParserCreate">XML_ExternalEntityParserCreate</a></li>
		  <li><a href="#XML_ParserFree">XML_ParserFree</a></li>
              </ul>
          </li>
	  <li><a href="#parsing">Parsing Functions</a>
	      <ul>
	          <li><a href="#XML_Parse">XML_Parse</a></li>
		  <li><a href="#XML_ParseBuffer">XML_ParseBuffer</a></li>
		  <li><a href="#XML_GetBuffer">XML_GetBuffer</a></li>
              </ul>
	  </li>
	  <li><a href="#setting">Handler Setting Functions</a>
	      <ul>
	          <li><a href="#XML_SetStartElementHandler">XML_SetStartElementHandler</a></li>
		  <li><a href="#XML_SetEndElementHandler">XML_SetEndElementHandler</a></li>
	          <li><a href="#XML_SetElementHandler">XML_SetElementHandler</a></li>
		  <li><a href="#XML_SetCharacterDataHandler">XML_SetCharacterDataHandler</a></li>
		  <li><a href="#XML_SetProcessingInstructionHandler">XML_SetProcessingInstructionHandler</a></li>
		  <li><a href="#XML_SetCommentHandler">XML_SetCommentHandler</a></li>
		  <li><a href="#XML_SetStartCdataSectionHandler">XML_SetStartCdataSectionHandler</a></li>
		  <li><a href="#XML_SetEndCdataSectionHandler">XML_SetEndCdataSectionHandler</a></li>
		  <li><a href="#XML_SetCdataSectionHandler">XML_SetCdataSectionHandler</a></li>
		  <li><a href="#XML_SetDefaultHandler">XML_SetDefaultHandler</a></li>
		  <li><a href="#XML_SetDefaultHandlerExpand">XML_SetDefaultHandlerExpand</a></li>
		  <li><a href="#XML_SetExternalEntityRefHandler">XML_SetExternalEntityRefHandler</a></li>
		  <li><a href="#XML_SetUnknownEncodingHandler">XML_SetUnknownEncodingHandler</a></li>
		  <li><a href="#XML_SetStartNamespaceDeclHandler">XML_SetStartNamespaceDeclHandler</a></li>
		  <li><a href="#XML_SetEndNamespaceDeclHandler">XML_SetEndNamespaceDeclHandler</a></li>
		  <li><a href="#XML_SetNamespaceDeclHandler">XML_SetNamespaceDeclHandler</a></li>
		  <li><a href="#XML_SetXmlDeclHandler">XML_SetXmlDeclHandler</a></li>		  
		  <li><a href="#XML_SetStartDoctypeDeclHandler">XML_SetStartDoctypeDeclHandler</a></li>
		  <li><a href="#XML_SetEndDoctypeDeclHandler">XML_SetEndDoctypeDeclHandler</a></li>
		  <li><a href="#XML_SetDoctypeDeclHandler">XML_SetDoctypeDeclHandler</a></li>
		  <li><a href="#XML_SetElementDeclHandler">XML_SetElementDeclHandler</a></li>
		  <li><a href="#XML_SetAttlistDeclHandler">XML_SetAttlistDeclHandler</a></li>
		  <li><a href="#XML_SetEntityDeclHandler">XML_SetEntityDeclHandler</a></li>
		  <li><a href="#XML_SetUnparsedEntityDeclHandler">XML_SetUnparsedEntityDeclHandler</a></li>
		  <li><a href="#XML_SetNotationDeclHandler">XML_SetNotationDeclHandler</a></li>
		  <li><a href="#XML_SetNotStandaloneHandler">XML_SetNotStandaloneHandler</a></li>
	      </ul>
	  </li>
	  <li><a href="#position">Parse Position and Error Reporting Functions</a>
	      <ul>
	          <li><a href="#XML_GetErrorCode">XML_GetErrorCode</a></li>
		  <li><a href="#XML_ErrorString">XML_ErrorString</a></li>
		  <li><a href="#XML_GetCurrentByteIndex">XML_GetCurrentByteIndex</a></li>
		  <li><a href="#XML_GetCurrentLineNumber">XML_GetCurrentLineNumber</a></li>
		  <li><a href="#XML_GetCurrentColumnNumber">XML_GetCurrentColumnNumber</a></li>
		  <li><a href="#XML_GetCurrentByteCount">XML_GetCurrentByteCount</a></li>
		  <li><a href="#XML_GetInputContext">XML_GetInputContext</a></li>
	      </ul>
	  </li>
	  <li><a href="#miscellaneous">Miscellaneous Functions</a>
	      <ul>
	          <li><a href="#XML_SetUserData">XML_SetUserData</a></li>
		  <li><a href="#XML_GetUserData">XML_GetUserData</a></li>
		  <li><a href="#XML_UseParserAsHandlerArg">XML_UseParserAsHandlerArg</a></li>
		  <li><a href="#XML_SetBase">XML_SetBase</a></li>
		  <li><a href="#XML_GetBase">XML_GetBase</a></li>
		  <li><a href="#XML_GetSpecifiedAttributeCount">XML_GetSpecifiedAttributeCount</a></li>
		  <li><a href="#XML_GetIdAttributeIndex">XML_GetIdAttributeIndex</a></li>
		  <li><a href="#XML_SetEncoding">XML_SetEncoding</a></li>
		  <li><a href="#XML_SetParamEntityParsing">XML_SetParamEntityParsing</a></li>
		  <li><a href="#XML_SetReturnNSTriplet">XML_SetReturnNSTriplet</a></li>
		  <li><a href="#XML_ExpatVersion">XML_ExpatVersion</a></li>
		  <li><a href="#XML_ExpatVersionInfo">XML_ExpatVersionInfo</a></li>
	      </ul>
	  </li>
      </ul>  
  </li>
</ul>

<hr>
<h2><a name="overview">Overview</a></h2>
<p>Expat is a stream-oriented parser. You register callback (or handler) 
functions with
the parser and then start feeding it the document.
As the parser recognizes parts of
the document, it will call the appropriate handler for that part (if you've
registered one.) The document is fed to the parser in pieces, so you can
start parsing before you have all the document. This also allows you to
parse really huge documents that won't fit into memory.</p>

<p>Expat can be intimidating due to the many kinds of handlers and options
you can set. But you only need to learn four functions in order to do 90%
of what you'll want to do with it:</p>

<dl>

<dt><code>XML_ParserCreate</code></dt>
  <dd>Create a new parser object.</dd>

<dt><code>XML_SetElementHandler</code></dt>
  <dd>Set handlers for start and end tags.</dd>

<dt><code>XML_SetCharacterDataHandler</code></dt>
  <dd>Set handler for text.</dd>

<dt><code>XML_Parse</code></dt>
  <dd>Pass a buffer full of document to the parser</dd>
</dl>

<p>These functions and others are described in the
<a href="#reference">reference</a> part of this document. The reference
section also describes in detail the parameters passed to the different
types of handlers.

<p>Let's look at a very simple example program that only uses 3 of the above
functions (it doesn't need to set a character handler.) The program
<a href="../examples/outline.c">outline.c</a>
prints an element outline, indenting child elements to distinguish them from
the parent element that contains them. The start handler does all the work.
It prints two indenting spaces for every level of ancestor elements, then
it prints the element and attribute information. Finally it increments the
global Depth variable.

<div class="eg">
<pre>
int Depth;

void
start(void *data, const char *el, const char **attr) {
  int i;

  for (i = 0; i &lt; Depth; i++)
    printf("  ");

  printf("%s", el);

  for (i = 0; attr[i]; i += 2) {
    printf(" %s='%s'", attr[i], attr[i + 1]);
  }

  printf("\n");
  Depth++;
}  /* End of start handler */
</pre>
</div>

<p>The end tag simply does the bookkeeping work of decrementing the Depth.
<div class="eg">
<pre>
void
end(void *data, const char *el) {
  Depth--;
}  /* End of end handler */
</pre>
</div>

<p>After creating the parser, the main program just has the job of
shoveling the document to the parser so that it can do its work.

<hr>
<h2><a name="building">Building and Installing expat</a></h2>
<p>The expat distribution comes as a compressed (with GNU gzip) tar file.
You may download the latest version from
<a href="http://sourceforge.net/projects/expat/">Source Forge</a>.
After unpacking this, cd into the directory. Then follow either the
Win32 directions or Unix directions below.</p>

<h3>Building under Win32</h3>
<p>If you're using the GNU compiler under cygwin, follow the Unix directions
in the next section. Otherwise if you have Microsoft's Developer Studio
installed, then from Windows Explorer double-click on "expat.dsp" in the
lib directory and build and install in the usual manner.</p>

<p>Alternatively, you may download the win32 binary package that contains
the expat.h include file and a pre-built dll.</p>

<h3>Building under Unix (or GNU)</h3>
<p>First you'll need to run the configure shell script in order to configure
the Makefiles and headers for your system.</p>

<p>If you're happy with all the defaults that configure picks for you,
and you have permission on your system to install into /usr/local, you can
install expat with this sequence of commands:</p>

<pre>
   ./configure
   make
   make install
</pre>

<p>There are some options that you can provide to this script, but the
only one we'll mention here is the <code>--prefix</code> option. You can
find out all the options available by running configure with just the
<code>--help</code> option.
</p>

By default, the configure script sets things up so that the library gets
installed in <code>/usr/local/lib</code> and the associated header file in
<code>/usr/local/include</code>.
But if you were to give the option, <code>--prefix=/home/me/mystuff</code>,
then the library and header would get installed in
<code>/home/me/mystuff/lib</code> and <code>/home/me/mystuff/include</code>
respectively.
</p>

<hr>
<h2><a name="using">Using Expat</a></h2>
<h3>Compiling and Linking against expat</h3>
<p>Unless you installed expat in a location not expected by your compiler
and linker, all you have to do to use expat in your programs is to include
the expat header (<code>#include &lt;expat.h&gt;</code>) in your files that
make calls to it and to tell the linker
that it needs to link against the expat library. On Unix systems, this would
be the <code>-lexpat</code> argument.
Otherwise, you'll need to tell the compiler where to look for the expat header
and the linker where to find the expat library. You may also need to take
steps to tell the operating system where to find this libary at run time.
</p>
<p>On a Unix based system, here's what a Makefile might look like when expat
is installed in a standard location:</p>

<div class="eg">
<pre>
CC=cc
LDFLAGS=
LIBS= -lexpat
xmlapp: xmlapp.o
        $(CC) $(LDFLAGS) -o xmlapp xmlapp.o $(LIBS)
</pre>
</div>

<p>If you installed expat in, say, <code>/home/me/mystuff</code>, then
the Makefile would look like this:</p>

<div class="eg">
<pre>
CC=cc
CFLAGS= -I/home/me/mystuff/include
LDFLAGS=
LIBS= -L/home/me/mystuff/lib -lexpat
xmlapp: xmlapp.o
        $(CC) $(LDFLAGS) -o xmlapp xmlapp.o $(LIBS)
</pre>
</div>

<p>You'd also have to set the environment variable <code>LD_LIBRARY_PATH</code>
to <code>/home/me/mystuff/lib</code> (or to
<code>${LD_LIBRARY_PATH}:/home/me/mystuff/lib</code> if LD_LIBRARY_PATH
already has some directories in it) in order to run your application.
</p>

<h3>Expat Basics</h3>
<p>As we saw in the example in the overview, the first step in parsing an
XML document with expat is to create a parser object. There are
<a href="#creation">three functions</a> in the expat API for creating a
parser object.
However, only two of these
(<a href="#XML_ParserCreate"><code>XML_ParserCreate</code></a> and
<a href="#XML_ParserCreateNS"><code>XML_ParserCreateNS</code></a>)
can be used for constructing a parser for a top-level document.
The object returned by these functions is an opaque pointer
(i.e. expat.h declares it as void *) to data with further internal structure. 
In order to free the memory associated with this object you must call
<a href="#XML_ParserFree"><code>XML_ParserFree</code></a>. Note that if
you have provided any <a href="userdata">user data</a> that gets stored
in the parser, then your application is responsible for freeing it prior to
calling XML_ParserFree.
</p>

<p>The objects returned by the parser creation functions are good for
parsing only one XML document or external parsed entity. If your application
needs to parse many XML documents, then it needs to create a parser object
for each one. The best way to deal with this is to create a higher level
object that contains all the default initialization you want for your parser
objects.

<p>Walking through a document hierarchy with a stream oriented parser will
require a good stack mechanism in order to keep track of current context.
For instance, to answer the simple question,
"What element does this text belong to?" requires a stack, since the
parser may have descended into other elements that are children of the
current one and has encountered this text on the way out.

<p>The things you're likely to want to keep on a stack are the currently
opened element and it's attributes. You push this information onto the
stack in the start handler and you pop it off in the end handler.

<p>For some tasks, it is sufficient to just keep information on what the
depth of the stack is (or would be if you had one.) The outline program shown
above presents one example. Another such task would be skipping over a
complete element. When you see the start tag for the element you want to
skip, you set a skip flag and record the depth at which the element started.
When the end tag handler encounters the same depth, the skipped element has
ended and the flag may be cleared. If you follow the convention that the
root element starts at 1, then you can use the same variable for skip flag
and skip depth.

<div class="eg">
<pre>
void
init_info(Parseinfo *info) {
  info->skip = 0;
  info->depth = 1;
  /* Other initializations here */
}  /* End of init_info */

void
rawstart(void *data, const char *el, const char **attr) {
  Parseinfo *inf = (Parseinfo *) data;

  if (! inf->skip) {
    if (should_skip(inf, el, attr)) {
      inf->skip = inf->depth;
    }
    else
      start(inf, el, attr);     /* This does rest of start handling */
  }

  inf->depth++;
}  /* End of rawstart */

void
rawend(void *data, const char *el) {
  Parseinfo *inf = (Parseinfo *) data;

  inf->depth--;

  if (! inf->skip)
    end(inf, el);              /* This does rest of end handling */

  if (inf->skip == inf->depth)
    inf->skip = 0;
}  /* End rawend */

</pre>
</div>

<p>Notice in the above example the difference in how depth is manipulated
in the start and end handlers. The end tag handler should be the mirror
image of the start tag handler. This is necessary to properly model
containment. Since, in the start tag handler, we
incremented depth <em>after</em> the main body of start tag code, then in
the end handler, we need to manipulate it <em>before</em> the main body.
If we'd decided to increment it first thing in the start handler, then
we'd have had to decrement it last thing in the end handler.

<h3>Communicating between handlers</h3>

<p>In order to be able to pass information between different handlers
without using globals, you'll need to define a data structure to hold
the shared variables. You can then tell expat (with the XML_SetUserData
function) to pass a pointer to this
structure to the handlers. This is typically the first argument received
by most handlers.

<h3>Namespace Processing</h3>

<p>When the parser is created using the <code>XML_ParserCreateNS</code>,
function, expat performs namespace processing. Under namespace processing,
expat consumes <code>xmlns</code> and <code>xmlns:...</code> attributes,
which declare namespaces for the scope of the element in which they
occur. This means that your start handler will not see these attributes.
Your application can still be informed of these declarations by setting
namespace declaration handlers with
<a href="#XML_SetNamespaceDeclHandler">
<code>XML_SetNamespaceDeclHandler</code></a>.

<p>Element type and attribute names that belong to a given namespace are
passed to the appropriate handler in expanded form. By default this expanded
form is a concatenation of the namespace URI, the separator character (which
is the 2nd argument to <code>XML_ParserCreateNS</code>), and the local
name (i.e. the part after the colon). Names with undeclared prefixes are
passed through to the handlers unchanged, with the prefix and colon still
attached. Unprefixed attribute names are never expanded, and unprefixed
element names are only expanded when they are in the scope of a default
namespace.

<p>However if <a href="XML_SetReturnNSTriplet">XML_SetReturnNSTriplet</a>
has been called with a non-zero <code>do_nst</code> parameter, then the
expanded form for names with an explicit prefix is a concatenation of:
URI, separator, local name, separator, prefix.
</p>

<p>You can set handlers for the start of a namespace declaration and for
the end of a scope of a declaration with the
<code>XML_SetNamespaceDeclHandler</code> function.
The StartNamespaceDeclHandler is called prior to the start tag handler
and the EndNamespaceDeclHandler is called before the corresponding end tag
that ends the namespace's scope.
The namespace start handler gets passed the prefix and URI for the namespace.
For a default namespace declaration (xmlns='...'), the prefix will be null.
The URI will be null for the case where the default namespace is being unset.
The namespace end handler just gets the prefix for the closing scope.

<p>These handlers are called for each declaration. So if, for instance, a
start tag had three namespace declarations, then the StartNamespaceDeclHandler
would be called three times before the start tag handler is called, once for
each declaration.

<p>The <a href="src/namespace.c">namespace.c</a> example demonstrates the
use of these features. Like outline.c, it produces an outline, but
in addition it annotates when a namespace scope starts and when it ends.
This example also demonstrates use of application user data.

<h3>Character Encodings</h3>

<p>While XML is based on Unicode, and every XML processor is required to
recognized UTF-8 and UTF-16 (1 and 2 byte encodings of Unicode), other
encodings may be declared in XML documents or entities. For the main
document, an XML declaration may contain an encoding declaration:
<pre>
&lt;?xml version="1.0" encoding="ISO-8859-2"?&gt;
</pre>

<p>External parsed entities may begin with a text declaration, which
looks like an XML declaration with just an encoding declaration:
<pre>
&lt;?xml encoding="Big5"?&gt;
</pre>

<p>With expat, you may also specify an encoding at the time of creating a
parser. This is useful when the encoding information may come from a source
outside the document itself (like a higher level protocol.)

<p><a name="builtin_encodings"></a>There are four built-in encodings in expat:
<ul>
<li>UTF-8
<li>UTF-16
<li>ISO-8859-1
<li>US-ASCII
</ul>

<p>Anything else discovered in an encoding declaration or in the
protocol encoding specified in the parser constructor, triggers a call
to the <code>UnknownEncodingHandler</code>. This handler gets passed
the encoding name and a pointer to an <code>XML_Encoding</code> data
structure. Your handler must fill in this structure and return 1 if 
it knows how to deal with the encoding. Otherwise the handler should
return 0.
The handler also gets passed a pointer to an
optional application data structure that you may indicate when you set
the handler.

<p>Expat places restrictions on character encodings that it can support
by filling in the <code>XML_Encoding</code> structure.
include file:
<ol>
<li>Every ASCII character that can appear in a well-formed XML document
must be represented by a single byte, and that byte must correspond to
it's ASCII encoding (except for the characters $@@\^'{}~)</li>
<li>Characters must be encoded in 4 bytes or less.</li>
<li>All characters encoded must have Unicode scalar values less than or
equal to 65535 (0xFFFF)<em>This does not apply to the built-in support
for UTF-16 and UTF-8</em></li>
<li>No character may be encoded by more that one distinct sequence of
bytes</li>
</ol>

<p><code>XML_Encoding</code> contains an array of integers that correspond
to the 1st byte of an encoding sequence. If the value in the array for a
byte is zero or positive, then the byte is a single byte encoding that
encodes the Unicode scalar value contained in the array. A -1 in this array
indicates a malformed byte. If the value is
-2, -3, or -4, then the byte is the beginning of a 2, 3, or 4 byte sequence
respectively. Multi-byte sequences are sent to the convert function pointed
at in the <code>XML_Encoding</code> structure. This function should return
the Unicode scalar value for the sequence or -1 if the sequence is malformed.

<p>One pitfall that novice expat users are likely to fall into is that
although expat may accept input in various encodings, the strings that it
passes to the handlers are always encoded in UTF-8. Your application is
responsible for any translation of these strings into other encodings.

<h3>Handling External Entity References</h3>

<p>Expat does not read or parse external entities directly. Note that any
external DTD is a special case of an external entity.
If you've set no <code>ExternalEntityRefHandler</code>, then external
entity references are silently ignored. Otherwise, it calls your handler with
the information needed to read and parse the external entity.

<p>Your handler
isn't actually responsible for parsing the entity, but it is responsible
for creating a subsidiary parser with
<code>XML_ExternalEntityParserCreate</code> that will do the job. This returns
an instance of <code>XML_Parser</code> that has handlers and other data
structures initialized from the parent parser. You may then use
<code>XML_Parse</code> or <code>XML_ParseBuffer</code> calls against this
parser.
Since external entities my refer to other external entities, your handler
should be prepared to be called recursively.

<h3>Parsing DTDs</h3>
<p>In order to parse parameter entities,  before starting the parse, you must
call <code>XML_SetParamEntityParsing</code> with one of the following
arguments:
<dl>
<dt><code>XML_PARAM_ENTITY_PARSING_NEVER</code></dt>
<dd>Don't parse parameter entities or the external subset</dd>
<dt><code>XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE</code></dt>
<dd>Parse parameter entites and the external subset unless
<code>standalone</code> was set to "yes" in the XML declaration.</dd>
<dt><code>XML_PARAM_ENTITY_PARSING_ALWAYS</code></dt>
<dd>Always parse parameter entities and the external subset</dd>
</dl>

<p>In order to read an external DTD, you also have to set an
external entity reference handler as described above.

<hr>
<h2><a name="examples">Some expat Examples</a></h2>

<hr>
<!-- ================================================================ -->

<h2><a name="reference">Expat Reference</a></h2>

<h3><a name="creation">Parser Creation</a></h3>

<div class="fcndec"><a name="XML_ParserCreate"><pre>
XML_Parser
XML_ParserCreate(const XML_Char *encoding)
</pre></a></div>
<div class="fcndef">
Construct a new parser. If encoding is non-null, it specifies a
character encoding to use for the document. This overrides the document
encoding declaration. There are four built-in encodings:
<ul>
<li>US-ASCII
<li>UTF-8
<li>UTF-16
<li>ISO-8859-1
</ul>
Any other value will invoke a call to the UnknownEncodingHandler.
</div>

<div class="fcndec"><a name="XML_ParserCreateNS"><pre>
XML_Parser
XML_ParserCreateNS(const XML_Char *encoding,
                   XML_Char sep)
</pre></a></div>
<div class="fcndef">
Constructs a new parser that has namespace processing in effect. Namespace
expanded element names and attribute names are returned as a concatenation
of the namespace URI, <em>sep</em>, and the local part of the name. This
means that you should pick a character for <em>sep</em> that can't be
part of a legal URI.</div>

<div class="fcndec"><a name="XML_ParserCreate_MM"><pre>
XML_Parser
XML_ParserCreate_MM(const XML_Char *encoding,
                    const XML_Memory_Handling_Suite *ms,
		    const XML_Char *sep)
</pre></a></div>
<div class="fcndef">
<p>Construct a new parser using the suite of memory handling functions
specified in <code>ms</code>. If <code>ms</code> is NULL, then use the
standard set of memory management functions. If <code>sep</code> is
non NULL, then namespace processing is enabled in the created parser
and the character pointed at by sep is used as the separator between
the namespace URI and the local part of the name</p>
<div class="eg"><pre>
typedef struct {
  void *(*malloc_fcn)(size_t size);
  void *(*realloc_fcn)(void *ptr, size_t size);
  void (*free_fcn)(void *ptr);
} XML_Memory_Handling_Suite;
</pre></div>
</div>

<div class="fcndec"><a name="XML_ExternalEntityParserCreate"><pre>
XML_Parser
XML_ExternalEntityParserCreate(XML_Parser p,
                               const XML_Char *context,
                               const XML_Char *encoding)
</pre></a></div>
<div class="fcndef">
Construct a new XML_Parser object for parsing an external general
entity. Context is the context argument passed in a call to a
ExternalEntityRefHandler. Other state information such as handlers, user data,
namespace processing is inherited from the parser passed as the 1st
argument. So you shouldn't need to call any of the behavior changing
functions on this parser (unless you want it to act differently than the
parent parser.)
</div>

<div class="fcndec"><a name="XML_ParserFree"><pre>
void
XML_ParserFree(XML_Parser p)
</pre></a></div>
<div class="fcndef">
Free memory used by the parser. Your application is responsible for
freeing any memory associated with <a href="#userdata">UserData</a>.
</div>

<h3><a name="parsing">Parsing</a></h3>


<div class="fcndec"><a name="XML_Parse"><pre>
int
XML_Parse(XML_Parser p,
          const char *s,
          int len,
          int isFinal)
</pre></a></div>
<div class="fcndef">
Parse some more of the document. The string <code>s</code> is a buffer
containing part (or perhaps all) of the document. The number of bytes of s
that are part of the document is indicated by <code>len</code>. This means
that <code>s</code> doesn't have to be null terminated. It also means that
if <code>len</code> is larger than the number of bytes in the block of
memory that <code>s</code> points at, then a memory fault is likely. The
<code>isFinal</code> parameter informs the parser that this is the last
piece of the document. Frequently, the last piece is empty (i.e.
<code>len</code> is zero.)
If a parse error occurred, it returns 0. Otherwise it returns a non-zero
value.
</div>

<div class="fcndec"><a name="XML_ParseBuffer"><pre>
int
XML_ParseBuffer(XML_Parser p,
                int len,
                int isFinal)
</pre></a></div>
<div class="fcndef">
This is just like XML_Parse, except in this case expat provides the buffer.
By obtaining the buffer from expat with the <code>XML_GetBuffer</code>
function, the application can avoid double copying of the input.
</div>

<div class="fcndec"><a name="XML_GetBuffer"><pre>
void *
XML_GetBuffer(XML_Parser p,
              int len)
</pre></a></div>
<div class="fcndef">
Obtain a buffer of size <code>len</code> to read a piece of the document
into. A NULL value is returned if expat can't allocate enough memory for
this buffer. This has to be called prior to every call to
<code>XML_ParseBuffer</code>. A typical use would look like this:

<div id="eg">
<pre>
for (;;) {
  int bytes_read;
  void *buff = XML_GetBuffer(p, BUFF_SIZE);
  if (buff == NULL) {
    /* handle error */
  }

  bytes_read = read(docfd, buff, BUFF_SIZE);
  if (bytes_read < 0) {
    /* handle error */
  }

  if (! XML_ParseBuffer(p, bytes_read, bytes_read == 0)) {
    /* handle parse error */
  }

  if (bytes_read == 0)
    break;
}  
</pre>
</div>
</div>

<h3><a name="setting">Handler Setting</a></h3>
<p>Although handlers are typically set prior to parsing and left alone, an
application may choose to set or change the handler for a parsing event
while the parse is in progress. For instance, your application may choose
to ignore all text not descended from a <code>para</code> element. One
way it could do this is to set the character handler when a para start tag
is seen, and unset it for the corresponding end tag.

<p>A handler may be <em>unset</em> by providing a NULL pointer to the
appropriate handler setter. None of the handler setting functions have
a return value.

<p>Your handlers will be receiving strings in arrays of type
<code>XML_Char</code>. This type is defined in expat.h as <code>char *</code>
and contains bytes encoding UTF-8.
Note that you'll receive them in this form independent of the original
encoding of the document.</p>

<div class="handler">
<div class="setter"><a name="XML_SetStartElementHandler"><pre>
XML_SetStartElementHandler(XML_Parser p,
                           XML_StartElementHandler start);
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_StartElementHandler)(void *userData,
                           const XML_Char *name,
                           const XML_Char **atts);
</pre></div>
<p>Set handler for start (and empty) tags. Attributes are passed to the start
handler as a pointer to a vector of char pointers. Each attribute seen in
a start (or empty) tag occupies 2 consecutive places in this vector: the
attribute name followed by the attribute value. These pairs are terminated
by a null pointer.</p>
<p>Note that an empty tag generates a call to both start and end handlers
(in that order).</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetEndElementHandler"><pre>
XML_SetEndElementHandler(XML_Parser p,
                         XML_EndElementHandler);
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_EndElementHandler)(void *userData,
                         const XML_Char *name);
</pre></div>
<p>Set handler for end (and empty) tags. As noted above, an empty tag
generates a call to both start and end handlers.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetElementHandler"><pre>
XML_SetElementHandler(XML_Parser p,
                      XML_StartElementHandler start,
                      XML_EndElementHandler end);
</pre></a></div>
<p>Set handlers for start and end tags with one call.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetCharacterDataHandler"><pre>
XML_SetCharacterDataHandler(XML_Parser p,
                            XML_CharacterDataHandler charhndl)
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_CharacterDataHandler)(void *userData,
                            const XML_Char *s,
                            int len);
</pre></div>
<p>Set a text handler. The string your handler receives
is <em>NOT zero terminated</em>. You have to use the length argument
to deal with the end of the string. A single block of contiguous text
free of markup may still result in a sequence of calls to this handler.
In other words, if you're searching for a pattern in the text, it may
be split across calls to this handler.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetProcessingInstructionHandler"><pre>
XML_SetProcessingInstructionHandler(XML_Parser p,
                                    XML_ProcessingInstructionHandler proc)
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_ProcessingInstructionHandler)(void *userData,
                                    const XML_Char *target,
                                    const XML_Char *data);

</pre></div>
<p>Set a handler for processing instructions. The target is the first word
in the processing instruction. The data is the rest of the characters in
it after skipping all whitespace after the initial word.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetCommentHandler"><pre>
XML_SetCommentHandler(XML_Parser p,
                      XML_CommentHandler cmnt)
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_CommentHandler)(void *userData,
                      const XML_Char *data);
</pre></div>
<p>Set a handler for comments. The data is all text inside the comment
delimiters.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetStartCdataSectionHandler"><pre>
XML_SetStartCdataSectionHandler(XML_Parser p,
                                XML_StartCdataSectionHandler start);
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_StartCdataSectionHandler)(void *userData);
</pre></div>
<p>Set a handler that gets called at the beginning of a CDATA section.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetEndCdataSectionHandler"><pre>
XML_SetEndCdataSectionHandler(XML_Parser p,
                              XML_EndCdataSectionHandler end);
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_EndCdataSectionHandler)(void *userData);
</pre></div>
<p>Set a handler that gets called at the end of a CDATA section.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetCdataSectionHandler"><pre>
XML_SetCdataSectionHandler(XML_Parser p,
                           XML_StartCdataSectionHandler start,
                           XML_EndCdataSectionHandler end)
</pre></a></div>
<p>Sets both CDATA section handlers with one call.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetDefaultHandler"><pre>
XML_SetDefaultHandler(XML_Parser p,
                      XML_DefaultHandler hndl)
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_DefaultHandler)(void *userData,
                      const XML_Char *s,
                      int len);
</pre></div>
<p>Sets a handler for any characters in the document which wouldn't
otherwise be handled. This includes both data for which no handlers can be
set (like some kinds of DTD declarations) and data which could be reported
but which currently has no handler set. Note that a contiguous piece of
data that is destined to be reported to the default handler may actually
be reported over several calls to the handler. Setting the handler with
this call has the side effect of turning off expansion of references
to internally defined general entities. Instead these references are
passed to the default handler.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetDefaultHandlerExpand"><pre>
XML_SetDefaultHandlerExpand(XML_Parser p,
                            XML_DefaultHandler hndl)
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_DefaultHandler)(void *userData,
                      const XML_Char *s,
                      int len);
</pre></div>
<p>This sets a default handler, but doesn't affect expansion of internal
entity references.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetExternalEntityRefHandler"><pre>
XML_SetExternalEntityRefHandler(XML_Parser p,
                                XML_ExternalEntityRefHandler hndl)
</pre></a></div>
<div class="signature"><pre>
typedef int
(*XML_ExternalEntityRefHandler)(XML_Parser p,
                                const XML_Char *context,
                                const XML_Char *base,
                                const XML_Char *systemId,
                                const XML_Char *publicId);
</pre></div>
<p>Set an external entity reference handler. This handler is also
called for processing an external DTD subset if parameter entity parsing
is in effect. (See <a href="#XML_SetParamEntityParsing">
<code>XML_SetParamEntityParsing</code></a>.)</p>


<p>The base parameter is the base to use for relative system identifiers.
It is set by <a href="#XML_SetBase">XML_SetBase</a> and may be null. The
public id parameter is the public id given in the entity declaration and
may be null. The system id is the system identifier specified in the entity
declaration and is never null.</p>

<p>There are a couple of ways in which this handler differs from others.
First, this handler returns an integer. A non-zero value should be returned
for successful handling of the external entity reference. Returning a zero
indicates failure, and causes the calling parser to return
an <code>XML_ERROR_EXTERNAL_ENTITY_HANDLING</code> error.</p>

<p>Second, instead of having userData as its first argument, it receives the
parser that encountered the entity reference. This, along with the context
parameter, may be used as arguments to a call to
<a href="#XML_ExternalEntityParserCreate">XML_ExternalEntityParserCreate</a>.
Using the returned parser, the body of the external entity can be recursively
parsed.</p>

<p>Since this handler may be called recursively, it should not be saving
information into global or static variables.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetUnknownEncodingHandler"><pre>
XML_SetUnknownEncodingHandler(XML_Parser p,
                              XML_UnknownEncodingHandler enchandler,
			      void *encodingHandlerData)
</pre></a></div>
<div class="signature"><pre>
typedef int
(*XML_UnknownEncodingHandler)(void *encodingHandlerData,
                              const XML_Char *name,
                              XML_Encoding *info);
</pre></div>
<p>Set a handler to deal with encodings other than the
<a href="#builtin_encodings">built in set</a>. If the handler knows how
to deal with an encoding with the given name, it should fill in the info
data structure and return 1. Otherwise it should return 0.</p>

<pre>
    typedef struct {
      int map[256];
      void *data;
      int (*convert)(void *data, const char *s);
      void (*release)(void *data);
    } XML_Encoding;
</pre>

<p>The map array contains information for every possible possible leading
byte in a byte sequence. If the corresponding value is &gt;= 0, then it's
a single byte sequence and the byte encodes that Unicode value. If the
value is -1, then that byte is invalid as the initial byte in a sequence.
If the value is -n, where n is an integer &gt; 1, then n is the number of
bytes in the sequence and the actual conversion is accomplished by a
call to the function pointed at by convert. This function may return -1
if the sequence itself is invalid. The convert pointer may be null if
there are only single byte codes. The data parameter passed to the convert
function is the data pointer from XML_Encoding. The string s is <em>NOT</em>
null terminated and points at the sequence of bytes to be converted.</p>

<p>The function pointed at by release is called by the parser when it is
finished with the encoding. It may be null.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetStartNamespaceDeclHandler"><pre>
XML_SetStartNamespaceDeclHandler(XML_Parser p,
			         XML_StartNamespaceDeclHandler start);
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_StartNamespaceDeclHandler)(void *userData,
                                 const XML_Char *prefix,
                                 const XML_Char *uri);
</pre></div>
<p>Set a handler to be called when a namespace is declared. Namespace
declarations occur inside start tags. But the namespace declaration start
handler is called before the start tag handler for each namespace declared
in that start tag.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetEndNamespaceDeclHandler"><pre>
XML_SetEndNamespaceDeclHandler(XML_Parser p,
			       XML_EndNamespaceDeclHandler end);
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_EndNamespaceDeclHandler)(void *userData,
                               const XML_Char *prefix);
</pre></div>
<p>Set a handler to be called when leaving the scope of a namespace
declaration. This will be called, for each namespace declaration, after
the handler for the end tag of the element in which the namespace was declared.
</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetNamespaceDeclHandler"><pre>
XML_SetNamespaceDeclHandler(XML_Parser p,
                            XML_StartNamespaceDeclHandler start,
                            XML_EndNamespaceDeclHandler end)
</pre></a></div>
<p>Sets both namespace declaration handlers with a single call</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetXmlDeclHandler"><pre>
XML_SetXmlDeclHandler(XML_Parser p,
		      XML_XmlDeclHandler xmldecl);
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_XmlDeclHandler) (void            *userData,
                       const XML_Char  *version,
                       const XML_Char  *encoding,
                       int             standalone);
</pre></div>
<p>Sets a handler that is called for XML declarations and also for
text declarations discovered in external entities. The way to distinguish
is that the <code>version</code> parameter will be NULL for text
declarations. The <code>encoding</code> parameter may be NULL for
an XML declaration. The <code>standalone</code> argument will contain
-1, 0, or 1  indicating respectively that there was no standalone parameter in
the declaration, that it was given as no, or that it was given as yes.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetStartDoctypeDeclHandler"><pre>
XML_SetStartDoctypeDeclHandler(XML_Parser p,
			       XML_StartDoctypeDeclHandler start);
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_StartDoctypeDeclHandler)(void           *userData,
                               const XML_Char *doctypeName,
                               const XML_Char *sysid,
                               const XML_Char *pubid,
                               int            has_internal_subset);
</pre></div>
<p>Set a handler that is called at the start of a DOCTYPE declaration,
before any external or internal subset is parsed. Both <code>sysid</code>
and <code>pubid</code> may be NULL. The <code>has_internal_subset</code>
will be non-zero if the DOCTYPE declaration has an internal subset.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetEndDoctypeDeclHandler"><pre>
XML_SetEndDoctypeDeclHandler(XML_Parser p,
			     XML_EndDoctypeDeclHandler end);
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_EndDoctypeDeclHandler)(void *userData);
</pre></div>
<p>Set a handler that is called at the end of a DOCTYPE declaration,
after parsing any external subset.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetDoctypeDeclHandler"><pre>
XML_SetDoctypeDeclHandler(XML_Parser p,
			  XML_StartDoctypeDeclHandler start,
			  XML_EndDoctypeDeclHandler end);
</pre></a></div>
<p>Set both doctype handlers with one call.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetElementDeclHandler"><pre>
XML_SetElementDeclHandler(XML_Parser p,
			  XML_ElementDeclHandler eldecl);
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_ElementDeclHandler)(void *userData,
                          const XML_Char *name,
                          XML_Content *model);
</pre></div>
<div class="signature"><pre>
enum XML_Content_Type {
  XML_CTYPE_EMPTY = 1,
  XML_CTYPE_ANY,
  XML_CTYPE_MIXED,
  XML_CTYPE_NAME,
  XML_CTYPE_CHOICE,
  XML_CTYPE_SEQ
};

enum XML_Content_Quant {
  XML_CQUANT_NONE,
  XML_CQUANT_OPT,
  XML_CQUANT_REP,
  XML_CQUANT_PLUS
};

typedef struct XML_cp XML_Content;

struct XML_cp {
  enum XML_Content_Type		type;
  enum XML_Content_Quant	quant;
  const XML_Char *		name;
  unsigned int			numchildren;
  XML_Content *			children;
};
</pre></div>
<p>Sets a handler for element declarations in a DTD. The handler gets called
with the name of the element in the declaration and a pointer to a structure
that contains the element model. It is the application's responsibility to
free this data structure.</p>

<p>The <code>model</code> argument is the root of a tree of
<code>XML_Content</code> nodes. If <code>type</code> equals
<code>XML_CTYPE_EMPTY</code> or <code>XML_CTYPE_ANY</code>, then
<code>quant</code> will be <code>XML_CQUANT_NONE</code>, and the other fields
will be zero or NULL.
If <code>type</code> is <code>XML_CTYPE_MIXED</code>, then <code>quant</code>
will be <code>XML_CQUANT_NONE</code> or <code>XML_CQUANT_REP</code> and
<code>numchildren</code> will contain the number of elements that are allowed
to be mixed in and <code>children</code> points to an array of
<code>XML_Content</code> structures that will all have type XML_CTYPE_NAME
with no quantification.
Only the root node can be type <code>XML_CTYPE_EMPTY</code>, <code>XML_CTYPE_ANY</code>, or <code>XML_CTYPE_MIXED</code>.</p>

<p>For type <code>XML_CTYPE_NAME</code>, the <code>name</code> field points
to the name and the <code>numchildren</code> and <code>children</code> fields
will be zero and NULL. The <code>quant</code> field will indicate any
quantifiers placed on the name.</p>

<p>Types <code>XML_CTYPE_CHOICE</code> and <code>XML_CTYPE_SEQ</code>
indicate a choice or sequence respectively. The <code>numchildren</code>
field indicates how many nodes in the choice or sequence and
<code>children</code> points to the nodes.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetAttlistDeclHandler"><pre>
XML_SetAttlistDeclHandler(XML_Parser p,
                          XML_AttlistDeclHandler attdecl);
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_AttlistDeclHandler) (void           *userData,
                           const XML_Char *elname,
                           const XML_Char *attname,
                           const XML_Char *att_type,
                           const XML_Char *dflt,
                           int            isrequired);
</pre></div>
<p>Set a handler for attlist declarations in the DTD. This handler is called
for <em>each</em> attribute. So a single attlist declaration with multiple
attributes declared will generate multiple calls to this handler. The
<code>elname</code> parameter returns the name of the element for which the
attribute is being declared. The attribute name is in the <code>attname</code>
parameter. The attribute type is in the <code>att_type</code> parameter.
It is the string representing the type in the declaration with whitespace
removed.</p>

<p>The <code>dflt</code> parameter holds the default value. It will
be NULL in the case of "#IMPLIED" or "#REQUIRED" attributes. You can
distinguish these two cases by checking the <code>isrequired</code>
parameter, which will be true in the case of "#REQUIRED" attributes.
Attributes which are "#FIXED" will have also have a true
<code>isrequired</code>, but they will have the non-NULL fixed value in the
<code>dflt</code> parameter.
</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetEntityDeclHandler"><pre>
XML_SetEntityDeclHandler(XML_Parser p,
			 XML_EntityDeclHandler handler);
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_EntityDeclHandler) (void           *userData,
                          const XML_Char *entityName,
                          int            is_parameter_entity,
                          const XML_Char *value,
                          int            value_length,
                          const XML_Char *base,
                          const XML_Char *systemId,
                          const XML_Char *publicId,
                          const XML_Char *notationName);
</pre></div>
<p>Sets a handler that will be called for all entity declarations.
The <code>is_parameter_entity</code> argument will be non-zero in the case
of parameter entities and zero otherwise.
</p>
<p>For internal entities (<code>&lt;!ENTITY foo "bar"&gt;</code>),
<code>value</code> will be non-NULL and <code>systemId</code>,
<code>publicId</code>, and <code>notationName</code> will all be NULL.
The value string is <em>not</em> NULL terminated; the length is provided in
the <code>value_length</code> parameter. Do not use <code>value_length</code>
to test for internal entities, since it is legal to have zero-length
values. Instead check for whether or not <code>value</code> is NULL.</p>
<p>The <code>notationName</code> argument will have a non-NULL value only
for unparsed entity declarations.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetUnparsedEntityDeclHandler"><pre>
XML_SetUnparsedEntityDeclHandler(XML_Parser p,
                                 XML_UnparsedEntityDeclHandler h)
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_UnparsedEntityDeclHandler)(void *userData,
                                 const XML_Char *entityName,
                                 const XML_Char *base,
                                 const XML_Char *systemId,
                                 const XML_Char *publicId,
                                 const XML_Char *notationName);
</pre></div>
<p>Set a handler that receives declarations of unparsed entities. These
are entity declarations that have a notation (NDATA) field:</p>

<div id="eg"><pre>
&lt;!ENTITY logo SYSTEM "images/logo.gif" NDATA gif&gt;
</pre></div>

<p>This handler is obsolete and is provided for backwards compatibility.
Use instead <a href="#XML_SetEntityDeclHandler">XML_SetEntityDeclHandler</a>.
</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetNotationDeclHandler"><pre>
XML_SetNotationDeclHandler(XML_Parser p,
                           XML_NotationDeclHandler h)
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_NotationDeclHandler)(void *userData,
                           const XML_Char *notationName,
                           const XML_Char *base,
                           const XML_Char *systemId,
                           const XML_Char *publicId);
</pre></div>
<p>Set a handler that receives notation declarations.</p>
</div>

<div class="handler">
<div class="setter"><a name="XML_SetNotStandaloneHandler"><pre>
XML_SetNotStandaloneHandler(XML_Parser p,
                            XML_NotStandaloneHandler h)
</pre></a></div>
<div class="signature"><pre>
typedef int 
(*XML_NotStandaloneHandler)(void *userData);
</pre></div>
<p>Set a handler that is called if the document is not "standalone".
This happens when there is an external subset or a reference to a parameter
entity, but does not have standalone set to "yes" in an XML declaration.
If this handler returns 0, then the parser will throw an
<code>XML_ERROR_NOT_STANDALONE</code> error.</p>
</div>

<h3><a name="position">Parse position and error reporting functions</a></h3>
<p>These are the functions you'll want to call when the parse functions
return 0 (i.e. a parse error has ocurred), although the position reporting
functions are useful outside of errors. The position reported is the byte
position (in the original document or entity encoding) of the first of the
sequence of characters that generated the current event (or the error that
caused the parse functions to return 0.)</p>
<p>The position reporting functions are accurate only outside of the DTD.
In other words, they usually return bogus information when called from within
a DTD declaration handler.</p>

<div class="fcndec"><a name="XML_GetErrorCode"><pre>
enum XML_Error
XML_GetErrorCode(XML_Parser p)
</pre></a></div>
<div class="fcndef">
Return what type of error has occurred.
</div>

<div class="fcndec"><a name="XML_ErrorString"><pre>
const XML_LChar *
XML_ErrorString(int code)
</pre></a></div>
<div class="fcndef">
Return a string describing the error corresponding to code.
The code should be one of the enums that can be returned from
XML_GetErrorCode.
</div>

<div class="fcndec"><a name="XML_GetCurrentByteIndex"><pre>
long
XML_GetCurrentByteIndex(XML_Parser p)
</pre></a></div>
<div class="fcndef">
Return the byte offset of the position.
</div>

<div class="fcndec"><a name="XML_GetCurrentLineNumber"><pre>
int
XML_GetCurrentLineNumber(XML_Parser p)
</pre></a></div>
<div class="fcndef">
Return the line number of the position.
</div>

<div class="fcndec"><a name="XML_GetCurrentColumnNumber"><pre>
int
XML_GetCurrentColumnNumber(XML_Parser p)
</pre></a></div>
<div class="fcndef">
Return the offset, from the beginning of the current line, of
the position.
</div>

<div class="fcndec"><a name="XML_GetCurrentByteCount"><pre>
int
XML_GetCurrentByteCount(XML_Parser p);
</pre></a></div>
<div class="fcndef">
Return the number of bytes in the current event. Returns 0 if the event is
inside a reference to an internal entity.
</div>

<div class="fcndec"><a name="XML_GetInputContext"><pre>
const char *
XML_GetInputContext(XML_Parser p,
                    int *offset,
                    int *size);
</pre></a></div>
<div class="fcndef">
<p>Returns the parser's input buffer, sets the integer pointed at by
<code>offset</code> to the offset within this buffer of the current
parse position, and set the integer pointed at by <code>size</code>
to the size of the returned buffer.</p>
<p>This should only be called from within a handler during an active
parse and the returned buffer should only be referred to from within
the handler that made the call. This input buffer contains the untranslated
bytes of the input.</p>
<p>Only a limited amount of context is kept, so if the event triggering
a call spans over a very large amount of input, the actual parse position
may be before the beginning of the buffer.</p>
</div>

<h3><a name="miscellaneous">Miscellaneous functions</a></h3>
<p>The functions in this section either obtain state information from the
parser or can be used to dynamicly set parser options.

<div class="fcndec"><a name="XML_SetUserData"><pre>
void
XML_SetUserData(XML_Parser p,
                void *userData)
</pre></a></div>
<div class="fcndef">
This sets the user data pointer that gets passed to handlers.
It overwrites any previous value for this pointer. Note that the
application is responsible for freeing the memory associated with
<code>userData</code> when it is finished with the parser. So if
you call this when there's already a pointer there, and you haven't
freed the memory associated with it, then you've probably just leaked
memory.
</div>

<div class="fcndec"><a name="XML_GetUserData"><pre>
void *
XML_GetUserData(XML_Parser p)
</pre></a></div>
<div class="fcndef">
This returns the user data pointer that gets passed to handlers.
It is actually implemented as a macro.
</div>

<div class="fcndec"><a name="XML_UseParserAsHandlerArg"><pre>
void
XML_UseParserAsHandlerArg(XML_Parser p)
</pre></a></div>
<div class="fcndef">
After this is called, handlers receive the parser in the
userData argument. The userData information can still be obtained using
the XML_GetUserData function.
</div>

<div class="fcndec"><a name="XML_SetBase"><pre>
int
XML_SetBase(XML_Parser p,
            const XML_Char *base)
</pre></a></div>
<div class="fcndef">
Set the base to be used for resolving relative URIs in system identifiers.
The return value is 0 if there's no memory to store base, otherwise it's
non-zero.
</div>

<div class="fcndec"><a name="XML_GetBase"><pre>
const XML_Char *
XML_GetBase(XML_Parser p)
</pre></a></div>
<div class="fcndef">
Return the base for resolving relative URIs.
</div>

<div class="fcndec"><a name="XML_GetSpecifiedAttributeCount"><pre>
int
XML_GetSpecifiedAttributeCount(XML_Parser p)
</pre></a></div>
<div class="fcndef">
When attributes are reported to the start handler in the atts vector,
attributes that were explicitly set in the element occur before any
attributes that receive their value from default information in an
ATTLIST declaration. This function returns the number of attributes that
were explicitly set times two, thus giving the offset in the <code>atts</code>
array passed to the start tag handler of the first attribute set
due to defaults. It supplies information for the last call to a start
handler. If called inside a start handler, then that means the current call.
</div>

<div class="fcndec"><a name="XML_GetIdAttributeIndex"><pre>
int
XML_GetIdAttributeIndex(XML_Parser p);
</pre></a></div>
<div class="fcndef">
Returns the index of the ID attribute passed in the atts array
in the last call to XML_StartElementHandler, or -1 if there is no ID
attribute. If called inside a start handler, then that means the current call.
</div>

<div class="fcndec"><a name="XML_SetEncoding"><pre>
int
XML_SetEncoding(XML_Parser p,
                const XML_Char *encoding)
</pre></a></div>
<div class="fcndef">
Set the encoding to be used by the parser. It is equivalent to
passing a non-null encoding argument to the parser creation functions.
It must not be called after XML_Parser or XML_ParseBuffer have been
called on the given parser.
</div>

<div class="fcndec"><a name="XML_SetParamEntityParsing"><pre>
int
XML_SetParamEntityParsing(XML_Parser p,
                          enum XML_ParamEntityParsing code)
</pre></a></div>
<div class="fcndef">
This enables parsing of parameter entities, including the external
parameter entity that is the external DTD subset, according to
<code>code</code>.
The choices for <code>code</code> are:
<ul>
<li><code>XML_PARAM_ENTITY_PARSING_NEVER</code></li>
<li><code>XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE</code></li>
<li><code>XML_PARAM_ENTITY_PARSING_ALWAYS</code></li>
</ul>
</div>

<div class="fcndec"><a name="XML_SetReturnNSTriplet"><pre>
void
XML_SetReturnNSTriplet(XML_Parser parser,
                       int        do_nst);
</pre></a></div>
<div class="fcndef">
<p>
This function only has an effect when using a parser created with
<a href="#XML_ParserCreateNS">XML_ParserCreateNS</a>, i.e. when namespace
processing is in effect. The <code>do_nst</code> sets whether or not prefixes
are returned with names qualified with a namespace prefix. If this function
is called with <code>do_nst</code> non-zero, then afterwards namespace
qualified names (that is qualified with a prefix as opposed to belonging
to a default namespace) are returned as a triplet with the three parts
separated by the namespace separator specified when the parser was created.
The order of returned parts is URI, local name, and prefix.</p>
<p>If <code>do_nst</code> is zero, then namespaces are reported in the
default manner, URI then local_name separated by the namespace separator.</p>
</div>

<div class="fcndec"><a name="XML_ExpatVersion"><pre>
XML_LChar *
XML_ExpatVersion();
</pre></a></div>
<div class="fcndef">
Return the library version as a string (e.g. "expat_1.95.1").
</div>

<div class="fcndec"><a name="XML_ExpatVersionInfo"><pre>
struct XML_expat_version
XML_ExpatVersionInfo();
</pre></a></div>
<div class="fcndef">
Return the library version information as a structure.
<div class="eg"><pre>
typedef struct {
  int major;
  int minor;
  int micro;
} XML_Expat_Version;
</pre></div>
Some macros are also defined that support compile-time tests of the
library version:
<ul>
<li><code>XML_MAJOR_VERSION</code></li>
<li><code>XML_MINOR_VERSION</code></li>
<li><code>XML_MICRO_VERSION</code></li>
</ul>
Testing these constants is currently the best way to determine if
particular parts of the Expat API are available.
</div>
</dl>

</body>
</html>
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 2
a2 3
<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
d5 1
d11 3
a13 3
  <meta name="author" content="Clark Cooper, coopercc@@netheaven.com" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link href="style.css" rel="stylesheet" type="text/css" />
d18 3
a20 4
<p>Expat is a library, written in C, for parsing XML documents. It's
the underlying XML parser for the open source Mozilla project, Perl's
<code>XML::Parser</code>, Python's <code>xml.parsers.expat</code>, and
other open-source XML parsers.</p>
d23 8
a30 8
groff (an nroff look-alike), Jade (an implemention of ISO's DSSSL
stylesheet language for SGML), XP (a Java XML parser package), XT (a
Java XSL engine).  James was also the technical lead on the XML
Working Group at W3C that produced the XML specification.</p>

<p>This is free software, licensed under the <a
href="../COPYING">MIT/X Consortium license</a>. You may download it
from <a href="http://www.libexpat.org/">the Expat home page</a>.
d34 2
a35 2
<a href="http://www.xml.com/">XML.com</a>. They graciously allowed
Clark Cooper to retain copyright and to distribute it with Expat.</p>
d37 1
a37 1
<hr />
d42 2
a43 1
  <li><a href="#using">Using Expat</a></li>
d45 75
a119 85
  <ul>
    <li><a href="#creation">Parser Creation Functions</a>
    <ul>
      <li><a href="#XML_ParserCreate">XML_ParserCreate</a></li>
      <li><a href="#XML_ParserCreateNS">XML_ParserCreateNS</a></li>
      <li><a href="#XML_ParserCreate_MM">XML_ParserCreate_MM</a></li>
      <li><a href="#XML_ExternalEntityParserCreate">XML_ExternalEntityParserCreate</a></li>
      <li><a href="#XML_ParserFree">XML_ParserFree</a></li>
      <li><a href="#XML_ParserReset">XML_ParserReset</a></li>
    </ul>
    </li>
    <li><a href="#parsing">Parsing Functions</a>
    <ul>
      <li><a href="#XML_Parse">XML_Parse</a></li>
      <li><a href="#XML_ParseBuffer">XML_ParseBuffer</a></li>
      <li><a href="#XML_GetBuffer">XML_GetBuffer</a></li>
    </ul>
    </li>
    <li><a href="#setting">Handler Setting Functions</a>
    <ul>
      <li><a href="#XML_SetStartElementHandler">XML_SetStartElementHandler</a></li>
      <li><a href="#XML_SetEndElementHandler">XML_SetEndElementHandler</a></li>
      <li><a href="#XML_SetElementHandler">XML_SetElementHandler</a></li>
      <li><a href="#XML_SetCharacterDataHandler">XML_SetCharacterDataHandler</a></li>
      <li><a href="#XML_SetProcessingInstructionHandler">XML_SetProcessingInstructionHandler</a></li>
      <li><a href="#XML_SetCommentHandler">XML_SetCommentHandler</a></li>
      <li><a href="#XML_SetStartCdataSectionHandler">XML_SetStartCdataSectionHandler</a></li>
      <li><a href="#XML_SetEndCdataSectionHandler">XML_SetEndCdataSectionHandler</a></li>
      <li><a href="#XML_SetCdataSectionHandler">XML_SetCdataSectionHandler</a></li>
      <li><a href="#XML_SetDefaultHandler">XML_SetDefaultHandler</a></li>
      <li><a href="#XML_SetDefaultHandlerExpand">XML_SetDefaultHandlerExpand</a></li>
      <li><a href="#XML_SetExternalEntityRefHandler">XML_SetExternalEntityRefHandler</a></li>
      <li><a href="#XML_SetExternalEntityRefHandlerArg">XML_SetExternalEntityRefHandlerArg</a></li>
      <li><a href="#XML_SetSkippedEntityHandler">XML_SetSkippedEntityHandler</a></li>
      <li><a href="#XML_SetUnknownEncodingHandler">XML_SetUnknownEncodingHandler</a></li>
      <li><a href="#XML_SetStartNamespaceDeclHandler">XML_SetStartNamespaceDeclHandler</a></li>
      <li><a href="#XML_SetEndNamespaceDeclHandler">XML_SetEndNamespaceDeclHandler</a></li>
      <li><a href="#XML_SetNamespaceDeclHandler">XML_SetNamespaceDeclHandler</a></li>
      <li><a href="#XML_SetXmlDeclHandler">XML_SetXmlDeclHandler</a></li>		  
      <li><a href="#XML_SetStartDoctypeDeclHandler">XML_SetStartDoctypeDeclHandler</a></li>
      <li><a href="#XML_SetEndDoctypeDeclHandler">XML_SetEndDoctypeDeclHandler</a></li>
      <li><a href="#XML_SetDoctypeDeclHandler">XML_SetDoctypeDeclHandler</a></li>
      <li><a href="#XML_SetElementDeclHandler">XML_SetElementDeclHandler</a></li>
      <li><a href="#XML_SetAttlistDeclHandler">XML_SetAttlistDeclHandler</a></li>
      <li><a href="#XML_SetEntityDeclHandler">XML_SetEntityDeclHandler</a></li>
      <li><a href="#XML_SetUnparsedEntityDeclHandler">XML_SetUnparsedEntityDeclHandler</a></li>
      <li><a href="#XML_SetNotationDeclHandler">XML_SetNotationDeclHandler</a></li>
      <li><a href="#XML_SetNotStandaloneHandler">XML_SetNotStandaloneHandler</a></li>
    </ul>
    </li>
    <li><a href="#position">Parse Position and Error Reporting Functions</a>
    <ul>
      <li><a href="#XML_GetErrorCode">XML_GetErrorCode</a></li>
      <li><a href="#XML_ErrorString">XML_ErrorString</a></li>
      <li><a href="#XML_GetCurrentByteIndex">XML_GetCurrentByteIndex</a></li>
      <li><a href="#XML_GetCurrentLineNumber">XML_GetCurrentLineNumber</a></li>
      <li><a href="#XML_GetCurrentColumnNumber">XML_GetCurrentColumnNumber</a></li>
      <li><a href="#XML_GetCurrentByteCount">XML_GetCurrentByteCount</a></li>
      <li><a href="#XML_GetInputContext">XML_GetInputContext</a></li>
    </ul>
    </li>
    <li><a href="#miscellaneous">Miscellaneous Functions</a>
    <ul>
      <li><a href="#XML_SetUserData">XML_SetUserData</a></li>
      <li><a href="#XML_GetUserData">XML_GetUserData</a></li>
      <li><a href="#XML_UseParserAsHandlerArg">XML_UseParserAsHandlerArg</a></li>
      <li><a href="#XML_SetBase">XML_SetBase</a></li>
      <li><a href="#XML_GetBase">XML_GetBase</a></li>
      <li><a href="#XML_GetSpecifiedAttributeCount">XML_GetSpecifiedAttributeCount</a></li>
      <li><a href="#XML_GetIdAttributeIndex">XML_GetIdAttributeIndex</a></li>
      <li><a href="#XML_SetEncoding">XML_SetEncoding</a></li>
      <li><a href="#XML_SetParamEntityParsing">XML_SetParamEntityParsing</a></li>
      <li><a href="#XML_UseForeignDTD">XML_UseForeignDTD</a></li>
      <li><a href="#XML_SetReturnNSTriplet">XML_SetReturnNSTriplet</a></li>
      <li><a href="#XML_DefaultCurrent">XML_DefaultCurrent</a></li>
      <li><a href="#XML_ExpatVersion">XML_ExpatVersion</a></li>
      <li><a href="#XML_ExpatVersionInfo">XML_ExpatVersionInfo</a></li>
      <li><a href="#XML_GetFeatureList">XML_GetFeatureList</a></li>
      <li><a href="#XML_FreeContentModel">XML_FreeContentModel</a></li>
      <li><a href="#XML_MemMalloc">XML_MemMalloc</a></li>
      <li><a href="#XML_MemRealloc">XML_MemRealloc</a></li>
      <li><a href="#XML_MemFree">XML_MemFree</a></li>
    </ul>
    </li>
  </ul>  
d123 1
a123 1
<hr />
d125 12
a136 12

<p>Expat is a stream-oriented parser. You register callback (or
handler) functions with the parser and then start feeding it the
document.  As the parser recognizes parts of the document, it will
call the appropriate handler for that part (if you've registered one.) 
The document is fed to the parser in pieces, so you can start parsing
before you have all the document. This also allows you to parse really
huge documents that won't fit into memory.</p>

<p>Expat can be intimidating due to the many kinds of handlers and
options you can set. But you only need to learn four functions in
order to do 90% of what you'll want to do with it:</p>
d140 1
a140 2
<dt><code><a href= "#XML_ParserCreate"
             >XML_ParserCreate</a></code></dt>
d143 1
a143 2
<dt><code><a href= "#XML_SetElementHandler"
             >XML_SetElementHandler</a></code></dt>
d146 1
a146 2
<dt><code><a href= "#XML_SetCharacterDataHandler"
             >XML_SetCharacterDataHandler</a></code></dt>
d149 1
a149 2
<dt><code><a href= "#XML_Parse"
             >XML_Parse</a></code></dt>
d153 13
a165 14
<p>These functions and others are described in the <a
href="#reference">reference</a> part of this document. The reference
section also describes in detail the parameters passed to the
different types of handlers.</p>

<p>Let's look at a very simple example program that only uses 3 of the
above functions (it doesn't need to set a character handler.) The
program <a href="../examples/outline.c">outline.c</a> prints an
element outline, indenting child elements to distinguish them from the
parent element that contains them. The start handler does all the
work.  It prints two indenting spaces for every level of ancestor
elements, then it prints the element and attribute
information. Finally it increments the global <code>Depth</code>
variable.</p>
d167 2
a168 1
<pre class="eg">
d188 1
d190 3
a192 3
<p>The end tag simply does the bookkeeping work of decrementing
<code>Depth</code>.</p>
<pre class="eg">
d198 1
d201 1
a201 1
shoveling the document to the parser so that it can do its work.</p>
d203 7
a209 8
<hr />
<h2><a name="building">Building and Installing Expat</a></h2>

<p>The Expat distribution comes as a compressed (with GNU gzip) tar
file.  You may download the latest version from <a href=
"http://sourceforge.net/projects/expat/" >Source Forge</a>.  After
unpacking this, cd into the directory. Then follow either the Win32
directions or Unix directions below.</p>
d212 4
d217 2
a218 8
<p>If you're using the GNU compiler under cygwin, follow the Unix
directions in the next section. Otherwise if you have Microsoft's
Developer Studio installed, then from Windows Explorer double-click on
"expat.dsp" in the lib directory and build and install in the usual
manner.</p>

<p>Alternatively, you may download the Win32 binary package that
contains the "expat.h" include file and a pre-built DLL.</p>
d221 2
a222 3

<p>First you'll need to run the configure shell script in order to
configure the Makefiles and headers for your system.</p>
d225 2
a226 2
and you have permission on your system to install into /usr/local, you
can install Expat with this sequence of commands:</p>
d228 1
a228 1
<pre class="eg">
d235 4
a238 11
only one we'll mention here is the <code>--prefix</code> option. You
can find out all the options available by running configure with just
the <code>--help</code> option.</p>

<p>By default, the configure script sets things up so that the library
gets installed in <code>/usr/local/lib</code> and the associated
header file in <code>/usr/local/include</code>.  But if you were to
give the option, <code>--prefix=/home/me/mystuff</code>, then the
library and header would get installed in
<code>/home/me/mystuff/lib</code> and
<code>/home/me/mystuff/include</code> respectively.</p>
d240 10
a249 1
<hr />
d251 13
d265 2
a266 17
<h3>Compiling and Linking Against Expat</h3>

<p>Unless you installed Expat in a location not expected by your
compiler and linker, all you have to do to use Expat in your programs
is to include the Expat header (<code>#include &lt;expat.h&gt;</code>)
in your files that make calls to it and to tell the linker that it
needs to link against the Expat library.  On Unix systems, this would
usually be done with the <code>-lexpat</code> argument.  Otherwise,
you'll need to tell the compiler where to look for the Expat header
and the linker where to find the Expat library.  You may also need to
take steps to tell the operating system where to find this libary at
run time.</p>

<p>On a Unix-based system, here's what a Makefile might look like when
Expat is installed in a standard location:</p>

<pre class="eg">
d273 1
d275 1
a275 1
<p>If you installed Expat in, say, <code>/home/me/mystuff</code>, then
d278 2
a279 1
<pre class="eg">
d287 1
d289 5
a293 5
<p>You'd also have to set the environment variable
<code>LD_LIBRARY_PATH</code> to <code>/home/me/mystuff/lib</code> (or
to <code>${LD_LIBRARY_PATH}:/home/me/mystuff/lib</code> if
LD_LIBRARY_PATH already has some directories in it) in order to run
your application.</p>
d296 16
a311 15

<p>As we saw in the example in the overview, the first step in parsing
an XML document with Expat is to create a parser object. There are <a
href="#creation">three functions</a> in the Expat API for creating a
parser object.  However, only two of these (<code><a href=
"#XML_ParserCreate" >XML_ParserCreate</a></code> and <code><a href=
"#XML_ParserCreateNS" >XML_ParserCreateNS</a></code>) can be used for
constructing a parser for a top-level document.  The object returned
by these functions is an opaque pointer (i.e. "expat.h" declares it as
void *) to data with further internal structure. In order to free the
memory associated with this object you must call <code><a href=
"#XML_ParserFree" >XML_ParserFree</a></code>. Note that if you have
provided any <a href="userdata">user data</a> that gets stored in the
parser, then your application is responsible for freeing it prior to
calling <code>XML_ParserFree</code>.</p>
d314 26
a339 28
parsing only one XML document or external parsed entity. If your
application needs to parse many XML documents, then it needs to create
a parser object for each one. The best way to deal with this is to
create a higher level object that contains all the default
initialization you want for your parser objects.</p>

<p>Walking through a document hierarchy with a stream oriented parser
will require a good stack mechanism in order to keep track of current
context.  For instance, to answer the simple question, "What element
does this text belong to?" requires a stack, since the parser may have
descended into other elements that are children of the current one and
has encountered this text on the way out.</p>

<p>The things you're likely to want to keep on a stack are the
currently opened element and it's attributes. You push this
information onto the stack in the start handler and you pop it off in
the end handler.</p>

<p>For some tasks, it is sufficient to just keep information on what
the depth of the stack is (or would be if you had one.) The outline
program shown above presents one example. Another such task would be
skipping over a complete element. When you see the start tag for the
element you want to skip, you set a skip flag and record the depth at
which the element started.  When the end tag handler encounters the
same depth, the skipped element has ended and the flag may be
cleared. If you follow the convention that the root element starts at
1, then you can use the same variable for skip flag and skip
depth.</p>
d341 2
a342 1
<pre class="eg">
d377 1
d379 1
d381 8
a388 9
<p>Notice in the above example the difference in how depth is
manipulated in the start and end handlers. The end tag handler should
be the mirror image of the start tag handler. This is necessary to
properly model containment. Since, in the start tag handler, we
incremented depth <em>after</em> the main body of start tag code, then
in the end handler, we need to manipulate it <em>before</em> the main
body.  If we'd decided to increment it first thing in the start
handler, then we'd have had to decrement it last thing in the end
handler.</p>
d390 1
a390 1
<h3 id="userdata">Communicating between handlers</h3>
d394 4
a397 44
the shared variables. You can then tell Expat (with the <code><a href=
"#XML_SetUserData" >XML_SetUserData</a></code> function) to pass a
pointer to this structure to the handlers. This is typically the first
argument received by most handlers.</p>

<h3>XML Version</h3>

<p>Expat is an XML 1.0 parser, and as such never complains based on
the value of the <code>version</code> pseudo-attribute in the XML
declaration, if present.</p>

<p>If an application needs to check the version number (to support
alternate processing), it should use the <code><a href=
"#XML_SetXmlDeclHandler" >XML_SetXmlDeclHandler</a></code> function to
set a handler that uses the information in the XML declaration to
determine what to do.  This example shows how to check that only a
version number of <code>"1.0"</code> is accepted:</p>

<pre class="eg">
static int wrong_version;
static XML_Parser parser;

static void
xmldecl_handler(void            *userData,
                const XML_Char  *version,
                const XML_Char  *encoding,
                int              standalone)
{
  static const XML_Char Version_1_0[] = {'1', '.', '0', 0};

  int i;

  for (i = 0; i &lt; (sizeof(Version_1_0) / sizeof(Version_1_0[0])); ++i) {
    if (version[i] != Version_1_0[i]) {
      wrong_version = 1;
      /* also clear all other handlers: */
      XML_SetCharacterDataHandler(parser, NULL);
      ...
      return;
    }
  }
  ...
}
</pre>
d401 3
a403 4
<p>When the parser is created using the <code><a href=
"#XML_ParserCreateNS" >XML_ParserCreateNS</a></code>, function, Expat
performs namespace processing. Under namespace processing, Expat
consumes <code>xmlns</code> and <code>xmlns:...</code> attributes,
d405 42
a446 39
occur. This means that your start handler will not see these
attributes.  Your application can still be informed of these
declarations by setting namespace declaration handlers with <a href=
"#XML_SetNamespaceDeclHandler"
><code>XML_SetNamespaceDeclHandler</code></a>.</p>

<p>Element type and attribute names that belong to a given namespace
are passed to the appropriate handler in expanded form. By default
this expanded form is a concatenation of the namespace URI, the
separator character (which is the 2nd argument to <code><a href=
"#XML_ParserCreateNS" >XML_ParserCreateNS</a></code>), and the local
name (i.e. the part after the colon). Names with undeclared prefixes
are passed through to the handlers unchanged, with the prefix and
colon still attached. Unprefixed attribute names are never expanded,
and unprefixed element names are only expanded when they are in the
scope of a default namespace.</p>

<p>However if <code><a href= "XML_SetReturnNSTriplet"
>XML_SetReturnNSTriplet</a></code> has been called with a non-zero
<code>do_nst</code> parameter, then the expanded form for names with
an explicit prefix is a concatenation of: URI, separator, local name,
separator, prefix.</p>

<p>You can set handlers for the start of a namespace declaration and
for the end of a scope of a declaration with the <code><a href=
"#XML_SetNamespaceDeclHandler" >XML_SetNamespaceDeclHandler</a></code>
function.  The StartNamespaceDeclHandler is called prior to the start
tag handler and the EndNamespaceDeclHandler is called before the
corresponding end tag that ends the namespace's scope.  The namespace
start handler gets passed the prefix and URI for the namespace.  For a
default namespace declaration (xmlns='...'), the prefix will be null.
The URI will be null for the case where the default namespace is being
unset.  The namespace end handler just gets the prefix for the closing
scope.</p>

<p>These handlers are called for each declaration. So if, for
instance, a start tag had three namespace declarations, then the
StartNamespaceDeclHandler would be called three times before the start
tag handler is called, once for each declaration.</p>
d450 4
a453 5
<p>While XML is based on Unicode, and every XML processor is required
to recognized UTF-8 and UTF-16 (1 and 2 byte encodings of Unicode),
other encodings may be declared in XML documents or entities. For the
main document, an XML declaration may contain an encoding
declaration:</p>
d459 1
a459 1
looks like an XML declaration with just an encoding declaration:</p>
d464 3
a466 4
<p>With Expat, you may also specify an encoding at the time of
creating a parser. This is useful when the encoding information may
come from a source outside the document itself (like a higher level
protocol.)</p>
d468 1
a468 2
<p><a name="builtin_encodings"></a>There are four built-in encodings
in Expat:</p>
d470 4
a473 4
<li>UTF-8</li>
<li>UTF-16</li>
<li>ISO-8859-1</li>
<li>US-ASCII</li>
d480 10
a489 10
structure. Your handler must fill in this structure and return
<code>XML_STATUS_OK</code> if it knows how to deal with the
encoding. Otherwise the handler should return
<code>XML_STATUS_ERROR</code>.  The handler also gets passed a pointer
to an optional application data structure that you may indicate when
you set the handler.</p>

<p>Expat places restrictions on character encodings that it can
support by filling in the <code>XML_Encoding</code> structure.
include file:</p>
d502 14
a515 16
<p><code>XML_Encoding</code> contains an array of integers that
correspond to the 1st byte of an encoding sequence. If the value in
the array for a byte is zero or positive, then the byte is a single
byte encoding that encodes the Unicode scalar value contained in the
array. A -1 in this array indicates a malformed byte. If the value is
-2, -3, or -4, then the byte is the beginning of a 2, 3, or 4 byte
sequence respectively. Multi-byte sequences are sent to the convert
function pointed at in the <code>XML_Encoding</code> structure. This
function should return the Unicode scalar value for the sequence or -1
if the sequence is malformed.</p>

<p>One pitfall that novice Expat users are likely to fall into is that
although Expat may accept input in various encodings, the strings that
it passes to the handlers are always encoded in UTF-8 or UTF-16
(depending on how Expat was compiled). Your application is responsible
for any translation of these strings into other encodings.</p>
d519 16
a534 16
<p>Expat does not read or parse external entities directly. Note that
any external DTD is a special case of an external entity.  If you've
set no <code>ExternalEntityRefHandler</code>, then external entity
references are silently ignored. Otherwise, it calls your handler with
the information needed to read and parse the external entity.</p>

<p>Your handler isn't actually responsible for parsing the entity, but
it is responsible for creating a subsidiary parser with <code><a href=
"#XML_ExternalEntityParserCreate"
>XML_ExternalEntityParserCreate</a></code> that will do the job. This
returns an instance of <code>XML_Parser</code> that has handlers and
other data structures initialized from the parent parser. You may then
use <code><a href= "#XML_Parse" >XML_Parse</a></code> or <code><a
href= "#XML_ParseBuffer">XML_ParseBuffer</a></code> calls against this
parser.  Since external entities my refer to other external entities,
your handler should be prepared to be called recursively.</p>
d537 3
a539 5

<p>In order to parse parameter entities, before starting the parse,
you must call <code><a href= "#XML_SetParamEntityParsing"
>XML_SetParamEntityParsing</a></code> with one of the following
arguments:</p>
d550 2
a551 2
<p>In order to read an external DTD, you also have to set an external
entity reference handler as described above.</p>
d553 4
a556 1
<hr />
d563 1
a563 1
<pre class="fcndec" id="XML_ParserCreate">
d565 2
a566 2
XML_ParserCreate(const XML_Char *encoding);
</pre>
d572 4
a575 4
<li>US-ASCII</li>
<li>UTF-8</li>
<li>UTF-16</li>
<li>ISO-8859-1</li>
d580 1
a580 1
<pre class="fcndec" id="XML_ParserCreateNS">
d583 2
a584 2
                   XML_Char sep);
</pre>
d592 1
a592 1
<pre class="fcndec" id="XML_ParserCreate_MM">
d596 2
a597 9
		    const XML_Char *sep);
</pre>
<pre class="signature">
typedef struct {
  void *(*malloc_fcn)(size_t size);
  void *(*realloc_fcn)(void *ptr, size_t size);
  void (*free_fcn)(void *ptr);
} XML_Memory_Handling_Suite;
</pre>
d604 8
a611 1
the namespace URI and the local part of the name.</p>
d614 1
a614 1
<pre class="fcndec" id="XML_ExternalEntityParserCreate">
d618 2
a619 2
                               const XML_Char *encoding);
</pre>
d621 7
a627 7
Construct a new <code>XML_Parser</code> object for parsing an external
general entity. Context is the context argument passed in a call to a
ExternalEntityRefHandler. Other state information such as handlers,
user data, namespace processing is inherited from the parser passed as
the 1st argument. So you shouldn't need to call any of the behavior
changing functions on this parser (unless you want it to act
differently than the parent parser).
d630 1
a630 1
<pre class="fcndec" id="XML_ParserFree">
d632 2
a633 2
XML_ParserFree(XML_Parser p);
</pre>
d636 1
a636 16
freeing any memory associated with <a href="#userdata">user data</a>.
</div>

<pre class="fcndec" id="XML_ParserReset">
XML_Bool
XML_ParserReset(XML_Parser p);
</pre>
<div class="fcndef">
Clean up the memory structures maintained by the parser so that it may
be used again.  After this has been called, <code>parser</code> is
ready to start parsing a new document.  This function may not be used
on a parser created using <code><a href=
"#XML_ExternalEntityParserCreate" >XML_ExternalEntityParserCreate</a
></code>; it will return <code>XML_FALSE</code> in that case.  Returns
<code>XML_TRUE</code> on success.  Your application is responsible for
dealing with any memory associated with <a href="#userdata">user data</a>.
a640 10
<p>To state the obvious: the three parsing functions <code><a href=
"#XML_Parse" >XML_Parse</a></code>, <code><a href= "#XML_ParseBuffer"
>XML_ParseBuffer</a></code> and <code><a href= "#XML_GetBuffer"
>>XML_GetBuffer</a></code> must not be
called from within a handler unless they operate on a separate parser
instance, that is, one that did not call the handler. For example, it
is OK to call the parsing functions from within an
<code>XML_ExternalEntityRefHandler</code>, if they apply to the parser
created by <code><a href= "#XML_ExternalEntityParserCreate"
>XML_ExternalEntityParserCreate</a></code>.</p>
d642 2
a643 2
<pre class="fcndec" id="XML_Parse">
XML_Status
d647 2
a648 8
          int isFinal);
</pre>
<pre class="signature">
enum XML_Status {
  XML_STATUS_ERROR = 0,
  XML_STATUS_OK = 1
};
</pre>
d659 2
a660 2
If a parse error occurred, it returns <code>XML_STATUS_ERROR</code>.
Otherwise it returns <code>XML_STATUS_OK</code> value.
d663 2
a664 2
<pre class="fcndec" id="XML_ParseBuffer">
XML_Status
d667 2
a668 2
                int isFinal);
</pre>
d670 3
a672 5
This is just like <code><a href= "#XML_Parse" >XML_Parse</a></code>,
except in this case Expat provides the buffer.  By obtaining the
buffer from Expat with the <code><a href= "#XML_GetBuffer"
>XML_GetBuffer</a></code> function, the application can avoid double
copying of the input.
d675 1
a675 1
<pre class="fcndec" id="XML_GetBuffer">
d678 2
a679 2
              int len);
</pre>
d682 1
a682 1
into. A NULL value is returned if Expat can't allocate enough memory for
d684 1
a684 2
<code><a href= "#XML_ParseBuffer" >XML_ParseBuffer</a></code>. A
typical use would look like this:
d686 2
a687 1
<pre class="eg">
d696 1
a696 1
  if (bytes_read &lt; 0) {
d706 1
a706 1
}
d709 1
a711 1

d717 1
a717 1
is seen, and unset it for the corresponding end tag.</p>
d721 1
a721 1
a return value.</p>
d724 4
a727 4
<code>XML_Char</code>. This type is defined in expat.h as <code>char
*</code> and contains bytes encoding UTF-8.  Note that you'll receive
them in this form independent of the original encoding of the
document.</p>
d730 1
a730 1
<pre class="setter" id="XML_SetStartElementHandler">
d733 2
a734 2
</pre>
<pre class="signature">
d739 1
a739 1
</pre>
d750 1
a750 1
<pre class="setter" id="XML_SetEndElementHandler">
d753 2
a754 2
</pre>
<pre class="signature">
d758 1
a758 1
</pre>
d764 1
a764 1
<pre class="setter" id="XML_SetElementHandler">
d768 1
a768 1
</pre>
d773 1
a773 1
<pre class="setter" id="XML_SetCharacterDataHandler">
d776 2
a777 2
</pre>
<pre class="signature">
d782 1
a782 1
</pre>
d784 1
a784 1
is <em>NOT nul-terminated</em>. You have to use the length argument
d792 1
a792 1
<pre class="setter" id="XML_SetProcessingInstructionHandler">
d795 2
a796 2
</pre>
<pre class="signature">
d802 1
a802 1
</pre>
d809 1
a809 1
<pre class="setter" id="XML_SetCommentHandler">
d812 2
a813 2
</pre>
<pre class="signature">
d817 1
a817 1
</pre>
d823 1
a823 1
<pre class="setter" id="XML_SetStartCdataSectionHandler">
d826 2
a827 2
</pre>
<pre class="signature">
d830 1
a830 1
</pre>
d835 1
a835 1
<pre class="setter" id="XML_SetEndCdataSectionHandler">
d838 2
a839 2
</pre>
<pre class="signature">
d842 1
a842 1
</pre>
d847 1
a847 1
<pre class="setter" id="XML_SetCdataSectionHandler">
d851 1
a851 1
</pre>
d856 1
a856 1
<pre class="setter" id="XML_SetDefaultHandler">
d859 2
a860 2
</pre>
<pre class="signature">
d865 1
a865 2
</pre>

d867 5
a871 9
otherwise be handled. This includes both data for which no handlers
can be set (like some kinds of DTD declarations) and data which could
be reported but which currently has no handler set.  The characters
are passed exactly as they were present in the XML document except
that they will be encoded in UTF-8 or UTF-16. Line boundaries are not
normalized. Note that a byte order mark character is not passed to the
default handler. There are no guarantees about how characters are
divided between calls to the default handler: for example, a comment
might be split between multiple calls.  Setting the handler with
a874 3

<p>See also <code><a
href="#XML_DefaultCurrent">XML_DefaultCurrent</a></code>.</p>
d878 1
a878 1
<pre class="setter" id="XML_SetDefaultHandlerExpand">
d881 2
a882 2
</pre>
<pre class="signature">
d887 3
a889 7
</pre>
<p>This sets a default handler, but doesn't inhibit the expansion of
internal entity references.  The entity reference will not be passed
to the default handler.</p>

<p>See also <code><a
href="#XML_DefaultCurrent">XML_DefaultCurrent</a></code>.</p>
d893 1
a893 1
<pre class="setter" id="XML_SetExternalEntityRefHandler">
d896 2
a897 2
</pre>
<pre class="signature">
d904 1
a904 1
</pre>
d910 19
a928 30
<p>The <code>context</code> parameter specifies the parsing context in
the format expected by the <code>context</code> argument to <code><a
href="#XML_ExternalEntityParserCreate"
>XML_ExternalEntityParserCreate</a></code>.  <code>code</code> is
valid only until the handler returns, so if the referenced entity is
to be parsed later, it must be copied.  <code>context</code> is NULL
only when the entity is a parameter entity, which is how one can
differentiate between general and parameter entities.</p>

<p>The <code>base</code> parameter is the base to use for relative
system identifiers.  It is set by <code><a
href="#XML_SetBase">XML_SetBase</a></code> and may be NULL. The
<code>publicId</code> parameter is the public id given in the entity
declaration and may be NULL.  <code>systemId</code> is the system
identifier specified in the entity declaration and is never NULL.</p>

<p>There are a couple of ways in which this handler differs from
others.  First, this handler returns a status indicator (an
integer). <code>XML_STATUS_OK</code> should be returned for successful
handling of the external entity reference.  Returning
<code>XML_STATUS_ERROR</code> indicates failure, and causes the
calling parser to return an
<code>XML_ERROR_EXTERNAL_ENTITY_HANDLING</code> error.</p>

<p>Second, instead of having the user data as its first argument, it
receives the parser that encountered the entity reference. This, along
with the context parameter, may be used as arguments to a call to
<code><a href= "#XML_ExternalEntityParserCreate"
>XML_ExternalEntityParserCreate</a></code>.  Using the returned
parser, the body of the external entity can be recursively parsed.</p>
a933 24
<pre class="fcndec" id="XML_SetExternalEntityRefHandlerArg">
XML_SetExternalEntityRefHandlerArg(XML_Parser p,
                                   void *arg)
</pre>
<div class="fcndef">
<p>Set the argument passed to the ExternalEntityRefHandler.  If
<code>arg</code> is not NULL, it is the new value passed to the
handler set using <code><a href="#XML_SetExternalEntityRefHandler"
>XML_SetExternalEntityRefHandler</a></code>; if <code>arg</code> is
NULL, the argument passed to the handler function will be the parser
object itself.</p>

<p><strong>Note:</strong>
The type of <code>arg</code> and the type of the first argument to the
ExternalEntityRefHandler do not match.  This function takes a
<code>void *</code> to be passed to the handler, while the handler
accepts an <code>XML_Parser</code>.  This is a historical accident,
but will not be corrected before Expat 2.0 (at the earliest) to avoid
causing compiler warnings for code that's known to work with this
API.  It is the responsibility of the application code to know the
actual type of the argument passed to the handler and to manage it
properly.</p>
</div>

d935 1
a935 27
<pre class="setter" id="XML_SetSkippedEntityHandler">
XML_SetSkippedEntityHandler(XML_Parser p,
                            XML_SkippedEntityHandler handler)
</pre>
<pre class="signature">
typedef void
(*XML_SkippedEntityHandler)(void *userData,
                            const XML_Char *entityName,
                            int is_parameter_entity);
</pre>
<p>Set a skipped entity handler. This is called in two situations:</p>
<ol>
   <li>An entity reference is encountered for which no declaration
       has been read <em>and</em> this is not an error.</li>
   <li>An internal entity reference is read, but not expanded, because
       <a href="#XML_SetDefaultHandler"><code>XML_SetDefaultHandler</code></a>
	   has been called.</li>
</ol>
<p>The <code>is_parameter_entity</code> argument will be non-zero for
a parameter entity and zero for a general entity.</p> <p>Note: skipped
parameter entities in declarations and skipped general entities in
attribute values cannot be reported, because the event would be out of
sync with the reporting of the declarations or attribute values</p>
</div>

<div class="handler">
<pre class="setter" id="XML_SetUnknownEncodingHandler">
d939 2
a940 2
</pre>
<pre class="signature">
d945 5
d951 7
a957 6
typedef struct {
  int map[256];
  void *data;
  int (*convert)(void *data, const char *s);
  void (*release)(void *data);
} XML_Encoding;
a958 11
<p>Set a handler to deal with encodings other than the <a
href="#builtin_encodings">built in set</a>. This should be done before
<code><a href= "#XML_Parse" >XML_Parse</a></code> or <code><a href=
"#XML_ParseBuffer" >XML_ParseBuffer</a></code> have been called on the
given parser.</p> <p>If the handler knows how to deal with an encoding
with the given name, it should fill in the <code>info</code> data
structure and return <code>XML_STATUS_ERROR</code>. Otherwise it
should return <code>XML_STATUS_OK</code>. The handler will be called
at most once per parsed (external) entity. The optional application
data pointer <code>encodingHandlerData</code> will be passed back to
the handler.</p>
d969 2
a970 3
function is the data pointer from <code>XML_Encoding</code>. The
string s is <em>NOT</em> nul-terminated and points at the sequence of
bytes to be converted.</p>
d972 2
a973 2
<p>The function pointed at by <code>release</code> is called by the
parser when it is finished with the encoding. It may be NULL.</p>
d977 1
a977 1
<pre class="setter" id="XML_SetStartNamespaceDeclHandler">
d980 2
a981 2
</pre>
<pre class="signature">
d986 1
a986 1
</pre>
a990 6

<p><strong>Note:</strong>
Due to limitations of the implementation, the
StartNamespaceDeclHandler is not called unless the StartElementHandler
is also set.  The specific value of the StartElementHandler is allowed
to change freely, so long as it is not NULL.</p>
d994 1
a994 1
<pre class="setter" id="XML_SetEndNamespaceDeclHandler">
d997 2
a998 2
</pre>
<pre class="signature">
d1002 1
a1002 1
</pre>
d1004 3
a1006 9
declaration. This will be called, for each namespace declaration,
after the handler for the end tag of the element in which the
namespace was declared.</p>

<p><strong>Note:</strong>
Due to limitations of the implementation, the EndNamespaceDeclHandler
is not called unless the StartElementHandler is also set.  The
specific value of the StartElementHandler is allowed to change freely,
so long as it is not NULL.</p>
d1010 1
a1010 1
<pre class="setter" id="XML_SetNamespaceDeclHandler">
d1014 2
a1015 9
</pre>
<p>Sets both namespace declaration handlers with a single call.</p>

<p><strong>Note:</strong>
Due to limitations of the implementation, the
StartNamespaceDeclHandler and EndNamespaceDeclHandler are not called
unless the StartElementHandler is also set.  The specific value of the
StartElementHandler is allowed to change freely, so long as it is not
NULL.</p>
d1019 1
a1019 1
<pre class="setter" id="XML_SetXmlDeclHandler">
d1022 2
a1023 2
</pre>
<pre class="signature">
d1029 1
a1029 1
</pre>
d1031 6
a1036 7
text declarations discovered in external entities. The way to
distinguish is that the <code>version</code> parameter will be NULL
for text declarations. The <code>encoding</code> parameter may be NULL
for an XML declaration. The <code>standalone</code> argument will
contain -1, 0, or 1 indicating respectively that there was no
standalone parameter in the declaration, that it was given as no, or
that it was given as yes.</p>
d1040 1
a1040 1
<pre class="setter" id="XML_SetStartDoctypeDeclHandler">
d1043 2
a1044 2
</pre>
<pre class="signature">
d1051 1
a1051 1
</pre>
d1059 1
a1059 1
<pre class="setter" id="XML_SetEndDoctypeDeclHandler">
d1062 2
a1063 2
</pre>
<pre class="signature">
d1066 1
a1066 1
</pre>
d1072 1
a1072 1
<pre class="setter" id="XML_SetDoctypeDeclHandler">
d1076 1
a1076 1
</pre>
d1081 1
a1081 1
<pre class="setter" id="XML_SetElementDeclHandler">
d1084 2
a1085 2
</pre>
<pre class="signature">
d1090 2
a1091 2
</pre>
<pre class="signature">
d1117 5
a1121 7
</pre>
<p>Sets a handler for element declarations in a DTD. The handler gets
called with the name of the element in the declaration and a pointer
to a structure that contains the element model. It is the
application's responsibility to free this data structure using
<code><a href="#XML_FreeContentModel"
>XML_FreeContentModel</a></code>.</p>
d1126 14
a1139 16
<code>quant</code> will be <code>XML_CQUANT_NONE</code>, and the other
fields will be zero or NULL.  If <code>type</code> is
<code>XML_CTYPE_MIXED</code>, then <code>quant</code> will be
<code>XML_CQUANT_NONE</code> or <code>XML_CQUANT_REP</code> and
<code>numchildren</code> will contain the number of elements that are
allowed to be mixed in and <code>children</code> points to an array of
<code>XML_Content</code> structures that will all have type
XML_CTYPE_NAME with no quantification.  Only the root node can be type
<code>XML_CTYPE_EMPTY</code>, <code>XML_CTYPE_ANY</code>, or
<code>XML_CTYPE_MIXED</code>.</p>

<p>For type <code>XML_CTYPE_NAME</code>, the <code>name</code> field
points to the name and the <code>numchildren</code> and
<code>children</code> fields will be zero and NULL. The
<code>quant</code> field will indicate any quantifiers placed on the
name.</p>
d1142 3
a1144 3
indicate a choice or sequence respectively. The
<code>numchildren</code> field indicates how many nodes in the choice
or sequence and <code>children</code> points to the nodes.</p>
d1148 1
a1148 1
<pre class="setter" id="XML_SetAttlistDeclHandler">
d1151 2
a1152 2
</pre>
<pre class="signature">
d1160 9
a1168 9
</pre>
<p>Set a handler for attlist declarations in the DTD. This handler is
called for <em>each</em> attribute. So a single attlist declaration
with multiple attributes declared will generate multiple calls to this
handler. The <code>elname</code> parameter returns the name of the
element for which the attribute is being declared. The attribute name
is in the <code>attname</code> parameter. The attribute type is in the
<code>att_type</code> parameter.  It is the string representing the
type in the declaration with whitespace removed.</p>
d1170 2
a1171 2
<p>The <code>dflt</code> parameter holds the default value. It will be
NULL in the case of "#IMPLIED" or "#REQUIRED" attributes. You can
d1175 3
a1177 2
<code>isrequired</code>, but they will have the non-NULL fixed value
in the <code>dflt</code> parameter.</p>
d1181 1
a1181 1
<pre class="setter" id="XML_SetEntityDeclHandler">
d1184 2
a1185 2
</pre>
<pre class="signature">
d1196 1
a1196 1
</pre>
d1198 3
a1200 3
The <code>is_parameter_entity</code> argument will be non-zero in the
case of parameter entities and zero otherwise.</p>

d1204 6
a1209 7
The value string is <em>not</em> NULL terminated; the length is
provided in the <code>value_length</code> parameter. Do not use
<code>value_length</code> to test for internal entities, since it is
legal to have zero-length values. Instead check for whether or not
<code>value</code> is NULL.</p> <p>The <code>notationName</code>
argument will have a non-NULL value only for unparsed entity
declarations.</p>
d1213 1
a1213 1
<pre class="setter" id="XML_SetUnparsedEntityDeclHandler">
d1216 2
a1217 2
</pre>
<pre class="signature">
d1225 1
a1225 1
</pre>
d1232 4
a1235 3
<p>This handler is obsolete and is provided for backwards
compatibility.  Use instead <a href= "#XML_SetEntityDeclHandler"
>XML_SetEntityDeclHandler</a>.</p>
d1239 1
a1239 1
<pre class="setter" id="XML_SetNotationDeclHandler">
d1242 2
a1243 2
</pre>
<pre class="signature">
d1250 1
a1250 1
</pre>
d1255 1
a1255 1
<pre class="setter" id="XML_SetNotStandaloneHandler">
d1258 2
a1259 2
</pre>
<pre class="signature">
d1262 1
a1262 1
</pre>
d1264 4
a1267 5
This happens when there is an external subset or a reference to a
parameter entity, but does not have standalone set to "yes" in an XML
declaration.  If this handler returns <code>XML_STATUS_ERROR</code>,
then the parser will throw an <code>XML_ERROR_NOT_STANDALONE</code>
error.</p>
d1271 9
d1281 1
a1281 13
<p>These are the functions you'll want to call when the parse
functions return <code>XML_STATUS_ERROR</code> (a parse error has
ocurred), although the position reporting functions are useful outside
of errors. The position reported is the byte position (in the original
document or entity encoding) of the first of the sequence of
characters that generated the current event (or the error that caused
the parse functions to return <code>XML_STATUS_ERROR</code>.)</p>

<p>The position reporting functions are accurate only outside of the
DTD.  In other words, they usually return bogus information when
called from within a DTD declaration handler.</p>

<pre class="fcndec" id="XML_GetErrorCode">
d1283 2
a1284 2
XML_GetErrorCode(XML_Parser p);
</pre>
d1289 1
a1289 1
<pre class="fcndec" id="XML_ErrorString">
d1291 2
a1292 2
XML_ErrorString(int code);
</pre>
d1296 1
a1296 1
<code><a href= "#XML_GetErrorCode" >XML_GetErrorCode</a></code>.
d1299 1
a1299 1
<pre class="fcndec" id="XML_GetCurrentByteIndex">
d1301 2
a1302 2
XML_GetCurrentByteIndex(XML_Parser p);
</pre>
d1307 1
a1307 1
<pre class="fcndec" id="XML_GetCurrentLineNumber">
d1309 2
a1310 2
XML_GetCurrentLineNumber(XML_Parser p);
</pre>
d1315 1
a1315 1
<pre class="fcndec" id="XML_GetCurrentColumnNumber">
d1317 2
a1318 2
XML_GetCurrentColumnNumber(XML_Parser p);
</pre>
d1324 1
a1324 1
<pre class="fcndec" id="XML_GetCurrentByteCount">
d1327 1
a1327 1
</pre>
d1329 2
a1330 5
Return the number of bytes in the current event. Returns
<code>0</code> if the event is inside a reference to an internal
entity and for the end-tag event for empty element tags (the later can
be used to distinguish empty-element tags from empty elements using
separate start and end tags).
d1333 1
a1333 1
<pre class="fcndec" id="XML_GetInputContext">
d1338 1
a1338 1
</pre>
a1339 1

d1342 2
a1343 3
parse position, and set the integer pointed at by <code>size</code> to
the size of the returned buffer.</p>

d1346 5
a1350 6
the handler that made the call. This input buffer contains the
untranslated bytes of the input.</p>

<p>Only a limited amount of context is kept, so if the event
triggering a call spans over a very large amount of input, the actual
parse position may be before the beginning of the buffer.</p>
d1354 2
d1357 1
a1357 4
<p>The functions in this section either obtain state information from
the parser or can be used to dynamicly set parser options.</p>

<pre class="fcndec" id="XML_SetUserData">
d1360 2
a1361 2
                void *userData);
</pre>
d1363 2
a1364 2
This sets the user data pointer that gets passed to handlers.  It
overwrites any previous value for this pointer. Note that the
d1366 3
a1368 3
<code>userData</code> when it is finished with the parser. So if you
call this when there's already a pointer there, and you haven't freed
the memory associated with it, then you've probably just leaked
d1372 1
a1372 1
<pre class="fcndec" id="XML_GetUserData">
d1374 2
a1375 2
XML_GetUserData(XML_Parser p);
</pre>
d1381 1
a1381 1
<pre class="fcndec" id="XML_UseParserAsHandlerArg">
d1383 2
a1384 2
XML_UseParserAsHandlerArg(XML_Parser p);
</pre>
d1386 3
a1388 4
After this is called, handlers receive the parser in their
<code>userData</code> arguments.  The user data can still be obtained
using the <code><a href= "#XML_GetUserData"
>XML_GetUserData</a></code> function.
d1391 2
a1392 2
<pre class="fcndec" id="XML_SetBase">
enum XML_Status
d1394 2
a1395 2
            const XML_Char *base);
</pre>
d1397 3
a1399 4
Set the base to be used for resolving relative URIs in system
identifiers.  The return value is <code>XML_STATUS_ERROR</code> if
there's no memory to store base, otherwise it's
<code>XML_STATUS_OK</code>.
d1402 1
a1402 1
<pre class="fcndec" id="XML_GetBase">
d1404 2
a1405 2
XML_GetBase(XML_Parser p);
</pre>
d1410 1
a1410 1
<pre class="fcndec" id="XML_GetSpecifiedAttributeCount">
d1412 2
a1413 2
XML_GetSpecifiedAttributeCount(XML_Parser p);
</pre>
d1418 5
a1422 6
ATTLIST declaration. This function returns the number of attributes
that were explicitly set times two, thus giving the offset in the
<code>atts</code> array passed to the start tag handler of the first
attribute set due to defaults. It supplies information for the last
call to a start handler. If called inside a start handler, then that
means the current call.
d1425 1
a1425 1
<pre class="fcndec" id="XML_GetIdAttributeIndex">
d1428 1
a1428 1
</pre>
d1430 3
a1432 5
Returns the index of the ID attribute passed in the atts array in the
last call to <code><a href= "#XML_StartElementHandler"
>XML_StartElementHandler</a></code>, or -1 if there is no ID
attribute. If called inside a start handler, then that means the
current call.
d1435 2
a1436 2
<pre class="fcndec" id="XML_SetEncoding">
enum XML_Status
d1438 2
a1439 2
                const XML_Char *encoding);
</pre>
d1443 2
a1444 5
It must not be called after <code><a href= "#XML_Parse"
>XML_Parse</a></code> or <code><a href= "#XML_ParseBuffer"
>XML_ParseBuffer</a></code> have been called on the given parser.
Returns <code>XML_STATUS_OK</code> on success or
<code>XML_STATUS_ERROR</code> on error.
d1447 1
a1447 1
<pre class="fcndec" id="XML_SetParamEntityParsing">
d1450 2
a1451 2
                          enum XML_ParamEntityParsing code);
</pre>
d1464 1
a1464 33
<pre class="fcndec" id="XML_UseForeignDTD">
enum XML_Error
XML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD);
</pre>
<div class="fcndef">
<p>This function allows an application to provide an external subset
for the document type declaration for documents which do not specify
an external subset of their own.  For documents which specify an
external subset in their DOCTYPE declaration, the application-provided
subset will be ignored.  If the document does not contain a DOCTYPE
declaration at all and <code>useDTD</code> is true, the
application-provided subset will be parsed, but the
<code>startDoctypeDeclHandler</code> and
<code>endDoctypeDeclHandler</code> functions, if set, will not be
called.  The setting of parameter entity parsing, controlled using
<code><a href= "#XML_SetParamEntityParsing"
>XML_SetParamEntityParsing</a></code>, will be honored.</p>

<p>The application-provided external subset is read by calling the
external entity reference handler set via <code><a href=
"#XML_SetExternalEntityRefHandler"
>XML_SetExternalEntityRefHandler</a></code> with both
<code>publicId</code> and <code>systemId</code> set to NULL.</p>

<p>If this function is called after parsing has begun, it returns
<code>XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING</code> and ignores
<code>useDTD</code>.  If called when Expat has been compiled without
DTD support, it returns
<code>XML_ERROR_FEATURE_REQUIRES_XML_DTD</code>.  Otherwise, it
returns <code>XML_ERROR_NONE</code>.</p>
</div>

<pre class="fcndec" id="XML_SetReturnNSTriplet">
d1468 1
a1468 1
</pre>
d1472 10
a1481 12
<code><a href= "#XML_ParserCreateNS" >XML_ParserCreateNS</a></code>,
i.e. when namespace processing is in effect. The <code>do_nst</code>
sets whether or not prefixes are returned with names qualified with a
namespace prefix. If this function is called with <code>do_nst</code>
non-zero, then afterwards namespace qualified names (that is qualified
with a prefix as opposed to belonging to a default namespace) are
returned as a triplet with the three parts separated by the namespace
separator specified when the parser was created.  The order of
returned parts is URI, local name, and prefix.</p> <p>If
<code>do_nst</code> is zero, then namespaces are reported in the
default manner, URI then local_name separated by the namespace
separator.</p>
d1484 1
a1484 15
<pre class="fcndec" id="XML_DefaultCurrent">
void
XML_DefaultCurrent(XML_Parser parser);
</pre>
<div class="fcndef">
This can be called within a handler for a start element, end element,
processing instruction or character data.  It causes the corresponding
markup to be passed to the default handler set by <code><a
href="#XML_SetDefaultHandler" >XML_SetDefaultHandler</a></code> or
<code><a href="#XML_SetDefaultHandlerExpand"
>XML_SetDefaultHandlerExpand</a></code>.  It does nothing if there is
not a default handler.
</div>

<pre class="fcndec" id="XML_ExpatVersion">
d1487 1
a1487 1
</pre>
d1489 1
a1489 1
Return the library version as a string (e.g. <code>"expat_1.95.1"</code>).
d1492 2
a1493 2
<pre class="fcndec" id="XML_ExpatVersionInfo">
struct XML_Expat_Version
d1495 4
a1498 2
</pre>
<pre class="signature">
d1504 1
a1504 3
</pre>
<div class="fcndef">
Return the library version information as a structure.
a1514 57

<pre class="fcndec" id="XML_GetFeatureList">
const XML_Feature *
XML_GetFeatureList();
</pre>
<pre class="signature">
enum XML_FeatureEnum {
  XML_FEATURE_END = 0,
  XML_FEATURE_UNICODE,
  XML_FEATURE_UNICODE_WCHAR_T,
  XML_FEATURE_DTD,
  XML_FEATURE_CONTEXT_BYTES,
  XML_FEATURE_MIN_SIZE,
  XML_FEATURE_SIZEOF_XML_CHAR,
  XML_FEATURE_SIZEOF_XML_LCHAR
};

typedef struct {
  enum XML_FeatureEnum  feature;
  XML_LChar            *name;
  long int              value;
} XML_Feature;
</pre>
<div class="fcndef">
<p>Returns a list of "feature" records, providing details on how
Expat was configured at compile time.  Most applications should not
need to worry about this, but this information is otherwise not
available from Expat.  This function allows code that does need to
check these features to do so at runtime.</p>

<p>The return value is an array of <code>XML_Feature</code>,
terminated by a record with a <code>feature</code> of
<code>XML_FEATURE_END</code> and <code>name</code> of NULL,
identifying the feature-test macros Expat was compiled with.  Since an
application that requires this kind of information needs to determine
the type of character the <code>name</code> points to, records for the
<code>XML_FEATURE_SIZEOF_XML_CHAR</code> and
<code>XML_FEATURE_SIZEOF_XML_LCHAR</code> will be located at the
beginning of the list, followed by <code>XML_FEATURE_UNICODE</code>
and <code>XML_FEATURE_UNICODE_WCHAR_T</code>, if they are present at
all.</p>

<p>Some features have an associated value.  If there isn't an
associated value, the <code>value</code> field is set to 0.  At this
time, the following features have been defined to have values:</p>

<dl>
  <dt><code>XML_FEATURE_SIZEOF_XML_CHAR</code></dt>
  <dd>The number of bytes occupied by one <code>XML_Char</code>
  character.</dd>
  <dt><code>XML_FEATURE_SIZEOF_XML_LCHAR</code></dt>
  <dd>The number of bytes occupied by one <code>XML_LChar</code>
  character.</dd>
  <dt><code>XML_FEATURE_CONTEXT_BYTES</code></dt>
  <dd>The maximum number of characters of context which can be
  reported by <code><a href= "#XML_GetInputContext"
  >XML_GetInputContext</a></code>.</dd>
a1515 61
</div>

<pre class="fcndec" id="XML_FreeContentModel">
void
XML_FreeContentModel(XML_Parser parser, XML_Content *model);
</pre>
<div class="fcndef">
Function to deallocate the <code>model</code> argument passed to the
<code>XML_ElementDeclHandler</code> callback set using <code><a
href="#XML_SetElementDeclHandler" >XML_ElementDeclHandler</a></code>.
This function should not be used for any other purpose.
</div>

<p>The following functions allow external code to share the memory
allocator an <code>XML_Parser</code> has been configured to use.  This
is especially useful for third-party libraries that interact with a
parser object created by application code, or heavily layered
applications.  This can be essential when using dynamically loaded
libraries which use different C standard libraries (this can happen on
Windows, at least).</p>

<pre class="fcndec" id="XML_MemMalloc">
void *
XML_MemMalloc(XML_Parser parser, size_t size);
</pre>
<div class="fcndef">
Allocate <code>size</code> bytes of memory using the allocator the
<code>parser</code> object has been configured to use.  Returns a
pointer to the memory or NULL on failure.  Memory allocated in this
way must be freed using <code><a href="#XML_MemFree"
>XML_MemFree</a></code>.
</div>

<pre class="fcndec" id="XML_MemRealloc">
void *
XML_MemRealloc(XML_Parser parser, void *ptr, size_t size);
</pre>
<div class="fcndef">
Allocate <code>size</code> bytes of memory using the allocator the
<code>parser</code> object has been configured to use.
<code>ptr</code> must point to a block of memory allocated by <code><a
href="#XML_MemMalloc" >XML_MemMalloc</a></code> or
<code>XML_MemRealloc</code>, or be NULL.  This function tries to
expand the block pointed to by <code>ptr</code> if possible.  Returns
a pointer to the memory or NULL on failure.  On success, the original
block has either been expanded or freed.  On failure, the original
block has not been freed; the caller is responsible for freeing the
original block.  Memory allocated in this way must be freed using
<code><a href="#XML_MemFree"
>XML_MemFree</a></code>.
</div>

<pre class="fcndec" id="XML_MemFree">
void
XML_MemFree(XML_Parser parser, void *ptr);
</pre>
<div class="fcndef">
Free a block of memory pointed to by <code>ptr</code>.  The block must
have been allocated by <code><a href="#XML_MemMalloc"
>XML_MemMalloc</a></code> or <code>XML_MemRealloc</code>, or be NULL.
</div>
a1516 4
<hr />
<p><a href="http://validator.w3.org/check/referer"><img
        src="valid-xhtml10.png" alt="Valid XHTML 1.0!"
        height="31" width="88" class="noborder" /></a></p>
@


1.1.1.1
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@@


1.1.1.2
log
@Import OpenBSD tree again due to CVS bugs
@
text
@d30 1
a30 1
<a href="http://www.libexpat.org/">the Expat home page</a>.
d64 1
a64 1
	      <li><a href="#XML_SetStartElementHandler">XML_SetStartElementHandler</a></li>
d66 1
a66 1
	      <li><a href="#XML_SetElementHandler">XML_SetElementHandler</a></li>
a75 1
		  <li><a href="#XML_SetSkippedEntityHandler">XML_SetSkippedEntityHandler</a></li>
d94 1
a94 1
	      <li><a href="#XML_GetErrorCode">XML_GetErrorCode</a></li>
d105 1
a105 1
	      <li><a href="#XML_SetUserData">XML_SetUserData</a></li>
a934 26
<div class="setter"><a name="XML_SetSkippedEntityHandler"><pre>
XML_SetSkippedEntityHandler(XML_Parser p,
                            XML_SkippedEntityHandler handler)
</pre></a></div>
<div class="signature"><pre>
typedef void
(*XML_SkippedEntityHandler)(void *userData,
                            const XML_Char *entityName,
                            int is_parameter_entity);
</pre></div>
<p>Set a skipped entity handler. This is called in two situations:</p>
<ol>
   <li>An entity reference is encountered for which no declaration
       has been read *and* this is not an error.</li>
   <li>An internal entity reference is read, but not expanded, because
       <a href="#XML_SetDefaultHandler"><code>XML_SetDefaultHandler</code></a>
	   has been called.</li>
</ol>
<p>The <code>is_parameter_entity</code> argument will be non-zero for
a parameter entity and zero for a general entity.</p>
<p>Note: skipped parameter entities in declarations and skipped general
entities in attribute values cannot be reported, because the event would
be out of sync with the reporting of the declarations or attribute values</p>
</div>

<div class="handler">
d938 1
a938 1
			                  void *encodingHandlerData)
d1329 2
a1330 5
Return the number of bytes in the current event. Returns
<code>0</code> if the event is inside a reference to an internal
entity and for the end-tag event for empty element tags (the later can
be used to distinguish empty-element tags from empty elements using
separate start and end tags).
@


1.1.1.3
log
@sync with OpenBSD's idea of X-Window as of now();
@
text
@d1 2
a2 3
<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
d5 1
d11 3
a13 3
  <meta name="author" content="Clark Cooper, coopercc@@netheaven.com" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link href="style.css" rel="stylesheet" type="text/css" />
d18 3
a20 4
<p>Expat is a library, written in C, for parsing XML documents. It's
the underlying XML parser for the open source Mozilla project, Perl's
<code>XML::Parser</code>, Python's <code>xml.parsers.expat</code>, and
other open-source XML parsers.</p>
d23 8
a30 8
groff (an nroff look-alike), Jade (an implemention of ISO's DSSSL
stylesheet language for SGML), XP (a Java XML parser package), XT (a
Java XSL engine).  James was also the technical lead on the XML
Working Group at W3C that produced the XML specification.</p>

<p>This is free software, licensed under the <a
href="../COPYING">MIT/X Consortium license</a>. You may download it
from <a href="http://www.libexpat.org/">the Expat home page</a>.
d34 2
a35 2
<a href="http://www.xml.com/">XML.com</a>. They graciously allowed
Clark Cooper to retain copyright and to distribute it with Expat.</p>
d37 1
a37 1
<hr />
d42 2
a43 1
  <li><a href="#using">Using Expat</a></li>
d45 76
a120 85
  <ul>
    <li><a href="#creation">Parser Creation Functions</a>
    <ul>
      <li><a href="#XML_ParserCreate">XML_ParserCreate</a></li>
      <li><a href="#XML_ParserCreateNS">XML_ParserCreateNS</a></li>
      <li><a href="#XML_ParserCreate_MM">XML_ParserCreate_MM</a></li>
      <li><a href="#XML_ExternalEntityParserCreate">XML_ExternalEntityParserCreate</a></li>
      <li><a href="#XML_ParserFree">XML_ParserFree</a></li>
      <li><a href="#XML_ParserReset">XML_ParserReset</a></li>
    </ul>
    </li>
    <li><a href="#parsing">Parsing Functions</a>
    <ul>
      <li><a href="#XML_Parse">XML_Parse</a></li>
      <li><a href="#XML_ParseBuffer">XML_ParseBuffer</a></li>
      <li><a href="#XML_GetBuffer">XML_GetBuffer</a></li>
    </ul>
    </li>
    <li><a href="#setting">Handler Setting Functions</a>
    <ul>
      <li><a href="#XML_SetStartElementHandler">XML_SetStartElementHandler</a></li>
      <li><a href="#XML_SetEndElementHandler">XML_SetEndElementHandler</a></li>
      <li><a href="#XML_SetElementHandler">XML_SetElementHandler</a></li>
      <li><a href="#XML_SetCharacterDataHandler">XML_SetCharacterDataHandler</a></li>
      <li><a href="#XML_SetProcessingInstructionHandler">XML_SetProcessingInstructionHandler</a></li>
      <li><a href="#XML_SetCommentHandler">XML_SetCommentHandler</a></li>
      <li><a href="#XML_SetStartCdataSectionHandler">XML_SetStartCdataSectionHandler</a></li>
      <li><a href="#XML_SetEndCdataSectionHandler">XML_SetEndCdataSectionHandler</a></li>
      <li><a href="#XML_SetCdataSectionHandler">XML_SetCdataSectionHandler</a></li>
      <li><a href="#XML_SetDefaultHandler">XML_SetDefaultHandler</a></li>
      <li><a href="#XML_SetDefaultHandlerExpand">XML_SetDefaultHandlerExpand</a></li>
      <li><a href="#XML_SetExternalEntityRefHandler">XML_SetExternalEntityRefHandler</a></li>
      <li><a href="#XML_SetExternalEntityRefHandlerArg">XML_SetExternalEntityRefHandlerArg</a></li>
      <li><a href="#XML_SetSkippedEntityHandler">XML_SetSkippedEntityHandler</a></li>
      <li><a href="#XML_SetUnknownEncodingHandler">XML_SetUnknownEncodingHandler</a></li>
      <li><a href="#XML_SetStartNamespaceDeclHandler">XML_SetStartNamespaceDeclHandler</a></li>
      <li><a href="#XML_SetEndNamespaceDeclHandler">XML_SetEndNamespaceDeclHandler</a></li>
      <li><a href="#XML_SetNamespaceDeclHandler">XML_SetNamespaceDeclHandler</a></li>
      <li><a href="#XML_SetXmlDeclHandler">XML_SetXmlDeclHandler</a></li>		  
      <li><a href="#XML_SetStartDoctypeDeclHandler">XML_SetStartDoctypeDeclHandler</a></li>
      <li><a href="#XML_SetEndDoctypeDeclHandler">XML_SetEndDoctypeDeclHandler</a></li>
      <li><a href="#XML_SetDoctypeDeclHandler">XML_SetDoctypeDeclHandler</a></li>
      <li><a href="#XML_SetElementDeclHandler">XML_SetElementDeclHandler</a></li>
      <li><a href="#XML_SetAttlistDeclHandler">XML_SetAttlistDeclHandler</a></li>
      <li><a href="#XML_SetEntityDeclHandler">XML_SetEntityDeclHandler</a></li>
      <li><a href="#XML_SetUnparsedEntityDeclHandler">XML_SetUnparsedEntityDeclHandler</a></li>
      <li><a href="#XML_SetNotationDeclHandler">XML_SetNotationDeclHandler</a></li>
      <li><a href="#XML_SetNotStandaloneHandler">XML_SetNotStandaloneHandler</a></li>
    </ul>
    </li>
    <li><a href="#position">Parse Position and Error Reporting Functions</a>
    <ul>
      <li><a href="#XML_GetErrorCode">XML_GetErrorCode</a></li>
      <li><a href="#XML_ErrorString">XML_ErrorString</a></li>
      <li><a href="#XML_GetCurrentByteIndex">XML_GetCurrentByteIndex</a></li>
      <li><a href="#XML_GetCurrentLineNumber">XML_GetCurrentLineNumber</a></li>
      <li><a href="#XML_GetCurrentColumnNumber">XML_GetCurrentColumnNumber</a></li>
      <li><a href="#XML_GetCurrentByteCount">XML_GetCurrentByteCount</a></li>
      <li><a href="#XML_GetInputContext">XML_GetInputContext</a></li>
    </ul>
    </li>
    <li><a href="#miscellaneous">Miscellaneous Functions</a>
    <ul>
      <li><a href="#XML_SetUserData">XML_SetUserData</a></li>
      <li><a href="#XML_GetUserData">XML_GetUserData</a></li>
      <li><a href="#XML_UseParserAsHandlerArg">XML_UseParserAsHandlerArg</a></li>
      <li><a href="#XML_SetBase">XML_SetBase</a></li>
      <li><a href="#XML_GetBase">XML_GetBase</a></li>
      <li><a href="#XML_GetSpecifiedAttributeCount">XML_GetSpecifiedAttributeCount</a></li>
      <li><a href="#XML_GetIdAttributeIndex">XML_GetIdAttributeIndex</a></li>
      <li><a href="#XML_SetEncoding">XML_SetEncoding</a></li>
      <li><a href="#XML_SetParamEntityParsing">XML_SetParamEntityParsing</a></li>
      <li><a href="#XML_UseForeignDTD">XML_UseForeignDTD</a></li>
      <li><a href="#XML_SetReturnNSTriplet">XML_SetReturnNSTriplet</a></li>
      <li><a href="#XML_DefaultCurrent">XML_DefaultCurrent</a></li>
      <li><a href="#XML_ExpatVersion">XML_ExpatVersion</a></li>
      <li><a href="#XML_ExpatVersionInfo">XML_ExpatVersionInfo</a></li>
      <li><a href="#XML_GetFeatureList">XML_GetFeatureList</a></li>
      <li><a href="#XML_FreeContentModel">XML_FreeContentModel</a></li>
      <li><a href="#XML_MemMalloc">XML_MemMalloc</a></li>
      <li><a href="#XML_MemRealloc">XML_MemRealloc</a></li>
      <li><a href="#XML_MemFree">XML_MemFree</a></li>
    </ul>
    </li>
  </ul>  
d124 1
a124 1
<hr />
d126 12
a137 12

<p>Expat is a stream-oriented parser. You register callback (or
handler) functions with the parser and then start feeding it the
document.  As the parser recognizes parts of the document, it will
call the appropriate handler for that part (if you've registered one.) 
The document is fed to the parser in pieces, so you can start parsing
before you have all the document. This also allows you to parse really
huge documents that won't fit into memory.</p>

<p>Expat can be intimidating due to the many kinds of handlers and
options you can set. But you only need to learn four functions in
order to do 90% of what you'll want to do with it:</p>
d141 1
a141 2
<dt><code><a href= "#XML_ParserCreate"
             >XML_ParserCreate</a></code></dt>
d144 1
a144 2
<dt><code><a href= "#XML_SetElementHandler"
             >XML_SetElementHandler</a></code></dt>
d147 1
a147 2
<dt><code><a href= "#XML_SetCharacterDataHandler"
             >XML_SetCharacterDataHandler</a></code></dt>
d150 1
a150 2
<dt><code><a href= "#XML_Parse"
             >XML_Parse</a></code></dt>
d154 13
a166 14
<p>These functions and others are described in the <a
href="#reference">reference</a> part of this document. The reference
section also describes in detail the parameters passed to the
different types of handlers.</p>

<p>Let's look at a very simple example program that only uses 3 of the
above functions (it doesn't need to set a character handler.) The
program <a href="../examples/outline.c">outline.c</a> prints an
element outline, indenting child elements to distinguish them from the
parent element that contains them. The start handler does all the
work.  It prints two indenting spaces for every level of ancestor
elements, then it prints the element and attribute
information. Finally it increments the global <code>Depth</code>
variable.</p>
d168 2
a169 1
<pre class="eg">
d189 1
d191 3
a193 3
<p>The end tag simply does the bookkeeping work of decrementing
<code>Depth</code>.</p>
<pre class="eg">
d199 1
d202 1
a202 1
shoveling the document to the parser so that it can do its work.</p>
d204 7
a210 8
<hr />
<h2><a name="building">Building and Installing Expat</a></h2>

<p>The Expat distribution comes as a compressed (with GNU gzip) tar
file.  You may download the latest version from <a href=
"http://sourceforge.net/projects/expat/" >Source Forge</a>.  After
unpacking this, cd into the directory. Then follow either the Win32
directions or Unix directions below.</p>
d213 4
d218 2
a219 8
<p>If you're using the GNU compiler under cygwin, follow the Unix
directions in the next section. Otherwise if you have Microsoft's
Developer Studio installed, then from Windows Explorer double-click on
"expat.dsp" in the lib directory and build and install in the usual
manner.</p>

<p>Alternatively, you may download the Win32 binary package that
contains the "expat.h" include file and a pre-built DLL.</p>
d222 2
a223 3

<p>First you'll need to run the configure shell script in order to
configure the Makefiles and headers for your system.</p>
d226 2
a227 2
and you have permission on your system to install into /usr/local, you
can install Expat with this sequence of commands:</p>
d229 1
a229 1
<pre class="eg">
d236 4
a239 11
only one we'll mention here is the <code>--prefix</code> option. You
can find out all the options available by running configure with just
the <code>--help</code> option.</p>

<p>By default, the configure script sets things up so that the library
gets installed in <code>/usr/local/lib</code> and the associated
header file in <code>/usr/local/include</code>.  But if you were to
give the option, <code>--prefix=/home/me/mystuff</code>, then the
library and header would get installed in
<code>/home/me/mystuff/lib</code> and
<code>/home/me/mystuff/include</code> respectively.</p>
d241 10
a250 1
<hr />
d252 13
d266 2
a267 17
<h3>Compiling and Linking Against Expat</h3>

<p>Unless you installed Expat in a location not expected by your
compiler and linker, all you have to do to use Expat in your programs
is to include the Expat header (<code>#include &lt;expat.h&gt;</code>)
in your files that make calls to it and to tell the linker that it
needs to link against the Expat library.  On Unix systems, this would
usually be done with the <code>-lexpat</code> argument.  Otherwise,
you'll need to tell the compiler where to look for the Expat header
and the linker where to find the Expat library.  You may also need to
take steps to tell the operating system where to find this libary at
run time.</p>

<p>On a Unix-based system, here's what a Makefile might look like when
Expat is installed in a standard location:</p>

<pre class="eg">
d274 1
d276 1
a276 1
<p>If you installed Expat in, say, <code>/home/me/mystuff</code>, then
d279 2
a280 1
<pre class="eg">
d288 1
d290 5
a294 5
<p>You'd also have to set the environment variable
<code>LD_LIBRARY_PATH</code> to <code>/home/me/mystuff/lib</code> (or
to <code>${LD_LIBRARY_PATH}:/home/me/mystuff/lib</code> if
LD_LIBRARY_PATH already has some directories in it) in order to run
your application.</p>
d297 16
a312 15

<p>As we saw in the example in the overview, the first step in parsing
an XML document with Expat is to create a parser object. There are <a
href="#creation">three functions</a> in the Expat API for creating a
parser object.  However, only two of these (<code><a href=
"#XML_ParserCreate" >XML_ParserCreate</a></code> and <code><a href=
"#XML_ParserCreateNS" >XML_ParserCreateNS</a></code>) can be used for
constructing a parser for a top-level document.  The object returned
by these functions is an opaque pointer (i.e. "expat.h" declares it as
void *) to data with further internal structure. In order to free the
memory associated with this object you must call <code><a href=
"#XML_ParserFree" >XML_ParserFree</a></code>. Note that if you have
provided any <a href="userdata">user data</a> that gets stored in the
parser, then your application is responsible for freeing it prior to
calling <code>XML_ParserFree</code>.</p>
d315 26
a340 28
parsing only one XML document or external parsed entity. If your
application needs to parse many XML documents, then it needs to create
a parser object for each one. The best way to deal with this is to
create a higher level object that contains all the default
initialization you want for your parser objects.</p>

<p>Walking through a document hierarchy with a stream oriented parser
will require a good stack mechanism in order to keep track of current
context.  For instance, to answer the simple question, "What element
does this text belong to?" requires a stack, since the parser may have
descended into other elements that are children of the current one and
has encountered this text on the way out.</p>

<p>The things you're likely to want to keep on a stack are the
currently opened element and it's attributes. You push this
information onto the stack in the start handler and you pop it off in
the end handler.</p>

<p>For some tasks, it is sufficient to just keep information on what
the depth of the stack is (or would be if you had one.) The outline
program shown above presents one example. Another such task would be
skipping over a complete element. When you see the start tag for the
element you want to skip, you set a skip flag and record the depth at
which the element started.  When the end tag handler encounters the
same depth, the skipped element has ended and the flag may be
cleared. If you follow the convention that the root element starts at
1, then you can use the same variable for skip flag and skip
depth.</p>
d342 2
a343 1
<pre class="eg">
d378 1
d380 1
d382 8
a389 9
<p>Notice in the above example the difference in how depth is
manipulated in the start and end handlers. The end tag handler should
be the mirror image of the start tag handler. This is necessary to
properly model containment. Since, in the start tag handler, we
incremented depth <em>after</em> the main body of start tag code, then
in the end handler, we need to manipulate it <em>before</em> the main
body.  If we'd decided to increment it first thing in the start
handler, then we'd have had to decrement it last thing in the end
handler.</p>
d391 1
a391 1
<h3 id="userdata">Communicating between handlers</h3>
d395 4
a398 44
the shared variables. You can then tell Expat (with the <code><a href=
"#XML_SetUserData" >XML_SetUserData</a></code> function) to pass a
pointer to this structure to the handlers. This is typically the first
argument received by most handlers.</p>

<h3>XML Version</h3>

<p>Expat is an XML 1.0 parser, and as such never complains based on
the value of the <code>version</code> pseudo-attribute in the XML
declaration, if present.</p>

<p>If an application needs to check the version number (to support
alternate processing), it should use the <code><a href=
"#XML_SetXmlDeclHandler" >XML_SetXmlDeclHandler</a></code> function to
set a handler that uses the information in the XML declaration to
determine what to do.  This example shows how to check that only a
version number of <code>"1.0"</code> is accepted:</p>

<pre class="eg">
static int wrong_version;
static XML_Parser parser;

static void
xmldecl_handler(void            *userData,
                const XML_Char  *version,
                const XML_Char  *encoding,
                int              standalone)
{
  static const XML_Char Version_1_0[] = {'1', '.', '0', 0};

  int i;

  for (i = 0; i &lt; (sizeof(Version_1_0) / sizeof(Version_1_0[0])); ++i) {
    if (version[i] != Version_1_0[i]) {
      wrong_version = 1;
      /* also clear all other handlers: */
      XML_SetCharacterDataHandler(parser, NULL);
      ...
      return;
    }
  }
  ...
}
</pre>
d402 3
a404 4
<p>When the parser is created using the <code><a href=
"#XML_ParserCreateNS" >XML_ParserCreateNS</a></code>, function, Expat
performs namespace processing. Under namespace processing, Expat
consumes <code>xmlns</code> and <code>xmlns:...</code> attributes,
d406 42
a447 39
occur. This means that your start handler will not see these
attributes.  Your application can still be informed of these
declarations by setting namespace declaration handlers with <a href=
"#XML_SetNamespaceDeclHandler"
><code>XML_SetNamespaceDeclHandler</code></a>.</p>

<p>Element type and attribute names that belong to a given namespace
are passed to the appropriate handler in expanded form. By default
this expanded form is a concatenation of the namespace URI, the
separator character (which is the 2nd argument to <code><a href=
"#XML_ParserCreateNS" >XML_ParserCreateNS</a></code>), and the local
name (i.e. the part after the colon). Names with undeclared prefixes
are passed through to the handlers unchanged, with the prefix and
colon still attached. Unprefixed attribute names are never expanded,
and unprefixed element names are only expanded when they are in the
scope of a default namespace.</p>

<p>However if <code><a href= "XML_SetReturnNSTriplet"
>XML_SetReturnNSTriplet</a></code> has been called with a non-zero
<code>do_nst</code> parameter, then the expanded form for names with
an explicit prefix is a concatenation of: URI, separator, local name,
separator, prefix.</p>

<p>You can set handlers for the start of a namespace declaration and
for the end of a scope of a declaration with the <code><a href=
"#XML_SetNamespaceDeclHandler" >XML_SetNamespaceDeclHandler</a></code>
function.  The StartNamespaceDeclHandler is called prior to the start
tag handler and the EndNamespaceDeclHandler is called before the
corresponding end tag that ends the namespace's scope.  The namespace
start handler gets passed the prefix and URI for the namespace.  For a
default namespace declaration (xmlns='...'), the prefix will be null.
The URI will be null for the case where the default namespace is being
unset.  The namespace end handler just gets the prefix for the closing
scope.</p>

<p>These handlers are called for each declaration. So if, for
instance, a start tag had three namespace declarations, then the
StartNamespaceDeclHandler would be called three times before the start
tag handler is called, once for each declaration.</p>
d451 4
a454 5
<p>While XML is based on Unicode, and every XML processor is required
to recognized UTF-8 and UTF-16 (1 and 2 byte encodings of Unicode),
other encodings may be declared in XML documents or entities. For the
main document, an XML declaration may contain an encoding
declaration:</p>
d460 1
a460 1
looks like an XML declaration with just an encoding declaration:</p>
d465 3
a467 4
<p>With Expat, you may also specify an encoding at the time of
creating a parser. This is useful when the encoding information may
come from a source outside the document itself (like a higher level
protocol.)</p>
d469 1
a469 2
<p><a name="builtin_encodings"></a>There are four built-in encodings
in Expat:</p>
d471 4
a474 4
<li>UTF-8</li>
<li>UTF-16</li>
<li>ISO-8859-1</li>
<li>US-ASCII</li>
d481 10
a490 10
structure. Your handler must fill in this structure and return
<code>XML_STATUS_OK</code> if it knows how to deal with the
encoding. Otherwise the handler should return
<code>XML_STATUS_ERROR</code>.  The handler also gets passed a pointer
to an optional application data structure that you may indicate when
you set the handler.</p>

<p>Expat places restrictions on character encodings that it can
support by filling in the <code>XML_Encoding</code> structure.
include file:</p>
d503 14
a516 16
<p><code>XML_Encoding</code> contains an array of integers that
correspond to the 1st byte of an encoding sequence. If the value in
the array for a byte is zero or positive, then the byte is a single
byte encoding that encodes the Unicode scalar value contained in the
array. A -1 in this array indicates a malformed byte. If the value is
-2, -3, or -4, then the byte is the beginning of a 2, 3, or 4 byte
sequence respectively. Multi-byte sequences are sent to the convert
function pointed at in the <code>XML_Encoding</code> structure. This
function should return the Unicode scalar value for the sequence or -1
if the sequence is malformed.</p>

<p>One pitfall that novice Expat users are likely to fall into is that
although Expat may accept input in various encodings, the strings that
it passes to the handlers are always encoded in UTF-8 or UTF-16
(depending on how Expat was compiled). Your application is responsible
for any translation of these strings into other encodings.</p>
d520 16
a535 16
<p>Expat does not read or parse external entities directly. Note that
any external DTD is a special case of an external entity.  If you've
set no <code>ExternalEntityRefHandler</code>, then external entity
references are silently ignored. Otherwise, it calls your handler with
the information needed to read and parse the external entity.</p>

<p>Your handler isn't actually responsible for parsing the entity, but
it is responsible for creating a subsidiary parser with <code><a href=
"#XML_ExternalEntityParserCreate"
>XML_ExternalEntityParserCreate</a></code> that will do the job. This
returns an instance of <code>XML_Parser</code> that has handlers and
other data structures initialized from the parent parser. You may then
use <code><a href= "#XML_Parse" >XML_Parse</a></code> or <code><a
href= "#XML_ParseBuffer">XML_ParseBuffer</a></code> calls against this
parser.  Since external entities my refer to other external entities,
your handler should be prepared to be called recursively.</p>
d538 3
a540 5

<p>In order to parse parameter entities, before starting the parse,
you must call <code><a href= "#XML_SetParamEntityParsing"
>XML_SetParamEntityParsing</a></code> with one of the following
arguments:</p>
d551 2
a552 2
<p>In order to read an external DTD, you also have to set an external
entity reference handler as described above.</p>
d554 4
a557 1
<hr />
d564 1
a564 1
<pre class="fcndec" id="XML_ParserCreate">
d566 2
a567 2
XML_ParserCreate(const XML_Char *encoding);
</pre>
d573 4
a576 4
<li>US-ASCII</li>
<li>UTF-8</li>
<li>UTF-16</li>
<li>ISO-8859-1</li>
d581 1
a581 1
<pre class="fcndec" id="XML_ParserCreateNS">
d584 2
a585 2
                   XML_Char sep);
</pre>
d593 1
a593 1
<pre class="fcndec" id="XML_ParserCreate_MM">
d597 2
a598 9
		    const XML_Char *sep);
</pre>
<pre class="signature">
typedef struct {
  void *(*malloc_fcn)(size_t size);
  void *(*realloc_fcn)(void *ptr, size_t size);
  void (*free_fcn)(void *ptr);
} XML_Memory_Handling_Suite;
</pre>
d605 8
a612 1
the namespace URI and the local part of the name.</p>
d615 1
a615 1
<pre class="fcndec" id="XML_ExternalEntityParserCreate">
d619 2
a620 2
                               const XML_Char *encoding);
</pre>
d622 7
a628 7
Construct a new <code>XML_Parser</code> object for parsing an external
general entity. Context is the context argument passed in a call to a
ExternalEntityRefHandler. Other state information such as handlers,
user data, namespace processing is inherited from the parser passed as
the 1st argument. So you shouldn't need to call any of the behavior
changing functions on this parser (unless you want it to act
differently than the parent parser).
d631 1
a631 1
<pre class="fcndec" id="XML_ParserFree">
d633 2
a634 2
XML_ParserFree(XML_Parser p);
</pre>
d637 1
a637 16
freeing any memory associated with <a href="#userdata">user data</a>.
</div>

<pre class="fcndec" id="XML_ParserReset">
XML_Bool
XML_ParserReset(XML_Parser p);
</pre>
<div class="fcndef">
Clean up the memory structures maintained by the parser so that it may
be used again.  After this has been called, <code>parser</code> is
ready to start parsing a new document.  This function may not be used
on a parser created using <code><a href=
"#XML_ExternalEntityParserCreate" >XML_ExternalEntityParserCreate</a
></code>; it will return <code>XML_FALSE</code> in that case.  Returns
<code>XML_TRUE</code> on success.  Your application is responsible for
dealing with any memory associated with <a href="#userdata">user data</a>.
a641 10
<p>To state the obvious: the three parsing functions <code><a href=
"#XML_Parse" >XML_Parse</a></code>, <code><a href= "#XML_ParseBuffer"
>XML_ParseBuffer</a></code> and <code><a href= "#XML_GetBuffer"
>>XML_GetBuffer</a></code> must not be
called from within a handler unless they operate on a separate parser
instance, that is, one that did not call the handler. For example, it
is OK to call the parsing functions from within an
<code>XML_ExternalEntityRefHandler</code>, if they apply to the parser
created by <code><a href= "#XML_ExternalEntityParserCreate"
>XML_ExternalEntityParserCreate</a></code>.</p>
d643 2
a644 2
<pre class="fcndec" id="XML_Parse">
XML_Status
d648 2
a649 8
          int isFinal);
</pre>
<pre class="signature">
enum XML_Status {
  XML_STATUS_ERROR = 0,
  XML_STATUS_OK = 1
};
</pre>
d660 2
a661 2
If a parse error occurred, it returns <code>XML_STATUS_ERROR</code>.
Otherwise it returns <code>XML_STATUS_OK</code> value.
d664 2
a665 2
<pre class="fcndec" id="XML_ParseBuffer">
XML_Status
d668 2
a669 2
                int isFinal);
</pre>
d671 3
a673 5
This is just like <code><a href= "#XML_Parse" >XML_Parse</a></code>,
except in this case Expat provides the buffer.  By obtaining the
buffer from Expat with the <code><a href= "#XML_GetBuffer"
>XML_GetBuffer</a></code> function, the application can avoid double
copying of the input.
d676 1
a676 1
<pre class="fcndec" id="XML_GetBuffer">
d679 2
a680 2
              int len);
</pre>
d683 1
a683 1
into. A NULL value is returned if Expat can't allocate enough memory for
d685 1
a685 2
<code><a href= "#XML_ParseBuffer" >XML_ParseBuffer</a></code>. A
typical use would look like this:
d687 2
a688 1
<pre class="eg">
d697 1
a697 1
  if (bytes_read &lt; 0) {
d707 1
a707 1
}
d710 1
a712 1

d718 1
a718 1
is seen, and unset it for the corresponding end tag.</p>
d722 1
a722 1
a return value.</p>
d725 4
a728 4
<code>XML_Char</code>. This type is defined in expat.h as <code>char
*</code> and contains bytes encoding UTF-8.  Note that you'll receive
them in this form independent of the original encoding of the
document.</p>
d731 1
a731 1
<pre class="setter" id="XML_SetStartElementHandler">
d734 2
a735 2
</pre>
<pre class="signature">
d740 1
a740 1
</pre>
d751 1
a751 1
<pre class="setter" id="XML_SetEndElementHandler">
d754 2
a755 2
</pre>
<pre class="signature">
d759 1
a759 1
</pre>
d765 1
a765 1
<pre class="setter" id="XML_SetElementHandler">
d769 1
a769 1
</pre>
d774 1
a774 1
<pre class="setter" id="XML_SetCharacterDataHandler">
d777 2
a778 2
</pre>
<pre class="signature">
d783 1
a783 1
</pre>
d785 1
a785 1
is <em>NOT nul-terminated</em>. You have to use the length argument
d793 1
a793 1
<pre class="setter" id="XML_SetProcessingInstructionHandler">
d796 2
a797 2
</pre>
<pre class="signature">
d803 1
a803 1
</pre>
d810 1
a810 1
<pre class="setter" id="XML_SetCommentHandler">
d813 2
a814 2
</pre>
<pre class="signature">
d818 1
a818 1
</pre>
d824 1
a824 1
<pre class="setter" id="XML_SetStartCdataSectionHandler">
d827 2
a828 2
</pre>
<pre class="signature">
d831 1
a831 1
</pre>
d836 1
a836 1
<pre class="setter" id="XML_SetEndCdataSectionHandler">
d839 2
a840 2
</pre>
<pre class="signature">
d843 1
a843 1
</pre>
d848 1
a848 1
<pre class="setter" id="XML_SetCdataSectionHandler">
d852 1
a852 1
</pre>
d857 1
a857 1
<pre class="setter" id="XML_SetDefaultHandler">
d860 2
a861 2
</pre>
<pre class="signature">
d866 1
a866 2
</pre>

d868 5
a872 9
otherwise be handled. This includes both data for which no handlers
can be set (like some kinds of DTD declarations) and data which could
be reported but which currently has no handler set.  The characters
are passed exactly as they were present in the XML document except
that they will be encoded in UTF-8 or UTF-16. Line boundaries are not
normalized. Note that a byte order mark character is not passed to the
default handler. There are no guarantees about how characters are
divided between calls to the default handler: for example, a comment
might be split between multiple calls.  Setting the handler with
a875 3

<p>See also <code><a
href="#XML_DefaultCurrent">XML_DefaultCurrent</a></code>.</p>
d879 1
a879 1
<pre class="setter" id="XML_SetDefaultHandlerExpand">
d882 2
a883 2
</pre>
<pre class="signature">
d888 3
a890 7
</pre>
<p>This sets a default handler, but doesn't inhibit the expansion of
internal entity references.  The entity reference will not be passed
to the default handler.</p>

<p>See also <code><a
href="#XML_DefaultCurrent">XML_DefaultCurrent</a></code>.</p>
d894 1
a894 1
<pre class="setter" id="XML_SetExternalEntityRefHandler">
d897 2
a898 2
</pre>
<pre class="signature">
d905 1
a905 1
</pre>
d911 19
a929 30
<p>The <code>context</code> parameter specifies the parsing context in
the format expected by the <code>context</code> argument to <code><a
href="#XML_ExternalEntityParserCreate"
>XML_ExternalEntityParserCreate</a></code>.  <code>code</code> is
valid only until the handler returns, so if the referenced entity is
to be parsed later, it must be copied.  <code>context</code> is NULL
only when the entity is a parameter entity, which is how one can
differentiate between general and parameter entities.</p>

<p>The <code>base</code> parameter is the base to use for relative
system identifiers.  It is set by <code><a
href="#XML_SetBase">XML_SetBase</a></code> and may be NULL. The
<code>publicId</code> parameter is the public id given in the entity
declaration and may be NULL.  <code>systemId</code> is the system
identifier specified in the entity declaration and is never NULL.</p>

<p>There are a couple of ways in which this handler differs from
others.  First, this handler returns a status indicator (an
integer). <code>XML_STATUS_OK</code> should be returned for successful
handling of the external entity reference.  Returning
<code>XML_STATUS_ERROR</code> indicates failure, and causes the
calling parser to return an
<code>XML_ERROR_EXTERNAL_ENTITY_HANDLING</code> error.</p>

<p>Second, instead of having the user data as its first argument, it
receives the parser that encountered the entity reference. This, along
with the context parameter, may be used as arguments to a call to
<code><a href= "#XML_ExternalEntityParserCreate"
>XML_ExternalEntityParserCreate</a></code>.  Using the returned
parser, the body of the external entity can be recursively parsed.</p>
a934 24
<pre class="fcndec" id="XML_SetExternalEntityRefHandlerArg">
XML_SetExternalEntityRefHandlerArg(XML_Parser p,
                                   void *arg)
</pre>
<div class="fcndef">
<p>Set the argument passed to the ExternalEntityRefHandler.  If
<code>arg</code> is not NULL, it is the new value passed to the
handler set using <code><a href="#XML_SetExternalEntityRefHandler"
>XML_SetExternalEntityRefHandler</a></code>; if <code>arg</code> is
NULL, the argument passed to the handler function will be the parser
object itself.</p>

<p><strong>Note:</strong>
The type of <code>arg</code> and the type of the first argument to the
ExternalEntityRefHandler do not match.  This function takes a
<code>void *</code> to be passed to the handler, while the handler
accepts an <code>XML_Parser</code>.  This is a historical accident,
but will not be corrected before Expat 2.0 (at the earliest) to avoid
causing compiler warnings for code that's known to work with this
API.  It is the responsibility of the application code to know the
actual type of the argument passed to the handler and to manage it
properly.</p>
</div>

d936 1
a936 1
<pre class="setter" id="XML_SetSkippedEntityHandler">
d939 2
a940 2
</pre>
<pre class="signature">
d945 1
a945 1
</pre>
d949 1
a949 1
       has been read <em>and</em> this is not an error.</li>
d955 4
a958 4
a parameter entity and zero for a general entity.</p> <p>Note: skipped
parameter entities in declarations and skipped general entities in
attribute values cannot be reported, because the event would be out of
sync with the reporting of the declarations or attribute values</p>
d962 1
a962 1
<pre class="setter" id="XML_SetUnknownEncodingHandler">
d965 3
a967 3
			      void *encodingHandlerData)
</pre>
<pre class="signature">
d972 5
d978 7
a984 6
typedef struct {
  int map[256];
  void *data;
  int (*convert)(void *data, const char *s);
  void (*release)(void *data);
} XML_Encoding;
a985 11
<p>Set a handler to deal with encodings other than the <a
href="#builtin_encodings">built in set</a>. This should be done before
<code><a href= "#XML_Parse" >XML_Parse</a></code> or <code><a href=
"#XML_ParseBuffer" >XML_ParseBuffer</a></code> have been called on the
given parser.</p> <p>If the handler knows how to deal with an encoding
with the given name, it should fill in the <code>info</code> data
structure and return <code>XML_STATUS_ERROR</code>. Otherwise it
should return <code>XML_STATUS_OK</code>. The handler will be called
at most once per parsed (external) entity. The optional application
data pointer <code>encodingHandlerData</code> will be passed back to
the handler.</p>
d996 2
a997 3
function is the data pointer from <code>XML_Encoding</code>. The
string s is <em>NOT</em> nul-terminated and points at the sequence of
bytes to be converted.</p>
d999 2
a1000 2
<p>The function pointed at by <code>release</code> is called by the
parser when it is finished with the encoding. It may be NULL.</p>
d1004 1
a1004 1
<pre class="setter" id="XML_SetStartNamespaceDeclHandler">
d1007 2
a1008 2
</pre>
<pre class="signature">
d1013 1
a1013 1
</pre>
a1017 6

<p><strong>Note:</strong>
Due to limitations of the implementation, the
StartNamespaceDeclHandler is not called unless the StartElementHandler
is also set.  The specific value of the StartElementHandler is allowed
to change freely, so long as it is not NULL.</p>
d1021 1
a1021 1
<pre class="setter" id="XML_SetEndNamespaceDeclHandler">
d1024 2
a1025 2
</pre>
<pre class="signature">
d1029 1
a1029 1
</pre>
d1031 3
a1033 9
declaration. This will be called, for each namespace declaration,
after the handler for the end tag of the element in which the
namespace was declared.</p>

<p><strong>Note:</strong>
Due to limitations of the implementation, the EndNamespaceDeclHandler
is not called unless the StartElementHandler is also set.  The
specific value of the StartElementHandler is allowed to change freely,
so long as it is not NULL.</p>
d1037 1
a1037 1
<pre class="setter" id="XML_SetNamespaceDeclHandler">
d1041 2
a1042 9
</pre>
<p>Sets both namespace declaration handlers with a single call.</p>

<p><strong>Note:</strong>
Due to limitations of the implementation, the
StartNamespaceDeclHandler and EndNamespaceDeclHandler are not called
unless the StartElementHandler is also set.  The specific value of the
StartElementHandler is allowed to change freely, so long as it is not
NULL.</p>
d1046 1
a1046 1
<pre class="setter" id="XML_SetXmlDeclHandler">
d1049 2
a1050 2
</pre>
<pre class="signature">
d1056 1
a1056 1
</pre>
d1058 6
a1063 7
text declarations discovered in external entities. The way to
distinguish is that the <code>version</code> parameter will be NULL
for text declarations. The <code>encoding</code> parameter may be NULL
for an XML declaration. The <code>standalone</code> argument will
contain -1, 0, or 1 indicating respectively that there was no
standalone parameter in the declaration, that it was given as no, or
that it was given as yes.</p>
d1067 1
a1067 1
<pre class="setter" id="XML_SetStartDoctypeDeclHandler">
d1070 2
a1071 2
</pre>
<pre class="signature">
d1078 1
a1078 1
</pre>
d1086 1
a1086 1
<pre class="setter" id="XML_SetEndDoctypeDeclHandler">
d1089 2
a1090 2
</pre>
<pre class="signature">
d1093 1
a1093 1
</pre>
d1099 1
a1099 1
<pre class="setter" id="XML_SetDoctypeDeclHandler">
d1103 1
a1103 1
</pre>
d1108 1
a1108 1
<pre class="setter" id="XML_SetElementDeclHandler">
d1111 2
a1112 2
</pre>
<pre class="signature">
d1117 2
a1118 2
</pre>
<pre class="signature">
d1144 5
a1148 7
</pre>
<p>Sets a handler for element declarations in a DTD. The handler gets
called with the name of the element in the declaration and a pointer
to a structure that contains the element model. It is the
application's responsibility to free this data structure using
<code><a href="#XML_FreeContentModel"
>XML_FreeContentModel</a></code>.</p>
d1153 14
a1166 16
<code>quant</code> will be <code>XML_CQUANT_NONE</code>, and the other
fields will be zero or NULL.  If <code>type</code> is
<code>XML_CTYPE_MIXED</code>, then <code>quant</code> will be
<code>XML_CQUANT_NONE</code> or <code>XML_CQUANT_REP</code> and
<code>numchildren</code> will contain the number of elements that are
allowed to be mixed in and <code>children</code> points to an array of
<code>XML_Content</code> structures that will all have type
XML_CTYPE_NAME with no quantification.  Only the root node can be type
<code>XML_CTYPE_EMPTY</code>, <code>XML_CTYPE_ANY</code>, or
<code>XML_CTYPE_MIXED</code>.</p>

<p>For type <code>XML_CTYPE_NAME</code>, the <code>name</code> field
points to the name and the <code>numchildren</code> and
<code>children</code> fields will be zero and NULL. The
<code>quant</code> field will indicate any quantifiers placed on the
name.</p>
d1169 3
a1171 3
indicate a choice or sequence respectively. The
<code>numchildren</code> field indicates how many nodes in the choice
or sequence and <code>children</code> points to the nodes.</p>
d1175 1
a1175 1
<pre class="setter" id="XML_SetAttlistDeclHandler">
d1178 2
a1179 2
</pre>
<pre class="signature">
d1187 9
a1195 9
</pre>
<p>Set a handler for attlist declarations in the DTD. This handler is
called for <em>each</em> attribute. So a single attlist declaration
with multiple attributes declared will generate multiple calls to this
handler. The <code>elname</code> parameter returns the name of the
element for which the attribute is being declared. The attribute name
is in the <code>attname</code> parameter. The attribute type is in the
<code>att_type</code> parameter.  It is the string representing the
type in the declaration with whitespace removed.</p>
d1197 2
a1198 2
<p>The <code>dflt</code> parameter holds the default value. It will be
NULL in the case of "#IMPLIED" or "#REQUIRED" attributes. You can
d1202 3
a1204 2
<code>isrequired</code>, but they will have the non-NULL fixed value
in the <code>dflt</code> parameter.</p>
d1208 1
a1208 1
<pre class="setter" id="XML_SetEntityDeclHandler">
d1211 2
a1212 2
</pre>
<pre class="signature">
d1223 1
a1223 1
</pre>
d1225 3
a1227 3
The <code>is_parameter_entity</code> argument will be non-zero in the
case of parameter entities and zero otherwise.</p>

d1231 6
a1236 7
The value string is <em>not</em> NULL terminated; the length is
provided in the <code>value_length</code> parameter. Do not use
<code>value_length</code> to test for internal entities, since it is
legal to have zero-length values. Instead check for whether or not
<code>value</code> is NULL.</p> <p>The <code>notationName</code>
argument will have a non-NULL value only for unparsed entity
declarations.</p>
d1240 1
a1240 1
<pre class="setter" id="XML_SetUnparsedEntityDeclHandler">
d1243 2
a1244 2
</pre>
<pre class="signature">
d1252 1
a1252 1
</pre>
d1259 4
a1262 3
<p>This handler is obsolete and is provided for backwards
compatibility.  Use instead <a href= "#XML_SetEntityDeclHandler"
>XML_SetEntityDeclHandler</a>.</p>
d1266 1
a1266 1
<pre class="setter" id="XML_SetNotationDeclHandler">
d1269 2
a1270 2
</pre>
<pre class="signature">
d1277 1
a1277 1
</pre>
d1282 1
a1282 1
<pre class="setter" id="XML_SetNotStandaloneHandler">
d1285 2
a1286 2
</pre>
<pre class="signature">
d1289 1
a1289 1
</pre>
d1291 4
a1294 5
This happens when there is an external subset or a reference to a
parameter entity, but does not have standalone set to "yes" in an XML
declaration.  If this handler returns <code>XML_STATUS_ERROR</code>,
then the parser will throw an <code>XML_ERROR_NOT_STANDALONE</code>
error.</p>
d1298 9
d1308 1
a1308 13
<p>These are the functions you'll want to call when the parse
functions return <code>XML_STATUS_ERROR</code> (a parse error has
ocurred), although the position reporting functions are useful outside
of errors. The position reported is the byte position (in the original
document or entity encoding) of the first of the sequence of
characters that generated the current event (or the error that caused
the parse functions to return <code>XML_STATUS_ERROR</code>.)</p>

<p>The position reporting functions are accurate only outside of the
DTD.  In other words, they usually return bogus information when
called from within a DTD declaration handler.</p>

<pre class="fcndec" id="XML_GetErrorCode">
d1310 2
a1311 2
XML_GetErrorCode(XML_Parser p);
</pre>
d1316 1
a1316 1
<pre class="fcndec" id="XML_ErrorString">
d1318 2
a1319 2
XML_ErrorString(int code);
</pre>
d1323 1
a1323 1
<code><a href= "#XML_GetErrorCode" >XML_GetErrorCode</a></code>.
d1326 1
a1326 1
<pre class="fcndec" id="XML_GetCurrentByteIndex">
d1328 2
a1329 2
XML_GetCurrentByteIndex(XML_Parser p);
</pre>
d1334 1
a1334 1
<pre class="fcndec" id="XML_GetCurrentLineNumber">
d1336 2
a1337 2
XML_GetCurrentLineNumber(XML_Parser p);
</pre>
d1342 1
a1342 1
<pre class="fcndec" id="XML_GetCurrentColumnNumber">
d1344 2
a1345 2
XML_GetCurrentColumnNumber(XML_Parser p);
</pre>
d1351 1
a1351 1
<pre class="fcndec" id="XML_GetCurrentByteCount">
d1354 1
a1354 1
</pre>
d1363 1
a1363 1
<pre class="fcndec" id="XML_GetInputContext">
d1368 1
a1368 1
</pre>
a1369 1

d1372 2
a1373 3
parse position, and set the integer pointed at by <code>size</code> to
the size of the returned buffer.</p>

d1376 5
a1380 6
the handler that made the call. This input buffer contains the
untranslated bytes of the input.</p>

<p>Only a limited amount of context is kept, so if the event
triggering a call spans over a very large amount of input, the actual
parse position may be before the beginning of the buffer.</p>
d1384 2
d1387 1
a1387 4
<p>The functions in this section either obtain state information from
the parser or can be used to dynamicly set parser options.</p>

<pre class="fcndec" id="XML_SetUserData">
d1390 2
a1391 2
                void *userData);
</pre>
d1393 2
a1394 2
This sets the user data pointer that gets passed to handlers.  It
overwrites any previous value for this pointer. Note that the
d1396 3
a1398 3
<code>userData</code> when it is finished with the parser. So if you
call this when there's already a pointer there, and you haven't freed
the memory associated with it, then you've probably just leaked
d1402 1
a1402 1
<pre class="fcndec" id="XML_GetUserData">
d1404 2
a1405 2
XML_GetUserData(XML_Parser p);
</pre>
d1411 1
a1411 1
<pre class="fcndec" id="XML_UseParserAsHandlerArg">
d1413 2
a1414 2
XML_UseParserAsHandlerArg(XML_Parser p);
</pre>
d1416 3
a1418 4
After this is called, handlers receive the parser in their
<code>userData</code> arguments.  The user data can still be obtained
using the <code><a href= "#XML_GetUserData"
>XML_GetUserData</a></code> function.
d1421 2
a1422 2
<pre class="fcndec" id="XML_SetBase">
enum XML_Status
d1424 2
a1425 2
            const XML_Char *base);
</pre>
d1427 3
a1429 4
Set the base to be used for resolving relative URIs in system
identifiers.  The return value is <code>XML_STATUS_ERROR</code> if
there's no memory to store base, otherwise it's
<code>XML_STATUS_OK</code>.
d1432 1
a1432 1
<pre class="fcndec" id="XML_GetBase">
d1434 2
a1435 2
XML_GetBase(XML_Parser p);
</pre>
d1440 1
a1440 1
<pre class="fcndec" id="XML_GetSpecifiedAttributeCount">
d1442 2
a1443 2
XML_GetSpecifiedAttributeCount(XML_Parser p);
</pre>
d1448 5
a1452 6
ATTLIST declaration. This function returns the number of attributes
that were explicitly set times two, thus giving the offset in the
<code>atts</code> array passed to the start tag handler of the first
attribute set due to defaults. It supplies information for the last
call to a start handler. If called inside a start handler, then that
means the current call.
d1455 1
a1455 1
<pre class="fcndec" id="XML_GetIdAttributeIndex">
d1458 1
a1458 1
</pre>
d1460 3
a1462 5
Returns the index of the ID attribute passed in the atts array in the
last call to <code><a href= "#XML_StartElementHandler"
>XML_StartElementHandler</a></code>, or -1 if there is no ID
attribute. If called inside a start handler, then that means the
current call.
d1465 2
a1466 2
<pre class="fcndec" id="XML_SetEncoding">
enum XML_Status
d1468 2
a1469 2
                const XML_Char *encoding);
</pre>
d1473 2
a1474 5
It must not be called after <code><a href= "#XML_Parse"
>XML_Parse</a></code> or <code><a href= "#XML_ParseBuffer"
>XML_ParseBuffer</a></code> have been called on the given parser.
Returns <code>XML_STATUS_OK</code> on success or
<code>XML_STATUS_ERROR</code> on error.
d1477 1
a1477 1
<pre class="fcndec" id="XML_SetParamEntityParsing">
d1480 2
a1481 2
                          enum XML_ParamEntityParsing code);
</pre>
d1494 1
a1494 33
<pre class="fcndec" id="XML_UseForeignDTD">
enum XML_Error
XML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD);
</pre>
<div class="fcndef">
<p>This function allows an application to provide an external subset
for the document type declaration for documents which do not specify
an external subset of their own.  For documents which specify an
external subset in their DOCTYPE declaration, the application-provided
subset will be ignored.  If the document does not contain a DOCTYPE
declaration at all and <code>useDTD</code> is true, the
application-provided subset will be parsed, but the
<code>startDoctypeDeclHandler</code> and
<code>endDoctypeDeclHandler</code> functions, if set, will not be
called.  The setting of parameter entity parsing, controlled using
<code><a href= "#XML_SetParamEntityParsing"
>XML_SetParamEntityParsing</a></code>, will be honored.</p>

<p>The application-provided external subset is read by calling the
external entity reference handler set via <code><a href=
"#XML_SetExternalEntityRefHandler"
>XML_SetExternalEntityRefHandler</a></code> with both
<code>publicId</code> and <code>systemId</code> set to NULL.</p>

<p>If this function is called after parsing has begun, it returns
<code>XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING</code> and ignores
<code>useDTD</code>.  If called when Expat has been compiled without
DTD support, it returns
<code>XML_ERROR_FEATURE_REQUIRES_XML_DTD</code>.  Otherwise, it
returns <code>XML_ERROR_NONE</code>.</p>
</div>

<pre class="fcndec" id="XML_SetReturnNSTriplet">
d1498 1
a1498 1
</pre>
d1502 10
a1511 12
<code><a href= "#XML_ParserCreateNS" >XML_ParserCreateNS</a></code>,
i.e. when namespace processing is in effect. The <code>do_nst</code>
sets whether or not prefixes are returned with names qualified with a
namespace prefix. If this function is called with <code>do_nst</code>
non-zero, then afterwards namespace qualified names (that is qualified
with a prefix as opposed to belonging to a default namespace) are
returned as a triplet with the three parts separated by the namespace
separator specified when the parser was created.  The order of
returned parts is URI, local name, and prefix.</p> <p>If
<code>do_nst</code> is zero, then namespaces are reported in the
default manner, URI then local_name separated by the namespace
separator.</p>
d1514 1
a1514 15
<pre class="fcndec" id="XML_DefaultCurrent">
void
XML_DefaultCurrent(XML_Parser parser);
</pre>
<div class="fcndef">
This can be called within a handler for a start element, end element,
processing instruction or character data.  It causes the corresponding
markup to be passed to the default handler set by <code><a
href="#XML_SetDefaultHandler" >XML_SetDefaultHandler</a></code> or
<code><a href="#XML_SetDefaultHandlerExpand"
>XML_SetDefaultHandlerExpand</a></code>.  It does nothing if there is
not a default handler.
</div>

<pre class="fcndec" id="XML_ExpatVersion">
d1517 1
a1517 1
</pre>
d1519 1
a1519 1
Return the library version as a string (e.g. <code>"expat_1.95.1"</code>).
d1522 2
a1523 2
<pre class="fcndec" id="XML_ExpatVersionInfo">
struct XML_Expat_Version
d1525 4
a1528 2
</pre>
<pre class="signature">
d1534 1
a1534 3
</pre>
<div class="fcndef">
Return the library version information as a structure.
a1544 57

<pre class="fcndec" id="XML_GetFeatureList">
const XML_Feature *
XML_GetFeatureList();
</pre>
<pre class="signature">
enum XML_FeatureEnum {
  XML_FEATURE_END = 0,
  XML_FEATURE_UNICODE,
  XML_FEATURE_UNICODE_WCHAR_T,
  XML_FEATURE_DTD,
  XML_FEATURE_CONTEXT_BYTES,
  XML_FEATURE_MIN_SIZE,
  XML_FEATURE_SIZEOF_XML_CHAR,
  XML_FEATURE_SIZEOF_XML_LCHAR
};

typedef struct {
  enum XML_FeatureEnum  feature;
  XML_LChar            *name;
  long int              value;
} XML_Feature;
</pre>
<div class="fcndef">
<p>Returns a list of "feature" records, providing details on how
Expat was configured at compile time.  Most applications should not
need to worry about this, but this information is otherwise not
available from Expat.  This function allows code that does need to
check these features to do so at runtime.</p>

<p>The return value is an array of <code>XML_Feature</code>,
terminated by a record with a <code>feature</code> of
<code>XML_FEATURE_END</code> and <code>name</code> of NULL,
identifying the feature-test macros Expat was compiled with.  Since an
application that requires this kind of information needs to determine
the type of character the <code>name</code> points to, records for the
<code>XML_FEATURE_SIZEOF_XML_CHAR</code> and
<code>XML_FEATURE_SIZEOF_XML_LCHAR</code> will be located at the
beginning of the list, followed by <code>XML_FEATURE_UNICODE</code>
and <code>XML_FEATURE_UNICODE_WCHAR_T</code>, if they are present at
all.</p>

<p>Some features have an associated value.  If there isn't an
associated value, the <code>value</code> field is set to 0.  At this
time, the following features have been defined to have values:</p>

<dl>
  <dt><code>XML_FEATURE_SIZEOF_XML_CHAR</code></dt>
  <dd>The number of bytes occupied by one <code>XML_Char</code>
  character.</dd>
  <dt><code>XML_FEATURE_SIZEOF_XML_LCHAR</code></dt>
  <dd>The number of bytes occupied by one <code>XML_LChar</code>
  character.</dd>
  <dt><code>XML_FEATURE_CONTEXT_BYTES</code></dt>
  <dd>The maximum number of characters of context which can be
  reported by <code><a href= "#XML_GetInputContext"
  >XML_GetInputContext</a></code>.</dd>
a1545 61
</div>

<pre class="fcndec" id="XML_FreeContentModel">
void
XML_FreeContentModel(XML_Parser parser, XML_Content *model);
</pre>
<div class="fcndef">
Function to deallocate the <code>model</code> argument passed to the
<code>XML_ElementDeclHandler</code> callback set using <code><a
href="#XML_SetElementDeclHandler" >XML_ElementDeclHandler</a></code>.
This function should not be used for any other purpose.
</div>

<p>The following functions allow external code to share the memory
allocator an <code>XML_Parser</code> has been configured to use.  This
is especially useful for third-party libraries that interact with a
parser object created by application code, or heavily layered
applications.  This can be essential when using dynamically loaded
libraries which use different C standard libraries (this can happen on
Windows, at least).</p>

<pre class="fcndec" id="XML_MemMalloc">
void *
XML_MemMalloc(XML_Parser parser, size_t size);
</pre>
<div class="fcndef">
Allocate <code>size</code> bytes of memory using the allocator the
<code>parser</code> object has been configured to use.  Returns a
pointer to the memory or NULL on failure.  Memory allocated in this
way must be freed using <code><a href="#XML_MemFree"
>XML_MemFree</a></code>.
</div>

<pre class="fcndec" id="XML_MemRealloc">
void *
XML_MemRealloc(XML_Parser parser, void *ptr, size_t size);
</pre>
<div class="fcndef">
Allocate <code>size</code> bytes of memory using the allocator the
<code>parser</code> object has been configured to use.
<code>ptr</code> must point to a block of memory allocated by <code><a
href="#XML_MemMalloc" >XML_MemMalloc</a></code> or
<code>XML_MemRealloc</code>, or be NULL.  This function tries to
expand the block pointed to by <code>ptr</code> if possible.  Returns
a pointer to the memory or NULL on failure.  On success, the original
block has either been expanded or freed.  On failure, the original
block has not been freed; the caller is responsible for freeing the
original block.  Memory allocated in this way must be freed using
<code><a href="#XML_MemFree"
>XML_MemFree</a></code>.
</div>

<pre class="fcndec" id="XML_MemFree">
void
XML_MemFree(XML_Parser parser, void *ptr);
</pre>
<div class="fcndef">
Free a block of memory pointed to by <code>ptr</code>.  The block must
have been allocated by <code><a href="#XML_MemMalloc"
>XML_MemMalloc</a></code> or <code>XML_MemRealloc</code>, or be NULL.
</div>
a1546 4
<hr />
<p><a href="http://validator.w3.org/check/referer"><img
        src="valid-xhtml10.png" alt="Valid XHTML 1.0!"
        height="31" width="88" class="noborder" /></a></p>
@


