head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.29.40;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.01.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.01.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.20.54;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.37.57;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.08.49;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftstream.h                                                             */
/*                                                                         */
/*    Stream handling(specification).                                      */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#ifndef __FTSTREAM_H__
#define __FTSTREAM_H__


#include <ft2build.h>
#include FT_INTERNAL_OBJECTS_H


FT_BEGIN_HEADER


  /* format of an 8-bit frame_op value = [ xxxxx | e | s ] */
  /* s is set to 1 if the value is signed,                 */
  /* e is set to 1 if the value is little-endian           */
  /* xxxxx is a command                                    */

#define FT_FRAME_OP_SHIFT         2
#define FT_FRAME_OP_SIGNED        1
#define FT_FRAME_OP_LITTLE        2
#define FT_FRAME_OP_COMMAND( x )  ( x >> FT_FRAME_OP_SHIFT )

#define FT_MAKE_FRAME_OP( command, little, sign ) \
          ( ( command << FT_FRAME_OP_SHIFT ) | ( little << 1 ) | sign )

#define FT_FRAME_OP_END   0
#define FT_FRAME_OP_START 1  /* start a new frame     */
#define FT_FRAME_OP_BYTE  2  /* read 1-byte value     */
#define FT_FRAME_OP_SHORT 3  /* read 2-byte value     */
#define FT_FRAME_OP_LONG  4  /* read 4-byte value     */
#define FT_FRAME_OP_OFF3  5  /* read 3-byte value     */
#define FT_FRAME_OP_BYTES 6  /* read a bytes sequence */


  typedef enum  FT_Frame_Op_
  {
    ft_frame_end       = 0,
    ft_frame_start     = FT_MAKE_FRAME_OP( FT_FRAME_OP_START, 0, 0 ),

    ft_frame_byte      = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTE,  0, 0 ),
    ft_frame_schar     = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTE,  0, 1 ),

    ft_frame_ushort_be = FT_MAKE_FRAME_OP( FT_FRAME_OP_SHORT, 0, 0 ),
    ft_frame_short_be  = FT_MAKE_FRAME_OP( FT_FRAME_OP_SHORT, 0, 1 ),
    ft_frame_ushort_le = FT_MAKE_FRAME_OP( FT_FRAME_OP_SHORT, 1, 0 ),
    ft_frame_short_le  = FT_MAKE_FRAME_OP( FT_FRAME_OP_SHORT, 1, 1 ),

    ft_frame_ulong_be  = FT_MAKE_FRAME_OP( FT_FRAME_OP_LONG, 0, 0 ),
    ft_frame_long_be   = FT_MAKE_FRAME_OP( FT_FRAME_OP_LONG, 0, 1 ),
    ft_frame_ulong_le  = FT_MAKE_FRAME_OP( FT_FRAME_OP_LONG, 1, 0 ),
    ft_frame_long_le   = FT_MAKE_FRAME_OP( FT_FRAME_OP_LONG, 1, 1 ),

    ft_frame_uoff3_be  = FT_MAKE_FRAME_OP( FT_FRAME_OP_OFF3, 0, 0 ),
    ft_frame_off3_be   = FT_MAKE_FRAME_OP( FT_FRAME_OP_OFF3, 0, 1 ),
    ft_frame_uoff3_le  = FT_MAKE_FRAME_OP( FT_FRAME_OP_OFF3, 1, 0 ),
    ft_frame_off3_le   = FT_MAKE_FRAME_OP( FT_FRAME_OP_OFF3, 1, 1 ),

    ft_frame_bytes     = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTES, 0, 0 ),
    ft_frame_skip      = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTES, 0, 1 )

  } FT_Frame_Op;


  typedef struct  FT_Frame_Field_
  {
    FT_Byte      value;
    FT_Byte      size;
    FT_UShort    offset;

  } FT_Frame_Field;


  /* Construct an FT_Frame_Field out of a structure type and a field name. */
  /* The structure type must be set in the FT_STRUCTURE macro before       */
  /* calling the FT_FRAME_START() macro.                                   */
#define FT_FIELD_SIZE( f ) \
          (FT_Byte)sizeof ( ((FT_STRUCTURE*)0)->f )

#define FT_FIELD_SIZE_DELTA( f ) \
          (FT_Byte)sizeof ( ((FT_STRUCTURE*)0)->f[0] )

#define FT_FIELD_OFFSET( f ) \
          (FT_UShort)( offsetof( FT_STRUCTURE, f ) )

#define FT_FRAME_FIELD( frame_op, field ) \
          {                               \
            frame_op,                     \
            FT_FIELD_SIZE( field ),       \
            FT_FIELD_OFFSET( field )      \
          }

#define FT_MAKE_EMPTY_FIELD( frame_op )  { frame_op, 0, 0 }

#define FT_FRAME_START( size )   { ft_frame_start, 0, size }
#define FT_FRAME_END             { ft_frame_end, 0, 0 }

#define FT_FRAME_LONG( f )       FT_FRAME_FIELD( ft_frame_long_be, f )
#define FT_FRAME_ULONG( f )      FT_FRAME_FIELD( ft_frame_ulong_be, f )
#define FT_FRAME_SHORT( f )      FT_FRAME_FIELD( ft_frame_short_be, f )
#define FT_FRAME_USHORT( f )     FT_FRAME_FIELD( ft_frame_ushort_be, f )
#define FT_FRAME_BYTE( f )       FT_FRAME_FIELD( ft_frame_byte, f )
#define FT_FRAME_CHAR( f )       FT_FRAME_FIELD( ft_frame_schar, f )

#define FT_FRAME_LONG_LE( f )    FT_FRAME_FIELD( ft_frame_long_le, f )
#define FT_FRAME_ULONG_LE( f )   FT_FRAME_FIELD( ft_frame_ulong_le, f )
#define FT_FRAME_SHORT_LE( f )   FT_FRAME_FIELD( ft_frame_short_le, f )
#define FT_FRAME_USHORT_LE( f )  FT_FRAME_FIELD( ft_frame_ushort_le, f )

#define FT_FRAME_SKIP_LONG       { ft_frame_long_be, 0, 0 }
#define FT_FRAME_SKIP_SHORT      { ft_frame_short_be, 0, 0 }
#define FT_FRAME_SKIP_BYTE       { ft_frame_byte, 0, 0 }

#define FT_FRAME_BYTES( field, count ) \
          {                            \
            ft_frame_bytes,            \
            count,                     \
            FT_FIELD_OFFSET( field )   \
          }

#define FT_FRAME_SKIP_BYTES( count )  { ft_frame_skip, count, 0 }



  /*************************************************************************/
  /*                                                                       */
  /* integer extraction macros -- the `buffer' parameter must ALWAYS be of */
  /* type `char*' or equivalent (1-byte elements).                         */
  /*                                                                       */

#define FT_GET_SHORT_BE( p )                                   \
          ((FT_Int16)( ( (FT_Int16)(FT_Char)(p)[0] <<  8 ) |   \
                         (FT_Int16)(FT_Byte)(p)[1]         ) )

#define FT_GET_USHORT_BE( p )                                   \
          ((FT_Int16)( ( (FT_UInt16)(FT_Byte)(p)[0] <<  8 ) |   \
                         (FT_UInt16)(FT_Byte)(p)[1]         ) )

#define FT_GET_OFF3_BE( p )                                      \
          ( (FT_Int32) ( ( (FT_Int32)(FT_Char)(p)[0] << 16 ) |   \
                         ( (FT_Int32)(FT_Byte)(p)[1] <<  8 ) |   \
                           (FT_Int32)(FT_Byte)(p)[2]         ) )

#define FT_GET_UOFF3_BE( p )                                      \
          ( (FT_Int32) ( ( (FT_UInt32)(FT_Byte)(p)[0] << 16 ) |   \
                         ( (FT_UInt32)(FT_Byte)(p)[1] <<  8 ) |   \
                           (FT_UInt32)(FT_Byte)(p)[2]         ) )

#define FT_GET_LONG_BE( p )                                      \
          ( (FT_Int32) ( ( (FT_Int32)(FT_Char)(p)[0] << 24 ) |   \
                         ( (FT_Int32)(FT_Byte)(p)[1] << 16 ) |   \
                         ( (FT_Int32)(FT_Byte)(p)[2] <<  8 ) |   \
                           (FT_Int32)(FT_Byte)(p)[3]         ) )

#define FT_GET_ULONG_BE( p )                                      \
          ( (FT_Int32) ( ( (FT_UInt32)(FT_Byte)(p)[0] << 24 ) |   \
                         ( (FT_UInt32)(FT_Byte)(p)[1] << 16 ) |   \
                         ( (FT_UInt32)(FT_Byte)(p)[2] <<  8 ) |   \
                           (FT_UInt32)(FT_Byte)(p)[3]         ) )

#define FT_GET_SHORT_LE( p )                                   \
          ((FT_Int16)( ( (FT_Int16)(FT_Char)(p)[1] <<  8 ) |   \
                         (FT_Int16)(FT_Byte)(p)[0]         ) )

#define FT_GET_USHORT_LE( p )                                   \
          ((FT_Int16)( ( (FT_UInt16)(FT_Byte)(p)[1] <<  8 ) |   \
                         (FT_UInt16)(FT_Byte)(p)[0]         ) )

#define FT_GET_OFF3_LE( p )                                      \
          ( (FT_Int32) ( ( (FT_Int32)(FT_Char)(p)[2] << 16 ) |   \
                         ( (FT_Int32)(FT_Byte)(p)[1] <<  8 ) |   \
                           (FT_Int32)(FT_Byte)(p)[0]         ) )

#define FT_GET_UOFF3_LE( p )                                      \
          ( (FT_Int32) ( ( (FT_UInt32)(FT_Byte)(p)[2] << 16 ) |   \
                         ( (FT_UInt32)(FT_Byte)(p)[1] <<  8 ) |   \
                           (FT_UInt32)(FT_Byte)(p)[0]         ) )

#define FT_GET_LONG_LE( p )                                      \
          ( (FT_Int32) ( ( (FT_Int32)(FT_Char)(p)[3] << 24 ) |   \
                         ( (FT_Int32)(FT_Byte)(p)[2] << 16 ) |   \
                         ( (FT_Int32)(FT_Byte)(p)[1] <<  8 ) |   \
                           (FT_Int32)(FT_Byte)(p)[0]         ) )

#define FT_GET_ULONG_LE( p )                                      \
          ( (FT_Int32) ( ( (FT_UInt32)(FT_Byte)(p)[3] << 24 ) |   \
                         ( (FT_UInt32)(FT_Byte)(p)[2] << 16 ) |   \
                         ( (FT_UInt32)(FT_Byte)(p)[1] <<  8 ) |   \
                           (FT_UInt32)(FT_Byte)(p)[0]         ) )


#define NEXT_Char( buffer )          \
          ( (signed char)*buffer++ )

#define NEXT_Byte( buffer )            \
          ( (unsigned char)*buffer++ )

#define NEXT_Short( buffer )                                        \
          ( (short)( buffer += 2, FT_GET_SHORT_BE( buffer - 2 ) ) )

#define NEXT_UShort( buffer )                                                 \
          ( (unsigned short)( buffer += 2, FT_GET_USHORT_BE( buffer - 2 ) ) )

#define NEXT_Offset( buffer )                                     \
          ( (long)( buffer += 3, FT_GET_OFF3_BE( buffer - 3 ) ) )

#define NEXT_UOffset( buffer )                                              \
          ( (unsigned long)( buffer += 3, FT_GET_UOFF3_BE( buffer - 3 ) ) )

#define NEXT_Long( buffer )                                       \
          ( (long)( buffer += 4, FT_GET_LONG_BE( buffer - 4 ) ) )

#define NEXT_ULong( buffer )                                                \
          ( (unsigned long)( buffer += 4, FT_GET_ULONG_BE( buffer - 4 ) ) )


#define NEXT_ShortLE( buffer )                                      \
          ( (short)( buffer += 2, FT_GET_SHORT_LE( buffer - 2 ) ) )

#define NEXT_UShortLE( buffer )                                               \
          ( (unsigned short)( buffer += 2, FT_GET_USHORT_LE( buffer - 2 ) ) )

#define NEXT_OffsetLE( buffer )                                   \
          ( (long)( buffer += 3, FT_GET_OFF3_LE( buffer - 3 ) ) )

#define NEXT_UOffsetLE( buffer )                                            \
          ( (unsigned long)( buffer += 3, FT_GET_UOFF3_LE( buffer - 3 ) ) )


#define NEXT_LongLE( buffer )                                     \
          ( (long)( buffer += 4, FT_GET_LONG_LE( buffer - 4 ) ) )

#define NEXT_ULongLE( buffer )                                              \
          ( (unsigned long)( buffer += 4, FT_GET_ULONG_LE( buffer - 4 ) ) )


  /*************************************************************************/
  /*                                                                       */
  /* Each GET_xxxx() macro uses an implicit `stream' variable.             */
  /*                                                                       */
#define FT_GET_MACRO( func, type )        ( (type)func( stream ) )

#define GET_Char()      FT_GET_MACRO( FT_Get_Char, FT_Char )
#define GET_Byte()      FT_GET_MACRO( FT_Get_Char, FT_Byte )
#define GET_Short()     FT_GET_MACRO( FT_Get_Short, FT_Short )
#define GET_UShort()    FT_GET_MACRO( FT_Get_Short, FT_UShort )
#define GET_Offset()    FT_GET_MACRO( FT_Get_Offset, FT_Long )
#define GET_UOffset()   FT_GET_MACRO( FT_Get_Offset, FT_ULong )
#define GET_Long()      FT_GET_MACRO( FT_Get_Long, FT_Long )
#define GET_ULong()     FT_GET_MACRO( FT_Get_Long, FT_ULong )
#define GET_Tag4()      FT_GET_MACRO( FT_Get_Long, FT_ULong )

#define GET_ShortLE()   FT_GET_MACRO( FT_Get_ShortLE, FT_Short )
#define GET_UShortLE()  FT_GET_MACRO( FT_Get_ShortLE, FT_UShort )
#define GET_LongLE()    FT_GET_MACRO( FT_Get_LongLE, FT_Long )
#define GET_ULongLE()   FT_GET_MACRO( FT_Get_LongLE, FT_ULong )

#define FT_READ_MACRO( func, type, var )        \
          ( var = (type)func( stream, &error ), \
            error != FT_Err_Ok )

#define READ_Byte( var )      FT_READ_MACRO( FT_Read_Char, FT_Byte, var )
#define READ_Char( var )      FT_READ_MACRO( FT_Read_Char, FT_Char, var )
#define READ_Short( var )     FT_READ_MACRO( FT_Read_Short, FT_Short, var )
#define READ_UShort( var )    FT_READ_MACRO( FT_Read_Short, FT_UShort, var )
#define READ_Offset( var )    FT_READ_MACRO( FT_Read_Offset, FT_Long, var )
#define READ_UOffset( var )   FT_READ_MACRO( FT_Read_Offset, FT_ULong, var )
#define READ_Long( var )      FT_READ_MACRO( FT_Read_Long, FT_Long, var )
#define READ_ULong( var )     FT_READ_MACRO( FT_Read_Long, FT_ULong, var )

#define READ_ShortLE( var )   FT_READ_MACRO( FT_Read_ShortLE, FT_Short, var )
#define READ_UShortLE( var )  FT_READ_MACRO( FT_Read_ShortLE, FT_UShort, var )
#define READ_LongLE( var )    FT_READ_MACRO( FT_Read_LongLE, FT_Long, var )
#define READ_ULongLE( var )   FT_READ_MACRO( FT_Read_LongLE, FT_ULong, var )


  FT_BASE( void )
  FT_New_Memory_Stream( FT_Library  library,
                        FT_Byte*    base,
                        FT_ULong    size,
                        FT_Stream   stream );

  FT_BASE( FT_Error )
  FT_Seek_Stream( FT_Stream  stream,
                  FT_ULong   pos );

  FT_BASE( FT_Error )
  FT_Skip_Stream( FT_Stream  stream,
                  FT_Long    distance );

  FT_BASE( FT_Long )
  FT_Stream_Pos( FT_Stream  stream );


  FT_BASE( FT_Error )
  FT_Read_Stream( FT_Stream  stream,
                  FT_Byte*   buffer,
                  FT_ULong   count );

  FT_BASE( FT_Error )
  FT_Read_Stream_At( FT_Stream  stream,
                     FT_ULong   pos,
                     FT_Byte*   buffer,
                     FT_ULong   count );

  FT_BASE( FT_Error )
  FT_Access_Frame( FT_Stream  stream,
                   FT_ULong   count );

  FT_BASE( void )
  FT_Forget_Frame( FT_Stream  stream );

  FT_BASE( FT_Error )
  FT_Extract_Frame( FT_Stream  stream,
                    FT_ULong   count,
                    FT_Byte**  pbytes );

  FT_BASE( void )
  FT_Release_Frame( FT_Stream  stream,
                    FT_Byte**  pbytes );

  FT_BASE( FT_Char )
  FT_Get_Char( FT_Stream  stream );

  FT_BASE( FT_Short )
  FT_Get_Short( FT_Stream  stream );

  FT_BASE( FT_Long )
  FT_Get_Offset( FT_Stream  stream );

  FT_BASE( FT_Long )
  FT_Get_Long( FT_Stream  stream );

  FT_BASE( FT_Short )
  FT_Get_ShortLE( FT_Stream  stream );

  FT_BASE( FT_Long )
  FT_Get_LongLE( FT_Stream  stream );


  FT_BASE( FT_Char )
  FT_Read_Char( FT_Stream  stream,
                FT_Error*  error );

  FT_BASE( FT_Short )
  FT_Read_Short( FT_Stream  stream,
                 FT_Error*  error );

  FT_BASE( FT_Long )
  FT_Read_Offset( FT_Stream  stream,
                  FT_Error*  error );

  FT_BASE( FT_Long )
  FT_Read_Long( FT_Stream  stream,
                FT_Error*  error );

  FT_BASE( FT_Short )
  FT_Read_ShortLE( FT_Stream  stream,
                   FT_Error*  error );

  FT_BASE( FT_Long )
  FT_Read_LongLE( FT_Stream  stream,
                  FT_Error*  error );

  FT_BASE( FT_Error )
  FT_Read_Fields( FT_Stream              stream,
                  const FT_Frame_Field*  fields,
                  void*                  structure );


#define USE_Stream( resource, stream )                       \
          FT_SET_ERROR( FT_Open_Stream( resource, stream ) )

#define DONE_Stream( stream )      \
          FT_Done_Stream( stream )


#define ACCESS_Frame( size )                              \
          FT_SET_ERROR( FT_Access_Frame( stream, size ) )

#define FORGET_Frame()              \
          FT_Forget_Frame( stream )

#define EXTRACT_Frame( size, bytes )                              \
          FT_SET_ERROR( FT_Extract_Frame( stream, size,           \
                                          (FT_Byte**)&(bytes) ) )

#define RELEASE_Frame( bytes )                            \
          FT_Release_Frame( stream, (FT_Byte**)&(bytes) )

#define FILE_Seek( position )                                \
          FT_SET_ERROR( FT_Seek_Stream( stream, position ) )

#define FILE_Skip( distance )                                \
          FT_SET_ERROR( FT_Skip_Stream( stream, distance ) )

#define FILE_Pos()                \
          FT_Stream_Pos( stream )

#define FILE_Read( buffer, count )                        \
          FT_SET_ERROR( FT_Read_Stream( stream,           \
                                        (FT_Byte*)buffer, \
                                        count ) )

#define FILE_Read_At( position, buffer, count )              \
          FT_SET_ERROR( FT_Read_Stream_At( stream,           \
                                           position,         \
                                           (FT_Byte*)buffer, \
                                           count ) )

#define READ_Fields( fields, object )  \
        ( ( error = FT_Read_Fields( stream, fields, object ) ) != FT_Err_Ok )


FT_END_HEADER

#endif /* __FTSTREAM_H__ */


/* END */
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d5 1
a5 1
/*    Stream handling (specification).                                     */
d7 1
a7 1
/*  Copyright 1996-2001, 2002 by                                           */
a23 1
#include FT_SYSTEM_H
d30 4
a33 8
  /* format of an 8-bit frame_op value:           */
  /*                                              */
  /* bit  76543210                                */
  /*      xxxxxxes                                */
  /*                                              */
  /* s is set to 1 if the value is signed.        */
  /* e is set to 1 if the value is little-endian. */
  /* xxx is a command.                            */
d43 7
a49 7
#define FT_FRAME_OP_END    0
#define FT_FRAME_OP_START  1  /* start a new frame     */
#define FT_FRAME_OP_BYTE   2  /* read 1-byte value     */
#define FT_FRAME_OP_SHORT  3  /* read 2-byte value     */
#define FT_FRAME_OP_LONG   4  /* read 4-byte value     */
#define FT_FRAME_OP_OFF3   5  /* read 3-byte value     */
#define FT_FRAME_OP_BYTES  6  /* read a bytes sequence */
d83 3
a85 3
    FT_Byte    value;
    FT_Byte    size;
    FT_UShort  offset;
a92 1
  /*                                                                       */
a117 2
#define FT_FRAME_OFF3( f )       FT_FRAME_FIELD( ft_frame_off3_be, f )
#define FT_FRAME_UOFF3( f )      FT_FRAME_FIELD( ft_frame_uoff3_be, f )
a124 2
#define FT_FRAME_OFF3_LE( f )    FT_FRAME_FIELD( ft_frame_off3_le, f )
#define FT_FRAME_UOFF3_LE( f )   FT_FRAME_FIELD( ft_frame_uoff3_le, f )
d140 1
d143 1
a143 1
  /* Integer extraction macros -- the `buffer' parameter must ALWAYS be of */
d147 59
a205 38
#define FT_BYTE_( p, i )  ( ((const FT_Byte*)(p))[(i)] )
#define FT_INT8_( p, i )  ( ((const FT_Char*)(p))[(i)] )

#define FT_INT16( x )   ( (FT_Int16)(x)  )
#define FT_UINT16( x )  ( (FT_UInt16)(x) )
#define FT_INT32( x )   ( (FT_Int32)(x)  )
#define FT_UINT32( x )  ( (FT_UInt32)(x) )

#define FT_BYTE_I16( p, i, s )  ( FT_INT16(  FT_BYTE_( p, i ) ) << (s) )
#define FT_BYTE_U16( p, i, s )  ( FT_UINT16( FT_BYTE_( p, i ) ) << (s) )
#define FT_BYTE_I32( p, i, s )  ( FT_INT32(  FT_BYTE_( p, i ) ) << (s) )
#define FT_BYTE_U32( p, i, s )  ( FT_UINT32( FT_BYTE_( p, i ) ) << (s) )

#define FT_INT8_I16( p, i, s )  ( FT_INT16(  FT_INT8_( p, i ) ) << (s) )
#define FT_INT8_U16( p, i, s )  ( FT_UINT16( FT_INT8_( p, i ) ) << (s) )
#define FT_INT8_I32( p, i, s )  ( FT_INT32(  FT_INT8_( p, i ) ) << (s) )
#define FT_INT8_U32( p, i, s )  ( FT_UINT32( FT_INT8_( p, i ) ) << (s) )


#define FT_PEEK_SHORT( p )  FT_INT16( FT_INT8_I16( p, 0, 8) | \
                                      FT_BYTE_I16( p, 1, 0) )

#define FT_PEEK_USHORT( p )  FT_UINT16( FT_BYTE_U16( p, 0, 8 ) | \
                                        FT_BYTE_U16( p, 1, 0 ) )

#define FT_PEEK_LONG( p )  FT_INT32( FT_INT8_I32( p, 0, 24 ) | \
                                     FT_BYTE_I32( p, 1, 16 ) | \
                                     FT_BYTE_I32( p, 2,  8 ) | \
                                     FT_BYTE_I32( p, 3,  0 ) )

#define FT_PEEK_ULONG( p )  FT_UINT32( FT_BYTE_U32( p, 0, 24 ) | \
                                       FT_BYTE_U32( p, 1, 16 ) | \
                                       FT_BYTE_U32( p, 2,  8 ) | \
                                       FT_BYTE_U32( p, 3,  0 ) )

#define FT_PEEK_OFF3( p )  FT_INT32( FT_INT8_I32( p, 0, 16 ) | \
                                     FT_BYTE_I32( p, 1,  8 ) | \
                                     FT_BYTE_I32( p, 2,  0 ) )
a206 3
#define FT_PEEK_UOFF3( p )  FT_UINT32( FT_BYTE_U32( p, 0, 16 ) | \
                                       FT_BYTE_U32( p, 1,  8 ) | \
                                       FT_BYTE_U32( p, 2,  0 ) )
d208 1
a208 26
#define FT_PEEK_SHORT_LE( p )  FT_INT16( FT_INT8_I16( p, 1, 8 ) | \
                                         FT_BYTE_I16( p, 0, 0 ) )

#define FT_PEEK_USHORT_LE( p )  FT_UINT16( FT_BYTE_U16( p, 1, 8 ) |  \
                                           FT_BYTE_U16( p, 0, 0 ) )

#define FT_PEEK_LONG_LE( p )  FT_INT32( FT_INT8_I32( p, 3, 24 ) | \
                                        FT_BYTE_I32( p, 2, 16 ) | \
                                        FT_BYTE_I32( p, 1,  8 ) | \
                                        FT_BYTE_I32( p, 0,  0 ) )

#define FT_PEEK_ULONG_LE( p )  FT_UINT32( FT_BYTE_U32( p, 3, 24 ) | \
                                          FT_BYTE_U32( p, 2, 16 ) | \
                                          FT_BYTE_U32( p, 1,  8 ) | \
                                          FT_BYTE_U32( p, 0,  0 ) )

#define FT_PEEK_OFF3_LE( p )  FT_INT32( FT_INT8_I32( p, 2, 16 ) | \
                                        FT_BYTE_I32( p, 1,  8 ) | \
                                        FT_BYTE_I32( p, 0,  0 ) )

#define FT_PEEK_UOFF3_LE( p )  FT_UINT32( FT_BYTE_U32( p, 2, 16 ) | \
                                          FT_BYTE_U32( p, 1,  8 ) | \
                                          FT_BYTE_U32( p, 0,  0 ) )


#define FT_NEXT_CHAR( buffer )       \
d211 1
a211 1
#define FT_NEXT_BYTE( buffer )         \
d214 5
a218 2
#define FT_NEXT_SHORT( buffer )                                   \
          ( (short)( buffer += 2, FT_PEEK_SHORT( buffer - 2 ) ) )
d220 2
a221 2
#define FT_NEXT_USHORT( buffer )                                            \
          ( (unsigned short)( buffer += 2, FT_PEEK_USHORT( buffer - 2 ) ) )
d223 2
a224 2
#define FT_NEXT_OFF3( buffer )                                  \
          ( (long)( buffer += 3, FT_PEEK_OFF3( buffer - 3 ) ) )
d226 2
a227 2
#define FT_NEXT_UOFF3( buffer )                                           \
          ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3( buffer - 3 ) ) )
d229 2
a230 2
#define FT_NEXT_LONG( buffer )                                  \
          ( (long)( buffer += 4, FT_PEEK_LONG( buffer - 4 ) ) )
a231 2
#define FT_NEXT_ULONG( buffer )                                           \
          ( (unsigned long)( buffer += 4, FT_PEEK_ULONG( buffer - 4 ) ) )
d233 2
d236 2
a237 2
#define FT_NEXT_SHORT_LE( buffer )                                   \
          ( (short)( buffer += 2, FT_PEEK_SHORT_LE( buffer - 2 ) ) )
d239 2
a240 2
#define FT_NEXT_USHORT_LE( buffer )                                            \
          ( (unsigned short)( buffer += 2, FT_PEEK_USHORT_LE( buffer - 2 ) ) )
d242 2
a243 2
#define FT_NEXT_OFF3_LE( buffer )                                  \
          ( (long)( buffer += 3, FT_PEEK_OFF3_LE( buffer - 3 ) ) )
a244 2
#define FT_NEXT_UOFF3_LE( buffer )                                           \
          ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3_LE( buffer - 3 ) ) )
d246 2
a247 2
#define FT_NEXT_LONG_LE( buffer )                                  \
          ( (long)( buffer += 4, FT_PEEK_LONG_LE( buffer - 4 ) ) )
d249 2
a250 2
#define FT_NEXT_ULONG_LE( buffer )                                           \
          ( (unsigned long)( buffer += 4, FT_PEEK_ULONG_LE( buffer - 4 ) ) )
d259 14
a272 14
#define FT_GET_CHAR()       FT_GET_MACRO( FT_Stream_GetChar, FT_Char )
#define FT_GET_BYTE()       FT_GET_MACRO( FT_Stream_GetChar, FT_Byte )
#define FT_GET_SHORT()      FT_GET_MACRO( FT_Stream_GetShort, FT_Short )
#define FT_GET_USHORT()     FT_GET_MACRO( FT_Stream_GetShort, FT_UShort )
#define FT_GET_OFF3()       FT_GET_MACRO( FT_Stream_GetOffset, FT_Long )
#define FT_GET_UOFF3()      FT_GET_MACRO( FT_Stream_GetOffset, FT_ULong )
#define FT_GET_LONG()       FT_GET_MACRO( FT_Stream_GetLong, FT_Long )
#define FT_GET_ULONG()      FT_GET_MACRO( FT_Stream_GetLong, FT_ULong )
#define FT_GET_TAG4()       FT_GET_MACRO( FT_Stream_GetLong, FT_ULong )

#define FT_GET_SHORT_LE()   FT_GET_MACRO( FT_Stream_GetShortLE, FT_Short )
#define FT_GET_USHORT_LE()  FT_GET_MACRO( FT_Stream_GetShortLE, FT_UShort )
#define FT_GET_LONG_LE()    FT_GET_MACRO( FT_Stream_GetLongLE, FT_Long )
#define FT_GET_ULONG_LE()   FT_GET_MACRO( FT_Stream_GetLongLE, FT_ULong )
d278 13
a290 16
#define FT_READ_BYTE( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Byte, var )
#define FT_READ_CHAR( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Char, var )
#define FT_READ_SHORT( var )      FT_READ_MACRO( FT_Stream_ReadShort, FT_Short, var )
#define FT_READ_USHORT( var )     FT_READ_MACRO( FT_Stream_ReadShort, FT_UShort, var )
#define FT_READ_OFF3( var )       FT_READ_MACRO( FT_Stream_ReadOffset, FT_Long, var )
#define FT_READ_UOFF3( var )      FT_READ_MACRO( FT_Stream_ReadOffset, FT_ULong, var )
#define FT_READ_LONG( var )       FT_READ_MACRO( FT_Stream_ReadLong, FT_Long, var )
#define FT_READ_ULONG( var )      FT_READ_MACRO( FT_Stream_ReadLong, FT_ULong, var )

#define FT_READ_SHORT_LE( var )   FT_READ_MACRO( FT_Stream_ReadShortLE, FT_Short, var )
#define FT_READ_USHORT_LE( var )  FT_READ_MACRO( FT_Stream_ReadShortLE, FT_UShort, var )
#define FT_READ_LONG_LE( var )    FT_READ_MACRO( FT_Stream_ReadLongLE, FT_Long, var )
#define FT_READ_ULONG_LE( var )   FT_READ_MACRO( FT_Stream_ReadLongLE, FT_ULong, var )


#ifndef FT_CONFIG_OPTION_NO_DEFAULT_SYSTEM
a291 4
  /* initialize a stream for reading a regular system stream */
  FT_EXPORT( FT_Error )
  FT_Stream_Open( FT_Stream    stream,
                  const char*  filepathname );
a292 10
#endif /* FT_CONFIG_OPTION_NO_DEFAULT_SYSTEM */


  /* initialize a stream for reading in-memory data */
  FT_BASE( void )
  FT_Stream_OpenMemory( FT_Stream       stream,
                        const FT_Byte*  base,
                        FT_ULong        size );

  /* close a stream (does not destroy the stream structure) */
d294 4
a297 2
  FT_Stream_Close( FT_Stream  stream );

a298 1
  /* seek within a stream. position is relative to start of stream */
d300 1
a300 1
  FT_Stream_Seek( FT_Stream  stream,
a302 1
  /* skip bytes in a stream */
d304 1
a304 1
  FT_Stream_Skip( FT_Stream  stream,
a306 1
  /* return current stream position */
d310 1
a310 2
  /* read bytes from a stream into a user-allocated buffer, returns an */
  /* error if not all bytes could be read.                             */
d312 1
a312 1
  FT_Stream_Read( FT_Stream  stream,
a315 1
  /* read bytes from a stream at a given position */
d317 5
a321 13
  FT_Stream_ReadAt( FT_Stream  stream,
                    FT_ULong   pos,
                    FT_Byte*   buffer,
                    FT_ULong   count );

  /* Enter a frame of `count' consecutive bytes in a stream.  Returns an */
  /* error if the frame could not be read/accessed.  The caller can use  */
  /* the FT_Stream_Get_XXX functions to retrieve frame data without      */
  /* error checks.                                                       */
  /*                                                                     */
  /* You must _always_ call FT_Stream_ExitFrame() once you have entered  */
  /* a stream frame!                                                     */
  /*                                                                     */
d323 2
a324 2
  FT_Stream_EnterFrame( FT_Stream  stream,
                        FT_ULong   count );
a325 1
  /* exit a stream frame */
d327 1
a327 1
  FT_Stream_ExitFrame( FT_Stream  stream );
a328 9
  /* Extract a stream frame.  If the stream is disk-based, a heap block */
  /* is allocated and the frame bytes are read into it.  If the stream  */
  /* is memory-based, this function simply set a pointer to the data.   */
  /*                                                                    */
  /* Useful to optimize access to memory-based streams transparently.   */
  /*                                                                    */
  /* All extracted frames must be `freed` with a call to the function   */
  /* FT_Stream_ReleaseFrame().                                          */
  /*                                                                    */
d330 3
a332 3
  FT_Stream_ExtractFrame( FT_Stream  stream,
                          FT_ULong   count,
                          FT_Byte**  pbytes );
a333 1
  /* release an extract frame (see FT_Stream_ExtractFrame) */
d335 2
a336 2
  FT_Stream_ReleaseFrame( FT_Stream  stream,
                          FT_Byte**  pbytes );
a337 1
  /* read a byte from an entered frame */
d339 1
a339 1
  FT_Stream_GetChar( FT_Stream  stream );
a340 1
  /* read a 16-bit big-endian integer from an entered frame */
d342 1
a342 1
  FT_Stream_GetShort( FT_Stream  stream );
a343 1
  /* read a 24-bit big-endian integer from an entered frame */
d345 1
a345 1
  FT_Stream_GetOffset( FT_Stream  stream );
a346 1
  /* read a 32-bit big-endian integer from an entered frame */
d348 1
a348 1
  FT_Stream_GetLong( FT_Stream  stream );
a349 1
  /* read a 16-bit little-endian integer from an entered frame */
d351 1
a351 1
  FT_Stream_GetShortLE( FT_Stream  stream );
a352 1
  /* read a 32-bit little-endian integer from an entered frame */
d354 1
a354 1
  FT_Stream_GetLongLE( FT_Stream  stream );
a356 1
  /* read a byte from a stream */
d358 2
a359 2
  FT_Stream_ReadChar( FT_Stream  stream,
                      FT_Error*  error );
a360 1
  /* read a 16-bit big-endian integer from a stream */
d362 2
a363 2
  FT_Stream_ReadShort( FT_Stream  stream,
                       FT_Error*  error );
a364 1
  /* read a 24-bit big-endian integer from a stream */
d366 2
a367 2
  FT_Stream_ReadOffset( FT_Stream  stream,
                        FT_Error*  error );
a368 1
  /* read a 32-bit big-endian integer from a stream */
d370 2
a371 2
  FT_Stream_ReadLong( FT_Stream  stream,
                      FT_Error*  error );
a372 1
  /* read a 16-bit little-endian integer from a stream */
d374 2
a375 2
  FT_Stream_ReadShortLE( FT_Stream  stream,
                         FT_Error*  error );
a376 1
  /* read a 32-bit little-endian integer from a stream */
d378 2
a379 2
  FT_Stream_ReadLongLE( FT_Stream  stream,
                        FT_Error*  error );
a380 2
  /* Read a structure from a stream.  The structure must be described */
  /* by an array of FT_Frame_Field records.                           */
d382 11
a392 3
  FT_Stream_ReadFields( FT_Stream              stream,
                        const FT_Frame_Field*  fields,
                        void*                  structure );
d394 2
d397 12
a408 2
#define FT_STREAM_POS()           \
          FT_Stream_Pos( stream )
d410 2
a411 2
#define FT_STREAM_SEEK( position )                           \
          FT_SET_ERROR( FT_Stream_Seek( stream, position ) )
d413 2
a414 2
#define FT_STREAM_SKIP( distance )                           \
          FT_SET_ERROR( FT_Stream_Skip( stream, distance ) )
d416 2
a417 2
#define FT_STREAM_READ( buffer, count )                   \
          FT_SET_ERROR( FT_Stream_Read( stream,           \
d421 2
a422 2
#define FT_STREAM_READ_AT( position, buffer, count )         \
          FT_SET_ERROR( FT_Stream_ReadAt( stream,            \
d427 2
a428 16
#define FT_STREAM_READ_FIELDS( fields, object )                          \
          FT_SET_ERROR( FT_Stream_ReadFields( stream, fields, object ) )


#define FT_FRAME_ENTER( size )                                 \
          FT_SET_ERROR( FT_Stream_EnterFrame( stream, size ) )

#define FT_FRAME_EXIT()                 \
          FT_Stream_ExitFrame( stream )

#define FT_FRAME_EXTRACT( size, bytes )                                 \
          FT_SET_ERROR( FT_Stream_ExtractFrame( stream, size,           \
                                                (FT_Byte**)&(bytes) ) )

#define FT_FRAME_RELEASE( bytes )                               \
          FT_Stream_ReleaseFrame( stream, (FT_Byte**)&(bytes) )
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d5 1
a5 1
/*    Stream handling (specification).                                     */
d7 1
a7 1
/*  Copyright 1996-2001, 2002 by                                           */
d30 4
a33 8
  /* format of an 8-bit frame_op value:           */
  /*                                              */
  /* bit  76543210                                */
  /*      xxxxxxes                                */
  /*                                              */
  /* s is set to 1 if the value is signed.        */
  /* e is set to 1 if the value is little-endian. */
  /* xxx is a command.                            */
d43 7
a49 7
#define FT_FRAME_OP_END    0
#define FT_FRAME_OP_START  1  /* start a new frame     */
#define FT_FRAME_OP_BYTE   2  /* read 1-byte value     */
#define FT_FRAME_OP_SHORT  3  /* read 2-byte value     */
#define FT_FRAME_OP_LONG   4  /* read 4-byte value     */
#define FT_FRAME_OP_OFF3   5  /* read 3-byte value     */
#define FT_FRAME_OP_BYTES  6  /* read a bytes sequence */
d83 3
a85 3
    FT_Byte    value;
    FT_Byte    size;
    FT_UShort  offset;
a92 1
  /*                                                                       */
a117 2
#define FT_FRAME_OFF3( f )       FT_FRAME_FIELD( ft_frame_off3_be, f )
#define FT_FRAME_UOFF3( f )      FT_FRAME_FIELD( ft_frame_uoff3_be, f )
a124 2
#define FT_FRAME_OFF3_LE( f )    FT_FRAME_FIELD( ft_frame_off3_le, f )
#define FT_FRAME_UOFF3_LE( f )   FT_FRAME_FIELD( ft_frame_uoff3_le, f )
d140 1
d143 1
a143 1
  /* Integer extraction macros -- the `buffer' parameter must ALWAYS be of */
d147 59
a205 38
#define FT_BYTE_( p, i )  ( ((const FT_Byte*)(p))[(i)] )
#define FT_INT8_( p, i )  ( ((const FT_Char*)(p))[(i)] )

#define FT_INT16( x )   ( (FT_Int16)(x)  )
#define FT_UINT16( x )  ( (FT_UInt16)(x) )
#define FT_INT32( x )   ( (FT_Int32)(x)  )
#define FT_UINT32( x )  ( (FT_UInt32)(x) )

#define FT_BYTE_I16( p, i, s )  ( FT_INT16(  FT_BYTE_( p, i ) ) << (s) )
#define FT_BYTE_U16( p, i, s )  ( FT_UINT16( FT_BYTE_( p, i ) ) << (s) )
#define FT_BYTE_I32( p, i, s )  ( FT_INT32(  FT_BYTE_( p, i ) ) << (s) )
#define FT_BYTE_U32( p, i, s )  ( FT_UINT32( FT_BYTE_( p, i ) ) << (s) )

#define FT_INT8_I16( p, i, s )  ( FT_INT16(  FT_INT8_( p, i ) ) << (s) )
#define FT_INT8_U16( p, i, s )  ( FT_UINT16( FT_INT8_( p, i ) ) << (s) )
#define FT_INT8_I32( p, i, s )  ( FT_INT32(  FT_INT8_( p, i ) ) << (s) )
#define FT_INT8_U32( p, i, s )  ( FT_UINT32( FT_INT8_( p, i ) ) << (s) )


#define FT_PEEK_SHORT( p )  FT_INT16( FT_INT8_I16( p, 0, 8) | \
                                      FT_BYTE_I16( p, 1, 0) )

#define FT_PEEK_USHORT( p )  FT_UINT16( FT_BYTE_U16( p, 0, 8 ) | \
                                        FT_BYTE_U16( p, 1, 0 ) )

#define FT_PEEK_LONG( p )  FT_INT32( FT_INT8_I32( p, 0, 24 ) | \
                                     FT_BYTE_I32( p, 1, 16 ) | \
                                     FT_BYTE_I32( p, 2,  8 ) | \
                                     FT_BYTE_I32( p, 3,  0 ) )

#define FT_PEEK_ULONG( p )  FT_UINT32( FT_BYTE_U32( p, 0, 24 ) | \
                                       FT_BYTE_U32( p, 1, 16 ) | \
                                       FT_BYTE_U32( p, 2,  8 ) | \
                                       FT_BYTE_U32( p, 3,  0 ) )

#define FT_PEEK_OFF3( p )  FT_INT32( FT_INT8_I32( p, 0, 16 ) | \
                                     FT_BYTE_I32( p, 1,  8 ) | \
                                     FT_BYTE_I32( p, 2,  0 ) )
a206 3
#define FT_PEEK_UOFF3( p )  FT_UINT32( FT_BYTE_U32( p, 0, 16 ) | \
                                       FT_BYTE_U32( p, 1,  8 ) | \
                                       FT_BYTE_U32( p, 2,  0 ) )
d208 1
a208 26
#define FT_PEEK_SHORT_LE( p )  FT_INT16( FT_INT8_I16( p, 1, 8 ) | \
                                         FT_BYTE_I16( p, 0, 0 ) )

#define FT_PEEK_USHORT_LE( p )  FT_UINT16( FT_BYTE_U16( p, 1, 8 ) |  \
                                           FT_BYTE_U16( p, 0, 0 ) )

#define FT_PEEK_LONG_LE( p )  FT_INT32( FT_INT8_I32( p, 3, 24 ) | \
                                        FT_BYTE_I32( p, 2, 16 ) | \
                                        FT_BYTE_I32( p, 1,  8 ) | \
                                        FT_BYTE_I32( p, 0,  0 ) )

#define FT_PEEK_ULONG_LE( p )  FT_UINT32( FT_BYTE_U32( p, 3, 24 ) | \
                                          FT_BYTE_U32( p, 2, 16 ) | \
                                          FT_BYTE_U32( p, 1,  8 ) | \
                                          FT_BYTE_U32( p, 0,  0 ) )

#define FT_PEEK_OFF3_LE( p )  FT_INT32( FT_INT8_I32( p, 2, 16 ) | \
                                        FT_BYTE_I32( p, 1,  8 ) | \
                                        FT_BYTE_I32( p, 0,  0 ) )

#define FT_PEEK_UOFF3_LE( p )  FT_UINT32( FT_BYTE_U32( p, 2, 16 ) | \
                                          FT_BYTE_U32( p, 1,  8 ) | \
                                          FT_BYTE_U32( p, 0,  0 ) )


#define FT_NEXT_CHAR( buffer )       \
d211 1
a211 1
#define FT_NEXT_BYTE( buffer )         \
d214 5
a218 2
#define FT_NEXT_SHORT( buffer )                                   \
          ( (short)( buffer += 2, FT_PEEK_SHORT( buffer - 2 ) ) )
d220 2
a221 2
#define FT_NEXT_USHORT( buffer )                                            \
          ( (unsigned short)( buffer += 2, FT_PEEK_USHORT( buffer - 2 ) ) )
d223 2
a224 2
#define FT_NEXT_OFF3( buffer )                                  \
          ( (long)( buffer += 3, FT_PEEK_OFF3( buffer - 3 ) ) )
d226 2
a227 2
#define FT_NEXT_UOFF3( buffer )                                           \
          ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3( buffer - 3 ) ) )
d229 2
a230 2
#define FT_NEXT_LONG( buffer )                                  \
          ( (long)( buffer += 4, FT_PEEK_LONG( buffer - 4 ) ) )
a231 2
#define FT_NEXT_ULONG( buffer )                                           \
          ( (unsigned long)( buffer += 4, FT_PEEK_ULONG( buffer - 4 ) ) )
d233 2
d236 2
a237 2
#define FT_NEXT_SHORT_LE( buffer )                                   \
          ( (short)( buffer += 2, FT_PEEK_SHORT_LE( buffer - 2 ) ) )
d239 2
a240 2
#define FT_NEXT_USHORT_LE( buffer )                                            \
          ( (unsigned short)( buffer += 2, FT_PEEK_USHORT_LE( buffer - 2 ) ) )
d242 2
a243 2
#define FT_NEXT_OFF3_LE( buffer )                                  \
          ( (long)( buffer += 3, FT_PEEK_OFF3_LE( buffer - 3 ) ) )
a244 2
#define FT_NEXT_UOFF3_LE( buffer )                                           \
          ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3_LE( buffer - 3 ) ) )
d246 2
a247 2
#define FT_NEXT_LONG_LE( buffer )                                  \
          ( (long)( buffer += 4, FT_PEEK_LONG_LE( buffer - 4 ) ) )
d249 2
a250 2
#define FT_NEXT_ULONG_LE( buffer )                                           \
          ( (unsigned long)( buffer += 4, FT_PEEK_ULONG_LE( buffer - 4 ) ) )
d259 14
a272 14
#define FT_GET_CHAR()       FT_GET_MACRO( FT_Stream_GetChar, FT_Char )
#define FT_GET_BYTE()       FT_GET_MACRO( FT_Stream_GetChar, FT_Byte )
#define FT_GET_SHORT()      FT_GET_MACRO( FT_Stream_GetShort, FT_Short )
#define FT_GET_USHORT()     FT_GET_MACRO( FT_Stream_GetShort, FT_UShort )
#define FT_GET_OFF3()       FT_GET_MACRO( FT_Stream_GetOffset, FT_Long )
#define FT_GET_UOFF3()      FT_GET_MACRO( FT_Stream_GetOffset, FT_ULong )
#define FT_GET_LONG()       FT_GET_MACRO( FT_Stream_GetLong, FT_Long )
#define FT_GET_ULONG()      FT_GET_MACRO( FT_Stream_GetLong, FT_ULong )
#define FT_GET_TAG4()       FT_GET_MACRO( FT_Stream_GetLong, FT_ULong )

#define FT_GET_SHORT_LE()   FT_GET_MACRO( FT_Stream_GetShortLE, FT_Short )
#define FT_GET_USHORT_LE()  FT_GET_MACRO( FT_Stream_GetShortLE, FT_UShort )
#define FT_GET_LONG_LE()    FT_GET_MACRO( FT_Stream_GetLongLE, FT_Long )
#define FT_GET_ULONG_LE()   FT_GET_MACRO( FT_Stream_GetLongLE, FT_ULong )
d278 13
a290 16
#define FT_READ_BYTE( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Byte, var )
#define FT_READ_CHAR( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Char, var )
#define FT_READ_SHORT( var )      FT_READ_MACRO( FT_Stream_ReadShort, FT_Short, var )
#define FT_READ_USHORT( var )     FT_READ_MACRO( FT_Stream_ReadShort, FT_UShort, var )
#define FT_READ_OFF3( var )       FT_READ_MACRO( FT_Stream_ReadOffset, FT_Long, var )
#define FT_READ_UOFF3( var )      FT_READ_MACRO( FT_Stream_ReadOffset, FT_ULong, var )
#define FT_READ_LONG( var )       FT_READ_MACRO( FT_Stream_ReadLong, FT_Long, var )
#define FT_READ_ULONG( var )      FT_READ_MACRO( FT_Stream_ReadLong, FT_ULong, var )

#define FT_READ_SHORT_LE( var )   FT_READ_MACRO( FT_Stream_ReadShortLE, FT_Short, var )
#define FT_READ_USHORT_LE( var )  FT_READ_MACRO( FT_Stream_ReadShortLE, FT_UShort, var )
#define FT_READ_LONG_LE( var )    FT_READ_MACRO( FT_Stream_ReadLongLE, FT_Long, var )
#define FT_READ_ULONG_LE( var )   FT_READ_MACRO( FT_Stream_ReadLongLE, FT_ULong, var )


#ifndef FT_CONFIG_OPTION_NO_DEFAULT_SYSTEM
a291 4
  /* initialize a stream for reading a regular system stream */
  FT_EXPORT( FT_Error )
  FT_Stream_Open( FT_Stream    stream,
                  const char*  filepathname );
a292 10
#endif /* FT_CONFIG_OPTION_NO_DEFAULT_SYSTEM */


  /* initialize a stream for reading in-memory data */
  FT_BASE( void )
  FT_Stream_OpenMemory( FT_Stream       stream,
                        const FT_Byte*  base,
                        FT_ULong        size );

  /* close a stream (does not destroy the stream structure) */
d294 4
a297 2
  FT_Stream_Close( FT_Stream  stream );

a298 1
  /* seek within a stream. position is relative to start of stream */
d300 1
a300 1
  FT_Stream_Seek( FT_Stream  stream,
a302 1
  /* skip bytes in a stream */
d304 1
a304 1
  FT_Stream_Skip( FT_Stream  stream,
a306 1
  /* return current stream position */
d310 1
a310 2
  /* read bytes from a stream into a user-allocated buffer, returns an */
  /* error if not all bytes could be read.                             */
d312 1
a312 1
  FT_Stream_Read( FT_Stream  stream,
a315 1
  /* read bytes from a stream at a given position */
d317 5
a321 13
  FT_Stream_ReadAt( FT_Stream  stream,
                    FT_ULong   pos,
                    FT_Byte*   buffer,
                    FT_ULong   count );

  /* Enter a frame of `count' consecutive bytes in a stream.  Returns an */
  /* error if the frame could not be read/accessed.  The caller can use  */
  /* the FT_Stream_Get_XXX functions to retrieve frame data without      */
  /* error checks.                                                       */
  /*                                                                     */
  /* You must _always_ call FT_Stream_ExitFrame() once you have entered  */
  /* a stream frame!                                                     */
  /*                                                                     */
d323 2
a324 2
  FT_Stream_EnterFrame( FT_Stream  stream,
                        FT_ULong   count );
a325 1
  /* exit a stream frame */
d327 1
a327 1
  FT_Stream_ExitFrame( FT_Stream  stream );
a328 9
  /* Extract a stream frame.  If the stream is disk-based, a heap block */
  /* is allocated and the frame bytes are read into it.  If the stream  */
  /* is memory-based, this function simply set a pointer to the data.   */
  /*                                                                    */
  /* Useful to optimize access to memory-based streams transparently.   */
  /*                                                                    */
  /* All extracted frames must be `freed` with a call to the function   */
  /* FT_Stream_ReleaseFrame().                                          */
  /*                                                                    */
d330 3
a332 3
  FT_Stream_ExtractFrame( FT_Stream  stream,
                          FT_ULong   count,
                          FT_Byte**  pbytes );
a333 1
  /* release an extract frame (see FT_Stream_ExtractFrame) */
d335 3
a337 4
  FT_Stream_ReleaseFrame( FT_Stream  stream,
                          FT_Byte**  pbytes );
             
  /* read a byte from an entered frame */
d339 1
a339 1
  FT_Stream_GetChar( FT_Stream  stream );
a340 1
  /* read a 16-bit big-endian integer from an entered frame */
d342 1
a342 1
  FT_Stream_GetShort( FT_Stream  stream );
a343 1
  /* read a 24-bit big-endian integer from an entered frame */
d345 1
a345 1
  FT_Stream_GetOffset( FT_Stream  stream );
a346 1
  /* read a 32-bit big-endian integer from an entered frame */
d348 1
a348 1
  FT_Stream_GetLong( FT_Stream  stream );
a349 1
  /* read a 16-bit little-endian integer from an entered frame */
d351 1
a351 1
  FT_Stream_GetShortLE( FT_Stream  stream );
a352 1
  /* read a 32-bit little-endian integer from an entered frame */
d354 1
a354 1
  FT_Stream_GetLongLE( FT_Stream  stream );
a356 1
  /* read a byte from a stream */
d358 2
a359 2
  FT_Stream_ReadChar( FT_Stream  stream,
                      FT_Error*  error );
a360 1
  /* read a 16-bit big-endian integer from a stream */
d362 2
a363 2
  FT_Stream_ReadShort( FT_Stream  stream,
                       FT_Error*  error );
a364 1
  /* read a 24-bit big-endian integer from a stream */
d366 2
a367 2
  FT_Stream_ReadOffset( FT_Stream  stream,
                        FT_Error*  error );
a368 1
  /* read a 32-bit big-endian integer from a stream */
d370 2
a371 2
  FT_Stream_ReadLong( FT_Stream  stream,
                      FT_Error*  error );
a372 1
  /* read a 16-bit little-endian integer from a stream */
d374 2
a375 2
  FT_Stream_ReadShortLE( FT_Stream  stream,
                         FT_Error*  error );
a376 1
  /* read a 32-bit little-endian integer from a stream */
d378 2
a379 2
  FT_Stream_ReadLongLE( FT_Stream  stream,
                        FT_Error*  error );
a380 2
  /* Read a structure from a stream.  The structure must be described */
  /* by an array of FT_Frame_Field records.                           */
d382 10
a391 3
  FT_Stream_ReadFields( FT_Stream              stream,
                        const FT_Frame_Field*  fields,
                        void*                  structure );
d394 15
a408 2
#define FT_STREAM_POS()           \
          FT_Stream_Pos( stream )
d410 2
a411 2
#define FT_STREAM_SEEK( position )                           \
          FT_SET_ERROR( FT_Stream_Seek( stream, position ) )
d413 2
a414 2
#define FT_STREAM_SKIP( distance )                           \
          FT_SET_ERROR( FT_Stream_Skip( stream, distance ) )
d416 2
a417 2
#define FT_STREAM_READ( buffer, count )                   \
          FT_SET_ERROR( FT_Stream_Read( stream,           \
d421 2
a422 2
#define FT_STREAM_READ_AT( position, buffer, count )         \
          FT_SET_ERROR( FT_Stream_ReadAt( stream,            \
d427 2
a428 16
#define FT_STREAM_READ_FIELDS( fields, object )                          \
          FT_SET_ERROR( FT_Stream_ReadFields( stream, fields, object ) )


#define FT_FRAME_ENTER( size )                                 \
          FT_SET_ERROR( FT_Stream_EnterFrame( stream, size ) )

#define FT_FRAME_EXIT()                 \
          FT_Stream_ExitFrame( stream )

#define FT_FRAME_EXTRACT( size, bytes )                                 \
          FT_SET_ERROR( FT_Stream_ExtractFrame( stream, size,           \
                                                (FT_Byte**)&(bytes) ) )

#define FT_FRAME_RELEASE( bytes )                               \
          FT_Stream_ReleaseFrame( stream, (FT_Byte**)&(bytes) )
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@a23 1
#include FT_SYSTEM_H
d390 1
a390 1

@


