head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.29.47;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.01.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.01.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.21.01;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.38.28;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.09.00;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@/***************************************************************************/
/*                                                                         */
/*  cffobjs.c                                                              */
/*                                                                         */
/*    OpenType objects manager (body).                                     */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_CALC_H
#include FT_INTERNAL_STREAM_H
#include FT_ERRORS_H
#include FT_TRUETYPE_IDS_H
#include FT_TRUETYPE_TAGS_H
#include FT_INTERNAL_SFNT_H
#include FT_INTERNAL_POSTSCRIPT_NAMES_H
#include FT_INTERNAL_POSTSCRIPT_HINTS_H
#include "cffobjs.h"
#include "cffload.h"

#include "cfferrs.h"

#include <string.h>         /* for strlen() */


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_cffobjs




  /*************************************************************************/
  /*                                                                       */
  /*                            SIZE FUNCTIONS                             */
  /*                                                                       */
  /*  Note that we store the global hints in the size's "internal" root    */
  /*  field.                                                               */
  /*                                                                       */
  /*************************************************************************/


  static PSH_Globals_Funcs
  CFF_Size_Get_Globals_Funcs( CFF_Size  size )
  {
    CFF_Face             face     = (CFF_Face)size->face;
    CFF_Font*            font     = face->extra.data;
    PSHinter_Interface*  pshinter = font->pshinter;
    FT_Module            module;


    module = FT_Get_Module( size->face->driver->root.library,
                            "pshinter" );
    return ( module && pshinter && pshinter->get_globals_funcs )
           ? pshinter->get_globals_funcs( module )
           : 0;
  }


  FT_LOCAL_DEF void
  CFF_Size_Done( CFF_Size  size )
  {
    if ( size->internal )
    {
      PSH_Globals_Funcs  funcs;


      funcs = CFF_Size_Get_Globals_Funcs( size );
      if ( funcs )
        funcs->destroy( (PSH_Globals)size->internal );

      size->internal = 0;
    }
  }


  FT_LOCAL_DEF FT_Error
  CFF_Size_Init( CFF_Size  size )
  {
    FT_Error           error = 0;
    PSH_Globals_Funcs  funcs = CFF_Size_Get_Globals_Funcs( size );


    if ( funcs )
    {
      PSH_Globals   globals;
      CFF_Face      face    = (CFF_Face)size->face;
      CFF_Font*     font    = face->extra.data;
      CFF_SubFont*  subfont = &font->top_font;

      CFF_Private*  cpriv   = &subfont->private_dict;
      T1_Private    priv;


      /* IMPORTANT: The CFF and Type1 private dictionaries have    */
      /*            slightly different structures; we need to      */
      /*            synthetize a type1 dictionary on the fly here. */

      {
        FT_UInt  n, count;


        MEM_Set( &priv, 0, sizeof ( priv ) );

        count = priv.num_blue_values = cpriv->num_blue_values;
        for ( n = 0; n < count; n++ )
          priv.blue_values[n] = (FT_Short) cpriv->blue_values[n];

        count = priv.num_other_blues = cpriv->num_other_blues;
        for ( n = 0; n < count; n++ )
          priv.other_blues[n] = (FT_Short) cpriv->other_blues[n];

        count = priv.num_family_blues = cpriv->num_family_blues;
        for ( n = 0; n < count; n++ )
          priv.family_blues[n] = (FT_Short) cpriv->family_blues[n];

        count = priv.num_family_other_blues = cpriv->num_family_other_blues;
        for ( n = 0; n < count; n++ )
          priv.family_other_blues[n] = (FT_Short) cpriv->family_other_blues[n];

        priv.blue_scale = cpriv->blue_scale;
        priv.blue_shift = cpriv->blue_shift;
        priv.blue_fuzz  = cpriv->blue_fuzz;

        priv.standard_width[0]  = (FT_UShort) cpriv->standard_width;
        priv.standard_height[0] = (FT_UShort) cpriv->standard_height;

        count = priv.num_snap_widths = cpriv->num_snap_widths;
        for ( n = 0; n < count; n++ )
          priv.snap_widths[n] = (FT_Short) cpriv->snap_widths[n];

        count = priv.num_snap_heights = cpriv->num_snap_heights;
        for ( n = 0; n < count; n++ )
          priv.snap_heights[n] = (FT_Short) cpriv->snap_heights[n];

        priv.force_bold     = cpriv->force_bold;
        priv.language_group = cpriv->language_group;
        priv.lenIV          = cpriv->lenIV;
      }

      error = funcs->create( size->face->memory, &priv, &globals );
      if ( !error )
        size->internal = (FT_Size_Internal)(void*)globals;
    }

    return error;
  }


  FT_LOCAL_DEF FT_Error
  CFF_Size_Reset( CFF_Size  size )
  {
    PSH_Globals_Funcs  funcs = CFF_Size_Get_Globals_Funcs( size );
    FT_Error           error = 0;


    if ( funcs )
      error = funcs->set_scale( (PSH_Globals)size->internal,
                                 size->metrics.x_scale,
                                 size->metrics.y_scale,
                                 0, 0 );
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /*                            SLOT  FUNCTIONS                            */
  /*                                                                       */
  /*************************************************************************/

  FT_LOCAL_DEF void
  CFF_GlyphSlot_Done( CFF_GlyphSlot  slot )
  {
    slot->root.internal->glyph_hints = 0;
  }


  FT_LOCAL_DEF FT_Error
  CFF_GlyphSlot_Init( CFF_GlyphSlot  slot )
  {
    CFF_Face             face     = (CFF_Face)slot->root.face;
    CFF_Font*            font     = face->extra.data;
    PSHinter_Interface*  pshinter = font->pshinter;


    if ( pshinter )
    {
      FT_Module  module;


      module = FT_Get_Module( slot->root.face->driver->root.library,
                              "pshinter" );
      if ( module )
      {
        T2_Hints_Funcs  funcs;


        funcs = pshinter->get_t2_funcs( module );
        slot->root.internal->glyph_hints = (void*)funcs;
      }
    }

    return 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /*                           FACE  FUNCTIONS                             */
  /*                                                                       */
  /*************************************************************************/

  static FT_String*
  CFF_StrCopy( FT_Memory         memory,
               const FT_String*  source )
  {
    FT_Error    error;
    FT_String*  result = 0;
    FT_Int      len = (FT_Int)strlen( source );


    if ( !ALLOC( result, len + 1 ) )
    {
      MEM_Copy( result, source, len );
      result[len] = 0;
    }
    return result;
  }


#if 0

  /* this function is used to build a Unicode charmap from the glyph names */
  /* in a file                                                             */
  static FT_Error
  CFF_Build_Unicode_Charmap( CFF_Face            face,
                             FT_ULong            base_offset,
                             PSNames_Interface*  psnames )
  {
    CFF_Font*       font = (CFF_Font*)face->extra.data;
    FT_Memory       memory = FT_FACE_MEMORY(face);
    FT_UInt         n, num_glyphs = face->root.num_glyphs;
    const char**    glyph_names;
    FT_Error        error;
    CFF_Font_Dict*  dict = &font->top_font.font_dict;
    FT_ULong        charset_offset;
    FT_Byte         format;
    FT_Stream       stream = face->root.stream;


    charset_offset = dict->charset_offset;
    if ( !charset_offset )
    {
      FT_ERROR(( "CFF_Build_Unicode_Charmap: charset table is missing\n" ));
      error = CFF_Err_Invalid_File_Format;
      goto Exit;
    }

    /* allocate the charmap */
    if ( ALLOC( face->charmap, ...

    /* seek to charset table and allocate glyph names table */
    if ( FILE_Seek( base_offset + charset_offset )           ||
         ALLOC_ARRAY( glyph_names, num_glyphs, const char* ) )
      goto Exit;

    /* now, read each glyph name and store it in the glyph name table */
    if ( READ_Byte( format ) )
      goto Fail;

    switch ( format )
    {
    case 0:  /* format 0 - one SID per glyph */
      {
        const char**  gname = glyph_names;
        const char**  limit = gname + num_glyphs;


        if ( ACCESS_Frame( num_glyphs * 2 ) )
          goto Fail;

        for ( ; gname < limit; gname++ )
          gname[0] = CFF_Get_String( &font->string_index,
                                     GET_UShort(),
                                     psnames );
        FORGET_Frame();
        break;
      }

    case 1:  /* format 1 - sequential ranges                    */
    case 2:  /* format 2 - sequential ranges with 16-bit counts */
      {
        const char**  gname = glyph_names;
        const char**  limit = gname + num_glyphs;
        FT_UInt       len = 3;


        if ( format == 2 )
          len++;

        while ( gname < limit )
        {
          FT_UInt  first;
          FT_UInt  count;


          if ( ACCESS_Frame( len ) )
            goto Fail;

          first = GET_UShort();
          if ( format == 3 )
            count = GET_UShort();
          else
            count = GET_Byte();

          FORGET_Frame();

          for ( ; count > 0; count-- )
          {
            gname[0] = CFF_Get_String( &font->string_index,
                                       first,
                                       psnames );
            gname++;
            first++;
          }
        }
        break;
      }

    default:   /* unknown charset format! */
      FT_ERROR(( "CFF_Build_Unicode_Charmap: unknown charset format!\n" ));
      error = CFF_Err_Invalid_File_Format;
      goto Fail;
    }

    /* all right, the glyph names were loaded; we now need to create */
    /* the corresponding unicode charmap                             */

  Fail:
    for ( n = 0; n < num_glyphs; n++ )
      FREE( glyph_names[n] );

    FREE( glyph_names );

  Exit:
    return error;
  }

#endif /* 0 */


  static FT_Encoding
  find_encoding( int  platform_id,
                 int  encoding_id )
  {
    typedef struct  TEncoding
    {
      int          platform_id;
      int          encoding_id;
      FT_Encoding  encoding;

    } TEncoding;

    static
    const TEncoding  tt_encodings[] =
    {
      { TT_PLATFORM_ISO,           -1,                  ft_encoding_unicode },

      { TT_PLATFORM_APPLE_UNICODE, -1,                  ft_encoding_unicode },

      { TT_PLATFORM_MACINTOSH,     TT_MAC_ID_ROMAN,     ft_encoding_apple_roman },

      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UNICODE_CS, ft_encoding_unicode },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SJIS,       ft_encoding_sjis },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_GB2312,     ft_encoding_gb2312 },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_BIG_5,      ft_encoding_big5 },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_WANSUNG,    ft_encoding_wansung },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_JOHAB,      ft_encoding_johab }
    };

    const TEncoding  *cur, *limit;


    cur   = tt_encodings;
    limit = cur + sizeof ( tt_encodings ) / sizeof ( tt_encodings[0] );

    for ( ; cur < limit; cur++ )
    {
      if ( cur->platform_id == platform_id )
      {
        if ( cur->encoding_id == encoding_id ||
             cur->encoding_id == -1          )
          return cur->encoding;
      }
    }

    return ft_encoding_none;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    CFF_Face_Init                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initializes a given OpenType face object.                          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    stream     :: The source font stream.                              */
  /*                                                                       */
  /*    face_index :: The index of the font face in the resource.          */
  /*                                                                       */
  /*    num_params :: Number of additional generic parameters.  Ignored.   */
  /*                                                                       */
  /*    params     :: Additional generic parameters.  Ignored.             */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face       :: The newly built face object.                         */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  CFF_Face_Init( FT_Stream      stream,
                 CFF_Face       face,
                 FT_Int         face_index,
                 FT_Int         num_params,
                 FT_Parameter*  params )
  {
    FT_Error             error;
    SFNT_Interface*      sfnt;
    PSNames_Interface*   psnames;
    PSHinter_Interface*  pshinter;
    FT_Bool              pure_cff    = 1;
    FT_Bool              sfnt_format = 0;


    sfnt = (SFNT_Interface*)FT_Get_Module_Interface(
             face->root.driver->root.library, "sfnt" );
    if ( !sfnt )
      goto Bad_Format;

    psnames = (PSNames_Interface*)FT_Get_Module_Interface(
                face->root.driver->root.library, "psnames" );

    pshinter = (PSHinter_Interface*)FT_Get_Module_Interface(
                 face->root.driver->root.library, "pshinter" );

    /* create input stream from resource */
    if ( FILE_Seek( 0 ) )
      goto Exit;

    /* check that we have a valid OpenType file */
    error = sfnt->init_face( stream, face, face_index, num_params, params );
    if ( !error )
    {
      if ( face->format_tag != 0x4F54544FL )  /* `OTTO'; OpenType/CFF font */
      {
        FT_TRACE2(( "[not a valid OpenType/CFF font]\n" ));
        goto Bad_Format;
      }

      /* if we are performing a simple font format check, exit immediately */
      if ( face_index < 0 )
        return CFF_Err_Ok;

      sfnt_format = 1;

      /* now, the font can be either an OpenType/CFF font, or an SVG CEF */
      /* font in the later case; it doesn't have a `head' table          */
      error = face->goto_table( face, TTAG_head, stream, 0 );
      if ( !error )
      {
        pure_cff = 0;

        /* load font directory */
        error = sfnt->load_face( stream, face,
                                 face_index, num_params, params );
        if ( error )
          goto Exit;
      }
      else
      {
        /* load the `cmap' table by hand */
        error = sfnt->load_charmaps( face, stream );
        if ( error )
          goto Exit;

        /* XXX: we don't load the GPOS table, as OpenType Layout     */
        /* support will be added later to a layout library on top of */
        /* FreeType 2                                                */
      }

      /* now, load the CFF part of the file */
      error = face->goto_table( face, TTAG_CFF, stream, 0 );
      if ( error )
        goto Exit;
    }
    else
    {
      /* rewind to start of file; we are going to load a pure-CFF font */
      if ( FILE_Seek( 0 ) )
        goto Exit;
      error = CFF_Err_Ok;
    }

    /* now load and parse the CFF table in the file */
    {
      CFF_Font*  cff;
      FT_Memory  memory = face->root.memory;
      FT_Face    root;
      FT_UInt    flags;


      if ( ALLOC( cff, sizeof ( *cff ) ) )
        goto Exit;

      face->extra.data = cff;
      error = CFF_Load_Font( stream, face_index, cff );
      if ( error )
        goto Exit;

      cff->pshinter = pshinter;

      /* Complement the root flags with some interesting information. */
      /* Note that this is only necessary for pure CFF and CEF fonts. */

      root             = &face->root;
      root->num_glyphs = cff->num_glyphs;

      if ( pure_cff )
      {
        CFF_Font_Dict*  dict = &cff->top_font.font_dict;


        /* we need the `PSNames' module for pure-CFF and CEF formats */
        if ( !psnames )
        {
          FT_ERROR(( "CFF_Face_Init:" ));
          FT_ERROR(( " cannot open CFF & CEF fonts\n" ));
          FT_ERROR(( "             " ));
          FT_ERROR(( " without the `PSNames' module\n" ));
          goto Bad_Format;
        }

        /* Set up num_faces. */
        root->num_faces = cff->num_faces;

        /* compute number of glyphs */
        if ( dict->cid_registry )
          root->num_glyphs = dict->cid_count;
        else
          root->num_glyphs = cff->charstrings_index.count;

        /* set global bbox, as well as EM size */
        root->bbox      = dict->font_bbox;
        root->ascender  = (FT_Short)( root->bbox.yMax >> 16 );
        root->descender = (FT_Short)( root->bbox.yMin >> 16 );
        root->height    = (FT_Short)(
          ( ( root->ascender - root->descender ) * 12 ) / 10 );

        if ( dict->units_per_em )
          root->units_per_EM = dict->units_per_em;
        else
          root->units_per_EM = 1000;

        /* retrieve font family & style name */
        root->family_name  = CFF_Get_Name( &cff->name_index, face_index );
        if ( dict->cid_registry )
          root->style_name = CFF_StrCopy( memory, "Regular" );  /* XXXX */
        else
          root->style_name = CFF_Get_String( &cff->string_index,
                                             dict->weight,
                                             psnames );

        /*******************************************************************/
        /*                                                                 */
        /* Compute face flags.                                             */
        /*                                                                 */
        flags = FT_FACE_FLAG_SCALABLE  |    /* scalable outlines */
                FT_FACE_FLAG_HORIZONTAL;    /* horizontal data   */

        if ( sfnt_format )
          flags |= FT_FACE_FLAG_SFNT;

        /* fixed width font? */
        if ( dict->is_fixed_pitch )
          flags |= FT_FACE_FLAG_FIXED_WIDTH;

  /* XXX: WE DO NOT SUPPORT KERNING METRICS IN THE GPOS TABLE FOR NOW */
#if 0
        /* kerning available? */
        if ( face->kern_pairs )
          flags |= FT_FACE_FLAG_KERNING;
#endif

#ifndef FT_CONFIG_OPTION_NO_GLYPH_NAMES
        flags |= FT_FACE_FLAG_GLYPH_NAMES;
#endif

        root->face_flags = flags;

        /*******************************************************************/
        /*                                                                 */
        /* Compute style flags.                                            */
        /*                                                                 */
        flags = 0;

        if ( dict->italic_angle )
          flags |= FT_STYLE_FLAG_ITALIC;

        /* XXX: may not be correct */
        if ( cff->top_font.private_dict.force_bold )
          flags |= FT_STYLE_FLAG_BOLD;

        root->style_flags = flags;

        /* set the charmaps if any */
        if ( sfnt_format )
        {
          /*****************************************************************/
          /*                                                               */
          /* Polish the charmaps.                                          */
          /*                                                               */
          /*   Try to set the charmap encoding according to the platform & */
          /*   encoding ID of each charmap.                                */
          /*                                                               */
          TT_CharMap  charmap;
          FT_Int      n;


          charmap            = face->charmaps;
          root->num_charmaps = face->num_charmaps;

          /* allocate table of pointers */
          if ( ALLOC_ARRAY( root->charmaps, root->num_charmaps, FT_CharMap ) )
            goto Exit;

          for ( n = 0; n < root->num_charmaps; n++, charmap++ )
          {
            FT_Int  platform = charmap->cmap.platformID;
            FT_Int  encoding = charmap->cmap.platformEncodingID;


            charmap->root.face        = (FT_Face)face;
            charmap->root.platform_id = (FT_UShort)platform;
            charmap->root.encoding_id = (FT_UShort)encoding;
            charmap->root.encoding    = find_encoding( platform, encoding );

            /* now, set root->charmap with a unicode charmap */
            /* wherever available                            */
            if ( !root->charmap                                &&
                 charmap->root.encoding == ft_encoding_unicode )
              root->charmap = (FT_CharMap)charmap;

            root->charmaps[n] = (FT_CharMap)charmap;
          }
        }
      }
    }

  Exit:
    return error;

  Bad_Format:
    error = CFF_Err_Unknown_File_Format;
    goto Exit;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    CFF_Face_Done                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Finalizes a given face object.                                     */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A pointer to the face object to destroy.                   */
  /*                                                                       */
  FT_LOCAL_DEF void
  CFF_Face_Done( CFF_Face  face )
  {
    FT_Memory        memory = face->root.memory;
    SFNT_Interface*  sfnt   = (SFNT_Interface*)face->sfnt;


    if ( sfnt )
      sfnt->done_face( face );

    {
      CFF_Font*  cff = (CFF_Font*)face->extra.data;


      if ( cff )
      {
        CFF_Done_Font( cff );
        FREE( face->extra.data );
      }
    }
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    CFF_Driver_Init                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Initializes a given OpenType driver object.                        */
  /*                                                                       */
  /* <Input>                                                               */
  /*    driver :: A handle to the target driver object.                    */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  CFF_Driver_Init( CFF_Driver  driver )
  {
    /* init extension registry if needed */

#ifdef TT_CONFIG_OPTION_EXTEND_ENGINE

    return TT_Init_Extensions( driver );

#else

    FT_UNUSED( driver );

    return CFF_Err_Ok;

#endif
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    CFF_Driver_Done                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Finalizes a given OpenType driver.                                 */
  /*                                                                       */
  /* <Input>                                                               */
  /*    driver :: A handle to the target OpenType driver.                  */
  /*                                                                       */
  FT_LOCAL_DEF void
  CFF_Driver_Done( CFF_Driver  driver )
  {
    /* destroy extensions registry if needed */

#ifdef TT_CONFIG_OPTION_EXTEND_ENGINE

    TT_Done_Extensions( driver );

#else

    FT_UNUSED( driver );

#endif
  }


/* END */
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002 by                                           */
d31 1
a31 1
#include "cffcmap.h"
d34 2
d47 2
d60 1
a60 1
  cff_size_get_globals_funcs( CFF_Size  size )
d62 4
a65 4
    CFF_Face          face     = (CFF_Face)size->face;
    CFF_Font          font     = (CFF_FontRec *)face->extra.data;
    PSHinter_Service  pshinter = (PSHinter_Service)font->pshinter;
    FT_Module         module;
d76 2
a77 2
  FT_LOCAL_DEF( void )
  cff_size_done( CFF_Size  size )
d84 1
a84 1
      funcs = cff_size_get_globals_funcs( size );
d93 2
a94 2
  FT_LOCAL_DEF( FT_Error )
  cff_size_init( CFF_Size  size )
d97 1
a97 1
    PSH_Globals_Funcs  funcs = cff_size_get_globals_funcs( size );
d102 4
a105 4
      PSH_Globals    globals;
      CFF_Face       face    = (CFF_Face)size->face;
      CFF_Font       font    = (CFF_FontRec *)face->extra.data;
      CFF_SubFont    subfont = &font->top_font;
d107 2
a108 2
      CFF_Private    cpriv   = &subfont->private_dict;
      PS_PrivateRec  priv;
d119 1
a119 1
        FT_MEM_ZERO( &priv, sizeof ( priv ) );
d123 1
a123 1
          priv.blue_values[n] = (FT_Short)cpriv->blue_values[n];
d127 1
a127 1
          priv.other_blues[n] = (FT_Short)cpriv->other_blues[n];
d131 1
a131 1
          priv.family_blues[n] = (FT_Short)cpriv->family_blues[n];
d135 1
a135 1
          priv.family_other_blues[n] = (FT_Short)cpriv->family_other_blues[n];
d138 2
a139 2
        priv.blue_shift = (FT_Int)cpriv->blue_shift;
        priv.blue_fuzz  = (FT_Int)cpriv->blue_fuzz;
d141 2
a142 2
        priv.standard_width[0]  = (FT_UShort)cpriv->standard_width;
        priv.standard_height[0] = (FT_UShort)cpriv->standard_height;
d146 1
a146 1
          priv.snap_widths[n] = (FT_Short)cpriv->snap_widths[n];
d150 1
a150 1
          priv.snap_heights[n] = (FT_Short)cpriv->snap_heights[n];
d166 2
a167 2
  FT_LOCAL_DEF( FT_Error )
  cff_size_reset( CFF_Size  size )
d169 1
a169 1
    PSH_Globals_Funcs  funcs = cff_size_get_globals_funcs( size );
d188 2
a189 2
  FT_LOCAL_DEF( void )
  cff_slot_done( CFF_GlyphSlot  slot )
d195 2
a196 2
  FT_LOCAL_DEF( FT_Error )
  cff_slot_init( CFF_GlyphSlot  slot )
d198 3
a200 3
    CFF_Face          face     = (CFF_Face)slot->root.face;
    CFF_Font          font     = (CFF_FontRec *)face->extra.data;
    PSHinter_Service  pshinter = (PSHinter_Service)font->pshinter;
d231 2
a232 2
  cff_strcpy( FT_Memory         memory,
              const FT_String*  source )
d236 1
a236 1
    FT_Int      len = (FT_Int)ft_strlen( source );
d239 1
a239 1
    if ( !FT_ALLOC( result, len + 1 ) )
d241 1
a241 1
      FT_MEM_COPY( result, source, len );
d244 78
a322 1
    FT_UNUSED( error );
d324 40
a363 1
    return result;
d366 47
d414 2
d418 25
a442 2
  FT_LOCAL_DEF( FT_Error )
  cff_face_init( FT_Stream      stream,
d448 6
a453 6
    FT_Error          error;
    SFNT_Service      sfnt;
    PSNames_Service   psnames;
    PSHinter_Service  pshinter;
    FT_Bool           pure_cff    = 1;
    FT_Bool           sfnt_format = 0;
d456 1
a456 1
    sfnt = (SFNT_Service)FT_Get_Module_Interface(
d461 1
a461 1
    psnames = (PSNames_Service)FT_Get_Module_Interface(
d464 1
a464 1
    pshinter = (PSHinter_Service)FT_Get_Module_Interface(
d468 1
a468 1
    if ( FT_STREAM_SEEK( 0 ) )
d520 1
a520 1
      if ( FT_STREAM_SEEK( 0 ) )
d527 1
a527 1
      CFF_Font   cff;
d530 1
a530 1
      FT_Int32   flags;
d533 1
a533 1
      if ( FT_NEW( cff ) )
d537 1
a537 1
      error = cff_font_load( stream, face_index, cff );
a541 1
      cff->psnames  = psnames;
d551 1
a551 1
        CFF_FontRecDict  dict = &cff->top_font.font_dict;
d557 1
a557 1
          FT_ERROR(( "cff_face_init:" ));
d559 1
a559 1
          FT_ERROR(( "              " ));
d574 3
a576 8
        root->bbox.xMin =   dict->font_bbox.xMin             >> 16;
        root->bbox.yMin =   dict->font_bbox.yMin             >> 16;
        root->bbox.xMax = ( dict->font_bbox.xMax + 0xFFFFU ) >> 16;
        root->bbox.yMax = ( dict->font_bbox.yMax + 0xFFFFU ) >> 16;


        root->ascender  = (FT_Short)( root->bbox.yMax );
        root->descender = (FT_Short)( root->bbox.yMin );
d586 1
a586 1
        root->family_name  = cff_index_get_name( &cff->name_index, face_index );
d588 1
a588 1
          root->style_name = cff_strcpy( memory, "Regular" );  /* XXXX */
d590 3
a592 3
          root->style_name = cff_index_get_sid_string( &cff->string_index,
                                                       dict->weight,
                                                       psnames );
a634 1
      }
d636 2
a637 16
      /*******************************************************************/
      /*                                                                 */
      /* Compute char maps.                                              */
      /*                                                                 */

      /* Try to synthetize a Unicode charmap if there is none available */
      /* already.  If an OpenType font contains a Unicode "cmap", we    */
      /* will use it, whatever be in the CFF part of the file.          */
      {
        FT_CharMapRec  cmaprec;
        FT_CharMap     cmap;
        FT_UInt        nn;
        CFF_Encoding   encoding = &cff->encoding;


        for ( nn = 0; nn < (FT_UInt) root->num_charmaps; nn++ )
d639 17
a655 1
          cmap = root->charmaps[nn];
d657 4
a660 8
          /* Windows Unicode (3,1)? */
          if ( cmap->platform_id == 3 && cmap->encoding_id == 1 )
            goto Skip_Unicode;

          /* Deprecated Unicode platform id? */
          if ( cmap->platform_id == 0 )
            goto Skip_Unicode; /* Standard Unicode (deprecated) */
        }
a661 18
        /* we didn't find a Unicode charmap, synthetize one */
        cmaprec.face        = root;
        cmaprec.platform_id = 3;
        cmaprec.encoding_id = 1;
        cmaprec.encoding    = FT_ENCODING_UNICODE;

        nn = (FT_UInt) root->num_charmaps;

        FT_CMap_New( &cff_cmap_unicode_class_rec, NULL, &cmaprec, NULL );

        /* if no Unicode charmap was previously selected, select this one */
        if ( root->charmap == NULL && nn != (FT_UInt) root->num_charmaps )
          root->charmap = root->charmaps[nn];

      Skip_Unicode:
        if ( encoding->count > 0 )
        {
          FT_CMap_Class  clazz;
d663 10
d674 1
a674 8
          cmaprec.face        = root;
          cmaprec.platform_id = 7;  /* Adobe platform id */

          if ( encoding->offset == 0 )
          {
            cmaprec.encoding_id = 0;
            cmaprec.encoding    = FT_ENCODING_ADOBE_STANDARD;
            clazz               = &cff_cmap_encoding_class_rec;
a675 14
          else if ( encoding->offset == 1 )
          {
            cmaprec.encoding_id = 1;
            cmaprec.encoding    = FT_ENCODING_ADOBE_EXPERT;
            clazz               = &cff_cmap_encoding_class_rec;
          }
          else
          {
            cmaprec.encoding_id = 3;
            cmaprec.encoding    = FT_ENCODING_ADOBE_CUSTOM;
            clazz               = &cff_cmap_encoding_class_rec;
          }

          FT_CMap_New( clazz, NULL, &cmaprec, NULL );
a676 1

d689 13
a701 2
  FT_LOCAL_DEF( void )
  cff_face_done( CFF_Face  face )
d703 2
a704 2
    FT_Memory     memory = face->root.memory;
    SFNT_Service  sfnt   = (SFNT_Service)face->sfnt;
d711 1
a711 1
      CFF_Font  cff = (CFF_Font)face->extra.data;
d716 2
a717 2
        cff_font_done( cff );
        FT_FREE( face->extra.data );
d723 16
a738 2
  FT_LOCAL_DEF( FT_Error )
  cff_driver_init( CFF_Driver  driver )
d740 8
d751 2
d756 13
a768 2
  FT_LOCAL_DEF( void )
  cff_driver_done( CFF_Driver  driver )
d770 8
d779 2
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002 by                                           */
d34 2
d47 2
d62 4
a65 4
    CFF_Face          face     = (CFF_Face)size->face;
    CFF_Font          font     = (CFF_FontRec *)face->extra.data;
    PSHinter_Service  pshinter = (PSHinter_Service)font->pshinter;
    FT_Module         module;
d76 1
a76 1
  FT_LOCAL_DEF( void )
d93 1
a93 1
  FT_LOCAL_DEF( FT_Error )
d102 4
a105 4
      PSH_Globals    globals;
      CFF_Face       face    = (CFF_Face)size->face;
      CFF_Font       font    = (CFF_FontRec *)face->extra.data;
      CFF_SubFont    subfont = &font->top_font;
d107 2
a108 2
      CFF_Private    cpriv   = &subfont->private_dict;
      PS_PrivateRec  priv;
d119 1
a119 1
        FT_MEM_SET( &priv, 0, sizeof ( priv ) );
d123 1
a123 1
          priv.blue_values[n] = (FT_Short)cpriv->blue_values[n];
d127 1
a127 1
          priv.other_blues[n] = (FT_Short)cpriv->other_blues[n];
d131 1
a131 1
          priv.family_blues[n] = (FT_Short)cpriv->family_blues[n];
d135 1
a135 1
          priv.family_other_blues[n] = (FT_Short)cpriv->family_other_blues[n];
d141 2
a142 2
        priv.standard_width[0]  = (FT_UShort)cpriv->standard_width;
        priv.standard_height[0] = (FT_UShort)cpriv->standard_height;
d146 1
a146 1
          priv.snap_widths[n] = (FT_Short)cpriv->snap_widths[n];
d150 1
a150 1
          priv.snap_heights[n] = (FT_Short)cpriv->snap_heights[n];
d166 1
a166 1
  FT_LOCAL_DEF( FT_Error )
d188 1
a188 1
  FT_LOCAL_DEF( void )
d195 1
a195 1
  FT_LOCAL_DEF( FT_Error )
d198 3
a200 3
    CFF_Face          face     = (CFF_Face)slot->root.face;
    CFF_Font          font     = (CFF_FontRec *)face->extra.data;
    PSHinter_Service  pshinter = (PSHinter_Service)font->pshinter;
d236 1
a236 1
    FT_Int      len = (FT_Int)ft_strlen( source );
d239 1
a239 1
    if ( !FT_ALLOC( result, len + 1 ) )
d241 1
a241 1
      FT_MEM_COPY( result, source, len );
d244 108
d353 2
a354 1
    FT_UNUSED( error );
d356 8
a363 1
    return result;
d366 33
d401 41
a441 1
  FT_LOCAL_DEF( FT_Error )
d448 6
a453 6
    FT_Error          error;
    SFNT_Service      sfnt;
    PSNames_Service   psnames;
    PSHinter_Service  pshinter;
    FT_Bool           pure_cff    = 1;
    FT_Bool           sfnt_format = 0;
d456 1
a456 1
    sfnt = (SFNT_Service)FT_Get_Module_Interface(
d461 1
a461 1
    psnames = (PSNames_Service)FT_Get_Module_Interface(
d464 1
a464 1
    pshinter = (PSHinter_Service)FT_Get_Module_Interface(
d468 1
a468 1
    if ( FT_STREAM_SEEK( 0 ) )
d520 1
a520 1
      if ( FT_STREAM_SEEK( 0 ) )
d527 1
a527 1
      CFF_Font   cff;
d533 1
a533 1
      if ( FT_NEW( cff ) )
d551 1
a551 1
        CFF_FontRecDict  dict = &cff->top_font.font_dict;
d559 1
a559 1
          FT_ERROR(( "              " ));
d574 3
a576 8
        root->bbox.xMin =   dict->font_bbox.xMin             >> 16;
        root->bbox.yMin =   dict->font_bbox.yMin             >> 16;
        root->bbox.xMax = ( dict->font_bbox.xMax + 0xFFFFU ) >> 16;
        root->bbox.yMax = ( dict->font_bbox.yMax + 0xFFFFU ) >> 16;


        root->ascender  = (FT_Short)( root->bbox.yMax );
        root->descender = (FT_Short)( root->bbox.yMin );
d635 42
a676 2
        
        /* XXX: no charmaps for pure CFF fonts currently! */
d689 12
a700 1
  FT_LOCAL_DEF( void )
d703 2
a704 2
    FT_Memory     memory = face->root.memory;
    SFNT_Service  sfnt   = (SFNT_Service)face->sfnt;
d711 1
a711 1
      CFF_Font  cff = (CFF_Font)face->extra.data;
d717 1
a717 1
        FT_FREE( face->extra.data );
d723 15
a737 1
  FT_LOCAL_DEF( FT_Error )
d740 8
d751 2
d756 12
a767 1
  FT_LOCAL_DEF( void )
d770 8
d779 2
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d31 1
a31 1
#include "cffcmap.h"
d56 1
a56 1
  cff_size_get_globals_funcs( CFF_Size  size )
d73 1
a73 1
  cff_size_done( CFF_Size  size )
d80 1
a80 1
      funcs = cff_size_get_globals_funcs( size );
d90 1
a90 1
  cff_size_init( CFF_Size  size )
d93 1
a93 1
    PSH_Globals_Funcs  funcs = cff_size_get_globals_funcs( size );
d115 1
a115 1
        FT_MEM_ZERO( &priv, sizeof ( priv ) );
d134 2
a135 2
        priv.blue_shift = (FT_Int)cpriv->blue_shift;
        priv.blue_fuzz  = (FT_Int)cpriv->blue_fuzz;
d163 1
a163 1
  cff_size_reset( CFF_Size  size )
d165 1
a165 1
    PSH_Globals_Funcs  funcs = cff_size_get_globals_funcs( size );
d185 1
a185 1
  cff_slot_done( CFF_GlyphSlot  slot )
d192 1
a192 1
  cff_slot_init( CFF_GlyphSlot  slot )
d227 2
a228 2
  cff_strcpy( FT_Memory         memory,
              const FT_String*  source )
a247 1

d249 1
a249 1
  cff_face_init( FT_Stream      stream,
d337 1
a337 1
      FT_Int32   flags;
d344 1
a344 1
      error = cff_font_load( stream, face_index, cff );
a348 1
      cff->psnames  = psnames;
d364 1
a364 1
          FT_ERROR(( "cff_face_init:" ));
d398 1
a398 1
        root->family_name  = cff_index_get_name( &cff->name_index, face_index );
d400 1
a400 1
          root->style_name = cff_strcpy( memory, "Regular" );  /* XXXX */
d402 3
a404 3
          root->style_name = cff_index_get_sid_string( &cff->string_index,
                                                       dict->weight,
                                                       psnames );
d447 2
a448 75
      }

      /*******************************************************************/
      /*                                                                 */
      /* Compute char maps.                                              */
      /*                                                                 */

      /* Try to synthetize a Unicode charmap if there is none available */
      /* already.  If an OpenType font contains a Unicode "cmap", we    */
      /* will use it, whatever be in the CFF part of the file.          */
      {
        FT_CharMapRec  cmaprec;
        FT_CharMap     cmap;
        FT_UInt        nn;
        CFF_Encoding   encoding = &cff->encoding;


        for ( nn = 0; nn < (FT_UInt) root->num_charmaps; nn++ )
        {
          cmap = root->charmaps[nn];

          /* Windows Unicode (3,1)? */
          if ( cmap->platform_id == 3 && cmap->encoding_id == 1 )
            goto Skip_Unicode;

          /* Deprecated Unicode platform id? */
          if ( cmap->platform_id == 0 )
            goto Skip_Unicode; /* Standard Unicode (deprecated) */
        }

        /* we didn't find a Unicode charmap, synthetize one */
        cmaprec.face        = root;
        cmaprec.platform_id = 3;
        cmaprec.encoding_id = 1;
        cmaprec.encoding    = FT_ENCODING_UNICODE;

        nn = (FT_UInt) root->num_charmaps;

        FT_CMap_New( &cff_cmap_unicode_class_rec, NULL, &cmaprec, NULL );

        /* if no Unicode charmap was previously selected, select this one */
        if ( root->charmap == NULL && nn != (FT_UInt) root->num_charmaps )
          root->charmap = root->charmaps[nn];

      Skip_Unicode:
        if ( encoding->count > 0 )
        {
          FT_CMap_Class  clazz;


          cmaprec.face        = root;
          cmaprec.platform_id = 7;  /* Adobe platform id */

          if ( encoding->offset == 0 )
          {
            cmaprec.encoding_id = 0;
            cmaprec.encoding    = FT_ENCODING_ADOBE_STANDARD;
            clazz               = &cff_cmap_encoding_class_rec;
          }
          else if ( encoding->offset == 1 )
          {
            cmaprec.encoding_id = 1;
            cmaprec.encoding    = FT_ENCODING_ADOBE_EXPERT;
            clazz               = &cff_cmap_encoding_class_rec;
          }
          else
          {
            cmaprec.encoding_id = 3;
            cmaprec.encoding    = FT_ENCODING_ADOBE_CUSTOM;
            clazz               = &cff_cmap_encoding_class_rec;
          }

          FT_CMap_New( clazz, NULL, &cmaprec, NULL );
        }

d462 1
a462 1
  cff_face_done( CFF_Face  face )
d477 1
a477 1
        cff_font_done( cff );
d485 1
a485 1
  cff_driver_init( CFF_Driver  driver )
d494 1
a494 1
  cff_driver_done( CFF_Driver  driver )
@


