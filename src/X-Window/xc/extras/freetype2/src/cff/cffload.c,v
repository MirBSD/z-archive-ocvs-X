head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.29.47;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.01.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.01.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.21.01;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.38.27;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.08.59;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@/***************************************************************************/
/*                                                                         */
/*  cffload.c                                                              */
/*                                                                         */
/*    OpenType and CFF data/program tables loader (body).                  */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_OBJECTS_H
#include FT_INTERNAL_STREAM_H
#include FT_INTERNAL_POSTSCRIPT_NAMES_H
#include FT_TRUETYPE_TAGS_H

#include "cffload.h"
#include "cffparse.h"

#include "cfferrs.h"


#if 1
  static const FT_UShort  cff_isoadobe_charset[229] =
  {
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131,
    132,
    133,
    134,
    135,
    136,
    137,
    138,
    139,
    140,
    141,
    142,
    143,
    144,
    145,
    146,
    147,
    148,
    149,
    150,
    151,
    152,
    153,
    154,
    155,
    156,
    157,
    158,
    159,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228
  };

  static const FT_UShort  cff_expert_charset[166] =
  {
    0,
    1,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    13,
    14,
    15,
    99,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    27,
    28,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    109,
    110,
    267,
    268,
    269,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    304,
    305,
    306,
    307,
    308,
    309,
    310,
    311,
    312,
    313,
    314,
    315,
    316,
    317,
    318,
    158,
    155,
    163,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    150,
    164,
    169,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378
  };

  static const FT_UShort  cff_expertsubset_charset[87] =
  {
    0,
    1,
    231,
    232,
    235,
    236,
    237,
    238,
    13,
    14,
    15,
    99,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    27,
    28,
    249,
    250,
    251,
    253,
    254,
    255,
    256,
    257,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    109,
    110,
    267,
    268,
    269,
    270,
    272,
    300,
    301,
    302,
    305,
    314,
    315,
    158,
    155,
    163,
    320,
    321,
    322,
    323,
    324,
    325,
    326,
    150,
    164,
    169,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346
  };

  static const FT_UShort  cff_standard_encoding[256] =
  {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    0,
    111,
    112,
    113,
    114,
    0,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    0,
    123,
    0,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131,
    0,
    132,
    133,
    0,
    134,
    135,
    136,
    137,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    138,
    0,
    139,
    0,
    0,
    0,
    0,
    140,
    141,
    142,
    143,
    0,
    0,
    0,
    0,
    0,
    144,
    0,
    0,
    0,
    145,
    0,
    0,
    146,
    147,
    148,
    149,
    0,
    0,
    0,
    0
  };

  static const FT_UShort  cff_expert_encoding[256] =
  {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    229,
    230,
    0,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    13,
    14,
    15,
    99,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    27,
    28,
    249,
    250,
    251,
    252,
    0,
    253,
    254,
    255,
    256,
    257,
    0,
    0,
    0,
    258,
    0,
    0,
    259,
    260,
    261,
    262,
    0,
    0,
    263,
    264,
    265,
    0,
    266,
    109,
    110,
    267,
    268,
    269,
    0,
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281,
    282,
    283,
    284,
    285,
    286,
    287,
    288,
    289,
    290,
    291,
    292,
    293,
    294,
    295,
    296,
    297,
    298,
    299,
    300,
    301,
    302,
    303,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    304,
    305,
    306,
    0,
    0,
    307,
    308,
    309,
    310,
    311,
    0,
    312,
    0,
    0,
    312,
    0,
    0,
    314,
    315,
    0,
    0,
    316,
    317,
    318,
    0,
    0,
    0,
    158,
    155,
    163,
    319,
    320,
    321,
    322,
    323,
    324,
    325,
    0,
    0,
    326,
    150,
    164,
    169,
    327,
    328,
    329,
    330,
    331,
    332,
    333,
    334,
    335,
    336,
    337,
    338,
    339,
    340,
    341,
    342,
    343,
    344,
    345,
    346,
    347,
    348,
    349,
    350,
    351,
    352,
    353,
    354,
    355,
    356,
    357,
    358,
    359,
    360,
    361,
    362,
    363,
    364,
    365,
    366,
    367,
    368,
    369,
    370,
    371,
    372,
    373,
    374,
    375,
    376,
    377,
    378
  };
#endif


  FT_LOCAL_DEF FT_UShort
  CFF_Get_Standard_Encoding( FT_UInt  charcode )
  {
    return  (FT_UShort)(charcode < 256 ? cff_standard_encoding[charcode] : 0);
  }


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_cffload


  /* read a CFF offset from memory */
  static FT_ULong
  cff_get_offset( FT_Byte*  p,
                  FT_Byte   off_size )
  {
    FT_ULong  result;


    for ( result = 0; off_size > 0; off_size-- )
    {
      result <<= 8;
      result  |= *p++;
    }

    return result;
  }


  static FT_Error
  cff_new_index( CFF_Index*  index,
                 FT_Stream   stream,
                 FT_Bool     load )
  {
    FT_Error   error;
    FT_Memory  memory = stream->memory;
    FT_UShort  count;


    MEM_Set( index, 0, sizeof ( *index ) );

    index->stream = stream;
    if ( !READ_UShort( count ) &&
         count > 0             )
    {
      FT_Byte*   p;
      FT_Byte    offsize;
      FT_ULong   data_size;
      FT_ULong*  poff;


      /* there is at least one element; read the offset size,           */
      /* then access the offset table to compute the index's total size */
      if ( READ_Byte( offsize ) )
        goto Exit;

      index->stream   = stream;
      index->count    = count;
      index->off_size = offsize;
      data_size       = (FT_ULong)( count + 1 ) * offsize;

      if ( ALLOC_ARRAY( index->offsets, count + 1, FT_ULong ) ||
           ACCESS_Frame( data_size )                          )
        goto Exit;

      poff = index->offsets;
      p    = (FT_Byte*)stream->cursor;

      for ( ; (FT_Short)count >= 0; count-- )
      {
        poff[0] = cff_get_offset( p, offsize );
        poff++;
        p += offsize;
      }

      FORGET_Frame();

      index->data_offset = FILE_Pos();
      data_size          = poff[-1] - 1;

      if ( load )
      {
        /* load the data */
        if ( EXTRACT_Frame( data_size, index->bytes ) )
          goto Exit;
      }
      else
      {
        /* skip the data */
        if ( FILE_Skip( data_size ) )
          goto Exit;
      }
    }

  Exit:
    if ( error )
      FREE( index->offsets );

    return error;
  }


  static void
  cff_done_index( CFF_Index*  index )
  {
    if ( index->stream )
    {
      FT_Stream  stream = index->stream;
      FT_Memory  memory = stream->memory;


      if ( index->bytes )
        RELEASE_Frame( index->bytes );

      FREE( index->offsets );
      MEM_Set( index, 0, sizeof ( *index ) );
    }
  }


  static FT_Error
  cff_explicit_index( CFF_Index*  index,
                      FT_Byte***  table )
  {
    FT_Error   error  = 0;
    FT_Memory  memory = index->stream->memory;
    FT_UInt    n, offset, old_offset;
    FT_Byte**  t;


    *table = 0;

    if ( index->count > 0 && !ALLOC_ARRAY( t, index->count + 1, FT_Byte* ) )
    {
      old_offset = 1;
      for ( n = 0; n <= index->count; n++ )
      {
        offset = index->offsets[n];
        if ( !offset )
          offset = old_offset;

        t[n] = index->bytes + offset - 1;

        old_offset = offset;
      }
      *table = t;
    }

    return error;
  }


  FT_LOCAL_DEF FT_Error
  CFF_Access_Element( CFF_Index*  index,
                      FT_UInt     element,
                      FT_Byte**   pbytes,
                      FT_ULong*   pbyte_len )
  {
    FT_Error  error = 0;


    if ( index && index->count > element )
    {
      /* compute start and end offsets */
      FT_ULong  off1, off2 = 0;


      off1 = index->offsets[element];
      if ( off1 )
      {
        do
        {
          element++;
          off2 = index->offsets[element];

        } while ( off2 == 0 && element < index->count );

        if ( !off2 )
          off1 = 0;
      }

      /* access element */
      if ( off1 )
      {
        *pbyte_len = off2 - off1;

        if ( index->bytes )
        {
          /* this index was completely loaded in memory, that's easy */
          *pbytes = index->bytes + off1 - 1;
        }
        else
        {
          /* this index is still on disk/file, access it through a frame */
          FT_Stream  stream = index->stream;


          if ( FILE_Seek( index->data_offset + off1 - 1 ) ||
               EXTRACT_Frame( off2 - off1, *pbytes )      )
            goto Exit;
        }
      }
      else
      {
        /* empty index element */
        *pbytes    = 0;
        *pbyte_len = 0;
      }
    }
    else
      error = CFF_Err_Invalid_Argument;

  Exit:
    return error;
  }


  FT_LOCAL_DEF void
  CFF_Forget_Element( CFF_Index*  index,
                      FT_Byte**   pbytes )
  {
    if ( index->bytes == 0 )
    {
      FT_Stream  stream = index->stream;


      RELEASE_Frame( *pbytes );
    }
  }


  FT_LOCAL_DEF FT_String*
  CFF_Get_Name( CFF_Index*  index,
                FT_UInt     element )
  {
    FT_Memory   memory = index->stream->memory;
    FT_Byte*    bytes;
    FT_ULong    byte_len;
    FT_Error    error;
    FT_String*  name = 0;


    error = CFF_Access_Element( index, element, &bytes, &byte_len );
    if ( error )
      goto Exit;

    if ( !ALLOC( name, byte_len + 1 ) )
    {
      MEM_Copy( name, bytes, byte_len );
      name[byte_len] = 0;
    }
    CFF_Forget_Element( index, &bytes );

  Exit:
    return name;
  }


  FT_LOCAL_DEF FT_String*
  CFF_Get_String( CFF_Index*          index,
                  FT_UInt             sid,
                  PSNames_Interface*  interface )
  {
    /* if it is not a standard string, return it */
    if ( sid > 390 )
      return CFF_Get_Name( index, sid - 391 );

    /* that's a standard string, fetch a copy from the PSName module */
    {
      FT_String*   name       = 0;
      const char*  adobe_name = interface->adobe_std_strings( sid );
      FT_UInt      len;


      if ( adobe_name )
      {
        FT_Memory memory = index->stream->memory;
        FT_Error  error;


        len = (FT_UInt)strlen( adobe_name );
        if ( !ALLOC( name, len + 1 ) )
        {
          MEM_Copy( name, adobe_name, len );
          name[len] = 0;
        }
      }

      return name;
    }
  }


  /*************************************************************************/
  /*************************************************************************/
  /***                                                                   ***/
  /***   FD Select table support                                         ***/
  /***                                                                   ***/
  /*************************************************************************/
  /*************************************************************************/


  static void
  CFF_Done_FD_Select( CFF_FD_Select*  select,
                      FT_Stream       stream )
  {
    if ( select->data )
      RELEASE_Frame( select->data );

    select->data_size   = 0;
    select->format      = 0;
    select->range_count = 0;
  }


  static FT_Error
  CFF_Load_FD_Select( CFF_FD_Select*  select,
                      FT_UInt         num_glyphs,
                      FT_Stream       stream,
                      FT_ULong        offset )
  {
    FT_Error  error;
    FT_Byte   format;
    FT_UInt   num_ranges;


    /* read format */
    if ( FILE_Seek( offset ) || READ_Byte( format ) )
      goto Exit;

    select->format      = format;
    select->cache_count = 0;   /* clear cache */

    switch ( format )
    {
    case 0:     /* format 0, that's simple */
      select->data_size = num_glyphs;
      goto Load_Data;

    case 3:     /* format 3, a tad more complex */
      if ( READ_UShort( num_ranges ) )
        goto Exit;

      select->data_size = num_ranges * 3 + 2;

    Load_Data:
      if ( EXTRACT_Frame( select->data_size, select->data ) )
        goto Exit;
      break;

    default:    /* hmm... that's wrong */
      error = CFF_Err_Invalid_File_Format;
    }

  Exit:
    return error;
  }


  FT_LOCAL_DEF FT_Byte
  CFF_Get_FD( CFF_FD_Select*  select,
              FT_UInt         glyph_index )
  {
    FT_Byte  fd = 0;


    switch ( select->format )
    {
    case 0:
      fd = select->data[glyph_index];
      break;

    case 3:
      /* first, compare to cache */
      if ( (FT_UInt)(glyph_index-select->cache_first) < select->cache_count )
      {
        fd = select->cache_fd;
        break;
      }

      /* then, lookup the ranges array */
      {
        FT_Byte*  p       = select->data;
        FT_Byte*  p_limit = p + select->data_size;
        FT_Byte   fd2;
        FT_UInt   first, limit;


        first = NEXT_UShort( p );
        do
        {
          if ( glyph_index < first )
            break;

          fd2   = *p++;
          limit = NEXT_UShort( p );

          if ( glyph_index < limit )
          {
            fd = fd2;

            /* update cache */
            select->cache_first = first;
            select->cache_count = limit-first;
            select->cache_fd    = fd2;
            break;
          }
          first = limit;

        } while ( p < p_limit );
      }
      break;

    default:
      ;
    }

    return fd;
  }


  /*************************************************************************/
  /*************************************************************************/
  /***                                                                   ***/
  /***   CFF font support                                                ***/
  /***                                                                   ***/
  /*************************************************************************/
  /*************************************************************************/

  static void
  CFF_Done_Encoding( CFF_Encoding*  encoding,
                     FT_Stream      stream )
  {
    FT_Memory  memory = stream->memory;


    FREE( encoding->codes );
    FREE( encoding->sids  );
    encoding->format = 0;
    encoding->offset = 0;
    encoding->codes  = 0;
    encoding->sids   = 0;
  }


  static void
  CFF_Done_Charset( CFF_Charset*  charset,
                    FT_Stream     stream )
  {
    FT_Memory  memory = stream->memory;


    FREE( charset->sids );
    charset->format = 0;
    charset->offset = 0;
    charset->sids   = 0;
  }


  static FT_Error
  CFF_Load_Charset( CFF_Charset*  charset,
                    FT_UInt       num_glyphs,
                    FT_Stream     stream,
                    FT_ULong      base_offset,
                    FT_ULong      offset )
  {
    FT_Memory  memory     = stream->memory;
    FT_Error   error      = 0;
    FT_UShort  glyph_sid;


    charset->offset = base_offset + offset;

    /* Get the format of the table. */
    if ( FILE_Seek( charset->offset ) ||
         READ_Byte( charset->format ) )
      goto Exit;

    /* If the the offset is greater than 2, we have to parse the */
    /* charset table.                                            */
    if ( offset > 2 )
    {
      FT_UInt  j;


      /* Allocate memory for sids. */
      if ( ALLOC( charset->sids, num_glyphs * sizeof ( FT_UShort ) ) )
        goto Exit;

      /* assign the .notdef glyph */
      charset->sids[0] = 0;

      switch ( charset->format )
      {
      case 0:
        for ( j = 1; j < num_glyphs; j++ )
        {
          if ( READ_UShort( glyph_sid ) )
            goto Exit;

          charset->sids[j] = glyph_sid;
        }
        break;

      case 1:
      case 2:
        {
          FT_UInt  nleft;
          FT_UInt  i;


          j = 1;

          while ( j < num_glyphs )
          {

            /* Read the first glyph sid of the range. */
            if ( READ_UShort( glyph_sid ) )
              goto Exit;

            /* Read the number of glyphs in the range.  */
            if ( charset->format == 2 )
            {
              if ( READ_UShort( nleft ) )
                goto Exit;
            }
            else
            {
              if ( READ_Byte( nleft ) )
                goto Exit;
            }

            /* Fill in the range of sids -- `nleft + 1' glyphs. */
            for ( i = 0; i <= nleft; i++, j++, glyph_sid++ )
              charset->sids[j] = glyph_sid;
          }
        }
        break;

      default:
        FT_ERROR(( "CFF_Load_Charset: invalid table format!\n" ));
        error = CFF_Err_Invalid_File_Format;
        goto Exit;
      }
    }
    else
    {
      /* Parse default tables corresponding to offset == 0, 1, or 2.  */
      /* CFF specification intimates the following:                   */
      /*                                                              */
      /* In order to use a predefined charset, the following must be  */
      /* true: The charset constructed for the glyphs in the font's   */
      /* charstrings dictionary must match the predefined charset in  */
      /* the first num_glyphs, and hence must match the predefined    */
      /* charset *exactly*.                                           */

      switch ( offset )
      {
      case 0:
        if ( num_glyphs != 229 )
        {
          FT_ERROR(("CFF_Load_Charset: implicit charset not equal to\n"
                    "predefined charset (Adobe ISO-Latin)!\n" ));
          error = CFF_Err_Invalid_File_Format;
          goto Exit;
        }

        /* Allocate memory for sids. */
        if ( ALLOC( charset->sids, num_glyphs * sizeof ( FT_UShort ) ) )
          goto Exit;

        /* Copy the predefined charset into the allocated memory. */
        MEM_Copy( charset->sids, cff_isoadobe_charset,
                  num_glyphs * sizeof ( FT_UShort ) );

        break;

      case 1:
        if ( num_glyphs != 166 )
        {
          FT_ERROR(( "CFF_Load_Charset: implicit charset not equal to\n"
                     "predefined charset (Adobe Expert)!\n" ));
          error = CFF_Err_Invalid_File_Format;
          goto Exit;
        }

        /* Allocate memory for sids. */
        if ( ALLOC( charset->sids, num_glyphs * sizeof ( FT_UShort ) ) )
          goto Exit;

        /* Copy the predefined charset into the allocated memory.     */
        MEM_Copy( charset->sids, cff_expert_charset,
                  num_glyphs * sizeof ( FT_UShort ) );

        break;

      case 2:
        if ( num_glyphs != 87 )
        {
          FT_ERROR(( "CFF_Load_Charset: implicit charset not equal to\n"
                     "predefined charset (Adobe Expert Subset)!\n" ));
          error = CFF_Err_Invalid_File_Format;
          goto Exit;
        }

        /* Allocate memory for sids. */
        if ( ALLOC( charset->sids, num_glyphs * sizeof ( FT_UShort ) ) )
          goto Exit;

        /* Copy the predefined charset into the allocated memory.     */
        MEM_Copy( charset->sids, cff_expertsubset_charset,
                  num_glyphs * sizeof ( FT_UShort ) );

        break;

      default:
        error = CFF_Err_Invalid_File_Format;
        goto Exit;
      }
    }

  Exit:

    /* Clean up if there was an error. */
    if ( error )
      if ( charset->sids )
      {
        if ( charset->sids )
          FREE( charset->sids );
        charset->format = 0;
        charset->offset = 0;
        charset->sids   = 0;
      }

    return error;
  }


  static FT_Error
  CFF_Load_Encoding( CFF_Encoding*  encoding,
                     CFF_Charset*   charset,
                     FT_UInt        num_glyphs,
                     FT_Stream      stream,
                     FT_ULong       base_offset,
                     FT_ULong       offset )
  {
    FT_Memory   memory = stream->memory;
    FT_Error    error  = 0;
    FT_UInt     count;
    FT_UInt     j;
    FT_UShort   glyph_sid;
    FT_Byte     glyph_code;


    /* Check for charset->sids.  If we do not have this, we fail. */
    if ( !charset->sids )
    {
      error = CFF_Err_Invalid_File_Format;
      goto Exit;
    }

    /* Allocate memory for sids/codes -- there are at most 256 sids/codes */
    /* for an encoding.                                                   */
    if ( ALLOC( encoding->sids,  256 * sizeof ( FT_UShort ) ) ||
         ALLOC( encoding->codes, 256 * sizeof ( FT_UShort ) ) )
      goto Exit;

    /* Zero out the code to gid/sid mappings. */
    for ( j = 0; j < 255; j++ )
    {
      encoding->sids [j] = 0;
      encoding->codes[j] = 0;
    }

    /* Note: The encoding table in a CFF font is indexed by glyph index,  */
    /* where the first encoded glyph index is 1.  Hence, we read the char */
    /* code (`glyph_code') at index j and make the assignment:            */
    /*                                                                    */
    /*    encoding->codes[glyph_code] = j + 1                             */
    /*                                                                    */
    /* We also make the assignment:                                       */
    /*                                                                    */
    /*    encoding->sids[glyph_code] = charset->sids[j + 1]               */
    /*                                                                    */
    /* This gives us both a code to GID and a code to SID mapping.        */

    if ( offset > 1 )
    {

      encoding->offset = base_offset + offset;

      /* we need to parse the table to determine its size */
      if ( FILE_Seek( encoding->offset ) ||
           READ_Byte( encoding->format ) ||
           READ_Byte( count )            )
        goto Exit;

      switch ( encoding->format & 0x7F )
      {
      case 0:
        for ( j = 1; j <= count; j++ )
        {
          if ( READ_Byte( glyph_code ) )
            goto Exit;

          /* Make sure j is not too big. */
          if ( j > num_glyphs )
            goto Exit;

          /* Assign code to GID mapping. */
          encoding->codes[glyph_code] = (FT_UShort)j;

          /* Assign code to SID mapping. */
          encoding->sids[glyph_code] = charset->sids[j];
        }

        break;

      case 1:
        {
          FT_Byte  nleft;
          FT_UInt  i = 1;
          FT_UInt  k;


          /* Parse the Format1 ranges. */
          for ( j = 0;  j < count; j++, i += nleft )
          {
            /* Read the first glyph code of the range. */
            if ( READ_Byte( glyph_code ) )
              goto Exit;

            /* Read the number of codes in the range. */
            if ( READ_Byte( nleft ) )
              goto Exit;

            /* Increment nleft, so we read `nleft + 1' codes/sids. */
            nleft++;

            /* Fill in the range of codes/sids. */
            for ( k = i; k < nleft + i; k++, glyph_code++ )
            {
              /* Make sure k is not too big. */
              if ( k > num_glyphs )
                goto Exit;

              /* Assign code to GID mapping. */
              encoding->codes[glyph_code] = (FT_UShort)k;

              /* Assign code to SID mapping. */
              encoding->sids[glyph_code] = charset->sids[k];
            }
          }
        }
        break;

      default:
        FT_ERROR(( "CFF_Load_Encoding: invalid table format!\n" ));
        error = CFF_Err_Invalid_File_Format;
        goto Exit;
      }

      /* Parse supplemental encodings, if any. */
      if ( encoding->format & 0x80 )
      {
        FT_UInt glyph_id;


        /* count supplements */
        if ( READ_Byte( count ) )
          goto Exit;

        for ( j = 0; j < count; j++ )
        {
          /* Read supplemental glyph code. */
          if ( READ_Byte( glyph_code ) )
            goto Exit;

          /* Read the SID associated with this glyph code. */
          if ( READ_UShort( glyph_sid ) )
            goto Exit;

          /* Assign code to SID mapping. */
          encoding->sids[glyph_code] = glyph_sid;

          /* First, lookup GID which has been assigned to */
          /* SID glyph_sid.                               */
          for ( glyph_id = 0; glyph_id < num_glyphs; glyph_id++ )
          {
            if ( charset->sids[glyph_id] == glyph_sid )
              break;
          }

          /* Now, make the assignment. */
          encoding->codes[glyph_code] = (FT_UShort)glyph_id;
        }
      }
    }
    else
    {
      FT_UInt i;


      /* We take into account the fact a CFF font can use a predefined  */
      /* encoding without containing all of the glyphs encoded by this  */
      /* encoding (see the note at the end of section 12 in the CFF     */
      /* specification).                                                */

      switch ( offset )
      {
      case 0:
        /* First, copy the code to SID mapping. */
        MEM_Copy( encoding->sids, cff_standard_encoding,
                  256 * sizeof ( FT_UShort ) );

        /* Construct code to GID mapping from code */
        /* to SID mapping and charset.             */
        for ( j = 0; j < 256; j++ )
        {
          /* If j is encoded, find the GID for it. */
          if ( encoding->sids[j] )
          {
            for ( i = 1; i < num_glyphs; i++ )
              /* We matched, so break. */
              if ( charset->sids[i] == encoding->sids[j] )
                break;

            /* i will be equal to num_glyphs if we exited the above */
            /* loop without a match.  In this case, we also have to */
            /* fix the code to SID mapping.                         */
            if ( i == num_glyphs )
            {
              encoding->codes[j] = 0;
              encoding->sids [j] = 0;
            }
            else
              encoding->codes[j] = (FT_UShort)i;
          }
        }
        break;

      case 1:
        /* First, copy the code to SID mapping. */
        MEM_Copy( encoding->sids, cff_expert_encoding,
                  256 * sizeof ( FT_UShort ) );

        /* Construct code to GID mapping from code to SID mapping */
        /* and charset.                                           */
        for ( j = 0; j < 256; j++ )
        {
          /* If j is encoded, find the GID for it. */
          if ( encoding->sids[j] )
          {
            for ( i = 1; i < num_glyphs; i++ )
              /* We matched, so break. */
              if ( charset->sids[i] == encoding->sids[j] )
                break;

            /* i will be equal to num_glyphs if we exited the above */
            /* loop without a match.  In this case, we also have to */
            /* fix the code to SID mapping.                         */
            if ( i == num_glyphs )
            {
              encoding->codes[j] = 0;
              encoding->sids [j] = 0;
            }
            else
              encoding->codes[j] = (FT_UShort)i;
          }
        }
        break;

      default:
        FT_ERROR(( "CFF_Load_Encoding: invalid table format!\n" ));
        error = CFF_Err_Invalid_File_Format;
        goto Exit;
      }
    }

  Exit:

    /* Clean up if there was an error. */
    if ( error )
    {
      if ( encoding->sids || encoding->codes )
      {
        if ( encoding->sids )
          FREE( encoding->sids );

        if ( encoding->codes )
          FREE( encoding->codes );

        charset->format = 0;
        charset->offset = 0;
        charset->sids   = 0;
      }
    }

    return error;
  }


  static FT_Error
  CFF_Load_SubFont( CFF_SubFont*  font,
                    CFF_Index*    index,
                    FT_UInt       font_index,
                    FT_Stream     stream,
                    FT_ULong      base_offset )
  {
    FT_Error        error;
    CFF_Parser      parser;
    FT_Byte*        dict;
    FT_ULong        dict_len;
    CFF_Font_Dict*  top  = &font->font_dict;
    CFF_Private*    priv = &font->private_dict;


    CFF_Parser_Init( &parser, CFF_CODE_TOPDICT, &font->font_dict );

    /* set defaults */
    MEM_Set( top, 0, sizeof ( *top ) );

    top->underline_position  = -100;
    top->underline_thickness = 50;
    top->charstring_type     = 2;
    top->font_matrix.xx      = 0x10000L;
    top->font_matrix.yy      = 0x10000L;
    top->cid_count           = 8720;

    error = CFF_Access_Element( index, font_index, &dict, &dict_len ) ||
            CFF_Parser_Run( &parser, dict, dict + dict_len );

    CFF_Forget_Element( index, &dict );

    if ( error )
      goto Exit;

    /* if it is a CID font, we stop there */
    if ( top->cid_registry )
      goto Exit;

    /* parse the private dictionary, if any */
    if ( top->private_offset && top->private_size )
    {
      /* set defaults */
      MEM_Set( priv, 0, sizeof ( *priv ) );

      priv->blue_shift       = 7;
      priv->blue_fuzz        = 1;
      priv->lenIV            = -1;
      priv->expansion_factor = (FT_Fixed)0.06 * 0x10000L;
      priv->blue_scale       = (FT_Fixed)0.039625 * 0x10000L;

      CFF_Parser_Init( &parser, CFF_CODE_PRIVATE, priv );

      if ( FILE_Seek( base_offset + font->font_dict.private_offset ) ||
           ACCESS_Frame( font->font_dict.private_size )              )
        goto Exit;

      error = CFF_Parser_Run( &parser,
                             (FT_Byte*)stream->cursor,
                             (FT_Byte*)stream->limit );
      FORGET_Frame();
      if ( error )
        goto Exit;
    }

    /* read the local subrs, if any */
    if ( priv->local_subrs_offset )
    {
      if ( FILE_Seek( base_offset + top->private_offset +
                      priv->local_subrs_offset ) )
        goto Exit;

      error = cff_new_index( &font->local_subrs_index, stream, 1 );
      if ( error )
        goto Exit;

      font->num_local_subrs = font->local_subrs_index.count;
      error = cff_explicit_index( &font->local_subrs_index,
                                     &font->local_subrs );
      if ( error )
        goto Exit;
    }

  Exit:
    return error;
  }


  static void
  CFF_Done_SubFont( FT_Memory     memory,
                    CFF_SubFont*  subfont )
  {
    if ( subfont )
    {
      cff_done_index( &subfont->local_subrs_index );
      FREE( subfont->local_subrs );
    }
  }


  FT_LOCAL_DEF FT_Error
  CFF_Load_Font( FT_Stream  stream,
                 FT_Int     face_index,
                 CFF_Font*  font )
  {
    static const FT_Frame_Field  cff_header_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  CFF_Font

      FT_FRAME_START( 4 ),
        FT_FRAME_BYTE( version_major ),
        FT_FRAME_BYTE( version_minor ),
        FT_FRAME_BYTE( header_size ),
        FT_FRAME_BYTE( absolute_offsize ),
      FT_FRAME_END
    };

    FT_Error        error;
    FT_Memory       memory = stream->memory;
    FT_ULong        base_offset;
    CFF_Font_Dict*  dict;


    MEM_Set( font, 0, sizeof ( *font ) );

    font->stream = stream;
    font->memory = memory;
    dict         = &font->top_font.font_dict;
    base_offset  = FILE_Pos();

    /* read CFF font header */
    if ( READ_Fields( cff_header_fields, font ) )
      goto Exit;

    /* check format */
    if ( font->version_major   != 1 ||
         font->header_size      < 4 ||
         font->absolute_offsize > 4 )
    {
      FT_TRACE2(( "[not a CFF font header!]\n" ));
      error = CFF_Err_Unknown_File_Format;
      goto Exit;
    }

    /* skip the rest of the header */
    if ( FILE_Skip( font->header_size - 4 ) )
      goto Exit;

    /* read the name, top dict, string and global subrs index */
    if ( FT_SET_ERROR( cff_new_index( &font->name_index,         stream, 0 )) ||
         FT_SET_ERROR( cff_new_index( &font->font_dict_index,    stream, 0 )) ||
         FT_SET_ERROR( cff_new_index( &font->string_index,       stream, 0 )) ||
         FT_SET_ERROR( cff_new_index( &font->global_subrs_index, stream, 1 )) )
      goto Exit;

    /* well, we don't really forget the `disabled' fonts... */
    font->num_faces = font->name_index.count;
    if ( face_index >= (FT_Int)font->num_faces )
    {
      FT_ERROR(( "CFF_Load_Font: incorrect face index = %d\n",
                 face_index ));
      error = CFF_Err_Invalid_Argument;
    }

    /* in case of a font format check, simply exit now */
    if ( face_index < 0 )
      goto Exit;

    /* now, parse the top-level font dictionary */
    error = CFF_Load_SubFont( &font->top_font,
                              &font->font_dict_index,
                              face_index,
                              stream,
                              base_offset );
    if ( error )
      goto Exit;

    /* now, check for a CID font */
    if ( dict->cid_registry )
    {
      CFF_Index     fd_index;
      CFF_SubFont*  sub;
      FT_UInt       index;


      /* this is a CID-keyed font, we must now allocate a table of */
      /* sub-fonts, then load each of them separately              */
      if ( FILE_Seek( base_offset + dict->cid_fd_array_offset ) )
        goto Exit;

      error = cff_new_index( &fd_index, stream, 0 );
      if ( error )
        goto Exit;

      if ( fd_index.count > CFF_MAX_CID_FONTS )
      {
        FT_ERROR(( "CFF_Load_Font: FD array too large in CID font\n" ));
        goto Fail_CID;
      }

      /* allocate & read each font dict independently */
      font->num_subfonts = fd_index.count;
      if ( ALLOC_ARRAY( sub, fd_index.count, CFF_SubFont ) )
        goto Fail_CID;

      /* setup pointer table */
      for ( index = 0; index < fd_index.count; index++ )
        font->subfonts[index] = sub + index;

      /* now load each sub font independently */
      for ( index = 0; index < fd_index.count; index++ )
      {
        sub = font->subfonts[index];
        error = CFF_Load_SubFont( sub, &fd_index, index,
                                  stream, base_offset );
        if ( error )
          goto Fail_CID;
      }

      /* now load the FD Select array */
      error = CFF_Load_FD_Select( &font->fd_select,
                                  dict->cid_count,
                                  stream,
                                  base_offset + dict->cid_fd_select_offset );

    Fail_CID:
      cff_done_index( &fd_index );

      if ( error )
        goto Exit;
    }
    else
      font->num_subfonts = 0;

    /* read the charstrings index now */
    if ( dict->charstrings_offset == 0 )
    {
      FT_ERROR(( "CFF_Load_Font: no charstrings offset!\n" ));
      error = CFF_Err_Unknown_File_Format;
      goto Exit;
    }

    if ( FILE_Seek( base_offset + dict->charstrings_offset ) )
      goto Exit;

    error = cff_new_index( &font->charstrings_index, stream, 0 );
    if ( error )
      goto Exit;

    /* explicit the global subrs */
    font->num_global_subrs = font->global_subrs_index.count;
    font->num_glyphs       = font->charstrings_index.count;

    error = cff_explicit_index( &font->global_subrs_index,
                                &font->global_subrs ) ;

    if ( error )
      goto Exit;

    /* read the Charset and Encoding tables when available */
    error = CFF_Load_Charset( &font->charset, font->num_glyphs, stream,
                              base_offset, dict->charset_offset );
    if ( error )
      goto Exit;

    error = CFF_Load_Encoding( &font->encoding,
                               &font->charset,
                               font->num_glyphs,
                               stream,
                               base_offset,
                               dict->encoding_offset );
    if ( error )
      goto Exit;

    /* get the font name */
    font->font_name = CFF_Get_Name( &font->name_index, face_index );

  Exit:
    return error;
  }


  FT_LOCAL_DEF void
  CFF_Done_Font( CFF_Font*  font )
  {
    FT_Memory  memory = font->memory;
    FT_UInt    index;


    cff_done_index( &font->global_subrs_index );
    cff_done_index( &font->string_index );
    cff_done_index( &font->font_dict_index );
    cff_done_index( &font->name_index );
    cff_done_index( &font->charstrings_index );

    /* release font dictionaries, but only if working with */
    /* a CID keyed CFF font                                */
    if ( font->num_subfonts > 0 )
    {
      for ( index = 0; index < font->num_subfonts; index++ )
        CFF_Done_SubFont( memory, font->subfonts[index] );

      FREE( font->subfonts );
    }

    CFF_Done_Encoding( &font->encoding, font->stream );
    CFF_Done_Charset( &font->charset, font->stream );

    CFF_Done_SubFont( memory, &font->top_font );

    CFF_Done_FD_Select( &font->fd_select, font->stream );

    FREE( font->global_subrs );
    FREE( font->font_name );
  }


/* END */
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002 by                                           */
d1049 2
a1050 2
  FT_LOCAL_DEF( FT_UShort )
  cff_get_standard_encoding( FT_UInt  charcode )
d1085 3
a1087 3
  cff_new_index( CFF_Index  idx,
                 FT_Stream  stream,
                 FT_Bool    load )
d1094 1
a1094 1
    FT_MEM_ZERO( idx, sizeof ( *idx ) );
d1096 2
a1097 2
    idx->stream = stream;
    if ( !FT_READ_USHORT( count ) &&
d1108 1
a1108 1
      if ( FT_READ_BYTE( offsize ) )
d1111 4
a1114 4
      idx->stream   = stream;
      idx->count    = count;
      idx->off_size = offsize;
      data_size     = (FT_ULong)( count + 1 ) * offsize;
d1116 2
a1117 2
      if ( FT_NEW_ARRAY( idx->offsets, count + 1 ) ||
           FT_FRAME_ENTER( data_size )             )
d1120 1
a1120 1
      poff = idx->offsets;
d1130 1
a1130 1
      FT_FRAME_EXIT();
d1132 2
a1133 2
      idx->data_offset = FT_STREAM_POS();
      data_size        = poff[-1] - 1;
d1138 1
a1138 1
        if ( FT_FRAME_EXTRACT( data_size, idx->bytes ) )
d1144 1
a1144 1
        if ( FT_STREAM_SKIP( data_size ) )
d1151 1
a1151 1
      FT_FREE( idx->offsets );
d1158 1
a1158 1
  cff_done_index( CFF_Index  idx )
d1160 1
a1160 1
    if ( idx->stream )
d1162 1
a1162 1
      FT_Stream  stream = idx->stream;
d1166 2
a1167 2
      if ( idx->bytes )
        FT_FRAME_RELEASE( idx->bytes );
d1169 2
a1170 2
      FT_FREE( idx->offsets );
      FT_MEM_ZERO( idx, sizeof ( *idx ) );
a1174 1
 /* allocate a table containing pointers to an index's elements */
d1176 2
a1177 2
  cff_index_get_pointers( CFF_Index   idx,
                          FT_Byte***  table )
d1180 2
a1181 2
    FT_Memory  memory = idx->stream->memory;
    FT_ULong   n, offset, old_offset;
d1187 1
a1187 1
    if ( idx->count > 0 && !FT_NEW_ARRAY( t, idx->count + 1 ) )
d1190 1
a1190 1
      for ( n = 0; n <= idx->count; n++ )
d1192 1
a1192 1
        offset = idx->offsets[n];
d1196 1
a1196 1
        t[n] = idx->bytes + offset - 1;
d1207 5
a1211 5
  FT_LOCAL_DEF( FT_Error )
  cff_index_access_element( CFF_Index  idx,
                            FT_UInt    element,
                            FT_Byte**  pbytes,
                            FT_ULong*  pbyte_len )
d1216 1
a1216 1
    if ( idx && idx->count > element )
d1222 1
a1222 1
      off1 = idx->offsets[element];
d1228 1
a1228 1
          off2 = idx->offsets[element];
d1230 1
a1230 1
        } while ( off2 == 0 && element < idx->count );
d1241 1
a1241 1
        if ( idx->bytes )
d1244 1
a1244 1
          *pbytes = idx->bytes + off1 - 1;
d1249 1
a1249 1
          FT_Stream  stream = idx->stream;
d1252 2
a1253 2
          if ( FT_STREAM_SEEK( idx->data_offset + off1 - 1 ) ||
               FT_FRAME_EXTRACT( off2 - off1, *pbytes )      )
d1272 3
a1274 3
  FT_LOCAL_DEF( void )
  cff_index_forget_element( CFF_Index  idx,
                            FT_Byte**  pbytes )
d1276 1
a1276 1
    if ( idx->bytes == 0 )
d1278 1
a1278 1
      FT_Stream  stream = idx->stream;
d1281 1
a1281 1
      FT_FRAME_RELEASE( *pbytes );
d1286 3
a1288 3
  FT_LOCAL_DEF( FT_String* )
  cff_index_get_name( CFF_Index  idx,
                      FT_UInt    element )
d1290 1
a1290 1
    FT_Memory   memory = idx->stream->memory;
d1297 1
a1297 1
    error = cff_index_access_element( idx, element, &bytes, &byte_len );
d1301 1
a1301 1
    if ( !FT_ALLOC( name, byte_len + 1 ) )
d1303 1
a1303 1
      FT_MEM_COPY( name, bytes, byte_len );
d1306 1
a1306 1
    cff_index_forget_element( idx, &bytes );
d1313 4
a1316 4
  FT_LOCAL_DEF( FT_String* )
  cff_index_get_sid_string( CFF_Index        idx,
                            FT_UInt          sid,
                            PSNames_Service  psnames_service )
d1320 1
a1320 1
      return cff_index_get_name( idx, sid - 391 );
d1325 1
a1325 1
      const char*  adobe_name = psnames_service->adobe_std_strings( sid );
d1331 2
a1332 2
        FT_Memory  memory = idx->stream->memory;
        FT_Error   error;
d1335 2
a1336 2
        len = (FT_UInt)ft_strlen( adobe_name );
        if ( !FT_ALLOC( name, len + 1 ) )
d1338 1
a1338 1
          FT_MEM_COPY( name, adobe_name, len );
a1340 2

        FT_UNUSED( error );
d1358 2
a1359 2
  CFF_Done_FD_Select( CFF_FDSelect  fdselect,
                      FT_Stream     stream )
d1361 2
a1362 2
    if ( fdselect->data )
      FT_FRAME_RELEASE( fdselect->data );
d1364 3
a1366 3
    fdselect->data_size   = 0;
    fdselect->format      = 0;
    fdselect->range_count = 0;
d1371 4
a1374 4
  CFF_Load_FD_Select( CFF_FDSelect  fdselect,
                      FT_UInt       num_glyphs,
                      FT_Stream     stream,
                      FT_ULong      offset )
d1382 1
a1382 1
    if ( FT_STREAM_SEEK( offset ) || FT_READ_BYTE( format ) )
d1385 2
a1386 2
    fdselect->format      = format;
    fdselect->cache_count = 0;   /* clear cache */
d1391 1
a1391 1
      fdselect->data_size = num_glyphs;
d1395 1
a1395 1
      if ( FT_READ_USHORT( num_ranges ) )
d1398 1
a1398 1
      fdselect->data_size = num_ranges * 3 + 2;
d1401 1
a1401 1
      if ( FT_FRAME_EXTRACT( fdselect->data_size, fdselect->data ) )
d1414 3
a1416 3
  FT_LOCAL_DEF( FT_Byte )
  cff_fd_select_get( CFF_FDSelect  fdselect,
                     FT_UInt       glyph_index )
d1421 1
a1421 1
    switch ( fdselect->format )
d1424 1
a1424 1
      fd = fdselect->data[glyph_index];
d1429 1
a1429 2
      if ( (FT_UInt)( glyph_index - fdselect->cache_first ) <
                        fdselect->cache_count )
d1431 1
a1431 1
        fd = fdselect->cache_fd;
d1437 2
a1438 2
        FT_Byte*  p       = fdselect->data;
        FT_Byte*  p_limit = p + fdselect->data_size;
d1443 1
a1443 1
        first = FT_NEXT_USHORT( p );
d1450 1
a1450 1
          limit = FT_NEXT_USHORT( p );
d1457 3
a1459 3
            fdselect->cache_first = first;
            fdselect->cache_count = limit-first;
            fdselect->cache_fd    = fd2;
d1485 18
a1502 2
  cff_charset_done( CFF_Charset  charset,
                    FT_Stream    stream )
d1507 1
a1507 1
    FT_FREE( charset->sids );
d1510 1
d1515 5
a1519 5
  cff_charset_load( CFF_Charset  charset,
                    FT_UInt      num_glyphs,
                    FT_Stream    stream,
                    FT_ULong     base_offset,
                    FT_ULong     offset )
d1526 7
a1539 7
      charset->offset = base_offset + offset;

      /* Get the format of the table. */
      if ( FT_STREAM_SEEK( charset->offset ) ||
           FT_READ_BYTE( charset->format )   )
        goto Exit;

d1541 1
a1541 1
      if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )
d1550 1
a1550 1
        if ( num_glyphs > 0 )
d1552 1
a1552 1
          if ( FT_FRAME_ENTER( ( num_glyphs - 1 ) * 2 ) )
d1555 1
a1555 4
          for ( j = 1; j < num_glyphs; j++ )
            charset->sids[j] = FT_GET_USHORT();

          FT_FRAME_EXIT();
d1572 1
a1572 1
            if ( FT_READ_USHORT( glyph_sid ) )
d1578 1
a1578 1
              if ( FT_READ_USHORT( nleft ) )
d1583 1
a1583 1
              if ( FT_READ_BYTE( nleft ) )
d1588 1
a1588 1
            for ( i = 0; j < num_glyphs && i <= nleft; i++, j++, glyph_sid++ )
d1595 1
a1595 1
        FT_ERROR(( "cff_charset_load: invalid table format!\n" ));
d1608 2
a1609 1
      /* the first num_glyphs                                         */
d1611 1
a1611 3
      charset->offset = offset;  /* record charset type */

      switch ( (FT_UInt)offset )
d1614 1
a1614 1
        if ( num_glyphs > 229 )
d1616 1
a1616 1
          FT_ERROR(("cff_charset_load: implicit charset larger than\n"
d1623 1
a1623 1
        if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )
d1627 2
a1628 2
        FT_MEM_COPY( charset->sids, cff_isoadobe_charset,
                     num_glyphs * sizeof ( FT_UShort ) );
d1633 1
a1633 1
        if ( num_glyphs > 166 )
d1635 1
a1635 1
          FT_ERROR(( "cff_charset_load: implicit charset larger than\n"
d1642 1
a1642 1
        if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )
d1646 2
a1647 2
        FT_MEM_COPY( charset->sids, cff_expert_charset,
                     num_glyphs * sizeof ( FT_UShort ) );
d1652 1
a1652 1
        if ( num_glyphs > 87 )
d1654 1
a1654 1
          FT_ERROR(( "cff_charset_load: implicit charset larger than\n"
d1661 1
a1661 1
        if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )
d1665 2
a1666 2
        FT_MEM_COPY( charset->sids, cff_expertsubset_charset,
                     num_glyphs * sizeof ( FT_UShort ) );
d1682 2
a1683 1
        FT_FREE( charset->sids );
a1692 11

  static void
  cff_encoding_done( CFF_Encoding  encoding )
  {
    encoding->format = 0;
    encoding->offset = 0;
    encoding->count  = 0;
  }



d1694 6
a1699 6
  cff_encoding_load( CFF_Encoding  encoding,
                     CFF_Charset   charset,
                     FT_UInt       num_glyphs,
                     FT_Stream     stream,
                     FT_ULong      base_offset,
                     FT_ULong      offset )
d1701 1
d1706 1
a1706 1
    FT_UInt     glyph_code;
d1716 6
d1723 1
a1723 1
    for ( j = 0; j < 256; j++ )
d1747 3
a1749 3
      if ( FT_STREAM_SEEK( encoding->offset ) ||
           FT_READ_BYTE( encoding->format )   ||
           FT_READ_BYTE( count )              )
d1755 1
d1757 2
a1758 1
          FT_Byte*  p;
d1760 2
a1761 7
          /* by convention, GID 0 is always ".notdef" and is never */
          /* coded in the font. Hence, the number of codes found   */
          /* in the table is 'count+1'                             */
          /*                                                       */
          encoding->count = count + 1;

          if ( FT_FRAME_ENTER( count ) )
d1764 2
a1765 1
          p = (FT_Byte*)stream->cursor;
d1767 3
a1769 14
          for ( j = 1; j <= count; j++ )
          {
            glyph_code = *p++;

            /* Make sure j is not too big. */
            if ( j < num_glyphs )
            {
              /* Assign code to GID mapping. */
              encoding->codes[glyph_code] = (FT_UShort)j;

              /* Assign code to SID mapping. */
              encoding->sids[glyph_code] = charset->sids[j];
            }
          }
a1770 2
          FT_FRAME_EXIT();
        }
a1779 2
          encoding->count = 0;

d1784 1
a1784 1
            if ( FT_READ_BYTE( glyph_code ) )
d1788 1
a1788 1
            if ( FT_READ_BYTE( nleft ) )
a1793 4
            /* compute max number of character codes */
            if ( (FT_UInt)nleft > encoding->count )
              encoding->count = nleft;

d1798 8
a1805 8
              if ( k < num_glyphs && glyph_code < 256 )
              {
                /* Assign code to GID mapping. */
                encoding->codes[glyph_code] = (FT_UShort)k;

                /* Assign code to SID mapping. */
                encoding->sids[glyph_code] = charset->sids[k];
              }
a1807 4

          /* simple check, one never knows what can be found in a font */
          if ( encoding->count > 256 )
            encoding->count = 256;
d1812 1
a1812 1
        FT_ERROR(( "cff_encoding_load: invalid table format!\n" ));
d1820 1
a1820 1
        FT_UInt  gindex;
d1824 1
a1824 1
        if ( FT_READ_BYTE( count ) )
d1830 1
a1830 1
          if ( FT_READ_BYTE( glyph_code ) )
d1834 1
a1834 1
          if ( FT_READ_USHORT( glyph_sid ) )
d1842 1
a1842 1
          for ( gindex = 0; gindex < num_glyphs; gindex++ )
d1844 1
a1844 3
            if ( charset->sids[gindex] == glyph_sid )
            {
              encoding->codes[glyph_code] = (FT_UShort) gindex;
a1845 1
            }
d1847 3
d1863 1
a1863 1
      switch ( (FT_UInt)offset )
d1867 2
a1868 2
        FT_MEM_COPY( encoding->sids, cff_standard_encoding,
                     256 * sizeof ( FT_UShort ) );
d1870 25
a1894 1
        goto Populate;
d1898 2
a1899 2
        FT_MEM_COPY( encoding->sids, cff_expert_encoding,
                     256 * sizeof ( FT_UShort ) );
a1900 1
      Populate:
a1902 4

        encoding->count = 0;


a1921 1
            {
a1922 5

              /* update encoding count */
              if ( encoding->count < j+1 )
                encoding->count = j+1;
            }
d1928 1
a1928 1
        FT_ERROR(( "cff_encoding_load: invalid table format!\n" ));
d1937 16
d1958 12
a1969 12
  cff_subfont_load( CFF_SubFont  font,
                    CFF_Index    idx,
                    FT_UInt      font_index,
                    FT_Stream    stream,
                    FT_ULong     base_offset )
  {
    FT_Error         error;
    CFF_ParserRec    parser;
    FT_Byte*         dict;
    FT_ULong         dict_len;
    CFF_FontRecDict  top  = &font->font_dict;
    CFF_Private      priv = &font->private_dict;
d1972 1
a1972 1
    cff_parser_init( &parser, CFF_CODE_TOPDICT, &font->font_dict );
d1975 1
a1975 1
    FT_MEM_ZERO( top, sizeof ( *top ) );
d1984 2
a1985 2
    error = cff_index_access_element( idx, font_index, &dict, &dict_len ) ||
            cff_parser_run( &parser, dict, dict + dict_len );
d1987 1
a1987 1
    cff_index_forget_element( idx, &dict );
d2000 1
a2000 1
      FT_MEM_ZERO( priv, sizeof ( *priv ) );
d2008 1
a2008 1
      cff_parser_init( &parser, CFF_CODE_PRIVATE, priv );
d2010 2
a2011 2
      if ( FT_STREAM_SEEK( base_offset + font->font_dict.private_offset ) ||
           FT_FRAME_ENTER( font->font_dict.private_size )                 )
d2014 4
a2017 4
      error = cff_parser_run( &parser,
                              (FT_Byte*)stream->cursor,
                              (FT_Byte*)stream->limit );
      FT_FRAME_EXIT();
d2025 2
a2026 2
      if ( FT_STREAM_SEEK( base_offset + top->private_offset +
                           priv->local_subrs_offset ) )
d2034 2
a2035 2
      error = cff_index_get_pointers( &font->local_subrs_index,
                                      &font->local_subrs );
d2046 2
a2047 2
  cff_subfont_done( FT_Memory    memory,
                    CFF_SubFont  subfont )
d2052 1
a2052 1
      FT_FREE( subfont->local_subrs );
d2057 2
a2058 2
  FT_LOCAL_DEF( FT_Error )
  cff_font_load( FT_Stream  stream,
d2060 1
a2060 1
                 CFF_Font   font )
d2065 1
a2065 1
#define FT_STRUCTURE  CFF_FontRec
d2075 4
a2078 4
    FT_Error         error;
    FT_Memory        memory = stream->memory;
    FT_ULong         base_offset;
    CFF_FontRecDict  dict;
d2080 2
a2081 1
    FT_ZERO( font );
d2086 1
a2086 1
    base_offset  = FT_STREAM_POS();
d2089 1
a2089 1
    if ( FT_STREAM_READ_FIELDS( cff_header_fields, font ) )
d2103 1
a2103 1
    if ( FT_STREAM_SKIP( font->header_size - 4 ) )
d2117 1
a2117 1
      FT_ERROR(( "cff_font_load: incorrect face index = %d\n",
d2127 1
a2127 1
    error = cff_subfont_load( &font->top_font,
d2138 3
a2140 3
      CFF_IndexRec  fd_index;
      CFF_SubFont   sub;
      FT_UInt       idx;
d2145 1
a2145 1
      if ( FT_STREAM_SEEK( base_offset + dict->cid_fd_array_offset ) )
d2154 1
a2154 1
        FT_ERROR(( "cff_font_load: FD array too large in CID font\n" ));
d2160 1
a2160 1
      if ( FT_NEW_ARRAY( sub, fd_index.count ) )
d2164 2
a2165 2
      for ( idx = 0; idx < fd_index.count; idx++ )
        font->subfonts[idx] = sub + idx;
d2168 1
a2168 1
      for ( idx = 0; idx < fd_index.count; idx++ )
d2170 2
a2171 2
        sub = font->subfonts[idx];
        error = cff_subfont_load( sub, &fd_index, idx,
d2179 1
a2179 1
                                  (FT_UInt)dict->cid_count,
d2195 1
a2195 1
      FT_ERROR(( "cff_font_load: no charstrings offset!\n" ));
d2200 1
a2200 1
    if ( FT_STREAM_SEEK( base_offset + dict->charstrings_offset ) )
d2211 2
a2212 2
    error = cff_index_get_pointers( &font->global_subrs_index,
                                    &font->global_subrs ) ;
d2218 1
a2218 3
    if ( font->num_glyphs > 0 )
    {
      error = cff_charset_load( &font->charset, font->num_glyphs, stream,
d2220 2
a2221 2
      if ( error )
        goto Exit;
d2223 8
a2230 9
      error = cff_encoding_load( &font->encoding,
                                 &font->charset,
                                 font->num_glyphs,
                                 stream,
                                 base_offset,
                                 dict->encoding_offset );
      if ( error )
        goto Exit;
    }
d2233 1
a2233 1
    font->font_name = cff_index_get_name( &font->name_index, face_index );
d2240 2
a2241 2
  FT_LOCAL_DEF( void )
  cff_font_done( CFF_Font  font )
d2244 1
a2244 1
    FT_UInt    idx;
d2257 2
a2258 2
      for ( idx = 0; idx < font->num_subfonts; idx++ )
        cff_subfont_done( memory, font->subfonts[idx] );
d2260 1
a2260 1
      FT_FREE( font->subfonts );
d2263 2
a2264 2
    cff_encoding_done( &font->encoding );
    cff_charset_done( &font->charset, font->stream );
d2266 1
a2266 1
    cff_subfont_done( memory, &font->top_font );
d2270 2
a2271 2
    FT_FREE( font->global_subrs );
    FT_FREE( font->font_name );
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002 by                                           */
d1049 1
a1049 1
  FT_LOCAL_DEF( FT_UShort )
d1085 3
a1087 3
  cff_new_index( CFF_Index  idx,
                 FT_Stream  stream,
                 FT_Bool    load )
d1094 1
a1094 1
    FT_MEM_SET( idx, 0, sizeof ( *idx ) );
d1096 2
a1097 2
    idx->stream = stream;
    if ( !FT_READ_USHORT( count ) &&
d1108 1
a1108 1
      if ( FT_READ_BYTE( offsize ) )
d1111 4
a1114 4
      idx->stream   = stream;
      idx->count    = count;
      idx->off_size = offsize;
      data_size     = (FT_ULong)( count + 1 ) * offsize;
d1116 2
a1117 2
      if ( FT_NEW_ARRAY( idx->offsets, count + 1 ) ||
           FT_FRAME_ENTER( data_size )             )
d1120 1
a1120 1
      poff = idx->offsets;
d1130 1
a1130 1
      FT_FRAME_EXIT();
d1132 2
a1133 2
      idx->data_offset = FT_STREAM_POS();
      data_size        = poff[-1] - 1;
d1138 1
a1138 1
        if ( FT_FRAME_EXTRACT( data_size, idx->bytes ) )
d1144 1
a1144 1
        if ( FT_STREAM_SKIP( data_size ) )
d1151 1
a1151 1
      FT_FREE( idx->offsets );
d1158 1
a1158 1
  cff_done_index( CFF_Index  idx )
d1160 1
a1160 1
    if ( idx->stream )
d1162 1
a1162 1
      FT_Stream  stream = idx->stream;
d1166 2
a1167 2
      if ( idx->bytes )
        FT_FRAME_RELEASE( idx->bytes );
d1169 2
a1170 2
      FT_FREE( idx->offsets );
      FT_MEM_SET( idx, 0, sizeof ( *idx ) );
d1176 1
a1176 1
  cff_explicit_index( CFF_Index   idx,
d1180 1
a1180 1
    FT_Memory  memory = idx->stream->memory;
d1187 1
a1187 1
    if ( idx->count > 0 && !FT_NEW_ARRAY( t, idx->count + 1 ) )
d1190 1
a1190 1
      for ( n = 0; n <= idx->count; n++ )
d1192 1
a1192 1
        offset = idx->offsets[n];
d1196 1
a1196 1
        t[n] = idx->bytes + offset - 1;
d1207 5
a1211 5
  FT_LOCAL_DEF( FT_Error )
  CFF_Access_Element( CFF_Index  idx,
                      FT_UInt    element,
                      FT_Byte**  pbytes,
                      FT_ULong*  pbyte_len )
d1216 1
a1216 1
    if ( idx && idx->count > element )
d1222 1
a1222 1
      off1 = idx->offsets[element];
d1228 1
a1228 1
          off2 = idx->offsets[element];
d1230 1
a1230 1
        } while ( off2 == 0 && element < idx->count );
d1241 1
a1241 1
        if ( idx->bytes )
d1244 1
a1244 1
          *pbytes = idx->bytes + off1 - 1;
d1249 1
a1249 1
          FT_Stream  stream = idx->stream;
d1252 2
a1253 2
          if ( FT_STREAM_SEEK( idx->data_offset + off1 - 1 ) ||
               FT_FRAME_EXTRACT( off2 - off1, *pbytes )      )
d1272 3
a1274 3
  FT_LOCAL_DEF( void )
  CFF_Forget_Element( CFF_Index  idx,
                      FT_Byte**  pbytes )
d1276 1
a1276 1
    if ( idx->bytes == 0 )
d1278 1
a1278 1
      FT_Stream  stream = idx->stream;
d1281 1
a1281 1
      FT_FRAME_RELEASE( *pbytes );
d1286 3
a1288 3
  FT_LOCAL_DEF( FT_String* )
  CFF_Get_Name( CFF_Index  idx,
                FT_UInt    element )
d1290 1
a1290 1
    FT_Memory   memory = idx->stream->memory;
d1297 1
a1297 1
    error = CFF_Access_Element( idx, element, &bytes, &byte_len );
d1301 1
a1301 1
    if ( !FT_ALLOC( name, byte_len + 1 ) )
d1303 1
a1303 1
      FT_MEM_COPY( name, bytes, byte_len );
d1306 1
a1306 1
    CFF_Forget_Element( idx, &bytes );
d1313 4
a1316 4
  FT_LOCAL_DEF( FT_String* )
  CFF_Get_String( CFF_Index        idx,
                  FT_UInt          sid,
                  PSNames_Service  psnames_interface )
d1320 1
a1320 1
      return CFF_Get_Name( idx, sid - 391 );
d1325 1
a1325 1
      const char*  adobe_name = psnames_interface->adobe_std_strings( sid );
d1331 2
a1332 2
        FT_Memory  memory = idx->stream->memory;
        FT_Error   error;
d1335 2
a1336 2
        len = (FT_UInt)ft_strlen( adobe_name );
        if ( !FT_ALLOC( name, len + 1 ) )
d1338 1
a1338 1
          FT_MEM_COPY( name, adobe_name, len );
a1340 2

        FT_UNUSED( error );
d1358 2
a1359 2
  CFF_Done_FD_Select( CFF_FDSelect  select,
                      FT_Stream     stream )
d1362 1
a1362 1
      FT_FRAME_RELEASE( select->data );
d1371 4
a1374 4
  CFF_Load_FD_Select( CFF_FDSelect  select,
                      FT_UInt       num_glyphs,
                      FT_Stream     stream,
                      FT_ULong      offset )
d1382 1
a1382 1
    if ( FT_STREAM_SEEK( offset ) || FT_READ_BYTE( format ) )
d1395 1
a1395 1
      if ( FT_READ_USHORT( num_ranges ) )
d1401 1
a1401 1
      if ( FT_FRAME_EXTRACT( select->data_size, select->data ) )
d1414 3
a1416 3
  FT_LOCAL_DEF( FT_Byte )
  CFF_Get_FD( CFF_FDSelect  select,
              FT_UInt       glyph_index )
d1443 1
a1443 1
        first = FT_NEXT_USHORT( p );
d1450 1
a1450 1
          limit = FT_NEXT_USHORT( p );
d1485 2
a1486 2
  CFF_Done_Encoding( CFF_Encoding  encoding,
                     FT_Stream     stream )
d1491 2
a1492 2
    FT_FREE( encoding->codes );
    FT_FREE( encoding->sids  );
d1501 2
a1502 2
  CFF_Done_Charset( CFF_Charset  charset,
                    FT_Stream    stream )
d1507 1
a1507 1
    FT_FREE( charset->sids );
d1515 5
a1519 5
  CFF_Load_Charset( CFF_Charset  charset,
                    FT_UInt      num_glyphs,
                    FT_Stream    stream,
                    FT_ULong     base_offset,
                    FT_ULong     offset )
d1529 2
a1530 2
    if ( FT_STREAM_SEEK( charset->offset ) ||
         FT_READ_BYTE( charset->format )   )
d1541 1
a1541 1
      if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )
d1552 1
a1552 1
          if ( FT_READ_USHORT( glyph_sid ) )
d1572 1
a1572 1
            if ( FT_READ_USHORT( glyph_sid ) )
d1578 1
a1578 1
              if ( FT_READ_USHORT( nleft ) )
d1583 1
a1583 1
              if ( FT_READ_BYTE( nleft ) )
d1623 1
a1623 1
        if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )
d1627 2
a1628 2
        FT_MEM_COPY( charset->sids, cff_isoadobe_charset,
                     num_glyphs * sizeof ( FT_UShort ) );
d1642 1
a1642 1
        if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )
d1646 2
a1647 2
        FT_MEM_COPY( charset->sids, cff_expert_charset,
                     num_glyphs * sizeof ( FT_UShort ) );
d1661 1
a1661 1
        if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )
d1665 2
a1666 2
        FT_MEM_COPY( charset->sids, cff_expertsubset_charset,
                     num_glyphs * sizeof ( FT_UShort ) );
d1683 1
a1683 1
          FT_FREE( charset->sids );
d1694 6
a1699 6
  CFF_Load_Encoding( CFF_Encoding  encoding,
                     CFF_Charset   charset,
                     FT_UInt       num_glyphs,
                     FT_Stream     stream,
                     FT_ULong      base_offset,
                     FT_ULong      offset )
d1718 2
a1719 2
    if ( FT_NEW_ARRAY( encoding->sids,  256 ) ||
         FT_NEW_ARRAY( encoding->codes, 256 ) )
d1747 3
a1749 3
      if ( FT_STREAM_SEEK( encoding->offset ) ||
           FT_READ_BYTE( encoding->format )   ||
           FT_READ_BYTE( count )              )
d1757 1
a1757 1
          if ( FT_READ_BYTE( glyph_code ) )
d1784 1
a1784 1
            if ( FT_READ_BYTE( glyph_code ) )
d1788 1
a1788 1
            if ( FT_READ_BYTE( nleft ) )
d1824 1
a1824 1
        if ( FT_READ_BYTE( count ) )
d1830 1
a1830 1
          if ( FT_READ_BYTE( glyph_code ) )
d1834 1
a1834 1
          if ( FT_READ_USHORT( glyph_sid ) )
d1867 2
a1868 2
        FT_MEM_COPY( encoding->sids, cff_standard_encoding,
                     256 * sizeof ( FT_UShort ) );
d1898 2
a1899 2
        FT_MEM_COPY( encoding->sids, cff_expert_encoding,
                     256 * sizeof ( FT_UShort ) );
d1942 1
a1942 1
          FT_FREE( encoding->sids );
d1945 1
a1945 1
          FT_FREE( encoding->codes );
d1958 12
a1969 12
  CFF_Load_SubFont( CFF_SubFont  font,
                    CFF_Index    idx,
                    FT_UInt      font_index,
                    FT_Stream    stream,
                    FT_ULong     base_offset )
  {
    FT_Error         error;
    CFF_ParserRec    parser;
    FT_Byte*         dict;
    FT_ULong         dict_len;
    CFF_FontRecDict  top  = &font->font_dict;
    CFF_Private      priv = &font->private_dict;
d1975 1
a1975 1
    FT_MEM_SET( top, 0, sizeof ( *top ) );
d1984 1
a1984 1
    error = CFF_Access_Element( idx, font_index, &dict, &dict_len ) ||
d1987 1
a1987 1
    CFF_Forget_Element( idx, &dict );
d2000 1
a2000 1
      FT_MEM_SET( priv, 0, sizeof ( *priv ) );
d2010 2
a2011 2
      if ( FT_STREAM_SEEK( base_offset + font->font_dict.private_offset ) ||
           FT_FRAME_ENTER( font->font_dict.private_size )                 )
d2017 1
a2017 1
      FT_FRAME_EXIT();
d2025 2
a2026 2
      if ( FT_STREAM_SEEK( base_offset + top->private_offset +
                           priv->local_subrs_offset ) )
d2035 1
a2035 1
                                  &font->local_subrs );
d2046 2
a2047 2
  CFF_Done_SubFont( FT_Memory    memory,
                    CFF_SubFont  subfont )
d2052 1
a2052 1
      FT_FREE( subfont->local_subrs );
d2057 1
a2057 1
  FT_LOCAL_DEF( FT_Error )
d2060 1
a2060 1
                 CFF_Font   font )
d2065 1
a2065 1
#define FT_STRUCTURE  CFF_FontRec
d2075 4
a2078 4
    FT_Error         error;
    FT_Memory        memory = stream->memory;
    FT_ULong         base_offset;
    CFF_FontRecDict  dict;
d2081 1
a2081 1
    FT_MEM_SET( font, 0, sizeof ( *font ) );
d2086 1
a2086 1
    base_offset  = FT_STREAM_POS();
d2089 1
a2089 1
    if ( FT_STREAM_READ_FIELDS( cff_header_fields, font ) )
d2103 1
a2103 1
    if ( FT_STREAM_SKIP( font->header_size - 4 ) )
d2138 3
a2140 3
      CFF_IndexRec  fd_index;
      CFF_SubFont   sub;
      FT_UInt       idx;
d2145 1
a2145 1
      if ( FT_STREAM_SEEK( base_offset + dict->cid_fd_array_offset ) )
d2160 1
a2160 1
      if ( FT_NEW_ARRAY( sub, fd_index.count ) )
d2164 2
a2165 2
      for ( idx = 0; idx < fd_index.count; idx++ )
        font->subfonts[idx] = sub + idx;
d2168 1
a2168 1
      for ( idx = 0; idx < fd_index.count; idx++ )
d2170 2
a2171 2
        sub = font->subfonts[idx];
        error = CFF_Load_SubFont( sub, &fd_index, idx,
d2200 1
a2200 1
    if ( FT_STREAM_SEEK( base_offset + dict->charstrings_offset ) )
d2240 2
a2241 2
  FT_LOCAL_DEF( void )
  CFF_Done_Font( CFF_Font  font )
d2244 1
a2244 1
    FT_UInt    idx;
d2257 2
a2258 2
      for ( idx = 0; idx < font->num_subfonts; idx++ )
        CFF_Done_SubFont( memory, font->subfonts[idx] );
d2260 1
a2260 1
      FT_FREE( font->subfonts );
d2270 2
a2271 2
    FT_FREE( font->global_subrs );
    FT_FREE( font->font_name );
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1050 1
a1050 1
  cff_get_standard_encoding( FT_UInt  charcode )
d1094 1
a1094 1
    FT_MEM_ZERO( idx, sizeof ( *idx ) );
d1170 1
a1170 1
      FT_MEM_ZERO( idx, sizeof ( *idx ) );
a1174 1
 /* allocate a table containing pointers to an index's elements */
d1176 2
a1177 2
  cff_index_get_pointers( CFF_Index   idx,
                          FT_Byte***  table )
d1181 1
a1181 1
    FT_ULong   n, offset, old_offset;
d1208 4
a1211 4
  cff_index_access_element( CFF_Index  idx,
                            FT_UInt    element,
                            FT_Byte**  pbytes,
                            FT_ULong*  pbyte_len )
d1273 2
a1274 2
  cff_index_forget_element( CFF_Index  idx,
                            FT_Byte**  pbytes )
d1287 2
a1288 2
  cff_index_get_name( CFF_Index  idx,
                      FT_UInt    element )
d1297 1
a1297 1
    error = cff_index_access_element( idx, element, &bytes, &byte_len );
d1306 1
a1306 1
    cff_index_forget_element( idx, &bytes );
d1314 3
a1316 3
  cff_index_get_sid_string( CFF_Index        idx,
                            FT_UInt          sid,
                            PSNames_Service  psnames_service )
d1320 1
a1320 1
      return cff_index_get_name( idx, sid - 391 );
d1325 1
a1325 1
      const char*  adobe_name = psnames_service->adobe_std_strings( sid );
d1360 1
a1360 1
  CFF_Done_FD_Select( CFF_FDSelect  fdselect,
d1363 2
a1364 2
    if ( fdselect->data )
      FT_FRAME_RELEASE( fdselect->data );
d1366 3
a1368 3
    fdselect->data_size   = 0;
    fdselect->format      = 0;
    fdselect->range_count = 0;
d1373 1
a1373 1
  CFF_Load_FD_Select( CFF_FDSelect  fdselect,
d1387 2
a1388 2
    fdselect->format      = format;
    fdselect->cache_count = 0;   /* clear cache */
d1393 1
a1393 1
      fdselect->data_size = num_glyphs;
d1400 1
a1400 1
      fdselect->data_size = num_ranges * 3 + 2;
d1403 1
a1403 1
      if ( FT_FRAME_EXTRACT( fdselect->data_size, fdselect->data ) )
d1417 2
a1418 2
  cff_fd_select_get( CFF_FDSelect  fdselect,
                     FT_UInt       glyph_index )
d1423 1
a1423 1
    switch ( fdselect->format )
d1426 1
a1426 1
      fd = fdselect->data[glyph_index];
d1431 1
a1431 2
      if ( (FT_UInt)( glyph_index - fdselect->cache_first ) <
                        fdselect->cache_count )
d1433 1
a1433 1
        fd = fdselect->cache_fd;
d1439 2
a1440 2
        FT_Byte*  p       = fdselect->data;
        FT_Byte*  p_limit = p + fdselect->data_size;
d1459 3
a1461 3
            fdselect->cache_first = first;
            fdselect->cache_count = limit-first;
            fdselect->cache_fd    = fd2;
d1487 17
a1503 1
  cff_charset_done( CFF_Charset  charset,
d1512 1
d1517 1
a1517 1
  cff_charset_load( CFF_Charset  charset,
d1528 7
a1541 7
      charset->offset = base_offset + offset;

      /* Get the format of the table. */
      if ( FT_STREAM_SEEK( charset->offset ) ||
           FT_READ_BYTE( charset->format )   )
        goto Exit;

d1552 1
a1552 1
        if ( num_glyphs > 0 )
d1554 1
a1554 1
          if ( FT_FRAME_ENTER( ( num_glyphs - 1 ) * 2 ) )
d1557 1
a1557 4
          for ( j = 1; j < num_glyphs; j++ )
            charset->sids[j] = FT_GET_USHORT();

          FT_FRAME_EXIT();
d1590 1
a1590 1
            for ( i = 0; j < num_glyphs && i <= nleft; i++, j++, glyph_sid++ )
d1597 1
a1597 1
        FT_ERROR(( "cff_charset_load: invalid table format!\n" ));
d1610 2
a1611 1
      /* the first num_glyphs                                         */
d1613 1
a1613 3
      charset->offset = offset;  /* record charset type */

      switch ( (FT_UInt)offset )
d1616 1
a1616 1
        if ( num_glyphs > 229 )
d1618 1
a1618 1
          FT_ERROR(("cff_charset_load: implicit charset larger than\n"
d1635 1
a1635 1
        if ( num_glyphs > 166 )
d1637 1
a1637 1
          FT_ERROR(( "cff_charset_load: implicit charset larger than\n"
d1654 1
a1654 1
        if ( num_glyphs > 87 )
d1656 1
a1656 1
          FT_ERROR(( "cff_charset_load: implicit charset larger than\n"
d1684 2
a1685 1
        FT_FREE( charset->sids );
a1694 11

  static void
  cff_encoding_done( CFF_Encoding  encoding )
  {
    encoding->format = 0;
    encoding->offset = 0;
    encoding->count  = 0;
  }



d1696 1
a1696 1
  cff_encoding_load( CFF_Encoding  encoding,
d1703 1
d1708 1
a1708 1
    FT_UInt     glyph_code;
d1718 6
d1725 1
a1725 1
    for ( j = 0; j < 256; j++ )
d1757 1
d1759 2
a1760 7
          FT_Byte*  p;

          /* by convention, GID 0 is always ".notdef" and is never */
          /* coded in the font. Hence, the number of codes found   */
          /* in the table is 'count+1'                             */
          /*                                                       */
          encoding->count = count + 1;
d1762 2
a1763 1
          if ( FT_FRAME_ENTER( count ) )
d1766 2
a1767 1
          p = (FT_Byte*)stream->cursor;
d1769 3
a1771 14
          for ( j = 1; j <= count; j++ )
          {
            glyph_code = *p++;

            /* Make sure j is not too big. */
            if ( j < num_glyphs )
            {
              /* Assign code to GID mapping. */
              encoding->codes[glyph_code] = (FT_UShort)j;

              /* Assign code to SID mapping. */
              encoding->sids[glyph_code] = charset->sids[j];
            }
          }
a1772 2
          FT_FRAME_EXIT();
        }
a1781 2
          encoding->count = 0;

a1795 4
            /* compute max number of character codes */
            if ( (FT_UInt)nleft > encoding->count )
              encoding->count = nleft;

d1800 8
a1807 8
              if ( k < num_glyphs && glyph_code < 256 )
              {
                /* Assign code to GID mapping. */
                encoding->codes[glyph_code] = (FT_UShort)k;

                /* Assign code to SID mapping. */
                encoding->sids[glyph_code] = charset->sids[k];
              }
a1809 4

          /* simple check, one never knows what can be found in a font */
          if ( encoding->count > 256 )
            encoding->count = 256;
d1814 1
a1814 1
        FT_ERROR(( "cff_encoding_load: invalid table format!\n" ));
d1822 1
a1822 1
        FT_UInt  gindex;
d1844 1
a1844 1
          for ( gindex = 0; gindex < num_glyphs; gindex++ )
d1846 1
a1846 3
            if ( charset->sids[gindex] == glyph_sid )
            {
              encoding->codes[glyph_code] = (FT_UShort) gindex;
a1847 1
            }
d1849 3
d1865 1
a1865 1
      switch ( (FT_UInt)offset )
d1872 25
a1896 1
        goto Populate;
a1902 1
      Populate:
a1904 4

        encoding->count = 0;


a1923 1
            {
a1924 5

              /* update encoding count */
              if ( encoding->count < j+1 )
                encoding->count = j+1;
            }
d1930 1
a1930 1
        FT_ERROR(( "cff_encoding_load: invalid table format!\n" ));
d1939 16
d1960 1
a1960 1
  cff_subfont_load( CFF_SubFont  font,
d1974 1
a1974 1
    cff_parser_init( &parser, CFF_CODE_TOPDICT, &font->font_dict );
d1977 1
a1977 1
    FT_MEM_ZERO( top, sizeof ( *top ) );
d1986 2
a1987 2
    error = cff_index_access_element( idx, font_index, &dict, &dict_len ) ||
            cff_parser_run( &parser, dict, dict + dict_len );
d1989 1
a1989 1
    cff_index_forget_element( idx, &dict );
d2002 1
a2002 1
      FT_MEM_ZERO( priv, sizeof ( *priv ) );
d2010 1
a2010 1
      cff_parser_init( &parser, CFF_CODE_PRIVATE, priv );
d2016 3
a2018 3
      error = cff_parser_run( &parser,
                              (FT_Byte*)stream->cursor,
                              (FT_Byte*)stream->limit );
d2036 2
a2037 2
      error = cff_index_get_pointers( &font->local_subrs_index,
                                      &font->local_subrs );
d2048 1
a2048 1
  cff_subfont_done( FT_Memory    memory,
d2060 1
a2060 1
  cff_font_load( FT_Stream  stream,
d2082 2
a2083 1
    FT_ZERO( font );
d2119 1
a2119 1
      FT_ERROR(( "cff_font_load: incorrect face index = %d\n",
d2129 1
a2129 1
    error = cff_subfont_load( &font->top_font,
d2156 1
a2156 1
        FT_ERROR(( "cff_font_load: FD array too large in CID font\n" ));
d2173 1
a2173 1
        error = cff_subfont_load( sub, &fd_index, idx,
d2181 1
a2181 1
                                  (FT_UInt)dict->cid_count,
d2197 1
a2197 1
      FT_ERROR(( "cff_font_load: no charstrings offset!\n" ));
d2213 2
a2214 2
    error = cff_index_get_pointers( &font->global_subrs_index,
                                    &font->global_subrs ) ;
d2220 1
a2220 3
    if ( font->num_glyphs > 0 )
    {
      error = cff_charset_load( &font->charset, font->num_glyphs, stream,
d2222 2
a2223 2
      if ( error )
        goto Exit;
d2225 8
a2232 9
      error = cff_encoding_load( &font->encoding,
                                 &font->charset,
                                 font->num_glyphs,
                                 stream,
                                 base_offset,
                                 dict->encoding_offset );
      if ( error )
        goto Exit;
    }
d2235 1
a2235 1
    font->font_name = cff_index_get_name( &font->name_index, face_index );
d2243 1
a2243 1
  cff_font_done( CFF_Font  font )
d2260 1
a2260 1
        cff_subfont_done( memory, font->subfonts[idx] );
d2265 2
a2266 2
    cff_encoding_done( &font->encoding );
    cff_charset_done( &font->charset, font->stream );
d2268 1
a2268 1
    cff_subfont_done( memory, &font->top_font );
@


