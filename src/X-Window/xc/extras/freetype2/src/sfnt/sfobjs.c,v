head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.29.54;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.01.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.01.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.21.07;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.39.08;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.09.11;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@/***************************************************************************/
/*                                                                         */
/*  sfobjs.c                                                               */
/*                                                                         */
/*    SFNT object management (base).                                       */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include "sfobjs.h"
#include "ttload.h"
#include FT_INTERNAL_SFNT_H
#include FT_INTERNAL_POSTSCRIPT_NAMES_H
#include FT_TRUETYPE_IDS_H
#include FT_TRUETYPE_TAGS_H

#include "sferrors.h"


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_sfobjs


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    Get_Name                                                           */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Returns a given ENGLISH name record in ASCII.                      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face   :: A handle to the source face object.                      */
  /*                                                                       */
  /*    nameid :: The name id of the name record to return.                */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Character string.  NULL if no name is present.                     */
  /*                                                                       */
  static FT_String*
  Get_Name( TT_Face    face,
            FT_UShort  nameid )
  {
    FT_Memory    memory = face->root.memory;
    FT_UShort    n;
    TT_NameRec*  rec;
    FT_Bool      wide_chars = 1;


    rec = face->name_table.names;
    for ( n = 0; n < face->name_table.numNameRecords; n++, rec++ )
    {
      if ( rec->nameID == nameid )
      {
        /* found the name -- now create an ASCII string from it */
        FT_Bool  found = 0;


        /* test for Microsoft English language */
        if ( rec->platformID == TT_PLATFORM_MICROSOFT &&
             rec->encodingID <= TT_MS_ID_UNICODE_CS   &&
             ( rec->languageID & 0x3FF ) == 0x009     )
          found = 1;

        /* test for Apple Unicode encoding */
        else if ( rec->platformID == TT_PLATFORM_APPLE_UNICODE )
          found = 1;

        /* test for Apple Roman */
        else if ( rec->platformID == TT_PLATFORM_MACINTOSH &&
                  rec->languageID == TT_MAC_ID_ROMAN       )
        {
          found      = 1;
          wide_chars = 0;
        }

        /* found a Unicode name */
        if ( found )
        {
          FT_String*  string;
          FT_UInt     len;


          if ( wide_chars )
          {
            FT_UInt   m;


            len = (FT_UInt)rec->stringLength / 2;
            if ( MEM_Alloc( string, len + 1 ) )
              return NULL;

            for ( m = 0; m < len; m ++ )
              string[m] = rec->string[2 * m + 1];
          }
          else
          {
            len = rec->stringLength;
            if ( MEM_Alloc( string, len + 1 ) )
              return NULL;

            MEM_Copy( string, rec->string, len );
          }

          string[len] = '\0';
          return string;
        }
      }
    }

    return NULL;
  }


  static FT_Encoding
  find_encoding( int  platform_id,
                 int  encoding_id )
  {
    typedef struct  TEncoding
    {
      int          platform_id;
      int          encoding_id;
      FT_Encoding  encoding;

    } TEncoding;

    static
    const TEncoding  tt_encodings[] =
    {
      { TT_PLATFORM_ISO,           -1,                  ft_encoding_unicode },

      { TT_PLATFORM_APPLE_UNICODE, -1,                  ft_encoding_unicode },

      { TT_PLATFORM_MACINTOSH,     TT_MAC_ID_ROMAN,     ft_encoding_apple_roman },

      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SYMBOL_CS,  ft_encoding_symbol },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UCS_4,      ft_encoding_unicode },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UNICODE_CS, ft_encoding_unicode },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SJIS,       ft_encoding_sjis },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_GB2312,     ft_encoding_gb2312 },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_BIG_5,      ft_encoding_big5 },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_WANSUNG,    ft_encoding_wansung },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_JOHAB,      ft_encoding_johab }
    };

    const TEncoding  *cur, *limit;


    cur   = tt_encodings;
    limit = cur + sizeof ( tt_encodings ) / sizeof ( tt_encodings[0] );

    for ( ; cur < limit; cur++ )
    {
      if ( cur->platform_id == platform_id )
      {
        if ( cur->encoding_id == encoding_id ||
             cur->encoding_id == -1          )
          return cur->encoding;
      }
    }

    return ft_encoding_none;
  }


  FT_LOCAL_DEF FT_Error
  SFNT_Init_Face( FT_Stream      stream,
                  TT_Face        face,
                  FT_Int         face_index,
                  FT_Int         num_params,
                  FT_Parameter*  params )
  {
    FT_Error            error;
    FT_Library          library = face->root.driver->root.library;
    SFNT_Interface*     sfnt;
    SFNT_Header         sfnt_header;

    /* for now, parameters are unused */
    FT_UNUSED( num_params );
    FT_UNUSED( params );

    sfnt = (SFNT_Interface*)face->sfnt;
    if ( !sfnt )
    {
      sfnt = (SFNT_Interface*)FT_Get_Module_Interface( library, "sfnt" );
      if ( !sfnt )
      {
        error = SFNT_Err_Invalid_File_Format;
        goto Exit;
      }

      face->sfnt       = sfnt;
      face->goto_table = sfnt->goto_table;
    }

    if ( !face->psnames )
    {
      face->psnames = (PSNames_Interface*)
                       FT_Get_Module_Interface( library, "psnames" );
    }

    /* check that we have a valid TrueType file */
    error = sfnt->load_sfnt_header( face, stream, face_index, &sfnt_header );
    if ( error )
      goto Exit;

    face->format_tag = sfnt_header.format_tag;
    face->num_tables = sfnt_header.num_tables;

    /* Load font directory */
    error = sfnt->load_directory( face, stream, &sfnt_header );
    if ( error )
      goto Exit;

    face->root.num_faces = face->ttc_header.count;
    if ( face->root.num_faces < 1 )
      face->root.num_faces = 1;

  Exit:
    return error;
  }


#undef  LOAD_
#define LOAD_( x )  ( ( error = sfnt->load_##x( face, stream ) ) \
                      != SFNT_Err_Ok )


  FT_LOCAL_DEF FT_Error
  SFNT_Load_Face( FT_Stream      stream,
                  TT_Face        face,
                  FT_Int         face_index,
                  FT_Int         num_params,
                  FT_Parameter*  params )
  {
    FT_Error         error;
    FT_Bool          has_outline;
    FT_Bool          is_apple_sbit;

    SFNT_Interface*  sfnt = (SFNT_Interface*)face->sfnt;

    FT_UNUSED( face_index );
    FT_UNUSED( num_params );
    FT_UNUSED( params );


    /* Load tables */

    /* We now support two SFNT-based bitmapped font formats.  They */
    /* are recognized easily as they do not include a `glyf'       */
    /* table.                                                      */
    /*                                                             */
    /* The first format comes from Apple, and uses a table named   */
    /* `bhed' instead of `head' to store the font header (using    */
    /* the same format).  It also doesn't include horizontal and   */
    /* vertical metrics tables (i.e. `hhea' and `vhea' tables are  */
    /* missing).                                                   */
    /*                                                             */
    /* The other format comes from Microsoft, and is used with     */
    /* WinCE/PocketPC.  It looks like a standard TTF, except that  */
    /* it doesn't contain outlines.                                */
    /*                                                             */

    /* do we have outlines in there? */
    has_outline   = FT_BOOL( ( TT_LookUp_Table( face, TTAG_glyf ) != 0 ) ||
                             ( TT_LookUp_Table( face, TTAG_CFF  ) != 0 ) );
    is_apple_sbit = 0;

#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

    /* if this font doesn't contain outlines, we try to load */
    /* a `bhed' table                                        */
    if ( !has_outline )
      is_apple_sbit = FT_BOOL( !LOAD_( bitmap_header ) );

#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */

    /* load the font header (`head' table) if this isn't an Apple */
    /* sbit font file                                             */
    if ( !is_apple_sbit && LOAD_( header ) )
      goto Exit;

    /* load other tables */
    if ( LOAD_( max_profile ) ||
         LOAD_( charmaps )    )
      goto Exit;
      
    /* the following tables are optional in PCL fonts -- */
    /* don't check for errors                            */
    (void)LOAD_( names );
    (void)LOAD_( psnames );

    /* do not load the metrics headers and tables if this is an Apple */
    /* sbit font file                                                 */
    if ( !is_apple_sbit )
    {
      /* load the `hhea' and `hmtx' tables at once */
      error = sfnt->load_metrics( face, stream, 0 );
      if ( error )
        goto Exit;

      /* try to load the `vhea' and `vmtx' tables at once */
      error = sfnt->load_metrics( face, stream, 1 );
      if ( error )
        goto Exit;

      if ( LOAD_( os2 ) )
        goto Exit;
    }

    /* the optional tables */

#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

    /* embedded bitmap support. */
    if ( sfnt->load_sbits && LOAD_( sbits ) )
    {
      /* return an error if this font file has no outlines */
      if ( error == SFNT_Err_Table_Missing && has_outline )
        error = SFNT_Err_Ok;
      else
        goto Exit;
    }
#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */

    if ( LOAD_( hdmx )    ||
         LOAD_( gasp )    ||
         LOAD_( kerning ) ||
         LOAD_( pclt )    )
      goto Exit;

#ifdef TT_CONFIG_OPTION_EXTEND_ENGINE
    if ( ( error = TT_Extension_Create( face ) ) != SFNT_Err_Ok )
      goto Exit;
#endif

    face->root.family_name = Get_Name( face, TT_NAME_ID_FONT_FAMILY );
    face->root.style_name  = Get_Name( face, TT_NAME_ID_FONT_SUBFAMILY );

    /* now set up root fields */
    {
      FT_Face     root = &face->root;
      FT_Int      flags = 0;
      TT_CharMap  charmap;
      FT_Int      n;
      FT_Memory   memory;


      memory = root->memory;

      /*********************************************************************/
      /*                                                                   */
      /* Compute face flags.                                               */
      /*                                                                   */
      if ( has_outline == TRUE )
        flags = FT_FACE_FLAG_SCALABLE;    /* scalable outlines */

      flags |= FT_FACE_FLAG_SFNT      |   /* SFNT file format  */
               FT_FACE_FLAG_HORIZONTAL;   /* horizontal data   */

#ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
      /* might need more polish to detect the presence of a Postscript */
      /* name table in the font                                        */
      flags |= FT_FACE_FLAG_GLYPH_NAMES;
#endif

      /* fixed width font? */
      if ( face->postscript.isFixedPitch )
        flags |= FT_FACE_FLAG_FIXED_WIDTH;

      /* vertical information? */
      if ( face->vertical_info )
        flags |= FT_FACE_FLAG_VERTICAL;

      /* kerning available ? */
      if ( face->kern_pairs )
        flags |= FT_FACE_FLAG_KERNING;

      root->face_flags = flags;

      /*********************************************************************/
      /*                                                                   */
      /* Compute style flags.                                              */
      /*                                                                   */
      flags = 0;
      if ( has_outline == TRUE && face->os2.version != 0xFFFF )
      {
        /* we have an OS/2 table; use the `fsSelection' field */
        if ( face->os2.fsSelection & 1 )
          flags |= FT_STYLE_FLAG_ITALIC;

        if ( face->os2.fsSelection & 32 )
          flags |= FT_STYLE_FLAG_BOLD;
      }
      else
      {
        /* this is an old Mac font, use the header field */
        if ( face->header.Mac_Style & 1 )
          flags |= FT_STYLE_FLAG_BOLD;

        if ( face->header.Mac_Style & 2 )
          flags |= FT_STYLE_FLAG_ITALIC;
      }

      root->style_flags = flags;

      /*********************************************************************/
      /*                                                                   */
      /* Polish the charmaps.                                              */
      /*                                                                   */
      /*   Try to set the charmap encoding according to the platform &     */
      /*   encoding ID of each charmap.                                    */
      /*                                                                   */
      charmap            = face->charmaps;
      root->num_charmaps = face->num_charmaps;

      /* allocate table of pointers */
      if ( ALLOC_ARRAY( root->charmaps, root->num_charmaps, FT_CharMap ) )
        goto Exit;

      for ( n = 0; n < root->num_charmaps; n++, charmap++ )
      {
        FT_Int  platform = charmap->cmap.platformID;
        FT_Int  encoding = charmap->cmap.platformEncodingID;


        charmap->root.face        = (FT_Face)face;
        charmap->root.platform_id = (FT_UShort)platform;
        charmap->root.encoding_id = (FT_UShort)encoding;
        charmap->root.encoding    = find_encoding( platform, encoding );

        /* now, set root->charmap with a unicode charmap */
        /* wherever available                            */
        if ( !root->charmap                                &&
             charmap->root.encoding == ft_encoding_unicode )
          root->charmap = (FT_CharMap)charmap;

        root->charmaps[n] = (FT_CharMap)charmap;
      }

#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

      if ( face->num_sbit_strikes )
      {
        root->face_flags |= FT_FACE_FLAG_FIXED_SIZES;

#if 0
        /* I don't know criteria whether layout is horizontal or vertical */
        if ( has_outline.... )
        {
          ...
          root->face_flags |= FT_FACE_FLAG_VERTICAL;
        }
#endif
        root->num_fixed_sizes = face->num_sbit_strikes;

        if ( ALLOC_ARRAY( root->available_sizes,
                          face->num_sbit_strikes,
                          FT_Bitmap_Size ) )
          goto Exit;

        for ( n = 0 ; n < face->num_sbit_strikes ; n++ )
        {
          root->available_sizes[n].width =
            face->sbit_strikes[n].x_ppem;

          root->available_sizes[n].height =
            face->sbit_strikes[n].y_ppem;
        }
      }
      else

#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */

      {
        root->num_fixed_sizes = 0;
        root->available_sizes = 0;
      }

      /*********************************************************************/
      /*                                                                   */
      /*  Set up metrics.                                                  */
      /*                                                                   */
      if ( has_outline == TRUE )
      {
        /* XXX What about if outline header is missing */
        /*     (e.g. sfnt wrapped outline)?            */
        root->bbox.xMin    = face->header.xMin;
        root->bbox.yMin    = face->header.yMin;
        root->bbox.xMax    = face->header.xMax;
        root->bbox.yMax    = face->header.yMax;
        root->units_per_EM = face->header.Units_Per_EM;


        /* XXX: Computing the ascender/descender/height is very different */
        /*      from what the specification tells you.  Apparently, we    */
        /*      must be careful because                                   */
        /*                                                                */
        /*      - not all fonts have an OS/2 table; in this case, we take */
        /*        the values in the horizontal header.  However, these    */
        /*        values very often are not reliable.                     */
        /*                                                                */
        /*      - otherwise, the correct typographic values are in the    */
        /*        sTypoAscender, sTypoDescender & sTypoLineGap fields.    */
        /*                                                                */
        /*        However, certains fonts have these fields set to 0.     */
        /*        Rather, they have usWinAscent & usWinDescent correctly  */
        /*        set (but with different values).                        */
        /*                                                                */
        /*      As an example, Arial Narrow is implemented through four   */
        /*      files ARIALN.TTF, ARIALNI.TTF, ARIALNB.TTF & ARIALNBI.TTF */
        /*                                                                */
        /*      Strangely, all fonts have the same values in their        */
        /*      sTypoXXX fields, except ARIALNB which sets them to 0.     */
        /*                                                                */
        /*      On the other hand, they all have different                */
        /*      usWinAscent/Descent values -- as a conclusion, the OS/2   */
        /*      table cannot be used to compute the text height reliably! */
        /*                                                                */

        /* The ascender/descender/height are computed from the OS/2 table */
        /* when found.  Otherwise, they're taken from the horizontal      */
        /* header.                                                        */
        /*                                                                */

        root->ascender  = face->horizontal.Ascender;
        root->descender = face->horizontal.Descender;

        root->height    = (FT_Short)( root->ascender - root->descender +
                                      face->horizontal.Line_Gap );

        /* if the line_gap is 0, we add an extra 15% to the text height --  */
        /* this computation is based on various versions of Times New Roman */
        if ( face->horizontal.Line_Gap == 0 )
          root->height = (FT_Short)( ( root->height * 115 + 50 ) / 100 );

#if 0

        /* some fonts have the OS/2 "sTypoAscender", "sTypoDescender" & */
        /* "sTypoLineGap" fields set to 0, like ARIALNB.TTF             */
        if ( face->os2.version != 0xFFFF && root->ascender )
        {
          FT_Int  height;


          root->ascender  =  face->os2.sTypoAscender;
          root->descender = -face->os2.sTypoDescender;

          height = root->ascender + root->descender + face->os2.sTypoLineGap;
          if ( height > root->height )
            root->height = height;
        }

#endif /* 0 */

        root->max_advance_width   = face->horizontal.advance_Width_Max;

        root->max_advance_height  = (FT_Short)( face->vertical_info
                                      ? face->vertical.advance_Height_Max
                                      : root->height );

        root->underline_position  = face->postscript.underlinePosition;
        root->underline_thickness = face->postscript.underlineThickness;

        /* root->max_points   -- already set up */
        /* root->max_contours -- already set up */
      }
    }

  Exit:
    return error;
  }


#undef LOAD_


  FT_LOCAL_DEF void
  SFNT_Done_Face( TT_Face  face )
  {
    FT_Memory        memory = face->root.memory;
    SFNT_Interface*  sfnt   = (SFNT_Interface*)face->sfnt;


    if ( sfnt )
    {
      /* destroy the postscript names table if it is loaded */
      if ( sfnt->free_psnames )
        sfnt->free_psnames( face );

      /* destroy the embedded bitmaps table if it is loaded */
      if ( sfnt->free_sbits )
        sfnt->free_sbits( face );
    }

    /* freeing the kerning table */
    FREE( face->kern_pairs );
    face->num_kern_pairs = 0;

    /* freeing the collection table */
    FREE( face->ttc_header.offsets );
    face->ttc_header.count = 0;

    /* freeing table directory */
    FREE( face->dir_tables );
    face->num_tables = 0;

    /* freeing the character mapping tables */
    if ( sfnt && sfnt->load_charmaps )
    {
      FT_UShort  n;


      for ( n = 0; n < face->num_charmaps; n++ )
        sfnt->free_charmap( face, &face->charmaps[n].cmap );
    }

    FREE( face->charmaps );
    face->num_charmaps = 0;

    FREE( face->root.charmaps );
    face->root.num_charmaps = 0;
    face->root.charmap      = 0;

    /* freeing the horizontal metrics */
    FREE( face->horizontal.long_metrics );
    FREE( face->horizontal.short_metrics );

    /* freeing the vertical ones, if any */
    if ( face->vertical_info )
    {
      FREE( face->vertical.long_metrics  );
      FREE( face->vertical.short_metrics );
      face->vertical_info = 0;
    }

    /* freeing the gasp table */
    FREE( face->gasp.gaspRanges );
    face->gasp.numRanges = 0;

    /* freeing the name table */
    sfnt->free_names( face );

    /* freeing the hdmx table */
    sfnt->free_hdmx( face );

    /* freeing family and style name */
    FREE( face->root.family_name );
    FREE( face->root.style_name );

    /* freeing sbit size table */
    face->root.num_fixed_sizes = 0;
    if ( face->root.available_sizes )
      FREE( face->root.available_sizes );

    face->sfnt = 0;
  }


/* END */
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002 by                                           */
d17 1
a17 1
/* $XFree86: xc/extras/freetype2/src/sfnt/sfobjs.c,v 1.3 2003/05/29 02:13:05 dawes Exp $ */
a21 1
#include "ttcmap0.h"
a39 95

  /* convert a UTF-16 name entry to ASCII */
  static FT_String*
  tt_name_entry_ascii_from_utf16( TT_NameEntry  entry,
                                  FT_Memory     memory )
  {
    FT_String*  string;
    FT_UInt     len, code, n;
    FT_Byte*    read = (FT_Byte*)entry->string;


    len = (FT_UInt)entry->stringLength / 2;

    if ( FT_MEM_NEW_ARRAY( string, len + 1 ) )
      return NULL;

    for ( n = 0; n < len; n++ )
    {
      code = FT_NEXT_USHORT( read );
      if ( code < 32 || code > 127 )
        code = '?';

      string[n] = (char)code;
    }

    string[len] = 0;

    return string;
  }


  /* convert a UCS-4 name entry to ASCII */
  static FT_String*
  tt_name_entry_ascii_from_ucs4( TT_NameEntry  entry,
                                 FT_Memory     memory )
  {
    FT_String*  string;
    FT_UInt     len, code, n;
    FT_Byte*    read = (FT_Byte*)entry->string;


    len = (FT_UInt)entry->stringLength / 4;

    if ( FT_MEM_NEW_ARRAY( string, len + 1 ) )
      return NULL;

    for ( n = 0; n < len; n++ )
    {
      code = (FT_UInt)FT_NEXT_ULONG( read );
      if ( code < 32 || code > 127 )
        code = '?';

      string[n] = (char)code;
    }

    string[len] = 0;

    return string;
  }


  /* convert an Apple Roman or symbol name entry to ASCII */
  static FT_String*
  tt_name_entry_ascii_from_other( TT_NameEntry  entry,
                                  FT_Memory     memory )
  {
    FT_String*  string;
    FT_UInt     len, code, n;
    FT_Byte*    read = (FT_Byte*)entry->string;


    len = (FT_UInt)entry->stringLength;

    if ( FT_MEM_NEW_ARRAY( string, len + 1 ) )
      return NULL;

    for ( n = 0; n < len; n++ )
    {
      code = *read++;
      if ( code < 32 || code > 127 )
        code = '?';

      string[n] = (char)code;
    }

    string[len] = 0;

    return string;
  }


  typedef FT_String*  (*TT_NameEntry_ConvertFunc)( TT_NameEntry  entry,
                                                   FT_Memory     memory );


d43 1
a43 1
  /*    tt_face_get_name                                                   */
d57 2
a58 2
  tt_face_get_name( TT_Face    face,
                    FT_UShort  nameid )
d60 4
a63 9
    FT_Memory         memory = face->root.memory;
    FT_String*        result = NULL;
    FT_UShort         n;
    TT_NameEntryRec*  rec;
    FT_Int            found_apple   = -1;
    FT_Int            found_win     = -1;
    FT_Int            found_unicode = -1;

    TT_NameEntry_ConvertFunc  convert;
d67 1
a67 1
    for ( n = 0; n < face->num_names; n++, rec++ )
d69 1
a69 10
      /* According to the OpenType 1.3 specification, only Microsoft or  */
      /* Apple platform IDs might be used in the `name' table.  The      */
      /* `Unicode' platform is reserved for the `cmap' table, and the    */
      /* `Iso' one is deprecated.                                        */
      /*                                                                 */
      /* However, the Apple TrueType specification doesn't say the same  */
      /* thing and goes to suggest that all Unicode `name' table entries */
      /* should be coded in UTF-16 (in big-endian format I suppose).     */
      /*                                                                 */
      if ( rec->nameID == nameid && rec->stringLength > 0 )
d71 24
a94 1
        switch ( rec->platformID )
d96 5
a100 20
        case TT_PLATFORM_APPLE_UNICODE:
        case TT_PLATFORM_ISO:
          /* there is `languageID' to check there.  We should use this */
          /* field only as a last solution when nothing else is        */
          /* available.                                                */
          /*                                                           */
          found_unicode = n;
          break;

        case TT_PLATFORM_MACINTOSH:
          if ( rec->languageID == TT_MAC_LANGID_ENGLISH )
            found_apple = n;

          break;

        case TT_PLATFORM_MICROSOFT:
          /* we only take a non-English name when there is nothing */
          /* else available in the font                            */
          /*                                                       */
          if ( found_win == -1 || ( rec->languageID & 0x3FF ) == 0x009 )
d102 1
a102 13
            switch ( rec->encodingID )
            {
            case TT_MS_ID_SYMBOL_CS:
            case TT_MS_ID_UNICODE_CS:
            case TT_MS_ID_UCS_4:
              found_win = n;
              break;

            default:
              ;
            }
          }
          break;
a103 5
        default:
          ;
        }
      }
    }
d105 3
a107 17
    /* some fonts contain invalid Unicode or Macintosh formatted entries; */
    /* we will thus favor names encoded in Windows formats if available   */
    /*                                                                    */
    convert = NULL;
    if ( found_win >= 0 )
    {
      rec = face->name_table.names + found_win;
      switch ( rec->encodingID )
      {
      case TT_MS_ID_UNICODE_CS:
      case TT_MS_ID_SYMBOL_CS:
        convert = tt_name_entry_ascii_from_utf16;
        break;

      case TT_MS_ID_UCS_4:
        convert = tt_name_entry_ascii_from_ucs4;
        break;
d109 8
a116 21
      default:
        ;
      }
    }
    else if ( found_apple >= 0 )
    {
      rec     = face->name_table.names + found_apple;
      convert = tt_name_entry_ascii_from_other;
    }
    else if ( found_unicode >= 0 )
    {
      rec     = face->name_table.names + found_unicode;
      convert = tt_name_entry_ascii_from_utf16;
    }

    if ( rec && convert )
    {
      if ( rec->string == NULL )
      {
        FT_Error   error;
        FT_Stream  stream = face->name_table.stream;
d118 2
d121 2
a122 8
        if ( FT_NEW_ARRAY  ( rec->string, rec->stringLength ) ||
             FT_STREAM_SEEK( rec->stringOffset )              ||
             FT_STREAM_READ( rec->string, rec->stringLength ) )
        {
          FT_FREE( rec->string );
          rec->stringLength = 0;
          result            = NULL;
          goto Exit;
a123 2

	(void)error;	/* Muffle compiler */
a124 2

      result = convert( rec, memory );
d127 1
a127 2
  Exit:
    return result;
d132 2
a133 2
  sfnt_find_encoding( int  platform_id,
                      int  encoding_id )
d146 1
a146 1
      { TT_PLATFORM_ISO,           -1,                  FT_ENCODING_UNICODE },
d148 1
a148 1
      { TT_PLATFORM_APPLE_UNICODE, -1,                  FT_ENCODING_UNICODE },
d150 1
a150 1
      { TT_PLATFORM_MACINTOSH,     TT_MAC_ID_ROMAN,     FT_ENCODING_APPLE_ROMAN },
d152 8
a159 8
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SYMBOL_CS,  FT_ENCODING_MS_SYMBOL },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UCS_4,      FT_ENCODING_UNICODE },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UNICODE_CS, FT_ENCODING_UNICODE },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SJIS,       FT_ENCODING_MS_SJIS },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_GB2312,     FT_ENCODING_MS_GB2312 },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_BIG_5,      FT_ENCODING_MS_BIG5 },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_WANSUNG,    FT_ENCODING_MS_WANSUNG },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_JOHAB,      FT_ENCODING_MS_JOHAB }
d178 1
a178 1
    return FT_ENCODING_NONE;
d182 2
a183 2
  FT_LOCAL_DEF( FT_Error )
  sfnt_init_face( FT_Stream      stream,
d189 4
a192 4
    FT_Error         error;
    FT_Library       library = face->root.driver->root.library;
    SFNT_Service     sfnt;
    SFNT_HeaderRec   sfnt_header;
d198 1
a198 2

    sfnt = (SFNT_Service)face->sfnt;
d201 1
a201 1
      sfnt = (SFNT_Service)FT_Get_Module_Interface( library, "sfnt" );
d214 2
a215 2
      face->psnames = (PSNames_Service)
                        FT_Get_Module_Interface( library, "psnames" );
d245 2
a246 2
  FT_LOCAL_DEF( FT_Error )
  sfnt_load_face( FT_Stream      stream,
d252 3
a254 3
    FT_Error      error;
    FT_Bool       has_outline;
    FT_Bool       is_apple_sbit;
d256 1
a256 1
    SFNT_Service  sfnt = (SFNT_Service)face->sfnt;
d281 2
a282 9
#ifdef FT_CONFIG_OPTION_INCREMENTAL
    has_outline   = FT_BOOL( face->root.internal->incremental_interface != 0 ||
                             tt_face_lookup_table( face, TTAG_glyf ) != 0         ||
                             tt_face_lookup_table( face, TTAG_CFF ) != 0          );
#else
    has_outline   = FT_BOOL( tt_face_lookup_table( face, TTAG_glyf ) != 0 ||
                             tt_face_lookup_table( face, TTAG_CFF ) != 0  );
#endif

d299 5
a303 5
    /* the following tables are often not present in embedded TrueType */
    /* fonts within PDF documents, so don't check for them.            */
    (void)LOAD_( max_profile );
    (void)LOAD_( charmaps );

a339 1

d348 7
a354 4
    face->root.family_name = tt_face_get_name( face,
                                               TT_NAME_ID_FONT_FAMILY );
    face->root.style_name  = tt_face_get_name( face,
                                               TT_NAME_ID_FONT_SUBFAMILY );
d358 5
a362 3
      FT_Face    root = &face->root;
      FT_Int32   flags = 0;
      FT_Memory  memory;
d430 2
d433 3
a435 1
      tt_face_build_cmaps( face );  /* ignore errors */
d437 1
a437 2

      /* set the encoding fields */
d439 2
a440 2
        FT_Int  m;

a441 3
        for ( m = 0; m < root->num_charmaps; m++ )
        {
          FT_CharMap  charmap = root->charmaps[m];
d443 4
d448 5
a452 2
          charmap->encoding = sfnt_find_encoding( charmap->platform_id,
                                                  charmap->encoding_id );
d454 1
a454 9
#if 0
          if ( root->charmap     == NULL &&
               charmap->encoding == FT_ENCODING_UNICODE )
          {
            /* set 'root->charmap' to the first Unicode encoding we find */
            root->charmap = charmap;
          }
#endif
        }
a456 1

a460 3
        FT_ULong  n;


d464 1
a464 2
        /* XXX: I don't know criteria whether layout is horizontal */
        /*      or vertical.                                       */
d473 3
a475 1
        if ( FT_NEW_ARRAY( root->available_sizes, face->num_sbit_strikes ) )
d594 2
a595 2
  FT_LOCAL_DEF( void )
  sfnt_done_face( TT_Face  face )
d597 2
a598 2
    FT_Memory     memory = face->root.memory;
    SFNT_Service  sfnt   = (SFNT_Service)face->sfnt;
d613 1
a613 1
    FT_FREE( face->kern_pairs );
d617 1
a617 1
    FT_FREE( face->ttc_header.offsets );
d621 1
a621 1
    FT_FREE( face->dir_tables );
d624 2
d627 1
a627 1
      FT_Stream  stream = FT_FACE_STREAM( face );
d630 2
a631 3
      /* simply release the 'cmap' table frame */
      FT_FRAME_RELEASE( face->cmap_table );
      face->cmap_size = 0;
d634 7
d642 2
a643 2
    FT_FREE( face->horizontal.long_metrics );
    FT_FREE( face->horizontal.short_metrics );
d648 2
a649 2
      FT_FREE( face->vertical.long_metrics  );
      FT_FREE( face->vertical.short_metrics );
d654 1
a654 1
    FT_FREE( face->gasp.gaspRanges );
d664 2
a665 2
    FT_FREE( face->root.family_name );
    FT_FREE( face->root.style_name );
d670 1
a670 1
      FT_FREE( face->root.available_sizes );
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002 by                                           */
a21 1
#include "ttcmap0.h"
a39 95

  /* convert a UTF-16 name entry to ASCII */
  static FT_String*
  tt_name_entry_ascii_from_utf16( TT_NameEntry  entry,
                                  FT_Memory     memory )
  {
    FT_String*  string;
    FT_UInt     len, code, n;
    FT_Byte*    read = (FT_Byte*)entry->string;


    len = (FT_UInt)entry->stringLength / 2;

    if ( FT_MEM_NEW_ARRAY( string, len + 1 ) )
      return NULL;

    for ( n = 0; n < len; n++ )
    {
      code = FT_NEXT_USHORT( read );
      if ( code < 32 || code > 127 )
        code = '?';

      string[n] = (char)code;
    }

    string[len] = 0;

    return string;
  }


  /* convert a UCS-4 name entry to ASCII */
  static FT_String*
  tt_name_entry_ascii_from_ucs4( TT_NameEntry  entry,
                                 FT_Memory     memory )
  {
    FT_String*  string;
    FT_UInt     len, code, n;
    FT_Byte*    read = (FT_Byte*)entry->string;


    len = (FT_UInt)entry->stringLength / 4;

    if ( FT_MEM_NEW_ARRAY( string, len + 1 ) )
      return NULL;

    for ( n = 0; n < len; n++ )
    {
      code = FT_NEXT_ULONG( read );
      if ( code < 32 || code > 127 )
        code = '?';

      string[n] = (char)code;
    }

    string[len] = 0;

    return string;
  }


  /* convert an Apple Roman or symbol name entry to ASCII */
  static FT_String*
  tt_name_entry_ascii_from_other( TT_NameEntry  entry,
                                  FT_Memory     memory )
  {
    FT_String*  string;
    FT_UInt     len, code, n;
    FT_Byte*    read = (FT_Byte*)entry->string;


    len = (FT_UInt)entry->stringLength;

    if ( FT_MEM_NEW_ARRAY( string, len + 1 ) )
      return NULL;

    for ( n = 0; n < len; n++ )
    {
      code = *read++;
      if ( code < 32 || code > 127 )
        code = '?';

      string[n] = (char)code;
    }

    string[len] = 0;

    return string;
  }


  typedef FT_String*  (*TT_NameEntry_ConvertFunc)( TT_NameEntry  entry,
                                                   FT_Memory     memory );


d43 1
a43 1
  /*    tt_face_get_name                                                   */
d57 2
a58 2
  tt_face_get_name( TT_Face    face,
                    FT_UShort  nameid )
d60 4
a63 9
    FT_Memory         memory = face->root.memory;
    FT_String*        result = NULL;
    FT_UShort         n;
    TT_NameEntryRec*  rec;
    FT_Int            found_apple   = -1;
    FT_Int            found_win     = -1;
    FT_Int            found_unicode = -1;

    TT_NameEntry_ConvertFunc  convert;
d67 1
a67 1
    for ( n = 0; n < face->num_names; n++, rec++ )
d69 1
a69 10
      /* According to the OpenType 1.3 specification, only Microsoft or  */
      /* Apple platform IDs might be used in the `name' table.  The      */
      /* `Unicode' platform is reserved for the `cmap' table, and the    */
      /* `Iso' one is deprecated.                                        */
      /*                                                                 */
      /* However, the Apple TrueType specification doesn't say the same  */
      /* thing and goes to suggest that all Unicode `name' table entries */
      /* should be coded in UTF-16 (in big-endian format I suppose).     */
      /*                                                                 */
      if ( rec->nameID == nameid && rec->stringLength > 0 )
d71 24
a94 1
        switch ( rec->platformID )
d96 5
a100 20
        case TT_PLATFORM_APPLE_UNICODE:
        case TT_PLATFORM_ISO:
          /* there is `languageID' to check there.  We should use this */
          /* field only as a last solution when nothing else is        */
          /* available.                                                */
          /*                                                           */
          found_unicode = n;
          break;

        case TT_PLATFORM_MACINTOSH:
          if ( rec->languageID == TT_MAC_LANGID_ENGLISH )
            found_apple = n;

          break;

        case TT_PLATFORM_MICROSOFT:
          /* we only take a non-English name when there is nothing */
          /* else available in the font                            */
          /*                                                       */
          if ( found_win == -1 || ( rec->languageID & 0x3FF ) == 0x009 )
d102 1
a102 13
            switch ( rec->encodingID )
            {
            case TT_MS_ID_SYMBOL_CS:
            case TT_MS_ID_UNICODE_CS:
            case TT_MS_ID_UCS_4:
              found_win = n;
              break;

            default:
              ;
            }
          }
          break;
a103 5
        default:
          ;
        }
      }
    }
d105 3
a107 17
    /* some fonts contain invalid Unicode or Macintosh formatted entries; */
    /* we will thus favor names encoded in Windows formats if available   */
    /*                                                                    */
    convert = NULL;
    if ( found_win >= 0 )
    {
      rec = face->name_table.names + found_win;
      switch ( rec->encodingID )
      {
      case TT_MS_ID_UNICODE_CS:
      case TT_MS_ID_SYMBOL_CS:
        convert = tt_name_entry_ascii_from_utf16;
        break;

      case TT_MS_ID_UCS_4:
        convert = tt_name_entry_ascii_from_ucs4;
        break;
d109 8
a116 21
      default:
        ;
      }
    }
    else if ( found_apple >= 0 )
    {
      rec     = face->name_table.names + found_apple;
      convert = tt_name_entry_ascii_from_other;
    }
    else if ( found_unicode >= 0 )
    {
      rec     = face->name_table.names + found_unicode;
      convert = tt_name_entry_ascii_from_utf16;
    }

    if ( rec && convert )
    {
      if ( rec->string == NULL )
      {
        FT_Error   error;
        FT_Stream  stream = face->name_table.stream;
d118 2
d121 2
a122 8
        if ( FT_NEW_ARRAY  ( rec->string, rec->stringLength ) ||
             FT_STREAM_SEEK( rec->stringOffset )              ||
             FT_STREAM_READ( rec->string, rec->stringLength ) )
        {
          FT_FREE( rec->string );
          rec->stringLength = 0;
          result            = NULL;
          goto Exit;
a124 2

      result = convert( rec, memory );
d127 1
a127 2
  Exit:
    return result;
d132 2
a133 2
  sfnt_find_encoding( int  platform_id,
                      int  encoding_id )
d182 1
a182 1
  FT_LOCAL_DEF( FT_Error )
d189 4
a192 4
    FT_Error         error;
    FT_Library       library = face->root.driver->root.library;
    SFNT_Service     sfnt;
    SFNT_HeaderRec   sfnt_header;
d198 1
a198 2

    sfnt = (SFNT_Service)face->sfnt;
d201 1
a201 1
      sfnt = (SFNT_Service)FT_Get_Module_Interface( library, "sfnt" );
d214 2
a215 2
      face->psnames = (PSNames_Service)
                        FT_Get_Module_Interface( library, "psnames" );
d245 1
a245 1
  FT_LOCAL_DEF( FT_Error )
d252 3
a254 3
    FT_Error      error;
    FT_Bool       has_outline;
    FT_Bool       is_apple_sbit;
d256 1
a256 1
    SFNT_Service  sfnt = (SFNT_Service)face->sfnt;
d299 5
a303 5
    /* the following tables are often not present in embedded TrueType */
    /* fonts within PDF documents, so don't check for them.            */
    (void)LOAD_( max_profile );
    (void)LOAD_( charmaps );

a339 1

d348 7
a354 4
    face->root.family_name = tt_face_get_name( face,
                                               TT_NAME_ID_FONT_FAMILY );
    face->root.style_name  = tt_face_get_name( face,
                                               TT_NAME_ID_FONT_SUBFAMILY );
d358 5
a362 4
      FT_Face    root = &face->root;
      FT_Int     flags = 0;
      FT_Int     n;
      FT_Memory  memory;
d430 2
a431 3
#ifdef FT_CONFIG_OPTION_USE_CMAPS

      TT_Build_CMaps( face );  /* ignore errors */
d433 3
d437 1
a437 1
      /* set the encoding fields */
d439 2
a440 1
        FT_Int  m;
d443 4
a446 4
        for ( m = 0; m < root->num_charmaps; m++ )
        {
          FT_CharMap  charmap = root->charmaps[m];

d448 5
a452 2
          charmap->encoding = sfnt_find_encoding( charmap->platform_id,
                                                  charmap->encoding_id );
d454 1
a454 7
          if ( root->charmap     == NULL &&
               charmap->encoding == ft_encoding_unicode )
          {
            /* set 'root->charmap' to the first Unicode encoding we find */
            root->charmap = charmap;
          }
        }
a456 37
#else /* !FT_CONFIG_OPTION_USE_CMAPS */

      {
        TT_CharMap  charmap = face->charmaps;


        charmap            = face->charmaps;
        root->num_charmaps = face->num_charmaps;

        /* allocate table of pointers */
        if ( FT_NEW_ARRAY( root->charmaps, root->num_charmaps ) )
          goto Exit;

        for ( n = 0; n < root->num_charmaps; n++, charmap++ )
        {
          FT_Int  platform = charmap->cmap.platformID;
          FT_Int  encoding = charmap->cmap.platformEncodingID;


          charmap->root.face        = (FT_Face)face;
          charmap->root.platform_id = (FT_UShort)platform;
          charmap->root.encoding_id = (FT_UShort)encoding;
          charmap->root.encoding    = sfnt_find_encoding( platform, encoding );

          /* now, set root->charmap with a unicode charmap */
          /* wherever available                            */
          if ( !root->charmap                                &&
               charmap->root.encoding == ft_encoding_unicode )
            root->charmap = (FT_CharMap)charmap;

          root->charmaps[n] = (FT_CharMap)charmap;
        }
      }

#endif /* !FT_CONFIG_OPTION_USE_CMAPS */


d464 1
a464 2
        /* XXX: I don't know criteria whether layout is horizontal */
        /*      or vertical.                                       */
d473 3
a475 1
        if ( FT_NEW_ARRAY( root->available_sizes, face->num_sbit_strikes ) )
d594 1
a594 1
  FT_LOCAL_DEF( void )
d597 2
a598 2
    FT_Memory     memory = face->root.memory;
    SFNT_Service  sfnt   = (SFNT_Service)face->sfnt;
d613 1
a613 1
    FT_FREE( face->kern_pairs );
d617 1
a617 1
    FT_FREE( face->ttc_header.offsets );
d621 1
a621 1
    FT_FREE( face->dir_tables );
a623 13
#ifdef FT_CONFIG_OPTION_USE_CMAPS

    {
      FT_Stream  stream = FT_FACE_STREAM( face );


      /* simply release the 'cmap' table frame */
      FT_FRAME_RELEASE( face->cmap_table );
      face->cmap_size = 0;
    }

#else /* !FT_CONFIG_OPTION_USE_CMAPS */

d634 1
a634 1
    FT_FREE( face->charmaps );
d637 1
a637 1
    FT_FREE( face->root.charmaps );
a640 2
#endif /* !FT_CONFIG_OPTION_USE_CMAPS */

d642 2
a643 2
    FT_FREE( face->horizontal.long_metrics );
    FT_FREE( face->horizontal.short_metrics );
d648 2
a649 2
      FT_FREE( face->vertical.long_metrics  );
      FT_FREE( face->vertical.short_metrics );
d654 1
a654 1
    FT_FREE( face->gasp.gaspRanges );
d664 2
a665 2
    FT_FREE( face->root.family_name );
    FT_FREE( face->root.style_name );
d670 1
a670 1
      FT_FREE( face->root.available_sizes );
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d17 1
a17 1
/* $XFree86: xc/extras/freetype2/src/sfnt/sfobjs.c,v 1.3 2003/05/29 02:13:05 dawes Exp $ */
d89 1
a89 1
      code = (FT_UInt)FT_NEXT_ULONG( read );
a273 2

	(void)error;	/* Muffle compiler */
d299 1
a299 1
      { TT_PLATFORM_ISO,           -1,                  FT_ENCODING_UNICODE },
d301 1
a301 1
      { TT_PLATFORM_APPLE_UNICODE, -1,                  FT_ENCODING_UNICODE },
d303 1
a303 1
      { TT_PLATFORM_MACINTOSH,     TT_MAC_ID_ROMAN,     FT_ENCODING_APPLE_ROMAN },
d305 8
a312 8
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SYMBOL_CS,  FT_ENCODING_MS_SYMBOL },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UCS_4,      FT_ENCODING_UNICODE },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UNICODE_CS, FT_ENCODING_UNICODE },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SJIS,       FT_ENCODING_MS_SJIS },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_GB2312,     FT_ENCODING_MS_GB2312 },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_BIG_5,      FT_ENCODING_MS_BIG5 },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_WANSUNG,    FT_ENCODING_MS_WANSUNG },
      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_JOHAB,      FT_ENCODING_MS_JOHAB }
d331 1
a331 1
    return FT_ENCODING_NONE;
d336 1
a336 1
  sfnt_init_face( FT_Stream      stream,
d400 1
a400 1
  sfnt_load_face( FT_Stream      stream,
d435 2
a436 9
#ifdef FT_CONFIG_OPTION_INCREMENTAL
    has_outline   = FT_BOOL( face->root.internal->incremental_interface != 0 ||
                             tt_face_lookup_table( face, TTAG_glyf ) != 0         ||
                             tt_face_lookup_table( face, TTAG_CFF ) != 0          );
#else
    has_outline   = FT_BOOL( tt_face_lookup_table( face, TTAG_glyf ) != 0 ||
                             tt_face_lookup_table( face, TTAG_CFF ) != 0  );
#endif

d511 2
a512 1
      FT_Int32   flags = 0;
d581 1
d583 1
a583 1
      tt_face_build_cmaps( face );  /* ignore errors */
a598 1
#if 0
d600 1
a600 1
               charmap->encoding == FT_ENCODING_UNICODE )
a604 1
#endif
d608 36
a648 3
        FT_ULong  n;


d782 1
a782 1
  sfnt_done_face( TT_Face  face )
d811 2
d821 21
@


