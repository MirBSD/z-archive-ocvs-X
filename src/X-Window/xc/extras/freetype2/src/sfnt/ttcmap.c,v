head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.29.54;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.01.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.01.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.21.07;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.39.09;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.09.11;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@/***************************************************************************/
/*                                                                         */
/*  ttcmap.c                                                               */
/*                                                                         */
/*    TrueType character mapping table (cmap) support (body).              */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include "ttload.h"
#include "ttcmap.h"

#include "sferrors.h"


  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_ttcmap


  FT_CALLBACK_DEF( FT_UInt )
  code_to_index0( TT_CMapTable*  charmap,
                  FT_ULong       char_code );

  FT_CALLBACK_DEF( FT_UInt )
  code_to_index2( TT_CMapTable*  charmap,
                  FT_ULong       char_code );

  FT_CALLBACK_DEF( FT_UInt )
  code_to_index4( TT_CMapTable*  charmap,
                  FT_ULong       char_code );

  FT_CALLBACK_DEF( FT_UInt )
  code_to_index6( TT_CMapTable*  charmap,
                  FT_ULong       char_code );

  FT_CALLBACK_DEF( FT_UInt )
  code_to_index8_12( TT_CMapTable*  charmap,
                     FT_ULong       char_code );

  FT_CALLBACK_DEF( FT_UInt )
  code_to_index10( TT_CMapTable*  charmap,
                   FT_ULong       char_code );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_CharMap_Load                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads a given TrueType character map into memory.                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face   :: A handle to the parent face object.                      */
  /*    stream :: A handle to the current stream object.                   */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    table  :: A pointer to a cmap object.                              */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The function assumes that the stream is already in use (i.e.,      */
  /*    opened).  In case of error, all partially allocated tables are     */
  /*    released.                                                          */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_CharMap_Load( TT_Face        face,
                   TT_CMapTable*  cmap,
                   FT_Stream      stream )
  {
    FT_Error      error;
    FT_Memory     memory;
    FT_UShort     num_SH, num_Seg, i;
    FT_ULong      j, n;

    FT_UShort     u, l;

    TT_CMap0*     cmap0;
    TT_CMap2*     cmap2;
    TT_CMap4*     cmap4;
    TT_CMap6*     cmap6;
    TT_CMap8_12*  cmap8_12;
    TT_CMap10*    cmap10;

    TT_CMap2SubHeader*  cmap2sub;
    TT_CMap4Segment*    segments;
    TT_CMapGroup*       groups;


    if ( cmap->loaded )
      return SFNT_Err_Ok;

    memory = stream->memory;

    if ( FILE_Seek( cmap->offset ) )
      return error;

    switch ( cmap->format )
    {
    case 0:
      cmap0 = &cmap->c.cmap0;

      if ( READ_UShort( cmap0->language )         ||
           ALLOC( cmap0->glyphIdArray, 256L )     ||
           FILE_Read( cmap0->glyphIdArray, 256L ) )
        goto Fail;

      cmap->get_index = code_to_index0;
      break;

    case 2:
      num_SH = 0;
      cmap2  = &cmap->c.cmap2;

      /* allocate subheader keys */

      if ( ALLOC_ARRAY( cmap2->subHeaderKeys, 256, FT_UShort ) ||
           ACCESS_Frame( 2L + 512L )                           )
        goto Fail;

      cmap2->language = GET_UShort();

      for ( i = 0; i < 256; i++ )
      {
        u = (FT_UShort)( GET_UShort() / 8 );
        cmap2->subHeaderKeys[i] = u;

        if ( num_SH < u )
          num_SH = u;
      }

      FORGET_Frame();

      /* load subheaders */

      cmap2->numGlyphId = l = (FT_UShort)(
        ( ( cmap->length - 2L * ( 256 + 3 ) - num_SH * 8L ) & 0xFFFF ) / 2 );

      if ( ALLOC_ARRAY( cmap2->subHeaders,
                        num_SH + 1,
                        TT_CMap2SubHeader )    ||
           ACCESS_Frame( ( num_SH + 1 ) * 8L ) )
      {
        FREE( cmap2->subHeaderKeys );
        goto Fail;
      }

      cmap2sub = cmap2->subHeaders;

      for ( i = 0; i <= num_SH; i++ )
      {
        cmap2sub->firstCode     = GET_UShort();
        cmap2sub->entryCount    = GET_UShort();
        cmap2sub->idDelta       = GET_Short();
        /* we apply the location offset immediately */
        cmap2sub->idRangeOffset = (FT_UShort)(
          GET_UShort() - ( num_SH - i ) * 8 - 2 );

        cmap2sub++;
      }

      FORGET_Frame();

      /* load glyph IDs */

      if ( ALLOC_ARRAY( cmap2->glyphIdArray, l, FT_UShort ) ||
           ACCESS_Frame( l * 2L )                           )
      {
        FREE( cmap2->subHeaders );
        FREE( cmap2->subHeaderKeys );
        goto Fail;
      }

      for ( i = 0; i < l; i++ )
        cmap2->glyphIdArray[i] = GET_UShort();

      FORGET_Frame();

      cmap->get_index = code_to_index2;
      break;

    case 4:
      cmap4 = &cmap->c.cmap4;

      /* load header */

      if ( ACCESS_Frame( 10L ) )
        goto Fail;

      cmap4->language      = GET_UShort();
      cmap4->segCountX2    = GET_UShort();
      cmap4->searchRange   = GET_UShort();
      cmap4->entrySelector = GET_UShort();
      cmap4->rangeShift    = GET_UShort();

      num_Seg = (FT_UShort)( cmap4->segCountX2 / 2 );

      FORGET_Frame();

      /* load segments */

      if ( ALLOC_ARRAY( cmap4->segments,
                        num_Seg,
                        TT_CMap4Segment )           ||
           ACCESS_Frame( ( num_Seg * 4 + 1 ) * 2L ) )
        goto Fail;

      segments = cmap4->segments;

      for ( i = 0; i < num_Seg; i++ )
        segments[i].endCount      = GET_UShort();

      (void)GET_UShort();

      for ( i = 0; i < num_Seg; i++ )
        segments[i].startCount    = GET_UShort();

      for ( i = 0; i < num_Seg; i++ )
        segments[i].idDelta       = GET_Short();

      for ( i = 0; i < num_Seg; i++ )
        segments[i].idRangeOffset = GET_UShort();

      FORGET_Frame();

      cmap4->numGlyphId = l = (FT_UShort)(
        ( ( cmap->length - ( 16L + 8L * num_Seg ) ) & 0xFFFF ) / 2 );

      /* load IDs */

      if ( ALLOC_ARRAY( cmap4->glyphIdArray, l, FT_UShort ) ||
           ACCESS_Frame( l * 2L )                           )
      {
        FREE( cmap4->segments );
        goto Fail;
      }

      for ( i = 0; i < l; i++ )
        cmap4->glyphIdArray[i] = GET_UShort();

      FORGET_Frame();

      cmap4->last_segment = cmap4->segments;

      cmap->get_index = code_to_index4;
      break;

    case 6:
      cmap6 = &cmap->c.cmap6;

      if ( ACCESS_Frame( 6L ) )
        goto Fail;

      cmap6->language   = GET_UShort();
      cmap6->firstCode  = GET_UShort();
      cmap6->entryCount = GET_UShort();

      FORGET_Frame();

      l = cmap6->entryCount;

      if ( ALLOC_ARRAY( cmap6->glyphIdArray, l, FT_Short ) ||
           ACCESS_Frame( l * 2L )                          )
        goto Fail;

      for ( i = 0; i < l; i++ )
        cmap6->glyphIdArray[i] = GET_UShort();

      FORGET_Frame();
      cmap->get_index = code_to_index6;
      break;

    case 8:
    case 12:
      cmap8_12 = &cmap->c.cmap8_12;

      if ( ACCESS_Frame( 8L ) )
        goto Fail;

      cmap->length       = GET_ULong();
      cmap8_12->language = GET_ULong();

      FORGET_Frame();

      if ( cmap->format == 8 )
        if ( FILE_Skip( 8192L ) )
          goto Fail;

      if ( READ_ULong( cmap8_12->nGroups ) )
        goto Fail;

      n = cmap8_12->nGroups;

      if ( ALLOC_ARRAY( cmap8_12->groups, n, TT_CMapGroup ) ||
           ACCESS_Frame( n * 3 * 4L )                       )
        goto Fail;

      groups = cmap8_12->groups;

      for ( j = 0; j < n; j++ )
      {
        groups[j].startCharCode = GET_ULong();
        groups[j].endCharCode   = GET_ULong();
        groups[j].startGlyphID  = GET_ULong();
      }

      FORGET_Frame();

      cmap8_12->last_group = cmap8_12->groups;

      cmap->get_index = code_to_index8_12;
      break;

    case 10:
      cmap10 = &cmap->c.cmap10;

      if ( ACCESS_Frame( 16L ) )
        goto Fail;

      cmap->length          = GET_ULong();
      cmap10->language      = GET_ULong();
      cmap10->startCharCode = GET_ULong();
      cmap10->numChars      = GET_ULong();

      FORGET_Frame();

      n = cmap10->numChars;

      if ( ALLOC_ARRAY( cmap10->glyphs, n, FT_Short ) ||
           ACCESS_Frame( n * 2L )                     )
        goto Fail;

      for ( j = 0; j < n; j++ )
        cmap10->glyphs[j] = GET_UShort();

      FORGET_Frame();
      cmap->get_index = code_to_index10;
      break;

    default:   /* corrupt character mapping table */
      return SFNT_Err_Invalid_CharMap_Format;

    }

    return SFNT_Err_Ok;

  Fail:
    TT_CharMap_Free( face, cmap );
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_CharMap_Free                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Destroys a character mapping table.                                */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A handle to the parent face object.                        */
  /*    cmap :: A handle to a cmap object.                                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_CharMap_Free( TT_Face        face,
                   TT_CMapTable*  cmap )
  {
    FT_Memory  memory;


    if ( !cmap )
      return SFNT_Err_Ok;

    memory = face->root.driver->root.memory;

    switch ( cmap->format )
    {
    case 0:
      FREE( cmap->c.cmap0.glyphIdArray );
      break;

    case 2:
      FREE( cmap->c.cmap2.subHeaderKeys );
      FREE( cmap->c.cmap2.subHeaders );
      FREE( cmap->c.cmap2.glyphIdArray );
      break;

    case 4:
      FREE( cmap->c.cmap4.segments );
      FREE( cmap->c.cmap4.glyphIdArray );
      cmap->c.cmap4.segCountX2 = 0;
      break;

    case 6:
      FREE( cmap->c.cmap6.glyphIdArray );
      cmap->c.cmap6.entryCount = 0;
      break;

    case 8:
    case 12:
      FREE( cmap->c.cmap8_12.groups );
      cmap->c.cmap8_12.nGroups = 0;
      break;

    case 10:
      FREE( cmap->c.cmap10.glyphs );
      cmap->c.cmap10.numChars = 0;
      break;

    default:
      /* invalid table format, do nothing */
      ;
    }

    cmap->loaded = FALSE;
    return SFNT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    code_to_index0                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Converts the character code into a glyph index.  Uses format 0.    */
  /*    `charCode' must be in the range 0x00-0xFF (otherwise 0 is          */
  /*    returned).                                                         */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*    cmap0    :: A pointer to a cmap table in format 0.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Glyph index into the glyphs array.  0 if the glyph does not exist. */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_UInt )
  code_to_index0( TT_CMapTable*  cmap,
                  FT_ULong       charCode )
  {
    TT_CMap0*  cmap0 = &cmap->c.cmap0;


    return ( charCode <= 0xFF ? cmap0->glyphIdArray[charCode] : 0 );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    code_to_index2                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Converts the character code into a glyph index.  Uses format 2.    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*    cmap2    :: A pointer to a cmap table in format 2.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Glyph index into the glyphs array.  0 if the glyph does not exist. */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_UInt )
  code_to_index2( TT_CMapTable*  cmap,
                  FT_ULong       charCode )
  {
    FT_UInt             result, index1, offset;
    FT_UInt             char_lo;
    FT_ULong            char_hi;
    TT_CMap2SubHeader*  sh2;
    TT_CMap2*           cmap2;


    cmap2   = &cmap->c.cmap2;
    result  = 0;
    char_lo = (FT_UInt)( charCode & 0xFF );
    char_hi = charCode >> 8;

    if ( char_hi == 0 )
    {
      /* an 8-bit character code -- we use the subHeader 0 in this case */
      /* to test whether the character code is in the charmap           */
      index1 = cmap2->subHeaderKeys[char_lo];
      if ( index1 != 0 )
        return 0;
    }
    else
    {
      /* a 16-bit character code */
      index1 = cmap2->subHeaderKeys[char_hi & 0xFF];
      if ( index1 == 0 )
        return 0;
    }

    sh2      = cmap2->subHeaders + index1;
    char_lo -= sh2->firstCode;

    if ( char_lo < (FT_UInt)sh2->entryCount )
    {
      offset = sh2->idRangeOffset / 2 + char_lo;
      if ( offset < (FT_UInt)cmap2->numGlyphId )
      {
        result = cmap2->glyphIdArray[offset];
        if ( result )
          result = ( result + sh2->idDelta ) & 0xFFFF;
      }
    }

    return result;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    code_to_index4                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Converts the character code into a glyph index.  Uses format 4.    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*    cmap4    :: A pointer to a cmap table in format 4.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Glyph index into the glyphs array.  0 if the glyph does not exist. */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_UInt )
  code_to_index4( TT_CMapTable*  cmap,
                  FT_ULong       charCode )
  {
    FT_UInt          result, index1, segCount;
    TT_CMap4*        cmap4;
    TT_CMap4Segment  *seg4, *limit;


    cmap4    = &cmap->c.cmap4;
    result   = 0;
    segCount = cmap4->segCountX2 / 2;
    limit    = cmap4->segments + segCount;

    /* first, check against the last used segment */

    seg4 = cmap4->last_segment;

    /* the following is equivalent to performing two tests, as in         */
    /*                                                                    */
    /*  if ( charCode >= seg4->startCount && charCode <= seg4->endCount ) */
    /*                                                                    */
    /* This is a bit strange, but it is faster, and the idea behind the   */
    /* cache is to significantly speed up charcode to glyph index         */
    /* conversion.                                                        */

    if ( (FT_ULong)( charCode       - seg4->startCount ) <
         (FT_ULong)( seg4->endCount - seg4->startCount ) )
      goto Found1;

    for ( seg4 = cmap4->segments; seg4 < limit; seg4++ )
    {
      /* the ranges are sorted in increasing order.  If we are out of */
      /* the range here, the char code isn't in the charmap, so exit. */

      if ( charCode > (FT_UInt)seg4->endCount )
        continue;

      if ( charCode >= (FT_UInt)seg4->startCount )
        goto Found;
    }
    return 0;

  Found:
    cmap4->last_segment = seg4;

  Found1:
    /* if the idRangeOffset is 0, we can compute the glyph index */
    /* directly                                                  */

    if ( seg4->idRangeOffset == 0 )
      result = ( charCode + seg4->idDelta ) & 0xFFFF;
    else
    {
      /* otherwise, we must use the glyphIdArray to do it */
      index1 = (FT_UInt)( seg4->idRangeOffset / 2
                          + ( charCode - seg4->startCount )
                          + ( seg4 - cmap4->segments )
                          - segCount );

      if ( index1 < (FT_UInt)cmap4->numGlyphId &&
           cmap4->glyphIdArray[index1] != 0    )
        result = ( cmap4->glyphIdArray[index1] + seg4->idDelta ) & 0xFFFF;
    }

    return result;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    code_to_index6                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Converts the character code into a glyph index.  Uses format 6.    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*    cmap6    :: A pointer to a cmap table in format 6.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Glyph index into the glyphs array.  0 if the glyph does not exist. */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_UInt )
  code_to_index6( TT_CMapTable*  cmap,
                  FT_ULong       charCode )
  {
    TT_CMap6*  cmap6;
    FT_UInt    result = 0;


    cmap6     = &cmap->c.cmap6;
    charCode -= cmap6->firstCode;

    if ( charCode < (FT_UInt)cmap6->entryCount )
      result = cmap6->glyphIdArray[charCode];

    return result;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    code_to_index8_12                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Converts the (possibly 32bit) character code into a glyph index.   */
  /*    Uses format 8 or 12.                                               */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*    cmap8_12 :: A pointer to a cmap table in format 8 or 12.           */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Glyph index into the glyphs array.  0 if the glyph does not exist. */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_UInt )
  code_to_index8_12( TT_CMapTable*  cmap,
                     FT_ULong       charCode )
  {
    TT_CMap8_12*  cmap8_12;
    TT_CMapGroup  *group, *limit;


    cmap8_12 = &cmap->c.cmap8_12;
    limit    = cmap8_12->groups + cmap8_12->nGroups;

    /* first, check against the last used group */

    group = cmap8_12->last_group;

    /* the following is equivalent to performing two tests, as in       */
    /*                                                                  */
    /*  if ( charCode >= group->startCharCode &&                        */
    /*       charCode <= group->endCharCode   )                         */
    /*                                                                  */
    /* This is a bit strange, but it is faster, and the idea behind the */
    /* cache is to significantly speed up charcode to glyph index       */
    /* conversion.                                                      */

    if ( (FT_ULong)( charCode           - group->startCharCode ) <
         (FT_ULong)( group->endCharCode - group->startCharCode ) )
      goto Found1;

    for ( group = cmap8_12->groups; group < limit; group++ )
    {
      /* the ranges are sorted in increasing order.  If we are out of */
      /* the range here, the char code isn't in the charmap, so exit. */

      if ( charCode > group->endCharCode )
        continue;

      if ( charCode >= group->startCharCode )
        goto Found;
    }
    return 0;

  Found:
    cmap8_12->last_group = group;

  Found1:
    return group->startGlyphID + (FT_UInt)( charCode - group->startCharCode );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    code_to_index10                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Converts the (possibly 32bit) character code into a glyph index.   */
  /*    Uses format 10.                                                    */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*    cmap10   :: A pointer to a cmap table in format 10.                */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Glyph index into the glyphs array.  0 if the glyph does not exist. */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_UInt )
  code_to_index10( TT_CMapTable*  cmap,
                   FT_ULong       charCode )
  {
    TT_CMap10*  cmap10;
    FT_UInt     result = 0;


    cmap10    = &cmap->c.cmap10;
    charCode -= cmap10->startCharCode;

    /* the overflow trick for comparison works here also since the number */
    /* of glyphs (even if numChars is specified as ULong in the specs) in */
    /* an OpenType font is limited to 64k                                 */

    if ( charCode < cmap10->numChars )
      result = cmap10->glyphs[charCode];

    return result;
  }


/* END */
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002 by                                           */
d38 2
a39 6
  code_to_index0( TT_CMapTable  charmap,
                  FT_ULong      char_code );

  FT_CALLBACK_DEF( FT_ULong )
  code_to_next0( TT_CMapTable  charmap,
                 FT_ULong      char_code );
d42 2
a43 6
  code_to_index2( TT_CMapTable  charmap,
                  FT_ULong      char_code );

  FT_CALLBACK_DEF( FT_ULong )
  code_to_next2( TT_CMapTable  charmap,
                 FT_ULong      char_code );
d46 2
a47 6
  code_to_index4( TT_CMapTable  charmap,
                  FT_ULong      char_code );

  FT_CALLBACK_DEF( FT_ULong )
  code_to_next4( TT_CMapTable  charmap,
                 FT_ULong      char_code );
d50 2
a51 6
  code_to_index6( TT_CMapTable  charmap,
                  FT_ULong      char_code );

  FT_CALLBACK_DEF( FT_ULong )
  code_to_next6( TT_CMapTable  charmap,
                 FT_ULong      char_code );
d54 2
a55 6
  code_to_index8_12( TT_CMapTable  charmap,
                     FT_ULong      char_code );

  FT_CALLBACK_DEF( FT_ULong )
  code_to_next8_12( TT_CMapTable  charmap,
                    FT_ULong      char_code );
d58 2
a59 6
  code_to_index10( TT_CMapTable  charmap,
                   FT_ULong      char_code );

  FT_CALLBACK_DEF( FT_ULong )
  code_to_next10( TT_CMapTable  charmap,
                  FT_ULong      char_code );
d65 1
a65 1
  /*    tt_face_load_charmap                                               */
a71 1
  /*                                                                       */
d85 22
a106 22
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_charmap( TT_Face       face,
                        TT_CMapTable  cmap,
                        FT_Stream     stream )
  {
    FT_Error     error;
    FT_Memory    memory;
    FT_UShort    num_SH, num_Seg, i;
    FT_ULong     j, n;

    FT_UShort    u, l;

    TT_CMap0     cmap0;
    TT_CMap2     cmap2;
    TT_CMap4     cmap4;
    TT_CMap6     cmap6;
    TT_CMap8_12  cmap8_12;
    TT_CMap10    cmap10;

    TT_CMap2SubHeader  cmap2sub;
    TT_CMap4Segment    segments;
    TT_CMapGroup       groups;
d114 1
a114 1
    if ( FT_STREAM_SEEK( cmap->offset ) )
d122 3
a124 3
      if ( FT_READ_USHORT( cmap0->language )           ||
           FT_ALLOC( cmap0->glyphIdArray, 256L )       ||
           FT_STREAM_READ( cmap0->glyphIdArray, 256L ) )
d127 1
a127 2
      cmap->get_index     = code_to_index0;
      cmap->get_next_char = code_to_next0;
d136 2
a137 2
      if ( FT_NEW_ARRAY( cmap2->subHeaderKeys, 256 ) ||
           FT_FRAME_ENTER( 2L + 512L )               )
d140 1
a140 1
      cmap2->language = FT_GET_USHORT();
d144 1
a144 1
        u = (FT_UShort)( FT_GET_USHORT() / 8 );
d151 1
a151 1
      FT_FRAME_EXIT();
d156 1
a156 1
        ( ( cmap->length - 2L * ( 256 + 3 ) - num_SH * 8L ) & 0xFFFFU ) / 2 );
d158 4
a161 2
      if ( FT_NEW_ARRAY( cmap2->subHeaders, num_SH + 1 ) ||
           FT_FRAME_ENTER( ( num_SH + 1 ) * 8L )         )
d163 1
a163 1
        FT_FREE( cmap2->subHeaderKeys );
d171 3
a173 3
        cmap2sub->firstCode     = FT_GET_USHORT();
        cmap2sub->entryCount    = FT_GET_USHORT();
        cmap2sub->idDelta       = FT_GET_SHORT();
d176 1
a176 1
          FT_GET_USHORT() - ( num_SH - i ) * 8 - 2 );
d181 1
a181 1
      FT_FRAME_EXIT();
d185 2
a186 2
      if ( FT_NEW_ARRAY( cmap2->glyphIdArray, l ) ||
           FT_FRAME_ENTER( l * 2L )               )
d188 2
a189 2
        FT_FREE( cmap2->subHeaders );
        FT_FREE( cmap2->subHeaderKeys );
d194 1
a194 1
        cmap2->glyphIdArray[i] = FT_GET_USHORT();
d196 1
a196 1
      FT_FRAME_EXIT();
a198 1
      cmap->get_next_char = code_to_next2;
d206 1
a206 1
      if ( FT_FRAME_ENTER( 10L ) )
d209 5
a213 5
      cmap4->language      = FT_GET_USHORT();
      cmap4->segCountX2    = FT_GET_USHORT();
      cmap4->searchRange   = FT_GET_USHORT();
      cmap4->entrySelector = FT_GET_USHORT();
      cmap4->rangeShift    = FT_GET_USHORT();
d217 1
a217 1
      FT_FRAME_EXIT();
d221 4
a224 2
      if ( FT_NEW_ARRAY( cmap4->segments, num_Seg )   ||
           FT_FRAME_ENTER( ( num_Seg * 4 + 1 ) * 2L ) )
d230 1
a230 1
        segments[i].endCount = FT_GET_USHORT();
d232 1
a232 1
      (void)FT_GET_USHORT();
d235 1
a235 1
        segments[i].startCount = FT_GET_USHORT();
d238 1
a238 1
        segments[i].idDelta = FT_GET_SHORT();
d241 1
a241 1
        segments[i].idRangeOffset = FT_GET_USHORT();
d243 1
a243 1
      FT_FRAME_EXIT();
d246 1
a246 1
        ( ( cmap->length - ( 16L + 8L * num_Seg ) ) & 0xFFFFU ) / 2 );
d250 2
a251 2
      if ( FT_NEW_ARRAY( cmap4->glyphIdArray, l ) ||
           FT_FRAME_ENTER( l * 2L )               )
d253 1
a253 1
        FT_FREE( cmap4->segments );
d258 1
a258 1
        cmap4->glyphIdArray[i] = FT_GET_USHORT();
d260 1
a260 1
      FT_FRAME_EXIT();
d264 1
a264 2
      cmap->get_index     = code_to_index4;
      cmap->get_next_char = code_to_next4;
d270 1
a270 1
      if ( FT_FRAME_ENTER( 6L ) )
d273 3
a275 3
      cmap6->language   = FT_GET_USHORT();
      cmap6->firstCode  = FT_GET_USHORT();
      cmap6->entryCount = FT_GET_USHORT();
d277 1
a277 1
      FT_FRAME_EXIT();
d281 2
a282 2
      if ( FT_NEW_ARRAY( cmap6->glyphIdArray, l ) ||
           FT_FRAME_ENTER( l * 2L )               )
d286 1
a286 1
        cmap6->glyphIdArray[i] = FT_GET_USHORT();
d288 2
a289 3
      FT_FRAME_EXIT();
      cmap->get_index     = code_to_index6;
      cmap->get_next_char = code_to_next6;
d296 1
a296 1
      if ( FT_FRAME_ENTER( 8L ) )
d299 2
a300 2
      cmap->length       = FT_GET_ULONG();
      cmap8_12->language = FT_GET_ULONG();
d302 1
a302 1
      FT_FRAME_EXIT();
d305 1
a305 1
        if ( FT_STREAM_SKIP( 8192L ) )
d308 1
a308 1
      if ( FT_READ_ULONG( cmap8_12->nGroups ) )
d313 2
a314 2
      if ( FT_NEW_ARRAY( cmap8_12->groups, n ) ||
           FT_FRAME_ENTER( n * 3 * 4L )        )
d321 3
a323 3
        groups[j].startCharCode = FT_GET_ULONG();
        groups[j].endCharCode   = FT_GET_ULONG();
        groups[j].startGlyphID  = FT_GET_ULONG();
d326 1
a326 1
      FT_FRAME_EXIT();
d330 1
a330 2
      cmap->get_index     = code_to_index8_12;
      cmap->get_next_char = code_to_next8_12;
d336 1
a336 1
      if ( FT_FRAME_ENTER( 16L ) )
d339 4
a342 4
      cmap->length          = FT_GET_ULONG();
      cmap10->language      = FT_GET_ULONG();
      cmap10->startCharCode = FT_GET_ULONG();
      cmap10->numChars      = FT_GET_ULONG();
d344 1
a344 1
      FT_FRAME_EXIT();
d348 2
a349 2
      if ( FT_NEW_ARRAY( cmap10->glyphs, n ) ||
           FT_FRAME_ENTER( n * 2L )          )
d353 1
a353 1
        cmap10->glyphs[j] = FT_GET_USHORT();
d355 2
a356 3
      FT_FRAME_EXIT();
      cmap->get_index     = code_to_index10;
      cmap->get_next_char = code_to_next10;
d367 1
a367 1
    tt_face_free_charmap( face, cmap );
d375 1
a375 1
  /*    tt_face_free_charmap                                               */
a381 1
  /*                                                                       */
d387 3
a389 3
  FT_LOCAL_DEF( FT_Error )
  tt_face_free_charmap( TT_Face       face,
                        TT_CMapTable  cmap )
d402 1
a402 1
      FT_FREE( cmap->c.cmap0.glyphIdArray );
d406 3
a408 3
      FT_FREE( cmap->c.cmap2.subHeaderKeys );
      FT_FREE( cmap->c.cmap2.subHeaders );
      FT_FREE( cmap->c.cmap2.glyphIdArray );
d412 2
a413 2
      FT_FREE( cmap->c.cmap4.segments );
      FT_FREE( cmap->c.cmap4.glyphIdArray );
d418 1
a418 1
      FT_FREE( cmap->c.cmap6.glyphIdArray );
d424 1
a424 1
      FT_FREE( cmap->c.cmap8_12.groups );
d429 1
a429 1
      FT_FREE( cmap->c.cmap10.glyphs );
a454 1
  /*                                                                       */
d461 2
a462 2
  code_to_index0( TT_CMapTable  cmap,
                  FT_ULong      charCode )
d464 1
a464 1
    TT_CMap0  cmap0 = &cmap->c.cmap0;
a473 32
  /*    code_to_next0                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Finds the next encoded character after the given one.  Uses        */
  /*    format 0. `charCode' must be in the range 0x00-0xFF (otherwise 0   */
  /*    is returned).                                                      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*                                                                       */
  /*    cmap0    :: A pointer to a cmap table in format 0.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Next char code.  0 if no higher one is encoded.                    */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_ULong )
  code_to_next0( TT_CMapTable  cmap,
                 FT_ULong      charCode )
  {
    TT_CMap0  cmap0 = &cmap->c.cmap0;


    while ( ++charCode <= 0xFF )
      if ( cmap0->glyphIdArray[charCode] )
        return ( charCode );
    return ( 0 );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
a480 1
  /*                                                                       */
d487 2
a488 2
  code_to_index2( TT_CMapTable  cmap,
                  FT_ULong      charCode )
d490 5
a494 5
    FT_UInt            result, index1, offset;
    FT_UInt            char_lo;
    FT_ULong           char_hi;
    TT_CMap2SubHeader  sh2;
    TT_CMap2           cmap2;
d528 1
a528 1
          result = ( result + sh2->idDelta ) & 0xFFFFU;
a538 84
  /*    code_to_next2                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Find the next encoded character.  Uses format 2.                   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*                                                                       */
  /*    cmap2    :: A pointer to a cmap table in format 2.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Next encoded character.  0 if none exists.                         */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_ULong )
  code_to_next2( TT_CMapTable  cmap,
                 FT_ULong      charCode )
  {
    FT_UInt            index1, offset;
    FT_UInt            char_lo;
    FT_ULong           char_hi;
    TT_CMap2SubHeader  sh2;
    TT_CMap2           cmap2;


    cmap2 = &cmap->c.cmap2;
    charCode++;

    /*
     * This is relatively simplistic -- look for a subHeader containing
     * glyphs and then walk to the first glyph in that subHeader.
     */
    while ( charCode < 0x10000L )
    {
      char_lo = (FT_UInt)( charCode & 0xFF );
      char_hi = charCode >> 8;

      if ( char_hi == 0 )
      {
        /* an 8-bit character code -- we use the subHeader 0 in this case */
        /* to test whether the character code is in the charmap           */
        index1 = cmap2->subHeaderKeys[char_lo];
        if ( index1 != 0 )
        {
          charCode++;
          continue;
        }
      }
      else
      {
        /* a 16-bit character code */
        index1 = cmap2->subHeaderKeys[char_hi & 0xFF];
        if ( index1 == 0 )
        {
          charCode = ( char_hi + 1 ) << 8;
          continue;
        }
      }

      sh2      = cmap2->subHeaders + index1;
      char_lo -= sh2->firstCode;

      if ( char_lo > (FT_UInt)sh2->entryCount )
      {
        charCode = ( char_hi + 1 ) << 8;
        continue;
      }

      offset = sh2->idRangeOffset / 2 + char_lo;
      if ( offset >= (FT_UInt)cmap2->numGlyphId ||
           cmap2->glyphIdArray[offset] == 0     )
      {
        charCode++;
        continue;
      }

      return charCode;
    }
    return 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
a545 1
  /*                                                                       */
d552 2
a553 2
  code_to_index4( TT_CMapTable  cmap,
                  FT_ULong      charCode )
d555 3
a557 3
    FT_UInt             result, index1, segCount;
    TT_CMap4            cmap4;
    TT_CMap4SegmentRec  *seg4, *limit;
d602 1
a602 1
      result = (FT_UInt)( charCode + seg4->idDelta ) & 0xFFFFU;
d613 1
a613 1
        result = ( cmap4->glyphIdArray[index1] + seg4->idDelta ) & 0xFFFFU;
a622 68
  /*    code_to_next4                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Find the next encoded character.  Uses format 4.                   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*                                                                       */
  /*    cmap     :: A pointer to a cmap table in format 4.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Next encoded character.  0 if none exists.                         */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_ULong )
  code_to_next4( TT_CMapTable  cmap,
                 FT_ULong      charCode )
  {
    FT_UInt             index1, segCount;
    TT_CMap4            cmap4;
    TT_CMap4SegmentRec  *seg4, *limit;


    cmap4    = &cmap->c.cmap4;
    segCount = cmap4->segCountX2 / 2;
    limit    = cmap4->segments + segCount;

    charCode++;

    for ( seg4 = cmap4->segments; seg4 < limit; seg4++ )
    {
      /* The ranges are sorted in increasing order.  If we are out of */
      /* the range here, the char code isn't in the charmap, so exit. */

      if ( charCode <= (FT_UInt)seg4->endCount )
        goto Found;
    }
    return 0;

  Found:
    if ( charCode < (FT_ULong) seg4->startCount )
      charCode = seg4->startCount;

    /* if the idRangeOffset is 0, all chars in the map exist */

    if ( seg4->idRangeOffset == 0 )
      return ( charCode );

    while ( charCode <= (FT_UInt) seg4->endCount )
    {
      /* otherwise, we must use the glyphIdArray to do it */
      index1 = (FT_UInt)( seg4->idRangeOffset / 2
                          + ( charCode - seg4->startCount )
                          + ( seg4 - cmap4->segments )
                          - segCount );

      if ( index1 < (FT_UInt)cmap4->numGlyphId &&
           cmap4->glyphIdArray[index1] != 0    )
        return ( charCode );
      charCode++;
    }

    return 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
a629 1
  /*                                                                       */
d636 2
a637 2
  code_to_index6( TT_CMapTable  cmap,
                  FT_ULong      charCode )
d639 2
a640 2
    TT_CMap6  cmap6;
    FT_UInt   result = 0;
a655 43
  /*    code_to_next6                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Find the next encoded character.  Uses format 6.                   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*                                                                       */
  /*    cmap     :: A pointer to a cmap table in format 6.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Next encoded character.  0 if none exists.                         */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_ULong )
  code_to_next6( TT_CMapTable  cmap,
                 FT_ULong      charCode )
  {
    TT_CMap6  cmap6;


    charCode++;

    cmap6 = &cmap->c.cmap6;

    if ( charCode < (FT_ULong) cmap6->firstCode )
      charCode = cmap6->firstCode;

    charCode -= cmap6->firstCode;

    while ( charCode < (FT_UInt)cmap6->entryCount )
    {
      if ( cmap6->glyphIdArray[charCode] != 0 )
        return charCode + cmap6->firstCode;
      charCode++;
    }

    return 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
a663 1
  /*                                                                       */
d670 2
a671 2
  code_to_index8_12( TT_CMapTable  cmap,
                     FT_ULong      charCode )
d673 2
a674 2
    TT_CMap8_12      cmap8_12;
    TT_CMapGroupRec  *group, *limit;
d714 1
a714 48
    return (FT_UInt)( group->startGlyphID +
                      ( charCode - group->startCharCode ) );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    code_to_next8_12                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Find the next encoded character.  Uses format 8 or 12.             */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*                                                                       */
  /*    cmap     :: A pointer to a cmap table in format 8 or 12.           */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Next encoded character.  0 if none exists.                         */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_ULong )
  code_to_next8_12( TT_CMapTable  cmap,
                    FT_ULong      charCode )
  {
    TT_CMap8_12      cmap8_12;
    TT_CMapGroupRec  *group, *limit;


    charCode++;
    cmap8_12 = &cmap->c.cmap8_12;
    limit    = cmap8_12->groups + cmap8_12->nGroups;

    for ( group = cmap8_12->groups; group < limit; group++ )
    {
      /* the ranges are sorted in increasing order.  If we are out of */
      /* the range here, the char code isn't in the charmap, so exit. */

      if ( charCode <= group->endCharCode )
        goto Found;
    }
    return 0;

  Found:
    if ( charCode < group->startCharCode )
      charCode = group->startCharCode;

    return charCode;
a728 1
  /*                                                                       */
d735 2
a736 2
  code_to_index10( TT_CMapTable  cmap,
                   FT_ULong      charCode )
d738 2
a739 2
    TT_CMap10  cmap10;
    FT_UInt    result = 0;
a752 46
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    code_to_next10                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Find the next encoded character.  Uses format 10.                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*                                                                       */
  /*    cmap     :: A pointer to a cmap table in format 10.                */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Next encoded character.  0 if none exists.                         */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_ULong )
  code_to_next10( TT_CMapTable  cmap,
                  FT_ULong      charCode )
  {
    TT_CMap10  cmap10;


    charCode++;
    cmap10 = &cmap->c.cmap10;

    if ( charCode < cmap10->startCharCode )
      charCode = cmap10->startCharCode;

    charCode -= cmap10->startCharCode;

    /* the overflow trick for comparison works here also since the number */
    /* of glyphs (even if numChars is specified as ULong in the specs) in */
    /* an OpenType font is limited to 64k                                 */

    while ( charCode < cmap10->numChars )
    {
      if ( cmap10->glyphs[charCode] )
        return ( charCode + cmap10->startCharCode );
      charCode++;
    }

    return 0;
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d7 1
a7 1
/*  Copyright 1996-2001, 2002 by                                           */
d38 2
a39 6
  code_to_index0( TT_CMapTable  charmap,
                  FT_ULong      char_code );

  FT_CALLBACK_DEF( FT_ULong )
  code_to_next0( TT_CMapTable  charmap,
                 FT_ULong      char_code );
d42 2
a43 6
  code_to_index2( TT_CMapTable  charmap,
                  FT_ULong      char_code );

  FT_CALLBACK_DEF( FT_ULong )
  code_to_next2( TT_CMapTable  charmap,
                 FT_ULong      char_code );
d46 2
a47 6
  code_to_index4( TT_CMapTable  charmap,
                  FT_ULong      char_code );

  FT_CALLBACK_DEF( FT_ULong )
  code_to_next4( TT_CMapTable  charmap,
                 FT_ULong      char_code );
d50 2
a51 6
  code_to_index6( TT_CMapTable  charmap,
                  FT_ULong      char_code );

  FT_CALLBACK_DEF( FT_ULong )
  code_to_next6( TT_CMapTable  charmap,
                 FT_ULong      char_code );
d54 2
a55 6
  code_to_index8_12( TT_CMapTable  charmap,
                     FT_ULong      char_code );

  FT_CALLBACK_DEF( FT_ULong )
  code_to_next8_12( TT_CMapTable  charmap,
                    FT_ULong      char_code );
d58 2
a59 6
  code_to_index10( TT_CMapTable  charmap,
                   FT_ULong      char_code );

  FT_CALLBACK_DEF( FT_ULong )
  code_to_next10( TT_CMapTable  charmap,
                  FT_ULong      char_code );
a71 1
  /*                                                                       */
d85 22
a106 22
  FT_LOCAL_DEF( FT_Error )
  TT_CharMap_Load( TT_Face       face,
                   TT_CMapTable  cmap,
                   FT_Stream     stream )
  {
    FT_Error     error;
    FT_Memory    memory;
    FT_UShort    num_SH, num_Seg, i;
    FT_ULong     j, n;

    FT_UShort    u, l;

    TT_CMap0     cmap0;
    TT_CMap2     cmap2;
    TT_CMap4     cmap4;
    TT_CMap6     cmap6;
    TT_CMap8_12  cmap8_12;
    TT_CMap10    cmap10;

    TT_CMap2SubHeader  cmap2sub;
    TT_CMap4Segment    segments;
    TT_CMapGroup       groups;
d114 1
a114 1
    if ( FT_STREAM_SEEK( cmap->offset ) )
d122 3
a124 3
      if ( FT_READ_USHORT( cmap0->language )           ||
           FT_ALLOC( cmap0->glyphIdArray, 256L )       ||
           FT_STREAM_READ( cmap0->glyphIdArray, 256L ) )
d127 1
a127 2
      cmap->get_index     = code_to_index0;
      cmap->get_next_char = code_to_next0;
d136 2
a137 2
      if ( FT_NEW_ARRAY( cmap2->subHeaderKeys, 256 ) ||
           FT_FRAME_ENTER( 2L + 512L )               )
d140 1
a140 1
      cmap2->language = FT_GET_USHORT();
d144 1
a144 1
        u = (FT_UShort)( FT_GET_USHORT() / 8 );
d151 1
a151 1
      FT_FRAME_EXIT();
d156 1
a156 1
        ( ( cmap->length - 2L * ( 256 + 3 ) - num_SH * 8L ) & 0xFFFFU ) / 2 );
d158 4
a161 2
      if ( FT_NEW_ARRAY( cmap2->subHeaders, num_SH + 1 ) ||
           FT_FRAME_ENTER( ( num_SH + 1 ) * 8L )         )
d163 1
a163 1
        FT_FREE( cmap2->subHeaderKeys );
d171 3
a173 3
        cmap2sub->firstCode     = FT_GET_USHORT();
        cmap2sub->entryCount    = FT_GET_USHORT();
        cmap2sub->idDelta       = FT_GET_SHORT();
d176 1
a176 1
          FT_GET_USHORT() - ( num_SH - i ) * 8 - 2 );
d181 1
a181 1
      FT_FRAME_EXIT();
d185 2
a186 2
      if ( FT_NEW_ARRAY( cmap2->glyphIdArray, l ) ||
           FT_FRAME_ENTER( l * 2L )               )
d188 2
a189 2
        FT_FREE( cmap2->subHeaders );
        FT_FREE( cmap2->subHeaderKeys );
d194 1
a194 1
        cmap2->glyphIdArray[i] = FT_GET_USHORT();
d196 1
a196 1
      FT_FRAME_EXIT();
a198 1
      cmap->get_next_char = code_to_next2;
d206 1
a206 1
      if ( FT_FRAME_ENTER( 10L ) )
d209 5
a213 5
      cmap4->language      = FT_GET_USHORT();
      cmap4->segCountX2    = FT_GET_USHORT();
      cmap4->searchRange   = FT_GET_USHORT();
      cmap4->entrySelector = FT_GET_USHORT();
      cmap4->rangeShift    = FT_GET_USHORT();
d217 1
a217 1
      FT_FRAME_EXIT();
d221 4
a224 2
      if ( FT_NEW_ARRAY( cmap4->segments, num_Seg )   ||
           FT_FRAME_ENTER( ( num_Seg * 4 + 1 ) * 2L ) )
d230 1
a230 1
        segments[i].endCount = FT_GET_USHORT();
d232 1
a232 1
      (void)FT_GET_USHORT();
d235 1
a235 1
        segments[i].startCount = FT_GET_USHORT();
d238 1
a238 1
        segments[i].idDelta = FT_GET_SHORT();
d241 1
a241 1
        segments[i].idRangeOffset = FT_GET_USHORT();
d243 1
a243 1
      FT_FRAME_EXIT();
d246 1
a246 1
        ( ( cmap->length - ( 16L + 8L * num_Seg ) ) & 0xFFFFU ) / 2 );
d250 2
a251 2
      if ( FT_NEW_ARRAY( cmap4->glyphIdArray, l ) ||
           FT_FRAME_ENTER( l * 2L )               )
d253 1
a253 1
        FT_FREE( cmap4->segments );
d258 1
a258 1
        cmap4->glyphIdArray[i] = FT_GET_USHORT();
d260 1
a260 1
      FT_FRAME_EXIT();
d264 1
a264 2
      cmap->get_index     = code_to_index4;
      cmap->get_next_char = code_to_next4;
d270 1
a270 1
      if ( FT_FRAME_ENTER( 6L ) )
d273 3
a275 3
      cmap6->language   = FT_GET_USHORT();
      cmap6->firstCode  = FT_GET_USHORT();
      cmap6->entryCount = FT_GET_USHORT();
d277 1
a277 1
      FT_FRAME_EXIT();
d281 2
a282 2
      if ( FT_NEW_ARRAY( cmap6->glyphIdArray, l ) ||
           FT_FRAME_ENTER( l * 2L )               )
d286 1
a286 1
        cmap6->glyphIdArray[i] = FT_GET_USHORT();
d288 2
a289 3
      FT_FRAME_EXIT();
      cmap->get_index     = code_to_index6;
      cmap->get_next_char = code_to_next6;
d296 1
a296 1
      if ( FT_FRAME_ENTER( 8L ) )
d299 2
a300 2
      cmap->length       = FT_GET_ULONG();
      cmap8_12->language = FT_GET_ULONG();
d302 1
a302 1
      FT_FRAME_EXIT();
d305 1
a305 1
        if ( FT_STREAM_SKIP( 8192L ) )
d308 1
a308 1
      if ( FT_READ_ULONG( cmap8_12->nGroups ) )
d313 2
a314 2
      if ( FT_NEW_ARRAY( cmap8_12->groups, n ) ||
           FT_FRAME_ENTER( n * 3 * 4L )        )
d321 3
a323 3
        groups[j].startCharCode = FT_GET_ULONG();
        groups[j].endCharCode   = FT_GET_ULONG();
        groups[j].startGlyphID  = FT_GET_ULONG();
d326 1
a326 1
      FT_FRAME_EXIT();
d330 1
a330 2
      cmap->get_index     = code_to_index8_12;
      cmap->get_next_char = code_to_next8_12;
d336 1
a336 1
      if ( FT_FRAME_ENTER( 16L ) )
d339 4
a342 4
      cmap->length          = FT_GET_ULONG();
      cmap10->language      = FT_GET_ULONG();
      cmap10->startCharCode = FT_GET_ULONG();
      cmap10->numChars      = FT_GET_ULONG();
d344 1
a344 1
      FT_FRAME_EXIT();
d348 2
a349 2
      if ( FT_NEW_ARRAY( cmap10->glyphs, n ) ||
           FT_FRAME_ENTER( n * 2L )          )
d353 1
a353 1
        cmap10->glyphs[j] = FT_GET_USHORT();
d355 2
a356 3
      FT_FRAME_EXIT();
      cmap->get_index     = code_to_index10;
      cmap->get_next_char = code_to_next10;
a381 1
  /*                                                                       */
d387 3
a389 3
  FT_LOCAL_DEF( FT_Error )
  TT_CharMap_Free( TT_Face       face,
                   TT_CMapTable  cmap )
d402 1
a402 1
      FT_FREE( cmap->c.cmap0.glyphIdArray );
d406 3
a408 3
      FT_FREE( cmap->c.cmap2.subHeaderKeys );
      FT_FREE( cmap->c.cmap2.subHeaders );
      FT_FREE( cmap->c.cmap2.glyphIdArray );
d412 2
a413 2
      FT_FREE( cmap->c.cmap4.segments );
      FT_FREE( cmap->c.cmap4.glyphIdArray );
d418 1
a418 1
      FT_FREE( cmap->c.cmap6.glyphIdArray );
d424 1
a424 1
      FT_FREE( cmap->c.cmap8_12.groups );
d429 1
a429 1
      FT_FREE( cmap->c.cmap10.glyphs );
a454 1
  /*                                                                       */
d461 2
a462 2
  code_to_index0( TT_CMapTable  cmap,
                  FT_ULong      charCode )
d464 1
a464 1
    TT_CMap0  cmap0 = &cmap->c.cmap0;
a473 32
  /*    code_to_next0                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Finds the next encoded character after the given one.  Uses        */
  /*    format 0. `charCode' must be in the range 0x00-0xFF (otherwise 0   */
  /*    is returned).                                                      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*                                                                       */
  /*    cmap0    :: A pointer to a cmap table in format 0.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Next char code.  0 if no higher one is encoded.                    */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_ULong )
  code_to_next0( TT_CMapTable  cmap,
                 FT_ULong      charCode )
  {
    TT_CMap0  cmap0 = &cmap->c.cmap0;


    while ( ++charCode <= 0xFF )
      if ( cmap0->glyphIdArray[charCode] )
        return ( charCode );
    return ( 0 );
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
a480 1
  /*                                                                       */
d487 2
a488 2
  code_to_index2( TT_CMapTable  cmap,
                  FT_ULong      charCode )
d490 5
a494 5
    FT_UInt            result, index1, offset;
    FT_UInt            char_lo;
    FT_ULong           char_hi;
    TT_CMap2SubHeader  sh2;
    TT_CMap2           cmap2;
d528 1
a528 1
          result = ( result + sh2->idDelta ) & 0xFFFFU;
a538 84
  /*    code_to_next2                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Find the next encoded character.  Uses format 2.                   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*                                                                       */
  /*    cmap2    :: A pointer to a cmap table in format 2.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Next encoded character.  0 if none exists.                         */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_ULong )
  code_to_next2( TT_CMapTable  cmap,
                 FT_ULong      charCode )
  {
    FT_UInt            index1, offset;
    FT_UInt            char_lo;
    FT_ULong           char_hi;
    TT_CMap2SubHeader  sh2;
    TT_CMap2           cmap2;


    cmap2 = &cmap->c.cmap2;
    charCode++;

    /*
     * This is relatively simplistic -- look for a subHeader containing
     * glyphs and then walk to the first glyph in that subHeader.
     */
    while ( charCode < 0x10000 )
    {
      char_lo = (FT_UInt)( charCode & 0xFF );
      char_hi = charCode >> 8;
  
      if ( char_hi == 0 )
      {
        /* an 8-bit character code -- we use the subHeader 0 in this case */
        /* to test whether the character code is in the charmap           */
        index1 = cmap2->subHeaderKeys[char_lo];
        if ( index1 != 0 )
        {
          charCode++;
          continue;
        }
      }
      else
      {
        /* a 16-bit character code */
        index1 = cmap2->subHeaderKeys[char_hi & 0xFF];
        if ( index1 == 0 )
        {
          charCode = ( char_hi + 1 ) << 8;
          continue;
        }
      }
  
      sh2      = cmap2->subHeaders + index1;
      char_lo -= sh2->firstCode;
  
      if ( char_lo > (FT_UInt)sh2->entryCount )
      {
        charCode = ( char_hi + 1 ) << 8;
        continue;
      }
      
      offset = sh2->idRangeOffset / 2 + char_lo;
      if ( offset >= (FT_UInt)cmap2->numGlyphId ||
           cmap2->glyphIdArray[offset] == 0     )
      {
        charCode++;
        continue;
      }
      
      return charCode;
    }
    return 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
a545 1
  /*                                                                       */
d552 2
a553 2
  code_to_index4( TT_CMapTable  cmap,
                  FT_ULong      charCode )
d555 3
a557 3
    FT_UInt             result, index1, segCount;
    TT_CMap4            cmap4;
    TT_CMap4SegmentRec  *seg4, *limit;
d602 1
a602 1
      result = ( charCode + seg4->idDelta ) & 0xFFFFU;
d613 1
a613 1
        result = ( cmap4->glyphIdArray[index1] + seg4->idDelta ) & 0xFFFFU;
a622 68
  /*    code_to_next4                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Find the next encoded character.  Uses format 4.                   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*                                                                       */
  /*    cmap     :: A pointer to a cmap table in format 4.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Next encoded character.  0 if none exists.                         */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_ULong )
  code_to_next4( TT_CMapTable  cmap,
                 FT_ULong      charCode )
  {
    FT_UInt             index1, segCount;
    TT_CMap4            cmap4;
    TT_CMap4SegmentRec  *seg4, *limit;


    cmap4    = &cmap->c.cmap4;
    segCount = cmap4->segCountX2 / 2;
    limit    = cmap4->segments + segCount;

    charCode++;

    for ( seg4 = cmap4->segments; seg4 < limit; seg4++ )
    {
      /* The ranges are sorted in increasing order.  If we are out of */
      /* the range here, the char code isn't in the charmap, so exit. */

      if ( charCode <= (FT_UInt)seg4->endCount )
        goto Found;
    }
    return 0;

  Found:
    if ( charCode < (FT_ULong) seg4->startCount )
      charCode = seg4->startCount;

    /* if the idRangeOffset is 0, all chars in the map exist */

    if ( seg4->idRangeOffset == 0 )
      return ( charCode );
    
    while ( charCode <= (FT_UInt) seg4->endCount )
    {
      /* otherwise, we must use the glyphIdArray to do it */
      index1 = (FT_UInt)( seg4->idRangeOffset / 2
                          + ( charCode - seg4->startCount )
                          + ( seg4 - cmap4->segments )
                          - segCount );

      if ( index1 < (FT_UInt)cmap4->numGlyphId &&
           cmap4->glyphIdArray[index1] != 0    )
        return ( charCode );
      charCode++;
    }

    return 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
a629 1
  /*                                                                       */
d636 2
a637 2
  code_to_index6( TT_CMapTable  cmap,
                  FT_ULong      charCode )
d639 2
a640 2
    TT_CMap6  cmap6;
    FT_UInt   result = 0;
a655 43
  /*    code_to_next6                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Find the next encoded character.  Uses format 6.                   */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*                                                                       */
  /*    cmap     :: A pointer to a cmap table in format 6.                 */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Next encoded character.  0 if none exists.                         */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_ULong )
  code_to_next6( TT_CMapTable  cmap,
                 FT_ULong      charCode )
  {
    TT_CMap6  cmap6;


    charCode++;
    
    cmap6 = &cmap->c.cmap6;
    
    if ( charCode < (FT_ULong) cmap6->firstCode )
      charCode = cmap6->firstCode;
    
    charCode -= cmap6->firstCode;

    while ( charCode < (FT_UInt)cmap6->entryCount )
    {
      if ( cmap6->glyphIdArray[charCode] != 0 )
        return charCode + cmap6->firstCode;
      charCode++;
    }

    return 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
a663 1
  /*                                                                       */
d670 2
a671 2
  code_to_index8_12( TT_CMapTable  cmap,
                     FT_ULong      charCode )
d673 2
a674 2
    TT_CMap8_12      cmap8_12;
    TT_CMapGroupRec  *group, *limit;
a720 46
  /*    code_to_next8_12                                                   */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Find the next encoded character.  Uses format 8 or 12.             */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*                                                                       */
  /*    cmap     :: A pointer to a cmap table in format 8 or 12.           */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Next encoded character.  0 if none exists.                         */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_ULong )
  code_to_next8_12( TT_CMapTable  cmap,
                    FT_ULong      charCode )
  {
    TT_CMap8_12      cmap8_12;
    TT_CMapGroupRec  *group, *limit;


    charCode++;
    cmap8_12 = &cmap->c.cmap8_12;
    limit    = cmap8_12->groups + cmap8_12->nGroups;

    for ( group = cmap8_12->groups; group < limit; group++ )
    {
      /* the ranges are sorted in increasing order.  If we are out of */
      /* the range here, the char code isn't in the charmap, so exit. */

      if ( charCode <= group->endCharCode )
        goto Found;
    }
    return 0;

  Found:
    if ( charCode < group->startCharCode )
      charCode = group->startCharCode;
    
    return charCode;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
a728 1
  /*                                                                       */
d735 2
a736 2
  code_to_index10( TT_CMapTable  cmap,
                   FT_ULong      charCode )
d738 2
a739 2
    TT_CMap10  cmap10;
    FT_UInt    result = 0;
a752 46
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    code_to_next10                                                     */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Find the next encoded character.  Uses format 10.                  */
  /*                                                                       */
  /* <Input>                                                               */
  /*    charCode :: The wanted character code.                             */
  /*                                                                       */
  /*    cmap     :: A pointer to a cmap table in format 10.                */
  /*                                                                       */
  /* <Return>                                                              */
  /*    Next encoded character.  0 if none exists.                         */
  /*                                                                       */
  FT_CALLBACK_DEF( FT_ULong )
  code_to_next10( TT_CMapTable  cmap,
                  FT_ULong      charCode )
  {
    TT_CMap10  cmap10;


    charCode++;
    cmap10 = &cmap->c.cmap10;
    
    if ( charCode < cmap10->startCharCode )
      charCode = cmap10->startCharCode;
    
    charCode -= cmap10->startCharCode;

    /* the overflow trick for comparison works here also since the number */
    /* of glyphs (even if numChars is specified as ULong in the specs) in */
    /* an OpenType font is limited to 64k                                 */

    while ( charCode < cmap10->numChars )
    {
      if ( cmap10->glyphs[charCode] )
        return ( charCode + cmap10->startCharCode );
      charCode++;
    }

    return 0;
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d89 1
a89 1
  /*    tt_face_load_charmap                                               */
d111 3
a113 3
  tt_face_load_charmap( TT_Face       face,
                        TT_CMapTable  cmap,
                        FT_Stream     stream )
d394 1
a394 1
    tt_face_free_charmap( face, cmap );
d402 1
a402 1
  /*    tt_face_free_charmap                                               */
d416 2
a417 2
  tt_face_free_charmap( TT_Face       face,
                        TT_CMapTable  cmap )
d632 1
a632 1
    while ( charCode < 0x10000L )
d636 1
a636 1

d658 1
a658 1

d661 1
a661 1

d667 1
a667 1

d675 1
a675 1

d749 1
a749 1
      result = (FT_UInt)( charCode + seg4->idDelta ) & 0xFFFFU;
d816 1
a816 1

d893 1
a893 1

d895 1
a895 1

d898 1
a898 1

d974 1
a974 2
    return (FT_UInt)( group->startGlyphID +
                      ( charCode - group->startCharCode ) );
d1019 1
a1019 1

d1088 1
a1088 1

d1091 1
a1091 1

@


