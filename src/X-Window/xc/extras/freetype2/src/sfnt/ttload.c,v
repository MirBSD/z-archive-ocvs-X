head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.29.54;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.01.23;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.01.23;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.21.07;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.39.10;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.09.12;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@/***************************************************************************/
/*                                                                         */
/*  ttload.c                                                               */
/*                                                                         */
/*    Load the basic TrueType tables, i.e., tables that can be either in   */
/*    TTF or OTF fonts (body).                                             */
/*                                                                         */
/*  Copyright 1996-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_INTERNAL_DEBUG_H
#include FT_INTERNAL_STREAM_H
#include FT_TRUETYPE_TAGS_H
#include "ttload.h"
#include "ttcmap.h"

#include "sferrors.h"

#include <stdlib.h>  /* for qsort */

  /*************************************************************************/
  /*                                                                       */
  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  /* messages during execution.                                            */
  /*                                                                       */
#undef  FT_COMPONENT
#define FT_COMPONENT  trace_ttload


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_LookUp_Table                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Looks for a TrueType table by name.                                */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A face object handle.                                      */
  /*    tag  :: The searched tag.                                          */
  /*                                                                       */
  /* <Return>                                                              */
  /*    A pointer to the table directory entry.  0 if not found.           */
  /*                                                                       */
  FT_LOCAL_DEF TT_Table*
  TT_LookUp_Table( TT_Face   face,
                   FT_ULong  tag  )
  {
    TT_Table*  entry;
    TT_Table*  limit;


    FT_TRACE3(( "TT_LookUp_Table: %08p, `%c%c%c%c' -- ",
                face,
                (FT_Char)( tag >> 24 ),
                (FT_Char)( tag >> 16 ),
                (FT_Char)( tag >> 8  ),
                (FT_Char)( tag       ) ));

    entry = face->dir_tables;
    limit = entry + face->num_tables;

    for ( ; entry < limit; entry++ )
    {
      if ( entry->Tag == tag )
      {
        FT_TRACE3(( "found table.\n" ));
        return entry;
      }
    }

    FT_TRACE3(( "could not find table!\n" ));
    return 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Goto_Table                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Looks for a TrueType table by name, then seek a stream to it.      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face   :: A face object handle.                                    */
  /*    tag    :: The searched tag.                                        */
  /*    stream :: The stream to seek when the table is found.              */
  /*                                                                       */
  /* <Output>                                                              */
  /*    length :: The length of the table if found, undefined otherwise.   */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_Goto_Table( TT_Face    face,
                 FT_ULong   tag,
                 FT_Stream  stream,
                 FT_ULong*  length )
  {
    TT_Table*  table;
    FT_Error   error;


    table = TT_LookUp_Table( face, tag );
    if ( table )
    {
      if ( length )
        *length = table->Length;

      if ( FILE_Seek( table->Offset ) )
       goto Exit;
    }
    else
      error = SFNT_Err_Table_Missing;

  Exit:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_SFNT_Header                                                */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads the header of a SFNT font file.  Supports collections.       */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face       :: A handle to the target face object.                  */
  /*    stream     :: The input stream.                                    */
  /*    face_index :: If the font is a collection, the number of the font  */
  /*                  in the collection, ignored otherwise.                */
  /*                                                                       */
  /* <Output>                                                              */
  /*    sfnt       :: The SFNT header.                                     */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The stream cursor must be at the font file's origin.               */
  /*                                                                       */
  /*    This function recognizes fonts embedded in a `TrueType collection' */
  /*                                                                       */
  /*    The header will be checked whether it is valid by looking at the   */
  /*    values of `search_range', `entry_selector', and `range_shift'.     */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_Load_SFNT_Header( TT_Face       face,
                       FT_Stream     stream,
                       FT_Long       face_index,
                       SFNT_Header*  sfnt )
  {
    FT_Error   error;
    FT_ULong   format_tag;
    FT_Memory  memory = stream->memory;

    const FT_Frame_Field  sfnt_header_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  SFNT_Header

      FT_FRAME_START( 8 ),
        FT_FRAME_USHORT( num_tables ),
        FT_FRAME_USHORT( search_range ),
        FT_FRAME_USHORT( entry_selector ),
        FT_FRAME_USHORT( range_shift ),
      FT_FRAME_END
    };

    const FT_Frame_Field  ttc_header_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  TTC_Header

      FT_FRAME_START( 8 ),
        FT_FRAME_LONG( version ),
        FT_FRAME_LONG( count   ),
      FT_FRAME_END };


    FT_TRACE2(( "TT_Load_SFNT_Header: %08p, %ld\n",
                face, face_index ));

    face->ttc_header.tag      = 0;
    face->ttc_header.version  = 0;
    face->ttc_header.count    = 0;

    face->num_tables = 0;

    /* first of all, read the first 4 bytes.  If it is `ttcf', then the */
    /* file is a TrueType collection, otherwise it can be any other     */
    /* kind of font.                                                    */
    if ( READ_ULong( format_tag ) )
      goto Exit;

    if ( format_tag == TTAG_ttcf )
    {
      FT_Int  n;


      FT_TRACE3(( "TT_Load_SFNT_Header: file is a collection\n" ));

      /* it's a TrueType collection, i.e. a file containing several */
      /* font files.  Read the font directory now                   */
      if ( READ_Fields( ttc_header_fields, &face->ttc_header ) )
        goto Exit;

      /* now read the offsets of each font in the file */
      if ( ALLOC_ARRAY( face->ttc_header.offsets,
                        face->ttc_header.count,
                        FT_ULong )                     ||
           ACCESS_Frame( face->ttc_header.count * 4L ) )
        goto Exit;

      for ( n = 0; n < face->ttc_header.count; n++ )
        face->ttc_header.offsets[n] = GET_ULong();

      FORGET_Frame();

      /* check face index */
      if ( face_index >= face->ttc_header.count )
      {
        error = SFNT_Err_Bad_Argument;
        goto Exit;
      }

      /* seek to the appropriate TrueType file, then read tag */
      if ( FILE_Seek( face->ttc_header.offsets[face_index] ) ||
           READ_Long( format_tag )                           )
        goto Exit;
    }

    /* the format tag was read, now check the rest of the header */
    sfnt->format_tag = format_tag;
    if ( READ_Fields( sfnt_header_fields, sfnt ) )
      goto Exit;

    /* now, check the values of `num_tables', `seach_range', etc. */
    {
      FT_UInt   num_tables     = sfnt->num_tables;
      FT_ULong  entry_selector = 1L << sfnt->entry_selector;


      /* IMPORTANT: Many fonts have an incorrect `search_range' value, so */
      /*            we only check the `entry_selector' correctness here.  */
      /*                                                                  */
      if ( num_tables == 0                  ||
           entry_selector > num_tables      ||
           entry_selector * 2 <= num_tables )
      {
        FT_TRACE2(( "TT_Load_SFNT_Header: file is not SFNT!\n" ));
        error = SFNT_Err_Unknown_File_Format;
      }
    }

  Exit:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_Directory                                                  */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads the table directory into a face object.                      */
  /*                                                                       */
  /* <InOut>                                                               */
  /*    face   :: A handle to the target face object.                      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    stream :: The input stream.                                        */
  /*    sfnt   :: The SFNT directory header.                               */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  /* <Note>                                                                */
  /*    The stream cursor must be at the font file's origin.               */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_Load_Directory( TT_Face       face,
                     FT_Stream     stream,
                     SFNT_Header*  sfnt )
  {
    FT_Error   error;
    FT_Memory  memory = stream->memory;

    TT_Table *entry, *limit;


    FT_TRACE2(( "TT_Load_Directory: %08p\n", face ));

    FT_TRACE2(( "-- Tables count:   %12u\n",  sfnt->num_tables ));
    FT_TRACE2(( "-- Format version: %08lx\n", sfnt->format_tag ));

    face->num_tables = sfnt->num_tables;

    if ( ALLOC_ARRAY( face->dir_tables,
                      face->num_tables,
                      TT_Table ) )
      goto Exit;

    if ( ACCESS_Frame( face->num_tables * 16L ) )
      goto Exit;

    entry = face->dir_tables;
    limit = entry + face->num_tables;

    for ( ; entry < limit; entry++ )
    {                    /* loop through the tables and get all entries */
      entry->Tag      = GET_Tag4();
      entry->CheckSum = GET_ULong();
      entry->Offset   = GET_Long();
      entry->Length   = GET_Long();

      FT_TRACE2(( "  %c%c%c%c  -  %08lx  -  %08lx\n",
                  (FT_Char)( entry->Tag >> 24 ),
                  (FT_Char)( entry->Tag >> 16 ),
                  (FT_Char)( entry->Tag >> 8  ),
                  (FT_Char)( entry->Tag       ),
                  entry->Offset,
                  entry->Length ));
    }

    FORGET_Frame();

    FT_TRACE2(( "Directory loaded\n\n" ));

  Exit:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_Any                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads any font table into client memory.                           */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face   :: The face object to look for.                             */
  /*                                                                       */
  /*    tag    :: The tag of table to load.  Use the value 0 if you want   */
  /*              to access the whole font file, else set this parameter   */
  /*              to a valid TrueType table tag that you can forge with    */
  /*              the MAKE_TT_TAG macro.                                   */
  /*                                                                       */
  /*    offset :: The starting offset in the table (or the file if         */
  /*              tag == 0).                                               */
  /*                                                                       */
  /*    length :: The address of the decision variable:                    */
  /*                                                                       */
  /*                If length == NULL:                                     */
  /*                  Loads the whole table.  Returns an error if          */
  /*                  `offset' == 0!                                       */
  /*                                                                       */
  /*                If *length == 0:                                       */
  /*                  Exits immediately; returning the length of the given */
  /*                  table or of the font file, depending on the value of */
  /*                  `tag'.                                               */
  /*                                                                       */
  /*                If *length != 0:                                       */
  /*                  Loads the next `length' bytes of table or font,      */
  /*                  starting at offset `offset' (in table or font too).  */
  /*                                                                       */
  /* <Output>                                                              */
  /*    buffer :: The address of target buffer.                            */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_Load_Any( TT_Face    face,
               FT_ULong   tag,
               FT_Long    offset,
               FT_Byte*   buffer,
               FT_ULong*  length )
  {
    FT_Error   error;
    FT_Stream  stream;
    TT_Table*  table;
    FT_ULong   size;


    if ( tag != 0 )
    {
      /* look for tag in font directory */
      table = TT_LookUp_Table( face, tag );
      if ( !table )
      {
        error = SFNT_Err_Table_Missing;
        goto Exit;
      }

      offset += table->Offset;
      size    = table->Length;
    }
    else
      /* tag == 0 -- the user wants to access the font file directly */
      size = face->root.stream->size;

    if ( length && *length == 0 )
    {
      *length = size;

      return SFNT_Err_Ok;
    }

    if ( length )
      size = *length;

    stream = face->root.stream;
    /* the `if' is syntactic sugar for picky compilers */
    if ( FILE_Read_At( offset, buffer, size ) )
      goto Exit;

  Exit:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_Generic_Header                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads the TrueType table `head' or `bhed'.                         */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face   :: A handle to the target face object.                      */
  /*    stream :: The input stream.                                        */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  static FT_Error
  TT_Load_Generic_Header( TT_Face    face,
                          FT_Stream  stream,
                          FT_ULong   tag )
  {
    FT_Error    error;
    TT_Header*  header;

    static const FT_Frame_Field  header_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  TT_Header

      FT_FRAME_START( 54 ),
        FT_FRAME_ULONG ( Table_Version ),
        FT_FRAME_ULONG ( Font_Revision ),
        FT_FRAME_LONG  ( CheckSum_Adjust ),
        FT_FRAME_LONG  ( Magic_Number ),
        FT_FRAME_USHORT( Flags ),
        FT_FRAME_USHORT( Units_Per_EM ),
        FT_FRAME_LONG  ( Created[0] ),
        FT_FRAME_LONG  ( Created[1] ),
        FT_FRAME_LONG  ( Modified[0] ),
        FT_FRAME_LONG  ( Modified[1] ),
        FT_FRAME_SHORT ( xMin ),
        FT_FRAME_SHORT ( yMin ),
        FT_FRAME_SHORT ( xMax ),
        FT_FRAME_SHORT ( yMax ),
        FT_FRAME_USHORT( Mac_Style ),
        FT_FRAME_USHORT( Lowest_Rec_PPEM ),
        FT_FRAME_SHORT ( Font_Direction ),
        FT_FRAME_SHORT ( Index_To_Loc_Format ),
        FT_FRAME_SHORT ( Glyph_Data_Format ),
      FT_FRAME_END
    };


    FT_TRACE2(( "TT_Load_Generic_Header: "
                "%08p, looking up font table `%c%c%c%c'.\n",
                face,
                (FT_Char)( tag >> 24 ),
                (FT_Char)( tag >> 16 ),
                (FT_Char)( tag >> 8  ),
                (FT_Char)( tag       ) ));

    error = face->goto_table( face, tag, stream, 0 );
    if ( error )
    {
      FT_TRACE2(( "TT_Load_Generic_Header: Font table is missing!\n" ));
      goto Exit;
    }

    header = &face->header;

    if ( READ_Fields( header_fields, header ) )
      goto Exit;

    FT_TRACE2(( "    Units per EM: %8u\n", header->Units_Per_EM ));
    FT_TRACE2(( "    IndexToLoc:   %8d\n", header->Index_To_Loc_Format ));
    FT_TRACE2(( "TT_Load_Generic_Header: Font table loaded.\n" ));

  Exit:
    return error;
  }


  FT_LOCAL_DEF FT_Error
  TT_Load_Header( TT_Face    face,
                  FT_Stream  stream )
  {
    return TT_Load_Generic_Header( face, stream, TTAG_head );
  }


#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS

  FT_LOCAL_DEF FT_Error
  TT_Load_Bitmap_Header( TT_Face    face,
                         FT_Stream  stream )
  {
    return TT_Load_Generic_Header( face, stream, TTAG_bhed );
  }

#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_MaxProfile                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads the maximum profile into a face object.                      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face   :: A handle to the target face object.                      */
  /*    stream :: The input stream.                                        */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_Load_MaxProfile( TT_Face    face,
                      FT_Stream  stream )
  {
    FT_Error        error;
    TT_MaxProfile*  maxProfile = &face->max_profile;

    const FT_Frame_Field  maxp_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  TT_MaxProfile

      FT_FRAME_START( 6 ),
        FT_FRAME_LONG  ( version ),
        FT_FRAME_USHORT( numGlyphs ),
      FT_FRAME_END
    };

    const FT_Frame_Field  maxp_fields_extra[] =
    {
      FT_FRAME_START( 26 ),
        FT_FRAME_USHORT( maxPoints ),
        FT_FRAME_USHORT( maxContours ),
        FT_FRAME_USHORT( maxCompositePoints ),
        FT_FRAME_USHORT( maxCompositeContours ),
        FT_FRAME_USHORT( maxZones ),
        FT_FRAME_USHORT( maxTwilightPoints ),
        FT_FRAME_USHORT( maxStorage ),
        FT_FRAME_USHORT( maxFunctionDefs ),
        FT_FRAME_USHORT( maxInstructionDefs ),
        FT_FRAME_USHORT( maxStackElements ),
        FT_FRAME_USHORT( maxSizeOfInstructions ),
        FT_FRAME_USHORT( maxComponentElements ),
        FT_FRAME_USHORT( maxComponentDepth ),
      FT_FRAME_END
    };


    FT_TRACE2(( "Load_TT_MaxProfile: %08p\n", face ));

    error = face->goto_table( face, TTAG_maxp, stream, 0 );
    if ( error )
      goto Exit;

    if ( READ_Fields( maxp_fields, maxProfile ) )
      goto Exit;

    maxProfile->maxPoints             = 0;
    maxProfile->maxContours           = 0;
    maxProfile->maxCompositePoints    = 0;
    maxProfile->maxCompositeContours  = 0;
    maxProfile->maxZones              = 0;
    maxProfile->maxTwilightPoints     = 0;
    maxProfile->maxStorage            = 0;
    maxProfile->maxFunctionDefs       = 0;
    maxProfile->maxInstructionDefs    = 0;
    maxProfile->maxStackElements      = 0;
    maxProfile->maxSizeOfInstructions = 0;
    maxProfile->maxComponentElements  = 0;
    maxProfile->maxComponentDepth     = 0;

    if ( maxProfile->version >= 0x10000L )
    {
      if ( READ_Fields( maxp_fields_extra, maxProfile ) )
        goto Exit;

      /* XXX: an adjustment that is necessary to load certain */
      /*      broken fonts like `Keystrokes MT' :-(           */
      /*                                                      */
      /*   We allocate 64 function entries by default when    */
      /*   the maxFunctionDefs field is null.                 */

      if ( maxProfile->maxFunctionDefs == 0 )
        maxProfile->maxFunctionDefs = 64;

      face->root.num_glyphs = maxProfile->numGlyphs;

      face->root.internal->max_points =
        (FT_UShort)MAX( maxProfile->maxCompositePoints,
                        maxProfile->maxPoints );

      face->root.internal->max_contours =
        (FT_Short)MAX( maxProfile->maxCompositeContours,
                       maxProfile->maxContours );

      face->max_components = (FT_ULong)maxProfile->maxComponentElements +
                             maxProfile->maxComponentDepth;

      /* XXX: some fonts have maxComponents set to 0; we will */
      /*      then use 16 of them by default.                 */
      if ( face->max_components == 0 )
        face->max_components = 16;

      /* We also increase maxPoints and maxContours in order to support */
      /* some broken fonts.                                             */
      face->root.internal->max_points   += (FT_UShort) 8;
      face->root.internal->max_contours += (FT_Short)  4;
    }

    FT_TRACE2(( "MAXP loaded.\n" ));

  Exit:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_Metrics                                                    */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads the horizontal or vertical metrics table into a face object. */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face     :: A handle to the target face object.                    */
  /*    stream   :: The input stream.                                      */
  /*    vertical :: A boolean flag.  If set, load vertical metrics.        */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  static FT_Error
  TT_Load_Metrics( TT_Face    face,
                   FT_Stream  stream,
                   FT_Bool    vertical )
  {
    FT_Error   error;
    FT_Memory  memory = stream->memory;

    FT_ULong   table_len;
    FT_Long    num_shorts, num_longs, num_shorts_checked;

    TT_LongMetrics**   longs;
    TT_ShortMetrics**  shorts;


    FT_TRACE2(( "TT_Load_%s_Metrics: %08p\n", vertical ? "Vertical"
                                                       : "Horizontal",
                                              face ));

    if ( vertical )
    {
      /* The table is optional, quit silently if it wasn't found       */
      /* XXX: Some fonts have a valid vertical header with a non-null  */
      /*      `number_of_VMetrics' fields, but no corresponding `vmtx' */
      /*      table to get the metrics from (e.g. mingliu).            */
      /*                                                               */
      /*      For safety, we set the field to 0!                       */
      /*                                                               */
      error = face->goto_table( face, TTAG_vmtx, stream, &table_len );
      if ( error )
      {
        /* Set number_Of_VMetrics to 0! */
        FT_TRACE2(( "  no vertical header in file.\n" ));
        face->vertical.number_Of_VMetrics = 0;
        error = SFNT_Err_Ok;
        goto Exit;
      }

      num_longs = face->vertical.number_Of_VMetrics;
      longs     = (TT_LongMetrics**)&face->vertical.long_metrics;
      shorts    = (TT_ShortMetrics**)&face->vertical.short_metrics;
    }
    else
    {
      error = face->goto_table( face, TTAG_hmtx, stream, &table_len );
      if ( error )
      {
        FT_ERROR(( " no horizontal metrics in file!\n" ));
        error = SFNT_Err_Hmtx_Table_Missing;
        goto Exit;
      }

      num_longs = face->horizontal.number_Of_HMetrics;
      longs     = (TT_LongMetrics**)&face->horizontal.long_metrics;
      shorts    = (TT_ShortMetrics**)&face->horizontal.short_metrics;
    }

    /* never trust derived values */

    num_shorts         = face->max_profile.numGlyphs - num_longs;
    num_shorts_checked = ( table_len - num_longs * 4L ) / 2;

    if ( num_shorts < 0 )
    {
      FT_ERROR(( "TT_Load_%s_Metrics: more metrics than glyphs!\n",
                 vertical ? "Vertical"
                          : "Horizontal" ));

      error = vertical ? SFNT_Err_Invalid_Vert_Metrics
                       : SFNT_Err_Invalid_Horiz_Metrics;
      goto Exit;
    }

    if ( ALLOC_ARRAY( *longs,  num_longs,  TT_LongMetrics )  ||
         ALLOC_ARRAY( *shorts, num_shorts, TT_ShortMetrics ) )
      goto Exit;

    if ( ACCESS_Frame( table_len ) )
      goto Exit;

    {
      TT_LongMetrics*  cur   = *longs;
      TT_LongMetrics*  limit = cur + num_longs;


      for ( ; cur < limit; cur++ )
      {
        cur->advance = GET_UShort();
        cur->bearing = GET_Short();
      }
    }

    /* do we have an inconsistent number of metric values? */
    {
      TT_ShortMetrics*  cur   = *shorts;
      TT_ShortMetrics*  limit = cur + MIN( num_shorts, num_shorts_checked );


      for ( ; cur < limit; cur++ )
        *cur = GET_Short();

      /* we fill up the missing left side bearings with the     */
      /* last valid value.  Since this will occur for buggy CJK */
      /* fonts usually only, nothing serious will happen        */
      if ( num_shorts > num_shorts_checked && num_shorts_checked > 0 )
      {
        FT_Short  val = (*shorts)[num_shorts_checked - 1];


        limit = *shorts + num_shorts;
        for ( ; cur < limit; cur++ )
          *cur = val;
      }
    }

    FORGET_Frame();

    FT_TRACE2(( "loaded\n" ));

  Exit:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_Metrics_Header                                             */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads the horizontal or vertical header in a face object.          */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face     :: A handle to the target face object.                    */
  /*    stream   :: The input stream.                                      */
  /*    vertical :: A boolean flag.  If set, load vertical metrics.        */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_Load_Metrics_Header( TT_Face    face,
                          FT_Stream  stream,
                          FT_Bool    vertical )
  {
    FT_Error        error;
    TT_HoriHeader*  header;

    const FT_Frame_Field  metrics_header_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  TT_HoriHeader

      FT_FRAME_START( 36 ),
        FT_FRAME_ULONG ( Version ),
        FT_FRAME_SHORT ( Ascender ),
        FT_FRAME_SHORT ( Descender ),
        FT_FRAME_SHORT ( Line_Gap ),
        FT_FRAME_USHORT( advance_Width_Max ),
        FT_FRAME_SHORT ( min_Left_Side_Bearing ),
        FT_FRAME_SHORT ( min_Right_Side_Bearing ),
        FT_FRAME_SHORT ( xMax_Extent ),
        FT_FRAME_SHORT ( caret_Slope_Rise ),
        FT_FRAME_SHORT ( caret_Slope_Run ),
        FT_FRAME_SHORT ( caret_Offset ),
        FT_FRAME_SHORT ( Reserved[0] ),
        FT_FRAME_SHORT ( Reserved[1] ),
        FT_FRAME_SHORT ( Reserved[2] ),
        FT_FRAME_SHORT ( Reserved[3] ),
        FT_FRAME_SHORT ( metric_Data_Format ),
        FT_FRAME_USHORT( number_Of_HMetrics ),
      FT_FRAME_END
    };


    FT_TRACE2(( vertical ? "Vertical header " : "Horizontal header " ));

    if ( vertical )
    {
      face->vertical_info = 0;

      /* The vertical header table is optional, so return quietly if */
      /* we don't find it.                                           */
      error = face->goto_table( face, TTAG_vhea, stream, 0 );
      if ( error )
      {
        error = SFNT_Err_Ok;
        goto Exit;
      }

      face->vertical_info = 1;
      header = (TT_HoriHeader*)&face->vertical;
    }
    else
    {
      /* The horizontal header is mandatory; return an error if we */
      /* don't find it.                                            */
      error = face->goto_table( face, TTAG_hhea, stream, 0 );
      if ( error )
      {
        error = SFNT_Err_Horiz_Header_Missing;
        goto Exit;
      }

      header = &face->horizontal;
    }

    if ( READ_Fields( metrics_header_fields, header ) )
      goto Exit;

    header->long_metrics  = NULL;
    header->short_metrics = NULL;

    FT_TRACE2(( "loaded\n" ));

    /* Now try to load the corresponding metrics */

    error = TT_Load_Metrics( face, stream, vertical );

  Exit:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_Names                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads the name records.                                            */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face   :: A handle to the target face object.                      */
  /*    stream :: The input stream.                                        */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_Load_Names( TT_Face    face,
                 FT_Stream  stream )
  {
    FT_Error   error;
    FT_Memory  memory = stream->memory;

    FT_ULong   table_pos, table_len;
    FT_ULong   storageSize;

    TT_NameTable*  names;

    const FT_Frame_Field  name_table_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  TT_NameTable

      FT_FRAME_START( 6 ),
        FT_FRAME_USHORT( format ),
        FT_FRAME_USHORT( numNameRecords ),
        FT_FRAME_USHORT( storageOffset ),
      FT_FRAME_END
    };

    const FT_Frame_Field  name_record_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  TT_NameRec

      /* no FT_FRAME_START */
        FT_FRAME_USHORT( platformID ),
        FT_FRAME_USHORT( encodingID ),
        FT_FRAME_USHORT( languageID ),
        FT_FRAME_USHORT( nameID ),
        FT_FRAME_USHORT( stringLength ),
        FT_FRAME_USHORT( stringOffset ),
      FT_FRAME_END
    };


    FT_TRACE2(( "Names " ));

    error = face->goto_table( face, TTAG_name, stream, &table_len );
    if ( error )
    {
      /* The name table is required so indicate failure. */
      FT_TRACE2(( "is missing!\n" ));
      error = SFNT_Err_Name_Table_Missing;
      goto Exit;
    }

    table_pos = FILE_Pos();

    names = &face->name_table;

    if ( READ_Fields( name_table_fields, names ) )
      goto Exit;

    /* Allocate the array of name records. */
    if ( ALLOC_ARRAY( names->names,
                      names->numNameRecords,
                      TT_NameRec )                   ||
         ACCESS_Frame( names->numNameRecords * 12L ) )
      goto Exit;

    /* Load the name records and determine how much storage is needed */
    /* to hold the strings themselves.                                */
    {
      TT_NameRec*  cur   = names->names;
      TT_NameRec*  limit = cur + names->numNameRecords;


      storageSize = 0;

      for ( ; cur < limit; cur ++ )
      {
        FT_ULong  upper;


        if ( READ_Fields( name_record_fields, cur ) )
          break;

        upper = (FT_ULong)( cur->stringOffset + cur->stringLength );
        if ( upper > storageSize )
          storageSize = upper;
      }
    }

    FORGET_Frame();

    if ( storageSize > 0 )
    {
      /* allocate the name storage area in memory, then read it */
      if ( ALLOC( names->storage, storageSize )               ||
           FILE_Read_At( table_pos + names->storageOffset,
                         names->storage, storageSize ) )
        goto Exit;

      /* Go through and assign the string pointers to the name records. */
      {
        TT_NameRec*  cur   = names->names;
        TT_NameRec*  limit = cur + names->numNameRecords;


        for ( ; cur < limit; cur++ )
          cur->string = names->storage + cur->stringOffset;
      }

#ifdef FT_DEBUG_LEVEL_TRACE

      /* Print Name Record Table in case of debugging */
      {
        TT_NameRec*  cur   = names->names;
        TT_NameRec*  limit = cur + names->numNameRecords;


        for ( ; cur < limit; cur++ )
        {
          FT_UInt  j;


          FT_TRACE3(( "%d %d %x %d\n  ",
                       cur->platformID,
                       cur->encodingID,
                       cur->languageID,
                       cur->nameID ));

          /* I know that M$ encoded strings are Unicode,            */
          /* but this works reasonable well for debugging purposes. */
          if ( cur->string )
            for ( j = 0; j < (FT_UInt)cur->stringLength; j++ )
            {
              FT_Char  c = *( cur->string + j );


              if ( (FT_Byte)c < 128 )
                FT_TRACE3(( "%c", c ));
            }
        }
      }
      FT_TRACE3(( "\n" ));

#endif /* FT_DEBUG_LEVEL_TRACE */

    }
    FT_TRACE2(( "loaded\n" ));

    /* everything went well, update face->num_names */
    face->num_names = names->numNameRecords;

  Exit:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Free_Names                                                      */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Frees the name records.                                            */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A handle to the target face object.                        */
  /*                                                                       */
  FT_LOCAL_DEF void
  TT_Free_Names( TT_Face  face )
  {
    FT_Memory      memory = face->root.driver->root.memory;
    TT_NameTable*  names  = &face->name_table;


    /* free strings table */
    FREE( names->names );

    /* free strings storage */
    FREE( names->storage );

    names->numNameRecords = 0;
    names->format         = 0;
    names->storageOffset  = 0;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_CMap                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads the cmap directory in a face object.  The cmaps itselves are */
  /*    loaded on demand in the `ttcmap.c' module.                         */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face   :: A handle to the target face object.                      */
  /*    stream :: A handle to the input stream.                            */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_Load_CMap( TT_Face    face,
                FT_Stream  stream )
  {
    FT_Error    error;
    FT_Memory   memory = stream->memory;
    FT_Long     table_start;
    TT_CMapDir  cmap_dir;

    const FT_Frame_Field  cmap_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  TT_CMapDir

      FT_FRAME_START( 4 ),
        FT_FRAME_USHORT( tableVersionNumber ),
        FT_FRAME_USHORT( numCMaps ),
      FT_FRAME_END
    };

    const FT_Frame_Field  cmap_rec_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  TT_CMapTable

      FT_FRAME_START( 4 ),
        FT_FRAME_USHORT( format ),
        FT_FRAME_USHORT( length ),
      FT_FRAME_END
    };


    FT_TRACE2(( "CMaps " ));

    error = face->goto_table( face, TTAG_cmap, stream, 0 );
    if ( error )
    {
      error = SFNT_Err_CMap_Table_Missing;
      goto Exit;
    }

    table_start = FILE_Pos();

    if ( READ_Fields( cmap_fields, &cmap_dir ) )
      goto Exit;

    /* reserve space in face table for cmap tables */
    if ( ALLOC_ARRAY( face->charmaps,
                      cmap_dir.numCMaps,
                      TT_CharMapRec ) )
      goto Exit;

    face->num_charmaps = cmap_dir.numCMaps;
    {
      TT_CharMap  charmap = face->charmaps;
      TT_CharMap  limit   = charmap + face->num_charmaps;


      /* read the header of each charmap first */
      if ( ACCESS_Frame( face->num_charmaps * 8L ) )
        goto Exit;

      for ( ; charmap < limit; charmap++ )
      {
        TT_CMapTable*  cmap;


        charmap->root.face = (FT_Face)face;
        cmap               = &charmap->cmap;

        cmap->loaded             = FALSE;
        cmap->platformID         = GET_UShort();
        cmap->platformEncodingID = GET_UShort();
        cmap->offset             = (FT_ULong)GET_Long();
      }

      FORGET_Frame();

      /* now read the rest of each table */
      for ( charmap = face->charmaps; charmap < limit; charmap++ )
      {
        TT_CMapTable* cmap = &charmap->cmap;


        if ( FILE_Seek( table_start + (FT_Long)cmap->offset ) ||
             READ_Fields( cmap_rec_fields, cmap )             )
          goto Exit;

        cmap->offset = FILE_Pos();
      }
    }

    FT_TRACE2(( "loaded\n" ));

  Exit:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_OS2                                                        */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads the OS2 table.                                               */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face   :: A handle to the target face object.                      */
  /*    stream :: A handle to the input stream.                            */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_Load_OS2( TT_Face    face,
               FT_Stream  stream )
  {
    FT_Error  error;
    TT_OS2*   os2;

    const FT_Frame_Field  os2_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  TT_OS2

      FT_FRAME_START( 78 ),
        FT_FRAME_USHORT( version ),
        FT_FRAME_SHORT ( xAvgCharWidth ),
        FT_FRAME_USHORT( usWeightClass ),
        FT_FRAME_USHORT( usWidthClass ),
        FT_FRAME_SHORT ( fsType ),
        FT_FRAME_SHORT ( ySubscriptXSize ),
        FT_FRAME_SHORT ( ySubscriptYSize ),
        FT_FRAME_SHORT ( ySubscriptXOffset ),
        FT_FRAME_SHORT ( ySubscriptYOffset ),
        FT_FRAME_SHORT ( ySuperscriptXSize ),
        FT_FRAME_SHORT ( ySuperscriptYSize ),
        FT_FRAME_SHORT ( ySuperscriptXOffset ),
        FT_FRAME_SHORT ( ySuperscriptYOffset ),
        FT_FRAME_SHORT ( yStrikeoutSize ),
        FT_FRAME_SHORT ( yStrikeoutPosition ),
        FT_FRAME_SHORT ( sFamilyClass ),
        FT_FRAME_BYTE  ( panose[0] ),
        FT_FRAME_BYTE  ( panose[1] ),
        FT_FRAME_BYTE  ( panose[2] ),
        FT_FRAME_BYTE  ( panose[3] ),
        FT_FRAME_BYTE  ( panose[4] ),
        FT_FRAME_BYTE  ( panose[5] ),
        FT_FRAME_BYTE  ( panose[6] ),
        FT_FRAME_BYTE  ( panose[7] ),
        FT_FRAME_BYTE  ( panose[8] ),
        FT_FRAME_BYTE  ( panose[9] ),
        FT_FRAME_ULONG ( ulUnicodeRange1 ),
        FT_FRAME_ULONG ( ulUnicodeRange2 ),
        FT_FRAME_ULONG ( ulUnicodeRange3 ),
        FT_FRAME_ULONG ( ulUnicodeRange4 ),
        FT_FRAME_BYTE  ( achVendID[0] ),
        FT_FRAME_BYTE  ( achVendID[1] ),
        FT_FRAME_BYTE  ( achVendID[2] ),
        FT_FRAME_BYTE  ( achVendID[3] ),

        FT_FRAME_USHORT( fsSelection ),
        FT_FRAME_USHORT( usFirstCharIndex ),
        FT_FRAME_USHORT( usLastCharIndex ),
        FT_FRAME_SHORT ( sTypoAscender ),
        FT_FRAME_SHORT ( sTypoDescender ),
        FT_FRAME_SHORT ( sTypoLineGap ),
        FT_FRAME_USHORT( usWinAscent ),
        FT_FRAME_USHORT( usWinDescent ),
      FT_FRAME_END
    };

    const FT_Frame_Field  os2_fields_extra[] =
    {
      FT_FRAME_START( 8 ),
        FT_FRAME_ULONG( ulCodePageRange1 ),
        FT_FRAME_ULONG( ulCodePageRange2 ),
      FT_FRAME_END
    };

    const FT_Frame_Field  os2_fields_extra2[] =
    {
      FT_FRAME_START( 10 ),
        FT_FRAME_SHORT ( sxHeight ),
        FT_FRAME_SHORT ( sCapHeight ),
        FT_FRAME_USHORT( usDefaultChar ),
        FT_FRAME_USHORT( usBreakChar ),
        FT_FRAME_USHORT( usMaxContext ),
      FT_FRAME_END
    };


    FT_TRACE2(( "OS/2 Table " ));

    /* We now support old Mac fonts where the OS/2 table doesn't  */
    /* exist.  Simply put, we set the `version' field to 0xFFFF   */
    /* and test this value each time we need to access the table. */
    error = face->goto_table( face, TTAG_OS2, stream, 0 );
    if ( error )
    {
      FT_TRACE2(( "is missing!\n" ));
      face->os2.version = 0xFFFF;
      error = SFNT_Err_Ok;
      goto Exit;
    }

    os2 = &face->os2;

    if ( READ_Fields( os2_fields, os2 ) )
      goto Exit;

    os2->ulCodePageRange1 = 0;
    os2->ulCodePageRange2 = 0;
    os2->sxHeight         = 0;
    os2->sCapHeight       = 0;
    os2->usDefaultChar    = 0;
    os2->usBreakChar      = 0;
    os2->usMaxContext     = 0;

    if ( os2->version >= 0x0001 )
    {
      /* only version 1 tables */
      if ( READ_Fields( os2_fields_extra, os2 ) )
        goto Exit;

      if ( os2->version >= 0x0002 )
      {
        /* only version 2 tables */
        if ( READ_Fields( os2_fields_extra2, os2 ) )
          goto Exit;
      }
    }

    FT_TRACE2(( "loaded\n" ));

  Exit:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_Postscript                                                 */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads the Postscript table.                                        */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face   :: A handle to the target face object.                      */
  /*    stream :: A handle to the input stream.                            */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_Load_PostScript( TT_Face    face,
                      FT_Stream  stream )
  {
    FT_Error        error;
    TT_Postscript*  post = &face->postscript;

    static const FT_Frame_Field  post_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  TT_Postscript

      FT_FRAME_START( 32 ),
        FT_FRAME_ULONG( FormatType ),
        FT_FRAME_ULONG( italicAngle ),
        FT_FRAME_SHORT( underlinePosition ),
        FT_FRAME_SHORT( underlineThickness ),
        FT_FRAME_ULONG( isFixedPitch ),
        FT_FRAME_ULONG( minMemType42 ),
        FT_FRAME_ULONG( maxMemType42 ),
        FT_FRAME_ULONG( minMemType1 ),
        FT_FRAME_ULONG( maxMemType1 ),
      FT_FRAME_END
    };


    FT_TRACE2(( "PostScript " ));

    error = face->goto_table( face, TTAG_post, stream, 0 );
    if ( error )
      return SFNT_Err_Post_Table_Missing;

    if ( READ_Fields( post_fields, post ) )
      return error;

    /* we don't load the glyph names, we do that in another */
    /* module (ttpost).                                     */
    FT_TRACE2(( "loaded\n" ));

    return SFNT_Err_Ok;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_PCLT                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads the PCL 5 Table.                                             */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face   :: A handle to the target face object.                      */
  /*    stream :: A handle to the input stream.                            */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_Load_PCLT( TT_Face    face,
                FT_Stream  stream )
  {
    static const FT_Frame_Field  pclt_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  TT_PCLT

      FT_FRAME_START( 54 ),
        FT_FRAME_ULONG ( Version ),
        FT_FRAME_ULONG ( FontNumber ),
        FT_FRAME_USHORT( Pitch ),
        FT_FRAME_USHORT( xHeight ),
        FT_FRAME_USHORT( Style ),
        FT_FRAME_USHORT( TypeFamily ),
        FT_FRAME_USHORT( CapHeight ),
        FT_FRAME_BYTES ( TypeFace, 16 ),
        FT_FRAME_BYTES ( CharacterComplement, 8 ),
        FT_FRAME_BYTES ( FileName, 6 ),
        FT_FRAME_CHAR  ( StrokeWeight ),
        FT_FRAME_CHAR  ( WidthType ),
        FT_FRAME_BYTE  ( SerifStyle ),
        FT_FRAME_BYTE  ( Reserved ),
      FT_FRAME_END
    };

    FT_Error  error;
    TT_PCLT*  pclt = &face->pclt;


    FT_TRACE2(( "PCLT " ));

    /* optional table */
    error = face->goto_table( face, TTAG_PCLT, stream, 0 );
    if ( error )
    {
      FT_TRACE2(( "missing (optional)\n" ));
      pclt->Version = 0;
      return SFNT_Err_Ok;
    }

    if ( READ_Fields( pclt_fields, pclt ) )
      goto Exit;

    FT_TRACE2(( "loaded\n" ));

  Exit:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_Gasp                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads the `gasp' table into a face object.                         */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face   :: A handle to the target face object.                      */
  /*    stream :: The input stream.                                        */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_Load_Gasp( TT_Face    face,
                FT_Stream  stream )
  {
    FT_Error   error;
    FT_Memory  memory = stream->memory;

    FT_UInt        j,num_ranges;
    TT_GaspRange*  gaspranges;


    FT_TRACE2(( "TT_Load_Gasp: %08p\n", face ));

    /* the gasp table is optional */
    error = face->goto_table( face, TTAG_gasp, stream, 0 );
    if ( error )
      return SFNT_Err_Ok;

    if ( ACCESS_Frame( 4L ) )
      goto Exit;

    face->gasp.version   = GET_UShort();
    face->gasp.numRanges = GET_UShort();

    FORGET_Frame();

    num_ranges = face->gasp.numRanges;
    FT_TRACE3(( "number of ranges = %d\n", num_ranges ));

    if ( ALLOC_ARRAY( gaspranges, num_ranges, TT_GaspRange ) ||
         ACCESS_Frame( num_ranges * 4L )                     )
      goto Exit;

    face->gasp.gaspRanges = gaspranges;

    for ( j = 0; j < num_ranges; j++ )
    {
      gaspranges[j].maxPPEM  = GET_UShort();
      gaspranges[j].gaspFlag = GET_UShort();

      FT_TRACE3(( " [max:%d flag:%d]",
                    gaspranges[j].maxPPEM,
                    gaspranges[j].gaspFlag ));
    }
    FT_TRACE3(( "\n" ));

    FORGET_Frame();
    FT_TRACE2(( "GASP loaded\n" ));

  Exit:
    return error;
  }


  FT_CALLBACK_DEF( int )
  tt_kern_pair_compare( const void*  a,
                        const void*  b );


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_Kern                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads the first kerning table with format 0 in the font.  Only     */
  /*    accepts the first horizontal kerning table.  Developers should use */
  /*    the `ftxkern' extension to access other kerning tables in the font */
  /*    file, if they really want to.                                      */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face   :: A handle to the target face object.                      */
  /*    stream :: The input stream.                                        */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_Load_Kern( TT_Face    face,
                FT_Stream  stream )
  {
    FT_Error   error;
    FT_Memory  memory = stream->memory;

    FT_UInt    n, num_tables;


    /* the kern table is optional; exit silently if it is missing */
    error = face->goto_table( face, TTAG_kern, stream, 0 );
    if ( error )
      return SFNT_Err_Ok;

    if ( ACCESS_Frame( 4L ) )
      goto Exit;

    (void)GET_UShort();         /* version */
    num_tables = GET_UShort();

    FORGET_Frame();

    for ( n = 0; n < num_tables; n++ )
    {
      FT_UInt  coverage;
      FT_UInt  length;


      if ( ACCESS_Frame( 6L ) )
        goto Exit;

      (void)GET_UShort();           /* version                 */
      length   = GET_UShort() - 6;  /* substract header length */
      coverage = GET_UShort();

      FORGET_Frame();

      if ( coverage == 0x0001 )
      {
        FT_UInt          num_pairs;
        TT_Kern_0_Pair*  pair;
        TT_Kern_0_Pair*  limit;


        /* found a horizontal format 0 kerning table! */
        if ( ACCESS_Frame( 8L ) )
          goto Exit;

        num_pairs = GET_UShort();

        /* skip the rest */

        FORGET_Frame();

        /* allocate array of kerning pairs */
        if ( ALLOC_ARRAY( face->kern_pairs, num_pairs, TT_Kern_0_Pair ) ||
             ACCESS_Frame( 6L * num_pairs )                             )
          goto Exit;

        pair  = face->kern_pairs;
        limit = pair + num_pairs;
        for ( ; pair < limit; pair++ )
        {
          pair->left  = GET_UShort();
          pair->right = GET_UShort();
          pair->value = GET_UShort();
        }

        FORGET_Frame();

        face->num_kern_pairs   = num_pairs;
        face->kern_table_index = n;

        /* ensure that the kerning pair table is sorted (yes, some */
        /* fonts have unsorted tables!)                            */
        {
          FT_UInt          i;
          TT_Kern_0_Pair*  pair0;


          pair0 = face->kern_pairs;

          for ( i = 1; i < num_pairs; i++, pair0++ )
          {
            if ( tt_kern_pair_compare( pair0, pair0 + 1 ) != -1 )
            {
              qsort( (void*)face->kern_pairs, (int)num_pairs,
                     sizeof ( TT_Kern_0_Pair ), tt_kern_pair_compare );
              break;
            }
          }
        }

        goto Exit;
      }

      if ( FILE_Skip( length ) )
        goto Exit;
    }

    /* no kern table found -- doesn't matter */
    face->kern_table_index = -1;
    face->num_kern_pairs   = 0;
    face->kern_pairs       = NULL;

  Exit:
    return error;
  }


#undef  TT_KERN_INDEX
#define TT_KERN_INDEX( g1, g2 )  ( ( (FT_ULong)g1 << 16 ) | g2 )

  FT_CALLBACK_DEF( int )
  tt_kern_pair_compare( const void*  a,
                        const void*  b )
  {
    TT_Kern_0_Pair*  pair1 = (TT_Kern_0_Pair*)a;
    TT_Kern_0_Pair*  pair2 = (TT_Kern_0_Pair*)b;

    FT_ULong  index1 = TT_KERN_INDEX( pair1->left, pair1->right );
    FT_ULong  index2 = TT_KERN_INDEX( pair2->left, pair2->right );


    return ( index1 < index2 ? -1 :
           ( index1 > index2 ?  1 : 0 ));
  }

#undef TT_KERN_INDEX


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Load_Hdmx                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Loads the horizontal device metrics table.                         */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face   :: A handle to the target face object.                      */
  /*    stream :: A handle to the input stream.                            */
  /*                                                                       */
  /* <Return>                                                              */
  /*    FreeType error code.  0 means success.                             */
  /*                                                                       */
  FT_LOCAL_DEF FT_Error
  TT_Load_Hdmx( TT_Face    face,
                FT_Stream  stream )
  {
    FT_Error  error;
    FT_Memory memory = stream->memory;

    TT_Hdmx*  hdmx = &face->hdmx;
    FT_Long   num_glyphs;
    FT_Long   record_size;


    hdmx->version     = 0;
    hdmx->num_records = 0;
    hdmx->records     = 0;

    /* this table is optional */
    error = face->goto_table( face, TTAG_hdmx, stream, 0 );
    if ( error )
      return SFNT_Err_Ok;

    if ( ACCESS_Frame( 8L ) )
      goto Exit;

    hdmx->version     = GET_UShort();
    hdmx->num_records = GET_Short();
    record_size       = GET_Long();

    FORGET_Frame();

    /* Only recognize format 0 */
    if ( hdmx->version != 0 )
      goto Exit;

    if ( ALLOC_ARRAY( hdmx->records, hdmx->num_records, TT_HdmxRec ) )
      goto Exit;

    num_glyphs   = face->root.num_glyphs;
    record_size -= num_glyphs + 2;

    {
      TT_HdmxRec*  cur   = hdmx->records;
      TT_HdmxRec*  limit = cur + hdmx->num_records;


      for ( ; cur < limit; cur++ )
      {
        /* read record */
        if ( READ_Byte( cur->ppem      ) ||
             READ_Byte( cur->max_width ) )
          goto Exit;

        if ( ALLOC( cur->widths, num_glyphs )     ||
             FILE_Read( cur->widths, num_glyphs ) )
          goto Exit;

        /* skip padding bytes */
        if ( record_size > 0 && FILE_Skip( record_size ) )
            goto Exit;
      }
    }

  Exit:
    return error;
  }


  /*************************************************************************/
  /*                                                                       */
  /* <Function>                                                            */
  /*    TT_Free_Hdmx                                                       */
  /*                                                                       */
  /* <Description>                                                         */
  /*    Frees the horizontal device metrics table.                         */
  /*                                                                       */
  /* <Input>                                                               */
  /*    face :: A handle to the target face object.                        */
  /*                                                                       */
  FT_LOCAL_DEF void
  TT_Free_Hdmx( TT_Face  face )
  {
    if ( face )
    {
      FT_Int     n;
      FT_Memory  memory = face->root.driver->root.memory;


      for ( n = 0; n < face->hdmx.num_records; n++ )
        FREE( face->hdmx.records[n].widths );

      FREE( face->hdmx.records );
      face->hdmx.num_records = 0;
    }
  }


/* END */
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d8 1
a8 1
/*  Copyright 1996-2001, 2002 by                                           */
d18 1
a18 1
/* $XFree86: xc/extras/freetype2/src/sfnt/ttload.c,v 1.2 2003/10/22 17:26:30 tsi Exp $ */
d29 1
d44 1
a44 1
  /*    tt_face_lookup_table                                               */
a50 1
  /*                                                                       */
d56 3
a58 3
  FT_LOCAL_DEF( TT_Table  )
  tt_face_lookup_table( TT_Face   face,
                        FT_ULong  tag  )
d60 2
a61 2
    TT_Table  entry;
    TT_Table  limit;
d64 1
a64 1
    FT_TRACE3(( "tt_face_lookup_table: %08p, `%c%c%c%c' -- ",
d76 1
a76 3
      /* For compatibility with Windows, we consider 0-length */
      /* tables the same as missing tables.                   */
      if ( entry->Tag == tag && entry->Length != 0 )
d91 1
a91 1
  /*    tt_face_goto_table                                                 */
a97 1
  /*                                                                       */
a98 1
  /*                                                                       */
d107 5
a111 5
  FT_LOCAL_DEF( FT_Error )
  tt_face_goto_table( TT_Face    face,
                      FT_ULong   tag,
                      FT_Stream  stream,
                      FT_ULong*  length )
d113 2
a114 2
    TT_Table  table;
    FT_Error  error;
d117 1
a117 1
    table = tt_face_lookup_table( face, tag );
d123 1
a123 1
      if ( FT_STREAM_SEEK( table->Offset ) )
a133 109
 /* In theory, we should check the values of `search_range',               */
 /* `entry_selector', and `range_shift' to detect non-SFNT based files     */
 /* whose header might also start with 0x100000L (yes, these exist).       */
 /*                                                                        */
 /* Very unfortunately, many TrueType fonts don't have these fields        */
 /* set correctly and we must ignore them to support them.  An alternative */
 /* way to check the font file is thus to:                                 */
 /*                                                                        */
 /* - check that `num_tables' is valid                                     */
 /* - look for a "head" table, check its size, and parse it to             */
 /*   see if its "magic" field is correctly set                            */
 /*                                                                        */
 /* When checking directory entries, ignore the tables `glyx' and `locx'   */
 /* which are hacked-out versions of `glyf' and `loca' in some PostScript  */
 /* Type 42 fonts, and will generally be invalid.                          */
 /*                                                                        */
  static FT_Error
  sfnt_dir_check( FT_Stream  stream,
                  FT_ULong   offset,
                  FT_UInt    num_tables )
   {
    FT_Error        error;
    FT_UInt         nn, has_head = 0;

    const FT_ULong  glyx_tag = FT_MAKE_TAG( 'g', 'l', 'y', 'x' );
    const FT_ULong  locx_tag = FT_MAKE_TAG( 'l', 'o', 'c', 'x' );

    static const FT_Frame_Field  sfnt_dir_entry_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  TT_TableRec

      FT_FRAME_START( 16 ),
        FT_FRAME_ULONG( Tag ),
        FT_FRAME_ULONG( CheckSum ),
        FT_FRAME_ULONG( Offset ),
        FT_FRAME_ULONG( Length ),
      FT_FRAME_END
    };


    /* if 'num_tables' is 0, read the table count from the file */
    if ( num_tables == 0 )
    {
      FT_ULong  format_tag;

      if ( FT_STREAM_SEEK( offset )     ||
           FT_READ_ULONG ( format_tag ) ||
           FT_READ_USHORT( num_tables ) ||
           FT_STREAM_SKIP( 6 )          )
        goto Bad_Format;

      (void) format_tag;

      if ( offset + 12 + num_tables*16 > stream->size )
        goto Bad_Format;
    }
    else if ( FT_STREAM_SEEK( offset + 12 ) )
      goto Bad_Format;

    for ( nn = 0; nn < num_tables; nn++ )
    {
      TT_TableRec  table;


      if ( FT_STREAM_READ_FIELDS( sfnt_dir_entry_fields, &table ) )
        goto Bad_Format;

      if ( table.Offset + table.Length > stream->size     &&
           table.Tag != glyx_tag && table.Tag != locx_tag )
        goto Bad_Format;

      if ( table.Tag == TTAG_head )
      {
        FT_UInt32  magic;


        has_head = 1;

       /* the table length should be 0x36, but certain font tools
        * make it 0x38, so we will just check that it is greater.
        *
        * note that according to the specification,
        * the table must be padded to 32-bit lengths, but this doesn't
        * apply to the value of its "Length" field !!
        */
        if ( table.Length < 0x36                 ||
             FT_STREAM_SEEK( table.Offset + 12 ) ||
             FT_READ_ULONG( magic )              ||
             magic != 0x5F0F3CF5UL               )
          goto Bad_Format;

        if ( FT_STREAM_SEEK( offset + 28 + 16*nn ) )
          goto Bad_Format;
      }
    }

    if ( has_head == 0 )
      goto Bad_Format;

  Exit:
    return  error;

  Bad_Format:
    error = FT_Err_Unknown_File_Format;
    goto Exit;
  }


d137 1
a137 1
  /*    tt_face_load_sfnt_header                                           */
a143 1
  /*                                                                       */
a144 1
  /*                                                                       */
d162 5
a166 5
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_sfnt_header( TT_Face      face,
                            FT_Stream    stream,
                            FT_Long      face_index,
                            SFNT_Header  sfnt )
d169 1
a169 1
    FT_ULong   format_tag, offset;
d172 1
a172 1
    static const FT_Frame_Field  sfnt_header_fields[] =
d175 1
a175 1
#define FT_STRUCTURE  SFNT_HeaderRec
d185 1
a185 1
    static const FT_Frame_Field  ttc_header_fields[] =
d188 1
a188 1
#define FT_STRUCTURE  TTC_HeaderRec
d193 1
a193 2
      FT_FRAME_END
    };
d196 1
a196 1
    FT_TRACE2(( "tt_face_load_sfnt_header: %08p, %ld\n",
d199 3
a201 3
    face->ttc_header.tag     = 0;
    face->ttc_header.version = 0;
    face->ttc_header.count   = 0;
d208 1
a208 4
    /*                                                                  */
    offset = FT_STREAM_POS();

    if ( FT_READ_ULONG( format_tag ) )
d216 1
a216 1
      FT_TRACE3(( "tt_face_load_sfnt_header: file is a collection\n" ));
d218 3
a220 3
      /* It is a TrueType collection, i.e. a file containing several */
      /* font files.  Read the font directory now                    */
      if ( FT_STREAM_READ_FIELDS( ttc_header_fields, &face->ttc_header ) )
d224 4
a227 2
      if ( FT_NEW_ARRAY( face->ttc_header.offsets, face->ttc_header.count ) ||
           FT_FRAME_ENTER( face->ttc_header.count * 4L )                    )
d231 1
a231 1
        face->ttc_header.offsets[n] = FT_GET_ULONG();
d233 1
a233 1
      FT_FRAME_EXIT();
d243 2
a244 4
      offset = face->ttc_header.offsets[face_index];

      if ( FT_STREAM_SEEK( offset ) ||
           FT_READ_LONG( format_tag )                             )
d250 1
a250 3
    sfnt->offset     = offset;

    if ( FT_STREAM_READ_FIELDS( sfnt_header_fields, sfnt ) )
d253 1
a253 3
    /* now check the sfnt directory */
    error = sfnt_dir_check( stream, offset, sfnt->num_tables );
    if ( error )
d255 14
a268 2
      FT_TRACE2(( "tt_face_load_sfnt_header: file is not SFNT!\n" ));
      error = SFNT_Err_Unknown_File_Format;
d279 1
a279 1
  /*    tt_face_load_directory                                             */
a288 1
  /*                                                                       */
d297 4
a300 4
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_directory( TT_Face      face,
                          FT_Stream    stream,
                          SFNT_Header  sfnt )
d302 2
a303 2
    FT_Error     error;
    FT_Memory    memory = stream->memory;
d305 1
a305 1
    TT_TableRec  *entry, *limit;
d308 1
a308 1
    FT_TRACE2(( "tt_face_load_directory: %08p\n", face ));
d315 3
a317 1
    if ( FT_NEW_ARRAY( face->dir_tables, face->num_tables ) )
d320 1
a320 2
    if ( FT_STREAM_SEEK( sfnt->offset + 12 )      ||
         FT_FRAME_ENTER( face->num_tables * 16L ) )
d328 4
a331 4
      entry->Tag      = FT_GET_TAG4();
      entry->CheckSum = FT_GET_ULONG();
      entry->Offset   = FT_GET_LONG();
      entry->Length   = FT_GET_LONG();
d342 1
a342 1
    FT_FRAME_EXIT();
d354 1
a354 1
  /*    tt_face_load_any                                                   */
d391 6
a396 6
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_any( TT_Face    face,
                    FT_ULong   tag,
                    FT_Long    offset,
                    FT_Byte*   buffer,
                    FT_ULong*  length )
d400 1
a400 1
    TT_Table   table;
d407 1
a407 1
      table = tt_face_lookup_table( face, tag );
d433 1
a433 1
    if ( FT_STREAM_READ_AT( offset, buffer, size ) )
d444 1
a444 1
  /*    tt_face_load_generic_header                                        */
a450 1
  /*                                                                       */
d457 3
a459 3
  tt_face_load_generic_header( TT_Face    face,
                               FT_Stream  stream,
                               FT_ULong   tag )
d493 1
a493 1
    FT_TRACE2(( "tt_face_load_generic_header: "
d504 1
a504 1
      FT_TRACE2(( "tt_face_load_generic_header: Font table is missing!\n" ));
d510 1
a510 1
    if ( FT_STREAM_READ_FIELDS( header_fields, header ) )
d515 1
a515 1
    FT_TRACE2(( "tt_face_load_generic_header: Font table loaded.\n" ));
d522 3
a524 3
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_header( TT_Face    face,
                       FT_Stream  stream )
d526 1
a526 1
    return tt_face_load_generic_header( face, stream, TTAG_head );
d532 3
a534 3
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_bitmap_header( TT_Face    face,
                              FT_Stream  stream )
d536 1
a536 1
    return tt_face_load_generic_header( face, stream, TTAG_bhed );
d545 1
a545 1
  /*    tt_face_load_max_profile                                           */
a551 1
  /*                                                                       */
d557 3
a559 3
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_max_profile( TT_Face    face,
                            FT_Stream  stream )
d601 1
a601 1
    if ( FT_STREAM_READ_FIELDS( maxp_fields, maxProfile ) )
d620 1
a620 1
      if ( FT_STREAM_READ_FIELDS( maxp_fields_extra, maxProfile ) )
d652 2
a653 2
      face->root.internal->max_points   += (FT_UShort)8;
      face->root.internal->max_contours += (FT_Short) 4;
d666 1
a666 1
  /*    tt_face_load_metrics                                               */
a672 1
  /*                                                                       */
a673 1
  /*                                                                       */
d680 3
a682 3
  tt_face_load_metrics( TT_Face    face,
                        FT_Stream  stream,
                        FT_Bool    vertical )
d690 1
a690 1
    TT_LongMetrics *   longs;
a700 1
      /*                                                               */
d718 1
a718 1
      longs     = (TT_LongMetrics *)&face->vertical.long_metrics;
a725 14

#ifdef FT_CONFIG_OPTION_INCREMENTAL
      /* If this is an incrementally loaded font and there are    */
      /* overriding metrics tolerate a missing 'hmtx' table.      */
        if ( face->root.internal->incremental_interface &&
             face->root.internal->incremental_interface->funcs->
                 get_glyph_metrics )
        {
          face->horizontal.number_Of_HMetrics = 0;
          error = SFNT_Err_Ok;
          goto Exit;
	    }
#endif

d732 1
a732 1
      longs     = (TT_LongMetrics *)&face->horizontal.long_metrics;
d752 2
a753 2
    if ( FT_NEW_ARRAY( *longs,  num_longs  ) ||
         FT_NEW_ARRAY( *shorts, num_shorts ) )
d756 1
a756 1
    if ( FT_FRAME_ENTER( table_len ) )
d760 2
a761 2
      TT_LongMetrics  cur   = *longs;
      TT_LongMetrics  limit = cur + num_longs;
d766 2
a767 2
        cur->advance = FT_GET_USHORT();
        cur->bearing = FT_GET_SHORT();
d778 1
a778 1
        *cur = FT_GET_SHORT();
d794 1
a794 1
    FT_FRAME_EXIT();
d806 1
a806 1
  /*    tt_face_load_metrics_header                                        */
a812 1
  /*                                                                       */
a813 1
  /*                                                                       */
d819 4
a822 4
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_metrics_header( TT_Face    face,
                               FT_Stream  stream,
                               FT_Bool    vertical )
d886 1
a886 1
    if ( FT_STREAM_READ_FIELDS( metrics_header_fields, header ) )
d896 1
a896 1
    error = tt_face_load_metrics( face, stream, vertical );
d906 1
a906 1
  /*    tt_face_load_names                                                 */
a912 1
  /*                                                                       */
d918 3
a920 3
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_names( TT_Face    face,
                      FT_Stream  stream )
d922 7
a928 6
    FT_Error      error;
    FT_Memory     memory = stream->memory;
    FT_ULong      table_pos, table_len;
    FT_ULong      storage_start, storage_limit;
    FT_UInt       count;
    TT_NameTable  table;
d930 1
a930 1
    static const FT_Frame_Field  name_table_fields[] =
d933 1
a933 1
#define FT_STRUCTURE  TT_NameTableRec
d942 1
a942 1
    static const FT_Frame_Field  name_record_fields[] =
d945 1
a945 1
#define FT_STRUCTURE  TT_NameEntryRec
a957 3
    table         = &face->name_table;
    table->stream = stream;

d969 1
a969 1
    table_pos = FT_STREAM_POS();
d971 1
d973 1
a973 1
    if ( FT_STREAM_READ_FIELDS( name_table_fields, table ) )
d976 6
a981 9
    /* Some popular Asian fonts have an invalid `storageOffset' value   */
    /* (it should be at least "6 + 12*num_names").  However, the string */
    /* offsets, computed as "storageOffset + entry->stringOffset", are  */
    /* valid pointers within the name table...                          */
    /*                                                                  */
    /* We thus can't check `storageOffset' right now.                   */
    /*                                                                  */
    storage_start = table_pos + 6 + 12*table->numNameRecords;
    storage_limit = table_pos + table_len;
d983 2
a984 1
    if ( storage_start > storage_limit )
d986 18
a1003 3
      FT_ERROR(( "tt_face_load_names: invalid `name' table\n" ));
      error = SFNT_Err_Name_Table_Missing;
      goto Exit;
d1006 14
a1019 3
    /* Allocate the array of name records. */
    count                 = table->numNameRecords;
    table->numNameRecords = 0;
a1020 3
    if ( FT_NEW_ARRAY( table->names, count ) ||
         FT_FRAME_ENTER( count * 12 )        )
      goto Exit;
d1022 3
a1024 4
    /* Load the name records and determine how much storage is needed */
    /* to hold the strings themselves.                                */
    {
      TT_NameEntryRec*  entry = table->names;
d1026 1
d1028 1
a1028 1
      for ( ; count > 0; count-- )
d1030 3
a1032 2
        if ( FT_STREAM_READ_FIELDS( name_record_fields, entry ) )
          continue;
d1034 1
a1034 8
        /* check that the name is not empty */
        if ( entry->stringLength == 0 )
          continue;

        /* check that the name string is within the table */
        entry->stringOffset += table_pos + table->storageOffset;
        if ( entry->stringOffset                       < storage_start ||
             entry->stringOffset + entry->stringLength > storage_limit )
d1036 20
a1055 4
          /* invalid entry - ignore it */
          entry->stringOffset = 0;
          entry->stringLength = 0;
          continue;
d1057 2
d1060 1
a1060 2
        entry++;
      }
a1061 1
      table->numNameRecords = (FT_UInt)( entry - table->names );
a1062 3

    FT_FRAME_EXIT();

d1066 1
a1066 1
    face->num_names = (FT_UShort) table->numNameRecords;
d1076 1
a1076 1
  /*    tt_face_free_names                                                 */
d1084 2
a1085 2
  FT_LOCAL_DEF( void )
  tt_face_free_names( TT_Face  face )
d1087 2
a1088 4
    FT_Memory     memory = face->root.driver->root.memory;
    TT_NameTable  table  = &face->name_table;
    TT_NameEntry  entry  = table->names;
    FT_UInt       count  = table->numNameRecords;
d1091 2
a1092 5
    for ( ; count > 0; count--, entry++ )
    {
      FT_FREE( entry->string );
      entry->stringLength = 0;
    }
d1094 2
a1095 2
    /* free strings table */
    FT_FREE( table->names );
d1097 3
a1099 3
    table->numNameRecords = 0;
    table->format         = 0;
    table->storageOffset  = 0;
d1106 1
a1106 1
  /*    tt_face_load_cmap                                                  */
a1113 1
  /*                                                                       */
d1119 30
a1149 5
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_cmap( TT_Face    face,
                     FT_Stream  stream )
  {
    FT_Error  error;
d1151 1
d1153 1
a1153 1
    error = face->goto_table( face, TTAG_cmap, stream, &face->cmap_size );
a1155 1
      FT_TRACE2(( "No `cmap' table in font !\n" ));
d1160 12
a1171 3
    if ( !FT_FRAME_EXTRACT( face->cmap_size, face->cmap_table ) )
      FT_TRACE2(( "`cmap' table loaded\n" ));
    else
d1173 36
a1208 2
      FT_ERROR(( "`cmap' table is too short!\n" ));
      face->cmap_size = 0;
d1211 2
a1217 1

d1221 1
a1221 1
  /*    tt_face_load_os2                                                   */
a1227 1
  /*                                                                       */
d1233 3
a1235 3
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_os2( TT_Face    face,
                    FT_Stream  stream )
d1321 1
a1321 1
      face->os2.version = 0xFFFFU;
d1328 1
a1328 1
    if ( FT_STREAM_READ_FIELDS( os2_fields, os2 ) )
d1342 1
a1342 1
      if ( FT_STREAM_READ_FIELDS( os2_fields_extra, os2 ) )
d1348 1
a1348 1
        if ( FT_STREAM_READ_FIELDS( os2_fields_extra2, os2 ) )
d1363 1
a1363 1
  /*    tt_face_load_postscript                                            */
a1369 1
  /*                                                                       */
d1375 3
a1377 3
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_postscript( TT_Face    face,
                           FT_Stream  stream )
d1407 1
a1407 1
    if ( FT_STREAM_READ_FIELDS( post_fields, post ) )
d1421 1
a1421 1
  /*    tt_face_load_pclt                                                  */
a1427 1
  /*                                                                       */
d1433 3
a1435 3
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_pclt( TT_Face    face,
                     FT_Stream  stream )
d1475 1
a1475 1
    if ( FT_STREAM_READ_FIELDS( pclt_fields, pclt ) )
d1488 1
a1488 1
  /*    tt_face_load_gasp                                                  */
a1494 1
  /*                                                                       */
d1500 3
a1502 3
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_gasp( TT_Face    face,
                     FT_Stream  stream )
d1508 1
a1508 1
    TT_GaspRange   gaspranges;
d1511 1
a1511 1
    FT_TRACE2(( "tt_face_load_gasp: %08p\n", face ));
d1518 1
a1518 1
    if ( FT_FRAME_ENTER( 4L ) )
d1521 2
a1522 2
    face->gasp.version   = FT_GET_USHORT();
    face->gasp.numRanges = FT_GET_USHORT();
d1524 1
a1524 1
    FT_FRAME_EXIT();
d1529 2
a1530 2
    if ( FT_NEW_ARRAY( gaspranges, num_ranges ) ||
         FT_FRAME_ENTER( num_ranges * 4L )      )
d1537 2
a1538 2
      gaspranges[j].maxPPEM  = FT_GET_USHORT();
      gaspranges[j].gaspFlag = FT_GET_USHORT();
d1546 1
a1546 1
    FT_FRAME_EXIT();
d1562 1
a1562 1
  /*    tt_face_load_kern                                                  */
a1571 1
  /*                                                                       */
d1577 3
a1579 3
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_kern( TT_Face    face,
                     FT_Stream  stream )
d1592 1
a1592 1
    if ( FT_FRAME_ENTER( 4L ) )
d1595 2
a1596 2
    (void)FT_GET_USHORT();         /* version */
    num_tables = FT_GET_USHORT();
d1598 1
a1598 1
    FT_FRAME_EXIT();
d1606 1
a1606 1
      if ( FT_FRAME_ENTER( 6L ) )
d1609 3
a1611 3
      (void)FT_GET_USHORT();           /* version                 */
      length   = FT_GET_USHORT() - 6;  /* substract header length */
      coverage = FT_GET_USHORT();
d1613 1
a1613 1
      FT_FRAME_EXIT();
d1617 3
a1619 3
        FT_UInt        num_pairs;
        TT_Kern0_Pair  pair;
        TT_Kern0_Pair  limit;
d1623 1
a1623 1
        if ( FT_FRAME_ENTER( 8L ) )
d1626 1
a1626 1
        num_pairs = FT_GET_USHORT();
d1630 1
a1630 1
        FT_FRAME_EXIT();
d1633 2
a1634 2
        if ( FT_NEW_ARRAY( face->kern_pairs, num_pairs ) ||
             FT_FRAME_ENTER( 6L * num_pairs )            )
d1641 3
a1643 3
          pair->left  = FT_GET_USHORT();
          pair->right = FT_GET_USHORT();
          pair->value = FT_GET_USHORT();
d1646 1
a1646 1
        FT_FRAME_EXIT();
d1654 2
a1655 2
          FT_UInt        i;
          TT_Kern0_Pair  pair0;
d1664 2
a1665 2
              ft_qsort( (void*)face->kern_pairs, (int)num_pairs,
                        sizeof ( TT_Kern0_PairRec ), tt_kern_pair_compare );
d1674 1
a1674 1
      if ( FT_STREAM_SKIP( length ) )
a1690 1

d1695 2
a1696 2
    TT_Kern0_Pair  pair1 = (TT_Kern0_Pair)a;
    TT_Kern0_Pair  pair2 = (TT_Kern0_Pair)b;
a1705 1

d1712 1
a1712 1
  /*    tt_face_load_hdmx                                                  */
a1718 1
  /*                                                                       */
d1724 3
a1726 3
  FT_LOCAL_DEF( FT_Error )
  tt_face_load_hdmx( TT_Face    face,
                     FT_Stream  stream )
d1728 2
a1729 2
    FT_Error   error;
    FT_Memory  memory = stream->memory;
d1731 3
a1733 3
    TT_Hdmx    hdmx = &face->hdmx;
    FT_Long    num_glyphs;
    FT_Long    record_size;
d1745 1
a1745 1
    if ( FT_FRAME_ENTER( 8L ) )
d1748 3
a1750 3
    hdmx->version     = FT_GET_USHORT();
    hdmx->num_records = FT_GET_SHORT();
    record_size       = FT_GET_LONG();
d1752 1
a1752 1
    FT_FRAME_EXIT();
d1758 1
a1758 1
    if ( FT_NEW_ARRAY( hdmx->records, hdmx->num_records ) )
d1765 2
a1766 2
      TT_HdmxEntry  cur   = hdmx->records;
      TT_HdmxEntry  limit = cur + hdmx->num_records;
d1772 2
a1773 2
        if ( FT_READ_BYTE( cur->ppem      ) ||
             FT_READ_BYTE( cur->max_width ) )
d1776 2
a1777 2
        if ( FT_ALLOC( cur->widths, num_glyphs )       ||
             FT_STREAM_READ( cur->widths, num_glyphs ) )
d1781 1
a1781 1
        if ( record_size > 0 && FT_STREAM_SKIP( record_size ) )
d1794 1
a1794 1
  /*    tt_face_free_hdmx                                                  */
d1802 2
a1803 2
  FT_LOCAL_DEF( void )
  tt_face_free_hdmx( TT_Face  face )
d1812 1
a1812 1
        FT_FREE( face->hdmx.records[n].widths );
d1814 1
a1814 1
      FT_FREE( face->hdmx.records );
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d8 1
a8 1
/*  Copyright 1996-2001, 2002 by                                           */
d29 1
a50 1
  /*                                                                       */
d56 1
a56 1
  FT_LOCAL_DEF( TT_Table  )
d60 2
a61 2
    TT_Table  entry;
    TT_Table  limit;
d76 1
a76 3
      /* For compatibility with Windows, we consider 0-length */
      /* tables the same as missing tables.                   */
      if ( entry->Tag == tag && entry->Length != 0 )
a97 1
  /*                                                                       */
a98 1
  /*                                                                       */
d107 1
a107 1
  FT_LOCAL_DEF( FT_Error )
d113 2
a114 2
    TT_Table  table;
    FT_Error  error;
d123 1
a123 1
      if ( FT_STREAM_SEEK( table->Offset ) )
d137 1
a137 1
  /*    TT_Load_SFNT_HeaderRec                                             */
a143 1
  /*                                                                       */
a144 1
  /*                                                                       */
d162 5
a166 5
  FT_LOCAL_DEF( FT_Error )
  TT_Load_SFNT_HeaderRec( TT_Face       face,
                          FT_Stream     stream,
                          FT_Long       face_index,
                          SFNT_Header   sfnt )
d175 1
a175 1
#define FT_STRUCTURE  SFNT_HeaderRec
d188 1
a188 1
#define FT_STRUCTURE  TTC_HeaderRec
d193 1
a193 2
      FT_FRAME_END
    };
d196 1
a196 1
    FT_TRACE2(( "TT_Load_SFNT_HeaderRec: %08p, %ld\n",
d199 3
a201 3
    face->ttc_header.tag     = 0;
    face->ttc_header.version = 0;
    face->ttc_header.count   = 0;
d208 1
a208 2
    /*                                                                  */
    if ( FT_READ_ULONG( format_tag ) )
d216 1
a216 1
      FT_TRACE3(( "TT_Load_SFNT_HeaderRec: file is a collection\n" ));
d218 3
a220 3
      /* It is a TrueType collection, i.e. a file containing several */
      /* font files.  Read the font directory now                    */
      if ( FT_STREAM_READ_FIELDS( ttc_header_fields, &face->ttc_header ) )
d224 4
a227 2
      if ( FT_NEW_ARRAY( face->ttc_header.offsets, face->ttc_header.count ) ||
           FT_FRAME_ENTER( face->ttc_header.count * 4L )                    )
d231 1
a231 1
        face->ttc_header.offsets[n] = FT_GET_ULONG();
d233 1
a233 1
      FT_FRAME_EXIT();
d243 2
a244 2
      if ( FT_STREAM_SEEK( face->ttc_header.offsets[face_index] ) ||
           FT_READ_LONG( format_tag )                             )
d250 1
a250 1
    if ( FT_STREAM_READ_FIELDS( sfnt_header_fields, sfnt ) )
d266 1
a266 1
        FT_TRACE2(( "TT_Load_SFNT_HeaderRec: file is not SFNT!\n" ));
a288 1
  /*                                                                       */
d297 4
a300 4
  FT_LOCAL_DEF( FT_Error )
  TT_Load_Directory( TT_Face      face,
                     FT_Stream    stream,
                     SFNT_Header  sfnt )
d302 2
a303 2
    FT_Error     error;
    FT_Memory    memory = stream->memory;
d305 1
a305 1
    TT_TableRec  *entry, *limit;
d315 3
a317 1
    if ( FT_NEW_ARRAY( face->dir_tables, face->num_tables ) )
d320 1
a320 1
    if ( FT_FRAME_ENTER( face->num_tables * 16L ) )
d328 4
a331 4
      entry->Tag      = FT_GET_TAG4();
      entry->CheckSum = FT_GET_ULONG();
      entry->Offset   = FT_GET_LONG();
      entry->Length   = FT_GET_LONG();
d342 1
a342 1
    FT_FRAME_EXIT();
d391 1
a391 1
  FT_LOCAL_DEF( FT_Error )
d400 1
a400 1
    TT_Table   table;
d433 1
a433 1
    if ( FT_STREAM_READ_AT( offset, buffer, size ) )
a450 1
  /*                                                                       */
d510 1
a510 1
    if ( FT_STREAM_READ_FIELDS( header_fields, header ) )
d522 1
a522 1
  FT_LOCAL_DEF( FT_Error )
d532 1
a532 1
  FT_LOCAL_DEF( FT_Error )
a551 1
  /*                                                                       */
d557 1
a557 1
  FT_LOCAL_DEF( FT_Error )
d601 1
a601 1
    if ( FT_STREAM_READ_FIELDS( maxp_fields, maxProfile ) )
d620 1
a620 1
      if ( FT_STREAM_READ_FIELDS( maxp_fields_extra, maxProfile ) )
d652 2
a653 2
      face->root.internal->max_points   += (FT_UShort)8;
      face->root.internal->max_contours += (FT_Short) 4;
a672 1
  /*                                                                       */
a673 1
  /*                                                                       */
d690 1
a690 1
    TT_LongMetrics *   longs;
a700 1
      /*                                                               */
d718 1
a718 1
      longs     = (TT_LongMetrics *)&face->vertical.long_metrics;
d732 1
a732 1
      longs     = (TT_LongMetrics *)&face->horizontal.long_metrics;
d752 2
a753 2
    if ( FT_NEW_ARRAY( *longs,  num_longs  ) ||
         FT_NEW_ARRAY( *shorts, num_shorts ) )
d756 1
a756 1
    if ( FT_FRAME_ENTER( table_len ) )
d760 2
a761 2
      TT_LongMetrics  cur   = *longs;
      TT_LongMetrics  limit = cur + num_longs;
d766 2
a767 2
        cur->advance = FT_GET_USHORT();
        cur->bearing = FT_GET_SHORT();
d778 1
a778 1
        *cur = FT_GET_SHORT();
d794 1
a794 1
    FT_FRAME_EXIT();
a812 1
  /*                                                                       */
a813 1
  /*                                                                       */
d819 1
a819 1
  FT_LOCAL_DEF( FT_Error )
d886 1
a886 1
    if ( FT_STREAM_READ_FIELDS( metrics_header_fields, header ) )
a912 1
  /*                                                                       */
d918 1
a918 1
  FT_LOCAL_DEF( FT_Error )
d922 5
a926 6
    FT_Error      error;
    FT_Memory     memory = stream->memory;
    FT_ULong      table_pos, table_len;
    FT_ULong      storage_start, storage_limit;
    FT_UInt       count;
    TT_NameTable  table;
d928 3
a930 1
    static const FT_Frame_Field  name_table_fields[] =
d933 1
a933 1
#define FT_STRUCTURE  TT_NameTableRec
d942 1
a942 1
    static const FT_Frame_Field  name_record_fields[] =
d945 1
a945 1
#define FT_STRUCTURE  TT_NameEntryRec
a957 3
    table         = &face->name_table;
    table->stream = stream;

d969 1
a969 1
    table_pos = FT_STREAM_POS();
d971 1
d973 1
a973 1
    if ( FT_STREAM_READ_FIELDS( name_table_fields, table ) )
d976 6
a981 9
    /* Some popular asian fonts have an invalid `storageOffset' value   */
    /* (it should be at least "6 + 12*num_names").  However, the string */
    /* offsets, computed as "storageOffset + entry->stringOffset", are  */
    /* valid pointers within the name table...                          */
    /*                                                                  */
    /* We thus can't check `storageOffset' right now.                   */
    /*                                                                  */
    storage_start = table_pos + 6 + 12*table->numNameRecords;
    storage_limit = table_pos + table_len;
d983 2
a984 1
    if ( storage_start > storage_limit )
d986 18
a1003 3
      FT_ERROR(( "TT_Load_Names: invalid `name' table\n" ));
      error = SFNT_Err_Name_Table_Missing;
      goto Exit;
d1006 14
a1019 3
    /* Allocate the array of name records. */
    count                 = table->numNameRecords;
    table->numNameRecords = 0;
a1020 3
    if ( FT_NEW_ARRAY( table->names, count ) ||
         FT_FRAME_ENTER( count * 12 )        )
      goto Exit;
d1022 3
a1024 4
    /* Load the name records and determine how much storage is needed */
    /* to hold the strings themselves.                                */
    {
      TT_NameEntryRec*  entry = table->names;
d1026 1
d1028 1
a1028 1
      for ( ; count > 0; count-- )
d1030 3
a1032 2
        if ( FT_STREAM_READ_FIELDS( name_record_fields, entry ) )
          continue;
d1034 1
a1034 8
        /* check that the name is not empty */
        if ( entry->stringLength == 0 )
          continue;

        /* check that the name string is within the table */
        entry->stringOffset += table_pos + table->storageOffset;
        if ( entry->stringOffset                       < storage_start ||
             entry->stringOffset + entry->stringLength > storage_limit )
d1036 20
a1055 4
          /* invalid entry - ignore it */
          entry->stringOffset = 0;
          entry->stringLength = 0;
          continue;
d1057 2
d1060 1
a1060 2
        entry++;
      }
a1061 1
      table->numNameRecords = entry - table->names;
a1062 3

    FT_FRAME_EXIT();

d1066 1
a1066 1
    face->num_names = (FT_UShort) table->numNameRecords;
d1084 1
a1084 1
  FT_LOCAL_DEF( void )
d1087 2
a1088 4
    FT_Memory     memory = face->root.driver->root.memory;
    TT_NameTable  table  = &face->name_table;
    TT_NameEntry  entry  = table->names;
    FT_UInt       count  = table->numNameRecords;
d1091 2
a1092 5
    for ( ; count > 0; count--, entry++ )
    {
      FT_FREE( entry->string );
      entry->stringLength = 0;
    }
d1094 2
a1095 2
    /* free strings table */
    FT_FREE( table->names );
d1097 3
a1099 3
    table->numNameRecords = 0;
    table->format         = 0;
    table->storageOffset  = 0;
a1113 1
  /*                                                                       */
d1119 1
a1119 4

#ifdef FT_CONFIG_OPTION_USE_CMAPS

  FT_LOCAL_DEF( FT_Error )
d1123 4
a1126 33
    FT_Error  error;


    error = face->goto_table( face, TTAG_cmap, stream, &face->cmap_size );
    if ( error )
    {
      FT_TRACE2(( "No `cmap' table in font !\n" ));
      error = SFNT_Err_CMap_Table_Missing;
      goto Exit;
    }

    if ( !FT_FRAME_EXTRACT( face->cmap_size, face->cmap_table ) )
      FT_TRACE2(( "`cmap' table loaded\n" ));
    else
    {
      FT_ERROR(( "`cmap' table is too short!\n" ));
      face->cmap_size = 0;
    }

  Exit:
    return error;
  }

#else /* !FT_CONFIG_OPTION_USE_CMAPS */

  FT_LOCAL_DEF( FT_Error )
  TT_Load_CMap( TT_Face    face,
                FT_Stream  stream )
  {
    FT_Error       error;
    FT_Memory      memory = stream->memory;
    FT_Long        table_start;
    TT_CMapDirRec  cmap_dir;
d1131 1
a1131 1
#define FT_STRUCTURE  TT_CMapDirRec
d1142 1
a1142 1
#define FT_STRUCTURE  TT_CMapTableRec
d1160 1
a1160 1
    table_start = FT_STREAM_POS();
d1162 1
a1162 1
    if ( FT_STREAM_READ_FIELDS( cmap_fields, &cmap_dir ) )
d1166 3
a1168 1
    if ( FT_NEW_ARRAY( face->charmaps, cmap_dir.numCMaps ) )
d1178 1
a1178 1
      if ( FT_FRAME_ENTER( face->num_charmaps * 8L ) )
d1183 1
a1183 1
        TT_CMapTable  cmap;
d1190 3
a1192 3
        cmap->platformID         = FT_GET_USHORT();
        cmap->platformEncodingID = FT_GET_USHORT();
        cmap->offset             = (FT_ULong)FT_GET_LONG();
d1195 1
a1195 1
      FT_FRAME_EXIT();
d1200 1
a1200 1
        TT_CMapTable  cmap = &charmap->cmap;
d1203 2
a1204 2
        if ( FT_STREAM_SEEK( table_start + (FT_Long)cmap->offset ) ||
             FT_STREAM_READ_FIELDS( cmap_rec_fields, cmap )        )
d1207 1
a1207 1
        cmap->offset = FT_STREAM_POS();
a1216 2
#endif /* !FT_CONFIG_OPTION_USE_CMAPS */

a1227 1
  /*                                                                       */
d1233 1
a1233 1
  FT_LOCAL_DEF( FT_Error )
d1321 1
a1321 1
      face->os2.version = 0xFFFFU;
d1328 1
a1328 1
    if ( FT_STREAM_READ_FIELDS( os2_fields, os2 ) )
d1342 1
a1342 1
      if ( FT_STREAM_READ_FIELDS( os2_fields_extra, os2 ) )
d1348 1
a1348 1
        if ( FT_STREAM_READ_FIELDS( os2_fields_extra2, os2 ) )
a1369 1
  /*                                                                       */
d1375 1
a1375 1
  FT_LOCAL_DEF( FT_Error )
d1407 1
a1407 1
    if ( FT_STREAM_READ_FIELDS( post_fields, post ) )
a1427 1
  /*                                                                       */
d1433 1
a1433 1
  FT_LOCAL_DEF( FT_Error )
d1475 1
a1475 1
    if ( FT_STREAM_READ_FIELDS( pclt_fields, pclt ) )
a1494 1
  /*                                                                       */
d1500 1
a1500 1
  FT_LOCAL_DEF( FT_Error )
d1508 1
a1508 1
    TT_GaspRange   gaspranges;
d1518 1
a1518 1
    if ( FT_FRAME_ENTER( 4L ) )
d1521 2
a1522 2
    face->gasp.version   = FT_GET_USHORT();
    face->gasp.numRanges = FT_GET_USHORT();
d1524 1
a1524 1
    FT_FRAME_EXIT();
d1529 2
a1530 2
    if ( FT_NEW_ARRAY( gaspranges, num_ranges ) ||
         FT_FRAME_ENTER( num_ranges * 4L )      )
d1537 2
a1538 2
      gaspranges[j].maxPPEM  = FT_GET_USHORT();
      gaspranges[j].gaspFlag = FT_GET_USHORT();
d1546 1
a1546 1
    FT_FRAME_EXIT();
a1571 1
  /*                                                                       */
d1577 1
a1577 1
  FT_LOCAL_DEF( FT_Error )
d1592 1
a1592 1
    if ( FT_FRAME_ENTER( 4L ) )
d1595 2
a1596 2
    (void)FT_GET_USHORT();         /* version */
    num_tables = FT_GET_USHORT();
d1598 1
a1598 1
    FT_FRAME_EXIT();
d1606 1
a1606 1
      if ( FT_FRAME_ENTER( 6L ) )
d1609 3
a1611 3
      (void)FT_GET_USHORT();           /* version                 */
      length   = FT_GET_USHORT() - 6;  /* substract header length */
      coverage = FT_GET_USHORT();
d1613 1
a1613 1
      FT_FRAME_EXIT();
d1617 3
a1619 3
        FT_UInt        num_pairs;
        TT_Kern0_Pair  pair;
        TT_Kern0_Pair  limit;
d1623 1
a1623 1
        if ( FT_FRAME_ENTER( 8L ) )
d1626 1
a1626 1
        num_pairs = FT_GET_USHORT();
d1630 1
a1630 1
        FT_FRAME_EXIT();
d1633 2
a1634 2
        if ( FT_NEW_ARRAY( face->kern_pairs, num_pairs ) ||
             FT_FRAME_ENTER( 6L * num_pairs )            )
d1641 3
a1643 3
          pair->left  = FT_GET_USHORT();
          pair->right = FT_GET_USHORT();
          pair->value = FT_GET_USHORT();
d1646 1
a1646 1
        FT_FRAME_EXIT();
d1654 2
a1655 2
          FT_UInt        i;
          TT_Kern0_Pair  pair0;
d1664 2
a1665 2
              ft_qsort( (void*)face->kern_pairs, (int)num_pairs,
                        sizeof ( TT_Kern0_PairRec ), tt_kern_pair_compare );
d1674 1
a1674 1
      if ( FT_STREAM_SKIP( length ) )
a1690 1

d1695 2
a1696 2
    TT_Kern0_Pair  pair1 = (TT_Kern0_Pair)a;
    TT_Kern0_Pair  pair2 = (TT_Kern0_Pair)b;
a1705 1

a1718 1
  /*                                                                       */
d1724 1
a1724 1
  FT_LOCAL_DEF( FT_Error )
d1728 2
a1729 2
    FT_Error   error;
    FT_Memory  memory = stream->memory;
d1731 3
a1733 3
    TT_Hdmx    hdmx = &face->hdmx;
    FT_Long    num_glyphs;
    FT_Long    record_size;
d1745 1
a1745 1
    if ( FT_FRAME_ENTER( 8L ) )
d1748 3
a1750 3
    hdmx->version     = FT_GET_USHORT();
    hdmx->num_records = FT_GET_SHORT();
    record_size       = FT_GET_LONG();
d1752 1
a1752 1
    FT_FRAME_EXIT();
d1758 1
a1758 1
    if ( FT_NEW_ARRAY( hdmx->records, hdmx->num_records ) )
d1765 2
a1766 2
      TT_HdmxEntry  cur   = hdmx->records;
      TT_HdmxEntry  limit = cur + hdmx->num_records;
d1772 2
a1773 2
        if ( FT_READ_BYTE( cur->ppem      ) ||
             FT_READ_BYTE( cur->max_width ) )
d1776 2
a1777 2
        if ( FT_ALLOC( cur->widths, num_glyphs )       ||
             FT_STREAM_READ( cur->widths, num_glyphs ) )
d1781 1
a1781 1
        if ( record_size > 0 && FT_STREAM_SKIP( record_size ) )
d1802 1
a1802 1
  FT_LOCAL_DEF( void )
d1812 1
a1812 1
        FT_FREE( face->hdmx.records[n].widths );
d1814 1
a1814 1
      FT_FREE( face->hdmx.records );
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d18 1
a18 1
/* $XFree86: xc/extras/freetype2/src/sfnt/ttload.c,v 1.2 2003/10/22 17:26:30 tsi Exp $ */
d43 1
a43 1
  /*    tt_face_lookup_table                                               */
d57 2
a58 2
  tt_face_lookup_table( TT_Face   face,
                        FT_ULong  tag  )
d64 1
a64 1
    FT_TRACE3(( "tt_face_lookup_table: %08p, `%c%c%c%c' -- ",
d93 1
a93 1
  /*    tt_face_goto_table                                                 */
d112 4
a115 4
  tt_face_goto_table( TT_Face    face,
                      FT_ULong   tag,
                      FT_Stream  stream,
                      FT_ULong*  length )
d121 1
a121 1
    table = tt_face_lookup_table( face, tag );
a137 109
 /* In theory, we should check the values of `search_range',               */
 /* `entry_selector', and `range_shift' to detect non-SFNT based files     */
 /* whose header might also start with 0x100000L (yes, these exist).       */
 /*                                                                        */
 /* Very unfortunately, many TrueType fonts don't have these fields        */
 /* set correctly and we must ignore them to support them.  An alternative */
 /* way to check the font file is thus to:                                 */
 /*                                                                        */
 /* - check that `num_tables' is valid                                     */
 /* - look for a "head" table, check its size, and parse it to             */
 /*   see if its "magic" field is correctly set                            */
 /*                                                                        */
 /* When checking directory entries, ignore the tables `glyx' and `locx'   */
 /* which are hacked-out versions of `glyf' and `loca' in some PostScript  */
 /* Type 42 fonts, and will generally be invalid.                          */
 /*                                                                        */
  static FT_Error
  sfnt_dir_check( FT_Stream  stream,
                  FT_ULong   offset,
                  FT_UInt    num_tables )
   {
    FT_Error        error;
    FT_UInt         nn, has_head = 0;

    const FT_ULong  glyx_tag = FT_MAKE_TAG( 'g', 'l', 'y', 'x' );
    const FT_ULong  locx_tag = FT_MAKE_TAG( 'l', 'o', 'c', 'x' );

    static const FT_Frame_Field  sfnt_dir_entry_fields[] =
    {
#undef  FT_STRUCTURE
#define FT_STRUCTURE  TT_TableRec

      FT_FRAME_START( 16 ),
        FT_FRAME_ULONG( Tag ),
        FT_FRAME_ULONG( CheckSum ),
        FT_FRAME_ULONG( Offset ),
        FT_FRAME_ULONG( Length ),
      FT_FRAME_END
    };


    /* if 'num_tables' is 0, read the table count from the file */
    if ( num_tables == 0 )
    {
      FT_ULong  format_tag;

      if ( FT_STREAM_SEEK( offset )     ||
           FT_READ_ULONG ( format_tag ) ||
           FT_READ_USHORT( num_tables ) ||
           FT_STREAM_SKIP( 6 )          )
        goto Bad_Format;

      (void) format_tag;

      if ( offset + 12 + num_tables*16 > stream->size )
        goto Bad_Format;
    }
    else if ( FT_STREAM_SEEK( offset + 12 ) )
      goto Bad_Format;

    for ( nn = 0; nn < num_tables; nn++ )
    {
      TT_TableRec  table;


      if ( FT_STREAM_READ_FIELDS( sfnt_dir_entry_fields, &table ) )
        goto Bad_Format;

      if ( table.Offset + table.Length > stream->size     &&
           table.Tag != glyx_tag && table.Tag != locx_tag )
        goto Bad_Format;

      if ( table.Tag == TTAG_head )
      {
        FT_UInt32  magic;


        has_head = 1;

       /* the table length should be 0x36, but certain font tools
        * make it 0x38, so we will just check that it is greater.
        *
        * note that according to the specification,
        * the table must be padded to 32-bit lengths, but this doesn't
        * apply to the value of its "Length" field !!
        */
        if ( table.Length < 0x36                 ||
             FT_STREAM_SEEK( table.Offset + 12 ) ||
             FT_READ_ULONG( magic )              ||
             magic != 0x5F0F3CF5UL               )
          goto Bad_Format;

        if ( FT_STREAM_SEEK( offset + 28 + 16*nn ) )
          goto Bad_Format;
      }
    }

    if ( has_head == 0 )
      goto Bad_Format;

  Exit:
    return  error;

  Bad_Format:
    error = FT_Err_Unknown_File_Format;
    goto Exit;
  }


d141 1
a141 1
  /*    tt_face_load_sfnt_header                                           */
d169 4
a172 4
  tt_face_load_sfnt_header( TT_Face      face,
                            FT_Stream    stream,
                            FT_Long      face_index,
                            SFNT_Header  sfnt )
d175 1
a175 1
    FT_ULong   format_tag, offset;
d178 1
a178 1
    static const FT_Frame_Field  sfnt_header_fields[] =
d191 1
a191 1
    static const FT_Frame_Field  ttc_header_fields[] =
d203 1
a203 1
    FT_TRACE2(( "tt_face_load_sfnt_header: %08p, %ld\n",
a215 2
    offset = FT_STREAM_POS();

d224 1
a224 1
      FT_TRACE3(( "tt_face_load_sfnt_header: file is a collection\n" ));
d249 1
a249 3
      offset = face->ttc_header.offsets[face_index];

      if ( FT_STREAM_SEEK( offset ) ||
a255 2
    sfnt->offset     = offset;

d259 1
a259 3
    /* now check the sfnt directory */
    error = sfnt_dir_check( stream, offset, sfnt->num_tables );
    if ( error )
d261 14
a274 2
      FT_TRACE2(( "tt_face_load_sfnt_header: file is not SFNT!\n" ));
      error = SFNT_Err_Unknown_File_Format;
d285 1
a285 1
  /*    tt_face_load_directory                                             */
d305 3
a307 3
  tt_face_load_directory( TT_Face      face,
                          FT_Stream    stream,
                          SFNT_Header  sfnt )
d315 1
a315 1
    FT_TRACE2(( "tt_face_load_directory: %08p\n", face ));
d325 1
a325 2
    if ( FT_STREAM_SEEK( sfnt->offset + 12 )      ||
         FT_FRAME_ENTER( face->num_tables * 16L ) )
d359 1
a359 1
  /*    tt_face_load_any                                                   */
d397 5
a401 5
  tt_face_load_any( TT_Face    face,
                    FT_ULong   tag,
                    FT_Long    offset,
                    FT_Byte*   buffer,
                    FT_ULong*  length )
d412 1
a412 1
      table = tt_face_lookup_table( face, tag );
d449 1
a449 1
  /*    tt_face_load_generic_header                                        */
d463 3
a465 3
  tt_face_load_generic_header( TT_Face    face,
                               FT_Stream  stream,
                               FT_ULong   tag )
d499 1
a499 1
    FT_TRACE2(( "tt_face_load_generic_header: "
d510 1
a510 1
      FT_TRACE2(( "tt_face_load_generic_header: Font table is missing!\n" ));
d521 1
a521 1
    FT_TRACE2(( "tt_face_load_generic_header: Font table loaded.\n" ));
d529 2
a530 2
  tt_face_load_header( TT_Face    face,
                       FT_Stream  stream )
d532 1
a532 1
    return tt_face_load_generic_header( face, stream, TTAG_head );
d539 2
a540 2
  tt_face_load_bitmap_header( TT_Face    face,
                              FT_Stream  stream )
d542 1
a542 1
    return tt_face_load_generic_header( face, stream, TTAG_bhed );
d551 1
a551 1
  /*    tt_face_load_max_profile                                           */
d565 2
a566 2
  tt_face_load_max_profile( TT_Face    face,
                            FT_Stream  stream )
d673 1
a673 1
  /*    tt_face_load_metrics                                               */
d689 3
a691 3
  tt_face_load_metrics( TT_Face    face,
                        FT_Stream  stream,
                        FT_Bool    vertical )
a735 14

#ifdef FT_CONFIG_OPTION_INCREMENTAL
      /* If this is an incrementally loaded font and there are    */
      /* overriding metrics tolerate a missing 'hmtx' table.      */
        if ( face->root.internal->incremental_interface &&
             face->root.internal->incremental_interface->funcs->
                 get_glyph_metrics )
        {
          face->horizontal.number_Of_HMetrics = 0;
          error = SFNT_Err_Ok;
          goto Exit;
	    }
#endif

d816 1
a816 1
  /*    tt_face_load_metrics_header                                        */
d832 3
a834 3
  tt_face_load_metrics_header( TT_Face    face,
                               FT_Stream  stream,
                               FT_Bool    vertical )
d908 1
a908 1
    error = tt_face_load_metrics( face, stream, vertical );
d918 1
a918 1
  /*    tt_face_load_names                                                 */
d932 2
a933 2
  tt_face_load_names( TT_Face    face,
                      FT_Stream  stream )
d990 1
a990 1
    /* Some popular Asian fonts have an invalid `storageOffset' value   */
d1002 1
a1002 1
      FT_ERROR(( "tt_face_load_names: invalid `name' table\n" ));
d1044 1
a1044 1
      table->numNameRecords = (FT_UInt)( entry - table->names );
d1062 1
a1062 1
  /*    tt_face_free_names                                                 */
d1071 1
a1071 1
  tt_face_free_names( TT_Face  face )
d1097 1
a1097 1
  /*    tt_face_load_cmap                                                  */
d1112 2
d1115 2
a1116 2
  tt_face_load_cmap( TT_Face    face,
                     FT_Stream  stream )
d1141 99
d1245 1
a1245 1
  /*    tt_face_load_os2                                                   */
d1259 2
a1260 2
  tt_face_load_os2( TT_Face    face,
                    FT_Stream  stream )
d1388 1
a1388 1
  /*    tt_face_load_postscript                                            */
d1402 2
a1403 2
  tt_face_load_postscript( TT_Face    face,
                           FT_Stream  stream )
d1447 1
a1447 1
  /*    tt_face_load_pclt                                                  */
d1461 2
a1462 2
  tt_face_load_pclt( TT_Face    face,
                     FT_Stream  stream )
d1515 1
a1515 1
  /*    tt_face_load_gasp                                                  */
d1529 2
a1530 2
  tt_face_load_gasp( TT_Face    face,
                     FT_Stream  stream )
d1539 1
a1539 1
    FT_TRACE2(( "tt_face_load_gasp: %08p\n", face ));
d1590 1
a1590 1
  /*    tt_face_load_kern                                                  */
d1607 2
a1608 2
  tt_face_load_kern( TT_Face    face,
                     FT_Stream  stream )
d1743 1
a1743 1
  /*    tt_face_load_hdmx                                                  */
d1757 2
a1758 2
  tt_face_load_hdmx( TT_Face    face,
                     FT_Stream  stream )
d1826 1
a1826 1
  /*    tt_face_free_hdmx                                                  */
d1835 1
a1835 1
  tt_face_free_hdmx( TT_Face  face )
@


