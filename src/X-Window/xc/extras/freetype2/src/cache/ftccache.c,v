head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.29.47;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.01.19;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.01.19;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.21.00;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.38.20;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.08.58;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@/***************************************************************************/
/*                                                                         */
/*  ftccache.c                                                             */
/*                                                                         */
/*    The FreeType internal cache interface (body).                        */
/*                                                                         */
/*  Copyright 2000-2001 by                                                 */
/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
/*                                                                         */
/*  This file is part of the FreeType project, and may only be used,       */
/*  modified, and distributed under the terms of the FreeType project      */
/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
/*  this file you indicate that you have read the license and              */
/*  understand and accept it fully.                                        */
/*                                                                         */
/***************************************************************************/


#include <ft2build.h>
#include FT_CACHE_MANAGER_H
#include FT_INTERNAL_OBJECTS_H
#include FT_INTERNAL_DEBUG_H

#include "ftcerror.h"


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                   CACHE NODE DEFINITIONS                      *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

  FT_EXPORT_DEF( void )
  ftc_node_done( FTC_Node   node,
                 FTC_Cache  cache )
  {
    FTC_Family       family;
    FTC_FamilyEntry  entry;


    entry  = cache->manager->families.entries + node->fam_index;
    family = entry->family;

    /* remove from parent set table - eventually destroy the set */
    if ( --family->num_nodes <= 0 )
      FT_LruList_Remove( cache->families, (FT_LruNode) family );
  }


  /* add a new node to the head of the manager's circular MRU list */
  static void
  ftc_node_mru_link( FTC_Node     node,
                     FTC_Manager  manager )
  {
    FTC_Node  first = manager->nodes_list;


    if ( first )
    {
      node->mru_prev = first->mru_prev;
      node->mru_next = first;

      first->mru_prev->mru_next = node;
      first->mru_prev           = node;
    }
    else
    {
      node->mru_next = node;
      node->mru_prev = node;
    }

    manager->nodes_list = node;
    manager->num_nodes++;
  }


  /* remove a node from the manager's MRU list */
  static void
  ftc_node_mru_unlink( FTC_Node     node,
                       FTC_Manager  manager )
  {
    FTC_Node  prev  = node->mru_prev;
    FTC_Node  next  = node->mru_next;
    FTC_Node  first = manager->nodes_list;


    prev->mru_next = next;
    next->mru_prev = prev;

    if ( node->mru_next == first )
    {
      /* this is the last node in the list; update its head pointer */
      if ( node == first )
        manager->nodes_list = NULL;
      else
        first->mru_prev = prev;
    }

    node->mru_next = NULL;
    node->mru_prev = NULL;
    manager->num_nodes--;
  }


  /* move a node to the head of the manager's MRU list */
  static void
  ftc_node_mru_up( FTC_Node     node,
                   FTC_Manager  manager )
  {
    FTC_Node  first = manager->nodes_list;


    if ( node != first )
    {
      ftc_node_mru_unlink( node, manager );
      ftc_node_mru_link( node, manager );
    }
  }


  /* remove a node from its cache's hash table */
  static void
  ftc_node_hash_unlink( FTC_Node   node,
                        FTC_Cache  cache )
  {
    FTC_Node  *pnode = cache->buckets + ( node->hash % cache->size );


    for (;;)
    {
      if ( *pnode == NULL )
      {
        FT_ERROR(( "FreeType.cache.hash_unlink: unknown node!\n" ));
        return;
      }

      if ( *pnode == node )
      {
        *pnode     = node->link;
        node->link = NULL;

        cache->nodes--;
        return;
      }

      pnode = &(*pnode)->link;
    }
  }


  /* add a node to the "top" of its cache's hash table */
  static void
  ftc_node_hash_link( FTC_Node   node,
                      FTC_Cache  cache )
  {
    FTC_Node  *pnode = cache->buckets + ( node->hash % cache->size );


    node->link = *pnode;
    *pnode     = node;

    cache->nodes++;
  }


  /* remove a node from the cache manager */
  FT_EXPORT_DEF( void )
  ftc_node_destroy( FTC_Node     node,
                    FTC_Manager  manager )
  {
    FT_Memory        memory  = manager->library->memory;
    FTC_Cache        cache;
    FTC_FamilyEntry  entry;
    FTC_Cache_Class  clazz;


#ifdef FT_DEBUG_ERROR
    /* find node's cache */
    if ( node->fam_index >= manager->families.count )
    {
      FT_ERROR(( "ftc_node_destroy: invalid node handle\n" ));
      return;
    }
#endif

    entry = manager->families.entries + node->fam_index;
    cache = entry->cache;

#ifdef FT_DEBUG_ERROR
    if ( cache == NULL )
    {
      FT_ERROR(( "ftc_node_destroy: invalid node handle\n" ));
      return;
    }
#endif

    clazz = cache->clazz;

    manager->cur_weight -= clazz->node_weight( node, cache );

    /* remove node from mru list */
    ftc_node_mru_unlink( node, manager );

    /* remove node from cache's hash table */
    ftc_node_hash_unlink( node, cache );

    /* now finalize it */
    if ( clazz->node_done )
      clazz->node_done( node, cache );

    FREE( node );

    /* check, just in case of general corruption :-) */
    if ( manager->num_nodes <= 0 )
      FT_ERROR(( "ftc_node_destroy: invalid cache node count! = %d\n",
                  manager->num_nodes ));
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                   CACHE FAMILY DEFINITIONS                    *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/


  FT_EXPORT_DEF( FT_Error )
  ftc_family_init( FTC_Family  family,
                   FTC_Query   query,
                   FTC_Cache   cache )
  {
    FT_Error         error;
    FTC_Manager      manager = cache->manager;
    FT_Memory        memory  = manager->library->memory;
    FTC_FamilyEntry  entry;


    family->cache     = cache;
    family->num_nodes = 0;

    /* now add to manager's family table */
    error = ftc_family_table_alloc( &manager->families, memory, &entry );
    if ( !error )
    {
      entry->cache      = cache;
      entry->family     = family;
      family->fam_index = entry->index;

      query->family = family;   /* save family in query */
    }

    return error;
  }


  FT_EXPORT_DEF( void )
  ftc_family_done( FTC_Family  family )
  {
    FTC_Manager  manager = family->cache->manager;


    /* remove from manager's family table */
    ftc_family_table_free( &manager->families, family->fam_index );
  }


  /*************************************************************************/
  /*************************************************************************/
  /*****                                                               *****/
  /*****                    ABSTRACT CACHE CLASS                       *****/
  /*****                                                               *****/
  /*************************************************************************/
  /*************************************************************************/

#define FTC_PRIMES_MIN  7
#define FTC_PRIMES_MAX  13845163

  static const FT_UInt  ftc_primes[] =
  {
    7,
    11,
    19,
    37,
    73,
    109,
    163,
    251,
    367,
    557,
    823,
    1237,
    1861,
    2777,
    4177,
    6247,
    9371,
    14057,
    21089,
    31627,
    47431,
    71143,
    106721,
    160073,
    240101,
    360163,
    540217,
    810343,
    1215497,
    1823231,
    2734867,
    4102283,
    6153409,
    9230113,
    13845163,
  };


  static FT_UFast
  ftc_prime_closest( FT_UFast  num )
  {
    FT_UInt  i;


    for ( i = 0; i < sizeof ( ftc_primes ) / sizeof ( ftc_primes[0] ); i++ )
      if ( ftc_primes[i] > num )
        return ftc_primes[i];

    return FTC_PRIMES_MAX;
  }


#define FTC_CACHE_RESIZE_TEST( c )       \
          ( (c)->nodes*3 < (c)->size  || \
            (c)->size*3  < (c)->nodes )


  static void
  ftc_cache_resize( FTC_Cache  cache )
  {
    FT_UFast  new_size;


    new_size = ftc_prime_closest( cache->nodes );
    if ( new_size != cache->size )
    {
      FT_Memory  memory = cache->memory;
      FT_Error   error;
      FTC_Node*  new_buckets ;
      FT_ULong   i;


      /* no need to report an error; we'll simply keep using the same */
      /* buckets number / size                                        */
      if ( ALLOC_ARRAY( new_buckets, new_size, FTC_Node ) )
        return;

      for ( i = 0; i < cache->size; i++ )
      {
        FTC_Node   node, next, *pnode;
        FT_UFast   hash;


        node = cache->buckets[i];
        while ( node )
        {
          next  = node->link;
          hash  = node->hash % new_size;
          pnode = new_buckets + hash;

          node->link = pnode[0];
          pnode[0]   = node;

          node = next;
        }
      }

      if ( cache->buckets )
        FREE( cache->buckets );

      cache->buckets = new_buckets;
      cache->size    = new_size;
    }
  }


  FT_EXPORT_DEF( FT_Error )
  ftc_cache_init( FTC_Cache  cache )
  {
    FT_Memory        memory = cache->memory;
    FTC_Cache_Class  clazz  = cache->clazz;
    FT_Error         error;


    cache->nodes = 0;
    cache->size  = FTC_PRIMES_MIN;

    if ( ALLOC_ARRAY( cache->buckets, cache->size, FTC_Node ) )
      goto Exit;

    /* now, initialize the lru list of families for this cache */
    if ( clazz->family_size > 0 )
    {
      FT_LruList_ClassRec*  lru_class = &cache->family_class;


      lru_class->list_size = sizeof( FT_LruListRec );
      lru_class->list_init = NULL;
      lru_class->list_done = NULL;

      lru_class->node_size    = clazz->family_size;
      lru_class->node_init    = (FT_LruNode_InitFunc)   clazz->family_init;
      lru_class->node_done    = (FT_LruNode_DoneFunc)   clazz->family_done;
      lru_class->node_flush   = (FT_LruNode_FlushFunc)  NULL;
      lru_class->node_compare = (FT_LruNode_CompareFunc)clazz->family_compare;

      error = FT_LruList_New( (FT_LruList_Class) lru_class,
                              0,    /* max items == 0 => unbounded list */
                              cache,
                              memory,
                              &cache->families );
      if ( error )
        FREE( cache->buckets );
    }

  Exit:
    return error;
  }


  FT_EXPORT_DEF( void )
  ftc_cache_clear( FTC_Cache  cache )
  {
    if ( cache )
    {
      FT_Memory        memory  = cache->memory;
      FTC_Cache_Class  clazz   = cache->clazz;
      FTC_Manager      manager = cache->manager;
      FT_UFast         i;


      for ( i = 0; i < cache->size; i++ )
      {
        FTC_Node  *pnode = cache->buckets + i, next, node = *pnode;


        while ( node )
        {
          next        = node->link;
          node->link  = NULL;

          /* remove node from mru list */
          ftc_node_mru_unlink( node, manager );

          /* now finalize it */
          manager->cur_weight -= clazz->node_weight( node, cache );

          if ( clazz->node_done )
            clazz->node_done( node, cache );

          FREE( node );
          node = next;
        }
        cache->buckets[i] = NULL;
      }

      cache->nodes = 0;

      /* destroy the families */
      if ( cache->families )
        FT_LruList_Reset( cache->families );
    }
  }


  FT_EXPORT_DEF( void )
  ftc_cache_done( FTC_Cache  cache )
  {
    if ( cache )
    {
      FT_Memory  memory = cache->memory;


      ftc_cache_clear( cache );

      FREE( cache->buckets );
      cache->size = 0;

      if ( cache->families )
      {
        FT_LruList_Destroy( cache->families );
        cache->families = NULL;
      }
    }
  }


  /* Look up a node in "top" of its cache's hash table. */
  /* If not found, create a new node.                   */
  /*                                                    */
  FT_EXPORT_DEF( FT_Error )
  ftc_cache_lookup( FTC_Cache   cache,
                    FTC_Query   query,
                    FTC_Node   *anode )
  {
    FT_Error    error;
    FT_LruNode  lru;


    /* some argument checks are delayed to ftc_glyph_cache_lookup */
    if ( !cache || !query || !anode )
      return FTC_Err_Invalid_Argument;

    *anode = NULL;

    query->hash   = 0;
    query->family = NULL;

    error = FT_LruList_Lookup( cache->families, query, &lru );
    if ( !error )
    {
      FTC_Family  family = (FTC_Family) lru;
      FT_UFast    hash    = query->hash;
      FTC_Node*   bucket  = cache->buckets + (hash % cache->size);


      if ( query->family     != family                        ||
           family->fam_index >= cache->manager->families.size )
      {
        FT_ERROR((
          "ftc_cache_lookup: invalid query (bad 'family' field)\n" ));
        return FT_Err_Invalid_Argument;
      }

      if ( *bucket )
      {
        FTC_Node*             pnode   = bucket;
        FTC_Node_CompareFunc  compare = cache->clazz->node_compare;


        for ( ;; )
        {
          FTC_Node  node;


          node = *pnode;
          if ( node == NULL )
            break;

          if ( (FT_UInt)node->fam_index == family->fam_index &&
               compare( node, query, cache ) )
          {
            /* move to head of bucket list */
            if ( pnode != bucket )
            {
              *pnode     = node->link;
              node->link = *bucket;
              *bucket    = node;
            }

            /* move to head of MRU list */
            if ( node != cache->manager->nodes_list )
              ftc_node_mru_up( node, cache->manager );

            *anode = node;
            goto Exit;
          }

          pnode = &(*pnode)->link;
        }
      }

      /* didn't find a node, create a new one */
      {
        FTC_Cache_Class  clazz   = cache->clazz;
        FTC_Manager      manager = cache->manager;
        FT_Memory        memory  = cache->memory;
        FTC_Node         node;


        if ( ALLOC( node, clazz->node_size ) )
          goto Exit;

        node->fam_index = (FT_UShort) family->fam_index;
        node->hash      = query->hash;
        node->ref_count = 0;

        error = clazz->node_init( node, query, cache );
        if ( error )
        {
          FREE( node );
          goto Exit;
        }

        ftc_node_hash_link( node, cache );
        ftc_node_mru_link( node, cache->manager );

        cache->manager->cur_weight += clazz->node_weight( node, cache );

        /* now try to compress the node pool when necessary */
        if ( manager->cur_weight >= manager->max_weight )
        {
          node->ref_count++;
          FTC_Manager_Compress( manager );
          node->ref_count--;
        }

        /* try to resize the hash table if appropriate */
        if ( FTC_CACHE_RESIZE_TEST( cache ) )
          ftc_cache_resize( cache );

        *anode = node;
      }
    }

  Exit:
    return error;
  }


/* END */
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002 by                                           */
a26 8
#define FTC_HASH_MAX_LOAD  2
#define FTC_HASH_MIN_LOAD  1
#define FTC_HASH_SUB_LOAD  ( FTC_HASH_MAX_LOAD - FTC_HASH_MIN_LOAD )

/* this one _must_ be a power of 2! */
#define FTC_HASH_INITIAL_SIZE  8


d47 1
a47 1
    if ( --family->num_nodes == 0 )
d62 1
a62 6
      FTC_Node  last = first->mru_prev;


      FT_ASSERT( last->mru_next == first );

      node->mru_prev = last;
d65 2
a66 2
      last->mru_next  = node;
      first->mru_prev = node;
a69 2
      FT_ASSERT( manager->num_nodes == 0 );

a83 1
    FTC_Node  first = manager->nodes_list;
d86 1
d89 1
a89 4
    FT_ASSERT( first != NULL && manager->num_nodes > 0 );
    FT_ASSERT( next->mru_prev == node );
    FT_ASSERT( prev->mru_next == node );

a90 1
    prev->mru_next = next;
d92 1
a92 1
    if ( node == first )
d95 1
a95 1
      if ( node == next )
d98 1
a98 1
        manager->nodes_list = next;
d117 2
a118 15
      FTC_Node  prev = node->mru_prev;
      FTC_Node  next = node->mru_next;
      FTC_Node  last;


      prev->mru_next = next;
      next->mru_prev = prev;

      last            = first->mru_prev;
      node->mru_next  = first;
      node->mru_prev  = last;
      first->mru_prev = node;
      last->mru_next  = node;

      manager->nodes_list = node;
d124 1
a124 1
  static FT_Error
d128 1
a128 8
    FT_Error   error = 0;
    FTC_Node  *pnode;
    FT_UInt    idx, num_buckets;


    idx = (FT_UInt)( node->hash & cache->mask );
    if ( idx < cache->p )
      idx = (FT_UInt)( node->hash & ( 2 * cache->mask + 1 ) );
a129 1
    pnode = cache->buckets + idx;
d135 2
a136 2
        FT_ERROR(( "ftc_node_hash_unlink: unknown node!\n" ));
        return FT_Err_Ok;
d143 3
a145 1
        break;
a149 45

    num_buckets = ( cache->p + cache->mask + 1 );

    if ( ++cache->slack > (FT_Long)num_buckets * FTC_HASH_SUB_LOAD )
    {
      FT_UInt    p         = cache->p;
      FT_UInt    mask      = cache->mask;
      FT_UInt    old_index = p + mask;
      FTC_Node*  pold;


      if ( old_index+1 <= FTC_HASH_INITIAL_SIZE )
        goto Exit;

      if ( p == 0 )
      {
        FT_Memory  memory = cache->memory;


        cache->mask >>= 1;
        p             = cache->mask;

        if ( FT_RENEW_ARRAY( cache->buckets, ( mask + 1 ) * 2, (mask+1) ) )
        {
          FT_ERROR(( "ftc_node_hash_unlink: couldn't shunk buckets!\n" ));
          goto Exit;
        }
      }
      else
        p--;

      pnode = cache->buckets + p;
      while ( *pnode )
        pnode = &(*pnode)->link;

      pold   = cache->buckets + old_index;
      *pnode = *pold;
      *pold  = NULL;

      cache->slack -= FTC_HASH_MAX_LOAD;
      cache->p      = p;
    }

  Exit:
    return error;
a152 1

d154 1
a154 1
  static FT_Error
d158 1
a158 8
    FTC_Node  *pnode;
    FT_UInt    idx;
    FT_Error   error = 0;


    idx = (FT_UInt)( node->hash & cache->mask );
    if ( idx < cache->p )
      idx = (FT_UInt)( node->hash & (2 * cache->mask + 1 ) );
a159 1
    pnode = cache->buckets + idx;
d164 1
a164 52
    if ( --cache->slack < 0 )
    {
      FT_UInt    p     = cache->p;
      FT_UInt    mask  = cache->mask;
      FTC_Node   new_list;


      /* split a single bucket */
      new_list = NULL;
      pnode    = cache->buckets + p;

      for (;;)
      {
        node = *pnode;
        if ( node == NULL )
          break;

        if ( node->hash & ( mask + 1 ) )
        {
          *pnode     = node->link;
          node->link = new_list;
          new_list   = node;
        }
        else
          pnode = &node->link;
      }

      cache->buckets[p + mask + 1] = new_list;

      cache->slack += FTC_HASH_MAX_LOAD;

      if ( p >= mask )
      {
        FT_Memory  memory = cache->memory;


        if ( FT_RENEW_ARRAY( cache->buckets,
                             ( mask + 1 ) * 2, ( mask + 1 ) * 4 ) )
        {
          FT_ERROR(( "ftc_node_hash_link: couldn't expand buckets!\n" ));
          goto Exit;
        }

        cache->mask = 2 * mask + 1;
        cache->p    = 0;
      }
      else
        cache->p = p + 1;
    }

  Exit:
    return error;
a167 2


d213 1
a213 1
    FT_FREE( node );
a214 1
#if 0
d216 1
a216 1
    if ( manager->num_nodes == 0 )
a218 1
#endif
d263 1
a263 3
    if ( family && family->cache )
    {
      FTC_Manager  manager = family->cache->manager;
d266 2
a267 3
      /* remove from manager's family table */
      ftc_family_table_free( &manager->families, family->fam_index );
    }
d279 109
d398 2
a399 3
    cache->p     = 0;
    cache->mask  = FTC_HASH_INITIAL_SIZE - 1;
    cache->slack = FTC_HASH_INITIAL_SIZE * FTC_HASH_MAX_LOAD;
d401 1
a401 1
    if ( FT_NEW_ARRAY( cache->buckets, FTC_HASH_INITIAL_SIZE * 2 ) )
d426 1
a426 1
        FT_FREE( cache->buckets );
a442 1
      FT_UInt          count;
a443 1
      count = cache->p + cache->mask + 1;
d445 1
a445 1
      for ( i = 0; i < count; i++ )
d464 1
a464 1
          FT_FREE( node );
d470 1
a470 1
      cache->p = 0;
d489 2
a490 3
      FT_FREE( cache->buckets );
      cache->mask  = 0;
      cache->slack = 0;
d509 2
a510 4
    FT_Error     error = FT_Err_Ok;
    FTC_Manager  manager;
    FT_LruNode   lru;
    FT_UInt      free_count = 0;
d513 1
d522 6
a527 1
    manager = cache->manager;
a528 20
   /*  here's a small note explaining what's hapenning in the code below.
    *
    *  we need to deal intelligently with out-of-memory (OOM) conditions
    *  when trying to create a new family or cache node during the lookup.
    *
    *  when an OOM is detected, we'll try to free one or more "old" nodes
    *  from the cache, then try again. it may be necessary to do that several
    *  times, so a loop is needed.
    *
    *  the local variable "free_count" holds the number of "old" nodes to
    *  discard on each attempt. it starts at 1 and doubles on each iteration.
    *  the loop stops when:
    *
    *   - a non-OOM error is detected
    *   - a succesful lookup is performed
    *   - there are no more unused nodes in the cache
    *
    *  for the record, remember that all used nodes appear _before_
    *  unused ones in the manager's MRU node list.
    */
d530 2
a531 2
    for (;;)
    {
d533 3
a535 38
        /* first of all, find the relevant family */
        FT_LruList              list    = cache->families;
        FT_LruNode              fam, *pfam;
        FT_LruNode_CompareFunc  compare = list->clazz->node_compare;

        pfam = &list->nodes;
        for (;;)
        {
          fam = *pfam;
          if ( fam == NULL )
          {
            error = FT_LruList_Lookup( list, query, &lru );
            if ( error )
              goto Fail;

            goto Skip;
          }

          if ( compare( fam, query, list->data ) )
            break;

          pfam = &fam->next;
        }

        FT_ASSERT( fam != NULL );

        /* move to top of list when needed */
        if ( fam != list->nodes )
        {
          *pfam       = fam->next;
          fam->next   = list->nodes;
          list->nodes = fam;
        }

        lru = fam;

      Skip:
        ;
d538 1
d540 2
a541 6
        FTC_Manager  manager = cache->manager;
        FTC_Family   family  = (FTC_Family) lru;
        FT_UFast     hash    = query->hash;
        FTC_Node*    bucket;
        FT_UInt      idx;

a542 3
        idx = hash & cache->mask;
        if ( idx < cache->p )
          idx = hash & ( cache->mask * 2 + 1 );
d544 1
a544 5
        bucket  = cache->buckets + idx;


        if ( query->family     != family                 ||
             family->fam_index >= manager->families.size )
d546 1
a546 5
          FT_ERROR((
            "ftc_cache_lookup: invalid query (bad 'family' field)\n" ));
          error = FTC_Err_Invalid_Argument;
          goto Exit;
        }
a547 4
        if ( *bucket )
        {
          FTC_Node*             pnode   = bucket;
          FTC_Node_CompareFunc  compare = cache->clazz->node_compare;
d549 3
d553 2
a554 1
          for ( ;; )
d556 2
a557 10
            FTC_Node  node;


            node = *pnode;
            if ( node == NULL )
              break;

            if ( node->hash == hash                            &&
                 (FT_UInt)node->fam_index == family->fam_index &&
                 compare( node, query, cache ) )
d559 3
a561 14
              /* move to head of bucket list */
              if ( pnode != bucket )
              {
                *pnode     = node->link;
                node->link = *bucket;
                *bucket    = node;
              }

              /* move to head of MRU list */
              if ( node != manager->nodes_list )
                ftc_node_mru_up( node, manager );

              *anode = node;
              goto Exit;
d564 3
a566 3
            pnode = &node->link;
          }
        }
d568 2
a569 19
        /* didn't find a node, create a new one */
        {
          FTC_Cache_Class  clazz   = cache->clazz;
          FT_Memory        memory  = cache->memory;
          FTC_Node         node;


          if ( FT_ALLOC( node, clazz->node_size ) )
            goto Fail;

          node->fam_index = (FT_UShort) family->fam_index;
          node->hash      = query->hash;
          node->ref_count = 0;

          error = clazz->node_init( node, query, cache );
          if ( error )
          {
            FT_FREE( node );
            goto Fail;
d572 1
a572 21
          error = ftc_node_hash_link( node, cache );
          if ( error )
          {
            clazz->node_done( node, cache );
            FT_FREE( node );
            goto Fail;
          }

          ftc_node_mru_link( node, cache->manager );

          cache->manager->cur_weight += clazz->node_weight( node, cache );

          /* now try to compress the node pool when necessary */
          if ( manager->cur_weight >= manager->max_weight )
          {
            node->ref_count++;
            FTC_Manager_Compress( manager );
            node->ref_count--;
          }

          *anode = node;
a573 4

       /* all is well, exit now
        */
        goto Exit;
d576 1
a576 7
    Fail:
      if ( error != FT_Err_Out_Of_Memory )
        goto Exit;

     /* there is not enough memory, try to release some unused nodes
      * from the cache to make room for a new one.
      */
d578 4
a581 1
        FT_UInt   new_count;
a582 1
        new_count = 1 + free_count*2;
d584 1
a584 2
        /* check overflow and bounds */
        if ( new_count < free_count || free_count > manager->num_nodes )
d587 3
a589 1
        free_count = new_count;
d591 2
a592 1
        /* try to remove "new_count" nodes from the list */
d594 3
a596 2
          FTC_Node   first = manager->nodes_list;
          FTC_Node   node;
d598 2
a599 2
          if ( first == NULL )  /* empty list ! */
            goto Exit;
d601 1
a601 5
         /* go to last node - it's a circular list */
          node = first->mru_prev;
          for ( ; node && new_count > 0; new_count-- )
          {
            FTC_Node  prev = node->mru_prev;
d603 7
a609 9
           /* used nodes always appear before unused one in the MRU
            * list. if we find one here, we'd better stop right now
            * our iteration
            */
            if ( node->ref_count > 0 )
            {
              /* if there are no unused nodes in the list, we'd better exit */
              if ( new_count == free_count )
                goto Exit;
d611 3
a613 7
              break;
            }

            ftc_node_destroy( node, manager );

            if ( node == first )
              break;
d615 1
a615 3
            node = prev;
          }
        }
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright © 1968-2003  The authors of And contributors to UNIX®, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d7 1
a7 1
/*  Copyright 2000-2001, 2002 by                                           */
a26 11
#ifdef FTC_CACHE_USE_LINEAR_HASHING

#define FTC_HASH_MAX_LOAD  2
#define FTC_HASH_MIN_LOAD  1
#define FTC_HASH_SUB_LOAD  ( FTC_HASH_MAX_LOAD - FTC_HASH_MIN_LOAD )

/* this one _must_ be a power of 2! */
#define FTC_HASH_INITIAL_SIZE  8

#endif /* FTC_CACHE_USE_LINEAR_HASHING */

d47 1
a47 1
    if ( --family->num_nodes == 0 )
d62 1
a62 6
      FTC_Node  last = first->mru_prev;


      FT_ASSERT( last->mru_next == first );

      node->mru_prev = last;
d65 2
a66 2
      last->mru_next  = node;
      first->mru_prev = node;
a69 2
      FT_ASSERT( manager->num_nodes == 0 );

a83 1
    FTC_Node  first = manager->nodes_list;
d86 1
d89 1
a89 4
    FT_ASSERT( first != NULL && manager->num_nodes > 0 );
    FT_ASSERT( next->mru_prev == node );
    FT_ASSERT( prev->mru_next == node );

a90 1
    prev->mru_next = next;
d92 1
a92 1
    if ( node == first )
d95 1
a95 1
      if ( node == next )
d98 1
a98 1
        manager->nodes_list = next;
d117 2
a118 94
      FTC_Node  prev = node->mru_prev;
      FTC_Node  next = node->mru_next;
      FTC_Node  last;


      prev->mru_next = next;
      next->mru_prev = prev;

      last            = first->mru_prev;
      node->mru_next  = first;
      node->mru_prev  = last;
      first->mru_prev = node;
      last->mru_next  = node;

      manager->nodes_list = node;
    }
  }


#ifdef FTC_CACHE_USE_LINEAR_HASHING

  /* remove a node from its cache's hash table */
  static FT_Error
  ftc_node_hash_unlink( FTC_Node   node,
                        FTC_Cache  cache )
  {
    FT_Error   error = 0;
    FTC_Node  *pnode;
    FT_UInt    index, num_buckets;

  
    index = (FT_UInt)( node->hash & cache->mask );
    if ( index < cache->p )
      index = (FT_UInt)( node->hash & ( 2 * cache->mask + 1 ) );

    pnode = cache->buckets + index;

    for (;;)
    {
      if ( *pnode == NULL )
      {
        FT_ERROR(( "ftc_node_hash_unlink: unknown node!\n" ));
        return FT_Err_Ok;
      }

      if ( *pnode == node )
      {
        *pnode     = node->link;
        node->link = NULL;
        break;
      }

      pnode = &(*pnode)->link;
    }

    num_buckets = ( cache->p + cache->mask + 1 );

    if ( ++cache->slack > (FT_Long)num_buckets * FTC_HASH_SUB_LOAD )
    {
      FT_UInt    p         = cache->p;
      FT_UInt    mask      = cache->mask;
      FT_UInt    old_index = p + mask;
      FTC_Node*  pold;


      FT_ASSERT( old_index >= FTC_HASH_INITIAL_SIZE );

      if ( p == 0 )
      {
        FT_Memory  memory = cache->memory;


        cache->mask >>= 1;
        p             = cache->mask;

        if ( FT_RENEW_ARRAY( cache->buckets, ( mask + 1 ) * 2, (mask+1) ) )
        {
          FT_ERROR(( "ftc_node_hash_unlink: couldn't shunk buckets!\n" ));
          goto Exit;
        }
      }
      else
        p--;

      pnode = cache->buckets + p;
      while ( *pnode )
        pnode = &(*pnode)->link;

      pold   = cache->buckets + old_index;
      *pnode = *pold;
      *pold  = NULL;

      cache->slack -= FTC_HASH_MAX_LOAD;
      cache->p      = p;
a119 3

  Exit:
    return error;
a121 1
#else /* !FTC_CACHE_USE_LINEAR_HASHING */
a151 79
#endif /* !FTC_CACHE_USE_LINEAR_HASHING */


#ifdef FTC_CACHE_USE_LINEAR_HASHING

  /* add a node to the "top" of its cache's hash table */
  static FT_Error
  ftc_node_hash_link( FTC_Node   node,
                      FTC_Cache  cache )
  {
    FTC_Node  *pnode;
    FT_UInt    index;
    FT_Error   error = 0;


    index = (FT_UInt)( node->hash & cache->mask );
    if ( index < cache->p )
      index = (FT_UInt)( node->hash & (2 * cache->mask + 1 ) );

    pnode = cache->buckets + index;

    node->link = *pnode;
    *pnode     = node;

    if ( --cache->slack < 0 )
    {
      FT_UInt    p     = cache->p;
      FT_UInt    mask  = cache->mask;
      FTC_Node   new_list;


      /* split a single bucket */
      new_list = NULL;
      pnode    = cache->buckets + p;

      for (;;)
      {
        node = *pnode;
        if ( node == NULL )
          break;

        if ( node->hash & ( mask + 1 ) )
        {
          *pnode     = node->link;
          node->link = new_list;
          new_list   = node;
        }
        else
          pnode = &node->link;
      }

      cache->buckets[p + mask + 1] = new_list;

      cache->slack += FTC_HASH_MAX_LOAD;

      if ( p >= mask )
      {
        FT_Memory  memory = cache->memory;


        if ( FT_RENEW_ARRAY( cache->buckets,
                             ( mask + 1 ) * 2, ( mask + 1 ) * 4 ) )
        {
          FT_ERROR(( "ftc_node_hash_link: couldn't expand buckets!\n" ));
          goto Exit;
        }

        cache->mask = 2 * mask + 1;
        cache->p    = 0;
      }
      else
        cache->p = p + 1;
    }

  Exit:
    return error;
  }

#else /* !FTC_CACHE_USE_LINEAR_HASHING */
a166 3
#endif /* !FTC_CACHE_USE_LINEAR_HASHING */


d213 1
a213 1
    FT_FREE( node );
d216 1
a216 1
    if ( manager->num_nodes == 0 )
a278 6
#ifdef FTC_CACHE_USE_LINEAR_HASHING

  /* nothing */

#else /* !FTC_CACHE_USE_LINEAR_HASHING */

d358 1
a358 1
      if ( FT_NEW_ARRAY( new_buckets, new_size ) )
d363 2
a364 2
        FTC_Node  node, next, *pnode;
        FT_UFast  hash;
d382 1
a382 1
        FT_FREE( cache->buckets );
a385 2

      FT_UNUSED( error );
a388 2
#endif /* !FTC_CACHE_USE_LINEAR_HASHING */

a397 11
#ifdef FTC_CACHE_USE_LINEAR_HASHING

    cache->p     = 0;
    cache->mask  = FTC_HASH_INITIAL_SIZE - 1;
    cache->slack = FTC_HASH_INITIAL_SIZE * FTC_HASH_MAX_LOAD;

    if ( FT_NEW_ARRAY( cache->buckets, FTC_HASH_INITIAL_SIZE * 2 ) )
      goto Exit;

#else /* !FTC_CACHE_USE_LINEAR_HASHING */

d401 1
a401 1
    if ( FT_NEW_ARRAY( cache->buckets, cache->size ) )
a403 2
#endif /* !FTC_CACHE_USE_LINEAR_HASHING */

d426 1
a426 1
        FT_FREE( cache->buckets );
a442 1
      FT_UInt          count;
a443 5
#ifdef FTC_CACHE_USE_LINEAR_HASHING
      count = cache->p + cache->mask + 1;
#else
      count = cache->size;
#endif
d445 1
a445 1
      for ( i = 0; i < count; i++ )
d464 1
a464 1
          FT_FREE( node );
a469 3
#ifdef FTC_CACHE_USE_LINEAR_HASHING
      cache->p = 0;
#else
d471 1
a471 1
#endif
d489 1
a489 5
      FT_FREE( cache->buckets );
#ifdef FTC_CACHE_USE_LINEAR_HASHING
      cache->mask  = 0;
      cache->slack = 0;
#else
a490 1
#endif
d509 1
a509 1
    FT_Error    error = FT_Err_Ok;
d513 1
a521 46
#if 1

    /* XXX: we break encapsulation for the sake of speed! */
    {
      /* first of all, find the relevant family */
      FT_LruList              list    = cache->families;
      FT_LruNode              fam, *pfam;
      FT_LruNode_CompareFunc  compare = list->clazz->node_compare;

      pfam = &list->nodes;
      for (;;)
      {
        fam = *pfam;
        if ( fam == NULL )
        {
          error = FT_LruList_Lookup( list, query, &lru );
          if ( error )
            goto Exit;

          goto Skip;
        }

        if ( compare( fam, query, list->data ) )
          break;

        pfam = &fam->next;
      }

      FT_ASSERT( fam != NULL );

      /* move to top of list when needed */
      if ( fam != list->nodes )
      {
        *pfam       = fam->next;
        fam->next   = list->nodes;
        list->nodes = fam;
      }

      lru = fam;

    Skip:
      ;
    }

#else

a523 2

#endif
d527 1
a527 18
      FTC_Node*   bucket;

#ifdef FTC_CACHE_USE_LINEAR_HASHING

      FT_UInt  index;


      index = hash & cache->mask;
      if ( index < cache->p )
        index = hash & ( cache->mask * 2 + 1 );

      bucket  = cache->buckets + index;

#else

      bucket  = cache->buckets + (hash % cache->size);

#endif
d535 1
a535 1
        return FTC_Err_Invalid_Argument;
d553 1
a553 2
          if ( node->hash == hash                            &&
               (FT_UInt)node->fam_index == family->fam_index &&
d572 1
a572 1
          pnode = &node->link;
d584 1
a584 1
        if ( FT_ALLOC( node, clazz->node_size ) )
d594 1
a594 1
          FT_FREE( node );
a597 9
#ifdef FTC_CACHE_USE_LINEAR_HASHING
        error = ftc_node_hash_link( node, cache );
        if ( error )
        {
          clazz->node_done( node, cache );
          FT_FREE( node );
          goto Exit;
        }
#else
a598 2
#endif

a610 1
#ifndef FTC_CACHE_USE_LINEAR_HASHING
a613 1
#endif
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d27 2
d36 1
d158 2
d167 1
a167 2
    FT_UInt    idx, num_buckets;

d169 4
a172 3
    idx = (FT_UInt)( node->hash & cache->mask );
    if ( idx < cache->p )
      idx = (FT_UInt)( node->hash & ( 2 * cache->mask + 1 ) );
d174 1
a174 1
    pnode = cache->buckets + idx;
d204 1
a204 2
      if ( old_index+1 <= FTC_HASH_INITIAL_SIZE )
        goto Exit;
d239 32
d273 2
d281 1
a281 1
    FT_UInt    idx;
d285 3
a287 3
    idx = (FT_UInt)( node->hash & cache->mask );
    if ( idx < cache->p )
      idx = (FT_UInt)( node->hash & (2 * cache->mask + 1 ) );
d289 1
a289 1
    pnode = cache->buckets + idx;
d348 17
a414 1
#if 0
a418 1
#endif
d463 1
a463 3
    if ( family && family->cache )
    {
      FTC_Manager  manager = family->cache->manager;
d466 2
a467 3
      /* remove from manager's family table */
      ftc_family_table_free( &manager->families, family->fam_index );
    }
d479 119
d608 2
d617 10
d668 1
d670 3
d699 1
d701 3
a703 1

d722 1
d725 3
d746 2
a747 4
    FT_Error     error = FT_Err_Ok;
    FTC_Manager  manager;
    FT_LruNode   lru;
    FT_UInt      free_count = 0;
d758 1
a758 1
    manager = cache->manager;
d760 6
a765 20
   /*  here's a small note explaining what's hapenning in the code below.
    *
    *  we need to deal intelligently with out-of-memory (OOM) conditions
    *  when trying to create a new family or cache node during the lookup.
    *
    *  when an OOM is detected, we'll try to free one or more "old" nodes
    *  from the cache, then try again. it may be necessary to do that several
    *  times, so a loop is needed.
    *
    *  the local variable "free_count" holds the number of "old" nodes to
    *  discard on each attempt. it starts at 1 and doubles on each iteration.
    *  the loop stops when:
    *
    *   - a non-OOM error is detected
    *   - a succesful lookup is performed
    *   - there are no more unused nodes in the cache
    *
    *  for the record, remember that all used nodes appear _before_
    *  unused ones in the manager's MRU node list.
    */
d767 2
a768 2
    for (;;)
    {
d770 2
a771 7
        /* first of all, find the relevant family */
        FT_LruList              list    = cache->families;
        FT_LruNode              fam, *pfam;
        FT_LruNode_CompareFunc  compare = list->clazz->node_compare;

        pfam = &list->nodes;
        for (;;)
d773 3
a775 12
          fam = *pfam;
          if ( fam == NULL )
          {
            error = FT_LruList_Lookup( list, query, &lru );
            if ( error )
              goto Fail;

            goto Skip;
          }

          if ( compare( fam, query, list->data ) )
            break;
d777 1
a777 1
          pfam = &fam->next;
d780 2
a781 1
        FT_ASSERT( fam != NULL );
d783 2
a784 7
        /* move to top of list when needed */
        if ( fam != list->nodes )
        {
          *pfam       = fam->next;
          fam->next   = list->nodes;
          list->nodes = fam;
        }
d786 1
a786 1
        lru = fam;
d788 6
a793 2
      Skip:
        ;
d796 1
a796 6
      {
        FTC_Manager  manager = cache->manager;
        FTC_Family   family  = (FTC_Family) lru;
        FT_UFast     hash    = query->hash;
        FTC_Node*    bucket;
        FT_UInt      idx;
d798 3
d802 1
a802 3
        idx = hash & cache->mask;
        if ( idx < cache->p )
          idx = hash & ( cache->mask * 2 + 1 );
d804 8
a811 1
        bucket  = cache->buckets + idx;
d813 1
d815 1
a815 8
        if ( query->family     != family                 ||
             family->fam_index >= manager->families.size )
        {
          FT_ERROR((
            "ftc_cache_lookup: invalid query (bad 'family' field)\n" ));
          error = FTC_Err_Invalid_Argument;
          goto Exit;
        }
a816 4
        if ( *bucket )
        {
          FTC_Node*             pnode   = bucket;
          FTC_Node_CompareFunc  compare = cache->clazz->node_compare;
d818 3
d822 1
a822 3
          for ( ;; )
          {
            FTC_Node  node;
d824 1
d826 1
a826 3
            node = *pnode;
            if ( node == NULL )
              break;
d828 1
a828 15
            if ( node->hash == hash                            &&
                 (FT_UInt)node->fam_index == family->fam_index &&
                 compare( node, query, cache ) )
            {
              /* move to head of bucket list */
              if ( pnode != bucket )
              {
                *pnode     = node->link;
                node->link = *bucket;
                *bucket    = node;
              }

              /* move to head of MRU list */
              if ( node != manager->nodes_list )
                ftc_node_mru_up( node, manager );
a829 3
              *anode = node;
              goto Exit;
            }
d831 7
a837 3
            pnode = &node->link;
          }
        }
d839 4
a842 5
        /* didn't find a node, create a new one */
        {
          FTC_Cache_Class  clazz   = cache->clazz;
          FT_Memory        memory  = cache->memory;
          FTC_Node         node;
d845 3
a847 2
          if ( FT_ALLOC( node, clazz->node_size ) )
            goto Fail;
a848 3
          node->fam_index = (FT_UShort) family->fam_index;
          node->hash      = query->hash;
          node->ref_count = 0;
d850 3
a852 6
          error = clazz->node_init( node, query, cache );
          if ( error )
          {
            FT_FREE( node );
            goto Fail;
          }
d854 3
a856 2
          error = ftc_node_hash_link( node, cache );
          if ( error )
d858 7
a864 4
            clazz->node_done( node, cache );
            FT_FREE( node );
            goto Fail;
          }
d866 3
a868 1
          ftc_node_mru_link( node, cache->manager );
d870 2
a871 8
          cache->manager->cur_weight += clazz->node_weight( node, cache );

          /* now try to compress the node pool when necessary */
          if ( manager->cur_weight >= manager->max_weight )
          {
            node->ref_count++;
            FTC_Manager_Compress( manager );
            node->ref_count--;
d874 1
a874 1
          *anode = node;
a875 4

       /* all is well, exit now
        */
        goto Exit;
d878 1
a878 7
    Fail:
      if ( error != FT_Err_Out_Of_Memory )
        goto Exit;

     /* there is not enough memory, try to release some unused nodes
      * from the cache to make room for a new one.
      */
d880 4
a883 1
        FT_UInt   new_count;
a884 1
        new_count = 1 + free_count*2;
d886 1
a886 2
        /* check overflow and bounds */
        if ( new_count < free_count || free_count > manager->num_nodes )
d889 3
a891 1
        free_count = new_count;
d893 2
a894 1
        /* try to remove "new_count" nodes from the list */
d896 3
a898 2
          FTC_Node   first = manager->nodes_list;
          FTC_Node   node;
d900 11
a910 2
          if ( first == NULL )  /* empty list ! */
            goto Exit;
d912 1
a912 5
         /* go to last node - it's a circular list */
          node = first->mru_prev;
          for ( ; node && new_count > 0; new_count-- )
          {
            FTC_Node  prev = node->mru_prev;
d914 1
a914 9
           /* used nodes always appear before unused one in the MRU
            * list. if we find one here, we'd better stop right now
            * our iteration
            */
            if ( node->ref_count > 0 )
            {
              /* if there are no unused nodes in the list, we'd better exit */
              if ( new_count == free_count )
                goto Exit;
d916 7
a922 2
              break;
            }
d924 5
a928 4
            ftc_node_destroy( node, manager );

            if ( node == first )
              break;
d930 1
a930 3
            node = prev;
          }
        }
@


