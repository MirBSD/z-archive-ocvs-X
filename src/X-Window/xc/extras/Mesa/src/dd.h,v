head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.28.14;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.00.58;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.00.58;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.19.56;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.28.23;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.04.35;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@/* $XFree86: xc/extras/Mesa/src/dd.h,v 1.11 2001/10/28 03:32:06 tsi Exp $ */
/*
 * Mesa 3-D graphics library
 * Version:  3.4
 * 
 * Copyright (C) 1999-2000  Brian Paul   All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */



#ifndef DD_INCLUDED
#define DD_INCLUDED


#include "macros.h"


struct gl_pixelstore_attrib;


struct vertex_buffer;
struct immediate;
struct gl_pipeline_stage;


/* THIS FILE ONLY INCLUDED BY types.h !!!!! */


/*
 *                      Device Driver (DD) interface
 *
 *
 * All device driver functions are accessed through pointers in the
 * dd_function_table struct (defined below) which is stored in the GLcontext
 * struct.  Since the device driver is strictly accessed trough a table of
 * function pointers we can:
 *   1. switch between a number of different device drivers at runtime.
 *   2. use optimized functions dependant on current rendering state or
 *      frame buffer configuration.
 *
 * The function pointers in the dd_function_table struct are divided into
 * two groups:  mandatory and optional.
 * Mandatory functions have to be implemented by every device driver.
 * Optional functions may or may not be implemented by the device driver.
 * The optional functions provide ways to take advantage of special hardware
 * or optimized algorithms.
 *
 * The function pointers in the dd_function_table struct should first be
 * initialized in the driver's "MakeCurrent" function.  The "MakeCurrent"
 * function is a little different in each device driver.  See the X/Mesa,
 * GLX, or OS/Mesa drivers for examples.
 *
 * Later, Mesa may call the dd_function_table's UpdateState() function.
 * This function should initialize the dd_function_table's pointers again.
 * The UpdateState() function is called whenever the core (GL) rendering
 * state is changed in a way which may effect rasterization.  For example,
 * the TriangleFunc() pointer may have to point to different functions
 * depending on whether smooth or flat shading is enabled.
 *
 * Note that the first argument to every device driver function is a
 * GLcontext *.  In turn, the GLcontext->DriverCtx pointer points to
 * the driver-specific context struct.  See the X/Mesa or OS/Mesa interface
 * for an example.
 *
 * For more information about writing a device driver see the ddsample.c
 * file and other device drivers (X/xmesa[1234].c, OSMesa/osmesa.c, etc)
 * for examples.
 *
 *
 * Look below in the dd_function_table struct definition for descriptions
 * of each device driver function.
 * 
 *
 * In the future more function pointers may be added for glReadPixels
 * glCopyPixels, etc.
 *
 *
 * Notes:
 * ------
 *   RGBA = red/green/blue/alpha
 *   CI = color index (color mapped mode)
 *   mono = all pixels have the same color or index
 *
 *   The write_ functions all take an array of mask flags which indicate
 *   whether or not the pixel should be written.  One special case exists
 *   in the write_color_span function: if the mask array is NULL, then
 *   draw all pixels.  This is an optimization used for glDrawPixels().
 *
 * IN ALL CASES:
 *      X coordinates start at 0 at the left and increase to the right
 *      Y coordinates start at 0 at the bottom and increase upward
 *
 */




/* Used by the GetParameteri device driver function */
#define DD_HAVE_HARDWARE_FOG         3



/* Mask bits sent to the driver Clear() function */
#define DD_FRONT_LEFT_BIT  FRONT_LEFT_BIT         /* 1 */
#define DD_FRONT_RIGHT_BIT FRONT_RIGHT_BIT        /* 2 */
#define DD_BACK_LEFT_BIT   BACK_LEFT_BIT          /* 4 */
#define DD_BACK_RIGHT_BIT  BACK_RIGHT_BIT         /* 8 */
#define DD_DEPTH_BIT       GL_DEPTH_BUFFER_BIT    /* 0x00000100 */
#define DD_STENCIL_BIT     GL_STENCIL_BUFFER_BIT  /* 0x00000400 */
#define DD_ACCUM_BIT       GL_ACCUM_BUFFER_BIT    /* 0x00000200 */



/*
 * Device Driver function table.
 */
struct dd_function_table {

   /**********************************************************************
    *** Mandatory functions:  these functions must be implemented by   ***
    *** every device driver.                                           ***
    **********************************************************************/

   const GLubyte * (*GetString)( GLcontext *ctx, GLenum name );
   /* Return a string as needed by glGetString().
    * Only the GL_RENDERER token must be implemented.  Otherwise,
    * NULL can be returned.
    */

   void (*UpdateState)( GLcontext *ctx );
   /*
    * UpdateState() is called whenver Mesa thinks the device driver should
    * update its state and/or the other pointers (such as PointsFunc,
    * LineFunc, or TriangleFunc).
    */

   void (*ClearIndex)( GLcontext *ctx, GLuint index );
   /*
    * Called whenever glClearIndex() is called.  Set the index for clearing
    * the color buffer when in color index mode.
    */

   void (*ClearColor)( GLcontext *ctx, GLubyte red, GLubyte green,
                                        GLubyte blue, GLubyte alpha );
   /*
    * Called whenever glClearColor() is called.  Set the color for clearing
    * the color buffer when in RGBA mode.
    */

   GLbitfield (*Clear)( GLcontext *ctx, GLbitfield mask, GLboolean all,
                        GLint x, GLint y, GLint width, GLint height );
   /* Clear the color/depth/stencil/accum buffer(s).
    * 'mask' is a bitmask of the DD_*_BIT values defined above that indicates
    * which buffers need to be cleared.  The driver should clear those
    * buffers then return a new bitmask indicating which buffers should be
    * cleared by software Mesa.
    * If 'all' is true then the clear the whole buffer, else clear only the
    * region defined by (x,y,width,height).
    * This function must obey the glColorMask, glIndexMask and glStencilMask
    * settings!  Software Mesa can do masked clears if the device driver can't.
    */

   void (*Index)( GLcontext *ctx, GLuint index );
   /*
    * Sets current color index for drawing flat-shaded primitives.
    * This index should also be used in the "mono" drawing functions.
    */

   void (*Color)( GLcontext *ctx,
                  GLubyte red, GLubyte green, GLubyte glue, GLubyte alpha );
   /*
    * Sets current color for drawing flat-shaded primitives.
    * This color should also be used in the "mono" drawing functions.
    */

   GLboolean (*SetDrawBuffer)( GLcontext *ctx, GLenum buffer );
   /*
    * Specifies the current buffer for writing.
    * The following values must be accepted when applicable:
    *    GL_FRONT_LEFT - this buffer always exists
    *    GL_BACK_LEFT - when double buffering
    *    GL_FRONT_RIGHT - when using stereo
    *    GL_BACK_RIGHT - when using stereo and double buffering
    * The folowing values may optionally be accepted.  Return GL_TRUE
    * if accepted, GL_FALSE if not accepted.  In practice, only drivers
    * which can write to multiple color buffers at once should accept
    * these values.
    *    GL_FRONT - write to front left and front right if it exists
    *    GL_BACK - write to back left and back right if it exists
    *    GL_LEFT - write to front left and back left if it exists
    *    GL_RIGHT - write to right left and back right if they exist
    *    GL_FRONT_AND_BACK - write to all four buffers if they exist
    *    GL_NONE - disable buffer write in device driver.
    */

   void (*SetReadBuffer)( GLcontext *ctx, GLframebuffer *colorBuffer,
                          GLenum buffer );
   /*
    * Specifies the current buffer for reading.
    * colorBuffer will be one of:
    *    GL_FRONT_LEFT - this buffer always exists
    *    GL_BACK_LEFT - when double buffering
    *    GL_FRONT_RIGHT - when using stereo
    *    GL_BACK_RIGHT - when using stereo and double buffering
    */

   void (*GetBufferSize)( GLcontext *ctx, GLuint *width, GLuint *height );
   /*
    * Returns the width and height of the current color buffer.
    */


   /***
    *** Functions for writing pixels to the frame buffer:
    ***/

   void (*WriteRGBASpan)( const GLcontext *ctx,
                          GLuint n, GLint x, GLint y,
                          CONST GLubyte rgba[][4], const GLubyte mask[] );
   void (*WriteRGBSpan)( const GLcontext *ctx,
                         GLuint n, GLint x, GLint y,
                         CONST GLubyte rgb[][3], const GLubyte mask[] );
   /* Write a horizontal run of RGBA or RGB pixels.
    * If mask is NULL, draw all pixels.
    * If mask is not null, only draw pixel [i] when mask [i] is true.
    */

   void (*WriteMonoRGBASpan)( const GLcontext *ctx, GLuint n, GLint x, GLint y,
                              const GLubyte mask[] );
   /* Write a horizontal run of RGBA pixels all with the color last
    * specified by the Color function.
    */

   void (*WriteRGBAPixels)( const GLcontext *ctx,
                            GLuint n, const GLint x[], const GLint y[],
                            CONST GLubyte rgba[][4], const GLubyte mask[] );
   /* Write array of RGBA pixels at random locations.
    */

   void (*WriteMonoRGBAPixels)( const GLcontext *ctx,
                                GLuint n, const GLint x[], const GLint y[],
                                const GLubyte mask[] );
   /* Write an array of mono-RGBA pixels at random locations.
    */

   void (*WriteCI32Span)( const GLcontext *ctx, GLuint n, GLint x, GLint y,
                          const GLuint index[], const GLubyte mask[] );
   void (*WriteCI8Span)( const GLcontext *ctx, GLuint n, GLint x, GLint y,
                         const GLubyte index[], const GLubyte mask[] );
   /* Write a horizontal run of CI pixels.  One function is for 32bpp
    * indexes and the other for 8bpp pixels (the common case).  You mus
    * implement both for color index mode.
    */

   void (*WriteMonoCISpan)( const GLcontext *ctx, GLuint n, GLint x, GLint y,
                            const GLubyte mask[] );
   /* Write a horizontal run of color index pixels using the color index
    * last specified by the Index() function.
    */

   void (*WriteCI32Pixels)( const GLcontext *ctx,
                            GLuint n, const GLint x[], const GLint y[],
                            const GLuint index[], const GLubyte mask[] );
   /*
    * Write a random array of CI pixels.
    */

   void (*WriteMonoCIPixels)( const GLcontext *ctx,
                              GLuint n, const GLint x[], const GLint y[],
                              const GLubyte mask[] );
   /* Write a random array of color index pixels using the color index
    * last specified by the Index() function.
    */


   /***
    *** Functions to read pixels from frame buffer:
    ***/

   void (*ReadCI32Span)( const GLcontext *ctx,
                         GLuint n, GLint x, GLint y, GLuint index[] );
   /* Read a horizontal run of color index pixels.
    */

   void (*ReadRGBASpan)( const GLcontext *ctx, GLuint n, GLint x, GLint y,
                         GLubyte rgba[][4] );
   /* Read a horizontal run of RGBA pixels.
    */

   void (*ReadCI32Pixels)( const GLcontext *ctx,
                           GLuint n, const GLint x[], const GLint y[],
                           GLuint indx[], const GLubyte mask[] );
   /* Read a random array of CI pixels.
    */

   void (*ReadRGBAPixels)( const GLcontext *ctx,
                           GLuint n, const GLint x[], const GLint y[],
                           GLubyte rgba[][4], const GLubyte mask[] );
   /* Read a random array of RGBA pixels.
    */


   /**********************************************************************
    *** Optional functions:  these functions may or may not be         ***
    *** implemented by the device driver.  If the device driver        ***
    *** doesn't implement them it should never touch these pointers    ***
    *** since Mesa will either set them to NULL or point them at a     ***
    *** fall-back function.                                            ***
    **********************************************************************/

   void (*Finish)( GLcontext *ctx );
   /*
    * This is called whenever glFinish() is called.
    */

   void (*Flush)( GLcontext *ctx );
   /*
    * This is called whenever glFlush() is called.
    */

   GLboolean (*IndexMask)( GLcontext *ctx, GLuint mask );
   /*
    * Implements glIndexMask() if possible, else return GL_FALSE.
    */

   GLboolean (*ColorMask)( GLcontext *ctx,
                           GLboolean rmask, GLboolean gmask,
                           GLboolean bmask, GLboolean amask );
   /*
    * Implements glColorMask() if possible, else return GL_FALSE.
    */

   GLboolean (*LogicOp)( GLcontext *ctx, GLenum op );
   /*
    * Implements glLogicOp() if possible, else return GL_FALSE.
    */

   void (*Dither)( GLcontext *ctx, GLboolean enable );
   /*
    * Enable/disable dithering.
    * NOTE: This function will be removed in the future in favor
    * of the "Enable" driver function.
    */

   void (*Error)( GLcontext *ctx );
   /*
    * Called whenever an error is generated.  ctx->ErrorValue contains
    * the error value.
    */

   void (*NearFar)( GLcontext *ctx, GLfloat nearVal, GLfloat farVal );
   /*
    * Called from glFrustum and glOrtho to tell device driver the
    * near and far clipping plane Z values.  The 3Dfx driver, for example,
    * uses this.
    */

   GLint (*GetParameteri)( const GLcontext *ctx, GLint param );
   /* Query the device driver to get an integer parameter.
    * Current parameters:
    *     DD_MAX_TEXTURE_SIZE         return maximum texture size
    *
    *     DD_MAX_TEXTURES             number of texture sets/stages, usually 1
    *
    *     DD_HAVE_HARDWARE_FOG        the driver should return 1 (0 otherwise)
    *                                 when the hardware support per fragment
    *                                 fog for free (like the Voodoo Graphics)
    *                                 so the Mesa core will start to ever use
    *                                 per fragment fog
    */


   /***
    *** For supporting hardware Z buffers:
    *** Either ALL or NONE of these functions must be implemented!
    *** NOTE that Each depth value is a 32-bit GLuint.  If the depth
    *** buffer is less than 32 bits deep then the extra upperbits are zero.
    ***/

   void (*WriteDepthSpan)( GLcontext *ctx, GLuint n, GLint x, GLint y,
                           const GLdepth depth[], const GLubyte mask[] );
   /* Write a horizontal span of values into the depth buffer.  Only write
    * depth[i] value if mask[i] is nonzero.
    */

   void (*ReadDepthSpan)( GLcontext *ctx, GLuint n, GLint x, GLint y,
                          GLdepth depth[] );
   /* Read a horizontal span of values from the depth buffer.
    */


   void (*WriteDepthPixels)( GLcontext *ctx, GLuint n,
                             const GLint x[], const GLint y[],
                             const GLdepth depth[], const GLubyte mask[] );
   /* Write an array of randomly positioned depth values into the
    * depth buffer.  Only write depth[i] value if mask[i] is nonzero.
    */

   void (*ReadDepthPixels)( GLcontext *ctx, GLuint n,
                            const GLint x[], const GLint y[],
                            GLdepth depth[] );
   /* Read an array of randomly positioned depth values from the depth buffer.
    */



   /***
    *** For supporting hardware stencil buffers:
    *** Either ALL or NONE of these functions must be implemented!
    ***/

   void (*WriteStencilSpan)( GLcontext *ctx, GLuint n, GLint x, GLint y,
                             const GLstencil stencil[], const GLubyte mask[] );
   /* Write a horizontal span of stencil values into the stencil buffer.
    * If mask is NULL, write all stencil values.
    * Else, only write stencil[i] if mask[i] is non-zero.
    */

   void (*ReadStencilSpan)( GLcontext *ctx, GLuint n, GLint x, GLint y,
                            GLstencil stencil[] );
   /* Read a horizontal span of stencil values from the stencil buffer.
    */

   void (*WriteStencilPixels)( GLcontext *ctx, GLuint n,
                               const GLint x[], const GLint y[],
                               const GLstencil stencil[],
                               const GLubyte mask[] );
   /* Write an array of stencil values into the stencil buffer.
    * If mask is NULL, write all stencil values.
    * Else, only write stencil[i] if mask[i] is non-zero.
    */

   void (*ReadStencilPixels)( GLcontext *ctx, GLuint n,
                              const GLint x[], const GLint y[],
                              GLstencil stencil[] );
   /* Read an array of stencil values from the stencil buffer.
    */
  

   /***
    *** glDraw/Read/CopyPixels and glBitmap functions:
    ***/

   GLboolean (*DrawPixels)( GLcontext *ctx,
                            GLint x, GLint y, GLsizei width, GLsizei height,
                            GLenum format, GLenum type,
                            const struct gl_pixelstore_attrib *unpack,
                            const GLvoid *pixels );
   /* This is called by glDrawPixels.
    * 'unpack' describes how to unpack the source image data.
    * Return GL_TRUE if the driver succeeds, return GL_FALSE if core Mesa
    * must do the job.
    */

   GLboolean (*ReadPixels)( GLcontext *ctx,
                            GLint x, GLint y, GLsizei width, GLsizei height,
                            GLenum format, GLenum type,
                            const struct gl_pixelstore_attrib *unpack,
                            GLvoid *dest );
   /* Called by glReadPixels.
    * Return GL_TRUE if operation completed, else return GL_FALSE.
    * This function must respect all glPixelTransfer settings.
    */

   GLboolean (*CopyPixels)( GLcontext *ctx,
                            GLint srcx, GLint srcy,
                            GLsizei width, GLsizei height,
                            GLint dstx, GLint dsty, GLenum type );
   /* Do a glCopyPixels.  Return GL_TRUE if operation completed, else
    * return GL_FALSE.  This function must respect all rasterization
    * state, glPixelTransfer, glPixelZoom, etc.
    */

   GLboolean (*Bitmap)( GLcontext *ctx,
                        GLint x, GLint y, GLsizei width, GLsizei height,
                        const struct gl_pixelstore_attrib *unpack,
                        const GLubyte *bitmap );
   /* This is called by glBitmap.  Works the same as DrawPixels, above.
    */


   /***
    *** Texture mapping functions:
    ***/

   void (*TexImage)( GLcontext *ctx, GLenum target,
                     struct gl_texture_object *tObj, GLint level,
                     GLint internalFormat,
                     const struct gl_texture_image *image );
   /* XXX this function is obsolete */
   /* Called whenever a texture object's image is changed.
    *    texObject is the number of the texture object being changed.
    *    level indicates the mipmap level.
    *    internalFormat is the format in which the texture is to be stored.
    *    image is a pointer to a gl_texture_image struct which contains
    *       the actual image data.
    */

   void (*TexSubImage)( GLcontext *ctx, GLenum target,
                        struct gl_texture_object *tObj, GLint level,
                        GLint xoffset, GLint yoffset,
                        GLsizei width, GLsizei height,
                        GLint internalFormat,
                        const struct gl_texture_image *image );
   /* XXX this function is obsolete */
   /* Called from glTexSubImage() to define a sub-region of a texture.
    */


   GLboolean (*TexImage1D)( GLcontext *ctx, GLenum target, GLint level,
                            GLenum format, GLenum type, const GLvoid *pixels,
                            const struct gl_pixelstore_attrib *packing,
                            struct gl_texture_object *texObj,
                            struct gl_texture_image *texImage,
                            GLboolean *retainInternalCopy );
   GLboolean (*TexImage2D)( GLcontext *ctx, GLenum target, GLint level,
                            GLenum format, GLenum type, const GLvoid *pixels,
                            const struct gl_pixelstore_attrib *packing,
                            struct gl_texture_object *texObj,
                            struct gl_texture_image *texImage,
                            GLboolean *retainInternalCopy );
   GLboolean (*TexImage3D)( GLcontext *ctx, GLenum target, GLint level,
                            GLenum format, GLenum type, const GLvoid *pixels,
                            const struct gl_pixelstore_attrib *packing,
                            struct gl_texture_object *texObj,
                            struct gl_texture_image *texImage,
                            GLboolean *retainInternalCopy );
   /* Called by glTexImage1/2/3D.
    * Will not be called if any glPixelTransfer operations are enabled.
    * Arguments:
    *   <target>, <level>, <format>, <type> and <pixels> are user specified.
    *   <packing> indicates the image packing of pixels.
    *   <texObj> is the target texture object.
    *   <texImage> is the target texture image.  It will have the texture
    *      width, height, depth, border and internalFormat information.
    *   <retainInternalCopy> is returned by this function and indicates whether
    *      core Mesa should keep an internal copy of the texture image.
    * Return GL_TRUE if operation completed, return GL_FALSE if core Mesa
    * should do the job.  If GL_FALSE is returned, this function will be
    * called a second time after the texture image has been unpacked into
    * GLubytes.  It may be easier for the driver to handle then.
    */

   GLboolean (*TexSubImage1D)( GLcontext *ctx, GLenum target, GLint level,
                               GLint xoffset, GLsizei width,
                               GLenum format, GLenum type,
                               const GLvoid *pixels,
                               const struct gl_pixelstore_attrib *packing,
                               struct gl_texture_object *texObj,
                               struct gl_texture_image *texImage );
   GLboolean (*TexSubImage2D)( GLcontext *ctx, GLenum target, GLint level,
                               GLint xoffset, GLint yoffset,
                               GLsizei width, GLsizei height,
                               GLenum format, GLenum type,
                               const GLvoid *pixels,
                               const struct gl_pixelstore_attrib *packing,
                               struct gl_texture_object *texObj,
                               struct gl_texture_image *texImage );
   GLboolean (*TexSubImage3D)( GLcontext *ctx, GLenum target, GLint level,
                               GLint xoffset, GLint yoffset, GLint zoffset,
                               GLsizei width, GLsizei height, GLint depth,
                               GLenum format, GLenum type,
                               const GLvoid *pixels,
                               const struct gl_pixelstore_attrib *packing,
                               struct gl_texture_object *texObj,
                               struct gl_texture_image *texImage );
   /* Called by glTexSubImage1/2/3D.
    * Will not be called if any glPixelTransfer operations are enabled.
    * Arguments:
    *   <target>, <level>, <xoffset>, <yoffset>, <zoffset>, <width>, <height>,
    *      <depth>, <format>, <type> and <pixels> are user specified.
    *   <packing> indicates the image packing of pixels.
    *   <texObj> is the target texture object.
    *   <texImage> is the target texture image.  It will have the texture
    *      width, height, border and internalFormat information.
    * Return GL_TRUE if operation completed, return GL_FALSE if core Mesa
    * should do the job.  If GL_FALSE is returned, then TexImage1/2/3D will
    * be called with the complete texture image.
    */
      
   GLboolean (*CopyTexImage1D)( GLcontext *ctx, GLenum target, GLint level,
                                GLenum internalFormat, GLint x, GLint y,
                                GLsizei width, GLint border );
   GLboolean (*CopyTexImage2D)( GLcontext *ctx, GLenum target, GLint level,
                                GLenum internalFormat, GLint x, GLint y,
                                GLsizei width, GLsizei height, GLint border );
   /* Called by glCopyTexImage1D and glCopyTexImage2D.
    * Will not be called if any glPixelTransfer operations are enabled.
    * Return GL_TRUE if operation completed, return GL_FALSE if core Mesa
    * should do the job.
    */

   GLboolean (*CopyTexSubImage1D)( GLcontext *ctx, GLenum target, GLint level,
                                   GLint xoffset,
                                   GLint x, GLint y, GLsizei width );
   GLboolean (*CopyTexSubImage2D)( GLcontext *ctx, GLenum target, GLint level,
                                   GLint xoffset, GLint yoffset,
                                   GLint x, GLint y,
                                   GLsizei width, GLsizei height );
   GLboolean (*CopyTexSubImage3D)( GLcontext *ctx, GLenum target, GLint level,
                                   GLint xoffset, GLint yoffset, GLint zoffset,
                                   GLint x, GLint y,
                                   GLsizei width, GLsizei height );
   /* Called by glCopyTexSubImage1/2/3D.
    * Will not be called if any glPixelTransfer operations are enabled.
    * Return GL_TRUE if operation completed, return GL_FALSE if core Mesa
    * should do the job.
    */

   GLvoid *(*GetTexImage)( GLcontext *ctx, GLenum target, GLint level,
                           const struct gl_texture_object *texObj,
                           GLenum *formatOut, GLenum *typeOut,
                           GLboolean *freeImageOut );
   /* Called by glGetTexImage or by core Mesa when a texture image
    * is needed for software fallback rendering.
    * Return the address of the texture image or NULL if failure.
    * The image must be tightly packed (i.e. row stride = image width)
    * Return the image's format and type in formatOut and typeOut.
    * The format and type must be values which are accepted by glTexImage.
    * Set the freeImageOut flag if the returned image should be deallocated
    * with FREE() when finished.
    * The size of the image can be deduced from the target and level.
    * Core Mesa will perform any image format/type conversions that are needed.
    */

   GLboolean (*TestProxyTexImage)(GLcontext *ctx, GLenum target,
                                  GLint level, GLint internalFormat,
                                  GLenum format, GLenum type,
                                  GLint width, GLint height,
                                  GLint depth, GLint border);
   /* Called by glTexImage[123]D when user specifies a proxy texture
    * target.  Return GL_TRUE if the proxy test passes, return GL_FALSE
    * if the test fails.
    */

   GLboolean (*CompressedTexImage1D)( GLcontext *ctx, GLenum target,
                                      GLint level, GLsizei imageSize,
                                      const GLvoid *data,
                                      struct gl_texture_object *texObj,
                                      struct gl_texture_image *texImage,
                                      GLboolean *retainInternalCopy);
   GLboolean (*CompressedTexImage2D)( GLcontext *ctx, GLenum target,
                                      GLint level, GLsizei imageSize,
                                      const GLvoid *data,
                                      struct gl_texture_object *texObj,
                                      struct gl_texture_image *texImage,
                                      GLboolean *retainInternalCopy);
   GLboolean (*CompressedTexImage3D)( GLcontext *ctx, GLenum target,
                                      GLint level, GLsizei imageSize,
                                      const GLvoid *data,
                                      struct gl_texture_object *texObj,
                                      struct gl_texture_image *texImage,
                                      GLboolean *retainInternalCopy);
   /* Called by glCompressedTexImage1/2/3D.
    * Arguments:
    *   <target>, <level>, <internalFormat>, <data> are user specified.
    *   <texObj> is the target texture object.
    *   <texImage> is the target texture image.  It will have the texture
    *      width, height, depth, border and internalFormat information.
    *   <retainInternalCopy> is returned by this function and indicates whether
    *      core Mesa should keep an internal copy of the texture image.
    * Return GL_TRUE if operation completed, return GL_FALSE if core Mesa
    * should do the job.
    */

   GLboolean (*CompressedTexSubImage1D)( GLcontext *ctx, GLenum target,
                                         GLint level, GLint xoffset,
                                         GLsizei width, GLenum format,
                                         GLsizei imageSize, const GLvoid *data,
                                         struct gl_texture_object *texObj,
                                         struct gl_texture_image *texImage );
   GLboolean (*CompressedTexSubImage2D)( GLcontext *ctx, GLenum target,
                                         GLint level, GLint xoffset,
                                         GLint yoffset, GLsizei width,
                                         GLint height, GLenum format,
                                         GLsizei imageSize, const GLvoid *data,
                                         struct gl_texture_object *texObj,
                                         struct gl_texture_image *texImage );
   GLboolean (*CompressedTexSubImage3D)( GLcontext *ctx, GLenum target,
                                         GLint level, GLint xoffset,
                                         GLint yoffset, GLint zoffset,
                                         GLsizei width, GLint height,
                                         GLint depth, GLenum format,
                                         GLsizei imageSize, const GLvoid *data,
                                         struct gl_texture_object *texObj,
                                         struct gl_texture_image *texImage );
   /* Called by glCompressedTexSubImage1/2/3D.
    * Arguments:
    *   <target>, <level>, <x/z/zoffset>, <width>, <height>, <depth>,
    *      <imageSize>, and <data> are user specified.
    *   <texObj> is the target texture object.
    *   <texImage> is the target texture image.  It will have the texture
    *      width, height, depth, border and internalFormat information.
    * Return GL_TRUE if operation completed, return GL_FALSE if core Mesa
    * should do the job.
    */

   GLint (*BaseCompressedTexFormat)(GLcontext *ctx,
                                    GLint internalFormat);
   /* Called to compute the base format for a specific compressed
    * format.  Return -1 if the internalFormat is not a specific
    * compressed format that the driver recognizes.  Note the
    * return value differences between this function and
    * SpecificCompressedTexFormat below.
    */

   GLint (*SpecificCompressedTexFormat)(GLcontext *ctx,
                                        GLint      internalFormat,
                                        GLint      numDimensions,
                                        GLint     *levelp,
                                        GLsizei   *widthp,
                                        GLsizei   *heightp,
                                        GLsizei   *depthp,
                                        GLint     *borderp,
                                        GLenum    *formatp,
                                        GLenum    *typep);
   /* Called to turn a generic texture format into a specific
    * texture format.  For example, if a driver implements
    * GL_3DFX_texture_compression_FXT1, this would map
    * GL_COMPRESSED_RGBA_ARB to GL_COMPRESSED_RGBA_FXT1_3DFX.
    *
    * If the driver does not know how to handle the compressed
    * format, then just return the generic format, and Mesa will
    * do the right thing with it.
    */

   GLboolean (*IsCompressedFormat)(GLcontext *ctx, GLint internalFormat);
   /* Called to tell if a format is a compressed format.
    */

   GLsizei (*CompressedImageSize)(GLcontext *ctx,
                                  GLenum internalFormat,
                                  GLuint numDimensions,
                                  GLuint width,
                                  GLuint height,
                                  GLuint depth);
   /* Calculate the size of a compressed image, given the image's
    * format and dimensions.
    */

   void (*GetCompressedTexImage)( GLcontext *ctx, GLenum target,
                                  GLint lod, void *image,
                                  const struct gl_texture_object *texObj,
                                  struct gl_texture_image *texImage );
   /* Called by glGetCompressedTexImageARB.
    * <target>, <lod>, <image> are specified by user.
    * <texObj> is the source texture object.
    * <texImage> is the source texture image.
    */

   void (*TexEnv)( GLcontext *ctx, GLenum target, GLenum pname,
                   const GLfloat *param );
   /* Called by glTexEnv*().
    */

   void (*TexParameter)( GLcontext *ctx, GLenum target,
                         struct gl_texture_object *texObj,
                         GLenum pname, const GLfloat *params );
   /* Called by glTexParameter*().
    *    <target> is user specified
    *    <texObj> the texture object to modify
    *    <pname> is one of GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER,
    *       GL_TEXTURE_WRAP_[STR], or GL_TEXTURE_BORDER_COLOR.
    *    <params> is user specified.
    */

   void (*BindTexture)( GLcontext *ctx, GLenum target,
                        struct gl_texture_object *tObj );
   /* Called by glBindTexture().
    */

   void (*DeleteTexture)( GLcontext *ctx, struct gl_texture_object *tObj );
   /* Called when a texture object is about to be deallocated.  Driver
    * should free anything attached to the DriverData pointers.
    */

   GLboolean (*IsTextureResident)( GLcontext *ctx, 
                                   struct gl_texture_object *t );
   /* Called by glAreTextureResident().
    */

   void (*PrioritizeTexture)( GLcontext *ctx,  struct gl_texture_object *t,
                              GLclampf priority );
   /* Called by glPrioritizeTextures().
    */

   void (*ActiveTexture)( GLcontext *ctx, GLuint texUnitNumber );
   /* Called by glActiveTextureARB to set current texture unit.
    */

   void (*UpdateTexturePalette)( GLcontext *ctx,
                                 struct gl_texture_object *tObj );
   /* Called when the texture's color lookup table is changed.
    * If tObj is NULL then the shared texture palette ctx->Texture.Palette
    * is to be updated.
    */



   /***
    *** Accelerated point, line, polygon, quad and rect functions:
    ***/

   points_func   PointsFunc;
   line_func     LineFunc;
   triangle_func TriangleFunc;
   quad_func     QuadFunc;
   rect_func     RectFunc;    
   

   /***
    *** Transformation/Rendering functions
    ***/

   void (*RenderStart)( GLcontext *ctx );
   void (*RenderFinish)( GLcontext *ctx );
    /* KW: These replace Begin and End, and have more relaxed semantics.
     * They are called prior-to and after one or more vb flush, and are
     * thus decoupled from the gl_begin/gl_end pairs, which are possibly 
     * more frequent.  If a begin/end pair covers >1 vertex buffer, these
     * are called at most once for the pair. (a bit broken at present)
     */

   void (*RasterSetup)( struct vertex_buffer *VB, GLuint start, GLuint end );
   /* This function, if not NULL, is called whenever new window coordinates
    * are put in the vertex buffer.  The vertices in question are those n
    * such that start <= n < end.
    * The device driver can convert the window coords to its own specialized
    * format.  The 3Dfx driver uses this.
    *
    * Note: Deprecated in favour of RegisterPipelineStages, below.
    */

   render_func *RenderVBClippedTab;
   render_func *RenderVBCulledTab;
   render_func *RenderVBRawTab;
   /* These function tables allow the device driver to rasterize an
    * entire begin/end group of primitives at once.  See the
    * gl_render_vb() function in vbrender.c for more details.  
    */

   void (*ReducedPrimitiveChange)( GLcontext *ctx, GLenum primitive );
   /* If registered, this will be called when rendering transitions between
    * points, lines and triangles.  It is not called on transitions between 
    * primtives such as GL_TRIANGLES and GL_TRIANGLE_STRIPS, or between
    * triangles and quads or triangles and polygons.
    */

   GLuint TriangleCaps;
   /* Holds a list of the reasons why we might normally want to call
    * render_triangle, but which are in fact implemented by the
    * driver.  The FX driver sets this to DD_TRI_CULL, and will soon
    * implement DD_TRI_OFFSET.
    */

   GLboolean (*MultipassFunc)( struct vertex_buffer *VB, GLuint passno );
   /* Driver may request additional render passes by returning GL_TRUE
    * when this function is called.  This function will be called
    * after the first pass, and passes will be made until the function
    * returns GL_FALSE.  If no function is registered, only one pass
    * is made.  
    * 
    * This function will be first invoked with passno == 1.
    */

   /***
    *** NEW in Mesa 3.x
    ***/

   void (*RegisterVB)( struct vertex_buffer *VB );
   void (*UnregisterVB)( struct vertex_buffer *VB );
   /* Do any processing (eg allocate memory) required to set up a new
    * vertex_buffer.  
    */


   void (*ResetVB)( struct vertex_buffer *VB );
   void (*ResetCvaVB)( struct vertex_buffer *VB, GLuint stages );
   /* Do any reset operations necessary to the driver data associated
    * with these vertex buffers.
    */

   GLuint RenderVectorFlags;
   /* What do the render tables require of the vectors they deal
    * with?  
    */

   GLuint (*RegisterPipelineStages)( struct gl_pipeline_stage *out,
				     const struct gl_pipeline_stage *in,
				     GLuint nr );
   /* Register new pipeline stages, or modify existing ones.  See also
    * the OptimizePipeline() functions.
    */


   GLboolean (*BuildPrecalcPipeline)( GLcontext *ctx );
   GLboolean (*BuildEltPipeline)( GLcontext *ctx );
   /* Perform the full pipeline build, or return false.
    */


   void (*OptimizePrecalcPipeline)( GLcontext *ctx, struct gl_pipeline *pipe );
   void (*OptimizeImmediatePipeline)( GLcontext *ctx, struct gl_pipeline *pipe);
   /* Check to see if a fast path exists for this combination of stages 
    * in the precalc and immediate (elt) pipelines.
    */


   /*
    * State-changing functions (drawing functions are above)
    *
    * These functions are called by their corresponding OpenGL API functions.
    * They're ALSO called by the gl_PopAttrib() function!!!
    * May add more functions like these to the device driver in the future.
    * This should reduce the amount of state checking that
    * the driver's UpdateState() function must do.
    */
   void (*AlphaFunc)(GLcontext *ctx, GLenum func, GLclampf ref);
   void (*BlendEquation)(GLcontext *ctx, GLenum mode);
   void (*BlendFunc)(GLcontext *ctx, GLenum sfactor, GLenum dfactor);
   void (*BlendFuncSeparate)( GLcontext *ctx, GLenum sfactorRGB, 
			      GLenum dfactorRGB, GLenum sfactorA,
			      GLenum dfactorA );
   void (*BlendConstColor)(GLcontext *ctx, GLfloat red, GLfloat green,
			   GLfloat blue, GLfloat alpha);
   void (*ClearDepth)(GLcontext *ctx, GLclampd d);
   void (*CullFace)(GLcontext *ctx, GLenum mode);
   void (*FrontFace)(GLcontext *ctx, GLenum mode);
   void (*DepthFunc)(GLcontext *ctx, GLenum func);
   void (*DepthMask)(GLcontext *ctx, GLboolean flag);
   void (*DepthRange)(GLcontext *ctx, GLclampd nearval, GLclampd farval);
   void (*Enable)(GLcontext* ctx, GLenum cap, GLboolean state);
   void (*Fogfv)(GLcontext *ctx, GLenum pname, const GLfloat *params);
   void (*Hint)(GLcontext *ctx, GLenum target, GLenum mode);
   void (*Lightfv)(GLcontext *ctx, GLenum light,
		   GLenum pname, const GLfloat *params, GLint nparams );
   void (*LightModelfv)(GLcontext *ctx, GLenum pname, const GLfloat *params);
   void (*LineStipple)(GLcontext *ctx, GLint factor, GLushort pattern );
   void (*LineWidth)(GLcontext *ctx, GLfloat width);
   void (*LogicOpcode)(GLcontext *ctx, GLenum opcode);
   void (*PointSize)(GLcontext *ctx, GLfloat size);
   void (*PolygonMode)(GLcontext *ctx, GLenum face, GLenum mode);
   void (*PolygonStipple)(GLcontext *ctx, const GLubyte *mask );
   void (*Scissor)(GLcontext *ctx, GLint x, GLint y, GLsizei w, GLsizei h);
   void (*ShadeModel)(GLcontext *ctx, GLenum mode);
   void (*ClearStencil)(GLcontext *ctx, GLint s);
   void (*StencilFunc)(GLcontext *ctx, GLenum func, GLint ref, GLuint mask);
   void (*StencilMask)(GLcontext *ctx, GLuint mask);
   void (*StencilOp)(GLcontext *ctx, GLenum fail, GLenum zfail, GLenum zpass);
   void (*Viewport)(GLcontext *ctx, GLint x, GLint y, GLsizei w, GLsizei h);

   /* State-query functions
    *
    * Return GL_TRUE if query was completed, GL_FALSE otherwise.
    */
   GLboolean (*GetBooleanv)(GLcontext *ctx, GLenum pname, GLboolean *result);
   GLboolean (*GetDoublev)(GLcontext *ctx, GLenum pname, GLdouble *result);
   GLboolean (*GetFloatv)(GLcontext *ctx, GLenum pname, GLfloat *result);
   GLboolean (*GetIntegerv)(GLcontext *ctx, GLenum pname, GLint *result);
   GLboolean (*GetPointerv)(GLcontext *ctx, GLenum pname, GLvoid **result);
};



#endif

@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
a1 1

d4 4
a7 4
 * Version:  4.1
 *
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
 *
d14 1
a14 1
 *
d17 1
a17 1
 *
d31 3
a33 1
/* THIS FILE ONLY INCLUDED BY mtypes.h !!!!! */
d37 83
a124 4
#define DD_AUX0            AUX0_BIT               /* future use */
#define DD_AUX1            AUX1_BIT               /* future use */
#define DD_AUX2            AUX2_BIT               /* future use */
#define DD_AUX3            AUX3_BIT               /* future use */
d126 1
d128 1
a128 1
#define DD_STENCIL_BIT     GL_STENCIL_BUFFER_BIT  /* 0x00000400 */
d136 5
d147 1
a147 1
   void (*UpdateState)( GLcontext *ctx, GLuint new_state );
d149 3
a151 3
    * UpdateState() is called to notify the driver after Mesa has made
    * some internal state changes.  This is in addition to any
    * statechange callbacks Mesa may already have made.
d154 15
a168 2
   void (*Clear)( GLcontext *ctx, GLbitfield mask, GLboolean all,
		  GLint x, GLint y, GLint width, GLint height );
d171 3
a173 1
    * which buffers need to be cleared.
d177 1
a177 2
    * settings!
    * Software Mesa can do masked clears if the device driver can't.
d180 1
a180 1
   void (*DrawBuffer)( GLcontext *ctx, GLenum buffer );
d182 2
a183 3
    * Specifies the current buffer for writing.  Called via glDrawBuffer().
    * Note the driver must organize fallbacks (eg with swrast) if it
    * cannot implement the requested mode.
d186 6
d193 1
a193 1
   void (*ReadBuffer)( GLcontext *ctx, GLenum buffer );
d195 16
a210 1
    * Specifies the current buffer for reading.  Called via glReadBuffer().
d213 2
a214 2
   void (*GetBufferSize)( GLframebuffer *buffer,
                          GLuint *width, GLuint *height );
d216 33
a248 2
    * Returns the width and height of the named buffer/window.
    * Mesa uses this to determine when the driver's window size has changed.
d251 30
a280 1
   void (*ResizeBuffers)( GLframebuffer *buffer );
d282 35
a316 3
    * Resize the driver's depth/stencil/accum/back buffers to match the
    * size given in the GLframebuffer struct.  This is typically called
    * when Mesa detects that a window size has changed.
d319 9
d338 24
d368 21
d391 4
a394 1
    *** For hardware accumulation buffer:
d396 5
a400 3
   void (*Accum)( GLcontext *ctx, GLenum op, GLfloat value,
		  GLint xpos, GLint ypos, GLint width, GLint height );
   /* Execute glAccum command within the given scissor region.
d403 53
d461 5
a465 5
   void (*DrawPixels)( GLcontext *ctx,
		       GLint x, GLint y, GLsizei width, GLsizei height,
		       GLenum format, GLenum type,
		       const struct gl_pixelstore_attrib *unpack,
		       const GLvoid *pixels );
d468 2
d472 5
a476 5
   void (*ReadPixels)( GLcontext *ctx,
		       GLint x, GLint y, GLsizei width, GLsizei height,
		       GLenum format, GLenum type,
		       const struct gl_pixelstore_attrib *unpack,
		       GLvoid *dest );
d478 2
d482 1
a482 1
   void (*CopyPixels)( GLcontext *ctx,
d486 2
a487 1
   /* Do a glCopyPixels.  This function must respect all rasterization
d491 4
a494 4
   void (*Bitmap)( GLcontext *ctx,
		   GLint x, GLint y, GLsizei width, GLsizei height,
		   const struct gl_pixelstore_attrib *unpack,
		   const GLubyte *bitmap );
d498 1
d500 1
a500 1
    *** Texture image functions:
d502 43
a544 29
   const struct gl_texture_format *
   (*ChooseTextureFormat)( GLcontext *ctx, GLint internalFormat,
                           GLenum srcFormat, GLenum srcType );
   /* This is called by the _mesa_store_tex[sub]image[123]d() fallback
    * functions.  The driver should examine <internalFormat> and return a
    * pointer to an appropriate gl_texture_format.
    */

   void (*TexImage1D)( GLcontext *ctx, GLenum target, GLint level,
                       GLint internalFormat,
                       GLint width, GLint border,
                       GLenum format, GLenum type, const GLvoid *pixels,
                       const struct gl_pixelstore_attrib *packing,
                       struct gl_texture_object *texObj,
                       struct gl_texture_image *texImage );
   void (*TexImage2D)( GLcontext *ctx, GLenum target, GLint level,
                       GLint internalFormat,
                       GLint width, GLint height, GLint border,
                       GLenum format, GLenum type, const GLvoid *pixels,
                       const struct gl_pixelstore_attrib *packing,
                       struct gl_texture_object *texObj,
                       struct gl_texture_image *texImage );
   void (*TexImage3D)( GLcontext *ctx, GLenum target, GLint level,
                       GLint internalFormat,
                       GLint width, GLint height, GLint depth, GLint border,
                       GLenum format, GLenum type, const GLvoid *pixels,
                       const struct gl_pixelstore_attrib *packing,
                       struct gl_texture_object *texObj,
                       struct gl_texture_image *texImage );
d546 1
d555 29
a583 26
    * Drivers should call a fallback routine from texstore.c if needed.
    */

   void (*TexSubImage1D)( GLcontext *ctx, GLenum target, GLint level,
                          GLint xoffset, GLsizei width,
                          GLenum format, GLenum type,
                          const GLvoid *pixels,
                          const struct gl_pixelstore_attrib *packing,
                          struct gl_texture_object *texObj,
                          struct gl_texture_image *texImage );
   void (*TexSubImage2D)( GLcontext *ctx, GLenum target, GLint level,
                          GLint xoffset, GLint yoffset,
                          GLsizei width, GLsizei height,
                          GLenum format, GLenum type,
                          const GLvoid *pixels,
                          const struct gl_pixelstore_attrib *packing,
                          struct gl_texture_object *texObj,
                          struct gl_texture_image *texImage );
   void (*TexSubImage3D)( GLcontext *ctx, GLenum target, GLint level,
                          GLint xoffset, GLint yoffset, GLint zoffset,
                          GLsizei width, GLsizei height, GLint depth,
                          GLenum format, GLenum type,
                          const GLvoid *pixels,
                          const struct gl_pixelstore_attrib *packing,
                          struct gl_texture_object *texObj,
                          struct gl_texture_image *texImage );
d585 1
d593 3
a595 1
    * The driver should use a fallback routine from texstore.c if needed.
d597 7
a603 7

   void (*CopyTexImage1D)( GLcontext *ctx, GLenum target, GLint level,
                           GLenum internalFormat, GLint x, GLint y,
                           GLsizei width, GLint border );
   void (*CopyTexImage2D)( GLcontext *ctx, GLenum target, GLint level,
                           GLenum internalFormat, GLint x, GLint y,
                           GLsizei width, GLsizei height, GLint border );
d605 3
a607 1
    * Drivers should use a fallback routine from texstore.c if needed.
d610 11
a620 11
   void (*CopyTexSubImage1D)( GLcontext *ctx, GLenum target, GLint level,
                              GLint xoffset,
                              GLint x, GLint y, GLsizei width );
   void (*CopyTexSubImage2D)( GLcontext *ctx, GLenum target, GLint level,
                              GLint xoffset, GLint yoffset,
                              GLint x, GLint y,
                              GLsizei width, GLsizei height );
   void (*CopyTexSubImage3D)( GLcontext *ctx, GLenum target, GLint level,
                              GLint xoffset, GLint yoffset, GLint zoffset,
                              GLint x, GLint y,
                              GLsizei width, GLsizei height );
d622 19
a640 1
    * Drivers should use a fallback routine from texstore.c if needed.
d653 18
a670 23
   /***
    *** Compressed texture functions:
    ***/

   void (*CompressedTexImage1D)( GLcontext *ctx, GLenum target,
                                 GLint level, GLint internalFormat,
                                 GLsizei width, GLint border,
                                 GLsizei imageSize, const GLvoid *data,
                                 struct gl_texture_object *texObj,
                                 struct gl_texture_image *texImage );
   void (*CompressedTexImage2D)( GLcontext *ctx, GLenum target,
                                 GLint level, GLint internalFormat,
                                 GLsizei width, GLsizei height, GLint border,
                                 GLsizei imageSize, const GLvoid *data,
                                 struct gl_texture_object *texObj,
                                 struct gl_texture_image *texImage );
   void (*CompressedTexImage3D)( GLcontext *ctx, GLenum target,
                                 GLint level, GLint internalFormat,
                                 GLsizei width, GLsizei height, GLsizei depth,
                                 GLint border,
                                 GLsizei imageSize, const GLvoid *data,
                                 struct gl_texture_object *texObj,
                                 struct gl_texture_image *texImage );
d683 21
a703 20
   void (*CompressedTexSubImage1D)(GLcontext *ctx, GLenum target, GLint level,
                                   GLint xoffset, GLsizei width,
                                   GLenum format,
                                   GLsizei imageSize, const GLvoid *data,
                                   struct gl_texture_object *texObj,
                                   struct gl_texture_image *texImage);
   void (*CompressedTexSubImage2D)(GLcontext *ctx, GLenum target, GLint level,
                                   GLint xoffset, GLint yoffset,
                                   GLsizei width, GLint height,
                                   GLenum format,
                                   GLsizei imageSize, const GLvoid *data,
                                   struct gl_texture_object *texObj,
                                   struct gl_texture_image *texImage);
   void (*CompressedTexSubImage3D)(GLcontext *ctx, GLenum target, GLint level,
                                   GLint xoffset, GLint yoffset, GLint zoffset,
                                   GLsizei width, GLint height, GLint depth,
                                   GLenum format,
                                   GLsizei imageSize, const GLvoid *data,
                                   struct gl_texture_object *texObj,
                                   struct gl_texture_image *texImage);
d715 68
a782 3
   /***
    *** Texture object functions:
    ***/
a788 4
   void (*CreateTexture)( GLcontext *ctx, struct gl_texture_object *tObj );
   /* Called when a texture object is created.
    */

d794 1
a794 1
   GLboolean (*IsTextureResident)( GLcontext *ctx,
d815 2
d818 1
a818 1
    *** Imaging functionality:
a819 16
   void (*CopyColorTable)( GLcontext *ctx,
			   GLenum target, GLenum internalformat,
			   GLint x, GLint y, GLsizei width );

   void (*CopyColorSubTable)( GLcontext *ctx,
			      GLenum target, GLsizei start,
			      GLint x, GLint y, GLsizei width );

   void (*CopyConvolutionFilter1D)( GLcontext *ctx, GLenum target,
				    GLenum internalFormat,
				    GLint x, GLint y, GLsizei width );

   void (*CopyConvolutionFilter2D)( GLcontext *ctx, GLenum target,
				    GLenum internalFormat,
				    GLint x, GLint y,
				    GLsizei width, GLsizei height );
d821 6
d828 54
d884 1
a884 5
    *** State-changing functions (drawing functions are above)
    ***
    *** These functions are called by their corresponding OpenGL API functions.
    *** They're ALSO called by the gl_PopAttrib() function!!!
    *** May add more functions like these to the device driver in the future.
d886 50
a935 2
   void (*AlphaFunc)(GLcontext *ctx, GLenum func, GLfloat ref);
   void (*BlendColor)(GLcontext *ctx, const GLfloat color[4]);
d938 5
a942 4
   void (*BlendFuncSeparate)(GLcontext *ctx,
                             GLenum sfactorRGB, GLenum dfactorRGB,
                             GLenum sfactorA, GLenum dfactorA);
   void (*ClearColor)(GLcontext *ctx, const GLfloat color[4]);
a943 6
   void (*ClearIndex)(GLcontext *ctx, GLuint index);
   void (*ClearStencil)(GLcontext *ctx, GLint s);
   void (*ClipPlane)(GLcontext *ctx, GLenum plane, const GLfloat *equation );
   void (*ColorMask)(GLcontext *ctx, GLboolean rmask, GLboolean gmask,
                     GLboolean bmask, GLboolean amask );
   void (*ColorMaterial)(GLcontext *ctx, GLenum face, GLenum mode);
a951 1
   void (*IndexMask)(GLcontext *ctx, GLuint mask);
d953 1
a953 1
		   GLenum pname, const GLfloat *params );
a957 2
   void (*PointParameterfv)(GLcontext *ctx, GLenum pname,
                            const GLfloat *params);
a959 1
   void (*PolygonOffset)(GLcontext *ctx, GLfloat factor, GLfloat units);
a960 1
   void (*RenderMode)(GLcontext *ctx, GLenum mode );
d963 1
a966 9
   void (*ActiveStencilFace)(GLcontext *ctx, GLuint face);
   void (*TexGen)(GLcontext *ctx, GLenum coord, GLenum pname,
		  const GLfloat *params);
   void (*TexEnv)(GLcontext *ctx, GLenum target, GLenum pname,
                  const GLfloat *param);
   void (*TexParameter)(GLcontext *ctx, GLenum target,
                        struct gl_texture_object *texObj,
                        GLenum pname, const GLfloat *params);
   void (*TextureMatrix)(GLcontext *ctx, GLuint unit, const GLmatrix *mat);
d969 4
a972 28
   /***
    *** Vertex array functions
    ***
    *** Called by the corresponding OpenGL functions.
    ***/
   void (*VertexPointer)(GLcontext *ctx, GLint size, GLenum type,
			 GLsizei stride, const GLvoid *ptr);
   void (*NormalPointer)(GLcontext *ctx, GLenum type,
			 GLsizei stride, const GLvoid *ptr);
   void (*ColorPointer)(GLcontext *ctx, GLint size, GLenum type,
			GLsizei stride, const GLvoid *ptr);
   void (*FogCoordPointer)(GLcontext *ctx, GLenum type,
			   GLsizei stride, const GLvoid *ptr);
   void (*IndexPointer)(GLcontext *ctx, GLenum type,
			GLsizei stride, const GLvoid *ptr);
   void (*SecondaryColorPointer)(GLcontext *ctx, GLint size, GLenum type,
				 GLsizei stride, const GLvoid *ptr);
   void (*TexCoordPointer)(GLcontext *ctx, GLint size, GLenum type,
			   GLsizei stride, const GLvoid *ptr);
   void (*EdgeFlagPointer)(GLcontext *ctx, GLsizei stride, const GLvoid *ptr);
   void (*VertexAttribPointer)(GLcontext *ctx, GLuint index, GLint size,
                               GLenum type, GLsizei stride, const GLvoid *ptr);


   /*** State-query functions
    ***
    *** Return GL_TRUE if query was completed, GL_FALSE otherwise.
    ***/
a977 86

   /***
    *** Support for multiple t&l engines
    ***/

   GLuint NeedValidate;
   /* Bitmask of state changes that require the current tnl module to be
    * validated, using ValidateTnlModule() below.
    */

   void (*ValidateTnlModule)( GLcontext *ctx, GLuint new_state );
   /* Validate the current tnl module.  This is called directly after
    * UpdateState() when a state change that has occured matches the
    * NeedValidate bitmask above.  This ensures all computed values are
    * up to date, thus allowing the driver to decide if the current tnl
    * module needs to be swapped out.
    *
    * This must be non-NULL if a driver installs a custom tnl module and
    * sets the NeedValidate bitmask, but may be NULL otherwise.
    */


#define PRIM_OUTSIDE_BEGIN_END   GL_POLYGON+1
#define PRIM_INSIDE_UNKNOWN_PRIM GL_POLYGON+2
#define PRIM_UNKNOWN             GL_POLYGON+3

   GLuint CurrentExecPrimitive;
   /* Set by the driver-supplied t&l engine.  Set to
    * PRIM_OUTSIDE_BEGIN_END when outside begin/end.
    */

   GLuint CurrentSavePrimitive;
   /* Current state of an in-progress compilation.  May take on any of
    * the additional values defined above.
    */


#define FLUSH_STORED_VERTICES 0x1
#define FLUSH_UPDATE_CURRENT  0x2
   GLuint NeedFlush;
   /* Set by the driver-supplied t&l engine whenever vertices are
    * buffered between begin/end objects or ctx->Current is not uptodate.
    *
    * The FlushVertices() call below may be used to resolve
    * these conditions.
    */

   void (*FlushVertices)( GLcontext *ctx, GLuint flags );
   /* If inside begin/end, ASSERT(0).
    * Otherwise,
    *   if (flags & FLUSH_STORED_VERTICES) flushes any buffered vertices,
    *   if (flags & FLUSH_UPDATE_CURRENT) updates ctx->Current
    *                                     and ctx->Light.Material
    *
    * Note that the default t&l engine never clears the
    * FLUSH_UPDATE_CURRENT bit, even after performing the update.
    */

   void (*LightingSpaceChange)( GLcontext *ctx );
   /* Notify driver that the special derived value _NeedEyeCoords has
    * changed.
    */

   void (*NewList)( GLcontext *ctx, GLuint list, GLenum mode );
   void (*EndList)( GLcontext *ctx );
   /* Let the t&l component know what is going on with display lists
    * in time to make changes to dispatch tables, etc.
    * Called by glNewList() and glEndList(), respectively.
    */

   void (*BeginCallList)( GLcontext *ctx, GLuint list );
   void (*EndCallList)( GLcontext *ctx );
   /* Notify the t&l component before and after calling a display list.
    * Called by glCallList(s), but not recursively.
    */

   void (*MakeCurrent)( GLcontext *ctx, GLframebuffer *drawBuffer,
			GLframebuffer *readBuffer );
   /* Let the t&l component know when the context becomes current.
    */


   void (*LockArraysEXT)( GLcontext *ctx, GLint first, GLsizei count );
   void (*UnlockArraysEXT)( GLcontext *ctx );
   /* Called by glLockArraysEXT() and glUnlockArraysEXT(), respectively.
    */
d982 1
a982 107
/*
 * Transform/Clip/Lighting interface
 */
typedef struct {
   void (*ArrayElement)( GLint ); /* NOTE */
   void (*Color3f)( GLfloat, GLfloat, GLfloat );
   void (*Color3fv)( const GLfloat * );
   void (*Color3ub)( GLubyte, GLubyte, GLubyte );
   void (*Color3ubv)( const GLubyte * );
   void (*Color4f)( GLfloat, GLfloat, GLfloat, GLfloat );
   void (*Color4fv)( const GLfloat * );
   void (*Color4ub)( GLubyte, GLubyte, GLubyte, GLubyte );
   void (*Color4ubv)( const GLubyte * );
   void (*EdgeFlag)( GLboolean );
   void (*EdgeFlagv)( const GLboolean * );
   void (*EvalCoord1f)( GLfloat );          /* NOTE */
   void (*EvalCoord1fv)( const GLfloat * ); /* NOTE */
   void (*EvalCoord2f)( GLfloat, GLfloat ); /* NOTE */
   void (*EvalCoord2fv)( const GLfloat * ); /* NOTE */
   void (*EvalPoint1)( GLint );             /* NOTE */
   void (*EvalPoint2)( GLint, GLint );      /* NOTE */
   void (*FogCoordfEXT)( GLfloat );
   void (*FogCoordfvEXT)( const GLfloat * );
   void (*Indexi)( GLint );
   void (*Indexiv)( const GLint * );
   void (*Materialfv)( GLenum face, GLenum pname, const GLfloat * ); /* NOTE */
   void (*MultiTexCoord1fARB)( GLenum, GLfloat );
   void (*MultiTexCoord1fvARB)( GLenum, const GLfloat * );
   void (*MultiTexCoord2fARB)( GLenum, GLfloat, GLfloat );
   void (*MultiTexCoord2fvARB)( GLenum, const GLfloat * );
   void (*MultiTexCoord3fARB)( GLenum, GLfloat, GLfloat, GLfloat );
   void (*MultiTexCoord3fvARB)( GLenum, const GLfloat * );
   void (*MultiTexCoord4fARB)( GLenum, GLfloat, GLfloat, GLfloat, GLfloat );
   void (*MultiTexCoord4fvARB)( GLenum, const GLfloat * );
   void (*Normal3f)( GLfloat, GLfloat, GLfloat );
   void (*Normal3fv)( const GLfloat * );
   void (*SecondaryColor3fEXT)( GLfloat, GLfloat, GLfloat );
   void (*SecondaryColor3fvEXT)( const GLfloat * );
   void (*SecondaryColor3ubEXT)( GLubyte, GLubyte, GLubyte );
   void (*SecondaryColor3ubvEXT)( const GLubyte * );
   void (*TexCoord1f)( GLfloat );
   void (*TexCoord1fv)( const GLfloat * );
   void (*TexCoord2f)( GLfloat, GLfloat );
   void (*TexCoord2fv)( const GLfloat * );
   void (*TexCoord3f)( GLfloat, GLfloat, GLfloat );
   void (*TexCoord3fv)( const GLfloat * );
   void (*TexCoord4f)( GLfloat, GLfloat, GLfloat, GLfloat );
   void (*TexCoord4fv)( const GLfloat * );
   void (*Vertex2f)( GLfloat, GLfloat );
   void (*Vertex2fv)( const GLfloat * );
   void (*Vertex3f)( GLfloat, GLfloat, GLfloat );
   void (*Vertex3fv)( const GLfloat * );
   void (*Vertex4f)( GLfloat, GLfloat, GLfloat, GLfloat );
   void (*Vertex4fv)( const GLfloat * );
   void (*CallList)( GLuint );	/* NOTE */
   void (*Begin)( GLenum );
   void (*End)( void );
   void (*VertexAttrib4fNV)( GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w );
   void (*VertexAttrib4fvNV)( GLuint index, const GLfloat *v );

   /* Drivers present a reduced set of the functions possible in
    * begin/end objects.  Core mesa provides translation stubs for the
    * remaining functions to map down to these entrypoints.
    *
    * These are the initial values to be installed into dispatch by
    * mesa.  If the t&l driver wants to modify the dispatch table
    * while installed, it must do so itself.  It would be possible for
    * the vertexformat to install it's own initial values for these
    * functions, but this way there is an obvious list of what is
    * expected of the driver.
    *
    * If the driver wants to hook in entrypoints other than those
    * listed above, it must restore them to their original values in
    * the disable() callback, below.
    */

   void (*Rectf)( GLfloat, GLfloat, GLfloat, GLfloat );
   /*
    */

   void (*DrawArrays)( GLenum mode, GLint start, GLsizei count );
   void (*DrawElements)( GLenum mode, GLsizei count, GLenum type,
			 const GLvoid *indices );
   void (*DrawRangeElements)( GLenum mode, GLuint start,
			      GLuint end, GLsizei count,
			      GLenum type, const GLvoid *indices );
   /* These may or may not belong here.  Heuristic: If an array is
    * enabled, the installed vertex format should support that array and
    * it's current size natively.
    */

   void (*EvalMesh1)( GLenum mode, GLint i1, GLint i2 );
   void (*EvalMesh2)( GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 );
   /* If you don't support eval, fallback to the default vertex format
    * on receiving an eval call and use the pipeline mechanism to
    * provide partial t&l acceleration.
    *
    * Mesa will provide a set of helper functions to do eval within
    * accelerated vertex formats, eventually...
    */

   GLboolean prefer_float_colors;
   /* Should core try to send colors to glColor4f or glColor4chan,
    * where it has a choice?
    */
} GLvertexformat;

a983 1
#endif /* DD_INCLUDED */
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d1 1
d4 4
a7 4
 * Version:  4.0.3
 *
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
 *
d14 1
a14 1
 *
d17 1
a17 1
 *
a30 1
/* THIS FILE ONLY INCLUDED BY mtypes.h !!!!! */
d34 1
d37 83
d130 1
d147 1
a147 1
   void (*UpdateState)( GLcontext *ctx, GLuint new_state );
d149 3
a151 3
    * UpdateState() is called to notify the driver after Mesa has made
    * some internal state changes.  This is in addition to any
    * statechange callbacks Mesa may already have made.
d154 15
a168 2
   void (*Clear)( GLcontext *ctx, GLbitfield mask, GLboolean all,
		  GLint x, GLint y, GLint width, GLint height );
d171 3
a173 1
    * which buffers need to be cleared.
d180 14
a193 1
   void (*SetDrawBuffer)( GLcontext *ctx, GLenum buffer );
d201 4
a210 3
    *
    * Note the driver must organize fallbacks (eg with swrast) if it
    * cannot implement the requested mode.
d213 2
a214 2
   void (*GetBufferSize)( GLframebuffer *buffer,
                          GLuint *width, GLuint *height );
d216 6
a221 2
    * Returns the width and height of the named buffer/window.
    * Mesa uses this to determine when the driver's window size has changed.
d224 1
a224 1
   void (*ResizeBuffers)( GLframebuffer *buffer );
d226 50
a275 3
    * Resize the driver's depth/stencil/accum/back buffers to match the
    * size given in the GLframebuffer struct.  This is typically called
    * when Mesa detects that a window size has changed.
d278 50
d338 24
d368 21
d391 4
a394 1
    *** For hardware accumulation buffer:
d396 10
a405 3
   void (*Accum)( GLcontext *ctx, GLenum op, GLfloat value,
		  GLint xpos, GLint ypos, GLint width, GLint height );
   /* Execute glAccum command within the given scissor region.
d409 48
d461 5
a465 5
   void (*DrawPixels)( GLcontext *ctx,
		       GLint x, GLint y, GLsizei width, GLsizei height,
		       GLenum format, GLenum type,
		       const struct gl_pixelstore_attrib *unpack,
		       const GLvoid *pixels );
d468 2
d472 5
a476 5
   void (*ReadPixels)( GLcontext *ctx,
		       GLint x, GLint y, GLsizei width, GLsizei height,
		       GLenum format, GLenum type,
		       const struct gl_pixelstore_attrib *unpack,
		       GLvoid *dest );
d478 2
d482 1
a482 1
   void (*CopyPixels)( GLcontext *ctx,
d486 2
a487 1
   /* Do a glCopyPixels.  This function must respect all rasterization
d491 4
a494 4
   void (*Bitmap)( GLcontext *ctx,
		   GLint x, GLint y, GLsizei width, GLsizei height,
		   const struct gl_pixelstore_attrib *unpack,
		   const GLubyte *bitmap );
d498 1
d500 1
a500 1
    *** Texture image functions:
d502 43
a544 29
   const struct gl_texture_format *
   (*ChooseTextureFormat)( GLcontext *ctx, GLint internalFormat,
                           GLenum srcFormat, GLenum srcType );
   /* This is called by the _mesa_store_tex[sub]image[123]d() fallback
    * functions.  The driver should examine <internalFormat> and return a
    * pointer to an appropriate gl_texture_format.
    */

   void (*TexImage1D)( GLcontext *ctx, GLenum target, GLint level,
                       GLint internalFormat,
                       GLint width, GLint border,
                       GLenum format, GLenum type, const GLvoid *pixels,
                       const struct gl_pixelstore_attrib *packing,
                       struct gl_texture_object *texObj,
                       struct gl_texture_image *texImage );
   void (*TexImage2D)( GLcontext *ctx, GLenum target, GLint level,
                       GLint internalFormat,
                       GLint width, GLint height, GLint border,
                       GLenum format, GLenum type, const GLvoid *pixels,
                       const struct gl_pixelstore_attrib *packing,
                       struct gl_texture_object *texObj,
                       struct gl_texture_image *texImage );
   void (*TexImage3D)( GLcontext *ctx, GLenum target, GLint level,
                       GLint internalFormat,
                       GLint width, GLint height, GLint depth, GLint border,
                       GLenum format, GLenum type, const GLvoid *pixels,
                       const struct gl_pixelstore_attrib *packing,
                       struct gl_texture_object *texObj,
                       struct gl_texture_image *texImage );
d546 1
d555 29
a583 26
    * Drivers should call a fallback routine from texstore.c if needed.
    */

   void (*TexSubImage1D)( GLcontext *ctx, GLenum target, GLint level,
                          GLint xoffset, GLsizei width,
                          GLenum format, GLenum type,
                          const GLvoid *pixels,
                          const struct gl_pixelstore_attrib *packing,
                          struct gl_texture_object *texObj,
                          struct gl_texture_image *texImage );
   void (*TexSubImage2D)( GLcontext *ctx, GLenum target, GLint level,
                          GLint xoffset, GLint yoffset,
                          GLsizei width, GLsizei height,
                          GLenum format, GLenum type,
                          const GLvoid *pixels,
                          const struct gl_pixelstore_attrib *packing,
                          struct gl_texture_object *texObj,
                          struct gl_texture_image *texImage );
   void (*TexSubImage3D)( GLcontext *ctx, GLenum target, GLint level,
                          GLint xoffset, GLint yoffset, GLint zoffset,
                          GLsizei width, GLsizei height, GLint depth,
                          GLenum format, GLenum type,
                          const GLvoid *pixels,
                          const struct gl_pixelstore_attrib *packing,
                          struct gl_texture_object *texObj,
                          struct gl_texture_image *texImage );
d585 1
d593 3
a595 1
    * The driver should use a fallback routine from texstore.c if needed.
d597 7
a603 7

   void (*CopyTexImage1D)( GLcontext *ctx, GLenum target, GLint level,
                           GLenum internalFormat, GLint x, GLint y,
                           GLsizei width, GLint border );
   void (*CopyTexImage2D)( GLcontext *ctx, GLenum target, GLint level,
                           GLenum internalFormat, GLint x, GLint y,
                           GLsizei width, GLsizei height, GLint border );
d605 3
a607 1
    * Drivers should use a fallback routine from texstore.c if needed.
d610 11
a620 11
   void (*CopyTexSubImage1D)( GLcontext *ctx, GLenum target, GLint level,
                              GLint xoffset,
                              GLint x, GLint y, GLsizei width );
   void (*CopyTexSubImage2D)( GLcontext *ctx, GLenum target, GLint level,
                              GLint xoffset, GLint yoffset,
                              GLint x, GLint y,
                              GLsizei width, GLsizei height );
   void (*CopyTexSubImage3D)( GLcontext *ctx, GLenum target, GLint level,
                              GLint xoffset, GLint yoffset, GLint zoffset,
                              GLint x, GLint y,
                              GLsizei width, GLsizei height );
d622 19
a640 1
    * Drivers should use a fallback routine from texstore.c if needed.
d653 18
a670 23
   /***
    *** Compressed texture functions:
    ***/

   void (*CompressedTexImage1D)( GLcontext *ctx, GLenum target,
                                 GLint level, GLint internalFormat,
                                 GLsizei width, GLint border,
                                 GLsizei imageSize, const GLvoid *data,
                                 struct gl_texture_object *texObj,
                                 struct gl_texture_image *texImage );
   void (*CompressedTexImage2D)( GLcontext *ctx, GLenum target,
                                 GLint level, GLint internalFormat,
                                 GLsizei width, GLsizei height, GLint border,
                                 GLsizei imageSize, const GLvoid *data,
                                 struct gl_texture_object *texObj,
                                 struct gl_texture_image *texImage );
   void (*CompressedTexImage3D)( GLcontext *ctx, GLenum target,
                                 GLint level, GLint internalFormat,
                                 GLsizei width, GLsizei height, GLsizei depth,
                                 GLint border,
                                 GLsizei imageSize, const GLvoid *data,
                                 struct gl_texture_object *texObj,
                                 struct gl_texture_image *texImage );
d683 21
a703 20
   void (*CompressedTexSubImage1D)(GLcontext *ctx, GLenum target, GLint level,
                                   GLint xoffset, GLsizei width,
                                   GLenum format,
                                   GLsizei imageSize, const GLvoid *data,
                                   struct gl_texture_object *texObj,
                                   struct gl_texture_image *texImage);
   void (*CompressedTexSubImage2D)(GLcontext *ctx, GLenum target, GLint level,
                                   GLint xoffset, GLint yoffset,
                                   GLsizei width, GLint height,
                                   GLenum format,
                                   GLsizei imageSize, const GLvoid *data,
                                   struct gl_texture_object *texObj,
                                   struct gl_texture_image *texImage);
   void (*CompressedTexSubImage3D)(GLcontext *ctx, GLenum target, GLint level,
                                   GLint xoffset, GLint yoffset, GLint zoffset,
                                   GLsizei width, GLint height, GLint depth,
                                   GLenum format,
                                   GLsizei imageSize, const GLvoid *data,
                                   struct gl_texture_object *texObj,
                                   struct gl_texture_image *texImage);
a714 10
   void (*GetCompressedTexImage)( GLcontext *ctx, GLenum target,
                                  GLint level, void *image,
                                  const struct gl_texture_object *texObj,
                                  struct gl_texture_image *texImage );
   /* Called by glGetCompressedTexImageARB.
    * <target>, <level>, <image> are specified by user.
    * <texObj> is the source texture object.
    * <texImage> is the source texture image.
    */

d719 1
a719 9
    * compressed format that the driver recognizes.
    * Example: if internalFormat==GL_COMPRESSED_RGB_FXT1_3DFX, return GL_RGB.
    */

   GLint (*CompressedTextureSize)(GLcontext *ctx,
                                  const struct gl_texture_image *texImage);

#if 000
   /* ... Note the
d744 28
a771 1
#endif
d773 10
a782 3
   /***
    *** Texture object functions:
    ***/
a788 4
   void (*CreateTexture)( GLcontext *ctx, struct gl_texture_object *tObj );
   /* Called when a texture object is created.
    */

d794 1
a794 1
   GLboolean (*IsTextureResident)( GLcontext *ctx,
d815 2
d818 1
a818 1
    *** Imaging functionality:
a819 16
   void (*CopyColorTable)( GLcontext *ctx,
			   GLenum target, GLenum internalformat,
			   GLint x, GLint y, GLsizei width );

   void (*CopyColorSubTable)( GLcontext *ctx,
			      GLenum target, GLsizei start,
			      GLint x, GLint y, GLsizei width );

   void (*CopyConvolutionFilter1D)( GLcontext *ctx, GLenum target,
				    GLenum internalFormat,
				    GLint x, GLint y, GLsizei width );

   void (*CopyConvolutionFilter2D)( GLcontext *ctx, GLenum target,
				    GLenum internalFormat,
				    GLint x, GLint y,
				    GLsizei width, GLsizei height );
d821 6
d828 54
d884 1
a884 5
    *** State-changing functions (drawing functions are above)
    ***
    *** These functions are called by their corresponding OpenGL API functions.
    *** They're ALSO called by the gl_PopAttrib() function!!!
    *** May add more functions like these to the device driver in the future.
d886 50
a935 2
   void (*AlphaFunc)(GLcontext *ctx, GLenum func, GLchan ref);
   void (*BlendColor)(GLcontext *ctx, const GLfloat color[4]);
d938 3
a940 3
   void (*BlendFuncSeparate)(GLcontext *ctx,
                             GLenum sfactorRGB, GLenum dfactorRGB,
                             GLenum sfactorA, GLenum dfactorA);
d942 1
a942 2
                           GLfloat blue, GLfloat alpha);
   void (*ClearColor)(GLcontext *ctx, const GLchan color[4]);
a943 6
   void (*ClearIndex)(GLcontext *ctx, GLuint index);
   void (*ClearStencil)(GLcontext *ctx, GLint s);
   void (*ClipPlane)(GLcontext *ctx, GLenum plane, const GLfloat *equation );
   void (*ColorMask)(GLcontext *ctx, GLboolean rmask, GLboolean gmask,
                     GLboolean bmask, GLboolean amask );
   void (*ColorMaterial)(GLcontext *ctx, GLenum face, GLenum mode);
a951 1
   void (*IndexMask)(GLcontext *ctx, GLuint mask);
d953 1
a953 1
		   GLenum pname, const GLfloat *params );
a957 2
   void (*PointParameterfv)(GLcontext *ctx, GLenum pname,
                            const GLfloat *params);
a959 1
   void (*PolygonOffset)(GLcontext *ctx, GLfloat factor, GLfloat units);
a960 1
   void (*RenderMode)(GLcontext *ctx, GLenum mode );
d963 1
a966 8
   void (*TexGen)(GLcontext *ctx, GLenum coord, GLenum pname,
		  const GLfloat *params);
   void (*TexEnv)(GLcontext *ctx, GLenum target, GLenum pname,
                  const GLfloat *param);
   void (*TexParameter)(GLcontext *ctx, GLenum target,
                        struct gl_texture_object *texObj,
                        GLenum pname, const GLfloat *params);
   void (*TextureMatrix)(GLcontext *ctx, GLuint unit, const GLmatrix *mat);
d969 4
a972 27

   /***
    *** Vertex array functions
    ***
    *** Called by the corresponding OpenGL functions.
    ***/
   void (*VertexPointer)(GLcontext *ctx, GLint size, GLenum type,
			 GLsizei stride, const GLvoid *ptr);
   void (*NormalPointer)(GLcontext *ctx, GLenum type,
			 GLsizei stride, const GLvoid *ptr);
   void (*ColorPointer)(GLcontext *ctx, GLint size, GLenum type,
			GLsizei stride, const GLvoid *ptr);
   void (*FogCoordPointer)(GLcontext *ctx, GLenum type,
			   GLsizei stride, const GLvoid *ptr);
   void (*IndexPointer)(GLcontext *ctx, GLenum type,
			GLsizei stride, const GLvoid *ptr);
   void (*SecondaryColorPointer)(GLcontext *ctx, GLint size, GLenum type,
				 GLsizei stride, const GLvoid *ptr);
   void (*TexCoordPointer)(GLcontext *ctx, GLint size, GLenum type,
			   GLsizei stride, const GLvoid *ptr);
   void (*EdgeFlagPointer)(GLcontext *ctx, GLsizei stride, const GLvoid *ptr);


   /*** State-query functions
    ***
    *** Return GL_TRUE if query was completed, GL_FALSE otherwise.
    ***/
a977 88



   /***
    *** Support for multiple t&l engines
    ***/

   GLuint NeedValidate;
   /* Bitmask of state changes that require the current tnl module to be
    * validated, using ValidateTnlModule() below.
    */

   void (*ValidateTnlModule)( GLcontext *ctx, GLuint new_state );
   /* Validate the current tnl module.  This is called directly after
    * UpdateState() when a state change that has occured matches the
    * NeedValidate bitmask above.  This ensures all computed values are
    * up to date, thus allowing the driver to decide if the current tnl
    * module needs to be swapped out.
    *
    * This must be non-NULL if a driver installs a custom tnl module and
    * sets the NeedValidate bitmask, but may be NULL otherwise.
    */


#define PRIM_OUTSIDE_BEGIN_END   GL_POLYGON+1
#define PRIM_INSIDE_UNKNOWN_PRIM GL_POLYGON+2
#define PRIM_UNKNOWN             GL_POLYGON+3

   GLuint CurrentExecPrimitive;
   /* Set by the driver-supplied t&l engine.  Set to
    * PRIM_OUTSIDE_BEGIN_END when outside begin/end.
    */

   GLuint CurrentSavePrimitive;
   /* Current state of an in-progress compilation.  May take on any of
    * the additional values defined above.
    */


#define FLUSH_STORED_VERTICES 0x1
#define FLUSH_UPDATE_CURRENT  0x2
   GLuint NeedFlush;
   /* Set by the driver-supplied t&l engine whenever vertices are
    * buffered between begin/end objects or ctx->Current is not uptodate.
    *
    * The FlushVertices() call below may be used to resolve
    * these conditions.
    */

   void (*FlushVertices)( GLcontext *ctx, GLuint flags );
   /* If inside begin/end, ASSERT(0).
    * Otherwise,
    *   if (flags & FLUSH_STORED_VERTICES) flushes any buffered vertices,
    *   if (flags & FLUSH_UPDATE_CURRENT) updates ctx->Current
    *                                     and ctx->Light.Material
    *
    * Note that the default t&l engine never clears the
    * FLUSH_UPDATE_CURRENT bit, even after performing the update.
    */

   void (*LightingSpaceChange)( GLcontext *ctx );
   /* Notify driver that the special derived value _NeedEyeCoords has
    * changed.
    */

   void (*NewList)( GLcontext *ctx, GLuint list, GLenum mode );
   void (*EndList)( GLcontext *ctx );
   /* Let the t&l component know what is going on with display lists
    * in time to make changes to dispatch tables, etc.
    * Called by glNewList() and glEndList(), respectively.
    */

   void (*BeginCallList)( GLcontext *ctx, GLuint list );
   void (*EndCallList)( GLcontext *ctx );
   /* Notify the t&l component before and after calling a display list.
    * Called by glCallList(s), but not recursively.
    */

   void (*MakeCurrent)( GLcontext *ctx, GLframebuffer *drawBuffer,
			GLframebuffer *readBuffer );
   /* Let the t&l component know when the context becomes current.
    */


   void (*LockArraysEXT)( GLcontext *ctx, GLint first, GLsizei count );
   void (*UnlockArraysEXT)( GLcontext *ctx );
   /* Called by glLockArraysEXT() and glUnlockArraysEXT(), respectively.
    */
d982 1
a982 104
/*
 * Transform/Clip/Lighting interface
 */
typedef struct {
   void (*ArrayElement)( GLint ); /* NOTE */
   void (*Color3f)( GLfloat, GLfloat, GLfloat );
   void (*Color3fv)( const GLfloat * );
   void (*Color3ub)( GLubyte, GLubyte, GLubyte );
   void (*Color3ubv)( const GLubyte * );
   void (*Color4f)( GLfloat, GLfloat, GLfloat, GLfloat );
   void (*Color4fv)( const GLfloat * );
   void (*Color4ub)( GLubyte, GLubyte, GLubyte, GLubyte );
   void (*Color4ubv)( const GLubyte * );
   void (*EdgeFlag)( GLboolean );
   void (*EdgeFlagv)( const GLboolean * );
   void (*EvalCoord1f)( GLfloat );          /* NOTE */
   void (*EvalCoord1fv)( const GLfloat * ); /* NOTE */
   void (*EvalCoord2f)( GLfloat, GLfloat ); /* NOTE */
   void (*EvalCoord2fv)( const GLfloat * ); /* NOTE */
   void (*EvalPoint1)( GLint );             /* NOTE */
   void (*EvalPoint2)( GLint, GLint );      /* NOTE */
   void (*FogCoordfEXT)( GLfloat );
   void (*FogCoordfvEXT)( const GLfloat * );
   void (*Indexi)( GLint );
   void (*Indexiv)( const GLint * );
   void (*Materialfv)( GLenum face, GLenum pname, const GLfloat * ); /* NOTE */
   void (*MultiTexCoord1fARB)( GLenum, GLfloat );
   void (*MultiTexCoord1fvARB)( GLenum, const GLfloat * );
   void (*MultiTexCoord2fARB)( GLenum, GLfloat, GLfloat );
   void (*MultiTexCoord2fvARB)( GLenum, const GLfloat * );
   void (*MultiTexCoord3fARB)( GLenum, GLfloat, GLfloat, GLfloat );
   void (*MultiTexCoord3fvARB)( GLenum, const GLfloat * );
   void (*MultiTexCoord4fARB)( GLenum, GLfloat, GLfloat, GLfloat, GLfloat );
   void (*MultiTexCoord4fvARB)( GLenum, const GLfloat * );
   void (*Normal3f)( GLfloat, GLfloat, GLfloat );
   void (*Normal3fv)( const GLfloat * );
   void (*SecondaryColor3fEXT)( GLfloat, GLfloat, GLfloat );
   void (*SecondaryColor3fvEXT)( const GLfloat * );
   void (*SecondaryColor3ubEXT)( GLubyte, GLubyte, GLubyte );
   void (*SecondaryColor3ubvEXT)( const GLubyte * );
   void (*TexCoord1f)( GLfloat );
   void (*TexCoord1fv)( const GLfloat * );
   void (*TexCoord2f)( GLfloat, GLfloat );
   void (*TexCoord2fv)( const GLfloat * );
   void (*TexCoord3f)( GLfloat, GLfloat, GLfloat );
   void (*TexCoord3fv)( const GLfloat * );
   void (*TexCoord4f)( GLfloat, GLfloat, GLfloat, GLfloat );
   void (*TexCoord4fv)( const GLfloat * );
   void (*Vertex2f)( GLfloat, GLfloat );
   void (*Vertex2fv)( const GLfloat * );
   void (*Vertex3f)( GLfloat, GLfloat, GLfloat );
   void (*Vertex3fv)( const GLfloat * );
   void (*Vertex4f)( GLfloat, GLfloat, GLfloat, GLfloat );
   void (*Vertex4fv)( const GLfloat * );
   void (*CallList)( GLuint );	/* NOTE */
   void (*Begin)( GLenum );
   void (*End)( void );
   /* Drivers present a reduced set of the functions possible in
    * begin/end objects.  Core mesa provides translation stubs for the
    * remaining functions to map down to these entrypoints.
    *
    * These are the initial values to be installed into dispatch by
    * mesa.  If the t&l driver wants to modify the dispatch table
    * while installed, it must do so itself.  It would be possible for
    * the vertexformat to install it's own initial values for these
    * functions, but this way there is an obvious list of what is
    * expected of the driver.
    *
    * If the driver wants to hook in entrypoints other than those
    * listed above, it must restore them to their original values in
    * the disable() callback, below.
    */

   void (*Rectf)( GLfloat, GLfloat, GLfloat, GLfloat );
   /*
    */

   void (*DrawArrays)( GLenum mode, GLint start, GLsizei count );
   void (*DrawElements)( GLenum mode, GLsizei count, GLenum type,
			 const GLvoid *indices );
   void (*DrawRangeElements)( GLenum mode, GLuint start,
			      GLuint end, GLsizei count,
			      GLenum type, const GLvoid *indices );
   /* These may or may not belong here.  Heuristic: If an array is
    * enabled, the installed vertex format should support that array and
    * it's current size natively.
    */

   void (*EvalMesh1)( GLenum mode, GLint i1, GLint i2 );
   void (*EvalMesh2)( GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2 );
   /* If you don't support eval, fallback to the default vertex format
    * on receiving an eval call and use the pipeline mechanism to
    * provide partial t&l acceleration.
    *
    * Mesa will provide a set of helper functions to do eval within
    * accelerated vertex formats, eventually...
    */

   GLboolean prefer_float_colors;
   /* Should core try to send colors to glColor4f or glColor4chan,
    * where it has a choice?
    */
} GLvertexformat;

a983 1
#endif /* DD_INCLUDED */
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@a0 1

d3 1
a3 1
 * Version:  4.1
d32 2
a40 4
#define DD_AUX0            AUX0_BIT               /* future use */
#define DD_AUX1            AUX1_BIT               /* future use */
#define DD_AUX2            AUX2_BIT               /* future use */
#define DD_AUX3            AUX3_BIT               /* future use */
d42 1
a43 1
#define DD_STENCIL_BIT     GL_STENCIL_BUFFER_BIT  /* 0x00000400 */
d51 5
d77 1
a77 2
    * settings!
    * Software Mesa can do masked clears if the device driver can't.
d80 1
a80 1
   void (*DrawBuffer)( GLcontext *ctx, GLenum buffer );
d82 13
a94 1
    * Specifies the current buffer for writing.  Called via glDrawBuffer().
a98 6

   void (*ReadBuffer)( GLcontext *ctx, GLenum buffer );
   /*
    * Specifies the current buffer for reading.  Called via glReadBuffer().
    */

d354 49
d471 1
a471 1
   void (*AlphaFunc)(GLcontext *ctx, GLenum func, GLfloat ref);
d478 3
a480 1
   void (*ClearColor)(GLcontext *ctx, const GLfloat color[4]);
a514 1
   void (*ActiveStencilFace)(GLcontext *ctx, GLuint face);
d525 1
a545 2
   void (*VertexAttribPointer)(GLcontext *ctx, GLuint index, GLint size,
                               GLenum type, GLsizei stride, const GLvoid *ptr);
d558 2
a705 3
   void (*VertexAttrib4fNV)( GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w );
   void (*VertexAttrib4fvNV)( GLuint index, const GLfloat *v );

@


