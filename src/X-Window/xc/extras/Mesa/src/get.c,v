head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.28.16;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.00.58;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.00.58;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.19.57;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.28.39;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.04.39;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@
/*
 * Mesa 3-D graphics library
 * Version:  3.4.2
 * 
 * Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */


#ifdef PC_HEADER
#include "all.h"
#else
#include "glheader.h"
#include "context.h"
#include "enable.h"
#include "enums.h"
#include "extensions.h"
#include "get.h"
#include "macros.h"
#include "matrix.h"
#include "mmath.h"
#include "types.h"
#include "vb.h"
#endif



#define FLOAT_TO_BOOL(X)	( (X)==0.0F ? GL_FALSE : GL_TRUE )
#define INT_TO_BOOL(I)		( (I)==0 ? GL_FALSE : GL_TRUE )
#define ENUM_TO_BOOL(E)		( (E)==0 ? GL_FALSE : GL_TRUE )

#ifdef SPECIALCAST
/* Needed for an Amiga compiler */
#define ENUM_TO_FLOAT(X) ((GLfloat)(GLint)(X))
#define ENUM_TO_DOUBLE(X) ((GLdouble)(GLint)(X))
#else
/* all other compilers */
#define ENUM_TO_FLOAT(X) ((GLfloat)(X))
#define ENUM_TO_DOUBLE(X) ((GLdouble)(X))
#endif


static GLenum
pixel_texgen_mode(const GLcontext *ctx)
{
   if (ctx->Pixel.FragmentRgbSource == GL_CURRENT_RASTER_POSITION) {
      if (ctx->Pixel.FragmentAlphaSource == GL_CURRENT_RASTER_POSITION) {
         return GL_RGBA;
      }
      else {
         return GL_RGB;
      }
   }
   else {
      if (ctx->Pixel.FragmentAlphaSource == GL_CURRENT_RASTER_POSITION) {
         return GL_ALPHA;
      }
      else {
         return GL_NONE;
      }
   }
}



void
_mesa_GetBooleanv( GLenum pname, GLboolean *params )
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint i;
   GLuint texUnit = ctx->Texture.CurrentUnit;
   GLuint texTransformUnit = ctx->Texture.CurrentTransformUnit;
   const struct gl_texture_unit *textureUnit = &ctx->Texture.Unit[texUnit];

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetBooleanv");

   if (!params)
      return;

   if (MESA_VERBOSE & VERBOSE_API) 
      fprintf(stderr, "glGetBooleanv %s\n", gl_lookup_enum_by_nr(pname));

   if (ctx->Driver.GetBooleanv
       && (*ctx->Driver.GetBooleanv)(ctx, pname, params))
      return;

   switch (pname) {
      case GL_ACCUM_RED_BITS:
         *params = INT_TO_BOOL(ctx->Visual->AccumRedBits);
         break;
      case GL_ACCUM_GREEN_BITS:
         *params = INT_TO_BOOL(ctx->Visual->AccumGreenBits);
         break;
      case GL_ACCUM_BLUE_BITS:
         *params = INT_TO_BOOL(ctx->Visual->AccumBlueBits);
         break;
      case GL_ACCUM_ALPHA_BITS:
         *params = INT_TO_BOOL(ctx->Visual->AccumAlphaBits);
         break;
      case GL_ACCUM_CLEAR_VALUE:
         params[0] = FLOAT_TO_BOOL(ctx->Accum.ClearColor[0]);
         params[1] = FLOAT_TO_BOOL(ctx->Accum.ClearColor[1]);
         params[2] = FLOAT_TO_BOOL(ctx->Accum.ClearColor[2]);
         params[3] = FLOAT_TO_BOOL(ctx->Accum.ClearColor[3]);
         break;
      case GL_ALPHA_BIAS:
         *params = FLOAT_TO_BOOL(ctx->Pixel.AlphaBias);
         break;
      case GL_ALPHA_BITS:
         *params = INT_TO_BOOL(ctx->Visual->AlphaBits);
         break;
      case GL_ALPHA_SCALE:
         *params = FLOAT_TO_BOOL(ctx->Pixel.AlphaScale);
         break;
      case GL_ALPHA_TEST:
         *params = ctx->Color.AlphaEnabled;
         break;
      case GL_ALPHA_TEST_FUNC:
         *params = ENUM_TO_BOOL(ctx->Color.AlphaFunc);
         break;
      case GL_ALPHA_TEST_REF:
         *params = FLOAT_TO_BOOL((GLfloat) ctx->Color.AlphaRef / 255.0);
         break;
      case GL_ATTRIB_STACK_DEPTH:
         *params = INT_TO_BOOL(ctx->AttribStackDepth);
         break;
      case GL_AUTO_NORMAL:
         *params = ctx->Eval.AutoNormal;
         break;
      case GL_AUX_BUFFERS:
         *params = (ctx->Const.NumAuxBuffers) ? GL_TRUE : GL_FALSE;
         break;
      case GL_BLEND:
         *params = ctx->Color.BlendEnabled;
         break;
      case GL_BLEND_DST:
         *params = ENUM_TO_BOOL(ctx->Color.BlendDstRGB);
         break;
      case GL_BLEND_SRC:
         *params = ENUM_TO_BOOL(ctx->Color.BlendSrcRGB);
         break;
      case GL_BLEND_SRC_RGB_EXT:
         *params = ENUM_TO_BOOL(ctx->Color.BlendSrcRGB);
         break;
      case GL_BLEND_DST_RGB_EXT:
         *params = ENUM_TO_BOOL(ctx->Color.BlendDstRGB);
         break;
      case GL_BLEND_SRC_ALPHA_EXT:
         *params = ENUM_TO_BOOL(ctx->Color.BlendSrcA);
         break;
      case GL_BLEND_DST_ALPHA_EXT:
         *params = ENUM_TO_BOOL(ctx->Color.BlendDstA);
         break;
      case GL_BLEND_EQUATION_EXT:
	 *params = ENUM_TO_BOOL( ctx->Color.BlendEquation );
	 break;
      case GL_BLEND_COLOR_EXT:
	 params[0] = FLOAT_TO_BOOL( ctx->Color.BlendColor[0] );
	 params[1] = FLOAT_TO_BOOL( ctx->Color.BlendColor[1] );
	 params[2] = FLOAT_TO_BOOL( ctx->Color.BlendColor[2] );
	 params[3] = FLOAT_TO_BOOL( ctx->Color.BlendColor[3] );
	 break;
      case GL_BLUE_BIAS:
         *params = FLOAT_TO_BOOL(ctx->Pixel.BlueBias);
         break;
      case GL_BLUE_BITS:
         *params = INT_TO_BOOL( ctx->Visual->BlueBits );
         break;
      case GL_BLUE_SCALE:
         *params = FLOAT_TO_BOOL(ctx->Pixel.BlueScale);
         break;
      case GL_CLIENT_ATTRIB_STACK_DEPTH:
         *params = INT_TO_BOOL(ctx->ClientAttribStackDepth);
         break;
      case GL_CLIP_PLANE0:
      case GL_CLIP_PLANE1:
      case GL_CLIP_PLANE2:
      case GL_CLIP_PLANE3:
      case GL_CLIP_PLANE4:
      case GL_CLIP_PLANE5:
         *params = ctx->Transform.ClipEnabled[pname-GL_CLIP_PLANE0];
         break;
      case GL_COLOR_CLEAR_VALUE:
         params[0] = FLOAT_TO_BOOL(ctx->Color.ClearColor[0]);
         params[1] = FLOAT_TO_BOOL(ctx->Color.ClearColor[1]);
         params[2] = FLOAT_TO_BOOL(ctx->Color.ClearColor[2]);
         params[3] = FLOAT_TO_BOOL(ctx->Color.ClearColor[3]);
         break;
      case GL_COLOR_MATERIAL:
         *params = ctx->Light.ColorMaterialEnabled;
         break;
      case GL_COLOR_MATERIAL_FACE:
         *params = ENUM_TO_BOOL(ctx->Light.ColorMaterialFace);
         break;
      case GL_COLOR_MATERIAL_PARAMETER:
         *params = ENUM_TO_BOOL(ctx->Light.ColorMaterialMode);
         break;
      case GL_COLOR_WRITEMASK:
         params[0] = ctx->Color.ColorMask[RCOMP] ? GL_TRUE : GL_FALSE;
         params[1] = ctx->Color.ColorMask[GCOMP] ? GL_TRUE : GL_FALSE;
         params[2] = ctx->Color.ColorMask[BCOMP] ? GL_TRUE : GL_FALSE;
         params[3] = ctx->Color.ColorMask[ACOMP] ? GL_TRUE : GL_FALSE;
         break;
      case GL_CULL_FACE:
         *params = ctx->Polygon.CullFlag;
         break;
      case GL_CULL_FACE_MODE:
         *params = ENUM_TO_BOOL(ctx->Polygon.CullFaceMode);
         break;
      case GL_CURRENT_COLOR:
         params[0] = INT_TO_BOOL(ctx->Current.ByteColor[0]);
         params[1] = INT_TO_BOOL(ctx->Current.ByteColor[1]);
         params[2] = INT_TO_BOOL(ctx->Current.ByteColor[2]);
         params[3] = INT_TO_BOOL(ctx->Current.ByteColor[3]);
         break;
      case GL_CURRENT_INDEX:
         *params = INT_TO_BOOL(ctx->Current.Index);
         break;
      case GL_CURRENT_NORMAL:
         params[0] = FLOAT_TO_BOOL(ctx->Current.Normal[0]);
         params[1] = FLOAT_TO_BOOL(ctx->Current.Normal[1]);
         params[2] = FLOAT_TO_BOOL(ctx->Current.Normal[2]);
         break;
      case GL_CURRENT_RASTER_COLOR:
	 params[0] = FLOAT_TO_BOOL(ctx->Current.RasterColor[0]);
	 params[1] = FLOAT_TO_BOOL(ctx->Current.RasterColor[1]);
	 params[2] = FLOAT_TO_BOOL(ctx->Current.RasterColor[2]);
	 params[3] = FLOAT_TO_BOOL(ctx->Current.RasterColor[3]);
	 break;
      case GL_CURRENT_RASTER_DISTANCE:
	 *params = FLOAT_TO_BOOL(ctx->Current.RasterDistance);
	 break;
      case GL_CURRENT_RASTER_INDEX:
	 *params = FLOAT_TO_BOOL(ctx->Current.RasterIndex);
	 break;
      case GL_CURRENT_RASTER_POSITION:
	 params[0] = FLOAT_TO_BOOL(ctx->Current.RasterPos[0]);
	 params[1] = FLOAT_TO_BOOL(ctx->Current.RasterPos[1]);
	 params[2] = FLOAT_TO_BOOL(ctx->Current.RasterPos[2]);
	 params[3] = FLOAT_TO_BOOL(ctx->Current.RasterPos[3]);
	 break;
      case GL_CURRENT_RASTER_TEXTURE_COORDS:
         params[0] = FLOAT_TO_BOOL(ctx->Current.RasterMultiTexCoord[texTransformUnit][0]);
         params[1] = FLOAT_TO_BOOL(ctx->Current.RasterMultiTexCoord[texTransformUnit][1]);
         params[2] = FLOAT_TO_BOOL(ctx->Current.RasterMultiTexCoord[texTransformUnit][2]);
         params[3] = FLOAT_TO_BOOL(ctx->Current.RasterMultiTexCoord[texTransformUnit][3]);
	 break;
      case GL_CURRENT_RASTER_POSITION_VALID:
         *params = ctx->Current.RasterPosValid;
	 break;
      case GL_CURRENT_TEXTURE_COORDS:
         params[0] = FLOAT_TO_BOOL(ctx->Current.Texcoord[texTransformUnit][0]);
         params[1] = FLOAT_TO_BOOL(ctx->Current.Texcoord[texTransformUnit][1]);
         params[2] = FLOAT_TO_BOOL(ctx->Current.Texcoord[texTransformUnit][2]);
         params[3] = FLOAT_TO_BOOL(ctx->Current.Texcoord[texTransformUnit][3]);
	 break;
      case GL_DEPTH_BIAS:
         *params = FLOAT_TO_BOOL(ctx->Pixel.DepthBias);
	 break;
      case GL_DEPTH_BITS:
	 *params = INT_TO_BOOL(ctx->Visual->DepthBits);
	 break;
      case GL_DEPTH_CLEAR_VALUE:
         *params = FLOAT_TO_BOOL(ctx->Depth.Clear);
	 break;
      case GL_DEPTH_FUNC:
         *params = ENUM_TO_BOOL(ctx->Depth.Func);
	 break;
      case GL_DEPTH_RANGE:
         params[0] = FLOAT_TO_BOOL(ctx->Viewport.Near);
         params[1] = FLOAT_TO_BOOL(ctx->Viewport.Far);
	 break;
      case GL_DEPTH_SCALE:
         *params = FLOAT_TO_BOOL(ctx->Pixel.DepthScale);
	 break;
      case GL_DEPTH_TEST:
         *params = ctx->Depth.Test;
	 break;
      case GL_DEPTH_WRITEMASK:
	 *params = ctx->Depth.Mask;
	 break;
      case GL_DITHER:
	 *params = ctx->Color.DitherFlag;
	 break;
      case GL_DOUBLEBUFFER:
	 *params = ctx->Visual->DBflag;
	 break;
      case GL_DRAW_BUFFER:
	 *params = ENUM_TO_BOOL(ctx->Color.DrawBuffer);
	 break;
      case GL_EDGE_FLAG:
	 *params = ctx->Current.EdgeFlag;
	 break;
      case GL_FEEDBACK_BUFFER_SIZE:
         *params = INT_TO_BOOL(ctx->Feedback.BufferSize);
         break;
      case GL_FEEDBACK_BUFFER_TYPE:
         *params = INT_TO_BOOL(ctx->Feedback.Type);
         break;
      case GL_FOG:
	 *params = ctx->Fog.Enabled;
	 break;
      case GL_FOG_COLOR:
         params[0] = FLOAT_TO_BOOL(ctx->Fog.Color[0]);
         params[1] = FLOAT_TO_BOOL(ctx->Fog.Color[1]);
         params[2] = FLOAT_TO_BOOL(ctx->Fog.Color[2]);
         params[3] = FLOAT_TO_BOOL(ctx->Fog.Color[3]);
	 break;
      case GL_FOG_DENSITY:
         *params = FLOAT_TO_BOOL(ctx->Fog.Density);
	 break;
      case GL_FOG_END:
         *params = FLOAT_TO_BOOL(ctx->Fog.End);
	 break;
      case GL_FOG_HINT:
	 *params = ENUM_TO_BOOL(ctx->Hint.Fog);
	 break;
      case GL_FOG_INDEX:
	 *params = FLOAT_TO_BOOL(ctx->Fog.Index);
	 break;
      case GL_FOG_MODE:
	 *params = ENUM_TO_BOOL(ctx->Fog.Mode);
	 break;
      case GL_FOG_START:
         *params = FLOAT_TO_BOOL(ctx->Fog.End);
	 break;
      case GL_FRONT_FACE:
	 *params = ENUM_TO_BOOL(ctx->Polygon.FrontFace);
	 break;
      case GL_GREEN_BIAS:
         *params = FLOAT_TO_BOOL(ctx->Pixel.GreenBias);
	 break;
      case GL_GREEN_BITS:
         *params = INT_TO_BOOL( ctx->Visual->GreenBits );
	 break;
      case GL_GREEN_SCALE:
         *params = FLOAT_TO_BOOL(ctx->Pixel.GreenScale);
	 break;
      case GL_HISTOGRAM:
         *params = ctx->Pixel.HistogramEnabled;
	 break;
      case GL_INDEX_BITS:
         *params = INT_TO_BOOL( ctx->Visual->IndexBits );
	 break;
      case GL_INDEX_CLEAR_VALUE:
	 *params = INT_TO_BOOL(ctx->Color.ClearIndex);
	 break;
      case GL_INDEX_MODE:
	 *params = ctx->Visual->RGBAflag ? GL_FALSE : GL_TRUE;
	 break;
      case GL_INDEX_OFFSET:
	 *params = INT_TO_BOOL(ctx->Pixel.IndexOffset);
	 break;
      case GL_INDEX_SHIFT:
	 *params = INT_TO_BOOL(ctx->Pixel.IndexShift);
	 break;
      case GL_INDEX_WRITEMASK:
	 *params = INT_TO_BOOL(ctx->Color.IndexMask);
	 break;
      case GL_LIGHT0:
      case GL_LIGHT1:
      case GL_LIGHT2:
      case GL_LIGHT3:
      case GL_LIGHT4:
      case GL_LIGHT5:
      case GL_LIGHT6:
      case GL_LIGHT7:
	 *params = ctx->Light.Light[pname-GL_LIGHT0].Enabled;
	 break;
      case GL_LIGHTING:
	 *params = ctx->Light.Enabled;
	 break;
      case GL_LIGHT_MODEL_AMBIENT:
	 params[0] = FLOAT_TO_BOOL(ctx->Light.Model.Ambient[0]);
	 params[1] = FLOAT_TO_BOOL(ctx->Light.Model.Ambient[1]);
	 params[2] = FLOAT_TO_BOOL(ctx->Light.Model.Ambient[2]);
	 params[3] = FLOAT_TO_BOOL(ctx->Light.Model.Ambient[3]);
	 break;
      case GL_LIGHT_MODEL_COLOR_CONTROL:
         params[0] = ENUM_TO_BOOL(ctx->Light.Model.ColorControl);
         break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
	 *params = ctx->Light.Model.LocalViewer;
	 break;
      case GL_LIGHT_MODEL_TWO_SIDE:
	 *params = ctx->Light.Model.TwoSide;
	 break;
      case GL_LINE_SMOOTH:
	 *params = ctx->Line.SmoothFlag;
	 break;
      case GL_LINE_SMOOTH_HINT:
	 *params = ENUM_TO_BOOL(ctx->Hint.LineSmooth);
	 break;
      case GL_LINE_STIPPLE:
	 *params = ctx->Line.StippleFlag;
	 break;
      case GL_LINE_STIPPLE_PATTERN:
	 *params = INT_TO_BOOL(ctx->Line.StipplePattern);
	 break;
      case GL_LINE_STIPPLE_REPEAT:
	 *params = INT_TO_BOOL(ctx->Line.StippleFactor);
	 break;
      case GL_LINE_WIDTH:
	 *params = FLOAT_TO_BOOL(ctx->Line.Width);
	 break;
      case GL_LINE_WIDTH_GRANULARITY:
	 *params = FLOAT_TO_BOOL(ctx->Const.LineWidthGranularity);
	 break;
      case GL_LINE_WIDTH_RANGE:
	 params[0] = FLOAT_TO_BOOL(ctx->Const.MinLineWidthAA);
	 params[1] = FLOAT_TO_BOOL(ctx->Const.MaxLineWidthAA);
         break;
      case GL_ALIASED_LINE_WIDTH_RANGE:
	 params[0] = FLOAT_TO_BOOL(ctx->Const.MinLineWidth);
	 params[1] = FLOAT_TO_BOOL(ctx->Const.MaxLineWidth);
	 break;
      case GL_LIST_BASE:
	 *params = INT_TO_BOOL(ctx->List.ListBase);
	 break;
      case GL_LIST_INDEX:
	 *params = INT_TO_BOOL( ctx->CurrentListNum );
	 break;
      case GL_LIST_MODE:
	 *params = ENUM_TO_BOOL( ctx->ExecuteFlag
				  ? GL_COMPILE_AND_EXECUTE : GL_COMPILE );
	 break;
      case GL_INDEX_LOGIC_OP:
	 *params = ctx->Color.IndexLogicOpEnabled;
	 break;
      case GL_COLOR_LOGIC_OP:
	 *params = ctx->Color.ColorLogicOpEnabled;
	 break;
      case GL_LOGIC_OP_MODE:
	 *params = ENUM_TO_BOOL(ctx->Color.LogicOp);
	 break;
      case GL_MAP1_COLOR_4:
	 *params = ctx->Eval.Map1Color4;
	 break;
      case GL_MAP1_GRID_DOMAIN:
	 params[0] = FLOAT_TO_BOOL(ctx->Eval.MapGrid1u1);
	 params[1] = FLOAT_TO_BOOL(ctx->Eval.MapGrid1u2);
	 break;
      case GL_MAP1_GRID_SEGMENTS:
	 *params = INT_TO_BOOL(ctx->Eval.MapGrid1un);
	 break;
      case GL_MAP1_INDEX:
	 *params = ctx->Eval.Map1Index;
	 break;
      case GL_MAP1_NORMAL:
	 *params = ctx->Eval.Map1Normal;
	 break;
      case GL_MAP1_TEXTURE_COORD_1:
	 *params = ctx->Eval.Map1TextureCoord1;
	 break;
      case GL_MAP1_TEXTURE_COORD_2:
	 *params = ctx->Eval.Map1TextureCoord2;
	 break;
      case GL_MAP1_TEXTURE_COORD_3:
	 *params = ctx->Eval.Map1TextureCoord3;
	 break;
      case GL_MAP1_TEXTURE_COORD_4:
	 *params = ctx->Eval.Map1TextureCoord4;
	 break;
      case GL_MAP1_VERTEX_3:
	 *params = ctx->Eval.Map1Vertex3;
	 break;
      case GL_MAP1_VERTEX_4:
	 *params = ctx->Eval.Map1Vertex4;
	 break;
      case GL_MAP2_COLOR_4:
	 *params = ctx->Eval.Map2Color4;
	 break;
      case GL_MAP2_GRID_DOMAIN:
	 params[0] = FLOAT_TO_BOOL(ctx->Eval.MapGrid2u1);
	 params[1] = FLOAT_TO_BOOL(ctx->Eval.MapGrid2u2);
	 params[2] = FLOAT_TO_BOOL(ctx->Eval.MapGrid2v1);
	 params[3] = FLOAT_TO_BOOL(ctx->Eval.MapGrid2v2);
	 break;
      case GL_MAP2_GRID_SEGMENTS:
	 params[0] = INT_TO_BOOL(ctx->Eval.MapGrid2un);
	 params[1] = INT_TO_BOOL(ctx->Eval.MapGrid2vn);
	 break;
      case GL_MAP2_INDEX:
	 *params = ctx->Eval.Map2Index;
	 break;
      case GL_MAP2_NORMAL:
	 *params = ctx->Eval.Map2Normal;
	 break;
      case GL_MAP2_TEXTURE_COORD_1:
	 *params = ctx->Eval.Map2TextureCoord1;
	 break;
      case GL_MAP2_TEXTURE_COORD_2:
	 *params = ctx->Eval.Map2TextureCoord2;
	 break;
      case GL_MAP2_TEXTURE_COORD_3:
	 *params = ctx->Eval.Map2TextureCoord3;
	 break;
      case GL_MAP2_TEXTURE_COORD_4:
	 *params = ctx->Eval.Map2TextureCoord4;
	 break;
      case GL_MAP2_VERTEX_3:
	 *params = ctx->Eval.Map2Vertex3;
	 break;
      case GL_MAP2_VERTEX_4:
	 *params = ctx->Eval.Map2Vertex4;
	 break;
      case GL_MAP_COLOR:
	 *params = ctx->Pixel.MapColorFlag;
	 break;
      case GL_MAP_STENCIL:
	 *params = ctx->Pixel.MapStencilFlag;
	 break;
      case GL_MATRIX_MODE:
	 *params = ENUM_TO_BOOL( ctx->Transform.MatrixMode );
	 break;
      case GL_MAX_ATTRIB_STACK_DEPTH:
	 *params = INT_TO_BOOL(MAX_ATTRIB_STACK_DEPTH);
	 break;
      case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
         *params = INT_TO_BOOL( MAX_CLIENT_ATTRIB_STACK_DEPTH);
         break;
      case GL_MAX_CLIP_PLANES:
	 *params = INT_TO_BOOL(MAX_CLIP_PLANES);
	 break;
      case GL_MAX_ELEMENTS_VERTICES:  /* GL_VERSION_1_2 */
         *params = INT_TO_BOOL(VB_MAX);
         break;
      case GL_MAX_ELEMENTS_INDICES:   /* GL_VERSION_1_2 */
         *params = INT_TO_BOOL(VB_MAX);
         break;
      case GL_MAX_EVAL_ORDER:
	 *params = INT_TO_BOOL(MAX_EVAL_ORDER);
	 break;
      case GL_MAX_LIGHTS:
	 *params = INT_TO_BOOL(MAX_LIGHTS);
	 break;
      case GL_MAX_LIST_NESTING:
	 *params = INT_TO_BOOL(MAX_LIST_NESTING);
	 break;
      case GL_MAX_MODELVIEW_STACK_DEPTH:
	 *params = INT_TO_BOOL(MAX_MODELVIEW_STACK_DEPTH);
	 break;
      case GL_MAX_NAME_STACK_DEPTH:
	 *params = INT_TO_BOOL(MAX_NAME_STACK_DEPTH);
	 break;
      case GL_MAX_PIXEL_MAP_TABLE:
	 *params = INT_TO_BOOL(MAX_PIXEL_MAP_TABLE);
	 break;
      case GL_MAX_PROJECTION_STACK_DEPTH:
	 *params = INT_TO_BOOL(MAX_PROJECTION_STACK_DEPTH);
	 break;
      case GL_MAX_TEXTURE_SIZE:
      case GL_MAX_3D_TEXTURE_SIZE:
         *params = INT_TO_BOOL(ctx->Const.MaxTextureSize);
	 break;
      case GL_MAX_TEXTURE_STACK_DEPTH:
	 *params = INT_TO_BOOL(MAX_TEXTURE_STACK_DEPTH);
	 break;
      case GL_MAX_VIEWPORT_DIMS:
	 params[0] = INT_TO_BOOL(MAX_WIDTH);
	 params[1] = INT_TO_BOOL(MAX_HEIGHT);
	 break;
      case GL_MINMAX:
         *params = ctx->Pixel.MinMaxEnabled;
         break;
      case GL_MODELVIEW_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = FLOAT_TO_BOOL(ctx->ModelView.m[i]);
	 }
	 break;
      case GL_MODELVIEW_STACK_DEPTH:
	 *params = INT_TO_BOOL(ctx->ModelViewStackDepth + 1);
	 break;
      case GL_NAME_STACK_DEPTH:
	 *params = INT_TO_BOOL(ctx->Select.NameStackDepth);
	 break;
      case GL_NORMALIZE:
	 *params = ctx->Transform.Normalize;
	 break;
      case GL_PACK_ALIGNMENT:
	 *params = INT_TO_BOOL(ctx->Pack.Alignment);
	 break;
      case GL_PACK_LSB_FIRST:
	 *params = ctx->Pack.LsbFirst;
	 break;
      case GL_PACK_ROW_LENGTH:
	 *params = INT_TO_BOOL(ctx->Pack.RowLength);
	 break;
      case GL_PACK_SKIP_PIXELS:
	 *params = INT_TO_BOOL(ctx->Pack.SkipPixels);
	 break;
      case GL_PACK_SKIP_ROWS:
	 *params = INT_TO_BOOL(ctx->Pack.SkipRows);
	 break;
      case GL_PACK_SWAP_BYTES:
	 *params = ctx->Pack.SwapBytes;
	 break;
      case GL_PACK_SKIP_IMAGES_EXT:
         *params = ctx->Pack.SkipImages;
         break;
      case GL_PACK_IMAGE_HEIGHT_EXT:
         *params = ctx->Pack.ImageHeight;
         break;
      case GL_PERSPECTIVE_CORRECTION_HINT:
	 *params = ENUM_TO_BOOL(ctx->Hint.PerspectiveCorrection);
	 break;
      case GL_PIXEL_MAP_A_TO_A_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapAtoAsize);
	 break;
      case GL_PIXEL_MAP_B_TO_B_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapBtoBsize);
	 break;
      case GL_PIXEL_MAP_G_TO_G_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapGtoGsize);
	 break;
      case GL_PIXEL_MAP_I_TO_A_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapItoAsize);
	 break;
      case GL_PIXEL_MAP_I_TO_B_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapItoBsize);
	 break;
      case GL_PIXEL_MAP_I_TO_G_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapItoGsize);
	 break;
      case GL_PIXEL_MAP_I_TO_I_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapItoIsize);
	 break;
      case GL_PIXEL_MAP_I_TO_R_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapItoRsize);
	 break;
      case GL_PIXEL_MAP_R_TO_R_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapRtoRsize);
	 break;
      case GL_PIXEL_MAP_S_TO_S_SIZE:
	 *params = INT_TO_BOOL(ctx->Pixel.MapStoSsize);
	 break;
      case GL_POINT_SIZE:
	 *params = FLOAT_TO_BOOL(ctx->Point.UserSize);
	 break;
      case GL_POINT_SIZE_GRANULARITY:
	 *params = FLOAT_TO_BOOL(ctx->Const.PointSizeGranularity );
	 break;
      case GL_POINT_SIZE_RANGE:
	 params[0] = FLOAT_TO_BOOL(ctx->Const.MinPointSizeAA);
	 params[1] = FLOAT_TO_BOOL(ctx->Const.MaxPointSizeAA);
         break;
      case GL_ALIASED_POINT_SIZE_RANGE:
	 params[0] = FLOAT_TO_BOOL(ctx->Const.MinPointSize);
	 params[1] = FLOAT_TO_BOOL(ctx->Const.MaxPointSize);
	 break;
      case GL_POINT_SMOOTH:
	 *params = ctx->Point.SmoothFlag;
	 break;
      case GL_POINT_SMOOTH_HINT:
	 *params = ENUM_TO_BOOL(ctx->Hint.PointSmooth);
	 break;
      case GL_POINT_SIZE_MIN_EXT:
	 *params = FLOAT_TO_BOOL(ctx->Point.MinSize);
	 break;
      case GL_POINT_SIZE_MAX_EXT:
	 *params = FLOAT_TO_BOOL(ctx->Point.MaxSize);
	 break;
      case GL_POINT_FADE_THRESHOLD_SIZE_EXT:
	 *params = FLOAT_TO_BOOL(ctx->Point.Threshold);
	 break;
      case GL_DISTANCE_ATTENUATION_EXT:
	 params[0] = FLOAT_TO_BOOL(ctx->Point.Params[0]);
	 params[1] = FLOAT_TO_BOOL(ctx->Point.Params[1]);
	 params[2] = FLOAT_TO_BOOL(ctx->Point.Params[2]);
	 break;
      case GL_POLYGON_MODE:
	 params[0] = ENUM_TO_BOOL(ctx->Polygon.FrontMode);
	 params[1] = ENUM_TO_BOOL(ctx->Polygon.BackMode);
	 break;
      case GL_POLYGON_OFFSET_BIAS_EXT:  /* GL_EXT_polygon_offset */
         *params = FLOAT_TO_BOOL( ctx->Polygon.OffsetUnits );
         break;
      case GL_POLYGON_OFFSET_FACTOR:
         *params = FLOAT_TO_BOOL( ctx->Polygon.OffsetFactor );
         break;
      case GL_POLYGON_OFFSET_UNITS:
         *params = FLOAT_TO_BOOL( ctx->Polygon.OffsetUnits );
         break;
      case GL_POLYGON_SMOOTH:
	 *params = ctx->Polygon.SmoothFlag;
	 break;
      case GL_POLYGON_SMOOTH_HINT:
	 *params = ENUM_TO_BOOL(ctx->Hint.PolygonSmooth);
	 break;
      case GL_POLYGON_STIPPLE:
	 *params = ctx->Polygon.StippleFlag;
	 break;
      case GL_PROJECTION_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = FLOAT_TO_BOOL(ctx->ProjectionMatrix.m[i]);
	 }
	 break;
      case GL_PROJECTION_STACK_DEPTH:
	 *params = INT_TO_BOOL(ctx->ProjectionStackDepth + 1);
	 break;
      case GL_READ_BUFFER:
	 *params = ENUM_TO_BOOL(ctx->Pixel.ReadBuffer);
	 break;
      case GL_RED_BIAS:
         *params = FLOAT_TO_BOOL(ctx->Pixel.RedBias);
	 break;
      case GL_RED_BITS:
         *params = INT_TO_BOOL( ctx->Visual->RedBits );
	 break;
      case GL_RED_SCALE:
         *params = FLOAT_TO_BOOL(ctx->Pixel.RedScale);
	 break;
      case GL_RENDER_MODE:
	 *params = ENUM_TO_BOOL(ctx->RenderMode);
	 break;
      case GL_RESCALE_NORMAL:
         *params = ctx->Transform.RescaleNormals;
         break;
      case GL_RGBA_MODE:
         *params = ctx->Visual->RGBAflag;
	 break;
      case GL_SCISSOR_BOX:
	 params[0] = INT_TO_BOOL(ctx->Scissor.X);
	 params[1] = INT_TO_BOOL(ctx->Scissor.Y);
	 params[2] = INT_TO_BOOL(ctx->Scissor.Width);
	 params[3] = INT_TO_BOOL(ctx->Scissor.Height);
	 break;
      case GL_SCISSOR_TEST:
	 *params = ctx->Scissor.Enabled;
	 break;
      case GL_SELECTION_BUFFER_SIZE:
         *params = INT_TO_BOOL(ctx->Select.BufferSize);
         break;
      case GL_SHADE_MODEL:
	 *params = ENUM_TO_BOOL(ctx->Light.ShadeModel);
	 break;
      case GL_SHARED_TEXTURE_PALETTE_EXT:
         *params = ctx->Texture.SharedPalette;
         break;
      case GL_STENCIL_BITS:
	 *params = INT_TO_BOOL(ctx->Visual->StencilBits);
	 break;
      case GL_STENCIL_CLEAR_VALUE:
	 *params = INT_TO_BOOL(ctx->Stencil.Clear);
	 break;
      case GL_STENCIL_FAIL:
	 *params = ENUM_TO_BOOL(ctx->Stencil.FailFunc);
	 break;
      case GL_STENCIL_FUNC:
	 *params = ENUM_TO_BOOL(ctx->Stencil.Function);
	 break;
      case GL_STENCIL_PASS_DEPTH_FAIL:
	 *params = ENUM_TO_BOOL(ctx->Stencil.ZFailFunc);
	 break;
      case GL_STENCIL_PASS_DEPTH_PASS:
	 *params = ENUM_TO_BOOL(ctx->Stencil.ZPassFunc);
	 break;
      case GL_STENCIL_REF:
	 *params = INT_TO_BOOL(ctx->Stencil.Ref);
	 break;
      case GL_STENCIL_TEST:
	 *params = ctx->Stencil.Enabled;
	 break;
      case GL_STENCIL_VALUE_MASK:
	 *params = INT_TO_BOOL(ctx->Stencil.ValueMask);
	 break;
      case GL_STENCIL_WRITEMASK:
	 *params = INT_TO_BOOL(ctx->Stencil.WriteMask);
	 break;
      case GL_STEREO:
	 *params = ctx->Visual->StereoFlag;
	 break;
      case GL_SUBPIXEL_BITS:
	 *params = INT_TO_BOOL(ctx->Const.SubPixelBits);
	 break;
      case GL_TEXTURE_1D:
         *params = _mesa_IsEnabled(GL_TEXTURE_1D);
	 break;
      case GL_TEXTURE_2D:
         *params = _mesa_IsEnabled(GL_TEXTURE_2D);
	 break;
      case GL_TEXTURE_3D:
         *params = _mesa_IsEnabled(GL_TEXTURE_3D);
	 break;
      case GL_TEXTURE_BINDING_1D:
         *params = INT_TO_BOOL(textureUnit->CurrentD[1]->Name);
          break;
      case GL_TEXTURE_BINDING_2D:
         *params = INT_TO_BOOL(textureUnit->CurrentD[2]->Name);
          break;
      case GL_TEXTURE_BINDING_3D:
         *params = INT_TO_BOOL(textureUnit->CurrentD[3]->Name);
         break;
      case GL_TEXTURE_ENV_COLOR:
         {
            params[0] = FLOAT_TO_BOOL(textureUnit->EnvColor[0]);
            params[1] = FLOAT_TO_BOOL(textureUnit->EnvColor[1]);
            params[2] = FLOAT_TO_BOOL(textureUnit->EnvColor[2]);
            params[3] = FLOAT_TO_BOOL(textureUnit->EnvColor[3]);
         }
	 break;
      case GL_TEXTURE_ENV_MODE:
	 *params = ENUM_TO_BOOL(textureUnit->EnvMode);
	 break;
      case GL_TEXTURE_GEN_S:
	 *params = (textureUnit->TexGenEnabled & S_BIT) ? GL_TRUE : GL_FALSE;
	 break;
      case GL_TEXTURE_GEN_T:
	 *params = (textureUnit->TexGenEnabled & T_BIT) ? GL_TRUE : GL_FALSE;
	 break;
      case GL_TEXTURE_GEN_R:
	 *params = (textureUnit->TexGenEnabled & R_BIT) ? GL_TRUE : GL_FALSE;
	 break;
      case GL_TEXTURE_GEN_Q:
	 *params = (textureUnit->TexGenEnabled & Q_BIT) ? GL_TRUE : GL_FALSE;
	 break;
      case GL_TEXTURE_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = 
	       FLOAT_TO_BOOL(ctx->TextureMatrix[texTransformUnit].m[i]);
	 }
	 break;
      case GL_TEXTURE_STACK_DEPTH:
	 *params = INT_TO_BOOL(ctx->TextureStackDepth[texTransformUnit] + 1);
	 break;
      case GL_UNPACK_ALIGNMENT:
	 *params = INT_TO_BOOL(ctx->Unpack.Alignment);
	 break;
      case GL_UNPACK_LSB_FIRST:
	 *params = ctx->Unpack.LsbFirst;
	 break;
      case GL_UNPACK_ROW_LENGTH:
	 *params = INT_TO_BOOL(ctx->Unpack.RowLength);
	 break;
      case GL_UNPACK_SKIP_PIXELS:
	 *params = INT_TO_BOOL(ctx->Unpack.SkipPixels);
	 break;
      case GL_UNPACK_SKIP_ROWS:
	 *params = INT_TO_BOOL(ctx->Unpack.SkipRows);
	 break;
      case GL_UNPACK_SWAP_BYTES:
	 *params = ctx->Unpack.SwapBytes;
	 break;
      case GL_UNPACK_SKIP_IMAGES_EXT:
         *params = ctx->Unpack.SkipImages;
         break;
      case GL_UNPACK_IMAGE_HEIGHT_EXT:
         *params = ctx->Unpack.ImageHeight;
         break;
      case GL_VIEWPORT:
	 params[0] = INT_TO_BOOL(ctx->Viewport.X);
	 params[1] = INT_TO_BOOL(ctx->Viewport.Y);
	 params[2] = INT_TO_BOOL(ctx->Viewport.Width);
	 params[3] = INT_TO_BOOL(ctx->Viewport.Height);
	 break;
      case GL_ZOOM_X:
	 *params = FLOAT_TO_BOOL(ctx->Pixel.ZoomX);
	 break;
      case GL_ZOOM_Y:
	 *params = FLOAT_TO_BOOL(ctx->Pixel.ZoomY);
	 break;
      case GL_VERTEX_ARRAY:
#ifdef VAO
         *params = ctx->Array.Current->Vertex.Enabled;
#else
         *params = ctx->Array.Vertex.Enabled;
#endif
         break;
      case GL_VERTEX_ARRAY_SIZE:
#ifdef VAO
         *params = INT_TO_BOOL(ctx->Array.Current->Vertex.Size);
#else
         *params = INT_TO_BOOL(ctx->Array.Vertex.Size);
#endif
         break;
      case GL_VERTEX_ARRAY_TYPE:
#ifdef VAO
         *params = ENUM_TO_BOOL(ctx->Array.Current->Vertex.Type);
#else
         *params = ENUM_TO_BOOL(ctx->Array.Vertex.Type);
#endif
         break;
      case GL_VERTEX_ARRAY_STRIDE:
#ifdef VAO
         *params = INT_TO_BOOL(ctx->Array.Current->Vertex.Stride);
#else
         *params = INT_TO_BOOL(ctx->Array.Vertex.Stride);
#endif
         break;
      case GL_VERTEX_ARRAY_COUNT_EXT:
         *params = INT_TO_BOOL(0);
         break;
      case GL_NORMAL_ARRAY:
#ifdef VAO
         *params = ctx->Array.Current->Normal.Enabled;
#else
         *params = ctx->Array.Normal.Enabled;
#endif
         break;
      case GL_NORMAL_ARRAY_TYPE:
#ifdef VAO
         *params = ENUM_TO_BOOL(ctx->Array.Current->Normal.Type);
#else
         *params = ENUM_TO_BOOL(ctx->Array.Normal.Type);
#endif
         break;
      case GL_NORMAL_ARRAY_STRIDE:
#ifdef VAO
         *params = INT_TO_BOOL(ctx->Array.Current->Normal.Stride);
#else
         *params = INT_TO_BOOL(ctx->Array.Normal.Stride);
#endif
         break;
      case GL_NORMAL_ARRAY_COUNT_EXT:
         *params = INT_TO_BOOL(0);
         break;
      case GL_COLOR_ARRAY:
#ifdef VAO
         *params = ctx->Array.Current->Color.Enabled;
#else
         *params = ctx->Array.Color.Enabled;
#endif
         break;
      case GL_COLOR_ARRAY_SIZE:
#ifdef VAO
         *params = INT_TO_BOOL(ctx->Array.Current->Color.Size);
#else
         *params = INT_TO_BOOL(ctx->Array.Color.Size);
#endif
         break;
      case GL_COLOR_ARRAY_TYPE:
#ifdef VAO
         *params = ENUM_TO_BOOL(ctx->Array.Current->Color.Type);
#else
         *params = ENUM_TO_BOOL(ctx->Array.Color.Type);
#endif
         break;
      case GL_COLOR_ARRAY_STRIDE:
#ifdef VAO
         *params = INT_TO_BOOL(ctx->Array.Current->Color.Stride);
#else
         *params = INT_TO_BOOL(ctx->Array.Color.Stride);
#endif
         break;
      case GL_COLOR_ARRAY_COUNT_EXT:
         *params = INT_TO_BOOL(0);
         break;
      case GL_INDEX_ARRAY:
#ifdef VAO
         *params = ctx->Array.Current->Index.Enabled;
#else
         *params = ctx->Array.Index.Enabled;
#endif
         break;
      case GL_INDEX_ARRAY_TYPE:
#ifdef VAO
         *params = ENUM_TO_BOOL(ctx->Array.Current->Index.Type);
#else
         *params = ENUM_TO_BOOL(ctx->Array.Index.Type);
#endif
         break;
      case GL_INDEX_ARRAY_STRIDE:
#ifdef VAO
         *params = INT_TO_BOOL(ctx->Array.Current->Index.Stride);
#else
         *params = INT_TO_BOOL(ctx->Array.Index.Stride);
#endif
         break;
      case GL_INDEX_ARRAY_COUNT_EXT:
         *params = INT_TO_BOOL(0);
         break;
      case GL_TEXTURE_COORD_ARRAY:
#ifdef VAO
         *params = ctx->Array.Current->TexCoord[texUnit].Enabled;
#else
         *params = ctx->Array.TexCoord[texUnit].Enabled;
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_SIZE:
#ifdef VAO
         *params = INT_TO_BOOL(ctx->Array.Current->TexCoord[texUnit].Size);
#else
         *params = INT_TO_BOOL(ctx->Array.TexCoord[texUnit].Size);
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_TYPE:
#ifdef VAO
         *params = ENUM_TO_BOOL(ctx->Array.Current->TexCoord[texUnit].Type);
#else
         *params = ENUM_TO_BOOL(ctx->Array.TexCoord[texUnit].Type);
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_STRIDE:
#ifdef VAO
         *params = INT_TO_BOOL(ctx->Array.Current->TexCoord[texUnit].Stride);
#else
         *params = INT_TO_BOOL(ctx->Array.TexCoord[texUnit].Stride);
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_COUNT_EXT:
         *params = INT_TO_BOOL(0);
         break;
      case GL_EDGE_FLAG_ARRAY:
#ifdef VAO
         *params = ctx->Array.Current->EdgeFlag.Enabled;
#else
         *params = ctx->Array.EdgeFlag.Enabled;
#endif
         break;
      case GL_EDGE_FLAG_ARRAY_STRIDE:
#ifdef VAO
         *params = INT_TO_BOOL(ctx->Array.Current->EdgeFlag.Stride);
#else
         *params = INT_TO_BOOL(ctx->Array.EdgeFlag.Stride);
#endif
         break;

      /* GL_ARB_multitexture */
      case GL_MAX_TEXTURE_UNITS_ARB:
         *params = ctx->Const.MaxTextureUnits;
         break;
      case GL_ACTIVE_TEXTURE_ARB:
         *params = INT_TO_BOOL(GL_TEXTURE0_ARB + ctx->Texture.CurrentUnit);
         break;
      case GL_CLIENT_ACTIVE_TEXTURE_ARB:
         *params = INT_TO_BOOL(GL_TEXTURE0_ARB + ctx->Array.ActiveTexture);
         break;

      /* GL_ARB_texture_cube_map */
      case GL_TEXTURE_CUBE_MAP_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            *params = _mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB);
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
         return;
      case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            *params = INT_TO_BOOL(textureUnit->CurrentCubeMap->Name);
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
         return;
      case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            *params = INT_TO_BOOL(ctx->Const.MaxCubeTextureSize);
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
         break;

      /* GL_ARB_texture_compression */
      case GL_TEXTURE_COMPRESSION_HINT_ARB:
         if (ctx->Extensions.HaveTextureCompression) {
            *params = INT_TO_BOOL(ctx->Hint.TextureCompression);
         }
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
         break;
      case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:
         if (ctx->Extensions.HaveTextureCompression) {
            *params = INT_TO_BOOL(ctx->Const.NumCompressedTextureFormats);
         }
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
         break;
      case GL_COMPRESSED_TEXTURE_FORMATS_ARB:
         if (ctx->Extensions.HaveTextureCompression) {
            GLuint i;
            for (i = 0; i < ctx->Const.NumCompressedTextureFormats; i++)
               params[i] = INT_TO_BOOL(ctx->Const.CompressedTextureFormats[i]);
         }
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
         break;

      /* GL_PGI_misc_hints */
      case GL_STRICT_DEPTHFUNC_HINT_PGI:
	 *params = ENUM_TO_BOOL(GL_NICEST);
         break;
      case GL_STRICT_LIGHTING_HINT_PGI:
	 *params = ENUM_TO_BOOL(ctx->Hint.StrictLighting);
	 break;
      case GL_STRICT_SCISSOR_HINT_PGI:
      case GL_FULL_STIPPLE_HINT_PGI:
	 *params = ENUM_TO_BOOL(GL_TRUE);
	 break;
      case GL_CONSERVE_MEMORY_HINT_PGI:
	 *params = ENUM_TO_BOOL(GL_FALSE);
	 break;
      case GL_ALWAYS_FAST_HINT_PGI:
	 *params = (GLboolean) (ctx->Hint.AllowDrawWin == GL_TRUE &&
			      ctx->Hint.AllowDrawFrg == GL_FALSE && 
			      ctx->Hint.AllowDrawMem == GL_FALSE);
	 break;
      case GL_ALWAYS_SOFT_HINT_PGI:
	 *params = (GLboolean) (ctx->Hint.AllowDrawWin == GL_TRUE &&
			      ctx->Hint.AllowDrawFrg == GL_TRUE && 
			      ctx->Hint.AllowDrawMem == GL_TRUE);
	 break;
      case GL_ALLOW_DRAW_OBJ_HINT_PGI:
	 *params = (GLboolean) GL_TRUE;
	 break;
      case GL_ALLOW_DRAW_WIN_HINT_PGI:
	 *params = (GLboolean) ctx->Hint.AllowDrawWin;
	 break;
      case GL_ALLOW_DRAW_FRG_HINT_PGI:
	 *params = (GLboolean) ctx->Hint.AllowDrawFrg;
	 break;
      case GL_ALLOW_DRAW_MEM_HINT_PGI:
	 *params = (GLboolean) ctx->Hint.AllowDrawMem;
	 break;
      case GL_CLIP_NEAR_HINT_PGI:
      case GL_CLIP_FAR_HINT_PGI:
	 *params = ENUM_TO_BOOL(GL_TRUE);
	 break;
      case GL_WIDE_LINE_HINT_PGI:
	 *params = ENUM_TO_BOOL(GL_DONT_CARE);
	 break;
      case GL_BACK_NORMALS_HINT_PGI:
	 *params = ENUM_TO_BOOL(GL_TRUE);
	 break;
      case GL_NATIVE_GRAPHICS_HANDLE_PGI:
	 *params = 0;
	 break;

      /* GL_EXT_compiled_vertex_array */
      case GL_ARRAY_ELEMENT_LOCK_FIRST_EXT:
#ifdef VAO
	 *params = ctx->Array.Current->LockFirst ? GL_TRUE : GL_FALSE;
#else
	 *params = ctx->Array.LockFirst ? GL_TRUE : GL_FALSE;
#endif
	 break;
      case GL_ARRAY_ELEMENT_LOCK_COUNT_EXT:
#ifdef VAO
	 *params = ctx->Array.Current->LockCount ? GL_TRUE : GL_FALSE;
#else
	 *params = ctx->Array.LockCount ? GL_TRUE : GL_FALSE;
#endif
	 break;

      /* GL_ARB_transpose_matrix */
      case GL_TRANSPOSE_COLOR_MATRIX_ARB:
         {
            GLfloat tm[16];
            GLuint i;
            gl_matrix_transposef(tm, ctx->ColorMatrix.m);
            for (i=0;i<16;i++) {
               params[i] = FLOAT_TO_BOOL(tm[i]);
            }
         }
         break;
      case GL_TRANSPOSE_MODELVIEW_MATRIX_ARB:
         {
            GLfloat tm[16];
            GLuint i;
            gl_matrix_transposef(tm, ctx->ModelView.m);
            for (i=0;i<16;i++) {
               params[i] = FLOAT_TO_BOOL(tm[i]);
            }
         }
         break;
      case GL_TRANSPOSE_PROJECTION_MATRIX_ARB:
         {
            GLfloat tm[16];
            GLuint i;
            gl_matrix_transposef(tm, ctx->ProjectionMatrix.m);
            for (i=0;i<16;i++) {
               params[i] = FLOAT_TO_BOOL(tm[i]);
            }
         }
         break;
      case GL_TRANSPOSE_TEXTURE_MATRIX_ARB:
         {
            GLfloat tm[16];
            GLuint i;
            gl_matrix_transposef(tm, ctx->TextureMatrix[texTransformUnit].m);
            for (i=0;i<16;i++) {
               params[i] = FLOAT_TO_BOOL(tm[i]);
            }
         }
         break;

      /* GL_HP_occlusion_test */
      case GL_OCCLUSION_TEST_HP:
         if (ctx->Extensions.HaveHpOcclusionTest) {
            *params = ctx->Depth.OcclusionTest;
         }
         else {
            gl_error( ctx, GL_INVALID_ENUM, "glGetBooleanv" );
         }
         return;
      case GL_OCCLUSION_TEST_RESULT_HP:
         if (ctx->Extensions.HaveHpOcclusionTest) {
            if (ctx->Depth.OcclusionTest)
               *params = ctx->OcclusionResult;
            else
               *params = ctx->OcclusionResultSaved;
            /* reset flag now */
            ctx->OcclusionResult = GL_FALSE;
            ctx->OcclusionResultSaved = GL_FALSE;
         }
         else {
            gl_error( ctx, GL_INVALID_ENUM, "glGetBooleanv" );
         }
         return;

      /* GL_SGIS_pixel_texture */
      case GL_PIXEL_TEXTURE_SGIS:
         *params = ctx->Pixel.PixelTextureEnabled;
         break;

      /* GL_SGIX_pixel_texture */
      case GL_PIXEL_TEX_GEN_SGIX:
         *params = ctx->Pixel.PixelTextureEnabled;
         break;
      case GL_PIXEL_TEX_GEN_MODE_SGIX:
         *params = (GLboolean) pixel_texgen_mode(ctx);
         break;

      /* GL_SGI_color_matrix (also in 1.2 imaging) */
      case GL_COLOR_MATRIX_SGI:
         for (i=0;i<16;i++) {
	    params[i] = FLOAT_TO_BOOL(ctx->ColorMatrix.m[i]);
	 }
	 break;
      case GL_COLOR_MATRIX_STACK_DEPTH_SGI:
         *params = INT_TO_BOOL(ctx->ColorStackDepth + 1);
         break;
      case GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI:
         *params = FLOAT_TO_BOOL(MAX_COLOR_STACK_DEPTH);
         break;
      case GL_POST_COLOR_MATRIX_RED_SCALE_SGI:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostColorMatrixScale[0]);
         break;
      case GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostColorMatrixScale[1]);
         break;
      case GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostColorMatrixScale[2]);
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostColorMatrixScale[3]);
         break;
      case GL_POST_COLOR_MATRIX_RED_BIAS_SGI:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostColorMatrixBias[0]);
         break;
      case GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostColorMatrixBias[1]);
         break;
      case GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostColorMatrixBias[2]);
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostColorMatrixBias[3]);
         break;

      /* GL_EXT_convolution (also in 1.2 imaging) */
      case GL_MAX_CONVOLUTION_WIDTH:
         *params = INT_TO_BOOL(ctx->Const.MaxConvolutionWidth);
         break;
      case GL_MAX_CONVOLUTION_HEIGHT:
         *params = INT_TO_BOOL(ctx->Const.MaxConvolutionHeight);
         break;
      case GL_POST_CONVOLUTION_RED_SCALE_EXT:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostConvolutionScale[0]);
         break;
      case GL_POST_CONVOLUTION_GREEN_SCALE_EXT:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostConvolutionScale[1]);
         break;
      case GL_POST_CONVOLUTION_BLUE_SCALE_EXT:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostConvolutionScale[2]);
         break;
      case GL_POST_CONVOLUTION_ALPHA_SCALE_EXT:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostConvolutionScale[3]);
         break;
      case GL_POST_CONVOLUTION_RED_BIAS_EXT:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostConvolutionBias[0]);
         break;
      case GL_POST_CONVOLUTION_GREEN_BIAS_EXT:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostConvolutionBias[1]);
         break;
      case GL_POST_CONVOLUTION_BLUE_BIAS_EXT:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostConvolutionBias[2]);
         break;
      case GL_POST_CONVOLUTION_ALPHA_BIAS_EXT:
         *params = FLOAT_TO_BOOL(ctx->Pixel.PostConvolutionBias[2]);
         break;

      /* GL_SGI_color_table (also in 1.2 imaging */
      case GL_COLOR_TABLE_SGI:
         *params = ctx->Pixel.ColorTableEnabled;
         break;
      case GL_POST_CONVOLUTION_COLOR_TABLE_SGI:
         *params = ctx->Pixel.PostConvolutionColorTableEnabled;
         break;
      case GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI:
         *params = ctx->Pixel.PostColorMatrixColorTableEnabled;
         break;

      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetBooleanv" );
   }
}




void
_mesa_GetDoublev( GLenum pname, GLdouble *params )
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint i;
   GLuint texUnit = ctx->Texture.CurrentUnit;
   GLuint texTransformUnit = ctx->Texture.CurrentTransformUnit;
   const struct gl_texture_unit *textureUnit = &ctx->Texture.Unit[texUnit];

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetDoublev");

   if (!params)
      return;

   if (MESA_VERBOSE & VERBOSE_API) 
      fprintf(stderr, "glGetDoublev %s\n", gl_lookup_enum_by_nr(pname));

   if (ctx->Driver.GetDoublev && (*ctx->Driver.GetDoublev)(ctx, pname, params))
      return;

   switch (pname) {
      case GL_ACCUM_RED_BITS:
         *params = (GLdouble) ctx->Visual->AccumRedBits;
         break;
      case GL_ACCUM_GREEN_BITS:
         *params = (GLdouble) ctx->Visual->AccumGreenBits;
         break;
      case GL_ACCUM_BLUE_BITS:
         *params = (GLdouble) ctx->Visual->AccumBlueBits;
         break;
      case GL_ACCUM_ALPHA_BITS:
         *params = (GLdouble) ctx->Visual->AccumAlphaBits;
         break;
      case GL_ACCUM_CLEAR_VALUE:
         params[0] = (GLdouble) ctx->Accum.ClearColor[0];
         params[1] = (GLdouble) ctx->Accum.ClearColor[1];
         params[2] = (GLdouble) ctx->Accum.ClearColor[2];
         params[3] = (GLdouble) ctx->Accum.ClearColor[3];
         break;
      case GL_ALPHA_BIAS:
         *params = (GLdouble) ctx->Pixel.AlphaBias;
         break;
      case GL_ALPHA_BITS:
         *params = (GLdouble) ctx->Visual->AlphaBits;
         break;
      case GL_ALPHA_SCALE:
         *params = (GLdouble) ctx->Pixel.AlphaScale;
         break;
      case GL_ALPHA_TEST:
         *params = (GLdouble) ctx->Color.AlphaEnabled;
         break;
      case GL_ALPHA_TEST_FUNC:
         *params = ENUM_TO_DOUBLE(ctx->Color.AlphaFunc);
         break;
      case GL_ALPHA_TEST_REF:
         *params = (GLdouble) ctx->Color.AlphaRef / 255.0;
         break;
      case GL_ATTRIB_STACK_DEPTH:
         *params = (GLdouble ) (ctx->AttribStackDepth);
         break;
      case GL_AUTO_NORMAL:
         *params = (GLdouble) ctx->Eval.AutoNormal;
         break;
      case GL_AUX_BUFFERS:
         *params = (GLdouble) ctx->Const.NumAuxBuffers;
         break;
      case GL_BLEND:
         *params = (GLdouble) ctx->Color.BlendEnabled;
         break;
      case GL_BLEND_DST:
         *params = ENUM_TO_DOUBLE(ctx->Color.BlendDstRGB);
         break;
      case GL_BLEND_SRC:
         *params = ENUM_TO_DOUBLE(ctx->Color.BlendSrcRGB);
         break;
      case GL_BLEND_SRC_RGB_EXT:
         *params = ENUM_TO_DOUBLE(ctx->Color.BlendSrcRGB);
         break;
      case GL_BLEND_DST_RGB_EXT:
         *params = ENUM_TO_DOUBLE(ctx->Color.BlendDstRGB);
         break;
      case GL_BLEND_SRC_ALPHA_EXT:
         *params = ENUM_TO_DOUBLE(ctx->Color.BlendSrcA);
         break;
      case GL_BLEND_DST_ALPHA_EXT:
         *params = ENUM_TO_DOUBLE(ctx->Color.BlendDstA);
         break;
      case GL_BLEND_EQUATION_EXT:
	 *params = ENUM_TO_DOUBLE(ctx->Color.BlendEquation);
	 break;
      case GL_BLEND_COLOR_EXT:
	 params[0] = (GLdouble) ctx->Color.BlendColor[0];
	 params[1] = (GLdouble) ctx->Color.BlendColor[1];
	 params[2] = (GLdouble) ctx->Color.BlendColor[2];
	 params[3] = (GLdouble) ctx->Color.BlendColor[3];
	 break;
      case GL_BLUE_BIAS:
         *params = (GLdouble) ctx->Pixel.BlueBias;
         break;
      case GL_BLUE_BITS:
         *params = (GLdouble) ctx->Visual->BlueBits;
         break;
      case GL_BLUE_SCALE:
         *params = (GLdouble) ctx->Pixel.BlueScale;
         break;
      case GL_CLIENT_ATTRIB_STACK_DEPTH:
         *params = (GLdouble) (ctx->ClientAttribStackDepth);
         break;
      case GL_CLIP_PLANE0:
      case GL_CLIP_PLANE1:
      case GL_CLIP_PLANE2:
      case GL_CLIP_PLANE3:
      case GL_CLIP_PLANE4:
      case GL_CLIP_PLANE5:
         *params = (GLdouble) ctx->Transform.ClipEnabled[pname-GL_CLIP_PLANE0];
         break;
      case GL_COLOR_CLEAR_VALUE:
         params[0] = (GLdouble) ctx->Color.ClearColor[0];
         params[1] = (GLdouble) ctx->Color.ClearColor[1];
         params[2] = (GLdouble) ctx->Color.ClearColor[2];
         params[3] = (GLdouble) ctx->Color.ClearColor[3];
         break;
      case GL_COLOR_MATERIAL:
         *params = (GLdouble) ctx->Light.ColorMaterialEnabled;
         break;
      case GL_COLOR_MATERIAL_FACE:
         *params = ENUM_TO_DOUBLE(ctx->Light.ColorMaterialFace);
         break;
      case GL_COLOR_MATERIAL_PARAMETER:
         *params = ENUM_TO_DOUBLE(ctx->Light.ColorMaterialMode);
         break;
      case GL_COLOR_WRITEMASK:
         params[0] = ctx->Color.ColorMask[RCOMP] ? 1.0 : 0.0;
         params[1] = ctx->Color.ColorMask[GCOMP] ? 1.0 : 0.0;
         params[2] = ctx->Color.ColorMask[BCOMP] ? 1.0 : 0.0;
         params[3] = ctx->Color.ColorMask[ACOMP] ? 1.0 : 0.0;
         break;
      case GL_CULL_FACE:
         *params = (GLdouble) ctx->Polygon.CullFlag;
         break;
      case GL_CULL_FACE_MODE:
         *params = ENUM_TO_DOUBLE(ctx->Polygon.CullFaceMode);
         break;
      case GL_CURRENT_COLOR:
         params[0] = UBYTE_COLOR_TO_FLOAT_COLOR(ctx->Current.ByteColor[0]);
         params[1] = UBYTE_COLOR_TO_FLOAT_COLOR(ctx->Current.ByteColor[1]);
         params[2] = UBYTE_COLOR_TO_FLOAT_COLOR(ctx->Current.ByteColor[2]);
         params[3] = UBYTE_COLOR_TO_FLOAT_COLOR(ctx->Current.ByteColor[3]);
         break;
      case GL_CURRENT_INDEX:
         *params = (GLdouble) ctx->Current.Index;
         break;
      case GL_CURRENT_NORMAL:
         params[0] = (GLdouble) ctx->Current.Normal[0];
         params[1] = (GLdouble) ctx->Current.Normal[1];
         params[2] = (GLdouble) ctx->Current.Normal[2];
         break;
      case GL_CURRENT_RASTER_COLOR:
	 params[0] = (GLdouble) ctx->Current.RasterColor[0];
	 params[1] = (GLdouble) ctx->Current.RasterColor[1];
	 params[2] = (GLdouble) ctx->Current.RasterColor[2];
	 params[3] = (GLdouble) ctx->Current.RasterColor[3];
	 break;
      case GL_CURRENT_RASTER_DISTANCE:
	 params[0] = (GLdouble) ctx->Current.RasterDistance;
	 break;
      case GL_CURRENT_RASTER_INDEX:
	 *params = (GLdouble) ctx->Current.RasterIndex;
	 break;
      case GL_CURRENT_RASTER_POSITION:
	 params[0] = (GLdouble) ctx->Current.RasterPos[0];
	 params[1] = (GLdouble) ctx->Current.RasterPos[1];
	 params[2] = (GLdouble) ctx->Current.RasterPos[2];
	 params[3] = (GLdouble) ctx->Current.RasterPos[3];
	 break;
      case GL_CURRENT_RASTER_TEXTURE_COORDS:
	 params[0] = (GLdouble) ctx->Current.RasterMultiTexCoord[texTransformUnit][0];
	 params[1] = (GLdouble) ctx->Current.RasterMultiTexCoord[texTransformUnit][1];
	 params[2] = (GLdouble) ctx->Current.RasterMultiTexCoord[texTransformUnit][2];
	 params[3] = (GLdouble) ctx->Current.RasterMultiTexCoord[texTransformUnit][3];
	 break;
      case GL_CURRENT_RASTER_POSITION_VALID:
	 *params = (GLdouble) ctx->Current.RasterPosValid;
	 break;
      case GL_CURRENT_TEXTURE_COORDS:
	 params[0] = (GLdouble) ctx->Current.Texcoord[texTransformUnit][0];
	 params[1] = (GLdouble) ctx->Current.Texcoord[texTransformUnit][1];
	 params[2] = (GLdouble) ctx->Current.Texcoord[texTransformUnit][2];
	 params[3] = (GLdouble) ctx->Current.Texcoord[texTransformUnit][3];
	 break;
      case GL_DEPTH_BIAS:
	 *params = (GLdouble) ctx->Pixel.DepthBias;
	 break;
      case GL_DEPTH_BITS:
	 *params = (GLdouble) ctx->Visual->DepthBits;
	 break;
      case GL_DEPTH_CLEAR_VALUE:
	 *params = (GLdouble) ctx->Depth.Clear;
	 break;
      case GL_DEPTH_FUNC:
	 *params = ENUM_TO_DOUBLE(ctx->Depth.Func);
	 break;
      case GL_DEPTH_RANGE:
         params[0] = (GLdouble) ctx->Viewport.Near;
         params[1] = (GLdouble) ctx->Viewport.Far;
	 break;
      case GL_DEPTH_SCALE:
	 *params = (GLdouble) ctx->Pixel.DepthScale;
	 break;
      case GL_DEPTH_TEST:
	 *params = (GLdouble) ctx->Depth.Test;
	 break;
      case GL_DEPTH_WRITEMASK:
	 *params = (GLdouble) ctx->Depth.Mask;
	 break;
      case GL_DITHER:
	 *params = (GLdouble) ctx->Color.DitherFlag;
	 break;
      case GL_DOUBLEBUFFER:
	 *params = (GLdouble) ctx->Visual->DBflag;
	 break;
      case GL_DRAW_BUFFER:
	 *params = ENUM_TO_DOUBLE(ctx->Color.DrawBuffer);
	 break;
      case GL_EDGE_FLAG:
	 *params = (GLdouble) ctx->Current.EdgeFlag;
	 break;
      case GL_FEEDBACK_BUFFER_SIZE:
         *params = (GLdouble) ctx->Feedback.BufferSize;
         break;
      case GL_FEEDBACK_BUFFER_TYPE:
         *params = ENUM_TO_DOUBLE(ctx->Feedback.Type);
         break;
      case GL_FOG:
	 *params = (GLdouble) ctx->Fog.Enabled;
	 break;
      case GL_FOG_COLOR:
	 params[0] = (GLdouble) ctx->Fog.Color[0];
	 params[1] = (GLdouble) ctx->Fog.Color[1];
	 params[2] = (GLdouble) ctx->Fog.Color[2];
	 params[3] = (GLdouble) ctx->Fog.Color[3];
	 break;
      case GL_FOG_DENSITY:
	 *params = (GLdouble) ctx->Fog.Density;
	 break;
      case GL_FOG_END:
	 *params = (GLdouble) ctx->Fog.End;
	 break;
      case GL_FOG_HINT:
	 *params = ENUM_TO_DOUBLE(ctx->Hint.Fog);
	 break;
      case GL_FOG_INDEX:
	 *params = (GLdouble) ctx->Fog.Index;
	 break;
      case GL_FOG_MODE:
	 *params = ENUM_TO_DOUBLE(ctx->Fog.Mode);
	 break;
      case GL_FOG_START:
	 *params = (GLdouble) ctx->Fog.Start;
	 break;
      case GL_FRONT_FACE:
	 *params = ENUM_TO_DOUBLE(ctx->Polygon.FrontFace);
	 break;
      case GL_GREEN_BIAS:
         *params = (GLdouble) ctx->Pixel.GreenBias;
         break;
      case GL_GREEN_BITS:
         *params = (GLdouble) ctx->Visual->GreenBits;
         break;
      case GL_GREEN_SCALE:
         *params = (GLdouble) ctx->Pixel.GreenScale;
         break;
      case GL_HISTOGRAM:
         *params = (GLdouble) ctx->Pixel.HistogramEnabled;
	 break;
      case GL_INDEX_BITS:
         *params = (GLdouble) ctx->Visual->IndexBits;
	 break;
      case GL_INDEX_CLEAR_VALUE:
         *params = (GLdouble) ctx->Color.ClearIndex;
	 break;
      case GL_INDEX_MODE:
	 *params = ctx->Visual->RGBAflag ? 0.0 : 1.0;
	 break;
      case GL_INDEX_OFFSET:
	 *params = (GLdouble) ctx->Pixel.IndexOffset;
	 break;
      case GL_INDEX_SHIFT:
	 *params = (GLdouble) ctx->Pixel.IndexShift;
	 break;
      case GL_INDEX_WRITEMASK:
	 *params = (GLdouble) ctx->Color.IndexMask;
	 break;
      case GL_LIGHT0:
      case GL_LIGHT1:
      case GL_LIGHT2:
      case GL_LIGHT3:
      case GL_LIGHT4:
      case GL_LIGHT5:
      case GL_LIGHT6:
      case GL_LIGHT7:
	 *params = (GLdouble) ctx->Light.Light[pname-GL_LIGHT0].Enabled;
	 break;
      case GL_LIGHTING:
	 *params = (GLdouble) ctx->Light.Enabled;
	 break;
      case GL_LIGHT_MODEL_AMBIENT:
	 params[0] = (GLdouble) ctx->Light.Model.Ambient[0];
	 params[1] = (GLdouble) ctx->Light.Model.Ambient[1];
	 params[2] = (GLdouble) ctx->Light.Model.Ambient[2];
	 params[3] = (GLdouble) ctx->Light.Model.Ambient[3];
	 break;
      case GL_LIGHT_MODEL_COLOR_CONTROL:
         params[0] = (GLdouble) ctx->Light.Model.ColorControl;
         break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
	 *params = (GLdouble) ctx->Light.Model.LocalViewer;
	 break;
      case GL_LIGHT_MODEL_TWO_SIDE:
	 *params = (GLdouble) ctx->Light.Model.TwoSide;
	 break;
      case GL_LINE_SMOOTH:
	 *params = (GLdouble) ctx->Line.SmoothFlag;
	 break;
      case GL_LINE_SMOOTH_HINT:
	 *params = ENUM_TO_DOUBLE(ctx->Hint.LineSmooth);
	 break;
      case GL_LINE_STIPPLE:
	 *params = (GLdouble) ctx->Line.StippleFlag;
	 break;
      case GL_LINE_STIPPLE_PATTERN:
         *params = (GLdouble) ctx->Line.StipplePattern;
         break;
      case GL_LINE_STIPPLE_REPEAT:
         *params = (GLdouble) ctx->Line.StippleFactor;
         break;
      case GL_LINE_WIDTH:
	 *params = (GLdouble) ctx->Line.Width;
	 break;
      case GL_LINE_WIDTH_GRANULARITY:
	 *params = (GLdouble) ctx->Const.LineWidthGranularity;
	 break;
      case GL_LINE_WIDTH_RANGE:
	 params[0] = (GLdouble) ctx->Const.MinLineWidthAA;
	 params[1] = (GLdouble) ctx->Const.MaxLineWidthAA;
	 break;
      case GL_ALIASED_LINE_WIDTH_RANGE:
	 params[0] = (GLdouble) ctx->Const.MinLineWidth;
	 params[1] = (GLdouble) ctx->Const.MaxLineWidth;
	 break;
      case GL_LIST_BASE:
	 *params = (GLdouble) ctx->List.ListBase;
	 break;
      case GL_LIST_INDEX:
	 *params = (GLdouble) ctx->CurrentListNum;
	 break;
      case GL_LIST_MODE:
	 *params = ctx->ExecuteFlag ? ENUM_TO_DOUBLE(GL_COMPILE_AND_EXECUTE)
	   			  : ENUM_TO_DOUBLE(GL_COMPILE);
	 break;
      case GL_INDEX_LOGIC_OP:
	 *params = (GLdouble) ctx->Color.IndexLogicOpEnabled;
	 break;
      case GL_COLOR_LOGIC_OP:
	 *params = (GLdouble) ctx->Color.ColorLogicOpEnabled;
	 break;
      case GL_LOGIC_OP_MODE:
         *params = ENUM_TO_DOUBLE(ctx->Color.LogicOp);
	 break;
      case GL_MAP1_COLOR_4:
	 *params = (GLdouble) ctx->Eval.Map1Color4;
	 break;
      case GL_MAP1_GRID_DOMAIN:
	 params[0] = (GLdouble) ctx->Eval.MapGrid1u1;
	 params[1] = (GLdouble) ctx->Eval.MapGrid1u2;
	 break;
      case GL_MAP1_GRID_SEGMENTS:
	 *params = (GLdouble) ctx->Eval.MapGrid1un;
	 break;
      case GL_MAP1_INDEX:
	 *params = (GLdouble) ctx->Eval.Map1Index;
	 break;
      case GL_MAP1_NORMAL:
	 *params = (GLdouble) ctx->Eval.Map1Normal;
	 break;
      case GL_MAP1_TEXTURE_COORD_1:
	 *params = (GLdouble) ctx->Eval.Map1TextureCoord1;
	 break;
      case GL_MAP1_TEXTURE_COORD_2:
	 *params = (GLdouble) ctx->Eval.Map1TextureCoord2;
	 break;
      case GL_MAP1_TEXTURE_COORD_3:
	 *params = (GLdouble) ctx->Eval.Map1TextureCoord3;
	 break;
      case GL_MAP1_TEXTURE_COORD_4:
	 *params = (GLdouble) ctx->Eval.Map1TextureCoord4;
	 break;
      case GL_MAP1_VERTEX_3:
	 *params = (GLdouble) ctx->Eval.Map1Vertex3;
	 break;
      case GL_MAP1_VERTEX_4:
	 *params = (GLdouble) ctx->Eval.Map1Vertex4;
	 break;
      case GL_MAP2_COLOR_4:
	 *params = (GLdouble) ctx->Eval.Map2Color4;
	 break;
      case GL_MAP2_GRID_DOMAIN:
	 params[0] = (GLdouble) ctx->Eval.MapGrid2u1;
	 params[1] = (GLdouble) ctx->Eval.MapGrid2u2;
	 params[2] = (GLdouble) ctx->Eval.MapGrid2v1;
	 params[3] = (GLdouble) ctx->Eval.MapGrid2v2;
	 break;
      case GL_MAP2_GRID_SEGMENTS:
	 params[0] = (GLdouble) ctx->Eval.MapGrid2un;
	 params[1] = (GLdouble) ctx->Eval.MapGrid2vn;
	 break;
      case GL_MAP2_INDEX:
	 *params = (GLdouble) ctx->Eval.Map2Index;
	 break;
      case GL_MAP2_NORMAL:
	 *params = (GLdouble) ctx->Eval.Map2Normal;
	 break;
      case GL_MAP2_TEXTURE_COORD_1:
	 *params = (GLdouble) ctx->Eval.Map2TextureCoord1;
	 break;
      case GL_MAP2_TEXTURE_COORD_2:
	 *params = (GLdouble) ctx->Eval.Map2TextureCoord2;
	 break;
      case GL_MAP2_TEXTURE_COORD_3:
	 *params = (GLdouble) ctx->Eval.Map2TextureCoord3;
	 break;
      case GL_MAP2_TEXTURE_COORD_4:
	 *params = (GLdouble) ctx->Eval.Map2TextureCoord4;
	 break;
      case GL_MAP2_VERTEX_3:
	 *params = (GLdouble) ctx->Eval.Map2Vertex3;
	 break;
      case GL_MAP2_VERTEX_4:
	 *params = (GLdouble) ctx->Eval.Map2Vertex4;
	 break;
      case GL_MAP_COLOR:
	 *params = (GLdouble) ctx->Pixel.MapColorFlag;
	 break;
      case GL_MAP_STENCIL:
	 *params = (GLdouble) ctx->Pixel.MapStencilFlag;
	 break;
      case GL_MATRIX_MODE:
	 *params = ENUM_TO_DOUBLE(ctx->Transform.MatrixMode);
	 break;
      case GL_MAX_ATTRIB_STACK_DEPTH:
	 *params = (GLdouble) MAX_ATTRIB_STACK_DEPTH;
	 break;
      case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
         *params = (GLdouble) MAX_CLIENT_ATTRIB_STACK_DEPTH;
         break;
      case GL_MAX_CLIP_PLANES:
	 *params = (GLdouble) MAX_CLIP_PLANES;
	 break;
      case GL_MAX_ELEMENTS_VERTICES:  /* GL_VERSION_1_2 */
         *params = (GLdouble) VB_MAX;
         break;
      case GL_MAX_ELEMENTS_INDICES:   /* GL_VERSION_1_2 */
         *params = (GLdouble) VB_MAX;
         break;
      case GL_MAX_EVAL_ORDER:
	 *params = (GLdouble) MAX_EVAL_ORDER;
	 break;
      case GL_MAX_LIGHTS:
	 *params = (GLdouble) MAX_LIGHTS;
	 break;
      case GL_MAX_LIST_NESTING:
	 *params = (GLdouble) MAX_LIST_NESTING;
	 break;
      case GL_MAX_MODELVIEW_STACK_DEPTH:
	 *params = (GLdouble) MAX_MODELVIEW_STACK_DEPTH;
	 break;
      case GL_MAX_NAME_STACK_DEPTH:
	 *params = (GLdouble) MAX_NAME_STACK_DEPTH;
	 break;
      case GL_MAX_PIXEL_MAP_TABLE:
	 *params = (GLdouble) MAX_PIXEL_MAP_TABLE;
	 break;
      case GL_MAX_PROJECTION_STACK_DEPTH:
	 *params = (GLdouble) MAX_PROJECTION_STACK_DEPTH;
	 break;
      case GL_MAX_TEXTURE_SIZE:
      case GL_MAX_3D_TEXTURE_SIZE:
         *params = (GLdouble) ctx->Const.MaxTextureSize;
	 break;
      case GL_MAX_TEXTURE_STACK_DEPTH:
	 *params = (GLdouble) MAX_TEXTURE_STACK_DEPTH;
	 break;
      case GL_MAX_VIEWPORT_DIMS:
         params[0] = (GLdouble) MAX_WIDTH;
         params[1] = (GLdouble) MAX_HEIGHT;
         break;
      case GL_MINMAX:
         *params = (GLdouble) ctx->Pixel.MinMaxEnabled;
         break;
      case GL_MODELVIEW_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = (GLdouble) ctx->ModelView.m[i];
	 }
	 break;
      case GL_MODELVIEW_STACK_DEPTH:
	 *params = (GLdouble) (ctx->ModelViewStackDepth + 1);
	 break;
      case GL_NAME_STACK_DEPTH:
	 *params = (GLdouble) ctx->Select.NameStackDepth;
	 break;
      case GL_NORMALIZE:
	 *params = (GLdouble) ctx->Transform.Normalize;
	 break;
      case GL_PACK_ALIGNMENT:
	 *params = (GLdouble) ctx->Pack.Alignment;
	 break;
      case GL_PACK_LSB_FIRST:
	 *params = (GLdouble) ctx->Pack.LsbFirst;
	 break;
      case GL_PACK_ROW_LENGTH:
	 *params = (GLdouble) ctx->Pack.RowLength;
	 break;
      case GL_PACK_SKIP_PIXELS:
	 *params = (GLdouble) ctx->Pack.SkipPixels;
	 break;
      case GL_PACK_SKIP_ROWS:
	 *params = (GLdouble) ctx->Pack.SkipRows;
	 break;
      case GL_PACK_SWAP_BYTES:
	 *params = (GLdouble) ctx->Pack.SwapBytes;
	 break;
      case GL_PACK_SKIP_IMAGES_EXT:
         *params = (GLdouble) ctx->Pack.SkipImages;
         break;
      case GL_PACK_IMAGE_HEIGHT_EXT:
         *params = (GLdouble) ctx->Pack.ImageHeight;
         break;
      case GL_PERSPECTIVE_CORRECTION_HINT:
	 *params = ENUM_TO_DOUBLE(ctx->Hint.PerspectiveCorrection);
	 break;
      case GL_PIXEL_MAP_A_TO_A_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapAtoAsize;
	 break;
      case GL_PIXEL_MAP_B_TO_B_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapBtoBsize;
	 break;
      case GL_PIXEL_MAP_G_TO_G_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapGtoGsize;
	 break;
      case GL_PIXEL_MAP_I_TO_A_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapItoAsize;
	 break;
      case GL_PIXEL_MAP_I_TO_B_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapItoBsize;
	 break;
      case GL_PIXEL_MAP_I_TO_G_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapItoGsize;
	 break;
      case GL_PIXEL_MAP_I_TO_I_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapItoIsize;
	 break;
      case GL_PIXEL_MAP_I_TO_R_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapItoRsize;
	 break;
      case GL_PIXEL_MAP_R_TO_R_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapRtoRsize;
	 break;
      case GL_PIXEL_MAP_S_TO_S_SIZE:
	 *params = (GLdouble) ctx->Pixel.MapStoSsize;
	 break;
      case GL_POINT_SIZE:
         *params = (GLdouble) ctx->Point.UserSize;
         break;
      case GL_POINT_SIZE_GRANULARITY:
	 *params = (GLdouble) ctx->Const.PointSizeGranularity;
	 break;
      case GL_POINT_SIZE_RANGE:
	 params[0] = (GLdouble) ctx->Const.MinPointSizeAA;
	 params[1] = (GLdouble) ctx->Const.MaxPointSizeAA;
	 break;
      case GL_ALIASED_POINT_SIZE_RANGE:
	 params[0] = (GLdouble) ctx->Const.MinPointSize;
	 params[1] = (GLdouble) ctx->Const.MaxPointSize;
	 break;
      case GL_POINT_SMOOTH:
	 *params = (GLdouble) ctx->Point.SmoothFlag;
	 break;
      case GL_POINT_SMOOTH_HINT:
	 *params = ENUM_TO_DOUBLE(ctx->Hint.PointSmooth);
	 break;
      case GL_POINT_SIZE_MIN_EXT:
	 *params = (GLdouble) (ctx->Point.MinSize);
	 break;
      case GL_POINT_SIZE_MAX_EXT:
	 *params = (GLdouble) (ctx->Point.MaxSize);
	 break;
      case GL_POINT_FADE_THRESHOLD_SIZE_EXT:
	 *params = (GLdouble) (ctx->Point.Threshold);
	 break;
      case GL_DISTANCE_ATTENUATION_EXT:
	 params[0] = (GLdouble) (ctx->Point.Params[0]);
	 params[1] = (GLdouble) (ctx->Point.Params[1]);
	 params[2] = (GLdouble) (ctx->Point.Params[2]);
	 break;
      case GL_POLYGON_MODE:
	 params[0] = ENUM_TO_DOUBLE(ctx->Polygon.FrontMode);
	 params[1] = ENUM_TO_DOUBLE(ctx->Polygon.BackMode);
	 break;
      case GL_POLYGON_OFFSET_BIAS_EXT:  /* GL_EXT_polygon_offset */
         *params = (GLdouble) ctx->Polygon.OffsetUnits;
         break;
      case GL_POLYGON_OFFSET_FACTOR:
         *params = (GLdouble) ctx->Polygon.OffsetFactor;
         break;
      case GL_POLYGON_OFFSET_UNITS:
         *params = (GLdouble) ctx->Polygon.OffsetUnits;
         break;
      case GL_POLYGON_SMOOTH:
	 *params = (GLdouble) ctx->Polygon.SmoothFlag;
	 break;
      case GL_POLYGON_SMOOTH_HINT:
	 *params = ENUM_TO_DOUBLE(ctx->Hint.PolygonSmooth);
	 break;
      case GL_POLYGON_STIPPLE:
         *params = (GLdouble) ctx->Polygon.StippleFlag;
	 break;
      case GL_PROJECTION_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = (GLdouble) ctx->ProjectionMatrix.m[i];
	 }
	 break;
      case GL_PROJECTION_STACK_DEPTH:
	 *params = (GLdouble) (ctx->ProjectionStackDepth + 1);
	 break;
      case GL_READ_BUFFER:
	 *params = ENUM_TO_DOUBLE(ctx->Pixel.ReadBuffer);
	 break;
      case GL_RED_BIAS:
         *params = (GLdouble) ctx->Pixel.RedBias;
         break;
      case GL_RED_BITS:
         *params = (GLdouble) ctx->Visual->RedBits;
         break;
      case GL_RED_SCALE:
         *params = (GLdouble) ctx->Pixel.RedScale;
         break;
      case GL_RENDER_MODE:
	 *params = ENUM_TO_DOUBLE(ctx->RenderMode);
	 break;
      case GL_RESCALE_NORMAL:
         *params = (GLdouble) ctx->Transform.RescaleNormals;
         break;
      case GL_RGBA_MODE:
	 *params = (GLdouble) ctx->Visual->RGBAflag;
	 break;
      case GL_SCISSOR_BOX:
	 params[0] = (GLdouble) ctx->Scissor.X;
	 params[1] = (GLdouble) ctx->Scissor.Y;
	 params[2] = (GLdouble) ctx->Scissor.Width;
	 params[3] = (GLdouble) ctx->Scissor.Height;
	 break;
      case GL_SCISSOR_TEST:
	 *params = (GLdouble) ctx->Scissor.Enabled;
	 break;
      case GL_SELECTION_BUFFER_SIZE:
         *params = (GLdouble) ctx->Select.BufferSize;
         break;
      case GL_SHADE_MODEL:
	 *params = ENUM_TO_DOUBLE(ctx->Light.ShadeModel);
	 break;
      case GL_SHARED_TEXTURE_PALETTE_EXT:
         *params = (GLdouble) ctx->Texture.SharedPalette;
         break;
      case GL_STENCIL_BITS:
         *params = (GLdouble) ctx->Visual->StencilBits;
         break;
      case GL_STENCIL_CLEAR_VALUE:
	 *params = (GLdouble) ctx->Stencil.Clear;
	 break;
      case GL_STENCIL_FAIL:
	 *params = ENUM_TO_DOUBLE(ctx->Stencil.FailFunc);
	 break;
      case GL_STENCIL_FUNC:
	 *params = ENUM_TO_DOUBLE(ctx->Stencil.Function);
	 break;
      case GL_STENCIL_PASS_DEPTH_FAIL:
	 *params = ENUM_TO_DOUBLE(ctx->Stencil.ZFailFunc);
	 break;
      case GL_STENCIL_PASS_DEPTH_PASS:
	 *params = ENUM_TO_DOUBLE(ctx->Stencil.ZPassFunc);
	 break;
      case GL_STENCIL_REF:
	 *params = (GLdouble) ctx->Stencil.Ref;
	 break;
      case GL_STENCIL_TEST:
	 *params = (GLdouble) ctx->Stencil.Enabled;
	 break;
      case GL_STENCIL_VALUE_MASK:
	 *params = (GLdouble) ctx->Stencil.ValueMask;
	 break;
      case GL_STENCIL_WRITEMASK:
	 *params = (GLdouble) ctx->Stencil.WriteMask;
	 break;
      case GL_STEREO:
	 *params = (GLdouble) ctx->Visual->StereoFlag;
	 break;
      case GL_SUBPIXEL_BITS:
	 *params = (GLdouble) ctx->Const.SubPixelBits;
	 break;
      case GL_TEXTURE_1D:
         *params = _mesa_IsEnabled(GL_TEXTURE_1D) ? 1.0 : 0.0;
	 break;
      case GL_TEXTURE_2D:
         *params = _mesa_IsEnabled(GL_TEXTURE_2D) ? 1.0 : 0.0;
	 break;
      case GL_TEXTURE_3D:
         *params = _mesa_IsEnabled(GL_TEXTURE_3D) ? 1.0 : 0.0;
	 break;
      case GL_TEXTURE_BINDING_1D:
         *params = (GLdouble) textureUnit->CurrentD[1]->Name;
          break;
      case GL_TEXTURE_BINDING_2D:
         *params = (GLdouble) textureUnit->CurrentD[2]->Name;
          break;
      case GL_TEXTURE_BINDING_3D:
         *params = (GLdouble) textureUnit->CurrentD[3]->Name;
          break;
      case GL_TEXTURE_ENV_COLOR:
	 params[0] = (GLdouble) textureUnit->EnvColor[0];
	 params[1] = (GLdouble) textureUnit->EnvColor[1];
	 params[2] = (GLdouble) textureUnit->EnvColor[2];
	 params[3] = (GLdouble) textureUnit->EnvColor[3];
	 break;
      case GL_TEXTURE_ENV_MODE:
	 *params = ENUM_TO_DOUBLE(textureUnit->EnvMode);
	 break;
      case GL_TEXTURE_GEN_S:
	 *params = (textureUnit->TexGenEnabled & S_BIT) ? 1.0 : 0.0;
	 break;
      case GL_TEXTURE_GEN_T:
	 *params = (textureUnit->TexGenEnabled & T_BIT) ? 1.0 : 0.0;
	 break;
      case GL_TEXTURE_GEN_R:
	 *params = (textureUnit->TexGenEnabled & R_BIT) ? 1.0 : 0.0;
	 break;
      case GL_TEXTURE_GEN_Q:
	 *params = (textureUnit->TexGenEnabled & Q_BIT) ? 1.0 : 0.0;
	 break;
      case GL_TEXTURE_MATRIX:
         for (i=0;i<16;i++) {
	    params[i] = (GLdouble) ctx->TextureMatrix[texTransformUnit].m[i];
	 }
	 break;
      case GL_TEXTURE_STACK_DEPTH:
	 *params = (GLdouble) (ctx->TextureStackDepth[texTransformUnit] + 1);
	 break;
      case GL_UNPACK_ALIGNMENT:
	 *params = (GLdouble) ctx->Unpack.Alignment;
	 break;
      case GL_UNPACK_LSB_FIRST:
	 *params = (GLdouble) ctx->Unpack.LsbFirst;
	 break;
      case GL_UNPACK_ROW_LENGTH:
	 *params = (GLdouble) ctx->Unpack.RowLength;
	 break;
      case GL_UNPACK_SKIP_PIXELS:
	 *params = (GLdouble) ctx->Unpack.SkipPixels;
	 break;
      case GL_UNPACK_SKIP_ROWS:
	 *params = (GLdouble) ctx->Unpack.SkipRows;
	 break;
      case GL_UNPACK_SWAP_BYTES:
	 *params = (GLdouble) ctx->Unpack.SwapBytes;
	 break;
      case GL_UNPACK_SKIP_IMAGES_EXT:
         *params = (GLdouble) ctx->Unpack.SkipImages;
         break;
      case GL_UNPACK_IMAGE_HEIGHT_EXT:
         *params = (GLdouble) ctx->Unpack.ImageHeight;
         break;
      case GL_VIEWPORT:
	 params[0] = (GLdouble) ctx->Viewport.X;
	 params[1] = (GLdouble) ctx->Viewport.Y;
	 params[2] = (GLdouble) ctx->Viewport.Width;
	 params[3] = (GLdouble) ctx->Viewport.Height;
	 break;
      case GL_ZOOM_X:
	 *params = (GLdouble) ctx->Pixel.ZoomX;
	 break;
      case GL_ZOOM_Y:
	 *params = (GLdouble) ctx->Pixel.ZoomY;
	 break;
      case GL_VERTEX_ARRAY:
#ifdef VAO
         *params = (GLdouble) ctx->Array.Current->Vertex.Enabled;
#else
         *params = (GLdouble) ctx->Array.Vertex.Enabled;
#endif
         break;
      case GL_VERTEX_ARRAY_SIZE:
#ifdef VAO
         *params = (GLdouble) ctx->Array.Current->Vertex.Size;
#else
         *params = (GLdouble) ctx->Array.Vertex.Size;
#endif
         break;
      case GL_VERTEX_ARRAY_TYPE:
#ifdef VAO
         *params = ENUM_TO_DOUBLE(ctx->Array.Current->Vertex.Type);
#else
         *params = ENUM_TO_DOUBLE(ctx->Array.Vertex.Type);
#endif
         break;
      case GL_VERTEX_ARRAY_STRIDE:
#ifdef VAO
         *params = (GLdouble) ctx->Array.Current->Vertex.Stride;
#else
         *params = (GLdouble) ctx->Array.Vertex.Stride;
#endif
         break;
      case GL_VERTEX_ARRAY_COUNT_EXT:
         *params = 0.0;
         break;
      case GL_NORMAL_ARRAY:
#ifdef VAO
         *params = (GLdouble) ctx->Array.Current->Normal.Enabled;
#else
         *params = (GLdouble) ctx->Array.Normal.Enabled;
#endif
         break;
      case GL_NORMAL_ARRAY_TYPE:
#ifdef VAO
         *params = ENUM_TO_DOUBLE(ctx->Array.Current->Normal.Type);
#else
         *params = ENUM_TO_DOUBLE(ctx->Array.Normal.Type);
#endif
         break;
      case GL_NORMAL_ARRAY_STRIDE:
#ifdef VAO
         *params = (GLdouble) ctx->Array.Current->Normal.Stride;
#else
         *params = (GLdouble) ctx->Array.Normal.Stride;
#endif
         break;
      case GL_NORMAL_ARRAY_COUNT_EXT:
         *params = 0.0;
         break;
      case GL_COLOR_ARRAY:
#ifdef VAO
         *params = (GLdouble) ctx->Array.Current->Color.Enabled;
#else
         *params = (GLdouble) ctx->Array.Color.Enabled;
#endif
         break;
      case GL_COLOR_ARRAY_SIZE:
#ifdef VAO
         *params = (GLdouble) ctx->Array.Current->Color.Size;
#else
         *params = (GLdouble) ctx->Array.Color.Size;
#endif
         break;
      case GL_COLOR_ARRAY_TYPE:
#ifdef VAO
         *params = ENUM_TO_DOUBLE(ctx->Array.Current->Color.Type);
#else
         *params = ENUM_TO_DOUBLE(ctx->Array.Color.Type);
#endif
         break;
      case GL_COLOR_ARRAY_STRIDE:
#ifdef VAO
         *params = (GLdouble) ctx->Array.Current->Color.Stride;
#else
         *params = (GLdouble) ctx->Array.Color.Stride;
#endif
         break;
      case GL_COLOR_ARRAY_COUNT_EXT:
         *params = 0.0;
         break;
      case GL_INDEX_ARRAY:
#ifdef VAO
         *params = (GLdouble) ctx->Array.Current->Index.Enabled;
#else
         *params = (GLdouble) ctx->Array.Index.Enabled;
#endif
         break;
      case GL_INDEX_ARRAY_TYPE:
#ifdef VAO
         *params = ENUM_TO_DOUBLE(ctx->Array.Current->Index.Type);
#else
         *params = ENUM_TO_DOUBLE(ctx->Array.Index.Type);
#endif
         break;
      case GL_INDEX_ARRAY_STRIDE:
#ifdef VAO
         *params = (GLdouble) ctx->Array.Current->Index.Stride;
#else
         *params = (GLdouble) ctx->Array.Index.Stride;
#endif
         break;
      case GL_INDEX_ARRAY_COUNT_EXT:
         *params = 0.0;
         break;
      case GL_TEXTURE_COORD_ARRAY:
#ifdef VAO
         *params = (GLdouble) ctx->Array.Current->TexCoord[texUnit].Enabled;
#else
         *params = (GLdouble) ctx->Array.TexCoord[texUnit].Enabled;
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_SIZE:
#ifdef VAO
         *params = (GLdouble) ctx->Array.Current->TexCoord[texUnit].Size;
#else
         *params = (GLdouble) ctx->Array.TexCoord[texUnit].Size;
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_TYPE:
#ifdef VAO
         *params = ENUM_TO_DOUBLE(ctx->Array.Current->TexCoord[texUnit].Type);
#else
         *params = ENUM_TO_DOUBLE(ctx->Array.TexCoord[texUnit].Type);
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_STRIDE:
#ifdef VAO
         *params = (GLdouble) ctx->Array.Current->TexCoord[texUnit].Stride;
#else
         *params = (GLdouble) ctx->Array.TexCoord[texUnit].Stride;
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_COUNT_EXT:
         *params = 0.0;
         break;
      case GL_EDGE_FLAG_ARRAY:
#ifdef VAO
         *params = (GLdouble) ctx->Array.Current->EdgeFlag.Enabled;
#else
         *params = (GLdouble) ctx->Array.EdgeFlag.Enabled;
#endif
         break;
      case GL_EDGE_FLAG_ARRAY_STRIDE:
#ifdef VAO
         *params = (GLdouble) ctx->Array.Current->EdgeFlag.Stride;
#else
         *params = (GLdouble) ctx->Array.EdgeFlag.Stride;
#endif
         break;
      case GL_EDGE_FLAG_ARRAY_COUNT_EXT:
         *params = 0.0;
         break;

      /* GL_ARB_multitexture */
      case GL_MAX_TEXTURE_UNITS_ARB:
         *params = (GLdouble) ctx->Const.MaxTextureUnits;
         break;
      case GL_ACTIVE_TEXTURE_ARB:
         *params = (GLdouble) (GL_TEXTURE0_ARB + ctx->Texture.CurrentUnit);
         break;
      case GL_CLIENT_ACTIVE_TEXTURE_ARB:
         *params = (GLdouble) (GL_TEXTURE0_ARB + ctx->Array.ActiveTexture);
         break;

      /* GL_ARB_texture_cube_map */
      case GL_TEXTURE_CUBE_MAP_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            *params = (GLdouble) _mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB);
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
         return;
      case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            *params = (GLdouble) textureUnit->CurrentCubeMap->Name;
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
         return;
      case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            *params = (GLdouble) ctx->Const.MaxCubeTextureSize;
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
         return;

      /* GL_ARB_texture_compression */
      case GL_TEXTURE_COMPRESSION_HINT_ARB:
         if (ctx->Extensions.HaveTextureCompression) {
            *params = (GLdouble) ctx->Hint.TextureCompression;
         }
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
         break;
      case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:
         if (ctx->Extensions.HaveTextureCompression) {
            *params = (GLdouble) ctx->Const.NumCompressedTextureFormats;
         }
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
         break;
      case GL_COMPRESSED_TEXTURE_FORMATS_ARB:
         if (ctx->Extensions.HaveTextureCompression) {
            GLuint i;
            for (i = 0; i < ctx->Const.NumCompressedTextureFormats; i++)
               params[i] = (GLdouble) ctx->Const.CompressedTextureFormats[i];
         }
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
         break;

      /* GL_PGI_misc_hints */
      case GL_STRICT_DEPTHFUNC_HINT_PGI:
	 *params = ENUM_TO_DOUBLE(GL_NICEST);
         break;
      case GL_STRICT_LIGHTING_HINT_PGI:
	 *params = ENUM_TO_DOUBLE(ctx->Hint.StrictLighting);
	 break;
      case GL_STRICT_SCISSOR_HINT_PGI:
      case GL_FULL_STIPPLE_HINT_PGI:
	 *params = ENUM_TO_DOUBLE(GL_TRUE);
	 break;
      case GL_CONSERVE_MEMORY_HINT_PGI:
	 *params = ENUM_TO_DOUBLE(GL_FALSE);
	 break;
      case GL_ALWAYS_FAST_HINT_PGI:
	 *params = (GLdouble) (ctx->Hint.AllowDrawWin == GL_TRUE &&
			      ctx->Hint.AllowDrawFrg == GL_FALSE && 
			      ctx->Hint.AllowDrawMem == GL_FALSE);
	 break;
      case GL_ALWAYS_SOFT_HINT_PGI:
	 *params = (GLdouble) (ctx->Hint.AllowDrawWin == GL_TRUE &&
			      ctx->Hint.AllowDrawFrg == GL_TRUE && 
			      ctx->Hint.AllowDrawMem == GL_TRUE);
	 break;
      case GL_ALLOW_DRAW_OBJ_HINT_PGI:
	 *params = (GLdouble) GL_TRUE;
	 break;
      case GL_ALLOW_DRAW_WIN_HINT_PGI:
	 *params = (GLdouble) ctx->Hint.AllowDrawWin;
	 break;
      case GL_ALLOW_DRAW_FRG_HINT_PGI:
	 *params = (GLdouble) ctx->Hint.AllowDrawFrg;
	 break;
      case GL_ALLOW_DRAW_MEM_HINT_PGI:
	 *params = (GLdouble) ctx->Hint.AllowDrawMem;
	 break;
      case GL_CLIP_NEAR_HINT_PGI:
      case GL_CLIP_FAR_HINT_PGI:
	 *params = ENUM_TO_DOUBLE(GL_TRUE);
	 break;
      case GL_WIDE_LINE_HINT_PGI:
	 *params = ENUM_TO_DOUBLE(GL_DONT_CARE);
	 break;
      case GL_BACK_NORMALS_HINT_PGI:
	 *params = ENUM_TO_DOUBLE(GL_TRUE);
	 break;
      case GL_NATIVE_GRAPHICS_HANDLE_PGI:
	 *params = 0;
	 break;

      /* GL_EXT_compiled_vertex_array */
      case GL_ARRAY_ELEMENT_LOCK_FIRST_EXT:
#ifdef VAO
	 *params = (GLdouble) ctx->Array.Current->LockFirst;
#else
	 *params = (GLdouble) ctx->Array.LockFirst;
#endif
	 break;
      case GL_ARRAY_ELEMENT_LOCK_COUNT_EXT:
#ifdef VAO
	 *params = (GLdouble) ctx->Array.Current->LockCount;
#else
	 *params = (GLdouble) ctx->Array.LockCount;
#endif
	 break;

      /* GL_ARB_transpose_matrix */
      case GL_TRANSPOSE_COLOR_MATRIX_ARB:
         {
            GLfloat tm[16];
            GLuint i;
            gl_matrix_transposef(tm, ctx->ColorMatrix.m);
            for (i=0;i<16;i++) {
               params[i] = (GLdouble) tm[i];
            }
         }
         break;
      case GL_TRANSPOSE_MODELVIEW_MATRIX_ARB:
         {
            GLfloat tm[16];
            GLuint i;
            gl_matrix_transposef(tm, ctx->ModelView.m);
            for (i=0;i<16;i++) {
               params[i] = (GLdouble) tm[i];
            }
         }
         break;
      case GL_TRANSPOSE_PROJECTION_MATRIX_ARB:
         {
            GLfloat tm[16];
            GLuint i;
            gl_matrix_transposef(tm, ctx->ProjectionMatrix.m);
            for (i=0;i<16;i++) {
               params[i] = (GLdouble) tm[i];
            }
         }
         break;
      case GL_TRANSPOSE_TEXTURE_MATRIX_ARB:
         {
            GLfloat tm[16];
            GLuint i;
            gl_matrix_transposef(tm, ctx->TextureMatrix[texTransformUnit].m);
            for (i=0;i<16;i++) {
               params[i] = (GLdouble) tm[i];
            }
         }
         break;

      /* GL_HP_occlusion_test */
      case GL_OCCLUSION_TEST_HP:
         if (ctx->Extensions.HaveHpOcclusionTest) {
            *params = (GLdouble) ctx->Depth.OcclusionTest;
         }
         else {
            gl_error( ctx, GL_INVALID_ENUM, "glGetDoublev" );
         }
         return;
      case GL_OCCLUSION_TEST_RESULT_HP:
         if (ctx->Extensions.HaveHpOcclusionTest) {
            if (ctx->Depth.OcclusionTest)
               *params = (GLdouble) ctx->OcclusionResult;
            else
               *params = (GLdouble) ctx->OcclusionResultSaved;
            /* reset flag now */
            ctx->OcclusionResult = GL_FALSE;
            ctx->OcclusionResultSaved = GL_FALSE;
         }
         else {
            gl_error( ctx, GL_INVALID_ENUM, "glGetDoublev" );
         }
         return;

      /* GL_SGIS_pixel_texture */
      case GL_PIXEL_TEXTURE_SGIS:
         *params = (GLdouble) ctx->Pixel.PixelTextureEnabled;
         break;

      /* GL_SGIX_pixel_texture */
      case GL_PIXEL_TEX_GEN_SGIX:
         *params = (GLdouble) ctx->Pixel.PixelTextureEnabled;
         break;
      case GL_PIXEL_TEX_GEN_MODE_SGIX:
         *params = (GLdouble) pixel_texgen_mode(ctx);
         break;

      /* GL_SGI_color_matrix (also in 1.2 imaging) */
      case GL_COLOR_MATRIX_SGI:
         for (i=0;i<16;i++) {
	    params[i] = (GLdouble) ctx->ColorMatrix.m[i];
	 }
	 break;
      case GL_COLOR_MATRIX_STACK_DEPTH_SGI:
         *params = (GLdouble) (ctx->ColorStackDepth + 1);
         break;
      case GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI:
         *params = (GLdouble) MAX_COLOR_STACK_DEPTH;
         break;
      case GL_POST_COLOR_MATRIX_RED_SCALE_SGI:
         *params = (GLdouble) ctx->Pixel.PostColorMatrixScale[0];
         break;
      case GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI:
         *params = (GLdouble) ctx->Pixel.PostColorMatrixScale[1];
         break;
      case GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI:
         *params = (GLdouble) ctx->Pixel.PostColorMatrixScale[2];
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI:
         *params = (GLdouble) ctx->Pixel.PostColorMatrixScale[3];
         break;
      case GL_POST_COLOR_MATRIX_RED_BIAS_SGI:
         *params = (GLdouble) ctx->Pixel.PostColorMatrixBias[0];
         break;
      case GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI:
         *params = (GLdouble) ctx->Pixel.PostColorMatrixBias[1];
         break;
      case GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI:
         *params = (GLdouble) ctx->Pixel.PostColorMatrixBias[2];
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI:
         *params = (GLdouble) ctx->Pixel.PostColorMatrixBias[3];
         break;

      /* GL_EXT_convolution (also in 1.2 imaging) */
      case GL_MAX_CONVOLUTION_WIDTH:
         *params = (GLdouble) ctx->Const.MaxConvolutionWidth;
         break;
      case GL_MAX_CONVOLUTION_HEIGHT:
         *params = (GLdouble) ctx->Const.MaxConvolutionHeight;
         break;
      case GL_POST_CONVOLUTION_RED_SCALE_EXT:
         *params = (GLdouble) ctx->Pixel.PostConvolutionScale[0];
         break;
      case GL_POST_CONVOLUTION_GREEN_SCALE_EXT:
         *params = (GLdouble) ctx->Pixel.PostConvolutionScale[1];
         break;
      case GL_POST_CONVOLUTION_BLUE_SCALE_EXT:
         *params = (GLdouble) ctx->Pixel.PostConvolutionScale[2];
         break;
      case GL_POST_CONVOLUTION_ALPHA_SCALE_EXT:
         *params = (GLdouble) ctx->Pixel.PostConvolutionScale[3];
         break;
      case GL_POST_CONVOLUTION_RED_BIAS_EXT:
         *params = (GLdouble) ctx->Pixel.PostConvolutionBias[0];
         break;
      case GL_POST_CONVOLUTION_GREEN_BIAS_EXT:
         *params = (GLdouble) ctx->Pixel.PostConvolutionBias[1];
         break;
      case GL_POST_CONVOLUTION_BLUE_BIAS_EXT:
         *params = (GLdouble) ctx->Pixel.PostConvolutionBias[2];
         break;
      case GL_POST_CONVOLUTION_ALPHA_BIAS_EXT:
         *params = (GLdouble) ctx->Pixel.PostConvolutionBias[2];
         break;

      /* GL_SGI_color_table (also in 1.2 imaging */
      case GL_COLOR_TABLE_SGI:
         *params = (GLdouble) ctx->Pixel.ColorTableEnabled;
         break;
      case GL_POST_CONVOLUTION_COLOR_TABLE_SGI:
         *params = (GLdouble) ctx->Pixel.PostConvolutionColorTableEnabled;
         break;
      case GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI:
         *params = (GLdouble) ctx->Pixel.PostColorMatrixColorTableEnabled;
         break;

      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetDoublev" );
   }
}




void
_mesa_GetFloatv( GLenum pname, GLfloat *params )
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint i;
   GLuint texUnit = ctx->Texture.CurrentUnit;
   GLuint texTransformUnit = ctx->Texture.CurrentTransformUnit;
   const struct gl_texture_unit *textureUnit = &ctx->Texture.Unit[texUnit];

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetFloatv");

   if (!params)
      return;

   if (MESA_VERBOSE & VERBOSE_API) 
      fprintf(stderr, "glGetFloatv %s\n", gl_lookup_enum_by_nr(pname));

   if (ctx->Driver.GetFloatv && (*ctx->Driver.GetFloatv)(ctx, pname, params))
      return;

   switch (pname) {
      case GL_ACCUM_RED_BITS:
         *params = (GLfloat) ctx->Visual->AccumRedBits;
         break;
      case GL_ACCUM_GREEN_BITS:
         *params = (GLfloat) ctx->Visual->AccumGreenBits;
         break;
      case GL_ACCUM_BLUE_BITS:
         *params = (GLfloat) ctx->Visual->AccumBlueBits;
         break;
      case GL_ACCUM_ALPHA_BITS:
         *params = (GLfloat) ctx->Visual->AccumAlphaBits;
         break;
      case GL_ACCUM_CLEAR_VALUE:
         params[0] = ctx->Accum.ClearColor[0];
         params[1] = ctx->Accum.ClearColor[1];
         params[2] = ctx->Accum.ClearColor[2];
         params[3] = ctx->Accum.ClearColor[3];
         break;
      case GL_ALPHA_BIAS:
         *params = ctx->Pixel.AlphaBias;
         break;
      case GL_ALPHA_BITS:
         *params = (GLfloat) ctx->Visual->AlphaBits;
         break;
      case GL_ALPHA_SCALE:
         *params = ctx->Pixel.AlphaScale;
         break;
      case GL_ALPHA_TEST:
         *params = (GLfloat) ctx->Color.AlphaEnabled;
         break;
      case GL_ALPHA_TEST_FUNC:
         *params = ENUM_TO_FLOAT(ctx->Color.AlphaFunc);
         break;
      case GL_ALPHA_TEST_REF:
         *params = (GLfloat) ctx->Color.AlphaRef / 255.0;
         break;
      case GL_ATTRIB_STACK_DEPTH:
         *params = (GLfloat) (ctx->AttribStackDepth);
         break;
      case GL_AUTO_NORMAL:
         *params = (GLfloat) ctx->Eval.AutoNormal;
         break;
      case GL_AUX_BUFFERS:
         *params = (GLfloat) ctx->Const.NumAuxBuffers;
         break;
      case GL_BLEND:
         *params = (GLfloat) ctx->Color.BlendEnabled;
         break;
      case GL_BLEND_DST:
         *params = ENUM_TO_FLOAT(ctx->Color.BlendDstRGB);
         break;
      case GL_BLEND_SRC:
         *params = ENUM_TO_FLOAT(ctx->Color.BlendSrcRGB);
         break;
      case GL_BLEND_SRC_RGB_EXT:
         *params = ENUM_TO_FLOAT(ctx->Color.BlendSrcRGB);
         break;
      case GL_BLEND_DST_RGB_EXT:
         *params = ENUM_TO_FLOAT(ctx->Color.BlendDstRGB);
         break;
      case GL_BLEND_SRC_ALPHA_EXT:
         *params = ENUM_TO_FLOAT(ctx->Color.BlendSrcA);
         break;
      case GL_BLEND_DST_ALPHA_EXT:
         *params = ENUM_TO_FLOAT(ctx->Color.BlendDstA);
         break;
      case GL_BLEND_EQUATION_EXT:
	 *params = ENUM_TO_FLOAT(ctx->Color.BlendEquation);
	 break;
      case GL_BLEND_COLOR_EXT:
	 params[0] = ctx->Color.BlendColor[0];
	 params[1] = ctx->Color.BlendColor[1];
	 params[2] = ctx->Color.BlendColor[2];
	 params[3] = ctx->Color.BlendColor[3];
	 break;
      case GL_BLUE_BIAS:
         *params = ctx->Pixel.BlueBias;
         break;
      case GL_BLUE_BITS:
         *params = (GLfloat) ctx->Visual->BlueBits;
         break;
      case GL_BLUE_SCALE:
         *params = ctx->Pixel.BlueScale;
         break;
      case GL_CLIENT_ATTRIB_STACK_DEPTH:
         *params = (GLfloat) (ctx->ClientAttribStackDepth);
         break;
      case GL_CLIP_PLANE0:
      case GL_CLIP_PLANE1:
      case GL_CLIP_PLANE2:
      case GL_CLIP_PLANE3:
      case GL_CLIP_PLANE4:
      case GL_CLIP_PLANE5:
         *params = (GLfloat) ctx->Transform.ClipEnabled[pname-GL_CLIP_PLANE0];
         break;
      case GL_COLOR_CLEAR_VALUE:
         params[0] = (GLfloat) ctx->Color.ClearColor[0];
         params[1] = (GLfloat) ctx->Color.ClearColor[1];
         params[2] = (GLfloat) ctx->Color.ClearColor[2];
         params[3] = (GLfloat) ctx->Color.ClearColor[3];
         break;
      case GL_COLOR_MATERIAL:
         *params = (GLfloat) ctx->Light.ColorMaterialEnabled;
         break;
      case GL_COLOR_MATERIAL_FACE:
         *params = ENUM_TO_FLOAT(ctx->Light.ColorMaterialFace);
         break;
      case GL_COLOR_MATERIAL_PARAMETER:
         *params = ENUM_TO_FLOAT(ctx->Light.ColorMaterialMode);
         break;
      case GL_COLOR_WRITEMASK:
         params[0] = ctx->Color.ColorMask[RCOMP] ? 1.0F : 0.0F;
         params[1] = ctx->Color.ColorMask[GCOMP] ? 1.0F : 0.0F;
         params[2] = ctx->Color.ColorMask[BCOMP] ? 1.0F : 0.0F;
         params[3] = ctx->Color.ColorMask[ACOMP] ? 1.0F : 0.0F;
         break;
      case GL_CULL_FACE:
         *params = (GLfloat) ctx->Polygon.CullFlag;
         break;
      case GL_CULL_FACE_MODE:
         *params = ENUM_TO_FLOAT(ctx->Polygon.CullFaceMode);
         break;
      case GL_CURRENT_COLOR:
	 UBYTE_RGBA_TO_FLOAT_RGBA(params, ctx->Current.ByteColor);
         break;
      case GL_CURRENT_INDEX:
         *params = (GLfloat) ctx->Current.Index;
         break;
      case GL_CURRENT_NORMAL:
         params[0] = ctx->Current.Normal[0];
         params[1] = ctx->Current.Normal[1];
         params[2] = ctx->Current.Normal[2];
         break;
      case GL_CURRENT_RASTER_COLOR:
	 params[0] = ctx->Current.RasterColor[0];
	 params[1] = ctx->Current.RasterColor[1];
	 params[2] = ctx->Current.RasterColor[2];
	 params[3] = ctx->Current.RasterColor[3];
	 break;
      case GL_CURRENT_RASTER_DISTANCE:
	 params[0] = ctx->Current.RasterDistance;
	 break;
      case GL_CURRENT_RASTER_INDEX:
	 *params = (GLfloat) ctx->Current.RasterIndex;
	 break;
      case GL_CURRENT_RASTER_POSITION:
	 params[0] = ctx->Current.RasterPos[0];
	 params[1] = ctx->Current.RasterPos[1];
	 params[2] = ctx->Current.RasterPos[2];
	 params[3] = ctx->Current.RasterPos[3];
	 break;
      case GL_CURRENT_RASTER_TEXTURE_COORDS:
	 params[0] = ctx->Current.RasterMultiTexCoord[texTransformUnit][0];
	 params[1] = ctx->Current.RasterMultiTexCoord[texTransformUnit][1];
	 params[2] = ctx->Current.RasterMultiTexCoord[texTransformUnit][2];
	 params[3] = ctx->Current.RasterMultiTexCoord[texTransformUnit][3];
	 break;
      case GL_CURRENT_RASTER_POSITION_VALID:
	 *params = (GLfloat) ctx->Current.RasterPosValid;
	 break;
      case GL_CURRENT_TEXTURE_COORDS:
	 params[0] = (GLfloat) ctx->Current.Texcoord[texTransformUnit][0];
	 params[1] = (GLfloat) ctx->Current.Texcoord[texTransformUnit][1];
	 params[2] = (GLfloat) ctx->Current.Texcoord[texTransformUnit][2];
	 params[3] = (GLfloat) ctx->Current.Texcoord[texTransformUnit][3];
	 break;
      case GL_DEPTH_BIAS:
	 *params = (GLfloat) ctx->Pixel.DepthBias;
	 break;
      case GL_DEPTH_BITS:
	 *params = (GLfloat) ctx->Visual->DepthBits;
	 break;
      case GL_DEPTH_CLEAR_VALUE:
	 *params = (GLfloat) ctx->Depth.Clear;
	 break;
      case GL_DEPTH_FUNC:
	 *params = ENUM_TO_FLOAT(ctx->Depth.Func);
	 break;
      case GL_DEPTH_RANGE:
         params[0] = (GLfloat) ctx->Viewport.Near;
         params[1] = (GLfloat) ctx->Viewport.Far;
	 break;
      case GL_DEPTH_SCALE:
	 *params = (GLfloat) ctx->Pixel.DepthScale;
	 break;
      case GL_DEPTH_TEST:
	 *params = (GLfloat) ctx->Depth.Test;
	 break;
      case GL_DEPTH_WRITEMASK:
	 *params = (GLfloat) ctx->Depth.Mask;
	 break;
      case GL_DITHER:
	 *params = (GLfloat) ctx->Color.DitherFlag;
	 break;
      case GL_DOUBLEBUFFER:
	 *params = (GLfloat) ctx->Visual->DBflag;
	 break;
      case GL_DRAW_BUFFER:
	 *params = ENUM_TO_FLOAT(ctx->Color.DrawBuffer);
	 break;
      case GL_EDGE_FLAG:
	 *params = (GLfloat) ctx->Current.EdgeFlag;
	 break;
      case GL_FEEDBACK_BUFFER_SIZE:
         *params = (GLfloat) ctx->Feedback.BufferSize;
         break;
      case GL_FEEDBACK_BUFFER_TYPE:
         *params = ENUM_TO_FLOAT(ctx->Feedback.Type);
         break;
      case GL_FOG:
	 *params = (GLfloat) ctx->Fog.Enabled;
	 break;
      case GL_FOG_COLOR:
	 params[0] = ctx->Fog.Color[0];
	 params[1] = ctx->Fog.Color[1];
	 params[2] = ctx->Fog.Color[2];
	 params[3] = ctx->Fog.Color[3];
	 break;
      case GL_FOG_DENSITY:
	 *params = ctx->Fog.Density;
	 break;
      case GL_FOG_END:
	 *params = ctx->Fog.End;
	 break;
      case GL_FOG_HINT:
	 *params = ENUM_TO_FLOAT(ctx->Hint.Fog);
	 break;
      case GL_FOG_INDEX:
	 *params = ctx->Fog.Index;
	 break;
      case GL_FOG_MODE:
	 *params = ENUM_TO_FLOAT(ctx->Fog.Mode);
	 break;
      case GL_FOG_START:
	 *params = ctx->Fog.Start;
	 break;
      case GL_FRONT_FACE:
	 *params = ENUM_TO_FLOAT(ctx->Polygon.FrontFace);
	 break;
      case GL_GREEN_BIAS:
         *params = (GLfloat) ctx->Pixel.GreenBias;
         break;
      case GL_GREEN_BITS:
         *params = (GLfloat) ctx->Visual->GreenBits;
         break;
      case GL_GREEN_SCALE:
         *params = (GLfloat) ctx->Pixel.GreenScale;
         break;
      case GL_HISTOGRAM:
         *params = (GLfloat) ctx->Pixel.HistogramEnabled;
	 break;
      case GL_INDEX_BITS:
         *params = (GLfloat) ctx->Visual->IndexBits;
	 break;
      case GL_INDEX_CLEAR_VALUE:
         *params = (GLfloat) ctx->Color.ClearIndex;
	 break;
      case GL_INDEX_MODE:
	 *params = ctx->Visual->RGBAflag ? 0.0F : 1.0F;
	 break;
      case GL_INDEX_OFFSET:
	 *params = (GLfloat) ctx->Pixel.IndexOffset;
	 break;
      case GL_INDEX_SHIFT:
	 *params = (GLfloat) ctx->Pixel.IndexShift;
	 break;
      case GL_INDEX_WRITEMASK:
	 *params = (GLfloat) ctx->Color.IndexMask;
	 break;
      case GL_LIGHT0:
      case GL_LIGHT1:
      case GL_LIGHT2:
      case GL_LIGHT3:
      case GL_LIGHT4:
      case GL_LIGHT5:
      case GL_LIGHT6:
      case GL_LIGHT7:
	 *params = (GLfloat) ctx->Light.Light[pname-GL_LIGHT0].Enabled;
	 break;
      case GL_LIGHTING:
	 *params = (GLfloat) ctx->Light.Enabled;
	 break;
      case GL_LIGHT_MODEL_AMBIENT:
	 params[0] = ctx->Light.Model.Ambient[0];
	 params[1] = ctx->Light.Model.Ambient[1];
	 params[2] = ctx->Light.Model.Ambient[2];
	 params[3] = ctx->Light.Model.Ambient[3];
	 break;
      case GL_LIGHT_MODEL_COLOR_CONTROL:
         params[0] = ENUM_TO_FLOAT(ctx->Light.Model.ColorControl);
         break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
	 *params = (GLfloat) ctx->Light.Model.LocalViewer;
	 break;
      case GL_LIGHT_MODEL_TWO_SIDE:
	 *params = (GLfloat) ctx->Light.Model.TwoSide;
	 break;
      case GL_LINE_SMOOTH:
	 *params = (GLfloat) ctx->Line.SmoothFlag;
	 break;
      case GL_LINE_SMOOTH_HINT:
	 *params = ENUM_TO_FLOAT(ctx->Hint.LineSmooth);
	 break;
      case GL_LINE_STIPPLE:
	 *params = (GLfloat) ctx->Line.StippleFlag;
	 break;
      case GL_LINE_STIPPLE_PATTERN:
         *params = (GLfloat) ctx->Line.StipplePattern;
         break;
      case GL_LINE_STIPPLE_REPEAT:
         *params = (GLfloat) ctx->Line.StippleFactor;
         break;
      case GL_LINE_WIDTH:
	 *params = (GLfloat) ctx->Line.Width;
	 break;
      case GL_LINE_WIDTH_GRANULARITY:
	 *params = (GLfloat) ctx->Const.LineWidthGranularity;
	 break;
      case GL_LINE_WIDTH_RANGE:
	 params[0] = (GLfloat) ctx->Const.MinLineWidthAA;
	 params[1] = (GLfloat) ctx->Const.MaxLineWidthAA;
	 break;
      case GL_ALIASED_LINE_WIDTH_RANGE:
	 params[0] = (GLfloat) ctx->Const.MinLineWidth;
	 params[1] = (GLfloat) ctx->Const.MaxLineWidth;
	 break;
      case GL_LIST_BASE:
	 *params = (GLfloat) ctx->List.ListBase;
	 break;
      case GL_LIST_INDEX:
	 *params = (GLfloat) ctx->CurrentListNum;
	 break;
      case GL_LIST_MODE:
	 *params = ctx->ExecuteFlag ? ENUM_TO_FLOAT(GL_COMPILE_AND_EXECUTE)
	   			  : ENUM_TO_FLOAT(GL_COMPILE);
	 break;
      case GL_INDEX_LOGIC_OP:
	 *params = (GLfloat) ctx->Color.IndexLogicOpEnabled;
	 break;
      case GL_COLOR_LOGIC_OP:
	 *params = (GLfloat) ctx->Color.ColorLogicOpEnabled;
	 break;
      case GL_LOGIC_OP_MODE:
         *params = ENUM_TO_FLOAT(ctx->Color.LogicOp);
	 break;
      case GL_MAP1_COLOR_4:
	 *params = (GLfloat) ctx->Eval.Map1Color4;
	 break;
      case GL_MAP1_GRID_DOMAIN:
	 params[0] = ctx->Eval.MapGrid1u1;
	 params[1] = ctx->Eval.MapGrid1u2;
	 break;
      case GL_MAP1_GRID_SEGMENTS:
	 *params = (GLfloat) ctx->Eval.MapGrid1un;
	 break;
      case GL_MAP1_INDEX:
	 *params = (GLfloat) ctx->Eval.Map1Index;
	 break;
      case GL_MAP1_NORMAL:
	 *params = (GLfloat) ctx->Eval.Map1Normal;
	 break;
      case GL_MAP1_TEXTURE_COORD_1:
	 *params = (GLfloat) ctx->Eval.Map1TextureCoord1;
	 break;
      case GL_MAP1_TEXTURE_COORD_2:
	 *params = (GLfloat) ctx->Eval.Map1TextureCoord2;
	 break;
      case GL_MAP1_TEXTURE_COORD_3:
	 *params = (GLfloat) ctx->Eval.Map1TextureCoord3;
	 break;
      case GL_MAP1_TEXTURE_COORD_4:
	 *params = (GLfloat) ctx->Eval.Map1TextureCoord4;
	 break;
      case GL_MAP1_VERTEX_3:
	 *params = (GLfloat) ctx->Eval.Map1Vertex3;
	 break;
      case GL_MAP1_VERTEX_4:
	 *params = (GLfloat) ctx->Eval.Map1Vertex4;
	 break;
      case GL_MAP2_COLOR_4:
	 *params = (GLfloat) ctx->Eval.Map2Color4;
	 break;
      case GL_MAP2_GRID_DOMAIN:
	 params[0] = ctx->Eval.MapGrid2u1;
	 params[1] = ctx->Eval.MapGrid2u2;
	 params[2] = ctx->Eval.MapGrid2v1;
	 params[3] = ctx->Eval.MapGrid2v2;
	 break;
      case GL_MAP2_GRID_SEGMENTS:
	 params[0] = (GLfloat) ctx->Eval.MapGrid2un;
	 params[1] = (GLfloat) ctx->Eval.MapGrid2vn;
	 break;
      case GL_MAP2_INDEX:
	 *params = (GLfloat) ctx->Eval.Map2Index;
	 break;
      case GL_MAP2_NORMAL:
	 *params = (GLfloat) ctx->Eval.Map2Normal;
	 break;
      case GL_MAP2_TEXTURE_COORD_1:
	 *params = ctx->Eval.Map2TextureCoord1;
	 break;
      case GL_MAP2_TEXTURE_COORD_2:
	 *params = ctx->Eval.Map2TextureCoord2;
	 break;
      case GL_MAP2_TEXTURE_COORD_3:
	 *params = ctx->Eval.Map2TextureCoord3;
	 break;
      case GL_MAP2_TEXTURE_COORD_4:
	 *params = ctx->Eval.Map2TextureCoord4;
	 break;
      case GL_MAP2_VERTEX_3:
	 *params = (GLfloat) ctx->Eval.Map2Vertex3;
	 break;
      case GL_MAP2_VERTEX_4:
	 *params = (GLfloat) ctx->Eval.Map2Vertex4;
	 break;
      case GL_MAP_COLOR:
	 *params = (GLfloat) ctx->Pixel.MapColorFlag;
	 break;
      case GL_MAP_STENCIL:
	 *params = (GLfloat) ctx->Pixel.MapStencilFlag;
	 break;
      case GL_MATRIX_MODE:
	 *params = ENUM_TO_FLOAT(ctx->Transform.MatrixMode);
	 break;
      case GL_MAX_ATTRIB_STACK_DEPTH:
	 *params = (GLfloat) MAX_ATTRIB_STACK_DEPTH;
	 break;
      case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
         *params = (GLfloat) MAX_CLIENT_ATTRIB_STACK_DEPTH;
         break;
      case GL_MAX_CLIP_PLANES:
	 *params = (GLfloat) MAX_CLIP_PLANES;
	 break;
      case GL_MAX_ELEMENTS_VERTICES:  /* GL_VERSION_1_2 */
         *params = (GLfloat) VB_MAX;
         break;
      case GL_MAX_ELEMENTS_INDICES:   /* GL_VERSION_1_2 */
         *params = (GLfloat) VB_MAX;
         break;
      case GL_MAX_EVAL_ORDER:
	 *params = (GLfloat) MAX_EVAL_ORDER;
	 break;
      case GL_MAX_LIGHTS:
	 *params = (GLfloat) MAX_LIGHTS;
	 break;
      case GL_MAX_LIST_NESTING:
	 *params = (GLfloat) MAX_LIST_NESTING;
	 break;
      case GL_MAX_MODELVIEW_STACK_DEPTH:
	 *params = (GLfloat) MAX_MODELVIEW_STACK_DEPTH;
	 break;
      case GL_MAX_NAME_STACK_DEPTH:
	 *params = (GLfloat) MAX_NAME_STACK_DEPTH;
	 break;
      case GL_MAX_PIXEL_MAP_TABLE:
	 *params = (GLfloat) MAX_PIXEL_MAP_TABLE;
	 break;
      case GL_MAX_PROJECTION_STACK_DEPTH:
	 *params = (GLfloat) MAX_PROJECTION_STACK_DEPTH;
	 break;
      case GL_MAX_TEXTURE_SIZE:
      case GL_MAX_3D_TEXTURE_SIZE:
         *params = (GLfloat) ctx->Const.MaxTextureSize;
	 break;
      case GL_MAX_TEXTURE_STACK_DEPTH:
	 *params = (GLfloat) MAX_TEXTURE_STACK_DEPTH;
	 break;
      case GL_MAX_VIEWPORT_DIMS:
         params[0] = (GLfloat) MAX_WIDTH;
         params[1] = (GLfloat) MAX_HEIGHT;
         break;
      case GL_MINMAX:
         *params = (GLfloat) ctx->Pixel.MinMaxEnabled;
         break;
      case GL_MODELVIEW_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = ctx->ModelView.m[i];
	 }
	 break;
      case GL_MODELVIEW_STACK_DEPTH:
	 *params = (GLfloat) (ctx->ModelViewStackDepth + 1);
	 break;
      case GL_NAME_STACK_DEPTH:
	 *params = (GLfloat) ctx->Select.NameStackDepth;
	 break;
      case GL_NORMALIZE:
	 *params = (GLfloat) ctx->Transform.Normalize;
	 break;
      case GL_PACK_ALIGNMENT:
	 *params = (GLfloat) ctx->Pack.Alignment;
	 break;
      case GL_PACK_LSB_FIRST:
	 *params = (GLfloat) ctx->Pack.LsbFirst;
	 break;
      case GL_PACK_ROW_LENGTH:
	 *params = (GLfloat) ctx->Pack.RowLength;
	 break;
      case GL_PACK_SKIP_PIXELS:
	 *params = (GLfloat) ctx->Pack.SkipPixels;
	 break;
      case GL_PACK_SKIP_ROWS:
	 *params = (GLfloat) ctx->Pack.SkipRows;
	 break;
      case GL_PACK_SWAP_BYTES:
	 *params = (GLfloat) ctx->Pack.SwapBytes;
	 break;
      case GL_PACK_SKIP_IMAGES_EXT:
         *params = (GLfloat) ctx->Pack.SkipImages;
         break;
      case GL_PACK_IMAGE_HEIGHT_EXT:
         *params = (GLfloat) ctx->Pack.ImageHeight;
         break;
      case GL_PERSPECTIVE_CORRECTION_HINT:
	 *params = ENUM_TO_FLOAT(ctx->Hint.PerspectiveCorrection);
	 break;
      case GL_PIXEL_MAP_A_TO_A_SIZE:
	 *params = (GLfloat) ctx->Pixel.MapAtoAsize;
	 break;
      case GL_PIXEL_MAP_B_TO_B_SIZE:
	 *params = (GLfloat) ctx->Pixel.MapBtoBsize;
	 break;
      case GL_PIXEL_MAP_G_TO_G_SIZE:
	 *params = (GLfloat) ctx->Pixel.MapGtoGsize;
	 break;
      case GL_PIXEL_MAP_I_TO_A_SIZE:
	 *params = (GLfloat) ctx->Pixel.MapItoAsize;
	 break;
      case GL_PIXEL_MAP_I_TO_B_SIZE:
	 *params = (GLfloat) ctx->Pixel.MapItoBsize;
	 break;
      case GL_PIXEL_MAP_I_TO_G_SIZE:
	 *params = (GLfloat) ctx->Pixel.MapItoGsize;
	 break;
      case GL_PIXEL_MAP_I_TO_I_SIZE:
	 *params = (GLfloat) ctx->Pixel.MapItoIsize;
	 break;
      case GL_PIXEL_MAP_I_TO_R_SIZE:
	 *params = (GLfloat) ctx->Pixel.MapItoRsize;
	 break;
      case GL_PIXEL_MAP_R_TO_R_SIZE:
	 *params = (GLfloat) ctx->Pixel.MapRtoRsize;
	 break;
      case GL_PIXEL_MAP_S_TO_S_SIZE:
	 *params = (GLfloat) ctx->Pixel.MapStoSsize;
	 break;
      case GL_POINT_SIZE:
         *params = (GLfloat) ctx->Point.UserSize;
         break;
      case GL_POINT_SIZE_GRANULARITY:
	 *params = (GLfloat) ctx->Const.PointSizeGranularity;
	 break;
      case GL_POINT_SIZE_RANGE:
	 params[0] = (GLfloat) ctx->Const.MinPointSizeAA;
	 params[1] = (GLfloat) ctx->Const.MaxPointSizeAA;
	 break;
      case GL_ALIASED_POINT_SIZE_RANGE:
	 params[0] = (GLfloat) ctx->Const.MinPointSize;
	 params[1] = (GLfloat) ctx->Const.MaxPointSize;
	 break;
      case GL_POINT_SMOOTH:
	 *params = (GLfloat) ctx->Point.SmoothFlag;
	 break;
      case GL_POINT_SMOOTH_HINT:
	 *params = ENUM_TO_FLOAT(ctx->Hint.PointSmooth);
	 break;
      case GL_POINT_SIZE_MIN_EXT:
	 *params = (GLfloat) (ctx->Point.MinSize);
	 break;
      case GL_POINT_SIZE_MAX_EXT:
	 *params = (GLfloat) (ctx->Point.MaxSize);
	 break;
      case GL_POINT_FADE_THRESHOLD_SIZE_EXT:
	 *params = (GLfloat) (ctx->Point.Threshold);
	 break;
      case GL_DISTANCE_ATTENUATION_EXT:
	 params[0] = (GLfloat) (ctx->Point.Params[0]);
	 params[1] = (GLfloat) (ctx->Point.Params[1]);
	 params[2] = (GLfloat) (ctx->Point.Params[2]);
	 break;
      case GL_POLYGON_MODE:
	 params[0] = ENUM_TO_FLOAT(ctx->Polygon.FrontMode);
	 params[1] = ENUM_TO_FLOAT(ctx->Polygon.BackMode);
	 break;
#ifdef GL_EXT_polygon_offset
      case GL_POLYGON_OFFSET_BIAS_EXT:
         *params = ctx->Polygon.OffsetUnits;
         break;
#endif
      case GL_POLYGON_OFFSET_FACTOR:
         *params = ctx->Polygon.OffsetFactor;
         break;
      case GL_POLYGON_OFFSET_UNITS:
         *params = ctx->Polygon.OffsetUnits;
         break;
      case GL_POLYGON_SMOOTH:
	 *params = (GLfloat) ctx->Polygon.SmoothFlag;
	 break;
      case GL_POLYGON_SMOOTH_HINT:
	 *params = ENUM_TO_FLOAT(ctx->Hint.PolygonSmooth);
	 break;
      case GL_POLYGON_STIPPLE:
         *params = (GLfloat) ctx->Polygon.StippleFlag;
	 break;
      case GL_PROJECTION_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = ctx->ProjectionMatrix.m[i];
	 }
	 break;
      case GL_PROJECTION_STACK_DEPTH:
	 *params = (GLfloat) (ctx->ProjectionStackDepth + 1);
	 break;
      case GL_READ_BUFFER:
	 *params = ENUM_TO_FLOAT(ctx->Pixel.ReadBuffer);
	 break;
      case GL_RED_BIAS:
         *params = ctx->Pixel.RedBias;
         break;
      case GL_RED_BITS:
         *params = (GLfloat) ctx->Visual->RedBits;
         break;
      case GL_RED_SCALE:
         *params = ctx->Pixel.RedScale;
         break;
      case GL_RENDER_MODE:
	 *params = ENUM_TO_FLOAT(ctx->RenderMode);
	 break;
      case GL_RESCALE_NORMAL:
         *params = (GLfloat) ctx->Transform.RescaleNormals;
         break;
      case GL_RGBA_MODE:
	 *params = (GLfloat) ctx->Visual->RGBAflag;
	 break;
      case GL_SCISSOR_BOX:
	 params[0] = (GLfloat) ctx->Scissor.X;
	 params[1] = (GLfloat) ctx->Scissor.Y;
	 params[2] = (GLfloat) ctx->Scissor.Width;
	 params[3] = (GLfloat) ctx->Scissor.Height;
	 break;
      case GL_SCISSOR_TEST:
	 *params = (GLfloat) ctx->Scissor.Enabled;
	 break;
      case GL_SELECTION_BUFFER_SIZE:
         *params = (GLfloat) ctx->Select.BufferSize;
         break;
      case GL_SHADE_MODEL:
	 *params = ENUM_TO_FLOAT(ctx->Light.ShadeModel);
	 break;
      case GL_SHARED_TEXTURE_PALETTE_EXT:
         *params = (GLfloat) ctx->Texture.SharedPalette;
         break;
      case GL_STENCIL_BITS:
         *params = (GLfloat) ctx->Visual->StencilBits;
         break;
      case GL_STENCIL_CLEAR_VALUE:
	 *params = (GLfloat) ctx->Stencil.Clear;
	 break;
      case GL_STENCIL_FAIL:
	 *params = ENUM_TO_FLOAT(ctx->Stencil.FailFunc);
	 break;
      case GL_STENCIL_FUNC:
	 *params = ENUM_TO_FLOAT(ctx->Stencil.Function);
	 break;
      case GL_STENCIL_PASS_DEPTH_FAIL:
	 *params = ENUM_TO_FLOAT(ctx->Stencil.ZFailFunc);
	 break;
      case GL_STENCIL_PASS_DEPTH_PASS:
	 *params = ENUM_TO_FLOAT(ctx->Stencil.ZPassFunc);
	 break;
      case GL_STENCIL_REF:
	 *params = (GLfloat) ctx->Stencil.Ref;
	 break;
      case GL_STENCIL_TEST:
	 *params = (GLfloat) ctx->Stencil.Enabled;
	 break;
      case GL_STENCIL_VALUE_MASK:
	 *params = (GLfloat) ctx->Stencil.ValueMask;
	 break;
      case GL_STENCIL_WRITEMASK:
	 *params = (GLfloat) ctx->Stencil.WriteMask;
	 break;
      case GL_STEREO:
	 *params = (GLfloat) ctx->Visual->StereoFlag;
	 break;
      case GL_SUBPIXEL_BITS:
	 *params = (GLfloat) ctx->Const.SubPixelBits;
	 break;
      case GL_TEXTURE_1D:
         *params = _mesa_IsEnabled(GL_TEXTURE_1D) ? 1.0 : 0.0;
	 break;
      case GL_TEXTURE_2D:
         *params = _mesa_IsEnabled(GL_TEXTURE_2D) ? 1.0 : 0.0;
	 break;
      case GL_TEXTURE_3D:
         *params = _mesa_IsEnabled(GL_TEXTURE_3D) ? 1.0 : 0.0;
	 break;
      case GL_TEXTURE_BINDING_1D:
         *params = (GLfloat) textureUnit->CurrentD[1]->Name;
          break;
      case GL_TEXTURE_BINDING_2D:
         *params = (GLfloat) textureUnit->CurrentD[2]->Name;
          break;
      case GL_TEXTURE_BINDING_3D:
         *params = (GLfloat) textureUnit->CurrentD[2]->Name;
          break;
      case GL_TEXTURE_ENV_COLOR:
	 params[0] = textureUnit->EnvColor[0];
	 params[1] = textureUnit->EnvColor[1];
	 params[2] = textureUnit->EnvColor[2];
	 params[3] = textureUnit->EnvColor[3];
	 break;
      case GL_TEXTURE_ENV_MODE:
	 *params = ENUM_TO_FLOAT(textureUnit->EnvMode);
	 break;
      case GL_TEXTURE_GEN_S:
	 *params = (textureUnit->TexGenEnabled & S_BIT) ? 1.0 : 0.0;
	 break;
      case GL_TEXTURE_GEN_T:
	 *params = (textureUnit->TexGenEnabled & T_BIT) ? 1.0 : 0.0;
	 break;
      case GL_TEXTURE_GEN_R:
	 *params = (textureUnit->TexGenEnabled & R_BIT) ? 1.0 : 0.0;
	 break;
      case GL_TEXTURE_GEN_Q:
	 *params = (textureUnit->TexGenEnabled & Q_BIT) ? 1.0 : 0.0;
	 break;
      case GL_TEXTURE_MATRIX:
         for (i=0;i<16;i++) {
	    params[i] = ctx->TextureMatrix[texTransformUnit].m[i];
	 }
	 break;
      case GL_TEXTURE_STACK_DEPTH:
	 *params = (GLfloat) (ctx->TextureStackDepth[texTransformUnit] + 1);
	 break;
      case GL_UNPACK_ALIGNMENT:
	 *params = (GLfloat) ctx->Unpack.Alignment;
	 break;
      case GL_UNPACK_LSB_FIRST:
	 *params = (GLfloat) ctx->Unpack.LsbFirst;
	 break;
      case GL_UNPACK_ROW_LENGTH:
	 *params = (GLfloat) ctx->Unpack.RowLength;
	 break;
      case GL_UNPACK_SKIP_PIXELS:
	 *params = (GLfloat) ctx->Unpack.SkipPixels;
	 break;
      case GL_UNPACK_SKIP_ROWS:
	 *params = (GLfloat) ctx->Unpack.SkipRows;
	 break;
      case GL_UNPACK_SWAP_BYTES:
	 *params = (GLfloat) ctx->Unpack.SwapBytes;
	 break;
      case GL_UNPACK_SKIP_IMAGES_EXT:
         *params = (GLfloat) ctx->Unpack.SkipImages;
         break;
      case GL_UNPACK_IMAGE_HEIGHT_EXT:
         *params = (GLfloat) ctx->Unpack.ImageHeight;
         break;
      case GL_VIEWPORT:
	 params[0] = (GLfloat) ctx->Viewport.X;
	 params[1] = (GLfloat) ctx->Viewport.Y;
	 params[2] = (GLfloat) ctx->Viewport.Width;
	 params[3] = (GLfloat) ctx->Viewport.Height;
	 break;
      case GL_ZOOM_X:
	 *params = (GLfloat) ctx->Pixel.ZoomX;
	 break;
      case GL_ZOOM_Y:
	 *params = (GLfloat) ctx->Pixel.ZoomY;
	 break;
      case GL_VERTEX_ARRAY:
#ifdef VAO
         *params = (GLfloat) ctx->Array.Current->Vertex.Enabled;
#else
         *params = (GLfloat) ctx->Array.Vertex.Enabled;
#endif
         break;
      case GL_VERTEX_ARRAY_SIZE:
#ifdef VAO
         *params = (GLfloat) ctx->Array.Current->Vertex.Size;
#else
         *params = (GLfloat) ctx->Array.Vertex.Size;
#endif
         break;
      case GL_VERTEX_ARRAY_TYPE:
#ifdef VAO
         *params = ENUM_TO_FLOAT(ctx->Array.Current->Vertex.Type);
#else
         *params = ENUM_TO_FLOAT(ctx->Array.Vertex.Type);
#endif
         break;
      case GL_VERTEX_ARRAY_STRIDE:
#ifdef VAO
         *params = (GLfloat) ctx->Array.Current->Vertex.Stride;
#else
         *params = (GLfloat) ctx->Array.Vertex.Stride;
#endif
         break;
      case GL_VERTEX_ARRAY_COUNT_EXT:
         *params = 0.0;
         break;
      case GL_NORMAL_ARRAY:
#ifdef VAO
         *params = (GLfloat) ctx->Array.Current->Normal.Enabled;
#else
         *params = (GLfloat) ctx->Array.Normal.Enabled;
#endif
         break;
      case GL_NORMAL_ARRAY_TYPE:
#ifdef VAO
         *params = ENUM_TO_FLOAT(ctx->Array.Current->Normal.Type);
#else
         *params = ENUM_TO_FLOAT(ctx->Array.Normal.Type);
#endif
         break;
      case GL_NORMAL_ARRAY_STRIDE:
#ifdef VAO
         *params = (GLfloat) ctx->Array.Current->Normal.Stride;
#else
         *params = (GLfloat) ctx->Array.Normal.Stride;
#endif
         break;
      case GL_NORMAL_ARRAY_COUNT_EXT:
         *params = 0.0;
         break;
      case GL_COLOR_ARRAY:
#ifdef VAO
         *params = (GLfloat) ctx->Array.Current->Color.Enabled;
#else
         *params = (GLfloat) ctx->Array.Color.Enabled;
#endif
         break;
      case GL_COLOR_ARRAY_SIZE:
#ifdef VAO
         *params = (GLfloat) ctx->Array.Current->Color.Size;
#else
         *params = (GLfloat) ctx->Array.Color.Size;
#endif
         break;
      case GL_COLOR_ARRAY_TYPE:
#ifdef VAO
         *params = ENUM_TO_FLOAT(ctx->Array.Current->Color.Type);
#else
         *params = ENUM_TO_FLOAT(ctx->Array.Color.Type);
#endif
         break;
      case GL_COLOR_ARRAY_STRIDE:
#ifdef VAO
         *params = (GLfloat) ctx->Array.Current->Color.Stride;
#else
         *params = (GLfloat) ctx->Array.Color.Stride;
#endif
         break;
      case GL_COLOR_ARRAY_COUNT_EXT:
         *params = 0.0;
         break;
      case GL_INDEX_ARRAY:
#ifdef VAO
         *params = (GLfloat) ctx->Array.Current->Index.Enabled;
#else
         *params = (GLfloat) ctx->Array.Index.Enabled;
#endif
         break;
      case GL_INDEX_ARRAY_TYPE:
#ifdef VAO
         *params = ENUM_TO_FLOAT(ctx->Array.Current->Index.Type);
#else
         *params = ENUM_TO_FLOAT(ctx->Array.Index.Type);
#endif
         break;
      case GL_INDEX_ARRAY_STRIDE:
#ifdef VAO
         *params = (GLfloat) ctx->Array.Current->Index.Stride;
#else
         *params = (GLfloat) ctx->Array.Index.Stride;
#endif
         break;
      case GL_INDEX_ARRAY_COUNT_EXT:
         *params = 0.0;
         break;
      case GL_TEXTURE_COORD_ARRAY:
#ifdef VAO
         *params = (GLfloat) ctx->Array.Current->TexCoord[texUnit].Enabled;
#else
         *params = (GLfloat) ctx->Array.TexCoord[texUnit].Enabled;
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_SIZE:
#ifdef VAO
         *params = (GLfloat) ctx->Array.Current->TexCoord[texUnit].Size;
#else
         *params = (GLfloat) ctx->Array.TexCoord[texUnit].Size;
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_TYPE:
#ifdef VAO
         *params = ENUM_TO_FLOAT(ctx->Array.Current->TexCoord[texUnit].Type);
#else
         *params = ENUM_TO_FLOAT(ctx->Array.TexCoord[texUnit].Type);
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_STRIDE:
#ifdef VAO
         *params = (GLfloat) ctx->Array.Current->TexCoord[texUnit].Stride;
#else
         *params = (GLfloat) ctx->Array.TexCoord[texUnit].Stride;
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_COUNT_EXT:
         *params = 0.0;
         break;
      case GL_EDGE_FLAG_ARRAY:
#ifdef VAO
         *params = (GLfloat) ctx->Array.Current->EdgeFlag.Enabled;
#else
         *params = (GLfloat) ctx->Array.EdgeFlag.Enabled;
#endif
         break;
      case GL_EDGE_FLAG_ARRAY_STRIDE:
#ifdef VAO
         *params = (GLfloat) ctx->Array.Current->EdgeFlag.Stride;
#else
         *params = (GLfloat) ctx->Array.EdgeFlag.Stride;
#endif
         break;
      case GL_EDGE_FLAG_ARRAY_COUNT_EXT:
         *params = 0.0;
         break;

      /* GL_ARB_multitexture */
      case GL_MAX_TEXTURE_UNITS_ARB:
         *params = (GLfloat) ctx->Const.MaxTextureUnits;
         break;
      case GL_ACTIVE_TEXTURE_ARB:
         *params = (GLfloat) (GL_TEXTURE0_ARB + ctx->Texture.CurrentUnit);
         break;
      case GL_CLIENT_ACTIVE_TEXTURE_ARB:
         *params = (GLfloat) (GL_TEXTURE0_ARB + ctx->Array.ActiveTexture);
         break;

      /* GL_ARB_texture_cube_map */
      case GL_TEXTURE_CUBE_MAP_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            *params = (GLfloat) _mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB);
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetFloatv");
         return;
      case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            *params = (GLfloat) textureUnit->CurrentCubeMap->Name;
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetFloatv");
         return;
      case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            *params = (GLfloat) ctx->Const.MaxCubeTextureSize;
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetFloatv");
         return;

      /* GL_ARB_texture_compression */
      case GL_TEXTURE_COMPRESSION_HINT_ARB:
         if (ctx->Extensions.HaveTextureCompression) {
            *params = (GLfloat) ctx->Hint.TextureCompression;
         }
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetFloatv");
         break;
      case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:
         if (ctx->Extensions.HaveTextureCompression) {
            *params = (GLfloat) ctx->Const.NumCompressedTextureFormats;
         }
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetFloatv");
         break;
      case GL_COMPRESSED_TEXTURE_FORMATS_ARB:
         if (ctx->Extensions.HaveTextureCompression) {
            GLuint i;
            for (i = 0; i < ctx->Const.NumCompressedTextureFormats; i++)
               params[i] = (GLfloat) ctx->Const.CompressedTextureFormats[i];
         }
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetFloatv");
         break;

      /* GL_PGI_misc_hints */
      case GL_STRICT_DEPTHFUNC_HINT_PGI:
	 *params = ENUM_TO_FLOAT(GL_NICEST);
         break;
      case GL_STRICT_LIGHTING_HINT_PGI:
	 *params = ENUM_TO_FLOAT(ctx->Hint.StrictLighting);
	 break;
      case GL_STRICT_SCISSOR_HINT_PGI:
      case GL_FULL_STIPPLE_HINT_PGI:
	 *params = ENUM_TO_FLOAT(GL_TRUE);
	 break;
      case GL_CONSERVE_MEMORY_HINT_PGI:
	 *params = ENUM_TO_FLOAT(GL_FALSE);
	 break;
      case GL_ALWAYS_FAST_HINT_PGI:
	 *params = (GLfloat) (ctx->Hint.AllowDrawWin == GL_TRUE &&
			      ctx->Hint.AllowDrawFrg == GL_FALSE && 
			      ctx->Hint.AllowDrawMem == GL_FALSE);
	 break;
      case GL_ALWAYS_SOFT_HINT_PGI:
	 *params = (GLfloat) (ctx->Hint.AllowDrawWin == GL_TRUE &&
			      ctx->Hint.AllowDrawFrg == GL_TRUE && 
			      ctx->Hint.AllowDrawMem == GL_TRUE);
	 break;
      case GL_ALLOW_DRAW_OBJ_HINT_PGI:
	 *params = (GLfloat) GL_TRUE;
	 break;
      case GL_ALLOW_DRAW_WIN_HINT_PGI:
	 *params = (GLfloat) ctx->Hint.AllowDrawWin;
	 break;
      case GL_ALLOW_DRAW_FRG_HINT_PGI:
	 *params = (GLfloat) ctx->Hint.AllowDrawFrg;
	 break;
      case GL_ALLOW_DRAW_MEM_HINT_PGI:
	 *params = (GLfloat) ctx->Hint.AllowDrawMem;
	 break;
      case GL_CLIP_NEAR_HINT_PGI:
      case GL_CLIP_FAR_HINT_PGI:
	 *params = ENUM_TO_FLOAT(GL_TRUE);
	 break;
      case GL_WIDE_LINE_HINT_PGI:
	 *params = ENUM_TO_FLOAT(GL_DONT_CARE);
	 break;
      case GL_BACK_NORMALS_HINT_PGI:
	 *params = ENUM_TO_FLOAT(GL_TRUE);
	 break;
      case GL_NATIVE_GRAPHICS_HANDLE_PGI:
	 *params = 0;
	 break;

      /* GL_EXT_compiled_vertex_array */
      case GL_ARRAY_ELEMENT_LOCK_FIRST_EXT:
#ifdef VAO
	 *params = (GLfloat) ctx->Array.Current->LockFirst;
#else
	 *params = (GLfloat) ctx->Array.LockFirst;
#endif
	 break;
      case GL_ARRAY_ELEMENT_LOCK_COUNT_EXT:
#ifdef VAO
	 *params = (GLfloat) ctx->Array.Current->LockCount;
#else
	 *params = (GLfloat) ctx->Array.LockCount;
#endif
	 break;

      /* GL_ARB_transpose_matrix */
      case GL_TRANSPOSE_COLOR_MATRIX_ARB:
         gl_matrix_transposef(params, ctx->ColorMatrix.m);
         break;
      case GL_TRANSPOSE_MODELVIEW_MATRIX_ARB:
         gl_matrix_transposef(params, ctx->ModelView.m);
         break;
      case GL_TRANSPOSE_PROJECTION_MATRIX_ARB:
         gl_matrix_transposef(params, ctx->ProjectionMatrix.m);
         break;
      case GL_TRANSPOSE_TEXTURE_MATRIX_ARB:
         gl_matrix_transposef(params, ctx->TextureMatrix[texTransformUnit].m);
         break;

      /* GL_HP_occlusion_test */
      case GL_OCCLUSION_TEST_HP:
         if (ctx->Extensions.HaveHpOcclusionTest) {
            *params = (GLfloat) ctx->Depth.OcclusionTest;
         }
         else {
            gl_error( ctx, GL_INVALID_ENUM, "glGetFloatv" );
         }
         return;
      case GL_OCCLUSION_TEST_RESULT_HP:
         if (ctx->Extensions.HaveHpOcclusionTest) {
            if (ctx->Depth.OcclusionTest)
               *params = (GLfloat) ctx->OcclusionResult;
            else
               *params = (GLfloat) ctx->OcclusionResultSaved;
            /* reset flag now */
            ctx->OcclusionResult = GL_FALSE;
            ctx->OcclusionResultSaved = GL_FALSE;
         }
         else {
            gl_error( ctx, GL_INVALID_ENUM, "glGetFloatv" );
         }
         return;

      /* GL_SGIS_pixel_texture */
      case GL_PIXEL_TEXTURE_SGIS:
         *params = (GLfloat) ctx->Pixel.PixelTextureEnabled;
         break;

      /* GL_SGIX_pixel_texture */
      case GL_PIXEL_TEX_GEN_SGIX:
         *params = (GLfloat) ctx->Pixel.PixelTextureEnabled;
         break;
      case GL_PIXEL_TEX_GEN_MODE_SGIX:
         *params = (GLfloat) pixel_texgen_mode(ctx);
         break;

      /* GL_SGI_color_matrix (also in 1.2 imaging) */
      case GL_COLOR_MATRIX_SGI:
         for (i=0;i<16;i++) {
	    params[i] = ctx->ColorMatrix.m[i];
	 }
	 break;
      case GL_COLOR_MATRIX_STACK_DEPTH_SGI:
         *params = (GLfloat) (ctx->ColorStackDepth + 1);
         break;
      case GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI:
         *params = (GLfloat) MAX_COLOR_STACK_DEPTH;
         break;
      case GL_POST_COLOR_MATRIX_RED_SCALE_SGI:
         *params = ctx->Pixel.PostColorMatrixScale[0];
         break;
      case GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI:
         *params = ctx->Pixel.PostColorMatrixScale[1];
         break;
      case GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI:
         *params = ctx->Pixel.PostColorMatrixScale[2];
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI:
         *params = ctx->Pixel.PostColorMatrixScale[3];
         break;
      case GL_POST_COLOR_MATRIX_RED_BIAS_SGI:
         *params = ctx->Pixel.PostColorMatrixBias[0];
         break;
      case GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI:
         *params = ctx->Pixel.PostColorMatrixBias[1];
         break;
      case GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI:
         *params = ctx->Pixel.PostColorMatrixBias[2];
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI:
         *params = ctx->Pixel.PostColorMatrixBias[3];
         break;

      /* GL_EXT_convolution (also in 1.2 imaging) */
      case GL_MAX_CONVOLUTION_WIDTH:
         *params = (GLfloat) ctx->Const.MaxConvolutionWidth;
         break;
      case GL_MAX_CONVOLUTION_HEIGHT:
         *params = (GLfloat) ctx->Const.MaxConvolutionHeight;
         break;
      case GL_POST_CONVOLUTION_RED_SCALE_EXT:
         *params = ctx->Pixel.PostConvolutionScale[0];
         break;
      case GL_POST_CONVOLUTION_GREEN_SCALE_EXT:
         *params = ctx->Pixel.PostConvolutionScale[1];
         break;
      case GL_POST_CONVOLUTION_BLUE_SCALE_EXT:
         *params = ctx->Pixel.PostConvolutionScale[2];
         break;
      case GL_POST_CONVOLUTION_ALPHA_SCALE_EXT:
         *params = ctx->Pixel.PostConvolutionScale[3];
         break;
      case GL_POST_CONVOLUTION_RED_BIAS_EXT:
         *params = ctx->Pixel.PostConvolutionBias[0];
         break;
      case GL_POST_CONVOLUTION_GREEN_BIAS_EXT:
         *params = ctx->Pixel.PostConvolutionBias[1];
         break;
      case GL_POST_CONVOLUTION_BLUE_BIAS_EXT:
         *params = ctx->Pixel.PostConvolutionBias[2];
         break;
      case GL_POST_CONVOLUTION_ALPHA_BIAS_EXT:
         *params = ctx->Pixel.PostConvolutionBias[2];
         break;

      /* GL_SGI_color_table (also in 1.2 imaging */
      case GL_COLOR_TABLE_SGI:
         *params = (GLfloat) ctx->Pixel.ColorTableEnabled;
         break;
      case GL_POST_CONVOLUTION_COLOR_TABLE_SGI:
         *params = (GLfloat) ctx->Pixel.PostConvolutionColorTableEnabled;
         break;
      case GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI:
         *params = (GLfloat) ctx->Pixel.PostColorMatrixColorTableEnabled;
         break;

      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetFloatv" );
   }
}




void
_mesa_GetIntegerv( GLenum pname, GLint *params )
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint i;
   GLuint texUnit = ctx->Texture.CurrentUnit;
   GLuint texTransformUnit = ctx->Texture.CurrentTransformUnit;
   const struct gl_texture_unit *textureUnit = &ctx->Texture.Unit[texUnit];

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetIntegerv");

   if (!params)
      return;

   if (MESA_VERBOSE & VERBOSE_API) 
      fprintf(stderr, "glGetIntegerv %s\n", gl_lookup_enum_by_nr(pname));

   if (ctx->Driver.GetIntegerv
       && (*ctx->Driver.GetIntegerv)(ctx, pname, params))
      return;

   switch (pname) {
      case GL_ACCUM_RED_BITS:
         *params = (GLint) ctx->Visual->AccumRedBits;
         break;
      case GL_ACCUM_GREEN_BITS:
         *params = (GLint) ctx->Visual->AccumGreenBits;
         break;
      case GL_ACCUM_BLUE_BITS:
         *params = (GLint) ctx->Visual->AccumBlueBits;
         break;
      case GL_ACCUM_ALPHA_BITS:
         *params = (GLint) ctx->Visual->AccumAlphaBits;
         break;
      case GL_ACCUM_CLEAR_VALUE:
         params[0] = FLOAT_TO_INT( ctx->Accum.ClearColor[0] );
         params[1] = FLOAT_TO_INT( ctx->Accum.ClearColor[1] );
         params[2] = FLOAT_TO_INT( ctx->Accum.ClearColor[2] );
         params[3] = FLOAT_TO_INT( ctx->Accum.ClearColor[3] );
         break;
      case GL_ALPHA_BIAS:
         *params = (GLint) ctx->Pixel.AlphaBias;
         break;
      case GL_ALPHA_BITS:
         *params = ctx->Visual->AlphaBits;
         break;
      case GL_ALPHA_SCALE:
         *params = (GLint) ctx->Pixel.AlphaScale;
         break;
      case GL_ALPHA_TEST:
         *params = (GLint) ctx->Color.AlphaEnabled;
         break;
      case GL_ALPHA_TEST_REF:
         *params = FLOAT_TO_INT( (GLfloat) ctx->Color.AlphaRef / 255.0 );
         break;
      case GL_ALPHA_TEST_FUNC:
         *params = (GLint) ctx->Color.AlphaFunc;
         break;
      case GL_ATTRIB_STACK_DEPTH:
         *params = (GLint) (ctx->AttribStackDepth);
         break;
      case GL_AUTO_NORMAL:
         *params = (GLint) ctx->Eval.AutoNormal;
         break;
      case GL_AUX_BUFFERS:
         *params = (GLint) ctx->Const.NumAuxBuffers;
         break;
      case GL_BLEND:
         *params = (GLint) ctx->Color.BlendEnabled;
         break;
      case GL_BLEND_DST:
         *params = (GLint) ctx->Color.BlendDstRGB;
         break;
      case GL_BLEND_SRC:
         *params = (GLint) ctx->Color.BlendSrcRGB;
         break;
      case GL_BLEND_SRC_RGB_EXT:
         *params = (GLint) ctx->Color.BlendSrcRGB;
         break;
      case GL_BLEND_DST_RGB_EXT:
         *params = (GLint) ctx->Color.BlendDstRGB;
         break;
      case GL_BLEND_SRC_ALPHA_EXT:
         *params = (GLint) ctx->Color.BlendSrcA;
         break;
      case GL_BLEND_DST_ALPHA_EXT:
         *params = (GLint) ctx->Color.BlendDstA;
         break;
      case GL_BLEND_EQUATION_EXT:
	 *params = (GLint) ctx->Color.BlendEquation;
	 break;
      case GL_BLEND_COLOR_EXT:
	 params[0] = FLOAT_TO_INT( ctx->Color.BlendColor[0] );
	 params[1] = FLOAT_TO_INT( ctx->Color.BlendColor[1] );
	 params[2] = FLOAT_TO_INT( ctx->Color.BlendColor[2] );
	 params[3] = FLOAT_TO_INT( ctx->Color.BlendColor[3] );
	 break;
      case GL_BLUE_BIAS:
         *params = (GLint) ctx->Pixel.BlueBias;
         break;
      case GL_BLUE_BITS:
         *params = (GLint) ctx->Visual->BlueBits;
         break;
      case GL_BLUE_SCALE:
         *params = (GLint) ctx->Pixel.BlueScale;
         break;
      case GL_CLIENT_ATTRIB_STACK_DEPTH:
         *params = (GLint) (ctx->ClientAttribStackDepth);
         break;
      case GL_CLIP_PLANE0:
      case GL_CLIP_PLANE1:
      case GL_CLIP_PLANE2:
      case GL_CLIP_PLANE3:
      case GL_CLIP_PLANE4:
      case GL_CLIP_PLANE5:
         i = (GLint) (pname - GL_CLIP_PLANE0);
         *params = (GLint) ctx->Transform.ClipEnabled[i];
         break;
      case GL_COLOR_CLEAR_VALUE:
         params[0] = FLOAT_TO_INT( ctx->Color.ClearColor[0] );
         params[1] = FLOAT_TO_INT( ctx->Color.ClearColor[1] );
         params[2] = FLOAT_TO_INT( ctx->Color.ClearColor[2] );
         params[3] = FLOAT_TO_INT( ctx->Color.ClearColor[3] );
         break;
      case GL_COLOR_MATERIAL:
         *params = (GLint) ctx->Light.ColorMaterialEnabled;
         break;
      case GL_COLOR_MATERIAL_FACE:
         *params = (GLint) ctx->Light.ColorMaterialFace;
         break;
      case GL_COLOR_MATERIAL_PARAMETER:
         *params = (GLint) ctx->Light.ColorMaterialMode;
         break;
      case GL_COLOR_WRITEMASK:
         params[0] = ctx->Color.ColorMask[RCOMP] ? 1 : 0;
         params[1] = ctx->Color.ColorMask[GCOMP] ? 1 : 0;
         params[2] = ctx->Color.ColorMask[BCOMP] ? 1 : 0;
         params[3] = ctx->Color.ColorMask[ACOMP] ? 1 : 0;
         break;
      case GL_CULL_FACE:
         *params = (GLint) ctx->Polygon.CullFlag;
         break;
      case GL_CULL_FACE_MODE:
         *params = (GLint) ctx->Polygon.CullFaceMode;
         break;
      case GL_CURRENT_COLOR:
         params[0] = FLOAT_TO_INT( UBYTE_COLOR_TO_FLOAT_COLOR( ctx->Current.ByteColor[0] ) );
         params[1] = FLOAT_TO_INT( UBYTE_COLOR_TO_FLOAT_COLOR( ctx->Current.ByteColor[1] ) );
         params[2] = FLOAT_TO_INT( UBYTE_COLOR_TO_FLOAT_COLOR( ctx->Current.ByteColor[2] ) );
         params[3] = FLOAT_TO_INT( UBYTE_COLOR_TO_FLOAT_COLOR( ctx->Current.ByteColor[3] ) );
         break;
      case GL_CURRENT_INDEX:
         *params = (GLint) ctx->Current.Index;
         break;
      case GL_CURRENT_NORMAL:
         params[0] = FLOAT_TO_INT( ctx->Current.Normal[0] );
         params[1] = FLOAT_TO_INT( ctx->Current.Normal[1] );
         params[2] = FLOAT_TO_INT( ctx->Current.Normal[2] );
         break;
      case GL_CURRENT_RASTER_COLOR:
	 params[0] = FLOAT_TO_INT( ctx->Current.RasterColor[0] );
	 params[1] = FLOAT_TO_INT( ctx->Current.RasterColor[1] );
	 params[2] = FLOAT_TO_INT( ctx->Current.RasterColor[2] );
	 params[3] = FLOAT_TO_INT( ctx->Current.RasterColor[3] );
	 break;
      case GL_CURRENT_RASTER_DISTANCE:
	 params[0] = (GLint) ctx->Current.RasterDistance;
	 break;
      case GL_CURRENT_RASTER_INDEX:
	 *params = (GLint) ctx->Current.RasterIndex;
	 break;
      case GL_CURRENT_RASTER_POSITION:
	 params[0] = (GLint) ctx->Current.RasterPos[0];
	 params[1] = (GLint) ctx->Current.RasterPos[1];
	 params[2] = (GLint) ctx->Current.RasterPos[2];
	 params[3] = (GLint) ctx->Current.RasterPos[3];
	 break;
      case GL_CURRENT_RASTER_TEXTURE_COORDS:
	 params[0] = (GLint) ctx->Current.RasterMultiTexCoord[texTransformUnit][0];
	 params[1] = (GLint) ctx->Current.RasterMultiTexCoord[texTransformUnit][1];
	 params[2] = (GLint) ctx->Current.RasterMultiTexCoord[texTransformUnit][2];
	 params[3] = (GLint) ctx->Current.RasterMultiTexCoord[texTransformUnit][3];
	 break;
      case GL_CURRENT_RASTER_POSITION_VALID:
	 *params = (GLint) ctx->Current.RasterPosValid;
	 break;
      case GL_CURRENT_TEXTURE_COORDS:
         params[0] = (GLint) ctx->Current.Texcoord[texTransformUnit][0];
         params[1] = (GLint) ctx->Current.Texcoord[texTransformUnit][1];
         params[2] = (GLint) ctx->Current.Texcoord[texTransformUnit][2];
         params[3] = (GLint) ctx->Current.Texcoord[texTransformUnit][3];
	 break;
      case GL_DEPTH_BIAS:
         *params = (GLint) ctx->Pixel.DepthBias;
	 break;
      case GL_DEPTH_BITS:
	 *params = ctx->Visual->DepthBits;
	 break;
      case GL_DEPTH_CLEAR_VALUE:
         *params = (GLint) ctx->Depth.Clear;
	 break;
      case GL_DEPTH_FUNC:
         *params = (GLint) ctx->Depth.Func;
	 break;
      case GL_DEPTH_RANGE:
         params[0] = (GLint) ctx->Viewport.Near;
         params[1] = (GLint) ctx->Viewport.Far;
	 break;
      case GL_DEPTH_SCALE:
         *params = (GLint) ctx->Pixel.DepthScale;
	 break;
      case GL_DEPTH_TEST:
         *params = (GLint) ctx->Depth.Test;
	 break;
      case GL_DEPTH_WRITEMASK:
	 *params = (GLint) ctx->Depth.Mask;
	 break;
      case GL_DITHER:
	 *params = (GLint) ctx->Color.DitherFlag;
	 break;
      case GL_DOUBLEBUFFER:
	 *params = (GLint) ctx->Visual->DBflag;
	 break;
      case GL_DRAW_BUFFER:
	 *params = (GLint) ctx->Color.DrawBuffer;
	 break;
      case GL_EDGE_FLAG:
	 *params = (GLint) ctx->Current.EdgeFlag;
	 break;
      case GL_FEEDBACK_BUFFER_SIZE:
         *params = ctx->Feedback.BufferSize;
         break;
      case GL_FEEDBACK_BUFFER_TYPE:
         *params = ctx->Feedback.Type;
         break;
      case GL_FOG:
	 *params = (GLint) ctx->Fog.Enabled;
	 break;
      case GL_FOG_COLOR:
	 params[0] = FLOAT_TO_INT( ctx->Fog.Color[0] );
	 params[1] = FLOAT_TO_INT( ctx->Fog.Color[1] );
	 params[2] = FLOAT_TO_INT( ctx->Fog.Color[2] );
	 params[3] = FLOAT_TO_INT( ctx->Fog.Color[3] );
	 break;
      case GL_FOG_DENSITY:
	 *params = (GLint) ctx->Fog.Density;
	 break;
      case GL_FOG_END:
	 *params = (GLint) ctx->Fog.End;
	 break;
      case GL_FOG_HINT:
	 *params = (GLint) ctx->Hint.Fog;
	 break;
      case GL_FOG_INDEX:
	 *params = (GLint) ctx->Fog.Index;
	 break;
      case GL_FOG_MODE:
	 *params = (GLint) ctx->Fog.Mode;
	 break;
      case GL_FOG_START:
	 *params = (GLint) ctx->Fog.Start;
	 break;
      case GL_FRONT_FACE:
	 *params = (GLint) ctx->Polygon.FrontFace;
	 break;
      case GL_GREEN_BIAS:
         *params = (GLint) ctx->Pixel.GreenBias;
         break;
      case GL_GREEN_BITS:
         *params = (GLint) ctx->Visual->GreenBits;
         break;
      case GL_GREEN_SCALE:
         *params = (GLint) ctx->Pixel.GreenScale;
         break;
      case GL_HISTOGRAM:
         *params = (GLint) ctx->Pixel.HistogramEnabled;
	 break;
      case GL_INDEX_BITS:
         *params = (GLint) ctx->Visual->IndexBits;
         break;
      case GL_INDEX_CLEAR_VALUE:
         *params = (GLint) ctx->Color.ClearIndex;
         break;
      case GL_INDEX_MODE:
	 *params = ctx->Visual->RGBAflag ? 0 : 1;
	 break;
      case GL_INDEX_OFFSET:
	 *params = ctx->Pixel.IndexOffset;
	 break;
      case GL_INDEX_SHIFT:
	 *params = ctx->Pixel.IndexShift;
	 break;
      case GL_INDEX_WRITEMASK:
	 *params = (GLint) ctx->Color.IndexMask;
	 break;
      case GL_LIGHT0:
      case GL_LIGHT1:
      case GL_LIGHT2:
      case GL_LIGHT3:
      case GL_LIGHT4:
      case GL_LIGHT5:
      case GL_LIGHT6:
      case GL_LIGHT7:
	 *params = (GLint) ctx->Light.Light[pname-GL_LIGHT0].Enabled;
	 break;
      case GL_LIGHTING:
	 *params = (GLint) ctx->Light.Enabled;
	 break;
      case GL_LIGHT_MODEL_AMBIENT:
	 params[0] = FLOAT_TO_INT( ctx->Light.Model.Ambient[0] );
	 params[1] = FLOAT_TO_INT( ctx->Light.Model.Ambient[1] );
	 params[2] = FLOAT_TO_INT( ctx->Light.Model.Ambient[2] );
	 params[3] = FLOAT_TO_INT( ctx->Light.Model.Ambient[3] );
	 break;
      case GL_LIGHT_MODEL_COLOR_CONTROL:
         params[0] = (GLint) ctx->Light.Model.ColorControl;
         break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
	 *params = (GLint) ctx->Light.Model.LocalViewer;
	 break;
      case GL_LIGHT_MODEL_TWO_SIDE:
	 *params = (GLint) ctx->Light.Model.TwoSide;
	 break;
      case GL_LINE_SMOOTH:
	 *params = (GLint) ctx->Line.SmoothFlag;
	 break;
      case GL_LINE_SMOOTH_HINT:
	 *params = (GLint) ctx->Hint.LineSmooth;
	 break;
      case GL_LINE_STIPPLE:
	 *params = (GLint) ctx->Line.StippleFlag;
	 break;
      case GL_LINE_STIPPLE_PATTERN:
         *params = (GLint) ctx->Line.StipplePattern;
         break;
      case GL_LINE_STIPPLE_REPEAT:
         *params = (GLint) ctx->Line.StippleFactor;
         break;
      case GL_LINE_WIDTH:
	 *params = (GLint) ctx->Line.Width;
	 break;
      case GL_LINE_WIDTH_GRANULARITY:
	 *params = (GLint) ctx->Const.LineWidthGranularity;
	 break;
      case GL_LINE_WIDTH_RANGE:
	 params[0] = (GLint) ctx->Const.MinLineWidthAA;
	 params[1] = (GLint) ctx->Const.MaxLineWidthAA;
	 break;
      case GL_ALIASED_LINE_WIDTH_RANGE:
	 params[0] = (GLint) ctx->Const.MinLineWidth;
	 params[1] = (GLint) ctx->Const.MaxLineWidth;
	 break;
      case GL_LIST_BASE:
	 *params = (GLint) ctx->List.ListBase;
	 break;
      case GL_LIST_INDEX:
	 *params = (GLint) ctx->CurrentListNum;
	 break;
      case GL_LIST_MODE:
	 *params = ctx->ExecuteFlag ? (GLint) GL_COMPILE_AND_EXECUTE
	   			  : (GLint) GL_COMPILE;
	 break;
      case GL_INDEX_LOGIC_OP:
	 *params = (GLint) ctx->Color.IndexLogicOpEnabled;
	 break;
      case GL_COLOR_LOGIC_OP:
	 *params = (GLint) ctx->Color.ColorLogicOpEnabled;
	 break;
      case GL_LOGIC_OP_MODE:
         *params = (GLint) ctx->Color.LogicOp;
         break;
      case GL_MAP1_COLOR_4:
	 *params = (GLint) ctx->Eval.Map1Color4;
	 break;
      case GL_MAP1_GRID_DOMAIN:
	 params[0] = (GLint) ctx->Eval.MapGrid1u1;
	 params[1] = (GLint) ctx->Eval.MapGrid1u2;
	 break;
      case GL_MAP1_GRID_SEGMENTS:
	 *params = (GLint) ctx->Eval.MapGrid1un;
	 break;
      case GL_MAP1_INDEX:
	 *params = (GLint) ctx->Eval.Map1Index;
	 break;
      case GL_MAP1_NORMAL:
	 *params = (GLint) ctx->Eval.Map1Normal;
	 break;
      case GL_MAP1_TEXTURE_COORD_1:
	 *params = (GLint) ctx->Eval.Map1TextureCoord1;
	 break;
      case GL_MAP1_TEXTURE_COORD_2:
	 *params = (GLint) ctx->Eval.Map1TextureCoord2;
	 break;
      case GL_MAP1_TEXTURE_COORD_3:
	 *params = (GLint) ctx->Eval.Map1TextureCoord3;
	 break;
      case GL_MAP1_TEXTURE_COORD_4:
	 *params = (GLint) ctx->Eval.Map1TextureCoord4;
	 break;
      case GL_MAP1_VERTEX_3:
	 *params = (GLint) ctx->Eval.Map1Vertex3;
	 break;
      case GL_MAP1_VERTEX_4:
	 *params = (GLint) ctx->Eval.Map1Vertex4;
	 break;
      case GL_MAP2_COLOR_4:
	 *params = (GLint) ctx->Eval.Map2Color4;
	 break;
      case GL_MAP2_GRID_DOMAIN:
	 params[0] = (GLint) ctx->Eval.MapGrid2u1;
	 params[1] = (GLint) ctx->Eval.MapGrid2u2;
	 params[2] = (GLint) ctx->Eval.MapGrid2v1;
	 params[3] = (GLint) ctx->Eval.MapGrid2v2;
	 break;
      case GL_MAP2_GRID_SEGMENTS:
	 params[0] = (GLint) ctx->Eval.MapGrid2un;
	 params[1] = (GLint) ctx->Eval.MapGrid2vn;
	 break;
      case GL_MAP2_INDEX:
	 *params = (GLint) ctx->Eval.Map2Index;
	 break;
      case GL_MAP2_NORMAL:
	 *params = (GLint) ctx->Eval.Map2Normal;
	 break;
      case GL_MAP2_TEXTURE_COORD_1:
	 *params = (GLint) ctx->Eval.Map2TextureCoord1;
	 break;
      case GL_MAP2_TEXTURE_COORD_2:
	 *params = (GLint) ctx->Eval.Map2TextureCoord2;
	 break;
      case GL_MAP2_TEXTURE_COORD_3:
	 *params = (GLint) ctx->Eval.Map2TextureCoord3;
	 break;
      case GL_MAP2_TEXTURE_COORD_4:
	 *params = (GLint) ctx->Eval.Map2TextureCoord4;
	 break;
      case GL_MAP2_VERTEX_3:
	 *params = (GLint) ctx->Eval.Map2Vertex3;
	 break;
      case GL_MAP2_VERTEX_4:
	 *params = (GLint) ctx->Eval.Map2Vertex4;
	 break;
      case GL_MAP_COLOR:
	 *params = (GLint) ctx->Pixel.MapColorFlag;
	 break;
      case GL_MAP_STENCIL:
	 *params = (GLint) ctx->Pixel.MapStencilFlag;
	 break;
      case GL_MATRIX_MODE:
	 *params = (GLint) ctx->Transform.MatrixMode;
	 break;
      case GL_MAX_ATTRIB_STACK_DEPTH:
         *params = (GLint) MAX_ATTRIB_STACK_DEPTH;
         break;
      case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
         *params = (GLint) MAX_CLIENT_ATTRIB_STACK_DEPTH;
         break;
      case GL_MAX_CLIP_PLANES:
         *params = (GLint) MAX_CLIP_PLANES;
         break;
      case GL_MAX_ELEMENTS_VERTICES:  /* GL_VERSION_1_2 */
         *params = VB_MAX;
         break;
      case GL_MAX_ELEMENTS_INDICES:   /* GL_VERSION_1_2 */
         *params = VB_MAX;
         break;
      case GL_MAX_EVAL_ORDER:
	 *params = (GLint) MAX_EVAL_ORDER;
	 break;
      case GL_MAX_LIGHTS:
         *params = (GLint) MAX_LIGHTS;
         break;
      case GL_MAX_LIST_NESTING:
         *params = (GLint) MAX_LIST_NESTING;
         break;
      case GL_MAX_MODELVIEW_STACK_DEPTH:
         *params = (GLint) MAX_MODELVIEW_STACK_DEPTH;
         break;
      case GL_MAX_NAME_STACK_DEPTH:
	 *params = (GLint) MAX_NAME_STACK_DEPTH;
	 break;
      case GL_MAX_PIXEL_MAP_TABLE:
	 *params = (GLint) MAX_PIXEL_MAP_TABLE;
	 break;
      case GL_MAX_PROJECTION_STACK_DEPTH:
         *params = (GLint) MAX_PROJECTION_STACK_DEPTH;
         break;
      case GL_MAX_TEXTURE_SIZE:
      case GL_MAX_3D_TEXTURE_SIZE:
         *params = ctx->Const.MaxTextureSize;
	 break;
      case GL_MAX_TEXTURE_STACK_DEPTH:
	 *params = (GLint) MAX_TEXTURE_STACK_DEPTH;
	 break;
      case GL_MAX_VIEWPORT_DIMS:
         params[0] = (GLint) MAX_WIDTH;
         params[1] = (GLint) MAX_HEIGHT;
         break;
      case GL_MINMAX:
         *params = (GLint) ctx->Pixel.MinMaxEnabled;
         break;
      case GL_MODELVIEW_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = (GLint) ctx->ModelView.m[i];
	 }
	 break;
      case GL_MODELVIEW_STACK_DEPTH:
	 *params = (GLint) (ctx->ModelViewStackDepth + 1);
	 break;
      case GL_NAME_STACK_DEPTH:
	 *params = (GLint) ctx->Select.NameStackDepth;
	 break;
      case GL_NORMALIZE:
	 *params = (GLint) ctx->Transform.Normalize;
	 break;
      case GL_PACK_ALIGNMENT:
	 *params = ctx->Pack.Alignment;
	 break;
      case GL_PACK_LSB_FIRST:
	 *params = (GLint) ctx->Pack.LsbFirst;
	 break;
      case GL_PACK_ROW_LENGTH:
	 *params = ctx->Pack.RowLength;
	 break;
      case GL_PACK_SKIP_PIXELS:
	 *params = ctx->Pack.SkipPixels;
	 break;
      case GL_PACK_SKIP_ROWS:
	 *params = ctx->Pack.SkipRows;
	 break;
      case GL_PACK_SWAP_BYTES:
	 *params = (GLint) ctx->Pack.SwapBytes;
	 break;
      case GL_PACK_SKIP_IMAGES_EXT:
         *params = ctx->Pack.SkipImages;
         break;
      case GL_PACK_IMAGE_HEIGHT_EXT:
         *params = ctx->Pack.ImageHeight;
         break;
      case GL_PERSPECTIVE_CORRECTION_HINT:
	 *params = (GLint) ctx->Hint.PerspectiveCorrection;
	 break;
      case GL_PIXEL_MAP_A_TO_A_SIZE:
	 *params = ctx->Pixel.MapAtoAsize;
	 break;
      case GL_PIXEL_MAP_B_TO_B_SIZE:
	 *params = ctx->Pixel.MapBtoBsize;
	 break;
      case GL_PIXEL_MAP_G_TO_G_SIZE:
	 *params = ctx->Pixel.MapGtoGsize;
	 break;
      case GL_PIXEL_MAP_I_TO_A_SIZE:
	 *params = ctx->Pixel.MapItoAsize;
	 break;
      case GL_PIXEL_MAP_I_TO_B_SIZE:
	 *params = ctx->Pixel.MapItoBsize;
	 break;
      case GL_PIXEL_MAP_I_TO_G_SIZE:
	 *params = ctx->Pixel.MapItoGsize;
	 break;
      case GL_PIXEL_MAP_I_TO_I_SIZE:
	 *params = ctx->Pixel.MapItoIsize;
	 break;
      case GL_PIXEL_MAP_I_TO_R_SIZE:
	 *params = ctx->Pixel.MapItoRsize;
	 break;
      case GL_PIXEL_MAP_R_TO_R_SIZE:
	 *params = ctx->Pixel.MapRtoRsize;
	 break;
      case GL_PIXEL_MAP_S_TO_S_SIZE:
	 *params = ctx->Pixel.MapStoSsize;
	 break;
      case GL_POINT_SIZE:
         *params = (GLint) ctx->Point.UserSize;
         break;
      case GL_POINT_SIZE_GRANULARITY:
	 *params = (GLint) ctx->Const.PointSizeGranularity;
	 break;
      case GL_POINT_SIZE_RANGE:
	 params[0] = (GLint) ctx->Const.MinPointSizeAA;
	 params[1] = (GLint) ctx->Const.MaxPointSizeAA;
	 break;
      case GL_ALIASED_POINT_SIZE_RANGE:
	 params[0] = (GLint) ctx->Const.MinPointSize;
	 params[1] = (GLint) ctx->Const.MaxPointSize;
	 break;
      case GL_POINT_SMOOTH:
	 *params = (GLint) ctx->Point.SmoothFlag;
	 break;
      case GL_POINT_SMOOTH_HINT:
	 *params = (GLint) ctx->Hint.PointSmooth;
	 break;
      case GL_POINT_SIZE_MIN_EXT:
	 *params = (GLint) (ctx->Point.MinSize);
	 break;
      case GL_POINT_SIZE_MAX_EXT:
	 *params = (GLint) (ctx->Point.MaxSize);
	 break;
      case GL_POINT_FADE_THRESHOLD_SIZE_EXT:
	 *params = (GLint) (ctx->Point.Threshold);
	 break;
      case GL_DISTANCE_ATTENUATION_EXT:
	 params[0] = (GLint) (ctx->Point.Params[0]);
	 params[1] = (GLint) (ctx->Point.Params[1]);
	 params[2] = (GLint) (ctx->Point.Params[2]);
	 break;
      case GL_POLYGON_MODE:
	 params[0] = (GLint) ctx->Polygon.FrontMode;
	 params[1] = (GLint) ctx->Polygon.BackMode;
	 break;
      case GL_POLYGON_OFFSET_BIAS_EXT: /* GL_EXT_polygon_offset */
         *params = (GLint) ctx->Polygon.OffsetUnits;
         break;
      case GL_POLYGON_OFFSET_FACTOR:
         *params = (GLint) ctx->Polygon.OffsetFactor;
         break;
      case GL_POLYGON_OFFSET_UNITS:
         *params = (GLint) ctx->Polygon.OffsetUnits;
         break;
      case GL_POLYGON_SMOOTH:
	 *params = (GLint) ctx->Polygon.SmoothFlag;
	 break;
      case GL_POLYGON_SMOOTH_HINT:
	 *params = (GLint) ctx->Hint.PolygonSmooth;
	 break;
      case GL_POLYGON_STIPPLE:
         *params = (GLint) ctx->Polygon.StippleFlag;
	 break;
      case GL_PROJECTION_MATRIX:
	 for (i=0;i<16;i++) {
	    params[i] = (GLint) ctx->ProjectionMatrix.m[i];
	 }
	 break;
      case GL_PROJECTION_STACK_DEPTH:
	 *params = (GLint) (ctx->ProjectionStackDepth + 1);
	 break;
      case GL_READ_BUFFER:
	 *params = (GLint) ctx->Pixel.ReadBuffer;
	 break;
      case GL_RED_BIAS:
         *params = (GLint) ctx->Pixel.RedBias;
         break;
      case GL_RED_BITS:
         *params = (GLint) ctx->Visual->RedBits;
         break;
      case GL_RED_SCALE:
         *params = (GLint) ctx->Pixel.RedScale;
         break;
      case GL_RENDER_MODE:
	 *params = (GLint) ctx->RenderMode;
	 break;
      case GL_RESCALE_NORMAL:
         *params = (GLint) ctx->Transform.RescaleNormals;
         break;
      case GL_RGBA_MODE:
	 *params = (GLint) ctx->Visual->RGBAflag;
	 break;
      case GL_SCISSOR_BOX:
	 params[0] = (GLint) ctx->Scissor.X;
	 params[1] = (GLint) ctx->Scissor.Y;
	 params[2] = (GLint) ctx->Scissor.Width;
	 params[3] = (GLint) ctx->Scissor.Height;
	 break;
      case GL_SCISSOR_TEST:
	 *params = (GLint) ctx->Scissor.Enabled;
	 break;
      case GL_SELECTION_BUFFER_SIZE:
         *params = (GLint) ctx->Select.BufferSize;
         break;
      case GL_SHADE_MODEL:
	 *params = (GLint) ctx->Light.ShadeModel;
	 break;
      case GL_SHARED_TEXTURE_PALETTE_EXT:
         *params = (GLint) ctx->Texture.SharedPalette;
         break;
      case GL_STENCIL_BITS:
         *params = ctx->Visual->StencilBits;
         break;
      case GL_STENCIL_CLEAR_VALUE:
	 *params = (GLint) ctx->Stencil.Clear;
	 break;
      case GL_STENCIL_FAIL:
	 *params = (GLint) ctx->Stencil.FailFunc;
	 break;
      case GL_STENCIL_FUNC:
	 *params = (GLint) ctx->Stencil.Function;
	 break;
      case GL_STENCIL_PASS_DEPTH_FAIL:
	 *params = (GLint) ctx->Stencil.ZFailFunc;
	 break;
      case GL_STENCIL_PASS_DEPTH_PASS:
	 *params = (GLint) ctx->Stencil.ZPassFunc;
	 break;
      case GL_STENCIL_REF:
	 *params = (GLint) ctx->Stencil.Ref;
	 break;
      case GL_STENCIL_TEST:
	 *params = (GLint) ctx->Stencil.Enabled;
	 break;
      case GL_STENCIL_VALUE_MASK:
	 *params = (GLint) ctx->Stencil.ValueMask;
	 break;
      case GL_STENCIL_WRITEMASK:
	 *params = (GLint) ctx->Stencil.WriteMask;
	 break;
      case GL_STEREO:
	 *params = (GLint) ctx->Visual->StereoFlag;
	 break;
      case GL_SUBPIXEL_BITS:
	 *params = ctx->Const.SubPixelBits;
	 break;
      case GL_TEXTURE_1D:
         *params = _mesa_IsEnabled(GL_TEXTURE_1D) ? 1 : 0;
	 break;
      case GL_TEXTURE_2D:
         *params = _mesa_IsEnabled(GL_TEXTURE_2D) ? 1 : 0;
	 break;
      case GL_TEXTURE_3D:
         *params = _mesa_IsEnabled(GL_TEXTURE_3D) ? 1 : 0;
	 break;
      case GL_TEXTURE_BINDING_1D:
         *params = textureUnit->CurrentD[1]->Name;
          break;
      case GL_TEXTURE_BINDING_2D:
         *params = textureUnit->CurrentD[2]->Name;
          break;
      case GL_TEXTURE_BINDING_3D:
         *params = textureUnit->CurrentD[3]->Name;
          break;
      case GL_TEXTURE_ENV_COLOR:
	 params[0] = FLOAT_TO_INT( textureUnit->EnvColor[0] );
	 params[1] = FLOAT_TO_INT( textureUnit->EnvColor[1] );
	 params[2] = FLOAT_TO_INT( textureUnit->EnvColor[2] );
	 params[3] = FLOAT_TO_INT( textureUnit->EnvColor[3] );
	 break;
      case GL_TEXTURE_ENV_MODE:
	 *params = (GLint) textureUnit->EnvMode;
	 break;
      case GL_TEXTURE_GEN_S:
	 *params = (textureUnit->TexGenEnabled & S_BIT) ? 1 : 0;
	 break;
      case GL_TEXTURE_GEN_T:
	 *params = (textureUnit->TexGenEnabled & T_BIT) ? 1 : 0;
	 break;
      case GL_TEXTURE_GEN_R:
	 *params = (textureUnit->TexGenEnabled & R_BIT) ? 1 : 0;
	 break;
      case GL_TEXTURE_GEN_Q:
	 *params = (textureUnit->TexGenEnabled & Q_BIT) ? 1 : 0;
	 break;
      case GL_TEXTURE_MATRIX:
         for (i=0;i<16;i++) {
	    params[i] = (GLint) ctx->TextureMatrix[texTransformUnit].m[i];
	 }
	 break;
      case GL_TEXTURE_STACK_DEPTH:
	 *params = (GLint) (ctx->TextureStackDepth[texTransformUnit] + 1);
	 break;
      case GL_UNPACK_ALIGNMENT:
	 *params = ctx->Unpack.Alignment;
	 break;
      case GL_UNPACK_LSB_FIRST:
	 *params = (GLint) ctx->Unpack.LsbFirst;
	 break;
      case GL_UNPACK_ROW_LENGTH:
	 *params = ctx->Unpack.RowLength;
	 break;
      case GL_UNPACK_SKIP_PIXELS:
	 *params = ctx->Unpack.SkipPixels;
	 break;
      case GL_UNPACK_SKIP_ROWS:
	 *params = ctx->Unpack.SkipRows;
	 break;
      case GL_UNPACK_SWAP_BYTES:
	 *params = (GLint) ctx->Unpack.SwapBytes;
	 break;
      case GL_UNPACK_SKIP_IMAGES_EXT:
         *params = ctx->Unpack.SkipImages;
         break;
      case GL_UNPACK_IMAGE_HEIGHT_EXT:
         *params = ctx->Unpack.ImageHeight;
         break;
      case GL_VIEWPORT:
         params[0] = (GLint) ctx->Viewport.X;
         params[1] = (GLint) ctx->Viewport.Y;
         params[2] = (GLint) ctx->Viewport.Width;
         params[3] = (GLint) ctx->Viewport.Height;
         break;
      case GL_ZOOM_X:
	 *params = (GLint) ctx->Pixel.ZoomX;
	 break;
      case GL_ZOOM_Y:
	 *params = (GLint) ctx->Pixel.ZoomY;
	 break;
      case GL_VERTEX_ARRAY:
#ifdef VAO
         *params = (GLint) ctx->Array.Current->Vertex.Enabled;
#else
         *params = (GLint) ctx->Array.Vertex.Enabled;
#endif
         break;
      case GL_VERTEX_ARRAY_SIZE:
#ifdef VAO
         *params = ctx->Array.Current->Vertex.Size;
#else
         *params = ctx->Array.Vertex.Size;
#endif
         break;
      case GL_VERTEX_ARRAY_TYPE:
#ifdef VAO
         *params = ctx->Array.Current->Vertex.Type;
#else
         *params = ctx->Array.Vertex.Type;
#endif
         break;
      case GL_VERTEX_ARRAY_STRIDE:
#ifdef VAO
         *params = ctx->Array.Current->Vertex.Stride;
#else
         *params = ctx->Array.Vertex.Stride;
#endif
         break;
      case GL_VERTEX_ARRAY_COUNT_EXT:
         *params = 0;
         break;
      case GL_NORMAL_ARRAY:
#ifdef VAO
         *params = (GLint) ctx->Array.Current->Normal.Enabled;
#else
         *params = (GLint) ctx->Array.Normal.Enabled;
#endif
         break;
      case GL_NORMAL_ARRAY_TYPE:
#ifdef VAO
         *params = ctx->Array.Current->Normal.Type;
#else
         *params = ctx->Array.Normal.Type;
#endif
         break;
      case GL_NORMAL_ARRAY_STRIDE:
#ifdef VAO
         *params = ctx->Array.Current->Normal.Stride;
#else
         *params = ctx->Array.Normal.Stride;
#endif
         break;
      case GL_NORMAL_ARRAY_COUNT_EXT:
         *params = 0;
         break;
      case GL_COLOR_ARRAY:
#ifdef VAO
         *params = (GLint) ctx->Array.Current->Color.Enabled;
#else
         *params = (GLint) ctx->Array.Color.Enabled;
#endif
         break;
      case GL_COLOR_ARRAY_SIZE:
#ifdef VAO
         *params = ctx->Array.Current->Color.Size;
#else
         *params = ctx->Array.Color.Size;
#endif
         break;
      case GL_COLOR_ARRAY_TYPE:
#ifdef VAO
         *params = ctx->Array.Current->Color.Type;
#else
         *params = ctx->Array.Color.Type;
#endif
         break;
      case GL_COLOR_ARRAY_STRIDE:
#ifdef VAO
         *params = ctx->Array.Current->Color.Stride;
#else
         *params = ctx->Array.Color.Stride;
#endif
         break;
      case GL_COLOR_ARRAY_COUNT_EXT:
         *params = 0;
         break;
      case GL_INDEX_ARRAY:
#ifdef VAO
         *params = (GLint) ctx->Array.Current->Index.Enabled;
#else
         *params = (GLint) ctx->Array.Index.Enabled;
#endif
         break;
      case GL_INDEX_ARRAY_TYPE:
#ifdef VAO
         *params = ctx->Array.Current->Index.Type;
#else
         *params = ctx->Array.Index.Type;
#endif
         break;
      case GL_INDEX_ARRAY_STRIDE:
#ifdef VAO
         *params = ctx->Array.Current->Index.Stride;
#else
         *params = ctx->Array.Index.Stride;
#endif
         break;
      case GL_INDEX_ARRAY_COUNT_EXT:
         *params = 0;
         break;
      case GL_TEXTURE_COORD_ARRAY:
#ifdef VAO
         *params = (GLint) ctx->Array.Current->TexCoord[texUnit].Enabled;
#else
         *params = (GLint) ctx->Array.TexCoord[texUnit].Enabled;
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_SIZE:
#ifdef VAO
         *params = ctx->Array.Current->TexCoord[texUnit].Size;
#else
         *params = ctx->Array.TexCoord[texUnit].Size;
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_TYPE:
#ifdef VAO
         *params = ctx->Array.Current->TexCoord[texUnit].Type;
#else
         *params = ctx->Array.TexCoord[texUnit].Type;
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_STRIDE:
#ifdef VAO
         *params = ctx->Array.Current->TexCoord[texUnit].Stride;
#else
         *params = ctx->Array.TexCoord[texUnit].Stride;
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_COUNT_EXT:
         *params = 0;
         break;
      case GL_EDGE_FLAG_ARRAY:
#ifdef VAO
         *params = (GLint) ctx->Array.Current->EdgeFlag.Enabled;
#else
         *params = (GLint) ctx->Array.EdgeFlag.Enabled;
#endif
         break;
      case GL_EDGE_FLAG_ARRAY_STRIDE:
#ifdef VAO
         *params = ctx->Array.Current->EdgeFlag.Stride;
#else
         *params = ctx->Array.EdgeFlag.Stride;
#endif
         break;
      case GL_EDGE_FLAG_ARRAY_COUNT_EXT:
         *params = 0;
         break;

      /* GL_ARB_multitexture */
      case GL_MAX_TEXTURE_UNITS_ARB:
         *params = ctx->Const.MaxTextureUnits;
         break;
      case GL_ACTIVE_TEXTURE_ARB:
         *params = GL_TEXTURE0_ARB + ctx->Texture.CurrentUnit;
         break;
      case GL_CLIENT_ACTIVE_TEXTURE_ARB:
         *params = GL_TEXTURE0_ARB + ctx->Array.ActiveTexture;
         break;

      /* GL_ARB_texture_cube_map */
      case GL_TEXTURE_CUBE_MAP_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            *params = (GLint) _mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB);
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
         return;
      case GL_TEXTURE_BINDING_CUBE_MAP_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            *params = textureUnit->CurrentCubeMap->Name;
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
         return;
      case GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB:
         if (ctx->Extensions.HaveTextureCubeMap)
            *params = ctx->Const.MaxCubeTextureSize;
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
         return;

      /* GL_ARB_texture_compression */
      case GL_TEXTURE_COMPRESSION_HINT_ARB:
         if (ctx->Extensions.HaveTextureCompression) {
            *params = (GLint) ctx->Hint.TextureCompression;
         }
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
         break;
      case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:
         if (ctx->Extensions.HaveTextureCompression) {
            *params = (GLint) ctx->Const.NumCompressedTextureFormats;
         }
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
         break;
      case GL_COMPRESSED_TEXTURE_FORMATS_ARB:
         if (ctx->Extensions.HaveTextureCompression) {
            GLuint i;
            for (i = 0; i < ctx->Const.NumCompressedTextureFormats; i++)
               params[i] = (GLint) ctx->Const.CompressedTextureFormats[i];
         }
         else
            gl_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
         break;

      /* GL_PGI_misc_hints */
      case GL_STRICT_DEPTHFUNC_HINT_PGI:
	 *params = (GL_NICEST);
         break;
      case GL_STRICT_LIGHTING_HINT_PGI:
	 *params = (ctx->Hint.StrictLighting);
	 break;
      case GL_STRICT_SCISSOR_HINT_PGI:
      case GL_FULL_STIPPLE_HINT_PGI:
	 *params = GL_TRUE;
	 break;
      case GL_CONSERVE_MEMORY_HINT_PGI:
	 *params = GL_FALSE;
	 break;
      case GL_ALWAYS_FAST_HINT_PGI:
	 *params = (ctx->Hint.AllowDrawWin == GL_TRUE &&
		    ctx->Hint.AllowDrawFrg == GL_FALSE && 
		    ctx->Hint.AllowDrawMem == GL_FALSE);
	 break;
      case GL_ALWAYS_SOFT_HINT_PGI:
	 *params =  (ctx->Hint.AllowDrawWin == GL_TRUE &&
		     ctx->Hint.AllowDrawFrg == GL_TRUE && 
		     ctx->Hint.AllowDrawMem == GL_TRUE);
	 break;
      case GL_ALLOW_DRAW_OBJ_HINT_PGI:
	 *params = GL_TRUE;
	 break;
      case GL_ALLOW_DRAW_WIN_HINT_PGI:
	 *params = ctx->Hint.AllowDrawWin;
	 break;
      case GL_ALLOW_DRAW_FRG_HINT_PGI:
	 *params = ctx->Hint.AllowDrawFrg;
	 break;
      case GL_ALLOW_DRAW_MEM_HINT_PGI:
	 *params = ctx->Hint.AllowDrawMem;
	 break;
      case GL_CLIP_NEAR_HINT_PGI:
      case GL_CLIP_FAR_HINT_PGI:
	 *params = GL_TRUE;
	 break;
      case GL_WIDE_LINE_HINT_PGI:
	 *params = GL_DONT_CARE;
	 break;
      case GL_BACK_NORMALS_HINT_PGI:
	 *params = GL_TRUE;
	 break;
      case GL_NATIVE_GRAPHICS_HANDLE_PGI:
	 *params = 0;
	 break;

      /* GL_EXT_compiled_vertex_array */
      case GL_ARRAY_ELEMENT_LOCK_FIRST_EXT:
#ifdef VAO
	 *params = ctx->Array.Current->LockFirst;
#else
	 *params = ctx->Array.LockFirst;
#endif
	 break;
      case GL_ARRAY_ELEMENT_LOCK_COUNT_EXT:
#ifdef VAO
	 *params = ctx->Array.Current->LockCount;
#else
	 *params = ctx->Array.LockCount;
#endif
	 break;
	 
      /* GL_ARB_transpose_matrix */
      case GL_TRANSPOSE_COLOR_MATRIX_ARB:
         {
            GLfloat tm[16];
            GLuint i;
            gl_matrix_transposef(tm, ctx->ColorMatrix.m);
            for (i=0;i<16;i++) {
               params[i] = (GLint) tm[i];
            }
         }
         break;
      case GL_TRANSPOSE_MODELVIEW_MATRIX_ARB:
         {
            GLfloat tm[16];
            GLuint i;
            gl_matrix_transposef(tm, ctx->ModelView.m);
            for (i=0;i<16;i++) {
               params[i] = (GLint) tm[i];
            }
         }
         break;
      case GL_TRANSPOSE_PROJECTION_MATRIX_ARB:
         {
            GLfloat tm[16];
            GLuint i;
            gl_matrix_transposef(tm, ctx->ProjectionMatrix.m);
            for (i=0;i<16;i++) {
               params[i] = (GLint) tm[i];
            }
         }
         break;
      case GL_TRANSPOSE_TEXTURE_MATRIX_ARB:
         {
            GLfloat tm[16];
            GLuint i;
            gl_matrix_transposef(tm, ctx->TextureMatrix[texTransformUnit].m);
            for (i=0;i<16;i++) {
               params[i] = (GLint) tm[i];
            }
         }
         break;

      /* GL_HP_occlusion_test */
      case GL_OCCLUSION_TEST_HP:
         if (ctx->Extensions.HaveHpOcclusionTest) {
            *params = (GLint) ctx->Depth.OcclusionTest;
         }
         else {
            gl_error( ctx, GL_INVALID_ENUM, "glGetIntegerv" );
         }
         return;
      case GL_OCCLUSION_TEST_RESULT_HP:
         if (ctx->Extensions.HaveHpOcclusionTest) {
            if (ctx->Depth.OcclusionTest)
               *params = (GLint) ctx->OcclusionResult;
            else
               *params = (GLint) ctx->OcclusionResultSaved;
            /* reset flag now */
            ctx->OcclusionResult = GL_FALSE;
            ctx->OcclusionResultSaved = GL_FALSE;
         }
         else {
            gl_error( ctx, GL_INVALID_ENUM, "glGetIntegerv" );
         }
         return;

      /* GL_SGIS_pixel_texture */
      case GL_PIXEL_TEXTURE_SGIS:
         *params = (GLint) ctx->Pixel.PixelTextureEnabled;
         break;

      /* GL_SGIX_pixel_texture */
      case GL_PIXEL_TEX_GEN_SGIX:
         *params = (GLint) ctx->Pixel.PixelTextureEnabled;
         break;
      case GL_PIXEL_TEX_GEN_MODE_SGIX:
         *params = (GLint) pixel_texgen_mode(ctx);
         break;

      /* GL_SGI_color_matrix (also in 1.2 imaging) */
      case GL_COLOR_MATRIX_SGI:
         for (i=0;i<16;i++) {
	    params[i] = (GLint) ctx->ColorMatrix.m[i];
	 }
	 break;
      case GL_COLOR_MATRIX_STACK_DEPTH_SGI:
         *params = ctx->ColorStackDepth + 1;
         break;
      case GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI:
         *params = MAX_COLOR_STACK_DEPTH;
         break;
      case GL_POST_COLOR_MATRIX_RED_SCALE_SGI:
         *params = (GLint) ctx->Pixel.PostColorMatrixScale[0];
         break;
      case GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI:
         *params = (GLint) ctx->Pixel.PostColorMatrixScale[1];
         break;
      case GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI:
         *params = (GLint) ctx->Pixel.PostColorMatrixScale[2];
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI:
         *params = (GLint) ctx->Pixel.PostColorMatrixScale[3];
         break;
      case GL_POST_COLOR_MATRIX_RED_BIAS_SGI:
         *params = (GLint) ctx->Pixel.PostColorMatrixBias[0];
         break;
      case GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI:
         *params = (GLint) ctx->Pixel.PostColorMatrixBias[1];
         break;
      case GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI:
         *params = (GLint) ctx->Pixel.PostColorMatrixBias[2];
         break;
      case GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI:
         *params = (GLint) ctx->Pixel.PostColorMatrixBias[3];
         break;

      /* GL_EXT_convolution (also in 1.2 imaging) */
      case GL_MAX_CONVOLUTION_WIDTH:
         *params = ctx->Const.MaxConvolutionWidth;
         break;
      case GL_MAX_CONVOLUTION_HEIGHT:
         *params = ctx->Const.MaxConvolutionHeight;
         break;
      case GL_POST_CONVOLUTION_RED_SCALE_EXT:
         *params = (GLint) ctx->Pixel.PostConvolutionScale[0];
         break;
      case GL_POST_CONVOLUTION_GREEN_SCALE_EXT:
         *params = (GLint) ctx->Pixel.PostConvolutionScale[1];
         break;
      case GL_POST_CONVOLUTION_BLUE_SCALE_EXT:
         *params = (GLint) ctx->Pixel.PostConvolutionScale[2];
         break;
      case GL_POST_CONVOLUTION_ALPHA_SCALE_EXT:
         *params = (GLint) ctx->Pixel.PostConvolutionScale[3];
         break;
      case GL_POST_CONVOLUTION_RED_BIAS_EXT:
         *params = (GLint) ctx->Pixel.PostConvolutionBias[0];
         break;
      case GL_POST_CONVOLUTION_GREEN_BIAS_EXT:
         *params = (GLint) ctx->Pixel.PostConvolutionBias[1];
         break;
      case GL_POST_CONVOLUTION_BLUE_BIAS_EXT:
         *params = (GLint) ctx->Pixel.PostConvolutionBias[2];
         break;
      case GL_POST_CONVOLUTION_ALPHA_BIAS_EXT:
         *params = (GLint) ctx->Pixel.PostConvolutionBias[2];
         break;

      /* GL_SGI_color_table (also in 1.2 imaging */
      case GL_COLOR_TABLE_SGI:
         *params = (GLint) ctx->Pixel.ColorTableEnabled;
         break;
      case GL_POST_CONVOLUTION_COLOR_TABLE_SGI:
         *params = (GLint) ctx->Pixel.PostConvolutionColorTableEnabled;
         break;
      case GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI:
         *params = (GLint) ctx->Pixel.PostColorMatrixColorTableEnabled;
         break;

      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetIntegerv" );
   }
}



void
_mesa_GetPointerv( GLenum pname, GLvoid **params )
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint texUnit = ctx->Texture.CurrentUnit;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetPointerv");

   if (!params)
      return;

   if (MESA_VERBOSE & VERBOSE_API) 
      fprintf(stderr, "glGetPointerv %s\n", gl_lookup_enum_by_nr(pname));

   if (ctx->Driver.GetPointerv
       && (*ctx->Driver.GetPointerv)(ctx, pname, params))
      return;

   switch (pname) {
      case GL_VERTEX_ARRAY_POINTER:
#ifdef VAO
         *params = ctx->Array.Current->Vertex.Ptr;
#else
         *params = ctx->Array.Vertex.Ptr;
#endif
         break;
      case GL_NORMAL_ARRAY_POINTER:
#ifdef VAO
         *params = ctx->Array.Current->Normal.Ptr;
#else
         *params = ctx->Array.Normal.Ptr;
#endif
         break;
      case GL_COLOR_ARRAY_POINTER:
#ifdef VAO
         *params = ctx->Array.Current->Color.Ptr;
#else
         *params = ctx->Array.Color.Ptr;
#endif
         break;
      case GL_INDEX_ARRAY_POINTER:
#ifdef VAO
         *params = ctx->Array.Current->Index.Ptr;
#else
         *params = ctx->Array.Index.Ptr;
#endif
         break;
      case GL_TEXTURE_COORD_ARRAY_POINTER:
#ifdef VAO
         *params = ctx->Array.Current->TexCoord[texUnit].Ptr;
#else
         *params = ctx->Array.TexCoord[texUnit].Ptr;
#endif
         break;
      case GL_EDGE_FLAG_ARRAY_POINTER:
#ifdef VAO
         *params = ctx->Array.Current->EdgeFlag.Ptr;
#else
         *params = ctx->Array.EdgeFlag.Ptr;
#endif
         break;
      case GL_FEEDBACK_BUFFER_POINTER:
         *params = ctx->Feedback.Buffer;
         break;
      case GL_SELECTION_BUFFER_POINTER:
         *params = ctx->Select.Buffer;
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetPointerv" );
         return;
   }
}



const GLubyte *
_mesa_GetString( GLenum name )
{
   GET_CURRENT_CONTEXT(ctx);
   static const char *vendor = "Brian Paul";
   static const char *renderer = "Mesa";
   static const char *version = "1.2 Mesa 3.4.2";

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH_WITH_RETVAL(ctx, "glGetString", 0);

   /* this is a required driver function */
   assert(ctx->Driver.GetString);
   {
      const GLubyte *str = (*ctx->Driver.GetString)(ctx, name);
      if (str)
         return str;

       switch (name) {
          case GL_VENDOR:
             return (const GLubyte *) vendor;
          case GL_RENDERER:
             return (const GLubyte *) renderer;
          case GL_VERSION:
             return (const GLubyte *) version;
          case GL_EXTENSIONS:
             return (GLubyte *) gl_extensions_get_string( ctx );
          default:
             gl_error( ctx, GL_INVALID_ENUM, "glGetString" );
             return (GLubyte *) 0;
       }
   }
}


/*
 * Execute a glGetError command
 */
GLenum
_mesa_GetError( void )
{
   GET_CURRENT_CONTEXT(ctx);

   GLenum e = ctx->ErrorValue;

   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL( ctx, "glGetError", (GLenum) 0);

   if (MESA_VERBOSE & VERBOSE_API)
      fprintf(stderr, "glGetError <-- %s\n", gl_lookup_enum_by_nr(e));

   ctx->ErrorValue = (GLenum) GL_NO_ERROR;
   return e;
}

@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
d4 4
a7 4
 * Version:  5.0.2
 *
 * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
 *
d14 1
a14 1
 *
d17 1
a17 1
 *
d27 3
a30 1
#include "colormac.h"
d37 1
d39 3
a41 3
#include "mtypes.h"
#include "texcompress.h"
#include "math/m_matrix.h"
a59 33
/* Check if named extension is enabled, if not generate error and return */

#define CHECK_EXTENSION_B(EXTNAME, PNAME)			\
   if (!ctx->Extensions.EXTNAME) {				\
      _mesa_error(ctx, GL_INVALID_VALUE,			\
                  "glGetBooleanv(0x%x)", (int) PNAME);		\
      return;							\
   }	

#define CHECK_EXTENSION_I(EXTNAME, PNAME)			\
   if (!ctx->Extensions.EXTNAME) {				\
      _mesa_error(ctx, GL_INVALID_VALUE,			\
                  "glGetIntegerv(0x%x)", (int) PNAME);		\
      return;							\
   }	

#define CHECK_EXTENSION_F(EXTNAME, PNAME)			\
   if (!ctx->Extensions.EXTNAME) {				\
      _mesa_error(ctx, GL_INVALID_VALUE,			\
                  "glGetFloatv(0x%x)", (int) PNAME);		\
      return;							\
   }	

#define CHECK_EXTENSION_D(EXTNAME, PNAME)			\
   if (!ctx->Extensions.EXTNAME) {				\
      _mesa_error(ctx, GL_INVALID_VALUE,			\
                  "glGetDoublev(0x%x)", (int) PNAME);		\
      return;							\
   }	




d82 1
d89 1
d91 2
a92 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d97 2
a98 7
   /* We need this in order to get correct results for
    * GL_OCCLUSION_TEST_RESULT_HP.  There might be other important cases.
    */
   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGetBooleanv %s\n", _mesa_lookup_enum_by_nr(pname));
d106 1
a106 1
         *params = INT_TO_BOOL(ctx->Visual.accumRedBits);
d109 1
a109 1
         *params = INT_TO_BOOL(ctx->Visual.accumGreenBits);
d112 1
a112 1
         *params = INT_TO_BOOL(ctx->Visual.accumBlueBits);
d115 1
a115 1
         *params = INT_TO_BOOL(ctx->Visual.accumAlphaBits);
d127 1
a127 1
         *params = INT_TO_BOOL(ctx->Visual.alphaBits);
d139 1
a139 1
         *params = ctx->Color.AlphaRef ? GL_TRUE : GL_FALSE;
d184 1
a184 1
         *params = INT_TO_BOOL( ctx->Visual.blueBits );
d198 1
a198 4
         if (ctx->Transform.ClipPlanesEnabled & (1 << (pname - GL_CLIP_PLANE0)))
            *params = GL_TRUE;
         else
            *params = GL_FALSE;
d201 4
a204 4
         params[0] = ctx->Color.ClearColor[0] ? GL_TRUE : GL_FALSE;
         params[1] = ctx->Color.ClearColor[1] ? GL_TRUE : GL_FALSE;
         params[2] = ctx->Color.ClearColor[2] ? GL_TRUE : GL_FALSE;
         params[3] = ctx->Color.ClearColor[3] ? GL_TRUE : GL_FALSE;
d228 4
a231 5
	 FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0]);
         params[1] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1]);
         params[2] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2]);
         params[3] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3]);
a233 1
	 FLUSH_CURRENT(ctx, 0);
d237 3
a239 4
	 FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][0]);
         params[1] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][1]);
         params[2] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][2]);
d260 4
a263 4
         params[0] = FLOAT_TO_BOOL(ctx->Current.RasterTexCoords[texUnit][0]);
         params[1] = FLOAT_TO_BOOL(ctx->Current.RasterTexCoords[texUnit][1]);
         params[2] = FLOAT_TO_BOOL(ctx->Current.RasterTexCoords[texUnit][2]);
         params[3] = FLOAT_TO_BOOL(ctx->Current.RasterTexCoords[texUnit][3]);
d269 4
a272 5
	 FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][0]);
         params[1] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][1]);
         params[2] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][2]);
         params[3] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][3]);
d278 1
a278 1
	 *params = INT_TO_BOOL(ctx->Visual.depthBits);
d303 1
a303 1
	 *params = ctx->Visual.doubleBufferMode;
a308 1
	 FLUSH_CURRENT(ctx, 0);
d351 1
a351 1
         *params = INT_TO_BOOL( ctx->Visual.greenBits );
d356 3
d360 1
a360 1
         *params = INT_TO_BOOL( ctx->Visual.indexBits );
d366 1
a366 1
	 *params = ctx->Visual.rgbMode ? GL_FALSE : GL_TRUE;
d441 2
a442 6
         if (!ctx->CompileFlag)
            *params = 0;
         else if (ctx->ExecuteFlag)
            *params = ENUM_TO_BOOL(GL_COMPILE_AND_EXECUTE);
         else
            *params = ENUM_TO_BOOL(GL_COMPILE);
d540 1
a540 1
	 *params = INT_TO_BOOL(ctx->Const.MaxClipPlanes);
d543 1
a543 1
         *params = INT_TO_BOOL(ctx->Const.MaxArrayLockSize);
d546 1
a546 1
         *params = INT_TO_BOOL(ctx->Const.MaxArrayLockSize);
d552 1
a552 1
	 *params = INT_TO_BOOL(ctx->Const.MaxLights);
a569 2
         *params = INT_TO_BOOL(1 << (ctx->Const.MaxTextureLevels - 1));
	 break;
d571 1
a571 1
         *params = INT_TO_BOOL(1 << (ctx->Const.Max3DTextureLevels - 1));
d580 3
d585 1
a585 1
	    params[i] = FLOAT_TO_BOOL(ctx->ModelviewMatrixStack.Top->m[i]);
d589 1
a589 1
         *params = INT_TO_BOOL(ctx->ModelviewMatrixStack.Depth + 1);
a620 3
      case GL_PACK_INVERT_MESA:
         *params = ctx->Pack.Invert;
         break;
d655 1
a655 1
	 *params = FLOAT_TO_BOOL(ctx->Point.Size);
d712 1
a712 1
	    params[i] = FLOAT_TO_BOOL(ctx->ProjectionMatrixStack.Top->m[i]);
d716 1
a716 1
	 *params = INT_TO_BOOL(ctx->ProjectionMatrixStack.Depth + 1);
d725 1
a725 1
         *params = INT_TO_BOOL( ctx->Visual.redBits );
d737 1
a737 1
         *params = ctx->Visual.rgbMode;
d758 1
a758 1
	 *params = INT_TO_BOOL(ctx->Visual.stencilBits);
d764 1
a764 1
	 *params = ENUM_TO_BOOL(ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace]);
d767 1
a767 1
	 *params = ENUM_TO_BOOL(ctx->Stencil.Function[ctx->Stencil.ActiveFace]);
d770 1
a770 1
	 *params = ENUM_TO_BOOL(ctx->Stencil.ZFailFunc[ctx->Stencil.ActiveFace]);
d773 1
a773 1
	 *params = ENUM_TO_BOOL(ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace]);
d776 1
a776 1
	 *params = INT_TO_BOOL(ctx->Stencil.Ref[ctx->Stencil.ActiveFace]);
d782 1
a782 1
	 *params = INT_TO_BOOL(ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace]);
d785 1
a785 1
	 *params = INT_TO_BOOL(ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace]);
d788 1
a788 1
	 *params = ctx->Visual.stereoMode;
d803 1
a803 1
         *params = INT_TO_BOOL(textureUnit->Current1D->Name);
d806 1
a806 1
         *params = INT_TO_BOOL(textureUnit->Current2D->Name);
d809 1
a809 1
         *params = INT_TO_BOOL(textureUnit->Current3D->Name);
d836 2
a837 2
	    params[i] =
	       FLOAT_TO_BOOL(ctx->TextureMatrixStack[texUnit].Top->m[i]);
d841 1
a841 1
	 *params = INT_TO_BOOL(ctx->TextureMatrixStack[texUnit].Depth + 1);
a866 3
      case GL_UNPACK_CLIENT_STORAGE_APPLE:
         *params = ctx->Unpack.ClientStorage;
         break;
d880 3
d884 1
d887 3
d891 1
d894 3
d898 1
d901 3
d905 1
d911 3
d915 1
d918 3
d922 1
d925 3
d929 1
d935 3
d939 1
d942 3
d946 1
d949 3
d953 1
d956 3
d960 1
d966 3
d970 1
d973 3
d977 1
d980 3
d984 1
d990 3
d994 1
d997 3
d1001 1
d1004 3
d1008 1
d1011 3
d1015 1
d1021 3
d1025 1
d1028 3
d1032 1
a1032 3
         break;
      case GL_EDGE_FLAG_ARRAY_COUNT_EXT:
         *params = INT_TO_BOOL(0);
d1037 1
a1037 2
         CHECK_EXTENSION_B(ARB_multitexture, pname);
         *params = INT_TO_BOOL(ctx->Const.MaxTextureUnits);
a1039 1
         CHECK_EXTENSION_B(ARB_multitexture, pname);
a1042 1
         CHECK_EXTENSION_B(ARB_multitexture, pname);
d1048 5
a1052 3
         CHECK_EXTENSION_B(ARB_texture_cube_map, pname);
         *params = _mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB);
         break;
d1054 5
a1058 3
         CHECK_EXTENSION_B(ARB_texture_cube_map, pname);
         *params = INT_TO_BOOL(textureUnit->CurrentCubeMap->Name);
         break;
d1060 4
a1063 2
         CHECK_EXTENSION_B(ARB_texture_cube_map, pname);
         *params = INT_TO_BOOL(1 << (ctx->Const.MaxCubeTextureLevels - 1));
d1068 5
a1072 2
         CHECK_EXTENSION_B(ARB_texture_compression, pname);
         *params = INT_TO_BOOL(ctx->Hint.TextureCompression);
d1075 5
a1079 2
         CHECK_EXTENSION_B(ARB_texture_compression, pname);
         *params = INT_TO_BOOL(_mesa_get_compressed_formats(ctx, NULL));
d1082 4
a1085 7
         CHECK_EXTENSION_B(ARB_texture_compression, pname);
         {
            GLint formats[100];
            GLuint i, n;
            n = _mesa_get_compressed_formats(ctx, formats);
            for (i = 0; i < n; i++)
               params[i] = INT_TO_BOOL(formats[i]);
d1087 7
d1095 45
d1143 3
d1147 1
d1150 3
d1154 1
d1162 1
a1162 1
            _math_transposef(tm, ctx->ColorMatrixStack.Top->m);
d1172 1
a1172 1
            _math_transposef(tm, ctx->ModelviewMatrixStack.Top->m);
d1182 1
a1182 1
            _math_transposef(tm, ctx->ProjectionMatrixStack.Top->m);
d1192 1
a1192 1
            _math_transposef(tm, ctx->TextureMatrixStack[texUnit].Top->m);
d1201 6
a1206 2
         CHECK_EXTENSION_B(HP_occlusion_test, pname);
         *params = ctx->Depth.OcclusionTest;
d1209 12
a1220 8
         CHECK_EXTENSION_B(HP_occlusion_test, pname);
         if (ctx->Depth.OcclusionTest)
            *params = ctx->OcclusionResult;
         else
            *params = ctx->OcclusionResultSaved;
         /* reset flag now */
         ctx->OcclusionResult = GL_FALSE;
         ctx->OcclusionResultSaved = GL_FALSE;
d1239 1
a1239 1
	    params[i] = FLOAT_TO_BOOL(ctx->ColorMatrixStack.Top->m[i]);
d1243 1
a1243 1
         *params = INT_TO_BOOL(ctx->ColorMatrixStack.Depth + 1);
d1274 5
a1278 11
      case GL_CONVOLUTION_1D_EXT:
         CHECK_EXTENSION_B(EXT_convolution, pname);
         *params = ctx->Pixel.Convolution1DEnabled;
         break;
      case GL_CONVOLUTION_2D:
         CHECK_EXTENSION_B(EXT_convolution, pname);
         *params = ctx->Pixel.Convolution2DEnabled;
         break;
      case GL_SEPARABLE_2D:
         CHECK_EXTENSION_B(EXT_convolution, pname);
         *params = ctx->Pixel.Separable2DEnabled;
a1280 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1283 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1286 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1289 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1292 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1295 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1298 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1301 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1304 10
      /* GL_EXT_histogram (also in 1.2 imaging) */
      case GL_HISTOGRAM:
         CHECK_EXTENSION_B(EXT_histogram, pname);
         *params = ctx->Pixel.HistogramEnabled;
	 break;
      case GL_MINMAX:
         CHECK_EXTENSION_B(EXT_histogram, pname);
         *params = ctx->Pixel.MinMaxEnabled;
         break;

a1315 250
      /* GL_EXT_secondary_color */
      case GL_COLOR_SUM_EXT:
         CHECK_EXTENSION_B(EXT_secondary_color, pname);
	 *params = ctx->Fog.ColorSumEnabled;
	 break;
      case GL_CURRENT_SECONDARY_COLOR_EXT:
         CHECK_EXTENSION_B(EXT_secondary_color, pname);
	 FLUSH_CURRENT(ctx, 0);
         params[0] = INT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][0]);
         params[1] = INT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][1]);
         params[2] = INT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][2]);
         params[3] = INT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][3]);
	 break;
      case GL_SECONDARY_COLOR_ARRAY_EXT:
         CHECK_EXTENSION_B(EXT_secondary_color, pname);
         *params = ctx->Array.SecondaryColor.Enabled;
         break;
      case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
         CHECK_EXTENSION_B(EXT_secondary_color, pname);
	 *params = ENUM_TO_BOOL(ctx->Array.SecondaryColor.Type);
	 break;
      case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
         CHECK_EXTENSION_B(EXT_secondary_color, pname);
	 *params = INT_TO_BOOL(ctx->Array.SecondaryColor.Stride);
	 break;
      case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
         CHECK_EXTENSION_B(EXT_secondary_color, pname);
	 *params = INT_TO_BOOL(ctx->Array.SecondaryColor.Size);
	 break;

      /* GL_EXT_fog_coord */
      case GL_CURRENT_FOG_COORDINATE_EXT:
         CHECK_EXTENSION_B(EXT_fog_coord, pname);
	 FLUSH_CURRENT(ctx, 0);
	 *params = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_FOG][0]);
	 break;
      case GL_FOG_COORDINATE_ARRAY_EXT:
         CHECK_EXTENSION_B(EXT_fog_coord, pname);
         *params = ctx->Array.FogCoord.Enabled;
         break;
      case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
         CHECK_EXTENSION_B(EXT_fog_coord, pname);
	 *params = ENUM_TO_BOOL(ctx->Array.FogCoord.Type);
	 break;
      case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
         CHECK_EXTENSION_B(EXT_fog_coord, pname);
	 *params = INT_TO_BOOL(ctx->Array.FogCoord.Stride);
	 break;
      case GL_FOG_COORDINATE_SOURCE_EXT:
         CHECK_EXTENSION_B(EXT_fog_coord, pname);
	 *params = ENUM_TO_BOOL(ctx->Fog.FogCoordinateSource);
	 break;

      /* GL_EXT_texture_lod_bias */
      case GL_MAX_TEXTURE_LOD_BIAS_EXT:
         *params = FLOAT_TO_BOOL(ctx->Const.MaxTextureLodBias);
         break;

      /* GL_EXT_texture_filter_anisotropic */
      case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
         CHECK_EXTENSION_B(EXT_texture_filter_anisotropic, pname);
         *params = FLOAT_TO_BOOL(ctx->Const.MaxTextureMaxAnisotropy);
	 break;

      /* GL_ARB_multisample */
      case GL_MULTISAMPLE_ARB:
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = ctx->Multisample.Enabled;
         break;
      case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = ctx->Multisample.SampleAlphaToCoverage;
         break;
      case GL_SAMPLE_ALPHA_TO_ONE_ARB:
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = ctx->Multisample.SampleAlphaToOne;
         break;
      case GL_SAMPLE_COVERAGE_ARB:
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = ctx->Multisample.SampleCoverage;
         break;
      case GL_SAMPLE_COVERAGE_VALUE_ARB:
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = FLOAT_TO_BOOL(ctx->Multisample.SampleCoverageValue);
         break;
      case GL_SAMPLE_COVERAGE_INVERT_ARB:
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = ctx->Multisample.SampleCoverageInvert;
         break;
      case GL_SAMPLE_BUFFERS_ARB:
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = 0; /* XXX fix someday */
         break;
      case GL_SAMPLES_ARB:
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = 0; /* XXX fix someday */
         break;

      /* GL_IBM_rasterpos_clip */
      case GL_RASTER_POSITION_UNCLIPPED_IBM:
         CHECK_EXTENSION_B(IBM_rasterpos_clip, pname);
         *params = ctx->Transform.RasterPositionUnclipped;
         break;

      /* GL_NV_point_sprite */
      case GL_POINT_SPRITE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = ctx->Point.PointSprite;
         break;
      case GL_POINT_SPRITE_R_MODE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = ENUM_TO_BOOL(ctx->Point.SpriteRMode);
         break;

      /* GL_SGIS_generate_mipmap */
      case GL_GENERATE_MIPMAP_HINT_SGIS:
         CHECK_EXTENSION_B(SGIS_generate_mipmap, pname);
         *params = ENUM_TO_BOOL(ctx->Hint.GenerateMipmap);
         break;

#if FEATURE_NV_vertex_program
      case GL_VERTEX_PROGRAM_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = ctx->VertexProgram.Enabled;
         break;
      case GL_VERTEX_PROGRAM_POINT_SIZE_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = ctx->VertexProgram.PointSizeEnabled;
         break;
      case GL_VERTEX_PROGRAM_TWO_SIDE_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = ctx->VertexProgram.TwoSideEnabled;
         break;
      case GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = (MAX_PROGRAM_STACK_DEPTH > 0) ? GL_TRUE : GL_FALSE;
         break;
      case GL_MAX_TRACK_MATRICES_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = (MAX_PROGRAM_MATRICES > 0) ? GL_TRUE : GL_FALSE;
         break;
      case GL_CURRENT_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = GL_TRUE;
         break;
      case GL_CURRENT_MATRIX_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         for (i = 0; i < 16; i++)
            params[i] = FLOAT_TO_BOOL(ctx->CurrentStack->Top->m[i]);
         break;
      case GL_VERTEX_PROGRAM_BINDING_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = (ctx->VertexProgram.CurrentID != 0) ? GL_TRUE : GL_FALSE;
         break;
      case GL_PROGRAM_ERROR_POSITION_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = (ctx->VertexProgram.ErrorPos != 0) ? GL_TRUE : GL_FALSE;
         break;
      case GL_VERTEX_ATTRIB_ARRAY0_NV:
      case GL_VERTEX_ATTRIB_ARRAY1_NV:
      case GL_VERTEX_ATTRIB_ARRAY2_NV:
      case GL_VERTEX_ATTRIB_ARRAY3_NV:
      case GL_VERTEX_ATTRIB_ARRAY4_NV:
      case GL_VERTEX_ATTRIB_ARRAY5_NV:
      case GL_VERTEX_ATTRIB_ARRAY6_NV:
      case GL_VERTEX_ATTRIB_ARRAY7_NV:
      case GL_VERTEX_ATTRIB_ARRAY8_NV:
      case GL_VERTEX_ATTRIB_ARRAY9_NV:
      case GL_VERTEX_ATTRIB_ARRAY10_NV:
      case GL_VERTEX_ATTRIB_ARRAY11_NV:
      case GL_VERTEX_ATTRIB_ARRAY12_NV:
      case GL_VERTEX_ATTRIB_ARRAY13_NV:
      case GL_VERTEX_ATTRIB_ARRAY14_NV:
      case GL_VERTEX_ATTRIB_ARRAY15_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_VERTEX_ATTRIB_ARRAY0_NV;
            *params = ctx->Array.VertexAttrib[n].Enabled;
         }
         break;
      case GL_MAP1_VERTEX_ATTRIB0_4_NV:
      case GL_MAP1_VERTEX_ATTRIB1_4_NV:
      case GL_MAP1_VERTEX_ATTRIB2_4_NV:
      case GL_MAP1_VERTEX_ATTRIB3_4_NV:
      case GL_MAP1_VERTEX_ATTRIB4_4_NV:
      case GL_MAP1_VERTEX_ATTRIB5_4_NV:
      case GL_MAP1_VERTEX_ATTRIB6_4_NV:
      case GL_MAP1_VERTEX_ATTRIB7_4_NV:
      case GL_MAP1_VERTEX_ATTRIB8_4_NV:
      case GL_MAP1_VERTEX_ATTRIB9_4_NV:
      case GL_MAP1_VERTEX_ATTRIB10_4_NV:
      case GL_MAP1_VERTEX_ATTRIB11_4_NV:
      case GL_MAP1_VERTEX_ATTRIB12_4_NV:
      case GL_MAP1_VERTEX_ATTRIB13_4_NV:
      case GL_MAP1_VERTEX_ATTRIB14_4_NV:
      case GL_MAP1_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP1_VERTEX_ATTRIB0_4_NV;
            *params = ctx->Eval.Map1Attrib[n];
         }
         break;
      case GL_MAP2_VERTEX_ATTRIB0_4_NV:
      case GL_MAP2_VERTEX_ATTRIB1_4_NV:
      case GL_MAP2_VERTEX_ATTRIB2_4_NV:
      case GL_MAP2_VERTEX_ATTRIB3_4_NV:
      case GL_MAP2_VERTEX_ATTRIB4_4_NV:
      case GL_MAP2_VERTEX_ATTRIB5_4_NV:
      case GL_MAP2_VERTEX_ATTRIB6_4_NV:
      case GL_MAP2_VERTEX_ATTRIB7_4_NV:
      case GL_MAP2_VERTEX_ATTRIB8_4_NV:
      case GL_MAP2_VERTEX_ATTRIB9_4_NV:
      case GL_MAP2_VERTEX_ATTRIB10_4_NV:
      case GL_MAP2_VERTEX_ATTRIB11_4_NV:
      case GL_MAP2_VERTEX_ATTRIB12_4_NV:
      case GL_MAP2_VERTEX_ATTRIB13_4_NV:
      case GL_MAP2_VERTEX_ATTRIB14_4_NV:
      case GL_MAP2_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP2_VERTEX_ATTRIB0_4_NV;
            *params = ctx->Eval.Map2Attrib[n];
         }
         break;
#endif /* FEATURE_NV_vertex_program */

      /* GL_NV_texture_rectangle */
      case GL_TEXTURE_RECTANGLE_NV:
         CHECK_EXTENSION_B(NV_texture_rectangle, pname);
         *params = _mesa_IsEnabled(GL_TEXTURE_RECTANGLE_NV);
         break;
      case GL_TEXTURE_BINDING_RECTANGLE_NV:
         CHECK_EXTENSION_B(NV_texture_rectangle, pname);
         *params = INT_TO_BOOL(textureUnit->CurrentRect->Name);
         break;
      case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
         CHECK_EXTENSION_B(NV_texture_rectangle, pname);
         *params = INT_TO_BOOL(ctx->Const.MaxTextureRectSize);
         break;

      /* GL_EXT_stencil_two_side */
      case GL_STENCIL_TEST_TWO_SIDE_EXT:
         CHECK_EXTENSION_B(EXT_stencil_two_side, pname);
         *params = ctx->Stencil.TestTwoSide;
         break;
      case GL_ACTIVE_STENCIL_FACE_EXT:
         CHECK_EXTENSION_B(EXT_stencil_two_side, pname);
         *params = ENUM_TO_BOOL(ctx->Stencil.ActiveFace ? GL_BACK : GL_FRONT);
         break;

d1317 1
a1317 1
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv(pname=0x%x)", pname);
d1322 2
d1330 1
d1332 2
a1333 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1338 2
a1339 7
   /* We need this in order to get correct results for
    * GL_OCCLUSION_TEST_RESULT_HP.  There might be other important cases.
    */
   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGetDoublev %s\n", _mesa_lookup_enum_by_nr(pname));
d1346 1
a1346 1
         *params = (GLdouble) ctx->Visual.accumRedBits;
d1349 1
a1349 1
         *params = (GLdouble) ctx->Visual.accumGreenBits;
d1352 1
a1352 1
         *params = (GLdouble) ctx->Visual.accumBlueBits;
d1355 1
a1355 1
         *params = (GLdouble) ctx->Visual.accumAlphaBits;
d1367 1
a1367 1
         *params = (GLdouble) ctx->Visual.alphaBits;
d1379 1
a1379 1
         *params = (GLdouble) ctx->Color.AlphaRef;
d1424 1
a1424 1
         *params = (GLdouble) ctx->Visual.blueBits;
d1438 1
a1438 4
         if (ctx->Transform.ClipPlanesEnabled & (1 << (pname - GL_CLIP_PLANE0)))
            *params = 1.0;
         else
            *params = 0.0;
d1468 4
a1471 5
	 FLUSH_CURRENT(ctx, 0);
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0];
         params[1] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1];
         params[2] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2];
         params[3] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3];
a1473 1
	 FLUSH_CURRENT(ctx, 0);
d1477 3
a1479 4
	 FLUSH_CURRENT(ctx, 0);
         params[0] = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_NORMAL][0];
         params[1] = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_NORMAL][1];
         params[2] = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_NORMAL][2];
d1500 4
a1503 4
	 params[0] = (GLdouble) ctx->Current.RasterTexCoords[texUnit][0];
	 params[1] = (GLdouble) ctx->Current.RasterTexCoords[texUnit][1];
	 params[2] = (GLdouble) ctx->Current.RasterTexCoords[texUnit][2];
	 params[3] = (GLdouble) ctx->Current.RasterTexCoords[texUnit][3];
d1509 4
a1512 5
	 FLUSH_CURRENT(ctx, 0);
	 params[0] = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][0];
	 params[1] = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][1];
	 params[2] = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][2];
	 params[3] = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][3];
d1518 1
a1518 1
	 *params = (GLdouble) ctx->Visual.depthBits;
d1543 1
a1543 1
	 *params = (GLdouble) ctx->Visual.doubleBufferMode;
a1548 1
	 FLUSH_CURRENT(ctx, 0);
d1591 1
a1591 1
         *params = (GLdouble) ctx->Visual.greenBits;
d1596 3
d1600 1
a1600 1
         *params = (GLdouble) ctx->Visual.indexBits;
d1606 1
a1606 1
	 *params = ctx->Visual.rgbMode ? 0.0 : 1.0;
d1681 2
a1682 6
         if (!ctx->CompileFlag)
            *params = 0.0;
         else if (ctx->ExecuteFlag)
            *params = ENUM_TO_DOUBLE(GL_COMPILE_AND_EXECUTE);
         else
            *params = ENUM_TO_DOUBLE(GL_COMPILE);
d1780 1
a1780 1
	 *params = (GLdouble) ctx->Const.MaxClipPlanes;
d1783 1
a1783 1
         *params = (GLdouble) ctx->Const.MaxArrayLockSize;
d1786 1
a1786 1
         *params = (GLdouble) ctx->Const.MaxArrayLockSize;
d1792 1
a1792 1
	 *params = (GLdouble) ctx->Const.MaxLights;
a1809 2
         *params = (GLdouble) (1 << (ctx->Const.MaxTextureLevels - 1));
	 break;
d1811 1
a1811 1
         *params = (GLdouble) (1 << (ctx->Const.Max3DTextureLevels - 1));
d1820 3
d1825 1
a1825 1
	    params[i] = (GLdouble) ctx->ModelviewMatrixStack.Top->m[i];
d1829 1
a1829 1
	 *params = (GLdouble) (ctx->ModelviewMatrixStack.Depth + 1);
a1860 3
      case GL_PACK_INVERT_MESA:
         *params = (GLdouble) ctx->Pack.Invert;
         break;
d1895 1
a1895 1
         *params = (GLdouble) ctx->Point.Size;
d1952 1
a1952 1
	    params[i] = (GLdouble) ctx->ProjectionMatrixStack.Top->m[i];
d1956 1
a1956 1
	 *params = (GLdouble) (ctx->ProjectionMatrixStack.Depth + 1);
d1965 1
a1965 1
         *params = (GLdouble) ctx->Visual.redBits;
d1977 1
a1977 1
	 *params = (GLdouble) ctx->Visual.rgbMode;
d1998 1
a1998 1
         *params = (GLdouble) ctx->Visual.stencilBits;
d2004 1
a2004 1
	 *params = ENUM_TO_DOUBLE(ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace]);
d2007 1
a2007 1
	 *params = ENUM_TO_DOUBLE(ctx->Stencil.Function[ctx->Stencil.ActiveFace]);
d2010 1
a2010 1
	 *params = ENUM_TO_DOUBLE(ctx->Stencil.ZFailFunc[ctx->Stencil.ActiveFace]);
d2013 1
a2013 1
	 *params = ENUM_TO_DOUBLE(ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace]);
d2016 1
a2016 1
	 *params = (GLdouble) ctx->Stencil.Ref[ctx->Stencil.ActiveFace];
d2022 1
a2022 1
	 *params = (GLdouble) ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace];
d2025 1
a2025 1
	 *params = (GLdouble) ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace];
d2028 1
a2028 1
	 *params = (GLdouble) ctx->Visual.stereoMode;
d2043 1
a2043 1
         *params = (GLdouble) textureUnit->Current1D->Name;
d2046 1
a2046 1
         *params = (GLdouble) textureUnit->Current2D->Name;
d2049 1
a2049 1
         *params = (GLdouble) textureUnit->Current3D->Name;
d2074 1
a2074 1
	    params[i] = (GLdouble) ctx->TextureMatrixStack[texUnit].Top->m[i];
d2078 1
a2078 1
	 *params = (GLdouble) (ctx->TextureMatrixStack[texUnit].Depth + 1);
a2103 3
      case GL_UNPACK_CLIENT_STORAGE_APPLE:
         *params = (GLdouble) ctx->Unpack.ClientStorage;
         break;
d2117 3
d2121 1
d2124 3
d2128 1
d2131 3
d2135 1
d2138 3
d2142 1
d2148 3
d2152 1
d2155 3
d2159 1
d2162 3
d2166 1
d2172 3
d2176 1
d2179 3
d2183 1
d2186 3
d2190 1
d2193 3
d2197 1
d2203 3
d2207 1
d2210 3
d2214 1
d2217 3
d2221 1
d2227 3
d2231 1
d2234 3
d2238 1
d2241 3
d2245 1
d2248 3
d2252 1
d2258 3
d2262 1
d2265 3
d2269 1
a2276 1
         CHECK_EXTENSION_D(ARB_multitexture, pname);
a2279 1
         CHECK_EXTENSION_D(ARB_multitexture, pname);
a2282 1
         CHECK_EXTENSION_D(ARB_multitexture, pname);
d2288 5
a2292 3
         CHECK_EXTENSION_D(ARB_texture_cube_map, pname);
         *params = (GLdouble) _mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB);
         break;
d2294 5
a2298 3
         CHECK_EXTENSION_D(ARB_texture_cube_map, pname);
         *params = (GLdouble) textureUnit->CurrentCubeMap->Name;
         break;
d2300 5
a2304 3
         CHECK_EXTENSION_D(ARB_texture_cube_map, pname);
         *params = (GLdouble) (1 << (ctx->Const.MaxCubeTextureLevels - 1));
         break;
d2308 5
a2312 2
         CHECK_EXTENSION_D(ARB_texture_compression, pname);
         *params = (GLdouble) ctx->Hint.TextureCompression;
d2315 5
a2319 2
         CHECK_EXTENSION_D(ARB_texture_compression, pname);
         *params = (GLdouble) _mesa_get_compressed_formats(ctx, NULL);
d2322 4
a2325 7
         CHECK_EXTENSION_D(ARB_texture_compression, pname);
         {
            GLint formats[100];
            GLuint i, n;
            n = _mesa_get_compressed_formats(ctx, formats);
            for (i = 0; i < n; i++)
               params[i] = (GLdouble) formats[i];
d2327 7
d2335 45
d2383 3
d2387 1
d2390 3
d2394 1
d2402 1
a2402 1
            _math_transposef(tm, ctx->ColorMatrixStack.Top->m);
d2412 1
a2412 1
            _math_transposef(tm, ctx->ModelviewMatrixStack.Top->m);
d2422 1
a2422 1
            _math_transposef(tm, ctx->ProjectionMatrixStack.Top->m);
d2432 1
a2432 1
            _math_transposef(tm, ctx->TextureMatrixStack[texUnit].Top->m);
d2441 7
a2447 3
         CHECK_EXTENSION_D(HP_occlusion_test, pname);
         *params = (GLdouble) ctx->Depth.OcclusionTest;
         break;
d2449 13
a2461 9
         CHECK_EXTENSION_D(HP_occlusion_test, pname);
         if (ctx->Depth.OcclusionTest)
            *params = (GLdouble) ctx->OcclusionResult;
         else
            *params = (GLdouble) ctx->OcclusionResultSaved;
         /* reset flag now */
         ctx->OcclusionResult = GL_FALSE;
         ctx->OcclusionResultSaved = GL_FALSE;
         break;
d2479 1
a2479 1
	    params[i] = (GLdouble) ctx->ColorMatrixStack.Top->m[i];
d2483 1
a2483 1
         *params = (GLdouble) (ctx->ColorMatrixStack.Depth + 1);
d2514 5
a2518 11
      case GL_CONVOLUTION_1D_EXT:
         CHECK_EXTENSION_D(EXT_convolution, pname);
         *params = (GLdouble) ctx->Pixel.Convolution1DEnabled;
         break;
      case GL_CONVOLUTION_2D:
         CHECK_EXTENSION_D(EXT_convolution, pname);
         *params = (GLdouble) ctx->Pixel.Convolution2DEnabled;
         break;
      case GL_SEPARABLE_2D:
         CHECK_EXTENSION_D(EXT_convolution, pname);
         *params = (GLdouble) ctx->Pixel.Separable2DEnabled;
a2520 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2523 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2526 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2529 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2532 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2535 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2538 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2541 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2544 10
      /* GL_EXT_histogram (also in 1.2 imaging) */
      case GL_HISTOGRAM:
         CHECK_EXTENSION_D(EXT_histogram, pname);
         *params = (GLdouble) ctx->Pixel.HistogramEnabled;
	 break;
      case GL_MINMAX:
         CHECK_EXTENSION_D(EXT_histogram, pname);
         *params = (GLdouble) ctx->Pixel.MinMaxEnabled;
         break;

a2555 250
      /* GL_EXT_secondary_color */
      case GL_COLOR_SUM_EXT:
         CHECK_EXTENSION_D(EXT_secondary_color, pname);
	 *params = (GLdouble) ctx->Fog.ColorSumEnabled;
	 break;
      case GL_CURRENT_SECONDARY_COLOR_EXT:
         CHECK_EXTENSION_D(EXT_secondary_color, pname);
	 FLUSH_CURRENT(ctx, 0);
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][0];
         params[1] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][1];
         params[2] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][2];
         params[3] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][3];
	 break;
      case GL_SECONDARY_COLOR_ARRAY_EXT:
         CHECK_EXTENSION_D(EXT_secondary_color, pname);
         *params = (GLdouble) ctx->Array.SecondaryColor.Enabled;
         break;
      case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
         CHECK_EXTENSION_D(EXT_secondary_color, pname);
	 *params = (GLdouble) ctx->Array.SecondaryColor.Type;
	 break;
      case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
         CHECK_EXTENSION_D(EXT_secondary_color, pname);
	 *params = (GLdouble) ctx->Array.SecondaryColor.Stride;
	 break;
      case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
         CHECK_EXTENSION_D(EXT_secondary_color, pname);
	 *params = (GLdouble) ctx->Array.SecondaryColor.Size;
	 break;

      /* GL_EXT_fog_coord */
      case GL_CURRENT_FOG_COORDINATE_EXT:
         CHECK_EXTENSION_D(EXT_fog_coord, pname);
	 FLUSH_CURRENT(ctx, 0);
	 *params = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_FOG][0];
	 break;
      case GL_FOG_COORDINATE_ARRAY_EXT:
         CHECK_EXTENSION_D(EXT_fog_coord, pname);
         *params = (GLdouble) ctx->Array.FogCoord.Enabled;
         break;
      case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
         CHECK_EXTENSION_D(EXT_fog_coord, pname);
	 *params = (GLdouble) ctx->Array.FogCoord.Type;
	 break;
      case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
         CHECK_EXTENSION_D(EXT_fog_coord, pname);
	 *params = (GLdouble) ctx->Array.FogCoord.Stride;
	 break;
      case GL_FOG_COORDINATE_SOURCE_EXT:
         CHECK_EXTENSION_D(EXT_fog_coord, pname);
	 *params = (GLdouble) ctx->Fog.FogCoordinateSource;
	 break;

      /* GL_EXT_texture_lod_bias */
      case GL_MAX_TEXTURE_LOD_BIAS_EXT:
         *params = (GLdouble) ctx->Const.MaxTextureLodBias;
         break;

      /* GL_EXT_texture_filter_anisotropic */
      case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
         CHECK_EXTENSION_D(EXT_texture_filter_anisotropic, pname);
         *params = (GLdouble) ctx->Const.MaxTextureMaxAnisotropy;
	 break;

      /* GL_ARB_multisample */
      case GL_MULTISAMPLE_ARB:
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = (GLdouble) ctx->Multisample.Enabled;
         break;
      case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = (GLdouble) ctx->Multisample.SampleAlphaToCoverage;
         break;
      case GL_SAMPLE_ALPHA_TO_ONE_ARB:
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = (GLdouble) ctx->Multisample.SampleAlphaToOne;
         break;
      case GL_SAMPLE_COVERAGE_ARB:
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = (GLdouble) ctx->Multisample.SampleCoverage;
         break;
      case GL_SAMPLE_COVERAGE_VALUE_ARB:
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = ctx->Multisample.SampleCoverageValue;
         break;
      case GL_SAMPLE_COVERAGE_INVERT_ARB:
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = (GLdouble) ctx->Multisample.SampleCoverageInvert;
         break;
      case GL_SAMPLE_BUFFERS_ARB:
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = 0.0; /* XXX fix someday */
         break;
      case GL_SAMPLES_ARB:
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = 0.0; /* XXX fix someday */
         break;

      /* GL_IBM_rasterpos_clip */
      case GL_RASTER_POSITION_UNCLIPPED_IBM:
         CHECK_EXTENSION_D(IBM_rasterpos_clip, pname);
         *params = (GLdouble) ctx->Transform.RasterPositionUnclipped;
         break;

      /* GL_NV_point_sprite */
      case GL_POINT_SPRITE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = (GLdouble) ctx->Point.PointSprite;
         break;
      case GL_POINT_SPRITE_R_MODE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = (GLdouble) ctx->Point.SpriteRMode;
         break;

      /* GL_SGIS_generate_mipmap */
      case GL_GENERATE_MIPMAP_HINT_SGIS:
         CHECK_EXTENSION_D(SGIS_generate_mipmap, pname);
         *params = (GLdouble) ctx->Hint.GenerateMipmap;
         break;

#if FEATURE_NV_vertex_program
      case GL_VERTEX_PROGRAM_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) ctx->VertexProgram.Enabled;
         break;
      case GL_VERTEX_PROGRAM_POINT_SIZE_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) ctx->VertexProgram.PointSizeEnabled;
         break;
      case GL_VERTEX_PROGRAM_TWO_SIDE_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) ctx->VertexProgram.TwoSideEnabled;
         break;
      case GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) MAX_PROGRAM_STACK_DEPTH;
         break;
      case GL_MAX_TRACK_MATRICES_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) MAX_PROGRAM_MATRICES;
         break;
      case GL_CURRENT_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) ctx->CurrentStack->Depth + 1;
         break;
      case GL_CURRENT_MATRIX_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         for (i = 0; i < 16; i++)
            params[i] = (GLdouble) ctx->CurrentStack->Top->m[i];
         break;
      case GL_VERTEX_PROGRAM_BINDING_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) ctx->VertexProgram.CurrentID;
         break;
      case GL_PROGRAM_ERROR_POSITION_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) ctx->VertexProgram.ErrorPos;
         break;
      case GL_VERTEX_ATTRIB_ARRAY0_NV:
      case GL_VERTEX_ATTRIB_ARRAY1_NV:
      case GL_VERTEX_ATTRIB_ARRAY2_NV:
      case GL_VERTEX_ATTRIB_ARRAY3_NV:
      case GL_VERTEX_ATTRIB_ARRAY4_NV:
      case GL_VERTEX_ATTRIB_ARRAY5_NV:
      case GL_VERTEX_ATTRIB_ARRAY6_NV:
      case GL_VERTEX_ATTRIB_ARRAY7_NV:
      case GL_VERTEX_ATTRIB_ARRAY8_NV:
      case GL_VERTEX_ATTRIB_ARRAY9_NV:
      case GL_VERTEX_ATTRIB_ARRAY10_NV:
      case GL_VERTEX_ATTRIB_ARRAY11_NV:
      case GL_VERTEX_ATTRIB_ARRAY12_NV:
      case GL_VERTEX_ATTRIB_ARRAY13_NV:
      case GL_VERTEX_ATTRIB_ARRAY14_NV:
      case GL_VERTEX_ATTRIB_ARRAY15_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_VERTEX_ATTRIB_ARRAY0_NV;
            *params = (GLdouble) ctx->Array.VertexAttrib[n].Enabled;
         }
         break;
      case GL_MAP1_VERTEX_ATTRIB0_4_NV:
      case GL_MAP1_VERTEX_ATTRIB1_4_NV:
      case GL_MAP1_VERTEX_ATTRIB2_4_NV:
      case GL_MAP1_VERTEX_ATTRIB3_4_NV:
      case GL_MAP1_VERTEX_ATTRIB4_4_NV:
      case GL_MAP1_VERTEX_ATTRIB5_4_NV:
      case GL_MAP1_VERTEX_ATTRIB6_4_NV:
      case GL_MAP1_VERTEX_ATTRIB7_4_NV:
      case GL_MAP1_VERTEX_ATTRIB8_4_NV:
      case GL_MAP1_VERTEX_ATTRIB9_4_NV:
      case GL_MAP1_VERTEX_ATTRIB10_4_NV:
      case GL_MAP1_VERTEX_ATTRIB11_4_NV:
      case GL_MAP1_VERTEX_ATTRIB12_4_NV:
      case GL_MAP1_VERTEX_ATTRIB13_4_NV:
      case GL_MAP1_VERTEX_ATTRIB14_4_NV:
      case GL_MAP1_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP1_VERTEX_ATTRIB0_4_NV;
            *params = (GLdouble) ctx->Eval.Map1Attrib[n];
         }
         break;
      case GL_MAP2_VERTEX_ATTRIB0_4_NV:
      case GL_MAP2_VERTEX_ATTRIB1_4_NV:
      case GL_MAP2_VERTEX_ATTRIB2_4_NV:
      case GL_MAP2_VERTEX_ATTRIB3_4_NV:
      case GL_MAP2_VERTEX_ATTRIB4_4_NV:
      case GL_MAP2_VERTEX_ATTRIB5_4_NV:
      case GL_MAP2_VERTEX_ATTRIB6_4_NV:
      case GL_MAP2_VERTEX_ATTRIB7_4_NV:
      case GL_MAP2_VERTEX_ATTRIB8_4_NV:
      case GL_MAP2_VERTEX_ATTRIB9_4_NV:
      case GL_MAP2_VERTEX_ATTRIB10_4_NV:
      case GL_MAP2_VERTEX_ATTRIB11_4_NV:
      case GL_MAP2_VERTEX_ATTRIB12_4_NV:
      case GL_MAP2_VERTEX_ATTRIB13_4_NV:
      case GL_MAP2_VERTEX_ATTRIB14_4_NV:
      case GL_MAP2_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP2_VERTEX_ATTRIB0_4_NV;
            *params = (GLdouble) ctx->Eval.Map2Attrib[n];
         }
         break;
#endif /* FEATURE_NV_vertex_program */

      /* GL_NV_texture_rectangle */
      case GL_TEXTURE_RECTANGLE_NV:
         CHECK_EXTENSION_D(NV_texture_rectangle, pname);
         *params = (GLdouble) _mesa_IsEnabled(GL_TEXTURE_RECTANGLE_NV);
         break;
      case GL_TEXTURE_BINDING_RECTANGLE_NV:
         CHECK_EXTENSION_D(NV_texture_rectangle, pname);
         *params = (GLdouble) textureUnit->CurrentRect->Name;
         break;
      case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
         CHECK_EXTENSION_D(NV_texture_rectangle, pname);
         *params = (GLdouble) ctx->Const.MaxTextureRectSize;
         break;

      /* GL_EXT_stencil_two_side */
      case GL_STENCIL_TEST_TWO_SIDE_EXT:
         CHECK_EXTENSION_D(EXT_stencil_two_side, pname);
         *params = (GLdouble) ctx->Stencil.TestTwoSide;
         break;
      case GL_ACTIVE_STENCIL_FACE_EXT:
         CHECK_EXTENSION_D(EXT_stencil_two_side, pname);
         *params = (GLdouble) (ctx->Stencil.ActiveFace ? GL_BACK : GL_FRONT);
         break;

d2557 1
a2557 1
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev(pname=0x%x)", pname);
d2562 2
d2570 1
d2572 2
a2573 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d2578 2
a2579 7
   /* We need this in order to get correct results for
    * GL_OCCLUSION_TEST_RESULT_HP.  There might be other important cases.
    */
   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGetFloatv %s\n", _mesa_lookup_enum_by_nr(pname));
d2586 1
a2586 1
         *params = (GLfloat) ctx->Visual.accumRedBits;
d2589 1
a2589 1
         *params = (GLfloat) ctx->Visual.accumGreenBits;
d2592 1
a2592 1
         *params = (GLfloat) ctx->Visual.accumBlueBits;
d2595 1
a2595 1
         *params = (GLfloat) ctx->Visual.accumAlphaBits;
d2607 1
a2607 1
         *params = (GLfloat) ctx->Visual.alphaBits;
d2619 1
a2619 1
         *params = (GLfloat) ctx->Color.AlphaRef;
d2664 1
a2664 1
         *params = (GLfloat) ctx->Visual.blueBits;
d2678 1
a2678 4
         if (ctx->Transform.ClipPlanesEnabled & (1 << (pname - GL_CLIP_PLANE0)))
            *params = 1.0;
         else
            *params = 0.0;
d2681 4
a2684 4
         params[0] = ctx->Color.ClearColor[0];
         params[1] = ctx->Color.ClearColor[1];
         params[2] = ctx->Color.ClearColor[2];
         params[3] = ctx->Color.ClearColor[3];
d2708 1
a2708 5
	 FLUSH_CURRENT(ctx, 0);
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0];
         params[1] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1];
         params[2] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2];
         params[3] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3];
a2710 1
	 FLUSH_CURRENT(ctx, 0);
d2714 3
a2716 4
	 FLUSH_CURRENT(ctx, 0);
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_NORMAL][0];
         params[1] = ctx->Current.Attrib[VERT_ATTRIB_NORMAL][1];
         params[2] = ctx->Current.Attrib[VERT_ATTRIB_NORMAL][2];
d2737 4
a2740 4
	 params[0] = ctx->Current.RasterTexCoords[texUnit][0];
	 params[1] = ctx->Current.RasterTexCoords[texUnit][1];
	 params[2] = ctx->Current.RasterTexCoords[texUnit][2];
	 params[3] = ctx->Current.RasterTexCoords[texUnit][3];
d2746 4
a2749 5
	 FLUSH_CURRENT(ctx, 0);
	 params[0] = (GLfloat) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][0];
	 params[1] = (GLfloat) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][1];
	 params[2] = (GLfloat) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][2];
	 params[3] = (GLfloat) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][3];
d2755 1
a2755 1
	 *params = (GLfloat) ctx->Visual.depthBits;
d2780 1
a2780 1
	 *params = (GLfloat) ctx->Visual.doubleBufferMode;
a2785 1
	 FLUSH_CURRENT(ctx, 0);
d2828 1
a2828 1
         *params = (GLfloat) ctx->Visual.greenBits;
d2833 3
d2837 1
a2837 1
         *params = (GLfloat) ctx->Visual.indexBits;
d2843 1
a2843 1
	 *params = ctx->Visual.rgbMode ? 0.0F : 1.0F;
d2918 2
a2919 6
         if (!ctx->CompileFlag)
            *params = 0.0F;
         else if (ctx->ExecuteFlag)
            *params = ENUM_TO_FLOAT(GL_COMPILE_AND_EXECUTE);
         else
            *params = ENUM_TO_FLOAT(GL_COMPILE);
d3017 1
a3017 1
	 *params = (GLfloat) ctx->Const.MaxClipPlanes;
d3020 1
a3020 1
         *params = (GLfloat) ctx->Const.MaxArrayLockSize;
d3023 1
a3023 1
         *params = (GLfloat) ctx->Const.MaxArrayLockSize;
d3029 1
a3029 1
	 *params = (GLfloat) ctx->Const.MaxLights;
a3046 2
         *params = (GLfloat) (1 << (ctx->Const.MaxTextureLevels - 1));
	 break;
d3048 1
a3048 1
         *params = (GLfloat) (1 << (ctx->Const.Max3DTextureLevels - 1));
d3057 3
d3062 1
a3062 1
	    params[i] = ctx->ModelviewMatrixStack.Top->m[i];
d3066 1
a3066 1
	 *params = (GLfloat) (ctx->ModelviewMatrixStack.Depth + 1);
a3097 3
      case GL_PACK_INVERT_MESA:
         *params = (GLfloat) ctx->Pack.Invert;
         break;
d3132 1
a3132 1
         *params = (GLfloat) ctx->Point.Size;
d3191 1
a3191 1
	    params[i] = ctx->ProjectionMatrixStack.Top->m[i];
d3195 1
a3195 1
	 *params = (GLfloat) (ctx->ProjectionMatrixStack.Depth + 1);
d3204 1
a3204 1
         *params = (GLfloat) ctx->Visual.redBits;
d3216 1
a3216 1
	 *params = (GLfloat) ctx->Visual.rgbMode;
d3237 1
a3237 1
         *params = (GLfloat) ctx->Visual.stencilBits;
d3243 1
a3243 1
	 *params = ENUM_TO_FLOAT(ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace]);
d3246 1
a3246 1
	 *params = ENUM_TO_FLOAT(ctx->Stencil.Function[ctx->Stencil.ActiveFace]);
d3249 1
a3249 1
	 *params = ENUM_TO_FLOAT(ctx->Stencil.ZFailFunc[ctx->Stencil.ActiveFace]);
d3252 1
a3252 1
	 *params = ENUM_TO_FLOAT(ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace]);
d3255 1
a3255 1
	 *params = (GLfloat) ctx->Stencil.Ref[ctx->Stencil.ActiveFace];
d3261 1
a3261 1
	 *params = (GLfloat) ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace];
d3264 1
a3264 1
	 *params = (GLfloat) ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace];
d3267 1
a3267 1
	 *params = (GLfloat) ctx->Visual.stereoMode;
d3273 1
a3273 1
         *params = _mesa_IsEnabled(GL_TEXTURE_1D) ? 1.0F : 0.0F;
d3276 1
a3276 1
         *params = _mesa_IsEnabled(GL_TEXTURE_2D) ? 1.0F : 0.0F;
d3279 1
a3279 1
         *params = _mesa_IsEnabled(GL_TEXTURE_3D) ? 1.0F : 0.0F;
d3282 1
a3282 1
         *params = (GLfloat) textureUnit->Current1D->Name;
d3285 1
a3285 1
         *params = (GLfloat) textureUnit->Current2D->Name;
d3288 1
a3288 1
         *params = (GLfloat) textureUnit->Current2D->Name;
d3300 1
a3300 1
	 *params = (textureUnit->TexGenEnabled & S_BIT) ? 1.0F : 0.0F;
d3303 1
a3303 1
	 *params = (textureUnit->TexGenEnabled & T_BIT) ? 1.0F : 0.0F;
d3306 1
a3306 1
	 *params = (textureUnit->TexGenEnabled & R_BIT) ? 1.0F : 0.0F;
d3309 1
a3309 1
	 *params = (textureUnit->TexGenEnabled & Q_BIT) ? 1.0F : 0.0F;
d3313 1
a3313 1
	    params[i] = ctx->TextureMatrixStack[texUnit].Top->m[i];
d3317 1
a3317 1
	 *params = (GLfloat) (ctx->TextureMatrixStack[texUnit].Depth + 1);
a3342 3
      case GL_UNPACK_CLIENT_STORAGE_APPLE:
         *params = (GLfloat) ctx->Unpack.ClientStorage;
         break;
d3356 3
d3360 1
d3363 3
d3367 1
d3370 3
d3374 1
d3377 3
d3381 1
d3387 3
d3391 1
d3394 3
d3398 1
d3401 3
d3405 1
d3411 3
d3415 1
d3418 3
d3422 1
d3425 3
d3429 1
d3432 3
d3436 1
d3442 3
d3446 1
d3449 3
d3453 1
d3456 3
d3460 1
d3466 3
d3470 1
d3473 3
d3477 1
d3480 3
d3484 1
d3487 3
d3491 1
d3497 3
d3501 1
d3504 3
d3508 1
a3515 1
         CHECK_EXTENSION_F(ARB_multitexture, pname);
a3518 1
         CHECK_EXTENSION_F(ARB_multitexture, pname);
a3521 1
         CHECK_EXTENSION_F(ARB_multitexture, pname);
d3527 5
a3531 3
         CHECK_EXTENSION_F(ARB_texture_cube_map, pname);
         *params = (GLfloat) _mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB);
         break;
d3533 5
a3537 3
         CHECK_EXTENSION_F(ARB_texture_cube_map, pname);
         *params = (GLfloat) textureUnit->CurrentCubeMap->Name;
         break;
d3539 5
a3543 3
         CHECK_EXTENSION_F(ARB_texture_cube_map, pname);
         *params = (GLfloat) (1 << (ctx->Const.MaxCubeTextureLevels - 1));
         break;
d3547 5
a3551 2
         CHECK_EXTENSION_F(ARB_texture_compression, pname);
         *params = (GLfloat) ctx->Hint.TextureCompression;
d3554 5
a3558 2
         CHECK_EXTENSION_F(ARB_texture_compression, pname);
         *params = (GLfloat) _mesa_get_compressed_formats(ctx, NULL);
d3561 4
a3564 7
         CHECK_EXTENSION_F(ARB_texture_compression, pname);
         {
            GLint formats[100];
            GLuint i, n;
            n = _mesa_get_compressed_formats(ctx, formats);
            for (i = 0; i < n; i++)
               params[i] = (GLfloat) formats[i];
d3566 2
d3570 50
d3622 3
a3624 1
         CHECK_EXTENSION_F(EXT_compiled_vertex_array, pname);
d3626 1
d3629 3
a3631 1
         CHECK_EXTENSION_F(EXT_compiled_vertex_array, pname);
d3633 1
d3638 1
a3638 1
         _math_transposef(params, ctx->ColorMatrixStack.Top->m);
d3641 1
a3641 1
         _math_transposef(params, ctx->ModelviewMatrixStack.Top->m);
d3644 1
a3644 1
         _math_transposef(params, ctx->ProjectionMatrixStack.Top->m);
d3647 1
a3647 1
         _math_transposef(params, ctx->TextureMatrixStack[texUnit].Top->m);
d3652 7
a3658 3
         CHECK_EXTENSION_F(HP_occlusion_test, pname);
         *params = (GLfloat) ctx->Depth.OcclusionTest;
         break;
d3660 13
a3672 9
         CHECK_EXTENSION_F(HP_occlusion_test, pname);
         if (ctx->Depth.OcclusionTest)
            *params = (GLfloat) ctx->OcclusionResult;
         else
            *params = (GLfloat) ctx->OcclusionResultSaved;
         /* reset flag now */
         ctx->OcclusionResult = GL_FALSE;
         ctx->OcclusionResultSaved = GL_FALSE;
         break;
d3690 1
a3690 1
	    params[i] = ctx->ColorMatrixStack.Top->m[i];
d3694 1
a3694 1
         *params = (GLfloat) (ctx->ColorMatrixStack.Depth + 1);
d3725 5
a3729 11
      case GL_CONVOLUTION_1D_EXT:
         CHECK_EXTENSION_F(EXT_convolution, pname);
         *params = (GLfloat) ctx->Pixel.Convolution1DEnabled;
         break;
      case GL_CONVOLUTION_2D:
         CHECK_EXTENSION_F(EXT_convolution, pname);
         *params = (GLfloat) ctx->Pixel.Convolution2DEnabled;
         break;
      case GL_SEPARABLE_2D:
         CHECK_EXTENSION_F(EXT_convolution, pname);
         *params = (GLfloat) ctx->Pixel.Separable2DEnabled;
a3731 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3734 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3737 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3740 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3743 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3746 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3749 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3752 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3755 10
      /* GL_EXT_histogram (also in 1.2 imaging) */
      case GL_HISTOGRAM:
         CHECK_EXTENSION_F(EXT_histogram, pname);
         *params = (GLfloat) ctx->Pixel.HistogramEnabled;
	 break;
      case GL_MINMAX:
         CHECK_EXTENSION_F(EXT_histogram, pname);
         *params = (GLfloat) ctx->Pixel.MinMaxEnabled;
         break;

a3766 250
      /* GL_EXT_secondary_color */
      case GL_COLOR_SUM_EXT:
         CHECK_EXTENSION_F(EXT_secondary_color, pname);
	 *params = (GLfloat) ctx->Fog.ColorSumEnabled;
	 break;
      case GL_CURRENT_SECONDARY_COLOR_EXT:
         CHECK_EXTENSION_F(EXT_secondary_color, pname);
	 FLUSH_CURRENT(ctx, 0);
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][0];
         params[1] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][1];
         params[2] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][2];
         params[3] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][3];
	 break;
      case GL_SECONDARY_COLOR_ARRAY_EXT:
         CHECK_EXTENSION_F(EXT_secondary_color, pname);
         *params = (GLfloat) ctx->Array.SecondaryColor.Enabled;
         break;
      case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
         CHECK_EXTENSION_F(EXT_secondary_color, pname);
	 *params = (GLfloat) ctx->Array.SecondaryColor.Type;
	 break;
      case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
         CHECK_EXTENSION_F(EXT_secondary_color, pname);
	 *params = (GLfloat) ctx->Array.SecondaryColor.Stride;
	 break;
      case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
         CHECK_EXTENSION_F(EXT_secondary_color, pname);
	 *params = (GLfloat) ctx->Array.SecondaryColor.Size;
	 break;

      /* GL_EXT_fog_coord */
      case GL_CURRENT_FOG_COORDINATE_EXT:
         CHECK_EXTENSION_F(EXT_fog_coord, pname);
	 FLUSH_CURRENT(ctx, 0);
	 *params = (GLfloat) ctx->Current.Attrib[VERT_ATTRIB_FOG][0];
	 break;
      case GL_FOG_COORDINATE_ARRAY_EXT:
         CHECK_EXTENSION_F(EXT_fog_coord, pname);
         *params = (GLfloat) ctx->Array.FogCoord.Enabled;
         break;
      case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
         CHECK_EXTENSION_F(EXT_fog_coord, pname);
	 *params = (GLfloat) ctx->Array.FogCoord.Type;
	 break;
      case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
         CHECK_EXTENSION_F(EXT_fog_coord, pname);
	 *params = (GLfloat) ctx->Array.FogCoord.Stride;
	 break;
      case GL_FOG_COORDINATE_SOURCE_EXT:
         CHECK_EXTENSION_F(EXT_fog_coord, pname);
	 *params = (GLfloat) ctx->Fog.FogCoordinateSource;
	 break;

      /* GL_EXT_texture_lod_bias */
      case GL_MAX_TEXTURE_LOD_BIAS_EXT:
         *params = ctx->Const.MaxTextureLodBias;
         break;

      /* GL_EXT_texture_filter_anisotropic */
      case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
         CHECK_EXTENSION_F(EXT_texture_filter_anisotropic, pname);
         *params = ctx->Const.MaxTextureMaxAnisotropy;
	 break;

      /* GL_ARB_multisample */
      case GL_MULTISAMPLE_ARB:
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = (GLfloat) ctx->Multisample.Enabled;
         break;
      case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = (GLfloat) ctx->Multisample.SampleAlphaToCoverage;
         break;
      case GL_SAMPLE_ALPHA_TO_ONE_ARB:
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = (GLfloat) ctx->Multisample.SampleAlphaToOne;
         break;
      case GL_SAMPLE_COVERAGE_ARB:
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = (GLfloat) ctx->Multisample.SampleCoverage;
         break;
      case GL_SAMPLE_COVERAGE_VALUE_ARB:
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = ctx->Multisample.SampleCoverageValue;
         break;
      case GL_SAMPLE_COVERAGE_INVERT_ARB:
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = (GLfloat) ctx->Multisample.SampleCoverageInvert;
         break;
      case GL_SAMPLE_BUFFERS_ARB:
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = 0.0; /* XXX fix someday */
         break;
      case GL_SAMPLES_ARB:
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = 0.0; /* XXX fix someday */
         break;

      /* GL_IBM_rasterpos_clip */
      case GL_RASTER_POSITION_UNCLIPPED_IBM:
         CHECK_EXTENSION_F(IBM_rasterpos_clip, pname);
         *params = (GLfloat) ctx->Transform.RasterPositionUnclipped;
         break;

      /* GL_NV_point_sprite */
      case GL_POINT_SPRITE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = (GLfloat) ctx->Point.PointSprite;
         break;
      case GL_POINT_SPRITE_R_MODE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = (GLfloat) ctx->Point.SpriteRMode;
         break;

      /* GL_SGIS_generate_mipmap */
      case GL_GENERATE_MIPMAP_HINT_SGIS:
         CHECK_EXTENSION_F(SGIS_generate_mipmap, pname);
         *params = (GLfloat) ctx->Hint.GenerateMipmap;
         break;

#if FEATURE_NV_vertex_program
      case GL_VERTEX_PROGRAM_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) ctx->VertexProgram.Enabled;
         break;
      case GL_VERTEX_PROGRAM_POINT_SIZE_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) ctx->VertexProgram.PointSizeEnabled;
         break;
      case GL_VERTEX_PROGRAM_TWO_SIDE_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) ctx->VertexProgram.TwoSideEnabled;
         break;
      case GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) MAX_PROGRAM_STACK_DEPTH;
         break;
      case GL_MAX_TRACK_MATRICES_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) MAX_PROGRAM_MATRICES;
         break;
      case GL_CURRENT_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) ctx->CurrentStack->Depth + 1;
         break;
      case GL_CURRENT_MATRIX_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         for (i = 0; i < 16; i++)
            params[i] = ctx->CurrentStack->Top->m[i];
         break;
      case GL_VERTEX_PROGRAM_BINDING_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) ctx->VertexProgram.CurrentID;
         break;
      case GL_PROGRAM_ERROR_POSITION_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) ctx->VertexProgram.ErrorPos;
         break;
      case GL_VERTEX_ATTRIB_ARRAY0_NV:
      case GL_VERTEX_ATTRIB_ARRAY1_NV:
      case GL_VERTEX_ATTRIB_ARRAY2_NV:
      case GL_VERTEX_ATTRIB_ARRAY3_NV:
      case GL_VERTEX_ATTRIB_ARRAY4_NV:
      case GL_VERTEX_ATTRIB_ARRAY5_NV:
      case GL_VERTEX_ATTRIB_ARRAY6_NV:
      case GL_VERTEX_ATTRIB_ARRAY7_NV:
      case GL_VERTEX_ATTRIB_ARRAY8_NV:
      case GL_VERTEX_ATTRIB_ARRAY9_NV:
      case GL_VERTEX_ATTRIB_ARRAY10_NV:
      case GL_VERTEX_ATTRIB_ARRAY11_NV:
      case GL_VERTEX_ATTRIB_ARRAY12_NV:
      case GL_VERTEX_ATTRIB_ARRAY13_NV:
      case GL_VERTEX_ATTRIB_ARRAY14_NV:
      case GL_VERTEX_ATTRIB_ARRAY15_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_VERTEX_ATTRIB_ARRAY0_NV;
            *params = (GLfloat) ctx->Array.VertexAttrib[n].Enabled;
         }
         break;
      case GL_MAP1_VERTEX_ATTRIB0_4_NV:
      case GL_MAP1_VERTEX_ATTRIB1_4_NV:
      case GL_MAP1_VERTEX_ATTRIB2_4_NV:
      case GL_MAP1_VERTEX_ATTRIB3_4_NV:
      case GL_MAP1_VERTEX_ATTRIB4_4_NV:
      case GL_MAP1_VERTEX_ATTRIB5_4_NV:
      case GL_MAP1_VERTEX_ATTRIB6_4_NV:
      case GL_MAP1_VERTEX_ATTRIB7_4_NV:
      case GL_MAP1_VERTEX_ATTRIB8_4_NV:
      case GL_MAP1_VERTEX_ATTRIB9_4_NV:
      case GL_MAP1_VERTEX_ATTRIB10_4_NV:
      case GL_MAP1_VERTEX_ATTRIB11_4_NV:
      case GL_MAP1_VERTEX_ATTRIB12_4_NV:
      case GL_MAP1_VERTEX_ATTRIB13_4_NV:
      case GL_MAP1_VERTEX_ATTRIB14_4_NV:
      case GL_MAP1_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP1_VERTEX_ATTRIB0_4_NV;
            *params = (GLfloat) ctx->Eval.Map1Attrib[n];
         }
         break;
      case GL_MAP2_VERTEX_ATTRIB0_4_NV:
      case GL_MAP2_VERTEX_ATTRIB1_4_NV:
      case GL_MAP2_VERTEX_ATTRIB2_4_NV:
      case GL_MAP2_VERTEX_ATTRIB3_4_NV:
      case GL_MAP2_VERTEX_ATTRIB4_4_NV:
      case GL_MAP2_VERTEX_ATTRIB5_4_NV:
      case GL_MAP2_VERTEX_ATTRIB6_4_NV:
      case GL_MAP2_VERTEX_ATTRIB7_4_NV:
      case GL_MAP2_VERTEX_ATTRIB8_4_NV:
      case GL_MAP2_VERTEX_ATTRIB9_4_NV:
      case GL_MAP2_VERTEX_ATTRIB10_4_NV:
      case GL_MAP2_VERTEX_ATTRIB11_4_NV:
      case GL_MAP2_VERTEX_ATTRIB12_4_NV:
      case GL_MAP2_VERTEX_ATTRIB13_4_NV:
      case GL_MAP2_VERTEX_ATTRIB14_4_NV:
      case GL_MAP2_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP2_VERTEX_ATTRIB0_4_NV;
            *params = (GLfloat) ctx->Eval.Map2Attrib[n];
         }
         break;

      /* GL_NV_texture_rectangle */
      case GL_TEXTURE_RECTANGLE_NV:
         CHECK_EXTENSION_F(NV_texture_rectangle, pname);
         *params = (GLfloat) _mesa_IsEnabled(GL_TEXTURE_RECTANGLE_NV);
         break;
      case GL_TEXTURE_BINDING_RECTANGLE_NV:
         CHECK_EXTENSION_F(NV_texture_rectangle, pname);
         *params = (GLfloat) textureUnit->CurrentRect->Name;
         break;
      case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
         CHECK_EXTENSION_F(NV_texture_rectangle, pname);
         *params = (GLfloat) ctx->Const.MaxTextureRectSize;
         break;
#endif /* FEATURE_NV_vertex_program */

      /* GL_EXT_stencil_two_side */
      case GL_STENCIL_TEST_TWO_SIDE_EXT:
         CHECK_EXTENSION_F(EXT_stencil_two_side, pname);
         *params = (GLfloat) ctx->Stencil.TestTwoSide;
         break;
      case GL_ACTIVE_STENCIL_FACE_EXT:
         CHECK_EXTENSION_F(EXT_stencil_two_side, pname);
         *params = (GLfloat) (ctx->Stencil.ActiveFace ? GL_BACK : GL_FRONT);
         break;

d3768 1
a3768 1
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetFloatv(0x%x)", pname);
d3773 2
d3781 1
d3783 2
a3784 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d3789 2
a3790 7
   /* We need this in order to get correct results for
    * GL_OCCLUSION_TEST_RESULT_HP.  There might be other important cases.
    */
   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGetIntegerv %s\n", _mesa_lookup_enum_by_nr(pname));
d3798 1
a3798 1
         *params = (GLint) ctx->Visual.accumRedBits;
d3801 1
a3801 1
         *params = (GLint) ctx->Visual.accumGreenBits;
d3804 1
a3804 1
         *params = (GLint) ctx->Visual.accumBlueBits;
d3807 1
a3807 1
         *params = (GLint) ctx->Visual.accumAlphaBits;
d3819 1
a3819 1
         *params = ctx->Visual.alphaBits;
d3828 1
a3828 1
         *params = FLOAT_TO_INT(ctx->Color.AlphaRef);
d3876 1
a3876 1
         *params = (GLint) ctx->Visual.blueBits;
d3890 2
a3891 4
         if (ctx->Transform.ClipPlanesEnabled & (1 << (pname - GL_CLIP_PLANE0)))
            *params = 1;
         else
            *params = 0;
d3894 4
a3897 4
         params[0] = FLOAT_TO_INT( (ctx->Color.ClearColor[0]) );
         params[1] = FLOAT_TO_INT( (ctx->Color.ClearColor[1]) );
         params[2] = FLOAT_TO_INT( (ctx->Color.ClearColor[2]) );
         params[3] = FLOAT_TO_INT( (ctx->Color.ClearColor[3]) );
d3921 4
a3924 5
	 FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0]);
         params[1] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1]);
         params[2] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2]);
         params[3] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3]);
a3926 1
	 FLUSH_CURRENT(ctx, 0);
d3930 3
a3932 4
	 FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][0]);
         params[1] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][1]);
         params[2] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][2]);
d3953 4
a3956 4
	 params[0] = (GLint) ctx->Current.RasterTexCoords[texUnit][0];
	 params[1] = (GLint) ctx->Current.RasterTexCoords[texUnit][1];
	 params[2] = (GLint) ctx->Current.RasterTexCoords[texUnit][2];
	 params[3] = (GLint) ctx->Current.RasterTexCoords[texUnit][3];
d3962 4
a3965 5
	 FLUSH_CURRENT(ctx, 0);
         params[0] = (GLint) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][0];
         params[1] = (GLint) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][1];
         params[2] = (GLint) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][2];
         params[3] = (GLint) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][3];
d3971 1
a3971 1
	 *params = ctx->Visual.depthBits;
d3996 1
a3996 1
	 *params = (GLint) ctx->Visual.doubleBufferMode;
a4001 1
	 FLUSH_CURRENT(ctx, 0);
d4044 1
a4044 1
         *params = (GLint) ctx->Visual.greenBits;
d4049 3
d4053 1
a4053 1
         *params = (GLint) ctx->Visual.indexBits;
d4059 1
a4059 1
	 *params = ctx->Visual.rgbMode ? 0 : 1;
d4134 2
a4135 6
         if (!ctx->CompileFlag)
            *params = 0;
         else if (ctx->ExecuteFlag)
            *params = (GLint) GL_COMPILE_AND_EXECUTE;
         else
            *params = (GLint) GL_COMPILE;
d4233 1
a4233 1
         *params = (GLint) ctx->Const.MaxClipPlanes;
d4236 1
a4236 1
         *params = (GLint) ctx->Const.MaxArrayLockSize;
d4239 1
a4239 1
         *params = (GLint) ctx->Const.MaxArrayLockSize;
d4245 1
a4245 1
         *params = (GLint) ctx->Const.MaxLights;
a4262 2
         *params = (1 << (ctx->Const.MaxTextureLevels - 1));
	 break;
d4264 1
a4264 1
         *params = (1 << (ctx->Const.Max3DTextureLevels - 1));
d4273 3
d4278 1
a4278 1
	    params[i] = (GLint) ctx->ModelviewMatrixStack.Top->m[i];
d4282 1
a4282 1
	 *params = (GLint) (ctx->ModelviewMatrixStack.Depth + 1);
a4313 3
      case GL_PACK_INVERT_MESA:
         *params = ctx->Pack.Invert;
         break;
d4348 1
a4348 1
         *params = (GLint) ctx->Point.Size;
d4405 1
a4405 1
	    params[i] = (GLint) ctx->ProjectionMatrixStack.Top->m[i];
d4409 1
a4409 1
	 *params = (GLint) (ctx->ProjectionMatrixStack.Depth + 1);
d4418 1
a4418 1
         *params = (GLint) ctx->Visual.redBits;
d4430 1
a4430 1
	 *params = (GLint) ctx->Visual.rgbMode;
d4451 1
a4451 1
         *params = ctx->Visual.stencilBits;
d4457 1
a4457 1
	 *params = (GLint) ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace];
d4460 1
a4460 1
	 *params = (GLint) ctx->Stencil.Function[ctx->Stencil.ActiveFace];
d4463 1
a4463 1
	 *params = (GLint) ctx->Stencil.ZFailFunc[ctx->Stencil.ActiveFace];
d4466 1
a4466 1
	 *params = (GLint) ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace];
d4469 1
a4469 1
	 *params = (GLint) ctx->Stencil.Ref[ctx->Stencil.ActiveFace];
d4475 1
a4475 1
	 *params = (GLint) ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace];
d4478 1
a4478 1
	 *params = (GLint) ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace];
d4481 1
a4481 1
	 *params = (GLint) ctx->Visual.stereoMode;
d4496 1
a4496 1
         *params = textureUnit->Current1D->Name;
d4499 1
a4499 1
         *params = textureUnit->Current2D->Name;
d4502 1
a4502 1
         *params = textureUnit->Current3D->Name;
d4527 1
a4527 1
	    params[i] = (GLint) ctx->TextureMatrixStack[texUnit].Top->m[i];
d4531 1
a4531 1
	 *params = (GLint) (ctx->TextureMatrixStack[texUnit].Depth + 1);
a4556 3
      case GL_UNPACK_CLIENT_STORAGE_APPLE:
         *params = ctx->Unpack.ClientStorage;
         break;
d4570 3
d4574 1
d4577 3
d4581 1
d4584 3
d4588 1
d4591 3
d4595 1
d4601 3
d4605 1
d4608 3
d4612 1
d4615 3
d4619 1
d4625 3
d4629 1
d4632 3
d4636 1
d4639 3
d4643 1
d4646 3
d4650 1
d4656 3
d4660 1
d4663 3
d4667 1
d4670 3
d4674 1
d4680 3
d4684 1
d4687 3
d4691 1
d4694 3
d4698 1
d4701 3
d4705 1
d4711 3
d4715 1
d4718 3
d4722 1
a4729 1
         CHECK_EXTENSION_I(ARB_multitexture, pname);
a4732 1
         CHECK_EXTENSION_I(ARB_multitexture, pname);
a4735 1
         CHECK_EXTENSION_I(ARB_multitexture, pname);
d4741 5
a4745 3
         CHECK_EXTENSION_I(ARB_texture_cube_map, pname);
         *params = (GLint) _mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB);
         break;
d4747 5
a4751 3
         CHECK_EXTENSION_I(ARB_texture_cube_map, pname);
         *params = textureUnit->CurrentCubeMap->Name;
         break;
d4753 5
a4757 3
         CHECK_EXTENSION_I(ARB_texture_cube_map, pname);
         *params = (1 << (ctx->Const.MaxCubeTextureLevels - 1));
         break;
d4761 5
a4765 2
         CHECK_EXTENSION_I(ARB_texture_compression, pname);
         *params = (GLint) ctx->Hint.TextureCompression;
d4768 5
a4772 2
         CHECK_EXTENSION_I(ARB_texture_compression, pname);
         *params = (GLint) _mesa_get_compressed_formats(ctx, NULL);
d4775 12
a4786 2
         CHECK_EXTENSION_I(ARB_texture_compression, pname);
         (void) _mesa_get_compressed_formats(ctx, params);
d4788 45
d4836 3
a4838 1
         CHECK_EXTENSION_I(EXT_compiled_vertex_array, pname);
d4840 1
d4843 3
a4845 1
         CHECK_EXTENSION_I(EXT_compiled_vertex_array, pname);
d4847 1
d4849 1
a4849 1

d4855 1
a4855 1
            _math_transposef(tm, ctx->ColorMatrixStack.Top->m);
d4865 1
a4865 1
            _math_transposef(tm, ctx->ModelviewMatrixStack.Top->m);
d4875 1
a4875 1
            _math_transposef(tm, ctx->ProjectionMatrixStack.Top->m);
d4885 1
a4885 1
            _math_transposef(tm, ctx->TextureMatrixStack[texUnit].Top->m);
d4894 7
a4900 3
         CHECK_EXTENSION_I(HP_occlusion_test, pname);
         *params = (GLint) ctx->Depth.OcclusionTest;
         break;
d4902 13
a4914 9
         CHECK_EXTENSION_I(HP_occlusion_test, pname);
         if (ctx->Depth.OcclusionTest)
            *params = (GLint) ctx->OcclusionResult;
         else
            *params = (GLint) ctx->OcclusionResultSaved;
         /* reset flag now */
         ctx->OcclusionResult = GL_FALSE;
         ctx->OcclusionResultSaved = GL_FALSE;
         break;
a4917 1
         CHECK_EXTENSION_I(SGIS_pixel_texture, pname);
a4922 1
         CHECK_EXTENSION_I(SGIX_pixel_texture, pname);
a4925 1
         CHECK_EXTENSION_I(SGIX_pixel_texture, pname);
a4930 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
d4932 1
a4932 1
	    params[i] = (GLint) ctx->ColorMatrixStack.Top->m[i];
d4936 1
a4936 2
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
         *params = ctx->ColorMatrixStack.Depth + 1;
a4938 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a4941 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a4944 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a4947 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a4950 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a4953 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a4956 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a4959 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a4962 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
d4967 5
a4971 11
      case GL_CONVOLUTION_1D_EXT:
         CHECK_EXTENSION_I(EXT_convolution, pname);
         *params = (GLint) ctx->Pixel.Convolution1DEnabled;
         break;
      case GL_CONVOLUTION_2D:
         CHECK_EXTENSION_I(EXT_convolution, pname);
         *params = (GLint) ctx->Pixel.Convolution2DEnabled;
         break;
      case GL_SEPARABLE_2D:
         CHECK_EXTENSION_I(EXT_convolution, pname);
         *params = (GLint) ctx->Pixel.Separable2DEnabled;
a4973 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a4976 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a4979 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a4982 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a4985 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a4988 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a4991 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a4994 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a4997 10
      /* GL_EXT_histogram (also in 1.2 imaging) */
      case GL_HISTOGRAM:
         CHECK_EXTENSION_I(EXT_histogram, pname);
         *params = (GLint) ctx->Pixel.HistogramEnabled;
	 break;
      case GL_MINMAX:
         CHECK_EXTENSION_I(EXT_histogram, pname);
         *params = (GLint) ctx->Pixel.MinMaxEnabled;
         break;

a4999 1
         CHECK_EXTENSION_I(SGI_color_table, pname);
a5002 1
         CHECK_EXTENSION_I(SGI_color_table, pname);
a5005 1
         CHECK_EXTENSION_I(SGI_color_table, pname);
a5008 251

      /* GL_EXT_secondary_color */
      case GL_COLOR_SUM_EXT:
         CHECK_EXTENSION_I(EXT_secondary_color, pname);
	 *params = (GLint) ctx->Fog.ColorSumEnabled;
	 break;
      case GL_CURRENT_SECONDARY_COLOR_EXT:
         CHECK_EXTENSION_I(EXT_secondary_color, pname);
	 FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_INT( (ctx->Current.Attrib[VERT_ATTRIB_COLOR1][0]) );
         params[1] = FLOAT_TO_INT( (ctx->Current.Attrib[VERT_ATTRIB_COLOR1][1]) );
         params[2] = FLOAT_TO_INT( (ctx->Current.Attrib[VERT_ATTRIB_COLOR1][2]) );
         params[3] = FLOAT_TO_INT( (ctx->Current.Attrib[VERT_ATTRIB_COLOR1][3]) );
	 break;
      case GL_SECONDARY_COLOR_ARRAY_EXT:
         CHECK_EXTENSION_I(EXT_secondary_color, pname);
         *params = (GLint) ctx->Array.SecondaryColor.Enabled;
         break;
      case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
         CHECK_EXTENSION_I(EXT_secondary_color, pname);
	 *params = (GLint) ctx->Array.SecondaryColor.Type;
	 break;
      case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
         CHECK_EXTENSION_I(EXT_secondary_color, pname);
	 *params = (GLint) ctx->Array.SecondaryColor.Stride;
	 break;
      case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
         CHECK_EXTENSION_I(EXT_secondary_color, pname);
	 *params = (GLint) ctx->Array.SecondaryColor.Size;
	 break;

      /* GL_EXT_fog_coord */
      case GL_CURRENT_FOG_COORDINATE_EXT:
         CHECK_EXTENSION_I(EXT_fog_coord, pname);
         FLUSH_CURRENT(ctx, 0);
         *params = (GLint) ctx->Current.Attrib[VERT_ATTRIB_FOG][0];
	 break;
      case GL_FOG_COORDINATE_ARRAY_EXT:
         CHECK_EXTENSION_I(EXT_fog_coord, pname);
         *params = (GLint) ctx->Array.FogCoord.Enabled;
         break;
      case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
         CHECK_EXTENSION_I(EXT_fog_coord, pname);
         *params = (GLint) ctx->Array.FogCoord.Type;
	 break;
      case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
         CHECK_EXTENSION_I(EXT_fog_coord, pname);
         *params = (GLint) ctx->Array.FogCoord.Stride;
	 break;
      case GL_FOG_COORDINATE_SOURCE_EXT:
         CHECK_EXTENSION_I(EXT_fog_coord, pname);
	 *params = (GLint) ctx->Fog.FogCoordinateSource;
	 break;

      /* GL_EXT_texture_lod_bias */
      case GL_MAX_TEXTURE_LOD_BIAS_EXT:
         *params = (GLint) ctx->Const.MaxTextureLodBias;
         break;

      /* GL_EXT_texture_filter_anisotropic */
      case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
         CHECK_EXTENSION_I(EXT_texture_filter_anisotropic, pname);
         *params = (GLint) ctx->Const.MaxTextureMaxAnisotropy;
	 break;

      /* GL_ARB_multisample */
      case GL_MULTISAMPLE_ARB:
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = (GLint) ctx->Multisample.Enabled;
         break;
      case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = (GLint) ctx->Multisample.SampleAlphaToCoverage;
         break;
      case GL_SAMPLE_ALPHA_TO_ONE_ARB:
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = (GLint) ctx->Multisample.SampleAlphaToOne;
         break;
      case GL_SAMPLE_COVERAGE_ARB:
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = (GLint) ctx->Multisample.SampleCoverage;
         break;
      case GL_SAMPLE_COVERAGE_VALUE_ARB:
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = (GLint) ctx->Multisample.SampleCoverageValue;
         break;
      case GL_SAMPLE_COVERAGE_INVERT_ARB:
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = (GLint) ctx->Multisample.SampleCoverageInvert;
         break;
      case GL_SAMPLE_BUFFERS_ARB:
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = 0; /* XXX fix someday */
         break;
      case GL_SAMPLES_ARB:
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = 0; /* XXX fix someday */
         break;

      /* GL_IBM_rasterpos_clip */
      case GL_RASTER_POSITION_UNCLIPPED_IBM:
         CHECK_EXTENSION_I(IBM_rasterpos_clip, pname);
         *params = (GLint) ctx->Transform.RasterPositionUnclipped;
         break;

      /* GL_NV_point_sprite */
      case GL_POINT_SPRITE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = (GLint) ctx->Point.PointSprite;
         break;
      case GL_POINT_SPRITE_R_MODE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = (GLint) ctx->Point.SpriteRMode;
         break;

      /* GL_SGIS_generate_mipmap */
      case GL_GENERATE_MIPMAP_HINT_SGIS:
         CHECK_EXTENSION_I(SGIS_generate_mipmap, pname);
         *params = (GLint) ctx->Hint.GenerateMipmap;
         break;

#if FEATURE_NV_vertex_program
      case GL_VERTEX_PROGRAM_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = (GLint) ctx->VertexProgram.Enabled;
         break;
      case GL_VERTEX_PROGRAM_POINT_SIZE_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = (GLint) ctx->VertexProgram.PointSizeEnabled;
         break;
      case GL_VERTEX_PROGRAM_TWO_SIDE_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = (GLint) ctx->VertexProgram.TwoSideEnabled;
         break;
      case GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = MAX_PROGRAM_STACK_DEPTH;
         break;
      case GL_MAX_TRACK_MATRICES_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = MAX_PROGRAM_MATRICES;
         break;
      case GL_CURRENT_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = ctx->CurrentStack->Depth + 1;
         break;
      case GL_CURRENT_MATRIX_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         for (i = 0; i < 16; i++)
            params[i] = (GLint) ctx->CurrentStack->Top->m[i];
         break;
      case GL_VERTEX_PROGRAM_BINDING_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = (GLint) ctx->VertexProgram.CurrentID;
         break;
      case GL_PROGRAM_ERROR_POSITION_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = (GLint) ctx->VertexProgram.ErrorPos;
         break;
      case GL_VERTEX_ATTRIB_ARRAY0_NV:
      case GL_VERTEX_ATTRIB_ARRAY1_NV:
      case GL_VERTEX_ATTRIB_ARRAY2_NV:
      case GL_VERTEX_ATTRIB_ARRAY3_NV:
      case GL_VERTEX_ATTRIB_ARRAY4_NV:
      case GL_VERTEX_ATTRIB_ARRAY5_NV:
      case GL_VERTEX_ATTRIB_ARRAY6_NV:
      case GL_VERTEX_ATTRIB_ARRAY7_NV:
      case GL_VERTEX_ATTRIB_ARRAY8_NV:
      case GL_VERTEX_ATTRIB_ARRAY9_NV:
      case GL_VERTEX_ATTRIB_ARRAY10_NV:
      case GL_VERTEX_ATTRIB_ARRAY11_NV:
      case GL_VERTEX_ATTRIB_ARRAY12_NV:
      case GL_VERTEX_ATTRIB_ARRAY13_NV:
      case GL_VERTEX_ATTRIB_ARRAY14_NV:
      case GL_VERTEX_ATTRIB_ARRAY15_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_VERTEX_ATTRIB_ARRAY0_NV;
            *params = (GLint) ctx->Array.VertexAttrib[n].Enabled;
         }
         break;
      case GL_MAP1_VERTEX_ATTRIB0_4_NV:
      case GL_MAP1_VERTEX_ATTRIB1_4_NV:
      case GL_MAP1_VERTEX_ATTRIB2_4_NV:
      case GL_MAP1_VERTEX_ATTRIB3_4_NV:
      case GL_MAP1_VERTEX_ATTRIB4_4_NV:
      case GL_MAP1_VERTEX_ATTRIB5_4_NV:
      case GL_MAP1_VERTEX_ATTRIB6_4_NV:
      case GL_MAP1_VERTEX_ATTRIB7_4_NV:
      case GL_MAP1_VERTEX_ATTRIB8_4_NV:
      case GL_MAP1_VERTEX_ATTRIB9_4_NV:
      case GL_MAP1_VERTEX_ATTRIB10_4_NV:
      case GL_MAP1_VERTEX_ATTRIB11_4_NV:
      case GL_MAP1_VERTEX_ATTRIB12_4_NV:
      case GL_MAP1_VERTEX_ATTRIB13_4_NV:
      case GL_MAP1_VERTEX_ATTRIB14_4_NV:
      case GL_MAP1_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP1_VERTEX_ATTRIB0_4_NV;
            *params = (GLint) ctx->Eval.Map1Attrib[n];
         }
         break;
      case GL_MAP2_VERTEX_ATTRIB0_4_NV:
      case GL_MAP2_VERTEX_ATTRIB1_4_NV:
      case GL_MAP2_VERTEX_ATTRIB2_4_NV:
      case GL_MAP2_VERTEX_ATTRIB3_4_NV:
      case GL_MAP2_VERTEX_ATTRIB4_4_NV:
      case GL_MAP2_VERTEX_ATTRIB5_4_NV:
      case GL_MAP2_VERTEX_ATTRIB6_4_NV:
      case GL_MAP2_VERTEX_ATTRIB7_4_NV:
      case GL_MAP2_VERTEX_ATTRIB8_4_NV:
      case GL_MAP2_VERTEX_ATTRIB9_4_NV:
      case GL_MAP2_VERTEX_ATTRIB10_4_NV:
      case GL_MAP2_VERTEX_ATTRIB11_4_NV:
      case GL_MAP2_VERTEX_ATTRIB12_4_NV:
      case GL_MAP2_VERTEX_ATTRIB13_4_NV:
      case GL_MAP2_VERTEX_ATTRIB14_4_NV:
      case GL_MAP2_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP2_VERTEX_ATTRIB0_4_NV;
            *params = (GLint) ctx->Eval.Map2Attrib[n];
         }
         break;

      /* GL_NV_texture_rectangle */
      case GL_TEXTURE_RECTANGLE_NV:
         CHECK_EXTENSION_I(NV_texture_rectangle, pname);
         *params = (GLint) _mesa_IsEnabled(GL_TEXTURE_RECTANGLE_NV);
         break;
      case GL_TEXTURE_BINDING_RECTANGLE_NV:
         CHECK_EXTENSION_I(NV_texture_rectangle, pname);
         *params = (GLint) textureUnit->CurrentRect->Name;
         break;
      case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
         CHECK_EXTENSION_I(NV_texture_rectangle, pname);
         *params = (GLint) ctx->Const.MaxTextureRectSize;
         break;
#endif /* FEATURE_NV_vertex_program */

      /* GL_EXT_stencil_two_side */
      case GL_STENCIL_TEST_TWO_SIDE_EXT:
         CHECK_EXTENSION_I(EXT_stencil_two_side, pname);
         *params = (GLint) ctx->Stencil.TestTwoSide;
         break;
      case GL_ACTIVE_STENCIL_FACE_EXT:
         CHECK_EXTENSION_I(EXT_stencil_two_side, pname);
         *params = (GLint) (ctx->Stencil.ActiveFace ? GL_BACK : GL_FRONT);
         break;

d5010 1
a5010 1
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv(pname=0x%x)", pname);
d5021 2
a5022 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d5027 2
a5028 2
   if (MESA_VERBOSE & VERBOSE_API)
      _mesa_debug(ctx, "glGetPointerv %s\n", _mesa_lookup_enum_by_nr(pname));
d5036 3
d5040 1
d5043 3
d5047 1
d5050 3
d5054 1
a5054 6
         break;
      case GL_SECONDARY_COLOR_ARRAY_POINTER_EXT:
         *params = ctx->Array.SecondaryColor.Ptr;
         break;
      case GL_FOG_COORDINATE_ARRAY_POINTER_EXT:
         *params = ctx->Array.FogCoord.Ptr;
d5057 3
d5061 1
d5064 3
d5068 1
d5071 3
d5075 1
d5084 1
a5084 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetPointerv" );
d5097 1
a5097 3
   static const char *version_1_2 = "1.2 Mesa 5.0.2";
   static const char *version_1_3 = "1.3 Mesa 5.0.2";
   static const char *version_1_4 = "1.4 Mesa 5.0.2";
d5099 1
a5099 1
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);
d5108 13
a5120 46
      switch (name) {
         case GL_VENDOR:
            return (const GLubyte *) vendor;
         case GL_RENDERER:
            return (const GLubyte *) renderer;
         case GL_VERSION:
            if (ctx->Extensions.ARB_multisample &&
                ctx->Extensions.ARB_multitexture &&
                ctx->Extensions.ARB_texture_border_clamp &&
                ctx->Extensions.ARB_texture_compression &&
                ctx->Extensions.ARB_texture_cube_map &&
                ctx->Extensions.EXT_texture_env_add &&
                ctx->Extensions.ARB_texture_env_combine &&
                ctx->Extensions.ARB_texture_env_dot3) {
               if (ctx->Extensions.ARB_depth_texture &&
                   ctx->Extensions.ARB_shadow &&
                   ctx->Extensions.ARB_texture_env_crossbar &&
                   ctx->Extensions.ARB_texture_mirrored_repeat &&
                   ctx->Extensions.ARB_window_pos &&
                   ctx->Extensions.EXT_blend_color &&
                   ctx->Extensions.EXT_blend_func_separate &&
                   ctx->Extensions.EXT_blend_logic_op &&
                   ctx->Extensions.EXT_blend_minmax &&
                   ctx->Extensions.EXT_blend_subtract &&
                   ctx->Extensions.EXT_fog_coord &&
                   ctx->Extensions.EXT_multi_draw_arrays &&
                   ctx->Extensions.EXT_point_parameters && /*aka ARB*/
                   ctx->Extensions.EXT_secondary_color &&
                   ctx->Extensions.EXT_stencil_wrap &&
                   ctx->Extensions.EXT_texture_lod_bias &&
                   ctx->Extensions.SGIS_generate_mipmap) {
                  return (const GLubyte *) version_1_4;
               }
               else {
                  return (const GLubyte *) version_1_3;
               }
            }
            else {
               return (const GLubyte *) version_1_2;
            }
         case GL_EXTENSIONS:
            return (const GLubyte *) _mesa_extensions_get_string(ctx);
         default:
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetString" );
            return (const GLubyte *) 0;
      }
d5132 1
d5134 2
a5135 1
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);
d5138 1
a5138 1
      _mesa_debug(ctx, "glGetError <-- %s\n", _mesa_lookup_enum_by_nr(e));
d5143 1
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d4 4
a7 4
 * Version:  4.0.4
 *
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
 *
d14 1
a14 1
 *
d17 1
a17 1
 *
a30 1
#include "colormac.h"
d37 1
d39 2
a40 3
#include "mtypes.h"

#include "math/m_matrix.h"
a59 37

/* Check if named extension is enabled, if not generate error and return */

#define CHECK_EXTENSION_B(EXTNAME, PNAME)			\
   if (!ctx->Extensions.EXTNAME) {				\
      char message[100];					\
      sprintf(message, "glGetBooleanv(0x%x)", (int) PNAME);	\
      _mesa_error(ctx, GL_INVALID_VALUE, message);		\
      return;							\
   }	

#define CHECK_EXTENSION_I(EXTNAME, PNAME)			\
   if (!ctx->Extensions.EXTNAME) {				\
      char message[100];					\
      sprintf(message, "glGetIntegerv(0x%x)", (int) PNAME);	\
      _mesa_error(ctx, GL_INVALID_VALUE, message);		\
      return;							\
   }	

#define CHECK_EXTENSION_F(EXTNAME, PNAME)			\
   if (!ctx->Extensions.EXTNAME) {				\
      char message[100];					\
      sprintf(message, "glGetFloatv(0x%x)", (int) PNAME);	\
      _mesa_error(ctx, GL_INVALID_VALUE, message);		\
      return;							\
   }	

#define CHECK_EXTENSION_D(EXTNAME, PNAME)			\
   if (!ctx->Extensions.EXTNAME) {				\
      char message[100];					\
      sprintf(message, "glGetDoublev(0x%x)", (int) PNAME);	\
      _mesa_error(ctx, GL_INVALID_VALUE, message);		\
      return;							\
   }	



d82 1
d89 1
d91 2
a92 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d97 2
a98 7
   /* We need this in order to get correct results for
    * GL_OCCLUSION_TEST_RESULT_HP.  There might be other important cases.
    */
   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      fprintf(stderr, "glGetBooleanv %s\n", _mesa_lookup_enum_by_nr(pname));
d106 1
a106 1
         *params = INT_TO_BOOL(ctx->Visual.accumRedBits);
d109 1
a109 1
         *params = INT_TO_BOOL(ctx->Visual.accumGreenBits);
d112 1
a112 1
         *params = INT_TO_BOOL(ctx->Visual.accumBlueBits);
d115 1
a115 1
         *params = INT_TO_BOOL(ctx->Visual.accumAlphaBits);
d127 1
a127 1
         *params = INT_TO_BOOL(ctx->Visual.alphaBits);
d139 1
a139 1
         *params = FLOAT_TO_BOOL((GLfloat) ctx->Color.AlphaRef / CHAN_MAXF);
d184 1
a184 1
         *params = INT_TO_BOOL( ctx->Visual.blueBits );
d201 4
a204 4
         params[0] = ctx->Color.ClearColor[0] ? GL_TRUE : GL_FALSE;
         params[1] = ctx->Color.ClearColor[1] ? GL_TRUE : GL_FALSE;
         params[2] = ctx->Color.ClearColor[2] ? GL_TRUE : GL_FALSE;
         params[3] = ctx->Color.ClearColor[3] ? GL_TRUE : GL_FALSE;
d228 4
a231 5
	 FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_BOOL(ctx->Current.Color[0]);
         params[1] = FLOAT_TO_BOOL(ctx->Current.Color[1]);
         params[2] = FLOAT_TO_BOOL(ctx->Current.Color[2]);
         params[3] = FLOAT_TO_BOOL(ctx->Current.Color[3]);
a233 1
	 FLUSH_CURRENT(ctx, 0);
a236 1
	 FLUSH_CURRENT(ctx, 0);
d260 4
a263 4
         params[0] = FLOAT_TO_BOOL(ctx->Current.RasterMultiTexCoord[texUnit][0]);
         params[1] = FLOAT_TO_BOOL(ctx->Current.RasterMultiTexCoord[texUnit][1]);
         params[2] = FLOAT_TO_BOOL(ctx->Current.RasterMultiTexCoord[texUnit][2]);
         params[3] = FLOAT_TO_BOOL(ctx->Current.RasterMultiTexCoord[texUnit][3]);
d269 4
a272 5
	 FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_BOOL(ctx->Current.Texcoord[texUnit][0]);
         params[1] = FLOAT_TO_BOOL(ctx->Current.Texcoord[texUnit][1]);
         params[2] = FLOAT_TO_BOOL(ctx->Current.Texcoord[texUnit][2]);
         params[3] = FLOAT_TO_BOOL(ctx->Current.Texcoord[texUnit][3]);
d278 1
a278 1
	 *params = INT_TO_BOOL(ctx->Visual.depthBits);
d303 1
a303 1
	 *params = ctx->Visual.doubleBufferMode;
a308 1
	 FLUSH_CURRENT(ctx, 0);
d351 1
a351 1
         *params = INT_TO_BOOL( ctx->Visual.greenBits );
d357 1
a357 7
         if (ctx->Extensions.EXT_histogram) {
            *params = ctx->Pixel.HistogramEnabled;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
            return;
         }
d360 1
a360 1
         *params = INT_TO_BOOL( ctx->Visual.indexBits );
d366 1
a366 1
	 *params = ctx->Visual.rgbMode ? GL_FALSE : GL_TRUE;
d540 1
a540 1
	 *params = INT_TO_BOOL(ctx->Const.MaxClipPlanes);
d543 1
a543 1
         *params = INT_TO_BOOL(ctx->Const.MaxArrayLockSize);
d546 1
a546 1
         *params = INT_TO_BOOL(ctx->Const.MaxArrayLockSize);
d552 1
a552 1
	 *params = INT_TO_BOOL(ctx->Const.MaxLights);
a569 2
         *params = INT_TO_BOOL(1 << (ctx->Const.MaxTextureLevels - 1));
	 break;
d571 1
a571 1
         *params = INT_TO_BOOL(1 << (ctx->Const.Max3DTextureLevels - 1));
a620 3
      case GL_PACK_INVERT_MESA:
         *params = ctx->Pack.Invert;
         break;
d655 1
a655 1
	 *params = FLOAT_TO_BOOL(ctx->Point.Size);
d725 1
a725 1
         *params = INT_TO_BOOL( ctx->Visual.redBits );
d737 1
a737 1
         *params = ctx->Visual.rgbMode;
d758 1
a758 1
	 *params = INT_TO_BOOL(ctx->Visual.stencilBits);
d788 1
a788 1
	 *params = ctx->Visual.stereoMode;
d803 1
a803 1
         *params = INT_TO_BOOL(textureUnit->Current1D->Name);
d806 1
a806 1
         *params = INT_TO_BOOL(textureUnit->Current2D->Name);
d809 1
a809 1
         *params = INT_TO_BOOL(textureUnit->Current3D->Name);
d836 2
a837 2
	    params[i] =
	       FLOAT_TO_BOOL(ctx->TextureMatrix[texUnit].m[i]);
d841 1
a841 1
	 *params = INT_TO_BOOL(ctx->TextureStackDepth[texUnit] + 1);
a866 3
      case GL_UNPACK_CLIENT_STORAGE_APPLE:
         *params = ctx->Unpack.ClientStorage;
         break;
d880 3
d884 1
d887 3
d891 1
d894 3
d898 1
d901 3
d905 1
d911 3
d915 1
d918 3
d922 1
d925 3
d929 1
d935 3
d939 1
d942 3
d946 1
d949 3
d953 1
d956 3
d960 1
d966 3
d970 1
d973 3
d977 1
d980 3
d984 1
d990 3
d994 1
d997 3
d1001 1
d1004 3
d1008 1
d1011 3
d1015 1
d1021 3
d1025 1
d1028 3
d1032 1
a1032 3
         break;
      case GL_EDGE_FLAG_ARRAY_COUNT_EXT:
         *params = INT_TO_BOOL(0);
d1048 1
a1048 1
         if (ctx->Extensions.ARB_texture_cube_map)
d1051 1
a1051 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
d1054 1
a1054 1
         if (ctx->Extensions.ARB_texture_cube_map)
d1057 1
a1057 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
d1060 2
a1061 2
         if (ctx->Extensions.ARB_texture_cube_map)
            *params = INT_TO_BOOL(1 << (ctx->Const.MaxCubeTextureLevels - 1));
d1063 1
a1063 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
d1068 1
a1068 1
         if (ctx->Extensions.ARB_texture_compression) {
d1072 1
a1072 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
d1075 1
a1075 1
         if (ctx->Extensions.ARB_texture_compression) {
d1079 1
a1079 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
d1082 1
a1082 1
         if (ctx->Extensions.ARB_texture_compression) {
d1088 6
a1093 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
d1095 45
d1143 3
d1147 1
d1150 3
d1154 1
d1162 1
a1162 1
            _math_transposef(tm, ctx->ColorMatrix.m);
d1172 1
a1172 1
            _math_transposef(tm, ctx->ModelView.m);
d1182 1
a1182 1
            _math_transposef(tm, ctx->ProjectionMatrix.m);
d1192 1
a1192 1
            _math_transposef(tm, ctx->TextureMatrix[texUnit].m);
d1201 1
a1201 1
         if (ctx->Extensions.HP_occlusion_test) {
d1205 1
a1205 1
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetBooleanv" );
d1209 1
a1209 1
         if (ctx->Extensions.HP_occlusion_test) {
d1219 1
a1219 1
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetBooleanv" );
d1274 2
a1275 17
      case GL_CONVOLUTION_1D_EXT:
         if (ctx->Extensions.EXT_convolution || ctx->Extensions.ARB_imaging) {
            *params = ctx->Pixel.Convolution1DEnabled;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
            return;
         }
         break;
      case GL_CONVOLUTION_2D:
         if (ctx->Extensions.EXT_convolution || ctx->Extensions.ARB_imaging) {
            *params = ctx->Pixel.Convolution2DEnabled;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
            return;
         }
d1277 2
a1278 8
      case GL_SEPARABLE_2D:
         if (ctx->Extensions.EXT_convolution || ctx->Extensions.ARB_imaging) {
            *params = ctx->Pixel.Separable2DEnabled;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
            return;
         }
a1315 164
      /* GL_EXT_secondary_color */
      case GL_COLOR_SUM_EXT:
	 *params = ctx->Fog.ColorSumEnabled;
	 break;
      case GL_CURRENT_SECONDARY_COLOR_EXT:
	 FLUSH_CURRENT(ctx, 0);
         params[0] = INT_TO_BOOL(ctx->Current.SecondaryColor[0]);
         params[1] = INT_TO_BOOL(ctx->Current.SecondaryColor[1]);
         params[2] = INT_TO_BOOL(ctx->Current.SecondaryColor[2]);
	 break;
      case GL_SECONDARY_COLOR_ARRAY_EXT:
         *params = ctx->Array.SecondaryColor.Enabled;
         break;
      case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
	 *params = ENUM_TO_BOOL(ctx->Array.SecondaryColor.Type);
	 break;
      case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
	 *params = INT_TO_BOOL(ctx->Array.SecondaryColor.Stride);
	 break;
      case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
	 *params = INT_TO_BOOL(ctx->Array.SecondaryColor.Stride);
	 break;

      /* GL_EXT_fog_coord */
      case GL_CURRENT_FOG_COORDINATE_EXT:
	 FLUSH_CURRENT(ctx, 0);
	 *params = FLOAT_TO_BOOL(ctx->Current.FogCoord);
	 break;
      case GL_FOG_COORDINATE_ARRAY_EXT:
         *params = ctx->Array.FogCoord.Enabled;
         break;
      case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
	 *params = ENUM_TO_BOOL(ctx->Array.FogCoord.Type);
	 break;
      case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
	 *params = INT_TO_BOOL(ctx->Array.FogCoord.Stride);
	 break;

      /* GL_EXT_texture_lod_bias */
      case GL_MAX_TEXTURE_LOD_BIAS_EXT:
         *params = FLOAT_TO_BOOL(ctx->Const.MaxTextureLodBias);
         break;

      /* GL_EXT_texture_filter_anisotropic */
      case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
         if (ctx->Extensions.EXT_texture_filter_anisotropic) {
	    *params = FLOAT_TO_BOOL(ctx->Const.MaxTextureMaxAnisotropy);
         }
         else {
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetBooleanv" );
            return;
         }
	 break;

      /* GL_ARB_multisample */
      case GL_MULTISAMPLE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = ctx->Multisample.Enabled;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
            return;
         }
         break;
      case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = ctx->Multisample.SampleAlphaToCoverage;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
            return;
         }
         break;
      case GL_SAMPLE_ALPHA_TO_ONE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = ctx->Multisample.SampleAlphaToOne;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
            return;
         }
         break;
      case GL_SAMPLE_COVERAGE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = ctx->Multisample.SampleCoverage;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
            return;
         }
         break;
      case GL_SAMPLE_COVERAGE_VALUE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = FLOAT_TO_BOOL(ctx->Multisample.SampleCoverageValue);
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
            return;
         }
         break;
      case GL_SAMPLE_COVERAGE_INVERT_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = ctx->Multisample.SampleCoverageInvert;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
            return;
         }
         break;
      case GL_SAMPLE_BUFFERS_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = 0; /* XXX fix someday */
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
            return;
         }
         break;
      case GL_SAMPLES_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = 0; /* XXX fix someday */
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
            return;
         }
         break;

      /* GL_IBM_rasterpos_clip */
      case GL_RASTER_POSITION_UNCLIPPED_IBM:
         if (ctx->Extensions.IBM_rasterpos_clip) {
            *params = ctx->Transform.RasterPositionUnclipped;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBoolean");
            return;
         }
         break;

      /* GL_SGIS_generate_mipmap */
      case GL_GENERATE_MIPMAP_HINT_SGIS:
         if (ctx->Extensions.SGIS_generate_mipmap) {
            *params = ENUM_TO_BOOL(ctx->Hint.GenerateMipmap);
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv");
	    return;
         }
         break;

      /* GL_NV_texture_rectangle */
      case GL_TEXTURE_RECTANGLE_NV:
         CHECK_EXTENSION_B(NV_texture_rectangle, pname);
         *params = _mesa_IsEnabled(GL_TEXTURE_RECTANGLE_NV);
         break;
      case GL_TEXTURE_BINDING_RECTANGLE_NV:
         CHECK_EXTENSION_B(NV_texture_rectangle, pname);
         *params = INT_TO_BOOL(textureUnit->CurrentRect->Name);
         break;
      case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
         CHECK_EXTENSION_B(NV_texture_rectangle, pname);
         *params = INT_TO_BOOL(ctx->Const.MaxTextureRectSize);
         break;

d1317 1
a1317 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetBooleanv" );
d1322 2
d1330 1
d1332 2
a1333 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1338 2
a1339 7
   /* We need this in order to get correct results for
    * GL_OCCLUSION_TEST_RESULT_HP.  There might be other important cases.
    */
   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      fprintf(stderr, "glGetDoublev %s\n", _mesa_lookup_enum_by_nr(pname));
d1346 1
a1346 1
         *params = (GLdouble) ctx->Visual.accumRedBits;
d1349 1
a1349 1
         *params = (GLdouble) ctx->Visual.accumGreenBits;
d1352 1
a1352 1
         *params = (GLdouble) ctx->Visual.accumBlueBits;
d1355 1
a1355 1
         *params = (GLdouble) ctx->Visual.accumAlphaBits;
d1367 1
a1367 1
         *params = (GLdouble) ctx->Visual.alphaBits;
d1379 1
a1379 1
         *params = (GLdouble) ctx->Color.AlphaRef / CHAN_MAXF;
d1424 1
a1424 1
         *params = (GLdouble) ctx->Visual.blueBits;
d1441 4
a1444 4
         params[0] = (GLdouble) CHAN_TO_FLOAT(ctx->Color.ClearColor[0]);
         params[1] = (GLdouble) CHAN_TO_FLOAT(ctx->Color.ClearColor[1]);
         params[2] = (GLdouble) CHAN_TO_FLOAT(ctx->Color.ClearColor[2]);
         params[3] = (GLdouble) CHAN_TO_FLOAT(ctx->Color.ClearColor[3]);
d1468 4
a1471 5
	 FLUSH_CURRENT(ctx, 0);
         params[0] = (ctx->Current.Color[0]);
         params[1] = (ctx->Current.Color[1]);
         params[2] = (ctx->Current.Color[2]);
         params[3] = (ctx->Current.Color[3]);
a1473 1
	 FLUSH_CURRENT(ctx, 0);
a1476 1
	 FLUSH_CURRENT(ctx, 0);
d1500 4
a1503 4
	 params[0] = (GLdouble) ctx->Current.RasterMultiTexCoord[texUnit][0];
	 params[1] = (GLdouble) ctx->Current.RasterMultiTexCoord[texUnit][1];
	 params[2] = (GLdouble) ctx->Current.RasterMultiTexCoord[texUnit][2];
	 params[3] = (GLdouble) ctx->Current.RasterMultiTexCoord[texUnit][3];
d1509 4
a1512 5
	 FLUSH_CURRENT(ctx, 0);
	 params[0] = (GLdouble) ctx->Current.Texcoord[texUnit][0];
	 params[1] = (GLdouble) ctx->Current.Texcoord[texUnit][1];
	 params[2] = (GLdouble) ctx->Current.Texcoord[texUnit][2];
	 params[3] = (GLdouble) ctx->Current.Texcoord[texUnit][3];
d1518 1
a1518 1
	 *params = (GLdouble) ctx->Visual.depthBits;
d1543 1
a1543 1
	 *params = (GLdouble) ctx->Visual.doubleBufferMode;
a1548 1
	 FLUSH_CURRENT(ctx, 0);
d1591 1
a1591 1
         *params = (GLdouble) ctx->Visual.greenBits;
d1597 1
a1597 7
         if (ctx->Extensions.EXT_histogram || ctx->Extensions.ARB_imaging) {
            *params = (GLdouble) ctx->Pixel.HistogramEnabled;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
            return;
         }
d1600 1
a1600 1
         *params = (GLdouble) ctx->Visual.indexBits;
d1606 1
a1606 1
	 *params = ctx->Visual.rgbMode ? 0.0 : 1.0;
d1780 1
a1780 1
	 *params = (GLdouble) ctx->Const.MaxClipPlanes;
d1783 1
a1783 1
         *params = (GLdouble) ctx->Const.MaxArrayLockSize;
d1786 1
a1786 1
         *params = (GLdouble) ctx->Const.MaxArrayLockSize;
d1792 1
a1792 1
	 *params = (GLdouble) ctx->Const.MaxLights;
a1809 2
         *params = (GLdouble) (1 << (ctx->Const.MaxTextureLevels - 1));
	 break;
d1811 1
a1811 1
         *params = (GLdouble) (1 << (ctx->Const.Max3DTextureLevels - 1));
a1860 3
      case GL_PACK_INVERT_MESA:
         *params = (GLdouble) ctx->Pack.Invert;
         break;
d1895 1
a1895 1
         *params = (GLdouble) ctx->Point.Size;
d1965 1
a1965 1
         *params = (GLdouble) ctx->Visual.redBits;
d1977 1
a1977 1
	 *params = (GLdouble) ctx->Visual.rgbMode;
d1998 1
a1998 1
         *params = (GLdouble) ctx->Visual.stencilBits;
d2028 1
a2028 1
	 *params = (GLdouble) ctx->Visual.stereoMode;
d2043 1
a2043 1
         *params = (GLdouble) textureUnit->Current1D->Name;
d2046 1
a2046 1
         *params = (GLdouble) textureUnit->Current2D->Name;
d2049 1
a2049 1
         *params = (GLdouble) textureUnit->Current3D->Name;
d2074 1
a2074 1
	    params[i] = (GLdouble) ctx->TextureMatrix[texUnit].m[i];
d2078 1
a2078 1
	 *params = (GLdouble) (ctx->TextureStackDepth[texUnit] + 1);
a2103 3
      case GL_UNPACK_CLIENT_STORAGE_APPLE:
         *params = (GLdouble) ctx->Unpack.ClientStorage;
         break;
d2117 3
d2121 1
d2124 3
d2128 1
d2131 3
d2135 1
d2138 3
d2142 1
d2148 3
d2152 1
d2155 3
d2159 1
d2162 3
d2166 1
d2172 3
d2176 1
d2179 3
d2183 1
d2186 3
d2190 1
d2193 3
d2197 1
d2203 3
d2207 1
d2210 3
d2214 1
d2217 3
d2221 1
d2227 3
d2231 1
d2234 3
d2238 1
d2241 3
d2245 1
d2248 3
d2252 1
d2258 3
d2262 1
d2265 3
d2269 1
d2288 1
a2288 1
         if (ctx->Extensions.ARB_texture_cube_map)
d2291 1
a2291 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
d2294 1
a2294 1
         if (ctx->Extensions.ARB_texture_cube_map)
d2297 1
a2297 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
d2300 2
a2301 2
         if (ctx->Extensions.ARB_texture_cube_map)
            *params = (GLdouble) (1 << (ctx->Const.MaxCubeTextureLevels - 1));
d2303 1
a2303 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
d2308 1
a2308 1
         if (ctx->Extensions.ARB_texture_compression) {
d2312 1
a2312 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
d2315 1
a2315 1
         if (ctx->Extensions.ARB_texture_compression) {
d2319 1
a2319 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
d2322 1
a2322 1
         if (ctx->Extensions.ARB_texture_compression) {
d2328 6
a2333 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
d2335 45
d2383 3
d2387 1
d2390 3
d2394 1
d2402 1
a2402 1
            _math_transposef(tm, ctx->ColorMatrix.m);
d2412 1
a2412 1
            _math_transposef(tm, ctx->ModelView.m);
d2422 1
a2422 1
            _math_transposef(tm, ctx->ProjectionMatrix.m);
d2432 1
a2432 1
            _math_transposef(tm, ctx->TextureMatrix[texUnit].m);
d2441 1
a2441 1
         if (ctx->Extensions.HP_occlusion_test) {
d2445 1
a2445 1
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetDoublev" );
d2449 1
a2449 1
         if (ctx->Extensions.HP_occlusion_test) {
d2459 1
a2459 1
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetDoublev" );
d2514 2
a2515 17
      case GL_CONVOLUTION_1D_EXT:
         if (ctx->Extensions.EXT_convolution || ctx->Extensions.ARB_imaging) {
            *params = (GLdouble) ctx->Pixel.Convolution1DEnabled;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
            return;
         }
         break;
      case GL_CONVOLUTION_2D:
         if (ctx->Extensions.EXT_convolution || ctx->Extensions.ARB_imaging) {
            *params = (GLdouble) ctx->Pixel.Convolution2DEnabled;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
            return;
         }
d2517 2
a2518 8
      case GL_SEPARABLE_2D:
         if (ctx->Extensions.EXT_convolution || ctx->Extensions.ARB_imaging) {
            *params = (GLdouble) ctx->Pixel.Separable2DEnabled;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
            return;
         }
d2556 4
a2559 22
      /* GL_EXT_secondary_color */
      case GL_COLOR_SUM_EXT:
	 *params = (GLdouble) ctx->Fog.ColorSumEnabled;
	 break;
      case GL_CURRENT_SECONDARY_COLOR_EXT:
	 FLUSH_CURRENT(ctx, 0);
         params[0] = (ctx->Current.SecondaryColor[0]);
         params[1] = (ctx->Current.SecondaryColor[1]);
         params[2] = (ctx->Current.SecondaryColor[2]);
	 break;
      case GL_SECONDARY_COLOR_ARRAY_EXT:
         *params = (GLdouble) ctx->Array.SecondaryColor.Enabled;
         break;
      case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
	 *params = (GLdouble) ctx->Array.SecondaryColor.Type;
	 break;
      case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
	 *params = (GLdouble) ctx->Array.SecondaryColor.Stride;
	 break;
      case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
	 *params = (GLdouble) ctx->Array.SecondaryColor.Stride;
	 break;
a2560 14
      /* GL_EXT_fog_coord */
      case GL_CURRENT_FOG_COORDINATE_EXT:
	 FLUSH_CURRENT(ctx, 0);
	 *params = (GLdouble) ctx->Current.FogCoord;
	 break;
      case GL_FOG_COORDINATE_ARRAY_EXT:
         *params = (GLdouble) ctx->Array.FogCoord.Enabled;
         break;
      case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
	 *params = (GLdouble) ctx->Array.FogCoord.Type;
	 break;
      case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
	 *params = (GLdouble) ctx->Array.FogCoord.Stride;
	 break;
a2561 4
      /* GL_EXT_texture_lod_bias */
      case GL_MAX_TEXTURE_LOD_BIAS_EXT:
         *params = (GLdouble) ctx->Const.MaxTextureLodBias;
         break;
a2562 10
      /* GL_EXT_texture_filter_anisotropic */
      case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
         if (ctx->Extensions.EXT_texture_filter_anisotropic) {
	    *params = (GLdouble) ctx->Const.MaxTextureMaxAnisotropy;
         }
         else {
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetDoublev" );
            return;
         }
	 break;
d2564 4
a2567 127
      /* GL_ARB_multisample */
      case GL_MULTISAMPLE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLdouble) ctx->Multisample.Enabled;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
            return;
         }
         break;
      case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLdouble) ctx->Multisample.SampleAlphaToCoverage;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
            return;
         }
         break;
      case GL_SAMPLE_ALPHA_TO_ONE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLdouble) ctx->Multisample.SampleAlphaToOne;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
            return;
         }
         break;
      case GL_SAMPLE_COVERAGE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLdouble) ctx->Multisample.SampleCoverage;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
            return;
         }
         break;
      case GL_SAMPLE_COVERAGE_VALUE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = ctx->Multisample.SampleCoverageValue;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
            return;
         }
         break;
      case GL_SAMPLE_COVERAGE_INVERT_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLdouble) ctx->Multisample.SampleCoverageInvert;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
            return;
         }
         break;
      case GL_SAMPLE_BUFFERS_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = 0.0; /* XXX fix someday */
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
            return;
         }
         break;
      case GL_SAMPLES_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = 0.0; /* XXX fix someday */
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
            return;
         }
         break;

      /* GL_IBM_rasterpos_clip */
      case GL_RASTER_POSITION_UNCLIPPED_IBM:
         if (ctx->Extensions.IBM_rasterpos_clip) {
            *params = (GLdouble) ctx->Transform.RasterPositionUnclipped;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
            return;
         }
         break;

      /* GL_SGIS_generate_mipmap */
      case GL_GENERATE_MIPMAP_HINT_SGIS:
         if (ctx->Extensions.SGIS_generate_mipmap) {
            *params = (GLdouble) ctx->Hint.GenerateMipmap;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev");
	    return;
         }
         break;

      /* GL_NV_texture_rectangle */
      case GL_TEXTURE_RECTANGLE_NV:
         CHECK_EXTENSION_D(NV_texture_rectangle, pname);
         *params = (GLdouble) _mesa_IsEnabled(GL_TEXTURE_RECTANGLE_NV);
         break;
      case GL_TEXTURE_BINDING_RECTANGLE_NV:
         CHECK_EXTENSION_D(NV_texture_rectangle, pname);
         *params = (GLdouble) textureUnit->CurrentRect->Name;
         break;
      case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
         CHECK_EXTENSION_D(NV_texture_rectangle, pname);
         *params = (GLdouble) ctx->Const.MaxTextureRectSize;
         break;

      default:
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetDoublev" );
   }
}


#define GET_FLOAT_ERROR				\
{						\
   char s[100];					\
   sprintf(s, "glGetFloatv(0x%x)", pname);	\
   _mesa_error(ctx, GL_INVALID_ENUM, s);	\
}

void
_mesa_GetFloatv( GLenum pname, GLfloat *params )
{
   GET_CURRENT_CONTEXT(ctx);
d2570 1
d2572 2
a2573 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d2578 2
a2579 7
   /* We need this in order to get correct results for
    * GL_OCCLUSION_TEST_RESULT_HP.  There might be other important cases.
    */
   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      fprintf(stderr, "glGetFloatv %s\n", _mesa_lookup_enum_by_nr(pname));
d2586 1
a2586 1
         *params = (GLfloat) ctx->Visual.accumRedBits;
d2589 1
a2589 1
         *params = (GLfloat) ctx->Visual.accumGreenBits;
d2592 1
a2592 1
         *params = (GLfloat) ctx->Visual.accumBlueBits;
d2595 1
a2595 1
         *params = (GLfloat) ctx->Visual.accumAlphaBits;
d2607 1
a2607 1
         *params = (GLfloat) ctx->Visual.alphaBits;
d2619 1
a2619 1
         *params = (GLfloat) ctx->Color.AlphaRef / CHAN_MAXF;
d2664 1
a2664 1
         *params = (GLfloat) ctx->Visual.blueBits;
d2681 4
a2684 4
         params[0] = CHAN_TO_FLOAT(ctx->Color.ClearColor[0]);
         params[1] = CHAN_TO_FLOAT(ctx->Color.ClearColor[1]);
         params[2] = CHAN_TO_FLOAT(ctx->Color.ClearColor[2]);
         params[3] = CHAN_TO_FLOAT(ctx->Color.ClearColor[3]);
d2708 1
a2708 5
	 FLUSH_CURRENT(ctx, 0);
         params[0] = (ctx->Current.Color[0]);
         params[1] = (ctx->Current.Color[1]);
         params[2] = (ctx->Current.Color[2]);
         params[3] = (ctx->Current.Color[3]);
a2710 1
	 FLUSH_CURRENT(ctx, 0);
a2713 1
	 FLUSH_CURRENT(ctx, 0);
d2737 4
a2740 4
	 params[0] = ctx->Current.RasterMultiTexCoord[texUnit][0];
	 params[1] = ctx->Current.RasterMultiTexCoord[texUnit][1];
	 params[2] = ctx->Current.RasterMultiTexCoord[texUnit][2];
	 params[3] = ctx->Current.RasterMultiTexCoord[texUnit][3];
d2746 4
a2749 5
	 FLUSH_CURRENT(ctx, 0);
	 params[0] = (GLfloat) ctx->Current.Texcoord[texUnit][0];
	 params[1] = (GLfloat) ctx->Current.Texcoord[texUnit][1];
	 params[2] = (GLfloat) ctx->Current.Texcoord[texUnit][2];
	 params[3] = (GLfloat) ctx->Current.Texcoord[texUnit][3];
d2755 1
a2755 1
	 *params = (GLfloat) ctx->Visual.depthBits;
d2780 1
a2780 1
	 *params = (GLfloat) ctx->Visual.doubleBufferMode;
a2785 1
	 FLUSH_CURRENT(ctx, 0);
d2828 1
a2828 1
         *params = (GLfloat) ctx->Visual.greenBits;
d2834 1
a2834 7
         if (ctx->Extensions.EXT_histogram || ctx->Extensions.ARB_imaging) {
            *params = (GLfloat) ctx->Pixel.HistogramEnabled;
         }
         else {
            GET_FLOAT_ERROR;
            return;
         }
d2837 1
a2837 1
         *params = (GLfloat) ctx->Visual.indexBits;
d2843 1
a2843 1
	 *params = ctx->Visual.rgbMode ? 0.0F : 1.0F;
d3017 1
a3017 1
	 *params = (GLfloat) ctx->Const.MaxClipPlanes;
d3020 1
a3020 1
         *params = (GLfloat) ctx->Const.MaxArrayLockSize;
d3023 1
a3023 1
         *params = (GLfloat) ctx->Const.MaxArrayLockSize;
d3029 1
a3029 1
	 *params = (GLfloat) ctx->Const.MaxLights;
a3046 2
         *params = (GLfloat) (1 << (ctx->Const.MaxTextureLevels - 1));
	 break;
d3048 1
a3048 1
         *params = (GLfloat) (1 << (ctx->Const.Max3DTextureLevels - 1));
a3097 3
      case GL_PACK_INVERT_MESA:
         *params = (GLfloat) ctx->Pack.Invert;
         break;
d3132 1
a3132 1
         *params = (GLfloat) ctx->Point.Size;
d3204 1
a3204 1
         *params = (GLfloat) ctx->Visual.redBits;
d3216 1
a3216 1
	 *params = (GLfloat) ctx->Visual.rgbMode;
d3237 1
a3237 1
         *params = (GLfloat) ctx->Visual.stencilBits;
d3267 1
a3267 1
	 *params = (GLfloat) ctx->Visual.stereoMode;
d3273 1
a3273 1
         *params = _mesa_IsEnabled(GL_TEXTURE_1D) ? 1.0F : 0.0F;
d3276 1
a3276 1
         *params = _mesa_IsEnabled(GL_TEXTURE_2D) ? 1.0F : 0.0F;
d3279 1
a3279 1
         *params = _mesa_IsEnabled(GL_TEXTURE_3D) ? 1.0F : 0.0F;
d3282 1
a3282 1
         *params = (GLfloat) textureUnit->Current1D->Name;
d3285 1
a3285 1
         *params = (GLfloat) textureUnit->Current2D->Name;
d3288 1
a3288 1
         *params = (GLfloat) textureUnit->Current2D->Name;
d3300 1
a3300 1
	 *params = (textureUnit->TexGenEnabled & S_BIT) ? 1.0F : 0.0F;
d3303 1
a3303 1
	 *params = (textureUnit->TexGenEnabled & T_BIT) ? 1.0F : 0.0F;
d3306 1
a3306 1
	 *params = (textureUnit->TexGenEnabled & R_BIT) ? 1.0F : 0.0F;
d3309 1
a3309 1
	 *params = (textureUnit->TexGenEnabled & Q_BIT) ? 1.0F : 0.0F;
d3313 1
a3313 1
	    params[i] = ctx->TextureMatrix[texUnit].m[i];
d3317 1
a3317 1
	 *params = (GLfloat) (ctx->TextureStackDepth[texUnit] + 1);
a3342 3
      case GL_UNPACK_CLIENT_STORAGE_APPLE:
         *params = (GLfloat) ctx->Unpack.ClientStorage;
         break;
d3356 3
d3360 1
d3363 3
d3367 1
d3370 3
d3374 1
d3377 3
d3381 1
d3387 3
d3391 1
d3394 3
d3398 1
d3401 3
d3405 1
d3411 3
d3415 1
d3418 3
d3422 1
d3425 3
d3429 1
d3432 3
d3436 1
d3442 3
d3446 1
d3449 3
d3453 1
d3456 3
d3460 1
d3466 3
d3470 1
d3473 3
d3477 1
d3480 3
d3484 1
d3487 3
d3491 1
d3497 3
d3501 1
d3504 3
d3508 1
d3527 1
a3527 1
         if (ctx->Extensions.ARB_texture_cube_map)
d3530 1
a3530 1
            GET_FLOAT_ERROR;
d3533 1
a3533 1
         if (ctx->Extensions.ARB_texture_cube_map)
d3536 1
a3536 1
            GET_FLOAT_ERROR;
d3539 2
a3540 2
         if (ctx->Extensions.ARB_texture_cube_map)
            *params = (GLfloat) (1 << (ctx->Const.MaxCubeTextureLevels - 1));
d3542 1
a3542 1
            GET_FLOAT_ERROR;
d3547 1
a3547 1
         if (ctx->Extensions.ARB_texture_compression) {
d3551 1
a3551 1
            GET_FLOAT_ERROR;
d3554 1
a3554 1
         if (ctx->Extensions.ARB_texture_compression) {
d3558 1
a3558 1
            GET_FLOAT_ERROR;
d3561 1
a3561 1
         if (ctx->Extensions.ARB_texture_compression) {
d3567 1
a3567 1
            GET_FLOAT_ERROR;
d3570 50
d3622 3
d3626 1
d3629 3
d3633 1
d3638 1
a3638 1
         _math_transposef(params, ctx->ColorMatrix.m);
d3641 1
a3641 1
         _math_transposef(params, ctx->ModelView.m);
d3644 1
a3644 1
         _math_transposef(params, ctx->ProjectionMatrix.m);
d3647 1
a3647 1
         _math_transposef(params, ctx->TextureMatrix[texUnit].m);
d3652 1
a3652 1
         if (ctx->Extensions.HP_occlusion_test) {
d3656 1
a3656 1
            GET_FLOAT_ERROR;
d3660 1
a3660 1
         if (ctx->Extensions.HP_occlusion_test) {
d3670 1
a3670 1
            GET_FLOAT_ERROR;
d3725 2
a3726 17
      case GL_CONVOLUTION_1D_EXT:
         if (ctx->Extensions.EXT_convolution || ctx->Extensions.ARB_imaging) {
            *params = (GLfloat) ctx->Pixel.Convolution1DEnabled;
         }
         else {
            GET_FLOAT_ERROR;
            return;
         }
         break;
      case GL_CONVOLUTION_2D:
         if (ctx->Extensions.EXT_convolution || ctx->Extensions.ARB_imaging) {
            *params = (GLfloat) ctx->Pixel.Convolution2DEnabled;
         }
         else {
            GET_FLOAT_ERROR;
            return;
         }
d3728 2
a3729 8
      case GL_SEPARABLE_2D:
         if (ctx->Extensions.EXT_convolution || ctx->Extensions.ARB_imaging) {
            *params = (GLfloat) ctx->Pixel.Separable2DEnabled;
         }
         else {
            GET_FLOAT_ERROR;
            return;
         }
d3767 4
a3770 149
      /* GL_EXT_secondary_color */
      case GL_COLOR_SUM_EXT:
	 *params = (GLfloat) ctx->Fog.ColorSumEnabled;
	 break;
      case GL_CURRENT_SECONDARY_COLOR_EXT:
	 FLUSH_CURRENT(ctx, 0);
         params[0] = (ctx->Current.SecondaryColor[0]);
         params[1] = (ctx->Current.SecondaryColor[1]);
         params[2] = (ctx->Current.SecondaryColor[2]);
	 break;
      case GL_SECONDARY_COLOR_ARRAY_EXT:
         *params = (GLfloat) ctx->Array.SecondaryColor.Enabled;
         break;
      case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
	 *params = (GLfloat) ctx->Array.SecondaryColor.Type;
	 break;
      case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
	 *params = (GLfloat) ctx->Array.SecondaryColor.Stride;
	 break;
      case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
	 *params = (GLfloat) ctx->Array.SecondaryColor.Stride;
	 break;

      /* GL_EXT_fog_coord */
      case GL_CURRENT_FOG_COORDINATE_EXT:
	 FLUSH_CURRENT(ctx, 0);
	 *params = (GLfloat) ctx->Current.FogCoord;
	 break;
      case GL_FOG_COORDINATE_ARRAY_EXT:
         *params = (GLfloat) ctx->Array.FogCoord.Enabled;
         break;
      case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
	 *params = (GLfloat) ctx->Array.FogCoord.Type;
	 break;
      case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
	 *params = (GLfloat) ctx->Array.FogCoord.Stride;
	 break;

      /* GL_EXT_texture_lod_bias */
      case GL_MAX_TEXTURE_LOD_BIAS_EXT:
         *params = ctx->Const.MaxTextureLodBias;
         break;

      /* GL_EXT_texture_filter_anisotropic */
      case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
         if (ctx->Extensions.EXT_texture_filter_anisotropic) {
	    *params = ctx->Const.MaxTextureMaxAnisotropy;
         }
         else {
            GET_FLOAT_ERROR;
            return;
         }
	 break;

      /* GL_ARB_multisample */
      case GL_MULTISAMPLE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLfloat) ctx->Multisample.Enabled;
         }
         else {
            GET_FLOAT_ERROR;
            return;
         }
         break;
      case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLfloat) ctx->Multisample.SampleAlphaToCoverage;
         }
         else {
            GET_FLOAT_ERROR;
            return;
         }
         break;
      case GL_SAMPLE_ALPHA_TO_ONE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLfloat) ctx->Multisample.SampleAlphaToOne;
         }
         else {
            GET_FLOAT_ERROR;
            return;
         }
         break;
      case GL_SAMPLE_COVERAGE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLfloat) ctx->Multisample.SampleCoverage;
         }
         else {
            GET_FLOAT_ERROR;
            return;
         }
         break;
      case GL_SAMPLE_COVERAGE_VALUE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = ctx->Multisample.SampleCoverageValue;
         }
         else {
            GET_FLOAT_ERROR;
            return;
         }
         break;
      case GL_SAMPLE_COVERAGE_INVERT_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLfloat) ctx->Multisample.SampleCoverageInvert;
         }
         else {
            GET_FLOAT_ERROR;
            return;
         }
         break;
      case GL_SAMPLE_BUFFERS_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = 0.0; /* XXX fix someday */
         }
         else {
            GET_FLOAT_ERROR;
            return;
         }
         break;
      case GL_SAMPLES_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = 0.0; /* XXX fix someday */
         }
         else {
            GET_FLOAT_ERROR;
            return;
         }
         break;

      /* GL_IBM_rasterpos_clip */
      case GL_RASTER_POSITION_UNCLIPPED_IBM:
         if (ctx->Extensions.IBM_rasterpos_clip) {
            *params = (GLfloat) ctx->Transform.RasterPositionUnclipped;
         }
         else {
            GET_FLOAT_ERROR;
            return;
         }
         break;

      /* GL_SGIS_generate_mipmap */
      case GL_GENERATE_MIPMAP_HINT_SGIS:
         if (ctx->Extensions.SGIS_generate_mipmap) {
            *params = (GLfloat) ctx->Hint.GenerateMipmap;
         }
         else {
            GET_FLOAT_ERROR;
	    return;
         }
         break;
a3771 13
      /* GL_NV_texture_rectangle */
      case GL_TEXTURE_RECTANGLE_NV:
         CHECK_EXTENSION_F(NV_texture_rectangle, pname);
         *params = (GLfloat) _mesa_IsEnabled(GL_TEXTURE_RECTANGLE_NV);
         break;
      case GL_TEXTURE_BINDING_RECTANGLE_NV:
         CHECK_EXTENSION_F(NV_texture_rectangle, pname);
         *params = (GLfloat) textureUnit->CurrentRect->Name;
         break;
      case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
         CHECK_EXTENSION_F(NV_texture_rectangle, pname);
         *params = (GLfloat) ctx->Const.MaxTextureRectSize;
         break;
a3772 4
       default:
         GET_FLOAT_ERROR;
   }
}
d3781 1
d3783 2
a3784 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d3789 2
a3790 7
   /* We need this in order to get correct results for
    * GL_OCCLUSION_TEST_RESULT_HP.  There might be other important cases.
    */
   FLUSH_VERTICES(ctx, 0);

   if (MESA_VERBOSE & VERBOSE_API)
      fprintf(stderr, "glGetIntegerv %s\n", _mesa_lookup_enum_by_nr(pname));
d3798 1
a3798 1
         *params = (GLint) ctx->Visual.accumRedBits;
d3801 1
a3801 1
         *params = (GLint) ctx->Visual.accumGreenBits;
d3804 1
a3804 1
         *params = (GLint) ctx->Visual.accumBlueBits;
d3807 1
a3807 1
         *params = (GLint) ctx->Visual.accumAlphaBits;
d3819 1
a3819 1
         *params = ctx->Visual.alphaBits;
d3828 1
a3828 1
         *params = FLOAT_TO_INT( (GLfloat) ctx->Color.AlphaRef / CHAN_MAXF );
d3876 1
a3876 1
         *params = (GLint) ctx->Visual.blueBits;
d3894 4
a3897 4
         params[0] = FLOAT_TO_INT( (ctx->Color.ClearColor[0]) );
         params[1] = FLOAT_TO_INT( (ctx->Color.ClearColor[1]) );
         params[2] = FLOAT_TO_INT( (ctx->Color.ClearColor[2]) );
         params[3] = FLOAT_TO_INT( (ctx->Color.ClearColor[3]) );
d3921 4
a3924 5
	 FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_INT( ( ctx->Current.Color[0] ) );
         params[1] = FLOAT_TO_INT( ( ctx->Current.Color[1] ) );
         params[2] = FLOAT_TO_INT( ( ctx->Current.Color[2] ) );
         params[3] = FLOAT_TO_INT( ( ctx->Current.Color[3] ) );
a3926 1
	 FLUSH_CURRENT(ctx, 0);
a3929 1
	 FLUSH_CURRENT(ctx, 0);
d3953 4
a3956 4
	 params[0] = (GLint) ctx->Current.RasterMultiTexCoord[texUnit][0];
	 params[1] = (GLint) ctx->Current.RasterMultiTexCoord[texUnit][1];
	 params[2] = (GLint) ctx->Current.RasterMultiTexCoord[texUnit][2];
	 params[3] = (GLint) ctx->Current.RasterMultiTexCoord[texUnit][3];
d3962 4
a3965 5
	 FLUSH_CURRENT(ctx, 0);
         params[0] = (GLint) ctx->Current.Texcoord[texUnit][0];
         params[1] = (GLint) ctx->Current.Texcoord[texUnit][1];
         params[2] = (GLint) ctx->Current.Texcoord[texUnit][2];
         params[3] = (GLint) ctx->Current.Texcoord[texUnit][3];
d3971 1
a3971 1
	 *params = ctx->Visual.depthBits;
d3996 1
a3996 1
	 *params = (GLint) ctx->Visual.doubleBufferMode;
a4001 1
	 FLUSH_CURRENT(ctx, 0);
d4044 1
a4044 1
         *params = (GLint) ctx->Visual.greenBits;
d4050 1
a4050 7
         if (ctx->Extensions.EXT_histogram || ctx->Extensions.ARB_imaging) {
            *params = (GLint) ctx->Pixel.HistogramEnabled;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetFloatv");
            return;
         }
d4053 1
a4053 1
         *params = (GLint) ctx->Visual.indexBits;
d4059 1
a4059 1
	 *params = ctx->Visual.rgbMode ? 0 : 1;
d4233 1
a4233 1
         *params = (GLint) ctx->Const.MaxClipPlanes;
d4236 1
a4236 1
         *params = (GLint) ctx->Const.MaxArrayLockSize;
d4239 1
a4239 1
         *params = (GLint) ctx->Const.MaxArrayLockSize;
d4245 1
a4245 1
         *params = (GLint) ctx->Const.MaxLights;
a4262 2
         *params = (1 << (ctx->Const.MaxTextureLevels - 1));
	 break;
d4264 1
a4264 1
         *params = (1 << (ctx->Const.Max3DTextureLevels - 1));
a4313 3
      case GL_PACK_INVERT_MESA:
         *params = ctx->Pack.Invert;
         break;
d4348 1
a4348 1
         *params = (GLint) ctx->Point.Size;
d4418 1
a4418 1
         *params = (GLint) ctx->Visual.redBits;
d4430 1
a4430 1
	 *params = (GLint) ctx->Visual.rgbMode;
d4451 1
a4451 1
         *params = ctx->Visual.stencilBits;
d4481 1
a4481 1
	 *params = (GLint) ctx->Visual.stereoMode;
d4496 1
a4496 1
         *params = textureUnit->Current1D->Name;
d4499 1
a4499 1
         *params = textureUnit->Current2D->Name;
d4502 1
a4502 1
         *params = textureUnit->Current3D->Name;
d4527 1
a4527 1
	    params[i] = (GLint) ctx->TextureMatrix[texUnit].m[i];
d4531 1
a4531 1
	 *params = (GLint) (ctx->TextureStackDepth[texUnit] + 1);
a4556 3
      case GL_UNPACK_CLIENT_STORAGE_APPLE:
         *params = ctx->Unpack.ClientStorage;
         break;
d4570 3
d4574 1
d4577 3
d4581 1
d4584 3
d4588 1
d4591 3
d4595 1
d4601 3
d4605 1
d4608 3
d4612 1
d4615 3
d4619 1
d4625 3
d4629 1
d4632 3
d4636 1
d4639 3
d4643 1
d4646 3
d4650 1
d4656 3
d4660 1
d4663 3
d4667 1
d4670 3
d4674 1
d4680 3
d4684 1
d4687 3
d4691 1
d4694 3
d4698 1
d4701 3
d4705 1
d4711 3
d4715 1
d4718 3
d4722 1
d4741 1
a4741 1
         if (ctx->Extensions.ARB_texture_cube_map)
d4744 1
a4744 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
d4747 1
a4747 1
         if (ctx->Extensions.ARB_texture_cube_map)
d4750 1
a4750 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
d4753 2
a4754 2
         if (ctx->Extensions.ARB_texture_cube_map)
            *params = (1 << (ctx->Const.MaxCubeTextureLevels - 1));
d4756 1
a4756 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
d4761 1
a4761 1
         if (ctx->Extensions.ARB_texture_compression) {
d4765 1
a4765 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
d4768 1
a4768 1
         if (ctx->Extensions.ARB_texture_compression) {
d4772 1
a4772 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
d4775 1
a4775 1
         if (ctx->Extensions.ARB_texture_compression) {
d4781 6
a4786 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
d4788 45
d4836 3
d4840 1
d4843 3
d4847 1
d4849 1
a4849 1

d4855 1
a4855 1
            _math_transposef(tm, ctx->ColorMatrix.m);
d4865 1
a4865 1
            _math_transposef(tm, ctx->ModelView.m);
d4875 1
a4875 1
            _math_transposef(tm, ctx->ProjectionMatrix.m);
d4885 1
a4885 1
            _math_transposef(tm, ctx->TextureMatrix[texUnit].m);
d4894 1
a4894 1
         if (ctx->Extensions.HP_occlusion_test) {
d4898 1
a4898 1
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetIntegerv" );
d4902 1
a4902 1
         if (ctx->Extensions.HP_occlusion_test) {
d4912 1
a4912 1
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetIntegerv" );
d4967 2
a4968 8
      case GL_CONVOLUTION_1D_EXT:
         if (ctx->Extensions.EXT_convolution || ctx->Extensions.ARB_imaging) {
            *params = (GLint) ctx->Pixel.Convolution1DEnabled;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
            return;
         }
d4970 2
a4971 17
      case GL_CONVOLUTION_2D:
         if (ctx->Extensions.EXT_convolution || ctx->Extensions.ARB_imaging) {
            *params = (GLint) ctx->Pixel.Convolution2DEnabled;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
            return;
         }
         break;
      case GL_SEPARABLE_2D:
         if (ctx->Extensions.EXT_convolution || ctx->Extensions.ARB_imaging) {
            *params = (GLint) ctx->Pixel.Separable2DEnabled;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
            return;
         }
a5008 185

      /* GL_EXT_secondary_color */
      case GL_COLOR_SUM_EXT:
	 *params = (GLint) ctx->Fog.ColorSumEnabled;
	 break;
      case GL_CURRENT_SECONDARY_COLOR_EXT:
	 FLUSH_CURRENT(ctx, 0);
         params[0] = FLOAT_TO_INT( (ctx->Current.SecondaryColor[0]) );
         params[1] = FLOAT_TO_INT( (ctx->Current.SecondaryColor[1]) );
         params[2] = FLOAT_TO_INT( (ctx->Current.SecondaryColor[2]) );
	 break;
      case GL_SECONDARY_COLOR_ARRAY_EXT:
         *params = (GLint) ctx->Array.SecondaryColor.Enabled;
         break;
      case GL_SECONDARY_COLOR_ARRAY_TYPE_EXT:
	 *params = (GLint) ctx->Array.SecondaryColor.Type;
	 break;
      case GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT:
	 *params = (GLint) ctx->Array.SecondaryColor.Stride;
	 break;
      case GL_SECONDARY_COLOR_ARRAY_SIZE_EXT:
	 *params = (GLint) ctx->Array.SecondaryColor.Stride;
	 break;

      /* GL_EXT_fog_coord */
      case GL_CURRENT_FOG_COORDINATE_EXT:
         if (ctx->Extensions.EXT_fog_coord) {
            FLUSH_CURRENT(ctx, 0);
            *params = (GLint) ctx->Current.FogCoord;
         }
         else {
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetIntegerv" );
         }
	 break;
      case GL_FOG_COORDINATE_ARRAY_EXT:
         if (ctx->Extensions.EXT_fog_coord) {
            *params = (GLint) ctx->Array.FogCoord.Enabled;
         }
         else {
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetIntegerv" );
         }
         break;
      case GL_FOG_COORDINATE_ARRAY_TYPE_EXT:
         if (ctx->Extensions.EXT_fog_coord) {
            *params = (GLint) ctx->Array.FogCoord.Type;
         }
         else {
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetIntegerv" );
         }
	 break;
      case GL_FOG_COORDINATE_ARRAY_STRIDE_EXT:
         if (ctx->Extensions.EXT_fog_coord) {
            *params = (GLint) ctx->Array.FogCoord.Stride;
         }
         else {
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetIntegerv" );
         }
	 break;

      /* GL_EXT_texture_lod_bias */
      case GL_MAX_TEXTURE_LOD_BIAS_EXT:
         *params = (GLint) ctx->Const.MaxTextureLodBias;
         break;

      /* GL_EXT_texture_filter_anisotropic */
      case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:
         if (ctx->Extensions.EXT_texture_filter_anisotropic) {
	    *params = (GLint) ctx->Const.MaxTextureMaxAnisotropy;
         }
         else {
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetIntegerv" );
            return;
         }
	 break;

      /* GL_ARB_multisample */
      case GL_MULTISAMPLE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLint) ctx->Multisample.Enabled;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
            return;
         }
         break;
      case GL_SAMPLE_ALPHA_TO_COVERAGE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLint) ctx->Multisample.SampleAlphaToCoverage;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
            return;
         }
         break;
      case GL_SAMPLE_ALPHA_TO_ONE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLint) ctx->Multisample.SampleAlphaToOne;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
            return;
         }
         break;
      case GL_SAMPLE_COVERAGE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLint) ctx->Multisample.SampleCoverage;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
            return;
         }
         break;
      case GL_SAMPLE_COVERAGE_VALUE_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLint) ctx->Multisample.SampleCoverageValue;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
            return;
         }
         break;
      case GL_SAMPLE_COVERAGE_INVERT_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = (GLint) ctx->Multisample.SampleCoverageInvert;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
            return;
         }
         break;
      case GL_SAMPLE_BUFFERS_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = 0; /* XXX fix someday */
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
            return;
         }
         break;
      case GL_SAMPLES_ARB:
         if (ctx->Extensions.ARB_multisample) {
            *params = 0; /* XXX fix someday */
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
            return;
         }
         break;

      /* GL_IBM_rasterpos_clip */
      case GL_RASTER_POSITION_UNCLIPPED_IBM:
         if (ctx->Extensions.IBM_rasterpos_clip) {
            *params = (GLint) ctx->Transform.RasterPositionUnclipped;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
            return;
         }
         break;

      /* GL_SGIS_generate_mipmap */
      case GL_GENERATE_MIPMAP_HINT_SGIS:
         if (ctx->Extensions.SGIS_generate_mipmap) {
            *params = (GLint) ctx->Hint.GenerateMipmap;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv");
	    return;
         }
         break;

      /* GL_NV_texture_rectangle */
      case GL_TEXTURE_RECTANGLE_NV:
         CHECK_EXTENSION_I(NV_texture_rectangle, pname);
         *params = (GLint) _mesa_IsEnabled(GL_TEXTURE_RECTANGLE_NV);
         break;
      case GL_TEXTURE_BINDING_RECTANGLE_NV:
         CHECK_EXTENSION_I(NV_texture_rectangle, pname);
         *params = (GLint) textureUnit->CurrentRect->Name;
         break;
      case GL_MAX_RECTANGLE_TEXTURE_SIZE_NV:
         CHECK_EXTENSION_I(NV_texture_rectangle, pname);
         *params = (GLint) ctx->Const.MaxTextureRectSize;
         break;

d5010 1
a5010 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetIntegerv" );
d5021 2
a5022 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d5027 2
a5028 2
   if (MESA_VERBOSE & VERBOSE_API)
      fprintf(stderr, "glGetPointerv %s\n", _mesa_lookup_enum_by_nr(pname));
d5036 3
d5040 1
d5043 3
d5047 1
d5050 3
d5054 1
a5054 6
         break;
      case GL_SECONDARY_COLOR_ARRAY_POINTER_EXT:
         *params = ctx->Array.SecondaryColor.Ptr;
         break;
      case GL_FOG_COORDINATE_ARRAY_POINTER_EXT:
         *params = ctx->Array.FogCoord.Ptr;
d5057 3
d5061 1
d5064 3
d5068 1
d5071 3
d5075 1
d5084 1
a5084 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetPointerv" );
d5097 1
a5097 2
   static const char *version_1_2 = "1.2 Mesa 4.0.4";
   static const char *version_1_3 = "1.3 Mesa 4.0.4";
d5099 1
a5099 1
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);
d5114 1
a5114 11
             if (ctx->Extensions.ARB_multitexture &&
                 ctx->Extensions.ARB_multisample &&
                 ctx->Extensions.ARB_texture_border_clamp &&
                 ctx->Extensions.ARB_texture_compression &&
                 ctx->Extensions.ARB_texture_cube_map &&
                 ctx->Extensions.EXT_texture_env_add &&
                 ctx->Extensions.ARB_texture_env_combine &&
                 ctx->Extensions.ARB_texture_env_dot3)
                return (const GLubyte *) version_1_3;
             else
                return (const GLubyte *) version_1_2;
d5116 1
a5116 1
             return (const GLubyte *) _mesa_extensions_get_string(ctx);
d5118 2
a5119 2
             _mesa_error( ctx, GL_INVALID_ENUM, "glGetString" );
             return (const GLubyte *) 0;
d5132 1
d5134 2
a5135 1
   ASSERT_OUTSIDE_BEGIN_END_WITH_RETVAL(ctx, 0);
d5138 1
a5138 1
      fprintf(stderr, "glGetError <-- %s\n", _mesa_lookup_enum_by_nr(e));
d5143 1
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
d4 1
a4 1
 * Version:  5.0.2
d6 1
a6 1
 * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
d27 3
d40 1
a40 1
#include "texcompress.h"
d42 1
d61 1
d66 3
a68 2
      _mesa_error(ctx, GL_INVALID_VALUE,			\
                  "glGetBooleanv(0x%x)", (int) PNAME);		\
d74 3
a76 2
      _mesa_error(ctx, GL_INVALID_VALUE,			\
                  "glGetIntegerv(0x%x)", (int) PNAME);		\
d82 3
a84 2
      _mesa_error(ctx, GL_INVALID_VALUE,			\
                  "glGetFloatv(0x%x)", (int) PNAME);		\
d90 3
a92 2
      _mesa_error(ctx, GL_INVALID_VALUE,			\
                  "glGetDoublev(0x%x)", (int) PNAME);		\
a97 1

d138 1
a138 1
      _mesa_debug(ctx, "glGetBooleanv %s\n", _mesa_lookup_enum_by_nr(pname));
d179 1
a179 1
         *params = ctx->Color.AlphaRef ? GL_TRUE : GL_FALSE;
d238 1
a238 4
         if (ctx->Transform.ClipPlanesEnabled & (1 << (pname - GL_CLIP_PLANE0)))
            *params = GL_TRUE;
         else
            *params = GL_FALSE;
d269 4
a272 4
         params[0] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0]);
         params[1] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1]);
         params[2] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2]);
         params[3] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3]);
d280 3
a282 3
         params[0] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][0]);
         params[1] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][1]);
         params[2] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][2]);
d303 4
a306 4
         params[0] = FLOAT_TO_BOOL(ctx->Current.RasterTexCoords[texUnit][0]);
         params[1] = FLOAT_TO_BOOL(ctx->Current.RasterTexCoords[texUnit][1]);
         params[2] = FLOAT_TO_BOOL(ctx->Current.RasterTexCoords[texUnit][2]);
         params[3] = FLOAT_TO_BOOL(ctx->Current.RasterTexCoords[texUnit][3]);
d313 4
a316 4
         params[0] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][0]);
         params[1] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][1]);
         params[2] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][2]);
         params[3] = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][3]);
d401 9
d492 2
a493 6
         if (!ctx->CompileFlag)
            *params = 0;
         else if (ctx->ExecuteFlag)
            *params = ENUM_TO_BOOL(GL_COMPILE_AND_EXECUTE);
         else
            *params = ENUM_TO_BOOL(GL_COMPILE);
d633 3
d638 1
a638 1
	    params[i] = FLOAT_TO_BOOL(ctx->ModelviewMatrixStack.Top->m[i]);
d642 1
a642 1
         *params = INT_TO_BOOL(ctx->ModelviewMatrixStack.Depth + 1);
d768 1
a768 1
	    params[i] = FLOAT_TO_BOOL(ctx->ProjectionMatrixStack.Top->m[i]);
d772 1
a772 1
	 *params = INT_TO_BOOL(ctx->ProjectionMatrixStack.Depth + 1);
d820 1
a820 1
	 *params = ENUM_TO_BOOL(ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace]);
d823 1
a823 1
	 *params = ENUM_TO_BOOL(ctx->Stencil.Function[ctx->Stencil.ActiveFace]);
d826 1
a826 1
	 *params = ENUM_TO_BOOL(ctx->Stencil.ZFailFunc[ctx->Stencil.ActiveFace]);
d829 1
a829 1
	 *params = ENUM_TO_BOOL(ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace]);
d832 1
a832 1
	 *params = INT_TO_BOOL(ctx->Stencil.Ref[ctx->Stencil.ActiveFace]);
d838 1
a838 1
	 *params = INT_TO_BOOL(ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace]);
d841 1
a841 1
	 *params = INT_TO_BOOL(ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace]);
d893 1
a893 1
	       FLOAT_TO_BOOL(ctx->TextureMatrixStack[texUnit].Top->m[i]);
d897 1
a897 1
	 *params = INT_TO_BOOL(ctx->TextureMatrixStack[texUnit].Depth + 1);
d1019 1
a1019 2
         CHECK_EXTENSION_B(ARB_multitexture, pname);
         *params = INT_TO_BOOL(ctx->Const.MaxTextureUnits);
a1021 1
         CHECK_EXTENSION_B(ARB_multitexture, pname);
a1024 1
         CHECK_EXTENSION_B(ARB_multitexture, pname);
d1030 5
a1034 3
         CHECK_EXTENSION_B(ARB_texture_cube_map, pname);
         *params = _mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB);
         break;
d1036 5
a1040 3
         CHECK_EXTENSION_B(ARB_texture_cube_map, pname);
         *params = INT_TO_BOOL(textureUnit->CurrentCubeMap->Name);
         break;
d1042 4
a1045 2
         CHECK_EXTENSION_B(ARB_texture_cube_map, pname);
         *params = INT_TO_BOOL(1 << (ctx->Const.MaxCubeTextureLevels - 1));
d1050 5
a1054 2
         CHECK_EXTENSION_B(ARB_texture_compression, pname);
         *params = INT_TO_BOOL(ctx->Hint.TextureCompression);
d1057 5
a1061 2
         CHECK_EXTENSION_B(ARB_texture_compression, pname);
         *params = INT_TO_BOOL(_mesa_get_compressed_formats(ctx, NULL));
d1064 4
a1067 7
         CHECK_EXTENSION_B(ARB_texture_compression, pname);
         {
            GLint formats[100];
            GLuint i, n;
            n = _mesa_get_compressed_formats(ctx, formats);
            for (i = 0; i < n; i++)
               params[i] = INT_TO_BOOL(formats[i]);
d1069 2
d1086 1
a1086 1
            _math_transposef(tm, ctx->ColorMatrixStack.Top->m);
d1096 1
a1096 1
            _math_transposef(tm, ctx->ModelviewMatrixStack.Top->m);
d1106 1
a1106 1
            _math_transposef(tm, ctx->ProjectionMatrixStack.Top->m);
d1116 1
a1116 1
            _math_transposef(tm, ctx->TextureMatrixStack[texUnit].Top->m);
d1125 6
a1130 2
         CHECK_EXTENSION_B(HP_occlusion_test, pname);
         *params = ctx->Depth.OcclusionTest;
d1133 12
a1144 8
         CHECK_EXTENSION_B(HP_occlusion_test, pname);
         if (ctx->Depth.OcclusionTest)
            *params = ctx->OcclusionResult;
         else
            *params = ctx->OcclusionResultSaved;
         /* reset flag now */
         ctx->OcclusionResult = GL_FALSE;
         ctx->OcclusionResultSaved = GL_FALSE;
d1163 1
a1163 1
	    params[i] = FLOAT_TO_BOOL(ctx->ColorMatrixStack.Top->m[i]);
d1167 1
a1167 1
         *params = INT_TO_BOOL(ctx->ColorMatrixStack.Depth + 1);
d1199 7
a1205 2
         CHECK_EXTENSION_B(EXT_convolution, pname);
         *params = ctx->Pixel.Convolution1DEnabled;
d1208 7
a1214 2
         CHECK_EXTENSION_B(EXT_convolution, pname);
         *params = ctx->Pixel.Convolution2DEnabled;
d1217 7
a1223 2
         CHECK_EXTENSION_B(EXT_convolution, pname);
         *params = ctx->Pixel.Separable2DEnabled;
a1225 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1228 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1231 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1234 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1237 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1240 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1243 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1246 1
         CHECK_EXTENSION_B(EXT_convolution, pname);
a1249 10
      /* GL_EXT_histogram (also in 1.2 imaging) */
      case GL_HISTOGRAM:
         CHECK_EXTENSION_B(EXT_histogram, pname);
         *params = ctx->Pixel.HistogramEnabled;
	 break;
      case GL_MINMAX:
         CHECK_EXTENSION_B(EXT_histogram, pname);
         *params = ctx->Pixel.MinMaxEnabled;
         break;

a1262 1
         CHECK_EXTENSION_B(EXT_secondary_color, pname);
a1265 1
         CHECK_EXTENSION_B(EXT_secondary_color, pname);
d1267 3
a1269 4
         params[0] = INT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][0]);
         params[1] = INT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][1]);
         params[2] = INT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][2]);
         params[3] = INT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_COLOR1][3]);
a1271 1
         CHECK_EXTENSION_B(EXT_secondary_color, pname);
a1274 1
         CHECK_EXTENSION_B(EXT_secondary_color, pname);
a1277 1
         CHECK_EXTENSION_B(EXT_secondary_color, pname);
d1281 1
a1281 2
         CHECK_EXTENSION_B(EXT_secondary_color, pname);
	 *params = INT_TO_BOOL(ctx->Array.SecondaryColor.Size);
a1285 1
         CHECK_EXTENSION_B(EXT_fog_coord, pname);
d1287 1
a1287 1
	 *params = FLOAT_TO_BOOL(ctx->Current.Attrib[VERT_ATTRIB_FOG][0]);
a1289 1
         CHECK_EXTENSION_B(EXT_fog_coord, pname);
a1292 1
         CHECK_EXTENSION_B(EXT_fog_coord, pname);
a1295 1
         CHECK_EXTENSION_B(EXT_fog_coord, pname);
a1297 4
      case GL_FOG_COORDINATE_SOURCE_EXT:
         CHECK_EXTENSION_B(EXT_fog_coord, pname);
	 *params = ENUM_TO_BOOL(ctx->Fog.FogCoordinateSource);
	 break;
d1306 7
a1312 2
         CHECK_EXTENSION_B(EXT_texture_filter_anisotropic, pname);
         *params = FLOAT_TO_BOOL(ctx->Const.MaxTextureMaxAnisotropy);
d1317 7
a1323 2
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = ctx->Multisample.Enabled;
d1326 7
a1332 2
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = ctx->Multisample.SampleAlphaToCoverage;
d1335 7
a1341 2
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = ctx->Multisample.SampleAlphaToOne;
d1344 7
a1350 2
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = ctx->Multisample.SampleCoverage;
d1353 7
a1359 2
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = FLOAT_TO_BOOL(ctx->Multisample.SampleCoverageValue);
d1362 7
a1368 2
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = ctx->Multisample.SampleCoverageInvert;
d1371 7
a1377 2
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = 0; /* XXX fix someday */
d1380 7
a1386 2
         CHECK_EXTENSION_B(ARB_multisample, pname);
         *params = 0; /* XXX fix someday */
d1391 7
a1397 12
         CHECK_EXTENSION_B(IBM_rasterpos_clip, pname);
         *params = ctx->Transform.RasterPositionUnclipped;
         break;

      /* GL_NV_point_sprite */
      case GL_POINT_SPRITE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = ctx->Point.PointSprite;
         break;
      case GL_POINT_SPRITE_R_MODE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = ENUM_TO_BOOL(ctx->Point.SpriteRMode);
d1402 2
a1403 62
         CHECK_EXTENSION_B(SGIS_generate_mipmap, pname);
         *params = ENUM_TO_BOOL(ctx->Hint.GenerateMipmap);
         break;

#if FEATURE_NV_vertex_program
      case GL_VERTEX_PROGRAM_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = ctx->VertexProgram.Enabled;
         break;
      case GL_VERTEX_PROGRAM_POINT_SIZE_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = ctx->VertexProgram.PointSizeEnabled;
         break;
      case GL_VERTEX_PROGRAM_TWO_SIDE_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = ctx->VertexProgram.TwoSideEnabled;
         break;
      case GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = (MAX_PROGRAM_STACK_DEPTH > 0) ? GL_TRUE : GL_FALSE;
         break;
      case GL_MAX_TRACK_MATRICES_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = (MAX_PROGRAM_MATRICES > 0) ? GL_TRUE : GL_FALSE;
         break;
      case GL_CURRENT_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = GL_TRUE;
         break;
      case GL_CURRENT_MATRIX_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         for (i = 0; i < 16; i++)
            params[i] = FLOAT_TO_BOOL(ctx->CurrentStack->Top->m[i]);
         break;
      case GL_VERTEX_PROGRAM_BINDING_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = (ctx->VertexProgram.CurrentID != 0) ? GL_TRUE : GL_FALSE;
         break;
      case GL_PROGRAM_ERROR_POSITION_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         *params = (ctx->VertexProgram.ErrorPos != 0) ? GL_TRUE : GL_FALSE;
         break;
      case GL_VERTEX_ATTRIB_ARRAY0_NV:
      case GL_VERTEX_ATTRIB_ARRAY1_NV:
      case GL_VERTEX_ATTRIB_ARRAY2_NV:
      case GL_VERTEX_ATTRIB_ARRAY3_NV:
      case GL_VERTEX_ATTRIB_ARRAY4_NV:
      case GL_VERTEX_ATTRIB_ARRAY5_NV:
      case GL_VERTEX_ATTRIB_ARRAY6_NV:
      case GL_VERTEX_ATTRIB_ARRAY7_NV:
      case GL_VERTEX_ATTRIB_ARRAY8_NV:
      case GL_VERTEX_ATTRIB_ARRAY9_NV:
      case GL_VERTEX_ATTRIB_ARRAY10_NV:
      case GL_VERTEX_ATTRIB_ARRAY11_NV:
      case GL_VERTEX_ATTRIB_ARRAY12_NV:
      case GL_VERTEX_ATTRIB_ARRAY13_NV:
      case GL_VERTEX_ATTRIB_ARRAY14_NV:
      case GL_VERTEX_ATTRIB_ARRAY15_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_VERTEX_ATTRIB_ARRAY0_NV;
            *params = ctx->Array.VertexAttrib[n].Enabled;
d1405 3
a1407 43
         break;
      case GL_MAP1_VERTEX_ATTRIB0_4_NV:
      case GL_MAP1_VERTEX_ATTRIB1_4_NV:
      case GL_MAP1_VERTEX_ATTRIB2_4_NV:
      case GL_MAP1_VERTEX_ATTRIB3_4_NV:
      case GL_MAP1_VERTEX_ATTRIB4_4_NV:
      case GL_MAP1_VERTEX_ATTRIB5_4_NV:
      case GL_MAP1_VERTEX_ATTRIB6_4_NV:
      case GL_MAP1_VERTEX_ATTRIB7_4_NV:
      case GL_MAP1_VERTEX_ATTRIB8_4_NV:
      case GL_MAP1_VERTEX_ATTRIB9_4_NV:
      case GL_MAP1_VERTEX_ATTRIB10_4_NV:
      case GL_MAP1_VERTEX_ATTRIB11_4_NV:
      case GL_MAP1_VERTEX_ATTRIB12_4_NV:
      case GL_MAP1_VERTEX_ATTRIB13_4_NV:
      case GL_MAP1_VERTEX_ATTRIB14_4_NV:
      case GL_MAP1_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP1_VERTEX_ATTRIB0_4_NV;
            *params = ctx->Eval.Map1Attrib[n];
         }
         break;
      case GL_MAP2_VERTEX_ATTRIB0_4_NV:
      case GL_MAP2_VERTEX_ATTRIB1_4_NV:
      case GL_MAP2_VERTEX_ATTRIB2_4_NV:
      case GL_MAP2_VERTEX_ATTRIB3_4_NV:
      case GL_MAP2_VERTEX_ATTRIB4_4_NV:
      case GL_MAP2_VERTEX_ATTRIB5_4_NV:
      case GL_MAP2_VERTEX_ATTRIB6_4_NV:
      case GL_MAP2_VERTEX_ATTRIB7_4_NV:
      case GL_MAP2_VERTEX_ATTRIB8_4_NV:
      case GL_MAP2_VERTEX_ATTRIB9_4_NV:
      case GL_MAP2_VERTEX_ATTRIB10_4_NV:
      case GL_MAP2_VERTEX_ATTRIB11_4_NV:
      case GL_MAP2_VERTEX_ATTRIB12_4_NV:
      case GL_MAP2_VERTEX_ATTRIB13_4_NV:
      case GL_MAP2_VERTEX_ATTRIB14_4_NV:
      case GL_MAP2_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP2_VERTEX_ATTRIB0_4_NV;
            *params = ctx->Eval.Map2Attrib[n];
a1409 1
#endif /* FEATURE_NV_vertex_program */
a1424 10
      /* GL_EXT_stencil_two_side */
      case GL_STENCIL_TEST_TWO_SIDE_EXT:
         CHECK_EXTENSION_B(EXT_stencil_two_side, pname);
         *params = ctx->Stencil.TestTwoSide;
         break;
      case GL_ACTIVE_STENCIL_FACE_EXT:
         CHECK_EXTENSION_B(EXT_stencil_two_side, pname);
         *params = ENUM_TO_BOOL(ctx->Stencil.ActiveFace ? GL_BACK : GL_FRONT);
         break;

d1426 1
a1426 1
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetBooleanv(pname=0x%x)", pname);
d1449 1
a1449 1
      _mesa_debug(ctx, "glGetDoublev %s\n", _mesa_lookup_enum_by_nr(pname));
d1489 1
a1489 1
         *params = (GLdouble) ctx->Color.AlphaRef;
d1548 1
a1548 4
         if (ctx->Transform.ClipPlanesEnabled & (1 << (pname - GL_CLIP_PLANE0)))
            *params = 1.0;
         else
            *params = 0.0;
d1551 4
a1554 4
         params[0] = (GLdouble) ctx->Color.ClearColor[0];
         params[1] = (GLdouble) ctx->Color.ClearColor[1];
         params[2] = (GLdouble) ctx->Color.ClearColor[2];
         params[3] = (GLdouble) ctx->Color.ClearColor[3];
d1579 4
a1582 4
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0];
         params[1] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1];
         params[2] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2];
         params[3] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3];
d1590 3
a1592 3
         params[0] = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_NORMAL][0];
         params[1] = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_NORMAL][1];
         params[2] = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_NORMAL][2];
d1613 4
a1616 4
	 params[0] = (GLdouble) ctx->Current.RasterTexCoords[texUnit][0];
	 params[1] = (GLdouble) ctx->Current.RasterTexCoords[texUnit][1];
	 params[2] = (GLdouble) ctx->Current.RasterTexCoords[texUnit][2];
	 params[3] = (GLdouble) ctx->Current.RasterTexCoords[texUnit][3];
d1623 4
a1626 4
	 params[0] = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][0];
	 params[1] = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][1];
	 params[2] = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][2];
	 params[3] = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][3];
d1711 9
d1802 2
a1803 6
         if (!ctx->CompileFlag)
            *params = 0.0;
         else if (ctx->ExecuteFlag)
            *params = ENUM_TO_DOUBLE(GL_COMPILE_AND_EXECUTE);
         else
            *params = ENUM_TO_DOUBLE(GL_COMPILE);
d1943 3
d1948 1
a1948 1
	    params[i] = (GLdouble) ctx->ModelviewMatrixStack.Top->m[i];
d1952 1
a1952 1
	 *params = (GLdouble) (ctx->ModelviewMatrixStack.Depth + 1);
d2078 1
a2078 1
	    params[i] = (GLdouble) ctx->ProjectionMatrixStack.Top->m[i];
d2082 1
a2082 1
	 *params = (GLdouble) (ctx->ProjectionMatrixStack.Depth + 1);
d2130 1
a2130 1
	 *params = ENUM_TO_DOUBLE(ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace]);
d2133 1
a2133 1
	 *params = ENUM_TO_DOUBLE(ctx->Stencil.Function[ctx->Stencil.ActiveFace]);
d2136 1
a2136 1
	 *params = ENUM_TO_DOUBLE(ctx->Stencil.ZFailFunc[ctx->Stencil.ActiveFace]);
d2139 1
a2139 1
	 *params = ENUM_TO_DOUBLE(ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace]);
d2142 1
a2142 1
	 *params = (GLdouble) ctx->Stencil.Ref[ctx->Stencil.ActiveFace];
d2148 1
a2148 1
	 *params = (GLdouble) ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace];
d2151 1
a2151 1
	 *params = (GLdouble) ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace];
d2200 1
a2200 1
	    params[i] = (GLdouble) ctx->TextureMatrixStack[texUnit].Top->m[i];
d2204 1
a2204 1
	 *params = (GLdouble) (ctx->TextureMatrixStack[texUnit].Depth + 1);
a2325 1
         CHECK_EXTENSION_D(ARB_multitexture, pname);
a2328 1
         CHECK_EXTENSION_D(ARB_multitexture, pname);
a2331 1
         CHECK_EXTENSION_D(ARB_multitexture, pname);
d2337 5
a2341 3
         CHECK_EXTENSION_D(ARB_texture_cube_map, pname);
         *params = (GLdouble) _mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB);
         break;
d2343 5
a2347 3
         CHECK_EXTENSION_D(ARB_texture_cube_map, pname);
         *params = (GLdouble) textureUnit->CurrentCubeMap->Name;
         break;
d2349 5
a2353 3
         CHECK_EXTENSION_D(ARB_texture_cube_map, pname);
         *params = (GLdouble) (1 << (ctx->Const.MaxCubeTextureLevels - 1));
         break;
d2357 5
a2361 2
         CHECK_EXTENSION_D(ARB_texture_compression, pname);
         *params = (GLdouble) ctx->Hint.TextureCompression;
d2364 5
a2368 2
         CHECK_EXTENSION_D(ARB_texture_compression, pname);
         *params = (GLdouble) _mesa_get_compressed_formats(ctx, NULL);
d2371 4
a2374 7
         CHECK_EXTENSION_D(ARB_texture_compression, pname);
         {
            GLint formats[100];
            GLuint i, n;
            n = _mesa_get_compressed_formats(ctx, formats);
            for (i = 0; i < n; i++)
               params[i] = (GLdouble) formats[i];
d2376 2
d2393 1
a2393 1
            _math_transposef(tm, ctx->ColorMatrixStack.Top->m);
d2403 1
a2403 1
            _math_transposef(tm, ctx->ModelviewMatrixStack.Top->m);
d2413 1
a2413 1
            _math_transposef(tm, ctx->ProjectionMatrixStack.Top->m);
d2423 1
a2423 1
            _math_transposef(tm, ctx->TextureMatrixStack[texUnit].Top->m);
d2432 7
a2438 3
         CHECK_EXTENSION_D(HP_occlusion_test, pname);
         *params = (GLdouble) ctx->Depth.OcclusionTest;
         break;
d2440 13
a2452 9
         CHECK_EXTENSION_D(HP_occlusion_test, pname);
         if (ctx->Depth.OcclusionTest)
            *params = (GLdouble) ctx->OcclusionResult;
         else
            *params = (GLdouble) ctx->OcclusionResultSaved;
         /* reset flag now */
         ctx->OcclusionResult = GL_FALSE;
         ctx->OcclusionResultSaved = GL_FALSE;
         break;
d2470 1
a2470 1
	    params[i] = (GLdouble) ctx->ColorMatrixStack.Top->m[i];
d2474 1
a2474 1
         *params = (GLdouble) (ctx->ColorMatrixStack.Depth + 1);
d2506 7
a2512 2
         CHECK_EXTENSION_D(EXT_convolution, pname);
         *params = (GLdouble) ctx->Pixel.Convolution1DEnabled;
d2515 7
a2521 2
         CHECK_EXTENSION_D(EXT_convolution, pname);
         *params = (GLdouble) ctx->Pixel.Convolution2DEnabled;
d2524 7
a2530 2
         CHECK_EXTENSION_D(EXT_convolution, pname);
         *params = (GLdouble) ctx->Pixel.Separable2DEnabled;
a2532 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2535 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2538 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2541 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2544 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2547 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2550 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2553 1
         CHECK_EXTENSION_D(EXT_convolution, pname);
a2556 10
      /* GL_EXT_histogram (also in 1.2 imaging) */
      case GL_HISTOGRAM:
         CHECK_EXTENSION_D(EXT_histogram, pname);
         *params = (GLdouble) ctx->Pixel.HistogramEnabled;
	 break;
      case GL_MINMAX:
         CHECK_EXTENSION_D(EXT_histogram, pname);
         *params = (GLdouble) ctx->Pixel.MinMaxEnabled;
         break;

a2569 1
         CHECK_EXTENSION_D(EXT_secondary_color, pname);
a2572 1
         CHECK_EXTENSION_D(EXT_secondary_color, pname);
d2574 3
a2576 4
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][0];
         params[1] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][1];
         params[2] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][2];
         params[3] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][3];
a2578 1
         CHECK_EXTENSION_D(EXT_secondary_color, pname);
a2581 1
         CHECK_EXTENSION_D(EXT_secondary_color, pname);
a2584 1
         CHECK_EXTENSION_D(EXT_secondary_color, pname);
d2588 1
a2588 2
         CHECK_EXTENSION_D(EXT_secondary_color, pname);
	 *params = (GLdouble) ctx->Array.SecondaryColor.Size;
a2592 1
         CHECK_EXTENSION_D(EXT_fog_coord, pname);
d2594 1
a2594 1
	 *params = (GLdouble) ctx->Current.Attrib[VERT_ATTRIB_FOG][0];
a2596 1
         CHECK_EXTENSION_D(EXT_fog_coord, pname);
a2599 1
         CHECK_EXTENSION_D(EXT_fog_coord, pname);
a2602 1
         CHECK_EXTENSION_D(EXT_fog_coord, pname);
a2604 4
      case GL_FOG_COORDINATE_SOURCE_EXT:
         CHECK_EXTENSION_D(EXT_fog_coord, pname);
	 *params = (GLdouble) ctx->Fog.FogCoordinateSource;
	 break;
d2613 7
a2619 2
         CHECK_EXTENSION_D(EXT_texture_filter_anisotropic, pname);
         *params = (GLdouble) ctx->Const.MaxTextureMaxAnisotropy;
d2624 7
a2630 2
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = (GLdouble) ctx->Multisample.Enabled;
d2633 7
a2639 2
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = (GLdouble) ctx->Multisample.SampleAlphaToCoverage;
d2642 7
a2648 2
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = (GLdouble) ctx->Multisample.SampleAlphaToOne;
d2651 7
a2657 2
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = (GLdouble) ctx->Multisample.SampleCoverage;
d2660 7
a2666 2
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = ctx->Multisample.SampleCoverageValue;
d2669 7
a2675 2
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = (GLdouble) ctx->Multisample.SampleCoverageInvert;
d2678 7
a2684 2
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = 0.0; /* XXX fix someday */
d2687 7
a2693 2
         CHECK_EXTENSION_D(ARB_multisample, pname);
         *params = 0.0; /* XXX fix someday */
d2698 7
a2704 12
         CHECK_EXTENSION_D(IBM_rasterpos_clip, pname);
         *params = (GLdouble) ctx->Transform.RasterPositionUnclipped;
         break;

      /* GL_NV_point_sprite */
      case GL_POINT_SPRITE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = (GLdouble) ctx->Point.PointSprite;
         break;
      case GL_POINT_SPRITE_R_MODE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = (GLdouble) ctx->Point.SpriteRMode;
d2709 2
a2710 62
         CHECK_EXTENSION_D(SGIS_generate_mipmap, pname);
         *params = (GLdouble) ctx->Hint.GenerateMipmap;
         break;

#if FEATURE_NV_vertex_program
      case GL_VERTEX_PROGRAM_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) ctx->VertexProgram.Enabled;
         break;
      case GL_VERTEX_PROGRAM_POINT_SIZE_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) ctx->VertexProgram.PointSizeEnabled;
         break;
      case GL_VERTEX_PROGRAM_TWO_SIDE_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) ctx->VertexProgram.TwoSideEnabled;
         break;
      case GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) MAX_PROGRAM_STACK_DEPTH;
         break;
      case GL_MAX_TRACK_MATRICES_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) MAX_PROGRAM_MATRICES;
         break;
      case GL_CURRENT_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) ctx->CurrentStack->Depth + 1;
         break;
      case GL_CURRENT_MATRIX_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         for (i = 0; i < 16; i++)
            params[i] = (GLdouble) ctx->CurrentStack->Top->m[i];
         break;
      case GL_VERTEX_PROGRAM_BINDING_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) ctx->VertexProgram.CurrentID;
         break;
      case GL_PROGRAM_ERROR_POSITION_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         *params = (GLdouble) ctx->VertexProgram.ErrorPos;
         break;
      case GL_VERTEX_ATTRIB_ARRAY0_NV:
      case GL_VERTEX_ATTRIB_ARRAY1_NV:
      case GL_VERTEX_ATTRIB_ARRAY2_NV:
      case GL_VERTEX_ATTRIB_ARRAY3_NV:
      case GL_VERTEX_ATTRIB_ARRAY4_NV:
      case GL_VERTEX_ATTRIB_ARRAY5_NV:
      case GL_VERTEX_ATTRIB_ARRAY6_NV:
      case GL_VERTEX_ATTRIB_ARRAY7_NV:
      case GL_VERTEX_ATTRIB_ARRAY8_NV:
      case GL_VERTEX_ATTRIB_ARRAY9_NV:
      case GL_VERTEX_ATTRIB_ARRAY10_NV:
      case GL_VERTEX_ATTRIB_ARRAY11_NV:
      case GL_VERTEX_ATTRIB_ARRAY12_NV:
      case GL_VERTEX_ATTRIB_ARRAY13_NV:
      case GL_VERTEX_ATTRIB_ARRAY14_NV:
      case GL_VERTEX_ATTRIB_ARRAY15_NV:
         CHECK_EXTENSION_D(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_VERTEX_ATTRIB_ARRAY0_NV;
            *params = (GLdouble) ctx->Array.VertexAttrib[n].Enabled;
d2712 3
a2714 21
         break;
      case GL_MAP1_VERTEX_ATTRIB0_4_NV:
      case GL_MAP1_VERTEX_ATTRIB1_4_NV:
      case GL_MAP1_VERTEX_ATTRIB2_4_NV:
      case GL_MAP1_VERTEX_ATTRIB3_4_NV:
      case GL_MAP1_VERTEX_ATTRIB4_4_NV:
      case GL_MAP1_VERTEX_ATTRIB5_4_NV:
      case GL_MAP1_VERTEX_ATTRIB6_4_NV:
      case GL_MAP1_VERTEX_ATTRIB7_4_NV:
      case GL_MAP1_VERTEX_ATTRIB8_4_NV:
      case GL_MAP1_VERTEX_ATTRIB9_4_NV:
      case GL_MAP1_VERTEX_ATTRIB10_4_NV:
      case GL_MAP1_VERTEX_ATTRIB11_4_NV:
      case GL_MAP1_VERTEX_ATTRIB12_4_NV:
      case GL_MAP1_VERTEX_ATTRIB13_4_NV:
      case GL_MAP1_VERTEX_ATTRIB14_4_NV:
      case GL_MAP1_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP1_VERTEX_ATTRIB0_4_NV;
            *params = (GLdouble) ctx->Eval.Map1Attrib[n];
a2716 23
      case GL_MAP2_VERTEX_ATTRIB0_4_NV:
      case GL_MAP2_VERTEX_ATTRIB1_4_NV:
      case GL_MAP2_VERTEX_ATTRIB2_4_NV:
      case GL_MAP2_VERTEX_ATTRIB3_4_NV:
      case GL_MAP2_VERTEX_ATTRIB4_4_NV:
      case GL_MAP2_VERTEX_ATTRIB5_4_NV:
      case GL_MAP2_VERTEX_ATTRIB6_4_NV:
      case GL_MAP2_VERTEX_ATTRIB7_4_NV:
      case GL_MAP2_VERTEX_ATTRIB8_4_NV:
      case GL_MAP2_VERTEX_ATTRIB9_4_NV:
      case GL_MAP2_VERTEX_ATTRIB10_4_NV:
      case GL_MAP2_VERTEX_ATTRIB11_4_NV:
      case GL_MAP2_VERTEX_ATTRIB12_4_NV:
      case GL_MAP2_VERTEX_ATTRIB13_4_NV:
      case GL_MAP2_VERTEX_ATTRIB14_4_NV:
      case GL_MAP2_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP2_VERTEX_ATTRIB0_4_NV;
            *params = (GLdouble) ctx->Eval.Map2Attrib[n];
         }
         break;
#endif /* FEATURE_NV_vertex_program */
a2731 10
      /* GL_EXT_stencil_two_side */
      case GL_STENCIL_TEST_TWO_SIDE_EXT:
         CHECK_EXTENSION_D(EXT_stencil_two_side, pname);
         *params = (GLdouble) ctx->Stencil.TestTwoSide;
         break;
      case GL_ACTIVE_STENCIL_FACE_EXT:
         CHECK_EXTENSION_D(EXT_stencil_two_side, pname);
         *params = (GLdouble) (ctx->Stencil.ActiveFace ? GL_BACK : GL_FRONT);
         break;

d2733 1
a2733 1
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetDoublev(pname=0x%x)", pname);
d2738 7
d2763 1
a2763 1
      _mesa_debug(ctx, "glGetFloatv %s\n", _mesa_lookup_enum_by_nr(pname));
d2803 1
a2803 1
         *params = (GLfloat) ctx->Color.AlphaRef;
d2862 1
a2862 4
         if (ctx->Transform.ClipPlanesEnabled & (1 << (pname - GL_CLIP_PLANE0)))
            *params = 1.0;
         else
            *params = 0.0;
d2865 4
a2868 4
         params[0] = ctx->Color.ClearColor[0];
         params[1] = ctx->Color.ClearColor[1];
         params[2] = ctx->Color.ClearColor[2];
         params[3] = ctx->Color.ClearColor[3];
d2893 4
a2896 4
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0];
         params[1] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1];
         params[2] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2];
         params[3] = ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3];
d2904 3
a2906 3
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_NORMAL][0];
         params[1] = ctx->Current.Attrib[VERT_ATTRIB_NORMAL][1];
         params[2] = ctx->Current.Attrib[VERT_ATTRIB_NORMAL][2];
d2927 4
a2930 4
	 params[0] = ctx->Current.RasterTexCoords[texUnit][0];
	 params[1] = ctx->Current.RasterTexCoords[texUnit][1];
	 params[2] = ctx->Current.RasterTexCoords[texUnit][2];
	 params[3] = ctx->Current.RasterTexCoords[texUnit][3];
d2937 4
a2940 4
	 params[0] = (GLfloat) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][0];
	 params[1] = (GLfloat) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][1];
	 params[2] = (GLfloat) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][2];
	 params[3] = (GLfloat) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][3];
d3025 9
d3116 2
a3117 6
         if (!ctx->CompileFlag)
            *params = 0.0F;
         else if (ctx->ExecuteFlag)
            *params = ENUM_TO_FLOAT(GL_COMPILE_AND_EXECUTE);
         else
            *params = ENUM_TO_FLOAT(GL_COMPILE);
d3257 3
d3262 1
a3262 1
	    params[i] = ctx->ModelviewMatrixStack.Top->m[i];
d3266 1
a3266 1
	 *params = (GLfloat) (ctx->ModelviewMatrixStack.Depth + 1);
d3394 1
a3394 1
	    params[i] = ctx->ProjectionMatrixStack.Top->m[i];
d3398 1
a3398 1
	 *params = (GLfloat) (ctx->ProjectionMatrixStack.Depth + 1);
d3446 1
a3446 1
	 *params = ENUM_TO_FLOAT(ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace]);
d3449 1
a3449 1
	 *params = ENUM_TO_FLOAT(ctx->Stencil.Function[ctx->Stencil.ActiveFace]);
d3452 1
a3452 1
	 *params = ENUM_TO_FLOAT(ctx->Stencil.ZFailFunc[ctx->Stencil.ActiveFace]);
d3455 1
a3455 1
	 *params = ENUM_TO_FLOAT(ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace]);
d3458 1
a3458 1
	 *params = (GLfloat) ctx->Stencil.Ref[ctx->Stencil.ActiveFace];
d3464 1
a3464 1
	 *params = (GLfloat) ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace];
d3467 1
a3467 1
	 *params = (GLfloat) ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace];
d3516 1
a3516 1
	    params[i] = ctx->TextureMatrixStack[texUnit].Top->m[i];
d3520 1
a3520 1
	 *params = (GLfloat) (ctx->TextureMatrixStack[texUnit].Depth + 1);
a3641 1
         CHECK_EXTENSION_F(ARB_multitexture, pname);
a3644 1
         CHECK_EXTENSION_F(ARB_multitexture, pname);
a3647 1
         CHECK_EXTENSION_F(ARB_multitexture, pname);
d3653 5
a3657 3
         CHECK_EXTENSION_F(ARB_texture_cube_map, pname);
         *params = (GLfloat) _mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB);
         break;
d3659 5
a3663 3
         CHECK_EXTENSION_F(ARB_texture_cube_map, pname);
         *params = (GLfloat) textureUnit->CurrentCubeMap->Name;
         break;
d3665 5
a3669 3
         CHECK_EXTENSION_F(ARB_texture_cube_map, pname);
         *params = (GLfloat) (1 << (ctx->Const.MaxCubeTextureLevels - 1));
         break;
d3673 5
a3677 2
         CHECK_EXTENSION_F(ARB_texture_compression, pname);
         *params = (GLfloat) ctx->Hint.TextureCompression;
d3680 5
a3684 2
         CHECK_EXTENSION_F(ARB_texture_compression, pname);
         *params = (GLfloat) _mesa_get_compressed_formats(ctx, NULL);
d3687 4
a3690 7
         CHECK_EXTENSION_F(ARB_texture_compression, pname);
         {
            GLint formats[100];
            GLuint i, n;
            n = _mesa_get_compressed_formats(ctx, formats);
            for (i = 0; i < n; i++)
               params[i] = (GLfloat) formats[i];
d3692 2
a3697 1
         CHECK_EXTENSION_F(EXT_compiled_vertex_array, pname);
a3700 1
         CHECK_EXTENSION_F(EXT_compiled_vertex_array, pname);
d3706 1
a3706 1
         _math_transposef(params, ctx->ColorMatrixStack.Top->m);
d3709 1
a3709 1
         _math_transposef(params, ctx->ModelviewMatrixStack.Top->m);
d3712 1
a3712 1
         _math_transposef(params, ctx->ProjectionMatrixStack.Top->m);
d3715 1
a3715 1
         _math_transposef(params, ctx->TextureMatrixStack[texUnit].Top->m);
d3720 7
a3726 3
         CHECK_EXTENSION_F(HP_occlusion_test, pname);
         *params = (GLfloat) ctx->Depth.OcclusionTest;
         break;
d3728 13
a3740 9
         CHECK_EXTENSION_F(HP_occlusion_test, pname);
         if (ctx->Depth.OcclusionTest)
            *params = (GLfloat) ctx->OcclusionResult;
         else
            *params = (GLfloat) ctx->OcclusionResultSaved;
         /* reset flag now */
         ctx->OcclusionResult = GL_FALSE;
         ctx->OcclusionResultSaved = GL_FALSE;
         break;
d3758 1
a3758 1
	    params[i] = ctx->ColorMatrixStack.Top->m[i];
d3762 1
a3762 1
         *params = (GLfloat) (ctx->ColorMatrixStack.Depth + 1);
d3794 7
a3800 2
         CHECK_EXTENSION_F(EXT_convolution, pname);
         *params = (GLfloat) ctx->Pixel.Convolution1DEnabled;
d3803 7
a3809 2
         CHECK_EXTENSION_F(EXT_convolution, pname);
         *params = (GLfloat) ctx->Pixel.Convolution2DEnabled;
d3812 7
a3818 2
         CHECK_EXTENSION_F(EXT_convolution, pname);
         *params = (GLfloat) ctx->Pixel.Separable2DEnabled;
a3820 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3823 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3826 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3829 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3832 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3835 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3838 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3841 1
         CHECK_EXTENSION_F(EXT_convolution, pname);
a3844 10
      /* GL_EXT_histogram (also in 1.2 imaging) */
      case GL_HISTOGRAM:
         CHECK_EXTENSION_F(EXT_histogram, pname);
         *params = (GLfloat) ctx->Pixel.HistogramEnabled;
	 break;
      case GL_MINMAX:
         CHECK_EXTENSION_F(EXT_histogram, pname);
         *params = (GLfloat) ctx->Pixel.MinMaxEnabled;
         break;

a3857 1
         CHECK_EXTENSION_F(EXT_secondary_color, pname);
a3860 1
         CHECK_EXTENSION_F(EXT_secondary_color, pname);
d3862 3
a3864 4
         params[0] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][0];
         params[1] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][1];
         params[2] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][2];
         params[3] = ctx->Current.Attrib[VERT_ATTRIB_COLOR1][3];
a3866 1
         CHECK_EXTENSION_F(EXT_secondary_color, pname);
a3869 1
         CHECK_EXTENSION_F(EXT_secondary_color, pname);
a3872 1
         CHECK_EXTENSION_F(EXT_secondary_color, pname);
d3876 1
a3876 2
         CHECK_EXTENSION_F(EXT_secondary_color, pname);
	 *params = (GLfloat) ctx->Array.SecondaryColor.Size;
a3880 1
         CHECK_EXTENSION_F(EXT_fog_coord, pname);
d3882 1
a3882 1
	 *params = (GLfloat) ctx->Current.Attrib[VERT_ATTRIB_FOG][0];
a3884 1
         CHECK_EXTENSION_F(EXT_fog_coord, pname);
a3887 1
         CHECK_EXTENSION_F(EXT_fog_coord, pname);
a3890 1
         CHECK_EXTENSION_F(EXT_fog_coord, pname);
a3892 4
      case GL_FOG_COORDINATE_SOURCE_EXT:
         CHECK_EXTENSION_F(EXT_fog_coord, pname);
	 *params = (GLfloat) ctx->Fog.FogCoordinateSource;
	 break;
d3901 7
a3907 2
         CHECK_EXTENSION_F(EXT_texture_filter_anisotropic, pname);
         *params = ctx->Const.MaxTextureMaxAnisotropy;
d3912 7
a3918 2
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = (GLfloat) ctx->Multisample.Enabled;
d3921 7
a3927 2
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = (GLfloat) ctx->Multisample.SampleAlphaToCoverage;
d3930 7
a3936 2
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = (GLfloat) ctx->Multisample.SampleAlphaToOne;
d3939 7
a3945 2
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = (GLfloat) ctx->Multisample.SampleCoverage;
d3948 7
a3954 2
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = ctx->Multisample.SampleCoverageValue;
d3957 7
a3963 2
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = (GLfloat) ctx->Multisample.SampleCoverageInvert;
d3966 7
a3972 2
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = 0.0; /* XXX fix someday */
d3975 7
a3981 2
         CHECK_EXTENSION_F(ARB_multisample, pname);
         *params = 0.0; /* XXX fix someday */
d3986 7
a3992 12
         CHECK_EXTENSION_F(IBM_rasterpos_clip, pname);
         *params = (GLfloat) ctx->Transform.RasterPositionUnclipped;
         break;

      /* GL_NV_point_sprite */
      case GL_POINT_SPRITE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = (GLfloat) ctx->Point.PointSprite;
         break;
      case GL_POINT_SPRITE_R_MODE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = (GLfloat) ctx->Point.SpriteRMode;
d3997 2
a3998 62
         CHECK_EXTENSION_F(SGIS_generate_mipmap, pname);
         *params = (GLfloat) ctx->Hint.GenerateMipmap;
         break;

#if FEATURE_NV_vertex_program
      case GL_VERTEX_PROGRAM_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) ctx->VertexProgram.Enabled;
         break;
      case GL_VERTEX_PROGRAM_POINT_SIZE_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) ctx->VertexProgram.PointSizeEnabled;
         break;
      case GL_VERTEX_PROGRAM_TWO_SIDE_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) ctx->VertexProgram.TwoSideEnabled;
         break;
      case GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) MAX_PROGRAM_STACK_DEPTH;
         break;
      case GL_MAX_TRACK_MATRICES_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) MAX_PROGRAM_MATRICES;
         break;
      case GL_CURRENT_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) ctx->CurrentStack->Depth + 1;
         break;
      case GL_CURRENT_MATRIX_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         for (i = 0; i < 16; i++)
            params[i] = ctx->CurrentStack->Top->m[i];
         break;
      case GL_VERTEX_PROGRAM_BINDING_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) ctx->VertexProgram.CurrentID;
         break;
      case GL_PROGRAM_ERROR_POSITION_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         *params = (GLfloat) ctx->VertexProgram.ErrorPos;
         break;
      case GL_VERTEX_ATTRIB_ARRAY0_NV:
      case GL_VERTEX_ATTRIB_ARRAY1_NV:
      case GL_VERTEX_ATTRIB_ARRAY2_NV:
      case GL_VERTEX_ATTRIB_ARRAY3_NV:
      case GL_VERTEX_ATTRIB_ARRAY4_NV:
      case GL_VERTEX_ATTRIB_ARRAY5_NV:
      case GL_VERTEX_ATTRIB_ARRAY6_NV:
      case GL_VERTEX_ATTRIB_ARRAY7_NV:
      case GL_VERTEX_ATTRIB_ARRAY8_NV:
      case GL_VERTEX_ATTRIB_ARRAY9_NV:
      case GL_VERTEX_ATTRIB_ARRAY10_NV:
      case GL_VERTEX_ATTRIB_ARRAY11_NV:
      case GL_VERTEX_ATTRIB_ARRAY12_NV:
      case GL_VERTEX_ATTRIB_ARRAY13_NV:
      case GL_VERTEX_ATTRIB_ARRAY14_NV:
      case GL_VERTEX_ATTRIB_ARRAY15_NV:
         CHECK_EXTENSION_F(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_VERTEX_ATTRIB_ARRAY0_NV;
            *params = (GLfloat) ctx->Array.VertexAttrib[n].Enabled;
d4000 3
a4002 43
         break;
      case GL_MAP1_VERTEX_ATTRIB0_4_NV:
      case GL_MAP1_VERTEX_ATTRIB1_4_NV:
      case GL_MAP1_VERTEX_ATTRIB2_4_NV:
      case GL_MAP1_VERTEX_ATTRIB3_4_NV:
      case GL_MAP1_VERTEX_ATTRIB4_4_NV:
      case GL_MAP1_VERTEX_ATTRIB5_4_NV:
      case GL_MAP1_VERTEX_ATTRIB6_4_NV:
      case GL_MAP1_VERTEX_ATTRIB7_4_NV:
      case GL_MAP1_VERTEX_ATTRIB8_4_NV:
      case GL_MAP1_VERTEX_ATTRIB9_4_NV:
      case GL_MAP1_VERTEX_ATTRIB10_4_NV:
      case GL_MAP1_VERTEX_ATTRIB11_4_NV:
      case GL_MAP1_VERTEX_ATTRIB12_4_NV:
      case GL_MAP1_VERTEX_ATTRIB13_4_NV:
      case GL_MAP1_VERTEX_ATTRIB14_4_NV:
      case GL_MAP1_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP1_VERTEX_ATTRIB0_4_NV;
            *params = (GLfloat) ctx->Eval.Map1Attrib[n];
         }
         break;
      case GL_MAP2_VERTEX_ATTRIB0_4_NV:
      case GL_MAP2_VERTEX_ATTRIB1_4_NV:
      case GL_MAP2_VERTEX_ATTRIB2_4_NV:
      case GL_MAP2_VERTEX_ATTRIB3_4_NV:
      case GL_MAP2_VERTEX_ATTRIB4_4_NV:
      case GL_MAP2_VERTEX_ATTRIB5_4_NV:
      case GL_MAP2_VERTEX_ATTRIB6_4_NV:
      case GL_MAP2_VERTEX_ATTRIB7_4_NV:
      case GL_MAP2_VERTEX_ATTRIB8_4_NV:
      case GL_MAP2_VERTEX_ATTRIB9_4_NV:
      case GL_MAP2_VERTEX_ATTRIB10_4_NV:
      case GL_MAP2_VERTEX_ATTRIB11_4_NV:
      case GL_MAP2_VERTEX_ATTRIB12_4_NV:
      case GL_MAP2_VERTEX_ATTRIB13_4_NV:
      case GL_MAP2_VERTEX_ATTRIB14_4_NV:
      case GL_MAP2_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP2_VERTEX_ATTRIB0_4_NV;
            *params = (GLfloat) ctx->Eval.Map2Attrib[n];
a4018 1
#endif /* FEATURE_NV_vertex_program */
d4020 2
a4021 12
      /* GL_EXT_stencil_two_side */
      case GL_STENCIL_TEST_TWO_SIDE_EXT:
         CHECK_EXTENSION_F(EXT_stencil_two_side, pname);
         *params = (GLfloat) ctx->Stencil.TestTwoSide;
         break;
      case GL_ACTIVE_STENCIL_FACE_EXT:
         CHECK_EXTENSION_F(EXT_stencil_two_side, pname);
         *params = (GLfloat) (ctx->Stencil.ActiveFace ? GL_BACK : GL_FRONT);
         break;

      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetFloatv(0x%x)", pname);
d4044 1
a4044 1
      _mesa_debug(ctx, "glGetIntegerv %s\n", _mesa_lookup_enum_by_nr(pname));
d4082 1
a4082 1
         *params = FLOAT_TO_INT(ctx->Color.AlphaRef);
d4144 2
a4145 4
         if (ctx->Transform.ClipPlanesEnabled & (1 << (pname - GL_CLIP_PLANE0)))
            *params = 1;
         else
            *params = 0;
d4176 4
a4179 4
         params[0] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][0]);
         params[1] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][1]);
         params[2] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][2]);
         params[3] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_COLOR0][3]);
d4187 3
a4189 3
         params[0] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][0]);
         params[1] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][1]);
         params[2] = FLOAT_TO_INT(ctx->Current.Attrib[VERT_ATTRIB_NORMAL][2]);
d4210 4
a4213 4
	 params[0] = (GLint) ctx->Current.RasterTexCoords[texUnit][0];
	 params[1] = (GLint) ctx->Current.RasterTexCoords[texUnit][1];
	 params[2] = (GLint) ctx->Current.RasterTexCoords[texUnit][2];
	 params[3] = (GLint) ctx->Current.RasterTexCoords[texUnit][3];
d4220 4
a4223 4
         params[0] = (GLint) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][0];
         params[1] = (GLint) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][1];
         params[2] = (GLint) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][2];
         params[3] = (GLint) ctx->Current.Attrib[VERT_ATTRIB_TEX0 + texUnit][3];
d4308 9
d4399 2
a4400 6
         if (!ctx->CompileFlag)
            *params = 0;
         else if (ctx->ExecuteFlag)
            *params = (GLint) GL_COMPILE_AND_EXECUTE;
         else
            *params = (GLint) GL_COMPILE;
d4540 3
d4545 1
a4545 1
	    params[i] = (GLint) ctx->ModelviewMatrixStack.Top->m[i];
d4549 1
a4549 1
	 *params = (GLint) (ctx->ModelviewMatrixStack.Depth + 1);
d4675 1
a4675 1
	    params[i] = (GLint) ctx->ProjectionMatrixStack.Top->m[i];
d4679 1
a4679 1
	 *params = (GLint) (ctx->ProjectionMatrixStack.Depth + 1);
d4727 1
a4727 1
	 *params = (GLint) ctx->Stencil.FailFunc[ctx->Stencil.ActiveFace];
d4730 1
a4730 1
	 *params = (GLint) ctx->Stencil.Function[ctx->Stencil.ActiveFace];
d4733 1
a4733 1
	 *params = (GLint) ctx->Stencil.ZFailFunc[ctx->Stencil.ActiveFace];
d4736 1
a4736 1
	 *params = (GLint) ctx->Stencil.ZPassFunc[ctx->Stencil.ActiveFace];
d4739 1
a4739 1
	 *params = (GLint) ctx->Stencil.Ref[ctx->Stencil.ActiveFace];
d4745 1
a4745 1
	 *params = (GLint) ctx->Stencil.ValueMask[ctx->Stencil.ActiveFace];
d4748 1
a4748 1
	 *params = (GLint) ctx->Stencil.WriteMask[ctx->Stencil.ActiveFace];
d4797 1
a4797 1
	    params[i] = (GLint) ctx->TextureMatrixStack[texUnit].Top->m[i];
d4801 1
a4801 1
	 *params = (GLint) (ctx->TextureMatrixStack[texUnit].Depth + 1);
a4922 1
         CHECK_EXTENSION_I(ARB_multitexture, pname);
a4925 1
         CHECK_EXTENSION_I(ARB_multitexture, pname);
a4928 1
         CHECK_EXTENSION_I(ARB_multitexture, pname);
d4934 5
a4938 3
         CHECK_EXTENSION_I(ARB_texture_cube_map, pname);
         *params = (GLint) _mesa_IsEnabled(GL_TEXTURE_CUBE_MAP_ARB);
         break;
d4940 5
a4944 3
         CHECK_EXTENSION_I(ARB_texture_cube_map, pname);
         *params = textureUnit->CurrentCubeMap->Name;
         break;
d4946 5
a4950 3
         CHECK_EXTENSION_I(ARB_texture_cube_map, pname);
         *params = (1 << (ctx->Const.MaxCubeTextureLevels - 1));
         break;
d4954 5
a4958 2
         CHECK_EXTENSION_I(ARB_texture_compression, pname);
         *params = (GLint) ctx->Hint.TextureCompression;
d4961 5
a4965 2
         CHECK_EXTENSION_I(ARB_texture_compression, pname);
         *params = (GLint) _mesa_get_compressed_formats(ctx, NULL);
d4968 7
a4974 2
         CHECK_EXTENSION_I(ARB_texture_compression, pname);
         (void) _mesa_get_compressed_formats(ctx, params);
a4978 1
         CHECK_EXTENSION_I(EXT_compiled_vertex_array, pname);
a4981 1
         CHECK_EXTENSION_I(EXT_compiled_vertex_array, pname);
d4990 1
a4990 1
            _math_transposef(tm, ctx->ColorMatrixStack.Top->m);
d5000 1
a5000 1
            _math_transposef(tm, ctx->ModelviewMatrixStack.Top->m);
d5010 1
a5010 1
            _math_transposef(tm, ctx->ProjectionMatrixStack.Top->m);
d5020 1
a5020 1
            _math_transposef(tm, ctx->TextureMatrixStack[texUnit].Top->m);
d5029 7
a5035 3
         CHECK_EXTENSION_I(HP_occlusion_test, pname);
         *params = (GLint) ctx->Depth.OcclusionTest;
         break;
d5037 13
a5049 9
         CHECK_EXTENSION_I(HP_occlusion_test, pname);
         if (ctx->Depth.OcclusionTest)
            *params = (GLint) ctx->OcclusionResult;
         else
            *params = (GLint) ctx->OcclusionResultSaved;
         /* reset flag now */
         ctx->OcclusionResult = GL_FALSE;
         ctx->OcclusionResultSaved = GL_FALSE;
         break;
a5052 1
         CHECK_EXTENSION_I(SGIS_pixel_texture, pname);
a5057 1
         CHECK_EXTENSION_I(SGIX_pixel_texture, pname);
a5060 1
         CHECK_EXTENSION_I(SGIX_pixel_texture, pname);
a5065 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
d5067 1
a5067 1
	    params[i] = (GLint) ctx->ColorMatrixStack.Top->m[i];
d5071 1
a5071 2
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
         *params = ctx->ColorMatrixStack.Depth + 1;
a5073 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a5076 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a5079 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a5082 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a5085 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a5088 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a5091 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a5094 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
a5097 1
         CHECK_EXTENSION_I(SGI_color_matrix, pname);
d5103 7
a5109 2
         CHECK_EXTENSION_I(EXT_convolution, pname);
         *params = (GLint) ctx->Pixel.Convolution1DEnabled;
d5112 7
a5118 2
         CHECK_EXTENSION_I(EXT_convolution, pname);
         *params = (GLint) ctx->Pixel.Convolution2DEnabled;
d5121 7
a5127 2
         CHECK_EXTENSION_I(EXT_convolution, pname);
         *params = (GLint) ctx->Pixel.Separable2DEnabled;
a5129 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a5132 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a5135 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a5138 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a5141 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a5144 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a5147 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a5150 1
         CHECK_EXTENSION_I(EXT_convolution, pname);
a5153 10
      /* GL_EXT_histogram (also in 1.2 imaging) */
      case GL_HISTOGRAM:
         CHECK_EXTENSION_I(EXT_histogram, pname);
         *params = (GLint) ctx->Pixel.HistogramEnabled;
	 break;
      case GL_MINMAX:
         CHECK_EXTENSION_I(EXT_histogram, pname);
         *params = (GLint) ctx->Pixel.MinMaxEnabled;
         break;

a5155 1
         CHECK_EXTENSION_I(SGI_color_table, pname);
a5158 1
         CHECK_EXTENSION_I(SGI_color_table, pname);
a5161 1
         CHECK_EXTENSION_I(SGI_color_table, pname);
a5167 1
         CHECK_EXTENSION_I(EXT_secondary_color, pname);
a5170 1
         CHECK_EXTENSION_I(EXT_secondary_color, pname);
d5172 3
a5174 4
         params[0] = FLOAT_TO_INT( (ctx->Current.Attrib[VERT_ATTRIB_COLOR1][0]) );
         params[1] = FLOAT_TO_INT( (ctx->Current.Attrib[VERT_ATTRIB_COLOR1][1]) );
         params[2] = FLOAT_TO_INT( (ctx->Current.Attrib[VERT_ATTRIB_COLOR1][2]) );
         params[3] = FLOAT_TO_INT( (ctx->Current.Attrib[VERT_ATTRIB_COLOR1][3]) );
a5176 1
         CHECK_EXTENSION_I(EXT_secondary_color, pname);
a5179 1
         CHECK_EXTENSION_I(EXT_secondary_color, pname);
a5182 1
         CHECK_EXTENSION_I(EXT_secondary_color, pname);
d5186 1
a5186 2
         CHECK_EXTENSION_I(EXT_secondary_color, pname);
	 *params = (GLint) ctx->Array.SecondaryColor.Size;
d5191 7
a5197 3
         CHECK_EXTENSION_I(EXT_fog_coord, pname);
         FLUSH_CURRENT(ctx, 0);
         *params = (GLint) ctx->Current.Attrib[VERT_ATTRIB_FOG][0];
d5200 6
a5205 2
         CHECK_EXTENSION_I(EXT_fog_coord, pname);
         *params = (GLint) ctx->Array.FogCoord.Enabled;
d5208 6
a5213 2
         CHECK_EXTENSION_I(EXT_fog_coord, pname);
         *params = (GLint) ctx->Array.FogCoord.Type;
d5216 6
a5221 6
         CHECK_EXTENSION_I(EXT_fog_coord, pname);
         *params = (GLint) ctx->Array.FogCoord.Stride;
	 break;
      case GL_FOG_COORDINATE_SOURCE_EXT:
         CHECK_EXTENSION_I(EXT_fog_coord, pname);
	 *params = (GLint) ctx->Fog.FogCoordinateSource;
d5231 7
a5237 2
         CHECK_EXTENSION_I(EXT_texture_filter_anisotropic, pname);
         *params = (GLint) ctx->Const.MaxTextureMaxAnisotropy;
d5242 7
a5248 2
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = (GLint) ctx->Multisample.Enabled;
d5251 7
a5257 2
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = (GLint) ctx->Multisample.SampleAlphaToCoverage;
d5260 7
a5266 2
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = (GLint) ctx->Multisample.SampleAlphaToOne;
d5269 7
a5275 2
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = (GLint) ctx->Multisample.SampleCoverage;
d5278 7
a5284 2
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = (GLint) ctx->Multisample.SampleCoverageValue;
d5287 7
a5293 2
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = (GLint) ctx->Multisample.SampleCoverageInvert;
d5296 7
a5302 2
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = 0; /* XXX fix someday */
d5305 7
a5311 2
         CHECK_EXTENSION_I(ARB_multisample, pname);
         *params = 0; /* XXX fix someday */
d5316 7
a5322 12
         CHECK_EXTENSION_I(IBM_rasterpos_clip, pname);
         *params = (GLint) ctx->Transform.RasterPositionUnclipped;
         break;

      /* GL_NV_point_sprite */
      case GL_POINT_SPRITE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = (GLint) ctx->Point.PointSprite;
         break;
      case GL_POINT_SPRITE_R_MODE_NV:
         CHECK_EXTENSION_B(NV_point_sprite, pname);
         *params = (GLint) ctx->Point.SpriteRMode;
d5327 2
a5328 62
         CHECK_EXTENSION_I(SGIS_generate_mipmap, pname);
         *params = (GLint) ctx->Hint.GenerateMipmap;
         break;

#if FEATURE_NV_vertex_program
      case GL_VERTEX_PROGRAM_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = (GLint) ctx->VertexProgram.Enabled;
         break;
      case GL_VERTEX_PROGRAM_POINT_SIZE_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = (GLint) ctx->VertexProgram.PointSizeEnabled;
         break;
      case GL_VERTEX_PROGRAM_TWO_SIDE_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = (GLint) ctx->VertexProgram.TwoSideEnabled;
         break;
      case GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = MAX_PROGRAM_STACK_DEPTH;
         break;
      case GL_MAX_TRACK_MATRICES_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = MAX_PROGRAM_MATRICES;
         break;
      case GL_CURRENT_MATRIX_STACK_DEPTH_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = ctx->CurrentStack->Depth + 1;
         break;
      case GL_CURRENT_MATRIX_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         for (i = 0; i < 16; i++)
            params[i] = (GLint) ctx->CurrentStack->Top->m[i];
         break;
      case GL_VERTEX_PROGRAM_BINDING_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = (GLint) ctx->VertexProgram.CurrentID;
         break;
      case GL_PROGRAM_ERROR_POSITION_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         *params = (GLint) ctx->VertexProgram.ErrorPos;
         break;
      case GL_VERTEX_ATTRIB_ARRAY0_NV:
      case GL_VERTEX_ATTRIB_ARRAY1_NV:
      case GL_VERTEX_ATTRIB_ARRAY2_NV:
      case GL_VERTEX_ATTRIB_ARRAY3_NV:
      case GL_VERTEX_ATTRIB_ARRAY4_NV:
      case GL_VERTEX_ATTRIB_ARRAY5_NV:
      case GL_VERTEX_ATTRIB_ARRAY6_NV:
      case GL_VERTEX_ATTRIB_ARRAY7_NV:
      case GL_VERTEX_ATTRIB_ARRAY8_NV:
      case GL_VERTEX_ATTRIB_ARRAY9_NV:
      case GL_VERTEX_ATTRIB_ARRAY10_NV:
      case GL_VERTEX_ATTRIB_ARRAY11_NV:
      case GL_VERTEX_ATTRIB_ARRAY12_NV:
      case GL_VERTEX_ATTRIB_ARRAY13_NV:
      case GL_VERTEX_ATTRIB_ARRAY14_NV:
      case GL_VERTEX_ATTRIB_ARRAY15_NV:
         CHECK_EXTENSION_I(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_VERTEX_ATTRIB_ARRAY0_NV;
            *params = (GLint) ctx->Array.VertexAttrib[n].Enabled;
d5330 3
a5332 43
         break;
      case GL_MAP1_VERTEX_ATTRIB0_4_NV:
      case GL_MAP1_VERTEX_ATTRIB1_4_NV:
      case GL_MAP1_VERTEX_ATTRIB2_4_NV:
      case GL_MAP1_VERTEX_ATTRIB3_4_NV:
      case GL_MAP1_VERTEX_ATTRIB4_4_NV:
      case GL_MAP1_VERTEX_ATTRIB5_4_NV:
      case GL_MAP1_VERTEX_ATTRIB6_4_NV:
      case GL_MAP1_VERTEX_ATTRIB7_4_NV:
      case GL_MAP1_VERTEX_ATTRIB8_4_NV:
      case GL_MAP1_VERTEX_ATTRIB9_4_NV:
      case GL_MAP1_VERTEX_ATTRIB10_4_NV:
      case GL_MAP1_VERTEX_ATTRIB11_4_NV:
      case GL_MAP1_VERTEX_ATTRIB12_4_NV:
      case GL_MAP1_VERTEX_ATTRIB13_4_NV:
      case GL_MAP1_VERTEX_ATTRIB14_4_NV:
      case GL_MAP1_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP1_VERTEX_ATTRIB0_4_NV;
            *params = (GLint) ctx->Eval.Map1Attrib[n];
         }
         break;
      case GL_MAP2_VERTEX_ATTRIB0_4_NV:
      case GL_MAP2_VERTEX_ATTRIB1_4_NV:
      case GL_MAP2_VERTEX_ATTRIB2_4_NV:
      case GL_MAP2_VERTEX_ATTRIB3_4_NV:
      case GL_MAP2_VERTEX_ATTRIB4_4_NV:
      case GL_MAP2_VERTEX_ATTRIB5_4_NV:
      case GL_MAP2_VERTEX_ATTRIB6_4_NV:
      case GL_MAP2_VERTEX_ATTRIB7_4_NV:
      case GL_MAP2_VERTEX_ATTRIB8_4_NV:
      case GL_MAP2_VERTEX_ATTRIB9_4_NV:
      case GL_MAP2_VERTEX_ATTRIB10_4_NV:
      case GL_MAP2_VERTEX_ATTRIB11_4_NV:
      case GL_MAP2_VERTEX_ATTRIB12_4_NV:
      case GL_MAP2_VERTEX_ATTRIB13_4_NV:
      case GL_MAP2_VERTEX_ATTRIB14_4_NV:
      case GL_MAP2_VERTEX_ATTRIB15_4_NV:
         CHECK_EXTENSION_B(NV_vertex_program, pname);
         {
            GLuint n = (GLuint) pname - GL_MAP2_VERTEX_ATTRIB0_4_NV;
            *params = (GLint) ctx->Eval.Map2Attrib[n];
a5348 11
#endif /* FEATURE_NV_vertex_program */

      /* GL_EXT_stencil_two_side */
      case GL_STENCIL_TEST_TWO_SIDE_EXT:
         CHECK_EXTENSION_I(EXT_stencil_two_side, pname);
         *params = (GLint) ctx->Stencil.TestTwoSide;
         break;
      case GL_ACTIVE_STENCIL_FACE_EXT:
         CHECK_EXTENSION_I(EXT_stencil_two_side, pname);
         *params = (GLint) (ctx->Stencil.ActiveFace ? GL_BACK : GL_FRONT);
         break;
d5351 1
a5351 1
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetIntegerv(pname=0x%x)", pname);
d5368 1
a5368 1
      _mesa_debug(ctx, "glGetPointerv %s\n", _mesa_lookup_enum_by_nr(pname));
d5419 2
a5420 3
   static const char *version_1_2 = "1.2 Mesa 5.0.2";
   static const char *version_1_3 = "1.3 Mesa 5.0.2";
   static const char *version_1_4 = "1.4 Mesa 5.0.2";
d5431 23
a5453 46
      switch (name) {
         case GL_VENDOR:
            return (const GLubyte *) vendor;
         case GL_RENDERER:
            return (const GLubyte *) renderer;
         case GL_VERSION:
            if (ctx->Extensions.ARB_multisample &&
                ctx->Extensions.ARB_multitexture &&
                ctx->Extensions.ARB_texture_border_clamp &&
                ctx->Extensions.ARB_texture_compression &&
                ctx->Extensions.ARB_texture_cube_map &&
                ctx->Extensions.EXT_texture_env_add &&
                ctx->Extensions.ARB_texture_env_combine &&
                ctx->Extensions.ARB_texture_env_dot3) {
               if (ctx->Extensions.ARB_depth_texture &&
                   ctx->Extensions.ARB_shadow &&
                   ctx->Extensions.ARB_texture_env_crossbar &&
                   ctx->Extensions.ARB_texture_mirrored_repeat &&
                   ctx->Extensions.ARB_window_pos &&
                   ctx->Extensions.EXT_blend_color &&
                   ctx->Extensions.EXT_blend_func_separate &&
                   ctx->Extensions.EXT_blend_logic_op &&
                   ctx->Extensions.EXT_blend_minmax &&
                   ctx->Extensions.EXT_blend_subtract &&
                   ctx->Extensions.EXT_fog_coord &&
                   ctx->Extensions.EXT_multi_draw_arrays &&
                   ctx->Extensions.EXT_point_parameters && /*aka ARB*/
                   ctx->Extensions.EXT_secondary_color &&
                   ctx->Extensions.EXT_stencil_wrap &&
                   ctx->Extensions.EXT_texture_lod_bias &&
                   ctx->Extensions.SGIS_generate_mipmap) {
                  return (const GLubyte *) version_1_4;
               }
               else {
                  return (const GLubyte *) version_1_3;
               }
            }
            else {
               return (const GLubyte *) version_1_2;
            }
         case GL_EXTENSIONS:
            return (const GLubyte *) _mesa_extensions_get_string(ctx);
         default:
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetString" );
            return (const GLubyte *) 0;
      }
d5469 1
a5469 1
      _mesa_debug(ctx, "glGetError <-- %s\n", _mesa_lookup_enum_by_nr(e));
@


