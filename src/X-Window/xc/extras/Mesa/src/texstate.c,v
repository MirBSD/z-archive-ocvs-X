head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.28.22;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.01.02;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.01.02;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.20.04;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.29.07;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.04.49;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@
/*
 * Mesa 3-D graphics library
 * Version:  3.4
 *
 * Copyright (C) 1999-2000  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */


#ifdef PC_HEADER
#include "all.h"
#else
#include "glheader.h"
#include "context.h"
#include "enums.h"
#include "extensions.h"
#include "macros.h"
#include "matrix.h"
#include "texobj.h"
#include "teximage.h"
#include "texstate.h"
#include "texture.h"
#include "types.h"
#include "xform.h"
#endif



#ifdef SPECIALCAST
/* Needed for an Amiga compiler */
#define ENUM_TO_FLOAT(X) ((GLfloat)(GLint)(X))
#define ENUM_TO_DOUBLE(X) ((GLdouble)(GLint)(X))
#else
/* all other compilers */
#define ENUM_TO_FLOAT(X) ((GLfloat)(X))
#define ENUM_TO_DOUBLE(X) ((GLdouble)(X))
#endif




/**********************************************************************/
/*                       Texture Environment                          */
/**********************************************************************/


void
_mesa_TexEnvfv( GLenum target, GLenum pname, const GLfloat *param )
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glTexEnv");

   if (target==GL_TEXTURE_ENV) {
      switch (pname) {
         case GL_TEXTURE_ENV_MODE:
            {
               GLenum mode = (GLenum) (GLint) *param;
               switch (mode) {
                  case GL_MODULATE:
                  case GL_BLEND:
                  case GL_DECAL:
                  case GL_REPLACE:
                  case GL_ADD:
                  case GL_COMBINE_EXT:
                     if (mode == GL_ADD &&
                         !ctx->Extensions.HaveTextureEnvAdd) {
                        gl_error(ctx, GL_INVALID_ENUM, "glTexEnv(param)");
                        return;
                     }
                     if (mode == GL_COMBINE_EXT &&
                         !ctx->Extensions.HaveTextureEnvCombine) {
                        gl_error(ctx, GL_INVALID_ENUM, "glTexEnv(param)");
                        return;
                     }
                     if (texUnit->EnvMode == mode)
                        return;  /* no change */
                     texUnit->EnvMode = mode;
                     ctx->NewState |= NEW_TEXTURE_ENV;
                     break;
                  default:
                     gl_error( ctx, GL_INVALID_VALUE, "glTexEnv(param)" );
                     return;
               }
            }
            break;
         case GL_TEXTURE_ENV_COLOR:
            texUnit->EnvColor[0] = CLAMP( param[0], 0.0F, 1.0F );
            texUnit->EnvColor[1] = CLAMP( param[1], 0.0F, 1.0F );
            texUnit->EnvColor[2] = CLAMP( param[2], 0.0F, 1.0F );
            texUnit->EnvColor[3] = CLAMP( param[3], 0.0F, 1.0F );
            break;
         case GL_COMBINE_RGB_EXT:
            if (ctx->Extensions.HaveTextureEnvCombine) {
               GLenum mode = (GLenum) (GLint) *param;
               switch (mode) {
                  case GL_REPLACE:
                  case GL_MODULATE:
                  case GL_ADD:
                  case GL_ADD_SIGNED_EXT:
                  case GL_INTERPOLATE_EXT:
	          case GL_DOT3_RGB_EXT:
	          case GL_DOT3_RGBA_EXT:
                     if ((mode == GL_DOT3_RGB_EXT ||
			  mode == GL_DOT3_RGBA_EXT) &&
                         !ctx->Extensions.HaveTextureEnvDot3) {
                        gl_error(ctx, GL_INVALID_ENUM, "glTexEnv(param)");
                        return;
                     }
                     if (texUnit->CombineModeRGB == mode)
                        return;  /* no change */
                     texUnit->CombineModeRGB = mode;
                     ctx->NewState |= NEW_TEXTURE_ENV;
                     break;
                  default:
                     gl_error( ctx, GL_INVALID_ENUM, "glTexEnv(param)" );
                     return;
               }
            }
            else {
               gl_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
               return;
            }
            break;
         case GL_COMBINE_ALPHA_EXT:
            if (ctx->Extensions.HaveTextureEnvCombine) {
               GLenum mode = (GLenum) (GLint) *param;
               switch (mode) {
                  case GL_REPLACE:
                  case GL_MODULATE:
                  case GL_ADD:
                  case GL_ADD_SIGNED_EXT:
                  case GL_INTERPOLATE_EXT:
                     if (texUnit->CombineModeA == mode)
                        return;  /* no change */
                     texUnit->CombineModeA = mode;
                     ctx->NewState |= NEW_TEXTURE_ENV;
                     break;
                  default:
                     gl_error( ctx, GL_INVALID_ENUM, "glTexEnv(param)" );
                     return;
               }
            }
            else {
               gl_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
               return;
            }
            break;
         case GL_SOURCE0_RGB_EXT:
         case GL_SOURCE1_RGB_EXT:
         case GL_SOURCE2_RGB_EXT:
            if (ctx->Extensions.HaveTextureEnvCombine) {
               GLenum source = (GLenum) (GLint) *param;
               GLuint s = pname - GL_SOURCE0_RGB_EXT;
               switch (source) {
                  case GL_TEXTURE:
                  case GL_CONSTANT_EXT:
                  case GL_PRIMARY_COLOR_EXT:
                  case GL_PREVIOUS_EXT:
                     if (texUnit->CombineSourceRGB[s] == source)
                        return;  /* no change */
                     texUnit->CombineSourceRGB[s] = source;
                     ctx->NewState |= NEW_TEXTURE_ENV;
                     break;
                  default:
                     gl_error( ctx, GL_INVALID_ENUM, "glTexEnv(param)" );
                     return;
               }
            }
            else {
               gl_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
               return;
            }
            break;
         case GL_SOURCE0_ALPHA_EXT:
         case GL_SOURCE1_ALPHA_EXT:
         case GL_SOURCE2_ALPHA_EXT:
            if (ctx->Extensions.HaveTextureEnvCombine) {
               GLenum source = (GLenum) (GLint) *param;
               GLuint s = pname - GL_SOURCE0_ALPHA_EXT;
               switch (source) {
                  case GL_TEXTURE:
                  case GL_CONSTANT_EXT:
                  case GL_PRIMARY_COLOR_EXT:
                  case GL_PREVIOUS_EXT:
                     if (texUnit->CombineSourceA[s] == source) return;
                     texUnit->CombineSourceA[s] = source;
                     ctx->NewState |= NEW_TEXTURE_ENV;
                     break;
                  default:
                     gl_error( ctx, GL_INVALID_ENUM, "glTexEnv(param)" );
                     return;
               }
            }
            else {
               gl_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
               return;
            }
            break;
         case GL_OPERAND0_RGB_EXT:
         case GL_OPERAND1_RGB_EXT:
            if (ctx->Extensions.HaveTextureEnvCombine) {
               GLenum operand = (GLenum) (GLint) *param;
               GLuint s = pname - GL_OPERAND0_RGB_EXT;
               switch (operand) {
                  case GL_SRC_COLOR:
                  case GL_ONE_MINUS_SRC_COLOR:
                  case GL_SRC_ALPHA:
                  case GL_ONE_MINUS_SRC_ALPHA:
                     texUnit->CombineOperandRGB[s] = operand;
                     ctx->NewState |= NEW_TEXTURE_ENV;
                     break;
                  default:
                     gl_error( ctx, GL_INVALID_ENUM, "glTexEnv(param)" );
                     return;
               }
            }
            else {
               gl_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
               return;
            }
            break;
         case GL_OPERAND0_ALPHA_EXT:
         case GL_OPERAND1_ALPHA_EXT:
            if (ctx->Extensions.HaveTextureEnvCombine) {
               GLenum operand = (GLenum) (GLint) *param;
               switch (operand) {
                  case GL_SRC_ALPHA:
                  case GL_ONE_MINUS_SRC_ALPHA:
                     texUnit->CombineOperandA[pname-GL_OPERAND0_ALPHA_EXT]
                        = operand;
                     ctx->NewState |= NEW_TEXTURE_ENV;
                     break;
                  default:
                     gl_error( ctx, GL_INVALID_ENUM, "glTexEnv(param)" );
                     return;
               }
            }
            else {
               gl_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
               return;
            }
            break;
         case GL_OPERAND2_RGB_EXT:
            if (ctx->Extensions.HaveTextureEnvCombine) {
               if ((GLenum) (GLint) *param == GL_SRC_ALPHA) {
                  texUnit->CombineOperandRGB[2] = (GLenum) (GLint) *param;
                  ctx->NewState |= NEW_TEXTURE_ENV;
               }
               else {
                  gl_error( ctx, GL_INVALID_ENUM, "glTexEnv(param)" );
                  return;
               }
            }
            else {
               gl_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
               return;
            }
            break;
         case GL_OPERAND2_ALPHA_EXT:
            if (ctx->Extensions.HaveTextureEnvCombine) {
               if ((GLenum) (GLint) *param == GL_SRC_ALPHA) {
                  texUnit->CombineOperandA[2] = (GLenum) (GLint) *param;
                  ctx->NewState |= NEW_TEXTURE_ENV;
               }
               else {
                  gl_error( ctx, GL_INVALID_ENUM, "glTexEnv(param)" );
                  return;
               }
            }
            else {
               gl_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
               return;
            }
            break;
         case GL_RGB_SCALE_EXT:
            if (ctx->Extensions.HaveTextureEnvCombine) {
               if (*param == 1.0) {
                  texUnit->CombineScaleShiftRGB = 0;
                  ctx->NewState |= NEW_TEXTURE_ENV;
               }
               else if (*param == 2.0) {
                  texUnit->CombineScaleShiftRGB = 1;
                  ctx->NewState |= NEW_TEXTURE_ENV;
               }
               else if (*param == 4.0) {
                  texUnit->CombineScaleShiftRGB = 2;
                  ctx->NewState |= NEW_TEXTURE_ENV;
               }
               else {
                  gl_error( ctx, GL_INVALID_VALUE, "glTexEnv(param)" );
                  return;
               }
            }
            else {
               gl_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
               return;
            }
            break;
         case GL_ALPHA_SCALE:
            if (ctx->Extensions.HaveTextureEnvCombine) {
               if (*param == 1.0) {
                  texUnit->CombineScaleShiftA = 0;
                  ctx->NewState |= NEW_TEXTURE_ENV;
               }
               else if (*param == 2.0) {
                  texUnit->CombineScaleShiftA = 1;
                  ctx->NewState |= NEW_TEXTURE_ENV;
               }
               else if (*param == 4.0) {
                  texUnit->CombineScaleShiftA = 2;
                  ctx->NewState |= NEW_TEXTURE_ENV;
               }
               else {
                  gl_error( ctx, GL_INVALID_VALUE, "glTexEnv(param)" );
                  return;
               }
            }
            else {
               gl_error(ctx, GL_INVALID_ENUM, "glTexEnv(pname)");
               return;
            }
            break;
         default:
            gl_error( ctx, GL_INVALID_ENUM, "glTexEnv(pname)" );
            return;
      }
   }
   else if (target==GL_TEXTURE_FILTER_CONTROL_EXT) {
      if (!ctx->Extensions.HaveTextureLodBias) {
	 gl_error( ctx, GL_INVALID_ENUM, "glTexEnv(param)" );
	 return;
      }
      if (pname == GL_TEXTURE_LOD_BIAS_EXT) {
	 texUnit->LodBias = param[0];
      }
      else {
	 gl_error( ctx, GL_INVALID_ENUM, "glTexEnv(pname)" );
	 return;
      }
   }
   else {
      gl_error( ctx, GL_INVALID_ENUM, "glTexEnv(target)" );
      return;
   }

   if (MESA_VERBOSE&(VERBOSE_API|VERBOSE_TEXTURE))
      fprintf(stderr, "glTexEnv %s %s %.1f(%s) ...\n",
	      gl_lookup_enum_by_nr(target),
	      gl_lookup_enum_by_nr(pname),
	      *param,
	      gl_lookup_enum_by_nr((GLenum) (GLint) *param));

   /* Tell device driver about the new texture environment */
   if (ctx->Driver.TexEnv) {
      (*ctx->Driver.TexEnv)( ctx, target, pname, param );
   }

}


void
_mesa_TexEnvf( GLenum target, GLenum pname, GLfloat param )
{
   _mesa_TexEnvfv( target, pname, &param );
}



void
_mesa_TexEnvi( GLenum target, GLenum pname, GLint param )
{
   GLfloat p[4];
   p[0] = (GLfloat) param;
   p[1] = p[2] = p[3] = 0.0;
   _mesa_TexEnvfv( target, pname, p );
}


void
_mesa_TexEnviv( GLenum target, GLenum pname, const GLint *param )
{
   GLfloat p[4];
   p[0] = INT_TO_FLOAT( param[0] );
   p[1] = INT_TO_FLOAT( param[1] );
   p[2] = INT_TO_FLOAT( param[2] );
   p[3] = INT_TO_FLOAT( param[3] );
   _mesa_TexEnvfv( target, pname, p );
}


void
_mesa_GetTexEnvfv( GLenum target, GLenum pname, GLfloat *params )
{
   GET_CURRENT_CONTEXT(ctx);
   const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetTexEnvfv");

   if (target!=GL_TEXTURE_ENV) {
      gl_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(target)" );
      return;
   }

   switch (pname) {
      case GL_TEXTURE_ENV_MODE:
         *params = ENUM_TO_FLOAT(texUnit->EnvMode);
	 break;
      case GL_TEXTURE_ENV_COLOR:
	 COPY_4FV( params, texUnit->EnvColor );
	 break;
      case GL_RGB_SCALE_EXT:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            if (texUnit->CombineScaleShiftRGB == 0)
               *params = 1.0;
            else if (texUnit->CombineScaleShiftRGB == 1)
               *params = 2.0;
            else
               *params = 4.0;
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            return;
         }
         break;
      case GL_ALPHA_SCALE:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            if (texUnit->CombineScaleShiftA == 0)
               *params = 1.0;
            else if (texUnit->CombineScaleShiftA == 1)
               *params = 2.0;
            else
               *params = 4.0;
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            return;
         }
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)" );
   }
}


void
_mesa_GetTexEnviv( GLenum target, GLenum pname, GLint *params )
{
   GET_CURRENT_CONTEXT(ctx);
   const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetTexEnviv");

   if (target != GL_TEXTURE_ENV) {
      gl_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(target)" );
      return;
   }

   switch (pname) {
      case GL_TEXTURE_ENV_MODE:
         *params = (GLint) texUnit->EnvMode;
	 break;
      case GL_TEXTURE_ENV_COLOR:
	 params[0] = FLOAT_TO_INT( texUnit->EnvColor[0] );
	 params[1] = FLOAT_TO_INT( texUnit->EnvColor[1] );
	 params[2] = FLOAT_TO_INT( texUnit->EnvColor[2] );
	 params[3] = FLOAT_TO_INT( texUnit->EnvColor[3] );
         break;
      case GL_COMBINE_RGB_EXT:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            *params = (GLint) texUnit->CombineModeRGB;
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
         }
         break;
      case GL_COMBINE_ALPHA_EXT:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            *params = (GLint) texUnit->CombineModeA;
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
         }
         break;
      case GL_SOURCE0_RGB_EXT:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            *params = (GLint) texUnit->CombineSourceRGB[0];
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
         }
         break;
      case GL_SOURCE1_RGB_EXT:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            *params = (GLint) texUnit->CombineSourceRGB[1];
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
         }
         break;
      case GL_SOURCE2_RGB_EXT:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            *params = (GLint) texUnit->CombineSourceRGB[2];
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
         }
         break;
      case GL_SOURCE0_ALPHA_EXT:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            *params = (GLint) texUnit->CombineSourceA[0];
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
         }
         break;
      case GL_SOURCE1_ALPHA_EXT:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            *params = (GLint) texUnit->CombineSourceA[1];
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
         }
         break;
      case GL_SOURCE2_ALPHA_EXT:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            *params = (GLint) texUnit->CombineSourceA[2];
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
         }
         break;
      case GL_OPERAND0_RGB_EXT:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            *params = (GLint) texUnit->CombineOperandRGB[0];
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
         }
         break;
      case GL_OPERAND1_RGB_EXT:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            *params = (GLint) texUnit->CombineOperandRGB[1];
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
         }
         break;
      case GL_OPERAND2_RGB_EXT:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            *params = (GLint) texUnit->CombineOperandRGB[2];
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
         }
         break;
      case GL_OPERAND0_ALPHA_EXT:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            *params = (GLint) texUnit->CombineOperandA[0];
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
         }
         break;
      case GL_OPERAND1_ALPHA_EXT:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            *params = (GLint) texUnit->CombineOperandA[1];
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
         }
         break;
      case GL_OPERAND2_ALPHA_EXT:
         if (ctx->Extensions.HaveTextureEnvCombine) {
            *params = (GLint) texUnit->CombineOperandA[2];
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
         }
	 break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)" );
   }
}




/**********************************************************************/
/*                       Texture Parameters                           */
/**********************************************************************/


void
_mesa_TexParameterf( GLenum target, GLenum pname, GLfloat param )
{
   _mesa_TexParameterfv(target, pname, &param);
}


void
_mesa_TexParameterfv( GLenum target, GLenum pname, const GLfloat *params )
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   GLenum eparam = (GLenum) (GLint) params[0];
   struct gl_texture_object *texObj;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glTexParameterfv");

   if (MESA_VERBOSE&(VERBOSE_API|VERBOSE_TEXTURE))
      fprintf(stderr, "texPARAM %s %s %d...\n",
	      gl_lookup_enum_by_nr(target),
	      gl_lookup_enum_by_nr(pname),
	      eparam);


   switch (target) {
      case GL_TEXTURE_1D:
         texObj = texUnit->CurrentD[1];
         break;
      case GL_TEXTURE_2D:
         texObj = texUnit->CurrentD[2];
         break;
      case GL_TEXTURE_3D_EXT:
         texObj = texUnit->CurrentD[3];
         break;
      case GL_TEXTURE_CUBE_MAP_ARB:
         if (ctx->Extensions.HaveTextureCubeMap) {
            texObj = texUnit->CurrentCubeMap;
            break;
         }
         /* fallthrough */
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glTexParameter(target)" );
         return;
   }

   switch (pname) {
      case GL_TEXTURE_MIN_FILTER:
         /* A small optimization */
         if (texObj->MinFilter == eparam)
            return;

         if (eparam==GL_NEAREST || eparam==GL_LINEAR
             || eparam==GL_NEAREST_MIPMAP_NEAREST
             || eparam==GL_LINEAR_MIPMAP_NEAREST
             || eparam==GL_NEAREST_MIPMAP_LINEAR
             || eparam==GL_LINEAR_MIPMAP_LINEAR) {
            texObj->MinFilter = eparam;
            ctx->NewState |= NEW_TEXTURING;
         }
         else {
            gl_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
            return;
         }
         break;
      case GL_TEXTURE_MAG_FILTER:
         /* A small optimization */
         if (texObj->MagFilter == eparam)
            return;

         if (eparam==GL_NEAREST || eparam==GL_LINEAR) {
            texObj->MagFilter = eparam;
            ctx->NewState |= NEW_TEXTURING;
         }
         else {
            gl_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
            return;
         }
         break;
      case GL_TEXTURE_WRAP_S:
         if (texObj->WrapS == eparam)
            return;

         if (eparam==GL_CLAMP || eparam==GL_REPEAT || eparam==GL_CLAMP_TO_EDGE) {
            texObj->WrapS = eparam;
            ctx->NewState |= NEW_TEXTURING;
         }
         else {
            gl_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
            return;
         }
         break;
      case GL_TEXTURE_WRAP_T:
         if (texObj->WrapT == eparam)
            return;

         if (eparam==GL_CLAMP || eparam==GL_REPEAT || eparam==GL_CLAMP_TO_EDGE) {
            texObj->WrapT = eparam;
            ctx->NewState |= NEW_TEXTURING;
         }
         else {
            gl_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
            return;
         }
         break;
      case GL_TEXTURE_WRAP_R_EXT:
         if (texObj->WrapR == eparam)
            return;

         if (eparam==GL_CLAMP || eparam==GL_REPEAT || eparam==GL_CLAMP_TO_EDGE) {
            texObj->WrapR = eparam;
            ctx->NewState |= NEW_TEXTURING;
         }
         else {
            gl_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
         }
         break;
      case GL_TEXTURE_BORDER_COLOR:
         texObj->BorderColor[0] = (GLubyte) CLAMP((GLint)(params[0]*255.0), 0, 255);
         texObj->BorderColor[1] = (GLubyte) CLAMP((GLint)(params[1]*255.0), 0, 255);
         texObj->BorderColor[2] = (GLubyte) CLAMP((GLint)(params[2]*255.0), 0, 255);
         texObj->BorderColor[3] = (GLubyte) CLAMP((GLint)(params[3]*255.0), 0, 255);
         break;
      case GL_TEXTURE_MIN_LOD:
         texObj->MinLod = params[0];
         ctx->NewState |= NEW_TEXTURING;
         break;
      case GL_TEXTURE_MAX_LOD:
         texObj->MaxLod = params[0];
         ctx->NewState |= NEW_TEXTURING;
         break;
      case GL_TEXTURE_BASE_LEVEL:
         if (params[0] < 0.0) {
            gl_error(ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
            return;
         }
         texObj->BaseLevel = (GLint) params[0];
         ctx->NewState |= NEW_TEXTURING;
         break;
      case GL_TEXTURE_MAX_LEVEL:
         if (params[0] < 0.0) {
            gl_error(ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
            return;
         }
         texObj->MaxLevel = (GLint) params[0];
         ctx->NewState |= NEW_TEXTURING;
         break;
      case GL_TEXTURE_PRIORITY:
         /* (keithh@@netcomuk.co.uk) */
         texObj->Priority = CLAMP( params[0], 0.0F, 1.0F );
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glTexParameter(pname)" );
         return;
   }

   gl_put_texobj_on_dirty_list( ctx, texObj );

   if (ctx->Driver.TexParameter) {
      (*ctx->Driver.TexParameter)( ctx, target, texObj, pname, params );
   }
}


void
_mesa_TexParameteri( GLenum target, GLenum pname, GLint param )
{
   GLfloat fparam[4];
   fparam[0] = (GLfloat) param;
   fparam[1] = fparam[2] = fparam[3] = 0.0;
   _mesa_TexParameterfv(target, pname, fparam);
}

void
_mesa_TexParameteriv( GLenum target, GLenum pname, const GLint *params )
{
   GLfloat fparam[4];
   fparam[0] = (GLfloat) params[0];
   fparam[1] = fparam[2] = fparam[3] = 0.0;
   _mesa_TexParameterfv(target, pname, fparam);
}


void
_mesa_GetTexLevelParameterfv( GLenum target, GLint level,
                              GLenum pname, GLfloat *params )
{
   GLint iparam;
   _mesa_GetTexLevelParameteriv( target, level, pname, &iparam );
   *params = (GLfloat) iparam;
}


static GLuint
tex_image_dimensions(GLcontext *ctx, GLenum target)
{
   switch (target) {
      case GL_TEXTURE_1D:
      case GL_PROXY_TEXTURE_1D:
         return 1;
      case GL_TEXTURE_2D:
      case GL_PROXY_TEXTURE_2D:
         return 2;
      case GL_TEXTURE_3D:
      case GL_PROXY_TEXTURE_3D:
         return 3;
      case GL_TEXTURE_CUBE_MAP_ARB:
      case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
         return ctx->Extensions.HaveTextureCubeMap ? 2 : 0;
      default:
         gl_problem(ctx, "bad target in _mesa_tex_target_dimensions()");
         return 0;
   }
}


void
_mesa_GetTexLevelParameteriv( GLenum target, GLint level,
                              GLenum pname, GLint *params )
{
   GET_CURRENT_CONTEXT(ctx);
   const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   const struct gl_texture_image *img = NULL;
   GLuint dimensions;
   GLboolean isProxy;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetTexLevelParameter");

   if (level < 0 || level >= ctx->Const.MaxTextureLevels) {
      gl_error( ctx, GL_INVALID_VALUE, "glGetTexLevelParameter[if]v" );
      return;
   }

   dimensions = tex_image_dimensions(ctx, target);  /* 1, 2 or 3 */
   if (dimensions == 0) {
      gl_error(ctx, GL_INVALID_ENUM, "glGetTexLevelParameter[if]v(target)");
      return;
   }

   img = _mesa_select_tex_image(ctx, texUnit, target, level);
   if (!img) {
      if (pname == GL_TEXTURE_COMPONENTS)
         *params = 1;
      else
         *params = 0;
      return;
   }

   isProxy = (target == GL_PROXY_TEXTURE_1D) ||
             (target == GL_PROXY_TEXTURE_2D) ||
             (target == GL_PROXY_TEXTURE_3D) ||
             (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB);

   switch (pname) {
      case GL_TEXTURE_WIDTH:
         *params = img->Width;
         return;
      case GL_TEXTURE_HEIGHT:
         if (dimensions > 1) {
            *params = img->Height;
         }
         else {
            gl_error( ctx, GL_INVALID_ENUM,
                      "glGetTexLevelParameter[if]v(pname=GL_TEXTURE_HEIGHT)" );
         }
         return;
      case GL_TEXTURE_DEPTH:
         if (dimensions > 2) {
            *params = img->Depth;
         }
         else {
            gl_error( ctx, GL_INVALID_ENUM,
                      "glGetTexLevelParameter[if]v(pname=GL_TEXTURE_DEPTH)" );
         }
         return;
      case GL_TEXTURE_COMPONENTS:
         *params = img->IntFormat;
         return;
      case GL_TEXTURE_BORDER:
         *params = img->Border;
         return;
      case GL_TEXTURE_RED_SIZE:
         if (img->Format == GL_RGB || img->Format == GL_RGBA)
            *params = img->TexFormat->RedBits;
         else
            *params = 0;
         return;
      case GL_TEXTURE_GREEN_SIZE:
         if (img->Format == GL_RGB || img->Format == GL_RGBA)
            *params = img->TexFormat->GreenBits;
         else
            *params = 0;
         return;
      case GL_TEXTURE_BLUE_SIZE:
         if (img->Format == GL_RGB || img->Format == GL_RGBA)
            *params = img->TexFormat->BlueBits;
         else
            *params = 0;
         return;
      case GL_TEXTURE_ALPHA_SIZE:
         if (img->Format == GL_ALPHA || img->Format == GL_LUMINANCE_ALPHA ||
             img->Format == GL_RGBA)
            *params = img->TexFormat->AlphaBits;
         else
            *params = 0;
         return;
      case GL_TEXTURE_INTENSITY_SIZE:
         if (img->Format != GL_INTENSITY)
            *params = 0;
         else if (img->TexFormat->IntensityBits > 0)
            *params = img->TexFormat->IntensityBits;
         else /* intensity probably stored as rgb texture */
            *params = MIN2(img->TexFormat->RedBits, img->TexFormat->GreenBits);
         return;
      case GL_TEXTURE_LUMINANCE_SIZE:
         if (img->Format != GL_LUMINANCE &&
             img->Format != GL_LUMINANCE_ALPHA)
            *params = 0;
         else if (img->TexFormat->LuminanceBits)
            *params = img->TexFormat->LuminanceBits;
         else /* luminance probably stored as rgb texture */
            *params = img->TexFormat->RedBits;
         return;
      case GL_TEXTURE_INDEX_SIZE_EXT:
         *params = img->TexFormat->IndexBits;
         return;

      /* GL_ARB_texture_compression */
      case GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB:
         if (ctx->Extensions.HaveTextureCompression) {
            if (img->IsCompressed && !isProxy)
               *params = img->CompressedSize;
            else
               gl_error(ctx, GL_INVALID_OPERATION,
                        "glGetTexLevelParameter[if]v(pname)");
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexLevelParameter[if]v(pname)");
         }
         return;
      case GL_TEXTURE_COMPRESSED_ARB:
         if (ctx->Extensions.HaveTextureCompression) {
            *params = (GLint) img->IsCompressed;
         }
         else {
            gl_error(ctx, GL_INVALID_ENUM, "glGetTexLevelParameter[if]v(pname)");
         }
         return;

      default:
         gl_error(ctx, GL_INVALID_ENUM, "glGetTexLevelParameter[if]v(pname)");
   }
}



void
_mesa_GetTexParameterfv( GLenum target, GLenum pname, GLfloat *params )
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   struct gl_texture_object *obj;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetTexParameterfv");

   obj = _mesa_select_tex_object(ctx, texUnit, target);
   if (!obj) {
      gl_error(ctx, GL_INVALID_ENUM, "glGetTexParameterfv(target)");
      return;
   }

   switch (pname) {
      case GL_TEXTURE_MAG_FILTER:
	 *params = ENUM_TO_FLOAT(obj->MagFilter);
	 break;
      case GL_TEXTURE_MIN_FILTER:
         *params = ENUM_TO_FLOAT(obj->MinFilter);
         break;
      case GL_TEXTURE_WRAP_S:
         *params = ENUM_TO_FLOAT(obj->WrapS);
         break;
      case GL_TEXTURE_WRAP_T:
         *params = ENUM_TO_FLOAT(obj->WrapT);
         break;
      case GL_TEXTURE_WRAP_R_EXT:
         *params = ENUM_TO_FLOAT(obj->WrapR);
         break;
      case GL_TEXTURE_BORDER_COLOR:
         params[0] = obj->BorderColor[0] / 255.0F;
         params[1] = obj->BorderColor[1] / 255.0F;
         params[2] = obj->BorderColor[2] / 255.0F;
         params[3] = obj->BorderColor[3] / 255.0F;
         break;
      case GL_TEXTURE_RESIDENT:
         {
            GLboolean resident;
            if (ctx->Driver.IsTextureResident)
               resident = ctx->Driver.IsTextureResident(ctx, obj);
            else
               resident = GL_TRUE;
            *params = ENUM_TO_FLOAT(resident);
         }
         break;
      case GL_TEXTURE_PRIORITY:
         *params = obj->Priority;
         break;
      case GL_TEXTURE_MIN_LOD:
         *params = obj->MinLod;
         break;
      case GL_TEXTURE_MAX_LOD:
         *params = obj->MaxLod;
         break;
      case GL_TEXTURE_BASE_LEVEL:
         *params = (GLfloat) obj->BaseLevel;
         break;
      case GL_TEXTURE_MAX_LEVEL:
         *params = (GLfloat) obj->MaxLevel;
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetTexParameterfv(pname)" );
   }
}


void
_mesa_GetTexParameteriv( GLenum target, GLenum pname, GLint *params )
{
   GET_CURRENT_CONTEXT(ctx);
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   struct gl_texture_object *obj;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetTexParameteriv");

   obj = _mesa_select_tex_object(ctx, texUnit, target);
   if (!obj) {
      gl_error(ctx, GL_INVALID_ENUM, "glGetTexParameteriv(target)");
      return;
   }

   switch (pname) {
      case GL_TEXTURE_MAG_FILTER:
         *params = (GLint) obj->MagFilter;
         break;
      case GL_TEXTURE_MIN_FILTER:
         *params = (GLint) obj->MinFilter;
         break;
      case GL_TEXTURE_WRAP_S:
         *params = (GLint) obj->WrapS;
         break;
      case GL_TEXTURE_WRAP_T:
         *params = (GLint) obj->WrapT;
         break;
      case GL_TEXTURE_WRAP_R_EXT:
         *params = (GLint) obj->WrapR;
         break;
      case GL_TEXTURE_BORDER_COLOR:
         {
            GLfloat color[4];
            color[0] = obj->BorderColor[0] / 255.0F;
            color[1] = obj->BorderColor[1] / 255.0F;
            color[2] = obj->BorderColor[2] / 255.0F;
            color[3] = obj->BorderColor[3] / 255.0F;
            params[0] = FLOAT_TO_INT( color[0] );
            params[1] = FLOAT_TO_INT( color[1] );
            params[2] = FLOAT_TO_INT( color[2] );
            params[3] = FLOAT_TO_INT( color[3] );
         }
         break;
      case GL_TEXTURE_RESIDENT:
         {
            GLboolean resident;
            if (ctx->Driver.IsTextureResident)
               resident = ctx->Driver.IsTextureResident(ctx, obj);
            else
               resident = GL_TRUE;
            *params = (GLint) resident;
         }
         break;
      case GL_TEXTURE_PRIORITY:
         *params = (GLint) obj->Priority;
         break;
      case GL_TEXTURE_MIN_LOD:
         *params = (GLint) obj->MinLod;
         break;
      case GL_TEXTURE_MAX_LOD:
         *params = (GLint) obj->MaxLod;
         break;
      case GL_TEXTURE_BASE_LEVEL:
         *params = obj->BaseLevel;
         break;
      case GL_TEXTURE_MAX_LEVEL:
         *params = obj->MaxLevel;
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetTexParameteriv(pname)" );
   }
}




/**********************************************************************/
/*                    Texture Coord Generation                        */
/**********************************************************************/


void
_mesa_TexGenfv( GLenum coord, GLenum pname, const GLfloat *params )
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint tUnit = ctx->Texture.CurrentTransformUnit;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[tUnit];
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glTexGenfv");

   if (MESA_VERBOSE&(VERBOSE_API|VERBOSE_TEXTURE))
      fprintf(stderr, "texGEN %s %s %x...\n",
	      gl_lookup_enum_by_nr(coord),
	      gl_lookup_enum_by_nr(pname),
	      *(int *)params);

   switch (coord) {
      case GL_S:
         if (pname==GL_TEXTURE_GEN_MODE) {
	    GLenum mode = (GLenum) (GLint) *params;
	    switch (mode) {
	    case GL_OBJECT_LINEAR:
	       texUnit->GenModeS = mode;
	       texUnit->GenBitS = TEXGEN_OBJ_LINEAR;
	       break;
	    case GL_EYE_LINEAR:
	       texUnit->GenModeS = mode;
	       texUnit->GenBitS = TEXGEN_EYE_LINEAR;
	       break;
	    case GL_REFLECTION_MAP_NV:
	       texUnit->GenModeS = mode;
	       texUnit->GenBitS = TEXGEN_REFLECTION_MAP_NV;
	       break;
	    case GL_NORMAL_MAP_NV:
	       texUnit->GenModeS = mode;
	       texUnit->GenBitS = TEXGEN_NORMAL_MAP_NV;
	       break;
	    case GL_SPHERE_MAP:
	       texUnit->GenModeS = mode;
	       texUnit->GenBitS = TEXGEN_SPHERE_MAP;
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
	       return;
	    }
	 }
	 else if (pname==GL_OBJECT_PLANE) {
	    texUnit->ObjectPlaneS[0] = params[0];
	    texUnit->ObjectPlaneS[1] = params[1];
	    texUnit->ObjectPlaneS[2] = params[2];
	    texUnit->ObjectPlaneS[3] = params[3];
	 }
	 else if (pname==GL_EYE_PLANE) {
            /* Transform plane equation by the inverse modelview matrix */
            if (ctx->ModelView.flags & MAT_DIRTY_INVERSE) {
               gl_matrix_analyze( &ctx->ModelView );
            }
            gl_transform_vector( texUnit->EyePlaneS, params,
                                 ctx->ModelView.inv );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
	    return;
	 }
	 break;
      case GL_T:
         if (pname==GL_TEXTURE_GEN_MODE) {
	    GLenum mode = (GLenum) (GLint) *params;
	    switch (mode) {
               case GL_OBJECT_LINEAR:
                  texUnit->GenModeT = GL_OBJECT_LINEAR;
                  texUnit->GenBitT = TEXGEN_OBJ_LINEAR;
                  break;
               case GL_EYE_LINEAR:
                  texUnit->GenModeT = GL_EYE_LINEAR;
                  texUnit->GenBitT = TEXGEN_EYE_LINEAR;
                  break;
               case GL_REFLECTION_MAP_NV:
                  texUnit->GenModeT = GL_REFLECTION_MAP_NV;
                  texUnit->GenBitT = TEXGEN_REFLECTION_MAP_NV;
                  break;
               case GL_NORMAL_MAP_NV:
                  texUnit->GenModeT = GL_NORMAL_MAP_NV;
                  texUnit->GenBitT = TEXGEN_NORMAL_MAP_NV;
                  break;
               case GL_SPHERE_MAP:
                  texUnit->GenModeT = GL_SPHERE_MAP;
                  texUnit->GenBitT = TEXGEN_SPHERE_MAP;
                  break;
               default:
                  gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
                  return;
	    }
	 }
	 else if (pname==GL_OBJECT_PLANE) {
	    texUnit->ObjectPlaneT[0] = params[0];
	    texUnit->ObjectPlaneT[1] = params[1];
	    texUnit->ObjectPlaneT[2] = params[2];
	    texUnit->ObjectPlaneT[3] = params[3];
	 }
	 else if (pname==GL_EYE_PLANE) {
            /* Transform plane equation by the inverse modelview matrix */
            if (ctx->ModelView.flags & MAT_DIRTY_INVERSE) {
               gl_matrix_analyze( &ctx->ModelView );
            }
            gl_transform_vector( texUnit->EyePlaneT, params,
                                 ctx->ModelView.inv );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
	    return;
	 }
	 break;
      case GL_R:
         if (pname==GL_TEXTURE_GEN_MODE) {
	    GLenum mode = (GLenum) (GLint) *params;
	    switch (mode) {
	    case GL_OBJECT_LINEAR:
	       texUnit->GenModeR = GL_OBJECT_LINEAR;
	       texUnit->GenBitR = TEXGEN_OBJ_LINEAR;
	       break;
	    case GL_REFLECTION_MAP_NV:
	       texUnit->GenModeR = GL_REFLECTION_MAP_NV;
	       texUnit->GenBitR = TEXGEN_REFLECTION_MAP_NV;
	       break;
	    case GL_NORMAL_MAP_NV:
	       texUnit->GenModeR = GL_NORMAL_MAP_NV;
	       texUnit->GenBitR = TEXGEN_NORMAL_MAP_NV;
	       break;
	    case GL_EYE_LINEAR:
	       texUnit->GenModeR = GL_EYE_LINEAR;
	       texUnit->GenBitR = TEXGEN_EYE_LINEAR;
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
	       return;
	    }
	 }
	 else if (pname==GL_OBJECT_PLANE) {
	    texUnit->ObjectPlaneR[0] = params[0];
	    texUnit->ObjectPlaneR[1] = params[1];
	    texUnit->ObjectPlaneR[2] = params[2];
	    texUnit->ObjectPlaneR[3] = params[3];
	 }
	 else if (pname==GL_EYE_PLANE) {
            /* Transform plane equation by the inverse modelview matrix */
            if (ctx->ModelView.flags & MAT_DIRTY_INVERSE) {
               gl_matrix_analyze( &ctx->ModelView );
            }
            gl_transform_vector( texUnit->EyePlaneR, params,
                                 ctx->ModelView.inv );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
	    return;
	 }
	 break;
      case GL_Q:
         if (pname==GL_TEXTURE_GEN_MODE) {
	    GLenum mode = (GLenum) (GLint) *params;
	    switch (mode) {
	    case GL_OBJECT_LINEAR:
	       texUnit->GenModeQ = GL_OBJECT_LINEAR;
	       texUnit->GenBitQ = TEXGEN_OBJ_LINEAR;
	       break;
	    case GL_EYE_LINEAR:
	       texUnit->GenModeQ = GL_EYE_LINEAR;
	       texUnit->GenBitQ = TEXGEN_EYE_LINEAR;
	       break;
	    default:
	       gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
	       return;
	    }
	 }
	 else if (pname==GL_OBJECT_PLANE) {
	    texUnit->ObjectPlaneQ[0] = params[0];
	    texUnit->ObjectPlaneQ[1] = params[1];
	    texUnit->ObjectPlaneQ[2] = params[2];
	    texUnit->ObjectPlaneQ[3] = params[3];
	 }
	 else if (pname==GL_EYE_PLANE) {
            /* Transform plane equation by the inverse modelview matrix */
            if (ctx->ModelView.flags & MAT_DIRTY_INVERSE) {
               gl_matrix_analyze( &ctx->ModelView );
            }
            gl_transform_vector( texUnit->EyePlaneQ, params,
                                 ctx->ModelView.inv );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
	    return;
	 }
	 break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glTexGenfv(coord)" );
	 return;
   }

   ctx->NewState |= NEW_TEXTURING;
}


void
_mesa_TexGeniv(GLenum coord, GLenum pname, const GLint *params )
{
   GLfloat p[4];
   p[0] = params[0];
   p[1] = params[1];
   p[2] = params[2];
   p[3] = params[3];
   _mesa_TexGenfv(coord, pname, p);
}


void
_mesa_TexGend(GLenum coord, GLenum pname, GLdouble param )
{
   GLfloat p = (GLfloat) param;
   _mesa_TexGenfv( coord, pname, &p );
}


void
_mesa_TexGendv(GLenum coord, GLenum pname, const GLdouble *params )
{
   GLfloat p[4];
   p[0] = params[0];
   p[1] = params[1];
   p[2] = params[2];
   p[3] = params[3];
   _mesa_TexGenfv( coord, pname, p );
}


void
_mesa_TexGenf( GLenum coord, GLenum pname, GLfloat param )
{
   _mesa_TexGenfv(coord, pname, &param);
}


void
_mesa_TexGeni( GLenum coord, GLenum pname, GLint param )
{
   _mesa_TexGeniv( coord, pname, &param );
}



void
_mesa_GetTexGendv( GLenum coord, GLenum pname, GLdouble *params )
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint tUnit = ctx->Texture.CurrentTransformUnit;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[tUnit];

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetTexGendv");

   switch (coord) {
      case GL_S:
         if (pname==GL_TEXTURE_GEN_MODE) {
            params[0] = ENUM_TO_DOUBLE(texUnit->GenModeS);
	 }
	 else if (pname==GL_OBJECT_PLANE) {
            COPY_4V( params, texUnit->ObjectPlaneS );
	 }
	 else if (pname==GL_EYE_PLANE) {
            COPY_4V( params, texUnit->EyePlaneS );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
	    return;
	 }
	 break;
      case GL_T:
         if (pname==GL_TEXTURE_GEN_MODE) {
            params[0] = ENUM_TO_DOUBLE(texUnit->GenModeT);
	 }
	 else if (pname==GL_OBJECT_PLANE) {
            COPY_4V( params, texUnit->ObjectPlaneT );
	 }
	 else if (pname==GL_EYE_PLANE) {
            COPY_4V( params, texUnit->EyePlaneT );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
	    return;
	 }
	 break;
      case GL_R:
         if (pname==GL_TEXTURE_GEN_MODE) {
            params[0] = ENUM_TO_DOUBLE(texUnit->GenModeR);
	 }
	 else if (pname==GL_OBJECT_PLANE) {
            COPY_4V( params, texUnit->ObjectPlaneR );
	 }
	 else if (pname==GL_EYE_PLANE) {
            COPY_4V( params, texUnit->EyePlaneR );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
	    return;
	 }
	 break;
      case GL_Q:
         if (pname==GL_TEXTURE_GEN_MODE) {
            params[0] = ENUM_TO_DOUBLE(texUnit->GenModeQ);
	 }
	 else if (pname==GL_OBJECT_PLANE) {
            COPY_4V( params, texUnit->ObjectPlaneQ );
	 }
	 else if (pname==GL_EYE_PLANE) {
            COPY_4V( params, texUnit->EyePlaneQ );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
	    return;
	 }
	 break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(coord)" );
	 return;
   }
}



void
_mesa_GetTexGenfv( GLenum coord, GLenum pname, GLfloat *params )
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint tUnit = ctx->Texture.CurrentTransformUnit;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[tUnit];

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetTexGenfv");

   switch (coord) {
      case GL_S:
         if (pname==GL_TEXTURE_GEN_MODE) {
            params[0] = ENUM_TO_FLOAT(texUnit->GenModeS);
	 }
	 else if (pname==GL_OBJECT_PLANE) {
            COPY_4V( params, texUnit->ObjectPlaneS );
	 }
	 else if (pname==GL_EYE_PLANE) {
            COPY_4V( params, texUnit->EyePlaneS );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
	    return;
	 }
	 break;
      case GL_T:
         if (pname==GL_TEXTURE_GEN_MODE) {
            params[0] = ENUM_TO_FLOAT(texUnit->GenModeT);
	 }
	 else if (pname==GL_OBJECT_PLANE) {
            COPY_4V( params, texUnit->ObjectPlaneT );
	 }
	 else if (pname==GL_EYE_PLANE) {
            COPY_4V( params, texUnit->EyePlaneT );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
	    return;
	 }
	 break;
      case GL_R:
         if (pname==GL_TEXTURE_GEN_MODE) {
            params[0] = ENUM_TO_FLOAT(texUnit->GenModeR);
	 }
	 else if (pname==GL_OBJECT_PLANE) {
            COPY_4V( params, texUnit->ObjectPlaneR );
	 }
	 else if (pname==GL_EYE_PLANE) {
            COPY_4V( params, texUnit->EyePlaneR );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
	    return;
	 }
	 break;
      case GL_Q:
         if (pname==GL_TEXTURE_GEN_MODE) {
            params[0] = ENUM_TO_FLOAT(texUnit->GenModeQ);
	 }
	 else if (pname==GL_OBJECT_PLANE) {
            COPY_4V( params, texUnit->ObjectPlaneQ );
	 }
	 else if (pname==GL_EYE_PLANE) {
            COPY_4V( params, texUnit->EyePlaneQ );
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
	    return;
	 }
	 break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(coord)" );
	 return;
   }
}



void
_mesa_GetTexGeniv( GLenum coord, GLenum pname, GLint *params )
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint tUnit = ctx->Texture.CurrentTransformUnit;
   struct gl_texture_unit *texUnit = &ctx->Texture.Unit[tUnit];

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetTexGeniv");

   switch (coord) {
      case GL_S:
         if (pname==GL_TEXTURE_GEN_MODE) {
            params[0] = texUnit->GenModeS;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
            params[0] = (GLint) texUnit->ObjectPlaneS[0];
            params[1] = (GLint) texUnit->ObjectPlaneS[1];
            params[2] = (GLint) texUnit->ObjectPlaneS[2];
            params[3] = (GLint) texUnit->ObjectPlaneS[3];
	 }
	 else if (pname==GL_EYE_PLANE) {
            params[0] = (GLint) texUnit->EyePlaneS[0];
            params[1] = (GLint) texUnit->EyePlaneS[1];
            params[2] = (GLint) texUnit->EyePlaneS[2];
            params[3] = (GLint) texUnit->EyePlaneS[3];
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
	    return;
	 }
	 break;
      case GL_T:
         if (pname==GL_TEXTURE_GEN_MODE) {
            params[0] = texUnit->GenModeT;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
            params[0] = (GLint) texUnit->ObjectPlaneT[0];
            params[1] = (GLint) texUnit->ObjectPlaneT[1];
            params[2] = (GLint) texUnit->ObjectPlaneT[2];
            params[3] = (GLint) texUnit->ObjectPlaneT[3];
	 }
	 else if (pname==GL_EYE_PLANE) {
            params[0] = (GLint) texUnit->EyePlaneT[0];
            params[1] = (GLint) texUnit->EyePlaneT[1];
            params[2] = (GLint) texUnit->EyePlaneT[2];
            params[3] = (GLint) texUnit->EyePlaneT[3];
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
	    return;
	 }
	 break;
      case GL_R:
         if (pname==GL_TEXTURE_GEN_MODE) {
            params[0] = texUnit->GenModeR;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
            params[0] = (GLint) texUnit->ObjectPlaneR[0];
            params[1] = (GLint) texUnit->ObjectPlaneR[1];
            params[2] = (GLint) texUnit->ObjectPlaneR[2];
            params[3] = (GLint) texUnit->ObjectPlaneR[3];
	 }
	 else if (pname==GL_EYE_PLANE) {
            params[0] = (GLint) texUnit->EyePlaneR[0];
            params[1] = (GLint) texUnit->EyePlaneR[1];
            params[2] = (GLint) texUnit->EyePlaneR[2];
            params[3] = (GLint) texUnit->EyePlaneR[3];
	 }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
	    return;
	 }
	 break;
      case GL_Q:
         if (pname==GL_TEXTURE_GEN_MODE) {
            params[0] = texUnit->GenModeQ;
	 }
	 else if (pname==GL_OBJECT_PLANE) {
            params[0] = (GLint) texUnit->ObjectPlaneQ[0];
            params[1] = (GLint) texUnit->ObjectPlaneQ[1];
            params[2] = (GLint) texUnit->ObjectPlaneQ[2];
            params[3] = (GLint) texUnit->ObjectPlaneQ[3];
	 }
	 else if (pname==GL_EYE_PLANE) {
            params[0] = (GLint) texUnit->EyePlaneQ[0];
            params[1] = (GLint) texUnit->EyePlaneQ[1];
            params[2] = (GLint) texUnit->EyePlaneQ[2];
            params[3] = (GLint) texUnit->EyePlaneQ[3];
         }
	 else {
	    gl_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
	    return;
	 }
	 break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(coord)" );
	 return;
   }
}


/* GL_ARB_multitexture */
void
_mesa_ActiveTextureARB( GLenum target )
{
   GET_CURRENT_CONTEXT(ctx);
   const GLuint maxUnits = ctx->Const.MaxTextureUnits;

   ASSERT_OUTSIDE_BEGIN_END( ctx, "glActiveTextureARB" );

   if (MESA_VERBOSE & (VERBOSE_API|VERBOSE_TEXTURE))
      fprintf(stderr, "glActiveTexture %s\n",
	      gl_lookup_enum_by_nr(target));

   if (target >= GL_TEXTURE0_ARB && target < GL_TEXTURE0_ARB + maxUnits) {
      GLint texUnit = target - GL_TEXTURE0_ARB;
      ctx->Texture.CurrentUnit = texUnit;
      ctx->Texture.CurrentTransformUnit = texUnit;
      if (ctx->Driver.ActiveTexture) {
         (*ctx->Driver.ActiveTexture)( ctx, (GLuint) texUnit );
      }
   }
   else {
      gl_error(ctx, GL_INVALID_ENUM, "glActiveTextureARB(target)");
   }
}


/* GL_ARB_multitexture */
void
_mesa_ClientActiveTextureARB( GLenum target )
{
   GET_CURRENT_CONTEXT(ctx);
   const GLuint maxUnits = ctx->Const.MaxTextureUnits;

   ASSERT_OUTSIDE_BEGIN_END( ctx, "glClientActiveTextureARB" );

   if (target >= GL_TEXTURE0_ARB && target < GL_TEXTURE0_ARB + maxUnits) {
      GLint texUnit = target - GL_TEXTURE0_ARB;
      ctx->Array.ActiveTexture = texUnit;
   }
   else {
      gl_error(ctx, GL_INVALID_ENUM, "glClientActiveTextureARB(target)");
   }
}



/*
 * Put the given texture object into the list of dirty texture objects.
 * When a texture object is dirty we have to reexamine it for completeness
 * and perhaps choose a different texture sampling function.
 */
void gl_put_texobj_on_dirty_list( GLcontext *ctx, struct gl_texture_object *t )
{
   ASSERT(ctx);
   ASSERT(t);
   /* Only insert if not already in the dirty list.
    * The Dirty flag is only set iff the texture object is in the dirty list.
    */
   if (!t->Dirty) {
      ASSERT(t->NextDirty == NULL);
      t->Dirty = GL_TRUE;
      t->NextDirty = ctx->Shared->DirtyTexObjList;
      ctx->Shared->DirtyTexObjList = t;
   }
#ifdef DEBUG
   else {
      /* make sure t is in the list */
      struct gl_texture_object *obj = ctx->Shared->DirtyTexObjList;
      while (obj) {
         if (obj == t) {
            return;
         }
         obj = obj->NextDirty;
      }
      gl_problem(ctx, "Error in gl_put_texobj_on_dirty_list");
   }
#endif
}


/*
 * Remove a texture object from the dirty texture list.
 */
void gl_remove_texobj_from_dirty_list( struct gl_shared_state *shared,
                                       struct gl_texture_object *tObj )
{
   struct gl_texture_object *t, *prev = NULL;
   ASSERT(shared);
   ASSERT(tObj);
   for (t = shared->DirtyTexObjList; t; t = t->NextDirty) {
      if (t == tObj) {
         if (prev) {
            prev->NextDirty = t->NextDirty;
         }
         else {
            shared->DirtyTexObjList = t->NextDirty;
         }
         return;
      }
      prev = t;
   }
}


/*
 * This is called by gl_update_state() if the NEW_TEXTURING bit in
 * ctx->NewState is set.
 */
void gl_update_dirty_texobjs( GLcontext *ctx )
{
   struct gl_texture_object *t, *next;
   for (t = ctx->Shared->DirtyTexObjList; t; t = next) {
      next = t->NextDirty;
      _mesa_test_texobj_completeness(ctx, t);
      _mesa_set_texture_sampler(t);
      t->NextDirty = NULL;
      t->Dirty = GL_FALSE;
   }
   ctx->Shared->DirtyTexObjList = NULL;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d1 1
d4 1
a4 1
 * Version:  5.0.2
d6 1
a6 1
 * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
d27 3
a30 1
#include "colormac.h"
d35 1
d39 4
a42 3
#include "mtypes.h"
#include "math/m_xform.h"
#include "math/m_matrix.h"
a57 93
void
_mesa_copy_texture_state( const GLcontext *src, GLcontext *dst )
{
   GLuint i;

   ASSERT(src);
   ASSERT(dst);

   dst->Texture.CurrentUnit = src->Texture.CurrentUnit;
   dst->Texture._GenFlags = src->Texture._GenFlags;
   dst->Texture._TexGenEnabled = src->Texture._TexGenEnabled;
   dst->Texture._TexMatEnabled = src->Texture._TexMatEnabled;
   dst->Texture.SharedPalette = src->Texture.SharedPalette;

   /* per-unit state */
   for (i = 0; i < src->Const.MaxTextureUnits; i++) {
      dst->Texture.Unit[i].Enabled = src->Texture.Unit[i].Enabled;
      dst->Texture.Unit[i].EnvMode = src->Texture.Unit[i].EnvMode;
      COPY_4V(dst->Texture.Unit[i].EnvColor, src->Texture.Unit[i].EnvColor);
      dst->Texture.Unit[i].TexGenEnabled = src->Texture.Unit[i].TexGenEnabled;
      dst->Texture.Unit[i].GenModeS = src->Texture.Unit[i].GenModeS;
      dst->Texture.Unit[i].GenModeT = src->Texture.Unit[i].GenModeT;
      dst->Texture.Unit[i].GenModeR = src->Texture.Unit[i].GenModeR;
      dst->Texture.Unit[i].GenModeQ = src->Texture.Unit[i].GenModeQ;
      dst->Texture.Unit[i]._GenBitS = src->Texture.Unit[i]._GenBitS;
      dst->Texture.Unit[i]._GenBitT = src->Texture.Unit[i]._GenBitT;
      dst->Texture.Unit[i]._GenBitR = src->Texture.Unit[i]._GenBitR;
      dst->Texture.Unit[i]._GenBitQ = src->Texture.Unit[i]._GenBitQ;
      dst->Texture.Unit[i]._GenFlags = src->Texture.Unit[i]._GenFlags;
      COPY_4V(dst->Texture.Unit[i].ObjectPlaneS, src->Texture.Unit[i].ObjectPlaneS);
      COPY_4V(dst->Texture.Unit[i].ObjectPlaneT, src->Texture.Unit[i].ObjectPlaneT);
      COPY_4V(dst->Texture.Unit[i].ObjectPlaneR, src->Texture.Unit[i].ObjectPlaneR);
      COPY_4V(dst->Texture.Unit[i].ObjectPlaneQ, src->Texture.Unit[i].ObjectPlaneQ);
      COPY_4V(dst->Texture.Unit[i].EyePlaneS, src->Texture.Unit[i].EyePlaneS);
      COPY_4V(dst->Texture.Unit[i].EyePlaneT, src->Texture.Unit[i].EyePlaneT);
      COPY_4V(dst->Texture.Unit[i].EyePlaneR, src->Texture.Unit[i].EyePlaneR);
      COPY_4V(dst->Texture.Unit[i].EyePlaneQ, src->Texture.Unit[i].EyePlaneQ);
      dst->Texture.Unit[i].LodBias = src->Texture.Unit[i].LodBias;

      /* GL_EXT_texture_env_combine */
      dst->Texture.Unit[i].CombineModeRGB = src->Texture.Unit[i].CombineModeRGB;
      dst->Texture.Unit[i].CombineModeA = src->Texture.Unit[i].CombineModeA;
      COPY_3V(dst->Texture.Unit[i].CombineSourceRGB, src->Texture.Unit[i].CombineSourceRGB);
      COPY_3V(dst->Texture.Unit[i].CombineSourceA, src->Texture.Unit[i].CombineSourceA);
      COPY_3V(dst->Texture.Unit[i].CombineOperandRGB, src->Texture.Unit[i].CombineOperandRGB);
      COPY_3V(dst->Texture.Unit[i].CombineOperandA, src->Texture.Unit[i].CombineOperandA);
      dst->Texture.Unit[i].CombineScaleShiftRGB = src->Texture.Unit[i].CombineScaleShiftRGB;
      dst->Texture.Unit[i].CombineScaleShiftA = src->Texture.Unit[i].CombineScaleShiftA;

      /* texture object state */
      _mesa_copy_texture_object(dst->Texture.Unit[i].Current1D,
                                src->Texture.Unit[i].Current1D);
      _mesa_copy_texture_object(dst->Texture.Unit[i].Current2D,
                                src->Texture.Unit[i].Current2D);
      _mesa_copy_texture_object(dst->Texture.Unit[i].Current3D,
                                src->Texture.Unit[i].Current3D);
      _mesa_copy_texture_object(dst->Texture.Unit[i].CurrentCubeMap,
                                src->Texture.Unit[i].CurrentCubeMap);
      _mesa_copy_texture_object(dst->Texture.Unit[i].CurrentRect,
                                src->Texture.Unit[i].CurrentRect);
   }
}


/*
 * For debugging
 */
void
_mesa_print_texunit_state( GLcontext *ctx, GLuint unit )
{
   const struct gl_texture_unit *texUnit = ctx->Texture.Unit + unit;
   _mesa_printf("Texture Unit %d\n", unit);
   _mesa_printf("  GL_TEXTURE_ENV_MODE = %s\n", _mesa_lookup_enum_by_nr(texUnit->EnvMode));
   _mesa_printf("  GL_COMBINE_RGB = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineModeRGB));
   _mesa_printf("  GL_COMBINE_ALPHA = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineModeA));
   _mesa_printf("  GL_SOURCE0_RGB = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineSourceRGB[0]));
   _mesa_printf("  GL_SOURCE1_RGB = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineSourceRGB[1]));
   _mesa_printf("  GL_SOURCE2_RGB = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineSourceRGB[2]));
   _mesa_printf("  GL_SOURCE0_ALPHA = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineSourceA[0]));
   _mesa_printf("  GL_SOURCE1_ALPHA = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineSourceA[1]));
   _mesa_printf("  GL_SOURCE2_ALPHA = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineSourceA[2]));
   _mesa_printf("  GL_OPERAND0_RGB = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineOperandRGB[0]));
   _mesa_printf("  GL_OPERAND1_RGB = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineOperandRGB[1]));
   _mesa_printf("  GL_OPERAND2_RGB = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineOperandRGB[2]));
   _mesa_printf("  GL_OPERAND0_ALPHA = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineOperandA[0]));
   _mesa_printf("  GL_OPERAND1_ALPHA = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineOperandA[1]));
   _mesa_printf("  GL_OPERAND2_ALPHA = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineOperandA[2]));
   _mesa_printf("  GL_RGB_SCALE = %d\n", 1 << texUnit->CombineScaleShiftRGB);
   _mesa_printf("  GL_ALPHA_SCALE = %d\n", 1 << texUnit->CombineScaleShiftA);
   _mesa_printf("  GL_TEXTURE_ENV_COLOR = (%f, %f, %f, %f)\n", texUnit->EnvColor[0], texUnit->EnvColor[1], texUnit->EnvColor[2], texUnit->EnvColor[3]);
}


a68 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d70 1
a70 2
#define TE_ERROR(errCode, msg, value)				\
   _mesa_error(ctx, errCode, msg, _mesa_lookup_enum_by_nr(value));
d72 1
a72 1
   if (target == GL_TEXTURE_ENV) {
d74 196
a269 13
      case GL_TEXTURE_ENV_MODE:
         {
            const GLenum mode = (GLenum) (GLint) *param;
            if (mode == GL_MODULATE ||
                mode == GL_BLEND ||
                mode == GL_DECAL ||
                mode == GL_REPLACE ||
                (mode == GL_ADD && ctx->Extensions.EXT_texture_env_add) ||
                (mode == GL_COMBINE &&
                 (ctx->Extensions.EXT_texture_env_combine ||
                  ctx->Extensions.ARB_texture_env_combine))) {
               /* legal */
               if (texUnit->EnvMode == mode)
d271 1
a271 2
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texUnit->EnvMode = mode;
d274 1
a274 1
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
d277 14
a290 10
         }
         break;
      case GL_TEXTURE_ENV_COLOR:
         {
            GLfloat tmp[4];
            tmp[0] = CLAMP( param[0], 0.0F, 1.0F );
            tmp[1] = CLAMP( param[1], 0.0F, 1.0F );
            tmp[2] = CLAMP( param[2], 0.0F, 1.0F );
            tmp[3] = CLAMP( param[3], 0.0F, 1.0F );
            if (TEST_EQ_4V(tmp, texUnit->EnvColor))
d292 18
a309 19
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            COPY_4FV(texUnit->EnvColor, tmp);
         }
         break;
      case GL_COMBINE_RGB:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum mode = (GLenum) (GLint) *param;
	    switch (mode) {
	    case GL_REPLACE:
	    case GL_MODULATE:
	    case GL_ADD:
	    case GL_ADD_SIGNED:
	    case GL_INTERPOLATE:
               /* OK */
	       break;
            case GL_SUBTRACT:
               if (!ctx->Extensions.ARB_texture_env_combine) {
                  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
a311 99
               break;
	    case GL_DOT3_RGB_EXT:
	    case GL_DOT3_RGBA_EXT:
	       if (!ctx->Extensions.EXT_texture_env_dot3) {
                  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
		  return;
	       }
	       break;
	    case GL_DOT3_RGB:
	    case GL_DOT3_RGBA:
	       if (!ctx->Extensions.ARB_texture_env_dot3) {
                  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
		  return;
	       }
	       break;
	    case GL_MODULATE_ADD_ATI:
	    case GL_MODULATE_SIGNED_ADD_ATI:
	    case GL_MODULATE_SUBTRACT_ATI:
	       if (!ctx->Extensions.ATI_texture_env_combine3) {
                  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
		  return;
	       }
	       break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
	       return;
	    }
	    if (texUnit->CombineModeRGB == mode)
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->CombineModeRGB = mode;
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
         break;
      case GL_COMBINE_ALPHA:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum mode = (GLenum) (GLint) *param;
            switch (mode) {
	    case GL_REPLACE:
	    case GL_MODULATE:
	    case GL_ADD:
	    case GL_ADD_SIGNED:
	    case GL_INTERPOLATE:
	       /* OK */
	       break;
	    case GL_SUBTRACT:
	       if (!ctx->Extensions.ARB_texture_env_combine) {
		  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
		  return;
	       }
	       break;
	    case GL_MODULATE_ADD_ATI:
	    case GL_MODULATE_SIGNED_ADD_ATI:
	    case GL_MODULATE_SUBTRACT_ATI:
	       if (!ctx->Extensions.ATI_texture_env_combine3) {
                  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
		  return;
	       }
	       break;
	    default:
	       TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
	       return;
	    }

	    if (texUnit->CombineModeA == mode)
		return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->CombineModeA = mode;
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      case GL_SOURCE0_RGB:
      case GL_SOURCE1_RGB:
      case GL_SOURCE2_RGB:
	 if (ctx->Extensions.EXT_texture_env_combine ||
	     ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum source = (GLenum) (GLint) *param;
	    const GLuint s = pname - GL_SOURCE0_RGB;
            if (source == GL_TEXTURE ||
                source == GL_CONSTANT ||
                source == GL_PRIMARY_COLOR ||
                source == GL_PREVIOUS ||
                (ctx->Extensions.ARB_texture_env_crossbar &&
                 source >= GL_TEXTURE0 &&
                 source < GL_TEXTURE0 + ctx->Const.MaxTextureUnits) ||
                (ctx->Extensions.ATI_texture_env_combine3 &&
                 (source == GL_ZERO || source == GL_ONE))) {
               /* legal */
               if (texUnit->CombineSourceRGB[s] == source)
                  return;
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->CombineSourceRGB[s] = source;
d314 20
a333 27
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", source);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      case GL_SOURCE0_ALPHA:
      case GL_SOURCE1_ALPHA:
      case GL_SOURCE2_ALPHA:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum source = (GLenum) (GLint) *param;
	    const GLuint s = pname - GL_SOURCE0_ALPHA;
            if (source == GL_TEXTURE ||
                source == GL_CONSTANT ||
                source == GL_PRIMARY_COLOR ||
                source == GL_PREVIOUS ||
                (ctx->Extensions.ARB_texture_env_crossbar &&
                 source >= GL_TEXTURE0 &&
                 source < GL_TEXTURE0 + ctx->Const.MaxTextureUnits) ||
		(ctx->Extensions.ATI_texture_env_combine3 &&
                 (source == GL_ZERO || source == GL_ONE))) {
               /* legal */
	       if (texUnit->CombineSourceA[s] == source)
d335 1
a335 2
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->CombineSourceA[s] = source;
d338 7
a344 120
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", source);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      case GL_OPERAND0_RGB:
      case GL_OPERAND1_RGB:
      case GL_OPERAND2_RGB:
	 if (ctx->Extensions.EXT_texture_env_combine ||
	     ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum operand = (GLenum) (GLint) *param;
	    const GLuint s = pname - GL_OPERAND0_RGB;
	    switch (operand) {
	    case GL_SRC_COLOR:
	    case GL_ONE_MINUS_SRC_COLOR:
	    case GL_SRC_ALPHA:
	    case GL_ONE_MINUS_SRC_ALPHA:
	       if (texUnit->CombineOperandRGB[s] == operand)
		  return;
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->CombineOperandRGB[s] = operand;
	       break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", operand);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      case GL_OPERAND0_ALPHA:
      case GL_OPERAND1_ALPHA:
      case GL_OPERAND2_ALPHA:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum operand = (GLenum) (GLint) *param;
	    switch (operand) {
	    case GL_SRC_ALPHA:
	    case GL_ONE_MINUS_SRC_ALPHA:
	       if (texUnit->CombineOperandA[pname-GL_OPERAND0_ALPHA] ==
		   operand)
		  return;
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->CombineOperandA[pname-GL_OPERAND0_ALPHA] = operand;
	       break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", operand);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      case GL_RGB_SCALE:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    GLuint newshift;
	    if (*param == 1.0) {
	       newshift = 0;
	    }
	    else if (*param == 2.0) {
	       newshift = 1;
	    }
	    else if (*param == 4.0) {
	       newshift = 2;
	    }
	    else {
	       _mesa_error( ctx, GL_INVALID_VALUE,
                            "glTexEnv(GL_RGB_SCALE not 1, 2 or 4)" );
	       return;
	    }
	    if (texUnit->CombineScaleShiftRGB == newshift)
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->CombineScaleShiftRGB = newshift;
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      case GL_ALPHA_SCALE:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    GLuint newshift;
	    if (*param == 1.0) {
	       newshift = 0;
	    }
	    else if (*param == 2.0) {
	       newshift = 1;
	    }
	    else if (*param == 4.0) {
	       newshift = 2;
	    }
	    else {
	       _mesa_error( ctx, GL_INVALID_VALUE,
                            "glTexEnv(GL_ALPHA_SCALE not 1, 2 or 4)" );
	       return;
	    }
	    if (texUnit->CombineScaleShiftA == newshift)
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->CombineScaleShiftA = newshift;
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      default:
	 _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(pname)" );
	 return;
d347 3
a349 4
   else if (target == GL_TEXTURE_FILTER_CONTROL_EXT) {
      /* GL_EXT_texture_lod_bias */
      if (!ctx->Extensions.EXT_texture_lod_bias) {
	 _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(target=0x%x)", target );
d353 1
a353 4
	 if (texUnit->LodBias == param[0])
	    return;
	 FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texUnit->LodBias = param[0];
d356 1
a356 8
         TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	 return;
      }
   }
   else if (target == GL_POINT_SPRITE_NV) {
      /* GL_NV_point_sprite */
      if (!ctx->Extensions.NV_point_sprite) {
	 _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(target=0x%x)", target );
a358 21
      if (pname == GL_COORD_REPLACE_NV) {
         const GLenum value = (GLenum) param[0];
         if (value == GL_TRUE || value == GL_FALSE) {
            /* It's kind of weird to set point state via glTexEnv,
             * but that's what the spec calls for.
             */
            const GLboolean state = (GLboolean) value;
            if (ctx->Point.CoordReplace[ctx->Texture.CurrentUnit] == state)
               return;
            FLUSH_VERTICES(ctx, _NEW_POINT);
            ctx->Point.CoordReplace[ctx->Texture.CurrentUnit] = state;
         }
         else {
            _mesa_error( ctx, GL_INVALID_VALUE, "glTexEnv(param=0x%x)", value);
            return;
         }
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(pname=0x%x)", pname );
         return;
      }
d361 1
a361 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(target=0x%x)",target );
d366 5
a370 5
      _mesa_debug(ctx, "glTexEnv %s %s %.1f(%s) ...\n",
                  _mesa_lookup_enum_by_nr(target),
                  _mesa_lookup_enum_by_nr(pname),
                  *param,
                  _mesa_lookup_enum_by_nr((GLenum) (GLint) *param));
d376 1
d402 19
a420 5
   if (pname == GL_TEXTURE_ENV_COLOR) {
      p[0] = INT_TO_FLOAT( param[0] );
      p[1] = INT_TO_FLOAT( param[1] );
      p[2] = INT_TO_FLOAT( param[2] );
      p[3] = INT_TO_FLOAT( param[3] );
d422 38
a459 3
   else {
      p[0] = (GLfloat) param[0];
      p[1] = p[2] = p[3] = 0;  /* init to zero, just to be safe */
a460 1
   _mesa_TexEnvfv( target, pname, p );
d465 1
a465 1
_mesa_GetTexEnvfv( GLenum target, GLenum pname, GLfloat *params )
a468 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d470 131
a600 412
   if (target == GL_TEXTURE_ENV) {
      switch (pname) {
         case GL_TEXTURE_ENV_MODE:
            *params = ENUM_TO_FLOAT(texUnit->EnvMode);
            break;
         case GL_TEXTURE_ENV_COLOR:
            COPY_4FV( params, texUnit->EnvColor );
            break;
         case GL_COMBINE_RGB:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineModeRGB;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
         case GL_COMBINE_ALPHA:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineModeA;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
         case GL_SOURCE0_RGB:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineSourceRGB[0];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
         case GL_SOURCE1_RGB:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineSourceRGB[1];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
         case GL_SOURCE2_RGB:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineSourceRGB[2];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
         case GL_SOURCE0_ALPHA:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineSourceA[0];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
         case GL_SOURCE1_ALPHA:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineSourceA[1];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
         case GL_SOURCE2_ALPHA:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineSourceA[2];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
         case GL_OPERAND0_RGB:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineOperandRGB[0];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
         case GL_OPERAND1_RGB:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineOperandRGB[1];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
         case GL_OPERAND2_RGB:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineOperandRGB[2];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
         case GL_OPERAND0_ALPHA:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineOperandA[0];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
         case GL_OPERAND1_ALPHA:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineOperandA[1];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
         case GL_OPERAND2_ALPHA:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineOperandA[2];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
         case GL_RGB_SCALE:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               if (texUnit->CombineScaleShiftRGB == 0)
                  *params = 1.0;
               else if (texUnit->CombineScaleShiftRGB == 1)
                  *params = 2.0;
               else
                  *params = 4.0;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
               return;
            }
            break;
         case GL_ALPHA_SCALE:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               if (texUnit->CombineScaleShiftA == 0)
                  *params = 1.0;
               else if (texUnit->CombineScaleShiftA == 1)
                  *params = 2.0;
               else
                  *params = 4.0;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
               return;
            }
            break;
         default:
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)" );
      }
   }
   else if (target == GL_TEXTURE_FILTER_CONTROL_EXT) {
      /* GL_EXT_texture_lod_bias */
      if (!ctx->Extensions.EXT_texture_lod_bias) {
	 _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(target)" );
	 return;
      }
      if (pname == GL_TEXTURE_LOD_BIAS_EXT) {
         *params = texUnit->LodBias;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)" );
	 return;
      }
   }
   else if (target == GL_POINT_SPRITE_NV) {
      /* GL_NV_point_sprite */
      if (!ctx->Extensions.NV_point_sprite) {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(target)" );
         return;
      }
      if (pname == GL_COORD_REPLACE_NV) {
         *params = (GLfloat) ctx->Point.CoordReplace[ctx->Texture.CurrentUnit];
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)" );
         return;
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(target)" );
      return;
   }
}


void
_mesa_GetTexEnviv( GLenum target, GLenum pname, GLint *params )
{
   GET_CURRENT_CONTEXT(ctx);
   const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (target == GL_TEXTURE_ENV) {
      switch (pname) {
         case GL_TEXTURE_ENV_MODE:
            *params = (GLint) texUnit->EnvMode;
            break;
         case GL_TEXTURE_ENV_COLOR:
            params[0] = FLOAT_TO_INT( texUnit->EnvColor[0] );
            params[1] = FLOAT_TO_INT( texUnit->EnvColor[1] );
            params[2] = FLOAT_TO_INT( texUnit->EnvColor[2] );
            params[3] = FLOAT_TO_INT( texUnit->EnvColor[3] );
            break;
         case GL_COMBINE_RGB:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineModeRGB;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_COMBINE_ALPHA:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineModeA;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_SOURCE0_RGB:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineSourceRGB[0];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_SOURCE1_RGB:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineSourceRGB[1];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_SOURCE2_RGB:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineSourceRGB[2];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_SOURCE0_ALPHA:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineSourceA[0];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_SOURCE1_ALPHA:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineSourceA[1];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_SOURCE2_ALPHA:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineSourceA[2];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_OPERAND0_RGB:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineOperandRGB[0];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_OPERAND1_RGB:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineOperandRGB[1];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_OPERAND2_RGB:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineOperandRGB[2];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_OPERAND0_ALPHA:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineOperandA[0];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_OPERAND1_ALPHA:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineOperandA[1];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_OPERAND2_ALPHA:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineOperandA[2];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_RGB_SCALE:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               if (texUnit->CombineScaleShiftRGB == 0)
                  *params = 1;
               else if (texUnit->CombineScaleShiftRGB == 1)
                  *params = 2;
               else
                  *params = 4;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
               return;
            }
            break;
         case GL_ALPHA_SCALE:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               if (texUnit->CombineScaleShiftA == 0)
                  *params = 1;
               else if (texUnit->CombineScaleShiftA == 1)
                  *params = 2;
               else
                  *params = 4;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
               return;
            }
            break;
         default:
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)" );
      }
   }
   else if (target == GL_TEXTURE_FILTER_CONTROL_EXT) {
      /* GL_EXT_texture_lod_bias */
      if (!ctx->Extensions.EXT_texture_lod_bias) {
	 _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(target)" );
	 return;
      }
      if (pname == GL_TEXTURE_LOD_BIAS_EXT) {
         *params = (GLint) texUnit->LodBias;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)" );
	 return;
      }
   }
   else if (target == GL_POINT_SPRITE_NV) {
      /* GL_NV_point_sprite */
      if (!ctx->Extensions.NV_point_sprite) {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(target)" );
         return;
      }
      if (pname == GL_COORD_REPLACE_NV) {
         *params = (GLint) ctx->Point.CoordReplace[ctx->Texture.CurrentUnit];
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)" );
         return;
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(target)" );
      return;
d626 2
a627 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d630 4
a633 5
      _mesa_debug(ctx, "glTexParameter %s %s %.1f(%s)...\n",
                  _mesa_lookup_enum_by_nr(target),
                  _mesa_lookup_enum_by_nr(pname),
                  *params,
		  _mesa_lookup_enum_by_nr(eparam));
d638 1
a638 1
         texObj = texUnit->Current1D;
d641 1
a641 1
         texObj = texUnit->Current2D;
d643 2
a644 2
      case GL_TEXTURE_3D:
         texObj = texUnit->Current3D;
d646 4
a649 4
      case GL_TEXTURE_CUBE_MAP:
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(target)" );
            return;
d651 1
a651 9
         texObj = texUnit->CurrentCubeMap;
         break;
      case GL_TEXTURE_RECTANGLE_NV:
         if (!ctx->Extensions.NV_texture_rectangle) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(target)" );
            return;
         }
         texObj = texUnit->CurrentRect;
         break;
d653 1
a653 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(target)" );
d662 6
a667 10
         if (eparam==GL_NEAREST || eparam==GL_LINEAR) {
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texObj->MinFilter = eparam;
         }
         else if ((eparam==GL_NEAREST_MIPMAP_NEAREST ||
                   eparam==GL_LINEAR_MIPMAP_NEAREST ||
                   eparam==GL_NEAREST_MIPMAP_LINEAR ||
                   eparam==GL_LINEAR_MIPMAP_LINEAR) &&
                  texObj->Target != GL_TEXTURE_RECTANGLE_NV) {
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
d669 1
d672 1
a672 1
            _mesa_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
a681 1
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
d683 1
d686 1
a686 1
            _mesa_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
d693 2
a694 17
         if (eparam == GL_CLAMP || eparam == GL_CLAMP_TO_EDGE ||
             (eparam == GL_CLAMP_TO_BORDER &&
              ctx->Extensions.ARB_texture_border_clamp)) {
            /* any texture target */
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texObj->WrapS = eparam;
         }
         else if (texObj->Target != GL_TEXTURE_RECTANGLE_NV &&
                  (eparam == GL_REPEAT ||
                   (eparam == GL_MIRRORED_REPEAT &&
                    ctx->Extensions.ARB_texture_mirrored_repeat) ||
                   (eparam == GL_MIRROR_CLAMP_ATI &&
                    ctx->Extensions.ATI_texture_mirror_once) ||
                   (eparam == GL_MIRROR_CLAMP_TO_EDGE_ATI &&
                    ctx->Extensions.ATI_texture_mirror_once))) {
            /* non-rectangle texture */
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
d696 1
d699 1
a699 1
            _mesa_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
d706 2
a707 5
         if (eparam == GL_CLAMP || eparam == GL_CLAMP_TO_EDGE ||
             (eparam == GL_CLAMP_TO_BORDER &&
              ctx->Extensions.ARB_texture_border_clamp)) {
            /* any texture target */
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
d709 1
a709 197
         }
         else if (texObj->Target != GL_TEXTURE_RECTANGLE_NV &&
                  (eparam == GL_REPEAT ||
                   (eparam == GL_MIRRORED_REPEAT &&
                    ctx->Extensions.ARB_texture_mirrored_repeat) ||
                   (eparam == GL_MIRROR_CLAMP_ATI &&
                    ctx->Extensions.ATI_texture_mirror_once) ||
                   (eparam == GL_MIRROR_CLAMP_TO_EDGE_ATI &&
                    ctx->Extensions.ATI_texture_mirror_once))) {
            /* non-rectangle texture */
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texObj->WrapT = eparam;
         }
         else {
            _mesa_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
            return;
         }
         break;
      case GL_TEXTURE_WRAP_R:
         if (texObj->WrapR == eparam)
            return;
         if (eparam == GL_CLAMP || eparam == GL_CLAMP_TO_EDGE ||
             (eparam == GL_CLAMP_TO_BORDER &&
              ctx->Extensions.ARB_texture_border_clamp)) {
            /* any texture target */
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texObj->WrapR = eparam;
         }
         else if (texObj->Target != GL_TEXTURE_RECTANGLE_NV &&
                  (eparam == GL_REPEAT ||
                   (eparam == GL_MIRRORED_REPEAT &&
                    ctx->Extensions.ARB_texture_mirrored_repeat) ||
                   (eparam == GL_MIRROR_CLAMP_ATI &&
                    ctx->Extensions.ATI_texture_mirror_once) ||
                   (eparam == GL_MIRROR_CLAMP_TO_EDGE_ATI &&
                    ctx->Extensions.ATI_texture_mirror_once))) {
            /* non-rectangle texture */
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texObj->WrapR = eparam;
         }
         else {
            _mesa_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
         }
         break;
      case GL_TEXTURE_BORDER_COLOR:
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texObj->BorderColor[RCOMP] = params[0];
         texObj->BorderColor[GCOMP] = params[1];
         texObj->BorderColor[BCOMP] = params[2];
         texObj->BorderColor[ACOMP] = params[3];
         UNCLAMPED_FLOAT_TO_CHAN(texObj->_BorderChan[RCOMP], params[0]);
         UNCLAMPED_FLOAT_TO_CHAN(texObj->_BorderChan[GCOMP], params[1]);
         UNCLAMPED_FLOAT_TO_CHAN(texObj->_BorderChan[BCOMP], params[2]);
         UNCLAMPED_FLOAT_TO_CHAN(texObj->_BorderChan[ACOMP], params[3]);
         break;
      case GL_TEXTURE_MIN_LOD:
         if (texObj->MinLod == params[0])
            return;
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texObj->MinLod = params[0];
         break;
      case GL_TEXTURE_MAX_LOD:
         if (texObj->MaxLod == params[0])
            return;
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texObj->MaxLod = params[0];
         break;
      case GL_TEXTURE_BASE_LEVEL:
         if (params[0] < 0.0) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
            return;
         }
         if (target == GL_TEXTURE_RECTANGLE_NV && params[0] != 0.0) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
            return;
         }
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texObj->BaseLevel = (GLint) params[0];
         break;
      case GL_TEXTURE_MAX_LEVEL:
         if (params[0] < 0.0) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
            return;
         }
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texObj->MaxLevel = (GLint) params[0];
         break;
      case GL_TEXTURE_PRIORITY:
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texObj->Priority = CLAMP( params[0], 0.0F, 1.0F );
         break;
      case GL_TEXTURE_MAX_ANISOTROPY_EXT:
         if (ctx->Extensions.EXT_texture_filter_anisotropic) {
	    if (params[0] < 1.0) {
	       _mesa_error(ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
	       return;
	    }
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texObj->MaxAnisotropy = params[0];
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_TEXTURE_MAX_ANISOTROPY_EXT)");
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texObj->CompareFlag = params[0] ? GL_TRUE : GL_FALSE;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_TEXTURE_COMPARE_SGIX)");
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            GLenum op = (GLenum) params[0];
            if (op == GL_TEXTURE_LEQUAL_R_SGIX ||
                op == GL_TEXTURE_GEQUAL_R_SGIX) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texObj->CompareOperator = op;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(param)");
            }
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                    "glTexParameter(pname=GL_TEXTURE_COMPARE_OPERATOR_SGIX)");
            return;
         }
         break;
      case GL_SHADOW_AMBIENT_SGIX: /* aka GL_TEXTURE_COMPARE_FAIL_VALUE_ARB */
         if (ctx->Extensions.SGIX_shadow_ambient) {
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texObj->ShadowAmbient = CLAMP(params[0], 0.0F, 1.0F);
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_SHADOW_AMBIENT_SGIX)");
            return;
         }
         break;
      case GL_GENERATE_MIPMAP_SGIS:
         if (ctx->Extensions.SGIS_generate_mipmap) {
            texObj->GenerateMipmap = params[0] ? GL_TRUE : GL_FALSE;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_GENERATE_MIPMAP_SGIS)");
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_MODE_ARB:
         if (ctx->Extensions.ARB_shadow) {
            const GLenum mode = (GLenum) params[0];
            if (mode == GL_NONE || mode == GL_COMPARE_R_TO_TEXTURE_ARB) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texObj->CompareMode = mode;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM,
                           "glTexParameter(bad GL_TEXTURE_COMPARE_MODE_ARB: 0x%x)", mode);
               return;
            }
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_TEXTURE_COMPARE_MODE_ARB)");
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_FUNC_ARB:
         if (ctx->Extensions.ARB_shadow) {
            const GLenum func = (GLenum) params[0];
            if (func == GL_LEQUAL || func == GL_GEQUAL) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texObj->CompareFunc = func;
            }
            else if (ctx->Extensions.EXT_shadow_funcs &&
                     (func == GL_EQUAL ||
                      func == GL_NOTEQUAL ||
                      func == GL_LESS ||
                      func == GL_GREATER ||
                      func == GL_ALWAYS ||
                      func == GL_NEVER)) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texObj->CompareFunc = func;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM,
                           "glTexParameter(bad GL_TEXTURE_COMPARE_FUNC_ARB)");
               return;
            }
d712 1
a712 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_TEXTURE_COMPARE_FUNC_ARB)");
d716 7
a722 13
      case GL_DEPTH_TEXTURE_MODE_ARB:
         if (ctx->Extensions.ARB_depth_texture) {
            const GLenum result = (GLenum) params[0];
            if (result == GL_LUMINANCE || result == GL_INTENSITY
                || result == GL_ALPHA) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texObj->DepthMode = result;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM,
                          "glTexParameter(bad GL_DEPTH_TEXTURE_MODE_ARB)");
               return;
            }
d725 20
a744 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_DEPTH_TEXTURE_MODE_ARB)");
d747 2
d750 4
a753 7
      case GL_TEXTURE_LOD_BIAS:
         /* NOTE: this is really part of OpenGL 1.4, not EXT_texture_lod_bias*/
         if (ctx->Extensions.EXT_texture_lod_bias) {
            if (texObj->LodBias != params[0]) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texObj->LodBias = params[0];
            }
d755 6
a761 1

d763 1
a763 2
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexParameter(pname=0x%x)", pname);
d767 1
a767 1
   texObj->Complete = GL_FALSE;
d779 1
a779 4
   if (pname == GL_TEXTURE_PRIORITY)
      fparam[0] = INT_TO_FLOAT(param);
   else
      fparam[0] = (GLfloat) param;
a783 1

d788 2
a789 13
   if (pname == GL_TEXTURE_BORDER_COLOR) {
      fparam[0] = INT_TO_FLOAT(params[0]);
      fparam[1] = INT_TO_FLOAT(params[1]);
      fparam[2] = INT_TO_FLOAT(params[2]);
      fparam[3] = INT_TO_FLOAT(params[3]);
   }
   else {
      if (pname == GL_TEXTURE_PRIORITY)
         fparam[0] = INT_TO_FLOAT(params[0]);
      else
         fparam[0] = (GLfloat) params[0];
      fparam[1] = fparam[2] = fparam[3] = 0.0F;
   }
d817 3
a819 12
      case GL_TEXTURE_CUBE_MAP:
      case GL_PROXY_TEXTURE_CUBE_MAP:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
         return ctx->Extensions.ARB_texture_cube_map ? 2 : 0;
      case GL_TEXTURE_RECTANGLE_NV:
      case GL_PROXY_TEXTURE_RECTANGLE_NV:
         return ctx->Extensions.NV_texture_rectangle ? 2 : 0;
d821 1
a821 1
         _mesa_problem(ctx, "bad target in _mesa_tex_target_dimensions()");
a835 2
   GLint maxLevels;
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d837 1
a837 6
   /* this will catch bad target values */
   dimensions = tex_image_dimensions(ctx, target);  /* 1, 2 or 3 */
   if (dimensions == 0) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexLevelParameter[if]v(target)");
      return;
   }
d839 2
a840 26
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
      maxLevels = ctx->Const.MaxTextureLevels;
      break;
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      maxLevels = ctx->Const.Max3DTextureLevels;
      break;
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
   case GL_PROXY_TEXTURE_CUBE_MAP:
      maxLevels = ctx->Const.MaxCubeTextureLevels;
      break;
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_PROXY_TEXTURE_RECTANGLE_NV:
      maxLevels = 1;
      break;
   default:
      _mesa_problem(ctx, "switch in _mesa_GetTexLevelParameter");
d844 3
a846 2
   if (level < 0 || level >= maxLevels) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glGetTexLevelParameter[if]v" );
d851 1
a851 2
   if (!img || !img->TexFormat) {
      /* undefined texture image */
d862 1
a862 2
             (target == GL_PROXY_TEXTURE_CUBE_MAP) ||
             (target == GL_PROXY_TEXTURE_RECTANGLE_NV);
d869 7
a875 1
         *params = img->Height;
d878 7
a884 1
         *params = img->Depth;
d886 1
a886 1
      case GL_TEXTURE_INTERNAL_FORMAT:
d929 1
a929 1
         else if (img->TexFormat->LuminanceBits > 0)
d932 1
a932 1
            *params = MIN2(img->TexFormat->RedBits, img->TexFormat->GreenBits);
d935 1
a935 14
         if (img->Format == GL_COLOR_INDEX)
            *params = img->TexFormat->IndexBits;
         else
            *params = 0;
         return;
      case GL_DEPTH_BITS:
         /* XXX this isn't in the GL_SGIX_depth_texture spec
          * but seems appropriate.
          */
         if (ctx->Extensions.SGIX_depth_texture)
            *params = img->TexFormat->DepthBits;
         else
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d939 2
a940 2
      case GL_TEXTURE_COMPRESSED_IMAGE_SIZE:
         if (ctx->Extensions.ARB_texture_compression) {
d944 2
a945 2
               _mesa_error(ctx, GL_INVALID_OPERATION,
                           "glGetTexLevelParameter[if]v(pname)");
d948 1
a948 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d951 2
a952 2
      case GL_TEXTURE_COMPRESSED:
         if (ctx->Extensions.ARB_texture_compression) {
d956 1
a956 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d961 1
a961 2
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glGetTexLevelParameter[if]v(pname)");
d973 2
a974 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d978 1
a978 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexParameterfv(target)");
d985 1
a985 1
	 return;
d988 1
a988 1
         return;
d991 1
a991 1
         return;
d994 2
a995 2
         return;
      case GL_TEXTURE_WRAP_R:
d997 1
a997 1
         return;
d999 5
a1003 5
         params[0] = CLAMP(obj->BorderColor[0], 0.0F, 1.0F);
         params[1] = CLAMP(obj->BorderColor[1], 0.0F, 1.0F);
         params[2] = CLAMP(obj->BorderColor[2], 0.0F, 1.0F);
         params[3] = CLAMP(obj->BorderColor[3], 0.0F, 1.0F);
         return;
d1013 1
a1013 1
         return;
d1016 1
a1016 1
         return;
d1019 1
a1019 1
         return;
d1022 1
a1022 1
         return;
d1025 1
a1025 1
         return;
a1027 54
         return;
      case GL_TEXTURE_LOD_BIAS:
         if (ctx->Extensions.EXT_texture_lod_bias) {
            *params = obj->LodBias;
            break;
         }
         break;
      case GL_TEXTURE_MAX_ANISOTROPY_EXT:
         if (ctx->Extensions.EXT_texture_filter_anisotropic) {
            *params = obj->MaxAnisotropy;
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            *params = (GLfloat) obj->CompareFlag;
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            *params = (GLfloat) obj->CompareOperator;
            return;
         }
         break;
      case GL_SHADOW_AMBIENT_SGIX: /* aka GL_TEXTURE_COMPARE_FAIL_VALUE_ARB */
         if (ctx->Extensions.SGIX_shadow_ambient) {
            *params = obj->ShadowAmbient;
            return;
         }
         break;
      case GL_GENERATE_MIPMAP_SGIS:
         if (ctx->Extensions.SGIS_generate_mipmap) {
            *params = (GLfloat) obj->GenerateMipmap;
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_MODE_ARB:
         if (ctx->Extensions.ARB_shadow) {
            *params = (GLfloat) obj->CompareMode;
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_FUNC_ARB:
         if (ctx->Extensions.ARB_shadow) {
            *params = (GLfloat) obj->CompareFunc;
            return;
         }
         break;
      case GL_DEPTH_TEXTURE_MODE_ARB:
         if (ctx->Extensions.ARB_depth_texture) {
            *params = (GLfloat) obj->DepthMode;
            return;
         }
d1030 1
a1030 1
         ; /* silence warnings */
a1031 2
   /* If we get here, pname was an unrecognized enum */
   _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexParameterfv(pname)" );
d1041 2
a1042 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1046 1
a1046 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexParameteriv(target)");
d1053 1
a1053 1
         return;
d1056 1
a1056 1
         return;
d1059 1
a1059 1
         return;
d1062 2
a1063 2
         return;
      case GL_TEXTURE_WRAP_R:
d1065 1
a1065 1
         return;
d1068 9
a1076 9
            GLfloat b[4];
            b[0] = CLAMP(obj->BorderColor[0], 0.0F, 1.0F);
            b[1] = CLAMP(obj->BorderColor[1], 0.0F, 1.0F);
            b[2] = CLAMP(obj->BorderColor[2], 0.0F, 1.0F);
            b[3] = CLAMP(obj->BorderColor[3], 0.0F, 1.0F);
            params[0] = FLOAT_TO_INT(b[0]);
            params[1] = FLOAT_TO_INT(b[1]);
            params[2] = FLOAT_TO_INT(b[2]);
            params[3] = FLOAT_TO_INT(b[3]);
d1078 1
a1078 1
         return;
d1088 1
a1088 1
         return;
d1090 2
a1091 2
         *params = FLOAT_TO_INT(obj->Priority);
         return;
d1094 1
a1094 1
         return;
d1097 1
a1097 1
         return;
d1100 1
a1100 1
         return;
a1102 54
         return;
      case GL_TEXTURE_LOD_BIAS:
         if (ctx->Extensions.EXT_texture_lod_bias) {
            *params = (GLint) obj->LodBias;
            break;
         }
         break;
      case GL_TEXTURE_MAX_ANISOTROPY_EXT:
         if (ctx->Extensions.EXT_texture_filter_anisotropic) {
            *params = (GLint) obj->MaxAnisotropy;
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            *params = (GLint) obj->CompareFlag;
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            *params = (GLint) obj->CompareOperator;
            return;
         }
         break;
      case GL_SHADOW_AMBIENT_SGIX: /* aka GL_TEXTURE_COMPARE_FAIL_VALUE_ARB */
         if (ctx->Extensions.SGIX_shadow_ambient) {
            *params = (GLint) FLOAT_TO_INT(obj->ShadowAmbient);
            return;
         }
         break;
      case GL_GENERATE_MIPMAP_SGIS:
         if (ctx->Extensions.SGIS_generate_mipmap) {
            *params = (GLint) obj->GenerateMipmap;
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_MODE_ARB:
         if (ctx->Extensions.ARB_shadow) {
            *params = (GLint) obj->CompareMode;
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_FUNC_ARB:
         if (ctx->Extensions.ARB_shadow) {
            *params = (GLint) obj->CompareFunc;
            return;
         }
         break;
      case GL_DEPTH_TEXTURE_MODE_ARB:
         if (ctx->Extensions.ARB_depth_texture) {
            *params = (GLint) obj->DepthMode;
            return;
         }
d1105 1
a1105 1
         ; /* silence warnings */
a1106 2
   /* If we get here, pname was an unrecognized enum */
   _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexParameteriv(pname)" );
d1121 1
a1121 1
   GLuint tUnit = ctx->Texture.CurrentUnit;
d1123 1
a1123 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1126 4
a1129 5
      _mesa_debug(ctx, "glTexGen %s %s %.1f(%s)...\n",
                  _mesa_lookup_enum_by_nr(coord),
                  _mesa_lookup_enum_by_nr(pname),
                  *params,
		  _mesa_lookup_enum_by_nr((GLenum) (GLint) *params));
a1134 1
	    GLuint bits;
d1137 2
a1138 1
	       bits = TEXGEN_OBJ_LINEAR;
d1141 2
a1142 1
	       bits = TEXGEN_EYE_LINEAR;
d1145 2
a1146 1
	       bits = TEXGEN_REFLECTION_MAP_NV;
d1149 2
a1150 1
	       bits = TEXGEN_NORMAL_MAP_NV;
d1153 2
a1154 1
	       bits = TEXGEN_SPHERE_MAP;
d1157 1
a1157 1
	       _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
a1159 5
	    if (texUnit->GenModeS == mode)
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->GenModeS = mode;
	    texUnit->_GenBitS = bits;
a1161 3
	    if (TEST_EQ_4V(texUnit->ObjectPlaneS, params))
		return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
a1167 2
	    GLfloat tmp[4];

d1169 2
a1170 2
            if (ctx->ModelviewMatrixStack.Top->flags & MAT_DIRTY_INVERSE) {
               _math_matrix_analyse( ctx->ModelviewMatrixStack.Top );
d1172 2
a1173 5
            _mesa_transform_vector( tmp, params, ctx->ModelviewMatrixStack.Top->inv );
	    if (TEST_EQ_4V(texUnit->EyePlaneS, tmp))
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    COPY_4FV(texUnit->EyePlaneS, tmp);
d1176 1
a1176 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
a1182 1
	    GLuint bitt;
d1185 2
a1186 1
                  bitt = TEXGEN_OBJ_LINEAR;
d1189 2
a1190 1
                  bitt = TEXGEN_EYE_LINEAR;
d1193 2
a1194 1
                  bitt = TEXGEN_REFLECTION_MAP_NV;
d1197 2
a1198 1
                  bitt = TEXGEN_NORMAL_MAP_NV;
d1201 2
a1202 1
                  bitt = TEXGEN_SPHERE_MAP;
d1205 1
a1205 1
                  _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
a1207 5
	    if (texUnit->GenModeT == mode)
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->GenModeT = mode;
	    texUnit->_GenBitT = bitt;
a1209 3
	    if (TEST_EQ_4V(texUnit->ObjectPlaneT, params))
		return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
a1215 1
	    GLfloat tmp[4];
d1217 2
a1218 2
	    if (ctx->ModelviewMatrixStack.Top->flags & MAT_DIRTY_INVERSE) {
               _math_matrix_analyse( ctx->ModelviewMatrixStack.Top );
d1220 2
a1221 5
            _mesa_transform_vector( tmp, params, ctx->ModelviewMatrixStack.Top->inv );
	    if (TEST_EQ_4V(texUnit->EyePlaneT, tmp))
		return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    COPY_4FV(texUnit->EyePlaneT, tmp);
d1224 1
a1224 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
a1230 1
	    GLuint bitr;
d1233 2
a1234 1
	       bitr = TEXGEN_OBJ_LINEAR;
d1237 2
a1238 1
	       bitr = TEXGEN_REFLECTION_MAP_NV;
d1241 2
a1242 1
	       bitr = TEXGEN_NORMAL_MAP_NV;
d1245 2
a1246 1
	       bitr = TEXGEN_EYE_LINEAR;
d1249 1
a1249 1
	       _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
a1251 5
	    if (texUnit->GenModeR == mode)
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->GenModeR = mode;
	    texUnit->_GenBitR = bitr;
a1253 3
	    if (TEST_EQ_4V(texUnit->ObjectPlaneR, params))
		return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
a1259 1
	    GLfloat tmp[4];
d1261 2
a1262 2
            if (ctx->ModelviewMatrixStack.Top->flags & MAT_DIRTY_INVERSE) {
               _math_matrix_analyse( ctx->ModelviewMatrixStack.Top );
d1264 2
a1265 5
            _mesa_transform_vector( tmp, params, ctx->ModelviewMatrixStack.Top->inv );
	    if (TEST_EQ_4V(texUnit->EyePlaneR, tmp))
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    COPY_4FV(texUnit->EyePlaneR, tmp);
d1268 1
a1268 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
a1274 1
	    GLuint bitq;
d1277 2
a1278 1
	       bitq = TEXGEN_OBJ_LINEAR;
d1281 2
a1282 1
	       bitq = TEXGEN_EYE_LINEAR;
d1285 1
a1285 1
	       _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
a1287 5
	    if (texUnit->GenModeQ == mode)
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->GenModeQ = mode;
	    texUnit->_GenBitQ = bitq;
a1289 3
	    if (TEST_EQ_4V(texUnit->ObjectPlaneQ, params))
		return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
a1295 1
	    GLfloat tmp[4];
d1297 2
a1298 2
            if (ctx->ModelviewMatrixStack.Top->flags & MAT_DIRTY_INVERSE) {
               _math_matrix_analyse( ctx->ModelviewMatrixStack.Top );
d1300 2
a1301 5
            _mesa_transform_vector( tmp, params, ctx->ModelviewMatrixStack.Top->inv );
	    if (TEST_EQ_4V(texUnit->EyePlaneQ, tmp))
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    COPY_4FV(texUnit->EyePlaneQ, tmp);
d1304 1
a1304 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
d1309 1
a1309 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(coord)" );
d1313 1
a1313 2
   if (ctx->Driver.TexGen)
      ctx->Driver.TexGen( ctx, coord, pname, params );
d1321 4
a1324 9
   p[0] = (GLfloat) params[0];
   if (pname == GL_TEXTURE_GEN_MODE) {
      p[1] = p[2] = p[3] = 0.0F;
   }
   else {
      p[1] = (GLfloat) params[1];
      p[2] = (GLfloat) params[2];
      p[3] = (GLfloat) params[3];
   }
d1341 4
a1344 9
   p[0] = (GLfloat) params[0];
   if (pname == GL_TEXTURE_GEN_MODE) {
      p[1] = p[2] = p[3] = 0.0F;
   }
   else {
      p[1] = (GLfloat) params[1];
      p[2] = (GLfloat) params[2];
      p[3] = (GLfloat) params[3];
   }
d1368 1
a1368 1
   GLuint tUnit = ctx->Texture.CurrentUnit;
d1370 2
a1371 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1385 1
a1385 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
d1400 1
a1400 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
d1415 1
a1415 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
d1430 1
a1430 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
d1435 1
a1435 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(coord)" );
d1446 1
a1446 1
   GLuint tUnit = ctx->Texture.CurrentUnit;
d1448 2
a1449 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1463 1
a1463 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
d1478 1
a1478 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
d1493 1
a1493 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
d1508 1
a1508 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
d1513 1
a1513 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(coord)" );
d1524 1
a1524 1
   GLuint tUnit = ctx->Texture.CurrentUnit;
d1526 2
a1527 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1547 1
a1547 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
d1568 1
a1568 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
d1589 1
a1589 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
d1610 1
a1610 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
d1615 1
a1615 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(coord)" );
d1626 3
a1628 2
   GLuint texUnit = target - GL_TEXTURE0;
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1631 2
a1632 2
      _mesa_debug(ctx, "glActiveTexture %s\n",
                  _mesa_lookup_enum_by_nr(target));
d1634 7
a1640 4
   /* Cater for texture unit 0 is first, therefore use >= */
   if (texUnit >= ctx->Const.MaxTextureUnits) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glActiveTexture(target)");
      return;
d1642 2
a1643 11

   FLUSH_VERTICES(ctx, _NEW_TEXTURE);

   ctx->Texture.CurrentUnit = texUnit;
   if (ctx->Transform.MatrixMode == GL_TEXTURE) {
      /* update current stack pointer */
      ctx->CurrentStack = &ctx->TextureMatrixStack[texUnit];
   }

   if (ctx->Driver.ActiveTexture) {
      (*ctx->Driver.ActiveTexture)( ctx, (GLuint) texUnit );
d1653 1
a1653 2
   GLuint texUnit = target - GL_TEXTURE0;
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1655 5
a1659 3
   if (texUnit > ctx->Const.MaxTextureUnits) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glClientActiveTexture(target)");
      return;
d1661 2
a1662 38

   FLUSH_VERTICES(ctx, _NEW_ARRAY);
   ctx->Array.ActiveTexture = texUnit;
}



/**********************************************************************/
/*                     Pixel Texgen Extensions                        */
/**********************************************************************/

void
_mesa_PixelTexGenSGIX(GLenum mode)
{
   GLenum newRgbSource, newAlphaSource;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   switch (mode) {
      case GL_NONE:
         newRgbSource = GL_PIXEL_GROUP_COLOR_SGIS;
         newAlphaSource = GL_PIXEL_GROUP_COLOR_SGIS;
         break;
      case GL_ALPHA:
         newRgbSource = GL_PIXEL_GROUP_COLOR_SGIS;
         newAlphaSource = GL_CURRENT_RASTER_COLOR;
         break;
      case GL_RGB:
         newRgbSource = GL_CURRENT_RASTER_COLOR;
         newAlphaSource = GL_PIXEL_GROUP_COLOR_SGIS;
         break;
      case GL_RGBA:
         newRgbSource = GL_CURRENT_RASTER_COLOR;
         newAlphaSource = GL_CURRENT_RASTER_COLOR;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glPixelTexGenSGIX(mode)");
         return;
a1663 15

   if (newRgbSource == ctx->Pixel.FragmentRgbSource &&
       newAlphaSource == ctx->Pixel.FragmentAlphaSource)
      return;

   FLUSH_VERTICES(ctx, _NEW_PIXEL);
   ctx->Pixel.FragmentRgbSource = newRgbSource;
   ctx->Pixel.FragmentAlphaSource = newAlphaSource;
}


void
_mesa_PixelTexGenParameterfSGIS(GLenum target, GLfloat value)
{
   _mesa_PixelTexGenParameteriSGIS(target, (GLint) value);
a1666 6
void
_mesa_PixelTexGenParameterfvSGIS(GLenum target, const GLfloat *value)
{
   _mesa_PixelTexGenParameteriSGIS(target, (GLint) *value);
}

d1668 6
a1673 2
void
_mesa_PixelTexGenParameteriSGIS(GLenum target, GLint value)
d1675 10
a1684 6
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (value != GL_CURRENT_RASTER_COLOR && value != GL_PIXEL_GROUP_COLOR_SGIS) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glPixelTexGenParameterSGIS(value)");
      return;
d1686 11
a1696 17

   switch (target) {
   case GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS:
      if (ctx->Pixel.FragmentRgbSource == (GLenum) value)
	 return;
      FLUSH_VERTICES(ctx, _NEW_PIXEL);
      ctx->Pixel.FragmentRgbSource = (GLenum) value;
      break;
   case GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS:
      if (ctx->Pixel.FragmentAlphaSource == (GLenum) value)
	 return;
      FLUSH_VERTICES(ctx, _NEW_PIXEL);
      ctx->Pixel.FragmentAlphaSource = (GLenum) value;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glPixelTexGenParameterSGIS(target)");
      return;
d1698 1
d1702 5
a1706 2
void
_mesa_PixelTexGenParameterivSGIS(GLenum target, const GLint *value)
d1708 14
a1721 18
  _mesa_PixelTexGenParameteriSGIS(target, *value);
}


void
_mesa_GetPixelTexGenParameterfvSGIS(GLenum target, GLfloat *value)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (target == GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS) {
      *value = (GLfloat) ctx->Pixel.FragmentRgbSource;
   }
   else if (target == GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS) {
      *value = (GLfloat) ctx->Pixel.FragmentAlphaSource;
   }
   else {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetPixelTexGenParameterfvSGIS(target)");
d1726 5
a1730 2
void
_mesa_GetPixelTexGenParameterivSGIS(GLenum target, GLint *value)
d1732 7
a1738 11
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (target == GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS) {
      *value = (GLint) ctx->Pixel.FragmentRgbSource;
   }
   else if (target == GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS) {
      *value = (GLint) ctx->Pixel.FragmentAlphaSource;
   }
   else {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetPixelTexGenParameterivSGIS(target)");
d1740 1
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d4 1
a4 1
 * Version:  4.0.4
d6 1
a6 1
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
a30 1
#include "colormac.h"
d35 1
d39 3
a41 3
#include "mtypes.h"
#include "math/m_xform.h"
#include "math/m_matrix.h"
a57 64
void
_mesa_copy_texture_state( const GLcontext *src, GLcontext *dst )
{
   GLuint i;

   ASSERT(src);
   ASSERT(dst);

   dst->Texture.CurrentUnit = src->Texture.CurrentUnit;
   dst->Texture._GenFlags = src->Texture._GenFlags;
   dst->Texture._TexGenEnabled = src->Texture._TexGenEnabled;
   dst->Texture._TexMatEnabled = src->Texture._TexMatEnabled;
   dst->Texture.SharedPalette = src->Texture.SharedPalette;

   /* per-unit state */
   for (i = 0; i < src->Const.MaxTextureUnits; i++) {
      dst->Texture.Unit[i].Enabled = src->Texture.Unit[i].Enabled;
      dst->Texture.Unit[i].EnvMode = src->Texture.Unit[i].EnvMode;
      COPY_4V(dst->Texture.Unit[i].EnvColor, src->Texture.Unit[i].EnvColor);
      dst->Texture.Unit[i].TexGenEnabled = src->Texture.Unit[i].TexGenEnabled;
      dst->Texture.Unit[i].GenModeS = src->Texture.Unit[i].GenModeS;
      dst->Texture.Unit[i].GenModeT = src->Texture.Unit[i].GenModeT;
      dst->Texture.Unit[i].GenModeR = src->Texture.Unit[i].GenModeR;
      dst->Texture.Unit[i].GenModeQ = src->Texture.Unit[i].GenModeQ;
      dst->Texture.Unit[i]._GenBitS = src->Texture.Unit[i]._GenBitS;
      dst->Texture.Unit[i]._GenBitT = src->Texture.Unit[i]._GenBitT;
      dst->Texture.Unit[i]._GenBitR = src->Texture.Unit[i]._GenBitR;
      dst->Texture.Unit[i]._GenBitQ = src->Texture.Unit[i]._GenBitQ;
      dst->Texture.Unit[i]._GenFlags = src->Texture.Unit[i]._GenFlags;
      COPY_4V(dst->Texture.Unit[i].ObjectPlaneS, src->Texture.Unit[i].ObjectPlaneS);
      COPY_4V(dst->Texture.Unit[i].ObjectPlaneT, src->Texture.Unit[i].ObjectPlaneT);
      COPY_4V(dst->Texture.Unit[i].ObjectPlaneR, src->Texture.Unit[i].ObjectPlaneR);
      COPY_4V(dst->Texture.Unit[i].ObjectPlaneQ, src->Texture.Unit[i].ObjectPlaneQ);
      COPY_4V(dst->Texture.Unit[i].EyePlaneS, src->Texture.Unit[i].EyePlaneS);
      COPY_4V(dst->Texture.Unit[i].EyePlaneT, src->Texture.Unit[i].EyePlaneT);
      COPY_4V(dst->Texture.Unit[i].EyePlaneR, src->Texture.Unit[i].EyePlaneR);
      COPY_4V(dst->Texture.Unit[i].EyePlaneQ, src->Texture.Unit[i].EyePlaneQ);
      dst->Texture.Unit[i].LodBias = src->Texture.Unit[i].LodBias;

      /* GL_EXT_texture_env_combine */
      dst->Texture.Unit[i].CombineModeRGB = src->Texture.Unit[i].CombineModeRGB;
      dst->Texture.Unit[i].CombineModeA = src->Texture.Unit[i].CombineModeA;
      COPY_3V(dst->Texture.Unit[i].CombineSourceRGB, src->Texture.Unit[i].CombineSourceRGB);
      COPY_3V(dst->Texture.Unit[i].CombineSourceA, src->Texture.Unit[i].CombineSourceA);
      COPY_3V(dst->Texture.Unit[i].CombineOperandRGB, src->Texture.Unit[i].CombineOperandRGB);
      COPY_3V(dst->Texture.Unit[i].CombineOperandA, src->Texture.Unit[i].CombineOperandA);
      dst->Texture.Unit[i].CombineScaleShiftRGB = src->Texture.Unit[i].CombineScaleShiftRGB;
      dst->Texture.Unit[i].CombineScaleShiftA = src->Texture.Unit[i].CombineScaleShiftA;

      /* texture object state */
      _mesa_copy_texture_object(dst->Texture.Unit[i].Current1D,
                                src->Texture.Unit[i].Current1D);
      _mesa_copy_texture_object(dst->Texture.Unit[i].Current2D,
                                src->Texture.Unit[i].Current2D);
      _mesa_copy_texture_object(dst->Texture.Unit[i].Current3D,
                                src->Texture.Unit[i].Current3D);
      _mesa_copy_texture_object(dst->Texture.Unit[i].CurrentCubeMap,
                                src->Texture.Unit[i].CurrentCubeMap);
      _mesa_copy_texture_object(dst->Texture.Unit[i].CurrentRect,
                                src->Texture.Unit[i].CurrentRect);
   }
}


a68 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d70 1
a70 6
#define TE_ERROR(errCode, msg, value)				\
   {								\
      char s[100];						\
      sprintf(s, msg, _mesa_lookup_enum_by_nr(value));		\
      _mesa_error(ctx, errCode, s);				\
   }
d74 28
a101 61
      case GL_TEXTURE_ENV_MODE: {
	 GLenum mode = (GLenum) (GLint) *param;

	 switch (mode) {
	 case GL_ADD:
	    if (!ctx->Extensions.EXT_texture_env_add) {
	       TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
	       return;
	    }
	    break;
	 case GL_COMBINE_EXT:
	    if (!ctx->Extensions.EXT_texture_env_combine &&
                !ctx->Extensions.ARB_texture_env_combine) {
	       TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
	       return;
	    }
	    break;
	 case GL_MODULATE:
	 case GL_BLEND:
	 case GL_DECAL:
	 case GL_REPLACE:
	    break;
	 default:
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
	    return;
	 }

	 if (texUnit->EnvMode == mode)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	 texUnit->EnvMode = mode;
	 break;
      }
      case GL_TEXTURE_ENV_COLOR: {
	 GLfloat tmp[4];
	 tmp[0] = CLAMP( param[0], 0.0F, 1.0F );
	 tmp[1] = CLAMP( param[1], 0.0F, 1.0F );
	 tmp[2] = CLAMP( param[2], 0.0F, 1.0F );
	 tmp[3] = CLAMP( param[3], 0.0F, 1.0F );
	 if (TEST_EQ_4V(tmp, texUnit->EnvColor))
	    return;
	 FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	 COPY_4FV(texUnit->EnvColor, tmp);
	 break;
      }
      case GL_COMBINE_RGB_EXT:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum mode = (GLenum) (GLint) *param;
	    switch (mode) {
	    case GL_REPLACE:
	    case GL_MODULATE:
	    case GL_ADD:
	    case GL_ADD_SIGNED_EXT:
	    case GL_INTERPOLATE_EXT:
               /* OK */
	       break;
            case GL_SUBTRACT_ARB:
               if (!ctx->Extensions.ARB_texture_env_combine) {
                  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
                  return;
d103 1
a103 355
               break;
	    case GL_DOT3_RGB_EXT:
	    case GL_DOT3_RGBA_EXT:
	       if (!ctx->Extensions.EXT_texture_env_dot3) {
                  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
		  return;
	       }
	       break;
	    case GL_DOT3_RGB_ARB:
	    case GL_DOT3_RGBA_ARB:
               if (!ctx->Extensions.ARB_texture_env_dot3) {
                  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
		  return;
	       }
	       break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
	       return;
	    }
	    if (texUnit->CombineModeRGB == mode)
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->CombineModeRGB = mode;
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
         break;
      case GL_COMBINE_ALPHA_EXT:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    const GLenum mode = (GLenum) (GLint) *param;
	    switch (mode) {
	    case GL_REPLACE:
	    case GL_MODULATE:
	    case GL_ADD:
	    case GL_ADD_SIGNED_EXT:
	    case GL_INTERPOLATE_EXT:
               /* OK */
	       break;
            case GL_SUBTRACT_ARB:
               if (!ctx->Extensions.ARB_texture_env_combine) {
                  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
                  return;
               }
               break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
	       return;
	    }
            if (texUnit->CombineModeA == mode)
               return;
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texUnit->CombineModeA = mode;
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      case GL_SOURCE0_RGB_EXT:
      case GL_SOURCE1_RGB_EXT:
      case GL_SOURCE2_RGB_EXT:
	 if (ctx->Extensions.EXT_texture_env_combine ||
	     ctx->Extensions.ARB_texture_env_combine) {
	    GLenum source = (GLenum) (GLint) *param;
	    GLuint s = pname - GL_SOURCE0_RGB_EXT;
	    switch (source) {
	    case GL_TEXTURE:
	    case GL_CONSTANT_EXT:
	    case GL_PRIMARY_COLOR_EXT:
	    case GL_PREVIOUS_EXT:
	       if (texUnit->CombineSourceRGB[s] == source)
		  return;
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->CombineSourceRGB[s] = source;
	       break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", source);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      case GL_SOURCE0_ALPHA_EXT:
      case GL_SOURCE1_ALPHA_EXT:
      case GL_SOURCE2_ALPHA_EXT:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    GLenum source = (GLenum) (GLint) *param;
	    GLuint s = pname - GL_SOURCE0_ALPHA_EXT;
	    switch (source) {
	    case GL_TEXTURE:
	    case GL_CONSTANT_EXT:
	    case GL_PRIMARY_COLOR_EXT:
	    case GL_PREVIOUS_EXT:
	       if (texUnit->CombineSourceA[s] == source) return;
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->CombineSourceA[s] = source;
	       break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", source);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      case GL_OPERAND0_RGB_EXT:
      case GL_OPERAND1_RGB_EXT:
	 if (ctx->Extensions.EXT_texture_env_combine ||
	     ctx->Extensions.ARB_texture_env_combine) {
	    GLenum operand = (GLenum) (GLint) *param;
	    GLuint s = pname - GL_OPERAND0_RGB_EXT;
	    switch (operand) {
	    case GL_SRC_COLOR:
	    case GL_ONE_MINUS_SRC_COLOR:
	    case GL_SRC_ALPHA:
	    case GL_ONE_MINUS_SRC_ALPHA:
	       if (texUnit->CombineOperandRGB[s] == operand)
		  return;
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->CombineOperandRGB[s] = operand;
	       break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", operand);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      case GL_OPERAND0_ALPHA_EXT:
      case GL_OPERAND1_ALPHA_EXT:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    GLenum operand = (GLenum) (GLint) *param;
	    switch (operand) {
	    case GL_SRC_ALPHA:
	    case GL_ONE_MINUS_SRC_ALPHA:
	       if (texUnit->CombineOperandA[pname-GL_OPERAND0_ALPHA_EXT] ==
		   operand)
		  return;
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->CombineOperandA[pname-GL_OPERAND0_ALPHA_EXT] = operand;
	       break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", operand);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      case GL_OPERAND2_RGB_EXT:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    GLenum operand = (GLenum) (GLint) *param;
	    switch (operand) {
	    case GL_SRC_COLOR:           /* ARB combine only */
	    case GL_ONE_MINUS_SRC_COLOR: /* ARB combine only */
	    case GL_SRC_ALPHA:
	    case GL_ONE_MINUS_SRC_ALPHA: /* ARB combine only */
	       if (texUnit->CombineOperandRGB[2] == operand)
		  return;
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->CombineOperandRGB[2] = operand;
	       break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", operand);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      case GL_OPERAND2_ALPHA_EXT:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    GLenum operand = (GLenum) (GLint) *param;
	    switch (operand) {
	    case GL_SRC_ALPHA:
	    case GL_ONE_MINUS_SRC_ALPHA: /* ARB combine only */
	       if (texUnit->CombineOperandA[2] == operand)
		  return;
	       FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	       texUnit->CombineOperandA[2] = operand;
	       break;
	    default:
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", operand);
	       return;
	    }
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      case GL_RGB_SCALE_EXT:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    GLuint newshift;
	    if (*param == 1.0) {
	       newshift = 0;
	    }
	    else if (*param == 2.0) {
	       newshift = 1;
	    }
	    else if (*param == 4.0) {
	       newshift = 2;
	    }
	    else {
	       _mesa_error( ctx, GL_INVALID_VALUE,
                            "glTexEnv(GL_RGB_SCALE not 1, 2 or 4)" );
	       return;
	    }
	    if (texUnit->CombineScaleShiftRGB == newshift)
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->CombineScaleShiftRGB = newshift;
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      case GL_ALPHA_SCALE:
	 if (ctx->Extensions.EXT_texture_env_combine ||
             ctx->Extensions.ARB_texture_env_combine) {
	    GLuint newshift;
	    if (*param == 1.0) {
	       newshift = 0;
	    }
	    else if (*param == 2.0) {
	       newshift = 1;
	    }
	    else if (*param == 4.0) {
	       newshift = 2;
	    }
	    else {
	       _mesa_error( ctx, GL_INVALID_VALUE,
                            "glTexEnv(GL_ALPHA_SCALE not 1, 2 or 4)" );
	       return;
	    }
	    if (texUnit->CombineScaleShiftA == newshift)
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->CombineScaleShiftA = newshift;
	 }
	 else {
            TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	    return;
	 }
	 break;
      default:
	 _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(pname)" );
	 return;
      }
   }
   else if (target==GL_TEXTURE_FILTER_CONTROL_EXT) {
      if (!ctx->Extensions.EXT_texture_lod_bias) {
	 _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(param)" );
	 return;
      }
      switch (pname) {
      case GL_TEXTURE_LOD_BIAS_EXT:
	 if (texUnit->LodBias == param[0])
	    return;
	 FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         texUnit->LodBias = CLAMP(param[0], -ctx->Const.MaxTextureLodBias,
                                  ctx->Const.MaxTextureLodBias);
	 break;
      default:
         TE_ERROR(GL_INVALID_ENUM, "glTexEnv(pname=%s)", pname);
	 return;
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(target)" );
      return;
   }

   if (MESA_VERBOSE&(VERBOSE_API|VERBOSE_TEXTURE))
      fprintf(stderr, "glTexEnv %s %s %.1f(%s) ...\n",
	      _mesa_lookup_enum_by_nr(target),
	      _mesa_lookup_enum_by_nr(pname),
	      *param,
	      _mesa_lookup_enum_by_nr((GLenum) (GLint) *param));

   /* Tell device driver about the new texture environment */
   if (ctx->Driver.TexEnv) {
      (*ctx->Driver.TexEnv)( ctx, target, pname, param );
   }
}


void
_mesa_TexEnvf( GLenum target, GLenum pname, GLfloat param )
{
   _mesa_TexEnvfv( target, pname, &param );
}



void
_mesa_TexEnvi( GLenum target, GLenum pname, GLint param )
{
   GLfloat p[4];
   p[0] = (GLfloat) param;
   p[1] = p[2] = p[3] = 0.0;
   _mesa_TexEnvfv( target, pname, p );
}


void
_mesa_TexEnviv( GLenum target, GLenum pname, const GLint *param )
{
   GLfloat p[4];
   if (pname == GL_TEXTURE_ENV_COLOR) {
      p[0] = INT_TO_FLOAT( param[0] );
      p[1] = INT_TO_FLOAT( param[1] );
      p[2] = INT_TO_FLOAT( param[2] );
      p[3] = INT_TO_FLOAT( param[3] );
   }
   else {
      p[0] = (GLfloat) param[0];
      p[1] = p[2] = p[3] = 0;  /* init to zero, just to be safe */
   }
   _mesa_TexEnvfv( target, pname, p );
}


void
_mesa_GetTexEnvfv( GLenum target, GLenum pname, GLfloat *params )
{
   GET_CURRENT_CONTEXT(ctx);
   const struct gl_texture_unit *texUnit = &ctx->Texture.Unit[ctx->Texture.CurrentUnit];
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (target == GL_TEXTURE_ENV) {
      switch (pname) {
         case GL_TEXTURE_ENV_MODE:
            *params = ENUM_TO_FLOAT(texUnit->EnvMode);
d106 4
a109 1
            COPY_4FV( params, texUnit->EnvColor );
d112 25
a136 3
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineModeRGB;
d139 2
a140 1
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
d144 17
a160 3
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineModeA;
d163 2
a164 1
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
a167 8
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineSourceRGB[0];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
a168 8
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineSourceRGB[1];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
d170 17
a186 3
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineSourceRGB[2];
d189 2
a190 1
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
a193 8
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineSourceA[0];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
a194 8
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineSourceA[1];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
d196 16
a211 3
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineSourceA[2];
d214 2
a215 1
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
a218 8
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineOperandRGB[0];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
d220 15
a234 3
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineOperandRGB[1];
d237 2
a238 10
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
            }
            break;
         case GL_OPERAND2_RGB_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineOperandRGB[2];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
d242 14
a255 3
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineOperandA[0];
d258 2
a259 1
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
d262 10
a271 4
         case GL_OPERAND1_ALPHA_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineOperandA[1];
d274 2
a275 1
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
d279 9
a287 3
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLfloat) texUnit->CombineOperandA[2];
d290 2
a291 1
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
d295 17
a311 8
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               if (texUnit->CombineScaleShiftRGB == 0)
                  *params = 1.0;
               else if (texUnit->CombineScaleShiftRGB == 1)
                  *params = 2.0;
               else
                  *params = 4.0;
d314 1
a314 1
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
d319 17
a335 8
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               if (texUnit->CombineScaleShiftA == 0)
                  *params = 1.0;
               else if (texUnit->CombineScaleShiftA == 1)
                  *params = 2.0;
               else
                  *params = 4.0;
d338 1
a338 1
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)");
d343 2
a344 1
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)" );
d347 3
a349 4
   else if (target == GL_TEXTURE_FILTER_CONTROL_EXT) {
      /* GL_EXT_texture_lod_bias */
      if (!ctx->Extensions.EXT_texture_lod_bias) {
	 _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(target)" );
d353 1
a353 1
         *params = texUnit->LodBias;
d356 1
a356 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)" );
d361 59
a419 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(target)" );
d422 39
d469 2
a470 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d473 1
a473 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(target)" );
d477 124
a600 188
   if (target == GL_TEXTURE_ENV) {
      switch (pname) {
         case GL_TEXTURE_ENV_MODE:
            *params = (GLint) texUnit->EnvMode;
            break;
         case GL_TEXTURE_ENV_COLOR:
            params[0] = FLOAT_TO_INT( texUnit->EnvColor[0] );
            params[1] = FLOAT_TO_INT( texUnit->EnvColor[1] );
            params[2] = FLOAT_TO_INT( texUnit->EnvColor[2] );
            params[3] = FLOAT_TO_INT( texUnit->EnvColor[3] );
            break;
         case GL_COMBINE_RGB_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineModeRGB;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_COMBINE_ALPHA_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineModeA;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_SOURCE0_RGB_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineSourceRGB[0];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_SOURCE1_RGB_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineSourceRGB[1];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_SOURCE2_RGB_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineSourceRGB[2];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_SOURCE0_ALPHA_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineSourceA[0];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_SOURCE1_ALPHA_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineSourceA[1];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_SOURCE2_ALPHA_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineSourceA[2];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_OPERAND0_RGB_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineOperandRGB[0];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_OPERAND1_RGB_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineOperandRGB[1];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_OPERAND2_RGB_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineOperandRGB[2];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_OPERAND0_ALPHA_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineOperandA[0];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_OPERAND1_ALPHA_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineOperandA[1];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_OPERAND2_ALPHA_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               *params = (GLint) texUnit->CombineOperandA[2];
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
            }
            break;
         case GL_RGB_SCALE_EXT:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               if (texUnit->CombineScaleShiftRGB == 0)
                  *params = 1;
               else if (texUnit->CombineScaleShiftRGB == 1)
                  *params = 2;
               else
                  *params = 4;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
               return;
            }
            break;
         case GL_ALPHA_SCALE:
            if (ctx->Extensions.EXT_texture_env_combine ||
                ctx->Extensions.ARB_texture_env_combine) {
               if (texUnit->CombineScaleShiftA == 0)
                  *params = 1;
               else if (texUnit->CombineScaleShiftA == 1)
                  *params = 2;
               else
                  *params = 4;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)");
               return;
            }
            break;
         default:
            _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)" );
      }
   }
   else if (target == GL_TEXTURE_FILTER_CONTROL_EXT) {
      /* GL_EXT_texture_lod_bias */
      if (!ctx->Extensions.EXT_texture_lod_bias) {
	 _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(target)" );
	 return;
      }
      if (pname == GL_TEXTURE_LOD_BIAS_EXT) {
         *params = (GLint) texUnit->LodBias;
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)" );
	 return;
      }
   }
   else {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(target)" );
      return;
d626 2
a627 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d631 2
a632 2
	      _mesa_lookup_enum_by_nr(target),
	      _mesa_lookup_enum_by_nr(pname),
d638 1
a638 1
         texObj = texUnit->Current1D;
d641 1
a641 1
         texObj = texUnit->Current2D;
d644 1
a644 1
         texObj = texUnit->Current3D;
d647 3
a649 10
         if (!ctx->Extensions.ARB_texture_cube_map) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(target)" );
            return;
         }
         texObj = texUnit->CurrentCubeMap;
         break;
      case GL_TEXTURE_RECTANGLE_NV:
         if (!ctx->Extensions.NV_texture_rectangle) {
            _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(target)" );
            return;
d651 1
a651 2
         texObj = texUnit->CurrentRect;
         break;
d653 1
a653 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexParameter(target)" );
d663 5
a667 10
         if (eparam==GL_NEAREST || eparam==GL_LINEAR) {
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texObj->MinFilter = eparam;
         }
         else if ((eparam==GL_NEAREST_MIPMAP_NEAREST ||
                   eparam==GL_LINEAR_MIPMAP_NEAREST ||
                   eparam==GL_NEAREST_MIPMAP_LINEAR ||
                   eparam==GL_LINEAR_MIPMAP_LINEAR) &&
                  texObj->Target != GL_TEXTURE_RECTANGLE_NV) {
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
d669 1
d672 1
a672 1
            _mesa_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
a681 1
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
d683 1
d686 1
a686 1
            _mesa_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
d693 2
a694 13
         if (eparam == GL_CLAMP || eparam == GL_CLAMP_TO_EDGE ||
             (eparam == GL_CLAMP_TO_BORDER_ARB &&
              ctx->Extensions.ARB_texture_border_clamp)) {
            /* any texture target */
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texObj->WrapS = eparam;
         }
         else if (texObj->Target != GL_TEXTURE_RECTANGLE_NV &&
                  (eparam == GL_REPEAT ||
                   (eparam == GL_MIRRORED_REPEAT_ARB &&
                    ctx->Extensions.ARB_texture_mirrored_repeat))) {
            /* non-rectangle texture */
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
d696 1
d699 1
a699 1
            _mesa_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
d706 2
a707 13
         if (eparam == GL_CLAMP || eparam == GL_CLAMP_TO_EDGE ||
             (eparam == GL_CLAMP_TO_BORDER_ARB &&
              ctx->Extensions.ARB_texture_border_clamp)) {
            /* any texture target */
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texObj->WrapT = eparam;
         }
         else if (texObj->Target != GL_TEXTURE_RECTANGLE_NV &&
                  (eparam == GL_REPEAT ||
                   (eparam == GL_MIRRORED_REPEAT_ARB &&
                    ctx->Extensions.ARB_texture_mirrored_repeat))) {
            /* non-rectangle texture */
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
d709 1
d712 1
a712 1
            _mesa_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
d719 2
a720 13
         if (eparam == GL_CLAMP || eparam == GL_CLAMP_TO_EDGE ||
             (eparam == GL_CLAMP_TO_BORDER_ARB &&
              ctx->Extensions.ARB_texture_border_clamp)) {
            /* any texture target */
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texObj->WrapR = eparam;
         }
         else if (texObj->Target != GL_TEXTURE_RECTANGLE_NV &&
                  (eparam == GL_REPEAT ||
                   (eparam == GL_MIRRORED_REPEAT_ARB &&
                    ctx->Extensions.ARB_texture_mirrored_repeat))) {
            /* non-rectangle texture */
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
d722 1
d725 1
a725 1
            _mesa_error( ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
d729 4
a732 5
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
         UNCLAMPED_FLOAT_TO_CHAN(texObj->BorderColor[0], params[0]);
         UNCLAMPED_FLOAT_TO_CHAN(texObj->BorderColor[1], params[1]);
         UNCLAMPED_FLOAT_TO_CHAN(texObj->BorderColor[2], params[2]);
         UNCLAMPED_FLOAT_TO_CHAN(texObj->BorderColor[3], params[3]);
a734 3
         if (texObj->MinLod == params[0])
            return;
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
d736 1
a738 3
         if (texObj->MaxLod == params[0])
            return;
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
d740 1
d744 1
a744 1
            _mesa_error(ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
a746 5
         if (target == GL_TEXTURE_RECTANGLE_NV && params[0] != 0.0) {
            _mesa_error(ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
            return;
         }
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
d748 1
d752 1
a752 1
            _mesa_error(ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
a754 1
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
d756 1
a759 1
         FLUSH_VERTICES(ctx, _NEW_TEXTURE);
a761 66
      case GL_TEXTURE_MAX_ANISOTROPY_EXT:
         if (ctx->Extensions.EXT_texture_filter_anisotropic) {
	    if (params[0] < 1.0) {
	       _mesa_error(ctx, GL_INVALID_VALUE, "glTexParameter(param)" );
	       return;
	    }
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texObj->MaxAnisotropy = params[0];
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_MAX_TEXTURE_ANISOTROPY_EXT)");
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texObj->CompareFlag = params[0] ? GL_TRUE : GL_FALSE;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_TEXTURE_COMPARE_SGIX)");
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            GLenum op = (GLenum) params[0];
            if (op == GL_TEXTURE_LEQUAL_R_SGIX ||
                op == GL_TEXTURE_GEQUAL_R_SGIX) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texObj->CompareOperator = op;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM, "glTexParameter(param)");
            }
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                    "glTexParameter(pname=GL_TEXTURE_COMPARE_OPERATOR_SGIX)");
            return;
         }
         break;
      case GL_SHADOW_AMBIENT_SGIX:
         if (ctx->Extensions.SGIX_shadow_ambient) {
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            UNCLAMPED_FLOAT_TO_CHAN(texObj->ShadowAmbient, params[0]);
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_SHADOW_AMBIENT_SGIX)");
            return;
         }
         break;
      case GL_GENERATE_MIPMAP_SGIS:
         if (ctx->Extensions.SGIS_generate_mipmap) {
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            texObj->GenerateMipmap = params[0] ? GL_TRUE : GL_FALSE;
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_GENERATE_MIPMAP_SGIS)");
            return;
         }
         break;
d763 1
a763 5
         {
            char s[100];
            sprintf(s, "glTexParameter(pname=0x%x)", pname);
            _mesa_error( ctx, GL_INVALID_ENUM, s);
         }
d767 1
a767 1
   texObj->Complete = GL_FALSE;
d819 1
a819 10
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
         return ctx->Extensions.ARB_texture_cube_map ? 2 : 0;
      case GL_TEXTURE_RECTANGLE_NV:
      case GL_PROXY_TEXTURE_RECTANGLE_NV:
         return ctx->Extensions.NV_texture_rectangle ? 2 : 0;
d821 1
a821 1
         _mesa_problem(ctx, "bad target in _mesa_tex_target_dimensions()");
a835 2
   GLint maxLevels;
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d837 4
a840 3
   dimensions = tex_image_dimensions(ctx, target);  /* 1, 2 or 3 */
   if (dimensions == 0) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexLevelParameter[if]v(target)");
d844 3
a846 31
   switch (target) {
   case GL_TEXTURE_1D:
   case GL_PROXY_TEXTURE_1D:
   case GL_TEXTURE_2D:
   case GL_PROXY_TEXTURE_2D:
      maxLevels = ctx->Const.MaxTextureLevels;
      break;
   case GL_TEXTURE_3D:
   case GL_PROXY_TEXTURE_3D:
      maxLevels = ctx->Const.Max3DTextureLevels;
      break;
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB:
   case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
      maxLevels = ctx->Const.MaxCubeTextureLevels;
      break;
   case GL_TEXTURE_RECTANGLE_NV:
   case GL_PROXY_TEXTURE_RECTANGLE_NV:
      maxLevels = 1;
      break;
   default:
      maxLevels = ctx->Const.MaxCubeTextureLevels;
      break;
   }

   if (level < 0 || level >= maxLevels) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glGetTexLevelParameter[if]v" );
d851 1
a851 2
   if (!img || !img->TexFormat) {
      /* undefined texture image */
d862 1
a862 2
             (target == GL_PROXY_TEXTURE_CUBE_MAP_ARB) ||
             (target == GL_PROXY_TEXTURE_RECTANGLE_NV);
d869 7
a875 1
         *params = img->Height;
d878 7
a884 1
         *params = img->Depth;
d886 1
a886 1
      case GL_TEXTURE_INTERNAL_FORMAT:
d929 1
a929 1
         else if (img->TexFormat->LuminanceBits > 0)
d932 1
a932 1
            *params = MIN2(img->TexFormat->RedBits, img->TexFormat->GreenBits);
d935 1
a935 13
         if (img->Format == GL_COLOR_INDEX)
            *params = img->TexFormat->IndexBits;
         else
            *params = 0;
         return;
      case GL_DEPTH_BITS:
         /* XXX this isn't in the GL_SGIX_depth_texture spec
          * but seems appropriate.
          */
         if (ctx->Extensions.SGIX_depth_texture)
            *params = img->TexFormat->DepthBits;
         else
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexLevelParameter[if]v(pname)");
d940 1
a940 1
         if (ctx->Extensions.ARB_texture_compression) {
d944 1
a944 1
               _mesa_error(ctx, GL_INVALID_OPERATION,
d948 1
a948 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexLevelParameter[if]v(pname)");
d952 1
a952 1
         if (ctx->Extensions.ARB_texture_compression) {
d956 1
a956 1
            _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexLevelParameter[if]v(pname)");
d961 1
a961 1
         _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexLevelParameter[if]v(pname)");
d973 2
a974 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d978 1
a978 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexParameterfv(target)");
d985 1
a985 1
	 return;
d988 1
a988 1
         return;
d991 1
a991 1
         return;
d994 1
a994 1
         return;
d997 1
a997 1
         return;
d999 5
a1003 5
         params[0] = obj->BorderColor[0] / CHAN_MAXF;
         params[1] = obj->BorderColor[1] / CHAN_MAXF;
         params[2] = obj->BorderColor[2] / CHAN_MAXF;
         params[3] = obj->BorderColor[3] / CHAN_MAXF;
         return;
d1013 1
a1013 1
         return;
d1016 1
a1016 1
         return;
d1019 1
a1019 1
         return;
d1022 1
a1022 1
         return;
d1025 1
a1025 1
         return;
a1027 30
         return;
      case GL_TEXTURE_MAX_ANISOTROPY_EXT:
         if (ctx->Extensions.EXT_texture_filter_anisotropic) {
            *params = obj->MaxAnisotropy;
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            *params = (GLfloat) obj->CompareFlag;
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            *params = (GLfloat) obj->CompareOperator;
            return;
         }
         break;
      case GL_SHADOW_AMBIENT_SGIX:
         if (ctx->Extensions.SGIX_shadow_ambient) {
            *params = CHAN_TO_FLOAT(obj->ShadowAmbient);
            return;
         }
         break;
      case GL_GENERATE_MIPMAP_SGIS:
         if (ctx->Extensions.SGIS_generate_mipmap) {
            *params = (GLfloat) obj->GenerateMipmap;
            return;
         }
d1030 1
a1030 1
         ; /* silence warnings */
a1031 2
   /* If we get here, pname was an unrecognized enum */
   _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexParameterfv(pname)" );
d1041 2
a1042 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1046 1
a1046 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetTexParameteriv(target)");
d1053 1
a1053 1
         return;
d1056 1
a1056 1
         return;
d1059 1
a1059 1
         return;
d1062 1
a1062 1
         return;
d1065 1
a1065 1
         return;
d1069 4
a1072 4
            color[0] = obj->BorderColor[0] / CHAN_MAXF;
            color[1] = obj->BorderColor[1] / CHAN_MAXF;
            color[2] = obj->BorderColor[2] / CHAN_MAXF;
            color[3] = obj->BorderColor[3] / CHAN_MAXF;
d1078 1
a1078 1
         return;
d1088 1
a1088 1
         return;
d1091 1
a1091 1
         return;
d1094 1
a1094 1
         return;
d1097 1
a1097 1
         return;
d1100 1
a1100 1
         return;
a1102 31
         return;
      case GL_TEXTURE_MAX_ANISOTROPY_EXT:
         if (ctx->Extensions.EXT_texture_filter_anisotropic) {
            *params = (GLint) obj->MaxAnisotropy;
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            *params = (GLint) obj->CompareFlag;
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
         if (ctx->Extensions.SGIX_shadow) {
            *params = (GLint) obj->CompareOperator;
            return;
         }
         break;
      case GL_SHADOW_AMBIENT_SGIX:
         if (ctx->Extensions.SGIX_shadow_ambient) {
            /* XXX range? */
            *params = (GLint) CHAN_TO_FLOAT(obj->ShadowAmbient);
            return;
         }
         break;
      case GL_GENERATE_MIPMAP_SGIS:
         if (ctx->Extensions.SGIS_generate_mipmap) {
            *params = (GLint) obj->GenerateMipmap;
            return;
         }
d1105 1
a1105 1
         ; /* silence warnings */
a1106 2
   /* If we get here, pname was an unrecognized enum */
   _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexParameteriv(pname)" );
d1121 1
a1121 1
   GLuint tUnit = ctx->Texture.CurrentUnit;
d1123 1
a1123 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1127 2
a1128 2
	      _mesa_lookup_enum_by_nr(coord),
	      _mesa_lookup_enum_by_nr(pname),
a1134 1
	    GLuint bits;
d1137 2
a1138 1
	       bits = TEXGEN_OBJ_LINEAR;
d1141 2
a1142 1
	       bits = TEXGEN_EYE_LINEAR;
d1145 2
a1146 1
	       bits = TEXGEN_REFLECTION_MAP_NV;
d1149 2
a1150 1
	       bits = TEXGEN_NORMAL_MAP_NV;
d1153 2
a1154 1
	       bits = TEXGEN_SPHERE_MAP;
d1157 1
a1157 1
	       _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
a1159 5
	    if (texUnit->GenModeS == mode)
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->GenModeS = mode;
	    texUnit->_GenBitS = bits;
a1161 3
	    if (TEST_EQ_4V(texUnit->ObjectPlaneS, params))
		return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
a1167 2
	    GLfloat tmp[4];

d1170 1
a1170 1
               _math_matrix_analyse( &ctx->ModelView );
d1172 2
a1173 5
            _mesa_transform_vector( tmp, params, ctx->ModelView.inv );
	    if (TEST_EQ_4V(texUnit->EyePlaneS, tmp))
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    COPY_4FV(texUnit->EyePlaneS, tmp);
d1176 1
a1176 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
a1182 1
	    GLuint bitt;
d1185 2
a1186 1
                  bitt = TEXGEN_OBJ_LINEAR;
d1189 2
a1190 1
                  bitt = TEXGEN_EYE_LINEAR;
d1193 2
a1194 1
                  bitt = TEXGEN_REFLECTION_MAP_NV;
d1197 2
a1198 1
                  bitt = TEXGEN_NORMAL_MAP_NV;
d1201 2
a1202 1
                  bitt = TEXGEN_SPHERE_MAP;
d1205 1
a1205 1
                  _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
a1207 5
	    if (texUnit->GenModeT == mode)
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->GenModeT = mode;
	    texUnit->_GenBitT = bitt;
a1209 3
	    if (TEST_EQ_4V(texUnit->ObjectPlaneT, params))
		return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
a1215 1
	    GLfloat tmp[4];
d1217 2
a1218 2
	    if (ctx->ModelView.flags & MAT_DIRTY_INVERSE) {
               _math_matrix_analyse( &ctx->ModelView );
d1220 2
a1221 5
            _mesa_transform_vector( tmp, params, ctx->ModelView.inv );
	    if (TEST_EQ_4V(texUnit->EyePlaneT, tmp))
		return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    COPY_4FV(texUnit->EyePlaneT, tmp);
d1224 1
a1224 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
a1230 1
	    GLuint bitr;
d1233 2
a1234 1
	       bitr = TEXGEN_OBJ_LINEAR;
d1237 2
a1238 1
	       bitr = TEXGEN_REFLECTION_MAP_NV;
d1241 2
a1242 1
	       bitr = TEXGEN_NORMAL_MAP_NV;
d1245 2
a1246 1
	       bitr = TEXGEN_EYE_LINEAR;
d1249 1
a1249 1
	       _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
a1251 5
	    if (texUnit->GenModeR == mode)
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->GenModeR = mode;
	    texUnit->_GenBitR = bitr;
a1253 3
	    if (TEST_EQ_4V(texUnit->ObjectPlaneR, params))
		return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
a1259 1
	    GLfloat tmp[4];
d1262 1
a1262 1
               _math_matrix_analyse( &ctx->ModelView );
d1264 2
a1265 5
            _mesa_transform_vector( tmp, params, ctx->ModelView.inv );
	    if (TEST_EQ_4V(texUnit->EyePlaneR, tmp))
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    COPY_4FV(texUnit->EyePlaneR, tmp);
d1268 1
a1268 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
a1274 1
	    GLuint bitq;
d1277 2
a1278 1
	       bitq = TEXGEN_OBJ_LINEAR;
d1281 2
a1282 1
	       bitq = TEXGEN_EYE_LINEAR;
d1285 1
a1285 1
	       _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(param)" );
a1287 5
	    if (texUnit->GenModeQ == mode)
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->GenModeQ = mode;
	    texUnit->_GenBitQ = bitq;
a1289 3
	    if (TEST_EQ_4V(texUnit->ObjectPlaneQ, params))
		return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
a1295 1
	    GLfloat tmp[4];
d1298 1
a1298 1
               _math_matrix_analyse( &ctx->ModelView );
d1300 2
a1301 5
            _mesa_transform_vector( tmp, params, ctx->ModelView.inv );
	    if (TEST_EQ_4V(texUnit->EyePlaneQ, tmp))
	       return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    COPY_4FV(texUnit->EyePlaneQ, tmp);
d1304 1
a1304 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(pname)" );
d1309 1
a1309 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexGenfv(coord)" );
d1313 1
a1313 2
   if (ctx->Driver.TexGen)
      ctx->Driver.TexGen( ctx, coord, pname, params );
d1321 4
a1324 4
   p[0] = (GLfloat) params[0];
   p[1] = (GLfloat) params[1];
   p[2] = (GLfloat) params[2];
   p[3] = (GLfloat) params[3];
d1341 4
a1344 4
   p[0] = (GLfloat) params[0];
   p[1] = (GLfloat) params[1];
   p[2] = (GLfloat) params[2];
   p[3] = (GLfloat) params[3];
d1368 1
a1368 1
   GLuint tUnit = ctx->Texture.CurrentUnit;
d1370 2
a1371 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1385 1
a1385 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
d1400 1
a1400 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
d1415 1
a1415 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
d1430 1
a1430 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(pname)" );
d1435 1
a1435 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGendv(coord)" );
d1446 1
a1446 1
   GLuint tUnit = ctx->Texture.CurrentUnit;
d1448 2
a1449 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1463 1
a1463 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
d1478 1
a1478 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
d1493 1
a1493 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
d1508 1
a1508 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(pname)" );
d1513 1
a1513 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGenfv(coord)" );
d1524 1
a1524 1
   GLuint tUnit = ctx->Texture.CurrentUnit;
d1526 2
a1527 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1547 1
a1547 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
d1568 1
a1568 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
d1589 1
a1589 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
d1610 1
a1610 1
	    _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(pname)" );
d1615 1
a1615 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexGeniv(coord)" );
d1626 3
a1628 2
   GLuint texUnit = target - GL_TEXTURE0_ARB;
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1632 1
a1632 1
	      _mesa_lookup_enum_by_nr(target));
d1634 7
a1640 4
   /* Cater for texture unit 0 is first, therefore use >= */
   if (texUnit >= ctx->Const.MaxTextureUnits) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glActiveTextureARB(target)");
      return;
d1642 2
a1643 5

   FLUSH_VERTICES(ctx, _NEW_TEXTURE);
   ctx->Texture.CurrentUnit = texUnit;
   if (ctx->Driver.ActiveTexture) {
      (*ctx->Driver.ActiveTexture)( ctx, (GLuint) texUnit );
d1653 3
a1655 2
   GLuint texUnit = target - GL_TEXTURE0_ARB;
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d1657 3
a1659 3
   if (texUnit > ctx->Const.MaxTextureUnits) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glClientActiveTextureARB(target)");
      return;
d1661 2
a1662 38

   FLUSH_VERTICES(ctx, _NEW_ARRAY);
   ctx->Array.ActiveTexture = texUnit;
}



/**********************************************************************/
/*                     Pixel Texgen Extensions                        */
/**********************************************************************/

void
_mesa_PixelTexGenSGIX(GLenum mode)
{
   GLenum newRgbSource, newAlphaSource;
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   switch (mode) {
      case GL_NONE:
         newRgbSource = GL_PIXEL_GROUP_COLOR_SGIS;
         newAlphaSource = GL_PIXEL_GROUP_COLOR_SGIS;
         break;
      case GL_ALPHA:
         newRgbSource = GL_PIXEL_GROUP_COLOR_SGIS;
         newAlphaSource = GL_CURRENT_RASTER_COLOR;
         break;
      case GL_RGB:
         newRgbSource = GL_CURRENT_RASTER_COLOR;
         newAlphaSource = GL_PIXEL_GROUP_COLOR_SGIS;
         break;
      case GL_RGBA:
         newRgbSource = GL_CURRENT_RASTER_COLOR;
         newAlphaSource = GL_CURRENT_RASTER_COLOR;
         break;
      default:
         _mesa_error(ctx, GL_INVALID_ENUM, "glPixelTexGenSGIX(mode)");
         return;
a1663 8

   if (newRgbSource == ctx->Pixel.FragmentRgbSource &&
       newAlphaSource == ctx->Pixel.FragmentAlphaSource)
      return;

   FLUSH_VERTICES(ctx, _NEW_PIXEL);
   ctx->Pixel.FragmentRgbSource = newRgbSource;
   ctx->Pixel.FragmentAlphaSource = newAlphaSource;
a1666 5
void
_mesa_PixelTexGenParameterfSGIS(GLenum target, GLfloat value)
{
   _mesa_PixelTexGenParameteriSGIS(target, (GLint) value);
}
d1668 6
a1673 10

void
_mesa_PixelTexGenParameterfvSGIS(GLenum target, const GLfloat *value)
{
   _mesa_PixelTexGenParameteriSGIS(target, (GLint) *value);
}


void
_mesa_PixelTexGenParameteriSGIS(GLenum target, GLint value)
d1675 10
a1684 6
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (value != GL_CURRENT_RASTER_COLOR && value != GL_PIXEL_GROUP_COLOR_SGIS) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glPixelTexGenParameterSGIS(value)");
      return;
d1686 11
a1696 17

   switch (target) {
   case GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS:
      if (ctx->Pixel.FragmentRgbSource == (GLenum) value)
	 return;
      FLUSH_VERTICES(ctx, _NEW_PIXEL);
      ctx->Pixel.FragmentRgbSource = (GLenum) value;
      break;
   case GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS:
      if (ctx->Pixel.FragmentAlphaSource == (GLenum) value)
	 return;
      FLUSH_VERTICES(ctx, _NEW_PIXEL);
      ctx->Pixel.FragmentAlphaSource = (GLenum) value;
      break;
   default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glPixelTexGenParameterSGIS(target)");
      return;
d1698 1
d1702 5
a1706 2
void
_mesa_PixelTexGenParameterivSGIS(GLenum target, const GLint *value)
d1708 14
a1721 18
  _mesa_PixelTexGenParameteriSGIS(target, *value);
}


void
_mesa_GetPixelTexGenParameterfvSGIS(GLenum target, GLfloat *value)
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (target == GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS) {
      *value = (GLfloat) ctx->Pixel.FragmentRgbSource;
   }
   else if (target == GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS) {
      *value = (GLfloat) ctx->Pixel.FragmentAlphaSource;
   }
   else {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetPixelTexGenParameterfvSGIS(target)");
d1726 5
a1730 2
void
_mesa_GetPixelTexGenParameterivSGIS(GLenum target, GLint *value)
d1732 7
a1738 11
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END(ctx);

   if (target == GL_PIXEL_FRAGMENT_RGB_SOURCE_SGIS) {
      *value = (GLint) ctx->Pixel.FragmentRgbSource;
   }
   else if (target == GL_PIXEL_FRAGMENT_ALPHA_SOURCE_SGIS) {
      *value = (GLint) ctx->Pixel.FragmentAlphaSource;
   }
   else {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetPixelTexGenParameterivSGIS(target)");
d1740 1
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d1 1
d4 1
a4 1
 * Version:  5.0.2
d6 1
a6 1
 * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
d27 3
d42 1
a121 29
/*
 * For debugging
 */
void
_mesa_print_texunit_state( GLcontext *ctx, GLuint unit )
{
   const struct gl_texture_unit *texUnit = ctx->Texture.Unit + unit;
   _mesa_printf("Texture Unit %d\n", unit);
   _mesa_printf("  GL_TEXTURE_ENV_MODE = %s\n", _mesa_lookup_enum_by_nr(texUnit->EnvMode));
   _mesa_printf("  GL_COMBINE_RGB = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineModeRGB));
   _mesa_printf("  GL_COMBINE_ALPHA = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineModeA));
   _mesa_printf("  GL_SOURCE0_RGB = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineSourceRGB[0]));
   _mesa_printf("  GL_SOURCE1_RGB = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineSourceRGB[1]));
   _mesa_printf("  GL_SOURCE2_RGB = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineSourceRGB[2]));
   _mesa_printf("  GL_SOURCE0_ALPHA = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineSourceA[0]));
   _mesa_printf("  GL_SOURCE1_ALPHA = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineSourceA[1]));
   _mesa_printf("  GL_SOURCE2_ALPHA = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineSourceA[2]));
   _mesa_printf("  GL_OPERAND0_RGB = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineOperandRGB[0]));
   _mesa_printf("  GL_OPERAND1_RGB = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineOperandRGB[1]));
   _mesa_printf("  GL_OPERAND2_RGB = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineOperandRGB[2]));
   _mesa_printf("  GL_OPERAND0_ALPHA = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineOperandA[0]));
   _mesa_printf("  GL_OPERAND1_ALPHA = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineOperandA[1]));
   _mesa_printf("  GL_OPERAND2_ALPHA = %s\n", _mesa_lookup_enum_by_nr(texUnit->CombineOperandA[2]));
   _mesa_printf("  GL_RGB_SCALE = %d\n", 1 << texUnit->CombineScaleShiftRGB);
   _mesa_printf("  GL_ALPHA_SCALE = %d\n", 1 << texUnit->CombineScaleShiftA);
   _mesa_printf("  GL_TEXTURE_ENV_COLOR = (%f, %f, %f, %f)\n", texUnit->EnvColor[0], texUnit->EnvColor[1], texUnit->EnvColor[2], texUnit->EnvColor[3]);
}


d136 5
a140 1
   _mesa_error(ctx, errCode, msg, _mesa_lookup_enum_by_nr(value));
d142 1
a142 1
   if (target == GL_TEXTURE_ENV) {
d144 46
a189 37
      case GL_TEXTURE_ENV_MODE:
         {
            const GLenum mode = (GLenum) (GLint) *param;
            if (mode == GL_MODULATE ||
                mode == GL_BLEND ||
                mode == GL_DECAL ||
                mode == GL_REPLACE ||
                (mode == GL_ADD && ctx->Extensions.EXT_texture_env_add) ||
                (mode == GL_COMBINE &&
                 (ctx->Extensions.EXT_texture_env_combine ||
                  ctx->Extensions.ARB_texture_env_combine))) {
               /* legal */
               if (texUnit->EnvMode == mode)
                  return;
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texUnit->EnvMode = mode;
            }
            else {
               TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
               return;
            }
         }
         break;
      case GL_TEXTURE_ENV_COLOR:
         {
            GLfloat tmp[4];
            tmp[0] = CLAMP( param[0], 0.0F, 1.0F );
            tmp[1] = CLAMP( param[1], 0.0F, 1.0F );
            tmp[2] = CLAMP( param[2], 0.0F, 1.0F );
            tmp[3] = CLAMP( param[3], 0.0F, 1.0F );
            if (TEST_EQ_4V(tmp, texUnit->EnvColor))
               return;
            FLUSH_VERTICES(ctx, _NEW_TEXTURE);
            COPY_4FV(texUnit->EnvColor, tmp);
         }
         break;
      case GL_COMBINE_RGB:
d197 2
a198 2
	    case GL_ADD_SIGNED:
	    case GL_INTERPOLATE:
d201 1
a201 1
            case GL_SUBTRACT:
d214 3
a216 11
	    case GL_DOT3_RGB:
	    case GL_DOT3_RGBA:
	       if (!ctx->Extensions.ARB_texture_env_dot3) {
                  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
		  return;
	       }
	       break;
	    case GL_MODULATE_ADD_ATI:
	    case GL_MODULATE_SIGNED_ADD_ATI:
	    case GL_MODULATE_SUBTRACT_ATI:
	       if (!ctx->Extensions.ATI_texture_env_combine3) {
d235 1
a235 1
      case GL_COMBINE_ALPHA:
d239 1
a239 1
            switch (mode) {
d243 3
a245 9
	    case GL_ADD_SIGNED:
	    case GL_INTERPOLATE:
	       /* OK */
	       break;
	    case GL_SUBTRACT:
	       if (!ctx->Extensions.ARB_texture_env_combine) {
		  TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
		  return;
	       }
d247 2
a248 4
	    case GL_MODULATE_ADD_ATI:
	    case GL_MODULATE_SIGNED_ADD_ATI:
	    case GL_MODULATE_SUBTRACT_ATI:
	       if (!ctx->Extensions.ATI_texture_env_combine3) {
d250 3
a252 3
		  return;
	       }
	       break;
d254 1
a254 1
	       TE_ERROR(GL_INVALID_ENUM, "glTexEnv(param=%s)", mode);
d257 4
a260 5

	    if (texUnit->CombineModeA == mode)
		return;
	    FLUSH_VERTICES(ctx, _NEW_TEXTURE);
	    texUnit->CombineModeA = mode;
d267 3
a269 3
      case GL_SOURCE0_RGB:
      case GL_SOURCE1_RGB:
      case GL_SOURCE2_RGB:
d272 9
a280 14
	    const GLenum source = (GLenum) (GLint) *param;
	    const GLuint s = pname - GL_SOURCE0_RGB;
            if (source == GL_TEXTURE ||
                source == GL_CONSTANT ||
                source == GL_PRIMARY_COLOR ||
                source == GL_PREVIOUS ||
                (ctx->Extensions.ARB_texture_env_crossbar &&
                 source >= GL_TEXTURE0 &&
                 source < GL_TEXTURE0 + ctx->Const.MaxTextureUnits) ||
                (ctx->Extensions.ATI_texture_env_combine3 &&
                 (source == GL_ZERO || source == GL_ONE))) {
               /* legal */
               if (texUnit->CombineSourceRGB[s] == source)
                  return;
d283 2
a284 2
            }
            else {
d294 3
a296 3
      case GL_SOURCE0_ALPHA:
      case GL_SOURCE1_ALPHA:
      case GL_SOURCE2_ALPHA:
d299 8
a306 14
	    const GLenum source = (GLenum) (GLint) *param;
	    const GLuint s = pname - GL_SOURCE0_ALPHA;
            if (source == GL_TEXTURE ||
                source == GL_CONSTANT ||
                source == GL_PRIMARY_COLOR ||
                source == GL_PREVIOUS ||
                (ctx->Extensions.ARB_texture_env_crossbar &&
                 source >= GL_TEXTURE0 &&
                 source < GL_TEXTURE0 + ctx->Const.MaxTextureUnits) ||
		(ctx->Extensions.ATI_texture_env_combine3 &&
                 (source == GL_ZERO || source == GL_ONE))) {
               /* legal */
	       if (texUnit->CombineSourceA[s] == source)
                  return;
d309 2
a310 2
            }
            else {
d320 2
a321 3
      case GL_OPERAND0_RGB:
      case GL_OPERAND1_RGB:
      case GL_OPERAND2_RGB:
d324 2
a325 2
	    const GLenum operand = (GLenum) (GLint) *param;
	    const GLuint s = pname - GL_OPERAND0_RGB;
d346 2
a347 3
      case GL_OPERAND0_ALPHA:
      case GL_OPERAND1_ALPHA:
      case GL_OPERAND2_ALPHA:
d350 1
a350 1
	    const GLenum operand = (GLenum) (GLint) *param;
d354 1
a354 1
	       if (texUnit->CombineOperandA[pname-GL_OPERAND0_ALPHA] ==
d358 25
a382 1
	       texUnit->CombineOperandA[pname-GL_OPERAND0_ALPHA] = operand;
d394 23
a416 1
      case GL_RGB_SCALE:
d477 1
a477 2
   else if (target == GL_TEXTURE_FILTER_CONTROL_EXT) {
      /* GL_EXT_texture_lod_bias */
d479 1
a479 1
	 _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(target=0x%x)", target );
d482 2
a483 1
      if (pname == GL_TEXTURE_LOD_BIAS_EXT) {
d487 4
a490 3
         texUnit->LodBias = param[0];
      }
      else {
a494 28
   else if (target == GL_POINT_SPRITE_NV) {
      /* GL_NV_point_sprite */
      if (!ctx->Extensions.NV_point_sprite) {
	 _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(target=0x%x)", target );
	 return;
      }
      if (pname == GL_COORD_REPLACE_NV) {
         const GLenum value = (GLenum) param[0];
         if (value == GL_TRUE || value == GL_FALSE) {
            /* It's kind of weird to set point state via glTexEnv,
             * but that's what the spec calls for.
             */
            const GLboolean state = (GLboolean) value;
            if (ctx->Point.CoordReplace[ctx->Texture.CurrentUnit] == state)
               return;
            FLUSH_VERTICES(ctx, _NEW_POINT);
            ctx->Point.CoordReplace[ctx->Texture.CurrentUnit] = state;
         }
         else {
            _mesa_error( ctx, GL_INVALID_VALUE, "glTexEnv(param=0x%x)", value);
            return;
         }
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(pname=0x%x)", pname );
         return;
      }
   }
d496 1
a496 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glTexEnv(target=0x%x)",target );
d501 5
a505 5
      _mesa_debug(ctx, "glTexEnv %s %s %.1f(%s) ...\n",
                  _mesa_lookup_enum_by_nr(target),
                  _mesa_lookup_enum_by_nr(pname),
                  *param,
                  _mesa_lookup_enum_by_nr((GLenum) (GLint) *param));
d565 1
a565 1
         case GL_COMBINE_RGB:
d574 1
a574 1
         case GL_COMBINE_ALPHA:
d583 1
a583 1
         case GL_SOURCE0_RGB:
d592 1
a592 1
         case GL_SOURCE1_RGB:
d601 1
a601 1
         case GL_SOURCE2_RGB:
d610 1
a610 1
         case GL_SOURCE0_ALPHA:
d619 1
a619 1
         case GL_SOURCE1_ALPHA:
d628 1
a628 1
         case GL_SOURCE2_ALPHA:
d637 1
a637 1
         case GL_OPERAND0_RGB:
d646 1
a646 1
         case GL_OPERAND1_RGB:
d655 1
a655 1
         case GL_OPERAND2_RGB:
d664 1
a664 1
         case GL_OPERAND0_ALPHA:
d673 1
a673 1
         case GL_OPERAND1_ALPHA:
d682 1
a682 1
         case GL_OPERAND2_ALPHA:
d691 1
a691 1
         case GL_RGB_SCALE:
a738 14
   else if (target == GL_POINT_SPRITE_NV) {
      /* GL_NV_point_sprite */
      if (!ctx->Extensions.NV_point_sprite) {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(target)" );
         return;
      }
      if (pname == GL_COORD_REPLACE_NV) {
         *params = (GLfloat) ctx->Point.CoordReplace[ctx->Texture.CurrentUnit];
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnvfv(pname)" );
         return;
      }
   }
d753 5
d769 1
a769 1
         case GL_COMBINE_RGB:
d778 1
a778 1
         case GL_COMBINE_ALPHA:
d787 1
a787 1
         case GL_SOURCE0_RGB:
d796 1
a796 1
         case GL_SOURCE1_RGB:
d805 1
a805 1
         case GL_SOURCE2_RGB:
d814 1
a814 1
         case GL_SOURCE0_ALPHA:
d823 1
a823 1
         case GL_SOURCE1_ALPHA:
d832 1
a832 1
         case GL_SOURCE2_ALPHA:
d841 1
a841 1
         case GL_OPERAND0_RGB:
d850 1
a850 1
         case GL_OPERAND1_RGB:
d859 1
a859 1
         case GL_OPERAND2_RGB:
d868 1
a868 1
         case GL_OPERAND0_ALPHA:
d877 1
a877 1
         case GL_OPERAND1_ALPHA:
d886 1
a886 1
         case GL_OPERAND2_ALPHA:
d895 1
a895 1
         case GL_RGB_SCALE:
a942 14
   else if (target == GL_POINT_SPRITE_NV) {
      /* GL_NV_point_sprite */
      if (!ctx->Extensions.NV_point_sprite) {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(target)" );
         return;
      }
      if (pname == GL_COORD_REPLACE_NV) {
         *params = (GLint) ctx->Point.CoordReplace[ctx->Texture.CurrentUnit];
      }
      else {
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(pname)" );
         return;
      }
   }
d944 1
a944 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetTexEnviv(target)" );
d974 4
a977 5
      _mesa_debug(ctx, "glTexParameter %s %s %.1f(%s)...\n",
                  _mesa_lookup_enum_by_nr(target),
                  _mesa_lookup_enum_by_nr(pname),
                  *params,
		  _mesa_lookup_enum_by_nr(eparam));
d987 1
a987 1
      case GL_TEXTURE_3D:
d990 1
a990 1
      case GL_TEXTURE_CUBE_MAP:
d1014 1
d1050 1
a1050 1
             (eparam == GL_CLAMP_TO_BORDER &&
d1058 2
a1059 6
                   (eparam == GL_MIRRORED_REPEAT &&
                    ctx->Extensions.ARB_texture_mirrored_repeat) ||
                   (eparam == GL_MIRROR_CLAMP_ATI &&
                    ctx->Extensions.ATI_texture_mirror_once) ||
                   (eparam == GL_MIRROR_CLAMP_TO_EDGE_ATI &&
                    ctx->Extensions.ATI_texture_mirror_once))) {
d1073 1
a1073 1
             (eparam == GL_CLAMP_TO_BORDER &&
d1081 2
a1082 6
                   (eparam == GL_MIRRORED_REPEAT &&
                    ctx->Extensions.ARB_texture_mirrored_repeat) ||
                   (eparam == GL_MIRROR_CLAMP_ATI &&
                    ctx->Extensions.ATI_texture_mirror_once) ||
                   (eparam == GL_MIRROR_CLAMP_TO_EDGE_ATI &&
                    ctx->Extensions.ATI_texture_mirror_once))) {
d1092 1
a1092 1
      case GL_TEXTURE_WRAP_R:
d1096 1
a1096 1
             (eparam == GL_CLAMP_TO_BORDER &&
d1104 2
a1105 6
                   (eparam == GL_MIRRORED_REPEAT &&
                    ctx->Extensions.ARB_texture_mirrored_repeat) ||
                   (eparam == GL_MIRROR_CLAMP_ATI &&
                    ctx->Extensions.ATI_texture_mirror_once) ||
                   (eparam == GL_MIRROR_CLAMP_TO_EDGE_ATI &&
                    ctx->Extensions.ATI_texture_mirror_once))) {
d1116 4
a1119 8
         texObj->BorderColor[RCOMP] = params[0];
         texObj->BorderColor[GCOMP] = params[1];
         texObj->BorderColor[BCOMP] = params[2];
         texObj->BorderColor[ACOMP] = params[3];
         UNCLAMPED_FLOAT_TO_CHAN(texObj->_BorderChan[RCOMP], params[0]);
         UNCLAMPED_FLOAT_TO_CHAN(texObj->_BorderChan[GCOMP], params[1]);
         UNCLAMPED_FLOAT_TO_CHAN(texObj->_BorderChan[BCOMP], params[2]);
         UNCLAMPED_FLOAT_TO_CHAN(texObj->_BorderChan[ACOMP], params[3]);
d1154 1
d1169 1
a1169 1
                        "glTexParameter(pname=GL_TEXTURE_MAX_ANISOTROPY_EXT)");
d1202 1
a1202 1
      case GL_SHADOW_AMBIENT_SGIX: /* aka GL_TEXTURE_COMPARE_FAIL_VALUE_ARB */
d1205 1
a1205 1
            texObj->ShadowAmbient = CLAMP(params[0], 0.0F, 1.0F);
d1215 1
d1224 5
a1228 75
      case GL_TEXTURE_COMPARE_MODE_ARB:
         if (ctx->Extensions.ARB_shadow) {
            const GLenum mode = (GLenum) params[0];
            if (mode == GL_NONE || mode == GL_COMPARE_R_TO_TEXTURE_ARB) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texObj->CompareMode = mode;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM,
                           "glTexParameter(bad GL_TEXTURE_COMPARE_MODE_ARB: 0x%x)", mode);
               return;
            }
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_TEXTURE_COMPARE_MODE_ARB)");
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_FUNC_ARB:
         if (ctx->Extensions.ARB_shadow) {
            const GLenum func = (GLenum) params[0];
            if (func == GL_LEQUAL || func == GL_GEQUAL) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texObj->CompareFunc = func;
            }
            else if (ctx->Extensions.EXT_shadow_funcs &&
                     (func == GL_EQUAL ||
                      func == GL_NOTEQUAL ||
                      func == GL_LESS ||
                      func == GL_GREATER ||
                      func == GL_ALWAYS ||
                      func == GL_NEVER)) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texObj->CompareFunc = func;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM,
                           "glTexParameter(bad GL_TEXTURE_COMPARE_FUNC_ARB)");
               return;
            }
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_TEXTURE_COMPARE_FUNC_ARB)");
            return;
         }
         break;
      case GL_DEPTH_TEXTURE_MODE_ARB:
         if (ctx->Extensions.ARB_depth_texture) {
            const GLenum result = (GLenum) params[0];
            if (result == GL_LUMINANCE || result == GL_INTENSITY
                || result == GL_ALPHA) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texObj->DepthMode = result;
            }
            else {
               _mesa_error(ctx, GL_INVALID_ENUM,
                          "glTexParameter(bad GL_DEPTH_TEXTURE_MODE_ARB)");
               return;
            }
         }
         else {
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glTexParameter(pname=GL_DEPTH_TEXTURE_MODE_ARB)");
            return;
         }
         break;
      case GL_TEXTURE_LOD_BIAS:
         /* NOTE: this is really part of OpenGL 1.4, not EXT_texture_lod_bias*/
         if (ctx->Extensions.EXT_texture_lod_bias) {
            if (texObj->LodBias != params[0]) {
               FLUSH_VERTICES(ctx, _NEW_TEXTURE);
               texObj->LodBias = params[0];
            }
a1229 5
         break;

      default:
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glTexParameter(pname=0x%x)", pname);
d1245 1
a1245 4
   if (pname == GL_TEXTURE_PRIORITY)
      fparam[0] = INT_TO_FLOAT(param);
   else
      fparam[0] = (GLfloat) param;
a1249 1

d1254 2
a1255 13
   if (pname == GL_TEXTURE_BORDER_COLOR) {
      fparam[0] = INT_TO_FLOAT(params[0]);
      fparam[1] = INT_TO_FLOAT(params[1]);
      fparam[2] = INT_TO_FLOAT(params[2]);
      fparam[3] = INT_TO_FLOAT(params[3]);
   }
   else {
      if (pname == GL_TEXTURE_PRIORITY)
         fparam[0] = INT_TO_FLOAT(params[0]);
      else
         fparam[0] = (GLfloat) params[0];
      fparam[1] = fparam[2] = fparam[3] = 0.0F;
   }
d1283 8
a1290 8
      case GL_TEXTURE_CUBE_MAP:
      case GL_PROXY_TEXTURE_CUBE_MAP:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
      case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
      case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
a1313 1
   /* this will catch bad target values */
d1331 7
a1337 7
   case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
   case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
   case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
   case GL_PROXY_TEXTURE_CUBE_MAP:
d1345 2
a1346 2
      _mesa_problem(ctx, "switch in _mesa_GetTexLevelParameter");
      return;
d1367 1
a1367 1
             (target == GL_PROXY_TEXTURE_CUBE_MAP) ||
d1441 1
a1441 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d1445 1
a1445 1
      case GL_TEXTURE_COMPRESSED_IMAGE_SIZE:
d1451 1
a1451 1
                           "glGetTexLevelParameter[if]v(pname)");
d1454 1
a1454 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d1457 1
a1457 1
      case GL_TEXTURE_COMPRESSED:
d1462 1
a1462 2
            _mesa_error(ctx, GL_INVALID_ENUM,
                        "glGetTexLevelParameter[if]v(pname)");
d1467 1
a1467 2
         _mesa_error(ctx, GL_INVALID_ENUM,
                     "glGetTexLevelParameter[if]v(pname)");
d1500 1
a1500 1
      case GL_TEXTURE_WRAP_R:
d1504 4
a1507 4
         params[0] = CLAMP(obj->BorderColor[0], 0.0F, 1.0F);
         params[1] = CLAMP(obj->BorderColor[1], 0.0F, 1.0F);
         params[2] = CLAMP(obj->BorderColor[2], 0.0F, 1.0F);
         params[3] = CLAMP(obj->BorderColor[3], 0.0F, 1.0F);
a1533 6
      case GL_TEXTURE_LOD_BIAS:
         if (ctx->Extensions.EXT_texture_lod_bias) {
            *params = obj->LodBias;
            break;
         }
         break;
d1552 1
a1552 1
      case GL_SHADOW_AMBIENT_SGIX: /* aka GL_TEXTURE_COMPARE_FAIL_VALUE_ARB */
d1554 1
a1554 1
            *params = obj->ShadowAmbient;
a1563 18
      case GL_TEXTURE_COMPARE_MODE_ARB:
         if (ctx->Extensions.ARB_shadow) {
            *params = (GLfloat) obj->CompareMode;
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_FUNC_ARB:
         if (ctx->Extensions.ARB_shadow) {
            *params = (GLfloat) obj->CompareFunc;
            return;
         }
         break;
      case GL_DEPTH_TEXTURE_MODE_ARB:
         if (ctx->Extensions.ARB_depth_texture) {
            *params = (GLfloat) obj->DepthMode;
            return;
         }
         break;
d1599 1
a1599 1
      case GL_TEXTURE_WRAP_R:
d1604 9
a1612 9
            GLfloat b[4];
            b[0] = CLAMP(obj->BorderColor[0], 0.0F, 1.0F);
            b[1] = CLAMP(obj->BorderColor[1], 0.0F, 1.0F);
            b[2] = CLAMP(obj->BorderColor[2], 0.0F, 1.0F);
            b[3] = CLAMP(obj->BorderColor[3], 0.0F, 1.0F);
            params[0] = FLOAT_TO_INT(b[0]);
            params[1] = FLOAT_TO_INT(b[1]);
            params[2] = FLOAT_TO_INT(b[2]);
            params[3] = FLOAT_TO_INT(b[3]);
d1626 1
a1626 1
         *params = FLOAT_TO_INT(obj->Priority);
a1639 6
      case GL_TEXTURE_LOD_BIAS:
         if (ctx->Extensions.EXT_texture_lod_bias) {
            *params = (GLint) obj->LodBias;
            break;
         }
         break;
d1658 1
a1658 1
      case GL_SHADOW_AMBIENT_SGIX: /* aka GL_TEXTURE_COMPARE_FAIL_VALUE_ARB */
d1660 2
a1661 1
            *params = (GLint) FLOAT_TO_INT(obj->ShadowAmbient);
a1670 18
      case GL_TEXTURE_COMPARE_MODE_ARB:
         if (ctx->Extensions.ARB_shadow) {
            *params = (GLint) obj->CompareMode;
            return;
         }
         break;
      case GL_TEXTURE_COMPARE_FUNC_ARB:
         if (ctx->Extensions.ARB_shadow) {
            *params = (GLint) obj->CompareFunc;
            return;
         }
         break;
      case GL_DEPTH_TEXTURE_MODE_ARB:
         if (ctx->Extensions.ARB_depth_texture) {
            *params = (GLint) obj->DepthMode;
            return;
         }
         break;
d1695 4
a1698 5
      _mesa_debug(ctx, "glTexGen %s %s %.1f(%s)...\n",
                  _mesa_lookup_enum_by_nr(coord),
                  _mesa_lookup_enum_by_nr(pname),
                  *params,
		  _mesa_lookup_enum_by_nr((GLenum) (GLint) *params));
d1744 2
a1745 2
            if (ctx->ModelviewMatrixStack.Top->flags & MAT_DIRTY_INVERSE) {
               _math_matrix_analyse( ctx->ModelviewMatrixStack.Top );
d1747 1
a1747 1
            _mesa_transform_vector( tmp, params, ctx->ModelviewMatrixStack.Top->inv );
d1800 2
a1801 2
	    if (ctx->ModelviewMatrixStack.Top->flags & MAT_DIRTY_INVERSE) {
               _math_matrix_analyse( ctx->ModelviewMatrixStack.Top );
d1803 1
a1803 1
            _mesa_transform_vector( tmp, params, ctx->ModelviewMatrixStack.Top->inv );
d1853 2
a1854 2
            if (ctx->ModelviewMatrixStack.Top->flags & MAT_DIRTY_INVERSE) {
               _math_matrix_analyse( ctx->ModelviewMatrixStack.Top );
d1856 1
a1856 1
            _mesa_transform_vector( tmp, params, ctx->ModelviewMatrixStack.Top->inv );
d1900 2
a1901 2
            if (ctx->ModelviewMatrixStack.Top->flags & MAT_DIRTY_INVERSE) {
               _math_matrix_analyse( ctx->ModelviewMatrixStack.Top );
d1903 1
a1903 1
            _mesa_transform_vector( tmp, params, ctx->ModelviewMatrixStack.Top->inv );
d1929 3
a1931 8
   if (pname == GL_TEXTURE_GEN_MODE) {
      p[1] = p[2] = p[3] = 0.0F;
   }
   else {
      p[1] = (GLfloat) params[1];
      p[2] = (GLfloat) params[2];
      p[3] = (GLfloat) params[3];
   }
d1949 3
a1951 8
   if (pname == GL_TEXTURE_GEN_MODE) {
      p[1] = p[2] = p[3] = 0.0F;
   }
   else {
      p[1] = (GLfloat) params[1];
      p[2] = (GLfloat) params[2];
      p[3] = (GLfloat) params[3];
   }
d2230 1
a2230 1
   GLuint texUnit = target - GL_TEXTURE0;
d2234 2
a2235 2
      _mesa_debug(ctx, "glActiveTexture %s\n",
                  _mesa_lookup_enum_by_nr(target));
d2239 1
a2239 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glActiveTexture(target)");
a2243 1

a2244 5
   if (ctx->Transform.MatrixMode == GL_TEXTURE) {
      /* update current stack pointer */
      ctx->CurrentStack = &ctx->TextureMatrixStack[texUnit];
   }

d2256 1
a2256 1
   GLuint texUnit = target - GL_TEXTURE0;
d2260 1
a2260 1
      _mesa_error(ctx, GL_INVALID_ENUM, "glClientActiveTexture(target)");
@


