head	1.2;
branch	1.1.1;
access;
symbols
	tg-mergetmp-2:1.1.1.3
	cvs-200410241530:1.1.1.3
	cvs-200410012000:1.1.1.3
	cvs-200407141120:1.1.1.3
	cvs-200406231010:1.1.1.3
	MIRBSD_7quater:1.1.1.2
	cvs-200405271510:1.1.1.3
	XFree86_4_4_0:1.1.9.1
	cvs-200403021700:1.1.1.3
	XFREE86_20040213:1.1.9.1
	xc:1.1.9
	cvs-200401291925:1.1.1.2
	MIRBSD_7_ALPHA:1.1.1.2.0.4
	MIRBSD_7:1.1.1.2.0.2
	MIRBSD_7ter:1.1.1.2
	cvs-20011091815:1.1.1.2
	cvs-200309162130:1.1.1.2
	cvs-200308302005:1.1.1.2
	ctmx-0387:1.1.1.2
	ctmx-0384:1.1.1.2
	MIRBSD_5:1.1.1.2
	ctmx-0375:1.1.1.2
	ctmx-0373:1.1.1.2
	ctm-0371:1.1.1.2
	ctm-0370:1.1.1.2
	MIRBSD_4:1.1.1.2
	ctm-0363:1.1.1.2
	ctm-0359:1.1.1.2
	ctm-0349:1.1.1.1
	openbsd:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2003.05.16.16.28.18;	author tg;	state dead;
branches;
next	1.1;

1.1
date	2003.03.22.20.00.59;	author tg;	state Exp;
branches
	1.1.1.1
	1.1.9.1;
next	;

1.1.1.1
date	2003.03.22.20.00.59;	author tg;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.04.08.18.20.02;	author tg;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.03.02.17.28.52;	author tg;	state Stab;
branches;
next	;

1.1.9.1
date	2004.02.14.19.04.44;	author tg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove a bunch of files not used in MirBSD - clean tree. People who want them got cvs.
@
text
@
/*
 * Mesa 3-D graphics library
 * Version:  3.3
 * 
 * Copyright (C) 1999-2000  Brian Paul   All Rights Reserved.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */


#ifdef PC_HEADER
#include "all.h"
#else
#include "glheader.h"
#include "context.h"
#include "enums.h"
#include "light.h"
#include "macros.h"
#include "matrix.h"
#include "mem.h"
#include "mmath.h"
#include "simple_list.h"
#include "types.h"
#include "vb.h"
#include "xform.h"
#endif


/* XXX this is a bit of a hack needed for compilation within XFree86 */
#ifndef FLT_MIN
#define FLT_MIN 1e-37
#endif


void
_mesa_ShadeModel( GLenum mode )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glShadeModel");

   if (MESA_VERBOSE & VERBOSE_API)
      fprintf(stderr, "glShadeModel %s\n", gl_lookup_enum_by_nr(mode));

   if (mode == GL_FLAT || mode == GL_SMOOTH) {
      if (ctx->Light.ShadeModel != mode) {
         ctx->Light.ShadeModel = mode;
         if (ctx->Light.ShadeModel == GL_FLAT)
            SET_BITS(ctx->TriangleCaps, DD_FLATSHADE);
         else
            CLEAR_BITS(ctx->TriangleCaps, DD_FLATSHADE);
         ctx->NewState |= NEW_RASTER_OPS;
         if (ctx->Driver.ShadeModel) 
            (*ctx->Driver.ShadeModel)( ctx, mode );
      }
   }
   else {
      gl_error( ctx, GL_INVALID_ENUM, "glShadeModel" );
   }
}



void
_mesa_Lightf( GLenum light, GLenum pname, GLfloat param )
{
   _mesa_Lightfv( light, pname, &param );
}


void
_mesa_Lightfv( GLenum light, GLenum pname, const GLfloat *params )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint l;
   GLint nParams;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glLight");

   l = (GLint) (light - GL_LIGHT0);

   if (l < 0 || l >= MAX_LIGHTS) {
      gl_error( ctx, GL_INVALID_ENUM, "glLight" );
      return;
   }

   switch (pname) {
      case GL_AMBIENT:
         COPY_4V( ctx->Light.Light[l].Ambient, params );
         nParams = 4;
         break;
      case GL_DIFFUSE:
         COPY_4V( ctx->Light.Light[l].Diffuse, params );
         nParams = 4;
         break;
      case GL_SPECULAR:
         COPY_4V( ctx->Light.Light[l].Specular, params );
         nParams = 4;
         break;
      case GL_POSITION:
	 /* transform position by ModelView matrix */
	 TRANSFORM_POINT( ctx->Light.Light[l].EyePosition, 
			  ctx->ModelView.m,
                          params );
         nParams = 4;
         break;
      case GL_SPOT_DIRECTION:
	 /* transform direction by inverse modelview */
	 if (ctx->ModelView.flags & MAT_DIRTY_INVERSE) {
	    gl_matrix_analyze( &ctx->ModelView );
	 }
	 TRANSFORM_NORMAL( ctx->Light.Light[l].EyeDirection,
			   params,
			   ctx->ModelView.inv );
         nParams = 3;
         break;
      case GL_SPOT_EXPONENT:
         if (params[0]<0.0 || params[0]>128.0) {
            gl_error( ctx, GL_INVALID_VALUE, "glLight" );
            return;
         }
         if (ctx->Light.Light[l].SpotExponent != params[0]) {
            ctx->Light.Light[l].SpotExponent = params[0];
            gl_compute_spot_exp_table( &ctx->Light.Light[l] );
         }
         nParams = 1;
         break;
      case GL_SPOT_CUTOFF:
         if ((params[0]<0.0 || params[0]>90.0) && params[0]!=180.0) {
            gl_error( ctx, GL_INVALID_VALUE, "glLight" );
            return;
         }
         ctx->Light.Light[l].SpotCutoff = params[0];
         ctx->Light.Light[l].CosCutoff = cos(params[0]*DEG2RAD);
         if (ctx->Light.Light[l].CosCutoff < 0) 
	    ctx->Light.Light[l].CosCutoff = 0;
         nParams = 1;
         break;
      case GL_CONSTANT_ATTENUATION:
         if (params[0]<0.0) {
            gl_error( ctx, GL_INVALID_VALUE, "glLight" );
            return;
         }
         ctx->Light.Light[l].ConstantAttenuation = params[0];
         nParams = 1;
         break;
      case GL_LINEAR_ATTENUATION:
         if (params[0]<0.0) {
            gl_error( ctx, GL_INVALID_VALUE, "glLight" );
            return;
         }
         ctx->Light.Light[l].LinearAttenuation = params[0];
         nParams = 1;
         break;
      case GL_QUADRATIC_ATTENUATION:
         if (params[0]<0.0) {
            gl_error( ctx, GL_INVALID_VALUE, "glLight" );
            return;
         }
         ctx->Light.Light[l].QuadraticAttenuation = params[0];
         nParams = 1;
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glLight" );
         return;
   }

   if (ctx->Driver.Lightfv)
      ctx->Driver.Lightfv( ctx, light, pname, params, nParams );

   ctx->NewState |= NEW_LIGHTING;
}


void
_mesa_Lighti( GLenum light, GLenum pname, GLint param )
{
   _mesa_Lightiv( light, pname, &param );
}


void
_mesa_Lightiv( GLenum light, GLenum pname, const GLint *params )
{
   GLfloat fparam[4];

   switch (pname) {
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_SPECULAR:
         fparam[0] = INT_TO_FLOAT( params[0] );
         fparam[1] = INT_TO_FLOAT( params[1] );
         fparam[2] = INT_TO_FLOAT( params[2] );
         fparam[3] = INT_TO_FLOAT( params[3] );
         break;
      case GL_POSITION:
         fparam[0] = (GLfloat) params[0];
         fparam[1] = (GLfloat) params[1];
         fparam[2] = (GLfloat) params[2];
         fparam[3] = (GLfloat) params[3];
         break;
      case GL_SPOT_DIRECTION:
         fparam[0] = (GLfloat) params[0];
         fparam[1] = (GLfloat) params[1];
         fparam[2] = (GLfloat) params[2];
         break;
      case GL_SPOT_EXPONENT:
      case GL_SPOT_CUTOFF:
      case GL_CONSTANT_ATTENUATION:
      case GL_LINEAR_ATTENUATION:
      case GL_QUADRATIC_ATTENUATION:
         fparam[0] = (GLfloat) params[0];
         break;
      default:
         /* error will be caught later in gl_Lightfv */
         ;
   }

   _mesa_Lightfv( light, pname, fparam );
}



void
_mesa_GetLightfv( GLenum light, GLenum pname, GLfloat *params )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint l = (GLint) (light - GL_LIGHT0);

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetLight");

   if (l<0 || l>=MAX_LIGHTS) {
      gl_error( ctx, GL_INVALID_ENUM, "glGetLightfv" );
      return;
   }

   switch (pname) {
      case GL_AMBIENT:
         COPY_4V( params, ctx->Light.Light[l].Ambient );
         break;
      case GL_DIFFUSE:
         COPY_4V( params, ctx->Light.Light[l].Diffuse );
         break;
      case GL_SPECULAR:
         COPY_4V( params, ctx->Light.Light[l].Specular );
         break;
      case GL_POSITION:
         COPY_4V( params, ctx->Light.Light[l].EyePosition );
         break;
      case GL_SPOT_DIRECTION:
         COPY_3V( params, ctx->Light.Light[l].EyeDirection );
         break;
      case GL_SPOT_EXPONENT:
         params[0] = ctx->Light.Light[l].SpotExponent;
         break;
      case GL_SPOT_CUTOFF:
         params[0] = ctx->Light.Light[l].SpotCutoff;
         break;
      case GL_CONSTANT_ATTENUATION:
         params[0] = ctx->Light.Light[l].ConstantAttenuation;
         break;
      case GL_LINEAR_ATTENUATION:
         params[0] = ctx->Light.Light[l].LinearAttenuation;
         break;
      case GL_QUADRATIC_ATTENUATION:
         params[0] = ctx->Light.Light[l].QuadraticAttenuation;
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetLightfv" );
         break;
   }
}



void
_mesa_GetLightiv( GLenum light, GLenum pname, GLint *params )
{
   GET_CURRENT_CONTEXT(ctx);
   GLint l = (GLint) (light - GL_LIGHT0);

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetLight");

   if (l<0 || l>=MAX_LIGHTS) {
      gl_error( ctx, GL_INVALID_ENUM, "glGetLightiv" );
      return;
   }

   switch (pname) {
      case GL_AMBIENT:
         params[0] = FLOAT_TO_INT(ctx->Light.Light[l].Ambient[0]);
         params[1] = FLOAT_TO_INT(ctx->Light.Light[l].Ambient[1]);
         params[2] = FLOAT_TO_INT(ctx->Light.Light[l].Ambient[2]);
         params[3] = FLOAT_TO_INT(ctx->Light.Light[l].Ambient[3]);
         break;
      case GL_DIFFUSE:
         params[0] = FLOAT_TO_INT(ctx->Light.Light[l].Diffuse[0]);
         params[1] = FLOAT_TO_INT(ctx->Light.Light[l].Diffuse[1]);
         params[2] = FLOAT_TO_INT(ctx->Light.Light[l].Diffuse[2]);
         params[3] = FLOAT_TO_INT(ctx->Light.Light[l].Diffuse[3]);
         break;
      case GL_SPECULAR:
         params[0] = FLOAT_TO_INT(ctx->Light.Light[l].Specular[0]);
         params[1] = FLOAT_TO_INT(ctx->Light.Light[l].Specular[1]);
         params[2] = FLOAT_TO_INT(ctx->Light.Light[l].Specular[2]);
         params[3] = FLOAT_TO_INT(ctx->Light.Light[l].Specular[3]);
         break;
      case GL_POSITION:
         params[0] = (GLint) ctx->Light.Light[l].EyePosition[0];
         params[1] = (GLint) ctx->Light.Light[l].EyePosition[1];
         params[2] = (GLint) ctx->Light.Light[l].EyePosition[2];
         params[3] = (GLint) ctx->Light.Light[l].EyePosition[3];
         break;
      case GL_SPOT_DIRECTION:
         params[0] = (GLint) ctx->Light.Light[l].EyeDirection[0];
         params[1] = (GLint) ctx->Light.Light[l].EyeDirection[1];
         params[2] = (GLint) ctx->Light.Light[l].EyeDirection[2];
         break;
      case GL_SPOT_EXPONENT:
         params[0] = (GLint) ctx->Light.Light[l].SpotExponent;
         break;
      case GL_SPOT_CUTOFF:
         params[0] = (GLint) ctx->Light.Light[l].SpotCutoff;
         break;
      case GL_CONSTANT_ATTENUATION:
         params[0] = (GLint) ctx->Light.Light[l].ConstantAttenuation;
         break;
      case GL_LINEAR_ATTENUATION:
         params[0] = (GLint) ctx->Light.Light[l].LinearAttenuation;
         break;
      case GL_QUADRATIC_ATTENUATION:
         params[0] = (GLint) ctx->Light.Light[l].QuadraticAttenuation;
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetLightiv" );
         break;
   }
}



/**********************************************************************/
/***                        Light Model                             ***/
/**********************************************************************/


void
_mesa_LightModelfv( GLenum pname, const GLfloat *params )
{
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glLightModelfv");

   switch (pname) {
      case GL_LIGHT_MODEL_AMBIENT:
         COPY_4V( ctx->Light.Model.Ambient, params );
         break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
         if (params[0]==0.0)
            ctx->Light.Model.LocalViewer = GL_FALSE;
         else
            ctx->Light.Model.LocalViewer = GL_TRUE;
         break;
      case GL_LIGHT_MODEL_TWO_SIDE:
         if (params[0]==0.0) 
            ctx->Light.Model.TwoSide = GL_FALSE;
         else
            ctx->Light.Model.TwoSide = GL_TRUE;
         break;
      case GL_LIGHT_MODEL_COLOR_CONTROL:
         if (params[0] == (GLfloat) GL_SINGLE_COLOR) {
            ctx->Light.Model.ColorControl = GL_SINGLE_COLOR;
            CLEAR_BITS(ctx->TriangleCaps, DD_SEPERATE_SPECULAR);
         }
         else if (params[0] == (GLfloat) GL_SEPARATE_SPECULAR_COLOR) {
            ctx->Light.Model.ColorControl = GL_SEPARATE_SPECULAR_COLOR;
	    SET_BITS(ctx->TriangleCaps, DD_SEPERATE_SPECULAR);
	 }
         else {
            gl_error( ctx, GL_INVALID_ENUM, "glLightModel(param)" );
         }
	 ctx->NewState |= NEW_RASTER_OPS;
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glLightModel" );
         break;
   }

   if (ctx->Driver.LightModelfv) 
      ctx->Driver.LightModelfv( ctx, pname, params );

   ctx->NewState |= NEW_LIGHTING;
}


void
_mesa_LightModeliv( GLenum pname, const GLint *params )
{
   GLfloat fparam[4];
   GET_CURRENT_CONTEXT(ctx);
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glLightModeliv");

   switch (pname) {
      case GL_LIGHT_MODEL_AMBIENT:
         fparam[0] = INT_TO_FLOAT( params[0] );
         fparam[1] = INT_TO_FLOAT( params[1] );
         fparam[2] = INT_TO_FLOAT( params[2] );
         fparam[3] = INT_TO_FLOAT( params[3] );
         break;
      case GL_LIGHT_MODEL_LOCAL_VIEWER:
      case GL_LIGHT_MODEL_TWO_SIDE:
      case GL_LIGHT_MODEL_COLOR_CONTROL:
         fparam[0] = (GLfloat) params[0];
         break;
      default:
         /* Error will be caught later in gl_LightModelfv */
         ;
   }
   _mesa_LightModelfv( pname, fparam );
}


void
_mesa_LightModeli( GLenum pname, GLint param )
{
   _mesa_LightModeliv( pname, &param );
}


void
_mesa_LightModelf( GLenum pname, GLfloat param )
{
   _mesa_LightModelfv( pname, &param );
}



/********** MATERIAL **********/


/*
 * Given a face and pname value (ala glColorMaterial), compute a bitmask
 * of the targeted material values.
 */
GLuint gl_material_bitmask( GLcontext *ctx, GLenum face, GLenum pname, 
			    GLuint legal,
			    const char *where )
{
   GLuint bitmask = 0;

   /* Make a bitmask indicating what material attribute(s) we're updating */
   switch (pname) {
      case GL_EMISSION:
         bitmask |= FRONT_EMISSION_BIT | BACK_EMISSION_BIT;
         break;
      case GL_AMBIENT:
         bitmask |= FRONT_AMBIENT_BIT | BACK_AMBIENT_BIT;
         break;
      case GL_DIFFUSE:
         bitmask |= FRONT_DIFFUSE_BIT | BACK_DIFFUSE_BIT;
         break;
      case GL_SPECULAR:
         bitmask |= FRONT_SPECULAR_BIT | BACK_SPECULAR_BIT;
         break;
      case GL_SHININESS:
         bitmask |= FRONT_SHININESS_BIT | BACK_SHININESS_BIT;
         break;
      case GL_AMBIENT_AND_DIFFUSE:
         bitmask |= FRONT_AMBIENT_BIT | BACK_AMBIENT_BIT;
         bitmask |= FRONT_DIFFUSE_BIT | BACK_DIFFUSE_BIT;
         break;
      case GL_COLOR_INDEXES:
         bitmask |= FRONT_INDEXES_BIT  | BACK_INDEXES_BIT;
         break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, where );
         return 0;
   }

   if (face==GL_FRONT) {
      bitmask &= FRONT_MATERIAL_BITS;
   }
   else if (face==GL_BACK) {
      bitmask &= BACK_MATERIAL_BITS;
   }
   else if (face != GL_FRONT_AND_BACK) {
      gl_error( ctx, GL_INVALID_ENUM, where );
      return 0;
   }
   
   if (bitmask & ~legal) {
      gl_error( ctx, GL_INVALID_ENUM, where );
      return 0;
   }

   return bitmask;
}



/*
 * Check if the global material has to be updated with info that was
 * associated with a vertex via glMaterial.
 * This function is used when any material values get changed between
 * glBegin/glEnd either by calling glMaterial() or by calling glColor()
 * when GL_COLOR_MATERIAL is enabled.
 *
 * src[0] is front material, src[1] is back material
 *
 * KW: Added code here to keep the precomputed variables uptodate.
 *     This means we can use the faster shade functions when using
 *     GL_COLOR_MATERIAL, and we can also now use the precomputed 
 *     values in the slower shading functions, which further offsets
 *     the cost of doing this here.
 */
void gl_update_material( GLcontext *ctx, 
			 const struct gl_material src[2], 
			 GLuint bitmask )
{
   struct gl_light *light, *list = &ctx->Light.EnabledList;

   if (ctx->Light.ColorMaterialEnabled)
      bitmask &= ~ctx->Light.ColorMaterialBitmask;

   if (MESA_VERBOSE&VERBOSE_IMMEDIATE)
      fprintf(stderr, "gl_update_material, mask 0x%x\n", bitmask);

   if (!bitmask) 
      return;

   /* update material emission */
   if (bitmask & FRONT_EMISSION_BIT) {
      struct gl_material *mat = &ctx->Light.Material[0];
      COPY_4FV( mat->Emission, src[0].Emission );
   }
   if (bitmask & BACK_EMISSION_BIT) {
      struct gl_material *mat = &ctx->Light.Material[1];
      COPY_4FV( mat->Emission, src[1].Emission );
   }

   /* update material ambience */
   if (bitmask & FRONT_AMBIENT_BIT) {
      struct gl_material *mat = &ctx->Light.Material[0];
      COPY_4FV( mat->Ambient, src[0].Ambient );
      foreach (light, list) {
         SCALE_3V( light->MatAmbient[0], light->Ambient, src[0].Ambient);
      }
   }
   if (bitmask & BACK_AMBIENT_BIT) {
      struct gl_material *mat = &ctx->Light.Material[1];
      COPY_4FV( mat->Ambient, src[1].Ambient );
      foreach (light, list) {
         SCALE_3V( light->MatAmbient[1], light->Ambient, src[1].Ambient);
      }
   }

   /* update BaseColor = emission + scene's ambience * material's ambience */
   if (bitmask & (FRONT_EMISSION_BIT | FRONT_AMBIENT_BIT)) {
      struct gl_material *mat = &ctx->Light.Material[0];
      COPY_3V( ctx->Light.BaseColor[0], mat->Emission );
      ACC_SCALE_3V( ctx->Light.BaseColor[0], mat->Ambient, ctx->Light.Model.Ambient );
   }
   if (bitmask & (BACK_EMISSION_BIT | BACK_AMBIENT_BIT)) {
      struct gl_material *mat = &ctx->Light.Material[1];
      COPY_3V( ctx->Light.BaseColor[1], mat->Emission );
      ACC_SCALE_3V( ctx->Light.BaseColor[1], mat->Ambient, ctx->Light.Model.Ambient );
   }

   /* update material diffuse values */
   if (bitmask & FRONT_DIFFUSE_BIT) {
      struct gl_material *mat = &ctx->Light.Material[0];
      GLfloat tmp[4];
      SUB_3V( tmp, src[0].Diffuse, mat->Diffuse );
      foreach (light, list) {
	 ACC_SCALE_3V( light->MatDiffuse[0], light->Diffuse, tmp );
      }
      COPY_4FV( mat->Diffuse, src[0].Diffuse );
      FLOAT_COLOR_TO_UBYTE_COLOR(ctx->Light.BaseAlpha[0], mat->Diffuse[3]);
   }
   if (bitmask & BACK_DIFFUSE_BIT) {
      struct gl_material *mat = &ctx->Light.Material[1];
      GLfloat tmp[4];
      SUB_3V( tmp, src[1].Diffuse, mat->Diffuse );
      foreach (light, list) {
	 ACC_SCALE_3V( light->MatDiffuse[1], light->Diffuse, tmp );
      }
      COPY_4FV( mat->Diffuse, src[1].Diffuse );
      FLOAT_COLOR_TO_UBYTE_COLOR(ctx->Light.BaseAlpha[1], mat->Diffuse[3]);
   }

   /* update material specular values */
   if (bitmask & FRONT_SPECULAR_BIT) {
      struct gl_material *mat = &ctx->Light.Material[0];
      GLfloat tmp[4];
      SUB_3V( tmp, src[0].Specular, mat->Specular );
      foreach (light, list) {
	 if (light->Flags & LIGHT_SPECULAR) {
	    ACC_SCALE_3V( light->MatSpecular[0], light->Specular, tmp );
	    light->IsMatSpecular[0] = 
	       (LEN_SQUARED_3FV(light->MatSpecular[0]) > 1e-16);
	 }
      }
      COPY_4FV( mat->Specular, src[0].Specular );
   }
   if (bitmask & BACK_SPECULAR_BIT) {
      struct gl_material *mat = &ctx->Light.Material[1];
      GLfloat tmp[4];
      SUB_3V( tmp, src[1].Specular, mat->Specular );
      foreach (light, list) {
	 if (light->Flags & LIGHT_SPECULAR) {
	    ACC_SCALE_3V( light->MatSpecular[1], light->Specular, tmp );
	    light->IsMatSpecular[1] = 
	       (LEN_SQUARED_3FV(light->MatSpecular[1]) > 1e-16);
	 }
      }
      COPY_4FV( mat->Specular, src[1].Specular );
   }

   if (bitmask & FRONT_SHININESS_BIT) {
      GLfloat shininess = ctx->Light.Material[0].Shininess = src[0].Shininess;
      gl_compute_shine_table( ctx, 0, shininess );
      gl_compute_shine_table( ctx, 2, shininess * .5 );
   }
   if (bitmask & BACK_SHININESS_BIT) {
      GLfloat shininess = ctx->Light.Material[1].Shininess = src[1].Shininess;
      gl_compute_shine_table( ctx, 1, shininess );
      gl_compute_shine_table( ctx, 3, shininess * .5 );
   }

   if (bitmask & FRONT_INDEXES_BIT) {
      ctx->Light.Material[0].AmbientIndex = src[0].AmbientIndex;
      ctx->Light.Material[0].DiffuseIndex = src[0].DiffuseIndex;
      ctx->Light.Material[0].SpecularIndex = src[0].SpecularIndex;
   }
   if (bitmask & BACK_INDEXES_BIT) {
      ctx->Light.Material[1].AmbientIndex = src[1].AmbientIndex;
      ctx->Light.Material[1].DiffuseIndex = src[1].DiffuseIndex;
      ctx->Light.Material[1].SpecularIndex = src[1].SpecularIndex;
   }

   if (0)
   {
      struct gl_material *mat = &ctx->Light.Material[0];
      fprintf(stderr, "update_mat  emission : %f %f %f\n",
	      mat->Emission[0],
	      mat->Emission[1],
	      mat->Emission[2]);
      fprintf(stderr, "update_mat  specular : %f %f %f\n",
	      mat->Specular[0],
	      mat->Specular[1],
	      mat->Specular[2]);
      fprintf(stderr, "update_mat  diffuse : %f %f %f\n",
	      mat->Diffuse[0],
	      mat->Diffuse[1],
	      mat->Diffuse[2]);
      fprintf(stderr, "update_mat  ambient : %f %f %f\n",
	      mat->Ambient[0],
	      mat->Ambient[1],
	      mat->Ambient[2]);
   }
}




/*
 * Update the current materials from the given rgba color
 * according to the bitmask in ColorMaterialBitmask, which is
 * set by glColorMaterial().
 */
void gl_update_color_material( GLcontext *ctx, 
			       const GLubyte rgba[4] )
{
   struct gl_light *light, *list = &ctx->Light.EnabledList;
   GLuint bitmask = ctx->Light.ColorMaterialBitmask;
   GLfloat color[4];

   UBYTE_RGBA_TO_FLOAT_RGBA( color, rgba );
   
   if (MESA_VERBOSE&VERBOSE_IMMEDIATE)
      fprintf(stderr, "gl_update_color_material, mask 0x%x\n", bitmask);

   /* update emissive colors */
   if (bitmask & FRONT_EMISSION_BIT) {
      struct gl_material *mat = &ctx->Light.Material[0];
      COPY_4FV( mat->Emission, color );
   }

   if (bitmask & BACK_EMISSION_BIT) {
      struct gl_material *mat = &ctx->Light.Material[1];
      COPY_4FV( mat->Emission, color );
   }

   /* update light->MatAmbient = light's ambient * material's ambient */
   if (bitmask & FRONT_AMBIENT_BIT) {
      struct gl_material *mat = &ctx->Light.Material[0];
      foreach (light, list) {
         SCALE_3V( light->MatAmbient[0], light->Ambient, color);
      }
      COPY_4FV( mat->Ambient, color );
   }

   if (bitmask & BACK_AMBIENT_BIT) {
      struct gl_material *mat = &ctx->Light.Material[1];
      foreach (light, list) {
         SCALE_3V( light->MatAmbient[1], light->Ambient, color);
      }
      COPY_4FV( mat->Ambient, color );
   }

   /* update BaseColor = emission + scene's ambience * material's ambience */
   if (bitmask & (FRONT_EMISSION_BIT | FRONT_AMBIENT_BIT)) {
      struct gl_material *mat = &ctx->Light.Material[0];
      COPY_3V( ctx->Light.BaseColor[0], mat->Emission );
      ACC_SCALE_3V( ctx->Light.BaseColor[0], mat->Ambient, ctx->Light.Model.Ambient );
   }

   if (bitmask & (BACK_EMISSION_BIT | BACK_AMBIENT_BIT)) {
      struct gl_material *mat = &ctx->Light.Material[1];
      COPY_3V( ctx->Light.BaseColor[1], mat->Emission );
      ACC_SCALE_3V( ctx->Light.BaseColor[1], mat->Ambient, ctx->Light.Model.Ambient );
   }

   /* update light->MatDiffuse = light's diffuse * material's diffuse */
   if (bitmask & FRONT_DIFFUSE_BIT) {
      struct gl_material *mat = &ctx->Light.Material[0];
      GLfloat tmp[4];
      SUB_3V( tmp, color, mat->Diffuse );
      foreach (light, list) {
	 ACC_SCALE_3V( light->MatDiffuse[0], light->Diffuse, tmp );
      }
      COPY_4FV( mat->Diffuse, color );
      FLOAT_COLOR_TO_UBYTE_COLOR(ctx->Light.BaseAlpha[0], mat->Diffuse[3]);
   }

   if (bitmask & BACK_DIFFUSE_BIT) {
      struct gl_material *mat = &ctx->Light.Material[1];
      GLfloat tmp[4];
      SUB_3V( tmp, color, mat->Diffuse );
      foreach (light, list) {
	 ACC_SCALE_3V( light->MatDiffuse[1], light->Diffuse, tmp );
      }
      COPY_4FV( mat->Diffuse, color );
      FLOAT_COLOR_TO_UBYTE_COLOR(ctx->Light.BaseAlpha[1], mat->Diffuse[3]);
   }

   /* update light->MatSpecular = light's specular * material's specular */
   if (bitmask & FRONT_SPECULAR_BIT) {
      struct gl_material *mat = &ctx->Light.Material[0];
      GLfloat tmp[4];
      SUB_3V( tmp, color, mat->Specular );
      foreach (light, list) {
	 if (light->Flags & LIGHT_SPECULAR) {
	    ACC_SCALE_3V( light->MatSpecular[0], light->Specular, tmp );
	    light->IsMatSpecular[0] = 
	       (LEN_SQUARED_3FV(light->MatSpecular[0]) > 1e-16);
	 }
      }
      COPY_4FV( mat->Specular, color );
   }

   if (bitmask & BACK_SPECULAR_BIT) {
      struct gl_material *mat = &ctx->Light.Material[1];
      GLfloat tmp[4];
      SUB_3V( tmp, color, mat->Specular );
      foreach (light, list) {
	 if (light->Flags & LIGHT_SPECULAR) {
	    ACC_SCALE_3V( light->MatSpecular[1], light->Specular, tmp );
	    light->IsMatSpecular[1] = 
	       (LEN_SQUARED_3FV(light->MatSpecular[1]) > 1e-16);
	 }
      }
      COPY_4FV( mat->Specular, color );
   }

   if (0)
   {
      struct gl_material *mat = &ctx->Light.Material[0];
      fprintf(stderr, "update_color_mat  emission : %f %f %f\n",
	      mat->Emission[0],
	      mat->Emission[1],
	      mat->Emission[2]);
      fprintf(stderr, "update_color_mat  specular : %f %f %f\n",
	      mat->Specular[0],
	      mat->Specular[1],
	      mat->Specular[2]);
      fprintf(stderr, "update_color_mat  diffuse : %f %f %f\n",
	      mat->Diffuse[0],
	      mat->Diffuse[1],
	      mat->Diffuse[2]);
      fprintf(stderr, "update_color_mat  ambient : %f %f %f\n",
	      mat->Ambient[0],
	      mat->Ambient[1],
	      mat->Ambient[2]);
   }
}




void
_mesa_ColorMaterial( GLenum face, GLenum mode )
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint bitmask;
   GLuint legal = (FRONT_EMISSION_BIT | BACK_EMISSION_BIT |
		   FRONT_SPECULAR_BIT | BACK_SPECULAR_BIT |
		   FRONT_DIFFUSE_BIT  | BACK_DIFFUSE_BIT  |
		   FRONT_AMBIENT_BIT  | BACK_AMBIENT_BIT);

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glColorMaterial");

   if (MESA_VERBOSE&VERBOSE_API) 
      fprintf(stderr, "glColorMaterial %s %s\n", 
	      gl_lookup_enum_by_nr(face),
	      gl_lookup_enum_by_nr(mode));

   bitmask = gl_material_bitmask( ctx, face, mode, legal, "glColorMaterial" );

   if (bitmask != 0) {
      ctx->Light.ColorMaterialBitmask = bitmask;
      ctx->Light.ColorMaterialFace = face;
      ctx->Light.ColorMaterialMode = mode;
   }

   if (ctx->Light.ColorMaterialEnabled)
      gl_update_color_material( ctx, ctx->Current.ByteColor );
}




void
_mesa_Materialf( GLenum face, GLenum pname, GLfloat param )
{
   _mesa_Materialfv( face, pname, &param );
}


/* KW:  This is now called directly (ie by name) from the glMaterial* 
 *      API functions.
 */
void
_mesa_Materialfv( GLenum face, GLenum pname, const GLfloat *params )
{
   GET_CURRENT_CONTEXT(ctx);
   struct immediate *IM;
   struct gl_material *mat;
   GLuint bitmask;
   GLuint count;

   bitmask = gl_material_bitmask( ctx, face, pname, ~0, "gl_Materialfv" );
   if (bitmask == 0)
      return;

   IM = ctx->input;
   count = IM->Count;

   if (!IM->Material) {
      IM->Material = 
	 (struct gl_material (*)[2]) MALLOC( sizeof(struct gl_material) * 
					     VB_SIZE * 2 );
      IM->MaterialMask = (GLuint *) MALLOC( sizeof(GLuint) * VB_SIZE );
   }


   if (!(IM->Flag[count] & VERT_MATERIAL)) {
      IM->Flag[count] |= VERT_MATERIAL;
      IM->MaterialMask[count] = 0;      
   }


   IM->MaterialMask[count] |= bitmask;
   mat = IM->Material[count];

   if (bitmask & FRONT_AMBIENT_BIT) {
      COPY_4FV( mat[0].Ambient, params );
   }
   if (bitmask & BACK_AMBIENT_BIT) {
      COPY_4FV( mat[1].Ambient, params );
   }
   if (bitmask & FRONT_DIFFUSE_BIT) {
      COPY_4FV( mat[0].Diffuse, params );
   }
   if (bitmask & BACK_DIFFUSE_BIT) {
      COPY_4FV( mat[1].Diffuse, params );
   }
   if (bitmask & FRONT_SPECULAR_BIT) {
      COPY_4FV( mat[0].Specular, params );
   }
   if (bitmask & BACK_SPECULAR_BIT) {
      COPY_4FV( mat[1].Specular, params );
   }
   if (bitmask & FRONT_EMISSION_BIT) {
      COPY_4FV( mat[0].Emission, params );
   }
   if (bitmask & BACK_EMISSION_BIT) {
      COPY_4FV( mat[1].Emission, params );
   }
   if (bitmask & FRONT_SHININESS_BIT) {
      GLfloat shininess = CLAMP( params[0], 0.0F, 128.0F );
      mat[0].Shininess = shininess;
   }
   if (bitmask & BACK_SHININESS_BIT) {
      GLfloat shininess = CLAMP( params[0], 0.0F, 128.0F );
      mat[1].Shininess = shininess;
   }
   if (bitmask & FRONT_INDEXES_BIT) {
      mat[0].AmbientIndex = params[0];
      mat[0].DiffuseIndex = params[1];
      mat[0].SpecularIndex = params[2];
   }
   if (bitmask & BACK_INDEXES_BIT) {
      mat[1].AmbientIndex = params[0];
      mat[1].DiffuseIndex = params[1];
      mat[1].SpecularIndex = params[2];
   }
}


void
_mesa_Materiali(GLenum face, GLenum pname, GLint param )
{
   _mesa_Materialiv(face, pname, &param);
}


void
_mesa_Materialiv(GLenum face, GLenum pname, const GLint *params )
{
   GLfloat fparam[4];
   switch (pname) {
      case GL_AMBIENT:
      case GL_DIFFUSE:
      case GL_SPECULAR:
      case GL_EMISSION:
      case GL_AMBIENT_AND_DIFFUSE:
         fparam[0] = INT_TO_FLOAT( params[0] );
         fparam[1] = INT_TO_FLOAT( params[1] );
         fparam[2] = INT_TO_FLOAT( params[2] );
         fparam[3] = INT_TO_FLOAT( params[3] );
         break;
      case GL_SHININESS:
         fparam[0] = (GLfloat) params[0];
         break;
      case GL_COLOR_INDEXES:
         fparam[0] = (GLfloat) params[0];
         fparam[1] = (GLfloat) params[1];
         fparam[2] = (GLfloat) params[2];
         break;
      default:
         /* Error will be caught later in gl_Materialfv */
         ;
   }
   _mesa_Materialfv(face, pname, fparam);
}


void
_mesa_GetMaterialfv( GLenum face, GLenum pname, GLfloat *params )
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint f;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetMaterialfv");

   if (face==GL_FRONT) {
      f = 0;
   }
   else if (face==GL_BACK) {
      f = 1;
   }
   else {
      gl_error( ctx, GL_INVALID_ENUM, "glGetMaterialfv(face)" );
      return;
   }
   switch (pname) {
      case GL_AMBIENT:
         COPY_4FV( params, ctx->Light.Material[f].Ambient );
         break;
      case GL_DIFFUSE:
         COPY_4FV( params, ctx->Light.Material[f].Diffuse );
	 break;
      case GL_SPECULAR:
         COPY_4FV( params, ctx->Light.Material[f].Specular );
	 break;
      case GL_EMISSION:
	 COPY_4FV( params, ctx->Light.Material[f].Emission );
	 break;
      case GL_SHININESS:
	 *params = ctx->Light.Material[f].Shininess;
	 break;
      case GL_COLOR_INDEXES:
	 params[0] = ctx->Light.Material[f].AmbientIndex;
	 params[1] = ctx->Light.Material[f].DiffuseIndex;
	 params[2] = ctx->Light.Material[f].SpecularIndex;
	 break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetMaterialfv(pname)" );
   }
}



void
_mesa_GetMaterialiv( GLenum face, GLenum pname, GLint *params )
{
   GET_CURRENT_CONTEXT(ctx);
   GLuint f;

   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx, "glGetMaterialiv");

   if (face==GL_FRONT) {
      f = 0;
   }
   else if (face==GL_BACK) {
      f = 1;
   }
   else {
      gl_error( ctx, GL_INVALID_ENUM, "glGetMaterialiv(face)" );
      return;
   }
   switch (pname) {
      case GL_AMBIENT:
         params[0] = FLOAT_TO_INT( ctx->Light.Material[f].Ambient[0] );
         params[1] = FLOAT_TO_INT( ctx->Light.Material[f].Ambient[1] );
         params[2] = FLOAT_TO_INT( ctx->Light.Material[f].Ambient[2] );
         params[3] = FLOAT_TO_INT( ctx->Light.Material[f].Ambient[3] );
         break;
      case GL_DIFFUSE:
         params[0] = FLOAT_TO_INT( ctx->Light.Material[f].Diffuse[0] );
         params[1] = FLOAT_TO_INT( ctx->Light.Material[f].Diffuse[1] );
         params[2] = FLOAT_TO_INT( ctx->Light.Material[f].Diffuse[2] );
         params[3] = FLOAT_TO_INT( ctx->Light.Material[f].Diffuse[3] );
	 break;
      case GL_SPECULAR:
         params[0] = FLOAT_TO_INT( ctx->Light.Material[f].Specular[0] );
         params[1] = FLOAT_TO_INT( ctx->Light.Material[f].Specular[1] );
         params[2] = FLOAT_TO_INT( ctx->Light.Material[f].Specular[2] );
         params[3] = FLOAT_TO_INT( ctx->Light.Material[f].Specular[3] );
	 break;
      case GL_EMISSION:
         params[0] = FLOAT_TO_INT( ctx->Light.Material[f].Emission[0] );
         params[1] = FLOAT_TO_INT( ctx->Light.Material[f].Emission[1] );
         params[2] = FLOAT_TO_INT( ctx->Light.Material[f].Emission[2] );
         params[3] = FLOAT_TO_INT( ctx->Light.Material[f].Emission[3] );
	 break;
      case GL_SHININESS:
         *params = ROUNDF( ctx->Light.Material[f].Shininess );
	 break;
      case GL_COLOR_INDEXES:
	 params[0] = ROUNDF( ctx->Light.Material[f].AmbientIndex );
	 params[1] = ROUNDF( ctx->Light.Material[f].DiffuseIndex );
	 params[2] = ROUNDF( ctx->Light.Material[f].SpecularIndex );
	 break;
      default:
         gl_error( ctx, GL_INVALID_ENUM, "glGetMaterialfv(pname)" );
   }
}




/**********************************************************************/
/*****                  Lighting computation                      *****/
/**********************************************************************/


/*
 * Notes:
 *   When two-sided lighting is enabled we compute the color (or index)
 *   for both the front and back side of the primitive.  Then, when the
 *   orientation of the facet is later learned, we can determine which
 *   color (or index) to use for rendering.
 *
 *   KW: We now know orientation in advance and only shade for 
 *       the side or sides which are actually required.
 *
 * Variables:
 *   n = normal vector
 *   V = vertex position
 *   P = light source position
 *   Pe = (0,0,0,1)
 *
 * Precomputed:
 *   IF P[3]==0 THEN
 *       // light at infinity
 *       IF local_viewer THEN
 *           VP_inf_norm = unit vector from V to P      // Precompute
 *       ELSE 
 *           // eye at infinity
 *           h_inf_norm = Normalize( VP + <0,0,1> )     // Precompute
 *       ENDIF
 *   ENDIF
 *
 * Functions:
 *   Normalize( v ) = normalized vector v
 *   Magnitude( v ) = length of vector v
 */



/*
 * Whenever the spotlight exponent for a light changes we must call
 * this function to recompute the exponent lookup table.
 */
void
gl_compute_spot_exp_table( struct gl_light *l )
{
   GLint i;
   GLdouble exponent = l->SpotExponent;
   GLdouble tmp = 0;
   GLint clamp = 0;

   l->SpotExpTable[0][0] = 0.0;

   for (i = EXP_TABLE_SIZE - 1; i > 0 ;i--) {
      if (clamp == 0) {
         tmp = pow(i / (GLdouble) (EXP_TABLE_SIZE - 1), exponent);
         if (tmp < FLT_MIN * 100.0) {
            tmp = 0.0;
            clamp = 1;
         }
      }
      l->SpotExpTable[i][0] = tmp;
   }
   for (i = 0; i < EXP_TABLE_SIZE - 1; i++) {
      l->SpotExpTable[i][1] = l->SpotExpTable[i+1][0] - l->SpotExpTable[i][0];
   }
   l->SpotExpTable[EXP_TABLE_SIZE-1][1] = 0.0;
}




/* Calculate a new shine table.  Doing this here saves a branch in
 * lighting, and the cost of doing it early may be partially offset
 * by keeping a MRU cache of shine tables for various shine values.
 */
static void
compute_shine_table( struct gl_shine_tab *tab, GLfloat shininess )
{
   GLint i;
   GLfloat *m = tab->tab;

   m[0] = 0.0;
   if (shininess == 0.0) {
      for (i = 1 ; i <= SHINE_TABLE_SIZE ; i++)
	 m[i] = 1.0;
   }
   else {
      for (i = 1 ; i < SHINE_TABLE_SIZE ; i++) {
	 GLdouble t = pow(i / (GLfloat) (SHINE_TABLE_SIZE - 1), shininess);
	 if (t > 1e-20)
            m[i] = t;
         else
            m[i] = 0.0;
      }      
      m[SHINE_TABLE_SIZE] = 1.0;
   }

   tab->shininess = shininess;
}


void
gl_compute_shine_table( GLcontext *ctx, GLuint i, GLfloat shininess )
{
#define DISTSQR(a,b) ((a-b)*(a-b))
   struct gl_shine_tab *list = ctx->ShineTabList;
   struct gl_shine_tab *s;

   foreach(s, list) 
      if ( DISTSQR(s->shininess, shininess) < 1e-4 ) 
	 break;

   if (s == list) {
      foreach(s, list) 
	 if (s->refcount == 0)
            break;

      compute_shine_table( s, shininess );
   }

   ctx->ShineTable[i]->refcount--;
   ctx->ShineTable[i] = s;
   move_to_tail( list, s );
   s->refcount++;
#undef DISTSQR
}



#if 0
static void
gl_reinit_light_attrib( GLcontext *ctx, struct gl_light_attrib *l )
{
   GLuint i;

   if (ctx->ShineTable[0]->shininess != l->Material[0].Shininess) {
      gl_compute_shine_table( ctx, 0, l->Material[0].Shininess );
      gl_compute_shine_table( ctx, 2, l->Material[0].Shininess * .5 );
   }

   if (ctx->ShineTable[1]->shininess != l->Material[1].Shininess) {
      gl_compute_shine_table( ctx, 1, l->Material[1].Shininess );
      gl_compute_shine_table( ctx, 3, l->Material[1].Shininess * .5 );
   }

   make_empty_list( &l->EnabledList );
   for (i = 0 ; i < MAX_LIGHTS ; i++) {
      if (l->Light[i].Enabled) 
	 insert_at_tail( &l->EnabledList, &l->Light[i] );
   }
}
#endif


/*
 * Examine current lighting parameters to determine if the optimized lighting
 * function can be used.
 * Also, precompute some lighting values such as the products of light
 * source and material ambient, diffuse and specular coefficients.
 */
void
gl_update_lighting( GLcontext *ctx )
{
   struct gl_light *light;

   ctx->Light.Flags = 0;

   foreach(light, &ctx->Light.EnabledList) {

      light->Flags = 0;

      if (light->EyePosition[3] != 0.0F) 
	 light->Flags |= LIGHT_POSITIONAL;
      
      if (LEN_SQUARED_3FV(light->Specular) > 1e-16) 
	 light->Flags |= LIGHT_SPECULAR;
      
      if (light->SpotCutoff != 180.0F)
	 light->Flags |= LIGHT_SPOT;

      ctx->Light.Flags |= light->Flags;
   }

   ctx->Light.NeedVertices = 
      ((ctx->Light.Flags & (LIGHT_POSITIONAL|LIGHT_SPOT)) ||
       (ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR) ||
       (ctx->Light.Model.LocalViewer && (ctx->Light.Flags & LIGHT_SPECULAR)));


   /* Precompute some shading values.
    */
   if (ctx->Visual->RGBAflag) {
      GLuint sides = ((ctx->TriangleCaps & DD_TRI_LIGHT_TWOSIDE) ? 2 : 1);
      GLuint side;
      for (side=0; side < sides; side++) {
	 struct gl_material *mat = &ctx->Light.Material[side];

	 COPY_3V(ctx->Light.BaseColor[side], mat->Emission);
	 ACC_SCALE_3V(ctx->Light.BaseColor[side], 
		      ctx->Light.Model.Ambient,
		      mat->Ambient);

	 FLOAT_COLOR_TO_UBYTE_COLOR(ctx->Light.BaseAlpha[side],
				    ctx->Light.Material[side].Diffuse[3] );
      }
      
      foreach (light, &ctx->Light.EnabledList) {	 
	 for (side=0; side< sides; side++) {
	    const struct gl_material *mat = &ctx->Light.Material[side];
	    SCALE_3V( light->MatDiffuse[side], light->Diffuse, mat->Diffuse );
	    SCALE_3V( light->MatAmbient[side], light->Ambient, mat->Ambient );
	    if (light->Flags & LIGHT_SPECULAR) {
	       SCALE_3V( light->MatSpecular[side], light->Specular,
			 mat->Specular);
	       light->IsMatSpecular[side] = 
		  (LEN_SQUARED_3FV(light->MatSpecular[side]) > 1e-16);
	    } 
	    else 
	       light->IsMatSpecular[side] = 0;
	 }
      }
   } 
   else {
      static const GLfloat ci[3] = { .30, .59, .11 };
      foreach(light, &ctx->Light.EnabledList) {
	 light->dli = DOT3(ci, light->Diffuse);
	 light->sli = DOT3(ci, light->Specular);
      }
   }
}



/* Need to seriously restrict the circumstances under which these
 * calc's are performed.
 */
void
gl_compute_light_positions( GLcontext *ctx )
{
   struct gl_light *light;
   
   if (1 /*ctx->Light.NeedVertices && !ctx->Light.Model.LocalViewer*/) {
      static const GLfloat eye_z[3] = { 0, 0, 1 };
      if (ctx->NeedEyeCoords) {
	 COPY_3V( ctx->EyeZDir, eye_z );
      }
      else {
	 TRANSFORM_NORMAL( ctx->EyeZDir, eye_z, ctx->ModelView.m );
      }
   }

   foreach (light, &ctx->Light.EnabledList) {

      if (ctx->NeedEyeCoords) {
	 COPY_4FV( light->Position, light->EyePosition );
      }
      else {
	 TRANSFORM_POINT( light->Position, ctx->ModelView.inv, 
			  light->EyePosition );
      }

      if (!(light->Flags & LIGHT_POSITIONAL)) {
	 /* VP (VP) = Normalize( Position ) */
	 COPY_3V( light->VP_inf_norm, light->Position );
	 NORMALIZE_3FV( light->VP_inf_norm );

	 if (!ctx->Light.Model.LocalViewer) {
	    /* h_inf_norm = Normalize( V_to_P + <0,0,1> ) */
	    ADD_3V( light->h_inf_norm, light->VP_inf_norm, ctx->EyeZDir);
	    NORMALIZE_3FV( light->h_inf_norm );
	 }
	 light->VP_inf_spot_attenuation = 1.0;
      }
      
      if (light->Flags & LIGHT_SPOT) {
	 if (ctx->NeedEyeNormals) {
	    COPY_3V( light->NormDirection, light->EyeDirection );
	 }
         else {
	    TRANSFORM_NORMAL( light->NormDirection, 
			      light->EyeDirection,
			      ctx->ModelView.m);
	 }

	 NORMALIZE_3FV( light->NormDirection );


	 /* Unlikely occurrance?
	  */
	 if (!(light->Flags & LIGHT_POSITIONAL)) {
	    GLfloat PV_dot_dir = - DOT3(light->VP_inf_norm, 
					light->NormDirection);

	    if (PV_dot_dir > light->CosCutoff) {
	       double x = PV_dot_dir * (EXP_TABLE_SIZE-1);
	       int k = (int) x;
	       light->VP_inf_spot_attenuation = 
		  (light->SpotExpTable[k][0] + 
		   (x-k)*light->SpotExpTable[k][1]);
	    }
	    else {
	       light->VP_inf_spot_attenuation = 0;
            }
	 }
      }
   }
}


void
gl_update_normal_transform( GLcontext *ctx )
{
   GLuint new_flag = 0;
   normal_func *last = ctx->NormalTransform;
   
   ctx->vb_rescale_factor = 1.0;

   if (ctx->NeedEyeCoords) {
      if (ctx->NeedNormals) {
	 GLuint transform = NORM_TRANSFORM_NO_ROT;

	 if (ctx->ModelView.flags & (MAT_FLAG_GENERAL |
				     MAT_FLAG_ROTATION |
				     MAT_FLAG_GENERAL_3D |
				     MAT_FLAG_PERSPECTIVE)) 
	    transform = NORM_TRANSFORM;

	    
	 new_flag = ctx->NewState & NEW_MODELVIEW;
	 ctx->vb_rescale_factor = ctx->rescale_factor;
	       
	 if (ctx->Transform.Normalize) {
	    ctx->NormalTransform = gl_normal_tab[transform | NORM_NORMALIZE];
	 } 
	 else if (ctx->Transform.RescaleNormals &&
		  ctx->rescale_factor != 1.0) {
	    ctx->NormalTransform = gl_normal_tab[transform | NORM_RESCALE];
	 }
	 else {
	    ctx->NormalTransform = gl_normal_tab[transform];
	 }
      }
      else {
	 ctx->NormalTransform = 0;
      }
   }
   else {
      if (ctx->NeedNormals) {
	 ctx->vb_rescale_factor = 1.0/ctx->rescale_factor;

	 if (ctx->Transform.Normalize) {
	    ctx->NormalTransform = gl_normal_tab[NORM_NORMALIZE];
	 }
	 else if (!ctx->Transform.RescaleNormals &&
		  ctx->rescale_factor != 1.0) {
	    ctx->NormalTransform = gl_normal_tab[NORM_RESCALE];
	 }
	 else {
	    ctx->NormalTransform = 0;
	 }
      }
      else {
	 ctx->NormalTransform = 0;
      }
   }

   if (last != ctx->NormalTransform || new_flag)
      ctx->NewState |= NEW_NORMAL_TRANSFORM;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.9.1
log
@OpenBSD just has imported exactly this tree into their vendor branch,
called the same tag, in XF4/xc
This is, apparently, the last XFree86 snapshot before the licence change
(ie, addition of the advertising clause)

Since the developers don't see any problems with that, and we would like
to integrate improvements done by the remaining one or two (or so) XFree86
developers (j/k), this prepares enabling us to update X-Window in the future.
@
text
@d4 4
a7 4
 * Version:  4.1
 *
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
 *
d14 1
a14 1
 *
d17 1
a17 1
 *
d27 3
a30 2
#include "imports.h"
#include "colormac.h"
d35 2
d39 4
a42 3
#include "mtypes.h"
#include "math/m_xform.h"
#include "math/m_matrix.h"
d55 1
a55 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d58 1
a58 1
      _mesa_debug(ctx, "glShadeModel %s\n", _mesa_lookup_enum_by_nr(mode));
d60 14
a73 3
   if (mode != GL_FLAT && mode != GL_SMOOTH) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glShadeModel" );
      return;
a74 9

   if (ctx->Light.ShadeModel == mode)
      return;

   FLUSH_VERTICES(ctx, _NEW_LIGHT);
   ctx->Light.ShadeModel = mode;
   ctx->_TriangleCaps ^= DD_FLATSHADE;
   if (ctx->Driver.ShadeModel)
      (*ctx->Driver.ShadeModel)( ctx, mode );
d90 4
a93 2
   GLint i = (GLint) (light - GL_LIGHT0);
   struct gl_light *l = &ctx->Light.Light[i];
d95 4
a98 2
   if (i < 0 || i >= (GLint) ctx->Const.MaxLights) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glLight(light=0x%x)", light );
d103 78
a180 106
   case GL_AMBIENT:
      if (TEST_EQ_4V(l->Ambient, params))
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      COPY_4V( l->Ambient, params );
      break;
   case GL_DIFFUSE:
      if (TEST_EQ_4V(l->Diffuse, params))
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      COPY_4V( l->Diffuse, params );
      break;
   case GL_SPECULAR:
      if (TEST_EQ_4V(l->Specular, params))
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      COPY_4V( l->Specular, params );
      break;
   case GL_POSITION: {
      GLfloat tmp[4];
      /* transform position by ModelView matrix */
      TRANSFORM_POINT( tmp, ctx->ModelviewMatrixStack.Top->m, params );
      if (TEST_EQ_4V(l->EyePosition, tmp))
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      COPY_4V(l->EyePosition, tmp);
      if (l->EyePosition[3] != 0.0F)
	 l->_Flags |= LIGHT_POSITIONAL;
      else
	 l->_Flags &= ~LIGHT_POSITIONAL;
      break;
   }
   case GL_SPOT_DIRECTION: {
      GLfloat tmp[4];
      /* transform direction by inverse modelview */
      if (ctx->ModelviewMatrixStack.Top->flags & MAT_DIRTY_INVERSE) {
	 _math_matrix_analyse( ctx->ModelviewMatrixStack.Top );
      }
      TRANSFORM_NORMAL( tmp, params, ctx->ModelviewMatrixStack.Top->inv );
      if (TEST_EQ_3V(l->EyeDirection, tmp))
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      COPY_3V(l->EyeDirection, tmp);
      break;
   }
   case GL_SPOT_EXPONENT:
      if (params[0]<0.0 || params[0]>128.0) {
	 _mesa_error( ctx, GL_INVALID_VALUE, "glLight" );
	 return;
      }
      if (l->SpotExponent == params[0])
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      l->SpotExponent = params[0];
      _mesa_invalidate_spot_exp_table( l );
      break;
   case GL_SPOT_CUTOFF:
      if ((params[0]<0.0 || params[0]>90.0) && params[0]!=180.0) {
	 _mesa_error( ctx, GL_INVALID_VALUE, "glLight" );
	 return;
      }
      if (l->SpotCutoff == params[0])
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      l->SpotCutoff = params[0];
      l->_CosCutoff = (GLfloat) _mesa_cos(params[0]*DEG2RAD);
      if (l->_CosCutoff < 0)
	 l->_CosCutoff = 0;
      if (l->SpotCutoff != 180.0F)
	 l->_Flags |= LIGHT_SPOT;
      else
	 l->_Flags &= ~LIGHT_SPOT;
      break;
   case GL_CONSTANT_ATTENUATION:
      if (params[0]<0.0) {
	 _mesa_error( ctx, GL_INVALID_VALUE, "glLight" );
	 return;
      }
      if (l->ConstantAttenuation == params[0])
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      l->ConstantAttenuation = params[0];
      break;
   case GL_LINEAR_ATTENUATION:
      if (params[0]<0.0) {
	 _mesa_error( ctx, GL_INVALID_VALUE, "glLight" );
	 return;
      }
      if (l->LinearAttenuation == params[0])
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      l->LinearAttenuation = params[0];
      break;
   case GL_QUADRATIC_ATTENUATION:
      if (params[0]<0.0) {
	 _mesa_error( ctx, GL_INVALID_VALUE, "glLight" );
	 return;
      }
      if (l->QuadraticAttenuation == params[0])
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      l->QuadraticAttenuation = params[0];
      break;
   default:
      _mesa_error( ctx, GL_INVALID_ENUM, "glLight(pname=0x%x)", pname );
      return;
d184 3
a186 1
      ctx->Driver.Lightfv( ctx, light, pname, params );
a243 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d245 4
a248 2
   if (l < 0 || l >= (GLint) ctx->Const.MaxLights) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetLightfv" );
d284 1
a284 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetLightfv" );
a295 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d297 4
a300 2
   if (l < 0 || l >= (GLint) ctx->Const.MaxLights) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetLightiv" );
d350 1
a350 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetLightiv" );
a364 2
   GLenum newenum;
   GLboolean newbool;
d366 1
a366 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a369 3
         if (TEST_EQ_4V( ctx->Light.Model.Ambient, params ))
	    return;
	 FLUSH_VERTICES(ctx, _NEW_LIGHT);
d373 4
a376 5
         newbool = (params[0]!=0.0);
	 if (ctx->Light.Model.LocalViewer == newbool)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_LIGHT);
	 ctx->Light.Model.LocalViewer = newbool;
d379 4
a382 10
         newbool = (params[0]!=0.0);
	 if (ctx->Light.Model.TwoSide == newbool)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_LIGHT);
	 ctx->Light.Model.TwoSide = newbool;

	 if (ctx->Light.Enabled && ctx->Light.Model.TwoSide)
	    ctx->_TriangleCaps |= DD_TRI_LIGHT_TWOSIDE;
	 else
	    ctx->_TriangleCaps &= ~DD_TRI_LIGHT_TWOSIDE;
d385 10
a394 8
         if (params[0] == (GLfloat) GL_SINGLE_COLOR)
	    newenum = GL_SINGLE_COLOR;
         else if (params[0] == (GLfloat) GL_SEPARATE_SPECULAR_COLOR)
	    newenum = GL_SEPARATE_SPECULAR_COLOR;
	 else {
            _mesa_error( ctx, GL_INVALID_ENUM, "glLightModel(param=0x0%x)",
                         (GLint) params[0] );
	    return;
d396 1
a396 12
	 if (ctx->Light.Model.ColorControl == newenum)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_LIGHT);
	 ctx->Light.Model.ColorControl = newenum;

	 if ((ctx->Light.Enabled &&
	      ctx->Light.Model.ColorControl==GL_SEPARATE_SPECULAR_COLOR)
	     || ctx->Fog.ColorSumEnabled)
	    ctx->_TriangleCaps |= DD_SEPARATE_SPECULAR;
	 else
	    ctx->_TriangleCaps &= ~DD_SEPARATE_SPECULAR;

d399 1
a399 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glLightModel(pname=0x%x)", pname );
d403 1
a403 1
   if (ctx->Driver.LightModelfv)
d405 2
d414 2
d459 3
a461 3
GLuint
_mesa_material_bitmask( GLcontext *ctx, GLenum face, GLenum pname,
                        GLuint legal, const char *where )
d490 1
a490 1
         _mesa_error( ctx, GL_INVALID_ENUM, where );
d501 1
a501 1
      _mesa_error( ctx, GL_INVALID_ENUM, where );
d504 1
a504 1

d506 1
a506 1
      _mesa_error( ctx, GL_INVALID_ENUM, where );
a513 48
/* Perform a straight copy between pairs of materials.
 */
void _mesa_copy_material_pairs( struct gl_material dst[2],
			     const struct gl_material src[2],
			     GLuint bitmask )
{
   if (bitmask & FRONT_EMISSION_BIT) {
      COPY_4FV( dst[0].Emission, src[0].Emission );
   }
   if (bitmask & BACK_EMISSION_BIT) {
      COPY_4FV( dst[1].Emission, src[1].Emission );
   }
   if (bitmask & FRONT_AMBIENT_BIT) {
      COPY_4FV( dst[0].Ambient, src[0].Ambient );
   }
   if (bitmask & BACK_AMBIENT_BIT) {
      COPY_4FV( dst[1].Ambient, src[1].Ambient );
   }
   if (bitmask & FRONT_DIFFUSE_BIT) {
      COPY_4FV( dst[0].Diffuse, src[0].Diffuse );
   }
   if (bitmask & BACK_DIFFUSE_BIT) {
      COPY_4FV( dst[1].Diffuse, src[1].Diffuse );
   }
   if (bitmask & FRONT_SPECULAR_BIT) {
      COPY_4FV( dst[0].Specular, src[0].Specular );
   }
   if (bitmask & BACK_SPECULAR_BIT) {
      COPY_4FV( dst[1].Specular, src[1].Specular );
   }
   if (bitmask & FRONT_SHININESS_BIT) {
      dst[0].Shininess = src[0].Shininess;
   }
   if (bitmask & BACK_SHININESS_BIT) {
      dst[1].Shininess = src[1].Shininess;
   }
   if (bitmask & FRONT_INDEXES_BIT) {
      dst[0].AmbientIndex = src[0].AmbientIndex;
      dst[0].DiffuseIndex = src[0].DiffuseIndex;
      dst[0].SpecularIndex = src[0].SpecularIndex;
   }
   if (bitmask & BACK_INDEXES_BIT) {
      dst[1].AmbientIndex = src[1].AmbientIndex;
      dst[1].DiffuseIndex = src[1].DiffuseIndex;
      dst[1].SpecularIndex = src[1].SpecularIndex;
   }
}

d524 5
a528 1
 * Additionally keeps the precomputed lighting state uptodate.
d530 2
a531 2
void _mesa_update_material( GLcontext *ctx,
			 const struct gl_material src[2],
d540 1
a540 1
      _mesa_debug(ctx, "_mesa_update_material, mask 0x%x\n", bitmask);
d542 1
a542 1
   if (!bitmask)
d560 1
a560 1
         SCALE_3V( light->_MatAmbient[0], light->Ambient, src[0].Ambient);
d567 1
a567 1
         SCALE_3V( light->_MatAmbient[1], light->Ambient, src[1].Ambient);
d574 2
a575 3
      COPY_3V( ctx->Light._BaseColor[0], mat->Emission );
      ACC_SCALE_3V( ctx->Light._BaseColor[0], mat->Ambient,
		    ctx->Light.Model.Ambient );
d579 2
a580 3
      COPY_3V( ctx->Light._BaseColor[1], mat->Emission );
      ACC_SCALE_3V( ctx->Light._BaseColor[1], mat->Ambient,
		    ctx->Light.Model.Ambient );
d586 2
a587 1
      COPY_4FV( mat->Diffuse, src[0].Diffuse );
d589 1
a589 1
	 SCALE_3V( light->_MatDiffuse[0], light->Diffuse, mat->Diffuse );
d591 2
d596 2
a597 1
      COPY_4FV( mat->Diffuse, src[1].Diffuse );
d599 1
a599 1
	 SCALE_3V( light->_MatDiffuse[1], light->Diffuse, mat->Diffuse );
d601 2
d608 2
a609 1
      COPY_4FV( mat->Specular, src[0].Specular );
d611 5
a615 1
	 SCALE_3V( light->_MatSpecular[0], light->Specular, mat->Specular);
d617 1
d621 2
a622 1
      COPY_4FV( mat->Specular, src[1].Specular );
d624 5
a628 1
	 SCALE_3V( light->_MatSpecular[1], light->Specular, mat->Specular);
d630 1
d634 3
a636 2
      ctx->Light.Material[0].Shininess = src[0].Shininess;
      _mesa_invalidate_shine_table( ctx, 0 );
d639 3
a641 2
      ctx->Light.Material[1].Shininess = src[1].Shininess;
      _mesa_invalidate_shine_table( ctx, 1 );
d655 2
a656 1
   if (0) {
d658 16
a673 8
      _mesa_debug(ctx, "update_mat  emission : %f %f %f\n",
                  mat->Emission[0], mat->Emission[1], mat->Emission[2]);
      _mesa_debug(ctx, "update_mat  specular : %f %f %f\n",
                  mat->Specular[0], mat->Specular[1], mat->Specular[2]);
      _mesa_debug(ctx, "update_mat  diffuse : %f %f %f\n",
                  mat->Diffuse[0], mat->Diffuse[1], mat->Diffuse[2]);
      _mesa_debug(ctx, "update_mat  ambient : %f %f %f\n",
                  mat->Ambient[0], mat->Ambient[1], mat->Ambient[2]);
a679 3



d685 2
a686 2
void _mesa_update_color_material( GLcontext *ctx,
				  const GLfloat color[4] )
d690 1
d692 2
d695 1
a695 1
      _mesa_debug(ctx, "_mesa_update_color_material, mask 0x%x\n", bitmask);
d708 1
a708 1
   /* update light->_MatAmbient = light's ambient * material's ambient */
d712 1
a712 1
         SCALE_3V( light->_MatAmbient[0], light->Ambient, color);
d720 1
a720 1
         SCALE_3V( light->_MatAmbient[1], light->Ambient, color);
d728 2
a729 2
      COPY_3V( ctx->Light._BaseColor[0], mat->Emission );
      ACC_SCALE_3V( ctx->Light._BaseColor[0], mat->Ambient, ctx->Light.Model.Ambient );
d734 2
a735 2
      COPY_3V( ctx->Light._BaseColor[1], mat->Emission );
      ACC_SCALE_3V( ctx->Light._BaseColor[1], mat->Ambient, ctx->Light.Model.Ambient );
d738 1
a738 1
   /* update light->_MatDiffuse = light's diffuse * material's diffuse */
d741 2
a742 1
      COPY_4FV( mat->Diffuse, color );
d744 1
a744 1
	 SCALE_3V( light->_MatDiffuse[0], light->Diffuse, mat->Diffuse );
d746 2
d752 2
a753 1
      COPY_4FV( mat->Diffuse, color );
d755 1
a755 1
	 SCALE_3V( light->_MatDiffuse[1], light->Diffuse, mat->Diffuse );
d757 2
d761 1
a761 1
   /* update light->_MatSpecular = light's specular * material's specular */
d764 2
a765 1
      COPY_4FV( mat->Specular, color );
d767 5
a771 1
	 ACC_SCALE_3V( light->_MatSpecular[0], light->Specular, mat->Specular);
d773 1
d778 2
a779 1
      COPY_4FV( mat->Specular, color );
d781 5
a785 1
	 ACC_SCALE_3V( light->_MatSpecular[1], light->Specular, mat->Specular);
d787 1
d790 2
a791 1
   if (0) {
d793 16
a808 8
      _mesa_debug(ctx, "update_color_mat  emission : %f %f %f\n",
                  mat->Emission[0], mat->Emission[1], mat->Emission[2]);
      _mesa_debug(ctx, "update_color_mat  specular : %f %f %f\n",
                  mat->Specular[0], mat->Specular[1], mat->Specular[2]);
      _mesa_debug(ctx, "update_color_mat  diffuse : %f %f %f\n",
                  mat->Diffuse[0], mat->Diffuse[1], mat->Diffuse[2]);
      _mesa_debug(ctx, "update_color_mat  ambient : %f %f %f\n",
                  mat->Ambient[0], mat->Ambient[1], mat->Ambient[2]);
a823 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d825 43
a867 10
   if (MESA_VERBOSE&VERBOSE_API)
      _mesa_debug(ctx, "glColorMaterial %s %s\n",
                  _mesa_lookup_enum_by_nr(face),
                  _mesa_lookup_enum_by_nr(mode));

   bitmask = _mesa_material_bitmask(ctx, face, mode, legal, "glColorMaterial");

   if (ctx->Light.ColorMaterialBitmask == bitmask &&
       ctx->Light.ColorMaterialFace == face &&
       ctx->Light.ColorMaterialMode == mode)
d870 8
a877 8
   FLUSH_VERTICES(ctx, _NEW_LIGHT);
   ctx->Light.ColorMaterialBitmask = bitmask;
   ctx->Light.ColorMaterialFace = face;
   ctx->Light.ColorMaterialMode = mode;

   if (ctx->Light.ColorMaterialEnabled) {
      FLUSH_CURRENT( ctx, 0 );
      _mesa_update_color_material(ctx,ctx->Current.Attrib[VERT_ATTRIB_COLOR0]);
d880 52
a931 2
   if (ctx->Driver.ColorMaterial)
      (*ctx->Driver.ColorMaterial)( ctx, face, mode );
d935 6
d942 29
d978 2
a979 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx); /* update materials */
d988 1
a988 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetMaterialfv(face)" );
d1013 1
a1013 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetMaterialfv(pname)" );
d1024 2
a1025 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx); /* update materials */
d1034 1
a1034 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetMaterialiv(face)" );
d1071 1
a1071 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetMaterialfv(pname)" );
d1090 1
a1090 1
 *   KW: We now know orientation in advance and only shade for
d1103 2
a1104 2
 *           _VP_inf_norm = unit vector from V to P      // Precompute
 *       ELSE
d1106 1
a1106 1
 *           _h_inf_norm = Normalize( VP + <0,0,1> )     // Precompute
d1122 1
a1122 6
_mesa_invalidate_spot_exp_table( struct gl_light *l )
{
   l->_SpotExpTable[0][0] = -1;
}

static void validate_spot_exp_table( struct gl_light *l )
d1129 1
a1129 1
   l->_SpotExpTable[0][0] = 0.0;
d1133 5
a1137 5
	 tmp = _mesa_pow(i / (GLdouble) (EXP_TABLE_SIZE - 1), exponent);
	 if (tmp < FLT_MIN * 100.0) {
	    tmp = 0.0;
	    clamp = 1;
	 }
d1139 1
a1139 1
      l->_SpotExpTable[i][0] = (GLfloat) tmp;
d1142 1
a1142 2
      l->_SpotExpTable[i][1] = (l->_SpotExpTable[i+1][0] -
				l->_SpotExpTable[i][0]);
d1144 1
a1144 1
   l->_SpotExpTable[EXP_TABLE_SIZE-1][1] = 0.0;
d1154 2
a1155 2
void
_mesa_invalidate_shine_table( GLcontext *ctx, GLuint i )
d1157 20
a1176 3
   if (ctx->_ShineTable[i])
      ctx->_ShineTable[i]->refcount--;
   ctx->_ShineTable[i] = 0;
d1179 3
a1181 1
static void validate_shine_table( GLcontext *ctx, GLuint i, GLfloat shininess )
d1183 2
a1184 1
   struct gl_shine_tab *list = ctx->_ShineTabList;
d1187 2
a1188 2
   foreach(s, list)
      if ( s->shininess == shininess )
d1192 1
a1192 4
      GLint j;
      GLfloat *m;

      foreach(s, list)
d1194 1
a1194 1
	    break;
d1196 1
a1196 21
      m = s->tab;
      m[0] = 0.0;
      if (shininess == 0.0) {
	 for (j = 1 ; j <= SHINE_TABLE_SIZE ; j++)
	    m[j] = 1.0;
      }
      else {
	 for (j = 1 ; j < SHINE_TABLE_SIZE ; j++) {
            GLdouble t, x = j / (GLfloat) (SHINE_TABLE_SIZE - 1);
            if (x < 0.005) /* underflow check */
               x = 0.005;
            t = _mesa_pow(x, shininess);
	    if (t > 1e-20)
	       m[j] = (GLfloat) t;
	    else
	       m[j] = 0.0;
	 }
	 m[SHINE_TABLE_SIZE] = 1.0;
      }

      s->shininess = shininess;
d1199 2
a1200 4
   if (ctx->_ShineTable[i])
      ctx->_ShineTable[i]->refcount--;

   ctx->_ShineTable[i] = s;
d1203 1
d1206 5
a1210 2
void
_mesa_validate_all_lighting_tables( GLcontext *ctx )
d1212 1
a1212 2
   GLint i;
   GLfloat shininess;
d1214 4
a1217 12
   shininess = ctx->Light.Material[0].Shininess;
   if (!ctx->_ShineTable[0] || ctx->_ShineTable[0]->shininess != shininess)
      validate_shine_table( ctx, 0, shininess );

   shininess = ctx->Light.Material[1].Shininess;
   if (!ctx->_ShineTable[1] || ctx->_ShineTable[1]->shininess != shininess)
      validate_shine_table( ctx, 1, shininess );

   for (i = 0 ; i < MAX_LIGHTS ; i++)
      if (ctx->Light.Light[i]._SpotExpTable[0][0] == -1)
	 validate_spot_exp_table( &ctx->Light.Light[i] );
}
d1219 4
d1224 7
d1240 1
a1240 1
_mesa_update_lighting( GLcontext *ctx )
a1242 3
   ctx->_NeedEyeCoords &= ~NEED_EYE_LIGHT;
   ctx->_NeedNormals &= ~NEED_NORMALS_LIGHT;
   ctx->Light._Flags = 0;
d1244 1
a1244 4
   if (!ctx->Light.Enabled)
      return;

   ctx->_NeedNormals |= NEED_NORMALS_LIGHT;
a1246 2
      ctx->Light._Flags |= light->_Flags;
   }
d1248 1
a1248 4
   ctx->Light._NeedVertices =
      ((ctx->Light._Flags & (LIGHT_POSITIONAL|LIGHT_SPOT)) ||
       ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR ||
       ctx->Light.Model.LocalViewer);
d1250 8
a1257 3
   if ((ctx->Light._Flags & LIGHT_POSITIONAL) ||
       ctx->Light.Model.LocalViewer)
      ctx->_NeedEyeCoords |= NEED_EYE_LIGHT;
d1259 2
d1262 4
a1265 6
   /* XXX: This test is overkill & needs to be fixed both for software and
    * hardware t&l drivers.  The above should be sufficient & should
    * be tested to verify this.
    */
   if (ctx->Light._NeedVertices)
      ctx->_NeedEyeCoords |= NEED_EYE_LIGHT;
d1268 1
a1268 4
   /* Precompute some shading values.  Although we reference
    * Light.Material here, we can get away without flushing
    * FLUSH_UPDATE_CURRENT, as when any outstanding material changes
    * are flushed, they will update the derived state at that time.
d1270 2
a1271 2
   if (ctx->Visual.rgbMode) {
      GLuint sides = ctx->Light.Model.TwoSide ? 2 : 1;
d1276 2
a1277 2
	 COPY_3V(ctx->Light._BaseColor[side], mat->Emission);
	 ACC_SCALE_3V(ctx->Light._BaseColor[side],
d1280 3
d1284 2
a1285 2

      foreach (light, &ctx->Light.EnabledList) {
d1288 10
a1297 4
	    SCALE_3V( light->_MatDiffuse[side], light->Diffuse, mat->Diffuse );
	    SCALE_3V( light->_MatAmbient[side], light->Ambient, mat->Ambient );
	    SCALE_3V( light->_MatSpecular[side], light->Specular,
		      mat->Specular);
d1300 1
a1300 1
   }
d1302 1
a1302 1
      static const GLfloat ci[3] = { .30F, .59F, .11F };
d1304 2
a1305 2
	 light->_dli = DOT3(ci, light->Diffuse);
	 light->_sli = DOT3(ci, light->Specular);
d1311 3
a1313 6
/* _NEW_MODELVIEW
 * _NEW_LIGHT
 * _TNL_NEW_NEED_EYE_COORDS
 *
 * Update on (_NEW_MODELVIEW | _NEW_LIGHT) when lighting is enabled.
 * Also update on lighting space changes.
d1316 1
a1316 1
_mesa_compute_light_positions( GLcontext *ctx )
d1319 9
a1327 10
   static const GLfloat eye_z[3] = { 0, 0, 1 };

   if (!ctx->Light.Enabled)
      return;

   if (ctx->_NeedEyeCoords) {
      COPY_3V( ctx->_EyeZDir, eye_z );
   }
   else {
      TRANSFORM_NORMAL( ctx->_EyeZDir, eye_z, ctx->ModelviewMatrixStack.Top->m );
d1332 2
a1333 2
      if (ctx->_NeedEyeCoords) {
	 COPY_4FV( light->_Position, light->EyePosition );
d1336 1
a1336 1
	 TRANSFORM_POINT( light->_Position, ctx->ModelviewMatrixStack.Top->inv,
d1340 1
a1340 1
      if (!(light->_Flags & LIGHT_POSITIONAL)) {
d1342 2
a1343 2
	 COPY_3V( light->_VP_inf_norm, light->_Position );
	 NORMALIZE_3FV( light->_VP_inf_norm );
d1346 3
a1348 3
	    /* _h_inf_norm = Normalize( V_to_P + <0,0,1> ) */
	    ADD_3V( light->_h_inf_norm, light->_VP_inf_norm, ctx->_EyeZDir);
	    NORMALIZE_3FV( light->_h_inf_norm );
d1350 1
a1350 1
	 light->_VP_inf_spot_attenuation = 1.0;
d1352 4
a1355 4

      if (light->_Flags & LIGHT_SPOT) {
	 if (ctx->_NeedEyeCoords) {
	    COPY_3V( light->_NormDirection, light->EyeDirection );
d1358 1
a1358 1
	    TRANSFORM_NORMAL( light->_NormDirection,
d1360 1
a1360 1
			      ctx->ModelviewMatrixStack.Top->m);
d1363 2
a1364 1
	 NORMALIZE_3FV( light->_NormDirection );
d1366 5
a1370 3
	 if (!(light->_Flags & LIGHT_POSITIONAL)) {
	    GLfloat PV_dot_dir = - DOT3(light->_VP_inf_norm,
					light->_NormDirection);
d1372 1
a1372 1
	    if (PV_dot_dir > light->_CosCutoff) {
d1375 3
a1377 3
	       light->_VP_inf_spot_attenuation =
		  (GLfloat) (light->_SpotExpTable[k][0] +
		   (x-k)*light->_SpotExpTable[k][1]);
d1380 1
a1380 1
	       light->_VP_inf_spot_attenuation = 0;
d1385 62
@


1.1.1.1
log
@Import OpenBSD 3.3 XF4 repository from CTM 3132 the first time
This finalizes starting an OpenBSD-mirabile (aka MirBSD) repository.

### MirBSD is:
# Copyright (c) 1982-2003 by Thorsten "mirabile" Glaser <x86@@ePost.de>
# Copyright  1968-2003  The authors of And contributors to UNIX, the
#       C Language, BSD/Berkeley Unix; 386BSD, NetBSD 1.1 and OpenBSD.
#
# Anyone who obtained a copy of this work is hereby permitted to freely use,
# distribute, modify, merge, sublicence, give away or sell it as long as the
# authors are given due credit and the following notice is retained:
#
# This work is provided "as is", with no explicit or implicit warranty what-
# soever. Use it only at your own risk. In no event may an author or contri-
# butor be held liable for any damage, directly or indirectly, that origina-
# ted through or is caused by creation or modification of this work.

MirBSD is my private tree. MirBSD does not differ very much from OpenBSD
and intentionally tracks OpenBSD. That's why it _is_ OpenBSD, just not the
official one. It's like with DarrenBSD.

At time of this writing, no advertising for MirBSD must be done,
because the advertising clause has not yet been sorted out.

http://templeofhate.com/tglaser/MirBSD/index.php
@
text
@@


1.1.1.2
log
@The X-Windowing System

Import XFree86 4.3 from OpenBSD by CTM, in the hope it's stable
@
text
@d4 4
a7 4
 * Version:  3.5
 *
 * Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.
 *
d14 1
a14 1
 *
d17 1
a17 1
 *
a30 1
#include "colormac.h"
d35 1
d39 3
a41 4
#include "mtypes.h"

#include "math/m_xform.h"
#include "math/m_matrix.h"
d55 1
a55 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d58 1
a58 1
      fprintf(stderr, "glShadeModel %s\n", _mesa_lookup_enum_by_nr(mode));
d60 14
a73 3
   if (mode != GL_FLAT && mode != GL_SMOOTH) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glShadeModel" );
      return;
a74 9

   if (ctx->Light.ShadeModel == mode)
      return;

   FLUSH_VERTICES(ctx, _NEW_LIGHT);
   ctx->Light.ShadeModel = mode;
   ctx->_TriangleCaps ^= DD_FLATSHADE;
   if (ctx->Driver.ShadeModel)
      (*ctx->Driver.ShadeModel)( ctx, mode );
d90 4
a93 2
   GLint i = (GLint) (light - GL_LIGHT0);
   struct gl_light *l = &ctx->Light.Light[i];
d95 4
a98 2
   if (i < 0 || i >= (GLint) ctx->Const.MaxLights) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glLight" );
d103 78
a180 106
   case GL_AMBIENT:
      if (TEST_EQ_4V(l->Ambient, params))
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      COPY_4V( l->Ambient, params );
      break;
   case GL_DIFFUSE:
      if (TEST_EQ_4V(l->Diffuse, params))
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      COPY_4V( l->Diffuse, params );
      break;
   case GL_SPECULAR:
      if (TEST_EQ_4V(l->Specular, params))
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      COPY_4V( l->Specular, params );
      break;
   case GL_POSITION: {
      GLfloat tmp[4];
      /* transform position by ModelView matrix */
      TRANSFORM_POINT( tmp, ctx->ModelView.m, params );
      if (TEST_EQ_4V(l->EyePosition, tmp))
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      COPY_4V(l->EyePosition, tmp);
      if (l->EyePosition[3] != 0.0F)
	 l->_Flags |= LIGHT_POSITIONAL;
      else
	 l->_Flags &= ~LIGHT_POSITIONAL;
      break;
   }
   case GL_SPOT_DIRECTION: {
      GLfloat tmp[4];
      /* transform direction by inverse modelview */
      if (ctx->ModelView.flags & MAT_DIRTY_INVERSE) {
	 _math_matrix_analyse( &ctx->ModelView );
      }
      TRANSFORM_NORMAL( tmp, params, ctx->ModelView.inv );
      if (TEST_EQ_3V(l->EyeDirection, tmp))
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      COPY_3V(l->EyeDirection, tmp);
      break;
   }
   case GL_SPOT_EXPONENT:
      if (params[0]<0.0 || params[0]>128.0) {
	 _mesa_error( ctx, GL_INVALID_VALUE, "glLight" );
	 return;
      }
      if (l->SpotExponent == params[0])
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      l->SpotExponent = params[0];
      _mesa_invalidate_spot_exp_table( l );
      break;
   case GL_SPOT_CUTOFF:
      if ((params[0]<0.0 || params[0]>90.0) && params[0]!=180.0) {
	 _mesa_error( ctx, GL_INVALID_VALUE, "glLight" );
	 return;
      }
      if (l->SpotCutoff == params[0])
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      l->SpotCutoff = params[0];
      l->_CosCutoff = (GLfloat) cos(params[0]*DEG2RAD);
      if (l->_CosCutoff < 0)
	 l->_CosCutoff = 0;
      if (l->SpotCutoff != 180.0F)
	 l->_Flags |= LIGHT_SPOT;
      else
	 l->_Flags &= ~LIGHT_SPOT;
      break;
   case GL_CONSTANT_ATTENUATION:
      if (params[0]<0.0) {
	 _mesa_error( ctx, GL_INVALID_VALUE, "glLight" );
	 return;
      }
      if (l->ConstantAttenuation == params[0])
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      l->ConstantAttenuation = params[0];
      break;
   case GL_LINEAR_ATTENUATION:
      if (params[0]<0.0) {
	 _mesa_error( ctx, GL_INVALID_VALUE, "glLight" );
	 return;
      }
      if (l->LinearAttenuation == params[0])
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      l->LinearAttenuation = params[0];
      break;
   case GL_QUADRATIC_ATTENUATION:
      if (params[0]<0.0) {
	 _mesa_error( ctx, GL_INVALID_VALUE, "glLight" );
	 return;
      }
      if (l->QuadraticAttenuation == params[0])
	 return;
      FLUSH_VERTICES(ctx, _NEW_LIGHT);
      l->QuadraticAttenuation = params[0];
      break;
   default:
      _mesa_error( ctx, GL_INVALID_ENUM, "glLight" );
      return;
d184 3
a186 1
      ctx->Driver.Lightfv( ctx, light, pname, params );
a243 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d245 4
a248 2
   if (l < 0 || l >= (GLint) ctx->Const.MaxLights) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetLightfv" );
d284 1
a284 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetLightfv" );
a295 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d297 4
a300 2
   if (l < 0 || l >= (GLint) ctx->Const.MaxLights) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetLightiv" );
d350 1
a350 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetLightiv" );
a364 2
   GLenum newenum;
   GLboolean newbool;
d366 1
a366 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
a369 3
         if (TEST_EQ_4V( ctx->Light.Model.Ambient, params ))
	    return;
	 FLUSH_VERTICES(ctx, _NEW_LIGHT);
d373 4
a376 5
         newbool = (params[0]!=0.0);
	 if (ctx->Light.Model.LocalViewer == newbool)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_LIGHT);
	 ctx->Light.Model.LocalViewer = newbool;
d379 4
a382 10
         newbool = (params[0]!=0.0);
	 if (ctx->Light.Model.TwoSide == newbool)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_LIGHT);
	 ctx->Light.Model.TwoSide = newbool;

	 if (ctx->Light.Enabled && ctx->Light.Model.TwoSide)
	    ctx->_TriangleCaps |= DD_TRI_LIGHT_TWOSIDE;
	 else
	    ctx->_TriangleCaps &= ~DD_TRI_LIGHT_TWOSIDE;
d385 10
a394 7
         if (params[0] == (GLfloat) GL_SINGLE_COLOR)
	    newenum = GL_SINGLE_COLOR;
         else if (params[0] == (GLfloat) GL_SEPARATE_SPECULAR_COLOR)
	    newenum = GL_SEPARATE_SPECULAR_COLOR;
	 else {
            _mesa_error( ctx, GL_INVALID_ENUM, "glLightModel(param)" );
	    return;
d396 1
a396 12
	 if (ctx->Light.Model.ColorControl == newenum)
	    return;
	 FLUSH_VERTICES(ctx, _NEW_LIGHT);
	 ctx->Light.Model.ColorControl = newenum;

	 if ((ctx->Light.Enabled &&
	      ctx->Light.Model.ColorControl==GL_SEPARATE_SPECULAR_COLOR)
	     || ctx->Fog.ColorSumEnabled)
	    ctx->_TriangleCaps |= DD_SEPARATE_SPECULAR;
	 else
	    ctx->_TriangleCaps &= ~DD_SEPARATE_SPECULAR;

d399 1
a399 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glLightModel" );
d403 1
a403 1
   if (ctx->Driver.LightModelfv)
d405 2
d414 2
d459 3
a461 3
GLuint
_mesa_material_bitmask( GLcontext *ctx, GLenum face, GLenum pname,
                        GLuint legal, const char *where )
d490 1
a490 1
         _mesa_error( ctx, GL_INVALID_ENUM, where );
d501 1
a501 1
      _mesa_error( ctx, GL_INVALID_ENUM, where );
d504 1
a504 1

d506 1
a506 1
      _mesa_error( ctx, GL_INVALID_ENUM, where );
a513 48
/* Perform a straight copy between pairs of materials.
 */
void _mesa_copy_material_pairs( struct gl_material dst[2],
			     const struct gl_material src[2],
			     GLuint bitmask )
{
   if (bitmask & FRONT_EMISSION_BIT) {
      COPY_4FV( dst[0].Emission, src[0].Emission );
   }
   if (bitmask & BACK_EMISSION_BIT) {
      COPY_4FV( dst[1].Emission, src[1].Emission );
   }
   if (bitmask & FRONT_AMBIENT_BIT) {
      COPY_4FV( dst[0].Ambient, src[0].Ambient );
   }
   if (bitmask & BACK_AMBIENT_BIT) {
      COPY_4FV( dst[1].Ambient, src[1].Ambient );
   }
   if (bitmask & FRONT_DIFFUSE_BIT) {
      COPY_4FV( dst[0].Diffuse, src[0].Diffuse );
   }
   if (bitmask & BACK_DIFFUSE_BIT) {
      COPY_4FV( dst[1].Diffuse, src[1].Diffuse );
   }
   if (bitmask & FRONT_SPECULAR_BIT) {
      COPY_4FV( dst[0].Specular, src[0].Specular );
   }
   if (bitmask & BACK_SPECULAR_BIT) {
      COPY_4FV( dst[1].Specular, src[1].Specular );
   }
   if (bitmask & FRONT_SHININESS_BIT) {
      dst[0].Shininess = src[0].Shininess;
   }
   if (bitmask & BACK_SHININESS_BIT) {
      dst[1].Shininess = src[1].Shininess;
   }
   if (bitmask & FRONT_INDEXES_BIT) {
      dst[0].AmbientIndex = src[0].AmbientIndex;
      dst[0].DiffuseIndex = src[0].DiffuseIndex;
      dst[0].SpecularIndex = src[0].SpecularIndex;
   }
   if (bitmask & BACK_INDEXES_BIT) {
      dst[1].AmbientIndex = src[1].AmbientIndex;
      dst[1].DiffuseIndex = src[1].DiffuseIndex;
      dst[1].SpecularIndex = src[1].SpecularIndex;
   }
}

d524 5
a528 1
 * Additionally keeps the precomputed lighting state uptodate.
d530 2
a531 2
void _mesa_update_material( GLcontext *ctx,
			 const struct gl_material src[2],
d540 1
a540 1
      fprintf(stderr, "_mesa_update_material, mask 0x%x\n", bitmask);
d542 1
a542 1
   if (!bitmask)
d560 1
a560 1
         SCALE_3V( light->_MatAmbient[0], light->Ambient, src[0].Ambient);
d567 1
a567 1
         SCALE_3V( light->_MatAmbient[1], light->Ambient, src[1].Ambient);
d574 2
a575 3
      COPY_3V( ctx->Light._BaseColor[0], mat->Emission );
      ACC_SCALE_3V( ctx->Light._BaseColor[0], mat->Ambient,
		    ctx->Light.Model.Ambient );
d579 2
a580 3
      COPY_3V( ctx->Light._BaseColor[1], mat->Emission );
      ACC_SCALE_3V( ctx->Light._BaseColor[1], mat->Ambient,
		    ctx->Light.Model.Ambient );
d586 2
a587 1
      COPY_4FV( mat->Diffuse, src[0].Diffuse );
d589 1
a589 1
	 SCALE_3V( light->_MatDiffuse[0], light->Diffuse, mat->Diffuse );
d591 2
d596 2
a597 1
      COPY_4FV( mat->Diffuse, src[1].Diffuse );
d599 1
a599 1
	 SCALE_3V( light->_MatDiffuse[1], light->Diffuse, mat->Diffuse );
d601 2
d608 2
a609 1
      COPY_4FV( mat->Specular, src[0].Specular );
d611 5
a615 1
	 SCALE_3V( light->_MatSpecular[0], light->Specular, mat->Specular);
d617 1
d621 2
a622 1
      COPY_4FV( mat->Specular, src[1].Specular );
d624 5
a628 1
	 SCALE_3V( light->_MatSpecular[1], light->Specular, mat->Specular);
d630 1
d634 3
a636 2
      ctx->Light.Material[0].Shininess = src[0].Shininess;
      _mesa_invalidate_shine_table( ctx, 0 );
d639 3
a641 2
      ctx->Light.Material[1].Shininess = src[1].Shininess;
      _mesa_invalidate_shine_table( ctx, 1 );
a679 3



d685 2
a686 2
void _mesa_update_color_material( GLcontext *ctx,
				  const GLfloat color[4] )
d690 1
d692 2
d695 1
a695 1
      fprintf(stderr, "_mesa_update_color_material, mask 0x%x\n", bitmask);
d708 1
a708 1
   /* update light->_MatAmbient = light's ambient * material's ambient */
d712 1
a712 1
         SCALE_3V( light->_MatAmbient[0], light->Ambient, color);
d720 1
a720 1
         SCALE_3V( light->_MatAmbient[1], light->Ambient, color);
d728 2
a729 2
      COPY_3V( ctx->Light._BaseColor[0], mat->Emission );
      ACC_SCALE_3V( ctx->Light._BaseColor[0], mat->Ambient, ctx->Light.Model.Ambient );
d734 2
a735 2
      COPY_3V( ctx->Light._BaseColor[1], mat->Emission );
      ACC_SCALE_3V( ctx->Light._BaseColor[1], mat->Ambient, ctx->Light.Model.Ambient );
d738 1
a738 1
   /* update light->_MatDiffuse = light's diffuse * material's diffuse */
d741 2
a742 1
      COPY_4FV( mat->Diffuse, color );
d744 1
a744 1
	 SCALE_3V( light->_MatDiffuse[0], light->Diffuse, mat->Diffuse );
d746 2
d752 2
a753 1
      COPY_4FV( mat->Diffuse, color );
d755 1
a755 1
	 SCALE_3V( light->_MatDiffuse[1], light->Diffuse, mat->Diffuse );
d757 2
d761 1
a761 1
   /* update light->_MatSpecular = light's specular * material's specular */
d764 2
a765 1
      COPY_4FV( mat->Specular, color );
d767 5
a771 1
	 ACC_SCALE_3V( light->_MatSpecular[0], light->Specular, mat->Specular);
d773 1
d778 2
a779 1
      COPY_4FV( mat->Specular, color );
d781 5
a785 1
	 ACC_SCALE_3V( light->_MatSpecular[1], light->Specular, mat->Specular);
d787 1
a823 1
   ASSERT_OUTSIDE_BEGIN_END(ctx);
d825 43
a867 10
   if (MESA_VERBOSE&VERBOSE_API)
      fprintf(stderr, "glColorMaterial %s %s\n",
	      _mesa_lookup_enum_by_nr(face),
	      _mesa_lookup_enum_by_nr(mode));

   bitmask = _mesa_material_bitmask(ctx, face, mode, legal, "glColorMaterial");

   if (ctx->Light.ColorMaterialBitmask == bitmask &&
       ctx->Light.ColorMaterialFace == face &&
       ctx->Light.ColorMaterialMode == mode)
d870 8
a877 8
   FLUSH_VERTICES(ctx, _NEW_LIGHT);
   ctx->Light.ColorMaterialBitmask = bitmask;
   ctx->Light.ColorMaterialFace = face;
   ctx->Light.ColorMaterialMode = mode;

   if (ctx->Light.ColorMaterialEnabled) {
      FLUSH_CURRENT( ctx, 0 );
      _mesa_update_color_material( ctx, ctx->Current.Color );
d880 52
a931 2
   if (ctx->Driver.ColorMaterial)
      (*ctx->Driver.ColorMaterial)( ctx, face, mode );
d935 6
d942 29
d978 2
a979 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx); /* update materials */
d988 1
a988 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetMaterialfv(face)" );
d1013 1
a1013 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetMaterialfv(pname)" );
d1024 2
a1025 1
   ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx); /* update materials */
d1034 1
a1034 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glGetMaterialiv(face)" );
d1071 1
a1071 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glGetMaterialfv(pname)" );
d1090 1
a1090 1
 *   KW: We now know orientation in advance and only shade for
d1103 2
a1104 2
 *           _VP_inf_norm = unit vector from V to P      // Precompute
 *       ELSE
d1106 1
a1106 1
 *           _h_inf_norm = Normalize( VP + <0,0,1> )     // Precompute
d1122 1
a1122 6
_mesa_invalidate_spot_exp_table( struct gl_light *l )
{
   l->_SpotExpTable[0][0] = -1;
}

static void validate_spot_exp_table( struct gl_light *l )
d1129 1
a1129 1
   l->_SpotExpTable[0][0] = 0.0;
d1133 5
a1137 5
	 tmp = pow(i / (GLdouble) (EXP_TABLE_SIZE - 1), exponent);
	 if (tmp < FLT_MIN * 100.0) {
	    tmp = 0.0;
	    clamp = 1;
	 }
d1139 1
a1139 1
      l->_SpotExpTable[i][0] = (GLfloat) tmp;
d1142 1
a1142 2
      l->_SpotExpTable[i][1] = (l->_SpotExpTable[i+1][0] -
				l->_SpotExpTable[i][0]);
d1144 1
a1144 1
   l->_SpotExpTable[EXP_TABLE_SIZE-1][1] = 0.0;
d1154 2
a1155 2
void
_mesa_invalidate_shine_table( GLcontext *ctx, GLuint i )
d1157 20
a1176 3
   if (ctx->_ShineTable[i])
      ctx->_ShineTable[i]->refcount--;
   ctx->_ShineTable[i] = 0;
d1179 3
a1181 1
static void validate_shine_table( GLcontext *ctx, GLuint i, GLfloat shininess )
d1183 2
a1184 1
   struct gl_shine_tab *list = ctx->_ShineTabList;
d1187 2
a1188 2
   foreach(s, list)
      if ( s->shininess == shininess )
d1192 1
a1192 4
      GLint j;
      GLfloat *m;

      foreach(s, list)
d1194 1
a1194 1
	    break;
d1196 1
a1196 21
      m = s->tab;
      m[0] = 0.0;
      if (shininess == 0.0) {
	 for (j = 1 ; j <= SHINE_TABLE_SIZE ; j++)
	    m[j] = 1.0;
      }
      else {
	 for (j = 1 ; j < SHINE_TABLE_SIZE ; j++) {
            GLdouble t, x = j / (GLfloat) (SHINE_TABLE_SIZE - 1);
            if (x < 0.005) /* underflow check */
               x = 0.005;
            t = pow(x, shininess);
	    if (t > 1e-20)
	       m[j] = (GLfloat) t;
	    else
	       m[j] = 0.0;
	 }
	 m[SHINE_TABLE_SIZE] = 1.0;
      }

      s->shininess = shininess;
d1199 2
a1200 4
   if (ctx->_ShineTable[i])
      ctx->_ShineTable[i]->refcount--;

   ctx->_ShineTable[i] = s;
d1203 1
d1206 5
a1210 2
void
_mesa_validate_all_lighting_tables( GLcontext *ctx )
d1212 1
a1212 2
   GLint i;
   GLfloat shininess;
d1214 4
a1217 12
   shininess = ctx->Light.Material[0].Shininess;
   if (!ctx->_ShineTable[0] || ctx->_ShineTable[0]->shininess != shininess)
      validate_shine_table( ctx, 0, shininess );

   shininess = ctx->Light.Material[1].Shininess;
   if (!ctx->_ShineTable[1] || ctx->_ShineTable[1]->shininess != shininess)
      validate_shine_table( ctx, 1, shininess );

   for (i = 0 ; i < MAX_LIGHTS ; i++)
      if (ctx->Light.Light[i]._SpotExpTable[0][0] == -1)
	 validate_spot_exp_table( &ctx->Light.Light[i] );
}
d1219 4
d1224 7
d1240 1
a1240 1
_mesa_update_lighting( GLcontext *ctx )
a1242 3
   ctx->_NeedEyeCoords &= ~NEED_EYE_LIGHT;
   ctx->_NeedNormals &= ~NEED_NORMALS_LIGHT;
   ctx->Light._Flags = 0;
d1244 1
a1244 4
   if (!ctx->Light.Enabled)
      return;

   ctx->_NeedNormals |= NEED_NORMALS_LIGHT;
a1246 2
      ctx->Light._Flags |= light->_Flags;
   }
d1248 1
a1248 4
   ctx->Light._NeedVertices =
      ((ctx->Light._Flags & (LIGHT_POSITIONAL|LIGHT_SPOT)) ||
       ctx->Light.Model.ColorControl == GL_SEPARATE_SPECULAR_COLOR ||
       ctx->Light.Model.LocalViewer);
d1250 8
a1257 3
   if ((ctx->Light._Flags & LIGHT_POSITIONAL) ||
       ctx->Light.Model.LocalViewer)
      ctx->_NeedEyeCoords |= NEED_EYE_LIGHT;
d1259 2
d1262 4
a1265 6
   /* XXX: This test is overkill & needs to be fixed both for software and
    * hardware t&l drivers.  The above should be sufficient & should
    * be tested to verify this.
    */
   if (ctx->Light._NeedVertices)
      ctx->_NeedEyeCoords |= NEED_EYE_LIGHT;
d1268 1
a1268 4
   /* Precompute some shading values.  Although we reference
    * Light.Material here, we can get away without flushing
    * FLUSH_UPDATE_CURRENT, as when any outstanding material changes
    * are flushed, they will update the derived state at that time.
d1270 2
a1271 2
   if (ctx->Visual.rgbMode) {
      GLuint sides = ctx->Light.Model.TwoSide ? 2 : 1;
d1276 2
a1277 2
	 COPY_3V(ctx->Light._BaseColor[side], mat->Emission);
	 ACC_SCALE_3V(ctx->Light._BaseColor[side],
d1280 3
d1284 2
a1285 2

      foreach (light, &ctx->Light.EnabledList) {
d1288 10
a1297 4
	    SCALE_3V( light->_MatDiffuse[side], light->Diffuse, mat->Diffuse );
	    SCALE_3V( light->_MatAmbient[side], light->Ambient, mat->Ambient );
	    SCALE_3V( light->_MatSpecular[side], light->Specular,
		      mat->Specular);
d1300 1
a1300 1
   }
d1302 1
a1302 1
      static const GLfloat ci[3] = { .30F, .59F, .11F };
d1304 2
a1305 2
	 light->_dli = DOT3(ci, light->Diffuse);
	 light->_sli = DOT3(ci, light->Specular);
d1311 3
a1313 6
/* _NEW_MODELVIEW
 * _NEW_LIGHT
 * _TNL_NEW_NEED_EYE_COORDS
 *
 * Update on (_NEW_MODELVIEW | _NEW_LIGHT) when lighting is enabled.
 * Also update on lighting space changes.
d1316 1
a1316 1
_mesa_compute_light_positions( GLcontext *ctx )
d1319 9
a1327 10
   static const GLfloat eye_z[3] = { 0, 0, 1 };

   if (!ctx->Light.Enabled)
      return;

   if (ctx->_NeedEyeCoords) {
      COPY_3V( ctx->_EyeZDir, eye_z );
   }
   else {
      TRANSFORM_NORMAL( ctx->_EyeZDir, eye_z, ctx->ModelView.m );
d1332 2
a1333 2
      if (ctx->_NeedEyeCoords) {
	 COPY_4FV( light->_Position, light->EyePosition );
d1336 1
a1336 1
	 TRANSFORM_POINT( light->_Position, ctx->ModelView.inv,
d1340 1
a1340 1
      if (!(light->_Flags & LIGHT_POSITIONAL)) {
d1342 2
a1343 2
	 COPY_3V( light->_VP_inf_norm, light->_Position );
	 NORMALIZE_3FV( light->_VP_inf_norm );
d1346 3
a1348 3
	    /* _h_inf_norm = Normalize( V_to_P + <0,0,1> ) */
	    ADD_3V( light->_h_inf_norm, light->_VP_inf_norm, ctx->_EyeZDir);
	    NORMALIZE_3FV( light->_h_inf_norm );
d1350 1
a1350 1
	 light->_VP_inf_spot_attenuation = 1.0;
d1352 4
a1355 4

      if (light->_Flags & LIGHT_SPOT) {
	 if (ctx->_NeedEyeCoords) {
	    COPY_3V( light->_NormDirection, light->EyeDirection );
d1358 1
a1358 1
	    TRANSFORM_NORMAL( light->_NormDirection,
d1363 2
a1364 1
	 NORMALIZE_3FV( light->_NormDirection );
d1366 5
a1370 3
	 if (!(light->_Flags & LIGHT_POSITIONAL)) {
	    GLfloat PV_dot_dir = - DOT3(light->_VP_inf_norm,
					light->_NormDirection);
d1372 1
a1372 1
	    if (PV_dot_dir > light->_CosCutoff) {
d1375 3
a1377 3
	       light->_VP_inf_spot_attenuation =
		  (GLfloat) (light->_SpotExpTable[k][0] +
		   (x-k)*light->_SpotExpTable[k][1]);
d1380 1
a1380 1
	       light->_VP_inf_spot_attenuation = 0;
d1385 62
@


1.1.1.3
log
@That's what OpenBSD will, probably, ship as XF4 in 3.5
their last sync against XFree86 4.3-current has been
imported into our vendor branch, too
@
text
@d4 1
a4 1
 * Version:  4.1
d6 1
a6 1
 * Copyright (C) 1999-2002  Brian Paul   All Rights Reserved.
d27 3
a30 1
#include "imports.h"
d36 1
d40 1
d43 1
d59 1
a59 1
      _mesa_debug(ctx, "glShadeModel %s\n", _mesa_lookup_enum_by_nr(mode));
d93 1
a93 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glLight(light=0x%x)", light );
d119 1
a119 1
      TRANSFORM_POINT( tmp, ctx->ModelviewMatrixStack.Top->m, params );
d133 2
a134 2
      if (ctx->ModelviewMatrixStack.Top->flags & MAT_DIRTY_INVERSE) {
	 _math_matrix_analyse( ctx->ModelviewMatrixStack.Top );
d136 1
a136 1
      TRANSFORM_NORMAL( tmp, params, ctx->ModelviewMatrixStack.Top->inv );
d163 1
a163 1
      l->_CosCutoff = (GLfloat) _mesa_cos(params[0]*DEG2RAD);
d202 1
a202 1
      _mesa_error( ctx, GL_INVALID_ENUM, "glLight(pname=0x%x)", pname );
d421 1
a421 2
            _mesa_error( ctx, GL_INVALID_ENUM, "glLightModel(param=0x0%x)",
                         (GLint) params[0] );
d438 1
a438 1
         _mesa_error( ctx, GL_INVALID_ENUM, "glLightModel(pname=0x%x)", pname );
d619 1
a619 1
      _mesa_debug(ctx, "_mesa_update_material, mask 0x%x\n", bitmask);
d716 2
a717 1
   if (0) {
d719 16
a734 8
      _mesa_debug(ctx, "update_mat  emission : %f %f %f\n",
                  mat->Emission[0], mat->Emission[1], mat->Emission[2]);
      _mesa_debug(ctx, "update_mat  specular : %f %f %f\n",
                  mat->Specular[0], mat->Specular[1], mat->Specular[2]);
      _mesa_debug(ctx, "update_mat  diffuse : %f %f %f\n",
                  mat->Diffuse[0], mat->Diffuse[1], mat->Diffuse[2]);
      _mesa_debug(ctx, "update_mat  ambient : %f %f %f\n",
                  mat->Ambient[0], mat->Ambient[1], mat->Ambient[2]);
d756 1
a756 1
      _mesa_debug(ctx, "_mesa_update_color_material, mask 0x%x\n", bitmask);
d833 2
a834 1
   if (0) {
d836 16
a851 8
      _mesa_debug(ctx, "update_color_mat  emission : %f %f %f\n",
                  mat->Emission[0], mat->Emission[1], mat->Emission[2]);
      _mesa_debug(ctx, "update_color_mat  specular : %f %f %f\n",
                  mat->Specular[0], mat->Specular[1], mat->Specular[2]);
      _mesa_debug(ctx, "update_color_mat  diffuse : %f %f %f\n",
                  mat->Diffuse[0], mat->Diffuse[1], mat->Diffuse[2]);
      _mesa_debug(ctx, "update_color_mat  ambient : %f %f %f\n",
                  mat->Ambient[0], mat->Ambient[1], mat->Ambient[2]);
d870 3
a872 3
      _mesa_debug(ctx, "glColorMaterial %s %s\n",
                  _mesa_lookup_enum_by_nr(face),
                  _mesa_lookup_enum_by_nr(mode));
d888 1
a888 1
      _mesa_update_color_material(ctx,ctx->Current.Attrib[VERT_ATTRIB_COLOR0]);
d1062 1
a1062 1
	 tmp = _mesa_pow(i / (GLdouble) (EXP_TABLE_SIZE - 1), exponent);
d1120 1
a1120 1
            t = _mesa_pow(x, shininess);
d1260 1
a1260 1
      TRANSFORM_NORMAL( ctx->_EyeZDir, eye_z, ctx->ModelviewMatrixStack.Top->m );
d1269 1
a1269 1
	 TRANSFORM_POINT( light->_Position, ctx->ModelviewMatrixStack.Top->inv,
d1293 1
a1293 1
			      ctx->ModelviewMatrixStack.Top->m);
@


